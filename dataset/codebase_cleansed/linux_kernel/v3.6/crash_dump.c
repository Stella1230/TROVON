ssize_t copy_oldmem_page(unsigned long pfn, char *buf,\r\nsize_t csize, unsigned long offset, int userbuf)\r\n{\r\nunsigned long src;\r\nif (!csize)\r\nreturn 0;\r\nsrc = (pfn << PAGE_SHIFT) + offset;\r\nif (src < OLDMEM_SIZE)\r\nsrc += OLDMEM_BASE;\r\nelse if (src > OLDMEM_BASE &&\r\nsrc < OLDMEM_BASE + OLDMEM_SIZE)\r\nsrc -= OLDMEM_BASE;\r\nif (userbuf)\r\ncopy_to_user_real((void __force __user *) buf, (void *) src,\r\ncsize);\r\nelse\r\nmemcpy_real(buf, (void *) src, csize);\r\nreturn csize;\r\n}\r\nint copy_from_oldmem(void *dest, void *src, size_t count)\r\n{\r\nunsigned long copied = 0;\r\nint rc;\r\nif ((unsigned long) src < OLDMEM_SIZE) {\r\ncopied = min(count, OLDMEM_SIZE - (unsigned long) src);\r\nrc = memcpy_real(dest, src + OLDMEM_BASE, copied);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn memcpy_real(dest + copied, src + copied, count - copied);\r\n}\r\nstatic void *kzalloc_panic(int len)\r\n{\r\nvoid *rc;\r\nrc = kzalloc(len, GFP_KERNEL);\r\nif (!rc)\r\npanic("s390 kdump kzalloc (%d) failed", len);\r\nreturn rc;\r\n}\r\nstatic struct mem_chunk *get_memory_layout(void)\r\n{\r\nstruct mem_chunk *chunk_array;\r\nchunk_array = kzalloc_panic(MEMORY_CHUNKS * sizeof(struct mem_chunk));\r\ndetect_memory_layout(chunk_array);\r\ncreate_mem_hole(chunk_array, OLDMEM_BASE, OLDMEM_SIZE, CHUNK_CRASHK);\r\nreturn chunk_array;\r\n}\r\nstatic void *nt_init(void *buf, Elf64_Word type, void *desc, int d_len,\r\nconst char *name)\r\n{\r\nElf64_Nhdr *note;\r\nu64 len;\r\nnote = (Elf64_Nhdr *)buf;\r\nnote->n_namesz = strlen(name) + 1;\r\nnote->n_descsz = d_len;\r\nnote->n_type = type;\r\nlen = sizeof(Elf64_Nhdr);\r\nmemcpy(buf + len, name, note->n_namesz);\r\nlen = roundup(len + note->n_namesz, 4);\r\nmemcpy(buf + len, desc, note->n_descsz);\r\nlen = roundup(len + note->n_descsz, 4);\r\nreturn PTR_ADD(buf, len);\r\n}\r\nstatic void *nt_prstatus(void *ptr, struct save_area *sa)\r\n{\r\nstruct elf_prstatus nt_prstatus;\r\nstatic int cpu_nr = 1;\r\nmemset(&nt_prstatus, 0, sizeof(nt_prstatus));\r\nmemcpy(&nt_prstatus.pr_reg.gprs, sa->gp_regs, sizeof(sa->gp_regs));\r\nmemcpy(&nt_prstatus.pr_reg.psw, sa->psw, sizeof(sa->psw));\r\nmemcpy(&nt_prstatus.pr_reg.acrs, sa->acc_regs, sizeof(sa->acc_regs));\r\nnt_prstatus.pr_pid = cpu_nr;\r\ncpu_nr++;\r\nreturn nt_init(ptr, NT_PRSTATUS, &nt_prstatus, sizeof(nt_prstatus),\r\n"CORE");\r\n}\r\nstatic void *nt_fpregset(void *ptr, struct save_area *sa)\r\n{\r\nelf_fpregset_t nt_fpregset;\r\nmemset(&nt_fpregset, 0, sizeof(nt_fpregset));\r\nmemcpy(&nt_fpregset.fpc, &sa->fp_ctrl_reg, sizeof(sa->fp_ctrl_reg));\r\nmemcpy(&nt_fpregset.fprs, &sa->fp_regs, sizeof(sa->fp_regs));\r\nreturn nt_init(ptr, NT_PRFPREG, &nt_fpregset, sizeof(nt_fpregset),\r\n"CORE");\r\n}\r\nstatic void *nt_s390_timer(void *ptr, struct save_area *sa)\r\n{\r\nreturn nt_init(ptr, NT_S390_TIMER, &sa->timer, sizeof(sa->timer),\r\nKEXEC_CORE_NOTE_NAME);\r\n}\r\nstatic void *nt_s390_tod_cmp(void *ptr, struct save_area *sa)\r\n{\r\nreturn nt_init(ptr, NT_S390_TODCMP, &sa->clk_cmp,\r\nsizeof(sa->clk_cmp), KEXEC_CORE_NOTE_NAME);\r\n}\r\nstatic void *nt_s390_tod_preg(void *ptr, struct save_area *sa)\r\n{\r\nreturn nt_init(ptr, NT_S390_TODPREG, &sa->tod_reg,\r\nsizeof(sa->tod_reg), KEXEC_CORE_NOTE_NAME);\r\n}\r\nstatic void *nt_s390_ctrs(void *ptr, struct save_area *sa)\r\n{\r\nreturn nt_init(ptr, NT_S390_CTRS, &sa->ctrl_regs,\r\nsizeof(sa->ctrl_regs), KEXEC_CORE_NOTE_NAME);\r\n}\r\nstatic void *nt_s390_prefix(void *ptr, struct save_area *sa)\r\n{\r\nreturn nt_init(ptr, NT_S390_PREFIX, &sa->pref_reg,\r\nsizeof(sa->pref_reg), KEXEC_CORE_NOTE_NAME);\r\n}\r\nvoid *fill_cpu_elf_notes(void *ptr, struct save_area *sa)\r\n{\r\nptr = nt_prstatus(ptr, sa);\r\nptr = nt_fpregset(ptr, sa);\r\nptr = nt_s390_timer(ptr, sa);\r\nptr = nt_s390_tod_cmp(ptr, sa);\r\nptr = nt_s390_tod_preg(ptr, sa);\r\nptr = nt_s390_ctrs(ptr, sa);\r\nptr = nt_s390_prefix(ptr, sa);\r\nreturn ptr;\r\n}\r\nstatic void *nt_prpsinfo(void *ptr)\r\n{\r\nstruct elf_prpsinfo prpsinfo;\r\nmemset(&prpsinfo, 0, sizeof(prpsinfo));\r\nprpsinfo.pr_sname = 'R';\r\nstrcpy(prpsinfo.pr_fname, "vmlinux");\r\nreturn nt_init(ptr, NT_PRPSINFO, &prpsinfo, sizeof(prpsinfo),\r\nKEXEC_CORE_NOTE_NAME);\r\n}\r\nstatic void *get_vmcoreinfo_old(unsigned long *size)\r\n{\r\nchar nt_name[11], *vmcoreinfo;\r\nElf64_Nhdr note;\r\nvoid *addr;\r\nif (copy_from_oldmem(&addr, &S390_lowcore.vmcore_info, sizeof(addr)))\r\nreturn NULL;\r\nmemset(nt_name, 0, sizeof(nt_name));\r\nif (copy_from_oldmem(&note, addr, sizeof(note)))\r\nreturn NULL;\r\nif (copy_from_oldmem(nt_name, addr + sizeof(note), sizeof(nt_name) - 1))\r\nreturn NULL;\r\nif (strcmp(nt_name, "VMCOREINFO") != 0)\r\nreturn NULL;\r\nvmcoreinfo = kzalloc_panic(note.n_descsz);\r\nif (copy_from_oldmem(vmcoreinfo, addr + 24, note.n_descsz))\r\nreturn NULL;\r\n*size = note.n_descsz;\r\nreturn vmcoreinfo;\r\n}\r\nstatic void *nt_vmcoreinfo(void *ptr)\r\n{\r\nunsigned long size;\r\nvoid *vmcoreinfo;\r\nvmcoreinfo = os_info_old_entry(OS_INFO_VMCOREINFO, &size);\r\nif (!vmcoreinfo)\r\nvmcoreinfo = get_vmcoreinfo_old(&size);\r\nif (!vmcoreinfo)\r\nreturn ptr;\r\nreturn nt_init(ptr, 0, vmcoreinfo, size, "VMCOREINFO");\r\n}\r\nstatic void *ehdr_init(Elf64_Ehdr *ehdr, int mem_chunk_cnt)\r\n{\r\nmemset(ehdr, 0, sizeof(*ehdr));\r\nmemcpy(ehdr->e_ident, ELFMAG, SELFMAG);\r\nehdr->e_ident[EI_CLASS] = ELFCLASS64;\r\nehdr->e_ident[EI_DATA] = ELFDATA2MSB;\r\nehdr->e_ident[EI_VERSION] = EV_CURRENT;\r\nmemset(ehdr->e_ident + EI_PAD, 0, EI_NIDENT - EI_PAD);\r\nehdr->e_type = ET_CORE;\r\nehdr->e_machine = EM_S390;\r\nehdr->e_version = EV_CURRENT;\r\nehdr->e_phoff = sizeof(Elf64_Ehdr);\r\nehdr->e_ehsize = sizeof(Elf64_Ehdr);\r\nehdr->e_phentsize = sizeof(Elf64_Phdr);\r\nehdr->e_phnum = mem_chunk_cnt + 1;\r\nreturn ehdr + 1;\r\n}\r\nstatic int get_cpu_cnt(void)\r\n{\r\nint i, cpus = 0;\r\nfor (i = 0; zfcpdump_save_areas[i]; i++) {\r\nif (zfcpdump_save_areas[i]->pref_reg == 0)\r\ncontinue;\r\ncpus++;\r\n}\r\nreturn cpus;\r\n}\r\nstatic int get_mem_chunk_cnt(void)\r\n{\r\nstruct mem_chunk *chunk_array, *mem_chunk;\r\nint i, cnt = 0;\r\nchunk_array = get_memory_layout();\r\nfor (i = 0; i < MEMORY_CHUNKS; i++) {\r\nmem_chunk = &chunk_array[i];\r\nif (chunk_array[i].type != CHUNK_READ_WRITE &&\r\nchunk_array[i].type != CHUNK_READ_ONLY)\r\ncontinue;\r\nif (mem_chunk->size == 0)\r\ncontinue;\r\ncnt++;\r\n}\r\nkfree(chunk_array);\r\nreturn cnt;\r\n}\r\nstatic inline unsigned long relocate(unsigned long addr)\r\n{\r\nreturn OLDMEM_BASE + addr;\r\n}\r\nstatic int loads_init(Elf64_Phdr *phdr, u64 loads_offset)\r\n{\r\nstruct mem_chunk *chunk_array, *mem_chunk;\r\nint i;\r\nchunk_array = get_memory_layout();\r\nfor (i = 0; i < MEMORY_CHUNKS; i++) {\r\nmem_chunk = &chunk_array[i];\r\nif (mem_chunk->size == 0)\r\nbreak;\r\nif (chunk_array[i].type != CHUNK_READ_WRITE &&\r\nchunk_array[i].type != CHUNK_READ_ONLY)\r\ncontinue;\r\nelse\r\nphdr->p_filesz = mem_chunk->size;\r\nphdr->p_type = PT_LOAD;\r\nphdr->p_offset = mem_chunk->addr;\r\nphdr->p_vaddr = mem_chunk->addr;\r\nphdr->p_paddr = mem_chunk->addr;\r\nphdr->p_memsz = mem_chunk->size;\r\nphdr->p_flags = PF_R | PF_W | PF_X;\r\nphdr->p_align = PAGE_SIZE;\r\nphdr++;\r\n}\r\nkfree(chunk_array);\r\nreturn i;\r\n}\r\nstatic void *notes_init(Elf64_Phdr *phdr, void *ptr, u64 notes_offset)\r\n{\r\nstruct save_area *sa;\r\nvoid *ptr_start = ptr;\r\nint i;\r\nptr = nt_prpsinfo(ptr);\r\nfor (i = 0; zfcpdump_save_areas[i]; i++) {\r\nsa = zfcpdump_save_areas[i];\r\nif (sa->pref_reg == 0)\r\ncontinue;\r\nptr = fill_cpu_elf_notes(ptr, sa);\r\n}\r\nptr = nt_vmcoreinfo(ptr);\r\nmemset(phdr, 0, sizeof(*phdr));\r\nphdr->p_type = PT_NOTE;\r\nphdr->p_offset = relocate(notes_offset);\r\nphdr->p_filesz = (unsigned long) PTR_SUB(ptr, ptr_start);\r\nphdr->p_memsz = phdr->p_filesz;\r\nreturn ptr;\r\n}\r\nstatic void s390_elf_corehdr_create(char **elfcorebuf, size_t *elfcorebuf_sz)\r\n{\r\nElf64_Phdr *phdr_notes, *phdr_loads;\r\nint mem_chunk_cnt;\r\nvoid *ptr, *hdr;\r\nu32 alloc_size;\r\nu64 hdr_off;\r\nmem_chunk_cnt = get_mem_chunk_cnt();\r\nalloc_size = 0x1000 + get_cpu_cnt() * 0x300 +\r\nmem_chunk_cnt * sizeof(Elf64_Phdr);\r\nhdr = kzalloc_panic(alloc_size);\r\nptr = ehdr_init(hdr, mem_chunk_cnt);\r\nphdr_notes = ptr;\r\nptr = PTR_ADD(ptr, sizeof(Elf64_Phdr));\r\nphdr_loads = ptr;\r\nptr = PTR_ADD(ptr, sizeof(Elf64_Phdr) * mem_chunk_cnt);\r\nhdr_off = PTR_DIFF(ptr, hdr);\r\nptr = notes_init(phdr_notes, ptr, ((unsigned long) hdr) + hdr_off);\r\nhdr_off = PTR_DIFF(ptr, hdr);\r\nloads_init(phdr_loads, ((unsigned long) hdr) + hdr_off);\r\n*elfcorebuf_sz = hdr_off;\r\n*elfcorebuf = (void *) relocate((unsigned long) hdr);\r\nBUG_ON(*elfcorebuf_sz > alloc_size);\r\n}\r\nstatic int setup_kdump_elfcorehdr(void)\r\n{\r\nsize_t elfcorebuf_sz;\r\nchar *elfcorebuf;\r\nif (!OLDMEM_BASE || is_kdump_kernel())\r\nreturn -EINVAL;\r\ns390_elf_corehdr_create(&elfcorebuf, &elfcorebuf_sz);\r\nelfcorehdr_addr = (unsigned long long) elfcorebuf;\r\nelfcorehdr_size = elfcorebuf_sz;\r\nreturn 0;\r\n}
