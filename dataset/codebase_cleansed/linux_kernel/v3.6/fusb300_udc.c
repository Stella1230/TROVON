static void fusb300_enable_bit(struct fusb300 *fusb300, u32 offset,\r\nu32 value)\r\n{\r\nu32 reg = ioread32(fusb300->reg + offset);\r\nreg |= value;\r\niowrite32(reg, fusb300->reg + offset);\r\n}\r\nstatic void fusb300_disable_bit(struct fusb300 *fusb300, u32 offset,\r\nu32 value)\r\n{\r\nu32 reg = ioread32(fusb300->reg + offset);\r\nreg &= ~value;\r\niowrite32(reg, fusb300->reg + offset);\r\n}\r\nstatic void fusb300_ep_setting(struct fusb300_ep *ep,\r\nstruct fusb300_ep_info info)\r\n{\r\nep->epnum = info.epnum;\r\nep->type = info.type;\r\n}\r\nstatic int fusb300_ep_release(struct fusb300_ep *ep)\r\n{\r\nif (!ep->epnum)\r\nreturn 0;\r\nep->epnum = 0;\r\nep->stall = 0;\r\nep->wedged = 0;\r\nreturn 0;\r\n}\r\nstatic void fusb300_set_fifo_entry(struct fusb300 *fusb300,\r\nu32 ep)\r\n{\r\nu32 val = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\r\nval &= ~FUSB300_EPSET1_FIFOENTRY_MSK;\r\nval |= FUSB300_EPSET1_FIFOENTRY(FUSB300_FIFO_ENTRY_NUM);\r\niowrite32(val, fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\r\n}\r\nstatic void fusb300_set_start_entry(struct fusb300 *fusb300,\r\nu8 ep)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\r\nu32 start_entry = fusb300->fifo_entry_num * FUSB300_FIFO_ENTRY_NUM;\r\nreg &= ~FUSB300_EPSET1_START_ENTRY_MSK ;\r\nreg |= FUSB300_EPSET1_START_ENTRY(start_entry);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\r\nif (fusb300->fifo_entry_num == FUSB300_MAX_FIFO_ENTRY) {\r\nfusb300->fifo_entry_num = 0;\r\nfusb300->addrofs = 0;\r\npr_err("fifo entry is over the maximum number!\n");\r\n} else\r\nfusb300->fifo_entry_num++;\r\n}\r\nstatic void fusb300_set_epaddrofs(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\r\nreg &= ~FUSB300_EPSET2_ADDROFS_MSK;\r\nreg |= FUSB300_EPSET2_ADDROFS(fusb300->addrofs);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\r\nfusb300->addrofs += (info.maxpacket + 7) / 8 * FUSB300_FIFO_ENTRY_NUM;\r\n}\r\nstatic void ep_fifo_setting(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nfusb300_set_fifo_entry(fusb300, info.epnum);\r\nfusb300_set_start_entry(fusb300, info.epnum);\r\nfusb300_set_epaddrofs(fusb300, info);\r\n}\r\nstatic void fusb300_set_eptype(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\nreg &= ~FUSB300_EPSET1_TYPE_MSK;\r\nreg |= FUSB300_EPSET1_TYPE(info.type);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\n}\r\nstatic void fusb300_set_epdir(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nu32 reg;\r\nif (!info.dir_in)\r\nreturn;\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\nreg &= ~FUSB300_EPSET1_DIR_MSK;\r\nreg |= FUSB300_EPSET1_DIRIN;\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\n}\r\nstatic void fusb300_set_ep_active(struct fusb300 *fusb300,\r\nu8 ep)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\r\nreg |= FUSB300_EPSET1_ACTEN;\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\r\n}\r\nstatic void fusb300_set_epmps(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\r\nreg &= ~FUSB300_EPSET2_MPS_MSK;\r\nreg |= FUSB300_EPSET2_MPS(info.maxpacket);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\r\n}\r\nstatic void fusb300_set_interval(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\nreg &= ~FUSB300_EPSET1_INTERVAL(0x7);\r\nreg |= FUSB300_EPSET1_INTERVAL(info.interval);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\n}\r\nstatic void fusb300_set_bwnum(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\nreg &= ~FUSB300_EPSET1_BWNUM(0x3);\r\nreg |= FUSB300_EPSET1_BWNUM(info.bw_num);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\r\n}\r\nstatic void set_ep_reg(struct fusb300 *fusb300,\r\nstruct fusb300_ep_info info)\r\n{\r\nfusb300_set_eptype(fusb300, info);\r\nfusb300_set_epdir(fusb300, info);\r\nfusb300_set_epmps(fusb300, info);\r\nif (info.interval)\r\nfusb300_set_interval(fusb300, info);\r\nif (info.bw_num)\r\nfusb300_set_bwnum(fusb300, info);\r\nfusb300_set_ep_active(fusb300, info.epnum);\r\n}\r\nstatic int config_ep(struct fusb300_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct fusb300 *fusb300 = ep->fusb300;\r\nstruct fusb300_ep_info info;\r\nep->ep.desc = desc;\r\ninfo.interval = 0;\r\ninfo.addrofs = 0;\r\ninfo.bw_num = 0;\r\ninfo.type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\ninfo.dir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;\r\ninfo.maxpacket = usb_endpoint_maxp(desc);\r\ninfo.epnum = desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\r\nif ((info.type == USB_ENDPOINT_XFER_INT) ||\r\n(info.type == USB_ENDPOINT_XFER_ISOC)) {\r\ninfo.interval = desc->bInterval;\r\nif (info.type == USB_ENDPOINT_XFER_ISOC)\r\ninfo.bw_num = ((desc->wMaxPacketSize & 0x1800) >> 11);\r\n}\r\nep_fifo_setting(fusb300, info);\r\nset_ep_reg(fusb300, info);\r\nfusb300_ep_setting(ep, info);\r\nfusb300->ep[info.epnum] = ep;\r\nreturn 0;\r\n}\r\nstatic int fusb300_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct fusb300_ep *ep;\r\nep = container_of(_ep, struct fusb300_ep, ep);\r\nif (ep->fusb300->reenum) {\r\nep->fusb300->fifo_entry_num = 0;\r\nep->fusb300->addrofs = 0;\r\nep->fusb300->reenum = 0;\r\n}\r\nreturn config_ep(ep, desc);\r\n}\r\nstatic int fusb300_disable(struct usb_ep *_ep)\r\n{\r\nstruct fusb300_ep *ep;\r\nstruct fusb300_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct fusb300_ep, ep);\r\nBUG_ON(!ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct fusb300_request, queue);\r\nspin_lock_irqsave(&ep->fusb300->lock, flags);\r\ndone(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->fusb300->lock, flags);\r\n}\r\nreturn fusb300_ep_release(ep);\r\n}\r\nstatic struct usb_request *fusb300_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct fusb300_request *req;\r\nreq = kzalloc(sizeof(struct fusb300_request), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void fusb300_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct fusb300_request *req;\r\nreq = container_of(_req, struct fusb300_request, req);\r\nkfree(req);\r\n}\r\nstatic int enable_fifo_int(struct fusb300_ep *ep)\r\n{\r\nstruct fusb300 *fusb300 = ep->fusb300;\r\nif (ep->epnum) {\r\nfusb300_enable_bit(fusb300, FUSB300_OFFSET_IGER0,\r\nFUSB300_IGER0_EEPn_FIFO_INT(ep->epnum));\r\n} else {\r\npr_err("can't enable_fifo_int ep0\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int disable_fifo_int(struct fusb300_ep *ep)\r\n{\r\nstruct fusb300 *fusb300 = ep->fusb300;\r\nif (ep->epnum) {\r\nfusb300_disable_bit(fusb300, FUSB300_OFFSET_IGER0,\r\nFUSB300_IGER0_EEPn_FIFO_INT(ep->epnum));\r\n} else {\r\npr_err("can't disable_fifo_int ep0\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fusb300_set_cxlen(struct fusb300 *fusb300, u32 length)\r\n{\r\nu32 reg;\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_CSR);\r\nreg &= ~FUSB300_CSR_LEN_MSK;\r\nreg |= FUSB300_CSR_LEN(length);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_CSR);\r\n}\r\nstatic void fusb300_wrcxf(struct fusb300_ep *ep,\r\nstruct fusb300_request *req)\r\n{\r\nint i = 0;\r\nu8 *tmp;\r\nu32 data;\r\nstruct fusb300 *fusb300 = ep->fusb300;\r\nu32 length = req->req.length - req->req.actual;\r\ntmp = req->req.buf + req->req.actual;\r\nif (length > SS_CTL_MAX_PACKET_SIZE) {\r\nfusb300_set_cxlen(fusb300, SS_CTL_MAX_PACKET_SIZE);\r\nfor (i = (SS_CTL_MAX_PACKET_SIZE >> 2); i > 0; i--) {\r\ndata = *tmp | *(tmp + 1) << 8 | *(tmp + 2) << 16 |\r\n*(tmp + 3) << 24;\r\niowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\r\ntmp += 4;\r\n}\r\nreq->req.actual += SS_CTL_MAX_PACKET_SIZE;\r\n} else {\r\nfusb300_set_cxlen(fusb300, length);\r\nfor (i = length >> 2; i > 0; i--) {\r\ndata = *tmp | *(tmp + 1) << 8 | *(tmp + 2) << 16 |\r\n*(tmp + 3) << 24;\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\niowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\r\ntmp = tmp + 4;\r\n}\r\nswitch (length % 4) {\r\ncase 1:\r\ndata = *tmp;\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\niowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\r\nbreak;\r\ncase 2:\r\ndata = *tmp | *(tmp + 1) << 8;\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\niowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\r\nbreak;\r\ncase 3:\r\ndata = *tmp | *(tmp + 1) << 8 | *(tmp + 2) << 16;\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\niowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreq->req.actual += length;\r\n}\r\n}\r\nstatic void fusb300_set_epnstall(struct fusb300 *fusb300, u8 ep)\r\n{\r\nfusb300_enable_bit(fusb300, FUSB300_OFFSET_EPSET0(ep),\r\nFUSB300_EPSET0_STL);\r\n}\r\nstatic void fusb300_clear_epnstall(struct fusb300 *fusb300, u8 ep)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET0(ep));\r\nif (reg & FUSB300_EPSET0_STL) {\r\nprintk(KERN_DEBUG "EP%d stall... Clear!!\n", ep);\r\nreg &= ~FUSB300_EPSET0_STL;\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET0(ep));\r\n}\r\n}\r\nstatic void ep0_queue(struct fusb300_ep *ep, struct fusb300_request *req)\r\n{\r\nif (ep->fusb300->ep0_dir) {\r\nif (req->req.length) {\r\nfusb300_wrcxf(ep, req);\r\n} else\r\nprintk(KERN_DEBUG "%s : req->req.length = 0x%x\n",\r\n__func__, req->req.length);\r\nif ((req->req.length == req->req.actual) ||\r\n(req->req.actual < ep->ep.maxpacket))\r\ndone(ep, req, 0);\r\n} else {\r\nif (!req->req.length)\r\ndone(ep, req, 0);\r\nelse\r\nfusb300_enable_bit(ep->fusb300, FUSB300_OFFSET_IGER1,\r\nFUSB300_IGER1_CX_OUT_INT);\r\n}\r\n}\r\nstatic int fusb300_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct fusb300_ep *ep;\r\nstruct fusb300_request *req;\r\nunsigned long flags;\r\nint request = 0;\r\nep = container_of(_ep, struct fusb300_ep, ep);\r\nreq = container_of(_req, struct fusb300_request, req);\r\nif (ep->fusb300->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&ep->fusb300->lock, flags);\r\nif (list_empty(&ep->queue))\r\nrequest = 1;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nreq->req.actual = 0;\r\nreq->req.status = -EINPROGRESS;\r\nif (ep->ep.desc == NULL)\r\nep0_queue(ep, req);\r\nelse if (request && !ep->stall)\r\nenable_fifo_int(ep);\r\nspin_unlock_irqrestore(&ep->fusb300->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fusb300_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct fusb300_ep *ep;\r\nstruct fusb300_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct fusb300_ep, ep);\r\nreq = container_of(_req, struct fusb300_request, req);\r\nspin_lock_irqsave(&ep->fusb300->lock, flags);\r\nif (!list_empty(&ep->queue))\r\ndone(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->fusb300->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fusb300_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedge)\r\n{\r\nstruct fusb300_ep *ep;\r\nstruct fusb300 *fusb300;\r\nunsigned long flags;\r\nint ret = 0;\r\nep = container_of(_ep, struct fusb300_ep, ep);\r\nfusb300 = ep->fusb300;\r\nspin_lock_irqsave(&ep->fusb300->lock, flags);\r\nif (!list_empty(&ep->queue)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nif (value) {\r\nfusb300_set_epnstall(fusb300, ep->epnum);\r\nep->stall = 1;\r\nif (wedge)\r\nep->wedged = 1;\r\n} else {\r\nfusb300_clear_epnstall(fusb300, ep->epnum);\r\nep->stall = 0;\r\nep->wedged = 0;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ep->fusb300->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fusb300_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn fusb300_set_halt_and_wedge(_ep, value, 0);\r\n}\r\nstatic int fusb300_set_wedge(struct usb_ep *_ep)\r\n{\r\nreturn fusb300_set_halt_and_wedge(_ep, 1, 1);\r\n}\r\nstatic void fusb300_fifo_flush(struct usb_ep *_ep)\r\n{\r\n}\r\nstatic void fusb300_clear_int(struct fusb300 *fusb300, u32 offset,\r\nu32 value)\r\n{\r\niowrite32(value, fusb300->reg + offset);\r\n}\r\nstatic void fusb300_reset(void)\r\n{\r\n}\r\nstatic void fusb300_set_cxstall(struct fusb300 *fusb300)\r\n{\r\nfusb300_enable_bit(fusb300, FUSB300_OFFSET_CSR,\r\nFUSB300_CSR_STL);\r\n}\r\nstatic void fusb300_set_cxdone(struct fusb300 *fusb300)\r\n{\r\nfusb300_enable_bit(fusb300, FUSB300_OFFSET_CSR,\r\nFUSB300_CSR_DONE);\r\n}\r\nvoid fusb300_rdcxf(struct fusb300 *fusb300,\r\nu8 *buffer, u32 length)\r\n{\r\nint i = 0;\r\nu8 *tmp;\r\nu32 data;\r\ntmp = buffer;\r\nfor (i = (length >> 2); i > 0; i--) {\r\ndata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\n*(tmp + 2) = (data >> 16) & 0xFF;\r\n*(tmp + 3) = (data >> 24) & 0xFF;\r\ntmp = tmp + 4;\r\n}\r\nswitch (length % 4) {\r\ncase 1:\r\ndata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\n*tmp = data & 0xFF;\r\nbreak;\r\ncase 2:\r\ndata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\nbreak;\r\ncase 3:\r\ndata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\r\nprintk(KERN_DEBUG " 0x%x\n", data);\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\n*(tmp + 2) = (data >> 16) & 0xFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void fusb300_rdfifo(struct fusb300_ep *ep,\r\nstruct fusb300_request *req,\r\nu32 length)\r\n{\r\nint i = 0;\r\nu8 *tmp;\r\nu32 data, reg;\r\nstruct fusb300 *fusb300 = ep->fusb300;\r\ntmp = req->req.buf + req->req.actual;\r\nreq->req.actual += length;\r\nif (req->req.actual > req->req.length)\r\nprintk(KERN_DEBUG "req->req.actual > req->req.length\n");\r\nfor (i = (length >> 2); i > 0; i--) {\r\ndata = ioread32(fusb300->reg +\r\nFUSB300_OFFSET_EPPORT(ep->epnum));\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\n*(tmp + 2) = (data >> 16) & 0xFF;\r\n*(tmp + 3) = (data >> 24) & 0xFF;\r\ntmp = tmp + 4;\r\n}\r\nswitch (length % 4) {\r\ncase 1:\r\ndata = ioread32(fusb300->reg +\r\nFUSB300_OFFSET_EPPORT(ep->epnum));\r\n*tmp = data & 0xFF;\r\nbreak;\r\ncase 2:\r\ndata = ioread32(fusb300->reg +\r\nFUSB300_OFFSET_EPPORT(ep->epnum));\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\nbreak;\r\ncase 3:\r\ndata = ioread32(fusb300->reg +\r\nFUSB300_OFFSET_EPPORT(ep->epnum));\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\n*(tmp + 2) = (data >> 16) & 0xFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndo {\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_IGR1);\r\nreg &= FUSB300_IGR1_SYNF0_EMPTY_INT;\r\nif (i)\r\nprintk(KERN_INFO "sync fifo is not empty!\n");\r\ni++;\r\n} while (!reg);\r\n}\r\nstatic u8 fusb300_get_epnstall(struct fusb300 *fusb300, u8 ep)\r\n{\r\nu8 value;\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET0(ep));\r\nvalue = reg & FUSB300_EPSET0_STL;\r\nreturn value;\r\n}\r\nstatic u8 fusb300_get_cxstall(struct fusb300 *fusb300)\r\n{\r\nu8 value;\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_CSR);\r\nvalue = (reg & FUSB300_CSR_STL) >> 1;\r\nreturn value;\r\n}\r\nstatic void request_error(struct fusb300 *fusb300)\r\n{\r\nfusb300_set_cxstall(fusb300);\r\nprintk(KERN_DEBUG "request error!!\n");\r\n}\r\nstatic void get_status(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\r\n__releases(fusb300->lock)\r\n__acquires(fusb300->lock)\r\n{\r\nu8 ep;\r\nu16 status = 0;\r\nu16 w_index = ctrl->wIndex;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nstatus = 1 << USB_DEVICE_SELF_POWERED;\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nstatus = 0;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = w_index & USB_ENDPOINT_NUMBER_MASK;\r\nif (ep) {\r\nif (fusb300_get_epnstall(fusb300, ep))\r\nstatus = 1 << USB_ENDPOINT_HALT;\r\n} else {\r\nif (fusb300_get_cxstall(fusb300))\r\nstatus = 0;\r\n}\r\nbreak;\r\ndefault:\r\nrequest_error(fusb300);\r\nreturn;\r\n}\r\nfusb300->ep0_data = cpu_to_le16(status);\r\nfusb300->ep0_req->buf = &fusb300->ep0_data;\r\nfusb300->ep0_req->length = 2;\r\nspin_unlock(&fusb300->lock);\r\nfusb300_queue(fusb300->gadget.ep0, fusb300->ep0_req, GFP_KERNEL);\r\nspin_lock(&fusb300->lock);\r\n}\r\nstatic void set_feature(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\r\n{\r\nu8 ep;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nfusb300_set_cxdone(fusb300);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nfusb300_set_cxdone(fusb300);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT: {\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nep = w_index & USB_ENDPOINT_NUMBER_MASK;\r\nif (ep)\r\nfusb300_set_epnstall(fusb300, ep);\r\nelse\r\nfusb300_set_cxstall(fusb300);\r\nfusb300_set_cxdone(fusb300);\r\n}\r\nbreak;\r\ndefault:\r\nrequest_error(fusb300);\r\nbreak;\r\n}\r\n}\r\nstatic void fusb300_clear_seqnum(struct fusb300 *fusb300, u8 ep)\r\n{\r\nfusb300_enable_bit(fusb300, FUSB300_OFFSET_EPSET0(ep),\r\nFUSB300_EPSET0_CLRSEQNUM);\r\n}\r\nstatic void clear_feature(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct fusb300_ep *ep =\r\nfusb300->ep[ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK];\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nfusb300_set_cxdone(fusb300);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nfusb300_set_cxdone(fusb300);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nif (ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK) {\r\nif (ep->wedged) {\r\nfusb300_set_cxdone(fusb300);\r\nbreak;\r\n}\r\nif (ep->stall) {\r\nep->stall = 0;\r\nfusb300_clear_seqnum(fusb300, ep->epnum);\r\nfusb300_clear_epnstall(fusb300, ep->epnum);\r\nif (!list_empty(&ep->queue))\r\nenable_fifo_int(ep);\r\n}\r\n}\r\nfusb300_set_cxdone(fusb300);\r\nbreak;\r\ndefault:\r\nrequest_error(fusb300);\r\nbreak;\r\n}\r\n}\r\nstatic void fusb300_set_dev_addr(struct fusb300 *fusb300, u16 addr)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_DAR);\r\nreg &= ~FUSB300_DAR_DRVADDR_MSK;\r\nreg |= FUSB300_DAR_DRVADDR(addr);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_DAR);\r\n}\r\nstatic void set_address(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\r\n{\r\nif (ctrl->wValue >= 0x0100)\r\nrequest_error(fusb300);\r\nelse {\r\nfusb300_set_dev_addr(fusb300, ctrl->wValue);\r\nfusb300_set_cxdone(fusb300);\r\n}\r\n}\r\nstatic int setup_packet(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\r\n{\r\nu8 *p = (u8 *)ctrl;\r\nu8 ret = 0;\r\nu8 i = 0;\r\nfusb300_rdcxf(fusb300, p, 8);\r\nfusb300->ep0_dir = ctrl->bRequestType & USB_DIR_IN;\r\nfusb300->ep0_length = ctrl->wLength;\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nget_status(fusb300, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nclear_feature(fusb300, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nset_feature(fusb300, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\nset_address(fusb300, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nfusb300_enable_bit(fusb300, FUSB300_OFFSET_DAR,\r\nFUSB300_DAR_SETCONFG);\r\nfor (i = 1; i <= FUSB300_MAX_NUM_EP; i++)\r\nfusb300_clear_seqnum(fusb300, i);\r\nfusb300->reenum = 1;\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\n} else\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic void done(struct fusb300_ep *ep, struct fusb300_request *req,\r\nint status)\r\n{\r\nlist_del_init(&req->queue);\r\nif (ep->fusb300->gadget.speed == USB_SPEED_UNKNOWN)\r\nreq->req.status = -ESHUTDOWN;\r\nelse\r\nreq->req.status = status;\r\nspin_unlock(&ep->fusb300->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&ep->fusb300->lock);\r\nif (ep->epnum) {\r\ndisable_fifo_int(ep);\r\nif (!list_empty(&ep->queue))\r\nenable_fifo_int(ep);\r\n} else\r\nfusb300_set_cxdone(ep->fusb300);\r\n}\r\nstatic void fusb300_fill_idma_prdtbl(struct fusb300_ep *ep, dma_addr_t d,\r\nu32 len)\r\n{\r\nu32 value;\r\nu32 reg;\r\ndo {\r\nreg = ioread32(ep->fusb300->reg +\r\nFUSB300_OFFSET_EPPRD_W0(ep->epnum));\r\nreg &= FUSB300_EPPRD0_H;\r\n} while (reg);\r\niowrite32(d, ep->fusb300->reg + FUSB300_OFFSET_EPPRD_W1(ep->epnum));\r\nvalue = FUSB300_EPPRD0_BTC(len) | FUSB300_EPPRD0_H |\r\nFUSB300_EPPRD0_F | FUSB300_EPPRD0_L | FUSB300_EPPRD0_I;\r\niowrite32(value, ep->fusb300->reg + FUSB300_OFFSET_EPPRD_W0(ep->epnum));\r\niowrite32(0x0, ep->fusb300->reg + FUSB300_OFFSET_EPPRD_W2(ep->epnum));\r\nfusb300_enable_bit(ep->fusb300, FUSB300_OFFSET_EPPRDRDY,\r\nFUSB300_EPPRDR_EP_PRD_RDY(ep->epnum));\r\n}\r\nstatic void fusb300_wait_idma_finished(struct fusb300_ep *ep)\r\n{\r\nu32 reg;\r\ndo {\r\nreg = ioread32(ep->fusb300->reg + FUSB300_OFFSET_IGR1);\r\nif ((reg & FUSB300_IGR1_VBUS_CHG_INT) ||\r\n(reg & FUSB300_IGR1_WARM_RST_INT) ||\r\n(reg & FUSB300_IGR1_HOT_RST_INT) ||\r\n(reg & FUSB300_IGR1_USBRST_INT)\r\n)\r\ngoto IDMA_RESET;\r\nreg = ioread32(ep->fusb300->reg + FUSB300_OFFSET_IGR0);\r\nreg &= FUSB300_IGR0_EPn_PRD_INT(ep->epnum);\r\n} while (!reg);\r\nfusb300_clear_int(ep->fusb300, FUSB300_OFFSET_IGR0,\r\nFUSB300_IGR0_EPn_PRD_INT(ep->epnum));\r\nIDMA_RESET:\r\nfusb300_clear_int(ep->fusb300, FUSB300_OFFSET_IGER0,\r\nFUSB300_IGER0_EEPn_PRD_INT(ep->epnum));\r\n}\r\nstatic void fusb300_set_idma(struct fusb300_ep *ep,\r\nstruct fusb300_request *req)\r\n{\r\ndma_addr_t d;\r\nd = dma_map_single(NULL, req->req.buf, req->req.length, DMA_TO_DEVICE);\r\nif (dma_mapping_error(NULL, d)) {\r\nprintk(KERN_DEBUG "dma_mapping_error\n");\r\nreturn;\r\n}\r\ndma_sync_single_for_device(NULL, d, req->req.length, DMA_TO_DEVICE);\r\nfusb300_enable_bit(ep->fusb300, FUSB300_OFFSET_IGER0,\r\nFUSB300_IGER0_EEPn_PRD_INT(ep->epnum));\r\nfusb300_fill_idma_prdtbl(ep, d, req->req.length);\r\nfusb300_wait_idma_finished(ep);\r\ndma_unmap_single(NULL, d, req->req.length, DMA_TO_DEVICE);\r\n}\r\nstatic void in_ep_fifo_handler(struct fusb300_ep *ep)\r\n{\r\nstruct fusb300_request *req = list_entry(ep->queue.next,\r\nstruct fusb300_request, queue);\r\nif (req->req.length)\r\nfusb300_set_idma(ep, req);\r\ndone(ep, req, 0);\r\n}\r\nstatic void out_ep_fifo_handler(struct fusb300_ep *ep)\r\n{\r\nstruct fusb300 *fusb300 = ep->fusb300;\r\nstruct fusb300_request *req = list_entry(ep->queue.next,\r\nstruct fusb300_request, queue);\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPFFR(ep->epnum));\r\nu32 length = reg & FUSB300_FFR_BYCNT;\r\nfusb300_rdfifo(ep, req, length);\r\nif ((req->req.length == req->req.actual) || (length < ep->ep.maxpacket))\r\ndone(ep, req, 0);\r\n}\r\nstatic void check_device_mode(struct fusb300 *fusb300)\r\n{\r\nu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_GCR);\r\nswitch (reg & FUSB300_GCR_DEVEN_MSK) {\r\ncase FUSB300_GCR_DEVEN_SS:\r\nfusb300->gadget.speed = USB_SPEED_SUPER;\r\nbreak;\r\ncase FUSB300_GCR_DEVEN_HS:\r\nfusb300->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase FUSB300_GCR_DEVEN_FS:\r\nfusb300->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ndefault:\r\nfusb300->gadget.speed = USB_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\nprintk(KERN_INFO "dev_mode = %d\n", (reg & FUSB300_GCR_DEVEN_MSK));\r\n}\r\nstatic void fusb300_ep0out(struct fusb300 *fusb300)\r\n{\r\nstruct fusb300_ep *ep = fusb300->ep[0];\r\nu32 reg;\r\nif (!list_empty(&ep->queue)) {\r\nstruct fusb300_request *req;\r\nreq = list_first_entry(&ep->queue,\r\nstruct fusb300_request, queue);\r\nif (req->req.length)\r\nfusb300_rdcxf(ep->fusb300, req->req.buf,\r\nreq->req.length);\r\ndone(ep, req, 0);\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_IGER1);\r\nreg &= ~FUSB300_IGER1_CX_OUT_INT;\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_IGER1);\r\n} else\r\npr_err("%s : empty queue\n", __func__);\r\n}\r\nstatic void fusb300_ep0in(struct fusb300 *fusb300)\r\n{\r\nstruct fusb300_request *req;\r\nstruct fusb300_ep *ep = fusb300->ep[0];\r\nif ((!list_empty(&ep->queue)) && (fusb300->ep0_dir)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct fusb300_request, queue);\r\nif (req->req.length)\r\nfusb300_wrcxf(ep, req);\r\nif ((req->req.length - req->req.actual) < ep->ep.maxpacket)\r\ndone(ep, req, 0);\r\n} else\r\nfusb300_set_cxdone(fusb300);\r\n}\r\nstatic void fusb300_grp2_handler(void)\r\n{\r\n}\r\nstatic void fusb300_grp3_handler(void)\r\n{\r\n}\r\nstatic void fusb300_grp4_handler(void)\r\n{\r\n}\r\nstatic void fusb300_grp5_handler(void)\r\n{\r\n}\r\nstatic irqreturn_t fusb300_irq(int irq, void *_fusb300)\r\n{\r\nstruct fusb300 *fusb300 = _fusb300;\r\nu32 int_grp1 = ioread32(fusb300->reg + FUSB300_OFFSET_IGR1);\r\nu32 int_grp1_en = ioread32(fusb300->reg + FUSB300_OFFSET_IGER1);\r\nu32 int_grp0 = ioread32(fusb300->reg + FUSB300_OFFSET_IGR0);\r\nu32 int_grp0_en = ioread32(fusb300->reg + FUSB300_OFFSET_IGER0);\r\nstruct usb_ctrlrequest ctrl;\r\nu8 in;\r\nu32 reg;\r\nint i;\r\nspin_lock(&fusb300->lock);\r\nint_grp1 &= int_grp1_en;\r\nint_grp0 &= int_grp0_en;\r\nif (int_grp1 & FUSB300_IGR1_WARM_RST_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_WARM_RST_INT);\r\nprintk(KERN_INFO"fusb300_warmreset\n");\r\nfusb300_reset();\r\n}\r\nif (int_grp1 & FUSB300_IGR1_HOT_RST_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_HOT_RST_INT);\r\nprintk(KERN_INFO"fusb300_hotreset\n");\r\nfusb300_reset();\r\n}\r\nif (int_grp1 & FUSB300_IGR1_USBRST_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_USBRST_INT);\r\nfusb300_reset();\r\n}\r\nif (int_grp1 & FUSB300_IGR1_CX_COMABT_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_CX_COMABT_INT);\r\nprintk(KERN_INFO"fusb300_ep0abt\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_VBUS_CHG_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_VBUS_CHG_INT);\r\nprintk(KERN_INFO"fusb300_vbus_change\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U3_EXIT_FAIL_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U3_EXIT_FAIL_INT);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U2_EXIT_FAIL_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U2_EXIT_FAIL_INT);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U1_EXIT_FAIL_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U1_EXIT_FAIL_INT);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U2_ENTRY_FAIL_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U2_ENTRY_FAIL_INT);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U1_ENTRY_FAIL_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U1_ENTRY_FAIL_INT);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U3_EXIT_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U3_EXIT_INT);\r\nprintk(KERN_INFO "FUSB300_IGR1_U3_EXIT_INT\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U2_EXIT_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U2_EXIT_INT);\r\nprintk(KERN_INFO "FUSB300_IGR1_U2_EXIT_INT\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U1_EXIT_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U1_EXIT_INT);\r\nprintk(KERN_INFO "FUSB300_IGR1_U1_EXIT_INT\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U3_ENTRY_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U3_ENTRY_INT);\r\nprintk(KERN_INFO "FUSB300_IGR1_U3_ENTRY_INT\n");\r\nfusb300_enable_bit(fusb300, FUSB300_OFFSET_SSCR1,\r\nFUSB300_SSCR1_GO_U3_DONE);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U2_ENTRY_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U2_ENTRY_INT);\r\nprintk(KERN_INFO "FUSB300_IGR1_U2_ENTRY_INT\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_U1_ENTRY_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_U1_ENTRY_INT);\r\nprintk(KERN_INFO "FUSB300_IGR1_U1_ENTRY_INT\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_RESM_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_RESM_INT);\r\nprintk(KERN_INFO "fusb300_resume\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_SUSP_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_SUSP_INT);\r\nprintk(KERN_INFO "fusb300_suspend\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_HS_LPM_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_HS_LPM_INT);\r\nprintk(KERN_INFO "fusb300_HS_LPM_INT\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_DEV_MODE_CHG_INT) {\r\nfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\r\nFUSB300_IGR1_DEV_MODE_CHG_INT);\r\ncheck_device_mode(fusb300);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_CX_COMFAIL_INT) {\r\nfusb300_set_cxstall(fusb300);\r\nprintk(KERN_INFO "fusb300_ep0fail\n");\r\n}\r\nif (int_grp1 & FUSB300_IGR1_CX_SETUP_INT) {\r\nprintk(KERN_INFO "fusb300_ep0setup\n");\r\nif (setup_packet(fusb300, &ctrl)) {\r\nspin_unlock(&fusb300->lock);\r\nif (fusb300->driver->setup(&fusb300->gadget, &ctrl) < 0)\r\nfusb300_set_cxstall(fusb300);\r\nspin_lock(&fusb300->lock);\r\n}\r\n}\r\nif (int_grp1 & FUSB300_IGR1_CX_CMDEND_INT)\r\nprintk(KERN_INFO "fusb300_cmdend\n");\r\nif (int_grp1 & FUSB300_IGR1_CX_OUT_INT) {\r\nprintk(KERN_INFO "fusb300_cxout\n");\r\nfusb300_ep0out(fusb300);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_CX_IN_INT) {\r\nprintk(KERN_INFO "fusb300_cxin\n");\r\nfusb300_ep0in(fusb300);\r\n}\r\nif (int_grp1 & FUSB300_IGR1_INTGRP5)\r\nfusb300_grp5_handler();\r\nif (int_grp1 & FUSB300_IGR1_INTGRP4)\r\nfusb300_grp4_handler();\r\nif (int_grp1 & FUSB300_IGR1_INTGRP3)\r\nfusb300_grp3_handler();\r\nif (int_grp1 & FUSB300_IGR1_INTGRP2)\r\nfusb300_grp2_handler();\r\nif (int_grp0) {\r\nfor (i = 1; i < FUSB300_MAX_NUM_EP; i++) {\r\nif (int_grp0 & FUSB300_IGR0_EPn_FIFO_INT(i)) {\r\nreg = ioread32(fusb300->reg +\r\nFUSB300_OFFSET_EPSET1(i));\r\nin = (reg & FUSB300_EPSET1_DIRIN) ? 1 : 0;\r\nif (in)\r\nin_ep_fifo_handler(fusb300->ep[i]);\r\nelse\r\nout_ep_fifo_handler(fusb300->ep[i]);\r\n}\r\n}\r\n}\r\nspin_unlock(&fusb300->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fusb300_set_u2_timeout(struct fusb300 *fusb300,\r\nu32 time)\r\n{\r\nu32 reg;\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_TT);\r\nreg &= ~0xff;\r\nreg |= FUSB300_SSCR2_U2TIMEOUT(time);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_TT);\r\n}\r\nstatic void fusb300_set_u1_timeout(struct fusb300 *fusb300,\r\nu32 time)\r\n{\r\nu32 reg;\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_TT);\r\nreg &= ~(0xff << 8);\r\nreg |= FUSB300_SSCR2_U1TIMEOUT(time);\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_TT);\r\n}\r\nstatic void init_controller(struct fusb300 *fusb300)\r\n{\r\nu32 reg;\r\nu32 mask = 0;\r\nu32 val = 0;\r\nmask = val = FUSB300_AHBBCR_S0_SPLIT_ON | FUSB300_AHBBCR_S1_SPLIT_ON;\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_AHBCR);\r\nreg &= ~mask;\r\nreg |= val;\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_AHBCR);\r\nmask = val = FUSB300_HSCR_HS_LPM_PERMIT;\r\nreg = ioread32(fusb300->reg + FUSB300_OFFSET_HSCR);\r\nreg &= ~mask;\r\nreg |= val;\r\niowrite32(reg, fusb300->reg + FUSB300_OFFSET_HSCR);\r\nfusb300_set_u2_timeout(fusb300, 0xff);\r\nfusb300_set_u1_timeout(fusb300, 0xff);\r\niowrite32(0xcfffff9f, fusb300->reg + FUSB300_OFFSET_IGER1);\r\n}\r\nstatic int fusb300_udc_start(struct usb_gadget_driver *driver,\r\nint (*bind)(struct usb_gadget *))\r\n{\r\nstruct fusb300 *fusb300 = the_controller;\r\nint retval;\r\nif (!driver\r\n|| driver->max_speed < USB_SPEED_FULL\r\n|| !bind\r\n|| !driver->setup)\r\nreturn -EINVAL;\r\nif (!fusb300)\r\nreturn -ENODEV;\r\nif (fusb300->driver)\r\nreturn -EBUSY;\r\ndriver->driver.bus = NULL;\r\nfusb300->driver = driver;\r\nfusb300->gadget.dev.driver = &driver->driver;\r\nretval = device_add(&fusb300->gadget.dev);\r\nif (retval) {\r\npr_err("device_add error (%d)\n", retval);\r\ngoto error;\r\n}\r\nretval = bind(&fusb300->gadget);\r\nif (retval) {\r\npr_err("bind to driver error (%d)\n", retval);\r\ndevice_del(&fusb300->gadget.dev);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nfusb300->driver = NULL;\r\nfusb300->gadget.dev.driver = NULL;\r\nreturn retval;\r\n}\r\nstatic int fusb300_udc_stop(struct usb_gadget_driver *driver)\r\n{\r\nstruct fusb300 *fusb300 = the_controller;\r\nif (driver != fusb300->driver || !driver->unbind)\r\nreturn -EINVAL;\r\ndriver->unbind(&fusb300->gadget);\r\nfusb300->gadget.dev.driver = NULL;\r\ninit_controller(fusb300);\r\ndevice_del(&fusb300->gadget.dev);\r\nfusb300->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic int fusb300_udc_pullup(struct usb_gadget *_gadget, int is_active)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __exit fusb300_remove(struct platform_device *pdev)\r\n{\r\nstruct fusb300 *fusb300 = dev_get_drvdata(&pdev->dev);\r\nusb_del_gadget_udc(&fusb300->gadget);\r\niounmap(fusb300->reg);\r\nfree_irq(platform_get_irq(pdev, 0), fusb300);\r\nfusb300_free_request(&fusb300->ep[0]->ep, fusb300->ep0_req);\r\nkfree(fusb300);\r\nreturn 0;\r\n}\r\nstatic int __init fusb300_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res, *ires, *ires1;\r\nvoid __iomem *reg = NULL;\r\nstruct fusb300 *fusb300 = NULL;\r\nstruct fusb300_ep *_ep[FUSB300_MAX_NUM_EP];\r\nint ret = 0;\r\nint i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\npr_err("platform_get_resource error.\n");\r\ngoto clean_up;\r\n}\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!ires) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev,\r\n"platform_get_resource IORESOURCE_IRQ error.\n");\r\ngoto clean_up;\r\n}\r\nires1 = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\r\nif (!ires1) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev,\r\n"platform_get_resource IORESOURCE_IRQ 1 error.\n");\r\ngoto clean_up;\r\n}\r\nreg = ioremap(res->start, resource_size(res));\r\nif (reg == NULL) {\r\nret = -ENOMEM;\r\npr_err("ioremap error.\n");\r\ngoto clean_up;\r\n}\r\nfusb300 = kzalloc(sizeof(struct fusb300), GFP_KERNEL);\r\nif (fusb300 == NULL) {\r\npr_err("kzalloc error\n");\r\ngoto clean_up;\r\n}\r\nfor (i = 0; i < FUSB300_MAX_NUM_EP; i++) {\r\n_ep[i] = kzalloc(sizeof(struct fusb300_ep), GFP_KERNEL);\r\nif (_ep[i] == NULL) {\r\npr_err("_ep kzalloc error\n");\r\ngoto clean_up;\r\n}\r\nfusb300->ep[i] = _ep[i];\r\n}\r\nspin_lock_init(&fusb300->lock);\r\ndev_set_drvdata(&pdev->dev, fusb300);\r\nfusb300->gadget.ops = &fusb300_gadget_ops;\r\ndevice_initialize(&fusb300->gadget.dev);\r\ndev_set_name(&fusb300->gadget.dev, "gadget");\r\nfusb300->gadget.max_speed = USB_SPEED_HIGH;\r\nfusb300->gadget.dev.parent = &pdev->dev;\r\nfusb300->gadget.dev.dma_mask = pdev->dev.dma_mask;\r\nfusb300->gadget.dev.release = pdev->dev.release;\r\nfusb300->gadget.name = udc_name;\r\nfusb300->reg = reg;\r\nret = request_irq(ires->start, fusb300_irq, IRQF_SHARED,\r\nudc_name, fusb300);\r\nif (ret < 0) {\r\npr_err("request_irq error (%d)\n", ret);\r\ngoto clean_up;\r\n}\r\nret = request_irq(ires1->start, fusb300_irq,\r\nIRQF_SHARED, udc_name, fusb300);\r\nif (ret < 0) {\r\npr_err("request_irq1 error (%d)\n", ret);\r\ngoto clean_up;\r\n}\r\nINIT_LIST_HEAD(&fusb300->gadget.ep_list);\r\nfor (i = 0; i < FUSB300_MAX_NUM_EP ; i++) {\r\nstruct fusb300_ep *ep = fusb300->ep[i];\r\nif (i != 0) {\r\nINIT_LIST_HEAD(&fusb300->ep[i]->ep.ep_list);\r\nlist_add_tail(&fusb300->ep[i]->ep.ep_list,\r\n&fusb300->gadget.ep_list);\r\n}\r\nep->fusb300 = fusb300;\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->ep.name = fusb300_ep_name[i];\r\nep->ep.ops = &fusb300_ep_ops;\r\nep->ep.maxpacket = HS_BULK_MAX_PACKET_SIZE;\r\n}\r\nfusb300->ep[0]->ep.maxpacket = HS_CTL_MAX_PACKET_SIZE;\r\nfusb300->ep[0]->epnum = 0;\r\nfusb300->gadget.ep0 = &fusb300->ep[0]->ep;\r\nINIT_LIST_HEAD(&fusb300->gadget.ep0->ep_list);\r\nthe_controller = fusb300;\r\nfusb300->ep0_req = fusb300_alloc_request(&fusb300->ep[0]->ep,\r\nGFP_KERNEL);\r\nif (fusb300->ep0_req == NULL)\r\ngoto clean_up3;\r\ninit_controller(fusb300);\r\nret = usb_add_gadget_udc(&pdev->dev, &fusb300->gadget);\r\nif (ret)\r\ngoto err_add_udc;\r\ndev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);\r\nreturn 0;\r\nerr_add_udc:\r\nfusb300_free_request(&fusb300->ep[0]->ep, fusb300->ep0_req);\r\nclean_up3:\r\nfree_irq(ires->start, fusb300);\r\nclean_up:\r\nif (fusb300) {\r\nif (fusb300->ep0_req)\r\nfusb300_free_request(&fusb300->ep[0]->ep,\r\nfusb300->ep0_req);\r\nkfree(fusb300);\r\n}\r\nif (reg)\r\niounmap(reg);\r\nreturn ret;\r\n}\r\nstatic int __init fusb300_udc_init(void)\r\n{\r\nreturn platform_driver_probe(&fusb300_driver, fusb300_probe);\r\n}\r\nstatic void __exit fusb300_udc_cleanup(void)\r\n{\r\nplatform_driver_unregister(&fusb300_driver);\r\n}
