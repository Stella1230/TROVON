static unsigned int mbxfb_get_pixclock(unsigned int pixclock_ps,\r\nstruct pixclock_div *div)\r\n{\r\nu8 m, n, p;\r\nunsigned int err = 0;\r\nunsigned int min_err = ~0x0;\r\nunsigned int clk;\r\nunsigned int best_clk = 0;\r\nunsigned int ref_clk = 13000;\r\nunsigned int pixclock;\r\npixclock = PICOS2KHZ(pixclock_ps);\r\nfor (m = 1; m < 64; m++) {\r\nfor (n = 2; n < 8; n++) {\r\nfor (p = 0; p < 8; p++) {\r\nclk = (ref_clk * m) / (n * (1 << p));\r\nerr = (clk > pixclock) ? (clk - pixclock) :\r\n(pixclock - clk);\r\nif (err < min_err) {\r\nmin_err = err;\r\nbest_clk = clk;\r\ndiv->m = m;\r\ndiv->n = n;\r\ndiv->p = p;\r\n}\r\n}\r\n}\r\n}\r\nreturn KHZ2PICOS(best_clk);\r\n}\r\nstatic int mbxfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nu32 val, ret = 1;\r\nif (regno < MAX_PALETTES) {\r\nu32 *pal = info->pseudo_palette;\r\nval = (red & 0xf800) | ((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mbxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct pixclock_div div;\r\nvar->pixclock = mbxfb_get_pixclock(var->pixclock, &div);\r\nif (var->xres < MIN_XRES)\r\nvar->xres = MIN_XRES;\r\nif (var->yres < MIN_YRES)\r\nvar->yres = MIN_YRES;\r\nif (var->xres > MAX_XRES)\r\nreturn -EINVAL;\r\nif (var->yres > MAX_YRES)\r\nreturn -EINVAL;\r\nvar->xres_virtual = max(var->xres_virtual, var->xres);\r\nvar->yres_virtual = max(var->yres_virtual, var->yres);\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nreturn -EINVAL;\r\ncase 16:\r\nvar->green.length = (var->green.length == 5) ? 5 : 6;\r\nvar->red.length = 5;\r\nvar->blue.length = 5;\r\nvar->transp.length = 6 - var->green.length;\r\nvar->blue.offset = 0;\r\nvar->green.offset = 5;\r\nvar->red.offset = 5 + var->green.length;\r\nvar->transp.offset = (5 + var->red.offset) & 15;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.length = var->bits_per_pixel - 24;\r\nvar->transp.offset = (var->transp.length) ? 24 : 0;\r\nbreak;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nreturn 0;\r\n}\r\nstatic int mbxfb_set_par(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct pixclock_div div;\r\nushort hbps, ht, hfps, has;\r\nushort vbps, vt, vfps, vas;\r\nu32 gsctrl = readl(GSCTRL);\r\nu32 gsadr = readl(GSADR);\r\ninfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\ngsctrl &= ~(FMsk(GSCTRL_GPIXFMT));\r\nif (info->var.bits_per_pixel == 8) {\r\nreturn -EINVAL;\r\n} else {\r\nfb_dealloc_cmap(&info->cmap);\r\ngsctrl &= ~GSCTRL_LUT_EN;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\nif (info->var.green.length == 5)\r\ngsctrl |= GSCTRL_GPIXFMT_ARGB1555;\r\nelse\r\ngsctrl |= GSCTRL_GPIXFMT_RGB565;\r\nbreak;\r\ncase 24:\r\ngsctrl |= GSCTRL_GPIXFMT_RGB888;\r\nbreak;\r\ncase 32:\r\ngsctrl |= GSCTRL_GPIXFMT_ARGB8888;\r\nbreak;\r\n}\r\n}\r\ngsctrl &= ~(FMsk(GSCTRL_GSWIDTH) | FMsk(GSCTRL_GSHEIGHT));\r\ngsctrl |= Gsctrl_Width(info->var.xres) |\r\nGsctrl_Height(info->var.yres);\r\nwrite_reg_dly(gsctrl, GSCTRL);\r\ngsadr &= ~(FMsk(GSADR_SRCSTRIDE));\r\ngsadr |= Gsadr_Srcstride(info->var.xres * info->var.bits_per_pixel /\r\n(8 * 16) - 1);\r\nwrite_reg_dly(gsadr, GSADR);\r\nvar->pixclock = mbxfb_get_pixclock(info->var.pixclock, &div);\r\nwrite_reg_dly((Disp_Pll_M(div.m) | Disp_Pll_N(div.n) |\r\nDisp_Pll_P(div.p) | DISP_PLL_EN), DISPPLL);\r\nhbps = var->hsync_len;\r\nhas = hbps + var->left_margin;\r\nhfps = has + var->xres;\r\nht = hfps + var->right_margin;\r\nvbps = var->vsync_len;\r\nvas = vbps + var->upper_margin;\r\nvfps = vas + var->yres;\r\nvt = vfps + var->lower_margin;\r\nwrite_reg_dly((Dht01_Hbps(hbps) | Dht01_Ht(ht)), DHT01);\r\nwrite_reg_dly((Dht02_Hlbs(has) | Dht02_Has(has)), DHT02);\r\nwrite_reg_dly((Dht03_Hfps(hfps) | Dht03_Hrbs(hfps)), DHT03);\r\nwrite_reg_dly((Dhdet_Hdes(has) | Dhdet_Hdef(hfps)), DHDET);\r\nwrite_reg_dly((Dvt01_Vbps(vbps) | Dvt01_Vt(vt)), DVT01);\r\nwrite_reg_dly((Dvt02_Vtbs(vas) | Dvt02_Vas(vas)), DVT02);\r\nwrite_reg_dly((Dvt03_Vfps(vfps) | Dvt03_Vbbs(vfps)), DVT03);\r\nwrite_reg_dly((Dvdet_Vdes(vas) | Dvdet_Vdef(vfps)), DVDET);\r\nwrite_reg_dly((Dvectrl_Vevent(vfps) | Dvectrl_Vfetch(vbps)), DVECTRL);\r\nwrite_reg_dly((readl(DSCTRL) | DSCTRL_SYNCGEN_EN), DSCTRL);\r\nwrite_reg_dly(DINTRE_VEVENT0_EN, DINTRE);\r\nreturn 0;\r\n}\r\nstatic int mbxfb_blank(int blank, struct fb_info *info)\r\n{\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nwrite_reg_dly((readl(DSCTRL) & ~DSCTRL_SYNCGEN_EN), DSCTRL);\r\nwrite_reg_dly((readl(PIXCLK) & ~PIXCLK_EN), PIXCLK);\r\nwrite_reg_dly((readl(VOVRCLK) & ~VOVRCLK_EN), VOVRCLK);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nwrite_reg_dly((readl(DSCTRL) | DSCTRL_SYNCGEN_EN), DSCTRL);\r\nwrite_reg_dly((readl(PIXCLK) | PIXCLK_EN), PIXCLK);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mbxfb_setupOverlay(struct mbxfb_overlaySetup *set)\r\n{\r\nu32 vsctrl, vscadr, vsadr;\r\nu32 sssize, spoctrl, shctrl;\r\nu32 vubase, vvbase;\r\nu32 vovrclk;\r\nif (set->scaled_width==0 || set->scaled_height==0)\r\nreturn -EINVAL;\r\nvovrclk = readl(VOVRCLK);\r\nvsctrl = readl(VSCTRL);\r\nvscadr = readl(VSCADR);\r\nvubase = readl(VUBASE);\r\nvvbase = readl(VVBASE);\r\nshctrl = readl(SHCTRL);\r\nspoctrl = readl(SPOCTRL);\r\nsssize = readl(SSSIZE);\r\nvsctrl &= ~( FMsk(VSCTRL_VSWIDTH) |\r\nFMsk(VSCTRL_VSHEIGHT) |\r\nFMsk(VSCTRL_VPIXFMT) |\r\nVSCTRL_GAMMA_EN | VSCTRL_CSC_EN |\r\nVSCTRL_COSITED );\r\nvsctrl |= Vsctrl_Width(set->width) | Vsctrl_Height(set->height) |\r\nVSCTRL_CSC_EN;\r\nvscadr &= ~(VSCADR_STR_EN | FMsk(VSCADR_VBASE_ADR) );\r\nvubase &= ~(VUBASE_UVHALFSTR | FMsk(VUBASE_UBASE_ADR));\r\nvvbase &= ~(FMsk(VVBASE_VBASE_ADR));\r\nswitch (set->fmt) {\r\ncase MBXFB_FMT_YUV16:\r\nvsctrl |= VSCTRL_VPIXFMT_YUV12;\r\nset->Y_stride = ((set->width) + 0xf ) & ~0xf;\r\nbreak;\r\ncase MBXFB_FMT_YUV12:\r\nvsctrl |= VSCTRL_VPIXFMT_YUV12;\r\nset->Y_stride = ((set->width) + 0xf ) & ~0xf;\r\nvubase |= VUBASE_UVHALFSTR;\r\nbreak;\r\ncase MBXFB_FMT_UY0VY1:\r\nvsctrl |= VSCTRL_VPIXFMT_UY0VY1;\r\nset->Y_stride = (set->width*2 + 0xf ) & ~0xf;\r\nbreak;\r\ncase MBXFB_FMT_VY0UY1:\r\nvsctrl |= VSCTRL_VPIXFMT_VY0UY1;\r\nset->Y_stride = (set->width*2 + 0xf ) & ~0xf;\r\nbreak;\r\ncase MBXFB_FMT_Y0UY1V:\r\nvsctrl |= VSCTRL_VPIXFMT_Y0UY1V;\r\nset->Y_stride = (set->width*2 + 0xf ) & ~0xf;\r\nbreak;\r\ncase MBXFB_FMT_Y0VY1U:\r\nvsctrl |= VSCTRL_VPIXFMT_Y0VY1U;\r\nset->Y_stride = (set->width*2 + 0xf ) & ~0xf;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nset->UV_stride = ((set->width/2) + 0x7 ) & ~0x7;\r\nset->U_offset = set->height * set->Y_stride;\r\nset->V_offset = set->U_offset +\r\nset->height * set->UV_stride;\r\nvubase |= Vubase_Ubase_Adr(\r\n(0x60000 + set->mem_offset + set->U_offset)>>3);\r\nvvbase |= Vvbase_Vbase_Adr(\r\n(0x60000 + set->mem_offset + set->V_offset)>>3);\r\nvscadr |= Vscadr_Vbase_Adr((0x60000 + set->mem_offset)>>4);\r\nif (set->enable)\r\nvscadr |= VSCADR_STR_EN;\r\nvsadr = Vsadr_Srcstride((set->Y_stride)/16-1) |\r\nVsadr_Xstart(set->x) | Vsadr_Ystart(set->y);\r\nsssize &= ~(FMsk(SSSIZE_SC_WIDTH) | FMsk(SSSIZE_SC_HEIGHT));\r\nsssize = Sssize_Sc_Width(set->scaled_width-1) |\r\nSssize_Sc_Height(set->scaled_height-1);\r\nspoctrl &= ~(SPOCTRL_H_SC_BP | SPOCTRL_V_SC_BP |\r\nSPOCTRL_HV_SC_OR | SPOCTRL_VS_UR_C |\r\nFMsk(SPOCTRL_VPITCH));\r\nspoctrl |= Spoctrl_Vpitch((set->height<<11)/set->scaled_height);\r\nif (set->scaled_width == set->width)\r\nspoctrl |= SPOCTRL_H_SC_BP;\r\nif (set->scaled_height == set->height)\r\nspoctrl |= SPOCTRL_V_SC_BP;\r\nshctrl &= ~(FMsk(SHCTRL_HPITCH) | SHCTRL_HDECIM);\r\nshctrl |= Shctrl_Hpitch((set->width<<11)/set->scaled_width);\r\nwrite_reg(vsctrl, VSCTRL);\r\nwrite_reg(vscadr, VSCADR);\r\nwrite_reg(vubase, VUBASE);\r\nwrite_reg(vvbase, VVBASE);\r\nwrite_reg(vsadr, VSADR);\r\nwrite_reg(sssize, SSSIZE);\r\nwrite_reg(spoctrl, SPOCTRL);\r\nwrite_reg(shctrl, SHCTRL);\r\nif (set->enable)\r\nvovrclk |= 1;\r\nelse\r\nvovrclk &= ~1;\r\nwrite_reg(vovrclk, VOVRCLK);\r\nreturn 0;\r\n}\r\nstatic int mbxfb_ioctl_planeorder(struct mbxfb_planeorder *porder)\r\n{\r\nunsigned long gscadr, vscadr;\r\nif (porder->bottom == porder->top)\r\nreturn -EINVAL;\r\ngscadr = readl(GSCADR);\r\nvscadr = readl(VSCADR);\r\ngscadr &= ~(FMsk(GSCADR_BLEND_POS));\r\nvscadr &= ~(FMsk(VSCADR_BLEND_POS));\r\nswitch (porder->bottom) {\r\ncase MBXFB_PLANE_GRAPHICS:\r\ngscadr |= GSCADR_BLEND_GFX;\r\nbreak;\r\ncase MBXFB_PLANE_VIDEO:\r\nvscadr |= VSCADR_BLEND_GFX;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (porder->top) {\r\ncase MBXFB_PLANE_GRAPHICS:\r\ngscadr |= GSCADR_BLEND_VID;\r\nbreak;\r\ncase MBXFB_PLANE_VIDEO:\r\nvscadr |= GSCADR_BLEND_VID;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwrite_reg_dly(vscadr, VSCADR);\r\nwrite_reg_dly(gscadr, GSCADR);\r\nreturn 0;\r\n}\r\nstatic int mbxfb_ioctl_alphactl(struct mbxfb_alphaCtl *alpha)\r\n{\r\nunsigned long vscadr, vbbase, vcmsk;\r\nunsigned long gscadr, gbbase, gdrctrl;\r\nvbbase = Vbbase_Glalpha(alpha->overlay_global_alpha) |\r\nVbbase_Colkey(alpha->overlay_colorkey);\r\ngbbase = Gbbase_Glalpha(alpha->graphics_global_alpha) |\r\nGbbase_Colkey(alpha->graphics_colorkey);\r\nvcmsk = readl(VCMSK);\r\nvcmsk &= ~(FMsk(VCMSK_COLKEY_M));\r\nvcmsk |= Vcmsk_colkey_m(alpha->overlay_colorkey_mask);\r\ngdrctrl = readl(GDRCTRL);\r\ngdrctrl &= ~(FMsk(GDRCTRL_COLKEYM));\r\ngdrctrl |= Gdrctrl_Colkeym(alpha->graphics_colorkey_mask);\r\nvscadr = readl(VSCADR);\r\nvscadr &= ~(FMsk(VSCADR_BLEND_M) | VSCADR_COLKEYSRC | VSCADR_COLKEY_EN);\r\ngscadr = readl(GSCADR);\r\ngscadr &= ~(FMsk(GSCADR_BLEND_M) | GSCADR_COLKEY_EN | GSCADR_COLKEYSRC);\r\nswitch (alpha->overlay_colorkey_mode) {\r\ncase MBXFB_COLORKEY_DISABLED:\r\nbreak;\r\ncase MBXFB_COLORKEY_PREVIOUS:\r\nvscadr |= VSCADR_COLKEY_EN;\r\nbreak;\r\ncase MBXFB_COLORKEY_CURRENT:\r\nvscadr |= VSCADR_COLKEY_EN | VSCADR_COLKEYSRC;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (alpha->overlay_blend_mode) {\r\ncase MBXFB_ALPHABLEND_NONE:\r\nvscadr |= VSCADR_BLEND_NONE;\r\nbreak;\r\ncase MBXFB_ALPHABLEND_GLOBAL:\r\nvscadr |= VSCADR_BLEND_GLOB;\r\nbreak;\r\ncase MBXFB_ALPHABLEND_PIXEL:\r\nvscadr |= VSCADR_BLEND_PIX;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (alpha->graphics_colorkey_mode) {\r\ncase MBXFB_COLORKEY_DISABLED:\r\nbreak;\r\ncase MBXFB_COLORKEY_PREVIOUS:\r\ngscadr |= GSCADR_COLKEY_EN;\r\nbreak;\r\ncase MBXFB_COLORKEY_CURRENT:\r\ngscadr |= GSCADR_COLKEY_EN | GSCADR_COLKEYSRC;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (alpha->graphics_blend_mode) {\r\ncase MBXFB_ALPHABLEND_NONE:\r\ngscadr |= GSCADR_BLEND_NONE;\r\nbreak;\r\ncase MBXFB_ALPHABLEND_GLOBAL:\r\ngscadr |= GSCADR_BLEND_GLOB;\r\nbreak;\r\ncase MBXFB_ALPHABLEND_PIXEL:\r\ngscadr |= GSCADR_BLEND_PIX;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwrite_reg_dly(vbbase, VBBASE);\r\nwrite_reg_dly(gbbase, GBBASE);\r\nwrite_reg_dly(vcmsk, VCMSK);\r\nwrite_reg_dly(gdrctrl, GDRCTRL);\r\nwrite_reg_dly(gscadr, GSCADR);\r\nwrite_reg_dly(vscadr, VSCADR);\r\nreturn 0;\r\n}\r\nstatic int mbxfb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mbxfb_overlaySetup setup;\r\nstruct mbxfb_planeorder porder;\r\nstruct mbxfb_alphaCtl alpha;\r\nstruct mbxfb_reg reg;\r\nint res;\r\n__u32 tmp;\r\nswitch (cmd)\r\n{\r\ncase MBXFB_IOCX_OVERLAY:\r\nif (copy_from_user(&setup, (void __user*)arg,\r\nsizeof(struct mbxfb_overlaySetup)))\r\nreturn -EFAULT;\r\nres = mbxfb_setupOverlay(&setup);\r\nif (res)\r\nreturn res;\r\nif (copy_to_user((void __user*)arg, &setup,\r\nsizeof(struct mbxfb_overlaySetup)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase MBXFB_IOCS_PLANEORDER:\r\nif (copy_from_user(&porder, (void __user*)arg,\r\nsizeof(struct mbxfb_planeorder)))\r\nreturn -EFAULT;\r\nreturn mbxfb_ioctl_planeorder(&porder);\r\ncase MBXFB_IOCS_ALPHA:\r\nif (copy_from_user(&alpha, (void __user*)arg,\r\nsizeof(struct mbxfb_alphaCtl)))\r\nreturn -EFAULT;\r\nreturn mbxfb_ioctl_alphactl(&alpha);\r\ncase MBXFB_IOCS_REG:\r\nif (copy_from_user(&reg, (void __user*)arg,\r\nsizeof(struct mbxfb_reg)))\r\nreturn -EFAULT;\r\nif (reg.addr >= 0x10000)\r\nreturn -EINVAL;\r\ntmp = readl(virt_base_2700 + reg.addr);\r\ntmp &= ~reg.mask;\r\ntmp |= reg.val & reg.mask;\r\nwritel(tmp, virt_base_2700 + reg.addr);\r\nreturn 0;\r\ncase MBXFB_IOCX_REG:\r\nif (copy_from_user(&reg, (void __user*)arg,\r\nsizeof(struct mbxfb_reg)))\r\nreturn -EFAULT;\r\nif (reg.addr >= 0x10000)\r\nreturn -EINVAL;\r\nreg.val = readl(virt_base_2700 + reg.addr);\r\nif (copy_to_user((void __user*)arg, &reg,\r\nsizeof(struct mbxfb_reg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void __devinit setup_memc(struct fb_info *fbi)\r\n{\r\nunsigned long tmp;\r\nint i;\r\nwrite_reg_dly((LMCFG_LMC_DS | LMCFG_LMC_TS | LMCFG_LMD_TS |\r\nLMCFG_LMA_TS),\r\nLMCFG);\r\nwrite_reg_dly(LMPWR_MC_PWR_ACT, LMPWR);\r\nwrite_reg_dly((Lmtim_Tras(7) | Lmtim_Trp(3) | Lmtim_Trcd(3) |\r\nLmtim_Trc(9) | Lmtim_Tdpl(2)),\r\nLMTIM);\r\nwrite_reg_dly(0xc2b, LMREFRESH);\r\nwrite_reg_dly((LMTYPE_CASLAT_3 | LMTYPE_BKSZ_2 | LMTYPE_ROWSZ_11 |\r\nLMTYPE_COLSZ_8),\r\nLMTYPE);\r\nwrite_reg_dly(LMPWR_MC_PWR_ACT, LMPWR);\r\nfor ( i = 0; i < 16; i++ ) {\r\ntmp = readl(fbi->screen_base);\r\n}\r\n}\r\nstatic void enable_clocks(struct fb_info *fbi)\r\n{\r\nwrite_reg_dly(SYSCLKSRC_PLL_2, SYSCLKSRC);\r\nwrite_reg_dly(PIXCLKSRC_PLL_1, PIXCLKSRC);\r\nwrite_reg_dly(0x00000000, CLKSLEEP);\r\nwrite_reg_dly((Core_Pll_M(0xb) | Core_Pll_N(0x1) | Core_Pll_P(0x1) |\r\nCORE_PLL_EN),\r\nCOREPLL);\r\nwrite_reg_dly((Disp_Pll_M(0x1b) | Disp_Pll_N(0x7) | Disp_Pll_P(0x1) |\r\nDISP_PLL_EN),\r\nDISPPLL);\r\nwrite_reg_dly(0x00000000, VOVRCLK);\r\nwrite_reg_dly(PIXCLK_EN, PIXCLK);\r\nwrite_reg_dly(MEMCLK_EN, MEMCLK);\r\nwrite_reg_dly(0x00000001, M24CLK);\r\nwrite_reg_dly(0x00000001, MBXCLK);\r\nwrite_reg_dly(SDCLK_EN, SDCLK);\r\nwrite_reg_dly(0x00000001, PIXCLKDIV);\r\n}\r\nstatic void __devinit setup_graphics(struct fb_info *fbi)\r\n{\r\nunsigned long gsctrl;\r\nunsigned long vscadr;\r\ngsctrl = GSCTRL_GAMMA_EN | Gsctrl_Width(fbi->var.xres) |\r\nGsctrl_Height(fbi->var.yres);\r\nswitch (fbi->var.bits_per_pixel) {\r\ncase 16:\r\nif (fbi->var.green.length == 5)\r\ngsctrl |= GSCTRL_GPIXFMT_ARGB1555;\r\nelse\r\ngsctrl |= GSCTRL_GPIXFMT_RGB565;\r\nbreak;\r\ncase 24:\r\ngsctrl |= GSCTRL_GPIXFMT_RGB888;\r\nbreak;\r\ncase 32:\r\ngsctrl |= GSCTRL_GPIXFMT_ARGB8888;\r\nbreak;\r\n}\r\nwrite_reg_dly(gsctrl, GSCTRL);\r\nwrite_reg_dly(0x00000000, GBBASE);\r\nwrite_reg_dly(0x00ffffff, GDRCTRL);\r\nwrite_reg_dly((GSCADR_STR_EN | Gscadr_Gbase_Adr(0x6000)), GSCADR);\r\nwrite_reg_dly(0x00000000, GPLUT);\r\nvscadr = readl(VSCADR);\r\nvscadr &= ~(FMsk(VSCADR_BLEND_POS) | FMsk(VSCADR_BLEND_M));\r\nvscadr |= VSCADR_BLEND_VID | VSCADR_BLEND_NONE;\r\nwrite_reg_dly(vscadr, VSCADR);\r\n}\r\nstatic void __devinit setup_display(struct fb_info *fbi)\r\n{\r\nunsigned long dsctrl = 0;\r\ndsctrl = DSCTRL_BLNK_POL;\r\nif (fbi->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\ndsctrl |= DSCTRL_HS_POL;\r\nif (fbi->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\ndsctrl |= DSCTRL_VS_POL;\r\nwrite_reg_dly(dsctrl, DSCTRL);\r\nwrite_reg_dly(0xd0303010, DMCTRL);\r\nwrite_reg_dly((readl(DSCTRL) | DSCTRL_SYNCGEN_EN), DSCTRL);\r\n}\r\nstatic void __devinit enable_controller(struct fb_info *fbi)\r\n{\r\nu32 svctrl, shctrl;\r\nwrite_reg_dly(SYSRST_RST, SYSRST);\r\nwrite_reg_dly(0xffffff0c, SYSCFG);\r\nenable_clocks(fbi);\r\nsetup_memc(fbi);\r\nsetup_graphics(fbi);\r\nsetup_display(fbi);\r\nshctrl = readl(SHCTRL);\r\nshctrl &= ~(FMsk(SHCTRL_HINITIAL));\r\nshctrl |= Shctrl_Hinitial(4<<11);\r\nwritel(shctrl, SHCTRL);\r\nsvctrl = Svctrl_Initial1(1<<10) | Svctrl_Initial2(1<<10);\r\nwritel(svctrl, SVCTRL);\r\nwritel(SPOCTRL_H_SC_BP | SPOCTRL_V_SC_BP | SPOCTRL_VORDER_4TAP\r\n, SPOCTRL);\r\nwrite_reg(0xff000100, VSCOEFF0);\r\nwrite_reg(0xfdfcfdfe, VSCOEFF1);\r\nwrite_reg(0x170d0500, VSCOEFF2);\r\nwrite_reg(0x3d372d22, VSCOEFF3);\r\nwrite_reg(0x00000040, VSCOEFF4);\r\nwrite_reg(0xff010100, HSCOEFF0);\r\nwrite_reg(0x00000000, HSCOEFF1);\r\nwrite_reg(0x02010000, HSCOEFF2);\r\nwrite_reg(0x01020302, HSCOEFF3);\r\nwrite_reg(0xf9fbfe00, HSCOEFF4);\r\nwrite_reg(0xfbf7f6f7, HSCOEFF5);\r\nwrite_reg(0x1c110700, HSCOEFF6);\r\nwrite_reg(0x3e393127, HSCOEFF7);\r\nwrite_reg(0x00000040, HSCOEFF8);\r\n}\r\nstatic int mbxfb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nwrite_reg_dly(LMPWR_MC_PWR_SRM, LMPWR);\r\nwhile (readl(LMPWRSTAT) != LMPWRSTAT_MC_PWR_SRM)\r\n;\r\nwrite_reg_dly(SYSRST_RST, SYSRST);\r\nreturn 0;\r\n}\r\nstatic int mbxfb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *fbi = platform_get_drvdata(dev);\r\nenable_clocks(fbi);\r\nwrite_reg_dly((readl(DSCTRL) | DSCTRL_SYNCGEN_EN), DSCTRL);\r\nreturn 0;\r\n}\r\nstatic int __devinit mbxfb_probe(struct platform_device *dev)\r\n{\r\nint ret;\r\nstruct fb_info *fbi;\r\nstruct mbxfb_info *mfbi;\r\nstruct mbxfb_platform_data *pdata;\r\ndev_dbg(&dev->dev, "mbxfb_probe\n");\r\npdata = dev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&dev->dev, "platform data is required\n");\r\nreturn -EINVAL;\r\n}\r\nfbi = framebuffer_alloc(sizeof(struct mbxfb_info), &dev->dev);\r\nif (fbi == NULL) {\r\ndev_err(&dev->dev, "framebuffer_alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmfbi = fbi->par;\r\nfbi->pseudo_palette = mfbi->pseudo_palette;\r\nif (pdata->probe)\r\nmfbi->platform_probe = pdata->probe;\r\nif (pdata->remove)\r\nmfbi->platform_remove = pdata->remove;\r\nmfbi->fb_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nmfbi->reg_res = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nif (!mfbi->fb_res || !mfbi->reg_res) {\r\ndev_err(&dev->dev, "no resources found\n");\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\nmfbi->fb_req = request_mem_region(mfbi->fb_res->start,\r\nres_size(mfbi->fb_res), dev->name);\r\nif (mfbi->fb_req == NULL) {\r\ndev_err(&dev->dev, "failed to claim framebuffer memory\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nmfbi->fb_phys_addr = mfbi->fb_res->start;\r\nmfbi->reg_req = request_mem_region(mfbi->reg_res->start,\r\nres_size(mfbi->reg_res), dev->name);\r\nif (mfbi->reg_req == NULL) {\r\ndev_err(&dev->dev, "failed to claim Marathon registers\n");\r\nret = -EINVAL;\r\ngoto err2;\r\n}\r\nmfbi->reg_phys_addr = mfbi->reg_res->start;\r\nmfbi->reg_virt_addr = ioremap_nocache(mfbi->reg_phys_addr,\r\nres_size(mfbi->reg_req));\r\nif (!mfbi->reg_virt_addr) {\r\ndev_err(&dev->dev, "failed to ioremap Marathon registers\n");\r\nret = -EINVAL;\r\ngoto err3;\r\n}\r\nvirt_base_2700 = mfbi->reg_virt_addr;\r\nmfbi->fb_virt_addr = ioremap_nocache(mfbi->fb_phys_addr,\r\nres_size(mfbi->fb_req));\r\nif (!mfbi->fb_virt_addr) {\r\ndev_err(&dev->dev, "failed to ioremap frame buffer\n");\r\nret = -EINVAL;\r\ngoto err4;\r\n}\r\nfbi->screen_base = (char __iomem *)(mfbi->fb_virt_addr + 0x60000);\r\nfbi->screen_size = pdata->memsize;\r\nfbi->fbops = &mbxfb_ops;\r\nfbi->var = mbxfb_default;\r\nfbi->fix = mbxfb_fix;\r\nfbi->fix.smem_start = mfbi->fb_phys_addr + 0x60000;\r\nfbi->fix.smem_len = pdata->memsize;\r\nfbi->fix.line_length = mbxfb_default.xres_virtual *\r\nmbxfb_default.bits_per_pixel / 8;\r\nret = fb_alloc_cmap(&fbi->cmap, 256, 0);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "fb_alloc_cmap failed\n");\r\nret = -EINVAL;\r\ngoto err5;\r\n}\r\nplatform_set_drvdata(dev, fbi);\r\nprintk(KERN_INFO "fb%d: mbx frame buffer device\n", fbi->node);\r\nif (mfbi->platform_probe)\r\nmfbi->platform_probe(fbi);\r\nenable_controller(fbi);\r\nmbxfb_debugfs_init(fbi);\r\nret = register_framebuffer(fbi);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "register_framebuffer failed\n");\r\nret = -EINVAL;\r\ngoto err6;\r\n}\r\nreturn 0;\r\nerr6:\r\nfb_dealloc_cmap(&fbi->cmap);\r\nerr5:\r\niounmap(mfbi->fb_virt_addr);\r\nerr4:\r\niounmap(mfbi->reg_virt_addr);\r\nerr3:\r\nrelease_mem_region(mfbi->reg_res->start, res_size(mfbi->reg_res));\r\nerr2:\r\nrelease_mem_region(mfbi->fb_res->start, res_size(mfbi->fb_res));\r\nerr1:\r\nframebuffer_release(fbi);\r\nreturn ret;\r\n}\r\nstatic int __devexit mbxfb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *fbi = platform_get_drvdata(dev);\r\nwrite_reg_dly(SYSRST_RST, SYSRST);\r\nmbxfb_debugfs_remove(fbi);\r\nif (fbi) {\r\nstruct mbxfb_info *mfbi = fbi->par;\r\nunregister_framebuffer(fbi);\r\nif (mfbi) {\r\nif (mfbi->platform_remove)\r\nmfbi->platform_remove(fbi);\r\nif (mfbi->fb_virt_addr)\r\niounmap(mfbi->fb_virt_addr);\r\nif (mfbi->reg_virt_addr)\r\niounmap(mfbi->reg_virt_addr);\r\nif (mfbi->reg_req)\r\nrelease_mem_region(mfbi->reg_req->start,\r\nres_size(mfbi->reg_req));\r\nif (mfbi->fb_req)\r\nrelease_mem_region(mfbi->fb_req->start,\r\nres_size(mfbi->fb_req));\r\n}\r\nframebuffer_release(fbi);\r\n}\r\nreturn 0;\r\n}
