static inline void beatic_update_irq_mask(unsigned int irq_plug)\r\n{\r\nint off;\r\nunsigned long masks[4];\r\noff = (irq_plug / 256) * 4;\r\nmasks[0] = beatic_irq_mask_enable[off + 0]\r\n& beatic_irq_mask_ack[off + 0];\r\nmasks[1] = beatic_irq_mask_enable[off + 1]\r\n& beatic_irq_mask_ack[off + 1];\r\nmasks[2] = beatic_irq_mask_enable[off + 2]\r\n& beatic_irq_mask_ack[off + 2];\r\nmasks[3] = beatic_irq_mask_enable[off + 3]\r\n& beatic_irq_mask_ack[off + 3];\r\nif (beat_set_interrupt_mask(irq_plug&~255UL,\r\nmasks[0], masks[1], masks[2], masks[3]) != 0)\r\npanic("Failed to set mask IRQ!");\r\n}\r\nstatic void beatic_mask_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&beatic_irq_mask_lock, flags);\r\nbeatic_irq_mask_enable[d->irq/64] &= ~(1UL << (63 - (d->irq%64)));\r\nbeatic_update_irq_mask(d->irq);\r\nraw_spin_unlock_irqrestore(&beatic_irq_mask_lock, flags);\r\n}\r\nstatic void beatic_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&beatic_irq_mask_lock, flags);\r\nbeatic_irq_mask_enable[d->irq/64] |= 1UL << (63 - (d->irq%64));\r\nbeatic_update_irq_mask(d->irq);\r\nraw_spin_unlock_irqrestore(&beatic_irq_mask_lock, flags);\r\n}\r\nstatic void beatic_ack_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&beatic_irq_mask_lock, flags);\r\nbeatic_irq_mask_ack[d->irq/64] &= ~(1UL << (63 - (d->irq%64)));\r\nbeatic_update_irq_mask(d->irq);\r\nraw_spin_unlock_irqrestore(&beatic_irq_mask_lock, flags);\r\n}\r\nstatic void beatic_end_irq(struct irq_data *d)\r\n{\r\ns64 err;\r\nunsigned long flags;\r\nerr = beat_downcount_of_interrupt(d->irq);\r\nif (err != 0) {\r\nif ((err & 0xFFFFFFFF) != 0xFFFFFFF5)\r\npanic("Failed to downcount IRQ! Error = %16llx", err);\r\nprintk(KERN_ERR "IRQ over-downcounted, plug %d\n", d->irq);\r\n}\r\nraw_spin_lock_irqsave(&beatic_irq_mask_lock, flags);\r\nbeatic_irq_mask_ack[d->irq/64] |= 1UL << (63 - (d->irq%64));\r\nbeatic_update_irq_mask(d->irq);\r\nraw_spin_unlock_irqrestore(&beatic_irq_mask_lock, flags);\r\n}\r\nstatic void beatic_pic_host_unmap(struct irq_domain *h, unsigned int virq)\r\n{\r\nbeat_destruct_irq_plug(virq);\r\n}\r\nstatic int beatic_pic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nint64_t err;\r\nerr = beat_construct_and_connect_irq_plug(virq, hw);\r\nif (err < 0)\r\nreturn -EIO;\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &beatic_pic, handle_fasteoi_irq);\r\nreturn 0;\r\n}\r\nstatic int beatic_pic_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq,\r\nunsigned int *out_flags)\r\n{\r\nconst u64 *intspec2 = (const u64 *)intspec;\r\n*out_hwirq = *intspec2;\r\n*out_flags |= IRQ_TYPE_LEVEL_LOW;\r\nreturn 0;\r\n}\r\nstatic int beatic_pic_host_match(struct irq_domain *h, struct device_node *np)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline unsigned int beatic_get_irq_plug(void)\r\n{\r\nint i;\r\nuint64_t pending[4], ub;\r\nfor (i = 0; i < MAX_IRQS; i += 256) {\r\nbeat_detect_pending_interrupts(i, pending);\r\n__asm__ ("cntlzd %0,%1":"=r"(ub):\r\n"r"(pending[0] & beatic_irq_mask_enable[i/64+0]\r\n& beatic_irq_mask_ack[i/64+0]));\r\nif (ub != 64)\r\nreturn i + ub + 0;\r\n__asm__ ("cntlzd %0,%1":"=r"(ub):\r\n"r"(pending[1] & beatic_irq_mask_enable[i/64+1]\r\n& beatic_irq_mask_ack[i/64+1]));\r\nif (ub != 64)\r\nreturn i + ub + 64;\r\n__asm__ ("cntlzd %0,%1":"=r"(ub):\r\n"r"(pending[2] & beatic_irq_mask_enable[i/64+2]\r\n& beatic_irq_mask_ack[i/64+2]));\r\nif (ub != 64)\r\nreturn i + ub + 128;\r\n__asm__ ("cntlzd %0,%1":"=r"(ub):\r\n"r"(pending[3] & beatic_irq_mask_enable[i/64+3]\r\n& beatic_irq_mask_ack[i/64+3]));\r\nif (ub != 64)\r\nreturn i + ub + 192;\r\n}\r\nreturn NO_IRQ;\r\n}\r\nunsigned int beatic_get_irq(void)\r\n{\r\nunsigned int ret;\r\nret = beatic_get_irq_plug();\r\nif (ret != NO_IRQ)\r\nbeatic_ack_irq(irq_get_irq_data(ret));\r\nreturn ret;\r\n}\r\nvoid __init beatic_init_IRQ(void)\r\n{\r\nint i;\r\nmemset(beatic_irq_mask_enable, 0, sizeof(beatic_irq_mask_enable));\r\nmemset(beatic_irq_mask_ack, 255, sizeof(beatic_irq_mask_ack));\r\nfor (i = 0; i < MAX_IRQS; i += 256)\r\nbeat_set_interrupt_mask(i, 0L, 0L, 0L, 0L);\r\nppc_md.get_irq = beatic_get_irq;\r\nbeatic_host = irq_domain_add_nomap(NULL, 0, &beatic_pic_host_ops, NULL);\r\nBUG_ON(beatic_host == NULL);\r\nirq_set_default_host(beatic_host);\r\n}\r\nvoid beatic_deinit_IRQ(void)\r\n{\r\nint i;\r\nfor (i = 1; i < nr_irqs; i++)\r\nbeat_destruct_irq_plug(i);\r\n}
