static int tda18218_wr_regs(struct tda18218_priv *priv, u8 reg, u8 *val, u8 len)\r\n{\r\nint ret = 0;\r\nu8 buf[1+len], quotient, remainder, i, msg_len, msg_len_max;\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_address,\r\n.flags = 0,\r\n.buf = buf,\r\n}\r\n};\r\nmsg_len_max = priv->cfg->i2c_wr_max - 1;\r\nquotient = len / msg_len_max;\r\nremainder = len % msg_len_max;\r\nmsg_len = msg_len_max;\r\nfor (i = 0; (i <= quotient && remainder); i++) {\r\nif (i == quotient)\r\nmsg_len = remainder;\r\nmsg[0].len = msg_len + 1;\r\nbuf[0] = reg + i * msg_len_max;\r\nmemcpy(&buf[1], &val[i * msg_len_max], msg_len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret != 1)\r\nbreak;\r\n}\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\nwarn("i2c wr failed ret:%d reg:%02x len:%d", ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda18218_rd_regs(struct tda18218_priv *priv, u8 reg, u8 *val, u8 len)\r\n{\r\nint ret;\r\nu8 buf[reg+len];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg->i2c_address,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = "\x00",\r\n}, {\r\n.addr = priv->cfg->i2c_address,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, &buf[reg], len);\r\nret = 0;\r\n} else {\r\nwarn("i2c rd failed ret:%d reg:%02x len:%d", ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda18218_wr_reg(struct tda18218_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn tda18218_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int tda18218_rd_reg(struct tda18218_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn tda18218_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int tda18218_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct tda18218_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 bw = c->bandwidth_hz;\r\nint ret;\r\nu8 buf[3], i, BP_Filter, LP_Fc;\r\nu32 LO_Frac;\r\nu8 agc[][2] = {\r\n{ R20_AGC11, 0x60 },\r\n{ R23_AGC21, 0x02 },\r\n{ R20_AGC11, 0xa0 },\r\n{ R23_AGC21, 0x09 },\r\n{ R20_AGC11, 0xe0 },\r\n{ R23_AGC21, 0x0c },\r\n{ R20_AGC11, 0x40 },\r\n{ R23_AGC21, 0x01 },\r\n{ R20_AGC11, 0x80 },\r\n{ R23_AGC21, 0x08 },\r\n{ R20_AGC11, 0xc0 },\r\n{ R23_AGC21, 0x0b },\r\n{ R24_AGC22, 0x1c },\r\n{ R24_AGC22, 0x0c },\r\n};\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (bw <= 6000000) {\r\nLP_Fc = 0;\r\npriv->if_frequency = 3000000;\r\n} else if (bw <= 7000000) {\r\nLP_Fc = 1;\r\npriv->if_frequency = 3500000;\r\n} else {\r\nLP_Fc = 2;\r\npriv->if_frequency = 4000000;\r\n}\r\nLO_Frac = c->frequency + priv->if_frequency;\r\nif (LO_Frac < 188000000)\r\nBP_Filter = 3;\r\nelse if (LO_Frac < 253000000)\r\nBP_Filter = 4;\r\nelse if (LO_Frac < 343000000)\r\nBP_Filter = 5;\r\nelse\r\nBP_Filter = 6;\r\nbuf[0] = (priv->regs[R1A_IF1] & ~7) | BP_Filter;\r\nbuf[1] = (priv->regs[R1B_IF2] & ~3) | LP_Fc;\r\nbuf[2] = priv->regs[R1C_AGC2B];\r\nret = tda18218_wr_regs(priv, R1A_IF1, buf, 3);\r\nif (ret)\r\ngoto error;\r\nbuf[0] = (LO_Frac / 1000) >> 12;\r\nbuf[1] = (LO_Frac / 1000) >> 4;\r\nbuf[2] = (LO_Frac / 1000) << 4 |\r\n(priv->regs[R0C_MD5] & 0x0f);\r\nret = tda18218_wr_regs(priv, R0A_MD3, buf, 3);\r\nif (ret)\r\ngoto error;\r\nbuf[0] = priv->regs[R0F_MD8] | (1 << 6);\r\nret = tda18218_wr_regs(priv, R0F_MD8, buf, 1);\r\nif (ret)\r\ngoto error;\r\nbuf[0] = priv->regs[R0F_MD8] & ~(1 << 6);\r\nret = tda18218_wr_regs(priv, R0F_MD8, buf, 1);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < ARRAY_SIZE(agc); i++) {\r\nret = tda18218_wr_reg(priv, agc[i][0], agc[i][1]);\r\nif (ret)\r\ngoto error;\r\n}\r\nerror:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret)\r\ndbg("%s: failed ret:%d", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda18218_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tda18218_priv *priv = fe->tuner_priv;\r\n*frequency = priv->if_frequency;\r\ndbg("%s: if=%d", __func__, *frequency);\r\nreturn 0;\r\n}\r\nstatic int tda18218_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tda18218_priv *priv = fe->tuner_priv;\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tda18218_wr_reg(priv, R17_PD1, priv->regs[R17_PD1] | (1 << 0));\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret)\r\ndbg("%s: failed ret:%d", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda18218_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda18218_priv *priv = fe->tuner_priv;\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tda18218_wr_regs(priv, R00_ID, priv->regs, TDA18218_NUM_REGS);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret)\r\ndbg("%s: failed ret:%d", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int tda18218_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tda18218_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, struct tda18218_config *cfg)\r\n{\r\nstruct tda18218_priv *priv = NULL;\r\nu8 val;\r\nint ret;\r\nstatic u8 def_regs[] = {\r\n0xc0, 0x88, 0x00, 0x8e, 0x03, 0x00, 0x00, 0xd0, 0x00, 0x40,\r\n0x00, 0x00, 0x07, 0xff, 0x84, 0x09, 0x00, 0x13, 0x00, 0x00,\r\n0x01, 0x84, 0x09, 0xf0, 0x19, 0x0a, 0x8e, 0x69, 0x98, 0x01,\r\n0x00, 0x58, 0x10, 0x40, 0x8c, 0x00, 0x0c, 0x48, 0x85, 0xc9,\r\n0xa7, 0x00, 0x00, 0x00, 0x30, 0x81, 0x80, 0x00, 0x39, 0x00,\r\n0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xf6\r\n};\r\npriv = kzalloc(sizeof(struct tda18218_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nfe->tuner_priv = priv;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tda18218_rd_reg(priv, R00_ID, &val);\r\ndbg("%s: ret:%d chip ID:%02x", __func__, ret, val);\r\nif (ret || val != def_regs[R00_ID]) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\ninfo("NXP TDA18218HN successfully identified.");\r\nmemcpy(&fe->ops.tuner_ops, &tda18218_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nmemcpy(priv->regs, def_regs, sizeof(def_regs));\r\nif (priv->cfg->loop_through) {\r\npriv->regs[R17_PD1] = 0xb0;\r\npriv->regs[R18_PD2] = 0x59;\r\n}\r\nret = tda18218_wr_reg(priv, R17_PD1, priv->regs[R17_PD1] | (1 << 0));\r\nif (ret)\r\ndbg("%s: failed ret:%d", __func__, ret);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn fe;\r\n}
