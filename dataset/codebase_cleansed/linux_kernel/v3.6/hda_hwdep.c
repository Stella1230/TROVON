static int verb_write_ioctl(struct hda_codec *codec,\r\nstruct hda_verb_ioctl __user *arg)\r\n{\r\nu32 verb, res;\r\nif (get_user(verb, &arg->verb))\r\nreturn -EFAULT;\r\nres = snd_hda_codec_read(codec, verb >> 24, 0,\r\n(verb >> 8) & 0xffff, verb & 0xff);\r\nif (put_user(res, &arg->res))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_wcap_ioctl(struct hda_codec *codec,\r\nstruct hda_verb_ioctl __user *arg)\r\n{\r\nu32 verb, res;\r\nif (get_user(verb, &arg->verb))\r\nreturn -EFAULT;\r\nres = get_wcaps(codec, verb >> 24);\r\nif (put_user(res, &arg->res))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int hda_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct hda_codec *codec = hw->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase HDA_IOCTL_PVERSION:\r\nreturn put_user(HDA_HWDEP_VERSION, (int __user *)argp);\r\ncase HDA_IOCTL_VERB_WRITE:\r\nreturn verb_write_ioctl(codec, argp);\r\ncase HDA_IOCTL_GET_WCAP:\r\nreturn get_wcap_ioctl(codec, argp);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int hda_hwdep_ioctl_compat(struct snd_hwdep *hw, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn hda_hwdep_ioctl(hw, file, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int hda_hwdep_open(struct snd_hwdep *hw, struct file *file)\r\n{\r\n#ifndef CONFIG_SND_DEBUG_VERBOSE\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void clear_hwdep_elements(struct hda_codec *codec)\r\n{\r\nint i;\r\nsnd_array_free(&codec->init_verbs);\r\nfor (i = 0; i < codec->hints.used; i++) {\r\nstruct hda_hint *hint = snd_array_elem(&codec->hints, i);\r\nkfree(hint->key);\r\n}\r\nsnd_array_free(&codec->hints);\r\nsnd_array_free(&codec->user_pins);\r\n}\r\nstatic void hwdep_free(struct snd_hwdep *hwdep)\r\n{\r\nclear_hwdep_elements(hwdep->private_data);\r\n}\r\nint snd_hda_create_hwdep(struct hda_codec *codec)\r\n{\r\nchar hwname[16];\r\nstruct snd_hwdep *hwdep;\r\nint err;\r\nsprintf(hwname, "HDA Codec %d", codec->addr);\r\nerr = snd_hwdep_new(codec->bus->card, hwname, codec->addr, &hwdep);\r\nif (err < 0)\r\nreturn err;\r\ncodec->hwdep = hwdep;\r\nsprintf(hwdep->name, "HDA Codec %d", codec->addr);\r\nhwdep->iface = SNDRV_HWDEP_IFACE_HDA;\r\nhwdep->private_data = codec;\r\nhwdep->private_free = hwdep_free;\r\nhwdep->exclusive = 1;\r\nhwdep->ops.open = hda_hwdep_open;\r\nhwdep->ops.ioctl = hda_hwdep_ioctl;\r\n#ifdef CONFIG_COMPAT\r\nhwdep->ops.ioctl_compat = hda_hwdep_ioctl_compat;\r\n#endif\r\nsnd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);\r\nsnd_array_init(&codec->hints, sizeof(struct hda_hint), 32);\r\nsnd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);\r\nreturn 0;\r\n}\r\nstatic ssize_t power_on_acct_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nsnd_hda_update_power_acct(codec);\r\nreturn sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_on_acct));\r\n}\r\nstatic ssize_t power_off_acct_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nsnd_hda_update_power_acct(codec);\r\nreturn sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_off_acct));\r\n}\r\nint snd_hda_hwdep_add_power_sysfs(struct hda_codec *codec)\r\n{\r\nstruct snd_hwdep *hwdep = codec->hwdep;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(power_attrs); i++)\r\nsnd_add_device_sysfs_file(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card,\r\nhwdep->device, &power_attrs[i]);\r\nreturn 0;\r\n}\r\nstatic int clear_codec(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = snd_hda_codec_reset(codec);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "The codec is being used, can't free.\n");\r\nreturn err;\r\n}\r\nclear_hwdep_elements(codec);\r\nreturn 0;\r\n}\r\nstatic int reconfig_codec(struct hda_codec *codec)\r\n{\r\nint err;\r\nsnd_hda_power_up(codec);\r\nsnd_printk(KERN_INFO "hda-codec: reconfiguring\n");\r\nerr = snd_hda_codec_reset(codec);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR\r\n"The codec is being used, can't reconfigure.\n");\r\ngoto error;\r\n}\r\nerr = snd_hda_codec_configure(codec);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_hda_codec_build_pcms(codec);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_hda_codec_build_controls(codec);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(codec->bus->card);\r\nerror:\r\nsnd_hda_power_down(codec);\r\nreturn err;\r\n}\r\nstatic char *kstrndup_noeol(const char *src, size_t len)\r\n{\r\nchar *s = kstrndup(src, len, GFP_KERNEL);\r\nchar *p;\r\nif (!s)\r\nreturn NULL;\r\np = strchr(s, '\n');\r\nif (p)\r\n*p = 0;\r\nreturn s;\r\n}\r\nstatic ssize_t init_verbs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nint i, len = 0;\r\nfor (i = 0; i < codec->init_verbs.used; i++) {\r\nstruct hda_verb *v = snd_array_elem(&codec->init_verbs, i);\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"0x%02x 0x%03x 0x%04x\n",\r\nv->nid, v->verb, v->param);\r\n}\r\nreturn len;\r\n}\r\nstatic int parse_init_verbs(struct hda_codec *codec, const char *buf)\r\n{\r\nstruct hda_verb *v;\r\nint nid, verb, param;\r\nif (sscanf(buf, "%i %i %i", &nid, &verb, &param) != 3)\r\nreturn -EINVAL;\r\nif (!nid || !verb)\r\nreturn -EINVAL;\r\nv = snd_array_new(&codec->init_verbs);\r\nif (!v)\r\nreturn -ENOMEM;\r\nv->nid = nid;\r\nv->verb = verb;\r\nv->param = param;\r\nreturn 0;\r\n}\r\nstatic ssize_t init_verbs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nint err = parse_init_verbs(codec, buf);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t hints_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nint i, len = 0;\r\nfor (i = 0; i < codec->hints.used; i++) {\r\nstruct hda_hint *hint = snd_array_elem(&codec->hints, i);\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"%s = %s\n", hint->key, hint->val);\r\n}\r\nreturn len;\r\n}\r\nstatic struct hda_hint *get_hint(struct hda_codec *codec, const char *key)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->hints.used; i++) {\r\nstruct hda_hint *hint = snd_array_elem(&codec->hints, i);\r\nif (!strcmp(hint->key, key))\r\nreturn hint;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void remove_trail_spaces(char *str)\r\n{\r\nchar *p;\r\nif (!*str)\r\nreturn;\r\np = str + strlen(str) - 1;\r\nfor (; isspace(*p); p--) {\r\n*p = 0;\r\nif (p == str)\r\nreturn;\r\n}\r\n}\r\nstatic int parse_hints(struct hda_codec *codec, const char *buf)\r\n{\r\nchar *key, *val;\r\nstruct hda_hint *hint;\r\nbuf = skip_spaces(buf);\r\nif (!*buf || *buf == '#' || *buf == '\n')\r\nreturn 0;\r\nif (*buf == '=')\r\nreturn -EINVAL;\r\nkey = kstrndup_noeol(buf, 1024);\r\nif (!key)\r\nreturn -ENOMEM;\r\nval = strchr(key, '=');\r\nif (!val) {\r\nkfree(key);\r\nreturn -EINVAL;\r\n}\r\n*val++ = 0;\r\nval = skip_spaces(val);\r\nremove_trail_spaces(key);\r\nremove_trail_spaces(val);\r\nhint = get_hint(codec, key);\r\nif (hint) {\r\nkfree(hint->key);\r\nhint->key = key;\r\nhint->val = val;\r\nreturn 0;\r\n}\r\nif (codec->hints.used >= MAX_HINTS)\r\nhint = NULL;\r\nelse\r\nhint = snd_array_new(&codec->hints);\r\nif (!hint) {\r\nkfree(key);\r\nreturn -ENOMEM;\r\n}\r\nhint->key = key;\r\nhint->val = val;\r\nreturn 0;\r\n}\r\nstatic ssize_t hints_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nint err = parse_hints(codec, buf);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t pin_configs_show(struct hda_codec *codec,\r\nstruct snd_array *list,\r\nchar *buf)\r\n{\r\nint i, len = 0;\r\nfor (i = 0; i < list->used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(list, i);\r\nlen += sprintf(buf + len, "0x%02x 0x%08x\n",\r\npin->nid, pin->cfg);\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t init_pin_configs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nreturn pin_configs_show(codec, &codec->init_pins, buf);\r\n}\r\nstatic ssize_t user_pin_configs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nreturn pin_configs_show(codec, &codec->user_pins, buf);\r\n}\r\nstatic ssize_t driver_pin_configs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nreturn pin_configs_show(codec, &codec->driver_pins, buf);\r\n}\r\nstatic int parse_user_pin_configs(struct hda_codec *codec, const char *buf)\r\n{\r\nint nid, cfg;\r\nif (sscanf(buf, "%i %i", &nid, &cfg) != 2)\r\nreturn -EINVAL;\r\nif (!nid)\r\nreturn -EINVAL;\r\nreturn snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);\r\n}\r\nstatic ssize_t user_pin_configs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct snd_hwdep *hwdep = dev_get_drvdata(dev);\r\nstruct hda_codec *codec = hwdep->private_data;\r\nint err = parse_user_pin_configs(codec, buf);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nint snd_hda_hwdep_add_sysfs(struct hda_codec *codec)\r\n{\r\nstruct snd_hwdep *hwdep = codec->hwdep;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(codec_attrs); i++)\r\nsnd_add_device_sysfs_file(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card,\r\nhwdep->device, &codec_attrs[i]);\r\nreturn 0;\r\n}\r\nconst char *snd_hda_get_hint(struct hda_codec *codec, const char *key)\r\n{\r\nstruct hda_hint *hint = get_hint(codec, key);\r\nreturn hint ? hint->val : NULL;\r\n}\r\nint snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)\r\n{\r\nconst char *p = snd_hda_get_hint(codec, key);\r\nif (!p || !*p)\r\nreturn -ENOENT;\r\nswitch (toupper(*p)) {\r\ncase 'T':\r\ncase 'Y':\r\ncase '1':\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int strmatch(const char *a, const char *b)\r\n{\r\nreturn strnicmp(a, b, strlen(b)) == 0;\r\n}\r\nstatic void parse_codec_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nint vendorid, subid, caddr;\r\nstruct hda_codec *codec;\r\n*codecp = NULL;\r\nif (sscanf(buf, "%i %i %i", &vendorid, &subid, &caddr) == 3) {\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\nif ((vendorid <= 0 || codec->vendor_id == vendorid) &&\r\n(subid <= 0 || codec->subsystem_id == subid) &&\r\ncodec->addr == caddr) {\r\n*codecp = codec;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void parse_pincfg_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nparse_user_pin_configs(*codecp, buf);\r\n}\r\nstatic void parse_verb_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nparse_init_verbs(*codecp, buf);\r\n}\r\nstatic void parse_hint_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nparse_hints(*codecp, buf);\r\n}\r\nstatic void parse_model_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nkfree((*codecp)->modelname);\r\n(*codecp)->modelname = kstrdup(buf, GFP_KERNEL);\r\n}\r\nstatic void parse_chip_name_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nkfree((*codecp)->chip_name);\r\n(*codecp)->chip_name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nstatic int parse_line_mode(char *buf, struct hda_bus *bus)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(patch_items); i++) {\r\nif (!patch_items[i].tag)\r\ncontinue;\r\nif (strmatch(buf, patch_items[i].tag))\r\nreturn i;\r\n}\r\nreturn LINE_MODE_NONE;\r\n}\r\nstatic int get_line_from_fw(char *buf, int size, struct firmware *fw)\r\n{\r\nint len;\r\nconst char *p = fw->data;\r\nwhile (isspace(*p) && fw->size) {\r\np++;\r\nfw->size--;\r\n}\r\nif (!fw->size)\r\nreturn 0;\r\nfor (len = 0; len < fw->size; len++) {\r\nif (!*p)\r\nbreak;\r\nif (*p == '\n') {\r\np++;\r\nlen++;\r\nbreak;\r\n}\r\nif (len < size)\r\n*buf++ = *p++;\r\n}\r\n*buf = 0;\r\nfw->size -= len;\r\nfw->data = p;\r\nremove_trail_spaces(buf);\r\nreturn 1;\r\n}\r\nint snd_hda_load_patch(struct hda_bus *bus, const char *patch)\r\n{\r\nint err;\r\nconst struct firmware *fw;\r\nstruct firmware tmp;\r\nchar buf[128];\r\nstruct hda_codec *codec;\r\nint line_mode;\r\nstruct device *dev = bus->card->dev;\r\nif (snd_BUG_ON(!dev))\r\nreturn -ENODEV;\r\nerr = request_firmware(&fw, patch, dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR "hda-codec: Cannot load the patch '%s'\n",\r\npatch);\r\nreturn err;\r\n}\r\ntmp = *fw;\r\nline_mode = LINE_MODE_NONE;\r\ncodec = NULL;\r\nwhile (get_line_from_fw(buf, sizeof(buf) - 1, &tmp)) {\r\nif (!*buf || *buf == '#' || *buf == '\n')\r\ncontinue;\r\nif (*buf == '[')\r\nline_mode = parse_line_mode(buf, bus);\r\nelse if (patch_items[line_mode].parser &&\r\n(codec || !patch_items[line_mode].need_codec))\r\npatch_items[line_mode].parser(buf, bus, &codec);\r\n}\r\nrelease_firmware(fw);\r\nreturn 0;\r\n}
