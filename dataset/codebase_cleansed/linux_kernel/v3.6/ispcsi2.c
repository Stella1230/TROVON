static void csi2_if_enable(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2, u8 enable)\r\n{\r\nstruct isp_csi2_ctrl_cfg *currctrl = &csi2->ctrl;\r\nisp_reg_clr_set(isp, csi2->regs1, ISPCSI2_CTRL, ISPCSI2_CTRL_IF_EN,\r\nenable ? ISPCSI2_CTRL_IF_EN : 0);\r\ncurrctrl->if_enable = enable;\r\n}\r\nstatic void csi2_recv_config(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2,\r\nstruct isp_csi2_ctrl_cfg *currctrl)\r\n{\r\nu32 reg;\r\nreg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTRL);\r\nif (currctrl->frame_mode)\r\nreg |= ISPCSI2_CTRL_FRAME;\r\nelse\r\nreg &= ~ISPCSI2_CTRL_FRAME;\r\nif (currctrl->vp_clk_enable)\r\nreg |= ISPCSI2_CTRL_VP_CLK_EN;\r\nelse\r\nreg &= ~ISPCSI2_CTRL_VP_CLK_EN;\r\nif (currctrl->vp_only_enable)\r\nreg |= ISPCSI2_CTRL_VP_ONLY_EN;\r\nelse\r\nreg &= ~ISPCSI2_CTRL_VP_ONLY_EN;\r\nreg &= ~ISPCSI2_CTRL_VP_OUT_CTRL_MASK;\r\nreg |= currctrl->vp_out_ctrl << ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT;\r\nif (currctrl->ecc_enable)\r\nreg |= ISPCSI2_CTRL_ECC_EN;\r\nelse\r\nreg &= ~ISPCSI2_CTRL_ECC_EN;\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTRL);\r\n}\r\nstatic u16 csi2_ctx_map_format(struct isp_csi2_device *csi2)\r\n{\r\nconst struct v4l2_mbus_framefmt *fmt = &csi2->formats[CSI2_PAD_SINK];\r\nint fmtidx, destidx, is_3630;\r\nswitch (fmt->code) {\r\ncase V4L2_MBUS_FMT_SGRBG10_1X10:\r\ncase V4L2_MBUS_FMT_SRGGB10_1X10:\r\ncase V4L2_MBUS_FMT_SBGGR10_1X10:\r\ncase V4L2_MBUS_FMT_SGBRG10_1X10:\r\nfmtidx = 0;\r\nbreak;\r\ncase V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8:\r\ncase V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8:\r\ncase V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8:\r\nfmtidx = 1;\r\nbreak;\r\ndefault:\r\nWARN(1, KERN_ERR "CSI2: pixel format %08x unsupported!\n",\r\nfmt->code);\r\nreturn 0;\r\n}\r\nif (!(csi2->output & CSI2_OUTPUT_CCDC) &&\r\n!(csi2->output & CSI2_OUTPUT_MEMORY)) {\r\nreturn CSI2_PIX_FMT_OTHERS;\r\n}\r\ndestidx = csi2->frame_skip ? 0 : !!(csi2->output & CSI2_OUTPUT_CCDC);\r\nis_3630 = csi2->isp->revision == ISP_REVISION_15_0;\r\nreturn __csi2_fmt_map[fmtidx][destidx][csi2->dpcm_decompress][is_3630];\r\n}\r\nstatic void csi2_set_outaddr(struct isp_csi2_device *csi2, u32 addr)\r\n{\r\nstruct isp_device *isp = csi2->isp;\r\nstruct isp_csi2_ctx_cfg *ctx = &csi2->contexts[0];\r\nctx->ping_addr = addr;\r\nctx->pong_addr = addr;\r\nisp_reg_writel(isp, ctx->ping_addr,\r\ncsi2->regs1, ISPCSI2_CTX_DAT_PING_ADDR(ctx->ctxnum));\r\nisp_reg_writel(isp, ctx->pong_addr,\r\ncsi2->regs1, ISPCSI2_CTX_DAT_PONG_ADDR(ctx->ctxnum));\r\n}\r\nstatic inline int is_usr_def_mapping(u32 format_id)\r\n{\r\nreturn (format_id & 0x40) ? 1 : 0;\r\n}\r\nstatic void csi2_ctx_enable(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2, u8 ctxnum, u8 enable)\r\n{\r\nstruct isp_csi2_ctx_cfg *ctx = &csi2->contexts[ctxnum];\r\nunsigned int skip = 0;\r\nu32 reg;\r\nreg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL1(ctxnum));\r\nif (enable) {\r\nif (csi2->frame_skip)\r\nskip = csi2->frame_skip;\r\nelse if (csi2->output & CSI2_OUTPUT_MEMORY)\r\nskip = 1;\r\nreg &= ~ISPCSI2_CTX_CTRL1_COUNT_MASK;\r\nreg |= ISPCSI2_CTX_CTRL1_COUNT_UNLOCK\r\n| (skip << ISPCSI2_CTX_CTRL1_COUNT_SHIFT)\r\n| ISPCSI2_CTX_CTRL1_CTX_EN;\r\n} else {\r\nreg &= ~ISPCSI2_CTX_CTRL1_CTX_EN;\r\n}\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL1(ctxnum));\r\nctx->enabled = enable;\r\n}\r\nstatic void csi2_ctx_config(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2,\r\nstruct isp_csi2_ctx_cfg *ctx)\r\n{\r\nu32 reg;\r\nreg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL1(ctx->ctxnum));\r\nif (ctx->eof_enabled)\r\nreg |= ISPCSI2_CTX_CTRL1_EOF_EN;\r\nelse\r\nreg &= ~ISPCSI2_CTX_CTRL1_EOF_EN;\r\nif (ctx->eol_enabled)\r\nreg |= ISPCSI2_CTX_CTRL1_EOL_EN;\r\nelse\r\nreg &= ~ISPCSI2_CTX_CTRL1_EOL_EN;\r\nif (ctx->checksum_enabled)\r\nreg |= ISPCSI2_CTX_CTRL1_CS_EN;\r\nelse\r\nreg &= ~ISPCSI2_CTX_CTRL1_CS_EN;\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL1(ctx->ctxnum));\r\nreg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL2(ctx->ctxnum));\r\nreg &= ~(ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK);\r\nreg |= ctx->virtual_id << ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;\r\nreg &= ~(ISPCSI2_CTX_CTRL2_FORMAT_MASK);\r\nreg |= ctx->format_id << ISPCSI2_CTX_CTRL2_FORMAT_SHIFT;\r\nif (ctx->dpcm_decompress) {\r\nif (ctx->dpcm_predictor)\r\nreg |= ISPCSI2_CTX_CTRL2_DPCM_PRED;\r\nelse\r\nreg &= ~ISPCSI2_CTX_CTRL2_DPCM_PRED;\r\n}\r\nif (is_usr_def_mapping(ctx->format_id)) {\r\nreg &= ~ISPCSI2_CTX_CTRL2_USER_DEF_MAP_MASK;\r\nreg |= 2 << ISPCSI2_CTX_CTRL2_USER_DEF_MAP_SHIFT;\r\n}\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL2(ctx->ctxnum));\r\nreg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_CTRL3(ctx->ctxnum));\r\nreg &= ~(ISPCSI2_CTX_CTRL3_ALPHA_MASK);\r\nreg |= (ctx->alpha << ISPCSI2_CTX_CTRL3_ALPHA_SHIFT);\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_CTX_CTRL3(ctx->ctxnum));\r\nreg = isp_reg_readl(isp, csi2->regs1,\r\nISPCSI2_CTX_DAT_OFST(ctx->ctxnum));\r\nreg &= ~ISPCSI2_CTX_DAT_OFST_OFST_MASK;\r\nreg |= ctx->data_offset << ISPCSI2_CTX_DAT_OFST_OFST_SHIFT;\r\nisp_reg_writel(isp, reg, csi2->regs1,\r\nISPCSI2_CTX_DAT_OFST(ctx->ctxnum));\r\nisp_reg_writel(isp, ctx->ping_addr,\r\ncsi2->regs1, ISPCSI2_CTX_DAT_PING_ADDR(ctx->ctxnum));\r\nisp_reg_writel(isp, ctx->pong_addr,\r\ncsi2->regs1, ISPCSI2_CTX_DAT_PONG_ADDR(ctx->ctxnum));\r\n}\r\nstatic void csi2_timing_config(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2,\r\nstruct isp_csi2_timing_cfg *timing)\r\n{\r\nu32 reg;\r\nreg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_TIMING);\r\nif (timing->force_rx_mode)\r\nreg |= ISPCSI2_TIMING_FORCE_RX_MODE_IO(timing->ionum);\r\nelse\r\nreg &= ~ISPCSI2_TIMING_FORCE_RX_MODE_IO(timing->ionum);\r\nif (timing->stop_state_16x)\r\nreg |= ISPCSI2_TIMING_STOP_STATE_X16_IO(timing->ionum);\r\nelse\r\nreg &= ~ISPCSI2_TIMING_STOP_STATE_X16_IO(timing->ionum);\r\nif (timing->stop_state_4x)\r\nreg |= ISPCSI2_TIMING_STOP_STATE_X4_IO(timing->ionum);\r\nelse\r\nreg &= ~ISPCSI2_TIMING_STOP_STATE_X4_IO(timing->ionum);\r\nreg &= ~ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(timing->ionum);\r\nreg |= timing->stop_state_counter <<\r\nISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(timing->ionum);\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_TIMING);\r\n}\r\nstatic void csi2_irq_ctx_set(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2, int enable)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nisp_reg_writel(isp, ISPCSI2_CTX_IRQSTATUS_FE_IRQ, csi2->regs1,\r\nISPCSI2_CTX_IRQSTATUS(i));\r\nif (enable)\r\nisp_reg_set(isp, csi2->regs1, ISPCSI2_CTX_IRQENABLE(i),\r\nISPCSI2_CTX_IRQSTATUS_FE_IRQ);\r\nelse\r\nisp_reg_clr(isp, csi2->regs1, ISPCSI2_CTX_IRQENABLE(i),\r\nISPCSI2_CTX_IRQSTATUS_FE_IRQ);\r\n}\r\n}\r\nstatic void csi2_irq_complexio1_set(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2, int enable)\r\n{\r\nu32 reg;\r\nreg = ISPCSI2_PHY_IRQENABLE_STATEALLULPMEXIT |\r\nISPCSI2_PHY_IRQENABLE_STATEALLULPMENTER |\r\nISPCSI2_PHY_IRQENABLE_STATEULPM5 |\r\nISPCSI2_PHY_IRQENABLE_ERRCONTROL5 |\r\nISPCSI2_PHY_IRQENABLE_ERRESC5 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS5 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTHS5 |\r\nISPCSI2_PHY_IRQENABLE_STATEULPM4 |\r\nISPCSI2_PHY_IRQENABLE_ERRCONTROL4 |\r\nISPCSI2_PHY_IRQENABLE_ERRESC4 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS4 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTHS4 |\r\nISPCSI2_PHY_IRQENABLE_STATEULPM3 |\r\nISPCSI2_PHY_IRQENABLE_ERRCONTROL3 |\r\nISPCSI2_PHY_IRQENABLE_ERRESC3 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS3 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTHS3 |\r\nISPCSI2_PHY_IRQENABLE_STATEULPM2 |\r\nISPCSI2_PHY_IRQENABLE_ERRCONTROL2 |\r\nISPCSI2_PHY_IRQENABLE_ERRESC2 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS2 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTHS2 |\r\nISPCSI2_PHY_IRQENABLE_STATEULPM1 |\r\nISPCSI2_PHY_IRQENABLE_ERRCONTROL1 |\r\nISPCSI2_PHY_IRQENABLE_ERRESC1 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTSYNCHS1 |\r\nISPCSI2_PHY_IRQENABLE_ERRSOTHS1;\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_PHY_IRQSTATUS);\r\nif (enable)\r\nreg |= isp_reg_readl(isp, csi2->regs1, ISPCSI2_PHY_IRQENABLE);\r\nelse\r\nreg = 0;\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_PHY_IRQENABLE);\r\n}\r\nstatic void csi2_irq_status_set(struct isp_device *isp,\r\nstruct isp_csi2_device *csi2, int enable)\r\n{\r\nu32 reg;\r\nreg = ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |\r\nISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |\r\nISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ |\r\nISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |\r\nISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |\r\nISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ |\r\nISPCSI2_IRQSTATUS_FIFO_OVF_IRQ |\r\nISPCSI2_IRQSTATUS_CONTEXT(0);\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_IRQSTATUS);\r\nif (enable)\r\nreg |= isp_reg_readl(isp, csi2->regs1, ISPCSI2_IRQENABLE);\r\nelse\r\nreg = 0;\r\nisp_reg_writel(isp, reg, csi2->regs1, ISPCSI2_IRQENABLE);\r\n}\r\nint omap3isp_csi2_reset(struct isp_csi2_device *csi2)\r\n{\r\nstruct isp_device *isp = csi2->isp;\r\nu8 soft_reset_retries = 0;\r\nu32 reg;\r\nint i;\r\nif (!csi2->available)\r\nreturn -ENODEV;\r\nif (csi2->phy->phy_in_use)\r\nreturn -EBUSY;\r\nisp_reg_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,\r\nISPCSI2_SYSCONFIG_SOFT_RESET);\r\ndo {\r\nreg = isp_reg_readl(isp, csi2->regs1, ISPCSI2_SYSSTATUS) &\r\nISPCSI2_SYSSTATUS_RESET_DONE;\r\nif (reg == ISPCSI2_SYSSTATUS_RESET_DONE)\r\nbreak;\r\nsoft_reset_retries++;\r\nif (soft_reset_retries < 5)\r\nudelay(100);\r\n} while (soft_reset_retries < 5);\r\nif (soft_reset_retries == 5) {\r\nprintk(KERN_ERR "CSI2: Soft reset try count exceeded!\n");\r\nreturn -EBUSY;\r\n}\r\nif (isp->revision == ISP_REVISION_15_0)\r\nisp_reg_set(isp, csi2->regs1, ISPCSI2_PHY_CFG,\r\nISPCSI2_PHY_CFG_RESET_CTRL);\r\ni = 100;\r\ndo {\r\nreg = isp_reg_readl(isp, csi2->phy->phy_regs, ISPCSIPHY_REG1)\r\n& ISPCSIPHY_REG1_RESET_DONE_CTRLCLK;\r\nif (reg == ISPCSIPHY_REG1_RESET_DONE_CTRLCLK)\r\nbreak;\r\nudelay(100);\r\n} while (--i > 0);\r\nif (i == 0) {\r\nprintk(KERN_ERR\r\n"CSI2: Reset for CSI2_96M_FCLK domain Failed!\n");\r\nreturn -EBUSY;\r\n}\r\nif (isp->autoidle)\r\nisp_reg_clr_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,\r\nISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK |\r\nISPCSI2_SYSCONFIG_AUTO_IDLE,\r\nISPCSI2_SYSCONFIG_MSTANDBY_MODE_SMART |\r\n((isp->revision == ISP_REVISION_15_0) ?\r\nISPCSI2_SYSCONFIG_AUTO_IDLE : 0));\r\nelse\r\nisp_reg_clr_set(isp, csi2->regs1, ISPCSI2_SYSCONFIG,\r\nISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK |\r\nISPCSI2_SYSCONFIG_AUTO_IDLE,\r\nISPCSI2_SYSCONFIG_MSTANDBY_MODE_NO);\r\nreturn 0;\r\n}\r\nstatic int csi2_configure(struct isp_csi2_device *csi2)\r\n{\r\nconst struct isp_v4l2_subdevs_group *pdata;\r\nstruct isp_device *isp = csi2->isp;\r\nstruct isp_csi2_timing_cfg *timing = &csi2->timing[0];\r\nstruct v4l2_subdev *sensor;\r\nstruct media_pad *pad;\r\nif (csi2->contexts[0].enabled || csi2->ctrl.if_enable)\r\nreturn -EBUSY;\r\npad = media_entity_remote_source(&csi2->pads[CSI2_PAD_SINK]);\r\nsensor = media_entity_to_v4l2_subdev(pad->entity);\r\npdata = sensor->host_priv;\r\ncsi2->frame_skip = 0;\r\nv4l2_subdev_call(sensor, sensor, g_skip_frames, &csi2->frame_skip);\r\ncsi2->ctrl.vp_out_ctrl = pdata->bus.csi2.vpclk_div;\r\ncsi2->ctrl.frame_mode = ISP_CSI2_FRAME_IMMEDIATE;\r\ncsi2->ctrl.ecc_enable = pdata->bus.csi2.crc;\r\ntiming->ionum = 1;\r\ntiming->force_rx_mode = 1;\r\ntiming->stop_state_16x = 1;\r\ntiming->stop_state_4x = 1;\r\ntiming->stop_state_counter = 0x1FF;\r\nif (csi2->formats[CSI2_PAD_SINK].code !=\r\ncsi2->formats[CSI2_PAD_SOURCE].code)\r\ncsi2->dpcm_decompress = true;\r\nelse\r\ncsi2->dpcm_decompress = false;\r\ncsi2->contexts[0].format_id = csi2_ctx_map_format(csi2);\r\nif (csi2->video_out.bpl_padding == 0)\r\ncsi2->contexts[0].data_offset = 0;\r\nelse\r\ncsi2->contexts[0].data_offset = csi2->video_out.bpl_value;\r\ncsi2->contexts[0].eof_enabled = 1;\r\ncsi2->contexts[0].eol_enabled = 1;\r\ncsi2_irq_complexio1_set(isp, csi2, 1);\r\ncsi2_irq_ctx_set(isp, csi2, 1);\r\ncsi2_irq_status_set(isp, csi2, 1);\r\ncsi2_timing_config(isp, csi2, timing);\r\ncsi2_recv_config(isp, csi2, &csi2->ctrl);\r\ncsi2_ctx_config(isp, csi2, &csi2->contexts[0]);\r\nreturn 0;\r\n}\r\nstatic void csi2_print_status(struct isp_csi2_device *csi2)\r\n{\r\nstruct isp_device *isp = csi2->isp;\r\nif (!csi2->available)\r\nreturn;\r\ndev_dbg(isp->dev, "-------------CSI2 Register dump-------------\n");\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, SYSCONFIG);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, SYSSTATUS);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, IRQENABLE);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, IRQSTATUS);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTRL);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, DBG_H);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, GNQ);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_CFG);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_IRQSTATUS);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, SHORT_PACKET);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, PHY_IRQENABLE);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, DBG_P);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, TIMING);\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL1(0));\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL2(0));\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_OFST(0));\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_PING_ADDR(0));\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_DAT_PONG_ADDR(0));\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_IRQENABLE(0));\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_IRQSTATUS(0));\r\nCSI2_PRINT_REGISTER(isp, csi2->regs1, CTX_CTRL3(0));\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nstatic void csi2_isr_buffer(struct isp_csi2_device *csi2)\r\n{\r\nstruct isp_device *isp = csi2->isp;\r\nstruct isp_buffer *buffer;\r\ncsi2_ctx_enable(isp, csi2, 0, 0);\r\nbuffer = omap3isp_video_buffer_next(&csi2->video_out);\r\nif (buffer == NULL)\r\nreturn;\r\ncsi2_set_outaddr(csi2, buffer->isp_addr);\r\ncsi2_ctx_enable(isp, csi2, 0, 1);\r\n}\r\nstatic void csi2_isr_ctx(struct isp_csi2_device *csi2,\r\nstruct isp_csi2_ctx_cfg *ctx)\r\n{\r\nstruct isp_device *isp = csi2->isp;\r\nunsigned int n = ctx->ctxnum;\r\nu32 status;\r\nstatus = isp_reg_readl(isp, csi2->regs1, ISPCSI2_CTX_IRQSTATUS(n));\r\nisp_reg_writel(isp, status, csi2->regs1, ISPCSI2_CTX_IRQSTATUS(n));\r\nif (!(status & ISPCSI2_CTX_IRQSTATUS_FE_IRQ))\r\nreturn;\r\nif (csi2->frame_skip) {\r\ncsi2->frame_skip--;\r\nif (csi2->frame_skip == 0) {\r\nctx->format_id = csi2_ctx_map_format(csi2);\r\ncsi2_ctx_config(isp, csi2, ctx);\r\ncsi2_ctx_enable(isp, csi2, n, 1);\r\n}\r\nreturn;\r\n}\r\nif (csi2->output & CSI2_OUTPUT_MEMORY)\r\ncsi2_isr_buffer(csi2);\r\n}\r\nvoid omap3isp_csi2_isr(struct isp_csi2_device *csi2)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&csi2->subdev.entity);\r\nu32 csi2_irqstatus, cpxio1_irqstatus;\r\nstruct isp_device *isp = csi2->isp;\r\nif (!csi2->available)\r\nreturn;\r\ncsi2_irqstatus = isp_reg_readl(isp, csi2->regs1, ISPCSI2_IRQSTATUS);\r\nisp_reg_writel(isp, csi2_irqstatus, csi2->regs1, ISPCSI2_IRQSTATUS);\r\nif (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ) {\r\ncpxio1_irqstatus = isp_reg_readl(isp, csi2->regs1,\r\nISPCSI2_PHY_IRQSTATUS);\r\nisp_reg_writel(isp, cpxio1_irqstatus,\r\ncsi2->regs1, ISPCSI2_PHY_IRQSTATUS);\r\ndev_dbg(isp->dev, "CSI2: ComplexIO Error IRQ "\r\n"%x\n", cpxio1_irqstatus);\r\npipe->error = true;\r\n}\r\nif (csi2_irqstatus & (ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |\r\nISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |\r\nISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |\r\nISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |\r\nISPCSI2_IRQSTATUS_FIFO_OVF_IRQ)) {\r\ndev_dbg(isp->dev, "CSI2 Err:"\r\n" OCP:%d,"\r\n" Short_pack:%d,"\r\n" ECC:%d,"\r\n" CPXIO2:%d,"\r\n" FIFO_OVF:%d,"\r\n"\n",\r\n(csi2_irqstatus &\r\nISPCSI2_IRQSTATUS_OCP_ERR_IRQ) ? 1 : 0,\r\n(csi2_irqstatus &\r\nISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ) ? 1 : 0,\r\n(csi2_irqstatus &\r\nISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ) ? 1 : 0,\r\n(csi2_irqstatus &\r\nISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ) ? 1 : 0,\r\n(csi2_irqstatus &\r\nISPCSI2_IRQSTATUS_FIFO_OVF_IRQ) ? 1 : 0);\r\npipe->error = true;\r\n}\r\nif (omap3isp_module_sync_is_stopping(&csi2->wait, &csi2->stopping))\r\nreturn;\r\nif (csi2_irqstatus & ISPCSI2_IRQSTATUS_CONTEXT(0))\r\ncsi2_isr_ctx(csi2, &csi2->contexts[0]);\r\nif (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ)\r\ndev_dbg(isp->dev, "CSI2: ECC correction done\n");\r\n}\r\nstatic int csi2_queue(struct isp_video *video, struct isp_buffer *buffer)\r\n{\r\nstruct isp_device *isp = video->isp;\r\nstruct isp_csi2_device *csi2 = &isp->isp_csi2a;\r\ncsi2_set_outaddr(csi2, buffer->isp_addr);\r\nif (csi2->video_out.dmaqueue_flags & ISP_VIDEO_DMAQUEUE_UNDERRUN) {\r\ncsi2_if_enable(isp, csi2, 1);\r\ncsi2_ctx_enable(isp, csi2, 0, 1);\r\nisp_video_dmaqueue_flags_clr(&csi2->video_out);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__csi2_get_format(struct isp_csi2_device *csi2, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\nelse\r\nreturn &csi2->formats[pad];\r\n}\r\nstatic void\r\ncsi2_try_format(struct isp_csi2_device *csi2, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, struct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nenum v4l2_mbus_pixelcode pixelcode;\r\nstruct v4l2_mbus_framefmt *format;\r\nconst struct isp_format_info *info;\r\nunsigned int i;\r\nswitch (pad) {\r\ncase CSI2_PAD_SINK:\r\nfor (i = 0; i < ARRAY_SIZE(csi2_input_fmts); i++) {\r\nif (fmt->code == csi2_input_fmts[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(csi2_input_fmts))\r\nfmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nfmt->width = clamp_t(u32, fmt->width, 1, 8191);\r\nfmt->height = clamp_t(u32, fmt->height, 1, 8191);\r\nbreak;\r\ncase CSI2_PAD_SOURCE:\r\npixelcode = fmt->code;\r\nformat = __csi2_get_format(csi2, fh, CSI2_PAD_SINK, which);\r\nmemcpy(fmt, format, sizeof(*fmt));\r\ninfo = omap3isp_video_format_info(fmt->code);\r\nif (info->uncompressed == pixelcode)\r\nfmt->code = pixelcode;\r\nbreak;\r\n}\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int csi2_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nconst struct isp_format_info *info;\r\nif (code->pad == CSI2_PAD_SINK) {\r\nif (code->index >= ARRAY_SIZE(csi2_input_fmts))\r\nreturn -EINVAL;\r\ncode->code = csi2_input_fmts[code->index];\r\n} else {\r\nformat = __csi2_get_format(csi2, fh, CSI2_PAD_SINK,\r\nV4L2_SUBDEV_FORMAT_TRY);\r\nswitch (code->index) {\r\ncase 0:\r\ncode->code = format->code;\r\nbreak;\r\ncase 1:\r\ninfo = omap3isp_video_format_info(format->code);\r\nif (info->uncompressed == format->code)\r\nreturn -EINVAL;\r\ncode->code = info->uncompressed;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int csi2_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\ncsi2_try_format(csi2, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\ncsi2_try_format(csi2, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int csi2_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __csi2_get_format(csi2, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int csi2_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __csi2_get_format(csi2, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\ncsi2_try_format(csi2, fh, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == CSI2_PAD_SINK) {\r\nformat = __csi2_get_format(csi2, fh, CSI2_PAD_SOURCE,\r\nfmt->which);\r\n*format = fmt->format;\r\ncsi2_try_format(csi2, fh, CSI2_PAD_SOURCE, format, fmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstatic int csi2_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = CSI2_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\ncsi2_set_format(sd, fh, &format);\r\nreturn 0;\r\n}\r\nstatic int csi2_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct isp_device *isp = csi2->isp;\r\nstruct isp_video *video_out = &csi2->video_out;\r\nswitch (enable) {\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (omap3isp_csiphy_acquire(csi2->phy) < 0)\r\nreturn -ENODEV;\r\nif (csi2->output & CSI2_OUTPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CSI2A_WRITE);\r\ncsi2_configure(csi2);\r\ncsi2_print_status(csi2);\r\nif (csi2->output & CSI2_OUTPUT_MEMORY &&\r\n!(video_out->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED))\r\nbreak;\r\natomic_set(&csi2->stopping, 0);\r\ncsi2_ctx_enable(isp, csi2, 0, 1);\r\ncsi2_if_enable(isp, csi2, 1);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\nif (csi2->state == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nif (omap3isp_module_sync_idle(&sd->entity, &csi2->wait,\r\n&csi2->stopping))\r\ndev_dbg(isp->dev, "%s: module stop timeout.\n",\r\nsd->name);\r\ncsi2_ctx_enable(isp, csi2, 0, 0);\r\ncsi2_if_enable(isp, csi2, 0);\r\ncsi2_irq_ctx_set(isp, csi2, 0);\r\nomap3isp_csiphy_release(csi2->phy);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_CSI2A_WRITE);\r\nbreak;\r\n}\r\ncsi2->state = enable;\r\nreturn 0;\r\n}\r\nstatic int csi2_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct isp_csi2_device *csi2 = v4l2_get_subdevdata(sd);\r\nstruct isp_csi2_ctrl_cfg *ctrl = &csi2->ctrl;\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase CSI2_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (csi2->output & ~CSI2_OUTPUT_MEMORY)\r\nreturn -EBUSY;\r\ncsi2->output |= CSI2_OUTPUT_MEMORY;\r\n} else {\r\ncsi2->output &= ~CSI2_OUTPUT_MEMORY;\r\n}\r\nbreak;\r\ncase CSI2_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (csi2->output & ~CSI2_OUTPUT_CCDC)\r\nreturn -EBUSY;\r\ncsi2->output |= CSI2_OUTPUT_CCDC;\r\n} else {\r\ncsi2->output &= ~CSI2_OUTPUT_CCDC;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl->vp_only_enable =\r\n(csi2->output & CSI2_OUTPUT_MEMORY) ? false : true;\r\nctrl->vp_clk_enable = !!(csi2->output & CSI2_OUTPUT_CCDC);\r\nreturn 0;\r\n}\r\nvoid omap3isp_csi2_unregister_entities(struct isp_csi2_device *csi2)\r\n{\r\nv4l2_device_unregister_subdev(&csi2->subdev);\r\nomap3isp_video_unregister(&csi2->video_out);\r\n}\r\nint omap3isp_csi2_register_entities(struct isp_csi2_device *csi2,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &csi2->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&csi2->video_out, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap3isp_csi2_unregister_entities(csi2);\r\nreturn ret;\r\n}\r\nstatic int csi2_init_entities(struct isp_csi2_device *csi2)\r\n{\r\nstruct v4l2_subdev *sd = &csi2->subdev;\r\nstruct media_pad *pads = csi2->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nv4l2_subdev_init(sd, &csi2_ops);\r\nsd->internal_ops = &csi2_internal_ops;\r\nstrlcpy(sd->name, "OMAP3 ISP CSI2a", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, csi2);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\npads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\nme->ops = &csi2_media_ops;\r\nret = media_entity_init(me, CSI2_PADS_NUM, pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\ncsi2_init_formats(sd, NULL);\r\ncsi2->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncsi2->video_out.ops = &csi2_ispvideo_ops;\r\ncsi2->video_out.bpl_alignment = 32;\r\ncsi2->video_out.bpl_zero_padding = 1;\r\ncsi2->video_out.bpl_max = 0x1ffe0;\r\ncsi2->video_out.isp = csi2->isp;\r\ncsi2->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\r\nret = omap3isp_video_init(&csi2->video_out, "CSI2a");\r\nif (ret < 0)\r\ngoto error_video;\r\nret = media_entity_create_link(&csi2->subdev.entity, CSI2_PAD_SOURCE,\r\n&csi2->video_out.video.entity, 0, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nreturn 0;\r\nerror_link:\r\nomap3isp_video_cleanup(&csi2->video_out);\r\nerror_video:\r\nmedia_entity_cleanup(&csi2->subdev.entity);\r\nreturn ret;\r\n}\r\nint omap3isp_csi2_init(struct isp_device *isp)\r\n{\r\nstruct isp_csi2_device *csi2a = &isp->isp_csi2a;\r\nstruct isp_csi2_device *csi2c = &isp->isp_csi2c;\r\nint ret;\r\ncsi2a->isp = isp;\r\ncsi2a->available = 1;\r\ncsi2a->regs1 = OMAP3_ISP_IOMEM_CSI2A_REGS1;\r\ncsi2a->regs2 = OMAP3_ISP_IOMEM_CSI2A_REGS2;\r\ncsi2a->phy = &isp->isp_csiphy2;\r\ncsi2a->state = ISP_PIPELINE_STREAM_STOPPED;\r\ninit_waitqueue_head(&csi2a->wait);\r\nret = csi2_init_entities(csi2a);\r\nif (ret < 0)\r\nreturn ret;\r\nif (isp->revision == ISP_REVISION_15_0) {\r\ncsi2c->isp = isp;\r\ncsi2c->available = 1;\r\ncsi2c->regs1 = OMAP3_ISP_IOMEM_CSI2C_REGS1;\r\ncsi2c->regs2 = OMAP3_ISP_IOMEM_CSI2C_REGS2;\r\ncsi2c->phy = &isp->isp_csiphy1;\r\ncsi2c->state = ISP_PIPELINE_STREAM_STOPPED;\r\ninit_waitqueue_head(&csi2c->wait);\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3isp_csi2_cleanup(struct isp_device *isp)\r\n{\r\nstruct isp_csi2_device *csi2a = &isp->isp_csi2a;\r\nomap3isp_video_cleanup(&csi2a->video_out);\r\nmedia_entity_cleanup(&csi2a->subdev.entity);\r\n}
