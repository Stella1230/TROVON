static inline u32 dwc3_omap_readl(void __iomem *base, u32 offset)\r\n{\r\nreturn readl(base + offset);\r\n}\r\nstatic inline void dwc3_omap_writel(void __iomem *base, u32 offset, u32 value)\r\n{\r\nwritel(value, base + offset);\r\n}\r\nstatic irqreturn_t dwc3_omap_interrupt(int irq, void *_omap)\r\n{\r\nstruct dwc3_omap *omap = _omap;\r\nu32 reg;\r\nspin_lock(&omap->lock);\r\nreg = dwc3_omap_readl(omap->base, USBOTGSS_IRQSTATUS_1);\r\nif (reg & USBOTGSS_IRQ1_DMADISABLECLR) {\r\ndev_dbg(omap->dev, "DMA Disable was Cleared\n");\r\nomap->dma_status = false;\r\n}\r\nif (reg & USBOTGSS_IRQ1_OEVT)\r\ndev_dbg(omap->dev, "OTG Event\n");\r\nif (reg & USBOTGSS_IRQ1_DRVVBUS_RISE)\r\ndev_dbg(omap->dev, "DRVVBUS Rise\n");\r\nif (reg & USBOTGSS_IRQ1_CHRGVBUS_RISE)\r\ndev_dbg(omap->dev, "CHRGVBUS Rise\n");\r\nif (reg & USBOTGSS_IRQ1_DISCHRGVBUS_RISE)\r\ndev_dbg(omap->dev, "DISCHRGVBUS Rise\n");\r\nif (reg & USBOTGSS_IRQ1_IDPULLUP_RISE)\r\ndev_dbg(omap->dev, "IDPULLUP Rise\n");\r\nif (reg & USBOTGSS_IRQ1_DRVVBUS_FALL)\r\ndev_dbg(omap->dev, "DRVVBUS Fall\n");\r\nif (reg & USBOTGSS_IRQ1_CHRGVBUS_FALL)\r\ndev_dbg(omap->dev, "CHRGVBUS Fall\n");\r\nif (reg & USBOTGSS_IRQ1_DISCHRGVBUS_FALL)\r\ndev_dbg(omap->dev, "DISCHRGVBUS Fall\n");\r\nif (reg & USBOTGSS_IRQ1_IDPULLUP_FALL)\r\ndev_dbg(omap->dev, "IDPULLUP Fall\n");\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQSTATUS_1, reg);\r\nreg = dwc3_omap_readl(omap->base, USBOTGSS_IRQSTATUS_0);\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQSTATUS_0, reg);\r\nspin_unlock(&omap->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit dwc3_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct dwc3_omap_data *pdata = pdev->dev.platform_data;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct platform_device *dwc3;\r\nstruct dwc3_omap *omap;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nint devid;\r\nint size;\r\nint ret = -ENOMEM;\r\nint irq;\r\nconst u32 *utmi_mode;\r\nu32 reg;\r\nvoid __iomem *base;\r\nvoid *context;\r\nomap = devm_kzalloc(dev, sizeof(*omap), GFP_KERNEL);\r\nif (!omap) {\r\ndev_err(dev, "not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, omap);\r\nirq = platform_get_irq(pdev, 1);\r\nif (irq < 0) {\r\ndev_err(dev, "missing IRQ resource\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(dev, "missing memory base resource\n");\r\nreturn -EINVAL;\r\n}\r\nbase = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!base) {\r\ndev_err(dev, "ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndevid = dwc3_get_device_id();\r\nif (devid < 0)\r\nreturn -ENODEV;\r\ndwc3 = platform_device_alloc("dwc3", devid);\r\nif (!dwc3) {\r\ndev_err(dev, "couldn't allocate dwc3 device\n");\r\ngoto err1;\r\n}\r\ncontext = devm_kzalloc(dev, resource_size(res), GFP_KERNEL);\r\nif (!context) {\r\ndev_err(dev, "couldn't allocate dwc3 context memory\n");\r\ngoto err2;\r\n}\r\nspin_lock_init(&omap->lock);\r\ndma_set_coherent_mask(&dwc3->dev, dev->coherent_dma_mask);\r\ndwc3->dev.parent = dev;\r\ndwc3->dev.dma_mask = dev->dma_mask;\r\ndwc3->dev.dma_parms = dev->dma_parms;\r\nomap->resource_size = resource_size(res);\r\nomap->context = context;\r\nomap->dev = dev;\r\nomap->irq = irq;\r\nomap->base = base;\r\nomap->dwc3 = dwc3;\r\nreg = dwc3_omap_readl(omap->base, USBOTGSS_UTMI_OTG_STATUS);\r\nutmi_mode = of_get_property(node, "utmi-mode", &size);\r\nif (utmi_mode && size == sizeof(*utmi_mode)) {\r\nreg |= *utmi_mode;\r\n} else {\r\nif (!pdata) {\r\ndev_dbg(dev, "missing platform data\n");\r\n} else {\r\nswitch (pdata->utmi_mode) {\r\ncase DWC3_OMAP_UTMI_MODE_SW:\r\nreg |= USBOTGSS_UTMI_OTG_STATUS_SW_MODE;\r\nbreak;\r\ncase DWC3_OMAP_UTMI_MODE_HW:\r\nreg &= ~USBOTGSS_UTMI_OTG_STATUS_SW_MODE;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "UNKNOWN utmi mode %d\n",\r\npdata->utmi_mode);\r\n}\r\n}\r\n}\r\ndwc3_omap_writel(omap->base, USBOTGSS_UTMI_OTG_STATUS, reg);\r\nreg = dwc3_omap_readl(omap->base, USBOTGSS_SYSCONFIG);\r\nomap->dma_status = !!(reg & USBOTGSS_SYSCONFIG_DMADISABLE);\r\nreg &= ~(USBOTGSS_STANDBYMODE_MASK\r\n| USBOTGSS_IDLEMODE_MASK);\r\nreg |= (USBOTGSS_SYSCONFIG_STANDBYMODE(USBOTGSS_STANDBYMODE_NO_STANDBY)\r\n| USBOTGSS_SYSCONFIG_IDLEMODE(USBOTGSS_IDLEMODE_NO_IDLE));\r\ndwc3_omap_writel(omap->base, USBOTGSS_SYSCONFIG, reg);\r\nret = devm_request_irq(dev, omap->irq, dwc3_omap_interrupt, 0,\r\n"dwc3-omap", omap);\r\nif (ret) {\r\ndev_err(dev, "failed to request IRQ #%d --> %d\n",\r\nomap->irq, ret);\r\ngoto err2;\r\n}\r\nreg = USBOTGSS_IRQO_COREIRQ_ST;\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_SET_0, reg);\r\nreg = (USBOTGSS_IRQ1_OEVT |\r\nUSBOTGSS_IRQ1_DRVVBUS_RISE |\r\nUSBOTGSS_IRQ1_CHRGVBUS_RISE |\r\nUSBOTGSS_IRQ1_DISCHRGVBUS_RISE |\r\nUSBOTGSS_IRQ1_IDPULLUP_RISE |\r\nUSBOTGSS_IRQ1_DRVVBUS_FALL |\r\nUSBOTGSS_IRQ1_CHRGVBUS_FALL |\r\nUSBOTGSS_IRQ1_DISCHRGVBUS_FALL |\r\nUSBOTGSS_IRQ1_IDPULLUP_FALL);\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_SET_1, reg);\r\nret = platform_device_add_resources(dwc3, pdev->resource,\r\npdev->num_resources);\r\nif (ret) {\r\ndev_err(dev, "couldn't add resources to dwc3 device\n");\r\ngoto err2;\r\n}\r\nret = platform_device_add(dwc3);\r\nif (ret) {\r\ndev_err(dev, "failed to register dwc3 device\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nplatform_device_put(dwc3);\r\nerr1:\r\ndwc3_put_device_id(devid);\r\nreturn ret;\r\n}\r\nstatic int __devexit dwc3_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct dwc3_omap *omap = platform_get_drvdata(pdev);\r\nplatform_device_unregister(omap->dwc3);\r\ndwc3_put_device_id(omap->dwc3->id);\r\nreturn 0;\r\n}
