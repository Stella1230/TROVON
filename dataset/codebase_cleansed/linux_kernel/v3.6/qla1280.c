static inline uint16_t\r\nqla1280_data_direction(struct scsi_cmnd *cmnd)\r\n{\r\nswitch(cmnd->sc_data_direction) {\r\ncase DMA_FROM_DEVICE:\r\nreturn BIT_5;\r\ncase DMA_TO_DEVICE:\r\nreturn BIT_6;\r\ncase DMA_BIDIRECTIONAL:\r\nreturn BIT_5 | BIT_6;\r\ncase DMA_NONE:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int qla1280_read_nvram(struct scsi_qla_host *ha)\r\n{\r\nuint16_t *wptr;\r\nuint8_t chksum;\r\nint cnt, i;\r\nstruct nvram *nv;\r\nENTER("qla1280_read_nvram");\r\nif (driver_setup.no_nvram)\r\nreturn 1;\r\nprintk(KERN_INFO "scsi(%ld): Reading NVRAM\n", ha->host_no);\r\nwptr = (uint16_t *)&ha->nvram;\r\nnv = &ha->nvram;\r\nchksum = 0;\r\nfor (cnt = 0; cnt < 3; cnt++) {\r\n*wptr = qla1280_get_nvram_word(ha, cnt);\r\nchksum += *wptr & 0xff;\r\nchksum += (*wptr >> 8) & 0xff;\r\nwptr++;\r\n}\r\nif (nv->id0 != 'I' || nv->id1 != 'S' ||\r\nnv->id2 != 'P' || nv->id3 != ' ' || nv->version < 1) {\r\ndprintk(2, "Invalid nvram ID or version!\n");\r\nchksum = 1;\r\n} else {\r\nfor (; cnt < sizeof(struct nvram); cnt++) {\r\n*wptr = qla1280_get_nvram_word(ha, cnt);\r\nchksum += *wptr & 0xff;\r\nchksum += (*wptr >> 8) & 0xff;\r\nwptr++;\r\n}\r\n}\r\ndprintk(3, "qla1280_read_nvram: NVRAM Magic ID= %c %c %c %02x"\r\n" version %i\n", nv->id0, nv->id1, nv->id2, nv->id3,\r\nnv->version);\r\nif (chksum) {\r\nif (!driver_setup.no_nvram)\r\nprintk(KERN_WARNING "scsi(%ld): Unable to identify or "\r\n"validate NVRAM checksum, using default "\r\n"settings\n", ha->host_no);\r\nha->nvram_valid = 0;\r\n} else\r\nha->nvram_valid = 1;\r\nnv->isp_parameter = cpu_to_le16(nv->isp_parameter);\r\nnv->firmware_feature.w = cpu_to_le16(nv->firmware_feature.w);\r\nfor(i = 0; i < MAX_BUSES; i++) {\r\nnv->bus[i].selection_timeout = cpu_to_le16(nv->bus[i].selection_timeout);\r\nnv->bus[i].max_queue_depth = cpu_to_le16(nv->bus[i].max_queue_depth);\r\n}\r\ndprintk(1, "qla1280_read_nvram: Completed Reading NVRAM\n");\r\nLEAVE("qla1280_read_nvram");\r\nreturn chksum;\r\n}\r\nstatic const char *\r\nqla1280_info(struct Scsi_Host *host)\r\n{\r\nstatic char qla1280_scsi_name_buffer[125];\r\nchar *bp;\r\nstruct scsi_qla_host *ha;\r\nstruct qla_boards *bdp;\r\nbp = &qla1280_scsi_name_buffer[0];\r\nha = (struct scsi_qla_host *)host->hostdata;\r\nbdp = &ql1280_board_tbl[ha->devnum];\r\nmemset(bp, 0, sizeof(qla1280_scsi_name_buffer));\r\nsprintf (bp,\r\n"QLogic %s PCI to SCSI Host Adapter\n"\r\n" Firmware version: %2d.%02d.%02d, Driver version %s",\r\n&bdp->name[0], ha->fwver1, ha->fwver2, ha->fwver3,\r\nQLA1280_VERSION);\r\nreturn bp;\r\n}\r\nstatic int\r\nqla1280_queuecommand_lck(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;\r\nstruct srb *sp = (struct srb *)CMD_SP(cmd);\r\nint status;\r\ncmd->scsi_done = fn;\r\nsp->cmd = cmd;\r\nsp->flags = 0;\r\nsp->wait = NULL;\r\nCMD_HANDLE(cmd) = (unsigned char *)NULL;\r\nqla1280_print_scsi_cmd(5, cmd);\r\n#ifdef QLA_64BIT_PTR\r\nstatus = qla1280_64bit_start_scsi(ha, sp);\r\n#else\r\nstatus = qla1280_32bit_start_scsi(ha, sp);\r\n#endif\r\nreturn status;\r\n}\r\nstatic void qla1280_mailbox_timeout(unsigned long __data)\r\n{\r\nstruct scsi_qla_host *ha = (struct scsi_qla_host *)__data;\r\nstruct device_reg __iomem *reg;\r\nreg = ha->iobase;\r\nha->mailbox_out[0] = RD_REG_WORD(&reg->mailbox0);\r\nprintk(KERN_ERR "scsi(%ld): mailbox timed out, mailbox0 %04x, "\r\n"ictrl %04x, istatus %04x\n", ha->host_no, ha->mailbox_out[0],\r\nRD_REG_WORD(&reg->ictrl), RD_REG_WORD(&reg->istatus));\r\ncomplete(ha->mailbox_wait);\r\n}\r\nstatic int\r\n_qla1280_wait_for_single_command(struct scsi_qla_host *ha, struct srb *sp,\r\nstruct completion *wait)\r\n{\r\nint status = FAILED;\r\nstruct scsi_cmnd *cmd = sp->cmd;\r\nspin_unlock_irq(ha->host->host_lock);\r\nwait_for_completion_timeout(wait, 4*HZ);\r\nspin_lock_irq(ha->host->host_lock);\r\nsp->wait = NULL;\r\nif(CMD_HANDLE(cmd) == COMPLETED_HANDLE) {\r\nstatus = SUCCESS;\r\n(*cmd->scsi_done)(cmd);\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_wait_for_single_command(struct scsi_qla_host *ha, struct srb *sp)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nsp->wait = &wait;\r\nreturn _qla1280_wait_for_single_command(ha, sp, &wait);\r\n}\r\nstatic int\r\nqla1280_wait_for_pending_commands(struct scsi_qla_host *ha, int bus, int target)\r\n{\r\nint cnt;\r\nint status;\r\nstruct srb *sp;\r\nstruct scsi_cmnd *cmd;\r\nstatus = SUCCESS;\r\nfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {\r\nsp = ha->outstanding_cmds[cnt];\r\nif (sp) {\r\ncmd = sp->cmd;\r\nif (bus >= 0 && SCSI_BUS_32(cmd) != bus)\r\ncontinue;\r\nif (target >= 0 && SCSI_TCN_32(cmd) != target)\r\ncontinue;\r\nstatus = qla1280_wait_for_single_command(ha, sp);\r\nif (status == FAILED)\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_error_action(struct scsi_cmnd *cmd, enum action action)\r\n{\r\nstruct scsi_qla_host *ha;\r\nint bus, target, lun;\r\nstruct srb *sp;\r\nint i, found;\r\nint result=FAILED;\r\nint wait_for_bus=-1;\r\nint wait_for_target = -1;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nENTER("qla1280_error_action");\r\nha = (struct scsi_qla_host *)(CMD_HOST(cmd)->hostdata);\r\nsp = (struct srb *)CMD_SP(cmd);\r\nbus = SCSI_BUS_32(cmd);\r\ntarget = SCSI_TCN_32(cmd);\r\nlun = SCSI_LUN_32(cmd);\r\ndprintk(4, "error_action %i, istatus 0x%04x\n", action,\r\nRD_REG_WORD(&ha->iobase->istatus));\r\ndprintk(4, "host_cmd 0x%04x, ictrl 0x%04x, jiffies %li\n",\r\nRD_REG_WORD(&ha->iobase->host_cmd),\r\nRD_REG_WORD(&ha->iobase->ictrl), jiffies);\r\nif (qla1280_verbose)\r\nprintk(KERN_INFO "scsi(%li): Resetting Cmnd=0x%p, "\r\n"Handle=0x%p, action=0x%x\n",\r\nha->host_no, cmd, CMD_HANDLE(cmd), action);\r\nfound = -1;\r\nfor (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {\r\nif (sp == ha->outstanding_cmds[i]) {\r\nfound = i;\r\nsp->wait = &wait;\r\nbreak;\r\n}\r\n}\r\nif (found < 0) {\r\nresult = SUCCESS;\r\nif (qla1280_verbose) {\r\nprintk(KERN_INFO\r\n"scsi(%ld:%d:%d:%d): specified command has "\r\n"already completed.\n", ha->host_no, bus,\r\ntarget, lun);\r\n}\r\n}\r\nswitch (action) {\r\ncase ABORT_COMMAND:\r\ndprintk(1, "qla1280: RISC aborting command\n");\r\nif (found >= 0)\r\nqla1280_abort_command(ha, sp, found);\r\nbreak;\r\ncase DEVICE_RESET:\r\nif (qla1280_verbose)\r\nprintk(KERN_INFO\r\n"scsi(%ld:%d:%d:%d): Queueing device reset "\r\n"command.\n", ha->host_no, bus, target, lun);\r\nif (qla1280_device_reset(ha, bus, target) == 0) {\r\nwait_for_bus = bus;\r\nwait_for_target = target;\r\n}\r\nbreak;\r\ncase BUS_RESET:\r\nif (qla1280_verbose)\r\nprintk(KERN_INFO "qla1280(%ld:%d): Issued bus "\r\n"reset.\n", ha->host_no, bus);\r\nif (qla1280_bus_reset(ha, bus) == 0) {\r\nwait_for_bus = bus;\r\n}\r\nbreak;\r\ncase ADAPTER_RESET:\r\ndefault:\r\nif (qla1280_verbose) {\r\nprintk(KERN_INFO\r\n"scsi(%ld): Issued ADAPTER RESET\n",\r\nha->host_no);\r\nprintk(KERN_INFO "scsi(%ld): I/O processing will "\r\n"continue automatically\n", ha->host_no);\r\n}\r\nha->flags.reset_active = 1;\r\nif (qla1280_abort_isp(ha) != 0) {\r\nresult = FAILED;\r\n}\r\nha->flags.reset_active = 0;\r\n}\r\nif (found >= 0)\r\nresult = _qla1280_wait_for_single_command(ha, sp, &wait);\r\nif (action == ABORT_COMMAND && result != SUCCESS) {\r\nprintk(KERN_WARNING\r\n"scsi(%li:%i:%i:%i): "\r\n"Unable to abort command!\n",\r\nha->host_no, bus, target, lun);\r\n}\r\nif (result == SUCCESS && wait_for_bus >= 0) {\r\nresult = qla1280_wait_for_pending_commands(ha,\r\nwait_for_bus, wait_for_target);\r\n}\r\ndprintk(1, "RESET returning %d\n", result);\r\nLEAVE("qla1280_error_action");\r\nreturn result;\r\n}\r\nstatic int\r\nqla1280_eh_abort(struct scsi_cmnd * cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = qla1280_error_action(cmd, ABORT_COMMAND);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nqla1280_eh_device_reset(struct scsi_cmnd *cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = qla1280_error_action(cmd, DEVICE_RESET);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nqla1280_eh_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = qla1280_error_action(cmd, BUS_RESET);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nqla1280_eh_adapter_reset(struct scsi_cmnd *cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = qla1280_error_action(cmd, ADAPTER_RESET);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nqla1280_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nint heads, sectors, cylinders;\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = (unsigned long)capacity / (heads * sectors);\r\nif (cylinders > 1024) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = (unsigned long)capacity / (heads * sectors);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nqla1280_disable_intrs(struct scsi_qla_host *ha)\r\n{\r\nWRT_REG_WORD(&ha->iobase->ictrl, 0);\r\nRD_REG_WORD(&ha->iobase->ictrl);\r\n}\r\nstatic inline void\r\nqla1280_enable_intrs(struct scsi_qla_host *ha)\r\n{\r\nWRT_REG_WORD(&ha->iobase->ictrl, (ISP_EN_INT | ISP_EN_RISC));\r\nRD_REG_WORD(&ha->iobase->ictrl);\r\n}\r\nstatic irqreturn_t\r\nqla1280_intr_handler(int irq, void *dev_id)\r\n{\r\nstruct scsi_qla_host *ha;\r\nstruct device_reg __iomem *reg;\r\nu16 data;\r\nint handled = 0;\r\nENTER_INTR ("qla1280_intr_handler");\r\nha = (struct scsi_qla_host *)dev_id;\r\nspin_lock(ha->host->host_lock);\r\nha->isr_count++;\r\nreg = ha->iobase;\r\nqla1280_disable_intrs(ha);\r\ndata = qla1280_debounce_register(&reg->istatus);\r\nif (data & RISC_INT) {\r\nqla1280_isr(ha, &ha->done_q);\r\nhandled = 1;\r\n}\r\nif (!list_empty(&ha->done_q))\r\nqla1280_done(ha);\r\nspin_unlock(ha->host->host_lock);\r\nqla1280_enable_intrs(ha);\r\nLEAVE_INTR("qla1280_intr_handler");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int\r\nqla1280_set_target_parameters(struct scsi_qla_host *ha, int bus, int target)\r\n{\r\nuint8_t mr;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nstruct nvram *nv;\r\nint status, lun;\r\nnv = &ha->nvram;\r\nmr = BIT_3 | BIT_2 | BIT_1 | BIT_0;\r\nmb[0] = MBC_SET_TARGET_PARAMETERS;\r\nmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\r\nmb[2] = nv->bus[bus].target[target].parameter.renegotiate_on_error << 8;\r\nmb[2] |= nv->bus[bus].target[target].parameter.stop_queue_on_check << 9;\r\nmb[2] |= nv->bus[bus].target[target].parameter.auto_request_sense << 10;\r\nmb[2] |= nv->bus[bus].target[target].parameter.tag_queuing << 11;\r\nmb[2] |= nv->bus[bus].target[target].parameter.enable_sync << 12;\r\nmb[2] |= nv->bus[bus].target[target].parameter.enable_wide << 13;\r\nmb[2] |= nv->bus[bus].target[target].parameter.parity_checking << 14;\r\nmb[2] |= nv->bus[bus].target[target].parameter.disconnect_allowed << 15;\r\nif (IS_ISP1x160(ha)) {\r\nmb[2] |= nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr << 5;\r\nmb[3] = (nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8);\r\nmb[6] = (nv->bus[bus].target[target].ppr_1x160.flags.ppr_options << 8) |\r\nnv->bus[bus].target[target].ppr_1x160.flags.ppr_bus_width;\r\nmr |= BIT_6;\r\n} else {\r\nmb[3] = (nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8);\r\n}\r\nmb[3] |= nv->bus[bus].target[target].sync_period;\r\nstatus = qla1280_mailbox_command(ha, mr, mb);\r\nfor (lun = 0; lun < MAX_LUNS; lun++) {\r\nmb[0] = MBC_SET_DEVICE_QUEUE;\r\nmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\r\nmb[1] |= lun;\r\nmb[2] = nv->bus[bus].max_queue_depth;\r\nmb[3] = nv->bus[bus].target[target].execution_throttle;\r\nstatus |= qla1280_mailbox_command(ha, 0x0f, mb);\r\n}\r\nif (status)\r\nprintk(KERN_WARNING "scsi(%ld:%i:%i): "\r\n"qla1280_set_target_parameters() failed\n",\r\nha->host_no, bus, target);\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_slave_configure(struct scsi_device *device)\r\n{\r\nstruct scsi_qla_host *ha;\r\nint default_depth = 3;\r\nint bus = device->channel;\r\nint target = device->id;\r\nint status = 0;\r\nstruct nvram *nv;\r\nunsigned long flags;\r\nha = (struct scsi_qla_host *)device->host->hostdata;\r\nnv = &ha->nvram;\r\nif (qla1280_check_for_dead_scsi_bus(ha, bus))\r\nreturn 1;\r\nif (device->tagged_supported &&\r\n(ha->bus_settings[bus].qtag_enables & (BIT_0 << target))) {\r\nscsi_adjust_queue_depth(device, MSG_ORDERED_TAG,\r\nha->bus_settings[bus].hiwat);\r\n} else {\r\nscsi_adjust_queue_depth(device, 0, default_depth);\r\n}\r\nnv->bus[bus].target[target].parameter.enable_sync = device->sdtr;\r\nnv->bus[bus].target[target].parameter.enable_wide = device->wdtr;\r\nnv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = device->ppr;\r\nif (driver_setup.no_sync ||\r\n(driver_setup.sync_mask &&\r\n(~driver_setup.sync_mask & (1 << target))))\r\nnv->bus[bus].target[target].parameter.enable_sync = 0;\r\nif (driver_setup.no_wide ||\r\n(driver_setup.wide_mask &&\r\n(~driver_setup.wide_mask & (1 << target))))\r\nnv->bus[bus].target[target].parameter.enable_wide = 0;\r\nif (IS_ISP1x160(ha)) {\r\nif (driver_setup.no_ppr ||\r\n(driver_setup.ppr_mask &&\r\n(~driver_setup.ppr_mask & (1 << target))))\r\nnv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 0;\r\n}\r\nspin_lock_irqsave(ha->host->host_lock, flags);\r\nif (nv->bus[bus].target[target].parameter.enable_sync)\r\nstatus = qla1280_set_target_parameters(ha, bus, target);\r\nqla1280_get_target_parameters(ha, device);\r\nspin_unlock_irqrestore(ha->host->host_lock, flags);\r\nreturn status;\r\n}\r\nstatic void\r\nqla1280_done(struct scsi_qla_host *ha)\r\n{\r\nstruct srb *sp;\r\nstruct list_head *done_q;\r\nint bus, target, lun;\r\nstruct scsi_cmnd *cmd;\r\nENTER("qla1280_done");\r\ndone_q = &ha->done_q;\r\nwhile (!list_empty(done_q)) {\r\nsp = list_entry(done_q->next, struct srb, list);\r\nlist_del(&sp->list);\r\ncmd = sp->cmd;\r\nbus = SCSI_BUS_32(cmd);\r\ntarget = SCSI_TCN_32(cmd);\r\nlun = SCSI_LUN_32(cmd);\r\nswitch ((CMD_RESULT(cmd) >> 16)) {\r\ncase DID_RESET:\r\nif (!ha->flags.abort_isp_active)\r\nqla1280_marker(ha, bus, target, 0, MK_SYNC_ID);\r\nbreak;\r\ncase DID_ABORT:\r\nsp->flags &= ~SRB_ABORT_PENDING;\r\nsp->flags |= SRB_ABORTED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nscsi_dma_unmap(cmd);\r\nha->actthreads--;\r\nif (sp->wait == NULL)\r\n(*(cmd)->scsi_done)(cmd);\r\nelse\r\ncomplete(sp->wait);\r\n}\r\nLEAVE("qla1280_done");\r\n}\r\nstatic int\r\nqla1280_return_status(struct response * sts, struct scsi_cmnd *cp)\r\n{\r\nint host_status = DID_ERROR;\r\nuint16_t comp_status = le16_to_cpu(sts->comp_status);\r\nuint16_t state_flags = le16_to_cpu(sts->state_flags);\r\nuint32_t residual_length = le32_to_cpu(sts->residual_length);\r\nuint16_t scsi_status = le16_to_cpu(sts->scsi_status);\r\n#if DEBUG_QLA1280_INTR\r\nstatic char *reason[] = {\r\n"DID_OK",\r\n"DID_NO_CONNECT",\r\n"DID_BUS_BUSY",\r\n"DID_TIME_OUT",\r\n"DID_BAD_TARGET",\r\n"DID_ABORT",\r\n"DID_PARITY",\r\n"DID_ERROR",\r\n"DID_RESET",\r\n"DID_BAD_INTR"\r\n};\r\n#endif\r\nENTER("qla1280_return_status");\r\n#if DEBUG_QLA1280_INTR\r\n#endif\r\nswitch (comp_status) {\r\ncase CS_COMPLETE:\r\nhost_status = DID_OK;\r\nbreak;\r\ncase CS_INCOMPLETE:\r\nif (!(state_flags & SF_GOT_BUS))\r\nhost_status = DID_NO_CONNECT;\r\nelse if (!(state_flags & SF_GOT_TARGET))\r\nhost_status = DID_BAD_TARGET;\r\nelse if (!(state_flags & SF_SENT_CDB))\r\nhost_status = DID_ERROR;\r\nelse if (!(state_flags & SF_TRANSFERRED_DATA))\r\nhost_status = DID_ERROR;\r\nelse if (!(state_flags & SF_GOT_STATUS))\r\nhost_status = DID_ERROR;\r\nelse if (!(state_flags & SF_GOT_SENSE))\r\nhost_status = DID_ERROR;\r\nbreak;\r\ncase CS_RESET:\r\nhost_status = DID_RESET;\r\nbreak;\r\ncase CS_ABORTED:\r\nhost_status = DID_ABORT;\r\nbreak;\r\ncase CS_TIMEOUT:\r\nhost_status = DID_TIME_OUT;\r\nbreak;\r\ncase CS_DATA_OVERRUN:\r\ndprintk(2, "Data overrun 0x%x\n", residual_length);\r\ndprintk(2, "qla1280_return_status: response packet data\n");\r\nqla1280_dump_buffer(2, (char *)sts, RESPONSE_ENTRY_SIZE);\r\nhost_status = DID_ERROR;\r\nbreak;\r\ncase CS_DATA_UNDERRUN:\r\nif ((scsi_bufflen(cp) - residual_length) <\r\ncp->underflow) {\r\nprintk(KERN_WARNING\r\n"scsi: Underflow detected - retrying "\r\n"command.\n");\r\nhost_status = DID_ERROR;\r\n} else {\r\nscsi_set_resid(cp, residual_length);\r\nhost_status = DID_OK;\r\n}\r\nbreak;\r\ndefault:\r\nhost_status = DID_ERROR;\r\nbreak;\r\n}\r\n#if DEBUG_QLA1280_INTR\r\ndprintk(1, "qla1280 ISP status: host status (%s) scsi status %x\n",\r\nreason[host_status], scsi_status);\r\n#endif\r\nLEAVE("qla1280_return_status");\r\nreturn (scsi_status & 0xff) | (host_status << 16);\r\n}\r\nstatic int __devinit\r\nqla1280_initialize_adapter(struct scsi_qla_host *ha)\r\n{\r\nstruct device_reg __iomem *reg;\r\nint status;\r\nint bus;\r\nunsigned long flags;\r\nENTER("qla1280_initialize_adapter");\r\nha->flags.online = 0;\r\nha->flags.disable_host_adapter = 0;\r\nha->flags.reset_active = 0;\r\nha->flags.abort_isp_active = 0;\r\n#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)\r\nif (ia64_platform_is("sn2")) {\r\nprintk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "\r\n"dual channel lockup workaround\n", ha->host_no);\r\nha->flags.use_pci_vchannel = 1;\r\ndriver_setup.no_nvram = 1;\r\n}\r\n#endif\r\nif (IS_ISP1040(ha))\r\ndriver_setup.no_nvram = 1;\r\ndprintk(1, "Configure PCI space for adapter...\n");\r\nreg = ha->iobase;\r\nWRT_REG_WORD(&reg->semaphore, 0);\r\nWRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);\r\nWRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);\r\nRD_REG_WORD(&reg->host_cmd);\r\nif (qla1280_read_nvram(ha)) {\r\ndprintk(2, "qla1280_initialize_adapter: failed to read "\r\n"NVRAM\n");\r\n}\r\nspin_lock_irqsave(ha->host->host_lock, flags);\r\nstatus = qla1280_load_firmware(ha);\r\nif (status) {\r\nprintk(KERN_ERR "scsi(%li): initialize: pci probe failed!\n",\r\nha->host_no);\r\ngoto out;\r\n}\r\ndprintk(1, "scsi(%ld): Configure NVRAM parameters\n", ha->host_no);\r\nqla1280_nvram_config(ha);\r\nif (ha->flags.disable_host_adapter) {\r\nstatus = 1;\r\ngoto out;\r\n}\r\nstatus = qla1280_init_rings(ha);\r\nif (status)\r\ngoto out;\r\nfor (bus = 0; bus < ha->ports; bus++) {\r\nif (!ha->bus_settings[bus].disable_scsi_reset &&\r\nqla1280_bus_reset(ha, bus) &&\r\nqla1280_bus_reset(ha, bus))\r\nha->bus_settings[bus].scsi_bus_dead = 1;\r\n}\r\nha->flags.online = 1;\r\nout:\r\nspin_unlock_irqrestore(ha->host->host_lock, flags);\r\nif (status)\r\ndprintk(2, "qla1280_initialize_adapter: **** FAILED ****\n");\r\nLEAVE("qla1280_initialize_adapter");\r\nreturn status;\r\n}\r\nstatic const struct firmware *\r\nqla1280_request_firmware(struct scsi_qla_host *ha)\r\n{\r\nconst struct firmware *fw;\r\nint err;\r\nint index;\r\nchar *fwname;\r\nspin_unlock_irq(ha->host->host_lock);\r\nmutex_lock(&qla1280_firmware_mutex);\r\nindex = ql1280_board_tbl[ha->devnum].fw_index;\r\nfw = qla1280_fw_tbl[index].fw;\r\nif (fw)\r\ngoto out;\r\nfwname = qla1280_fw_tbl[index].fwname;\r\nerr = request_firmware(&fw, fwname, &ha->pdev->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfwname, err);\r\nfw = ERR_PTR(err);\r\ngoto unlock;\r\n}\r\nif ((fw->size % 2) || (fw->size < 6)) {\r\nprintk(KERN_ERR "Invalid firmware length %zu in image \"%s\"\n",\r\nfw->size, fwname);\r\nrelease_firmware(fw);\r\nfw = ERR_PTR(-EINVAL);\r\ngoto unlock;\r\n}\r\nqla1280_fw_tbl[index].fw = fw;\r\nout:\r\nha->fwver1 = fw->data[0];\r\nha->fwver2 = fw->data[1];\r\nha->fwver3 = fw->data[2];\r\nunlock:\r\nmutex_unlock(&qla1280_firmware_mutex);\r\nspin_lock_irq(ha->host->host_lock);\r\nreturn fw;\r\n}\r\nstatic int\r\nqla1280_chip_diag(struct scsi_qla_host *ha)\r\n{\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nint status = 0;\r\nint cnt;\r\nuint16_t data;\r\ndprintk(3, "qla1280_chip_diag: testing device at 0x%p \n", &reg->id_l);\r\ndprintk(1, "scsi(%ld): Verifying chip\n", ha->host_no);\r\nWRT_REG_WORD(&reg->ictrl, ISP_RESET);\r\nudelay(20);\r\ndata = qla1280_debounce_register(&reg->ictrl);\r\nfor (cnt = 1000000; cnt && data & ISP_RESET; cnt--) {\r\nudelay(5);\r\ndata = RD_REG_WORD(&reg->ictrl);\r\n}\r\nif (!cnt)\r\ngoto fail;\r\ndprintk(3, "qla1280_chip_diag: reset register cleared by chip reset\n");\r\nWRT_REG_WORD(&reg->cfg_1, 0);\r\nWRT_REG_WORD(&reg->host_cmd, HC_RESET_RISC |\r\nHC_RELEASE_RISC | HC_DISABLE_BIOS);\r\nRD_REG_WORD(&reg->id_l);\r\ndata = qla1280_debounce_register(&reg->mailbox0);\r\nfor (cnt = 1000000; cnt && data == MBS_BUSY; cnt--) {\r\nudelay(5);\r\ndata = RD_REG_WORD(&reg->mailbox0);\r\n}\r\nif (!cnt)\r\ngoto fail;\r\ndprintk(3, "qla1280_chip_diag: Checking product ID of chip\n");\r\nif (RD_REG_WORD(&reg->mailbox1) != PROD_ID_1 ||\r\n(RD_REG_WORD(&reg->mailbox2) != PROD_ID_2 &&\r\nRD_REG_WORD(&reg->mailbox2) != PROD_ID_2a) ||\r\nRD_REG_WORD(&reg->mailbox3) != PROD_ID_3 ||\r\nRD_REG_WORD(&reg->mailbox4) != PROD_ID_4) {\r\nprintk(KERN_INFO "qla1280: Wrong product ID = "\r\n"0x%x,0x%x,0x%x,0x%x\n",\r\nRD_REG_WORD(&reg->mailbox1),\r\nRD_REG_WORD(&reg->mailbox2),\r\nRD_REG_WORD(&reg->mailbox3),\r\nRD_REG_WORD(&reg->mailbox4));\r\ngoto fail;\r\n}\r\nqla1280_enable_intrs(ha);\r\ndprintk(1, "qla1280_chip_diag: Checking mailboxes of chip\n");\r\nmb[0] = MBC_MAILBOX_REGISTER_TEST;\r\nmb[1] = 0xAAAA;\r\nmb[2] = 0x5555;\r\nmb[3] = 0xAA55;\r\nmb[4] = 0x55AA;\r\nmb[5] = 0xA5A5;\r\nmb[6] = 0x5A5A;\r\nmb[7] = 0x2525;\r\nstatus = qla1280_mailbox_command(ha, 0xff, mb);\r\nif (status)\r\ngoto fail;\r\nif (mb[1] != 0xAAAA || mb[2] != 0x5555 || mb[3] != 0xAA55 ||\r\nmb[4] != 0x55AA || mb[5] != 0xA5A5 || mb[6] != 0x5A5A ||\r\nmb[7] != 0x2525) {\r\nprintk(KERN_INFO "qla1280: Failed mbox check\n");\r\ngoto fail;\r\n}\r\ndprintk(3, "qla1280_chip_diag: exiting normally\n");\r\nreturn 0;\r\nfail:\r\ndprintk(2, "qla1280_chip_diag: **** FAILED ****\n");\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_load_firmware_pio(struct scsi_qla_host *ha)\r\n{\r\nconst struct firmware *fw;\r\nconst __le16 *fw_data;\r\nuint16_t risc_address, risc_code_size;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT], i;\r\nint err = 0;\r\nfw = qla1280_request_firmware(ha);\r\nif (IS_ERR(fw))\r\nreturn PTR_ERR(fw);\r\nfw_data = (const __le16 *)&fw->data[0];\r\nha->fwstart = __le16_to_cpu(fw_data[2]);\r\nrisc_address = ha->fwstart;\r\nfw_data = (const __le16 *)&fw->data[6];\r\nrisc_code_size = (fw->size - 6) / 2;\r\nfor (i = 0; i < risc_code_size; i++) {\r\nmb[0] = MBC_WRITE_RAM_WORD;\r\nmb[1] = risc_address + i;\r\nmb[2] = __le16_to_cpu(fw_data[i]);\r\nerr = qla1280_mailbox_command(ha, BIT_0 | BIT_1 | BIT_2, mb);\r\nif (err) {\r\nprintk(KERN_ERR "scsi(%li): Failed to load firmware\n",\r\nha->host_no);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nqla1280_load_firmware_dma(struct scsi_qla_host *ha)\r\n{\r\nconst struct firmware *fw;\r\nconst __le16 *fw_data;\r\nuint16_t risc_address, risc_code_size;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT], cnt;\r\nint err = 0, num, i;\r\n#if DUMP_IT_BACK\r\nuint8_t *sp, *tbuf;\r\ndma_addr_t p_tbuf;\r\ntbuf = pci_alloc_consistent(ha->pdev, 8000, &p_tbuf);\r\nif (!tbuf)\r\nreturn -ENOMEM;\r\n#endif\r\nfw = qla1280_request_firmware(ha);\r\nif (IS_ERR(fw))\r\nreturn PTR_ERR(fw);\r\nfw_data = (const __le16 *)&fw->data[0];\r\nha->fwstart = __le16_to_cpu(fw_data[2]);\r\nrisc_address = ha->fwstart;\r\nfw_data = (const __le16 *)&fw->data[6];\r\nrisc_code_size = (fw->size - 6) / 2;\r\ndprintk(1, "%s: DMA RISC code (%i) words\n",\r\n__func__, risc_code_size);\r\nnum = 0;\r\nwhile (risc_code_size > 0) {\r\nint warn __attribute__((unused)) = 0;\r\ncnt = 2000 >> 1;\r\nif (cnt > risc_code_size)\r\ncnt = risc_code_size;\r\ndprintk(2, "qla1280_setup_chip: loading risc @ =(0x%p),"\r\n"%d,%d(0x%x)\n",\r\nfw_data, cnt, num, risc_address);\r\nfor(i = 0; i < cnt; i++)\r\n((__le16 *)ha->request_ring)[i] = fw_data[i];\r\nmb[0] = MBC_LOAD_RAM;\r\nmb[1] = risc_address;\r\nmb[4] = cnt;\r\nmb[3] = ha->request_dma & 0xffff;\r\nmb[2] = (ha->request_dma >> 16) & 0xffff;\r\nmb[7] = pci_dma_hi32(ha->request_dma) & 0xffff;\r\nmb[6] = pci_dma_hi32(ha->request_dma) >> 16;\r\ndprintk(2, "%s: op=%d 0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\n",\r\n__func__, mb[0],\r\n(void *)(long)ha->request_dma,\r\nmb[6], mb[7], mb[2], mb[3]);\r\nerr = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |\r\nBIT_1 | BIT_0, mb);\r\nif (err) {\r\nprintk(KERN_ERR "scsi(%li): Failed to load partial "\r\n"segment of f\n", ha->host_no);\r\ngoto out;\r\n}\r\n#if DUMP_IT_BACK\r\nmb[0] = MBC_DUMP_RAM;\r\nmb[1] = risc_address;\r\nmb[4] = cnt;\r\nmb[3] = p_tbuf & 0xffff;\r\nmb[2] = (p_tbuf >> 16) & 0xffff;\r\nmb[7] = pci_dma_hi32(p_tbuf) & 0xffff;\r\nmb[6] = pci_dma_hi32(p_tbuf) >> 16;\r\nerr = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |\r\nBIT_1 | BIT_0, mb);\r\nif (err) {\r\nprintk(KERN_ERR\r\n"Failed to dump partial segment of f/w\n");\r\ngoto out;\r\n}\r\nsp = (uint8_t *)ha->request_ring;\r\nfor (i = 0; i < (cnt << 1); i++) {\r\nif (tbuf[i] != sp[i] && warn++ < 10) {\r\nprintk(KERN_ERR "%s: FW compare error @ "\r\n"byte(0x%x) loop#=%x\n",\r\n__func__, i, num);\r\nprintk(KERN_ERR "%s: FWbyte=%x "\r\n"FWfromChip=%x\n",\r\n__func__, sp[i], tbuf[i]);\r\n}\r\n}\r\n#endif\r\nrisc_address += cnt;\r\nrisc_code_size = risc_code_size - cnt;\r\nfw_data = fw_data + cnt;\r\nnum++;\r\n}\r\nout:\r\n#if DUMP_IT_BACK\r\npci_free_consistent(ha->pdev, 8000, tbuf, p_tbuf);\r\n#endif\r\nreturn err;\r\n}\r\nstatic int\r\nqla1280_start_firmware(struct scsi_qla_host *ha)\r\n{\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nint err;\r\ndprintk(1, "%s: Verifying checksum of loaded RISC code.\n",\r\n__func__);\r\nmb[0] = MBC_VERIFY_CHECKSUM;\r\nmb[1] = ha->fwstart;\r\nerr = qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\r\nif (err) {\r\nprintk(KERN_ERR "scsi(%li): RISC checksum failed.\n", ha->host_no);\r\nreturn err;\r\n}\r\ndprintk(1, "%s: start firmware running.\n", __func__);\r\nmb[0] = MBC_EXECUTE_FIRMWARE;\r\nmb[1] = ha->fwstart;\r\nerr = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);\r\nif (err) {\r\nprintk(KERN_ERR "scsi(%li): Failed to start firmware\n",\r\nha->host_no);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nqla1280_load_firmware(struct scsi_qla_host *ha)\r\n{\r\nint err;\r\nerr = qla1280_chip_diag(ha);\r\nif (err)\r\ngoto out;\r\nif (IS_ISP1040(ha))\r\nerr = qla1280_load_firmware_pio(ha);\r\nelse\r\nerr = qla1280_load_firmware_dma(ha);\r\nif (err)\r\ngoto out;\r\nerr = qla1280_start_firmware(ha);\r\nout:\r\nreturn err;\r\n}\r\nstatic int\r\nqla1280_init_rings(struct scsi_qla_host *ha)\r\n{\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nint status = 0;\r\nENTER("qla1280_init_rings");\r\nmemset(ha->outstanding_cmds, 0,\r\nsizeof(struct srb *) * MAX_OUTSTANDING_COMMANDS);\r\nha->request_ring_ptr = ha->request_ring;\r\nha->req_ring_index = 0;\r\nha->req_q_cnt = REQUEST_ENTRY_CNT;\r\nmb[0] = MBC_INIT_REQUEST_QUEUE_A64;\r\nmb[1] = REQUEST_ENTRY_CNT;\r\nmb[3] = ha->request_dma & 0xffff;\r\nmb[2] = (ha->request_dma >> 16) & 0xffff;\r\nmb[4] = 0;\r\nmb[7] = pci_dma_hi32(ha->request_dma) & 0xffff;\r\nmb[6] = pci_dma_hi32(ha->request_dma) >> 16;\r\nif (!(status = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_4 |\r\nBIT_3 | BIT_2 | BIT_1 | BIT_0,\r\n&mb[0]))) {\r\nha->response_ring_ptr = ha->response_ring;\r\nha->rsp_ring_index = 0;\r\nmb[0] = MBC_INIT_RESPONSE_QUEUE_A64;\r\nmb[1] = RESPONSE_ENTRY_CNT;\r\nmb[3] = ha->response_dma & 0xffff;\r\nmb[2] = (ha->response_dma >> 16) & 0xffff;\r\nmb[5] = 0;\r\nmb[7] = pci_dma_hi32(ha->response_dma) & 0xffff;\r\nmb[6] = pci_dma_hi32(ha->response_dma) >> 16;\r\nstatus = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_5 |\r\nBIT_3 | BIT_2 | BIT_1 | BIT_0,\r\n&mb[0]);\r\n}\r\nif (status)\r\ndprintk(2, "qla1280_init_rings: **** FAILED ****\n");\r\nLEAVE("qla1280_init_rings");\r\nreturn status;\r\n}\r\nstatic void\r\nqla1280_print_settings(struct nvram *nv)\r\n{\r\ndprintk(1, "qla1280 : initiator scsi id bus[0]=%d\n",\r\nnv->bus[0].config_1.initiator_id);\r\ndprintk(1, "qla1280 : initiator scsi id bus[1]=%d\n",\r\nnv->bus[1].config_1.initiator_id);\r\ndprintk(1, "qla1280 : bus reset delay[0]=%d\n",\r\nnv->bus[0].bus_reset_delay);\r\ndprintk(1, "qla1280 : bus reset delay[1]=%d\n",\r\nnv->bus[1].bus_reset_delay);\r\ndprintk(1, "qla1280 : retry count[0]=%d\n", nv->bus[0].retry_count);\r\ndprintk(1, "qla1280 : retry delay[0]=%d\n", nv->bus[0].retry_delay);\r\ndprintk(1, "qla1280 : retry count[1]=%d\n", nv->bus[1].retry_count);\r\ndprintk(1, "qla1280 : retry delay[1]=%d\n", nv->bus[1].retry_delay);\r\ndprintk(1, "qla1280 : async data setup time[0]=%d\n",\r\nnv->bus[0].config_2.async_data_setup_time);\r\ndprintk(1, "qla1280 : async data setup time[1]=%d\n",\r\nnv->bus[1].config_2.async_data_setup_time);\r\ndprintk(1, "qla1280 : req/ack active negation[0]=%d\n",\r\nnv->bus[0].config_2.req_ack_active_negation);\r\ndprintk(1, "qla1280 : req/ack active negation[1]=%d\n",\r\nnv->bus[1].config_2.req_ack_active_negation);\r\ndprintk(1, "qla1280 : data line active negation[0]=%d\n",\r\nnv->bus[0].config_2.data_line_active_negation);\r\ndprintk(1, "qla1280 : data line active negation[1]=%d\n",\r\nnv->bus[1].config_2.data_line_active_negation);\r\ndprintk(1, "qla1280 : disable loading risc code=%d\n",\r\nnv->cntr_flags_1.disable_loading_risc_code);\r\ndprintk(1, "qla1280 : enable 64bit addressing=%d\n",\r\nnv->cntr_flags_1.enable_64bit_addressing);\r\ndprintk(1, "qla1280 : selection timeout limit[0]=%d\n",\r\nnv->bus[0].selection_timeout);\r\ndprintk(1, "qla1280 : selection timeout limit[1]=%d\n",\r\nnv->bus[1].selection_timeout);\r\ndprintk(1, "qla1280 : max queue depth[0]=%d\n",\r\nnv->bus[0].max_queue_depth);\r\ndprintk(1, "qla1280 : max queue depth[1]=%d\n",\r\nnv->bus[1].max_queue_depth);\r\n}\r\nstatic void\r\nqla1280_set_target_defaults(struct scsi_qla_host *ha, int bus, int target)\r\n{\r\nstruct nvram *nv = &ha->nvram;\r\nnv->bus[bus].target[target].parameter.renegotiate_on_error = 1;\r\nnv->bus[bus].target[target].parameter.auto_request_sense = 1;\r\nnv->bus[bus].target[target].parameter.tag_queuing = 1;\r\nnv->bus[bus].target[target].parameter.enable_sync = 1;\r\n#if 1\r\nnv->bus[bus].target[target].parameter.enable_wide = 1;\r\n#endif\r\nnv->bus[bus].target[target].execution_throttle =\r\nnv->bus[bus].max_queue_depth - 1;\r\nnv->bus[bus].target[target].parameter.parity_checking = 1;\r\nnv->bus[bus].target[target].parameter.disconnect_allowed = 1;\r\nif (IS_ISP1x160(ha)) {\r\nnv->bus[bus].target[target].flags.flags1x160.device_enable = 1;\r\nnv->bus[bus].target[target].flags.flags1x160.sync_offset = 0x0e;\r\nnv->bus[bus].target[target].sync_period = 9;\r\nnv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 1;\r\nnv->bus[bus].target[target].ppr_1x160.flags.ppr_options = 2;\r\nnv->bus[bus].target[target].ppr_1x160.flags.ppr_bus_width = 1;\r\n} else {\r\nnv->bus[bus].target[target].flags.flags1x80.device_enable = 1;\r\nnv->bus[bus].target[target].flags.flags1x80.sync_offset = 12;\r\nnv->bus[bus].target[target].sync_period = 10;\r\n}\r\n}\r\nstatic void\r\nqla1280_set_defaults(struct scsi_qla_host *ha)\r\n{\r\nstruct nvram *nv = &ha->nvram;\r\nint bus, target;\r\ndprintk(1, "Using defaults for NVRAM: \n");\r\nmemset(nv, 0, sizeof(struct nvram));\r\nnv->firmware_feature.f.enable_fast_posting = 1;\r\nnv->firmware_feature.f.disable_synchronous_backoff = 1;\r\nnv->termination.scsi_bus_0_control = 3;\r\nnv->termination.scsi_bus_1_control = 3;\r\nnv->termination.auto_term_support = 1;\r\nnv->isp_config.burst_enable = 1;\r\nif (IS_ISP1040(ha))\r\nnv->isp_config.fifo_threshold |= 3;\r\nelse\r\nnv->isp_config.fifo_threshold |= 4;\r\nif (IS_ISP1x160(ha))\r\nnv->isp_parameter = 0x01;\r\nfor (bus = 0; bus < MAX_BUSES; bus++) {\r\nnv->bus[bus].config_1.initiator_id = 7;\r\nnv->bus[bus].config_2.req_ack_active_negation = 1;\r\nnv->bus[bus].config_2.data_line_active_negation = 1;\r\nnv->bus[bus].selection_timeout = 250;\r\nnv->bus[bus].max_queue_depth = 32;\r\nif (IS_ISP1040(ha)) {\r\nnv->bus[bus].bus_reset_delay = 3;\r\nnv->bus[bus].config_2.async_data_setup_time = 6;\r\nnv->bus[bus].retry_delay = 1;\r\n} else {\r\nnv->bus[bus].bus_reset_delay = 5;\r\nnv->bus[bus].config_2.async_data_setup_time = 8;\r\n}\r\nfor (target = 0; target < MAX_TARGETS; target++)\r\nqla1280_set_target_defaults(ha, bus, target);\r\n}\r\n}\r\nstatic int\r\nqla1280_config_target(struct scsi_qla_host *ha, int bus, int target)\r\n{\r\nstruct nvram *nv = &ha->nvram;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nint status, lun;\r\nuint16_t flag;\r\nmb[0] = MBC_SET_TARGET_PARAMETERS;\r\nmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\r\nmb[2] = (TP_RENEGOTIATE | TP_AUTO_REQUEST_SENSE | TP_TAGGED_QUEUE\r\n| TP_WIDE | TP_PARITY | TP_DISCONNECT);\r\nif (IS_ISP1x160(ha))\r\nmb[3] = nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8;\r\nelse\r\nmb[3] = nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8;\r\nmb[3] |= nv->bus[bus].target[target].sync_period;\r\nstatus = qla1280_mailbox_command(ha, 0x0f, mb);\r\nflag = (BIT_0 << target);\r\nif (nv->bus[bus].target[target].parameter.tag_queuing)\r\nha->bus_settings[bus].qtag_enables |= flag;\r\nif (IS_ISP1x160(ha)) {\r\nif (nv->bus[bus].target[target].flags.flags1x160.device_enable)\r\nha->bus_settings[bus].device_enables |= flag;\r\nha->bus_settings[bus].lun_disables |= 0;\r\n} else {\r\nif (nv->bus[bus].target[target].flags.flags1x80.device_enable)\r\nha->bus_settings[bus].device_enables |= flag;\r\nif (nv->bus[bus].target[target].flags.flags1x80.lun_disable)\r\nha->bus_settings[bus].lun_disables |= flag;\r\n}\r\nfor (lun = 0; lun < MAX_LUNS; lun++) {\r\nmb[0] = MBC_SET_DEVICE_QUEUE;\r\nmb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);\r\nmb[1] |= lun;\r\nmb[2] = nv->bus[bus].max_queue_depth;\r\nmb[3] = nv->bus[bus].target[target].execution_throttle;\r\nstatus |= qla1280_mailbox_command(ha, 0x0f, mb);\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_config_bus(struct scsi_qla_host *ha, int bus)\r\n{\r\nstruct nvram *nv = &ha->nvram;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nint target, status;\r\nha->bus_settings[bus].disable_scsi_reset =\r\nnv->bus[bus].config_1.scsi_reset_disable;\r\nha->bus_settings[bus].id = nv->bus[bus].config_1.initiator_id;\r\nmb[0] = MBC_SET_INITIATOR_ID;\r\nmb[1] = bus ? ha->bus_settings[bus].id | BIT_7 :\r\nha->bus_settings[bus].id;\r\nstatus = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);\r\nha->bus_settings[bus].bus_reset_delay =\r\nnv->bus[bus].bus_reset_delay;\r\nha->bus_settings[bus].hiwat = nv->bus[bus].max_queue_depth - 1;\r\nfor (target = 0; target < MAX_TARGETS; target++)\r\nstatus |= qla1280_config_target(ha, bus, target);\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_nvram_config(struct scsi_qla_host *ha)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nstruct nvram *nv = &ha->nvram;\r\nint bus, target, status = 0;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nENTER("qla1280_nvram_config");\r\nif (ha->nvram_valid) {\r\nfor (bus = 0; bus < MAX_BUSES; bus++)\r\nfor (target = 0; target < MAX_TARGETS; target++) {\r\nnv->bus[bus].target[target].parameter.\r\nauto_request_sense = 1;\r\n}\r\n} else {\r\nqla1280_set_defaults(ha);\r\n}\r\nqla1280_print_settings(nv);\r\nha->flags.disable_risc_code_load =\r\nnv->cntr_flags_1.disable_loading_risc_code;\r\nif (IS_ISP1040(ha)) {\r\nuint16_t hwrev, cfg1, cdma_conf, ddma_conf;\r\nhwrev = RD_REG_WORD(&reg->cfg_0) & ISP_CFG0_HWMSK;\r\ncfg1 = RD_REG_WORD(&reg->cfg_1) & ~(BIT_4 | BIT_5 | BIT_6);\r\ncdma_conf = RD_REG_WORD(&reg->cdma_cfg);\r\nddma_conf = RD_REG_WORD(&reg->ddma_cfg);\r\nif (hwrev != ISP_CFG0_1040A)\r\ncfg1 |= nv->isp_config.fifo_threshold << 4;\r\ncfg1 |= nv->isp_config.burst_enable << 2;\r\nWRT_REG_WORD(&reg->cfg_1, cfg1);\r\nWRT_REG_WORD(&reg->cdma_cfg, cdma_conf | CDMA_CONF_BENAB);\r\nWRT_REG_WORD(&reg->ddma_cfg, cdma_conf | DDMA_CONF_BENAB);\r\n} else {\r\nuint16_t cfg1, term;\r\ncfg1 = nv->isp_config.fifo_threshold << 4;\r\ncfg1 |= nv->isp_config.burst_enable << 2;\r\nif (ha->ports > 1)\r\ncfg1 |= BIT_13;\r\nWRT_REG_WORD(&reg->cfg_1, cfg1);\r\nWRT_REG_WORD(&reg->gpio_enable,\r\nBIT_7 | BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nterm = nv->termination.scsi_bus_1_control;\r\nterm |= nv->termination.scsi_bus_0_control << 2;\r\nterm |= nv->termination.auto_term_support << 7;\r\nRD_REG_WORD(&reg->id_l);\r\nWRT_REG_WORD(&reg->gpio_data, term);\r\n}\r\nRD_REG_WORD(&reg->id_l);\r\nmb[0] = MBC_SET_SYSTEM_PARAMETER;\r\nmb[1] = nv->isp_parameter;\r\nstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);\r\nif (IS_ISP1x40(ha)) {\r\nmb[0] = MBC_SET_CLOCK_RATE;\r\nmb[1] = 40;\r\nstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\r\n}\r\nmb[0] = MBC_SET_FIRMWARE_FEATURES;\r\nmb[1] = nv->firmware_feature.f.enable_fast_posting;\r\nmb[1] |= nv->firmware_feature.f.report_lvd_bus_transition << 1;\r\nmb[1] |= nv->firmware_feature.f.disable_synchronous_backoff << 5;\r\n#if defined(CONFIG_IA64_GENERIC) || defined (CONFIG_IA64_SGI_SN2)\r\nif (ia64_platform_is("sn2")) {\r\nprintk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "\r\n"workaround\n", ha->host_no);\r\nmb[1] |= nv->firmware_feature.f.unused_9 << 9;\r\n}\r\n#endif\r\nstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\r\nmb[0] = MBC_SET_RETRY_COUNT;\r\nmb[1] = nv->bus[0].retry_count;\r\nmb[2] = nv->bus[0].retry_delay;\r\nmb[6] = nv->bus[1].retry_count;\r\nmb[7] = nv->bus[1].retry_delay;\r\nstatus |= qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_2 |\r\nBIT_1 | BIT_0, &mb[0]);\r\nmb[0] = MBC_SET_ASYNC_DATA_SETUP;\r\nmb[1] = nv->bus[0].config_2.async_data_setup_time;\r\nmb[2] = nv->bus[1].config_2.async_data_setup_time;\r\nstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);\r\nmb[0] = MBC_SET_ACTIVE_NEGATION;\r\nmb[1] = 0;\r\nif (nv->bus[0].config_2.req_ack_active_negation)\r\nmb[1] |= BIT_5;\r\nif (nv->bus[0].config_2.data_line_active_negation)\r\nmb[1] |= BIT_4;\r\nmb[2] = 0;\r\nif (nv->bus[1].config_2.req_ack_active_negation)\r\nmb[2] |= BIT_5;\r\nif (nv->bus[1].config_2.data_line_active_negation)\r\nmb[2] |= BIT_4;\r\nstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);\r\nmb[0] = MBC_SET_DATA_OVERRUN_RECOVERY;\r\nmb[1] = 2;\r\nstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\r\nmb[0] = MBC_SET_PCI_CONTROL;\r\nmb[1] = BIT_1;\r\nmb[2] = BIT_1;\r\nstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);\r\nmb[0] = MBC_SET_TAG_AGE_LIMIT;\r\nmb[1] = 8;\r\nstatus |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);\r\nmb[0] = MBC_SET_SELECTION_TIMEOUT;\r\nmb[1] = nv->bus[0].selection_timeout;\r\nmb[2] = nv->bus[1].selection_timeout;\r\nstatus |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);\r\nfor (bus = 0; bus < ha->ports; bus++)\r\nstatus |= qla1280_config_bus(ha, bus);\r\nif (status)\r\ndprintk(2, "qla1280_nvram_config: **** FAILED ****\n");\r\nLEAVE("qla1280_nvram_config");\r\nreturn status;\r\n}\r\nstatic uint16_t\r\nqla1280_get_nvram_word(struct scsi_qla_host *ha, uint32_t address)\r\n{\r\nuint32_t nv_cmd;\r\nuint16_t data;\r\nnv_cmd = address << 16;\r\nnv_cmd |= NV_READ_OP;\r\ndata = le16_to_cpu(qla1280_nvram_request(ha, nv_cmd));\r\ndprintk(8, "qla1280_get_nvram_word: exiting normally NVRAM data = "\r\n"0x%x", data);\r\nreturn data;\r\n}\r\nstatic uint16_t\r\nqla1280_nvram_request(struct scsi_qla_host *ha, uint32_t nv_cmd)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nint cnt;\r\nuint16_t data = 0;\r\nuint16_t reg_data;\r\nnv_cmd <<= 5;\r\nfor (cnt = 0; cnt < 11; cnt++) {\r\nif (nv_cmd & BIT_31)\r\nqla1280_nv_write(ha, NV_DATA_OUT);\r\nelse\r\nqla1280_nv_write(ha, 0);\r\nnv_cmd <<= 1;\r\n}\r\nfor (cnt = 0; cnt < 16; cnt++) {\r\nWRT_REG_WORD(&reg->nvram, (NV_SELECT | NV_CLOCK));\r\nRD_REG_WORD(&reg->id_l);\r\nNVRAM_DELAY();\r\ndata <<= 1;\r\nreg_data = RD_REG_WORD(&reg->nvram);\r\nif (reg_data & NV_DATA_IN)\r\ndata |= BIT_0;\r\nWRT_REG_WORD(&reg->nvram, NV_SELECT);\r\nRD_REG_WORD(&reg->id_l);\r\nNVRAM_DELAY();\r\n}\r\nWRT_REG_WORD(&reg->nvram, NV_DESELECT);\r\nRD_REG_WORD(&reg->id_l);\r\nNVRAM_DELAY();\r\nreturn data;\r\n}\r\nstatic void\r\nqla1280_nv_write(struct scsi_qla_host *ha, uint16_t data)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nWRT_REG_WORD(&reg->nvram, data | NV_SELECT);\r\nRD_REG_WORD(&reg->id_l);\r\nNVRAM_DELAY();\r\nWRT_REG_WORD(&reg->nvram, data | NV_SELECT | NV_CLOCK);\r\nRD_REG_WORD(&reg->id_l);\r\nNVRAM_DELAY();\r\nWRT_REG_WORD(&reg->nvram, data | NV_SELECT);\r\nRD_REG_WORD(&reg->id_l);\r\nNVRAM_DELAY();\r\n}\r\nstatic int\r\nqla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nint status = 0;\r\nint cnt;\r\nuint16_t *optr, *iptr;\r\nuint16_t __iomem *mptr;\r\nuint16_t data;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nstruct timer_list timer;\r\nENTER("qla1280_mailbox_command");\r\nif (ha->mailbox_wait) {\r\nprintk(KERN_ERR "Warning mailbox wait already in use!\n");\r\n}\r\nha->mailbox_wait = &wait;\r\nmptr = (uint16_t __iomem *) &reg->mailbox0;\r\niptr = mb;\r\nfor (cnt = 0; cnt < MAILBOX_REGISTER_COUNT; cnt++) {\r\nif (mr & BIT_0) {\r\nWRT_REG_WORD(mptr, (*iptr));\r\n}\r\nmr >>= 1;\r\nmptr++;\r\niptr++;\r\n}\r\ninit_timer(&timer);\r\ntimer.expires = jiffies + 20*HZ;\r\ntimer.data = (unsigned long)ha;\r\ntimer.function = qla1280_mailbox_timeout;\r\nadd_timer(&timer);\r\nspin_unlock_irq(ha->host->host_lock);\r\nWRT_REG_WORD(&reg->host_cmd, HC_SET_HOST_INT);\r\ndata = qla1280_debounce_register(&reg->istatus);\r\nwait_for_completion(&wait);\r\ndel_timer_sync(&timer);\r\nspin_lock_irq(ha->host->host_lock);\r\nha->mailbox_wait = NULL;\r\nif (ha->mailbox_out[0] != MBS_CMD_CMP) {\r\nprintk(KERN_WARNING "qla1280_mailbox_command: Command failed, "\r\n"mailbox0 = 0x%04x, mailbox_out0 = 0x%04x, istatus = "\r\n"0x%04x\n",\r\nmb[0], ha->mailbox_out[0], RD_REG_WORD(&reg->istatus));\r\nprintk(KERN_WARNING "m0 %04x, m1 %04x, m2 %04x, m3 %04x\n",\r\nRD_REG_WORD(&reg->mailbox0), RD_REG_WORD(&reg->mailbox1),\r\nRD_REG_WORD(&reg->mailbox2), RD_REG_WORD(&reg->mailbox3));\r\nprintk(KERN_WARNING "m4 %04x, m5 %04x, m6 %04x, m7 %04x\n",\r\nRD_REG_WORD(&reg->mailbox4), RD_REG_WORD(&reg->mailbox5),\r\nRD_REG_WORD(&reg->mailbox6), RD_REG_WORD(&reg->mailbox7));\r\nstatus = 1;\r\n}\r\noptr = mb;\r\niptr = (uint16_t *) &ha->mailbox_out[0];\r\nmr = MAILBOX_REGISTER_COUNT;\r\nmemcpy(optr, iptr, MAILBOX_REGISTER_COUNT * sizeof(uint16_t));\r\nif (ha->flags.reset_marker)\r\nqla1280_rst_aen(ha);\r\nif (status)\r\ndprintk(2, "qla1280_mailbox_command: **** FAILED, mailbox0 = "\r\n"0x%x ****\n", mb[0]);\r\nLEAVE("qla1280_mailbox_command");\r\nreturn status;\r\n}\r\nstatic void\r\nqla1280_poll(struct scsi_qla_host *ha)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nuint16_t data;\r\nLIST_HEAD(done_q);\r\ndata = RD_REG_WORD(&reg->istatus);\r\nif (data & RISC_INT)\r\nqla1280_isr(ha, &done_q);\r\nif (!ha->mailbox_wait) {\r\nif (ha->flags.reset_marker)\r\nqla1280_rst_aen(ha);\r\n}\r\nif (!list_empty(&done_q))\r\nqla1280_done(ha);\r\n}\r\nstatic int\r\nqla1280_bus_reset(struct scsi_qla_host *ha, int bus)\r\n{\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nuint16_t reset_delay;\r\nint status;\r\ndprintk(3, "qla1280_bus_reset: entered\n");\r\nif (qla1280_verbose)\r\nprintk(KERN_INFO "scsi(%li:%i): Resetting SCSI BUS\n",\r\nha->host_no, bus);\r\nreset_delay = ha->bus_settings[bus].bus_reset_delay;\r\nmb[0] = MBC_BUS_RESET;\r\nmb[1] = reset_delay;\r\nmb[2] = (uint16_t) bus;\r\nstatus = qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);\r\nif (status) {\r\nif (ha->bus_settings[bus].failed_reset_count > 2)\r\nha->bus_settings[bus].scsi_bus_dead = 1;\r\nha->bus_settings[bus].failed_reset_count++;\r\n} else {\r\nspin_unlock_irq(ha->host->host_lock);\r\nssleep(reset_delay);\r\nspin_lock_irq(ha->host->host_lock);\r\nha->bus_settings[bus].scsi_bus_dead = 0;\r\nha->bus_settings[bus].failed_reset_count = 0;\r\nha->bus_settings[bus].reset_marker = 0;\r\nqla1280_marker(ha, bus, 0, 0, MK_SYNC_ALL);\r\n}\r\nif (status)\r\ndprintk(2, "qla1280_bus_reset: **** FAILED ****\n");\r\nelse\r\ndprintk(3, "qla1280_bus_reset: exiting normally\n");\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_device_reset(struct scsi_qla_host *ha, int bus, int target)\r\n{\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nint status;\r\nENTER("qla1280_device_reset");\r\nmb[0] = MBC_ABORT_TARGET;\r\nmb[1] = (bus ? (target | BIT_7) : target) << 8;\r\nmb[2] = 1;\r\nstatus = qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);\r\nqla1280_marker(ha, bus, target, 0, MK_SYNC_ID);\r\nif (status)\r\ndprintk(2, "qla1280_device_reset: **** FAILED ****\n");\r\nLEAVE("qla1280_device_reset");\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_abort_command(struct scsi_qla_host *ha, struct srb * sp, int handle)\r\n{\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nunsigned int bus, target, lun;\r\nint status;\r\nENTER("qla1280_abort_command");\r\nbus = SCSI_BUS_32(sp->cmd);\r\ntarget = SCSI_TCN_32(sp->cmd);\r\nlun = SCSI_LUN_32(sp->cmd);\r\nsp->flags |= SRB_ABORT_PENDING;\r\nmb[0] = MBC_ABORT_COMMAND;\r\nmb[1] = (bus ? target | BIT_7 : target) << 8 | lun;\r\nmb[2] = handle >> 16;\r\nmb[3] = handle & 0xffff;\r\nstatus = qla1280_mailbox_command(ha, 0x0f, &mb[0]);\r\nif (status) {\r\ndprintk(2, "qla1280_abort_command: **** FAILED ****\n");\r\nsp->flags &= ~SRB_ABORT_PENDING;\r\n}\r\nLEAVE("qla1280_abort_command");\r\nreturn status;\r\n}\r\nstatic void\r\nqla1280_reset_adapter(struct scsi_qla_host *ha)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nENTER("qla1280_reset_adapter");\r\nha->flags.online = 0;\r\nWRT_REG_WORD(&reg->ictrl, ISP_RESET);\r\nWRT_REG_WORD(&reg->host_cmd,\r\nHC_RESET_RISC | HC_RELEASE_RISC | HC_DISABLE_BIOS);\r\nRD_REG_WORD(&reg->id_l);\r\nLEAVE("qla1280_reset_adapter");\r\n}\r\nstatic void\r\nqla1280_marker(struct scsi_qla_host *ha, int bus, int id, int lun, u8 type)\r\n{\r\nstruct mrk_entry *pkt;\r\nENTER("qla1280_marker");\r\nif ((pkt = (struct mrk_entry *) qla1280_req_pkt(ha))) {\r\npkt->entry_type = MARKER_TYPE;\r\npkt->lun = (uint8_t) lun;\r\npkt->target = (uint8_t) (bus ? (id | BIT_7) : id);\r\npkt->modifier = type;\r\npkt->entry_status = 0;\r\nqla1280_isp_cmd(ha);\r\n}\r\nLEAVE("qla1280_marker");\r\n}\r\nstatic int\r\nqla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nstruct scsi_cmnd *cmd = sp->cmd;\r\ncmd_a64_entry_t *pkt;\r\n__le32 *dword_ptr;\r\ndma_addr_t dma_handle;\r\nint status = 0;\r\nint cnt;\r\nint req_cnt;\r\nint seg_cnt;\r\nu8 dir;\r\nENTER("qla1280_64bit_start_scsi:");\r\nreq_cnt = 1;\r\nseg_cnt = scsi_dma_map(cmd);\r\nif (seg_cnt > 0) {\r\nif (seg_cnt > 2) {\r\nreq_cnt += (seg_cnt - 2) / 5;\r\nif ((seg_cnt - 2) % 5)\r\nreq_cnt++;\r\n}\r\n} else if (seg_cnt < 0) {\r\nstatus = 1;\r\ngoto out;\r\n}\r\nif ((req_cnt + 2) >= ha->req_q_cnt) {\r\ncnt = RD_REG_WORD(&reg->mailbox4);\r\nif (ha->req_ring_index < cnt)\r\nha->req_q_cnt = cnt - ha->req_ring_index;\r\nelse\r\nha->req_q_cnt =\r\nREQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);\r\n}\r\ndprintk(3, "Number of free entries=(%d) seg_cnt=0x%x\n",\r\nha->req_q_cnt, seg_cnt);\r\nif ((req_cnt + 2) >= ha->req_q_cnt) {\r\nstatus = SCSI_MLQUEUE_HOST_BUSY;\r\ndprintk(2, "qla1280_start_scsi: in-ptr=0x%x req_q_cnt="\r\n"0x%xreq_cnt=0x%x", ha->req_ring_index, ha->req_q_cnt,\r\nreq_cnt);\r\ngoto out;\r\n}\r\nfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS &&\r\nha->outstanding_cmds[cnt] != NULL; cnt++);\r\nif (cnt >= MAX_OUTSTANDING_COMMANDS) {\r\nstatus = SCSI_MLQUEUE_HOST_BUSY;\r\ndprintk(2, "qla1280_start_scsi: NO ROOM IN "\r\n"OUTSTANDING ARRAY, req_q_cnt=0x%x", ha->req_q_cnt);\r\ngoto out;\r\n}\r\nha->outstanding_cmds[cnt] = sp;\r\nha->req_q_cnt -= req_cnt;\r\nCMD_HANDLE(sp->cmd) = (unsigned char *)(unsigned long)(cnt + 1);\r\ndprintk(2, "start: cmd=%p sp=%p CDB=%xm, handle %lx\n", cmd, sp,\r\ncmd->cmnd[0], (long)CMD_HANDLE(sp->cmd));\r\ndprintk(2, " bus %i, target %i, lun %i\n",\r\nSCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\r\nqla1280_dump_buffer(2, cmd->cmnd, MAX_COMMAND_SIZE);\r\npkt = (cmd_a64_entry_t *) ha->request_ring_ptr;\r\npkt->entry_type = COMMAND_A64_TYPE;\r\npkt->entry_count = (uint8_t) req_cnt;\r\npkt->sys_define = (uint8_t) ha->req_ring_index;\r\npkt->entry_status = 0;\r\npkt->handle = cpu_to_le32(cnt);\r\nmemset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));\r\npkt->timeout = cpu_to_le16(cmd->request->timeout/HZ);\r\npkt->lun = SCSI_LUN_32(cmd);\r\npkt->target = SCSI_BUS_32(cmd) ?\r\n(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);\r\nif (cmd->device->simple_tags)\r\npkt->control_flags |= cpu_to_le16(BIT_3);\r\npkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));\r\nmemcpy(pkt->scsi_cdb, CMD_CDBP(cmd), CMD_CDBLEN(cmd));\r\ndir = qla1280_data_direction(cmd);\r\npkt->control_flags |= cpu_to_le16(dir);\r\npkt->dseg_count = cpu_to_le16(seg_cnt);\r\nif (seg_cnt) {\r\nstruct scatterlist *sg, *s;\r\nint remseg = seg_cnt;\r\nsg = scsi_sglist(cmd);\r\ndword_ptr = (u32 *)&pkt->dseg_0_address;\r\nfor_each_sg(sg, s, seg_cnt, cnt) {\r\nif (cnt == 2)\r\nbreak;\r\ndma_handle = sg_dma_address(s);\r\n#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)\r\nif (ha->flags.use_pci_vchannel)\r\nsn_pci_set_vchan(ha->pdev,\r\n(unsigned long *)&dma_handle,\r\nSCSI_BUS_32(cmd));\r\n#endif\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_lo32(dma_handle));\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_hi32(dma_handle));\r\n*dword_ptr++ = cpu_to_le32(sg_dma_len(s));\r\ndprintk(3, "S/G Segment phys_addr=%x %x, len=0x%x\n",\r\ncpu_to_le32(pci_dma_hi32(dma_handle)),\r\ncpu_to_le32(pci_dma_lo32(dma_handle)),\r\ncpu_to_le32(sg_dma_len(sg_next(s))));\r\nremseg--;\r\n}\r\ndprintk(5, "qla1280_64bit_start_scsi: Scatter/gather "\r\n"command packet data - b %i, t %i, l %i \n",\r\nSCSI_BUS_32(cmd), SCSI_TCN_32(cmd),\r\nSCSI_LUN_32(cmd));\r\nqla1280_dump_buffer(5, (char *)pkt,\r\nREQUEST_ENTRY_SIZE);\r\ndprintk(3, "S/G Building Continuation...seg_cnt=0x%x "\r\n"remains\n", seg_cnt);\r\nwhile (remseg > 0) {\r\nsg = s;\r\nha->req_ring_index++;\r\nif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\r\nha->req_ring_index = 0;\r\nha->request_ring_ptr =\r\nha->request_ring;\r\n} else\r\nha->request_ring_ptr++;\r\npkt = (cmd_a64_entry_t *)ha->request_ring_ptr;\r\nmemset(pkt, 0, REQUEST_ENTRY_SIZE);\r\n((struct cont_a64_entry *) pkt)->entry_type =\r\nCONTINUE_A64_TYPE;\r\n((struct cont_a64_entry *) pkt)->entry_count = 1;\r\n((struct cont_a64_entry *) pkt)->sys_define =\r\n(uint8_t)ha->req_ring_index;\r\ndword_ptr =\r\n(u32 *)&((struct cont_a64_entry *) pkt)->dseg_0_address;\r\nfor_each_sg(sg, s, remseg, cnt) {\r\nif (cnt == 5)\r\nbreak;\r\ndma_handle = sg_dma_address(s);\r\n#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)\r\nif (ha->flags.use_pci_vchannel)\r\nsn_pci_set_vchan(ha->pdev,\r\n(unsigned long *)&dma_handle,\r\nSCSI_BUS_32(cmd));\r\n#endif\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_lo32(dma_handle));\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_hi32(dma_handle));\r\n*dword_ptr++ =\r\ncpu_to_le32(sg_dma_len(s));\r\ndprintk(3, "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n",\r\ncpu_to_le32(pci_dma_hi32(dma_handle)),\r\ncpu_to_le32(pci_dma_lo32(dma_handle)),\r\ncpu_to_le32(sg_dma_len(s)));\r\n}\r\nremseg -= cnt;\r\ndprintk(5, "qla1280_64bit_start_scsi: "\r\n"continuation packet data - b %i, t "\r\n"%i, l %i \n", SCSI_BUS_32(cmd),\r\nSCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\r\nqla1280_dump_buffer(5, (char *)pkt,\r\nREQUEST_ENTRY_SIZE);\r\n}\r\n} else {\r\ndprintk(5, "qla1280_64bit_start_scsi: No data, command "\r\n"packet data - b %i, t %i, l %i \n",\r\nSCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\r\nqla1280_dump_buffer(5, (char *)pkt, REQUEST_ENTRY_SIZE);\r\n}\r\nha->req_ring_index++;\r\nif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\r\nha->req_ring_index = 0;\r\nha->request_ring_ptr = ha->request_ring;\r\n} else\r\nha->request_ring_ptr++;\r\ndprintk(2,\r\n"qla1280_64bit_start_scsi: Wakeup RISC for pending command\n");\r\nsp->flags |= SRB_SENT;\r\nha->actthreads++;\r\nWRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);\r\nmmiowb();\r\nout:\r\nif (status)\r\ndprintk(2, "qla1280_64bit_start_scsi: **** FAILED ****\n");\r\nelse\r\ndprintk(3, "qla1280_64bit_start_scsi: exiting normally\n");\r\nreturn status;\r\n}\r\nstatic int\r\nqla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nstruct scsi_cmnd *cmd = sp->cmd;\r\nstruct cmd_entry *pkt;\r\n__le32 *dword_ptr;\r\nint status = 0;\r\nint cnt;\r\nint req_cnt;\r\nint seg_cnt;\r\nu8 dir;\r\nENTER("qla1280_32bit_start_scsi");\r\ndprintk(1, "32bit_start: cmd=%p sp=%p CDB=%x\n", cmd, sp,\r\ncmd->cmnd[0]);\r\nreq_cnt = 1;\r\nseg_cnt = scsi_dma_map(cmd);\r\nif (seg_cnt) {\r\nif (seg_cnt > 4) {\r\nreq_cnt += (seg_cnt - 4) / 7;\r\nif ((seg_cnt - 4) % 7)\r\nreq_cnt++;\r\n}\r\ndprintk(3, "S/G Transfer cmd=%p seg_cnt=0x%x, req_cnt=%x\n",\r\ncmd, seg_cnt, req_cnt);\r\n} else if (seg_cnt < 0) {\r\nstatus = 1;\r\ngoto out;\r\n}\r\nif ((req_cnt + 2) >= ha->req_q_cnt) {\r\ncnt = RD_REG_WORD(&reg->mailbox4);\r\nif (ha->req_ring_index < cnt)\r\nha->req_q_cnt = cnt - ha->req_ring_index;\r\nelse\r\nha->req_q_cnt =\r\nREQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);\r\n}\r\ndprintk(3, "Number of free entries=(%d) seg_cnt=0x%x\n",\r\nha->req_q_cnt, seg_cnt);\r\nif ((req_cnt + 2) >= ha->req_q_cnt) {\r\nstatus = SCSI_MLQUEUE_HOST_BUSY;\r\ndprintk(2, "qla1280_32bit_start_scsi: in-ptr=0x%x, "\r\n"req_q_cnt=0x%x, req_cnt=0x%x", ha->req_ring_index,\r\nha->req_q_cnt, req_cnt);\r\ngoto out;\r\n}\r\nfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS &&\r\n(ha->outstanding_cmds[cnt] != 0); cnt++) ;\r\nif (cnt >= MAX_OUTSTANDING_COMMANDS) {\r\nstatus = SCSI_MLQUEUE_HOST_BUSY;\r\ndprintk(2, "qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING "\r\n"ARRAY, req_q_cnt=0x%x\n", ha->req_q_cnt);\r\ngoto out;\r\n}\r\nCMD_HANDLE(sp->cmd) = (unsigned char *) (unsigned long)(cnt + 1);\r\nha->outstanding_cmds[cnt] = sp;\r\nha->req_q_cnt -= req_cnt;\r\npkt = (struct cmd_entry *) ha->request_ring_ptr;\r\npkt->entry_type = COMMAND_TYPE;\r\npkt->entry_count = (uint8_t) req_cnt;\r\npkt->sys_define = (uint8_t) ha->req_ring_index;\r\npkt->entry_status = 0;\r\npkt->handle = cpu_to_le32(cnt);\r\nmemset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));\r\npkt->timeout = cpu_to_le16(cmd->request->timeout/HZ);\r\npkt->lun = SCSI_LUN_32(cmd);\r\npkt->target = SCSI_BUS_32(cmd) ?\r\n(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);\r\nif (cmd->device->simple_tags)\r\npkt->control_flags |= cpu_to_le16(BIT_3);\r\npkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));\r\nmemcpy(pkt->scsi_cdb, CMD_CDBP(cmd), CMD_CDBLEN(cmd));\r\ndir = qla1280_data_direction(cmd);\r\npkt->control_flags |= cpu_to_le16(dir);\r\npkt->dseg_count = cpu_to_le16(seg_cnt);\r\nif (seg_cnt) {\r\nstruct scatterlist *sg, *s;\r\nint remseg = seg_cnt;\r\nsg = scsi_sglist(cmd);\r\ndword_ptr = &pkt->dseg_0_address;\r\ndprintk(3, "Building S/G data segments..\n");\r\nqla1280_dump_buffer(1, (char *)sg, 4 * 16);\r\nfor_each_sg(sg, s, seg_cnt, cnt) {\r\nif (cnt == 4)\r\nbreak;\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_lo32(sg_dma_address(s)));\r\n*dword_ptr++ = cpu_to_le32(sg_dma_len(s));\r\ndprintk(3, "S/G Segment phys_addr=0x%lx, len=0x%x\n",\r\n(pci_dma_lo32(sg_dma_address(s))),\r\n(sg_dma_len(s)));\r\nremseg--;\r\n}\r\ndprintk(3, "S/G Building Continuation"\r\n"...seg_cnt=0x%x remains\n", seg_cnt);\r\nwhile (remseg > 0) {\r\nsg = s;\r\nha->req_ring_index++;\r\nif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\r\nha->req_ring_index = 0;\r\nha->request_ring_ptr =\r\nha->request_ring;\r\n} else\r\nha->request_ring_ptr++;\r\npkt = (struct cmd_entry *)ha->request_ring_ptr;\r\nmemset(pkt, 0, REQUEST_ENTRY_SIZE);\r\n((struct cont_entry *) pkt)->\r\nentry_type = CONTINUE_TYPE;\r\n((struct cont_entry *) pkt)->entry_count = 1;\r\n((struct cont_entry *) pkt)->sys_define =\r\n(uint8_t) ha->req_ring_index;\r\ndword_ptr =\r\n&((struct cont_entry *) pkt)->dseg_0_address;\r\nfor_each_sg(sg, s, remseg, cnt) {\r\nif (cnt == 7)\r\nbreak;\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_lo32(sg_dma_address(s)));\r\n*dword_ptr++ =\r\ncpu_to_le32(sg_dma_len(s));\r\ndprintk(1,\r\n"S/G Segment Cont. phys_addr=0x%x, "\r\n"len=0x%x\n",\r\ncpu_to_le32(pci_dma_lo32(sg_dma_address(s))),\r\ncpu_to_le32(sg_dma_len(s)));\r\n}\r\nremseg -= cnt;\r\ndprintk(5, "qla1280_32bit_start_scsi: "\r\n"continuation packet data - "\r\n"scsi(%i:%i:%i)\n", SCSI_BUS_32(cmd),\r\nSCSI_TCN_32(cmd), SCSI_LUN_32(cmd));\r\nqla1280_dump_buffer(5, (char *)pkt,\r\nREQUEST_ENTRY_SIZE);\r\n}\r\n} else {\r\ndprintk(5, "qla1280_32bit_start_scsi: No data, command "\r\n"packet data - \n");\r\nqla1280_dump_buffer(5, (char *)pkt, REQUEST_ENTRY_SIZE);\r\n}\r\ndprintk(5, "qla1280_32bit_start_scsi: First IOCB block:\n");\r\nqla1280_dump_buffer(5, (char *)ha->request_ring_ptr,\r\nREQUEST_ENTRY_SIZE);\r\nha->req_ring_index++;\r\nif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\r\nha->req_ring_index = 0;\r\nha->request_ring_ptr = ha->request_ring;\r\n} else\r\nha->request_ring_ptr++;\r\ndprintk(2, "qla1280_32bit_start_scsi: Wakeup RISC "\r\n"for pending command\n");\r\nsp->flags |= SRB_SENT;\r\nha->actthreads++;\r\nWRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);\r\nmmiowb();\r\nout:\r\nif (status)\r\ndprintk(2, "qla1280_32bit_start_scsi: **** FAILED ****\n");\r\nLEAVE("qla1280_32bit_start_scsi");\r\nreturn status;\r\n}\r\nstatic request_t *\r\nqla1280_req_pkt(struct scsi_qla_host *ha)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nrequest_t *pkt = NULL;\r\nint cnt;\r\nuint32_t timer;\r\nENTER("qla1280_req_pkt");\r\nfor (timer = 15000000; timer; timer--) {\r\nif (ha->req_q_cnt > 0) {\r\ncnt = RD_REG_WORD(&reg->mailbox4);\r\nif (ha->req_ring_index < cnt)\r\nha->req_q_cnt = cnt - ha->req_ring_index;\r\nelse\r\nha->req_q_cnt =\r\nREQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);\r\n}\r\nif (ha->req_q_cnt > 0) {\r\nha->req_q_cnt--;\r\npkt = ha->request_ring_ptr;\r\nmemset(pkt, 0, REQUEST_ENTRY_SIZE);\r\npkt->sys_define = (uint8_t) ha->req_ring_index;\r\npkt->entry_count = 1;\r\nbreak;\r\n}\r\nudelay(2);\r\nqla1280_poll(ha);\r\n}\r\nif (!pkt)\r\ndprintk(2, "qla1280_req_pkt: **** FAILED ****\n");\r\nelse\r\ndprintk(3, "qla1280_req_pkt: exiting normally\n");\r\nreturn pkt;\r\n}\r\nstatic void\r\nqla1280_isp_cmd(struct scsi_qla_host *ha)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nENTER("qla1280_isp_cmd");\r\ndprintk(5, "qla1280_isp_cmd: IOCB data:\n");\r\nqla1280_dump_buffer(5, (char *)ha->request_ring_ptr,\r\nREQUEST_ENTRY_SIZE);\r\nha->req_ring_index++;\r\nif (ha->req_ring_index == REQUEST_ENTRY_CNT) {\r\nha->req_ring_index = 0;\r\nha->request_ring_ptr = ha->request_ring;\r\n} else\r\nha->request_ring_ptr++;\r\nWRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);\r\nmmiowb();\r\nLEAVE("qla1280_isp_cmd");\r\n}\r\nstatic void\r\nqla1280_isr(struct scsi_qla_host *ha, struct list_head *done_q)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nstruct response *pkt;\r\nstruct srb *sp = NULL;\r\nuint16_t mailbox[MAILBOX_REGISTER_COUNT];\r\nuint16_t *wptr;\r\nuint32_t index;\r\nu16 istatus;\r\nENTER("qla1280_isr");\r\nistatus = RD_REG_WORD(&reg->istatus);\r\nif (!(istatus & (RISC_INT | PCI_INT)))\r\nreturn;\r\nmailbox[5] = RD_REG_WORD(&reg->mailbox5);\r\nmailbox[0] = RD_REG_WORD_dmasync(&reg->semaphore);\r\nif (mailbox[0] & BIT_0) {\r\nwptr = &mailbox[0];\r\n*wptr++ = RD_REG_WORD(&reg->mailbox0);\r\n*wptr++ = RD_REG_WORD(&reg->mailbox1);\r\n*wptr = RD_REG_WORD(&reg->mailbox2);\r\nif (mailbox[0] != MBA_SCSI_COMPLETION) {\r\nwptr++;\r\n*wptr++ = RD_REG_WORD(&reg->mailbox3);\r\n*wptr++ = RD_REG_WORD(&reg->mailbox4);\r\nwptr++;\r\n*wptr++ = RD_REG_WORD(&reg->mailbox6);\r\n*wptr = RD_REG_WORD(&reg->mailbox7);\r\n}\r\nWRT_REG_WORD(&reg->semaphore, 0);\r\nWRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);\r\ndprintk(5, "qla1280_isr: mailbox interrupt mailbox[0] = 0x%x",\r\nmailbox[0]);\r\nswitch (mailbox[0]) {\r\ncase MBA_SCSI_COMPLETION:\r\ndprintk(5, "qla1280_isr: mailbox SCSI response "\r\n"completion\n");\r\nif (ha->flags.online) {\r\nindex = mailbox[2] << 16 | mailbox[1];\r\nif (index < MAX_OUTSTANDING_COMMANDS)\r\nsp = ha->outstanding_cmds[index];\r\nelse\r\nsp = NULL;\r\nif (sp) {\r\nha->outstanding_cmds[index] = NULL;\r\nCMD_RESULT(sp->cmd) = 0;\r\nCMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;\r\nlist_add_tail(&sp->list, done_q);\r\n} else {\r\nprintk(KERN_WARNING\r\n"qla1280: ISP invalid handle\n");\r\n}\r\n}\r\nbreak;\r\ncase MBA_BUS_RESET:\r\nha->flags.reset_marker = 1;\r\nindex = mailbox[6] & BIT_0;\r\nha->bus_settings[index].reset_marker = 1;\r\nprintk(KERN_DEBUG "qla1280_isr(): index %i "\r\n"asynchronous BUS_RESET\n", index);\r\nbreak;\r\ncase MBA_SYSTEM_ERR:\r\nprintk(KERN_WARNING\r\n"qla1280: ISP System Error - mbx1=%xh, mbx2="\r\n"%xh, mbx3=%xh\n", mailbox[1], mailbox[2],\r\nmailbox[3]);\r\nbreak;\r\ncase MBA_REQ_TRANSFER_ERR:\r\nprintk(KERN_WARNING\r\n"qla1280: ISP Request Transfer Error\n");\r\nbreak;\r\ncase MBA_RSP_TRANSFER_ERR:\r\nprintk(KERN_WARNING\r\n"qla1280: ISP Response Transfer Error\n");\r\nbreak;\r\ncase MBA_WAKEUP_THRES:\r\ndprintk(2, "qla1280_isr: asynchronous WAKEUP_THRES\n");\r\nbreak;\r\ncase MBA_TIMEOUT_RESET:\r\ndprintk(2,\r\n"qla1280_isr: asynchronous TIMEOUT_RESET\n");\r\nbreak;\r\ncase MBA_DEVICE_RESET:\r\nprintk(KERN_INFO "qla1280_isr(): asynchronous "\r\n"BUS_DEVICE_RESET\n");\r\nha->flags.reset_marker = 1;\r\nindex = mailbox[6] & BIT_0;\r\nha->bus_settings[index].reset_marker = 1;\r\nbreak;\r\ncase MBA_BUS_MODE_CHANGE:\r\ndprintk(2,\r\n"qla1280_isr: asynchronous BUS_MODE_CHANGE\n");\r\nbreak;\r\ndefault:\r\nif (mailbox[0] < MBA_ASYNC_EVENT) {\r\nwptr = &mailbox[0];\r\nmemcpy((uint16_t *) ha->mailbox_out, wptr,\r\nMAILBOX_REGISTER_COUNT *\r\nsizeof(uint16_t));\r\nif(ha->mailbox_wait != NULL)\r\ncomplete(ha->mailbox_wait);\r\n}\r\nbreak;\r\n}\r\n} else {\r\nWRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);\r\n}\r\nif (!(ha->flags.online && !ha->mailbox_wait)) {\r\ndprintk(2, "qla1280_isr: Response pointer Error\n");\r\ngoto out;\r\n}\r\nif (mailbox[5] >= RESPONSE_ENTRY_CNT)\r\ngoto out;\r\nwhile (ha->rsp_ring_index != mailbox[5]) {\r\npkt = ha->response_ring_ptr;\r\ndprintk(5, "qla1280_isr: ha->rsp_ring_index = 0x%x, mailbox[5]"\r\n" = 0x%x\n", ha->rsp_ring_index, mailbox[5]);\r\ndprintk(5,"qla1280_isr: response packet data\n");\r\nqla1280_dump_buffer(5, (char *)pkt, RESPONSE_ENTRY_SIZE);\r\nif (pkt->entry_type == STATUS_TYPE) {\r\nif ((le16_to_cpu(pkt->scsi_status) & 0xff)\r\n|| pkt->comp_status || pkt->entry_status) {\r\ndprintk(2, "qla1280_isr: ha->rsp_ring_index = "\r\n"0x%x mailbox[5] = 0x%x, comp_status "\r\n"= 0x%x, scsi_status = 0x%x\n",\r\nha->rsp_ring_index, mailbox[5],\r\nle16_to_cpu(pkt->comp_status),\r\nle16_to_cpu(pkt->scsi_status));\r\n}\r\n} else {\r\ndprintk(2, "qla1280_isr: ha->rsp_ring_index = "\r\n"0x%x, mailbox[5] = 0x%x\n",\r\nha->rsp_ring_index, mailbox[5]);\r\ndprintk(2, "qla1280_isr: response packet data\n");\r\nqla1280_dump_buffer(2, (char *)pkt,\r\nRESPONSE_ENTRY_SIZE);\r\n}\r\nif (pkt->entry_type == STATUS_TYPE || pkt->entry_status) {\r\ndprintk(2, "status: Cmd %p, handle %i\n",\r\nha->outstanding_cmds[pkt->handle]->cmd,\r\npkt->handle);\r\nif (pkt->entry_type == STATUS_TYPE)\r\nqla1280_status_entry(ha, pkt, done_q);\r\nelse\r\nqla1280_error_entry(ha, pkt, done_q);\r\nha->rsp_ring_index++;\r\nif (ha->rsp_ring_index == RESPONSE_ENTRY_CNT) {\r\nha->rsp_ring_index = 0;\r\nha->response_ring_ptr = ha->response_ring;\r\n} else\r\nha->response_ring_ptr++;\r\nWRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);\r\n}\r\n}\r\nout:\r\nLEAVE("qla1280_isr");\r\n}\r\nstatic void\r\nqla1280_rst_aen(struct scsi_qla_host *ha)\r\n{\r\nuint8_t bus;\r\nENTER("qla1280_rst_aen");\r\nif (ha->flags.online && !ha->flags.reset_active &&\r\n!ha->flags.abort_isp_active) {\r\nha->flags.reset_active = 1;\r\nwhile (ha->flags.reset_marker) {\r\nha->flags.reset_marker = 0;\r\nfor (bus = 0; bus < ha->ports &&\r\n!ha->flags.reset_marker; bus++) {\r\nif (ha->bus_settings[bus].reset_marker) {\r\nha->bus_settings[bus].reset_marker = 0;\r\nqla1280_marker(ha, bus, 0, 0,\r\nMK_SYNC_ALL);\r\n}\r\n}\r\n}\r\n}\r\nLEAVE("qla1280_rst_aen");\r\n}\r\nstatic void\r\nqla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,\r\nstruct list_head *done_q)\r\n{\r\nunsigned int bus, target, lun;\r\nint sense_sz;\r\nstruct srb *sp;\r\nstruct scsi_cmnd *cmd;\r\nuint32_t handle = le32_to_cpu(pkt->handle);\r\nuint16_t scsi_status = le16_to_cpu(pkt->scsi_status);\r\nuint16_t comp_status = le16_to_cpu(pkt->comp_status);\r\nENTER("qla1280_status_entry");\r\nif (handle < MAX_OUTSTANDING_COMMANDS)\r\nsp = ha->outstanding_cmds[handle];\r\nelse\r\nsp = NULL;\r\nif (!sp) {\r\nprintk(KERN_WARNING "qla1280: Status Entry invalid handle\n");\r\ngoto out;\r\n}\r\nha->outstanding_cmds[handle] = NULL;\r\ncmd = sp->cmd;\r\nbus = SCSI_BUS_32(cmd);\r\ntarget = SCSI_TCN_32(cmd);\r\nlun = SCSI_LUN_32(cmd);\r\nif (comp_status || scsi_status) {\r\ndprintk(3, "scsi: comp_status = 0x%x, scsi_status = "\r\n"0x%x, handle = 0x%x\n", comp_status,\r\nscsi_status, handle);\r\n}\r\nif ((scsi_status & 0xFF) == SAM_STAT_TASK_SET_FULL ||\r\n(scsi_status & 0xFF) == SAM_STAT_BUSY) {\r\nCMD_RESULT(cmd) = scsi_status & 0xff;\r\n} else {\r\nCMD_RESULT(cmd) = qla1280_return_status(pkt, cmd);\r\nif (scsi_status & SAM_STAT_CHECK_CONDITION) {\r\nif (comp_status != CS_ARS_FAILED) {\r\nuint16_t req_sense_length =\r\nle16_to_cpu(pkt->req_sense_length);\r\nif (req_sense_length < CMD_SNSLEN(cmd))\r\nsense_sz = req_sense_length;\r\nelse\r\nsense_sz = CMD_SNSLEN(cmd) - 1;\r\nmemcpy(cmd->sense_buffer,\r\n&pkt->req_sense_data, sense_sz);\r\n} else\r\nsense_sz = 0;\r\nmemset(cmd->sense_buffer + sense_sz, 0,\r\nSCSI_SENSE_BUFFERSIZE - sense_sz);\r\ndprintk(2, "qla1280_status_entry: Check "\r\n"condition Sense data, b %i, t %i, "\r\n"l %i\n", bus, target, lun);\r\nif (sense_sz)\r\nqla1280_dump_buffer(2,\r\n(char *)cmd->sense_buffer,\r\nsense_sz);\r\n}\r\n}\r\nCMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;\r\nlist_add_tail(&sp->list, done_q);\r\nout:\r\nLEAVE("qla1280_status_entry");\r\n}\r\nstatic void\r\nqla1280_error_entry(struct scsi_qla_host *ha, struct response *pkt,\r\nstruct list_head *done_q)\r\n{\r\nstruct srb *sp;\r\nuint32_t handle = le32_to_cpu(pkt->handle);\r\nENTER("qla1280_error_entry");\r\nif (pkt->entry_status & BIT_3)\r\ndprintk(2, "qla1280_error_entry: BAD PAYLOAD flag error\n");\r\nelse if (pkt->entry_status & BIT_2)\r\ndprintk(2, "qla1280_error_entry: BAD HEADER flag error\n");\r\nelse if (pkt->entry_status & BIT_1)\r\ndprintk(2, "qla1280_error_entry: FULL flag error\n");\r\nelse\r\ndprintk(2, "qla1280_error_entry: UNKNOWN flag error\n");\r\nif (handle < MAX_OUTSTANDING_COMMANDS)\r\nsp = ha->outstanding_cmds[handle];\r\nelse\r\nsp = NULL;\r\nif (sp) {\r\nha->outstanding_cmds[handle] = NULL;\r\nif (pkt->entry_status & (BIT_3 + BIT_2)) {\r\nCMD_RESULT(sp->cmd) = DID_ERROR << 16;\r\n} else if (pkt->entry_status & BIT_1) {\r\nCMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;\r\n} else {\r\nCMD_RESULT(sp->cmd) = DID_ERROR << 16;\r\n}\r\nCMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;\r\nlist_add_tail(&sp->list, done_q);\r\n}\r\n#ifdef QLA_64BIT_PTR\r\nelse if (pkt->entry_type == COMMAND_A64_TYPE) {\r\nprintk(KERN_WARNING "!qla1280: Error Entry invalid handle");\r\n}\r\n#endif\r\nLEAVE("qla1280_error_entry");\r\n}\r\nstatic int\r\nqla1280_abort_isp(struct scsi_qla_host *ha)\r\n{\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nstruct srb *sp;\r\nint status = 0;\r\nint cnt;\r\nint bus;\r\nENTER("qla1280_abort_isp");\r\nif (ha->flags.abort_isp_active || !ha->flags.online)\r\ngoto out;\r\nha->flags.abort_isp_active = 1;\r\nqla1280_disable_intrs(ha);\r\nWRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);\r\nRD_REG_WORD(&reg->id_l);\r\nprintk(KERN_INFO "scsi(%li): dequeuing outstanding commands\n",\r\nha->host_no);\r\nfor (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {\r\nstruct scsi_cmnd *cmd;\r\nsp = ha->outstanding_cmds[cnt];\r\nif (sp) {\r\ncmd = sp->cmd;\r\nCMD_RESULT(cmd) = DID_RESET << 16;\r\nCMD_HANDLE(cmd) = COMPLETED_HANDLE;\r\nha->outstanding_cmds[cnt] = NULL;\r\nlist_add_tail(&sp->list, &ha->done_q);\r\n}\r\n}\r\nqla1280_done(ha);\r\nstatus = qla1280_load_firmware(ha);\r\nif (status)\r\ngoto out;\r\nqla1280_nvram_config (ha);\r\nstatus = qla1280_init_rings(ha);\r\nif (status)\r\ngoto out;\r\nfor (bus = 0; bus < ha->ports; bus++)\r\nqla1280_bus_reset(ha, bus);\r\nha->flags.abort_isp_active = 0;\r\nout:\r\nif (status) {\r\nprintk(KERN_WARNING\r\n"qla1280: ISP error recovery failed, board disabled");\r\nqla1280_reset_adapter(ha);\r\ndprintk(2, "qla1280_abort_isp: **** FAILED ****\n");\r\n}\r\nLEAVE("qla1280_abort_isp");\r\nreturn status;\r\n}\r\nstatic u16\r\nqla1280_debounce_register(volatile u16 __iomem * addr)\r\n{\r\nvolatile u16 ret;\r\nvolatile u16 ret2;\r\nret = RD_REG_WORD(addr);\r\nret2 = RD_REG_WORD(addr);\r\nif (ret == ret2)\r\nreturn ret;\r\ndo {\r\ncpu_relax();\r\nret = RD_REG_WORD(addr);\r\nret2 = RD_REG_WORD(addr);\r\n} while (ret != ret2);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla1280_check_for_dead_scsi_bus(struct scsi_qla_host *ha, unsigned int bus)\r\n{\r\nuint16_t config_reg, scsi_control;\r\nstruct device_reg __iomem *reg = ha->iobase;\r\nif (ha->bus_settings[bus].scsi_bus_dead) {\r\nWRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);\r\nconfig_reg = RD_REG_WORD(&reg->cfg_1);\r\nWRT_REG_WORD(&reg->cfg_1, SET_SXP_BANK);\r\nscsi_control = RD_REG_WORD(&reg->scsiControlPins);\r\nWRT_REG_WORD(&reg->cfg_1, config_reg);\r\nWRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);\r\nif (scsi_control == SCSI_PHASE_INVALID) {\r\nha->bus_settings[bus].scsi_bus_dead = 1;\r\nreturn 1;\r\n} else {\r\nha->bus_settings[bus].scsi_bus_dead = 0;\r\nha->bus_settings[bus].failed_reset_count = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nqla1280_get_target_parameters(struct scsi_qla_host *ha,\r\nstruct scsi_device *device)\r\n{\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nint bus, target, lun;\r\nbus = device->channel;\r\ntarget = device->id;\r\nlun = device->lun;\r\nmb[0] = MBC_GET_TARGET_PARAMETERS;\r\nmb[1] = (uint16_t) (bus ? target | BIT_7 : target);\r\nmb[1] <<= 8;\r\nqla1280_mailbox_command(ha, BIT_6 | BIT_3 | BIT_2 | BIT_1 | BIT_0,\r\n&mb[0]);\r\nprintk(KERN_INFO "scsi(%li:%d:%d:%d):", ha->host_no, bus, target, lun);\r\nif (mb[3] != 0) {\r\nprintk(" Sync: period %d, offset %d",\r\n(mb[3] & 0xff), (mb[3] >> 8));\r\nif (mb[2] & BIT_13)\r\nprintk(", Wide");\r\nif ((mb[2] & BIT_5) && ((mb[6] >> 8) & 0xff) >= 2)\r\nprintk(", DT");\r\n} else\r\nprintk(" Async");\r\nif (device->simple_tags)\r\nprintk(", Tagged queuing: depth %d", device->queue_depth);\r\nprintk("\n");\r\n}\r\nstatic void\r\n__qla1280_dump_buffer(char *b, int size)\r\n{\r\nint cnt;\r\nu8 c;\r\nprintk(KERN_DEBUG " 0 1 2 3 4 5 6 7 8 9 Ah "\r\n"Bh Ch Dh Eh Fh\n");\r\nprintk(KERN_DEBUG "---------------------------------------------"\r\n"------------------\n");\r\nfor (cnt = 0; cnt < size;) {\r\nc = *b++;\r\nprintk("0x%02x", c);\r\ncnt++;\r\nif (!(cnt % 16))\r\nprintk("\n");\r\nelse\r\nprintk(" ");\r\n}\r\nif (cnt % 16)\r\nprintk("\n");\r\n}\r\nstatic void\r\n__qla1280_print_scsi_cmd(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_qla_host *ha;\r\nstruct Scsi_Host *host = CMD_HOST(cmd);\r\nstruct srb *sp;\r\nint i;\r\nha = (struct scsi_qla_host *)host->hostdata;\r\nsp = (struct srb *)CMD_SP(cmd);\r\nprintk("SCSI Command @= 0x%p, Handle=0x%p\n", cmd, CMD_HANDLE(cmd));\r\nprintk(" chan=%d, target = 0x%02x, lun = 0x%02x, cmd_len = 0x%02x\n",\r\nSCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd),\r\nCMD_CDBLEN(cmd));\r\nprintk(" CDB = ");\r\nfor (i = 0; i < cmd->cmd_len; i++) {\r\nprintk("0x%02x ", cmd->cmnd[i]);\r\n}\r\nprintk(" seg_cnt =%d\n", scsi_sg_count(cmd));\r\nprintk(" request buffer=0x%p, request buffer len=0x%x\n",\r\nscsi_sglist(cmd), scsi_bufflen(cmd));\r\nprintk(" tag=%d, transfersize=0x%x \n",\r\ncmd->tag, cmd->transfersize);\r\nprintk(" SP=0x%p\n", CMD_SP(cmd));\r\nprintk(" underflow size = 0x%x, direction=0x%x\n",\r\ncmd->underflow, cmd->sc_data_direction);\r\n}\r\nstatic void\r\nql1280_dump_device(struct scsi_qla_host *ha)\r\n{\r\nstruct scsi_cmnd *cp;\r\nstruct srb *sp;\r\nint i;\r\nprintk(KERN_DEBUG "Outstanding Commands on controller:\n");\r\nfor (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {\r\nif ((sp = ha->outstanding_cmds[i]) == NULL)\r\ncontinue;\r\nif ((cp = sp->cmd) == NULL)\r\ncontinue;\r\nqla1280_print_scsi_cmd(1, cp);\r\n}\r\n}\r\nstatic int __init\r\nqla1280_setup(char *s)\r\n{\r\nchar *cp, *ptr;\r\nunsigned long val;\r\nint toke;\r\ncp = s;\r\nwhile (cp && (ptr = strchr(cp, ':'))) {\r\nptr++;\r\nif (!strcmp(ptr, "yes")) {\r\nval = 0x10000;\r\nptr += 3;\r\n} else if (!strcmp(ptr, "no")) {\r\nval = 0;\r\nptr += 2;\r\n} else\r\nval = simple_strtoul(ptr, &ptr, 0);\r\nswitch ((toke = qla1280_get_token(cp))) {\r\ncase TOKEN_NVRAM:\r\nif (!val)\r\ndriver_setup.no_nvram = 1;\r\nbreak;\r\ncase TOKEN_SYNC:\r\nif (!val)\r\ndriver_setup.no_sync = 1;\r\nelse if (val != 0x10000)\r\ndriver_setup.sync_mask = val;\r\nbreak;\r\ncase TOKEN_WIDE:\r\nif (!val)\r\ndriver_setup.no_wide = 1;\r\nelse if (val != 0x10000)\r\ndriver_setup.wide_mask = val;\r\nbreak;\r\ncase TOKEN_PPR:\r\nif (!val)\r\ndriver_setup.no_ppr = 1;\r\nelse if (val != 0x10000)\r\ndriver_setup.ppr_mask = val;\r\nbreak;\r\ncase TOKEN_VERBOSE:\r\nqla1280_verbose = val;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "qla1280: unknown boot option %s\n",\r\ncp);\r\n}\r\ncp = strchr(ptr, ';');\r\nif (cp)\r\ncp++;\r\nelse {\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init\r\nqla1280_get_token(char *str)\r\n{\r\nchar *sep;\r\nlong ret = -1;\r\nint i;\r\nsep = strchr(str, ':');\r\nif (sep) {\r\nfor (i = 0; i < ARRAY_SIZE(setup_token); i++) {\r\nif (!strncmp(setup_token[i].token, str, (sep - str))) {\r\nret = setup_token[i].val;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit\r\nqla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint devnum = id->driver_data;\r\nstruct qla_boards *bdp = &ql1280_board_tbl[devnum];\r\nstruct Scsi_Host *host;\r\nstruct scsi_qla_host *ha;\r\nint error = -ENODEV;\r\nif (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) {\r\nprintk(KERN_INFO\r\n"qla1280: Skipping AMI SubSys Vendor ID Chip\n");\r\ngoto error;\r\n}\r\nprintk(KERN_INFO "qla1280: %s found on PCI bus %i, dev %i\n",\r\nbdp->name, pdev->bus->number, PCI_SLOT(pdev->devfn));\r\nif (pci_enable_device(pdev)) {\r\nprintk(KERN_WARNING\r\n"qla1280: Failed to enabled pci device, aborting.\n");\r\ngoto error;\r\n}\r\npci_set_master(pdev);\r\nerror = -ENOMEM;\r\nhost = scsi_host_alloc(&qla1280_driver_template, sizeof(*ha));\r\nif (!host) {\r\nprintk(KERN_WARNING\r\n"qla1280: Failed to register host, aborting.\n");\r\ngoto error_disable_device;\r\n}\r\nha = (struct scsi_qla_host *)host->hostdata;\r\nmemset(ha, 0, sizeof(struct scsi_qla_host));\r\nha->pdev = pdev;\r\nha->devnum = devnum;\r\n#ifdef QLA_64BIT_PTR\r\nif (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(64))) {\r\nif (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_WARNING "scsi(%li): Unable to set a "\r\n"suitable DMA mask - aborting\n", ha->host_no);\r\nerror = -ENODEV;\r\ngoto error_put_host;\r\n}\r\n} else\r\ndprintk(2, "scsi(%li): 64 Bit PCI Addressing Enabled\n",\r\nha->host_no);\r\n#else\r\nif (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_WARNING "scsi(%li): Unable to set a "\r\n"suitable DMA mask - aborting\n", ha->host_no);\r\nerror = -ENODEV;\r\ngoto error_put_host;\r\n}\r\n#endif\r\nha->request_ring = pci_alloc_consistent(ha->pdev,\r\n((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),\r\n&ha->request_dma);\r\nif (!ha->request_ring) {\r\nprintk(KERN_INFO "qla1280: Failed to get request memory\n");\r\ngoto error_put_host;\r\n}\r\nha->response_ring = pci_alloc_consistent(ha->pdev,\r\n((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),\r\n&ha->response_dma);\r\nif (!ha->response_ring) {\r\nprintk(KERN_INFO "qla1280: Failed to get response memory\n");\r\ngoto error_free_request_ring;\r\n}\r\nha->ports = bdp->numPorts;\r\nha->host = host;\r\nha->host_no = host->host_no;\r\nhost->irq = pdev->irq;\r\nhost->max_channel = bdp->numPorts - 1;\r\nhost->max_lun = MAX_LUNS - 1;\r\nhost->max_id = MAX_TARGETS;\r\nhost->max_sectors = 1024;\r\nhost->unique_id = host->host_no;\r\nerror = -ENODEV;\r\n#if MEMORY_MAPPED_IO\r\nha->mmpbase = pci_ioremap_bar(ha->pdev, 1);\r\nif (!ha->mmpbase) {\r\nprintk(KERN_INFO "qla1280: Unable to map I/O memory\n");\r\ngoto error_free_response_ring;\r\n}\r\nhost->base = (unsigned long)ha->mmpbase;\r\nha->iobase = (struct device_reg __iomem *)ha->mmpbase;\r\n#else\r\nhost->io_port = pci_resource_start(ha->pdev, 0);\r\nif (!request_region(host->io_port, 0xff, "qla1280")) {\r\nprintk(KERN_INFO "qla1280: Failed to reserve i/o region "\r\n"0x%04lx-0x%04lx - already in use\n",\r\nhost->io_port, host->io_port + 0xff);\r\ngoto error_free_response_ring;\r\n}\r\nha->iobase = (struct device_reg *)host->io_port;\r\n#endif\r\nINIT_LIST_HEAD(&ha->done_q);\r\nqla1280_disable_intrs(ha);\r\nif (request_irq(pdev->irq, qla1280_intr_handler, IRQF_SHARED,\r\n"qla1280", ha)) {\r\nprintk("qla1280 : Failed to reserve interrupt %d already "\r\n"in use\n", pdev->irq);\r\ngoto error_release_region;\r\n}\r\nif (qla1280_initialize_adapter(ha)) {\r\nprintk(KERN_INFO "qla1x160: Failed to initialize adapter\n");\r\ngoto error_free_irq;\r\n}\r\nhost->this_id = ha->bus_settings[0].id;\r\npci_set_drvdata(pdev, host);\r\nerror = scsi_add_host(host, &pdev->dev);\r\nif (error)\r\ngoto error_disable_adapter;\r\nscsi_scan_host(host);\r\nreturn 0;\r\nerror_disable_adapter:\r\nqla1280_disable_intrs(ha);\r\nerror_free_irq:\r\nfree_irq(pdev->irq, ha);\r\nerror_release_region:\r\n#if MEMORY_MAPPED_IO\r\niounmap(ha->mmpbase);\r\n#else\r\nrelease_region(host->io_port, 0xff);\r\n#endif\r\nerror_free_response_ring:\r\npci_free_consistent(ha->pdev,\r\n((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),\r\nha->response_ring, ha->response_dma);\r\nerror_free_request_ring:\r\npci_free_consistent(ha->pdev,\r\n((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),\r\nha->request_ring, ha->request_dma);\r\nerror_put_host:\r\nscsi_host_put(host);\r\nerror_disable_device:\r\npci_disable_device(pdev);\r\nerror:\r\nreturn error;\r\n}\r\nstatic void __devexit\r\nqla1280_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;\r\nscsi_remove_host(host);\r\nqla1280_disable_intrs(ha);\r\nfree_irq(pdev->irq, ha);\r\n#if MEMORY_MAPPED_IO\r\niounmap(ha->mmpbase);\r\n#else\r\nrelease_region(host->io_port, 0xff);\r\n#endif\r\npci_free_consistent(ha->pdev,\r\n((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),\r\nha->request_ring, ha->request_dma);\r\npci_free_consistent(ha->pdev,\r\n((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),\r\nha->response_ring, ha->response_dma);\r\npci_disable_device(pdev);\r\nscsi_host_put(host);\r\n}\r\nstatic int __init\r\nqla1280_init(void)\r\n{\r\nif (sizeof(struct srb) > sizeof(struct scsi_pointer)) {\r\nprintk(KERN_WARNING\r\n"qla1280: struct srb too big, aborting\n");\r\nreturn -EINVAL;\r\n}\r\n#ifdef MODULE\r\nif (qla1280)\r\nqla1280_setup(qla1280);\r\n#endif\r\nreturn pci_register_driver(&qla1280_pci_driver);\r\n}\r\nstatic void __exit\r\nqla1280_exit(void)\r\n{\r\nint i;\r\npci_unregister_driver(&qla1280_pci_driver);\r\nfor (i = 0; i < QL_NUM_FW_IMAGES; i++) {\r\nrelease_firmware(qla1280_fw_tbl[i].fw);\r\nqla1280_fw_tbl[i].fw = NULL;\r\n}\r\n}
