int omap_lcd_dma_running(void)\r\n{\r\nif (cpu_is_omap15xx())\r\nif (omap_readw(OMAP_LCDC_CONTROL) & OMAP_LCDC_CTRL_LCD_EN)\r\nreturn 1;\r\nif (cpu_is_omap16xx())\r\nif (omap_readw(OMAP1610_DMA_LCD_CCR) & OMAP_DMA_CCR_EN)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid omap_set_lcd_dma_b1(unsigned long addr, u16 fb_xres, u16 fb_yres,\r\nint data_type)\r\n{\r\nlcd_dma.addr = addr;\r\nlcd_dma.data_type = data_type;\r\nlcd_dma.xres = fb_xres;\r\nlcd_dma.yres = fb_yres;\r\n}\r\nvoid omap_set_lcd_dma_ext_controller(int external)\r\n{\r\nlcd_dma.ext_ctrl = external;\r\n}\r\nvoid omap_set_lcd_dma_single_transfer(int single)\r\n{\r\nlcd_dma.single_transfer = single;\r\n}\r\nvoid omap_set_lcd_dma_b1_rotation(int rotate)\r\n{\r\nif (cpu_is_omap15xx()) {\r\nprintk(KERN_ERR "DMA rotation is not supported in 1510 mode\n");\r\nBUG();\r\nreturn;\r\n}\r\nlcd_dma.rotate = rotate;\r\n}\r\nvoid omap_set_lcd_dma_b1_mirror(int mirror)\r\n{\r\nif (cpu_is_omap15xx()) {\r\nprintk(KERN_ERR "DMA mirror is not supported in 1510 mode\n");\r\nBUG();\r\n}\r\nlcd_dma.mirror = mirror;\r\n}\r\nvoid omap_set_lcd_dma_b1_vxres(unsigned long vxres)\r\n{\r\nif (cpu_is_omap15xx()) {\r\nprintk(KERN_ERR "DMA virtual resolution is not supported "\r\n"in 1510 mode\n");\r\nBUG();\r\n}\r\nlcd_dma.vxres = vxres;\r\n}\r\nvoid omap_set_lcd_dma_b1_scale(unsigned int xscale, unsigned int yscale)\r\n{\r\nif (cpu_is_omap15xx()) {\r\nprintk(KERN_ERR "DMA scale is not supported in 1510 mode\n");\r\nBUG();\r\n}\r\nlcd_dma.xscale = xscale;\r\nlcd_dma.yscale = yscale;\r\n}\r\nstatic void set_b1_regs(void)\r\n{\r\nunsigned long top, bottom;\r\nint es;\r\nu16 w;\r\nunsigned long en, fn;\r\nlong ei, fi;\r\nunsigned long vxres;\r\nunsigned int xscale, yscale;\r\nswitch (lcd_dma.data_type) {\r\ncase OMAP_DMA_DATA_TYPE_S8:\r\nes = 1;\r\nbreak;\r\ncase OMAP_DMA_DATA_TYPE_S16:\r\nes = 2;\r\nbreak;\r\ncase OMAP_DMA_DATA_TYPE_S32:\r\nes = 4;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nvxres = lcd_dma.vxres ? lcd_dma.vxres : lcd_dma.xres;\r\nxscale = lcd_dma.xscale ? lcd_dma.xscale : 1;\r\nyscale = lcd_dma.yscale ? lcd_dma.yscale : 1;\r\nBUG_ON(vxres < lcd_dma.xres);\r\n#define PIXADDR(x, y) (lcd_dma.addr + \\r\n((y) * vxres * yscale + (x) * xscale) * es)\r\n#define PIXSTEP(sx, sy, dx, dy) (PIXADDR(dx, dy) - PIXADDR(sx, sy) - es + 1)\r\nswitch (lcd_dma.rotate) {\r\ncase 0:\r\nif (!lcd_dma.mirror) {\r\ntop = PIXADDR(0, 0);\r\nbottom = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\r\nif (cpu_is_omap15xx() &&\r\nlcd_dma.data_type == OMAP_DMA_DATA_TYPE_S32)\r\nbottom += 2;\r\nei = PIXSTEP(0, 0, 1, 0);\r\nfi = PIXSTEP(lcd_dma.xres - 1, 0, 0, 1);\r\n} else {\r\ntop = PIXADDR(lcd_dma.xres - 1, 0);\r\nbottom = PIXADDR(0, lcd_dma.yres - 1);\r\nei = PIXSTEP(1, 0, 0, 0);\r\nfi = PIXSTEP(0, 0, lcd_dma.xres - 1, 1);\r\n}\r\nen = lcd_dma.xres;\r\nfn = lcd_dma.yres;\r\nbreak;\r\ncase 90:\r\nif (!lcd_dma.mirror) {\r\ntop = PIXADDR(0, lcd_dma.yres - 1);\r\nbottom = PIXADDR(lcd_dma.xres - 1, 0);\r\nei = PIXSTEP(0, 1, 0, 0);\r\nfi = PIXSTEP(0, 0, 1, lcd_dma.yres - 1);\r\n} else {\r\ntop = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\r\nbottom = PIXADDR(0, 0);\r\nei = PIXSTEP(0, 1, 0, 0);\r\nfi = PIXSTEP(1, 0, 0, lcd_dma.yres - 1);\r\n}\r\nen = lcd_dma.yres;\r\nfn = lcd_dma.xres;\r\nbreak;\r\ncase 180:\r\nif (!lcd_dma.mirror) {\r\ntop = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\r\nbottom = PIXADDR(0, 0);\r\nei = PIXSTEP(1, 0, 0, 0);\r\nfi = PIXSTEP(0, 1, lcd_dma.xres - 1, 0);\r\n} else {\r\ntop = PIXADDR(0, lcd_dma.yres - 1);\r\nbottom = PIXADDR(lcd_dma.xres - 1, 0);\r\nei = PIXSTEP(0, 0, 1, 0);\r\nfi = PIXSTEP(lcd_dma.xres - 1, 1, 0, 0);\r\n}\r\nen = lcd_dma.xres;\r\nfn = lcd_dma.yres;\r\nbreak;\r\ncase 270:\r\nif (!lcd_dma.mirror) {\r\ntop = PIXADDR(lcd_dma.xres - 1, 0);\r\nbottom = PIXADDR(0, lcd_dma.yres - 1);\r\nei = PIXSTEP(0, 0, 0, 1);\r\nfi = PIXSTEP(1, lcd_dma.yres - 1, 0, 0);\r\n} else {\r\ntop = PIXADDR(0, 0);\r\nbottom = PIXADDR(lcd_dma.xres - 1, lcd_dma.yres - 1);\r\nei = PIXSTEP(0, 0, 0, 1);\r\nfi = PIXSTEP(0, lcd_dma.yres - 1, 1, 0);\r\n}\r\nen = lcd_dma.yres;\r\nfn = lcd_dma.xres;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nif (cpu_is_omap15xx()) {\r\nomap_writew(top >> 16, OMAP1510_DMA_LCD_TOP_F1_U);\r\nomap_writew(top, OMAP1510_DMA_LCD_TOP_F1_L);\r\nomap_writew(bottom >> 16, OMAP1510_DMA_LCD_BOT_F1_U);\r\nomap_writew(bottom, OMAP1510_DMA_LCD_BOT_F1_L);\r\nreturn;\r\n}\r\nomap_writew(top >> 16, OMAP1610_DMA_LCD_TOP_B1_U);\r\nomap_writew(top, OMAP1610_DMA_LCD_TOP_B1_L);\r\nomap_writew(bottom >> 16, OMAP1610_DMA_LCD_BOT_B1_U);\r\nomap_writew(bottom, OMAP1610_DMA_LCD_BOT_B1_L);\r\nomap_writew(en, OMAP1610_DMA_LCD_SRC_EN_B1);\r\nomap_writew(fn, OMAP1610_DMA_LCD_SRC_FN_B1);\r\nw = omap_readw(OMAP1610_DMA_LCD_CSDP);\r\nw &= ~0x03;\r\nw |= lcd_dma.data_type;\r\nomap_writew(w, OMAP1610_DMA_LCD_CSDP);\r\nw = omap_readw(OMAP1610_DMA_LCD_CTRL);\r\nw &= ~(0x03 << 6);\r\nif (lcd_dma.callback != NULL)\r\nw |= 1 << 1;\r\nelse\r\nw &= ~(1 << 1);\r\nomap_writew(w, OMAP1610_DMA_LCD_CTRL);\r\nif (!(lcd_dma.rotate || lcd_dma.mirror ||\r\nlcd_dma.vxres || lcd_dma.xscale || lcd_dma.yscale))\r\nreturn;\r\nw = omap_readw(OMAP1610_DMA_LCD_CCR);\r\nw |= (0x03 << 12);\r\nomap_writew(w, OMAP1610_DMA_LCD_CCR);\r\nomap_writew(ei, OMAP1610_DMA_LCD_SRC_EI_B1);\r\nomap_writew(fi >> 16, OMAP1610_DMA_LCD_SRC_FI_B1_U);\r\nomap_writew(fi, OMAP1610_DMA_LCD_SRC_FI_B1_L);\r\n}\r\nstatic irqreturn_t lcd_dma_irq_handler(int irq, void *dev_id)\r\n{\r\nu16 w;\r\nw = omap_readw(OMAP1610_DMA_LCD_CTRL);\r\nif (unlikely(!(w & (1 << 3)))) {\r\nprintk(KERN_WARNING "Spurious LCD DMA IRQ\n");\r\nreturn IRQ_NONE;\r\n}\r\nw |= (1 << 3);\r\nomap_writew(w, OMAP1610_DMA_LCD_CTRL);\r\nlcd_dma.active = 0;\r\nif (lcd_dma.callback != NULL)\r\nlcd_dma.callback(w, lcd_dma.cb_data);\r\nreturn IRQ_HANDLED;\r\n}\r\nint omap_request_lcd_dma(void (*callback)(u16 status, void *data),\r\nvoid *data)\r\n{\r\nspin_lock_irq(&lcd_dma.lock);\r\nif (lcd_dma.reserved) {\r\nspin_unlock_irq(&lcd_dma.lock);\r\nprintk(KERN_ERR "LCD DMA channel already reserved\n");\r\nBUG();\r\nreturn -EBUSY;\r\n}\r\nlcd_dma.reserved = 1;\r\nspin_unlock_irq(&lcd_dma.lock);\r\nlcd_dma.callback = callback;\r\nlcd_dma.cb_data = data;\r\nlcd_dma.active = 0;\r\nlcd_dma.single_transfer = 0;\r\nlcd_dma.rotate = 0;\r\nlcd_dma.vxres = 0;\r\nlcd_dma.mirror = 0;\r\nlcd_dma.xscale = 0;\r\nlcd_dma.yscale = 0;\r\nlcd_dma.ext_ctrl = 0;\r\nlcd_dma.src_port = 0;\r\nreturn 0;\r\n}\r\nvoid omap_free_lcd_dma(void)\r\n{\r\nspin_lock(&lcd_dma.lock);\r\nif (!lcd_dma.reserved) {\r\nspin_unlock(&lcd_dma.lock);\r\nprintk(KERN_ERR "LCD DMA is not reserved\n");\r\nBUG();\r\nreturn;\r\n}\r\nif (!cpu_is_omap15xx())\r\nomap_writew(omap_readw(OMAP1610_DMA_LCD_CCR) & ~1,\r\nOMAP1610_DMA_LCD_CCR);\r\nlcd_dma.reserved = 0;\r\nspin_unlock(&lcd_dma.lock);\r\n}\r\nvoid omap_enable_lcd_dma(void)\r\n{\r\nu16 w;\r\nif (cpu_is_omap15xx() || !lcd_dma.ext_ctrl)\r\nreturn;\r\nw = omap_readw(OMAP1610_DMA_LCD_CTRL);\r\nw |= 1 << 8;\r\nomap_writew(w, OMAP1610_DMA_LCD_CTRL);\r\nlcd_dma.active = 1;\r\nw = omap_readw(OMAP1610_DMA_LCD_CCR);\r\nw |= 1 << 7;\r\nomap_writew(w, OMAP1610_DMA_LCD_CCR);\r\n}\r\nvoid omap_setup_lcd_dma(void)\r\n{\r\nBUG_ON(lcd_dma.active);\r\nif (!cpu_is_omap15xx()) {\r\nomap_writew(0x5440, OMAP1610_DMA_LCD_CCR);\r\nomap_writew(0x9102, OMAP1610_DMA_LCD_CSDP);\r\nomap_writew(0x0004, OMAP1610_DMA_LCD_LCH_CTRL);\r\n}\r\nset_b1_regs();\r\nif (!cpu_is_omap15xx()) {\r\nu16 w;\r\nw = omap_readw(OMAP1610_DMA_LCD_CCR);\r\nw |= 1 << 11;\r\nif (!lcd_dma.single_transfer)\r\nw |= (3 << 8);\r\nomap_writew(w, OMAP1610_DMA_LCD_CCR);\r\n}\r\n}\r\nvoid omap_stop_lcd_dma(void)\r\n{\r\nu16 w;\r\nlcd_dma.active = 0;\r\nif (cpu_is_omap15xx() || !lcd_dma.ext_ctrl)\r\nreturn;\r\nw = omap_readw(OMAP1610_DMA_LCD_CCR);\r\nw &= ~(1 << 7);\r\nomap_writew(w, OMAP1610_DMA_LCD_CCR);\r\nw = omap_readw(OMAP1610_DMA_LCD_CTRL);\r\nw &= ~(1 << 8);\r\nomap_writew(w, OMAP1610_DMA_LCD_CTRL);\r\n}\r\nstatic int __init omap_init_lcd_dma(void)\r\n{\r\nint r;\r\nif (!cpu_class_is_omap1())\r\nreturn -ENODEV;\r\nif (cpu_is_omap16xx()) {\r\nu16 w;\r\nw = omap_readw(OMAP1610_DMA_LCD_CTRL);\r\nw &= ~(1 << 8);\r\nomap_writew(w, OMAP1610_DMA_LCD_CTRL);\r\n}\r\nspin_lock_init(&lcd_dma.lock);\r\nr = request_irq(INT_DMA_LCD, lcd_dma_irq_handler, 0,\r\n"LCD DMA", NULL);\r\nif (r != 0)\r\nprintk(KERN_ERR "unable to request IRQ for LCD DMA "\r\n"(error %d)\n", r);\r\nreturn r;\r\n}
