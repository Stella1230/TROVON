static int\r\nep_matches (\r\nstruct usb_gadget *gadget,\r\nstruct usb_ep *ep,\r\nstruct usb_endpoint_descriptor *desc,\r\nstruct usb_ss_ep_comp_descriptor *ep_comp\r\n)\r\n{\r\nu8 type;\r\nconst char *tmp;\r\nu16 max;\r\nint num_req_streams = 0;\r\nif (NULL != ep->driver_data)\r\nreturn 0;\r\ntype = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nif (USB_ENDPOINT_XFER_CONTROL == type)\r\nreturn 0;\r\nif ('e' != ep->name[0])\r\nreturn 0;\r\nif ('-' != ep->name[2]) {\r\ntmp = strrchr (ep->name, '-');\r\nif (tmp) {\r\nswitch (type) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif ('s' == tmp[2])\r\nreturn 0;\r\nif (gadget_is_pxa (gadget)\r\n&& 'i' == tmp [1])\r\nreturn 0;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif ('b' != tmp[1])\r\nreturn 0;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif ('s' != tmp[2])\r\nreturn 0;\r\n}\r\n} else {\r\ntmp = ep->name + strlen (ep->name);\r\n}\r\ntmp--;\r\nif (!isdigit (*tmp)) {\r\nif (desc->bEndpointAddress & USB_DIR_IN) {\r\nif ('n' != *tmp)\r\nreturn 0;\r\n} else {\r\nif ('t' != *tmp)\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (usb_endpoint_xfer_bulk(desc)) {\r\nif (ep_comp && gadget->max_speed >= USB_SPEED_SUPER) {\r\nnum_req_streams = ep_comp->bmAttributes & 0x1f;\r\nif (num_req_streams > ep->max_streams)\r\nreturn 0;\r\n}\r\n}\r\nif (desc->wMaxPacketSize == 0)\r\ndesc->wMaxPacketSize = cpu_to_le16(ep->maxpacket);\r\nmax = 0x7ff & usb_endpoint_maxp(desc);\r\nswitch (type) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (!gadget_is_dualspeed(gadget) && max > 64)\r\nreturn 0;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (ep->maxpacket < max)\r\nreturn 0;\r\nif (!gadget_is_dualspeed(gadget) && max > 1023)\r\nreturn 0;\r\nif ((desc->wMaxPacketSize & cpu_to_le16(3<<11))) {\r\nif (!gadget_is_dualspeed(gadget))\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\ndesc->bEndpointAddress &= USB_DIR_IN;\r\nif (isdigit (ep->name [2])) {\r\nu8 num = simple_strtoul (&ep->name [2], NULL, 10);\r\ndesc->bEndpointAddress |= num;\r\n#ifdef MANY_ENDPOINTS\r\n} else if (desc->bEndpointAddress & USB_DIR_IN) {\r\nif (++in_epnum > 15)\r\nreturn 0;\r\ndesc->bEndpointAddress = USB_DIR_IN | in_epnum;\r\n#endif\r\n} else {\r\nif (++epnum > 15)\r\nreturn 0;\r\ndesc->bEndpointAddress |= epnum;\r\n}\r\nif ((USB_ENDPOINT_XFER_BULK == type) && !ep_comp) {\r\nint size = ep->maxpacket;\r\nif (size > 64)\r\nsize = 64;\r\ndesc->wMaxPacketSize = cpu_to_le16(size);\r\n}\r\nep->address = desc->bEndpointAddress;\r\nreturn 1;\r\n}\r\nstatic struct usb_ep *\r\nfind_ep (struct usb_gadget *gadget, const char *name)\r\n{\r\nstruct usb_ep *ep;\r\nlist_for_each_entry (ep, &gadget->ep_list, ep_list) {\r\nif (0 == strcmp (ep->name, name))\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstruct usb_ep *usb_ep_autoconfig_ss(\r\nstruct usb_gadget *gadget,\r\nstruct usb_endpoint_descriptor *desc,\r\nstruct usb_ss_ep_comp_descriptor *ep_comp\r\n)\r\n{\r\nstruct usb_ep *ep;\r\nu8 type;\r\ntype = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nif (gadget_is_net2280 (gadget) && type == USB_ENDPOINT_XFER_INT) {\r\nep = find_ep (gadget, "ep-e");\r\nif (ep && ep_matches(gadget, ep, desc, ep_comp))\r\ngoto found_ep;\r\nep = find_ep (gadget, "ep-f");\r\nif (ep && ep_matches(gadget, ep, desc, ep_comp))\r\ngoto found_ep;\r\n} else if (gadget_is_goku (gadget)) {\r\nif (USB_ENDPOINT_XFER_INT == type) {\r\nep = find_ep(gadget, "ep3-bulk");\r\nif (ep && ep_matches(gadget, ep, desc, ep_comp))\r\ngoto found_ep;\r\n} else if (USB_ENDPOINT_XFER_BULK == type\r\n&& (USB_DIR_IN & desc->bEndpointAddress)) {\r\nep = find_ep(gadget, "ep2-bulk");\r\nif (ep && ep_matches(gadget, ep, desc,\r\nep_comp))\r\ngoto found_ep;\r\n}\r\n#ifdef CONFIG_BLACKFIN\r\n} else if (gadget_is_musbhdrc(gadget)) {\r\nif ((USB_ENDPOINT_XFER_BULK == type) ||\r\n(USB_ENDPOINT_XFER_ISOC == type)) {\r\nif (USB_DIR_IN & desc->bEndpointAddress)\r\nep = find_ep (gadget, "ep5in");\r\nelse\r\nep = find_ep (gadget, "ep6out");\r\n} else if (USB_ENDPOINT_XFER_INT == type) {\r\nif (USB_DIR_IN & desc->bEndpointAddress)\r\nep = find_ep(gadget, "ep1in");\r\nelse\r\nep = find_ep(gadget, "ep2out");\r\n} else\r\nep = NULL;\r\nif (ep && ep_matches(gadget, ep, desc, ep_comp))\r\ngoto found_ep;\r\n#endif\r\n}\r\nlist_for_each_entry (ep, &gadget->ep_list, ep_list) {\r\nif (ep_matches(gadget, ep, desc, ep_comp))\r\ngoto found_ep;\r\n}\r\nreturn NULL;\r\nfound_ep:\r\nep->desc = NULL;\r\nep->comp_desc = NULL;\r\nreturn ep;\r\n}\r\nstruct usb_ep *usb_ep_autoconfig(\r\nstruct usb_gadget *gadget,\r\nstruct usb_endpoint_descriptor *desc\r\n)\r\n{\r\nreturn usb_ep_autoconfig_ss(gadget, desc, NULL);\r\n}\r\nvoid usb_ep_autoconfig_reset (struct usb_gadget *gadget)\r\n{\r\nstruct usb_ep *ep;\r\nlist_for_each_entry (ep, &gadget->ep_list, ep_list) {\r\nep->driver_data = NULL;\r\n}\r\n#ifdef MANY_ENDPOINTS\r\nin_epnum = 0;\r\n#endif\r\nepnum = 0;\r\n}
