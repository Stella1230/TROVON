int adjust_standard(struct easycap *peasycap, v4l2_std_id std_id)\r\n{\r\nstruct easycap_standard const *peasycap_standard;\r\nu16 reg, set;\r\nint ir, rc, need, k;\r\nunsigned int itwas, isnow;\r\nbool resubmit;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npeasycap_standard = &easycap_standard[0];\r\nwhile (0xFFFF != peasycap_standard->mask) {\r\nif (std_id == peasycap_standard->v4l2_standard.id)\r\nbreak;\r\npeasycap_standard++;\r\n}\r\nif (0xFFFF == peasycap_standard->mask) {\r\npeasycap_standard = &easycap_standard[0];\r\nwhile (0xFFFF != peasycap_standard->mask) {\r\nif (std_id & peasycap_standard->v4l2_standard.id)\r\nbreak;\r\npeasycap_standard++;\r\n}\r\n}\r\nif (0xFFFF == peasycap_standard->mask) {\r\nSAM("ERROR: 0x%08X=std_id: standard not found\n",\r\n(unsigned int)std_id);\r\nreturn -EINVAL;\r\n}\r\nSAM("selected standard: %s\n",\r\n&(peasycap_standard->v4l2_standard.name[0]));\r\nif (peasycap->standard_offset == peasycap_standard - easycap_standard) {\r\nSAM("requested standard already in effect\n");\r\nreturn 0;\r\n}\r\npeasycap->standard_offset = peasycap_standard - easycap_standard;\r\nfor (k = 0; k < INPUT_MANY; k++) {\r\nif (!peasycap->inputset[k].standard_offset_ok) {\r\npeasycap->inputset[k].standard_offset =\r\npeasycap->standard_offset;\r\n}\r\n}\r\nif ((0 <= peasycap->input) && (INPUT_MANY > peasycap->input)) {\r\npeasycap->inputset[peasycap->input].standard_offset =\r\npeasycap->standard_offset;\r\npeasycap->inputset[peasycap->input].standard_offset_ok = 1;\r\n} else\r\nJOM(8, "%i=peasycap->input\n", peasycap->input);\r\npeasycap->fps = peasycap_standard->v4l2_standard.frameperiod.denominator /\r\npeasycap_standard->v4l2_standard.frameperiod.numerator;\r\nswitch (peasycap->fps) {\r\ncase 6:\r\ncase 30: {\r\npeasycap->ntsc = true;\r\nbreak;\r\n}\r\ncase 5:\r\ncase 25: {\r\npeasycap->ntsc = false;\r\nbreak;\r\n}\r\ndefault: {\r\nSAM("MISTAKE: %i=frames-per-second\n", peasycap->fps);\r\nreturn -ENOENT;\r\n}\r\n}\r\nJOM(8, "%i frames-per-second\n", peasycap->fps);\r\nif (0x8000 & peasycap_standard->mask) {\r\npeasycap->skip = 5;\r\npeasycap->usec = 1000000 / (2 * (5 * peasycap->fps));\r\npeasycap->tolerate = 1000 * (25 / (5 * peasycap->fps));\r\n} else {\r\npeasycap->skip = 0;\r\npeasycap->usec = 1000000 / (2 * peasycap->fps);\r\npeasycap->tolerate = 1000 * (25 / peasycap->fps);\r\n}\r\nif (peasycap->video_isoc_streaming) {\r\nresubmit = true;\r\neasycap_video_kill_urbs(peasycap);\r\n} else\r\nresubmit = false;\r\nneed = 0;\r\nitwas = 0;\r\nreg = 0x00;\r\nset = 0x00;\r\nswitch (peasycap_standard->mask & 0x000F) {\r\ncase NTSC_M_JP: {\r\nreg = 0x0A;\r\nset = 0x95;\r\nir = read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nSAM("ERROR: cannot read SAA register 0x%02X\n", reg);\r\nelse\r\nitwas = (unsigned int)ir;\r\nrc = write_saa(peasycap->pusb_device, reg, set);\r\nif (rc)\r\nSAM("ERROR: failed to set SAA register "\r\n"0x%02X to 0x%02X for JP standard\n", reg, set);\r\nelse {\r\nisnow = (unsigned int)read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nJOM(8, "SAA register 0x%02X changed "\r\n"to 0x%02X\n", reg, isnow);\r\nelse\r\nJOM(8, "SAA register 0x%02X changed "\r\n"from 0x%02X to 0x%02X\n", reg, itwas, isnow);\r\n}\r\nreg = 0x0B;\r\nset = 0x48;\r\nir = read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nSAM("ERROR: cannot read SAA register 0x%02X\n", reg);\r\nelse\r\nitwas = (unsigned int)ir;\r\nrc = write_saa(peasycap->pusb_device, reg, set);\r\nif (rc)\r\nSAM("ERROR: failed to set SAA register 0x%02X to 0x%02X "\r\n"for JP standard\n", reg, set);\r\nelse {\r\nisnow = (unsigned int)read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nJOM(8, "SAA register 0x%02X changed "\r\n"to 0x%02X\n", reg, isnow);\r\nelse\r\nJOM(8, "SAA register 0x%02X changed "\r\n"from 0x%02X to 0x%02X\n", reg, itwas, isnow);\r\n}\r\n}\r\ncase NTSC_M:\r\ncase PAL_BGHIN: {\r\nreg = 0x0E;\r\nset = 0x01;\r\nneed = 1;\r\nbreak;\r\n}\r\ncase NTSC_N_443:\r\ncase PAL_60: {\r\nreg = 0x0E;\r\nset = 0x11;\r\nneed = 1;\r\nbreak;\r\n}\r\ncase NTSC_443:\r\ncase PAL_Nc: {\r\nreg = 0x0E;\r\nset = 0x21;\r\nneed = 1;\r\nbreak;\r\n}\r\ncase NTSC_N:\r\ncase PAL_M: {\r\nreg = 0x0E;\r\nset = 0x31;\r\nneed = 1;\r\nbreak;\r\n}\r\ncase SECAM: {\r\nreg = 0x0E;\r\nset = 0x51;\r\nneed = 1;\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (need) {\r\nir = read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nSAM("ERROR: failed to read SAA register 0x%02X\n", reg);\r\nelse\r\nitwas = (unsigned int)ir;\r\nrc = write_saa(peasycap->pusb_device, reg, set);\r\nif (0 != write_saa(peasycap->pusb_device, reg, set)) {\r\nSAM("ERROR: failed to set SAA register "\r\n"0x%02X to 0x%02X for table 42\n", reg, set);\r\n} else {\r\nisnow = (unsigned int)read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nJOM(8, "SAA register 0x%02X changed "\r\n"to 0x%02X\n", reg, isnow);\r\nelse\r\nJOM(8, "SAA register 0x%02X changed "\r\n"from 0x%02X to 0x%02X\n", reg, itwas, isnow);\r\n}\r\n}\r\nreg = 0x08;\r\nir = read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nSAM("ERROR: failed to read SAA register 0x%02X "\r\n"so cannot reset\n", reg);\r\nelse {\r\nitwas = (unsigned int)ir;\r\nif (peasycap_standard->mask & 0x0001)\r\nset = itwas | 0x40 ;\r\nelse\r\nset = itwas & ~0x40 ;\r\nrc = write_saa(peasycap->pusb_device, reg, set);\r\nif (rc)\r\nSAM("ERROR: failed to set SAA register 0x%02X to 0x%02X\n",\r\nreg, set);\r\nelse {\r\nisnow = (unsigned int)read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nJOM(8, "SAA register 0x%02X changed to 0x%02X\n",\r\nreg, isnow);\r\nelse\r\nJOM(8, "SAA register 0x%02X changed "\r\n"from 0x%02X to 0x%02X\n", reg, itwas, isnow);\r\n}\r\n}\r\nreg = 0x40;\r\nir = read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nSAM("ERROR: failed to read SAA register 0x%02X "\r\n"so cannot reset\n", reg);\r\nelse {\r\nitwas = (unsigned int)ir;\r\nif (peasycap_standard->mask & 0x0001)\r\nset = itwas | 0x80 ;\r\nelse\r\nset = itwas & ~0x80 ;\r\nrc = write_saa(peasycap->pusb_device, reg, set);\r\nif (rc)\r\nSAM("ERROR: failed to set SAA register 0x%02X to 0x%02X\n",\r\nreg, set);\r\nelse {\r\nisnow = (unsigned int)read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nJOM(8, "SAA register 0x%02X changed to 0x%02X\n",\r\nreg, isnow);\r\nelse\r\nJOM(8, "SAA register 0x%02X changed "\r\n"from 0x%02X to 0x%02X\n", reg, itwas, isnow);\r\n}\r\n}\r\nreg = 0x5A;\r\nir = read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nSAM("ERROR: failed to read SAA register 0x%02X but continuing\n", reg);\r\nitwas = (unsigned int)ir;\r\nif (peasycap_standard->mask & 0x0001)\r\nset = 0x0A ;\r\nelse\r\nset = 0x07 ;\r\nif (0 != write_saa(peasycap->pusb_device, reg, set))\r\nSAM("ERROR: failed to set SAA register 0x%02X to 0x%02X\n",\r\nreg, set);\r\nelse {\r\nisnow = (unsigned int)read_saa(peasycap->pusb_device, reg);\r\nif (0 > ir)\r\nJOM(8, "SAA register 0x%02X changed "\r\n"to 0x%02X\n", reg, isnow);\r\nelse\r\nJOM(8, "SAA register 0x%02X changed "\r\n"from 0x%02X to 0x%02X\n", reg, itwas, isnow);\r\n}\r\nif (resubmit)\r\neasycap_video_submit_urbs(peasycap);\r\nreturn 0;\r\n}\r\nint adjust_format(struct easycap *peasycap,\r\nu32 width, u32 height, u32 pixelformat, int field, bool try)\r\n{\r\nstruct easycap_format *peasycap_format, *peasycap_best_format;\r\nu16 mask;\r\nstruct usb_device *p;\r\nint miss, multiplier, best, k;\r\nchar bf[5], fo[32], *pc;\r\nu32 uc;\r\nbool resubmit;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (0 > peasycap->standard_offset) {\r\nJOM(8, "%i=peasycap->standard_offset\n", peasycap->standard_offset);\r\nreturn -EBUSY;\r\n}\r\np = peasycap->pusb_device;\r\nif (!p) {\r\nSAM("ERROR: peaycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npc = &bf[0];\r\nuc = pixelformat;\r\nmemcpy((void *)pc, (void *)(&uc), 4);\r\nbf[4] = 0;\r\nmask = 0xFF & easycap_standard[peasycap->standard_offset].mask;\r\nSAM("sought: %ix%i,%s(0x%08X),%i=field,0x%02X=std mask\n",\r\nwidth, height, pc, pixelformat, field, mask);\r\nswitch (field) {\r\ncase V4L2_FIELD_ANY: {\r\nstrcpy(&fo[0], "V4L2_FIELD_ANY ");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_NONE: {\r\nstrcpy(&fo[0], "V4L2_FIELD_NONE");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_TOP: {\r\nstrcpy(&fo[0], "V4L2_FIELD_TOP");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_BOTTOM: {\r\nstrcpy(&fo[0], "V4L2_FIELD_BOTTOM");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_INTERLACED: {\r\nstrcpy(&fo[0], "V4L2_FIELD_INTERLACED");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_SEQ_TB: {\r\nstrcpy(&fo[0], "V4L2_FIELD_SEQ_TB");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_SEQ_BT: {\r\nstrcpy(&fo[0], "V4L2_FIELD_SEQ_BT");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_ALTERNATE: {\r\nstrcpy(&fo[0], "V4L2_FIELD_ALTERNATE");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_INTERLACED_TB: {\r\nstrcpy(&fo[0], "V4L2_FIELD_INTERLACED_TB");\r\nbreak;\r\n}\r\ncase V4L2_FIELD_INTERLACED_BT: {\r\nstrcpy(&fo[0], "V4L2_FIELD_INTERLACED_BT");\r\nbreak;\r\n}\r\ndefault: {\r\nstrcpy(&fo[0], "V4L2_FIELD_... UNKNOWN ");\r\nbreak;\r\n}\r\n}\r\nSAM("sought: %s\n", &fo[0]);\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = V4L2_FIELD_NONE;\r\nSAM("prefer: V4L2_FIELD_NONE=field, was V4L2_FIELD_ANY\n");\r\n}\r\npeasycap_best_format = NULL;\r\npeasycap_format = &easycap_format[0];\r\nwhile (0 != peasycap_format->v4l2_format.fmt.pix.width) {\r\nJOM(16, ".> %i %i 0x%08X %ix%i\n",\r\npeasycap_format->mask & 0x01,\r\npeasycap_format->v4l2_format.fmt.pix.field,\r\npeasycap_format->v4l2_format.fmt.pix.pixelformat,\r\npeasycap_format->v4l2_format.fmt.pix.width,\r\npeasycap_format->v4l2_format.fmt.pix.height);\r\nif (((peasycap_format->mask & 0x1F) == (mask & 0x1F)) &&\r\n(peasycap_format->v4l2_format.fmt.pix.field == field) &&\r\n(peasycap_format->v4l2_format.fmt.pix.pixelformat == pixelformat) &&\r\n(peasycap_format->v4l2_format.fmt.pix.width == width) &&\r\n(peasycap_format->v4l2_format.fmt.pix.height == height)) {\r\npeasycap_best_format = peasycap_format;\r\nbreak;\r\n}\r\npeasycap_format++;\r\n}\r\nif (0 == peasycap_format->v4l2_format.fmt.pix.width) {\r\nSAM("cannot do: %ix%i with standard mask 0x%02X\n",\r\nwidth, height, mask);\r\npeasycap_format = &easycap_format[0];\r\nbest = -1;\r\nwhile (0 != peasycap_format->v4l2_format.fmt.pix.width) {\r\nif (((peasycap_format->mask & 0x1F) == (mask & 0x1F)) &&\r\n(peasycap_format->v4l2_format.fmt.pix.field == field) &&\r\n(peasycap_format->v4l2_format.fmt.pix.pixelformat == pixelformat)) {\r\nmiss = abs(peasycap_format->v4l2_format.fmt.pix.width - width);\r\nif ((best > miss) || (best < 0)) {\r\nbest = miss;\r\npeasycap_best_format = peasycap_format;\r\nif (!miss)\r\nbreak;\r\n}\r\n}\r\npeasycap_format++;\r\n}\r\nif (-1 == best) {\r\nSAM("cannot do %ix... with standard mask 0x%02X\n",\r\nwidth, mask);\r\nSAM("cannot do ...x%i with standard mask 0x%02X\n",\r\nheight, mask);\r\nSAM(" %ix%i unmatched\n", width, height);\r\nreturn peasycap->format_offset;\r\n}\r\n}\r\nif (!peasycap_best_format) {\r\nSAM("MISTAKE: peasycap_best_format is NULL");\r\nreturn -EINVAL;\r\n}\r\npeasycap_format = peasycap_best_format;\r\nif (try)\r\nreturn peasycap_best_format - easycap_format;\r\nif (false != try) {\r\nSAM("MISTAKE: true==try where is should be false\n");\r\nreturn -EINVAL;\r\n}\r\nSAM("actioning: %ix%i %s\n",\r\npeasycap_format->v4l2_format.fmt.pix.width,\r\npeasycap_format->v4l2_format.fmt.pix.height,\r\n&peasycap_format->name[0]);\r\npeasycap->height = peasycap_format->v4l2_format.fmt.pix.height;\r\npeasycap->width = peasycap_format->v4l2_format.fmt.pix.width;\r\npeasycap->pixelformat = peasycap_format->v4l2_format.fmt.pix.pixelformat;\r\npeasycap->format_offset = peasycap_format - easycap_format;\r\nfor (k = 0; k < INPUT_MANY; k++) {\r\nif (!peasycap->inputset[k].format_offset_ok) {\r\npeasycap->inputset[k].format_offset =\r\npeasycap->format_offset;\r\n}\r\n}\r\nif ((0 <= peasycap->input) && (INPUT_MANY > peasycap->input)) {\r\npeasycap->inputset[peasycap->input].format_offset =\r\npeasycap->format_offset;\r\npeasycap->inputset[peasycap->input].format_offset_ok = 1;\r\n} else\r\nJOM(8, "%i=peasycap->input\n", peasycap->input);\r\npeasycap->bytesperpixel = (0x00E0 & peasycap_format->mask) >> 5 ;\r\nif (0x0100 & peasycap_format->mask)\r\npeasycap->byteswaporder = true;\r\nelse\r\npeasycap->byteswaporder = false;\r\nif (0x0200 & peasycap_format->mask)\r\npeasycap->skip = 5;\r\nelse\r\npeasycap->skip = 0;\r\nif (0x0800 & peasycap_format->mask)\r\npeasycap->decimatepixel = true;\r\nelse\r\npeasycap->decimatepixel = false;\r\nif (0x1000 & peasycap_format->mask)\r\npeasycap->offerfields = true;\r\nelse\r\npeasycap->offerfields = false;\r\nif (peasycap->decimatepixel)\r\nmultiplier = 2;\r\nelse\r\nmultiplier = 1;\r\npeasycap->videofieldamount =\r\nmultiplier * peasycap->width * multiplier * peasycap->height;\r\npeasycap->frame_buffer_used =\r\npeasycap->bytesperpixel * peasycap->width * peasycap->height;\r\nif (peasycap->video_isoc_streaming) {\r\nresubmit = true;\r\neasycap_video_kill_urbs(peasycap);\r\n} else\r\nresubmit = false;\r\nif (0 == (0x01 & peasycap_format->mask)) {\r\nif (((720 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(576 == peasycap_format->v4l2_format.fmt.pix.height)) ||\r\n((360 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(288 == peasycap_format->v4l2_format.fmt.pix.height))) {\r\nif (set_resolution(p, 0x0000, 0x0001, 0x05A0, 0x0121)) {\r\nSAM("ERROR: set_resolution() failed\n");\r\nreturn -EINVAL;\r\n}\r\n} else if ((704 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(576 == peasycap_format->v4l2_format.fmt.pix.height)) {\r\nif (set_resolution(p, 0x0004, 0x0001, 0x0584, 0x0121)) {\r\nSAM("ERROR: set_resolution() failed\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (((640 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(480 == peasycap_format->v4l2_format.fmt.pix.height)) ||\r\n((320 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(240 == peasycap_format->v4l2_format.fmt.pix.height))) {\r\nif (set_resolution(p, 0x0014, 0x0020, 0x0514, 0x0110)) {\r\nSAM("ERROR: set_resolution() failed\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nSAM("MISTAKE: bad format, cannot set resolution\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (((720 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(480 == peasycap_format->v4l2_format.fmt.pix.height)) ||\r\n((360 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(240 == peasycap_format->v4l2_format.fmt.pix.height))) {\r\nif (set_resolution(p, 0x0000, 0x0003, 0x05A0, 0x00F3)) {\r\nSAM("ERROR: set_resolution() failed\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (((640 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(480 == peasycap_format->v4l2_format.fmt.pix.height)) ||\r\n((320 == peasycap_format->v4l2_format.fmt.pix.width) &&\r\n(240 == peasycap_format->v4l2_format.fmt.pix.height))) {\r\nif (set_resolution(p, 0x0014, 0x0003, 0x0514, 0x00F3)) {\r\nSAM("ERROR: set_resolution() failed\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nSAM("MISTAKE: bad format, cannot set resolution\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (resubmit)\r\neasycap_video_submit_urbs(peasycap);\r\nreturn peasycap_best_format - easycap_format;\r\n}\r\nint adjust_brightness(struct easycap *peasycap, int value)\r\n{\r\nunsigned int mood;\r\nint i1, k;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\ni1 = 0;\r\nwhile (0xFFFFFFFF != easycap_control[i1].id) {\r\nif (V4L2_CID_BRIGHTNESS == easycap_control[i1].id) {\r\nif ((easycap_control[i1].minimum > value) ||\r\n(easycap_control[i1].maximum < value))\r\nvalue = easycap_control[i1].default_value;\r\nif ((easycap_control[i1].minimum <= peasycap->brightness) &&\r\n(easycap_control[i1].maximum >= peasycap->brightness)) {\r\nif (peasycap->brightness == value) {\r\nSAM("unchanged brightness at 0x%02X\n",\r\nvalue);\r\nreturn 0;\r\n}\r\n}\r\npeasycap->brightness = value;\r\nfor (k = 0; k < INPUT_MANY; k++) {\r\nif (!peasycap->inputset[k].brightness_ok)\r\npeasycap->inputset[k].brightness =\r\npeasycap->brightness;\r\n}\r\nif ((0 <= peasycap->input) && (INPUT_MANY > peasycap->input)) {\r\npeasycap->inputset[peasycap->input].brightness =\r\npeasycap->brightness;\r\npeasycap->inputset[peasycap->input].brightness_ok = 1;\r\n} else\r\nJOM(8, "%i=peasycap->input\n", peasycap->input);\r\nmood = 0x00FF & (unsigned int)peasycap->brightness;\r\nif (write_saa(peasycap->pusb_device, 0x0A, mood)) {\r\nSAM("WARNING: failed to adjust brightness "\r\n"to 0x%02X\n", mood);\r\nreturn -ENOENT;\r\n}\r\nSAM("adjusting brightness to 0x%02X\n", mood);\r\nreturn 0;\r\n}\r\ni1++;\r\n}\r\nSAM("WARNING: failed to adjust brightness: control not found\n");\r\nreturn -ENOENT;\r\n}\r\nint adjust_contrast(struct easycap *peasycap, int value)\r\n{\r\nunsigned int mood;\r\nint i1, k;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\ni1 = 0;\r\nwhile (0xFFFFFFFF != easycap_control[i1].id) {\r\nif (V4L2_CID_CONTRAST == easycap_control[i1].id) {\r\nif ((easycap_control[i1].minimum > value) ||\r\n(easycap_control[i1].maximum < value))\r\nvalue = easycap_control[i1].default_value;\r\nif ((easycap_control[i1].minimum <= peasycap->contrast) &&\r\n(easycap_control[i1].maximum >= peasycap->contrast)) {\r\nif (peasycap->contrast == value) {\r\nSAM("unchanged contrast at 0x%02X\n", value);\r\nreturn 0;\r\n}\r\n}\r\npeasycap->contrast = value;\r\nfor (k = 0; k < INPUT_MANY; k++) {\r\nif (!peasycap->inputset[k].contrast_ok)\r\npeasycap->inputset[k].contrast = peasycap->contrast;\r\n}\r\nif ((0 <= peasycap->input) && (INPUT_MANY > peasycap->input)) {\r\npeasycap->inputset[peasycap->input].contrast =\r\npeasycap->contrast;\r\npeasycap->inputset[peasycap->input].contrast_ok = 1;\r\n} else\r\nJOM(8, "%i=peasycap->input\n", peasycap->input);\r\nmood = 0x00FF & (unsigned int) (peasycap->contrast - 128);\r\nif (write_saa(peasycap->pusb_device, 0x0B, mood)) {\r\nSAM("WARNING: failed to adjust contrast to "\r\n"0x%02X\n", mood);\r\nreturn -ENOENT;\r\n}\r\nSAM("adjusting contrast to 0x%02X\n", mood);\r\nreturn 0;\r\n}\r\ni1++;\r\n}\r\nSAM("WARNING: failed to adjust contrast: control not found\n");\r\nreturn -ENOENT;\r\n}\r\nint adjust_saturation(struct easycap *peasycap, int value)\r\n{\r\nunsigned int mood;\r\nint i1, k;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\ni1 = 0;\r\nwhile (0xFFFFFFFF != easycap_control[i1].id) {\r\nif (V4L2_CID_SATURATION == easycap_control[i1].id) {\r\nif ((easycap_control[i1].minimum > value) ||\r\n(easycap_control[i1].maximum < value))\r\nvalue = easycap_control[i1].default_value;\r\nif ((easycap_control[i1].minimum <= peasycap->saturation) &&\r\n(easycap_control[i1].maximum >= peasycap->saturation)) {\r\nif (peasycap->saturation == value) {\r\nSAM("unchanged saturation at 0x%02X\n",\r\nvalue);\r\nreturn 0;\r\n}\r\n}\r\npeasycap->saturation = value;\r\nfor (k = 0; k < INPUT_MANY; k++) {\r\nif (!peasycap->inputset[k].saturation_ok)\r\npeasycap->inputset[k].saturation =\r\npeasycap->saturation;\r\n}\r\nif ((0 <= peasycap->input) && (INPUT_MANY > peasycap->input)) {\r\npeasycap->inputset[peasycap->input].saturation =\r\npeasycap->saturation;\r\npeasycap->inputset[peasycap->input].saturation_ok = 1;\r\n} else\r\nJOM(8, "%i=peasycap->input\n", peasycap->input);\r\nmood = 0x00FF & (unsigned int) (peasycap->saturation - 128);\r\nif (write_saa(peasycap->pusb_device, 0x0C, mood)) {\r\nSAM("WARNING: failed to adjust saturation to "\r\n"0x%02X\n", mood);\r\nreturn -ENOENT;\r\n}\r\nSAM("adjusting saturation to 0x%02X\n", mood);\r\nreturn 0;\r\nbreak;\r\n}\r\ni1++;\r\n}\r\nSAM("WARNING: failed to adjust saturation: control not found\n");\r\nreturn -ENOENT;\r\n}\r\nint adjust_hue(struct easycap *peasycap, int value)\r\n{\r\nunsigned int mood;\r\nint i1, i2, k;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\ni1 = 0;\r\nwhile (0xFFFFFFFF != easycap_control[i1].id) {\r\nif (V4L2_CID_HUE == easycap_control[i1].id) {\r\nif ((easycap_control[i1].minimum > value) ||\r\n(easycap_control[i1].maximum < value))\r\nvalue = easycap_control[i1].default_value;\r\nif ((easycap_control[i1].minimum <= peasycap->hue) &&\r\n(easycap_control[i1].maximum >= peasycap->hue)) {\r\nif (peasycap->hue == value) {\r\nSAM("unchanged hue at 0x%02X\n", value);\r\nreturn 0;\r\n}\r\n}\r\npeasycap->hue = value;\r\nfor (k = 0; k < INPUT_MANY; k++) {\r\nif (!peasycap->inputset[k].hue_ok)\r\npeasycap->inputset[k].hue = peasycap->hue;\r\n}\r\nif (0 <= peasycap->input && INPUT_MANY > peasycap->input) {\r\npeasycap->inputset[peasycap->input].hue = peasycap->hue;\r\npeasycap->inputset[peasycap->input].hue_ok = 1;\r\n} else\r\nJOM(8, "%i=peasycap->input\n", peasycap->input);\r\ni2 = peasycap->hue - 128;\r\nmood = 0x00FF & ((int) i2);\r\nif (write_saa(peasycap->pusb_device, 0x0D, mood)) {\r\nSAM("WARNING: failed to adjust hue to 0x%02X\n", mood);\r\nreturn -ENOENT;\r\n}\r\nSAM("adjusting hue to 0x%02X\n", mood);\r\nreturn 0;\r\nbreak;\r\n}\r\ni1++;\r\n}\r\nSAM("WARNING: failed to adjust hue: control not found\n");\r\nreturn -ENOENT;\r\n}\r\nstatic int adjust_volume(struct easycap *peasycap, int value)\r\n{\r\ns8 mood;\r\nint i1;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\ni1 = 0;\r\nwhile (0xFFFFFFFF != easycap_control[i1].id) {\r\nif (V4L2_CID_AUDIO_VOLUME == easycap_control[i1].id) {\r\nif ((easycap_control[i1].minimum > value) ||\r\n(easycap_control[i1].maximum < value))\r\nvalue = easycap_control[i1].default_value;\r\nif ((easycap_control[i1].minimum <= peasycap->volume) &&\r\n(easycap_control[i1].maximum >= peasycap->volume)) {\r\nif (peasycap->volume == value) {\r\nSAM("unchanged volume at 0x%02X\n", value);\r\nreturn 0;\r\n}\r\n}\r\npeasycap->volume = value;\r\nmood = (16 > peasycap->volume) ? 16 :\r\n((31 < peasycap->volume) ? 31 :\r\n(s8) peasycap->volume);\r\nif (!easycap_audio_gainset(peasycap->pusb_device, mood)) {\r\nSAM("WARNING: failed to adjust volume to "\r\n"0x%2X\n", mood);\r\nreturn -ENOENT;\r\n}\r\nSAM("adjusting volume to 0x%02X\n", mood);\r\nreturn 0;\r\n}\r\ni1++;\r\n}\r\nSAM("WARNING: failed to adjust volume: control not found\n");\r\nreturn -ENOENT;\r\n}\r\nstatic int adjust_mute(struct easycap *peasycap, int value)\r\n{\r\nint i1;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\ni1 = 0;\r\nwhile (0xFFFFFFFF != easycap_control[i1].id) {\r\nif (V4L2_CID_AUDIO_MUTE == easycap_control[i1].id) {\r\npeasycap->mute = value;\r\nswitch (peasycap->mute) {\r\ncase 1: {\r\npeasycap->audio_idle = 1;\r\nSAM("adjusting mute: %i=peasycap->audio_idle\n",\r\npeasycap->audio_idle);\r\nreturn 0;\r\n}\r\ndefault: {\r\npeasycap->audio_idle = 0;\r\nSAM("adjusting mute: %i=peasycap->audio_idle\n",\r\npeasycap->audio_idle);\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\n}\r\ni1++;\r\n}\r\nSAM("WARNING: failed to adjust mute: control not found\n");\r\nreturn -ENOENT;\r\n}\r\nlong easycap_unlocked_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct easycap *peasycap;\r\nstruct usb_device *p;\r\nint kd;\r\nif (!file) {\r\nSAY("ERROR: file is NULL\n");\r\nreturn -ERESTARTSYS;\r\n}\r\npeasycap = file->private_data;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -1;\r\n}\r\np = peasycap->pusb_device;\r\nif (!p) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nkd = easycap_isdongle(peasycap);\r\nif (0 <= kd && DONGLE_MANY > kd) {\r\nif (mutex_lock_interruptible(&easycapdc60_dongle[kd].mutex_video)) {\r\nSAY("ERROR: cannot lock "\r\n"easycapdc60_dongle[%i].mutex_video\n", kd);\r\nreturn -ERESTARTSYS;\r\n}\r\nJOM(4, "locked easycapdc60_dongle[%i].mutex_video\n", kd);\r\nif (kd != easycap_isdongle(peasycap))\r\nreturn -ERESTARTSYS;\r\nif (!file) {\r\nSAY("ERROR: file is NULL\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ERESTARTSYS;\r\n}\r\npeasycap = file->private_data;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ERESTARTSYS;\r\n}\r\n} else {\r\nreturn -ERESTARTSYS;\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCAP: {\r\nstruct v4l2_capability v4l2_capability;\r\nchar version[16], *p1, *p2;\r\nint i, rc, k[3];\r\nlong lng;\r\nJOM(8, "VIDIOC_QUERYCAP\n");\r\nif (16 <= strlen(EASYCAP_DRIVER_VERSION)) {\r\nSAM("ERROR: bad driver version string\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nstrcpy(&version[0], EASYCAP_DRIVER_VERSION);\r\nfor (i = 0; i < 3; i++)\r\nk[i] = 0;\r\np2 = &version[0];\r\ni = 0;\r\nwhile (*p2) {\r\np1 = p2;\r\nwhile (*p2 && ('.' != *p2))\r\np2++;\r\nif (*p2)\r\n*p2++ = 0;\r\nif (3 > i) {\r\nrc = (int) strict_strtol(p1, 10, &lng);\r\nif (rc) {\r\nSAM("ERROR: %i=strict_strtol(%s,.,,)\n",\r\nrc, p1);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nk[i] = (int)lng;\r\n}\r\ni++;\r\n}\r\nmemset(&v4l2_capability, 0, sizeof(struct v4l2_capability));\r\nstrlcpy(&v4l2_capability.driver[0],\r\n"easycap", sizeof(v4l2_capability.driver));\r\nv4l2_capability.capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_AUDIO |\r\nV4L2_CAP_READWRITE;\r\nv4l2_capability.version = KERNEL_VERSION(k[0], k[1], k[2]);\r\nJOM(8, "v4l2_capability.version=(%i,%i,%i)\n", k[0], k[1], k[2]);\r\nstrlcpy(&v4l2_capability.card[0],\r\n"EasyCAP DC60", sizeof(v4l2_capability.card));\r\nif (usb_make_path(peasycap->pusb_device,\r\n&v4l2_capability.bus_info[0],\r\nsizeof(v4l2_capability.bus_info)) < 0) {\r\nstrlcpy(&v4l2_capability.bus_info[0], "EasyCAP bus_info",\r\nsizeof(v4l2_capability.bus_info));\r\nJOM(8, "%s=v4l2_capability.bus_info\n",\r\n&v4l2_capability.bus_info[0]);\r\n}\r\nif (copy_to_user((void __user *)arg, &v4l2_capability,\r\nsizeof(struct v4l2_capability))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMINPUT: {\r\nstruct v4l2_input v4l2_input;\r\nu32 index;\r\nJOM(8, "VIDIOC_ENUMINPUT\n");\r\nif (copy_from_user(&v4l2_input, (void __user *)arg,\r\nsizeof(struct v4l2_input))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nindex = v4l2_input.index;\r\nmemset(&v4l2_input, 0, sizeof(struct v4l2_input));\r\nswitch (index) {\r\ncase 0: {\r\nv4l2_input.index = index;\r\nstrcpy(&v4l2_input.name[0], "CVBS0");\r\nv4l2_input.type = V4L2_INPUT_TYPE_CAMERA;\r\nv4l2_input.audioset = 0x01;\r\nv4l2_input.tuner = 0;\r\nv4l2_input.std = V4L2_STD_PAL |\r\nV4L2_STD_SECAM |\r\nV4L2_STD_NTSC ;\r\nv4l2_input.status = 0;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_input.name[0]);\r\nbreak;\r\n}\r\ncase 1: {\r\nv4l2_input.index = index;\r\nstrcpy(&v4l2_input.name[0], "CVBS1");\r\nv4l2_input.type = V4L2_INPUT_TYPE_CAMERA;\r\nv4l2_input.audioset = 0x01;\r\nv4l2_input.tuner = 0;\r\nv4l2_input.std = V4L2_STD_PAL | V4L2_STD_SECAM |\r\nV4L2_STD_NTSC;\r\nv4l2_input.status = 0;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_input.name[0]);\r\nbreak;\r\n}\r\ncase 2: {\r\nv4l2_input.index = index;\r\nstrcpy(&v4l2_input.name[0], "CVBS2");\r\nv4l2_input.type = V4L2_INPUT_TYPE_CAMERA;\r\nv4l2_input.audioset = 0x01;\r\nv4l2_input.tuner = 0;\r\nv4l2_input.std = V4L2_STD_PAL | V4L2_STD_SECAM |\r\nV4L2_STD_NTSC ;\r\nv4l2_input.status = 0;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_input.name[0]);\r\nbreak;\r\n}\r\ncase 3: {\r\nv4l2_input.index = index;\r\nstrcpy(&v4l2_input.name[0], "CVBS3");\r\nv4l2_input.type = V4L2_INPUT_TYPE_CAMERA;\r\nv4l2_input.audioset = 0x01;\r\nv4l2_input.tuner = 0;\r\nv4l2_input.std = V4L2_STD_PAL | V4L2_STD_SECAM |\r\nV4L2_STD_NTSC ;\r\nv4l2_input.status = 0;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_input.name[0]);\r\nbreak;\r\n}\r\ncase 4: {\r\nv4l2_input.index = index;\r\nstrcpy(&v4l2_input.name[0], "CVBS4");\r\nv4l2_input.type = V4L2_INPUT_TYPE_CAMERA;\r\nv4l2_input.audioset = 0x01;\r\nv4l2_input.tuner = 0;\r\nv4l2_input.std = V4L2_STD_PAL | V4L2_STD_SECAM |\r\nV4L2_STD_NTSC ;\r\nv4l2_input.status = 0;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_input.name[0]);\r\nbreak;\r\n}\r\ncase 5: {\r\nv4l2_input.index = index;\r\nstrcpy(&v4l2_input.name[0], "S-VIDEO");\r\nv4l2_input.type = V4L2_INPUT_TYPE_CAMERA;\r\nv4l2_input.audioset = 0x01;\r\nv4l2_input.tuner = 0;\r\nv4l2_input.std = V4L2_STD_PAL | V4L2_STD_SECAM |\r\nV4L2_STD_NTSC ;\r\nv4l2_input.status = 0;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_input.name[0]);\r\nbreak;\r\n}\r\ndefault: {\r\nJOM(8, "%i=index: exhausts inputs\n", index);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (copy_to_user((void __user *)arg, &v4l2_input,\r\nsizeof(struct v4l2_input))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_INPUT: {\r\nu32 index;\r\nJOM(8, "VIDIOC_G_INPUT\n");\r\nindex = (u32)peasycap->input;\r\nJOM(8, "user is told: %i\n", index);\r\nif (copy_to_user((void __user *)arg, &index, sizeof(u32))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_INPUT:\r\n{\r\nu32 index;\r\nint rc;\r\nJOM(8, "VIDIOC_S_INPUT\n");\r\nif (0 != copy_from_user(&index, (void __user *)arg, sizeof(u32))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nJOM(8, "user requests input %i\n", index);\r\nif ((int)index == peasycap->input) {\r\nSAM("requested input already in effect\n");\r\nbreak;\r\n}\r\nif ((0 > index) || (INPUT_MANY <= index)) {\r\nJOM(8, "ERROR: bad requested input: %i\n", index);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nrc = easycap_newinput(peasycap, (int)index);\r\nif (0 == rc) {\r\nJOM(8, "newinput(.,%i) OK\n", (int)index);\r\n} else {\r\nSAM("ERROR: newinput(.,%i) returned %i\n", (int)index, rc);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMAUDIO: {\r\nJOM(8, "VIDIOC_ENUMAUDIO\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_ENUMAUDOUT: {\r\nstruct v4l2_audioout v4l2_audioout;\r\nJOM(8, "VIDIOC_ENUMAUDOUT\n");\r\nif (copy_from_user(&v4l2_audioout, (void __user *)arg,\r\nsizeof(struct v4l2_audioout))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nif (0 != v4l2_audioout.index) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nmemset(&v4l2_audioout, 0, sizeof(struct v4l2_audioout));\r\nv4l2_audioout.index = 0;\r\nstrcpy(&v4l2_audioout.name[0], "Soundtrack");\r\nif (copy_to_user((void __user *)arg, &v4l2_audioout,\r\nsizeof(struct v4l2_audioout))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYCTRL: {\r\nint i1;\r\nstruct v4l2_queryctrl v4l2_queryctrl;\r\nJOM(8, "VIDIOC_QUERYCTRL\n");\r\nif (0 != copy_from_user(&v4l2_queryctrl, (void __user *)arg,\r\nsizeof(struct v4l2_queryctrl))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\ni1 = 0;\r\nwhile (0xFFFFFFFF != easycap_control[i1].id) {\r\nif (easycap_control[i1].id == v4l2_queryctrl.id) {\r\nJOM(8, "VIDIOC_QUERYCTRL %s=easycap_control[%i]"\r\n".name\n", &easycap_control[i1].name[0], i1);\r\nmemcpy(&v4l2_queryctrl, &easycap_control[i1],\r\nsizeof(struct v4l2_queryctrl));\r\nbreak;\r\n}\r\ni1++;\r\n}\r\nif (0xFFFFFFFF == easycap_control[i1].id) {\r\nJOM(8, "%i=index: exhausts controls\n", i1);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user((void __user *)arg, &v4l2_queryctrl,\r\nsizeof(struct v4l2_queryctrl))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYMENU: {\r\nJOM(8, "VIDIOC_QUERYMENU unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_G_CTRL: {\r\nstruct v4l2_control *pv4l2_control;\r\nJOM(8, "VIDIOC_G_CTRL\n");\r\npv4l2_control = memdup_user((void __user *)arg,\r\nsizeof(struct v4l2_control));\r\nif (IS_ERR(pv4l2_control)) {\r\nSAM("ERROR: copy from user failed\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn PTR_ERR(pv4l2_control);\r\n}\r\nswitch (pv4l2_control->id) {\r\ncase V4L2_CID_BRIGHTNESS: {\r\npv4l2_control->value = peasycap->brightness;\r\nJOM(8, "user enquires brightness: %i\n", pv4l2_control->value);\r\nbreak;\r\n}\r\ncase V4L2_CID_CONTRAST: {\r\npv4l2_control->value = peasycap->contrast;\r\nJOM(8, "user enquires contrast: %i\n", pv4l2_control->value);\r\nbreak;\r\n}\r\ncase V4L2_CID_SATURATION: {\r\npv4l2_control->value = peasycap->saturation;\r\nJOM(8, "user enquires saturation: %i\n", pv4l2_control->value);\r\nbreak;\r\n}\r\ncase V4L2_CID_HUE: {\r\npv4l2_control->value = peasycap->hue;\r\nJOM(8, "user enquires hue: %i\n", pv4l2_control->value);\r\nbreak;\r\n}\r\ncase V4L2_CID_AUDIO_VOLUME: {\r\npv4l2_control->value = peasycap->volume;\r\nJOM(8, "user enquires volume: %i\n", pv4l2_control->value);\r\nbreak;\r\n}\r\ncase V4L2_CID_AUDIO_MUTE: {\r\nif (1 == peasycap->mute)\r\npv4l2_control->value = true;\r\nelse\r\npv4l2_control->value = false;\r\nJOM(8, "user enquires mute: %i\n", pv4l2_control->value);\r\nbreak;\r\n}\r\ndefault: {\r\nSAM("ERROR: unknown V4L2 control: 0x%08X=id\n",\r\npv4l2_control->id);\r\nkfree(pv4l2_control);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (copy_to_user((void __user *)arg, pv4l2_control,\r\nsizeof(struct v4l2_control))) {\r\nkfree(pv4l2_control);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nkfree(pv4l2_control);\r\nbreak;\r\n}\r\ncase VIDIOC_S_CTRL: {\r\nstruct v4l2_control v4l2_control;\r\nJOM(8, "VIDIOC_S_CTRL\n");\r\nif (0 != copy_from_user(&v4l2_control, (void __user *)arg,\r\nsizeof(struct v4l2_control))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nswitch (v4l2_control.id) {\r\ncase V4L2_CID_BRIGHTNESS: {\r\nJOM(8, "user requests brightness %i\n", v4l2_control.value);\r\nif (0 != adjust_brightness(peasycap, v4l2_control.value))\r\n;\r\nbreak;\r\n}\r\ncase V4L2_CID_CONTRAST: {\r\nJOM(8, "user requests contrast %i\n", v4l2_control.value);\r\nif (0 != adjust_contrast(peasycap, v4l2_control.value))\r\n;\r\nbreak;\r\n}\r\ncase V4L2_CID_SATURATION: {\r\nJOM(8, "user requests saturation %i\n", v4l2_control.value);\r\nif (0 != adjust_saturation(peasycap, v4l2_control.value))\r\n;\r\nbreak;\r\n}\r\ncase V4L2_CID_HUE: {\r\nJOM(8, "user requests hue %i\n", v4l2_control.value);\r\nif (0 != adjust_hue(peasycap, v4l2_control.value))\r\n;\r\nbreak;\r\n}\r\ncase V4L2_CID_AUDIO_VOLUME: {\r\nJOM(8, "user requests volume %i\n", v4l2_control.value);\r\nif (0 != adjust_volume(peasycap, v4l2_control.value))\r\n;\r\nbreak;\r\n}\r\ncase V4L2_CID_AUDIO_MUTE: {\r\nint mute;\r\nJOM(8, "user requests mute %i\n", v4l2_control.value);\r\nif (v4l2_control.value)\r\nmute = 1;\r\nelse\r\nmute = 0;\r\nif (0 != adjust_mute(peasycap, mute))\r\nSAM("WARNING: failed to adjust mute to %i\n", mute);\r\nbreak;\r\n}\r\ndefault: {\r\nSAM("ERROR: unknown V4L2 control: 0x%08X=id\n",\r\nv4l2_control.id);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_EXT_CTRLS: {\r\nJOM(8, "VIDIOC_S_EXT_CTRLS unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_ENUM_FMT: {\r\nu32 index;\r\nstruct v4l2_fmtdesc v4l2_fmtdesc;\r\nJOM(8, "VIDIOC_ENUM_FMT\n");\r\nif (0 != copy_from_user(&v4l2_fmtdesc, (void __user *)arg,\r\nsizeof(struct v4l2_fmtdesc))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nindex = v4l2_fmtdesc.index;\r\nmemset(&v4l2_fmtdesc, 0, sizeof(struct v4l2_fmtdesc));\r\nv4l2_fmtdesc.index = index;\r\nv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nswitch (index) {\r\ncase 0: {\r\nv4l2_fmtdesc.flags = 0;\r\nstrcpy(&v4l2_fmtdesc.description[0], "uyvy");\r\nv4l2_fmtdesc.pixelformat = V4L2_PIX_FMT_UYVY;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_fmtdesc.description[0]);\r\nbreak;\r\n}\r\ncase 1: {\r\nv4l2_fmtdesc.flags = 0;\r\nstrcpy(&v4l2_fmtdesc.description[0], "yuy2");\r\nv4l2_fmtdesc.pixelformat = V4L2_PIX_FMT_YUYV;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_fmtdesc.description[0]);\r\nbreak;\r\n}\r\ncase 2: {\r\nv4l2_fmtdesc.flags = 0;\r\nstrcpy(&v4l2_fmtdesc.description[0], "rgb24");\r\nv4l2_fmtdesc.pixelformat = V4L2_PIX_FMT_RGB24;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_fmtdesc.description[0]);\r\nbreak;\r\n}\r\ncase 3: {\r\nv4l2_fmtdesc.flags = 0;\r\nstrcpy(&v4l2_fmtdesc.description[0], "rgb32");\r\nv4l2_fmtdesc.pixelformat = V4L2_PIX_FMT_RGB32;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_fmtdesc.description[0]);\r\nbreak;\r\n}\r\ncase 4: {\r\nv4l2_fmtdesc.flags = 0;\r\nstrcpy(&v4l2_fmtdesc.description[0], "bgr24");\r\nv4l2_fmtdesc.pixelformat = V4L2_PIX_FMT_BGR24;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_fmtdesc.description[0]);\r\nbreak;\r\n}\r\ncase 5: {\r\nv4l2_fmtdesc.flags = 0;\r\nstrcpy(&v4l2_fmtdesc.description[0], "bgr32");\r\nv4l2_fmtdesc.pixelformat = V4L2_PIX_FMT_BGR32;\r\nJOM(8, "%i=index: %s\n", index, &v4l2_fmtdesc.description[0]);\r\nbreak;\r\n}\r\ndefault: {\r\nJOM(8, "%i=index: exhausts formats\n", index);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (copy_to_user((void __user *)arg, &v4l2_fmtdesc,\r\nsizeof(struct v4l2_fmtdesc))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_ENUM_FRAMESIZES: {\r\nu32 index;\r\nstruct v4l2_frmsizeenum v4l2_frmsizeenum;\r\nJOM(8, "VIDIOC_ENUM_FRAMESIZES\n");\r\nif (0 != copy_from_user(&v4l2_frmsizeenum, (void __user *)arg,\r\nsizeof(struct v4l2_frmsizeenum))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nindex = v4l2_frmsizeenum.index;\r\nv4l2_frmsizeenum.type = (u32) V4L2_FRMSIZE_TYPE_DISCRETE;\r\nif (peasycap->ntsc) {\r\nswitch (index) {\r\ncase 0: {\r\nv4l2_frmsizeenum.discrete.width = 640;\r\nv4l2_frmsizeenum.discrete.height = 480;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ncase 1: {\r\nv4l2_frmsizeenum.discrete.width = 320;\r\nv4l2_frmsizeenum.discrete.height = 240;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ncase 2: {\r\nv4l2_frmsizeenum.discrete.width = 720;\r\nv4l2_frmsizeenum.discrete.height = 480;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ncase 3: {\r\nv4l2_frmsizeenum.discrete.width = 360;\r\nv4l2_frmsizeenum.discrete.height = 240;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ndefault: {\r\nJOM(8, "%i=index: exhausts framesizes\n", index);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\n}\r\n} else {\r\nswitch (index) {\r\ncase 0: {\r\nv4l2_frmsizeenum.discrete.width = 640;\r\nv4l2_frmsizeenum.discrete.height = 480;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ncase 1: {\r\nv4l2_frmsizeenum.discrete.width = 320;\r\nv4l2_frmsizeenum.discrete.height = 240;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ncase 2: {\r\nv4l2_frmsizeenum.discrete.width = 704;\r\nv4l2_frmsizeenum.discrete.height = 576;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ncase 3: {\r\nv4l2_frmsizeenum.discrete.width = 720;\r\nv4l2_frmsizeenum.discrete.height = 576;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ncase 4: {\r\nv4l2_frmsizeenum.discrete.width = 360;\r\nv4l2_frmsizeenum.discrete.height = 288;\r\nJOM(8, "%i=index: %ix%i\n", index,\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.width),\r\n(int)(v4l2_frmsizeenum.\r\ndiscrete.height));\r\nbreak;\r\n}\r\ndefault: {\r\nJOM(8, "%i=index: exhausts framesizes\n", index);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (copy_to_user((void __user *)arg, &v4l2_frmsizeenum,\r\nsizeof(struct v4l2_frmsizeenum))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_ENUM_FRAMEINTERVALS: {\r\nu32 index;\r\nint denominator;\r\nstruct v4l2_frmivalenum v4l2_frmivalenum;\r\nJOM(8, "VIDIOC_ENUM_FRAMEINTERVALS\n");\r\nif (peasycap->fps)\r\ndenominator = peasycap->fps;\r\nelse {\r\nif (peasycap->ntsc)\r\ndenominator = 30;\r\nelse\r\ndenominator = 25;\r\n}\r\nif (0 != copy_from_user(&v4l2_frmivalenum, (void __user *)arg,\r\nsizeof(struct v4l2_frmivalenum))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nindex = v4l2_frmivalenum.index;\r\nv4l2_frmivalenum.type = (u32) V4L2_FRMIVAL_TYPE_DISCRETE;\r\nswitch (index) {\r\ncase 0: {\r\nv4l2_frmivalenum.discrete.numerator = 1;\r\nv4l2_frmivalenum.discrete.denominator = denominator;\r\nJOM(8, "%i=index: %i/%i\n", index,\r\n(int)(v4l2_frmivalenum.discrete.numerator),\r\n(int)(v4l2_frmivalenum.discrete.denominator));\r\nbreak;\r\n}\r\ncase 1: {\r\nv4l2_frmivalenum.discrete.numerator = 1;\r\nv4l2_frmivalenum.discrete.denominator = denominator/5;\r\nJOM(8, "%i=index: %i/%i\n", index,\r\n(int)(v4l2_frmivalenum.discrete.numerator),\r\n(int)(v4l2_frmivalenum.discrete.denominator));\r\nbreak;\r\n}\r\ndefault: {\r\nJOM(8, "%i=index: exhausts frameintervals\n", index);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (copy_to_user((void __user *)arg, &v4l2_frmivalenum,\r\nsizeof(struct v4l2_frmivalenum))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_FMT: {\r\nstruct v4l2_format *pv4l2_format;\r\nstruct v4l2_pix_format *pv4l2_pix_format;\r\nJOM(8, "VIDIOC_G_FMT\n");\r\npv4l2_format = kzalloc(sizeof(struct v4l2_format), GFP_KERNEL);\r\nif (!pv4l2_format) {\r\nSAM("ERROR: out of memory\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ENOMEM;\r\n}\r\npv4l2_pix_format = kzalloc(sizeof(struct v4l2_pix_format), GFP_KERNEL);\r\nif (!pv4l2_pix_format) {\r\nSAM("ERROR: out of memory\n");\r\nkfree(pv4l2_format);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ENOMEM;\r\n}\r\nif (0 != copy_from_user(pv4l2_format, (void __user *)arg,\r\nsizeof(struct v4l2_format))) {\r\nkfree(pv4l2_format);\r\nkfree(pv4l2_pix_format);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nif (pv4l2_format->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nkfree(pv4l2_format);\r\nkfree(pv4l2_pix_format);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nmemset(pv4l2_pix_format, 0, sizeof(struct v4l2_pix_format));\r\npv4l2_format->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nmemcpy(&pv4l2_format->fmt.pix,\r\n&easycap_format[peasycap->format_offset]\r\n.v4l2_format.fmt.pix, sizeof(struct v4l2_pix_format));\r\nJOM(8, "user is told: %s\n",\r\n&easycap_format[peasycap->format_offset].name[0]);\r\nif (copy_to_user((void __user *)arg, pv4l2_format,\r\nsizeof(struct v4l2_format))) {\r\nkfree(pv4l2_format);\r\nkfree(pv4l2_pix_format);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nkfree(pv4l2_format);\r\nkfree(pv4l2_pix_format);\r\nbreak;\r\n}\r\ncase VIDIOC_TRY_FMT:\r\ncase VIDIOC_S_FMT: {\r\nstruct v4l2_format v4l2_format;\r\nstruct v4l2_pix_format v4l2_pix_format;\r\nbool try;\r\nint best_format;\r\nif (VIDIOC_TRY_FMT == cmd) {\r\nJOM(8, "VIDIOC_TRY_FMT\n");\r\ntry = true;\r\n} else {\r\nJOM(8, "VIDIOC_S_FMT\n");\r\ntry = false;\r\n}\r\nif (0 != copy_from_user(&v4l2_format, (void __user *)arg,\r\nsizeof(struct v4l2_format))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbest_format = adjust_format(peasycap,\r\nv4l2_format.fmt.pix.width,\r\nv4l2_format.fmt.pix.height,\r\nv4l2_format.fmt.pix.pixelformat,\r\nv4l2_format.fmt.pix.field,\r\ntry);\r\nif (0 > best_format) {\r\nif (-EBUSY == best_format) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EBUSY;\r\n}\r\nJOM(8, "WARNING: adjust_format() returned %i\n", best_format);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ENOENT;\r\n}\r\nmemset(&v4l2_pix_format, 0, sizeof(struct v4l2_pix_format));\r\nv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nmemcpy(&(v4l2_format.fmt.pix),\r\n&(easycap_format[best_format].v4l2_format.fmt.pix),\r\nsizeof(v4l2_pix_format));\r\nJOM(8, "user is told: %s\n", &easycap_format[best_format].name[0]);\r\nif (copy_to_user((void __user *)arg, &v4l2_format,\r\nsizeof(struct v4l2_format))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_CROPCAP: {\r\nstruct v4l2_cropcap v4l2_cropcap;\r\nJOM(8, "VIDIOC_CROPCAP\n");\r\nif (0 != copy_from_user(&v4l2_cropcap, (void __user *)arg,\r\nsizeof(struct v4l2_cropcap))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nif (v4l2_cropcap.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nJOM(8, "v4l2_cropcap.type != V4L2_BUF_TYPE_VIDEO_CAPTURE\n");\r\nmemset(&v4l2_cropcap, 0, sizeof(struct v4l2_cropcap));\r\nv4l2_cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nv4l2_cropcap.bounds.left = 0;\r\nv4l2_cropcap.bounds.top = 0;\r\nv4l2_cropcap.bounds.width = peasycap->width;\r\nv4l2_cropcap.bounds.height = peasycap->height;\r\nv4l2_cropcap.defrect.left = 0;\r\nv4l2_cropcap.defrect.top = 0;\r\nv4l2_cropcap.defrect.width = peasycap->width;\r\nv4l2_cropcap.defrect.height = peasycap->height;\r\nv4l2_cropcap.pixelaspect.numerator = 1;\r\nv4l2_cropcap.pixelaspect.denominator = 1;\r\nJOM(8, "user is told: %ix%i\n", peasycap->width, peasycap->height);\r\nif (copy_to_user((void __user *)arg, &v4l2_cropcap,\r\nsizeof(struct v4l2_cropcap))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_CROP:\r\ncase VIDIOC_S_CROP: {\r\nJOM(8, "VIDIOC_G_CROP|VIDIOC_S_CROP unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_QUERYSTD: {\r\nJOM(8, "VIDIOC_QUERYSTD: "\r\n"EasyCAP is incapable of detecting standard\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMSTD: {\r\nint last0 = -1, last1 = -1, last2 = -1, last3 = -1;\r\nstruct v4l2_standard v4l2_standard;\r\nu32 index;\r\nstruct easycap_standard const *peasycap_standard;\r\nJOM(8, "VIDIOC_ENUMSTD\n");\r\nif (0 != copy_from_user(&v4l2_standard, (void __user *)arg,\r\nsizeof(struct v4l2_standard))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nindex = v4l2_standard.index;\r\nlast3 = last2;\r\nlast2 = last1;\r\nlast1 = last0;\r\nlast0 = index;\r\nif ((index == last3) && (index == last2) &&\r\n(index == last1) && (index == last0)) {\r\nindex++;\r\nlast3 = last2;\r\nlast2 = last1;\r\nlast1 = last0;\r\nlast0 = index;\r\n}\r\nmemset(&v4l2_standard, 0, sizeof(struct v4l2_standard));\r\npeasycap_standard = &easycap_standard[0];\r\nwhile (0xFFFF != peasycap_standard->mask) {\r\nif ((int)(peasycap_standard - &easycap_standard[0]) == index)\r\nbreak;\r\npeasycap_standard++;\r\n}\r\nif (0xFFFF == peasycap_standard->mask) {\r\nJOM(8, "%i=index: exhausts standards\n", index);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nJOM(8, "%i=index: %s\n", index,\r\n&(peasycap_standard->v4l2_standard.name[0]));\r\nmemcpy(&v4l2_standard, &(peasycap_standard->v4l2_standard),\r\nsizeof(struct v4l2_standard));\r\nv4l2_standard.index = index;\r\nif (copy_to_user((void __user *)arg, &v4l2_standard,\r\nsizeof(struct v4l2_standard))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_STD: {\r\nv4l2_std_id std_id;\r\nstruct easycap_standard const *peasycap_standard;\r\nJOM(8, "VIDIOC_G_STD\n");\r\nif (0 > peasycap->standard_offset) {\r\nJOM(8, "%i=peasycap->standard_offset\n",\r\npeasycap->standard_offset);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EBUSY;\r\n}\r\nif (0 != copy_from_user(&std_id, (void __user *)arg,\r\nsizeof(v4l2_std_id))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\npeasycap_standard = &easycap_standard[peasycap->standard_offset];\r\nstd_id = peasycap_standard->v4l2_standard.id;\r\nJOM(8, "user is told: %s\n",\r\n&peasycap_standard->v4l2_standard.name[0]);\r\nif (copy_to_user((void __user *)arg, &std_id,\r\nsizeof(v4l2_std_id))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_STD: {\r\nv4l2_std_id std_id;\r\nint rc;\r\nJOM(8, "VIDIOC_S_STD\n");\r\nif (0 != copy_from_user(&std_id, (void __user *)arg,\r\nsizeof(v4l2_std_id))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nJOM(8, "User requests standard: 0x%08X%08X\n",\r\n(int)((std_id & (((v4l2_std_id)0xFFFFFFFF) << 32)) >> 32),\r\n(int)(std_id & ((v4l2_std_id)0xFFFFFFFF)));\r\nrc = adjust_standard(peasycap, std_id);\r\nif (0 > rc) {\r\nJOM(8, "WARNING: adjust_standard() returned %i\n", rc);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ENOENT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_REQBUFS: {\r\nint nbuffers;\r\nstruct v4l2_requestbuffers v4l2_requestbuffers;\r\nJOM(8, "VIDIOC_REQBUFS\n");\r\nif (0 != copy_from_user(&v4l2_requestbuffers,\r\n(void __user *)arg,\r\nsizeof(struct v4l2_requestbuffers))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nif (v4l2_requestbuffers.type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nif (v4l2_requestbuffers.memory != V4L2_MEMORY_MMAP) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nnbuffers = v4l2_requestbuffers.count;\r\nJOM(8, " User requests %i buffers ...\n", nbuffers);\r\nif (nbuffers < 2)\r\nnbuffers = 2;\r\nif (nbuffers > FRAME_BUFFER_MANY)\r\nnbuffers = FRAME_BUFFER_MANY;\r\nif (v4l2_requestbuffers.count == nbuffers) {\r\nJOM(8, " ... agree to %i buffers\n",\r\nnbuffers);\r\n} else {\r\nJOM(8, " ... insist on %i buffers\n",\r\nnbuffers);\r\nv4l2_requestbuffers.count = nbuffers;\r\n}\r\npeasycap->frame_buffer_many = nbuffers;\r\nif (copy_to_user((void __user *)arg, &v4l2_requestbuffers,\r\nsizeof(struct v4l2_requestbuffers))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYBUF: {\r\nu32 index;\r\nstruct v4l2_buffer v4l2_buffer;\r\nJOM(8, "VIDIOC_QUERYBUF\n");\r\nif (peasycap->video_eof) {\r\nJOM(8, "returning -EIO because %i=video_eof\n",\r\npeasycap->video_eof);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EIO;\r\n}\r\nif (0 != copy_from_user(&v4l2_buffer, (void __user *)arg,\r\nsizeof(struct v4l2_buffer))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nif (v4l2_buffer.type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nindex = v4l2_buffer.index;\r\nif (index < 0 || index >= peasycap->frame_buffer_many)\r\nreturn -EINVAL;\r\nmemset(&v4l2_buffer, 0, sizeof(struct v4l2_buffer));\r\nv4l2_buffer.index = index;\r\nv4l2_buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nv4l2_buffer.bytesused = peasycap->frame_buffer_used;\r\nv4l2_buffer.flags = V4L2_BUF_FLAG_MAPPED |\r\npeasycap->done[index] |\r\npeasycap->queued[index];\r\nv4l2_buffer.field = V4L2_FIELD_NONE;\r\nv4l2_buffer.memory = V4L2_MEMORY_MMAP;\r\nv4l2_buffer.m.offset = index * FRAME_BUFFER_SIZE;\r\nv4l2_buffer.length = FRAME_BUFFER_SIZE;\r\nJOM(16, " %10i=index\n", v4l2_buffer.index);\r\nJOM(16, " 0x%08X=type\n", v4l2_buffer.type);\r\nJOM(16, " %10i=bytesused\n", v4l2_buffer.bytesused);\r\nJOM(16, " 0x%08X=flags\n", v4l2_buffer.flags);\r\nJOM(16, " %10i=field\n", v4l2_buffer.field);\r\nJOM(16, " %10li=timestamp.tv_usec\n",\r\n(long)v4l2_buffer.timestamp.tv_usec);\r\nJOM(16, " %10i=sequence\n", v4l2_buffer.sequence);\r\nJOM(16, " 0x%08X=memory\n", v4l2_buffer.memory);\r\nJOM(16, " %10i=m.offset\n", v4l2_buffer.m.offset);\r\nJOM(16, " %10i=length\n", v4l2_buffer.length);\r\nif (copy_to_user((void __user *)arg, &v4l2_buffer,\r\nsizeof(struct v4l2_buffer))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_QBUF: {\r\nstruct v4l2_buffer v4l2_buffer;\r\nJOM(8, "VIDIOC_QBUF\n");\r\nif (0 != copy_from_user(&v4l2_buffer, (void __user *)arg,\r\nsizeof(struct v4l2_buffer))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nif (v4l2_buffer.type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nif (v4l2_buffer.memory != V4L2_MEMORY_MMAP) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nif (v4l2_buffer.index < 0 ||\r\nv4l2_buffer.index >= peasycap->frame_buffer_many) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nv4l2_buffer.flags = V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED;\r\npeasycap->done[v4l2_buffer.index] = 0;\r\npeasycap->queued[v4l2_buffer.index] = V4L2_BUF_FLAG_QUEUED;\r\nif (copy_to_user((void __user *)arg, &v4l2_buffer,\r\nsizeof(struct v4l2_buffer))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nJOM(8, "..... user queueing frame buffer %i\n",\r\n(int)v4l2_buffer.index);\r\npeasycap->frame_lock = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_DQBUF:\r\n{\r\nstruct timeval timeval, timeval2;\r\nint i, j;\r\nstruct v4l2_buffer v4l2_buffer;\r\nint rcdq;\r\nu16 input;\r\nJOM(8, "VIDIOC_DQBUF\n");\r\nif ((peasycap->video_idle) || (peasycap->video_eof)) {\r\nJOM(8, "returning -EIO because "\r\n"%i=video_idle %i=video_eof\n",\r\npeasycap->video_idle, peasycap->video_eof);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EIO;\r\n}\r\nif (copy_from_user(&v4l2_buffer, (void __user *)arg,\r\nsizeof(struct v4l2_buffer))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nif (v4l2_buffer.type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\nif (peasycap->offerfields) {\r\nif (V4L2_FIELD_TOP == v4l2_buffer.field)\r\nJOM(8, "user wants V4L2_FIELD_TOP\n");\r\nelse if (V4L2_FIELD_BOTTOM == v4l2_buffer.field)\r\nJOM(8, "user wants V4L2_FIELD_BOTTOM\n");\r\nelse if (V4L2_FIELD_ANY == v4l2_buffer.field)\r\nJOM(8, "user wants V4L2_FIELD_ANY\n");\r\nelse\r\nJOM(8, "user wants V4L2_FIELD_...UNKNOWN: %i\n",\r\nv4l2_buffer.field);\r\n}\r\nif (!peasycap->video_isoc_streaming) {\r\nJOM(16, "returning -EIO because video urbs not streaming\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EIO;\r\n}\r\nif (!peasycap->polled) {\r\ndo {\r\nrcdq = easycap_video_dqbuf(peasycap, 0);\r\nif (-EIO == rcdq) {\r\nJOM(8, "returning -EIO because "\r\n"dqbuf() returned -EIO\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EIO;\r\n}\r\n} while (0 != rcdq);\r\n} else {\r\nif (peasycap->video_eof) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EIO;\r\n}\r\n}\r\nif (V4L2_BUF_FLAG_DONE != peasycap->done[peasycap->frame_read]) {\r\nJOM(8, "V4L2_BUF_FLAG_DONE != 0x%08X\n",\r\npeasycap->done[peasycap->frame_read]);\r\n}\r\npeasycap->polled = 0;\r\nif (!(peasycap->isequence % 10)) {\r\nfor (i = 0; i < 179; i++)\r\npeasycap->merit[i] = peasycap->merit[i+1];\r\npeasycap->merit[179] = merit_saa(peasycap->pusb_device);\r\nj = 0;\r\nfor (i = 0; i < 180; i++)\r\nj += peasycap->merit[i];\r\nif (90 < j) {\r\nSAM("easycap driver shutting down "\r\n"on condition blue\n");\r\npeasycap->video_eof = 1;\r\npeasycap->audio_eof = 1;\r\n}\r\n}\r\nv4l2_buffer.index = peasycap->frame_read;\r\nv4l2_buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nv4l2_buffer.bytesused = peasycap->frame_buffer_used;\r\nv4l2_buffer.flags = V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_DONE;\r\nif (peasycap->offerfields)\r\nv4l2_buffer.field = V4L2_FIELD_BOTTOM;\r\nelse\r\nv4l2_buffer.field = V4L2_FIELD_NONE;\r\ndo_gettimeofday(&timeval);\r\ntimeval2 = timeval;\r\nv4l2_buffer.timestamp = timeval2;\r\nv4l2_buffer.sequence = peasycap->isequence++;\r\nv4l2_buffer.memory = V4L2_MEMORY_MMAP;\r\nv4l2_buffer.m.offset = v4l2_buffer.index * FRAME_BUFFER_SIZE;\r\nv4l2_buffer.length = FRAME_BUFFER_SIZE;\r\nJOM(16, " %10i=index\n", v4l2_buffer.index);\r\nJOM(16, " 0x%08X=type\n", v4l2_buffer.type);\r\nJOM(16, " %10i=bytesused\n", v4l2_buffer.bytesused);\r\nJOM(16, " 0x%08X=flags\n", v4l2_buffer.flags);\r\nJOM(16, " %10i=field\n", v4l2_buffer.field);\r\nJOM(16, " %10li=timestamp.tv_sec\n",\r\n(long)v4l2_buffer.timestamp.tv_sec);\r\nJOM(16, " %10li=timestamp.tv_usec\n",\r\n(long)v4l2_buffer.timestamp.tv_usec);\r\nJOM(16, " %10i=sequence\n", v4l2_buffer.sequence);\r\nJOM(16, " 0x%08X=memory\n", v4l2_buffer.memory);\r\nJOM(16, " %10i=m.offset\n", v4l2_buffer.m.offset);\r\nJOM(16, " %10i=length\n", v4l2_buffer.length);\r\nif (copy_to_user((void __user *)arg, &v4l2_buffer,\r\nsizeof(struct v4l2_buffer))) {\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\ninput = peasycap->frame_buffer[peasycap->frame_read][0].input;\r\nif (0x08 & input) {\r\nJOM(8, "user is offered frame buffer %i, input %i\n",\r\npeasycap->frame_read, (0x07 & input));\r\n} else {\r\nJOM(8, "user is offered frame buffer %i\n",\r\npeasycap->frame_read);\r\n}\r\npeasycap->frame_lock = 1;\r\nJOM(8, "%i=peasycap->frame_fill\n", peasycap->frame_fill);\r\nif (peasycap->frame_read == peasycap->frame_fill) {\r\nif (peasycap->frame_lock) {\r\nJOM(8, "WORRY: filling frame buffer "\r\n"while offered to user\n");\r\n}\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_STREAMON: {\r\nint i;\r\nJOM(8, "VIDIOC_STREAMON\n");\r\npeasycap->isequence = 0;\r\nfor (i = 0; i < 180; i++)\r\npeasycap->merit[i] = 0;\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\neasycap_video_submit_urbs(peasycap);\r\npeasycap->video_idle = 0;\r\npeasycap->audio_idle = 0;\r\npeasycap->video_eof = 0;\r\npeasycap->audio_eof = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_STREAMOFF: {\r\nJOM(8, "VIDIOC_STREAMOFF\n");\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\npeasycap->video_idle = 1;\r\npeasycap->audio_idle = 1;\r\nJOM(8, "calling wake_up on wq_video and wq_audio\n");\r\nwake_up_interruptible(&(peasycap->wq_video));\r\nif (peasycap->psubstream)\r\nsnd_pcm_period_elapsed(peasycap->psubstream);\r\nbreak;\r\n}\r\ncase VIDIOC_G_PARM: {\r\nstruct v4l2_streamparm *pv4l2_streamparm;\r\nJOM(8, "VIDIOC_G_PARM\n");\r\npv4l2_streamparm = memdup_user((void __user *)arg,\r\nsizeof(struct v4l2_streamparm));\r\nif (IS_ERR(pv4l2_streamparm)) {\r\nSAM("ERROR: copy from user failed\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn PTR_ERR(pv4l2_streamparm);\r\n}\r\nif (pv4l2_streamparm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nkfree(pv4l2_streamparm);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\npv4l2_streamparm->parm.capture.capability = 0;\r\npv4l2_streamparm->parm.capture.capturemode = 0;\r\npv4l2_streamparm->parm.capture.timeperframe.numerator = 1;\r\nif (peasycap->fps) {\r\npv4l2_streamparm->parm.capture.timeperframe.\r\ndenominator = peasycap->fps;\r\n} else {\r\nif (peasycap->ntsc) {\r\npv4l2_streamparm->parm.capture.timeperframe.\r\ndenominator = 30;\r\n} else {\r\npv4l2_streamparm->parm.capture.timeperframe.\r\ndenominator = 25;\r\n}\r\n}\r\npv4l2_streamparm->parm.capture.readbuffers =\r\npeasycap->frame_buffer_many;\r\npv4l2_streamparm->parm.capture.extendedmode = 0;\r\nif (copy_to_user((void __user *)arg,\r\npv4l2_streamparm,\r\nsizeof(struct v4l2_streamparm))) {\r\nkfree(pv4l2_streamparm);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EFAULT;\r\n}\r\nkfree(pv4l2_streamparm);\r\nbreak;\r\n}\r\ncase VIDIOC_S_PARM: {\r\nJOM(8, "VIDIOC_S_PARM unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_G_AUDIO: {\r\nJOM(8, "VIDIOC_G_AUDIO unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_S_AUDIO: {\r\nJOM(8, "VIDIOC_S_AUDIO unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_S_TUNER: {\r\nJOM(8, "VIDIOC_S_TUNER unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_G_FBUF:\r\ncase VIDIOC_S_FBUF:\r\ncase VIDIOC_OVERLAY: {\r\nJOM(8, "VIDIOC_G_FBUF|VIDIOC_S_FBUF|VIDIOC_OVERLAY unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_G_TUNER: {\r\nJOM(8, "VIDIOC_G_TUNER unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ncase VIDIOC_G_FREQUENCY:\r\ncase VIDIOC_S_FREQUENCY: {\r\nJOM(8, "VIDIOC_G_FREQUENCY|VIDIOC_S_FREQUENCY unsupported\n");\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -EINVAL;\r\n}\r\ndefault: {\r\nJOM(8, "ERROR: unrecognized V4L2 IOCTL command: 0x%08X\n", cmd);\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nmutex_unlock(&easycapdc60_dongle[kd].mutex_video);\r\nJOM(4, "unlocked easycapdc60_dongle[%i].mutex_video\n", kd);\r\nreturn 0;\r\n}
