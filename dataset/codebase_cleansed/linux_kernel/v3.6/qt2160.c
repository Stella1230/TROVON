static int qt2160_read_block(struct i2c_client *client,\r\nu8 inireg, u8 *buffer, unsigned int count)\r\n{\r\nint error, idx = 0;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nerror = i2c_smbus_write_byte(client, inireg + idx);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"couldn't send request. Returned %d\n", error);\r\nreturn error;\r\n}\r\nerror = i2c_master_recv(client, buffer, count);\r\nif (error != count) {\r\ndev_err(&client->dev,\r\n"couldn't read registers. Returned %d bytes\n", error);\r\nreturn error;\r\n}\r\n} else {\r\nwhile (count--) {\r\nint data;\r\nerror = i2c_smbus_write_byte(client, inireg + idx);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"couldn't send request. Returned %d\n", error);\r\nreturn error;\r\n}\r\ndata = i2c_smbus_read_byte(client);\r\nif (data < 0) {\r\ndev_err(&client->dev,\r\n"couldn't read register. Returned %d\n", data);\r\nreturn data;\r\n}\r\nbuffer[idx++] = data;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt2160_get_key_matrix(struct qt2160_data *qt2160)\r\n{\r\nstruct i2c_client *client = qt2160->client;\r\nstruct input_dev *input = qt2160->input;\r\nu8 regs[6];\r\nu16 old_matrix, new_matrix;\r\nint ret, i, mask;\r\ndev_dbg(&client->dev, "requesting keys...\n");\r\nret = qt2160_read_block(client, QT2160_CMD_GSTAT, regs, 6);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"could not perform chip read.\n");\r\nreturn ret;\r\n}\r\nold_matrix = qt2160->key_matrix;\r\nqt2160->key_matrix = new_matrix = (regs[2] << 8) | regs[1];\r\nmask = 0x01;\r\nfor (i = 0; i < 16; ++i, mask <<= 1) {\r\nint keyval = new_matrix & mask;\r\nif ((old_matrix & mask) != keyval) {\r\ninput_report_key(input, qt2160->keycodes[i], keyval);\r\ndev_dbg(&client->dev, "key %d %s\n",\r\ni, keyval ? "pressed" : "released");\r\n}\r\n}\r\ninput_sync(input);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t qt2160_irq(int irq, void *_qt2160)\r\n{\r\nstruct qt2160_data *qt2160 = _qt2160;\r\nunsigned long flags;\r\nspin_lock_irqsave(&qt2160->lock, flags);\r\n__cancel_delayed_work(&qt2160->dwork);\r\nschedule_delayed_work(&qt2160->dwork, 0);\r\nspin_unlock_irqrestore(&qt2160->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void qt2160_schedule_read(struct qt2160_data *qt2160)\r\n{\r\nspin_lock_irq(&qt2160->lock);\r\nschedule_delayed_work(&qt2160->dwork, QT2160_CYCLE_INTERVAL);\r\nspin_unlock_irq(&qt2160->lock);\r\n}\r\nstatic void qt2160_worker(struct work_struct *work)\r\n{\r\nstruct qt2160_data *qt2160 =\r\ncontainer_of(work, struct qt2160_data, dwork.work);\r\ndev_dbg(&qt2160->client->dev, "worker\n");\r\nqt2160_get_key_matrix(qt2160);\r\nqt2160_schedule_read(qt2160);\r\n}\r\nstatic int __devinit qt2160_read(struct i2c_client *client, u8 reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte(client, reg);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"couldn't send request. Returned %d\n", ret);\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_byte(client);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"couldn't read register. Returned %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit qt2160_write(struct i2c_client *client, u8 reg, u8 data)\r\n{\r\nint error;\r\nerror = i2c_smbus_write_byte(client, reg);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"couldn't send request. Returned %d\n", error);\r\nreturn error;\r\n}\r\nerror = i2c_smbus_write_byte(client, data);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"couldn't write data. Returned %d\n", error);\r\nreturn error;\r\n}\r\nreturn error;\r\n}\r\nstatic bool __devinit qt2160_identify(struct i2c_client *client)\r\n{\r\nint id, ver, rev;\r\nid = qt2160_read(client, QT2160_CMD_CHIPID);\r\nif (id != QT2160_VALID_CHIPID) {\r\ndev_err(&client->dev, "ID %d not supported\n", id);\r\nreturn false;\r\n}\r\nver = qt2160_read(client, QT2160_CMD_CODEVER);\r\nif (ver < 0) {\r\ndev_err(&client->dev, "could not get firmware version\n");\r\nreturn false;\r\n}\r\nrev = qt2160_read(client, QT2160_CMD_SUBVER);\r\nif (rev < 0) {\r\ndev_err(&client->dev, "could not get firmware revision\n");\r\nreturn false;\r\n}\r\ndev_info(&client->dev, "AT42QT2160 firmware version %d.%d.%d\n",\r\nver >> 4, ver & 0xf, rev);\r\nreturn true;\r\n}\r\nstatic int __devinit qt2160_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct qt2160_data *qt2160;\r\nstruct input_dev *input;\r\nint i;\r\nint error;\r\nerror = i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE);\r\nif (!error) {\r\ndev_err(&client->dev, "%s adapter not supported\n",\r\ndev_driver_string(&client->adapter->dev));\r\nreturn -ENODEV;\r\n}\r\nif (!qt2160_identify(client))\r\nreturn -ENODEV;\r\nqt2160 = kzalloc(sizeof(struct qt2160_data), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!qt2160 || !input) {\r\ndev_err(&client->dev, "insufficient memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nqt2160->client = client;\r\nqt2160->input = input;\r\nINIT_DELAYED_WORK(&qt2160->dwork, qt2160_worker);\r\nspin_lock_init(&qt2160->lock);\r\ninput->name = "AT42QT2160 Touch Sense Keyboard";\r\ninput->id.bustype = BUS_I2C;\r\ninput->keycode = qt2160->keycodes;\r\ninput->keycodesize = sizeof(qt2160->keycodes[0]);\r\ninput->keycodemax = ARRAY_SIZE(qt2160_key2code);\r\n__set_bit(EV_KEY, input->evbit);\r\n__clear_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(qt2160_key2code); i++) {\r\nqt2160->keycodes[i] = qt2160_key2code[i];\r\n__set_bit(qt2160_key2code[i], input->keybit);\r\n}\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nerror = qt2160_write(client, QT2160_CMD_CALIBRATE, 1);\r\nif (error) {\r\ndev_err(&client->dev, "failed to calibrate device\n");\r\ngoto err_free_mem;\r\n}\r\nif (client->irq) {\r\nerror = request_irq(client->irq, qt2160_irq,\r\nIRQF_TRIGGER_FALLING, "qt2160", qt2160);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to allocate irq %d\n", client->irq);\r\ngoto err_free_mem;\r\n}\r\n}\r\nerror = input_register_device(qt2160->input);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to register input device\n");\r\ngoto err_free_irq;\r\n}\r\ni2c_set_clientdata(client, qt2160);\r\nqt2160_schedule_read(qt2160);\r\nreturn 0;\r\nerr_free_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, qt2160);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(qt2160);\r\nreturn error;\r\n}\r\nstatic int __devexit qt2160_remove(struct i2c_client *client)\r\n{\r\nstruct qt2160_data *qt2160 = i2c_get_clientdata(client);\r\nif (client->irq)\r\nfree_irq(client->irq, qt2160);\r\ncancel_delayed_work_sync(&qt2160->dwork);\r\ninput_unregister_device(qt2160->input);\r\nkfree(qt2160);\r\nreturn 0;\r\n}
