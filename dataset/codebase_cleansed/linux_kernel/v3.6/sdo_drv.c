static inline struct sdo_device *sd_to_sdev(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct sdo_device, sd);\r\n}\r\nstatic inline\r\nvoid sdo_write_mask(struct sdo_device *sdev, u32 reg_id, u32 value, u32 mask)\r\n{\r\nu32 old = readl(sdev->regs + reg_id);\r\nvalue = (value & mask) | (old & ~mask);\r\nwritel(value, sdev->regs + reg_id);\r\n}\r\nstatic inline\r\nvoid sdo_write(struct sdo_device *sdev, u32 reg_id, u32 value)\r\n{\r\nwritel(value, sdev->regs + reg_id);\r\n}\r\nstatic inline\r\nu32 sdo_read(struct sdo_device *sdev, u32 reg_id)\r\n{\r\nreturn readl(sdev->regs + reg_id);\r\n}\r\nstatic irqreturn_t sdo_irq_handler(int irq, void *dev_data)\r\n{\r\nstruct sdo_device *sdev = dev_data;\r\nsdo_write_mask(sdev, SDO_IRQ, ~0, SDO_VSYNC_IRQ_PEND);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sdo_reg_debug(struct sdo_device *sdev)\r\n{\r\n#define DBGREG(reg_id) \\r\ndev_info(sdev->dev, #reg_id " = %08x\n", \\r\nsdo_read(sdev, reg_id))\r\nDBGREG(SDO_CLKCON);\r\nDBGREG(SDO_CONFIG);\r\nDBGREG(SDO_VBI);\r\nDBGREG(SDO_DAC);\r\nDBGREG(SDO_IRQ);\r\nDBGREG(SDO_IRQMASK);\r\nDBGREG(SDO_VERSION);\r\n}\r\nstatic const struct sdo_format *sdo_find_format(v4l2_std_id id)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(sdo_format); ++i)\r\nif (sdo_format[i].id & id)\r\nreturn &sdo_format[i];\r\nreturn NULL;\r\n}\r\nstatic int sdo_g_tvnorms_output(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\n*std = V4L2_STD_NTSC_M | V4L2_STD_PAL_M | V4L2_STD_PAL |\r\nV4L2_STD_PAL_N | V4L2_STD_PAL_Nc |\r\nV4L2_STD_NTSC_443 | V4L2_STD_PAL_60;\r\nreturn 0;\r\n}\r\nstatic int sdo_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct sdo_device *sdev = sd_to_sdev(sd);\r\nconst struct sdo_format *fmt;\r\nfmt = sdo_find_format(std);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nsdev->fmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int sdo_g_std_output(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\n*std = sd_to_sdev(sd)->fmt->id;\r\nreturn 0;\r\n}\r\nstatic int sdo_g_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct sdo_device *sdev = sd_to_sdev(sd);\r\nif (!sdev->fmt)\r\nreturn -ENXIO;\r\nfmt->width = 720;\r\nfmt->height = sdev->fmt->height;\r\nfmt->code = V4L2_MBUS_FMT_FIXED;\r\nfmt->field = V4L2_FIELD_INTERLACED;\r\nfmt->colorspace = V4L2_COLORSPACE_JPEG;\r\nreturn 0;\r\n}\r\nstatic int sdo_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct sdo_device *sdev = sd_to_sdev(sd);\r\nstruct device *dev = sdev->dev;\r\nint ret;\r\ndev_info(dev, "sdo_s_power(%d)\n", on);\r\nif (on)\r\nret = pm_runtime_get_sync(dev);\r\nelse\r\nret = pm_runtime_put_sync(dev);\r\nreturn IS_ERR_VALUE(ret) ? ret : 0;\r\n}\r\nstatic int sdo_streamon(struct sdo_device *sdev)\r\n{\r\nclk_set_rate(sdev->fout_vpll, 54000000);\r\ndev_info(sdev->dev, "fout_vpll.rate = %lu\n",\r\nclk_get_rate(sdev->fout_vpll));\r\nsdo_write_mask(sdev, SDO_CLKCON, ~0, SDO_TVOUT_CLOCK_ON);\r\nclk_enable(sdev->dacphy);\r\nsdo_write_mask(sdev, SDO_DAC, ~0, SDO_POWER_ON_DAC);\r\nsdo_reg_debug(sdev);\r\nreturn 0;\r\n}\r\nstatic int sdo_streamoff(struct sdo_device *sdev)\r\n{\r\nint tries;\r\nsdo_write_mask(sdev, SDO_DAC, 0, SDO_POWER_ON_DAC);\r\nclk_disable(sdev->dacphy);\r\nsdo_write_mask(sdev, SDO_CLKCON, 0, SDO_TVOUT_CLOCK_ON);\r\nfor (tries = 100; tries; --tries) {\r\nif (sdo_read(sdev, SDO_CLKCON) & SDO_TVOUT_CLOCK_READY)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (tries == 0)\r\ndev_err(sdev->dev, "failed to stop streaming\n");\r\nreturn tries ? 0 : -EIO;\r\n}\r\nstatic int sdo_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct sdo_device *sdev = sd_to_sdev(sd);\r\nreturn on ? sdo_streamon(sdev) : sdo_streamoff(sdev);\r\n}\r\nstatic int sdo_runtime_suspend(struct device *dev)\r\n{\r\nstruct v4l2_subdev *sd = dev_get_drvdata(dev);\r\nstruct sdo_device *sdev = sd_to_sdev(sd);\r\ndev_info(dev, "suspend\n");\r\nregulator_disable(sdev->vdet);\r\nregulator_disable(sdev->vdac);\r\nclk_disable(sdev->sclk_dac);\r\nreturn 0;\r\n}\r\nstatic int sdo_runtime_resume(struct device *dev)\r\n{\r\nstruct v4l2_subdev *sd = dev_get_drvdata(dev);\r\nstruct sdo_device *sdev = sd_to_sdev(sd);\r\ndev_info(dev, "resume\n");\r\nclk_enable(sdev->sclk_dac);\r\nregulator_enable(sdev->vdac);\r\nregulator_enable(sdev->vdet);\r\nsdo_write_mask(sdev, SDO_CLKCON, ~0, SDO_TVOUT_SW_RESET);\r\nmdelay(10);\r\nsdo_write_mask(sdev, SDO_CLKCON, 0, SDO_TVOUT_SW_RESET);\r\nsdo_write_mask(sdev, SDO_CONFIG, sdev->fmt->cookie, SDO_STANDARD_MASK);\r\nsdo_write_mask(sdev, SDO_CONFIG, 0, SDO_PROGRESSIVE);\r\nsdo_write_mask(sdev, SDO_VBI, 0, SDO_CVBS_WSS_INS |\r\nSDO_CVBS_CLOSED_CAPTION_MASK);\r\nsdo_write_mask(sdev, SDO_CCCON, ~0, SDO_COMPENSATION_BHS_ADJ_OFF |\r\nSDO_COMPENSATION_CVBS_COMP_OFF);\r\nsdo_reg_debug(sdev);\r\nreturn 0;\r\n}\r\nstatic int __devinit sdo_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sdo_device *sdev;\r\nstruct resource *res;\r\nint ret = 0;\r\nstruct clk *sclk_vpll;\r\ndev_info(dev, "probe start\n");\r\nsdev = devm_kzalloc(&pdev->dev, sizeof *sdev, GFP_KERNEL);\r\nif (!sdev) {\r\ndev_err(dev, "not enough memory.\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nsdev->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get memory resource failed.\n");\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nsdev->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (sdev->regs == NULL) {\r\ndev_err(dev, "register mapping failed.\n");\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get interrupt resource failed.\n");\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nret = devm_request_irq(&pdev->dev, res->start, sdo_irq_handler, 0,\r\n"s5p-sdo", sdev);\r\nif (ret) {\r\ndev_err(dev, "request interrupt failed.\n");\r\ngoto fail;\r\n}\r\nsdev->irq = res->start;\r\nsdev->sclk_dac = clk_get(dev, "sclk_dac");\r\nif (IS_ERR_OR_NULL(sdev->sclk_dac)) {\r\ndev_err(dev, "failed to get clock 'sclk_dac'\n");\r\nret = -ENXIO;\r\ngoto fail;\r\n}\r\nsdev->dac = clk_get(dev, "dac");\r\nif (IS_ERR_OR_NULL(sdev->dac)) {\r\ndev_err(dev, "failed to get clock 'dac'\n");\r\nret = -ENXIO;\r\ngoto fail_sclk_dac;\r\n}\r\nsdev->dacphy = clk_get(dev, "dacphy");\r\nif (IS_ERR_OR_NULL(sdev->dacphy)) {\r\ndev_err(dev, "failed to get clock 'dacphy'\n");\r\nret = -ENXIO;\r\ngoto fail_dac;\r\n}\r\nsclk_vpll = clk_get(dev, "sclk_vpll");\r\nif (IS_ERR_OR_NULL(sclk_vpll)) {\r\ndev_err(dev, "failed to get clock 'sclk_vpll'\n");\r\nret = -ENXIO;\r\ngoto fail_dacphy;\r\n}\r\nclk_set_parent(sdev->sclk_dac, sclk_vpll);\r\nclk_put(sclk_vpll);\r\nsdev->fout_vpll = clk_get(dev, "fout_vpll");\r\nif (IS_ERR_OR_NULL(sdev->fout_vpll)) {\r\ndev_err(dev, "failed to get clock 'fout_vpll'\n");\r\ngoto fail_dacphy;\r\n}\r\ndev_info(dev, "fout_vpll.rate = %lu\n", clk_get_rate(sclk_vpll));\r\nsdev->vdac = regulator_get(dev, "vdd33a_dac");\r\nif (IS_ERR_OR_NULL(sdev->vdac)) {\r\ndev_err(dev, "failed to get regulator 'vdac'\n");\r\ngoto fail_fout_vpll;\r\n}\r\nsdev->vdet = regulator_get(dev, "vdet");\r\nif (IS_ERR_OR_NULL(sdev->vdet)) {\r\ndev_err(dev, "failed to get regulator 'vdet'\n");\r\ngoto fail_vdac;\r\n}\r\nclk_enable(sdev->dac);\r\npm_runtime_enable(dev);\r\nv4l2_subdev_init(&sdev->sd, &sdo_sd_ops);\r\nsdev->sd.owner = THIS_MODULE;\r\nstrlcpy(sdev->sd.name, "s5p-sdo", sizeof sdev->sd.name);\r\nsdev->fmt = sdo_find_format(SDO_DEFAULT_STD);\r\nBUG_ON(sdev->fmt == NULL);\r\ndev_set_drvdata(dev, &sdev->sd);\r\ndev_info(dev, "probe succeeded\n");\r\nreturn 0;\r\nfail_vdac:\r\nregulator_put(sdev->vdac);\r\nfail_fout_vpll:\r\nclk_put(sdev->fout_vpll);\r\nfail_dacphy:\r\nclk_put(sdev->dacphy);\r\nfail_dac:\r\nclk_put(sdev->dac);\r\nfail_sclk_dac:\r\nclk_put(sdev->sclk_dac);\r\nfail:\r\ndev_info(dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int __devexit sdo_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *sd = dev_get_drvdata(&pdev->dev);\r\nstruct sdo_device *sdev = sd_to_sdev(sd);\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable(sdev->dac);\r\nregulator_put(sdev->vdet);\r\nregulator_put(sdev->vdac);\r\nclk_put(sdev->fout_vpll);\r\nclk_put(sdev->dacphy);\r\nclk_put(sdev->dac);\r\nclk_put(sdev->sclk_dac);\r\ndev_info(&pdev->dev, "remove successful\n");\r\nreturn 0;\r\n}
