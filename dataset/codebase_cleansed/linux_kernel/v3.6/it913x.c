static int it913x_bulk_write(struct usb_device *dev,\r\nu8 *snd, int len, u8 pipe)\r\n{\r\nint ret, actual_l, i;\r\nfor (i = 0; i < IT913X_RETRY; i++) {\r\nret = usb_bulk_msg(dev, usb_sndbulkpipe(dev, pipe),\r\nsnd, len , &actual_l, IT913X_SND_TIMEOUT);\r\nif (ret != -EBUSY && ret != -ETIMEDOUT)\r\nbreak;\r\n}\r\nif (len != actual_l && ret == 0)\r\nret = -EAGAIN;\r\nreturn ret;\r\n}\r\nstatic int it913x_bulk_read(struct usb_device *dev,\r\nu8 *rev, int len, u8 pipe)\r\n{\r\nint ret, actual_l, i;\r\nfor (i = 0; i < IT913X_RETRY; i++) {\r\nret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, pipe),\r\nrev, len , &actual_l, IT913X_RCV_TIMEOUT);\r\nif (ret != -EBUSY && ret != -ETIMEDOUT)\r\nbreak;\r\n}\r\nif (len != actual_l && ret == 0)\r\nret = -EAGAIN;\r\nreturn ret;\r\n}\r\nstatic u16 check_sum(u8 *p, u8 len)\r\n{\r\nu16 sum = 0;\r\nu8 i = 1;\r\nwhile (i < len)\r\nsum += (i++ & 1) ? (*p++) << 8 : *p++;\r\nreturn ~sum;\r\n}\r\nstatic int it913x_usb_talk(struct usb_device *udev, u8 mode, u8 pro,\r\nu8 cmd, u32 reg, u8 addr, u8 *data, u8 len)\r\n{\r\nint ret = 0, i, buf_size = 1;\r\nu8 *buff;\r\nu8 rlen;\r\nu16 chk_sum;\r\nbuff = kzalloc(256, GFP_KERNEL);\r\nif (!buff) {\r\ninfo("USB Buffer Failed");\r\nreturn -ENOMEM;\r\n}\r\nbuff[buf_size++] = pro;\r\nbuff[buf_size++] = cmd;\r\nbuff[buf_size++] = cmd_counter;\r\nswitch (mode) {\r\ncase READ_LONG:\r\ncase WRITE_LONG:\r\nbuff[buf_size++] = len;\r\nbuff[buf_size++] = 2;\r\nbuff[buf_size++] = (reg >> 24);\r\nbuff[buf_size++] = (reg >> 16) & 0xff;\r\nbuff[buf_size++] = (reg >> 8) & 0xff;\r\nbuff[buf_size++] = reg & 0xff;\r\nbreak;\r\ncase READ_SHORT:\r\nbuff[buf_size++] = addr;\r\nbreak;\r\ncase WRITE_SHORT:\r\nbuff[buf_size++] = len;\r\nbuff[buf_size++] = addr;\r\nbuff[buf_size++] = (reg >> 8) & 0xff;\r\nbuff[buf_size++] = reg & 0xff;\r\nbreak;\r\ncase READ_DATA:\r\ncase WRITE_DATA:\r\nbreak;\r\ncase WRITE_CMD:\r\nmode = 7;\r\nbreak;\r\ndefault:\r\nkfree(buff);\r\nreturn -EINVAL;\r\n}\r\nif (mode & 1) {\r\nfor (i = 0; i < len ; i++)\r\nbuff[buf_size++] = data[i];\r\n}\r\nchk_sum = check_sum(&buff[1], buf_size);\r\nbuff[buf_size++] = chk_sum >> 8;\r\nbuff[0] = buf_size;\r\nbuff[buf_size++] = (chk_sum & 0xff);\r\nret = it913x_bulk_write(udev, buff, buf_size , 0x02);\r\nif (ret < 0)\r\ngoto error;\r\nret = it913x_bulk_read(udev, buff, (mode & 1) ?\r\n5 : len + 5 , 0x01);\r\nif (ret < 0)\r\ngoto error;\r\nrlen = (mode & 0x1) ? 0x1 : len;\r\nif (mode & 1)\r\nret = buff[2];\r\nelse\r\nmemcpy(data, &buff[3], rlen);\r\ncmd_counter++;\r\nerror: kfree(buff);\r\nreturn ret;\r\n}\r\nstatic int it913x_io(struct usb_device *udev, u8 mode, u8 pro,\r\nu8 cmd, u32 reg, u8 addr, u8 *data, u8 len)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < IT913X_RETRY; i++) {\r\nret = it913x_usb_talk(udev, mode, pro,\r\ncmd, reg, addr, data, len);\r\nif (ret != -EAGAIN)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int it913x_wr_reg(struct usb_device *udev, u8 pro, u32 reg , u8 data)\r\n{\r\nint ret;\r\nu8 b[1];\r\nb[0] = data;\r\nret = it913x_io(udev, WRITE_LONG, pro,\r\nCMD_DEMOD_WRITE, reg, 0, b, sizeof(b));\r\nreturn ret;\r\n}\r\nstatic int it913x_read_reg(struct usb_device *udev, u32 reg)\r\n{\r\nint ret;\r\nu8 data[1];\r\nret = it913x_io(udev, READ_LONG, DEV_0,\r\nCMD_DEMOD_READ, reg, 0, &data[0], 1);\r\nreturn (ret < 0) ? ret : data[0];\r\n}\r\nstatic u32 it913x_query(struct usb_device *udev, u8 pro)\r\n{\r\nint ret, i;\r\nu8 data[4];\r\nu8 ver;\r\nfor (i = 0; i < 5; i++) {\r\nret = it913x_io(udev, READ_LONG, pro, CMD_DEMOD_READ,\r\n0x1222, 0, &data[0], 3);\r\nver = data[0];\r\nif (ver > 0 && ver < 3)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (ver < 1 || ver > 2) {\r\ninfo("Failed to identify chip version applying 1");\r\nit913x_config.chip_ver = 0x1;\r\nit913x_config.chip_type = 0x9135;\r\nreturn 0;\r\n}\r\nit913x_config.chip_ver = ver;\r\nit913x_config.chip_type = (u16)(data[2] << 8) + data[1];\r\ninfo("Chip Version=%02x Chip Type=%04x", it913x_config.chip_ver,\r\nit913x_config.chip_type);\r\nret |= it913x_io(udev, READ_SHORT, pro,\r\nCMD_QUERYINFO, 0, 0x1, &data[0], 4);\r\nit913x_config.firmware = (data[0] << 24) + (data[1] << 16) +\r\n(data[2] << 8) + data[3];\r\nreturn (ret < 0) ? 0 : it913x_config.firmware;\r\n}\r\nstatic int it913x_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct it913x_state *st = adap->dev->priv;\r\nstruct usb_device *udev = adap->dev->udev;\r\nint ret;\r\nu8 pro = (adap->id == 0) ? DEV_0_DMOD : DEV_1_DMOD;\r\nmutex_lock(&adap->dev->i2c_mutex);\r\ndeb_info(1, "PID_C (%02x)", onoff);\r\nret = it913x_wr_reg(udev, pro, PID_EN, st->pid_filter_onoff);\r\nmutex_unlock(&adap->dev->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int it913x_pid_filter(struct dvb_usb_adapter *adap,\r\nint index, u16 pid, int onoff)\r\n{\r\nstruct it913x_state *st = adap->dev->priv;\r\nstruct usb_device *udev = adap->dev->udev;\r\nint ret;\r\nu8 pro = (adap->id == 0) ? DEV_0_DMOD : DEV_1_DMOD;\r\nmutex_lock(&adap->dev->i2c_mutex);\r\ndeb_info(1, "PID_F (%02x)", onoff);\r\nret = it913x_wr_reg(udev, pro, PID_LSB, (u8)(pid & 0xff));\r\nret |= it913x_wr_reg(udev, pro, PID_MSB, (u8)(pid >> 8));\r\nret |= it913x_wr_reg(udev, pro, PID_INX_EN, (u8)onoff);\r\nret |= it913x_wr_reg(udev, pro, PID_INX, (u8)(index & 0x1f));\r\nif (udev->speed == USB_SPEED_HIGH && pid == 0x2000) {\r\nret |= it913x_wr_reg(udev, pro, PID_EN, !onoff);\r\nst->pid_filter_onoff = !onoff;\r\n} else\r\nst->pid_filter_onoff =\r\nadap->fe_adap[adap->active_fe].pid_filtering;\r\nmutex_unlock(&adap->dev->i2c_mutex);\r\nreturn 0;\r\n}\r\nstatic int it913x_return_status(struct usb_device *udev)\r\n{\r\nu32 firm = 0;\r\nfirm = it913x_query(udev, DEV_0);\r\nif (firm > 0)\r\ninfo("Firmware Version %d", firm);\r\nreturn (firm > 0) ? firm : 0;\r\n}\r\nstatic int it913x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstatic u8 data[256];\r\nint ret;\r\nu32 reg;\r\nu8 pro;\r\nmutex_lock(&d->i2c_mutex);\r\ndebug_data_snipet(1, "Message out", msg[0].buf);\r\ndeb_info(2, "num of messages %d address %02x", num, msg[0].addr);\r\npro = (msg[0].addr & 0x2) ? DEV_0_DMOD : 0x0;\r\npro |= (msg[0].addr & 0x20) ? DEV_1 : DEV_0;\r\nmemcpy(data, msg[0].buf, msg[0].len);\r\nreg = (data[0] << 24) + (data[1] << 16) +\r\n(data[2] << 8) + data[3];\r\nif (num == 2) {\r\nret = it913x_io(d->udev, READ_LONG, pro,\r\nCMD_DEMOD_READ, reg, 0, data, msg[1].len);\r\nmemcpy(msg[1].buf, data, msg[1].len);\r\n} else\r\nret = it913x_io(d->udev, WRITE_LONG, pro, CMD_DEMOD_WRITE,\r\nreg, 0, &data[4], msg[0].len - 4);\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 it913x_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int it913x_rc_query(struct dvb_usb_device *d)\r\n{\r\nu8 ibuf[4];\r\nint ret;\r\nu32 key;\r\nmutex_lock(&d->i2c_mutex);\r\nret = it913x_io(d->udev, READ_LONG, PRO_LINK, CMD_IR_GET,\r\n0, 0, &ibuf[0], sizeof(ibuf));\r\nif ((ibuf[2] + ibuf[3]) == 0xff) {\r\nkey = ibuf[2];\r\nkey += ibuf[0] << 16;\r\nkey += ibuf[1] << 8;\r\ndeb_info(1, "NEC Extended Key =%08x", key);\r\nif (d->rc_dev != NULL)\r\nrc_keydown(d->rc_dev, key, 0);\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int ite_firmware_select(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props)\r\n{\r\nint sw;\r\nif (le16_to_cpu(udev->descriptor.idVendor) == USB_VID_KWORLD_2)\r\nsw = IT9137_FW;\r\nelse if (it913x_config.chip_ver == 1)\r\nsw = IT9135_V1_FW;\r\nelse\r\nsw = IT9135_V2_FW;\r\nif (dvb_usb_it913x_firmware != IT9135_AUTO)\r\nsw = dvb_usb_it913x_firmware;\r\nswitch (sw) {\r\ncase IT9135_V1_FW:\r\nit913x_config.firmware_ver = 1;\r\nit913x_config.adc_x2 = 1;\r\nit913x_config.read_slevel = false;\r\nprops->firmware = fw_it9135_v1;\r\nbreak;\r\ncase IT9135_V2_FW:\r\nit913x_config.firmware_ver = 1;\r\nit913x_config.adc_x2 = 1;\r\nit913x_config.read_slevel = false;\r\nprops->firmware = fw_it9135_v2;\r\nswitch (it913x_config.tuner_id_0) {\r\ncase IT9135_61:\r\ncase IT9135_62:\r\nbreak;\r\ndefault:\r\ninfo("Unknown tuner ID applying default 0x60");\r\ncase IT9135_60:\r\nit913x_config.tuner_id_0 = IT9135_60;\r\n}\r\nbreak;\r\ncase IT9137_FW:\r\ndefault:\r\nit913x_config.firmware_ver = 0;\r\nit913x_config.adc_x2 = 0;\r\nit913x_config.read_slevel = true;\r\nprops->firmware = fw_it9137;\r\n}\r\nreturn 0;\r\n}\r\nstatic void it913x_select_remote(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props)\r\n{\r\nswitch (le16_to_cpu(udev->descriptor.idProduct)) {\r\ncase USB_PID_ITETECH_IT9135_9005:\r\nprops->rc.core.rc_codes = RC_MAP_IT913X_V2;\r\nreturn;\r\ndefault:\r\nprops->rc.core.rc_codes = RC_MAP_IT913X_V1;\r\n}\r\nreturn;\r\n}\r\nstatic int it913x_select_config(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props)\r\n{\r\nint ret = 0, reg;\r\nbool proprietary_ir = false;\r\nif (it913x_config.chip_ver == 0x02\r\n&& it913x_config.chip_type == 0x9135)\r\nreg = it913x_read_reg(udev, 0x461d);\r\nelse\r\nreg = it913x_read_reg(udev, 0x461b);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg == 0) {\r\nit913x_config.dual_mode = 0;\r\nit913x_config.tuner_id_0 = IT9135_38;\r\nproprietary_ir = true;\r\n} else {\r\nreg = it913x_read_reg(udev, 0x49c5);\r\nif (reg < 0)\r\nreturn reg;\r\nit913x_config.dual_mode = reg;\r\nreg = it913x_read_reg(udev, 0x49ac);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg == 5) {\r\ninfo("Remote propriety (raw) mode");\r\nproprietary_ir = true;\r\n} else if (reg == 1) {\r\ninfo("Remote HID mode NOT SUPPORTED");\r\nproprietary_ir = false;\r\nprops->rc.core.rc_codes = NULL;\r\n} else\r\nprops->rc.core.rc_codes = NULL;\r\nreg = it913x_read_reg(udev, 0x49d0);\r\nif (reg < 0)\r\nreturn reg;\r\nit913x_config.tuner_id_0 = reg;\r\n}\r\nif (proprietary_ir)\r\nit913x_select_remote(udev, props);\r\nif (udev->speed != USB_SPEED_HIGH) {\r\nprops->adapter[0].fe[0].pid_filter_count = 5;\r\ninfo("USB 1 low speed mode - connect to USB 2 port");\r\nif (pid_filter > 0)\r\npid_filter = 0;\r\nif (it913x_config.dual_mode) {\r\nit913x_config.dual_mode = 0;\r\ninfo("Dual mode not supported in USB 1");\r\n}\r\n} else\r\nif(props->adapter[0].fe[0].pid_filter_count == 5)\r\nprops->adapter[0].fe[0].pid_filter_count = 31;\r\nif (pid_filter) {\r\nprops->adapter[0].fe[0].stream.u.bulk.buffersize =\r\nTS_BUFFER_SIZE_MAX;\r\nprops->adapter[0].fe[0].caps &=\r\n~DVB_USB_ADAP_NEED_PID_FILTERING;\r\n} else\r\nprops->adapter[0].fe[0].stream.u.bulk.buffersize =\r\nTS_BUFFER_SIZE_PID;\r\nif (it913x_config.dual_mode) {\r\nprops->adapter[1].fe[0].stream.u.bulk.buffersize =\r\nprops->adapter[0].fe[0].stream.u.bulk.buffersize;\r\nprops->num_adapters = 2;\r\nif (pid_filter)\r\nprops->adapter[1].fe[0].caps =\r\nprops->adapter[0].fe[0].caps;\r\n} else\r\nprops->num_adapters = 1;\r\ninfo("Dual mode=%x Tuner Type=%x", it913x_config.dual_mode,\r\nit913x_config.tuner_id_0);\r\nret = ite_firmware_select(udev, props);\r\nreturn ret;\r\n}\r\nstatic int it913x_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\nint ret = 0, firm_no;\r\nu8 reg;\r\nfirm_no = it913x_return_status(udev);\r\nret = it913x_select_config(udev, props);\r\nif (ret < 0)\r\nreturn ret;\r\nif (firm_no > 0) {\r\n*cold = 0;\r\nreturn 0;\r\n}\r\nif (it913x_config.dual_mode) {\r\nit913x_config.tuner_id_1 = it913x_read_reg(udev, 0x49e0);\r\nret = it913x_wr_reg(udev, DEV_0, GPIOH1_EN, 0x1);\r\nret |= it913x_wr_reg(udev, DEV_0, GPIOH1_ON, 0x1);\r\nret |= it913x_wr_reg(udev, DEV_0, GPIOH1_O, 0x1);\r\nmsleep(50);\r\nret |= it913x_wr_reg(udev, DEV_0, GPIOH1_O, 0x0);\r\nmsleep(50);\r\nreg = it913x_read_reg(udev, GPIOH1_O);\r\nif (reg == 0) {\r\nret |= it913x_wr_reg(udev, DEV_0, GPIOH1_O, 0x1);\r\nret |= it913x_return_status(udev);\r\nif (ret != 0)\r\nret = it913x_wr_reg(udev, DEV_0,\r\nGPIOH1_O, 0x0);\r\n}\r\n}\r\nreg = it913x_read_reg(udev, IO_MUX_POWER_CLK);\r\nif (it913x_config.dual_mode) {\r\nret |= it913x_wr_reg(udev, DEV_0, 0x4bfb, CHIP2_I2C_ADDR);\r\nif (it913x_config.firmware_ver == 1)\r\nret |= it913x_wr_reg(udev, DEV_0, 0xcfff, 0x1);\r\nelse\r\nret |= it913x_wr_reg(udev, DEV_0, CLK_O_EN, 0x1);\r\n} else {\r\nret |= it913x_wr_reg(udev, DEV_0, 0x4bfb, 0x0);\r\nif (it913x_config.firmware_ver == 1)\r\nret |= it913x_wr_reg(udev, DEV_0, 0xcfff, 0x0);\r\nelse\r\nret |= it913x_wr_reg(udev, DEV_0, CLK_O_EN, 0x0);\r\n}\r\n*cold = 1;\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct it913x_state *st = adap->dev->priv;\r\nint ret = 0;\r\nu8 pro = (adap->id == 0) ? DEV_0_DMOD : DEV_1_DMOD;\r\ndeb_info(1, "STM (%02x)", onoff);\r\nif (!onoff) {\r\nmutex_lock(&adap->dev->i2c_mutex);\r\nret = it913x_wr_reg(adap->dev->udev, pro, PID_RST, 0x1);\r\nmutex_unlock(&adap->dev->i2c_mutex);\r\nst->pid_filter_onoff =\r\nadap->fe_adap[adap->active_fe].pid_filtering;\r\n}\r\nreturn ret;\r\n}\r\nstatic int it913x_download_firmware(struct usb_device *udev,\r\nconst struct firmware *fw)\r\n{\r\nint ret = 0, i = 0, pos = 0;\r\nu8 packet_size, min_pkt;\r\nu8 *fw_data;\r\nret = it913x_wr_reg(udev, DEV_0, I2C_CLK, I2C_CLK_100);\r\ninfo("FRM Starting Firmware Download");\r\nif (it913x_config.chip_ver == 2)\r\nmin_pkt = 0x11;\r\nelse\r\nmin_pkt = 0x19;\r\nwhile (i <= fw->size) {\r\nif (((fw->data[i] == 0x3) && (fw->data[i + 2] == 0x0))\r\n|| (i == fw->size)) {\r\npacket_size = i - pos;\r\nif ((packet_size > min_pkt) || (i == fw->size)) {\r\nfw_data = (u8 *)(fw->data + pos);\r\npos += packet_size;\r\nif (packet_size > 0) {\r\nret = it913x_io(udev, WRITE_DATA,\r\nDEV_0, CMD_SCATTER_WRITE, 0,\r\n0, fw_data, packet_size);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nudelay(1000);\r\n}\r\n}\r\ni++;\r\n}\r\nif (ret < 0)\r\ninfo("FRM Firmware Download Failed (%d)" , ret);\r\nelse\r\ninfo("FRM Firmware Download Completed - Resetting Device");\r\nmsleep(30);\r\nret = it913x_io(udev, WRITE_CMD, DEV_0, CMD_BOOT, 0, 0, NULL, 0);\r\nif (ret < 0)\r\ninfo("FRM Device not responding to reboot");\r\nret = it913x_return_status(udev);\r\nif (ret == 0) {\r\ninfo("FRM Failed to reboot device");\r\nreturn -ENODEV;\r\n}\r\nmsleep(30);\r\nret = it913x_wr_reg(udev, DEV_0, I2C_CLK, I2C_CLK_400);\r\nmsleep(30);\r\nif (it913x_config.dual_mode)\r\nret |= it913x_wr_reg(udev, DEV_0_DMOD , 0xec4c, 0xa0);\r\nelse\r\nret |= it913x_wr_reg(udev, DEV_0_DMOD , 0xec4c, 0x68);\r\nif ((it913x_config.chip_ver == 1) &&\r\n(it913x_config.chip_type == 0x9135)) {\r\nret |= it913x_wr_reg(udev, DEV_0, PADODPU, 0x0);\r\nret |= it913x_wr_reg(udev, DEV_0, AGC_O_D, 0x0);\r\nif (it913x_config.dual_mode) {\r\nret |= it913x_wr_reg(udev, DEV_1, PADODPU, 0x0);\r\nret |= it913x_wr_reg(udev, DEV_1, AGC_O_D, 0x0);\r\n}\r\n}\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_name(struct dvb_usb_adapter *adap)\r\n{\r\nconst char *desc = adap->dev->desc->name;\r\nchar *fe_name[] = {"_1", "_2", "_3", "_4"};\r\nchar *name = adap->fe_adap[0].fe->ops.info.name;\r\nstrlcpy(name, desc, 128);\r\nstrlcat(name, fe_name[adap->id], 128);\r\nreturn 0;\r\n}\r\nstatic int it913x_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct usb_device *udev = adap->dev->udev;\r\nstruct it913x_state *st = adap->dev->priv;\r\nint ret = 0;\r\nu8 adap_addr = I2C_BASE_ADDR + (adap->id << 5);\r\nu16 ep_size = adap->props.fe[0].stream.u.bulk.buffersize / 4;\r\nu8 pkt_size = 0x80;\r\nif (adap->dev->udev->speed != USB_SPEED_HIGH)\r\npkt_size = 0x10;\r\nit913x_config.adf = it913x_read_reg(udev, IO_MUX_POWER_CLK);\r\nif (adap->id == 0)\r\nmemcpy(&st->it913x_config, &it913x_config,\r\nsizeof(struct ite_config));\r\nadap->fe_adap[0].fe = dvb_attach(it913x_fe_attach,\r\n&adap->dev->i2c_adap, adap_addr, &st->it913x_config);\r\nif (adap->id == 0 && adap->fe_adap[0].fe) {\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, MP2_SW_RST, 0x1);\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, MP2IF2_SW_RST, 0x1);\r\nret = it913x_wr_reg(udev, DEV_0, EP0_TX_EN, 0x0f);\r\nret = it913x_wr_reg(udev, DEV_0, EP0_TX_NAK, 0x1b);\r\nret = it913x_wr_reg(udev, DEV_0, EP0_TX_EN, 0x2f);\r\nret = it913x_wr_reg(udev, DEV_0, EP4_TX_LEN_LSB,\r\nep_size & 0xff);\r\nret = it913x_wr_reg(udev, DEV_0, EP4_TX_LEN_MSB, ep_size >> 8);\r\nret = it913x_wr_reg(udev, DEV_0, EP4_MAX_PKT, pkt_size);\r\n} else if (adap->id == 1 && adap->fe_adap[0].fe) {\r\nret = it913x_wr_reg(udev, DEV_0, EP0_TX_EN, 0x6f);\r\nret = it913x_wr_reg(udev, DEV_0, EP5_TX_LEN_LSB,\r\nep_size & 0xff);\r\nret = it913x_wr_reg(udev, DEV_0, EP5_TX_LEN_MSB, ep_size >> 8);\r\nret = it913x_wr_reg(udev, DEV_0, EP5_MAX_PKT, pkt_size);\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, MP2IF2_EN, 0x1);\r\nret = it913x_wr_reg(udev, DEV_1_DMOD, MP2IF_SERIAL, 0x1);\r\nret = it913x_wr_reg(udev, DEV_1, TOP_HOSTB_SER_MODE, 0x1);\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, TSIS_ENABLE, 0x1);\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, MP2_SW_RST, 0x0);\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, MP2IF2_SW_RST, 0x0);\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, MP2IF2_HALF_PSB, 0x0);\r\nret = it913x_wr_reg(udev, DEV_0_DMOD, MP2IF_STOP_EN, 0x1);\r\nret = it913x_wr_reg(udev, DEV_1_DMOD, MPEG_FULL_SPEED, 0x0);\r\nret = it913x_wr_reg(udev, DEV_1_DMOD, MP2IF_STOP_EN, 0x0);\r\n} else\r\nreturn -ENODEV;\r\nret = it913x_name(adap);\r\nreturn ret;\r\n}\r\nstatic int it913x_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\ncmd_counter = 0;\r\nif (0 == dvb_usb_device_init(intf, &it913x_properties,\r\nTHIS_MODULE, NULL, adapter_nr)) {\r\ninfo("DEV registering device driver");\r\nreturn 0;\r\n}\r\ninfo("DEV it913x Error");\r\nreturn -ENODEV;\r\n}
