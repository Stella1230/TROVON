static void trace_stbit(const char *name,int val)\r\n{\r\npvr2_trace(PVR2_TRACE_STBITS,\r\n"State bit %s <-- %s",\r\nname,(val ? "true" : "false"));\r\n}\r\nstatic int ctrl_channelfreq_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nif ((hdw->freqProgSlot > 0) && (hdw->freqProgSlot <= FREQTABLE_SIZE)) {\r\n*vp = hdw->freqTable[hdw->freqProgSlot-1];\r\n} else {\r\n*vp = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_channelfreq_set(struct pvr2_ctrl *cptr,int m,int v)\r\n{\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nunsigned int slotId = hdw->freqProgSlot;\r\nif ((slotId > 0) && (slotId <= FREQTABLE_SIZE)) {\r\nhdw->freqTable[slotId-1] = v;\r\nif (hdw->freqSelector) {\r\nif (hdw->freqSlotRadio == slotId) {\r\nhdw->freqSlotRadio = 0;\r\n}\r\n} else {\r\nif (hdw->freqSlotTelevision == slotId) {\r\nhdw->freqSlotTelevision = 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_channelprog_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\n*vp = cptr->hdw->freqProgSlot;\r\nreturn 0;\r\n}\r\nstatic int ctrl_channelprog_set(struct pvr2_ctrl *cptr,int m,int v)\r\n{\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nif ((v >= 0) && (v <= FREQTABLE_SIZE)) {\r\nhdw->freqProgSlot = v;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_channel_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\n*vp = hdw->freqSelector ? hdw->freqSlotRadio : hdw->freqSlotTelevision;\r\nreturn 0;\r\n}\r\nstatic int ctrl_channel_set(struct pvr2_ctrl *cptr,int m,int slotId)\r\n{\r\nunsigned freq = 0;\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nif ((slotId < 0) || (slotId > FREQTABLE_SIZE)) return 0;\r\nif (slotId > 0) {\r\nfreq = hdw->freqTable[slotId-1];\r\nif (!freq) return 0;\r\npvr2_hdw_set_cur_freq(hdw,freq);\r\n}\r\nif (hdw->freqSelector) {\r\nhdw->freqSlotRadio = slotId;\r\n} else {\r\nhdw->freqSlotTelevision = slotId;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_freq_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\n*vp = pvr2_hdw_get_cur_freq(cptr->hdw);\r\nreturn 0;\r\n}\r\nstatic int ctrl_freq_is_dirty(struct pvr2_ctrl *cptr)\r\n{\r\nreturn cptr->hdw->freqDirty != 0;\r\n}\r\nstatic void ctrl_freq_clear_dirty(struct pvr2_ctrl *cptr)\r\n{\r\ncptr->hdw->freqDirty = 0;\r\n}\r\nstatic int ctrl_freq_set(struct pvr2_ctrl *cptr,int m,int v)\r\n{\r\npvr2_hdw_set_cur_freq(cptr->hdw,v);\r\nreturn 0;\r\n}\r\nstatic int ctrl_cropl_min_get(struct pvr2_ctrl *cptr, int *left)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*left = cap->bounds.left;\r\nreturn 0;\r\n}\r\nstatic int ctrl_cropl_max_get(struct pvr2_ctrl *cptr, int *left)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*left = cap->bounds.left;\r\nif (cap->bounds.width > cptr->hdw->cropw_val) {\r\n*left += cap->bounds.width - cptr->hdw->cropw_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_cropt_min_get(struct pvr2_ctrl *cptr, int *top)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*top = cap->bounds.top;\r\nreturn 0;\r\n}\r\nstatic int ctrl_cropt_max_get(struct pvr2_ctrl *cptr, int *top)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*top = cap->bounds.top;\r\nif (cap->bounds.height > cptr->hdw->croph_val) {\r\n*top += cap->bounds.height - cptr->hdw->croph_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_cropw_max_get(struct pvr2_ctrl *cptr, int *width)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat, bleftend, cleft;\r\nstat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\nbleftend = cap->bounds.left+cap->bounds.width;\r\ncleft = cptr->hdw->cropl_val;\r\n*width = cleft < bleftend ? bleftend-cleft : 0;\r\nreturn 0;\r\n}\r\nstatic int ctrl_croph_max_get(struct pvr2_ctrl *cptr, int *height)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat, btopend, ctop;\r\nstat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\nbtopend = cap->bounds.top+cap->bounds.height;\r\nctop = cptr->hdw->cropt_val;\r\n*height = ctop < btopend ? btopend-ctop : 0;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapbl(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->bounds.left;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapbt(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->bounds.top;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapbw(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->bounds.width;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapbh(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->bounds.height;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapdl(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->defrect.left;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapdt(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->defrect.top;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapdw(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->defrect.width;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcapdh(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->defrect.height;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcappan(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->pixelaspect.numerator;\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_cropcappad(struct pvr2_ctrl *cptr, int *val)\r\n{\r\nstruct v4l2_cropcap *cap = &cptr->hdw->cropcap_info;\r\nint stat = pvr2_hdw_check_cropcap(cptr->hdw);\r\nif (stat != 0) {\r\nreturn stat;\r\n}\r\n*val = cap->pixelaspect.denominator;\r\nreturn 0;\r\n}\r\nstatic int ctrl_vres_max_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nif (cptr->hdw->std_mask_cur & V4L2_STD_525_60) {\r\n*vp = 480;\r\n} else {\r\n*vp = 576;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_vres_min_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nif (cptr->hdw->hdw_desc->flag_has_cx25840) {\r\n*vp = 75;\r\n} else {\r\n*vp = 17;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctrl_get_input(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\n*vp = cptr->hdw->input_val;\r\nreturn 0;\r\n}\r\nstatic int ctrl_check_input(struct pvr2_ctrl *cptr,int v)\r\n{\r\nreturn ((1 << v) & cptr->hdw->input_allowed_mask) != 0;\r\n}\r\nstatic int ctrl_set_input(struct pvr2_ctrl *cptr,int m,int v)\r\n{\r\nreturn pvr2_hdw_set_input(cptr->hdw,v);\r\n}\r\nstatic int ctrl_isdirty_input(struct pvr2_ctrl *cptr)\r\n{\r\nreturn cptr->hdw->input_dirty != 0;\r\n}\r\nstatic void ctrl_cleardirty_input(struct pvr2_ctrl *cptr)\r\n{\r\ncptr->hdw->input_dirty = 0;\r\n}\r\nstatic int ctrl_freq_max_get(struct pvr2_ctrl *cptr, int *vp)\r\n{\r\nunsigned long fv;\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nif (hdw->tuner_signal_stale) {\r\npvr2_hdw_status_poll(hdw);\r\n}\r\nfv = hdw->tuner_signal_info.rangehigh;\r\nif (!fv) {\r\n*vp = TV_MAX_FREQ;\r\nreturn 0;\r\n}\r\nif (hdw->tuner_signal_info.capability & V4L2_TUNER_CAP_LOW) {\r\nfv = (fv * 125) / 2;\r\n} else {\r\nfv = fv * 62500;\r\n}\r\n*vp = fv;\r\nreturn 0;\r\n}\r\nstatic int ctrl_freq_min_get(struct pvr2_ctrl *cptr, int *vp)\r\n{\r\nunsigned long fv;\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nif (hdw->tuner_signal_stale) {\r\npvr2_hdw_status_poll(hdw);\r\n}\r\nfv = hdw->tuner_signal_info.rangelow;\r\nif (!fv) {\r\n*vp = TV_MIN_FREQ;\r\nreturn 0;\r\n}\r\nif (hdw->tuner_signal_info.capability & V4L2_TUNER_CAP_LOW) {\r\nfv = (fv * 125) / 2;\r\n} else {\r\nfv = fv * 62500;\r\n}\r\n*vp = fv;\r\nreturn 0;\r\n}\r\nstatic int ctrl_cx2341x_is_dirty(struct pvr2_ctrl *cptr)\r\n{\r\nreturn cptr->hdw->enc_stale != 0;\r\n}\r\nstatic void ctrl_cx2341x_clear_dirty(struct pvr2_ctrl *cptr)\r\n{\r\ncptr->hdw->enc_stale = 0;\r\ncptr->hdw->enc_unsafe_stale = 0;\r\n}\r\nstatic int ctrl_cx2341x_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nint ret;\r\nstruct v4l2_ext_controls cs;\r\nstruct v4l2_ext_control c1;\r\nmemset(&cs,0,sizeof(cs));\r\nmemset(&c1,0,sizeof(c1));\r\ncs.controls = &c1;\r\ncs.count = 1;\r\nc1.id = cptr->info->v4l_id;\r\nret = cx2341x_ext_ctrls(&cptr->hdw->enc_ctl_state, 0, &cs,\r\nVIDIOC_G_EXT_CTRLS);\r\nif (ret) return ret;\r\n*vp = c1.value;\r\nreturn 0;\r\n}\r\nstatic int ctrl_cx2341x_set(struct pvr2_ctrl *cptr,int m,int v)\r\n{\r\nint ret;\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nstruct v4l2_ext_controls cs;\r\nstruct v4l2_ext_control c1;\r\nmemset(&cs,0,sizeof(cs));\r\nmemset(&c1,0,sizeof(c1));\r\ncs.controls = &c1;\r\ncs.count = 1;\r\nc1.id = cptr->info->v4l_id;\r\nc1.value = v;\r\nret = cx2341x_ext_ctrls(&hdw->enc_ctl_state,\r\nhdw->state_encoder_run, &cs,\r\nVIDIOC_S_EXT_CTRLS);\r\nif (ret == -EBUSY) {\r\nret = cx2341x_ext_ctrls(&hdw->enc_ctl_state,\r\n0, &cs,\r\nVIDIOC_S_EXT_CTRLS);\r\nif (!ret) hdw->enc_unsafe_stale = !0;\r\n}\r\nif (ret) return ret;\r\nhdw->enc_stale = !0;\r\nreturn 0;\r\n}\r\nstatic unsigned int ctrl_cx2341x_getv4lflags(struct pvr2_ctrl *cptr)\r\n{\r\nstruct v4l2_queryctrl qctrl;\r\nstruct pvr2_ctl_info *info;\r\nqctrl.id = cptr->info->v4l_id;\r\ncx2341x_ctrl_query(&cptr->hdw->enc_ctl_state,&qctrl);\r\ninfo = (struct pvr2_ctl_info *)(cptr->info);\r\nif (qctrl.flags & V4L2_CTRL_FLAG_READ_ONLY) {\r\nif (info->set_value) {\r\ninfo->set_value = NULL;\r\n}\r\n} else {\r\nif (!(info->set_value)) {\r\ninfo->set_value = ctrl_cx2341x_set;\r\n}\r\n}\r\nreturn qctrl.flags;\r\n}\r\nstatic int ctrl_streamingenabled_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\n*vp = cptr->hdw->state_pipeline_req;\r\nreturn 0;\r\n}\r\nstatic int ctrl_masterstate_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\n*vp = cptr->hdw->master_state;\r\nreturn 0;\r\n}\r\nstatic int ctrl_hsm_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nint result = pvr2_hdw_is_hsm(cptr->hdw);\r\n*vp = PVR2_CVAL_HSM_FULL;\r\nif (result < 0) *vp = PVR2_CVAL_HSM_FAIL;\r\nif (result) *vp = PVR2_CVAL_HSM_HIGH;\r\nreturn 0;\r\n}\r\nstatic int ctrl_stddetect_get(struct pvr2_ctrl *cptr, int *vp)\r\n{\r\n*vp = pvr2_hdw_get_detected_std(cptr->hdw);\r\nreturn 0;\r\n}\r\nstatic int ctrl_stdavail_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\n*vp = cptr->hdw->std_mask_avail;\r\nreturn 0;\r\n}\r\nstatic int ctrl_stdavail_set(struct pvr2_ctrl *cptr,int m,int v)\r\n{\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nv4l2_std_id ns;\r\nns = hdw->std_mask_avail;\r\nns = (ns & ~m) | (v & m);\r\nif (ns == hdw->std_mask_avail) return 0;\r\nhdw->std_mask_avail = ns;\r\nhdw->std_info_cur.def.type_bitmask.valid_bits = hdw->std_mask_avail;\r\nreturn 0;\r\n}\r\nstatic int ctrl_std_val_to_sym(struct pvr2_ctrl *cptr,int msk,int val,\r\nchar *bufPtr,unsigned int bufSize,\r\nunsigned int *len)\r\n{\r\n*len = pvr2_std_id_to_str(bufPtr,bufSize,msk & val);\r\nreturn 0;\r\n}\r\nstatic int ctrl_std_sym_to_val(struct pvr2_ctrl *cptr,\r\nconst char *bufPtr,unsigned int bufSize,\r\nint *mskp,int *valp)\r\n{\r\nint ret;\r\nv4l2_std_id id;\r\nret = pvr2_std_str_to_id(&id,bufPtr,bufSize);\r\nif (ret < 0) return ret;\r\nif (mskp) *mskp = id;\r\nif (valp) *valp = id;\r\nreturn 0;\r\n}\r\nstatic int ctrl_stdcur_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\n*vp = cptr->hdw->std_mask_cur;\r\nreturn 0;\r\n}\r\nstatic int ctrl_stdcur_set(struct pvr2_ctrl *cptr,int m,int v)\r\n{\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\nv4l2_std_id ns;\r\nns = hdw->std_mask_cur;\r\nns = (ns & ~m) | (v & m);\r\nif (ns == hdw->std_mask_cur) return 0;\r\nhdw->std_mask_cur = ns;\r\nhdw->std_dirty = !0;\r\nreturn 0;\r\n}\r\nstatic int ctrl_stdcur_is_dirty(struct pvr2_ctrl *cptr)\r\n{\r\nreturn cptr->hdw->std_dirty != 0;\r\n}\r\nstatic void ctrl_stdcur_clear_dirty(struct pvr2_ctrl *cptr)\r\n{\r\ncptr->hdw->std_dirty = 0;\r\n}\r\nstatic int ctrl_signal_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\npvr2_hdw_status_poll(hdw);\r\n*vp = hdw->tuner_signal_info.signal;\r\nreturn 0;\r\n}\r\nstatic int ctrl_audio_modes_present_get(struct pvr2_ctrl *cptr,int *vp)\r\n{\r\nint val = 0;\r\nunsigned int subchan;\r\nstruct pvr2_hdw *hdw = cptr->hdw;\r\npvr2_hdw_status_poll(hdw);\r\nsubchan = hdw->tuner_signal_info.rxsubchans;\r\nif (subchan & V4L2_TUNER_SUB_MONO) {\r\nval |= (1 << V4L2_TUNER_MODE_MONO);\r\n}\r\nif (subchan & V4L2_TUNER_SUB_STEREO) {\r\nval |= (1 << V4L2_TUNER_MODE_STEREO);\r\n}\r\nif (subchan & V4L2_TUNER_SUB_LANG1) {\r\nval |= (1 << V4L2_TUNER_MODE_LANG1);\r\n}\r\nif (subchan & V4L2_TUNER_SUB_LANG2) {\r\nval |= (1 << V4L2_TUNER_MODE_LANG2);\r\n}\r\n*vp = val;\r\nreturn 0;\r\n}\r\nconst char *pvr2_config_get_name(enum pvr2_config cfg)\r\n{\r\nswitch (cfg) {\r\ncase pvr2_config_empty: return "empty";\r\ncase pvr2_config_mpeg: return "mpeg";\r\ncase pvr2_config_vbi: return "vbi";\r\ncase pvr2_config_pcm: return "pcm";\r\ncase pvr2_config_rawvideo: return "raw video";\r\n}\r\nreturn "<unknown>";\r\n}\r\nstruct usb_device *pvr2_hdw_get_dev(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->usb_dev;\r\n}\r\nunsigned long pvr2_hdw_get_sn(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->serial_number;\r\n}\r\nconst char *pvr2_hdw_get_bus_info(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->bus_info;\r\n}\r\nconst char *pvr2_hdw_get_device_identifier(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->identifier;\r\n}\r\nunsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->freqSelector ? hdw->freqValTelevision : hdw->freqValRadio;\r\n}\r\nstatic void pvr2_hdw_set_cur_freq(struct pvr2_hdw *hdw,unsigned long val)\r\n{\r\nif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\r\nif (hdw->freqSelector) {\r\nhdw->freqSelector = 0;\r\nhdw->freqDirty = !0;\r\n}\r\nif (hdw->freqValRadio != val) {\r\nhdw->freqValRadio = val;\r\nhdw->freqSlotRadio = 0;\r\nhdw->freqDirty = !0;\r\n}\r\n} else {\r\nif (!(hdw->freqSelector)) {\r\nhdw->freqSelector = 1;\r\nhdw->freqDirty = !0;\r\n}\r\nif (hdw->freqValTelevision != val) {\r\nhdw->freqValTelevision = val;\r\nhdw->freqSlotTelevision = 0;\r\nhdw->freqDirty = !0;\r\n}\r\n}\r\n}\r\nint pvr2_hdw_get_unit_number(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->unit_number;\r\n}\r\nstatic int pvr2_locate_firmware(struct pvr2_hdw *hdw,\r\nconst struct firmware **fw_entry,\r\nconst char *fwtypename,\r\nunsigned int fwcount,\r\nconst char *fwnames[])\r\n{\r\nunsigned int idx;\r\nint ret = -EINVAL;\r\nfor (idx = 0; idx < fwcount; idx++) {\r\nret = request_firmware(fw_entry,\r\nfwnames[idx],\r\n&hdw->usb_dev->dev);\r\nif (!ret) {\r\ntrace_firmware("Located %s firmware: %s;"\r\n" uploading...",\r\nfwtypename,\r\nfwnames[idx]);\r\nreturn idx;\r\n}\r\nif (ret == -ENOENT) continue;\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"request_firmware fatal error with code=%d",ret);\r\nreturn ret;\r\n}\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"***WARNING***"\r\n" Device %s firmware"\r\n" seems to be missing.",\r\nfwtypename);\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Did you install the pvrusb2 firmware files"\r\n" in their proper location?");\r\nif (fwcount == 1) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"request_firmware unable to locate %s file %s",\r\nfwtypename,fwnames[0]);\r\n} else {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"request_firmware unable to locate"\r\n" one of the following %s files:",\r\nfwtypename);\r\nfor (idx = 0; idx < fwcount; idx++) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"request_firmware: Failed to find %s",\r\nfwnames[idx]);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int pvr2_upload_firmware1(struct pvr2_hdw *hdw)\r\n{\r\nconst struct firmware *fw_entry = NULL;\r\nvoid *fw_ptr;\r\nunsigned int pipe;\r\nunsigned int fwsize;\r\nint ret;\r\nu16 address;\r\nif (!hdw->hdw_desc->fx2_firmware.cnt) {\r\nhdw->fw1_state = FW1_STATE_OK;\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Connected device type defines"\r\n" no firmware to upload; ignoring firmware");\r\nreturn -ENOTTY;\r\n}\r\nhdw->fw1_state = FW1_STATE_FAILED;\r\ntrace_firmware("pvr2_upload_firmware1");\r\nret = pvr2_locate_firmware(hdw,&fw_entry,"fx2 controller",\r\nhdw->hdw_desc->fx2_firmware.cnt,\r\nhdw->hdw_desc->fx2_firmware.lst);\r\nif (ret < 0) {\r\nif (ret == -ENOENT) hdw->fw1_state = FW1_STATE_MISSING;\r\nreturn ret;\r\n}\r\nusb_clear_halt(hdw->usb_dev, usb_sndbulkpipe(hdw->usb_dev, 0 & 0x7f));\r\npipe = usb_sndctrlpipe(hdw->usb_dev, 0);\r\nfwsize = fw_entry->size;\r\nif ((fwsize != 0x2000) &&\r\n(!(hdw->hdw_desc->flag_fx2_16kb && (fwsize == 0x4000)))) {\r\nif (hdw->hdw_desc->flag_fx2_16kb) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Wrong fx2 firmware size"\r\n" (expected 8192 or 16384, got %u)",\r\nfwsize);\r\n} else {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Wrong fx2 firmware size"\r\n" (expected 8192, got %u)",\r\nfwsize);\r\n}\r\nrelease_firmware(fw_entry);\r\nreturn -ENOMEM;\r\n}\r\nfw_ptr = kmalloc(0x800, GFP_KERNEL);\r\nif (fw_ptr == NULL){\r\nrelease_firmware(fw_entry);\r\nreturn -ENOMEM;\r\n}\r\npvr2_hdw_cpureset_assert(hdw,1);\r\nret = 0;\r\nfor (address = 0; address < fwsize; address += 0x800) {\r\nmemcpy(fw_ptr, fw_entry->data + address, 0x800);\r\nret += usb_control_msg(hdw->usb_dev, pipe, 0xa0, 0x40, address,\r\n0, fw_ptr, 0x800, HZ);\r\n}\r\ntrace_firmware("Upload done, releasing device's CPU");\r\npvr2_hdw_cpureset_assert(hdw,0);\r\nkfree(fw_ptr);\r\nrelease_firmware(fw_entry);\r\ntrace_firmware("Upload done (%d bytes sent)",ret);\r\nif (ret == fwsize) {\r\nhdw->fw1_state = FW1_STATE_RELOAD;\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nint pvr2_upload_firmware2(struct pvr2_hdw *hdw)\r\n{\r\nconst struct firmware *fw_entry = NULL;\r\nvoid *fw_ptr;\r\nunsigned int pipe, fw_len, fw_done, bcnt, icnt;\r\nint actual_length;\r\nint ret = 0;\r\nint fwidx;\r\nstatic const char *fw_files[] = {\r\nCX2341X_FIRM_ENC_FILENAME,\r\n};\r\nif (hdw->hdw_desc->flag_skip_cx23416_firmware) {\r\nreturn 0;\r\n}\r\ntrace_firmware("pvr2_upload_firmware2");\r\nret = pvr2_locate_firmware(hdw,&fw_entry,"encoder",\r\nARRAY_SIZE(fw_files), fw_files);\r\nif (ret < 0) return ret;\r\nfwidx = ret;\r\nret = 0;\r\nhdw->enc_cur_valid = 0;\r\ndel_timer_sync(&hdw->encoder_run_timer);\r\nif (hdw->state_encoder_runok) {\r\nhdw->state_encoder_runok = 0;\r\ntrace_stbit("state_encoder_runok",hdw->state_encoder_runok);\r\n}\r\nret |= pvr2_write_register(hdw, 0x0048, 0xffffffff);\r\nret |= pvr2_hdw_gpio_chg_dir(hdw,0xffffffff,0x00000088);\r\nret |= pvr2_hdw_gpio_chg_out(hdw,0xffffffff,0x00000008);\r\nret |= pvr2_hdw_cmd_deep_reset(hdw);\r\nret |= pvr2_write_register(hdw, 0xa064, 0x00000000);\r\nret |= pvr2_hdw_gpio_chg_dir(hdw,0xffffffff,0x00000408);\r\nret |= pvr2_hdw_gpio_chg_out(hdw,0xffffffff,0x00000008);\r\nret |= pvr2_write_register(hdw, 0x9058, 0xffffffed);\r\nret |= pvr2_write_register(hdw, 0x9054, 0xfffffffd);\r\nret |= pvr2_write_register(hdw, 0x07f8, 0x80000800);\r\nret |= pvr2_write_register(hdw, 0x07fc, 0x0000001a);\r\nret |= pvr2_write_register(hdw, 0x0700, 0x00000000);\r\nret |= pvr2_write_register(hdw, 0xaa00, 0x00000000);\r\nret |= pvr2_write_register(hdw, 0xaa04, 0x00057810);\r\nret |= pvr2_write_register(hdw, 0xaa10, 0x00148500);\r\nret |= pvr2_write_register(hdw, 0xaa18, 0x00840000);\r\nret |= pvr2_issue_simple_cmd(hdw,FX2CMD_FWPOST1);\r\nret |= pvr2_issue_simple_cmd(hdw,FX2CMD_MEMSEL | (1 << 8) | (0 << 16));\r\nif (ret) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"firmware2 upload prep failed, ret=%d",ret);\r\nrelease_firmware(fw_entry);\r\ngoto done;\r\n}\r\nfw_len = fw_entry->size;\r\nif (fw_len % sizeof(u32)) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"size of %s firmware"\r\n" must be a multiple of %zu bytes",\r\nfw_files[fwidx],sizeof(u32));\r\nrelease_firmware(fw_entry);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nfw_ptr = kmalloc(FIRMWARE_CHUNK_SIZE, GFP_KERNEL);\r\nif (fw_ptr == NULL){\r\nrelease_firmware(fw_entry);\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"failed to allocate memory for firmware2 upload");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\npipe = usb_sndbulkpipe(hdw->usb_dev, PVR2_FIRMWARE_ENDPOINT);\r\nfw_done = 0;\r\nfor (fw_done = 0; fw_done < fw_len;) {\r\nbcnt = fw_len - fw_done;\r\nif (bcnt > FIRMWARE_CHUNK_SIZE) bcnt = FIRMWARE_CHUNK_SIZE;\r\nmemcpy(fw_ptr, fw_entry->data + fw_done, bcnt);\r\nfor (icnt = 0; icnt < bcnt/4 ; icnt++)\r\n((u32 *)fw_ptr)[icnt] = swab32(((u32 *)fw_ptr)[icnt]);\r\nret |= usb_bulk_msg(hdw->usb_dev, pipe, fw_ptr,bcnt,\r\n&actual_length, HZ);\r\nret |= (actual_length != bcnt);\r\nif (ret) break;\r\nfw_done += bcnt;\r\n}\r\ntrace_firmware("upload of %s : %i / %i ",\r\nfw_files[fwidx],fw_done,fw_len);\r\nkfree(fw_ptr);\r\nrelease_firmware(fw_entry);\r\nif (ret) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"firmware2 upload transfer failure");\r\ngoto done;\r\n}\r\nret |= pvr2_write_register(hdw, 0x9054, 0xffffffff);\r\nret |= pvr2_write_register(hdw, 0x9058, 0xffffffe8);\r\nret |= pvr2_issue_simple_cmd(hdw,FX2CMD_MEMSEL | (1 << 8) | (0 << 16));\r\nif (ret) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"firmware2 upload post-proc failure");\r\n}\r\ndone:\r\nif (hdw->hdw_desc->signal_routing_scheme ==\r\nPVR2_ROUTING_SCHEME_GOTVIEW) {\r\npvr2_hdw_gpio_chg_dir(hdw,(1 << 11),~0);\r\n}\r\nreturn ret;\r\n}\r\nstatic const char *pvr2_get_state_name(unsigned int st)\r\n{\r\nif (st < ARRAY_SIZE(pvr2_state_names)) {\r\nreturn pvr2_state_names[st];\r\n}\r\nreturn "???";\r\n}\r\nstatic int pvr2_decoder_enable(struct pvr2_hdw *hdw,int enablefl)\r\n{\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev v4l2 stream=%s",\r\n(enablefl ? "on" : "off"));\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, video, s_stream, enablefl);\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, audio, s_stream, enablefl);\r\nif (hdw->decoder_client_id) {\r\nreturn 0;\r\n}\r\nif (!hdw->flag_decoder_missed) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"WARNING: No decoder present");\r\nhdw->flag_decoder_missed = !0;\r\ntrace_stbit("flag_decoder_missed",\r\nhdw->flag_decoder_missed);\r\n}\r\nreturn -EIO;\r\n}\r\nint pvr2_hdw_get_state(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->master_state;\r\n}\r\nstatic int pvr2_hdw_untrip_unlocked(struct pvr2_hdw *hdw)\r\n{\r\nif (!hdw->flag_tripped) return 0;\r\nhdw->flag_tripped = 0;\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Clearing driver error statuss");\r\nreturn !0;\r\n}\r\nint pvr2_hdw_untrip(struct pvr2_hdw *hdw)\r\n{\r\nint fl;\r\nLOCK_TAKE(hdw->big_lock); do {\r\nfl = pvr2_hdw_untrip_unlocked(hdw);\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\nif (fl) pvr2_hdw_state_sched(hdw);\r\nreturn 0;\r\n}\r\nint pvr2_hdw_get_streaming(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->state_pipeline_req != 0;\r\n}\r\nint pvr2_hdw_set_streaming(struct pvr2_hdw *hdw,int enable_flag)\r\n{\r\nint ret,st;\r\nLOCK_TAKE(hdw->big_lock); do {\r\npvr2_hdw_untrip_unlocked(hdw);\r\nif ((!enable_flag) != !(hdw->state_pipeline_req)) {\r\nhdw->state_pipeline_req = enable_flag != 0;\r\npvr2_trace(PVR2_TRACE_START_STOP,\r\n"/*--TRACE_STREAM--*/ %s",\r\nenable_flag ? "enable" : "disable");\r\n}\r\npvr2_hdw_state_sched(hdw);\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\nif ((ret = pvr2_hdw_wait(hdw,0)) < 0) return ret;\r\nif (enable_flag) {\r\nwhile ((st = hdw->master_state) != PVR2_STATE_RUN) {\r\nif (st != PVR2_STATE_READY) return -EIO;\r\nif ((ret = pvr2_hdw_wait(hdw,st)) < 0) return ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint pvr2_hdw_set_stream_type(struct pvr2_hdw *hdw,enum pvr2_config config)\r\n{\r\nint fl;\r\nLOCK_TAKE(hdw->big_lock);\r\nif ((fl = (hdw->desired_stream_type != config)) != 0) {\r\nhdw->desired_stream_type = config;\r\nhdw->state_pipeline_config = 0;\r\ntrace_stbit("state_pipeline_config",\r\nhdw->state_pipeline_config);\r\npvr2_hdw_state_sched(hdw);\r\n}\r\nLOCK_GIVE(hdw->big_lock);\r\nif (fl) return 0;\r\nreturn pvr2_hdw_wait(hdw,0);\r\n}\r\nstatic int get_default_tuner_type(struct pvr2_hdw *hdw)\r\n{\r\nint unit_number = hdw->unit_number;\r\nint tp = -1;\r\nif ((unit_number >= 0) && (unit_number < PVR_NUM)) {\r\ntp = tuner[unit_number];\r\n}\r\nif (tp < 0) return -EINVAL;\r\nhdw->tuner_type = tp;\r\nhdw->tuner_updated = !0;\r\nreturn 0;\r\n}\r\nstatic v4l2_std_id get_default_standard(struct pvr2_hdw *hdw)\r\n{\r\nint unit_number = hdw->unit_number;\r\nint tp = 0;\r\nif ((unit_number >= 0) && (unit_number < PVR_NUM)) {\r\ntp = video_std[unit_number];\r\nif (tp) return tp;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int get_default_error_tolerance(struct pvr2_hdw *hdw)\r\n{\r\nint unit_number = hdw->unit_number;\r\nint tp = 0;\r\nif ((unit_number >= 0) && (unit_number < PVR_NUM)) {\r\ntp = tolerance[unit_number];\r\n}\r\nreturn tp;\r\n}\r\nstatic int pvr2_hdw_check_firmware(struct pvr2_hdw *hdw)\r\n{\r\nint result;\r\nLOCK_TAKE(hdw->ctl_lock); do {\r\nhdw->cmd_buffer[0] = FX2CMD_GET_EEPROM_ADDR;\r\nresult = pvr2_send_request_ex(hdw,HZ*1,!0,\r\nhdw->cmd_buffer,1,\r\nhdw->cmd_buffer,1);\r\nif (result < 0) break;\r\n} while(0); LOCK_GIVE(hdw->ctl_lock);\r\nif (result) {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Probe of device endpoint 1 result status %d",\r\nresult);\r\n} else {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Probe of device endpoint 1 succeeded");\r\n}\r\nreturn result == 0;\r\n}\r\nstatic void pvr2_hdw_setup_std(struct pvr2_hdw *hdw)\r\n{\r\nchar buf[40];\r\nunsigned int bcnt;\r\nv4l2_std_id std1,std2,std3;\r\nstd1 = get_default_standard(hdw);\r\nstd3 = std1 ? 0 : hdw->hdw_desc->default_std_mask;\r\nbcnt = pvr2_std_id_to_str(buf,sizeof(buf),hdw->std_mask_eeprom);\r\npvr2_trace(PVR2_TRACE_STD,\r\n"Supported video standard(s) reported available"\r\n" in hardware: %.*s",\r\nbcnt,buf);\r\nhdw->std_mask_avail = hdw->std_mask_eeprom;\r\nstd2 = (std1|std3) & ~hdw->std_mask_avail;\r\nif (std2) {\r\nbcnt = pvr2_std_id_to_str(buf,sizeof(buf),std2);\r\npvr2_trace(PVR2_TRACE_STD,\r\n"Expanding supported video standards"\r\n" to include: %.*s",\r\nbcnt,buf);\r\nhdw->std_mask_avail |= std2;\r\n}\r\nhdw->std_info_cur.def.type_bitmask.valid_bits = hdw->std_mask_avail;\r\nif (std1) {\r\nbcnt = pvr2_std_id_to_str(buf,sizeof(buf),std1);\r\npvr2_trace(PVR2_TRACE_STD,\r\n"Initial video standard forced to %.*s",\r\nbcnt,buf);\r\nhdw->std_mask_cur = std1;\r\nhdw->std_dirty = !0;\r\nreturn;\r\n}\r\nif (std3) {\r\nbcnt = pvr2_std_id_to_str(buf,sizeof(buf),std3);\r\npvr2_trace(PVR2_TRACE_STD,\r\n"Initial video standard"\r\n" (determined by device type): %.*s",bcnt,buf);\r\nhdw->std_mask_cur = std3;\r\nhdw->std_dirty = !0;\r\nreturn;\r\n}\r\n{\r\nunsigned int idx;\r\nfor (idx = 0; idx < ARRAY_SIZE(std_eeprom_maps); idx++) {\r\nif (std_eeprom_maps[idx].msk ?\r\n((std_eeprom_maps[idx].pat ^\r\nhdw->std_mask_eeprom) &\r\nstd_eeprom_maps[idx].msk) :\r\n(std_eeprom_maps[idx].pat !=\r\nhdw->std_mask_eeprom)) continue;\r\nbcnt = pvr2_std_id_to_str(buf,sizeof(buf),\r\nstd_eeprom_maps[idx].std);\r\npvr2_trace(PVR2_TRACE_STD,\r\n"Initial video standard guessed as %.*s",\r\nbcnt,buf);\r\nhdw->std_mask_cur = std_eeprom_maps[idx].std;\r\nhdw->std_dirty = !0;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic unsigned int pvr2_copy_i2c_addr_list(\r\nunsigned short *dst, const unsigned char *src,\r\nunsigned int dst_max)\r\n{\r\nunsigned int cnt = 0;\r\nif (!src) return 0;\r\nwhile (src[cnt] && (cnt + 1) < dst_max) {\r\ndst[cnt] = src[cnt];\r\ncnt++;\r\n}\r\ndst[cnt] = I2C_CLIENT_END;\r\nreturn cnt;\r\n}\r\nstatic void pvr2_hdw_cx25840_vbi_hack(struct pvr2_hdw *hdw)\r\n{\r\nstruct v4l2_format fmt;\r\nif (hdw->decoder_client_id != PVR2_CLIENT_ID_CX25840) {\r\nreturn;\r\n}\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Module ID %u:"\r\n" Executing cx25840 VBI hack",\r\nhdw->decoder_client_id);\r\nmemset(&fmt, 0, sizeof(fmt));\r\nfmt.type = V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\r\nfmt.fmt.sliced.service_lines[0][21] = V4L2_SLICED_CAPTION_525;\r\nfmt.fmt.sliced.service_lines[1][21] = V4L2_SLICED_CAPTION_525;\r\nv4l2_device_call_all(&hdw->v4l2_dev, hdw->decoder_client_id,\r\nvbi, s_sliced_fmt, &fmt.fmt.sliced);\r\n}\r\nstatic int pvr2_hdw_load_subdev(struct pvr2_hdw *hdw,\r\nconst struct pvr2_device_client_desc *cd)\r\n{\r\nconst char *fname;\r\nunsigned char mid;\r\nstruct v4l2_subdev *sd;\r\nunsigned int i2ccnt;\r\nconst unsigned char *p;\r\nunsigned short i2caddr[25];\r\nmid = cd->module_id;\r\nfname = (mid < ARRAY_SIZE(module_names)) ? module_names[mid] : NULL;\r\nif (!fname) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Module ID %u for device %s has no name?"\r\n" The driver might have a configuration problem.",\r\nmid,\r\nhdw->hdw_desc->description);\r\nreturn -EINVAL;\r\n}\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Module ID %u (%s) for device %s being loaded...",\r\nmid, fname,\r\nhdw->hdw_desc->description);\r\ni2ccnt = pvr2_copy_i2c_addr_list(i2caddr, cd->i2c_address_list,\r\nARRAY_SIZE(i2caddr));\r\nif (!i2ccnt && ((p = (mid < ARRAY_SIZE(module_i2c_addresses)) ?\r\nmodule_i2c_addresses[mid] : NULL) != NULL)) {\r\ni2ccnt = pvr2_copy_i2c_addr_list(i2caddr, p,\r\nARRAY_SIZE(i2caddr));\r\nif (i2ccnt) {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Module ID %u:"\r\n" Using default i2c address list",\r\nmid);\r\n}\r\n}\r\nif (!i2ccnt) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Module ID %u (%s) for device %s:"\r\n" No i2c addresses."\r\n" The driver might have a configuration problem.",\r\nmid, fname, hdw->hdw_desc->description);\r\nreturn -EINVAL;\r\n}\r\nif (i2ccnt == 1) {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Module ID %u:"\r\n" Setting up with specified i2c address 0x%x",\r\nmid, i2caddr[0]);\r\nsd = v4l2_i2c_new_subdev(&hdw->v4l2_dev, &hdw->i2c_adap,\r\nfname, i2caddr[0], NULL);\r\n} else {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Module ID %u:"\r\n" Setting up with address probe list",\r\nmid);\r\nsd = v4l2_i2c_new_subdev(&hdw->v4l2_dev, &hdw->i2c_adap,\r\nfname, 0, i2caddr);\r\n}\r\nif (!sd) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Module ID %u (%s) for device %s failed to load."\r\n" Possible missing sub-device kernel module or"\r\n" initialization failure within module.",\r\nmid, fname, hdw->hdw_desc->description);\r\nreturn -EIO;\r\n}\r\nsd->grp_id = mid;\r\npvr2_trace(PVR2_TRACE_INFO, "Attached sub-driver %s", fname);\r\nswitch (mid) {\r\ncase PVR2_CLIENT_ID_CX25840:\r\ncase PVR2_CLIENT_ID_SAA7115:\r\nhdw->decoder_client_id = mid;\r\nbreak;\r\ndefault: break;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pvr2_hdw_load_modules(struct pvr2_hdw *hdw)\r\n{\r\nunsigned int idx;\r\nconst struct pvr2_string_table *cm;\r\nconst struct pvr2_device_client_table *ct;\r\nint okFl = !0;\r\ncm = &hdw->hdw_desc->client_modules;\r\nfor (idx = 0; idx < cm->cnt; idx++) {\r\nrequest_module(cm->lst[idx]);\r\n}\r\nct = &hdw->hdw_desc->client_table;\r\nfor (idx = 0; idx < ct->cnt; idx++) {\r\nif (pvr2_hdw_load_subdev(hdw, &ct->lst[idx]) < 0) okFl = 0;\r\n}\r\nif (!okFl) {\r\nhdw->flag_modulefail = !0;\r\npvr2_hdw_render_useless(hdw);\r\n}\r\n}\r\nstatic void pvr2_hdw_setup_low(struct pvr2_hdw *hdw)\r\n{\r\nint ret;\r\nunsigned int idx;\r\nstruct pvr2_ctrl *cptr;\r\nint reloadFl = 0;\r\nif (hdw->hdw_desc->fx2_firmware.cnt) {\r\nif (!reloadFl) {\r\nreloadFl =\r\n(hdw->usb_intf->cur_altsetting->desc.bNumEndpoints\r\n== 0);\r\nif (reloadFl) {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"USB endpoint config looks strange"\r\n"; possibly firmware needs to be"\r\n" loaded");\r\n}\r\n}\r\nif (!reloadFl) {\r\nreloadFl = !pvr2_hdw_check_firmware(hdw);\r\nif (reloadFl) {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Check for FX2 firmware failed"\r\n"; possibly firmware needs to be"\r\n" loaded");\r\n}\r\n}\r\nif (reloadFl) {\r\nif (pvr2_upload_firmware1(hdw) != 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Failure uploading firmware1");\r\n}\r\nreturn;\r\n}\r\n}\r\nhdw->fw1_state = FW1_STATE_OK;\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\nhdw->force_dirty = !0;\r\nif (!hdw->hdw_desc->flag_no_powerup) {\r\npvr2_hdw_cmd_powerup(hdw);\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\n}\r\nif (hdw->ir_scheme_active == PVR2_IR_SCHEME_ZILOG) {\r\npvr2_issue_simple_cmd(hdw,\r\nFX2CMD_HCW_ZILOG_RESET |\r\n(1 << 8) |\r\n((0) << 16));\r\n}\r\npvr2_i2c_core_init(hdw);\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\npvr2_hdw_load_modules(hdw);\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, core, load_fw);\r\nfor (idx = 0; idx < CTRLDEF_COUNT; idx++) {\r\ncptr = hdw->controls + idx;\r\nif (cptr->info->skip_init) continue;\r\nif (!cptr->info->set_value) continue;\r\ncptr->info->set_value(cptr,~0,cptr->info->default_value);\r\n}\r\npvr2_hdw_cx25840_vbi_hack(hdw);\r\nhdw->freqValTelevision = default_tv_freq;\r\nhdw->freqValRadio = default_radio_freq;\r\nif (hdw->hdw_desc->flag_has_hauppauge_rom) {\r\nret = pvr2_hdw_get_eeprom_addr(hdw);\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\nif (ret < 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Unable to determine location of eeprom,"\r\n" skipping");\r\n} else {\r\nhdw->eeprom_addr = ret;\r\npvr2_eeprom_analyze(hdw);\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\n}\r\n} else {\r\nhdw->tuner_type = hdw->hdw_desc->default_tuner_type;\r\nhdw->tuner_updated = !0;\r\nhdw->std_mask_eeprom = V4L2_STD_ALL;\r\n}\r\nif (hdw->serial_number) {\r\nidx = scnprintf(hdw->identifier, sizeof(hdw->identifier) - 1,\r\n"sn-%lu", hdw->serial_number);\r\n} else if (hdw->unit_number >= 0) {\r\nidx = scnprintf(hdw->identifier, sizeof(hdw->identifier) - 1,\r\n"unit-%c",\r\nhdw->unit_number + 'a');\r\n} else {\r\nidx = scnprintf(hdw->identifier, sizeof(hdw->identifier) - 1,\r\n"unit-??");\r\n}\r\nhdw->identifier[idx] = 0;\r\npvr2_hdw_setup_std(hdw);\r\nif (!get_default_tuner_type(hdw)) {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"pvr2_hdw_setup: Tuner type overridden to %d",\r\nhdw->tuner_type);\r\n}\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\nif (hdw->hdw_desc->signal_routing_scheme ==\r\nPVR2_ROUTING_SCHEME_GOTVIEW) {\r\npvr2_hdw_gpio_chg_dir(hdw,(1 << 11),~0);\r\n}\r\npvr2_hdw_commit_setup(hdw);\r\nhdw->vid_stream = pvr2_stream_create();\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"pvr2_hdw_setup: video stream is %p",hdw->vid_stream);\r\nif (hdw->vid_stream) {\r\nidx = get_default_error_tolerance(hdw);\r\nif (idx) {\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"pvr2_hdw_setup: video stream %p"\r\n" setting tolerance %u",\r\nhdw->vid_stream,idx);\r\n}\r\npvr2_stream_setup(hdw->vid_stream,hdw->usb_dev,\r\nPVR2_VID_ENDPOINT,idx);\r\n}\r\nif (!pvr2_hdw_dev_ok(hdw)) return;\r\nhdw->flag_init_ok = !0;\r\npvr2_hdw_state_sched(hdw);\r\n}\r\nstatic void pvr2_hdw_setup(struct pvr2_hdw *hdw)\r\n{\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_hdw_setup(hdw=%p) begin",hdw);\r\ndo {\r\npvr2_hdw_setup_low(hdw);\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"pvr2_hdw_setup(hdw=%p) done, ok=%d init_ok=%d",\r\nhdw,pvr2_hdw_dev_ok(hdw),hdw->flag_init_ok);\r\nif (pvr2_hdw_dev_ok(hdw)) {\r\nif (hdw->flag_init_ok) {\r\npvr2_trace(\r\nPVR2_TRACE_INFO,\r\n"Device initialization"\r\n" completed successfully.");\r\nbreak;\r\n}\r\nif (hdw->fw1_state == FW1_STATE_RELOAD) {\r\npvr2_trace(\r\nPVR2_TRACE_INFO,\r\n"Device microcontroller firmware"\r\n" (re)loaded; it should now reset"\r\n" and reconnect.");\r\nbreak;\r\n}\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Device initialization was not successful.");\r\nif (hdw->fw1_state == FW1_STATE_MISSING) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Giving up since device"\r\n" microcontroller firmware"\r\n" appears to be missing.");\r\nbreak;\r\n}\r\n}\r\nif (hdw->flag_modulefail) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"***WARNING*** pvrusb2 driver initialization"\r\n" failed due to the failure of one or more"\r\n" sub-device kernel modules.");\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"You need to resolve the failing condition"\r\n" before this driver can function. There"\r\n" should be some earlier messages giving more"\r\n" information about the problem.");\r\nbreak;\r\n}\r\nif (procreload) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Attempting pvrusb2 recovery by reloading"\r\n" primary firmware.");\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"If this works, device should disconnect"\r\n" and reconnect in a sane state.");\r\nhdw->fw1_state = FW1_STATE_UNKNOWN;\r\npvr2_upload_firmware1(hdw);\r\n} else {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"***WARNING*** pvrusb2 device hardware"\r\n" appears to be jammed"\r\n" and I can't clear it.");\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"You might need to power cycle"\r\n" the pvrusb2 device"\r\n" in order to recover.");\r\n}\r\n} while (0);\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_hdw_setup(hdw=%p) end",hdw);\r\n}\r\nint pvr2_hdw_initialize(struct pvr2_hdw *hdw,\r\nvoid (*callback_func)(void *),\r\nvoid *callback_data)\r\n{\r\nLOCK_TAKE(hdw->big_lock); do {\r\nif (hdw->flag_disconnected) {\r\nbreak;\r\n}\r\nhdw->state_data = callback_data;\r\nhdw->state_func = callback_func;\r\npvr2_hdw_setup(hdw);\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\nreturn hdw->flag_init_ok;\r\n}\r\nstruct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf,\r\nconst struct usb_device_id *devid)\r\n{\r\nunsigned int idx,cnt1,cnt2,m;\r\nstruct pvr2_hdw *hdw = NULL;\r\nint valid_std_mask;\r\nstruct pvr2_ctrl *cptr;\r\nstruct usb_device *usb_dev;\r\nconst struct pvr2_device_desc *hdw_desc;\r\n__u8 ifnum;\r\nstruct v4l2_queryctrl qctrl;\r\nstruct pvr2_ctl_info *ciptr;\r\nusb_dev = interface_to_usbdev(intf);\r\nhdw_desc = (const struct pvr2_device_desc *)(devid->driver_info);\r\nif (hdw_desc == NULL) {\r\npvr2_trace(PVR2_TRACE_INIT, "pvr2_hdw_create:"\r\n" No device description pointer,"\r\n" unable to continue.");\r\npvr2_trace(PVR2_TRACE_INIT, "If you have a new device type,"\r\n" please contact Mike Isely <isely@pobox.com>"\r\n" to get it included in the driver\n");\r\ngoto fail;\r\n}\r\nhdw = kzalloc(sizeof(*hdw),GFP_KERNEL);\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_hdw_create: hdw=%p, type \"%s\"",\r\nhdw,hdw_desc->description);\r\npvr2_trace(PVR2_TRACE_INFO, "Hardware description: %s",\r\nhdw_desc->description);\r\nif (hdw_desc->flag_is_experimental) {\r\npvr2_trace(PVR2_TRACE_INFO, "**********");\r\npvr2_trace(PVR2_TRACE_INFO,\r\n"WARNING: Support for this device (%s) is"\r\n" experimental.", hdw_desc->description);\r\npvr2_trace(PVR2_TRACE_INFO,\r\n"Important functionality might not be"\r\n" entirely working.");\r\npvr2_trace(PVR2_TRACE_INFO,\r\n"Please consider contacting the driver author to"\r\n" help with further stabilization of the driver.");\r\npvr2_trace(PVR2_TRACE_INFO, "**********");\r\n}\r\nif (!hdw) goto fail;\r\ninit_timer(&hdw->quiescent_timer);\r\nhdw->quiescent_timer.data = (unsigned long)hdw;\r\nhdw->quiescent_timer.function = pvr2_hdw_quiescent_timeout;\r\ninit_timer(&hdw->decoder_stabilization_timer);\r\nhdw->decoder_stabilization_timer.data = (unsigned long)hdw;\r\nhdw->decoder_stabilization_timer.function =\r\npvr2_hdw_decoder_stabilization_timeout;\r\ninit_timer(&hdw->encoder_wait_timer);\r\nhdw->encoder_wait_timer.data = (unsigned long)hdw;\r\nhdw->encoder_wait_timer.function = pvr2_hdw_encoder_wait_timeout;\r\ninit_timer(&hdw->encoder_run_timer);\r\nhdw->encoder_run_timer.data = (unsigned long)hdw;\r\nhdw->encoder_run_timer.function = pvr2_hdw_encoder_run_timeout;\r\nhdw->master_state = PVR2_STATE_DEAD;\r\ninit_waitqueue_head(&hdw->state_wait_data);\r\nhdw->tuner_signal_stale = !0;\r\ncx2341x_fill_defaults(&hdw->enc_ctl_state);\r\nm = 0;\r\nif (hdw_desc->flag_has_analogtuner) m |= 1 << PVR2_CVAL_INPUT_TV;\r\nif (hdw_desc->digital_control_scheme != PVR2_DIGITAL_SCHEME_NONE) {\r\nm |= 1 << PVR2_CVAL_INPUT_DTV;\r\n}\r\nif (hdw_desc->flag_has_svideo) m |= 1 << PVR2_CVAL_INPUT_SVIDEO;\r\nif (hdw_desc->flag_has_composite) m |= 1 << PVR2_CVAL_INPUT_COMPOSITE;\r\nif (hdw_desc->flag_has_fmradio) m |= 1 << PVR2_CVAL_INPUT_RADIO;\r\nhdw->input_avail_mask = m;\r\nhdw->input_allowed_mask = hdw->input_avail_mask;\r\nif (!(hdw->input_avail_mask & (1 << PVR2_CVAL_INPUT_DTV))) {\r\nhdw->pathway_state = PVR2_PATHWAY_ANALOG;\r\n} else if (!(hdw->input_avail_mask & (1 << PVR2_CVAL_INPUT_TV))) {\r\nhdw->pathway_state = PVR2_PATHWAY_DIGITAL;\r\n}\r\nhdw->control_cnt = CTRLDEF_COUNT;\r\nhdw->control_cnt += MPEGDEF_COUNT;\r\nhdw->controls = kzalloc(sizeof(struct pvr2_ctrl) * hdw->control_cnt,\r\nGFP_KERNEL);\r\nif (!hdw->controls) goto fail;\r\nhdw->hdw_desc = hdw_desc;\r\nhdw->ir_scheme_active = hdw->hdw_desc->ir_scheme;\r\nfor (idx = 0; idx < hdw->control_cnt; idx++) {\r\ncptr = hdw->controls + idx;\r\ncptr->hdw = hdw;\r\n}\r\nfor (idx = 0; idx < 32; idx++) {\r\nhdw->std_mask_ptrs[idx] = hdw->std_mask_names[idx];\r\n}\r\nfor (idx = 0; idx < CTRLDEF_COUNT; idx++) {\r\ncptr = hdw->controls + idx;\r\ncptr->info = control_defs+idx;\r\n}\r\nm = hdw->input_avail_mask;\r\nif (m) for (idx = 0; idx < (sizeof(m) << 3); idx++) {\r\nif (!((1 << idx) & m)) continue;\r\nhdw->input_val = idx;\r\nbreak;\r\n}\r\nhdw->mpeg_ctrl_info = kcalloc(MPEGDEF_COUNT,\r\nsizeof(*(hdw->mpeg_ctrl_info)),\r\nGFP_KERNEL);\r\nif (!hdw->mpeg_ctrl_info) goto fail;\r\nfor (idx = 0; idx < MPEGDEF_COUNT; idx++) {\r\ncptr = hdw->controls + idx + CTRLDEF_COUNT;\r\nciptr = &(hdw->mpeg_ctrl_info[idx].info);\r\nciptr->desc = hdw->mpeg_ctrl_info[idx].desc;\r\nciptr->name = mpeg_ids[idx].strid;\r\nciptr->v4l_id = mpeg_ids[idx].id;\r\nciptr->skip_init = !0;\r\nciptr->get_value = ctrl_cx2341x_get;\r\nciptr->get_v4lflags = ctrl_cx2341x_getv4lflags;\r\nciptr->is_dirty = ctrl_cx2341x_is_dirty;\r\nif (!idx) ciptr->clear_dirty = ctrl_cx2341x_clear_dirty;\r\nqctrl.id = ciptr->v4l_id;\r\ncx2341x_ctrl_query(&hdw->enc_ctl_state,&qctrl);\r\nif (!(qctrl.flags & V4L2_CTRL_FLAG_READ_ONLY)) {\r\nciptr->set_value = ctrl_cx2341x_set;\r\n}\r\nstrncpy(hdw->mpeg_ctrl_info[idx].desc,qctrl.name,\r\nPVR2_CTLD_INFO_DESC_SIZE);\r\nhdw->mpeg_ctrl_info[idx].desc[PVR2_CTLD_INFO_DESC_SIZE-1] = 0;\r\nciptr->default_value = qctrl.default_value;\r\nswitch (qctrl.type) {\r\ndefault:\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nciptr->type = pvr2_ctl_int;\r\nciptr->def.type_int.min_value = qctrl.minimum;\r\nciptr->def.type_int.max_value = qctrl.maximum;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nciptr->type = pvr2_ctl_bool;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_MENU:\r\nciptr->type = pvr2_ctl_enum;\r\nciptr->def.type_enum.value_names =\r\ncx2341x_ctrl_get_menu(&hdw->enc_ctl_state,\r\nciptr->v4l_id);\r\nfor (cnt1 = 0;\r\nciptr->def.type_enum.value_names[cnt1] != NULL;\r\ncnt1++) { }\r\nciptr->def.type_enum.count = cnt1;\r\nbreak;\r\n}\r\ncptr->info = ciptr;\r\n}\r\nvalid_std_mask = pvr2_std_get_usable();\r\nfor (idx = 0; idx < 32; idx++) {\r\nif (!(valid_std_mask & (1 << idx))) continue;\r\ncnt1 = pvr2_std_id_to_str(\r\nhdw->std_mask_names[idx],\r\nsizeof(hdw->std_mask_names[idx])-1,\r\n1 << idx);\r\nhdw->std_mask_names[idx][cnt1] = 0;\r\n}\r\ncptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDAVAIL);\r\nif (cptr) {\r\nmemcpy(&hdw->std_info_avail,cptr->info,\r\nsizeof(hdw->std_info_avail));\r\ncptr->info = &hdw->std_info_avail;\r\nhdw->std_info_avail.def.type_bitmask.bit_names =\r\nhdw->std_mask_ptrs;\r\nhdw->std_info_avail.def.type_bitmask.valid_bits =\r\nvalid_std_mask;\r\n}\r\ncptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDCUR);\r\nif (cptr) {\r\nmemcpy(&hdw->std_info_cur,cptr->info,\r\nsizeof(hdw->std_info_cur));\r\ncptr->info = &hdw->std_info_cur;\r\nhdw->std_info_cur.def.type_bitmask.bit_names =\r\nhdw->std_mask_ptrs;\r\nhdw->std_info_cur.def.type_bitmask.valid_bits =\r\nvalid_std_mask;\r\n}\r\ncptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDDETECT);\r\nif (cptr) {\r\nmemcpy(&hdw->std_info_detect,cptr->info,\r\nsizeof(hdw->std_info_detect));\r\ncptr->info = &hdw->std_info_detect;\r\nhdw->std_info_detect.def.type_bitmask.bit_names =\r\nhdw->std_mask_ptrs;\r\nhdw->std_info_detect.def.type_bitmask.valid_bits =\r\nvalid_std_mask;\r\n}\r\nhdw->cropcap_stale = !0;\r\nhdw->eeprom_addr = -1;\r\nhdw->unit_number = -1;\r\nhdw->v4l_minor_number_video = -1;\r\nhdw->v4l_minor_number_vbi = -1;\r\nhdw->v4l_minor_number_radio = -1;\r\nhdw->ctl_write_buffer = kmalloc(PVR2_CTL_BUFFSIZE,GFP_KERNEL);\r\nif (!hdw->ctl_write_buffer) goto fail;\r\nhdw->ctl_read_buffer = kmalloc(PVR2_CTL_BUFFSIZE,GFP_KERNEL);\r\nif (!hdw->ctl_read_buffer) goto fail;\r\nhdw->ctl_write_urb = usb_alloc_urb(0,GFP_KERNEL);\r\nif (!hdw->ctl_write_urb) goto fail;\r\nhdw->ctl_read_urb = usb_alloc_urb(0,GFP_KERNEL);\r\nif (!hdw->ctl_read_urb) goto fail;\r\nif (v4l2_device_register(&intf->dev, &hdw->v4l2_dev) != 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Error registering with v4l core, giving up");\r\ngoto fail;\r\n}\r\nmutex_lock(&pvr2_unit_mtx); do {\r\nfor (idx = 0; idx < PVR_NUM; idx++) {\r\nif (unit_pointers[idx]) continue;\r\nhdw->unit_number = idx;\r\nunit_pointers[idx] = hdw;\r\nbreak;\r\n}\r\n} while (0); mutex_unlock(&pvr2_unit_mtx);\r\ncnt1 = 0;\r\ncnt2 = scnprintf(hdw->name+cnt1,sizeof(hdw->name)-cnt1,"pvrusb2");\r\ncnt1 += cnt2;\r\nif (hdw->unit_number >= 0) {\r\ncnt2 = scnprintf(hdw->name+cnt1,sizeof(hdw->name)-cnt1,"_%c",\r\n('a' + hdw->unit_number));\r\ncnt1 += cnt2;\r\n}\r\nif (cnt1 >= sizeof(hdw->name)) cnt1 = sizeof(hdw->name)-1;\r\nhdw->name[cnt1] = 0;\r\nhdw->workqueue = create_singlethread_workqueue(hdw->name);\r\nINIT_WORK(&hdw->workpoll,pvr2_hdw_worker_poll);\r\npvr2_trace(PVR2_TRACE_INIT,"Driver unit number is %d, name is %s",\r\nhdw->unit_number,hdw->name);\r\nhdw->tuner_type = -1;\r\nhdw->flag_ok = !0;\r\nhdw->usb_intf = intf;\r\nhdw->usb_dev = usb_dev;\r\nusb_make_path(hdw->usb_dev, hdw->bus_info, sizeof(hdw->bus_info));\r\nifnum = hdw->usb_intf->cur_altsetting->desc.bInterfaceNumber;\r\nusb_set_interface(hdw->usb_dev,ifnum,0);\r\nmutex_init(&hdw->ctl_lock_mutex);\r\nmutex_init(&hdw->big_lock_mutex);\r\nreturn hdw;\r\nfail:\r\nif (hdw) {\r\ndel_timer_sync(&hdw->quiescent_timer);\r\ndel_timer_sync(&hdw->decoder_stabilization_timer);\r\ndel_timer_sync(&hdw->encoder_run_timer);\r\ndel_timer_sync(&hdw->encoder_wait_timer);\r\nif (hdw->workqueue) {\r\nflush_workqueue(hdw->workqueue);\r\ndestroy_workqueue(hdw->workqueue);\r\nhdw->workqueue = NULL;\r\n}\r\nusb_free_urb(hdw->ctl_read_urb);\r\nusb_free_urb(hdw->ctl_write_urb);\r\nkfree(hdw->ctl_read_buffer);\r\nkfree(hdw->ctl_write_buffer);\r\nkfree(hdw->controls);\r\nkfree(hdw->mpeg_ctrl_info);\r\nkfree(hdw);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void pvr2_hdw_remove_usb_stuff(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->flag_disconnected) return;\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_hdw_remove_usb_stuff: hdw=%p",hdw);\r\nif (hdw->ctl_read_urb) {\r\nusb_kill_urb(hdw->ctl_read_urb);\r\nusb_free_urb(hdw->ctl_read_urb);\r\nhdw->ctl_read_urb = NULL;\r\n}\r\nif (hdw->ctl_write_urb) {\r\nusb_kill_urb(hdw->ctl_write_urb);\r\nusb_free_urb(hdw->ctl_write_urb);\r\nhdw->ctl_write_urb = NULL;\r\n}\r\nif (hdw->ctl_read_buffer) {\r\nkfree(hdw->ctl_read_buffer);\r\nhdw->ctl_read_buffer = NULL;\r\n}\r\nif (hdw->ctl_write_buffer) {\r\nkfree(hdw->ctl_write_buffer);\r\nhdw->ctl_write_buffer = NULL;\r\n}\r\nhdw->flag_disconnected = !0;\r\nv4l2_device_disconnect(&hdw->v4l2_dev);\r\nhdw->usb_dev = NULL;\r\nhdw->usb_intf = NULL;\r\npvr2_hdw_render_useless(hdw);\r\n}\r\nvoid pvr2_hdw_destroy(struct pvr2_hdw *hdw)\r\n{\r\nif (!hdw) return;\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_hdw_destroy: hdw=%p",hdw);\r\nif (hdw->workqueue) {\r\nflush_workqueue(hdw->workqueue);\r\ndestroy_workqueue(hdw->workqueue);\r\nhdw->workqueue = NULL;\r\n}\r\ndel_timer_sync(&hdw->quiescent_timer);\r\ndel_timer_sync(&hdw->decoder_stabilization_timer);\r\ndel_timer_sync(&hdw->encoder_run_timer);\r\ndel_timer_sync(&hdw->encoder_wait_timer);\r\nif (hdw->fw_buffer) {\r\nkfree(hdw->fw_buffer);\r\nhdw->fw_buffer = NULL;\r\n}\r\nif (hdw->vid_stream) {\r\npvr2_stream_destroy(hdw->vid_stream);\r\nhdw->vid_stream = NULL;\r\n}\r\npvr2_i2c_core_done(hdw);\r\nv4l2_device_unregister(&hdw->v4l2_dev);\r\npvr2_hdw_remove_usb_stuff(hdw);\r\nmutex_lock(&pvr2_unit_mtx); do {\r\nif ((hdw->unit_number >= 0) &&\r\n(hdw->unit_number < PVR_NUM) &&\r\n(unit_pointers[hdw->unit_number] == hdw)) {\r\nunit_pointers[hdw->unit_number] = NULL;\r\n}\r\n} while (0); mutex_unlock(&pvr2_unit_mtx);\r\nkfree(hdw->controls);\r\nkfree(hdw->mpeg_ctrl_info);\r\nkfree(hdw);\r\n}\r\nint pvr2_hdw_dev_ok(struct pvr2_hdw *hdw)\r\n{\r\nreturn (hdw && hdw->flag_ok);\r\n}\r\nvoid pvr2_hdw_disconnect(struct pvr2_hdw *hdw)\r\n{\r\npvr2_trace(PVR2_TRACE_INIT,"pvr2_hdw_disconnect(hdw=%p)",hdw);\r\nLOCK_TAKE(hdw->big_lock);\r\nLOCK_TAKE(hdw->ctl_lock);\r\npvr2_hdw_remove_usb_stuff(hdw);\r\nLOCK_GIVE(hdw->ctl_lock);\r\nLOCK_GIVE(hdw->big_lock);\r\n}\r\nunsigned int pvr2_hdw_get_ctrl_count(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->control_cnt;\r\n}\r\nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_by_index(struct pvr2_hdw *hdw,\r\nunsigned int idx)\r\n{\r\nif (idx >= hdw->control_cnt) return NULL;\r\nreturn hdw->controls + idx;\r\n}\r\nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_by_id(struct pvr2_hdw *hdw,\r\nunsigned int ctl_id)\r\n{\r\nstruct pvr2_ctrl *cptr;\r\nunsigned int idx;\r\nint i;\r\nfor (idx = 0; idx < hdw->control_cnt; idx++) {\r\ncptr = hdw->controls + idx;\r\ni = cptr->info->internal_id;\r\nif (i && (i == ctl_id)) return cptr;\r\n}\r\nreturn NULL;\r\n}\r\nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_v4l(struct pvr2_hdw *hdw,unsigned int ctl_id)\r\n{\r\nstruct pvr2_ctrl *cptr;\r\nunsigned int idx;\r\nint i;\r\nfor (idx = 0; idx < hdw->control_cnt; idx++) {\r\ncptr = hdw->controls + idx;\r\ni = cptr->info->v4l_id;\r\nif (i && (i == ctl_id)) return cptr;\r\n}\r\nreturn NULL;\r\n}\r\nstruct pvr2_ctrl *pvr2_hdw_get_ctrl_nextv4l(struct pvr2_hdw *hdw,\r\nunsigned int ctl_id)\r\n{\r\nstruct pvr2_ctrl *cptr,*cp2;\r\nunsigned int idx;\r\nint i;\r\ncp2 = NULL;\r\nfor (idx = 0; idx < hdw->control_cnt; idx++) {\r\ncptr = hdw->controls + idx;\r\ni = cptr->info->v4l_id;\r\nif (!i) continue;\r\nif (i <= ctl_id) continue;\r\nif (cp2 && (cp2->info->v4l_id < i)) continue;\r\ncp2 = cptr;\r\n}\r\nreturn cp2;\r\nreturn NULL;\r\n}\r\nstatic const char *get_ctrl_typename(enum pvr2_ctl_type tp)\r\n{\r\nswitch (tp) {\r\ncase pvr2_ctl_int: return "integer";\r\ncase pvr2_ctl_enum: return "enum";\r\ncase pvr2_ctl_bool: return "boolean";\r\ncase pvr2_ctl_bitmask: return "bitmask";\r\n}\r\nreturn "";\r\n}\r\nstatic void pvr2_subdev_set_control(struct pvr2_hdw *hdw, int id,\r\nconst char *name, int val)\r\n{\r\nstruct v4l2_control ctrl;\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev v4l2 %s=%d", name, val);\r\nmemset(&ctrl, 0, sizeof(ctrl));\r\nctrl.id = id;\r\nctrl.value = val;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, core, s_ctrl, &ctrl);\r\n}\r\nv4l2_std_id pvr2_hdw_get_detected_std(struct pvr2_hdw *hdw)\r\n{\r\nv4l2_std_id std;\r\nstd = (v4l2_std_id)hdw->std_mask_avail;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0,\r\nvideo, querystd, &std);\r\nreturn std;\r\n}\r\nstatic void pvr2_subdev_update(struct pvr2_hdw *hdw)\r\n{\r\nstruct v4l2_subdev *sd;\r\nunsigned int id;\r\npvr2_subdev_update_func fp;\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev update...");\r\nif (hdw->tuner_updated || hdw->force_dirty) {\r\nstruct tuner_setup setup;\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev tuner set_type(%d)",\r\nhdw->tuner_type);\r\nif (((int)(hdw->tuner_type)) >= 0) {\r\nmemset(&setup, 0, sizeof(setup));\r\nsetup.addr = ADDR_UNSET;\r\nsetup.type = hdw->tuner_type;\r\nsetup.mode_mask = T_RADIO | T_ANALOG_TV;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0,\r\ntuner, s_type_addr, &setup);\r\n}\r\n}\r\nif (hdw->input_dirty || hdw->std_dirty || hdw->force_dirty) {\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev v4l2 set_standard");\r\nif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0,\r\ntuner, s_radio);\r\n} else {\r\nv4l2_std_id vs;\r\nvs = hdw->std_mask_cur;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0,\r\ncore, s_std, vs);\r\npvr2_hdw_cx25840_vbi_hack(hdw);\r\n}\r\nhdw->tuner_signal_stale = !0;\r\nhdw->cropcap_stale = !0;\r\n}\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_BRIGHTNESS, brightness);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_CONTRAST, contrast);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_SATURATION, saturation);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_HUE, hue);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_MUTE, mute);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_VOLUME, volume);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_BALANCE, balance);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_BASS, bass);\r\nPVR2_SUBDEV_SET_CONTROL(hdw, V4L2_CID_AUDIO_TREBLE, treble);\r\nif (hdw->input_dirty || hdw->audiomode_dirty || hdw->force_dirty) {\r\nstruct v4l2_tuner vt;\r\nmemset(&vt, 0, sizeof(vt));\r\nvt.type = (hdw->input_val == PVR2_CVAL_INPUT_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nvt.audmode = hdw->audiomode_val;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, tuner, s_tuner, &vt);\r\n}\r\nif (hdw->freqDirty || hdw->force_dirty) {\r\nunsigned long fv;\r\nstruct v4l2_frequency freq;\r\nfv = pvr2_hdw_get_cur_freq(hdw);\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev v4l2 set_freq(%lu)", fv);\r\nif (hdw->tuner_signal_stale) pvr2_hdw_status_poll(hdw);\r\nmemset(&freq, 0, sizeof(freq));\r\nif (hdw->tuner_signal_info.capability & V4L2_TUNER_CAP_LOW) {\r\nfreq.frequency = (fv * 2) / 125;\r\n} else {\r\nfreq.frequency = fv / 62500;\r\n}\r\nif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\r\nfreq.type = V4L2_TUNER_RADIO;\r\n} else {\r\nfreq.type = V4L2_TUNER_ANALOG_TV;\r\n}\r\nfreq.tuner = 0;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, tuner,\r\ns_frequency, &freq);\r\n}\r\nif (hdw->res_hor_dirty || hdw->res_ver_dirty || hdw->force_dirty) {\r\nstruct v4l2_mbus_framefmt fmt;\r\nmemset(&fmt, 0, sizeof(fmt));\r\nfmt.width = hdw->res_hor_val;\r\nfmt.height = hdw->res_ver_val;\r\nfmt.code = V4L2_MBUS_FMT_FIXED;\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev v4l2 set_size(%dx%d)",\r\nfmt.width, fmt.height);\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, video, s_mbus_fmt, &fmt);\r\n}\r\nif (hdw->srate_dirty || hdw->force_dirty) {\r\nu32 val;\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev v4l2 set_audio %d",\r\nhdw->srate_val);\r\nswitch (hdw->srate_val) {\r\ndefault:\r\ncase V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000:\r\nval = 48000;\r\nbreak;\r\ncase V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100:\r\nval = 44100;\r\nbreak;\r\ncase V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000:\r\nval = 32000;\r\nbreak;\r\n}\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0,\r\naudio, s_clock_freq, val);\r\n}\r\nv4l2_device_for_each_subdev(sd, &hdw->v4l2_dev) {\r\nid = sd->grp_id;\r\nif (id >= ARRAY_SIZE(pvr2_module_update_functions)) continue;\r\nfp = pvr2_module_update_functions[id];\r\nif (!fp) continue;\r\n(*fp)(hdw, sd);\r\n}\r\nif (hdw->tuner_signal_stale || hdw->cropcap_stale) {\r\npvr2_hdw_status_poll(hdw);\r\n}\r\n}\r\nstatic int pvr2_hdw_commit_setup(struct pvr2_hdw *hdw)\r\n{\r\nunsigned int idx;\r\nstruct pvr2_ctrl *cptr;\r\nint value;\r\nint commit_flag = hdw->force_dirty;\r\nchar buf[100];\r\nunsigned int bcnt,ccnt;\r\nfor (idx = 0; idx < hdw->control_cnt; idx++) {\r\ncptr = hdw->controls + idx;\r\nif (!cptr->info->is_dirty) continue;\r\nif (!cptr->info->is_dirty(cptr)) continue;\r\ncommit_flag = !0;\r\nif (!(pvrusb2_debug & PVR2_TRACE_CTL)) continue;\r\nbcnt = scnprintf(buf,sizeof(buf),"\"%s\" <-- ",\r\ncptr->info->name);\r\nvalue = 0;\r\ncptr->info->get_value(cptr,&value);\r\npvr2_ctrl_value_to_sym_internal(cptr,~0,value,\r\nbuf+bcnt,\r\nsizeof(buf)-bcnt,&ccnt);\r\nbcnt += ccnt;\r\nbcnt += scnprintf(buf+bcnt,sizeof(buf)-bcnt," <%s>",\r\nget_ctrl_typename(cptr->info->type));\r\npvr2_trace(PVR2_TRACE_CTL,\r\n"/*--TRACE_COMMIT--*/ %.*s",\r\nbcnt,buf);\r\n}\r\nif (!commit_flag) {\r\nreturn 0;\r\n}\r\nhdw->state_pipeline_config = 0;\r\ntrace_stbit("state_pipeline_config",hdw->state_pipeline_config);\r\npvr2_hdw_state_sched(hdw);\r\nreturn !0;\r\n}\r\nstatic int pvr2_hdw_commit_execute(struct pvr2_hdw *hdw)\r\n{\r\nunsigned int idx;\r\nstruct pvr2_ctrl *cptr;\r\nint disruptive_change;\r\nif (hdw->input_dirty && hdw->state_pathway_ok &&\r\n(((hdw->input_val == PVR2_CVAL_INPUT_DTV) ?\r\nPVR2_PATHWAY_DIGITAL : PVR2_PATHWAY_ANALOG) !=\r\nhdw->pathway_state)) {\r\nhdw->state_pathway_ok = 0;\r\ntrace_stbit("state_pathway_ok", hdw->state_pathway_ok);\r\n}\r\nif (!hdw->state_pathway_ok) {\r\nreturn 0;\r\n}\r\nif (hdw->std_dirty) {\r\nint nvres;\r\nint gop_size;\r\nif (hdw->std_mask_cur & V4L2_STD_525_60) {\r\nnvres = 480;\r\ngop_size = 15;\r\n} else {\r\nnvres = 576;\r\ngop_size = 12;\r\n}\r\nif (nvres != hdw->res_ver_val) {\r\nhdw->res_ver_val = nvres;\r\nhdw->res_ver_dirty = !0;\r\n}\r\nif (gop_size != hdw->enc_ctl_state.video_gop_size) {\r\nstruct v4l2_ext_controls cs;\r\nstruct v4l2_ext_control c1;\r\nmemset(&cs, 0, sizeof(cs));\r\nmemset(&c1, 0, sizeof(c1));\r\ncs.controls = &c1;\r\ncs.count = 1;\r\nc1.id = V4L2_CID_MPEG_VIDEO_GOP_SIZE;\r\nc1.value = gop_size;\r\ncx2341x_ext_ctrls(&hdw->enc_ctl_state, 0, &cs,\r\nVIDIOC_S_EXT_CTRLS);\r\n}\r\n}\r\nif (hdw->res_hor_dirty && hdw->cropw_val < hdw->res_hor_val) {\r\nhdw->cropw_val = hdw->res_hor_val;\r\nhdw->cropw_dirty = !0;\r\n} else if (hdw->cropw_dirty) {\r\nhdw->res_hor_dirty = !0;\r\nhdw->res_hor_val = min(720, hdw->cropw_val);\r\n}\r\nif (hdw->res_ver_dirty && hdw->croph_val < hdw->res_ver_val) {\r\nhdw->croph_val = hdw->res_ver_val;\r\nhdw->croph_dirty = !0;\r\n} else if (hdw->croph_dirty) {\r\nint nvres = hdw->std_mask_cur & V4L2_STD_525_60 ? 480 : 576;\r\nhdw->res_ver_dirty = !0;\r\nhdw->res_ver_val = min(nvres, hdw->croph_val);\r\n}\r\ndisruptive_change =\r\n(hdw->std_dirty ||\r\nhdw->enc_unsafe_stale ||\r\nhdw->srate_dirty ||\r\nhdw->res_ver_dirty ||\r\nhdw->res_hor_dirty ||\r\nhdw->cropw_dirty ||\r\nhdw->croph_dirty ||\r\nhdw->input_dirty ||\r\n(hdw->active_stream_type != hdw->desired_stream_type));\r\nif (disruptive_change && !hdw->state_pipeline_idle) {\r\nhdw->state_pipeline_pause = !0;\r\nreturn 0;\r\n}\r\nif (hdw->srate_dirty) {\r\nstruct v4l2_ext_controls cs;\r\nstruct v4l2_ext_control c1;\r\nmemset(&cs,0,sizeof(cs));\r\nmemset(&c1,0,sizeof(c1));\r\ncs.controls = &c1;\r\ncs.count = 1;\r\nc1.id = V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ;\r\nc1.value = hdw->srate_val;\r\ncx2341x_ext_ctrls(&hdw->enc_ctl_state, 0, &cs,VIDIOC_S_EXT_CTRLS);\r\n}\r\nif (hdw->active_stream_type != hdw->desired_stream_type) {\r\nhdw->active_stream_type = hdw->desired_stream_type;\r\n}\r\nif (hdw->hdw_desc->signal_routing_scheme ==\r\nPVR2_ROUTING_SCHEME_GOTVIEW) {\r\nu32 b;\r\npvr2_hdw_gpio_get_out(hdw,&b);\r\nif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\r\npvr2_hdw_gpio_chg_out(hdw,(1 << 11),~0);\r\n} else {\r\npvr2_hdw_gpio_chg_out(hdw,(1 << 11),0);\r\n}\r\n}\r\npvr2_subdev_update(hdw);\r\nhdw->tuner_updated = 0;\r\nhdw->force_dirty = 0;\r\nfor (idx = 0; idx < hdw->control_cnt; idx++) {\r\ncptr = hdw->controls + idx;\r\nif (!cptr->info->clear_dirty) continue;\r\ncptr->info->clear_dirty(cptr);\r\n}\r\nif ((hdw->pathway_state == PVR2_PATHWAY_ANALOG) &&\r\nhdw->state_encoder_run) {\r\nif (pvr2_encoder_adjust(hdw) < 0) return !0;\r\n}\r\nhdw->state_pipeline_config = !0;\r\ntrace_stbit("state_pipeline_config",hdw->state_pipeline_config);\r\nreturn !0;\r\n}\r\nint pvr2_hdw_commit_ctl(struct pvr2_hdw *hdw)\r\n{\r\nint fl;\r\nLOCK_TAKE(hdw->big_lock);\r\nfl = pvr2_hdw_commit_setup(hdw);\r\nLOCK_GIVE(hdw->big_lock);\r\nif (!fl) return 0;\r\nreturn pvr2_hdw_wait(hdw,0);\r\n}\r\nstatic void pvr2_hdw_worker_poll(struct work_struct *work)\r\n{\r\nint fl = 0;\r\nstruct pvr2_hdw *hdw = container_of(work,struct pvr2_hdw,workpoll);\r\nLOCK_TAKE(hdw->big_lock); do {\r\nfl = pvr2_hdw_state_eval(hdw);\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\nif (fl && hdw->state_func) {\r\nhdw->state_func(hdw->state_data);\r\n}\r\n}\r\nstatic int pvr2_hdw_wait(struct pvr2_hdw *hdw,int state)\r\n{\r\nreturn wait_event_interruptible(\r\nhdw->state_wait_data,\r\n(hdw->state_stale == 0) &&\r\n(!state || (hdw->master_state != state)));\r\n}\r\nconst char *pvr2_hdw_get_driver_name(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->name;\r\n}\r\nconst char *pvr2_hdw_get_desc(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->hdw_desc->description;\r\n}\r\nconst char *pvr2_hdw_get_type(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->hdw_desc->shortname;\r\n}\r\nint pvr2_hdw_is_hsm(struct pvr2_hdw *hdw)\r\n{\r\nint result;\r\nLOCK_TAKE(hdw->ctl_lock); do {\r\nhdw->cmd_buffer[0] = FX2CMD_GET_USB_SPEED;\r\nresult = pvr2_send_request(hdw,\r\nhdw->cmd_buffer,1,\r\nhdw->cmd_buffer,1);\r\nif (result < 0) break;\r\nresult = (hdw->cmd_buffer[0] != 0);\r\n} while(0); LOCK_GIVE(hdw->ctl_lock);\r\nreturn result;\r\n}\r\nvoid pvr2_hdw_execute_tuner_poll(struct pvr2_hdw *hdw)\r\n{\r\nLOCK_TAKE(hdw->big_lock); do {\r\npvr2_hdw_status_poll(hdw);\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\n}\r\nstatic int pvr2_hdw_check_cropcap(struct pvr2_hdw *hdw)\r\n{\r\nif (!hdw->cropcap_stale) {\r\nreturn 0;\r\n}\r\npvr2_hdw_status_poll(hdw);\r\nif (hdw->cropcap_stale) {\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint pvr2_hdw_get_cropcap(struct pvr2_hdw *hdw, struct v4l2_cropcap *pp)\r\n{\r\nint stat = 0;\r\nLOCK_TAKE(hdw->big_lock);\r\nstat = pvr2_hdw_check_cropcap(hdw);\r\nif (!stat) {\r\nmemcpy(pp, &hdw->cropcap_info, sizeof(hdw->cropcap_info));\r\n}\r\nLOCK_GIVE(hdw->big_lock);\r\nreturn stat;\r\n}\r\nint pvr2_hdw_get_tuner_status(struct pvr2_hdw *hdw,struct v4l2_tuner *vtp)\r\n{\r\nLOCK_TAKE(hdw->big_lock); do {\r\nif (hdw->tuner_signal_stale) {\r\npvr2_hdw_status_poll(hdw);\r\n}\r\nmemcpy(vtp,&hdw->tuner_signal_info,sizeof(struct v4l2_tuner));\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\nreturn 0;\r\n}\r\nstruct pvr2_stream *pvr2_hdw_get_video_stream(struct pvr2_hdw *hp)\r\n{\r\nreturn hp->vid_stream;\r\n}\r\nvoid pvr2_hdw_trigger_module_log(struct pvr2_hdw *hdw)\r\n{\r\nint nr = pvr2_hdw_get_unit_number(hdw);\r\nLOCK_TAKE(hdw->big_lock); do {\r\nprintk(KERN_INFO "pvrusb2: ================= START STATUS CARD #%d =================\n", nr);\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, core, log_status);\r\npvr2_trace(PVR2_TRACE_INFO,"cx2341x config:");\r\ncx2341x_log_status(&hdw->enc_ctl_state, "pvrusb2");\r\npvr2_hdw_state_log_state(hdw);\r\nprintk(KERN_INFO "pvrusb2: ================== END STATUS CARD #%d ==================\n", nr);\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\n}\r\nstatic u8 *pvr2_full_eeprom_fetch(struct pvr2_hdw *hdw)\r\n{\r\nstruct i2c_msg msg[2];\r\nu8 *eeprom;\r\nu8 iadd[2];\r\nu8 addr;\r\nu16 eepromSize;\r\nunsigned int offs;\r\nint ret;\r\nint mode16 = 0;\r\nunsigned pcnt,tcnt;\r\neeprom = kmalloc(EEPROM_SIZE,GFP_KERNEL);\r\nif (!eeprom) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Failed to allocate memory"\r\n" required to read eeprom");\r\nreturn NULL;\r\n}\r\ntrace_eeprom("Value for eeprom addr from controller was 0x%x",\r\nhdw->eeprom_addr);\r\naddr = hdw->eeprom_addr;\r\nif (addr & 0x80) addr >>= 1;\r\nmode16 = (addr & 1);\r\neepromSize = (mode16 ? EEPROM_SIZE : 256);\r\ntrace_eeprom("Examining %d byte eeprom at location 0x%x"\r\n" using %d bit addressing",eepromSize,addr,\r\nmode16 ? 16 : 8);\r\nmsg[0].addr = addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = mode16 ? 2 : 1;\r\nmsg[0].buf = iadd;\r\nmsg[1].addr = addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmemset(eeprom,0,EEPROM_SIZE);\r\nfor (tcnt = 0; tcnt < EEPROM_SIZE; tcnt += pcnt) {\r\npcnt = 16;\r\nif (pcnt + tcnt > EEPROM_SIZE) pcnt = EEPROM_SIZE-tcnt;\r\noffs = tcnt + (eepromSize - EEPROM_SIZE);\r\nif (mode16) {\r\niadd[0] = offs >> 8;\r\niadd[1] = offs;\r\n} else {\r\niadd[0] = offs;\r\n}\r\nmsg[1].len = pcnt;\r\nmsg[1].buf = eeprom+tcnt;\r\nif ((ret = i2c_transfer(&hdw->i2c_adap,\r\nmsg,ARRAY_SIZE(msg))) != 2) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"eeprom fetch set offs err=%d",ret);\r\nkfree(eeprom);\r\nreturn NULL;\r\n}\r\n}\r\nreturn eeprom;\r\n}\r\nvoid pvr2_hdw_cpufw_set_enabled(struct pvr2_hdw *hdw,\r\nint mode,\r\nint enable_flag)\r\n{\r\nint ret;\r\nu16 address;\r\nunsigned int pipe;\r\nLOCK_TAKE(hdw->big_lock); do {\r\nif ((hdw->fw_buffer == NULL) == !enable_flag) break;\r\nif (!enable_flag) {\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Cleaning up after CPU firmware fetch");\r\nkfree(hdw->fw_buffer);\r\nhdw->fw_buffer = NULL;\r\nhdw->fw_size = 0;\r\nif (hdw->fw_cpu_flag) {\r\npvr2_hdw_cpureset_assert(hdw,0);\r\n}\r\nbreak;\r\n}\r\nhdw->fw_cpu_flag = (mode != 2);\r\nif (hdw->fw_cpu_flag) {\r\nhdw->fw_size = (mode == 1) ? 0x4000 : 0x2000;\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Preparing to suck out CPU firmware"\r\n" (size=%u)", hdw->fw_size);\r\nhdw->fw_buffer = kzalloc(hdw->fw_size,GFP_KERNEL);\r\nif (!hdw->fw_buffer) {\r\nhdw->fw_size = 0;\r\nbreak;\r\n}\r\npvr2_hdw_cpureset_assert(hdw,1);\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Grabbing CPU firmware");\r\npipe = usb_rcvctrlpipe(hdw->usb_dev, 0);\r\nfor(address = 0; address < hdw->fw_size;\r\naddress += 0x800) {\r\nret = usb_control_msg(hdw->usb_dev,pipe,\r\n0xa0,0xc0,\r\naddress,0,\r\nhdw->fw_buffer+address,\r\n0x800,HZ);\r\nif (ret < 0) break;\r\n}\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Done grabbing CPU firmware");\r\n} else {\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Sucking down EEPROM contents");\r\nhdw->fw_buffer = pvr2_full_eeprom_fetch(hdw);\r\nif (!hdw->fw_buffer) {\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"EEPROM content suck failed.");\r\nbreak;\r\n}\r\nhdw->fw_size = EEPROM_SIZE;\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Done sucking down EEPROM contents");\r\n}\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\n}\r\nint pvr2_hdw_cpufw_get_enabled(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->fw_buffer != NULL;\r\n}\r\nint pvr2_hdw_cpufw_get(struct pvr2_hdw *hdw,unsigned int offs,\r\nchar *buf,unsigned int cnt)\r\n{\r\nint ret = -EINVAL;\r\nLOCK_TAKE(hdw->big_lock); do {\r\nif (!buf) break;\r\nif (!cnt) break;\r\nif (!hdw->fw_buffer) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (offs >= hdw->fw_size) {\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Read firmware data offs=%d EOF",\r\noffs);\r\nret = 0;\r\nbreak;\r\n}\r\nif (offs + cnt > hdw->fw_size) cnt = hdw->fw_size - offs;\r\nmemcpy(buf,hdw->fw_buffer+offs,cnt);\r\npvr2_trace(PVR2_TRACE_FIRMWARE,\r\n"Read firmware data offs=%d cnt=%d",\r\noffs,cnt);\r\nret = cnt;\r\n} while (0); LOCK_GIVE(hdw->big_lock);\r\nreturn ret;\r\n}\r\nint pvr2_hdw_v4l_get_minor_number(struct pvr2_hdw *hdw,\r\nenum pvr2_v4l_type index)\r\n{\r\nswitch (index) {\r\ncase pvr2_v4l_type_video: return hdw->v4l_minor_number_video;\r\ncase pvr2_v4l_type_vbi: return hdw->v4l_minor_number_vbi;\r\ncase pvr2_v4l_type_radio: return hdw->v4l_minor_number_radio;\r\ndefault: return -1;\r\n}\r\n}\r\nvoid pvr2_hdw_v4l_store_minor_number(struct pvr2_hdw *hdw,\r\nenum pvr2_v4l_type index,int v)\r\n{\r\nswitch (index) {\r\ncase pvr2_v4l_type_video: hdw->v4l_minor_number_video = v;\r\ncase pvr2_v4l_type_vbi: hdw->v4l_minor_number_vbi = v;\r\ncase pvr2_v4l_type_radio: hdw->v4l_minor_number_radio = v;\r\ndefault: break;\r\n}\r\n}\r\nstatic void pvr2_ctl_write_complete(struct urb *urb)\r\n{\r\nstruct pvr2_hdw *hdw = urb->context;\r\nhdw->ctl_write_pend_flag = 0;\r\nif (hdw->ctl_read_pend_flag) return;\r\ncomplete(&hdw->ctl_done);\r\n}\r\nstatic void pvr2_ctl_read_complete(struct urb *urb)\r\n{\r\nstruct pvr2_hdw *hdw = urb->context;\r\nhdw->ctl_read_pend_flag = 0;\r\nif (hdw->ctl_write_pend_flag) return;\r\ncomplete(&hdw->ctl_done);\r\n}\r\nstatic void pvr2_ctl_timeout(unsigned long data)\r\n{\r\nstruct pvr2_hdw *hdw = (struct pvr2_hdw *)data;\r\nif (hdw->ctl_write_pend_flag || hdw->ctl_read_pend_flag) {\r\nhdw->ctl_timeout_flag = !0;\r\nif (hdw->ctl_write_pend_flag)\r\nusb_unlink_urb(hdw->ctl_write_urb);\r\nif (hdw->ctl_read_pend_flag)\r\nusb_unlink_urb(hdw->ctl_read_urb);\r\n}\r\n}\r\nstatic int pvr2_send_request_ex(struct pvr2_hdw *hdw,\r\nunsigned int timeout,int probe_fl,\r\nvoid *write_data,unsigned int write_len,\r\nvoid *read_data,unsigned int read_len)\r\n{\r\nunsigned int idx;\r\nint status = 0;\r\nstruct timer_list timer;\r\nif (!hdw->ctl_lock_held) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Attempted to execute control transfer"\r\n" without lock!!");\r\nreturn -EDEADLK;\r\n}\r\nif (!hdw->flag_ok && !probe_fl) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Attempted to execute control transfer"\r\n" when device not ok");\r\nreturn -EIO;\r\n}\r\nif (!(hdw->ctl_read_urb && hdw->ctl_write_urb)) {\r\nif (!probe_fl) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Attempted to execute control transfer"\r\n" when USB is disconnected");\r\n}\r\nreturn -ENOTTY;\r\n}\r\nif (!write_data) write_len = 0;\r\nif (!read_data) read_len = 0;\r\nif (write_len > PVR2_CTL_BUFFSIZE) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Attempted to execute %d byte"\r\n" control-write transfer (limit=%d)",\r\nwrite_len,PVR2_CTL_BUFFSIZE);\r\nreturn -EINVAL;\r\n}\r\nif (read_len > PVR2_CTL_BUFFSIZE) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Attempted to execute %d byte"\r\n" control-read transfer (limit=%d)",\r\nwrite_len,PVR2_CTL_BUFFSIZE);\r\nreturn -EINVAL;\r\n}\r\nif ((!write_len) && (!read_len)) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Attempted to execute null control transfer?");\r\nreturn -EINVAL;\r\n}\r\nhdw->cmd_debug_state = 1;\r\nif (write_len) {\r\nhdw->cmd_debug_code = ((unsigned char *)write_data)[0];\r\n} else {\r\nhdw->cmd_debug_code = 0;\r\n}\r\nhdw->cmd_debug_write_len = write_len;\r\nhdw->cmd_debug_read_len = read_len;\r\ninit_completion(&hdw->ctl_done);\r\nhdw->ctl_timeout_flag = 0;\r\nhdw->ctl_write_pend_flag = 0;\r\nhdw->ctl_read_pend_flag = 0;\r\ninit_timer(&timer);\r\ntimer.expires = jiffies + timeout;\r\ntimer.data = (unsigned long)hdw;\r\ntimer.function = pvr2_ctl_timeout;\r\nif (write_len) {\r\nhdw->cmd_debug_state = 2;\r\nfor (idx = 0; idx < write_len; idx++) {\r\nhdw->ctl_write_buffer[idx] =\r\n((unsigned char *)write_data)[idx];\r\n}\r\nusb_fill_bulk_urb(hdw->ctl_write_urb,\r\nhdw->usb_dev,\r\nusb_sndbulkpipe(hdw->usb_dev,\r\nPVR2_CTL_WRITE_ENDPOINT),\r\nhdw->ctl_write_buffer,\r\nwrite_len,\r\npvr2_ctl_write_complete,\r\nhdw);\r\nhdw->ctl_write_urb->actual_length = 0;\r\nhdw->ctl_write_pend_flag = !0;\r\nstatus = usb_submit_urb(hdw->ctl_write_urb,GFP_KERNEL);\r\nif (status < 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Failed to submit write-control"\r\n" URB status=%d",status);\r\nhdw->ctl_write_pend_flag = 0;\r\ngoto done;\r\n}\r\n}\r\nif (read_len) {\r\nhdw->cmd_debug_state = 3;\r\nmemset(hdw->ctl_read_buffer,0x43,read_len);\r\nusb_fill_bulk_urb(hdw->ctl_read_urb,\r\nhdw->usb_dev,\r\nusb_rcvbulkpipe(hdw->usb_dev,\r\nPVR2_CTL_READ_ENDPOINT),\r\nhdw->ctl_read_buffer,\r\nread_len,\r\npvr2_ctl_read_complete,\r\nhdw);\r\nhdw->ctl_read_urb->actual_length = 0;\r\nhdw->ctl_read_pend_flag = !0;\r\nstatus = usb_submit_urb(hdw->ctl_read_urb,GFP_KERNEL);\r\nif (status < 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Failed to submit read-control"\r\n" URB status=%d",status);\r\nhdw->ctl_read_pend_flag = 0;\r\ngoto done;\r\n}\r\n}\r\nadd_timer(&timer);\r\nhdw->cmd_debug_state = 4;\r\nwhile (hdw->ctl_write_pend_flag || hdw->ctl_read_pend_flag) {\r\nwait_for_completion(&hdw->ctl_done);\r\n}\r\nhdw->cmd_debug_state = 5;\r\ndel_timer_sync(&timer);\r\nhdw->cmd_debug_state = 6;\r\nstatus = 0;\r\nif (hdw->ctl_timeout_flag) {\r\nstatus = -ETIMEDOUT;\r\nif (!probe_fl) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Timed out control-write");\r\n}\r\ngoto done;\r\n}\r\nif (write_len) {\r\nif ((hdw->ctl_write_urb->status != 0) &&\r\n(hdw->ctl_write_urb->status != -ENOENT) &&\r\n(hdw->ctl_write_urb->status != -ESHUTDOWN) &&\r\n(hdw->ctl_write_urb->status != -ECONNRESET)) {\r\nstatus = hdw->ctl_write_urb->status;\r\nif (!probe_fl) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"control-write URB failure,"\r\n" status=%d",\r\nstatus);\r\n}\r\ngoto done;\r\n}\r\nif (hdw->ctl_write_urb->actual_length < write_len) {\r\nstatus = -EIO;\r\nif (!probe_fl) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"control-write URB short,"\r\n" expected=%d got=%d",\r\nwrite_len,\r\nhdw->ctl_write_urb->actual_length);\r\n}\r\ngoto done;\r\n}\r\n}\r\nif (read_len) {\r\nif ((hdw->ctl_read_urb->status != 0) &&\r\n(hdw->ctl_read_urb->status != -ENOENT) &&\r\n(hdw->ctl_read_urb->status != -ESHUTDOWN) &&\r\n(hdw->ctl_read_urb->status != -ECONNRESET)) {\r\nstatus = hdw->ctl_read_urb->status;\r\nif (!probe_fl) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"control-read URB failure,"\r\n" status=%d",\r\nstatus);\r\n}\r\ngoto done;\r\n}\r\nif (hdw->ctl_read_urb->actual_length < read_len) {\r\nstatus = -EIO;\r\nif (!probe_fl) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"control-read URB short,"\r\n" expected=%d got=%d",\r\nread_len,\r\nhdw->ctl_read_urb->actual_length);\r\n}\r\ngoto done;\r\n}\r\nfor (idx = 0; idx < read_len; idx++) {\r\n((unsigned char *)read_data)[idx] =\r\nhdw->ctl_read_buffer[idx];\r\n}\r\n}\r\ndone:\r\nhdw->cmd_debug_state = 0;\r\nif ((status < 0) && (!probe_fl)) {\r\npvr2_hdw_render_useless(hdw);\r\n}\r\nreturn status;\r\n}\r\nint pvr2_send_request(struct pvr2_hdw *hdw,\r\nvoid *write_data,unsigned int write_len,\r\nvoid *read_data,unsigned int read_len)\r\n{\r\nreturn pvr2_send_request_ex(hdw,HZ*4,0,\r\nwrite_data,write_len,\r\nread_data,read_len);\r\n}\r\nstatic int pvr2_issue_simple_cmd(struct pvr2_hdw *hdw,u32 cmdcode)\r\n{\r\nint ret;\r\nunsigned int cnt = 1;\r\nunsigned int args = 0;\r\nLOCK_TAKE(hdw->ctl_lock);\r\nhdw->cmd_buffer[0] = cmdcode & 0xffu;\r\nargs = (cmdcode >> 8) & 0xffu;\r\nargs = (args > 2) ? 2 : args;\r\nif (args) {\r\ncnt += args;\r\nhdw->cmd_buffer[1] = (cmdcode >> 16) & 0xffu;\r\nif (args > 1) {\r\nhdw->cmd_buffer[2] = (cmdcode >> 24) & 0xffu;\r\n}\r\n}\r\nif (pvrusb2_debug & PVR2_TRACE_INIT) {\r\nunsigned int idx;\r\nunsigned int ccnt,bcnt;\r\nchar tbuf[50];\r\ncmdcode &= 0xffu;\r\nbcnt = 0;\r\nccnt = scnprintf(tbuf+bcnt,\r\nsizeof(tbuf)-bcnt,\r\n"Sending FX2 command 0x%x",cmdcode);\r\nbcnt += ccnt;\r\nfor (idx = 0; idx < ARRAY_SIZE(pvr2_fx2cmd_desc); idx++) {\r\nif (pvr2_fx2cmd_desc[idx].id == cmdcode) {\r\nccnt = scnprintf(tbuf+bcnt,\r\nsizeof(tbuf)-bcnt,\r\n" \"%s\"",\r\npvr2_fx2cmd_desc[idx].desc);\r\nbcnt += ccnt;\r\nbreak;\r\n}\r\n}\r\nif (args) {\r\nccnt = scnprintf(tbuf+bcnt,\r\nsizeof(tbuf)-bcnt,\r\n" (%u",hdw->cmd_buffer[1]);\r\nbcnt += ccnt;\r\nif (args > 1) {\r\nccnt = scnprintf(tbuf+bcnt,\r\nsizeof(tbuf)-bcnt,\r\n",%u",hdw->cmd_buffer[2]);\r\nbcnt += ccnt;\r\n}\r\nccnt = scnprintf(tbuf+bcnt,\r\nsizeof(tbuf)-bcnt,\r\n")");\r\nbcnt += ccnt;\r\n}\r\npvr2_trace(PVR2_TRACE_INIT,"%.*s",bcnt,tbuf);\r\n}\r\nret = pvr2_send_request(hdw,hdw->cmd_buffer,cnt,NULL,0);\r\nLOCK_GIVE(hdw->ctl_lock);\r\nreturn ret;\r\n}\r\nint pvr2_write_register(struct pvr2_hdw *hdw, u16 reg, u32 data)\r\n{\r\nint ret;\r\nLOCK_TAKE(hdw->ctl_lock);\r\nhdw->cmd_buffer[0] = FX2CMD_REG_WRITE;\r\nPVR2_DECOMPOSE_LE(hdw->cmd_buffer,1,data);\r\nhdw->cmd_buffer[5] = 0;\r\nhdw->cmd_buffer[6] = (reg >> 8) & 0xff;\r\nhdw->cmd_buffer[7] = reg & 0xff;\r\nret = pvr2_send_request(hdw, hdw->cmd_buffer, 8, hdw->cmd_buffer, 0);\r\nLOCK_GIVE(hdw->ctl_lock);\r\nreturn ret;\r\n}\r\nstatic int pvr2_read_register(struct pvr2_hdw *hdw, u16 reg, u32 *data)\r\n{\r\nint ret = 0;\r\nLOCK_TAKE(hdw->ctl_lock);\r\nhdw->cmd_buffer[0] = FX2CMD_REG_READ;\r\nhdw->cmd_buffer[1] = 0;\r\nhdw->cmd_buffer[2] = 0;\r\nhdw->cmd_buffer[3] = 0;\r\nhdw->cmd_buffer[4] = 0;\r\nhdw->cmd_buffer[5] = 0;\r\nhdw->cmd_buffer[6] = (reg >> 8) & 0xff;\r\nhdw->cmd_buffer[7] = reg & 0xff;\r\nret |= pvr2_send_request(hdw, hdw->cmd_buffer, 8, hdw->cmd_buffer, 4);\r\n*data = PVR2_COMPOSE_LE(hdw->cmd_buffer,0);\r\nLOCK_GIVE(hdw->ctl_lock);\r\nreturn ret;\r\n}\r\nvoid pvr2_hdw_render_useless(struct pvr2_hdw *hdw)\r\n{\r\nif (!hdw->flag_ok) return;\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Device being rendered inoperable");\r\nif (hdw->vid_stream) {\r\npvr2_stream_setup(hdw->vid_stream,NULL,0,0);\r\n}\r\nhdw->flag_ok = 0;\r\ntrace_stbit("flag_ok",hdw->flag_ok);\r\npvr2_hdw_state_sched(hdw);\r\n}\r\nvoid pvr2_hdw_device_reset(struct pvr2_hdw *hdw)\r\n{\r\nint ret;\r\npvr2_trace(PVR2_TRACE_INIT,"Performing a device reset...");\r\nret = usb_lock_device_for_reset(hdw->usb_dev,NULL);\r\nif (ret == 0) {\r\nret = usb_reset_device(hdw->usb_dev);\r\nusb_unlock_device(hdw->usb_dev);\r\n} else {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Failed to lock USB device ret=%d",ret);\r\n}\r\nif (init_pause_msec) {\r\npvr2_trace(PVR2_TRACE_INFO,\r\n"Waiting %u msec for hardware to settle",\r\ninit_pause_msec);\r\nmsleep(init_pause_msec);\r\n}\r\n}\r\nvoid pvr2_hdw_cpureset_assert(struct pvr2_hdw *hdw,int val)\r\n{\r\nchar *da;\r\nunsigned int pipe;\r\nint ret;\r\nif (!hdw->usb_dev) return;\r\nda = kmalloc(16, GFP_KERNEL);\r\nif (da == NULL) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Unable to allocate memory to control CPU reset");\r\nreturn;\r\n}\r\npvr2_trace(PVR2_TRACE_INIT,"cpureset_assert(%d)",val);\r\nda[0] = val ? 0x01 : 0x00;\r\npipe = usb_sndctrlpipe(hdw->usb_dev, 0);\r\nret = usb_control_msg(hdw->usb_dev,pipe,0xa0,0x40,0xe600,0,da,1,HZ);\r\nif (ret < 0) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"cpureset_assert(%d) error=%d",val,ret);\r\npvr2_hdw_render_useless(hdw);\r\n}\r\nkfree(da);\r\n}\r\nint pvr2_hdw_cmd_deep_reset(struct pvr2_hdw *hdw)\r\n{\r\nreturn pvr2_issue_simple_cmd(hdw,FX2CMD_DEEP_RESET);\r\n}\r\nint pvr2_hdw_cmd_powerup(struct pvr2_hdw *hdw)\r\n{\r\nreturn pvr2_issue_simple_cmd(hdw,FX2CMD_POWER_ON);\r\n}\r\nint pvr2_hdw_cmd_powerdown(struct pvr2_hdw *hdw)\r\n{\r\nreturn pvr2_issue_simple_cmd(hdw,FX2CMD_POWER_OFF);\r\n}\r\nint pvr2_hdw_cmd_decoder_reset(struct pvr2_hdw *hdw)\r\n{\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Requesting decoder reset");\r\nif (hdw->decoder_client_id) {\r\nv4l2_device_call_all(&hdw->v4l2_dev, hdw->decoder_client_id,\r\ncore, reset, 0);\r\npvr2_hdw_cx25840_vbi_hack(hdw);\r\nreturn 0;\r\n}\r\npvr2_trace(PVR2_TRACE_INIT,\r\n"Unable to reset decoder: nothing attached");\r\nreturn -ENOTTY;\r\n}\r\nstatic int pvr2_hdw_cmd_hcw_demod_reset(struct pvr2_hdw *hdw, int onoff)\r\n{\r\nhdw->flag_ok = !0;\r\nreturn pvr2_issue_simple_cmd(hdw,\r\nFX2CMD_HCW_DEMOD_RESETIN |\r\n(1 << 8) |\r\n((onoff ? 1 : 0) << 16));\r\n}\r\nstatic int pvr2_hdw_cmd_onair_fe_power_ctrl(struct pvr2_hdw *hdw, int onoff)\r\n{\r\nhdw->flag_ok = !0;\r\nreturn pvr2_issue_simple_cmd(hdw,(onoff ?\r\nFX2CMD_ONAIR_DTV_POWER_ON :\r\nFX2CMD_ONAIR_DTV_POWER_OFF));\r\n}\r\nstatic int pvr2_hdw_cmd_onair_digital_path_ctrl(struct pvr2_hdw *hdw,\r\nint onoff)\r\n{\r\nreturn pvr2_issue_simple_cmd(hdw,(onoff ?\r\nFX2CMD_ONAIR_DTV_STREAMING_ON :\r\nFX2CMD_ONAIR_DTV_STREAMING_OFF));\r\n}\r\nstatic void pvr2_hdw_cmd_modeswitch(struct pvr2_hdw *hdw,int digitalFl)\r\n{\r\nint cmode;\r\ncmode = (digitalFl ? PVR2_PATHWAY_DIGITAL : PVR2_PATHWAY_ANALOG);\r\nif (cmode == hdw->pathway_state) {\r\nreturn;\r\n}\r\nswitch (hdw->hdw_desc->digital_control_scheme) {\r\ncase PVR2_DIGITAL_SCHEME_HAUPPAUGE:\r\npvr2_hdw_cmd_hcw_demod_reset(hdw,digitalFl);\r\nif (cmode == PVR2_PATHWAY_ANALOG) {\r\npvr2_hdw_cmd_decoder_reset(hdw);\r\n}\r\nbreak;\r\ncase PVR2_DIGITAL_SCHEME_ONAIR:\r\npvr2_hdw_cmd_onair_fe_power_ctrl(hdw,digitalFl);\r\nbreak;\r\ndefault: break;\r\n}\r\npvr2_hdw_untrip_unlocked(hdw);\r\nhdw->pathway_state = cmode;\r\n}\r\nstatic void pvr2_led_ctrl_hauppauge(struct pvr2_hdw *hdw, int onoff)\r\n{\r\nif (onoff) {\r\npvr2_hdw_gpio_chg_dir(hdw, 0xffffffff, 0x00000481);\r\n} else {\r\npvr2_hdw_gpio_chg_dir(hdw, 0xffffffff, 0x00000401);\r\n}\r\npvr2_hdw_gpio_chg_out(hdw, 0xffffffff, 0x00000000);\r\n}\r\nstatic void pvr2_led_ctrl(struct pvr2_hdw *hdw,int onoff)\r\n{\r\nunsigned int scheme_id;\r\nled_method_func fp;\r\nif ((!onoff) == (!hdw->led_on)) return;\r\nhdw->led_on = onoff != 0;\r\nscheme_id = hdw->hdw_desc->led_scheme;\r\nif (scheme_id < ARRAY_SIZE(led_methods)) {\r\nfp = led_methods[scheme_id];\r\n} else {\r\nfp = NULL;\r\n}\r\nif (fp) (*fp)(hdw,onoff);\r\n}\r\nstatic int pvr2_hdw_cmd_usbstream(struct pvr2_hdw *hdw,int runFl)\r\n{\r\nint ret;\r\nif (hdw->pathway_state == PVR2_PATHWAY_ANALOG) {\r\nreturn pvr2_issue_simple_cmd(hdw,\r\n(runFl ?\r\nFX2CMD_STREAMING_ON :\r\nFX2CMD_STREAMING_OFF));\r\n}\r\nif (hdw->pathway_state != PVR2_PATHWAY_DIGITAL) {\r\nreturn -EINVAL;\r\n}\r\nswitch (hdw->hdw_desc->digital_control_scheme) {\r\ncase PVR2_DIGITAL_SCHEME_HAUPPAUGE:\r\nreturn pvr2_issue_simple_cmd(hdw,\r\n(runFl ?\r\nFX2CMD_HCW_DTV_STREAMING_ON :\r\nFX2CMD_HCW_DTV_STREAMING_OFF));\r\ncase PVR2_DIGITAL_SCHEME_ONAIR:\r\nret = pvr2_issue_simple_cmd(hdw,\r\n(runFl ?\r\nFX2CMD_STREAMING_ON :\r\nFX2CMD_STREAMING_OFF));\r\nif (ret) return ret;\r\nreturn pvr2_hdw_cmd_onair_digital_path_ctrl(hdw,runFl);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int state_eval_pathway_ok(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_pathway_ok) {\r\nreturn 0;\r\n}\r\nif (!hdw->state_pipeline_idle) {\r\nreturn 0;\r\n}\r\npvr2_hdw_cmd_modeswitch(hdw,hdw->input_val == PVR2_CVAL_INPUT_DTV);\r\nhdw->state_pathway_ok = !0;\r\ntrace_stbit("state_pathway_ok",hdw->state_pathway_ok);\r\nreturn !0;\r\n}\r\nstatic int state_eval_encoder_ok(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_encoder_ok) return 0;\r\nif (hdw->flag_tripped) return 0;\r\nif (hdw->state_encoder_run) return 0;\r\nif (hdw->state_encoder_config) return 0;\r\nif (hdw->state_decoder_run) return 0;\r\nif (hdw->state_usbstream_run) return 0;\r\nif (hdw->pathway_state == PVR2_PATHWAY_DIGITAL) {\r\nif (!hdw->hdw_desc->flag_digital_requires_cx23416) return 0;\r\n} else if (hdw->pathway_state != PVR2_PATHWAY_ANALOG) {\r\nreturn 0;\r\n}\r\nif (pvr2_upload_firmware2(hdw) < 0) {\r\nhdw->flag_tripped = !0;\r\ntrace_stbit("flag_tripped",hdw->flag_tripped);\r\nreturn !0;\r\n}\r\nhdw->state_encoder_ok = !0;\r\ntrace_stbit("state_encoder_ok",hdw->state_encoder_ok);\r\nreturn !0;\r\n}\r\nstatic int state_eval_encoder_config(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_encoder_config) {\r\nif (hdw->state_encoder_ok) {\r\nif (hdw->state_pipeline_req &&\r\n!hdw->state_pipeline_pause) return 0;\r\n}\r\nhdw->state_encoder_config = 0;\r\nhdw->state_encoder_waitok = 0;\r\ntrace_stbit("state_encoder_waitok",hdw->state_encoder_waitok);\r\ndel_timer_sync(&hdw->encoder_wait_timer);\r\n} else {\r\nif (!hdw->state_pathway_ok ||\r\n(hdw->pathway_state != PVR2_PATHWAY_ANALOG) ||\r\n!hdw->state_encoder_ok ||\r\n!hdw->state_pipeline_idle ||\r\nhdw->state_pipeline_pause ||\r\n!hdw->state_pipeline_req ||\r\n!hdw->state_pipeline_config) {\r\nif (timer_pending(&hdw->encoder_wait_timer)) {\r\ndel_timer_sync(&hdw->encoder_wait_timer);\r\n}\r\nif (hdw->state_encoder_waitok) {\r\nhdw->state_encoder_waitok = 0;\r\ntrace_stbit("state_encoder_waitok",\r\nhdw->state_encoder_waitok);\r\nreturn !0;\r\n}\r\nreturn 0;\r\n}\r\nif (!hdw->state_encoder_waitok) {\r\nif (!timer_pending(&hdw->encoder_wait_timer)) {\r\nif (!hdw->state_encoder_waitok) {\r\nhdw->encoder_wait_timer.expires =\r\njiffies +\r\n(HZ * TIME_MSEC_ENCODER_WAIT\r\n/ 1000);\r\nadd_timer(&hdw->encoder_wait_timer);\r\n}\r\n}\r\nreturn 0;\r\n}\r\npvr2_encoder_configure(hdw);\r\nif (hdw->state_encoder_ok) hdw->state_encoder_config = !0;\r\n}\r\ntrace_stbit("state_encoder_config",hdw->state_encoder_config);\r\nreturn !0;\r\n}\r\nstatic int state_check_disable_encoder_run(struct pvr2_hdw *hdw)\r\n{\r\nif (!hdw->state_encoder_ok) {\r\nreturn !0;\r\n}\r\nif (!hdw->state_pathway_ok) {\r\nreturn !0;\r\n}\r\nswitch (hdw->pathway_state) {\r\ncase PVR2_PATHWAY_ANALOG:\r\nif (!hdw->state_decoder_run) {\r\nreturn !0;\r\n}\r\nbreak;\r\ncase PVR2_PATHWAY_DIGITAL:\r\nif (hdw->state_encoder_runok) {\r\nreturn !0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn !0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int state_check_enable_encoder_run(struct pvr2_hdw *hdw)\r\n{\r\nif (!hdw->state_encoder_ok) {\r\nreturn 0;\r\n}\r\nif (!hdw->state_pathway_ok) {\r\nreturn 0;\r\n}\r\nswitch (hdw->pathway_state) {\r\ncase PVR2_PATHWAY_ANALOG:\r\nif (hdw->state_decoder_run && hdw->state_decoder_ready) {\r\nreturn !0;\r\n}\r\nbreak;\r\ncase PVR2_PATHWAY_DIGITAL:\r\nif ((hdw->hdw_desc->digital_control_scheme ==\r\nPVR2_DIGITAL_SCHEME_ONAIR) &&\r\n!hdw->state_encoder_runok) {\r\nreturn !0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int state_eval_encoder_run(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_encoder_run) {\r\nif (!state_check_disable_encoder_run(hdw)) return 0;\r\nif (hdw->state_encoder_ok) {\r\ndel_timer_sync(&hdw->encoder_run_timer);\r\nif (pvr2_encoder_stop(hdw) < 0) return !0;\r\n}\r\nhdw->state_encoder_run = 0;\r\n} else {\r\nif (!state_check_enable_encoder_run(hdw)) return 0;\r\nif (pvr2_encoder_start(hdw) < 0) return !0;\r\nhdw->state_encoder_run = !0;\r\nif (!hdw->state_encoder_runok) {\r\nhdw->encoder_run_timer.expires =\r\njiffies + (HZ * TIME_MSEC_ENCODER_OK / 1000);\r\nadd_timer(&hdw->encoder_run_timer);\r\n}\r\n}\r\ntrace_stbit("state_encoder_run",hdw->state_encoder_run);\r\nreturn !0;\r\n}\r\nstatic void pvr2_hdw_quiescent_timeout(unsigned long data)\r\n{\r\nstruct pvr2_hdw *hdw = (struct pvr2_hdw *)data;\r\nhdw->state_decoder_quiescent = !0;\r\ntrace_stbit("state_decoder_quiescent",hdw->state_decoder_quiescent);\r\nhdw->state_stale = !0;\r\nqueue_work(hdw->workqueue,&hdw->workpoll);\r\n}\r\nstatic void pvr2_hdw_decoder_stabilization_timeout(unsigned long data)\r\n{\r\nstruct pvr2_hdw *hdw = (struct pvr2_hdw *)data;\r\nhdw->state_decoder_ready = !0;\r\ntrace_stbit("state_decoder_ready", hdw->state_decoder_ready);\r\nhdw->state_stale = !0;\r\nqueue_work(hdw->workqueue, &hdw->workpoll);\r\n}\r\nstatic void pvr2_hdw_encoder_wait_timeout(unsigned long data)\r\n{\r\nstruct pvr2_hdw *hdw = (struct pvr2_hdw *)data;\r\nhdw->state_encoder_waitok = !0;\r\ntrace_stbit("state_encoder_waitok",hdw->state_encoder_waitok);\r\nhdw->state_stale = !0;\r\nqueue_work(hdw->workqueue,&hdw->workpoll);\r\n}\r\nstatic void pvr2_hdw_encoder_run_timeout(unsigned long data)\r\n{\r\nstruct pvr2_hdw *hdw = (struct pvr2_hdw *)data;\r\nif (!hdw->state_encoder_runok) {\r\nhdw->state_encoder_runok = !0;\r\ntrace_stbit("state_encoder_runok",hdw->state_encoder_runok);\r\nhdw->state_stale = !0;\r\nqueue_work(hdw->workqueue,&hdw->workpoll);\r\n}\r\n}\r\nstatic int state_eval_decoder_run(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_decoder_run) {\r\nif (hdw->state_encoder_ok) {\r\nif (hdw->state_pipeline_req &&\r\n!hdw->state_pipeline_pause &&\r\nhdw->state_pathway_ok) return 0;\r\n}\r\nif (!hdw->flag_decoder_missed) {\r\npvr2_decoder_enable(hdw,0);\r\n}\r\nhdw->state_decoder_quiescent = 0;\r\nhdw->state_decoder_run = 0;\r\ndel_timer_sync(&hdw->quiescent_timer);\r\ndel_timer_sync(&hdw->decoder_stabilization_timer);\r\nhdw->state_decoder_ready = 0;\r\n} else {\r\nif (!hdw->state_decoder_quiescent) {\r\nif (!timer_pending(&hdw->quiescent_timer)) {\r\nif (!hdw->state_decoder_quiescent) {\r\nhdw->quiescent_timer.expires =\r\njiffies +\r\n(HZ * TIME_MSEC_DECODER_WAIT\r\n/ 1000);\r\nadd_timer(&hdw->quiescent_timer);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nif (!hdw->state_pathway_ok ||\r\n(hdw->pathway_state != PVR2_PATHWAY_ANALOG) ||\r\n!hdw->state_pipeline_req ||\r\nhdw->state_pipeline_pause ||\r\n!hdw->state_pipeline_config ||\r\n!hdw->state_encoder_config ||\r\n!hdw->state_encoder_ok) return 0;\r\ndel_timer_sync(&hdw->quiescent_timer);\r\nif (hdw->flag_decoder_missed) return 0;\r\nif (pvr2_decoder_enable(hdw,!0) < 0) return 0;\r\nhdw->state_decoder_quiescent = 0;\r\nhdw->state_decoder_ready = 0;\r\nhdw->state_decoder_run = !0;\r\nif (hdw->decoder_client_id == PVR2_CLIENT_ID_SAA7115) {\r\nhdw->decoder_stabilization_timer.expires =\r\njiffies +\r\n(HZ * TIME_MSEC_DECODER_STABILIZATION_WAIT /\r\n1000);\r\nadd_timer(&hdw->decoder_stabilization_timer);\r\n} else {\r\nhdw->state_decoder_ready = !0;\r\n}\r\n}\r\ntrace_stbit("state_decoder_quiescent",hdw->state_decoder_quiescent);\r\ntrace_stbit("state_decoder_run",hdw->state_decoder_run);\r\ntrace_stbit("state_decoder_ready", hdw->state_decoder_ready);\r\nreturn !0;\r\n}\r\nstatic int state_eval_usbstream_run(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_usbstream_run) {\r\nint fl = !0;\r\nif (hdw->pathway_state == PVR2_PATHWAY_ANALOG) {\r\nfl = (hdw->state_encoder_ok &&\r\nhdw->state_encoder_run);\r\n} else if ((hdw->pathway_state == PVR2_PATHWAY_DIGITAL) &&\r\n(hdw->hdw_desc->flag_digital_requires_cx23416)) {\r\nfl = hdw->state_encoder_ok;\r\n}\r\nif (fl &&\r\nhdw->state_pipeline_req &&\r\n!hdw->state_pipeline_pause &&\r\nhdw->state_pathway_ok) {\r\nreturn 0;\r\n}\r\npvr2_hdw_cmd_usbstream(hdw,0);\r\nhdw->state_usbstream_run = 0;\r\n} else {\r\nif (!hdw->state_pipeline_req ||\r\nhdw->state_pipeline_pause ||\r\n!hdw->state_pathway_ok) return 0;\r\nif (hdw->pathway_state == PVR2_PATHWAY_ANALOG) {\r\nif (!hdw->state_encoder_ok ||\r\n!hdw->state_encoder_run) return 0;\r\n} else if ((hdw->pathway_state == PVR2_PATHWAY_DIGITAL) &&\r\n(hdw->hdw_desc->flag_digital_requires_cx23416)) {\r\nif (!hdw->state_encoder_ok) return 0;\r\nif (hdw->state_encoder_run) return 0;\r\nif (hdw->hdw_desc->digital_control_scheme ==\r\nPVR2_DIGITAL_SCHEME_ONAIR) {\r\nif (!hdw->state_encoder_runok) return 0;\r\n}\r\n}\r\nif (pvr2_hdw_cmd_usbstream(hdw,!0) < 0) return 0;\r\nhdw->state_usbstream_run = !0;\r\n}\r\ntrace_stbit("state_usbstream_run",hdw->state_usbstream_run);\r\nreturn !0;\r\n}\r\nstatic int state_eval_pipeline_config(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_pipeline_config ||\r\nhdw->state_pipeline_pause) return 0;\r\npvr2_hdw_commit_execute(hdw);\r\nreturn !0;\r\n}\r\nstatic int state_update_pipeline_state(struct pvr2_hdw *hdw)\r\n{\r\nunsigned int st;\r\nint updatedFl = 0;\r\nst = !(hdw->state_encoder_run ||\r\nhdw->state_decoder_run ||\r\nhdw->state_usbstream_run ||\r\n(!hdw->state_decoder_quiescent));\r\nif (!st != !hdw->state_pipeline_idle) {\r\nhdw->state_pipeline_idle = st;\r\nupdatedFl = !0;\r\n}\r\nif (hdw->state_pipeline_idle && hdw->state_pipeline_pause) {\r\nhdw->state_pipeline_pause = 0;\r\nupdatedFl = !0;\r\n}\r\nreturn updatedFl;\r\n}\r\nstatic int pvr2_hdw_state_update(struct pvr2_hdw *hdw)\r\n{\r\nunsigned int i;\r\nint state_updated = 0;\r\nint check_flag;\r\nif (!hdw->state_stale) return 0;\r\nif ((hdw->fw1_state != FW1_STATE_OK) ||\r\n!hdw->flag_ok) {\r\nhdw->state_stale = 0;\r\nreturn !0;\r\n}\r\ndo {\r\ncheck_flag = 0;\r\nstate_update_pipeline_state(hdw);\r\nfor (i = 0; (i<ARRAY_SIZE(eval_funcs)) && hdw->flag_ok; i++) {\r\nif ((*eval_funcs[i])(hdw)) {\r\ncheck_flag = !0;\r\nstate_updated = !0;\r\nstate_update_pipeline_state(hdw);\r\n}\r\n}\r\n} while (check_flag && hdw->flag_ok);\r\nhdw->state_stale = 0;\r\ntrace_stbit("state_stale",hdw->state_stale);\r\nreturn state_updated;\r\n}\r\nstatic unsigned int print_input_mask(unsigned int msk,\r\nchar *buf,unsigned int acnt)\r\n{\r\nunsigned int idx,ccnt;\r\nunsigned int tcnt = 0;\r\nfor (idx = 0; idx < ARRAY_SIZE(control_values_input); idx++) {\r\nif (!((1 << idx) & msk)) continue;\r\nccnt = scnprintf(buf+tcnt,\r\nacnt-tcnt,\r\n"%s%s",\r\n(tcnt ? ", " : ""),\r\ncontrol_values_input[idx]);\r\ntcnt += ccnt;\r\n}\r\nreturn tcnt;\r\n}\r\nstatic const char *pvr2_pathway_state_name(int id)\r\n{\r\nswitch (id) {\r\ncase PVR2_PATHWAY_ANALOG: return "analog";\r\ncase PVR2_PATHWAY_DIGITAL: return "digital";\r\ndefault: return "unknown";\r\n}\r\n}\r\nstatic unsigned int pvr2_hdw_report_unlocked(struct pvr2_hdw *hdw,int which,\r\nchar *buf,unsigned int acnt)\r\n{\r\nswitch (which) {\r\ncase 0:\r\nreturn scnprintf(\r\nbuf,acnt,\r\n"driver:%s%s%s%s%s <mode=%s>",\r\n(hdw->flag_ok ? " <ok>" : " <fail>"),\r\n(hdw->flag_init_ok ? " <init>" : " <uninitialized>"),\r\n(hdw->flag_disconnected ? " <disconnected>" :\r\n" <connected>"),\r\n(hdw->flag_tripped ? " <tripped>" : ""),\r\n(hdw->flag_decoder_missed ? " <no decoder>" : ""),\r\npvr2_pathway_state_name(hdw->pathway_state));\r\ncase 1:\r\nreturn scnprintf(\r\nbuf,acnt,\r\n"pipeline:%s%s%s%s",\r\n(hdw->state_pipeline_idle ? " <idle>" : ""),\r\n(hdw->state_pipeline_config ?\r\n" <configok>" : " <stale>"),\r\n(hdw->state_pipeline_req ? " <req>" : ""),\r\n(hdw->state_pipeline_pause ? " <pause>" : ""));\r\ncase 2:\r\nreturn scnprintf(\r\nbuf,acnt,\r\n"worker:%s%s%s%s%s%s%s",\r\n(hdw->state_decoder_run ?\r\n(hdw->state_decoder_ready ?\r\n"<decode:run>" : " <decode:start>") :\r\n(hdw->state_decoder_quiescent ?\r\n"" : " <decode:stop>")),\r\n(hdw->state_decoder_quiescent ?\r\n" <decode:quiescent>" : ""),\r\n(hdw->state_encoder_ok ?\r\n"" : " <encode:init>"),\r\n(hdw->state_encoder_run ?\r\n(hdw->state_encoder_runok ?\r\n" <encode:run>" :\r\n" <encode:firstrun>") :\r\n(hdw->state_encoder_runok ?\r\n" <encode:stop>" :\r\n" <encode:virgin>")),\r\n(hdw->state_encoder_config ?\r\n" <encode:configok>" :\r\n(hdw->state_encoder_waitok ?\r\n"" : " <encode:waitok>")),\r\n(hdw->state_usbstream_run ?\r\n" <usb:run>" : " <usb:stop>"),\r\n(hdw->state_pathway_ok ?\r\n" <pathway:ok>" : ""));\r\ncase 3:\r\nreturn scnprintf(\r\nbuf,acnt,\r\n"state: %s",\r\npvr2_get_state_name(hdw->master_state));\r\ncase 4: {\r\nunsigned int tcnt = 0;\r\nunsigned int ccnt;\r\nccnt = scnprintf(buf,\r\nacnt,\r\n"Hardware supported inputs: ");\r\ntcnt += ccnt;\r\ntcnt += print_input_mask(hdw->input_avail_mask,\r\nbuf+tcnt,\r\nacnt-tcnt);\r\nif (hdw->input_avail_mask != hdw->input_allowed_mask) {\r\nccnt = scnprintf(buf+tcnt,\r\nacnt-tcnt,\r\n"; allowed inputs: ");\r\ntcnt += ccnt;\r\ntcnt += print_input_mask(hdw->input_allowed_mask,\r\nbuf+tcnt,\r\nacnt-tcnt);\r\n}\r\nreturn tcnt;\r\n}\r\ncase 5: {\r\nstruct pvr2_stream_stats stats;\r\nif (!hdw->vid_stream) break;\r\npvr2_stream_get_stats(hdw->vid_stream,\r\n&stats,\r\n0);\r\nreturn scnprintf(\r\nbuf,acnt,\r\n"Bytes streamed=%u"\r\n" URBs: queued=%u idle=%u ready=%u"\r\n" processed=%u failed=%u",\r\nstats.bytes_processed,\r\nstats.buffers_in_queue,\r\nstats.buffers_in_idle,\r\nstats.buffers_in_ready,\r\nstats.buffers_processed,\r\nstats.buffers_failed);\r\n}\r\ncase 6: {\r\nunsigned int id = hdw->ir_scheme_active;\r\nreturn scnprintf(buf, acnt, "ir scheme: id=%d %s", id,\r\n(id >= ARRAY_SIZE(ir_scheme_names) ?\r\n"?" : ir_scheme_names[id]));\r\n}\r\ndefault: break;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pvr2_hdw_report_clients(struct pvr2_hdw *hdw,\r\nchar *buf, unsigned int acnt)\r\n{\r\nstruct v4l2_subdev *sd;\r\nunsigned int tcnt = 0;\r\nunsigned int ccnt;\r\nstruct i2c_client *client;\r\nconst char *p;\r\nunsigned int id;\r\nccnt = scnprintf(buf, acnt, "Associated v4l2-subdev drivers and I2C clients:\n");\r\ntcnt += ccnt;\r\nv4l2_device_for_each_subdev(sd, &hdw->v4l2_dev) {\r\nid = sd->grp_id;\r\np = NULL;\r\nif (id < ARRAY_SIZE(module_names)) p = module_names[id];\r\nif (p) {\r\nccnt = scnprintf(buf + tcnt, acnt - tcnt, " %s:", p);\r\ntcnt += ccnt;\r\n} else {\r\nccnt = scnprintf(buf + tcnt, acnt - tcnt,\r\n" (unknown id=%u):", id);\r\ntcnt += ccnt;\r\n}\r\nclient = v4l2_get_subdevdata(sd);\r\nif (client) {\r\nccnt = scnprintf(buf + tcnt, acnt - tcnt,\r\n" %s @ %02x\n", client->name,\r\nclient->addr);\r\ntcnt += ccnt;\r\n} else {\r\nccnt = scnprintf(buf + tcnt, acnt - tcnt,\r\n" no i2c client\n");\r\ntcnt += ccnt;\r\n}\r\n}\r\nreturn tcnt;\r\n}\r\nunsigned int pvr2_hdw_state_report(struct pvr2_hdw *hdw,\r\nchar *buf,unsigned int acnt)\r\n{\r\nunsigned int bcnt,ccnt,idx;\r\nbcnt = 0;\r\nLOCK_TAKE(hdw->big_lock);\r\nfor (idx = 0; ; idx++) {\r\nccnt = pvr2_hdw_report_unlocked(hdw,idx,buf,acnt);\r\nif (!ccnt) break;\r\nbcnt += ccnt; acnt -= ccnt; buf += ccnt;\r\nif (!acnt) break;\r\nbuf[0] = '\n'; ccnt = 1;\r\nbcnt += ccnt; acnt -= ccnt; buf += ccnt;\r\n}\r\nccnt = pvr2_hdw_report_clients(hdw, buf, acnt);\r\nbcnt += ccnt; acnt -= ccnt; buf += ccnt;\r\nLOCK_GIVE(hdw->big_lock);\r\nreturn bcnt;\r\n}\r\nstatic void pvr2_hdw_state_log_state(struct pvr2_hdw *hdw)\r\n{\r\nchar buf[256];\r\nunsigned int idx, ccnt;\r\nunsigned int lcnt, ucnt;\r\nfor (idx = 0; ; idx++) {\r\nccnt = pvr2_hdw_report_unlocked(hdw,idx,buf,sizeof(buf));\r\nif (!ccnt) break;\r\nprintk(KERN_INFO "%s %.*s\n",hdw->name,ccnt,buf);\r\n}\r\nccnt = pvr2_hdw_report_clients(hdw, buf, sizeof(buf));\r\nucnt = 0;\r\nwhile (ucnt < ccnt) {\r\nlcnt = 0;\r\nwhile ((lcnt + ucnt < ccnt) && (buf[lcnt + ucnt] != '\n')) {\r\nlcnt++;\r\n}\r\nprintk(KERN_INFO "%s %.*s\n", hdw->name, lcnt, buf + ucnt);\r\nucnt += lcnt + 1;\r\n}\r\n}\r\nstatic int pvr2_hdw_state_eval(struct pvr2_hdw *hdw)\r\n{\r\nunsigned int st;\r\nint state_updated = 0;\r\nint callback_flag = 0;\r\nint analog_mode;\r\npvr2_trace(PVR2_TRACE_STBITS,\r\n"Drive state check START");\r\nif (pvrusb2_debug & PVR2_TRACE_STBITS) {\r\npvr2_hdw_state_log_state(hdw);\r\n}\r\nstate_updated = pvr2_hdw_state_update(hdw);\r\nanalog_mode = (hdw->pathway_state != PVR2_PATHWAY_DIGITAL);\r\nif (!hdw->flag_ok) {\r\nst = PVR2_STATE_DEAD;\r\n} else if (hdw->fw1_state != FW1_STATE_OK) {\r\nst = PVR2_STATE_COLD;\r\n} else if ((analog_mode ||\r\nhdw->hdw_desc->flag_digital_requires_cx23416) &&\r\n!hdw->state_encoder_ok) {\r\nst = PVR2_STATE_WARM;\r\n} else if (hdw->flag_tripped ||\r\n(analog_mode && hdw->flag_decoder_missed)) {\r\nst = PVR2_STATE_ERROR;\r\n} else if (hdw->state_usbstream_run &&\r\n(!analog_mode ||\r\n(hdw->state_encoder_run && hdw->state_decoder_run))) {\r\nst = PVR2_STATE_RUN;\r\n} else {\r\nst = PVR2_STATE_READY;\r\n}\r\nif (hdw->master_state != st) {\r\npvr2_trace(PVR2_TRACE_STATE,\r\n"Device state change from %s to %s",\r\npvr2_get_state_name(hdw->master_state),\r\npvr2_get_state_name(st));\r\npvr2_led_ctrl(hdw,st == PVR2_STATE_RUN);\r\nhdw->master_state = st;\r\nstate_updated = !0;\r\ncallback_flag = !0;\r\n}\r\nif (state_updated) {\r\nwake_up(&hdw->state_wait_data);\r\n}\r\nif (pvrusb2_debug & PVR2_TRACE_STBITS) {\r\npvr2_hdw_state_log_state(hdw);\r\n}\r\npvr2_trace(PVR2_TRACE_STBITS,\r\n"Drive state check DONE callback=%d",callback_flag);\r\nreturn callback_flag;\r\n}\r\nstatic void pvr2_hdw_state_sched(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->state_stale) return;\r\nhdw->state_stale = !0;\r\ntrace_stbit("state_stale",hdw->state_stale);\r\nqueue_work(hdw->workqueue,&hdw->workpoll);\r\n}\r\nint pvr2_hdw_gpio_get_dir(struct pvr2_hdw *hdw,u32 *dp)\r\n{\r\nreturn pvr2_read_register(hdw,PVR2_GPIO_DIR,dp);\r\n}\r\nint pvr2_hdw_gpio_get_out(struct pvr2_hdw *hdw,u32 *dp)\r\n{\r\nreturn pvr2_read_register(hdw,PVR2_GPIO_OUT,dp);\r\n}\r\nint pvr2_hdw_gpio_get_in(struct pvr2_hdw *hdw,u32 *dp)\r\n{\r\nreturn pvr2_read_register(hdw,PVR2_GPIO_IN,dp);\r\n}\r\nint pvr2_hdw_gpio_chg_dir(struct pvr2_hdw *hdw,u32 msk,u32 val)\r\n{\r\nu32 cval,nval;\r\nint ret;\r\nif (~msk) {\r\nret = pvr2_read_register(hdw,PVR2_GPIO_DIR,&cval);\r\nif (ret) return ret;\r\nnval = (cval & ~msk) | (val & msk);\r\npvr2_trace(PVR2_TRACE_GPIO,\r\n"GPIO direction changing 0x%x:0x%x"\r\n" from 0x%x to 0x%x",\r\nmsk,val,cval,nval);\r\n} else {\r\nnval = val;\r\npvr2_trace(PVR2_TRACE_GPIO,\r\n"GPIO direction changing to 0x%x",nval);\r\n}\r\nreturn pvr2_write_register(hdw,PVR2_GPIO_DIR,nval);\r\n}\r\nint pvr2_hdw_gpio_chg_out(struct pvr2_hdw *hdw,u32 msk,u32 val)\r\n{\r\nu32 cval,nval;\r\nint ret;\r\nif (~msk) {\r\nret = pvr2_read_register(hdw,PVR2_GPIO_OUT,&cval);\r\nif (ret) return ret;\r\nnval = (cval & ~msk) | (val & msk);\r\npvr2_trace(PVR2_TRACE_GPIO,\r\n"GPIO output changing 0x%x:0x%x from 0x%x to 0x%x",\r\nmsk,val,cval,nval);\r\n} else {\r\nnval = val;\r\npvr2_trace(PVR2_TRACE_GPIO,\r\n"GPIO output changing to 0x%x",nval);\r\n}\r\nreturn pvr2_write_register(hdw,PVR2_GPIO_OUT,nval);\r\n}\r\nvoid pvr2_hdw_status_poll(struct pvr2_hdw *hdw)\r\n{\r\nstruct v4l2_tuner *vtp = &hdw->tuner_signal_info;\r\nmemset(vtp, 0, sizeof(*vtp));\r\nvtp->type = (hdw->input_val == PVR2_CVAL_INPUT_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nhdw->tuner_signal_stale = 0;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, tuner, g_tuner, vtp);\r\npvr2_trace(PVR2_TRACE_CHIPS, "subdev status poll"\r\n" type=%u strength=%u audio=0x%x cap=0x%x"\r\n" low=%u hi=%u",\r\nvtp->type,\r\nvtp->signal, vtp->rxsubchans, vtp->capability,\r\nvtp->rangelow, vtp->rangehigh);\r\nhdw->cropcap_stale = 0;\r\n}\r\nunsigned int pvr2_hdw_get_input_available(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->input_avail_mask;\r\n}\r\nunsigned int pvr2_hdw_get_input_allowed(struct pvr2_hdw *hdw)\r\n{\r\nreturn hdw->input_allowed_mask;\r\n}\r\nstatic int pvr2_hdw_set_input(struct pvr2_hdw *hdw,int v)\r\n{\r\nif (hdw->input_val != v) {\r\nhdw->input_val = v;\r\nhdw->input_dirty = !0;\r\n}\r\nif (hdw->input_val == PVR2_CVAL_INPUT_RADIO) {\r\nhdw->freqSelector = 0;\r\nhdw->freqDirty = !0;\r\n} else if ((hdw->input_val == PVR2_CVAL_INPUT_TV) ||\r\n(hdw->input_val == PVR2_CVAL_INPUT_DTV)) {\r\nhdw->freqSelector = 1;\r\nhdw->freqDirty = !0;\r\n}\r\nreturn 0;\r\n}\r\nint pvr2_hdw_set_input_allowed(struct pvr2_hdw *hdw,\r\nunsigned int change_mask,\r\nunsigned int change_val)\r\n{\r\nint ret = 0;\r\nunsigned int nv,m,idx;\r\nLOCK_TAKE(hdw->big_lock);\r\ndo {\r\nnv = hdw->input_allowed_mask & ~change_mask;\r\nnv |= (change_val & change_mask);\r\nnv &= hdw->input_avail_mask;\r\nif (!nv) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nhdw->input_allowed_mask = nv;\r\nif ((1 << hdw->input_val) & hdw->input_allowed_mask) {\r\nbreak;\r\n}\r\nif (!hdw->input_allowed_mask) {\r\nbreak;\r\n}\r\nm = hdw->input_allowed_mask;\r\nfor (idx = 0; idx < (sizeof(m) << 3); idx++) {\r\nif (!((1 << idx) & m)) continue;\r\npvr2_hdw_set_input(hdw,idx);\r\nbreak;\r\n}\r\n} while (0);\r\nLOCK_GIVE(hdw->big_lock);\r\nreturn ret;\r\n}\r\nstatic int pvr2_hdw_get_eeprom_addr(struct pvr2_hdw *hdw)\r\n{\r\nint result;\r\nLOCK_TAKE(hdw->ctl_lock); do {\r\nhdw->cmd_buffer[0] = FX2CMD_GET_EEPROM_ADDR;\r\nresult = pvr2_send_request(hdw,\r\nhdw->cmd_buffer,1,\r\nhdw->cmd_buffer,1);\r\nif (result < 0) break;\r\nresult = hdw->cmd_buffer[0];\r\n} while(0); LOCK_GIVE(hdw->ctl_lock);\r\nreturn result;\r\n}\r\nint pvr2_hdw_register_access(struct pvr2_hdw *hdw,\r\nstruct v4l2_dbg_match *match, u64 reg_id,\r\nint setFl, u64 *val_ptr)\r\n{\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nstruct v4l2_dbg_register req;\r\nint stat = 0;\r\nint okFl = 0;\r\nif (!capable(CAP_SYS_ADMIN)) return -EPERM;\r\nreq.match = *match;\r\nreq.reg = reg_id;\r\nif (setFl) req.val = *val_ptr;\r\nv4l2_device_call_all(&hdw->v4l2_dev, 0, core, g_register, &req);\r\nif (!setFl) *val_ptr = req.val;\r\nif (okFl) {\r\nreturn stat;\r\n}\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENOSYS;\r\n#endif\r\n}
