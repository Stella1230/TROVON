static inline int __iio_allocate_kfifo(struct iio_kfifo *buf,\r\nint bytes_per_datum, int length)\r\n{\r\nif ((length == 0) || (bytes_per_datum == 0))\r\nreturn -EINVAL;\r\n__iio_update_buffer(&buf->buffer, bytes_per_datum, length);\r\nreturn kfifo_alloc(&buf->kf, bytes_per_datum*length, GFP_KERNEL);\r\n}\r\nstatic int iio_request_update_kfifo(struct iio_buffer *r)\r\n{\r\nint ret = 0;\r\nstruct iio_kfifo *buf = iio_to_kfifo(r);\r\nif (!buf->update_needed)\r\ngoto error_ret;\r\nkfifo_free(&buf->kf);\r\nret = __iio_allocate_kfifo(buf, buf->buffer.bytes_per_datum,\r\nbuf->buffer.length);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int iio_get_length_kfifo(struct iio_buffer *r)\r\n{\r\nreturn r->length;\r\n}\r\nstatic int iio_get_bytes_per_datum_kfifo(struct iio_buffer *r)\r\n{\r\nreturn r->bytes_per_datum;\r\n}\r\nstatic int iio_mark_update_needed_kfifo(struct iio_buffer *r)\r\n{\r\nstruct iio_kfifo *kf = iio_to_kfifo(r);\r\nkf->update_needed = true;\r\nreturn 0;\r\n}\r\nstatic int iio_set_bytes_per_datum_kfifo(struct iio_buffer *r, size_t bpd)\r\n{\r\nif (r->bytes_per_datum != bpd) {\r\nr->bytes_per_datum = bpd;\r\niio_mark_update_needed_kfifo(r);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_set_length_kfifo(struct iio_buffer *r, int length)\r\n{\r\nif (r->length != length) {\r\nr->length = length;\r\niio_mark_update_needed_kfifo(r);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_store_to_kfifo(struct iio_buffer *r,\r\nu8 *data,\r\ns64 timestamp)\r\n{\r\nint ret;\r\nstruct iio_kfifo *kf = iio_to_kfifo(r);\r\nret = kfifo_in(&kf->kf, data, r->bytes_per_datum);\r\nif (ret != r->bytes_per_datum)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int iio_read_first_n_kfifo(struct iio_buffer *r,\r\nsize_t n, char __user *buf)\r\n{\r\nint ret, copied;\r\nstruct iio_kfifo *kf = iio_to_kfifo(r);\r\nif (n < r->bytes_per_datum)\r\nreturn -EINVAL;\r\nn = rounddown(n, r->bytes_per_datum);\r\nret = kfifo_to_user(&kf->kf, buf, n, &copied);\r\nreturn copied;\r\n}\r\nstruct iio_buffer *iio_kfifo_allocate(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_kfifo *kf;\r\nkf = kzalloc(sizeof *kf, GFP_KERNEL);\r\nif (!kf)\r\nreturn NULL;\r\nkf->update_needed = true;\r\niio_buffer_init(&kf->buffer);\r\nkf->buffer.attrs = &iio_kfifo_attribute_group;\r\nkf->buffer.access = &kfifo_access_funcs;\r\nreturn &kf->buffer;\r\n}\r\nvoid iio_kfifo_free(struct iio_buffer *r)\r\n{\r\nkfree(iio_to_kfifo(r));\r\n}
