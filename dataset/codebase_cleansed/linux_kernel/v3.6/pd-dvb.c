static int poseidon_check_mode_dvbt(struct poseidon *pd)\r\n{\r\ns32 ret = 0, cmd_status = 0;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/4);\r\nret = usb_set_interface(pd->udev, 0, BULK_ALTERNATE_IFACE);\r\nif (ret != 0)\r\nreturn ret;\r\nret = set_tuner_mode(pd, TLG_MODE_CAPS_DVB_T);\r\nif (ret)\r\nreturn ret;\r\nret = send_set_req(pd, SGNL_SRC_SEL, TLG_SIG_SRC_ANTENNA, &cmd_status);\r\nif (ret|cmd_status)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int poseidon_ts_bus_ctrl(struct dvb_frontend *fe, int acquire)\r\n{\r\nstruct poseidon *pd = fe->demodulator_priv;\r\nstruct pd_dvb_adapter *pd_dvb;\r\nint ret = 0;\r\nif (!pd)\r\nreturn -ENODEV;\r\npd_dvb = container_of(fe, struct pd_dvb_adapter, dvb_fe);\r\nif (acquire) {\r\nmutex_lock(&pd->lock);\r\nif (pd->state & POSEIDON_STATE_DISCONNECT) {\r\nret = -ENODEV;\r\ngoto open_out;\r\n}\r\nif (pd->state && !(pd->state & POSEIDON_STATE_DVBT)) {\r\nret = -EBUSY;\r\ngoto open_out;\r\n}\r\nusb_autopm_get_interface(pd->interface);\r\nif (0 == pd->state) {\r\nret = poseidon_check_mode_dvbt(pd);\r\nif (ret < 0) {\r\nusb_autopm_put_interface(pd->interface);\r\ngoto open_out;\r\n}\r\npd->state |= POSEIDON_STATE_DVBT;\r\npd_dvb->bandwidth = 0;\r\npd_dvb->prev_freq = 0;\r\n}\r\natomic_inc(&pd_dvb->users);\r\nkref_get(&pd->kref);\r\nopen_out:\r\nmutex_unlock(&pd->lock);\r\n} else {\r\ndvb_stop_streaming(pd_dvb);\r\nif (atomic_dec_and_test(&pd_dvb->users)) {\r\nmutex_lock(&pd->lock);\r\npd->state &= ~POSEIDON_STATE_DVBT;\r\nmutex_unlock(&pd->lock);\r\n}\r\nkref_put(&pd->kref, poseidon_delete);\r\nusb_autopm_put_interface(pd->interface);\r\n}\r\nreturn ret;\r\n}\r\nstatic void poseidon_fe_release(struct dvb_frontend *fe)\r\n{\r\nstruct poseidon *pd = fe->demodulator_priv;\r\npd->pm_suspend = NULL;\r\npd->pm_resume = NULL;\r\n}\r\nstatic s32 poseidon_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool check_scan_ok(__u32 freq, int bandwidth,\r\nstruct pd_dvb_adapter *adapter)\r\n{\r\nif (bandwidth < 0)\r\nreturn false;\r\nif (adapter->prev_freq == freq\r\n&& adapter->bandwidth == bandwidth) {\r\nlong nl = jiffies - adapter->last_jiffies;\r\nunsigned int msec ;\r\nmsec = jiffies_to_msecs(abs(nl));\r\nreturn msec > 15000 ? true : false;\r\n}\r\nreturn true;\r\n}\r\nstatic int fw_delay_overflow(struct pd_dvb_adapter *adapter)\r\n{\r\nlong nl = jiffies - adapter->last_jiffies;\r\nunsigned int msec ;\r\nmsec = jiffies_to_msecs(abs(nl));\r\nreturn msec > 800 ? true : false;\r\n}\r\nstatic int poseidon_set_fe(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\r\ns32 ret = 0, cmd_status = 0;\r\ns32 i, bandwidth = -1;\r\nstruct poseidon *pd = fe->demodulator_priv;\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\nif (in_hibernation(pd))\r\nreturn -EBUSY;\r\nmutex_lock(&pd->lock);\r\nfor (i = 0; i < dvb_bandwidth_length; i++)\r\nif (fep->bandwidth_hz == dvb_bandwidth[i][1])\r\nbandwidth = dvb_bandwidth[i][0];\r\nif (check_scan_ok(fep->frequency, bandwidth, pd_dvb)) {\r\nret = send_set_req(pd, TUNE_FREQ_SELECT,\r\nfep->frequency / 1000, &cmd_status);\r\nif (ret | cmd_status) {\r\nlog("error line");\r\ngoto front_out;\r\n}\r\nret = send_set_req(pd, DVBT_BANDW_SEL,\r\nbandwidth, &cmd_status);\r\nif (ret | cmd_status) {\r\nlog("error line");\r\ngoto front_out;\r\n}\r\nret = send_set_req(pd, TAKE_REQUEST, 0, &cmd_status);\r\nif (ret | cmd_status) {\r\nlog("error line");\r\ngoto front_out;\r\n}\r\nmemcpy(&pd_dvb->fe_param, fep, sizeof(*fep));\r\npd_dvb->bandwidth = bandwidth;\r\npd_dvb->prev_freq = fep->frequency;\r\npd_dvb->last_jiffies = jiffies;\r\n}\r\nfront_out:\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic int pm_dvb_suspend(struct poseidon *pd)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\ndvb_stop_streaming(pd_dvb);\r\ndvb_urb_cleanup(pd_dvb);\r\nmsleep(500);\r\nreturn 0;\r\n}\r\nstatic int pm_dvb_resume(struct poseidon *pd)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\nposeidon_check_mode_dvbt(pd);\r\nmsleep(300);\r\nposeidon_set_fe(&pd_dvb->dvb_fe);\r\ndvb_start_streaming(pd_dvb);\r\nreturn 0;\r\n}\r\nstatic s32 poseidon_fe_init(struct dvb_frontend *fe)\r\n{\r\nstruct poseidon *pd = fe->demodulator_priv;\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\n#ifdef CONFIG_PM\r\npd->pm_suspend = pm_dvb_suspend;\r\npd->pm_resume = pm_dvb_resume;\r\n#endif\r\nmemset(&pd_dvb->fe_param, 0,\r\nsizeof(struct dtv_frontend_properties));\r\nreturn 0;\r\n}\r\nstatic int poseidon_get_fe(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\r\nstruct poseidon *pd = fe->demodulator_priv;\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\nmemcpy(fep, &pd_dvb->fe_param, sizeof(*fep));\r\nreturn 0;\r\n}\r\nstatic int poseidon_fe_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int poseidon_read_status(struct dvb_frontend *fe, fe_status_t *stat)\r\n{\r\nstruct poseidon *pd = fe->demodulator_priv;\r\ns32 ret = -1, cmd_status;\r\nstruct tuner_dtv_sig_stat_s status = {};\r\nif (in_hibernation(pd))\r\nreturn -EBUSY;\r\nmutex_lock(&pd->lock);\r\nret = send_get_req(pd, TUNER_STATUS, TLG_MODE_DVB_T,\r\n&status, &cmd_status, sizeof(status));\r\nif (ret | cmd_status) {\r\nlog("get tuner status error");\r\ngoto out;\r\n}\r\nif (debug_mode)\r\nlog("P : %d, L %d, LB :%d", status.sig_present,\r\nstatus.sig_locked, status.sig_lock_busy);\r\nif (status.sig_lock_busy) {\r\ngoto out;\r\n} else if (status.sig_present || status.sig_locked) {\r\n*stat |= FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER\r\n| FE_HAS_SYNC | FE_HAS_VITERBI;\r\n} else {\r\nif (fw_delay_overflow(&pd->dvb_data))\r\n*stat |= FE_TIMEDOUT;\r\n}\r\nout:\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic int poseidon_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct poseidon *pd = fe->demodulator_priv;\r\nstruct tuner_ber_rate_s tlg_ber = {};\r\ns32 ret = -1, cmd_status;\r\nmutex_lock(&pd->lock);\r\nret = send_get_req(pd, TUNER_BER_RATE, 0,\r\n&tlg_ber, &cmd_status, sizeof(tlg_ber));\r\nif (ret | cmd_status)\r\ngoto out;\r\n*ber = tlg_ber.ber_rate;\r\nout:\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic s32 poseidon_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct poseidon *pd = fe->demodulator_priv;\r\nstruct tuner_dtv_sig_stat_s status = {};\r\ns32 ret = 0, cmd_status;\r\nmutex_lock(&pd->lock);\r\nret = send_get_req(pd, TUNER_STATUS, TLG_MODE_DVB_T,\r\n&status, &cmd_status, sizeof(status));\r\nif (ret | cmd_status)\r\ngoto out;\r\nif ((status.sig_present || status.sig_locked) && !status.sig_strength)\r\n*strength = 0xFFFF;\r\nelse\r\n*strength = status.sig_strength;\r\nout:\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic int poseidon_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int poseidon_read_unc_blocks(struct dvb_frontend *fe, u32 *unc)\r\n{\r\n*unc = 0;\r\nreturn 0;\r\n}\r\nstatic void dvb_urb_irq(struct urb *urb)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = urb->context;\r\nint len = urb->transfer_buffer_length;\r\nstruct dvb_demux *demux = &pd_dvb->demux;\r\ns32 ret;\r\nif (!pd_dvb->is_streaming || urb->status) {\r\nif (urb->status == -EPROTO)\r\ngoto resend;\r\nreturn;\r\n}\r\nif (urb->actual_length == len)\r\ndvb_dmx_swfilter(demux, urb->transfer_buffer, len);\r\nelse if (urb->actual_length == len - 4) {\r\nint offset;\r\nu8 *buf = urb->transfer_buffer;\r\nfor (offset = 456; offset < len; offset += 512) {\r\nif (!strncmp(buf + offset, "DVHS", 4)) {\r\ndvb_dmx_swfilter(demux, buf, offset);\r\nif (len > offset + 52 + 4) {\r\nbuf += offset + 52;\r\nlen -= offset + 52 + 4;\r\ndvb_dmx_swfilter(demux, buf, len);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nresend:\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\nlog(" usb_submit_urb failed: error %d", ret);\r\n}\r\nstatic int dvb_urb_init(struct pd_dvb_adapter *pd_dvb)\r\n{\r\nif (pd_dvb->urb_array[0])\r\nreturn 0;\r\nalloc_bulk_urbs_generic(pd_dvb->urb_array, DVB_SBUF_NUM,\r\npd_dvb->pd_device->udev, pd_dvb->ep_addr,\r\nDVB_URB_BUF_SIZE, GFP_KERNEL,\r\ndvb_urb_irq, pd_dvb);\r\nreturn 0;\r\n}\r\nstatic void dvb_urb_cleanup(struct pd_dvb_adapter *pd_dvb)\r\n{\r\nfree_all_urb_generic(pd_dvb->urb_array, DVB_SBUF_NUM);\r\n}\r\nstatic s32 dvb_start_streaming(struct pd_dvb_adapter *pd_dvb)\r\n{\r\nstruct poseidon *pd = pd_dvb->pd_device;\r\nint ret = 0;\r\nif (pd->state & POSEIDON_STATE_DISCONNECT)\r\nreturn -ENODEV;\r\nmutex_lock(&pd->lock);\r\nif (!pd_dvb->is_streaming) {\r\ns32 i, cmd_status = 0;\r\nret = send_set_req(pd, PLAY_SERVICE, 1, &cmd_status);\r\nif (ret | cmd_status)\r\ngoto out;\r\nret = dvb_urb_init(pd_dvb);\r\nif (ret < 0)\r\ngoto out;\r\npd_dvb->is_streaming = 1;\r\nfor (i = 0; i < DVB_SBUF_NUM; i++) {\r\nret = usb_submit_urb(pd_dvb->urb_array[i],\r\nGFP_KERNEL);\r\nif (ret) {\r\nlog(" submit urb error %d", ret);\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nvoid dvb_stop_streaming(struct pd_dvb_adapter *pd_dvb)\r\n{\r\nstruct poseidon *pd = pd_dvb->pd_device;\r\nmutex_lock(&pd->lock);\r\nif (pd_dvb->is_streaming) {\r\ns32 i, ret, cmd_status = 0;\r\npd_dvb->is_streaming = 0;\r\nfor (i = 0; i < DVB_SBUF_NUM; i++)\r\nif (pd_dvb->urb_array[i])\r\nusb_kill_urb(pd_dvb->urb_array[i]);\r\nret = send_set_req(pd, PLAY_SERVICE, TLG_TUNE_PLAY_SVC_STOP,\r\n&cmd_status);\r\nif (ret | cmd_status)\r\nlog("error");\r\n}\r\nmutex_unlock(&pd->lock);\r\n}\r\nstatic int pd_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = feed->demux->priv;\r\nint ret = 0;\r\nif (!pd_dvb)\r\nreturn -1;\r\nif (atomic_inc_return(&pd_dvb->active_feed) == 1)\r\nret = dvb_start_streaming(pd_dvb);\r\nreturn ret;\r\n}\r\nstatic int pd_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = feed->demux->priv;\r\nif (!pd_dvb)\r\nreturn -1;\r\nif (atomic_dec_and_test(&pd_dvb->active_feed))\r\ndvb_stop_streaming(pd_dvb);\r\nreturn 0;\r\n}\r\nint pd_dvb_usb_device_init(struct poseidon *pd)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\nstruct dvb_demux *dvbdemux;\r\nint ret = 0;\r\npd_dvb->ep_addr = 0x82;\r\natomic_set(&pd_dvb->users, 0);\r\natomic_set(&pd_dvb->active_feed, 0);\r\npd_dvb->pd_device = pd;\r\nret = dvb_register_adapter(&pd_dvb->dvb_adap,\r\n"Poseidon dvbt adapter",\r\nTHIS_MODULE,\r\nNULL ,\r\nadapter_nr);\r\nif (ret < 0)\r\ngoto error1;\r\npd_dvb->dvb_fe.demodulator_priv = pd;\r\nmemcpy(&pd_dvb->dvb_fe.ops, &poseidon_frontend_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nret = dvb_register_frontend(&pd_dvb->dvb_adap, &pd_dvb->dvb_fe);\r\nif (ret < 0)\r\ngoto error2;\r\ndvbdemux = &pd_dvb->demux;\r\ndvbdemux->dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\ndvbdemux->priv = pd_dvb;\r\ndvbdemux->feednum = dvbdemux->filternum = 64;\r\ndvbdemux->start_feed = pd_start_feed;\r\ndvbdemux->stop_feed = pd_stop_feed;\r\ndvbdemux->write_to_decoder = NULL;\r\nret = dvb_dmx_init(dvbdemux);\r\nif (ret < 0)\r\ngoto error3;\r\npd_dvb->dmxdev.filternum = pd_dvb->demux.filternum;\r\npd_dvb->dmxdev.demux = &pd_dvb->demux.dmx;\r\npd_dvb->dmxdev.capabilities = 0;\r\nret = dvb_dmxdev_init(&pd_dvb->dmxdev, &pd_dvb->dvb_adap);\r\nif (ret < 0)\r\ngoto error3;\r\nreturn 0;\r\nerror3:\r\ndvb_unregister_frontend(&pd_dvb->dvb_fe);\r\nerror2:\r\ndvb_unregister_adapter(&pd_dvb->dvb_adap);\r\nerror1:\r\nreturn ret;\r\n}\r\nvoid pd_dvb_usb_device_exit(struct poseidon *pd)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\nwhile (atomic_read(&pd_dvb->users) != 0\r\n|| atomic_read(&pd_dvb->active_feed) != 0) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\n}\r\ndvb_dmxdev_release(&pd_dvb->dmxdev);\r\ndvb_unregister_frontend(&pd_dvb->dvb_fe);\r\ndvb_unregister_adapter(&pd_dvb->dvb_adap);\r\npd_dvb_usb_device_cleanup(pd);\r\n}\r\nvoid pd_dvb_usb_device_cleanup(struct poseidon *pd)\r\n{\r\nstruct pd_dvb_adapter *pd_dvb = &pd->dvb_data;\r\ndvb_urb_cleanup(pd_dvb);\r\n}\r\nint pd_dvb_get_adapter_num(struct pd_dvb_adapter *pd_dvb)\r\n{\r\nreturn pd_dvb->dvb_adap.num;\r\n}
