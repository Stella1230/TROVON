irqreturn_t exynos_mipi_dsi_interrupt_handler(int irq, void *dev_id)\r\n{\r\nstruct mipi_dsim_device *dsim = dev_id;\r\nunsigned int intsrc, intmsk;\r\nif (dsim == NULL) {\r\ndev_err(dsim->dev, "%s: wrong parameter\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nintsrc = exynos_mipi_dsi_read_interrupt(dsim);\r\nintmsk = exynos_mipi_dsi_read_interrupt_mask(dsim);\r\nintmsk = ~intmsk & intsrc;\r\nif (intsrc & INTMSK_RX_DONE) {\r\ncomplete(&dsim_rd_comp);\r\ndev_dbg(dsim->dev, "MIPI INTMSK_RX_DONE\n");\r\n}\r\nif (intsrc & INTMSK_FIFO_EMPTY) {\r\ncomplete(&dsim_wr_comp);\r\ndev_dbg(dsim->dev, "MIPI INTMSK_FIFO_EMPTY\n");\r\n}\r\nexynos_mipi_dsi_clear_interrupt(dsim, intmsk);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void exynos_mipi_dsi_long_data_wr(struct mipi_dsim_device *dsim,\r\nconst unsigned char *data0, unsigned int data_size)\r\n{\r\nunsigned int data_cnt = 0, payload = 0;\r\nfor (data_cnt = 0; data_cnt < data_size; data_cnt += 4) {\r\nif ((data_size - data_cnt) < 4) {\r\nif ((data_size - data_cnt) == 3) {\r\npayload = data0[data_cnt] |\r\ndata0[data_cnt + 1] << 8 |\r\ndata0[data_cnt + 2] << 16;\r\ndev_dbg(dsim->dev, "count = 3 payload = %x, %x %x %x\n",\r\npayload, data0[data_cnt],\r\ndata0[data_cnt + 1],\r\ndata0[data_cnt + 2]);\r\n} else if ((data_size - data_cnt) == 2) {\r\npayload = data0[data_cnt] |\r\ndata0[data_cnt + 1] << 8;\r\ndev_dbg(dsim->dev,\r\n"count = 2 payload = %x, %x %x\n", payload,\r\ndata0[data_cnt],\r\ndata0[data_cnt + 1]);\r\n} else if ((data_size - data_cnt) == 1) {\r\npayload = data0[data_cnt];\r\n}\r\nexynos_mipi_dsi_wr_tx_data(dsim, payload);\r\n} else {\r\npayload = data0[data_cnt] |\r\ndata0[data_cnt + 1] << 8 |\r\ndata0[data_cnt + 2] << 16 |\r\ndata0[data_cnt + 3] << 24;\r\ndev_dbg(dsim->dev,\r\n"count = 4 payload = %x, %x %x %x %x\n",\r\npayload, *(u8 *)(data0 + data_cnt),\r\ndata0[data_cnt + 1],\r\ndata0[data_cnt + 2],\r\ndata0[data_cnt + 3]);\r\nexynos_mipi_dsi_wr_tx_data(dsim, payload);\r\n}\r\n}\r\n}\r\nint exynos_mipi_dsi_wr_data(struct mipi_dsim_device *dsim, unsigned int data_id,\r\nconst unsigned char *data0, unsigned int data_size)\r\n{\r\nunsigned int check_rx_ack = 0;\r\nif (dsim->state == DSIM_STATE_ULPS) {\r\ndev_err(dsim->dev, "state is ULPS.\n");\r\nreturn -EINVAL;\r\n}\r\nmsleep(20);\r\nmutex_lock(&dsim->lock);\r\nswitch (data_id) {\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\ncase MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:\r\nexynos_mipi_dsi_wr_tx_header(dsim, data_id, data0[0], data0[1]);\r\nif (check_rx_ack) {\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&dsim->lock);\r\nreturn -EINVAL;\r\n}\r\ncase MIPI_DSI_COLOR_MODE_OFF:\r\ncase MIPI_DSI_COLOR_MODE_ON:\r\ncase MIPI_DSI_SHUTDOWN_PERIPHERAL:\r\ncase MIPI_DSI_TURN_ON_PERIPHERAL:\r\nexynos_mipi_dsi_wr_tx_header(dsim, data_id, data0[0], data0[1]);\r\nif (check_rx_ack) {\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&dsim->lock);\r\nreturn -EINVAL;\r\n}\r\ncase MIPI_DSI_V_SYNC_START:\r\ncase MIPI_DSI_V_SYNC_END:\r\ncase MIPI_DSI_H_SYNC_START:\r\ncase MIPI_DSI_H_SYNC_END:\r\ncase MIPI_DSI_END_OF_TRANSMISSION:\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\ncase MIPI_DSI_NULL_PACKET:\r\ncase MIPI_DSI_BLANKING_PACKET:\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\ncase MIPI_DSI_GENERIC_LONG_WRITE:\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\n{\r\nunsigned int size, payload = 0;\r\nINIT_COMPLETION(dsim_wr_comp);\r\nsize = data_size * 4;\r\nif (data_size < 4) {\r\npayload = data0[0] |\r\ndata0[1] << 8 |\r\ndata0[2] << 16;\r\nexynos_mipi_dsi_wr_tx_data(dsim, payload);\r\ndev_dbg(dsim->dev, "count = %d payload = %x,%x %x %x\n",\r\ndata_size, payload, data0[0],\r\ndata0[1], data0[2]);\r\n} else\r\nexynos_mipi_dsi_long_data_wr(dsim, data0, data_size);\r\nexynos_mipi_dsi_wr_tx_header(dsim, data_id, data_size & 0xff,\r\n(data_size & 0xff00) >> 8);\r\nif (!wait_for_completion_interruptible_timeout(&dsim_wr_comp,\r\nMIPI_FIFO_TIMEOUT)) {\r\ndev_warn(dsim->dev, "command write timeout.\n");\r\nmutex_unlock(&dsim->lock);\r\nreturn -EAGAIN;\r\n}\r\nif (check_rx_ack) {\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&dsim->lock);\r\nreturn -EINVAL;\r\n}\r\n}\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_16:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_18:\r\ncase MIPI_DSI_PIXEL_STREAM_3BYTE_18:\r\ncase MIPI_DSI_PACKED_PIXEL_STREAM_24:\r\nif (check_rx_ack) {\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&dsim->lock);\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\ndev_warn(dsim->dev,\r\n"data id %x is not supported current DSI spec.\n",\r\ndata_id);\r\nmutex_unlock(&dsim->lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int exynos_mipi_dsi_long_data_rd(struct mipi_dsim_device *dsim,\r\nunsigned int req_size, unsigned int rx_data, u8 *rx_buf)\r\n{\r\nunsigned int rcv_pkt, i, j;\r\nu16 rxsize;\r\nrxsize = (u16)((rx_data & 0x00ffff00) >> 8);\r\ndev_dbg(dsim->dev, "mipi dsi rx size : %d\n", rxsize);\r\nif (rxsize != req_size) {\r\ndev_dbg(dsim->dev,\r\n"received size mismatch received: %d, requested: %d\n",\r\nrxsize, req_size);\r\ngoto err;\r\n}\r\nfor (i = 0; i < (rxsize >> 2); i++) {\r\nrcv_pkt = exynos_mipi_dsi_rd_rx_fifo(dsim);\r\ndev_dbg(dsim->dev, "received pkt : %08x\n", rcv_pkt);\r\nfor (j = 0; j < 4; j++) {\r\nrx_buf[(i * 4) + j] =\r\n(u8)(rcv_pkt >> (j * 8)) & 0xff;\r\ndev_dbg(dsim->dev, "received value : %02x\n",\r\n(rcv_pkt >> (j * 8)) & 0xff);\r\n}\r\n}\r\nif (rxsize % 4) {\r\nrcv_pkt = exynos_mipi_dsi_rd_rx_fifo(dsim);\r\ndev_dbg(dsim->dev, "received pkt : %08x\n", rcv_pkt);\r\nfor (j = 0; j < (rxsize % 4); j++) {\r\nrx_buf[(i * 4) + j] =\r\n(u8)(rcv_pkt >> (j * 8)) & 0xff;\r\ndev_dbg(dsim->dev, "received value : %02x\n",\r\n(rcv_pkt >> (j * 8)) & 0xff);\r\n}\r\n}\r\nreturn rxsize;\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int exynos_mipi_dsi_response_size(unsigned int req_size)\r\n{\r\nswitch (req_size) {\r\ncase 1:\r\nreturn MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE;\r\ncase 2:\r\nreturn MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE;\r\ndefault:\r\nreturn MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE;\r\n}\r\n}\r\nint exynos_mipi_dsi_rd_data(struct mipi_dsim_device *dsim, unsigned int data_id,\r\nunsigned int data0, unsigned int req_size, u8 *rx_buf)\r\n{\r\nunsigned int rx_data, rcv_pkt, i;\r\nu8 response = 0;\r\nu16 rxsize;\r\nif (dsim->state == DSIM_STATE_ULPS) {\r\ndev_err(dsim->dev, "state is ULPS.\n");\r\nreturn -EINVAL;\r\n}\r\nmsleep(20);\r\nmutex_lock(&dsim->lock);\r\nINIT_COMPLETION(dsim_rd_comp);\r\nexynos_mipi_dsi_rd_tx_header(dsim,\r\nMIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE, req_size);\r\nresponse = exynos_mipi_dsi_response_size(req_size);\r\nswitch (data_id) {\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\r\ncase MIPI_DSI_DCS_READ:\r\nexynos_mipi_dsi_rd_tx_header(dsim,\r\ndata_id, data0);\r\nbreak;\r\ndefault:\r\ndev_warn(dsim->dev,\r\n"data id %x is not supported current DSI spec.\n",\r\ndata_id);\r\nreturn -EINVAL;\r\n}\r\nif (!wait_for_completion_interruptible_timeout(&dsim_rd_comp,\r\nMIPI_FIFO_TIMEOUT)) {\r\npr_err("RX done interrupt timeout\n");\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\n}\r\nmsleep(20);\r\nrx_data = exynos_mipi_dsi_rd_rx_fifo(dsim);\r\nif ((u8)(rx_data & 0xff) != response) {\r\nprintk(KERN_ERR\r\n"mipi dsi wrong response rx_data : %x, response:%x\n",\r\nrx_data, response);\r\ngoto clear_rx_fifo;\r\n}\r\nif (req_size <= 2) {\r\nfor (i = 0; i < req_size; i++)\r\nrx_buf[i] = (rx_data >> (8 + (i * 8))) & 0xff;\r\nrxsize = req_size;\r\n} else {\r\nrxsize = exynos_mipi_dsi_long_data_rd(dsim, req_size, rx_data,\r\nrx_buf);\r\nif (rxsize != req_size)\r\ngoto clear_rx_fifo;\r\n}\r\nrcv_pkt = exynos_mipi_dsi_rd_rx_fifo(dsim);\r\nmsleep(20);\r\nif (rcv_pkt != MIPI_RX_FIFO_READ_DONE) {\r\ndev_info(dsim->dev,\r\n"Can't found RX FIFO READ DONE FLAG : %x\n", rcv_pkt);\r\ngoto clear_rx_fifo;\r\n}\r\nmutex_unlock(&dsim->lock);\r\nreturn rxsize;\r\nclear_rx_fifo:\r\ni = 0;\r\nwhile (1) {\r\nrcv_pkt = exynos_mipi_dsi_rd_rx_fifo(dsim);\r\nif ((rcv_pkt == MIPI_RX_FIFO_READ_DONE)\r\n|| (i > MIPI_MAX_RX_FIFO))\r\nbreak;\r\ndev_dbg(dsim->dev,\r\n"mipi dsi clear rx fifo : %08x\n", rcv_pkt);\r\ni++;\r\n}\r\ndev_info(dsim->dev,\r\n"mipi dsi rx done count : %d, rcv_pkt : %08x\n", i, rcv_pkt);\r\nmutex_unlock(&dsim->lock);\r\nreturn 0;\r\n}\r\nstatic int exynos_mipi_dsi_pll_on(struct mipi_dsim_device *dsim,\r\nunsigned int enable)\r\n{\r\nint sw_timeout;\r\nif (enable) {\r\nsw_timeout = 1000;\r\nexynos_mipi_dsi_enable_pll(dsim, 1);\r\nwhile (1) {\r\nsw_timeout--;\r\nif (exynos_mipi_dsi_is_pll_stable(dsim))\r\nreturn 0;\r\nif (sw_timeout == 0)\r\nreturn -EINVAL;\r\n}\r\n} else\r\nexynos_mipi_dsi_enable_pll(dsim, 0);\r\nreturn 0;\r\n}\r\nstatic unsigned long exynos_mipi_dsi_change_pll(struct mipi_dsim_device *dsim,\r\nunsigned int pre_divider, unsigned int main_divider,\r\nunsigned int scaler)\r\n{\r\nunsigned long dfin_pll, dfvco, dpll_out;\r\nunsigned int i, freq_band = 0xf;\r\ndfin_pll = (FIN_HZ / pre_divider);\r\nif (dfin_pll < DFIN_PLL_MIN_HZ || dfin_pll > DFIN_PLL_MAX_HZ) {\r\ndev_warn(dsim->dev, "fin_pll range should be 6MHz ~ 12MHz\n");\r\nexynos_mipi_dsi_enable_afc(dsim, 0, 0);\r\n} else {\r\nif (dfin_pll < 7 * MHZ)\r\nexynos_mipi_dsi_enable_afc(dsim, 1, 0x1);\r\nelse if (dfin_pll < 8 * MHZ)\r\nexynos_mipi_dsi_enable_afc(dsim, 1, 0x0);\r\nelse if (dfin_pll < 9 * MHZ)\r\nexynos_mipi_dsi_enable_afc(dsim, 1, 0x3);\r\nelse if (dfin_pll < 10 * MHZ)\r\nexynos_mipi_dsi_enable_afc(dsim, 1, 0x2);\r\nelse if (dfin_pll < 11 * MHZ)\r\nexynos_mipi_dsi_enable_afc(dsim, 1, 0x5);\r\nelse\r\nexynos_mipi_dsi_enable_afc(dsim, 1, 0x4);\r\n}\r\ndfvco = dfin_pll * main_divider;\r\ndev_dbg(dsim->dev, "dfvco = %lu, dfin_pll = %lu, main_divider = %d\n",\r\ndfvco, dfin_pll, main_divider);\r\nif (dfvco < DFVCO_MIN_HZ || dfvco > DFVCO_MAX_HZ)\r\ndev_warn(dsim->dev, "fvco range should be 500MHz ~ 1000MHz\n");\r\ndpll_out = dfvco / (1 << scaler);\r\ndev_dbg(dsim->dev, "dpll_out = %lu, dfvco = %lu, scaler = %d\n",\r\ndpll_out, dfvco, scaler);\r\nfor (i = 0; i < ARRAY_SIZE(dpll_table); i++) {\r\nif (dpll_out < dpll_table[i] * MHZ) {\r\nfreq_band = i;\r\nbreak;\r\n}\r\n}\r\ndev_dbg(dsim->dev, "freq_band = %d\n", freq_band);\r\nexynos_mipi_dsi_pll_freq(dsim, pre_divider, main_divider, scaler);\r\nexynos_mipi_dsi_hs_zero_ctrl(dsim, 0);\r\nexynos_mipi_dsi_prep_ctrl(dsim, 0);\r\nexynos_mipi_dsi_pll_freq_band(dsim, freq_band);\r\nexynos_mipi_dsi_pll_stable_time(dsim, dsim->dsim_config->pll_stable_time);\r\ndev_dbg(dsim->dev, "FOUT of mipi dphy pll is %luMHz\n",\r\n(dpll_out / MHZ));\r\nreturn dpll_out;\r\n}\r\nstatic int exynos_mipi_dsi_set_clock(struct mipi_dsim_device *dsim,\r\nunsigned int byte_clk_sel, unsigned int enable)\r\n{\r\nunsigned int esc_div;\r\nunsigned long esc_clk_error_rate;\r\nunsigned long hs_clk = 0, byte_clk = 0, escape_clk = 0;\r\nif (enable) {\r\ndsim->e_clk_src = byte_clk_sel;\r\nexynos_mipi_dsi_set_byte_clock_src(dsim, byte_clk_sel);\r\nif (byte_clk_sel == DSIM_PLL_OUT_DIV8) {\r\nhs_clk = exynos_mipi_dsi_change_pll(dsim,\r\ndsim->dsim_config->p, dsim->dsim_config->m,\r\ndsim->dsim_config->s);\r\nif (hs_clk == 0) {\r\ndev_err(dsim->dev,\r\n"failed to get hs clock.\n");\r\nreturn -EINVAL;\r\n}\r\nbyte_clk = hs_clk / 8;\r\nexynos_mipi_dsi_enable_pll_bypass(dsim, 0);\r\nexynos_mipi_dsi_pll_on(dsim, 1);\r\n} else if (byte_clk_sel == DSIM_EXT_CLK_DIV8) {\r\ndev_warn(dsim->dev, "this project is not support\n");\r\ndev_warn(dsim->dev,\r\n"external clock source for MIPI DSIM.\n");\r\n} else if (byte_clk_sel == DSIM_EXT_CLK_BYPASS) {\r\ndev_warn(dsim->dev, "this project is not support\n");\r\ndev_warn(dsim->dev,\r\n"external clock source for MIPI DSIM\n");\r\n}\r\nesc_div = byte_clk / (dsim->dsim_config->esc_clk);\r\ndev_dbg(dsim->dev,\r\n"esc_div = %d, byte_clk = %lu, esc_clk = %lu\n",\r\nesc_div, byte_clk, dsim->dsim_config->esc_clk);\r\nif ((byte_clk / esc_div) >= (20 * MHZ) ||\r\n(byte_clk / esc_div) >\r\ndsim->dsim_config->esc_clk)\r\nesc_div += 1;\r\nescape_clk = byte_clk / esc_div;\r\ndev_dbg(dsim->dev,\r\n"escape_clk = %lu, byte_clk = %lu, esc_div = %d\n",\r\nescape_clk, byte_clk, esc_div);\r\nexynos_mipi_dsi_enable_byte_clock(dsim, 1);\r\nexynos_mipi_dsi_set_esc_clk_prs(dsim, 1, esc_div);\r\nexynos_mipi_dsi_enable_esc_clk_on_lane(dsim,\r\n(DSIM_LANE_CLOCK | dsim->data_lane), 1);\r\ndev_dbg(dsim->dev, "byte clock is %luMHz\n",\r\n(byte_clk / MHZ));\r\ndev_dbg(dsim->dev, "escape clock that user's need is %lu\n",\r\n(dsim->dsim_config->esc_clk / MHZ));\r\ndev_dbg(dsim->dev, "escape clock divider is %x\n", esc_div);\r\ndev_dbg(dsim->dev, "escape clock is %luMHz\n",\r\n((byte_clk / esc_div) / MHZ));\r\nif ((byte_clk / esc_div) > escape_clk) {\r\nesc_clk_error_rate = escape_clk /\r\n(byte_clk / esc_div);\r\ndev_warn(dsim->dev, "error rate is %lu over.\n",\r\n(esc_clk_error_rate / 100));\r\n} else if ((byte_clk / esc_div) < (escape_clk)) {\r\nesc_clk_error_rate = (byte_clk / esc_div) /\r\nescape_clk;\r\ndev_warn(dsim->dev, "error rate is %lu under.\n",\r\n(esc_clk_error_rate / 100));\r\n}\r\n} else {\r\nexynos_mipi_dsi_enable_esc_clk_on_lane(dsim,\r\n(DSIM_LANE_CLOCK | dsim->data_lane), 0);\r\nexynos_mipi_dsi_set_esc_clk_prs(dsim, 0, 0);\r\nexynos_mipi_dsi_enable_byte_clock(dsim, 0);\r\nif (byte_clk_sel == DSIM_PLL_OUT_DIV8)\r\nexynos_mipi_dsi_pll_on(dsim, 0);\r\n}\r\nreturn 0;\r\n}\r\nint exynos_mipi_dsi_init_dsim(struct mipi_dsim_device *dsim)\r\n{\r\ndsim->state = DSIM_STATE_INIT;\r\nswitch (dsim->dsim_config->e_no_data_lane) {\r\ncase DSIM_DATA_LANE_1:\r\ndsim->data_lane = DSIM_LANE_DATA0;\r\nbreak;\r\ncase DSIM_DATA_LANE_2:\r\ndsim->data_lane = DSIM_LANE_DATA0 | DSIM_LANE_DATA1;\r\nbreak;\r\ncase DSIM_DATA_LANE_3:\r\ndsim->data_lane = DSIM_LANE_DATA0 | DSIM_LANE_DATA1 |\r\nDSIM_LANE_DATA2;\r\nbreak;\r\ncase DSIM_DATA_LANE_4:\r\ndsim->data_lane = DSIM_LANE_DATA0 | DSIM_LANE_DATA1 |\r\nDSIM_LANE_DATA2 | DSIM_LANE_DATA3;\r\nbreak;\r\ndefault:\r\ndev_info(dsim->dev, "data lane is invalid.\n");\r\nreturn -EINVAL;\r\n};\r\nexynos_mipi_dsi_sw_reset(dsim);\r\nexynos_mipi_dsi_func_reset(dsim);\r\nexynos_mipi_dsi_dp_dn_swap(dsim, 0);\r\nreturn 0;\r\n}\r\nvoid exynos_mipi_dsi_init_interrupt(struct mipi_dsim_device *dsim)\r\n{\r\nunsigned int src = 0;\r\nsrc = (INTSRC_SFR_FIFO_EMPTY | INTSRC_RX_DATA_DONE);\r\nexynos_mipi_dsi_set_interrupt(dsim, src, 1);\r\nsrc = 0;\r\nsrc = ~(INTMSK_RX_DONE | INTMSK_FIFO_EMPTY);\r\nexynos_mipi_dsi_set_interrupt_mask(dsim, src, 1);\r\n}\r\nint exynos_mipi_dsi_enable_frame_done_int(struct mipi_dsim_device *dsim,\r\nunsigned int enable)\r\n{\r\nexynos_mipi_dsi_set_interrupt_mask(dsim, INTMSK_FRAME_DONE, enable);\r\nreturn 0;\r\n}\r\nvoid exynos_mipi_dsi_stand_by(struct mipi_dsim_device *dsim,\r\nunsigned int enable)\r\n{\r\nexynos_mipi_dsi_set_main_stand_by(dsim, enable);\r\n}\r\nint exynos_mipi_dsi_set_display_mode(struct mipi_dsim_device *dsim,\r\nstruct mipi_dsim_config *dsim_config)\r\n{\r\nstruct mipi_dsim_platform_data *dsim_pd;\r\nstruct fb_videomode *timing;\r\ndsim_pd = (struct mipi_dsim_platform_data *)dsim->pd;\r\ntiming = (struct fb_videomode *)dsim_pd->lcd_panel_info;\r\nif (dsim_config->e_interface == (u32) DSIM_VIDEO) {\r\nif (dsim_config->auto_vertical_cnt == 0) {\r\nexynos_mipi_dsi_set_main_disp_vporch(dsim,\r\ndsim_config->cmd_allow,\r\ntiming->lower_margin,\r\ntiming->upper_margin);\r\nexynos_mipi_dsi_set_main_disp_hporch(dsim,\r\ntiming->right_margin,\r\ntiming->left_margin);\r\nexynos_mipi_dsi_set_main_disp_sync_area(dsim,\r\ntiming->vsync_len,\r\ntiming->hsync_len);\r\n}\r\n}\r\nexynos_mipi_dsi_set_main_disp_resol(dsim, timing->xres,\r\ntiming->yres);\r\nexynos_mipi_dsi_display_config(dsim, dsim_config);\r\ndev_info(dsim->dev, "lcd panel ==> width = %d, height = %d\n",\r\ntiming->xres, timing->yres);\r\nreturn 0;\r\n}\r\nint exynos_mipi_dsi_init_link(struct mipi_dsim_device *dsim)\r\n{\r\nunsigned int time_out = 100;\r\nswitch (dsim->state) {\r\ncase DSIM_STATE_INIT:\r\nexynos_mipi_dsi_init_fifo_pointer(dsim, 0x1f);\r\nexynos_mipi_dsi_init_config(dsim);\r\nexynos_mipi_dsi_enable_lane(dsim, DSIM_LANE_CLOCK, 1);\r\nexynos_mipi_dsi_enable_lane(dsim, dsim->data_lane, 1);\r\nexynos_mipi_dsi_set_clock(dsim, dsim->dsim_config->e_byte_clk, 1);\r\nwhile (!(exynos_mipi_dsi_is_lane_state(dsim))) {\r\ntime_out--;\r\nif (time_out == 0) {\r\ndev_err(dsim->dev,\r\n"DSI Master is not stop state.\n");\r\ndev_err(dsim->dev,\r\n"Check initialization process\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (time_out != 0) {\r\ndev_info(dsim->dev,\r\n"DSI Master driver has been completed.\n");\r\ndev_info(dsim->dev, "DSI Master state is stop state\n");\r\n}\r\ndsim->state = DSIM_STATE_STOP;\r\nexynos_mipi_dsi_set_stop_state_counter(dsim,\r\ndsim->dsim_config->stop_holding_cnt);\r\nexynos_mipi_dsi_set_bta_timeout(dsim,\r\ndsim->dsim_config->bta_timeout);\r\nexynos_mipi_dsi_set_lpdr_timeout(dsim,\r\ndsim->dsim_config->rx_timeout);\r\nreturn 0;\r\ndefault:\r\ndev_info(dsim->dev, "DSI Master is already init.\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint exynos_mipi_dsi_set_hs_enable(struct mipi_dsim_device *dsim)\r\n{\r\nif (dsim->state != DSIM_STATE_STOP) {\r\ndev_warn(dsim->dev, "DSIM is not in stop state.\n");\r\nreturn 0;\r\n}\r\nif (dsim->e_clk_src == DSIM_EXT_CLK_BYPASS) {\r\ndev_warn(dsim->dev, "clock source is external bypass.\n");\r\nreturn 0;\r\n}\r\ndsim->state = DSIM_STATE_HSCLKEN;\r\nexynos_mipi_dsi_set_lcdc_transfer_mode(dsim, 0);\r\nexynos_mipi_dsi_set_cpu_transfer_mode(dsim, 0);\r\nexynos_mipi_dsi_enable_hs_clock(dsim, 1);\r\nreturn 0;\r\n}\r\nint exynos_mipi_dsi_set_data_transfer_mode(struct mipi_dsim_device *dsim,\r\nunsigned int mode)\r\n{\r\nif (mode) {\r\nif (dsim->state != DSIM_STATE_HSCLKEN) {\r\ndev_err(dsim->dev, "HS Clock lane is not enabled.\n");\r\nreturn -EINVAL;\r\n}\r\nexynos_mipi_dsi_set_lcdc_transfer_mode(dsim, 0);\r\n} else {\r\nif (dsim->state == DSIM_STATE_INIT || dsim->state ==\r\nDSIM_STATE_ULPS) {\r\ndev_err(dsim->dev,\r\n"DSI Master is not STOP or HSDT state.\n");\r\nreturn -EINVAL;\r\n}\r\nexynos_mipi_dsi_set_cpu_transfer_mode(dsim, 0);\r\n}\r\nreturn 0;\r\n}\r\nint exynos_mipi_dsi_get_frame_done_status(struct mipi_dsim_device *dsim)\r\n{\r\nreturn _exynos_mipi_dsi_get_frame_done_status(dsim);\r\n}\r\nint exynos_mipi_dsi_clear_frame_done(struct mipi_dsim_device *dsim)\r\n{\r\n_exynos_mipi_dsi_clear_frame_done(dsim);\r\nreturn 0;\r\n}\r\nint exynos_mipi_dsi_fifo_clear(struct mipi_dsim_device *dsim,\r\nunsigned int val)\r\n{\r\nint try = TRY_FIFO_CLEAR;\r\nexynos_mipi_dsi_sw_reset_release(dsim);\r\nexynos_mipi_dsi_func_reset(dsim);\r\ndo {\r\nif (exynos_mipi_dsi_get_sw_reset_release(dsim)) {\r\nexynos_mipi_dsi_init_interrupt(dsim);\r\ndev_dbg(dsim->dev, "reset release done.\n");\r\nreturn 0;\r\n}\r\n} while (--try);\r\ndev_err(dsim->dev, "failed to clear dsim fifo.\n");\r\nreturn -EAGAIN;\r\n}
