static int __devinit sis900_get_mac_addr(struct pci_dev * pci_dev, struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nu16 signature;\r\nint i;\r\nsignature = (u16) read_eeprom(ioaddr, EEPROMSignature);\r\nif (signature == 0xffff || signature == 0x0000) {\r\nprintk (KERN_WARNING "%s: Error EERPOM read %x\n",\r\npci_name(pci_dev), signature);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 3; i++)\r\n((u16 *)(net_dev->dev_addr))[i] = read_eeprom(ioaddr, i+EEPROMMACAddr);\r\nmemcpy(net_dev->perm_addr, net_dev->dev_addr, ETH_ALEN);\r\nreturn 1;\r\n}\r\nstatic int __devinit sis630e_get_mac_addr(struct pci_dev * pci_dev,\r\nstruct net_device *net_dev)\r\n{\r\nstruct pci_dev *isa_bridge = NULL;\r\nu8 reg;\r\nint i;\r\nisa_bridge = pci_get_device(PCI_VENDOR_ID_SI, 0x0008, isa_bridge);\r\nif (!isa_bridge)\r\nisa_bridge = pci_get_device(PCI_VENDOR_ID_SI, 0x0018, isa_bridge);\r\nif (!isa_bridge) {\r\nprintk(KERN_WARNING "%s: Can not find ISA bridge\n",\r\npci_name(pci_dev));\r\nreturn 0;\r\n}\r\npci_read_config_byte(isa_bridge, 0x48, &reg);\r\npci_write_config_byte(isa_bridge, 0x48, reg | 0x40);\r\nfor (i = 0; i < 6; i++) {\r\noutb(0x09 + i, 0x70);\r\n((u8 *)(net_dev->dev_addr))[i] = inb(0x71);\r\n}\r\nmemcpy(net_dev->perm_addr, net_dev->dev_addr, ETH_ALEN);\r\npci_write_config_byte(isa_bridge, 0x48, reg & ~0x40);\r\npci_dev_put(isa_bridge);\r\nreturn 1;\r\n}\r\nstatic int __devinit sis635_get_mac_addr(struct pci_dev * pci_dev,\r\nstruct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nu32 rfcrSave;\r\nu32 i;\r\nrfcrSave = sr32(rfcr);\r\nsw32(cr, rfcrSave | RELOAD);\r\nsw32(cr, 0);\r\nsw32(rfcr, rfcrSave & ~RFEN);\r\nfor (i = 0 ; i < 3 ; i++) {\r\nsw32(rfcr, (i << RFADDR_shift));\r\n*( ((u16 *)net_dev->dev_addr) + i) = sr16(rfdr);\r\n}\r\nmemcpy(net_dev->perm_addr, net_dev->dev_addr, ETH_ALEN);\r\nsw32(rfcr, rfcrSave | RFEN);\r\nreturn 1;\r\n}\r\nstatic int __devinit sis96x_get_mac_addr(struct pci_dev * pci_dev,\r\nstruct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nint wait, rc = 0;\r\nsw32(mear, EEREQ);\r\nfor (wait = 0; wait < 2000; wait++) {\r\nif (sr32(mear) & EEGNT) {\r\nu16 *mac = (u16 *)net_dev->dev_addr;\r\nint i;\r\nfor (i = 0; i < 3; i++)\r\nmac[i] = read_eeprom(ioaddr, i + EEPROMMACAddr);\r\nmemcpy(net_dev->perm_addr, net_dev->dev_addr, ETH_ALEN);\r\nrc = 1;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nsw32(mear, EEDONE);\r\nreturn rc;\r\n}\r\nstatic int __devinit sis900_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct sis900_private *sis_priv;\r\nstruct net_device *net_dev;\r\nstruct pci_dev *dev;\r\ndma_addr_t ring_dma;\r\nvoid *ring_space;\r\nvoid __iomem *ioaddr;\r\nint i, ret;\r\nconst char *card_name = card_names[pci_id->driver_data];\r\nconst char *dev_name = pci_name(pci_dev);\r\n#ifndef MODULE\r\nstatic int printed_version;\r\nif (!printed_version++)\r\nprintk(version);\r\n#endif\r\nret = pci_enable_device(pci_dev);\r\nif(ret) return ret;\r\ni = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32));\r\nif(i){\r\nprintk(KERN_ERR "sis900.c: architecture does not support "\r\n"32bit PCI busmaster DMA\n");\r\nreturn i;\r\n}\r\npci_set_master(pci_dev);\r\nnet_dev = alloc_etherdev(sizeof(struct sis900_private));\r\nif (!net_dev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(net_dev, &pci_dev->dev);\r\nret = pci_request_regions(pci_dev, "sis900");\r\nif (ret)\r\ngoto err_out;\r\nioaddr = pci_iomap(pci_dev, 0, 0);\r\nif (!ioaddr)\r\ngoto err_out_cleardev;\r\nsis_priv = netdev_priv(net_dev);\r\nsis_priv->ioaddr = ioaddr;\r\nsis_priv->pci_dev = pci_dev;\r\nspin_lock_init(&sis_priv->lock);\r\npci_set_drvdata(pci_dev, net_dev);\r\nring_space = pci_alloc_consistent(pci_dev, TX_TOTAL_SIZE, &ring_dma);\r\nif (!ring_space) {\r\nret = -ENOMEM;\r\ngoto err_out_unmap;\r\n}\r\nsis_priv->tx_ring = ring_space;\r\nsis_priv->tx_ring_dma = ring_dma;\r\nring_space = pci_alloc_consistent(pci_dev, RX_TOTAL_SIZE, &ring_dma);\r\nif (!ring_space) {\r\nret = -ENOMEM;\r\ngoto err_unmap_tx;\r\n}\r\nsis_priv->rx_ring = ring_space;\r\nsis_priv->rx_ring_dma = ring_dma;\r\nnet_dev->netdev_ops = &sis900_netdev_ops;\r\nnet_dev->watchdog_timeo = TX_TIMEOUT;\r\nnet_dev->ethtool_ops = &sis900_ethtool_ops;\r\nif (sis900_debug > 0)\r\nsis_priv->msg_enable = sis900_debug;\r\nelse\r\nsis_priv->msg_enable = SIS900_DEF_MSG;\r\nsis_priv->mii_info.dev = net_dev;\r\nsis_priv->mii_info.mdio_read = mdio_read;\r\nsis_priv->mii_info.mdio_write = mdio_write;\r\nsis_priv->mii_info.phy_id_mask = 0x1f;\r\nsis_priv->mii_info.reg_num_mask = 0x1f;\r\nsis_priv->chipset_rev = pci_dev->revision;\r\nif(netif_msg_probe(sis_priv))\r\nprintk(KERN_DEBUG "%s: detected revision %2.2x, "\r\n"trying to get MAC address...\n",\r\ndev_name, sis_priv->chipset_rev);\r\nret = 0;\r\nif (sis_priv->chipset_rev == SIS630E_900_REV)\r\nret = sis630e_get_mac_addr(pci_dev, net_dev);\r\nelse if ((sis_priv->chipset_rev > 0x81) && (sis_priv->chipset_rev <= 0x90) )\r\nret = sis635_get_mac_addr(pci_dev, net_dev);\r\nelse if (sis_priv->chipset_rev == SIS96x_900_REV)\r\nret = sis96x_get_mac_addr(pci_dev, net_dev);\r\nelse\r\nret = sis900_get_mac_addr(pci_dev, net_dev);\r\nif (!ret || !is_valid_ether_addr(net_dev->dev_addr)) {\r\neth_hw_addr_random(net_dev);\r\nprintk(KERN_WARNING "%s: Unreadable or invalid MAC address,"\r\n"using random generated one\n", dev_name);\r\n}\r\nif (sis_priv->chipset_rev == SIS630ET_900_REV)\r\nsw32(cr, ACCESSMODE | sr32(cr));\r\nif (sis900_mii_probe(net_dev) == 0) {\r\nprintk(KERN_WARNING "%s: Error probing MII device.\n",\r\ndev_name);\r\nret = -ENODEV;\r\ngoto err_unmap_rx;\r\n}\r\ndev = pci_get_device(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_630, NULL);\r\nif (dev) {\r\nsis_priv->host_bridge_rev = dev->revision;\r\npci_dev_put(dev);\r\n}\r\nret = register_netdev(net_dev);\r\nif (ret)\r\ngoto err_unmap_rx;\r\nprintk(KERN_INFO "%s: %s at 0x%p, IRQ %d, %pM\n",\r\nnet_dev->name, card_name, ioaddr, pci_dev->irq,\r\nnet_dev->dev_addr);\r\nret = (sr32(CFGPMC) & PMESP) >> 27;\r\nif (netif_msg_probe(sis_priv) && (ret & PME_D3C) == 0)\r\nprintk(KERN_INFO "%s: Wake on LAN only available from suspend to RAM.", net_dev->name);\r\nreturn 0;\r\nerr_unmap_rx:\r\npci_free_consistent(pci_dev, RX_TOTAL_SIZE, sis_priv->rx_ring,\r\nsis_priv->rx_ring_dma);\r\nerr_unmap_tx:\r\npci_free_consistent(pci_dev, TX_TOTAL_SIZE, sis_priv->tx_ring,\r\nsis_priv->tx_ring_dma);\r\nerr_out_unmap:\r\npci_iounmap(pci_dev, ioaddr);\r\nerr_out_cleardev:\r\npci_set_drvdata(pci_dev, NULL);\r\npci_release_regions(pci_dev);\r\nerr_out:\r\nfree_netdev(net_dev);\r\nreturn ret;\r\n}\r\nstatic int __devinit sis900_mii_probe(struct net_device * net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nconst char *dev_name = pci_name(sis_priv->pci_dev);\r\nu16 poll_bit = MII_STAT_LINK, status = 0;\r\nunsigned long timeout = jiffies + 5 * HZ;\r\nint phy_addr;\r\nsis_priv->mii = NULL;\r\nfor (phy_addr = 0; phy_addr < 32; phy_addr++) {\r\nstruct mii_phy * mii_phy = NULL;\r\nu16 mii_status;\r\nint i;\r\nmii_phy = NULL;\r\nfor(i = 0; i < 2; i++)\r\nmii_status = mdio_read(net_dev, phy_addr, MII_STATUS);\r\nif (mii_status == 0xffff || mii_status == 0x0000) {\r\nif (netif_msg_probe(sis_priv))\r\nprintk(KERN_DEBUG "%s: MII at address %d"\r\n" not accessible\n",\r\ndev_name, phy_addr);\r\ncontinue;\r\n}\r\nif ((mii_phy = kmalloc(sizeof(struct mii_phy), GFP_KERNEL)) == NULL) {\r\nmii_phy = sis_priv->first_mii;\r\nwhile (mii_phy) {\r\nstruct mii_phy *phy;\r\nphy = mii_phy;\r\nmii_phy = mii_phy->next;\r\nkfree(phy);\r\n}\r\nreturn 0;\r\n}\r\nmii_phy->phy_id0 = mdio_read(net_dev, phy_addr, MII_PHY_ID0);\r\nmii_phy->phy_id1 = mdio_read(net_dev, phy_addr, MII_PHY_ID1);\r\nmii_phy->phy_addr = phy_addr;\r\nmii_phy->status = mii_status;\r\nmii_phy->next = sis_priv->mii;\r\nsis_priv->mii = mii_phy;\r\nsis_priv->first_mii = mii_phy;\r\nfor (i = 0; mii_chip_table[i].phy_id1; i++)\r\nif ((mii_phy->phy_id0 == mii_chip_table[i].phy_id0 ) &&\r\n((mii_phy->phy_id1 & 0xFFF0) == mii_chip_table[i].phy_id1)){\r\nmii_phy->phy_types = mii_chip_table[i].phy_types;\r\nif (mii_chip_table[i].phy_types == MIX)\r\nmii_phy->phy_types =\r\n(mii_status & (MII_STAT_CAN_TX_FDX | MII_STAT_CAN_TX)) ? LAN : HOME;\r\nprintk(KERN_INFO "%s: %s transceiver found "\r\n"at address %d.\n",\r\ndev_name,\r\nmii_chip_table[i].name,\r\nphy_addr);\r\nbreak;\r\n}\r\nif( !mii_chip_table[i].phy_id1 ) {\r\nprintk(KERN_INFO "%s: Unknown PHY transceiver found at address %d.\n",\r\ndev_name, phy_addr);\r\nmii_phy->phy_types = UNKNOWN;\r\n}\r\n}\r\nif (sis_priv->mii == NULL) {\r\nprintk(KERN_INFO "%s: No MII transceivers found!\n", dev_name);\r\nreturn 0;\r\n}\r\nsis_priv->mii = NULL;\r\nsis900_default_phy( net_dev );\r\nif ((sis_priv->mii->phy_id0 == 0x001D) &&\r\n((sis_priv->mii->phy_id1&0xFFF0) == 0x8000))\r\nstatus = sis900_reset_phy(net_dev, sis_priv->cur_phy);\r\nif ((sis_priv->mii->phy_id0 == 0x0015) &&\r\n((sis_priv->mii->phy_id1&0xFFF0) == 0xF440))\r\nmdio_write(net_dev, sis_priv->cur_phy, 0x0018, 0xD200);\r\nif(status & MII_STAT_LINK){\r\nwhile (poll_bit) {\r\nyield();\r\npoll_bit ^= (mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS) & poll_bit);\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk(KERN_WARNING "%s: reset phy and link down now\n",\r\ndev_name);\r\nreturn -ETIME;\r\n}\r\n}\r\n}\r\nif (sis_priv->chipset_rev == SIS630E_900_REV) {\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_ANADV, 0x05e1);\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_CONFIG1, 0x22);\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_CONFIG2, 0xff00);\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_MASK, 0xffc0);\r\n}\r\nif (sis_priv->mii->status & MII_STAT_LINK)\r\nnetif_carrier_on(net_dev);\r\nelse\r\nnetif_carrier_off(net_dev);\r\nreturn 1;\r\n}\r\nstatic u16 sis900_default_phy(struct net_device * net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nstruct mii_phy *phy = NULL, *phy_home = NULL,\r\n*default_phy = NULL, *phy_lan = NULL;\r\nu16 status;\r\nfor (phy=sis_priv->first_mii; phy; phy=phy->next) {\r\nstatus = mdio_read(net_dev, phy->phy_addr, MII_STATUS);\r\nstatus = mdio_read(net_dev, phy->phy_addr, MII_STATUS);\r\nif ((status & MII_STAT_LINK) && !default_phy &&\r\n(phy->phy_types != UNKNOWN))\r\ndefault_phy = phy;\r\nelse {\r\nstatus = mdio_read(net_dev, phy->phy_addr, MII_CONTROL);\r\nmdio_write(net_dev, phy->phy_addr, MII_CONTROL,\r\nstatus | MII_CNTL_AUTO | MII_CNTL_ISOLATE);\r\nif (phy->phy_types == HOME)\r\nphy_home = phy;\r\nelse if(phy->phy_types == LAN)\r\nphy_lan = phy;\r\n}\r\n}\r\nif (!default_phy && phy_home)\r\ndefault_phy = phy_home;\r\nelse if (!default_phy && phy_lan)\r\ndefault_phy = phy_lan;\r\nelse if (!default_phy)\r\ndefault_phy = sis_priv->first_mii;\r\nif (sis_priv->mii != default_phy) {\r\nsis_priv->mii = default_phy;\r\nsis_priv->cur_phy = default_phy->phy_addr;\r\nprintk(KERN_INFO "%s: Using transceiver found at address %d as default\n",\r\npci_name(sis_priv->pci_dev), sis_priv->cur_phy);\r\n}\r\nsis_priv->mii_info.phy_id = sis_priv->cur_phy;\r\nstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_CONTROL);\r\nstatus &= (~MII_CNTL_ISOLATE);\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_CONTROL, status);\r\nstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\r\nstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\r\nreturn status;\r\n}\r\nstatic void sis900_set_capability(struct net_device *net_dev, struct mii_phy *phy)\r\n{\r\nu16 cap;\r\nu16 status;\r\nstatus = mdio_read(net_dev, phy->phy_addr, MII_STATUS);\r\nstatus = mdio_read(net_dev, phy->phy_addr, MII_STATUS);\r\ncap = MII_NWAY_CSMA_CD |\r\n((phy->status & MII_STAT_CAN_TX_FDX)? MII_NWAY_TX_FDX:0) |\r\n((phy->status & MII_STAT_CAN_TX) ? MII_NWAY_TX:0) |\r\n((phy->status & MII_STAT_CAN_T_FDX) ? MII_NWAY_T_FDX:0)|\r\n((phy->status & MII_STAT_CAN_T) ? MII_NWAY_T:0);\r\nmdio_write(net_dev, phy->phy_addr, MII_ANADV, cap);\r\n}\r\nstatic u16 __devinit read_eeprom(void __iomem *ioaddr, int location)\r\n{\r\nu32 read_cmd = location | EEread;\r\nint i;\r\nu16 retval = 0;\r\nsw32(mear, 0);\r\neeprom_delay();\r\nsw32(mear, EECS);\r\neeprom_delay();\r\nfor (i = 8; i >= 0; i--) {\r\nu32 dataval = (read_cmd & (1 << i)) ? EEDI | EECS : EECS;\r\nsw32(mear, dataval);\r\neeprom_delay();\r\nsw32(mear, dataval | EECLK);\r\neeprom_delay();\r\n}\r\nsw32(mear, EECS);\r\neeprom_delay();\r\nfor (i = 16; i > 0; i--) {\r\nsw32(mear, EECS);\r\neeprom_delay();\r\nsw32(mear, EECS | EECLK);\r\neeprom_delay();\r\nretval = (retval << 1) | ((sr32(mear) & EEDO) ? 1 : 0);\r\neeprom_delay();\r\n}\r\nsw32(mear, 0);\r\neeprom_delay();\r\nreturn retval;\r\n}\r\nstatic void mdio_idle(struct sis900_private *sp)\r\n{\r\nvoid __iomem *ioaddr = sp->ioaddr;\r\nsw32(mear, MDIO | MDDIR);\r\nmdio_delay();\r\nsw32(mear, MDIO | MDDIR | MDC);\r\n}\r\nstatic void mdio_reset(struct sis900_private *sp)\r\n{\r\nvoid __iomem *ioaddr = sp->ioaddr;\r\nint i;\r\nfor (i = 31; i >= 0; i--) {\r\nsw32(mear, MDDIR | MDIO);\r\nmdio_delay();\r\nsw32(mear, MDDIR | MDIO | MDC);\r\nmdio_delay();\r\n}\r\n}\r\nstatic int mdio_read(struct net_device *net_dev, int phy_id, int location)\r\n{\r\nint mii_cmd = MIIread|(phy_id<<MIIpmdShift)|(location<<MIIregShift);\r\nstruct sis900_private *sp = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sp->ioaddr;\r\nu16 retval = 0;\r\nint i;\r\nmdio_reset(sp);\r\nmdio_idle(sp);\r\nfor (i = 15; i >= 0; i--) {\r\nint dataval = (mii_cmd & (1 << i)) ? MDDIR | MDIO : MDDIR;\r\nsw32(mear, dataval);\r\nmdio_delay();\r\nsw32(mear, dataval | MDC);\r\nmdio_delay();\r\n}\r\nfor (i = 16; i > 0; i--) {\r\nsw32(mear, 0);\r\nmdio_delay();\r\nretval = (retval << 1) | ((sr32(mear) & MDIO) ? 1 : 0);\r\nsw32(mear, MDC);\r\nmdio_delay();\r\n}\r\nsw32(mear, 0x00);\r\nreturn retval;\r\n}\r\nstatic void mdio_write(struct net_device *net_dev, int phy_id, int location,\r\nint value)\r\n{\r\nint mii_cmd = MIIwrite|(phy_id<<MIIpmdShift)|(location<<MIIregShift);\r\nstruct sis900_private *sp = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sp->ioaddr;\r\nint i;\r\nmdio_reset(sp);\r\nmdio_idle(sp);\r\nfor (i = 15; i >= 0; i--) {\r\nint dataval = (mii_cmd & (1 << i)) ? MDDIR | MDIO : MDDIR;\r\nsw8(mear, dataval);\r\nmdio_delay();\r\nsw8(mear, dataval | MDC);\r\nmdio_delay();\r\n}\r\nmdio_delay();\r\nfor (i = 15; i >= 0; i--) {\r\nint dataval = (value & (1 << i)) ? MDDIR | MDIO : MDDIR;\r\nsw32(mear, dataval);\r\nmdio_delay();\r\nsw32(mear, dataval | MDC);\r\nmdio_delay();\r\n}\r\nmdio_delay();\r\nfor (i = 2; i > 0; i--) {\r\nsw8(mear, 0);\r\nmdio_delay();\r\nsw8(mear, MDC);\r\nmdio_delay();\r\n}\r\nsw32(mear, 0x00);\r\n}\r\nstatic u16 sis900_reset_phy(struct net_device *net_dev, int phy_addr)\r\n{\r\nint i;\r\nu16 status;\r\nfor (i = 0; i < 2; i++)\r\nstatus = mdio_read(net_dev, phy_addr, MII_STATUS);\r\nmdio_write( net_dev, phy_addr, MII_CONTROL, MII_CNTL_RESET );\r\nreturn status;\r\n}\r\nstatic void sis900_poll(struct net_device *dev)\r\n{\r\nstruct sis900_private *sp = netdev_priv(dev);\r\nconst int irq = sp->pci_dev->irq;\r\ndisable_irq(irq);\r\nsis900_interrupt(irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic int\r\nsis900_open(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nint ret;\r\nsis900_reset(net_dev);\r\nsis630_set_eq(net_dev, sis_priv->chipset_rev);\r\nret = request_irq(sis_priv->pci_dev->irq, sis900_interrupt, IRQF_SHARED,\r\nnet_dev->name, net_dev);\r\nif (ret)\r\nreturn ret;\r\nsis900_init_rxfilter(net_dev);\r\nsis900_init_tx_ring(net_dev);\r\nsis900_init_rx_ring(net_dev);\r\nset_rx_mode(net_dev);\r\nnetif_start_queue(net_dev);\r\nsis900_set_mode(sis_priv, HW_SPEED_10_MBPS, FDX_CAPABLE_HALF_SELECTED);\r\nsw32(imr, RxSOVR | RxORN | RxERR | RxOK | TxURN | TxERR | TxIDLE);\r\nsw32(cr, RxENA | sr32(cr));\r\nsw32(ier, IE);\r\nsis900_check_mode(net_dev, sis_priv->mii);\r\ninit_timer(&sis_priv->timer);\r\nsis_priv->timer.expires = jiffies + HZ;\r\nsis_priv->timer.data = (unsigned long)net_dev;\r\nsis_priv->timer.function = sis900_timer;\r\nadd_timer(&sis_priv->timer);\r\nreturn 0;\r\n}\r\nstatic void\r\nsis900_init_rxfilter (struct net_device * net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nu32 rfcrSave;\r\nu32 i;\r\nrfcrSave = sr32(rfcr);\r\nsw32(rfcr, rfcrSave & ~RFEN);\r\nfor (i = 0 ; i < 3 ; i++) {\r\nu32 w = (u32) *((u16 *)(net_dev->dev_addr)+i);\r\nsw32(rfcr, i << RFADDR_shift);\r\nsw32(rfdr, w);\r\nif (netif_msg_hw(sis_priv)) {\r\nprintk(KERN_DEBUG "%s: Receive Filter Addrss[%d]=%x\n",\r\nnet_dev->name, i, sr32(rfdr));\r\n}\r\n}\r\nsw32(rfcr, rfcrSave | RFEN);\r\n}\r\nstatic void\r\nsis900_init_tx_ring(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nint i;\r\nsis_priv->tx_full = 0;\r\nsis_priv->dirty_tx = sis_priv->cur_tx = 0;\r\nfor (i = 0; i < NUM_TX_DESC; i++) {\r\nsis_priv->tx_skbuff[i] = NULL;\r\nsis_priv->tx_ring[i].link = sis_priv->tx_ring_dma +\r\n((i+1)%NUM_TX_DESC)*sizeof(BufferDesc);\r\nsis_priv->tx_ring[i].cmdsts = 0;\r\nsis_priv->tx_ring[i].bufptr = 0;\r\n}\r\nsw32(txdp, sis_priv->tx_ring_dma);\r\nif (netif_msg_hw(sis_priv))\r\nprintk(KERN_DEBUG "%s: TX descriptor register loaded with: %8.8x\n",\r\nnet_dev->name, sr32(txdp));\r\n}\r\nstatic void\r\nsis900_init_rx_ring(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nint i;\r\nsis_priv->cur_rx = 0;\r\nsis_priv->dirty_rx = 0;\r\nfor (i = 0; i < NUM_RX_DESC; i++) {\r\nsis_priv->rx_skbuff[i] = NULL;\r\nsis_priv->rx_ring[i].link = sis_priv->rx_ring_dma +\r\n((i+1)%NUM_RX_DESC)*sizeof(BufferDesc);\r\nsis_priv->rx_ring[i].cmdsts = 0;\r\nsis_priv->rx_ring[i].bufptr = 0;\r\n}\r\nfor (i = 0; i < NUM_RX_DESC; i++) {\r\nstruct sk_buff *skb;\r\nif ((skb = netdev_alloc_skb(net_dev, RX_BUF_SIZE)) == NULL) {\r\nbreak;\r\n}\r\nsis_priv->rx_skbuff[i] = skb;\r\nsis_priv->rx_ring[i].cmdsts = RX_BUF_SIZE;\r\nsis_priv->rx_ring[i].bufptr = pci_map_single(sis_priv->pci_dev,\r\nskb->data, RX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\n}\r\nsis_priv->dirty_rx = (unsigned int) (i - NUM_RX_DESC);\r\nsw32(rxdp, sis_priv->rx_ring_dma);\r\nif (netif_msg_hw(sis_priv))\r\nprintk(KERN_DEBUG "%s: RX descriptor register loaded with: %8.8x\n",\r\nnet_dev->name, sr32(rxdp));\r\n}\r\nstatic void sis630_set_eq(struct net_device *net_dev, u8 revision)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nu16 reg14h, eq_value=0, max_value=0, min_value=0;\r\nint i, maxcount=10;\r\nif ( !(revision == SIS630E_900_REV || revision == SIS630EA1_900_REV ||\r\nrevision == SIS630A_900_REV || revision == SIS630ET_900_REV) )\r\nreturn;\r\nif (netif_carrier_ok(net_dev)) {\r\nreg14h = mdio_read(net_dev, sis_priv->cur_phy, MII_RESV);\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_RESV,\r\n(0x2200 | reg14h) & 0xBFFF);\r\nfor (i=0; i < maxcount; i++) {\r\neq_value = (0x00F8 & mdio_read(net_dev,\r\nsis_priv->cur_phy, MII_RESV)) >> 3;\r\nif (i == 0)\r\nmax_value=min_value=eq_value;\r\nmax_value = (eq_value > max_value) ?\r\neq_value : max_value;\r\nmin_value = (eq_value < min_value) ?\r\neq_value : min_value;\r\n}\r\nif (revision == SIS630E_900_REV || revision == SIS630EA1_900_REV ||\r\nrevision == SIS630ET_900_REV) {\r\nif (max_value < 5)\r\neq_value = max_value;\r\nelse if (max_value >= 5 && max_value < 15)\r\neq_value = (max_value == min_value) ?\r\nmax_value+2 : max_value+1;\r\nelse if (max_value >= 15)\r\neq_value=(max_value == min_value) ?\r\nmax_value+6 : max_value+5;\r\n}\r\nif (revision == SIS630A_900_REV &&\r\n(sis_priv->host_bridge_rev == SIS630B0 ||\r\nsis_priv->host_bridge_rev == SIS630B1)) {\r\nif (max_value == 0)\r\neq_value = 3;\r\nelse\r\neq_value = (max_value + min_value + 1)/2;\r\n}\r\nreg14h = mdio_read(net_dev, sis_priv->cur_phy, MII_RESV);\r\nreg14h = (reg14h & 0xFF07) | ((eq_value << 3) & 0x00F8);\r\nreg14h = (reg14h | 0x6000) & 0xFDFF;\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_RESV, reg14h);\r\n} else {\r\nreg14h = mdio_read(net_dev, sis_priv->cur_phy, MII_RESV);\r\nif (revision == SIS630A_900_REV &&\r\n(sis_priv->host_bridge_rev == SIS630B0 ||\r\nsis_priv->host_bridge_rev == SIS630B1))\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_RESV,\r\n(reg14h | 0x2200) & 0xBFFF);\r\nelse\r\nmdio_write(net_dev, sis_priv->cur_phy, MII_RESV,\r\n(reg14h | 0x2000) & 0xBFFF);\r\n}\r\n}\r\nstatic void sis900_timer(unsigned long data)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)data;\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nstruct mii_phy *mii_phy = sis_priv->mii;\r\nstatic const int next_tick = 5*HZ;\r\nu16 status;\r\nif (!sis_priv->autong_complete){\r\nint uninitialized_var(speed), duplex = 0;\r\nsis900_read_mode(net_dev, &speed, &duplex);\r\nif (duplex){\r\nsis900_set_mode(sis_priv, speed, duplex);\r\nsis630_set_eq(net_dev, sis_priv->chipset_rev);\r\nnetif_start_queue(net_dev);\r\n}\r\nsis_priv->timer.expires = jiffies + HZ;\r\nadd_timer(&sis_priv->timer);\r\nreturn;\r\n}\r\nstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\r\nstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\r\nif (!netif_carrier_ok(net_dev)) {\r\nLookForLink:\r\nstatus = sis900_default_phy(net_dev);\r\nmii_phy = sis_priv->mii;\r\nif (status & MII_STAT_LINK){\r\nsis900_check_mode(net_dev, mii_phy);\r\nnetif_carrier_on(net_dev);\r\n}\r\n} else {\r\nif (!(status & MII_STAT_LINK)){\r\nnetif_carrier_off(net_dev);\r\nif(netif_msg_link(sis_priv))\r\nprintk(KERN_INFO "%s: Media Link Off\n", net_dev->name);\r\nif ((mii_phy->phy_id0 == 0x001D) &&\r\n((mii_phy->phy_id1 & 0xFFF0) == 0x8000))\r\nsis900_reset_phy(net_dev, sis_priv->cur_phy);\r\nsis630_set_eq(net_dev, sis_priv->chipset_rev);\r\ngoto LookForLink;\r\n}\r\n}\r\nsis_priv->timer.expires = jiffies + next_tick;\r\nadd_timer(&sis_priv->timer);\r\n}\r\nstatic void sis900_check_mode(struct net_device *net_dev, struct mii_phy *mii_phy)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nint speed, duplex;\r\nif (mii_phy->phy_types == LAN) {\r\nsw32(cfg, ~EXD & sr32(cfg));\r\nsis900_set_capability(net_dev , mii_phy);\r\nsis900_auto_negotiate(net_dev, sis_priv->cur_phy);\r\n} else {\r\nsw32(cfg, EXD | sr32(cfg));\r\nspeed = HW_SPEED_HOME;\r\nduplex = FDX_CAPABLE_HALF_SELECTED;\r\nsis900_set_mode(sis_priv, speed, duplex);\r\nsis_priv->autong_complete = 1;\r\n}\r\n}\r\nstatic void sis900_set_mode(struct sis900_private *sp, int speed, int duplex)\r\n{\r\nvoid __iomem *ioaddr = sp->ioaddr;\r\nu32 tx_flags = 0, rx_flags = 0;\r\nif (sr32( cfg) & EDB_MASTER_EN) {\r\ntx_flags = TxATP | (DMA_BURST_64 << TxMXDMA_shift) |\r\n(TX_FILL_THRESH << TxFILLT_shift);\r\nrx_flags = DMA_BURST_64 << RxMXDMA_shift;\r\n} else {\r\ntx_flags = TxATP | (DMA_BURST_512 << TxMXDMA_shift) |\r\n(TX_FILL_THRESH << TxFILLT_shift);\r\nrx_flags = DMA_BURST_512 << RxMXDMA_shift;\r\n}\r\nif (speed == HW_SPEED_HOME || speed == HW_SPEED_10_MBPS) {\r\nrx_flags |= (RxDRNT_10 << RxDRNT_shift);\r\ntx_flags |= (TxDRNT_10 << TxDRNT_shift);\r\n} else {\r\nrx_flags |= (RxDRNT_100 << RxDRNT_shift);\r\ntx_flags |= (TxDRNT_100 << TxDRNT_shift);\r\n}\r\nif (duplex == FDX_CAPABLE_FULL_SELECTED) {\r\ntx_flags |= (TxCSI | TxHBI);\r\nrx_flags |= RxATX;\r\n}\r\n#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)\r\nrx_flags |= RxAJAB;\r\n#endif\r\nsw32(txcfg, tx_flags);\r\nsw32(rxcfg, rx_flags);\r\n}\r\nstatic void sis900_auto_negotiate(struct net_device *net_dev, int phy_addr)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nint i = 0;\r\nu32 status;\r\nfor (i = 0; i < 2; i++)\r\nstatus = mdio_read(net_dev, phy_addr, MII_STATUS);\r\nif (!(status & MII_STAT_LINK)){\r\nif(netif_msg_link(sis_priv))\r\nprintk(KERN_INFO "%s: Media Link Off\n", net_dev->name);\r\nsis_priv->autong_complete = 1;\r\nnetif_carrier_off(net_dev);\r\nreturn;\r\n}\r\nmdio_write(net_dev, phy_addr, MII_CONTROL,\r\nMII_CNTL_AUTO | MII_CNTL_RST_AUTO);\r\nsis_priv->autong_complete = 0;\r\n}\r\nstatic void sis900_read_mode(struct net_device *net_dev, int *speed, int *duplex)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nstruct mii_phy *phy = sis_priv->mii;\r\nint phy_addr = sis_priv->cur_phy;\r\nu32 status;\r\nu16 autoadv, autorec;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nstatus = mdio_read(net_dev, phy_addr, MII_STATUS);\r\nif (!(status & MII_STAT_LINK))\r\nreturn;\r\nautoadv = mdio_read(net_dev, phy_addr, MII_ANADV);\r\nautorec = mdio_read(net_dev, phy_addr, MII_ANLPAR);\r\nstatus = autoadv & autorec;\r\n*speed = HW_SPEED_10_MBPS;\r\n*duplex = FDX_CAPABLE_HALF_SELECTED;\r\nif (status & (MII_NWAY_TX | MII_NWAY_TX_FDX))\r\n*speed = HW_SPEED_100_MBPS;\r\nif (status & ( MII_NWAY_TX_FDX | MII_NWAY_T_FDX))\r\n*duplex = FDX_CAPABLE_FULL_SELECTED;\r\nsis_priv->autong_complete = 1;\r\nif ((phy->phy_id0 == 0x0000) && ((phy->phy_id1 & 0xFFF0) == 0x8200)) {\r\nif (mdio_read(net_dev, phy_addr, MII_CONTROL) & MII_CNTL_FDX)\r\n*duplex = FDX_CAPABLE_FULL_SELECTED;\r\nif (mdio_read(net_dev, phy_addr, 0x0019) & 0x01)\r\n*speed = HW_SPEED_100_MBPS;\r\n}\r\nif(netif_msg_link(sis_priv))\r\nprintk(KERN_INFO "%s: Media Link On %s %s-duplex\n",\r\nnet_dev->name,\r\n*speed == HW_SPEED_100_MBPS ?\r\n"100mbps" : "10mbps",\r\n*duplex == FDX_CAPABLE_FULL_SELECTED ?\r\n"full" : "half");\r\n}\r\nstatic void sis900_tx_timeout(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nunsigned long flags;\r\nint i;\r\nif (netif_msg_tx_err(sis_priv)) {\r\nprintk(KERN_INFO "%s: Transmit timeout, status %8.8x %8.8x\n",\r\nnet_dev->name, sr32(cr), sr32(isr));\r\n}\r\nsw32(imr, 0x0000);\r\nspin_lock_irqsave(&sis_priv->lock, flags);\r\nsis_priv->dirty_tx = sis_priv->cur_tx = 0;\r\nfor (i = 0; i < NUM_TX_DESC; i++) {\r\nstruct sk_buff *skb = sis_priv->tx_skbuff[i];\r\nif (skb) {\r\npci_unmap_single(sis_priv->pci_dev,\r\nsis_priv->tx_ring[i].bufptr, skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\nsis_priv->tx_skbuff[i] = NULL;\r\nsis_priv->tx_ring[i].cmdsts = 0;\r\nsis_priv->tx_ring[i].bufptr = 0;\r\nnet_dev->stats.tx_dropped++;\r\n}\r\n}\r\nsis_priv->tx_full = 0;\r\nnetif_wake_queue(net_dev);\r\nspin_unlock_irqrestore(&sis_priv->lock, flags);\r\nnet_dev->trans_start = jiffies;\r\nsw32(txdp, sis_priv->tx_ring_dma);\r\nsw32(imr, RxSOVR | RxORN | RxERR | RxOK | TxURN | TxERR | TxIDLE);\r\n}\r\nstatic netdev_tx_t\r\nsis900_start_xmit(struct sk_buff *skb, struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nunsigned int entry;\r\nunsigned long flags;\r\nunsigned int index_cur_tx, index_dirty_tx;\r\nunsigned int count_dirty_tx;\r\nif(!sis_priv->autong_complete){\r\nnetif_stop_queue(net_dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nspin_lock_irqsave(&sis_priv->lock, flags);\r\nentry = sis_priv->cur_tx % NUM_TX_DESC;\r\nsis_priv->tx_skbuff[entry] = skb;\r\nsis_priv->tx_ring[entry].bufptr = pci_map_single(sis_priv->pci_dev,\r\nskb->data, skb->len, PCI_DMA_TODEVICE);\r\nsis_priv->tx_ring[entry].cmdsts = (OWN | skb->len);\r\nsw32(cr, TxENA | sr32(cr));\r\nsis_priv->cur_tx ++;\r\nindex_cur_tx = sis_priv->cur_tx;\r\nindex_dirty_tx = sis_priv->dirty_tx;\r\nfor (count_dirty_tx = 0; index_cur_tx != index_dirty_tx; index_dirty_tx++)\r\ncount_dirty_tx ++;\r\nif (index_cur_tx == index_dirty_tx) {\r\nsis_priv->tx_full = 1;\r\nnetif_stop_queue(net_dev);\r\n} else if (count_dirty_tx < NUM_TX_DESC) {\r\nnetif_start_queue(net_dev);\r\n} else {\r\nsis_priv->tx_full = 1;\r\nnetif_stop_queue(net_dev);\r\n}\r\nspin_unlock_irqrestore(&sis_priv->lock, flags);\r\nif (netif_msg_tx_queued(sis_priv))\r\nprintk(KERN_DEBUG "%s: Queued Tx packet at %p size %d "\r\n"to slot %d.\n",\r\nnet_dev->name, skb->data, (int)skb->len, entry);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t sis900_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *net_dev = dev_instance;\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nint boguscnt = max_interrupt_work;\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nu32 status;\r\nunsigned int handled = 0;\r\nspin_lock (&sis_priv->lock);\r\ndo {\r\nstatus = sr32(isr);\r\nif ((status & (HIBERR|TxURN|TxERR|TxIDLE|RxORN|RxERR|RxOK)) == 0)\r\nbreak;\r\nhandled = 1;\r\nif (status & (RxORN | RxERR | RxOK))\r\nsis900_rx(net_dev);\r\nif (status & (TxURN | TxERR | TxIDLE))\r\nsis900_finish_xmit(net_dev);\r\nif (status & HIBERR) {\r\nif(netif_msg_intr(sis_priv))\r\nprintk(KERN_INFO "%s: Abnormal interrupt, "\r\n"status %#8.8x.\n", net_dev->name, status);\r\nbreak;\r\n}\r\nif (--boguscnt < 0) {\r\nif(netif_msg_intr(sis_priv))\r\nprintk(KERN_INFO "%s: Too much work at interrupt, "\r\n"interrupt status = %#8.8x.\n",\r\nnet_dev->name, status);\r\nbreak;\r\n}\r\n} while (1);\r\nif(netif_msg_intr(sis_priv))\r\nprintk(KERN_DEBUG "%s: exiting interrupt, "\r\n"interrupt status = 0x%#8.8x.\n",\r\nnet_dev->name, sr32(isr));\r\nspin_unlock (&sis_priv->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int sis900_rx(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nunsigned int entry = sis_priv->cur_rx % NUM_RX_DESC;\r\nu32 rx_status = sis_priv->rx_ring[entry].cmdsts;\r\nint rx_work_limit;\r\nif (netif_msg_rx_status(sis_priv))\r\nprintk(KERN_DEBUG "sis900_rx, cur_rx:%4.4d, dirty_rx:%4.4d "\r\n"status:0x%8.8x\n",\r\nsis_priv->cur_rx, sis_priv->dirty_rx, rx_status);\r\nrx_work_limit = sis_priv->dirty_rx + NUM_RX_DESC - sis_priv->cur_rx;\r\nwhile (rx_status & OWN) {\r\nunsigned int rx_size;\r\nunsigned int data_size;\r\nif (--rx_work_limit < 0)\r\nbreak;\r\ndata_size = rx_status & DSIZE;\r\nrx_size = data_size - CRC_SIZE;\r\n#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)\r\nif ((rx_status & TOOLONG) && data_size <= MAX_FRAME_SIZE)\r\nrx_status &= (~ ((unsigned int)TOOLONG));\r\n#endif\r\nif (rx_status & (ABORT|OVERRUN|TOOLONG|RUNT|RXISERR|CRCERR|FAERR)) {\r\nif (netif_msg_rx_err(sis_priv))\r\nprintk(KERN_DEBUG "%s: Corrupted packet "\r\n"received, buffer status = 0x%8.8x/%d.\n",\r\nnet_dev->name, rx_status, data_size);\r\nnet_dev->stats.rx_errors++;\r\nif (rx_status & OVERRUN)\r\nnet_dev->stats.rx_over_errors++;\r\nif (rx_status & (TOOLONG|RUNT))\r\nnet_dev->stats.rx_length_errors++;\r\nif (rx_status & (RXISERR | FAERR))\r\nnet_dev->stats.rx_frame_errors++;\r\nif (rx_status & CRCERR)\r\nnet_dev->stats.rx_crc_errors++;\r\nsis_priv->rx_ring[entry].cmdsts = RX_BUF_SIZE;\r\n} else {\r\nstruct sk_buff * skb;\r\nstruct sk_buff * rx_skb;\r\npci_unmap_single(sis_priv->pci_dev,\r\nsis_priv->rx_ring[entry].bufptr, RX_BUF_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif ((skb = netdev_alloc_skb(net_dev, RX_BUF_SIZE)) == NULL) {\r\nskb = sis_priv->rx_skbuff[entry];\r\nnet_dev->stats.rx_dropped++;\r\ngoto refill_rx_ring;\r\n}\r\nif (sis_priv->rx_skbuff[entry] == NULL) {\r\nif (netif_msg_rx_err(sis_priv))\r\nprintk(KERN_WARNING "%s: NULL pointer "\r\n"encountered in Rx ring\n"\r\n"cur_rx:%4.4d, dirty_rx:%4.4d\n",\r\nnet_dev->name, sis_priv->cur_rx,\r\nsis_priv->dirty_rx);\r\ndev_kfree_skb(skb);\r\nbreak;\r\n}\r\nrx_skb = sis_priv->rx_skbuff[entry];\r\nskb_put(rx_skb, rx_size);\r\nrx_skb->protocol = eth_type_trans(rx_skb, net_dev);\r\nnetif_rx(rx_skb);\r\nif ((rx_status & BCAST) == MCAST)\r\nnet_dev->stats.multicast++;\r\nnet_dev->stats.rx_bytes += rx_size;\r\nnet_dev->stats.rx_packets++;\r\nsis_priv->dirty_rx++;\r\nrefill_rx_ring:\r\nsis_priv->rx_skbuff[entry] = skb;\r\nsis_priv->rx_ring[entry].cmdsts = RX_BUF_SIZE;\r\nsis_priv->rx_ring[entry].bufptr =\r\npci_map_single(sis_priv->pci_dev, skb->data,\r\nRX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\n}\r\nsis_priv->cur_rx++;\r\nentry = sis_priv->cur_rx % NUM_RX_DESC;\r\nrx_status = sis_priv->rx_ring[entry].cmdsts;\r\n}\r\nfor (; sis_priv->cur_rx != sis_priv->dirty_rx; sis_priv->dirty_rx++) {\r\nstruct sk_buff *skb;\r\nentry = sis_priv->dirty_rx % NUM_RX_DESC;\r\nif (sis_priv->rx_skbuff[entry] == NULL) {\r\nif ((skb = netdev_alloc_skb(net_dev, RX_BUF_SIZE)) == NULL) {\r\nif (netif_msg_rx_err(sis_priv))\r\nprintk(KERN_INFO "%s: Memory squeeze, "\r\n"deferring packet.\n",\r\nnet_dev->name);\r\nnet_dev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nsis_priv->rx_skbuff[entry] = skb;\r\nsis_priv->rx_ring[entry].cmdsts = RX_BUF_SIZE;\r\nsis_priv->rx_ring[entry].bufptr =\r\npci_map_single(sis_priv->pci_dev, skb->data,\r\nRX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\n}\r\n}\r\nsw32(cr , RxENA | sr32(cr));\r\nreturn 0;\r\n}\r\nstatic void sis900_finish_xmit (struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nfor (; sis_priv->dirty_tx != sis_priv->cur_tx; sis_priv->dirty_tx++) {\r\nstruct sk_buff *skb;\r\nunsigned int entry;\r\nu32 tx_status;\r\nentry = sis_priv->dirty_tx % NUM_TX_DESC;\r\ntx_status = sis_priv->tx_ring[entry].cmdsts;\r\nif (tx_status & OWN) {\r\nbreak;\r\n}\r\nif (tx_status & (ABORT | UNDERRUN | OWCOLL)) {\r\nif (netif_msg_tx_err(sis_priv))\r\nprintk(KERN_DEBUG "%s: Transmit "\r\n"error, Tx status %8.8x.\n",\r\nnet_dev->name, tx_status);\r\nnet_dev->stats.tx_errors++;\r\nif (tx_status & UNDERRUN)\r\nnet_dev->stats.tx_fifo_errors++;\r\nif (tx_status & ABORT)\r\nnet_dev->stats.tx_aborted_errors++;\r\nif (tx_status & NOCARRIER)\r\nnet_dev->stats.tx_carrier_errors++;\r\nif (tx_status & OWCOLL)\r\nnet_dev->stats.tx_window_errors++;\r\n} else {\r\nnet_dev->stats.collisions += (tx_status & COLCNT) >> 16;\r\nnet_dev->stats.tx_bytes += tx_status & DSIZE;\r\nnet_dev->stats.tx_packets++;\r\n}\r\nskb = sis_priv->tx_skbuff[entry];\r\npci_unmap_single(sis_priv->pci_dev,\r\nsis_priv->tx_ring[entry].bufptr, skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\nsis_priv->tx_skbuff[entry] = NULL;\r\nsis_priv->tx_ring[entry].bufptr = 0;\r\nsis_priv->tx_ring[entry].cmdsts = 0;\r\n}\r\nif (sis_priv->tx_full && netif_queue_stopped(net_dev) &&\r\nsis_priv->cur_tx - sis_priv->dirty_tx < NUM_TX_DESC - 4) {\r\nsis_priv->tx_full = 0;\r\nnetif_wake_queue (net_dev);\r\n}\r\n}\r\nstatic int sis900_close(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nstruct pci_dev *pdev = sis_priv->pci_dev;\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nstruct sk_buff *skb;\r\nint i;\r\nnetif_stop_queue(net_dev);\r\nsw32(imr, 0x0000);\r\nsw32(ier, 0x0000);\r\nsw32(cr, RxDIS | TxDIS | sr32(cr));\r\ndel_timer(&sis_priv->timer);\r\nfree_irq(pdev->irq, net_dev);\r\nfor (i = 0; i < NUM_RX_DESC; i++) {\r\nskb = sis_priv->rx_skbuff[i];\r\nif (skb) {\r\npci_unmap_single(pdev, sis_priv->rx_ring[i].bufptr,\r\nRX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(skb);\r\nsis_priv->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nfor (i = 0; i < NUM_TX_DESC; i++) {\r\nskb = sis_priv->tx_skbuff[i];\r\nif (skb) {\r\npci_unmap_single(pdev, sis_priv->tx_ring[i].bufptr,\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(skb);\r\nsis_priv->tx_skbuff[i] = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sis900_get_drvinfo(struct net_device *net_dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nstrlcpy(info->driver, SIS900_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, SIS900_DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(sis_priv->pci_dev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic u32 sis900_get_msglevel(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nreturn sis_priv->msg_enable;\r\n}\r\nstatic void sis900_set_msglevel(struct net_device *net_dev, u32 value)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nsis_priv->msg_enable = value;\r\n}\r\nstatic u32 sis900_get_link(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nreturn mii_link_ok(&sis_priv->mii_info);\r\n}\r\nstatic int sis900_get_settings(struct net_device *net_dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nspin_lock_irq(&sis_priv->lock);\r\nmii_ethtool_gset(&sis_priv->mii_info, cmd);\r\nspin_unlock_irq(&sis_priv->lock);\r\nreturn 0;\r\n}\r\nstatic int sis900_set_settings(struct net_device *net_dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nint rt;\r\nspin_lock_irq(&sis_priv->lock);\r\nrt = mii_ethtool_sset(&sis_priv->mii_info, cmd);\r\nspin_unlock_irq(&sis_priv->lock);\r\nreturn rt;\r\n}\r\nstatic int sis900_nway_reset(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nreturn mii_nway_restart(&sis_priv->mii_info);\r\n}\r\nstatic int sis900_set_wol(struct net_device *net_dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nu32 cfgpmcsr = 0, pmctrl_bits = 0;\r\nif (wol->wolopts == 0) {\r\npci_read_config_dword(sis_priv->pci_dev, CFGPMCSR, &cfgpmcsr);\r\ncfgpmcsr &= ~PME_EN;\r\npci_write_config_dword(sis_priv->pci_dev, CFGPMCSR, cfgpmcsr);\r\nsw32(pmctrl, pmctrl_bits);\r\nif (netif_msg_wol(sis_priv))\r\nprintk(KERN_DEBUG "%s: Wake on LAN disabled\n", net_dev->name);\r\nreturn 0;\r\n}\r\nif (wol->wolopts & (WAKE_MAGICSECURE | WAKE_UCAST | WAKE_MCAST\r\n| WAKE_BCAST | WAKE_ARP))\r\nreturn -EINVAL;\r\nif (wol->wolopts & WAKE_MAGIC)\r\npmctrl_bits |= MAGICPKT;\r\nif (wol->wolopts & WAKE_PHY)\r\npmctrl_bits |= LINKON;\r\nsw32(pmctrl, pmctrl_bits);\r\npci_read_config_dword(sis_priv->pci_dev, CFGPMCSR, &cfgpmcsr);\r\ncfgpmcsr |= PME_EN;\r\npci_write_config_dword(sis_priv->pci_dev, CFGPMCSR, cfgpmcsr);\r\nif (netif_msg_wol(sis_priv))\r\nprintk(KERN_DEBUG "%s: Wake on LAN enabled\n", net_dev->name);\r\nreturn 0;\r\n}\r\nstatic void sis900_get_wol(struct net_device *net_dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct sis900_private *sp = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sp->ioaddr;\r\nu32 pmctrl_bits;\r\npmctrl_bits = sr32(pmctrl);\r\nif (pmctrl_bits & MAGICPKT)\r\nwol->wolopts |= WAKE_MAGIC;\r\nif (pmctrl_bits & LINKON)\r\nwol->wolopts |= WAKE_PHY;\r\nwol->supported = (WAKE_PHY | WAKE_MAGIC);\r\n}\r\nstatic int mii_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nswitch(cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = sis_priv->mii->phy_addr;\r\ncase SIOCGMIIREG:\r\ndata->val_out = mdio_read(net_dev, data->phy_id & 0x1f, data->reg_num & 0x1f);\r\nreturn 0;\r\ncase SIOCSMIIREG:\r\nmdio_write(net_dev, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int sis900_set_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(dev);\r\nstruct mii_phy *mii_phy = sis_priv->mii;\r\nu16 status;\r\nif ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\r\nswitch(map->port){\r\ncase IF_PORT_UNKNOWN:\r\ndev->if_port = map->port;\r\nnetif_carrier_off(dev);\r\nstatus = mdio_read(dev, mii_phy->phy_addr, MII_CONTROL);\r\nmdio_write(dev, mii_phy->phy_addr,\r\nMII_CONTROL, status | MII_CNTL_AUTO | MII_CNTL_RST_AUTO);\r\nbreak;\r\ncase IF_PORT_10BASET:\r\ndev->if_port = map->port;\r\nnetif_carrier_off(dev);\r\nstatus = mdio_read(dev, mii_phy->phy_addr, MII_CONTROL);\r\nmdio_write(dev, mii_phy->phy_addr,\r\nMII_CONTROL, status & ~(MII_CNTL_SPEED |\r\nMII_CNTL_AUTO));\r\nbreak;\r\ncase IF_PORT_100BASET:\r\ncase IF_PORT_100BASETX:\r\ndev->if_port = map->port;\r\nnetif_carrier_off(dev);\r\nstatus = mdio_read(dev, mii_phy->phy_addr, MII_CONTROL);\r\nmdio_write(dev, mii_phy->phy_addr,\r\nMII_CONTROL, (status & ~MII_CNTL_SPEED) |\r\nMII_CNTL_SPEED);\r\nbreak;\r\ncase IF_PORT_10BASE2:\r\ncase IF_PORT_AUI:\r\ncase IF_PORT_100BASEFX:\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u16 sis900_mcast_bitnr(u8 *addr, u8 revision)\r\n{\r\nu32 crc = ether_crc(6, addr);\r\nif ((revision >= SIS635A_900_REV) || (revision == SIS900B_900_REV))\r\nreturn (int)(crc >> 24);\r\nelse\r\nreturn (int)(crc >> 25);\r\n}\r\nstatic void set_rx_mode(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nu16 mc_filter[16] = {0};\r\nint i, table_entries;\r\nu32 rx_mode;\r\nif((sis_priv->chipset_rev >= SIS635A_900_REV) ||\r\n(sis_priv->chipset_rev == SIS900B_900_REV))\r\ntable_entries = 16;\r\nelse\r\ntable_entries = 8;\r\nif (net_dev->flags & IFF_PROMISC) {\r\nrx_mode = RFPromiscuous;\r\nfor (i = 0; i < table_entries; i++)\r\nmc_filter[i] = 0xffff;\r\n} else if ((netdev_mc_count(net_dev) > multicast_filter_limit) ||\r\n(net_dev->flags & IFF_ALLMULTI)) {\r\nrx_mode = RFAAB | RFAAM;\r\nfor (i = 0; i < table_entries; i++)\r\nmc_filter[i] = 0xffff;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nrx_mode = RFAAB;\r\nnetdev_for_each_mc_addr(ha, net_dev) {\r\nunsigned int bit_nr;\r\nbit_nr = sis900_mcast_bitnr(ha->addr,\r\nsis_priv->chipset_rev);\r\nmc_filter[bit_nr >> 4] |= (1 << (bit_nr & 0xf));\r\n}\r\n}\r\nfor (i = 0; i < table_entries; i++) {\r\nsw32(rfcr, (u32)(0x00000004 + i) << RFADDR_shift);\r\nsw32(rfdr, mc_filter[i]);\r\n}\r\nsw32(rfcr, RFEN | rx_mode);\r\nif (net_dev->flags & IFF_LOOPBACK) {\r\nu32 cr_saved;\r\ncr_saved = sr32(cr);\r\nsw32(cr, cr_saved | TxDIS | RxDIS);\r\nsw32(txcfg, sr32(txcfg) | TxMLB);\r\nsw32(rxcfg, sr32(rxcfg) | RxATX);\r\nsw32(cr, cr_saved);\r\n}\r\n}\r\nstatic void sis900_reset(struct net_device *net_dev)\r\n{\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nu32 status = TxRCMP | RxRCMP;\r\nint i;\r\nsw32(ier, 0);\r\nsw32(imr, 0);\r\nsw32(rfcr, 0);\r\nsw32(cr, RxRESET | TxRESET | RESET | sr32(cr));\r\nfor (i = 0; status && (i < 1000); i++)\r\nstatus ^= sr32(isr) & status;\r\nif (sis_priv->chipset_rev >= SIS635A_900_REV ||\r\nsis_priv->chipset_rev == SIS900B_900_REV)\r\nsw32(cfg, PESEL | RND_CNT);\r\nelse\r\nsw32(cfg, PESEL);\r\n}\r\nstatic void __devexit sis900_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct net_device *net_dev = pci_get_drvdata(pci_dev);\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nunregister_netdev(net_dev);\r\nwhile (sis_priv->first_mii) {\r\nstruct mii_phy *phy = sis_priv->first_mii;\r\nsis_priv->first_mii = phy->next;\r\nkfree(phy);\r\n}\r\npci_free_consistent(pci_dev, RX_TOTAL_SIZE, sis_priv->rx_ring,\r\nsis_priv->rx_ring_dma);\r\npci_free_consistent(pci_dev, TX_TOTAL_SIZE, sis_priv->tx_ring,\r\nsis_priv->tx_ring_dma);\r\npci_iounmap(pci_dev, sis_priv->ioaddr);\r\nfree_netdev(net_dev);\r\npci_release_regions(pci_dev);\r\npci_set_drvdata(pci_dev, NULL);\r\n}\r\nstatic int sis900_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct net_device *net_dev = pci_get_drvdata(pci_dev);\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nif(!netif_running(net_dev))\r\nreturn 0;\r\nnetif_stop_queue(net_dev);\r\nnetif_device_detach(net_dev);\r\nsw32(cr, RxDIS | TxDIS | sr32(cr));\r\npci_set_power_state(pci_dev, PCI_D3hot);\r\npci_save_state(pci_dev);\r\nreturn 0;\r\n}\r\nstatic int sis900_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct net_device *net_dev = pci_get_drvdata(pci_dev);\r\nstruct sis900_private *sis_priv = netdev_priv(net_dev);\r\nvoid __iomem *ioaddr = sis_priv->ioaddr;\r\nif(!netif_running(net_dev))\r\nreturn 0;\r\npci_restore_state(pci_dev);\r\npci_set_power_state(pci_dev, PCI_D0);\r\nsis900_init_rxfilter(net_dev);\r\nsis900_init_tx_ring(net_dev);\r\nsis900_init_rx_ring(net_dev);\r\nset_rx_mode(net_dev);\r\nnetif_device_attach(net_dev);\r\nnetif_start_queue(net_dev);\r\nsis900_set_mode(ioaddr, HW_SPEED_10_MBPS, FDX_CAPABLE_HALF_SELECTED);\r\nsw32(imr, RxSOVR | RxORN | RxERR | RxOK | TxURN | TxERR | TxIDLE);\r\nsw32(cr, RxENA | sr32(cr));\r\nsw32(ier, IE);\r\nsis900_check_mode(net_dev, sis_priv->mii);\r\nreturn 0;\r\n}\r\nstatic int __init sis900_init_module(void)\r\n{\r\n#ifdef MODULE\r\nprintk(version);\r\n#endif\r\nreturn pci_register_driver(&sis900_pci_driver);\r\n}\r\nstatic void __exit sis900_cleanup_module(void)\r\n{\r\npci_unregister_driver(&sis900_pci_driver);\r\n}
