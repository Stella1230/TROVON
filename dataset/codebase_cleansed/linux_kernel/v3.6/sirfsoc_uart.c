static inline struct sirfsoc_uart_port *to_sirfport(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct sirfsoc_uart_port, port);\r\n}\r\nstatic inline unsigned int sirfsoc_uart_tx_empty(struct uart_port *port)\r\n{\r\nunsigned long reg;\r\nreg = rd_regl(port, SIRFUART_TX_FIFO_STATUS);\r\nif (reg & SIRFUART_FIFOEMPTY_MASK(port))\r\nreturn TIOCSER_TEMT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned int sirfsoc_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nif (!(sirfport->ms_enabled)) {\r\ngoto cts_asserted;\r\n} else if (sirfport->hw_flow_ctrl) {\r\nif (!(rd_regl(port, SIRFUART_AFC_CTRL) &\r\nSIRFUART_CTS_IN_STATUS))\r\ngoto cts_asserted;\r\nelse\r\ngoto cts_deasserted;\r\n}\r\ncts_deasserted:\r\nreturn TIOCM_CAR | TIOCM_DSR;\r\ncts_asserted:\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void sirfsoc_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nunsigned int assert = mctrl & TIOCM_RTS;\r\nunsigned int val = assert ? SIRFUART_AFC_CTRL_RX_THD : 0x0;\r\nunsigned int current_val;\r\nif (sirfport->hw_flow_ctrl) {\r\ncurrent_val = rd_regl(port, SIRFUART_AFC_CTRL) & ~0xFF;\r\nval |= current_val;\r\nwr_regl(port, SIRFUART_AFC_CTRL, val);\r\n}\r\n}\r\nstatic void sirfsoc_uart_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int regv;\r\nregv = rd_regl(port, SIRFUART_INT_EN);\r\nwr_regl(port, SIRFUART_INT_EN, regv & ~SIRFUART_TX_INT_EN);\r\n}\r\nvoid sirfsoc_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nunsigned long regv;\r\nsirfsoc_uart_pio_tx_chars(sirfport, 1);\r\nwr_regl(port, SIRFUART_TX_FIFO_OP, SIRFUART_TX_FIFO_START);\r\nregv = rd_regl(port, SIRFUART_INT_EN);\r\nwr_regl(port, SIRFUART_INT_EN, regv | SIRFUART_TX_INT_EN);\r\n}\r\nstatic void sirfsoc_uart_stop_rx(struct uart_port *port)\r\n{\r\nunsigned long regv;\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, 0);\r\nregv = rd_regl(port, SIRFUART_INT_EN);\r\nwr_regl(port, SIRFUART_INT_EN, regv & ~SIRFUART_RX_IO_INT_EN);\r\n}\r\nstatic void sirfsoc_uart_disable_ms(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nunsigned long reg;\r\nsirfport->ms_enabled = 0;\r\nif (!sirfport->hw_flow_ctrl)\r\nreturn;\r\nreg = rd_regl(port, SIRFUART_AFC_CTRL);\r\nwr_regl(port, SIRFUART_AFC_CTRL, reg & ~0x3FF);\r\nreg = rd_regl(port, SIRFUART_INT_EN);\r\nwr_regl(port, SIRFUART_INT_EN, reg & ~SIRFUART_CTS_INT_EN);\r\n}\r\nstatic void sirfsoc_uart_enable_ms(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nunsigned long reg;\r\nunsigned long flg;\r\nif (!sirfport->hw_flow_ctrl)\r\nreturn;\r\nflg = SIRFUART_AFC_RX_EN | SIRFUART_AFC_TX_EN;\r\nreg = rd_regl(port, SIRFUART_AFC_CTRL);\r\nwr_regl(port, SIRFUART_AFC_CTRL, reg | flg);\r\nreg = rd_regl(port, SIRFUART_INT_EN);\r\nwr_regl(port, SIRFUART_INT_EN, reg | SIRFUART_CTS_INT_EN);\r\nuart_handle_cts_change(port,\r\n!(rd_regl(port, SIRFUART_AFC_CTRL) & SIRFUART_CTS_IN_STATUS));\r\nsirfport->ms_enabled = 1;\r\n}\r\nstatic void sirfsoc_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned long ulcon = rd_regl(port, SIRFUART_LINE_CTRL);\r\nif (break_state)\r\nulcon |= SIRFUART_SET_BREAK;\r\nelse\r\nulcon &= ~SIRFUART_SET_BREAK;\r\nwr_regl(port, SIRFUART_LINE_CTRL, ulcon);\r\n}\r\nstatic unsigned int\r\nsirfsoc_uart_pio_rx_chars(struct uart_port *port, unsigned int max_rx_count)\r\n{\r\nunsigned int ch, rx_count = 0;\r\nstruct tty_struct *tty;\r\ntty = tty_port_tty_get(&port->state->port);\r\nif (!tty)\r\nreturn -ENODEV;\r\nwhile (!(rd_regl(port, SIRFUART_RX_FIFO_STATUS) &\r\nSIRFUART_FIFOEMPTY_MASK(port))) {\r\nch = rd_regl(port, SIRFUART_RX_FIFO_DATA) | SIRFUART_DUMMY_READ;\r\nif (unlikely(uart_handle_sysrq_char(port, ch)))\r\ncontinue;\r\nuart_insert_char(port, 0, 0, ch, TTY_NORMAL);\r\nrx_count++;\r\nif (rx_count >= max_rx_count)\r\nbreak;\r\n}\r\nport->icount.rx += rx_count;\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\nreturn rx_count;\r\n}\r\nstatic unsigned int\r\nsirfsoc_uart_pio_tx_chars(struct sirfsoc_uart_port *sirfport, int count)\r\n{\r\nstruct uart_port *port = &sirfport->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int num_tx = 0;\r\nwhile (!uart_circ_empty(xmit) &&\r\n!(rd_regl(port, SIRFUART_TX_FIFO_STATUS) &\r\nSIRFUART_FIFOFULL_MASK(port)) &&\r\ncount--) {\r\nwr_regl(port, SIRFUART_TX_FIFO_DATA, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nnum_tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nreturn num_tx;\r\n}\r\nstatic irqreturn_t sirfsoc_uart_isr(int irq, void *dev_id)\r\n{\r\nunsigned long intr_status;\r\nunsigned long cts_status;\r\nunsigned long flag = TTY_NORMAL;\r\nstruct sirfsoc_uart_port *sirfport = (struct sirfsoc_uart_port *)dev_id;\r\nstruct uart_port *port = &sirfport->port;\r\nstruct uart_state *state = port->state;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nintr_status = rd_regl(port, SIRFUART_INT_STATUS);\r\nwr_regl(port, SIRFUART_INT_STATUS, intr_status);\r\nintr_status &= rd_regl(port, SIRFUART_INT_EN);\r\nif (unlikely(intr_status & (SIRFUART_ERR_INT_STAT))) {\r\nif (intr_status & SIRFUART_RXD_BREAK) {\r\nif (uart_handle_break(port))\r\ngoto recv_char;\r\nuart_insert_char(port, intr_status,\r\nSIRFUART_RX_OFLOW, 0, TTY_BREAK);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (intr_status & SIRFUART_RX_OFLOW)\r\nport->icount.overrun++;\r\nif (intr_status & SIRFUART_FRM_ERR) {\r\nport->icount.frame++;\r\nflag = TTY_FRAME;\r\n}\r\nif (intr_status & SIRFUART_PARITY_ERR)\r\nflag = TTY_PARITY;\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, SIRFUART_RX_FIFO_RESET);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, 0);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, SIRFUART_RX_FIFO_START);\r\nintr_status &= port->read_status_mask;\r\nuart_insert_char(port, intr_status,\r\nSIRFUART_RX_OFLOW_INT, 0, flag);\r\n}\r\nrecv_char:\r\nif (intr_status & SIRFUART_CTS_INT_EN) {\r\ncts_status = !(rd_regl(port, SIRFUART_AFC_CTRL) &\r\nSIRFUART_CTS_IN_STATUS);\r\nif (cts_status != 0) {\r\nuart_handle_cts_change(port, 1);\r\n} else {\r\nuart_handle_cts_change(port, 0);\r\nwake_up_interruptible(&state->port.delta_msr_wait);\r\n}\r\n}\r\nif (intr_status & SIRFUART_RX_IO_INT_EN)\r\nsirfsoc_uart_pio_rx_chars(port, SIRFSOC_UART_IO_RX_MAX_CNT);\r\nif (intr_status & SIRFUART_TX_INT_EN) {\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nreturn IRQ_HANDLED;\r\n} else {\r\nsirfsoc_uart_pio_tx_chars(sirfport,\r\nSIRFSOC_UART_IO_TX_REASONABLE_CNT);\r\nif ((uart_circ_empty(xmit)) &&\r\n(rd_regl(port, SIRFUART_TX_FIFO_STATUS) &\r\nSIRFUART_FIFOEMPTY_MASK(port)))\r\nsirfsoc_uart_stop_tx(port);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sirfsoc_uart_start_rx(struct uart_port *port)\r\n{\r\nunsigned long regv;\r\nregv = rd_regl(port, SIRFUART_INT_EN);\r\nwr_regl(port, SIRFUART_INT_EN, regv | SIRFUART_RX_IO_INT_EN);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, SIRFUART_RX_FIFO_RESET);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, 0);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, SIRFUART_RX_FIFO_START);\r\n}\r\nstatic unsigned int\r\nsirfsoc_calc_sample_div(unsigned long baud_rate,\r\nunsigned long ioclk_rate, unsigned long *setted_baud)\r\n{\r\nunsigned long min_delta = ~0UL;\r\nunsigned short sample_div;\r\nunsigned int regv = 0;\r\nunsigned long ioclk_div;\r\nunsigned long baud_tmp;\r\nint temp_delta;\r\nfor (sample_div = SIRF_MIN_SAMPLE_DIV;\r\nsample_div <= SIRF_MAX_SAMPLE_DIV; sample_div++) {\r\nioclk_div = (ioclk_rate / (baud_rate * (sample_div + 1))) - 1;\r\nif (ioclk_div > SIRF_IOCLK_DIV_MAX)\r\ncontinue;\r\nbaud_tmp = ioclk_rate / ((ioclk_div + 1) * (sample_div + 1));\r\ntemp_delta = baud_tmp - baud_rate;\r\ntemp_delta = (temp_delta > 0) ? temp_delta : -temp_delta;\r\nif (temp_delta < min_delta) {\r\nregv = regv & (~SIRF_IOCLK_DIV_MASK);\r\nregv = regv | ioclk_div;\r\nregv = regv & (~SIRF_SAMPLE_DIV_MASK);\r\nregv = regv | (sample_div << SIRF_SAMPLE_DIV_SHIFT);\r\nmin_delta = temp_delta;\r\n*setted_baud = baud_tmp;\r\n}\r\n}\r\nreturn regv;\r\n}\r\nstatic void sirfsoc_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nunsigned long ioclk_rate;\r\nunsigned long config_reg = 0;\r\nunsigned long baud_rate;\r\nunsigned long setted_baud;\r\nunsigned long flags;\r\nunsigned long ic;\r\nunsigned int clk_div_reg = 0;\r\nunsigned long temp_reg_val;\r\nunsigned long rx_time_out;\r\nint threshold_div;\r\nint temp;\r\nioclk_rate = 150000000;\r\nswitch (termios->c_cflag & CSIZE) {\r\ndefault:\r\ncase CS8:\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_8;\r\nbreak;\r\ncase CS7:\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_7;\r\nbreak;\r\ncase CS6:\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_6;\r\nbreak;\r\ncase CS5:\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_5;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nconfig_reg |= SIRFUART_STOP_BIT_LEN_2;\r\nbaud_rate = uart_get_baud_rate(port, termios, old, 0, 4000000);\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->read_status_mask = SIRFUART_RX_OFLOW_INT;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |=\r\nSIRFUART_FRM_ERR_INT | SIRFUART_PARITY_ERR_INT;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= SIRFUART_RXD_BREAK_INT;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |=\r\nSIRFUART_FRM_ERR_INT | SIRFUART_PARITY_ERR_INT;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= SIRFUART_DUMMY_READ;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\nconfig_reg |= SIRFUART_STICK_BIT_MARK;\r\nelse\r\nconfig_reg |= SIRFUART_STICK_BIT_SPACE;\r\n} else if (termios->c_cflag & PARODD) {\r\nconfig_reg |= SIRFUART_STICK_BIT_ODD;\r\n} else {\r\nconfig_reg |= SIRFUART_STICK_BIT_EVEN;\r\n}\r\n}\r\nif (UART_ENABLE_MS(port, termios->c_cflag)) {\r\nif (!sirfport->ms_enabled)\r\nsirfsoc_uart_enable_ms(port);\r\n} else {\r\nif (sirfport->ms_enabled)\r\nsirfsoc_uart_disable_ms(port);\r\n}\r\nfor (ic = 0; ic < SIRF_BAUD_RATE_SUPPORT_NR; ic++)\r\nif (baud_rate == baudrate_to_regv[ic].baud_rate)\r\nclk_div_reg = baudrate_to_regv[ic].reg_val;\r\nsetted_baud = baud_rate;\r\nif (unlikely(clk_div_reg == 0))\r\nclk_div_reg = sirfsoc_calc_sample_div(baud_rate, ioclk_rate,\r\n&setted_baud);\r\nwr_regl(port, SIRFUART_DIVISOR, clk_div_reg);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, setted_baud, setted_baud);\r\nrx_time_out = SIRFSOC_UART_RX_TIMEOUT(baud_rate, 20000);\r\nrx_time_out = (rx_time_out > 0xFFFF) ? 0xFFFF : rx_time_out;\r\nconfig_reg |= SIRFUART_RECV_TIMEOUT(rx_time_out);\r\ntemp_reg_val = rd_regl(port, SIRFUART_TX_FIFO_OP);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, 0);\r\nwr_regl(port, SIRFUART_TX_FIFO_OP,\r\ntemp_reg_val & ~SIRFUART_TX_FIFO_START);\r\nwr_regl(port, SIRFUART_TX_DMA_IO_CTRL, SIRFUART_TX_MODE_IO);\r\nwr_regl(port, SIRFUART_RX_DMA_IO_CTRL, SIRFUART_RX_MODE_IO);\r\nwr_regl(port, SIRFUART_LINE_CTRL, config_reg);\r\nif (baud_rate < 1000000)\r\nthreshold_div = 1;\r\nelse\r\nthreshold_div = 2;\r\ntemp = port->line == 1 ? 16 : 64;\r\nwr_regl(port, SIRFUART_TX_FIFO_CTRL, temp / threshold_div);\r\nwr_regl(port, SIRFUART_RX_FIFO_CTRL, temp / threshold_div);\r\ntemp_reg_val |= SIRFUART_TX_FIFO_START;\r\nwr_regl(port, SIRFUART_TX_FIFO_OP, temp_reg_val);\r\nuart_update_timeout(port, termios->c_cflag, baud_rate);\r\nsirfsoc_uart_start_rx(port);\r\nwr_regl(port, SIRFUART_TX_RX_EN, SIRFUART_TX_EN | SIRFUART_RX_EN);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void startup_uart_controller(struct uart_port *port)\r\n{\r\nunsigned long temp_regv;\r\nint temp;\r\ntemp_regv = rd_regl(port, SIRFUART_TX_DMA_IO_CTRL);\r\nwr_regl(port, SIRFUART_TX_DMA_IO_CTRL, temp_regv | SIRFUART_TX_MODE_IO);\r\ntemp_regv = rd_regl(port, SIRFUART_RX_DMA_IO_CTRL);\r\nwr_regl(port, SIRFUART_RX_DMA_IO_CTRL, temp_regv | SIRFUART_RX_MODE_IO);\r\nwr_regl(port, SIRFUART_TX_DMA_IO_LEN, 0);\r\nwr_regl(port, SIRFUART_RX_DMA_IO_LEN, 0);\r\nwr_regl(port, SIRFUART_TX_RX_EN, SIRFUART_RX_EN | SIRFUART_TX_EN);\r\nwr_regl(port, SIRFUART_TX_FIFO_OP, SIRFUART_TX_FIFO_RESET);\r\nwr_regl(port, SIRFUART_TX_FIFO_OP, 0);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, SIRFUART_RX_FIFO_RESET);\r\nwr_regl(port, SIRFUART_RX_FIFO_OP, 0);\r\ntemp = port->line == 1 ? 16 : 64;\r\nwr_regl(port, SIRFUART_TX_FIFO_CTRL, temp);\r\nwr_regl(port, SIRFUART_RX_FIFO_CTRL, temp);\r\n}\r\nstatic int sirfsoc_uart_startup(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nunsigned int index = port->line;\r\nint ret;\r\nset_irq_flags(port->irq, IRQF_VALID | IRQF_NOAUTOEN);\r\nret = request_irq(port->irq,\r\nsirfsoc_uart_isr,\r\n0,\r\nSIRFUART_PORT_NAME,\r\nsirfport);\r\nif (ret != 0) {\r\ndev_err(port->dev, "UART%d request IRQ line (%d) failed.\n",\r\nindex, port->irq);\r\ngoto irq_err;\r\n}\r\nstartup_uart_controller(port);\r\nenable_irq(port->irq);\r\nirq_err:\r\nreturn ret;\r\n}\r\nstatic void sirfsoc_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nwr_regl(port, SIRFUART_INT_EN, 0);\r\nfree_irq(port->irq, sirfport);\r\nif (sirfport->ms_enabled) {\r\nsirfsoc_uart_disable_ms(port);\r\nsirfport->ms_enabled = 0;\r\n}\r\n}\r\nstatic const char *sirfsoc_uart_type(struct uart_port *port)\r\n{\r\nreturn port->type == SIRFSOC_PORT_TYPE ? SIRFUART_PORT_NAME : NULL;\r\n}\r\nstatic int sirfsoc_uart_request_port(struct uart_port *port)\r\n{\r\nvoid *ret;\r\nret = request_mem_region(port->mapbase,\r\nSIRFUART_MAP_SIZE, SIRFUART_PORT_NAME);\r\nreturn ret ? 0 : -EBUSY;\r\n}\r\nstatic void sirfsoc_uart_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, SIRFUART_MAP_SIZE);\r\n}\r\nstatic void sirfsoc_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = SIRFSOC_PORT_TYPE;\r\nsirfsoc_uart_request_port(port);\r\n}\r\n}\r\nstatic int __init sirfsoc_uart_console_setup(struct console *co, char *options)\r\n{\r\nunsigned int baud = 115200;\r\nunsigned int bits = 8;\r\nunsigned int parity = 'n';\r\nunsigned int flow = 'n';\r\nstruct uart_port *port = &sirfsoc_uart_ports[co->index].port;\r\nif (co->index < 0 || co->index >= SIRFSOC_UART_NR)\r\nreturn -EINVAL;\r\nif (!port->mapbase)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nport->cons = co;\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic void sirfsoc_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (rd_regl(port,\r\nSIRFUART_TX_FIFO_STATUS) & SIRFUART_FIFOFULL_MASK(port))\r\ncpu_relax();\r\nwr_regb(port, SIRFUART_TX_FIFO_DATA, ch);\r\n}\r\nstatic void sirfsoc_uart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &sirfsoc_uart_ports[co->index].port;\r\nuart_console_write(port, s, count, sirfsoc_uart_console_putchar);\r\n}\r\nstatic int __init sirfsoc_uart_console_init(void)\r\n{\r\nregister_console(&sirfsoc_uart_console);\r\nreturn 0;\r\n}\r\nint sirfsoc_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct sirfsoc_uart_port *sirfport;\r\nstruct uart_port *port;\r\nstruct resource *res;\r\nint ret;\r\nif (of_property_read_u32(pdev->dev.of_node, "cell-index", &pdev->id)) {\r\ndev_err(&pdev->dev,\r\n"Unable to find cell-index in uart node.\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nsirfport = &sirfsoc_uart_ports[pdev->id];\r\nport = &sirfport->port;\r\nport->dev = &pdev->dev;\r\nport->private_data = sirfport;\r\nif (of_find_property(pdev->dev.of_node, "hw_flow_ctrl", NULL))\r\nsirfport->hw_flow_ctrl = 1;\r\nif (of_property_read_u32(pdev->dev.of_node,\r\n"fifosize",\r\n&port->fifosize)) {\r\ndev_err(&pdev->dev,\r\n"Unable to find fifosize in uart node.\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Insufficient resources.\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nport->mapbase = res->start;\r\nport->membase = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!port->membase) {\r\ndev_err(&pdev->dev, "Cannot remap resource.\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Insufficient resources.\n");\r\nret = -EFAULT;\r\ngoto irq_err;\r\n}\r\nport->irq = res->start;\r\nif (sirfport->hw_flow_ctrl) {\r\nsirfport->p = pinctrl_get_select_default(&pdev->dev);\r\nret = IS_ERR(sirfport->p);\r\nif (ret)\r\ngoto pin_err;\r\n}\r\nport->ops = &sirfsoc_uart_ops;\r\nspin_lock_init(&port->lock);\r\nplatform_set_drvdata(pdev, sirfport);\r\nret = uart_add_one_port(&sirfsoc_uart_drv, port);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Cannot add UART port(%d).\n", pdev->id);\r\ngoto port_err;\r\n}\r\nreturn 0;\r\nport_err:\r\nplatform_set_drvdata(pdev, NULL);\r\nif (sirfport->hw_flow_ctrl)\r\npinctrl_put(sirfport->p);\r\npin_err:\r\nirq_err:\r\ndevm_iounmap(&pdev->dev, port->membase);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int sirfsoc_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = platform_get_drvdata(pdev);\r\nstruct uart_port *port = &sirfport->port;\r\nplatform_set_drvdata(pdev, NULL);\r\nif (sirfport->hw_flow_ctrl)\r\npinctrl_put(sirfport->p);\r\ndevm_iounmap(&pdev->dev, port->membase);\r\nuart_remove_one_port(&sirfsoc_uart_drv, port);\r\nreturn 0;\r\n}\r\nstatic int\r\nsirfsoc_uart_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = platform_get_drvdata(pdev);\r\nstruct uart_port *port = &sirfport->port;\r\nuart_suspend_port(&sirfsoc_uart_drv, port);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_uart_resume(struct platform_device *pdev)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = platform_get_drvdata(pdev);\r\nstruct uart_port *port = &sirfport->port;\r\nuart_resume_port(&sirfsoc_uart_drv, port);\r\nreturn 0;\r\n}\r\nstatic int __init sirfsoc_uart_init(void)\r\n{\r\nint ret = 0;\r\nret = uart_register_driver(&sirfsoc_uart_drv);\r\nif (ret)\r\ngoto out;\r\nret = platform_driver_register(&sirfsoc_uart_driver);\r\nif (ret)\r\nuart_unregister_driver(&sirfsoc_uart_drv);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit sirfsoc_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&sirfsoc_uart_driver);\r\nuart_unregister_driver(&sirfsoc_uart_drv);\r\n}
