static inline struct saa6588 *to_saa6588(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa6588, sd);\r\n}\r\nstatic int block_to_user_buf(struct saa6588 *s, unsigned char __user *user_buf)\r\n{\r\nint i;\r\nif (s->rd_index == s->wr_index) {\r\nif (debug > 2)\r\ndprintk(PREFIX "Read: buffer empty.\n");\r\nreturn 0;\r\n}\r\nif (debug > 2) {\r\ndprintk(PREFIX "Read: ");\r\nfor (i = s->rd_index; i < s->rd_index + 3; i++)\r\ndprintk("0x%02x ", s->buffer[i]);\r\n}\r\nif (copy_to_user(user_buf, &s->buffer[s->rd_index], 3))\r\nreturn -EFAULT;\r\ns->rd_index += 3;\r\nif (s->rd_index >= s->buf_size)\r\ns->rd_index = 0;\r\ns->block_count--;\r\nif (debug > 2)\r\ndprintk("%d blocks total.\n", s->block_count);\r\nreturn 1;\r\n}\r\nstatic void read_from_buf(struct saa6588 *s, struct saa6588_command *a)\r\n{\r\nunsigned long flags;\r\nunsigned char __user *buf_ptr = a->buffer;\r\nunsigned int i;\r\nunsigned int rd_blocks;\r\na->result = 0;\r\nif (!a->buffer)\r\nreturn;\r\nwhile (!s->data_available_for_read) {\r\nint ret = wait_event_interruptible(s->read_queue,\r\ns->data_available_for_read);\r\nif (ret == -ERESTARTSYS) {\r\na->result = -EINTR;\r\nreturn;\r\n}\r\n}\r\nspin_lock_irqsave(&s->lock, flags);\r\nrd_blocks = a->block_count;\r\nif (rd_blocks > s->block_count)\r\nrd_blocks = s->block_count;\r\nif (!rd_blocks) {\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn;\r\n}\r\nfor (i = 0; i < rd_blocks; i++) {\r\nif (block_to_user_buf(s, buf_ptr)) {\r\nbuf_ptr += 3;\r\na->result++;\r\n} else\r\nbreak;\r\n}\r\na->result *= 3;\r\ns->data_available_for_read = (s->block_count > 0);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic void block_to_buf(struct saa6588 *s, unsigned char *blockbuf)\r\n{\r\nunsigned int i;\r\nif (debug > 3)\r\ndprintk(PREFIX "New block: ");\r\nfor (i = 0; i < 3; ++i) {\r\nif (debug > 3)\r\ndprintk("0x%02x ", blockbuf[i]);\r\ns->buffer[s->wr_index] = blockbuf[i];\r\ns->wr_index++;\r\n}\r\nif (s->wr_index >= s->buf_size)\r\ns->wr_index = 0;\r\nif (s->wr_index == s->rd_index) {\r\ns->rd_index += 3;\r\nif (s->rd_index >= s->buf_size)\r\ns->rd_index = 0;\r\n} else\r\ns->block_count++;\r\nif (debug > 3)\r\ndprintk("%d blocks total.\n", s->block_count);\r\n}\r\nstatic void saa6588_i2c_poll(struct saa6588 *s)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s->sd);\r\nunsigned long flags;\r\nunsigned char tmpbuf[6];\r\nunsigned char blocknum;\r\nunsigned char tmp;\r\nif (6 != i2c_master_recv(client, &tmpbuf[0], 6)) {\r\nif (debug > 1)\r\ndprintk(PREFIX "read error!\n");\r\nreturn;\r\n}\r\ns->sync = tmpbuf[0] & 0x10;\r\nif (!s->sync)\r\nreturn;\r\nblocknum = tmpbuf[0] >> 5;\r\nif (blocknum == s->last_blocknum) {\r\nif (debug > 3)\r\ndprintk("Saw block %d again.\n", blocknum);\r\nreturn;\r\n}\r\ns->last_blocknum = blocknum;\r\ntmp = tmpbuf[2];\r\ntmpbuf[2] = tmpbuf[0];\r\ntmpbuf[0] = tmp;\r\nif (blocknum == 6)\r\nblocknum = V4L2_RDS_BLOCK_INVALID;\r\nelse if (!mmbs && blocknum == 5)\r\nblocknum = V4L2_RDS_BLOCK_INVALID;\r\ntmp = blocknum;\r\ntmp |= blocknum << 3;\r\nif ((tmpbuf[2] & 0x03) == 0x03)\r\ntmp |= V4L2_RDS_BLOCK_ERROR;\r\nelse if ((tmpbuf[2] & 0x03) != 0x00)\r\ntmp |= V4L2_RDS_BLOCK_CORRECTED;\r\ntmpbuf[2] = tmp;\r\nspin_lock_irqsave(&s->lock, flags);\r\nblock_to_buf(s, tmpbuf);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\ns->data_available_for_read = 1;\r\nwake_up_interruptible(&s->read_queue);\r\n}\r\nstatic void saa6588_work(struct work_struct *work)\r\n{\r\nstruct saa6588 *s = container_of(work, struct saa6588, work.work);\r\nsaa6588_i2c_poll(s);\r\nschedule_delayed_work(&s->work, msecs_to_jiffies(20));\r\n}\r\nstatic void saa6588_configure(struct saa6588 *s)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s->sd);\r\nunsigned char buf[3];\r\nint rc;\r\nbuf[0] = cSyncRestart;\r\nif (mmbs)\r\nbuf[0] |= cProcessingModeRBDS;\r\nbuf[1] = cFlywheelDefault;\r\nswitch (plvl) {\r\ncase 0:\r\nbuf[1] |= cPauseLevel_11mV;\r\nbreak;\r\ncase 1:\r\nbuf[1] |= cPauseLevel_17mV;\r\nbreak;\r\ncase 2:\r\nbuf[1] |= cPauseLevel_27mV;\r\nbreak;\r\ncase 3:\r\nbuf[1] |= cPauseLevel_43mV;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbuf[2] = cQualityDetectDefault | cSelectOscFreqON;\r\nswitch (xtal) {\r\ncase 0:\r\nbuf[2] |= cOscFreq_4332kHz;\r\nbreak;\r\ncase 1:\r\nbuf[2] |= cOscFreq_8664kHz;\r\nbreak;\r\ncase 2:\r\nbuf[2] |= cOscFreq_12996kHz;\r\nbreak;\r\ncase 3:\r\nbuf[2] |= cOscFreq_17328kHz;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndprintk(PREFIX "writing: 0w=0x%02x 1w=0x%02x 2w=0x%02x\n",\r\nbuf[0], buf[1], buf[2]);\r\nrc = i2c_master_send(client, buf, 3);\r\nif (rc != 3)\r\nprintk(PREFIX "i2c i/o error: rc == %d (should be 3)\n", rc);\r\n}\r\nstatic long saa6588_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct saa6588 *s = to_saa6588(sd);\r\nstruct saa6588_command *a = arg;\r\nswitch (cmd) {\r\ncase SAA6588_CMD_OPEN:\r\na->result = 0;\r\nbreak;\r\ncase SAA6588_CMD_CLOSE:\r\ns->data_available_for_read = 1;\r\nwake_up_interruptible(&s->read_queue);\r\na->result = 0;\r\nbreak;\r\ncase SAA6588_CMD_READ:\r\nread_from_buf(s, a);\r\nbreak;\r\ncase SAA6588_CMD_POLL:\r\na->result = 0;\r\nif (s->data_available_for_read) {\r\na->result |= POLLIN | POLLRDNORM;\r\n}\r\npoll_wait(a->instance, &s->read_queue, a->event_list);\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa6588_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct saa6588 *s = to_saa6588(sd);\r\nvt->capability |= V4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_BLOCK_IO;\r\nif (s->sync)\r\nvt->rxsubchans |= V4L2_TUNER_SUB_RDS;\r\nreturn 0;\r\n}\r\nstatic int saa6588_s_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct saa6588 *s = to_saa6588(sd);\r\nsaa6588_configure(s);\r\nreturn 0;\r\n}\r\nstatic int saa6588_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SAA6588, 0);\r\n}\r\nstatic int saa6588_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct saa6588 *s;\r\nstruct v4l2_subdev *sd;\r\nv4l_info(client, "saa6588 found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\ns = kzalloc(sizeof(*s), GFP_KERNEL);\r\nif (s == NULL)\r\nreturn -ENOMEM;\r\ns->buf_size = bufblocks * 3;\r\ns->buffer = kmalloc(s->buf_size, GFP_KERNEL);\r\nif (s->buffer == NULL) {\r\nkfree(s);\r\nreturn -ENOMEM;\r\n}\r\nsd = &s->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa6588_ops);\r\nspin_lock_init(&s->lock);\r\ns->block_count = 0;\r\ns->wr_index = 0;\r\ns->rd_index = 0;\r\ns->last_blocknum = 0xff;\r\ninit_waitqueue_head(&s->read_queue);\r\ns->data_available_for_read = 0;\r\nsaa6588_configure(s);\r\nINIT_DELAYED_WORK(&s->work, saa6588_work);\r\nschedule_delayed_work(&s->work, 0);\r\nreturn 0;\r\n}\r\nstatic int saa6588_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct saa6588 *s = to_saa6588(sd);\r\nv4l2_device_unregister_subdev(sd);\r\ncancel_delayed_work_sync(&s->work);\r\nkfree(s->buffer);\r\nkfree(s);\r\nreturn 0;\r\n}
