static inline void mxcmci_init_ocr(struct mxcmci_host *host)\r\n{\r\nhost->vcc = regulator_get(mmc_dev(host->mmc), "vmmc");\r\nif (IS_ERR(host->vcc)) {\r\nhost->vcc = NULL;\r\n} else {\r\nhost->mmc->ocr_avail = mmc_regulator_get_ocrmask(host->vcc);\r\nif (host->pdata && host->pdata->ocr_avail)\r\ndev_warn(mmc_dev(host->mmc),\r\n"pdata->ocr_avail will not be used\n");\r\n}\r\nif (host->vcc == NULL) {\r\nif (host->pdata && host->pdata->ocr_avail)\r\nhost->mmc->ocr_avail = host->pdata->ocr_avail;\r\nelse\r\nhost->mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\n}\r\n}\r\nstatic inline void mxcmci_set_power(struct mxcmci_host *host,\r\nunsigned char power_mode,\r\nunsigned int vdd)\r\n{\r\nif (host->vcc) {\r\nif (power_mode == MMC_POWER_UP)\r\nmmc_regulator_set_ocr(host->mmc, host->vcc, vdd);\r\nelse if (power_mode == MMC_POWER_OFF)\r\nmmc_regulator_set_ocr(host->mmc, host->vcc, 0);\r\n}\r\nif (host->pdata && host->pdata->setpower)\r\nhost->pdata->setpower(mmc_dev(host->mmc), vdd);\r\n}\r\nstatic inline int mxcmci_use_dma(struct mxcmci_host *host)\r\n{\r\nreturn host->do_dma;\r\n}\r\nstatic void mxcmci_softreset(struct mxcmci_host *host)\r\n{\r\nint i;\r\ndev_dbg(mmc_dev(host->mmc), "mxcmci_softreset\n");\r\nwritew(STR_STP_CLK_RESET, host->base + MMC_REG_STR_STP_CLK);\r\nwritew(STR_STP_CLK_RESET | STR_STP_CLK_START_CLK,\r\nhost->base + MMC_REG_STR_STP_CLK);\r\nfor (i = 0; i < 8; i++)\r\nwritew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);\r\nwritew(0xff, host->base + MMC_REG_RES_TO);\r\n}\r\nstatic int mxcmci_setup_data(struct mxcmci_host *host, struct mmc_data *data)\r\n{\r\nunsigned int nob = data->blocks;\r\nunsigned int blksz = data->blksz;\r\nunsigned int datasize = nob * blksz;\r\nstruct scatterlist *sg;\r\nenum dma_transfer_direction slave_dirn;\r\nint i, nents;\r\nif (data->flags & MMC_DATA_STREAM)\r\nnob = 0xffff;\r\nhost->data = data;\r\ndata->bytes_xfered = 0;\r\nwritew(nob, host->base + MMC_REG_NOB);\r\nwritew(blksz, host->base + MMC_REG_BLK_LEN);\r\nhost->datasize = datasize;\r\nif (!mxcmci_use_dma(host))\r\nreturn 0;\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nif (sg->offset & 3 || sg->length & 3) {\r\nhost->do_dma = 0;\r\nreturn 0;\r\n}\r\n}\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->dma_dir = DMA_FROM_DEVICE;\r\nslave_dirn = DMA_DEV_TO_MEM;\r\n} else {\r\nhost->dma_dir = DMA_TO_DEVICE;\r\nslave_dirn = DMA_MEM_TO_DEV;\r\n}\r\nnents = dma_map_sg(host->dma->device->dev, data->sg,\r\ndata->sg_len, host->dma_dir);\r\nif (nents != data->sg_len)\r\nreturn -EINVAL;\r\nhost->desc = dmaengine_prep_slave_sg(host->dma,\r\ndata->sg, data->sg_len, slave_dirn,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!host->desc) {\r\ndma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,\r\nhost->dma_dir);\r\nhost->do_dma = 0;\r\nreturn 0;\r\n}\r\nwmb();\r\ndmaengine_submit(host->desc);\r\ndma_async_issue_pending(host->dma);\r\nreturn 0;\r\n}\r\nstatic int mxcmci_start_cmd(struct mxcmci_host *host, struct mmc_command *cmd,\r\nunsigned int cmdat)\r\n{\r\nu32 int_cntr = host->default_irq_mask;\r\nunsigned long flags;\r\nWARN_ON(host->cmd != NULL);\r\nhost->cmd = cmd;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_R1:\r\ncase MMC_RSP_R1B:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_48BIT_CRC;\r\nbreak;\r\ncase MMC_RSP_R2:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_136BIT;\r\nbreak;\r\ncase MMC_RSP_R3:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_48BIT;\r\nbreak;\r\ncase MMC_RSP_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(mmc_dev(host->mmc), "unhandled response type 0x%x\n",\r\nmmc_resp_type(cmd));\r\ncmd->error = -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nint_cntr = INT_END_CMD_RES_EN;\r\nif (mxcmci_use_dma(host))\r\nint_cntr |= INT_READ_OP_EN | INT_WRITE_OP_DONE_EN;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (host->use_sdio)\r\nint_cntr |= INT_SDIO_IRQ_EN;\r\nwritel(int_cntr, host->base + MMC_REG_INT_CNTR);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nwritew(cmd->opcode, host->base + MMC_REG_CMD);\r\nwritel(cmd->arg, host->base + MMC_REG_ARG);\r\nwritew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);\r\nreturn 0;\r\n}\r\nstatic void mxcmci_finish_request(struct mxcmci_host *host,\r\nstruct mmc_request *req)\r\n{\r\nu32 int_cntr = host->default_irq_mask;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (host->use_sdio)\r\nint_cntr |= INT_SDIO_IRQ_EN;\r\nwritel(int_cntr, host->base + MMC_REG_INT_CNTR);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nhost->req = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nmmc_request_done(host->mmc, req);\r\n}\r\nstatic int mxcmci_finish_data(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\nint data_error;\r\nif (mxcmci_use_dma(host)) {\r\ndmaengine_terminate_all(host->dma);\r\ndma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,\r\nhost->dma_dir);\r\n}\r\nif (stat & STATUS_ERR_MASK) {\r\ndev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n",\r\nstat);\r\nif (stat & STATUS_CRC_READ_ERR) {\r\ndev_err(mmc_dev(host->mmc), "%s: -EILSEQ\n", __func__);\r\ndata->error = -EILSEQ;\r\n} else if (stat & STATUS_CRC_WRITE_ERR) {\r\nu32 err_code = (stat >> 9) & 0x3;\r\nif (err_code == 2) {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: No CRC -ETIMEDOUT\n", __func__);\r\ndata->error = -ETIMEDOUT;\r\n} else {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: -EILSEQ\n", __func__);\r\ndata->error = -EILSEQ;\r\n}\r\n} else if (stat & STATUS_TIME_OUT_READ) {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: read -ETIMEDOUT\n", __func__);\r\ndata->error = -ETIMEDOUT;\r\n} else {\r\ndev_err(mmc_dev(host->mmc), "%s: -EIO\n", __func__);\r\ndata->error = -EIO;\r\n}\r\n} else {\r\ndata->bytes_xfered = host->datasize;\r\n}\r\ndata_error = data->error;\r\nhost->data = NULL;\r\nreturn data_error;\r\n}\r\nstatic void mxcmci_read_response(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nint i;\r\nu32 a, b, c;\r\nif (!cmd)\r\nreturn;\r\nif (stat & STATUS_TIME_OUT_RESP) {\r\ndev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");\r\ncmd->error = -ETIMEDOUT;\r\n} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {\r\ndev_dbg(mmc_dev(host->mmc), "cmd crc error\n");\r\ncmd->error = -EILSEQ;\r\n}\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\nfor (i = 0; i < 4; i++) {\r\na = readw(host->base + MMC_REG_RES_FIFO);\r\nb = readw(host->base + MMC_REG_RES_FIFO);\r\ncmd->resp[i] = a << 16 | b;\r\n}\r\n} else {\r\na = readw(host->base + MMC_REG_RES_FIFO);\r\nb = readw(host->base + MMC_REG_RES_FIFO);\r\nc = readw(host->base + MMC_REG_RES_FIFO);\r\ncmd->resp[0] = a << 24 | b << 8 | c >> 8;\r\n}\r\n}\r\n}\r\nstatic int mxcmci_poll_status(struct mxcmci_host *host, u32 mask)\r\n{\r\nu32 stat;\r\nunsigned long timeout = jiffies + HZ;\r\ndo {\r\nstat = readl(host->base + MMC_REG_STATUS);\r\nif (stat & STATUS_ERR_MASK)\r\nreturn stat;\r\nif (time_after(jiffies, timeout)) {\r\nmxcmci_softreset(host);\r\nmxcmci_set_clk_rate(host, host->clock);\r\nreturn STATUS_TIME_OUT_READ;\r\n}\r\nif (stat & mask)\r\nreturn 0;\r\ncpu_relax();\r\n} while (1);\r\n}\r\nstatic int mxcmci_pull(struct mxcmci_host *host, void *_buf, int bytes)\r\n{\r\nunsigned int stat;\r\nu32 *buf = _buf;\r\nwhile (bytes > 3) {\r\nstat = mxcmci_poll_status(host,\r\nSTATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);\r\nif (stat)\r\nreturn stat;\r\n*buf++ = readl(host->base + MMC_REG_BUFFER_ACCESS);\r\nbytes -= 4;\r\n}\r\nif (bytes) {\r\nu8 *b = (u8 *)buf;\r\nu32 tmp;\r\nstat = mxcmci_poll_status(host,\r\nSTATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);\r\nif (stat)\r\nreturn stat;\r\ntmp = readl(host->base + MMC_REG_BUFFER_ACCESS);\r\nmemcpy(b, &tmp, bytes);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxcmci_push(struct mxcmci_host *host, void *_buf, int bytes)\r\n{\r\nunsigned int stat;\r\nu32 *buf = _buf;\r\nwhile (bytes > 3) {\r\nstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\r\nif (stat)\r\nreturn stat;\r\nwritel(*buf++, host->base + MMC_REG_BUFFER_ACCESS);\r\nbytes -= 4;\r\n}\r\nif (bytes) {\r\nu8 *b = (u8 *)buf;\r\nu32 tmp;\r\nstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\r\nif (stat)\r\nreturn stat;\r\nmemcpy(&tmp, b, bytes);\r\nwritel(tmp, host->base + MMC_REG_BUFFER_ACCESS);\r\n}\r\nstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\r\nif (stat)\r\nreturn stat;\r\nreturn 0;\r\n}\r\nstatic int mxcmci_transfer_data(struct mxcmci_host *host)\r\n{\r\nstruct mmc_data *data = host->req->data;\r\nstruct scatterlist *sg;\r\nint stat, i;\r\nhost->data = data;\r\nhost->datasize = 0;\r\nif (data->flags & MMC_DATA_READ) {\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nstat = mxcmci_pull(host, sg_virt(sg), sg->length);\r\nif (stat)\r\nreturn stat;\r\nhost->datasize += sg->length;\r\n}\r\n} else {\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nstat = mxcmci_push(host, sg_virt(sg), sg->length);\r\nif (stat)\r\nreturn stat;\r\nhost->datasize += sg->length;\r\n}\r\nstat = mxcmci_poll_status(host, STATUS_WRITE_OP_DONE);\r\nif (stat)\r\nreturn stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mxcmci_datawork(struct work_struct *work)\r\n{\r\nstruct mxcmci_host *host = container_of(work, struct mxcmci_host,\r\ndatawork);\r\nint datastat = mxcmci_transfer_data(host);\r\nwritel(STATUS_READ_OP_DONE | STATUS_WRITE_OP_DONE,\r\nhost->base + MMC_REG_STATUS);\r\nmxcmci_finish_data(host, datastat);\r\nif (host->req->stop) {\r\nif (mxcmci_start_cmd(host, host->req->stop, 0)) {\r\nmxcmci_finish_request(host, host->req);\r\nreturn;\r\n}\r\n} else {\r\nmxcmci_finish_request(host, host->req);\r\n}\r\n}\r\nstatic void mxcmci_data_done(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\nint data_error;\r\nif (!data)\r\nreturn;\r\ndata_error = mxcmci_finish_data(host, stat);\r\nmxcmci_read_response(host, stat);\r\nhost->cmd = NULL;\r\nif (host->req->stop) {\r\nif (mxcmci_start_cmd(host, host->req->stop, 0)) {\r\nmxcmci_finish_request(host, host->req);\r\nreturn;\r\n}\r\n} else {\r\nmxcmci_finish_request(host, host->req);\r\n}\r\n}\r\nstatic void mxcmci_cmd_done(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nmxcmci_read_response(host, stat);\r\nhost->cmd = NULL;\r\nif (!host->data && host->req) {\r\nmxcmci_finish_request(host, host->req);\r\nreturn;\r\n}\r\nif (!mxcmci_use_dma(host) && host->data)\r\nschedule_work(&host->datawork);\r\n}\r\nstatic irqreturn_t mxcmci_irq(int irq, void *devid)\r\n{\r\nstruct mxcmci_host *host = devid;\r\nunsigned long flags;\r\nbool sdio_irq;\r\nu32 stat;\r\nstat = readl(host->base + MMC_REG_STATUS);\r\nwritel(stat & ~(STATUS_SDIO_INT_ACTIVE | STATUS_DATA_TRANS_DONE |\r\nSTATUS_WRITE_OP_DONE), host->base + MMC_REG_STATUS);\r\ndev_dbg(mmc_dev(host->mmc), "%s: 0x%08x\n", __func__, stat);\r\nspin_lock_irqsave(&host->lock, flags);\r\nsdio_irq = (stat & STATUS_SDIO_INT_ACTIVE) && host->use_sdio;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (mxcmci_use_dma(host) &&\r\n(stat & (STATUS_READ_OP_DONE | STATUS_WRITE_OP_DONE)))\r\nwritel(STATUS_READ_OP_DONE | STATUS_WRITE_OP_DONE,\r\nhost->base + MMC_REG_STATUS);\r\nif (sdio_irq) {\r\nwritel(STATUS_SDIO_INT_ACTIVE, host->base + MMC_REG_STATUS);\r\nmmc_signal_sdio_irq(host->mmc);\r\n}\r\nif (stat & STATUS_END_CMD_RESP)\r\nmxcmci_cmd_done(host, stat);\r\nif (mxcmci_use_dma(host) &&\r\n(stat & (STATUS_DATA_TRANS_DONE | STATUS_WRITE_OP_DONE)))\r\nmxcmci_data_done(host, stat);\r\nif (host->default_irq_mask &&\r\n(stat & (STATUS_CARD_INSERTION | STATUS_CARD_REMOVAL)))\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mxcmci_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nunsigned int cmdat = host->cmdat;\r\nint error;\r\nWARN_ON(host->req != NULL);\r\nhost->req = req;\r\nhost->cmdat &= ~CMD_DAT_CONT_INIT;\r\nif (host->dma)\r\nhost->do_dma = 1;\r\nif (req->data) {\r\nerror = mxcmci_setup_data(host, req->data);\r\nif (error) {\r\nreq->cmd->error = error;\r\ngoto out;\r\n}\r\ncmdat |= CMD_DAT_CONT_DATA_ENABLE;\r\nif (req->data->flags & MMC_DATA_WRITE)\r\ncmdat |= CMD_DAT_CONT_WRITE;\r\n}\r\nerror = mxcmci_start_cmd(host, req->cmd, cmdat);\r\nout:\r\nif (error)\r\nmxcmci_finish_request(host, req);\r\n}\r\nstatic void mxcmci_set_clk_rate(struct mxcmci_host *host, unsigned int clk_ios)\r\n{\r\nunsigned int divider;\r\nint prescaler = 0;\r\nunsigned int clk_in = clk_get_rate(host->clk_per);\r\nwhile (prescaler <= 0x800) {\r\nfor (divider = 1; divider <= 0xF; divider++) {\r\nint x;\r\nx = (clk_in / (divider + 1));\r\nif (prescaler)\r\nx /= (prescaler * 2);\r\nif (x <= clk_ios)\r\nbreak;\r\n}\r\nif (divider < 0x10)\r\nbreak;\r\nif (prescaler == 0)\r\nprescaler = 1;\r\nelse\r\nprescaler <<= 1;\r\n}\r\nwritew((prescaler << 4) | divider, host->base + MMC_REG_CLK_RATE);\r\ndev_dbg(mmc_dev(host->mmc), "scaler: %d divider: %d in: %d out: %d\n",\r\nprescaler, divider, clk_in, clk_ios);\r\n}\r\nstatic int mxcmci_setup_dma(struct mmc_host *mmc)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nstruct dma_slave_config *config = &host->dma_slave_config;\r\nconfig->dst_addr = host->res->start + MMC_REG_BUFFER_ACCESS;\r\nconfig->src_addr = host->res->start + MMC_REG_BUFFER_ACCESS;\r\nconfig->dst_addr_width = 4;\r\nconfig->src_addr_width = 4;\r\nconfig->dst_maxburst = host->burstlen;\r\nconfig->src_maxburst = host->burstlen;\r\nconfig->device_fc = false;\r\nreturn dmaengine_slave_config(host->dma, config);\r\n}\r\nstatic void mxcmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nint burstlen, ret;\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nburstlen = 16;\r\nelse\r\nburstlen = 4;\r\nif (mxcmci_use_dma(host) && burstlen != host->burstlen) {\r\nhost->burstlen = burstlen;\r\nret = mxcmci_setup_dma(mmc);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to config DMA channel. Falling back to PIO\n");\r\ndma_release_channel(host->dma);\r\nhost->do_dma = 0;\r\nhost->dma = NULL;\r\n}\r\n}\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nhost->cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;\r\nelse\r\nhost->cmdat &= ~CMD_DAT_CONT_BUS_WIDTH_4;\r\nif (host->power_mode != ios->power_mode) {\r\nmxcmci_set_power(host, ios->power_mode, ios->vdd);\r\nhost->power_mode = ios->power_mode;\r\nif (ios->power_mode == MMC_POWER_ON)\r\nhost->cmdat |= CMD_DAT_CONT_INIT;\r\n}\r\nif (ios->clock) {\r\nmxcmci_set_clk_rate(host, ios->clock);\r\nwritew(STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);\r\n} else {\r\nwritew(STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);\r\n}\r\nhost->clock = ios->clock;\r\n}\r\nstatic irqreturn_t mxcmci_detect_irq(int irq, void *data)\r\n{\r\nstruct mmc_host *mmc = data;\r\ndev_dbg(mmc_dev(mmc), "%s\n", __func__);\r\nmmc_detect_change(mmc, msecs_to_jiffies(250));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxcmci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nif (host->pdata && host->pdata->get_ro)\r\nreturn !!host->pdata->get_ro(mmc_dev(mmc));\r\nreturn -ENOSYS;\r\n}\r\nstatic void mxcmci_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nu32 int_cntr;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->use_sdio = enable;\r\nint_cntr = readl(host->base + MMC_REG_INT_CNTR);\r\nif (enable)\r\nint_cntr |= INT_SDIO_IRQ_EN;\r\nelse\r\nint_cntr &= ~INT_SDIO_IRQ_EN;\r\nwritel(int_cntr, host->base + MMC_REG_INT_CNTR);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void mxcmci_init_card(struct mmc_host *host, struct mmc_card *card)\r\n{\r\nif (cpu_is_mx3() && card->type == MMC_TYPE_SDIO)\r\nhost->caps &= ~MMC_CAP_4_BIT_DATA;\r\nelse\r\nhost->caps |= MMC_CAP_4_BIT_DATA;\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct mxcmci_host *host = param;\r\nif (!imx_dma_is_general_purpose(chan))\r\nreturn false;\r\nchan->private = &host->dma_data;\r\nreturn true;\r\n}\r\nstatic int mxcmci_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct mxcmci_host *host = NULL;\r\nstruct resource *iores, *r;\r\nint ret = 0, irq;\r\ndma_cap_mask_t mask;\r\npr_info("i.MX SDHC driver\n");\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!iores || irq < 0)\r\nreturn -EINVAL;\r\nr = request_mem_region(iores->start, resource_size(iores), pdev->name);\r\nif (!r)\r\nreturn -EBUSY;\r\nmmc = mmc_alloc_host(sizeof(struct mxcmci_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto out_release_mem;\r\n}\r\nmmc->ops = &mxcmci_ops;\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\r\nmmc->max_segs = 64;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 65535;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nhost = mmc_priv(mmc);\r\nhost->base = ioremap(r->start, resource_size(r));\r\nif (!host->base) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nhost->mmc = mmc;\r\nhost->pdata = pdev->dev.platform_data;\r\nspin_lock_init(&host->lock);\r\nmxcmci_init_ocr(host);\r\nif (host->pdata && host->pdata->dat3_card_detect)\r\nhost->default_irq_mask =\r\nINT_CARD_INSERTION_EN | INT_CARD_REMOVAL_EN;\r\nelse\r\nhost->default_irq_mask = 0;\r\nhost->res = r;\r\nhost->irq = irq;\r\nhost->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(host->clk_ipg)) {\r\nret = PTR_ERR(host->clk_ipg);\r\ngoto out_iounmap;\r\n}\r\nhost->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(host->clk_per)) {\r\nret = PTR_ERR(host->clk_per);\r\ngoto out_iounmap;\r\n}\r\nclk_prepare_enable(host->clk_per);\r\nclk_prepare_enable(host->clk_ipg);\r\nmxcmci_softreset(host);\r\nhost->rev_no = readw(host->base + MMC_REG_REV_NO);\r\nif (host->rev_no != 0x400) {\r\nret = -ENODEV;\r\ndev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",\r\nhost->rev_no);\r\ngoto out_clk_put;\r\n}\r\nmmc->f_min = clk_get_rate(host->clk_per) >> 16;\r\nmmc->f_max = clk_get_rate(host->clk_per) >> 1;\r\nwritew(0x2db4, host->base + MMC_REG_READ_TO);\r\nwritel(host->default_irq_mask, host->base + MMC_REG_INT_CNTR);\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (r) {\r\nhost->dmareq = r->start;\r\nhost->dma_data.peripheral_type = IMX_DMATYPE_SDHC;\r\nhost->dma_data.priority = DMA_PRIO_LOW;\r\nhost->dma_data.dma_request = host->dmareq;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhost->dma = dma_request_channel(mask, filter, host);\r\nif (host->dma)\r\nmmc->max_seg_size = dma_get_max_seg_size(\r\nhost->dma->device->dev);\r\n}\r\nif (!host->dma)\r\ndev_info(mmc_dev(host->mmc), "dma not available. Using PIO\n");\r\nINIT_WORK(&host->datawork, mxcmci_datawork);\r\nret = request_irq(host->irq, mxcmci_irq, 0, DRIVER_NAME, host);\r\nif (ret)\r\ngoto out_free_dma;\r\nplatform_set_drvdata(pdev, mmc);\r\nif (host->pdata && host->pdata->init) {\r\nret = host->pdata->init(&pdev->dev, mxcmci_detect_irq,\r\nhost->mmc);\r\nif (ret)\r\ngoto out_free_irq;\r\n}\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(host->irq, host);\r\nout_free_dma:\r\nif (host->dma)\r\ndma_release_channel(host->dma);\r\nout_clk_put:\r\nclk_disable_unprepare(host->clk_per);\r\nclk_disable_unprepare(host->clk_ipg);\r\nout_iounmap:\r\niounmap(host->base);\r\nout_free:\r\nmmc_free_host(mmc);\r\nout_release_mem:\r\nrelease_mem_region(iores->start, resource_size(iores));\r\nreturn ret;\r\n}\r\nstatic int mxcmci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nplatform_set_drvdata(pdev, NULL);\r\nmmc_remove_host(mmc);\r\nif (host->vcc)\r\nregulator_put(host->vcc);\r\nif (host->pdata && host->pdata->exit)\r\nhost->pdata->exit(&pdev->dev, mmc);\r\nfree_irq(host->irq, host);\r\niounmap(host->base);\r\nif (host->dma)\r\ndma_release_channel(host->dma);\r\nclk_disable_unprepare(host->clk_per);\r\nclk_disable_unprepare(host->clk_ipg);\r\nrelease_mem_region(host->res->start, resource_size(host->res));\r\nmmc_free_host(mmc);\r\nreturn 0;\r\n}\r\nstatic int mxcmci_suspend(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nint ret = 0;\r\nif (mmc)\r\nret = mmc_suspend_host(mmc);\r\nclk_disable_unprepare(host->clk_per);\r\nclk_disable_unprepare(host->clk_ipg);\r\nreturn ret;\r\n}\r\nstatic int mxcmci_resume(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nint ret = 0;\r\nclk_prepare_enable(host->clk_per);\r\nclk_prepare_enable(host->clk_ipg);\r\nif (mmc)\r\nret = mmc_resume_host(mmc);\r\nreturn ret;\r\n}
