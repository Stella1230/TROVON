static int valuable(struct ubifs_info *c, const struct ubifs_lprops *lprops)\r\n{\r\nint n, cat = lprops->flags & LPROPS_CAT_MASK;\r\nstruct ubifs_lpt_heap *heap;\r\nswitch (cat) {\r\ncase LPROPS_DIRTY:\r\ncase LPROPS_DIRTY_IDX:\r\ncase LPROPS_FREE:\r\nheap = &c->lpt_heap[cat - 1];\r\nif (heap->cnt < heap->max_cnt)\r\nreturn 1;\r\nif (lprops->free + lprops->dirty >= c->dark_wm)\r\nreturn 1;\r\nreturn 0;\r\ncase LPROPS_EMPTY:\r\nn = c->lst.empty_lebs + c->freeable_cnt -\r\nc->lst.taken_empty_lebs;\r\nif (n < c->lsave_cnt)\r\nreturn 1;\r\nreturn 0;\r\ncase LPROPS_FREEABLE:\r\nreturn 1;\r\ncase LPROPS_FRDI_IDX:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scan_for_dirty_cb(struct ubifs_info *c,\r\nconst struct ubifs_lprops *lprops, int in_tree,\r\nstruct scan_data *data)\r\n{\r\nint ret = LPT_SCAN_CONTINUE;\r\nif (lprops->flags & LPROPS_TAKEN)\r\nreturn LPT_SCAN_CONTINUE;\r\nif (!in_tree && valuable(c, lprops))\r\nret |= LPT_SCAN_ADD;\r\nif (lprops->free + lprops->dirty < data->min_space)\r\nreturn ret;\r\nif (data->exclude_index && lprops->flags & LPROPS_INDEX)\r\nreturn ret;\r\nif (lprops->free + lprops->dirty == c->leb_size) {\r\nif (!data->pick_free)\r\nreturn ret;\r\n} else if (lprops->dirty < c->dead_wm)\r\nreturn ret;\r\ndata->lnum = lprops->lnum;\r\nreturn LPT_SCAN_ADD | LPT_SCAN_STOP;\r\n}\r\nstatic const struct ubifs_lprops *scan_for_dirty(struct ubifs_info *c,\r\nint min_space, int pick_free,\r\nint exclude_index)\r\n{\r\nconst struct ubifs_lprops *lprops;\r\nstruct ubifs_lpt_heap *heap;\r\nstruct scan_data data;\r\nint err, i;\r\nheap = &c->lpt_heap[LPROPS_FREE - 1];\r\nfor (i = 0; i < heap->cnt; i++) {\r\nlprops = heap->arr[i];\r\nif (lprops->free + lprops->dirty < min_space)\r\ncontinue;\r\nif (lprops->dirty < c->dead_wm)\r\ncontinue;\r\nreturn lprops;\r\n}\r\nlist_for_each_entry(lprops, &c->uncat_list, list) {\r\nif (lprops->flags & LPROPS_TAKEN)\r\ncontinue;\r\nif (lprops->free + lprops->dirty < min_space)\r\ncontinue;\r\nif (exclude_index && (lprops->flags & LPROPS_INDEX))\r\ncontinue;\r\nif (lprops->dirty < c->dead_wm)\r\ncontinue;\r\nreturn lprops;\r\n}\r\nif (c->pnodes_have >= c->pnode_cnt)\r\nreturn ERR_PTR(-ENOSPC);\r\ndata.min_space = min_space;\r\ndata.pick_free = pick_free;\r\ndata.lnum = -1;\r\ndata.exclude_index = exclude_index;\r\nerr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\r\n(ubifs_lpt_scan_callback)scan_for_dirty_cb,\r\n&data);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\r\nc->lscan_lnum = data.lnum;\r\nlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\r\nif (IS_ERR(lprops))\r\nreturn lprops;\r\nubifs_assert(lprops->lnum == data.lnum);\r\nubifs_assert(lprops->free + lprops->dirty >= min_space);\r\nubifs_assert(lprops->dirty >= c->dead_wm ||\r\n(pick_free &&\r\nlprops->free + lprops->dirty == c->leb_size));\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert(!exclude_index || !(lprops->flags & LPROPS_INDEX));\r\nreturn lprops;\r\n}\r\nint ubifs_find_dirty_leb(struct ubifs_info *c, struct ubifs_lprops *ret_lp,\r\nint min_space, int pick_free)\r\n{\r\nint err = 0, sum, exclude_index = pick_free == 2 ? 1 : 0;\r\nconst struct ubifs_lprops *lp = NULL, *idx_lp = NULL;\r\nstruct ubifs_lpt_heap *heap, *idx_heap;\r\nubifs_get_lprops(c);\r\nif (pick_free) {\r\nint lebs, rsvd_idx_lebs = 0;\r\nspin_lock(&c->space_lock);\r\nlebs = c->lst.empty_lebs + c->idx_gc_cnt;\r\nlebs += c->freeable_cnt - c->lst.taken_empty_lebs;\r\nif (c->bi.min_idx_lebs >= c->lst.idx_lebs) {\r\nrsvd_idx_lebs = c->bi.min_idx_lebs - c->lst.idx_lebs;\r\nexclude_index = 1;\r\n}\r\nspin_unlock(&c->space_lock);\r\nif (rsvd_idx_lebs < lebs) {\r\nlp = ubifs_fast_find_empty(c);\r\nif (lp)\r\ngoto found;\r\nlp = ubifs_fast_find_freeable(c);\r\nif (lp)\r\ngoto found;\r\n} else\r\npick_free = 0;\r\n} else {\r\nspin_lock(&c->space_lock);\r\nexclude_index = (c->bi.min_idx_lebs >= c->lst.idx_lebs);\r\nspin_unlock(&c->space_lock);\r\n}\r\nheap = &c->lpt_heap[LPROPS_DIRTY - 1];\r\nidx_heap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\r\nif (idx_heap->cnt && !exclude_index) {\r\nidx_lp = idx_heap->arr[0];\r\nsum = idx_lp->free + idx_lp->dirty;\r\nif (sum < min_space || sum < c->half_leb_size)\r\nidx_lp = NULL;\r\n}\r\nif (heap->cnt) {\r\nlp = heap->arr[0];\r\nif (lp->dirty + lp->free < min_space)\r\nlp = NULL;\r\n}\r\nif (idx_lp && lp) {\r\nif (idx_lp->free + idx_lp->dirty >= lp->free + lp->dirty)\r\nlp = idx_lp;\r\n} else if (idx_lp && !lp)\r\nlp = idx_lp;\r\nif (lp) {\r\nubifs_assert(lp->free + lp->dirty >= c->dead_wm);\r\ngoto found;\r\n}\r\ndbg_find("scanning LPT for a dirty LEB");\r\nlp = scan_for_dirty(c, min_space, pick_free, exclude_index);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nubifs_assert(lp->dirty >= c->dead_wm ||\r\n(pick_free && lp->free + lp->dirty == c->leb_size));\r\nfound:\r\ndbg_find("found LEB %d, free %d, dirty %d, flags %#x",\r\nlp->lnum, lp->free, lp->dirty, lp->flags);\r\nlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\r\nlp->flags | LPROPS_TAKEN, 0);\r\nif (IS_ERR(lp)) {\r\nerr = PTR_ERR(lp);\r\ngoto out;\r\n}\r\nmemcpy(ret_lp, lp, sizeof(struct ubifs_lprops));\r\nout:\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}\r\nstatic int scan_for_free_cb(struct ubifs_info *c,\r\nconst struct ubifs_lprops *lprops, int in_tree,\r\nstruct scan_data *data)\r\n{\r\nint ret = LPT_SCAN_CONTINUE;\r\nif (lprops->flags & LPROPS_TAKEN)\r\nreturn LPT_SCAN_CONTINUE;\r\nif (!in_tree && valuable(c, lprops))\r\nret |= LPT_SCAN_ADD;\r\nif (lprops->flags & LPROPS_INDEX)\r\nreturn ret;\r\nif (lprops->free < data->min_space)\r\nreturn ret;\r\nif (!data->pick_free && lprops->free == c->leb_size)\r\nreturn ret;\r\nif (lprops->free + lprops->dirty == c->leb_size && lprops->dirty > 0)\r\nreturn ret;\r\ndata->lnum = lprops->lnum;\r\nreturn LPT_SCAN_ADD | LPT_SCAN_STOP;\r\n}\r\nstatic\r\nconst struct ubifs_lprops *do_find_free_space(struct ubifs_info *c,\r\nint min_space, int pick_free,\r\nint squeeze)\r\n{\r\nconst struct ubifs_lprops *lprops;\r\nstruct ubifs_lpt_heap *heap;\r\nstruct scan_data data;\r\nint err, i;\r\nif (squeeze) {\r\nlprops = ubifs_fast_find_free(c);\r\nif (lprops && lprops->free >= min_space)\r\nreturn lprops;\r\n}\r\nif (pick_free) {\r\nlprops = ubifs_fast_find_empty(c);\r\nif (lprops)\r\nreturn lprops;\r\n}\r\nif (!squeeze) {\r\nlprops = ubifs_fast_find_free(c);\r\nif (lprops && lprops->free >= min_space)\r\nreturn lprops;\r\n}\r\nheap = &c->lpt_heap[LPROPS_DIRTY - 1];\r\nfor (i = 0; i < heap->cnt; i++) {\r\nlprops = heap->arr[i];\r\nif (lprops->free >= min_space)\r\nreturn lprops;\r\n}\r\nlist_for_each_entry(lprops, &c->uncat_list, list) {\r\nif (lprops->flags & LPROPS_TAKEN)\r\ncontinue;\r\nif (lprops->flags & LPROPS_INDEX)\r\ncontinue;\r\nif (lprops->free >= min_space)\r\nreturn lprops;\r\n}\r\nif (c->pnodes_have >= c->pnode_cnt)\r\nreturn ERR_PTR(-ENOSPC);\r\ndata.min_space = min_space;\r\ndata.pick_free = pick_free;\r\ndata.lnum = -1;\r\nerr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\r\n(ubifs_lpt_scan_callback)scan_for_free_cb,\r\n&data);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\r\nc->lscan_lnum = data.lnum;\r\nlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\r\nif (IS_ERR(lprops))\r\nreturn lprops;\r\nubifs_assert(lprops->lnum == data.lnum);\r\nubifs_assert(lprops->free >= min_space);\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert(!(lprops->flags & LPROPS_INDEX));\r\nreturn lprops;\r\n}\r\nint ubifs_find_free_space(struct ubifs_info *c, int min_space, int *offs,\r\nint squeeze)\r\n{\r\nconst struct ubifs_lprops *lprops;\r\nint lebs, rsvd_idx_lebs, pick_free = 0, err, lnum, flags;\r\ndbg_find("min_space %d", min_space);\r\nubifs_get_lprops(c);\r\nspin_lock(&c->space_lock);\r\nif (c->bi.min_idx_lebs > c->lst.idx_lebs)\r\nrsvd_idx_lebs = c->bi.min_idx_lebs - c->lst.idx_lebs;\r\nelse\r\nrsvd_idx_lebs = 0;\r\nlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\r\nc->lst.taken_empty_lebs;\r\nif (rsvd_idx_lebs < lebs)\r\nif (c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\r\npick_free = 1;\r\nc->lst.taken_empty_lebs += 1;\r\n}\r\nspin_unlock(&c->space_lock);\r\nlprops = do_find_free_space(c, min_space, pick_free, squeeze);\r\nif (IS_ERR(lprops)) {\r\nerr = PTR_ERR(lprops);\r\ngoto out;\r\n}\r\nlnum = lprops->lnum;\r\nflags = lprops->flags | LPROPS_TAKEN;\r\nlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC, flags, 0);\r\nif (IS_ERR(lprops)) {\r\nerr = PTR_ERR(lprops);\r\ngoto out;\r\n}\r\nif (pick_free) {\r\nspin_lock(&c->space_lock);\r\nc->lst.taken_empty_lebs -= 1;\r\nspin_unlock(&c->space_lock);\r\n}\r\n*offs = c->leb_size - lprops->free;\r\nubifs_release_lprops(c);\r\nif (*offs == 0) {\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\nreturn err;\r\n}\r\ndbg_find("found LEB %d, free %d", lnum, c->leb_size - *offs);\r\nubifs_assert(*offs <= c->leb_size - min_space);\r\nreturn lnum;\r\nout:\r\nif (pick_free) {\r\nspin_lock(&c->space_lock);\r\nc->lst.taken_empty_lebs -= 1;\r\nspin_unlock(&c->space_lock);\r\n}\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}\r\nstatic int scan_for_idx_cb(struct ubifs_info *c,\r\nconst struct ubifs_lprops *lprops, int in_tree,\r\nstruct scan_data *data)\r\n{\r\nint ret = LPT_SCAN_CONTINUE;\r\nif (lprops->flags & LPROPS_TAKEN)\r\nreturn LPT_SCAN_CONTINUE;\r\nif (!in_tree && valuable(c, lprops))\r\nret |= LPT_SCAN_ADD;\r\nif (lprops->flags & LPROPS_INDEX)\r\nreturn ret;\r\nif (lprops->free + lprops->dirty != c->leb_size)\r\nreturn ret;\r\ndata->lnum = lprops->lnum;\r\nreturn LPT_SCAN_ADD | LPT_SCAN_STOP;\r\n}\r\nstatic const struct ubifs_lprops *scan_for_leb_for_idx(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nstruct scan_data data;\r\nint err;\r\ndata.lnum = -1;\r\nerr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\r\n(ubifs_lpt_scan_callback)scan_for_idx_cb,\r\n&data);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\r\nc->lscan_lnum = data.lnum;\r\nlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\r\nif (IS_ERR(lprops))\r\nreturn lprops;\r\nubifs_assert(lprops->lnum == data.lnum);\r\nubifs_assert(lprops->free + lprops->dirty == c->leb_size);\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert(!(lprops->flags & LPROPS_INDEX));\r\nreturn lprops;\r\n}\r\nint ubifs_find_free_leb_for_idx(struct ubifs_info *c)\r\n{\r\nconst struct ubifs_lprops *lprops;\r\nint lnum = -1, err, flags;\r\nubifs_get_lprops(c);\r\nlprops = ubifs_fast_find_empty(c);\r\nif (!lprops) {\r\nlprops = ubifs_fast_find_freeable(c);\r\nif (!lprops) {\r\nubifs_assert(c->freeable_cnt == 0);\r\nif (c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\r\nlprops = scan_for_leb_for_idx(c);\r\nif (IS_ERR(lprops)) {\r\nerr = PTR_ERR(lprops);\r\ngoto out;\r\n}\r\n}\r\n}\r\n}\r\nif (!lprops) {\r\nerr = -ENOSPC;\r\ngoto out;\r\n}\r\nlnum = lprops->lnum;\r\ndbg_find("found LEB %d, free %d, dirty %d, flags %#x",\r\nlnum, lprops->free, lprops->dirty, lprops->flags);\r\nflags = lprops->flags | LPROPS_TAKEN | LPROPS_INDEX;\r\nlprops = ubifs_change_lp(c, lprops, c->leb_size, 0, flags, 0);\r\nif (IS_ERR(lprops)) {\r\nerr = PTR_ERR(lprops);\r\ngoto out;\r\n}\r\nubifs_release_lprops(c);\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err) {\r\nubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\r\nLPROPS_TAKEN | LPROPS_INDEX, 0);\r\nreturn err;\r\n}\r\nreturn lnum;\r\nout:\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}\r\nstatic int cmp_dirty_idx(const struct ubifs_lprops **a,\r\nconst struct ubifs_lprops **b)\r\n{\r\nconst struct ubifs_lprops *lpa = *a;\r\nconst struct ubifs_lprops *lpb = *b;\r\nreturn lpa->dirty + lpa->free - lpb->dirty - lpb->free;\r\n}\r\nstatic void swap_dirty_idx(struct ubifs_lprops **a, struct ubifs_lprops **b,\r\nint size)\r\n{\r\nstruct ubifs_lprops *t = *a;\r\n*a = *b;\r\n*b = t;\r\n}\r\nint ubifs_save_dirty_idx_lnums(struct ubifs_info *c)\r\n{\r\nint i;\r\nubifs_get_lprops(c);\r\nc->dirty_idx.cnt = c->lpt_heap[LPROPS_DIRTY_IDX - 1].cnt;\r\nmemcpy(c->dirty_idx.arr, c->lpt_heap[LPROPS_DIRTY_IDX - 1].arr,\r\nsizeof(void *) * c->dirty_idx.cnt);\r\nsort(c->dirty_idx.arr, c->dirty_idx.cnt, sizeof(void *),\r\n(int (*)(const void *, const void *))cmp_dirty_idx,\r\n(void (*)(void *, void *, int))swap_dirty_idx);\r\ndbg_find("found %d dirty index LEBs", c->dirty_idx.cnt);\r\nif (c->dirty_idx.cnt)\r\ndbg_find("dirtiest index LEB is %d with dirty %d and free %d",\r\nc->dirty_idx.arr[c->dirty_idx.cnt - 1]->lnum,\r\nc->dirty_idx.arr[c->dirty_idx.cnt - 1]->dirty,\r\nc->dirty_idx.arr[c->dirty_idx.cnt - 1]->free);\r\nfor (i = 0; i < c->dirty_idx.cnt; i++)\r\nc->dirty_idx.arr[i] = (void *)(size_t)c->dirty_idx.arr[i]->lnum;\r\nubifs_release_lprops(c);\r\nreturn 0;\r\n}\r\nstatic int scan_dirty_idx_cb(struct ubifs_info *c,\r\nconst struct ubifs_lprops *lprops, int in_tree,\r\nstruct scan_data *data)\r\n{\r\nint ret = LPT_SCAN_CONTINUE;\r\nif (lprops->flags & LPROPS_TAKEN)\r\nreturn LPT_SCAN_CONTINUE;\r\nif (!in_tree && valuable(c, lprops))\r\nret |= LPT_SCAN_ADD;\r\nif (!(lprops->flags & LPROPS_INDEX))\r\nreturn ret;\r\nif (lprops->free + lprops->dirty < c->min_idx_node_sz)\r\nreturn ret;\r\ndata->lnum = lprops->lnum;\r\nreturn LPT_SCAN_ADD | LPT_SCAN_STOP;\r\n}\r\nstatic int find_dirty_idx_leb(struct ubifs_info *c)\r\n{\r\nconst struct ubifs_lprops *lprops;\r\nstruct ubifs_lpt_heap *heap;\r\nstruct scan_data data;\r\nint err, i, ret;\r\ndata.lnum = -1;\r\nheap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\r\nfor (i = 0; i < heap->cnt; i++) {\r\nlprops = heap->arr[i];\r\nret = scan_dirty_idx_cb(c, lprops, 1, &data);\r\nif (ret & LPT_SCAN_STOP)\r\ngoto found;\r\n}\r\nlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\r\nret = scan_dirty_idx_cb(c, lprops, 1, &data);\r\nif (ret & LPT_SCAN_STOP)\r\ngoto found;\r\n}\r\nlist_for_each_entry(lprops, &c->uncat_list, list) {\r\nret = scan_dirty_idx_cb(c, lprops, 1, &data);\r\nif (ret & LPT_SCAN_STOP)\r\ngoto found;\r\n}\r\nif (c->pnodes_have >= c->pnode_cnt)\r\nreturn -ENOSPC;\r\nerr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\r\n(ubifs_lpt_scan_callback)scan_dirty_idx_cb,\r\n&data);\r\nif (err)\r\nreturn err;\r\nfound:\r\nubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\r\nc->lscan_lnum = data.lnum;\r\nlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\r\nif (IS_ERR(lprops))\r\nreturn PTR_ERR(lprops);\r\nubifs_assert(lprops->lnum == data.lnum);\r\nubifs_assert(lprops->free + lprops->dirty >= c->min_idx_node_sz);\r\nubifs_assert(!(lprops->flags & LPROPS_TAKEN));\r\nubifs_assert((lprops->flags & LPROPS_INDEX));\r\ndbg_find("found dirty LEB %d, free %d, dirty %d, flags %#x",\r\nlprops->lnum, lprops->free, lprops->dirty, lprops->flags);\r\nlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC,\r\nlprops->flags | LPROPS_TAKEN, 0);\r\nif (IS_ERR(lprops))\r\nreturn PTR_ERR(lprops);\r\nreturn lprops->lnum;\r\n}\r\nstatic int get_idx_gc_leb(struct ubifs_info *c)\r\n{\r\nconst struct ubifs_lprops *lp;\r\nint err, lnum;\r\nerr = ubifs_get_idx_gc_leb(c);\r\nif (err < 0)\r\nreturn err;\r\nlnum = err;\r\nlp = ubifs_lpt_lookup_dirty(c, lnum);\r\nif (IS_ERR(lp))\r\nreturn PTR_ERR(lp);\r\nlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\r\nlp->flags | LPROPS_INDEX, -1);\r\nif (IS_ERR(lp))\r\nreturn PTR_ERR(lp);\r\ndbg_find("LEB %d, dirty %d and free %d flags %#x",\r\nlp->lnum, lp->dirty, lp->free, lp->flags);\r\nreturn lnum;\r\n}\r\nstatic int find_dirtiest_idx_leb(struct ubifs_info *c)\r\n{\r\nconst struct ubifs_lprops *lp;\r\nint lnum;\r\nwhile (1) {\r\nif (!c->dirty_idx.cnt)\r\nreturn -ENOSPC;\r\nlnum = (size_t)c->dirty_idx.arr[--c->dirty_idx.cnt];\r\nlp = ubifs_lpt_lookup(c, lnum);\r\nif (IS_ERR(lp))\r\nreturn PTR_ERR(lp);\r\nif ((lp->flags & LPROPS_TAKEN) || !(lp->flags & LPROPS_INDEX))\r\ncontinue;\r\nlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\r\nlp->flags | LPROPS_TAKEN, 0);\r\nif (IS_ERR(lp))\r\nreturn PTR_ERR(lp);\r\nbreak;\r\n}\r\ndbg_find("LEB %d, dirty %d and free %d flags %#x", lp->lnum, lp->dirty,\r\nlp->free, lp->flags);\r\nubifs_assert(lp->flags & LPROPS_TAKEN);\r\nubifs_assert(lp->flags & LPROPS_INDEX);\r\nreturn lnum;\r\n}\r\nint ubifs_find_dirty_idx_leb(struct ubifs_info *c)\r\n{\r\nint err;\r\nubifs_get_lprops(c);\r\nerr = find_dirtiest_idx_leb(c);\r\nif (err == -ENOSPC)\r\nerr = find_dirty_idx_leb(c);\r\nif (err == -ENOSPC)\r\nerr = get_idx_gc_leb(c);\r\nubifs_release_lprops(c);\r\nreturn err;\r\n}
