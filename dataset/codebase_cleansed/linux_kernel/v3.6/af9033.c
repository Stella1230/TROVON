static int af9033_wr_regs(struct af9033_state *state, u32 reg, const u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[3 + len];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = state->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nbuf[0] = (reg >> 16) & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nbuf[2] = (reg >> 0) & 0xff;\r\nmemcpy(&buf[3], val, len);\r\nret = i2c_transfer(state->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\nprintk(KERN_WARNING "%s: i2c wr failed=%d reg=%06x len=%d\n",\r\n__func__, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9033_rd_regs(struct af9033_state *state, u32 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[3] = { (reg >> 16) & 0xff, (reg >> 8) & 0xff,\r\n(reg >> 0) & 0xff };\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = state->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf\r\n}, {\r\n.addr = state->cfg.i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val\r\n}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\nprintk(KERN_WARNING "%s: i2c rd failed=%d reg=%06x len=%d\n",\r\n__func__, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9033_wr_reg(struct af9033_state *state, u32 reg, u8 val)\r\n{\r\nreturn af9033_wr_regs(state, reg, &val, 1);\r\n}\r\nstatic int af9033_rd_reg(struct af9033_state *state, u32 reg, u8 *val)\r\n{\r\nreturn af9033_rd_regs(state, reg, val, 1);\r\n}\r\nstatic int af9033_wr_reg_mask(struct af9033_state *state, u32 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = af9033_rd_regs(state, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn af9033_wr_regs(state, reg, &val, 1);\r\n}\r\nstatic int af9033_rd_reg_mask(struct af9033_state *state, u32 reg, u8 *val,\r\nu8 mask)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\nret = af9033_rd_regs(state, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\ntmp &= mask;\r\nfor (i = 0; i < 8; i++) {\r\nif ((mask >> i) & 0x01)\r\nbreak;\r\n}\r\n*val = tmp >> i;\r\nreturn 0;\r\n}\r\nstatic u32 af9033_div(u32 a, u32 b, u32 x)\r\n{\r\nu32 r = 0, c = 0, i;\r\npr_debug("%s: a=%d b=%d x=%d\n", __func__, a, b, x);\r\nif (a > b) {\r\nc = a / b;\r\na = a - c * b;\r\n}\r\nfor (i = 0; i < x; i++) {\r\nif (a >= b) {\r\nr += 1;\r\na -= b;\r\n}\r\na <<= 1;\r\nr <<= 1;\r\n}\r\nr = (c << (u32)x) + r;\r\npr_debug("%s: a=%d b=%d x=%d r=%d r=%x\n", __func__, a, b, x, r, r);\r\nreturn r;\r\n}\r\nstatic void af9033_release(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstatic int af9033_init(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret, i, len;\r\nconst struct reg_val *init;\r\nu8 buf[4];\r\nu32 adc_cw, clock_cw;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x80fb24, 0x00, 0x08 },\r\n{ 0x80004c, 0x00, 0xff },\r\n{ 0x00f641, state->cfg.tuner, 0xff },\r\n{ 0x80f5ca, 0x01, 0x01 },\r\n{ 0x80f715, 0x01, 0x01 },\r\n{ 0x00f41f, 0x04, 0x04 },\r\n{ 0x00f41a, 0x01, 0x01 },\r\n{ 0x80f731, 0x00, 0x01 },\r\n{ 0x00d91e, 0x00, 0x01 },\r\n{ 0x00d919, 0x00, 0x01 },\r\n{ 0x80f732, 0x00, 0x01 },\r\n{ 0x00d91f, 0x00, 0x01 },\r\n{ 0x00d91a, 0x00, 0x01 },\r\n{ 0x80f730, 0x00, 0x01 },\r\n{ 0x80f778, 0x00, 0xff },\r\n{ 0x80f73c, 0x01, 0x01 },\r\n{ 0x80f776, 0x00, 0x01 },\r\n{ 0x00d8fd, 0x01, 0xff },\r\n{ 0x00d830, 0x01, 0xff },\r\n{ 0x00d831, 0x00, 0xff },\r\n{ 0x00d832, 0x00, 0xff },\r\n{ 0x80f985, state->ts_mode_serial, 0x01 },\r\n{ 0x80f986, state->ts_mode_parallel, 0x01 },\r\n{ 0x00d827, 0x00, 0xff },\r\n{ 0x00d829, 0x00, 0xff },\r\n};\r\nclock_cw = af9033_div(state->cfg.clock, 1000000ul, 19ul);\r\nbuf[0] = (clock_cw >> 0) & 0xff;\r\nbuf[1] = (clock_cw >> 8) & 0xff;\r\nbuf[2] = (clock_cw >> 16) & 0xff;\r\nbuf[3] = (clock_cw >> 24) & 0xff;\r\npr_debug("%s: clock=%d clock_cw=%08x\n", __func__, state->cfg.clock,\r\nclock_cw);\r\nret = af9033_wr_regs(state, 0x800025, buf, 4);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\r\nif (clock_adc_lut[i].clock == state->cfg.clock)\r\nbreak;\r\n}\r\nadc_cw = af9033_div(clock_adc_lut[i].adc, 1000000ul, 19ul);\r\nbuf[0] = (adc_cw >> 0) & 0xff;\r\nbuf[1] = (adc_cw >> 8) & 0xff;\r\nbuf[2] = (adc_cw >> 16) & 0xff;\r\npr_debug("%s: adc=%d adc_cw=%06x\n", __func__, clock_adc_lut[i].adc,\r\nadc_cw);\r\nret = af9033_wr_regs(state, 0x80f1cd, buf, 3);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = af9033_wr_reg_mask(state, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (state->cfg.ts_mode == AF9033_TS_MODE_USB) {\r\nret = af9033_wr_reg_mask(state, 0x80f9a5, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(state, 0x80f9b5, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n} else {\r\nret = af9033_wr_reg_mask(state, 0x80f990, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(state, 0x80f9b5, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\npr_debug("%s: load ofsm settings\n", __func__);\r\nlen = ARRAY_SIZE(ofsm_init);\r\ninit = ofsm_init;\r\nfor (i = 0; i < len; i++) {\r\nret = af9033_wr_reg(state, init[i].reg, init[i].val);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\npr_debug("%s: load tuner specific settings\n",\r\n__func__);\r\nswitch (state->cfg.tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\nlen = ARRAY_SIZE(tuner_init_tua9001);\r\ninit = tuner_init_tua9001;\r\nbreak;\r\ncase AF9033_TUNER_FC0011:\r\nlen = ARRAY_SIZE(tuner_init_fc0011);\r\ninit = tuner_init_fc0011;\r\nbreak;\r\ncase AF9033_TUNER_MXL5007T:\r\nlen = ARRAY_SIZE(tuner_init_mxl5007t);\r\ninit = tuner_init_mxl5007t;\r\nbreak;\r\ncase AF9033_TUNER_TDA18218:\r\nlen = ARRAY_SIZE(tuner_init_tda18218);\r\ninit = tuner_init_tda18218;\r\nbreak;\r\ndefault:\r\npr_debug("%s: unsupported tuner ID=%d\n", __func__,\r\nstate->cfg.tuner);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nret = af9033_wr_reg(state, init[i].reg, init[i].val);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nstate->bandwidth_hz = 0;\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret, i;\r\nu8 tmp;\r\nret = af9033_wr_reg(state, 0x80004c, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(state, 0x800000, 0);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 100, tmp = 1; i && tmp; i--) {\r\nret = af9033_rd_reg(state, 0x80004c, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(200, 10000);\r\n}\r\npr_debug("%s: loop=%d\n", __func__, i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nret = af9033_wr_reg_mask(state, 0x80fb24, 0x08, 0x08);\r\nif (ret < 0)\r\ngoto err;\r\nif (state->cfg.ts_mode == AF9033_TS_MODE_SERIAL) {\r\nret = af9033_wr_reg_mask(state, 0x00d917, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(state, 0x00d916, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 800;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int af9033_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, spec_inv;\r\nu8 tmp, buf[3], bandwidth_reg_val;\r\nu32 if_frequency, freq_cw, adc_freq;\r\npr_debug("%s: frequency=%d bandwidth_hz=%d\n", __func__, c->frequency,\r\nc->bandwidth_hz);\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nbandwidth_reg_val = 0x00;\r\nbreak;\r\ncase 7000000:\r\nbandwidth_reg_val = 0x01;\r\nbreak;\r\ncase 8000000:\r\nbandwidth_reg_val = 0x02;\r\nbreak;\r\ndefault:\r\npr_debug("%s: invalid bandwidth_hz\n", __func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (c->bandwidth_hz != state->bandwidth_hz) {\r\nfor (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {\r\nif (coeff_lut[i].clock == state->cfg.clock &&\r\ncoeff_lut[i].bandwidth_hz == c->bandwidth_hz) {\r\nbreak;\r\n}\r\n}\r\nret = af9033_wr_regs(state, 0x800001,\r\ncoeff_lut[i].val, sizeof(coeff_lut[i].val));\r\n}\r\nif (c->bandwidth_hz != state->bandwidth_hz) {\r\nspec_inv = state->cfg.spec_inv ? -1 : 1;\r\nfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\r\nif (clock_adc_lut[i].clock == state->cfg.clock)\r\nbreak;\r\n}\r\nadc_freq = clock_adc_lut[i].adc;\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nfe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nelse\r\nif_frequency = 0;\r\nwhile (if_frequency > (adc_freq / 2))\r\nif_frequency -= adc_freq;\r\nif (if_frequency >= 0)\r\nspec_inv *= -1;\r\nelse\r\nif_frequency *= -1;\r\nfreq_cw = af9033_div(if_frequency, adc_freq, 23ul);\r\nif (spec_inv == -1)\r\nfreq_cw *= -1;\r\nret = af9033_rd_reg(state, 0x800045, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp == 1)\r\nfreq_cw /= 2;\r\nbuf[0] = (freq_cw >> 0) & 0xff;\r\nbuf[1] = (freq_cw >> 8) & 0xff;\r\nbuf[2] = (freq_cw >> 16) & 0x7f;\r\nret = af9033_wr_regs(state, 0x800029, buf, 3);\r\nif (ret < 0)\r\ngoto err;\r\nstate->bandwidth_hz = c->bandwidth_hz;\r\n}\r\nret = af9033_wr_reg_mask(state, 0x80f904, bandwidth_reg_val, 0x03);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(state, 0x800040, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(state, 0x800047, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(state, 0x80f999, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nif (c->frequency <= 230000000)\r\ntmp = 0x00;\r\nelse\r\ntmp = 0x01;\r\nret = af9033_wr_reg(state, 0x80004b, tmp);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(state, 0x800000, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu8 buf[8];\r\npr_debug("%s\n", __func__);\r\nret = af9033_rd_regs(state, 0x80f900, buf, sizeof(buf));\r\nif (ret < 0)\r\ngoto err;\r\nswitch ((buf[0] >> 0) & 3) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[3] >> 0) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[4] >> 0) & 3) {\r\ncase 0:\r\nc->bandwidth_hz = 6000000;\r\nbreak;\r\ncase 1:\r\nc->bandwidth_hz = 7000000;\r\nbreak;\r\ncase 2:\r\nc->bandwidth_hz = 8000000;\r\nbreak;\r\n}\r\nswitch ((buf[6] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\ncase 5:\r\nc->code_rate_HP = FEC_NONE;\r\nbreak;\r\n}\r\nswitch ((buf[7] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\ncase 5:\r\nc->code_rate_LP = FEC_NONE;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp;\r\n*status = 0;\r\nret = af9033_rd_reg(state, 0x800047, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp == 0x01)\r\n*status |= FE_HAS_SIGNAL;\r\nif (tmp != 0x02) {\r\nret = af9033_rd_reg_mask(state, 0x80f5a9, &tmp, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\nret = af9033_rd_reg_mask(state, 0x80f999, &tmp, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret, i, len;\r\nu8 buf[3], tmp;\r\nu32 snr_val;\r\nconst struct val_snr *uninitialized_var(snr_lut);\r\nret = af9033_rd_regs(state, 0x80002c, buf, 3);\r\nif (ret < 0)\r\ngoto err;\r\nsnr_val = (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nret = af9033_rd_reg(state, 0x80f903, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nswitch ((tmp >> 0) & 3) {\r\ncase 0:\r\nlen = ARRAY_SIZE(qpsk_snr_lut);\r\nsnr_lut = qpsk_snr_lut;\r\nbreak;\r\ncase 1:\r\nlen = ARRAY_SIZE(qam16_snr_lut);\r\nsnr_lut = qam16_snr_lut;\r\nbreak;\r\ncase 2:\r\nlen = ARRAY_SIZE(qam64_snr_lut);\r\nsnr_lut = qam64_snr_lut;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nfor (i = 0; i < len; i++) {\r\ntmp = snr_lut[i].snr;\r\nif (snr_val < snr_lut[i].val)\r\nbreak;\r\n}\r\n*snr = tmp * 10;\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 strength2;\r\nret = af9033_rd_reg(state, 0x800048, &strength2);\r\nif (ret < 0)\r\ngoto err;\r\n*strength = strength2 * 0xffff / 100;\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_update_ch_stat(struct af9033_state *state)\r\n{\r\nint ret = 0;\r\nu32 err_cnt, bit_cnt;\r\nu16 abort_cnt;\r\nu8 buf[7];\r\nif (time_after(jiffies, state->last_stat_check + msecs_to_jiffies(500))) {\r\nret = af9033_rd_regs(state, 0x800032, buf, sizeof(buf));\r\nif (ret < 0)\r\ngoto err;\r\nabort_cnt = (buf[1] << 8) + buf[0];\r\nerr_cnt = (buf[4] << 16) + (buf[3] << 8) + buf[2];\r\nbit_cnt = (buf[6] << 8) + buf[5];\r\nif (bit_cnt < abort_cnt) {\r\nabort_cnt = 1000;\r\nstate->ber = 0xffffffff;\r\n} else {\r\nbit_cnt -= (u32)abort_cnt;\r\nif (bit_cnt == 0) {\r\nstate->ber = 0xffffffff;\r\n} else {\r\nerr_cnt -= (u32)abort_cnt * 8 * 8;\r\nbit_cnt *= 8 * 8;\r\nstate->ber = err_cnt * (0xffffffff / bit_cnt);\r\n}\r\n}\r\nstate->ucb += abort_cnt;\r\nstate->last_stat_check = jiffies;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = af9033_update_ch_stat(state);\r\nif (ret < 0)\r\nreturn ret;\r\n*ber = state->ber;\r\nreturn 0;\r\n}\r\nstatic int af9033_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = af9033_update_ch_stat(state);\r\nif (ret < 0)\r\nreturn ret;\r\n*ucblocks = state->ucb;\r\nreturn 0;\r\n}\r\nstatic int af9033_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct af9033_state *state = fe->demodulator_priv;\r\nint ret;\r\npr_debug("%s: enable=%d\n", __func__, enable);\r\nret = af9033_wr_reg_mask(state, 0x00fa04, enable, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *af9033_attach(const struct af9033_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nint ret;\r\nstruct af9033_state *state;\r\nu8 buf[8];\r\npr_debug("%s:\n", __func__);\r\nstate = kzalloc(sizeof(struct af9033_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto err;\r\nstate->i2c = i2c;\r\nmemcpy(&state->cfg, config, sizeof(struct af9033_config));\r\nif (state->cfg.clock != 12000000) {\r\nprintk(KERN_INFO "af9033: unsupported clock=%d, only " \\r\n"12000000 Hz is supported currently\n",\r\nstate->cfg.clock);\r\ngoto err;\r\n}\r\nret = af9033_rd_regs(state, 0x0083e9, &buf[0], 4);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_rd_regs(state, 0x804191, &buf[4], 4);\r\nif (ret < 0)\r\ngoto err;\r\nprintk(KERN_INFO "af9033: firmware version: LINK=%d.%d.%d.%d " \\r\n"OFDM=%d.%d.%d.%d\n", buf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7]);\r\nswitch (state->cfg.ts_mode) {\r\ncase AF9033_TS_MODE_PARALLEL:\r\nstate->ts_mode_parallel = true;\r\nbreak;\r\ncase AF9033_TS_MODE_SERIAL:\r\nstate->ts_mode_serial = true;\r\nbreak;\r\ncase AF9033_TS_MODE_USB:\r\ndefault:\r\nbreak;\r\n}\r\nmemcpy(&state->fe.ops, &af9033_ops, sizeof(struct dvb_frontend_ops));\r\nstate->fe.demodulator_priv = state;\r\nreturn &state->fe;\r\nerr:\r\nkfree(state);\r\nreturn NULL;\r\n}
