static inline u32 addr_fold(void *addr)\r\n{\r\nunsigned long a = (unsigned long)addr;\r\nreturn (a & 0xFFFFFFFF) ^ (BITS_PER_LONG > 32 ? a >> 32 : 0);\r\n}\r\nstatic u32 flow_get_src(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nif (flow->src)\r\nreturn ntohl(flow->src);\r\nreturn addr_fold(skb->sk);\r\n}\r\nstatic u32 flow_get_dst(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nif (flow->dst)\r\nreturn ntohl(flow->dst);\r\nreturn addr_fold(skb_dst(skb)) ^ (__force u16)skb->protocol;\r\n}\r\nstatic u32 flow_get_proto(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nreturn flow->ip_proto;\r\n}\r\nstatic u32 flow_get_proto_src(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nif (flow->ports)\r\nreturn ntohs(flow->port16[0]);\r\nreturn addr_fold(skb->sk);\r\n}\r\nstatic u32 flow_get_proto_dst(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nif (flow->ports)\r\nreturn ntohs(flow->port16[1]);\r\nreturn addr_fold(skb_dst(skb)) ^ (__force u16)skb->protocol;\r\n}\r\nstatic u32 flow_get_iif(const struct sk_buff *skb)\r\n{\r\nreturn skb->skb_iif;\r\n}\r\nstatic u32 flow_get_priority(const struct sk_buff *skb)\r\n{\r\nreturn skb->priority;\r\n}\r\nstatic u32 flow_get_mark(const struct sk_buff *skb)\r\n{\r\nreturn skb->mark;\r\n}\r\nstatic u32 flow_get_nfct(const struct sk_buff *skb)\r\n{\r\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\r\nreturn addr_fold(skb->nfct);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic u32 flow_get_nfct_src(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nreturn ntohl(CTTUPLE(skb, src.u3.ip));\r\ncase htons(ETH_P_IPV6):\r\nreturn ntohl(CTTUPLE(skb, src.u3.ip6[3]));\r\n}\r\nfallback:\r\nreturn flow_get_src(skb, flow);\r\n}\r\nstatic u32 flow_get_nfct_dst(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nreturn ntohl(CTTUPLE(skb, dst.u3.ip));\r\ncase htons(ETH_P_IPV6):\r\nreturn ntohl(CTTUPLE(skb, dst.u3.ip6[3]));\r\n}\r\nfallback:\r\nreturn flow_get_dst(skb, flow);\r\n}\r\nstatic u32 flow_get_nfct_proto_src(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nreturn ntohs(CTTUPLE(skb, src.u.all));\r\nfallback:\r\nreturn flow_get_proto_src(skb, flow);\r\n}\r\nstatic u32 flow_get_nfct_proto_dst(const struct sk_buff *skb, const struct flow_keys *flow)\r\n{\r\nreturn ntohs(CTTUPLE(skb, dst.u.all));\r\nfallback:\r\nreturn flow_get_proto_dst(skb, flow);\r\n}\r\nstatic u32 flow_get_rtclassid(const struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_IP_ROUTE_CLASSID\r\nif (skb_dst(skb))\r\nreturn skb_dst(skb)->tclassid;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic u32 flow_get_skuid(const struct sk_buff *skb)\r\n{\r\nif (skb->sk && skb->sk->sk_socket && skb->sk->sk_socket->file)\r\nreturn skb->sk->sk_socket->file->f_cred->fsuid;\r\nreturn 0;\r\n}\r\nstatic u32 flow_get_skgid(const struct sk_buff *skb)\r\n{\r\nif (skb->sk && skb->sk->sk_socket && skb->sk->sk_socket->file)\r\nreturn skb->sk->sk_socket->file->f_cred->fsgid;\r\nreturn 0;\r\n}\r\nstatic u32 flow_get_vlan_tag(const struct sk_buff *skb)\r\n{\r\nu16 uninitialized_var(tag);\r\nif (vlan_get_tag(skb, &tag) < 0)\r\nreturn 0;\r\nreturn tag & VLAN_VID_MASK;\r\n}\r\nstatic u32 flow_get_rxhash(struct sk_buff *skb)\r\n{\r\nreturn skb_get_rxhash(skb);\r\n}\r\nstatic u32 flow_key_get(struct sk_buff *skb, int key, struct flow_keys *flow)\r\n{\r\nswitch (key) {\r\ncase FLOW_KEY_SRC:\r\nreturn flow_get_src(skb, flow);\r\ncase FLOW_KEY_DST:\r\nreturn flow_get_dst(skb, flow);\r\ncase FLOW_KEY_PROTO:\r\nreturn flow_get_proto(skb, flow);\r\ncase FLOW_KEY_PROTO_SRC:\r\nreturn flow_get_proto_src(skb, flow);\r\ncase FLOW_KEY_PROTO_DST:\r\nreturn flow_get_proto_dst(skb, flow);\r\ncase FLOW_KEY_IIF:\r\nreturn flow_get_iif(skb);\r\ncase FLOW_KEY_PRIORITY:\r\nreturn flow_get_priority(skb);\r\ncase FLOW_KEY_MARK:\r\nreturn flow_get_mark(skb);\r\ncase FLOW_KEY_NFCT:\r\nreturn flow_get_nfct(skb);\r\ncase FLOW_KEY_NFCT_SRC:\r\nreturn flow_get_nfct_src(skb, flow);\r\ncase FLOW_KEY_NFCT_DST:\r\nreturn flow_get_nfct_dst(skb, flow);\r\ncase FLOW_KEY_NFCT_PROTO_SRC:\r\nreturn flow_get_nfct_proto_src(skb, flow);\r\ncase FLOW_KEY_NFCT_PROTO_DST:\r\nreturn flow_get_nfct_proto_dst(skb, flow);\r\ncase FLOW_KEY_RTCLASSID:\r\nreturn flow_get_rtclassid(skb);\r\ncase FLOW_KEY_SKUID:\r\nreturn flow_get_skuid(skb);\r\ncase FLOW_KEY_SKGID:\r\nreturn flow_get_skgid(skb);\r\ncase FLOW_KEY_VLAN_TAG:\r\nreturn flow_get_vlan_tag(skb);\r\ncase FLOW_KEY_RXHASH:\r\nreturn flow_get_rxhash(skb);\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\n}\r\nstatic int flow_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct flow_head *head = tp->root;\r\nstruct flow_filter *f;\r\nu32 keymask;\r\nu32 classid;\r\nunsigned int n, key;\r\nint r;\r\nlist_for_each_entry(f, &head->filters, list) {\r\nu32 keys[FLOW_KEY_MAX + 1];\r\nstruct flow_keys flow_keys;\r\nif (!tcf_em_tree_match(skb, &f->ematches, NULL))\r\ncontinue;\r\nkeymask = f->keymask;\r\nif (keymask & FLOW_KEYS_NEEDED)\r\nskb_flow_dissect(skb, &flow_keys);\r\nfor (n = 0; n < f->nkeys; n++) {\r\nkey = ffs(keymask) - 1;\r\nkeymask &= ~(1 << key);\r\nkeys[n] = flow_key_get(skb, key, &flow_keys);\r\n}\r\nif (f->mode == FLOW_MODE_HASH)\r\nclassid = jhash2(keys, f->nkeys, f->hashrnd);\r\nelse {\r\nclassid = keys[0];\r\nclassid = (classid & f->mask) ^ f->xor;\r\nclassid = (classid >> f->rshift) + f->addend;\r\n}\r\nif (f->divisor)\r\nclassid %= f->divisor;\r\nres->class = 0;\r\nres->classid = TC_H_MAKE(f->baseclass, f->baseclass + classid);\r\nr = tcf_exts_exec(skb, &f->exts, res);\r\nif (r < 0)\r\ncontinue;\r\nreturn r;\r\n}\r\nreturn -1;\r\n}\r\nstatic void flow_perturbation(unsigned long arg)\r\n{\r\nstruct flow_filter *f = (struct flow_filter *)arg;\r\nget_random_bytes(&f->hashrnd, 4);\r\nif (f->perturb_period)\r\nmod_timer(&f->perturb_timer, jiffies + f->perturb_period);\r\n}\r\nstatic int flow_change(struct tcf_proto *tp, unsigned long base,\r\nu32 handle, struct nlattr **tca,\r\nunsigned long *arg)\r\n{\r\nstruct flow_head *head = tp->root;\r\nstruct flow_filter *f;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_FLOW_MAX + 1];\r\nstruct tcf_exts e;\r\nstruct tcf_ematch_tree t;\r\nunsigned int nkeys = 0;\r\nunsigned int perturb_period = 0;\r\nu32 baseclass = 0;\r\nu32 keymask = 0;\r\nu32 mode;\r\nint err;\r\nif (opt == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_FLOW_MAX, opt, flow_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_FLOW_BASECLASS]) {\r\nbaseclass = nla_get_u32(tb[TCA_FLOW_BASECLASS]);\r\nif (TC_H_MIN(baseclass) == 0)\r\nreturn -EINVAL;\r\n}\r\nif (tb[TCA_FLOW_KEYS]) {\r\nkeymask = nla_get_u32(tb[TCA_FLOW_KEYS]);\r\nnkeys = hweight32(keymask);\r\nif (nkeys == 0)\r\nreturn -EINVAL;\r\nif (fls(keymask) - 1 > FLOW_KEY_MAX)\r\nreturn -EOPNOTSUPP;\r\n}\r\nerr = tcf_exts_validate(tp, tb, tca[TCA_RATE], &e, &flow_ext_map);\r\nif (err < 0)\r\nreturn err;\r\nerr = tcf_em_tree_validate(tp, tb[TCA_FLOW_EMATCHES], &t);\r\nif (err < 0)\r\ngoto err1;\r\nf = (struct flow_filter *)*arg;\r\nif (f != NULL) {\r\nerr = -EINVAL;\r\nif (f->handle != handle && handle)\r\ngoto err2;\r\nmode = f->mode;\r\nif (tb[TCA_FLOW_MODE])\r\nmode = nla_get_u32(tb[TCA_FLOW_MODE]);\r\nif (mode != FLOW_MODE_HASH && nkeys > 1)\r\ngoto err2;\r\nif (mode == FLOW_MODE_HASH)\r\nperturb_period = f->perturb_period;\r\nif (tb[TCA_FLOW_PERTURB]) {\r\nif (mode != FLOW_MODE_HASH)\r\ngoto err2;\r\nperturb_period = nla_get_u32(tb[TCA_FLOW_PERTURB]) * HZ;\r\n}\r\n} else {\r\nerr = -EINVAL;\r\nif (!handle)\r\ngoto err2;\r\nif (!tb[TCA_FLOW_KEYS])\r\ngoto err2;\r\nmode = FLOW_MODE_MAP;\r\nif (tb[TCA_FLOW_MODE])\r\nmode = nla_get_u32(tb[TCA_FLOW_MODE]);\r\nif (mode != FLOW_MODE_HASH && nkeys > 1)\r\ngoto err2;\r\nif (tb[TCA_FLOW_PERTURB]) {\r\nif (mode != FLOW_MODE_HASH)\r\ngoto err2;\r\nperturb_period = nla_get_u32(tb[TCA_FLOW_PERTURB]) * HZ;\r\n}\r\nif (TC_H_MAJ(baseclass) == 0)\r\nbaseclass = TC_H_MAKE(tp->q->handle, baseclass);\r\nif (TC_H_MIN(baseclass) == 0)\r\nbaseclass = TC_H_MAKE(baseclass, 1);\r\nerr = -ENOBUFS;\r\nf = kzalloc(sizeof(*f), GFP_KERNEL);\r\nif (f == NULL)\r\ngoto err2;\r\nf->handle = handle;\r\nf->mask = ~0U;\r\nget_random_bytes(&f->hashrnd, 4);\r\nf->perturb_timer.function = flow_perturbation;\r\nf->perturb_timer.data = (unsigned long)f;\r\ninit_timer_deferrable(&f->perturb_timer);\r\n}\r\ntcf_exts_change(tp, &f->exts, &e);\r\ntcf_em_tree_change(tp, &f->ematches, &t);\r\ntcf_tree_lock(tp);\r\nif (tb[TCA_FLOW_KEYS]) {\r\nf->keymask = keymask;\r\nf->nkeys = nkeys;\r\n}\r\nf->mode = mode;\r\nif (tb[TCA_FLOW_MASK])\r\nf->mask = nla_get_u32(tb[TCA_FLOW_MASK]);\r\nif (tb[TCA_FLOW_XOR])\r\nf->xor = nla_get_u32(tb[TCA_FLOW_XOR]);\r\nif (tb[TCA_FLOW_RSHIFT])\r\nf->rshift = nla_get_u32(tb[TCA_FLOW_RSHIFT]);\r\nif (tb[TCA_FLOW_ADDEND])\r\nf->addend = nla_get_u32(tb[TCA_FLOW_ADDEND]);\r\nif (tb[TCA_FLOW_DIVISOR])\r\nf->divisor = nla_get_u32(tb[TCA_FLOW_DIVISOR]);\r\nif (baseclass)\r\nf->baseclass = baseclass;\r\nf->perturb_period = perturb_period;\r\ndel_timer(&f->perturb_timer);\r\nif (perturb_period)\r\nmod_timer(&f->perturb_timer, jiffies + perturb_period);\r\nif (*arg == 0)\r\nlist_add_tail(&f->list, &head->filters);\r\ntcf_tree_unlock(tp);\r\n*arg = (unsigned long)f;\r\nreturn 0;\r\nerr2:\r\ntcf_em_tree_destroy(tp, &t);\r\nerr1:\r\ntcf_exts_destroy(tp, &e);\r\nreturn err;\r\n}\r\nstatic void flow_destroy_filter(struct tcf_proto *tp, struct flow_filter *f)\r\n{\r\ndel_timer_sync(&f->perturb_timer);\r\ntcf_exts_destroy(tp, &f->exts);\r\ntcf_em_tree_destroy(tp, &f->ematches);\r\nkfree(f);\r\n}\r\nstatic int flow_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct flow_filter *f = (struct flow_filter *)arg;\r\ntcf_tree_lock(tp);\r\nlist_del(&f->list);\r\ntcf_tree_unlock(tp);\r\nflow_destroy_filter(tp, f);\r\nreturn 0;\r\n}\r\nstatic int flow_init(struct tcf_proto *tp)\r\n{\r\nstruct flow_head *head;\r\nhead = kzalloc(sizeof(*head), GFP_KERNEL);\r\nif (head == NULL)\r\nreturn -ENOBUFS;\r\nINIT_LIST_HEAD(&head->filters);\r\ntp->root = head;\r\nreturn 0;\r\n}\r\nstatic void flow_destroy(struct tcf_proto *tp)\r\n{\r\nstruct flow_head *head = tp->root;\r\nstruct flow_filter *f, *next;\r\nlist_for_each_entry_safe(f, next, &head->filters, list) {\r\nlist_del(&f->list);\r\nflow_destroy_filter(tp, f);\r\n}\r\nkfree(head);\r\n}\r\nstatic unsigned long flow_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct flow_head *head = tp->root;\r\nstruct flow_filter *f;\r\nlist_for_each_entry(f, &head->filters, list)\r\nif (f->handle == handle)\r\nreturn (unsigned long)f;\r\nreturn 0;\r\n}\r\nstatic void flow_put(struct tcf_proto *tp, unsigned long f)\r\n{\r\n}\r\nstatic int flow_dump(struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct flow_filter *f = (struct flow_filter *)fh;\r\nstruct nlattr *nest;\r\nif (f == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = f->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, TCA_FLOW_KEYS, f->keymask) ||\r\nnla_put_u32(skb, TCA_FLOW_MODE, f->mode))\r\ngoto nla_put_failure;\r\nif (f->mask != ~0 || f->xor != 0) {\r\nif (nla_put_u32(skb, TCA_FLOW_MASK, f->mask) ||\r\nnla_put_u32(skb, TCA_FLOW_XOR, f->xor))\r\ngoto nla_put_failure;\r\n}\r\nif (f->rshift &&\r\nnla_put_u32(skb, TCA_FLOW_RSHIFT, f->rshift))\r\ngoto nla_put_failure;\r\nif (f->addend &&\r\nnla_put_u32(skb, TCA_FLOW_ADDEND, f->addend))\r\ngoto nla_put_failure;\r\nif (f->divisor &&\r\nnla_put_u32(skb, TCA_FLOW_DIVISOR, f->divisor))\r\ngoto nla_put_failure;\r\nif (f->baseclass &&\r\nnla_put_u32(skb, TCA_FLOW_BASECLASS, f->baseclass))\r\ngoto nla_put_failure;\r\nif (f->perturb_period &&\r\nnla_put_u32(skb, TCA_FLOW_PERTURB, f->perturb_period / HZ))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &f->exts, &flow_ext_map) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NET_EMATCH\r\nif (f->ematches.hdr.nmatches &&\r\ntcf_em_tree_dump(skb, &f->ematches, TCA_FLOW_EMATCHES) < 0)\r\ngoto nla_put_failure;\r\n#endif\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &f->exts, &flow_ext_map) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, nest);\r\nreturn -1;\r\n}\r\nstatic void flow_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct flow_head *head = tp->root;\r\nstruct flow_filter *f;\r\nlist_for_each_entry(f, &head->filters, list) {\r\nif (arg->count < arg->skip)\r\ngoto skip;\r\nif (arg->fn(tp, (unsigned long)f, arg) < 0) {\r\narg->stop = 1;\r\nbreak;\r\n}\r\nskip:\r\narg->count++;\r\n}\r\n}\r\nstatic int __init cls_flow_init(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_flow_ops);\r\n}\r\nstatic void __exit cls_flow_exit(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_flow_ops);\r\n}
