static int snd_hammerfall_get_buffer(struct pci_dev *pci, struct snd_dma_buffer *dmab, size_t size)\r\n{\r\ndmab->dev.type = SNDRV_DMA_TYPE_DEV;\r\ndmab->dev.dev = snd_dma_pci_data(pci);\r\nif (snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {\r\nif (dmab->bytes >= size)\r\nreturn 0;\r\n}\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\nsize, dmab) < 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)\r\n{\r\nif (dmab->area) {\r\ndmab->dev.dev = NULL;\r\nsnd_dma_reserve_buf(dmab, snd_dma_pci_buf_id(pci));\r\n}\r\n}\r\nstatic int hdsp_playback_to_output_key (struct hdsp *hdsp, int in, int out)\r\n{\r\nswitch (hdsp->io_type) {\r\ncase Multiface:\r\ncase Digiface:\r\ncase RPM:\r\ndefault:\r\nif (hdsp->firmware_rev == 0xa)\r\nreturn (64 * out) + (32 + (in));\r\nelse\r\nreturn (52 * out) + (26 + (in));\r\ncase H9632:\r\nreturn (32 * out) + (16 + (in));\r\ncase H9652:\r\nreturn (52 * out) + (26 + (in));\r\n}\r\n}\r\nstatic int hdsp_input_to_output_key (struct hdsp *hdsp, int in, int out)\r\n{\r\nswitch (hdsp->io_type) {\r\ncase Multiface:\r\ncase Digiface:\r\ncase RPM:\r\ndefault:\r\nif (hdsp->firmware_rev == 0xa)\r\nreturn (64 * out) + in;\r\nelse\r\nreturn (52 * out) + in;\r\ncase H9632:\r\nreturn (32 * out) + in;\r\ncase H9652:\r\nreturn (52 * out) + in;\r\n}\r\n}\r\nstatic void hdsp_write(struct hdsp *hdsp, int reg, int val)\r\n{\r\nwritel(val, hdsp->iobase + reg);\r\n}\r\nstatic unsigned int hdsp_read(struct hdsp *hdsp, int reg)\r\n{\r\nreturn readl (hdsp->iobase + reg);\r\n}\r\nstatic int hdsp_check_for_iobox (struct hdsp *hdsp)\r\n{\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return 0;\r\nif (hdsp_read (hdsp, HDSP_statusRegister) & HDSP_ConfigError) {\r\nsnd_printk("Hammerfall-DSP: no IO box connected!\n");\r\nhdsp->state &= ~HDSP_FirmwareLoaded;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_wait_for_iobox(struct hdsp *hdsp, unsigned int loops,\r\nunsigned int delay)\r\n{\r\nunsigned int i;\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\r\nreturn 0;\r\nfor (i = 0; i != loops; ++i) {\r\nif (hdsp_read(hdsp, HDSP_statusRegister) & HDSP_ConfigError)\r\nmsleep(delay);\r\nelse {\r\nsnd_printd("Hammerfall-DSP: iobox found after %ums!\n",\r\ni * delay);\r\nreturn 0;\r\n}\r\n}\r\nsnd_printk("Hammerfall-DSP: no IO box connected!\n");\r\nhdsp->state &= ~HDSP_FirmwareLoaded;\r\nreturn -EIO;\r\n}\r\nstatic int snd_hdsp_load_firmware_from_cache(struct hdsp *hdsp) {\r\nint i;\r\nunsigned long flags;\r\nif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\r\nsnd_printk ("Hammerfall-DSP: loading firmware\n");\r\nhdsp_write (hdsp, HDSP_control2Reg, HDSP_S_PROGRAM);\r\nhdsp_write (hdsp, HDSP_fifoData, 0);\r\nif (hdsp_fifo_wait (hdsp, 0, HDSP_LONG_WAIT)) {\r\nsnd_printk ("Hammerfall-DSP: timeout waiting for download preparation\n");\r\nreturn -EIO;\r\n}\r\nhdsp_write (hdsp, HDSP_control2Reg, HDSP_S_LOAD);\r\nfor (i = 0; i < 24413; ++i) {\r\nhdsp_write(hdsp, HDSP_fifoData, hdsp->firmware_cache[i]);\r\nif (hdsp_fifo_wait (hdsp, 127, HDSP_LONG_WAIT)) {\r\nsnd_printk ("Hammerfall-DSP: timeout during firmware loading\n");\r\nreturn -EIO;\r\n}\r\n}\r\nssleep(3);\r\nif (hdsp_fifo_wait (hdsp, 0, HDSP_LONG_WAIT)) {\r\nsnd_printk ("Hammerfall-DSP: timeout at end of firmware loading\n");\r\nreturn -EIO;\r\n}\r\n#ifdef SNDRV_BIG_ENDIAN\r\nhdsp->control2_register = HDSP_BIGENDIAN_MODE;\r\n#else\r\nhdsp->control2_register = 0;\r\n#endif\r\nhdsp_write (hdsp, HDSP_control2Reg, hdsp->control2_register);\r\nsnd_printk ("Hammerfall-DSP: finished firmware loading\n");\r\n}\r\nif (hdsp->state & HDSP_InitializationComplete) {\r\nsnd_printk(KERN_INFO "Hammerfall-DSP: firmware loaded from cache, restoring defaults\n");\r\nspin_lock_irqsave(&hdsp->lock, flags);\r\nsnd_hdsp_set_defaults(hdsp);\r\nspin_unlock_irqrestore(&hdsp->lock, flags);\r\n}\r\nhdsp->state |= HDSP_FirmwareLoaded;\r\nreturn 0;\r\n}\r\nstatic int hdsp_get_iobox_version (struct hdsp *hdsp)\r\n{\r\nif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\r\nhdsp_write (hdsp, HDSP_control2Reg, HDSP_PROGRAM);\r\nhdsp_write (hdsp, HDSP_fifoData, 0);\r\nif (hdsp_fifo_wait (hdsp, 0, HDSP_SHORT_WAIT) < 0)\r\nreturn -EIO;\r\nhdsp_write (hdsp, HDSP_control2Reg, HDSP_S_LOAD);\r\nhdsp_write (hdsp, HDSP_fifoData, 0);\r\nif (hdsp_fifo_wait(hdsp, 0, HDSP_SHORT_WAIT)) {\r\nhdsp_write(hdsp, HDSP_control2Reg, HDSP_VERSION_BIT);\r\nhdsp_write(hdsp, HDSP_control2Reg, HDSP_S_LOAD);\r\nif (hdsp_fifo_wait(hdsp, 0, HDSP_SHORT_WAIT))\r\nhdsp->io_type = RPM;\r\nelse\r\nhdsp->io_type = Multiface;\r\n} else {\r\nhdsp->io_type = Digiface;\r\n}\r\n} else {\r\nif (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version2)\r\nhdsp->io_type = RPM;\r\nelse if (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version1)\r\nhdsp->io_type = Multiface;\r\nelse\r\nhdsp->io_type = Digiface;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_check_for_firmware (struct hdsp *hdsp, int load_on_demand)\r\n{\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\r\nreturn 0;\r\nif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\r\nhdsp->state &= ~HDSP_FirmwareLoaded;\r\nif (! load_on_demand)\r\nreturn -EIO;\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: firmware not present.\n");\r\nif (! (hdsp->state & HDSP_FirmwareCached)) {\r\n#ifdef HDSP_FW_LOADER\r\nif (! hdsp_request_fw_loader(hdsp))\r\nreturn 0;\r\n#endif\r\nsnd_printk(KERN_ERR\r\n"Hammerfall-DSP: No firmware loaded nor "\r\n"cached, please upload firmware.\n");\r\nreturn -EIO;\r\n}\r\nif (snd_hdsp_load_firmware_from_cache(hdsp) != 0) {\r\nsnd_printk(KERN_ERR\r\n"Hammerfall-DSP: Firmware loading from "\r\n"cache failed, please upload manually.\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_fifo_wait(struct hdsp *hdsp, int count, int timeout)\r\n{\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nif ((int)(hdsp_read (hdsp, HDSP_fifoStatus) & 0xff) <= count)\r\nreturn 0;\r\nudelay (100);\r\n}\r\nsnd_printk ("Hammerfall-DSP: wait for FIFO status <= %d failed after %d iterations\n",\r\ncount, timeout);\r\nreturn -1;\r\n}\r\nstatic int hdsp_read_gain (struct hdsp *hdsp, unsigned int addr)\r\n{\r\nif (addr >= HDSP_MATRIX_MIXER_SIZE)\r\nreturn 0;\r\nreturn hdsp->mixer_matrix[addr];\r\n}\r\nstatic int hdsp_write_gain(struct hdsp *hdsp, unsigned int addr, unsigned short data)\r\n{\r\nunsigned int ad;\r\nif (addr >= HDSP_MATRIX_MIXER_SIZE)\r\nreturn -1;\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632) {\r\nif (hdsp->io_type == H9632 && addr >= 512)\r\nreturn 0;\r\nif (hdsp->io_type == H9652 && addr >= 1352)\r\nreturn 0;\r\nhdsp->mixer_matrix[addr] = data;\r\nad = addr/2;\r\nhdsp_write (hdsp, 4096 + (ad*4),\r\n(hdsp->mixer_matrix[(addr&0x7fe)+1] << 16) +\r\nhdsp->mixer_matrix[addr&0x7fe]);\r\nreturn 0;\r\n} else {\r\nad = (addr << 16) + data;\r\nif (hdsp_fifo_wait(hdsp, 127, HDSP_LONG_WAIT))\r\nreturn -1;\r\nhdsp_write (hdsp, HDSP_fifoData, ad);\r\nhdsp->mixer_matrix[addr] = data;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_use_is_exclusive(struct hdsp *hdsp)\r\n{\r\nunsigned long flags;\r\nint ret = 1;\r\nspin_lock_irqsave(&hdsp->lock, flags);\r\nif ((hdsp->playback_pid != hdsp->capture_pid) &&\r\n(hdsp->playback_pid >= 0) && (hdsp->capture_pid >= 0))\r\nret = 0;\r\nspin_unlock_irqrestore(&hdsp->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int hdsp_spdif_sample_rate(struct hdsp *hdsp)\r\n{\r\nunsigned int status = hdsp_read(hdsp, HDSP_statusRegister);\r\nunsigned int rate_bits = (status & HDSP_spdifFrequencyMask);\r\nif (hdsp->io_type == H9632)\r\nrate_bits = (status & HDSP_spdifFrequencyMask_9632);\r\nif (status & HDSP_SPDIFErrorFlag)\r\nreturn 0;\r\nswitch (rate_bits) {\r\ncase HDSP_spdifFrequency32KHz: return 32000;\r\ncase HDSP_spdifFrequency44_1KHz: return 44100;\r\ncase HDSP_spdifFrequency48KHz: return 48000;\r\ncase HDSP_spdifFrequency64KHz: return 64000;\r\ncase HDSP_spdifFrequency88_2KHz: return 88200;\r\ncase HDSP_spdifFrequency96KHz: return 96000;\r\ncase HDSP_spdifFrequency128KHz:\r\nif (hdsp->io_type == H9632) return 128000;\r\nbreak;\r\ncase HDSP_spdifFrequency176_4KHz:\r\nif (hdsp->io_type == H9632) return 176400;\r\nbreak;\r\ncase HDSP_spdifFrequency192KHz:\r\nif (hdsp->io_type == H9632) return 192000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_printk ("Hammerfall-DSP: unknown spdif frequency status; bits = 0x%x, status = 0x%x\n", rate_bits, status);\r\nreturn 0;\r\n}\r\nstatic int hdsp_external_sample_rate(struct hdsp *hdsp)\r\n{\r\nunsigned int status2 = hdsp_read(hdsp, HDSP_status2Register);\r\nunsigned int rate_bits = status2 & HDSP_systemFrequencyMask;\r\nif (hdsp->io_type == H9632 &&\r\nhdsp_autosync_ref(hdsp) == HDSP_AUTOSYNC_FROM_SPDIF)\r\nreturn hdsp_spdif_sample_rate(hdsp);\r\nswitch (rate_bits) {\r\ncase HDSP_systemFrequency32: return 32000;\r\ncase HDSP_systemFrequency44_1: return 44100;\r\ncase HDSP_systemFrequency48: return 48000;\r\ncase HDSP_systemFrequency64: return 64000;\r\ncase HDSP_systemFrequency88_2: return 88200;\r\ncase HDSP_systemFrequency96: return 96000;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void hdsp_compute_period_size(struct hdsp *hdsp)\r\n{\r\nhdsp->period_bytes = 1 << ((hdsp_decode_latency(hdsp->control_register) + 8));\r\n}\r\nstatic snd_pcm_uframes_t hdsp_hw_pointer(struct hdsp *hdsp)\r\n{\r\nint position;\r\nposition = hdsp_read(hdsp, HDSP_statusRegister);\r\nif (!hdsp->precise_ptr)\r\nreturn (position & HDSP_BufferID) ? (hdsp->period_bytes / 4) : 0;\r\nposition &= HDSP_BufferPositionMask;\r\nposition /= 4;\r\nposition &= (hdsp->period_bytes/2) - 1;\r\nreturn position;\r\n}\r\nstatic void hdsp_reset_hw_pointer(struct hdsp *hdsp)\r\n{\r\nhdsp_write (hdsp, HDSP_resetPointer, 0);\r\nif (hdsp->io_type == H9632 && hdsp->firmware_rev >= 152)\r\nhdsp_write (hdsp, HDSP_freqReg, hdsp->dds_value);\r\n}\r\nstatic void hdsp_start_audio(struct hdsp *s)\r\n{\r\ns->control_register |= (HDSP_AudioInterruptEnable | HDSP_Start);\r\nhdsp_write(s, HDSP_controlRegister, s->control_register);\r\n}\r\nstatic void hdsp_stop_audio(struct hdsp *s)\r\n{\r\ns->control_register &= ~(HDSP_Start | HDSP_AudioInterruptEnable);\r\nhdsp_write(s, HDSP_controlRegister, s->control_register);\r\n}\r\nstatic void hdsp_silence_playback(struct hdsp *hdsp)\r\n{\r\nmemset(hdsp->playback_buffer, 0, HDSP_DMA_AREA_BYTES);\r\n}\r\nstatic int hdsp_set_interrupt_interval(struct hdsp *s, unsigned int frames)\r\n{\r\nint n;\r\nspin_lock_irq(&s->lock);\r\nframes >>= 7;\r\nn = 0;\r\nwhile (frames) {\r\nn++;\r\nframes >>= 1;\r\n}\r\ns->control_register &= ~HDSP_LatencyMask;\r\ns->control_register |= hdsp_encode_latency(n);\r\nhdsp_write(s, HDSP_controlRegister, s->control_register);\r\nhdsp_compute_period_size(s);\r\nspin_unlock_irq(&s->lock);\r\nreturn 0;\r\n}\r\nstatic void hdsp_set_dds_value(struct hdsp *hdsp, int rate)\r\n{\r\nu64 n;\r\nif (rate >= 112000)\r\nrate /= 4;\r\nelse if (rate >= 56000)\r\nrate /= 2;\r\nn = DDS_NUMERATOR;\r\nn = div_u64(n, rate);\r\nsnd_BUG_ON(n >> 32);\r\nhdsp->dds_value = n;\r\nhdsp_write(hdsp, HDSP_freqReg, hdsp->dds_value);\r\n}\r\nstatic int hdsp_set_rate(struct hdsp *hdsp, int rate, int called_internally)\r\n{\r\nint reject_if_open = 0;\r\nint current_rate;\r\nint rate_bits;\r\nif (!(hdsp->control_register & HDSP_ClockModeMaster)) {\r\nif (called_internally) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: device is not running as a clock master: cannot set sample rate.\n");\r\nreturn -1;\r\n} else {\r\nint external_freq = hdsp_external_sample_rate(hdsp);\r\nint spdif_freq = hdsp_spdif_sample_rate(hdsp);\r\nif ((spdif_freq == external_freq*2) && (hdsp_autosync_ref(hdsp) >= HDSP_AUTOSYNC_FROM_ADAT1))\r\nsnd_printk(KERN_INFO "Hammerfall-DSP: Detected ADAT in double speed mode\n");\r\nelse if (hdsp->io_type == H9632 && (spdif_freq == external_freq*4) && (hdsp_autosync_ref(hdsp) >= HDSP_AUTOSYNC_FROM_ADAT1))\r\nsnd_printk(KERN_INFO "Hammerfall-DSP: Detected ADAT in quad speed mode\n");\r\nelse if (rate != external_freq) {\r\nsnd_printk(KERN_INFO "Hammerfall-DSP: No AutoSync source for requested rate\n");\r\nreturn -1;\r\n}\r\n}\r\n}\r\ncurrent_rate = hdsp->system_sample_rate;\r\nif (rate > 96000 && hdsp->io_type != H9632)\r\nreturn -EINVAL;\r\nswitch (rate) {\r\ncase 32000:\r\nif (current_rate > 48000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency32KHz;\r\nbreak;\r\ncase 44100:\r\nif (current_rate > 48000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency44_1KHz;\r\nbreak;\r\ncase 48000:\r\nif (current_rate > 48000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency48KHz;\r\nbreak;\r\ncase 64000:\r\nif (current_rate <= 48000 || current_rate > 96000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency64KHz;\r\nbreak;\r\ncase 88200:\r\nif (current_rate <= 48000 || current_rate > 96000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency88_2KHz;\r\nbreak;\r\ncase 96000:\r\nif (current_rate <= 48000 || current_rate > 96000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency96KHz;\r\nbreak;\r\ncase 128000:\r\nif (current_rate < 128000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency128KHz;\r\nbreak;\r\ncase 176400:\r\nif (current_rate < 128000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency176_4KHz;\r\nbreak;\r\ncase 192000:\r\nif (current_rate < 128000)\r\nreject_if_open = 1;\r\nrate_bits = HDSP_Frequency192KHz;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (reject_if_open && (hdsp->capture_pid >= 0 || hdsp->playback_pid >= 0)) {\r\nsnd_printk ("Hammerfall-DSP: cannot change speed mode (capture PID = %d, playback PID = %d)\n",\r\nhdsp->capture_pid,\r\nhdsp->playback_pid);\r\nreturn -EBUSY;\r\n}\r\nhdsp->control_register &= ~HDSP_FrequencyMask;\r\nhdsp->control_register |= rate_bits;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nif (hdsp->io_type == H9632 && hdsp->firmware_rev >= 152)\r\nhdsp_set_dds_value(hdsp, rate);\r\nif (rate >= 128000) {\r\nhdsp->channel_map = channel_map_H9632_qs;\r\n} else if (rate > 48000) {\r\nif (hdsp->io_type == H9632)\r\nhdsp->channel_map = channel_map_H9632_ds;\r\nelse\r\nhdsp->channel_map = channel_map_ds;\r\n} else {\r\nswitch (hdsp->io_type) {\r\ncase RPM:\r\ncase Multiface:\r\nhdsp->channel_map = channel_map_mf_ss;\r\nbreak;\r\ncase Digiface:\r\ncase H9652:\r\nhdsp->channel_map = channel_map_df_ss;\r\nbreak;\r\ncase H9632:\r\nhdsp->channel_map = channel_map_H9632_ss;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nhdsp->system_sample_rate = rate;\r\nreturn 0;\r\n}\r\nstatic unsigned char snd_hdsp_midi_read_byte (struct hdsp *hdsp, int id)\r\n{\r\nif (id)\r\nreturn hdsp_read(hdsp, HDSP_midiDataIn1);\r\nelse\r\nreturn hdsp_read(hdsp, HDSP_midiDataIn0);\r\n}\r\nstatic void snd_hdsp_midi_write_byte (struct hdsp *hdsp, int id, int val)\r\n{\r\nif (id)\r\nhdsp_write(hdsp, HDSP_midiDataOut1, val);\r\nelse\r\nhdsp_write(hdsp, HDSP_midiDataOut0, val);\r\n}\r\nstatic int snd_hdsp_midi_input_available (struct hdsp *hdsp, int id)\r\n{\r\nif (id)\r\nreturn (hdsp_read(hdsp, HDSP_midiStatusIn1) & 0xff);\r\nelse\r\nreturn (hdsp_read(hdsp, HDSP_midiStatusIn0) & 0xff);\r\n}\r\nstatic int snd_hdsp_midi_output_possible (struct hdsp *hdsp, int id)\r\n{\r\nint fifo_bytes_used;\r\nif (id)\r\nfifo_bytes_used = hdsp_read(hdsp, HDSP_midiStatusOut1) & 0xff;\r\nelse\r\nfifo_bytes_used = hdsp_read(hdsp, HDSP_midiStatusOut0) & 0xff;\r\nif (fifo_bytes_used < 128)\r\nreturn 128 - fifo_bytes_used;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void snd_hdsp_flush_midi_input (struct hdsp *hdsp, int id)\r\n{\r\nwhile (snd_hdsp_midi_input_available (hdsp, id))\r\nsnd_hdsp_midi_read_byte (hdsp, id);\r\n}\r\nstatic int snd_hdsp_midi_output_write (struct hdsp_midi *hmidi)\r\n{\r\nunsigned long flags;\r\nint n_pending;\r\nint to_write;\r\nint i;\r\nunsigned char buf[128];\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nif (hmidi->output) {\r\nif (!snd_rawmidi_transmit_empty (hmidi->output)) {\r\nif ((n_pending = snd_hdsp_midi_output_possible (hmidi->hdsp, hmidi->id)) > 0) {\r\nif (n_pending > (int)sizeof (buf))\r\nn_pending = sizeof (buf);\r\nif ((to_write = snd_rawmidi_transmit (hmidi->output, buf, n_pending)) > 0) {\r\nfor (i = 0; i < to_write; ++i)\r\nsnd_hdsp_midi_write_byte (hmidi->hdsp, hmidi->id, buf[i]);\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore (&hmidi->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_midi_input_read (struct hdsp_midi *hmidi)\r\n{\r\nunsigned char buf[128];\r\nunsigned long flags;\r\nint n_pending;\r\nint i;\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nif ((n_pending = snd_hdsp_midi_input_available (hmidi->hdsp, hmidi->id)) > 0) {\r\nif (hmidi->input) {\r\nif (n_pending > (int)sizeof (buf))\r\nn_pending = sizeof (buf);\r\nfor (i = 0; i < n_pending; ++i)\r\nbuf[i] = snd_hdsp_midi_read_byte (hmidi->hdsp, hmidi->id);\r\nif (n_pending)\r\nsnd_rawmidi_receive (hmidi->input, buf, n_pending);\r\n} else {\r\nwhile (--n_pending)\r\nsnd_hdsp_midi_read_byte (hmidi->hdsp, hmidi->id);\r\n}\r\n}\r\nhmidi->pending = 0;\r\nif (hmidi->id)\r\nhmidi->hdsp->control_register |= HDSP_Midi1InterruptEnable;\r\nelse\r\nhmidi->hdsp->control_register |= HDSP_Midi0InterruptEnable;\r\nhdsp_write(hmidi->hdsp, HDSP_controlRegister, hmidi->hdsp->control_register);\r\nspin_unlock_irqrestore (&hmidi->lock, flags);\r\nreturn snd_hdsp_midi_output_write (hmidi);\r\n}\r\nstatic void snd_hdsp_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct hdsp *hdsp;\r\nstruct hdsp_midi *hmidi;\r\nunsigned long flags;\r\nu32 ie;\r\nhmidi = (struct hdsp_midi *) substream->rmidi->private_data;\r\nhdsp = hmidi->hdsp;\r\nie = hmidi->id ? HDSP_Midi1InterruptEnable : HDSP_Midi0InterruptEnable;\r\nspin_lock_irqsave (&hdsp->lock, flags);\r\nif (up) {\r\nif (!(hdsp->control_register & ie)) {\r\nsnd_hdsp_flush_midi_input (hdsp, hmidi->id);\r\nhdsp->control_register |= ie;\r\n}\r\n} else {\r\nhdsp->control_register &= ~ie;\r\ntasklet_kill(&hdsp->midi_tasklet);\r\n}\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nspin_unlock_irqrestore (&hdsp->lock, flags);\r\n}\r\nstatic void snd_hdsp_midi_output_timer(unsigned long data)\r\n{\r\nstruct hdsp_midi *hmidi = (struct hdsp_midi *) data;\r\nunsigned long flags;\r\nsnd_hdsp_midi_output_write(hmidi);\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nif (hmidi->istimer) {\r\nhmidi->timer.expires = 1 + jiffies;\r\nadd_timer(&hmidi->timer);\r\n}\r\nspin_unlock_irqrestore (&hmidi->lock, flags);\r\n}\r\nstatic void snd_hdsp_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct hdsp_midi *hmidi;\r\nunsigned long flags;\r\nhmidi = (struct hdsp_midi *) substream->rmidi->private_data;\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nif (up) {\r\nif (!hmidi->istimer) {\r\ninit_timer(&hmidi->timer);\r\nhmidi->timer.function = snd_hdsp_midi_output_timer;\r\nhmidi->timer.data = (unsigned long) hmidi;\r\nhmidi->timer.expires = 1 + jiffies;\r\nadd_timer(&hmidi->timer);\r\nhmidi->istimer++;\r\n}\r\n} else {\r\nif (hmidi->istimer && --hmidi->istimer <= 0)\r\ndel_timer (&hmidi->timer);\r\n}\r\nspin_unlock_irqrestore (&hmidi->lock, flags);\r\nif (up)\r\nsnd_hdsp_midi_output_write(hmidi);\r\n}\r\nstatic int snd_hdsp_midi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdsp_midi *hmidi;\r\nhmidi = (struct hdsp_midi *) substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nsnd_hdsp_flush_midi_input (hmidi->hdsp, hmidi->id);\r\nhmidi->input = substream;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_midi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdsp_midi *hmidi;\r\nhmidi = (struct hdsp_midi *) substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nhmidi->output = substream;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_midi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdsp_midi *hmidi;\r\nsnd_hdsp_midi_input_trigger (substream, 0);\r\nhmidi = (struct hdsp_midi *) substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nhmidi->input = NULL;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_midi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdsp_midi *hmidi;\r\nsnd_hdsp_midi_output_trigger (substream, 0);\r\nhmidi = (struct hdsp_midi *) substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nhmidi->output = NULL;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_create_midi (struct snd_card *card, struct hdsp *hdsp, int id)\r\n{\r\nchar buf[32];\r\nhdsp->midi[id].id = id;\r\nhdsp->midi[id].rmidi = NULL;\r\nhdsp->midi[id].input = NULL;\r\nhdsp->midi[id].output = NULL;\r\nhdsp->midi[id].hdsp = hdsp;\r\nhdsp->midi[id].istimer = 0;\r\nhdsp->midi[id].pending = 0;\r\nspin_lock_init (&hdsp->midi[id].lock);\r\nsprintf (buf, "%s MIDI %d", card->shortname, id+1);\r\nif (snd_rawmidi_new (card, buf, id, 1, 1, &hdsp->midi[id].rmidi) < 0)\r\nreturn -1;\r\nsprintf(hdsp->midi[id].rmidi->name, "HDSP MIDI %d", id+1);\r\nhdsp->midi[id].rmidi->private_data = &hdsp->midi[id];\r\nsnd_rawmidi_set_ops (hdsp->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_hdsp_midi_output);\r\nsnd_rawmidi_set_ops (hdsp->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_hdsp_midi_input);\r\nhdsp->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nreturn 0;\r\n}\r\nstatic u32 snd_hdsp_convert_from_aes(struct snd_aes_iec958 *aes)\r\n{\r\nu32 val = 0;\r\nval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? HDSP_SPDIFProfessional : 0;\r\nval |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? HDSP_SPDIFNonAudio : 0;\r\nif (val & HDSP_SPDIFProfessional)\r\nval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? HDSP_SPDIFEmphasis : 0;\r\nelse\r\nval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? HDSP_SPDIFEmphasis : 0;\r\nreturn val;\r\n}\r\nstatic void snd_hdsp_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)\r\n{\r\naes->status[0] = ((val & HDSP_SPDIFProfessional) ? IEC958_AES0_PROFESSIONAL : 0) |\r\n((val & HDSP_SPDIFNonAudio) ? IEC958_AES0_NONAUDIO : 0);\r\nif (val & HDSP_SPDIFProfessional)\r\naes->status[0] |= (val & HDSP_SPDIFEmphasis) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\r\nelse\r\naes->status[0] |= (val & HDSP_SPDIFEmphasis) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\r\n}\r\nstatic int snd_hdsp_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nsnd_hdsp_convert_to_aes(&ucontrol->value.iec958, hdsp->creg_spdif);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_hdsp_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&hdsp->lock);\r\nchange = val != hdsp->creg_spdif;\r\nhdsp->creg_spdif = val;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nsnd_hdsp_convert_to_aes(&ucontrol->value.iec958, hdsp->creg_spdif_stream);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_hdsp_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&hdsp->lock);\r\nchange = val != hdsp->creg_spdif_stream;\r\nhdsp->creg_spdif_stream = val;\r\nhdsp->control_register &= ~(HDSP_SPDIFProfessional | HDSP_SPDIFNonAudio | HDSP_SPDIFEmphasis);\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register |= val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = kcontrol->private_value;\r\nreturn 0;\r\n}\r\nstatic unsigned int hdsp_spdif_in(struct hdsp *hdsp)\r\n{\r\nreturn hdsp_decode_spdif_in(hdsp->control_register & HDSP_SPDIFInputMask);\r\n}\r\nstatic int hdsp_set_spdif_input(struct hdsp *hdsp, int in)\r\n{\r\nhdsp->control_register &= ~HDSP_SPDIFInputMask;\r\nhdsp->control_register |= hdsp_encode_spdif_in(in);\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = {"Optical", "Coaxial", "Internal", "AES"};\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = ((hdsp->io_type == H9632) ? 4 : 3);\r\nif (uinfo->value.enumerated.item > ((hdsp->io_type == H9632) ? 3 : 2))\r\nuinfo->value.enumerated.item = ((hdsp->io_type == H9632) ? 3 : 2);\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_spdif_in(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0] % ((hdsp->io_type == H9632) ? 4 : 3);\r\nspin_lock_irq(&hdsp->lock);\r\nchange = val != hdsp_spdif_in(hdsp);\r\nif (change)\r\nhdsp_set_spdif_input(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_spdif_out(struct hdsp *hdsp)\r\n{\r\nreturn (hdsp->control_register & HDSP_SPDIFOpticalOut) ? 1 : 0;\r\n}\r\nstatic int hdsp_set_spdif_output(struct hdsp *hdsp, int out)\r\n{\r\nif (out)\r\nhdsp->control_register |= HDSP_SPDIFOpticalOut;\r\nelse\r\nhdsp->control_register &= ~HDSP_SPDIFOpticalOut;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdsp_spdif_out(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_spdif_out(hdsp);\r\nhdsp_set_spdif_output(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_spdif_professional(struct hdsp *hdsp)\r\n{\r\nreturn (hdsp->control_register & HDSP_SPDIFProfessional) ? 1 : 0;\r\n}\r\nstatic int hdsp_set_spdif_professional(struct hdsp *hdsp, int val)\r\n{\r\nif (val)\r\nhdsp->control_register |= HDSP_SPDIFProfessional;\r\nelse\r\nhdsp->control_register &= ~HDSP_SPDIFProfessional;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_spdif_professional(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdsp_spdif_professional(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_spdif_professional(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_spdif_professional(hdsp);\r\nhdsp_set_spdif_professional(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_spdif_emphasis(struct hdsp *hdsp)\r\n{\r\nreturn (hdsp->control_register & HDSP_SPDIFEmphasis) ? 1 : 0;\r\n}\r\nstatic int hdsp_set_spdif_emphasis(struct hdsp *hdsp, int val)\r\n{\r\nif (val)\r\nhdsp->control_register |= HDSP_SPDIFEmphasis;\r\nelse\r\nhdsp->control_register &= ~HDSP_SPDIFEmphasis;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_spdif_emphasis(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdsp_spdif_emphasis(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_spdif_emphasis(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_spdif_emphasis(hdsp);\r\nhdsp_set_spdif_emphasis(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_spdif_nonaudio(struct hdsp *hdsp)\r\n{\r\nreturn (hdsp->control_register & HDSP_SPDIFNonAudio) ? 1 : 0;\r\n}\r\nstatic int hdsp_set_spdif_nonaudio(struct hdsp *hdsp, int val)\r\n{\r\nif (val)\r\nhdsp->control_register |= HDSP_SPDIFNonAudio;\r\nelse\r\nhdsp->control_register &= ~HDSP_SPDIFNonAudio;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_spdif_nonaudio(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdsp_spdif_nonaudio(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_spdif_nonaudio(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_spdif_nonaudio(hdsp);\r\nhdsp_set_spdif_nonaudio(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_info_spdif_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"32000", "44100", "48000", "64000", "88200", "96000", "None", "128000", "176400", "192000"};\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = (hdsp->io_type == H9632) ? 10 : 7;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_spdif_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nswitch (hdsp_spdif_sample_rate(hdsp)) {\r\ncase 32000:\r\nucontrol->value.enumerated.item[0] = 0;\r\nbreak;\r\ncase 44100:\r\nucontrol->value.enumerated.item[0] = 1;\r\nbreak;\r\ncase 48000:\r\nucontrol->value.enumerated.item[0] = 2;\r\nbreak;\r\ncase 64000:\r\nucontrol->value.enumerated.item[0] = 3;\r\nbreak;\r\ncase 88200:\r\nucontrol->value.enumerated.item[0] = 4;\r\nbreak;\r\ncase 96000:\r\nucontrol->value.enumerated.item[0] = 5;\r\nbreak;\r\ncase 128000:\r\nucontrol->value.enumerated.item[0] = 7;\r\nbreak;\r\ncase 176400:\r\nucontrol->value.enumerated.item[0] = 8;\r\nbreak;\r\ncase 192000:\r\nucontrol->value.enumerated.item[0] = 9;\r\nbreak;\r\ndefault:\r\nucontrol->value.enumerated.item[0] = 6;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_system_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_system_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp->system_sample_rate;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_autosync_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nstatic char *texts[] = {"32000", "44100", "48000", "64000", "88200", "96000", "None", "128000", "176400", "192000"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = (hdsp->io_type == H9632) ? 10 : 7 ;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_autosync_sample_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nswitch (hdsp_external_sample_rate(hdsp)) {\r\ncase 32000:\r\nucontrol->value.enumerated.item[0] = 0;\r\nbreak;\r\ncase 44100:\r\nucontrol->value.enumerated.item[0] = 1;\r\nbreak;\r\ncase 48000:\r\nucontrol->value.enumerated.item[0] = 2;\r\nbreak;\r\ncase 64000:\r\nucontrol->value.enumerated.item[0] = 3;\r\nbreak;\r\ncase 88200:\r\nucontrol->value.enumerated.item[0] = 4;\r\nbreak;\r\ncase 96000:\r\nucontrol->value.enumerated.item[0] = 5;\r\nbreak;\r\ncase 128000:\r\nucontrol->value.enumerated.item[0] = 7;\r\nbreak;\r\ncase 176400:\r\nucontrol->value.enumerated.item[0] = 8;\r\nbreak;\r\ncase 192000:\r\nucontrol->value.enumerated.item[0] = 9;\r\nbreak;\r\ndefault:\r\nucontrol->value.enumerated.item[0] = 6;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_system_clock_mode(struct hdsp *hdsp)\r\n{\r\nif (hdsp->control_register & HDSP_ClockModeMaster)\r\nreturn 0;\r\nelse if (hdsp_external_sample_rate(hdsp) != hdsp->system_sample_rate)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int snd_hdsp_info_system_clock_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"Master", "Slave" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_system_clock_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_system_clock_mode(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_clock_source(struct hdsp *hdsp)\r\n{\r\nif (hdsp->control_register & HDSP_ClockModeMaster) {\r\nswitch (hdsp->system_sample_rate) {\r\ncase 32000:\r\nreturn 1;\r\ncase 44100:\r\nreturn 2;\r\ncase 48000:\r\nreturn 3;\r\ncase 64000:\r\nreturn 4;\r\ncase 88200:\r\nreturn 5;\r\ncase 96000:\r\nreturn 6;\r\ncase 128000:\r\nreturn 7;\r\ncase 176400:\r\nreturn 8;\r\ncase 192000:\r\nreturn 9;\r\ndefault:\r\nreturn 3;\r\n}\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int hdsp_set_clock_source(struct hdsp *hdsp, int mode)\r\n{\r\nint rate;\r\nswitch (mode) {\r\ncase HDSP_CLOCK_SOURCE_AUTOSYNC:\r\nif (hdsp_external_sample_rate(hdsp) != 0) {\r\nif (!hdsp_set_rate(hdsp, hdsp_external_sample_rate(hdsp), 1)) {\r\nhdsp->control_register &= ~HDSP_ClockModeMaster;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_32KHZ:\r\nrate = 32000;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_44_1KHZ:\r\nrate = 44100;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_48KHZ:\r\nrate = 48000;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_64KHZ:\r\nrate = 64000;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_88_2KHZ:\r\nrate = 88200;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_96KHZ:\r\nrate = 96000;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_128KHZ:\r\nrate = 128000;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_176_4KHZ:\r\nrate = 176400;\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_192KHZ:\r\nrate = 192000;\r\nbreak;\r\ndefault:\r\nrate = 48000;\r\n}\r\nhdsp->control_register |= HDSP_ClockModeMaster;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nhdsp_set_rate(hdsp, rate, 1);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_clock_source(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"AutoSync", "Internal 32.0 kHz", "Internal 44.1 kHz", "Internal 48.0 kHz", "Internal 64.0 kHz", "Internal 88.2 kHz", "Internal 96.0 kHz", "Internal 128 kHz", "Internal 176.4 kHz", "Internal 192.0 KHz" };\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nif (hdsp->io_type == H9632)\r\nuinfo->value.enumerated.items = 10;\r\nelse\r\nuinfo->value.enumerated.items = 7;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_clock_source(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_clock_source(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_clock_source(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0) val = 0;\r\nif (hdsp->io_type == H9632) {\r\nif (val > 9)\r\nval = 9;\r\n} else {\r\nif (val > 6)\r\nval = 6;\r\n}\r\nspin_lock_irq(&hdsp->lock);\r\nif (val != hdsp_clock_source(hdsp))\r\nchange = (hdsp_set_clock_source(hdsp, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_get_clock_source_lock(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdsp->clock_source_locked;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_clock_source_lock(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nchange = (int)ucontrol->value.integer.value[0] != hdsp->clock_source_locked;\r\nif (change)\r\nhdsp->clock_source_locked = !!ucontrol->value.integer.value[0];\r\nreturn change;\r\n}\r\nstatic int hdsp_da_gain(struct hdsp *hdsp)\r\n{\r\nswitch (hdsp->control_register & HDSP_DAGainMask) {\r\ncase HDSP_DAGainHighGain:\r\nreturn 0;\r\ncase HDSP_DAGainPlus4dBu:\r\nreturn 1;\r\ncase HDSP_DAGainMinus10dBV:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int hdsp_set_da_gain(struct hdsp *hdsp, int mode)\r\n{\r\nhdsp->control_register &= ~HDSP_DAGainMask;\r\nswitch (mode) {\r\ncase 0:\r\nhdsp->control_register |= HDSP_DAGainHighGain;\r\nbreak;\r\ncase 1:\r\nhdsp->control_register |= HDSP_DAGainPlus4dBu;\r\nbreak;\r\ncase 2:\r\nhdsp->control_register |= HDSP_DAGainMinus10dBV;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_da_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"Hi Gain", "+4 dBu", "-10 dbV"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_da_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_da_gain(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_da_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0) val = 0;\r\nif (val > 2) val = 2;\r\nspin_lock_irq(&hdsp->lock);\r\nif (val != hdsp_da_gain(hdsp))\r\nchange = (hdsp_set_da_gain(hdsp, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_ad_gain(struct hdsp *hdsp)\r\n{\r\nswitch (hdsp->control_register & HDSP_ADGainMask) {\r\ncase HDSP_ADGainMinus10dBV:\r\nreturn 0;\r\ncase HDSP_ADGainPlus4dBu:\r\nreturn 1;\r\ncase HDSP_ADGainLowGain:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int hdsp_set_ad_gain(struct hdsp *hdsp, int mode)\r\n{\r\nhdsp->control_register &= ~HDSP_ADGainMask;\r\nswitch (mode) {\r\ncase 0:\r\nhdsp->control_register |= HDSP_ADGainMinus10dBV;\r\nbreak;\r\ncase 1:\r\nhdsp->control_register |= HDSP_ADGainPlus4dBu;\r\nbreak;\r\ncase 2:\r\nhdsp->control_register |= HDSP_ADGainLowGain;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_ad_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"-10 dBV", "+4 dBu", "Lo Gain"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_ad_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_ad_gain(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_ad_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0) val = 0;\r\nif (val > 2) val = 2;\r\nspin_lock_irq(&hdsp->lock);\r\nif (val != hdsp_ad_gain(hdsp))\r\nchange = (hdsp_set_ad_gain(hdsp, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_phone_gain(struct hdsp *hdsp)\r\n{\r\nswitch (hdsp->control_register & HDSP_PhoneGainMask) {\r\ncase HDSP_PhoneGain0dB:\r\nreturn 0;\r\ncase HDSP_PhoneGainMinus6dB:\r\nreturn 1;\r\ncase HDSP_PhoneGainMinus12dB:\r\nreturn 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int hdsp_set_phone_gain(struct hdsp *hdsp, int mode)\r\n{\r\nhdsp->control_register &= ~HDSP_PhoneGainMask;\r\nswitch (mode) {\r\ncase 0:\r\nhdsp->control_register |= HDSP_PhoneGain0dB;\r\nbreak;\r\ncase 1:\r\nhdsp->control_register |= HDSP_PhoneGainMinus6dB;\r\nbreak;\r\ncase 2:\r\nhdsp->control_register |= HDSP_PhoneGainMinus12dB;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_phone_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"0 dB", "-6 dB", "-12 dB"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_phone_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_phone_gain(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_phone_gain(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0) val = 0;\r\nif (val > 2) val = 2;\r\nspin_lock_irq(&hdsp->lock);\r\nif (val != hdsp_phone_gain(hdsp))\r\nchange = (hdsp_set_phone_gain(hdsp, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_xlr_breakout_cable(struct hdsp *hdsp)\r\n{\r\nif (hdsp->control_register & HDSP_XLRBreakoutCable)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hdsp_set_xlr_breakout_cable(struct hdsp *hdsp, int mode)\r\n{\r\nif (mode)\r\nhdsp->control_register |= HDSP_XLRBreakoutCable;\r\nelse\r\nhdsp->control_register &= ~HDSP_XLRBreakoutCable;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_xlr_breakout_cable(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_xlr_breakout_cable(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_xlr_breakout_cable(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_xlr_breakout_cable(hdsp);\r\nhdsp_set_xlr_breakout_cable(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_aeb(struct hdsp *hdsp)\r\n{\r\nif (hdsp->control_register & HDSP_AnalogExtensionBoard)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hdsp_set_aeb(struct hdsp *hdsp, int mode)\r\n{\r\nif (mode)\r\nhdsp->control_register |= HDSP_AnalogExtensionBoard;\r\nelse\r\nhdsp->control_register &= ~HDSP_AnalogExtensionBoard;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_aeb(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_aeb(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_aeb(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_aeb(hdsp);\r\nhdsp_set_aeb(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_pref_sync_ref(struct hdsp *hdsp)\r\n{\r\nswitch (hdsp->control_register & HDSP_SyncRefMask) {\r\ncase HDSP_SyncRef_ADAT1:\r\nreturn HDSP_SYNC_FROM_ADAT1;\r\ncase HDSP_SyncRef_ADAT2:\r\nreturn HDSP_SYNC_FROM_ADAT2;\r\ncase HDSP_SyncRef_ADAT3:\r\nreturn HDSP_SYNC_FROM_ADAT3;\r\ncase HDSP_SyncRef_SPDIF:\r\nreturn HDSP_SYNC_FROM_SPDIF;\r\ncase HDSP_SyncRef_WORD:\r\nreturn HDSP_SYNC_FROM_WORD;\r\ncase HDSP_SyncRef_ADAT_SYNC:\r\nreturn HDSP_SYNC_FROM_ADAT_SYNC;\r\ndefault:\r\nreturn HDSP_SYNC_FROM_WORD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_set_pref_sync_ref(struct hdsp *hdsp, int pref)\r\n{\r\nhdsp->control_register &= ~HDSP_SyncRefMask;\r\nswitch (pref) {\r\ncase HDSP_SYNC_FROM_ADAT1:\r\nhdsp->control_register &= ~HDSP_SyncRefMask;\r\nbreak;\r\ncase HDSP_SYNC_FROM_ADAT2:\r\nhdsp->control_register |= HDSP_SyncRef_ADAT2;\r\nbreak;\r\ncase HDSP_SYNC_FROM_ADAT3:\r\nhdsp->control_register |= HDSP_SyncRef_ADAT3;\r\nbreak;\r\ncase HDSP_SYNC_FROM_SPDIF:\r\nhdsp->control_register |= HDSP_SyncRef_SPDIF;\r\nbreak;\r\ncase HDSP_SYNC_FROM_WORD:\r\nhdsp->control_register |= HDSP_SyncRef_WORD;\r\nbreak;\r\ncase HDSP_SYNC_FROM_ADAT_SYNC:\r\nhdsp->control_register |= HDSP_SyncRef_ADAT_SYNC;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_pref_sync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"Word", "IEC958", "ADAT1", "ADAT Sync", "ADAT2", "ADAT3" };\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nswitch (hdsp->io_type) {\r\ncase Digiface:\r\ncase H9652:\r\nuinfo->value.enumerated.items = 6;\r\nbreak;\r\ncase Multiface:\r\nuinfo->value.enumerated.items = 4;\r\nbreak;\r\ncase H9632:\r\nuinfo->value.enumerated.items = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_pref_sync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_pref_sync_ref(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_pref_sync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change, max;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nswitch (hdsp->io_type) {\r\ncase Digiface:\r\ncase H9652:\r\nmax = 6;\r\nbreak;\r\ncase Multiface:\r\nmax = 4;\r\nbreak;\r\ncase H9632:\r\nmax = 3;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nval = ucontrol->value.enumerated.item[0] % max;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_pref_sync_ref(hdsp);\r\nhdsp_set_pref_sync_ref(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_autosync_ref(struct hdsp *hdsp)\r\n{\r\nunsigned int status2 = hdsp_read(hdsp, HDSP_status2Register);\r\nswitch (status2 & HDSP_SelSyncRefMask) {\r\ncase HDSP_SelSyncRef_WORD:\r\nreturn HDSP_AUTOSYNC_FROM_WORD;\r\ncase HDSP_SelSyncRef_ADAT_SYNC:\r\nreturn HDSP_AUTOSYNC_FROM_ADAT_SYNC;\r\ncase HDSP_SelSyncRef_SPDIF:\r\nreturn HDSP_AUTOSYNC_FROM_SPDIF;\r\ncase HDSP_SelSyncRefMask:\r\nreturn HDSP_AUTOSYNC_FROM_NONE;\r\ncase HDSP_SelSyncRef_ADAT1:\r\nreturn HDSP_AUTOSYNC_FROM_ADAT1;\r\ncase HDSP_SelSyncRef_ADAT2:\r\nreturn HDSP_AUTOSYNC_FROM_ADAT2;\r\ncase HDSP_SelSyncRef_ADAT3:\r\nreturn HDSP_AUTOSYNC_FROM_ADAT3;\r\ndefault:\r\nreturn HDSP_AUTOSYNC_FROM_WORD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_autosync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"Word", "ADAT Sync", "IEC958", "None", "ADAT1", "ADAT2", "ADAT3" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 7;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_autosync_ref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_autosync_ref(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_line_out(struct hdsp *hdsp)\r\n{\r\nreturn (hdsp->control_register & HDSP_LineOut) ? 1 : 0;\r\n}\r\nstatic int hdsp_set_line_output(struct hdsp *hdsp, int out)\r\n{\r\nif (out)\r\nhdsp->control_register |= HDSP_LineOut;\r\nelse\r\nhdsp->control_register &= ~HDSP_LineOut;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_line_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&hdsp->lock);\r\nucontrol->value.integer.value[0] = hdsp_line_out(hdsp);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_line_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_line_out(hdsp);\r\nhdsp_set_line_output(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_set_precise_pointer(struct hdsp *hdsp, int precise)\r\n{\r\nif (precise)\r\nhdsp->precise_ptr = 1;\r\nelse\r\nhdsp->precise_ptr = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_precise_pointer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&hdsp->lock);\r\nucontrol->value.integer.value[0] = hdsp->precise_ptr;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_precise_pointer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp->precise_ptr;\r\nhdsp_set_precise_pointer(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_set_use_midi_tasklet(struct hdsp *hdsp, int use_tasklet)\r\n{\r\nif (use_tasklet)\r\nhdsp->use_midi_tasklet = 1;\r\nelse\r\nhdsp->use_midi_tasklet = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_use_midi_tasklet(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&hdsp->lock);\r\nucontrol->value.integer.value[0] = hdsp->use_midi_tasklet;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_use_midi_tasklet(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp->use_midi_tasklet;\r\nhdsp_set_use_midi_tasklet(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_info_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 3;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 65536;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint source;\r\nint destination;\r\nint addr;\r\nsource = ucontrol->value.integer.value[0];\r\ndestination = ucontrol->value.integer.value[1];\r\nif (source >= hdsp->max_channels)\r\naddr = hdsp_playback_to_output_key(hdsp,source-hdsp->max_channels,destination);\r\nelse\r\naddr = hdsp_input_to_output_key(hdsp,source, destination);\r\nspin_lock_irq(&hdsp->lock);\r\nucontrol->value.integer.value[2] = hdsp_read_gain (hdsp, addr);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint source;\r\nint destination;\r\nint gain;\r\nint addr;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nsource = ucontrol->value.integer.value[0];\r\ndestination = ucontrol->value.integer.value[1];\r\nif (source >= hdsp->max_channels)\r\naddr = hdsp_playback_to_output_key(hdsp,source-hdsp->max_channels, destination);\r\nelse\r\naddr = hdsp_input_to_output_key(hdsp,source, destination);\r\ngain = ucontrol->value.integer.value[2];\r\nspin_lock_irq(&hdsp->lock);\r\nchange = gain != hdsp_read_gain(hdsp, addr);\r\nif (change)\r\nhdsp_write_gain(hdsp, addr, gain);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_info_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"No Lock", "Lock", "Sync" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int hdsp_wc_sync_check(struct hdsp *hdsp)\r\n{\r\nint status2 = hdsp_read(hdsp, HDSP_status2Register);\r\nif (status2 & HDSP_wc_lock) {\r\nif (status2 & HDSP_wc_sync)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n} else\r\nreturn 0;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_wc_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_wc_sync_check(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_spdif_sync_check(struct hdsp *hdsp)\r\n{\r\nint status = hdsp_read(hdsp, HDSP_statusRegister);\r\nif (status & HDSP_SPDIFErrorFlag)\r\nreturn 0;\r\nelse {\r\nif (status & HDSP_SPDIFSync)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_spdif_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_spdif_sync_check(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_adatsync_sync_check(struct hdsp *hdsp)\r\n{\r\nint status = hdsp_read(hdsp, HDSP_statusRegister);\r\nif (status & HDSP_TimecodeLock) {\r\nif (status & HDSP_TimecodeSync)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_adatsync_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_adatsync_sync_check(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_adat_sync_check(struct hdsp *hdsp, int idx)\r\n{\r\nint status = hdsp_read(hdsp, HDSP_statusRegister);\r\nif (status & (HDSP_Lock0>>idx)) {\r\nif (status & (HDSP_Sync0>>idx))\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_adat_sync_check(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nint offset;\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\noffset = ucontrol->id.index - 1;\r\nsnd_BUG_ON(offset < 0);\r\nswitch (hdsp->io_type) {\r\ncase Digiface:\r\ncase H9652:\r\nif (offset >= 3)\r\nreturn -EINVAL;\r\nbreak;\r\ncase Multiface:\r\ncase H9632:\r\nif (offset >= 1)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nucontrol->value.enumerated.item[0] = hdsp_adat_sync_check(hdsp, offset);\r\nreturn 0;\r\n}\r\nstatic int hdsp_dds_offset(struct hdsp *hdsp)\r\n{\r\nu64 n;\r\nunsigned int dds_value = hdsp->dds_value;\r\nint system_sample_rate = hdsp->system_sample_rate;\r\nif (!dds_value)\r\nreturn 0;\r\nn = DDS_NUMERATOR;\r\nn = div_u64(n, dds_value);\r\nif (system_sample_rate >= 112000)\r\nn *= 4;\r\nelse if (system_sample_rate >= 56000)\r\nn *= 2;\r\nreturn ((int)n) - system_sample_rate;\r\n}\r\nstatic int hdsp_set_dds_offset(struct hdsp *hdsp, int offset_hz)\r\n{\r\nint rate = hdsp->system_sample_rate + offset_hz;\r\nhdsp_set_dds_value(hdsp, rate);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_info_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = -5000;\r\nuinfo->value.integer.max = 5000;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_get_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_dds_offset(hdsp);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nspin_lock_irq(&hdsp->lock);\r\nif (val != hdsp_dds_offset(hdsp))\r\nchange = (hdsp_set_dds_offset(hdsp, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_rpm_input12(struct hdsp *hdsp)\r\n{\r\nswitch (hdsp->control_register & HDSP_RPM_Inp12) {\r\ncase HDSP_RPM_Inp12_Phon_6dB:\r\nreturn 0;\r\ncase HDSP_RPM_Inp12_Phon_n6dB:\r\nreturn 2;\r\ncase HDSP_RPM_Inp12_Line_0dB:\r\nreturn 3;\r\ncase HDSP_RPM_Inp12_Line_n6dB:\r\nreturn 4;\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_hdsp_get_rpm_input12(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_rpm_input12(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_set_rpm_input12(struct hdsp *hdsp, int mode)\r\n{\r\nhdsp->control_register &= ~HDSP_RPM_Inp12;\r\nswitch (mode) {\r\ncase 0:\r\nhdsp->control_register |= HDSP_RPM_Inp12_Phon_6dB;\r\nbreak;\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nhdsp->control_register |= HDSP_RPM_Inp12_Phon_n6dB;\r\nbreak;\r\ncase 3:\r\nhdsp->control_register |= HDSP_RPM_Inp12_Line_0dB;\r\nbreak;\r\ncase 4:\r\nhdsp->control_register |= HDSP_RPM_Inp12_Line_n6dB;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_rpm_input12(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0)\r\nval = 0;\r\nif (val > 4)\r\nval = 4;\r\nspin_lock_irq(&hdsp->lock);\r\nif (val != hdsp_rpm_input12(hdsp))\r\nchange = (hdsp_set_rpm_input12(hdsp, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_info_rpm_input(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"Phono +6dB", "Phono 0dB", "Phono -6dB", "Line 0dB", "Line -6dB"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 5;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int hdsp_rpm_input34(struct hdsp *hdsp)\r\n{\r\nswitch (hdsp->control_register & HDSP_RPM_Inp34) {\r\ncase HDSP_RPM_Inp34_Phon_6dB:\r\nreturn 0;\r\ncase HDSP_RPM_Inp34_Phon_n6dB:\r\nreturn 2;\r\ncase HDSP_RPM_Inp34_Line_0dB:\r\nreturn 3;\r\ncase HDSP_RPM_Inp34_Line_n6dB:\r\nreturn 4;\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_hdsp_get_rpm_input34(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdsp_rpm_input34(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_set_rpm_input34(struct hdsp *hdsp, int mode)\r\n{\r\nhdsp->control_register &= ~HDSP_RPM_Inp34;\r\nswitch (mode) {\r\ncase 0:\r\nhdsp->control_register |= HDSP_RPM_Inp34_Phon_6dB;\r\nbreak;\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nhdsp->control_register |= HDSP_RPM_Inp34_Phon_n6dB;\r\nbreak;\r\ncase 3:\r\nhdsp->control_register |= HDSP_RPM_Inp34_Line_0dB;\r\nbreak;\r\ncase 4:\r\nhdsp->control_register |= HDSP_RPM_Inp34_Line_n6dB;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_rpm_input34(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0)\r\nval = 0;\r\nif (val > 4)\r\nval = 4;\r\nspin_lock_irq(&hdsp->lock);\r\nif (val != hdsp_rpm_input34(hdsp))\r\nchange = (hdsp_set_rpm_input34(hdsp, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int hdsp_rpm_bypass(struct hdsp *hdsp)\r\n{\r\nreturn (hdsp->control_register & HDSP_RPM_Bypass) ? 1 : 0;\r\n}\r\nstatic int snd_hdsp_get_rpm_bypass(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdsp_rpm_bypass(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_set_rpm_bypass(struct hdsp *hdsp, int on)\r\n{\r\nif (on)\r\nhdsp->control_register |= HDSP_RPM_Bypass;\r\nelse\r\nhdsp->control_register &= ~HDSP_RPM_Bypass;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_rpm_bypass(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_rpm_bypass(hdsp);\r\nhdsp_set_rpm_bypass(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_info_rpm_bypass(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"On", "Off"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int hdsp_rpm_disconnect(struct hdsp *hdsp)\r\n{\r\nreturn (hdsp->control_register & HDSP_RPM_Disconnect) ? 1 : 0;\r\n}\r\nstatic int snd_hdsp_get_rpm_disconnect(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdsp_rpm_disconnect(hdsp);\r\nreturn 0;\r\n}\r\nstatic int hdsp_set_rpm_disconnect(struct hdsp *hdsp, int on)\r\n{\r\nif (on)\r\nhdsp->control_register |= HDSP_RPM_Disconnect;\r\nelse\r\nhdsp->control_register &= ~HDSP_RPM_Disconnect;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_put_rpm_disconnect(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdsp *hdsp = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdsp_use_is_exclusive(hdsp))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdsp->lock);\r\nchange = (int)val != hdsp_rpm_disconnect(hdsp);\r\nhdsp_set_rpm_disconnect(hdsp, val);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdsp_info_rpm_disconnect(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = {"On", "Off"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_create_controls(struct snd_card *card, struct hdsp *hdsp)\r\n{\r\nunsigned int idx;\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nif (hdsp->io_type == RPM) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_hdsp_rpm_controls); idx++) {\r\nerr = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_hdsp_rpm_controls[idx], hdsp));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_hdsp_controls); idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_hdsp_controls[idx], hdsp))) < 0)\r\nreturn err;\r\nif (idx == 1)\r\nhdsp->spdif_ctl = kctl;\r\n}\r\nsnd_hdsp_adat_sync_check.name = "ADAT Lock Status";\r\nsnd_hdsp_adat_sync_check.index = 1;\r\nif ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_adat_sync_check, hdsp))))\r\nreturn err;\r\nif (hdsp->io_type == Digiface || hdsp->io_type == H9652) {\r\nfor (idx = 1; idx < 3; ++idx) {\r\nsnd_hdsp_adat_sync_check.index = idx+1;\r\nif ((err = snd_ctl_add (card, kctl = snd_ctl_new1(&snd_hdsp_adat_sync_check, hdsp))))\r\nreturn err;\r\n}\r\n}\r\nif (hdsp->io_type == H9632) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_hdsp_9632_controls); idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_hdsp_9632_controls[idx], hdsp))) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (hdsp->io_type == H9632 || hdsp->io_type == H9652) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_hdsp_96xx_aeb, hdsp))) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_hdsp_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct hdsp *hdsp = entry->private_data;\r\nunsigned int status;\r\nunsigned int status2;\r\nchar *pref_sync_ref;\r\nchar *autosync_ref;\r\nchar *system_clock_mode;\r\nchar *clock_source;\r\nint x;\r\nstatus = hdsp_read(hdsp, HDSP_statusRegister);\r\nstatus2 = hdsp_read(hdsp, HDSP_status2Register);\r\nsnd_iprintf(buffer, "%s (Card #%d)\n", hdsp->card_name,\r\nhdsp->card->number + 1);\r\nsnd_iprintf(buffer, "Buffers: capture %p playback %p\n",\r\nhdsp->capture_buffer, hdsp->playback_buffer);\r\nsnd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",\r\nhdsp->irq, hdsp->port, (unsigned long)hdsp->iobase);\r\nsnd_iprintf(buffer, "Control register: 0x%x\n", hdsp->control_register);\r\nsnd_iprintf(buffer, "Control2 register: 0x%x\n",\r\nhdsp->control2_register);\r\nsnd_iprintf(buffer, "Status register: 0x%x\n", status);\r\nsnd_iprintf(buffer, "Status2 register: 0x%x\n", status2);\r\nif (hdsp_check_for_iobox(hdsp)) {\r\nsnd_iprintf(buffer, "No I/O box connected.\n"\r\n"Please connect one and upload firmware.\n");\r\nreturn;\r\n}\r\nif (hdsp_check_for_firmware(hdsp, 0)) {\r\nif (hdsp->state & HDSP_FirmwareCached) {\r\nif (snd_hdsp_load_firmware_from_cache(hdsp) != 0) {\r\nsnd_iprintf(buffer, "Firmware loading from "\r\n"cache failed, "\r\n"please upload manually.\n");\r\nreturn;\r\n}\r\n} else {\r\nint err = -EINVAL;\r\n#ifdef HDSP_FW_LOADER\r\nerr = hdsp_request_fw_loader(hdsp);\r\n#endif\r\nif (err < 0) {\r\nsnd_iprintf(buffer,\r\n"No firmware loaded nor cached, "\r\n"please upload firmware.\n");\r\nreturn;\r\n}\r\n}\r\n}\r\nsnd_iprintf(buffer, "FIFO status: %d\n", hdsp_read(hdsp, HDSP_fifoStatus) & 0xff);\r\nsnd_iprintf(buffer, "MIDI1 Output status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusOut0));\r\nsnd_iprintf(buffer, "MIDI1 Input status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusIn0));\r\nsnd_iprintf(buffer, "MIDI2 Output status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusOut1));\r\nsnd_iprintf(buffer, "MIDI2 Input status: 0x%x\n", hdsp_read(hdsp, HDSP_midiStatusIn1));\r\nsnd_iprintf(buffer, "Use Midi Tasklet: %s\n", hdsp->use_midi_tasklet ? "on" : "off");\r\nsnd_iprintf(buffer, "\n");\r\nx = 1 << (6 + hdsp_decode_latency(hdsp->control_register & HDSP_LatencyMask));\r\nsnd_iprintf(buffer, "Buffer Size (Latency): %d samples (2 periods of %lu bytes)\n", x, (unsigned long) hdsp->period_bytes);\r\nsnd_iprintf(buffer, "Hardware pointer (frames): %ld\n", hdsp_hw_pointer(hdsp));\r\nsnd_iprintf(buffer, "Precise pointer: %s\n", hdsp->precise_ptr ? "on" : "off");\r\nsnd_iprintf(buffer, "Line out: %s\n", (hdsp->control_register & HDSP_LineOut) ? "on" : "off");\r\nsnd_iprintf(buffer, "Firmware version: %d\n", (status2&HDSP_version0)|(status2&HDSP_version1)<<1|(status2&HDSP_version2)<<2);\r\nsnd_iprintf(buffer, "\n");\r\nswitch (hdsp_clock_source(hdsp)) {\r\ncase HDSP_CLOCK_SOURCE_AUTOSYNC:\r\nclock_source = "AutoSync";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_32KHZ:\r\nclock_source = "Internal 32 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_44_1KHZ:\r\nclock_source = "Internal 44.1 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_48KHZ:\r\nclock_source = "Internal 48 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_64KHZ:\r\nclock_source = "Internal 64 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_88_2KHZ:\r\nclock_source = "Internal 88.2 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_96KHZ:\r\nclock_source = "Internal 96 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_128KHZ:\r\nclock_source = "Internal 128 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_176_4KHZ:\r\nclock_source = "Internal 176.4 kHz";\r\nbreak;\r\ncase HDSP_CLOCK_SOURCE_INTERNAL_192KHZ:\r\nclock_source = "Internal 192 kHz";\r\nbreak;\r\ndefault:\r\nclock_source = "Error";\r\n}\r\nsnd_iprintf (buffer, "Sample Clock Source: %s\n", clock_source);\r\nif (hdsp_system_clock_mode(hdsp))\r\nsystem_clock_mode = "Slave";\r\nelse\r\nsystem_clock_mode = "Master";\r\nswitch (hdsp_pref_sync_ref (hdsp)) {\r\ncase HDSP_SYNC_FROM_WORD:\r\npref_sync_ref = "Word Clock";\r\nbreak;\r\ncase HDSP_SYNC_FROM_ADAT_SYNC:\r\npref_sync_ref = "ADAT Sync";\r\nbreak;\r\ncase HDSP_SYNC_FROM_SPDIF:\r\npref_sync_ref = "SPDIF";\r\nbreak;\r\ncase HDSP_SYNC_FROM_ADAT1:\r\npref_sync_ref = "ADAT1";\r\nbreak;\r\ncase HDSP_SYNC_FROM_ADAT2:\r\npref_sync_ref = "ADAT2";\r\nbreak;\r\ncase HDSP_SYNC_FROM_ADAT3:\r\npref_sync_ref = "ADAT3";\r\nbreak;\r\ndefault:\r\npref_sync_ref = "Word Clock";\r\nbreak;\r\n}\r\nsnd_iprintf (buffer, "Preferred Sync Reference: %s\n", pref_sync_ref);\r\nswitch (hdsp_autosync_ref (hdsp)) {\r\ncase HDSP_AUTOSYNC_FROM_WORD:\r\nautosync_ref = "Word Clock";\r\nbreak;\r\ncase HDSP_AUTOSYNC_FROM_ADAT_SYNC:\r\nautosync_ref = "ADAT Sync";\r\nbreak;\r\ncase HDSP_AUTOSYNC_FROM_SPDIF:\r\nautosync_ref = "SPDIF";\r\nbreak;\r\ncase HDSP_AUTOSYNC_FROM_NONE:\r\nautosync_ref = "None";\r\nbreak;\r\ncase HDSP_AUTOSYNC_FROM_ADAT1:\r\nautosync_ref = "ADAT1";\r\nbreak;\r\ncase HDSP_AUTOSYNC_FROM_ADAT2:\r\nautosync_ref = "ADAT2";\r\nbreak;\r\ncase HDSP_AUTOSYNC_FROM_ADAT3:\r\nautosync_ref = "ADAT3";\r\nbreak;\r\ndefault:\r\nautosync_ref = "---";\r\nbreak;\r\n}\r\nsnd_iprintf (buffer, "AutoSync Reference: %s\n", autosync_ref);\r\nsnd_iprintf (buffer, "AutoSync Frequency: %d\n", hdsp_external_sample_rate(hdsp));\r\nsnd_iprintf (buffer, "System Clock Mode: %s\n", system_clock_mode);\r\nsnd_iprintf (buffer, "System Clock Frequency: %d\n", hdsp->system_sample_rate);\r\nsnd_iprintf (buffer, "System Clock Locked: %s\n", hdsp->clock_source_locked ? "Yes" : "No");\r\nsnd_iprintf(buffer, "\n");\r\nif (hdsp->io_type != RPM) {\r\nswitch (hdsp_spdif_in(hdsp)) {\r\ncase HDSP_SPDIFIN_OPTICAL:\r\nsnd_iprintf(buffer, "IEC958 input: Optical\n");\r\nbreak;\r\ncase HDSP_SPDIFIN_COAXIAL:\r\nsnd_iprintf(buffer, "IEC958 input: Coaxial\n");\r\nbreak;\r\ncase HDSP_SPDIFIN_INTERNAL:\r\nsnd_iprintf(buffer, "IEC958 input: Internal\n");\r\nbreak;\r\ncase HDSP_SPDIFIN_AES:\r\nsnd_iprintf(buffer, "IEC958 input: AES\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "IEC958 input: ???\n");\r\nbreak;\r\n}\r\n}\r\nif (RPM == hdsp->io_type) {\r\nif (hdsp->control_register & HDSP_RPM_Bypass)\r\nsnd_iprintf(buffer, "RPM Bypass: disabled\n");\r\nelse\r\nsnd_iprintf(buffer, "RPM Bypass: enabled\n");\r\nif (hdsp->control_register & HDSP_RPM_Disconnect)\r\nsnd_iprintf(buffer, "RPM disconnected\n");\r\nelse\r\nsnd_iprintf(buffer, "RPM connected\n");\r\nswitch (hdsp->control_register & HDSP_RPM_Inp12) {\r\ncase HDSP_RPM_Inp12_Phon_6dB:\r\nsnd_iprintf(buffer, "Input 1/2: Phono, 6dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp12_Phon_0dB:\r\nsnd_iprintf(buffer, "Input 1/2: Phono, 0dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp12_Phon_n6dB:\r\nsnd_iprintf(buffer, "Input 1/2: Phono, -6dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp12_Line_0dB:\r\nsnd_iprintf(buffer, "Input 1/2: Line, 0dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp12_Line_n6dB:\r\nsnd_iprintf(buffer, "Input 1/2: Line, -6dB\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "Input 1/2: ???\n");\r\n}\r\nswitch (hdsp->control_register & HDSP_RPM_Inp34) {\r\ncase HDSP_RPM_Inp34_Phon_6dB:\r\nsnd_iprintf(buffer, "Input 3/4: Phono, 6dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp34_Phon_0dB:\r\nsnd_iprintf(buffer, "Input 3/4: Phono, 0dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp34_Phon_n6dB:\r\nsnd_iprintf(buffer, "Input 3/4: Phono, -6dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp34_Line_0dB:\r\nsnd_iprintf(buffer, "Input 3/4: Line, 0dB\n");\r\nbreak;\r\ncase HDSP_RPM_Inp34_Line_n6dB:\r\nsnd_iprintf(buffer, "Input 3/4: Line, -6dB\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "Input 3/4: ???\n");\r\n}\r\n} else {\r\nif (hdsp->control_register & HDSP_SPDIFOpticalOut)\r\nsnd_iprintf(buffer, "IEC958 output: Coaxial & ADAT1\n");\r\nelse\r\nsnd_iprintf(buffer, "IEC958 output: Coaxial only\n");\r\nif (hdsp->control_register & HDSP_SPDIFProfessional)\r\nsnd_iprintf(buffer, "IEC958 quality: Professional\n");\r\nelse\r\nsnd_iprintf(buffer, "IEC958 quality: Consumer\n");\r\nif (hdsp->control_register & HDSP_SPDIFEmphasis)\r\nsnd_iprintf(buffer, "IEC958 emphasis: on\n");\r\nelse\r\nsnd_iprintf(buffer, "IEC958 emphasis: off\n");\r\nif (hdsp->control_register & HDSP_SPDIFNonAudio)\r\nsnd_iprintf(buffer, "IEC958 NonAudio: on\n");\r\nelse\r\nsnd_iprintf(buffer, "IEC958 NonAudio: off\n");\r\nx = hdsp_spdif_sample_rate(hdsp);\r\nif (x != 0)\r\nsnd_iprintf(buffer, "IEC958 sample rate: %d\n", x);\r\nelse\r\nsnd_iprintf(buffer, "IEC958 sample rate: Error flag set\n");\r\n}\r\nsnd_iprintf(buffer, "\n");\r\nx = status & HDSP_Sync0;\r\nif (status & HDSP_Lock0)\r\nsnd_iprintf(buffer, "ADAT1: %s\n", x ? "Sync" : "Lock");\r\nelse\r\nsnd_iprintf(buffer, "ADAT1: No Lock\n");\r\nswitch (hdsp->io_type) {\r\ncase Digiface:\r\ncase H9652:\r\nx = status & HDSP_Sync1;\r\nif (status & HDSP_Lock1)\r\nsnd_iprintf(buffer, "ADAT2: %s\n", x ? "Sync" : "Lock");\r\nelse\r\nsnd_iprintf(buffer, "ADAT2: No Lock\n");\r\nx = status & HDSP_Sync2;\r\nif (status & HDSP_Lock2)\r\nsnd_iprintf(buffer, "ADAT3: %s\n", x ? "Sync" : "Lock");\r\nelse\r\nsnd_iprintf(buffer, "ADAT3: No Lock\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nx = status & HDSP_SPDIFSync;\r\nif (status & HDSP_SPDIFErrorFlag)\r\nsnd_iprintf (buffer, "SPDIF: No Lock\n");\r\nelse\r\nsnd_iprintf (buffer, "SPDIF: %s\n", x ? "Sync" : "Lock");\r\nx = status2 & HDSP_wc_sync;\r\nif (status2 & HDSP_wc_lock)\r\nsnd_iprintf (buffer, "Word Clock: %s\n", x ? "Sync" : "Lock");\r\nelse\r\nsnd_iprintf (buffer, "Word Clock: No Lock\n");\r\nx = status & HDSP_TimecodeSync;\r\nif (status & HDSP_TimecodeLock)\r\nsnd_iprintf(buffer, "ADAT Sync: %s\n", x ? "Sync" : "Lock");\r\nelse\r\nsnd_iprintf(buffer, "ADAT Sync: No Lock\n");\r\nsnd_iprintf(buffer, "\n");\r\nif (hdsp->io_type == H9632) {\r\nchar *tmp;\r\nswitch (hdsp_ad_gain(hdsp)) {\r\ncase 0:\r\ntmp = "-10 dBV";\r\nbreak;\r\ncase 1:\r\ntmp = "+4 dBu";\r\nbreak;\r\ndefault:\r\ntmp = "Lo Gain";\r\nbreak;\r\n}\r\nsnd_iprintf(buffer, "AD Gain : %s\n", tmp);\r\nswitch (hdsp_da_gain(hdsp)) {\r\ncase 0:\r\ntmp = "Hi Gain";\r\nbreak;\r\ncase 1:\r\ntmp = "+4 dBu";\r\nbreak;\r\ndefault:\r\ntmp = "-10 dBV";\r\nbreak;\r\n}\r\nsnd_iprintf(buffer, "DA Gain : %s\n", tmp);\r\nswitch (hdsp_phone_gain(hdsp)) {\r\ncase 0:\r\ntmp = "0 dB";\r\nbreak;\r\ncase 1:\r\ntmp = "-6 dB";\r\nbreak;\r\ndefault:\r\ntmp = "-12 dB";\r\nbreak;\r\n}\r\nsnd_iprintf(buffer, "Phones Gain : %s\n", tmp);\r\nsnd_iprintf(buffer, "XLR Breakout Cable : %s\n", hdsp_xlr_breakout_cable(hdsp) ? "yes" : "no");\r\nif (hdsp->control_register & HDSP_AnalogExtensionBoard)\r\nsnd_iprintf(buffer, "AEB : on (ADAT1 internal)\n");\r\nelse\r\nsnd_iprintf(buffer, "AEB : off (ADAT1 external)\n");\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nstatic void snd_hdsp_proc_init(struct hdsp *hdsp)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(hdsp->card, "hdsp", &entry))\r\nsnd_info_set_text_ops(entry, hdsp, snd_hdsp_proc_read);\r\n}\r\nstatic void snd_hdsp_free_buffers(struct hdsp *hdsp)\r\n{\r\nsnd_hammerfall_free_buffer(&hdsp->capture_dma_buf, hdsp->pci);\r\nsnd_hammerfall_free_buffer(&hdsp->playback_dma_buf, hdsp->pci);\r\n}\r\nstatic int __devinit snd_hdsp_initialize_memory(struct hdsp *hdsp)\r\n{\r\nunsigned long pb_bus, cb_bus;\r\nif (snd_hammerfall_get_buffer(hdsp->pci, &hdsp->capture_dma_buf, HDSP_DMA_AREA_BYTES) < 0 ||\r\nsnd_hammerfall_get_buffer(hdsp->pci, &hdsp->playback_dma_buf, HDSP_DMA_AREA_BYTES) < 0) {\r\nif (hdsp->capture_dma_buf.area)\r\nsnd_dma_free_pages(&hdsp->capture_dma_buf);\r\nprintk(KERN_ERR "%s: no buffers available\n", hdsp->card_name);\r\nreturn -ENOMEM;\r\n}\r\ncb_bus = ALIGN(hdsp->capture_dma_buf.addr, 0x10000ul);\r\npb_bus = ALIGN(hdsp->playback_dma_buf.addr, 0x10000ul);\r\nhdsp_write(hdsp, HDSP_inputBufferAddress, cb_bus);\r\nhdsp_write(hdsp, HDSP_outputBufferAddress, pb_bus);\r\nhdsp->capture_buffer = hdsp->capture_dma_buf.area + (cb_bus - hdsp->capture_dma_buf.addr);\r\nhdsp->playback_buffer = hdsp->playback_dma_buf.area + (pb_bus - hdsp->playback_dma_buf.addr);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_set_defaults(struct hdsp *hdsp)\r\n{\r\nunsigned int i;\r\nhdsp->control_register = HDSP_ClockModeMaster |\r\nHDSP_SPDIFInputCoaxial |\r\nhdsp_encode_latency(7) |\r\nHDSP_LineOut;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\n#ifdef SNDRV_BIG_ENDIAN\r\nhdsp->control2_register = HDSP_BIGENDIAN_MODE;\r\n#else\r\nhdsp->control2_register = 0;\r\n#endif\r\nif (hdsp->io_type == H9652)\r\nsnd_hdsp_9652_enable_mixer (hdsp);\r\nelse\r\nhdsp_write (hdsp, HDSP_control2Reg, hdsp->control2_register);\r\nhdsp_reset_hw_pointer(hdsp);\r\nhdsp_compute_period_size(hdsp);\r\nfor (i = 0; i < HDSP_MATRIX_MIXER_SIZE; ++i)\r\nhdsp->mixer_matrix[i] = MINUS_INFINITY_GAIN;\r\nfor (i = 0; i < ((hdsp->io_type == H9652 || hdsp->io_type == H9632) ? 1352 : HDSP_MATRIX_MIXER_SIZE); ++i) {\r\nif (hdsp_write_gain (hdsp, i, MINUS_INFINITY_GAIN))\r\nreturn -EIO;\r\n}\r\nif (hdsp->io_type == H9632) {\r\nhdsp->control_register |= (HDSP_DAGainPlus4dBu | HDSP_ADGainPlus4dBu | HDSP_PhoneGain0dB);\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\n}\r\nhdsp_set_rate(hdsp, 48000, 1);\r\nreturn 0;\r\n}\r\nstatic void hdsp_midi_tasklet(unsigned long arg)\r\n{\r\nstruct hdsp *hdsp = (struct hdsp *)arg;\r\nif (hdsp->midi[0].pending)\r\nsnd_hdsp_midi_input_read (&hdsp->midi[0]);\r\nif (hdsp->midi[1].pending)\r\nsnd_hdsp_midi_input_read (&hdsp->midi[1]);\r\n}\r\nstatic irqreturn_t snd_hdsp_interrupt(int irq, void *dev_id)\r\n{\r\nstruct hdsp *hdsp = (struct hdsp *) dev_id;\r\nunsigned int status;\r\nint audio;\r\nint midi0;\r\nint midi1;\r\nunsigned int midi0status;\r\nunsigned int midi1status;\r\nint schedule = 0;\r\nstatus = hdsp_read(hdsp, HDSP_statusRegister);\r\naudio = status & HDSP_audioIRQPending;\r\nmidi0 = status & HDSP_midi0IRQPending;\r\nmidi1 = status & HDSP_midi1IRQPending;\r\nif (!audio && !midi0 && !midi1)\r\nreturn IRQ_NONE;\r\nhdsp_write(hdsp, HDSP_interruptConfirmation, 0);\r\nmidi0status = hdsp_read (hdsp, HDSP_midiStatusIn0) & 0xff;\r\nmidi1status = hdsp_read (hdsp, HDSP_midiStatusIn1) & 0xff;\r\nif (!(hdsp->state & HDSP_InitializationComplete))\r\nreturn IRQ_HANDLED;\r\nif (audio) {\r\nif (hdsp->capture_substream)\r\nsnd_pcm_period_elapsed(hdsp->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\r\nif (hdsp->playback_substream)\r\nsnd_pcm_period_elapsed(hdsp->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);\r\n}\r\nif (midi0 && midi0status) {\r\nif (hdsp->use_midi_tasklet) {\r\nhdsp->control_register &= ~HDSP_Midi0InterruptEnable;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nhdsp->midi[0].pending = 1;\r\nschedule = 1;\r\n} else {\r\nsnd_hdsp_midi_input_read (&hdsp->midi[0]);\r\n}\r\n}\r\nif (hdsp->io_type != Multiface && hdsp->io_type != RPM && hdsp->io_type != H9632 && midi1 && midi1status) {\r\nif (hdsp->use_midi_tasklet) {\r\nhdsp->control_register &= ~HDSP_Midi1InterruptEnable;\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register);\r\nhdsp->midi[1].pending = 1;\r\nschedule = 1;\r\n} else {\r\nsnd_hdsp_midi_input_read (&hdsp->midi[1]);\r\n}\r\n}\r\nif (hdsp->use_midi_tasklet && schedule)\r\ntasklet_schedule(&hdsp->midi_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_hdsp_hw_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nreturn hdsp_hw_pointer(hdsp);\r\n}\r\nstatic char *hdsp_channel_buffer_location(struct hdsp *hdsp,\r\nint stream,\r\nint channel)\r\n{\r\nint mapped_channel;\r\nif (snd_BUG_ON(channel < 0 || channel >= hdsp->max_channels))\r\nreturn NULL;\r\nif ((mapped_channel = hdsp->channel_map[channel]) < 0)\r\nreturn NULL;\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE)\r\nreturn hdsp->capture_buffer + (mapped_channel * HDSP_CHANNEL_BUFFER_BYTES);\r\nelse\r\nreturn hdsp->playback_buffer + (mapped_channel * HDSP_CHANNEL_BUFFER_BYTES);\r\n}\r\nstatic int snd_hdsp_playback_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, void __user *src, snd_pcm_uframes_t count)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nchar *channel_buf;\r\nif (snd_BUG_ON(pos + count > HDSP_CHANNEL_BUFFER_BYTES / 4))\r\nreturn -EINVAL;\r\nchannel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);\r\nif (snd_BUG_ON(!channel_buf))\r\nreturn -EIO;\r\nif (copy_from_user(channel_buf + pos * 4, src, count * 4))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic int snd_hdsp_capture_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, void __user *dst, snd_pcm_uframes_t count)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nchar *channel_buf;\r\nif (snd_BUG_ON(pos + count > HDSP_CHANNEL_BUFFER_BYTES / 4))\r\nreturn -EINVAL;\r\nchannel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);\r\nif (snd_BUG_ON(!channel_buf))\r\nreturn -EIO;\r\nif (copy_to_user(dst, channel_buf + pos * 4, count * 4))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic int snd_hdsp_hw_silence(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, snd_pcm_uframes_t count)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nchar *channel_buf;\r\nchannel_buf = hdsp_channel_buffer_location (hdsp, substream->pstr->stream, channel);\r\nif (snd_BUG_ON(!channel_buf))\r\nreturn -EIO;\r\nmemset(channel_buf + pos * 4, 0, count * 4);\r\nreturn count;\r\n}\r\nstatic int snd_hdsp_reset(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *other;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nother = hdsp->capture_substream;\r\nelse\r\nother = hdsp->playback_substream;\r\nif (hdsp->running)\r\nruntime->status->hw_ptr = hdsp_hw_pointer(hdsp);\r\nelse\r\nruntime->status->hw_ptr = 0;\r\nif (other) {\r\nstruct snd_pcm_substream *s;\r\nstruct snd_pcm_runtime *oruntime = other->runtime;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == other) {\r\noruntime->status->hw_ptr = runtime->status->hw_ptr;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nint err;\r\npid_t this_pid;\r\npid_t other_pid;\r\nif (hdsp_check_for_iobox (hdsp))\r\nreturn -EIO;\r\nif (hdsp_check_for_firmware(hdsp, 1))\r\nreturn -EIO;\r\nspin_lock_irq(&hdsp->lock);\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nhdsp->control_register &= ~(HDSP_SPDIFProfessional | HDSP_SPDIFNonAudio | HDSP_SPDIFEmphasis);\r\nhdsp_write(hdsp, HDSP_controlRegister, hdsp->control_register |= hdsp->creg_spdif_stream);\r\nthis_pid = hdsp->playback_pid;\r\nother_pid = hdsp->capture_pid;\r\n} else {\r\nthis_pid = hdsp->capture_pid;\r\nother_pid = hdsp->playback_pid;\r\n}\r\nif ((other_pid > 0) && (this_pid != other_pid)) {\r\nif (params_rate(params) != hdsp->system_sample_rate) {\r\nspin_unlock_irq(&hdsp->lock);\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\r\nreturn -EBUSY;\r\n}\r\nif (params_period_size(params) != hdsp->period_bytes / 4) {\r\nspin_unlock_irq(&hdsp->lock);\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn 0;\r\n} else {\r\nspin_unlock_irq(&hdsp->lock);\r\n}\r\nspin_lock_irq(&hdsp->lock);\r\nif (! hdsp->clock_source_locked) {\r\nif ((err = hdsp_set_rate(hdsp, params_rate(params), 0)) < 0) {\r\nspin_unlock_irq(&hdsp->lock);\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\r\nreturn err;\r\n}\r\n}\r\nspin_unlock_irq(&hdsp->lock);\r\nif ((err = hdsp_set_interrupt_interval(hdsp, params_period_size(params))) < 0) {\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_channel_info(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_channel_info *info)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nint mapped_channel;\r\nif (snd_BUG_ON(info->channel >= hdsp->max_channels))\r\nreturn -EINVAL;\r\nif ((mapped_channel = hdsp->channel_map[info->channel]) < 0)\r\nreturn -EINVAL;\r\ninfo->offset = mapped_channel * HDSP_CHANNEL_BUFFER_BYTES;\r\ninfo->first = 0;\r\ninfo->step = 32;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL1_RESET:\r\nreturn snd_hdsp_reset(substream);\r\ncase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\r\nreturn snd_hdsp_channel_info(substream, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int snd_hdsp_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *other;\r\nint running;\r\nif (hdsp_check_for_iobox (hdsp))\r\nreturn -EIO;\r\nif (hdsp_check_for_firmware(hdsp, 0))\r\nreturn -EIO;\r\nspin_lock(&hdsp->lock);\r\nrunning = hdsp->running;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nrunning |= 1 << substream->stream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nrunning &= ~(1 << substream->stream);\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nspin_unlock(&hdsp->lock);\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nother = hdsp->capture_substream;\r\nelse\r\nother = hdsp->playback_substream;\r\nif (other) {\r\nstruct snd_pcm_substream *s;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == other) {\r\nsnd_pcm_trigger_done(s, substream);\r\nif (cmd == SNDRV_PCM_TRIGGER_START)\r\nrunning |= 1 << s->stream;\r\nelse\r\nrunning &= ~(1 << s->stream);\r\ngoto _ok;\r\n}\r\n}\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nif (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) &&\r\nsubstream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nhdsp_silence_playback(hdsp);\r\n} else {\r\nif (running &&\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nhdsp_silence_playback(hdsp);\r\n}\r\n} else {\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nhdsp_silence_playback(hdsp);\r\n}\r\n_ok:\r\nsnd_pcm_trigger_done(substream, substream);\r\nif (!hdsp->running && running)\r\nhdsp_start_audio(hdsp);\r\nelse if (hdsp->running && !running)\r\nhdsp_stop_audio(hdsp);\r\nhdsp->running = running;\r\nspin_unlock(&hdsp->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nif (hdsp_check_for_iobox (hdsp))\r\nreturn -EIO;\r\nif (hdsp_check_for_firmware(hdsp, 1))\r\nreturn -EIO;\r\nspin_lock_irq(&hdsp->lock);\r\nif (!hdsp->running)\r\nhdsp_reset_hw_pointer(hdsp);\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn result;\r\n}\r\nstatic int snd_hdsp_hw_rule_in_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct hdsp *hdsp = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (hdsp->io_type == H9632) {\r\nunsigned int list[3];\r\nlist[0] = hdsp->qs_in_channels;\r\nlist[1] = hdsp->ds_in_channels;\r\nlist[2] = hdsp->ss_in_channels;\r\nreturn snd_interval_list(c, 3, list, 0);\r\n} else {\r\nunsigned int list[2];\r\nlist[0] = hdsp->ds_in_channels;\r\nlist[1] = hdsp->ss_in_channels;\r\nreturn snd_interval_list(c, 2, list, 0);\r\n}\r\n}\r\nstatic int snd_hdsp_hw_rule_out_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int list[3];\r\nstruct hdsp *hdsp = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (hdsp->io_type == H9632) {\r\nlist[0] = hdsp->qs_out_channels;\r\nlist[1] = hdsp->ds_out_channels;\r\nlist[2] = hdsp->ss_out_channels;\r\nreturn snd_interval_list(c, 3, list, 0);\r\n} else {\r\nlist[0] = hdsp->ds_out_channels;\r\nlist[1] = hdsp->ss_out_channels;\r\n}\r\nreturn snd_interval_list(c, 2, list, 0);\r\n}\r\nstatic int snd_hdsp_hw_rule_in_channels_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct hdsp *hdsp = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (r->min > 96000 && hdsp->io_type == H9632) {\r\nstruct snd_interval t = {\r\n.min = hdsp->qs_in_channels,\r\n.max = hdsp->qs_in_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->min > 48000 && r->max <= 96000) {\r\nstruct snd_interval t = {\r\n.min = hdsp->ds_in_channels,\r\n.max = hdsp->ds_in_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->max < 64000) {\r\nstruct snd_interval t = {\r\n.min = hdsp->ss_in_channels,\r\n.max = hdsp->ss_in_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_hw_rule_out_channels_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct hdsp *hdsp = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (r->min > 96000 && hdsp->io_type == H9632) {\r\nstruct snd_interval t = {\r\n.min = hdsp->qs_out_channels,\r\n.max = hdsp->qs_out_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->min > 48000 && r->max <= 96000) {\r\nstruct snd_interval t = {\r\n.min = hdsp->ds_out_channels,\r\n.max = hdsp->ds_out_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->max < 64000) {\r\nstruct snd_interval t = {\r\n.min = hdsp->ss_out_channels,\r\n.max = hdsp->ss_out_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_hw_rule_rate_out_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct hdsp *hdsp = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (c->min >= hdsp->ss_out_channels) {\r\nstruct snd_interval t = {\r\n.min = 32000,\r\n.max = 48000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdsp->qs_out_channels && hdsp->io_type == H9632) {\r\nstruct snd_interval t = {\r\n.min = 128000,\r\n.max = 192000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdsp->ds_out_channels) {\r\nstruct snd_interval t = {\r\n.min = 64000,\r\n.max = 96000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_hw_rule_rate_in_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct hdsp *hdsp = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (c->min >= hdsp->ss_in_channels) {\r\nstruct snd_interval t = {\r\n.min = 32000,\r\n.max = 48000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdsp->qs_in_channels && hdsp->io_type == H9632) {\r\nstruct snd_interval t = {\r\n.min = 128000,\r\n.max = 192000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdsp->ds_in_channels) {\r\nstruct snd_interval t = {\r\n.min = 64000,\r\n.max = 96000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (hdsp_check_for_iobox (hdsp))\r\nreturn -EIO;\r\nif (hdsp_check_for_firmware(hdsp, 1))\r\nreturn -EIO;\r\nspin_lock_irq(&hdsp->lock);\r\nsnd_pcm_set_sync(substream);\r\nruntime->hw = snd_hdsp_playback_subinfo;\r\nruntime->dma_area = hdsp->playback_buffer;\r\nruntime->dma_bytes = HDSP_DMA_AREA_BYTES;\r\nhdsp->playback_pid = current->pid;\r\nhdsp->playback_substream = substream;\r\nspin_unlock_irq(&hdsp->lock);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hdsp_hw_constraints_period_sizes);\r\nif (hdsp->clock_source_locked) {\r\nruntime->hw.rate_min = runtime->hw.rate_max = hdsp->system_sample_rate;\r\n} else if (hdsp->io_type == H9632) {\r\nruntime->hw.rate_max = 192000;\r\nruntime->hw.rates = SNDRV_PCM_RATE_KNOT;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hdsp_hw_constraints_9632_sample_rates);\r\n}\r\nif (hdsp->io_type == H9632) {\r\nruntime->hw.channels_min = hdsp->qs_out_channels;\r\nruntime->hw.channels_max = hdsp->ss_out_channels;\r\n}\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdsp_hw_rule_out_channels, hdsp,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdsp_hw_rule_out_channels_rate, hdsp,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_hdsp_hw_rule_rate_out_channels, hdsp,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (RPM != hdsp->io_type) {\r\nhdsp->creg_spdif_stream = hdsp->creg_spdif;\r\nhdsp->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(hdsp->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &hdsp->spdif_ctl->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_playback_release(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&hdsp->lock);\r\nhdsp->playback_pid = -1;\r\nhdsp->playback_substream = NULL;\r\nspin_unlock_irq(&hdsp->lock);\r\nif (RPM != hdsp->io_type) {\r\nhdsp->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(hdsp->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &hdsp->spdif_ctl->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (hdsp_check_for_iobox (hdsp))\r\nreturn -EIO;\r\nif (hdsp_check_for_firmware(hdsp, 1))\r\nreturn -EIO;\r\nspin_lock_irq(&hdsp->lock);\r\nsnd_pcm_set_sync(substream);\r\nruntime->hw = snd_hdsp_capture_subinfo;\r\nruntime->dma_area = hdsp->capture_buffer;\r\nruntime->dma_bytes = HDSP_DMA_AREA_BYTES;\r\nhdsp->capture_pid = current->pid;\r\nhdsp->capture_substream = substream;\r\nspin_unlock_irq(&hdsp->lock);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hdsp_hw_constraints_period_sizes);\r\nif (hdsp->io_type == H9632) {\r\nruntime->hw.channels_min = hdsp->qs_in_channels;\r\nruntime->hw.channels_max = hdsp->ss_in_channels;\r\nruntime->hw.rate_max = 192000;\r\nruntime->hw.rates = SNDRV_PCM_RATE_KNOT;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hdsp_hw_constraints_9632_sample_rates);\r\n}\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdsp_hw_rule_in_channels, hdsp,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdsp_hw_rule_in_channels_rate, hdsp,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_hdsp_hw_rule_rate_in_channels, hdsp,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_capture_release(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdsp *hdsp = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&hdsp->lock);\r\nhdsp->capture_pid = -1;\r\nhdsp->capture_substream = NULL;\r\nspin_unlock_irq(&hdsp->lock);\r\nreturn 0;\r\n}\r\nstatic inline int copy_u32_le(void __user *dest, void __iomem *src)\r\n{\r\nu32 val = readl(src);\r\nreturn copy_to_user(dest, &val, 4);\r\n}\r\nstatic inline int copy_u64_le(void __user *dest, void __iomem *src_low, void __iomem *src_high)\r\n{\r\nu32 rms_low, rms_high;\r\nu64 rms;\r\nrms_low = readl(src_low);\r\nrms_high = readl(src_high);\r\nrms = ((u64)rms_high << 32) | rms_low;\r\nreturn copy_to_user(dest, &rms, 8);\r\n}\r\nstatic inline int copy_u48_le(void __user *dest, void __iomem *src_low, void __iomem *src_high)\r\n{\r\nu32 rms_low, rms_high;\r\nu64 rms;\r\nrms_low = readl(src_low) & 0xffffff00;\r\nrms_high = readl(src_high) & 0xffffff00;\r\nrms = ((u64)rms_high << 32) | rms_low;\r\nreturn copy_to_user(dest, &rms, 8);\r\n}\r\nstatic int hdsp_9652_get_peak(struct hdsp *hdsp, struct hdsp_peak_rms __user *peak_rms)\r\n{\r\nint doublespeed = 0;\r\nint i, j, channels, ofs;\r\nif (hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DoubleSpeedStatus)\r\ndoublespeed = 1;\r\nchannels = doublespeed ? 14 : 26;\r\nfor (i = 0, j = 0; i < 26; ++i) {\r\nif (doublespeed && (i & 4))\r\ncontinue;\r\nofs = HDSP_9652_peakBase - j * 4;\r\nif (copy_u32_le(&peak_rms->input_peaks[i], hdsp->iobase + ofs))\r\nreturn -EFAULT;\r\nofs -= channels * 4;\r\nif (copy_u32_le(&peak_rms->playback_peaks[i], hdsp->iobase + ofs))\r\nreturn -EFAULT;\r\nofs -= channels * 4;\r\nif (copy_u32_le(&peak_rms->output_peaks[i], hdsp->iobase + ofs))\r\nreturn -EFAULT;\r\nofs = HDSP_9652_rmsBase + j * 8;\r\nif (copy_u48_le(&peak_rms->input_rms[i], hdsp->iobase + ofs,\r\nhdsp->iobase + ofs + 4))\r\nreturn -EFAULT;\r\nofs += channels * 8;\r\nif (copy_u48_le(&peak_rms->playback_rms[i], hdsp->iobase + ofs,\r\nhdsp->iobase + ofs + 4))\r\nreturn -EFAULT;\r\nofs += channels * 8;\r\nif (copy_u48_le(&peak_rms->output_rms[i], hdsp->iobase + ofs,\r\nhdsp->iobase + ofs + 4))\r\nreturn -EFAULT;\r\nj++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_9632_get_peak(struct hdsp *hdsp, struct hdsp_peak_rms __user *peak_rms)\r\n{\r\nint i, j;\r\nstruct hdsp_9632_meters __iomem *m;\r\nint doublespeed = 0;\r\nif (hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DoubleSpeedStatus)\r\ndoublespeed = 1;\r\nm = (struct hdsp_9632_meters __iomem *)(hdsp->iobase+HDSP_9632_metersBase);\r\nfor (i = 0, j = 0; i < 16; ++i, ++j) {\r\nif (copy_u32_le(&peak_rms->input_peaks[i], &m->input_peak[j]))\r\nreturn -EFAULT;\r\nif (copy_u32_le(&peak_rms->playback_peaks[i], &m->playback_peak[j]))\r\nreturn -EFAULT;\r\nif (copy_u32_le(&peak_rms->output_peaks[i], &m->output_peak[j]))\r\nreturn -EFAULT;\r\nif (copy_u64_le(&peak_rms->input_rms[i], &m->input_rms_low[j],\r\n&m->input_rms_high[j]))\r\nreturn -EFAULT;\r\nif (copy_u64_le(&peak_rms->playback_rms[i], &m->playback_rms_low[j],\r\n&m->playback_rms_high[j]))\r\nreturn -EFAULT;\r\nif (copy_u64_le(&peak_rms->output_rms[i], &m->output_rms_low[j],\r\n&m->output_rms_high[j]))\r\nreturn -EFAULT;\r\nif (doublespeed && i == 3) i += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_get_peak(struct hdsp *hdsp, struct hdsp_peak_rms __user *peak_rms)\r\n{\r\nint i;\r\nfor (i = 0; i < 26; i++) {\r\nif (copy_u32_le(&peak_rms->playback_peaks[i],\r\nhdsp->iobase + HDSP_playbackPeakLevel + i * 4))\r\nreturn -EFAULT;\r\nif (copy_u32_le(&peak_rms->input_peaks[i],\r\nhdsp->iobase + HDSP_inputPeakLevel + i * 4))\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < 28; i++) {\r\nif (copy_u32_le(&peak_rms->output_peaks[i],\r\nhdsp->iobase + HDSP_outputPeakLevel + i * 4))\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < 26; ++i) {\r\nif (copy_u64_le(&peak_rms->playback_rms[i],\r\nhdsp->iobase + HDSP_playbackRmsLevel + i * 8 + 4,\r\nhdsp->iobase + HDSP_playbackRmsLevel + i * 8))\r\nreturn -EFAULT;\r\nif (copy_u64_le(&peak_rms->input_rms[i],\r\nhdsp->iobase + HDSP_inputRmsLevel + i * 8 + 4,\r\nhdsp->iobase + HDSP_inputRmsLevel + i * 8))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_hwdep_ioctl(struct snd_hwdep *hw, struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct hdsp *hdsp = hw->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint err;\r\nswitch (cmd) {\r\ncase SNDRV_HDSP_IOCTL_GET_PEAK_RMS: {\r\nstruct hdsp_peak_rms __user *peak_rms = (struct hdsp_peak_rms __user *)arg;\r\nerr = hdsp_check_for_iobox(hdsp);\r\nif (err < 0)\r\nreturn err;\r\nerr = hdsp_check_for_firmware(hdsp, 1);\r\nif (err < 0)\r\nreturn err;\r\nif (!(hdsp->state & HDSP_FirmwareLoaded)) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: firmware needs to be uploaded to the card.\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (hdsp->io_type) {\r\ncase H9652:\r\nreturn hdsp_9652_get_peak(hdsp, peak_rms);\r\ncase H9632:\r\nreturn hdsp_9632_get_peak(hdsp, peak_rms);\r\ndefault:\r\nreturn hdsp_get_peak(hdsp, peak_rms);\r\n}\r\n}\r\ncase SNDRV_HDSP_IOCTL_GET_CONFIG_INFO: {\r\nstruct hdsp_config_info info;\r\nunsigned long flags;\r\nint i;\r\nerr = hdsp_check_for_iobox(hdsp);\r\nif (err < 0)\r\nreturn err;\r\nerr = hdsp_check_for_firmware(hdsp, 1);\r\nif (err < 0)\r\nreturn err;\r\nmemset(&info, 0, sizeof(info));\r\nspin_lock_irqsave(&hdsp->lock, flags);\r\ninfo.pref_sync_ref = (unsigned char)hdsp_pref_sync_ref(hdsp);\r\ninfo.wordclock_sync_check = (unsigned char)hdsp_wc_sync_check(hdsp);\r\nif (hdsp->io_type != H9632)\r\ninfo.adatsync_sync_check = (unsigned char)hdsp_adatsync_sync_check(hdsp);\r\ninfo.spdif_sync_check = (unsigned char)hdsp_spdif_sync_check(hdsp);\r\nfor (i = 0; i < ((hdsp->io_type != Multiface && hdsp->io_type != RPM && hdsp->io_type != H9632) ? 3 : 1); ++i)\r\ninfo.adat_sync_check[i] = (unsigned char)hdsp_adat_sync_check(hdsp, i);\r\ninfo.spdif_in = (unsigned char)hdsp_spdif_in(hdsp);\r\ninfo.spdif_out = (unsigned char)hdsp_spdif_out(hdsp);\r\ninfo.spdif_professional = (unsigned char)hdsp_spdif_professional(hdsp);\r\ninfo.spdif_emphasis = (unsigned char)hdsp_spdif_emphasis(hdsp);\r\ninfo.spdif_nonaudio = (unsigned char)hdsp_spdif_nonaudio(hdsp);\r\ninfo.spdif_sample_rate = hdsp_spdif_sample_rate(hdsp);\r\ninfo.system_sample_rate = hdsp->system_sample_rate;\r\ninfo.autosync_sample_rate = hdsp_external_sample_rate(hdsp);\r\ninfo.system_clock_mode = (unsigned char)hdsp_system_clock_mode(hdsp);\r\ninfo.clock_source = (unsigned char)hdsp_clock_source(hdsp);\r\ninfo.autosync_ref = (unsigned char)hdsp_autosync_ref(hdsp);\r\ninfo.line_out = (unsigned char)hdsp_line_out(hdsp);\r\nif (hdsp->io_type == H9632) {\r\ninfo.da_gain = (unsigned char)hdsp_da_gain(hdsp);\r\ninfo.ad_gain = (unsigned char)hdsp_ad_gain(hdsp);\r\ninfo.phone_gain = (unsigned char)hdsp_phone_gain(hdsp);\r\ninfo.xlr_breakout_cable = (unsigned char)hdsp_xlr_breakout_cable(hdsp);\r\n} else if (hdsp->io_type == RPM) {\r\ninfo.da_gain = (unsigned char) hdsp_rpm_input12(hdsp);\r\ninfo.ad_gain = (unsigned char) hdsp_rpm_input34(hdsp);\r\n}\r\nif (hdsp->io_type == H9632 || hdsp->io_type == H9652)\r\ninfo.analog_extension_board = (unsigned char)hdsp_aeb(hdsp);\r\nspin_unlock_irqrestore(&hdsp->lock, flags);\r\nif (copy_to_user(argp, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase SNDRV_HDSP_IOCTL_GET_9632_AEB: {\r\nstruct hdsp_9632_aeb h9632_aeb;\r\nif (hdsp->io_type != H9632) return -EINVAL;\r\nh9632_aeb.aebi = hdsp->ss_in_channels - H9632_SS_CHANNELS;\r\nh9632_aeb.aebo = hdsp->ss_out_channels - H9632_SS_CHANNELS;\r\nif (copy_to_user(argp, &h9632_aeb, sizeof(h9632_aeb)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase SNDRV_HDSP_IOCTL_GET_VERSION: {\r\nstruct hdsp_version hdsp_version;\r\nint err;\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\r\nif (hdsp->io_type == Undefined) {\r\nif ((err = hdsp_get_iobox_version(hdsp)) < 0)\r\nreturn err;\r\n}\r\nhdsp_version.io_type = hdsp->io_type;\r\nhdsp_version.firmware_rev = hdsp->firmware_rev;\r\nif ((err = copy_to_user(argp, &hdsp_version, sizeof(hdsp_version))))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE: {\r\nstruct hdsp_firmware __user *firmware;\r\nu32 __user *firmware_data;\r\nint err;\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\r\nif (hdsp->io_type == Undefined) return -EINVAL;\r\nif (hdsp->state & (HDSP_FirmwareCached | HDSP_FirmwareLoaded))\r\nreturn -EBUSY;\r\nsnd_printk(KERN_INFO "Hammerfall-DSP: initializing firmware upload\n");\r\nfirmware = (struct hdsp_firmware __user *)argp;\r\nif (get_user(firmware_data, &firmware->firmware_data))\r\nreturn -EFAULT;\r\nif (hdsp_check_for_iobox (hdsp))\r\nreturn -EIO;\r\nif (copy_from_user(hdsp->firmware_cache, firmware_data, sizeof(hdsp->firmware_cache)) != 0)\r\nreturn -EFAULT;\r\nhdsp->state |= HDSP_FirmwareCached;\r\nif ((err = snd_hdsp_load_firmware_from_cache(hdsp)) < 0)\r\nreturn err;\r\nif (!(hdsp->state & HDSP_InitializationComplete)) {\r\nif ((err = snd_hdsp_enable_io(hdsp)) < 0)\r\nreturn err;\r\nsnd_hdsp_initialize_channels(hdsp);\r\nsnd_hdsp_initialize_midi_flush(hdsp);\r\nif ((err = snd_hdsp_create_alsa_devices(hdsp->card, hdsp)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: error creating alsa devices\n");\r\nreturn err;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase SNDRV_HDSP_IOCTL_GET_MIXER: {\r\nstruct hdsp_mixer __user *mixer = (struct hdsp_mixer __user *)argp;\r\nif (copy_to_user(mixer->matrix, hdsp->mixer_matrix, sizeof(unsigned short)*HDSP_MATRIX_MIXER_SIZE))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_create_hwdep(struct snd_card *card, struct hdsp *hdsp)\r\n{\r\nstruct snd_hwdep *hw;\r\nint err;\r\nif ((err = snd_hwdep_new(card, "HDSP hwdep", 0, &hw)) < 0)\r\nreturn err;\r\nhdsp->hwdep = hw;\r\nhw->private_data = hdsp;\r\nstrcpy(hw->name, "HDSP hwdep interface");\r\nhw->ops.ioctl = snd_hdsp_hwdep_ioctl;\r\nhw->ops.ioctl_compat = snd_hdsp_hwdep_ioctl;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_create_pcm(struct snd_card *card, struct hdsp *hdsp)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(card, hdsp->card_name, 0, 1, 1, &pcm)) < 0)\r\nreturn err;\r\nhdsp->pcm = pcm;\r\npcm->private_data = hdsp;\r\nstrcpy(pcm->name, hdsp->card_name);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_hdsp_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_hdsp_capture_ops);\r\npcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nreturn 0;\r\n}\r\nstatic void snd_hdsp_9652_enable_mixer (struct hdsp *hdsp)\r\n{\r\nhdsp->control2_register |= HDSP_9652_ENABLE_MIXER;\r\nhdsp_write (hdsp, HDSP_control2Reg, hdsp->control2_register);\r\n}\r\nstatic int snd_hdsp_enable_io (struct hdsp *hdsp)\r\n{\r\nint i;\r\nif (hdsp_fifo_wait (hdsp, 0, 100)) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: enable_io fifo_wait failed\n");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < hdsp->max_channels; ++i) {\r\nhdsp_write (hdsp, HDSP_inputEnable + (4 * i), 1);\r\nhdsp_write (hdsp, HDSP_outputEnable + (4 * i), 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_hdsp_initialize_channels(struct hdsp *hdsp)\r\n{\r\nint status, aebi_channels, aebo_channels;\r\nswitch (hdsp->io_type) {\r\ncase Digiface:\r\nhdsp->card_name = "RME Hammerfall DSP + Digiface";\r\nhdsp->ss_in_channels = hdsp->ss_out_channels = DIGIFACE_SS_CHANNELS;\r\nhdsp->ds_in_channels = hdsp->ds_out_channels = DIGIFACE_DS_CHANNELS;\r\nbreak;\r\ncase H9652:\r\nhdsp->card_name = "RME Hammerfall HDSP 9652";\r\nhdsp->ss_in_channels = hdsp->ss_out_channels = H9652_SS_CHANNELS;\r\nhdsp->ds_in_channels = hdsp->ds_out_channels = H9652_DS_CHANNELS;\r\nbreak;\r\ncase H9632:\r\nstatus = hdsp_read(hdsp, HDSP_statusRegister);\r\naebi_channels = (status & HDSP_AEBI) ? 0 : 4;\r\naebo_channels = (status & HDSP_AEBO) ? 0 : 4;\r\nhdsp->card_name = "RME Hammerfall HDSP 9632";\r\nhdsp->ss_in_channels = H9632_SS_CHANNELS+aebi_channels;\r\nhdsp->ds_in_channels = H9632_DS_CHANNELS+aebi_channels;\r\nhdsp->qs_in_channels = H9632_QS_CHANNELS+aebi_channels;\r\nhdsp->ss_out_channels = H9632_SS_CHANNELS+aebo_channels;\r\nhdsp->ds_out_channels = H9632_DS_CHANNELS+aebo_channels;\r\nhdsp->qs_out_channels = H9632_QS_CHANNELS+aebo_channels;\r\nbreak;\r\ncase Multiface:\r\nhdsp->card_name = "RME Hammerfall DSP + Multiface";\r\nhdsp->ss_in_channels = hdsp->ss_out_channels = MULTIFACE_SS_CHANNELS;\r\nhdsp->ds_in_channels = hdsp->ds_out_channels = MULTIFACE_DS_CHANNELS;\r\nbreak;\r\ncase RPM:\r\nhdsp->card_name = "RME Hammerfall DSP + RPM";\r\nhdsp->ss_in_channels = RPM_CHANNELS-1;\r\nhdsp->ss_out_channels = RPM_CHANNELS;\r\nhdsp->ds_in_channels = RPM_CHANNELS-1;\r\nhdsp->ds_out_channels = RPM_CHANNELS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void snd_hdsp_initialize_midi_flush (struct hdsp *hdsp)\r\n{\r\nsnd_hdsp_flush_midi_input (hdsp, 0);\r\nsnd_hdsp_flush_midi_input (hdsp, 1);\r\n}\r\nstatic int snd_hdsp_create_alsa_devices(struct snd_card *card, struct hdsp *hdsp)\r\n{\r\nint err;\r\nif ((err = snd_hdsp_create_pcm(card, hdsp)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: Error creating pcm interface\n");\r\nreturn err;\r\n}\r\nif ((err = snd_hdsp_create_midi(card, hdsp, 0)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: Error creating first midi interface\n");\r\nreturn err;\r\n}\r\nif (hdsp->io_type == Digiface || hdsp->io_type == H9652) {\r\nif ((err = snd_hdsp_create_midi(card, hdsp, 1)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: Error creating second midi interface\n");\r\nreturn err;\r\n}\r\n}\r\nif ((err = snd_hdsp_create_controls(card, hdsp)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: Error creating ctl interface\n");\r\nreturn err;\r\n}\r\nsnd_hdsp_proc_init(hdsp);\r\nhdsp->system_sample_rate = -1;\r\nhdsp->playback_pid = -1;\r\nhdsp->capture_pid = -1;\r\nhdsp->capture_substream = NULL;\r\nhdsp->playback_substream = NULL;\r\nif ((err = snd_hdsp_set_defaults(hdsp)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: Error setting default values\n");\r\nreturn err;\r\n}\r\nif (!(hdsp->state & HDSP_InitializationComplete)) {\r\nstrcpy(card->shortname, "Hammerfall DSP");\r\nsprintf(card->longname, "%s at 0x%lx, irq %d", hdsp->card_name,\r\nhdsp->port, hdsp->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: error registering card\n");\r\nreturn err;\r\n}\r\nhdsp->state |= HDSP_InitializationComplete;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdsp_request_fw_loader(struct hdsp *hdsp)\r\n{\r\nconst char *fwfile;\r\nconst struct firmware *fw;\r\nint err;\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\r\nreturn 0;\r\nif (hdsp->io_type == Undefined) {\r\nif ((err = hdsp_get_iobox_version(hdsp)) < 0)\r\nreturn err;\r\nif (hdsp->io_type == H9652 || hdsp->io_type == H9632)\r\nreturn 0;\r\n}\r\nswitch (hdsp->io_type) {\r\ncase RPM:\r\nfwfile = "rpm_firmware.bin";\r\nbreak;\r\ncase Multiface:\r\nif (hdsp->firmware_rev == 0xa)\r\nfwfile = "multiface_firmware.bin";\r\nelse\r\nfwfile = "multiface_firmware_rev11.bin";\r\nbreak;\r\ncase Digiface:\r\nif (hdsp->firmware_rev == 0xa)\r\nfwfile = "digiface_firmware.bin";\r\nelse\r\nfwfile = "digiface_firmware_rev11.bin";\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: invalid io_type %d\n", hdsp->io_type);\r\nreturn -EINVAL;\r\n}\r\nif (request_firmware(&fw, fwfile, &hdsp->pci->dev)) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: cannot load firmware %s\n", fwfile);\r\nreturn -ENOENT;\r\n}\r\nif (fw->size < sizeof(hdsp->firmware_cache)) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: too short firmware size %d (expected %d)\n",\r\n(int)fw->size, (int)sizeof(hdsp->firmware_cache));\r\nrelease_firmware(fw);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(hdsp->firmware_cache, fw->data, sizeof(hdsp->firmware_cache));\r\nrelease_firmware(fw);\r\nhdsp->state |= HDSP_FirmwareCached;\r\nif ((err = snd_hdsp_load_firmware_from_cache(hdsp)) < 0)\r\nreturn err;\r\nif (!(hdsp->state & HDSP_InitializationComplete)) {\r\nif ((err = snd_hdsp_enable_io(hdsp)) < 0)\r\nreturn err;\r\nif ((err = snd_hdsp_create_hwdep(hdsp->card, hdsp)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: error creating hwdep device\n");\r\nreturn err;\r\n}\r\nsnd_hdsp_initialize_channels(hdsp);\r\nsnd_hdsp_initialize_midi_flush(hdsp);\r\nif ((err = snd_hdsp_create_alsa_devices(hdsp->card, hdsp)) < 0) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: error creating alsa devices\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_hdsp_create(struct snd_card *card,\r\nstruct hdsp *hdsp)\r\n{\r\nstruct pci_dev *pci = hdsp->pci;\r\nint err;\r\nint is_9652 = 0;\r\nint is_9632 = 0;\r\nhdsp->irq = -1;\r\nhdsp->state = 0;\r\nhdsp->midi[0].rmidi = NULL;\r\nhdsp->midi[1].rmidi = NULL;\r\nhdsp->midi[0].input = NULL;\r\nhdsp->midi[1].input = NULL;\r\nhdsp->midi[0].output = NULL;\r\nhdsp->midi[1].output = NULL;\r\nhdsp->midi[0].pending = 0;\r\nhdsp->midi[1].pending = 0;\r\nspin_lock_init(&hdsp->midi[0].lock);\r\nspin_lock_init(&hdsp->midi[1].lock);\r\nhdsp->iobase = NULL;\r\nhdsp->control_register = 0;\r\nhdsp->control2_register = 0;\r\nhdsp->io_type = Undefined;\r\nhdsp->max_channels = 26;\r\nhdsp->card = card;\r\nspin_lock_init(&hdsp->lock);\r\ntasklet_init(&hdsp->midi_tasklet, hdsp_midi_tasklet, (unsigned long)hdsp);\r\npci_read_config_word(hdsp->pci, PCI_CLASS_REVISION, &hdsp->firmware_rev);\r\nhdsp->firmware_rev &= 0xff;\r\npci_write_config_byte(hdsp->pci, PCI_LATENCY_TIMER, 0xFF);\r\nstrcpy(card->driver, "H-DSP");\r\nstrcpy(card->mixername, "Xilinx FPGA");\r\nif (hdsp->firmware_rev < 0xa)\r\nreturn -ENODEV;\r\nelse if (hdsp->firmware_rev < 0x64)\r\nhdsp->card_name = "RME Hammerfall DSP";\r\nelse if (hdsp->firmware_rev < 0x96) {\r\nhdsp->card_name = "RME HDSP 9652";\r\nis_9652 = 1;\r\n} else {\r\nhdsp->card_name = "RME HDSP 9632";\r\nhdsp->max_channels = 16;\r\nis_9632 = 1;\r\n}\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\npci_set_master(hdsp->pci);\r\nif ((err = pci_request_regions(pci, "hdsp")) < 0)\r\nreturn err;\r\nhdsp->port = pci_resource_start(pci, 0);\r\nif ((hdsp->iobase = ioremap_nocache(hdsp->port, HDSP_IO_EXTENT)) == NULL) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: unable to remap region 0x%lx-0x%lx\n", hdsp->port, hdsp->port + HDSP_IO_EXTENT - 1);\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(pci->irq, snd_hdsp_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, hdsp)) {\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: unable to use IRQ %d\n", pci->irq);\r\nreturn -EBUSY;\r\n}\r\nhdsp->irq = pci->irq;\r\nhdsp->precise_ptr = 0;\r\nhdsp->use_midi_tasklet = 1;\r\nhdsp->dds_value = 0;\r\nif ((err = snd_hdsp_initialize_memory(hdsp)) < 0)\r\nreturn err;\r\nif (!is_9652 && !is_9632) {\r\nerr = hdsp_wait_for_iobox(hdsp, 1000, 10);\r\nif (err < 0)\r\nreturn err;\r\nif ((hdsp_read (hdsp, HDSP_statusRegister) & HDSP_DllError) != 0) {\r\n#ifdef HDSP_FW_LOADER\r\nif ((err = hdsp_request_fw_loader(hdsp)) < 0)\r\nsnd_printk(KERN_ERR "Hammerfall-DSP: couldn't get firmware from userspace. try using hdsploader\n");\r\nelse\r\nreturn 0;\r\n#endif\r\nsnd_printk(KERN_INFO "Hammerfall-DSP: card initialization pending : waiting for firmware\n");\r\nif ((err = snd_hdsp_create_hwdep(card, hdsp)) < 0)\r\nreturn err;\r\nreturn 0;\r\n} else {\r\nsnd_printk(KERN_INFO "Hammerfall-DSP: Firmware already present, initializing card.\n");\r\nif (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version2)\r\nhdsp->io_type = RPM;\r\nelse if (hdsp_read(hdsp, HDSP_status2Register) & HDSP_version1)\r\nhdsp->io_type = Multiface;\r\nelse\r\nhdsp->io_type = Digiface;\r\n}\r\n}\r\nif ((err = snd_hdsp_enable_io(hdsp)) != 0)\r\nreturn err;\r\nif (is_9652)\r\nhdsp->io_type = H9652;\r\nif (is_9632)\r\nhdsp->io_type = H9632;\r\nif ((err = snd_hdsp_create_hwdep(card, hdsp)) < 0)\r\nreturn err;\r\nsnd_hdsp_initialize_channels(hdsp);\r\nsnd_hdsp_initialize_midi_flush(hdsp);\r\nhdsp->state |= HDSP_FirmwareLoaded;\r\nif ((err = snd_hdsp_create_alsa_devices(card, hdsp)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_hdsp_free(struct hdsp *hdsp)\r\n{\r\nif (hdsp->port) {\r\ntasklet_kill(&hdsp->midi_tasklet);\r\nhdsp->control_register &= ~(HDSP_Start|HDSP_AudioInterruptEnable|HDSP_Midi0InterruptEnable|HDSP_Midi1InterruptEnable);\r\nhdsp_write (hdsp, HDSP_controlRegister, hdsp->control_register);\r\n}\r\nif (hdsp->irq >= 0)\r\nfree_irq(hdsp->irq, (void *)hdsp);\r\nsnd_hdsp_free_buffers(hdsp);\r\nif (hdsp->iobase)\r\niounmap(hdsp->iobase);\r\nif (hdsp->port)\r\npci_release_regions(hdsp->pci);\r\npci_disable_device(hdsp->pci);\r\nreturn 0;\r\n}\r\nstatic void snd_hdsp_card_free(struct snd_card *card)\r\n{\r\nstruct hdsp *hdsp = card->private_data;\r\nif (hdsp)\r\nsnd_hdsp_free(hdsp);\r\n}\r\nstatic int __devinit snd_hdsp_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct hdsp *hdsp;\r\nstruct snd_card *card;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct hdsp), &card);\r\nif (err < 0)\r\nreturn err;\r\nhdsp = card->private_data;\r\ncard->private_free = snd_hdsp_card_free;\r\nhdsp->dev = dev;\r\nhdsp->pci = pci;\r\nsnd_card_set_dev(card, &pci->dev);\r\nif ((err = snd_hdsp_create(card, hdsp)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->shortname, "Hammerfall DSP");\r\nsprintf(card->longname, "%s at 0x%lx, irq %d", hdsp->card_name,\r\nhdsp->port, hdsp->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void __devexit snd_hdsp_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
