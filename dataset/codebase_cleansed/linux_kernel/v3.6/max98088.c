static int max98088_volatile_register(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nreturn max98088_access[reg].vol;\r\n}\r\nstatic void m98088_eq_band(struct snd_soc_codec *codec, unsigned int dai,\r\nunsigned int band, u16 *coefs)\r\n{\r\nunsigned int eq_reg;\r\nunsigned int i;\r\nBUG_ON(band > 4);\r\nBUG_ON(dai > 1);\r\neq_reg = dai ? M98088_REG_84_DAI2_EQ_BASE : M98088_REG_52_DAI1_EQ_BASE;\r\neq_reg += band * (M98088_COEFS_PER_BAND << 1);\r\nfor (i = 0; i < M98088_COEFS_PER_BAND; i++) {\r\nsnd_soc_write(codec, eq_reg++, M98088_BYTE1(coefs[i]));\r\nsnd_soc_write(codec, eq_reg++, M98088_BYTE0(coefs[i]));\r\n}\r\n}\r\nstatic int max98088_mic1pre_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int sel = ucontrol->value.integer.value[0];\r\nmax98088->mic1pre = sel;\r\nsnd_soc_update_bits(codec, M98088_REG_35_LVL_MIC1, M98088_MICPRE_MASK,\r\n(1+sel)<<M98088_MICPRE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98088_mic1pre_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = max98088->mic1pre;\r\nreturn 0;\r\n}\r\nstatic int max98088_mic2pre_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int sel = ucontrol->value.integer.value[0];\r\nmax98088->mic2pre = sel;\r\nsnd_soc_update_bits(codec, M98088_REG_36_LVL_MIC2, M98088_MICPRE_MASK,\r\n(1+sel)<<M98088_MICPRE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98088_mic2pre_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = max98088->mic2pre;\r\nreturn 0;\r\n}\r\nstatic int max98088_mic_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (w->reg == M98088_REG_35_LVL_MIC1) {\r\nsnd_soc_update_bits(codec, w->reg, M98088_MICPRE_MASK,\r\n(1+max98088->mic1pre)<<M98088_MICPRE_SHIFT);\r\n} else {\r\nsnd_soc_update_bits(codec, w->reg, M98088_MICPRE_MASK,\r\n(1+max98088->mic2pre)<<M98088_MICPRE_SHIFT);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, w->reg, M98088_MICPRE_MASK, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98088_line_pga(struct snd_soc_dapm_widget *w,\r\nint event, int line, u8 channel)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nu8 *state;\r\nBUG_ON(!((channel == 1) || (channel == 2)));\r\nswitch (line) {\r\ncase LINE_INA:\r\nstate = &max98088->ina_state;\r\nbreak;\r\ncase LINE_INB:\r\nstate = &max98088->inb_state;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\n*state |= channel;\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << w->shift), (1 << w->shift));\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\n*state &= ~channel;\r\nif (*state == 0) {\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << w->shift), 0);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98088_pga_ina1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn max98088_line_pga(w, event, LINE_INA, 1);\r\n}\r\nstatic int max98088_pga_ina2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn max98088_line_pga(w, event, LINE_INA, 2);\r\n}\r\nstatic int max98088_pga_inb1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn max98088_line_pga(w, event, LINE_INB, 1);\r\n}\r\nstatic int max98088_pga_inb2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn max98088_line_pga(w, event, LINE_INB, 2);\r\n}\r\nstatic inline int rate_value(int rate, u8 *value)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\r\nif (rate_table[i].rate >= rate) {\r\n*value = rate_table[i].sr;\r\nreturn 0;\r\n}\r\n}\r\n*value = rate_table[0].sr;\r\nreturn -EINVAL;\r\n}\r\nstatic int max98088_dai1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_cdata *cdata;\r\nunsigned long long ni;\r\nunsigned int rate;\r\nu8 regval;\r\ncdata = &max98088->dai[0];\r\nrate = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsnd_soc_update_bits(codec, M98088_REG_14_DAI1_FORMAT,\r\nM98088_DAI_WS, 0);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsnd_soc_update_bits(codec, M98088_REG_14_DAI1_FORMAT,\r\nM98088_DAI_WS, M98088_DAI_WS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, M98088_REG_51_PWR_SYS, M98088_SHDNRUN, 0);\r\nif (rate_value(rate, &regval))\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, M98088_REG_11_DAI1_CLKMODE,\r\nM98088_CLKMODE_MASK, regval);\r\ncdata->rate = rate;\r\nif (snd_soc_read(codec, M98088_REG_14_DAI1_FORMAT)\r\n& M98088_DAI_MAS) {\r\nif (max98088->sysclk == 0) {\r\ndev_err(codec->dev, "Invalid system clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\r\n* (unsigned long long int)rate;\r\ndo_div(ni, (unsigned long long int)max98088->sysclk);\r\nsnd_soc_write(codec, M98088_REG_12_DAI1_CLKCFG_HI,\r\n(ni >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98088_REG_13_DAI1_CLKCFG_LO,\r\nni & 0xFF);\r\n}\r\nif (rate < 50000)\r\nsnd_soc_update_bits(codec, M98088_REG_18_DAI1_FILTERS,\r\nM98088_DAI_DHF, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98088_REG_18_DAI1_FILTERS,\r\nM98088_DAI_DHF, M98088_DAI_DHF);\r\nsnd_soc_update_bits(codec, M98088_REG_51_PWR_SYS, M98088_SHDNRUN,\r\nM98088_SHDNRUN);\r\nreturn 0;\r\n}\r\nstatic int max98088_dai2_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_cdata *cdata;\r\nunsigned long long ni;\r\nunsigned int rate;\r\nu8 regval;\r\ncdata = &max98088->dai[1];\r\nrate = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsnd_soc_update_bits(codec, M98088_REG_1C_DAI2_FORMAT,\r\nM98088_DAI_WS, 0);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsnd_soc_update_bits(codec, M98088_REG_1C_DAI2_FORMAT,\r\nM98088_DAI_WS, M98088_DAI_WS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, M98088_REG_51_PWR_SYS, M98088_SHDNRUN, 0);\r\nif (rate_value(rate, &regval))\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, M98088_REG_19_DAI2_CLKMODE,\r\nM98088_CLKMODE_MASK, regval);\r\ncdata->rate = rate;\r\nif (snd_soc_read(codec, M98088_REG_1C_DAI2_FORMAT)\r\n& M98088_DAI_MAS) {\r\nif (max98088->sysclk == 0) {\r\ndev_err(codec->dev, "Invalid system clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\r\n* (unsigned long long int)rate;\r\ndo_div(ni, (unsigned long long int)max98088->sysclk);\r\nsnd_soc_write(codec, M98088_REG_1A_DAI2_CLKCFG_HI,\r\n(ni >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98088_REG_1B_DAI2_CLKCFG_LO,\r\nni & 0xFF);\r\n}\r\nif (rate < 50000)\r\nsnd_soc_update_bits(codec, M98088_REG_20_DAI2_FILTERS,\r\nM98088_DAI_DHF, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98088_REG_20_DAI2_FILTERS,\r\nM98088_DAI_DHF, M98088_DAI_DHF);\r\nsnd_soc_update_bits(codec, M98088_REG_51_PWR_SYS, M98088_SHDNRUN,\r\nM98088_SHDNRUN);\r\nreturn 0;\r\n}\r\nstatic int max98088_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nif (freq == max98088->sysclk)\r\nreturn 0;\r\nif ((freq >= 10000000) && (freq < 20000000)) {\r\nsnd_soc_write(codec, M98088_REG_10_SYS_CLK, 0x10);\r\n} else if ((freq >= 20000000) && (freq < 30000000)) {\r\nsnd_soc_write(codec, M98088_REG_10_SYS_CLK, 0x20);\r\n} else {\r\ndev_err(codec->dev, "Invalid master clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nif (snd_soc_read(codec, M98088_REG_51_PWR_SYS) & M98088_SHDNRUN) {\r\nsnd_soc_update_bits(codec, M98088_REG_51_PWR_SYS,\r\nM98088_SHDNRUN, 0);\r\nsnd_soc_update_bits(codec, M98088_REG_51_PWR_SYS,\r\nM98088_SHDNRUN, M98088_SHDNRUN);\r\n}\r\ndev_dbg(dai->dev, "Clock source is %d at %uHz\n", clk_id, freq);\r\nmax98088->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int max98088_dai1_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_cdata *cdata;\r\nu8 reg15val;\r\nu8 reg14val = 0;\r\ncdata = &max98088->dai[0];\r\nif (fmt != cdata->fmt) {\r\ncdata->fmt = fmt;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_write(codec, M98088_REG_12_DAI1_CLKCFG_HI,\r\n0x80);\r\nsnd_soc_write(codec, M98088_REG_13_DAI1_CLKCFG_LO,\r\n0x00);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nreg14val |= M98088_DAI_MAS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "Clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nreg14val |= M98088_DAI_DLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nreg14val |= M98088_DAI_WCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nreg14val |= M98088_DAI_BCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nreg14val |= M98088_DAI_BCI|M98088_DAI_WCI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, M98088_REG_14_DAI1_FORMAT,\r\nM98088_DAI_MAS | M98088_DAI_DLY | M98088_DAI_BCI |\r\nM98088_DAI_WCI, reg14val);\r\nreg15val = M98088_DAI_BSEL64;\r\nif (max98088->digmic)\r\nreg15val |= M98088_DAI_OSR64;\r\nsnd_soc_write(codec, M98088_REG_15_DAI1_CLOCK, reg15val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98088_dai2_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_cdata *cdata;\r\nu8 reg1Cval = 0;\r\ncdata = &max98088->dai[1];\r\nif (fmt != cdata->fmt) {\r\ncdata->fmt = fmt;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_write(codec, M98088_REG_1A_DAI2_CLKCFG_HI,\r\n0x80);\r\nsnd_soc_write(codec, M98088_REG_1B_DAI2_CLKCFG_LO,\r\n0x00);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nreg1Cval |= M98088_DAI_MAS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "Clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nreg1Cval |= M98088_DAI_DLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nreg1Cval |= M98088_DAI_WCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nreg1Cval |= M98088_DAI_BCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nreg1Cval |= M98088_DAI_BCI|M98088_DAI_WCI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, M98088_REG_1C_DAI2_FORMAT,\r\nM98088_DAI_MAS | M98088_DAI_DLY | M98088_DAI_BCI |\r\nM98088_DAI_WCI, reg1Cval);\r\nsnd_soc_write(codec, M98088_REG_1D_DAI2_CLOCK,\r\nM98088_DAI_BSEL64);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98088_dai1_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint reg;\r\nif (mute)\r\nreg = M98088_DAI_MUTE;\r\nelse\r\nreg = 0;\r\nsnd_soc_update_bits(codec, M98088_REG_2F_LVL_DAI1_PLAY,\r\nM98088_DAI_MUTE_MASK, reg);\r\nreturn 0;\r\n}\r\nstatic int max98088_dai2_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint reg;\r\nif (mute)\r\nreg = M98088_DAI_MUTE;\r\nelse\r\nreg = 0;\r\nsnd_soc_update_bits(codec, M98088_REG_31_LVL_DAI2_PLAY,\r\nM98088_DAI_MUTE_MASK, reg);\r\nreturn 0;\r\n}\r\nstatic void max98088_sync_cache(struct snd_soc_codec *codec)\r\n{\r\nu16 *reg_cache = codec->reg_cache;\r\nint i;\r\nif (!codec->cache_sync)\r\nreturn;\r\ncodec->cache_only = 0;\r\nfor (i = 1; i < codec->driver->reg_cache_size; i++) {\r\nif (!max98088_access[i].writable)\r\ncontinue;\r\nif (reg_cache[i] == max98088_reg[i])\r\ncontinue;\r\nsnd_soc_write(codec, i, reg_cache[i]);\r\n}\r\ncodec->cache_sync = 0;\r\n}\r\nstatic int max98088_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF)\r\nmax98088_sync_cache(codec);\r\nsnd_soc_update_bits(codec, M98088_REG_4C_PWR_EN_IN,\r\nM98088_MBEN, M98088_MBEN);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, M98088_REG_4C_PWR_EN_IN,\r\nM98088_MBEN, 0);\r\ncodec->cache_sync = 1;\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int max98088_get_channel(struct snd_soc_codec *codec, const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(eq_mode_name); i++)\r\nif (strcmp(name, eq_mode_name[i]) == 0)\r\nreturn i;\r\ndev_err(codec->dev, "Bad EQ channel name '%s'\n", name);\r\nreturn -EINVAL;\r\n}\r\nstatic void max98088_setup_eq1(struct snd_soc_codec *codec)\r\n{\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_pdata *pdata = max98088->pdata;\r\nstruct max98088_eq_cfg *coef_set;\r\nint best, best_val, save, i, sel, fs;\r\nstruct max98088_cdata *cdata;\r\ncdata = &max98088->dai[0];\r\nif (!pdata || !max98088->eq_textcnt)\r\nreturn;\r\nfs = cdata->rate;\r\nsel = cdata->eq_sel;\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < pdata->eq_cfgcnt; i++) {\r\nif (strcmp(pdata->eq_cfg[i].name, max98088->eq_texts[sel]) == 0 &&\r\nabs(pdata->eq_cfg[i].rate - fs) < best_val) {\r\nbest = i;\r\nbest_val = abs(pdata->eq_cfg[i].rate - fs);\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected %s/%dHz for %dHz sample rate\n",\r\npdata->eq_cfg[best].name,\r\npdata->eq_cfg[best].rate, fs);\r\nsave = snd_soc_read(codec, M98088_REG_49_CFG_LEVEL);\r\nsnd_soc_update_bits(codec, M98088_REG_49_CFG_LEVEL, M98088_EQ1EN, 0);\r\ncoef_set = &pdata->eq_cfg[sel];\r\nm98088_eq_band(codec, 0, 0, coef_set->band1);\r\nm98088_eq_band(codec, 0, 1, coef_set->band2);\r\nm98088_eq_band(codec, 0, 2, coef_set->band3);\r\nm98088_eq_band(codec, 0, 3, coef_set->band4);\r\nm98088_eq_band(codec, 0, 4, coef_set->band5);\r\nsnd_soc_update_bits(codec, M98088_REG_49_CFG_LEVEL, M98088_EQ1EN, save);\r\n}\r\nstatic void max98088_setup_eq2(struct snd_soc_codec *codec)\r\n{\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_pdata *pdata = max98088->pdata;\r\nstruct max98088_eq_cfg *coef_set;\r\nint best, best_val, save, i, sel, fs;\r\nstruct max98088_cdata *cdata;\r\ncdata = &max98088->dai[1];\r\nif (!pdata || !max98088->eq_textcnt)\r\nreturn;\r\nfs = cdata->rate;\r\nsel = cdata->eq_sel;\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < pdata->eq_cfgcnt; i++) {\r\nif (strcmp(pdata->eq_cfg[i].name, max98088->eq_texts[sel]) == 0 &&\r\nabs(pdata->eq_cfg[i].rate - fs) < best_val) {\r\nbest = i;\r\nbest_val = abs(pdata->eq_cfg[i].rate - fs);\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected %s/%dHz for %dHz sample rate\n",\r\npdata->eq_cfg[best].name,\r\npdata->eq_cfg[best].rate, fs);\r\nsave = snd_soc_read(codec, M98088_REG_49_CFG_LEVEL);\r\nsnd_soc_update_bits(codec, M98088_REG_49_CFG_LEVEL, M98088_EQ2EN, 0);\r\ncoef_set = &pdata->eq_cfg[sel];\r\nm98088_eq_band(codec, 1, 0, coef_set->band1);\r\nm98088_eq_band(codec, 1, 1, coef_set->band2);\r\nm98088_eq_band(codec, 1, 2, coef_set->band3);\r\nm98088_eq_band(codec, 1, 3, coef_set->band4);\r\nm98088_eq_band(codec, 1, 4, coef_set->band5);\r\nsnd_soc_update_bits(codec, M98088_REG_49_CFG_LEVEL, M98088_EQ2EN,\r\nsave);\r\n}\r\nstatic int max98088_put_eq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_pdata *pdata = max98088->pdata;\r\nint channel = max98088_get_channel(codec, kcontrol->id.name);\r\nstruct max98088_cdata *cdata;\r\nint sel = ucontrol->value.integer.value[0];\r\nif (channel < 0)\r\nreturn channel;\r\ncdata = &max98088->dai[channel];\r\nif (sel >= pdata->eq_cfgcnt)\r\nreturn -EINVAL;\r\ncdata->eq_sel = sel;\r\nswitch (channel) {\r\ncase 0:\r\nmax98088_setup_eq1(codec);\r\nbreak;\r\ncase 1:\r\nmax98088_setup_eq2(codec);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98088_get_eq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nint channel = max98088_get_channel(codec, kcontrol->id.name);\r\nstruct max98088_cdata *cdata;\r\nif (channel < 0)\r\nreturn channel;\r\ncdata = &max98088->dai[channel];\r\nucontrol->value.enumerated.item[0] = cdata->eq_sel;\r\nreturn 0;\r\n}\r\nstatic void max98088_handle_eq_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_pdata *pdata = max98088->pdata;\r\nstruct max98088_eq_cfg *cfg;\r\nunsigned int cfgcnt;\r\nint i, j;\r\nconst char **t;\r\nint ret;\r\nstruct snd_kcontrol_new controls[] = {\r\nSOC_ENUM_EXT((char *)eq_mode_name[0],\r\nmax98088->eq_enum,\r\nmax98088_get_eq_enum,\r\nmax98088_put_eq_enum),\r\nSOC_ENUM_EXT((char *)eq_mode_name[1],\r\nmax98088->eq_enum,\r\nmax98088_get_eq_enum,\r\nmax98088_put_eq_enum),\r\n};\r\nBUILD_BUG_ON(ARRAY_SIZE(controls) != ARRAY_SIZE(eq_mode_name));\r\ncfg = pdata->eq_cfg;\r\ncfgcnt = pdata->eq_cfgcnt;\r\nmax98088->eq_textcnt = 0;\r\nmax98088->eq_texts = NULL;\r\nfor (i = 0; i < cfgcnt; i++) {\r\nfor (j = 0; j < max98088->eq_textcnt; j++) {\r\nif (strcmp(cfg[i].name, max98088->eq_texts[j]) == 0)\r\nbreak;\r\n}\r\nif (j != max98088->eq_textcnt)\r\ncontinue;\r\nt = krealloc(max98088->eq_texts,\r\nsizeof(char *) * (max98088->eq_textcnt + 1),\r\nGFP_KERNEL);\r\nif (t == NULL)\r\ncontinue;\r\nt[max98088->eq_textcnt] = cfg[i].name;\r\nmax98088->eq_textcnt++;\r\nmax98088->eq_texts = t;\r\n}\r\nmax98088->eq_enum.texts = max98088->eq_texts;\r\nmax98088->eq_enum.max = max98088->eq_textcnt;\r\nret = snd_soc_add_codec_controls(codec, controls, ARRAY_SIZE(controls));\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to add EQ control: %d\n", ret);\r\n}\r\nstatic void max98088_handle_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_pdata *pdata = max98088->pdata;\r\nu8 regval = 0;\r\nif (!pdata) {\r\ndev_dbg(codec->dev, "No platform data\n");\r\nreturn;\r\n}\r\nif (pdata->digmic_left_mode)\r\nregval |= M98088_DIGMIC_L;\r\nif (pdata->digmic_right_mode)\r\nregval |= M98088_DIGMIC_R;\r\nmax98088->digmic = (regval ? 1 : 0);\r\nsnd_soc_write(codec, M98088_REG_48_CFG_MIC, regval);\r\nregval = ((pdata->receiver_mode) ? M98088_REC_LINEMODE : 0);\r\nsnd_soc_update_bits(codec, M98088_REG_2A_MIC_REC_CNTL,\r\nM98088_REC_LINEMODE_MASK, regval);\r\nif (pdata->eq_cfgcnt)\r\nmax98088_handle_eq_pdata(codec);\r\n}\r\nstatic int max98088_suspend(struct snd_soc_codec *codec)\r\n{\r\nmax98088_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int max98088_resume(struct snd_soc_codec *codec)\r\n{\r\nmax98088_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int max98088_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98088_cdata *cdata;\r\nint ret = 0;\r\ncodec->cache_sync = 1;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nmax98088->sysclk = (unsigned)-1;\r\nmax98088->eq_textcnt = 0;\r\ncdata = &max98088->dai[0];\r\ncdata->rate = (unsigned)-1;\r\ncdata->fmt = (unsigned)-1;\r\ncdata->eq_sel = 0;\r\ncdata = &max98088->dai[1];\r\ncdata->rate = (unsigned)-1;\r\ncdata->fmt = (unsigned)-1;\r\ncdata->eq_sel = 0;\r\nmax98088->ina_state = 0;\r\nmax98088->inb_state = 0;\r\nmax98088->ex_mode = 0;\r\nmax98088->digmic = 0;\r\nmax98088->mic1pre = 0;\r\nmax98088->mic2pre = 0;\r\nret = snd_soc_read(codec, M98088_REG_FF_REV_ID);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_access;\r\n}\r\ndev_info(codec->dev, "revision %c\n", ret + 'A');\r\nsnd_soc_write(codec, M98088_REG_51_PWR_SYS, M98088_PWRSV);\r\nmax98088_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_write(codec, M98088_REG_0F_IRQ_ENABLE, 0x00);\r\nsnd_soc_write(codec, M98088_REG_22_MIX_DAC,\r\nM98088_DAI1L_TO_DACL|M98088_DAI2L_TO_DACL|\r\nM98088_DAI1R_TO_DACR|M98088_DAI2R_TO_DACR);\r\nsnd_soc_write(codec, M98088_REG_4E_BIAS_CNTL, 0xF0);\r\nsnd_soc_write(codec, M98088_REG_50_DAC_BIAS2, 0x0F);\r\nsnd_soc_write(codec, M98088_REG_16_DAI1_IOCFG,\r\nM98088_S1NORMAL|M98088_SDATA);\r\nsnd_soc_write(codec, M98088_REG_1E_DAI2_IOCFG,\r\nM98088_S2NORMAL|M98088_SDATA);\r\nmax98088_handle_pdata(codec);\r\nsnd_soc_add_codec_controls(codec, max98088_snd_controls,\r\nARRAY_SIZE(max98088_snd_controls));\r\nerr_access:\r\nreturn ret;\r\n}\r\nstatic int max98088_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct max98088_priv *max98088 = snd_soc_codec_get_drvdata(codec);\r\nmax98088_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nkfree(max98088->eq_texts);\r\nreturn 0;\r\n}\r\nstatic int max98088_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max98088_priv *max98088;\r\nint ret;\r\nmax98088 = devm_kzalloc(&i2c->dev, sizeof(struct max98088_priv),\r\nGFP_KERNEL);\r\nif (max98088 == NULL)\r\nreturn -ENOMEM;\r\nmax98088->devtype = id->driver_data;\r\ni2c_set_clientdata(i2c, max98088);\r\nmax98088->pdata = i2c->dev.platform_data;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_max98088, &max98088_dai[0], 2);\r\nreturn ret;\r\n}\r\nstatic int __devexit max98088_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init max98088_init(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&max98088_i2c_driver);\r\nif (ret)\r\npr_err("Failed to register max98088 I2C driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit max98088_exit(void)\r\n{\r\ni2c_del_driver(&max98088_i2c_driver);\r\n}
