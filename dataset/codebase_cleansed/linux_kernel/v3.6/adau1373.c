static int adau1373_pll_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nunsigned int pll_id = w->name[3] - '1';\r\nunsigned int val;\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\nval = ADAU1373_PLL_CTRL6_PLL_EN;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, ADAU1373_PLL_CTRL6(pll_id),\r\nADAU1373_PLL_CTRL6_PLL_EN, val);\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\nmdelay(5);\r\nreturn 0;\r\n}\r\nstatic int adau1373_check_aif_clk(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = source->codec;\r\nstruct adau1373 *adau1373 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int dai;\r\nconst char *clk;\r\ndai = sink->name[3] - '1';\r\nif (!adau1373->dais[dai].master)\r\nreturn 0;\r\nif (adau1373->dais[dai].clk_src == ADAU1373_CLK_SRC_PLL1)\r\nclk = "SYSCLK1";\r\nelse\r\nclk = "SYSCLK2";\r\nreturn strcmp(source->name, clk) == 0;\r\n}\r\nstatic int adau1373_check_src(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = source->codec;\r\nstruct adau1373 *adau1373 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int dai;\r\ndai = sink->name[3] - '1';\r\nreturn adau1373->dais[dai].enable_src;\r\n}\r\nstatic int adau1373_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adau1373 *adau1373 = snd_soc_codec_get_drvdata(codec);\r\nstruct adau1373_dai *adau1373_dai = &adau1373->dais[dai->id];\r\nunsigned int div;\r\nunsigned int freq;\r\nunsigned int ctrl;\r\nfreq = adau1373_dai->sysclk;\r\nif (freq % params_rate(params) != 0)\r\nreturn -EINVAL;\r\nswitch (freq / params_rate(params)) {\r\ncase 1024:\r\ndiv = 0;\r\nbreak;\r\ncase 1536:\r\ndiv = 1;\r\nbreak;\r\ncase 2048:\r\ndiv = 2;\r\nbreak;\r\ncase 3072:\r\ndiv = 3;\r\nbreak;\r\ncase 4096:\r\ndiv = 4;\r\nbreak;\r\ncase 6144:\r\ndiv = 5;\r\nbreak;\r\ncase 5632:\r\ndiv = 6;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadau1373_dai->enable_src = (div != 0);\r\nsnd_soc_update_bits(codec, ADAU1373_BCLKDIV(dai->id),\r\n~ADAU1373_BCLKDIV_SOURCE, (div << 2) | ADAU1373_BCLKDIV_64);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nctrl = ADAU1373_DAI_WLEN_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nctrl = ADAU1373_DAI_WLEN_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nctrl = ADAU1373_DAI_WLEN_24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nctrl = ADAU1373_DAI_WLEN_32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_update_bits(codec, ADAU1373_DAI(dai->id),\r\nADAU1373_DAI_WLEN_MASK, ctrl);\r\n}\r\nstatic int adau1373_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adau1373 *adau1373 = snd_soc_codec_get_drvdata(codec);\r\nstruct adau1373_dai *adau1373_dai = &adau1373->dais[dai->id];\r\nunsigned int ctrl;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nctrl = ADAU1373_DAI_MASTER;\r\nadau1373_dai->master = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nctrl = 0;\r\nadau1373_dai->master = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nctrl |= ADAU1373_DAI_FORMAT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nctrl |= ADAU1373_DAI_FORMAT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nctrl |= ADAU1373_DAI_FORMAT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nctrl |= ADAU1373_DAI_FORMAT_DSP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nctrl |= ADAU1373_DAI_INVERT_BCLK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nctrl |= ADAU1373_DAI_INVERT_LRCLK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nctrl |= ADAU1373_DAI_INVERT_LRCLK | ADAU1373_DAI_INVERT_BCLK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, ADAU1373_DAI(dai->id),\r\n~ADAU1373_DAI_WLEN_MASK, ctrl);\r\nreturn 0;\r\n}\r\nstatic int adau1373_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct adau1373 *adau1373 = snd_soc_codec_get_drvdata(dai->codec);\r\nstruct adau1373_dai *adau1373_dai = &adau1373->dais[dai->id];\r\nswitch (clk_id) {\r\ncase ADAU1373_CLK_SRC_PLL1:\r\ncase ADAU1373_CLK_SRC_PLL2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadau1373_dai->sysclk = freq;\r\nadau1373_dai->clk_src = clk_id;\r\nsnd_soc_update_bits(dai->codec, ADAU1373_BCLKDIV(dai->id),\r\nADAU1373_BCLKDIV_SOURCE, clk_id << 5);\r\nreturn 0;\r\n}\r\nstatic int adau1373_set_pll(struct snd_soc_codec *codec, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nunsigned int dpll_div = 0;\r\nunsigned int x, r, n, m, i, j, mode;\r\nswitch (pll_id) {\r\ncase ADAU1373_PLL1:\r\ncase ADAU1373_PLL2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (source) {\r\ncase ADAU1373_PLL_SRC_BCLK1:\r\ncase ADAU1373_PLL_SRC_BCLK2:\r\ncase ADAU1373_PLL_SRC_BCLK3:\r\ncase ADAU1373_PLL_SRC_LRCLK1:\r\ncase ADAU1373_PLL_SRC_LRCLK2:\r\ncase ADAU1373_PLL_SRC_LRCLK3:\r\ncase ADAU1373_PLL_SRC_MCLK1:\r\ncase ADAU1373_PLL_SRC_MCLK2:\r\ncase ADAU1373_PLL_SRC_GPIO1:\r\ncase ADAU1373_PLL_SRC_GPIO2:\r\ncase ADAU1373_PLL_SRC_GPIO3:\r\ncase ADAU1373_PLL_SRC_GPIO4:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (freq_in < 7813 || freq_in > 27000000)\r\nreturn -EINVAL;\r\nif (freq_out < 45158000 || freq_out > 49152000)\r\nreturn -EINVAL;\r\nwhile (freq_in < 8000000) {\r\nfreq_in *= 2;\r\ndpll_div++;\r\n}\r\nif (freq_out % freq_in != 0) {\r\nx = DIV_ROUND_UP(freq_in, 13500000);\r\nfreq_in /= x;\r\nr = freq_out / freq_in;\r\ni = freq_out % freq_in;\r\nj = gcd(i, freq_in);\r\nn = i / j;\r\nm = freq_in / j;\r\nx--;\r\nmode = 1;\r\n} else {\r\nr = freq_out / freq_in;\r\nn = 0;\r\nm = 0;\r\nx = 0;\r\nmode = 0;\r\n}\r\nif (r < 2 || r > 8 || x > 3 || m > 0xffff || n > 0xffff)\r\nreturn -EINVAL;\r\nif (dpll_div) {\r\ndpll_div = 11 - dpll_div;\r\nsnd_soc_update_bits(codec, ADAU1373_PLL_CTRL6(pll_id),\r\nADAU1373_PLL_CTRL6_DPLL_BYPASS, 0);\r\n} else {\r\nsnd_soc_update_bits(codec, ADAU1373_PLL_CTRL6(pll_id),\r\nADAU1373_PLL_CTRL6_DPLL_BYPASS,\r\nADAU1373_PLL_CTRL6_DPLL_BYPASS);\r\n}\r\nsnd_soc_write(codec, ADAU1373_DPLL_CTRL(pll_id),\r\n(source << 4) | dpll_div);\r\nsnd_soc_write(codec, ADAU1373_PLL_CTRL1(pll_id), (m >> 8) & 0xff);\r\nsnd_soc_write(codec, ADAU1373_PLL_CTRL2(pll_id), m & 0xff);\r\nsnd_soc_write(codec, ADAU1373_PLL_CTRL3(pll_id), (n >> 8) & 0xff);\r\nsnd_soc_write(codec, ADAU1373_PLL_CTRL4(pll_id), n & 0xff);\r\nsnd_soc_write(codec, ADAU1373_PLL_CTRL5(pll_id),\r\n(r << 3) | (x << 1) | mode);\r\nsnd_soc_update_bits(codec, ADAU1373_CLK_SRC_DIV(pll_id), 0x3f, 0x09);\r\nreturn 0;\r\n}\r\nstatic void adau1373_load_drc_settings(struct snd_soc_codec *codec,\r\nunsigned int nr, uint8_t *drc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ADAU1373_DRC_SIZE; ++i)\r\nsnd_soc_write(codec, ADAU1373_DRC(nr) + i, drc[i]);\r\n}\r\nstatic bool adau1373_valid_micbias(enum adau1373_micbias_voltage micbias)\r\n{\r\nswitch (micbias) {\r\ncase ADAU1373_MICBIAS_2_9V:\r\ncase ADAU1373_MICBIAS_2_2V:\r\ncase ADAU1373_MICBIAS_2_6V:\r\ncase ADAU1373_MICBIAS_1_8V:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic int adau1373_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct adau1373_platform_data *pdata = codec->dev->platform_data;\r\nbool lineout_differential = false;\r\nunsigned int val;\r\nint ret;\r\nint i;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);\r\nif (ret) {\r\ndev_err(codec->dev, "failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pdata) {\r\nif (pdata->num_drc > ARRAY_SIZE(pdata->drc_setting))\r\nreturn -EINVAL;\r\nif (!adau1373_valid_micbias(pdata->micbias1) ||\r\n!adau1373_valid_micbias(pdata->micbias2))\r\nreturn -EINVAL;\r\nfor (i = 0; i < pdata->num_drc; ++i) {\r\nadau1373_load_drc_settings(codec, i,\r\npdata->drc_setting[i]);\r\n}\r\nsnd_soc_add_codec_controls(codec, adau1373_drc_controls,\r\npdata->num_drc);\r\nval = 0;\r\nfor (i = 0; i < 4; ++i) {\r\nif (pdata->input_differential[i])\r\nval |= BIT(i);\r\n}\r\nsnd_soc_write(codec, ADAU1373_INPUT_MODE, val);\r\nval = 0;\r\nif (pdata->lineout_differential)\r\nval |= ADAU1373_OUTPUT_CTRL_LDIFF;\r\nif (pdata->lineout_ground_sense)\r\nval |= ADAU1373_OUTPUT_CTRL_LNFBEN;\r\nsnd_soc_write(codec, ADAU1373_OUTPUT_CTRL, val);\r\nlineout_differential = pdata->lineout_differential;\r\nsnd_soc_write(codec, ADAU1373_EP_CTRL,\r\n(pdata->micbias1 << ADAU1373_EP_CTRL_MICBIAS1_OFFSET) |\r\n(pdata->micbias2 << ADAU1373_EP_CTRL_MICBIAS2_OFFSET));\r\n}\r\nif (!lineout_differential) {\r\nsnd_soc_add_codec_controls(codec, adau1373_lineout2_controls,\r\nARRAY_SIZE(adau1373_lineout2_controls));\r\n}\r\nsnd_soc_write(codec, ADAU1373_ADC_CTRL,\r\nADAU1373_ADC_CTRL_RESET_FORCE | ADAU1373_ADC_CTRL_PEAK_DETECT);\r\nreturn 0;\r\n}\r\nstatic int adau1373_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, ADAU1373_PWDN_CTRL3,\r\nADAU1373_PWDN_CTRL3_PWR_EN, ADAU1373_PWDN_CTRL3_PWR_EN);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, ADAU1373_PWDN_CTRL3,\r\nADAU1373_PWDN_CTRL3_PWR_EN, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int adau1373_remove(struct snd_soc_codec *codec)\r\n{\r\nadau1373_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int adau1373_suspend(struct snd_soc_codec *codec)\r\n{\r\nreturn adau1373_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\n}\r\nstatic int adau1373_resume(struct snd_soc_codec *codec)\r\n{\r\nadau1373_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_cache_sync(codec);\r\nreturn 0;\r\n}\r\nstatic int __devinit adau1373_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adau1373 *adau1373;\r\nint ret;\r\nadau1373 = devm_kzalloc(&client->dev, sizeof(*adau1373), GFP_KERNEL);\r\nif (!adau1373)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&client->dev, adau1373);\r\nret = snd_soc_register_codec(&client->dev, &adau1373_codec_driver,\r\nadau1373_dai_driver, ARRAY_SIZE(adau1373_dai_driver));\r\nreturn ret;\r\n}\r\nstatic int __devexit adau1373_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init adau1373_init(void)\r\n{\r\nreturn i2c_add_driver(&adau1373_i2c_driver);\r\n}\r\nstatic void __exit adau1373_exit(void)\r\n{\r\ni2c_del_driver(&adau1373_i2c_driver);\r\n}
