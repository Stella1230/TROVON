static inline int volt_reg_to_mV(int value)\r\n{\r\nreturn ((value * 1000) / 512) + 2500;\r\n}\r\nstatic inline int ichg_reg_to_mA(int value)\r\n{\r\nreturn (value * 3900) / 1000;\r\n}\r\nstatic int da9052_read_chgend_current(struct da9052_battery *bat,\r\nint *current_mA)\r\n{\r\nint ret;\r\nif (bat->status == POWER_SUPPLY_STATUS_DISCHARGING)\r\nreturn -EINVAL;\r\nret = da9052_reg_read(bat->da9052, DA9052_ICHG_END_REG);\r\nif (ret < 0)\r\nreturn ret;\r\n*current_mA = ichg_reg_to_mA(ret & DA9052_ICHGEND_ICHGEND);\r\nreturn 0;\r\n}\r\nstatic int da9052_read_chg_current(struct da9052_battery *bat, int *current_mA)\r\n{\r\nint ret;\r\nif (bat->status == POWER_SUPPLY_STATUS_DISCHARGING)\r\nreturn -EINVAL;\r\nret = da9052_reg_read(bat->da9052, DA9052_ICHG_AV_REG);\r\nif (ret < 0)\r\nreturn ret;\r\n*current_mA = ichg_reg_to_mA(ret & DA9052_ICHGAV_ICHGAV);\r\nreturn 0;\r\n}\r\nstatic int da9052_bat_check_status(struct da9052_battery *bat, int *status)\r\n{\r\nu8 v[2] = {0, 0};\r\nu8 bat_status;\r\nu8 chg_end;\r\nint ret;\r\nint chg_current;\r\nint chg_end_current;\r\nbool dcinsel;\r\nbool dcindet;\r\nbool vbussel;\r\nbool vbusdet;\r\nbool dc;\r\nbool vbus;\r\nret = da9052_group_read(bat->da9052, DA9052_STATUS_A_REG, 2, v);\r\nif (ret < 0)\r\nreturn ret;\r\nbat_status = v[0];\r\nchg_end = v[1];\r\ndcinsel = bat_status & DA9052_STATUSA_DCINSEL;\r\ndcindet = bat_status & DA9052_STATUSA_DCINDET;\r\nvbussel = bat_status & DA9052_STATUSA_VBUSSEL;\r\nvbusdet = bat_status & DA9052_STATUSA_VBUSDET;\r\ndc = dcinsel && dcindet;\r\nvbus = vbussel && vbusdet;\r\nif (dc || vbus) {\r\nbat->charger_type = DA9052_CHARGER;\r\nif ((chg_end & DA9052_STATUSB_CHGEND) != 0) {\r\nret = da9052_read_chg_current(bat, &chg_current);\r\nif (ret < 0)\r\nreturn ret;\r\nret = da9052_read_chgend_current(bat, &chg_end_current);\r\nif (ret < 0)\r\nreturn ret;\r\nif (chg_current >= chg_end_current)\r\nbat->status = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nbat->status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n} else {\r\nbat->status = POWER_SUPPLY_STATUS_CHARGING;\r\n}\r\n} else if (dcindet || vbusdet) {\r\nbat->charger_type = DA9052_CHARGER;\r\nbat->status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n} else {\r\nbat->charger_type = DA9052_NOCHARGER;\r\nbat->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\n}\r\nif (status != NULL)\r\n*status = bat->status;\r\nreturn 0;\r\n}\r\nstatic int da9052_bat_read_volt(struct da9052_battery *bat, int *volt_mV)\r\n{\r\nint volt;\r\nvolt = da9052_adc_manual_read(bat->da9052, DA9052_ADC_MAN_MUXSEL_VBAT);\r\nif (volt < 0)\r\nreturn volt;\r\n*volt_mV = volt_reg_to_mV(volt);\r\nreturn 0;\r\n}\r\nstatic int da9052_bat_check_presence(struct da9052_battery *bat, int *illegal)\r\n{\r\nint bat_temp;\r\nbat_temp = da9052_adc_read_temp(bat->da9052);\r\nif (bat_temp < 0)\r\nreturn bat_temp;\r\nif (bat_temp > DA9052_BAT_TSH)\r\n*illegal = 1;\r\nelse\r\n*illegal = 0;\r\nreturn 0;\r\n}\r\nstatic int da9052_bat_interpolate(int vbat_lower, int vbat_upper,\r\nint level_lower, int level_upper,\r\nint bat_voltage)\r\n{\r\nint tmp;\r\ntmp = ((level_upper - level_lower) * 1000) / (vbat_upper - vbat_lower);\r\ntmp = level_lower + (((bat_voltage - vbat_lower) * tmp) / 1000);\r\nreturn tmp;\r\n}\r\nunsigned char da9052_determine_vc_tbl_index(unsigned char adc_temp)\r\n{\r\nint i;\r\nif (adc_temp <= vc_tbl_ref[0])\r\nreturn 0;\r\nif (adc_temp > vc_tbl_ref[DA9052_VC_TBL_REF_SZ - 1])\r\nreturn DA9052_VC_TBL_REF_SZ - 1;\r\nfor (i = 0; i < DA9052_VC_TBL_REF_SZ; i++) {\r\nif ((adc_temp > vc_tbl_ref[i]) &&\r\n(adc_temp <= DA9052_MEAN(vc_tbl_ref[i], vc_tbl_ref[i + 1])))\r\nreturn i;\r\nif ((adc_temp > DA9052_MEAN(vc_tbl_ref[i], vc_tbl_ref[i + 1]))\r\n&& (adc_temp <= vc_tbl_ref[i]))\r\nreturn i + 1;\r\n}\r\n}\r\nstatic int da9052_bat_read_capacity(struct da9052_battery *bat, int *capacity)\r\n{\r\nint adc_temp;\r\nint bat_voltage;\r\nint vbat_lower;\r\nint vbat_upper;\r\nint level_upper;\r\nint level_lower;\r\nint ret;\r\nint flag;\r\nint i = 0;\r\nint j;\r\nret = da9052_bat_read_volt(bat, &bat_voltage);\r\nif (ret < 0)\r\nreturn ret;\r\nadc_temp = da9052_adc_read_temp(bat->da9052);\r\nif (adc_temp < 0)\r\nreturn adc_temp;\r\ni = da9052_determine_vc_tbl_index(adc_temp);\r\nif (bat_voltage >= vc_tbl[i][0][0]) {\r\n*capacity = 100;\r\nreturn 0;\r\n}\r\nif (bat_voltage <= vc_tbl[i][DA9052_VC_TBL_SZ - 1][0]) {\r\n*capacity = 0;\r\nreturn 0;\r\n}\r\nflag = 0;\r\nfor (j = 0; j < (DA9052_VC_TBL_SZ-1); j++) {\r\nif ((bat_voltage <= vc_tbl[i][j][0]) &&\r\n(bat_voltage >= vc_tbl[i][j + 1][0])) {\r\nvbat_upper = vc_tbl[i][j][0];\r\nvbat_lower = vc_tbl[i][j + 1][0];\r\nlevel_upper = vc_tbl[i][j][1];\r\nlevel_lower = vc_tbl[i][j + 1][1];\r\nflag = 1;\r\nbreak;\r\n}\r\n}\r\nif (!flag)\r\nreturn -EIO;\r\n*capacity = da9052_bat_interpolate(vbat_lower, vbat_upper, level_lower,\r\nlevel_upper, bat_voltage);\r\nreturn 0;\r\n}\r\nstatic int da9052_bat_check_health(struct da9052_battery *bat, int *health)\r\n{\r\nint ret;\r\nint bat_illegal;\r\nint capacity;\r\nret = da9052_bat_check_presence(bat, &bat_illegal);\r\nif (ret < 0)\r\nreturn ret;\r\nif (bat_illegal) {\r\nbat->health = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nreturn 0;\r\n}\r\nif (bat->health != POWER_SUPPLY_HEALTH_OVERHEAT) {\r\nret = da9052_bat_read_capacity(bat, &capacity);\r\nif (ret < 0)\r\nreturn ret;\r\nif (capacity < DA9052_BAT_LOW_CAP)\r\nbat->health = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\nbat->health = POWER_SUPPLY_HEALTH_GOOD;\r\n}\r\n*health = bat->health;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t da9052_bat_irq(int irq, void *data)\r\n{\r\nstruct da9052_battery *bat = data;\r\nirq -= bat->da9052->irq_base;\r\nif (irq == DA9052_IRQ_CHGEND)\r\nbat->status = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nda9052_bat_check_status(bat, NULL);\r\nif (irq == DA9052_IRQ_CHGEND || irq == DA9052_IRQ_DCIN ||\r\nirq == DA9052_IRQ_VBUS || irq == DA9052_IRQ_TBAT) {\r\npower_supply_changed(&bat->psy);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int da9052_USB_current_notifier(struct notifier_block *nb,\r\nunsigned long events, void *data)\r\n{\r\nu8 row;\r\nu8 col;\r\nint *current_mA = data;\r\nint ret;\r\nstruct da9052_battery *bat = container_of(nb, struct da9052_battery,\r\nnb);\r\nif (bat->status == POWER_SUPPLY_STATUS_DISCHARGING)\r\nreturn -EPERM;\r\nret = da9052_reg_read(bat->da9052, DA9052_CHGBUCK_REG);\r\nif (ret & DA9052_CHG_USB_ILIM_MASK)\r\nreturn -EPERM;\r\nif (bat->da9052->chip_id == DA9052)\r\nrow = 0;\r\nelse\r\nrow = 1;\r\nif (*current_mA < da9052_chg_current_lim[row][0] ||\r\n*current_mA > da9052_chg_current_lim[row][DA9052_CHG_LIM_COLS - 1])\r\nreturn -EINVAL;\r\nfor (col = 0; col <= DA9052_CHG_LIM_COLS - 1 ; col++) {\r\nif (*current_mA <= da9052_chg_current_lim[row][col])\r\nbreak;\r\n}\r\nreturn da9052_reg_update(bat->da9052, DA9052_ISET_REG,\r\nDA9052_ISET_USB_MASK, col);\r\n}\r\nstatic int da9052_bat_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret;\r\nint illegal;\r\nstruct da9052_battery *bat = container_of(psy, struct da9052_battery,\r\npsy);\r\nret = da9052_bat_check_presence(bat, &illegal);\r\nif (ret < 0)\r\nreturn ret;\r\nif (illegal && psp != POWER_SUPPLY_PROP_PRESENT)\r\nreturn -ENODEV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nret = da9052_bat_check_status(bat, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval =\r\n(bat->charger_type == DA9052_NOCHARGER) ? 0 : 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nret = da9052_bat_check_presence(bat, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nret = da9052_bat_check_health(bat, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = DA9052_BAT_CUTOFF_VOLT * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\nret = da9052_bat_read_volt(bat, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nret = da9052_read_chg_current(bat, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = da9052_bat_read_capacity(bat, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval = da9052_adc_read_temp(bat->da9052);\r\nret = val->intval;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic s32 __devinit da9052_bat_probe(struct platform_device *pdev)\r\n{\r\nstruct da9052_pdata *pdata;\r\nstruct da9052_battery *bat;\r\nint ret;\r\nint irq;\r\nint i;\r\nbat = kzalloc(sizeof(struct da9052_battery), GFP_KERNEL);\r\nif (!bat)\r\nreturn -ENOMEM;\r\nbat->da9052 = dev_get_drvdata(pdev->dev.parent);\r\nbat->psy = template_battery;\r\nbat->charger_type = DA9052_NOCHARGER;\r\nbat->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbat->health = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nbat->nb.notifier_call = da9052_USB_current_notifier;\r\npdata = bat->da9052->dev->platform_data;\r\nif (pdata != NULL && pdata->use_for_apm)\r\nbat->psy.use_for_apm = pdata->use_for_apm;\r\nelse\r\nbat->psy.use_for_apm = 1;\r\nfor (i = 0; i < ARRAY_SIZE(da9052_bat_irqs); i++) {\r\nirq = platform_get_irq_byname(pdev, da9052_bat_irqs[i]);\r\nret = request_threaded_irq(bat->da9052->irq_base + irq,\r\nNULL, da9052_bat_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nda9052_bat_irqs[i], bat);\r\nif (ret != 0) {\r\ndev_err(bat->da9052->dev,\r\n"DA9052 failed to request %s IRQ %d: %d\n",\r\nda9052_bat_irqs[i], irq, ret);\r\ngoto err;\r\n}\r\n}\r\nret = power_supply_register(&pdev->dev, &bat->psy);\r\nif (ret)\r\ngoto err;\r\nplatform_set_drvdata(pdev, bat);\r\nreturn 0;\r\nerr:\r\nfor (; i >= 0; i--) {\r\nirq = platform_get_irq_byname(pdev, da9052_bat_irqs[i]);\r\nfree_irq(bat->da9052->irq_base + irq, bat);\r\n}\r\nkfree(bat);\r\nreturn ret;\r\n}\r\nstatic int __devexit da9052_bat_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nint irq;\r\nstruct da9052_battery *bat = platform_get_drvdata(pdev);\r\nfor (i = 0; i < ARRAY_SIZE(da9052_bat_irqs); i++) {\r\nirq = platform_get_irq_byname(pdev, da9052_bat_irqs[i]);\r\nfree_irq(bat->da9052->irq_base + irq, bat);\r\n}\r\npower_supply_unregister(&bat->psy);\r\nkfree(bat);\r\nreturn 0;\r\n}
