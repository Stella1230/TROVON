static int set_update_marker(struct ubi_device *ubi, struct ubi_volume *vol)\r\n{\r\nint err;\r\nstruct ubi_vtbl_record vtbl_rec;\r\ndbg_gen("set update marker for volume %d", vol->vol_id);\r\nif (vol->upd_marker) {\r\nubi_assert(ubi->vtbl[vol->vol_id].upd_marker);\r\ndbg_gen("already set");\r\nreturn 0;\r\n}\r\nmemcpy(&vtbl_rec, &ubi->vtbl[vol->vol_id],\r\nsizeof(struct ubi_vtbl_record));\r\nvtbl_rec.upd_marker = 1;\r\nmutex_lock(&ubi->device_mutex);\r\nerr = ubi_change_vtbl_record(ubi, vol->vol_id, &vtbl_rec);\r\nvol->upd_marker = 1;\r\nmutex_unlock(&ubi->device_mutex);\r\nreturn err;\r\n}\r\nstatic int clear_update_marker(struct ubi_device *ubi, struct ubi_volume *vol,\r\nlong long bytes)\r\n{\r\nint err;\r\nstruct ubi_vtbl_record vtbl_rec;\r\ndbg_gen("clear update marker for volume %d", vol->vol_id);\r\nmemcpy(&vtbl_rec, &ubi->vtbl[vol->vol_id],\r\nsizeof(struct ubi_vtbl_record));\r\nubi_assert(vol->upd_marker && vtbl_rec.upd_marker);\r\nvtbl_rec.upd_marker = 0;\r\nif (vol->vol_type == UBI_STATIC_VOLUME) {\r\nvol->corrupted = 0;\r\nvol->used_bytes = bytes;\r\nvol->used_ebs = div_u64_rem(bytes, vol->usable_leb_size,\r\n&vol->last_eb_bytes);\r\nif (vol->last_eb_bytes)\r\nvol->used_ebs += 1;\r\nelse\r\nvol->last_eb_bytes = vol->usable_leb_size;\r\n}\r\nmutex_lock(&ubi->device_mutex);\r\nerr = ubi_change_vtbl_record(ubi, vol->vol_id, &vtbl_rec);\r\nvol->upd_marker = 0;\r\nmutex_unlock(&ubi->device_mutex);\r\nreturn err;\r\n}\r\nint ubi_start_update(struct ubi_device *ubi, struct ubi_volume *vol,\r\nlong long bytes)\r\n{\r\nint i, err;\r\ndbg_gen("start update of volume %d, %llu bytes", vol->vol_id, bytes);\r\nubi_assert(!vol->updating && !vol->changing_leb);\r\nvol->updating = 1;\r\nerr = set_update_marker(ubi, vol);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < vol->reserved_pebs; i++) {\r\nerr = ubi_eba_unmap_leb(ubi, vol, i);\r\nif (err)\r\nreturn err;\r\n}\r\nif (bytes == 0) {\r\nerr = ubi_wl_flush(ubi, UBI_ALL, UBI_ALL);\r\nif (err)\r\nreturn err;\r\nerr = clear_update_marker(ubi, vol, 0);\r\nif (err)\r\nreturn err;\r\nvol->updating = 0;\r\nreturn 0;\r\n}\r\nvol->upd_buf = vmalloc(ubi->leb_size);\r\nif (!vol->upd_buf)\r\nreturn -ENOMEM;\r\nvol->upd_ebs = div_u64(bytes + vol->usable_leb_size - 1,\r\nvol->usable_leb_size);\r\nvol->upd_bytes = bytes;\r\nvol->upd_received = 0;\r\nreturn 0;\r\n}\r\nint ubi_start_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,\r\nconst struct ubi_leb_change_req *req)\r\n{\r\nubi_assert(!vol->updating && !vol->changing_leb);\r\ndbg_gen("start changing LEB %d:%d, %u bytes",\r\nvol->vol_id, req->lnum, req->bytes);\r\nif (req->bytes == 0)\r\nreturn ubi_eba_atomic_leb_change(ubi, vol, req->lnum, NULL, 0);\r\nvol->upd_bytes = req->bytes;\r\nvol->upd_received = 0;\r\nvol->changing_leb = 1;\r\nvol->ch_lnum = req->lnum;\r\nvol->upd_buf = vmalloc(req->bytes);\r\nif (!vol->upd_buf)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\r\nvoid *buf, int len, int used_ebs)\r\n{\r\nint err;\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\r\nint l = ALIGN(len, ubi->min_io_size);\r\nmemset(buf + len, 0xFF, l - len);\r\nlen = ubi_calc_data_len(ubi, buf, l);\r\nif (len == 0) {\r\ndbg_gen("all %d bytes contain 0xFF - skip", len);\r\nreturn 0;\r\n}\r\nerr = ubi_eba_write_leb(ubi, vol, lnum, buf, 0, len);\r\n} else {\r\nmemset(buf + len, 0, vol->usable_leb_size - len);\r\nerr = ubi_eba_write_leb_st(ubi, vol, lnum, buf, len, used_ebs);\r\n}\r\nreturn err;\r\n}\r\nint ubi_more_update_data(struct ubi_device *ubi, struct ubi_volume *vol,\r\nconst void __user *buf, int count)\r\n{\r\nint lnum, offs, err = 0, len, to_write = count;\r\ndbg_gen("write %d of %lld bytes, %lld already passed",\r\ncount, vol->upd_bytes, vol->upd_received);\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nlnum = div_u64_rem(vol->upd_received, vol->usable_leb_size, &offs);\r\nif (vol->upd_received + count > vol->upd_bytes)\r\nto_write = count = vol->upd_bytes - vol->upd_received;\r\nif (offs != 0) {\r\nlen = vol->usable_leb_size - offs;\r\nif (len > count)\r\nlen = count;\r\nerr = copy_from_user(vol->upd_buf + offs, buf, len);\r\nif (err)\r\nreturn -EFAULT;\r\nif (offs + len == vol->usable_leb_size ||\r\nvol->upd_received + len == vol->upd_bytes) {\r\nint flush_len = offs + len;\r\nubi_assert(flush_len <= vol->usable_leb_size);\r\nerr = write_leb(ubi, vol, lnum, vol->upd_buf, flush_len,\r\nvol->upd_ebs);\r\nif (err)\r\nreturn err;\r\n}\r\nvol->upd_received += len;\r\ncount -= len;\r\nbuf += len;\r\nlnum += 1;\r\n}\r\nwhile (count) {\r\nif (count > vol->usable_leb_size)\r\nlen = vol->usable_leb_size;\r\nelse\r\nlen = count;\r\nerr = copy_from_user(vol->upd_buf, buf, len);\r\nif (err)\r\nreturn -EFAULT;\r\nif (len == vol->usable_leb_size ||\r\nvol->upd_received + len == vol->upd_bytes) {\r\nerr = write_leb(ubi, vol, lnum, vol->upd_buf,\r\nlen, vol->upd_ebs);\r\nif (err)\r\nbreak;\r\n}\r\nvol->upd_received += len;\r\ncount -= len;\r\nlnum += 1;\r\nbuf += len;\r\n}\r\nubi_assert(vol->upd_received <= vol->upd_bytes);\r\nif (vol->upd_received == vol->upd_bytes) {\r\nerr = ubi_wl_flush(ubi, UBI_ALL, UBI_ALL);\r\nif (err)\r\nreturn err;\r\nerr = clear_update_marker(ubi, vol, vol->upd_bytes);\r\nif (err)\r\nreturn err;\r\nvol->updating = 0;\r\nerr = to_write;\r\nvfree(vol->upd_buf);\r\n}\r\nreturn err;\r\n}\r\nint ubi_more_leb_change_data(struct ubi_device *ubi, struct ubi_volume *vol,\r\nconst void __user *buf, int count)\r\n{\r\nint err;\r\ndbg_gen("write %d of %lld bytes, %lld already passed",\r\ncount, vol->upd_bytes, vol->upd_received);\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nif (vol->upd_received + count > vol->upd_bytes)\r\ncount = vol->upd_bytes - vol->upd_received;\r\nerr = copy_from_user(vol->upd_buf + vol->upd_received, buf, count);\r\nif (err)\r\nreturn -EFAULT;\r\nvol->upd_received += count;\r\nif (vol->upd_received == vol->upd_bytes) {\r\nint len = ALIGN((int)vol->upd_bytes, ubi->min_io_size);\r\nmemset(vol->upd_buf + vol->upd_bytes, 0xFF,\r\nlen - vol->upd_bytes);\r\nlen = ubi_calc_data_len(ubi, vol->upd_buf, len);\r\nerr = ubi_eba_atomic_leb_change(ubi, vol, vol->ch_lnum,\r\nvol->upd_buf, len);\r\nif (err)\r\nreturn err;\r\n}\r\nubi_assert(vol->upd_received <= vol->upd_bytes);\r\nif (vol->upd_received == vol->upd_bytes) {\r\nvol->changing_leb = 0;\r\nerr = count;\r\nvfree(vol->upd_buf);\r\n}\r\nreturn err;\r\n}
