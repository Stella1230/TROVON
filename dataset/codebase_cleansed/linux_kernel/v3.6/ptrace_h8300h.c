long h8300_get_reg(struct task_struct *task, int regno)\r\n{\r\nswitch (regno) {\r\ncase PT_USP:\r\nreturn task->thread.usp + sizeof(long)*2;\r\ncase PT_CCR:\r\nreturn *(unsigned short *)(task->thread.esp0 + h8300_register_offset[regno]);\r\ndefault:\r\nreturn *(unsigned long *)(task->thread.esp0 + h8300_register_offset[regno]);\r\n}\r\n}\r\nint h8300_put_reg(struct task_struct *task, int regno, unsigned long data)\r\n{\r\nunsigned short oldccr;\r\nswitch (regno) {\r\ncase PT_USP:\r\ntask->thread.usp = data - sizeof(long)*2;\r\ncase PT_CCR:\r\noldccr = *(unsigned short *)(task->thread.esp0 + h8300_register_offset[regno]);\r\noldccr &= ~CCR_MASK;\r\ndata &= CCR_MASK;\r\ndata |= oldccr;\r\n*(unsigned short *)(task->thread.esp0 + h8300_register_offset[regno]) = data;\r\nbreak;\r\ndefault:\r\n*(unsigned long *)(task->thread.esp0 + h8300_register_offset[regno]) = data;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid user_disable_single_step(struct task_struct *child)\r\n{\r\nif((long)child->thread.breakinfo.addr != -1L) {\r\n*child->thread.breakinfo.addr = child->thread.breakinfo.inst;\r\nchild->thread.breakinfo.addr = (unsigned short *)-1L;\r\n}\r\n}\r\nstatic int isbranch(struct task_struct *task,int reson)\r\n{\r\nunsigned char cond = h8300_get_reg(task, PT_CCR);\r\n__asm__("bld #3,%w0\n\t"\r\n"bxor #1,%w0\n\t"\r\n"bst #4,%w0\n\t"\r\n"bor #2,%w0\n\t"\r\n"bst #5,%w0\n\t"\r\n"bld #2,%w0\n\t"\r\n"bor #0,%w0\n\t"\r\n"bst #6,%w0\n\t"\r\n:"=&r"(cond)::"cc");\r\ncond &= condmask[reson >> 1];\r\nif (!(reson & 1))\r\nreturn cond == 0;\r\nelse\r\nreturn cond != 0;\r\n}\r\nstatic unsigned short *getnextpc(struct task_struct *child, unsigned short *pc)\r\n{\r\nconst struct optable *op;\r\nunsigned char *fetch_p;\r\nunsigned char inst;\r\nunsigned long addr;\r\nunsigned long *sp;\r\nint op_len,regno;\r\nop = optables[0].ptr;\r\nop_len = optables[0].size;\r\nfetch_p = (unsigned char *)pc;\r\ninst = *fetch_p++;\r\ndo {\r\nif ((inst & op->bitmask) == op->bitpattern) {\r\nif (op->length < 0) {\r\nop = optables[-op->length].ptr;\r\nop_len = optables[-op->length].size + 1;\r\ninst = *fetch_p++;\r\n} else {\r\nswitch (op->type) {\r\ncase none:\r\nreturn pc + op->length;\r\ncase jabs:\r\naddr = *(unsigned long *)pc;\r\nreturn (unsigned short *)(addr & 0x00ffffff);\r\ncase ind:\r\naddr = *pc & 0xff;\r\nreturn (unsigned short *)(*(unsigned long *)addr);\r\ncase ret:\r\nsp = (unsigned long *)h8300_get_reg(child, PT_USP);\r\nreturn (unsigned short *)(*(sp+2) & 0x00ffffff);\r\ncase reg:\r\nregno = (*pc >> 4) & 0x07;\r\nif (regno == 0)\r\naddr = h8300_get_reg(child, PT_ER0);\r\nelse\r\naddr = h8300_get_reg(child, regno-1+PT_ER1);\r\nreturn (unsigned short *)addr;\r\ncase relb:\r\nif (inst == 0x55 || isbranch(child,inst & 0x0f))\r\npc = (unsigned short *)((unsigned long)pc +\r\n((signed char)(*fetch_p)));\r\nreturn pc+1;\r\ncase relw:\r\nif (inst == 0x5c || isbranch(child,(*fetch_p & 0xf0) >> 4))\r\npc = (unsigned short *)((unsigned long)pc +\r\n((signed short)(*(pc+1))));\r\nreturn pc+2;\r\n}\r\n}\r\n} else\r\nop++;\r\n} while(--op_len > 0);\r\nreturn NULL;\r\n}\r\nvoid user_enable_single_step(struct task_struct *child)\r\n{\r\nunsigned short *nextpc;\r\nnextpc = getnextpc(child,(unsigned short *)h8300_get_reg(child, PT_PC));\r\nchild->thread.breakinfo.addr = nextpc;\r\nchild->thread.breakinfo.inst = *nextpc;\r\n*nextpc = BREAKINST;\r\n}\r\nasmlinkage void trace_trap(unsigned long bp)\r\n{\r\nif ((unsigned long)current->thread.breakinfo.addr == bp) {\r\nuser_disable_single_step(current);\r\nforce_sig(SIGTRAP,current);\r\n} else\r\nforce_sig(SIGILL,current);\r\n}
