static int easycap_audio_submit_urbs(struct easycap *peasycap)\r\n{\r\nstruct data_urb *pdata_urb;\r\nstruct urb *purb;\r\nstruct list_head *plist_head;\r\nint j, isbad, nospc, m, rc;\r\nint isbuf;\r\nif (!peasycap->purb_audio_head) {\r\nSAM("ERROR: peasycap->urb_audio_head uninitialized\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (peasycap->audio_isoc_streaming) {\r\nJOM(4, "already streaming audio urbs\n");\r\nreturn 0;\r\n}\r\nJOM(4, "initial submission of all audio urbs\n");\r\nrc = usb_set_interface(peasycap->pusb_device,\r\npeasycap->audio_interface,\r\npeasycap->audio_altsetting_on);\r\nJOM(8, "usb_set_interface(.,%i,%i) returned %i\n",\r\npeasycap->audio_interface,\r\npeasycap->audio_altsetting_on, rc);\r\nisbad = 0;\r\nnospc = 0;\r\nm = 0;\r\nlist_for_each(plist_head, peasycap->purb_audio_head) {\r\npdata_urb = list_entry(plist_head, struct data_urb, list_head);\r\nif (pdata_urb && pdata_urb->purb) {\r\npurb = pdata_urb->purb;\r\nisbuf = pdata_urb->isbuf;\r\npurb->interval = 1;\r\npurb->dev = peasycap->pusb_device;\r\npurb->pipe = usb_rcvisocpipe(peasycap->pusb_device,\r\npeasycap->audio_endpointnumber);\r\npurb->transfer_flags = URB_ISO_ASAP;\r\npurb->transfer_buffer = peasycap->audio_isoc_buffer[isbuf].pgo;\r\npurb->transfer_buffer_length = peasycap->audio_isoc_buffer_size;\r\npurb->complete = easycap_alsa_complete;\r\npurb->context = peasycap;\r\npurb->start_frame = 0;\r\npurb->number_of_packets = peasycap->audio_isoc_framesperdesc;\r\nfor (j = 0; j < peasycap->audio_isoc_framesperdesc; j++) {\r\npurb->iso_frame_desc[j].offset = j * peasycap->audio_isoc_maxframesize;\r\npurb->iso_frame_desc[j].length = peasycap->audio_isoc_maxframesize;\r\n}\r\nrc = usb_submit_urb(purb, GFP_KERNEL);\r\nif (rc) {\r\nisbad++;\r\nSAM("ERROR: usb_submit_urb() failed"\r\n" for urb with rc: -%s: %d\n",\r\nstrerror(rc), rc);\r\n} else {\r\nm++;\r\n}\r\n} else {\r\nisbad++;\r\n}\r\n}\r\nif (nospc) {\r\nSAM("-ENOSPC=usb_submit_urb() for %i urbs\n", nospc);\r\nSAM("..... possibly inadequate USB bandwidth\n");\r\npeasycap->audio_eof = 1;\r\n}\r\nif (isbad)\r\neasycap_audio_kill_urbs(peasycap);\r\nelse\r\npeasycap->audio_isoc_streaming = m;\r\nreturn 0;\r\n}\r\nstatic int easycap_sound_setup(struct easycap *peasycap)\r\n{\r\nint rc;\r\nJOM(4, "starting initialization\n");\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL.\n");\r\nreturn -EFAULT;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device is NULL\n");\r\nreturn -ENODEV;\r\n}\r\nJOM(16, "0x%08lX=peasycap->pusb_device\n", (long int)peasycap->pusb_device);\r\nrc = easycap_audio_setup(peasycap);\r\nJOM(8, "audio_setup() returned %i\n", rc);\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device has become NULL\n");\r\nreturn -ENODEV;\r\n}\r\nif (!peasycap->pusb_device) {\r\nSAM("ERROR: peasycap->pusb_device has become NULL\n");\r\nreturn -ENODEV;\r\n}\r\nrc = usb_set_interface(peasycap->pusb_device, peasycap->audio_interface,\r\npeasycap->audio_altsetting_on);\r\nJOM(8, "usb_set_interface(.,%i,%i) returned %i\n", peasycap->audio_interface,\r\npeasycap->audio_altsetting_on, rc);\r\nrc = easycap_wakeup_device(peasycap->pusb_device);\r\nJOM(8, "wakeup_device() returned %i\n", rc);\r\npeasycap->audio_eof = 0;\r\npeasycap->audio_idle = 0;\r\neasycap_audio_submit_urbs(peasycap);\r\nJOM(4, "finished initialization\n");\r\nreturn 0;\r\n}\r\nvoid easycap_alsa_complete(struct urb *purb)\r\n{\r\nstruct easycap *peasycap;\r\nstruct snd_pcm_substream *pss;\r\nstruct snd_pcm_runtime *prt;\r\nint dma_bytes, fragment_bytes;\r\nint isfragment;\r\nu8 *p1, *p2;\r\ns16 tmp;\r\nint i, j, more, much, rc;\r\n#ifdef UPSAMPLE\r\nint k;\r\ns16 oldaudio, newaudio, delta;\r\n#endif\r\nJOT(16, "\n");\r\nif (!purb) {\r\nSAY("ERROR: purb is NULL\n");\r\nreturn;\r\n}\r\npeasycap = purb->context;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn;\r\n}\r\nmuch = 0;\r\nif (peasycap->audio_idle) {\r\nJOM(16, "%i=audio_idle %i=audio_isoc_streaming\n",\r\npeasycap->audio_idle, peasycap->audio_isoc_streaming);\r\nif (peasycap->audio_isoc_streaming)\r\ngoto resubmit;\r\n}\r\npss = peasycap->psubstream;\r\nif (!pss)\r\ngoto resubmit;\r\nprt = pss->runtime;\r\nif (!prt)\r\ngoto resubmit;\r\ndma_bytes = (int)prt->dma_bytes;\r\nif (0 == dma_bytes)\r\ngoto resubmit;\r\nfragment_bytes = 4 * ((int)prt->period_size);\r\nif (0 == fragment_bytes)\r\ngoto resubmit;\r\nif (purb->status) {\r\nif ((-ESHUTDOWN == purb->status) || (-ENOENT == purb->status)) {\r\nJOM(16, "urb status -ESHUTDOWN or -ENOENT\n");\r\nreturn;\r\n}\r\nSAM("ERROR: non-zero urb status: -%s: %d\n",\r\nstrerror(purb->status), purb->status);\r\ngoto resubmit;\r\n}\r\n#ifdef UPSAMPLE\r\noldaudio = peasycap->oldaudio;\r\n#endif\r\nfor (i = 0; i < purb->number_of_packets; i++) {\r\nif (purb->iso_frame_desc[i].status < 0) {\r\nSAM("-%s: %d\n",\r\nstrerror(purb->iso_frame_desc[i].status),\r\npurb->iso_frame_desc[i].status);\r\n}\r\nif (purb->iso_frame_desc[i].status) {\r\nJOM(12, "discarding audio samples because "\r\n"%i=purb->iso_frame_desc[i].status\n",\r\npurb->iso_frame_desc[i].status);\r\ncontinue;\r\n}\r\nmore = purb->iso_frame_desc[i].actual_length;\r\nif (more == 0) {\r\npeasycap->audio_mt++;\r\ncontinue;\r\n}\r\nif (0 > more) {\r\nSAM("MISTAKE: more is negative\n");\r\nreturn;\r\n}\r\nif (peasycap->audio_mt) {\r\nJOM(12, "%4i empty audio urb frames\n",\r\npeasycap->audio_mt);\r\npeasycap->audio_mt = 0;\r\n}\r\np1 = (u8 *)(purb->transfer_buffer +\r\npurb->iso_frame_desc[i].offset);\r\nwhile (more) {\r\nmuch = dma_bytes - peasycap->dma_fill;\r\nif (0 > much) {\r\nSAM("MISTAKE: much is negative\n");\r\nreturn;\r\n}\r\nif (0 == much) {\r\npeasycap->dma_fill = 0;\r\npeasycap->dma_next = fragment_bytes;\r\nJOM(8, "wrapped dma buffer\n");\r\n}\r\nif (!peasycap->microphone) {\r\nif (much > more)\r\nmuch = more;\r\nmemcpy(prt->dma_area + peasycap->dma_fill,\r\np1, much);\r\np1 += much;\r\nmore -= much;\r\n} else {\r\n#ifdef UPSAMPLE\r\nif (much % 16)\r\nJOM(8, "MISTAKE? much"\r\n" is not divisible by 16\n");\r\nif (much > (16 * more))\r\nmuch = 16 * more;\r\np2 = (u8 *)(prt->dma_area + peasycap->dma_fill);\r\nfor (j = 0; j < (much / 16); j++) {\r\nnewaudio = ((int) *p1) - 128;\r\nnewaudio = 128 * newaudio;\r\ndelta = (newaudio - oldaudio) / 4;\r\ntmp = oldaudio + delta;\r\nfor (k = 0; k < 4; k++) {\r\n*p2 = (0x00FF & tmp);\r\n*(p2 + 1) = (0xFF00 & tmp) >> 8;\r\np2 += 2;\r\n*p2 = (0x00FF & tmp);\r\n*(p2 + 1) = (0xFF00 & tmp) >> 8;\r\np2 += 2;\r\ntmp += delta;\r\n}\r\np1++;\r\nmore--;\r\noldaudio = tmp;\r\n}\r\n#else\r\nif (much > (2 * more))\r\nmuch = 2 * more;\r\np2 = (u8 *)(prt->dma_area + peasycap->dma_fill);\r\nfor (j = 0; j < (much / 2); j++) {\r\ntmp = ((int) *p1) - 128;\r\ntmp = 128 * tmp;\r\n*p2 = (0x00FF & tmp);\r\n*(p2 + 1) = (0xFF00 & tmp) >> 8;\r\np1++;\r\np2 += 2;\r\nmore--;\r\n}\r\n#endif\r\n}\r\npeasycap->dma_fill += much;\r\nif (peasycap->dma_fill >= peasycap->dma_next) {\r\nisfragment = peasycap->dma_fill / fragment_bytes;\r\nif (0 > isfragment) {\r\nSAM("MISTAKE: isfragment is negative\n");\r\nreturn;\r\n}\r\npeasycap->dma_read = (isfragment - 1) * fragment_bytes;\r\npeasycap->dma_next = (isfragment + 1) * fragment_bytes;\r\nif (dma_bytes < peasycap->dma_next)\r\npeasycap->dma_next = fragment_bytes;\r\nif (0 <= peasycap->dma_read) {\r\nJOM(8, "snd_pcm_period_elapsed(), %i="\r\n"isfragment\n", isfragment);\r\nsnd_pcm_period_elapsed(pss);\r\n}\r\n}\r\n}\r\n#ifdef UPSAMPLE\r\npeasycap->oldaudio = oldaudio;\r\n#endif\r\n}\r\nresubmit:\r\nif (peasycap->audio_isoc_streaming == 0)\r\nreturn;\r\nrc = usb_submit_urb(purb, GFP_ATOMIC);\r\nif (rc) {\r\nif ((-ENODEV != rc) && (-ENOENT != rc)) {\r\nSAM("ERROR: while %i=audio_idle, usb_submit_urb failed "\r\n"with rc: -%s :%d\n",\r\npeasycap->audio_idle, strerror(rc), rc);\r\n}\r\nif (0 < peasycap->audio_isoc_streaming)\r\npeasycap->audio_isoc_streaming--;\r\n}\r\nreturn;\r\n}\r\nstatic int easycap_alsa_open(struct snd_pcm_substream *pss)\r\n{\r\nstruct snd_pcm *psnd_pcm;\r\nstruct snd_card *psnd_card;\r\nstruct easycap *peasycap;\r\nJOT(4, "\n");\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npsnd_pcm = pss->pcm;\r\nif (!psnd_pcm) {\r\nSAY("ERROR: psnd_pcm is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npsnd_card = psnd_pcm->card;\r\nif (!psnd_card) {\r\nSAY("ERROR: psnd_card is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npeasycap = psnd_card->private_data;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (peasycap->psnd_card != psnd_card) {\r\nSAM("ERROR: bad peasycap->psnd_card\n");\r\nreturn -EFAULT;\r\n}\r\nif (peasycap->psubstream) {\r\nSAM("ERROR: bad peasycap->psubstream\n");\r\nreturn -EFAULT;\r\n}\r\npss->private_data = peasycap;\r\npeasycap->psubstream = pss;\r\npss->runtime->hw = peasycap->alsa_hardware;\r\npss->runtime->private_data = peasycap;\r\npss->private_data = peasycap;\r\nif (0 != easycap_sound_setup(peasycap)) {\r\nJOM(4, "ending unsuccessfully\n");\r\nreturn -EFAULT;\r\n}\r\nJOM(4, "ending successfully\n");\r\nreturn 0;\r\n}\r\nstatic int easycap_alsa_close(struct snd_pcm_substream *pss)\r\n{\r\nstruct easycap *peasycap;\r\nJOT(4, "\n");\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npeasycap = snd_pcm_substream_chip(pss);\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npss->private_data = NULL;\r\npeasycap->psubstream = NULL;\r\nJOT(4, "ending successfully\n");\r\nreturn 0;\r\n}\r\nstatic int easycap_alsa_vmalloc(struct snd_pcm_substream *pss, size_t sz)\r\n{\r\nstruct snd_pcm_runtime *prt;\r\nJOT(4, "\n");\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nprt = pss->runtime;\r\nif (!prt) {\r\nSAY("ERROR: substream.runtime is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (prt->dma_area) {\r\nif (prt->dma_bytes > sz)\r\nreturn 0;\r\nvfree(prt->dma_area);\r\n}\r\nprt->dma_area = vmalloc(sz);\r\nif (!prt->dma_area)\r\nreturn -ENOMEM;\r\nprt->dma_bytes = sz;\r\nreturn 0;\r\n}\r\nstatic int easycap_alsa_hw_params(struct snd_pcm_substream *pss,\r\nstruct snd_pcm_hw_params *phw)\r\n{\r\nint rc;\r\nJOT(4, "%i\n", (params_buffer_bytes(phw)));\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nrc = easycap_alsa_vmalloc(pss, params_buffer_bytes(phw));\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int easycap_alsa_hw_free(struct snd_pcm_substream *pss)\r\n{\r\nstruct snd_pcm_runtime *prt;\r\nJOT(4, "\n");\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nprt = pss->runtime;\r\nif (!prt) {\r\nSAY("ERROR: substream.runtime is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (prt->dma_area) {\r\nJOT(8, "prt->dma_area = %p\n", prt->dma_area);\r\nvfree(prt->dma_area);\r\nprt->dma_area = NULL;\r\n} else\r\nJOT(8, "dma_area already freed\n");\r\nreturn 0;\r\n}\r\nstatic int easycap_alsa_prepare(struct snd_pcm_substream *pss)\r\n{\r\nstruct easycap *peasycap;\r\nstruct snd_pcm_runtime *prt;\r\nJOT(4, "\n");\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nprt = pss->runtime;\r\npeasycap = snd_pcm_substream_chip(pss);\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nJOM(16, "ALSA decides %8i Hz=rate\n", pss->runtime->rate);\r\nJOM(16, "ALSA decides %8ld =period_size\n", pss->runtime->period_size);\r\nJOM(16, "ALSA decides %8i =periods\n", pss->runtime->periods);\r\nJOM(16, "ALSA decides %8ld =buffer_size\n", pss->runtime->buffer_size);\r\nJOM(16, "ALSA decides %8zd =dma_bytes\n", pss->runtime->dma_bytes);\r\nJOM(16, "ALSA decides %8ld =boundary\n", pss->runtime->boundary);\r\nJOM(16, "ALSA decides %8i =period_step\n", pss->runtime->period_step);\r\nJOM(16, "ALSA decides %8i =sample_bits\n", pss->runtime->sample_bits);\r\nJOM(16, "ALSA decides %8i =frame_bits\n", pss->runtime->frame_bits);\r\nJOM(16, "ALSA decides %8ld =min_align\n", pss->runtime->min_align);\r\nJOM(12, "ALSA decides %8ld =hw_ptr_base\n", pss->runtime->hw_ptr_base);\r\nJOM(12, "ALSA decides %8ld =hw_ptr_interrupt\n",\r\npss->runtime->hw_ptr_interrupt);\r\nif (prt->dma_bytes != 4 * ((int)prt->period_size) * ((int)prt->periods)) {\r\nSAY("MISTAKE: unexpected ALSA parameters\n");\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int easycap_alsa_ack(struct snd_pcm_substream *pss)\r\n{\r\nreturn 0;\r\n}\r\nstatic int easycap_alsa_trigger(struct snd_pcm_substream *pss, int cmd)\r\n{\r\nstruct easycap *peasycap;\r\nJOT(4, "%i=cmd cf %i=START %i=STOP\n", cmd, SNDRV_PCM_TRIGGER_START,\r\nSNDRV_PCM_TRIGGER_STOP);\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npeasycap = snd_pcm_substream_chip(pss);\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START: {\r\npeasycap->audio_idle = 0;\r\nbreak;\r\n}\r\ncase SNDRV_PCM_TRIGGER_STOP: {\r\npeasycap->audio_idle = 1;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t easycap_alsa_pointer(struct snd_pcm_substream *pss)\r\n{\r\nstruct easycap *peasycap;\r\nsnd_pcm_uframes_t offset;\r\nJOT(16, "\n");\r\nif (!pss) {\r\nSAY("ERROR: pss is NULL\n");\r\nreturn -EFAULT;\r\n}\r\npeasycap = snd_pcm_substream_chip(pss);\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif ((0 != peasycap->audio_eof) || (0 != peasycap->audio_idle)) {\r\nJOM(8, "returning -EIO because "\r\n"%i=audio_idle %i=audio_eof\n",\r\npeasycap->audio_idle, peasycap->audio_eof);\r\nreturn -EIO;\r\n}\r\nif (0 > peasycap->dma_read) {\r\nJOM(8, "returning -EBUSY\n");\r\nreturn -EBUSY;\r\n}\r\noffset = ((snd_pcm_uframes_t)peasycap->dma_read)/4;\r\nJOM(8, "ALSA decides %8i =hw_ptr_base\n", (int)pss->runtime->hw_ptr_base);\r\nJOM(8, "ALSA decides %8i =hw_ptr_interrupt\n",\r\n(int)pss->runtime->hw_ptr_interrupt);\r\nJOM(8, "%7i=offset %7i=dma_read %7i=dma_next\n",\r\n(int)offset, peasycap->dma_read, peasycap->dma_next);\r\nreturn offset;\r\n}\r\nstatic struct page *\r\neasycap_alsa_page(struct snd_pcm_substream *pss, unsigned long offset)\r\n{\r\nreturn vmalloc_to_page(pss->runtime->dma_area + offset);\r\n}\r\nint easycap_alsa_probe(struct easycap *peasycap)\r\n{\r\nint rc;\r\nstruct snd_card *psnd_card;\r\nstruct snd_pcm *psnd_pcm;\r\nif (!peasycap) {\r\nSAY("ERROR: peasycap is NULL\n");\r\nreturn -ENODEV;\r\n}\r\nif (0 > peasycap->minor) {\r\nSAY("ERROR: no minor\n");\r\nreturn -ENODEV;\r\n}\r\npeasycap->alsa_hardware = alsa_hardware;\r\nif (peasycap->microphone) {\r\npeasycap->alsa_hardware.rates = SNDRV_PCM_RATE_32000;\r\npeasycap->alsa_hardware.rate_min = 32000;\r\npeasycap->alsa_hardware.rate_max = 32000;\r\n} else {\r\npeasycap->alsa_hardware.rates = SNDRV_PCM_RATE_48000;\r\npeasycap->alsa_hardware.rate_min = 48000;\r\npeasycap->alsa_hardware.rate_max = 48000;\r\n}\r\nif (0 != snd_card_create(SNDRV_DEFAULT_IDX1, "easycap_alsa",\r\nTHIS_MODULE, 0, &psnd_card)) {\r\nSAY("ERROR: Cannot do ALSA snd_card_create()\n");\r\nreturn -EFAULT;\r\n}\r\nsprintf(&psnd_card->id[0], "EasyALSA%i", peasycap->minor);\r\nstrcpy(&psnd_card->driver[0], EASYCAP_DRIVER_DESCRIPTION);\r\nstrcpy(&psnd_card->shortname[0], "easycap_alsa");\r\nsprintf(&psnd_card->longname[0], "%s", &psnd_card->shortname[0]);\r\npsnd_card->dev = &peasycap->pusb_device->dev;\r\npsnd_card->private_data = peasycap;\r\npeasycap->psnd_card = psnd_card;\r\nrc = snd_pcm_new(psnd_card, "easycap_pcm", 0, 0, 1, &psnd_pcm);\r\nif (rc) {\r\nSAM("ERROR: Cannot do ALSA snd_pcm_new()\n");\r\nsnd_card_free(psnd_card);\r\nreturn -EFAULT;\r\n}\r\nsnd_pcm_set_ops(psnd_pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&easycap_alsa_pcm_ops);\r\npsnd_pcm->info_flags = 0;\r\nstrcpy(&psnd_pcm->name[0], &psnd_card->id[0]);\r\npsnd_pcm->private_data = peasycap;\r\npeasycap->psnd_pcm = psnd_pcm;\r\npeasycap->psubstream = NULL;\r\nrc = snd_card_register(psnd_card);\r\nif (rc) {\r\nSAM("ERROR: Cannot do ALSA snd_card_register()\n");\r\nsnd_card_free(psnd_card);\r\nreturn -EFAULT;\r\n}\r\nSAM("registered %s\n", &psnd_card->id[0]);\r\nreturn 0;\r\n}
