static int sh_csi2_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct sh_csi2 *priv = container_of(sd, struct sh_csi2, subdev);\r\nstruct sh_csi2_pdata *pdata = priv->pdev->dev.platform_data;\r\nif (mf->width > 8188)\r\nmf->width = 8188;\r\nelse if (mf->width & 1)\r\nmf->width &= ~1;\r\nswitch (pdata->type) {\r\ncase SH_CSI2C:\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ncase V4L2_MBUS_FMT_YUYV8_1_5X8:\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\ncase V4L2_MBUS_FMT_SBGGR8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG8_1X8:\r\nbreak;\r\ndefault:\r\nmf->code = V4L2_MBUS_FMT_YUYV8_2X8;\r\n}\r\nbreak;\r\ncase SH_CSI2I:\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\ncase V4L2_MBUS_FMT_SBGGR8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG8_1X8:\r\ncase V4L2_MBUS_FMT_SBGGR10_1X10:\r\ncase V4L2_MBUS_FMT_SBGGR12_1X12:\r\nbreak;\r\ndefault:\r\nmf->code = V4L2_MBUS_FMT_SBGGR8_1X8;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_csi2_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct sh_csi2 *priv = container_of(sd, struct sh_csi2, subdev);\r\nu32 tmp = (priv->client->channel & 3) << 8;\r\ndev_dbg(sd->v4l2_dev->dev, "%s(%u)\n", __func__, mf->code);\r\nif (mf->width > 8188 || mf->width & 1)\r\nreturn -EINVAL;\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ntmp |= 0x1e;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YUYV8_1_5X8:\r\ntmp |= 0x18;\r\nbreak;\r\ncase V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE:\r\ntmp |= 0x21;\r\nbreak;\r\ncase V4L2_MBUS_FMT_RGB565_2X8_BE:\r\ntmp |= 0x22;\r\nbreak;\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\ncase V4L2_MBUS_FMT_SBGGR8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG8_1X8:\r\ntmp |= 0x2a;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\niowrite32(tmp, priv->base + SH_CSI2_VCDT);\r\nreturn 0;\r\n}\r\nstatic int sh_csi2_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_MASTER | V4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\nreturn 0;\r\n}\r\nstatic int sh_csi2_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nstruct sh_csi2 *priv = container_of(sd, struct sh_csi2, subdev);\r\nstruct soc_camera_device *icd = v4l2_get_subdev_hostdata(sd);\r\nstruct v4l2_subdev *client_sd = soc_camera_to_subdev(icd);\r\nstruct v4l2_mbus_config client_cfg = {.type = V4L2_MBUS_CSI2,\r\n.flags = priv->mipi_flags};\r\nreturn v4l2_subdev_call(client_sd, video, s_mbus_config, &client_cfg);\r\n}\r\nstatic void sh_csi2_hwinit(struct sh_csi2 *priv)\r\n{\r\nstruct sh_csi2_pdata *pdata = priv->pdev->dev.platform_data;\r\n__u32 tmp = 0x10;\r\niowrite32(0x00000001, priv->base + SH_CSI2_TREF);\r\niowrite32(0x00000001, priv->base + SH_CSI2_SRST);\r\nudelay(5);\r\niowrite32(0x00000000, priv->base + SH_CSI2_SRST);\r\nswitch (pdata->type) {\r\ncase SH_CSI2C:\r\nif (priv->client->lanes == 1)\r\ntmp |= 1;\r\nelse\r\ntmp |= 3;\r\nbreak;\r\ncase SH_CSI2I:\r\nif (!priv->client->lanes || priv->client->lanes > 4)\r\ntmp |= 0xf;\r\nelse\r\ntmp |= (1 << priv->client->lanes) - 1;\r\n}\r\nif (priv->client->phy == SH_CSI2_PHY_MAIN)\r\ntmp |= 0x8000;\r\niowrite32(tmp, priv->base + SH_CSI2_PHYCNT);\r\ntmp = 0;\r\nif (pdata->flags & SH_CSI2_ECC)\r\ntmp |= 2;\r\nif (pdata->flags & SH_CSI2_CRC)\r\ntmp |= 1;\r\niowrite32(tmp, priv->base + SH_CSI2_CHKSUM);\r\n}\r\nstatic int sh_csi2_client_connect(struct sh_csi2 *priv)\r\n{\r\nstruct sh_csi2_pdata *pdata = priv->pdev->dev.platform_data;\r\nstruct soc_camera_device *icd = v4l2_get_subdev_hostdata(&priv->subdev);\r\nstruct v4l2_subdev *client_sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = v4l2_get_subdevdata(&priv->subdev);\r\nstruct v4l2_mbus_config cfg;\r\nunsigned long common_flags, csi2_flags;\r\nint i, ret;\r\nif (priv->client)\r\nreturn -EBUSY;\r\nfor (i = 0; i < pdata->num_clients; i++)\r\nif (&pdata->clients[i].pdev->dev == icd->pdev)\r\nbreak;\r\ndev_dbg(dev, "%s(%p): found #%d\n", __func__, dev, i);\r\nif (i == pdata->num_clients)\r\nreturn -ENODEV;\r\ncsi2_flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK | V4L2_MBUS_CSI2_1_LANE;\r\nswitch (pdata->type) {\r\ncase SH_CSI2C:\r\nif (pdata->clients[i].lanes != 1)\r\ncsi2_flags |= V4L2_MBUS_CSI2_2_LANE;\r\nbreak;\r\ncase SH_CSI2I:\r\nswitch (pdata->clients[i].lanes) {\r\ndefault:\r\ncsi2_flags |= V4L2_MBUS_CSI2_4_LANE;\r\ncase 3:\r\ncsi2_flags |= V4L2_MBUS_CSI2_3_LANE;\r\ncase 2:\r\ncsi2_flags |= V4L2_MBUS_CSI2_2_LANE;\r\n}\r\n}\r\ncfg.type = V4L2_MBUS_CSI2;\r\nret = v4l2_subdev_call(client_sd, video, g_mbus_config, &cfg);\r\nif (ret == -ENOIOCTLCMD)\r\ncommon_flags = csi2_flags;\r\nelse if (!ret)\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\ncsi2_flags);\r\nelse\r\ncommon_flags = 0;\r\nif (!common_flags)\r\nreturn -EINVAL;\r\npriv->mipi_flags = common_flags;\r\npriv->client = pdata->clients + i;\r\npm_runtime_get_sync(dev);\r\nsh_csi2_hwinit(priv);\r\nreturn 0;\r\n}\r\nstatic void sh_csi2_client_disconnect(struct sh_csi2 *priv)\r\n{\r\nif (!priv->client)\r\nreturn;\r\npriv->client = NULL;\r\npm_runtime_put(v4l2_get_subdevdata(&priv->subdev));\r\n}\r\nstatic int sh_csi2_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct sh_csi2 *priv = container_of(sd, struct sh_csi2, subdev);\r\nif (on)\r\nreturn sh_csi2_client_connect(priv);\r\nsh_csi2_client_disconnect(priv);\r\nreturn 0;\r\n}\r\nstatic __devinit int sh_csi2_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nunsigned int irq;\r\nint ret;\r\nstruct sh_csi2 *priv;\r\nstruct sh_csi2_pdata *pdata = pdev->dev.platform_data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || (int)irq <= 0 || !pdata) {\r\ndev_err(&pdev->dev, "Not enough CSI2 platform resources.\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata->type != SH_CSI2C) {\r\ndev_err(&pdev->dev, "Only CSI2C supported ATM.\n");\r\nreturn -EINVAL;\r\n}\r\npriv = kzalloc(sizeof(struct sh_csi2), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->irq = irq;\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\ndev_err(&pdev->dev, "CSI2 register region already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqreg;\r\n}\r\npriv->base = ioremap(res->start, resource_size(res));\r\nif (!priv->base) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "Unable to ioremap CSI2 registers.\n");\r\ngoto eremap;\r\n}\r\npriv->pdev = pdev;\r\nplatform_set_drvdata(pdev, priv);\r\nv4l2_subdev_init(&priv->subdev, &sh_csi2_subdev_ops);\r\nv4l2_set_subdevdata(&priv->subdev, &pdev->dev);\r\nsnprintf(priv->subdev.name, V4L2_SUBDEV_NAME_SIZE, "%s.mipi-csi",\r\ndev_name(pdata->v4l2_dev->dev));\r\nret = v4l2_device_register_subdev(pdata->v4l2_dev, &priv->subdev);\r\ndev_dbg(&pdev->dev, "%s(%p): ret(register_subdev) = %d\n", __func__, priv, ret);\r\nif (ret < 0)\r\ngoto esdreg;\r\npm_runtime_enable(&pdev->dev);\r\ndev_dbg(&pdev->dev, "CSI2 probed.\n");\r\nreturn 0;\r\nesdreg:\r\niounmap(priv->base);\r\neremap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nereqreg:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic __devexit int sh_csi2_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_csi2 *priv = platform_get_drvdata(pdev);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nv4l2_device_unregister_subdev(&priv->subdev);\r\npm_runtime_disable(&pdev->dev);\r\niounmap(priv->base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(priv);\r\nreturn 0;\r\n}
