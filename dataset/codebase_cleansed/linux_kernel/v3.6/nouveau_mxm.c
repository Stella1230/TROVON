static u8 *\r\nmxms_data(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nreturn dev_priv->mxms;\r\n}\r\nstatic u16\r\nmxms_version(struct drm_device *dev)\r\n{\r\nu8 *mxms = mxms_data(dev);\r\nu16 version = (mxms[4] << 8) | mxms[5];\r\nswitch (version ) {\r\ncase 0x0200:\r\ncase 0x0201:\r\ncase 0x0300:\r\nreturn version;\r\ndefault:\r\nbreak;\r\n}\r\nMXM_DBG(dev, "unknown version %d.%d\n", mxms[4], mxms[5]);\r\nreturn 0x0000;\r\n}\r\nstatic u16\r\nmxms_headerlen(struct drm_device *dev)\r\n{\r\nreturn 8;\r\n}\r\nstatic u16\r\nmxms_structlen(struct drm_device *dev)\r\n{\r\nreturn *(u16 *)&mxms_data(dev)[6];\r\n}\r\nstatic bool\r\nmxms_checksum(struct drm_device *dev)\r\n{\r\nu16 size = mxms_headerlen(dev) + mxms_structlen(dev);\r\nu8 *mxms = mxms_data(dev), sum = 0;\r\nwhile (size--)\r\nsum += *mxms++;\r\nif (sum) {\r\nMXM_DBG(dev, "checksum invalid\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nmxms_valid(struct drm_device *dev)\r\n{\r\nu8 *mxms = mxms_data(dev);\r\nif (*(u32 *)mxms != 0x5f4d584d) {\r\nMXM_DBG(dev, "signature invalid\n");\r\nreturn false;\r\n}\r\nif (!mxms_version(dev) || !mxms_checksum(dev))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nmxms_foreach(struct drm_device *dev, u8 types,\r\nbool (*exec)(struct drm_device *, u8 *, void *), void *info)\r\n{\r\nu8 *mxms = mxms_data(dev);\r\nu8 *desc = mxms + mxms_headerlen(dev);\r\nu8 *fini = desc + mxms_structlen(dev) - 1;\r\nwhile (desc < fini) {\r\nu8 type = desc[0] & 0x0f;\r\nu8 headerlen = 0;\r\nu8 recordlen = 0;\r\nu8 entries = 0;\r\nswitch (type) {\r\ncase 0:\r\nif (mxms_version(dev) >= 0x0300)\r\nheaderlen = 8;\r\nelse\r\nheaderlen = 6;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nheaderlen = 4;\r\nbreak;\r\ncase 4:\r\nheaderlen = 4;\r\nrecordlen = 2;\r\nentries = (ROM32(desc[0]) & 0x01f00000) >> 20;\r\nbreak;\r\ncase 5:\r\nheaderlen = 8;\r\nbreak;\r\ncase 6:\r\nif (mxms_version(dev) >= 0x0300) {\r\nheaderlen = 4;\r\nrecordlen = 8;\r\nentries = (desc[1] & 0xf0) >> 4;\r\n} else {\r\nheaderlen = 8;\r\n}\r\nbreak;\r\ncase 7:\r\nheaderlen = 8;\r\nrecordlen = 4;\r\nentries = desc[1] & 0x07;\r\nbreak;\r\ndefault:\r\nMXM_DBG(dev, "unknown descriptor type %d\n", type);\r\nreturn false;\r\n}\r\nif ((drm_debug & DRM_UT_DRIVER) && (exec == NULL)) {\r\nstatic const char * mxms_desc_name[] = {\r\n"ODS", "SCCS", "TS", "IPS",\r\n"GSD", "VSS", "BCS", "FCS",\r\n};\r\nu8 *dump = desc;\r\nint i, j;\r\nMXM_DBG(dev, "%4s: ", mxms_desc_name[type]);\r\nfor (j = headerlen - 1; j >= 0; j--)\r\nprintk("%02x", dump[j]);\r\nprintk("\n");\r\ndump += headerlen;\r\nfor (i = 0; i < entries; i++, dump += recordlen) {\r\nMXM_DBG(dev, " ");\r\nfor (j = recordlen - 1; j >= 0; j--)\r\nprintk("%02x", dump[j]);\r\nprintk("\n");\r\n}\r\n}\r\nif (types & (1 << type)) {\r\nif (!exec(dev, desc, info))\r\nreturn false;\r\n}\r\ndesc += headerlen + (entries * recordlen);\r\n}\r\nreturn true;\r\n}\r\nstatic u8 *\r\nmxm_table(struct drm_device *dev, u8 *size)\r\n{\r\nstruct bit_entry x;\r\nif (bit_table(dev, 'x', &x)) {\r\nMXM_DBG(dev, "BIT 'x' table not present\n");\r\nreturn NULL;\r\n}\r\nif (x.version != 1 || x.length < 3) {\r\nMXM_MSG(dev, "BIT x table %d/%d unknown\n",\r\nx.version, x.length);\r\nreturn NULL;\r\n}\r\n*size = x.length;\r\nreturn x.data;\r\n}\r\nstatic u8\r\nmxm_sor_map(struct drm_device *dev, u8 conn)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu8 len, *mxm = mxm_table(dev, &len);\r\nif (mxm && len >= 6) {\r\nu8 *map = ROMPTR(dev, mxm[4]);\r\nif (map) {\r\nif (map[0] == 0x10) {\r\nif (conn < map[3])\r\nreturn map[map[1] + conn];\r\nreturn 0x00;\r\n}\r\nMXM_MSG(dev, "unknown sor map 0x%02x\n", map[0]);\r\n}\r\n}\r\nif (dev_priv->chipset == 0x84 || dev_priv->chipset == 0x86)\r\nreturn nv84_sor_map[conn];\r\nif (dev_priv->chipset == 0x92)\r\nreturn nv92_sor_map[conn];\r\nif (dev_priv->chipset == 0x94)\r\nreturn nv94_sor_map[conn];\r\nif (dev_priv->chipset == 0x96)\r\nreturn nv96_sor_map[conn];\r\nif (dev_priv->chipset == 0x98)\r\nreturn nv98_sor_map[conn];\r\nMXM_MSG(dev, "missing sor map\n");\r\nreturn 0x00;\r\n}\r\nstatic u8\r\nmxm_ddc_map(struct drm_device *dev, u8 port)\r\n{\r\nu8 len, *mxm = mxm_table(dev, &len);\r\nif (mxm && len >= 8) {\r\nu8 *map = ROMPTR(dev, mxm[6]);\r\nif (map) {\r\nif (map[0] == 0x10) {\r\nif (port < map[3])\r\nreturn map[map[1] + port];\r\nreturn 0x00;\r\n}\r\nMXM_MSG(dev, "unknown ddc map 0x%02x\n", map[0]);\r\n}\r\n}\r\nreturn (port << 4) | port;\r\n}\r\nstatic void\r\nmxms_output_device(struct drm_device *dev, u8 *pdata, struct mxms_odev *desc)\r\n{\r\nu64 data = ROM32(pdata[0]);\r\nif (mxms_version(dev) >= 0x0300)\r\ndata |= (u64)ROM16(pdata[4]) << 32;\r\ndesc->outp_type = (data & 0x00000000000000f0ULL) >> 4;\r\ndesc->ddc_port = (data & 0x0000000000000f00ULL) >> 8;\r\ndesc->conn_type = (data & 0x000000000001f000ULL) >> 12;\r\ndesc->dig_conn = (data & 0x0000000000780000ULL) >> 19;\r\n}\r\nstatic bool\r\nmxm_match_tmds_partner(struct drm_device *dev, u8 *data, void *info)\r\n{\r\nstruct context *ctx = info;\r\nstruct mxms_odev desc;\r\nmxms_output_device(dev, data, &desc);\r\nif (desc.outp_type == 2 &&\r\ndesc.dig_conn == ctx->desc.dig_conn)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nmxm_match_dcb(struct drm_device *dev, u8 *data, void *info)\r\n{\r\nstruct context *ctx = info;\r\nu64 desc = *(u64 *)data;\r\nmxms_output_device(dev, data, &ctx->desc);\r\nif ((ctx->outp[0] & 0x0000000f) != ctx->desc.outp_type)\r\nreturn true;\r\nif ((desc & 0x00000000000000f0) >= 0x20) {\r\nu8 link = mxm_sor_map(dev, ctx->desc.dig_conn);\r\nif ((ctx->outp[0] & 0x0f000000) != (link & 0x0f) << 24)\r\nreturn true;\r\nlink = (link & 0x30) >> 4;\r\nif ((link & ((ctx->outp[1] & 0x00000030) >> 4)) != link)\r\nreturn true;\r\n}\r\ndata[0] &= ~0xf0;\r\nif (ctx->desc.outp_type == 6 && ctx->desc.conn_type == 6 &&\r\nmxms_foreach(dev, 0x01, mxm_match_tmds_partner, ctx)) {\r\ndata[0] |= 0x20;\r\n} else {\r\ndata[0] |= 0xf0;\r\n}\r\nreturn false;\r\n}\r\nstatic int\r\nmxm_dcb_sanitise_entry(struct drm_device *dev, void *data, int idx, u8 *dcbe)\r\n{\r\nstruct context ctx = { .outp = (u32 *)dcbe };\r\nu8 type, i2cidx, link;\r\nu8 *conn;\r\nif (mxms_foreach(dev, 0x01, mxm_match_dcb, &ctx)) {\r\nMXM_DBG(dev, "disable %d: 0x%08x 0x%08x\n",\r\nidx, ctx.outp[0], ctx.outp[1]);\r\nctx.outp[0] |= 0x0000000f;\r\nreturn 0;\r\n}\r\ni2cidx = mxm_ddc_map(dev, ctx.desc.ddc_port);\r\nif ((ctx.outp[0] & 0x0000000f) != OUTPUT_DP)\r\ni2cidx = (i2cidx & 0x0f) << 4;\r\nelse\r\ni2cidx = (i2cidx & 0xf0);\r\nif (i2cidx != 0xf0) {\r\nctx.outp[0] &= ~0x000000f0;\r\nctx.outp[0] |= i2cidx;\r\n}\r\nswitch (ctx.desc.outp_type) {\r\ncase 0x00:\r\ncase 0x01:\r\nbreak;\r\ndefault:\r\nlink = mxm_sor_map(dev, ctx.desc.dig_conn) & 0x30;\r\nctx.outp[1] &= ~0x00000030;\r\nctx.outp[1] |= link;\r\nbreak;\r\n}\r\nconn = dcb_conn(dev, (ctx.outp[0] & 0x0000f000) >> 12);\r\ntype = conn[0];\r\nswitch (ctx.desc.conn_type) {\r\ncase 0x01:\r\nctx.outp[1] |= 0x00000004;\r\nbreak;\r\ncase 0x02:\r\ntype = DCB_CONNECTOR_HDMI_1;\r\nbreak;\r\ncase 0x03:\r\ntype = DCB_CONNECTOR_DVI_D;\r\nbreak;\r\ncase 0x0e:\r\nctx.outp[1] |= 0x00010000;\r\ncase 0x07:\r\nctx.outp[1] |= 0x00000004;\r\ntype = DCB_CONNECTOR_eDP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (mxms_version(dev) >= 0x0300)\r\nconn[0] = type;\r\nreturn 0;\r\n}\r\nstatic bool\r\nmxm_show_unmatched(struct drm_device *dev, u8 *data, void *info)\r\n{\r\nu64 desc = *(u64 *)data;\r\nif ((desc & 0xf0) != 0xf0)\r\nMXM_MSG(dev, "unmatched output device 0x%016llx\n", desc);\r\nreturn true;\r\n}\r\nstatic void\r\nmxm_dcb_sanitise(struct drm_device *dev)\r\n{\r\nu8 *dcb = dcb_table(dev);\r\nif (!dcb || dcb[0] != 0x40) {\r\nMXM_DBG(dev, "unsupported DCB version\n");\r\nreturn;\r\n}\r\ndcb_outp_foreach(dev, NULL, mxm_dcb_sanitise_entry);\r\nmxms_foreach(dev, 0x01, mxm_show_unmatched, NULL);\r\n}\r\nstatic bool\r\nmxm_shadow_rom_fetch(struct nouveau_i2c_chan *i2c, u8 addr,\r\nu8 offset, u8 size, u8 *data)\r\n{\r\nstruct i2c_msg msgs[] = {\r\n{ .addr = addr, .flags = 0, .len = 1, .buf = &offset },\r\n{ .addr = addr, .flags = I2C_M_RD, .len = size, .buf = data, },\r\n};\r\nreturn i2c_transfer(&i2c->adapter, msgs, 2) == 2;\r\n}\r\nstatic bool\r\nmxm_shadow_rom(struct drm_device *dev, u8 version)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_i2c_chan *i2c = NULL;\r\nu8 i2cidx, mxms[6], addr, size;\r\ni2cidx = mxm_ddc_map(dev, 1 ) & 0x0f;\r\nif (i2cidx < 0x0f)\r\ni2c = nouveau_i2c_find(dev, i2cidx);\r\nif (!i2c)\r\nreturn false;\r\naddr = 0x54;\r\nif (!mxm_shadow_rom_fetch(i2c, addr, 0, 6, mxms)) {\r\naddr = 0x56;\r\nif (!mxm_shadow_rom_fetch(i2c, addr, 0, 6, mxms))\r\nreturn false;\r\n}\r\ndev_priv->mxms = mxms;\r\nsize = mxms_headerlen(dev) + mxms_structlen(dev);\r\ndev_priv->mxms = kmalloc(size, GFP_KERNEL);\r\nif (dev_priv->mxms &&\r\nmxm_shadow_rom_fetch(i2c, addr, 0, size, dev_priv->mxms))\r\nreturn true;\r\nkfree(dev_priv->mxms);\r\ndev_priv->mxms = NULL;\r\nreturn false;\r\n}\r\nstatic bool\r\nmxm_shadow_dsm(struct drm_device *dev, u8 version)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstatic char muid[] = {\r\n0x00, 0xA4, 0x04, 0x40, 0x7D, 0x91, 0xF2, 0x4C,\r\n0xB8, 0x9C, 0x79, 0xB6, 0x2F, 0xD5, 0x56, 0x65\r\n};\r\nu32 mxms_args[] = { 0x00000000 };\r\nunion acpi_object args[4] = {\r\n{ .buffer.type = 3,\r\n.buffer.length = sizeof(muid),\r\n.buffer.pointer = muid,\r\n},\r\n{ .integer.type = ACPI_TYPE_INTEGER,\r\n.integer.value = (version & 0xf0) << 4 | (version & 0x0f),\r\n},\r\n{ .integer.type = ACPI_TYPE_INTEGER,\r\n.integer.value = 0x00000010,\r\n},\r\n{ .buffer.type = ACPI_TYPE_BUFFER,\r\n.buffer.length = sizeof(mxms_args),\r\n.buffer.pointer = (char *)mxms_args,\r\n},\r\n};\r\nstruct acpi_object_list list = { ARRAY_SIZE(args), args };\r\nstruct acpi_buffer retn = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_handle handle;\r\nint ret;\r\nhandle = DEVICE_ACPI_HANDLE(&dev->pdev->dev);\r\nif (!handle)\r\nreturn false;\r\nret = acpi_evaluate_object(handle, "_DSM", &list, &retn);\r\nif (ret) {\r\nMXM_DBG(dev, "DSM MXMS failed: %d\n", ret);\r\nreturn false;\r\n}\r\nobj = retn.pointer;\r\nif (obj->type == ACPI_TYPE_BUFFER) {\r\ndev_priv->mxms = kmemdup(obj->buffer.pointer,\r\nobj->buffer.length, GFP_KERNEL);\r\n} else\r\nif (obj->type == ACPI_TYPE_INTEGER) {\r\nMXM_DBG(dev, "DSM MXMS returned 0x%llx\n", obj->integer.value);\r\n}\r\nkfree(obj);\r\nreturn dev_priv->mxms != NULL;\r\n}\r\nstatic u8\r\nwmi_wmmx_mxmi(struct drm_device *dev, u8 version)\r\n{\r\nu32 mxmi_args[] = { 0x494D584D , version, 0 };\r\nstruct acpi_buffer args = { sizeof(mxmi_args), mxmi_args };\r\nstruct acpi_buffer retn = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nstatus = wmi_evaluate_method(WMI_WMMX_GUID, 0, 0, &args, &retn);\r\nif (ACPI_FAILURE(status)) {\r\nMXM_DBG(dev, "WMMX MXMI returned %d\n", status);\r\nreturn 0x00;\r\n}\r\nobj = retn.pointer;\r\nif (obj->type == ACPI_TYPE_INTEGER) {\r\nversion = obj->integer.value;\r\nMXM_DBG(dev, "WMMX MXMI version %d.%d\n",\r\n(version >> 4), version & 0x0f);\r\n} else {\r\nversion = 0;\r\nMXM_DBG(dev, "WMMX MXMI returned non-integer\n");\r\n}\r\nkfree(obj);\r\nreturn version;\r\n}\r\nstatic bool\r\nmxm_shadow_wmi(struct drm_device *dev, u8 version)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 mxms_args[] = { 0x534D584D , version, 0 };\r\nstruct acpi_buffer args = { sizeof(mxms_args), mxms_args };\r\nstruct acpi_buffer retn = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nif (!wmi_has_guid(WMI_WMMX_GUID)) {\r\nMXM_DBG(dev, "WMMX GUID not found\n");\r\nreturn false;\r\n}\r\nmxms_args[1] = wmi_wmmx_mxmi(dev, 0x00);\r\nif (!mxms_args[1])\r\nmxms_args[1] = wmi_wmmx_mxmi(dev, version);\r\nif (!mxms_args[1])\r\nreturn false;\r\nstatus = wmi_evaluate_method(WMI_WMMX_GUID, 0, 0, &args, &retn);\r\nif (ACPI_FAILURE(status)) {\r\nMXM_DBG(dev, "WMMX MXMS returned %d\n", status);\r\nreturn false;\r\n}\r\nobj = retn.pointer;\r\nif (obj->type == ACPI_TYPE_BUFFER) {\r\ndev_priv->mxms = kmemdup(obj->buffer.pointer,\r\nobj->buffer.length, GFP_KERNEL);\r\n}\r\nkfree(obj);\r\nreturn dev_priv->mxms != NULL;\r\n}\r\nstatic int\r\nmxm_shadow(struct drm_device *dev, u8 version)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct mxm_shadow_h *shadow = _mxm_shadow;\r\ndo {\r\nMXM_DBG(dev, "checking %s\n", shadow->name);\r\nif (shadow->exec(dev, version)) {\r\nif (mxms_valid(dev))\r\nreturn 0;\r\nkfree(dev_priv->mxms);\r\ndev_priv->mxms = NULL;\r\n}\r\n} while ((++shadow)->name);\r\nreturn -ENOENT;\r\n}\r\nint\r\nnouveau_mxm_init(struct drm_device *dev)\r\n{\r\nu8 mxm_size, *mxm = mxm_table(dev, &mxm_size);\r\nif (!mxm || !mxm[0]) {\r\nMXM_MSG(dev, "no VBIOS data, nothing to do\n");\r\nreturn 0;\r\n}\r\nMXM_MSG(dev, "BIOS version %d.%d\n", mxm[0] >> 4, mxm[0] & 0x0f);\r\nif (mxm_shadow(dev, mxm[0])) {\r\nMXM_MSG(dev, "failed to locate valid SIS\n");\r\n#if 0\r\nreturn -EINVAL;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nMXM_MSG(dev, "MXMS Version %d.%d\n",\r\nmxms_version(dev) >> 8, mxms_version(dev) & 0xff);\r\nmxms_foreach(dev, 0, NULL, NULL);\r\nif (nouveau_mxmdcb)\r\nmxm_dcb_sanitise(dev);\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_mxm_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nkfree(dev_priv->mxms);\r\ndev_priv->mxms = NULL;\r\n}
