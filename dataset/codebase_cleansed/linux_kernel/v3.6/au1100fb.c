static int au1100fb_fb_blank(int blank_mode, struct fb_info *fbi)\r\n{\r\nstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\r\nprint_dbg("fb_blank %d %p", blank_mode, fbi);\r\nswitch (blank_mode) {\r\ncase VESA_NO_BLANKING:\r\nfbdev->regs->lcd_control |= LCD_CONTROL_GO;\r\n#ifdef CONFIG_MIPS_PB1100\r\nif (fbdev->panel_idx == 1) {\r\nau_writew(au_readw(PB1100_G_CONTROL)\r\n| (PB1100_G_CONTROL_BL | PB1100_G_CONTROL_VDD),\r\nPB1100_G_CONTROL);\r\n}\r\n#endif\r\nau_sync();\r\nbreak;\r\ncase VESA_VSYNC_SUSPEND:\r\ncase VESA_HSYNC_SUSPEND:\r\ncase VESA_POWERDOWN:\r\nfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\r\n#ifdef CONFIG_MIPS_PB1100\r\nif (fbdev->panel_idx == 1) {\r\nau_writew(au_readw(PB1100_G_CONTROL)\r\n& ~(PB1100_G_CONTROL_BL | PB1100_G_CONTROL_VDD),\r\nPB1100_G_CONTROL);\r\n}\r\n#endif\r\nau_sync();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint au1100fb_setmode(struct au1100fb_device *fbdev)\r\n{\r\nstruct fb_info *info = &fbdev->info;\r\nu32 words;\r\nint index;\r\nif (!fbdev)\r\nreturn -EINVAL;\r\nif (panel_is_active(fbdev->panel) || panel_is_color(fbdev->panel)) {\r\nif (info->var.bits_per_pixel <= 8) {\r\ninfo->var.red.offset = 0;\r\ninfo->var.red.length = info->var.bits_per_pixel;\r\ninfo->var.red.msb_right = 0;\r\ninfo->var.green.offset = 0;\r\ninfo->var.green.length = info->var.bits_per_pixel;\r\ninfo->var.green.msb_right = 0;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.blue.length = info->var.bits_per_pixel;\r\ninfo->var.blue.msb_right = 0;\r\ninfo->var.transp.offset = 0;\r\ninfo->var.transp.length = 0;\r\ninfo->var.transp.msb_right = 0;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.line_length = info->var.xres_virtual /\r\n(8/info->var.bits_per_pixel);\r\n} else {\r\nindex = (fbdev->panel->control_base & LCD_CONTROL_SBPPF_MASK) >> LCD_CONTROL_SBPPF_BIT;\r\ninfo->var.red = rgb_bitfields[index][0];\r\ninfo->var.green = rgb_bitfields[index][1];\r\ninfo->var.blue = rgb_bitfields[index][2];\r\ninfo->var.transp = rgb_bitfields[index][3];\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = info->var.xres_virtual << 1;\r\n}\r\n} else {\r\ninfo->fix.visual = FB_VISUAL_MONO10;\r\ninfo->fix.line_length = info->var.xres_virtual / 8;\r\n}\r\ninfo->screen_size = info->fix.line_length * info->var.yres_virtual;\r\ninfo->var.rotate = ((fbdev->panel->control_base&LCD_CONTROL_SM_MASK) \\r\n>> LCD_CONTROL_SM_BIT) * 90;\r\nfbdev->regs->lcd_control = fbdev->panel->control_base;\r\nfbdev->regs->lcd_horztiming = fbdev->panel->horztiming;\r\nfbdev->regs->lcd_verttiming = fbdev->panel->verttiming;\r\nfbdev->regs->lcd_clkcontrol = fbdev->panel->clkcontrol_base;\r\nfbdev->regs->lcd_intenable = 0;\r\nfbdev->regs->lcd_intstatus = 0;\r\nfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(fbdev->fb_phys);\r\nif (panel_is_dual(fbdev->panel)) {\r\nif (info->var.yres_virtual >= (info->var.yres << 1)) {\r\nfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys +\r\n(info->fix.line_length *\r\n(info->var.yres_virtual >> 1)));\r\n} else {\r\nfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys);\r\n}\r\n}\r\nwords = info->fix.line_length / sizeof(u32);\r\nif (!info->var.rotate || (info->var.rotate == 180)) {\r\nwords *= info->var.yres_virtual;\r\nif (info->var.rotate ) {\r\nwords -= (words % 8);\r\n}\r\n}\r\nfbdev->regs->lcd_words = LCD_WRD_WRDS_N(words);\r\nfbdev->regs->lcd_pwmdiv = 0;\r\nfbdev->regs->lcd_pwmhi = 0;\r\nfbdev->regs->lcd_control |= LCD_CONTROL_GO;\r\nmdelay(10);\r\nau1100fb_fb_blank(VESA_NO_BLANKING, info);\r\nreturn 0;\r\n}\r\nint au1100fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)\r\n{\r\nstruct au1100fb_device *fbdev;\r\nu32 *palette;\r\nu32 value;\r\nfbdev = to_au1100fb_device(fbi);\r\npalette = fbdev->regs->lcd_pallettebase;\r\nif (regno > (AU1100_LCD_NBR_PALETTE_ENTRIES - 1))\r\nreturn -EINVAL;\r\nif (fbi->var.grayscale) {\r\nred = green = blue =\r\n(19595 * red + 38470 * green + 7471 * blue) >> 16;\r\n}\r\nif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nif (regno > 16)\r\nreturn -EINVAL;\r\npalette = (u32*)fbi->pseudo_palette;\r\nred >>= (16 - fbi->var.red.length);\r\ngreen >>= (16 - fbi->var.green.length);\r\nblue >>= (16 - fbi->var.blue.length);\r\nvalue = (red << fbi->var.red.offset) |\r\n(green << fbi->var.green.offset)|\r\n(blue << fbi->var.blue.offset);\r\nvalue &= 0xFFFF;\r\n} else if (panel_is_active(fbdev->panel)) {\r\nvalue = (red & 0xF800)|((green >> 5) & 0x07E0)|((blue >> 11) & 0x001F);\r\nvalue &= 0xFFFF;\r\n} else if (panel_is_color(fbdev->panel)) {\r\nvalue = (((panel_swap_rgb(fbdev->panel) ? blue : red) >> 12) & 0x000F) |\r\n((green >> 8) & 0x00F0) |\r\n(((panel_swap_rgb(fbdev->panel) ? red : blue) >> 4) & 0x0F00);\r\nvalue &= 0xFFF;\r\n} else {\r\nvalue = (green >> 12) & 0x000F;\r\nvalue &= 0xF;\r\n}\r\npalette[regno] = value;\r\nreturn 0;\r\n}\r\nint au1100fb_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fbi)\r\n{\r\nstruct au1100fb_device *fbdev;\r\nint dy;\r\nfbdev = to_au1100fb_device(fbi);\r\nprint_dbg("fb_pan_display %p %p", var, fbi);\r\nif (!var || !fbdev) {\r\nreturn -EINVAL;\r\n}\r\nif (var->xoffset - fbi->var.xoffset) {\r\nreturn -EINVAL;\r\n}\r\nprint_dbg("fb_pan_display 2 %p %p", var, fbi);\r\ndy = var->yoffset - fbi->var.yoffset;\r\nif (dy) {\r\nu32 dmaaddr;\r\nprint_dbg("Panning screen of %d lines", dy);\r\ndmaaddr = fbdev->regs->lcd_dmaaddr0;\r\ndmaaddr += (fbi->fix.line_length * dy);\r\nfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\r\nif (panel_is_dual(fbdev->panel)) {\r\ndmaaddr = fbdev->regs->lcd_dmaaddr1;\r\ndmaaddr += (fbi->fix.line_length * dy);\r\nfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\r\n}\r\n}\r\nprint_dbg("fb_pan_display 3 %p %p", var, fbi);\r\nreturn 0;\r\n}\r\nvoid au1100fb_fb_rotate(struct fb_info *fbi, int angle)\r\n{\r\nstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\r\nprint_dbg("fb_rotate %p %d", fbi, angle);\r\nif (fbdev && (angle > 0) && !(angle % 90)) {\r\nfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\r\nfbdev->regs->lcd_control &= ~(LCD_CONTROL_SM_MASK);\r\nfbdev->regs->lcd_control |= ((angle/90) << LCD_CONTROL_SM_BIT);\r\nfbdev->regs->lcd_control |= LCD_CONTROL_GO;\r\n}\r\n}\r\nint au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\r\n{\r\nstruct au1100fb_device *fbdev;\r\nunsigned int len;\r\nunsigned long start=0, off;\r\nfbdev = to_au1100fb_device(fbi);\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\r\nreturn -EINVAL;\r\n}\r\nstart = fbdev->fb_phys & PAGE_MASK;\r\nlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\r\noff = vma->vm_pgoff << PAGE_SHIFT;\r\nif ((vma->vm_end - vma->vm_start + off) > len) {\r\nreturn -EINVAL;\r\n}\r\noff += start;\r\nvma->vm_pgoff = off >> PAGE_SHIFT;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\npgprot_val(vma->vm_page_prot) |= (6 << 9);\r\nvma->vm_flags |= VM_IO;\r\nif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot)) {\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int au1100fb_setup(struct au1100fb_device *fbdev)\r\n{\r\nchar *this_opt, *options;\r\nint num_panels = ARRAY_SIZE(known_lcd_panels);\r\nif (num_panels <= 0) {\r\nprint_err("No LCD panels supported by driver!");\r\nreturn -ENODEV;\r\n}\r\nif (fb_get_options(DRIVER_NAME, &options))\r\nreturn -ENODEV;\r\nif (!options)\r\nreturn -ENODEV;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "panel:", 6)) {\r\nint i;\r\nthis_opt += 6;\r\nfor (i = 0; i < num_panels; i++) {\r\nif (!strncmp(this_opt, known_lcd_panels[i].name,\r\nstrlen(this_opt))) {\r\nfbdev->panel = &known_lcd_panels[i];\r\nfbdev->panel_idx = i;\r\nbreak;\r\n}\r\n}\r\nif (i >= num_panels) {\r\nprint_warn("Panel '%s' not supported!", this_opt);\r\nreturn -ENODEV;\r\n}\r\n}\r\nelse\r\nprint_warn("Unsupported option \"%s\"", this_opt);\r\n}\r\nprint_info("Panel=%s", fbdev->panel->name);\r\nreturn 0;\r\n}\r\nstatic int __devinit au1100fb_drv_probe(struct platform_device *dev)\r\n{\r\nstruct au1100fb_device *fbdev = NULL;\r\nstruct resource *regs_res;\r\nunsigned long page;\r\nu32 sys_clksrc;\r\nfbdev = devm_kzalloc(&dev->dev, sizeof(struct au1100fb_device),\r\nGFP_KERNEL);\r\nif (!fbdev) {\r\nprint_err("fail to allocate device private record");\r\nreturn -ENOMEM;\r\n}\r\nif (au1100fb_setup(fbdev))\r\ngoto failed;\r\nplatform_set_drvdata(dev, (void *)fbdev);\r\nregs_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!regs_res) {\r\nprint_err("fail to retrieve registers resource");\r\nreturn -EFAULT;\r\n}\r\nau1100fb_fix.mmio_start = regs_res->start;\r\nau1100fb_fix.mmio_len = resource_size(regs_res);\r\nif (!devm_request_mem_region(&dev->dev,\r\nau1100fb_fix.mmio_start,\r\nau1100fb_fix.mmio_len,\r\nDRIVER_NAME)) {\r\nprint_err("fail to lock memory region at 0x%08lx",\r\nau1100fb_fix.mmio_start);\r\nreturn -EBUSY;\r\n}\r\nfbdev->regs = (struct au1100fb_regs*)KSEG1ADDR(au1100fb_fix.mmio_start);\r\nprint_dbg("Register memory map at %p", fbdev->regs);\r\nprint_dbg("phys=0x%08x, size=%d", fbdev->regs_phys, fbdev->regs_len);\r\nfbdev->fb_len = fbdev->panel->xres * fbdev->panel->yres *\r\n(fbdev->panel->bpp >> 3) * AU1100FB_NBR_VIDEO_BUFFERS;\r\nfbdev->fb_mem = dmam_alloc_coherent(&dev->dev,\r\nPAGE_ALIGN(fbdev->fb_len),\r\n&fbdev->fb_phys, GFP_KERNEL);\r\nif (!fbdev->fb_mem) {\r\nprint_err("fail to allocate frambuffer (size: %dK))",\r\nfbdev->fb_len / 1024);\r\nreturn -ENOMEM;\r\n}\r\nau1100fb_fix.smem_start = fbdev->fb_phys;\r\nau1100fb_fix.smem_len = fbdev->fb_len;\r\nfor (page = (unsigned long)fbdev->fb_mem;\r\npage < PAGE_ALIGN((unsigned long)fbdev->fb_mem + fbdev->fb_len);\r\npage += PAGE_SIZE) {\r\n#ifdef CONFIG_DMA_NONCOHERENT\r\nSetPageReserved(virt_to_page(CAC_ADDR((void *)page)));\r\n#else\r\nSetPageReserved(virt_to_page(page));\r\n#endif\r\n}\r\nprint_dbg("Framebuffer memory map at %p", fbdev->fb_mem);\r\nprint_dbg("phys=0x%08x, size=%dK", fbdev->fb_phys, fbdev->fb_len / 1024);\r\nsys_clksrc = au_readl(SYS_CLKSRC) & ~(SYS_CS_ML_MASK | SYS_CS_DL | SYS_CS_CL);\r\nau_writel((sys_clksrc | (1 << SYS_CS_ML_BIT)), SYS_CLKSRC);\r\nau1100fb_var.bits_per_pixel = fbdev->panel->bpp;\r\nau1100fb_var.xres = fbdev->panel->xres;\r\nau1100fb_var.xres_virtual = au1100fb_var.xres;\r\nau1100fb_var.yres = fbdev->panel->yres;\r\nau1100fb_var.yres_virtual = au1100fb_var.yres;\r\nfbdev->info.screen_base = fbdev->fb_mem;\r\nfbdev->info.fbops = &au1100fb_ops;\r\nfbdev->info.fix = au1100fb_fix;\r\nfbdev->info.pseudo_palette =\r\ndevm_kzalloc(&dev->dev, sizeof(u32) * 16, GFP_KERNEL);\r\nif (!fbdev->info.pseudo_palette)\r\nreturn -ENOMEM;\r\nif (fb_alloc_cmap(&fbdev->info.cmap, AU1100_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\r\nprint_err("Fail to allocate colormap (%d entries)",\r\nAU1100_LCD_NBR_PALETTE_ENTRIES);\r\nreturn -EFAULT;\r\n}\r\nfbdev->info.var = au1100fb_var;\r\nau1100fb_setmode(fbdev);\r\nif (register_framebuffer(&fbdev->info) < 0) {\r\nprint_err("cannot register new framebuffer");\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nif (fbdev->fb_mem) {\r\ndma_free_noncoherent(&dev->dev, fbdev->fb_len, fbdev->fb_mem,\r\nfbdev->fb_phys);\r\n}\r\nif (fbdev->info.cmap.len != 0) {\r\nfb_dealloc_cmap(&fbdev->info.cmap);\r\n}\r\nplatform_set_drvdata(dev, NULL);\r\nreturn -ENODEV;\r\n}\r\nint au1100fb_drv_remove(struct platform_device *dev)\r\n{\r\nstruct au1100fb_device *fbdev = NULL;\r\nif (!dev)\r\nreturn -ENODEV;\r\nfbdev = (struct au1100fb_device *) platform_get_drvdata(dev);\r\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\r\nau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\r\n#endif\r\nfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\r\nunregister_framebuffer(&fbdev->info);\r\nfb_dealloc_cmap(&fbdev->info.cmap);\r\nreturn 0;\r\n}\r\nint au1100fb_drv_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\r\nif (!fbdev)\r\nreturn 0;\r\nsys_clksrc = au_readl(SYS_CLKSRC);\r\nau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\r\nau_writel(sys_clksrc & ~SYS_CS_ML_MASK, SYS_CLKSRC);\r\nmemcpy(&fbregs, fbdev->regs, sizeof(struct au1100fb_regs));\r\nreturn 0;\r\n}\r\nint au1100fb_drv_resume(struct platform_device *dev)\r\n{\r\nstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\r\nif (!fbdev)\r\nreturn 0;\r\nmemcpy(fbdev->regs, &fbregs, sizeof(struct au1100fb_regs));\r\nau_writel(sys_clksrc, SYS_CLKSRC);\r\nau1100fb_fb_blank(VESA_NO_BLANKING, &fbdev->info);\r\nreturn 0;\r\n}\r\nstatic int __init au1100fb_load(void)\r\n{\r\nreturn platform_driver_register(&au1100fb_driver);\r\n}\r\nstatic void __exit au1100fb_unload(void)\r\n{\r\nplatform_driver_unregister(&au1100fb_driver);\r\n}
