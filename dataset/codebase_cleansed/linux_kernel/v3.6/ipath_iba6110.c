static void hwerr_crcbits(struct ipath_devdata *dd, ipath_err_t hwerrs,\r\nchar *msg, size_t msgl)\r\n{\r\nchar bitsmsg[64];\r\nipath_err_t crcbits = hwerrs &\r\n(_IPATH_HTLINK0_CRCBITS | _IPATH_HTLINK1_CRCBITS);\r\nif (dd->ipath_flags & IPATH_8BIT_IN_HT0)\r\ncrcbits &= ~infinipath_hwe_htclnkabyte1crcerr;\r\nif (dd->ipath_flags & IPATH_8BIT_IN_HT1)\r\ncrcbits &= ~infinipath_hwe_htclnkbbyte1crcerr;\r\nif (crcbits) {\r\nu16 ctrl0, ctrl1;\r\nsnprintf(bitsmsg, sizeof bitsmsg,\r\n"[HT%s lane %s CRC (%llx); powercycle to completely clear]",\r\n!(crcbits & _IPATH_HTLINK1_CRCBITS) ?\r\n"0 (A)" : (!(crcbits & _IPATH_HTLINK0_CRCBITS)\r\n? "1 (B)" : "0+1 (A+B)"),\r\n!(crcbits & _IPATH_HTLANE1_CRCBITS) ? "0"\r\n: (!(crcbits & _IPATH_HTLANE0_CRCBITS) ? "1" :\r\n"0+1"), (unsigned long long) crcbits);\r\nstrlcat(msg, bitsmsg, msgl);\r\nif (pci_read_config_word(dd->pcidev,\r\ndd->ipath_ht_slave_off + 0x4,\r\n&ctrl0))\r\ndev_info(&dd->pcidev->dev, "Couldn't read "\r\n"linkctrl0 of slave/primary "\r\n"config block\n");\r\nelse if (!(ctrl0 & 1 << 6))\r\nipath_dbg("HT linkctrl0 0x%x%s%s\n", ctrl0,\r\n((ctrl0 >> 8) & 7) ? " CRC" : "",\r\n((ctrl0 >> 4) & 1) ? "linkfail" :\r\n"");\r\nif (pci_read_config_word(dd->pcidev,\r\ndd->ipath_ht_slave_off + 0x8,\r\n&ctrl1))\r\ndev_info(&dd->pcidev->dev, "Couldn't read "\r\n"linkctrl1 of slave/primary "\r\n"config block\n");\r\nelse if (!(ctrl1 & 1 << 6))\r\nipath_dbg("HT linkctrl1 0x%x%s%s\n", ctrl1,\r\n((ctrl1 >> 8) & 7) ? " CRC" : "",\r\n((ctrl1 >> 4) & 1) ? "linkfail" :\r\n"");\r\ndd->ipath_hwerrmask &= ~crcbits;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,\r\ndd->ipath_hwerrmask);\r\nipath_dbg("HT crc errs: %s\n", msg);\r\n} else\r\nipath_dbg("ignoring HT crc errors 0x%llx, "\r\n"not in use\n", (unsigned long long)\r\n(hwerrs & (_IPATH_HTLINK0_CRCBITS |\r\n_IPATH_HTLINK1_CRCBITS)));\r\n}\r\nstatic void ipath_ht_txe_recover(struct ipath_devdata *dd)\r\n{\r\n++ipath_stats.sps_txeparity;\r\ndev_info(&dd->pcidev->dev,\r\n"Recovering from TXE PIO parity error\n");\r\n}\r\nstatic void ipath_ht_handle_hwerrors(struct ipath_devdata *dd, char *msg,\r\nsize_t msgl)\r\n{\r\nipath_err_t hwerrs;\r\nu32 bits, ctrl;\r\nint isfatal = 0;\r\nchar bitsmsg[64];\r\nint log_idx;\r\nhwerrs = ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwerrstatus);\r\nif (!hwerrs) {\r\nipath_cdbg(VERBOSE, "Called but no hardware errors set\n");\r\ngoto bail;\r\n} else if (hwerrs == -1LL) {\r\nipath_dev_err(dd, "Read of hardware error status failed "\r\n"(all bits set); ignoring\n");\r\ngoto bail;\r\n}\r\nipath_stats.sps_hwerrs++;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,\r\nhwerrs&~INFINIPATH_HWE_MEMBISTFAILED);\r\nhwerrs &= dd->ipath_hwerrmask;\r\nfor (log_idx = 0; log_idx < IPATH_EEP_LOG_CNT; ++log_idx)\r\nif (hwerrs & dd->ipath_eep_st_masks[log_idx].hwerrs_to_log)\r\nipath_inc_eeprom_err(dd, log_idx, 1);\r\nif ((hwerrs & ~(dd->ipath_lasthwerror | TXE_PIO_PARITY |\r\nRXE_EAGER_PARITY)) ||\r\n(ipath_debug & __IPATH_VERBDBG))\r\ndev_info(&dd->pcidev->dev, "Hardware error: hwerr=0x%llx "\r\n"(cleared)\n", (unsigned long long) hwerrs);\r\ndd->ipath_lasthwerror |= hwerrs;\r\nif (hwerrs & ~dd->ipath_hwe_bitsextant)\r\nipath_dev_err(dd, "hwerror interrupt with unknown errors "\r\n"%llx set\n", (unsigned long long)\r\n(hwerrs & ~dd->ipath_hwe_bitsextant));\r\nctrl = ipath_read_kreg32(dd, dd->ipath_kregs->kr_control);\r\nif ((ctrl & INFINIPATH_C_FREEZEMODE) && !ipath_diag_inuse) {\r\nif (hwerrs & TXE_PIO_PARITY) {\r\nipath_ht_txe_recover(dd);\r\nhwerrs &= ~TXE_PIO_PARITY;\r\n}\r\nif (!hwerrs) {\r\nipath_dbg("Clearing freezemode on ignored or "\r\n"recovered hardware error\n");\r\nipath_clear_freeze(dd);\r\n}\r\n}\r\n*msg = '\0';\r\nif (hwerrs & (infinipath_hwe_htcmemparityerr_mask\r\n<< INFINIPATH_HWE_HTCMEMPARITYERR_SHIFT)) {\r\nbits = (u32) ((hwerrs >>\r\nINFINIPATH_HWE_HTCMEMPARITYERR_SHIFT) &\r\nINFINIPATH_HWE_HTCMEMPARITYERR_MASK);\r\nsnprintf(bitsmsg, sizeof bitsmsg, "[HTC Parity Errs %x] ",\r\nbits);\r\nstrlcat(msg, bitsmsg, msgl);\r\n}\r\nipath_format_hwerrors(hwerrs,\r\nipath_6110_hwerror_msgs,\r\nARRAY_SIZE(ipath_6110_hwerror_msgs),\r\nmsg, msgl);\r\nif (hwerrs & (_IPATH_HTLINK0_CRCBITS | _IPATH_HTLINK1_CRCBITS))\r\nhwerr_crcbits(dd, hwerrs, msg, msgl);\r\nif (hwerrs & INFINIPATH_HWE_MEMBISTFAILED) {\r\nstrlcat(msg, "[Memory BIST test failed, InfiniPath hardware unusable]",\r\nmsgl);\r\ndd->ipath_hwerrmask &= ~INFINIPATH_HWE_MEMBISTFAILED;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,\r\ndd->ipath_hwerrmask);\r\n}\r\n#define _IPATH_PLL_FAIL (INFINIPATH_HWE_COREPLL_FBSLIP | \\r\nINFINIPATH_HWE_COREPLL_RFSLIP | \\r\nINFINIPATH_HWE_HTBPLL_FBSLIP | \\r\nINFINIPATH_HWE_HTBPLL_RFSLIP | \\r\nINFINIPATH_HWE_HTAPLL_FBSLIP | \\r\nINFINIPATH_HWE_HTAPLL_RFSLIP)\r\nif (hwerrs & _IPATH_PLL_FAIL) {\r\nsnprintf(bitsmsg, sizeof bitsmsg,\r\n"[PLL failed (%llx), InfiniPath hardware unusable]",\r\n(unsigned long long) (hwerrs & _IPATH_PLL_FAIL));\r\nstrlcat(msg, bitsmsg, msgl);\r\ndd->ipath_hwerrmask &= ~(hwerrs & _IPATH_PLL_FAIL);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,\r\ndd->ipath_hwerrmask);\r\n}\r\nif (hwerrs & INFINIPATH_HWE_SERDESPLLFAILED) {\r\ndd->ipath_hwerrmask &= ~INFINIPATH_HWE_SERDESPLLFAILED;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,\r\ndd->ipath_hwerrmask);\r\n}\r\nif (hwerrs) {\r\nif (dd->ipath_flags & IPATH_INITTED) {\r\nipath_set_linkstate(dd, IPATH_IB_LINKDOWN);\r\nipath_setup_ht_setextled(dd,\r\nINFINIPATH_IBCS_L_STATE_DOWN,\r\nINFINIPATH_IBCS_LT_STATE_DISABLED);\r\nipath_dev_err(dd, "Fatal Hardware Error (freeze "\r\n"mode), no longer usable, SN %.16s\n",\r\ndd->ipath_serial);\r\nisfatal = 1;\r\n}\r\n*dd->ipath_statusp &= ~IPATH_STATUS_IB_READY;\r\n*dd->ipath_statusp |= IPATH_STATUS_HWERROR;\r\ndd->ipath_flags &= ~IPATH_INITTED;\r\n}\r\nelse\r\n*msg = 0;\r\nif (*msg)\r\nipath_dev_err(dd, "%s hardware error\n", msg);\r\nif (isfatal && !ipath_diag_inuse && dd->ipath_freezemsg)\r\nsnprintf(dd->ipath_freezemsg,\r\ndd->ipath_freezelen, "{%s}", msg);\r\nbail:;\r\n}\r\nstatic int ipath_ht_boardname(struct ipath_devdata *dd, char *name,\r\nsize_t namelen)\r\n{\r\nchar *n = NULL;\r\nu8 boardrev = dd->ipath_boardrev;\r\nint ret = 0;\r\nswitch (boardrev) {\r\ncase 5:\r\nn = "InfiniPath_QHT7040";\r\nbreak;\r\ncase 7:\r\nn = "InfiniPath_QHT7140";\r\nbreak;\r\ndefault:\r\nipath_dev_err(dd, "Don't yet know about board "\r\n"with ID %u\n", boardrev);\r\nsnprintf(name, namelen, "Unknown_InfiniPath_QHT7xxx_%u",\r\nboardrev);\r\nbreak;\r\n}\r\nif (n)\r\nsnprintf(name, namelen, "%s", n);\r\nif (ret) {\r\nipath_dev_err(dd, "Unsupported InfiniPath board %s!\n", name);\r\ngoto bail;\r\n}\r\nif (dd->ipath_majrev != 3 || (dd->ipath_minrev < 2 ||\r\ndd->ipath_minrev > 4)) {\r\nipath_dev_err(dd,\r\n"Unsupported InfiniPath hardware revision %u.%u!\n",\r\ndd->ipath_majrev, dd->ipath_minrev);\r\nret = 1;\r\ngoto bail;\r\n}\r\ndd->ipath_flags |= IPATH_32BITCOUNTERS;\r\ndd->ipath_flags |= IPATH_GPIO_INTR;\r\nif (dd->ipath_lbus_speed != 800)\r\nipath_dev_err(dd,\r\n"Incorrectly configured for HT @ %uMHz\n",\r\ndd->ipath_lbus_speed);\r\ndd->ipath_ureg_align =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_pagealign);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void ipath_check_htlink(struct ipath_devdata *dd)\r\n{\r\nu8 linkerr, link_off, i;\r\nfor (i = 0; i < 2; i++) {\r\nlink_off = dd->ipath_ht_slave_off + i * 4 + 0xd;\r\nif (pci_read_config_byte(dd->pcidev, link_off, &linkerr))\r\ndev_info(&dd->pcidev->dev, "Couldn't read "\r\n"linkerror%d of HT slave/primary block\n",\r\ni);\r\nelse if (linkerr & 0xf0) {\r\nipath_cdbg(VERBOSE, "HT linkerr%d bits 0x%x set, "\r\n"clearing\n", linkerr >> 4, i);\r\nif (pci_write_config_byte(dd->pcidev, link_off,\r\nlinkerr))\r\nipath_dbg("Failed write to clear HT "\r\n"linkerror%d\n", i);\r\nif (pci_read_config_byte(dd->pcidev, link_off,\r\n&linkerr))\r\ndev_info(&dd->pcidev->dev,\r\n"Couldn't reread linkerror%d of "\r\n"HT slave/primary block\n", i);\r\nelse if (linkerr & 0xf0)\r\ndev_info(&dd->pcidev->dev,\r\n"HT linkerror%d bits 0x%x "\r\n"couldn't be cleared\n",\r\ni, linkerr >> 4);\r\n}\r\n}\r\n}\r\nstatic int ipath_setup_ht_reset(struct ipath_devdata *dd)\r\n{\r\nipath_dbg("No reset possible for this InfiniPath hardware\n");\r\nreturn 0;\r\n}\r\nstatic void slave_or_pri_blk(struct ipath_devdata *dd, struct pci_dev *pdev,\r\nint pos, u8 cap_type)\r\n{\r\nu8 linkwidth = 0, linkerr, link_a_b_off, link_off;\r\nu16 linkctrl = 0;\r\nint i;\r\ndd->ipath_ht_slave_off = pos;\r\nif ((cap_type >> 2) & 1)\r\nlink_a_b_off = 4;\r\nelse\r\nlink_a_b_off = 0;\r\nipath_cdbg(VERBOSE, "HT%u (Link %c) connected to processor\n",\r\nlink_a_b_off ? 1 : 0,\r\nlink_a_b_off ? 'B' : 'A');\r\nlink_a_b_off += pos;\r\nfor (i = 0; i < 2; i++) {\r\nlink_off = pos + i * 4 + 0x4;\r\nif (pci_read_config_word(pdev, link_off, &linkctrl))\r\nipath_dev_err(dd, "Couldn't read HT link control%d "\r\n"register\n", i);\r\nelse if (linkctrl & (0xf << 8)) {\r\nipath_cdbg(VERBOSE, "Clear linkctrl%d CRC Error "\r\n"bits %x\n", i, linkctrl & (0xf << 8));\r\npci_write_config_word(pdev, link_off,\r\nlinkctrl & (0xf << 8));\r\n}\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nlink_off = pos + i * 4 + 0xd;\r\nif (pci_read_config_byte(pdev, link_off, &linkerr))\r\ndev_info(&pdev->dev, "Couldn't read linkerror%d "\r\n"of HT slave/primary block\n", i);\r\nelse if (linkerr & 0xf0) {\r\nipath_cdbg(VERBOSE, "HT linkerr%d bits 0x%x set, "\r\n"clearing\n", linkerr >> 4, i);\r\nif (pci_write_config_byte\r\n(pdev, link_off, linkerr))\r\nipath_dbg("Failed write to clear HT "\r\n"linkerror%d\n", i);\r\nif (pci_read_config_byte(pdev, link_off, &linkerr))\r\ndev_info(&pdev->dev, "Couldn't reread "\r\n"linkerror%d of HT slave/primary "\r\n"block\n", i);\r\nelse if (linkerr & 0xf0)\r\ndev_info(&pdev->dev, "HT linkerror%d bits "\r\n"0x%x couldn't be cleared\n",\r\ni, linkerr >> 4);\r\n}\r\n}\r\nif (pci_read_config_byte(pdev, link_a_b_off + 7, &linkwidth))\r\nipath_dev_err(dd, "Couldn't read HT link width "\r\n"config register\n");\r\nelse {\r\nu32 width;\r\nswitch (linkwidth & 7) {\r\ncase 5:\r\nwidth = 4;\r\nbreak;\r\ncase 4:\r\nwidth = 2;\r\nbreak;\r\ncase 3:\r\nwidth = 32;\r\nbreak;\r\ncase 1:\r\nwidth = 16;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nwidth = 8;\r\nbreak;\r\n}\r\ndd->ipath_lbus_width = width;\r\nif (linkwidth != 0x11) {\r\nipath_dev_err(dd, "Not configured for 16 bit HT "\r\n"(%x)\n", linkwidth);\r\nif (!(linkwidth & 0xf)) {\r\nipath_dbg("Will ignore HT lane1 errors\n");\r\ndd->ipath_flags |= IPATH_8BIT_IN_HT0;\r\n}\r\n}\r\n}\r\nif (pci_read_config_byte(pdev, link_a_b_off + 0xd, &linkwidth))\r\nipath_dev_err(dd, "Couldn't read HT link frequency "\r\n"config register\n");\r\nelse {\r\nu32 speed;\r\nswitch (linkwidth & 0xf) {\r\ncase 6:\r\nspeed = 1000;\r\nbreak;\r\ncase 5:\r\nspeed = 800;\r\nbreak;\r\ncase 4:\r\nspeed = 600;\r\nbreak;\r\ncase 3:\r\nspeed = 500;\r\nbreak;\r\ncase 2:\r\nspeed = 400;\r\nbreak;\r\ncase 1:\r\nspeed = 300;\r\nbreak;\r\ndefault:\r\ncase 0:\r\nspeed = 200;\r\nbreak;\r\n}\r\ndd->ipath_lbus_speed = speed;\r\n}\r\nsnprintf(dd->ipath_lbus_info, sizeof(dd->ipath_lbus_info),\r\n"HyperTransport,%uMHz,x%u\n",\r\ndd->ipath_lbus_speed,\r\ndd->ipath_lbus_width);\r\n}\r\nstatic int ipath_ht_intconfig(struct ipath_devdata *dd)\r\n{\r\nint ret;\r\nif (dd->ipath_intconfig) {\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_interruptconfig,\r\ndd->ipath_intconfig);\r\nret = 0;\r\n} else {\r\nipath_dev_err(dd, "No interrupts enabled, couldn't setup "\r\n"interrupt address\n");\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ipath_ht_irq_update(struct pci_dev *dev, int irq,\r\nstruct ht_irq_msg *msg)\r\n{\r\nstruct ipath_devdata *dd = pci_get_drvdata(dev);\r\nu64 prev_intconfig = dd->ipath_intconfig;\r\ndd->ipath_intconfig = msg->address_lo;\r\ndd->ipath_intconfig |= ((u64) msg->address_hi) << 32;\r\nif (prev_intconfig)\r\nipath_ht_intconfig(dd);\r\n}\r\nstatic int ipath_setup_ht_config(struct ipath_devdata *dd,\r\nstruct pci_dev *pdev)\r\n{\r\nint pos, ret;\r\nret = __ht_create_irq(pdev, 0, ipath_ht_irq_update);\r\nif (ret < 0) {\r\nipath_dev_err(dd, "Couldn't create interrupt handler: "\r\n"err %d\n", ret);\r\ngoto bail;\r\n}\r\ndd->ipath_irq = ret;\r\nret = 0;\r\npos = pci_find_capability(pdev, PCI_CAP_ID_HT);\r\nif (!pos) {\r\nipath_dev_err(dd, "Couldn't find HyperTransport "\r\n"capability; no interrupts\n");\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\ndo {\r\nu8 cap_type;\r\nif (pci_read_config_byte(pdev, pos + 3, &cap_type)) {\r\ndev_info(&pdev->dev, "Couldn't read config "\r\n"command @ %d\n", pos);\r\ncontinue;\r\n}\r\nif (!(cap_type & 0xE0))\r\nslave_or_pri_blk(dd, pdev, pos, cap_type);\r\n} while ((pos = pci_find_next_capability(pdev, pos,\r\nPCI_CAP_ID_HT)));\r\ndd->ipath_flags |= IPATH_SWAP_PIOBUFS;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void ipath_setup_ht_cleanup(struct ipath_devdata *dd)\r\n{\r\n}\r\nstatic void ipath_setup_ht_setextled(struct ipath_devdata *dd,\r\nu64 lst, u64 ltst)\r\n{\r\nu64 extctl;\r\nunsigned long flags = 0;\r\nif (ipath_diag_inuse)\r\nreturn;\r\nif (dd->ipath_led_override) {\r\nltst = (dd->ipath_led_override & IPATH_LED_PHYS)\r\n? INFINIPATH_IBCS_LT_STATE_LINKUP\r\n: INFINIPATH_IBCS_LT_STATE_DISABLED;\r\nlst = (dd->ipath_led_override & IPATH_LED_LOG)\r\n? INFINIPATH_IBCS_L_STATE_ACTIVE\r\n: INFINIPATH_IBCS_L_STATE_DOWN;\r\n}\r\nspin_lock_irqsave(&dd->ipath_gpio_lock, flags);\r\nif (dd->ipath_boardrev == 8) {\r\nextctl = (dd->ipath_extctrl & ~INFINIPATH_EXTC_LEDGBLOK_ON)\r\n| INFINIPATH_EXTC_LEDGBLERR_OFF;\r\nif (ltst == INFINIPATH_IBCS_LT_STATE_LINKUP)\r\nextctl &= ~INFINIPATH_EXTC_LEDGBLERR_OFF;\r\nif (lst == INFINIPATH_IBCS_L_STATE_ACTIVE)\r\nextctl |= INFINIPATH_EXTC_LEDGBLOK_ON;\r\n}\r\nelse {\r\nextctl = dd->ipath_extctrl &\r\n~(INFINIPATH_EXTC_LED1PRIPORT_ON |\r\nINFINIPATH_EXTC_LED2PRIPORT_ON);\r\nif (ltst == INFINIPATH_IBCS_LT_STATE_LINKUP)\r\nextctl |= INFINIPATH_EXTC_LED1PRIPORT_ON;\r\nif (lst == INFINIPATH_IBCS_L_STATE_ACTIVE)\r\nextctl |= INFINIPATH_EXTC_LED2PRIPORT_ON;\r\n}\r\ndd->ipath_extctrl = extctl;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_extctrl, extctl);\r\nspin_unlock_irqrestore(&dd->ipath_gpio_lock, flags);\r\n}\r\nstatic void ipath_init_ht_variables(struct ipath_devdata *dd)\r\n{\r\ndd->ipath_kregs = &ipath_ht_kregs;\r\ndd->ipath_cregs = &ipath_ht_cregs;\r\ndd->ipath_gpio_sda_num = _IPATH_GPIO_SDA_NUM;\r\ndd->ipath_gpio_scl_num = _IPATH_GPIO_SCL_NUM;\r\ndd->ipath_gpio_sda = IPATH_GPIO_SDA;\r\ndd->ipath_gpio_scl = IPATH_GPIO_SCL;\r\ndd->ibcs_ls_shift = IBA6110_IBCS_LINKSTATE_SHIFT;\r\ndd->ibcs_lts_mask = IBA6110_IBCS_LINKTRAININGSTATE_MASK;\r\ndd->ibcs_mask = (INFINIPATH_IBCS_LINKSTATE_MASK <<\r\ndd->ibcs_ls_shift) | dd->ibcs_lts_mask;\r\ndd->ib_init = (INFINIPATH_IBCS_LT_STATE_LINKUP <<\r\nINFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |\r\n(INFINIPATH_IBCS_L_STATE_INIT << dd->ibcs_ls_shift);\r\ndd->ib_arm = (INFINIPATH_IBCS_LT_STATE_LINKUP <<\r\nINFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |\r\n(INFINIPATH_IBCS_L_STATE_ARM << dd->ibcs_ls_shift);\r\ndd->ib_active = (INFINIPATH_IBCS_LT_STATE_LINKUP <<\r\nINFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |\r\n(INFINIPATH_IBCS_L_STATE_ACTIVE << dd->ibcs_ls_shift);\r\ndd->ibcc_lic_mask = INFINIPATH_IBCC_LINKINITCMD_MASK;\r\ndd->ibcc_lc_shift = INFINIPATH_IBCC_LINKCMD_SHIFT;\r\ndd->ibcc_mpl_shift = INFINIPATH_IBCC_MAXPKTLEN_SHIFT;\r\ndd->ipath_r_portenable_shift = INFINIPATH_R_PORTENABLE_SHIFT;\r\ndd->ipath_r_intravail_shift = INFINIPATH_R_INTRAVAIL_SHIFT;\r\ndd->ipath_r_tailupd_shift = INFINIPATH_R_TAILUPD_SHIFT;\r\ndd->ipath_r_portcfg_shift = 0;\r\ndd->ipath_i_bitsextant =\r\n(INFINIPATH_I_RCVURG_MASK << INFINIPATH_I_RCVURG_SHIFT) |\r\n(INFINIPATH_I_RCVAVAIL_MASK <<\r\nINFINIPATH_I_RCVAVAIL_SHIFT) |\r\nINFINIPATH_I_ERROR | INFINIPATH_I_SPIOSENT |\r\nINFINIPATH_I_SPIOBUFAVAIL | INFINIPATH_I_GPIO;\r\ndd->ipath_e_bitsextant =\r\nINFINIPATH_E_RFORMATERR | INFINIPATH_E_RVCRC |\r\nINFINIPATH_E_RICRC | INFINIPATH_E_RMINPKTLEN |\r\nINFINIPATH_E_RMAXPKTLEN | INFINIPATH_E_RLONGPKTLEN |\r\nINFINIPATH_E_RSHORTPKTLEN | INFINIPATH_E_RUNEXPCHAR |\r\nINFINIPATH_E_RUNSUPVL | INFINIPATH_E_REBP |\r\nINFINIPATH_E_RIBFLOW | INFINIPATH_E_RBADVERSION |\r\nINFINIPATH_E_RRCVEGRFULL | INFINIPATH_E_RRCVHDRFULL |\r\nINFINIPATH_E_RBADTID | INFINIPATH_E_RHDRLEN |\r\nINFINIPATH_E_RHDR | INFINIPATH_E_RIBLOSTLINK |\r\nINFINIPATH_E_SMINPKTLEN | INFINIPATH_E_SMAXPKTLEN |\r\nINFINIPATH_E_SUNDERRUN | INFINIPATH_E_SPKTLEN |\r\nINFINIPATH_E_SDROPPEDSMPPKT | INFINIPATH_E_SDROPPEDDATAPKT |\r\nINFINIPATH_E_SPIOARMLAUNCH | INFINIPATH_E_SUNEXPERRPKTNUM |\r\nINFINIPATH_E_SUNSUPVL | INFINIPATH_E_IBSTATUSCHANGED |\r\nINFINIPATH_E_INVALIDADDR | INFINIPATH_E_RESET |\r\nINFINIPATH_E_HARDWARE;\r\ndd->ipath_hwe_bitsextant =\r\n(INFINIPATH_HWE_HTCMEMPARITYERR_MASK <<\r\nINFINIPATH_HWE_HTCMEMPARITYERR_SHIFT) |\r\n(INFINIPATH_HWE_TXEMEMPARITYERR_MASK <<\r\nINFINIPATH_HWE_TXEMEMPARITYERR_SHIFT) |\r\n(INFINIPATH_HWE_RXEMEMPARITYERR_MASK <<\r\nINFINIPATH_HWE_RXEMEMPARITYERR_SHIFT) |\r\nINFINIPATH_HWE_HTCLNKABYTE0CRCERR |\r\nINFINIPATH_HWE_HTCLNKABYTE1CRCERR |\r\nINFINIPATH_HWE_HTCLNKBBYTE0CRCERR |\r\nINFINIPATH_HWE_HTCLNKBBYTE1CRCERR |\r\nINFINIPATH_HWE_HTCMISCERR4 |\r\nINFINIPATH_HWE_HTCMISCERR5 | INFINIPATH_HWE_HTCMISCERR6 |\r\nINFINIPATH_HWE_HTCMISCERR7 |\r\nINFINIPATH_HWE_HTCBUSTREQPARITYERR |\r\nINFINIPATH_HWE_HTCBUSTRESPPARITYERR |\r\nINFINIPATH_HWE_HTCBUSIREQPARITYERR |\r\nINFINIPATH_HWE_RXDSYNCMEMPARITYERR |\r\nINFINIPATH_HWE_MEMBISTFAILED |\r\nINFINIPATH_HWE_COREPLL_FBSLIP |\r\nINFINIPATH_HWE_COREPLL_RFSLIP |\r\nINFINIPATH_HWE_HTBPLL_FBSLIP |\r\nINFINIPATH_HWE_HTBPLL_RFSLIP |\r\nINFINIPATH_HWE_HTAPLL_FBSLIP |\r\nINFINIPATH_HWE_HTAPLL_RFSLIP |\r\nINFINIPATH_HWE_SERDESPLLFAILED |\r\nINFINIPATH_HWE_IBCBUSTOSPCPARITYERR |\r\nINFINIPATH_HWE_IBCBUSFRSPCPARITYERR;\r\ndd->ipath_i_rcvavail_mask = INFINIPATH_I_RCVAVAIL_MASK;\r\ndd->ipath_i_rcvurg_mask = INFINIPATH_I_RCVURG_MASK;\r\ndd->ipath_i_rcvavail_shift = INFINIPATH_I_RCVAVAIL_SHIFT;\r\ndd->ipath_i_rcvurg_shift = INFINIPATH_I_RCVURG_SHIFT;\r\ndd->ipath_eep_st_masks[0].hwerrs_to_log =\r\nINFINIPATH_HWE_TXEMEMPARITYERR_MASK <<\r\nINFINIPATH_HWE_TXEMEMPARITYERR_SHIFT;\r\ndd->ipath_eep_st_masks[1].hwerrs_to_log =\r\nINFINIPATH_HWE_RXEMEMPARITYERR_MASK <<\r\nINFINIPATH_HWE_RXEMEMPARITYERR_SHIFT;\r\ndd->ipath_eep_st_masks[2].errs_to_log = INFINIPATH_E_RESET;\r\ndd->delay_mult = 2;\r\ndd->ipath_link_width_supported = IB_WIDTH_1X | IB_WIDTH_4X;\r\ndd->ipath_link_speed_supported = IPATH_IB_SDR;\r\ndd->ipath_link_width_enabled = IB_WIDTH_4X;\r\ndd->ipath_link_speed_enabled = dd->ipath_link_speed_supported;\r\ndd->ipath_link_width_active = dd->ipath_link_width_enabled;\r\ndd->ipath_link_speed_active = dd->ipath_link_speed_enabled;\r\n}\r\nstatic void ipath_ht_init_hwerrors(struct ipath_devdata *dd)\r\n{\r\nipath_err_t val;\r\nu64 extsval;\r\nextsval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_extstatus);\r\nif (!(extsval & INFINIPATH_EXTS_MEMBIST_ENDTEST))\r\nipath_dev_err(dd, "MemBIST did not complete!\n");\r\nif (extsval & INFINIPATH_EXTS_MEMBIST_CORRECT)\r\nipath_dbg("MemBIST corrected\n");\r\nipath_check_htlink(dd);\r\nval = -1LL;\r\nif (dd->ipath_flags & IPATH_8BIT_IN_HT0)\r\nval &= ~infinipath_hwe_htclnkabyte1crcerr;\r\nif (dd->ipath_flags & IPATH_8BIT_IN_HT1)\r\nval &= ~infinipath_hwe_htclnkbbyte1crcerr;\r\nval &= ~(INFINIPATH_HWE_SERDESPLLFAILED |\r\nINFINIPATH_HWE_RXDSYNCMEMPARITYERR);\r\nval &= ~INFINIPATH_HWE_HTCMISCERR4;\r\nif (dd->ipath_boardrev == 4 || dd->ipath_boardrev == 9)\r\nval &= ~INFINIPATH_HWE_SERDESPLLFAILED;\r\ndd->ipath_hwerrmask = val;\r\n}\r\nstatic int ipath_ht_bringup_serdes(struct ipath_devdata *dd)\r\n{\r\nu64 val, config1;\r\nint ret = 0, change = 0;\r\nipath_dbg("Trying to bringup serdes\n");\r\nif (ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwerrstatus) &\r\nINFINIPATH_HWE_SERDESPLLFAILED)\r\n{\r\nipath_dbg("At start, serdes PLL failed bit set in "\r\n"hwerrstatus, clearing and continuing\n");\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,\r\nINFINIPATH_HWE_SERDESPLLFAILED);\r\n}\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig0);\r\nconfig1 = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig1);\r\nipath_cdbg(VERBOSE, "Initial serdes status is config0=%llx "\r\n"config1=%llx, sstatus=%llx xgxs %llx\n",\r\n(unsigned long long) val, (unsigned long long) config1,\r\n(unsigned long long)\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesstatus),\r\n(unsigned long long)\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig));\r\nval |= INFINIPATH_SERDC0_RESET_PLL\r\n;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0, val);\r\nudelay(15);\r\nif (val & INFINIPATH_SERDC0_RESET_PLL) {\r\nu64 val2 = val &= ~INFINIPATH_SERDC0_RESET_PLL;\r\nval2 |= INFINIPATH_SERDC0_RESET_MASK |\r\nINFINIPATH_SERDC0_TXIDLE;\r\nipath_cdbg(VERBOSE, "Clearing serdes PLL reset (writing "\r\n"%llx)\n", (unsigned long long) val2);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0,\r\nval2);\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);\r\nudelay(15);\r\nval = val2;\r\n}\r\nif (val & (INFINIPATH_SERDC0_RESET_PLL |\r\nINFINIPATH_SERDC0_RESET_MASK |\r\nINFINIPATH_SERDC0_TXIDLE)) {\r\nval &= ~(INFINIPATH_SERDC0_RESET_PLL |\r\nINFINIPATH_SERDC0_RESET_MASK |\r\nINFINIPATH_SERDC0_TXIDLE);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0,\r\nval);\r\n}\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig);\r\nif (val & INFINIPATH_XGXS_RESET) {\r\nval &= ~INFINIPATH_XGXS_RESET;\r\nchange = 1;\r\n}\r\nif (((val >> INFINIPATH_XGXS_RX_POL_SHIFT) &\r\nINFINIPATH_XGXS_RX_POL_MASK) != dd->ipath_rx_pol_inv ) {\r\nval &= ~(INFINIPATH_XGXS_RX_POL_MASK <<\r\nINFINIPATH_XGXS_RX_POL_SHIFT);\r\nval |= dd->ipath_rx_pol_inv <<\r\nINFINIPATH_XGXS_RX_POL_SHIFT;\r\nchange = 1;\r\n}\r\nif (change)\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig0);\r\nconfig1 &= ~0x0ffffffff00ULL;\r\nconfig1 |= 0x00000000000ULL;\r\nconfig1 |= 0x0cccc000000ULL;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig1, config1);\r\nipath_cdbg(VERBOSE, "After setup: serdes status is config0=%llx "\r\n"config1=%llx, sstatus=%llx xgxs %llx\n",\r\n(unsigned long long) val, (unsigned long long) config1,\r\n(unsigned long long)\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesstatus),\r\n(unsigned long long)\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig));\r\nreturn ret;\r\n}\r\nstatic void ipath_ht_quiet_serdes(struct ipath_devdata *dd)\r\n{\r\nu64 val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig0);\r\nval |= INFINIPATH_SERDC0_TXIDLE;\r\nipath_dbg("Setting TxIdleEn on serdes (config0 = %llx)\n",\r\n(unsigned long long) val);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0, val);\r\n}\r\nstatic void ipath_ht_put_tid(struct ipath_devdata *dd,\r\nu64 __iomem *tidptr, u32 type,\r\nunsigned long pa)\r\n{\r\nif (!dd->ipath_kregbase)\r\nreturn;\r\nif (pa != dd->ipath_tidinvalid) {\r\nif (unlikely((pa & ~INFINIPATH_RT_ADDR_MASK))) {\r\ndev_info(&dd->pcidev->dev,\r\n"physaddr %lx has more than "\r\n"40 bits, using only 40!!!\n", pa);\r\npa &= INFINIPATH_RT_ADDR_MASK;\r\n}\r\nif (type == RCVHQ_RCV_TYPE_EAGER)\r\npa |= dd->ipath_tidtemplate;\r\nelse {\r\nu64 lenvalid = PAGE_SIZE >> 2;\r\nlenvalid <<= INFINIPATH_RT_BUFSIZE_SHIFT;\r\npa |= lenvalid | INFINIPATH_RT_VALID;\r\n}\r\n}\r\nwriteq(pa, tidptr);\r\n}\r\nstatic void ipath_ht_clear_tids(struct ipath_devdata *dd, unsigned port)\r\n{\r\nu64 __iomem *tidbase;\r\nint i;\r\nif (!dd->ipath_kregbase)\r\nreturn;\r\nipath_cdbg(VERBOSE, "Invalidate TIDs for port %u\n", port);\r\ntidbase = (u64 __iomem *) ((char __iomem *)(dd->ipath_kregbase) +\r\ndd->ipath_rcvtidbase +\r\nport * dd->ipath_rcvtidcnt *\r\nsizeof(*tidbase));\r\nfor (i = 0; i < dd->ipath_rcvtidcnt; i++)\r\nipath_ht_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EXPECTED,\r\ndd->ipath_tidinvalid);\r\ntidbase = (u64 __iomem *) ((char __iomem *)(dd->ipath_kregbase) +\r\ndd->ipath_rcvegrbase +\r\nport * dd->ipath_rcvegrcnt *\r\nsizeof(*tidbase));\r\nfor (i = 0; i < dd->ipath_rcvegrcnt; i++)\r\nipath_ht_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EAGER,\r\ndd->ipath_tidinvalid);\r\n}\r\nstatic void ipath_ht_tidtemplate(struct ipath_devdata *dd)\r\n{\r\ndd->ipath_tidtemplate = dd->ipath_ibmaxlen >> 2;\r\ndd->ipath_tidtemplate <<= INFINIPATH_RT_BUFSIZE_SHIFT;\r\ndd->ipath_tidtemplate |= INFINIPATH_RT_VALID;\r\ndd->ipath_tidinvalid = (-1LL & INFINIPATH_RT_BUFSIZE_MASK) <<\r\nINFINIPATH_RT_BUFSIZE_SHIFT;\r\n}\r\nstatic int ipath_ht_early_init(struct ipath_devdata *dd)\r\n{\r\nu32 __iomem *piobuf;\r\nu32 pioincr, val32;\r\nint i;\r\ndd->ipath_rcvhdrentsize = 16;\r\ndd->ipath_rcvhdrsize = IPATH_DFLT_RCVHDRSIZE;\r\ndd->ipath_rcvegrbufsize = dd->ipath_piosize2k;\r\ndd->ipath_ibmaxlen = min(dd->ipath_piosize2k,\r\ndd->ipath_rcvegrbufsize);\r\ndd->ipath_init_ibmaxlen = dd->ipath_ibmaxlen;\r\nipath_ht_tidtemplate(dd);\r\nfor (val32 = 0; val32 < dd->ipath_portcnt; val32++)\r\nipath_ht_clear_tids(dd, val32);\r\npiobuf = (u32 __iomem *) (((char __iomem *)(dd->ipath_kregbase)) +\r\ndd->ipath_piobufbase);\r\npioincr = dd->ipath_palign / sizeof(*piobuf);\r\nfor (i = 0; i < dd->ipath_piobcnt2k; i++) {\r\nwritel(16, piobuf);\r\npiobuf += pioincr;\r\n}\r\nipath_get_eeprom_info(dd);\r\nif (dd->ipath_boardrev == 5) {\r\nif (dd->ipath_serial[0] == '1' &&\r\ndd->ipath_serial[1] == '2' &&\r\ndd->ipath_serial[2] == '8')\r\ndd->ipath_flags |= IPATH_GPIO_INTR;\r\nelse {\r\nipath_dev_err(dd, "Unsupported InfiniPath board "\r\n"(serial number %.16s)!\n",\r\ndd->ipath_serial);\r\nreturn 1;\r\n}\r\n}\r\nif (dd->ipath_minrev >= 4) {\r\ndd->ipath_flags |= IPATH_GPIO_ERRINTRS;\r\ndd->ipath_gpio_mask |= IPATH_GPIO_ERRINTR_MASK;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_gpio_mask,\r\ndd->ipath_gpio_mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipath_ht_get_base_info(struct ipath_portdata *pd, void *kbase)\r\n{\r\nstruct ipath_base_info *kinfo = kbase;\r\nkinfo->spi_runtime_flags |= IPATH_RUNTIME_HT |\r\nIPATH_RUNTIME_PIO_REGSWAPPED;\r\nif (pd->port_dd->ipath_minrev < 4)\r\nkinfo->spi_runtime_flags |= IPATH_RUNTIME_RCVHDR_COPY;\r\nreturn 0;\r\n}\r\nstatic void ipath_ht_free_irq(struct ipath_devdata *dd)\r\n{\r\nfree_irq(dd->ipath_irq, dd);\r\nht_destroy_irq(dd->ipath_irq);\r\ndd->ipath_irq = 0;\r\ndd->ipath_intconfig = 0;\r\n}\r\nstatic struct ipath_message_header *\r\nipath_ht_get_msgheader(struct ipath_devdata *dd, __le32 *rhf_addr)\r\n{\r\nreturn (struct ipath_message_header *)\r\n&rhf_addr[sizeof(u64) / sizeof(u32)];\r\n}\r\nstatic void ipath_ht_config_ports(struct ipath_devdata *dd, ushort cfgports)\r\n{\r\ndd->ipath_portcnt =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_portcnt);\r\ndd->ipath_p0_rcvegrcnt =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvegrcnt);\r\n}\r\nstatic void ipath_ht_read_counters(struct ipath_devdata *dd,\r\nstruct infinipath_counters *cntrs)\r\n{\r\ncntrs->LBIntCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(LBIntCnt));\r\ncntrs->LBFlowStallCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(LBFlowStallCnt));\r\ncntrs->TxSDmaDescCnt = 0;\r\ncntrs->TxUnsupVLErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxUnsupVLErrCnt));\r\ncntrs->TxDataPktCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxDataPktCnt));\r\ncntrs->TxFlowPktCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxFlowPktCnt));\r\ncntrs->TxDwordCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxDwordCnt));\r\ncntrs->TxLenErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxLenErrCnt));\r\ncntrs->TxMaxMinLenErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxMaxMinLenErrCnt));\r\ncntrs->TxUnderrunCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxUnderrunCnt));\r\ncntrs->TxFlowStallCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxFlowStallCnt));\r\ncntrs->TxDroppedPktCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxDroppedPktCnt));\r\ncntrs->RxDroppedPktCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxDroppedPktCnt));\r\ncntrs->RxDataPktCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxDataPktCnt));\r\ncntrs->RxFlowPktCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxFlowPktCnt));\r\ncntrs->RxDwordCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxDwordCnt));\r\ncntrs->RxLenErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxLenErrCnt));\r\ncntrs->RxMaxMinLenErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxMaxMinLenErrCnt));\r\ncntrs->RxICRCErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxICRCErrCnt));\r\ncntrs->RxVCRCErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxVCRCErrCnt));\r\ncntrs->RxFlowCtrlErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxFlowCtrlErrCnt));\r\ncntrs->RxBadFormatCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxBadFormatCnt));\r\ncntrs->RxLinkProblemCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxLinkProblemCnt));\r\ncntrs->RxEBPCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxEBPCnt));\r\ncntrs->RxLPCRCErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxLPCRCErrCnt));\r\ncntrs->RxBufOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxBufOvflCnt));\r\ncntrs->RxTIDFullErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxTIDFullErrCnt));\r\ncntrs->RxTIDValidErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxTIDValidErrCnt));\r\ncntrs->RxPKeyMismatchCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxPKeyMismatchCnt));\r\ncntrs->RxP0HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP0HdrEgrOvflCnt));\r\ncntrs->RxP1HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP1HdrEgrOvflCnt));\r\ncntrs->RxP2HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP2HdrEgrOvflCnt));\r\ncntrs->RxP3HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP3HdrEgrOvflCnt));\r\ncntrs->RxP4HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP4HdrEgrOvflCnt));\r\ncntrs->RxP5HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP5HdrEgrOvflCnt));\r\ncntrs->RxP6HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP6HdrEgrOvflCnt));\r\ncntrs->RxP7HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP7HdrEgrOvflCnt));\r\ncntrs->RxP8HdrEgrOvflCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP8HdrEgrOvflCnt));\r\ncntrs->RxP9HdrEgrOvflCnt = 0;\r\ncntrs->RxP10HdrEgrOvflCnt = 0;\r\ncntrs->RxP11HdrEgrOvflCnt = 0;\r\ncntrs->RxP12HdrEgrOvflCnt = 0;\r\ncntrs->RxP13HdrEgrOvflCnt = 0;\r\ncntrs->RxP14HdrEgrOvflCnt = 0;\r\ncntrs->RxP15HdrEgrOvflCnt = 0;\r\ncntrs->RxP16HdrEgrOvflCnt = 0;\r\ncntrs->IBStatusChangeCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBStatusChangeCnt));\r\ncntrs->IBLinkErrRecoveryCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBLinkErrRecoveryCnt));\r\ncntrs->IBLinkDownedCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBLinkDownedCnt));\r\ncntrs->IBSymbolErrCnt =\r\nipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBSymbolErrCnt));\r\ncntrs->RxVL15DroppedPktCnt = 0;\r\ncntrs->RxOtherLocalPhyErrCnt = 0;\r\ncntrs->PcieRetryBufDiagQwordCnt = 0;\r\ncntrs->ExcessBufferOvflCnt = dd->ipath_overrun_thresh_errs;\r\ncntrs->LocalLinkIntegrityErrCnt =\r\n(dd->ipath_flags & IPATH_GPIO_ERRINTRS) ?\r\ndd->ipath_lli_errs : dd->ipath_lli_errors;\r\ncntrs->RxVlErrCnt = 0;\r\ncntrs->RxDlidFltrCnt = 0;\r\n}\r\nstatic int ipath_ht_nointr_fallback(struct ipath_devdata *dd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ipath_ht_xgxs_reset(struct ipath_devdata *dd)\r\n{\r\nu64 val, prev_val;\r\nprev_val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig);\r\nval = prev_val | INFINIPATH_XGXS_RESET;\r\nprev_val &= ~INFINIPATH_XGXS_RESET;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_control,\r\ndd->ipath_control & ~INFINIPATH_C_LINKENABLE);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, prev_val);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_control,\r\ndd->ipath_control);\r\n}\r\nstatic int ipath_ht_get_ib_cfg(struct ipath_devdata *dd, int which)\r\n{\r\nint ret;\r\nswitch (which) {\r\ncase IPATH_IB_CFG_LWID:\r\nret = dd->ipath_link_width_active;\r\nbreak;\r\ncase IPATH_IB_CFG_SPD:\r\nret = dd->ipath_link_speed_active;\r\nbreak;\r\ncase IPATH_IB_CFG_LWID_ENB:\r\nret = dd->ipath_link_width_enabled;\r\nbreak;\r\ncase IPATH_IB_CFG_SPD_ENB:\r\nret = dd->ipath_link_speed_enabled;\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipath_ht_set_ib_cfg(struct ipath_devdata *dd, int which, u32 val)\r\n{\r\nint ret = 0;\r\nif (which == IPATH_IB_CFG_LWID_ENB)\r\ndd->ipath_link_width_enabled = val;\r\nelse if (which == IPATH_IB_CFG_SPD_ENB)\r\ndd->ipath_link_speed_enabled = val;\r\nelse\r\nret = -ENOTSUPP;\r\nreturn ret;\r\n}\r\nstatic void ipath_ht_config_jint(struct ipath_devdata *dd, u16 a, u16 b)\r\n{\r\n}\r\nstatic int ipath_ht_ib_updown(struct ipath_devdata *dd, int ibup, u64 ibcs)\r\n{\r\nipath_setup_ht_setextled(dd, ipath_ib_linkstate(dd, ibcs),\r\nipath_ib_linktrstate(dd, ibcs));\r\nreturn 0;\r\n}\r\nvoid ipath_init_iba6110_funcs(struct ipath_devdata *dd)\r\n{\r\ndd->ipath_f_intrsetup = ipath_ht_intconfig;\r\ndd->ipath_f_bus = ipath_setup_ht_config;\r\ndd->ipath_f_reset = ipath_setup_ht_reset;\r\ndd->ipath_f_get_boardname = ipath_ht_boardname;\r\ndd->ipath_f_init_hwerrors = ipath_ht_init_hwerrors;\r\ndd->ipath_f_early_init = ipath_ht_early_init;\r\ndd->ipath_f_handle_hwerrors = ipath_ht_handle_hwerrors;\r\ndd->ipath_f_quiet_serdes = ipath_ht_quiet_serdes;\r\ndd->ipath_f_bringup_serdes = ipath_ht_bringup_serdes;\r\ndd->ipath_f_clear_tids = ipath_ht_clear_tids;\r\ndd->ipath_f_put_tid = ipath_ht_put_tid;\r\ndd->ipath_f_cleanup = ipath_setup_ht_cleanup;\r\ndd->ipath_f_setextled = ipath_setup_ht_setextled;\r\ndd->ipath_f_get_base_info = ipath_ht_get_base_info;\r\ndd->ipath_f_free_irq = ipath_ht_free_irq;\r\ndd->ipath_f_tidtemplate = ipath_ht_tidtemplate;\r\ndd->ipath_f_intr_fallback = ipath_ht_nointr_fallback;\r\ndd->ipath_f_get_msgheader = ipath_ht_get_msgheader;\r\ndd->ipath_f_config_ports = ipath_ht_config_ports;\r\ndd->ipath_f_read_counters = ipath_ht_read_counters;\r\ndd->ipath_f_xgxs_reset = ipath_ht_xgxs_reset;\r\ndd->ipath_f_get_ib_cfg = ipath_ht_get_ib_cfg;\r\ndd->ipath_f_set_ib_cfg = ipath_ht_set_ib_cfg;\r\ndd->ipath_f_config_jint = ipath_ht_config_jint;\r\ndd->ipath_f_ib_updown = ipath_ht_ib_updown;\r\nipath_init_ht_variables(dd);\r\n}
