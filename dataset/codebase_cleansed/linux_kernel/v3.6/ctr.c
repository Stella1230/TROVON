static int crypto_ctr_setkey(struct crypto_tfm *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(parent);\r\nstruct crypto_cipher *child = ctx->child;\r\nint err;\r\ncrypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_cipher_setkey(child, key, keylen);\r\ncrypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic void crypto_ctr_crypt_final(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nunsigned long alignmask = crypto_cipher_alignmask(tfm);\r\nu8 *ctrblk = walk->iv;\r\nu8 tmp[bsize + alignmask];\r\nu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\ncrypto_cipher_encrypt_one(tfm, keystream, ctrblk);\r\ncrypto_xor(keystream, src, nbytes);\r\nmemcpy(dst, keystream, nbytes);\r\ncrypto_inc(ctrblk, bsize);\r\n}\r\nstatic int crypto_ctr_crypt_segment(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\r\ncrypto_cipher_alg(tfm)->cia_encrypt;\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nu8 *ctrblk = walk->iv;\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\ndo {\r\nfn(crypto_cipher_tfm(tfm), dst, ctrblk);\r\ncrypto_xor(dst, src, bsize);\r\ncrypto_inc(ctrblk, bsize);\r\nsrc += bsize;\r\ndst += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_ctr_crypt_inplace(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\r\ncrypto_cipher_alg(tfm)->cia_encrypt;\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nunsigned long alignmask = crypto_cipher_alignmask(tfm);\r\nunsigned int nbytes = walk->nbytes;\r\nu8 *ctrblk = walk->iv;\r\nu8 *src = walk->src.virt.addr;\r\nu8 tmp[bsize + alignmask];\r\nu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\r\ndo {\r\nfn(crypto_cipher_tfm(tfm), keystream, ctrblk);\r\ncrypto_xor(src, keystream, bsize);\r\ncrypto_inc(ctrblk, bsize);\r\nsrc += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_ctr_crypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nstruct crypto_blkcipher *tfm = desc->tfm;\r\nstruct crypto_ctr_ctx *ctx = crypto_blkcipher_ctx(tfm);\r\nstruct crypto_cipher *child = ctx->child;\r\nunsigned int bsize = crypto_cipher_blocksize(child);\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt_block(desc, &walk, bsize);\r\nwhile (walk.nbytes >= bsize) {\r\nif (walk.src.virt.addr == walk.dst.virt.addr)\r\nnbytes = crypto_ctr_crypt_inplace(&walk, child);\r\nelse\r\nnbytes = crypto_ctr_crypt_segment(&walk, child);\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nif (walk.nbytes) {\r\ncrypto_ctr_crypt_final(&walk, child);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int crypto_ctr_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_cipher *cipher;\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void crypto_ctr_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_ctr_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_BLKCIPHER);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nalg = crypto_attr_alg(tb[1], CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\nerr = -EINVAL;\r\nif (alg->cra_blocksize < 4)\r\ngoto out_put_alg;\r\nif (alg->cra_blocksize % 4)\r\ngoto out_put_alg;\r\ninst = crypto_alloc_instance("ctr", alg);\r\nif (IS_ERR(inst))\r\ngoto out;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask | (__alignof__(u32) - 1);\r\ninst->alg.cra_type = &crypto_blkcipher_type;\r\ninst->alg.cra_blkcipher.ivsize = alg->cra_blocksize;\r\ninst->alg.cra_blkcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\r\ninst->alg.cra_blkcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_ctr_ctx);\r\ninst->alg.cra_init = crypto_ctr_init_tfm;\r\ninst->alg.cra_exit = crypto_ctr_exit_tfm;\r\ninst->alg.cra_blkcipher.setkey = crypto_ctr_setkey;\r\ninst->alg.cra_blkcipher.encrypt = crypto_ctr_crypt;\r\ninst->alg.cra_blkcipher.decrypt = crypto_ctr_crypt;\r\ninst->alg.cra_blkcipher.geniv = "chainiv";\r\nout:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\nout_put_alg:\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic void crypto_ctr_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc3686_setkey(struct crypto_tfm *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc3686_ctx *ctx = crypto_tfm_ctx(parent);\r\nstruct crypto_blkcipher *child = ctx->child;\r\nint err;\r\nif (keylen < CTR_RFC3686_NONCE_SIZE)\r\nreturn -EINVAL;\r\nmemcpy(ctx->nonce, key + (keylen - CTR_RFC3686_NONCE_SIZE),\r\nCTR_RFC3686_NONCE_SIZE);\r\nkeylen -= CTR_RFC3686_NONCE_SIZE;\r\ncrypto_blkcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_blkcipher_set_flags(child, crypto_tfm_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_blkcipher_setkey(child, key, keylen);\r\ncrypto_tfm_set_flags(parent, crypto_blkcipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc3686_crypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct crypto_blkcipher *tfm = desc->tfm;\r\nstruct crypto_rfc3686_ctx *ctx = crypto_blkcipher_ctx(tfm);\r\nstruct crypto_blkcipher *child = ctx->child;\r\nunsigned long alignmask = crypto_blkcipher_alignmask(tfm);\r\nu8 ivblk[CTR_RFC3686_BLOCK_SIZE + alignmask];\r\nu8 *iv = PTR_ALIGN(ivblk + 0, alignmask + 1);\r\nu8 *info = desc->info;\r\nint err;\r\nmemcpy(iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);\r\nmemcpy(iv + CTR_RFC3686_NONCE_SIZE, info, CTR_RFC3686_IV_SIZE);\r\n*(__be32 *)(iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =\r\ncpu_to_be32(1);\r\ndesc->tfm = child;\r\ndesc->info = iv;\r\nerr = crypto_blkcipher_encrypt_iv(desc, dst, src, nbytes);\r\ndesc->tfm = tfm;\r\ndesc->info = info;\r\nreturn err;\r\n}\r\nstatic int crypto_rfc3686_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_rfc3686_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_blkcipher *cipher;\r\ncipher = crypto_spawn_blkcipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc3686_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_rfc3686_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_blkcipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_rfc3686_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_BLKCIPHER);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nalg = crypto_attr_alg(tb[1], CRYPTO_ALG_TYPE_BLKCIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nerr = PTR_ERR(alg);\r\nif (IS_ERR(alg))\r\nreturn ERR_PTR(err);\r\nerr = -EINVAL;\r\nif (alg->cra_blkcipher.ivsize != CTR_RFC3686_BLOCK_SIZE)\r\ngoto out_put_alg;\r\nif (alg->cra_blocksize != 1)\r\ngoto out_put_alg;\r\ninst = crypto_alloc_instance("rfc3686", alg);\r\nif (IS_ERR(inst))\r\ngoto out;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_type = &crypto_blkcipher_type;\r\ninst->alg.cra_blkcipher.ivsize = CTR_RFC3686_IV_SIZE;\r\ninst->alg.cra_blkcipher.min_keysize = alg->cra_blkcipher.min_keysize\r\n+ CTR_RFC3686_NONCE_SIZE;\r\ninst->alg.cra_blkcipher.max_keysize = alg->cra_blkcipher.max_keysize\r\n+ CTR_RFC3686_NONCE_SIZE;\r\ninst->alg.cra_blkcipher.geniv = "seqiv";\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_rfc3686_ctx);\r\ninst->alg.cra_init = crypto_rfc3686_init_tfm;\r\ninst->alg.cra_exit = crypto_rfc3686_exit_tfm;\r\ninst->alg.cra_blkcipher.setkey = crypto_rfc3686_setkey;\r\ninst->alg.cra_blkcipher.encrypt = crypto_rfc3686_crypt;\r\ninst->alg.cra_blkcipher.decrypt = crypto_rfc3686_crypt;\r\nout:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\nout_put_alg:\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic int __init crypto_ctr_module_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_template(&crypto_ctr_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_rfc3686_tmpl);\r\nif (err)\r\ngoto out_drop_ctr;\r\nout:\r\nreturn err;\r\nout_drop_ctr:\r\ncrypto_unregister_template(&crypto_ctr_tmpl);\r\ngoto out;\r\n}\r\nstatic void __exit crypto_ctr_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_rfc3686_tmpl);\r\ncrypto_unregister_template(&crypto_ctr_tmpl);\r\n}
