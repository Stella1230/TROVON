static __init int check_forcefamily(unsigned char forced_family[2])\r\n{\r\nconst char *p;\r\nforced_family[0] = '\0';\r\nforced_family[1] = '\0';\r\nstrncpy(cmdline, arcs_cmdline, COMMAND_LINE_SIZE - 1);\r\np = strstr(cmdline, FORCEFAMILY_PARAM);\r\nif (p && (p != cmdline) && (*(p - 1) != ' '))\r\np = strstr(p, " " FORCEFAMILY_PARAM "=");\r\nif (p) {\r\np += strlen(FORCEFAMILY_PARAM "=");\r\nif (*p == '\0' || *(p + 1) == '\0' ||\r\n(*(p + 2) != '\0' && *(p + 2) != ' '))\r\npr_err(FORCEFAMILY_PARAM " must be exactly two "\r\n"characters long, ignoring value\n");\r\nelse {\r\nforced_family[0] = *p;\r\nforced_family[1] = *(p + 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic __init noinline void platform_set_family(void)\r\n{\r\nunsigned char forced_family[2];\r\nunsigned short bootldr_family;\r\nif (check_forcefamily(forced_family) == 0)\r\nbootldr_family = BOOTLDRFAMILY(forced_family[0],\r\nforced_family[1]);\r\nelse {\r\n#ifdef CONFIG_BOOTLOADER_DRIVER\r\nbootldr_family = (unsigned short) kbldr_GetSWFamily();\r\n#else\r\n#if defined(CONFIG_BOOTLOADER_FAMILY)\r\nbootldr_family = (unsigned short) BOOTLDRFAMILY(\r\nCONFIG_BOOTLOADER_FAMILY[0],\r\nCONFIG_BOOTLOADER_FAMILY[1]);\r\n#else\r\n#error "Unknown Bootloader Family"\r\n#endif\r\n#endif\r\n}\r\npr_info("Bootloader Family = 0x%04X\n", bootldr_family);\r\nswitch (bootldr_family) {\r\ncase BOOTLDRFAMILY('R', '1'):\r\nplatform_family = FAMILY_1500;\r\nbreak;\r\ncase BOOTLDRFAMILY('4', '4'):\r\nplatform_family = FAMILY_4500;\r\nbreak;\r\ncase BOOTLDRFAMILY('4', '6'):\r\nplatform_family = FAMILY_4600;\r\nbreak;\r\ncase BOOTLDRFAMILY('A', '1'):\r\nplatform_family = FAMILY_4600VZA;\r\nbreak;\r\ncase BOOTLDRFAMILY('8', '5'):\r\nplatform_family = FAMILY_8500;\r\nbreak;\r\ncase BOOTLDRFAMILY('R', '2'):\r\nplatform_family = FAMILY_8500RNG;\r\nbreak;\r\ncase BOOTLDRFAMILY('8', '6'):\r\nplatform_family = FAMILY_8600;\r\nbreak;\r\ncase BOOTLDRFAMILY('B', '1'):\r\nplatform_family = FAMILY_8600VZB;\r\nbreak;\r\ncase BOOTLDRFAMILY('E', '1'):\r\nplatform_family = FAMILY_1500VZE;\r\nbreak;\r\ncase BOOTLDRFAMILY('F', '1'):\r\nplatform_family = FAMILY_1500VZF;\r\nbreak;\r\ncase BOOTLDRFAMILY('8', '7'):\r\nplatform_family = FAMILY_8700;\r\nbreak;\r\ndefault:\r\nplatform_family = -1;\r\n}\r\n}\r\nunsigned int platform_get_family(void)\r\n{\r\nreturn platform_family;\r\n}\r\nenum asic_type platform_get_asic(void)\r\n{\r\nreturn asic;\r\n}\r\nstatic void __init set_register_map(unsigned long phys_base,\r\nconst struct register_map *map)\r\n{\r\nasic_phy_base = phys_base;\r\n_asic_register_map = *map;\r\nregister_map_virtualize(&_asic_register_map);\r\nasic_base = (unsigned long)ioremap_nocache(phys_base, ASIC_IO_SIZE);\r\n}\r\nvoid __init configure_platform(void)\r\n{\r\nplatform_set_family();\r\nswitch (platform_family) {\r\ncase FAMILY_1500:\r\ncase FAMILY_1500VZE:\r\ncase FAMILY_1500VZF:\r\nplatform_features = FFS_CAPABLE;\r\nasic = ASIC_CALLIOPE;\r\nset_register_map(CALLIOPE_IO_BASE, &calliope_register_map);\r\nif (platform_family == FAMILY_1500VZE) {\r\ngp_resources = non_dvr_vze_calliope_resources;\r\npr_info("Platform: 1500/Vz Class E - "\r\n"CALLIOPE, NON_DVR_CAPABLE\n");\r\n} else if (platform_family == FAMILY_1500VZF) {\r\ngp_resources = non_dvr_vzf_calliope_resources;\r\npr_info("Platform: 1500/Vz Class F - "\r\n"CALLIOPE, NON_DVR_CAPABLE\n");\r\n} else {\r\ngp_resources = non_dvr_calliope_resources;\r\npr_info("Platform: 1500/RNG100 - CALLIOPE, "\r\n"NON_DVR_CAPABLE\n");\r\n}\r\nbreak;\r\ncase FAMILY_4500:\r\nplatform_features = FFS_CAPABLE | PCIE_CAPABLE |\r\nDISPLAY_CAPABLE;\r\nasic = ASIC_ZEUS;\r\nset_register_map(ZEUS_IO_BASE, &zeus_register_map);\r\ngp_resources = non_dvr_zeus_resources;\r\npr_info("Platform: 4500 - ZEUS, NON_DVR_CAPABLE\n");\r\nbreak;\r\ncase FAMILY_4600:\r\n{\r\nunsigned int chipversion = 0;\r\nplatform_features = FFS_CAPABLE | DISPLAY_CAPABLE;\r\nset_register_map(CRONUS_IO_BASE, &cronus_register_map);\r\nchipversion = asic_read(chipver3) << 24;\r\nchipversion |= asic_read(chipver2) << 16;\r\nchipversion |= asic_read(chipver1) << 8;\r\nchipversion |= asic_read(chipver0);\r\nif ((chipversion == CRONUS_10) || (chipversion == CRONUS_11))\r\nasic = ASIC_CRONUS;\r\nelse\r\nasic = ASIC_CRONUSLITE;\r\ngp_resources = non_dvr_cronuslite_resources;\r\npr_info("Platform: 4600 - %s, NON_DVR_CAPABLE, "\r\n"chipversion=0x%08X\n",\r\n(asic == ASIC_CRONUS) ? "CRONUS" : "CRONUS LITE",\r\nchipversion);\r\nbreak;\r\n}\r\ncase FAMILY_4600VZA:\r\nplatform_features = FFS_CAPABLE | DISPLAY_CAPABLE;\r\nasic = ASIC_CRONUS;\r\nset_register_map(CRONUS_IO_BASE, &cronus_register_map);\r\ngp_resources = non_dvr_cronus_resources;\r\npr_info("Platform: Vz Class A - CRONUS, NON_DVR_CAPABLE\n");\r\nbreak;\r\ncase FAMILY_8500:\r\ncase FAMILY_8500RNG:\r\nplatform_features = DVR_CAPABLE | PCIE_CAPABLE |\r\nDISPLAY_CAPABLE;\r\nasic = ASIC_ZEUS;\r\nset_register_map(ZEUS_IO_BASE, &zeus_register_map);\r\ngp_resources = dvr_zeus_resources;\r\npr_info("Platform: 8500/RNG200 - ZEUS, DVR_CAPABLE\n");\r\nbreak;\r\ncase FAMILY_8600:\r\ncase FAMILY_8600VZB:\r\nplatform_features = DVR_CAPABLE | PCIE_CAPABLE |\r\nDISPLAY_CAPABLE;\r\nasic = ASIC_CRONUS;\r\nset_register_map(CRONUS_IO_BASE, &cronus_register_map);\r\ngp_resources = dvr_cronus_resources;\r\npr_info("Platform: 8600/Vz Class B - CRONUS, "\r\n"DVR_CAPABLE\n");\r\nbreak;\r\ncase FAMILY_8700:\r\nplatform_features = FFS_CAPABLE | PCIE_CAPABLE;\r\nasic = ASIC_GAIA;\r\nset_register_map(GAIA_IO_BASE, &gaia_register_map);\r\ngp_resources = dvr_gaia_resources;\r\npr_info("Platform: 8700 - GAIA, DVR_CAPABLE\n");\r\nbreak;\r\ndefault:\r\npr_crit("Platform: UNKNOWN PLATFORM\n");\r\nbreak;\r\n}\r\nswitch (asic) {\r\ncase ASIC_ZEUS:\r\nphys_to_dma_offset = 0x30000000;\r\nbreak;\r\ncase ASIC_CALLIOPE:\r\nphys_to_dma_offset = 0x10000000;\r\nbreak;\r\ncase ASIC_CRONUSLITE:\r\ncase ASIC_CRONUS:\r\nphys_to_dma_offset = 0x10000000;\r\nbreak;\r\ndefault:\r\nphys_to_dma_offset = 0x00000000;\r\nbreak;\r\n}\r\n}\r\nvoid __init platform_alloc_bootmem(void)\r\n{\r\nint i;\r\nint total = 0;\r\npmem_setup_resource();\r\nfor (i = 0; gp_resources[i].flags != 0; i++) {\r\nint size = resource_size(&gp_resources[i]);\r\nif ((gp_resources[i].start != 0) &&\r\n((gp_resources[i].flags & IORESOURCE_MEM) != 0)) {\r\nreserve_bootmem(dma_to_phys(gp_resources[i].start),\r\nsize, 0);\r\ntotal += resource_size(&gp_resources[i]);\r\npr_info("reserve resource %s at %08x (%u bytes)\n",\r\ngp_resources[i].name, gp_resources[i].start,\r\nresource_size(&gp_resources[i]));\r\n}\r\n}\r\nfor (i = 0; gp_resources[i].flags != 0; i++) {\r\nint size = resource_size(&gp_resources[i]);\r\nif ((gp_resources[i].start == 0) &&\r\n((gp_resources[i].flags & IORESOURCE_MEM) != 0)) {\r\nvoid *mem = alloc_bootmem_pages(size);\r\nif (mem == NULL)\r\npr_err("Unable to allocate bootmem pages "\r\n"for %s\n", gp_resources[i].name);\r\nelse {\r\ngp_resources[i].start =\r\nphys_to_dma(virt_to_phys(mem));\r\ngp_resources[i].end =\r\ngp_resources[i].start + size - 1;\r\ntotal += size;\r\npr_info("allocate resource %s at %08x "\r\n"(%u bytes)\n",\r\ngp_resources[i].name,\r\ngp_resources[i].start, size);\r\n}\r\n}\r\n}\r\npr_info("Total Platform driver memory allocation: 0x%08x\n", total);\r\nfor (i = 0; gp_resources[i].flags != 0; i++) {\r\nif ((gp_resources[i].start != 0) &&\r\n((gp_resources[i].flags & IORESOURCE_IO) != 0)) {\r\npr_info("reserved platform resource %s at %08x\n",\r\ngp_resources[i].name, gp_resources[i].start);\r\n}\r\n}\r\n}\r\nstatic int __init early_param_pmemaddr(char *p)\r\n{\r\npmemaddr = (unsigned long)simple_strtoul(p, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int __init early_param_pmemlen(char *p)\r\n{\r\n#if 0\r\npmemlen = (unsigned long)simple_strtoul(p, NULL, 0);\r\n#else\r\npmemlen = 0x20000;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __init pmem_setup_resource(void)\r\n{\r\nstruct resource *resource;\r\nresource = asic_resource_get("DiagPersistentMemory");\r\nif (resource && pmemaddr && pmemlen) {\r\nresource->start = phys_to_dma(pmemaddr - 0x80000000);\r\nresource->end = resource->start + pmemlen - 1;\r\npr_info("persistent memory: start=0x%x end=0x%x\n",\r\nresource->start, resource->end);\r\n}\r\n}\r\nstruct resource *asic_resource_get(const char *name)\r\n{\r\nint i;\r\nfor (i = 0; gp_resources[i].flags != 0; i++) {\r\nif (strcmp(gp_resources[i].name, name) == 0)\r\nreturn &gp_resources[i];\r\n}\r\nreturn NULL;\r\n}\r\nvoid platform_release_memory(void *ptr, int size)\r\n{\r\nunsigned long addr;\r\nunsigned long end;\r\naddr = ((unsigned long)ptr + (PAGE_SIZE - 1)) & PAGE_MASK;\r\nend = ((unsigned long)ptr + size) & PAGE_MASK;\r\nfor (; addr < end; addr += PAGE_SIZE) {\r\nClearPageReserved(virt_to_page(__va(addr)));\r\ninit_page_count(virt_to_page(__va(addr)));\r\nfree_page((unsigned long)__va(addr));\r\n}\r\n}\r\nint platform_supports_dvr(void)\r\n{\r\nreturn (platform_features & DVR_CAPABLE) != 0;\r\n}\r\nint platform_supports_ffs(void)\r\n{\r\nreturn (platform_features & FFS_CAPABLE) != 0;\r\n}\r\nint platform_supports_pcie(void)\r\n{\r\nreturn (platform_features & PCIE_CAPABLE) != 0;\r\n}\r\nint platform_supports_display(void)\r\n{\r\nreturn (platform_features & DISPLAY_CAPABLE) != 0;\r\n}
