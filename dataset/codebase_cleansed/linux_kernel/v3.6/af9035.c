static u16 af9035_checksum(const u8 *buf, size_t len)\r\n{\r\nsize_t i;\r\nu16 checksum = 0;\r\nfor (i = 1; i < len; i++) {\r\nif (i % 2)\r\nchecksum += buf[i] << 8;\r\nelse\r\nchecksum += buf[i];\r\n}\r\nchecksum = ~checksum;\r\nreturn checksum;\r\n}\r\nstatic int af9035_ctrl_msg(struct usb_device *udev, struct usb_req *req)\r\n{\r\n#define BUF_LEN 64\r\n#define REQ_HDR_LEN 4\r\n#define ACK_HDR_LEN 3\r\n#define CHECKSUM_LEN 2\r\n#define USB_TIMEOUT 2000\r\nint ret, msg_len, act_len;\r\nu8 buf[BUF_LEN];\r\nstatic u8 seq;\r\nu16 checksum, tmp_checksum;\r\nif (req->wlen > (BUF_LEN - REQ_HDR_LEN - CHECKSUM_LEN) ||\r\nreq->rlen > (BUF_LEN - ACK_HDR_LEN - CHECKSUM_LEN)) {\r\npr_debug("%s: too much data wlen=%d rlen=%d\n", __func__,\r\nreq->wlen, req->rlen);\r\nreturn -EINVAL;\r\n}\r\nif (mutex_lock_interruptible(&af9035_usb_mutex) < 0)\r\nreturn -EAGAIN;\r\nbuf[0] = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN - 1;\r\nbuf[1] = req->mbox;\r\nbuf[2] = req->cmd;\r\nbuf[3] = seq++;\r\nif (req->wlen)\r\nmemcpy(&buf[4], req->wbuf, req->wlen);\r\nchecksum = af9035_checksum(buf, buf[0] - 1);\r\nbuf[buf[0] - 1] = (checksum >> 8);\r\nbuf[buf[0] - 0] = (checksum & 0xff);\r\nmsg_len = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN ;\r\nret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 0x02), buf, msg_len,\r\n&act_len, USB_TIMEOUT);\r\nif (ret < 0)\r\nerr("bulk message failed=%d (%d/%d)", ret, msg_len, act_len);\r\nelse\r\nif (act_len != msg_len)\r\nret = -EIO;\r\nif (ret < 0)\r\ngoto err_mutex_unlock;\r\nif (req->cmd == CMD_FW_DL)\r\ngoto exit_mutex_unlock;\r\nmsg_len = ACK_HDR_LEN + req->rlen + CHECKSUM_LEN;\r\nret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, 0x81), buf, msg_len,\r\n&act_len, USB_TIMEOUT);\r\nif (ret < 0) {\r\nerr("recv bulk message failed=%d", ret);\r\nret = -EIO;\r\ngoto err_mutex_unlock;\r\n}\r\nif (act_len != msg_len) {\r\nerr("recv bulk message truncated (%d != %d)", act_len, msg_len);\r\nret = -EIO;\r\ngoto err_mutex_unlock;\r\n}\r\nchecksum = af9035_checksum(buf, act_len - 2);\r\ntmp_checksum = (buf[act_len - 2] << 8) | buf[act_len - 1];\r\nif (tmp_checksum != checksum) {\r\nerr("%s: command=%02x checksum mismatch (%04x != %04x)",\r\n__func__, req->cmd, tmp_checksum, checksum);\r\nret = -EIO;\r\ngoto err_mutex_unlock;\r\n}\r\nif (buf[2]) {\r\npr_debug("%s: command=%02x failed fw error=%d\n", __func__,\r\nreq->cmd, buf[2]);\r\nret = -EIO;\r\ngoto err_mutex_unlock;\r\n}\r\nif (req->rlen)\r\nmemcpy(req->rbuf, &buf[ACK_HDR_LEN], req->rlen);\r\nerr_mutex_unlock:\r\nexit_mutex_unlock:\r\nmutex_unlock(&af9035_usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9035_wr_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\r\n{\r\nu8 wbuf[6 + len];\r\nu8 mbox = (reg >> 16) & 0xff;\r\nstruct usb_req req = { CMD_MEM_WR, mbox, sizeof(wbuf), wbuf, 0, NULL };\r\nwbuf[0] = len;\r\nwbuf[1] = 2;\r\nwbuf[2] = 0;\r\nwbuf[3] = 0;\r\nwbuf[4] = (reg >> 8) & 0xff;\r\nwbuf[5] = (reg >> 0) & 0xff;\r\nmemcpy(&wbuf[6], val, len);\r\nreturn af9035_ctrl_msg(d->udev, &req);\r\n}\r\nstatic int af9035_rd_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\r\n{\r\nu8 wbuf[] = { len, 2, 0, 0, (reg >> 8) & 0xff, reg & 0xff };\r\nu8 mbox = (reg >> 16) & 0xff;\r\nstruct usb_req req = { CMD_MEM_RD, mbox, sizeof(wbuf), wbuf, len, val };\r\nreturn af9035_ctrl_msg(d->udev, &req);\r\n}\r\nstatic int af9035_wr_reg(struct dvb_usb_device *d, u32 reg, u8 val)\r\n{\r\nreturn af9035_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int af9035_rd_reg(struct dvb_usb_device *d, u32 reg, u8 *val)\r\n{\r\nreturn af9035_rd_regs(d, reg, val, 1);\r\n}\r\nstatic int af9035_wr_reg_mask(struct dvb_usb_device *d, u32 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = af9035_rd_regs(d, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn af9035_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int af9035_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct state *state = d->priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num == 2 && !(msg[0].flags & I2C_M_RD) &&\r\n(msg[1].flags & I2C_M_RD)) {\r\nif (msg[0].len > 40 || msg[1].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else if (msg[0].addr == state->af9033_config[0].i2c_addr) {\r\nu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\r\nmsg[0].buf[2];\r\nret = af9035_rd_regs(d, reg, &msg[1].buf[0],\r\nmsg[1].len);\r\n} else {\r\nu8 buf[5 + msg[0].len];\r\nstruct usb_req req = { CMD_I2C_RD, 0, sizeof(buf),\r\nbuf, msg[1].len, msg[1].buf };\r\nbuf[0] = msg[1].len;\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nmemcpy(&buf[5], msg[0].buf, msg[0].len);\r\nret = af9035_ctrl_msg(d->udev, &req);\r\n}\r\n} else if (num == 1 && !(msg[0].flags & I2C_M_RD)) {\r\nif (msg[0].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else if (msg[0].addr == state->af9033_config[0].i2c_addr) {\r\nu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\r\nmsg[0].buf[2];\r\nret = af9035_wr_regs(d, reg, &msg[0].buf[3],\r\nmsg[0].len - 3);\r\n} else {\r\nu8 buf[5 + msg[0].len];\r\nstruct usb_req req = { CMD_I2C_WR, 0, sizeof(buf), buf,\r\n0, NULL };\r\nbuf[0] = msg[0].len;\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nmemcpy(&buf[5], msg[0].buf, msg[0].len);\r\nret = af9035_ctrl_msg(d->udev, &req);\r\n}\r\n} else {\r\nret = -EOPNOTSUPP;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn num;\r\n}\r\nstatic u32 af9035_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int af9035_rc_query(struct dvb_usb_device *d)\r\n{\r\nunsigned int key;\r\nunsigned char b[4];\r\nint ret;\r\nstruct usb_req req = { CMD_IR_GET, 0, 0, NULL, 4, b };\r\nret = af9035_ctrl_msg(d->udev, &req);\r\nif (ret < 0)\r\ngoto err;\r\nif ((b[2] + b[3]) == 0xff) {\r\nif ((b[0] + b[1]) == 0xff) {\r\nkey = b[0] << 8 | b[2];\r\n} else {\r\nkey = b[0] << 16 | b[1] << 8 | b[2];\r\n}\r\n} else {\r\nkey = b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3];\r\n}\r\nrc_keydown(d->rc_dev, key, 0);\r\nerr:\r\nreturn 0;\r\n}\r\nstatic int af9035_init(struct dvb_usb_device *d)\r\n{\r\nstruct state *state = d->priv;\r\nint ret, i;\r\nu16 frame_size = 87 * 188 / 4;\r\nu8 packet_size = 512 / 4;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x80f99d, 0x01, 0x01 },\r\n{ 0x80f9a4, 0x01, 0x01 },\r\n{ 0x00dd11, 0x00, 0x20 },\r\n{ 0x00dd11, 0x00, 0x40 },\r\n{ 0x00dd13, 0x00, 0x20 },\r\n{ 0x00dd13, 0x00, 0x40 },\r\n{ 0x00dd11, 0x20, 0x20 },\r\n{ 0x00dd88, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd89, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0c, packet_size, 0xff},\r\n{ 0x00dd11, state->dual_mode << 6, 0x40 },\r\n{ 0x00dd8a, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd8b, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0d, packet_size, 0xff },\r\n{ 0x80f9a3, 0x00, 0x01 },\r\n{ 0x80f9cd, 0x00, 0x01 },\r\n{ 0x80f99d, 0x00, 0x01 },\r\n{ 0x80f9a4, 0x00, 0x01 },\r\n};\r\npr_debug("%s: USB speed=%d frame_size=%04x packet_size=%02x\n",\r\n__func__, d->udev->speed, frame_size, packet_size);\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = af9035_wr_reg_mask(d, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\nint ret;\r\nu8 wbuf[1] = { 1 };\r\nu8 rbuf[4];\r\nstruct usb_req req = { CMD_FW_QUERYINFO, 0, sizeof(wbuf), wbuf,\r\nsizeof(rbuf), rbuf };\r\nret = af9035_ctrl_msg(udev, &req);\r\nif (ret < 0)\r\ngoto err;\r\npr_debug("%s: reply=%02x %02x %02x %02x\n", __func__,\r\nrbuf[0], rbuf[1], rbuf[2], rbuf[3]);\r\nif (rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])\r\n*cold = 0;\r\nelse\r\n*cold = 1;\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware(struct usb_device *udev,\r\nconst struct firmware *fw)\r\n{\r\nint ret, i, j, len;\r\nu8 wbuf[1];\r\nu8 rbuf[4];\r\nstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\r\nstruct usb_req req_fw_dl = { CMD_FW_DL, 0, 0, wbuf, 0, NULL };\r\nstruct usb_req req_fw_ver = { CMD_FW_QUERYINFO, 0, 1, wbuf, 4, rbuf } ;\r\nu8 hdr_core;\r\nu16 hdr_addr, hdr_data_len, hdr_checksum;\r\n#define MAX_DATA 58\r\n#define HDR_SIZE 7\r\nfor (i = fw->size; i > HDR_SIZE;) {\r\nhdr_core = fw->data[fw->size - i + 0];\r\nhdr_addr = fw->data[fw->size - i + 1] << 8;\r\nhdr_addr |= fw->data[fw->size - i + 2] << 0;\r\nhdr_data_len = fw->data[fw->size - i + 3] << 8;\r\nhdr_data_len |= fw->data[fw->size - i + 4] << 0;\r\nhdr_checksum = fw->data[fw->size - i + 5] << 8;\r\nhdr_checksum |= fw->data[fw->size - i + 6] << 0;\r\npr_debug("%s: core=%d addr=%04x data_len=%d checksum=%04x\n",\r\n__func__, hdr_core, hdr_addr, hdr_data_len,\r\nhdr_checksum);\r\nif (((hdr_core != 1) && (hdr_core != 2)) ||\r\n(hdr_data_len > i)) {\r\npr_debug("%s: bad firmware\n", __func__);\r\nbreak;\r\n}\r\nreq.cmd = CMD_FW_DL_BEGIN;\r\nret = af9035_ctrl_msg(udev, &req);\r\nif (ret < 0)\r\ngoto err;\r\nfor (j = HDR_SIZE + hdr_data_len; j > 0; j -= MAX_DATA) {\r\nlen = j;\r\nif (len > MAX_DATA)\r\nlen = MAX_DATA;\r\nreq_fw_dl.wlen = len;\r\nreq_fw_dl.wbuf = (u8 *) &fw->data[fw->size - i +\r\nHDR_SIZE + hdr_data_len - j];\r\nret = af9035_ctrl_msg(udev, &req_fw_dl);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreq.cmd = CMD_FW_DL_END;\r\nret = af9035_ctrl_msg(udev, &req);\r\nif (ret < 0)\r\ngoto err;\r\ni -= hdr_data_len + HDR_SIZE;\r\npr_debug("%s: data uploaded=%zu\n", __func__, fw->size - i);\r\n}\r\nreq.cmd = CMD_FW_BOOT;\r\nret = af9035_ctrl_msg(udev, &req);\r\nif (ret < 0)\r\ngoto err;\r\nwbuf[0] = 1;\r\nret = af9035_ctrl_msg(udev, &req_fw_ver);\r\nif (ret < 0)\r\ngoto err;\r\nif (!(rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])) {\r\ninfo("firmware did not run");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ninfo("firmware version=%d.%d.%d.%d", rbuf[0], rbuf[1], rbuf[2],\r\nrbuf[3]);\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware_it9135(struct usb_device *udev,\r\nconst struct firmware *fw)\r\n{\r\nint ret, i, i_prev;\r\nu8 wbuf[1];\r\nu8 rbuf[4];\r\nstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\r\nstruct usb_req req_fw_dl = { CMD_FW_SCATTER_WR, 0, 0, NULL, 0, NULL };\r\nstruct usb_req req_fw_ver = { CMD_FW_QUERYINFO, 0, 1, wbuf, 4, rbuf } ;\r\n#define HDR_SIZE 7\r\nfor (i = HDR_SIZE, i_prev = 0; i <= fw->size; i++) {\r\nif (i == fw->size ||\r\n(fw->data[i + 0] == 0x03 &&\r\n(fw->data[i + 1] == 0x00 ||\r\nfw->data[i + 1] == 0x01) &&\r\nfw->data[i + 2] == 0x00)) {\r\nreq_fw_dl.wlen = i - i_prev;\r\nreq_fw_dl.wbuf = (u8 *) &fw->data[i_prev];\r\ni_prev = i;\r\nret = af9035_ctrl_msg(udev, &req_fw_dl);\r\nif (ret < 0)\r\ngoto err;\r\npr_debug("%s: data uploaded=%d\n", __func__, i);\r\n}\r\n}\r\nreq.cmd = CMD_FW_BOOT;\r\nret = af9035_ctrl_msg(udev, &req);\r\nif (ret < 0)\r\ngoto err;\r\nwbuf[0] = 1;\r\nret = af9035_ctrl_msg(udev, &req_fw_ver);\r\nif (ret < 0)\r\ngoto err;\r\nif (!(rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])) {\r\ninfo("firmware did not run");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ninfo("firmware version=%d.%d.%d.%d", rbuf[0], rbuf[1], rbuf[2],\r\nrbuf[3]);\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_read_mac_address(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nstruct state *state = d->priv;\r\nint ret, i, eeprom_shift = 0;\r\nu8 tmp;\r\nu16 tmp16;\r\nret = af9035_rd_reg(d, EEPROM_DUAL_MODE, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nstate->dual_mode = tmp;\r\npr_debug("%s: dual mode=%d\n", __func__, state->dual_mode);\r\nfor (i = 0; i < af9035_properties[0].num_adapters; i++) {\r\nret = af9035_rd_reg(d, EEPROM_1_TUNER_ID + eeprom_shift, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nstate->af9033_config[i].tuner = tmp;\r\npr_debug("%s: [%d]tuner=%02x\n", __func__, i, tmp);\r\nswitch (tmp) {\r\ncase AF9033_TUNER_TUA9001:\r\ncase AF9033_TUNER_FC0011:\r\ncase AF9033_TUNER_MXL5007T:\r\ncase AF9033_TUNER_TDA18218:\r\nstate->af9033_config[i].spec_inv = 1;\r\nbreak;\r\ndefault:\r\nwarn("tuner ID=%02x not supported, please report!",\r\ntmp);\r\n};\r\nret = af9035_rd_reg(d, EEPROM_1_IFFREQ_L + eeprom_shift, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp16 = tmp;\r\nret = af9035_rd_reg(d, EEPROM_1_IFFREQ_H + eeprom_shift, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp16 |= tmp << 8;\r\npr_debug("%s: [%d]IF=%d\n", __func__, i, tmp16);\r\neeprom_shift = 0x10;\r\n}\r\nret = af9035_rd_reg(d, 0x00d800, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp = (tmp >> 0) & 0x0f;\r\nfor (i = 0; i < af9035_properties[0].num_adapters; i++)\r\nstate->af9033_config[i].clock = clock_lut[tmp];\r\nret = af9035_rd_reg(d, EEPROM_IR_MODE, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\npr_debug("%s: ir_mode=%02x\n", __func__, tmp);\r\nif (tmp == 5) {\r\nret = af9035_rd_reg(d, EEPROM_IR_TYPE, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\npr_debug("%s: ir_type=%02x\n", __func__, tmp);\r\nswitch (tmp) {\r\ncase 0:\r\ndefault:\r\nd->props.rc.core.protocol = RC_TYPE_NEC;\r\nd->props.rc.core.allowed_protos = RC_TYPE_NEC;\r\nbreak;\r\ncase 1:\r\nd->props.rc.core.protocol = RC_TYPE_RC6;\r\nd->props.rc.core.allowed_protos = RC_TYPE_RC6;\r\nbreak;\r\n}\r\nd->props.rc.core.rc_query = af9035_rc_query;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_read_mac_address_it9135(struct dvb_usb_device *d, u8 mac[6])\r\n{\r\nstruct state *state = d->priv;\r\nint ret, i;\r\nu8 tmp;\r\nstate->dual_mode = false;\r\nret = af9035_rd_reg(d, 0x00d800, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp = (tmp >> 0) & 0x0f;\r\nfor (i = 0; i < af9035_properties[0].num_adapters; i++)\r\nstate->af9033_config[i].clock = clock_lut_it9135[tmp];\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_fc0011_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nint ret;\r\nswitch (cmd) {\r\ncase FC0011_FE_CALLBACK_POWER:\r\nret = af9035_wr_reg_mask(d, 0xd8eb, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ec, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ed, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d0, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d1, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nbreak;\r\ncase FC0011_FE_CALLBACK_RESET:\r\nret = af9035_wr_reg(d, 0xd8e9, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0xd8e8, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0xd8e7, 1);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\nret = af9035_wr_reg(d, 0xd8e7, 0);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_tuner_callback(struct dvb_usb_device *d, int cmd, int arg)\r\n{\r\nstruct state *state = d->priv;\r\nswitch (state->af9033_config[0].tuner) {\r\ncase AF9033_TUNER_FC0011:\r\nreturn af9035_fc0011_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int af9035_frontend_callback(void *adapter_priv, int component,\r\nint cmd, int arg)\r\n{\r\nstruct i2c_adapter *adap = adapter_priv;\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nswitch (component) {\r\ncase DVB_FRONTEND_COMPONENT_TUNER:\r\nreturn af9035_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int af9035_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap->dev->priv;\r\nint ret;\r\nif (!state->af9033_config[adap->id].tuner) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (adap->id == 0) {\r\nstate->af9033_config[0].ts_mode = AF9033_TS_MODE_USB;\r\nstate->af9033_config[1].ts_mode = AF9033_TS_MODE_SERIAL;\r\nret = af9035_wr_reg(adap->dev, 0x00417f,\r\nstate->af9033_config[1].i2c_addr);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d81a,\r\nstate->dual_mode);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nadap->fe_adap[0].fe = dvb_attach(af9033_attach,\r\n&state->af9033_config[adap->id], &adap->dev->i2c_adap);\r\nif (adap->fe_adap[0].fe == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe_adap[0].fe->ops.i2c_gate_ctrl = NULL;\r\nadap->fe_adap[0].fe->callback = af9035_frontend_callback;\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap->dev->priv;\r\nint ret;\r\nstruct dvb_frontend *fe;\r\nswitch (state->af9033_config[adap->id].tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\nret = af9035_wr_reg_mask(adap->dev, 0x00d8ec, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(adap->dev, 0x00d8ed, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(adap->dev, 0x00d8e8, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(adap->dev, 0x00d8e9, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(adap->dev, 0x00d8e7, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(2000, 20000);\r\nret = af9035_wr_reg_mask(adap->dev, 0x00d8e7, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(adap->dev, 0x00d8eb, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nfe = dvb_attach(tua9001_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap, &af9035_tua9001_config);\r\nbreak;\r\ncase AF9033_TUNER_FC0011:\r\nfe = dvb_attach(fc0011_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap, &af9035_fc0011_config);\r\nbreak;\r\ncase AF9033_TUNER_MXL5007T:\r\nret = af9035_wr_reg(adap->dev, 0x00d8e0, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d8e1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d8df, 0);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(30);\r\nret = af9035_wr_reg(adap->dev, 0x00d8df, 1);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(300);\r\nret = af9035_wr_reg(adap->dev, 0x00d8c0, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d8c1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d8bf, 0);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d8b4, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d8b5, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(adap->dev, 0x00d8b3, 1);\r\nif (ret < 0)\r\ngoto err;\r\nfe = dvb_attach(mxl5007t_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap, 0x60, &af9035_mxl5007t_config);\r\nbreak;\r\ncase AF9033_TUNER_TDA18218:\r\nfe = dvb_attach(tda18218_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap, &af9035_tda18218_config);\r\nbreak;\r\ndefault:\r\nfe = NULL;\r\n}\r\nif (fe == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret, i;\r\nstruct dvb_usb_device *d = NULL;\r\nstruct usb_device *udev;\r\nbool found;\r\npr_debug("%s: interface=%d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\r\nreturn 0;\r\nudev = interface_to_usbdev(intf);\r\nfor (i = 0, found = false; i < ARRAY_SIZE(af9035_id) - 1; i++) {\r\nif (af9035_id[i].idVendor ==\r\nle16_to_cpu(udev->descriptor.idVendor) &&\r\naf9035_id[i].idProduct ==\r\nle16_to_cpu(udev->descriptor.idProduct)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\npr_debug("%s: using dynamic ID %04x:%04x\n", __func__,\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\naf9035_properties[0].devices[0].cold_ids[0]->idVendor =\r\nle16_to_cpu(udev->descriptor.idVendor);\r\naf9035_properties[0].devices[0].cold_ids[0]->idProduct =\r\nle16_to_cpu(udev->descriptor.idProduct);\r\n}\r\nfor (i = 0; i < af9035_properties_count; i++) {\r\nret = dvb_usb_device_init(intf, &af9035_properties[i],\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret == -ENODEV)\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto err;\r\nif (d) {\r\nret = af9035_init(d);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}
