static int align(int n)\r\n{\r\nif (is64bit)\r\nreturn (n + 0x1fff) & ~0x1fff;\r\nelse\r\nreturn (n + 0xfff) & ~0xfff;\r\n}\r\nstatic unsigned short ld2(char *p)\r\n{\r\nreturn (p[0] << 8) | p[1];\r\n}\r\nstatic void st4(char *p, unsigned int x)\r\n{\r\np[0] = x >> 24;\r\np[1] = x >> 16;\r\np[2] = x >> 8;\r\np[3] = x;\r\n}\r\nstatic void die(const char *str)\r\n{\r\nperror(str);\r\nexit(1);\r\n}\r\nstatic void usage(void)\r\n{\r\nfprintf(stderr, "Usage: piggyback bits vmlinux.aout System.map fs_img.gz\n");\r\nfprintf(stderr, "\tKernel image will be modified in place.\n");\r\nexit(1);\r\n}\r\nstatic int start_line(const char *line)\r\n{\r\nif (strcmp(line + 8, " T _start\n") == 0)\r\nreturn 1;\r\nelse if (strcmp(line + 16, " T _start\n") == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int end_line(const char *line)\r\n{\r\nif (strcmp(line + 8, " A _end\n") == 0)\r\nreturn 1;\r\nelse if (strcmp (line + 16, " A _end\n") == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int get_start_end(const char *filename, unsigned int *start,\r\nunsigned int *end)\r\n{\r\nFILE *map;\r\nchar buffer[1024];\r\n*start = 0;\r\n*end = 0;\r\nmap = fopen(filename, "r");\r\nif (!map)\r\ndie(filename);\r\nwhile (fgets(buffer, 1024, map)) {\r\nif (start_line(buffer))\r\n*start = strtoul(buffer, NULL, 16);\r\nelse if (end_line(buffer))\r\n*end = strtoul(buffer, NULL, 16);\r\n}\r\nfclose (map);\r\nif (*start == 0 || *end == 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic off_t get_hdrs_offset(int kernelfd, const char *filename)\r\n{\r\nchar buffer[BUFSIZE];\r\noff_t offset;\r\nint i;\r\nif (lseek(kernelfd, 0, SEEK_SET) < 0)\r\ndie("lseek");\r\nif (read(kernelfd, buffer, BUFSIZE) != BUFSIZE)\r\ndie(filename);\r\nif (buffer[40] == 'H' && buffer[41] == 'd' &&\r\nbuffer[42] == 'r' && buffer[43] == 'S') {\r\nreturn 40;\r\n} else {\r\noffset = ld2(buffer + AOUT_TEXT_OFFSET + 2) << 2;\r\noffset -= LOOKBACK;\r\noffset += AOUT_TEXT_OFFSET;\r\nif (lseek(kernelfd, offset, SEEK_SET) < 0)\r\ndie("lseek");\r\nif (read(kernelfd, buffer, BUFSIZE) != BUFSIZE)\r\ndie(filename);\r\nfor (i = 0; i < LOOKBACK; i += 4) {\r\nif (buffer[i + 0] == 'H' && buffer[i + 1] == 'd' &&\r\nbuffer[i + 2] == 'r' && buffer[i + 3] == 'S') {\r\nreturn offset + i;\r\n}\r\n}\r\n}\r\nfprintf (stderr, "Couldn't find headers signature in %s\n", filename);\r\nexit(1);\r\n}\r\nint main(int argc,char **argv)\r\n{\r\nstatic char aout_magic[] = { 0x01, 0x03, 0x01, 0x07 };\r\nchar buffer[1024];\r\nunsigned int i, start, end;\r\noff_t offset;\r\nstruct stat s;\r\nint image, tail;\r\nif (argc != 5)\r\nusage();\r\nif (strcmp(argv[1], "64") == 0)\r\nis64bit = 1;\r\nif (stat (argv[4], &s) < 0)\r\ndie(argv[4]);\r\nif (!get_start_end(argv[3], &start, &end)) {\r\nfprintf(stderr, "Could not determine start and end from %s\n",\r\nargv[3]);\r\nexit(1);\r\n}\r\nif ((image = open(argv[2], O_RDWR)) < 0)\r\ndie(argv[2]);\r\nif (read(image, buffer, 512) != 512)\r\ndie(argv[2]);\r\nif (memcmp(buffer, aout_magic, 4) != 0) {\r\nfprintf (stderr, "Not a.out. Don't blame me.\n");\r\nexit(1);\r\n}\r\noffset = get_hdrs_offset(image, argv[2]);\r\noffset += 10;\r\nif (lseek(image, offset, 0) < 0)\r\ndie("lseek");\r\nst4(buffer, 0);\r\nst4(buffer + 4, 0x01000000);\r\nst4(buffer + 8, align(end + 32));\r\nst4(buffer + 12, s.st_size);\r\nif (write(image, buffer + 2, 14) != 14)\r\ndie(argv[2]);\r\nif (is64bit)\r\n{\r\nif (lseek(image, 4, 0) < 0)\r\ndie("lseek");\r\nst4(buffer, align(end + 32 + 8191) - (start & ~0x3fffffUL) +\r\ns.st_size);\r\nst4(buffer + 4, 0);\r\nst4(buffer + 8, 0);\r\nif (write(image, buffer, 12) != 12)\r\ndie(argv[2]);\r\n}\r\nif (lseek(image, AOUT_TEXT_OFFSET - start + align(end + 32), 0) < 0)\r\ndie("lseek");\r\nif ((tail = open(argv[4], O_RDONLY)) < 0)\r\ndie(argv[4]);\r\nwhile ((i = read(tail, buffer, 1024)) > 0)\r\nif (write(image, buffer, i) != i)\r\ndie(argv[2]);\r\nif (close(image) < 0)\r\ndie("close");\r\nif (close(tail) < 0)\r\ndie("close");\r\nreturn 0;\r\n}
