static void vortex_wt_setstereo(vortex_t * vortex, u32 wt, u32 stereo)\r\n{\r\nint temp;\r\ntemp = hwread(vortex->mmio, WT_STEREO(wt));\r\ntemp = (temp & 0xfe) | (stereo & 1);\r\nhwwrite(vortex->mmio, WT_STEREO(wt), temp);\r\n}\r\nstatic void vortex_wt_setdsout(vortex_t * vortex, u32 wt, int en)\r\n{\r\nint temp;\r\ntemp = hwread(vortex->mmio, WT_DSREG((wt >= 0x20) ? 1 : 0));\r\nif (en)\r\ntemp |= (1 << (wt & 0x1f));\r\nelse\r\ntemp &= (1 << ~(wt & 0x1f));\r\nhwwrite(vortex->mmio, WT_DSREG((wt >= 0x20) ? 1 : 0), temp);\r\n}\r\nstatic int vortex_wt_allocroute(vortex_t * vortex, int wt, int nr_ch)\r\n{\r\nwt_voice_t *voice = &(vortex->wt_voice[wt]);\r\nint temp;\r\nif (nr_ch) {\r\nvortex_fifo_wtinitialize(vortex, wt, 1);\r\nvortex_fifo_setwtvalid(vortex, wt, 1);\r\nvortex_wt_setstereo(vortex, wt, nr_ch - 1);\r\n} else\r\nvortex_fifo_setwtvalid(vortex, wt, 0);\r\nvortex_wt_setdsout(vortex, wt, 1);\r\nhwwrite(vortex->mmio, WT_SRAMP(0), 0x880000);\r\n#ifdef CHIP_AU8830\r\nhwwrite(vortex->mmio, WT_SRAMP(1), 0x880000);\r\n#endif\r\nhwwrite(vortex->mmio, WT_PARM(wt, 0), 0);\r\nhwwrite(vortex->mmio, WT_PARM(wt, 1), 0);\r\nhwwrite(vortex->mmio, WT_PARM(wt, 2), 0);\r\ntemp = hwread(vortex->mmio, WT_PARM(wt, 3));\r\nprintk(KERN_DEBUG "vortex: WT PARM3: %x\n", temp);\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 0), 0);\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 1), 0);\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 2), 0);\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 3), 0);\r\nprintk(KERN_DEBUG "vortex: WT GMODE: %x\n", hwread(vortex->mmio, WT_GMODE(wt)));\r\nhwwrite(vortex->mmio, WT_PARM(wt, 2), 0xffffffff);\r\nhwwrite(vortex->mmio, WT_PARM(wt, 3), 0xcff1c810);\r\nvoice->parm0 = voice->parm1 = 0xcfb23e2f;\r\nhwwrite(vortex->mmio, WT_PARM(wt, 0), voice->parm0);\r\nhwwrite(vortex->mmio, WT_PARM(wt, 1), voice->parm1);\r\nprintk(KERN_DEBUG "vortex: WT GMODE 2 : %x\n", hwread(vortex->mmio, WT_GMODE(wt)));\r\nreturn 0;\r\n}\r\nstatic void vortex_wt_connect(vortex_t * vortex, int en)\r\n{\r\nint i, ii, mix;\r\n#define NR_WTROUTES 6\r\n#ifdef CHIP_AU8830\r\n#define NR_WTBLOCKS 2\r\n#else\r\n#define NR_WTBLOCKS 1\r\n#endif\r\nfor (i = 0; i < NR_WTBLOCKS; i++) {\r\nfor (ii = 0; ii < NR_WTROUTES; ii++) {\r\nmix =\r\nvortex_adb_checkinout(vortex,\r\nvortex->fixed_res, en,\r\nVORTEX_RESOURCE_MIXIN);\r\nvortex->mixwt[(i * NR_WTROUTES) + ii] = mix;\r\nvortex_route(vortex, en, 0x11,\r\nADB_WTOUT(i, ii + 0x20), ADB_MIXIN(mix));\r\nvortex_connection_mixin_mix(vortex, en, mix,\r\nvortex->mixplayb[ii % 2], 0);\r\nif (VORTEX_IS_QUAD(vortex))\r\nvortex_connection_mixin_mix(vortex, en,\r\nmix,\r\nvortex->mixplayb[2 +\r\n(ii % 2)], 0);\r\n}\r\n}\r\nfor (i = 0; i < NR_WT; i++) {\r\nhwwrite(vortex->mmio, WT_RUN(i), 1);\r\n}\r\n}\r\nstatic int\r\nvortex_wt_SetReg(vortex_t * vortex, unsigned char reg, int wt,\r\nu32 val)\r\n{\r\nint ecx;\r\nif ((reg == 5) || ((reg >= 7) && (reg <= 10)) || (reg == 0xc)) {\r\nif (wt >= (NR_WT / NR_WT_PB)) {\r\nprintk\r\n("vortex: WT SetReg: bank out of range. reg=0x%x, wt=%d\n",\r\nreg, wt);\r\nreturn 0;\r\n}\r\n} else {\r\nif (wt >= NR_WT) {\r\nprintk(KERN_ERR "vortex: WT SetReg: voice out of range\n");\r\nreturn 0;\r\n}\r\n}\r\nif (reg > 0xc)\r\nreturn 0;\r\nswitch (reg) {\r\ncase 0:\r\nhwwrite(vortex->mmio, WT_RUN(wt), val);\r\nreturn 0xc;\r\nbreak;\r\ncase 1:\r\nhwwrite(vortex->mmio, WT_PARM(wt, 0), val);\r\nreturn 0xc;\r\nbreak;\r\ncase 2:\r\nhwwrite(vortex->mmio, WT_PARM(wt, 1), val);\r\nreturn 0xc;\r\nbreak;\r\ncase 3:\r\nhwwrite(vortex->mmio, WT_PARM(wt, 2), val);\r\nreturn 0xc;\r\nbreak;\r\ncase 4:\r\nhwwrite(vortex->mmio, WT_PARM(wt, 3), val);\r\nreturn 0xc;\r\nbreak;\r\ncase 6:\r\nhwwrite(vortex->mmio, WT_MUTE(wt), val);\r\nreturn 0xc;\r\nbreak;\r\ncase 0xb:\r\n{\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 3), val);\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 2), val);\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 1), val);\r\nhwwrite(vortex->mmio, WT_DELAY(wt, 0), val);\r\nreturn 0xc;\r\n}\r\nbreak;\r\ncase 5:\r\necx = WT_SRAMP(wt);\r\nbreak;\r\ncase 8:\r\necx = WT_ARAMP(wt);\r\nbreak;\r\ncase 9:\r\necx = WT_MRAMP(wt);\r\nbreak;\r\ncase 0xa:\r\necx = WT_CTRL(wt);\r\nbreak;\r\ncase 0xc:\r\necx = WT_DSREG(wt);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\nbreak;\r\n}\r\nhwwrite(vortex->mmio, ecx, val);\r\nreturn 1;\r\n}\r\nstatic void vortex_wt_init(vortex_t * vortex)\r\n{\r\nu32 var4, var8, varc, var10 = 0, edi;\r\nvar10 &= 0xFFFFFFE3;\r\nvar10 |= 0x22;\r\nvar10 &= 0xFFFFFEBF;\r\nvar10 |= 0x80;\r\nvar10 |= 0x200;\r\nvar10 &= 0xfffffffe;\r\nvar10 &= 0xfffffbff;\r\nvar10 |= 0x1800;\r\nvar4 = 0x10000000;\r\nvarc = 0x00830000;\r\nvar8 = 0x00830000;\r\nfor (edi = 0; edi < (NR_WT / NR_WT_PB); edi++) {\r\nvortex_wt_SetReg(vortex, 0xc, edi, 0);\r\nvortex_wt_SetReg(vortex, 0xa, edi, var10);\r\nvortex_wt_SetReg(vortex, 0x9, edi, var4);\r\nvortex_wt_SetReg(vortex, 0x8, edi, varc);\r\nvortex_wt_SetReg(vortex, 0x5, edi, var8);\r\n}\r\nfor (edi = 0; edi < NR_WT; edi++) {\r\nvortex_wt_SetReg(vortex, 0x4, edi, 0);\r\nvortex_wt_SetReg(vortex, 0x3, edi, 0);\r\nvortex_wt_SetReg(vortex, 0x2, edi, 0);\r\nvortex_wt_SetReg(vortex, 0x1, edi, 0);\r\nvortex_wt_SetReg(vortex, 0xb, edi, 0);\r\n}\r\nvar10 |= 1;\r\nfor (edi = 0; edi < (NR_WT / NR_WT_PB); edi++)\r\nvortex_wt_SetReg(vortex, 0xa, edi, var10);\r\n}
