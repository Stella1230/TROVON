inline int metrousb_is_unidirectional_mode(struct usb_serial_port *port)\r\n{\r\n__u16 product_id = le16_to_cpu(\r\nport->serial->dev->descriptor.idProduct);\r\nreturn product_id == FOCUS_PRODUCT_ID_UNI;\r\n}\r\nstatic int metrousb_send_unidirectional_cmd(u8 cmd, struct usb_serial_port *port)\r\n{\r\nint ret;\r\nint actual_len;\r\nu8 *buffer_cmd = NULL;\r\nif (!metrousb_is_unidirectional_mode(port))\r\nreturn 0;\r\nbuffer_cmd = kzalloc(sizeof(cmd), GFP_KERNEL);\r\nif (!buffer_cmd)\r\nreturn -ENOMEM;\r\n*buffer_cmd = cmd;\r\nret = usb_interrupt_msg(port->serial->dev,\r\nusb_sndintpipe(port->serial->dev, port->interrupt_out_endpointAddress),\r\nbuffer_cmd, sizeof(cmd),\r\n&actual_len, USB_CTRL_SET_TIMEOUT);\r\nkfree(buffer_cmd);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (actual_len != sizeof(cmd))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void metrousb_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint throttled = 0;\r\nint result = 0;\r\nunsigned long flags = 0;\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev,\r\n"%s - urb shutting down, error code=%d\n",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev,\r\n"%s - non-zero urb received, error code=%d\n",\r\n__func__, urb->status);\r\ngoto exit;\r\n}\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty) {\r\ndev_err(&port->dev, "%s - bad tty pointer - exiting\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (tty && urb->actual_length) {\r\ntty_insert_flip_string(tty, data, urb->actual_length);\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\nspin_lock_irqsave(&metro_priv->lock, flags);\r\nthrottled = metro_priv->throttled;\r\nspin_unlock_irqrestore(&metro_priv->lock, flags);\r\nif (!throttled) {\r\nusb_fill_int_urb(port->interrupt_in_urb, port->serial->dev,\r\nusb_rcvintpipe(port->serial->dev, port->interrupt_in_endpointAddress),\r\nport->interrupt_in_urb->transfer_buffer,\r\nport->interrupt_in_urb->transfer_buffer_length,\r\nmetrousb_read_int_callback, port, 1);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed submitting interrupt in urb, error code=%d\n",\r\n__func__, result);\r\n}\r\nreturn;\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed submitting interrupt in urb, error code=%d\n",\r\n__func__, result);\r\n}\r\nstatic void metrousb_write_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\ndev_warn(&port->dev, "%s not implemented yet.\n",\r\n__func__);\r\n}\r\nstatic void metrousb_cleanup(struct usb_serial_port *port)\r\n{\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nif (port->serial->dev) {\r\nif (port->interrupt_in_urb) {\r\nusb_unlink_urb(port->interrupt_in_urb);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nmetrousb_send_unidirectional_cmd(UNI_CMD_CLOSE, port);\r\n}\r\n}\r\nstatic int metrousb_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\r\nunsigned long flags = 0;\r\nint result = 0;\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nif (!port->interrupt_in_urb) {\r\ndev_err(&port->dev, "%s - interrupt urb not initialized\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&metro_priv->lock, flags);\r\nmetro_priv->control_state = 0;\r\nmetro_priv->throttled = 0;\r\nspin_unlock_irqrestore(&metro_priv->lock, flags);\r\nusb_clear_halt(serial->dev, port->interrupt_in_urb->pipe);\r\nusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\r\nusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\r\nport->interrupt_in_urb->transfer_buffer,\r\nport->interrupt_in_urb->transfer_buffer_length,\r\nmetrousb_read_int_callback, port, 1);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - failed submitting interrupt in urb, error code=%d\n",\r\n__func__, result);\r\ngoto exit;\r\n}\r\nresult = metrousb_send_unidirectional_cmd(UNI_CMD_OPEN, port);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - failed to configure device for port number=%d, error code=%d\n",\r\n__func__, port->number, result);\r\ngoto exit;\r\n}\r\ndev_dbg(&port->dev, "%s - port open\n", __func__);\r\nexit:\r\nreturn result;\r\n}\r\nstatic int metrousb_set_modem_ctrl(struct usb_serial *serial, unsigned int control_state)\r\n{\r\nint retval = 0;\r\nunsigned char mcr = METROUSB_MCR_NONE;\r\ndev_dbg(&serial->dev->dev, "%s - control state = %d\n",\r\n__func__, control_state);\r\nif (control_state & TIOCM_DTR)\r\nmcr |= METROUSB_MCR_DTR;\r\nif (control_state & TIOCM_RTS)\r\nmcr |= METROUSB_MCR_RTS;\r\nretval = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nMETROUSB_SET_REQUEST_TYPE, METROUSB_SET_MODEM_CTRL_REQUEST,\r\ncontrol_state, 0, NULL, 0, WDR_TIMEOUT);\r\nif (retval < 0)\r\ndev_err(&serial->dev->dev,\r\n"%s - set modem ctrl=0x%x failed, error code=%d\n",\r\n__func__, mcr, retval);\r\nreturn retval;\r\n}\r\nstatic void metrousb_shutdown(struct usb_serial *serial)\r\n{\r\nint i = 0;\r\ndev_dbg(&serial->dev->dev, "%s\n", __func__);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nmetrousb_cleanup(serial->port[i]);\r\nkfree(usb_get_serial_port_data(serial->port[i]));\r\nusb_set_serial_port_data(serial->port[i], NULL);\r\ndev_dbg(&serial->dev->dev, "%s - freed port number=%d\n",\r\n__func__, serial->port[i]->number);\r\n}\r\n}\r\nstatic int metrousb_startup(struct usb_serial *serial)\r\n{\r\nstruct metrousb_private *metro_priv;\r\nstruct usb_serial_port *port;\r\nint i = 0;\r\ndev_dbg(&serial->dev->dev, "%s\n", __func__);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\nmetro_priv = kzalloc(sizeof(struct metrousb_private), GFP_KERNEL);\r\nif (!metro_priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&metro_priv->lock);\r\nusb_set_serial_port_data(port, metro_priv);\r\ndev_dbg(&serial->dev->dev, "%s - port number=%d\n ",\r\n__func__, port->number);\r\n}\r\nreturn 0;\r\n}\r\nstatic void metrousb_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\r\nunsigned long flags = 0;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&metro_priv->lock, flags);\r\nmetro_priv->throttled = 1;\r\nspin_unlock_irqrestore(&metro_priv->lock, flags);\r\n}\r\nstatic int metrousb_tiocmget(struct tty_struct *tty)\r\n{\r\nunsigned long control_state = 0;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\r\nunsigned long flags = 0;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&metro_priv->lock, flags);\r\ncontrol_state = metro_priv->control_state;\r\nspin_unlock_irqrestore(&metro_priv->lock, flags);\r\nreturn control_state;\r\n}\r\nstatic int metrousb_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\r\nunsigned long flags = 0;\r\nunsigned long control_state = 0;\r\ndev_dbg(tty->dev, "%s - set=%d, clear=%d\n", __func__, set, clear);\r\nspin_lock_irqsave(&metro_priv->lock, flags);\r\ncontrol_state = metro_priv->control_state;\r\nif (set & TIOCM_RTS)\r\ncontrol_state |= TIOCM_RTS;\r\nif (set & TIOCM_DTR)\r\ncontrol_state |= TIOCM_DTR;\r\nif (clear & TIOCM_RTS)\r\ncontrol_state &= ~TIOCM_RTS;\r\nif (clear & TIOCM_DTR)\r\ncontrol_state &= ~TIOCM_DTR;\r\nmetro_priv->control_state = control_state;\r\nspin_unlock_irqrestore(&metro_priv->lock, flags);\r\nreturn metrousb_set_modem_ctrl(serial, control_state);\r\n}\r\nstatic void metrousb_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\r\nunsigned long flags = 0;\r\nint result = 0;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&metro_priv->lock, flags);\r\nmetro_priv->throttled = 0;\r\nspin_unlock_irqrestore(&metro_priv->lock, flags);\r\nport->interrupt_in_urb->dev = port->serial->dev;\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(tty->dev,\r\n"failed submitting interrupt in urb error code=%d\n",\r\nresult);\r\n}
