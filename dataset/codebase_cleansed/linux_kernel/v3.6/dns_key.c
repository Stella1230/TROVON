static int\r\ndns_resolver_instantiate(struct key *key, const void *_data, size_t datalen)\r\n{\r\nstruct user_key_payload *upayload;\r\nunsigned long derrno;\r\nint ret;\r\nsize_t result_len = 0;\r\nconst char *data = _data, *end, *opt;\r\nkenter("%%%d,%s,'%*.*s',%zu",\r\nkey->serial, key->description,\r\n(int)datalen, (int)datalen, data, datalen);\r\nif (datalen <= 1 || !data || data[datalen - 1] != '\0')\r\nreturn -EINVAL;\r\ndatalen--;\r\nend = data + datalen;\r\nopt = memchr(data, '#', datalen);\r\nif (!opt) {\r\nkdebug("no options");\r\nresult_len = datalen;\r\n} else {\r\nconst char *next_opt;\r\nresult_len = opt - data;\r\nopt++;\r\nkdebug("options: '%s'", opt);\r\ndo {\r\nconst char *eq;\r\nint opt_len, opt_nlen, opt_vlen, tmp;\r\nnext_opt = memchr(opt, '#', end - opt) ?: end;\r\nopt_len = next_opt - opt;\r\nif (!opt_len) {\r\nprintk(KERN_WARNING\r\n"Empty option to dns_resolver key %d\n",\r\nkey->serial);\r\nreturn -EINVAL;\r\n}\r\neq = memchr(opt, '=', opt_len) ?: end;\r\nopt_nlen = eq - opt;\r\neq++;\r\nopt_vlen = next_opt - eq;\r\ntmp = opt_vlen >= 0 ? opt_vlen : 0;\r\nkdebug("option '%*.*s' val '%*.*s'",\r\nopt_nlen, opt_nlen, opt, tmp, tmp, eq);\r\nif (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&\r\nmemcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {\r\nkdebug("dns error number option");\r\nif (opt_vlen <= 0)\r\ngoto bad_option_value;\r\nret = strict_strtoul(eq, 10, &derrno);\r\nif (ret < 0)\r\ngoto bad_option_value;\r\nif (derrno < 1 || derrno > 511)\r\ngoto bad_option_value;\r\nkdebug("dns error no. = %lu", derrno);\r\nkey->type_data.x[0] = -derrno;\r\ncontinue;\r\n}\r\nbad_option_value:\r\nprintk(KERN_WARNING\r\n"Option '%*.*s' to dns_resolver key %d:"\r\n" bad/missing value\n",\r\nopt_nlen, opt_nlen, opt, key->serial);\r\nreturn -EINVAL;\r\n} while (opt = next_opt + 1, opt < end);\r\n}\r\nif (key->type_data.x[0]) {\r\nkleave(" = 0 [h_error %ld]", key->type_data.x[0]);\r\nreturn 0;\r\n}\r\nkdebug("store result");\r\nret = key_payload_reserve(key, result_len);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nupayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);\r\nif (!upayload) {\r\nkleave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nupayload->datalen = result_len;\r\nmemcpy(upayload->data, data, result_len);\r\nupayload->data[result_len] = '\0';\r\nrcu_assign_pointer(key->payload.data, upayload);\r\nkleave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int\r\ndns_resolver_match(const struct key *key, const void *description)\r\n{\r\nint slen, dlen, ret = 0;\r\nconst char *src = key->description, *dsp = description;\r\nkenter("%s,%s", src, dsp);\r\nif (!src || !dsp)\r\ngoto no_match;\r\nif (strcasecmp(src, dsp) == 0)\r\ngoto matched;\r\nslen = strlen(src);\r\ndlen = strlen(dsp);\r\nif (slen <= 0 || dlen <= 0)\r\ngoto no_match;\r\nif (src[slen - 1] == '.')\r\nslen--;\r\nif (dsp[dlen - 1] == '.')\r\ndlen--;\r\nif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\r\ngoto no_match;\r\nmatched:\r\nret = 1;\r\nno_match:\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\r\n{\r\nint err = key->type_data.x[0];\r\nseq_puts(m, key->description);\r\nif (key_is_instantiated(key)) {\r\nif (err)\r\nseq_printf(m, ": %d", err);\r\nelse\r\nseq_printf(m, ": %u", key->datalen);\r\n}\r\n}\r\nstatic long dns_resolver_read(const struct key *key,\r\nchar __user *buffer, size_t buflen)\r\n{\r\nif (key->type_data.x[0])\r\nreturn key->type_data.x[0];\r\nreturn user_read(key, buffer, buflen);\r\n}\r\nstatic int __init init_dns_resolver(void)\r\n{\r\nstruct cred *cred;\r\nstruct key *keyring;\r\nint ret;\r\ncred = prepare_kernel_cred(NULL);\r\nif (!cred)\r\nreturn -ENOMEM;\r\nkeyring = key_alloc(&key_type_keyring, ".dns_resolver", 0, 0, cred,\r\n(KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ,\r\nKEY_ALLOC_NOT_IN_QUOTA);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto failed_put_cred;\r\n}\r\nret = key_instantiate_and_link(keyring, NULL, 0, NULL, NULL);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nret = register_key_type(&key_type_dns_resolver);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\r\ncred->thread_keyring = keyring;\r\ncred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\r\ndns_resolver_cache = cred;\r\nkdebug("DNS resolver keyring: %d\n", key_serial(keyring));\r\nreturn 0;\r\nfailed_put_key:\r\nkey_put(keyring);\r\nfailed_put_cred:\r\nput_cred(cred);\r\nreturn ret;\r\n}\r\nstatic void __exit exit_dns_resolver(void)\r\n{\r\nkey_revoke(dns_resolver_cache->thread_keyring);\r\nunregister_key_type(&key_type_dns_resolver);\r\nput_cred(dns_resolver_cache);\r\n}
