static int exception_in_progress(struct fsg_dev *fsg)\r\n{\r\nreturn (fsg->state > FSG_STATE_IDLE);\r\n}\r\nstatic void set_bulk_out_req_length(struct fsg_dev *fsg,\r\nstruct fsg_buffhd *bh, unsigned int length)\r\n{\r\nunsigned int rem;\r\nbh->bulk_out_intended_length = length;\r\nrem = length % fsg->bulk_out_maxpacket;\r\nif (rem > 0)\r\nlength += fsg->bulk_out_maxpacket - rem;\r\nbh->outreq->length = length;\r\n}\r\nstatic int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)\r\n{\r\nconst char *name;\r\nif (ep == fsg->bulk_in)\r\nname = "bulk-in";\r\nelse if (ep == fsg->bulk_out)\r\nname = "bulk-out";\r\nelse\r\nname = ep->name;\r\nDBG(fsg, "%s set halt\n", name);\r\nreturn usb_ep_set_halt(ep);\r\n}\r\nstatic int populate_bos(struct fsg_dev *fsg, u8 *buf)\r\n{\r\nmemcpy(buf, &fsg_bos_desc, USB_DT_BOS_SIZE);\r\nbuf += USB_DT_BOS_SIZE;\r\nmemcpy(buf, &fsg_ext_cap_desc, USB_DT_USB_EXT_CAP_SIZE);\r\nbuf += USB_DT_USB_EXT_CAP_SIZE;\r\nmemcpy(buf, &fsg_ss_cap_desc, USB_DT_USB_SS_CAP_SIZE);\r\nreturn USB_DT_BOS_SIZE + USB_DT_USB_SS_CAP_SIZE\r\n+ USB_DT_USB_EXT_CAP_SIZE;\r\n}\r\nstatic int populate_config_buf(struct usb_gadget *gadget,\r\nu8 *buf, u8 type, unsigned index)\r\n{\r\nenum usb_device_speed speed = gadget->speed;\r\nint len;\r\nconst struct usb_descriptor_header **function;\r\nif (index > 0)\r\nreturn -EINVAL;\r\nif (gadget_is_dualspeed(gadget) && type == USB_DT_OTHER_SPEED_CONFIG)\r\nspeed = (USB_SPEED_FULL + USB_SPEED_HIGH) - speed;\r\nfunction = gadget_is_dualspeed(gadget) && speed == USB_SPEED_HIGH\r\n? (const struct usb_descriptor_header **)fsg_hs_function\r\n: (const struct usb_descriptor_header **)fsg_fs_function;\r\nif (!gadget_is_otg(gadget))\r\nfunction++;\r\nlen = usb_gadget_config_buf(&config_desc, buf, EP0_BUFSIZE, function);\r\n((struct usb_config_descriptor *) buf)->bDescriptorType = type;\r\nreturn len;\r\n}\r\nstatic void wakeup_thread(struct fsg_dev *fsg)\r\n{\r\nfsg->thread_wakeup_needed = 1;\r\nif (fsg->thread_task)\r\nwake_up_process(fsg->thread_task);\r\n}\r\nstatic void raise_exception(struct fsg_dev *fsg, enum fsg_state new_state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&fsg->lock, flags);\r\nif (fsg->state <= new_state) {\r\nfsg->exception_req_tag = fsg->ep0_req_tag;\r\nfsg->state = new_state;\r\nif (fsg->thread_task)\r\nsend_sig_info(SIGUSR1, SEND_SIG_FORCED,\r\nfsg->thread_task);\r\n}\r\nspin_unlock_irqrestore(&fsg->lock, flags);\r\n}\r\nstatic void fsg_disconnect(struct usb_gadget *gadget)\r\n{\r\nstruct fsg_dev *fsg = get_gadget_data(gadget);\r\nDBG(fsg, "disconnect or port reset\n");\r\nraise_exception(fsg, FSG_STATE_DISCONNECT);\r\n}\r\nstatic int ep0_queue(struct fsg_dev *fsg)\r\n{\r\nint rc;\r\nrc = usb_ep_queue(fsg->ep0, fsg->ep0req, GFP_ATOMIC);\r\nif (rc != 0 && rc != -ESHUTDOWN) {\r\nWARNING(fsg, "error in submission: %s --> %d\n",\r\nfsg->ep0->name, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void ep0_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct fsg_dev *fsg = ep->driver_data;\r\nif (req->actual > 0)\r\ndump_msg(fsg, fsg->ep0req_name, req->buf, req->actual);\r\nif (req->status || req->actual != req->length)\r\nDBG(fsg, "%s --> %d, %u/%u\n", __func__,\r\nreq->status, req->actual, req->length);\r\nif (req->status == -ECONNRESET)\r\nusb_ep_fifo_flush(ep);\r\nif (req->status == 0 && req->context)\r\n((fsg_routine_t) (req->context))(fsg);\r\n}\r\nstatic void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct fsg_dev *fsg = ep->driver_data;\r\nstruct fsg_buffhd *bh = req->context;\r\nif (req->status || req->actual != req->length)\r\nDBG(fsg, "%s --> %d, %u/%u\n", __func__,\r\nreq->status, req->actual, req->length);\r\nif (req->status == -ECONNRESET)\r\nusb_ep_fifo_flush(ep);\r\nsmp_wmb();\r\nspin_lock(&fsg->lock);\r\nbh->inreq_busy = 0;\r\nbh->state = BUF_STATE_EMPTY;\r\nwakeup_thread(fsg);\r\nspin_unlock(&fsg->lock);\r\n}\r\nstatic void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct fsg_dev *fsg = ep->driver_data;\r\nstruct fsg_buffhd *bh = req->context;\r\ndump_msg(fsg, "bulk-out", req->buf, req->actual);\r\nif (req->status || req->actual != bh->bulk_out_intended_length)\r\nDBG(fsg, "%s --> %d, %u/%u\n", __func__,\r\nreq->status, req->actual,\r\nbh->bulk_out_intended_length);\r\nif (req->status == -ECONNRESET)\r\nusb_ep_fifo_flush(ep);\r\nsmp_wmb();\r\nspin_lock(&fsg->lock);\r\nbh->outreq_busy = 0;\r\nbh->state = BUF_STATE_FULL;\r\nwakeup_thread(fsg);\r\nspin_unlock(&fsg->lock);\r\n}\r\nstatic void intr_in_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct fsg_dev *fsg = ep->driver_data;\r\nstruct fsg_buffhd *bh = req->context;\r\nif (req->status || req->actual != req->length)\r\nDBG(fsg, "%s --> %d, %u/%u\n", __func__,\r\nreq->status, req->actual, req->length);\r\nif (req->status == -ECONNRESET)\r\nusb_ep_fifo_flush(ep);\r\nsmp_wmb();\r\nspin_lock(&fsg->lock);\r\nfsg->intreq_busy = 0;\r\nbh->state = BUF_STATE_EMPTY;\r\nwakeup_thread(fsg);\r\nspin_unlock(&fsg->lock);\r\n}\r\nstatic void intr_in_complete(struct usb_ep *ep, struct usb_request *req)\r\n{}\r\nstatic void received_cbi_adsc(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct usb_request *req = fsg->ep0req;\r\nstatic u8 cbi_reset_cmnd[6] = {\r\nSEND_DIAGNOSTIC, 4, 0xff, 0xff, 0xff, 0xff};\r\nif (req->status || req->length != req->actual ||\r\nreq->actual < 6 || req->actual > MAX_COMMAND_SIZE) {\r\nfsg_set_halt(fsg, fsg->ep0);\r\nreturn;\r\n}\r\nif (req->actual >= sizeof cbi_reset_cmnd &&\r\nmemcmp(req->buf, cbi_reset_cmnd,\r\nsizeof cbi_reset_cmnd) == 0) {\r\nDBG(fsg, "cbi reset request\n");\r\nraise_exception(fsg, FSG_STATE_RESET);\r\nreturn;\r\n}\r\nVDBG(fsg, "CB[I] accept device-specific command\n");\r\nspin_lock(&fsg->lock);\r\nif (fsg->cbbuf_cmnd_size)\r\nWARNING(fsg, "CB[I] overwriting previous command\n");\r\nfsg->cbbuf_cmnd_size = req->actual;\r\nmemcpy(fsg->cbbuf_cmnd, req->buf, fsg->cbbuf_cmnd_size);\r\nwakeup_thread(fsg);\r\nspin_unlock(&fsg->lock);\r\n}\r\nstatic void received_cbi_adsc(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{}\r\nstatic int class_setup_req(struct fsg_dev *fsg,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_request *req = fsg->ep0req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nif (!fsg->config)\r\nreturn value;\r\nif (transport_is_bbb()) {\r\nswitch (ctrl->bRequest) {\r\ncase US_BULK_RESET_REQUEST:\r\nif (ctrl->bRequestType != (USB_DIR_OUT |\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE))\r\nbreak;\r\nif (w_index != 0 || w_value != 0 || w_length != 0) {\r\nvalue = -EDOM;\r\nbreak;\r\n}\r\nDBG(fsg, "bulk reset request\n");\r\nraise_exception(fsg, FSG_STATE_RESET);\r\nvalue = DELAYED_STATUS;\r\nbreak;\r\ncase US_BULK_GET_MAX_LUN:\r\nif (ctrl->bRequestType != (USB_DIR_IN |\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE))\r\nbreak;\r\nif (w_index != 0 || w_value != 0 || w_length != 1) {\r\nvalue = -EDOM;\r\nbreak;\r\n}\r\nVDBG(fsg, "get max LUN\n");\r\n*(u8 *) req->buf = fsg->nluns - 1;\r\nvalue = 1;\r\nbreak;\r\n}\r\n}\r\nelse {\r\nswitch (ctrl->bRequest) {\r\ncase USB_CBI_ADSC_REQUEST:\r\nif (ctrl->bRequestType != (USB_DIR_OUT |\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE))\r\nbreak;\r\nif (w_index != 0 || w_value != 0) {\r\nvalue = -EDOM;\r\nbreak;\r\n}\r\nif (w_length > MAX_COMMAND_SIZE) {\r\nvalue = -EOVERFLOW;\r\nbreak;\r\n}\r\nvalue = w_length;\r\nfsg->ep0req->context = received_cbi_adsc;\r\nbreak;\r\n}\r\n}\r\nif (value == -EOPNOTSUPP)\r\nVDBG(fsg,\r\n"unknown class-specific control req "\r\n"%02x.%02x v%04x i%04x l%u\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nle16_to_cpu(ctrl->wValue), w_index, w_length);\r\nreturn value;\r\n}\r\nstatic int standard_setup_req(struct fsg_dev *fsg,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_request *req = fsg->ep0req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_DESCRIPTOR:\r\nif (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD |\r\nUSB_RECIP_DEVICE))\r\nbreak;\r\nswitch (w_value >> 8) {\r\ncase USB_DT_DEVICE:\r\nVDBG(fsg, "get device descriptor\n");\r\ndevice_desc.bMaxPacketSize0 = fsg->ep0->maxpacket;\r\nvalue = sizeof device_desc;\r\nmemcpy(req->buf, &device_desc, value);\r\nbreak;\r\ncase USB_DT_DEVICE_QUALIFIER:\r\nVDBG(fsg, "get device qualifier\n");\r\nif (!gadget_is_dualspeed(fsg->gadget) ||\r\nfsg->gadget->speed == USB_SPEED_SUPER)\r\nbreak;\r\ndev_qualifier.bMaxPacketSize0 = fsg->ep0->maxpacket;\r\nvalue = sizeof dev_qualifier;\r\nmemcpy(req->buf, &dev_qualifier, value);\r\nbreak;\r\ncase USB_DT_OTHER_SPEED_CONFIG:\r\nVDBG(fsg, "get other-speed config descriptor\n");\r\nif (!gadget_is_dualspeed(fsg->gadget) ||\r\nfsg->gadget->speed == USB_SPEED_SUPER)\r\nbreak;\r\ngoto get_config;\r\ncase USB_DT_CONFIG:\r\nVDBG(fsg, "get configuration descriptor\n");\r\nget_config:\r\nvalue = populate_config_buf(fsg->gadget,\r\nreq->buf,\r\nw_value >> 8,\r\nw_value & 0xff);\r\nbreak;\r\ncase USB_DT_STRING:\r\nVDBG(fsg, "get string descriptor\n");\r\nvalue = usb_gadget_get_string(&fsg_stringtab,\r\nw_value & 0xff, req->buf);\r\nbreak;\r\ncase USB_DT_BOS:\r\nVDBG(fsg, "get bos descriptor\n");\r\nif (gadget_is_superspeed(fsg->gadget))\r\nvalue = populate_bos(fsg, req->buf);\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nif (ctrl->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD |\r\nUSB_RECIP_DEVICE))\r\nbreak;\r\nVDBG(fsg, "set configuration\n");\r\nif (w_value == CONFIG_VALUE || w_value == 0) {\r\nfsg->new_config = w_value;\r\nraise_exception(fsg, FSG_STATE_CONFIG_CHANGE);\r\nvalue = DELAYED_STATUS;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_CONFIGURATION:\r\nif (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD |\r\nUSB_RECIP_DEVICE))\r\nbreak;\r\nVDBG(fsg, "get configuration\n");\r\n*(u8 *) req->buf = fsg->config;\r\nvalue = 1;\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\nif (ctrl->bRequestType != (USB_DIR_OUT| USB_TYPE_STANDARD |\r\nUSB_RECIP_INTERFACE))\r\nbreak;\r\nif (fsg->config && w_index == 0) {\r\nraise_exception(fsg, FSG_STATE_INTERFACE_CHANGE);\r\nvalue = DELAYED_STATUS;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_INTERFACE:\r\nif (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD |\r\nUSB_RECIP_INTERFACE))\r\nbreak;\r\nif (!fsg->config)\r\nbreak;\r\nif (w_index != 0) {\r\nvalue = -EDOM;\r\nbreak;\r\n}\r\nVDBG(fsg, "get interface\n");\r\n*(u8 *) req->buf = 0;\r\nvalue = 1;\r\nbreak;\r\ndefault:\r\nVDBG(fsg,\r\n"unknown control req %02x.%02x v%04x i%04x l%u\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, le16_to_cpu(ctrl->wLength));\r\n}\r\nreturn value;\r\n}\r\nstatic int fsg_setup(struct usb_gadget *gadget,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct fsg_dev *fsg = get_gadget_data(gadget);\r\nint rc;\r\nint w_length = le16_to_cpu(ctrl->wLength);\r\n++fsg->ep0_req_tag;\r\nfsg->ep0req->context = NULL;\r\nfsg->ep0req->length = 0;\r\ndump_msg(fsg, "ep0-setup", (u8 *) ctrl, sizeof(*ctrl));\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS)\r\nrc = class_setup_req(fsg, ctrl);\r\nelse\r\nrc = standard_setup_req(fsg, ctrl);\r\nif (rc >= 0 && rc != DELAYED_STATUS) {\r\nrc = min(rc, w_length);\r\nfsg->ep0req->length = rc;\r\nfsg->ep0req->zero = rc < w_length;\r\nfsg->ep0req_name = (ctrl->bRequestType & USB_DIR_IN ?\r\n"ep0-in" : "ep0-out");\r\nrc = ep0_queue(fsg);\r\n}\r\nreturn rc;\r\n}\r\nstatic void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,\r\nstruct usb_request *req, int *pbusy,\r\nenum fsg_buffer_state *state)\r\n{\r\nint rc;\r\nif (ep == fsg->bulk_in)\r\ndump_msg(fsg, "bulk-in", req->buf, req->length);\r\nelse if (ep == fsg->intr_in)\r\ndump_msg(fsg, "intr-in", req->buf, req->length);\r\nspin_lock_irq(&fsg->lock);\r\n*pbusy = 1;\r\n*state = BUF_STATE_BUSY;\r\nspin_unlock_irq(&fsg->lock);\r\nrc = usb_ep_queue(ep, req, GFP_KERNEL);\r\nif (rc != 0) {\r\n*pbusy = 0;\r\n*state = BUF_STATE_EMPTY;\r\nif (rc != -ESHUTDOWN && !(rc == -EOPNOTSUPP &&\r\nreq->length == 0))\r\nWARNING(fsg, "error in submission: %s --> %d\n",\r\nep->name, rc);\r\n}\r\n}\r\nstatic int sleep_thread(struct fsg_dev *fsg)\r\n{\r\nint rc = 0;\r\nfor (;;) {\r\ntry_to_freeze();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (signal_pending(current)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\nif (fsg->thread_wakeup_needed)\r\nbreak;\r\nschedule();\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nfsg->thread_wakeup_needed = 0;\r\nreturn rc;\r\n}\r\nstatic int do_read(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nu32 lba;\r\nstruct fsg_buffhd *bh;\r\nint rc;\r\nu32 amount_left;\r\nloff_t file_offset, file_offset_tmp;\r\nunsigned int amount;\r\nssize_t nread;\r\nif (fsg->cmnd[0] == READ_6)\r\nlba = get_unaligned_be24(&fsg->cmnd[1]);\r\nelse {\r\nlba = get_unaligned_be32(&fsg->cmnd[2]);\r\nif ((fsg->cmnd[1] & ~0x18) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nfile_offset = ((loff_t) lba) << curlun->blkbits;\r\namount_left = fsg->data_size_from_cmnd;\r\nif (unlikely(amount_left == 0))\r\nreturn -EIO;\r\nfor (;;) {\r\namount = min((unsigned int) amount_left, mod_data.buflen);\r\namount = min((loff_t) amount,\r\ncurlun->file_length - file_offset);\r\nbh = fsg->next_buffhd_to_fill;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (amount == 0) {\r\ncurlun->sense_data =\r\nSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\ncurlun->sense_data_info = file_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbh->inreq->length = 0;\r\nbh->state = BUF_STATE_FULL;\r\nbreak;\r\n}\r\nfile_offset_tmp = file_offset;\r\nnread = vfs_read(curlun->filp,\r\n(char __user *) bh->buf,\r\namount, &file_offset_tmp);\r\nVLDBG(curlun, "file read %u @ %llu -> %d\n", amount,\r\n(unsigned long long) file_offset,\r\n(int) nread);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (nread < 0) {\r\nLDBG(curlun, "error in file read: %d\n",\r\n(int) nread);\r\nnread = 0;\r\n} else if (nread < amount) {\r\nLDBG(curlun, "partial file read: %d/%u\n",\r\n(int) nread, amount);\r\nnread = round_down(nread, curlun->blksize);\r\n}\r\nfile_offset += nread;\r\namount_left -= nread;\r\nfsg->residue -= nread;\r\nbh->inreq->length = nread;\r\nbh->state = BUF_STATE_FULL;\r\nif (nread < amount) {\r\ncurlun->sense_data = SS_UNRECOVERED_READ_ERROR;\r\ncurlun->sense_data_info = file_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nif (amount_left == 0)\r\nbreak;\r\nbh->inreq->zero = 0;\r\nstart_transfer(fsg, fsg->bulk_in, bh->inreq,\r\n&bh->inreq_busy, &bh->state);\r\nfsg->next_buffhd_to_fill = bh->next;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int do_write(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nu32 lba;\r\nstruct fsg_buffhd *bh;\r\nint get_some_more;\r\nu32 amount_left_to_req, amount_left_to_write;\r\nloff_t usb_offset, file_offset, file_offset_tmp;\r\nunsigned int amount;\r\nssize_t nwritten;\r\nint rc;\r\nif (curlun->ro) {\r\ncurlun->sense_data = SS_WRITE_PROTECTED;\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&curlun->filp->f_lock);\r\ncurlun->filp->f_flags &= ~O_SYNC;\r\nspin_unlock(&curlun->filp->f_lock);\r\nif (fsg->cmnd[0] == WRITE_6)\r\nlba = get_unaligned_be24(&fsg->cmnd[1]);\r\nelse {\r\nlba = get_unaligned_be32(&fsg->cmnd[2]);\r\nif ((fsg->cmnd[1] & ~0x18) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (!curlun->nofua && (fsg->cmnd[1] & 0x08)) {\r\nspin_lock(&curlun->filp->f_lock);\r\ncurlun->filp->f_flags |= O_DSYNC;\r\nspin_unlock(&curlun->filp->f_lock);\r\n}\r\n}\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nget_some_more = 1;\r\nfile_offset = usb_offset = ((loff_t) lba) << curlun->blkbits;\r\namount_left_to_req = amount_left_to_write = fsg->data_size_from_cmnd;\r\nwhile (amount_left_to_write > 0) {\r\nbh = fsg->next_buffhd_to_fill;\r\nif (bh->state == BUF_STATE_EMPTY && get_some_more) {\r\namount = min(amount_left_to_req, mod_data.buflen);\r\nif (usb_offset >= curlun->file_length) {\r\nget_some_more = 0;\r\ncurlun->sense_data =\r\nSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\ncurlun->sense_data_info = usb_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\ncontinue;\r\n}\r\nusb_offset += amount;\r\nfsg->usb_amount_left -= amount;\r\namount_left_to_req -= amount;\r\nif (amount_left_to_req == 0)\r\nget_some_more = 0;\r\nset_bulk_out_req_length(fsg, bh, amount);\r\nstart_transfer(fsg, fsg->bulk_out, bh->outreq,\r\n&bh->outreq_busy, &bh->state);\r\nfsg->next_buffhd_to_fill = bh->next;\r\ncontinue;\r\n}\r\nbh = fsg->next_buffhd_to_drain;\r\nif (bh->state == BUF_STATE_EMPTY && !get_some_more)\r\nbreak;\r\nif (bh->state == BUF_STATE_FULL) {\r\nsmp_rmb();\r\nfsg->next_buffhd_to_drain = bh->next;\r\nbh->state = BUF_STATE_EMPTY;\r\nif (bh->outreq->status != 0) {\r\ncurlun->sense_data = SS_COMMUNICATION_FAILURE;\r\ncurlun->sense_data_info = file_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\namount = bh->outreq->actual;\r\nif (curlun->file_length - file_offset < amount) {\r\nLERROR(curlun,\r\n"write %u @ %llu beyond end %llu\n",\r\namount, (unsigned long long) file_offset,\r\n(unsigned long long) curlun->file_length);\r\namount = curlun->file_length - file_offset;\r\n}\r\namount = min(amount, bh->bulk_out_intended_length);\r\namount = round_down(amount, curlun->blksize);\r\nif (amount == 0)\r\ngoto empty_write;\r\nfile_offset_tmp = file_offset;\r\nnwritten = vfs_write(curlun->filp,\r\n(char __user *) bh->buf,\r\namount, &file_offset_tmp);\r\nVLDBG(curlun, "file write %u @ %llu -> %d\n", amount,\r\n(unsigned long long) file_offset,\r\n(int) nwritten);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (nwritten < 0) {\r\nLDBG(curlun, "error in file write: %d\n",\r\n(int) nwritten);\r\nnwritten = 0;\r\n} else if (nwritten < amount) {\r\nLDBG(curlun, "partial file write: %d/%u\n",\r\n(int) nwritten, amount);\r\nnwritten = round_down(nwritten, curlun->blksize);\r\n}\r\nfile_offset += nwritten;\r\namount_left_to_write -= nwritten;\r\nfsg->residue -= nwritten;\r\nif (nwritten < amount) {\r\ncurlun->sense_data = SS_WRITE_ERROR;\r\ncurlun->sense_data_info = file_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nempty_write:\r\nif (bh->outreq->actual < bh->bulk_out_intended_length) {\r\nfsg->short_packet_received = 1;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int do_synchronize_cache(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nint rc;\r\nrc = fsg_lun_fsync_sub(curlun);\r\nif (rc)\r\ncurlun->sense_data = SS_WRITE_ERROR;\r\nreturn 0;\r\n}\r\nstatic void invalidate_sub(struct fsg_lun *curlun)\r\n{\r\nstruct file *filp = curlun->filp;\r\nstruct inode *inode = filp->f_path.dentry->d_inode;\r\nunsigned long rc;\r\nrc = invalidate_mapping_pages(inode->i_mapping, 0, -1);\r\nVLDBG(curlun, "invalidate_mapping_pages -> %ld\n", rc);\r\n}\r\nstatic int do_verify(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nu32 lba;\r\nu32 verification_length;\r\nstruct fsg_buffhd *bh = fsg->next_buffhd_to_fill;\r\nloff_t file_offset, file_offset_tmp;\r\nu32 amount_left;\r\nunsigned int amount;\r\nssize_t nread;\r\nlba = get_unaligned_be32(&fsg->cmnd[2]);\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nif ((fsg->cmnd[1] & ~0x10) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nverification_length = get_unaligned_be16(&fsg->cmnd[7]);\r\nif (unlikely(verification_length == 0))\r\nreturn -EIO;\r\namount_left = verification_length << curlun->blkbits;\r\nfile_offset = ((loff_t) lba) << curlun->blkbits;\r\nfsg_lun_fsync_sub(curlun);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\ninvalidate_sub(curlun);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nwhile (amount_left > 0) {\r\namount = min((unsigned int) amount_left, mod_data.buflen);\r\namount = min((loff_t) amount,\r\ncurlun->file_length - file_offset);\r\nif (amount == 0) {\r\ncurlun->sense_data =\r\nSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\ncurlun->sense_data_info = file_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nfile_offset_tmp = file_offset;\r\nnread = vfs_read(curlun->filp,\r\n(char __user *) bh->buf,\r\namount, &file_offset_tmp);\r\nVLDBG(curlun, "file read %u @ %llu -> %d\n", amount,\r\n(unsigned long long) file_offset,\r\n(int) nread);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (nread < 0) {\r\nLDBG(curlun, "error in file verify: %d\n",\r\n(int) nread);\r\nnread = 0;\r\n} else if (nread < amount) {\r\nLDBG(curlun, "partial file verify: %d/%u\n",\r\n(int) nread, amount);\r\nnread = round_down(nread, curlun->blksize);\r\n}\r\nif (nread == 0) {\r\ncurlun->sense_data = SS_UNRECOVERED_READ_ERROR;\r\ncurlun->sense_data_info = file_offset >> curlun->blkbits;\r\ncurlun->info_valid = 1;\r\nbreak;\r\n}\r\nfile_offset += nread;\r\namount_left -= nread;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nu8 *buf = (u8 *) bh->buf;\r\nstatic char vendor_id[] = "Linux ";\r\nstatic char product_disk_id[] = "File-Stor Gadget";\r\nstatic char product_cdrom_id[] = "File-CD Gadget ";\r\nif (!fsg->curlun) {\r\nfsg->bad_lun_okay = 1;\r\nmemset(buf, 0, 36);\r\nbuf[0] = 0x7f;\r\nbuf[4] = 31;\r\nreturn 36;\r\n}\r\nmemset(buf, 0, 8);\r\nbuf[0] = (mod_data.cdrom ? TYPE_ROM : TYPE_DISK);\r\nif (mod_data.removable)\r\nbuf[1] = 0x80;\r\nbuf[2] = 2;\r\nbuf[3] = 2;\r\nbuf[4] = 31;\r\nsprintf(buf + 8, "%-8s%-16s%04x", vendor_id,\r\n(mod_data.cdrom ? product_cdrom_id :\r\nproduct_disk_id),\r\nmod_data.release);\r\nreturn 36;\r\n}\r\nstatic int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nu8 *buf = (u8 *) bh->buf;\r\nu32 sd, sdinfo;\r\nint valid;\r\n#if 0\r\nif (curlun && curlun->unit_attention_data != SS_NO_SENSE) {\r\ncurlun->sense_data = curlun->unit_attention_data;\r\ncurlun->unit_attention_data = SS_NO_SENSE;\r\n}\r\n#endif\r\nif (!curlun) {\r\nfsg->bad_lun_okay = 1;\r\nsd = SS_LOGICAL_UNIT_NOT_SUPPORTED;\r\nsdinfo = 0;\r\nvalid = 0;\r\n} else {\r\nsd = curlun->sense_data;\r\nsdinfo = curlun->sense_data_info;\r\nvalid = curlun->info_valid << 7;\r\ncurlun->sense_data = SS_NO_SENSE;\r\ncurlun->sense_data_info = 0;\r\ncurlun->info_valid = 0;\r\n}\r\nmemset(buf, 0, 18);\r\nbuf[0] = valid | 0x70;\r\nbuf[2] = SK(sd);\r\nput_unaligned_be32(sdinfo, &buf[3]);\r\nbuf[7] = 18 - 8;\r\nbuf[12] = ASC(sd);\r\nbuf[13] = ASCQ(sd);\r\nreturn 18;\r\n}\r\nstatic int do_read_capacity(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nu32 lba = get_unaligned_be32(&fsg->cmnd[2]);\r\nint pmi = fsg->cmnd[8];\r\nu8 *buf = (u8 *) bh->buf;\r\nif (pmi > 1 || (pmi == 0 && lba != 0)) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nput_unaligned_be32(curlun->num_sectors - 1, &buf[0]);\r\nput_unaligned_be32(curlun->blksize, &buf[4]);\r\nreturn 8;\r\n}\r\nstatic int do_read_header(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nint msf = fsg->cmnd[1] & 0x02;\r\nu32 lba = get_unaligned_be32(&fsg->cmnd[2]);\r\nu8 *buf = (u8 *) bh->buf;\r\nif ((fsg->cmnd[1] & ~0x02) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (lba >= curlun->num_sectors) {\r\ncurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, 8);\r\nbuf[0] = 0x01;\r\nstore_cdrom_address(&buf[4], msf, lba);\r\nreturn 8;\r\n}\r\nstatic int do_read_toc(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nint msf = fsg->cmnd[1] & 0x02;\r\nint start_track = fsg->cmnd[6];\r\nu8 *buf = (u8 *) bh->buf;\r\nif ((fsg->cmnd[1] & ~0x02) != 0 ||\r\nstart_track > 1) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, 20);\r\nbuf[1] = (20-2);\r\nbuf[2] = 1;\r\nbuf[3] = 1;\r\nbuf[5] = 0x16;\r\nbuf[6] = 0x01;\r\nstore_cdrom_address(&buf[8], msf, 0);\r\nbuf[13] = 0x16;\r\nbuf[14] = 0xAA;\r\nstore_cdrom_address(&buf[16], msf, curlun->num_sectors);\r\nreturn 20;\r\n}\r\nstatic int do_mode_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nint mscmnd = fsg->cmnd[0];\r\nu8 *buf = (u8 *) bh->buf;\r\nu8 *buf0 = buf;\r\nint pc, page_code;\r\nint changeable_values, all_pages;\r\nint valid_page = 0;\r\nint len, limit;\r\nif ((fsg->cmnd[1] & ~0x08) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\npc = fsg->cmnd[2] >> 6;\r\npage_code = fsg->cmnd[2] & 0x3f;\r\nif (pc == 3) {\r\ncurlun->sense_data = SS_SAVING_PARAMETERS_NOT_SUPPORTED;\r\nreturn -EINVAL;\r\n}\r\nchangeable_values = (pc == 1);\r\nall_pages = (page_code == 0x3f);\r\nmemset(buf, 0, 8);\r\nif (mscmnd == MODE_SENSE) {\r\nbuf[2] = (curlun->ro ? 0x80 : 0x00);\r\nbuf += 4;\r\nlimit = 255;\r\n} else {\r\nbuf[3] = (curlun->ro ? 0x80 : 0x00);\r\nbuf += 8;\r\nlimit = 65535;\r\n}\r\nif (page_code == 0x08 || all_pages) {\r\nvalid_page = 1;\r\nbuf[0] = 0x08;\r\nbuf[1] = 10;\r\nmemset(buf+2, 0, 10);\r\nif (!changeable_values) {\r\nbuf[2] = 0x04;\r\nput_unaligned_be16(0xffff, &buf[4]);\r\nput_unaligned_be16(0xffff, &buf[8]);\r\nput_unaligned_be16(0xffff, &buf[10]);\r\n}\r\nbuf += 12;\r\n}\r\nlen = buf - buf0;\r\nif (!valid_page || len > limit) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (mscmnd == MODE_SENSE)\r\nbuf0[0] = len - 1;\r\nelse\r\nput_unaligned_be16(len - 2, buf0);\r\nreturn len;\r\n}\r\nstatic int do_start_stop(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nint loej, start;\r\nif (!mod_data.removable) {\r\ncurlun->sense_data = SS_INVALID_COMMAND;\r\nreturn -EINVAL;\r\n}\r\nloej = fsg->cmnd[4] & 0x02;\r\nstart = fsg->cmnd[4] & 0x01;\r\n#ifdef CONFIG_USB_FILE_STORAGE_TEST\r\nif ((fsg->cmnd[1] & ~0x01) != 0 ||\r\n(fsg->cmnd[4] & ~0x03) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (!start) {\r\nif (curlun->prevent_medium_removal) {\r\nLDBG(curlun, "unload attempt prevented\n");\r\ncurlun->sense_data = SS_MEDIUM_REMOVAL_PREVENTED;\r\nreturn -EINVAL;\r\n}\r\nif (loej) {\r\nup_read(&fsg->filesem);\r\ndown_write(&fsg->filesem);\r\nfsg_lun_close(curlun);\r\nup_write(&fsg->filesem);\r\ndown_read(&fsg->filesem);\r\n}\r\n} else {\r\nif (!fsg_lun_is_open(curlun)) {\r\ncurlun->sense_data = SS_MEDIUM_NOT_PRESENT;\r\nreturn -EINVAL;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int do_prevent_allow(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nint prevent;\r\nif (!mod_data.removable) {\r\ncurlun->sense_data = SS_INVALID_COMMAND;\r\nreturn -EINVAL;\r\n}\r\nprevent = fsg->cmnd[4] & 0x01;\r\nif ((fsg->cmnd[4] & ~0x01) != 0) {\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\nif (curlun->prevent_medium_removal && !prevent)\r\nfsg_lun_fsync_sub(curlun);\r\ncurlun->prevent_medium_removal = prevent;\r\nreturn 0;\r\n}\r\nstatic int do_read_format_capacities(struct fsg_dev *fsg,\r\nstruct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nu8 *buf = (u8 *) bh->buf;\r\nbuf[0] = buf[1] = buf[2] = 0;\r\nbuf[3] = 8;\r\nbuf += 4;\r\nput_unaligned_be32(curlun->num_sectors, &buf[0]);\r\nput_unaligned_be32(curlun->blksize, &buf[4]);\r\nbuf[4] = 0x02;\r\nreturn 12;\r\n}\r\nstatic int do_mode_select(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\ncurlun->sense_data = SS_INVALID_COMMAND;\r\nreturn -EINVAL;\r\n}\r\nstatic int halt_bulk_in_endpoint(struct fsg_dev *fsg)\r\n{\r\nint rc;\r\nrc = fsg_set_halt(fsg, fsg->bulk_in);\r\nif (rc == -EAGAIN)\r\nVDBG(fsg, "delayed bulk-in endpoint halt\n");\r\nwhile (rc != 0) {\r\nif (rc != -EAGAIN) {\r\nWARNING(fsg, "usb_ep_set_halt -> %d\n", rc);\r\nrc = 0;\r\nbreak;\r\n}\r\nif (msleep_interruptible(100) != 0)\r\nreturn -EINTR;\r\nrc = usb_ep_set_halt(fsg->bulk_in);\r\n}\r\nreturn rc;\r\n}\r\nstatic int wedge_bulk_in_endpoint(struct fsg_dev *fsg)\r\n{\r\nint rc;\r\nDBG(fsg, "bulk-in set wedge\n");\r\nrc = usb_ep_set_wedge(fsg->bulk_in);\r\nif (rc == -EAGAIN)\r\nVDBG(fsg, "delayed bulk-in endpoint wedge\n");\r\nwhile (rc != 0) {\r\nif (rc != -EAGAIN) {\r\nWARNING(fsg, "usb_ep_set_wedge -> %d\n", rc);\r\nrc = 0;\r\nbreak;\r\n}\r\nif (msleep_interruptible(100) != 0)\r\nreturn -EINTR;\r\nrc = usb_ep_set_wedge(fsg->bulk_in);\r\n}\r\nreturn rc;\r\n}\r\nstatic int throw_away_data(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_buffhd *bh;\r\nu32 amount;\r\nint rc;\r\nwhile ((bh = fsg->next_buffhd_to_drain)->state != BUF_STATE_EMPTY ||\r\nfsg->usb_amount_left > 0) {\r\nif (bh->state == BUF_STATE_FULL) {\r\nsmp_rmb();\r\nbh->state = BUF_STATE_EMPTY;\r\nfsg->next_buffhd_to_drain = bh->next;\r\nif (bh->outreq->actual < bh->bulk_out_intended_length ||\r\nbh->outreq->status != 0) {\r\nraise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);\r\nreturn -EINTR;\r\n}\r\ncontinue;\r\n}\r\nbh = fsg->next_buffhd_to_fill;\r\nif (bh->state == BUF_STATE_EMPTY && fsg->usb_amount_left > 0) {\r\namount = min(fsg->usb_amount_left,\r\n(u32) mod_data.buflen);\r\nset_bulk_out_req_length(fsg, bh, amount);\r\nstart_transfer(fsg, fsg->bulk_out, bh->outreq,\r\n&bh->outreq_busy, &bh->state);\r\nfsg->next_buffhd_to_fill = bh->next;\r\nfsg->usb_amount_left -= amount;\r\ncontinue;\r\n}\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int finish_reply(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_buffhd *bh = fsg->next_buffhd_to_fill;\r\nint rc = 0;\r\nswitch (fsg->data_dir) {\r\ncase DATA_DIR_NONE:\r\nbreak;\r\ncase DATA_DIR_UNKNOWN:\r\nif (mod_data.can_stall) {\r\nfsg_set_halt(fsg, fsg->bulk_out);\r\nrc = halt_bulk_in_endpoint(fsg);\r\n}\r\nbreak;\r\ncase DATA_DIR_TO_HOST:\r\nif (fsg->data_size == 0)\r\n;\r\nelse if (fsg->residue == 0) {\r\nbh->inreq->zero = 0;\r\nstart_transfer(fsg, fsg->bulk_in, bh->inreq,\r\n&bh->inreq_busy, &bh->state);\r\nfsg->next_buffhd_to_fill = bh->next;\r\n}\r\nelse if (!transport_is_bbb()) {\r\nif (mod_data.can_stall &&\r\nfsg->residue == fsg->data_size &&\r\n(!fsg->curlun || fsg->curlun->sense_data != SS_NO_SENSE)) {\r\nbh->state = BUF_STATE_EMPTY;\r\nrc = halt_bulk_in_endpoint(fsg);\r\n} else {\r\nbh->inreq->zero = 1;\r\nstart_transfer(fsg, fsg->bulk_in, bh->inreq,\r\n&bh->inreq_busy, &bh->state);\r\nfsg->next_buffhd_to_fill = bh->next;\r\n}\r\n}\r\nelse {\r\nbh->inreq->zero = 1;\r\nstart_transfer(fsg, fsg->bulk_in, bh->inreq,\r\n&bh->inreq_busy, &bh->state);\r\nfsg->next_buffhd_to_fill = bh->next;\r\nif (mod_data.can_stall)\r\nrc = halt_bulk_in_endpoint(fsg);\r\n}\r\nbreak;\r\ncase DATA_DIR_FROM_HOST:\r\nif (fsg->residue == 0)\r\n;\r\nelse if (fsg->short_packet_received) {\r\nraise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);\r\nrc = -EINTR;\r\n}\r\n#if 0\r\nelse if (mod_data.can_stall) {\r\nfsg_set_halt(fsg, fsg->bulk_out);\r\nraise_exception(fsg, FSG_STATE_ABORT_BULK_OUT);\r\nrc = -EINTR;\r\n}\r\n#endif\r\nelse\r\nrc = throw_away_data(fsg);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int send_status(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_lun *curlun = fsg->curlun;\r\nstruct fsg_buffhd *bh;\r\nint rc;\r\nu8 status = US_BULK_STAT_OK;\r\nu32 sd, sdinfo = 0;\r\nbh = fsg->next_buffhd_to_fill;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (curlun) {\r\nsd = curlun->sense_data;\r\nsdinfo = curlun->sense_data_info;\r\n} else if (fsg->bad_lun_okay)\r\nsd = SS_NO_SENSE;\r\nelse\r\nsd = SS_LOGICAL_UNIT_NOT_SUPPORTED;\r\nif (fsg->phase_error) {\r\nDBG(fsg, "sending phase-error status\n");\r\nstatus = US_BULK_STAT_PHASE;\r\nsd = SS_INVALID_COMMAND;\r\n} else if (sd != SS_NO_SENSE) {\r\nDBG(fsg, "sending command-failure status\n");\r\nstatus = US_BULK_STAT_FAIL;\r\nVDBG(fsg, " sense data: SK x%02x, ASC x%02x, ASCQ x%02x;"\r\n" info x%x\n",\r\nSK(sd), ASC(sd), ASCQ(sd), sdinfo);\r\n}\r\nif (transport_is_bbb()) {\r\nstruct bulk_cs_wrap *csw = bh->buf;\r\ncsw->Signature = cpu_to_le32(US_BULK_CS_SIGN);\r\ncsw->Tag = fsg->tag;\r\ncsw->Residue = cpu_to_le32(fsg->residue);\r\ncsw->Status = status;\r\nbh->inreq->length = US_BULK_CS_WRAP_LEN;\r\nbh->inreq->zero = 0;\r\nstart_transfer(fsg, fsg->bulk_in, bh->inreq,\r\n&bh->inreq_busy, &bh->state);\r\n} else if (mod_data.transport_type == USB_PR_CB) {\r\nreturn 0;\r\n} else {\r\nstruct interrupt_data *buf = bh->buf;\r\nif (mod_data.protocol_type == USB_SC_UFI) {\r\nbuf->bType = ASC(sd);\r\nbuf->bValue = ASCQ(sd);\r\n} else {\r\nbuf->bType = 0;\r\nbuf->bValue = status;\r\n}\r\nfsg->intreq->length = CBI_INTERRUPT_DATA_LEN;\r\nfsg->intr_buffhd = bh;\r\nfsg->intreq->buf = bh->inreq->buf;\r\nfsg->intreq->context = bh;\r\nstart_transfer(fsg, fsg->intr_in, fsg->intreq,\r\n&fsg->intreq_busy, &bh->state);\r\n}\r\nfsg->next_buffhd_to_fill = bh->next;\r\nreturn 0;\r\n}\r\nstatic int check_command(struct fsg_dev *fsg, int cmnd_size,\r\nenum data_direction data_dir, unsigned int mask,\r\nint needs_medium, const char *name)\r\n{\r\nint i;\r\nint lun = fsg->cmnd[1] >> 5;\r\nstatic const char dirletter[4] = {'u', 'o', 'i', 'n'};\r\nchar hdlen[20];\r\nstruct fsg_lun *curlun;\r\nif (protocol_is_scsi())\r\n;\r\nelse if (mod_data.protocol_type == USB_SC_RBC) {\r\nif (fsg->cmnd_size == 12)\r\ncmnd_size = 12;\r\n} else\r\ncmnd_size = 12;\r\nhdlen[0] = 0;\r\nif (fsg->data_dir != DATA_DIR_UNKNOWN)\r\nsprintf(hdlen, ", H%c=%u", dirletter[(int) fsg->data_dir],\r\nfsg->data_size);\r\nVDBG(fsg, "SCSI command: %s; Dc=%d, D%c=%u; Hc=%d%s\n",\r\nname, cmnd_size, dirletter[(int) data_dir],\r\nfsg->data_size_from_cmnd, fsg->cmnd_size, hdlen);\r\nif (fsg->data_size_from_cmnd == 0)\r\ndata_dir = DATA_DIR_NONE;\r\nif (fsg->data_dir == DATA_DIR_UNKNOWN) {\r\nfsg->data_dir = data_dir;\r\nfsg->data_size = fsg->data_size_from_cmnd;\r\n} else {\r\nif (fsg->data_size < fsg->data_size_from_cmnd) {\r\nfsg->data_size_from_cmnd = fsg->data_size;\r\nfsg->phase_error = 1;\r\n}\r\n}\r\nfsg->residue = fsg->usb_amount_left = fsg->data_size;\r\nif (fsg->data_dir != data_dir && fsg->data_size_from_cmnd > 0) {\r\nfsg->phase_error = 1;\r\nreturn -EINVAL;\r\n}\r\nif (cmnd_size != fsg->cmnd_size) {\r\nif (cmnd_size <= fsg->cmnd_size) {\r\nDBG(fsg, "%s is buggy! Expected length %d "\r\n"but we got %d\n", name,\r\ncmnd_size, fsg->cmnd_size);\r\ncmnd_size = fsg->cmnd_size;\r\n} else {\r\nfsg->phase_error = 1;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (transport_is_bbb()) {\r\nif (fsg->lun != lun)\r\nDBG(fsg, "using LUN %d from CBW, "\r\n"not LUN %d from CDB\n",\r\nfsg->lun, lun);\r\n}\r\ncurlun = fsg->curlun;\r\nif (curlun) {\r\nif (fsg->cmnd[0] != REQUEST_SENSE) {\r\ncurlun->sense_data = SS_NO_SENSE;\r\ncurlun->sense_data_info = 0;\r\ncurlun->info_valid = 0;\r\n}\r\n} else {\r\nfsg->bad_lun_okay = 0;\r\nif (fsg->cmnd[0] != INQUIRY &&\r\nfsg->cmnd[0] != REQUEST_SENSE) {\r\nDBG(fsg, "unsupported LUN %d\n", fsg->lun);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (curlun && curlun->unit_attention_data != SS_NO_SENSE &&\r\nfsg->cmnd[0] != INQUIRY &&\r\nfsg->cmnd[0] != REQUEST_SENSE) {\r\ncurlun->sense_data = curlun->unit_attention_data;\r\ncurlun->unit_attention_data = SS_NO_SENSE;\r\nreturn -EINVAL;\r\n}\r\nfsg->cmnd[1] &= 0x1f;\r\nfor (i = 1; i < cmnd_size; ++i) {\r\nif (fsg->cmnd[i] && !(mask & (1 << i))) {\r\nif (curlun)\r\ncurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (curlun && !fsg_lun_is_open(curlun) && needs_medium) {\r\ncurlun->sense_data = SS_MEDIUM_NOT_PRESENT;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_command_size_in_blocks(struct fsg_dev *fsg, int cmnd_size,\r\nenum data_direction data_dir, unsigned int mask,\r\nint needs_medium, const char *name)\r\n{\r\nif (fsg->curlun)\r\nfsg->data_size_from_cmnd <<= fsg->curlun->blkbits;\r\nreturn check_command(fsg, cmnd_size, data_dir,\r\nmask, needs_medium, name);\r\n}\r\nstatic int do_scsi_command(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_buffhd *bh;\r\nint rc;\r\nint reply = -EINVAL;\r\nint i;\r\nstatic char unknown[16];\r\ndump_cdb(fsg);\r\nbh = fsg->next_buffhd_to_drain = fsg->next_buffhd_to_fill;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nfsg->phase_error = 0;\r\nfsg->short_packet_received = 0;\r\ndown_read(&fsg->filesem);\r\nswitch (fsg->cmnd[0]) {\r\ncase INQUIRY:\r\nfsg->data_size_from_cmnd = fsg->cmnd[4];\r\nif ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,\r\n(1<<4), 0,\r\n"INQUIRY")) == 0)\r\nreply = do_inquiry(fsg, bh);\r\nbreak;\r\ncase MODE_SELECT:\r\nfsg->data_size_from_cmnd = fsg->cmnd[4];\r\nif ((reply = check_command(fsg, 6, DATA_DIR_FROM_HOST,\r\n(1<<1) | (1<<4), 0,\r\n"MODE SELECT(6)")) == 0)\r\nreply = do_mode_select(fsg, bh);\r\nbreak;\r\ncase MODE_SELECT_10:\r\nfsg->data_size_from_cmnd = get_unaligned_be16(&fsg->cmnd[7]);\r\nif ((reply = check_command(fsg, 10, DATA_DIR_FROM_HOST,\r\n(1<<1) | (3<<7), 0,\r\n"MODE SELECT(10)")) == 0)\r\nreply = do_mode_select(fsg, bh);\r\nbreak;\r\ncase MODE_SENSE:\r\nfsg->data_size_from_cmnd = fsg->cmnd[4];\r\nif ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,\r\n(1<<1) | (1<<2) | (1<<4), 0,\r\n"MODE SENSE(6)")) == 0)\r\nreply = do_mode_sense(fsg, bh);\r\nbreak;\r\ncase MODE_SENSE_10:\r\nfsg->data_size_from_cmnd = get_unaligned_be16(&fsg->cmnd[7]);\r\nif ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,\r\n(1<<1) | (1<<2) | (3<<7), 0,\r\n"MODE SENSE(10)")) == 0)\r\nreply = do_mode_sense(fsg, bh);\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\nfsg->data_size_from_cmnd = 0;\r\nif ((reply = check_command(fsg, 6, DATA_DIR_NONE,\r\n(1<<4), 0,\r\n"PREVENT-ALLOW MEDIUM REMOVAL")) == 0)\r\nreply = do_prevent_allow(fsg);\r\nbreak;\r\ncase READ_6:\r\ni = fsg->cmnd[4];\r\nfsg->data_size_from_cmnd = (i == 0) ? 256 : i;\r\nif ((reply = check_command_size_in_blocks(fsg, 6,\r\nDATA_DIR_TO_HOST,\r\n(7<<1) | (1<<4), 1,\r\n"READ(6)")) == 0)\r\nreply = do_read(fsg);\r\nbreak;\r\ncase READ_10:\r\nfsg->data_size_from_cmnd = get_unaligned_be16(&fsg->cmnd[7]);\r\nif ((reply = check_command_size_in_blocks(fsg, 10,\r\nDATA_DIR_TO_HOST,\r\n(1<<1) | (0xf<<2) | (3<<7), 1,\r\n"READ(10)")) == 0)\r\nreply = do_read(fsg);\r\nbreak;\r\ncase READ_12:\r\nfsg->data_size_from_cmnd = get_unaligned_be32(&fsg->cmnd[6]);\r\nif ((reply = check_command_size_in_blocks(fsg, 12,\r\nDATA_DIR_TO_HOST,\r\n(1<<1) | (0xf<<2) | (0xf<<6), 1,\r\n"READ(12)")) == 0)\r\nreply = do_read(fsg);\r\nbreak;\r\ncase READ_CAPACITY:\r\nfsg->data_size_from_cmnd = 8;\r\nif ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,\r\n(0xf<<2) | (1<<8), 1,\r\n"READ CAPACITY")) == 0)\r\nreply = do_read_capacity(fsg, bh);\r\nbreak;\r\ncase READ_HEADER:\r\nif (!mod_data.cdrom)\r\ngoto unknown_cmnd;\r\nfsg->data_size_from_cmnd = get_unaligned_be16(&fsg->cmnd[7]);\r\nif ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,\r\n(3<<7) | (0x1f<<1), 1,\r\n"READ HEADER")) == 0)\r\nreply = do_read_header(fsg, bh);\r\nbreak;\r\ncase READ_TOC:\r\nif (!mod_data.cdrom)\r\ngoto unknown_cmnd;\r\nfsg->data_size_from_cmnd = get_unaligned_be16(&fsg->cmnd[7]);\r\nif ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,\r\n(7<<6) | (1<<1), 1,\r\n"READ TOC")) == 0)\r\nreply = do_read_toc(fsg, bh);\r\nbreak;\r\ncase READ_FORMAT_CAPACITIES:\r\nfsg->data_size_from_cmnd = get_unaligned_be16(&fsg->cmnd[7]);\r\nif ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,\r\n(3<<7), 1,\r\n"READ FORMAT CAPACITIES")) == 0)\r\nreply = do_read_format_capacities(fsg, bh);\r\nbreak;\r\ncase REQUEST_SENSE:\r\nfsg->data_size_from_cmnd = fsg->cmnd[4];\r\nif ((reply = check_command(fsg, 6, DATA_DIR_TO_HOST,\r\n(1<<4), 0,\r\n"REQUEST SENSE")) == 0)\r\nreply = do_request_sense(fsg, bh);\r\nbreak;\r\ncase START_STOP:\r\nfsg->data_size_from_cmnd = 0;\r\nif ((reply = check_command(fsg, 6, DATA_DIR_NONE,\r\n(1<<1) | (1<<4), 0,\r\n"START-STOP UNIT")) == 0)\r\nreply = do_start_stop(fsg);\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\nfsg->data_size_from_cmnd = 0;\r\nif ((reply = check_command(fsg, 10, DATA_DIR_NONE,\r\n(0xf<<2) | (3<<7), 1,\r\n"SYNCHRONIZE CACHE")) == 0)\r\nreply = do_synchronize_cache(fsg);\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nfsg->data_size_from_cmnd = 0;\r\nreply = check_command(fsg, 6, DATA_DIR_NONE,\r\n0, 1,\r\n"TEST UNIT READY");\r\nbreak;\r\ncase VERIFY:\r\nfsg->data_size_from_cmnd = 0;\r\nif ((reply = check_command(fsg, 10, DATA_DIR_NONE,\r\n(1<<1) | (0xf<<2) | (3<<7), 1,\r\n"VERIFY")) == 0)\r\nreply = do_verify(fsg);\r\nbreak;\r\ncase WRITE_6:\r\ni = fsg->cmnd[4];\r\nfsg->data_size_from_cmnd = (i == 0) ? 256 : i;\r\nif ((reply = check_command_size_in_blocks(fsg, 6,\r\nDATA_DIR_FROM_HOST,\r\n(7<<1) | (1<<4), 1,\r\n"WRITE(6)")) == 0)\r\nreply = do_write(fsg);\r\nbreak;\r\ncase WRITE_10:\r\nfsg->data_size_from_cmnd = get_unaligned_be16(&fsg->cmnd[7]);\r\nif ((reply = check_command_size_in_blocks(fsg, 10,\r\nDATA_DIR_FROM_HOST,\r\n(1<<1) | (0xf<<2) | (3<<7), 1,\r\n"WRITE(10)")) == 0)\r\nreply = do_write(fsg);\r\nbreak;\r\ncase WRITE_12:\r\nfsg->data_size_from_cmnd = get_unaligned_be32(&fsg->cmnd[6]);\r\nif ((reply = check_command_size_in_blocks(fsg, 12,\r\nDATA_DIR_FROM_HOST,\r\n(1<<1) | (0xf<<2) | (0xf<<6), 1,\r\n"WRITE(12)")) == 0)\r\nreply = do_write(fsg);\r\nbreak;\r\ncase FORMAT_UNIT:\r\ncase RELEASE:\r\ncase RESERVE:\r\ncase SEND_DIAGNOSTIC:\r\ndefault:\r\nunknown_cmnd:\r\nfsg->data_size_from_cmnd = 0;\r\nsprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);\r\nif ((reply = check_command(fsg, fsg->cmnd_size,\r\nDATA_DIR_UNKNOWN, ~0, 0, unknown)) == 0) {\r\nfsg->curlun->sense_data = SS_INVALID_COMMAND;\r\nreply = -EINVAL;\r\n}\r\nbreak;\r\n}\r\nup_read(&fsg->filesem);\r\nif (reply == -EINTR || signal_pending(current))\r\nreturn -EINTR;\r\nif (reply == -EINVAL)\r\nreply = 0;\r\nif (reply >= 0 && fsg->data_dir == DATA_DIR_TO_HOST) {\r\nreply = min((u32) reply, fsg->data_size_from_cmnd);\r\nbh->inreq->length = reply;\r\nbh->state = BUF_STATE_FULL;\r\nfsg->residue -= reply;\r\n}\r\nreturn 0;\r\n}\r\nstatic int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)\r\n{\r\nstruct usb_request *req = bh->outreq;\r\nstruct bulk_cb_wrap *cbw = req->buf;\r\nif (req->status || test_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags))\r\nreturn -EINVAL;\r\nif (req->actual != US_BULK_CB_WRAP_LEN ||\r\ncbw->Signature != cpu_to_le32(\r\nUS_BULK_CB_SIGN)) {\r\nDBG(fsg, "invalid CBW: len %u sig 0x%x\n",\r\nreq->actual,\r\nle32_to_cpu(cbw->Signature));\r\nwedge_bulk_in_endpoint(fsg);\r\nset_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);\r\nreturn -EINVAL;\r\n}\r\nif (cbw->Lun >= FSG_MAX_LUNS || cbw->Flags & ~US_BULK_FLAG_IN ||\r\ncbw->Length <= 0 || cbw->Length > MAX_COMMAND_SIZE) {\r\nDBG(fsg, "non-meaningful CBW: lun = %u, flags = 0x%x, "\r\n"cmdlen %u\n",\r\ncbw->Lun, cbw->Flags, cbw->Length);\r\nif (mod_data.can_stall) {\r\nfsg_set_halt(fsg, fsg->bulk_out);\r\nhalt_bulk_in_endpoint(fsg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nfsg->cmnd_size = cbw->Length;\r\nmemcpy(fsg->cmnd, cbw->CDB, fsg->cmnd_size);\r\nif (cbw->Flags & US_BULK_FLAG_IN)\r\nfsg->data_dir = DATA_DIR_TO_HOST;\r\nelse\r\nfsg->data_dir = DATA_DIR_FROM_HOST;\r\nfsg->data_size = le32_to_cpu(cbw->DataTransferLength);\r\nif (fsg->data_size == 0)\r\nfsg->data_dir = DATA_DIR_NONE;\r\nfsg->lun = cbw->Lun;\r\nfsg->tag = cbw->Tag;\r\nreturn 0;\r\n}\r\nstatic int get_next_command(struct fsg_dev *fsg)\r\n{\r\nstruct fsg_buffhd *bh;\r\nint rc = 0;\r\nif (transport_is_bbb()) {\r\nbh = fsg->next_buffhd_to_fill;\r\nwhile (bh->state != BUF_STATE_EMPTY) {\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nset_bulk_out_req_length(fsg, bh, US_BULK_CB_WRAP_LEN);\r\nstart_transfer(fsg, fsg->bulk_out, bh->outreq,\r\n&bh->outreq_busy, &bh->state);\r\nwhile (bh->state != BUF_STATE_FULL) {\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nsmp_rmb();\r\nrc = received_cbw(fsg, bh);\r\nbh->state = BUF_STATE_EMPTY;\r\n} else {\r\nwhile (fsg->cbbuf_cmnd_size == 0) {\r\nrc = sleep_thread(fsg);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (fsg->intreq_busy)\r\nusb_ep_dequeue(fsg->intr_in, fsg->intreq);\r\nfsg->data_dir = DATA_DIR_UNKNOWN;\r\nspin_lock_irq(&fsg->lock);\r\nfsg->cmnd_size = fsg->cbbuf_cmnd_size;\r\nmemcpy(fsg->cmnd, fsg->cbbuf_cmnd, fsg->cmnd_size);\r\nfsg->cbbuf_cmnd_size = 0;\r\nspin_unlock_irq(&fsg->lock);\r\nfsg->lun = fsg->cmnd[1] >> 5;\r\n}\r\nif (fsg->lun >= 0 && fsg->lun < fsg->nluns)\r\nfsg->curlun = &fsg->luns[fsg->lun];\r\nelse\r\nfsg->curlun = NULL;\r\nreturn rc;\r\n}\r\nstatic int enable_endpoint(struct fsg_dev *fsg, struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *d)\r\n{\r\nint rc;\r\nep->driver_data = fsg;\r\nep->desc = d;\r\nrc = usb_ep_enable(ep);\r\nif (rc)\r\nERROR(fsg, "can't enable %s, result %d\n", ep->name, rc);\r\nreturn rc;\r\n}\r\nstatic int alloc_request(struct fsg_dev *fsg, struct usb_ep *ep,\r\nstruct usb_request **preq)\r\n{\r\n*preq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (*preq)\r\nreturn 0;\r\nERROR(fsg, "can't allocate request for %s\n", ep->name);\r\nreturn -ENOMEM;\r\n}\r\nstatic int do_set_interface(struct fsg_dev *fsg, int altsetting)\r\n{\r\nint rc = 0;\r\nint i;\r\nconst struct usb_endpoint_descriptor *d;\r\nif (fsg->running)\r\nDBG(fsg, "reset interface\n");\r\nreset:\r\nfor (i = 0; i < fsg_num_buffers; ++i) {\r\nstruct fsg_buffhd *bh = &fsg->buffhds[i];\r\nif (bh->inreq) {\r\nusb_ep_free_request(fsg->bulk_in, bh->inreq);\r\nbh->inreq = NULL;\r\n}\r\nif (bh->outreq) {\r\nusb_ep_free_request(fsg->bulk_out, bh->outreq);\r\nbh->outreq = NULL;\r\n}\r\n}\r\nif (fsg->intreq) {\r\nusb_ep_free_request(fsg->intr_in, fsg->intreq);\r\nfsg->intreq = NULL;\r\n}\r\nif (fsg->bulk_in_enabled) {\r\nusb_ep_disable(fsg->bulk_in);\r\nfsg->bulk_in_enabled = 0;\r\n}\r\nif (fsg->bulk_out_enabled) {\r\nusb_ep_disable(fsg->bulk_out);\r\nfsg->bulk_out_enabled = 0;\r\n}\r\nif (fsg->intr_in_enabled) {\r\nusb_ep_disable(fsg->intr_in);\r\nfsg->intr_in_enabled = 0;\r\n}\r\nfsg->running = 0;\r\nif (altsetting < 0 || rc != 0)\r\nreturn rc;\r\nDBG(fsg, "set interface %d\n", altsetting);\r\nd = fsg_ep_desc(fsg->gadget,\r\n&fsg_fs_bulk_in_desc, &fsg_hs_bulk_in_desc,\r\n&fsg_ss_bulk_in_desc);\r\nif ((rc = enable_endpoint(fsg, fsg->bulk_in, d)) != 0)\r\ngoto reset;\r\nfsg->bulk_in_enabled = 1;\r\nd = fsg_ep_desc(fsg->gadget,\r\n&fsg_fs_bulk_out_desc, &fsg_hs_bulk_out_desc,\r\n&fsg_ss_bulk_out_desc);\r\nif ((rc = enable_endpoint(fsg, fsg->bulk_out, d)) != 0)\r\ngoto reset;\r\nfsg->bulk_out_enabled = 1;\r\nfsg->bulk_out_maxpacket = usb_endpoint_maxp(d);\r\nclear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);\r\nif (transport_is_cbi()) {\r\nd = fsg_ep_desc(fsg->gadget,\r\n&fsg_fs_intr_in_desc, &fsg_hs_intr_in_desc,\r\n&fsg_ss_intr_in_desc);\r\nif ((rc = enable_endpoint(fsg, fsg->intr_in, d)) != 0)\r\ngoto reset;\r\nfsg->intr_in_enabled = 1;\r\n}\r\nfor (i = 0; i < fsg_num_buffers; ++i) {\r\nstruct fsg_buffhd *bh = &fsg->buffhds[i];\r\nif ((rc = alloc_request(fsg, fsg->bulk_in, &bh->inreq)) != 0)\r\ngoto reset;\r\nif ((rc = alloc_request(fsg, fsg->bulk_out, &bh->outreq)) != 0)\r\ngoto reset;\r\nbh->inreq->buf = bh->outreq->buf = bh->buf;\r\nbh->inreq->context = bh->outreq->context = bh;\r\nbh->inreq->complete = bulk_in_complete;\r\nbh->outreq->complete = bulk_out_complete;\r\n}\r\nif (transport_is_cbi()) {\r\nif ((rc = alloc_request(fsg, fsg->intr_in, &fsg->intreq)) != 0)\r\ngoto reset;\r\nfsg->intreq->complete = intr_in_complete;\r\n}\r\nfsg->running = 1;\r\nfor (i = 0; i < fsg->nluns; ++i)\r\nfsg->luns[i].unit_attention_data = SS_RESET_OCCURRED;\r\nreturn rc;\r\n}\r\nstatic int do_set_config(struct fsg_dev *fsg, u8 new_config)\r\n{\r\nint rc = 0;\r\nif (fsg->config != 0) {\r\nDBG(fsg, "reset config\n");\r\nfsg->config = 0;\r\nrc = do_set_interface(fsg, -1);\r\n}\r\nif (new_config != 0) {\r\nfsg->config = new_config;\r\nif ((rc = do_set_interface(fsg, 0)) != 0)\r\nfsg->config = 0;\r\nelse\r\nINFO(fsg, "%s config #%d\n",\r\nusb_speed_string(fsg->gadget->speed),\r\nfsg->config);\r\n}\r\nreturn rc;\r\n}\r\nstatic void handle_exception(struct fsg_dev *fsg)\r\n{\r\nsiginfo_t info;\r\nint sig;\r\nint i;\r\nint num_active;\r\nstruct fsg_buffhd *bh;\r\nenum fsg_state old_state;\r\nu8 new_config;\r\nstruct fsg_lun *curlun;\r\nunsigned int exception_req_tag;\r\nint rc;\r\nfor (;;) {\r\nsig = dequeue_signal_lock(current, &current->blocked, &info);\r\nif (!sig)\r\nbreak;\r\nif (sig != SIGUSR1) {\r\nif (fsg->state < FSG_STATE_EXIT)\r\nDBG(fsg, "Main thread exiting on signal\n");\r\nraise_exception(fsg, FSG_STATE_EXIT);\r\n}\r\n}\r\nif (fsg->intreq_busy)\r\nusb_ep_dequeue(fsg->intr_in, fsg->intreq);\r\nfor (i = 0; i < fsg_num_buffers; ++i) {\r\nbh = &fsg->buffhds[i];\r\nif (bh->inreq_busy)\r\nusb_ep_dequeue(fsg->bulk_in, bh->inreq);\r\nif (bh->outreq_busy)\r\nusb_ep_dequeue(fsg->bulk_out, bh->outreq);\r\n}\r\nfor (;;) {\r\nnum_active = fsg->intreq_busy;\r\nfor (i = 0; i < fsg_num_buffers; ++i) {\r\nbh = &fsg->buffhds[i];\r\nnum_active += bh->inreq_busy + bh->outreq_busy;\r\n}\r\nif (num_active == 0)\r\nbreak;\r\nif (sleep_thread(fsg))\r\nreturn;\r\n}\r\nif (fsg->bulk_in_enabled)\r\nusb_ep_fifo_flush(fsg->bulk_in);\r\nif (fsg->bulk_out_enabled)\r\nusb_ep_fifo_flush(fsg->bulk_out);\r\nif (fsg->intr_in_enabled)\r\nusb_ep_fifo_flush(fsg->intr_in);\r\nspin_lock_irq(&fsg->lock);\r\nfor (i = 0; i < fsg_num_buffers; ++i) {\r\nbh = &fsg->buffhds[i];\r\nbh->state = BUF_STATE_EMPTY;\r\n}\r\nfsg->next_buffhd_to_fill = fsg->next_buffhd_to_drain =\r\n&fsg->buffhds[0];\r\nexception_req_tag = fsg->exception_req_tag;\r\nnew_config = fsg->new_config;\r\nold_state = fsg->state;\r\nif (old_state == FSG_STATE_ABORT_BULK_OUT)\r\nfsg->state = FSG_STATE_STATUS_PHASE;\r\nelse {\r\nfor (i = 0; i < fsg->nluns; ++i) {\r\ncurlun = &fsg->luns[i];\r\ncurlun->prevent_medium_removal = 0;\r\ncurlun->sense_data = curlun->unit_attention_data =\r\nSS_NO_SENSE;\r\ncurlun->sense_data_info = 0;\r\ncurlun->info_valid = 0;\r\n}\r\nfsg->state = FSG_STATE_IDLE;\r\n}\r\nspin_unlock_irq(&fsg->lock);\r\nswitch (old_state) {\r\ndefault:\r\nbreak;\r\ncase FSG_STATE_ABORT_BULK_OUT:\r\nsend_status(fsg);\r\nspin_lock_irq(&fsg->lock);\r\nif (fsg->state == FSG_STATE_STATUS_PHASE)\r\nfsg->state = FSG_STATE_IDLE;\r\nspin_unlock_irq(&fsg->lock);\r\nbreak;\r\ncase FSG_STATE_RESET:\r\nif (test_and_clear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags))\r\nusb_ep_clear_halt(fsg->bulk_in);\r\nif (transport_is_bbb()) {\r\nif (fsg->ep0_req_tag == exception_req_tag)\r\nep0_queue(fsg);\r\n} else if (transport_is_cbi())\r\nsend_status(fsg);\r\nbreak;\r\ncase FSG_STATE_INTERFACE_CHANGE:\r\nrc = do_set_interface(fsg, 0);\r\nif (fsg->ep0_req_tag != exception_req_tag)\r\nbreak;\r\nif (rc != 0)\r\nfsg_set_halt(fsg, fsg->ep0);\r\nelse\r\nep0_queue(fsg);\r\nbreak;\r\ncase FSG_STATE_CONFIG_CHANGE:\r\nrc = do_set_config(fsg, new_config);\r\nif (fsg->ep0_req_tag != exception_req_tag)\r\nbreak;\r\nif (rc != 0)\r\nfsg_set_halt(fsg, fsg->ep0);\r\nelse\r\nep0_queue(fsg);\r\nbreak;\r\ncase FSG_STATE_DISCONNECT:\r\nfor (i = 0; i < fsg->nluns; ++i)\r\nfsg_lun_fsync_sub(fsg->luns + i);\r\ndo_set_config(fsg, 0);\r\nbreak;\r\ncase FSG_STATE_EXIT:\r\ncase FSG_STATE_TERMINATED:\r\ndo_set_config(fsg, 0);\r\nspin_lock_irq(&fsg->lock);\r\nfsg->state = FSG_STATE_TERMINATED;\r\nspin_unlock_irq(&fsg->lock);\r\nbreak;\r\n}\r\n}\r\nstatic int fsg_main_thread(void *fsg_)\r\n{\r\nstruct fsg_dev *fsg = fsg_;\r\nallow_signal(SIGINT);\r\nallow_signal(SIGTERM);\r\nallow_signal(SIGKILL);\r\nallow_signal(SIGUSR1);\r\nset_freezable();\r\nset_fs(get_ds());\r\nwhile (fsg->state != FSG_STATE_TERMINATED) {\r\nif (exception_in_progress(fsg) || signal_pending(current)) {\r\nhandle_exception(fsg);\r\ncontinue;\r\n}\r\nif (!fsg->running) {\r\nsleep_thread(fsg);\r\ncontinue;\r\n}\r\nif (get_next_command(fsg))\r\ncontinue;\r\nspin_lock_irq(&fsg->lock);\r\nif (!exception_in_progress(fsg))\r\nfsg->state = FSG_STATE_DATA_PHASE;\r\nspin_unlock_irq(&fsg->lock);\r\nif (do_scsi_command(fsg) || finish_reply(fsg))\r\ncontinue;\r\nspin_lock_irq(&fsg->lock);\r\nif (!exception_in_progress(fsg))\r\nfsg->state = FSG_STATE_STATUS_PHASE;\r\nspin_unlock_irq(&fsg->lock);\r\nif (send_status(fsg))\r\ncontinue;\r\nspin_lock_irq(&fsg->lock);\r\nif (!exception_in_progress(fsg))\r\nfsg->state = FSG_STATE_IDLE;\r\nspin_unlock_irq(&fsg->lock);\r\n}\r\nspin_lock_irq(&fsg->lock);\r\nfsg->thread_task = NULL;\r\nspin_unlock_irq(&fsg->lock);\r\nif (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags))\r\nusb_gadget_unregister_driver(&fsg_driver);\r\ncomplete_and_exit(&fsg->thread_notifier, 0);\r\n}\r\nstatic void fsg_release(struct kref *ref)\r\n{\r\nstruct fsg_dev *fsg = container_of(ref, struct fsg_dev, ref);\r\nkfree(fsg->luns);\r\nkfree(fsg);\r\n}\r\nstatic void lun_release(struct device *dev)\r\n{\r\nstruct rw_semaphore *filesem = dev_get_drvdata(dev);\r\nstruct fsg_dev *fsg =\r\ncontainer_of(filesem, struct fsg_dev, filesem);\r\nkref_put(&fsg->ref, fsg_release);\r\n}\r\nstatic void fsg_unbind(struct usb_gadget *gadget)\r\n{\r\nstruct fsg_dev *fsg = get_gadget_data(gadget);\r\nint i;\r\nstruct fsg_lun *curlun;\r\nstruct usb_request *req = fsg->ep0req;\r\nDBG(fsg, "unbind\n");\r\nclear_bit(REGISTERED, &fsg->atomic_bitflags);\r\nif (fsg->state != FSG_STATE_TERMINATED) {\r\nraise_exception(fsg, FSG_STATE_EXIT);\r\nwait_for_completion(&fsg->thread_notifier);\r\ncomplete(&fsg->thread_notifier);\r\n}\r\nfor (i = 0; i < fsg->nluns; ++i) {\r\ncurlun = &fsg->luns[i];\r\nif (curlun->registered) {\r\ndevice_remove_file(&curlun->dev, &dev_attr_nofua);\r\ndevice_remove_file(&curlun->dev, &dev_attr_ro);\r\ndevice_remove_file(&curlun->dev, &dev_attr_file);\r\nfsg_lun_close(curlun);\r\ndevice_unregister(&curlun->dev);\r\ncurlun->registered = 0;\r\n}\r\n}\r\nfor (i = 0; i < fsg_num_buffers; ++i)\r\nkfree(fsg->buffhds[i].buf);\r\nif (req) {\r\nkfree(req->buf);\r\nusb_ep_free_request(fsg->ep0, req);\r\n}\r\nset_gadget_data(gadget, NULL);\r\n}\r\nstatic int __init check_parameters(struct fsg_dev *fsg)\r\n{\r\nint prot;\r\nint gcnum;\r\nmod_data.transport_type = USB_PR_BULK;\r\nmod_data.transport_name = "Bulk-only";\r\nmod_data.protocol_type = USB_SC_SCSI;\r\nmod_data.protocol_name = "Transparent SCSI";\r\nif (gadget_is_at91(fsg->gadget))\r\nmod_data.can_stall = 0;\r\nif (mod_data.release == 0xffff) {\r\ngcnum = usb_gadget_controller_number(fsg->gadget);\r\nif (gcnum >= 0)\r\nmod_data.release = 0x0300 + gcnum;\r\nelse {\r\nWARNING(fsg, "controller '%s' not recognized\n",\r\nfsg->gadget->name);\r\nmod_data.release = 0x0399;\r\n}\r\n}\r\nprot = simple_strtol(mod_data.protocol_parm, NULL, 0);\r\n#ifdef CONFIG_USB_FILE_STORAGE_TEST\r\nif (strnicmp(mod_data.transport_parm, "BBB", 10) == 0) {\r\n;\r\n} else if (strnicmp(mod_data.transport_parm, "CB", 10) == 0) {\r\nmod_data.transport_type = USB_PR_CB;\r\nmod_data.transport_name = "Control-Bulk";\r\n} else if (strnicmp(mod_data.transport_parm, "CBI", 10) == 0) {\r\nmod_data.transport_type = USB_PR_CBI;\r\nmod_data.transport_name = "Control-Bulk-Interrupt";\r\n} else {\r\nERROR(fsg, "invalid transport: %s\n", mod_data.transport_parm);\r\nreturn -EINVAL;\r\n}\r\nif (strnicmp(mod_data.protocol_parm, "SCSI", 10) == 0 ||\r\nprot == USB_SC_SCSI) {\r\n;\r\n} else if (strnicmp(mod_data.protocol_parm, "RBC", 10) == 0 ||\r\nprot == USB_SC_RBC) {\r\nmod_data.protocol_type = USB_SC_RBC;\r\nmod_data.protocol_name = "RBC";\r\n} else if (strnicmp(mod_data.protocol_parm, "8020", 4) == 0 ||\r\nstrnicmp(mod_data.protocol_parm, "ATAPI", 10) == 0 ||\r\nprot == USB_SC_8020) {\r\nmod_data.protocol_type = USB_SC_8020;\r\nmod_data.protocol_name = "8020i (ATAPI)";\r\n} else if (strnicmp(mod_data.protocol_parm, "QIC", 3) == 0 ||\r\nprot == USB_SC_QIC) {\r\nmod_data.protocol_type = USB_SC_QIC;\r\nmod_data.protocol_name = "QIC-157";\r\n} else if (strnicmp(mod_data.protocol_parm, "UFI", 10) == 0 ||\r\nprot == USB_SC_UFI) {\r\nmod_data.protocol_type = USB_SC_UFI;\r\nmod_data.protocol_name = "UFI";\r\n} else if (strnicmp(mod_data.protocol_parm, "8070", 4) == 0 ||\r\nprot == USB_SC_8070) {\r\nmod_data.protocol_type = USB_SC_8070;\r\nmod_data.protocol_name = "8070i";\r\n} else {\r\nERROR(fsg, "invalid protocol: %s\n", mod_data.protocol_parm);\r\nreturn -EINVAL;\r\n}\r\nmod_data.buflen &= PAGE_CACHE_MASK;\r\nif (mod_data.buflen <= 0) {\r\nERROR(fsg, "invalid buflen\n");\r\nreturn -ETOOSMALL;\r\n}\r\n#endif\r\nif (mod_data.serial) {\r\nconst char *ch;\r\nunsigned len = 0;\r\nfor (ch = mod_data.serial; *ch; ++ch) {\r\n++len;\r\nif ((*ch < '0' || *ch > '9') &&\r\n(*ch < 'A' || *ch > 'F')) {\r\nWARNING(fsg,\r\n"Invalid serial string character: %c\n",\r\n*ch);\r\ngoto no_serial;\r\n}\r\n}\r\nif (len > 126 ||\r\n(mod_data.transport_type == USB_PR_BULK && len < 12) ||\r\n(mod_data.transport_type != USB_PR_BULK && len > 12)) {\r\nWARNING(fsg, "Invalid serial string length!\n");\r\ngoto no_serial;\r\n}\r\nfsg_strings[FSG_STRING_SERIAL - 1].s = mod_data.serial;\r\n} else {\r\nWARNING(fsg, "No serial-number string provided!\n");\r\nno_serial:\r\ndevice_desc.iSerialNumber = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init fsg_bind(struct usb_gadget *gadget)\r\n{\r\nstruct fsg_dev *fsg = the_fsg;\r\nint rc;\r\nint i;\r\nstruct fsg_lun *curlun;\r\nstruct usb_ep *ep;\r\nstruct usb_request *req;\r\nchar *pathbuf, *p;\r\nfsg->gadget = gadget;\r\nset_gadget_data(gadget, fsg);\r\nfsg->ep0 = gadget->ep0;\r\nfsg->ep0->driver_data = fsg;\r\nif ((rc = check_parameters(fsg)) != 0)\r\ngoto out;\r\nif (mod_data.removable) {\r\ndev_attr_file.attr.mode = 0644;\r\ndev_attr_file.store = fsg_store_file;\r\nif (!mod_data.cdrom) {\r\ndev_attr_ro.attr.mode = 0644;\r\ndev_attr_ro.store = fsg_store_ro;\r\n}\r\n}\r\ndev_attr_nofua.attr.mode = 0644;\r\ndev_attr_nofua.store = fsg_store_nofua;\r\ni = mod_data.nluns;\r\nif (i == 0)\r\ni = max(mod_data.num_filenames, 1u);\r\nif (i > FSG_MAX_LUNS) {\r\nERROR(fsg, "invalid number of LUNs: %d\n", i);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nfsg->luns = kzalloc(i * sizeof(struct fsg_lun), GFP_KERNEL);\r\nif (!fsg->luns) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfsg->nluns = i;\r\nfor (i = 0; i < fsg->nluns; ++i) {\r\ncurlun = &fsg->luns[i];\r\ncurlun->cdrom = !!mod_data.cdrom;\r\ncurlun->ro = mod_data.cdrom || mod_data.ro[i];\r\ncurlun->initially_ro = curlun->ro;\r\ncurlun->removable = mod_data.removable;\r\ncurlun->nofua = mod_data.nofua[i];\r\ncurlun->dev.release = lun_release;\r\ncurlun->dev.parent = &gadget->dev;\r\ncurlun->dev.driver = &fsg_driver.driver;\r\ndev_set_drvdata(&curlun->dev, &fsg->filesem);\r\ndev_set_name(&curlun->dev,"%s-lun%d",\r\ndev_name(&gadget->dev), i);\r\nkref_get(&fsg->ref);\r\nrc = device_register(&curlun->dev);\r\nif (rc) {\r\nINFO(fsg, "failed to register LUN%d: %d\n", i, rc);\r\nput_device(&curlun->dev);\r\ngoto out;\r\n}\r\ncurlun->registered = 1;\r\nrc = device_create_file(&curlun->dev, &dev_attr_ro);\r\nif (rc)\r\ngoto out;\r\nrc = device_create_file(&curlun->dev, &dev_attr_nofua);\r\nif (rc)\r\ngoto out;\r\nrc = device_create_file(&curlun->dev, &dev_attr_file);\r\nif (rc)\r\ngoto out;\r\nif (mod_data.file[i] && *mod_data.file[i]) {\r\nrc = fsg_lun_open(curlun, mod_data.file[i]);\r\nif (rc)\r\ngoto out;\r\n} else if (!mod_data.removable) {\r\nERROR(fsg, "no file given for LUN%d\n", i);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nusb_ep_autoconfig_reset(gadget);\r\nep = usb_ep_autoconfig(gadget, &fsg_fs_bulk_in_desc);\r\nif (!ep)\r\ngoto autoconf_fail;\r\nep->driver_data = fsg;\r\nfsg->bulk_in = ep;\r\nep = usb_ep_autoconfig(gadget, &fsg_fs_bulk_out_desc);\r\nif (!ep)\r\ngoto autoconf_fail;\r\nep->driver_data = fsg;\r\nfsg->bulk_out = ep;\r\nif (transport_is_cbi()) {\r\nep = usb_ep_autoconfig(gadget, &fsg_fs_intr_in_desc);\r\nif (!ep)\r\ngoto autoconf_fail;\r\nep->driver_data = fsg;\r\nfsg->intr_in = ep;\r\n}\r\ndevice_desc.idVendor = cpu_to_le16(mod_data.vendor);\r\ndevice_desc.idProduct = cpu_to_le16(mod_data.product);\r\ndevice_desc.bcdDevice = cpu_to_le16(mod_data.release);\r\ni = (transport_is_cbi() ? 3 : 2);\r\nfsg_intf_desc.bNumEndpoints = i;\r\nfsg_intf_desc.bInterfaceSubClass = mod_data.protocol_type;\r\nfsg_intf_desc.bInterfaceProtocol = mod_data.transport_type;\r\nfsg_fs_function[i + FSG_FS_FUNCTION_PRE_EP_ENTRIES] = NULL;\r\nif (gadget_is_dualspeed(gadget)) {\r\nfsg_hs_function[i + FSG_HS_FUNCTION_PRE_EP_ENTRIES] = NULL;\r\nfsg_hs_bulk_in_desc.bEndpointAddress =\r\nfsg_fs_bulk_in_desc.bEndpointAddress;\r\nfsg_hs_bulk_out_desc.bEndpointAddress =\r\nfsg_fs_bulk_out_desc.bEndpointAddress;\r\nfsg_hs_intr_in_desc.bEndpointAddress =\r\nfsg_fs_intr_in_desc.bEndpointAddress;\r\n}\r\nif (gadget_is_superspeed(gadget)) {\r\nunsigned max_burst;\r\nfsg_ss_function[i + FSG_SS_FUNCTION_PRE_EP_ENTRIES] = NULL;\r\nmax_burst = min_t(unsigned, mod_data.buflen / 1024, 15);\r\nfsg_ss_bulk_in_desc.bEndpointAddress =\r\nfsg_fs_bulk_in_desc.bEndpointAddress;\r\nfsg_ss_bulk_in_comp_desc.bMaxBurst = max_burst;\r\nfsg_ss_bulk_out_desc.bEndpointAddress =\r\nfsg_fs_bulk_out_desc.bEndpointAddress;\r\nfsg_ss_bulk_out_comp_desc.bMaxBurst = max_burst;\r\n}\r\nif (gadget_is_otg(gadget))\r\nfsg_otg_desc.bmAttributes |= USB_OTG_HNP;\r\nrc = -ENOMEM;\r\nfsg->ep0req = req = usb_ep_alloc_request(fsg->ep0, GFP_KERNEL);\r\nif (!req)\r\ngoto out;\r\nreq->buf = kmalloc(EP0_BUFSIZE, GFP_KERNEL);\r\nif (!req->buf)\r\ngoto out;\r\nreq->complete = ep0_complete;\r\nfor (i = 0; i < fsg_num_buffers; ++i) {\r\nstruct fsg_buffhd *bh = &fsg->buffhds[i];\r\nbh->buf = kmalloc(mod_data.buflen, GFP_KERNEL);\r\nif (!bh->buf)\r\ngoto out;\r\nbh->next = bh + 1;\r\n}\r\nfsg->buffhds[fsg_num_buffers - 1].next = &fsg->buffhds[0];\r\nusb_gadget_set_selfpowered(gadget);\r\nsnprintf(fsg_string_manufacturer, sizeof fsg_string_manufacturer,\r\n"%s %s with %s",\r\ninit_utsname()->sysname, init_utsname()->release,\r\ngadget->name);\r\nfsg->thread_task = kthread_create(fsg_main_thread, fsg,\r\n"file-storage-gadget");\r\nif (IS_ERR(fsg->thread_task)) {\r\nrc = PTR_ERR(fsg->thread_task);\r\ngoto out;\r\n}\r\nINFO(fsg, DRIVER_DESC ", version: " DRIVER_VERSION "\n");\r\nINFO(fsg, "NOTE: This driver is deprecated. "\r\n"Consider using g_mass_storage instead.\n");\r\nINFO(fsg, "Number of LUNs=%d\n", fsg->nluns);\r\npathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\r\nfor (i = 0; i < fsg->nluns; ++i) {\r\ncurlun = &fsg->luns[i];\r\nif (fsg_lun_is_open(curlun)) {\r\np = NULL;\r\nif (pathbuf) {\r\np = d_path(&curlun->filp->f_path,\r\npathbuf, PATH_MAX);\r\nif (IS_ERR(p))\r\np = NULL;\r\n}\r\nLINFO(curlun, "ro=%d, nofua=%d, file: %s\n",\r\ncurlun->ro, curlun->nofua, (p ? p : "(error)"));\r\n}\r\n}\r\nkfree(pathbuf);\r\nDBG(fsg, "transport=%s (x%02x)\n",\r\nmod_data.transport_name, mod_data.transport_type);\r\nDBG(fsg, "protocol=%s (x%02x)\n",\r\nmod_data.protocol_name, mod_data.protocol_type);\r\nDBG(fsg, "VendorID=x%04x, ProductID=x%04x, Release=x%04x\n",\r\nmod_data.vendor, mod_data.product, mod_data.release);\r\nDBG(fsg, "removable=%d, stall=%d, cdrom=%d, buflen=%u\n",\r\nmod_data.removable, mod_data.can_stall,\r\nmod_data.cdrom, mod_data.buflen);\r\nDBG(fsg, "I/O thread pid: %d\n", task_pid_nr(fsg->thread_task));\r\nset_bit(REGISTERED, &fsg->atomic_bitflags);\r\nwake_up_process(fsg->thread_task);\r\nreturn 0;\r\nautoconf_fail:\r\nERROR(fsg, "unable to autoconfigure all endpoints\n");\r\nrc = -ENOTSUPP;\r\nout:\r\nfsg->state = FSG_STATE_TERMINATED;\r\nfsg_unbind(gadget);\r\ncomplete(&fsg->thread_notifier);\r\nreturn rc;\r\n}\r\nstatic void fsg_suspend(struct usb_gadget *gadget)\r\n{\r\nstruct fsg_dev *fsg = get_gadget_data(gadget);\r\nDBG(fsg, "suspend\n");\r\nset_bit(SUSPENDED, &fsg->atomic_bitflags);\r\n}\r\nstatic void fsg_resume(struct usb_gadget *gadget)\r\n{\r\nstruct fsg_dev *fsg = get_gadget_data(gadget);\r\nDBG(fsg, "resume\n");\r\nclear_bit(SUSPENDED, &fsg->atomic_bitflags);\r\n}\r\nstatic int __init fsg_alloc(void)\r\n{\r\nstruct fsg_dev *fsg;\r\nfsg = kzalloc(sizeof *fsg +\r\nfsg_num_buffers * sizeof *(fsg->buffhds), GFP_KERNEL);\r\nif (!fsg)\r\nreturn -ENOMEM;\r\nspin_lock_init(&fsg->lock);\r\ninit_rwsem(&fsg->filesem);\r\nkref_init(&fsg->ref);\r\ninit_completion(&fsg->thread_notifier);\r\nthe_fsg = fsg;\r\nreturn 0;\r\n}\r\nstatic int __init fsg_init(void)\r\n{\r\nint rc;\r\nstruct fsg_dev *fsg;\r\nrc = fsg_num_buffers_validate();\r\nif (rc != 0)\r\nreturn rc;\r\nif ((rc = fsg_alloc()) != 0)\r\nreturn rc;\r\nfsg = the_fsg;\r\nif ((rc = usb_gadget_probe_driver(&fsg_driver, fsg_bind)) != 0)\r\nkref_put(&fsg->ref, fsg_release);\r\nreturn rc;\r\n}\r\nstatic void __exit fsg_cleanup(void)\r\n{\r\nstruct fsg_dev *fsg = the_fsg;\r\nif (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags))\r\nusb_gadget_unregister_driver(&fsg_driver);\r\nwait_for_completion(&fsg->thread_notifier);\r\nkref_put(&fsg->ref, fsg_release);\r\n}
