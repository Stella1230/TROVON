static inline unsigned short\r\nget_unaligned16(const unsigned short *p)\r\n{\r\nunion uu mm;\r\nunsigned char *b = (unsigned char *)p;\r\nmm.b[0] = b[0];\r\nmm.b[1] = b[1];\r\nreturn mm.us;\r\n}\r\nvoid inflate_fast(z_streamp strm, unsigned start)\r\n{\r\nstruct inflate_state *state;\r\nconst unsigned char *in;\r\nconst unsigned char *last;\r\nunsigned char *out;\r\nunsigned char *beg;\r\nunsigned char *end;\r\n#ifdef INFLATE_STRICT\r\nunsigned dmax;\r\n#endif\r\nunsigned wsize;\r\nunsigned whave;\r\nunsigned write;\r\nunsigned char *window;\r\nunsigned long hold;\r\nunsigned bits;\r\ncode const *lcode;\r\ncode const *dcode;\r\nunsigned lmask;\r\nunsigned dmask;\r\ncode this;\r\nunsigned op;\r\nunsigned len;\r\nunsigned dist;\r\nunsigned char *from;\r\nstate = (struct inflate_state *)strm->state;\r\nin = strm->next_in - OFF;\r\nlast = in + (strm->avail_in - 5);\r\nout = strm->next_out - OFF;\r\nbeg = out - (start - strm->avail_out);\r\nend = out + (strm->avail_out - 257);\r\n#ifdef INFLATE_STRICT\r\ndmax = state->dmax;\r\n#endif\r\nwsize = state->wsize;\r\nwhave = state->whave;\r\nwrite = state->write;\r\nwindow = state->window;\r\nhold = state->hold;\r\nbits = state->bits;\r\nlcode = state->lencode;\r\ndcode = state->distcode;\r\nlmask = (1U << state->lenbits) - 1;\r\ndmask = (1U << state->distbits) - 1;\r\ndo {\r\nif (bits < 15) {\r\nhold += (unsigned long)(PUP(in)) << bits;\r\nbits += 8;\r\nhold += (unsigned long)(PUP(in)) << bits;\r\nbits += 8;\r\n}\r\nthis = lcode[hold & lmask];\r\ndolen:\r\nop = (unsigned)(this.bits);\r\nhold >>= op;\r\nbits -= op;\r\nop = (unsigned)(this.op);\r\nif (op == 0) {\r\nPUP(out) = (unsigned char)(this.val);\r\n}\r\nelse if (op & 16) {\r\nlen = (unsigned)(this.val);\r\nop &= 15;\r\nif (op) {\r\nif (bits < op) {\r\nhold += (unsigned long)(PUP(in)) << bits;\r\nbits += 8;\r\n}\r\nlen += (unsigned)hold & ((1U << op) - 1);\r\nhold >>= op;\r\nbits -= op;\r\n}\r\nif (bits < 15) {\r\nhold += (unsigned long)(PUP(in)) << bits;\r\nbits += 8;\r\nhold += (unsigned long)(PUP(in)) << bits;\r\nbits += 8;\r\n}\r\nthis = dcode[hold & dmask];\r\ndodist:\r\nop = (unsigned)(this.bits);\r\nhold >>= op;\r\nbits -= op;\r\nop = (unsigned)(this.op);\r\nif (op & 16) {\r\ndist = (unsigned)(this.val);\r\nop &= 15;\r\nif (bits < op) {\r\nhold += (unsigned long)(PUP(in)) << bits;\r\nbits += 8;\r\nif (bits < op) {\r\nhold += (unsigned long)(PUP(in)) << bits;\r\nbits += 8;\r\n}\r\n}\r\ndist += (unsigned)hold & ((1U << op) - 1);\r\n#ifdef INFLATE_STRICT\r\nif (dist > dmax) {\r\nstrm->msg = (char *)"invalid distance too far back";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\n#endif\r\nhold >>= op;\r\nbits -= op;\r\nop = (unsigned)(out - beg);\r\nif (dist > op) {\r\nop = dist - op;\r\nif (op > whave) {\r\nstrm->msg = (char *)"invalid distance too far back";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nfrom = window - OFF;\r\nif (write == 0) {\r\nfrom += wsize - op;\r\nif (op < len) {\r\nlen -= op;\r\ndo {\r\nPUP(out) = PUP(from);\r\n} while (--op);\r\nfrom = out - dist;\r\n}\r\n}\r\nelse if (write < op) {\r\nfrom += wsize + write - op;\r\nop -= write;\r\nif (op < len) {\r\nlen -= op;\r\ndo {\r\nPUP(out) = PUP(from);\r\n} while (--op);\r\nfrom = window - OFF;\r\nif (write < len) {\r\nop = write;\r\nlen -= op;\r\ndo {\r\nPUP(out) = PUP(from);\r\n} while (--op);\r\nfrom = out - dist;\r\n}\r\n}\r\n}\r\nelse {\r\nfrom += write - op;\r\nif (op < len) {\r\nlen -= op;\r\ndo {\r\nPUP(out) = PUP(from);\r\n} while (--op);\r\nfrom = out - dist;\r\n}\r\n}\r\nwhile (len > 2) {\r\nPUP(out) = PUP(from);\r\nPUP(out) = PUP(from);\r\nPUP(out) = PUP(from);\r\nlen -= 3;\r\n}\r\nif (len) {\r\nPUP(out) = PUP(from);\r\nif (len > 1)\r\nPUP(out) = PUP(from);\r\n}\r\n}\r\nelse {\r\nunsigned short *sout;\r\nunsigned long loops;\r\nfrom = out - dist;\r\nif (!((long)(out - 1 + OFF) & 1)) {\r\nPUP(out) = PUP(from);\r\nlen--;\r\n}\r\nsout = (unsigned short *)(out - OFF);\r\nif (dist > 2) {\r\nunsigned short *sfrom;\r\nsfrom = (unsigned short *)(from - OFF);\r\nloops = len >> 1;\r\ndo\r\n#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\r\nPUP(sout) = PUP(sfrom);\r\n#else\r\nPUP(sout) = UP_UNALIGNED(sfrom);\r\n#endif\r\nwhile (--loops);\r\nout = (unsigned char *)sout + OFF;\r\nfrom = (unsigned char *)sfrom + OFF;\r\n} else {\r\nunsigned short pat16;\r\npat16 = *(sout-1+OFF);\r\nif (dist == 1) {\r\nunion uu mm;\r\nmm.us = pat16;\r\nmm.b[0] = mm.b[1];\r\npat16 = mm.us;\r\n}\r\nloops = len >> 1;\r\ndo\r\nPUP(sout) = pat16;\r\nwhile (--loops);\r\nout = (unsigned char *)sout + OFF;\r\n}\r\nif (len & 1)\r\nPUP(out) = PUP(from);\r\n}\r\n}\r\nelse if ((op & 64) == 0
