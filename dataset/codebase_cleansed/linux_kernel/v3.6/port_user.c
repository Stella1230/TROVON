static void *port_init(char *str, int device, const struct chan_opts *opts)\r\n{\r\nstruct port_chan *data;\r\nvoid *kern_data;\r\nchar *end;\r\nint port;\r\nif (*str != ':') {\r\nprintk(UM_KERN_ERR "port_init : channel type 'port' must "\r\n"specify a port number\n");\r\nreturn NULL;\r\n}\r\nstr++;\r\nport = strtoul(str, &end, 0);\r\nif ((*end != '\0') || (end == str)) {\r\nprintk(UM_KERN_ERR "port_init : couldn't parse port '%s'\n",\r\nstr);\r\nreturn NULL;\r\n}\r\nkern_data = port_data(port);\r\nif (kern_data == NULL)\r\nreturn NULL;\r\ndata = uml_kmalloc(sizeof(*data), UM_GFP_KERNEL);\r\nif (data == NULL)\r\ngoto err;\r\n*data = ((struct port_chan) { .raw = opts->raw,\r\n.kernel_data = kern_data });\r\nsprintf(data->dev, "%d", port);\r\nreturn data;\r\nerr:\r\nport_kern_free(kern_data);\r\nreturn NULL;\r\n}\r\nstatic void port_free(void *d)\r\n{\r\nstruct port_chan *data = d;\r\nport_kern_free(data->kernel_data);\r\nkfree(data);\r\n}\r\nstatic int port_open(int input, int output, int primary, void *d,\r\nchar **dev_out)\r\n{\r\nstruct port_chan *data = d;\r\nint fd, err;\r\nfd = port_wait(data->kernel_data);\r\nif ((fd >= 0) && data->raw) {\r\nCATCH_EINTR(err = tcgetattr(fd, &data->tt));\r\nif (err)\r\nreturn err;\r\nerr = raw(fd);\r\nif (err)\r\nreturn err;\r\n}\r\n*dev_out = data->dev;\r\nreturn fd;\r\n}\r\nstatic void port_close(int fd, void *d)\r\n{\r\nstruct port_chan *data = d;\r\nport_remove_dev(data->kernel_data);\r\nos_close_file(fd);\r\n}\r\nint port_listen_fd(int port)\r\n{\r\nstruct sockaddr_in addr;\r\nint fd, err, arg;\r\nfd = socket(PF_INET, SOCK_STREAM, 0);\r\nif (fd == -1)\r\nreturn -errno;\r\narg = 1;\r\nif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &arg, sizeof(arg)) < 0) {\r\nerr = -errno;\r\ngoto out;\r\n}\r\naddr.sin_family = AF_INET;\r\naddr.sin_port = htons(port);\r\naddr.sin_addr.s_addr = htonl(INADDR_ANY);\r\nif (bind(fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\r\nerr = -errno;\r\ngoto out;\r\n}\r\nif (listen(fd, 1) < 0) {\r\nerr = -errno;\r\ngoto out;\r\n}\r\nerr = os_set_fd_block(fd, 0);\r\nif (err < 0)\r\ngoto out;\r\nreturn fd;\r\nout:\r\nclose(fd);\r\nreturn err;\r\n}\r\nstatic void port_pre_exec(void *arg)\r\n{\r\nstruct port_pre_exec_data *data = arg;\r\ndup2(data->sock_fd, 0);\r\ndup2(data->sock_fd, 1);\r\ndup2(data->sock_fd, 2);\r\nclose(data->sock_fd);\r\ndup2(data->pipe_fd, 3);\r\nshutdown(3, SHUT_RD);\r\nclose(data->pipe_fd);\r\n}\r\nint port_connection(int fd, int *socket, int *pid_out)\r\n{\r\nint new, err;\r\nchar *argv[] = { "/usr/sbin/in.telnetd", "-L",\r\n"/usr/lib/uml/port-helper", NULL };\r\nstruct port_pre_exec_data data;\r\nnew = accept(fd, NULL, 0);\r\nif (new < 0)\r\nreturn -errno;\r\nerr = os_pipe(socket, 0, 0);\r\nif (err < 0)\r\ngoto out_close;\r\ndata = ((struct port_pre_exec_data)\r\n{ .sock_fd = new,\r\n.pipe_fd = socket[1] });\r\nerr = run_helper(port_pre_exec, &data, argv);\r\nif (err < 0)\r\ngoto out_shutdown;\r\n*pid_out = err;\r\nreturn new;\r\nout_shutdown:\r\nshutdown(socket[0], SHUT_RDWR);\r\nclose(socket[0]);\r\nshutdown(socket[1], SHUT_RDWR);\r\nclose(socket[1]);\r\nout_close:\r\nclose(new);\r\nreturn err;\r\n}
