static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\r\n{\r\nreturn container_of(s, struct dev_cgroup, css);\r\n}\r\nstatic inline struct dev_cgroup *cgroup_to_devcgroup(struct cgroup *cgroup)\r\n{\r\nreturn css_to_devcgroup(cgroup_subsys_state(cgroup, devices_subsys_id));\r\n}\r\nstatic inline struct dev_cgroup *task_devcgroup(struct task_struct *task)\r\n{\r\nreturn css_to_devcgroup(task_subsys_state(task, devices_subsys_id));\r\n}\r\nstatic int devcgroup_can_attach(struct cgroup *new_cgrp,\r\nstruct cgroup_taskset *set)\r\n{\r\nstruct task_struct *task = cgroup_taskset_first(set);\r\nif (current != task && !capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int dev_whitelist_copy(struct list_head *dest, struct list_head *orig)\r\n{\r\nstruct dev_whitelist_item *wh, *tmp, *new;\r\nlist_for_each_entry(wh, orig, list) {\r\nnew = kmemdup(wh, sizeof(*wh), GFP_KERNEL);\r\nif (!new)\r\ngoto free_and_exit;\r\nlist_add_tail(&new->list, dest);\r\n}\r\nreturn 0;\r\nfree_and_exit:\r\nlist_for_each_entry_safe(wh, tmp, dest, list) {\r\nlist_del(&wh->list);\r\nkfree(wh);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int dev_whitelist_add(struct dev_cgroup *dev_cgroup,\r\nstruct dev_whitelist_item *wh)\r\n{\r\nstruct dev_whitelist_item *whcopy, *walk;\r\nwhcopy = kmemdup(wh, sizeof(*wh), GFP_KERNEL);\r\nif (!whcopy)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(walk, &dev_cgroup->whitelist, list) {\r\nif (walk->type != wh->type)\r\ncontinue;\r\nif (walk->major != wh->major)\r\ncontinue;\r\nif (walk->minor != wh->minor)\r\ncontinue;\r\nwalk->access |= wh->access;\r\nkfree(whcopy);\r\nwhcopy = NULL;\r\n}\r\nif (whcopy != NULL)\r\nlist_add_tail_rcu(&whcopy->list, &dev_cgroup->whitelist);\r\nreturn 0;\r\n}\r\nstatic void dev_whitelist_rm(struct dev_cgroup *dev_cgroup,\r\nstruct dev_whitelist_item *wh)\r\n{\r\nstruct dev_whitelist_item *walk, *tmp;\r\nlist_for_each_entry_safe(walk, tmp, &dev_cgroup->whitelist, list) {\r\nif (walk->type == DEV_ALL)\r\ngoto remove;\r\nif (walk->type != wh->type)\r\ncontinue;\r\nif (walk->major != ~0 && walk->major != wh->major)\r\ncontinue;\r\nif (walk->minor != ~0 && walk->minor != wh->minor)\r\ncontinue;\r\nremove:\r\nwalk->access &= ~wh->access;\r\nif (!walk->access) {\r\nlist_del_rcu(&walk->list);\r\nkfree_rcu(walk, rcu);\r\n}\r\n}\r\n}\r\nstatic struct cgroup_subsys_state *devcgroup_create(struct cgroup *cgroup)\r\n{\r\nstruct dev_cgroup *dev_cgroup, *parent_dev_cgroup;\r\nstruct cgroup *parent_cgroup;\r\nint ret;\r\ndev_cgroup = kzalloc(sizeof(*dev_cgroup), GFP_KERNEL);\r\nif (!dev_cgroup)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&dev_cgroup->whitelist);\r\nparent_cgroup = cgroup->parent;\r\nif (parent_cgroup == NULL) {\r\nstruct dev_whitelist_item *wh;\r\nwh = kmalloc(sizeof(*wh), GFP_KERNEL);\r\nif (!wh) {\r\nkfree(dev_cgroup);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nwh->minor = wh->major = ~0;\r\nwh->type = DEV_ALL;\r\nwh->access = ACC_MASK;\r\nlist_add(&wh->list, &dev_cgroup->whitelist);\r\n} else {\r\nparent_dev_cgroup = cgroup_to_devcgroup(parent_cgroup);\r\nmutex_lock(&devcgroup_mutex);\r\nret = dev_whitelist_copy(&dev_cgroup->whitelist,\r\n&parent_dev_cgroup->whitelist);\r\nmutex_unlock(&devcgroup_mutex);\r\nif (ret) {\r\nkfree(dev_cgroup);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\nreturn &dev_cgroup->css;\r\n}\r\nstatic void devcgroup_destroy(struct cgroup *cgroup)\r\n{\r\nstruct dev_cgroup *dev_cgroup;\r\nstruct dev_whitelist_item *wh, *tmp;\r\ndev_cgroup = cgroup_to_devcgroup(cgroup);\r\nlist_for_each_entry_safe(wh, tmp, &dev_cgroup->whitelist, list) {\r\nlist_del(&wh->list);\r\nkfree(wh);\r\n}\r\nkfree(dev_cgroup);\r\n}\r\nstatic void set_access(char *acc, short access)\r\n{\r\nint idx = 0;\r\nmemset(acc, 0, ACCLEN);\r\nif (access & ACC_READ)\r\nacc[idx++] = 'r';\r\nif (access & ACC_WRITE)\r\nacc[idx++] = 'w';\r\nif (access & ACC_MKNOD)\r\nacc[idx++] = 'm';\r\n}\r\nstatic char type_to_char(short type)\r\n{\r\nif (type == DEV_ALL)\r\nreturn 'a';\r\nif (type == DEV_CHAR)\r\nreturn 'c';\r\nif (type == DEV_BLOCK)\r\nreturn 'b';\r\nreturn 'X';\r\n}\r\nstatic void set_majmin(char *str, unsigned m)\r\n{\r\nif (m == ~0)\r\nstrcpy(str, "*");\r\nelse\r\nsprintf(str, "%u", m);\r\n}\r\nstatic int devcgroup_seq_read(struct cgroup *cgroup, struct cftype *cft,\r\nstruct seq_file *m)\r\n{\r\nstruct dev_cgroup *devcgroup = cgroup_to_devcgroup(cgroup);\r\nstruct dev_whitelist_item *wh;\r\nchar maj[MAJMINLEN], min[MAJMINLEN], acc[ACCLEN];\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(wh, &devcgroup->whitelist, list) {\r\nset_access(acc, wh->access);\r\nset_majmin(maj, wh->major);\r\nset_majmin(min, wh->minor);\r\nseq_printf(m, "%c %s:%s %s\n", type_to_char(wh->type),\r\nmaj, min, acc);\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int may_access_whitelist(struct dev_cgroup *c,\r\nstruct dev_whitelist_item *refwh)\r\n{\r\nstruct dev_whitelist_item *whitem;\r\nlist_for_each_entry(whitem, &c->whitelist, list) {\r\nif (whitem->type & DEV_ALL)\r\nreturn 1;\r\nif ((refwh->type & DEV_BLOCK) && !(whitem->type & DEV_BLOCK))\r\ncontinue;\r\nif ((refwh->type & DEV_CHAR) && !(whitem->type & DEV_CHAR))\r\ncontinue;\r\nif (whitem->major != ~0 && whitem->major != refwh->major)\r\ncontinue;\r\nif (whitem->minor != ~0 && whitem->minor != refwh->minor)\r\ncontinue;\r\nif (refwh->access & (~whitem->access))\r\ncontinue;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parent_has_perm(struct dev_cgroup *childcg,\r\nstruct dev_whitelist_item *wh)\r\n{\r\nstruct cgroup *pcg = childcg->css.cgroup->parent;\r\nstruct dev_cgroup *parent;\r\nif (!pcg)\r\nreturn 1;\r\nparent = cgroup_to_devcgroup(pcg);\r\nreturn may_access_whitelist(parent, wh);\r\n}\r\nstatic int devcgroup_update_access(struct dev_cgroup *devcgroup,\r\nint filetype, const char *buffer)\r\n{\r\nconst char *b;\r\nchar *endp;\r\nint count;\r\nstruct dev_whitelist_item wh;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmemset(&wh, 0, sizeof(wh));\r\nb = buffer;\r\nswitch (*b) {\r\ncase 'a':\r\nwh.type = DEV_ALL;\r\nwh.access = ACC_MASK;\r\nwh.major = ~0;\r\nwh.minor = ~0;\r\ngoto handle;\r\ncase 'b':\r\nwh.type = DEV_BLOCK;\r\nbreak;\r\ncase 'c':\r\nwh.type = DEV_CHAR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nb++;\r\nif (!isspace(*b))\r\nreturn -EINVAL;\r\nb++;\r\nif (*b == '*') {\r\nwh.major = ~0;\r\nb++;\r\n} else if (isdigit(*b)) {\r\nwh.major = simple_strtoul(b, &endp, 10);\r\nb = endp;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (*b != ':')\r\nreturn -EINVAL;\r\nb++;\r\nif (*b == '*') {\r\nwh.minor = ~0;\r\nb++;\r\n} else if (isdigit(*b)) {\r\nwh.minor = simple_strtoul(b, &endp, 10);\r\nb = endp;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (!isspace(*b))\r\nreturn -EINVAL;\r\nfor (b++, count = 0; count < 3; count++, b++) {\r\nswitch (*b) {\r\ncase 'r':\r\nwh.access |= ACC_READ;\r\nbreak;\r\ncase 'w':\r\nwh.access |= ACC_WRITE;\r\nbreak;\r\ncase 'm':\r\nwh.access |= ACC_MKNOD;\r\nbreak;\r\ncase '\n':\r\ncase '\0':\r\ncount = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nhandle:\r\nswitch (filetype) {\r\ncase DEVCG_ALLOW:\r\nif (!parent_has_perm(devcgroup, &wh))\r\nreturn -EPERM;\r\nreturn dev_whitelist_add(devcgroup, &wh);\r\ncase DEVCG_DENY:\r\ndev_whitelist_rm(devcgroup, &wh);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int devcgroup_access_write(struct cgroup *cgrp, struct cftype *cft,\r\nconst char *buffer)\r\n{\r\nint retval;\r\nmutex_lock(&devcgroup_mutex);\r\nretval = devcgroup_update_access(cgroup_to_devcgroup(cgrp),\r\ncft->private, buffer);\r\nmutex_unlock(&devcgroup_mutex);\r\nreturn retval;\r\n}\r\nint __devcgroup_inode_permission(struct inode *inode, int mask)\r\n{\r\nstruct dev_cgroup *dev_cgroup;\r\nstruct dev_whitelist_item *wh;\r\nrcu_read_lock();\r\ndev_cgroup = task_devcgroup(current);\r\nlist_for_each_entry_rcu(wh, &dev_cgroup->whitelist, list) {\r\nif (wh->type & DEV_ALL)\r\ngoto found;\r\nif ((wh->type & DEV_BLOCK) && !S_ISBLK(inode->i_mode))\r\ncontinue;\r\nif ((wh->type & DEV_CHAR) && !S_ISCHR(inode->i_mode))\r\ncontinue;\r\nif (wh->major != ~0 && wh->major != imajor(inode))\r\ncontinue;\r\nif (wh->minor != ~0 && wh->minor != iminor(inode))\r\ncontinue;\r\nif ((mask & MAY_WRITE) && !(wh->access & ACC_WRITE))\r\ncontinue;\r\nif ((mask & MAY_READ) && !(wh->access & ACC_READ))\r\ncontinue;\r\nfound:\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nrcu_read_unlock();\r\nreturn -EPERM;\r\n}\r\nint devcgroup_inode_mknod(int mode, dev_t dev)\r\n{\r\nstruct dev_cgroup *dev_cgroup;\r\nstruct dev_whitelist_item *wh;\r\nif (!S_ISBLK(mode) && !S_ISCHR(mode))\r\nreturn 0;\r\nrcu_read_lock();\r\ndev_cgroup = task_devcgroup(current);\r\nlist_for_each_entry_rcu(wh, &dev_cgroup->whitelist, list) {\r\nif (wh->type & DEV_ALL)\r\ngoto found;\r\nif ((wh->type & DEV_BLOCK) && !S_ISBLK(mode))\r\ncontinue;\r\nif ((wh->type & DEV_CHAR) && !S_ISCHR(mode))\r\ncontinue;\r\nif (wh->major != ~0 && wh->major != MAJOR(dev))\r\ncontinue;\r\nif (wh->minor != ~0 && wh->minor != MINOR(dev))\r\ncontinue;\r\nif (!(wh->access & ACC_MKNOD))\r\ncontinue;\r\nfound:\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nrcu_read_unlock();\r\nreturn -EPERM;\r\n}
