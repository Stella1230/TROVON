static void pcap_ts_read_xy(void *data, u16 res[2])\r\n{\r\nstruct pcap_ts *pcap_ts = data;\r\nswitch (pcap_ts->read_state) {\r\ncase PCAP_ADC_TS_M_PRESSURE:\r\nif (res[0] > PRESSURE_MIN && res[0] < PRESSURE_MAX)\r\npcap_ts->pressure = res[0];\r\npcap_ts->read_state = PCAP_ADC_TS_M_XY;\r\nschedule_delayed_work(&pcap_ts->work, 0);\r\nbreak;\r\ncase PCAP_ADC_TS_M_XY:\r\npcap_ts->y = res[0];\r\npcap_ts->x = res[1];\r\nif (pcap_ts->x <= X_AXIS_MIN || pcap_ts->x >= X_AXIS_MAX ||\r\npcap_ts->y <= Y_AXIS_MIN || pcap_ts->y >= Y_AXIS_MAX) {\r\ninput_report_abs(pcap_ts->input, ABS_PRESSURE, 0);\r\ninput_report_key(pcap_ts->input, BTN_TOUCH, 0);\r\npcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;\r\nschedule_delayed_work(&pcap_ts->work, 0);\r\n} else {\r\ninput_report_abs(pcap_ts->input, ABS_X, pcap_ts->x);\r\ninput_report_abs(pcap_ts->input, ABS_Y, pcap_ts->y);\r\ninput_report_key(pcap_ts->input, BTN_TOUCH, 1);\r\ninput_report_abs(pcap_ts->input, ABS_PRESSURE,\r\npcap_ts->pressure);\r\npcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;\r\nschedule_delayed_work(&pcap_ts->work,\r\nmsecs_to_jiffies(SAMPLE_DELAY));\r\n}\r\ninput_sync(pcap_ts->input);\r\nbreak;\r\ndefault:\r\ndev_warn(&pcap_ts->input->dev,\r\n"pcap_ts: Warning, unhandled read_state %d\n",\r\npcap_ts->read_state);\r\nbreak;\r\n}\r\n}\r\nstatic void pcap_ts_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *dw = container_of(work, struct delayed_work, work);\r\nstruct pcap_ts *pcap_ts = container_of(dw, struct pcap_ts, work);\r\nu8 ch[2];\r\npcap_set_ts_bits(pcap_ts->pcap,\r\npcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\r\nif (pcap_ts->read_state == PCAP_ADC_TS_M_STANDBY)\r\nreturn;\r\nch[0] = PCAP_ADC_CH_TS_X1;\r\nch[1] = PCAP_ADC_CH_TS_Y1;\r\npcap_adc_async(pcap_ts->pcap, PCAP_ADC_BANK_1, 0, ch,\r\npcap_ts_read_xy, pcap_ts);\r\n}\r\nstatic irqreturn_t pcap_ts_event_touch(int pirq, void *data)\r\n{\r\nstruct pcap_ts *pcap_ts = data;\r\nif (pcap_ts->read_state == PCAP_ADC_TS_M_STANDBY) {\r\npcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;\r\nschedule_delayed_work(&pcap_ts->work, 0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcap_ts_open(struct input_dev *dev)\r\n{\r\nstruct pcap_ts *pcap_ts = input_get_drvdata(dev);\r\npcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;\r\nschedule_delayed_work(&pcap_ts->work, 0);\r\nreturn 0;\r\n}\r\nstatic void pcap_ts_close(struct input_dev *dev)\r\n{\r\nstruct pcap_ts *pcap_ts = input_get_drvdata(dev);\r\ncancel_delayed_work_sync(&pcap_ts->work);\r\npcap_ts->read_state = PCAP_ADC_TS_M_NONTS;\r\npcap_set_ts_bits(pcap_ts->pcap,\r\npcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\r\n}\r\nstatic int __devinit pcap_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input_dev;\r\nstruct pcap_ts *pcap_ts;\r\nint err = -ENOMEM;\r\npcap_ts = kzalloc(sizeof(*pcap_ts), GFP_KERNEL);\r\nif (!pcap_ts)\r\nreturn err;\r\npcap_ts->pcap = dev_get_drvdata(pdev->dev.parent);\r\nplatform_set_drvdata(pdev, pcap_ts);\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\ngoto fail;\r\nINIT_DELAYED_WORK(&pcap_ts->work, pcap_ts_work);\r\npcap_ts->read_state = PCAP_ADC_TS_M_NONTS;\r\npcap_set_ts_bits(pcap_ts->pcap,\r\npcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\r\npcap_ts->input = input_dev;\r\ninput_set_drvdata(input_dev, pcap_ts);\r\ninput_dev->name = "pcap-touchscreen";\r\ninput_dev->phys = "pcap_ts/input0";\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0002;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = pcap_ts_open;\r\ninput_dev->close = pcap_ts_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, X_AXIS_MIN, X_AXIS_MAX, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, Y_AXIS_MIN, Y_AXIS_MAX, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, PRESSURE_MIN,\r\nPRESSURE_MAX, 0, 0);\r\nerr = input_register_device(pcap_ts->input);\r\nif (err)\r\ngoto fail_allocate;\r\nerr = request_irq(pcap_to_irq(pcap_ts->pcap, PCAP_IRQ_TS),\r\npcap_ts_event_touch, 0, "Touch Screen", pcap_ts);\r\nif (err)\r\ngoto fail_register;\r\nreturn 0;\r\nfail_register:\r\ninput_unregister_device(input_dev);\r\ngoto fail;\r\nfail_allocate:\r\ninput_free_device(input_dev);\r\nfail:\r\nkfree(pcap_ts);\r\nreturn err;\r\n}\r\nstatic int __devexit pcap_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct pcap_ts *pcap_ts = platform_get_drvdata(pdev);\r\nfree_irq(pcap_to_irq(pcap_ts->pcap, PCAP_IRQ_TS), pcap_ts);\r\ncancel_delayed_work_sync(&pcap_ts->work);\r\ninput_unregister_device(pcap_ts->input);\r\nkfree(pcap_ts);\r\nreturn 0;\r\n}\r\nstatic int pcap_ts_suspend(struct device *dev)\r\n{\r\nstruct pcap_ts *pcap_ts = dev_get_drvdata(dev);\r\npcap_set_ts_bits(pcap_ts->pcap, PCAP_ADC_TS_REF_LOWPWR);\r\nreturn 0;\r\n}\r\nstatic int pcap_ts_resume(struct device *dev)\r\n{\r\nstruct pcap_ts *pcap_ts = dev_get_drvdata(dev);\r\npcap_set_ts_bits(pcap_ts->pcap,\r\npcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);\r\nreturn 0;\r\n}
