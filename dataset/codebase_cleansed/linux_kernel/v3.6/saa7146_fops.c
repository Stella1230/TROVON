int saa7146_res_get(struct saa7146_fh *fh, unsigned int bit)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nif (fh->resources & bit) {\r\nDEB_D("already allocated! want: 0x%02x, cur:0x%02x\n",\r\nbit, vv->resources);\r\nreturn 1;\r\n}\r\nif (vv->resources & bit) {\r\nDEB_D("locked! vv->resources:0x%02x, we want:0x%02x\n",\r\nvv->resources, bit);\r\nreturn 0;\r\n}\r\nfh->resources |= bit;\r\nvv->resources |= bit;\r\nDEB_D("res: get 0x%02x, cur:0x%02x\n", bit, vv->resources);\r\nreturn 1;\r\n}\r\nvoid saa7146_res_free(struct saa7146_fh *fh, unsigned int bits)\r\n{\r\nstruct saa7146_dev *dev = fh->dev;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nBUG_ON((fh->resources & bits) != bits);\r\nfh->resources &= ~bits;\r\nvv->resources &= ~bits;\r\nDEB_D("res: put 0x%02x, cur:0x%02x\n", bits, vv->resources);\r\n}\r\nvoid saa7146_dma_free(struct saa7146_dev *dev,struct videobuf_queue *q,\r\nstruct saa7146_buf *buf)\r\n{\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nDEB_EE("dev:%p, buf:%p\n", dev, buf);\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(q, &buf->vb, 0, 0);\r\nvideobuf_dma_unmap(q->dev, dma);\r\nvideobuf_dma_free(dma);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nint saa7146_buffer_queue(struct saa7146_dev *dev,\r\nstruct saa7146_dmaqueue *q,\r\nstruct saa7146_buf *buf)\r\n{\r\nassert_spin_locked(&dev->slock);\r\nDEB_EE("dev:%p, dmaq:%p, buf:%p\n", dev, q, buf);\r\nBUG_ON(!q);\r\nif (NULL == q->curr) {\r\nq->curr = buf;\r\nDEB_D("immediately activating buffer %p\n", buf);\r\nbuf->activate(dev,buf,NULL);\r\n} else {\r\nlist_add_tail(&buf->vb.queue,&q->queue);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nDEB_D("adding buffer %p to queue. (active buffer present)\n",\r\nbuf);\r\n}\r\nreturn 0;\r\n}\r\nvoid saa7146_buffer_finish(struct saa7146_dev *dev,\r\nstruct saa7146_dmaqueue *q,\r\nint state)\r\n{\r\nassert_spin_locked(&dev->slock);\r\nDEB_EE("dev:%p, dmaq:%p, state:%d\n", dev, q, state);\r\nDEB_EE("q->curr:%p\n", q->curr);\r\nBUG_ON(!q->curr);\r\nif (NULL == q->curr) {\r\nDEB_D("aiii. no current buffer\n");\r\nreturn;\r\n}\r\nq->curr->vb.state = state;\r\ndo_gettimeofday(&q->curr->vb.ts);\r\nwake_up(&q->curr->vb.done);\r\nq->curr = NULL;\r\n}\r\nvoid saa7146_buffer_next(struct saa7146_dev *dev,\r\nstruct saa7146_dmaqueue *q, int vbi)\r\n{\r\nstruct saa7146_buf *buf,*next = NULL;\r\nBUG_ON(!q);\r\nDEB_INT("dev:%p, dmaq:%p, vbi:%d\n", dev, q, vbi);\r\nassert_spin_locked(&dev->slock);\r\nif (!list_empty(&q->queue)) {\r\nbuf = list_entry(q->queue.next,struct saa7146_buf,vb.queue);\r\nlist_del(&buf->vb.queue);\r\nif (!list_empty(&q->queue))\r\nnext = list_entry(q->queue.next,struct saa7146_buf, vb.queue);\r\nq->curr = buf;\r\nDEB_INT("next buffer: buf:%p, prev:%p, next:%p\n",\r\nbuf, q->queue.prev, q->queue.next);\r\nbuf->activate(dev,buf,next);\r\n} else {\r\nDEB_INT("no next buffer. stopping.\n");\r\nif( 0 != vbi ) {\r\nsaa7146_write(dev,MC1, MASK_20);\r\n} else {\r\nsaa7146_write(dev, PROT_ADDR1, 0);\r\nsaa7146_write(dev, MC2, (MASK_02|MASK_18));\r\nsaa7146_write(dev, RPS_ADDR0, dev->d_rps0.dma_handle);\r\nsaa7146_write(dev, MC1, (MASK_12 | MASK_28));\r\n}\r\ndel_timer(&q->timeout);\r\n}\r\n}\r\nvoid saa7146_buffer_timeout(unsigned long data)\r\n{\r\nstruct saa7146_dmaqueue *q = (struct saa7146_dmaqueue*)data;\r\nstruct saa7146_dev *dev = q->dev;\r\nunsigned long flags;\r\nDEB_EE("dev:%p, dmaq:%p\n", dev, q);\r\nspin_lock_irqsave(&dev->slock,flags);\r\nif (q->curr) {\r\nDEB_D("timeout on %p\n", q->curr);\r\nsaa7146_buffer_finish(dev,q,VIDEOBUF_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock,flags);\r\n}\r\nstatic int fops_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7146_dev *dev = video_drvdata(file);\r\nstruct saa7146_fh *fh = NULL;\r\nint result = 0;\r\nDEB_EE("file:%p, dev:%s\n", file, video_device_node_name(vdev));\r\nif (mutex_lock_interruptible(&saa7146_devices_lock))\r\nreturn -ERESTARTSYS;\r\nDEB_D("using: %p\n", dev);\r\nif( NULL == dev->ext ) {\r\nDEB_S("no extension registered for this device\n");\r\nresult = -ENODEV;\r\ngoto out;\r\n}\r\nfh = kzalloc(sizeof(*fh),GFP_KERNEL);\r\nif (NULL == fh) {\r\nDEB_S("cannot allocate memory for per open data\n");\r\nresult = -ENOMEM;\r\ngoto out;\r\n}\r\nv4l2_fh_init(&fh->fh, vdev);\r\nfile->private_data = &fh->fh;\r\nfh->dev = dev;\r\nif (vdev->vfl_type == VFL_TYPE_VBI) {\r\nDEB_S("initializing vbi...\n");\r\nif (dev->ext_vv_data->capabilities & V4L2_CAP_VBI_CAPTURE)\r\nresult = saa7146_vbi_uops.open(dev,file);\r\nif (dev->ext_vv_data->vbi_fops.open)\r\ndev->ext_vv_data->vbi_fops.open(file);\r\n} else {\r\nDEB_S("initializing video...\n");\r\nresult = saa7146_video_uops.open(dev,file);\r\n}\r\nif (0 != result) {\r\ngoto out;\r\n}\r\nif( 0 == try_module_get(dev->ext->module)) {\r\nresult = -EINVAL;\r\ngoto out;\r\n}\r\nresult = 0;\r\nv4l2_fh_add(&fh->fh);\r\nout:\r\nif (fh && result != 0) {\r\nkfree(fh);\r\nfile->private_data = NULL;\r\n}\r\nmutex_unlock(&saa7146_devices_lock);\r\nreturn result;\r\n}\r\nstatic int fops_release(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct saa7146_dev *dev = fh->dev;\r\nDEB_EE("file:%p\n", file);\r\nif (mutex_lock_interruptible(&saa7146_devices_lock))\r\nreturn -ERESTARTSYS;\r\nif (vdev->vfl_type == VFL_TYPE_VBI) {\r\nif (dev->ext_vv_data->capabilities & V4L2_CAP_VBI_CAPTURE)\r\nsaa7146_vbi_uops.release(dev,file);\r\nif (dev->ext_vv_data->vbi_fops.release)\r\ndev->ext_vv_data->vbi_fops.release(file);\r\n} else {\r\nsaa7146_video_uops.release(dev,file);\r\n}\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nmodule_put(dev->ext->module);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\nmutex_unlock(&saa7146_devices_lock);\r\nreturn 0;\r\n}\r\nstatic int fops_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct videobuf_queue *q;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER: {\r\nDEB_EE("V4L2_BUF_TYPE_VIDEO_CAPTURE: file:%p, vma:%p\n",\r\nfile, vma);\r\nq = &fh->video_q;\r\nbreak;\r\n}\r\ncase VFL_TYPE_VBI: {\r\nDEB_EE("V4L2_BUF_TYPE_VBI_CAPTURE: file:%p, vma:%p\n",\r\nfile, vma);\r\nif (fh->dev->ext_vv_data->capabilities & V4L2_CAP_SLICED_VBI_OUTPUT)\r\nreturn -ENODEV;\r\nq = &fh->vbi_q;\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nreturn videobuf_mmap_mapper(q,vma);\r\n}\r\nstatic unsigned int fops_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7146_fh *fh = file->private_data;\r\nstruct videobuf_buffer *buf = NULL;\r\nstruct videobuf_queue *q;\r\nunsigned int res = v4l2_ctrl_poll(file, wait);\r\nDEB_EE("file:%p, poll:%p\n", file, wait);\r\nif (vdev->vfl_type == VFL_TYPE_VBI) {\r\nif (fh->dev->ext_vv_data->capabilities & V4L2_CAP_SLICED_VBI_OUTPUT)\r\nreturn res | POLLOUT | POLLWRNORM;\r\nif( 0 == fh->vbi_q.streaming )\r\nreturn res | videobuf_poll_stream(file, &fh->vbi_q, wait);\r\nq = &fh->vbi_q;\r\n} else {\r\nDEB_D("using video queue\n");\r\nq = &fh->video_q;\r\n}\r\nif (!list_empty(&q->stream))\r\nbuf = list_entry(q->stream.next, struct videobuf_buffer, stream);\r\nif (!buf) {\r\nDEB_D("buf == NULL!\n");\r\nreturn res | POLLERR;\r\n}\r\npoll_wait(file, &buf->done, wait);\r\nif (buf->state == VIDEOBUF_DONE || buf->state == VIDEOBUF_ERROR) {\r\nDEB_D("poll succeeded!\n");\r\nreturn res | POLLIN | POLLRDNORM;\r\n}\r\nDEB_D("nothing to poll for, buf->state:%d\n", buf->state);\r\nreturn res;\r\n}\r\nstatic ssize_t fops_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7146_fh *fh = file->private_data;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nreturn saa7146_video_uops.read(file,data,count,ppos);\r\ncase VFL_TYPE_VBI:\r\nif (fh->dev->ext_vv_data->capabilities & V4L2_CAP_VBI_CAPTURE)\r\nreturn saa7146_vbi_uops.read(file,data,count,ppos);\r\nreturn -EINVAL;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic ssize_t fops_write(struct file *file, const char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7146_fh *fh = file->private_data;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nreturn -EINVAL;\r\ncase VFL_TYPE_VBI:\r\nif (fh->dev->ext_vv_data->vbi_fops.write)\r\nreturn fh->dev->ext_vv_data->vbi_fops.write(file, data, count, ppos);\r\nelse\r\nreturn -EINVAL;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void vv_callback(struct saa7146_dev *dev, unsigned long status)\r\n{\r\nu32 isr = status;\r\nDEB_INT("dev:%p, isr:0x%08x\n", dev, (u32)status);\r\nif (0 != (isr & (MASK_27))) {\r\nDEB_INT("irq: RPS0 (0x%08x)\n", isr);\r\nsaa7146_video_uops.irq_done(dev,isr);\r\n}\r\nif (0 != (isr & (MASK_28))) {\r\nu32 mc2 = saa7146_read(dev, MC2);\r\nif( 0 != (mc2 & MASK_15)) {\r\nDEB_INT("irq: RPS1 vbi workaround (0x%08x)\n", isr);\r\nwake_up(&dev->vv_data->vbi_wq);\r\nsaa7146_write(dev,MC2, MASK_31);\r\nreturn;\r\n}\r\nDEB_INT("irq: RPS1 (0x%08x)\n", isr);\r\nsaa7146_vbi_uops.irq_done(dev,isr);\r\n}\r\n}\r\nint saa7146_vv_init(struct saa7146_dev* dev, struct saa7146_ext_vv *ext_vv)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &dev->ctrl_handler;\r\nstruct v4l2_pix_format *fmt;\r\nstruct v4l2_vbi_format *vbi;\r\nstruct saa7146_vv *vv;\r\nint err;\r\nerr = v4l2_device_register(&dev->pci->dev, &dev->v4l2_dev);\r\nif (err)\r\nreturn err;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &saa7146_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nif (hdl->error) {\r\nerr = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn err;\r\n}\r\ndev->v4l2_dev.ctrl_handler = hdl;\r\nvv = kzalloc(sizeof(struct saa7146_vv), GFP_KERNEL);\r\nif (vv == NULL) {\r\nERR("out of memory. aborting.\n");\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn -ENOMEM;\r\n}\r\next_vv->vid_ops = saa7146_video_ioctl_ops;\r\next_vv->vbi_ops = saa7146_vbi_ioctl_ops;\r\next_vv->core_ops = &saa7146_video_ioctl_ops;\r\nDEB_EE("dev:%p\n", dev);\r\nsaa7146_write(dev, BCS_CTRL, 0x80400040);\r\nsaa7146_write(dev, MC1, (MASK_10 | MASK_26));\r\ndev->ext_vv_data = ext_vv;\r\nvv->d_clipping.cpu_addr = pci_alloc_consistent(dev->pci, SAA7146_CLIPPING_MEM, &vv->d_clipping.dma_handle);\r\nif( NULL == vv->d_clipping.cpu_addr ) {\r\nERR("out of memory. aborting.\n");\r\nkfree(vv);\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn -1;\r\n}\r\nmemset(vv->d_clipping.cpu_addr, 0x0, SAA7146_CLIPPING_MEM);\r\nsaa7146_video_uops.init(dev,vv);\r\nif (dev->ext_vv_data->capabilities & V4L2_CAP_VBI_CAPTURE)\r\nsaa7146_vbi_uops.init(dev,vv);\r\nfmt = &vv->ov_fb.fmt;\r\nfmt->width = vv->standard->h_max_out;\r\nfmt->height = vv->standard->v_max_out;\r\nfmt->pixelformat = V4L2_PIX_FMT_RGB565;\r\nfmt->bytesperline = 2 * fmt->width;\r\nfmt->sizeimage = fmt->bytesperline * fmt->height;\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt = &vv->video_fmt;\r\nfmt->width = 384;\r\nfmt->height = 288;\r\nfmt->pixelformat = V4L2_PIX_FMT_BGR24;\r\nfmt->field = V4L2_FIELD_ANY;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nfmt->bytesperline = 3 * fmt->width;\r\nfmt->sizeimage = fmt->bytesperline * fmt->height;\r\nvbi = &vv->vbi_fmt;\r\nvbi->sampling_rate = 27000000;\r\nvbi->offset = 248;\r\nvbi->samples_per_line = 720 * 2;\r\nvbi->sample_format = V4L2_PIX_FMT_GREY;\r\nvbi->start[0] = 5;\r\nvbi->count[0] = 16;\r\nvbi->start[1] = 312;\r\nvbi->count[1] = 16;\r\ninit_timer(&vv->vbi_read_timeout);\r\nvv->ov_fb.capability = V4L2_FBUF_CAP_LIST_CLIPPING;\r\nvv->ov_fb.flags = V4L2_FBUF_FLAG_PRIMARY;\r\ndev->vv_data = vv;\r\ndev->vv_callback = &vv_callback;\r\nreturn 0;\r\n}\r\nint saa7146_vv_release(struct saa7146_dev* dev)\r\n{\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nDEB_EE("dev:%p\n", dev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\npci_free_consistent(dev->pci, SAA7146_CLIPPING_MEM, vv->d_clipping.cpu_addr, vv->d_clipping.dma_handle);\r\nv4l2_ctrl_handler_free(&dev->ctrl_handler);\r\nkfree(vv);\r\ndev->vv_data = NULL;\r\ndev->vv_callback = NULL;\r\nreturn 0;\r\n}\r\nint saa7146_register_device(struct video_device **vid, struct saa7146_dev* dev,\r\nchar *name, int type)\r\n{\r\nstruct video_device *vfd;\r\nint err;\r\nint i;\r\nDEB_EE("dev:%p, name:'%s', type:%d\n", dev, name, type);\r\nvfd = video_device_alloc();\r\nif (vfd == NULL)\r\nreturn -ENOMEM;\r\nvfd->fops = &video_fops;\r\nif (type == VFL_TYPE_GRABBER)\r\nvfd->ioctl_ops = &dev->ext_vv_data->vid_ops;\r\nelse\r\nvfd->ioctl_ops = &dev->ext_vv_data->vbi_ops;\r\nvfd->release = video_device_release;\r\nset_bit(V4L2_FL_LOCK_ALL_FOPS, &vfd->flags);\r\nvfd->lock = &dev->v4l2_lock;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->tvnorms = 0;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);\r\nfor (i = 0; i < dev->ext_vv_data->num_stds; i++)\r\nvfd->tvnorms |= dev->ext_vv_data->stds[i].id;\r\nstrlcpy(vfd->name, name, sizeof(vfd->name));\r\nvideo_set_drvdata(vfd, dev);\r\nerr = video_register_device(vfd, type, -1);\r\nif (err < 0) {\r\nERR("cannot register v4l2 device. skipping.\n");\r\nvideo_device_release(vfd);\r\nreturn err;\r\n}\r\npr_info("%s: registered device %s [v4l2]\n",\r\ndev->name, video_device_node_name(vfd));\r\n*vid = vfd;\r\nreturn 0;\r\n}\r\nint saa7146_unregister_device(struct video_device **vid, struct saa7146_dev* dev)\r\n{\r\nDEB_EE("dev:%p\n", dev);\r\nvideo_unregister_device(*vid);\r\n*vid = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init saa7146_vv_init_module(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit saa7146_vv_cleanup_module(void)\r\n{\r\n}
