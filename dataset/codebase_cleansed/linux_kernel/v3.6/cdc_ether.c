static int is_rndis(struct usb_interface_descriptor *desc)\r\n{\r\nreturn (desc->bInterfaceClass == USB_CLASS_COMM &&\r\ndesc->bInterfaceSubClass == 2 &&\r\ndesc->bInterfaceProtocol == 0xff);\r\n}\r\nstatic int is_activesync(struct usb_interface_descriptor *desc)\r\n{\r\nreturn (desc->bInterfaceClass == USB_CLASS_MISC &&\r\ndesc->bInterfaceSubClass == 1 &&\r\ndesc->bInterfaceProtocol == 1);\r\n}\r\nstatic int is_wireless_rndis(struct usb_interface_descriptor *desc)\r\n{\r\nreturn (desc->bInterfaceClass == USB_CLASS_WIRELESS_CONTROLLER &&\r\ndesc->bInterfaceSubClass == 1 &&\r\ndesc->bInterfaceProtocol == 3);\r\n}\r\nint usbnet_generic_cdc_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nu8 *buf = intf->cur_altsetting->extra;\r\nint len = intf->cur_altsetting->extralen;\r\nstruct usb_interface_descriptor *d;\r\nstruct cdc_state *info = (void *) &dev->data;\r\nint status;\r\nint rndis;\r\nbool android_rndis_quirk = false;\r\nstruct usb_driver *driver = driver_of(intf);\r\nstruct usb_cdc_mdlm_desc *desc = NULL;\r\nstruct usb_cdc_mdlm_detail_desc *detail = NULL;\r\nif (sizeof dev->data < sizeof *info)\r\nreturn -EDOM;\r\nif (len == 0 && dev->udev->actconfig->extralen) {\r\nbuf = dev->udev->actconfig->extra;\r\nlen = dev->udev->actconfig->extralen;\r\ndev_dbg(&intf->dev, "CDC descriptors on config\n");\r\n}\r\nif (len == 0) {\r\nstruct usb_host_endpoint *hep;\r\nhep = intf->cur_altsetting->endpoint;\r\nif (hep) {\r\nbuf = hep->extra;\r\nlen = hep->extralen;\r\n}\r\nif (len)\r\ndev_dbg(&intf->dev,\r\n"CDC descriptors on endpoint\n");\r\n}\r\nrndis = (is_rndis(&intf->cur_altsetting->desc) ||\r\nis_activesync(&intf->cur_altsetting->desc) ||\r\nis_wireless_rndis(&intf->cur_altsetting->desc));\r\nmemset(info, 0, sizeof *info);\r\ninfo->control = intf;\r\nwhile (len > 3) {\r\nif (buf [1] != USB_DT_CS_INTERFACE)\r\ngoto next_desc;\r\nswitch (buf [2]) {\r\ncase USB_CDC_HEADER_TYPE:\r\nif (info->header) {\r\ndev_dbg(&intf->dev, "extra CDC header\n");\r\ngoto bad_desc;\r\n}\r\ninfo->header = (void *) buf;\r\nif (info->header->bLength != sizeof *info->header) {\r\ndev_dbg(&intf->dev, "CDC header len %u\n",\r\ninfo->header->bLength);\r\ngoto bad_desc;\r\n}\r\nbreak;\r\ncase USB_CDC_ACM_TYPE:\r\nif (rndis) {\r\nstruct usb_cdc_acm_descriptor *acm;\r\nacm = (void *) buf;\r\nif (acm->bmCapabilities) {\r\ndev_dbg(&intf->dev,\r\n"ACM capabilities %02x, "\r\n"not really RNDIS?\n",\r\nacm->bmCapabilities);\r\ngoto bad_desc;\r\n}\r\n}\r\nbreak;\r\ncase USB_CDC_UNION_TYPE:\r\nif (info->u) {\r\ndev_dbg(&intf->dev, "extra CDC union\n");\r\ngoto bad_desc;\r\n}\r\ninfo->u = (void *) buf;\r\nif (info->u->bLength != sizeof *info->u) {\r\ndev_dbg(&intf->dev, "CDC union len %u\n",\r\ninfo->u->bLength);\r\ngoto bad_desc;\r\n}\r\ninfo->control = usb_ifnum_to_if(dev->udev,\r\ninfo->u->bMasterInterface0);\r\ninfo->data = usb_ifnum_to_if(dev->udev,\r\ninfo->u->bSlaveInterface0);\r\nif (!info->control || !info->data) {\r\ndev_dbg(&intf->dev,\r\n"master #%u/%p slave #%u/%p\n",\r\ninfo->u->bMasterInterface0,\r\ninfo->control,\r\ninfo->u->bSlaveInterface0,\r\ninfo->data);\r\nif (rndis) {\r\nandroid_rndis_quirk = true;\r\ngoto next_desc;\r\n}\r\ngoto bad_desc;\r\n}\r\nif (info->control != intf) {\r\ndev_dbg(&intf->dev, "bogus CDC Union\n");\r\nif (info->data == intf) {\r\ninfo->data = info->control;\r\ninfo->control = intf;\r\n} else\r\ngoto bad_desc;\r\n}\r\nd = &info->data->cur_altsetting->desc;\r\nif (d->bInterfaceClass != USB_CLASS_CDC_DATA) {\r\ndev_dbg(&intf->dev, "slave class %u\n",\r\nd->bInterfaceClass);\r\ngoto bad_desc;\r\n}\r\nbreak;\r\ncase USB_CDC_ETHERNET_TYPE:\r\nif (info->ether) {\r\ndev_dbg(&intf->dev, "extra CDC ether\n");\r\ngoto bad_desc;\r\n}\r\ninfo->ether = (void *) buf;\r\nif (info->ether->bLength != sizeof *info->ether) {\r\ndev_dbg(&intf->dev, "CDC ether len %u\n",\r\ninfo->ether->bLength);\r\ngoto bad_desc;\r\n}\r\ndev->hard_mtu = le16_to_cpu(\r\ninfo->ether->wMaxSegmentSize);\r\nbreak;\r\ncase USB_CDC_MDLM_TYPE:\r\nif (desc) {\r\ndev_dbg(&intf->dev, "extra MDLM descriptor\n");\r\ngoto bad_desc;\r\n}\r\ndesc = (void *)buf;\r\nif (desc->bLength != sizeof(*desc))\r\ngoto bad_desc;\r\nif (memcmp(&desc->bGUID, mbm_guid, 16))\r\ngoto bad_desc;\r\nbreak;\r\ncase USB_CDC_MDLM_DETAIL_TYPE:\r\nif (detail) {\r\ndev_dbg(&intf->dev, "extra MDLM detail descriptor\n");\r\ngoto bad_desc;\r\n}\r\ndetail = (void *)buf;\r\nif (detail->bGuidDescriptorType == 0) {\r\nif (detail->bLength < (sizeof(*detail) + 1))\r\ngoto bad_desc;\r\n} else\r\ngoto bad_desc;\r\nbreak;\r\n}\r\nnext_desc:\r\nlen -= buf [0];\r\nbuf += buf [0];\r\n}\r\nif (rndis && (!info->u || android_rndis_quirk)) {\r\ninfo->control = usb_ifnum_to_if(dev->udev, 0);\r\ninfo->data = usb_ifnum_to_if(dev->udev, 1);\r\nif (!info->control || !info->data || info->control != intf) {\r\ndev_dbg(&intf->dev,\r\n"rndis: master #0/%p slave #1/%p\n",\r\ninfo->control,\r\ninfo->data);\r\ngoto bad_desc;\r\n}\r\n} else if (!info->header || !info->u || (!rndis && !info->ether)) {\r\ndev_dbg(&intf->dev, "missing cdc %s%s%sdescriptor\n",\r\ninfo->header ? "" : "header ",\r\ninfo->u ? "" : "union ",\r\ninfo->ether ? "" : "ether ");\r\ngoto bad_desc;\r\n}\r\nstatus = usb_driver_claim_interface(driver, info->data, dev);\r\nif (status < 0)\r\nreturn status;\r\nstatus = usbnet_get_endpoints(dev, info->data);\r\nif (status < 0) {\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver, info->data);\r\nreturn status;\r\n}\r\ndev->status = NULL;\r\nif (info->control->cur_altsetting->desc.bNumEndpoints == 1) {\r\nstruct usb_endpoint_descriptor *desc;\r\ndev->status = &info->control->cur_altsetting->endpoint [0];\r\ndesc = &dev->status->desc;\r\nif (!usb_endpoint_is_int_in(desc) ||\r\n(le16_to_cpu(desc->wMaxPacketSize)\r\n< sizeof(struct usb_cdc_notification)) ||\r\n!desc->bInterval) {\r\ndev_dbg(&intf->dev, "bad notification endpoint\n");\r\ndev->status = NULL;\r\n}\r\n}\r\nif (rndis && !dev->status) {\r\ndev_dbg(&intf->dev, "missing RNDIS status endpoint\n");\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver, info->data);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\nbad_desc:\r\ndev_info(&dev->udev->dev, "bad CDC descriptors\n");\r\nreturn -ENODEV;\r\n}\r\nvoid usbnet_cdc_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_state *info = (void *) &dev->data;\r\nstruct usb_driver *driver = driver_of(intf);\r\nif (intf == info->control && info->data) {\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver, info->data);\r\ninfo->data = NULL;\r\n}\r\nelse if (intf == info->data && info->control) {\r\nusb_set_intfdata(info->control, NULL);\r\nusb_driver_release_interface(driver, info->control);\r\ninfo->control = NULL;\r\n}\r\n}\r\nstatic void dumpspeed(struct usbnet *dev, __le32 *speeds)\r\n{\r\nnetif_info(dev, timer, dev->net,\r\n"link speeds: %u kbps up, %u kbps down\n",\r\n__le32_to_cpu(speeds[0]) / 1000,\r\n__le32_to_cpu(speeds[1]) / 1000);\r\n}\r\nvoid usbnet_cdc_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct usb_cdc_notification *event;\r\nif (urb->actual_length < sizeof *event)\r\nreturn;\r\nif (test_and_clear_bit(EVENT_STS_SPLIT, &dev->flags)) {\r\ndumpspeed(dev, (__le32 *) urb->transfer_buffer);\r\nreturn;\r\n}\r\nevent = urb->transfer_buffer;\r\nswitch (event->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\nnetif_dbg(dev, timer, dev->net, "CDC: carrier %s\n",\r\nevent->wValue ? "on" : "off");\r\nif (event->wValue)\r\nnetif_carrier_on(dev->net);\r\nelse\r\nnetif_carrier_off(dev->net);\r\nbreak;\r\ncase USB_CDC_NOTIFY_SPEED_CHANGE:\r\nnetif_dbg(dev, timer, dev->net, "CDC: speed change (len %d)\n",\r\nurb->actual_length);\r\nif (urb->actual_length != (sizeof *event + 8))\r\nset_bit(EVENT_STS_SPLIT, &dev->flags);\r\nelse\r\ndumpspeed(dev, (__le32 *) &event[1]);\r\nbreak;\r\ndefault:\r\nnetdev_err(dev->net, "CDC: unexpected notification %02x!\n",\r\nevent->bNotificationType);\r\nbreak;\r\n}\r\n}\r\nint usbnet_cdc_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status;\r\nstruct cdc_state *info = (void *) &dev->data;\r\nBUILD_BUG_ON((sizeof(((struct usbnet *)0)->data)\r\n< sizeof(struct cdc_state)));\r\nstatus = usbnet_generic_cdc_bind(dev, intf);\r\nif (status < 0)\r\nreturn status;\r\nstatus = usbnet_get_ethernet_addr(dev, info->ether->iMACAddress);\r\nif (status < 0) {\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver_of(intf), info->data);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdc_manage_power(struct usbnet *dev, int on)\r\n{\r\ndev->intf->needs_remote_wakeup = on;\r\nreturn 0;\r\n}
