static void\r\nau1000_set_ac97_xmit_slots(struct snd_au1000 *au1000, long xmit_slots)\r\n{\r\nu32 volatile ac97_config;\r\nspin_lock(&au1000->ac97_lock);\r\nac97_config = au1000->ac97_ioport->config;\r\nac97_config = ac97_config & ~AC97C_XMIT_SLOTS_MASK;\r\nac97_config |= (xmit_slots << AC97C_XMIT_SLOTS_BIT);\r\nau1000->ac97_ioport->config = ac97_config;\r\nspin_unlock(&au1000->ac97_lock);\r\n}\r\nstatic void\r\nau1000_set_ac97_recv_slots(struct snd_au1000 *au1000, long recv_slots)\r\n{\r\nu32 volatile ac97_config;\r\nspin_lock(&au1000->ac97_lock);\r\nac97_config = au1000->ac97_ioport->config;\r\nac97_config = ac97_config & ~AC97C_RECV_SLOTS_MASK;\r\nac97_config |= (recv_slots << AC97C_RECV_SLOTS_BIT);\r\nau1000->ac97_ioport->config = ac97_config;\r\nspin_unlock(&au1000->ac97_lock);\r\n}\r\nstatic void\r\nau1000_release_dma_link(struct audio_stream *stream)\r\n{\r\nstruct au1000_period * pointer;\r\nstruct au1000_period * pointer_next;\r\nstream->period_size = 0;\r\nstream->periods = 0;\r\npointer = stream->buffer;\r\nif (! pointer)\r\nreturn;\r\ndo {\r\npointer_next = pointer->next;\r\nkfree(pointer);\r\npointer = pointer_next;\r\n} while (pointer != stream->buffer);\r\nstream->buffer = NULL;\r\n}\r\nstatic int\r\nau1000_setup_dma_link(struct audio_stream *stream, unsigned int period_bytes,\r\nunsigned int periods)\r\n{\r\nstruct snd_pcm_substream *substream = stream->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct au1000_period *pointer;\r\nunsigned long dma_start;\r\nint i;\r\ndma_start = virt_to_phys(runtime->dma_area);\r\nif (stream->period_size == period_bytes &&\r\nstream->periods == periods)\r\nreturn 0;\r\nau1000_release_dma_link(stream);\r\nstream->period_size = period_bytes;\r\nstream->periods = periods;\r\nstream->buffer = kmalloc(sizeof(struct au1000_period), GFP_KERNEL);\r\nif (! stream->buffer)\r\nreturn -ENOMEM;\r\npointer = stream->buffer;\r\nfor (i = 0; i < periods; i++) {\r\npointer->start = (u32)(dma_start + (i * period_bytes));\r\npointer->relative_end = (u32) (((i+1) * period_bytes) - 0x1);\r\nif (i < periods - 1) {\r\npointer->next = kmalloc(sizeof(struct au1000_period), GFP_KERNEL);\r\nif (! pointer->next) {\r\nau1000_release_dma_link(stream);\r\nreturn -ENOMEM;\r\n}\r\npointer = pointer->next;\r\n}\r\n}\r\npointer->next = stream->buffer;\r\nreturn 0;\r\n}\r\nstatic void\r\nau1000_dma_stop(struct audio_stream *stream)\r\n{\r\nif (snd_BUG_ON(!stream->buffer))\r\nreturn;\r\ndisable_dma(stream->dma);\r\n}\r\nstatic void\r\nau1000_dma_start(struct audio_stream *stream)\r\n{\r\nif (snd_BUG_ON(!stream->buffer))\r\nreturn;\r\ninit_dma(stream->dma);\r\nif (get_dma_active_buffer(stream->dma) == 0) {\r\nclear_dma_done0(stream->dma);\r\nset_dma_addr0(stream->dma, stream->buffer->start);\r\nset_dma_count0(stream->dma, stream->period_size >> 1);\r\nset_dma_addr1(stream->dma, stream->buffer->next->start);\r\nset_dma_count1(stream->dma, stream->period_size >> 1);\r\n} else {\r\nclear_dma_done1(stream->dma);\r\nset_dma_addr1(stream->dma, stream->buffer->start);\r\nset_dma_count1(stream->dma, stream->period_size >> 1);\r\nset_dma_addr0(stream->dma, stream->buffer->next->start);\r\nset_dma_count0(stream->dma, stream->period_size >> 1);\r\n}\r\nenable_dma_buffers(stream->dma);\r\nstart_dma(stream->dma);\r\n}\r\nstatic irqreturn_t\r\nau1000_dma_interrupt(int irq, void *dev_id)\r\n{\r\nstruct audio_stream *stream = (struct audio_stream *) dev_id;\r\nstruct snd_pcm_substream *substream = stream->substream;\r\nspin_lock(&stream->dma_lock);\r\nswitch (get_dma_buffer_done(stream->dma)) {\r\ncase DMA_D0:\r\nstream->buffer = stream->buffer->next;\r\nclear_dma_done0(stream->dma);\r\nset_dma_addr0(stream->dma, stream->buffer->next->start);\r\nset_dma_count0(stream->dma, stream->period_size >> 1);\r\nenable_dma_buffer0(stream->dma);\r\nbreak;\r\ncase DMA_D1:\r\nstream->buffer = stream->buffer->next;\r\nclear_dma_done1(stream->dma);\r\nset_dma_addr1(stream->dma, stream->buffer->next->start);\r\nset_dma_count1(stream->dma, stream->period_size >> 1);\r\nenable_dma_buffer1(stream->dma);\r\nbreak;\r\ncase (DMA_D0 | DMA_D1):\r\nprintk(KERN_ERR "DMA %d missed interrupt.\n",stream->dma);\r\nau1000_dma_stop(stream);\r\nau1000_dma_start(stream);\r\nbreak;\r\ncase (~DMA_D0 & ~DMA_D1):\r\nprintk(KERN_ERR "DMA %d empty irq.\n",stream->dma);\r\n}\r\nspin_unlock(&stream->dma_lock);\r\nsnd_pcm_period_elapsed(substream);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nsnd_au1000_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_au1000 *au1000 = substream->pcm->private_data;\r\nau1000->stream[PLAYBACK]->substream = substream;\r\nau1000->stream[PLAYBACK]->buffer = NULL;\r\nsubstream->private_data = au1000->stream[PLAYBACK];\r\nsubstream->runtime->hw = snd_au1000_hw;\r\nreturn (snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates) < 0);\r\n}\r\nstatic int\r\nsnd_au1000_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_au1000 *au1000 = substream->pcm->private_data;\r\nau1000->stream[CAPTURE]->substream = substream;\r\nau1000->stream[CAPTURE]->buffer = NULL;\r\nsubstream->private_data = au1000->stream[CAPTURE];\r\nsubstream->runtime->hw = snd_au1000_hw;\r\nreturn (snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates) < 0);\r\n}\r\nstatic int\r\nsnd_au1000_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_au1000 *au1000 = substream->pcm->private_data;\r\nau1000->stream[PLAYBACK]->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_au1000_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_au1000 *au1000 = substream->pcm->private_data;\r\nau1000->stream[CAPTURE]->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_au1000_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct audio_stream *stream = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nreturn au1000_setup_dma_link(stream,\r\nparams_period_bytes(hw_params),\r\nparams_periods(hw_params));\r\n}\r\nstatic int\r\nsnd_au1000_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct audio_stream *stream = substream->private_data;\r\nau1000_release_dma_link(stream);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int\r\nsnd_au1000_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_au1000 *au1000 = substream->pcm->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->channels == 1)\r\nau1000_set_ac97_xmit_slots(au1000, AC97_SLOT_4);\r\nelse\r\nau1000_set_ac97_xmit_slots(au1000, AC97_SLOT_3 | AC97_SLOT_4);\r\nsnd_ac97_set_rate(au1000->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_au1000_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_au1000 *au1000 = substream->pcm->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->channels == 1)\r\nau1000_set_ac97_recv_slots(au1000, AC97_SLOT_4);\r\nelse\r\nau1000_set_ac97_recv_slots(au1000, AC97_SLOT_3 | AC97_SLOT_4);\r\nsnd_ac97_set_rate(au1000->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_au1000_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct audio_stream *stream = substream->private_data;\r\nint err = 0;\r\nspin_lock(&stream->dma_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nau1000_dma_start(stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nau1000_dma_stop(stream);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&stream->dma_lock);\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_au1000_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct audio_stream *stream = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nlong location;\r\nspin_lock(&stream->dma_lock);\r\nlocation = get_dma_residue(stream->dma);\r\nspin_unlock(&stream->dma_lock);\r\nlocation = stream->buffer->relative_end - location;\r\nif (location == -1)\r\nlocation = 0;\r\nreturn bytes_to_frames(runtime,location);\r\n}\r\nstatic int __devinit\r\nsnd_au1000_pcm_new(struct snd_au1000 *au1000)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nunsigned long flags;\r\nif ((err = snd_pcm_new(au1000->card, "AU1000 AC97 PCM", 0, 1, 1, &pcm)) < 0)\r\nreturn err;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL), 128*1024, 128*1024);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_card_au1000_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_card_au1000_capture_ops);\r\npcm->private_data = au1000;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "Au1000 AC97 PCM");\r\nspin_lock_init(&au1000->stream[PLAYBACK]->dma_lock);\r\nspin_lock_init(&au1000->stream[CAPTURE]->dma_lock);\r\nflags = claim_dma_lock();\r\nif ((au1000->stream[PLAYBACK]->dma = request_au1000_dma(DMA_ID_AC97C_TX,\r\n"AC97 TX", au1000_dma_interrupt, 0,\r\nau1000->stream[PLAYBACK])) < 0) {\r\nrelease_dma_lock(flags);\r\nreturn -EBUSY;\r\n}\r\nif ((au1000->stream[CAPTURE]->dma = request_au1000_dma(DMA_ID_AC97C_RX,\r\n"AC97 RX", au1000_dma_interrupt, 0,\r\nau1000->stream[CAPTURE])) < 0){\r\nrelease_dma_lock(flags);\r\nreturn -EBUSY;\r\n}\r\nset_dma_mode(au1000->stream[PLAYBACK]->dma,\r\nget_dma_mode(au1000->stream[PLAYBACK]->dma) & ~DMA_NC);\r\nset_dma_mode(au1000->stream[CAPTURE]->dma,\r\nget_dma_mode(au1000->stream[CAPTURE]->dma) & ~DMA_NC);\r\nrelease_dma_lock(flags);\r\nau1000->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic unsigned short\r\nsnd_au1000_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct snd_au1000 *au1000 = ac97->private_data;\r\nu32 volatile cmd;\r\nu16 volatile data;\r\nint i;\r\nspin_lock(&au1000->ac97_lock);\r\nfor (i = 0; i < 0x5000; i++)\r\nif (!(au1000->ac97_ioport->status & AC97C_CP))\r\nbreak;\r\nif (i == 0x5000)\r\nprintk(KERN_ERR "au1000 AC97: AC97 command read timeout\n");\r\ncmd = (u32) reg & AC97C_INDEX_MASK;\r\ncmd |= AC97C_READ;\r\nau1000->ac97_ioport->cmd = cmd;\r\nfor (i = 0; i < 0x5000; i++)\r\nif (!(au1000->ac97_ioport->status & AC97C_CP))\r\nbreak;\r\nif (i == 0x5000) {\r\nprintk(KERN_ERR "au1000 AC97: AC97 command read timeout\n");\r\nspin_unlock(&au1000->ac97_lock);\r\nreturn 0;\r\n}\r\ndata = au1000->ac97_ioport->cmd & 0xffff;\r\nspin_unlock(&au1000->ac97_lock);\r\nreturn data;\r\n}\r\nstatic void\r\nsnd_au1000_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)\r\n{\r\nstruct snd_au1000 *au1000 = ac97->private_data;\r\nu32 cmd;\r\nint i;\r\nspin_lock(&au1000->ac97_lock);\r\nfor (i = 0; i < 0x5000; i++)\r\nif (!(au1000->ac97_ioport->status & AC97C_CP))\r\nbreak;\r\nif (i == 0x5000)\r\nprintk(KERN_ERR "au1000 AC97: AC97 command write timeout\n");\r\ncmd = (u32) reg & AC97C_INDEX_MASK;\r\ncmd &= ~AC97C_READ;\r\ncmd |= ((u32) val << AC97C_WD_BIT);\r\nau1000->ac97_ioport->cmd = cmd;\r\nspin_unlock(&au1000->ac97_lock);\r\n}\r\nstatic int __devinit\r\nsnd_au1000_ac97_new(struct snd_au1000 *au1000)\r\n{\r\nint err;\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_au1000_ac97_write,\r\n.read = snd_au1000_ac97_read,\r\n};\r\nif ((au1000->ac97_res_port = request_mem_region(CPHYSADDR(AC97C_CONFIG),\r\n0x100000, "Au1x00 AC97")) == NULL) {\r\nsnd_printk(KERN_ERR "ALSA AC97: can't grap AC97 port\n");\r\nreturn -EBUSY;\r\n}\r\nau1000->ac97_ioport = (struct au1000_ac97_reg *)\r\nKSEG1ADDR(au1000->ac97_res_port->start);\r\nspin_lock_init(&au1000->ac97_lock);\r\nau_writel(au_readl(SYS_PINFUNC) & ~0x02, SYS_PINFUNC);\r\nau1000->ac97_ioport->cntrl = AC97C_RS | AC97C_CE;\r\nudelay(10);\r\nau1000->ac97_ioport->cntrl = AC97C_CE;\r\nudelay(10);\r\nau1000->ac97_ioport->config = AC97C_RESET;\r\nudelay(10);\r\nau1000->ac97_ioport->config = 0x0;\r\nmdelay(5);\r\nif ((err = snd_ac97_bus(au1000->card, 0, &ops, au1000, &pbus)) < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = au1000;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &au1000->ac97)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_au1000_free(struct snd_card *card)\r\n{\r\nstruct snd_au1000 *au1000 = card->private_data;\r\nif (au1000->ac97_res_port) {\r\nau1000->ac97_ioport->cntrl = AC97C_RS;\r\nau1000->ac97_ioport = NULL;\r\nrelease_and_free_resource(au1000->ac97_res_port);\r\n}\r\nif (au1000->stream[PLAYBACK]) {\r\nif (au1000->stream[PLAYBACK]->dma >= 0)\r\nfree_au1000_dma(au1000->stream[PLAYBACK]->dma);\r\nkfree(au1000->stream[PLAYBACK]);\r\n}\r\nif (au1000->stream[CAPTURE]) {\r\nif (au1000->stream[CAPTURE]->dma >= 0)\r\nfree_au1000_dma(au1000->stream[CAPTURE]->dma);\r\nkfree(au1000->stream[CAPTURE]);\r\n}\r\n}\r\nstatic int __init\r\nau1000_init(void)\r\n{\r\nint err;\r\nstruct snd_card *card;\r\nstruct snd_au1000 *au1000;\r\nerr = snd_card_create(-1, "AC97", THIS_MODULE,\r\nsizeof(struct snd_au1000), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_au1000_free;\r\nau1000 = card->private_data;\r\nau1000->card = card;\r\nau1000->stream[PLAYBACK] = kmalloc(sizeof(struct audio_stream), GFP_KERNEL);\r\nau1000->stream[CAPTURE ] = kmalloc(sizeof(struct audio_stream), GFP_KERNEL);\r\nau1000->ac97_res_port = NULL;\r\nif (au1000->stream[PLAYBACK])\r\nau1000->stream[PLAYBACK]->dma = -1;\r\nif (au1000->stream[CAPTURE ])\r\nau1000->stream[CAPTURE ]->dma = -1;\r\nif (au1000->stream[PLAYBACK] == NULL ||\r\nau1000->stream[CAPTURE ] == NULL) {\r\nsnd_card_free(card);\r\nreturn -ENOMEM;\r\n}\r\nif ((err = snd_au1000_ac97_new(au1000)) < 0 ) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_au1000_pcm_new(au1000)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, "Au1000-AC97");\r\nstrcpy(card->shortname, "AMD Au1000-AC97");\r\nsprintf(card->longname, "AMD Au1000--AC97 ALSA Driver");\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "ALSA AC97: Driver Initialized\n");\r\nau1000_card = card;\r\nreturn 0;\r\n}\r\nstatic void __exit au1000_exit(void)\r\n{\r\nsnd_card_free(au1000_card);\r\n}
