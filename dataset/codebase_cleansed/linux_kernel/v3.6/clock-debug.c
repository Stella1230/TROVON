static int clock_debug_rate_set(void *data, u64 val)\r\n{\r\nstruct clk *clock = data;\r\nint ret;\r\nif (clock->flags & CLK_MAX)\r\nclk_set_max_rate(clock, val);\r\nif (clock->flags & CLK_MIN)\r\nret = clk_set_min_rate(clock, val);\r\nelse\r\nret = clk_set_rate(clock, val);\r\nif (ret != 0)\r\nprintk(KERN_ERR "clk_set%s_rate failed (%d)\n",\r\n(clock->flags & CLK_MIN) ? "_min" : "", ret);\r\nreturn ret;\r\n}\r\nstatic int clock_debug_rate_get(void *data, u64 *val)\r\n{\r\nstruct clk *clock = data;\r\n*val = clk_get_rate(clock);\r\nreturn 0;\r\n}\r\nstatic int clock_debug_enable_set(void *data, u64 val)\r\n{\r\nstruct clk *clock = data;\r\nint rc = 0;\r\nif (val)\r\nrc = clock->ops->enable(clock->id);\r\nelse\r\nclock->ops->disable(clock->id);\r\nreturn rc;\r\n}\r\nstatic int clock_debug_enable_get(void *data, u64 *val)\r\n{\r\nstruct clk *clock = data;\r\n*val = clock->ops->is_enabled(clock->id);\r\nreturn 0;\r\n}\r\nstatic int clock_debug_local_get(void *data, u64 *val)\r\n{\r\nstruct clk *clock = data;\r\n*val = clock->ops->is_local(clock->id);\r\nreturn 0;\r\n}\r\nint __init clock_debug_init(void)\r\n{\r\ndebugfs_base = debugfs_create_dir("clk", NULL);\r\nif (!debugfs_base)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint __init clock_debug_add(struct clk *clock)\r\n{\r\nchar temp[50], *ptr;\r\nstruct dentry *clk_dir;\r\nif (!debugfs_base)\r\nreturn -ENOMEM;\r\nstrncpy(temp, clock->dbg_name, ARRAY_SIZE(temp)-1);\r\nfor (ptr = temp; *ptr; ptr++)\r\n*ptr = tolower(*ptr);\r\nclk_dir = debugfs_create_dir(temp, debugfs_base);\r\nif (!clk_dir)\r\nreturn -ENOMEM;\r\nif (!debugfs_create_file("rate", S_IRUGO | S_IWUSR, clk_dir,\r\nclock, &clock_rate_fops))\r\ngoto error;\r\nif (!debugfs_create_file("enable", S_IRUGO | S_IWUSR, clk_dir,\r\nclock, &clock_enable_fops))\r\ngoto error;\r\nif (!debugfs_create_file("is_local", S_IRUGO, clk_dir, clock,\r\n&clock_local_fops))\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ndebugfs_remove_recursive(clk_dir);\r\nreturn -ENOMEM;\r\n}
