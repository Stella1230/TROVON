void\r\nnv50_fifo_playlist_update(struct drm_device *dev)\r\n{\r\nstruct nv50_fifo_priv *priv = nv_engine(dev, NVOBJ_ENGINE_FIFO);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *cur;\r\nint i, p;\r\ncur = priv->playlist[priv->cur_playlist];\r\npriv->cur_playlist = !priv->cur_playlist;\r\nfor (i = 0, p = 0; i < priv->base.channels; i++) {\r\nif (nv_rd32(dev, 0x002600 + (i * 4)) & 0x80000000)\r\nnv_wo32(cur, p++ * 4, i);\r\n}\r\ndev_priv->engine.instmem.flush(dev);\r\nnv_wr32(dev, 0x0032f4, cur->vinst >> 12);\r\nnv_wr32(dev, 0x0032ec, p);\r\nnv_wr32(dev, 0x002500, 0x00000101);\r\n}\r\nstatic int\r\nnv50_fifo_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nv50_fifo_priv *priv = nv_engine(chan->dev, engine);\r\nstruct nv50_fifo_chan *fctx;\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu64 ib_offset = chan->pushbuf_base + chan->dma.ib_base * 4;\r\nu64 instance = chan->ramin->vinst >> 12;\r\nunsigned long flags;\r\nint ret = 0, i;\r\nfctx = chan->engctx[engine] = kzalloc(sizeof(*fctx), GFP_KERNEL);\r\nif (!fctx)\r\nreturn -ENOMEM;\r\natomic_inc(&chan->vm->engref[engine]);\r\nchan->user = ioremap(pci_resource_start(dev->pdev, 0) +\r\nNV50_USER(chan->id), PAGE_SIZE);\r\nif (!chan->user) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nfor (i = 0; i < 0x100; i += 4)\r\nnv_wo32(chan->ramin, i, 0x00000000);\r\nnv_wo32(chan->ramin, 0x3c, 0x403f6078);\r\nnv_wo32(chan->ramin, 0x40, 0x00000000);\r\nnv_wo32(chan->ramin, 0x44, 0x01003fff);\r\nnv_wo32(chan->ramin, 0x48, chan->pushbuf->cinst >> 4);\r\nnv_wo32(chan->ramin, 0x50, lower_32_bits(ib_offset));\r\nnv_wo32(chan->ramin, 0x54, upper_32_bits(ib_offset) |\r\ndrm_order(chan->dma.ib_max + 1) << 16);\r\nnv_wo32(chan->ramin, 0x60, 0x7fffffff);\r\nnv_wo32(chan->ramin, 0x78, 0x00000000);\r\nnv_wo32(chan->ramin, 0x7c, 0x30000001);\r\nnv_wo32(chan->ramin, 0x80, ((chan->ramht->bits - 9) << 27) |\r\n(4 << 24) |\r\n(chan->ramht->gpuobj->cinst >> 4));\r\ndev_priv->engine.instmem.flush(dev);\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_wr32(dev, 0x002600 + (chan->id * 4), 0x80000000 | instance);\r\nnv50_fifo_playlist_update(dev);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nerror:\r\nif (ret)\r\npriv->base.base.context_del(chan, engine);\r\nreturn ret;\r\n}\r\nstatic bool\r\nnv50_fifo_kickoff(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nbool done = true;\r\nu32 me;\r\nme = nv_mask(dev, 0x00b860, 0x00000001, 0x00000001);\r\nnv_wr32(dev, 0x0032fc, chan->ramin->vinst >> 12);\r\nif (!nv_wait_ne(dev, 0x0032fc, 0xffffffff, 0xffffffff)) {\r\nNV_INFO(dev, "PFIFO: channel %d unload timeout\n", chan->id);\r\ndone = false;\r\n}\r\nnv_wr32(dev, 0x00b860, me);\r\nreturn done;\r\n}\r\nstatic void\r\nnv50_fifo_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nv50_fifo_chan *fctx = chan->engctx[engine];\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_mask(dev, 0x002600 + (chan->id * 4), 0x80000000, 0x00000000);\r\nnv50_fifo_playlist_update(dev);\r\nnv50_fifo_kickoff(chan);\r\nnv_wr32(dev, 0x002600 + (chan->id * 4), 0x00000000);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nif (chan->user) {\r\niounmap(chan->user);\r\nchan->user = NULL;\r\n}\r\natomic_dec(&chan->vm->engref[engine]);\r\nchan->engctx[engine] = NULL;\r\nkfree(fctx);\r\n}\r\nstatic int\r\nnv50_fifo_init(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 instance;\r\nint i;\r\nnv_mask(dev, 0x000200, 0x00000100, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x00000100, 0x00000100);\r\nnv_wr32(dev, 0x00250c, 0x6f3cfc34);\r\nnv_wr32(dev, 0x002044, 0x01003fff);\r\nnv_wr32(dev, 0x002100, 0xffffffff);\r\nnv_wr32(dev, 0x002140, 0xffffffff);\r\nfor (i = 0; i < 128; i++) {\r\nstruct nouveau_channel *chan = dev_priv->channels.ptr[i];\r\nif (chan && chan->engctx[engine])\r\ninstance = 0x80000000 | chan->ramin->vinst >> 12;\r\nelse\r\ninstance = 0x00000000;\r\nnv_wr32(dev, 0x002600 + (i * 4), instance);\r\n}\r\nnv50_fifo_playlist_update(dev);\r\nnv_wr32(dev, 0x003200, 1);\r\nnv_wr32(dev, 0x003250, 1);\r\nnv_wr32(dev, 0x002500, 1);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_fifo_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_fifo_priv *priv = nv_engine(dev, engine);\r\nint i;\r\nnv_wr32(dev, 0x0032ec, 0);\r\nfor (i = 0; i < priv->base.channels; i++) {\r\nstruct nouveau_channel *chan = dev_priv->channels.ptr[i];\r\nif (chan && !nv50_fifo_kickoff(chan))\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(dev, 0x002140, 0);\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_fifo_tlb_flush(struct drm_device *dev, int engine)\r\n{\r\nnv50_vm_flush_engine(dev, 5);\r\n}\r\nvoid\r\nnv50_fifo_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_fifo_priv *priv = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, 8);\r\nnouveau_gpuobj_ref(NULL, &priv->playlist[0]);\r\nnouveau_gpuobj_ref(NULL, &priv->playlist[1]);\r\ndev_priv->eng[engine] = NULL;\r\nkfree(priv);\r\n}\r\nint\r\nnv50_fifo_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_fifo_priv *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.base.destroy = nv50_fifo_destroy;\r\npriv->base.base.init = nv50_fifo_init;\r\npriv->base.base.fini = nv50_fifo_fini;\r\npriv->base.base.context_new = nv50_fifo_context_new;\r\npriv->base.base.context_del = nv50_fifo_context_del;\r\npriv->base.base.tlb_flush = nv50_fifo_tlb_flush;\r\npriv->base.channels = 127;\r\ndev_priv->eng[NVOBJ_ENGINE_FIFO] = &priv->base.base;\r\nret = nouveau_gpuobj_new(dev, NULL, priv->base.channels * 4, 0x1000,\r\nNVOBJ_FLAG_ZERO_ALLOC, &priv->playlist[0]);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_gpuobj_new(dev, NULL, priv->base.channels * 4, 0x1000,\r\nNVOBJ_FLAG_ZERO_ALLOC, &priv->playlist[1]);\r\nif (ret)\r\ngoto error;\r\nnouveau_irq_register(dev, 8, nv04_fifo_isr);\r\nerror:\r\nif (ret)\r\npriv->base.base.destroy(dev, NVOBJ_ENGINE_FIFO);\r\nreturn ret;\r\n}
