static void tulip_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nif (netif_running(dev))\r\nschedule_work(&tp->media_work);\r\n}\r\nstatic void tulip_set_power_state (struct tulip_private *tp,\r\nint sleep, int snooze)\r\n{\r\nif (tp->flags & HAS_ACPI) {\r\nu32 tmp, newtmp;\r\npci_read_config_dword (tp->pdev, CFDD, &tmp);\r\nnewtmp = tmp & ~(CFDD_Sleep | CFDD_Snooze);\r\nif (sleep)\r\nnewtmp |= CFDD_Sleep;\r\nelse if (snooze)\r\nnewtmp |= CFDD_Snooze;\r\nif (tmp != newtmp)\r\npci_write_config_dword (tp->pdev, CFDD, newtmp);\r\n}\r\n}\r\nstatic void tulip_up(struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nint next_tick = 3*HZ;\r\nu32 reg;\r\nint i;\r\n#ifdef CONFIG_TULIP_NAPI\r\nnapi_enable(&tp->napi);\r\n#endif\r\ntulip_set_power_state (tp, 0, 0);\r\npci_enable_wake(tp->pdev, PCI_D3hot, 0);\r\npci_enable_wake(tp->pdev, PCI_D3cold, 0);\r\ntulip_set_wolopts(tp->pdev, 0);\r\nif (tp->mii_cnt || (tp->mtable && tp->mtable->has_mii))\r\niowrite32(0x00040000, ioaddr + CSR6);\r\niowrite32(0x00000001, ioaddr + CSR0);\r\npci_read_config_dword(tp->pdev, PCI_COMMAND, &reg);\r\nudelay(100);\r\niowrite32(tp->csr0, ioaddr + CSR0);\r\npci_read_config_dword(tp->pdev, PCI_COMMAND, &reg);\r\nudelay(100);\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "tulip_up(), irq==%d\n", tp->pdev->irq);\r\niowrite32(tp->rx_ring_dma, ioaddr + CSR3);\r\niowrite32(tp->tx_ring_dma, ioaddr + CSR4);\r\ntp->cur_rx = tp->cur_tx = 0;\r\ntp->dirty_rx = tp->dirty_tx = 0;\r\nif (tp->flags & MC_HASH_ONLY) {\r\nu32 addr_low = get_unaligned_le32(dev->dev_addr);\r\nu32 addr_high = get_unaligned_le16(dev->dev_addr + 4);\r\nif (tp->chip_id == AX88140) {\r\niowrite32(0, ioaddr + CSR13);\r\niowrite32(addr_low, ioaddr + CSR14);\r\niowrite32(1, ioaddr + CSR13);\r\niowrite32(addr_high, ioaddr + CSR14);\r\n} else if (tp->flags & COMET_MAC_ADDR) {\r\niowrite32(addr_low, ioaddr + 0xA4);\r\niowrite32(addr_high, ioaddr + 0xA8);\r\niowrite32(0, ioaddr + CSR27);\r\niowrite32(0, ioaddr + CSR28);\r\n}\r\n} else {\r\nu16 *eaddrs = (u16 *)dev->dev_addr;\r\nu16 *setup_frm = &tp->setup_frame[15*6];\r\ndma_addr_t mapping;\r\nmemset(tp->setup_frame, 0xff, sizeof(tp->setup_frame));\r\n*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\r\n*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\r\n*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\r\nmapping = pci_map_single(tp->pdev, tp->setup_frame,\r\nsizeof(tp->setup_frame),\r\nPCI_DMA_TODEVICE);\r\ntp->tx_buffers[tp->cur_tx].skb = NULL;\r\ntp->tx_buffers[tp->cur_tx].mapping = mapping;\r\ntp->tx_ring[tp->cur_tx].length = cpu_to_le32(0x08000000 | 192);\r\ntp->tx_ring[tp->cur_tx].buffer1 = cpu_to_le32(mapping);\r\ntp->tx_ring[tp->cur_tx].status = cpu_to_le32(DescOwned);\r\ntp->cur_tx++;\r\n}\r\ntp->saved_if_port = dev->if_port;\r\nif (dev->if_port == 0)\r\ndev->if_port = tp->default_port;\r\ni = 0;\r\nif (tp->mtable == NULL)\r\ngoto media_picked;\r\nif (dev->if_port) {\r\nint looking_for = tulip_media_cap[dev->if_port] & MediaIsMII ? 11 :\r\n(dev->if_port == 12 ? 0 : dev->if_port);\r\nfor (i = 0; i < tp->mtable->leafcount; i++)\r\nif (tp->mtable->mleaf[i].media == looking_for) {\r\ndev_info(&dev->dev,\r\n"Using user-specified media %s\n",\r\nmedianame[dev->if_port]);\r\ngoto media_picked;\r\n}\r\n}\r\nif ((tp->mtable->defaultmedia & 0x0800) == 0) {\r\nint looking_for = tp->mtable->defaultmedia & MEDIA_MASK;\r\nfor (i = 0; i < tp->mtable->leafcount; i++)\r\nif (tp->mtable->mleaf[i].media == looking_for) {\r\ndev_info(&dev->dev,\r\n"Using EEPROM-set media %s\n",\r\nmedianame[looking_for]);\r\ngoto media_picked;\r\n}\r\n}\r\nfor (i = tp->mtable->leafcount - 1;\r\n(tulip_media_cap[tp->mtable->mleaf[i].media] & MediaAlwaysFD) && i > 0; i--)\r\n;\r\nmedia_picked:\r\ntp->csr6 = 0;\r\ntp->cur_index = i;\r\ntp->nwayset = 0;\r\nif (dev->if_port) {\r\nif (tp->chip_id == DC21143 &&\r\n(tulip_media_cap[dev->if_port] & MediaIsMII)) {\r\niowrite32(0x0000, ioaddr + CSR13);\r\niowrite32(0x0000, ioaddr + CSR14);\r\niowrite32(0x0008, ioaddr + CSR15);\r\n}\r\ntulip_select_media(dev, 1);\r\n} else if (tp->chip_id == DC21142) {\r\nif (tp->mii_cnt) {\r\ntulip_select_media(dev, 1);\r\nif (tulip_debug > 1)\r\ndev_info(&dev->dev,\r\n"Using MII transceiver %d, status %04x\n",\r\ntp->phys[0],\r\ntulip_mdio_read(dev, tp->phys[0], 1));\r\niowrite32(csr6_mask_defstate, ioaddr + CSR6);\r\ntp->csr6 = csr6_mask_hdcap;\r\ndev->if_port = 11;\r\niowrite32(0x0000, ioaddr + CSR13);\r\niowrite32(0x0000, ioaddr + CSR14);\r\n} else\r\nt21142_start_nway(dev);\r\n} else if (tp->chip_id == PNIC2) {\r\ntp->sym_advertise = 0x01E0;\r\niowrite32(ioread32(ioaddr+CSR5)| 0x00008010, ioaddr + CSR5);\r\niowrite32(ioread32(ioaddr+CSR7)| 0x00008010, ioaddr + CSR7);\r\npnic2_start_nway(dev);\r\n} else if (tp->chip_id == LC82C168 && ! tp->medialock) {\r\nif (tp->mii_cnt) {\r\ndev->if_port = 11;\r\ntp->csr6 = 0x814C0000 | (tp->full_duplex ? 0x0200 : 0);\r\niowrite32(0x0001, ioaddr + CSR15);\r\n} else if (ioread32(ioaddr + CSR5) & TPLnkPass)\r\npnic_do_nway(dev);\r\nelse {\r\niowrite32(0x32, ioaddr + CSR12);\r\ntp->csr6 = 0x00420000;\r\niowrite32(0x0001B078, ioaddr + 0xB8);\r\niowrite32(0x0201B078, ioaddr + 0xB8);\r\nnext_tick = 1*HZ;\r\n}\r\n} else if ((tp->chip_id == MX98713 || tp->chip_id == COMPEX9881) &&\r\n! tp->medialock) {\r\ndev->if_port = 0;\r\ntp->csr6 = 0x01880000 | (tp->full_duplex ? 0x0200 : 0);\r\niowrite32(0x0f370000 | ioread16(ioaddr + 0x80), ioaddr + 0x80);\r\n} else if (tp->chip_id == MX98715 || tp->chip_id == MX98725) {\r\ndev->if_port = 0;\r\ntp->csr6 = 0x01a80200;\r\niowrite32(0x0f370000 | ioread16(ioaddr + 0x80), ioaddr + 0x80);\r\niowrite32(0x11000 | ioread16(ioaddr + 0xa0), ioaddr + 0xa0);\r\n} else if (tp->chip_id == COMET || tp->chip_id == CONEXANT) {\r\niowrite32(ioread32(ioaddr + 0x88) | 1, ioaddr + 0x88);\r\ndev->if_port = tp->mii_cnt ? 11 : 0;\r\ntp->csr6 = 0x00040000;\r\n} else if (tp->chip_id == AX88140) {\r\ntp->csr6 = tp->mii_cnt ? 0x00040100 : 0x00000100;\r\n} else\r\ntulip_select_media(dev, 1);\r\ntulip_stop_rxtx(tp);\r\nbarrier();\r\nudelay(5);\r\niowrite32(tp->csr6 | TxOn, ioaddr + CSR6);\r\niowrite32(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR5);\r\niowrite32(tulip_tbl[tp->chip_id].valid_intrs, ioaddr + CSR7);\r\ntulip_start_rxtx(tp);\r\niowrite32(0, ioaddr + CSR2);\r\nif (tulip_debug > 2) {\r\nnetdev_dbg(dev, "Done tulip_up(), CSR0 %08x, CSR5 %08x CSR6 %08x\n",\r\nioread32(ioaddr + CSR0),\r\nioread32(ioaddr + CSR5),\r\nioread32(ioaddr + CSR6));\r\n}\r\ntp->timer.expires = RUN_AT(next_tick);\r\nadd_timer(&tp->timer);\r\n#ifdef CONFIG_TULIP_NAPI\r\ninit_timer(&tp->oom_timer);\r\ntp->oom_timer.data = (unsigned long)dev;\r\ntp->oom_timer.function = oom_timer;\r\n#endif\r\n}\r\nstatic int\r\ntulip_open(struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nint retval;\r\ntulip_init_ring (dev);\r\nretval = request_irq(tp->pdev->irq, tulip_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (retval)\r\ngoto free_ring;\r\ntulip_up (dev);\r\nnetif_start_queue (dev);\r\nreturn 0;\r\nfree_ring:\r\ntulip_free_ring (dev);\r\nreturn retval;\r\n}\r\nstatic void tulip_tx_timeout(struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave (&tp->lock, flags);\r\nif (tulip_media_cap[dev->if_port] & MediaIsMII) {\r\nif (tulip_debug > 1)\r\ndev_warn(&dev->dev,\r\n"Transmit timeout using MII device\n");\r\n} else if (tp->chip_id == DC21140 || tp->chip_id == DC21142 ||\r\ntp->chip_id == MX98713 || tp->chip_id == COMPEX9881 ||\r\ntp->chip_id == DM910X) {\r\ndev_warn(&dev->dev,\r\n"21140 transmit timed out, status %08x, SIA %08x %08x %08x %08x, resetting...\n",\r\nioread32(ioaddr + CSR5), ioread32(ioaddr + CSR12),\r\nioread32(ioaddr + CSR13), ioread32(ioaddr + CSR14),\r\nioread32(ioaddr + CSR15));\r\ntp->timeout_recovery = 1;\r\nschedule_work(&tp->media_work);\r\ngoto out_unlock;\r\n} else if (tp->chip_id == PNIC2) {\r\ndev_warn(&dev->dev,\r\n"PNIC2 transmit timed out, status %08x, CSR6/7 %08x / %08x CSR12 %08x, resetting...\n",\r\n(int)ioread32(ioaddr + CSR5),\r\n(int)ioread32(ioaddr + CSR6),\r\n(int)ioread32(ioaddr + CSR7),\r\n(int)ioread32(ioaddr + CSR12));\r\n} else {\r\ndev_warn(&dev->dev,\r\n"Transmit timed out, status %08x, CSR12 %08x, resetting...\n",\r\nioread32(ioaddr + CSR5), ioread32(ioaddr + CSR12));\r\ndev->if_port = 0;\r\n}\r\n#if defined(way_too_many_messages)\r\nif (tulip_debug > 3) {\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nu8 *buf = (u8 *)(tp->rx_ring[i].buffer1);\r\nint j;\r\nprintk(KERN_DEBUG\r\n"%2d: %08x %08x %08x %08x %02x %02x %02x\n",\r\ni,\r\n(unsigned int)tp->rx_ring[i].status,\r\n(unsigned int)tp->rx_ring[i].length,\r\n(unsigned int)tp->rx_ring[i].buffer1,\r\n(unsigned int)tp->rx_ring[i].buffer2,\r\nbuf[0], buf[1], buf[2]);\r\nfor (j = 0; buf[j] != 0xee && j < 1600; j++)\r\nif (j < 100)\r\npr_cont(" %02x", buf[j]);\r\npr_cont(" j=%d\n", j);\r\n}\r\nprintk(KERN_DEBUG " Rx ring %p: ", tp->rx_ring);\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\npr_cont(" %08x", (unsigned int)tp->rx_ring[i].status);\r\nprintk(KERN_DEBUG " Tx ring %p: ", tp->tx_ring);\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\npr_cont(" %08x", (unsigned int)tp->tx_ring[i].status);\r\npr_cont("\n");\r\n}\r\n#endif\r\ntulip_tx_timeout_complete(tp, ioaddr);\r\nout_unlock:\r\nspin_unlock_irqrestore (&tp->lock, flags);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue (dev);\r\n}\r\nstatic void tulip_init_ring(struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nint i;\r\ntp->susp_rx = 0;\r\ntp->ttimer = 0;\r\ntp->nir = 0;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\ntp->rx_ring[i].status = 0x00000000;\r\ntp->rx_ring[i].length = cpu_to_le32(PKT_BUF_SZ);\r\ntp->rx_ring[i].buffer2 = cpu_to_le32(tp->rx_ring_dma + sizeof(struct tulip_rx_desc) * (i + 1));\r\ntp->rx_buffers[i].skb = NULL;\r\ntp->rx_buffers[i].mapping = 0;\r\n}\r\ntp->rx_ring[i-1].length = cpu_to_le32(PKT_BUF_SZ | DESC_RING_WRAP);\r\ntp->rx_ring[i-1].buffer2 = cpu_to_le32(tp->rx_ring_dma);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\ndma_addr_t mapping;\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, PKT_BUF_SZ);\r\ntp->rx_buffers[i].skb = skb;\r\nif (skb == NULL)\r\nbreak;\r\nmapping = pci_map_single(tp->pdev, skb->data,\r\nPKT_BUF_SZ, PCI_DMA_FROMDEVICE);\r\ntp->rx_buffers[i].mapping = mapping;\r\ntp->rx_ring[i].status = cpu_to_le32(DescOwned);\r\ntp->rx_ring[i].buffer1 = cpu_to_le32(mapping);\r\n}\r\ntp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\ntp->tx_buffers[i].skb = NULL;\r\ntp->tx_buffers[i].mapping = 0;\r\ntp->tx_ring[i].status = 0x00000000;\r\ntp->tx_ring[i].buffer2 = cpu_to_le32(tp->tx_ring_dma + sizeof(struct tulip_tx_desc) * (i + 1));\r\n}\r\ntp->tx_ring[i-1].buffer2 = cpu_to_le32(tp->tx_ring_dma);\r\n}\r\nstatic netdev_tx_t\r\ntulip_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nint entry;\r\nu32 flag;\r\ndma_addr_t mapping;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tp->lock, flags);\r\nentry = tp->cur_tx % TX_RING_SIZE;\r\ntp->tx_buffers[entry].skb = skb;\r\nmapping = pci_map_single(tp->pdev, skb->data,\r\nskb->len, PCI_DMA_TODEVICE);\r\ntp->tx_buffers[entry].mapping = mapping;\r\ntp->tx_ring[entry].buffer1 = cpu_to_le32(mapping);\r\nif (tp->cur_tx - tp->dirty_tx < TX_RING_SIZE/2) {\r\nflag = 0x60000000;\r\n} else if (tp->cur_tx - tp->dirty_tx == TX_RING_SIZE/2) {\r\nflag = 0xe0000000;\r\n} else if (tp->cur_tx - tp->dirty_tx < TX_RING_SIZE - 2) {\r\nflag = 0x60000000;\r\n} else {\r\nflag = 0xe0000000;\r\nnetif_stop_queue(dev);\r\n}\r\nif (entry == TX_RING_SIZE-1)\r\nflag = 0xe0000000 | DESC_RING_WRAP;\r\ntp->tx_ring[entry].length = cpu_to_le32(skb->len | flag);\r\ntp->tx_ring[entry].status = cpu_to_le32(DescOwned);\r\nwmb();\r\ntp->cur_tx++;\r\niowrite32(0, tp->base_addr + CSR1);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void tulip_clean_tx_ring(struct tulip_private *tp)\r\n{\r\nunsigned int dirty_tx;\r\nfor (dirty_tx = tp->dirty_tx ; tp->cur_tx - dirty_tx > 0;\r\ndirty_tx++) {\r\nint entry = dirty_tx % TX_RING_SIZE;\r\nint status = le32_to_cpu(tp->tx_ring[entry].status);\r\nif (status < 0) {\r\ntp->dev->stats.tx_errors++;\r\ntp->tx_ring[entry].status = 0;\r\n}\r\nif (tp->tx_buffers[entry].skb == NULL) {\r\nif (tp->tx_buffers[entry].mapping)\r\npci_unmap_single(tp->pdev,\r\ntp->tx_buffers[entry].mapping,\r\nsizeof(tp->setup_frame),\r\nPCI_DMA_TODEVICE);\r\ncontinue;\r\n}\r\npci_unmap_single(tp->pdev, tp->tx_buffers[entry].mapping,\r\ntp->tx_buffers[entry].skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(tp->tx_buffers[entry].skb);\r\ntp->tx_buffers[entry].skb = NULL;\r\ntp->tx_buffers[entry].mapping = 0;\r\n}\r\n}\r\nstatic void tulip_down (struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nunsigned long flags;\r\ncancel_work_sync(&tp->media_work);\r\n#ifdef CONFIG_TULIP_NAPI\r\nnapi_disable(&tp->napi);\r\n#endif\r\ndel_timer_sync (&tp->timer);\r\n#ifdef CONFIG_TULIP_NAPI\r\ndel_timer_sync (&tp->oom_timer);\r\n#endif\r\nspin_lock_irqsave (&tp->lock, flags);\r\niowrite32 (0x00000000, ioaddr + CSR7);\r\ntulip_stop_rxtx(tp);\r\ntulip_refill_rx(dev);\r\ntulip_clean_tx_ring(tp);\r\nif (ioread32(ioaddr + CSR6) != 0xffffffff)\r\ndev->stats.rx_missed_errors += ioread32(ioaddr + CSR8) & 0xffff;\r\nspin_unlock_irqrestore (&tp->lock, flags);\r\ninit_timer(&tp->timer);\r\ntp->timer.data = (unsigned long)dev;\r\ntp->timer.function = tulip_tbl[tp->chip_id].media_timer;\r\ndev->if_port = tp->saved_if_port;\r\ntulip_set_power_state (tp, 0, 1);\r\n}\r\nstatic void tulip_free_ring (struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = tp->rx_buffers[i].skb;\r\ndma_addr_t mapping = tp->rx_buffers[i].mapping;\r\ntp->rx_buffers[i].skb = NULL;\r\ntp->rx_buffers[i].mapping = 0;\r\ntp->rx_ring[i].status = 0;\r\ntp->rx_ring[i].length = 0;\r\ntp->rx_ring[i].buffer1 = cpu_to_le32(0xBADF00D0);\r\nif (skb) {\r\npci_unmap_single(tp->pdev, mapping, PKT_BUF_SZ,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb (skb);\r\n}\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = tp->tx_buffers[i].skb;\r\nif (skb != NULL) {\r\npci_unmap_single(tp->pdev, tp->tx_buffers[i].mapping,\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb (skb);\r\n}\r\ntp->tx_buffers[i].skb = NULL;\r\ntp->tx_buffers[i].mapping = 0;\r\n}\r\n}\r\nstatic int tulip_close (struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nnetif_stop_queue (dev);\r\ntulip_down (dev);\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "Shutting down ethercard, status was %02x\n",\r\nioread32 (ioaddr + CSR5));\r\nfree_irq (tp->pdev->irq, dev);\r\ntulip_free_ring (dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *tulip_get_stats(struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nif (netif_running(dev)) {\r\nunsigned long flags;\r\nspin_lock_irqsave (&tp->lock, flags);\r\ndev->stats.rx_missed_errors += ioread32(ioaddr + CSR8) & 0xffff;\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void tulip_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct tulip_private *np = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(np->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int tulip_ethtool_set_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nif (wolinfo->wolopts & (~tp->wolinfo.supported))\r\nreturn -EOPNOTSUPP;\r\ntp->wolinfo.wolopts = wolinfo->wolopts;\r\ndevice_set_wakeup_enable(&tp->pdev->dev, tp->wolinfo.wolopts);\r\nreturn 0;\r\n}\r\nstatic void tulip_ethtool_get_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nwolinfo->supported = tp->wolinfo.supported;\r\nwolinfo->wolopts = tp->wolinfo.wolopts;\r\nreturn;\r\n}\r\nstatic int private_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nconst unsigned int phy_idx = 0;\r\nint phy = tp->phys[phy_idx] & 0x1f;\r\nunsigned int regnum = data->reg_num;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\nif (tp->mii_cnt)\r\ndata->phy_id = phy;\r\nelse if (tp->flags & HAS_NWAY)\r\ndata->phy_id = 32;\r\nelse if (tp->chip_id == COMET)\r\ndata->phy_id = 1;\r\nelse\r\nreturn -ENODEV;\r\ncase SIOCGMIIREG:\r\nif (data->phy_id == 32 && (tp->flags & HAS_NWAY)) {\r\nint csr12 = ioread32 (ioaddr + CSR12);\r\nint csr14 = ioread32 (ioaddr + CSR14);\r\nswitch (regnum) {\r\ncase 0:\r\nif (((csr14<<5) & 0x1000) ||\r\n(dev->if_port == 5 && tp->nwayset))\r\ndata->val_out = 0x1000;\r\nelse\r\ndata->val_out = (tulip_media_cap[dev->if_port]&MediaIs100 ? 0x2000 : 0)\r\n| (tulip_media_cap[dev->if_port]&MediaIsFD ? 0x0100 : 0);\r\nbreak;\r\ncase 1:\r\ndata->val_out =\r\n0x1848 +\r\n((csr12&0x7000) == 0x5000 ? 0x20 : 0) +\r\n((csr12&0x06) == 6 ? 0 : 4);\r\ndata->val_out |= 0x6048;\r\nbreak;\r\ncase 4:\r\ndata->val_out =\r\n((ioread32(ioaddr + CSR6) >> 3) & 0x0040) +\r\n((csr14 >> 1) & 0x20) + 1;\r\ndata->val_out |= ((csr14 >> 9) & 0x03C0);\r\nbreak;\r\ncase 5: data->val_out = tp->lpar; break;\r\ndefault: data->val_out = 0; break;\r\n}\r\n} else {\r\ndata->val_out = tulip_mdio_read (dev, data->phy_id & 0x1f, regnum);\r\n}\r\nreturn 0;\r\ncase SIOCSMIIREG:\r\nif (regnum & ~0x1f)\r\nreturn -EINVAL;\r\nif (data->phy_id == phy) {\r\nu16 value = data->val_in;\r\nswitch (regnum) {\r\ncase 0:\r\ntp->full_duplex_lock = (value & 0x9000) ? 0 : 1;\r\nif (tp->full_duplex_lock)\r\ntp->full_duplex = (value & 0x0100) ? 1 : 0;\r\nbreak;\r\ncase 4:\r\ntp->advertising[phy_idx] =\r\ntp->mii_advertise = data->val_in;\r\nbreak;\r\n}\r\n}\r\nif (data->phy_id == 32 && (tp->flags & HAS_NWAY)) {\r\nu16 value = data->val_in;\r\nif (regnum == 0) {\r\nif ((value & 0x1200) == 0x1200) {\r\nif (tp->chip_id == PNIC2) {\r\npnic2_start_nway (dev);\r\n} else {\r\nt21142_start_nway (dev);\r\n}\r\n}\r\n} else if (regnum == 4)\r\ntp->sym_advertise = value;\r\n} else {\r\ntulip_mdio_write (dev, data->phy_id & 0x1f, regnum, data->val_in);\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void build_setup_frame_hash(u16 *setup_frm, struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nu16 hash_table[32];\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nu16 *eaddrs;\r\nmemset(hash_table, 0, sizeof(hash_table));\r\nset_bit_le(255, hash_table);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint index = ether_crc_le(ETH_ALEN, ha->addr) & 0x1ff;\r\nset_bit_le(index, hash_table);\r\n}\r\nfor (i = 0; i < 32; i++) {\r\n*setup_frm++ = hash_table[i];\r\n*setup_frm++ = hash_table[i];\r\n}\r\nsetup_frm = &tp->setup_frame[13*6];\r\neaddrs = (u16 *)dev->dev_addr;\r\n*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\r\n*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\r\n*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\r\n}\r\nstatic void build_setup_frame_perfect(u16 *setup_frm, struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nu16 *eaddrs;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\neaddrs = (u16 *) ha->addr;\r\n*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\r\n*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\r\n*setup_frm++ = *eaddrs; *setup_frm++ = *eaddrs++;\r\n}\r\nmemset(setup_frm, 0xff, (15 - netdev_mc_count(dev)) * 12);\r\nsetup_frm = &tp->setup_frame[15*6];\r\neaddrs = (u16 *)dev->dev_addr;\r\n*setup_frm++ = eaddrs[0]; *setup_frm++ = eaddrs[0];\r\n*setup_frm++ = eaddrs[1]; *setup_frm++ = eaddrs[1];\r\n*setup_frm++ = eaddrs[2]; *setup_frm++ = eaddrs[2];\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nint csr6;\r\ncsr6 = ioread32(ioaddr + CSR6) & ~0x00D5;\r\ntp->csr6 &= ~0x00D5;\r\nif (dev->flags & IFF_PROMISC) {\r\ntp->csr6 |= AcceptAllMulticast | AcceptAllPhys;\r\ncsr6 |= AcceptAllMulticast | AcceptAllPhys;\r\n} else if ((netdev_mc_count(dev) > 1000) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\ntp->csr6 |= AcceptAllMulticast;\r\ncsr6 |= AcceptAllMulticast;\r\n} else if (tp->flags & MC_HASH_ONLY) {\r\nstruct netdev_hw_addr *ha;\r\nif (netdev_mc_count(dev) > 64) {\r\ntp->csr6 |= AcceptAllMulticast;\r\ncsr6 |= AcceptAllMulticast;\r\n} else {\r\nu32 mc_filter[2] = {0, 0};\r\nint filterbit;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (tp->flags & COMET_MAC_ADDR)\r\nfilterbit = ether_crc_le(ETH_ALEN,\r\nha->addr);\r\nelse\r\nfilterbit = ether_crc(ETH_ALEN,\r\nha->addr) >> 26;\r\nfilterbit &= 0x3f;\r\nmc_filter[filterbit >> 5] |= 1 << (filterbit & 31);\r\nif (tulip_debug > 2)\r\ndev_info(&dev->dev,\r\n"Added filter for %pM %08x bit %d\n",\r\nha->addr,\r\nether_crc(ETH_ALEN, ha->addr),\r\nfilterbit);\r\n}\r\nif (mc_filter[0] == tp->mc_filter[0] &&\r\nmc_filter[1] == tp->mc_filter[1])\r\n;\r\nelse if (tp->flags & IS_ASIX) {\r\niowrite32(2, ioaddr + CSR13);\r\niowrite32(mc_filter[0], ioaddr + CSR14);\r\niowrite32(3, ioaddr + CSR13);\r\niowrite32(mc_filter[1], ioaddr + CSR14);\r\n} else if (tp->flags & COMET_MAC_ADDR) {\r\niowrite32(mc_filter[0], ioaddr + CSR27);\r\niowrite32(mc_filter[1], ioaddr + CSR28);\r\n}\r\ntp->mc_filter[0] = mc_filter[0];\r\ntp->mc_filter[1] = mc_filter[1];\r\n}\r\n} else {\r\nunsigned long flags;\r\nu32 tx_flags = 0x08000000 | 192;\r\nif (netdev_mc_count(dev) > 14) {\r\nbuild_setup_frame_hash(tp->setup_frame, dev);\r\ntx_flags = 0x08400000 | 192;\r\n} else {\r\nbuild_setup_frame_perfect(tp->setup_frame, dev);\r\n}\r\nspin_lock_irqsave(&tp->lock, flags);\r\nif (tp->cur_tx - tp->dirty_tx > TX_RING_SIZE - 2) {\r\n} else {\r\nunsigned int entry;\r\nint dummy = -1;\r\nentry = tp->cur_tx++ % TX_RING_SIZE;\r\nif (entry != 0) {\r\ntp->tx_buffers[entry].skb = NULL;\r\ntp->tx_buffers[entry].mapping = 0;\r\ntp->tx_ring[entry].length =\r\n(entry == TX_RING_SIZE-1) ? cpu_to_le32(DESC_RING_WRAP) : 0;\r\ntp->tx_ring[entry].buffer1 = 0;\r\ndummy = entry;\r\nentry = tp->cur_tx++ % TX_RING_SIZE;\r\n}\r\ntp->tx_buffers[entry].skb = NULL;\r\ntp->tx_buffers[entry].mapping =\r\npci_map_single(tp->pdev, tp->setup_frame,\r\nsizeof(tp->setup_frame),\r\nPCI_DMA_TODEVICE);\r\nif (entry == TX_RING_SIZE-1)\r\ntx_flags |= DESC_RING_WRAP;\r\ntp->tx_ring[entry].length = cpu_to_le32(tx_flags);\r\ntp->tx_ring[entry].buffer1 =\r\ncpu_to_le32(tp->tx_buffers[entry].mapping);\r\ntp->tx_ring[entry].status = cpu_to_le32(DescOwned);\r\nif (dummy >= 0)\r\ntp->tx_ring[dummy].status = cpu_to_le32(DescOwned);\r\nif (tp->cur_tx - tp->dirty_tx >= TX_RING_SIZE - 2)\r\nnetif_stop_queue(dev);\r\niowrite32(0, ioaddr + CSR1);\r\n}\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\n}\r\niowrite32(csr6, ioaddr + CSR6);\r\n}\r\nstatic void __devinit tulip_mwi_config (struct pci_dev *pdev,\r\nstruct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nu8 cache;\r\nu16 pci_command;\r\nu32 csr0;\r\nif (tulip_debug > 3)\r\nnetdev_dbg(dev, "tulip_mwi_config()\n");\r\ntp->csr0 = csr0 = 0;\r\ncsr0 |= MRM | MWI;\r\npci_try_set_mwi(pdev);\r\npci_read_config_word(pdev, PCI_COMMAND, &pci_command);\r\nif ((csr0 & MWI) && (!(pci_command & PCI_COMMAND_INVALIDATE)))\r\ncsr0 &= ~MWI;\r\npci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &cache);\r\nif ((csr0 & MWI) && (cache == 0)) {\r\ncsr0 &= ~MWI;\r\npci_clear_mwi(pdev);\r\n}\r\nswitch (cache) {\r\ncase 8:\r\ncsr0 |= MRL | (1 << CALShift) | (16 << BurstLenShift);\r\nbreak;\r\ncase 16:\r\ncsr0 |= MRL | (2 << CALShift) | (16 << BurstLenShift);\r\nbreak;\r\ncase 32:\r\ncsr0 |= MRL | (3 << CALShift) | (32 << BurstLenShift);\r\nbreak;\r\ndefault:\r\ncache = 0;\r\nbreak;\r\n}\r\nif (cache)\r\ngoto out;\r\nif (csr0 & MWI) {\r\npci_clear_mwi(pdev);\r\ncsr0 &= ~MWI;\r\n}\r\ncsr0 |= (8 << BurstLenShift) | (1 << CALShift);\r\nout:\r\ntp->csr0 = csr0;\r\nif (tulip_debug > 2)\r\nnetdev_dbg(dev, "MWI config cacheline=%d, csr0=%08x\n",\r\ncache, csr0);\r\n}\r\nstatic int tulip_uli_dm_quirk(struct pci_dev *pdev)\r\n{\r\nif (pdev->vendor == 0x1282 && pdev->device == 0x9102)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __devinit tulip_init_one (struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct tulip_private *tp;\r\nstatic unsigned char last_phys_addr[6] = {0x00, 'L', 'i', 'n', 'u', 'x'};\r\nstatic int last_irq;\r\nstatic int multiport_cnt;\r\nint i, irq;\r\nunsigned short sum;\r\nunsigned char *ee_data;\r\nstruct net_device *dev;\r\nvoid __iomem *ioaddr;\r\nstatic int board_idx = -1;\r\nint chip_idx = ent->driver_data;\r\nconst char *chip_name = tulip_tbl[chip_idx].chip_name;\r\nunsigned int eeprom_missing = 0;\r\nunsigned int force_csr0 = 0;\r\n#ifndef MODULE\r\nif (tulip_debug > 0)\r\nprintk_once(KERN_INFO "%s", version);\r\n#endif\r\nboard_idx++;\r\nif (pdev->subsystem_vendor == PCI_VENDOR_ID_LMC) {\r\npr_err("skipping LMC card\n");\r\nreturn -ENODEV;\r\n} else if (pdev->subsystem_vendor == PCI_VENDOR_ID_SBE &&\r\n(pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_T3E3 ||\r\npdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P0 ||\r\npdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P1)) {\r\npr_err("skipping SBE T3E3 port\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_TULIP_DM910X\r\nif (chip_idx == DM910X) {\r\nstruct device_node *dp;\r\nif (pdev->vendor == 0x1282 && pdev->device == 0x9100 &&\r\npdev->revision < 0x30) {\r\npr_info("skipping early DM9100 with Crc bug (use dmfe)\n");\r\nreturn -ENODEV;\r\n}\r\ndp = pci_device_to_OF_node(pdev);\r\nif (!(dp && of_get_property(dp, "local-mac-address", NULL))) {\r\npr_info("skipping DM910x expansion card (use dmfe)\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\n#endif\r\nif (pci_dev_present(early_486_chipsets)) {\r\ncsr0 = MRL | MRM | (8 << BurstLenShift) | (1 << CALShift);\r\nforce_csr0 = 1;\r\n}\r\nif (chip_idx == AX88140) {\r\nif ((csr0 & 0x3f00) == 0)\r\ncsr0 |= 0x2000;\r\n}\r\nif (chip_idx == LC82C168)\r\ncsr0 &= ~0xfff10000;\r\nif (tulip_uli_dm_quirk(pdev)) {\r\ncsr0 &= ~0x01f100ff;\r\n#if defined(CONFIG_SPARC)\r\ncsr0 = (csr0 & ~0xff00) | 0xe000;\r\n#endif\r\n}\r\ni = pci_enable_device(pdev);\r\nif (i) {\r\npr_err("Cannot enable tulip board #%d, aborting\n", board_idx);\r\nreturn i;\r\n}\r\nif (pci_set_power_state(pdev, PCI_D0)) {\r\npr_notice("Failed to set power state to D0\n");\r\n}\r\nirq = pdev->irq;\r\ndev = alloc_etherdev (sizeof (*tp));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nif (pci_resource_len (pdev, 0) < tulip_tbl[chip_idx].io_size) {\r\npr_err("%s: I/O region (0x%llx@0x%llx) too small, aborting\n",\r\npci_name(pdev),\r\n(unsigned long long)pci_resource_len (pdev, 0),\r\n(unsigned long long)pci_resource_start (pdev, 0));\r\ngoto err_out_free_netdev;\r\n}\r\nif (pci_request_regions (pdev, DRV_NAME))\r\ngoto err_out_free_netdev;\r\nioaddr = pci_iomap(pdev, TULIP_BAR, tulip_tbl[chip_idx].io_size);\r\nif (!ioaddr)\r\ngoto err_out_free_res;\r\ntp = netdev_priv(dev);\r\ntp->dev = dev;\r\ntp->rx_ring = pci_alloc_consistent(pdev,\r\nsizeof(struct tulip_rx_desc) * RX_RING_SIZE +\r\nsizeof(struct tulip_tx_desc) * TX_RING_SIZE,\r\n&tp->rx_ring_dma);\r\nif (!tp->rx_ring)\r\ngoto err_out_mtable;\r\ntp->tx_ring = (struct tulip_tx_desc *)(tp->rx_ring + RX_RING_SIZE);\r\ntp->tx_ring_dma = tp->rx_ring_dma + sizeof(struct tulip_rx_desc) * RX_RING_SIZE;\r\ntp->chip_id = chip_idx;\r\ntp->flags = tulip_tbl[chip_idx].flags;\r\ntp->wolinfo.supported = 0;\r\ntp->wolinfo.wolopts = 0;\r\nif (chip_idx == COMET ) {\r\nu32 sig;\r\npci_read_config_dword (pdev, 0x80, &sig);\r\nif (sig == 0x09811317) {\r\ntp->flags |= COMET_PM;\r\ntp->wolinfo.supported = WAKE_PHY | WAKE_MAGIC;\r\npr_info("%s: Enabled WOL support for AN983B\n",\r\n__func__);\r\n}\r\n}\r\ntp->pdev = pdev;\r\ntp->base_addr = ioaddr;\r\ntp->revision = pdev->revision;\r\ntp->csr0 = csr0;\r\nspin_lock_init(&tp->lock);\r\nspin_lock_init(&tp->mii_lock);\r\ninit_timer(&tp->timer);\r\ntp->timer.data = (unsigned long)dev;\r\ntp->timer.function = tulip_tbl[tp->chip_id].media_timer;\r\nINIT_WORK(&tp->media_work, tulip_tbl[tp->chip_id].media_task);\r\n#ifdef CONFIG_TULIP_MWI\r\nif (!force_csr0 && (tp->flags & HAS_PCI_MWI))\r\ntulip_mwi_config (pdev, dev);\r\n#endif\r\ntulip_stop_rxtx(tp);\r\npci_set_master(pdev);\r\n#ifdef CONFIG_GSC\r\nif (pdev->subsystem_vendor == PCI_VENDOR_ID_HP) {\r\nswitch (pdev->subsystem_device) {\r\ndefault:\r\nbreak;\r\ncase 0x1061:\r\ncase 0x1062:\r\ncase 0x1063:\r\ncase 0x1098:\r\ncase 0x1099:\r\ncase 0x10EE:\r\ntp->flags |= HAS_SWAPPED_SEEPROM | NEEDS_FAKE_MEDIA_TABLE;\r\nchip_name = "GSC DS21140 Tulip";\r\n}\r\n}\r\n#endif\r\nioread32(ioaddr + CSR8);\r\nee_data = tp->eeprom;\r\nmemset(ee_data, 0, sizeof(tp->eeprom));\r\nsum = 0;\r\nif (chip_idx == LC82C168) {\r\nfor (i = 0; i < 3; i++) {\r\nint value, boguscnt = 100000;\r\niowrite32(0x600 | i, ioaddr + 0x98);\r\ndo {\r\nvalue = ioread32(ioaddr + CSR9);\r\n} while (value < 0 && --boguscnt > 0);\r\nput_unaligned_le16(value, ((__le16 *)dev->dev_addr) + i);\r\nsum += value & 0xffff;\r\n}\r\n} else if (chip_idx == COMET) {\r\nput_unaligned_le32(ioread32(ioaddr + 0xA4), dev->dev_addr);\r\nput_unaligned_le16(ioread32(ioaddr + 0xA8), dev->dev_addr + 4);\r\nfor (i = 0; i < 6; i ++)\r\nsum += dev->dev_addr[i];\r\n} else {\r\nint sa_offset = 0;\r\nint ee_addr_size = tulip_read_eeprom(dev, 0xff, 8) & 0x40000 ? 8 : 6;\r\nint ee_max_addr = ((1 << ee_addr_size) - 1) * sizeof(u16);\r\nif (ee_max_addr > sizeof(tp->eeprom))\r\nee_max_addr = sizeof(tp->eeprom);\r\nfor (i = 0; i < ee_max_addr ; i += sizeof(u16)) {\r\nu16 data = tulip_read_eeprom(dev, i/2, ee_addr_size);\r\nee_data[i] = data & 0xff;\r\nee_data[i + 1] = data >> 8;\r\n}\r\nfor (i = 0; i < 8; i ++)\r\nif (ee_data[i] != ee_data[16+i])\r\nsa_offset = 20;\r\nif (chip_idx == CONEXANT) {\r\nif (ee_data[0x198] == 0x04 && ee_data[0x199] == 6)\r\nsa_offset = 0x19A;\r\n} else if (ee_data[0] == 0xff && ee_data[1] == 0xff &&\r\nee_data[2] == 0) {\r\nsa_offset = 2;\r\nmultiport_cnt = 4;\r\n}\r\n#ifdef CONFIG_MIPS_COBALT\r\nif ((pdev->bus->number == 0) &&\r\n((PCI_SLOT(pdev->devfn) == 7) ||\r\n(PCI_SLOT(pdev->devfn) == 12))) {\r\nsa_offset = 0;\r\nmemcpy(ee_data + 16, ee_data, 8);\r\n}\r\n#endif\r\n#ifdef CONFIG_GSC\r\nif (ee_data[0] == 0x61 && ee_data[1] == 0x10) {\r\nee_data[0] = ee_data[2];\r\nee_data[1] = ee_data[3];\r\nee_data[2] = 0x61;\r\nee_data[3] = 0x10;\r\nfor (i = 4; i >= 0; i -= 2) {\r\nee_data[17 + i + 3] = ee_data[17 + i];\r\nee_data[16 + i + 5] = ee_data[16 + i];\r\n}\r\n}\r\n#endif\r\nfor (i = 0; i < 6; i ++) {\r\ndev->dev_addr[i] = ee_data[i + sa_offset];\r\nsum += ee_data[i + sa_offset];\r\n}\r\n}\r\nif ((dev->dev_addr[0] == 0xA0 ||\r\ndev->dev_addr[0] == 0xC0 ||\r\ndev->dev_addr[0] == 0x02) &&\r\ndev->dev_addr[1] == 0x00)\r\nfor (i = 0; i < 6; i+=2) {\r\nchar tmp = dev->dev_addr[i];\r\ndev->dev_addr[i] = dev->dev_addr[i+1];\r\ndev->dev_addr[i+1] = tmp;\r\n}\r\nif (sum == 0 || sum == 6*0xff) {\r\n#if defined(CONFIG_SPARC)\r\nstruct device_node *dp = pci_device_to_OF_node(pdev);\r\nconst unsigned char *addr;\r\nint len;\r\n#endif\r\neeprom_missing = 1;\r\nfor (i = 0; i < 5; i++)\r\ndev->dev_addr[i] = last_phys_addr[i];\r\ndev->dev_addr[i] = last_phys_addr[i] + 1;\r\n#if defined(CONFIG_SPARC)\r\naddr = of_get_property(dp, "local-mac-address", &len);\r\nif (addr && len == 6)\r\nmemcpy(dev->dev_addr, addr, 6);\r\n#endif\r\n#if defined(__i386__) || defined(__x86_64__)\r\nif (last_irq)\r\nirq = last_irq;\r\n#endif\r\n}\r\nfor (i = 0; i < 6; i++)\r\nlast_phys_addr[i] = dev->dev_addr[i];\r\nlast_irq = irq;\r\nif (board_idx >= 0 && board_idx < MAX_UNITS) {\r\nif (options[board_idx] & MEDIA_MASK)\r\ntp->default_port = options[board_idx] & MEDIA_MASK;\r\nif ((options[board_idx] & FullDuplex) || full_duplex[board_idx] > 0)\r\ntp->full_duplex = 1;\r\nif (mtu[board_idx] > 0)\r\ndev->mtu = mtu[board_idx];\r\n}\r\nif (dev->mem_start & MEDIA_MASK)\r\ntp->default_port = dev->mem_start & MEDIA_MASK;\r\nif (tp->default_port) {\r\npr_info(DRV_NAME "%d: Transceiver selection forced to %s\n",\r\nboard_idx, medianame[tp->default_port & MEDIA_MASK]);\r\ntp->medialock = 1;\r\nif (tulip_media_cap[tp->default_port] & MediaAlwaysFD)\r\ntp->full_duplex = 1;\r\n}\r\nif (tp->full_duplex)\r\ntp->full_duplex_lock = 1;\r\nif (tulip_media_cap[tp->default_port] & MediaIsMII) {\r\nstatic const u16 media2advert[] = {\r\n0x20, 0x40, 0x03e0, 0x60, 0x80, 0x100, 0x200\r\n};\r\ntp->mii_advertise = media2advert[tp->default_port - 9];\r\ntp->mii_advertise |= (tp->flags & HAS_8023X);\r\n}\r\nif (tp->flags & HAS_MEDIA_TABLE) {\r\nsprintf(dev->name, DRV_NAME "%d", board_idx);\r\ntulip_parse_eeprom(dev);\r\nstrcpy(dev->name, "eth%d");\r\n}\r\nif ((tp->flags & ALWAYS_CHECK_MII) ||\r\n(tp->mtable && tp->mtable->has_mii) ||\r\n( ! tp->mtable && (tp->flags & HAS_MII))) {\r\nif (tp->mtable && tp->mtable->has_mii) {\r\nfor (i = 0; i < tp->mtable->leafcount; i++)\r\nif (tp->mtable->mleaf[i].media == 11) {\r\ntp->cur_index = i;\r\ntp->saved_if_port = dev->if_port;\r\ntulip_select_media(dev, 2);\r\ndev->if_port = tp->saved_if_port;\r\nbreak;\r\n}\r\n}\r\ntulip_find_mii (dev, board_idx);\r\n}\r\ndev->netdev_ops = &tulip_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\n#ifdef CONFIG_TULIP_NAPI\r\nnetif_napi_add(dev, &tp->napi, tulip_poll, 16);\r\n#endif\r\nSET_ETHTOOL_OPS(dev, &ops);\r\nif (register_netdev(dev))\r\ngoto err_out_free_ring;\r\npci_set_drvdata(pdev, dev);\r\ndev_info(&dev->dev,\r\n#ifdef CONFIG_TULIP_MMIO\r\n"%s rev %d at MMIO %#llx,%s %pM, IRQ %d\n",\r\n#else\r\n"%s rev %d at Port %#llx,%s %pM, IRQ %d\n",\r\n#endif\r\nchip_name, pdev->revision,\r\n(unsigned long long)pci_resource_start(pdev, TULIP_BAR),\r\neeprom_missing ? " EEPROM not present," : "",\r\ndev->dev_addr, irq);\r\nif (tp->chip_id == PNIC2)\r\ntp->link_change = pnic2_lnk_change;\r\nelse if (tp->flags & HAS_NWAY)\r\ntp->link_change = t21142_lnk_change;\r\nelse if (tp->flags & HAS_PNICNWAY)\r\ntp->link_change = pnic_lnk_change;\r\nswitch (chip_idx) {\r\ncase DC21140:\r\ncase DM910X:\r\ndefault:\r\nif (tp->mtable)\r\niowrite32(tp->mtable->csr12dir | 0x100, ioaddr + CSR12);\r\nbreak;\r\ncase DC21142:\r\nif (tp->mii_cnt || tulip_media_cap[dev->if_port] & MediaIsMII) {\r\niowrite32(csr6_mask_defstate, ioaddr + CSR6);\r\niowrite32(0x0000, ioaddr + CSR13);\r\niowrite32(0x0000, ioaddr + CSR14);\r\niowrite32(csr6_mask_hdcap, ioaddr + CSR6);\r\n} else\r\nt21142_start_nway(dev);\r\nbreak;\r\ncase PNIC2:\r\niowrite32(0x0000, ioaddr + CSR13);\r\niowrite32(0x0000, ioaddr + CSR14);\r\nbreak;\r\ncase LC82C168:\r\nif ( ! tp->mii_cnt) {\r\ntp->nway = 1;\r\ntp->nwayset = 0;\r\niowrite32(csr6_ttm | csr6_ca, ioaddr + CSR6);\r\niowrite32(0x30, ioaddr + CSR12);\r\niowrite32(0x0001F078, ioaddr + CSR6);\r\niowrite32(0x0201F078, ioaddr + CSR6);\r\n}\r\nbreak;\r\ncase MX98713:\r\ncase COMPEX9881:\r\niowrite32(0x00000000, ioaddr + CSR6);\r\niowrite32(0x000711C0, ioaddr + CSR14);\r\niowrite32(0x00000001, ioaddr + CSR13);\r\nbreak;\r\ncase MX98715:\r\ncase MX98725:\r\niowrite32(0x01a80000, ioaddr + CSR6);\r\niowrite32(0xFFFFFFFF, ioaddr + CSR14);\r\niowrite32(0x00001000, ioaddr + CSR12);\r\nbreak;\r\ncase COMET:\r\nbreak;\r\n}\r\ntulip_set_power_state (tp, 0, 1);\r\nreturn 0;\r\nerr_out_free_ring:\r\npci_free_consistent (pdev,\r\nsizeof (struct tulip_rx_desc) * RX_RING_SIZE +\r\nsizeof (struct tulip_tx_desc) * TX_RING_SIZE,\r\ntp->rx_ring, tp->rx_ring_dma);\r\nerr_out_mtable:\r\nkfree (tp->mtable);\r\npci_iounmap(pdev, ioaddr);\r\nerr_out_free_res:\r\npci_release_regions (pdev);\r\nerr_out_free_netdev:\r\nfree_netdev (dev);\r\nreturn -ENODEV;\r\n}\r\nstatic void tulip_set_wolopts (struct pci_dev *pdev, u32 wolopts)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nif (tp->flags & COMET_PM) {\r\nunsigned int tmp;\r\ntmp = ioread32(ioaddr + CSR18);\r\ntmp &= ~(comet_csr18_pmes_sticky | comet_csr18_apm_mode | comet_csr18_d3a);\r\ntmp |= comet_csr18_pm_mode;\r\niowrite32(tmp, ioaddr + CSR18);\r\ntmp = ioread32(ioaddr + CSR13);\r\ntmp &= ~(comet_csr13_linkoffe | comet_csr13_linkone | comet_csr13_wfre | comet_csr13_lsce | comet_csr13_mpre);\r\nif (wolopts & WAKE_MAGIC)\r\ntmp |= comet_csr13_mpre;\r\nif (wolopts & WAKE_PHY)\r\ntmp |= comet_csr13_linkoffe | comet_csr13_linkone | comet_csr13_lsce;\r\ntmp |= comet_csr13_wfr | comet_csr13_mpr | comet_csr13_lsc;\r\niowrite32(tmp, ioaddr + CSR13);\r\n}\r\n}\r\nstatic int tulip_suspend (struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_power_t pstate;\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nif (!dev)\r\nreturn -EINVAL;\r\nif (!netif_running(dev))\r\ngoto save_state;\r\ntulip_down(dev);\r\nnetif_device_detach(dev);\r\nfree_irq(tp->pdev->irq, dev);\r\nsave_state:\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npstate = pci_choose_state(pdev, state);\r\nif (state.event == PM_EVENT_SUSPEND && pstate != PCI_D0) {\r\nint rc;\r\ntulip_set_wolopts(pdev, tp->wolinfo.wolopts);\r\nrc = pci_enable_wake(pdev, pstate, tp->wolinfo.wolopts);\r\nif (rc)\r\npr_err("pci_enable_wake failed (%d)\n", rc);\r\n}\r\npci_set_power_state(pdev, pstate);\r\nreturn 0;\r\n}\r\nstatic int tulip_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nint retval;\r\nunsigned int tmp;\r\nif (!dev)\r\nreturn -EINVAL;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nif ((retval = pci_enable_device(pdev))) {\r\npr_err("pci_enable_device failed in resume\n");\r\nreturn retval;\r\n}\r\nretval = request_irq(pdev->irq, tulip_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (retval) {\r\npr_err("request_irq failed in resume\n");\r\nreturn retval;\r\n}\r\nif (tp->flags & COMET_PM) {\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_enable_wake(pdev, PCI_D3cold, 0);\r\ntmp = ioread32(ioaddr + CSR20);\r\ntmp |= comet_csr20_pmes;\r\niowrite32(tmp, ioaddr + CSR20);\r\ntulip_set_wolopts(pdev, 0);\r\n}\r\nnetif_device_attach(dev);\r\nif (netif_running(dev))\r\ntulip_up(dev);\r\nreturn 0;\r\n}\r\nstatic void __devexit tulip_remove_one (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nstruct tulip_private *tp;\r\nif (!dev)\r\nreturn;\r\ntp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\npci_free_consistent (pdev,\r\nsizeof (struct tulip_rx_desc) * RX_RING_SIZE +\r\nsizeof (struct tulip_tx_desc) * TX_RING_SIZE,\r\ntp->rx_ring, tp->rx_ring_dma);\r\nkfree (tp->mtable);\r\npci_iounmap(pdev, tp->base_addr);\r\nfree_netdev (dev);\r\npci_release_regions (pdev);\r\npci_set_drvdata (pdev, NULL);\r\n}\r\nstatic void poll_tulip (struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nconst int irq = tp->pdev->irq;\r\ndisable_irq(irq);\r\ntulip_interrupt (irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic int __init tulip_init (void)\r\n{\r\n#ifdef MODULE\r\npr_info("%s", version);\r\n#endif\r\ntulip_rx_copybreak = rx_copybreak;\r\ntulip_max_interrupt_work = max_interrupt_work;\r\nreturn pci_register_driver(&tulip_driver);\r\n}\r\nstatic void __exit tulip_cleanup (void)\r\n{\r\npci_unregister_driver (&tulip_driver);\r\n}
