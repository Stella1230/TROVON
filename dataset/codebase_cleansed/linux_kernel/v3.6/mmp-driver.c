static inline struct mmp_camera *mcam_to_cam(struct mcam_camera *mcam)\r\n{\r\nreturn container_of(mcam, struct mmp_camera, mcam);\r\n}\r\nstatic void mmpcam_add_device(struct mmp_camera *cam)\r\n{\r\nmutex_lock(&mmpcam_devices_lock);\r\nlist_add(&cam->devlist, &mmpcam_devices);\r\nmutex_unlock(&mmpcam_devices_lock);\r\n}\r\nstatic void mmpcam_remove_device(struct mmp_camera *cam)\r\n{\r\nmutex_lock(&mmpcam_devices_lock);\r\nlist_del(&cam->devlist);\r\nmutex_unlock(&mmpcam_devices_lock);\r\n}\r\nstatic struct mmp_camera *mmpcam_find_device(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam;\r\nmutex_lock(&mmpcam_devices_lock);\r\nlist_for_each_entry(cam, &mmpcam_devices, devlist) {\r\nif (cam->pdev == pdev) {\r\nmutex_unlock(&mmpcam_devices_lock);\r\nreturn cam;\r\n}\r\n}\r\nmutex_unlock(&mmpcam_devices_lock);\r\nreturn NULL;\r\n}\r\nstatic void mmpcam_power_up_ctlr(struct mmp_camera *cam)\r\n{\r\niowrite32(0x3f, cam->power_regs + REG_CCIC_DCGCR);\r\niowrite32(0x3805b, cam->power_regs + REG_CCIC_CRCR);\r\nmdelay(1);\r\n}\r\nstatic void mmpcam_power_up(struct mcam_camera *mcam)\r\n{\r\nstruct mmp_camera *cam = mcam_to_cam(mcam);\r\nstruct mmp_camera_platform_data *pdata;\r\nmmpcam_power_up_ctlr(cam);\r\nmcam_reg_write(mcam, REG_CLKCTRL, 0x60000002);\r\npdata = cam->pdev->dev.platform_data;\r\ngpio_set_value(pdata->sensor_power_gpio, 1);\r\nmdelay(5);\r\nmcam_reg_clear_bit(mcam, REG_CTRL1, 0x10000000);\r\ngpio_set_value(pdata->sensor_reset_gpio, 0);\r\nmdelay(5);\r\ngpio_set_value(pdata->sensor_reset_gpio, 1);\r\nmdelay(5);\r\n}\r\nstatic void mmpcam_power_down(struct mcam_camera *mcam)\r\n{\r\nstruct mmp_camera *cam = mcam_to_cam(mcam);\r\nstruct mmp_camera_platform_data *pdata;\r\niowrite32(0, cam->power_regs + REG_CCIC_DCGCR);\r\niowrite32(0, cam->power_regs + REG_CCIC_CRCR);\r\npdata = cam->pdev->dev.platform_data;\r\ngpio_set_value(pdata->sensor_power_gpio, 0);\r\ngpio_set_value(pdata->sensor_reset_gpio, 0);\r\n}\r\nstatic irqreturn_t mmpcam_irq(int irq, void *data)\r\n{\r\nstruct mcam_camera *mcam = data;\r\nunsigned int irqs, handled;\r\nspin_lock(&mcam->dev_lock);\r\nirqs = mcam_reg_read(mcam, REG_IRQSTAT);\r\nhandled = mccic_irq(mcam, irqs);\r\nspin_unlock(&mcam->dev_lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int mmpcam_probe(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam;\r\nstruct mcam_camera *mcam;\r\nstruct resource *res;\r\nstruct mmp_camera_platform_data *pdata;\r\nint ret;\r\ncam = kzalloc(sizeof(*cam), GFP_KERNEL);\r\nif (cam == NULL)\r\nreturn -ENOMEM;\r\ncam->pdev = pdev;\r\nINIT_LIST_HEAD(&cam->devlist);\r\nmcam = &cam->mcam;\r\nmcam->plat_power_up = mmpcam_power_up;\r\nmcam->plat_power_down = mmpcam_power_down;\r\nmcam->dev = &pdev->dev;\r\nmcam->use_smbus = 0;\r\nmcam->chip_id = V4L2_IDENT_ARMADA610;\r\nmcam->buffer_mode = B_DMA_sg;\r\nspin_lock_init(&mcam->dev_lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no iomem resource!\n");\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nmcam->regs = ioremap(res->start, resource_size(res));\r\nif (mcam->regs == NULL) {\r\ndev_err(&pdev->dev, "MMIO ioremap fail\n");\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no power resource!\n");\r\nret = -ENODEV;\r\ngoto out_unmap1;\r\n}\r\ncam->power_regs = ioremap(res->start, resource_size(res));\r\nif (cam->power_regs == NULL) {\r\ndev_err(&pdev->dev, "power MMIO ioremap fail\n");\r\nret = -ENODEV;\r\ngoto out_unmap1;\r\n}\r\npdata = pdev->dev.platform_data;\r\nmcam->i2c_adapter = platform_get_drvdata(pdata->i2c_device);\r\nif (mcam->i2c_adapter == NULL) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "No i2c adapter\n");\r\ngoto out_unmap2;\r\n}\r\nret = gpio_request(pdata->sensor_power_gpio, "cam-power");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't get sensor power gpio %d",\r\npdata->sensor_power_gpio);\r\ngoto out_unmap2;\r\n}\r\ngpio_direction_output(pdata->sensor_power_gpio, 0);\r\nret = gpio_request(pdata->sensor_reset_gpio, "cam-reset");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't get sensor reset gpio %d",\r\npdata->sensor_reset_gpio);\r\ngoto out_gpio;\r\n}\r\ngpio_direction_output(pdata->sensor_reset_gpio, 0);\r\nmmpcam_power_up(mcam);\r\nret = mccic_register(mcam);\r\nif (ret)\r\ngoto out_gpio2;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\nret = -ENODEV;\r\ngoto out_unregister;\r\n}\r\ncam->irq = res->start;\r\nret = request_irq(cam->irq, mmpcam_irq, IRQF_SHARED,\r\n"mmp-camera", mcam);\r\nif (ret == 0) {\r\nmmpcam_add_device(cam);\r\nreturn 0;\r\n}\r\nout_unregister:\r\nmccic_shutdown(mcam);\r\nout_gpio2:\r\nmmpcam_power_down(mcam);\r\ngpio_free(pdata->sensor_reset_gpio);\r\nout_gpio:\r\ngpio_free(pdata->sensor_power_gpio);\r\nout_unmap2:\r\niounmap(cam->power_regs);\r\nout_unmap1:\r\niounmap(mcam->regs);\r\nout_free:\r\nkfree(cam);\r\nreturn ret;\r\n}\r\nstatic int mmpcam_remove(struct mmp_camera *cam)\r\n{\r\nstruct mcam_camera *mcam = &cam->mcam;\r\nstruct mmp_camera_platform_data *pdata;\r\nmmpcam_remove_device(cam);\r\nfree_irq(cam->irq, mcam);\r\nmccic_shutdown(mcam);\r\nmmpcam_power_down(mcam);\r\npdata = cam->pdev->dev.platform_data;\r\ngpio_free(pdata->sensor_reset_gpio);\r\ngpio_free(pdata->sensor_power_gpio);\r\niounmap(cam->power_regs);\r\niounmap(mcam->regs);\r\nkfree(cam);\r\nreturn 0;\r\n}\r\nstatic int mmpcam_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam = mmpcam_find_device(pdev);\r\nif (cam == NULL)\r\nreturn -ENODEV;\r\nreturn mmpcam_remove(cam);\r\n}\r\nstatic int mmpcam_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct mmp_camera *cam = mmpcam_find_device(pdev);\r\nif (state.event != PM_EVENT_SUSPEND)\r\nreturn 0;\r\nmccic_suspend(&cam->mcam);\r\nreturn 0;\r\n}\r\nstatic int mmpcam_resume(struct platform_device *pdev)\r\n{\r\nstruct mmp_camera *cam = mmpcam_find_device(pdev);\r\nmmpcam_power_up_ctlr(cam);\r\nreturn mccic_resume(&cam->mcam);\r\n}\r\nstatic int __init mmpcam_init_module(void)\r\n{\r\nmutex_init(&mmpcam_devices_lock);\r\nreturn platform_driver_register(&mmpcam_driver);\r\n}\r\nstatic void __exit mmpcam_exit_module(void)\r\n{\r\nplatform_driver_unregister(&mmpcam_driver);\r\nif (!list_empty(&mmpcam_devices))\r\nprintk(KERN_ERR "mmp_camera leaving devices behind\n");\r\n}
