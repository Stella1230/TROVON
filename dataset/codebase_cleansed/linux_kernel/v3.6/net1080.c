static int\r\nnc_vendor_read(struct usbnet *dev, u8 req, u8 regnum, u16 *retval_ptr)\r\n{\r\nint status = usb_control_msg(dev->udev,\r\nusb_rcvctrlpipe(dev->udev, 0),\r\nreq,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, regnum,\r\nretval_ptr, sizeof *retval_ptr,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (status > 0)\r\nstatus = 0;\r\nif (!status)\r\nle16_to_cpus(retval_ptr);\r\nreturn status;\r\n}\r\nstatic inline int\r\nnc_register_read(struct usbnet *dev, u8 regnum, u16 *retval_ptr)\r\n{\r\nreturn nc_vendor_read(dev, REQUEST_REGISTER, regnum, retval_ptr);\r\n}\r\nstatic void\r\nnc_vendor_write(struct usbnet *dev, u8 req, u8 regnum, u16 value)\r\n{\r\nusb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, regnum,\r\nNULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic inline void\r\nnc_register_write(struct usbnet *dev, u8 regnum, u16 value)\r\n{\r\nnc_vendor_write(dev, REQUEST_REGISTER, regnum, value);\r\n}\r\nstatic inline void nc_dump_usbctl(struct usbnet *dev, u16 usbctl)\r\n{\r\nnetif_dbg(dev, link, dev->net,\r\n"net1080 %s-%s usbctl 0x%x:%s%s%s%s%s; this%s%s; other%s%s; r/o 0x%x\n",\r\ndev->udev->bus->bus_name, dev->udev->devpath,\r\nusbctl,\r\n(usbctl & USBCTL_ENABLE_LANG) ? " lang" : "",\r\n(usbctl & USBCTL_ENABLE_MFGR) ? " mfgr" : "",\r\n(usbctl & USBCTL_ENABLE_PROD) ? " prod" : "",\r\n(usbctl & USBCTL_ENABLE_SERIAL) ? " serial" : "",\r\n(usbctl & USBCTL_ENABLE_DEFAULTS) ? " defaults" : "",\r\n(usbctl & USBCTL_FLUSH_THIS) ? " FLUSH" : "",\r\n(usbctl & USBCTL_DISCONN_THIS) ? " DIS" : "",\r\n(usbctl & USBCTL_FLUSH_OTHER) ? " FLUSH" : "",\r\n(usbctl & USBCTL_DISCONN_OTHER) ? " DIS" : "",\r\nusbctl & ~USBCTL_WRITABLE_MASK);\r\n}\r\nstatic inline void nc_dump_status(struct usbnet *dev, u16 status)\r\n{\r\nnetif_dbg(dev, link, dev->net,\r\n"net1080 %s-%s status 0x%x: this (%c) PKT=%d%s%s%s; other PKT=%d%s%s%s; unspec 0x%x\n",\r\ndev->udev->bus->bus_name, dev->udev->devpath,\r\nstatus,\r\n(status & STATUS_PORT_A) ? 'A' : 'B',\r\nSTATUS_PACKETS_THIS(status),\r\n(status & STATUS_CONN_THIS) ? " CON" : "",\r\n(status & STATUS_SUSPEND_THIS) ? " SUS" : "",\r\n(status & STATUS_MAILBOX_THIS) ? " MBOX" : "",\r\nSTATUS_PACKETS_OTHER(status),\r\n(status & STATUS_CONN_OTHER) ? " CON" : "",\r\n(status & STATUS_SUSPEND_OTHER) ? " SUS" : "",\r\n(status & STATUS_MAILBOX_OTHER) ? " MBOX" : "",\r\nstatus & STATUS_UNSPEC_MASK);\r\n}\r\nstatic inline void nc_dump_ttl(struct usbnet *dev, u16 ttl)\r\n{\r\nnetif_dbg(dev, link, dev->net, "net1080 %s-%s ttl 0x%x this = %d, other = %d\n",\r\ndev->udev->bus->bus_name, dev->udev->devpath,\r\nttl, TTL_THIS(ttl), TTL_OTHER(ttl));\r\n}\r\nstatic int net1080_reset(struct usbnet *dev)\r\n{\r\nu16 usbctl, status, ttl;\r\nu16 *vp = kmalloc(sizeof (u16), GFP_KERNEL);\r\nint retval;\r\nif (!vp)\r\nreturn -ENOMEM;\r\nif ((retval = nc_register_read(dev, REG_STATUS, vp)) < 0) {\r\ndbg("can't read %s-%s status: %d",\r\ndev->udev->bus->bus_name, dev->udev->devpath, retval);\r\ngoto done;\r\n}\r\nstatus = *vp;\r\nnc_dump_status(dev, status);\r\nif ((retval = nc_register_read(dev, REG_USBCTL, vp)) < 0) {\r\ndbg("can't read USBCTL, %d", retval);\r\ngoto done;\r\n}\r\nusbctl = *vp;\r\nnc_dump_usbctl(dev, usbctl);\r\nnc_register_write(dev, REG_USBCTL,\r\nUSBCTL_FLUSH_THIS | USBCTL_FLUSH_OTHER);\r\nif ((retval = nc_register_read(dev, REG_TTL, vp)) < 0) {\r\ndbg("can't read TTL, %d", retval);\r\ngoto done;\r\n}\r\nttl = *vp;\r\nnc_register_write(dev, REG_TTL,\r\nMK_TTL(NC_READ_TTL_MS, TTL_OTHER(ttl)) );\r\ndbg("%s: assigned TTL, %d ms", dev->net->name, NC_READ_TTL_MS);\r\nnetif_info(dev, link, dev->net, "port %c, peer %sconnected\n",\r\n(status & STATUS_PORT_A) ? 'A' : 'B',\r\n(status & STATUS_CONN_OTHER) ? "" : "dis");\r\nretval = 0;\r\ndone:\r\nkfree(vp);\r\nreturn retval;\r\n}\r\nstatic int net1080_check_connect(struct usbnet *dev)\r\n{\r\nint retval;\r\nu16 status;\r\nu16 *vp = kmalloc(sizeof (u16), GFP_KERNEL);\r\nif (!vp)\r\nreturn -ENOMEM;\r\nretval = nc_register_read(dev, REG_STATUS, vp);\r\nstatus = *vp;\r\nkfree(vp);\r\nif (retval != 0) {\r\ndbg("%s net1080_check_conn read - %d", dev->net->name, retval);\r\nreturn retval;\r\n}\r\nif ((status & STATUS_CONN_OTHER) != STATUS_CONN_OTHER)\r\nreturn -ENOLINK;\r\nreturn 0;\r\n}\r\nstatic void nc_flush_complete(struct urb *urb)\r\n{\r\nkfree(urb->context);\r\nusb_free_urb(urb);\r\n}\r\nstatic void nc_ensure_sync(struct usbnet *dev)\r\n{\r\ndev->frame_errors++;\r\nif (dev->frame_errors > 5) {\r\nstruct urb *urb;\r\nstruct usb_ctrlrequest *req;\r\nint status;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn;\r\nreq = kmalloc(sizeof *req, GFP_ATOMIC);\r\nif (!req) {\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nreq->bRequestType = USB_DIR_OUT\r\n| USB_TYPE_VENDOR\r\n| USB_RECIP_DEVICE;\r\nreq->bRequest = REQUEST_REGISTER;\r\nreq->wValue = cpu_to_le16(USBCTL_FLUSH_THIS\r\n| USBCTL_FLUSH_OTHER);\r\nreq->wIndex = cpu_to_le16(REG_USBCTL);\r\nreq->wLength = cpu_to_le16(0);\r\nusb_fill_control_urb(urb, dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n(unsigned char *) req,\r\nNULL, 0,\r\nnc_flush_complete, req);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\nkfree(req);\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nnetif_dbg(dev, rx_err, dev->net,\r\n"flush net1080; too many framing errors\n");\r\ndev->frame_errors = 0;\r\n}\r\n}\r\nstatic int net1080_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct nc_header *header;\r\nstruct nc_trailer *trailer;\r\nu16 hdr_len, packet_len;\r\nif (!(skb->len & 0x01)) {\r\n#ifdef DEBUG\r\nstruct net_device *net = dev->net;\r\ndbg("rx framesize %d range %d..%d mtu %d", skb->len,\r\nnet->hard_header_len, dev->hard_mtu, net->mtu);\r\n#endif\r\ndev->net->stats.rx_frame_errors++;\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n}\r\nheader = (struct nc_header *) skb->data;\r\nhdr_len = le16_to_cpup(&header->hdr_len);\r\npacket_len = le16_to_cpup(&header->packet_len);\r\nif (FRAMED_SIZE(packet_len) > NC_MAX_PACKET) {\r\ndev->net->stats.rx_frame_errors++;\r\ndbg("packet too big, %d", packet_len);\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n} else if (hdr_len < MIN_HEADER) {\r\ndev->net->stats.rx_frame_errors++;\r\ndbg("header too short, %d", hdr_len);\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n} else if (hdr_len > MIN_HEADER) {\r\ndbg("header OOB, %d bytes", hdr_len - MIN_HEADER);\r\nnc_ensure_sync(dev);\r\n}\r\nskb_pull(skb, hdr_len);\r\ntrailer = (struct nc_trailer *)\r\n(skb->data + skb->len - sizeof *trailer);\r\nskb_trim(skb, skb->len - sizeof *trailer);\r\nif ((packet_len & 0x01) == 0) {\r\nif (skb->data [packet_len] != PAD_BYTE) {\r\ndev->net->stats.rx_frame_errors++;\r\ndbg("bad pad");\r\nreturn 0;\r\n}\r\nskb_trim(skb, skb->len - 1);\r\n}\r\nif (skb->len != packet_len) {\r\ndev->net->stats.rx_frame_errors++;\r\ndbg("bad packet len %d (expected %d)",\r\nskb->len, packet_len);\r\nnc_ensure_sync(dev);\r\nreturn 0;\r\n}\r\nif (header->packet_id != get_unaligned(&trailer->packet_id)) {\r\ndev->net->stats.rx_fifo_errors++;\r\ndbg("(2+ dropped) rx packet_id mismatch 0x%x 0x%x",\r\nle16_to_cpu(header->packet_id),\r\nle16_to_cpu(trailer->packet_id));\r\nreturn 0;\r\n}\r\n#if 0\r\nnetdev_dbg(dev->net, "frame <rx h %d p %d id %d\n", header->hdr_len,\r\nheader->packet_len, header->packet_id);\r\n#endif\r\ndev->frame_errors = 0;\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *\r\nnet1080_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct nc_header *header = NULL;\r\nstruct nc_trailer *trailer = NULL;\r\nint padlen = sizeof (struct nc_trailer);\r\nint len = skb->len;\r\nif (!((len + padlen + sizeof (struct nc_header)) & 0x01))\r\npadlen++;\r\nif (!skb_cloned(skb)) {\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nif (padlen <= tailroom &&\r\nsizeof(struct nc_header) <= headroom)\r\ngoto encapsulate;\r\nif ((sizeof (struct nc_header) + padlen) <\r\n(headroom + tailroom)) {\r\nskb->data = memmove(skb->head\r\n+ sizeof (struct nc_header),\r\nskb->data, skb->len);\r\nskb_set_tail_pointer(skb, len);\r\ngoto encapsulate;\r\n}\r\n}\r\nskb2 = skb_copy_expand(skb,\r\nsizeof (struct nc_header),\r\npadlen,\r\nflags);\r\ndev_kfree_skb_any(skb);\r\nif (!skb2)\r\nreturn skb2;\r\nskb = skb2;\r\nencapsulate:\r\nheader = (struct nc_header *) skb_push(skb, sizeof *header);\r\nheader->hdr_len = cpu_to_le16(sizeof (*header));\r\nheader->packet_len = cpu_to_le16(len);\r\nheader->packet_id = cpu_to_le16((u16)dev->xid++);\r\nif (!((skb->len + sizeof *trailer) & 0x01))\r\n*skb_put(skb, 1) = PAD_BYTE;\r\ntrailer = (struct nc_trailer *) skb_put(skb, sizeof *trailer);\r\nput_unaligned(header->packet_id, &trailer->packet_id);\r\n#if 0\r\nnetdev_dbg(dev->net, "frame >tx h %d p %d id %d\n",\r\nheader->hdr_len, header->packet_len,\r\nheader->packet_id);\r\n#endif\r\nreturn skb;\r\n}\r\nstatic int net1080_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nunsigned extra = sizeof (struct nc_header)\r\n+ 1\r\n+ sizeof (struct nc_trailer);\r\ndev->net->hard_header_len += extra;\r\ndev->rx_urb_size = dev->net->hard_header_len + dev->net->mtu;\r\ndev->hard_mtu = NC_MAX_PACKET;\r\nreturn usbnet_get_endpoints (dev, intf);\r\n}
