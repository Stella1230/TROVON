static int skip_prefix(unsigned char *addr, struct prefix_bits *prf)\r\n{\r\nint i;\r\nunsigned char *p = addr;\r\nprf->shorted = 0;\r\nprf->enlarged = 0;\r\nprf->rexr = 0;\r\nprf->rex = 0;\r\nrestart:\r\nfor (i = 0; i < ARRAY_SIZE(prefix_codes); i++) {\r\nif (*p == prefix_codes[i]) {\r\nif (*p == 0x66)\r\nprf->shorted = 1;\r\n#ifdef __amd64__\r\nif ((*p & 0xf8) == 0x48)\r\nprf->enlarged = 1;\r\nif ((*p & 0xf4) == 0x44)\r\nprf->rexr = 1;\r\nif ((*p & 0xf0) == 0x40)\r\nprf->rex = 1;\r\n#endif\r\np++;\r\ngoto restart;\r\n}\r\n}\r\nreturn (p - addr);\r\n}\r\nstatic int get_opcode(unsigned char *addr, unsigned int *opcode)\r\n{\r\nint len;\r\nif (*addr == 0x0F) {\r\n*opcode = *(unsigned short *)addr;\r\nlen = 2;\r\n} else {\r\n*opcode = *addr;\r\nlen = 1;\r\n}\r\nreturn len;\r\n}\r\nenum reason_type get_ins_type(unsigned long ins_addr)\r\n{\r\nunsigned int opcode;\r\nunsigned char *p;\r\nstruct prefix_bits prf;\r\nint i;\r\nenum reason_type rv = OTHERS;\r\np = (unsigned char *)ins_addr;\r\np += skip_prefix(p, &prf);\r\np += get_opcode(p, &opcode);\r\nCHECK_OP_TYPE(opcode, reg_rop, REG_READ);\r\nCHECK_OP_TYPE(opcode, reg_wop, REG_WRITE);\r\nCHECK_OP_TYPE(opcode, imm_wop, IMM_WRITE);\r\nexit:\r\nreturn rv;\r\n}\r\nstatic unsigned int get_ins_reg_width(unsigned long ins_addr)\r\n{\r\nunsigned int opcode;\r\nunsigned char *p;\r\nstruct prefix_bits prf;\r\nint i;\r\np = (unsigned char *)ins_addr;\r\np += skip_prefix(p, &prf);\r\np += get_opcode(p, &opcode);\r\nfor (i = 0; i < ARRAY_SIZE(rw8); i++)\r\nif (rw8[i] == opcode)\r\nreturn 1;\r\nfor (i = 0; i < ARRAY_SIZE(rw32); i++)\r\nif (rw32[i] == opcode)\r\nreturn prf.shorted ? 2 : (prf.enlarged ? 8 : 4);\r\nprintk(KERN_ERR "mmiotrace: Unknown opcode 0x%02x\n", opcode);\r\nreturn 0;\r\n}\r\nunsigned int get_ins_mem_width(unsigned long ins_addr)\r\n{\r\nunsigned int opcode;\r\nunsigned char *p;\r\nstruct prefix_bits prf;\r\nint i;\r\np = (unsigned char *)ins_addr;\r\np += skip_prefix(p, &prf);\r\np += get_opcode(p, &opcode);\r\nfor (i = 0; i < ARRAY_SIZE(mw8); i++)\r\nif (mw8[i] == opcode)\r\nreturn 1;\r\nfor (i = 0; i < ARRAY_SIZE(mw16); i++)\r\nif (mw16[i] == opcode)\r\nreturn 2;\r\nfor (i = 0; i < ARRAY_SIZE(mw32); i++)\r\nif (mw32[i] == opcode)\r\nreturn prf.shorted ? 2 : 4;\r\nfor (i = 0; i < ARRAY_SIZE(mw64); i++)\r\nif (mw64[i] == opcode)\r\nreturn prf.shorted ? 2 : (prf.enlarged ? 8 : 4);\r\nprintk(KERN_ERR "mmiotrace: Unknown opcode 0x%02x\n", opcode);\r\nreturn 0;\r\n}\r\nstatic unsigned char *get_reg_w8(int no, int rex, struct pt_regs *regs)\r\n{\r\nunsigned char *rv = NULL;\r\nswitch (no) {\r\ncase arg_AL:\r\nrv = (unsigned char *)&regs->ax;\r\nbreak;\r\ncase arg_BL:\r\nrv = (unsigned char *)&regs->bx;\r\nbreak;\r\ncase arg_CL:\r\nrv = (unsigned char *)&regs->cx;\r\nbreak;\r\ncase arg_DL:\r\nrv = (unsigned char *)&regs->dx;\r\nbreak;\r\n#ifdef __amd64__\r\ncase arg_R8:\r\nrv = (unsigned char *)&regs->r8;\r\nbreak;\r\ncase arg_R9:\r\nrv = (unsigned char *)&regs->r9;\r\nbreak;\r\ncase arg_R10:\r\nrv = (unsigned char *)&regs->r10;\r\nbreak;\r\ncase arg_R11:\r\nrv = (unsigned char *)&regs->r11;\r\nbreak;\r\ncase arg_R12:\r\nrv = (unsigned char *)&regs->r12;\r\nbreak;\r\ncase arg_R13:\r\nrv = (unsigned char *)&regs->r13;\r\nbreak;\r\ncase arg_R14:\r\nrv = (unsigned char *)&regs->r14;\r\nbreak;\r\ncase arg_R15:\r\nrv = (unsigned char *)&regs->r15;\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nif (rv)\r\nreturn rv;\r\nif (rex) {\r\nswitch (no) {\r\ncase arg_SI:\r\nrv = (unsigned char *)&regs->si;\r\nbreak;\r\ncase arg_DI:\r\nrv = (unsigned char *)&regs->di;\r\nbreak;\r\ncase arg_BP:\r\nrv = (unsigned char *)&regs->bp;\r\nbreak;\r\ncase arg_SP:\r\nrv = (unsigned char *)&regs->sp;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (no) {\r\ncase arg_AH:\r\nrv = 1 + (unsigned char *)&regs->ax;\r\nbreak;\r\ncase arg_BH:\r\nrv = 1 + (unsigned char *)&regs->bx;\r\nbreak;\r\ncase arg_CH:\r\nrv = 1 + (unsigned char *)&regs->cx;\r\nbreak;\r\ncase arg_DH:\r\nrv = 1 + (unsigned char *)&regs->dx;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!rv)\r\nprintk(KERN_ERR "mmiotrace: Error reg no# %d\n", no);\r\nreturn rv;\r\n}\r\nstatic unsigned long *get_reg_w32(int no, struct pt_regs *regs)\r\n{\r\nunsigned long *rv = NULL;\r\nswitch (no) {\r\ncase arg_AX:\r\nrv = &regs->ax;\r\nbreak;\r\ncase arg_BX:\r\nrv = &regs->bx;\r\nbreak;\r\ncase arg_CX:\r\nrv = &regs->cx;\r\nbreak;\r\ncase arg_DX:\r\nrv = &regs->dx;\r\nbreak;\r\ncase arg_SP:\r\nrv = &regs->sp;\r\nbreak;\r\ncase arg_BP:\r\nrv = &regs->bp;\r\nbreak;\r\ncase arg_SI:\r\nrv = &regs->si;\r\nbreak;\r\ncase arg_DI:\r\nrv = &regs->di;\r\nbreak;\r\n#ifdef __amd64__\r\ncase arg_R8:\r\nrv = &regs->r8;\r\nbreak;\r\ncase arg_R9:\r\nrv = &regs->r9;\r\nbreak;\r\ncase arg_R10:\r\nrv = &regs->r10;\r\nbreak;\r\ncase arg_R11:\r\nrv = &regs->r11;\r\nbreak;\r\ncase arg_R12:\r\nrv = &regs->r12;\r\nbreak;\r\ncase arg_R13:\r\nrv = &regs->r13;\r\nbreak;\r\ncase arg_R14:\r\nrv = &regs->r14;\r\nbreak;\r\ncase arg_R15:\r\nrv = &regs->r15;\r\nbreak;\r\n#endif\r\ndefault:\r\nprintk(KERN_ERR "mmiotrace: Error reg no# %d\n", no);\r\n}\r\nreturn rv;\r\n}\r\nunsigned long get_ins_reg_val(unsigned long ins_addr, struct pt_regs *regs)\r\n{\r\nunsigned int opcode;\r\nint reg;\r\nunsigned char *p;\r\nstruct prefix_bits prf;\r\nint i;\r\np = (unsigned char *)ins_addr;\r\np += skip_prefix(p, &prf);\r\np += get_opcode(p, &opcode);\r\nfor (i = 0; i < ARRAY_SIZE(reg_rop); i++)\r\nif (reg_rop[i] == opcode)\r\ngoto do_work;\r\nfor (i = 0; i < ARRAY_SIZE(reg_wop); i++)\r\nif (reg_wop[i] == opcode)\r\ngoto do_work;\r\nprintk(KERN_ERR "mmiotrace: Not a register instruction, opcode "\r\n"0x%02x\n", opcode);\r\ngoto err;\r\ndo_work:\r\nif (opcode == 0xAA || opcode == 0xAB) {\r\nreg = arg_AX;\r\n} else {\r\nunsigned char mod_rm = *p;\r\nreg = ((mod_rm >> 3) & 0x7) | (prf.rexr << 3);\r\n}\r\nswitch (get_ins_reg_width(ins_addr)) {\r\ncase 1:\r\nreturn *get_reg_w8(reg, prf.rex, regs);\r\ncase 2:\r\nreturn *(unsigned short *)get_reg_w32(reg, regs);\r\ncase 4:\r\nreturn *(unsigned int *)get_reg_w32(reg, regs);\r\n#ifdef __amd64__\r\ncase 8:\r\nreturn *(unsigned long *)get_reg_w32(reg, regs);\r\n#endif\r\ndefault:\r\nprintk(KERN_ERR "mmiotrace: Error width# %d\n", reg);\r\n}\r\nerr:\r\nreturn 0;\r\n}\r\nunsigned long get_ins_imm_val(unsigned long ins_addr)\r\n{\r\nunsigned int opcode;\r\nunsigned char mod_rm;\r\nunsigned char mod;\r\nunsigned char *p;\r\nstruct prefix_bits prf;\r\nint i;\r\np = (unsigned char *)ins_addr;\r\np += skip_prefix(p, &prf);\r\np += get_opcode(p, &opcode);\r\nfor (i = 0; i < ARRAY_SIZE(imm_wop); i++)\r\nif (imm_wop[i] == opcode)\r\ngoto do_work;\r\nprintk(KERN_ERR "mmiotrace: Not an immediate instruction, opcode "\r\n"0x%02x\n", opcode);\r\ngoto err;\r\ndo_work:\r\nmod_rm = *p;\r\nmod = mod_rm >> 6;\r\np++;\r\nswitch (mod) {\r\ncase 0:\r\nif ((mod_rm & 0x7) == 0x5)\r\np += 4;\r\nbreak;\r\ncase 1:\r\np += 1;\r\nbreak;\r\ncase 2:\r\np += 4;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nprintk(KERN_ERR "mmiotrace: not a memory access instruction "\r\n"at 0x%lx, rm_mod=0x%02x\n",\r\nins_addr, mod_rm);\r\n}\r\nswitch (get_ins_reg_width(ins_addr)) {\r\ncase 1:\r\nreturn *(unsigned char *)p;\r\ncase 2:\r\nreturn *(unsigned short *)p;\r\ncase 4:\r\nreturn *(unsigned int *)p;\r\n#ifdef __amd64__\r\ncase 8:\r\nreturn *(unsigned long *)p;\r\n#endif\r\ndefault:\r\nprintk(KERN_ERR "mmiotrace: Error: width.\n");\r\n}\r\nerr:\r\nreturn 0;\r\n}
