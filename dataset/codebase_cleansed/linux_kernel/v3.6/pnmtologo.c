static unsigned int get_number(FILE *fp)\r\n{\r\nint c, val;\r\ndo {\r\nc = fgetc(fp);\r\nif (c == EOF)\r\ndie("%s: end of file\n", filename);\r\nif (c == '#') {\r\ndo {\r\nc = fgetc(fp);\r\nif (c == EOF)\r\ndie("%s: end of file\n", filename);\r\n} while (c != '\n');\r\n}\r\n} while (isspace(c));\r\nval = 0;\r\nwhile (isdigit(c)) {\r\nval = 10*val+c-'0';\r\nc = fgetc(fp);\r\nif (c == EOF)\r\ndie("%s: end of file\n", filename);\r\n}\r\nreturn val;\r\n}\r\nstatic unsigned int get_number255(FILE *fp, unsigned int maxval)\r\n{\r\nunsigned int val = get_number(fp);\r\nreturn (255*val+maxval/2)/maxval;\r\n}\r\nstatic void read_image(void)\r\n{\r\nFILE *fp;\r\nunsigned int i, j;\r\nint magic;\r\nunsigned int maxval;\r\nfp = fopen(filename, "r");\r\nif (!fp)\r\ndie("Cannot open file %s: %s\n", filename, strerror(errno));\r\nmagic = fgetc(fp);\r\nif (magic != 'P')\r\ndie("%s is not a PNM file\n", filename);\r\nmagic = fgetc(fp);\r\nswitch (magic) {\r\ncase '1':\r\ncase '2':\r\ncase '3':\r\nbreak;\r\ncase '4':\r\ncase '5':\r\ncase '6':\r\ndie("%s: Binary PNM is not supported\n"\r\n"Use pnmnoraw(1) to convert it to ASCII PNM\n", filename);\r\ndefault:\r\ndie("%s is not a PNM file\n", filename);\r\n}\r\nlogo_width = get_number(fp);\r\nlogo_height = get_number(fp);\r\nlogo_data = (struct color **)malloc(logo_height*sizeof(struct color *));\r\nif (!logo_data)\r\ndie("%s\n", strerror(errno));\r\nfor (i = 0; i < logo_height; i++) {\r\nlogo_data[i] = malloc(logo_width*sizeof(struct color));\r\nif (!logo_data[i])\r\ndie("%s\n", strerror(errno));\r\n}\r\nswitch (magic) {\r\ncase '1':\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++)\r\nlogo_data[i][j].red = logo_data[i][j].green =\r\nlogo_data[i][j].blue = 255*(1-get_number(fp));\r\nbreak;\r\ncase '2':\r\nmaxval = get_number(fp);\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++)\r\nlogo_data[i][j].red = logo_data[i][j].green =\r\nlogo_data[i][j].blue = get_number255(fp, maxval);\r\nbreak;\r\ncase '3':\r\nmaxval = get_number(fp);\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++) {\r\nlogo_data[i][j].red = get_number255(fp, maxval);\r\nlogo_data[i][j].green = get_number255(fp, maxval);\r\nlogo_data[i][j].blue = get_number255(fp, maxval);\r\n}\r\nbreak;\r\n}\r\nfclose(fp);\r\n}\r\nstatic inline int is_black(struct color c)\r\n{\r\nreturn c.red == 0 && c.green == 0 && c.blue == 0;\r\n}\r\nstatic inline int is_white(struct color c)\r\n{\r\nreturn c.red == 255 && c.green == 255 && c.blue == 255;\r\n}\r\nstatic inline int is_gray(struct color c)\r\n{\r\nreturn c.red == c.green && c.red == c.blue;\r\n}\r\nstatic inline int is_equal(struct color c1, struct color c2)\r\n{\r\nreturn c1.red == c2.red && c1.green == c2.green && c1.blue == c2.blue;\r\n}\r\nstatic void write_header(void)\r\n{\r\nif (outputname) {\r\nout = fopen(outputname, "w");\r\nif (!out)\r\ndie("Cannot create file %s: %s\n", outputname, strerror(errno));\r\n} else {\r\nout = stdout;\r\n}\r\nfputs("/*\n", out);\r\nfputs(" * DO NOT EDIT THIS FILE!\n", out);\r\nfputs(" *\n", out);\r\nfprintf(out, " * It was automatically generated from %s\n", filename);\r\nfputs(" *\n", out);\r\nfprintf(out, " * Linux logo %s\n", logoname);\r\nfputs(" */\n\n", out);\r\nfputs("#include <linux/linux_logo.h>\n\n", out);\r\nfprintf(out, "static unsigned char %s_data[] __initdata = {\n",\r\nlogoname);\r\n}\r\nstatic void write_footer(void)\r\n{\r\nfputs("\n};\n\n", out);\r\nfprintf(out, "const struct linux_logo %s __initconst = {\n", logoname);\r\nfprintf(out, "\t.type\t\t= %s,\n", logo_types[logo_type]);\r\nfprintf(out, "\t.width\t\t= %d,\n", logo_width);\r\nfprintf(out, "\t.height\t\t= %d,\n", logo_height);\r\nif (logo_type == LINUX_LOGO_CLUT224) {\r\nfprintf(out, "\t.clutsize\t= %d,\n", logo_clutsize);\r\nfprintf(out, "\t.clut\t\t= %s_clut,\n", logoname);\r\n}\r\nfprintf(out, "\t.data\t\t= %s_data\n", logoname);\r\nfputs("};\n\n", out);\r\nif (outputname)\r\nfclose(out);\r\n}\r\nstatic void write_hex(unsigned char byte)\r\n{\r\nif (write_hex_cnt % 12)\r\nfprintf(out, ", 0x%02x", byte);\r\nelse if (write_hex_cnt)\r\nfprintf(out, ",\n\t0x%02x", byte);\r\nelse\r\nfprintf(out, "\t0x%02x", byte);\r\nwrite_hex_cnt++;\r\n}\r\nstatic void write_logo_mono(void)\r\n{\r\nunsigned int i, j;\r\nunsigned char val, bit;\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++)\r\nif (!is_black(logo_data[i][j]) && !is_white(logo_data[i][j]))\r\ndie("Image must be monochrome\n");\r\nwrite_header();\r\nfor (i = 0; i < logo_height; i++) {\r\nfor (j = 0; j < logo_width;) {\r\nfor (val = 0, bit = 0x80; bit && j < logo_width; j++, bit >>= 1)\r\nif (logo_data[i][j].red)\r\nval |= bit;\r\nwrite_hex(val);\r\n}\r\n}\r\nwrite_footer();\r\n}\r\nstatic void write_logo_vga16(void)\r\n{\r\nunsigned int i, j, k;\r\nunsigned char val;\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++) {\r\nfor (k = 0; k < 16; k++)\r\nif (is_equal(logo_data[i][j], clut_vga16[k]))\r\nbreak;\r\nif (k == 16)\r\ndie("Image must use the 16 console colors only\n"\r\n"Use ppmquant(1) -map clut_vga16.ppm to reduce the number "\r\n"of colors\n");\r\n}\r\nwrite_header();\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++) {\r\nfor (k = 0; k < 16; k++)\r\nif (is_equal(logo_data[i][j], clut_vga16[k]))\r\nbreak;\r\nval = k<<4;\r\nif (++j < logo_width) {\r\nfor (k = 0; k < 16; k++)\r\nif (is_equal(logo_data[i][j], clut_vga16[k]))\r\nbreak;\r\nval |= k;\r\n}\r\nwrite_hex(val);\r\n}\r\nwrite_footer();\r\n}\r\nstatic void write_logo_clut224(void)\r\n{\r\nunsigned int i, j, k;\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++) {\r\nfor (k = 0; k < logo_clutsize; k++)\r\nif (is_equal(logo_data[i][j], logo_clut[k]))\r\nbreak;\r\nif (k == logo_clutsize) {\r\nif (logo_clutsize == MAX_LINUX_LOGO_COLORS)\r\ndie("Image has more than %d colors\n"\r\n"Use ppmquant(1) to reduce the number of colors\n",\r\nMAX_LINUX_LOGO_COLORS);\r\nlogo_clut[logo_clutsize++] = logo_data[i][j];\r\n}\r\n}\r\nwrite_header();\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++) {\r\nfor (k = 0; k < logo_clutsize; k++)\r\nif (is_equal(logo_data[i][j], logo_clut[k]))\r\nbreak;\r\nwrite_hex(k+32);\r\n}\r\nfputs("\n};\n\n", out);\r\nfprintf(out, "static unsigned char %s_clut[] __initdata = {\n",\r\nlogoname);\r\nwrite_hex_cnt = 0;\r\nfor (i = 0; i < logo_clutsize; i++) {\r\nwrite_hex(logo_clut[i].red);\r\nwrite_hex(logo_clut[i].green);\r\nwrite_hex(logo_clut[i].blue);\r\n}\r\nwrite_footer();\r\n}\r\nstatic void write_logo_gray256(void)\r\n{\r\nunsigned int i, j;\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++)\r\nif (!is_gray(logo_data[i][j]))\r\ndie("Image must be grayscale\n");\r\nwrite_header();\r\nfor (i = 0; i < logo_height; i++)\r\nfor (j = 0; j < logo_width; j++)\r\nwrite_hex(logo_data[i][j].red);\r\nwrite_footer();\r\n}\r\nstatic void die(const char *fmt, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, fmt);\r\nvfprintf(stderr, fmt, ap);\r\nva_end(ap);\r\nexit(1);\r\n}\r\nstatic void usage(void)\r\n{\r\ndie("\n"\r\n"Usage: %s [options] <filename>\n"\r\n"\n"\r\n"Valid options:\n"\r\n" -h : display this usage information\n"\r\n" -n <name> : specify logo name (default: linux_logo)\n"\r\n" -o <output> : output to file <output> instead of stdout\n"\r\n" -t <type> : specify logo type, one of\n"\r\n" mono : monochrome black/white\n"\r\n" vga16 : 16 colors VGA text palette\n"\r\n" clut224 : 224 colors (default)\n"\r\n" gray256 : 256 levels grayscale\n"\r\n"\n", programname);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint opt;\r\nprogramname = argv[0];\r\nopterr = 0;\r\nwhile (1) {\r\nopt = getopt(argc, argv, "hn:o:t:");\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'h':\r\nusage();\r\nbreak;\r\ncase 'n':\r\nlogoname = optarg;\r\nbreak;\r\ncase 'o':\r\noutputname = optarg;\r\nbreak;\r\ncase 't':\r\nif (!strcmp(optarg, "mono"))\r\nlogo_type = LINUX_LOGO_MONO;\r\nelse if (!strcmp(optarg, "vga16"))\r\nlogo_type = LINUX_LOGO_VGA16;\r\nelse if (!strcmp(optarg, "clut224"))\r\nlogo_type = LINUX_LOGO_CLUT224;\r\nelse if (!strcmp(optarg, "gray256"))\r\nlogo_type = LINUX_LOGO_GRAY256;\r\nelse\r\nusage();\r\nbreak;\r\ndefault:\r\nusage();\r\nbreak;\r\n}\r\n}\r\nif (optind != argc-1)\r\nusage();\r\nfilename = argv[optind];\r\nread_image();\r\nswitch (logo_type) {\r\ncase LINUX_LOGO_MONO:\r\nwrite_logo_mono();\r\nbreak;\r\ncase LINUX_LOGO_VGA16:\r\nwrite_logo_vga16();\r\nbreak;\r\ncase LINUX_LOGO_CLUT224:\r\nwrite_logo_clut224();\r\nbreak;\r\ncase LINUX_LOGO_GRAY256:\r\nwrite_logo_gray256();\r\nbreak;\r\n}\r\nexit(0);\r\n}
