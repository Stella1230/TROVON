static int cmi_mux_enum_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_input_mux_info(spec->input_mux, uinfo);\r\n}\r\nstatic int cmi_mux_enum_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cmi_spec *spec = codec->spec;\r\nunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nucontrol->value.enumerated.item[0] = spec->cur_mux[adc_idx];\r\nreturn 0;\r\n}\r\nstatic int cmi_mux_enum_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cmi_spec *spec = codec->spec;\r\nunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nreturn snd_hda_input_mux_put(codec, spec->input_mux, ucontrol,\r\nspec->adc_nids[adc_idx], &spec->cur_mux[adc_idx]);\r\n}\r\nstatic int cmi_ch_mode_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_ch_mode_info(codec, uinfo, spec->channel_modes,\r\nspec->num_channel_modes);\r\n}\r\nstatic int cmi_ch_mode_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_ch_mode_get(codec, ucontrol, spec->channel_modes,\r\nspec->num_channel_modes, spec->multiout.max_channels);\r\n}\r\nstatic int cmi_ch_mode_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_ch_mode_put(codec, ucontrol, spec->channel_modes,\r\nspec->num_channel_modes, &spec->multiout.max_channels);\r\n}\r\nstatic int cmi9880_build_controls(struct hda_codec *codec)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nstruct snd_kcontrol *kctl;\r\nint i, err;\r\nerr = snd_hda_add_new_ctls(codec, cmi9880_basic_mixer);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->channel_modes) {\r\nerr = snd_hda_add_new_ctls(codec, cmi9880_ch_mode_mixer);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->multiout.dig_out_nid) {\r\nerr = snd_hda_create_spdif_out_ctls(codec,\r\nspec->multiout.dig_out_nid,\r\nspec->multiout.dig_out_nid);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_create_spdif_share_sw(codec,\r\n&spec->multiout);\r\nif (err < 0)\r\nreturn err;\r\nspec->multiout.share_spdif = 1;\r\n}\r\nif (spec->dig_in_nid) {\r\nerr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in_nid);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nkctl = snd_hda_find_mixer_ctl(codec, "Capture Source");\r\nfor (i = 0; kctl && i < kctl->count; i++) {\r\nerr = snd_hda_add_nid(codec, kctl, i, spec->adc_nids[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cmi9880_fill_multi_dac_nids(struct hda_codec *codec, const struct auto_pin_cfg *cfg)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nint assigned[4];\r\nint i, j;\r\nmemset(spec->dac_nids, 0, sizeof(spec->dac_nids));\r\nmemset(assigned, 0, sizeof(assigned));\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\nnid = cfg->line_out_pins[i];\r\nif (nid >= 0x0b && nid <= 0x0e) {\r\nspec->dac_nids[i] = (nid - 0x0b) + 0x03;\r\nassigned[nid - 0x0b] = 1;\r\n}\r\n}\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\nnid = cfg->line_out_pins[i];\r\nif (nid <= 0x0e)\r\ncontinue;\r\nfor (j = 0; j < cfg->line_outs; j++) {\r\nif (! assigned[j]) {\r\nspec->dac_nids[i] = j + 0x03;\r\nassigned[j] = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nspec->num_dacs = cfg->line_outs;\r\nreturn 0;\r\n}\r\nstatic int cmi9880_fill_multi_init(struct hda_codec *codec, const struct auto_pin_cfg *cfg)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nint i, j, k;\r\nmemset(spec->multi_init, 0, sizeof(spec->multi_init));\r\nfor (j = 0, i = 0; i < cfg->line_outs; i++) {\r\nnid = cfg->line_out_pins[i];\r\nspec->multi_init[j].nid = nid;\r\nspec->multi_init[j].verb = AC_VERB_SET_PIN_WIDGET_CONTROL;\r\nspec->multi_init[j].param = PIN_OUT;\r\nj++;\r\nif (nid > 0x0e) {\r\nspec->multi_init[j].nid = nid;\r\nspec->multi_init[j].verb = AC_VERB_SET_CONNECT_SEL;\r\nspec->multi_init[j].param = 0;\r\nk = snd_hda_get_conn_index(codec, nid,\r\nspec->dac_nids[i], 0);\r\nif (k >= 0)\r\nspec->multi_init[j].param = k;\r\nj++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cmi9880_init(struct hda_codec *codec)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nif (spec->board_config == CMI_ALLOUT)\r\nsnd_hda_sequence_write(codec, cmi9880_allout_init);\r\nelse\r\nsnd_hda_sequence_write(codec, cmi9880_basic_init);\r\nif (spec->board_config == CMI_AUTO)\r\nsnd_hda_sequence_write(codec, spec->multi_init);\r\nreturn 0;\r\n}\r\nstatic int cmi9880_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_open(codec, &spec->multiout, substream,\r\nhinfo);\r\n}\r\nstatic int cmi9880_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_prepare(codec, &spec->multiout, stream_tag,\r\nformat, substream);\r\n}\r\nstatic int cmi9880_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);\r\n}\r\nstatic int cmi9880_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\r\n}\r\nstatic int cmi9880_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int cmi9880_dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout, stream_tag,\r\nformat, substream);\r\n}\r\nstatic int cmi9880_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nsnd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number],\r\nstream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int cmi9880_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec, spec->adc_nids[substream->number]);\r\nreturn 0;\r\n}\r\nstatic int cmi9880_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct cmi_spec *spec = codec->spec;\r\nstruct hda_pcm *info = spec->pcm_rec;\r\ncodec->num_pcms = 1;\r\ncodec->pcm_info = info;\r\ninfo->name = "CMI9880";\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = cmi9880_pcm_analog_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = cmi9880_pcm_analog_capture;\r\nif (spec->multiout.dig_out_nid || spec->dig_in_nid) {\r\ncodec->num_pcms++;\r\ninfo++;\r\ninfo->name = "CMI9880 Digital";\r\ninfo->pcm_type = HDA_PCM_TYPE_SPDIF;\r\nif (spec->multiout.dig_out_nid) {\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = cmi9880_pcm_digital_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->multiout.dig_out_nid;\r\n}\r\nif (spec->dig_in_nid) {\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = cmi9880_pcm_digital_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in_nid;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cmi9880_free(struct hda_codec *codec)\r\n{\r\nkfree(codec->spec);\r\n}\r\nstatic int patch_cmi9880(struct hda_codec *codec)\r\n{\r\nstruct cmi_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nspec->board_config = snd_hda_check_board_config(codec, CMI_MODELS,\r\ncmi9880_models,\r\ncmi9880_cfg_tbl);\r\nif (spec->board_config < 0) {\r\nsnd_printdd(KERN_INFO "hda_codec: %s: BIOS auto-probing.\n",\r\ncodec->chip_name);\r\nspec->board_config = CMI_AUTO;\r\n}\r\nmemcpy(spec->dac_nids, cmi9880_dac_nids, sizeof(spec->dac_nids));\r\nspec->num_dacs = 4;\r\nswitch (spec->board_config) {\r\ncase CMI_MINIMAL:\r\ncase CMI_MIN_FP:\r\nspec->channel_modes = cmi9880_channel_modes;\r\nif (spec->board_config == CMI_MINIMAL)\r\nspec->num_channel_modes = 2;\r\nelse {\r\nspec->front_panel = 1;\r\nspec->num_channel_modes = 3;\r\n}\r\nspec->multiout.max_channels = cmi9880_channel_modes[0].channels;\r\nspec->input_mux = &cmi9880_basic_mux;\r\nbreak;\r\ncase CMI_FULL:\r\ncase CMI_FULL_DIG:\r\nspec->front_panel = 1;\r\nspec->multiout.max_channels = 8;\r\nspec->input_mux = &cmi9880_basic_mux;\r\nif (spec->board_config == CMI_FULL_DIG) {\r\nspec->multiout.dig_out_nid = CMI_DIG_OUT_NID;\r\nspec->dig_in_nid = CMI_DIG_IN_NID;\r\n}\r\nbreak;\r\ncase CMI_ALLOUT:\r\nspec->front_panel = 1;\r\nspec->multiout.max_channels = 8;\r\nspec->no_line_in = 1;\r\nspec->input_mux = &cmi9880_no_line_mux;\r\nspec->multiout.dig_out_nid = CMI_DIG_OUT_NID;\r\nbreak;\r\ncase CMI_AUTO:\r\n{\r\nunsigned int port_e, port_f, port_g, port_h;\r\nunsigned int port_spdifi, port_spdifo;\r\nstruct auto_pin_cfg cfg;\r\nport_e = snd_hda_codec_get_pincfg(codec, 0x0f);\r\nport_f = snd_hda_codec_get_pincfg(codec, 0x10);\r\nspec->front_panel = 1;\r\nif (get_defcfg_connect(port_e) == AC_JACK_PORT_NONE ||\r\nget_defcfg_connect(port_f) == AC_JACK_PORT_NONE) {\r\nport_g = snd_hda_codec_get_pincfg(codec, 0x1f);\r\nport_h = snd_hda_codec_get_pincfg(codec, 0x20);\r\nspec->channel_modes = cmi9880_channel_modes;\r\nif (get_defcfg_connect(port_g) == AC_JACK_PORT_NONE ||\r\nget_defcfg_connect(port_h) == AC_JACK_PORT_NONE) {\r\nspec->board_config = CMI_MINIMAL;\r\nspec->front_panel = 0;\r\nspec->num_channel_modes = 2;\r\n} else {\r\nspec->board_config = CMI_MIN_FP;\r\nspec->num_channel_modes = 3;\r\n}\r\nspec->input_mux = &cmi9880_basic_mux;\r\nspec->multiout.max_channels = cmi9880_channel_modes[0].channels;\r\n} else {\r\nspec->input_mux = &cmi9880_basic_mux;\r\nport_spdifi = snd_hda_codec_get_pincfg(codec, 0x13);\r\nport_spdifo = snd_hda_codec_get_pincfg(codec, 0x12);\r\nif (get_defcfg_connect(port_spdifo) != AC_JACK_PORT_NONE)\r\nspec->multiout.dig_out_nid = CMI_DIG_OUT_NID;\r\nif (get_defcfg_connect(port_spdifi) != AC_JACK_PORT_NONE)\r\nspec->dig_in_nid = CMI_DIG_IN_NID;\r\nspec->multiout.max_channels = 8;\r\n}\r\nsnd_hda_parse_pin_def_config(codec, &cfg, NULL);\r\nif (cfg.line_outs) {\r\nspec->multiout.max_channels = cfg.line_outs * 2;\r\ncmi9880_fill_multi_dac_nids(codec, &cfg);\r\ncmi9880_fill_multi_init(codec, &cfg);\r\n} else\r\nsnd_printd("patch_cmedia: cannot detect association in defcfg\n");\r\nbreak;\r\n}\r\n}\r\nspec->multiout.num_dacs = spec->num_dacs;\r\nspec->multiout.dac_nids = spec->dac_nids;\r\nspec->adc_nids = cmi9880_adc_nids;\r\ncodec->patch_ops = cmi9880_patch_ops;\r\nreturn 0;\r\n}\r\nstatic int __init patch_cmedia_init(void)\r\n{\r\nreturn snd_hda_add_codec_preset(&cmedia_list);\r\n}\r\nstatic void __exit patch_cmedia_exit(void)\r\n{\r\nsnd_hda_delete_codec_preset(&cmedia_list);\r\n}
