static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd, struct m25p, mtd);\r\n}\r\nstatic int read_sr(struct m25p *flash)\r\n{\r\nssize_t retval;\r\nu8 code = OPCODE_RDSR;\r\nu8 val;\r\nretval = spi_write_then_read(flash->spi, &code, 1, &val, 1);\r\nif (retval < 0) {\r\ndev_err(&flash->spi->dev, "error %d reading SR\n",\r\n(int) retval);\r\nreturn retval;\r\n}\r\nreturn val;\r\n}\r\nstatic int write_sr(struct m25p *flash, u8 val)\r\n{\r\nflash->command[0] = OPCODE_WRSR;\r\nflash->command[1] = val;\r\nreturn spi_write(flash->spi, flash->command, 2);\r\n}\r\nstatic inline int write_enable(struct m25p *flash)\r\n{\r\nu8 code = OPCODE_WREN;\r\nreturn spi_write_then_read(flash->spi, &code, 1, NULL, 0);\r\n}\r\nstatic inline int write_disable(struct m25p *flash)\r\n{\r\nu8 code = OPCODE_WRDI;\r\nreturn spi_write_then_read(flash->spi, &code, 1, NULL, 0);\r\n}\r\nstatic inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)\r\n{\r\nswitch (JEDEC_MFR(jedec_id)) {\r\ncase CFI_MFR_MACRONIX:\r\nflash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;\r\nreturn spi_write(flash->spi, flash->command, 1);\r\ndefault:\r\nflash->command[0] = OPCODE_BRWR;\r\nflash->command[1] = enable << 7;\r\nreturn spi_write(flash->spi, flash->command, 2);\r\n}\r\n}\r\nstatic int wait_till_ready(struct m25p *flash)\r\n{\r\nunsigned long deadline;\r\nint sr;\r\ndeadline = jiffies + MAX_READY_WAIT_JIFFIES;\r\ndo {\r\nif ((sr = read_sr(flash)) < 0)\r\nbreak;\r\nelse if (!(sr & SR_WIP))\r\nreturn 0;\r\ncond_resched();\r\n} while (!time_after_eq(jiffies, deadline));\r\nreturn 1;\r\n}\r\nstatic int erase_chip(struct m25p *flash)\r\n{\r\npr_debug("%s: %s %lldKiB\n", dev_name(&flash->spi->dev), __func__,\r\n(long long)(flash->mtd.size >> 10));\r\nif (wait_till_ready(flash))\r\nreturn 1;\r\nwrite_enable(flash);\r\nflash->command[0] = OPCODE_CHIP_ERASE;\r\nspi_write(flash->spi, flash->command, 1);\r\nreturn 0;\r\n}\r\nstatic void m25p_addr2cmd(struct m25p *flash, unsigned int addr, u8 *cmd)\r\n{\r\ncmd[1] = addr >> (flash->addr_width * 8 - 8);\r\ncmd[2] = addr >> (flash->addr_width * 8 - 16);\r\ncmd[3] = addr >> (flash->addr_width * 8 - 24);\r\ncmd[4] = addr >> (flash->addr_width * 8 - 32);\r\n}\r\nstatic int m25p_cmdsz(struct m25p *flash)\r\n{\r\nreturn 1 + flash->addr_width;\r\n}\r\nstatic int erase_sector(struct m25p *flash, u32 offset)\r\n{\r\npr_debug("%s: %s %dKiB at 0x%08x\n", dev_name(&flash->spi->dev),\r\n__func__, flash->mtd.erasesize / 1024, offset);\r\nif (wait_till_ready(flash))\r\nreturn 1;\r\nwrite_enable(flash);\r\nflash->command[0] = flash->erase_opcode;\r\nm25p_addr2cmd(flash, offset, flash->command);\r\nspi_write(flash->spi, flash->command, m25p_cmdsz(flash));\r\nreturn 0;\r\n}\r\nstatic int m25p80_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct m25p *flash = mtd_to_m25p(mtd);\r\nu32 addr,len;\r\nuint32_t rem;\r\npr_debug("%s: %s at 0x%llx, len %lld\n", dev_name(&flash->spi->dev),\r\n__func__, (long long)instr->addr,\r\n(long long)instr->len);\r\ndiv_u64_rem(instr->len, mtd->erasesize, &rem);\r\nif (rem)\r\nreturn -EINVAL;\r\naddr = instr->addr;\r\nlen = instr->len;\r\nmutex_lock(&flash->lock);\r\nif (len == flash->mtd.size) {\r\nif (erase_chip(flash)) {\r\ninstr->state = MTD_ERASE_FAILED;\r\nmutex_unlock(&flash->lock);\r\nreturn -EIO;\r\n}\r\n} else {\r\nwhile (len) {\r\nif (erase_sector(flash, addr)) {\r\ninstr->state = MTD_ERASE_FAILED;\r\nmutex_unlock(&flash->lock);\r\nreturn -EIO;\r\n}\r\naddr += mtd->erasesize;\r\nlen -= mtd->erasesize;\r\n}\r\n}\r\nmutex_unlock(&flash->lock);\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct m25p *flash = mtd_to_m25p(mtd);\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\npr_debug("%s: %s from 0x%08x, len %zd\n", dev_name(&flash->spi->dev),\r\n__func__, (u32)from, len);\r\nspi_message_init(&m);\r\nmemset(t, 0, (sizeof t));\r\nt[0].tx_buf = flash->command;\r\nt[0].len = m25p_cmdsz(flash) + FAST_READ_DUMMY_BYTE;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = len;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&flash->lock);\r\nif (wait_till_ready(flash)) {\r\nmutex_unlock(&flash->lock);\r\nreturn 1;\r\n}\r\nflash->command[0] = OPCODE_READ;\r\nm25p_addr2cmd(flash, from, flash->command);\r\nspi_sync(flash->spi, &m);\r\n*retlen = m.actual_length - m25p_cmdsz(flash) - FAST_READ_DUMMY_BYTE;\r\nmutex_unlock(&flash->lock);\r\nreturn 0;\r\n}\r\nstatic int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct m25p *flash = mtd_to_m25p(mtd);\r\nu32 page_offset, page_size;\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\npr_debug("%s: %s to 0x%08x, len %zd\n", dev_name(&flash->spi->dev),\r\n__func__, (u32)to, len);\r\nspi_message_init(&m);\r\nmemset(t, 0, (sizeof t));\r\nt[0].tx_buf = flash->command;\r\nt[0].len = m25p_cmdsz(flash);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&flash->lock);\r\nif (wait_till_ready(flash)) {\r\nmutex_unlock(&flash->lock);\r\nreturn 1;\r\n}\r\nwrite_enable(flash);\r\nflash->command[0] = OPCODE_PP;\r\nm25p_addr2cmd(flash, to, flash->command);\r\npage_offset = to & (flash->page_size - 1);\r\nif (page_offset + len <= flash->page_size) {\r\nt[1].len = len;\r\nspi_sync(flash->spi, &m);\r\n*retlen = m.actual_length - m25p_cmdsz(flash);\r\n} else {\r\nu32 i;\r\npage_size = flash->page_size - page_offset;\r\nt[1].len = page_size;\r\nspi_sync(flash->spi, &m);\r\n*retlen = m.actual_length - m25p_cmdsz(flash);\r\nfor (i = page_size; i < len; i += page_size) {\r\npage_size = len - i;\r\nif (page_size > flash->page_size)\r\npage_size = flash->page_size;\r\nm25p_addr2cmd(flash, to + i, flash->command);\r\nt[1].tx_buf = buf + i;\r\nt[1].len = page_size;\r\nwait_till_ready(flash);\r\nwrite_enable(flash);\r\nspi_sync(flash->spi, &m);\r\n*retlen += m.actual_length - m25p_cmdsz(flash);\r\n}\r\n}\r\nmutex_unlock(&flash->lock);\r\nreturn 0;\r\n}\r\nstatic int sst_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct m25p *flash = mtd_to_m25p(mtd);\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nsize_t actual;\r\nint cmd_sz, ret;\r\npr_debug("%s: %s to 0x%08x, len %zd\n", dev_name(&flash->spi->dev),\r\n__func__, (u32)to, len);\r\nspi_message_init(&m);\r\nmemset(t, 0, (sizeof t));\r\nt[0].tx_buf = flash->command;\r\nt[0].len = m25p_cmdsz(flash);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&flash->lock);\r\nret = wait_till_ready(flash);\r\nif (ret)\r\ngoto time_out;\r\nwrite_enable(flash);\r\nactual = to % 2;\r\nif (actual) {\r\nflash->command[0] = OPCODE_BP;\r\nm25p_addr2cmd(flash, to, flash->command);\r\nt[1].len = 1;\r\nspi_sync(flash->spi, &m);\r\nret = wait_till_ready(flash);\r\nif (ret)\r\ngoto time_out;\r\n*retlen += m.actual_length - m25p_cmdsz(flash);\r\n}\r\nto += actual;\r\nflash->command[0] = OPCODE_AAI_WP;\r\nm25p_addr2cmd(flash, to, flash->command);\r\ncmd_sz = m25p_cmdsz(flash);\r\nfor (; actual < len - 1; actual += 2) {\r\nt[0].len = cmd_sz;\r\nt[1].len = 2;\r\nt[1].tx_buf = buf + actual;\r\nspi_sync(flash->spi, &m);\r\nret = wait_till_ready(flash);\r\nif (ret)\r\ngoto time_out;\r\n*retlen += m.actual_length - cmd_sz;\r\ncmd_sz = 1;\r\nto += 2;\r\n}\r\nwrite_disable(flash);\r\nret = wait_till_ready(flash);\r\nif (ret)\r\ngoto time_out;\r\nif (actual != len) {\r\nwrite_enable(flash);\r\nflash->command[0] = OPCODE_BP;\r\nm25p_addr2cmd(flash, to, flash->command);\r\nt[0].len = m25p_cmdsz(flash);\r\nt[1].len = 1;\r\nt[1].tx_buf = buf + actual;\r\nspi_sync(flash->spi, &m);\r\nret = wait_till_ready(flash);\r\nif (ret)\r\ngoto time_out;\r\n*retlen += m.actual_length - m25p_cmdsz(flash);\r\nwrite_disable(flash);\r\n}\r\ntime_out:\r\nmutex_unlock(&flash->lock);\r\nreturn ret;\r\n}\r\nstatic const struct spi_device_id *__devinit jedec_probe(struct spi_device *spi)\r\n{\r\nint tmp;\r\nu8 code = OPCODE_RDID;\r\nu8 id[5];\r\nu32 jedec;\r\nu16 ext_jedec;\r\nstruct flash_info *info;\r\ntmp = spi_write_then_read(spi, &code, 1, id, 5);\r\nif (tmp < 0) {\r\npr_debug("%s: error %d reading JEDEC ID\n",\r\ndev_name(&spi->dev), tmp);\r\nreturn ERR_PTR(tmp);\r\n}\r\njedec = id[0];\r\njedec = jedec << 8;\r\njedec |= id[1];\r\njedec = jedec << 8;\r\njedec |= id[2];\r\next_jedec = id[3] << 8 | id[4];\r\nfor (tmp = 0; tmp < ARRAY_SIZE(m25p_ids) - 1; tmp++) {\r\ninfo = (void *)m25p_ids[tmp].driver_data;\r\nif (info->jedec_id == jedec) {\r\nif (info->ext_id != 0 && info->ext_id != ext_jedec)\r\ncontinue;\r\nreturn &m25p_ids[tmp];\r\n}\r\n}\r\ndev_err(&spi->dev, "unrecognized JEDEC id %06x\n", jedec);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int __devinit m25p_probe(struct spi_device *spi)\r\n{\r\nconst struct spi_device_id *id = spi_get_device_id(spi);\r\nstruct flash_platform_data *data;\r\nstruct m25p *flash;\r\nstruct flash_info *info;\r\nunsigned i;\r\nstruct mtd_part_parser_data ppdata;\r\n#ifdef CONFIG_MTD_OF_PARTS\r\nif (!of_device_is_available(spi->dev.of_node))\r\nreturn -ENODEV;\r\n#endif\r\ndata = spi->dev.platform_data;\r\nif (data && data->type) {\r\nconst struct spi_device_id *plat_id;\r\nfor (i = 0; i < ARRAY_SIZE(m25p_ids) - 1; i++) {\r\nplat_id = &m25p_ids[i];\r\nif (strcmp(data->type, plat_id->name))\r\ncontinue;\r\nbreak;\r\n}\r\nif (i < ARRAY_SIZE(m25p_ids) - 1)\r\nid = plat_id;\r\nelse\r\ndev_warn(&spi->dev, "unrecognized id %s\n", data->type);\r\n}\r\ninfo = (void *)id->driver_data;\r\nif (info->jedec_id) {\r\nconst struct spi_device_id *jid;\r\njid = jedec_probe(spi);\r\nif (IS_ERR(jid)) {\r\nreturn PTR_ERR(jid);\r\n} else if (jid != id) {\r\ndev_warn(&spi->dev, "found %s, expected %s\n",\r\njid->name, id->name);\r\nid = jid;\r\ninfo = (void *)jid->driver_data;\r\n}\r\n}\r\nflash = kzalloc(sizeof *flash, GFP_KERNEL);\r\nif (!flash)\r\nreturn -ENOMEM;\r\nflash->command = kmalloc(MAX_CMD_SIZE + FAST_READ_DUMMY_BYTE, GFP_KERNEL);\r\nif (!flash->command) {\r\nkfree(flash);\r\nreturn -ENOMEM;\r\n}\r\nflash->spi = spi;\r\nmutex_init(&flash->lock);\r\ndev_set_drvdata(&spi->dev, flash);\r\nif (JEDEC_MFR(info->jedec_id) == CFI_MFR_ATMEL ||\r\nJEDEC_MFR(info->jedec_id) == CFI_MFR_INTEL ||\r\nJEDEC_MFR(info->jedec_id) == CFI_MFR_SST) {\r\nwrite_enable(flash);\r\nwrite_sr(flash, 0);\r\n}\r\nif (data && data->name)\r\nflash->mtd.name = data->name;\r\nelse\r\nflash->mtd.name = dev_name(&spi->dev);\r\nflash->mtd.type = MTD_NORFLASH;\r\nflash->mtd.writesize = 1;\r\nflash->mtd.flags = MTD_CAP_NORFLASH;\r\nflash->mtd.size = info->sector_size * info->n_sectors;\r\nflash->mtd._erase = m25p80_erase;\r\nflash->mtd._read = m25p80_read;\r\nif (JEDEC_MFR(info->jedec_id) == CFI_MFR_SST)\r\nflash->mtd._write = sst_write;\r\nelse\r\nflash->mtd._write = m25p80_write;\r\nif (info->flags & SECT_4K) {\r\nflash->erase_opcode = OPCODE_BE_4K;\r\nflash->mtd.erasesize = 4096;\r\n} else {\r\nflash->erase_opcode = OPCODE_SE;\r\nflash->mtd.erasesize = info->sector_size;\r\n}\r\nif (info->flags & M25P_NO_ERASE)\r\nflash->mtd.flags |= MTD_NO_ERASE;\r\nppdata.of_node = spi->dev.of_node;\r\nflash->mtd.dev.parent = &spi->dev;\r\nflash->page_size = info->page_size;\r\nflash->mtd.writebufsize = flash->page_size;\r\nif (info->addr_width)\r\nflash->addr_width = info->addr_width;\r\nelse {\r\nif (flash->mtd.size > 0x1000000) {\r\nflash->addr_width = 4;\r\nset_4byte(flash, info->jedec_id, 1);\r\n} else\r\nflash->addr_width = 3;\r\n}\r\ndev_info(&spi->dev, "%s (%lld Kbytes)\n", id->name,\r\n(long long)flash->mtd.size >> 10);\r\npr_debug("mtd .name = %s, .size = 0x%llx (%lldMiB) "\r\n".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",\r\nflash->mtd.name,\r\n(long long)flash->mtd.size, (long long)(flash->mtd.size >> 20),\r\nflash->mtd.erasesize, flash->mtd.erasesize / 1024,\r\nflash->mtd.numeraseregions);\r\nif (flash->mtd.numeraseregions)\r\nfor (i = 0; i < flash->mtd.numeraseregions; i++)\r\npr_debug("mtd.eraseregions[%d] = { .offset = 0x%llx, "\r\n".erasesize = 0x%.8x (%uKiB), "\r\n".numblocks = %d }\n",\r\ni, (long long)flash->mtd.eraseregions[i].offset,\r\nflash->mtd.eraseregions[i].erasesize,\r\nflash->mtd.eraseregions[i].erasesize / 1024,\r\nflash->mtd.eraseregions[i].numblocks);\r\nreturn mtd_device_parse_register(&flash->mtd, NULL, &ppdata,\r\ndata ? data->parts : NULL,\r\ndata ? data->nr_parts : 0);\r\n}\r\nstatic int __devexit m25p_remove(struct spi_device *spi)\r\n{\r\nstruct m25p *flash = dev_get_drvdata(&spi->dev);\r\nint status;\r\nstatus = mtd_device_unregister(&flash->mtd);\r\nif (status == 0) {\r\nkfree(flash->command);\r\nkfree(flash);\r\n}\r\nreturn 0;\r\n}
