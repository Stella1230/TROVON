static int tps65912_get_range(struct tps65912_reg *pmic, int id)\r\n{\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint range;\r\nswitch (id) {\r\ncase TPS65912_REG_DCDC1:\r\nrange = tps65912_reg_read(mfd, TPS65912_DCDC1_LIMIT);\r\nbreak;\r\ncase TPS65912_REG_DCDC2:\r\nrange = tps65912_reg_read(mfd, TPS65912_DCDC2_LIMIT);\r\nbreak;\r\ncase TPS65912_REG_DCDC3:\r\nrange = tps65912_reg_read(mfd, TPS65912_DCDC3_LIMIT);\r\nbreak;\r\ncase TPS65912_REG_DCDC4:\r\nrange = tps65912_reg_read(mfd, TPS65912_DCDC4_LIMIT);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (range >= 0)\r\nrange = (range & DCDC_LIMIT_RANGE_MASK)\r\n>> DCDC_LIMIT_RANGE_SHIFT;\r\npmic->dcdc_range[id] = range;\r\nreturn range;\r\n}\r\nstatic unsigned long tps65912_vsel_to_uv_range0(u8 vsel)\r\n{\r\nunsigned long uv;\r\nuv = ((vsel * 12500) + 500000);\r\nreturn uv;\r\n}\r\nstatic unsigned long tps65912_vsel_to_uv_range1(u8 vsel)\r\n{\r\nunsigned long uv;\r\nuv = ((vsel * 12500) + 700000);\r\nreturn uv;\r\n}\r\nstatic unsigned long tps65912_vsel_to_uv_range2(u8 vsel)\r\n{\r\nunsigned long uv;\r\nuv = ((vsel * 25000) + 500000);\r\nreturn uv;\r\n}\r\nstatic unsigned long tps65912_vsel_to_uv_range3(u8 vsel)\r\n{\r\nunsigned long uv;\r\nif (vsel == 0x3f)\r\nuv = 3800000;\r\nelse\r\nuv = ((vsel * 50000) + 500000);\r\nreturn uv;\r\n}\r\nstatic unsigned long tps65912_vsel_to_uv_ldo(u8 vsel)\r\n{\r\nunsigned long uv = 0;\r\nif (vsel <= 32)\r\nuv = ((vsel * 25000) + 800000);\r\nelse if (vsel > 32 && vsel <= 60)\r\nuv = (((vsel - 32) * 50000) + 1600000);\r\nelse if (vsel > 60)\r\nuv = (((vsel - 60) * 100000) + 3000000);\r\nreturn uv;\r\n}\r\nstatic int tps65912_get_ctrl_register(int id)\r\n{\r\nif (id >= TPS65912_REG_DCDC1 && id <= TPS65912_REG_LDO4)\r\nreturn id * 3 + TPS65912_DCDC1_AVS;\r\nelse if (id >= TPS65912_REG_LDO5 && id <= TPS65912_REG_LDO10)\r\nreturn id - TPS65912_REG_LDO5 + TPS65912_LDO5;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int tps65912_get_sel_register(struct tps65912_reg *pmic, int id)\r\n{\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint opvsel;\r\nu8 reg = 0;\r\nif (id >= TPS65912_REG_DCDC1 && id <= TPS65912_REG_LDO4) {\r\nopvsel = tps65912_reg_read(mfd, id * 3 + TPS65912_DCDC1_OP);\r\nif (opvsel & OP_SELREG_MASK)\r\nreg = id * 3 + TPS65912_DCDC1_AVS;\r\nelse\r\nreg = id * 3 + TPS65912_DCDC1_OP;\r\n} else if (id >= TPS65912_REG_LDO5 && id <= TPS65912_REG_LDO10) {\r\nreg = id - TPS65912_REG_LDO5 + TPS65912_LDO5;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn reg;\r\n}\r\nstatic int tps65912_get_mode_regiters(struct tps65912_reg *pmic, int id)\r\n{\r\nswitch (id) {\r\ncase TPS65912_REG_DCDC1:\r\npmic->pwm_mode_reg = TPS65912_DCDC1_CTRL;\r\npmic->eco_reg = TPS65912_DCDC1_AVS;\r\nbreak;\r\ncase TPS65912_REG_DCDC2:\r\npmic->pwm_mode_reg = TPS65912_DCDC2_CTRL;\r\npmic->eco_reg = TPS65912_DCDC2_AVS;\r\nbreak;\r\ncase TPS65912_REG_DCDC3:\r\npmic->pwm_mode_reg = TPS65912_DCDC3_CTRL;\r\npmic->eco_reg = TPS65912_DCDC3_AVS;\r\nbreak;\r\ncase TPS65912_REG_DCDC4:\r\npmic->pwm_mode_reg = TPS65912_DCDC4_CTRL;\r\npmic->eco_reg = TPS65912_DCDC4_AVS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65912_reg_is_enabled(struct regulator_dev *dev)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint reg, value, id = rdev_get_id(dev);\r\nif (id < TPS65912_REG_DCDC1 || id > TPS65912_REG_LDO10)\r\nreturn -EINVAL;\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nvalue = tps65912_reg_read(mfd, reg);\r\nif (value < 0)\r\nreturn value;\r\nreturn value & TPS65912_REG_ENABLED;\r\n}\r\nstatic int tps65912_reg_enable(struct regulator_dev *dev)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint id = rdev_get_id(dev);\r\nint reg;\r\nif (id < TPS65912_REG_DCDC1 || id > TPS65912_REG_LDO10)\r\nreturn -EINVAL;\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nreturn tps65912_set_bits(mfd, reg, TPS65912_REG_ENABLED);\r\n}\r\nstatic int tps65912_reg_disable(struct regulator_dev *dev)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint id = rdev_get_id(dev), reg;\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nreturn tps65912_clear_bits(mfd, reg, TPS65912_REG_ENABLED);\r\n}\r\nstatic int tps65912_set_mode(struct regulator_dev *dev, unsigned int mode)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint pwm_mode, eco, id = rdev_get_id(dev);\r\ntps65912_get_mode_regiters(pmic, id);\r\npwm_mode = tps65912_reg_read(mfd, pmic->pwm_mode_reg);\r\neco = tps65912_reg_read(mfd, pmic->eco_reg);\r\npwm_mode &= DCDCCTRL_DCDC_MODE_MASK;\r\neco &= DCDC_AVS_ECO_MASK;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nif (pwm_mode && !eco)\r\nbreak;\r\ntps65912_set_bits(mfd, pmic->pwm_mode_reg, DCDCCTRL_DCDC_MODE_MASK);\r\ntps65912_clear_bits(mfd, pmic->eco_reg, DCDC_AVS_ECO_MASK);\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\ncase REGULATOR_MODE_IDLE:\r\nif (!pwm_mode && !eco)\r\nbreak;\r\ntps65912_clear_bits(mfd, pmic->pwm_mode_reg, DCDCCTRL_DCDC_MODE_MASK);\r\ntps65912_clear_bits(mfd, pmic->eco_reg, DCDC_AVS_ECO_MASK);\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nif (!pwm_mode && eco)\r\nbreak;\r\ntps65912_clear_bits(mfd, pmic->pwm_mode_reg, DCDCCTRL_DCDC_MODE_MASK);\r\ntps65912_set_bits(mfd, pmic->eco_reg, DCDC_AVS_ECO_MASK);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int tps65912_get_mode(struct regulator_dev *dev)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint pwm_mode, eco, mode = 0, id = rdev_get_id(dev);\r\ntps65912_get_mode_regiters(pmic, id);\r\npwm_mode = tps65912_reg_read(mfd, pmic->pwm_mode_reg);\r\neco = tps65912_reg_read(mfd, pmic->eco_reg);\r\npwm_mode &= DCDCCTRL_DCDC_MODE_MASK;\r\neco &= DCDC_AVS_ECO_MASK;\r\nif (pwm_mode && !eco)\r\nmode = REGULATOR_MODE_FAST;\r\nelse if (!pwm_mode && !eco)\r\nmode = REGULATOR_MODE_NORMAL;\r\nelse if (!pwm_mode && eco)\r\nmode = REGULATOR_MODE_STANDBY;\r\nreturn mode;\r\n}\r\nstatic int tps65912_list_voltage(struct regulator_dev *dev, unsigned selector)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nint range, voltage = 0, id = rdev_get_id(dev);\r\nif (id >= TPS65912_REG_LDO1 && id <= TPS65912_REG_LDO10)\r\nreturn tps65912_vsel_to_uv_ldo(selector);\r\nif (id > TPS65912_REG_DCDC4)\r\nreturn -EINVAL;\r\nrange = pmic->dcdc_range[id];\r\nswitch (range) {\r\ncase 0:\r\nvoltage = tps65912_vsel_to_uv_range0(selector);\r\nbreak;\r\ncase 1:\r\nvoltage = tps65912_vsel_to_uv_range1(selector);\r\nbreak;\r\ncase 2:\r\nvoltage = tps65912_vsel_to_uv_range2(selector);\r\nbreak;\r\ncase 3:\r\nvoltage = tps65912_vsel_to_uv_range3(selector);\r\nbreak;\r\n}\r\nreturn voltage;\r\n}\r\nstatic int tps65912_get_voltage_sel(struct regulator_dev *dev)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint id = rdev_get_id(dev);\r\nint reg, vsel;\r\nreg = tps65912_get_sel_register(pmic, id);\r\nif (reg < 0)\r\nreturn reg;\r\nvsel = tps65912_reg_read(mfd, reg);\r\nvsel &= 0x3F;\r\nreturn vsel;\r\n}\r\nstatic int tps65912_set_voltage_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct tps65912_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65912 *mfd = pmic->mfd;\r\nint id = rdev_get_id(dev);\r\nint value;\r\nu8 reg;\r\nreg = tps65912_get_sel_register(pmic, id);\r\nvalue = tps65912_reg_read(mfd, reg);\r\nvalue &= 0xC0;\r\nreturn tps65912_reg_write(mfd, reg, selector | value);\r\n}\r\nstatic __devinit int tps65912_probe(struct platform_device *pdev)\r\n{\r\nstruct tps65912 *tps65912 = dev_get_drvdata(pdev->dev.parent);\r\nstruct regulator_config config = { };\r\nstruct tps_info *info;\r\nstruct regulator_init_data *reg_data;\r\nstruct regulator_dev *rdev;\r\nstruct tps65912_reg *pmic;\r\nstruct tps65912_board *pmic_plat_data;\r\nint i, err;\r\npmic_plat_data = dev_get_platdata(tps65912->dev);\r\nif (!pmic_plat_data)\r\nreturn -EINVAL;\r\nreg_data = pmic_plat_data->tps65912_pmic_init_data;\r\npmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\r\nif (!pmic)\r\nreturn -ENOMEM;\r\nmutex_init(&pmic->io_lock);\r\npmic->mfd = tps65912;\r\nplatform_set_drvdata(pdev, pmic);\r\npmic->get_ctrl_reg = &tps65912_get_ctrl_register;\r\ninfo = tps65912_regs;\r\nfor (i = 0; i < TPS65912_NUM_REGULATOR; i++, info++, reg_data++) {\r\nint range = 0;\r\npmic->info[i] = info;\r\npmic->desc[i].name = info->name;\r\npmic->desc[i].id = i;\r\npmic->desc[i].n_voltages = 64;\r\npmic->desc[i].ops = (i > TPS65912_REG_DCDC4 ?\r\n&tps65912_ops_ldo : &tps65912_ops_dcdc);\r\npmic->desc[i].type = REGULATOR_VOLTAGE;\r\npmic->desc[i].owner = THIS_MODULE;\r\nrange = tps65912_get_range(pmic, i);\r\nconfig.dev = tps65912->dev;\r\nconfig.init_data = reg_data;\r\nconfig.driver_data = pmic;\r\nrdev = regulator_register(&pmic->desc[i], &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(tps65912->dev,\r\n"failed to register %s regulator\n",\r\npdev->name);\r\nerr = PTR_ERR(rdev);\r\ngoto err;\r\n}\r\npmic->rdev[i] = rdev;\r\n}\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0)\r\nregulator_unregister(pmic->rdev[i]);\r\nreturn err;\r\n}\r\nstatic int __devexit tps65912_remove(struct platform_device *pdev)\r\n{\r\nstruct tps65912_reg *tps65912_reg = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < TPS65912_NUM_REGULATOR; i++)\r\nregulator_unregister(tps65912_reg->rdev[i]);\r\nreturn 0;\r\n}\r\nstatic int __init tps65912_init(void)\r\n{\r\nreturn platform_driver_register(&tps65912_driver);\r\n}\r\nstatic void __exit tps65912_cleanup(void)\r\n{\r\nplatform_driver_unregister(&tps65912_driver);\r\n}
