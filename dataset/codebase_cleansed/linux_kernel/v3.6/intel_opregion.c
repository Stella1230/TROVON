static u32 asle_set_backlight(struct drm_device *dev, u32 bclp)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct opregion_asle __iomem *asle = dev_priv->opregion.asle;\r\nu32 max;\r\nif (!(bclp & ASLE_BCLP_VALID))\r\nreturn ASLE_BACKLIGHT_FAILED;\r\nbclp &= ASLE_BCLP_MSK;\r\nif (bclp > 255)\r\nreturn ASLE_BACKLIGHT_FAILED;\r\nmax = intel_panel_get_max_backlight(dev);\r\nintel_panel_set_backlight(dev, bclp * max / 255);\r\niowrite32((bclp*0x64)/0xff | ASLE_CBLV_VALID, &asle->cblv);\r\nreturn 0;\r\n}\r\nstatic u32 asle_set_als_illum(struct drm_device *dev, u32 alsi)\r\n{\r\nreturn 0;\r\n}\r\nstatic u32 asle_set_pwm_freq(struct drm_device *dev, u32 pfmb)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (pfmb & ASLE_PFMB_PWM_VALID) {\r\nu32 blc_pwm_ctl = I915_READ(BLC_PWM_CTL);\r\nu32 pwm = pfmb & ASLE_PFMB_PWM_MASK;\r\nblc_pwm_ctl &= BACKLIGHT_DUTY_CYCLE_MASK;\r\npwm = pwm >> 9;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 asle_set_pfit(struct drm_device *dev, u32 pfit)\r\n{\r\nif (!(pfit & ASLE_PFIT_VALID))\r\nreturn ASLE_PFIT_FAILED;\r\nreturn 0;\r\n}\r\nvoid intel_opregion_asle_intr(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct opregion_asle __iomem *asle = dev_priv->opregion.asle;\r\nu32 asle_stat = 0;\r\nu32 asle_req;\r\nif (!asle)\r\nreturn;\r\nasle_req = ioread32(&asle->aslc) & ASLE_REQ_MSK;\r\nif (!asle_req) {\r\nDRM_DEBUG_DRIVER("non asle set request??\n");\r\nreturn;\r\n}\r\nif (asle_req & ASLE_SET_ALS_ILLUM)\r\nasle_stat |= asle_set_als_illum(dev, ioread32(&asle->alsi));\r\nif (asle_req & ASLE_SET_BACKLIGHT)\r\nasle_stat |= asle_set_backlight(dev, ioread32(&asle->bclp));\r\nif (asle_req & ASLE_SET_PFIT)\r\nasle_stat |= asle_set_pfit(dev, ioread32(&asle->pfit));\r\nif (asle_req & ASLE_SET_PWM_FREQ)\r\nasle_stat |= asle_set_pwm_freq(dev, ioread32(&asle->pfmb));\r\niowrite32(asle_stat, &asle->aslc);\r\n}\r\nvoid intel_opregion_gse_intr(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct opregion_asle __iomem *asle = dev_priv->opregion.asle;\r\nu32 asle_stat = 0;\r\nu32 asle_req;\r\nif (!asle)\r\nreturn;\r\nasle_req = ioread32(&asle->aslc) & ASLE_REQ_MSK;\r\nif (!asle_req) {\r\nDRM_DEBUG_DRIVER("non asle set request??\n");\r\nreturn;\r\n}\r\nif (asle_req & ASLE_SET_ALS_ILLUM) {\r\nDRM_DEBUG_DRIVER("Illum is not supported\n");\r\nasle_stat |= ASLE_ALS_ILLUM_FAILED;\r\n}\r\nif (asle_req & ASLE_SET_BACKLIGHT)\r\nasle_stat |= asle_set_backlight(dev, ioread32(&asle->bclp));\r\nif (asle_req & ASLE_SET_PFIT) {\r\nDRM_DEBUG_DRIVER("Pfit is not supported\n");\r\nasle_stat |= ASLE_PFIT_FAILED;\r\n}\r\nif (asle_req & ASLE_SET_PWM_FREQ) {\r\nDRM_DEBUG_DRIVER("PWM freq is not supported\n");\r\nasle_stat |= ASLE_PWM_FREQ_FAILED;\r\n}\r\niowrite32(asle_stat, &asle->aslc);\r\n}\r\nvoid intel_opregion_enable_asle(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct opregion_asle __iomem *asle = dev_priv->opregion.asle;\r\nif (asle) {\r\nif (IS_MOBILE(dev))\r\nintel_enable_asle(dev);\r\niowrite32(ASLE_ALS_EN | ASLE_BLC_EN | ASLE_PFIT_EN |\r\nASLE_PFMB_EN,\r\n&asle->tche);\r\niowrite32(1, &asle->ardy);\r\n}\r\n}\r\nstatic int intel_opregion_video_event(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct opregion_acpi __iomem *acpi;\r\nstruct acpi_bus_event *event = data;\r\nint ret = NOTIFY_OK;\r\nif (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)\r\nreturn NOTIFY_DONE;\r\nif (!system_opregion)\r\nreturn NOTIFY_DONE;\r\nacpi = system_opregion->acpi;\r\nif (event->type == 0x80 &&\r\n(ioread32(&acpi->cevt) & 1) == 0)\r\nret = NOTIFY_BAD;\r\niowrite32(0, &acpi->csts);\r\nreturn ret;\r\n}\r\nstatic void intel_didl_outputs(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nstruct drm_connector *connector;\r\nacpi_handle handle;\r\nstruct acpi_device *acpi_dev, *acpi_cdev, *acpi_video_bus = NULL;\r\nunsigned long long device_id;\r\nacpi_status status;\r\nu32 temp;\r\nint i = 0;\r\nhandle = DEVICE_ACPI_HANDLE(&dev->pdev->dev);\r\nif (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev)))\r\nreturn;\r\nif (acpi_is_video_device(acpi_dev))\r\nacpi_video_bus = acpi_dev;\r\nelse {\r\nlist_for_each_entry(acpi_cdev, &acpi_dev->children, node) {\r\nif (acpi_is_video_device(acpi_cdev)) {\r\nacpi_video_bus = acpi_cdev;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!acpi_video_bus) {\r\npr_warn("No ACPI video bus found\n");\r\nreturn;\r\n}\r\nlist_for_each_entry(acpi_cdev, &acpi_video_bus->children, node) {\r\nif (i >= 8) {\r\ndev_printk(KERN_ERR, &dev->pdev->dev,\r\n"More than 8 outputs detected\n");\r\nreturn;\r\n}\r\nstatus =\r\nacpi_evaluate_integer(acpi_cdev->handle, "_ADR",\r\nNULL, &device_id);\r\nif (ACPI_SUCCESS(status)) {\r\nif (!device_id)\r\ngoto blind_set;\r\niowrite32((u32)(device_id & 0x0f0f),\r\n&opregion->acpi->didl[i]);\r\ni++;\r\n}\r\n}\r\nend:\r\nif (i < 8)\r\niowrite32(0, &opregion->acpi->didl[i]);\r\nreturn;\r\nblind_set:\r\ni = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nint output_type = ACPI_OTHER_OUTPUT;\r\nif (i >= 8) {\r\ndev_printk(KERN_ERR, &dev->pdev->dev,\r\n"More than 8 outputs detected\n");\r\nreturn;\r\n}\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\noutput_type = ACPI_VGA_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Component:\r\ncase DRM_MODE_CONNECTOR_9PinDIN:\r\noutput_type = ACPI_TV_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\noutput_type = ACPI_DIGITAL_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\noutput_type = ACPI_LVDS_OUTPUT;\r\nbreak;\r\n}\r\ntemp = ioread32(&opregion->acpi->didl[i]);\r\niowrite32(temp | (1<<31) | output_type | i,\r\n&opregion->acpi->didl[i]);\r\ni++;\r\n}\r\ngoto end;\r\n}\r\nvoid intel_opregion_init(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->acpi) {\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nintel_didl_outputs(dev);\r\niowrite32(0, &opregion->acpi->csts);\r\niowrite32(1, &opregion->acpi->drdy);\r\nsystem_opregion = opregion;\r\nregister_acpi_notifier(&intel_opregion_notifier);\r\n}\r\nif (opregion->asle)\r\nintel_opregion_enable_asle(dev);\r\n}\r\nvoid intel_opregion_fini(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->acpi) {\r\niowrite32(0, &opregion->acpi->drdy);\r\nsystem_opregion = NULL;\r\nunregister_acpi_notifier(&intel_opregion_notifier);\r\n}\r\niounmap(opregion->header);\r\nopregion->header = NULL;\r\nopregion->acpi = NULL;\r\nopregion->swsci = NULL;\r\nopregion->asle = NULL;\r\nopregion->vbt = NULL;\r\n}\r\nint intel_opregion_setup(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nvoid __iomem *base;\r\nu32 asls, mboxes;\r\nchar buf[sizeof(OPREGION_SIGNATURE)];\r\nint err = 0;\r\npci_read_config_dword(dev->pdev, PCI_ASLS, &asls);\r\nDRM_DEBUG_DRIVER("graphic opregion physical addr: 0x%x\n", asls);\r\nif (asls == 0) {\r\nDRM_DEBUG_DRIVER("ACPI OpRegion not supported!\n");\r\nreturn -ENOTSUPP;\r\n}\r\nbase = acpi_os_ioremap(asls, OPREGION_SIZE);\r\nif (!base)\r\nreturn -ENOMEM;\r\nmemcpy_fromio(buf, base, sizeof(buf));\r\nif (memcmp(buf, OPREGION_SIGNATURE, 16)) {\r\nDRM_DEBUG_DRIVER("opregion signature mismatch\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nopregion->header = base;\r\nopregion->vbt = base + OPREGION_VBT_OFFSET;\r\nopregion->lid_state = base + ACPI_CLID;\r\nmboxes = ioread32(&opregion->header->mboxes);\r\nif (mboxes & MBOX_ACPI) {\r\nDRM_DEBUG_DRIVER("Public ACPI methods supported\n");\r\nopregion->acpi = base + OPREGION_ACPI_OFFSET;\r\n}\r\nif (mboxes & MBOX_SWSCI) {\r\nDRM_DEBUG_DRIVER("SWSCI supported\n");\r\nopregion->swsci = base + OPREGION_SWSCI_OFFSET;\r\n}\r\nif (mboxes & MBOX_ASLE) {\r\nDRM_DEBUG_DRIVER("ASLE supported\n");\r\nopregion->asle = base + OPREGION_ASLE_OFFSET;\r\n}\r\nreturn 0;\r\nerr_out:\r\niounmap(base);\r\nreturn err;\r\n}
