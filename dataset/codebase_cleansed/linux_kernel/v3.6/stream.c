static void free_substream(struct snd_usb_substream *subs)\r\n{\r\nstruct list_head *p, *n;\r\nif (!subs->num_formats)\r\nreturn;\r\nlist_for_each_safe(p, n, &subs->fmt_list) {\r\nstruct audioformat *fp = list_entry(p, struct audioformat, list);\r\nkfree(fp->rate_table);\r\nkfree(fp);\r\n}\r\nkfree(subs->rate_list.list);\r\n}\r\nstatic void snd_usb_audio_stream_free(struct snd_usb_stream *stream)\r\n{\r\nfree_substream(&stream->substream[0]);\r\nfree_substream(&stream->substream[1]);\r\nlist_del(&stream->list);\r\nkfree(stream);\r\n}\r\nstatic void snd_usb_audio_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_usb_stream *stream = pcm->private_data;\r\nif (stream) {\r\nstream->pcm = NULL;\r\nsnd_usb_audio_stream_free(stream);\r\n}\r\n}\r\nstatic void snd_usb_init_substream(struct snd_usb_stream *as,\r\nint stream,\r\nstruct audioformat *fp)\r\n{\r\nstruct snd_usb_substream *subs = &as->substream[stream];\r\nINIT_LIST_HEAD(&subs->fmt_list);\r\nspin_lock_init(&subs->lock);\r\nsubs->stream = as;\r\nsubs->direction = stream;\r\nsubs->dev = as->chip->dev;\r\nsubs->txfr_quirk = as->chip->txfr_quirk;\r\nsnd_usb_set_pcm_ops(as->pcm, stream);\r\nlist_add_tail(&fp->list, &subs->fmt_list);\r\nsubs->formats |= fp->formats;\r\nsubs->num_formats++;\r\nsubs->fmt_type = fp->fmt_type;\r\nsubs->ep_num = fp->endpoint;\r\n}\r\nint snd_usb_add_audio_stream(struct snd_usb_audio *chip,\r\nint stream,\r\nstruct audioformat *fp)\r\n{\r\nstruct list_head *p;\r\nstruct snd_usb_stream *as;\r\nstruct snd_usb_substream *subs;\r\nstruct snd_pcm *pcm;\r\nint err;\r\nlist_for_each(p, &chip->pcm_list) {\r\nas = list_entry(p, struct snd_usb_stream, list);\r\nif (as->fmt_type != fp->fmt_type)\r\ncontinue;\r\nsubs = &as->substream[stream];\r\nif (subs->ep_num == fp->endpoint) {\r\nlist_add_tail(&fp->list, &subs->fmt_list);\r\nsubs->num_formats++;\r\nsubs->formats |= fp->formats;\r\nreturn 0;\r\n}\r\n}\r\nlist_for_each(p, &chip->pcm_list) {\r\nas = list_entry(p, struct snd_usb_stream, list);\r\nif (as->fmt_type != fp->fmt_type)\r\ncontinue;\r\nsubs = &as->substream[stream];\r\nif (subs->ep_num)\r\ncontinue;\r\nerr = snd_pcm_new_stream(as->pcm, stream, 1);\r\nif (err < 0)\r\nreturn err;\r\nsnd_usb_init_substream(as, stream, fp);\r\nreturn 0;\r\n}\r\nas = kzalloc(sizeof(*as), GFP_KERNEL);\r\nif (!as)\r\nreturn -ENOMEM;\r\nas->pcm_index = chip->pcm_devs;\r\nas->chip = chip;\r\nas->fmt_type = fp->fmt_type;\r\nerr = snd_pcm_new(chip->card, "USB Audio", chip->pcm_devs,\r\nstream == SNDRV_PCM_STREAM_PLAYBACK ? 1 : 0,\r\nstream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1,\r\n&pcm);\r\nif (err < 0) {\r\nkfree(as);\r\nreturn err;\r\n}\r\nas->pcm = pcm;\r\npcm->private_data = as;\r\npcm->private_free = snd_usb_audio_pcm_free;\r\npcm->info_flags = 0;\r\nif (chip->pcm_devs > 0)\r\nsprintf(pcm->name, "USB Audio #%d", chip->pcm_devs);\r\nelse\r\nstrcpy(pcm->name, "USB Audio");\r\nsnd_usb_init_substream(as, stream, fp);\r\nlist_add(&as->list, &chip->pcm_list);\r\nchip->pcm_devs++;\r\nsnd_usb_proc_pcm_format_add(as);\r\nreturn 0;\r\n}\r\nstatic int parse_uac_endpoint_attributes(struct snd_usb_audio *chip,\r\nstruct usb_host_interface *alts,\r\nint protocol, int iface_no)\r\n{\r\nstruct uac_iso_endpoint_descriptor *csep;\r\nstruct usb_interface_descriptor *altsd = get_iface_desc(alts);\r\nint attributes = 0;\r\ncsep = snd_usb_find_desc(alts->endpoint[0].extra, alts->endpoint[0].extralen, NULL, USB_DT_CS_ENDPOINT);\r\nif (!csep && altsd->bNumEndpoints >= 2)\r\ncsep = snd_usb_find_desc(alts->endpoint[1].extra, alts->endpoint[1].extralen, NULL, USB_DT_CS_ENDPOINT);\r\nif (!csep || csep->bLength < 7 ||\r\ncsep->bDescriptorSubtype != UAC_EP_GENERAL) {\r\nsnd_printk(KERN_WARNING "%d:%u:%d : no or invalid"\r\n" class specific endpoint descriptor\n",\r\nchip->dev->devnum, iface_no,\r\naltsd->bAlternateSetting);\r\nreturn 0;\r\n}\r\nif (protocol == UAC_VERSION_1) {\r\nattributes = csep->bmAttributes;\r\n} else {\r\nstruct uac2_iso_endpoint_descriptor *csep2 =\r\n(struct uac2_iso_endpoint_descriptor *) csep;\r\nattributes = csep->bmAttributes & UAC_EP_CS_ATTR_FILL_MAX;\r\nif (csep2->bmControls & UAC2_CONTROL_PITCH)\r\nattributes |= UAC_EP_CS_ATTR_PITCH_CONTROL;\r\n}\r\nreturn attributes;\r\n}\r\nstatic struct uac2_input_terminal_descriptor *\r\nsnd_usb_find_input_terminal_descriptor(struct usb_host_interface *ctrl_iface,\r\nint terminal_id)\r\n{\r\nstruct uac2_input_terminal_descriptor *term = NULL;\r\nwhile ((term = snd_usb_find_csint_desc(ctrl_iface->extra,\r\nctrl_iface->extralen,\r\nterm, UAC_INPUT_TERMINAL))) {\r\nif (term->bTerminalID == terminal_id)\r\nreturn term;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct uac2_output_terminal_descriptor *\r\nsnd_usb_find_output_terminal_descriptor(struct usb_host_interface *ctrl_iface,\r\nint terminal_id)\r\n{\r\nstruct uac2_output_terminal_descriptor *term = NULL;\r\nwhile ((term = snd_usb_find_csint_desc(ctrl_iface->extra,\r\nctrl_iface->extralen,\r\nterm, UAC_OUTPUT_TERMINAL))) {\r\nif (term->bTerminalID == terminal_id)\r\nreturn term;\r\n}\r\nreturn NULL;\r\n}\r\nint snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)\r\n{\r\nstruct usb_device *dev;\r\nstruct usb_interface *iface;\r\nstruct usb_host_interface *alts;\r\nstruct usb_interface_descriptor *altsd;\r\nint i, altno, err, stream;\r\nint format = 0, num_channels = 0;\r\nstruct audioformat *fp = NULL;\r\nint num, protocol, clock = 0;\r\nstruct uac_format_type_i_continuous_descriptor *fmt;\r\ndev = chip->dev;\r\niface = usb_ifnum_to_if(dev, iface_no);\r\nnum = iface->num_altsetting;\r\nif (chip->usb_id == USB_ID(0x04fa, 0x4201))\r\nnum = 4;\r\nfor (i = 0; i < num; i++) {\r\nalts = &iface->altsetting[i];\r\naltsd = get_iface_desc(alts);\r\nprotocol = altsd->bInterfaceProtocol;\r\nif ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&\r\naltsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\r\n(altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING &&\r\naltsd->bInterfaceSubClass != USB_SUBCLASS_VENDOR_SPEC) ||\r\naltsd->bNumEndpoints < 1 ||\r\nle16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) == 0)\r\ncontinue;\r\nif ((get_endpoint(alts, 0)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) !=\r\nUSB_ENDPOINT_XFER_ISOC)\r\ncontinue;\r\nstream = (get_endpoint(alts, 0)->bEndpointAddress & USB_DIR_IN) ?\r\nSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\r\naltno = altsd->bAlternateSetting;\r\nif (snd_usb_apply_interface_quirk(chip, iface_no, altno))\r\ncontinue;\r\nswitch (protocol) {\r\ndefault:\r\nsnd_printdd(KERN_WARNING "%d:%u:%d: unknown interface protocol %#02x, assuming v1\n",\r\ndev->devnum, iface_no, altno, protocol);\r\nprotocol = UAC_VERSION_1;\r\ncase UAC_VERSION_1: {\r\nstruct uac1_as_header_descriptor *as =\r\nsnd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_AS_GENERAL);\r\nif (!as) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : UAC_AS_GENERAL descriptor not found\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (as->bLength < sizeof(*as)) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid UAC_AS_GENERAL desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nformat = le16_to_cpu(as->wFormatTag);\r\nbreak;\r\n}\r\ncase UAC_VERSION_2: {\r\nstruct uac2_input_terminal_descriptor *input_term;\r\nstruct uac2_output_terminal_descriptor *output_term;\r\nstruct uac2_as_header_descriptor *as =\r\nsnd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_AS_GENERAL);\r\nif (!as) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : UAC_AS_GENERAL descriptor not found\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (as->bLength < sizeof(*as)) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid UAC_AS_GENERAL desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nnum_channels = as->bNrChannels;\r\nformat = le32_to_cpu(as->bmFormats);\r\ninput_term = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,\r\nas->bTerminalLink);\r\nif (input_term) {\r\nclock = input_term->bCSourceID;\r\nbreak;\r\n}\r\noutput_term = snd_usb_find_output_terminal_descriptor(chip->ctrl_intf,\r\nas->bTerminalLink);\r\nif (output_term) {\r\nclock = output_term->bCSourceID;\r\nbreak;\r\n}\r\nsnd_printk(KERN_ERR "%d:%u:%d : bogus bTerminalLink %d\n",\r\ndev->devnum, iface_no, altno, as->bTerminalLink);\r\ncontinue;\r\n}\r\n}\r\nfmt = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_FORMAT_TYPE);\r\nif (!fmt) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : no UAC_FORMAT_TYPE desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (((protocol == UAC_VERSION_1) && (fmt->bLength < 8)) ||\r\n((protocol == UAC_VERSION_2) && (fmt->bLength < 6))) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid UAC_FORMAT_TYPE desc\n",\r\ndev->devnum, iface_no, altno);\r\ncontinue;\r\n}\r\nif (fmt->bNrChannels == 1 &&\r\nfmt->bSubframeSize == 2 &&\r\naltno == 2 && num == 3 &&\r\nfp && fp->altsetting == 1 && fp->channels == 1 &&\r\nfp->formats == SNDRV_PCM_FMTBIT_S16_LE &&\r\nprotocol == UAC_VERSION_1 &&\r\nle16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize) ==\r\nfp->maxpacksize * 2)\r\ncontinue;\r\nfp = kzalloc(sizeof(*fp), GFP_KERNEL);\r\nif (! fp) {\r\nsnd_printk(KERN_ERR "cannot malloc\n");\r\nreturn -ENOMEM;\r\n}\r\nfp->iface = iface_no;\r\nfp->altsetting = altno;\r\nfp->altset_idx = i;\r\nfp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;\r\nfp->ep_attr = get_endpoint(alts, 0)->bmAttributes;\r\nfp->datainterval = snd_usb_parse_datainterval(chip, alts);\r\nfp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\r\nfp->channels = num_channels;\r\nif (snd_usb_get_speed(dev) == USB_SPEED_HIGH)\r\nfp->maxpacksize = (((fp->maxpacksize >> 11) & 3) + 1)\r\n* (fp->maxpacksize & 0x7ff);\r\nfp->attributes = parse_uac_endpoint_attributes(chip, alts, protocol, iface_no);\r\nfp->clock = clock;\r\nswitch (chip->usb_id) {\r\ncase USB_ID(0x0a92, 0x0053):\r\nfp->attributes &= ~UAC_EP_CS_ATTR_SAMPLE_RATE;\r\nbreak;\r\ncase USB_ID(0x041e, 0x3020):\r\ncase USB_ID(0x0763, 0x2003):\r\nfp->attributes |= UAC_EP_CS_ATTR_SAMPLE_RATE;\r\nbreak;\r\ncase USB_ID(0x0763, 0x2001):\r\ncase USB_ID(0x0763, 0x2012):\r\ncase USB_ID(0x047f, 0x0ca1):\r\ncase USB_ID(0x077d, 0x07af):\r\nfp->ep_attr &= ~USB_ENDPOINT_SYNCTYPE;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfp->ep_attr |= USB_ENDPOINT_SYNC_ADAPTIVE;\r\nelse\r\nfp->ep_attr |= USB_ENDPOINT_SYNC_SYNC;\r\nbreak;\r\n}\r\nif (snd_usb_parse_audio_format(chip, fp, format, fmt, stream, alts) < 0) {\r\nkfree(fp->rate_table);\r\nkfree(fp);\r\nfp = NULL;\r\ncontinue;\r\n}\r\nsnd_printdd(KERN_INFO "%d:%u:%d: add audio endpoint %#x\n", dev->devnum, iface_no, altno, fp->endpoint);\r\nerr = snd_usb_add_audio_stream(chip, stream, fp);\r\nif (err < 0) {\r\nkfree(fp->rate_table);\r\nkfree(fp);\r\nreturn err;\r\n}\r\nusb_set_interface(chip->dev, iface_no, altno);\r\nsnd_usb_init_pitch(chip, iface_no, alts, fp);\r\nsnd_usb_init_sample_rate(chip, iface_no, alts, fp, fp->rate_max);\r\n}\r\nreturn 0;\r\n}
