static u32\r\nread_div(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nswitch (dev_priv->chipset) {\r\ncase 0x50:\r\ncase 0x84:\r\ncase 0x86:\r\ncase 0x98:\r\ncase 0xa0:\r\nreturn nv_rd32(dev, 0x004700);\r\ncase 0x92:\r\ncase 0x94:\r\ncase 0x96:\r\nreturn nv_rd32(dev, 0x004800);\r\ndefault:\r\nreturn 0x00000000;\r\n}\r\n}\r\nstatic u32\r\nread_pll_src(struct drm_device *dev, u32 base)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 coef, ref = read_clk(dev, clk_src_crystal);\r\nu32 rsel = nv_rd32(dev, 0x00e18c);\r\nint P, N, M, id;\r\nswitch (dev_priv->chipset) {\r\ncase 0x50:\r\ncase 0xa0:\r\nswitch (base) {\r\ncase 0x4020:\r\ncase 0x4028: id = !!(rsel & 0x00000004); break;\r\ncase 0x4008: id = !!(rsel & 0x00000008); break;\r\ncase 0x4030: id = 0; break;\r\ndefault:\r\nNV_ERROR(dev, "ref: bad pll 0x%06x\n", base);\r\nreturn 0;\r\n}\r\ncoef = nv_rd32(dev, 0x00e81c + (id * 0x0c));\r\nref *= (coef & 0x01000000) ? 2 : 4;\r\nP = (coef & 0x00070000) >> 16;\r\nN = ((coef & 0x0000ff00) >> 8) + 1;\r\nM = ((coef & 0x000000ff) >> 0) + 1;\r\nbreak;\r\ncase 0x84:\r\ncase 0x86:\r\ncase 0x92:\r\ncoef = nv_rd32(dev, 0x00e81c);\r\nP = (coef & 0x00070000) >> 16;\r\nN = (coef & 0x0000ff00) >> 8;\r\nM = (coef & 0x000000ff) >> 0;\r\nbreak;\r\ncase 0x94:\r\ncase 0x96:\r\ncase 0x98:\r\nrsel = nv_rd32(dev, 0x00c050);\r\nswitch (base) {\r\ncase 0x4020: rsel = (rsel & 0x00000003) >> 0; break;\r\ncase 0x4008: rsel = (rsel & 0x0000000c) >> 2; break;\r\ncase 0x4028: rsel = (rsel & 0x00001800) >> 11; break;\r\ncase 0x4030: rsel = 3; break;\r\ndefault:\r\nNV_ERROR(dev, "ref: bad pll 0x%06x\n", base);\r\nreturn 0;\r\n}\r\nswitch (rsel) {\r\ncase 0: id = 1; break;\r\ncase 1: return read_clk(dev, clk_src_crystal);\r\ncase 2: return read_clk(dev, clk_src_href);\r\ncase 3: id = 0; break;\r\n}\r\ncoef = nv_rd32(dev, 0x00e81c + (id * 0x28));\r\nP = (nv_rd32(dev, 0x00e824 + (id * 0x28)) >> 16) & 7;\r\nP += (coef & 0x00070000) >> 16;\r\nN = (coef & 0x0000ff00) >> 8;\r\nM = (coef & 0x000000ff) >> 0;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nif (M)\r\nreturn (ref * N / M) >> P;\r\nreturn 0;\r\n}\r\nstatic u32\r\nread_pll_ref(struct drm_device *dev, u32 base)\r\n{\r\nu32 src, mast = nv_rd32(dev, 0x00c040);\r\nswitch (base) {\r\ncase 0x004028:\r\nsrc = !!(mast & 0x00200000);\r\nbreak;\r\ncase 0x004020:\r\nsrc = !!(mast & 0x00400000);\r\nbreak;\r\ncase 0x004008:\r\nsrc = !!(mast & 0x00010000);\r\nbreak;\r\ncase 0x004030:\r\nsrc = !!(mast & 0x02000000);\r\nbreak;\r\ncase 0x00e810:\r\nreturn read_clk(dev, clk_src_crystal);\r\ndefault:\r\nNV_ERROR(dev, "bad pll 0x%06x\n", base);\r\nreturn 0;\r\n}\r\nif (src)\r\nreturn read_clk(dev, clk_src_href);\r\nreturn read_pll_src(dev, base);\r\n}\r\nstatic u32\r\nread_pll(struct drm_device *dev, u32 base)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 mast = nv_rd32(dev, 0x00c040);\r\nu32 ctrl = nv_rd32(dev, base + 0);\r\nu32 coef = nv_rd32(dev, base + 4);\r\nu32 ref = read_pll_ref(dev, base);\r\nu32 clk = 0;\r\nint N1, N2, M1, M2;\r\nif (base == 0x004028 && (mast & 0x00100000)) {\r\nif (dev_priv->chipset != 0xa0)\r\nreturn read_clk(dev, clk_src_dom6);\r\n}\r\nN2 = (coef & 0xff000000) >> 24;\r\nM2 = (coef & 0x00ff0000) >> 16;\r\nN1 = (coef & 0x0000ff00) >> 8;\r\nM1 = (coef & 0x000000ff);\r\nif ((ctrl & 0x80000000) && M1) {\r\nclk = ref * N1 / M1;\r\nif ((ctrl & 0x40000100) == 0x40000000) {\r\nif (M2)\r\nclk = clk * N2 / M2;\r\nelse\r\nclk = 0;\r\n}\r\n}\r\nreturn clk;\r\n}\r\nstatic u32\r\nread_clk(struct drm_device *dev, enum clk_src src)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 mast = nv_rd32(dev, 0x00c040);\r\nu32 P = 0;\r\nswitch (src) {\r\ncase clk_src_crystal:\r\nreturn dev_priv->crystal;\r\ncase clk_src_href:\r\nreturn 100000;\r\ncase clk_src_hclk:\r\nreturn read_clk(dev, clk_src_href) * 27778 / 10000;\r\ncase clk_src_hclkm3:\r\nreturn read_clk(dev, clk_src_hclk) * 3;\r\ncase clk_src_hclkm3d2:\r\nreturn read_clk(dev, clk_src_hclk) * 3 / 2;\r\ncase clk_src_host:\r\nswitch (mast & 0x30000000) {\r\ncase 0x00000000: return read_clk(dev, clk_src_href);\r\ncase 0x10000000: break;\r\ncase 0x20000000:\r\ncase 0x30000000: return read_clk(dev, clk_src_hclk);\r\n}\r\nbreak;\r\ncase clk_src_nvclk:\r\nif (!(mast & 0x00100000))\r\nP = (nv_rd32(dev, 0x004028) & 0x00070000) >> 16;\r\nswitch (mast & 0x00000003) {\r\ncase 0x00000000: return read_clk(dev, clk_src_crystal) >> P;\r\ncase 0x00000001: return read_clk(dev, clk_src_dom6);\r\ncase 0x00000002: return read_pll(dev, 0x004020) >> P;\r\ncase 0x00000003: return read_pll(dev, 0x004028) >> P;\r\n}\r\nbreak;\r\ncase clk_src_sclk:\r\nP = (nv_rd32(dev, 0x004020) & 0x00070000) >> 16;\r\nswitch (mast & 0x00000030) {\r\ncase 0x00000000:\r\nif (mast & 0x00000080)\r\nreturn read_clk(dev, clk_src_host) >> P;\r\nreturn read_clk(dev, clk_src_crystal) >> P;\r\ncase 0x00000010: break;\r\ncase 0x00000020: return read_pll(dev, 0x004028) >> P;\r\ncase 0x00000030: return read_pll(dev, 0x004020) >> P;\r\n}\r\nbreak;\r\ncase clk_src_mclk:\r\nP = (nv_rd32(dev, 0x004008) & 0x00070000) >> 16;\r\nif (nv_rd32(dev, 0x004008) & 0x00000200) {\r\nswitch (mast & 0x0000c000) {\r\ncase 0x00000000:\r\nreturn read_clk(dev, clk_src_crystal) >> P;\r\ncase 0x00008000:\r\ncase 0x0000c000:\r\nreturn read_clk(dev, clk_src_href) >> P;\r\n}\r\n} else {\r\nreturn read_pll(dev, 0x004008) >> P;\r\n}\r\nbreak;\r\ncase clk_src_vdec:\r\nP = (read_div(dev) & 0x00000700) >> 8;\r\nswitch (dev_priv->chipset) {\r\ncase 0x84:\r\ncase 0x86:\r\ncase 0x92:\r\ncase 0x94:\r\ncase 0x96:\r\ncase 0xa0:\r\nswitch (mast & 0x00000c00) {\r\ncase 0x00000000:\r\nif (dev_priv->chipset == 0xa0)\r\nreturn read_clk(dev, clk_src_nvclk) >> P;\r\nreturn read_clk(dev, clk_src_crystal) >> P;\r\ncase 0x00000400:\r\nreturn 0;\r\ncase 0x00000800:\r\nif (mast & 0x01000000)\r\nreturn read_pll(dev, 0x004028) >> P;\r\nreturn read_pll(dev, 0x004030) >> P;\r\ncase 0x00000c00:\r\nreturn read_clk(dev, clk_src_nvclk) >> P;\r\n}\r\nbreak;\r\ncase 0x98:\r\nswitch (mast & 0x00000c00) {\r\ncase 0x00000000:\r\nreturn read_clk(dev, clk_src_nvclk) >> P;\r\ncase 0x00000400:\r\nreturn 0;\r\ncase 0x00000800:\r\nreturn read_clk(dev, clk_src_hclkm3d2) >> P;\r\ncase 0x00000c00:\r\nreturn read_clk(dev, clk_src_mclk) >> P;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase clk_src_dom6:\r\nswitch (dev_priv->chipset) {\r\ncase 0x50:\r\ncase 0xa0:\r\nreturn read_pll(dev, 0x00e810) >> 2;\r\ncase 0x84:\r\ncase 0x86:\r\ncase 0x92:\r\ncase 0x94:\r\ncase 0x96:\r\ncase 0x98:\r\nP = (read_div(dev) & 0x00000007) >> 0;\r\nswitch (mast & 0x0c000000) {\r\ncase 0x00000000: return read_clk(dev, clk_src_href);\r\ncase 0x04000000: break;\r\ncase 0x08000000: return read_clk(dev, clk_src_hclk);\r\ncase 0x0c000000:\r\nreturn read_clk(dev, clk_src_hclkm3) >> P;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nNV_DEBUG(dev, "unknown clock source %d 0x%08x\n", src, mast);\r\nreturn 0;\r\n}\r\nint\r\nnv50_pm_clocks_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->chipset == 0xaa ||\r\ndev_priv->chipset == 0xac)\r\nreturn 0;\r\nperflvl->core = read_clk(dev, clk_src_nvclk);\r\nperflvl->shader = read_clk(dev, clk_src_sclk);\r\nperflvl->memory = read_clk(dev, clk_src_mclk);\r\nif (dev_priv->chipset != 0x50) {\r\nperflvl->vdec = read_clk(dev, clk_src_vdec);\r\nperflvl->dom6 = read_clk(dev, clk_src_dom6);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32\r\ncalc_pll(struct drm_device *dev, u32 reg, struct pll_lims *pll,\r\nu32 clk, int *N1, int *M1, int *log2P)\r\n{\r\nstruct nouveau_pll_vals coef;\r\nint ret;\r\nret = get_pll_limits(dev, reg, pll);\r\nif (ret)\r\nreturn 0;\r\npll->vco2.maxfreq = 0;\r\npll->refclk = read_pll_ref(dev, reg);\r\nif (!pll->refclk)\r\nreturn 0;\r\nret = nouveau_calc_pll_mnp(dev, pll, clk, &coef);\r\nif (ret == 0)\r\nreturn 0;\r\n*N1 = coef.N1;\r\n*M1 = coef.M1;\r\n*log2P = coef.log2P;\r\nreturn ret;\r\n}\r\nstatic inline u32\r\ncalc_div(u32 src, u32 target, int *div)\r\n{\r\nu32 clk0 = src, clk1 = src;\r\nfor (*div = 0; *div <= 7; (*div)++) {\r\nif (clk0 <= target) {\r\nclk1 = clk0 << (*div ? 1 : 0);\r\nbreak;\r\n}\r\nclk0 >>= 1;\r\n}\r\nif (target - clk0 <= clk1 - target)\r\nreturn clk0;\r\n(*div)--;\r\nreturn clk1;\r\n}\r\nstatic inline u32\r\nclk_same(u32 a, u32 b)\r\n{\r\nreturn ((a / 1000) == (b / 1000));\r\n}\r\nstatic void\r\nmclk_precharge(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nhwsq_wr32(hwsq, 0x1002d4, 0x00000001);\r\n}\r\nstatic void\r\nmclk_refresh(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nhwsq_wr32(hwsq, 0x1002d0, 0x00000001);\r\n}\r\nstatic void\r\nmclk_refresh_auto(struct nouveau_mem_exec_func *exec, bool enable)\r\n{\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nhwsq_wr32(hwsq, 0x100210, enable ? 0x80000000 : 0x00000000);\r\n}\r\nstatic void\r\nmclk_refresh_self(struct nouveau_mem_exec_func *exec, bool enable)\r\n{\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nhwsq_wr32(hwsq, 0x1002dc, enable ? 0x00000001 : 0x00000000);\r\n}\r\nstatic void\r\nmclk_wait(struct nouveau_mem_exec_func *exec, u32 nsec)\r\n{\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nif (nsec > 1000)\r\nhwsq_usec(hwsq, (nsec + 500) / 1000);\r\n}\r\nstatic u32\r\nmclk_mrg(struct nouveau_mem_exec_func *exec, int mr)\r\n{\r\nif (mr <= 1)\r\nreturn nv_rd32(exec->dev, 0x1002c0 + ((mr - 0) * 4));\r\nif (mr <= 3)\r\nreturn nv_rd32(exec->dev, 0x1002e0 + ((mr - 2) * 4));\r\nreturn 0;\r\n}\r\nstatic void\r\nmclk_mrs(struct nouveau_mem_exec_func *exec, int mr, u32 data)\r\n{\r\nstruct drm_nouveau_private *dev_priv = exec->dev->dev_private;\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nif (mr <= 1) {\r\nif (dev_priv->vram_rank_B)\r\nhwsq_wr32(hwsq, 0x1002c8 + ((mr - 0) * 4), data);\r\nhwsq_wr32(hwsq, 0x1002c0 + ((mr - 0) * 4), data);\r\n} else\r\nif (mr <= 3) {\r\nif (dev_priv->vram_rank_B)\r\nhwsq_wr32(hwsq, 0x1002e8 + ((mr - 2) * 4), data);\r\nhwsq_wr32(hwsq, 0x1002e0 + ((mr - 2) * 4), data);\r\n}\r\n}\r\nstatic void\r\nmclk_clock_set(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nu32 ctrl = nv_rd32(exec->dev, 0x004008);\r\ninfo->mmast = nv_rd32(exec->dev, 0x00c040);\r\ninfo->mmast &= ~0xc0000000;\r\ninfo->mmast |= 0x0000c000;\r\nhwsq_wr32(hwsq, 0xc040, info->mmast);\r\nhwsq_wr32(hwsq, 0x4008, ctrl | 0x00000200);\r\nif (info->mctrl & 0x80000000)\r\nhwsq_wr32(hwsq, 0x400c, info->mcoef);\r\nhwsq_wr32(hwsq, 0x4008, info->mctrl);\r\n}\r\nstatic void\r\nmclk_timing_set(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct drm_device *dev = exec->dev;\r\nstruct nv50_pm_state *info = exec->priv;\r\nstruct nouveau_pm_level *perflvl = info->perflvl;\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nint i;\r\nfor (i = 0; i < 9; i++) {\r\nu32 reg = 0x100220 + (i * 4);\r\nu32 val = nv_rd32(dev, reg);\r\nif (val != perflvl->timing.reg[i])\r\nhwsq_wr32(hwsq, reg, perflvl->timing.reg[i]);\r\n}\r\n}\r\nstatic int\r\ncalc_mclk(struct drm_device *dev, struct nouveau_pm_level *perflvl,\r\nstruct nv50_pm_state *info)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 crtc_mask = nv50_display_active_crtcs(dev);\r\nstruct nouveau_mem_exec_func exec = {\r\n.dev = dev,\r\n.precharge = mclk_precharge,\r\n.refresh = mclk_refresh,\r\n.refresh_auto = mclk_refresh_auto,\r\n.refresh_self = mclk_refresh_self,\r\n.wait = mclk_wait,\r\n.mrg = mclk_mrg,\r\n.mrs = mclk_mrs,\r\n.clock_set = mclk_clock_set,\r\n.timing_set = mclk_timing_set,\r\n.priv = info\r\n};\r\nstruct hwsq_ucode *hwsq = &info->mclk_hwsq;\r\nstruct pll_lims pll;\r\nint N, M, P;\r\nint ret;\r\ninfo->mctrl = nv_rd32(dev, 0x004008);\r\ninfo->mctrl &= ~0x81ff0200;\r\nif (clk_same(perflvl->memory, read_clk(dev, clk_src_href))) {\r\ninfo->mctrl |= 0x00000200 | (pll.log2p_bias << 19);\r\n} else {\r\nret = calc_pll(dev, 0x4008, &pll, perflvl->memory, &N, &M, &P);\r\nif (ret == 0)\r\nreturn -EINVAL;\r\ninfo->mctrl |= 0x80000000 | (P << 22) | (P << 16);\r\ninfo->mctrl |= pll.log2p_bias << 19;\r\ninfo->mcoef = (N << 8) | M;\r\n}\r\nhwsq_init(hwsq);\r\nif (crtc_mask) {\r\nhwsq_op5f(hwsq, crtc_mask, 0x00);\r\nhwsq_op5f(hwsq, crtc_mask, 0x01);\r\n}\r\nif (dev_priv->chipset >= 0x92)\r\nhwsq_wr32(hwsq, 0x611200, 0x00003300);\r\nhwsq_setf(hwsq, 0x10, 0);\r\nhwsq_op5f(hwsq, 0x00, 0x01);\r\nret = nouveau_mem_exec(&exec, perflvl);\r\nif (ret)\r\nreturn ret;\r\nhwsq_setf(hwsq, 0x10, 1);\r\nhwsq_op5f(hwsq, 0x00, 0x00);\r\nif (dev_priv->chipset >= 0x92)\r\nhwsq_wr32(hwsq, 0x611200, 0x00003330);\r\nhwsq_fini(hwsq);\r\nreturn 0;\r\n}\r\nvoid *\r\nnv50_pm_clocks_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_pm_state *info;\r\nstruct hwsq_ucode *hwsq;\r\nstruct pll_lims pll;\r\nu32 out, mast, divs, ctrl;\r\nint clk, ret = -EINVAL;\r\nint N, M, P1, P2;\r\nif (dev_priv->chipset == 0xaa ||\r\ndev_priv->chipset == 0xac)\r\nreturn ERR_PTR(-ENODEV);\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\ninfo->perflvl = perflvl;\r\ninfo->mclk_hwsq.len = 0;\r\nif (perflvl->memory) {\r\nret = calc_mclk(dev, perflvl, info);\r\nif (ret)\r\ngoto error;\r\ninfo->mscript = perflvl->memscript;\r\n}\r\ndivs = read_div(dev);\r\nmast = info->mmast;\r\nhwsq = &info->eclk_hwsq;\r\nhwsq_init(hwsq);\r\nhwsq_setf(hwsq, 0x10, 0);\r\nhwsq_op5f(hwsq, 0x00, 0x01);\r\nif (perflvl->vdec) {\r\nmast &= ~0x00000c00;\r\ndivs &= ~0x00000700;\r\n}\r\nif (perflvl->dom6) {\r\nmast &= ~0x0c000000;\r\ndivs &= ~0x00000007;\r\n}\r\nhwsq_wr32(hwsq, 0x00c040, mast);\r\nif (perflvl->vdec) {\r\nclk = calc_div(perflvl->core, perflvl->vdec, &P1);\r\nif (dev_priv->chipset != 0x98)\r\nout = read_pll(dev, 0x004030);\r\nelse\r\nout = read_clk(dev, clk_src_hclkm3d2);\r\nout = calc_div(out, perflvl->vdec, &P2);\r\nif (abs((int)perflvl->vdec - clk) <=\r\nabs((int)perflvl->vdec - out)) {\r\nif (dev_priv->chipset != 0x98)\r\nmast |= 0x00000c00;\r\ndivs |= P1 << 8;\r\n} else {\r\nmast |= 0x00000800;\r\ndivs |= P2 << 8;\r\n}\r\n}\r\nif (perflvl->dom6) {\r\nif (clk_same(perflvl->dom6, read_clk(dev, clk_src_href))) {\r\nmast |= 0x00000000;\r\n} else\r\nif (clk_same(perflvl->dom6, read_clk(dev, clk_src_hclk))) {\r\nmast |= 0x08000000;\r\n} else {\r\nclk = read_clk(dev, clk_src_hclk) * 3;\r\nclk = calc_div(clk, perflvl->dom6, &P1);\r\nmast |= 0x0c000000;\r\ndivs |= P1;\r\n}\r\n}\r\nswitch (dev_priv->chipset) {\r\ncase 0x92:\r\ncase 0x94:\r\ncase 0x96:\r\nhwsq_wr32(hwsq, 0x004800, divs);\r\nbreak;\r\ndefault:\r\nhwsq_wr32(hwsq, 0x004700, divs);\r\nbreak;\r\n}\r\nhwsq_wr32(hwsq, 0x00c040, mast);\r\nif (dev_priv->chipset < 0x92)\r\nmast = (mast & ~0x001000b0) | 0x00100080;\r\nelse\r\nmast = (mast & ~0x000000b3) | 0x00000081;\r\nhwsq_wr32(hwsq, 0x00c040, mast);\r\nclk = calc_pll(dev, 0x4028, &pll, perflvl->core, &N, &M, &P1);\r\nif (clk == 0)\r\ngoto error;\r\nctrl = nv_rd32(dev, 0x004028) & ~0xc03f0100;\r\nmast &= ~0x00100000;\r\nmast |= 3;\r\nhwsq_wr32(hwsq, 0x004028, 0x80000000 | (P1 << 19) | (P1 << 16) | ctrl);\r\nhwsq_wr32(hwsq, 0x00402c, (N << 8) | M);\r\nctrl = nv_rd32(dev, 0x004020) & ~0xc03f0100;\r\nif (P1-- && perflvl->shader == (perflvl->core << 1)) {\r\nhwsq_wr32(hwsq, 0x004020, (P1 << 19) | (P1 << 16) | ctrl);\r\nhwsq_wr32(hwsq, 0x00c040, 0x00000020 | mast);\r\n} else {\r\nclk = calc_pll(dev, 0x4020, &pll, perflvl->shader, &N, &M, &P1);\r\nif (clk == 0)\r\ngoto error;\r\nctrl |= 0x80000000;\r\nhwsq_wr32(hwsq, 0x004020, (P1 << 19) | (P1 << 16) | ctrl);\r\nhwsq_wr32(hwsq, 0x004024, (N << 8) | M);\r\nhwsq_wr32(hwsq, 0x00c040, 0x00000030 | mast);\r\n}\r\nhwsq_setf(hwsq, 0x10, 1);\r\nhwsq_op5f(hwsq, 0x00, 0x00);\r\nhwsq_fini(hwsq);\r\nreturn info;\r\nerror:\r\nkfree(info);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int\r\nprog_hwsq(struct drm_device *dev, struct hwsq_ucode *hwsq)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 hwsq_data, hwsq_kick;\r\nint i;\r\nif (dev_priv->chipset < 0x94) {\r\nhwsq_data = 0x001400;\r\nhwsq_kick = 0x00000003;\r\n} else {\r\nhwsq_data = 0x080000;\r\nhwsq_kick = 0x00000001;\r\n}\r\nnv_mask(dev, 0x001098, 0x00000008, 0x00000000);\r\nnv_wr32(dev, 0x001304, 0x00000000);\r\nif (dev_priv->chipset >= 0x92)\r\nnv_wr32(dev, 0x001318, 0x00000000);\r\nfor (i = 0; i < hwsq->len / 4; i++)\r\nnv_wr32(dev, hwsq_data + (i * 4), hwsq->ptr.u32[i]);\r\nnv_mask(dev, 0x001098, 0x00000018, 0x00000018);\r\nnv_wr32(dev, 0x00130c, hwsq_kick);\r\nif (!nv_wait(dev, 0x001308, 0x00000100, 0x00000000)) {\r\nNV_ERROR(dev, "hwsq ucode exec timed out\n");\r\nNV_ERROR(dev, "0x001308: 0x%08x\n", nv_rd32(dev, 0x001308));\r\nfor (i = 0; i < hwsq->len / 4; i++) {\r\nNV_ERROR(dev, "0x%06x: 0x%08x\n", 0x1400 + (i * 4),\r\nnv_rd32(dev, 0x001400 + (i * 4)));\r\n}\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv50_pm_clocks_set(struct drm_device *dev, void *data)\r\n{\r\nstruct nv50_pm_state *info = data;\r\nstruct bit_entry M;\r\nint ret = -EBUSY;\r\nnv_mask(dev, 0x002504, 0x00000001, 0x00000001);\r\nif (!nv_wait(dev, 0x002504, 0x00000010, 0x00000010))\r\ngoto resume;\r\nif (!nv_wait(dev, 0x00251c, 0x0000003f, 0x0000003f))\r\ngoto resume;\r\nif (info->mclk_hwsq.len) {\r\nif (!bit_table(dev, 'M', &M) && M.version == 1) {\r\nif (M.length >= 6)\r\nnouveau_bios_init_exec(dev, ROM16(M.data[5]));\r\nif (M.length >= 8)\r\nnouveau_bios_init_exec(dev, ROM16(M.data[7]));\r\nif (M.length >= 10)\r\nnouveau_bios_init_exec(dev, ROM16(M.data[9]));\r\nnouveau_bios_init_exec(dev, info->mscript);\r\n}\r\nret = prog_hwsq(dev, &info->mclk_hwsq);\r\nif (ret)\r\ngoto resume;\r\n}\r\nret = prog_hwsq(dev, &info->eclk_hwsq);\r\nresume:\r\nnv_mask(dev, 0x002504, 0x00000001, 0x00000000);\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int\r\npwm_info(struct drm_device *dev, int *line, int *ctrl, int *indx)\r\n{\r\nif (*line == 0x04) {\r\n*ctrl = 0x00e100;\r\n*line = 4;\r\n*indx = 0;\r\n} else\r\nif (*line == 0x09) {\r\n*ctrl = 0x00e100;\r\n*line = 9;\r\n*indx = 1;\r\n} else\r\nif (*line == 0x10) {\r\n*ctrl = 0x00e28c;\r\n*line = 0;\r\n*indx = 0;\r\n} else {\r\nNV_ERROR(dev, "unknown pwm ctrl for gpio %d\n", *line);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv50_pm_pwm_get(struct drm_device *dev, int line, u32 *divs, u32 *duty)\r\n{\r\nint ctrl, id, ret = pwm_info(dev, &line, &ctrl, &id);\r\nif (ret)\r\nreturn ret;\r\nif (nv_rd32(dev, ctrl) & (1 << line)) {\r\n*divs = nv_rd32(dev, 0x00e114 + (id * 8));\r\n*duty = nv_rd32(dev, 0x00e118 + (id * 8));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint\r\nnv50_pm_pwm_set(struct drm_device *dev, int line, u32 divs, u32 duty)\r\n{\r\nint ctrl, id, ret = pwm_info(dev, &line, &ctrl, &id);\r\nif (ret)\r\nreturn ret;\r\nnv_mask(dev, ctrl, 0x00010001 << line, 0x00000001 << line);\r\nnv_wr32(dev, 0x00e114 + (id * 8), divs);\r\nnv_wr32(dev, 0x00e118 + (id * 8), duty | 0x80000000);\r\nreturn 0;\r\n}
