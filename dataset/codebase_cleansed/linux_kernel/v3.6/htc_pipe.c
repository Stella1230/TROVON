static inline void restore_tx_packet(struct htc_packet *packet)\r\n{\r\nif (packet->info.tx.flags & HTC_FLAGS_TX_FIXUP_NETBUF) {\r\nskb_pull(packet->skb, sizeof(struct htc_frame_hdr));\r\npacket->info.tx.flags &= ~HTC_FLAGS_TX_FIXUP_NETBUF;\r\n}\r\n}\r\nstatic void do_send_completion(struct htc_endpoint *ep,\r\nstruct list_head *queue_to_indicate)\r\n{\r\nstruct htc_packet *packet;\r\nif (list_empty(queue_to_indicate)) {\r\nreturn;\r\n}\r\nif (ep->ep_cb.tx_comp_multi != NULL) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: calling ep %d, send complete multiple callback (%d pkts)\n",\r\n__func__, ep->eid,\r\nget_queue_depth(queue_to_indicate));\r\nep->ep_cb.tx_comp_multi(ep->target, queue_to_indicate);\r\nINIT_LIST_HEAD(queue_to_indicate);\r\n} else {\r\ndo {\r\npacket = list_first_entry(queue_to_indicate,\r\nstruct htc_packet, list);\r\nlist_del(&packet->list);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: calling ep %d send complete callback on packet 0x%p\n",\r\n__func__, ep->eid, packet);\r\nep->ep_cb.tx_complete(ep->target, packet);\r\n} while (!list_empty(queue_to_indicate));\r\n}\r\n}\r\nstatic void send_packet_completion(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nstruct htc_endpoint *ep = &target->endpoint[packet->endpoint];\r\nstruct list_head container;\r\nrestore_tx_packet(packet);\r\nINIT_LIST_HEAD(&container);\r\nlist_add_tail(&packet->list, &container);\r\ndo_send_completion(ep, &container);\r\n}\r\nstatic void get_htc_packet_credit_based(struct htc_target *target,\r\nstruct htc_endpoint *ep,\r\nstruct list_head *queue)\r\n{\r\nint credits_required;\r\nint remainder;\r\nu8 send_flags;\r\nstruct htc_packet *packet;\r\nunsigned int transfer_len;\r\nwhile (true) {\r\nsend_flags = 0;\r\nif (list_empty(&ep->txq))\r\nbreak;\r\npacket = list_first_entry(&ep->txq, struct htc_packet, list);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: got head packet:0x%p , queue depth: %d\n",\r\n__func__, packet, get_queue_depth(&ep->txq));\r\ntransfer_len = packet->act_len + HTC_HDR_LENGTH;\r\nif (transfer_len <= target->tgt_cred_sz) {\r\ncredits_required = 1;\r\n} else {\r\ncredits_required = transfer_len / target->tgt_cred_sz;\r\nremainder = transfer_len % target->tgt_cred_sz;\r\nif (remainder)\r\ncredits_required++;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_HTC, "%s: creds required:%d got:%d\n",\r\n__func__, credits_required, ep->cred_dist.credits);\r\nif (ep->eid == ENDPOINT_0) {\r\ncredits_required = 0;\r\n} else {\r\nif (ep->cred_dist.credits < credits_required)\r\nbreak;\r\nep->cred_dist.credits -= credits_required;\r\nep->ep_st.cred_cosumd += credits_required;\r\nif (ep->cred_dist.credits <\r\nep->cred_dist.cred_per_msg) {\r\nsend_flags |= HTC_FLAGS_NEED_CREDIT_UPDATE;\r\nep->ep_st.cred_low_indicate += 1;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: host needs credits\n",\r\n__func__);\r\n}\r\n}\r\npacket = list_first_entry(&ep->txq, struct htc_packet, list);\r\nlist_del(&packet->list);\r\npacket->info.tx.cred_used = credits_required;\r\npacket->info.tx.flags = send_flags;\r\npacket->info.tx.seqno = ep->seqno;\r\nep->seqno++;\r\nlist_add_tail(&packet->list, queue);\r\n}\r\n}\r\nstatic void get_htc_packet(struct htc_target *target,\r\nstruct htc_endpoint *ep,\r\nstruct list_head *queue, int resources)\r\n{\r\nstruct htc_packet *packet;\r\nwhile (resources) {\r\nif (list_empty(&ep->txq))\r\nbreak;\r\npacket = list_first_entry(&ep->txq, struct htc_packet, list);\r\nlist_del(&packet->list);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: got packet:0x%p , new queue depth: %d\n",\r\n__func__, packet, get_queue_depth(&ep->txq));\r\npacket->info.tx.seqno = ep->seqno;\r\npacket->info.tx.flags = 0;\r\npacket->info.tx.cred_used = 0;\r\nep->seqno++;\r\nlist_add_tail(&packet->list, queue);\r\nresources--;\r\n}\r\n}\r\nstatic int htc_issue_packets(struct htc_target *target,\r\nstruct htc_endpoint *ep,\r\nstruct list_head *pkt_queue)\r\n{\r\nint status = 0;\r\nu16 payload_len;\r\nstruct sk_buff *skb;\r\nstruct htc_frame_hdr *htc_hdr;\r\nstruct htc_packet *packet;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: queue: 0x%p, pkts %d\n", __func__,\r\npkt_queue, get_queue_depth(pkt_queue));\r\nwhile (!list_empty(pkt_queue)) {\r\npacket = list_first_entry(pkt_queue, struct htc_packet, list);\r\nlist_del(&packet->list);\r\nskb = packet->skb;\r\nif (!skb) {\r\nWARN_ON_ONCE(1);\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\npayload_len = packet->act_len;\r\nhtc_hdr = (struct htc_frame_hdr *) skb_push(skb,\r\nsizeof(*htc_hdr));\r\nif (!htc_hdr) {\r\nWARN_ON_ONCE(1);\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\npacket->info.tx.flags |= HTC_FLAGS_TX_FIXUP_NETBUF;\r\nput_unaligned((u16) payload_len, &htc_hdr->payld_len);\r\nhtc_hdr->flags = packet->info.tx.flags;\r\nhtc_hdr->eid = (u8) packet->endpoint;\r\nhtc_hdr->ctrl[0] = 0;\r\nhtc_hdr->ctrl[1] = (u8) packet->info.tx.seqno;\r\nspin_lock_bh(&target->tx_lock);\r\nlist_add_tail(&packet->list, &ep->pipe.tx_lookup_queue);\r\nep->ep_st.tx_issued += 1;\r\nspin_unlock_bh(&target->tx_lock);\r\nstatus = ath6kl_hif_pipe_send(target->dev->ar,\r\nep->pipe.pipeid_ul, NULL, skb);\r\nif (status != 0) {\r\nif (status != -ENOMEM) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: failed status:%d\n",\r\n__func__, status);\r\n}\r\nspin_lock_bh(&target->tx_lock);\r\nlist_del(&packet->list);\r\nep->cred_dist.credits += packet->info.tx.cred_used;\r\nspin_unlock_bh(&target->tx_lock);\r\nlist_add(&packet->list, pkt_queue);\r\nbreak;\r\n}\r\n}\r\nif (status != 0) {\r\nwhile (!list_empty(pkt_queue)) {\r\nif (status != -ENOMEM) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: failed pkt:0x%p status:%d\n",\r\n__func__, packet, status);\r\n}\r\npacket = list_first_entry(pkt_queue,\r\nstruct htc_packet, list);\r\nlist_del(&packet->list);\r\npacket->status = status;\r\nsend_packet_completion(target, packet);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic enum htc_send_queue_result htc_try_send(struct htc_target *target,\r\nstruct htc_endpoint *ep,\r\nstruct list_head *txq)\r\n{\r\nstruct list_head send_queue;\r\nstruct htc_packet *packet, *tmp_pkt;\r\nstruct ath6kl *ar = target->dev->ar;\r\nenum htc_send_full_action action;\r\nint tx_resources, overflow, txqueue_depth, i, good_pkts;\r\nu8 pipeid;\r\nath6kl_dbg(ATH6KL_DBG_HTC, "%s: (queue:0x%p depth:%d)\n",\r\n__func__, txq,\r\n(txq == NULL) ? 0 : get_queue_depth(txq));\r\nINIT_LIST_HEAD(&send_queue);\r\nif (txq != NULL) {\r\nif (list_empty(txq)) {\r\nreturn HTC_SEND_QUEUE_DROP;\r\n}\r\nspin_lock_bh(&target->tx_lock);\r\ntxqueue_depth = get_queue_depth(&ep->txq);\r\nspin_unlock_bh(&target->tx_lock);\r\nif (txqueue_depth >= ep->max_txq_depth) {\r\noverflow = get_queue_depth(txq);\r\n} else {\r\noverflow = txqueue_depth;\r\noverflow += get_queue_depth(txq);\r\noverflow -= ep->max_txq_depth;\r\n}\r\nif (overflow > 0) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: Endpoint %d, TX queue will overflow :%d, Tx Depth:%d, Max:%d\n",\r\n__func__, ep->eid, overflow, txqueue_depth,\r\nep->max_txq_depth);\r\n}\r\nif ((overflow <= 0) ||\r\n(ep->ep_cb.tx_full == NULL)) {\r\nlist_splice_tail_init(txq, &send_queue);\r\n} else {\r\ngood_pkts = get_queue_depth(txq) - overflow;\r\nif (good_pkts < 0) {\r\nWARN_ON_ONCE(1);\r\nreturn HTC_SEND_QUEUE_DROP;\r\n}\r\nfor (i = 0; i < good_pkts; i++) {\r\npacket = list_first_entry(txq,\r\nstruct htc_packet,\r\nlist);\r\nlist_del(&packet->list);\r\nlist_add_tail(&packet->list, &send_queue);\r\n}\r\nlist_for_each_entry_safe(packet, tmp_pkt,\r\ntxq, list) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: Indicat overflowed TX pkts: %p\n",\r\n__func__, packet);\r\naction = ep->ep_cb.tx_full(ep->target, packet);\r\nif (action == HTC_SEND_FULL_DROP) {\r\nep->ep_st.tx_dropped += 1;\r\n} else {\r\nlist_del(&packet->list);\r\nlist_add_tail(&packet->list,\r\n&send_queue);\r\n}\r\n}\r\nif (list_empty(&send_queue)) {\r\nreturn HTC_SEND_QUEUE_DROP;\r\n}\r\n}\r\n}\r\nif (!ep->pipe.tx_credit_flow_enabled) {\r\ntx_resources =\r\nath6kl_hif_pipe_get_free_queue_number(ar,\r\nep->pipe.pipeid_ul);\r\n} else {\r\ntx_resources = 0;\r\n}\r\nspin_lock_bh(&target->tx_lock);\r\nif (!list_empty(&send_queue)) {\r\nlist_splice_tail_init(&send_queue, &ep->txq);\r\nif (!list_empty(&send_queue)) {\r\nWARN_ON_ONCE(1);\r\nspin_unlock_bh(&target->tx_lock);\r\nreturn HTC_SEND_QUEUE_DROP;\r\n}\r\nINIT_LIST_HEAD(&send_queue);\r\n}\r\nep->tx_proc_cnt++;\r\nif (ep->tx_proc_cnt > 1) {\r\nep->tx_proc_cnt--;\r\nspin_unlock_bh(&target->tx_lock);\r\nreturn HTC_SEND_QUEUE_OK;\r\n}\r\nwhile (true) {\r\nif (get_queue_depth(&ep->txq) == 0)\r\nbreak;\r\nif (ep->pipe.tx_credit_flow_enabled) {\r\nget_htc_packet_credit_based(target, ep, &send_queue);\r\n} else {\r\nget_htc_packet(target, ep, &send_queue, tx_resources);\r\n}\r\nif (get_queue_depth(&send_queue) == 0) {\r\nbreak;\r\n}\r\nspin_unlock_bh(&target->tx_lock);\r\nhtc_issue_packets(target, ep, &send_queue);\r\nif (!ep->pipe.tx_credit_flow_enabled) {\r\npipeid = ep->pipe.pipeid_ul;\r\ntx_resources =\r\nath6kl_hif_pipe_get_free_queue_number(ar, pipeid);\r\n}\r\nspin_lock_bh(&target->tx_lock);\r\n}\r\nep->tx_proc_cnt = 0;\r\nspin_unlock_bh(&target->tx_lock);\r\nreturn HTC_SEND_QUEUE_OK;\r\n}\r\nstatic void destroy_htc_txctrl_packet(struct htc_packet *packet)\r\n{\r\nstruct sk_buff *skb;\r\nskb = packet->skb;\r\nif (skb != NULL)\r\ndev_kfree_skb(skb);\r\nkfree(packet);\r\n}\r\nstatic struct htc_packet *build_htc_txctrl_packet(void)\r\n{\r\nstruct htc_packet *packet = NULL;\r\nstruct sk_buff *skb;\r\npacket = kzalloc(sizeof(struct htc_packet), GFP_KERNEL);\r\nif (packet == NULL)\r\nreturn NULL;\r\nskb = __dev_alloc_skb(HTC_CONTROL_BUFFER_SIZE, GFP_KERNEL);\r\nif (skb == NULL) {\r\nkfree(packet);\r\nreturn NULL;\r\n}\r\npacket->skb = skb;\r\nreturn packet;\r\n}\r\nstatic void htc_free_txctrl_packet(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\ndestroy_htc_txctrl_packet(packet);\r\n}\r\nstatic struct htc_packet *htc_alloc_txctrl_packet(struct htc_target *target)\r\n{\r\nreturn build_htc_txctrl_packet();\r\n}\r\nstatic void htc_txctrl_complete(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nhtc_free_txctrl_packet(target, packet);\r\n}\r\nstatic int htc_setup_target_buffer_assignments(struct htc_target *target)\r\n{\r\nint status, credits, credit_per_maxmsg, i;\r\nstruct htc_pipe_txcredit_alloc *entry;\r\nunsigned int hif_usbaudioclass = 0;\r\ncredit_per_maxmsg = MAX_MESSAGE_SIZE / target->tgt_cred_sz;\r\nif (MAX_MESSAGE_SIZE % target->tgt_cred_sz)\r\ncredit_per_maxmsg++;\r\ncredits = target->tgt_creds;\r\nentry = &target->pipe.txcredit_alloc[0];\r\nstatus = -ENOMEM;\r\nif (hif_usbaudioclass) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: For USB Audio Class- Total:%d\n",\r\n__func__, credits);\r\nentry++;\r\nentry++;\r\nentry->service_id = WMI_DATA_VO_SVC;\r\nentry->credit_alloc = (credits - 6);\r\nif (entry->credit_alloc == 0)\r\nentry->credit_alloc++;\r\ncredits -= (int) entry->credit_alloc;\r\nif (credits <= 0)\r\nreturn status;\r\nentry++;\r\nentry->service_id = WMI_CONTROL_SVC;\r\nentry->credit_alloc = credit_per_maxmsg;\r\ncredits -= (int) entry->credit_alloc;\r\nif (credits <= 0)\r\nreturn status;\r\nentry++;\r\nentry++;\r\nentry->service_id = WMI_DATA_BE_SVC;\r\nentry->credit_alloc = (u8) credits;\r\nstatus = 0;\r\n} else {\r\nentry++;\r\nentry->service_id = WMI_DATA_VI_SVC;\r\nentry->credit_alloc = credits / 4;\r\nif (entry->credit_alloc == 0)\r\nentry->credit_alloc++;\r\ncredits -= (int) entry->credit_alloc;\r\nif (credits <= 0)\r\nreturn status;\r\nentry++;\r\nentry->service_id = WMI_DATA_VO_SVC;\r\nentry->credit_alloc = credits / 4;\r\nif (entry->credit_alloc == 0)\r\nentry->credit_alloc++;\r\ncredits -= (int) entry->credit_alloc;\r\nif (credits <= 0)\r\nreturn status;\r\nentry++;\r\nentry->service_id = WMI_CONTROL_SVC;\r\nentry->credit_alloc = credit_per_maxmsg;\r\ncredits -= (int) entry->credit_alloc;\r\nif (credits <= 0)\r\nreturn status;\r\nentry++;\r\nentry->service_id = WMI_DATA_BK_SVC;\r\nentry->credit_alloc = credit_per_maxmsg;\r\ncredits -= (int) entry->credit_alloc;\r\nif (credits <= 0)\r\nreturn status;\r\nentry++;\r\nentry->service_id = WMI_DATA_BE_SVC;\r\nentry->credit_alloc = (u8) credits;\r\nstatus = 0;\r\n}\r\nif (status == 0) {\r\nfor (i = 0; i < ENDPOINT_MAX; i++) {\r\nif (target->pipe.txcredit_alloc[i].service_id != 0) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"HTC Service Index : %d TX : 0x%2.2X : alloc:%d\n",\r\ni,\r\ntarget->pipe.txcredit_alloc[i].\r\nservice_id,\r\ntarget->pipe.txcredit_alloc[i].\r\ncredit_alloc);\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void htc_process_credit_report(struct htc_target *target,\r\nstruct htc_credit_report *rpt,\r\nint num_entries,\r\nenum htc_endpoint_id from_ep)\r\n{\r\nint total_credits = 0, i;\r\nstruct htc_endpoint *ep;\r\nspin_lock_bh(&target->tx_lock);\r\nfor (i = 0; i < num_entries; i++, rpt++) {\r\nif (rpt->eid >= ENDPOINT_MAX) {\r\nWARN_ON_ONCE(1);\r\nspin_unlock_bh(&target->tx_lock);\r\nreturn;\r\n}\r\nep = &target->endpoint[rpt->eid];\r\nep->cred_dist.credits += rpt->credits;\r\nif (ep->cred_dist.credits && get_queue_depth(&ep->txq)) {\r\nspin_unlock_bh(&target->tx_lock);\r\nhtc_try_send(target, ep, NULL);\r\nspin_lock_bh(&target->tx_lock);\r\n}\r\ntotal_credits += rpt->credits;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"Report indicated %d credits to distribute\n",\r\ntotal_credits);\r\nspin_unlock_bh(&target->tx_lock);\r\n}\r\nstatic void htc_flush_tx_endpoint(struct htc_target *target,\r\nstruct htc_endpoint *ep, u16 tag)\r\n{\r\nstruct htc_packet *packet;\r\nspin_lock_bh(&target->tx_lock);\r\nwhile (get_queue_depth(&ep->txq)) {\r\npacket = list_first_entry(&ep->txq, struct htc_packet, list);\r\nlist_del(&packet->list);\r\npacket->status = 0;\r\nsend_packet_completion(target, packet);\r\n}\r\nspin_unlock_bh(&target->tx_lock);\r\n}\r\nstatic struct htc_packet *htc_lookup_tx_packet(struct htc_target *target,\r\nstruct htc_endpoint *ep,\r\nstruct sk_buff *skb)\r\n{\r\nstruct htc_packet *packet, *tmp_pkt, *found_packet = NULL;\r\nspin_lock_bh(&target->tx_lock);\r\nlist_for_each_entry_safe(packet, tmp_pkt, &ep->pipe.tx_lookup_queue,\r\nlist) {\r\nif (skb == packet->skb) {\r\nlist_del(&packet->list);\r\nfound_packet = packet;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&target->tx_lock);\r\nreturn found_packet;\r\n}\r\nstatic int ath6kl_htc_pipe_tx_complete(struct ath6kl *ar, struct sk_buff *skb)\r\n{\r\nstruct htc_target *target = ar->htc_target;\r\nstruct htc_frame_hdr *htc_hdr;\r\nstruct htc_endpoint *ep;\r\nstruct htc_packet *packet;\r\nu8 ep_id, *netdata;\r\nu32 netlen;\r\nnetdata = skb->data;\r\nnetlen = skb->len;\r\nhtc_hdr = (struct htc_frame_hdr *) netdata;\r\nep_id = htc_hdr->eid;\r\nep = &target->endpoint[ep_id];\r\npacket = htc_lookup_tx_packet(target, ep, skb);\r\nif (packet == NULL) {\r\nath6kl_err("HTC TX lookup failed!\n");\r\n} else {\r\npacket->status = 0;\r\nsend_packet_completion(target, packet);\r\n}\r\nskb = NULL;\r\nif (!ep->pipe.tx_credit_flow_enabled) {\r\nhtc_try_send(target, ep, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int htc_send_packets_multiple(struct htc_target *target,\r\nstruct list_head *pkt_queue)\r\n{\r\nstruct htc_endpoint *ep;\r\nstruct htc_packet *packet, *tmp_pkt;\r\nif (list_empty(pkt_queue))\r\nreturn -EINVAL;\r\npacket = list_first_entry(pkt_queue, struct htc_packet, list);\r\nif (packet->endpoint >= ENDPOINT_MAX) {\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\nep = &target->endpoint[packet->endpoint];\r\nhtc_try_send(target, ep, pkt_queue);\r\nif (!list_empty(pkt_queue)) {\r\nlist_for_each_entry_safe(packet, tmp_pkt, pkt_queue, list) {\r\npacket->status = -ENOMEM;\r\n}\r\ndo_send_completion(ep, pkt_queue);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct htc_packet *alloc_htc_packet_container(struct htc_target *target)\r\n{\r\nstruct htc_packet *packet;\r\nspin_lock_bh(&target->rx_lock);\r\nif (target->pipe.htc_packet_pool == NULL) {\r\nspin_unlock_bh(&target->rx_lock);\r\nreturn NULL;\r\n}\r\npacket = target->pipe.htc_packet_pool;\r\ntarget->pipe.htc_packet_pool = (struct htc_packet *) packet->list.next;\r\nspin_unlock_bh(&target->rx_lock);\r\npacket->list.next = NULL;\r\nreturn packet;\r\n}\r\nstatic void free_htc_packet_container(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nstruct list_head *lh;\r\nspin_lock_bh(&target->rx_lock);\r\nif (target->pipe.htc_packet_pool == NULL) {\r\ntarget->pipe.htc_packet_pool = packet;\r\npacket->list.next = NULL;\r\n} else {\r\nlh = (struct list_head *) target->pipe.htc_packet_pool;\r\npacket->list.next = lh;\r\ntarget->pipe.htc_packet_pool = packet;\r\n}\r\nspin_unlock_bh(&target->rx_lock);\r\n}\r\nstatic int htc_process_trailer(struct htc_target *target, u8 *buffer,\r\nint len, enum htc_endpoint_id from_ep)\r\n{\r\nstruct htc_credit_report *report;\r\nstruct htc_record_hdr *record;\r\nu8 *record_buf, *orig_buf;\r\nint orig_len, status;\r\norig_buf = buffer;\r\norig_len = len;\r\nstatus = 0;\r\nwhile (len > 0) {\r\nif (len < sizeof(struct htc_record_hdr)) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nrecord = (struct htc_record_hdr *) buffer;\r\nlen -= sizeof(struct htc_record_hdr);\r\nbuffer += sizeof(struct htc_record_hdr);\r\nif (record->len > len) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"invalid length: %d (id:%d) buffer has: %d bytes left\n",\r\nrecord->len, record->rec_id, len);\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nrecord_buf = buffer;\r\nswitch (record->rec_id) {\r\ncase HTC_RECORD_CREDITS:\r\nif (record->len < sizeof(struct htc_credit_report)) {\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\nreport = (struct htc_credit_report *) record_buf;\r\nhtc_process_credit_report(target, report,\r\nrecord->len / sizeof(*report),\r\nfrom_ep);\r\nbreak;\r\ndefault:\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"unhandled record: id:%d length:%d\n",\r\nrecord->rec_id, record->len);\r\nbreak;\r\n}\r\nif (status != 0)\r\nbreak;\r\nbuffer += record->len;\r\nlen -= record->len;\r\n}\r\nreturn status;\r\n}\r\nstatic void do_recv_completion(struct htc_endpoint *ep,\r\nstruct list_head *queue_to_indicate)\r\n{\r\nstruct htc_packet *packet;\r\nif (list_empty(queue_to_indicate)) {\r\nreturn;\r\n}\r\nwhile (!list_empty(queue_to_indicate)) {\r\npacket = list_first_entry(queue_to_indicate,\r\nstruct htc_packet, list);\r\nlist_del(&packet->list);\r\nep->ep_cb.rx(ep->target, packet);\r\n}\r\nreturn;\r\n}\r\nstatic void recv_packet_completion(struct htc_target *target,\r\nstruct htc_endpoint *ep,\r\nstruct htc_packet *packet)\r\n{\r\nstruct list_head container;\r\nINIT_LIST_HEAD(&container);\r\nlist_add_tail(&packet->list, &container);\r\ndo_recv_completion(ep, &container);\r\n}\r\nstatic int ath6kl_htc_pipe_rx_complete(struct ath6kl *ar, struct sk_buff *skb,\r\nu8 pipeid)\r\n{\r\nstruct htc_target *target = ar->htc_target;\r\nu8 *netdata, *trailer, hdr_info;\r\nstruct htc_frame_hdr *htc_hdr;\r\nu32 netlen, trailerlen = 0;\r\nstruct htc_packet *packet;\r\nstruct htc_endpoint *ep;\r\nu16 payload_len;\r\nint status = 0;\r\nnetdata = skb->data;\r\nnetlen = skb->len;\r\nhtc_hdr = (struct htc_frame_hdr *) netdata;\r\nep = &target->endpoint[htc_hdr->eid];\r\nif (htc_hdr->eid >= ENDPOINT_MAX) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"HTC Rx: invalid EndpointID=%d\n",\r\nhtc_hdr->eid);\r\nstatus = -EINVAL;\r\ngoto free_skb;\r\n}\r\npayload_len = le16_to_cpu(get_unaligned(&htc_hdr->payld_len));\r\nif (netlen < (payload_len + HTC_HDR_LENGTH)) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"HTC Rx: insufficient length, got:%d expected =%u\n",\r\nnetlen, payload_len + HTC_HDR_LENGTH);\r\nstatus = -EINVAL;\r\ngoto free_skb;\r\n}\r\nhdr_info = htc_hdr->flags;\r\nif (hdr_info & HTC_FLG_RX_TRAILER) {\r\nhdr_info = htc_hdr->ctrl[0];\r\nif ((hdr_info < sizeof(struct htc_record_hdr)) ||\r\n(hdr_info > payload_len)) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"invalid header: payloadlen should be %d, CB[0]: %d\n",\r\npayload_len, hdr_info);\r\nstatus = -EINVAL;\r\ngoto free_skb;\r\n}\r\ntrailerlen = hdr_info;\r\ntrailer = (u8 *) htc_hdr + HTC_HDR_LENGTH +\r\npayload_len - hdr_info;\r\nstatus = htc_process_trailer(target, trailer, hdr_info,\r\nhtc_hdr->eid);\r\nif (status != 0)\r\ngoto free_skb;\r\n}\r\nif (((int) payload_len - (int) trailerlen) <= 0) {\r\ngoto free_skb;\r\n}\r\nif (htc_hdr->eid == ENDPOINT_0) {\r\nif (target->htc_flags & HTC_OP_STATE_SETUP_COMPLETE) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"HTC ignores Rx Ctrl after setup complete\n");\r\nstatus = -EINVAL;\r\ngoto free_skb;\r\n}\r\nskb_pull(skb, HTC_HDR_LENGTH);\r\nnetdata = skb->data;\r\nnetlen = skb->len;\r\nspin_lock_bh(&target->rx_lock);\r\ntarget->pipe.ctrl_response_valid = true;\r\ntarget->pipe.ctrl_response_len = min_t(int, netlen,\r\nHTC_MAX_CTRL_MSG_LEN);\r\nmemcpy(target->pipe.ctrl_response_buf, netdata,\r\ntarget->pipe.ctrl_response_len);\r\nspin_unlock_bh(&target->rx_lock);\r\ndev_kfree_skb(skb);\r\nskb = NULL;\r\ngoto free_skb;\r\n}\r\npacket = alloc_htc_packet_container(target);\r\nif (packet == NULL) {\r\nstatus = -ENOMEM;\r\ngoto free_skb;\r\n}\r\npacket->status = 0;\r\npacket->endpoint = htc_hdr->eid;\r\npacket->pkt_cntxt = skb;\r\npacket->buf = skb_push(skb, 0) + HTC_HDR_LENGTH;\r\npacket->act_len = netlen - HTC_HDR_LENGTH - trailerlen;\r\nskb_trim(skb, 0);\r\nrecv_packet_completion(target, ep, packet);\r\nfree_htc_packet_container(target, packet);\r\nskb = NULL;\r\nfree_skb:\r\nif (skb != NULL)\r\ndev_kfree_skb(skb);\r\nreturn status;\r\n}\r\nstatic void htc_flush_rx_queue(struct htc_target *target,\r\nstruct htc_endpoint *ep)\r\n{\r\nstruct list_head container;\r\nstruct htc_packet *packet;\r\nspin_lock_bh(&target->rx_lock);\r\nwhile (1) {\r\nif (list_empty(&ep->rx_bufq))\r\nbreak;\r\npacket = list_first_entry(&ep->rx_bufq,\r\nstruct htc_packet, list);\r\nlist_del(&packet->list);\r\nspin_unlock_bh(&target->rx_lock);\r\npacket->status = -ECANCELED;\r\npacket->act_len = 0;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"Flushing RX packet:0x%p, length:%d, ep:%d\n",\r\npacket, packet->buf_len,\r\npacket->endpoint);\r\nINIT_LIST_HEAD(&container);\r\nlist_add_tail(&packet->list, &container);\r\ndo_recv_completion(ep, &container);\r\nspin_lock_bh(&target->rx_lock);\r\n}\r\nspin_unlock_bh(&target->rx_lock);\r\n}\r\nstatic int htc_wait_recv_ctrl_message(struct htc_target *target)\r\n{\r\nint count = HTC_TARGET_RESPONSE_POLL_COUNT;\r\nwhile (count > 0) {\r\nspin_lock_bh(&target->rx_lock);\r\nif (target->pipe.ctrl_response_valid) {\r\ntarget->pipe.ctrl_response_valid = false;\r\nspin_unlock_bh(&target->rx_lock);\r\nbreak;\r\n}\r\nspin_unlock_bh(&target->rx_lock);\r\ncount--;\r\nmsleep_interruptible(HTC_TARGET_RESPONSE_POLL_WAIT);\r\n}\r\nif (count <= 0) {\r\nath6kl_dbg(ATH6KL_DBG_HTC, "%s: Timeout!\n", __func__);\r\nreturn -ECOMM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void htc_rxctrl_complete(struct htc_target *context,\r\nstruct htc_packet *packet)\r\n{\r\nath6kl_dbg(ATH6KL_DBG_HTC, "%s: invalid call function\n", __func__);\r\n}\r\nstatic void reset_endpoint_states(struct htc_target *target)\r\n{\r\nstruct htc_endpoint *ep;\r\nint i;\r\nfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\r\nep = &target->endpoint[i];\r\nep->svc_id = 0;\r\nep->len_max = 0;\r\nep->max_txq_depth = 0;\r\nep->eid = i;\r\nINIT_LIST_HEAD(&ep->txq);\r\nINIT_LIST_HEAD(&ep->pipe.tx_lookup_queue);\r\nINIT_LIST_HEAD(&ep->rx_bufq);\r\nep->target = target;\r\nep->pipe.tx_credit_flow_enabled = (bool) 1;\r\n}\r\n}\r\nstatic int htc_config_target_hif_pipe(struct htc_target *target)\r\n{\r\nreturn 0;\r\n}\r\nstatic u8 htc_get_credit_alloc(struct htc_target *target, u16 service_id)\r\n{\r\nu8 allocation = 0;\r\nint i;\r\nfor (i = 0; i < ENDPOINT_MAX; i++) {\r\nif (target->pipe.txcredit_alloc[i].service_id == service_id)\r\nallocation =\r\ntarget->pipe.txcredit_alloc[i].credit_alloc;\r\n}\r\nif (allocation == 0) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"HTC Service TX : 0x%2.2X : allocation is zero!\n",\r\nservice_id);\r\n}\r\nreturn allocation;\r\n}\r\nstatic int ath6kl_htc_pipe_conn_service(struct htc_target *target,\r\nstruct htc_service_connect_req *conn_req,\r\nstruct htc_service_connect_resp *conn_resp)\r\n{\r\nstruct ath6kl *ar = target->dev->ar;\r\nstruct htc_packet *packet = NULL;\r\nstruct htc_conn_service_resp *resp_msg;\r\nstruct htc_conn_service_msg *conn_msg;\r\nenum htc_endpoint_id assigned_epid = ENDPOINT_MAX;\r\nbool disable_credit_flowctrl = false;\r\nunsigned int max_msg_size = 0;\r\nstruct htc_endpoint *ep;\r\nint length, status = 0;\r\nstruct sk_buff *skb;\r\nu8 tx_alloc;\r\nu16 flags;\r\nif (conn_req->svc_id == 0) {\r\nWARN_ON_ONCE(1);\r\nstatus = -EINVAL;\r\ngoto free_packet;\r\n}\r\nif (conn_req->svc_id == HTC_CTRL_RSVD_SVC) {\r\nassigned_epid = ENDPOINT_0;\r\nmax_msg_size = HTC_MAX_CTRL_MSG_LEN;\r\ntx_alloc = 0;\r\n} else {\r\ntx_alloc = htc_get_credit_alloc(target, conn_req->svc_id);\r\nif (tx_alloc == 0) {\r\nstatus = -ENOMEM;\r\ngoto free_packet;\r\n}\r\npacket = htc_alloc_txctrl_packet(target);\r\nif (packet == NULL) {\r\nWARN_ON_ONCE(1);\r\nstatus = -ENOMEM;\r\ngoto free_packet;\r\n}\r\nskb = packet->skb;\r\nlength = sizeof(struct htc_conn_service_msg);\r\nconn_msg = (struct htc_conn_service_msg *) skb_put(skb,\r\nlength);\r\nif (conn_msg == NULL) {\r\nWARN_ON_ONCE(1);\r\nstatus = -EINVAL;\r\ngoto free_packet;\r\n}\r\nmemset(conn_msg, 0,\r\nsizeof(struct htc_conn_service_msg));\r\nconn_msg->msg_id = cpu_to_le16(HTC_MSG_CONN_SVC_ID);\r\nconn_msg->svc_id = cpu_to_le16(conn_req->svc_id);\r\nconn_msg->conn_flags = cpu_to_le16(conn_req->conn_flags &\r\n~HTC_CONN_FLGS_SET_RECV_ALLOC_MASK);\r\nflags = tx_alloc << HTC_CONN_FLGS_SET_RECV_ALLOC_SHIFT;\r\nconn_msg->conn_flags |= cpu_to_le16(flags);\r\nif (conn_req->conn_flags &\r\nHTC_CONN_FLGS_DISABLE_CRED_FLOW_CTRL) {\r\ndisable_credit_flowctrl = true;\r\n}\r\nset_htc_pkt_info(packet, NULL, (u8 *) conn_msg,\r\nlength,\r\nENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\r\nstatus = ath6kl_htc_pipe_tx(target, packet);\r\npacket = NULL;\r\nif (status != 0)\r\ngoto free_packet;\r\nstatus = htc_wait_recv_ctrl_message(target);\r\nif (status != 0)\r\ngoto free_packet;\r\nresp_msg = (struct htc_conn_service_resp *)\r\ntarget->pipe.ctrl_response_buf;\r\nif (resp_msg->msg_id != cpu_to_le16(HTC_MSG_CONN_SVC_RESP_ID) ||\r\n(target->pipe.ctrl_response_len < sizeof(*resp_msg))) {\r\nWARN_ON_ONCE(1);\r\nstatus = -EINVAL;\r\ngoto free_packet;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_TRC,\r\n"%s: service 0x%X conn resp: status: %d ep: %d\n",\r\n__func__, resp_msg->svc_id, resp_msg->status,\r\nresp_msg->eid);\r\nconn_resp->resp_code = resp_msg->status;\r\nif (resp_msg->status != HTC_SERVICE_SUCCESS) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"Target failed service 0x%X connect request (status:%d)\n",\r\nresp_msg->svc_id, resp_msg->status);\r\nstatus = -EINVAL;\r\ngoto free_packet;\r\n}\r\nassigned_epid = (enum htc_endpoint_id) resp_msg->eid;\r\nmax_msg_size = le16_to_cpu(resp_msg->max_msg_sz);\r\n}\r\nstatus = -EINVAL;\r\nif (assigned_epid >= ENDPOINT_MAX) {\r\nWARN_ON_ONCE(1);\r\ngoto free_packet;\r\n}\r\nif (max_msg_size == 0) {\r\nWARN_ON_ONCE(1);\r\ngoto free_packet;\r\n}\r\nep = &target->endpoint[assigned_epid];\r\nep->eid = assigned_epid;\r\nif (ep->svc_id != 0) {\r\nWARN_ON_ONCE(1);\r\ngoto free_packet;\r\n}\r\nconn_resp->endpoint = assigned_epid;\r\nconn_resp->len_max = max_msg_size;\r\nep->svc_id = conn_req->svc_id;\r\nep->max_txq_depth = conn_req->max_txq_depth;\r\nep->len_max = max_msg_size;\r\nep->cred_dist.credits = tx_alloc;\r\nep->cred_dist.cred_sz = target->tgt_cred_sz;\r\nep->cred_dist.cred_per_msg = max_msg_size / target->tgt_cred_sz;\r\nif (max_msg_size % target->tgt_cred_sz)\r\nep->cred_dist.cred_per_msg++;\r\nep->ep_cb = conn_req->ep_cb;\r\nep->tx_drop_packet_threshold = MAX_HI_COOKIE_NUM;\r\nstatus = ath6kl_hif_pipe_map_service(ar, ep->svc_id,\r\n&ep->pipe.pipeid_ul,\r\n&ep->pipe.pipeid_dl);\r\nif (status != 0)\r\ngoto free_packet;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"SVC Ready: 0x%4.4X: ULpipe:%d DLpipe:%d id:%d\n",\r\nep->svc_id, ep->pipe.pipeid_ul,\r\nep->pipe.pipeid_dl, ep->eid);\r\nif (disable_credit_flowctrl && ep->pipe.tx_credit_flow_enabled) {\r\nep->pipe.tx_credit_flow_enabled = false;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"SVC: 0x%4.4X ep:%d TX flow control off\n",\r\nep->svc_id, assigned_epid);\r\n}\r\nfree_packet:\r\nif (packet != NULL)\r\nhtc_free_txctrl_packet(target, packet);\r\nreturn status;\r\n}\r\nstatic void *ath6kl_htc_pipe_create(struct ath6kl *ar)\r\n{\r\nint status = 0;\r\nstruct htc_endpoint *ep = NULL;\r\nstruct htc_target *target = NULL;\r\nstruct htc_packet *packet;\r\nint i;\r\ntarget = kzalloc(sizeof(struct htc_target), GFP_KERNEL);\r\nif (target == NULL) {\r\nath6kl_err("htc create unable to allocate memory\n");\r\nstatus = -ENOMEM;\r\ngoto fail_htc_create;\r\n}\r\nspin_lock_init(&target->htc_lock);\r\nspin_lock_init(&target->rx_lock);\r\nspin_lock_init(&target->tx_lock);\r\nreset_endpoint_states(target);\r\nfor (i = 0; i < HTC_PACKET_CONTAINER_ALLOCATION; i++) {\r\npacket = kzalloc(sizeof(struct htc_packet), GFP_KERNEL);\r\nif (packet != NULL)\r\nfree_htc_packet_container(target, packet);\r\n}\r\ntarget->dev = kzalloc(sizeof(*target->dev), GFP_KERNEL);\r\nif (!target->dev) {\r\nath6kl_err("unable to allocate memory\n");\r\nstatus = -ENOMEM;\r\ngoto fail_htc_create;\r\n}\r\ntarget->dev->ar = ar;\r\ntarget->dev->htc_cnxt = target;\r\nep = &target->endpoint[ENDPOINT_0];\r\nath6kl_hif_pipe_get_default(ar, &ep->pipe.pipeid_ul,\r\n&ep->pipe.pipeid_dl);\r\nreturn target;\r\nfail_htc_create:\r\nif (status != 0) {\r\nif (target != NULL)\r\nath6kl_htc_pipe_cleanup(target);\r\ntarget = NULL;\r\n}\r\nreturn target;\r\n}\r\nstatic void ath6kl_htc_pipe_cleanup(struct htc_target *target)\r\n{\r\nstruct htc_packet *packet;\r\nwhile (true) {\r\npacket = alloc_htc_packet_container(target);\r\nif (packet == NULL)\r\nbreak;\r\nkfree(packet);\r\n}\r\nkfree(target->dev);\r\nkfree(target);\r\n}\r\nstatic int ath6kl_htc_pipe_start(struct htc_target *target)\r\n{\r\nstruct sk_buff *skb;\r\nstruct htc_setup_comp_ext_msg *setup;\r\nstruct htc_packet *packet;\r\nhtc_config_target_hif_pipe(target);\r\npacket = htc_alloc_txctrl_packet(target);\r\nif (packet == NULL) {\r\nWARN_ON_ONCE(1);\r\nreturn -ENOMEM;\r\n}\r\nskb = packet->skb;\r\nsetup = (struct htc_setup_comp_ext_msg *) skb_put(skb,\r\nsizeof(*setup));\r\nmemset(setup, 0, sizeof(struct htc_setup_comp_ext_msg));\r\nsetup->msg_id = cpu_to_le16(HTC_MSG_SETUP_COMPLETE_EX_ID);\r\nath6kl_dbg(ATH6KL_DBG_HTC, "HTC using TX credit flow control\n");\r\nset_htc_pkt_info(packet, NULL, (u8 *) setup,\r\nsizeof(struct htc_setup_comp_ext_msg),\r\nENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\r\ntarget->htc_flags |= HTC_OP_STATE_SETUP_COMPLETE;\r\nreturn ath6kl_htc_pipe_tx(target, packet);\r\n}\r\nstatic void ath6kl_htc_pipe_stop(struct htc_target *target)\r\n{\r\nint i;\r\nstruct htc_endpoint *ep;\r\nfor (i = 0; i < ENDPOINT_MAX; i++) {\r\nep = &target->endpoint[i];\r\nhtc_flush_rx_queue(target, ep);\r\nhtc_flush_tx_endpoint(target, ep, HTC_TX_PACKET_TAG_ALL);\r\n}\r\nreset_endpoint_states(target);\r\ntarget->htc_flags &= ~HTC_OP_STATE_SETUP_COMPLETE;\r\n}\r\nstatic int ath6kl_htc_pipe_get_rxbuf_num(struct htc_target *target,\r\nenum htc_endpoint_id endpoint)\r\n{\r\nint num;\r\nspin_lock_bh(&target->rx_lock);\r\nnum = get_queue_depth(&(target->endpoint[endpoint].rx_bufq));\r\nspin_unlock_bh(&target->rx_lock);\r\nreturn num;\r\n}\r\nstatic int ath6kl_htc_pipe_tx(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nstruct list_head queue;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"%s: endPointId: %d, buffer: 0x%p, length: %d\n",\r\n__func__, packet->endpoint, packet->buf,\r\npacket->act_len);\r\nINIT_LIST_HEAD(&queue);\r\nlist_add_tail(&packet->list, &queue);\r\nreturn htc_send_packets_multiple(target, &queue);\r\n}\r\nstatic int ath6kl_htc_pipe_wait_target(struct htc_target *target)\r\n{\r\nstruct htc_ready_ext_msg *ready_msg;\r\nstruct htc_service_connect_req connect;\r\nstruct htc_service_connect_resp resp;\r\nint status = 0;\r\nstatus = htc_wait_recv_ctrl_message(target);\r\nif (status != 0)\r\nreturn status;\r\nif (target->pipe.ctrl_response_len < sizeof(*ready_msg)) {\r\nath6kl_dbg(ATH6KL_DBG_HTC, "invalid htc ready msg len:%d!\n",\r\ntarget->pipe.ctrl_response_len);\r\nreturn -ECOMM;\r\n}\r\nready_msg = (struct htc_ready_ext_msg *) target->pipe.ctrl_response_buf;\r\nif (ready_msg->ver2_0_info.msg_id != cpu_to_le16(HTC_MSG_READY_ID)) {\r\nath6kl_dbg(ATH6KL_DBG_HTC, "invalid htc ready msg : 0x%X !\n",\r\nready_msg->ver2_0_info.msg_id);\r\nreturn -ECOMM;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"Target Ready! : transmit resources : %d size:%d\n",\r\nready_msg->ver2_0_info.cred_cnt,\r\nready_msg->ver2_0_info.cred_sz);\r\ntarget->tgt_creds = le16_to_cpu(ready_msg->ver2_0_info.cred_cnt);\r\ntarget->tgt_cred_sz = le16_to_cpu(ready_msg->ver2_0_info.cred_sz);\r\nif ((target->tgt_creds == 0) || (target->tgt_cred_sz == 0))\r\nreturn -ECOMM;\r\nhtc_setup_target_buffer_assignments(target);\r\nmemset(&connect, 0, sizeof(connect));\r\nmemset(&resp, 0, sizeof(resp));\r\nconnect.ep_cb.tx_complete = htc_txctrl_complete;\r\nconnect.ep_cb.rx = htc_rxctrl_complete;\r\nconnect.max_txq_depth = NUM_CONTROL_TX_BUFFERS;\r\nconnect.svc_id = HTC_CTRL_RSVD_SVC;\r\nstatus = ath6kl_htc_pipe_conn_service(target, &connect, &resp);\r\nreturn status;\r\n}\r\nstatic void ath6kl_htc_pipe_flush_txep(struct htc_target *target,\r\nenum htc_endpoint_id endpoint, u16 tag)\r\n{\r\nstruct htc_endpoint *ep = &target->endpoint[endpoint];\r\nif (ep->svc_id == 0) {\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\nhtc_flush_tx_endpoint(target, ep, tag);\r\n}\r\nstatic int ath6kl_htc_pipe_add_rxbuf_multiple(struct htc_target *target,\r\nstruct list_head *pkt_queue)\r\n{\r\nstruct htc_packet *packet, *tmp_pkt, *first;\r\nstruct htc_endpoint *ep;\r\nint status = 0;\r\nif (list_empty(pkt_queue))\r\nreturn -EINVAL;\r\nfirst = list_first_entry(pkt_queue, struct htc_packet, list);\r\nif (first->endpoint >= ENDPOINT_MAX) {\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_HTC, "%s: epid: %d, cnt:%d, len: %d\n",\r\n__func__, first->endpoint, get_queue_depth(pkt_queue),\r\nfirst->buf_len);\r\nep = &target->endpoint[first->endpoint];\r\nspin_lock_bh(&target->rx_lock);\r\nlist_splice_tail_init(pkt_queue, &ep->rx_bufq);\r\nspin_unlock_bh(&target->rx_lock);\r\nif (status != 0) {\r\nlist_for_each_entry_safe(packet, tmp_pkt, pkt_queue, list) {\r\npacket->status = -ECANCELED;\r\n}\r\ndo_recv_completion(ep, pkt_queue);\r\n}\r\nreturn status;\r\n}\r\nstatic void ath6kl_htc_pipe_activity_changed(struct htc_target *target,\r\nenum htc_endpoint_id ep,\r\nbool active)\r\n{\r\n}\r\nstatic void ath6kl_htc_pipe_flush_rx_buf(struct htc_target *target)\r\n{\r\n}\r\nstatic int ath6kl_htc_pipe_credit_setup(struct htc_target *target,\r\nstruct ath6kl_htc_credit_info *info)\r\n{\r\nreturn 0;\r\n}\r\nvoid ath6kl_htc_pipe_attach(struct ath6kl *ar)\r\n{\r\nar->htc_ops = &ath6kl_htc_pipe_ops;\r\n}
