void imx_enable_cpu(int cpu, bool enable)\r\n{\r\nu32 mask, val;\r\ncpu = cpu_logical_map(cpu);\r\nmask = 1 << (BP_SRC_SCR_CORE1_ENABLE + cpu - 1);\r\nval = readl_relaxed(src_base + SRC_SCR);\r\nval = enable ? val | mask : val & ~mask;\r\nwritel_relaxed(val, src_base + SRC_SCR);\r\n}\r\nvoid imx_set_cpu_jump(int cpu, void *jump_addr)\r\n{\r\ncpu = cpu_logical_map(cpu);\r\nwritel_relaxed(virt_to_phys(jump_addr),\r\nsrc_base + SRC_GPR1 + cpu * 8);\r\n}\r\nvoid imx_src_prepare_restart(void)\r\n{\r\nu32 val;\r\nval = readl_relaxed(src_base + SRC_SCR);\r\nval &= ~(0x7 << BP_SRC_SCR_CORE1_ENABLE);\r\nwritel_relaxed(val, src_base + SRC_SCR);\r\nwritel_relaxed(0, src_base + SRC_GPR1);\r\n}\r\nvoid __init imx_src_init(void)\r\n{\r\nstruct device_node *np;\r\nu32 val;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,imx6q-src");\r\nsrc_base = of_iomap(np, 0);\r\nWARN_ON(!src_base);\r\nval = readl_relaxed(src_base + SRC_SCR);\r\nval &= ~(1 << BP_SRC_SCR_WARM_RESET_ENABLE);\r\nwritel_relaxed(val, src_base + SRC_SCR);\r\n}
