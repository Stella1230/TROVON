static int ir_lirc_decode(struct rc_dev *dev, struct ir_raw_event ev)\r\n{\r\nstruct lirc_codec *lirc = &dev->raw->lirc;\r\nint sample;\r\nif (!(dev->raw->enabled_protocols & RC_TYPE_LIRC))\r\nreturn 0;\r\nif (!dev->raw->lirc.drv || !dev->raw->lirc.drv->rbuf)\r\nreturn -EINVAL;\r\nif (ev.reset)\r\nreturn 0;\r\nif (ev.carrier_report) {\r\nsample = LIRC_FREQUENCY(ev.carrier);\r\nIR_dprintk(2, "carrier report (freq: %d)\n", sample);\r\n} else if (ev.timeout) {\r\nif (lirc->gap)\r\nreturn 0;\r\nlirc->gap_start = ktime_get();\r\nlirc->gap = true;\r\nlirc->gap_duration = ev.duration;\r\nif (!lirc->send_timeout_reports)\r\nreturn 0;\r\nsample = LIRC_TIMEOUT(ev.duration / 1000);\r\nIR_dprintk(2, "timeout report (duration: %d)\n", sample);\r\n} else {\r\nif (lirc->gap) {\r\nint gap_sample;\r\nlirc->gap_duration += ktime_to_ns(ktime_sub(ktime_get(),\r\nlirc->gap_start));\r\ndo_div(lirc->gap_duration, 1000);\r\nlirc->gap_duration = min(lirc->gap_duration,\r\n(u64)LIRC_VALUE_MASK);\r\ngap_sample = LIRC_SPACE(lirc->gap_duration);\r\nlirc_buffer_write(dev->raw->lirc.drv->rbuf,\r\n(unsigned char *) &gap_sample);\r\nlirc->gap = false;\r\n}\r\nsample = ev.pulse ? LIRC_PULSE(ev.duration / 1000) :\r\nLIRC_SPACE(ev.duration / 1000);\r\nIR_dprintk(2, "delivering %uus %s to lirc_dev\n",\r\nTO_US(ev.duration), TO_STR(ev.pulse));\r\n}\r\nlirc_buffer_write(dev->raw->lirc.drv->rbuf,\r\n(unsigned char *) &sample);\r\nwake_up(&dev->raw->lirc.drv->rbuf->wait_poll);\r\nreturn 0;\r\n}\r\nstatic ssize_t ir_lirc_transmit_ir(struct file *file, const char __user *buf,\r\nsize_t n, loff_t *ppos)\r\n{\r\nstruct lirc_codec *lirc;\r\nstruct rc_dev *dev;\r\nunsigned int *txbuf;\r\nssize_t ret = 0;\r\nsize_t count;\r\nlirc = lirc_get_pdata(file);\r\nif (!lirc)\r\nreturn -EFAULT;\r\nif (n < sizeof(unsigned) || n % sizeof(unsigned))\r\nreturn -EINVAL;\r\ncount = n / sizeof(unsigned);\r\nif (count > LIRCBUF_SIZE || count % 2 == 0)\r\nreturn -EINVAL;\r\ntxbuf = memdup_user(buf, n);\r\nif (IS_ERR(txbuf))\r\nreturn PTR_ERR(txbuf);\r\ndev = lirc->dev;\r\nif (!dev) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (dev->tx_ir)\r\nret = dev->tx_ir(dev, txbuf, count);\r\nif (ret > 0)\r\nret *= sizeof(unsigned);\r\nout:\r\nkfree(txbuf);\r\nreturn ret;\r\n}\r\nstatic long ir_lirc_ioctl(struct file *filep, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct lirc_codec *lirc;\r\nstruct rc_dev *dev;\r\nu32 __user *argp = (u32 __user *)(arg);\r\nint ret = 0;\r\n__u32 val = 0, tmp;\r\nlirc = lirc_get_pdata(filep);\r\nif (!lirc)\r\nreturn -EFAULT;\r\ndev = lirc->dev;\r\nif (!dev)\r\nreturn -EFAULT;\r\nif (_IOC_DIR(cmd) & _IOC_WRITE) {\r\nret = get_user(val, argp);\r\nif (ret)\r\nreturn ret;\r\n}\r\nswitch (cmd) {\r\ncase LIRC_GET_SEND_MODE:\r\nval = LIRC_CAN_SEND_PULSE & LIRC_CAN_SEND_MASK;\r\nbreak;\r\ncase LIRC_SET_SEND_MODE:\r\nif (val != (LIRC_MODE_PULSE & LIRC_CAN_SEND_MASK))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase LIRC_SET_TRANSMITTER_MASK:\r\nif (!dev->s_tx_mask)\r\nreturn -EINVAL;\r\nreturn dev->s_tx_mask(dev, val);\r\ncase LIRC_SET_SEND_CARRIER:\r\nif (!dev->s_tx_carrier)\r\nreturn -EINVAL;\r\nreturn dev->s_tx_carrier(dev, val);\r\ncase LIRC_SET_SEND_DUTY_CYCLE:\r\nif (!dev->s_tx_duty_cycle)\r\nreturn -ENOSYS;\r\nif (val <= 0 || val >= 100)\r\nreturn -EINVAL;\r\nreturn dev->s_tx_duty_cycle(dev, val);\r\ncase LIRC_SET_REC_CARRIER:\r\nif (!dev->s_rx_carrier_range)\r\nreturn -ENOSYS;\r\nif (val <= 0)\r\nreturn -EINVAL;\r\nreturn dev->s_rx_carrier_range(dev,\r\ndev->raw->lirc.carrier_low,\r\nval);\r\ncase LIRC_SET_REC_CARRIER_RANGE:\r\nif (val <= 0)\r\nreturn -EINVAL;\r\ndev->raw->lirc.carrier_low = val;\r\nreturn 0;\r\ncase LIRC_GET_REC_RESOLUTION:\r\nval = dev->rx_resolution;\r\nbreak;\r\ncase LIRC_SET_WIDEBAND_RECEIVER:\r\nif (!dev->s_learning_mode)\r\nreturn -ENOSYS;\r\nreturn dev->s_learning_mode(dev, !!val);\r\ncase LIRC_SET_MEASURE_CARRIER_MODE:\r\nif (!dev->s_carrier_report)\r\nreturn -ENOSYS;\r\nreturn dev->s_carrier_report(dev, !!val);\r\ncase LIRC_GET_MIN_TIMEOUT:\r\nif (!dev->max_timeout)\r\nreturn -ENOSYS;\r\nval = dev->min_timeout / 1000;\r\nbreak;\r\ncase LIRC_GET_MAX_TIMEOUT:\r\nif (!dev->max_timeout)\r\nreturn -ENOSYS;\r\nval = dev->max_timeout / 1000;\r\nbreak;\r\ncase LIRC_SET_REC_TIMEOUT:\r\nif (!dev->max_timeout)\r\nreturn -ENOSYS;\r\ntmp = val * 1000;\r\nif (tmp < dev->min_timeout ||\r\ntmp > dev->max_timeout)\r\nreturn -EINVAL;\r\ndev->timeout = tmp;\r\nbreak;\r\ncase LIRC_SET_REC_TIMEOUT_REPORTS:\r\nlirc->send_timeout_reports = !!val;\r\nbreak;\r\ndefault:\r\nreturn lirc_dev_fop_ioctl(filep, cmd, arg);\r\n}\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nret = put_user(val, argp);\r\nreturn ret;\r\n}\r\nstatic int ir_lirc_open(void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ir_lirc_close(void *data)\r\n{\r\nreturn;\r\n}\r\nstatic int ir_lirc_register(struct rc_dev *dev)\r\n{\r\nstruct lirc_driver *drv;\r\nstruct lirc_buffer *rbuf;\r\nint rc = -ENOMEM;\r\nunsigned long features;\r\ndrv = kzalloc(sizeof(struct lirc_driver), GFP_KERNEL);\r\nif (!drv)\r\nreturn rc;\r\nrbuf = kzalloc(sizeof(struct lirc_buffer), GFP_KERNEL);\r\nif (!rbuf)\r\ngoto rbuf_alloc_failed;\r\nrc = lirc_buffer_init(rbuf, sizeof(int), LIRCBUF_SIZE);\r\nif (rc)\r\ngoto rbuf_init_failed;\r\nfeatures = LIRC_CAN_REC_MODE2;\r\nif (dev->tx_ir) {\r\nfeatures |= LIRC_CAN_SEND_PULSE;\r\nif (dev->s_tx_mask)\r\nfeatures |= LIRC_CAN_SET_TRANSMITTER_MASK;\r\nif (dev->s_tx_carrier)\r\nfeatures |= LIRC_CAN_SET_SEND_CARRIER;\r\nif (dev->s_tx_duty_cycle)\r\nfeatures |= LIRC_CAN_SET_SEND_DUTY_CYCLE;\r\n}\r\nif (dev->s_rx_carrier_range)\r\nfeatures |= LIRC_CAN_SET_REC_CARRIER |\r\nLIRC_CAN_SET_REC_CARRIER_RANGE;\r\nif (dev->s_learning_mode)\r\nfeatures |= LIRC_CAN_USE_WIDEBAND_RECEIVER;\r\nif (dev->s_carrier_report)\r\nfeatures |= LIRC_CAN_MEASURE_CARRIER;\r\nif (dev->max_timeout)\r\nfeatures |= LIRC_CAN_SET_REC_TIMEOUT;\r\nsnprintf(drv->name, sizeof(drv->name), "ir-lirc-codec (%s)",\r\ndev->driver_name);\r\ndrv->minor = -1;\r\ndrv->features = features;\r\ndrv->data = &dev->raw->lirc;\r\ndrv->rbuf = rbuf;\r\ndrv->set_use_inc = &ir_lirc_open;\r\ndrv->set_use_dec = &ir_lirc_close;\r\ndrv->code_length = sizeof(struct ir_raw_event) * 8;\r\ndrv->fops = &lirc_fops;\r\ndrv->dev = &dev->dev;\r\ndrv->owner = THIS_MODULE;\r\ndrv->minor = lirc_register_driver(drv);\r\nif (drv->minor < 0) {\r\nrc = -ENODEV;\r\ngoto lirc_register_failed;\r\n}\r\ndev->raw->lirc.drv = drv;\r\ndev->raw->lirc.dev = dev;\r\nreturn 0;\r\nlirc_register_failed:\r\nrbuf_init_failed:\r\nkfree(rbuf);\r\nrbuf_alloc_failed:\r\nkfree(drv);\r\nreturn rc;\r\n}\r\nstatic int ir_lirc_unregister(struct rc_dev *dev)\r\n{\r\nstruct lirc_codec *lirc = &dev->raw->lirc;\r\nlirc_unregister_driver(lirc->drv->minor);\r\nlirc_buffer_free(lirc->drv->rbuf);\r\nkfree(lirc->drv);\r\nreturn 0;\r\n}\r\nstatic int __init ir_lirc_codec_init(void)\r\n{\r\nir_raw_handler_register(&lirc_handler);\r\nprintk(KERN_INFO "IR LIRC bridge handler initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ir_lirc_codec_exit(void)\r\n{\r\nir_raw_handler_unregister(&lirc_handler);\r\n}
