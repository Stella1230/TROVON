uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,\r\nuint32_t max_formats, enum omap_color_mode supported_modes)\r\n{\r\nuint32_t nformats = 0;\r\nint i = 0;\r\nfor (i = 0; i < ARRAY_SIZE(formats) && nformats < max_formats; i++)\r\nif (formats[i].dss_format & supported_modes)\r\npixel_formats[nformats++] = formats[i].pixel_format;\r\nreturn nformats;\r\n}\r\nstatic int omap_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nreturn drm_gem_handle_create(file_priv,\r\nomap_fb->planes[0].bo, handle);\r\n}\r\nstatic void omap_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint i, n = drm_format_num_planes(fb->pixel_format);\r\nDBG("destroy: FB ID: %d (%p)", fb->base.id, fb);\r\ndrm_framebuffer_cleanup(fb);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nif (plane->bo)\r\ndrm_gem_object_unreference_unlocked(plane->bo);\r\n}\r\nkfree(omap_fb);\r\n}\r\nstatic int omap_framebuffer_dirty(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv, unsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips, unsigned num_clips)\r\n{\r\nint i;\r\nfor (i = 0; i < num_clips; i++) {\r\nomap_framebuffer_flush(fb, clips[i].x1, clips[i].y1,\r\nclips[i].x2 - clips[i].x1,\r\nclips[i].y2 - clips[i].y1);\r\n}\r\nreturn 0;\r\n}\r\nvoid omap_framebuffer_update_scanout(struct drm_framebuffer *fb, int x, int y,\r\nstruct omap_overlay_info *info)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nconst struct format *format = omap_fb->format;\r\nstruct plane *plane = &omap_fb->planes[0];\r\nunsigned int offset;\r\noffset = plane->offset +\r\n(x * format->planes[0].stride_bpp) +\r\n(y * plane->pitch / format->planes[0].sub_y);\r\ninfo->color_mode = format->dss_format;\r\ninfo->paddr = plane->paddr + offset;\r\ninfo->screen_width = plane->pitch / format->planes[0].stride_bpp;\r\nif (format->dss_format == OMAP_DSS_COLOR_NV12) {\r\nplane = &omap_fb->planes[1];\r\noffset = plane->offset +\r\n(x * format->planes[1].stride_bpp) +\r\n(y * plane->pitch / format->planes[1].sub_y);\r\ninfo->p_uv_addr = plane->paddr + offset;\r\n} else {\r\ninfo->p_uv_addr = 0;\r\n}\r\n}\r\nint omap_framebuffer_replace(struct drm_framebuffer *a,\r\nstruct drm_framebuffer *b, void *arg,\r\nvoid (*unpin)(void *arg, struct drm_gem_object *bo))\r\n{\r\nint ret = 0, i, na, nb;\r\nstruct omap_framebuffer *ofba = to_omap_framebuffer(a);\r\nstruct omap_framebuffer *ofbb = to_omap_framebuffer(b);\r\nna = a ? drm_format_num_planes(a->pixel_format) : 0;\r\nnb = b ? drm_format_num_planes(b->pixel_format) : 0;\r\nfor (i = 0; i < max(na, nb); i++) {\r\nstruct plane *pa, *pb;\r\npa = (i < na) ? &ofba->planes[i] : NULL;\r\npb = (i < nb) ? &ofbb->planes[i] : NULL;\r\nif (pa) {\r\nunpin(arg, pa->bo);\r\npa->paddr = 0;\r\n}\r\nif (pb && !ret) {\r\nret = omap_gem_get_paddr(pb->bo, &pb->paddr, true);\r\nif (!ret)\r\nomap_gem_dma_sync(pb->bo, DMA_TO_DEVICE);\r\n}\r\n}\r\nif (ret) {\r\nfor (i = 0; i < nb; i++) {\r\nstruct plane *pb = &ofba->planes[i];\r\nif (pb->paddr) {\r\nunpin(arg, pb->bo);\r\npb->paddr = 0;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstruct drm_gem_object *omap_framebuffer_bo(struct drm_framebuffer *fb, int p)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nif (p >= drm_format_num_planes(fb->pixel_format))\r\nreturn NULL;\r\nreturn omap_fb->planes[p].bo;\r\n}\r\nstruct drm_connector *omap_framebuffer_get_next_connector(\r\nstruct drm_framebuffer *fb, struct drm_connector *from)\r\n{\r\nstruct drm_device *dev = fb->dev;\r\nstruct list_head *connector_list = &dev->mode_config.connector_list;\r\nstruct drm_connector *connector = from;\r\nif (!from) {\r\nreturn list_first_entry(connector_list, typeof(*from), head);\r\n}\r\nlist_for_each_entry_from(connector, connector_list, head) {\r\nif (connector != from) {\r\nstruct drm_encoder *encoder = connector->encoder;\r\nstruct drm_crtc *crtc = encoder ? encoder->crtc : NULL;\r\nif (crtc && crtc->fb == fb) {\r\nreturn connector;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid omap_framebuffer_flush(struct drm_framebuffer *fb,\r\nint x, int y, int w, int h)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nVERB("flush: %d,%d %dx%d, fb=%p", x, y, w, h, fb);\r\nwhile ((connector = omap_framebuffer_get_next_connector(fb, connector))) {\r\nif (connector->encoder && connector->encoder->crtc) {\r\nstruct drm_crtc *crtc = connector->encoder->crtc;\r\nint cx = max(0, x - crtc->x);\r\nint cy = max(0, y - crtc->y);\r\nint cw = w + (x - crtc->x) - cx;\r\nint ch = h + (y - crtc->y) - cy;\r\nomap_connector_flush(connector, cx, cy, cw, ch);\r\n}\r\n}\r\n}\r\nvoid omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint i, n = drm_format_num_planes(fb->pixel_format);\r\nseq_printf(m, "fb: %dx%d@%4.4s\n", fb->width, fb->height,\r\n(char *)&fb->pixel_format);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nseq_printf(m, " %d: offset=%d pitch=%d, obj: ",\r\ni, plane->offset, plane->pitch);\r\nomap_gem_describe(plane->bo, m);\r\n}\r\n}\r\nstruct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *bos[4];\r\nstruct drm_framebuffer *fb;\r\nint ret;\r\nret = objects_lookup(dev, file, mode_cmd->pixel_format,\r\nbos, mode_cmd->handles);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nfb = omap_framebuffer_init(dev, mode_cmd, bos);\r\nif (IS_ERR(fb)) {\r\nint i, n = drm_format_num_planes(mode_cmd->pixel_format);\r\nfor (i = 0; i < n; i++)\r\ndrm_gem_object_unreference_unlocked(bos[i]);\r\nreturn fb;\r\n}\r\nreturn fb;\r\n}\r\nstruct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,\r\nstruct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)\r\n{\r\nstruct omap_framebuffer *omap_fb;\r\nstruct drm_framebuffer *fb = NULL;\r\nconst struct format *format = NULL;\r\nint ret, i, n = drm_format_num_planes(mode_cmd->pixel_format);\r\nDBG("create framebuffer: dev=%p, mode_cmd=%p (%dx%d@%4.4s)",\r\ndev, mode_cmd, mode_cmd->width, mode_cmd->height,\r\n(char *)&mode_cmd->pixel_format);\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (formats[i].pixel_format == mode_cmd->pixel_format) {\r\nformat = &formats[i];\r\nbreak;\r\n}\r\n}\r\nif (!format) {\r\ndev_err(dev->dev, "unsupported pixel format: %4.4s\n",\r\n(char *)&mode_cmd->pixel_format);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nomap_fb = kzalloc(sizeof(*omap_fb), GFP_KERNEL);\r\nif (!omap_fb) {\r\ndev_err(dev->dev, "could not allocate fb\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfb = &omap_fb->base;\r\nret = drm_framebuffer_init(dev, fb, &omap_framebuffer_funcs);\r\nif (ret) {\r\ndev_err(dev->dev, "framebuffer init failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nDBG("create: FB ID: %d (%p)", fb->base.id, fb);\r\nomap_fb->format = format;\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nint size, pitch = mode_cmd->pitches[i];\r\nif (pitch < (mode_cmd->width * format->planes[i].stride_bpp)) {\r\ndev_err(dev->dev, "provided buffer pitch is too small! %d < %d\n",\r\npitch, mode_cmd->width * format->planes[i].stride_bpp);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nsize = pitch * mode_cmd->height / format->planes[i].sub_y;\r\nif (size > (bos[i]->size - mode_cmd->offsets[i])) {\r\ndev_err(dev->dev, "provided buffer object is too small! %d < %d\n",\r\nbos[i]->size - mode_cmd->offsets[i], size);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nplane->bo = bos[i];\r\nplane->offset = mode_cmd->offsets[i];\r\nplane->pitch = pitch;\r\nplane->paddr = 0;\r\n}\r\ndrm_helper_mode_fill_fb_struct(fb, mode_cmd);\r\nreturn fb;\r\nfail:\r\nif (fb) {\r\nomap_framebuffer_destroy(fb);\r\n}\r\nreturn ERR_PTR(ret);\r\n}
