static inline struct freezer *cgroup_freezer(\r\nstruct cgroup *cgroup)\r\n{\r\nreturn container_of(\r\ncgroup_subsys_state(cgroup, freezer_subsys_id),\r\nstruct freezer, css);\r\n}\r\nstatic inline struct freezer *task_freezer(struct task_struct *task)\r\n{\r\nreturn container_of(task_subsys_state(task, freezer_subsys_id),\r\nstruct freezer, css);\r\n}\r\nbool cgroup_freezing(struct task_struct *task)\r\n{\r\nenum freezer_state state;\r\nbool ret;\r\nrcu_read_lock();\r\nstate = task_freezer(task)->state;\r\nret = state == CGROUP_FREEZING || state == CGROUP_FROZEN;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic struct cgroup_subsys_state *freezer_create(struct cgroup *cgroup)\r\n{\r\nstruct freezer *freezer;\r\nfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\r\nif (!freezer)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&freezer->lock);\r\nfreezer->state = CGROUP_THAWED;\r\nreturn &freezer->css;\r\n}\r\nstatic void freezer_destroy(struct cgroup *cgroup)\r\n{\r\nstruct freezer *freezer = cgroup_freezer(cgroup);\r\nif (freezer->state != CGROUP_THAWED)\r\natomic_dec(&system_freezing_cnt);\r\nkfree(freezer);\r\n}\r\nstatic bool is_task_frozen_enough(struct task_struct *task)\r\n{\r\nreturn frozen(task) ||\r\n(task_is_stopped_or_traced(task) && freezing(task));\r\n}\r\nstatic int freezer_can_attach(struct cgroup *new_cgroup,\r\nstruct cgroup_taskset *tset)\r\n{\r\nstruct freezer *freezer;\r\nstruct task_struct *task;\r\ncgroup_taskset_for_each(task, new_cgroup, tset)\r\nif (cgroup_freezing(task))\r\nreturn -EBUSY;\r\nfreezer = cgroup_freezer(new_cgroup);\r\nif (freezer->state != CGROUP_THAWED)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void freezer_fork(struct task_struct *task)\r\n{\r\nstruct freezer *freezer;\r\nrcu_read_lock();\r\nfreezer = task_freezer(task);\r\nrcu_read_unlock();\r\nif (!freezer->css.cgroup->parent)\r\nreturn;\r\nspin_lock_irq(&freezer->lock);\r\nBUG_ON(freezer->state == CGROUP_FROZEN);\r\nif (freezer->state == CGROUP_FREEZING)\r\nfreeze_task(task);\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\nstatic void update_if_frozen(struct cgroup *cgroup,\r\nstruct freezer *freezer)\r\n{\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\nunsigned int nfrozen = 0, ntotal = 0;\r\nenum freezer_state old_state = freezer->state;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it))) {\r\nntotal++;\r\nif (freezing(task) && is_task_frozen_enough(task))\r\nnfrozen++;\r\n}\r\nif (old_state == CGROUP_THAWED) {\r\nBUG_ON(nfrozen > 0);\r\n} else if (old_state == CGROUP_FREEZING) {\r\nif (nfrozen == ntotal)\r\nfreezer->state = CGROUP_FROZEN;\r\n} else {\r\nBUG_ON(nfrozen != ntotal);\r\n}\r\ncgroup_iter_end(cgroup, &it);\r\n}\r\nstatic int freezer_read(struct cgroup *cgroup, struct cftype *cft,\r\nstruct seq_file *m)\r\n{\r\nstruct freezer *freezer;\r\nenum freezer_state state;\r\nif (!cgroup_lock_live_group(cgroup))\r\nreturn -ENODEV;\r\nfreezer = cgroup_freezer(cgroup);\r\nspin_lock_irq(&freezer->lock);\r\nstate = freezer->state;\r\nif (state == CGROUP_FREEZING) {\r\nupdate_if_frozen(cgroup, freezer);\r\nstate = freezer->state;\r\n}\r\nspin_unlock_irq(&freezer->lock);\r\ncgroup_unlock();\r\nseq_puts(m, freezer_state_strs[state]);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int try_to_freeze_cgroup(struct cgroup *cgroup, struct freezer *freezer)\r\n{\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\nunsigned int num_cant_freeze_now = 0;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it))) {\r\nif (!freeze_task(task))\r\ncontinue;\r\nif (is_task_frozen_enough(task))\r\ncontinue;\r\nif (!freezing(task) && !freezer_should_skip(task))\r\nnum_cant_freeze_now++;\r\n}\r\ncgroup_iter_end(cgroup, &it);\r\nreturn num_cant_freeze_now ? -EBUSY : 0;\r\n}\r\nstatic void unfreeze_cgroup(struct cgroup *cgroup, struct freezer *freezer)\r\n{\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it)))\r\n__thaw_task(task);\r\ncgroup_iter_end(cgroup, &it);\r\n}\r\nstatic int freezer_change_state(struct cgroup *cgroup,\r\nenum freezer_state goal_state)\r\n{\r\nstruct freezer *freezer;\r\nint retval = 0;\r\nfreezer = cgroup_freezer(cgroup);\r\nspin_lock_irq(&freezer->lock);\r\nupdate_if_frozen(cgroup, freezer);\r\nswitch (goal_state) {\r\ncase CGROUP_THAWED:\r\nif (freezer->state != CGROUP_THAWED)\r\natomic_dec(&system_freezing_cnt);\r\nfreezer->state = CGROUP_THAWED;\r\nunfreeze_cgroup(cgroup, freezer);\r\nbreak;\r\ncase CGROUP_FROZEN:\r\nif (freezer->state == CGROUP_THAWED)\r\natomic_inc(&system_freezing_cnt);\r\nfreezer->state = CGROUP_FREEZING;\r\nretval = try_to_freeze_cgroup(cgroup, freezer);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nspin_unlock_irq(&freezer->lock);\r\nreturn retval;\r\n}\r\nstatic int freezer_write(struct cgroup *cgroup,\r\nstruct cftype *cft,\r\nconst char *buffer)\r\n{\r\nint retval;\r\nenum freezer_state goal_state;\r\nif (strcmp(buffer, freezer_state_strs[CGROUP_THAWED]) == 0)\r\ngoal_state = CGROUP_THAWED;\r\nelse if (strcmp(buffer, freezer_state_strs[CGROUP_FROZEN]) == 0)\r\ngoal_state = CGROUP_FROZEN;\r\nelse\r\nreturn -EINVAL;\r\nif (!cgroup_lock_live_group(cgroup))\r\nreturn -ENODEV;\r\nretval = freezer_change_state(cgroup, goal_state);\r\ncgroup_unlock();\r\nreturn retval;\r\n}
