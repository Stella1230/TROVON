static void\r\nbfad_im_get_starget_port_id(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct bfad_im_port_s *im_port;\r\nstruct bfad_s *bfad;\r\nstruct bfad_itnim_s *itnim = NULL;\r\nu32 fc_id = -1;\r\nunsigned long flags;\r\nshost = dev_to_shost(starget->dev.parent);\r\nim_port = (struct bfad_im_port_s *) shost->hostdata[0];\r\nbfad = im_port->bfad;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nitnim = bfad_get_itnim(im_port, starget->id);\r\nif (itnim)\r\nfc_id = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\r\nfc_starget_port_id(starget) = fc_id;\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\n}\r\nstatic void\r\nbfad_im_get_starget_node_name(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct bfad_im_port_s *im_port;\r\nstruct bfad_s *bfad;\r\nstruct bfad_itnim_s *itnim = NULL;\r\nu64 node_name = 0;\r\nunsigned long flags;\r\nshost = dev_to_shost(starget->dev.parent);\r\nim_port = (struct bfad_im_port_s *) shost->hostdata[0];\r\nbfad = im_port->bfad;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nitnim = bfad_get_itnim(im_port, starget->id);\r\nif (itnim)\r\nnode_name = bfa_fcs_itnim_get_nwwn(&itnim->fcs_itnim);\r\nfc_starget_node_name(starget) = cpu_to_be64(node_name);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\n}\r\nstatic void\r\nbfad_im_get_starget_port_name(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct bfad_im_port_s *im_port;\r\nstruct bfad_s *bfad;\r\nstruct bfad_itnim_s *itnim = NULL;\r\nu64 port_name = 0;\r\nunsigned long flags;\r\nshost = dev_to_shost(starget->dev.parent);\r\nim_port = (struct bfad_im_port_s *) shost->hostdata[0];\r\nbfad = im_port->bfad;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nitnim = bfad_get_itnim(im_port, starget->id);\r\nif (itnim)\r\nport_name = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\r\nfc_starget_port_name(starget) = cpu_to_be64(port_name);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\n}\r\nstatic void\r\nbfad_im_get_host_port_id(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_port_s *port = im_port->port;\r\nfc_host_port_id(shost) =\r\nbfa_hton3b(bfa_fcs_lport_get_fcid(port->fcs_port));\r\n}\r\nstatic void\r\nbfad_im_get_host_port_type(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfa_lport_attr_s port_attr;\r\nbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\r\nswitch (port_attr.port_type) {\r\ncase BFA_PORT_TYPE_NPORT:\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\r\nbreak;\r\ncase BFA_PORT_TYPE_NLPORT:\r\nfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\r\nbreak;\r\ncase BFA_PORT_TYPE_P2P:\r\nfc_host_port_type(shost) = FC_PORTTYPE_PTP;\r\nbreak;\r\ncase BFA_PORT_TYPE_LPORT:\r\nfc_host_port_type(shost) = FC_PORTTYPE_LPORT;\r\nbreak;\r\ndefault:\r\nfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfad_im_get_host_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfa_port_attr_s attr;\r\nbfa_fcport_get_attr(&bfad->bfa, &attr);\r\nswitch (attr.port_state) {\r\ncase BFA_PORT_ST_LINKDOWN:\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nbreak;\r\ncase BFA_PORT_ST_LINKUP:\r\nfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\r\nbreak;\r\ncase BFA_PORT_ST_DISABLED:\r\ncase BFA_PORT_ST_STOPPED:\r\ncase BFA_PORT_ST_IOCDOWN:\r\ncase BFA_PORT_ST_IOCDIS:\r\nfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\r\nbreak;\r\ncase BFA_PORT_ST_UNINIT:\r\ncase BFA_PORT_ST_ENABLING_QWAIT:\r\ncase BFA_PORT_ST_ENABLING:\r\ncase BFA_PORT_ST_DISABLING_QWAIT:\r\ncase BFA_PORT_ST_DISABLING:\r\ndefault:\r\nfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfad_im_get_host_active_fc4s(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_port_s *port = im_port->port;\r\nmemset(fc_host_active_fc4s(shost), 0,\r\nsizeof(fc_host_active_fc4s(shost)));\r\nif (port->supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\r\nfc_host_active_fc4s(shost)[2] = 1;\r\nfc_host_active_fc4s(shost)[7] = 1;\r\n}\r\nstatic void\r\nbfad_im_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfa_port_attr_s attr;\r\nbfa_fcport_get_attr(&bfad->bfa, &attr);\r\nswitch (attr.speed) {\r\ncase BFA_PORT_SPEED_10GBPS:\r\nfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\r\nbreak;\r\ncase BFA_PORT_SPEED_16GBPS:\r\nfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\r\nbreak;\r\ncase BFA_PORT_SPEED_8GBPS:\r\nfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\r\nbreak;\r\ncase BFA_PORT_SPEED_4GBPS:\r\nfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\r\nbreak;\r\ncase BFA_PORT_SPEED_2GBPS:\r\nfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\r\nbreak;\r\ncase BFA_PORT_SPEED_1GBPS:\r\nfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\r\nbreak;\r\ndefault:\r\nfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfad_im_get_host_fabric_name(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_port_s *port = im_port->port;\r\nwwn_t fabric_nwwn = 0;\r\nfabric_nwwn = bfa_fcs_lport_get_fabric_name(port->fcs_port);\r\nfc_host_fabric_name(shost) = cpu_to_be64(fabric_nwwn);\r\n}\r\nstatic struct fc_host_statistics *\r\nbfad_im_get_stats(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfad_hal_comp fcomp;\r\nunion bfa_port_stats_u *fcstats;\r\nstruct fc_host_statistics *hstats;\r\nbfa_status_t rc;\r\nunsigned long flags;\r\nfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\r\nif (fcstats == NULL)\r\nreturn NULL;\r\nhstats = &bfad->link_stats;\r\ninit_completion(&fcomp.comp);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nmemset(hstats, 0, sizeof(struct fc_host_statistics));\r\nrc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\r\nfcstats, bfad_hcb_comp, &fcomp);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (rc != BFA_STATUS_OK)\r\nreturn NULL;\r\nwait_for_completion(&fcomp.comp);\r\nhstats->seconds_since_last_reset = fcstats->fc.secs_reset;\r\nhstats->tx_frames = fcstats->fc.tx_frames;\r\nhstats->tx_words = fcstats->fc.tx_words;\r\nhstats->rx_frames = fcstats->fc.rx_frames;\r\nhstats->rx_words = fcstats->fc.rx_words;\r\nhstats->lip_count = fcstats->fc.lip_count;\r\nhstats->nos_count = fcstats->fc.nos_count;\r\nhstats->error_frames = fcstats->fc.error_frames;\r\nhstats->dumped_frames = fcstats->fc.dropped_frames;\r\nhstats->link_failure_count = fcstats->fc.link_failures;\r\nhstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\r\nhstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\r\nhstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\r\nhstats->invalid_crc_count = fcstats->fc.invalid_crcs;\r\nkfree(fcstats);\r\nreturn hstats;\r\n}\r\nstatic void\r\nbfad_im_reset_stats(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfad_hal_comp fcomp;\r\nunsigned long flags;\r\nbfa_status_t rc;\r\ninit_completion(&fcomp.comp);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nrc = bfa_port_clear_stats(BFA_FCPORT(&bfad->bfa), bfad_hcb_comp,\r\n&fcomp);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (rc != BFA_STATUS_OK)\r\nreturn;\r\nwait_for_completion(&fcomp.comp);\r\nreturn;\r\n}\r\nstatic void\r\nbfad_im_get_rport_loss_tmo(struct fc_rport *rport)\r\n{\r\nstruct bfad_itnim_data_s *itnim_data = rport->dd_data;\r\nstruct bfad_itnim_s *itnim = itnim_data->itnim;\r\nstruct bfad_s *bfad = itnim->im->bfad;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nrport->dev_loss_tmo = bfa_fcpim_path_tov_get(&bfad->bfa);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\n}\r\nstatic void\r\nbfad_im_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)\r\n{\r\nstruct bfad_itnim_data_s *itnim_data = rport->dd_data;\r\nstruct bfad_itnim_s *itnim = itnim_data->itnim;\r\nstruct bfad_s *bfad = itnim->im->bfad;\r\nunsigned long flags;\r\nif (timeout > 0) {\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nbfa_fcpim_path_tov_set(&bfad->bfa, timeout);\r\nrport->dev_loss_tmo = bfa_fcpim_path_tov_get(&bfad->bfa);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\n}\r\n}\r\nstatic int\r\nbfad_im_vport_create(struct fc_vport *fc_vport, bool disable)\r\n{\r\nchar *vname = fc_vport->symbolic_name;\r\nstruct Scsi_Host *shost = fc_vport->shost;\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfa_lport_cfg_s port_cfg;\r\nstruct bfad_vport_s *vp;\r\nint status = 0, rc;\r\nunsigned long flags;\r\nmemset(&port_cfg, 0, sizeof(port_cfg));\r\nu64_to_wwn(fc_vport->node_name, (u8 *)&port_cfg.nwwn);\r\nu64_to_wwn(fc_vport->port_name, (u8 *)&port_cfg.pwwn);\r\nif (strlen(vname) > 0)\r\nstrcpy((char *)&port_cfg.sym_name, vname);\r\nport_cfg.roles = BFA_LPORT_ROLE_FCP_IM;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nlist_for_each_entry(vp, &bfad->pbc_vport_list, list_entry) {\r\nif (port_cfg.pwwn ==\r\nvp->fcs_vport.lport.port_cfg.pwwn) {\r\nport_cfg.preboot_vp =\r\nvp->fcs_vport.lport.port_cfg.preboot_vp;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nrc = bfad_vport_create(bfad, 0, &port_cfg, &fc_vport->dev);\r\nif (rc == BFA_STATUS_OK) {\r\nstruct bfad_vport_s *vport;\r\nstruct bfa_fcs_vport_s *fcs_vport;\r\nstruct Scsi_Host *vshost;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0,\r\nport_cfg.pwwn);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (fcs_vport == NULL)\r\nreturn VPCERR_BAD_WWN;\r\nfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\r\nif (disable) {\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nbfa_fcs_vport_stop(fcs_vport);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\r\n}\r\nvport = fcs_vport->vport_drv;\r\nvshost = vport->drv_port.im_port->shost;\r\nfc_host_node_name(vshost) = wwn_to_u64((u8 *)&port_cfg.nwwn);\r\nfc_host_port_name(vshost) = wwn_to_u64((u8 *)&port_cfg.pwwn);\r\nfc_host_supported_classes(vshost) = FC_COS_CLASS3;\r\nmemset(fc_host_supported_fc4s(vshost), 0,\r\nsizeof(fc_host_supported_fc4s(vshost)));\r\nif (supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\r\nfc_host_supported_fc4s(vshost)[2] = 1;\r\nfc_host_supported_fc4s(vshost)[7] = 1;\r\nfc_host_supported_speeds(vshost) =\r\nbfad_im_supported_speeds(&bfad->bfa);\r\nfc_host_maxframe_size(vshost) =\r\nbfa_fcport_get_maxfrsize(&bfad->bfa);\r\nfc_vport->dd_data = vport;\r\nvport->drv_port.im_port->fc_vport = fc_vport;\r\n} else if (rc == BFA_STATUS_INVALID_WWN)\r\nreturn VPCERR_BAD_WWN;\r\nelse if (rc == BFA_STATUS_VPORT_EXISTS)\r\nreturn VPCERR_BAD_WWN;\r\nelse if (rc == BFA_STATUS_VPORT_MAX)\r\nreturn VPCERR_NO_FABRIC_SUPP;\r\nelse if (rc == BFA_STATUS_VPORT_WWN_BP)\r\nreturn VPCERR_BAD_WWN;\r\nelse\r\nreturn FC_VPORT_FAILED;\r\nreturn status;\r\n}\r\nint\r\nbfad_im_issue_fc_host_lip(struct Scsi_Host *shost)\r\n{\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfad_hal_comp fcomp;\r\nunsigned long flags;\r\nuint32_t status;\r\ninit_completion(&fcomp.comp);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nstatus = bfa_port_disable(&bfad->bfa.modules.port,\r\nbfad_hcb_comp, &fcomp);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (status != BFA_STATUS_OK)\r\nreturn -EIO;\r\nwait_for_completion(&fcomp.comp);\r\nif (fcomp.status != BFA_STATUS_OK)\r\nreturn -EIO;\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nstatus = bfa_port_enable(&bfad->bfa.modules.port,\r\nbfad_hcb_comp, &fcomp);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (status != BFA_STATUS_OK)\r\nreturn -EIO;\r\nwait_for_completion(&fcomp.comp);\r\nif (fcomp.status != BFA_STATUS_OK)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nbfad_im_vport_delete(struct fc_vport *fc_vport)\r\n{\r\nstruct bfad_vport_s *vport = (struct bfad_vport_s *)fc_vport->dd_data;\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) vport->drv_port.im_port;\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfad_port_s *port;\r\nstruct bfa_fcs_vport_s *fcs_vport;\r\nstruct Scsi_Host *vshost;\r\nwwn_t pwwn;\r\nint rc;\r\nunsigned long flags;\r\nstruct completion fcomp;\r\nif (im_port->flags & BFAD_PORT_DELETE) {\r\nbfad_scsi_host_free(bfad, im_port);\r\nlist_del(&vport->list_entry);\r\nkfree(vport);\r\nreturn 0;\r\n}\r\nport = im_port->port;\r\nvshost = vport->drv_port.im_port->shost;\r\nu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (fcs_vport == NULL)\r\nreturn VPCERR_BAD_WWN;\r\nvport->drv_port.flags |= BFAD_PORT_DELETE;\r\nvport->comp_del = &fcomp;\r\ninit_completion(vport->comp_del);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nrc = bfa_fcs_vport_delete(&vport->fcs_vport);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (rc == BFA_STATUS_PBC) {\r\nvport->drv_port.flags &= ~BFAD_PORT_DELETE;\r\nvport->comp_del = NULL;\r\nreturn -1;\r\n}\r\nwait_for_completion(vport->comp_del);\r\nbfad_scsi_host_free(bfad, im_port);\r\nlist_del(&vport->list_entry);\r\nkfree(vport);\r\nreturn 0;\r\n}\r\nstatic int\r\nbfad_im_vport_disable(struct fc_vport *fc_vport, bool disable)\r\n{\r\nstruct bfad_vport_s *vport;\r\nstruct bfad_s *bfad;\r\nstruct bfa_fcs_vport_s *fcs_vport;\r\nstruct Scsi_Host *vshost;\r\nwwn_t pwwn;\r\nunsigned long flags;\r\nvport = (struct bfad_vport_s *)fc_vport->dd_data;\r\nbfad = vport->drv_port.bfad;\r\nvshost = vport->drv_port.im_port->shost;\r\nu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nif (fcs_vport == NULL)\r\nreturn VPCERR_BAD_WWN;\r\nif (disable) {\r\nbfa_fcs_vport_stop(fcs_vport);\r\nfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\r\n} else {\r\nbfa_fcs_vport_start(fcs_vport);\r\nfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nbfad_im_serial_num_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nchar serial_num[BFA_ADAPTER_SERIAL_NUM_LEN];\r\nbfa_get_adapter_serial_num(&bfad->bfa, serial_num);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", serial_num);\r\n}\r\nstatic ssize_t\r\nbfad_im_model_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nchar model[BFA_ADAPTER_MODEL_NAME_LEN];\r\nbfa_get_adapter_model(&bfad->bfa, model);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", model);\r\n}\r\nstatic ssize_t\r\nbfad_im_model_desc_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nchar model[BFA_ADAPTER_MODEL_NAME_LEN];\r\nchar model_descr[BFA_ADAPTER_MODEL_DESCR_LEN];\r\nint nports = 0;\r\nbfa_get_adapter_model(&bfad->bfa, model);\r\nnports = bfa_get_nports(&bfad->bfa);\r\nif (!strcmp(model, "Brocade-425"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 4Gbps PCIe dual port FC HBA");\r\nelse if (!strcmp(model, "Brocade-825"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 8Gbps PCIe dual port FC HBA");\r\nelse if (!strcmp(model, "Brocade-42B"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 4Gbps PCIe dual port FC HBA for HP");\r\nelse if (!strcmp(model, "Brocade-82B"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 8Gbps PCIe dual port FC HBA for HP");\r\nelse if (!strcmp(model, "Brocade-1010"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 10Gbps single port CNA");\r\nelse if (!strcmp(model, "Brocade-1020"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 10Gbps dual port CNA");\r\nelse if (!strcmp(model, "Brocade-1007"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 10Gbps CNA for IBM Blade Center");\r\nelse if (!strcmp(model, "Brocade-415"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 4Gbps PCIe single port FC HBA");\r\nelse if (!strcmp(model, "Brocade-815"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 8Gbps PCIe single port FC HBA");\r\nelse if (!strcmp(model, "Brocade-41B"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 4Gbps PCIe single port FC HBA for HP");\r\nelse if (!strcmp(model, "Brocade-81B"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 8Gbps PCIe single port FC HBA for HP");\r\nelse if (!strcmp(model, "Brocade-804"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 8Gbps FC HBA for HP Bladesystem C-class");\r\nelse if (!strcmp(model, "Brocade-1741"))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 10Gbps CNA for Dell M-Series Blade Servers");\r\nelse if (strstr(model, "Brocade-1860")) {\r\nif (nports == 1 && bfa_ioc_is_cna(&bfad->bfa.ioc))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 10Gbps single port CNA");\r\nelse if (nports == 1 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 16Gbps PCIe single port FC HBA");\r\nelse if (nports == 2 && bfa_ioc_is_cna(&bfad->bfa.ioc))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 10Gbps dual port CNA");\r\nelse if (nports == 2 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Brocade 16Gbps PCIe dual port FC HBA");\r\n} else\r\nsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\r\n"Invalid Model");\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", model_descr);\r\n}\r\nstatic ssize_t\r\nbfad_im_node_name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_port_s *port = im_port->port;\r\nu64 nwwn;\r\nnwwn = bfa_fcs_lport_get_nwwn(port->fcs_port);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%llx\n", cpu_to_be64(nwwn));\r\n}\r\nstatic ssize_t\r\nbfad_im_symbolic_name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nstruct bfa_lport_attr_s port_attr;\r\nchar symname[BFA_SYMNAME_MAXLEN];\r\nbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\r\nstrncpy(symname, port_attr.port_cfg.sym_name.symname,\r\nBFA_SYMNAME_MAXLEN);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", symname);\r\n}\r\nstatic ssize_t\r\nbfad_im_hw_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nchar hw_ver[BFA_VERSION_LEN];\r\nbfa_get_pci_chip_rev(&bfad->bfa, hw_ver);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", hw_ver);\r\n}\r\nstatic ssize_t\r\nbfad_im_drv_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", BFAD_DRIVER_VERSION);\r\n}\r\nstatic ssize_t\r\nbfad_im_optionrom_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nchar optrom_ver[BFA_VERSION_LEN];\r\nbfa_get_adapter_optrom_ver(&bfad->bfa, optrom_ver);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", optrom_ver);\r\n}\r\nstatic ssize_t\r\nbfad_im_fw_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nchar fw_ver[BFA_VERSION_LEN];\r\nbfa_get_adapter_fw_ver(&bfad->bfa, fw_ver);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", fw_ver);\r\n}\r\nstatic ssize_t\r\nbfad_im_num_of_ports_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_s *bfad = im_port->bfad;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nbfa_get_nports(&bfad->bfa));\r\n}\r\nstatic ssize_t\r\nbfad_im_drv_name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", BFAD_DRIVER_NAME);\r\n}\r\nstatic ssize_t\r\nbfad_im_num_of_discovered_ports_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct bfad_im_port_s *im_port =\r\n(struct bfad_im_port_s *) shost->hostdata[0];\r\nstruct bfad_port_s *port = im_port->port;\r\nstruct bfad_s *bfad = im_port->bfad;\r\nint nrports = 2048;\r\nwwn_t *rports = NULL;\r\nunsigned long flags;\r\nrports = kzalloc(sizeof(wwn_t) * nrports , GFP_ATOMIC);\r\nif (rports == NULL)\r\nreturn snprintf(buf, PAGE_SIZE, "Failed\n");\r\nspin_lock_irqsave(&bfad->bfad_lock, flags);\r\nbfa_fcs_lport_get_rports(port->fcs_port, rports, &nrports);\r\nspin_unlock_irqrestore(&bfad->bfad_lock, flags);\r\nkfree(rports);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", nrports);\r\n}
