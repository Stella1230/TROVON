void omap3isp_flush(struct isp_device *isp)\r\n{\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\r\n}\r\nstatic void isp_enable_interrupts(struct isp_device *isp)\r\n{\r\nstatic const u32 irq = IRQ0ENABLE_CSIA_IRQ\r\n| IRQ0ENABLE_CSIB_IRQ\r\n| IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ\r\n| IRQ0ENABLE_CCDC_LSC_DONE_IRQ\r\n| IRQ0ENABLE_CCDC_VD0_IRQ\r\n| IRQ0ENABLE_CCDC_VD1_IRQ\r\n| IRQ0ENABLE_HS_VS_IRQ\r\n| IRQ0ENABLE_HIST_DONE_IRQ\r\n| IRQ0ENABLE_H3A_AWB_DONE_IRQ\r\n| IRQ0ENABLE_H3A_AF_DONE_IRQ\r\n| IRQ0ENABLE_PRV_DONE_IRQ\r\n| IRQ0ENABLE_RSZ_DONE_IRQ;\r\nisp_reg_writel(isp, irq, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nisp_reg_writel(isp, irq, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);\r\n}\r\nstatic void isp_disable_interrupts(struct isp_device *isp)\r\n{\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);\r\n}\r\nstatic u32 isp_set_xclk(struct isp_device *isp, u32 xclk, u8 xclksel)\r\n{\r\nu32 divisor;\r\nu32 currentxclk;\r\nunsigned long mclk_hz;\r\nif (!omap3isp_get(isp))\r\nreturn 0;\r\nmclk_hz = clk_get_rate(isp->clock[ISP_CLK_CAM_MCLK]);\r\nif (xclk >= mclk_hz) {\r\ndivisor = ISPTCTRL_CTRL_DIV_BYPASS;\r\ncurrentxclk = mclk_hz;\r\n} else if (xclk >= 2) {\r\ndivisor = mclk_hz / xclk;\r\nif (divisor >= ISPTCTRL_CTRL_DIV_BYPASS)\r\ndivisor = ISPTCTRL_CTRL_DIV_BYPASS - 1;\r\ncurrentxclk = mclk_hz / divisor;\r\n} else {\r\ndivisor = xclk;\r\ncurrentxclk = 0;\r\n}\r\nswitch (xclksel) {\r\ncase ISP_XCLK_A:\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,\r\nISPTCTRL_CTRL_DIVA_MASK,\r\ndivisor << ISPTCTRL_CTRL_DIVA_SHIFT);\r\ndev_dbg(isp->dev, "isp_set_xclk(): cam_xclka set to %d Hz\n",\r\ncurrentxclk);\r\nbreak;\r\ncase ISP_XCLK_B:\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,\r\nISPTCTRL_CTRL_DIVB_MASK,\r\ndivisor << ISPTCTRL_CTRL_DIVB_SHIFT);\r\ndev_dbg(isp->dev, "isp_set_xclk(): cam_xclkb set to %d Hz\n",\r\ncurrentxclk);\r\nbreak;\r\ncase ISP_XCLK_NONE:\r\ndefault:\r\nomap3isp_put(isp);\r\ndev_dbg(isp->dev, "ISP_ERR: isp_set_xclk(): Invalid requested "\r\n"xclk. Must be 0 (A) or 1 (B).\n");\r\nreturn -EINVAL;\r\n}\r\nif (divisor >= 2 && isp->xclk_divisor[xclksel - 1] < 2)\r\nomap3isp_get(isp);\r\nelse if (divisor < 2 && isp->xclk_divisor[xclksel - 1] >= 2)\r\nomap3isp_put(isp);\r\nisp->xclk_divisor[xclksel - 1] = divisor;\r\nomap3isp_put(isp);\r\nreturn currentxclk;\r\n}\r\nstatic void isp_power_settings(struct isp_device *isp, int idle)\r\n{\r\nisp_reg_writel(isp,\r\n((idle ? ISP_SYSCONFIG_MIDLEMODE_SMARTSTANDBY :\r\nISP_SYSCONFIG_MIDLEMODE_FORCESTANDBY) <<\r\nISP_SYSCONFIG_MIDLEMODE_SHIFT) |\r\n((isp->revision == ISP_REVISION_15_0) ?\r\nISP_SYSCONFIG_AUTOIDLE : 0),\r\nOMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);\r\nif (isp->autoidle)\r\nisp_reg_writel(isp, ISPCTRL_SBL_AUTOIDLE, OMAP3_ISP_IOMEM_MAIN,\r\nISP_CTRL);\r\n}\r\nvoid omap3isp_configure_bridge(struct isp_device *isp,\r\nenum ccdc_input_entity input,\r\nconst struct isp_parallel_platform_data *pdata,\r\nunsigned int shift)\r\n{\r\nu32 ispctrl_val;\r\nispctrl_val = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\r\nispctrl_val &= ~ISPCTRL_SHIFT_MASK;\r\nispctrl_val &= ~ISPCTRL_PAR_CLK_POL_INV;\r\nispctrl_val &= ~ISPCTRL_PAR_SER_CLK_SEL_MASK;\r\nispctrl_val &= ~ISPCTRL_PAR_BRIDGE_MASK;\r\nswitch (input) {\r\ncase CCDC_INPUT_PARALLEL:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_PARALLEL;\r\nispctrl_val |= pdata->clk_pol << ISPCTRL_PAR_CLK_POL_SHIFT;\r\nispctrl_val |= pdata->bridge << ISPCTRL_PAR_BRIDGE_SHIFT;\r\nshift += pdata->data_lane_shift * 2;\r\nbreak;\r\ncase CCDC_INPUT_CSI2A:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIA;\r\nbreak;\r\ncase CCDC_INPUT_CCP2B:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIB;\r\nbreak;\r\ncase CCDC_INPUT_CSI2C:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIC;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nispctrl_val |= ((shift/2) << ISPCTRL_SHIFT_SHIFT) & ISPCTRL_SHIFT_MASK;\r\nispctrl_val &= ~ISPCTRL_SYNC_DETECT_MASK;\r\nispctrl_val |= ISPCTRL_SYNC_DETECT_VSRISE;\r\nisp_reg_writel(isp, ispctrl_val, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\r\n}\r\nvoid omap3isp_hist_dma_done(struct isp_device *isp)\r\n{\r\nif (omap3isp_ccdc_busy(&isp->isp_ccdc) ||\r\nomap3isp_stat_pcr_busy(&isp->isp_hist)) {\r\natomic_set(&isp->isp_hist.buf_err, 1);\r\ndev_dbg(isp->dev, "hist: Out of synchronization with "\r\n"CCDC. Ignoring next buffer.\n");\r\n}\r\n}\r\nstatic inline void isp_isr_dbg(struct isp_device *isp, u32 irqstatus)\r\n{\r\nstatic const char *name[] = {\r\n"CSIA_IRQ",\r\n"res1",\r\n"res2",\r\n"CSIB_LCM_IRQ",\r\n"CSIB_IRQ",\r\n"res5",\r\n"res6",\r\n"res7",\r\n"CCDC_VD0_IRQ",\r\n"CCDC_VD1_IRQ",\r\n"CCDC_VD2_IRQ",\r\n"CCDC_ERR_IRQ",\r\n"H3A_AF_DONE_IRQ",\r\n"H3A_AWB_DONE_IRQ",\r\n"res14",\r\n"res15",\r\n"HIST_DONE_IRQ",\r\n"CCDC_LSC_DONE",\r\n"CCDC_LSC_PREFETCH_COMPLETED",\r\n"CCDC_LSC_PREFETCH_ERROR",\r\n"PRV_DONE_IRQ",\r\n"CBUFF_IRQ",\r\n"res22",\r\n"res23",\r\n"RSZ_DONE_IRQ",\r\n"OVF_IRQ",\r\n"res26",\r\n"res27",\r\n"MMU_ERR_IRQ",\r\n"OCP_ERR_IRQ",\r\n"SEC_ERR_IRQ",\r\n"HS_VS_IRQ",\r\n};\r\nint i;\r\ndev_dbg(isp->dev, "ISP IRQ: ");\r\nfor (i = 0; i < ARRAY_SIZE(name); i++) {\r\nif ((1 << i) & irqstatus)\r\nprintk(KERN_CONT "%s ", name[i]);\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void isp_isr_sbl(struct isp_device *isp)\r\n{\r\nstruct device *dev = isp->dev;\r\nstruct isp_pipeline *pipe;\r\nu32 sbl_pcr;\r\nsbl_pcr = isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);\r\nisp_reg_writel(isp, sbl_pcr, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);\r\nsbl_pcr &= ~ISPSBL_PCR_CCDCPRV_2_RSZ_OVF;\r\nif (sbl_pcr)\r\ndev_dbg(dev, "SBL overflow (PCR = 0x%08x)\n", sbl_pcr);\r\nif (sbl_pcr & ISPSBL_PCR_CSIB_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_ccp2.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_CSIA_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_csi2a.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_CCDC_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_ccdc.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_PRV_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_prev.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & (ISPSBL_PCR_RSZ1_WBL_OVF\r\n| ISPSBL_PCR_RSZ2_WBL_OVF\r\n| ISPSBL_PCR_RSZ3_WBL_OVF\r\n| ISPSBL_PCR_RSZ4_WBL_OVF)) {\r\npipe = to_isp_pipeline(&isp->isp_res.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_H3A_AF_WBL_OVF)\r\nomap3isp_stat_sbl_overflow(&isp->isp_af);\r\nif (sbl_pcr & ISPSBL_PCR_H3A_AEAWB_WBL_OVF)\r\nomap3isp_stat_sbl_overflow(&isp->isp_aewb);\r\n}\r\nstatic irqreturn_t isp_isr(int irq, void *_isp)\r\n{\r\nstatic const u32 ccdc_events = IRQ0STATUS_CCDC_LSC_PREF_ERR_IRQ |\r\nIRQ0STATUS_CCDC_LSC_DONE_IRQ |\r\nIRQ0STATUS_CCDC_VD0_IRQ |\r\nIRQ0STATUS_CCDC_VD1_IRQ |\r\nIRQ0STATUS_HS_VS_IRQ;\r\nstruct isp_device *isp = _isp;\r\nu32 irqstatus;\r\nirqstatus = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nisp_reg_writel(isp, irqstatus, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nisp_isr_sbl(isp);\r\nif (irqstatus & IRQ0STATUS_CSIA_IRQ)\r\nomap3isp_csi2_isr(&isp->isp_csi2a);\r\nif (irqstatus & IRQ0STATUS_CSIB_IRQ)\r\nomap3isp_ccp2_isr(&isp->isp_ccp2);\r\nif (irqstatus & IRQ0STATUS_CCDC_VD0_IRQ) {\r\nif (isp->isp_ccdc.output & CCDC_OUTPUT_PREVIEW)\r\nomap3isp_preview_isr_frame_sync(&isp->isp_prev);\r\nif (isp->isp_ccdc.output & CCDC_OUTPUT_RESIZER)\r\nomap3isp_resizer_isr_frame_sync(&isp->isp_res);\r\nomap3isp_stat_isr_frame_sync(&isp->isp_aewb);\r\nomap3isp_stat_isr_frame_sync(&isp->isp_af);\r\nomap3isp_stat_isr_frame_sync(&isp->isp_hist);\r\n}\r\nif (irqstatus & ccdc_events)\r\nomap3isp_ccdc_isr(&isp->isp_ccdc, irqstatus & ccdc_events);\r\nif (irqstatus & IRQ0STATUS_PRV_DONE_IRQ) {\r\nif (isp->isp_prev.output & PREVIEW_OUTPUT_RESIZER)\r\nomap3isp_resizer_isr_frame_sync(&isp->isp_res);\r\nomap3isp_preview_isr(&isp->isp_prev);\r\n}\r\nif (irqstatus & IRQ0STATUS_RSZ_DONE_IRQ)\r\nomap3isp_resizer_isr(&isp->isp_res);\r\nif (irqstatus & IRQ0STATUS_H3A_AWB_DONE_IRQ)\r\nomap3isp_stat_isr(&isp->isp_aewb);\r\nif (irqstatus & IRQ0STATUS_H3A_AF_DONE_IRQ)\r\nomap3isp_stat_isr(&isp->isp_af);\r\nif (irqstatus & IRQ0STATUS_HIST_DONE_IRQ)\r\nomap3isp_stat_isr(&isp->isp_hist);\r\nomap3isp_flush(isp);\r\n#if defined(DEBUG) && defined(ISP_ISR_DEBUG)\r\nisp_isr_dbg(isp, irqstatus);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int isp_pipeline_pm_use_count(struct media_entity *entity)\r\n{\r\nstruct media_entity_graph graph;\r\nint use = 0;\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nif (media_entity_type(entity) == MEDIA_ENT_T_DEVNODE)\r\nuse += entity->use_count;\r\n}\r\nreturn use;\r\n}\r\nstatic int isp_pipeline_pm_power_one(struct media_entity *entity, int change)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\nsubdev = media_entity_type(entity) == MEDIA_ENT_T_V4L2_SUBDEV\r\n? media_entity_to_v4l2_subdev(entity) : NULL;\r\nif (entity->use_count == 0 && change > 0 && subdev != NULL) {\r\nret = v4l2_subdev_call(subdev, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\n}\r\nentity->use_count += change;\r\nWARN_ON(entity->use_count < 0);\r\nif (entity->use_count == 0 && change < 0 && subdev != NULL)\r\nv4l2_subdev_call(subdev, core, s_power, 0);\r\nreturn 0;\r\n}\r\nstatic int isp_pipeline_pm_power(struct media_entity *entity, int change)\r\n{\r\nstruct media_entity_graph graph;\r\nstruct media_entity *first = entity;\r\nint ret = 0;\r\nif (!change)\r\nreturn 0;\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile (!ret && (entity = media_entity_graph_walk_next(&graph)))\r\nif (media_entity_type(entity) != MEDIA_ENT_T_DEVNODE)\r\nret = isp_pipeline_pm_power_one(entity, change);\r\nif (!ret)\r\nreturn 0;\r\nmedia_entity_graph_walk_start(&graph, first);\r\nwhile ((first = media_entity_graph_walk_next(&graph))\r\n&& first != entity)\r\nif (media_entity_type(first) != MEDIA_ENT_T_DEVNODE)\r\nisp_pipeline_pm_power_one(first, -change);\r\nreturn ret;\r\n}\r\nint omap3isp_pipeline_pm_use(struct media_entity *entity, int use)\r\n{\r\nint change = use ? 1 : -1;\r\nint ret;\r\nmutex_lock(&entity->parent->graph_mutex);\r\nentity->use_count += change;\r\nWARN_ON(entity->use_count < 0);\r\nret = isp_pipeline_pm_power(entity, change);\r\nif (ret < 0)\r\nentity->use_count -= change;\r\nmutex_unlock(&entity->parent->graph_mutex);\r\nreturn ret;\r\n}\r\nstatic int isp_pipeline_link_notify(struct media_pad *source,\r\nstruct media_pad *sink, u32 flags)\r\n{\r\nint source_use = isp_pipeline_pm_use_count(source->entity);\r\nint sink_use = isp_pipeline_pm_use_count(sink->entity);\r\nint ret;\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nisp_pipeline_pm_power(source->entity, -sink_use);\r\nisp_pipeline_pm_power(sink->entity, -source_use);\r\nreturn 0;\r\n}\r\nret = isp_pipeline_pm_power(source->entity, sink_use);\r\nif (ret < 0)\r\nreturn ret;\r\nret = isp_pipeline_pm_power(sink->entity, source_use);\r\nif (ret < 0)\r\nisp_pipeline_pm_power(source->entity, -sink_use);\r\nreturn ret;\r\n}\r\nstatic int isp_pipeline_enable(struct isp_pipeline *pipe,\r\nenum isp_pipeline_stream_state mode)\r\n{\r\nstruct isp_device *isp = pipe->output->isp;\r\nstruct media_entity *entity;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *subdev;\r\nunsigned long flags;\r\nint ret;\r\nif ((pipe->entities & isp->crashed) &\r\n(1U << isp->isp_prev.subdev.entity.id))\r\nreturn -EIO;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~(ISP_PIPELINE_IDLE_INPUT | ISP_PIPELINE_IDLE_OUTPUT);\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\npipe->do_propagation = false;\r\nentity = &pipe->output->video.entity;\r\nwhile (1) {\r\npad = &entity->pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\npad = media_entity_remote_source(pad);\r\nif (pad == NULL ||\r\nmedia_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nbreak;\r\nentity = pad->entity;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nret = v4l2_subdev_call(subdev, video, s_stream, mode);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nif (subdev == &isp->isp_ccdc.subdev) {\r\nv4l2_subdev_call(&isp->isp_aewb.subdev, video,\r\ns_stream, mode);\r\nv4l2_subdev_call(&isp->isp_af.subdev, video,\r\ns_stream, mode);\r\nv4l2_subdev_call(&isp->isp_hist.subdev, video,\r\ns_stream, mode);\r\npipe->do_propagation = true;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int isp_pipeline_wait_resizer(struct isp_device *isp)\r\n{\r\nreturn omap3isp_resizer_busy(&isp->isp_res);\r\n}\r\nstatic int isp_pipeline_wait_preview(struct isp_device *isp)\r\n{\r\nreturn omap3isp_preview_busy(&isp->isp_prev);\r\n}\r\nstatic int isp_pipeline_wait_ccdc(struct isp_device *isp)\r\n{\r\nreturn omap3isp_stat_busy(&isp->isp_af)\r\n|| omap3isp_stat_busy(&isp->isp_aewb)\r\n|| omap3isp_stat_busy(&isp->isp_hist)\r\n|| omap3isp_ccdc_busy(&isp->isp_ccdc);\r\n}\r\nstatic int isp_pipeline_wait(struct isp_device *isp,\r\nint(*busy)(struct isp_device *isp))\r\n{\r\nunsigned long timeout = jiffies + ISP_STOP_TIMEOUT;\r\nwhile (!time_after(jiffies, timeout)) {\r\nif (!busy(isp))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int isp_pipeline_disable(struct isp_pipeline *pipe)\r\n{\r\nstruct isp_device *isp = pipe->output->isp;\r\nstruct media_entity *entity;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *subdev;\r\nint failure = 0;\r\nint ret;\r\nentity = &pipe->output->video.entity;\r\nwhile (1) {\r\npad = &entity->pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\npad = media_entity_remote_source(pad);\r\nif (pad == NULL ||\r\nmedia_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nbreak;\r\nentity = pad->entity;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nif (subdev == &isp->isp_ccdc.subdev) {\r\nv4l2_subdev_call(&isp->isp_aewb.subdev,\r\nvideo, s_stream, 0);\r\nv4l2_subdev_call(&isp->isp_af.subdev,\r\nvideo, s_stream, 0);\r\nv4l2_subdev_call(&isp->isp_hist.subdev,\r\nvideo, s_stream, 0);\r\n}\r\nv4l2_subdev_call(subdev, video, s_stream, 0);\r\nif (subdev == &isp->isp_res.subdev)\r\nret = isp_pipeline_wait(isp, isp_pipeline_wait_resizer);\r\nelse if (subdev == &isp->isp_prev.subdev)\r\nret = isp_pipeline_wait(isp, isp_pipeline_wait_preview);\r\nelse if (subdev == &isp->isp_ccdc.subdev)\r\nret = isp_pipeline_wait(isp, isp_pipeline_wait_ccdc);\r\nelse\r\nret = 0;\r\nif (ret) {\r\ndev_info(isp->dev, "Unable to stop %s\n", subdev->name);\r\nisp->crashed |= 1U << subdev->entity.id;\r\nfailure = -ETIMEDOUT;\r\n}\r\n}\r\nreturn failure;\r\n}\r\nint omap3isp_pipeline_set_stream(struct isp_pipeline *pipe,\r\nenum isp_pipeline_stream_state state)\r\n{\r\nint ret;\r\nif (state == ISP_PIPELINE_STREAM_STOPPED)\r\nret = isp_pipeline_disable(pipe);\r\nelse\r\nret = isp_pipeline_enable(pipe, state);\r\nif (ret == 0 || state == ISP_PIPELINE_STREAM_STOPPED)\r\npipe->stream_state = state;\r\nreturn ret;\r\n}\r\nstatic void isp_pipeline_resume(struct isp_pipeline *pipe)\r\n{\r\nint singleshot = pipe->stream_state == ISP_PIPELINE_STREAM_SINGLESHOT;\r\nomap3isp_video_resume(pipe->output, !singleshot);\r\nif (singleshot)\r\nomap3isp_video_resume(pipe->input, 0);\r\nisp_pipeline_enable(pipe, pipe->stream_state);\r\n}\r\nstatic void isp_pipeline_suspend(struct isp_pipeline *pipe)\r\n{\r\nisp_pipeline_disable(pipe);\r\n}\r\nstatic int isp_pipeline_is_last(struct media_entity *me)\r\n{\r\nstruct isp_pipeline *pipe;\r\nstruct media_pad *pad;\r\nif (!me->pipe)\r\nreturn 0;\r\npipe = to_isp_pipeline(me);\r\nif (pipe->stream_state == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\npad = media_entity_remote_source(&pipe->output->pad);\r\nreturn pad->entity == me;\r\n}\r\nstatic void isp_suspend_module_pipeline(struct media_entity *me)\r\n{\r\nif (isp_pipeline_is_last(me))\r\nisp_pipeline_suspend(to_isp_pipeline(me));\r\n}\r\nstatic void isp_resume_module_pipeline(struct media_entity *me)\r\n{\r\nif (isp_pipeline_is_last(me))\r\nisp_pipeline_resume(to_isp_pipeline(me));\r\n}\r\nstatic int isp_suspend_modules(struct isp_device *isp)\r\n{\r\nunsigned long timeout;\r\nomap3isp_stat_suspend(&isp->isp_aewb);\r\nomap3isp_stat_suspend(&isp->isp_af);\r\nomap3isp_stat_suspend(&isp->isp_hist);\r\nisp_suspend_module_pipeline(&isp->isp_res.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_prev.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_ccdc.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_csi2a.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_ccp2.subdev.entity);\r\ntimeout = jiffies + ISP_STOP_TIMEOUT;\r\nwhile (omap3isp_stat_busy(&isp->isp_af)\r\n|| omap3isp_stat_busy(&isp->isp_aewb)\r\n|| omap3isp_stat_busy(&isp->isp_hist)\r\n|| omap3isp_preview_busy(&isp->isp_prev)\r\n|| omap3isp_resizer_busy(&isp->isp_res)\r\n|| omap3isp_ccdc_busy(&isp->isp_ccdc)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_info(isp->dev, "can't stop modules.\n");\r\nreturn 1;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void isp_resume_modules(struct isp_device *isp)\r\n{\r\nomap3isp_stat_resume(&isp->isp_aewb);\r\nomap3isp_stat_resume(&isp->isp_af);\r\nomap3isp_stat_resume(&isp->isp_hist);\r\nisp_resume_module_pipeline(&isp->isp_res.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_prev.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_ccdc.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_csi2a.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_ccp2.subdev.entity);\r\n}\r\nstatic int isp_reset(struct isp_device *isp)\r\n{\r\nunsigned long timeout = 0;\r\nisp_reg_writel(isp,\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG)\r\n| ISP_SYSCONFIG_SOFTRESET,\r\nOMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);\r\nwhile (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,\r\nISP_SYSSTATUS) & 0x1)) {\r\nif (timeout++ > 10000) {\r\ndev_alert(isp->dev, "cannot reset ISP\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(1);\r\n}\r\nisp->crashed = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nisp_save_context(struct isp_device *isp, struct isp_reg *reg_list)\r\n{\r\nstruct isp_reg *next = reg_list;\r\nfor (; next->reg != ISP_TOK_TERM; next++)\r\nnext->val = isp_reg_readl(isp, next->mmio_range, next->reg);\r\n}\r\nstatic void\r\nisp_restore_context(struct isp_device *isp, struct isp_reg *reg_list)\r\n{\r\nstruct isp_reg *next = reg_list;\r\nfor (; next->reg != ISP_TOK_TERM; next++)\r\nisp_reg_writel(isp, next->val, next->mmio_range, next->reg);\r\n}\r\nstatic void isp_save_ctx(struct isp_device *isp)\r\n{\r\nisp_save_context(isp, isp_reg_list);\r\nomap_iommu_save_ctx(isp->dev);\r\n}\r\nstatic void isp_restore_ctx(struct isp_device *isp)\r\n{\r\nisp_restore_context(isp, isp_reg_list);\r\nomap_iommu_restore_ctx(isp->dev);\r\nomap3isp_ccdc_restore_context(isp);\r\nomap3isp_preview_restore_context(isp);\r\n}\r\nvoid omap3isp_sbl_enable(struct isp_device *isp, enum isp_sbl_resource res)\r\n{\r\nu32 sbl = 0;\r\nisp->sbl_resources |= res;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_CSI1_READ)\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTA;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_CCDC_LSC_READ)\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTB;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_CSI2C_WRITE)\r\nsbl |= ISPCTRL_SBL_SHARED_WPORTC;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_RESIZER_WRITE)\r\nsbl |= ISPCTRL_SBL_WR0_RAM_EN;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_WRITE)\r\nsbl |= ISPCTRL_SBL_WR1_RAM_EN;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_READ)\r\nsbl |= ISPCTRL_SBL_RD_RAM_EN;\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, sbl);\r\n}\r\nvoid omap3isp_sbl_disable(struct isp_device *isp, enum isp_sbl_resource res)\r\n{\r\nu32 sbl = 0;\r\nisp->sbl_resources &= ~res;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_CSI1_READ))\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTA;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_CCDC_LSC_READ))\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTB;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_CSI2C_WRITE))\r\nsbl |= ISPCTRL_SBL_SHARED_WPORTC;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_RESIZER_WRITE))\r\nsbl |= ISPCTRL_SBL_WR0_RAM_EN;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_WRITE))\r\nsbl |= ISPCTRL_SBL_WR1_RAM_EN;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_READ))\r\nsbl |= ISPCTRL_SBL_RD_RAM_EN;\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, sbl);\r\n}\r\nint omap3isp_module_sync_idle(struct media_entity *me, wait_queue_head_t *wait,\r\natomic_t *stopping)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(me);\r\nif (pipe->stream_state == ISP_PIPELINE_STREAM_STOPPED ||\r\n(pipe->stream_state == ISP_PIPELINE_STREAM_SINGLESHOT &&\r\n!isp_pipeline_ready(pipe)))\r\nreturn 0;\r\natomic_set(stopping, 1);\r\nsmp_mb();\r\nif (isp_pipeline_is_last(me)) {\r\nstruct isp_video *video = pipe->output;\r\nunsigned long flags;\r\nspin_lock_irqsave(&video->queue->irqlock, flags);\r\nif (video->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_UNDERRUN) {\r\nspin_unlock_irqrestore(&video->queue->irqlock, flags);\r\natomic_set(stopping, 0);\r\nsmp_mb();\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&video->queue->irqlock, flags);\r\nif (!wait_event_timeout(*wait, !atomic_read(stopping),\r\nmsecs_to_jiffies(1000))) {\r\natomic_set(stopping, 0);\r\nsmp_mb();\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint omap3isp_module_sync_is_stopping(wait_queue_head_t *wait,\r\natomic_t *stopping)\r\n{\r\nif (atomic_cmpxchg(stopping, 1, 0)) {\r\nwake_up(wait);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __isp_subclk_update(struct isp_device *isp)\r\n{\r\nu32 clk = 0;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_H3A)\r\nclk |= ISPCTRL_H3A_CLK_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_HIST)\r\nclk |= ISPCTRL_HIST_CLK_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_RESIZER)\r\nclk |= ISPCTRL_RSZ_CLK_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_CCDC)\r\nclk |= ISPCTRL_CCDC_CLK_EN | ISPCTRL_CCDC_RAM_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_PREVIEW)\r\nclk |= ISPCTRL_PREV_CLK_EN | ISPCTRL_PREV_RAM_EN;\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,\r\nISPCTRL_CLKS_MASK, clk);\r\n}\r\nvoid omap3isp_subclk_enable(struct isp_device *isp,\r\nenum isp_subclk_resource res)\r\n{\r\nisp->subclk_resources |= res;\r\n__isp_subclk_update(isp);\r\n}\r\nvoid omap3isp_subclk_disable(struct isp_device *isp,\r\nenum isp_subclk_resource res)\r\n{\r\nisp->subclk_resources &= ~res;\r\n__isp_subclk_update(isp);\r\n}\r\nstatic int isp_enable_clocks(struct isp_device *isp)\r\n{\r\nint r;\r\nunsigned long rate;\r\nint divisor;\r\nif (cpu_is_omap3630())\r\ndivisor = 1;\r\nelse\r\ndivisor = 2;\r\nr = clk_enable(isp->clock[ISP_CLK_CAM_ICK]);\r\nif (r) {\r\ndev_err(isp->dev, "clk_enable cam_ick failed\n");\r\ngoto out_clk_enable_ick;\r\n}\r\nr = clk_set_rate(isp->clock[ISP_CLK_DPLL4_M5_CK],\r\nCM_CAM_MCLK_HZ/divisor);\r\nif (r) {\r\ndev_err(isp->dev, "clk_set_rate for dpll4_m5_ck failed\n");\r\ngoto out_clk_enable_mclk;\r\n}\r\nr = clk_enable(isp->clock[ISP_CLK_CAM_MCLK]);\r\nif (r) {\r\ndev_err(isp->dev, "clk_enable cam_mclk failed\n");\r\ngoto out_clk_enable_mclk;\r\n}\r\nrate = clk_get_rate(isp->clock[ISP_CLK_CAM_MCLK]);\r\nif (rate != CM_CAM_MCLK_HZ)\r\ndev_warn(isp->dev, "unexpected cam_mclk rate:\n"\r\n" expected : %d\n"\r\n" actual : %ld\n", CM_CAM_MCLK_HZ, rate);\r\nr = clk_enable(isp->clock[ISP_CLK_CSI2_FCK]);\r\nif (r) {\r\ndev_err(isp->dev, "clk_enable csi2_fck failed\n");\r\ngoto out_clk_enable_csi2_fclk;\r\n}\r\nreturn 0;\r\nout_clk_enable_csi2_fclk:\r\nclk_disable(isp->clock[ISP_CLK_CAM_MCLK]);\r\nout_clk_enable_mclk:\r\nclk_disable(isp->clock[ISP_CLK_CAM_ICK]);\r\nout_clk_enable_ick:\r\nreturn r;\r\n}\r\nstatic void isp_disable_clocks(struct isp_device *isp)\r\n{\r\nclk_disable(isp->clock[ISP_CLK_CAM_ICK]);\r\nclk_disable(isp->clock[ISP_CLK_CAM_MCLK]);\r\nclk_disable(isp->clock[ISP_CLK_CSI2_FCK]);\r\n}\r\nstatic void isp_put_clocks(struct isp_device *isp)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(isp_clocks); ++i) {\r\nif (isp->clock[i]) {\r\nclk_put(isp->clock[i]);\r\nisp->clock[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int isp_get_clocks(struct isp_device *isp)\r\n{\r\nstruct clk *clk;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(isp_clocks); ++i) {\r\nclk = clk_get(isp->dev, isp_clocks[i]);\r\nif (IS_ERR(clk)) {\r\ndev_err(isp->dev, "clk_get %s failed\n", isp_clocks[i]);\r\nisp_put_clocks(isp);\r\nreturn PTR_ERR(clk);\r\n}\r\nisp->clock[i] = clk;\r\n}\r\nreturn 0;\r\n}\r\nstruct isp_device *omap3isp_get(struct isp_device *isp)\r\n{\r\nstruct isp_device *__isp = isp;\r\nif (isp == NULL)\r\nreturn NULL;\r\nmutex_lock(&isp->isp_mutex);\r\nif (isp->ref_count > 0)\r\ngoto out;\r\nif (isp_enable_clocks(isp) < 0) {\r\n__isp = NULL;\r\ngoto out;\r\n}\r\nif (isp->has_context)\r\nisp_restore_ctx(isp);\r\nelse\r\nisp->has_context = 1;\r\nisp_enable_interrupts(isp);\r\nout:\r\nif (__isp != NULL)\r\nisp->ref_count++;\r\nmutex_unlock(&isp->isp_mutex);\r\nreturn __isp;\r\n}\r\nvoid omap3isp_put(struct isp_device *isp)\r\n{\r\nif (isp == NULL)\r\nreturn;\r\nmutex_lock(&isp->isp_mutex);\r\nBUG_ON(isp->ref_count == 0);\r\nif (--isp->ref_count == 0) {\r\nisp_disable_interrupts(isp);\r\nif (isp->domain)\r\nisp_save_ctx(isp);\r\nif (isp->crashed)\r\nisp_reset(isp);\r\nisp_disable_clocks(isp);\r\n}\r\nmutex_unlock(&isp->isp_mutex);\r\n}\r\nvoid omap3isp_print_status(struct isp_device *isp)\r\n{\r\ndev_dbg(isp->dev, "-------------ISP Register dump--------------\n");\r\nISP_PRINT_REGISTER(isp, SYSCONFIG);\r\nISP_PRINT_REGISTER(isp, SYSSTATUS);\r\nISP_PRINT_REGISTER(isp, IRQ0ENABLE);\r\nISP_PRINT_REGISTER(isp, IRQ0STATUS);\r\nISP_PRINT_REGISTER(isp, TCTRL_GRESET_LENGTH);\r\nISP_PRINT_REGISTER(isp, TCTRL_PSTRB_REPLAY);\r\nISP_PRINT_REGISTER(isp, CTRL);\r\nISP_PRINT_REGISTER(isp, TCTRL_CTRL);\r\nISP_PRINT_REGISTER(isp, TCTRL_FRAME);\r\nISP_PRINT_REGISTER(isp, TCTRL_PSTRB_DELAY);\r\nISP_PRINT_REGISTER(isp, TCTRL_STRB_DELAY);\r\nISP_PRINT_REGISTER(isp, TCTRL_SHUT_DELAY);\r\nISP_PRINT_REGISTER(isp, TCTRL_PSTRB_LENGTH);\r\nISP_PRINT_REGISTER(isp, TCTRL_STRB_LENGTH);\r\nISP_PRINT_REGISTER(isp, TCTRL_SHUT_LENGTH);\r\nSBL_PRINT_REGISTER(isp, PCR);\r\nSBL_PRINT_REGISTER(isp, SDR_REQ_EXP);\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nstatic int isp_pm_prepare(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nint reset;\r\nWARN_ON(mutex_is_locked(&isp->isp_mutex));\r\nif (isp->ref_count == 0)\r\nreturn 0;\r\nreset = isp_suspend_modules(isp);\r\nisp_disable_interrupts(isp);\r\nisp_save_ctx(isp);\r\nif (reset)\r\nisp_reset(isp);\r\nreturn 0;\r\n}\r\nstatic int isp_pm_suspend(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nWARN_ON(mutex_is_locked(&isp->isp_mutex));\r\nif (isp->ref_count)\r\nisp_disable_clocks(isp);\r\nreturn 0;\r\n}\r\nstatic int isp_pm_resume(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nif (isp->ref_count == 0)\r\nreturn 0;\r\nreturn isp_enable_clocks(isp);\r\n}\r\nstatic void isp_pm_complete(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nif (isp->ref_count == 0)\r\nreturn;\r\nisp_restore_ctx(isp);\r\nisp_enable_interrupts(isp);\r\nisp_resume_modules(isp);\r\n}\r\nstatic void isp_unregister_entities(struct isp_device *isp)\r\n{\r\nomap3isp_csi2_unregister_entities(&isp->isp_csi2a);\r\nomap3isp_ccp2_unregister_entities(&isp->isp_ccp2);\r\nomap3isp_ccdc_unregister_entities(&isp->isp_ccdc);\r\nomap3isp_preview_unregister_entities(&isp->isp_prev);\r\nomap3isp_resizer_unregister_entities(&isp->isp_res);\r\nomap3isp_stat_unregister_entities(&isp->isp_aewb);\r\nomap3isp_stat_unregister_entities(&isp->isp_af);\r\nomap3isp_stat_unregister_entities(&isp->isp_hist);\r\nv4l2_device_unregister(&isp->v4l2_dev);\r\nmedia_device_unregister(&isp->media_dev);\r\n}\r\nstatic struct v4l2_subdev *\r\nisp_register_subdev_group(struct isp_device *isp,\r\nstruct isp_subdev_i2c_board_info *board_info)\r\n{\r\nstruct v4l2_subdev *sensor = NULL;\r\nunsigned int first;\r\nif (board_info->board_info == NULL)\r\nreturn NULL;\r\nfor (first = 1; board_info->board_info; ++board_info, first = 0) {\r\nstruct v4l2_subdev *subdev;\r\nstruct i2c_adapter *adapter;\r\nadapter = i2c_get_adapter(board_info->i2c_adapter_id);\r\nif (adapter == NULL) {\r\nprintk(KERN_ERR "%s: Unable to get I2C adapter %d for "\r\n"device %s\n", __func__,\r\nboard_info->i2c_adapter_id,\r\nboard_info->board_info->type);\r\ncontinue;\r\n}\r\nsubdev = v4l2_i2c_new_subdev_board(&isp->v4l2_dev, adapter,\r\nboard_info->board_info, NULL);\r\nif (subdev == NULL) {\r\nprintk(KERN_ERR "%s: Unable to register subdev %s\n",\r\n__func__, board_info->board_info->type);\r\ncontinue;\r\n}\r\nif (first)\r\nsensor = subdev;\r\n}\r\nreturn sensor;\r\n}\r\nstatic int isp_register_entities(struct isp_device *isp)\r\n{\r\nstruct isp_platform_data *pdata = isp->pdata;\r\nstruct isp_v4l2_subdevs_group *subdevs;\r\nint ret;\r\nisp->media_dev.dev = isp->dev;\r\nstrlcpy(isp->media_dev.model, "TI OMAP3 ISP",\r\nsizeof(isp->media_dev.model));\r\nisp->media_dev.hw_revision = isp->revision;\r\nisp->media_dev.link_notify = isp_pipeline_link_notify;\r\nret = media_device_register(&isp->media_dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: Media device registration failed (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nisp->v4l2_dev.mdev = &isp->media_dev;\r\nret = v4l2_device_register(isp->dev, &isp->v4l2_dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: V4L2 device registration failed (%d)\n",\r\n__func__, ret);\r\ngoto done;\r\n}\r\nret = omap3isp_ccp2_register_entities(&isp->isp_ccp2, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_csi2_register_entities(&isp->isp_csi2a, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_ccdc_register_entities(&isp->isp_ccdc, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_preview_register_entities(&isp->isp_prev,\r\n&isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_resizer_register_entities(&isp->isp_res, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_stat_register_entities(&isp->isp_aewb, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_stat_register_entities(&isp->isp_af, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_stat_register_entities(&isp->isp_hist, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nfor (subdevs = pdata->subdevs; subdevs && subdevs->subdevs; ++subdevs) {\r\nstruct v4l2_subdev *sensor;\r\nstruct media_entity *input;\r\nunsigned int flags;\r\nunsigned int pad;\r\nsensor = isp_register_subdev_group(isp, subdevs->subdevs);\r\nif (sensor == NULL)\r\ncontinue;\r\nsensor->host_priv = subdevs;\r\nswitch (subdevs->interface) {\r\ncase ISP_INTERFACE_PARALLEL:\r\ninput = &isp->isp_ccdc.subdev.entity;\r\npad = CCDC_PAD_SINK;\r\nflags = 0;\r\nbreak;\r\ncase ISP_INTERFACE_CSI2A_PHY2:\r\ninput = &isp->isp_csi2a.subdev.entity;\r\npad = CSI2_PAD_SINK;\r\nflags = MEDIA_LNK_FL_IMMUTABLE\r\n| MEDIA_LNK_FL_ENABLED;\r\nbreak;\r\ncase ISP_INTERFACE_CCP2B_PHY1:\r\ncase ISP_INTERFACE_CCP2B_PHY2:\r\ninput = &isp->isp_ccp2.subdev.entity;\r\npad = CCP2_PAD_SINK;\r\nflags = 0;\r\nbreak;\r\ncase ISP_INTERFACE_CSI2C_PHY1:\r\ninput = &isp->isp_csi2c.subdev.entity;\r\npad = CSI2_PAD_SINK;\r\nflags = MEDIA_LNK_FL_IMMUTABLE\r\n| MEDIA_LNK_FL_ENABLED;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: invalid interface type %u\n",\r\n__func__, subdevs->interface);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = media_entity_create_link(&sensor->entity, 0, input, pad,\r\nflags);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nret = v4l2_device_register_subdev_nodes(&isp->v4l2_dev);\r\ndone:\r\nif (ret < 0)\r\nisp_unregister_entities(isp);\r\nreturn ret;\r\n}\r\nstatic void isp_cleanup_modules(struct isp_device *isp)\r\n{\r\nomap3isp_h3a_aewb_cleanup(isp);\r\nomap3isp_h3a_af_cleanup(isp);\r\nomap3isp_hist_cleanup(isp);\r\nomap3isp_resizer_cleanup(isp);\r\nomap3isp_preview_cleanup(isp);\r\nomap3isp_ccdc_cleanup(isp);\r\nomap3isp_ccp2_cleanup(isp);\r\nomap3isp_csi2_cleanup(isp);\r\n}\r\nstatic int isp_initialize_modules(struct isp_device *isp)\r\n{\r\nint ret;\r\nret = omap3isp_csiphy_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CSI PHY initialization failed\n");\r\ngoto error_csiphy;\r\n}\r\nret = omap3isp_csi2_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CSI2 initialization failed\n");\r\ngoto error_csi2;\r\n}\r\nret = omap3isp_ccp2_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CCP2 initialization failed\n");\r\ngoto error_ccp2;\r\n}\r\nret = omap3isp_ccdc_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CCDC initialization failed\n");\r\ngoto error_ccdc;\r\n}\r\nret = omap3isp_preview_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "Preview initialization failed\n");\r\ngoto error_preview;\r\n}\r\nret = omap3isp_resizer_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "Resizer initialization failed\n");\r\ngoto error_resizer;\r\n}\r\nret = omap3isp_hist_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "Histogram initialization failed\n");\r\ngoto error_hist;\r\n}\r\nret = omap3isp_h3a_aewb_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "H3A AEWB initialization failed\n");\r\ngoto error_h3a_aewb;\r\n}\r\nret = omap3isp_h3a_af_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "H3A AF initialization failed\n");\r\ngoto error_h3a_af;\r\n}\r\nret = media_entity_create_link(\r\n&isp->isp_csi2a.subdev.entity, CSI2_PAD_SOURCE,\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccp2.subdev.entity, CCP2_PAD_SOURCE,\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_prev.subdev.entity, PREV_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_OF,\r\n&isp->isp_res.subdev.entity, RESZ_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_prev.subdev.entity, PREV_PAD_SOURCE,\r\n&isp->isp_res.subdev.entity, RESZ_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_aewb.subdev.entity, 0,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_af.subdev.entity, 0,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_hist.subdev.entity, 0,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (ret < 0)\r\ngoto error_link;\r\nreturn 0;\r\nerror_link:\r\nomap3isp_h3a_af_cleanup(isp);\r\nerror_h3a_af:\r\nomap3isp_h3a_aewb_cleanup(isp);\r\nerror_h3a_aewb:\r\nomap3isp_hist_cleanup(isp);\r\nerror_hist:\r\nomap3isp_resizer_cleanup(isp);\r\nerror_resizer:\r\nomap3isp_preview_cleanup(isp);\r\nerror_preview:\r\nomap3isp_ccdc_cleanup(isp);\r\nerror_ccdc:\r\nomap3isp_ccp2_cleanup(isp);\r\nerror_ccp2:\r\nomap3isp_csi2_cleanup(isp);\r\nerror_csi2:\r\nerror_csiphy:\r\nreturn ret;\r\n}\r\nstatic int __devexit isp_remove(struct platform_device *pdev)\r\n{\r\nstruct isp_device *isp = platform_get_drvdata(pdev);\r\nint i;\r\nisp_unregister_entities(isp);\r\nisp_cleanup_modules(isp);\r\nomap3isp_get(isp);\r\niommu_detach_device(isp->domain, &pdev->dev);\r\niommu_domain_free(isp->domain);\r\nisp->domain = NULL;\r\nomap3isp_put(isp);\r\nfree_irq(isp->irq_num, isp);\r\nisp_put_clocks(isp);\r\nfor (i = 0; i < OMAP3_ISP_IOMEM_LAST; i++) {\r\nif (isp->mmio_base[i]) {\r\niounmap(isp->mmio_base[i]);\r\nisp->mmio_base[i] = NULL;\r\n}\r\nif (isp->mmio_base_phys[i]) {\r\nrelease_mem_region(isp->mmio_base_phys[i],\r\nisp->mmio_size[i]);\r\nisp->mmio_base_phys[i] = 0;\r\n}\r\n}\r\nregulator_put(isp->isp_csiphy1.vdd);\r\nregulator_put(isp->isp_csiphy2.vdd);\r\nkfree(isp);\r\nreturn 0;\r\n}\r\nstatic int isp_map_mem_resource(struct platform_device *pdev,\r\nstruct isp_device *isp,\r\nenum isp_mem_resources res)\r\n{\r\nstruct resource *mem;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, res);\r\nif (!mem) {\r\ndev_err(isp->dev, "no mem resource?\n");\r\nreturn -ENODEV;\r\n}\r\nif (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {\r\ndev_err(isp->dev,\r\n"cannot reserve camera register I/O region\n");\r\nreturn -ENODEV;\r\n}\r\nisp->mmio_base_phys[res] = mem->start;\r\nisp->mmio_size[res] = resource_size(mem);\r\nisp->mmio_base[res] = ioremap_nocache(isp->mmio_base_phys[res],\r\nisp->mmio_size[res]);\r\nif (!isp->mmio_base[res]) {\r\ndev_err(isp->dev, "cannot map camera register I/O region\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit isp_probe(struct platform_device *pdev)\r\n{\r\nstruct isp_platform_data *pdata = pdev->dev.platform_data;\r\nstruct isp_device *isp;\r\nint ret;\r\nint i, m;\r\nif (pdata == NULL)\r\nreturn -EINVAL;\r\nisp = kzalloc(sizeof(*isp), GFP_KERNEL);\r\nif (!isp) {\r\ndev_err(&pdev->dev, "could not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nisp->autoidle = autoidle;\r\nisp->platform_cb.set_xclk = isp_set_xclk;\r\nmutex_init(&isp->isp_mutex);\r\nspin_lock_init(&isp->stat_lock);\r\nisp->dev = &pdev->dev;\r\nisp->pdata = pdata;\r\nisp->ref_count = 0;\r\nisp->raw_dmamask = DMA_BIT_MASK(32);\r\nisp->dev->dma_mask = &isp->raw_dmamask;\r\nisp->dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nplatform_set_drvdata(pdev, isp);\r\nisp->isp_csiphy1.vdd = regulator_get(&pdev->dev, "VDD_CSIPHY1");\r\nisp->isp_csiphy2.vdd = regulator_get(&pdev->dev, "VDD_CSIPHY2");\r\nret = isp_map_mem_resource(pdev, isp, OMAP3_ISP_IOMEM_MAIN);\r\nif (ret < 0)\r\ngoto error;\r\nret = isp_get_clocks(isp);\r\nif (ret < 0)\r\ngoto error;\r\nif (omap3isp_get(isp) == NULL)\r\ngoto error;\r\nret = isp_reset(isp);\r\nif (ret < 0)\r\ngoto error_isp;\r\nisp->revision = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\r\ndev_info(isp->dev, "Revision %d.%d found\n",\r\n(isp->revision & 0xf0) >> 4, isp->revision & 0x0f);\r\nfor (m = 0; m < ARRAY_SIZE(isp_res_maps); m++)\r\nif (isp->revision == isp_res_maps[m].isp_rev)\r\nbreak;\r\nif (m == ARRAY_SIZE(isp_res_maps)) {\r\ndev_err(isp->dev, "No resource map found for ISP rev %d.%d\n",\r\n(isp->revision & 0xf0) >> 4, isp->revision & 0xf);\r\nret = -ENODEV;\r\ngoto error_isp;\r\n}\r\nfor (i = 1; i < OMAP3_ISP_IOMEM_LAST; i++) {\r\nif (isp_res_maps[m].map & 1 << i) {\r\nret = isp_map_mem_resource(pdev, isp, i);\r\nif (ret)\r\ngoto error_isp;\r\n}\r\n}\r\nisp->domain = iommu_domain_alloc(pdev->dev.bus);\r\nif (!isp->domain) {\r\ndev_err(isp->dev, "can't alloc iommu domain\n");\r\nret = -ENOMEM;\r\ngoto error_isp;\r\n}\r\nret = iommu_attach_device(isp->domain, &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't attach iommu device: %d\n", ret);\r\ngoto free_domain;\r\n}\r\nisp->irq_num = platform_get_irq(pdev, 0);\r\nif (isp->irq_num <= 0) {\r\ndev_err(isp->dev, "No IRQ resource\n");\r\nret = -ENODEV;\r\ngoto detach_dev;\r\n}\r\nif (request_irq(isp->irq_num, isp_isr, IRQF_SHARED, "OMAP3 ISP", isp)) {\r\ndev_err(isp->dev, "Unable to request IRQ\n");\r\nret = -EINVAL;\r\ngoto detach_dev;\r\n}\r\nret = isp_initialize_modules(isp);\r\nif (ret < 0)\r\ngoto error_irq;\r\nret = isp_register_entities(isp);\r\nif (ret < 0)\r\ngoto error_modules;\r\nisp_power_settings(isp, 1);\r\nomap3isp_put(isp);\r\nreturn 0;\r\nerror_modules:\r\nisp_cleanup_modules(isp);\r\nerror_irq:\r\nfree_irq(isp->irq_num, isp);\r\ndetach_dev:\r\niommu_detach_device(isp->domain, &pdev->dev);\r\nfree_domain:\r\niommu_domain_free(isp->domain);\r\nerror_isp:\r\nomap3isp_put(isp);\r\nerror:\r\nisp_put_clocks(isp);\r\nfor (i = 0; i < OMAP3_ISP_IOMEM_LAST; i++) {\r\nif (isp->mmio_base[i]) {\r\niounmap(isp->mmio_base[i]);\r\nisp->mmio_base[i] = NULL;\r\n}\r\nif (isp->mmio_base_phys[i]) {\r\nrelease_mem_region(isp->mmio_base_phys[i],\r\nisp->mmio_size[i]);\r\nisp->mmio_base_phys[i] = 0;\r\n}\r\n}\r\nregulator_put(isp->isp_csiphy2.vdd);\r\nregulator_put(isp->isp_csiphy1.vdd);\r\nplatform_set_drvdata(pdev, NULL);\r\nmutex_destroy(&isp->isp_mutex);\r\nkfree(isp);\r\nreturn ret;\r\n}
