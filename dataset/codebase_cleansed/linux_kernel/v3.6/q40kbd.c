static irqreturn_t q40kbd_interrupt(int irq, void *dev_id)\r\n{\r\nstruct q40kbd *q40kbd = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&q40kbd->lock, flags);\r\nif (Q40_IRQ_KEYB_MASK & master_inb(INTERRUPT_REG))\r\nserio_interrupt(q40kbd->port, master_inb(KEYCODE_REG), 0);\r\nmaster_outb(-1, KEYBOARD_UNLOCK_REG);\r\nspin_unlock_irqrestore(&q40kbd->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void q40kbd_flush(struct q40kbd *q40kbd)\r\n{\r\nint maxread = 100;\r\nunsigned long flags;\r\nspin_lock_irqsave(&q40kbd->lock, flags);\r\nwhile (maxread-- && (Q40_IRQ_KEYB_MASK & master_inb(INTERRUPT_REG)))\r\nmaster_inb(KEYCODE_REG);\r\nspin_unlock_irqrestore(&q40kbd->lock, flags);\r\n}\r\nstatic void q40kbd_stop(void)\r\n{\r\nmaster_outb(0, KEY_IRQ_ENABLE_REG);\r\nmaster_outb(-1, KEYBOARD_UNLOCK_REG);\r\n}\r\nstatic int q40kbd_open(struct serio *port)\r\n{\r\nstruct q40kbd *q40kbd = port->port_data;\r\nq40kbd_flush(q40kbd);\r\nmaster_outb(-1, KEYBOARD_UNLOCK_REG);\r\nmaster_outb(1, KEY_IRQ_ENABLE_REG);\r\nreturn 0;\r\n}\r\nstatic void q40kbd_close(struct serio *port)\r\n{\r\nstruct q40kbd *q40kbd = port->port_data;\r\nq40kbd_stop();\r\nq40kbd_flush(q40kbd);\r\n}\r\nstatic int __devinit q40kbd_probe(struct platform_device *pdev)\r\n{\r\nstruct q40kbd *q40kbd;\r\nstruct serio *port;\r\nint error;\r\nq40kbd = kzalloc(sizeof(struct q40kbd), GFP_KERNEL);\r\nport = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!q40kbd || !port) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nq40kbd->port = port;\r\nspin_lock_init(&q40kbd->lock);\r\nport->id.type = SERIO_8042;\r\nport->open = q40kbd_open;\r\nport->close = q40kbd_close;\r\nport->port_data = q40kbd;\r\nport->dev.parent = &pdev->dev;\r\nstrlcpy(port->name, "Q40 Kbd Port", sizeof(port->name));\r\nstrlcpy(port->phys, "Q40", sizeof(port->phys));\r\nq40kbd_stop();\r\nerror = request_irq(Q40_IRQ_KEYBOARD, q40kbd_interrupt, 0,\r\nDRV_NAME, q40kbd);\r\nif (error) {\r\ndev_err(&pdev->dev, "Can't get irq %d.\n", Q40_IRQ_KEYBOARD);\r\ngoto err_free_mem;\r\n}\r\nserio_register_port(q40kbd->port);\r\nplatform_set_drvdata(pdev, q40kbd);\r\nprintk(KERN_INFO "serio: Q40 kbd registered\n");\r\nreturn 0;\r\nerr_free_mem:\r\nkfree(port);\r\nkfree(q40kbd);\r\nreturn error;\r\n}\r\nstatic int __devexit q40kbd_remove(struct platform_device *pdev)\r\n{\r\nstruct q40kbd *q40kbd = platform_get_drvdata(pdev);\r\nserio_unregister_port(q40kbd->port);\r\nfree_irq(Q40_IRQ_KEYBOARD, q40kbd);\r\nkfree(q40kbd);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init q40kbd_init(void)\r\n{\r\nreturn platform_driver_probe(&q40kbd_driver, q40kbd_probe);\r\n}\r\nstatic void __exit q40kbd_exit(void)\r\n{\r\nplatform_driver_unregister(&q40kbd_driver);\r\n}
