static void __ccwgroup_remove_symlinks(struct ccwgroup_device *gdev)\r\n{\r\nint i;\r\nchar str[8];\r\nfor (i = 0; i < gdev->count; i++) {\r\nsprintf(str, "cdev%d", i);\r\nsysfs_remove_link(&gdev->dev.kobj, str);\r\nsysfs_remove_link(&gdev->cdev[i]->dev.kobj, "group_device");\r\n}\r\n}\r\nstatic void __ccwgroup_remove_cdev_refs(struct ccwgroup_device *gdev)\r\n{\r\nstruct ccw_device *cdev;\r\nint i;\r\nfor (i = 0; i < gdev->count; i++) {\r\ncdev = gdev->cdev[i];\r\nif (!cdev)\r\ncontinue;\r\nspin_lock_irq(cdev->ccwlock);\r\ndev_set_drvdata(&cdev->dev, NULL);\r\nspin_unlock_irq(cdev->ccwlock);\r\ngdev->cdev[i] = NULL;\r\nput_device(&cdev->dev);\r\n}\r\n}\r\nstatic int ccwgroup_set_online(struct ccwgroup_device *gdev)\r\n{\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nint ret = 0;\r\nif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\r\nreturn -EAGAIN;\r\nif (gdev->state == CCWGROUP_ONLINE)\r\ngoto out;\r\nif (gdrv->set_online)\r\nret = gdrv->set_online(gdev);\r\nif (ret)\r\ngoto out;\r\ngdev->state = CCWGROUP_ONLINE;\r\nout:\r\natomic_set(&gdev->onoff, 0);\r\nreturn ret;\r\n}\r\nstatic int ccwgroup_set_offline(struct ccwgroup_device *gdev)\r\n{\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nint ret = 0;\r\nif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\r\nreturn -EAGAIN;\r\nif (gdev->state == CCWGROUP_OFFLINE)\r\ngoto out;\r\nif (gdrv->set_offline)\r\nret = gdrv->set_offline(gdev);\r\nif (ret)\r\ngoto out;\r\ngdev->state = CCWGROUP_OFFLINE;\r\nout:\r\natomic_set(&gdev->onoff, 0);\r\nreturn ret;\r\n}\r\nstatic ssize_t ccwgroup_online_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(dev->driver);\r\nunsigned long value;\r\nint ret;\r\nif (!dev->driver)\r\nreturn -EINVAL;\r\nif (!try_module_get(gdrv->driver.owner))\r\nreturn -EINVAL;\r\nret = strict_strtoul(buf, 0, &value);\r\nif (ret)\r\ngoto out;\r\nif (value == 1)\r\nret = ccwgroup_set_online(gdev);\r\nelse if (value == 0)\r\nret = ccwgroup_set_offline(gdev);\r\nelse\r\nret = -EINVAL;\r\nout:\r\nmodule_put(gdrv->driver.owner);\r\nreturn (ret == 0) ? count : ret;\r\n}\r\nstatic ssize_t ccwgroup_online_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nint online;\r\nonline = (gdev->state == CCWGROUP_ONLINE) ? 1 : 0;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", online);\r\n}\r\nstatic void ccwgroup_ungroup_callback(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nmutex_lock(&gdev->reg_mutex);\r\nif (device_is_registered(&gdev->dev)) {\r\n__ccwgroup_remove_symlinks(gdev);\r\ndevice_unregister(dev);\r\n__ccwgroup_remove_cdev_refs(gdev);\r\n}\r\nmutex_unlock(&gdev->reg_mutex);\r\n}\r\nstatic ssize_t ccwgroup_ungroup_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nint rc;\r\nif (atomic_cmpxchg(&gdev->onoff, 0, 1) != 0)\r\nreturn -EAGAIN;\r\nif (gdev->state != CCWGROUP_OFFLINE) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = device_schedule_callback(dev, ccwgroup_ungroup_callback);\r\nout:\r\nif (rc) {\r\nif (rc != -EAGAIN)\r\natomic_set(&gdev->onoff, 0);\r\nreturn rc;\r\n}\r\nreturn count;\r\n}\r\nstatic void ccwgroup_release(struct device *dev)\r\n{\r\nkfree(to_ccwgroupdev(dev));\r\n}\r\nstatic int __ccwgroup_create_symlinks(struct ccwgroup_device *gdev)\r\n{\r\nchar str[8];\r\nint i, rc;\r\nfor (i = 0; i < gdev->count; i++) {\r\nrc = sysfs_create_link(&gdev->cdev[i]->dev.kobj,\r\n&gdev->dev.kobj, "group_device");\r\nif (rc) {\r\nfor (--i; i >= 0; i--)\r\nsysfs_remove_link(&gdev->cdev[i]->dev.kobj,\r\n"group_device");\r\nreturn rc;\r\n}\r\n}\r\nfor (i = 0; i < gdev->count; i++) {\r\nsprintf(str, "cdev%d", i);\r\nrc = sysfs_create_link(&gdev->dev.kobj,\r\n&gdev->cdev[i]->dev.kobj, str);\r\nif (rc) {\r\nfor (--i; i >= 0; i--) {\r\nsprintf(str, "cdev%d", i);\r\nsysfs_remove_link(&gdev->dev.kobj, str);\r\n}\r\nfor (i = 0; i < gdev->count; i++)\r\nsysfs_remove_link(&gdev->cdev[i]->dev.kobj,\r\n"group_device");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __get_next_id(const char **buf, struct ccw_dev_id *id)\r\n{\r\nunsigned int cssid, ssid, devno;\r\nint ret = 0, len;\r\nchar *start, *end;\r\nstart = (char *)*buf;\r\nend = strchr(start, ',');\r\nif (!end) {\r\nend = strchr(start, '\n');\r\nif (end)\r\n*end = '\0';\r\nlen = strlen(start) + 1;\r\n} else {\r\nlen = end - start + 1;\r\nend++;\r\n}\r\nif (len <= CCW_BUS_ID_SIZE) {\r\nif (sscanf(start, "%2x.%1x.%04x", &cssid, &ssid, &devno) != 3)\r\nret = -EINVAL;\r\n} else\r\nret = -EINVAL;\r\nif (!ret) {\r\nid->ssid = ssid;\r\nid->devno = devno;\r\n}\r\n*buf = end;\r\nreturn ret;\r\n}\r\nint ccwgroup_create_dev(struct device *parent, struct ccwgroup_driver *gdrv,\r\nint num_devices, const char *buf)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nstruct ccw_dev_id dev_id;\r\nint rc, i;\r\ngdev = kzalloc(sizeof(*gdev) + num_devices * sizeof(gdev->cdev[0]),\r\nGFP_KERNEL);\r\nif (!gdev)\r\nreturn -ENOMEM;\r\natomic_set(&gdev->onoff, 0);\r\nmutex_init(&gdev->reg_mutex);\r\nmutex_lock(&gdev->reg_mutex);\r\ngdev->count = num_devices;\r\ngdev->dev.bus = &ccwgroup_bus_type;\r\ngdev->dev.parent = parent;\r\ngdev->dev.release = ccwgroup_release;\r\ndevice_initialize(&gdev->dev);\r\nfor (i = 0; i < num_devices && buf; i++) {\r\nrc = __get_next_id(&buf, &dev_id);\r\nif (rc != 0)\r\ngoto error;\r\ngdev->cdev[i] = get_ccwdev_by_dev_id(&dev_id);\r\nif (!gdev->cdev[i] || !gdev->cdev[i]->drv ||\r\ngdev->cdev[i]->drv != gdev->cdev[0]->drv ||\r\ngdev->cdev[i]->id.driver_info !=\r\ngdev->cdev[0]->id.driver_info) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nspin_lock_irq(gdev->cdev[i]->ccwlock);\r\nif (dev_get_drvdata(&gdev->cdev[i]->dev)) {\r\nspin_unlock_irq(gdev->cdev[i]->ccwlock);\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\ndev_set_drvdata(&gdev->cdev[i]->dev, gdev);\r\nspin_unlock_irq(gdev->cdev[i]->ccwlock);\r\n}\r\nif (i < num_devices) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nif (i == num_devices && strlen(buf) > 0) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\ndev_set_name(&gdev->dev, "%s", dev_name(&gdev->cdev[0]->dev));\r\ngdev->dev.groups = ccwgroup_attr_groups;\r\nif (gdrv) {\r\ngdev->dev.driver = &gdrv->driver;\r\nrc = gdrv->setup ? gdrv->setup(gdev) : 0;\r\nif (rc)\r\ngoto error;\r\n}\r\nrc = device_add(&gdev->dev);\r\nif (rc)\r\ngoto error;\r\nrc = __ccwgroup_create_symlinks(gdev);\r\nif (rc) {\r\ndevice_del(&gdev->dev);\r\ngoto error;\r\n}\r\nmutex_unlock(&gdev->reg_mutex);\r\nreturn 0;\r\nerror:\r\nfor (i = 0; i < num_devices; i++)\r\nif (gdev->cdev[i]) {\r\nspin_lock_irq(gdev->cdev[i]->ccwlock);\r\nif (dev_get_drvdata(&gdev->cdev[i]->dev) == gdev)\r\ndev_set_drvdata(&gdev->cdev[i]->dev, NULL);\r\nspin_unlock_irq(gdev->cdev[i]->ccwlock);\r\nput_device(&gdev->cdev[i]->dev);\r\ngdev->cdev[i] = NULL;\r\n}\r\nmutex_unlock(&gdev->reg_mutex);\r\nput_device(&gdev->dev);\r\nreturn rc;\r\n}\r\nstatic int ccwgroup_notifier(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct device *dev = data;\r\nif (action == BUS_NOTIFY_UNBIND_DRIVER)\r\ndevice_schedule_callback(dev, ccwgroup_ungroup_callback);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init init_ccwgroup(void)\r\n{\r\nint ret;\r\nret = bus_register(&ccwgroup_bus_type);\r\nif (ret)\r\nreturn ret;\r\nret = bus_register_notifier(&ccwgroup_bus_type, &ccwgroup_nb);\r\nif (ret)\r\nbus_unregister(&ccwgroup_bus_type);\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_ccwgroup(void)\r\n{\r\nbus_unregister_notifier(&ccwgroup_bus_type, &ccwgroup_nb);\r\nbus_unregister(&ccwgroup_bus_type);\r\n}\r\nstatic int ccwgroup_remove(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(dev->driver);\r\nif (!dev->driver)\r\nreturn 0;\r\nif (gdrv->remove)\r\ngdrv->remove(gdev);\r\nreturn 0;\r\n}\r\nstatic void ccwgroup_shutdown(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(dev->driver);\r\nif (!dev->driver)\r\nreturn;\r\nif (gdrv->shutdown)\r\ngdrv->shutdown(gdev);\r\n}\r\nstatic int ccwgroup_pm_prepare(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (atomic_read(&gdev->onoff))\r\nreturn -EAGAIN;\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->prepare ? gdrv->prepare(gdev) : 0;\r\n}\r\nstatic void ccwgroup_pm_complete(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(dev->driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn;\r\nif (gdrv->complete)\r\ngdrv->complete(gdev);\r\n}\r\nstatic int ccwgroup_pm_freeze(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->freeze ? gdrv->freeze(gdev) : 0;\r\n}\r\nstatic int ccwgroup_pm_thaw(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->thaw ? gdrv->thaw(gdev) : 0;\r\n}\r\nstatic int ccwgroup_pm_restore(struct device *dev)\r\n{\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nstruct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);\r\nif (!gdev->dev.driver || gdev->state != CCWGROUP_ONLINE)\r\nreturn 0;\r\nreturn gdrv->restore ? gdrv->restore(gdev) : 0;\r\n}\r\nint ccwgroup_driver_register(struct ccwgroup_driver *cdriver)\r\n{\r\ncdriver->driver.bus = &ccwgroup_bus_type;\r\nreturn driver_register(&cdriver->driver);\r\n}\r\nstatic int __ccwgroup_match_all(struct device *dev, void *data)\r\n{\r\nreturn 1;\r\n}\r\nvoid ccwgroup_driver_unregister(struct ccwgroup_driver *cdriver)\r\n{\r\nstruct device *dev;\r\nwhile ((dev = driver_find_device(&cdriver->driver, NULL, NULL,\r\n__ccwgroup_match_all))) {\r\nstruct ccwgroup_device *gdev = to_ccwgroupdev(dev);\r\nmutex_lock(&gdev->reg_mutex);\r\n__ccwgroup_remove_symlinks(gdev);\r\ndevice_unregister(dev);\r\n__ccwgroup_remove_cdev_refs(gdev);\r\nmutex_unlock(&gdev->reg_mutex);\r\nput_device(dev);\r\n}\r\ndriver_unregister(&cdriver->driver);\r\n}\r\nint ccwgroup_probe_ccwdev(struct ccw_device *cdev)\r\n{\r\nreturn 0;\r\n}\r\nvoid ccwgroup_remove_ccwdev(struct ccw_device *cdev)\r\n{\r\nstruct ccwgroup_device *gdev;\r\nccw_device_set_offline(cdev);\r\nspin_lock_irq(cdev->ccwlock);\r\ngdev = dev_get_drvdata(&cdev->dev);\r\nif (!gdev) {\r\nspin_unlock_irq(cdev->ccwlock);\r\nreturn;\r\n}\r\nget_device(&gdev->dev);\r\nspin_unlock_irq(cdev->ccwlock);\r\nmutex_lock(&gdev->reg_mutex);\r\nif (device_is_registered(&gdev->dev)) {\r\n__ccwgroup_remove_symlinks(gdev);\r\ndevice_unregister(&gdev->dev);\r\n__ccwgroup_remove_cdev_refs(gdev);\r\n}\r\nmutex_unlock(&gdev->reg_mutex);\r\nput_device(&gdev->dev);\r\n}
