unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_get_boot_target_req *req;\r\nunsigned int tag = 0;\r\nSE_DEBUG(DBG_LVL_8, "In bescsi_get_boot_target\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,\r\nsizeof(struct be_cmd_get_boot_target_resp));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_get_session_info(struct beiscsi_hba *phba,\r\nu32 boot_session_handle,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int tag = 0;\r\nstruct be_cmd_get_session_req *req;\r\nstruct be_cmd_get_session_resp *resp;\r\nstruct be_sge *sge;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_get_session_info\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nnonemb_cmd->size = sizeof(*resp);\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb = wrb_from_mccq(phba);\r\nsge = nonembedded_sgl(wrb);\r\nwrb->tag0 |= tag;\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_SESSION_GET_A_SESSION,\r\nsizeof(*resp));\r\nreq->session_handle = boot_session_handle;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_get_fw_config(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_fw_cfg *req = embedded_payload(wrb);\r\nint status = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_QUERY_FIRMWARE_CONFIG, sizeof(*req));\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_fw_cfg *pfw_cfg;\r\npfw_cfg = req;\r\nphba->fw_config.phys_port = pfw_cfg->phys_port;\r\nphba->fw_config.iscsi_icd_start =\r\npfw_cfg->ulp[0].icd_base;\r\nphba->fw_config.iscsi_icd_count =\r\npfw_cfg->ulp[0].icd_count;\r\nphba->fw_config.iscsi_cid_start =\r\npfw_cfg->ulp[0].sq_base;\r\nphba->fw_config.iscsi_cid_count =\r\npfw_cfg->ulp[0].sq_count;\r\nif (phba->fw_config.iscsi_cid_count > (BE2_MAX_SESSIONS / 2)) {\r\nSE_DEBUG(DBG_LVL_8,\r\n"FW reported MAX CXNS as %d\t"\r\n"Max Supported = %d.\n",\r\nphba->fw_config.iscsi_cid_count,\r\nBE2_MAX_SESSIONS);\r\nphba->fw_config.iscsi_cid_count = BE2_MAX_SESSIONS / 2;\r\n}\r\n} else {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed in mgmt_get_fw_config\n");\r\n}\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint mgmt_check_supported_fw(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_dma_mem nonemb_cmd;\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_mgmt_controller_attributes *req;\r\nstruct be_sge *sge = nonembedded_sgl(wrb);\r\nint status = 0;\r\nnonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,\r\nsizeof(struct be_mgmt_controller_attributes),\r\n&nonemb_cmd.dma);\r\nif (nonemb_cmd.va == NULL) {\r\nSE_DEBUG(DBG_LVL_1,\r\n"Failed to allocate memory for mgmt_check_supported_fw"\r\n"\n");\r\nreturn -ENOMEM;\r\n}\r\nnonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);\r\nreq = nonemb_cmd.va;\r\nmemset(req, 0, sizeof(*req));\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd.size);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;\r\nSE_DEBUG(DBG_LVL_8, "Firmware version of CMD: %s\n",\r\nresp->params.hba_attribs.flashrom_version_string);\r\nSE_DEBUG(DBG_LVL_8, "Firmware version is : %s\n",\r\nresp->params.hba_attribs.firmware_version_string);\r\nSE_DEBUG(DBG_LVL_8,\r\n"Developer Build, not performing version check...\n");\r\nphba->fw_config.iscsi_features =\r\nresp->params.hba_attribs.iscsi_features;\r\nSE_DEBUG(DBG_LVL_8, " phba->fw_config.iscsi_features = %d\n",\r\nphba->fw_config.iscsi_features);\r\n} else\r\nSE_DEBUG(DBG_LVL_1, " Failed in mgmt_check_supported_fw\n");\r\nspin_unlock(&ctrl->mbox_lock);\r\nif (nonemb_cmd.va)\r\npci_free_consistent(ctrl->pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn status;\r\n}\r\nunsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba,\r\nstruct bsg_job *job,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_cmd_resp_hdr *resp;\r\nstruct be_mcc_wrb *wrb = wrb_from_mccq(phba);\r\nstruct be_sge *mcc_sge = nonembedded_sgl(wrb);\r\nunsigned int tag = 0;\r\nstruct iscsi_bsg_request *bsg_req = job->request;\r\nstruct be_bsg_vendor_cmd *req = nonemb_cmd->va;\r\nunsigned short region, sector_size, sector, offset;\r\nnonemb_cmd->size = job->request_payload.payload_len;\r\nmemset(nonemb_cmd->va, 0, nonemb_cmd->size);\r\nresp = nonemb_cmd->va;\r\nregion = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nsector_size = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nsector = bsg_req->rqst_data.h_vendor.vendor_cmd[3];\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[4];\r\nreq->region = region;\r\nreq->sector = sector;\r\nreq->offset = offset;\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {\r\ncase BEISCSI_WRITE_FLASH:\r\noffset = sector * sector_size + offset;\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_WRITE_FLASH, sizeof(*req));\r\nsg_copy_to_buffer(job->request_payload.sg_list,\r\njob->request_payload.sg_cnt,\r\nnonemb_cmd->va + offset, job->request_len);\r\nbreak;\r\ncase BEISCSI_READ_FLASH:\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_READ_FLASH, sizeof(*req));\r\nbreak;\r\ndefault:\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Unsupported cmd = 0x%x\n\n", bsg_req->rqst_data.\r\nh_vendor.vendor_cmd[0]);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn -ENOSYS;\r\n}\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false,\r\njob->request_payload.sg_cnt);\r\nmcc_sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nmcc_sge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nmcc_sge->len = cpu_to_le32(nonemb_cmd->size);\r\nwrb->tag0 |= tag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_epfw_cleanup(struct beiscsi_hba *phba, unsigned short chute)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb = wrb_from_mccq(phba);\r\nstruct iscsi_cleanup_req *req = embedded_payload(wrb);\r\nint status = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));\r\nreq->chute = chute;\r\nreq->hdr_ring_id = cpu_to_le16(HWI_GET_DEF_HDRQ_ID(phba));\r\nreq->data_ring_id = cpu_to_le16(HWI_GET_DEF_BUFQ_ID(phba));\r\nstatus = be_mcc_notify_wait(phba);\r\nif (status)\r\nshost_printk(KERN_WARNING, phba->shost,\r\n" mgmt_epfw_cleanup , FAILED\n");\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nunsigned int mgmt_invalidate_icds(struct beiscsi_hba *phba,\r\nstruct invalidate_command_table *inv_tbl,\r\nunsigned int num_invalidate, unsigned int cid,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *sge;\r\nstruct invalidate_commands_params_in *req;\r\nunsigned int i, tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb = wrb_from_mccq(phba);\r\nsge = nonembedded_sgl(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_ERROR_RECOVERY_INVALIDATE_COMMANDS,\r\nsizeof(*req));\r\nreq->ref_handle = 0;\r\nreq->cleanup_type = CMD_ISCSI_COMMAND_INVALIDATE;\r\nfor (i = 0; i < num_invalidate; i++) {\r\nreq->table[i].icd = inv_tbl->icd;\r\nreq->table[i].cid = inv_tbl->cid;\r\nreq->icd_count++;\r\ninv_tbl++;\r\n}\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba,\r\nstruct beiscsi_endpoint *beiscsi_ep,\r\nunsigned short cid,\r\nunsigned short issue_reset,\r\nunsigned short savecfg_flag)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct iscsi_invalidate_connection_params_in *req;\r\nunsigned int tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nwrb->tag0 |= tag;\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_DRIVER_INVALIDATE_CONNECTION,\r\nsizeof(*req));\r\nreq->session_handle = beiscsi_ep->fw_handle;\r\nreq->cid = cid;\r\nif (issue_reset)\r\nreq->cleanup_type = CMD_ISCSI_CONNECTION_ISSUE_TCP_RST;\r\nelse\r\nreq->cleanup_type = CMD_ISCSI_CONNECTION_INVALIDATE;\r\nreq->save_cfg = savecfg_flag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_upload_connection(struct beiscsi_hba *phba,\r\nunsigned short cid, unsigned int upload_flag)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_upload_params_in *req;\r\nunsigned int tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_COMMON_TCP_UPLOAD,\r\nOPCODE_COMMON_TCP_UPLOAD, sizeof(*req));\r\nreq->id = (unsigned short)cid;\r\nreq->upload_type = (unsigned char)upload_flag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_open_connection(struct beiscsi_hba *phba,\r\nstruct sockaddr *dst_addr,\r\nstruct beiscsi_endpoint *beiscsi_ep,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct hwi_controller *phwi_ctrlr;\r\nstruct hwi_context_memory *phwi_context;\r\nstruct sockaddr_in *daddr_in = (struct sockaddr_in *)dst_addr;\r\nstruct sockaddr_in6 *daddr_in6 = (struct sockaddr_in6 *)dst_addr;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_connect_and_offload_in *req;\r\nunsigned short def_hdr_id;\r\nunsigned short def_data_id;\r\nstruct phys_addr template_address = { 0, 0 };\r\nstruct phys_addr *ptemplate_address;\r\nunsigned int tag = 0;\r\nunsigned int i;\r\nunsigned short cid = beiscsi_ep->ep_cid;\r\nstruct be_sge *sge;\r\nphwi_ctrlr = phba->phwi_ctrlr;\r\nphwi_context = phwi_ctrlr->phwi_ctxt;\r\ndef_hdr_id = (unsigned short)HWI_GET_DEF_HDRQ_ID(phba);\r\ndef_data_id = (unsigned short)HWI_GET_DEF_BUFQ_ID(phba);\r\nptemplate_address = &template_address;\r\nISCSI_GET_PDU_TEMPLATE_ADDRESS(phba, ptemplate_address);\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nsge = nonembedded_sgl(wrb);\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_TCP_CONNECT_AND_OFFLOAD,\r\nsizeof(*req));\r\nif (dst_addr->sa_family == PF_INET) {\r\n__be32 s_addr = daddr_in->sin_addr.s_addr;\r\nreq->ip_address.ip_type = BE2_IPV4;\r\nreq->ip_address.addr[0] = s_addr & 0x000000ff;\r\nreq->ip_address.addr[1] = (s_addr & 0x0000ff00) >> 8;\r\nreq->ip_address.addr[2] = (s_addr & 0x00ff0000) >> 16;\r\nreq->ip_address.addr[3] = (s_addr & 0xff000000) >> 24;\r\nreq->tcp_port = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->dst_addr = daddr_in->sin_addr.s_addr;\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->ip_type = BE2_IPV4;\r\n} else if (dst_addr->sa_family == PF_INET6) {\r\nreq->ip_address.ip_type = BE2_IPV6;\r\nmemcpy(&req->ip_address.addr,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nreq->tcp_port = ntohs(daddr_in6->sin6_port);\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in6->sin6_port);\r\nmemcpy(&beiscsi_ep->dst6_addr,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nbeiscsi_ep->ip_type = BE2_IPV6;\r\n} else{\r\nshost_printk(KERN_ERR, phba->shost, "unknown addr family %d\n",\r\ndst_addr->sa_family);\r\nspin_unlock(&ctrl->mbox_lock);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\nreturn -EINVAL;\r\n}\r\nreq->cid = cid;\r\ni = phba->nxt_cqid++;\r\nif (phba->nxt_cqid == phba->num_cpus)\r\nphba->nxt_cqid = 0;\r\nreq->cq_id = phwi_context->be_cq[i].id;\r\nSE_DEBUG(DBG_LVL_8, "i=%d cq_id=%d\n", i, req->cq_id);\r\nreq->defq_id = def_hdr_id;\r\nreq->hdr_ring_id = def_hdr_id;\r\nreq->data_ring_id = def_data_id;\r\nreq->do_offload = 1;\r\nreq->dataout_template_pa.lo = ptemplate_address->lo;\r\nreq->dataout_template_pa.hi = ptemplate_address->hi;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_cmd_get_all_if_id_req *req = embedded_payload(wrb);\r\nstruct be_cmd_get_all_if_id_req *pbe_allid = req;\r\nint status = 0;\r\nmemset(wrb, 0, sizeof(*wrb));\r\nspin_lock(&ctrl->mbox_lock);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_ALL_IF_ID,\r\nsizeof(*req));\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status)\r\nphba->interface_handle = pbe_allid->if_hndl_list[0];\r\nelse {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed in mgmt_get_all_if_id\n");\r\n}\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nstatic int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,\r\nstruct be_dma_mem *nonemb_cmd, void *resp_buf,\r\nint resp_buf_len)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb = wrb_from_mccq(phba);\r\nunsigned short status, extd_status;\r\nstruct be_sge *sge;\r\nunsigned int tag;\r\nint rc = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nrc = -ENOMEM;\r\ngoto free_cmd;\r\n}\r\nmemset(wrb, 0, sizeof(*wrb));\r\nwrb->tag0 |= tag;\r\nsge = nonembedded_sgl(wrb);\r\nbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nwait_event_interruptible(phba->ctrl.mcc_wait[tag],\r\nphba->ctrl.mcc_numtag[tag]);\r\nextd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;\r\nstatus = phba->ctrl.mcc_numtag[tag] & 0x000000FF;\r\nif (status || extd_status) {\r\nSE_DEBUG(DBG_LVL_1,\r\n"mgmt_exec_nonemb_cmd Failed status = %d"\r\n"extd_status = %d\n", status, extd_status);\r\nrc = -EIO;\r\ngoto free_tag;\r\n}\r\nif (resp_buf)\r\nmemcpy(resp_buf, nonemb_cmd->va, resp_buf_len);\r\nfree_tag:\r\nfree_mcc_tag(&phba->ctrl, tag);\r\nfree_cmd:\r\npci_free_consistent(ctrl->pdev, nonemb_cmd->size,\r\nnonemb_cmd->va, nonemb_cmd->dma);\r\nreturn rc;\r\n}\r\nstatic int mgmt_alloc_cmd_data(struct beiscsi_hba *phba, struct be_dma_mem *cmd,\r\nint iscsi_cmd, int size)\r\n{\r\ncmd->va = pci_alloc_consistent(phba->ctrl.pdev, size, &cmd->dma);\r\nif (!cmd->va) {\r\nSE_DEBUG(DBG_LVL_1, "Failed to allocate memory for if info\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd->va, 0, size);\r\ncmd->size = size;\r\nbe_cmd_hdr_prepare(cmd->va, CMD_SUBSYSTEM_ISCSI, iscsi_cmd, size);\r\nreturn 0;\r\n}\r\nstatic int\r\nmgmt_static_ip_modify(struct beiscsi_hba *phba,\r\nstruct be_cmd_get_if_info_resp *if_info,\r\nstruct iscsi_iface_param_info *ip_param,\r\nstruct iscsi_iface_param_info *subnet_param,\r\nuint32_t ip_action)\r\n{\r\nstruct be_cmd_set_ip_addr_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nuint32_t ip_type;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR,\r\nsizeof(*req));\r\nif (rc)\r\nreturn rc;\r\nip_type = (ip_param->param == ISCSI_NET_PARAM_IPV6_ADDR) ?\r\nBE2_IPV6 : BE2_IPV4 ;\r\nreq = nonemb_cmd.va;\r\nreq->ip_params.record_entry_count = 1;\r\nreq->ip_params.ip_record.action = ip_action;\r\nreq->ip_params.ip_record.interface_hndl =\r\nphba->interface_handle;\r\nreq->ip_params.ip_record.ip_addr.size_of_structure =\r\nsizeof(struct be_ip_addr_subnet_format);\r\nreq->ip_params.ip_record.ip_addr.ip_type = ip_type;\r\nif (ip_action == IP_ACTION_ADD) {\r\nmemcpy(req->ip_params.ip_record.ip_addr.addr, ip_param->value,\r\nip_param->len);\r\nif (subnet_param)\r\nmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\r\nsubnet_param->value, subnet_param->len);\r\n} else {\r\nmemcpy(req->ip_params.ip_record.ip_addr.addr,\r\nif_info->ip_addr.addr, ip_param->len);\r\nmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\r\nif_info->ip_addr.subnet_mask, ip_param->len);\r\n}\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nif (rc < 0)\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed to Modify existing IP Address\n");\r\nreturn rc;\r\n}\r\nstatic int mgmt_modify_gateway(struct beiscsi_hba *phba, uint8_t *gt_addr,\r\nuint32_t gtway_action, uint32_t param_len)\r\n{\r\nstruct be_cmd_set_def_gateway_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rt_val;\r\nrt_val = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_MODIFY_DEFAULT_GATEWAY,\r\nsizeof(*req));\r\nif (rt_val)\r\nreturn rt_val;\r\nreq = nonemb_cmd.va;\r\nreq->action = gtway_action;\r\nreq->ip_addr.ip_type = BE2_IPV4;\r\nmemcpy(req->ip_addr.addr, gt_addr, param_len);\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\n}\r\nint mgmt_set_ip(struct beiscsi_hba *phba,\r\nstruct iscsi_iface_param_info *ip_param,\r\nstruct iscsi_iface_param_info *subnet_param,\r\nuint32_t boot_proto)\r\n{\r\nstruct be_cmd_get_def_gateway_resp gtway_addr_set;\r\nstruct be_cmd_get_if_info_resp if_info;\r\nstruct be_cmd_set_dhcp_req *dhcpreq;\r\nstruct be_cmd_rel_dhcp_req *reldhcp;\r\nstruct be_dma_mem nonemb_cmd;\r\nuint8_t *gtway_addr;\r\nuint32_t ip_type;\r\nint rc;\r\nif (mgmt_get_all_if_id(phba))\r\nreturn -EIO;\r\nmemset(&if_info, 0, sizeof(if_info));\r\nip_type = (ip_param->param == ISCSI_NET_PARAM_IPV6_ADDR) ?\r\nBE2_IPV6 : BE2_IPV4 ;\r\nrc = mgmt_get_if_info(phba, ip_type, &if_info);\r\nif (rc)\r\nreturn rc;\r\nif (boot_proto == ISCSI_BOOTPROTO_DHCP) {\r\nif (if_info.dhcp_state) {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"DHCP Already Enabled\n");\r\nreturn 0;\r\n}\r\nip_param->len = (ip_param->param == ISCSI_NET_PARAM_IPV6_ADDR) ?\r\nIP_V6_LEN : IP_V4_LEN;\r\n} else {\r\nif (if_info.dhcp_state) {\r\nmemset(&if_info, 0, sizeof(if_info));\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_REL_STATELESS_IP_ADDR,\r\nsizeof(*reldhcp));\r\nif (rc)\r\nreturn rc;\r\nreldhcp = nonemb_cmd.va;\r\nreldhcp->interface_hndl = phba->interface_handle;\r\nreldhcp->ip_type = ip_type;\r\nrc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\nif (rc < 0) {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed to Delete existing dhcp\n");\r\nreturn rc;\r\n}\r\n}\r\n}\r\nif (if_info.ip_addr.addr[0]) {\r\nrc = mgmt_static_ip_modify(phba, &if_info, ip_param, NULL,\r\nIP_ACTION_DEL);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (boot_proto == ISCSI_BOOTPROTO_DHCP) {\r\nmemset(&gtway_addr_set, 0, sizeof(gtway_addr_set));\r\nrc = mgmt_get_gateway(phba, BE2_IPV4, &gtway_addr_set);\r\nif (rc) {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed to Get Gateway Addr\n");\r\nreturn rc;\r\n}\r\nif (gtway_addr_set.ip_addr.addr[0]) {\r\ngtway_addr = (uint8_t *)&gtway_addr_set.ip_addr.addr;\r\nrc = mgmt_modify_gateway(phba, gtway_addr,\r\nIP_ACTION_DEL, IP_V4_LEN);\r\nif (rc) {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed to clear Gateway Addr Set\n");\r\nreturn rc;\r\n}\r\n}\r\n}\r\nif (boot_proto == ISCSI_BOOTPROTO_DHCP) {\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_CONFIG_STATELESS_IP_ADDR,\r\nsizeof(*dhcpreq));\r\nif (rc)\r\nreturn rc;\r\ndhcpreq = nonemb_cmd.va;\r\ndhcpreq->flags = BLOCKING;\r\ndhcpreq->retry_count = 1;\r\ndhcpreq->interface_hndl = phba->interface_handle;\r\ndhcpreq->ip_type = BE2_DHCP_V4;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);\r\n} else {\r\nreturn mgmt_static_ip_modify(phba, &if_info, ip_param,\r\nsubnet_param, IP_ACTION_ADD);\r\n}\r\nreturn rc;\r\n}\r\nint mgmt_set_gateway(struct beiscsi_hba *phba,\r\nstruct iscsi_iface_param_info *gateway_param)\r\n{\r\nstruct be_cmd_get_def_gateway_resp gtway_addr_set;\r\nuint8_t *gtway_addr;\r\nint rt_val;\r\nmemset(&gtway_addr_set, 0, sizeof(gtway_addr_set));\r\nrt_val = mgmt_get_gateway(phba, BE2_IPV4, &gtway_addr_set);\r\nif (rt_val) {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed to Get Gateway Addr\n");\r\nreturn rt_val;\r\n}\r\nif (gtway_addr_set.ip_addr.addr[0]) {\r\ngtway_addr = (uint8_t *)&gtway_addr_set.ip_addr.addr;\r\nrt_val = mgmt_modify_gateway(phba, gtway_addr, IP_ACTION_DEL,\r\ngateway_param->len);\r\nif (rt_val) {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed to clear Gateway Addr Set\n");\r\nreturn rt_val;\r\n}\r\n}\r\ngtway_addr = (uint8_t *)&gateway_param->value;\r\nrt_val = mgmt_modify_gateway(phba, gtway_addr, IP_ACTION_ADD,\r\ngateway_param->len);\r\nif (rt_val)\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed to Set Gateway Addr\n");\r\nreturn rt_val;\r\n}\r\nint mgmt_get_gateway(struct beiscsi_hba *phba, int ip_type,\r\nstruct be_cmd_get_def_gateway_resp *gateway)\r\n{\r\nstruct be_cmd_get_def_gateway_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_DEFAULT_GATEWAY,\r\nsizeof(*gateway));\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->ip_type = ip_type;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, gateway,\r\nsizeof(*gateway));\r\n}\r\nint mgmt_get_if_info(struct beiscsi_hba *phba, int ip_type,\r\nstruct be_cmd_get_if_info_resp *if_info)\r\n{\r\nstruct be_cmd_get_if_info_req *req;\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nif (mgmt_get_all_if_id(phba))\r\nreturn -EIO;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_IF_INFO,\r\nsizeof(*if_info));\r\nif (rc)\r\nreturn rc;\r\nreq = nonemb_cmd.va;\r\nreq->interface_hndl = phba->interface_handle;\r\nreq->ip_type = ip_type;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, if_info,\r\nsizeof(*if_info));\r\n}\r\nint mgmt_get_nic_conf(struct beiscsi_hba *phba,\r\nstruct be_cmd_get_nic_conf_resp *nic)\r\n{\r\nstruct be_dma_mem nonemb_cmd;\r\nint rc;\r\nrc = mgmt_alloc_cmd_data(phba, &nonemb_cmd,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG,\r\nsizeof(*nic));\r\nif (rc)\r\nreturn rc;\r\nreturn mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, nic, sizeof(*nic));\r\n}\r\nunsigned int be_cmd_get_initname(struct beiscsi_hba *phba)\r\n{\r\nunsigned int tag = 0;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_hba_name *req;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_CFG_GET_HBA_NAME,\r\nsizeof(*req));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int be_cmd_get_port_speed(struct beiscsi_hba *phba)\r\n{\r\nunsigned int tag = 0;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_ntwk_link_status_req *req;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_LINK_STATUS_QUERY,\r\nsizeof(*req));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}
