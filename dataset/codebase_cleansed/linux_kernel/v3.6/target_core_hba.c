int transport_subsystem_register(struct se_subsystem_api *sub_api)\r\n{\r\nstruct se_subsystem_api *s;\r\nINIT_LIST_HEAD(&sub_api->sub_api_list);\r\nmutex_lock(&subsystem_mutex);\r\nlist_for_each_entry(s, &subsystem_list, sub_api_list) {\r\nif (!strcmp(s->name, sub_api->name)) {\r\npr_err("%p is already registered with"\r\n" duplicate name %s, unable to process"\r\n" request\n", s, s->name);\r\nmutex_unlock(&subsystem_mutex);\r\nreturn -EEXIST;\r\n}\r\n}\r\nlist_add_tail(&sub_api->sub_api_list, &subsystem_list);\r\nmutex_unlock(&subsystem_mutex);\r\npr_debug("TCM: Registered subsystem plugin: %s struct module:"\r\n" %p\n", sub_api->name, sub_api->owner);\r\nreturn 0;\r\n}\r\nvoid transport_subsystem_release(struct se_subsystem_api *sub_api)\r\n{\r\nmutex_lock(&subsystem_mutex);\r\nlist_del(&sub_api->sub_api_list);\r\nmutex_unlock(&subsystem_mutex);\r\n}\r\nstatic struct se_subsystem_api *core_get_backend(const char *sub_name)\r\n{\r\nstruct se_subsystem_api *s;\r\nmutex_lock(&subsystem_mutex);\r\nlist_for_each_entry(s, &subsystem_list, sub_api_list) {\r\nif (!strcmp(s->name, sub_name))\r\ngoto found;\r\n}\r\nmutex_unlock(&subsystem_mutex);\r\nreturn NULL;\r\nfound:\r\nif (s->owner && !try_module_get(s->owner))\r\ns = NULL;\r\nmutex_unlock(&subsystem_mutex);\r\nreturn s;\r\n}\r\nstruct se_hba *\r\ncore_alloc_hba(const char *plugin_name, u32 plugin_dep_id, u32 hba_flags)\r\n{\r\nstruct se_hba *hba;\r\nint ret = 0;\r\nhba = kzalloc(sizeof(*hba), GFP_KERNEL);\r\nif (!hba) {\r\npr_err("Unable to allocate struct se_hba\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&hba->hba_dev_list);\r\nspin_lock_init(&hba->device_lock);\r\nmutex_init(&hba->hba_access_mutex);\r\nhba->hba_index = scsi_get_new_index(SCSI_INST_INDEX);\r\nhba->hba_flags |= hba_flags;\r\nhba->transport = core_get_backend(plugin_name);\r\nif (!hba->transport) {\r\nret = -EINVAL;\r\ngoto out_free_hba;\r\n}\r\nret = hba->transport->attach_hba(hba, plugin_dep_id);\r\nif (ret < 0)\r\ngoto out_module_put;\r\nspin_lock(&hba_lock);\r\nhba->hba_id = hba_id_counter++;\r\nlist_add_tail(&hba->hba_node, &hba_list);\r\nspin_unlock(&hba_lock);\r\npr_debug("CORE_HBA[%d] - Attached HBA to Generic Target"\r\n" Core\n", hba->hba_id);\r\nreturn hba;\r\nout_module_put:\r\nif (hba->transport->owner)\r\nmodule_put(hba->transport->owner);\r\nhba->transport = NULL;\r\nout_free_hba:\r\nkfree(hba);\r\nreturn ERR_PTR(ret);\r\n}\r\nint\r\ncore_delete_hba(struct se_hba *hba)\r\n{\r\nif (!list_empty(&hba->hba_dev_list))\r\ndump_stack();\r\nhba->transport->detach_hba(hba);\r\nspin_lock(&hba_lock);\r\nlist_del(&hba->hba_node);\r\nspin_unlock(&hba_lock);\r\npr_debug("CORE_HBA[%d] - Detached HBA from Generic Target"\r\n" Core\n", hba->hba_id);\r\nif (hba->transport->owner)\r\nmodule_put(hba->transport->owner);\r\nhba->transport = NULL;\r\nkfree(hba);\r\nreturn 0;\r\n}
