static void symbol_int_callback(struct urb *urb)\r\n{\r\nstruct symbol_private *priv = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct usb_serial_port *port = priv->port;\r\nint status = urb->status;\r\nstruct tty_struct *tty;\r\nint result;\r\nint data_length;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length,\r\ndata);\r\nif (urb->actual_length > 1) {\r\ndata_length = urb->actual_length - 1;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\ntty_insert_flip_string(tty, &data[1], data_length);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\n} else {\r\ndev_dbg(&priv->udev->dev,\r\n"Improper amount of data received from the device, "\r\n"%d bytes", urb->actual_length);\r\n}\r\nexit:\r\nspin_lock(&priv->lock);\r\nif (!priv->throttled) {\r\nusb_fill_int_urb(priv->int_urb, priv->udev,\r\nusb_rcvintpipe(priv->udev,\r\npriv->int_address),\r\npriv->int_buffer, priv->buffer_size,\r\nsymbol_int_callback, priv, priv->bInterval);\r\nresult = usb_submit_urb(priv->int_urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed resubmitting read urb, error %d\n",\r\n__func__, result);\r\n} else\r\npriv->actually_throttled = true;\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int symbol_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct symbol_private *priv = usb_get_serial_data(port->serial);\r\nunsigned long flags;\r\nint result = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->throttled = false;\r\npriv->actually_throttled = false;\r\npriv->port = port;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nusb_fill_int_urb(priv->int_urb, priv->udev,\r\nusb_rcvintpipe(priv->udev, priv->int_address),\r\npriv->int_buffer, priv->buffer_size,\r\nsymbol_int_callback, priv, priv->bInterval);\r\nresult = usb_submit_urb(priv->int_urb, GFP_KERNEL);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed resubmitting read urb, error %d\n",\r\n__func__, result);\r\nreturn result;\r\n}\r\nstatic void symbol_close(struct usb_serial_port *port)\r\n{\r\nstruct symbol_private *priv = usb_get_serial_data(port->serial);\r\nusb_kill_urb(priv->int_urb);\r\n}\r\nstatic void symbol_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct symbol_private *priv = usb_get_serial_data(port->serial);\r\nspin_lock_irq(&priv->lock);\r\npriv->throttled = true;\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic void symbol_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct symbol_private *priv = usb_get_serial_data(port->serial);\r\nint result;\r\nbool was_throttled;\r\nspin_lock_irq(&priv->lock);\r\npriv->throttled = false;\r\nwas_throttled = priv->actually_throttled;\r\npriv->actually_throttled = false;\r\nspin_unlock_irq(&priv->lock);\r\nif (was_throttled) {\r\nresult = usb_submit_urb(priv->int_urb, GFP_KERNEL);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed submitting read urb, error %d\n",\r\n__func__, result);\r\n}\r\n}\r\nstatic int symbol_startup(struct usb_serial *serial)\r\n{\r\nstruct symbol_private *priv;\r\nstruct usb_host_interface *intf;\r\nint i;\r\nint retval = -ENOMEM;\r\nbool int_in_found = false;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&serial->dev->dev, "%s - Out of memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&priv->lock);\r\npriv->serial = serial;\r\npriv->port = serial->port[0];\r\npriv->udev = serial->dev;\r\nintf = serial->interface->altsetting;\r\nfor (i = 0; i < intf->desc.bNumEndpoints; ++i) {\r\nstruct usb_endpoint_descriptor *endpoint;\r\nendpoint = &intf->endpoint[i].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\ncontinue;\r\npriv->int_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!priv->int_urb) {\r\ndev_err(&priv->udev->dev, "out of memory\n");\r\ngoto error;\r\n}\r\npriv->buffer_size = usb_endpoint_maxp(endpoint) * 2;\r\npriv->int_buffer = kmalloc(priv->buffer_size, GFP_KERNEL);\r\nif (!priv->int_buffer) {\r\ndev_err(&priv->udev->dev, "out of memory\n");\r\ngoto error;\r\n}\r\npriv->int_address = endpoint->bEndpointAddress;\r\npriv->bInterval = endpoint->bInterval;\r\nusb_fill_int_urb(priv->int_urb, priv->udev,\r\nusb_rcvintpipe(priv->udev,\r\nendpoint->bEndpointAddress),\r\npriv->int_buffer, priv->buffer_size,\r\nsymbol_int_callback, priv, priv->bInterval);\r\nint_in_found = true;\r\nbreak;\r\n}\r\nif (!int_in_found) {\r\ndev_err(&priv->udev->dev,\r\n"Error - the proper endpoints were not found!\n");\r\ngoto error;\r\n}\r\nusb_set_serial_data(serial, priv);\r\nreturn 0;\r\nerror:\r\nusb_free_urb(priv->int_urb);\r\nkfree(priv->int_buffer);\r\nkfree(priv);\r\nreturn retval;\r\n}\r\nstatic void symbol_disconnect(struct usb_serial *serial)\r\n{\r\nstruct symbol_private *priv = usb_get_serial_data(serial);\r\nusb_kill_urb(priv->int_urb);\r\nusb_free_urb(priv->int_urb);\r\n}\r\nstatic void symbol_release(struct usb_serial *serial)\r\n{\r\nstruct symbol_private *priv = usb_get_serial_data(serial);\r\nkfree(priv->int_buffer);\r\nkfree(priv);\r\n}
