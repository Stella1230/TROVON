static int\r\nsend_pbl_messages(struct c2_dev *c2dev, __be32 stag_index,\r\nunsigned long va, u32 pbl_depth,\r\nstruct c2_vq_req *vq_req, int pbl_type)\r\n{\r\nu32 pbe_count;\r\nu32 count;\r\nstruct c2wr_nsmr_pbl_req *wr;\r\nstruct c2wr_nsmr_pbl_rep *reply;\r\nint err, pbl_virt, pbl_index, i;\r\nswitch (pbl_type) {\r\ncase PBL_VIRT:\r\npbl_virt = 1;\r\nbreak;\r\ncase PBL_PHYS:\r\npbl_virt = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\npbe_count = (c2dev->req_vq.msg_size -\r\nsizeof(struct c2wr_nsmr_pbl_req)) / sizeof(u64);\r\nwr = kmalloc(c2dev->req_vq.msg_size, GFP_KERNEL);\r\nif (!wr) {\r\nreturn -ENOMEM;\r\n}\r\nc2_wr_set_id(wr, CCWR_NSMR_PBL);\r\nwr->hdr.context = 0;\r\nwr->rnic_handle = c2dev->adapter_handle;\r\nwr->stag_index = stag_index;\r\nwr->flags = 0;\r\npbl_index = 0;\r\nwhile (pbl_depth) {\r\ncount = min(pbe_count, pbl_depth);\r\nwr->addrs_length = cpu_to_be32(count);\r\nif (count == pbl_depth) {\r\nvq_req_get(c2dev, vq_req);\r\nwr->flags = cpu_to_be32(MEM_PBL_COMPLETE);\r\nwr->hdr.context = (unsigned long) vq_req;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (pbl_virt) {\r\nva += PAGE_SIZE;\r\n} else {\r\nwr->paddrs[i] =\r\ncpu_to_be64(((u64 *)va)[pbl_index + i]);\r\n}\r\n}\r\nerr = vq_send_wr(c2dev, (union c2wr *) wr);\r\nif (err) {\r\nif (count <= pbe_count) {\r\nvq_req_put(c2dev, vq_req);\r\n}\r\ngoto bail0;\r\n}\r\npbl_depth -= count;\r\npbl_index += count;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err) {\r\ngoto bail0;\r\n}\r\nreply = (struct c2wr_nsmr_pbl_rep *) (unsigned long) vq_req->reply_msg;\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nerr = c2_errno(reply);\r\nvq_repbuf_free(c2dev, reply);\r\nbail0:\r\nkfree(wr);\r\nreturn err;\r\n}\r\nint\r\nc2_nsmr_register_phys_kern(struct c2_dev *c2dev, u64 *addr_list,\r\nint page_size, int pbl_depth, u32 length,\r\nu32 offset, u64 *va, enum c2_acf acf,\r\nstruct c2_mr *mr)\r\n{\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_nsmr_register_req *wr;\r\nstruct c2wr_nsmr_register_rep *reply;\r\nu16 flags;\r\nint i, pbe_count, count;\r\nint err;\r\nif (!va || !length || !addr_list || !pbl_depth)\r\nreturn -EINTR;\r\nif (pbl_depth > C2_PBL_MAX_DEPTH) {\r\nreturn -EINTR;\r\n}\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req)\r\nreturn -ENOMEM;\r\nwr = kmalloc(c2dev->req_vq.msg_size, GFP_KERNEL);\r\nif (!wr) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nc2_wr_set_id(wr, CCWR_NSMR_REGISTER);\r\nwr->hdr.context = (unsigned long) vq_req;\r\nwr->rnic_handle = c2dev->adapter_handle;\r\nflags = (acf | MEM_VA_BASED | MEM_REMOTE);\r\npbe_count = (c2dev->req_vq.msg_size -\r\nsizeof(struct c2wr_nsmr_register_req)) / sizeof(u64);\r\nif (pbl_depth <= pbe_count) {\r\nflags |= MEM_PBL_COMPLETE;\r\n}\r\nwr->flags = cpu_to_be16(flags);\r\nwr->stag_key = 0;\r\nwr->va = cpu_to_be64(*va);\r\nwr->pd_id = mr->pd->pd_id;\r\nwr->pbe_size = cpu_to_be32(page_size);\r\nwr->length = cpu_to_be32(length);\r\nwr->pbl_depth = cpu_to_be32(pbl_depth);\r\nwr->fbo = cpu_to_be32(offset);\r\ncount = min(pbl_depth, pbe_count);\r\nwr->addrs_length = cpu_to_be32(count);\r\nfor (i = 0; i < count; i++) {\r\nwr->paddrs[i] = cpu_to_be64(addr_list[i]);\r\n}\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail1;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err) {\r\ngoto bail1;\r\n}\r\nreply =\r\n(struct c2wr_nsmr_register_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nif ((err = c2_errno(reply))) {\r\ngoto bail2;\r\n}\r\nmr->ibmr.lkey = mr->ibmr.rkey = be32_to_cpu(reply->stag_index);\r\nvq_repbuf_free(c2dev, reply);\r\npbl_depth -= count;\r\nif (pbl_depth) {\r\nvq_req->reply_msg = (unsigned long) NULL;\r\natomic_set(&vq_req->reply_ready, 0);\r\nerr = send_pbl_messages(c2dev,\r\ncpu_to_be32(mr->ibmr.lkey),\r\n(unsigned long) &addr_list[i],\r\npbl_depth, vq_req, PBL_PHYS);\r\nif (err) {\r\ngoto bail1;\r\n}\r\n}\r\nvq_req_free(c2dev, vq_req);\r\nkfree(wr);\r\nreturn err;\r\nbail2:\r\nvq_repbuf_free(c2dev, reply);\r\nbail1:\r\nkfree(wr);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nint c2_stag_dealloc(struct c2_dev *c2dev, u32 stag_index)\r\n{\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_stag_dealloc_req wr;\r\nstruct c2wr_stag_dealloc_rep *reply;\r\nint err;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req) {\r\nreturn -ENOMEM;\r\n}\r\nc2_wr_set_id(&wr, CCWR_STAG_DEALLOC);\r\nwr.hdr.context = (u64) (unsigned long) vq_req;\r\nwr.rnic_handle = c2dev->adapter_handle;\r\nwr.stag_index = cpu_to_be32(stag_index);\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) & wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail0;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err) {\r\ngoto bail0;\r\n}\r\nreply = (struct c2wr_stag_dealloc_rep *) (unsigned long) vq_req->reply_msg;\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nerr = c2_errno(reply);\r\nvq_repbuf_free(c2dev, reply);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}
