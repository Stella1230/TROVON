static inline void xoutb(unsigned char val, unsigned short port)\r\n{\r\npr_debug("outb(val=%.2x,port=%.4x)\n", val, port);\r\noutb(val, port);\r\n}\r\nstatic inline unsigned char xinb(unsigned short port)\r\n{\r\nunsigned char val;\r\nval = inb(port);\r\npr_debug("%.2x=inb(%.4x)\n", val, port);\r\nreturn val;\r\n}\r\nstatic inline unsigned char invert_revert(unsigned char ch)\r\n{\r\nreturn bitrev8(~ch);\r\n}\r\nstatic void str_invert_revert(unsigned char *b, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nb[i] = invert_revert(b[i]);\r\n}\r\nstatic unsigned int calc_baudv(unsigned char fidi)\r\n{\r\nunsigned int wcrcf, wbrcf, fi_rfu, di_rfu;\r\nfi_rfu = 372;\r\ndi_rfu = 1;\r\nswitch ((fidi >> 4) & 0x0F) {\r\ncase 0x00:\r\nwcrcf = 372;\r\nbreak;\r\ncase 0x01:\r\nwcrcf = 372;\r\nbreak;\r\ncase 0x02:\r\nwcrcf = 558;\r\nbreak;\r\ncase 0x03:\r\nwcrcf = 744;\r\nbreak;\r\ncase 0x04:\r\nwcrcf = 1116;\r\nbreak;\r\ncase 0x05:\r\nwcrcf = 1488;\r\nbreak;\r\ncase 0x06:\r\nwcrcf = 1860;\r\nbreak;\r\ncase 0x07:\r\nwcrcf = fi_rfu;\r\nbreak;\r\ncase 0x08:\r\nwcrcf = fi_rfu;\r\nbreak;\r\ncase 0x09:\r\nwcrcf = 512;\r\nbreak;\r\ncase 0x0A:\r\nwcrcf = 768;\r\nbreak;\r\ncase 0x0B:\r\nwcrcf = 1024;\r\nbreak;\r\ncase 0x0C:\r\nwcrcf = 1536;\r\nbreak;\r\ncase 0x0D:\r\nwcrcf = 2048;\r\nbreak;\r\ndefault:\r\nwcrcf = fi_rfu;\r\nbreak;\r\n}\r\nswitch (fidi & 0x0F) {\r\ncase 0x00:\r\nwbrcf = di_rfu;\r\nbreak;\r\ncase 0x01:\r\nwbrcf = 1;\r\nbreak;\r\ncase 0x02:\r\nwbrcf = 2;\r\nbreak;\r\ncase 0x03:\r\nwbrcf = 4;\r\nbreak;\r\ncase 0x04:\r\nwbrcf = 8;\r\nbreak;\r\ncase 0x05:\r\nwbrcf = 16;\r\nbreak;\r\ncase 0x06:\r\nwbrcf = 32;\r\nbreak;\r\ncase 0x07:\r\nwbrcf = di_rfu;\r\nbreak;\r\ncase 0x08:\r\nwbrcf = 12;\r\nbreak;\r\ncase 0x09:\r\nwbrcf = 20;\r\nbreak;\r\ndefault:\r\nwbrcf = di_rfu;\r\nbreak;\r\n}\r\nreturn (wcrcf / wbrcf);\r\n}\r\nstatic unsigned short io_read_num_rec_bytes(unsigned int iobase,\r\nunsigned short *s)\r\n{\r\nunsigned short tmp;\r\ntmp = *s = 0;\r\ndo {\r\n*s = tmp;\r\ntmp = inb(REG_NUM_BYTES(iobase)) |\r\n(inb(REG_FLAGS0(iobase)) & 4 ? 0x100 : 0);\r\n} while (tmp != *s);\r\nreturn *s;\r\n}\r\nstatic int parse_atr(struct cm4000_dev *dev)\r\n{\r\nunsigned char any_t1, any_t0;\r\nunsigned char ch, ifno;\r\nint ix, done;\r\nDEBUGP(3, dev, "-> parse_atr: dev->atr_len = %i\n", dev->atr_len);\r\nif (dev->atr_len < 3) {\r\nDEBUGP(5, dev, "parse_atr: atr_len < 3\n");\r\nreturn 0;\r\n}\r\nif (dev->atr[0] == 0x3f)\r\nset_bit(IS_INVREV, &dev->flags);\r\nelse\r\nclear_bit(IS_INVREV, &dev->flags);\r\nix = 1;\r\nifno = 1;\r\nch = dev->atr[1];\r\ndev->proto = 0;\r\nany_t1 = any_t0 = done = 0;\r\ndev->ta1 = 0x11;\r\ndo {\r\nif (ifno == 1 && (ch & 0x10)) {\r\ndev->ta1 = dev->atr[2];\r\nDEBUGP(5, dev, "Card says FiDi is 0x%.2x\n", dev->ta1);\r\nifno++;\r\n} else if ((ifno == 2) && (ch & 0x10)) {\r\ndev->ta1 = 0x11;\r\nifno++;\r\n}\r\nDEBUGP(5, dev, "Yi=%.2x\n", ch & 0xf0);\r\nix += ((ch & 0x10) >> 4)\r\n+((ch & 0x20) >> 5)\r\n+ ((ch & 0x40) >> 6)\r\n+ ((ch & 0x80) >> 7);\r\nif (ch & 0x80) {\r\nch = dev->atr[ix];\r\nif ((ch & 0x0f)) {\r\nany_t1 = 1;\r\nDEBUGP(5, dev, "card is capable of T=1\n");\r\n} else {\r\nany_t0 = 1;\r\nDEBUGP(5, dev, "card is capable of T=0\n");\r\n}\r\n} else\r\ndone = 1;\r\n} while (!done);\r\nDEBUGP(5, dev, "ix=%d noHist=%d any_t1=%d\n",\r\nix, dev->atr[1] & 15, any_t1);\r\nif (ix + 1 + (dev->atr[1] & 0x0f) + any_t1 != dev->atr_len) {\r\nDEBUGP(5, dev, "length error\n");\r\nreturn 0;\r\n}\r\nif (any_t0)\r\nset_bit(IS_ANY_T0, &dev->flags);\r\nif (any_t1) {\r\ndev->atr_csum = 0;\r\n#ifdef ATR_CSUM\r\nfor (i = 1; i < dev->atr_len; i++)\r\ndev->atr_csum ^= dev->atr[i];\r\nif (dev->atr_csum) {\r\nset_bit(IS_BAD_CSUM, &dev->flags);\r\nDEBUGP(5, dev, "bad checksum\n");\r\ngoto return_0;\r\n}\r\n#endif\r\nif (any_t0 == 0)\r\ndev->proto = 1;\r\nset_bit(IS_ANY_T1, &dev->flags);\r\n}\r\nreturn 1;\r\n}\r\nstatic void set_cardparameter(struct cm4000_dev *dev)\r\n{\r\nint i;\r\nunsigned int iobase = dev->p_dev->resource[0]->start;\r\nu_int8_t stopbits = 0x02;\r\nDEBUGP(3, dev, "-> set_cardparameter\n");\r\ndev->flags1 = dev->flags1 | (((dev->baudv - 1) & 0x0100) >> 8);\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\nDEBUGP(5, dev, "flags1 = 0x%02x\n", dev->flags1);\r\nxoutb((unsigned char)((dev->baudv - 1) & 0xFF), REG_BAUDRATE(iobase));\r\nDEBUGP(5, dev, "baudv = %i -> write 0x%02x\n", dev->baudv,\r\n((dev->baudv - 1) & 0xFF));\r\nfor (i = 0; i < ARRAY_SIZE(card_fixups); i++) {\r\nif (!memcmp(dev->atr, card_fixups[i].atr,\r\ncard_fixups[i].atr_len))\r\nstopbits = card_fixups[i].stopbits;\r\n}\r\nxoutb(stopbits, REG_STOPBITS(iobase));\r\nDEBUGP(3, dev, "<- set_cardparameter\n");\r\n}\r\nstatic int set_protocol(struct cm4000_dev *dev, struct ptsreq *ptsreq)\r\n{\r\nunsigned long tmp, i;\r\nunsigned short num_bytes_read;\r\nunsigned char pts_reply[4];\r\nssize_t rc;\r\nunsigned int iobase = dev->p_dev->resource[0]->start;\r\nrc = 0;\r\nDEBUGP(3, dev, "-> set_protocol\n");\r\nDEBUGP(5, dev, "ptsreq->Protocol = 0x%.8x, ptsreq->Flags=0x%.8x, "\r\n"ptsreq->pts1=0x%.2x, ptsreq->pts2=0x%.2x, "\r\n"ptsreq->pts3=0x%.2x\n", (unsigned int)ptsreq->protocol,\r\n(unsigned int)ptsreq->flags, ptsreq->pts1, ptsreq->pts2,\r\nptsreq->pts3);\r\ndev->pts[0] = 0xff;\r\ndev->pts[1] = 0x00;\r\ntmp = ptsreq->protocol;\r\nwhile ((tmp = (tmp >> 1)) > 0)\r\ndev->pts[1]++;\r\ndev->proto = dev->pts[1];\r\ndev->pts[1] = (0x01 << 4) | (dev->pts[1]);\r\nDEBUGP(5, dev, "Ta(1) from ATR is 0x%.2x\n", dev->ta1);\r\ndev->pts[2] = fi_di_table[dev->ta1 & 0x0F][(dev->ta1 >> 4) & 0x0F];\r\ndev->pts[3] = dev->pts[0] ^ dev->pts[1] ^ dev->pts[2];\r\nDEBUGP(5, dev, "pts0=%.2x, pts1=%.2x, pts2=%.2x, pts3=%.2x\n",\r\ndev->pts[0], dev->pts[1], dev->pts[2], dev->pts[3]);\r\nif (test_bit(IS_INVREV, &dev->flags))\r\nstr_invert_revert(dev->pts, 4);\r\nxoutb(0x80, REG_FLAGS0(iobase));\r\nDEBUGP(5, dev, "Enable access to the messages buffer\n");\r\ndev->flags1 = 0x20\r\n| (test_bit(IS_INVREV, &dev->flags) ? 0x02 : 0x00)\r\n| ((dev->baudv >> 8) & 0x01);\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\nDEBUGP(5, dev, "Enable message buffer -> flags1 = 0x%.2x\n",\r\ndev->flags1);\r\nDEBUGP(5, dev, "Write challenge to buffer: ");\r\nfor (i = 0; i < 4; i++) {\r\nxoutb(i, REG_BUF_ADDR(iobase));\r\nxoutb(dev->pts[i], REG_BUF_DATA(iobase));\r\n#ifdef CM4000_DEBUG\r\npr_debug("0x%.2x ", dev->pts[i]);\r\n}\r\npr_debug("\n");\r\n#else\r\n}\r\nint io_detect_cm4000(unsigned int iobase, struct cm4000_dev *dev)\r\n{\r\nif (inb(REG_FLAGS0(iobase)) & 8) {\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\nset_bit(IS_CMM_ABSENT, &dev->flags);\r\nreturn 0;\r\n}\r\nxoutb(dev->flags1 | 0x40, REG_FLAGS1(iobase));\r\nif ((inb(REG_FLAGS0(iobase)) & 8) == 0) {\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\nset_bit(IS_CMM_ABSENT, &dev->flags);\r\nreturn 0;\r\n}\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\nreturn 1;\r\n}\r\nstatic void terminate_monitor(struct cm4000_dev *dev)\r\n{\r\nDEBUGP(3, dev, "-> terminate_monitor\n");\r\nwait_event_interruptible(dev->devq,\r\ntest_and_set_bit(LOCK_MONITOR,\r\n(void *)&dev->flags));\r\nDEBUGP(5, dev, "Now allow last cycle of monitor!\n");\r\nwhile (test_bit(LOCK_MONITOR, (void *)&dev->flags))\r\nmsleep(25);\r\nDEBUGP(5, dev, "Delete timer\n");\r\ndel_timer_sync(&dev->timer);\r\n#ifdef CM4000_DEBUG\r\ndev->monitor_running = 0;\r\n#endif\r\nDEBUGP(3, dev, "<- terminate_monitor\n");\r\n}\r\nstatic void monitor_card(unsigned long p)\r\n{\r\nstruct cm4000_dev *dev = (struct cm4000_dev *) p;\r\nunsigned int iobase = dev->p_dev->resource[0]->start;\r\nunsigned short s;\r\nstruct ptsreq ptsreq;\r\nint i, atrc;\r\nDEBUGP(7, dev, "-> monitor_card\n");\r\nif (test_and_set_bit(LOCK_MONITOR, &dev->flags)) {\r\nDEBUGP(4, dev, "About to stop monitor\n");\r\ndev->rlen =\r\ndev->rpos =\r\ndev->atr_csum = dev->atr_len_retry = dev->cwarn = 0;\r\ndev->mstate = M_FETCH_ATR;\r\nclear_bit(LOCK_MONITOR, &dev->flags);\r\nwake_up_interruptible(&dev->devq);\r\nDEBUGP(2, dev, "<- monitor_card (we are done now)\n");\r\nreturn;\r\n}\r\nif (test_and_set_bit(LOCK_IO, (void *)&dev->flags)) {\r\nDEBUGP(4, dev, "Couldn't get IO lock\n");\r\ngoto return_with_timer;\r\n}\r\ndev->flags0 = xinb(REG_FLAGS0(iobase));\r\nDEBUGP(7, dev, "dev->flags0 = 0x%2x\n", dev->flags0);\r\nDEBUGP(7, dev, "smartcard present: %s\n",\r\ndev->flags0 & 1 ? "yes" : "no");\r\nDEBUGP(7, dev, "cardman present: %s\n",\r\ndev->flags0 == 0xff ? "no" : "yes");\r\nif ((dev->flags0 & 1) == 0\r\n|| dev->flags0 == 0xff) {\r\ndev->rlen =\r\ndev->rpos =\r\ndev->atr_csum = dev->atr_len_retry = dev->cwarn = 0;\r\ndev->mstate = M_FETCH_ATR;\r\ndev->flags &= 0x000000ff;\r\nif (dev->flags0 == 0xff) {\r\nDEBUGP(4, dev, "set IS_CMM_ABSENT bit\n");\r\nset_bit(IS_CMM_ABSENT, &dev->flags);\r\n} else if (test_bit(IS_CMM_ABSENT, &dev->flags)) {\r\nDEBUGP(4, dev, "clear IS_CMM_ABSENT bit "\r\n"(card is removed)\n");\r\nclear_bit(IS_CMM_ABSENT, &dev->flags);\r\n}\r\ngoto release_io;\r\n} else if ((dev->flags0 & 1) && test_bit(IS_CMM_ABSENT, &dev->flags)) {\r\nDEBUGP(4, dev, "clear IS_CMM_ABSENT bit (card is inserted)\n");\r\nclear_bit(IS_CMM_ABSENT, &dev->flags);\r\n}\r\nif (test_bit(IS_ATR_VALID, &dev->flags) == 1) {\r\nDEBUGP(7, dev, "believe ATR is already valid (do nothing)\n");\r\ngoto release_io;\r\n}\r\nswitch (dev->mstate) {\r\nunsigned char flags0;\r\ncase M_CARDOFF:\r\nDEBUGP(4, dev, "M_CARDOFF\n");\r\nflags0 = inb(REG_FLAGS0(iobase));\r\nif (flags0 & 0x02) {\r\ndev->mdelay = T_10MSEC;\r\n} else {\r\nxoutb(0x80, REG_FLAGS0(iobase));\r\ndev->rlen =\r\ndev->rpos =\r\ndev->atr_csum =\r\ndev->atr_len_retry = dev->cwarn = 0;\r\ndev->mstate = M_FETCH_ATR;\r\ndev->mdelay = T_50MSEC;\r\n}\r\nbreak;\r\ncase M_FETCH_ATR:\r\nDEBUGP(4, dev, "M_FETCH_ATR\n");\r\nxoutb(0x80, REG_FLAGS0(iobase));\r\nDEBUGP(4, dev, "Reset BAUDV to 9600\n");\r\ndev->baudv = 0x173;\r\nxoutb(0x02, REG_STOPBITS(iobase));\r\nxoutb(0x73, REG_BAUDRATE(iobase));\r\nxoutb(0x21, REG_FLAGS1(iobase));\r\nxoutb(dev->flags0 & 2 ? 0x46 : 0x44, REG_FLAGS0(iobase));\r\ndev->mdelay = T_40MSEC;\r\ndev->mstate = M_TIMEOUT_WAIT;\r\nbreak;\r\ncase M_TIMEOUT_WAIT:\r\nDEBUGP(4, dev, "M_TIMEOUT_WAIT\n");\r\nio_read_num_rec_bytes(iobase, &dev->atr_len);\r\ndev->mdelay = T_10MSEC;\r\ndev->mstate = M_READ_ATR_LEN;\r\nbreak;\r\ncase M_READ_ATR_LEN:\r\nDEBUGP(4, dev, "M_READ_ATR_LEN\n");\r\n#define MAX_ATR_LEN_RETRY 100\r\nif (dev->atr_len == io_read_num_rec_bytes(iobase, &s)) {\r\nif (dev->atr_len_retry++ >= MAX_ATR_LEN_RETRY) {\r\ndev->mdelay = T_10MSEC;\r\ndev->mstate = M_READ_ATR;\r\n}\r\n} else {\r\ndev->atr_len = s;\r\ndev->atr_len_retry = 0;\r\n}\r\nDEBUGP(4, dev, "Current ATR_LEN = %i\n", dev->atr_len);\r\nbreak;\r\ncase M_READ_ATR:\r\nDEBUGP(4, dev, "M_READ_ATR\n");\r\nxoutb(0x80, REG_FLAGS0(iobase));\r\nfor (i = 0; i < dev->atr_len; i++) {\r\nxoutb(i, REG_BUF_ADDR(iobase));\r\ndev->atr[i] = inb(REG_BUF_DATA(iobase));\r\n}\r\nDEBUGP(4, dev, "Deactivate T_Active flags\n");\r\ndev->flags1 = 0x01;\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\nset_bit(IS_ATR_PRESENT, &dev->flags);\r\nif (dev->atr[0] == 0x03)\r\nstr_invert_revert(dev->atr, dev->atr_len);\r\natrc = parse_atr(dev);\r\nif (atrc == 0) {\r\ndev->mdelay = 0;\r\ndev->mstate = M_BAD_CARD;\r\n} else {\r\ndev->mdelay = T_50MSEC;\r\ndev->mstate = M_ATR_PRESENT;\r\nset_bit(IS_ATR_VALID, &dev->flags);\r\n}\r\nif (test_bit(IS_ATR_VALID, &dev->flags) == 1) {\r\nDEBUGP(4, dev, "monitor_card: ATR valid\n");\r\nif ((test_bit(IS_AUTOPPS_ACT, &dev->flags) == 0) &&\r\n(dev->ta1 != 0x11) &&\r\n!(test_bit(IS_ANY_T0, &dev->flags) &&\r\ntest_bit(IS_ANY_T1, &dev->flags))) {\r\nDEBUGP(4, dev, "Perform AUTOPPS\n");\r\nset_bit(IS_AUTOPPS_ACT, &dev->flags);\r\nptsreq.protocol = (0x01 << dev->proto);\r\nptsreq.flags = 0x01;\r\nptsreq.pts1 = 0x00;\r\nptsreq.pts2 = 0x00;\r\nptsreq.pts3 = 0x00;\r\nif (set_protocol(dev, &ptsreq) == 0) {\r\nDEBUGP(4, dev, "AUTOPPS ret SUCC\n");\r\nclear_bit(IS_AUTOPPS_ACT, &dev->flags);\r\nwake_up_interruptible(&dev->atrq);\r\n} else {\r\nDEBUGP(4, dev, "AUTOPPS failed: "\r\n"repower using defaults\n");\r\nclear_bit(IS_ATR_PRESENT, &dev->flags);\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\ndev->rlen =\r\ndev->rpos =\r\ndev->atr_csum =\r\ndev->atr_len_retry = dev->cwarn = 0;\r\ndev->mstate = M_FETCH_ATR;\r\ndev->mdelay = T_50MSEC;\r\n}\r\n} else {\r\nset_cardparameter(dev);\r\nif (test_bit(IS_AUTOPPS_ACT, &dev->flags) == 1)\r\nDEBUGP(4, dev, "AUTOPPS already active "\r\n"2nd try:use default values\n");\r\nif (dev->ta1 == 0x11)\r\nDEBUGP(4, dev, "No AUTOPPS necessary "\r\n"TA(1)==0x11\n");\r\nif (test_bit(IS_ANY_T0, &dev->flags)\r\n&& test_bit(IS_ANY_T1, &dev->flags))\r\nDEBUGP(4, dev, "Do NOT perform AUTOPPS "\r\n"with multiprotocol cards\n");\r\nclear_bit(IS_AUTOPPS_ACT, &dev->flags);\r\nwake_up_interruptible(&dev->atrq);\r\n}\r\n} else {\r\nDEBUGP(4, dev, "ATR invalid\n");\r\nwake_up_interruptible(&dev->atrq);\r\n}\r\nbreak;\r\ncase M_BAD_CARD:\r\nDEBUGP(4, dev, "M_BAD_CARD\n");\r\nif (dev->cwarn == 0 || dev->cwarn == 10) {\r\nset_bit(IS_BAD_CARD, &dev->flags);\r\ndev_warn(&dev->p_dev->dev, MODULE_NAME ": ");\r\nif (test_bit(IS_BAD_CSUM, &dev->flags)) {\r\nDEBUGP(4, dev, "ATR checksum (0x%.2x, should "\r\n"be zero) failed\n", dev->atr_csum);\r\n}\r\n#ifdef CM4000_DEBUG\r\nelse if (test_bit(IS_BAD_LENGTH, &dev->flags)) {\r\nDEBUGP(4, dev, "ATR length error\n");\r\n} else {\r\nDEBUGP(4, dev, "card damaged or wrong way "\r\n"inserted\n");\r\n}\r\n#endif\r\ndev->cwarn = 0;\r\nwake_up_interruptible(&dev->atrq);\r\n}\r\ndev->cwarn++;\r\ndev->mdelay = T_100MSEC;\r\ndev->mstate = M_FETCH_ATR;\r\nbreak;\r\ndefault:\r\nDEBUGP(7, dev, "Unknown action\n");\r\nbreak;\r\n}\r\nrelease_io:\r\nDEBUGP(7, dev, "release_io\n");\r\nclear_bit(LOCK_IO, &dev->flags);\r\nwake_up_interruptible(&dev->ioq);\r\nreturn_with_timer:\r\nDEBUGP(7, dev, "<- monitor_card (returns with timer)\n");\r\nmod_timer(&dev->timer, jiffies + dev->mdelay);\r\nclear_bit(LOCK_MONITOR, &dev->flags);\r\n}\r\nstatic ssize_t cmm_read(struct file *filp, __user char *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct cm4000_dev *dev = filp->private_data;\r\nunsigned int iobase = dev->p_dev->resource[0]->start;\r\nssize_t rc;\r\nint i, j, k;\r\nDEBUGP(2, dev, "-> cmm_read(%s,%d)\n", current->comm, current->pid);\r\nif (count == 0)\r\nreturn 0;\r\nif (!pcmcia_dev_present(dev->p_dev) ||\r\ntest_bit(IS_CMM_ABSENT, &dev->flags))\r\nreturn -ENODEV;\r\nif (test_bit(IS_BAD_CSUM, &dev->flags))\r\nreturn -EIO;\r\nif (wait_event_interruptible\r\n(dev->atrq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_bit(IS_ATR_PRESENT, (void *)&dev->flags) != 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nreturn -ERESTARTSYS;\r\n}\r\nif (test_bit(IS_ATR_VALID, &dev->flags) == 0)\r\nreturn -EIO;\r\nif (wait_event_interruptible\r\n(dev->readq,\r\n((filp->f_flags & O_NONBLOCK) || (dev->rpos < dev->rlen)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nreturn -ERESTARTSYS;\r\n}\r\nif (wait_event_interruptible\r\n(dev->ioq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_and_set_bit(LOCK_IO, (void *)&dev->flags) == 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nreturn -ERESTARTSYS;\r\n}\r\nrc = 0;\r\ndev->flags0 = inb(REG_FLAGS0(iobase));\r\nif ((dev->flags0 & 1) == 0\r\n|| dev->flags0 == 0xff) {\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\nif (dev->flags0 & 1) {\r\nset_bit(IS_CMM_ABSENT, &dev->flags);\r\nrc = -ENODEV;\r\n} else {\r\nrc = -EIO;\r\n}\r\ngoto release_io;\r\n}\r\nDEBUGP(4, dev, "begin read answer\n");\r\nj = min(count, (size_t)(dev->rlen - dev->rpos));\r\nk = dev->rpos;\r\nif (k + j > 255)\r\nj = 256 - k;\r\nDEBUGP(4, dev, "read1 j=%d\n", j);\r\nfor (i = 0; i < j; i++) {\r\nxoutb(k++, REG_BUF_ADDR(iobase));\r\ndev->rbuf[i] = xinb(REG_BUF_DATA(iobase));\r\n}\r\nj = min(count, (size_t)(dev->rlen - dev->rpos));\r\nif (k + j > 255) {\r\nDEBUGP(4, dev, "read2 j=%d\n", j);\r\ndev->flags1 |= 0x10;\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\nfor (; i < j; i++) {\r\nxoutb(k++, REG_BUF_ADDR(iobase));\r\ndev->rbuf[i] = xinb(REG_BUF_DATA(iobase));\r\n}\r\n}\r\nif (dev->proto == 0 && count > dev->rlen - dev->rpos && i) {\r\nDEBUGP(4, dev, "T=0 and count > buffer\n");\r\ndev->rbuf[i] = dev->rbuf[i - 1];\r\ndev->rbuf[i - 1] = dev->procbyte;\r\nj++;\r\n}\r\ncount = j;\r\ndev->rpos = dev->rlen + 1;\r\nDEBUGP(4, dev, "Clear T1Active\n");\r\ndev->flags1 &= 0xdf;\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\nxoutb(0, REG_FLAGS1(iobase));\r\nif (!io_detect_cm4000(iobase, dev)) {\r\nrc = -ENODEV;\r\ngoto release_io;\r\n}\r\nif (test_bit(IS_INVREV, &dev->flags) && count > 0)\r\nstr_invert_revert(dev->rbuf, count);\r\nif (copy_to_user(buf, dev->rbuf, count))\r\nrc = -EFAULT;\r\nrelease_io:\r\nclear_bit(LOCK_IO, &dev->flags);\r\nwake_up_interruptible(&dev->ioq);\r\nDEBUGP(2, dev, "<- cmm_read returns: rc = %Zi\n",\r\n(rc < 0 ? rc : count));\r\nreturn rc < 0 ? rc : count;\r\n}\r\nstatic ssize_t cmm_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct cm4000_dev *dev = filp->private_data;\r\nunsigned int iobase = dev->p_dev->resource[0]->start;\r\nunsigned short s;\r\nunsigned char tmp;\r\nunsigned char infolen;\r\nunsigned char sendT0;\r\nunsigned short nsend;\r\nunsigned short nr;\r\nssize_t rc;\r\nint i;\r\nDEBUGP(2, dev, "-> cmm_write(%s,%d)\n", current->comm, current->pid);\r\nif (count == 0)\r\nreturn 0;\r\nif (dev->proto == 0 && count < 4) {\r\nDEBUGP(4, dev, "T0 short write\n");\r\nreturn -EIO;\r\n}\r\nnr = count & 0x1ff;\r\nsendT0 = dev->proto ? 0 : nr > 5 ? 0x08 : 0;\r\nif (!pcmcia_dev_present(dev->p_dev) ||\r\ntest_bit(IS_CMM_ABSENT, &dev->flags))\r\nreturn -ENODEV;\r\nif (test_bit(IS_BAD_CSUM, &dev->flags)) {\r\nDEBUGP(4, dev, "bad csum\n");\r\nreturn -EIO;\r\n}\r\nif (wait_event_interruptible\r\n(dev->atrq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_bit(IS_ATR_PRESENT, (void *)&dev->flags) != 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nreturn -ERESTARTSYS;\r\n}\r\nif (test_bit(IS_ATR_VALID, &dev->flags) == 0) {\r\nDEBUGP(4, dev, "invalid ATR\n");\r\nreturn -EIO;\r\n}\r\nif (wait_event_interruptible\r\n(dev->ioq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_and_set_bit(LOCK_IO, (void *)&dev->flags) == 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nreturn -ERESTARTSYS;\r\n}\r\nif (copy_from_user(dev->sbuf, buf, ((count > 512) ? 512 : count)))\r\nreturn -EFAULT;\r\nrc = 0;\r\ndev->flags0 = inb(REG_FLAGS0(iobase));\r\nif ((dev->flags0 & 1) == 0\r\n|| dev->flags0 == 0xff) {\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\nif (dev->flags0 & 1) {\r\nset_bit(IS_CMM_ABSENT, &dev->flags);\r\nrc = -ENODEV;\r\n} else {\r\nDEBUGP(4, dev, "IO error\n");\r\nrc = -EIO;\r\n}\r\ngoto release_io;\r\n}\r\nxoutb(0x80, REG_FLAGS0(iobase));\r\nif (!io_detect_cm4000(iobase, dev)) {\r\nrc = -ENODEV;\r\ngoto release_io;\r\n}\r\ndev->flags1 |= (sendT0);\r\nset_cardparameter(dev);\r\ntmp = inb(REG_FLAGS1(iobase));\r\ndev->flags1 = 0x20\r\n| (sendT0)\r\n| (test_bit(IS_INVREV, &dev->flags) ? 2 : 0)\r\n| (((dev->baudv - 1) & 0x0100) >> 8);\r\nDEBUGP(1, dev, "set dev->flags1 = 0x%.2x\n", dev->flags1);\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\nDEBUGP(4, dev, "Xmit data\n");\r\nfor (i = 0; i < nr; i++) {\r\nif (i >= 256) {\r\ndev->flags1 = 0x20\r\n| (sendT0)\r\n| (test_bit(IS_INVREV, &dev->flags) ? 2 : 0)\r\n| (((dev->baudv - 1) & 0x0100) >> 8)\r\n| 0x10;\r\nDEBUGP(4, dev, "dev->flags = 0x%.2x - set address "\r\n"high\n", dev->flags1);\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\n}\r\nif (test_bit(IS_INVREV, &dev->flags)) {\r\nDEBUGP(4, dev, "Apply inverse convention for 0x%.2x "\r\n"-> 0x%.2x\n", (unsigned char)dev->sbuf[i],\r\ninvert_revert(dev->sbuf[i]));\r\nxoutb(i, REG_BUF_ADDR(iobase));\r\nxoutb(invert_revert(dev->sbuf[i]),\r\nREG_BUF_DATA(iobase));\r\n} else {\r\nxoutb(i, REG_BUF_ADDR(iobase));\r\nxoutb(dev->sbuf[i], REG_BUF_DATA(iobase));\r\n}\r\n}\r\nDEBUGP(4, dev, "Xmit done\n");\r\nif (dev->proto == 0) {\r\nif (nr == 4) {\r\nDEBUGP(4, dev, "T=0 assumes 0 byte reply\n");\r\nxoutb(i, REG_BUF_ADDR(iobase));\r\nif (test_bit(IS_INVREV, &dev->flags))\r\nxoutb(0xff, REG_BUF_DATA(iobase));\r\nelse\r\nxoutb(0x00, REG_BUF_DATA(iobase));\r\n}\r\nif (sendT0)\r\nnsend = nr;\r\nelse {\r\nif (nr == 4)\r\nnsend = 5;\r\nelse {\r\nnsend = 5 + (unsigned char)dev->sbuf[4];\r\nif (dev->sbuf[4] == 0)\r\nnsend += 0x100;\r\n}\r\n}\r\n} else\r\nnsend = nr;\r\nif (test_bit(IS_INVREV, &dev->flags)) {\r\nDEBUGP(4, dev, "T=0 set Procedure byte (inverse-reverse) "\r\n"0x%.2x\n", invert_revert(dev->sbuf[1]));\r\nxoutb(invert_revert(dev->sbuf[1]), REG_NUM_BYTES(iobase));\r\n} else {\r\nDEBUGP(4, dev, "T=0 set Procedure byte 0x%.2x\n", dev->sbuf[1]);\r\nxoutb(dev->sbuf[1], REG_NUM_BYTES(iobase));\r\n}\r\nDEBUGP(1, dev, "set NumSendBytes = 0x%.2x\n",\r\n(unsigned char)(nsend & 0xff));\r\nxoutb((unsigned char)(nsend & 0xff), REG_NUM_SEND(iobase));\r\nDEBUGP(1, dev, "Trigger CARDMAN CONTROLLER (0x%.2x)\n",\r\n0x40\r\n| (dev->flags0 & 2 ? 0 : 4)\r\n|(dev->proto ? 0x10 : 0x08)\r\n|(nsend & 0x100) >> 8 );\r\nxoutb(0x40\r\n| (dev->flags0 & 2 ? 0 : 4)\r\n|(dev->proto ? 0x10 : 0x08)\r\n|(nsend & 0x100) >> 8,\r\nREG_FLAGS0(iobase));\r\nif (dev->proto == 1) {\r\nDEBUGP(4, dev, "Wait for xmit done\n");\r\nfor (i = 0; i < 1000; i++) {\r\nif (inb(REG_FLAGS0(iobase)) & 0x08)\r\nbreak;\r\nmsleep_interruptible(10);\r\n}\r\nif (i == 1000) {\r\nDEBUGP(4, dev, "timeout waiting for xmit done\n");\r\nrc = -EIO;\r\ngoto release_io;\r\n}\r\n}\r\ninfolen = 0;\r\nif (dev->proto) {\r\nfor (i = 0; i < 6000; i++) {\r\nio_read_num_rec_bytes(iobase, &s);\r\nif (s >= 3) {\r\ninfolen = inb(REG_FLAGS1(iobase));\r\nDEBUGP(4, dev, "infolen=%d\n", infolen);\r\nbreak;\r\n}\r\nmsleep_interruptible(10);\r\n}\r\nif (i == 6000) {\r\nDEBUGP(4, dev, "timeout waiting for infoLen\n");\r\nrc = -EIO;\r\ngoto release_io;\r\n}\r\n} else\r\nclear_bit(IS_PROCBYTE_PRESENT, &dev->flags);\r\nio_read_num_rec_bytes(iobase, &dev->rlen);\r\nfor (i = 0; i < 600; i++) {\r\nif (dev->proto) {\r\nif (dev->rlen >= infolen + 4)\r\nbreak;\r\n}\r\nmsleep_interruptible(10);\r\nio_read_num_rec_bytes(iobase, &s);\r\nif (s > dev->rlen) {\r\nDEBUGP(1, dev, "NumRecBytes inc (reset timeout)\n");\r\ni = 0;\r\ndev->rlen = s;\r\n}\r\nelse if (dev->proto == 0) {\r\nif ((inb(REG_BUF_ADDR(iobase)) & 0x80)) {\r\nDEBUGP(1, dev, "NoProcedure byte set\n");\r\n} else {\r\nDEBUGP(1, dev, "NoProcedure byte unset "\r\n"(reset timeout)\n");\r\ndev->procbyte = inb(REG_FLAGS1(iobase));\r\nDEBUGP(1, dev, "Read procedure byte 0x%.2x\n",\r\ndev->procbyte);\r\ni = 0;\r\n}\r\nif (inb(REG_FLAGS0(iobase)) & 0x08) {\r\nDEBUGP(1, dev, "T0Done flag (read reply)\n");\r\nbreak;\r\n}\r\n}\r\nif (dev->proto)\r\ninfolen = inb(REG_FLAGS1(iobase));\r\n}\r\nif (i == 600) {\r\nDEBUGP(1, dev, "timeout waiting for numRecBytes\n");\r\nrc = -EIO;\r\ngoto release_io;\r\n} else {\r\nif (dev->proto == 0) {\r\nDEBUGP(1, dev, "Wait for T0Done bit to be set\n");\r\nfor (i = 0; i < 1000; i++) {\r\nif (inb(REG_FLAGS0(iobase)) & 0x08)\r\nbreak;\r\nmsleep_interruptible(10);\r\n}\r\nif (i == 1000) {\r\nDEBUGP(1, dev, "timeout waiting for T0Done\n");\r\nrc = -EIO;\r\ngoto release_io;\r\n}\r\ndev->procbyte = inb(REG_FLAGS1(iobase));\r\nDEBUGP(4, dev, "Read procedure byte 0x%.2x\n",\r\ndev->procbyte);\r\nio_read_num_rec_bytes(iobase, &dev->rlen);\r\nDEBUGP(4, dev, "Read NumRecBytes = %i\n", dev->rlen);\r\n}\r\n}\r\ndev->rpos = dev->proto ? 0 : nr == 4 ? 5 : nr > dev->rlen ? 5 : nr;\r\nDEBUGP(4, dev, "dev->rlen = %i, dev->rpos = %i, nr = %i\n",\r\ndev->rlen, dev->rpos, nr);\r\nrelease_io:\r\nDEBUGP(4, dev, "Reset SM\n");\r\nxoutb(0x80, REG_FLAGS0(iobase));\r\nif (rc < 0) {\r\nDEBUGP(4, dev, "Write failed but clear T_Active\n");\r\ndev->flags1 &= 0xdf;\r\nxoutb(dev->flags1, REG_FLAGS1(iobase));\r\n}\r\nclear_bit(LOCK_IO, &dev->flags);\r\nwake_up_interruptible(&dev->ioq);\r\nwake_up_interruptible(&dev->readq);\r\nmemset((char *)dev->sbuf, 0, 512);\r\nDEBUGP(2, dev, "<- cmm_write\n");\r\nreturn rc < 0 ? rc : nr;\r\n}\r\nstatic void start_monitor(struct cm4000_dev *dev)\r\n{\r\nDEBUGP(3, dev, "-> start_monitor\n");\r\nif (!dev->monitor_running) {\r\nDEBUGP(5, dev, "create, init and add timer\n");\r\nsetup_timer(&dev->timer, monitor_card, (unsigned long)dev);\r\ndev->monitor_running = 1;\r\nmod_timer(&dev->timer, jiffies);\r\n} else\r\nDEBUGP(5, dev, "monitor already running\n");\r\nDEBUGP(3, dev, "<- start_monitor\n");\r\n}\r\nstatic void stop_monitor(struct cm4000_dev *dev)\r\n{\r\nDEBUGP(3, dev, "-> stop_monitor\n");\r\nif (dev->monitor_running) {\r\nDEBUGP(5, dev, "stopping monitor\n");\r\nterminate_monitor(dev);\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\nclear_bit(IS_ATR_PRESENT, &dev->flags);\r\n} else\r\nDEBUGP(5, dev, "monitor already stopped\n");\r\nDEBUGP(3, dev, "<- stop_monitor\n");\r\n}\r\nstatic long cmm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct cm4000_dev *dev = filp->private_data;\r\nunsigned int iobase = dev->p_dev->resource[0]->start;\r\nstruct inode *inode = filp->f_path.dentry->d_inode;\r\nstruct pcmcia_device *link;\r\nint size;\r\nint rc;\r\nvoid __user *argp = (void __user *)arg;\r\n#ifdef CM4000_DEBUG\r\nchar *ioctl_names[CM_IOC_MAXNR + 1] = {\r\n[_IOC_NR(CM_IOCGSTATUS)] "CM_IOCGSTATUS",\r\n[_IOC_NR(CM_IOCGATR)] "CM_IOCGATR",\r\n[_IOC_NR(CM_IOCARDOFF)] "CM_IOCARDOFF",\r\n[_IOC_NR(CM_IOCSPTS)] "CM_IOCSPTS",\r\n[_IOC_NR(CM_IOSDBGLVL)] "CM4000_DBGLVL",\r\n};\r\nDEBUGP(3, dev, "cmm_ioctl(device=%d.%d) %s\n", imajor(inode),\r\niminor(inode), ioctl_names[_IOC_NR(cmd)]);\r\n#endif\r\nmutex_lock(&cmm_mutex);\r\nrc = -ENODEV;\r\nlink = dev_table[iminor(inode)];\r\nif (!pcmcia_dev_present(link)) {\r\nDEBUGP(4, dev, "DEV_OK false\n");\r\ngoto out;\r\n}\r\nif (test_bit(IS_CMM_ABSENT, &dev->flags)) {\r\nDEBUGP(4, dev, "CMM_ABSENT flag set\n");\r\ngoto out;\r\n}\r\nrc = -EINVAL;\r\nif (_IOC_TYPE(cmd) != CM_IOC_MAGIC) {\r\nDEBUGP(4, dev, "ioctype mismatch\n");\r\ngoto out;\r\n}\r\nif (_IOC_NR(cmd) > CM_IOC_MAXNR) {\r\nDEBUGP(4, dev, "iocnr mismatch\n");\r\ngoto out;\r\n}\r\nsize = _IOC_SIZE(cmd);\r\nrc = -EFAULT;\r\nDEBUGP(4, dev, "iocdir=%.4x iocr=%.4x iocw=%.4x iocsize=%d cmd=%.4x\n",\r\n_IOC_DIR(cmd), _IOC_READ, _IOC_WRITE, size, cmd);\r\nif (_IOC_DIR(cmd) & _IOC_READ) {\r\nif (!access_ok(VERIFY_WRITE, argp, size))\r\ngoto out;\r\n}\r\nif (_IOC_DIR(cmd) & _IOC_WRITE) {\r\nif (!access_ok(VERIFY_READ, argp, size))\r\ngoto out;\r\n}\r\nrc = 0;\r\nswitch (cmd) {\r\ncase CM_IOCGSTATUS:\r\nDEBUGP(4, dev, " ... in CM_IOCGSTATUS\n");\r\n{\r\nint status;\r\nstatus = dev->flags0 & 3;\r\nif (test_bit(IS_ATR_PRESENT, &dev->flags))\r\nstatus |= CM_ATR_PRESENT;\r\nif (test_bit(IS_ATR_VALID, &dev->flags))\r\nstatus |= CM_ATR_VALID;\r\nif (test_bit(IS_CMM_ABSENT, &dev->flags))\r\nstatus |= CM_NO_READER;\r\nif (test_bit(IS_BAD_CARD, &dev->flags))\r\nstatus |= CM_BAD_CARD;\r\nif (copy_to_user(argp, &status, sizeof(int)))\r\nrc = -EFAULT;\r\n}\r\nbreak;\r\ncase CM_IOCGATR:\r\nDEBUGP(4, dev, "... in CM_IOCGATR\n");\r\n{\r\nstruct atreq __user *atreq = argp;\r\nint tmp;\r\nif (wait_event_interruptible\r\n(dev->atrq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_bit(IS_ATR_PRESENT, (void *)&dev->flags)\r\n!= 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nrc = -EAGAIN;\r\nelse\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nrc = -EFAULT;\r\nif (test_bit(IS_ATR_VALID, &dev->flags) == 0) {\r\ntmp = -1;\r\nif (copy_to_user(&(atreq->atr_len), &tmp,\r\nsizeof(int)))\r\nbreak;\r\n} else {\r\nif (copy_to_user(atreq->atr, dev->atr,\r\ndev->atr_len))\r\nbreak;\r\ntmp = dev->atr_len;\r\nif (copy_to_user(&(atreq->atr_len), &tmp, sizeof(int)))\r\nbreak;\r\n}\r\nrc = 0;\r\nbreak;\r\n}\r\ncase CM_IOCARDOFF:\r\n#ifdef CM4000_DEBUG\r\nDEBUGP(4, dev, "... in CM_IOCARDOFF\n");\r\nif (dev->flags0 & 0x01) {\r\nDEBUGP(4, dev, " Card inserted\n");\r\n} else {\r\nDEBUGP(2, dev, " No card inserted\n");\r\n}\r\nif (dev->flags0 & 0x02) {\r\nDEBUGP(4, dev, " Card powered\n");\r\n} else {\r\nDEBUGP(2, dev, " Card not powered\n");\r\n}\r\n#endif\r\nif ((dev->flags0 & 0x01) && (dev->flags0 & 0x02)) {\r\nif (wait_event_interruptible\r\n(dev->ioq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_and_set_bit(LOCK_IO, (void *)&dev->flags)\r\n== 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nrc = -EAGAIN;\r\nelse\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nDEBUGP(4, dev, "Set Flags0=0x42 \n");\r\nxoutb(0x42, REG_FLAGS0(iobase));\r\nclear_bit(IS_ATR_PRESENT, &dev->flags);\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\ndev->mstate = M_CARDOFF;\r\nclear_bit(LOCK_IO, &dev->flags);\r\nif (wait_event_interruptible\r\n(dev->atrq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_bit(IS_ATR_VALID, (void *)&dev->flags) !=\r\n0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nrc = -EAGAIN;\r\nelse\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\nclear_bit(LOCK_IO, &dev->flags);\r\nwake_up_interruptible(&dev->ioq);\r\nrc = 0;\r\nbreak;\r\ncase CM_IOCSPTS:\r\n{\r\nstruct ptsreq krnptsreq;\r\nif (copy_from_user(&krnptsreq, argp,\r\nsizeof(struct ptsreq))) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nrc = 0;\r\nDEBUGP(4, dev, "... in CM_IOCSPTS\n");\r\nif (wait_event_interruptible\r\n(dev->atrq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_bit(IS_ATR_PRESENT, (void *)&dev->flags)\r\n!= 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nrc = -EAGAIN;\r\nelse\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (wait_event_interruptible\r\n(dev->ioq,\r\n((filp->f_flags & O_NONBLOCK)\r\n|| (test_and_set_bit(LOCK_IO, (void *)&dev->flags)\r\n== 0)))) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nrc = -EAGAIN;\r\nelse\r\nrc = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif ((rc = set_protocol(dev, &krnptsreq)) != 0) {\r\ndev->mstate = M_FETCH_ATR;\r\nclear_bit(IS_ATR_VALID, &dev->flags);\r\n}\r\nclear_bit(LOCK_IO, &dev->flags);\r\nwake_up_interruptible(&dev->ioq);\r\n}\r\nbreak;\r\n#ifdef CM4000_DEBUG\r\ncase CM_IOSDBGLVL:\r\nrc = -ENOTTY;\r\nbreak;\r\n#endif\r\ndefault:\r\nDEBUGP(4, dev, "... in default (unknown IOCTL code)\n");\r\nrc = -ENOTTY;\r\n}\r\nout:\r\nmutex_unlock(&cmm_mutex);\r\nreturn rc;\r\n}\r\nstatic int cmm_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct cm4000_dev *dev;\r\nstruct pcmcia_device *link;\r\nint minor = iminor(inode);\r\nint ret;\r\nif (minor >= CM4000_MAX_DEV)\r\nreturn -ENODEV;\r\nmutex_lock(&cmm_mutex);\r\nlink = dev_table[minor];\r\nif (link == NULL || !pcmcia_dev_present(link)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (link->open) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ndev = link->priv;\r\nfilp->private_data = dev;\r\nDEBUGP(2, dev, "-> cmm_open(device=%d.%d process=%s,%d)\n",\r\nimajor(inode), minor, current->comm, current->pid);\r\nZERO_DEV(dev);\r\nif (filp->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\ndev->mdelay = T_50MSEC;\r\nstart_monitor(dev);\r\nlink->open = 1;\r\nDEBUGP(2, dev, "<- cmm_open\n");\r\nret = nonseekable_open(inode, filp);\r\nout:\r\nmutex_unlock(&cmm_mutex);\r\nreturn ret;\r\n}\r\nstatic int cmm_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct cm4000_dev *dev;\r\nstruct pcmcia_device *link;\r\nint minor = iminor(inode);\r\nif (minor >= CM4000_MAX_DEV)\r\nreturn -ENODEV;\r\nlink = dev_table[minor];\r\nif (link == NULL)\r\nreturn -ENODEV;\r\ndev = link->priv;\r\nDEBUGP(2, dev, "-> cmm_close(maj/min=%d.%d)\n",\r\nimajor(inode), minor);\r\nstop_monitor(dev);\r\nZERO_DEV(dev);\r\nlink->open = 0;\r\nwake_up(&dev->devq);\r\nDEBUGP(2, dev, "cmm_close\n");\r\nreturn 0;\r\n}\r\nstatic void cmm_cm4000_release(struct pcmcia_device * link)\r\n{\r\nstruct cm4000_dev *dev = link->priv;\r\nDEBUGP(3, dev, "-> cmm_cm4000_release\n");\r\nwhile (link->open) {\r\nprintk(KERN_INFO MODULE_NAME ": delaying release until "\r\n"process has terminated\n");\r\nwait_event(dev->devq, (link->open == 0));\r\n}\r\nDEBUGP(3, dev, "<- cmm_cm4000_release\n");\r\nreturn;\r\n}\r\nstatic int cm4000_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int cm4000_config(struct pcmcia_device * link, int devno)\r\n{\r\nstruct cm4000_dev *dev;\r\nlink->config_flags |= CONF_AUTO_SET_IO;\r\nif (pcmcia_loop_config(link, cm4000_config_check, NULL))\r\ngoto cs_release;\r\nif (pcmcia_enable_device(link))\r\ngoto cs_release;\r\ndev = link->priv;\r\nreturn 0;\r\ncs_release:\r\ncm4000_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic int cm4000_suspend(struct pcmcia_device *link)\r\n{\r\nstruct cm4000_dev *dev;\r\ndev = link->priv;\r\nstop_monitor(dev);\r\nreturn 0;\r\n}\r\nstatic int cm4000_resume(struct pcmcia_device *link)\r\n{\r\nstruct cm4000_dev *dev;\r\ndev = link->priv;\r\nif (link->open)\r\nstart_monitor(dev);\r\nreturn 0;\r\n}\r\nstatic void cm4000_release(struct pcmcia_device *link)\r\n{\r\ncmm_cm4000_release(link);\r\npcmcia_disable_device(link);\r\n}\r\nstatic int cm4000_probe(struct pcmcia_device *link)\r\n{\r\nstruct cm4000_dev *dev;\r\nint i, ret;\r\nfor (i = 0; i < CM4000_MAX_DEV; i++)\r\nif (dev_table[i] == NULL)\r\nbreak;\r\nif (i == CM4000_MAX_DEV) {\r\nprintk(KERN_NOTICE MODULE_NAME ": all devices in use\n");\r\nreturn -ENODEV;\r\n}\r\ndev = kzalloc(sizeof(struct cm4000_dev), GFP_KERNEL);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\ndev->p_dev = link;\r\nlink->priv = dev;\r\ndev_table[i] = link;\r\ninit_waitqueue_head(&dev->devq);\r\ninit_waitqueue_head(&dev->ioq);\r\ninit_waitqueue_head(&dev->atrq);\r\ninit_waitqueue_head(&dev->readq);\r\nret = cm4000_config(link, i);\r\nif (ret) {\r\ndev_table[i] = NULL;\r\nkfree(dev);\r\nreturn ret;\r\n}\r\ndevice_create(cmm_class, NULL, MKDEV(major, i), NULL, "cmm%d", i);\r\nreturn 0;\r\n}\r\nstatic void cm4000_detach(struct pcmcia_device *link)\r\n{\r\nstruct cm4000_dev *dev = link->priv;\r\nint devno;\r\nfor (devno = 0; devno < CM4000_MAX_DEV; devno++)\r\nif (dev_table[devno] == link)\r\nbreak;\r\nif (devno == CM4000_MAX_DEV)\r\nreturn;\r\nstop_monitor(dev);\r\ncm4000_release(link);\r\ndev_table[devno] = NULL;\r\nkfree(dev);\r\ndevice_destroy(cmm_class, MKDEV(major, devno));\r\nreturn;\r\n}\r\nstatic int __init cmm_init(void)\r\n{\r\nint rc;\r\ncmm_class = class_create(THIS_MODULE, "cardman_4000");\r\nif (IS_ERR(cmm_class))\r\nreturn PTR_ERR(cmm_class);\r\nmajor = register_chrdev(0, DEVICE_NAME, &cm4000_fops);\r\nif (major < 0) {\r\nprintk(KERN_WARNING MODULE_NAME\r\n": could not get major number\n");\r\nclass_destroy(cmm_class);\r\nreturn major;\r\n}\r\nrc = pcmcia_register_driver(&cm4000_driver);\r\nif (rc < 0) {\r\nunregister_chrdev(major, DEVICE_NAME);\r\nclass_destroy(cmm_class);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cmm_exit(void)\r\n{\r\npcmcia_unregister_driver(&cm4000_driver);\r\nunregister_chrdev(major, DEVICE_NAME);\r\nclass_destroy(cmm_class);\r\n}
