void\r\nqla2x00_bsg_job_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct scsi_qla_host *vha = (scsi_qla_host_t *)data;\r\nstruct fc_bsg_job *bsg_job = sp->u.bsg_job;\r\nbsg_job->reply->result = res;\r\nbsg_job->job_done(bsg_job);\r\nsp->free(vha, sp);\r\n}\r\nvoid\r\nqla2x00_bsg_sp_free(void *data, void *ptr)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct scsi_qla_host *vha = (scsi_qla_host_t *)data;\r\nstruct fc_bsg_job *bsg_job = sp->u.bsg_job;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\nif (sp->type == SRB_CT_CMD ||\r\nsp->type == SRB_ELS_CMD_HST)\r\nkfree(sp->fcport);\r\nmempool_free(sp, vha->hw->srb_mempool);\r\n}\r\nint\r\nqla24xx_fcp_prio_cfg_valid(scsi_qla_host_t *vha,\r\nstruct qla_fcp_prio_cfg *pri_cfg, uint8_t flag)\r\n{\r\nint i, ret, num_valid;\r\nuint8_t *bcode;\r\nstruct qla_fcp_prio_entry *pri_entry;\r\nuint32_t *bcode_val_ptr, bcode_val;\r\nret = 1;\r\nnum_valid = 0;\r\nbcode = (uint8_t *)pri_cfg;\r\nbcode_val_ptr = (uint32_t *)pri_cfg;\r\nbcode_val = (uint32_t)(*bcode_val_ptr);\r\nif (bcode_val == 0xFFFFFFFF) {\r\nql_dbg(ql_dbg_user, vha, 0x7051,\r\n"No FCP Priority config data.\n");\r\nreturn 0;\r\n}\r\nif (bcode[0] != 'H' || bcode[1] != 'Q' || bcode[2] != 'O' ||\r\nbcode[3] != 'S') {\r\nql_dbg(ql_dbg_user, vha, 0x7052,\r\n"Invalid FCP Priority data header. bcode=0x%x.\n",\r\nbcode_val);\r\nreturn 0;\r\n}\r\nif (flag != 1)\r\nreturn ret;\r\npri_entry = &pri_cfg->entry[0];\r\nfor (i = 0; i < pri_cfg->num_entries; i++) {\r\nif (pri_entry->flags & FCP_PRIO_ENTRY_TAG_VALID)\r\nnum_valid++;\r\npri_entry++;\r\n}\r\nif (num_valid == 0) {\r\nql_dbg(ql_dbg_user, vha, 0x7053,\r\n"No valid FCP Priority data entries.\n");\r\nret = 0;\r\n} else {\r\nql_dbg(ql_dbg_user, vha, 0x7054,\r\n"Valid FCP priority data. num entries = %d.\n",\r\nnum_valid);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nqla24xx_proc_fcp_prio_cfg_cmd(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint ret = 0;\r\nuint32_t len;\r\nuint32_t oper;\r\nif (!(IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha) || IS_QLA82XX(ha))) {\r\nret = -EINVAL;\r\ngoto exit_fcp_prio_cfg;\r\n}\r\noper = bsg_job->request->rqst_data.h_vendor.vendor_cmd[1];\r\nif (!ha->fcp_prio_cfg && (oper != QLFC_FCP_PRIO_SET_CONFIG)) {\r\nret = -EINVAL;\r\ngoto exit_fcp_prio_cfg;\r\n}\r\nswitch (oper) {\r\ncase QLFC_FCP_PRIO_DISABLE:\r\nif (ha->flags.fcp_prio_enabled) {\r\nha->flags.fcp_prio_enabled = 0;\r\nha->fcp_prio_cfg->attributes &=\r\n~FCP_PRIO_ATTR_ENABLE;\r\nqla24xx_update_all_fcp_prio(vha);\r\nbsg_job->reply->result = DID_OK;\r\n} else {\r\nret = -EINVAL;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\ngoto exit_fcp_prio_cfg;\r\n}\r\nbreak;\r\ncase QLFC_FCP_PRIO_ENABLE:\r\nif (!ha->flags.fcp_prio_enabled) {\r\nif (ha->fcp_prio_cfg) {\r\nha->flags.fcp_prio_enabled = 1;\r\nha->fcp_prio_cfg->attributes |=\r\nFCP_PRIO_ATTR_ENABLE;\r\nqla24xx_update_all_fcp_prio(vha);\r\nbsg_job->reply->result = DID_OK;\r\n} else {\r\nret = -EINVAL;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\ngoto exit_fcp_prio_cfg;\r\n}\r\n}\r\nbreak;\r\ncase QLFC_FCP_PRIO_GET_CONFIG:\r\nlen = bsg_job->reply_payload.payload_len;\r\nif (!len || len > FCP_PRIO_CFG_SIZE) {\r\nret = -EINVAL;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\ngoto exit_fcp_prio_cfg;\r\n}\r\nbsg_job->reply->result = DID_OK;\r\nbsg_job->reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(\r\nbsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, ha->fcp_prio_cfg,\r\nlen);\r\nbreak;\r\ncase QLFC_FCP_PRIO_SET_CONFIG:\r\nlen = bsg_job->request_payload.payload_len;\r\nif (!len || len > FCP_PRIO_CFG_SIZE) {\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\nret = -EINVAL;\r\ngoto exit_fcp_prio_cfg;\r\n}\r\nif (!ha->fcp_prio_cfg) {\r\nha->fcp_prio_cfg = vmalloc(FCP_PRIO_CFG_SIZE);\r\nif (!ha->fcp_prio_cfg) {\r\nql_log(ql_log_warn, vha, 0x7050,\r\n"Unable to allocate memory for fcp prio "\r\n"config data (%x).\n", FCP_PRIO_CFG_SIZE);\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\nret = -ENOMEM;\r\ngoto exit_fcp_prio_cfg;\r\n}\r\n}\r\nmemset(ha->fcp_prio_cfg, 0, FCP_PRIO_CFG_SIZE);\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, ha->fcp_prio_cfg,\r\nFCP_PRIO_CFG_SIZE);\r\nif (!qla24xx_fcp_prio_cfg_valid(vha,\r\n(struct qla_fcp_prio_cfg *) ha->fcp_prio_cfg, 1)) {\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\nret = -EINVAL;\r\nvfree(ha->fcp_prio_cfg);\r\nha->fcp_prio_cfg = NULL;\r\ngoto exit_fcp_prio_cfg;\r\n}\r\nha->flags.fcp_prio_enabled = 0;\r\nif (ha->fcp_prio_cfg->attributes & FCP_PRIO_ATTR_ENABLE)\r\nha->flags.fcp_prio_enabled = 1;\r\nqla24xx_update_all_fcp_prio(vha);\r\nbsg_job->reply->result = DID_OK;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nexit_fcp_prio_cfg:\r\nbsg_job->job_done(bsg_job);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla2x00_process_els(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct fc_rport *rport;\r\nfc_port_t *fcport = NULL;\r\nstruct Scsi_Host *host;\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nsrb_t *sp;\r\nconst char *type;\r\nint req_sg_cnt, rsp_sg_cnt;\r\nint rval = (DRIVER_ERROR << 16);\r\nuint16_t nextlid = 0;\r\nif (bsg_job->request->msgcode == FC_BSG_RPT_ELS) {\r\nrport = bsg_job->rport;\r\nfcport = *(fc_port_t **) rport->dd_data;\r\nhost = rport_to_shost(rport);\r\nvha = shost_priv(host);\r\nha = vha->hw;\r\ntype = "FC_BSG_RPT_ELS";\r\n} else {\r\nhost = bsg_job->shost;\r\nvha = shost_priv(host);\r\nha = vha->hw;\r\ntype = "FC_BSG_HST_ELS_NOLOGIN";\r\n}\r\nif (!IS_FWI2_CAPABLE(ha)) {\r\nql_dbg(ql_dbg_user, vha, 0x7001,\r\n"ELS passthru not supported for ISP23xx based adapters.\n");\r\nrval = -EPERM;\r\ngoto done;\r\n}\r\nif (bsg_job->request_payload.sg_cnt > 1 ||\r\nbsg_job->reply_payload.sg_cnt > 1) {\r\nql_dbg(ql_dbg_user, vha, 0x7002,\r\n"Multiple SG's are not suppored for ELS requests, "\r\n"request_sg_cnt=%x reply_sg_cnt=%x.\n",\r\nbsg_job->request_payload.sg_cnt,\r\nbsg_job->reply_payload.sg_cnt);\r\nrval = -EPERM;\r\ngoto done;\r\n}\r\nif (bsg_job->request->msgcode == FC_BSG_RPT_ELS) {\r\nif (qla2x00_fabric_login(vha, fcport, &nextlid)) {\r\nql_dbg(ql_dbg_user, vha, 0x7003,\r\n"Failed to login port %06X for ELS passthru.\n",\r\nfcport->d_id.b24);\r\nrval = -EIO;\r\ngoto done;\r\n}\r\n} else {\r\nfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (!fcport) {\r\nrval = -ENOMEM;\r\ngoto done;\r\n}\r\nfcport->vha = vha;\r\nfcport->d_id.b.al_pa =\r\nbsg_job->request->rqst_data.h_els.port_id[0];\r\nfcport->d_id.b.area =\r\nbsg_job->request->rqst_data.h_els.port_id[1];\r\nfcport->d_id.b.domain =\r\nbsg_job->request->rqst_data.h_els.port_id[2];\r\nfcport->loop_id =\r\n(fcport->d_id.b.al_pa == 0xFD) ?\r\nNPH_FABRIC_CONTROLLER : NPH_F_PORT;\r\n}\r\nif (!vha->flags.online) {\r\nql_log(ql_log_warn, vha, 0x7005, "Host not online.\n");\r\nrval = -EIO;\r\ngoto done;\r\n}\r\nreq_sg_cnt =\r\ndma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nif (!req_sg_cnt) {\r\nrval = -ENOMEM;\r\ngoto done_free_fcport;\r\n}\r\nrsp_sg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\nif (!rsp_sg_cnt) {\r\nrval = -ENOMEM;\r\ngoto done_free_fcport;\r\n}\r\nif ((req_sg_cnt != bsg_job->request_payload.sg_cnt) ||\r\n(rsp_sg_cnt != bsg_job->reply_payload.sg_cnt)) {\r\nql_log(ql_log_warn, vha, 0x7008,\r\n"dma mapping resulted in different sg counts, "\r\n"request_sg_cnt: %x dma_request_sg_cnt:%x reply_sg_cnt:%x "\r\n"dma_reply_sg_cnt:%x.\n", bsg_job->request_payload.sg_cnt,\r\nreq_sg_cnt, bsg_job->reply_payload.sg_cnt, rsp_sg_cnt);\r\nrval = -EAGAIN;\r\ngoto done_unmap_sg;\r\n}\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp) {\r\nrval = -ENOMEM;\r\ngoto done_unmap_sg;\r\n}\r\nsp->type =\r\n(bsg_job->request->msgcode == FC_BSG_RPT_ELS ?\r\nSRB_ELS_CMD_RPT : SRB_ELS_CMD_HST);\r\nsp->name =\r\n(bsg_job->request->msgcode == FC_BSG_RPT_ELS ?\r\n"bsg_els_rpt" : "bsg_els_hst");\r\nsp->u.bsg_job = bsg_job;\r\nsp->free = qla2x00_bsg_sp_free;\r\nsp->done = qla2x00_bsg_job_done;\r\nql_dbg(ql_dbg_user, vha, 0x700a,\r\n"bsg rqst type: %s els type: %x - loop-id=%x "\r\n"portid=%-2x%02x%02x.\n", type,\r\nbsg_job->request->rqst_data.h_els.command_code, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x700e,\r\n"qla2x00_start_sp failed = %d\n", rval);\r\nmempool_free(sp, ha->srb_mempool);\r\nrval = -EIO;\r\ngoto done_unmap_sg;\r\n}\r\nreturn rval;\r\ndone_unmap_sg:\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\ngoto done_free_fcport;\r\ndone_free_fcport:\r\nif (bsg_job->request->msgcode == FC_BSG_HST_ELS_NOLOGIN)\r\nkfree(fcport);\r\ndone:\r\nreturn rval;\r\n}\r\ninline uint16_t\r\nqla24xx_calc_ct_iocbs(uint16_t dsds)\r\n{\r\nuint16_t iocbs;\r\niocbs = 1;\r\nif (dsds > 2) {\r\niocbs += (dsds - 2) / 5;\r\nif ((dsds - 2) % 5)\r\niocbs++;\r\n}\r\nreturn iocbs;\r\n}\r\nstatic int\r\nqla2x00_process_ct(struct fc_bsg_job *bsg_job)\r\n{\r\nsrb_t *sp;\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = (DRIVER_ERROR << 16);\r\nint req_sg_cnt, rsp_sg_cnt;\r\nuint16_t loop_id;\r\nstruct fc_port *fcport;\r\nchar *type = "FC_BSG_HST_CT";\r\nreq_sg_cnt =\r\ndma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nif (!req_sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x700f,\r\n"dma_map_sg return %d for request\n", req_sg_cnt);\r\nrval = -ENOMEM;\r\ngoto done;\r\n}\r\nrsp_sg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\nif (!rsp_sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x7010,\r\n"dma_map_sg return %d for reply\n", rsp_sg_cnt);\r\nrval = -ENOMEM;\r\ngoto done;\r\n}\r\nif ((req_sg_cnt != bsg_job->request_payload.sg_cnt) ||\r\n(rsp_sg_cnt != bsg_job->reply_payload.sg_cnt)) {\r\nql_log(ql_log_warn, vha, 0x7011,\r\n"request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt:%x "\r\n"dma_reply_sg_cnt: %x\n", bsg_job->request_payload.sg_cnt,\r\nreq_sg_cnt, bsg_job->reply_payload.sg_cnt, rsp_sg_cnt);\r\nrval = -EAGAIN;\r\ngoto done_unmap_sg;\r\n}\r\nif (!vha->flags.online) {\r\nql_log(ql_log_warn, vha, 0x7012,\r\n"Host is not online.\n");\r\nrval = -EIO;\r\ngoto done_unmap_sg;\r\n}\r\nloop_id =\r\n(bsg_job->request->rqst_data.h_ct.preamble_word1 & 0xFF000000)\r\n>> 24;\r\nswitch (loop_id) {\r\ncase 0xFC:\r\nloop_id = cpu_to_le16(NPH_SNS);\r\nbreak;\r\ncase 0xFA:\r\nloop_id = vha->mgmt_svr_loop_id;\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_user, vha, 0x7013,\r\n"Unknown loop id: %x.\n", loop_id);\r\nrval = -EINVAL;\r\ngoto done_unmap_sg;\r\n}\r\nfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (!fcport) {\r\nql_log(ql_log_warn, vha, 0x7014,\r\n"Failed to allocate fcport.\n");\r\nrval = -ENOMEM;\r\ngoto done_unmap_sg;\r\n}\r\nfcport->vha = vha;\r\nfcport->d_id.b.al_pa = bsg_job->request->rqst_data.h_ct.port_id[0];\r\nfcport->d_id.b.area = bsg_job->request->rqst_data.h_ct.port_id[1];\r\nfcport->d_id.b.domain = bsg_job->request->rqst_data.h_ct.port_id[2];\r\nfcport->loop_id = loop_id;\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp) {\r\nql_log(ql_log_warn, vha, 0x7015,\r\n"qla2x00_get_sp failed.\n");\r\nrval = -ENOMEM;\r\ngoto done_free_fcport;\r\n}\r\nsp->type = SRB_CT_CMD;\r\nsp->name = "bsg_ct";\r\nsp->iocbs = qla24xx_calc_ct_iocbs(req_sg_cnt + rsp_sg_cnt);\r\nsp->u.bsg_job = bsg_job;\r\nsp->free = qla2x00_bsg_sp_free;\r\nsp->done = qla2x00_bsg_job_done;\r\nql_dbg(ql_dbg_user, vha, 0x7016,\r\n"bsg rqst type: %s else type: %x - "\r\n"loop-id=%x portid=%02x%02x%02x.\n", type,\r\n(bsg_job->request->rqst_data.h_ct.preamble_word2 >> 16),\r\nfcport->loop_id, fcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7017,\r\n"qla2x00_start_sp failed=%d.\n", rval);\r\nmempool_free(sp, ha->srb_mempool);\r\nrval = -EIO;\r\ngoto done_free_fcport;\r\n}\r\nreturn rval;\r\ndone_free_fcport:\r\nkfree(fcport);\r\ndone_unmap_sg:\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\ndone:\r\nreturn rval;\r\n}\r\nstatic inline int\r\nqla81xx_set_internal_loopback(scsi_qla_host_t *vha, uint16_t *config,\r\nuint16_t *new_config)\r\n{\r\nint ret = 0;\r\nint rval = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\r\ngoto done_set_internal;\r\nnew_config[0] = config[0] | (ENABLE_INTERNAL_LOOPBACK << 1);\r\nmemcpy(&new_config[1], &config[1], sizeof(uint16_t) * 3) ;\r\nha->notify_dcbx_comp = 1;\r\nret = qla81xx_set_port_config(vha, new_config);\r\nif (ret != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7021,\r\n"set port config failed.\n");\r\nha->notify_dcbx_comp = 0;\r\nrval = -EINVAL;\r\ngoto done_set_internal;\r\n}\r\nif (!wait_for_completion_timeout(&ha->dcbx_comp, (20 * HZ))) {\r\nql_dbg(ql_dbg_user, vha, 0x7022,\r\n"State change notification not received.\n");\r\n} else\r\nql_dbg(ql_dbg_user, vha, 0x7023,\r\n"State change received.\n");\r\nha->notify_dcbx_comp = 0;\r\ndone_set_internal:\r\nreturn rval;\r\n}\r\nstatic inline int\r\nqla81xx_reset_internal_loopback(scsi_qla_host_t *vha, uint16_t *config,\r\nint wait)\r\n{\r\nint ret = 0;\r\nint rval = 0;\r\nuint16_t new_config[4];\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\r\ngoto done_reset_internal;\r\nmemset(new_config, 0 , sizeof(new_config));\r\nif ((config[0] & INTERNAL_LOOPBACK_MASK) >> 1 ==\r\nENABLE_INTERNAL_LOOPBACK) {\r\nnew_config[0] = config[0] & ~INTERNAL_LOOPBACK_MASK;\r\nmemcpy(&new_config[1], &config[1], sizeof(uint16_t) * 3) ;\r\nha->notify_dcbx_comp = wait;\r\nret = qla81xx_set_port_config(vha, new_config);\r\nif (ret != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7025,\r\n"Set port config failed.\n");\r\nha->notify_dcbx_comp = 0;\r\nrval = -EINVAL;\r\ngoto done_reset_internal;\r\n}\r\nif (wait && !wait_for_completion_timeout(&ha->dcbx_comp,\r\n(20 * HZ))) {\r\nql_dbg(ql_dbg_user, vha, 0x7026,\r\n"State change notification not received.\n");\r\nha->notify_dcbx_comp = 0;\r\nrval = -EINVAL;\r\ngoto done_reset_internal;\r\n} else\r\nql_dbg(ql_dbg_user, vha, 0x7027,\r\n"State change received.\n");\r\nha->notify_dcbx_comp = 0;\r\n}\r\ndone_reset_internal:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_process_loopback(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval;\r\nuint8_t command_sent;\r\nchar *type;\r\nstruct msg_echo_lb elreq;\r\nuint16_t response[MAILBOX_REGISTER_COUNT];\r\nuint16_t config[4], new_config[4];\r\nuint8_t *fw_sts_ptr;\r\nuint8_t *req_data = NULL;\r\ndma_addr_t req_data_dma;\r\nuint32_t req_data_len;\r\nuint8_t *rsp_data = NULL;\r\ndma_addr_t rsp_data_dma;\r\nuint32_t rsp_data_len;\r\nif (!vha->flags.online) {\r\nql_log(ql_log_warn, vha, 0x7019, "Host is not online.\n");\r\nreturn -EIO;\r\n}\r\nelreq.req_sg_cnt = dma_map_sg(&ha->pdev->dev,\r\nbsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,\r\nDMA_TO_DEVICE);\r\nif (!elreq.req_sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x701a,\r\n"dma_map_sg returned %d for request.\n", elreq.req_sg_cnt);\r\nreturn -ENOMEM;\r\n}\r\nelreq.rsp_sg_cnt = dma_map_sg(&ha->pdev->dev,\r\nbsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,\r\nDMA_FROM_DEVICE);\r\nif (!elreq.rsp_sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x701b,\r\n"dma_map_sg returned %d for reply.\n", elreq.rsp_sg_cnt);\r\nrval = -ENOMEM;\r\ngoto done_unmap_req_sg;\r\n}\r\nif ((elreq.req_sg_cnt != bsg_job->request_payload.sg_cnt) ||\r\n(elreq.rsp_sg_cnt != bsg_job->reply_payload.sg_cnt)) {\r\nql_log(ql_log_warn, vha, 0x701c,\r\n"dma mapping resulted in different sg counts, "\r\n"request_sg_cnt: %x dma_request_sg_cnt: %x "\r\n"reply_sg_cnt: %x dma_reply_sg_cnt: %x.\n",\r\nbsg_job->request_payload.sg_cnt, elreq.req_sg_cnt,\r\nbsg_job->reply_payload.sg_cnt, elreq.rsp_sg_cnt);\r\nrval = -EAGAIN;\r\ngoto done_unmap_sg;\r\n}\r\nreq_data_len = rsp_data_len = bsg_job->request_payload.payload_len;\r\nreq_data = dma_alloc_coherent(&ha->pdev->dev, req_data_len,\r\n&req_data_dma, GFP_KERNEL);\r\nif (!req_data) {\r\nql_log(ql_log_warn, vha, 0x701d,\r\n"dma alloc failed for req_data.\n");\r\nrval = -ENOMEM;\r\ngoto done_unmap_sg;\r\n}\r\nrsp_data = dma_alloc_coherent(&ha->pdev->dev, rsp_data_len,\r\n&rsp_data_dma, GFP_KERNEL);\r\nif (!rsp_data) {\r\nql_log(ql_log_warn, vha, 0x7004,\r\n"dma alloc failed for rsp_data.\n");\r\nrval = -ENOMEM;\r\ngoto done_free_dma_req;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, req_data, req_data_len);\r\nelreq.send_dma = req_data_dma;\r\nelreq.rcv_dma = rsp_data_dma;\r\nelreq.transfer_size = req_data_len;\r\nelreq.options = bsg_job->request->rqst_data.h_vendor.vendor_cmd[1];\r\nif ((ha->current_topology == ISP_CFG_F ||\r\n((IS_QLA81XX(ha) || IS_QLA8031(ha)) &&\r\nle32_to_cpu(*(uint32_t *)req_data) == ELS_OPCODE_BYTE\r\n&& req_data_len == MAX_ELS_FRAME_PAYLOAD)) &&\r\nelreq.options == EXTERNAL_LOOPBACK) {\r\ntype = "FC_BSG_HST_VENDOR_ECHO_DIAG";\r\nql_dbg(ql_dbg_user, vha, 0x701e,\r\n"BSG request type: %s.\n", type);\r\ncommand_sent = INT_DEF_LB_ECHO_CMD;\r\nrval = qla2x00_echo_test(vha, &elreq, response);\r\n} else {\r\nif (IS_QLA81XX(ha) || IS_QLA8031(ha)) {\r\nmemset(config, 0, sizeof(config));\r\nmemset(new_config, 0, sizeof(new_config));\r\nif (qla81xx_get_port_config(vha, config)) {\r\nql_log(ql_log_warn, vha, 0x701f,\r\n"Get port config failed.\n");\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\nrval = -EPERM;\r\ngoto done_free_dma_req;\r\n}\r\nif (elreq.options != EXTERNAL_LOOPBACK) {\r\nql_dbg(ql_dbg_user, vha, 0x7020,\r\n"Internal: current port config = %x\n",\r\nconfig[0]);\r\nif (qla81xx_set_internal_loopback(vha, config,\r\nnew_config)) {\r\nql_log(ql_log_warn, vha, 0x7024,\r\n"Internal loopback failed.\n");\r\nbsg_job->reply->result =\r\n(DID_ERROR << 16);\r\nrval = -EPERM;\r\ngoto done_free_dma_req;\r\n}\r\n} else {\r\nif (qla81xx_reset_internal_loopback(vha,\r\nconfig, 1)) {\r\nbsg_job->reply->result =\r\n(DID_ERROR << 16);\r\nrval = -EPERM;\r\ngoto done_free_dma_req;\r\n}\r\n}\r\ntype = "FC_BSG_HST_VENDOR_LOOPBACK";\r\nql_dbg(ql_dbg_user, vha, 0x7028,\r\n"BSG request type: %s.\n", type);\r\ncommand_sent = INT_DEF_LB_LOOPBACK_CMD;\r\nrval = qla2x00_loopback_test(vha, &elreq, response);\r\nif (new_config[0]) {\r\nqla81xx_reset_internal_loopback(vha,\r\nnew_config, 0);\r\n}\r\nif (response[0] == MBS_COMMAND_ERROR &&\r\nresponse[1] == MBS_LB_RESET) {\r\nql_log(ql_log_warn, vha, 0x7029,\r\n"MBX command error, Aborting ISP.\n");\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nqla2x00_wait_for_chip_reset(vha);\r\nif (qla81xx_restart_mpi_firmware(vha) !=\r\nQLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x702a,\r\n"MPI reset failed.\n");\r\n}\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\nrval = -EIO;\r\ngoto done_free_dma_req;\r\n}\r\n} else {\r\ntype = "FC_BSG_HST_VENDOR_LOOPBACK";\r\nql_dbg(ql_dbg_user, vha, 0x702b,\r\n"BSG request type: %s.\n", type);\r\ncommand_sent = INT_DEF_LB_LOOPBACK_CMD;\r\nrval = qla2x00_loopback_test(vha, &elreq, response);\r\n}\r\n}\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x702c,\r\n"Vendor request %s failed.\n", type);\r\nfw_sts_ptr = ((uint8_t *)bsg_job->req->sense) +\r\nsizeof(struct fc_bsg_reply);\r\nmemcpy(fw_sts_ptr, response, sizeof(response));\r\nfw_sts_ptr += sizeof(response);\r\n*fw_sts_ptr = command_sent;\r\nrval = 0;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\n} else {\r\nql_dbg(ql_dbg_user, vha, 0x702d,\r\n"Vendor request %s completed.\n", type);\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply) +\r\nsizeof(response) + sizeof(uint8_t);\r\nbsg_job->reply->reply_payload_rcv_len =\r\nbsg_job->reply_payload.payload_len;\r\nfw_sts_ptr = ((uint8_t *)bsg_job->req->sense) +\r\nsizeof(struct fc_bsg_reply);\r\nmemcpy(fw_sts_ptr, response, sizeof(response));\r\nfw_sts_ptr += sizeof(response);\r\n*fw_sts_ptr = command_sent;\r\nbsg_job->reply->result = DID_OK;\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, rsp_data,\r\nrsp_data_len);\r\n}\r\nbsg_job->job_done(bsg_job);\r\ndma_free_coherent(&ha->pdev->dev, rsp_data_len,\r\nrsp_data, rsp_data_dma);\r\ndone_free_dma_req:\r\ndma_free_coherent(&ha->pdev->dev, req_data_len,\r\nreq_data, req_data_dma);\r\ndone_unmap_sg:\r\ndma_unmap_sg(&ha->pdev->dev,\r\nbsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\ndone_unmap_req_sg:\r\ndma_unmap_sg(&ha->pdev->dev,\r\nbsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla84xx_reset(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = 0;\r\nuint32_t flag;\r\nif (!IS_QLA84XX(ha)) {\r\nql_dbg(ql_dbg_user, vha, 0x702f, "Not 84xx, exiting.\n");\r\nreturn -EINVAL;\r\n}\r\nflag = bsg_job->request->rqst_data.h_vendor.vendor_cmd[1];\r\nrval = qla84xx_reset_chip(vha, flag == A84_ISSUE_RESET_DIAG_FW);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x7030,\r\n"Vendor request 84xx reset failed.\n");\r\nrval = 0;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\n} else {\r\nql_dbg(ql_dbg_user, vha, 0x7031,\r\n"Vendor request 84xx reset completed.\n");\r\nbsg_job->reply->result = DID_OK;\r\n}\r\nbsg_job->job_done(bsg_job);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla84xx_updatefw(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct verify_chip_entry_84xx *mn = NULL;\r\ndma_addr_t mn_dma, fw_dma;\r\nvoid *fw_buf = NULL;\r\nint rval = 0;\r\nuint32_t sg_cnt;\r\nuint32_t data_len;\r\nuint16_t options;\r\nuint32_t flag;\r\nuint32_t fw_ver;\r\nif (!IS_QLA84XX(ha)) {\r\nql_dbg(ql_dbg_user, vha, 0x7032,\r\n"Not 84xx, exiting.\n");\r\nreturn -EINVAL;\r\n}\r\nsg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nif (!sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x7033,\r\n"dma_map_sg returned %d for request.\n", sg_cnt);\r\nreturn -ENOMEM;\r\n}\r\nif (sg_cnt != bsg_job->request_payload.sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x7034,\r\n"DMA mapping resulted in different sg counts, "\r\n"request_sg_cnt: %x dma_request_sg_cnt: %x.\n",\r\nbsg_job->request_payload.sg_cnt, sg_cnt);\r\nrval = -EAGAIN;\r\ngoto done_unmap_sg;\r\n}\r\ndata_len = bsg_job->request_payload.payload_len;\r\nfw_buf = dma_alloc_coherent(&ha->pdev->dev, data_len,\r\n&fw_dma, GFP_KERNEL);\r\nif (!fw_buf) {\r\nql_log(ql_log_warn, vha, 0x7035,\r\n"DMA alloc failed for fw_buf.\n");\r\nrval = -ENOMEM;\r\ngoto done_unmap_sg;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, fw_buf, data_len);\r\nmn = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &mn_dma);\r\nif (!mn) {\r\nql_log(ql_log_warn, vha, 0x7036,\r\n"DMA alloc failed for fw buffer.\n");\r\nrval = -ENOMEM;\r\ngoto done_free_fw_buf;\r\n}\r\nflag = bsg_job->request->rqst_data.h_vendor.vendor_cmd[1];\r\nfw_ver = le32_to_cpu(*((uint32_t *)((uint32_t *)fw_buf + 2)));\r\nmemset(mn, 0, sizeof(struct access_chip_84xx));\r\nmn->entry_type = VERIFY_CHIP_IOCB_TYPE;\r\nmn->entry_count = 1;\r\noptions = VCO_FORCE_UPDATE | VCO_END_OF_DATA;\r\nif (flag == A84_ISSUE_UPDATE_DIAGFW_CMD)\r\noptions |= VCO_DIAG_FW;\r\nmn->options = cpu_to_le16(options);\r\nmn->fw_ver = cpu_to_le32(fw_ver);\r\nmn->fw_size = cpu_to_le32(data_len);\r\nmn->fw_seq_size = cpu_to_le32(data_len);\r\nmn->dseg_address[0] = cpu_to_le32(LSD(fw_dma));\r\nmn->dseg_address[1] = cpu_to_le32(MSD(fw_dma));\r\nmn->dseg_length = cpu_to_le32(data_len);\r\nmn->data_seg_cnt = cpu_to_le16(1);\r\nrval = qla2x00_issue_iocb_timeout(vha, mn, mn_dma, 0, 120);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x7037,\r\n"Vendor request 84xx updatefw failed.\n");\r\nrval = 0;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\n} else {\r\nql_dbg(ql_dbg_user, vha, 0x7038,\r\n"Vendor request 84xx updatefw completed.\n");\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply);\r\nbsg_job->reply->result = DID_OK;\r\n}\r\nbsg_job->job_done(bsg_job);\r\ndma_pool_free(ha->s_dma_pool, mn, mn_dma);\r\ndone_free_fw_buf:\r\ndma_free_coherent(&ha->pdev->dev, data_len, fw_buf, fw_dma);\r\ndone_unmap_sg:\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla84xx_mgmt_cmd(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct access_chip_84xx *mn = NULL;\r\ndma_addr_t mn_dma, mgmt_dma;\r\nvoid *mgmt_b = NULL;\r\nint rval = 0;\r\nstruct qla_bsg_a84_mgmt *ql84_mgmt;\r\nuint32_t sg_cnt;\r\nuint32_t data_len = 0;\r\nuint32_t dma_direction = DMA_NONE;\r\nif (!IS_QLA84XX(ha)) {\r\nql_log(ql_log_warn, vha, 0x703a,\r\n"Not 84xx, exiting.\n");\r\nreturn -EINVAL;\r\n}\r\nql84_mgmt = (struct qla_bsg_a84_mgmt *)((char *)bsg_job->request +\r\nsizeof(struct fc_bsg_request));\r\nif (!ql84_mgmt) {\r\nql_log(ql_log_warn, vha, 0x703b,\r\n"MGMT header not provided, exiting.\n");\r\nreturn -EINVAL;\r\n}\r\nmn = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &mn_dma);\r\nif (!mn) {\r\nql_log(ql_log_warn, vha, 0x703c,\r\n"DMA alloc failed for fw buffer.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(mn, 0, sizeof(struct access_chip_84xx));\r\nmn->entry_type = ACCESS_CHIP_IOCB_TYPE;\r\nmn->entry_count = 1;\r\nswitch (ql84_mgmt->mgmt.cmd) {\r\ncase QLA84_MGMT_READ_MEM:\r\ncase QLA84_MGMT_GET_INFO:\r\nsg_cnt = dma_map_sg(&ha->pdev->dev,\r\nbsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\nif (!sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x703d,\r\n"dma_map_sg returned %d for reply.\n", sg_cnt);\r\nrval = -ENOMEM;\r\ngoto exit_mgmt;\r\n}\r\ndma_direction = DMA_FROM_DEVICE;\r\nif (sg_cnt != bsg_job->reply_payload.sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x703e,\r\n"DMA mapping resulted in different sg counts, "\r\n"reply_sg_cnt: %x dma_reply_sg_cnt: %x.\n",\r\nbsg_job->reply_payload.sg_cnt, sg_cnt);\r\nrval = -EAGAIN;\r\ngoto done_unmap_sg;\r\n}\r\ndata_len = bsg_job->reply_payload.payload_len;\r\nmgmt_b = dma_alloc_coherent(&ha->pdev->dev, data_len,\r\n&mgmt_dma, GFP_KERNEL);\r\nif (!mgmt_b) {\r\nql_log(ql_log_warn, vha, 0x703f,\r\n"DMA alloc failed for mgmt_b.\n");\r\nrval = -ENOMEM;\r\ngoto done_unmap_sg;\r\n}\r\nif (ql84_mgmt->mgmt.cmd == QLA84_MGMT_READ_MEM) {\r\nmn->options = cpu_to_le16(ACO_DUMP_MEMORY);\r\nmn->parameter1 =\r\ncpu_to_le32(\r\nql84_mgmt->mgmt.mgmtp.u.mem.start_addr);\r\n} else if (ql84_mgmt->mgmt.cmd == QLA84_MGMT_GET_INFO) {\r\nmn->options = cpu_to_le16(ACO_REQUEST_INFO);\r\nmn->parameter1 =\r\ncpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.info.type);\r\nmn->parameter2 =\r\ncpu_to_le32(\r\nql84_mgmt->mgmt.mgmtp.u.info.context);\r\n}\r\nbreak;\r\ncase QLA84_MGMT_WRITE_MEM:\r\nsg_cnt = dma_map_sg(&ha->pdev->dev,\r\nbsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nif (!sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x7040,\r\n"dma_map_sg returned %d.\n", sg_cnt);\r\nrval = -ENOMEM;\r\ngoto exit_mgmt;\r\n}\r\ndma_direction = DMA_TO_DEVICE;\r\nif (sg_cnt != bsg_job->request_payload.sg_cnt) {\r\nql_log(ql_log_warn, vha, 0x7041,\r\n"DMA mapping resulted in different sg counts, "\r\n"request_sg_cnt: %x dma_request_sg_cnt: %x.\n",\r\nbsg_job->request_payload.sg_cnt, sg_cnt);\r\nrval = -EAGAIN;\r\ngoto done_unmap_sg;\r\n}\r\ndata_len = bsg_job->request_payload.payload_len;\r\nmgmt_b = dma_alloc_coherent(&ha->pdev->dev, data_len,\r\n&mgmt_dma, GFP_KERNEL);\r\nif (!mgmt_b) {\r\nql_log(ql_log_warn, vha, 0x7042,\r\n"DMA alloc failed for mgmt_b.\n");\r\nrval = -ENOMEM;\r\ngoto done_unmap_sg;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, mgmt_b, data_len);\r\nmn->options = cpu_to_le16(ACO_LOAD_MEMORY);\r\nmn->parameter1 =\r\ncpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.mem.start_addr);\r\nbreak;\r\ncase QLA84_MGMT_CHNG_CONFIG:\r\nmn->options = cpu_to_le16(ACO_CHANGE_CONFIG_PARAM);\r\nmn->parameter1 =\r\ncpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.config.id);\r\nmn->parameter2 =\r\ncpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.config.param0);\r\nmn->parameter3 =\r\ncpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.config.param1);\r\nbreak;\r\ndefault:\r\nrval = -EIO;\r\ngoto exit_mgmt;\r\n}\r\nif (ql84_mgmt->mgmt.cmd != QLA84_MGMT_CHNG_CONFIG) {\r\nmn->total_byte_cnt = cpu_to_le32(ql84_mgmt->mgmt.len);\r\nmn->dseg_count = cpu_to_le16(1);\r\nmn->dseg_address[0] = cpu_to_le32(LSD(mgmt_dma));\r\nmn->dseg_address[1] = cpu_to_le32(MSD(mgmt_dma));\r\nmn->dseg_length = cpu_to_le32(ql84_mgmt->mgmt.len);\r\n}\r\nrval = qla2x00_issue_iocb(vha, mn, mn_dma, 0);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x7043,\r\n"Vendor request 84xx mgmt failed.\n");\r\nrval = 0;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\n} else {\r\nql_dbg(ql_dbg_user, vha, 0x7044,\r\n"Vendor request 84xx mgmt completed.\n");\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply);\r\nbsg_job->reply->result = DID_OK;\r\nif ((ql84_mgmt->mgmt.cmd == QLA84_MGMT_READ_MEM) ||\r\n(ql84_mgmt->mgmt.cmd == QLA84_MGMT_GET_INFO)) {\r\nbsg_job->reply->reply_payload_rcv_len =\r\nbsg_job->reply_payload.payload_len;\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, mgmt_b,\r\ndata_len);\r\n}\r\n}\r\nbsg_job->job_done(bsg_job);\r\ndone_unmap_sg:\r\nif (mgmt_b)\r\ndma_free_coherent(&ha->pdev->dev, data_len, mgmt_b, mgmt_dma);\r\nif (dma_direction == DMA_TO_DEVICE)\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\r\nelse if (dma_direction == DMA_FROM_DEVICE)\r\ndma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\r\nexit_mgmt:\r\ndma_pool_free(ha->s_dma_pool, mn, mn_dma);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla24xx_iidma(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nint rval = 0;\r\nstruct qla_port_param *port_param = NULL;\r\nfc_port_t *fcport = NULL;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nuint8_t *rsp_ptr = NULL;\r\nif (!IS_IIDMA_CAPABLE(vha->hw)) {\r\nql_log(ql_log_info, vha, 0x7046, "iiDMA not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nport_param = (struct qla_port_param *)((char *)bsg_job->request +\r\nsizeof(struct fc_bsg_request));\r\nif (!port_param) {\r\nql_log(ql_log_warn, vha, 0x7047,\r\n"port_param header not provided.\n");\r\nreturn -EINVAL;\r\n}\r\nif (port_param->fc_scsi_addr.dest_type != EXT_DEF_TYPE_WWPN) {\r\nql_log(ql_log_warn, vha, 0x7048,\r\n"Invalid destination type.\n");\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (fcport->port_type != FCT_TARGET)\r\ncontinue;\r\nif (memcmp(port_param->fc_scsi_addr.dest_addr.wwpn,\r\nfcport->port_name, sizeof(fcport->port_name)))\r\ncontinue;\r\nbreak;\r\n}\r\nif (!fcport) {\r\nql_log(ql_log_warn, vha, 0x7049,\r\n"Failed to find port.\n");\r\nreturn -EINVAL;\r\n}\r\nif (atomic_read(&fcport->state) != FCS_ONLINE) {\r\nql_log(ql_log_warn, vha, 0x704a,\r\n"Port is not online.\n");\r\nreturn -EINVAL;\r\n}\r\nif (fcport->flags & FCF_LOGIN_NEEDED) {\r\nql_log(ql_log_warn, vha, 0x704b,\r\n"Remote port not logged in flags = 0x%x.\n", fcport->flags);\r\nreturn -EINVAL;\r\n}\r\nif (port_param->mode)\r\nrval = qla2x00_set_idma_speed(vha, fcport->loop_id,\r\nport_param->speed, mb);\r\nelse\r\nrval = qla2x00_get_idma_speed(vha, fcport->loop_id,\r\n&port_param->speed, mb);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x704c,\r\n"iIDMA cmd failed for %02x%02x%02x%02x%02x%02x%02x%02x -- "\r\n"%04x %x %04x %04x.\n", fcport->port_name[0],\r\nfcport->port_name[1], fcport->port_name[2],\r\nfcport->port_name[3], fcport->port_name[4],\r\nfcport->port_name[5], fcport->port_name[6],\r\nfcport->port_name[7], rval, fcport->fp_speed, mb[0], mb[1]);\r\nrval = 0;\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\n} else {\r\nif (!port_param->mode) {\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply) +\r\nsizeof(struct qla_port_param);\r\nrsp_ptr = ((uint8_t *)bsg_job->reply) +\r\nsizeof(struct fc_bsg_reply);\r\nmemcpy(rsp_ptr, port_param,\r\nsizeof(struct qla_port_param));\r\n}\r\nbsg_job->reply->result = DID_OK;\r\n}\r\nbsg_job->job_done(bsg_job);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_optrom_setup(struct fc_bsg_job *bsg_job, scsi_qla_host_t *vha,\r\nuint8_t is_update)\r\n{\r\nuint32_t start = 0;\r\nint valid = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn -EINVAL;\r\nstart = bsg_job->request->rqst_data.h_vendor.vendor_cmd[1];\r\nif (start > ha->optrom_size) {\r\nql_log(ql_log_warn, vha, 0x7055,\r\n"start %d > optrom_size %d.\n", start, ha->optrom_size);\r\nreturn -EINVAL;\r\n}\r\nif (ha->optrom_state != QLA_SWAITING) {\r\nql_log(ql_log_info, vha, 0x7056,\r\n"optrom_state %d.\n", ha->optrom_state);\r\nreturn -EBUSY;\r\n}\r\nha->optrom_region_start = start;\r\nql_dbg(ql_dbg_user, vha, 0x7057, "is_update=%d.\n", is_update);\r\nif (is_update) {\r\nif (ha->optrom_size == OPTROM_SIZE_2300 && start == 0)\r\nvalid = 1;\r\nelse if (start == (ha->flt_region_boot * 4) ||\r\nstart == (ha->flt_region_fw * 4))\r\nvalid = 1;\r\nelse if (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha) ||\r\nIS_CNA_CAPABLE(ha) || IS_QLA2031(ha))\r\nvalid = 1;\r\nif (!valid) {\r\nql_log(ql_log_warn, vha, 0x7058,\r\n"Invalid start region 0x%x/0x%x.\n", start,\r\nbsg_job->request_payload.payload_len);\r\nreturn -EINVAL;\r\n}\r\nha->optrom_region_size = start +\r\nbsg_job->request_payload.payload_len > ha->optrom_size ?\r\nha->optrom_size - start :\r\nbsg_job->request_payload.payload_len;\r\nha->optrom_state = QLA_SWRITING;\r\n} else {\r\nha->optrom_region_size = start +\r\nbsg_job->reply_payload.payload_len > ha->optrom_size ?\r\nha->optrom_size - start :\r\nbsg_job->reply_payload.payload_len;\r\nha->optrom_state = QLA_SREADING;\r\n}\r\nha->optrom_buffer = vmalloc(ha->optrom_region_size);\r\nif (!ha->optrom_buffer) {\r\nql_log(ql_log_warn, vha, 0x7059,\r\n"Read: Unable to allocate memory for optrom retrieval "\r\n"(%x)\n", ha->optrom_region_size);\r\nha->optrom_state = QLA_SWAITING;\r\nreturn -ENOMEM;\r\n}\r\nmemset(ha->optrom_buffer, 0, ha->optrom_region_size);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla2x00_read_optrom(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = 0;\r\nif (ha->flags.isp82xx_reset_hdlr_active)\r\nreturn -EBUSY;\r\nrval = qla2x00_optrom_setup(bsg_job, vha, 0);\r\nif (rval)\r\nreturn rval;\r\nha->isp_ops->read_optrom(vha, ha->optrom_buffer,\r\nha->optrom_region_start, ha->optrom_region_size);\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, ha->optrom_buffer,\r\nha->optrom_region_size);\r\nbsg_job->reply->reply_payload_rcv_len = ha->optrom_region_size;\r\nbsg_job->reply->result = DID_OK;\r\nvfree(ha->optrom_buffer);\r\nha->optrom_buffer = NULL;\r\nha->optrom_state = QLA_SWAITING;\r\nbsg_job->job_done(bsg_job);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_update_optrom(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = 0;\r\nrval = qla2x00_optrom_setup(bsg_job, vha, 1);\r\nif (rval)\r\nreturn rval;\r\nha->flags.isp82xx_no_md_cap = 1;\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, ha->optrom_buffer,\r\nha->optrom_region_size);\r\nha->isp_ops->write_optrom(vha, ha->optrom_buffer,\r\nha->optrom_region_start, ha->optrom_region_size);\r\nbsg_job->reply->result = DID_OK;\r\nvfree(ha->optrom_buffer);\r\nha->optrom_buffer = NULL;\r\nha->optrom_state = QLA_SWAITING;\r\nbsg_job->job_done(bsg_job);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_update_fru_versions(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = 0;\r\nuint8_t bsg[DMA_POOL_SIZE];\r\nstruct qla_image_version_list *list = (void *)bsg;\r\nstruct qla_image_version *image;\r\nuint32_t count;\r\ndma_addr_t sfp_dma;\r\nvoid *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\r\nif (!sfp) {\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =\r\nEXT_STATUS_NO_MEMORY;\r\ngoto done;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, list, sizeof(bsg));\r\nimage = list->version;\r\ncount = list->count;\r\nwhile (count--) {\r\nmemcpy(sfp, &image->field_info, sizeof(image->field_info));\r\nrval = qla2x00_write_sfp(vha, sfp_dma, sfp,\r\nimage->field_address.device, image->field_address.offset,\r\nsizeof(image->field_info), image->field_address.option);\r\nif (rval) {\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =\r\nEXT_STATUS_MAILBOX;\r\ngoto dealloc;\r\n}\r\nimage++;\r\n}\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\r\ndealloc:\r\ndma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\r\ndone:\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply);\r\nbsg_job->reply->result = DID_OK << 16;\r\nbsg_job->job_done(bsg_job);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla2x00_read_fru_status(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = 0;\r\nuint8_t bsg[DMA_POOL_SIZE];\r\nstruct qla_status_reg *sr = (void *)bsg;\r\ndma_addr_t sfp_dma;\r\nuint8_t *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\r\nif (!sfp) {\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =\r\nEXT_STATUS_NO_MEMORY;\r\ngoto done;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, sr, sizeof(*sr));\r\nrval = qla2x00_read_sfp(vha, sfp_dma, sfp,\r\nsr->field_address.device, sr->field_address.offset,\r\nsizeof(sr->status_reg), sr->field_address.option);\r\nsr->status_reg = *sfp;\r\nif (rval) {\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =\r\nEXT_STATUS_MAILBOX;\r\ngoto dealloc;\r\n}\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt, sr, sizeof(*sr));\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\r\ndealloc:\r\ndma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\r\ndone:\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply);\r\nbsg_job->reply->reply_payload_rcv_len = sizeof(*sr);\r\nbsg_job->reply->result = DID_OK << 16;\r\nbsg_job->job_done(bsg_job);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla2x00_write_fru_status(struct fc_bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = bsg_job->shost;\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = 0;\r\nuint8_t bsg[DMA_POOL_SIZE];\r\nstruct qla_status_reg *sr = (void *)bsg;\r\ndma_addr_t sfp_dma;\r\nuint8_t *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\r\nif (!sfp) {\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =\r\nEXT_STATUS_NO_MEMORY;\r\ngoto done;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, sr, sizeof(*sr));\r\n*sfp = sr->status_reg;\r\nrval = qla2x00_write_sfp(vha, sfp_dma, sfp,\r\nsr->field_address.device, sr->field_address.offset,\r\nsizeof(sr->status_reg), sr->field_address.option);\r\nif (rval) {\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] =\r\nEXT_STATUS_MAILBOX;\r\ngoto dealloc;\r\n}\r\nbsg_job->reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\r\ndealloc:\r\ndma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\r\ndone:\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply);\r\nbsg_job->reply->result = DID_OK << 16;\r\nbsg_job->job_done(bsg_job);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla2x00_process_vendor_specific(struct fc_bsg_job *bsg_job)\r\n{\r\nswitch (bsg_job->request->rqst_data.h_vendor.vendor_cmd[0]) {\r\ncase QL_VND_LOOPBACK:\r\nreturn qla2x00_process_loopback(bsg_job);\r\ncase QL_VND_A84_RESET:\r\nreturn qla84xx_reset(bsg_job);\r\ncase QL_VND_A84_UPDATE_FW:\r\nreturn qla84xx_updatefw(bsg_job);\r\ncase QL_VND_A84_MGMT_CMD:\r\nreturn qla84xx_mgmt_cmd(bsg_job);\r\ncase QL_VND_IIDMA:\r\nreturn qla24xx_iidma(bsg_job);\r\ncase QL_VND_FCP_PRIO_CFG_CMD:\r\nreturn qla24xx_proc_fcp_prio_cfg_cmd(bsg_job);\r\ncase QL_VND_READ_FLASH:\r\nreturn qla2x00_read_optrom(bsg_job);\r\ncase QL_VND_UPDATE_FLASH:\r\nreturn qla2x00_update_optrom(bsg_job);\r\ncase QL_VND_SET_FRU_VERSION:\r\nreturn qla2x00_update_fru_versions(bsg_job);\r\ncase QL_VND_READ_FRU_STATUS:\r\nreturn qla2x00_read_fru_status(bsg_job);\r\ncase QL_VND_WRITE_FRU_STATUS:\r\nreturn qla2x00_write_fru_status(bsg_job);\r\ndefault:\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\nbsg_job->job_done(bsg_job);\r\nreturn -ENOSYS;\r\n}\r\n}\r\nint\r\nqla24xx_bsg_request(struct fc_bsg_job *bsg_job)\r\n{\r\nint ret = -EINVAL;\r\nstruct fc_rport *rport;\r\nfc_port_t *fcport = NULL;\r\nstruct Scsi_Host *host;\r\nscsi_qla_host_t *vha;\r\nbsg_job->reply->reply_payload_rcv_len = 0;\r\nif (bsg_job->request->msgcode == FC_BSG_RPT_ELS) {\r\nrport = bsg_job->rport;\r\nfcport = *(fc_port_t **) rport->dd_data;\r\nhost = rport_to_shost(rport);\r\nvha = shost_priv(host);\r\n} else {\r\nhost = bsg_job->shost;\r\nvha = shost_priv(host);\r\n}\r\nif (qla2x00_reset_active(vha)) {\r\nql_dbg(ql_dbg_user, vha, 0x709f,\r\n"BSG: ISP abort active/needed -- cmd=%d.\n",\r\nbsg_job->request->msgcode);\r\nbsg_job->reply->result = (DID_ERROR << 16);\r\nbsg_job->job_done(bsg_job);\r\nreturn -EBUSY;\r\n}\r\nql_dbg(ql_dbg_user, vha, 0x7000,\r\n"Entered %s msgcode=0x%x.\n", __func__, bsg_job->request->msgcode);\r\nswitch (bsg_job->request->msgcode) {\r\ncase FC_BSG_RPT_ELS:\r\ncase FC_BSG_HST_ELS_NOLOGIN:\r\nret = qla2x00_process_els(bsg_job);\r\nbreak;\r\ncase FC_BSG_HST_CT:\r\nret = qla2x00_process_ct(bsg_job);\r\nbreak;\r\ncase FC_BSG_HST_VENDOR:\r\nret = qla2x00_process_vendor_specific(bsg_job);\r\nbreak;\r\ncase FC_BSG_HST_ADD_RPORT:\r\ncase FC_BSG_HST_DEL_RPORT:\r\ncase FC_BSG_RPT_CT:\r\ndefault:\r\nql_log(ql_log_warn, vha, 0x705a, "Unsupported BSG request.\n");\r\nbsg_job->reply->result = ret;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint\r\nqla24xx_bsg_timeout(struct fc_bsg_job *bsg_job)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(bsg_job->shost);\r\nstruct qla_hw_data *ha = vha->hw;\r\nsrb_t *sp;\r\nint cnt, que;\r\nunsigned long flags;\r\nstruct req_que *req;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (que = 0; que < ha->max_req_queues; que++) {\r\nreq = ha->req_q_map[que];\r\nif (!req)\r\ncontinue;\r\nfor (cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {\r\nsp = req->outstanding_cmds[cnt];\r\nif (sp) {\r\nif (((sp->type == SRB_CT_CMD) ||\r\n(sp->type == SRB_ELS_CMD_HST))\r\n&& (sp->u.bsg_job == bsg_job)) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (ha->isp_ops->abort_command(sp)) {\r\nql_log(ql_log_warn, vha, 0x7089,\r\n"mbx abort_command "\r\n"failed.\n");\r\nbsg_job->req->errors =\r\nbsg_job->reply->result = -EIO;\r\n} else {\r\nql_dbg(ql_dbg_user, vha, 0x708a,\r\n"mbx abort_command "\r\n"success.\n");\r\nbsg_job->req->errors =\r\nbsg_job->reply->result = 0;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ngoto done;\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nql_log(ql_log_info, vha, 0x708b, "SRB not found to abort.\n");\r\nbsg_job->req->errors = bsg_job->reply->result = -ENXIO;\r\nreturn 0;\r\ndone:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (bsg_job->request->msgcode == FC_BSG_HST_CT)\r\nkfree(sp->fcport);\r\nmempool_free(sp, ha->srb_mempool);\r\nreturn 0;\r\n}
