static int\r\nnv10_fence_emit(struct nouveau_fence *fence)\r\n{\r\nstruct nouveau_channel *chan = fence->channel;\r\nint ret = RING_SPACE(chan, 2);\r\nif (ret == 0) {\r\nBEGIN_NV04(chan, 0, NV10_SUBCHAN_REF_CNT, 1);\r\nOUT_RING (chan, fence->sequence);\r\nFIRE_RING (chan);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnv10_fence_sync(struct nouveau_fence *fence,\r\nstruct nouveau_channel *prev, struct nouveau_channel *chan)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nnv17_fence_sync(struct nouveau_fence *fence,\r\nstruct nouveau_channel *prev, struct nouveau_channel *chan)\r\n{\r\nstruct nv10_fence_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_FENCE);\r\nu32 value;\r\nint ret;\r\nif (!mutex_trylock(&prev->mutex))\r\nreturn -EBUSY;\r\nspin_lock(&priv->lock);\r\nvalue = priv->sequence;\r\npriv->sequence += 2;\r\nspin_unlock(&priv->lock);\r\nret = RING_SPACE(prev, 5);\r\nif (!ret) {\r\nBEGIN_NV04(prev, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 4);\r\nOUT_RING (prev, NvSema);\r\nOUT_RING (prev, 0);\r\nOUT_RING (prev, value + 0);\r\nOUT_RING (prev, value + 1);\r\nFIRE_RING (prev);\r\n}\r\nif (!ret && !(ret = RING_SPACE(chan, 5))) {\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 4);\r\nOUT_RING (chan, NvSema);\r\nOUT_RING (chan, 0);\r\nOUT_RING (chan, value + 1);\r\nOUT_RING (chan, value + 2);\r\nFIRE_RING (chan);\r\n}\r\nmutex_unlock(&prev->mutex);\r\nreturn 0;\r\n}\r\nstatic u32\r\nnv10_fence_read(struct nouveau_channel *chan)\r\n{\r\nreturn nvchan_rd32(chan, 0x0048);\r\n}\r\nstatic void\r\nnv10_fence_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nv10_fence_chan *fctx = chan->engctx[engine];\r\nnouveau_fence_context_del(&fctx->base);\r\nchan->engctx[engine] = NULL;\r\nkfree(fctx);\r\n}\r\nstatic int\r\nnv10_fence_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nv10_fence_priv *priv = nv_engine(chan->dev, engine);\r\nstruct nv10_fence_chan *fctx;\r\nstruct nouveau_gpuobj *obj;\r\nint ret = 0;\r\nfctx = chan->engctx[engine] = kzalloc(sizeof(*fctx), GFP_KERNEL);\r\nif (!fctx)\r\nreturn -ENOMEM;\r\nnouveau_fence_context_new(&fctx->base);\r\nif (priv->bo) {\r\nstruct ttm_mem_reg *mem = &priv->bo->bo.mem;\r\nret = nouveau_gpuobj_dma_new(chan, NV_CLASS_DMA_FROM_MEMORY,\r\nmem->start * PAGE_SIZE, mem->size,\r\nNV_MEM_ACCESS_RW,\r\nNV_MEM_TARGET_VRAM, &obj);\r\nif (!ret) {\r\nret = nouveau_ramht_insert(chan, NvSema, obj);\r\nnouveau_gpuobj_ref(NULL, &obj);\r\n}\r\n}\r\nif (ret)\r\nnv10_fence_context_del(chan, engine);\r\nreturn ret;\r\n}\r\nstatic int\r\nnv10_fence_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nnv10_fence_init(struct drm_device *dev, int engine)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nnv10_fence_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv10_fence_priv *priv = nv_engine(dev, engine);\r\nnouveau_bo_ref(NULL, &priv->bo);\r\ndev_priv->eng[engine] = NULL;\r\nkfree(priv);\r\n}\r\nint\r\nnv10_fence_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv10_fence_priv *priv;\r\nint ret = 0;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.engine.destroy = nv10_fence_destroy;\r\npriv->base.engine.init = nv10_fence_init;\r\npriv->base.engine.fini = nv10_fence_fini;\r\npriv->base.engine.context_new = nv10_fence_context_new;\r\npriv->base.engine.context_del = nv10_fence_context_del;\r\npriv->base.emit = nv10_fence_emit;\r\npriv->base.read = nv10_fence_read;\r\npriv->base.sync = nv10_fence_sync;\r\ndev_priv->eng[NVOBJ_ENGINE_FENCE] = &priv->base.engine;\r\nspin_lock_init(&priv->lock);\r\nif (dev_priv->chipset >= 0x17) {\r\nret = nouveau_bo_new(dev, 4096, 0x1000, TTM_PL_FLAG_VRAM,\r\n0, 0x0000, NULL, &priv->bo);\r\nif (!ret) {\r\nret = nouveau_bo_pin(priv->bo, TTM_PL_FLAG_VRAM);\r\nif (!ret)\r\nret = nouveau_bo_map(priv->bo);\r\nif (ret)\r\nnouveau_bo_ref(NULL, &priv->bo);\r\n}\r\nif (ret == 0) {\r\nnouveau_bo_wr32(priv->bo, 0x000, 0x00000000);\r\npriv->base.sync = nv17_fence_sync;\r\n}\r\n}\r\nif (ret)\r\nnv10_fence_destroy(dev, NVOBJ_ENGINE_FENCE);\r\nreturn ret;\r\n}
