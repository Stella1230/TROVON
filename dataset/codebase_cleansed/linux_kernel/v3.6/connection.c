int vmbus_connect(void)\r\n{\r\nint ret = 0;\r\nint t;\r\nstruct vmbus_channel_msginfo *msginfo = NULL;\r\nstruct vmbus_channel_initiate_contact *msg;\r\nunsigned long flags;\r\nvmbus_connection.conn_state = CONNECTING;\r\nvmbus_connection.work_queue = create_workqueue("hv_vmbus_con");\r\nif (!vmbus_connection.work_queue) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nINIT_LIST_HEAD(&vmbus_connection.chn_msg_list);\r\nspin_lock_init(&vmbus_connection.channelmsg_lock);\r\nINIT_LIST_HEAD(&vmbus_connection.chn_list);\r\nspin_lock_init(&vmbus_connection.channel_lock);\r\nvmbus_connection.int_page =\r\n(void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, 0);\r\nif (vmbus_connection.int_page == NULL) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nvmbus_connection.recv_int_page = vmbus_connection.int_page;\r\nvmbus_connection.send_int_page =\r\n(void *)((unsigned long)vmbus_connection.int_page +\r\n(PAGE_SIZE >> 1));\r\nvmbus_connection.monitor_pages =\r\n(void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 1);\r\nif (vmbus_connection.monitor_pages == NULL) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nmsginfo = kzalloc(sizeof(*msginfo) +\r\nsizeof(struct vmbus_channel_initiate_contact),\r\nGFP_KERNEL);\r\nif (msginfo == NULL) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\ninit_completion(&msginfo->waitevent);\r\nmsg = (struct vmbus_channel_initiate_contact *)msginfo->msg;\r\nmsg->header.msgtype = CHANNELMSG_INITIATE_CONTACT;\r\nmsg->vmbus_version_requested = VMBUS_REVISION_NUMBER;\r\nmsg->interrupt_page = virt_to_phys(vmbus_connection.int_page);\r\nmsg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages);\r\nmsg->monitor_page2 = virt_to_phys(\r\n(void *)((unsigned long)vmbus_connection.monitor_pages +\r\nPAGE_SIZE));\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_add_tail(&msginfo->msglistentry,\r\n&vmbus_connection.chn_msg_list);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nret = vmbus_post_msg(msg,\r\nsizeof(struct vmbus_channel_initiate_contact));\r\nif (ret != 0) {\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_del(&msginfo->msglistentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,\r\nflags);\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);\r\nif (t == 0) {\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock,\r\nflags);\r\nlist_del(&msginfo->msglistentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,\r\nflags);\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_del(&msginfo->msglistentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\nif (msginfo->response.version_response.version_supported) {\r\nvmbus_connection.conn_state = CONNECTED;\r\n} else {\r\npr_err("Unable to connect, "\r\n"Version %d not supported by Hyper-V\n",\r\nVMBUS_REVISION_NUMBER);\r\nret = -ECONNREFUSED;\r\ngoto cleanup;\r\n}\r\nkfree(msginfo);\r\nreturn 0;\r\ncleanup:\r\nvmbus_connection.conn_state = DISCONNECTED;\r\nif (vmbus_connection.work_queue)\r\ndestroy_workqueue(vmbus_connection.work_queue);\r\nif (vmbus_connection.int_page) {\r\nfree_pages((unsigned long)vmbus_connection.int_page, 0);\r\nvmbus_connection.int_page = NULL;\r\n}\r\nif (vmbus_connection.monitor_pages) {\r\nfree_pages((unsigned long)vmbus_connection.monitor_pages, 1);\r\nvmbus_connection.monitor_pages = NULL;\r\n}\r\nkfree(msginfo);\r\nreturn ret;\r\n}\r\nstruct vmbus_channel *relid2channel(u32 relid)\r\n{\r\nstruct vmbus_channel *channel;\r\nstruct vmbus_channel *found_channel = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vmbus_connection.channel_lock, flags);\r\nlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\r\nif (channel->offermsg.child_relid == relid) {\r\nfound_channel = channel;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);\r\nreturn found_channel;\r\n}\r\nstatic void process_chn_event(u32 relid)\r\n{\r\nstruct vmbus_channel *channel;\r\nunsigned long flags;\r\nchannel = relid2channel(relid);\r\nif (!channel) {\r\npr_err("channel not found for relid - %u\n", relid);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&channel->inbound_lock, flags);\r\nif (channel->onchannel_callback != NULL)\r\nchannel->onchannel_callback(channel->channel_callback_context);\r\nelse\r\npr_err("no channel callback for relid - %u\n", relid);\r\nspin_unlock_irqrestore(&channel->inbound_lock, flags);\r\n}\r\nvoid vmbus_on_event(unsigned long data)\r\n{\r\nu32 dword;\r\nu32 maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;\r\nint bit;\r\nu32 relid;\r\nu32 *recv_int_page = vmbus_connection.recv_int_page;\r\nif (!recv_int_page)\r\nreturn;\r\nfor (dword = 0; dword < maxdword; dword++) {\r\nif (!recv_int_page[dword])\r\ncontinue;\r\nfor (bit = 0; bit < 32; bit++) {\r\nif (sync_test_and_clear_bit(bit,\r\n(unsigned long *)&recv_int_page[dword])) {\r\nrelid = (dword << 5) + bit;\r\nif (relid == 0)\r\ncontinue;\r\nprocess_chn_event(relid);\r\n}\r\n}\r\n}\r\n}\r\nint vmbus_post_msg(void *buffer, size_t buflen)\r\n{\r\nunion hv_connection_id conn_id;\r\nint ret = 0;\r\nint retries = 0;\r\nconn_id.asu32 = 0;\r\nconn_id.u.id = VMBUS_MESSAGE_CONNECTION_ID;\r\nwhile (retries < 3) {\r\nret = hv_post_message(conn_id, 1, buffer, buflen);\r\nif (ret != HV_STATUS_INSUFFICIENT_BUFFERS)\r\nreturn ret;\r\nretries++;\r\nmsleep(100);\r\n}\r\nreturn ret;\r\n}\r\nint vmbus_set_event(u32 child_relid)\r\n{\r\nsync_set_bit(child_relid & 31,\r\n(unsigned long *)vmbus_connection.send_int_page +\r\n(child_relid >> 5));\r\nreturn hv_signal_event();\r\n}
