void gdbstub_io_init(void)\r\n{\r\nu16 tmp;\r\nGDBPORT_SERIAL_LCR = UART_LCR_WLEN8;\r\nGDBPORT_SERIAL_FCR = (UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT);\r\nFLOWCTL_CLEAR(DTR);\r\nFLOWCTL_SET(RTS);\r\ngdbstub_io_set_baud(115200);\r\nXIRQxICR(GDBPORT_SERIAL_IRQ) = 0;\r\ntmp = XIRQxICR(GDBPORT_SERIAL_IRQ);\r\n#if CONFIG_GDBSTUB_IRQ_LEVEL == 0\r\nIVAR0 = EXCEP_IRQ_LEVEL0;\r\n#elif CONFIG_GDBSTUB_IRQ_LEVEL == 1\r\nIVAR1 = EXCEP_IRQ_LEVEL1;\r\n#elif CONFIG_GDBSTUB_IRQ_LEVEL == 2\r\nIVAR2 = EXCEP_IRQ_LEVEL2;\r\n#elif CONFIG_GDBSTUB_IRQ_LEVEL == 3\r\nIVAR3 = EXCEP_IRQ_LEVEL3;\r\n#elif CONFIG_GDBSTUB_IRQ_LEVEL == 4\r\nIVAR4 = EXCEP_IRQ_LEVEL4;\r\n#elif CONFIG_GDBSTUB_IRQ_LEVEL == 5\r\nIVAR5 = EXCEP_IRQ_LEVEL5;\r\n#else\r\n#error "Unknown irq level for gdbstub."\r\n#endif\r\nset_intr_stub(NUM2EXCEP_IRQ_LEVEL(CONFIG_GDBSTUB_IRQ_LEVEL),\r\ngdbstub_io_rx_handler);\r\nXIRQxICR(GDBPORT_SERIAL_IRQ) &= ~GxICR_REQUEST;\r\nXIRQxICR(GDBPORT_SERIAL_IRQ) =\r\nGxICR_ENABLE | NUM2GxICR_LEVEL(CONFIG_GDBSTUB_IRQ_LEVEL);\r\ntmp = XIRQxICR(GDBPORT_SERIAL_IRQ);\r\nGDBPORT_SERIAL_IER = UART_IER_RDI | UART_IER_RLSI;\r\narch_local_change_intr_mask_level(\r\nNUM2EPSW_IM(CONFIG_GDBSTUB_IRQ_LEVEL + 1));\r\n}\r\nvoid gdbstub_io_set_baud(unsigned baud)\r\n{\r\nunsigned value;\r\nu8 lcr;\r\nvalue = 18432000 / 16 / baud;\r\nlcr = GDBPORT_SERIAL_LCR;\r\nGDBPORT_SERIAL_LCR |= UART_LCR_DLAB;\r\nGDBPORT_SERIAL_DLL = value & 0xff;\r\nGDBPORT_SERIAL_DLM = (value >> 8) & 0xff;\r\nGDBPORT_SERIAL_LCR = lcr;\r\n}\r\nint gdbstub_io_rx_char(unsigned char *_ch, int nonblock)\r\n{\r\nunsigned ix;\r\nu8 ch, st;\r\n#if defined(CONFIG_MN10300_WD_TIMER)\r\nint cpu;\r\n#endif\r\n*_ch = 0xff;\r\nif (gdbstub_rx_unget) {\r\n*_ch = gdbstub_rx_unget;\r\ngdbstub_rx_unget = 0;\r\nreturn 0;\r\n}\r\ntry_again:\r\nix = gdbstub_rx_outp;\r\nbarrier();\r\nif (ix == gdbstub_rx_inp) {\r\nif (nonblock)\r\nreturn -EAGAIN;\r\n#ifdef CONFIG_MN10300_WD_TIMER\r\nfor (cpu = 0; cpu < NR_CPUS; cpu++)\r\nwatchdog_alert_counter[cpu] = 0;\r\n#endif\r\ngoto try_again;\r\n}\r\nch = gdbstub_rx_buffer[ix++];\r\nst = gdbstub_rx_buffer[ix++];\r\nbarrier();\r\ngdbstub_rx_outp = ix & 0x00000fff;\r\nif (st & UART_LSR_BI) {\r\ngdbstub_proto("### GDB Rx Break Detected ###\n");\r\nreturn -EINTR;\r\n} else if (st & (UART_LSR_FE | UART_LSR_OE | UART_LSR_PE)) {\r\ngdbstub_proto("### GDB Rx Error (st=%02x) ###\n", st);\r\nreturn -EIO;\r\n} else {\r\ngdbstub_proto("### GDB Rx %02x (st=%02x) ###\n", ch, st);\r\n*_ch = ch & 0x7f;\r\nreturn 0;\r\n}\r\n}\r\nvoid gdbstub_io_tx_char(unsigned char ch)\r\n{\r\nFLOWCTL_SET(DTR);\r\nLSR_WAIT_FOR(THRE);\r\nif (ch == 0x0a) {\r\nGDBPORT_SERIAL_TX = 0x0d;\r\nLSR_WAIT_FOR(THRE);\r\n}\r\nGDBPORT_SERIAL_TX = ch;\r\nFLOWCTL_CLEAR(DTR);\r\n}\r\nvoid gdbstub_io_tx_flush(void)\r\n{\r\nLSR_WAIT_FOR(TEMT);\r\nLSR_WAIT_FOR(THRE);\r\nFLOWCTL_CLEAR(DTR);\r\n}
