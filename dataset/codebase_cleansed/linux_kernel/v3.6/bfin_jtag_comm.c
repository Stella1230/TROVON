static inline uint32_t bfin_write_emudat(uint32_t emudat)\r\n{\r\n__asm__ __volatile__("emudat = %0;" : : "d"(emudat));\r\nreturn emudat;\r\n}\r\nstatic inline uint32_t bfin_read_emudat(void)\r\n{\r\nuint32_t emudat;\r\n__asm__ __volatile__("%0 = emudat;" : "=d"(emudat));\r\nreturn emudat;\r\n}\r\nstatic inline uint32_t bfin_write_emudat_chars(char a, char b, char c, char d)\r\n{\r\nreturn bfin_write_emudat((a << 0) | (b << 8) | (c << 16) | (d << 24));\r\n}\r\nstatic int\r\nbfin_jc_emudat_manager(void *arg)\r\n{\r\nuint32_t inbound_len = 0, outbound_len = 0;\r\nwhile (!kthread_should_stop()) {\r\nstruct tty_struct *tty = tty_port_tty_get(&port);\r\nif (tty == NULL && circ_empty(&bfin_jc_write_buf)) {\r\npr_debug("waiting for readers\n");\r\n__set_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\n__set_current_state(TASK_RUNNING);\r\ncontinue;\r\n}\r\nif (!(bfin_read_DBGSTAT() & EMUDIF) && circ_empty(&bfin_jc_write_buf)) {\r\npr_debug("waiting for data (in_len = %i) (circ: %i %i)\n",\r\ninbound_len, bfin_jc_write_buf.tail, bfin_jc_write_buf.head);\r\ntty_kref_put(tty);\r\nif (inbound_len)\r\nschedule();\r\nelse\r\nschedule_timeout_interruptible(HZ);\r\ncontinue;\r\n}\r\nif (bfin_read_DBGSTAT() & EMUDIF) {\r\nif (tty != NULL) {\r\nuint32_t emudat = bfin_read_emudat();\r\nif (inbound_len == 0) {\r\npr_debug("incoming length: 0x%08x\n", emudat);\r\ninbound_len = emudat;\r\n} else {\r\nsize_t num_chars = (4 <= inbound_len ? 4 : inbound_len);\r\npr_debug(" incoming data: 0x%08x (pushing %zu)\n", emudat, num_chars);\r\ninbound_len -= num_chars;\r\ntty_insert_flip_string(tty, (unsigned char *)&emudat, num_chars);\r\ntty_flip_buffer_push(tty);\r\n}\r\n}\r\n}\r\nif (!(bfin_read_DBGSTAT() & EMUDOF) && !circ_empty(&bfin_jc_write_buf)) {\r\nif (outbound_len == 0) {\r\noutbound_len = circ_cnt(&bfin_jc_write_buf);\r\nbfin_write_emudat(outbound_len);\r\npr_debug("outgoing length: 0x%08x\n", outbound_len);\r\n} else {\r\nint tail = bfin_jc_write_buf.tail;\r\nsize_t ate = (4 <= outbound_len ? 4 : outbound_len);\r\nuint32_t emudat =\r\nbfin_write_emudat_chars(\r\ncirc_byte(&bfin_jc_write_buf, tail + 0),\r\ncirc_byte(&bfin_jc_write_buf, tail + 1),\r\ncirc_byte(&bfin_jc_write_buf, tail + 2),\r\ncirc_byte(&bfin_jc_write_buf, tail + 3)\r\n);\r\nbfin_jc_write_buf.tail += ate;\r\noutbound_len -= ate;\r\nif (tty)\r\ntty_wakeup(tty);\r\npr_debug(" outgoing data: 0x%08x (pushing %zu)\n", emudat, ate);\r\n}\r\n}\r\ntty_kref_put(tty);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn 0;\r\n}\r\nstatic int\r\nbfin_jc_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port.lock, flags);\r\nport.count++;\r\nspin_unlock_irqrestore(&port.lock, flags);\r\ntty_port_tty_set(&port, tty);\r\nwake_up_process(bfin_jc_kthread);\r\nreturn 0;\r\n}\r\nstatic void\r\nbfin_jc_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nunsigned long flags;\r\nbool last;\r\nspin_lock_irqsave(&port.lock, flags);\r\nlast = --port.count == 0;\r\nspin_unlock_irqrestore(&port.lock, flags);\r\nif (last)\r\ntty_port_tty_set(&port, NULL);\r\nwake_up_process(bfin_jc_kthread);\r\n}\r\nstatic int\r\nbfin_jc_circ_write(const unsigned char *buf, int count)\r\n{\r\nint i;\r\ncount = min(count, circ_free(&bfin_jc_write_buf));\r\npr_debug("going to write chunk of %i bytes\n", count);\r\nfor (i = 0; i < count; ++i)\r\ncirc_byte(&bfin_jc_write_buf, bfin_jc_write_buf.head + i) = buf[i];\r\nbfin_jc_write_buf.head += i;\r\nreturn i;\r\n}\r\nstatic int\r\nbfin_jc_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nint i;\r\nconsole_lock();\r\ni = bfin_jc_circ_write(buf, count);\r\nconsole_unlock();\r\nwake_up_process(bfin_jc_kthread);\r\nreturn i;\r\n}\r\nstatic void\r\nbfin_jc_flush_chars(struct tty_struct *tty)\r\n{\r\nwake_up_process(bfin_jc_kthread);\r\n}\r\nstatic int\r\nbfin_jc_write_room(struct tty_struct *tty)\r\n{\r\nreturn circ_free(&bfin_jc_write_buf);\r\n}\r\nstatic int\r\nbfin_jc_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nreturn circ_cnt(&bfin_jc_write_buf);\r\n}\r\nstatic void\r\nbfin_jc_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nunsigned long expire = jiffies + timeout;\r\nwhile (!circ_empty(&bfin_jc_write_buf)) {\r\nif (signal_pending(current))\r\nbreak;\r\nif (time_after(jiffies, expire))\r\nbreak;\r\n}\r\n}\r\nstatic int __init bfin_jc_init(void)\r\n{\r\nint ret;\r\ntty_port_init(&port);\r\nbfin_jc_kthread = kthread_create(bfin_jc_emudat_manager, NULL, DRV_NAME);\r\nif (IS_ERR(bfin_jc_kthread))\r\nreturn PTR_ERR(bfin_jc_kthread);\r\nret = -ENOMEM;\r\nbfin_jc_write_buf.head = bfin_jc_write_buf.tail = 0;\r\nbfin_jc_write_buf.buf = kmalloc(CIRC_SIZE, GFP_KERNEL);\r\nif (!bfin_jc_write_buf.buf)\r\ngoto err_buf;\r\nbfin_jc_driver = alloc_tty_driver(1);\r\nif (!bfin_jc_driver)\r\ngoto err_driver;\r\nbfin_jc_driver->driver_name = DRV_NAME;\r\nbfin_jc_driver->name = DEV_NAME;\r\nbfin_jc_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nbfin_jc_driver->subtype = SERIAL_TYPE_NORMAL;\r\nbfin_jc_driver->init_termios = tty_std_termios;\r\ntty_set_operations(bfin_jc_driver, &bfin_jc_ops);\r\nret = tty_register_driver(bfin_jc_driver);\r\nif (ret)\r\ngoto err;\r\npr_init(KERN_INFO DRV_NAME ": initialized\n");\r\nreturn 0;\r\nerr:\r\nput_tty_driver(bfin_jc_driver);\r\nerr_driver:\r\nkfree(bfin_jc_write_buf.buf);\r\nerr_buf:\r\nkthread_stop(bfin_jc_kthread);\r\nreturn ret;\r\n}\r\nstatic void __exit bfin_jc_exit(void)\r\n{\r\nkthread_stop(bfin_jc_kthread);\r\nkfree(bfin_jc_write_buf.buf);\r\ntty_unregister_driver(bfin_jc_driver);\r\nput_tty_driver(bfin_jc_driver);\r\n}\r\nstatic void\r\nbfin_jc_straight_buffer_write(const char *buf, unsigned count)\r\n{\r\nunsigned ate = 0;\r\nwhile (bfin_read_DBGSTAT() & EMUDOF)\r\ncontinue;\r\nbfin_write_emudat(count);\r\nwhile (ate < count) {\r\nwhile (bfin_read_DBGSTAT() & EMUDOF)\r\ncontinue;\r\nbfin_write_emudat_chars(buf[ate], buf[ate+1], buf[ate+2], buf[ate+3]);\r\nate += 4;\r\n}\r\n}\r\nstatic void\r\nbfin_jc_console_write(struct console *co, const char *buf, unsigned count)\r\n{\r\nif (bfin_jc_kthread == NULL)\r\nbfin_jc_straight_buffer_write(buf, count);\r\nelse\r\nbfin_jc_circ_write(buf, count);\r\n}\r\nstatic struct tty_driver *\r\nbfin_jc_console_device(struct console *co, int *index)\r\n{\r\n*index = co->index;\r\nreturn bfin_jc_driver;\r\n}\r\nstatic int __init bfin_jc_console_init(void)\r\n{\r\nregister_console(&bfin_jc_console);\r\nreturn 0;\r\n}\r\nstatic void __init\r\nbfin_jc_early_write(struct console *co, const char *buf, unsigned int count)\r\n{\r\nbfin_jc_straight_buffer_write(buf, count);\r\n}\r\nstruct console * __init\r\nbfin_jc_early_init(unsigned int port, unsigned int cflag)\r\n{\r\nreturn &bfin_jc_early_console;\r\n}
