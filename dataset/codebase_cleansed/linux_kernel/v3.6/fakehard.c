static struct wpan_phy *fake_to_phy(const struct net_device *dev)\r\n{\r\nstruct fakehard_priv *priv = netdev_priv(dev);\r\nreturn priv->phy;\r\n}\r\nstatic struct wpan_phy *fake_get_phy(const struct net_device *dev)\r\n{\r\nstruct wpan_phy *phy = fake_to_phy(dev);\r\nreturn to_phy(get_device(&phy->dev));\r\n}\r\nstatic u16 fake_get_pan_id(const struct net_device *dev)\r\n{\r\nBUG_ON(dev->type != ARPHRD_IEEE802154);\r\nreturn 0xeba1;\r\n}\r\nstatic u16 fake_get_short_addr(const struct net_device *dev)\r\n{\r\nBUG_ON(dev->type != ARPHRD_IEEE802154);\r\nreturn 0x1;\r\n}\r\nstatic u8 fake_get_dsn(const struct net_device *dev)\r\n{\r\nBUG_ON(dev->type != ARPHRD_IEEE802154);\r\nreturn 0x00;\r\n}\r\nstatic u8 fake_get_bsn(const struct net_device *dev)\r\n{\r\nBUG_ON(dev->type != ARPHRD_IEEE802154);\r\nreturn 0x00;\r\n}\r\nstatic int fake_assoc_req(struct net_device *dev,\r\nstruct ieee802154_addr *addr, u8 channel, u8 page, u8 cap)\r\n{\r\nstruct wpan_phy *phy = fake_to_phy(dev);\r\nmutex_lock(&phy->pib_lock);\r\nphy->current_channel = channel;\r\nphy->current_page = page;\r\nmutex_unlock(&phy->pib_lock);\r\nreturn ieee802154_nl_assoc_confirm(dev, fake_get_short_addr(dev),\r\nIEEE802154_SUCCESS);\r\n}\r\nstatic int fake_assoc_resp(struct net_device *dev,\r\nstruct ieee802154_addr *addr, u16 short_addr, u8 status)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fake_disassoc_req(struct net_device *dev,\r\nstruct ieee802154_addr *addr, u8 reason)\r\n{\r\nreturn ieee802154_nl_disassoc_confirm(dev, IEEE802154_SUCCESS);\r\n}\r\nstatic int fake_start_req(struct net_device *dev, struct ieee802154_addr *addr,\r\nu8 channel, u8 page,\r\nu8 bcn_ord, u8 sf_ord, u8 pan_coord, u8 blx,\r\nu8 coord_realign)\r\n{\r\nstruct wpan_phy *phy = fake_to_phy(dev);\r\nmutex_lock(&phy->pib_lock);\r\nphy->current_channel = channel;\r\nphy->current_page = page;\r\nmutex_unlock(&phy->pib_lock);\r\nieee802154_nl_start_confirm(dev, IEEE802154_INVALID_PARAMETER);\r\nreturn 0;\r\n}\r\nstatic int fake_scan_req(struct net_device *dev, u8 type, u32 channels,\r\nu8 page, u8 duration)\r\n{\r\nu8 edl[27] = {};\r\nreturn ieee802154_nl_scan_confirm(dev, IEEE802154_SUCCESS, type,\r\nchannels, page,\r\ntype == IEEE802154_MAC_SCAN_ED ? edl : NULL);\r\n}\r\nstatic int ieee802154_fake_open(struct net_device *dev)\r\n{\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ieee802154_fake_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ieee802154_fake_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ieee802154_fake_ioctl(struct net_device *dev, struct ifreq *ifr,\r\nint cmd)\r\n{\r\nstruct sockaddr_ieee802154 *sa =\r\n(struct sockaddr_ieee802154 *)&ifr->ifr_addr;\r\nu16 pan_id, short_addr;\r\nswitch (cmd) {\r\ncase SIOCGIFADDR:\r\npan_id = fake_get_pan_id(dev);\r\nshort_addr = fake_get_short_addr(dev);\r\nif (pan_id == IEEE802154_PANID_BROADCAST ||\r\nshort_addr == IEEE802154_ADDR_BROADCAST)\r\nreturn -EADDRNOTAVAIL;\r\nsa->family = AF_IEEE802154;\r\nsa->addr.addr_type = IEEE802154_ADDR_SHORT;\r\nsa->addr.pan_id = pan_id;\r\nsa->addr.short_addr = short_addr;\r\nreturn 0;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int ieee802154_fake_mac_addr(struct net_device *dev, void *p)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic void ieee802154_fake_destruct(struct net_device *dev)\r\n{\r\nstruct wpan_phy *phy = fake_to_phy(dev);\r\nwpan_phy_unregister(phy);\r\nfree_netdev(dev);\r\nwpan_phy_free(phy);\r\n}\r\nstatic void ieee802154_fake_setup(struct net_device *dev)\r\n{\r\ndev->addr_len = IEEE802154_ADDR_LEN;\r\nmemset(dev->broadcast, 0xff, IEEE802154_ADDR_LEN);\r\ndev->features = NETIF_F_HW_CSUM;\r\ndev->needed_tailroom = 2;\r\ndev->mtu = 127;\r\ndev->tx_queue_len = 10;\r\ndev->type = ARPHRD_IEEE802154;\r\ndev->flags = IFF_NOARP | IFF_BROADCAST;\r\ndev->watchdog_timeo = 0;\r\ndev->destructor = ieee802154_fake_destruct;\r\n}\r\nstatic int __devinit ieee802154fake_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct fakehard_priv *priv;\r\nstruct wpan_phy *phy = wpan_phy_alloc(0);\r\nint err;\r\nif (!phy)\r\nreturn -ENOMEM;\r\ndev = alloc_netdev(sizeof(struct fakehard_priv), "hardwpan%d", ieee802154_fake_setup);\r\nif (!dev) {\r\nwpan_phy_free(phy);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(dev->dev_addr, "\xba\xbe\xca\xfe\xde\xad\xbe\xef",\r\ndev->addr_len);\r\nmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);\r\nphy->channels_supported[0] |= 0x7FFF800;\r\nphy->channels_supported[3] |= 0x3fff;\r\nphy->transmit_power = 0xbf;\r\ndev->netdev_ops = &fake_ops;\r\ndev->ml_priv = &fake_mlme;\r\npriv = netdev_priv(dev);\r\npriv->phy = phy;\r\nwpan_phy_set_dev(phy, &pdev->dev);\r\nSET_NETDEV_DEV(dev, &phy->dev);\r\nplatform_set_drvdata(pdev, dev);\r\nerr = wpan_phy_register(phy);\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err < 0)\r\ngoto out;\r\ndev_info(&pdev->dev, "Added ieee802154 HardMAC hardware\n");\r\nreturn 0;\r\nout:\r\nunregister_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int __devexit ieee802154fake_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic __init int fake_init(void)\r\n{\r\nieee802154fake_dev = platform_device_register_simple(\r\n"ieee802154hardmac", -1, NULL, 0);\r\nreturn platform_driver_register(&ieee802154fake_driver);\r\n}\r\nstatic __exit void fake_exit(void)\r\n{\r\nplatform_driver_unregister(&ieee802154fake_driver);\r\nplatform_device_unregister(ieee802154fake_dev);\r\n}
