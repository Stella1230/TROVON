static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)\r\n{\r\nreturn clk_get_rate(dev->clk)/1000;\r\n}\r\nstatic int __devinit dw_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct dw_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *mem, *ioarea;\r\nint irq, r;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\nioarea = request_mem_region(mem->start, resource_size(mem),\r\npdev->name);\r\nif (!ioarea) {\r\ndev_err(&pdev->dev, "I2C region already claimed\n");\r\nreturn -EBUSY;\r\n}\r\ndev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);\r\nif (!dev) {\r\nr = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\ninit_completion(&dev->cmd_complete);\r\nmutex_init(&dev->lock);\r\ndev->dev = get_device(&pdev->dev);\r\ndev->irq = irq;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->clk = clk_get(&pdev->dev, NULL);\r\ndev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;\r\nif (IS_ERR(dev->clk)) {\r\nr = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nclk_prepare_enable(dev->clk);\r\ndev->functionality =\r\nI2C_FUNC_I2C |\r\nI2C_FUNC_10BIT_ADDR |\r\nI2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK;\r\ndev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |\r\nDW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;\r\ndev->base = ioremap(mem->start, resource_size(mem));\r\nif (dev->base == NULL) {\r\ndev_err(&pdev->dev, "failure mapping io resources\n");\r\nr = -EBUSY;\r\ngoto err_unuse_clocks;\r\n}\r\n{\r\nu32 param1 = i2c_dw_read_comp_param(dev);\r\ndev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;\r\ndev->rx_fifo_depth = ((param1 >> 8) & 0xff) + 1;\r\n}\r\nr = i2c_dw_init(dev);\r\nif (r)\r\ngoto err_iounmap;\r\ni2c_dw_disable_int(dev);\r\nr = request_irq(dev->irq, i2c_dw_isr, IRQF_DISABLED, pdev->name, dev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);\r\ngoto err_iounmap;\r\n}\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON;\r\nstrlcpy(adap->name, "Synopsys DesignWare I2C adapter",\r\nsizeof(adap->name));\r\nadap->algo = &i2c_dw_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nadap->nr = pdev->id;\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure adding adapter\n");\r\ngoto err_free_irq;\r\n}\r\nof_i2c_register_devices(adap);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_iounmap:\r\niounmap(dev->base);\r\nerr_unuse_clocks:\r\nclk_disable_unprepare(dev->clk);\r\nclk_put(dev->clk);\r\ndev->clk = NULL;\r\nerr_free_mem:\r\nplatform_set_drvdata(pdev, NULL);\r\nput_device(&pdev->dev);\r\nkfree(dev);\r\nerr_release_region:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn r;\r\n}\r\nstatic int __devexit dw_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct dw_i2c_dev *dev = platform_get_drvdata(pdev);\r\nstruct resource *mem;\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&dev->adapter);\r\nput_device(&pdev->dev);\r\nclk_disable_unprepare(dev->clk);\r\nclk_put(dev->clk);\r\ndev->clk = NULL;\r\ni2c_dw_disable(dev);\r\nfree_irq(dev->irq, dev);\r\nkfree(dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn 0;\r\n}\r\nstatic int dw_i2c_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(i_dev->clk);\r\nreturn 0;\r\n}\r\nstatic int dw_i2c_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);\r\nclk_prepare_enable(i_dev->clk);\r\ni2c_dw_init(i_dev);\r\nreturn 0;\r\n}\r\nstatic int __init dw_i2c_init_driver(void)\r\n{\r\nreturn platform_driver_probe(&dw_i2c_driver, dw_i2c_probe);\r\n}\r\nstatic void __exit dw_i2c_exit_driver(void)\r\n{\r\nplatform_driver_unregister(&dw_i2c_driver);\r\n}
