static void wf_fcu_release(struct kref *ref)\r\n{\r\nstruct wf_fcu_priv *pv = container_of(ref, struct wf_fcu_priv, ref);\r\nkfree(pv);\r\n}\r\nstatic void wf_fcu_fan_release(struct wf_control *ct)\r\n{\r\nstruct wf_fcu_fan *fan = ct->priv;\r\nkref_put(&fan->fcu_priv->ref, wf_fcu_release);\r\nkfree(fan);\r\n}\r\nstatic int wf_fcu_read_reg(struct wf_fcu_priv *pv, int reg,\r\nunsigned char *buf, int nb)\r\n{\r\nint tries, nr, nw;\r\nmutex_lock(&pv->lock);\r\nbuf[0] = reg;\r\ntries = 0;\r\nfor (;;) {\r\nnw = i2c_master_send(pv->i2c, buf, 1);\r\nif (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)\r\nbreak;\r\nmsleep(10);\r\n++tries;\r\n}\r\nif (nw <= 0) {\r\npr_err("Failure writing address to FCU: %d", nw);\r\nnr = nw;\r\ngoto bail;\r\n}\r\ntries = 0;\r\nfor (;;) {\r\nnr = i2c_master_recv(pv->i2c, buf, nb);\r\nif (nr > 0 || (nr < 0 && nr != -ENODEV) || tries >= 100)\r\nbreak;\r\nmsleep(10);\r\n++tries;\r\n}\r\nif (nr <= 0)\r\npr_err("wf_fcu: Failure reading data from FCU: %d", nw);\r\nbail:\r\nmutex_unlock(&pv->lock);\r\nreturn nr;\r\n}\r\nstatic int wf_fcu_write_reg(struct wf_fcu_priv *pv, int reg,\r\nconst unsigned char *ptr, int nb)\r\n{\r\nint tries, nw;\r\nunsigned char buf[16];\r\nbuf[0] = reg;\r\nmemcpy(buf+1, ptr, nb);\r\n++nb;\r\ntries = 0;\r\nfor (;;) {\r\nnw = i2c_master_send(pv->i2c, buf, nb);\r\nif (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)\r\nbreak;\r\nmsleep(10);\r\n++tries;\r\n}\r\nif (nw < 0)\r\npr_err("wf_fcu: Failure writing to FCU: %d", nw);\r\nreturn nw;\r\n}\r\nstatic int wf_fcu_fan_set_rpm(struct wf_control *ct, s32 value)\r\n{\r\nstruct wf_fcu_fan *fan = ct->priv;\r\nstruct wf_fcu_priv *pv = fan->fcu_priv;\r\nint rc, shift = pv->rpm_shift;\r\nunsigned char buf[2];\r\nif (value < fan->min)\r\nvalue = fan->min;\r\nif (value > fan->max)\r\nvalue = fan->max;\r\nfan->target = value;\r\nbuf[0] = value >> (8 - shift);\r\nbuf[1] = value << shift;\r\nrc = wf_fcu_write_reg(pv, 0x10 + (fan->id * 2), buf, 2);\r\nif (rc < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int wf_fcu_fan_get_rpm(struct wf_control *ct, s32 *value)\r\n{\r\nstruct wf_fcu_fan *fan = ct->priv;\r\nstruct wf_fcu_priv *pv = fan->fcu_priv;\r\nint rc, reg_base, shift = pv->rpm_shift;\r\nunsigned char failure;\r\nunsigned char active;\r\nunsigned char buf[2];\r\nrc = wf_fcu_read_reg(pv, 0xb, &failure, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((failure & (1 << fan->id)) != 0)\r\nreturn -EFAULT;\r\nrc = wf_fcu_read_reg(pv, 0xd, &active, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((active & (1 << fan->id)) == 0)\r\nreturn -ENXIO;\r\n#if RPM_PID_USE_ACTUAL_SPEED\r\nreg_base = 0x11;\r\n#else\r\nreg_base = 0x10;\r\n#endif\r\nrc = wf_fcu_read_reg(pv, reg_base + (fan->id * 2), buf, 2);\r\nif (rc != 2)\r\nreturn -EIO;\r\n*value = (buf[0] << (8 - shift)) | buf[1] >> shift;\r\nreturn 0;\r\n}\r\nstatic int wf_fcu_fan_set_pwm(struct wf_control *ct, s32 value)\r\n{\r\nstruct wf_fcu_fan *fan = ct->priv;\r\nstruct wf_fcu_priv *pv = fan->fcu_priv;\r\nunsigned char buf[2];\r\nint rc;\r\nif (value < fan->min)\r\nvalue = fan->min;\r\nif (value > fan->max)\r\nvalue = fan->max;\r\nfan->target = value;\r\nvalue = (value * 2559) / 1000;\r\nbuf[0] = value;\r\nrc = wf_fcu_write_reg(pv, 0x30 + (fan->id * 2), buf, 1);\r\nif (rc < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int wf_fcu_fan_get_pwm(struct wf_control *ct, s32 *value)\r\n{\r\nstruct wf_fcu_fan *fan = ct->priv;\r\nstruct wf_fcu_priv *pv = fan->fcu_priv;\r\nunsigned char failure;\r\nunsigned char active;\r\nunsigned char buf[2];\r\nint rc;\r\nrc = wf_fcu_read_reg(pv, 0x2b, &failure, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((failure & (1 << fan->id)) != 0)\r\nreturn -EFAULT;\r\nrc = wf_fcu_read_reg(pv, 0x2d, &active, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((active & (1 << fan->id)) == 0)\r\nreturn -ENXIO;\r\nrc = wf_fcu_read_reg(pv, 0x30 + (fan->id * 2), buf, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\n*value = (((s32)buf[0]) * 1000) / 2559;\r\nreturn 0;\r\n}\r\nstatic s32 wf_fcu_fan_min(struct wf_control *ct)\r\n{\r\nstruct wf_fcu_fan *fan = ct->priv;\r\nreturn fan->min;\r\n}\r\nstatic s32 wf_fcu_fan_max(struct wf_control *ct)\r\n{\r\nstruct wf_fcu_fan *fan = ct->priv;\r\nreturn fan->max;\r\n}\r\nstatic void __devinit wf_fcu_get_pump_minmax(struct wf_fcu_fan *fan)\r\n{\r\nconst struct mpu_data *mpu = wf_get_mpu(0);\r\nu16 pump_min = 0, pump_max = 0xffff;\r\nu16 tmp[4];\r\nif (mpu) {\r\nmemcpy(&tmp, mpu->processor_part_num, 8);\r\nif (tmp[0] != 0xffff && tmp[1] != 0xffff) {\r\npump_min = max(pump_min, tmp[0]);\r\npump_max = min(pump_max, tmp[1]);\r\n}\r\nif (tmp[2] != 0xffff && tmp[3] != 0xffff) {\r\npump_min = max(pump_min, tmp[2]);\r\npump_max = min(pump_max, tmp[3]);\r\n}\r\n}\r\nif (pump_min == pump_max || pump_min == 0 || pump_max == 0xffff) {\r\npump_min = CPU_PUMP_OUTPUT_MIN;\r\npump_max = CPU_PUMP_OUTPUT_MAX;\r\n}\r\nfan->min = pump_min;\r\nfan->max = pump_max;\r\nDBG("wf_fcu: pump min/max for %s set to: [%d..%d] RPM\n",\r\nfan->ctrl.name, pump_min, pump_max);\r\n}\r\nstatic void __devinit wf_fcu_get_rpmfan_minmax(struct wf_fcu_fan *fan)\r\n{\r\nstruct wf_fcu_priv *pv = fan->fcu_priv;\r\nconst struct mpu_data *mpu0 = wf_get_mpu(0);\r\nconst struct mpu_data *mpu1 = wf_get_mpu(1);\r\nfan->min = 2400 >> pv->rpm_shift;\r\nfan->max = 56000 >> pv->rpm_shift;\r\nif (mpu0 && !strcmp(fan->ctrl.name, "cpu-front-fan-0")) {\r\nfan->min = max(fan->min, (s32)mpu0->rminn_intake_fan);\r\nfan->max = min(fan->max, (s32)mpu0->rmaxn_intake_fan);\r\ngoto bail;\r\n}\r\nif (mpu1 && !strcmp(fan->ctrl.name, "cpu-front-fan-1")) {\r\nfan->min = max(fan->min, (s32)mpu1->rminn_intake_fan);\r\nfan->max = min(fan->max, (s32)mpu1->rmaxn_intake_fan);\r\ngoto bail;\r\n}\r\nif (mpu0 && !strcmp(fan->ctrl.name, "cpu-rear-fan-0")) {\r\nfan->min = max(fan->min, (s32)mpu0->rminn_exhaust_fan);\r\nfan->max = min(fan->max, (s32)mpu0->rmaxn_exhaust_fan);\r\ngoto bail;\r\n}\r\nif (mpu1 && !strcmp(fan->ctrl.name, "cpu-rear-fan-1")) {\r\nfan->min = max(fan->min, (s32)mpu1->rminn_exhaust_fan);\r\nfan->max = min(fan->max, (s32)mpu1->rmaxn_exhaust_fan);\r\ngoto bail;\r\n}\r\nif (!strncmp(fan->ctrl.name, "cpu-fan", 7)) {\r\nfan->min = max(fan->min, (s32)mpu0->rminn_intake_fan);\r\nfan->max = min(fan->max, (s32)mpu0->rmaxn_intake_fan);\r\ngoto bail;\r\n}\r\nbail:\r\nDBG("wf_fcu: fan min/max for %s set to: [%d..%d] RPM\n",\r\nfan->ctrl.name, fan->min, fan->max);\r\n}\r\nstatic void __devinit wf_fcu_add_fan(struct wf_fcu_priv *pv,\r\nconst char *name,\r\nint type, int id)\r\n{\r\nstruct wf_fcu_fan *fan;\r\nfan = kzalloc(sizeof(*fan), GFP_KERNEL);\r\nif (!fan)\r\nreturn;\r\nfan->fcu_priv = pv;\r\nfan->id = id;\r\nfan->ctrl.name = name;\r\nfan->ctrl.priv = fan;\r\nif (type == FCU_FAN_RPM) {\r\nif (!strncmp(name, "cpu-pump", strlen("cpu-pump")))\r\nwf_fcu_get_pump_minmax(fan);\r\nelse\r\nwf_fcu_get_rpmfan_minmax(fan);\r\nfan->ctrl.type = WF_CONTROL_RPM_FAN;\r\nfan->ctrl.ops = &wf_fcu_fan_rpm_ops;\r\n} else {\r\nfan->min = 10;\r\nfan->max = 100;\r\nfan->ctrl.type = WF_CONTROL_PWM_FAN;\r\nfan->ctrl.ops = &wf_fcu_fan_pwm_ops;\r\n}\r\nif (wf_register_control(&fan->ctrl)) {\r\npr_err("wf_fcu: Failed to register fan %s\n", name);\r\nkfree(fan);\r\nreturn;\r\n}\r\nlist_add(&fan->link, &pv->fan_list);\r\nkref_get(&pv->ref);\r\n}\r\nstatic void __devinit wf_fcu_lookup_fans(struct wf_fcu_priv *pv)\r\n{\r\nstatic const struct {\r\nconst char *dt_name;\r\nconst char *ct_name;\r\n} loc_trans[] = {\r\n{ "BACKSIDE", "backside-fan", },\r\n{ "SYS CTRLR FAN", "backside-fan", },\r\n{ "DRIVE BAY", "drive-bay-fan", },\r\n{ "SLOT", "slots-fan", },\r\n{ "PCI FAN", "slots-fan", },\r\n{ "CPU A INTAKE", "cpu-front-fan-0", },\r\n{ "CPU A EXHAUST", "cpu-rear-fan-0", },\r\n{ "CPU B INTAKE", "cpu-front-fan-1", },\r\n{ "CPU B EXHAUST", "cpu-rear-fan-1", },\r\n{ "CPU A PUMP", "cpu-pump-0", },\r\n{ "CPU B PUMP", "cpu-pump-1", },\r\n{ "CPU A 1", "cpu-fan-a-0", },\r\n{ "CPU A 2", "cpu-fan-b-0", },\r\n{ "CPU A 3", "cpu-fan-c-0", },\r\n{ "CPU B 1", "cpu-fan-a-1", },\r\n{ "CPU B 2", "cpu-fan-b-1", },\r\n{ "CPU B 3", "cpu-fan-c-1", },\r\n};\r\nstruct device_node *np = NULL, *fcu = pv->i2c->dev.of_node;\r\nint i;\r\nDBG("Looking up FCU controls in device-tree...\n");\r\nwhile ((np = of_get_next_child(fcu, np)) != NULL) {\r\nint id, type = -1;\r\nconst char *loc;\r\nconst char *name;\r\nconst u32 *reg;\r\nDBG(" control: %s, type: %s\n", np->name, np->type);\r\nif (!strcmp(np->type, "fan-rpm-control") ||\r\n!strcmp(np->type, "fan-rpm"))\r\ntype = FCU_FAN_RPM;\r\nif (!strcmp(np->type, "fan-pwm-control") ||\r\n!strcmp(np->type, "fan-pwm"))\r\ntype = FCU_FAN_PWM;\r\nif (type == -1)\r\ncontinue;\r\nloc = of_get_property(np, "location", NULL);\r\nreg = of_get_property(np, "reg", NULL);\r\nif (loc == NULL || reg == NULL)\r\ncontinue;\r\nDBG(" matching location: %s, reg: 0x%08x\n", loc, *reg);\r\nfor (i = 0; i < ARRAY_SIZE(loc_trans); i++) {\r\nif (strncmp(loc, loc_trans[i].dt_name,\r\nstrlen(loc_trans[i].dt_name)))\r\ncontinue;\r\nname = loc_trans[i].ct_name;\r\nDBG(" location match, name: %s\n", name);\r\nif (type == FCU_FAN_RPM)\r\nid = ((*reg) - 0x10) / 2;\r\nelse\r\nid = ((*reg) - 0x30) / 2;\r\nif (id > 7) {\r\npr_warning("wf_fcu: Can't parse "\r\n"fan ID in device-tree for %s\n",\r\nnp->full_name);\r\nbreak;\r\n}\r\nwf_fcu_add_fan(pv, name, type, id);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __devinit wf_fcu_default_fans(struct wf_fcu_priv *pv)\r\n{\r\nif (!of_machine_is_compatible("PowerMac7,2"))\r\nreturn;\r\nwf_fcu_add_fan(pv, "backside-fan", FCU_FAN_PWM, 1);\r\nwf_fcu_add_fan(pv, "drive-bay-fan", FCU_FAN_RPM, 2);\r\nwf_fcu_add_fan(pv, "slots-fan", FCU_FAN_PWM, 2);\r\nwf_fcu_add_fan(pv, "cpu-front-fan-0", FCU_FAN_RPM, 3);\r\nwf_fcu_add_fan(pv, "cpu-rear-fan-0", FCU_FAN_RPM, 4);\r\nwf_fcu_add_fan(pv, "cpu-front-fan-1", FCU_FAN_RPM, 5);\r\nwf_fcu_add_fan(pv, "cpu-rear-fan-1", FCU_FAN_RPM, 6);\r\n}\r\nstatic int __devinit wf_fcu_init_chip(struct wf_fcu_priv *pv)\r\n{\r\nunsigned char buf = 0xff;\r\nint rc;\r\nrc = wf_fcu_write_reg(pv, 0xe, &buf, 1);\r\nif (rc < 0)\r\nreturn -EIO;\r\nrc = wf_fcu_write_reg(pv, 0x2e, &buf, 1);\r\nif (rc < 0)\r\nreturn -EIO;\r\nrc = wf_fcu_read_reg(pv, 0, &buf, 1);\r\nif (rc < 0)\r\nreturn -EIO;\r\npv->rpm_shift = (buf == 1) ? 2 : 3;\r\npr_debug("wf_fcu: FCU Initialized, RPM fan shift is %d\n",\r\npv->rpm_shift);\r\nreturn 0;\r\n}\r\nstatic int __devinit wf_fcu_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wf_fcu_priv *pv;\r\npv = kzalloc(sizeof(*pv), GFP_KERNEL);\r\nif (!pv)\r\nreturn -ENOMEM;\r\nkref_init(&pv->ref);\r\nmutex_init(&pv->lock);\r\nINIT_LIST_HEAD(&pv->fan_list);\r\npv->i2c = client;\r\nif (wf_fcu_init_chip(pv)) {\r\npr_err("wf_fcu: Initialization failed !\n");\r\nkfree(pv);\r\nreturn -ENXIO;\r\n}\r\nwf_fcu_lookup_fans(pv);\r\nif (list_empty(&pv->fan_list))\r\nwf_fcu_default_fans(pv);\r\nif (list_empty(&pv->fan_list)) {\r\npr_err("wf_fcu: Failed to find fans for your machine\n");\r\nkfree(pv);\r\nreturn -ENODEV;\r\n}\r\ndev_set_drvdata(&client->dev, pv);\r\nreturn 0;\r\n}\r\nstatic int __devexit wf_fcu_remove(struct i2c_client *client)\r\n{\r\nstruct wf_fcu_priv *pv = dev_get_drvdata(&client->dev);\r\nstruct wf_fcu_fan *fan;\r\nwhile (!list_empty(&pv->fan_list)) {\r\nfan = list_first_entry(&pv->fan_list, struct wf_fcu_fan, link);\r\nlist_del(&fan->link);\r\nwf_unregister_control(&fan->ctrl);\r\n}\r\nkref_put(&pv->ref, wf_fcu_release);\r\nreturn 0;\r\n}\r\nstatic int __init wf_fcu_init(void)\r\n{\r\nreturn i2c_add_driver(&wf_fcu_driver);\r\n}\r\nstatic void __exit wf_fcu_exit(void)\r\n{\r\ni2c_del_driver(&wf_fcu_driver);\r\n}
