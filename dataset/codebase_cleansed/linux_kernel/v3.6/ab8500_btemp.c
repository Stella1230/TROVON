struct ab8500_btemp *ab8500_btemp_get(void)\r\n{\r\nstruct ab8500_btemp *btemp;\r\nbtemp = list_first_entry(&ab8500_btemp_list, struct ab8500_btemp, node);\r\nreturn btemp;\r\n}\r\nstatic int ab8500_btemp_batctrl_volt_to_res(struct ab8500_btemp *di,\r\nint v_batctrl, int inst_curr)\r\n{\r\nint rbs;\r\nif (is_ab8500_1p1_or_earlier(di->parent)) {\r\nreturn (450000 * (v_batctrl)) / (1800 - v_batctrl);\r\n}\r\nif (di->bat->adc_therm == ABx500_ADC_THERM_BATCTRL) {\r\nrbs = (v_batctrl * 1000\r\n- di->bat->gnd_lift_resistance * inst_curr)\r\n/ di->curr_source;\r\n} else {\r\nrbs = (80000 * (v_batctrl)) / (1800 - v_batctrl);\r\n}\r\nreturn rbs;\r\n}\r\nstatic int ab8500_btemp_read_batctrl_voltage(struct ab8500_btemp *di)\r\n{\r\nint vbtemp;\r\nstatic int prev;\r\nvbtemp = ab8500_gpadc_convert(di->gpadc, BAT_CTRL);\r\nif (vbtemp < 0) {\r\ndev_err(di->dev,\r\n"%s gpadc conversion failed, using previous value",\r\n__func__);\r\nreturn prev;\r\n}\r\nprev = vbtemp;\r\nreturn vbtemp;\r\n}\r\nstatic int ab8500_btemp_curr_source_enable(struct ab8500_btemp *di,\r\nbool enable)\r\n{\r\nint curr;\r\nint ret = 0;\r\nif (is_ab8500_1p1_or_earlier(di->parent))\r\nreturn 0;\r\nif (di->bat->adc_therm == ABx500_ADC_THERM_BATCTRL && enable) {\r\nif (di->curr_source == BTEMP_BATCTRL_CURR_SRC_7UA)\r\ncurr = BAT_CTRL_7U_ENA;\r\nelse\r\ncurr = BAT_CTRL_20U_ENA;\r\ndev_dbg(di->dev, "Set BATCTRL %duA\n", di->curr_source);\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nFORCE_BAT_CTRL_CMP_HIGH, FORCE_BAT_CTRL_CMP_HIGH);\r\nif (ret) {\r\ndev_err(di->dev, "%s failed setting cmp_force\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nudelay(32);\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nFORCE_BAT_CTRL_CMP_HIGH | curr);\r\nif (ret) {\r\ndev_err(di->dev, "%s failed enabling current source\n",\r\n__func__);\r\ngoto disable_curr_source;\r\n}\r\n} else if (di->bat->adc_therm == ABx500_ADC_THERM_BATCTRL && !enable) {\r\ndev_dbg(di->dev, "Disable BATCTRL curr source\n");\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nBAT_CTRL_7U_ENA | BAT_CTRL_20U_ENA,\r\n~(BAT_CTRL_7U_ENA | BAT_CTRL_20U_ENA));\r\nif (ret) {\r\ndev_err(di->dev, "%s failed disabling current source\n",\r\n__func__);\r\ngoto disable_curr_source;\r\n}\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nBAT_CTRL_PULL_UP_ENA | BAT_CTRL_CMP_ENA,\r\nBAT_CTRL_PULL_UP_ENA | BAT_CTRL_CMP_ENA);\r\nif (ret) {\r\ndev_err(di->dev, "%s failed enabling PU and comp\n",\r\n__func__);\r\ngoto enable_pu_comp;\r\n}\r\nudelay(32);\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nFORCE_BAT_CTRL_CMP_HIGH, ~FORCE_BAT_CTRL_CMP_HIGH);\r\nif (ret) {\r\ndev_err(di->dev, "%s failed disabling force comp\n",\r\n__func__);\r\ngoto disable_force_comp;\r\n}\r\n}\r\nreturn ret;\r\ndisable_curr_source:\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nBAT_CTRL_7U_ENA | BAT_CTRL_20U_ENA,\r\n~(BAT_CTRL_7U_ENA | BAT_CTRL_20U_ENA));\r\nif (ret) {\r\ndev_err(di->dev, "%s failed disabling current source\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nenable_pu_comp:\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nBAT_CTRL_PULL_UP_ENA | BAT_CTRL_CMP_ENA,\r\nBAT_CTRL_PULL_UP_ENA | BAT_CTRL_CMP_ENA);\r\nif (ret) {\r\ndev_err(di->dev, "%s failed enabling PU and comp\n",\r\n__func__);\r\nreturn ret;\r\n}\r\ndisable_force_comp:\r\nudelay(32);\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_BAT_CTRL_CURRENT_SOURCE,\r\nFORCE_BAT_CTRL_CMP_HIGH, ~FORCE_BAT_CTRL_CMP_HIGH);\r\nif (ret) {\r\ndev_err(di->dev, "%s failed disabling force comp\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ab8500_btemp_get_batctrl_res(struct ab8500_btemp *di)\r\n{\r\nint ret;\r\nint batctrl = 0;\r\nint res;\r\nint inst_curr;\r\nint i;\r\nret = ab8500_btemp_curr_source_enable(di, true);\r\nif (ret) {\r\ndev_err(di->dev, "%s curr source enabled failed\n", __func__);\r\nreturn ret;\r\n}\r\nif (!di->fg)\r\ndi->fg = ab8500_fg_get();\r\nif (!di->fg) {\r\ndev_err(di->dev, "No fg found\n");\r\nreturn -EINVAL;\r\n}\r\nret = ab8500_fg_inst_curr_start(di->fg);\r\nif (ret) {\r\ndev_err(di->dev, "Failed to start current measurement\n");\r\nreturn ret;\r\n}\r\ni = 0;\r\ndo {\r\nbatctrl += ab8500_btemp_read_batctrl_voltage(di);\r\ni++;\r\nmsleep(20);\r\n} while (!ab8500_fg_inst_curr_done(di->fg));\r\nbatctrl /= i;\r\nret = ab8500_fg_inst_curr_finalize(di->fg, &inst_curr);\r\nif (ret) {\r\ndev_err(di->dev, "Failed to finalize current measurement\n");\r\nreturn ret;\r\n}\r\nres = ab8500_btemp_batctrl_volt_to_res(di, batctrl, inst_curr);\r\nret = ab8500_btemp_curr_source_enable(di, false);\r\nif (ret) {\r\ndev_err(di->dev, "%s curr source disable failed\n", __func__);\r\nreturn ret;\r\n}\r\ndev_dbg(di->dev, "%s batctrl: %d res: %d inst_curr: %d samples: %d\n",\r\n__func__, batctrl, res, inst_curr, i);\r\nreturn res;\r\n}\r\nstatic int ab8500_btemp_res_to_temp(struct ab8500_btemp *di,\r\nconst struct abx500_res_to_temp *tbl, int tbl_size, int res)\r\n{\r\nint i, temp;\r\nif (res > tbl[0].resist)\r\ni = 0;\r\nelse if (res <= tbl[tbl_size - 1].resist)\r\ni = tbl_size - 2;\r\nelse {\r\ni = 0;\r\nwhile (!(res <= tbl[i].resist &&\r\nres > tbl[i + 1].resist))\r\ni++;\r\n}\r\ntemp = tbl[i].temp + ((tbl[i + 1].temp - tbl[i].temp) *\r\n(res - tbl[i].resist)) / (tbl[i + 1].resist - tbl[i].resist);\r\nreturn temp;\r\n}\r\nstatic int ab8500_btemp_measure_temp(struct ab8500_btemp *di)\r\n{\r\nint temp;\r\nstatic int prev;\r\nint rbat, rntc, vntc;\r\nu8 id;\r\nid = di->bat->batt_id;\r\nif (di->bat->adc_therm == ABx500_ADC_THERM_BATCTRL &&\r\nid != BATTERY_UNKNOWN) {\r\nrbat = ab8500_btemp_get_batctrl_res(di);\r\nif (rbat < 0) {\r\ndev_err(di->dev, "%s get batctrl res failed\n",\r\n__func__);\r\nreturn BTEMP_THERMAL_LOW_LIMIT;\r\n}\r\ntemp = ab8500_btemp_res_to_temp(di,\r\ndi->bat->bat_type[id].r_to_t_tbl,\r\ndi->bat->bat_type[id].n_temp_tbl_elements, rbat);\r\n} else {\r\nvntc = ab8500_gpadc_convert(di->gpadc, BTEMP_BALL);\r\nif (vntc < 0) {\r\ndev_err(di->dev,\r\n"%s gpadc conversion failed,"\r\n" using previous value\n", __func__);\r\nreturn prev;\r\n}\r\nrntc = 230000 * vntc / (VTVOUT_V - vntc);\r\ntemp = ab8500_btemp_res_to_temp(di,\r\ndi->bat->bat_type[id].r_to_t_tbl,\r\ndi->bat->bat_type[id].n_temp_tbl_elements, rntc);\r\nprev = temp;\r\n}\r\ndev_dbg(di->dev, "Battery temperature is %d\n", temp);\r\nreturn temp;\r\n}\r\nstatic int ab8500_btemp_id(struct ab8500_btemp *di)\r\n{\r\nint res;\r\nu8 i;\r\ndi->curr_source = BTEMP_BATCTRL_CURR_SRC_7UA;\r\ndi->bat->batt_id = BATTERY_UNKNOWN;\r\nres = ab8500_btemp_get_batctrl_res(di);\r\nif (res < 0) {\r\ndev_err(di->dev, "%s get batctrl res failed\n", __func__);\r\nreturn -ENXIO;\r\n}\r\nfor (i = BATTERY_UNKNOWN + 1; i < di->bat->n_btypes; i++) {\r\nif ((res <= di->bat->bat_type[i].resis_high) &&\r\n(res >= di->bat->bat_type[i].resis_low)) {\r\ndev_dbg(di->dev, "Battery detected on %s"\r\n" low %d < res %d < high: %d"\r\n" index: %d\n",\r\ndi->bat->adc_therm == ABx500_ADC_THERM_BATCTRL ?\r\n"BATCTRL" : "BATTEMP",\r\ndi->bat->bat_type[i].resis_low, res,\r\ndi->bat->bat_type[i].resis_high, i);\r\ndi->bat->batt_id = i;\r\nbreak;\r\n}\r\n}\r\nif (di->bat->batt_id == BATTERY_UNKNOWN) {\r\ndev_warn(di->dev, "Battery identified as unknown"\r\n", resistance %d Ohm\n", res);\r\nreturn -ENXIO;\r\n}\r\nif (di->bat->adc_therm == ABx500_ADC_THERM_BATCTRL &&\r\ndi->bat->batt_id == 1) {\r\ndev_dbg(di->dev, "Set BATCTRL current source to 20uA\n");\r\ndi->curr_source = BTEMP_BATCTRL_CURR_SRC_20UA;\r\n}\r\nreturn di->bat->batt_id;\r\n}\r\nstatic void ab8500_btemp_periodic_work(struct work_struct *work)\r\n{\r\nint interval;\r\nstruct ab8500_btemp *di = container_of(work,\r\nstruct ab8500_btemp, btemp_periodic_work.work);\r\ndi->bat_temp = ab8500_btemp_measure_temp(di);\r\nif (di->bat_temp != di->prev_bat_temp) {\r\ndi->prev_bat_temp = di->bat_temp;\r\npower_supply_changed(&di->btemp_psy);\r\n}\r\nif (di->events.ac_conn || di->events.usb_conn)\r\ninterval = di->bat->temp_interval_chg;\r\nelse\r\ninterval = di->bat->temp_interval_nochg;\r\nqueue_delayed_work(di->btemp_wq,\r\n&di->btemp_periodic_work,\r\nround_jiffies(interval * HZ));\r\n}\r\nstatic irqreturn_t ab8500_btemp_batctrlindb_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_btemp *di = _di;\r\ndev_err(di->dev, "Battery removal detected!\n");\r\ndi->events.batt_rem = true;\r\npower_supply_changed(&di->btemp_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_btemp_templow_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_btemp *di = _di;\r\nif (is_ab8500_2p0_or_earlier(di->parent)) {\r\ndev_dbg(di->dev, "Ignore false btemp low irq"\r\n" for ABB cut 1.0, 1.1 and 2.0\n");\r\n} else {\r\ndev_crit(di->dev, "Battery temperature lower than -10deg c\n");\r\ndi->events.btemp_low = true;\r\ndi->events.btemp_high = false;\r\ndi->events.btemp_medhigh = false;\r\ndi->events.btemp_lowmed = false;\r\npower_supply_changed(&di->btemp_psy);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_btemp_temphigh_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_btemp *di = _di;\r\ndev_crit(di->dev, "Battery temperature is higher than MAX temp\n");\r\ndi->events.btemp_high = true;\r\ndi->events.btemp_medhigh = false;\r\ndi->events.btemp_lowmed = false;\r\ndi->events.btemp_low = false;\r\npower_supply_changed(&di->btemp_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_btemp_lowmed_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_btemp *di = _di;\r\ndev_dbg(di->dev, "Battery temperature is between low and medium\n");\r\ndi->events.btemp_lowmed = true;\r\ndi->events.btemp_medhigh = false;\r\ndi->events.btemp_high = false;\r\ndi->events.btemp_low = false;\r\npower_supply_changed(&di->btemp_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_btemp_medhigh_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_btemp *di = _di;\r\ndev_dbg(di->dev, "Battery temperature is between medium and high\n");\r\ndi->events.btemp_medhigh = true;\r\ndi->events.btemp_lowmed = false;\r\ndi->events.btemp_high = false;\r\ndi->events.btemp_low = false;\r\npower_supply_changed(&di->btemp_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ab8500_btemp_periodic(struct ab8500_btemp *di,\r\nbool enable)\r\n{\r\ndev_dbg(di->dev, "Enable periodic temperature measurements: %d\n",\r\nenable);\r\ncancel_delayed_work_sync(&di->btemp_periodic_work);\r\nif (enable)\r\nqueue_delayed_work(di->btemp_wq, &di->btemp_periodic_work, 0);\r\n}\r\nstatic int ab8500_btemp_get_temp(struct ab8500_btemp *di)\r\n{\r\nint temp = 0;\r\nif (is_ab8500_2p0_or_earlier(di->parent)) {\r\ntemp = di->bat_temp * 10;\r\n} else {\r\nif (di->events.btemp_low) {\r\nif (temp > di->btemp_ranges.btemp_low_limit)\r\ntemp = di->btemp_ranges.btemp_low_limit;\r\nelse\r\ntemp = di->bat_temp * 10;\r\n} else if (di->events.btemp_high) {\r\nif (temp < di->btemp_ranges.btemp_high_limit)\r\ntemp = di->btemp_ranges.btemp_high_limit;\r\nelse\r\ntemp = di->bat_temp * 10;\r\n} else if (di->events.btemp_lowmed) {\r\nif (temp > di->btemp_ranges.btemp_med_limit)\r\ntemp = di->btemp_ranges.btemp_med_limit;\r\nelse\r\ntemp = di->bat_temp * 10;\r\n} else if (di->events.btemp_medhigh) {\r\nif (temp < di->btemp_ranges.btemp_med_limit)\r\ntemp = di->btemp_ranges.btemp_med_limit;\r\nelse\r\ntemp = di->bat_temp * 10;\r\n} else\r\ntemp = di->bat_temp * 10;\r\n}\r\nreturn temp;\r\n}\r\nint ab8500_btemp_get_batctrl_temp(struct ab8500_btemp *btemp)\r\n{\r\nreturn btemp->bat_temp * 1000;\r\n}\r\nstatic int ab8500_btemp_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct ab8500_btemp *di;\r\ndi = to_ab8500_btemp_device_info(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nif (di->events.batt_rem)\r\nval->intval = 0;\r\nelse\r\nval->intval = 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = di->bat->bat_type[di->bat->batt_id].name;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval = ab8500_btemp_get_temp(di);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_btemp_get_ext_psy_data(struct device *dev, void *data)\r\n{\r\nstruct power_supply *psy;\r\nstruct power_supply *ext;\r\nstruct ab8500_btemp *di;\r\nunion power_supply_propval ret;\r\nint i, j;\r\nbool psy_found = false;\r\npsy = (struct power_supply *)data;\r\next = dev_get_drvdata(dev);\r\ndi = to_ab8500_btemp_device_info(psy);\r\nfor (i = 0; i < ext->num_supplicants; i++) {\r\nif (!strcmp(ext->supplied_to[i], psy->name))\r\npsy_found = true;\r\n}\r\nif (!psy_found)\r\nreturn 0;\r\nfor (j = 0; j < ext->num_properties; j++) {\r\nenum power_supply_property prop;\r\nprop = ext->properties[j];\r\nif (ext->get_property(ext, prop, &ret))\r\ncontinue;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_MAINS:\r\nif (!ret.intval && di->events.ac_conn) {\r\ndi->events.ac_conn = false;\r\n}\r\nelse if (ret.intval && !di->events.ac_conn) {\r\ndi->events.ac_conn = true;\r\nif (!di->events.usb_conn)\r\nab8500_btemp_periodic(di, true);\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\nif (!ret.intval && di->events.usb_conn) {\r\ndi->events.usb_conn = false;\r\n}\r\nelse if (ret.intval && !di->events.usb_conn) {\r\ndi->events.usb_conn = true;\r\nif (!di->events.ac_conn)\r\nab8500_btemp_periodic(di, true);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ab8500_btemp_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct ab8500_btemp *di = to_ab8500_btemp_device_info(psy);\r\nclass_for_each_device(power_supply_class, NULL,\r\n&di->btemp_psy, ab8500_btemp_get_ext_psy_data);\r\n}\r\nstatic int ab8500_btemp_resume(struct platform_device *pdev)\r\n{\r\nstruct ab8500_btemp *di = platform_get_drvdata(pdev);\r\nab8500_btemp_periodic(di, true);\r\nreturn 0;\r\n}\r\nstatic int ab8500_btemp_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct ab8500_btemp *di = platform_get_drvdata(pdev);\r\nab8500_btemp_periodic(di, false);\r\nreturn 0;\r\n}\r\nstatic int __devexit ab8500_btemp_remove(struct platform_device *pdev)\r\n{\r\nstruct ab8500_btemp *di = platform_get_drvdata(pdev);\r\nint i, irq;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_btemp_irq); i++) {\r\nirq = platform_get_irq_byname(pdev, ab8500_btemp_irq[i].name);\r\nfree_irq(irq, di);\r\n}\r\ndestroy_workqueue(di->btemp_wq);\r\nflush_scheduled_work();\r\npower_supply_unregister(&di->btemp_psy);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(di);\r\nreturn 0;\r\n}\r\nstatic int __devinit ab8500_btemp_probe(struct platform_device *pdev)\r\n{\r\nint irq, i, ret = 0;\r\nu8 val;\r\nstruct abx500_bm_plat_data *plat_data = pdev->dev.platform_data;\r\nstruct ab8500_btemp *di;\r\nif (!plat_data) {\r\ndev_err(&pdev->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\ndi = kzalloc(sizeof(*di), GFP_KERNEL);\r\nif (!di)\r\nreturn -ENOMEM;\r\ndi->dev = &pdev->dev;\r\ndi->parent = dev_get_drvdata(pdev->dev.parent);\r\ndi->gpadc = ab8500_gpadc_get("ab8500-gpadc.0");\r\ndi->pdata = plat_data->btemp;\r\nif (!di->pdata) {\r\ndev_err(di->dev, "no btemp platform data supplied\n");\r\nret = -EINVAL;\r\ngoto free_device_info;\r\n}\r\ndi->bat = plat_data->battery;\r\nif (!di->bat) {\r\ndev_err(di->dev, "no battery platform data supplied\n");\r\nret = -EINVAL;\r\ngoto free_device_info;\r\n}\r\ndi->btemp_psy.name = "ab8500_btemp";\r\ndi->btemp_psy.type = POWER_SUPPLY_TYPE_BATTERY;\r\ndi->btemp_psy.properties = ab8500_btemp_props;\r\ndi->btemp_psy.num_properties = ARRAY_SIZE(ab8500_btemp_props);\r\ndi->btemp_psy.get_property = ab8500_btemp_get_property;\r\ndi->btemp_psy.supplied_to = di->pdata->supplied_to;\r\ndi->btemp_psy.num_supplicants = di->pdata->num_supplicants;\r\ndi->btemp_psy.external_power_changed =\r\nab8500_btemp_external_power_changed;\r\ndi->btemp_wq =\r\ncreate_singlethread_workqueue("ab8500_btemp_wq");\r\nif (di->btemp_wq == NULL) {\r\ndev_err(di->dev, "failed to create work queue\n");\r\ngoto free_device_info;\r\n}\r\nINIT_DELAYED_WORK_DEFERRABLE(&di->btemp_periodic_work,\r\nab8500_btemp_periodic_work);\r\nif (ab8500_btemp_id(di) < 0)\r\ndev_warn(di->dev, "failed to identify the battery\n");\r\ndi->btemp_ranges.btemp_low_limit = BTEMP_THERMAL_LOW_LIMIT;\r\ndi->btemp_ranges.btemp_med_limit = BTEMP_THERMAL_MED_LIMIT;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_CHARGER,\r\nAB8500_BTEMP_HIGH_TH, &val);\r\nif (ret < 0) {\r\ndev_err(di->dev, "%s ab8500 read failed\n", __func__);\r\ngoto free_btemp_wq;\r\n}\r\nswitch (val) {\r\ncase BTEMP_HIGH_TH_57_0:\r\ncase BTEMP_HIGH_TH_57_1:\r\ndi->btemp_ranges.btemp_high_limit =\r\nBTEMP_THERMAL_HIGH_LIMIT_57;\r\nbreak;\r\ncase BTEMP_HIGH_TH_52:\r\ndi->btemp_ranges.btemp_high_limit =\r\nBTEMP_THERMAL_HIGH_LIMIT_52;\r\nbreak;\r\ncase BTEMP_HIGH_TH_62:\r\ndi->btemp_ranges.btemp_high_limit =\r\nBTEMP_THERMAL_HIGH_LIMIT_62;\r\nbreak;\r\n}\r\nret = power_supply_register(di->dev, &di->btemp_psy);\r\nif (ret) {\r\ndev_err(di->dev, "failed to register BTEMP psy\n");\r\ngoto free_btemp_wq;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_btemp_irq); i++) {\r\nirq = platform_get_irq_byname(pdev, ab8500_btemp_irq[i].name);\r\nret = request_threaded_irq(irq, NULL, ab8500_btemp_irq[i].isr,\r\nIRQF_SHARED | IRQF_NO_SUSPEND,\r\nab8500_btemp_irq[i].name, di);\r\nif (ret) {\r\ndev_err(di->dev, "failed to request %s IRQ %d: %d\n"\r\n, ab8500_btemp_irq[i].name, irq, ret);\r\ngoto free_irq;\r\n}\r\ndev_dbg(di->dev, "Requested %s IRQ %d: %d\n",\r\nab8500_btemp_irq[i].name, irq, ret);\r\n}\r\nplatform_set_drvdata(pdev, di);\r\nab8500_btemp_periodic(di, true);\r\nlist_add_tail(&di->node, &ab8500_btemp_list);\r\nreturn ret;\r\nfree_irq:\r\npower_supply_unregister(&di->btemp_psy);\r\nfor (i = i - 1; i >= 0; i--) {\r\nirq = platform_get_irq_byname(pdev, ab8500_btemp_irq[i].name);\r\nfree_irq(irq, di);\r\n}\r\nfree_btemp_wq:\r\ndestroy_workqueue(di->btemp_wq);\r\nfree_device_info:\r\nkfree(di);\r\nreturn ret;\r\n}\r\nstatic int __init ab8500_btemp_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_btemp_driver);\r\n}\r\nstatic void __exit ab8500_btemp_exit(void)\r\n{\r\nplatform_driver_unregister(&ab8500_btemp_driver);\r\n}
