static inline u32\r\nip_to_id(const struct bitmap_ip *m, u32 ip)\r\n{\r\nreturn ((ip & ip_set_hostmask(m->netmask)) - m->first_ip)/m->hosts;\r\n}\r\nstatic int\r\nbitmap_ip_test(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nconst struct bitmap_ip *map = set->data;\r\nu16 id = *(u16 *)value;\r\nreturn !!test_bit(id, map->members);\r\n}\r\nstatic int\r\nbitmap_ip_add(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nu16 id = *(u16 *)value;\r\nif (test_and_set_bit(id, map->members))\r\nreturn -IPSET_ERR_EXIST;\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ip_del(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nu16 id = *(u16 *)value;\r\nif (!test_and_clear_bit(id, map->members))\r\nreturn -IPSET_ERR_EXIST;\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ip_list(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct bitmap_ip *map = set->data;\r\nstruct nlattr *atd, *nested;\r\nu32 id, first = cb->args[2];\r\natd = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!atd)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[2] < map->elements; cb->args[2]++) {\r\nid = cb->args[2];\r\nif (!test_bit(id, map->members))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (id == first) {\r\nnla_nest_cancel(skb, atd);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP,\r\nhtonl(map->first_ip + id * map->hosts)))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\n}\r\nipset_nest_end(skb, atd);\r\ncb->args[2] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nipset_nest_end(skb, atd);\r\nif (unlikely(id == first)) {\r\ncb->args[2] = 0;\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ip_ttest(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nconst struct bitmap_ip *map = set->data;\r\nconst unsigned long *members = map->members;\r\nu16 id = *(u16 *)value;\r\nreturn ip_set_timeout_test(members[id]);\r\n}\r\nstatic int\r\nbitmap_ip_tadd(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nunsigned long *members = map->members;\r\nu16 id = *(u16 *)value;\r\nif (ip_set_timeout_test(members[id]) && !(flags & IPSET_FLAG_EXIST))\r\nreturn -IPSET_ERR_EXIST;\r\nmembers[id] = ip_set_timeout_set(timeout);\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ip_tdel(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nunsigned long *members = map->members;\r\nu16 id = *(u16 *)value;\r\nint ret = -IPSET_ERR_EXIST;\r\nif (ip_set_timeout_test(members[id]))\r\nret = 0;\r\nmembers[id] = IPSET_ELEM_UNSET;\r\nreturn ret;\r\n}\r\nstatic int\r\nbitmap_ip_tlist(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct bitmap_ip *map = set->data;\r\nstruct nlattr *adt, *nested;\r\nu32 id, first = cb->args[2];\r\nconst unsigned long *members = map->members;\r\nadt = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!adt)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[2] < map->elements; cb->args[2]++) {\r\nid = cb->args[2];\r\nif (!ip_set_timeout_test(members[id]))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (id == first) {\r\nnla_nest_cancel(skb, adt);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP,\r\nhtonl(map->first_ip + id * map->hosts)) ||\r\nnla_put_net32(skb, IPSET_ATTR_TIMEOUT,\r\nhtonl(ip_set_timeout_get(members[id]))))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\n}\r\nipset_nest_end(skb, adt);\r\ncb->args[2] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nipset_nest_end(skb, adt);\r\nif (unlikely(id == first)) {\r\ncb->args[2] = 0;\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ip_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nu32 ip;\r\nip = ntohl(ip4addr(skb, opt->flags & IPSET_DIM_ONE_SRC));\r\nif (ip < map->first_ip || ip > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nip = ip_to_id(map, ip);\r\nreturn adtfn(set, &ip, opt_timeout(opt, map), opt->cmdflags);\r\n}\r\nstatic int\r\nbitmap_ip_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nu32 timeout = map->timeout;\r\nu32 ip, ip_to, id;\r\nint ret = 0;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\r\nif (ret)\r\nreturn ret;\r\nif (ip < map->first_ip || ip > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout(map->timeout))\r\nreturn -IPSET_ERR_TIMEOUT;\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nif (adt == IPSET_TEST) {\r\nid = ip_to_id(map, ip);\r\nreturn adtfn(set, &id, timeout, flags);\r\n}\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\r\nif (ret)\r\nreturn ret;\r\nif (ip > ip_to) {\r\nswap(ip, ip_to);\r\nif (ip < map->first_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\n}\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (cidr > 32)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(ip, ip_to, cidr);\r\n} else\r\nip_to = ip;\r\nif (ip_to > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nfor (; !before(ip_to, ip); ip += map->hosts) {\r\nid = ip_to_id(map, ip);\r\nret = adtfn(set, &id, timeout, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nelse\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nbitmap_ip_destroy(struct ip_set *set)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nif (with_timeout(map->timeout))\r\ndel_timer_sync(&map->gc);\r\nip_set_free(map->members);\r\nkfree(map);\r\nset->data = NULL;\r\n}\r\nstatic void\r\nbitmap_ip_flush(struct ip_set *set)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nmemset(map->members, 0, map->memsize);\r\n}\r\nstatic int\r\nbitmap_ip_head(struct ip_set *set, struct sk_buff *skb)\r\n{\r\nconst struct bitmap_ip *map = set->data;\r\nstruct nlattr *nested;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested)\r\ngoto nla_put_failure;\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, htonl(map->first_ip)) ||\r\nnla_put_ipaddr4(skb, IPSET_ATTR_IP_TO, htonl(map->last_ip)) ||\r\n(map->netmask != 32 &&\r\nnla_put_u8(skb, IPSET_ATTR_NETMASK, map->netmask)) ||\r\nnla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1)) ||\r\nnla_put_net32(skb, IPSET_ATTR_MEMSIZE,\r\nhtonl(sizeof(*map) + map->memsize)) ||\r\n(with_timeout(map->timeout) &&\r\nnla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout))))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic bool\r\nbitmap_ip_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct bitmap_ip *x = a->data;\r\nconst struct bitmap_ip *y = b->data;\r\nreturn x->first_ip == y->first_ip &&\r\nx->last_ip == y->last_ip &&\r\nx->netmask == y->netmask &&\r\nx->timeout == y->timeout;\r\n}\r\nstatic void\r\nbitmap_ip_gc(unsigned long ul_set)\r\n{\r\nstruct ip_set *set = (struct ip_set *) ul_set;\r\nstruct bitmap_ip *map = set->data;\r\nunsigned long *table = map->members;\r\nu32 id;\r\nread_lock_bh(&set->lock);\r\nfor (id = 0; id < map->elements; id++)\r\nif (ip_set_timeout_expired(table[id]))\r\ntable[id] = IPSET_ELEM_UNSET;\r\nread_unlock_bh(&set->lock);\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic void\r\nbitmap_ip_gc_init(struct ip_set *set)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\ninit_timer(&map->gc);\r\nmap->gc.data = (unsigned long) set;\r\nmap->gc.function = bitmap_ip_gc;\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic bool\r\ninit_map_ip(struct ip_set *set, struct bitmap_ip *map,\r\nu32 first_ip, u32 last_ip,\r\nu32 elements, u32 hosts, u8 netmask)\r\n{\r\nmap->members = ip_set_alloc(map->memsize);\r\nif (!map->members)\r\nreturn false;\r\nmap->first_ip = first_ip;\r\nmap->last_ip = last_ip;\r\nmap->elements = elements;\r\nmap->hosts = hosts;\r\nmap->netmask = netmask;\r\nmap->timeout = IPSET_NO_TIMEOUT;\r\nset->data = map;\r\nset->family = NFPROTO_IPV4;\r\nreturn true;\r\n}\r\nstatic int\r\nbitmap_ip_create(struct ip_set *set, struct nlattr *tb[], u32 flags)\r\n{\r\nstruct bitmap_ip *map;\r\nu32 first_ip, last_ip, hosts, elements;\r\nu8 netmask = 32;\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &first_ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &last_ip);\r\nif (ret)\r\nreturn ret;\r\nif (first_ip > last_ip) {\r\nu32 tmp = first_ip;\r\nfirst_ip = last_ip;\r\nlast_ip = tmp;\r\n}\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (cidr >= 32)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(first_ip, last_ip, cidr);\r\n} else\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_NETMASK]) {\r\nnetmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);\r\nif (netmask > 32)\r\nreturn -IPSET_ERR_INVALID_NETMASK;\r\nfirst_ip &= ip_set_hostmask(netmask);\r\nlast_ip |= ~ip_set_hostmask(netmask);\r\n}\r\nif (netmask == 32) {\r\nhosts = 1;\r\nelements = last_ip - first_ip + 1;\r\n} else {\r\nu8 mask_bits;\r\nu32 mask;\r\nmask = range_to_mask(first_ip, last_ip, &mask_bits);\r\nif ((!mask && (first_ip || last_ip != 0xFFFFFFFF)) ||\r\nnetmask <= mask_bits)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\npr_debug("mask_bits %u, netmask %u\n", mask_bits, netmask);\r\nhosts = 2 << (32 - netmask - 1);\r\nelements = 2 << (netmask - mask_bits - 1);\r\n}\r\nif (elements > IPSET_BITMAP_MAX_RANGE + 1)\r\nreturn -IPSET_ERR_BITMAP_RANGE_SIZE;\r\npr_debug("hosts %u, elements %u\n", hosts, elements);\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nmap->memsize = elements * sizeof(unsigned long);\r\nif (!init_map_ip(set, map, first_ip, last_ip,\r\nelements, hosts, netmask)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nmap->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nset->variant = &bitmap_tip;\r\nbitmap_ip_gc_init(set);\r\n} else {\r\nmap->memsize = bitmap_bytes(0, elements - 1);\r\nif (!init_map_ip(set, map, first_ip, last_ip,\r\nelements, hosts, netmask)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nset->variant = &bitmap_ip;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nbitmap_ip_init(void)\r\n{\r\nreturn ip_set_type_register(&bitmap_ip_type);\r\n}\r\nstatic void __exit\r\nbitmap_ip_fini(void)\r\n{\r\nip_set_type_unregister(&bitmap_ip_type);\r\n}
