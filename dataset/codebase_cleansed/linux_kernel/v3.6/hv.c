static int query_hypervisor_presence(void)\r\n{\r\nunsigned int eax;\r\nunsigned int ebx;\r\nunsigned int ecx;\r\nunsigned int edx;\r\nunsigned int op;\r\neax = 0;\r\nebx = 0;\r\necx = 0;\r\nedx = 0;\r\nop = HVCPUID_VERSION_FEATURES;\r\ncpuid(op, &eax, &ebx, &ecx, &edx);\r\nreturn ecx & HV_PRESENT_BIT;\r\n}\r\nstatic int query_hypervisor_info(void)\r\n{\r\nunsigned int eax;\r\nunsigned int ebx;\r\nunsigned int ecx;\r\nunsigned int edx;\r\nunsigned int max_leaf;\r\nunsigned int op;\r\neax = 0;\r\nebx = 0;\r\necx = 0;\r\nedx = 0;\r\nop = HVCPUID_VENDOR_MAXFUNCTION;\r\ncpuid(op, &eax, &ebx, &ecx, &edx);\r\nmax_leaf = eax;\r\nif (max_leaf >= HVCPUID_VERSION) {\r\neax = 0;\r\nebx = 0;\r\necx = 0;\r\nedx = 0;\r\nop = HVCPUID_VERSION;\r\ncpuid(op, &eax, &ebx, &ecx, &edx);\r\npr_info("Hyper-V Host OS Build:%d-%d.%d-%d-%d.%d\n",\r\neax,\r\nebx >> 16,\r\nebx & 0xFFFF,\r\necx,\r\nedx >> 24,\r\nedx & 0xFFFFFF);\r\n}\r\nreturn max_leaf;\r\n}\r\nstatic u64 do_hypercall(u64 control, void *input, void *output)\r\n{\r\n#ifdef CONFIG_X86_64\r\nu64 hv_status = 0;\r\nu64 input_address = (input) ? virt_to_phys(input) : 0;\r\nu64 output_address = (output) ? virt_to_phys(output) : 0;\r\nvoid *hypercall_page = hv_context.hypercall_page;\r\n__asm__ __volatile__("mov %0, %%r8" : : "r" (output_address) : "r8");\r\n__asm__ __volatile__("call *%3" : "=a" (hv_status) :\r\n"c" (control), "d" (input_address),\r\n"m" (hypercall_page));\r\nreturn hv_status;\r\n#else\r\nu32 control_hi = control >> 32;\r\nu32 control_lo = control & 0xFFFFFFFF;\r\nu32 hv_status_hi = 1;\r\nu32 hv_status_lo = 1;\r\nu64 input_address = (input) ? virt_to_phys(input) : 0;\r\nu32 input_address_hi = input_address >> 32;\r\nu32 input_address_lo = input_address & 0xFFFFFFFF;\r\nu64 output_address = (output) ? virt_to_phys(output) : 0;\r\nu32 output_address_hi = output_address >> 32;\r\nu32 output_address_lo = output_address & 0xFFFFFFFF;\r\nvoid *hypercall_page = hv_context.hypercall_page;\r\n__asm__ __volatile__ ("call *%8" : "=d"(hv_status_hi),\r\n"=a"(hv_status_lo) : "d" (control_hi),\r\n"a" (control_lo), "b" (input_address_hi),\r\n"c" (input_address_lo), "D"(output_address_hi),\r\n"S"(output_address_lo), "m" (hypercall_page));\r\nreturn hv_status_lo | ((u64)hv_status_hi << 32);\r\n#endif\r\n}\r\nint hv_init(void)\r\n{\r\nint max_leaf;\r\nunion hv_x64_msr_hypercall_contents hypercall_msr;\r\nvoid *virtaddr = NULL;\r\nmemset(hv_context.synic_event_page, 0, sizeof(void *) * NR_CPUS);\r\nmemset(hv_context.synic_message_page, 0,\r\nsizeof(void *) * NR_CPUS);\r\nif (!query_hypervisor_presence())\r\ngoto cleanup;\r\nmax_leaf = query_hypervisor_info();\r\nwrmsrl(HV_X64_MSR_GUEST_OS_ID, HV_LINUX_GUEST_ID);\r\nhv_context.guestid = HV_LINUX_GUEST_ID;\r\nrdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nvirtaddr = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_EXEC);\r\nif (!virtaddr)\r\ngoto cleanup;\r\nhypercall_msr.enable = 1;\r\nhypercall_msr.guest_physical_address = vmalloc_to_pfn(virtaddr);\r\nwrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nhypercall_msr.as_uint64 = 0;\r\nrdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nif (!hypercall_msr.enable)\r\ngoto cleanup;\r\nhv_context.hypercall_page = virtaddr;\r\nhv_context.signal_event_buffer =\r\nkmalloc(sizeof(struct hv_input_signal_event_buffer),\r\nGFP_KERNEL);\r\nif (!hv_context.signal_event_buffer)\r\ngoto cleanup;\r\nhv_context.signal_event_param =\r\n(struct hv_input_signal_event *)\r\n(ALIGN((unsigned long)\r\nhv_context.signal_event_buffer,\r\nHV_HYPERCALL_PARAM_ALIGN));\r\nhv_context.signal_event_param->connectionid.asu32 = 0;\r\nhv_context.signal_event_param->connectionid.u.id =\r\nVMBUS_EVENT_CONNECTION_ID;\r\nhv_context.signal_event_param->flag_number = 0;\r\nhv_context.signal_event_param->rsvdz = 0;\r\nreturn 0;\r\ncleanup:\r\nif (virtaddr) {\r\nif (hypercall_msr.enable) {\r\nhypercall_msr.as_uint64 = 0;\r\nwrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\n}\r\nvfree(virtaddr);\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nvoid hv_cleanup(void)\r\n{\r\nunion hv_x64_msr_hypercall_contents hypercall_msr;\r\nwrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);\r\nkfree(hv_context.signal_event_buffer);\r\nhv_context.signal_event_buffer = NULL;\r\nhv_context.signal_event_param = NULL;\r\nif (hv_context.hypercall_page) {\r\nhypercall_msr.as_uint64 = 0;\r\nwrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nvfree(hv_context.hypercall_page);\r\nhv_context.hypercall_page = NULL;\r\n}\r\n}\r\nint hv_post_message(union hv_connection_id connection_id,\r\nenum hv_message_type message_type,\r\nvoid *payload, size_t payload_size)\r\n{\r\nstruct aligned_input {\r\nu64 alignment8;\r\nstruct hv_input_post_message msg;\r\n};\r\nstruct hv_input_post_message *aligned_msg;\r\nu16 status;\r\nunsigned long addr;\r\nif (payload_size > HV_MESSAGE_PAYLOAD_BYTE_COUNT)\r\nreturn -EMSGSIZE;\r\naddr = (unsigned long)kmalloc(sizeof(struct aligned_input), GFP_ATOMIC);\r\nif (!addr)\r\nreturn -ENOMEM;\r\naligned_msg = (struct hv_input_post_message *)\r\n(ALIGN(addr, HV_HYPERCALL_PARAM_ALIGN));\r\naligned_msg->connectionid = connection_id;\r\naligned_msg->message_type = message_type;\r\naligned_msg->payload_size = payload_size;\r\nmemcpy((void *)aligned_msg->payload, payload, payload_size);\r\nstatus = do_hypercall(HVCALL_POST_MESSAGE, aligned_msg, NULL)\r\n& 0xFFFF;\r\nkfree((void *)addr);\r\nreturn status;\r\n}\r\nu16 hv_signal_event(void)\r\n{\r\nu16 status;\r\nstatus = do_hypercall(HVCALL_SIGNAL_EVENT,\r\nhv_context.signal_event_param,\r\nNULL) & 0xFFFF;\r\nreturn status;\r\n}\r\nvoid hv_synic_init(void *irqarg)\r\n{\r\nu64 version;\r\nunion hv_synic_simp simp;\r\nunion hv_synic_siefp siefp;\r\nunion hv_synic_sint shared_sint;\r\nunion hv_synic_scontrol sctrl;\r\nu32 irq_vector = *((u32 *)(irqarg));\r\nint cpu = smp_processor_id();\r\nif (!hv_context.hypercall_page)\r\nreturn;\r\nrdmsrl(HV_X64_MSR_SVERSION, version);\r\nhv_context.synic_message_page[cpu] =\r\n(void *)get_zeroed_page(GFP_ATOMIC);\r\nif (hv_context.synic_message_page[cpu] == NULL) {\r\npr_err("Unable to allocate SYNIC message page\n");\r\ngoto cleanup;\r\n}\r\nhv_context.synic_event_page[cpu] =\r\n(void *)get_zeroed_page(GFP_ATOMIC);\r\nif (hv_context.synic_event_page[cpu] == NULL) {\r\npr_err("Unable to allocate SYNIC event page\n");\r\ngoto cleanup;\r\n}\r\nrdmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nsimp.simp_enabled = 1;\r\nsimp.base_simp_gpa = virt_to_phys(hv_context.synic_message_page[cpu])\r\n>> PAGE_SHIFT;\r\nwrmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nrdmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nsiefp.siefp_enabled = 1;\r\nsiefp.base_siefp_gpa = virt_to_phys(hv_context.synic_event_page[cpu])\r\n>> PAGE_SHIFT;\r\nwrmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nrdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nshared_sint.as_uint64 = 0;\r\nshared_sint.vector = irq_vector;\r\nshared_sint.masked = false;\r\nshared_sint.auto_eoi = false;\r\nwrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nrdmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);\r\nsctrl.enable = 1;\r\nwrmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);\r\nhv_context.synic_initialized = true;\r\nreturn;\r\ncleanup:\r\nif (hv_context.synic_event_page[cpu])\r\nfree_page((unsigned long)hv_context.synic_event_page[cpu]);\r\nif (hv_context.synic_message_page[cpu])\r\nfree_page((unsigned long)hv_context.synic_message_page[cpu]);\r\nreturn;\r\n}\r\nvoid hv_synic_cleanup(void *arg)\r\n{\r\nunion hv_synic_sint shared_sint;\r\nunion hv_synic_simp simp;\r\nunion hv_synic_siefp siefp;\r\nint cpu = smp_processor_id();\r\nif (!hv_context.synic_initialized)\r\nreturn;\r\nrdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nshared_sint.masked = 1;\r\nwrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nrdmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nsimp.simp_enabled = 0;\r\nsimp.base_simp_gpa = 0;\r\nwrmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nrdmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nsiefp.siefp_enabled = 0;\r\nsiefp.base_siefp_gpa = 0;\r\nwrmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nfree_page((unsigned long)hv_context.synic_message_page[cpu]);\r\nfree_page((unsigned long)hv_context.synic_event_page[cpu]);\r\n}
