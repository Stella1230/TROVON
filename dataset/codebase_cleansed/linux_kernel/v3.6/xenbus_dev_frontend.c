static ssize_t xenbus_file_read(struct file *filp,\r\nchar __user *ubuf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct xenbus_file_priv *u = filp->private_data;\r\nstruct read_buffer *rb;\r\nunsigned i;\r\nint ret;\r\nmutex_lock(&u->reply_mutex);\r\nagain:\r\nwhile (list_empty(&u->read_buffers)) {\r\nmutex_unlock(&u->reply_mutex);\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(u->read_waitq,\r\n!list_empty(&u->read_buffers));\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&u->reply_mutex);\r\n}\r\nrb = list_entry(u->read_buffers.next, struct read_buffer, list);\r\ni = 0;\r\nwhile (i < len) {\r\nunsigned sz = min((unsigned)len - i, rb->len - rb->cons);\r\nret = copy_to_user(ubuf + i, &rb->msg[rb->cons], sz);\r\ni += sz - ret;\r\nrb->cons += sz - ret;\r\nif (ret != 0) {\r\nif (i == 0)\r\ni = -EFAULT;\r\ngoto out;\r\n}\r\nif (rb->cons == rb->len) {\r\nlist_del(&rb->list);\r\nkfree(rb);\r\nif (list_empty(&u->read_buffers))\r\nbreak;\r\nrb = list_entry(u->read_buffers.next,\r\nstruct read_buffer, list);\r\n}\r\n}\r\nif (i == 0)\r\ngoto again;\r\nout:\r\nmutex_unlock(&u->reply_mutex);\r\nreturn i;\r\n}\r\nstatic int queue_reply(struct list_head *queue, const void *data, size_t len)\r\n{\r\nstruct read_buffer *rb;\r\nif (len == 0)\r\nreturn 0;\r\nrb = kmalloc(sizeof(*rb) + len, GFP_KERNEL);\r\nif (rb == NULL)\r\nreturn -ENOMEM;\r\nrb->cons = 0;\r\nrb->len = len;\r\nmemcpy(rb->msg, data, len);\r\nlist_add_tail(&rb->list, queue);\r\nreturn 0;\r\n}\r\nstatic void queue_cleanup(struct list_head *list)\r\n{\r\nstruct read_buffer *rb;\r\nwhile (!list_empty(list)) {\r\nrb = list_entry(list->next, struct read_buffer, list);\r\nlist_del(list->next);\r\nkfree(rb);\r\n}\r\n}\r\nstatic void free_watch_adapter(struct watch_adapter *watch)\r\n{\r\nkfree(watch->watch.node);\r\nkfree(watch->token);\r\nkfree(watch);\r\n}\r\nstatic struct watch_adapter *alloc_watch_adapter(const char *path,\r\nconst char *token)\r\n{\r\nstruct watch_adapter *watch;\r\nwatch = kzalloc(sizeof(*watch), GFP_KERNEL);\r\nif (watch == NULL)\r\ngoto out_fail;\r\nwatch->watch.node = kstrdup(path, GFP_KERNEL);\r\nif (watch->watch.node == NULL)\r\ngoto out_free;\r\nwatch->token = kstrdup(token, GFP_KERNEL);\r\nif (watch->token == NULL)\r\ngoto out_free;\r\nreturn watch;\r\nout_free:\r\nfree_watch_adapter(watch);\r\nout_fail:\r\nreturn NULL;\r\n}\r\nstatic void watch_fired(struct xenbus_watch *watch,\r\nconst char **vec,\r\nunsigned int len)\r\n{\r\nstruct watch_adapter *adap;\r\nstruct xsd_sockmsg hdr;\r\nconst char *path, *token;\r\nint path_len, tok_len, body_len, data_len = 0;\r\nint ret;\r\nLIST_HEAD(staging_q);\r\nadap = container_of(watch, struct watch_adapter, watch);\r\npath = vec[XS_WATCH_PATH];\r\ntoken = adap->token;\r\npath_len = strlen(path) + 1;\r\ntok_len = strlen(token) + 1;\r\nif (len > 2)\r\ndata_len = vec[len] - vec[2] + 1;\r\nbody_len = path_len + tok_len + data_len;\r\nhdr.type = XS_WATCH_EVENT;\r\nhdr.len = body_len;\r\nmutex_lock(&adap->dev_data->reply_mutex);\r\nret = queue_reply(&staging_q, &hdr, sizeof(hdr));\r\nif (!ret)\r\nret = queue_reply(&staging_q, path, path_len);\r\nif (!ret)\r\nret = queue_reply(&staging_q, token, tok_len);\r\nif (!ret && len > 2)\r\nret = queue_reply(&staging_q, vec[2], data_len);\r\nif (!ret) {\r\nlist_splice_tail(&staging_q, &adap->dev_data->read_buffers);\r\nwake_up(&adap->dev_data->read_waitq);\r\n} else\r\nqueue_cleanup(&staging_q);\r\nmutex_unlock(&adap->dev_data->reply_mutex);\r\n}\r\nstatic int xenbus_write_transaction(unsigned msg_type,\r\nstruct xenbus_file_priv *u)\r\n{\r\nint rc;\r\nvoid *reply;\r\nstruct xenbus_transaction_holder *trans = NULL;\r\nLIST_HEAD(staging_q);\r\nif (msg_type == XS_TRANSACTION_START) {\r\ntrans = kmalloc(sizeof(*trans), GFP_KERNEL);\r\nif (!trans) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nreply = xenbus_dev_request_and_reply(&u->u.msg);\r\nif (IS_ERR(reply)) {\r\nkfree(trans);\r\nrc = PTR_ERR(reply);\r\ngoto out;\r\n}\r\nif (msg_type == XS_TRANSACTION_START) {\r\ntrans->handle.id = simple_strtoul(reply, NULL, 0);\r\nlist_add(&trans->list, &u->transactions);\r\n} else if (msg_type == XS_TRANSACTION_END) {\r\nlist_for_each_entry(trans, &u->transactions, list)\r\nif (trans->handle.id == u->u.msg.tx_id)\r\nbreak;\r\nBUG_ON(&trans->list == &u->transactions);\r\nlist_del(&trans->list);\r\nkfree(trans);\r\n}\r\nmutex_lock(&u->reply_mutex);\r\nrc = queue_reply(&staging_q, &u->u.msg, sizeof(u->u.msg));\r\nif (!rc)\r\nrc = queue_reply(&staging_q, reply, u->u.msg.len);\r\nif (!rc) {\r\nlist_splice_tail(&staging_q, &u->read_buffers);\r\nwake_up(&u->read_waitq);\r\n} else {\r\nqueue_cleanup(&staging_q);\r\n}\r\nmutex_unlock(&u->reply_mutex);\r\nkfree(reply);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int xenbus_write_watch(unsigned msg_type, struct xenbus_file_priv *u)\r\n{\r\nstruct watch_adapter *watch, *tmp_watch;\r\nchar *path, *token;\r\nint err, rc;\r\nLIST_HEAD(staging_q);\r\npath = u->u.buffer + sizeof(u->u.msg);\r\ntoken = memchr(path, 0, u->u.msg.len);\r\nif (token == NULL) {\r\nrc = -EILSEQ;\r\ngoto out;\r\n}\r\ntoken++;\r\nif (memchr(token, 0, u->u.msg.len - (token - path)) == NULL) {\r\nrc = -EILSEQ;\r\ngoto out;\r\n}\r\nif (msg_type == XS_WATCH) {\r\nwatch = alloc_watch_adapter(path, token);\r\nif (watch == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nwatch->watch.callback = watch_fired;\r\nwatch->dev_data = u;\r\nerr = register_xenbus_watch(&watch->watch);\r\nif (err) {\r\nfree_watch_adapter(watch);\r\nrc = err;\r\ngoto out;\r\n}\r\nlist_add(&watch->list, &u->watches);\r\n} else {\r\nlist_for_each_entry_safe(watch, tmp_watch, &u->watches, list) {\r\nif (!strcmp(watch->token, token) &&\r\n!strcmp(watch->watch.node, path)) {\r\nunregister_xenbus_watch(&watch->watch);\r\nlist_del(&watch->list);\r\nfree_watch_adapter(watch);\r\nbreak;\r\n}\r\n}\r\n}\r\n{\r\nstruct {\r\nstruct xsd_sockmsg hdr;\r\nchar body[3];\r\n} __packed reply = {\r\n{\r\n.type = msg_type,\r\n.len = sizeof(reply.body)\r\n},\r\n"OK"\r\n};\r\nmutex_lock(&u->reply_mutex);\r\nrc = queue_reply(&u->read_buffers, &reply, sizeof(reply));\r\nwake_up(&u->read_waitq);\r\nmutex_unlock(&u->reply_mutex);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic ssize_t xenbus_file_write(struct file *filp,\r\nconst char __user *ubuf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct xenbus_file_priv *u = filp->private_data;\r\nuint32_t msg_type;\r\nint rc = len;\r\nint ret;\r\nLIST_HEAD(staging_q);\r\nmutex_lock(&u->msgbuffer_mutex);\r\nif (len == 0)\r\ngoto out;\r\nif ((len + u->len) > sizeof(u->u.buffer)) {\r\nu->len = 0;\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nret = copy_from_user(u->u.buffer + u->len, ubuf, len);\r\nif (ret != 0) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nlen -= ret;\r\nrc = len;\r\nu->len += len;\r\nif (u->len < sizeof(u->u.msg))\r\ngoto out;\r\nif ((sizeof(u->u.msg) + u->u.msg.len) > sizeof(u->u.buffer)) {\r\nrc = -E2BIG;\r\nu->len = 0;\r\ngoto out;\r\n}\r\nif (u->len < (sizeof(u->u.msg) + u->u.msg.len))\r\ngoto out;\r\nmsg_type = u->u.msg.type;\r\nswitch (msg_type) {\r\ncase XS_WATCH:\r\ncase XS_UNWATCH:\r\nret = xenbus_write_watch(msg_type, u);\r\nbreak;\r\ndefault:\r\nret = xenbus_write_transaction(msg_type, u);\r\nbreak;\r\n}\r\nif (ret != 0)\r\nrc = ret;\r\nu->len = 0;\r\nout:\r\nmutex_unlock(&u->msgbuffer_mutex);\r\nreturn rc;\r\n}\r\nstatic int xenbus_file_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct xenbus_file_priv *u;\r\nif (xen_store_evtchn == 0)\r\nreturn -ENOENT;\r\nnonseekable_open(inode, filp);\r\nu = kzalloc(sizeof(*u), GFP_KERNEL);\r\nif (u == NULL)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&u->transactions);\r\nINIT_LIST_HEAD(&u->watches);\r\nINIT_LIST_HEAD(&u->read_buffers);\r\ninit_waitqueue_head(&u->read_waitq);\r\nmutex_init(&u->reply_mutex);\r\nmutex_init(&u->msgbuffer_mutex);\r\nfilp->private_data = u;\r\nreturn 0;\r\n}\r\nstatic int xenbus_file_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct xenbus_file_priv *u = filp->private_data;\r\nstruct xenbus_transaction_holder *trans, *tmp;\r\nstruct watch_adapter *watch, *tmp_watch;\r\nstruct read_buffer *rb, *tmp_rb;\r\nlist_for_each_entry_safe(trans, tmp, &u->transactions, list) {\r\nxenbus_transaction_end(trans->handle, 1);\r\nlist_del(&trans->list);\r\nkfree(trans);\r\n}\r\nlist_for_each_entry_safe(watch, tmp_watch, &u->watches, list) {\r\nunregister_xenbus_watch(&watch->watch);\r\nlist_del(&watch->list);\r\nfree_watch_adapter(watch);\r\n}\r\nlist_for_each_entry_safe(rb, tmp_rb, &u->read_buffers, list) {\r\nlist_del(&rb->list);\r\nkfree(rb);\r\n}\r\nkfree(u);\r\nreturn 0;\r\n}\r\nstatic unsigned int xenbus_file_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct xenbus_file_priv *u = file->private_data;\r\npoll_wait(file, &u->read_waitq, wait);\r\nif (!list_empty(&u->read_buffers))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int __init xenbus_init(void)\r\n{\r\nint err;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nerr = misc_register(&xenbus_dev);\r\nif (err)\r\nprintk(KERN_ERR "Could not register xenbus frontend device\n");\r\nreturn err;\r\n}\r\nstatic void __exit xenbus_exit(void)\r\n{\r\nmisc_deregister(&xenbus_dev);\r\n}
