static int mb86a20s_i2c_writereg(struct mb86a20s_state *state,\r\nu8 i2c_addr, int reg, int data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2\r\n};\r\nint rc;\r\nrc = i2c_transfer(state->i2c, &msg, 1);\r\nif (rc != 1) {\r\nprintk("%s: writereg error (rc == %i, reg == 0x%02x,"\r\n" data == 0x%02x)\n", __func__, rc, reg, data);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_i2c_writeregdata(struct mb86a20s_state *state,\r\nu8 i2c_addr, struct regdata *rd, int size)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < size; i++) {\r\nrc = mb86a20s_i2c_writereg(state, i2c_addr, rd[i].reg,\r\nrd[i].data);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_i2c_readreg(struct mb86a20s_state *state,\r\nu8 i2c_addr, u8 reg)\r\n{\r\nu8 val;\r\nint rc;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &val, .len = 1 }\r\n};\r\nrc = i2c_transfer(state->i2c, msg, 2);\r\nif (rc != 2) {\r\nrc("%s: reg=0x%x (error=%d)\n", __func__, reg, rc);\r\nreturn rc;\r\n}\r\nreturn val;\r\n}\r\nstatic int mb86a20s_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc;\r\nu8 regD5 = 1;\r\ndprintk("\n");\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrc = mb86a20s_writeregdata(state, mb86a20s_init);\r\nif (rc < 0)\r\ngoto err;\r\nif (!state->config->is_serial) {\r\nregD5 &= ~1;\r\nrc = mb86a20s_writereg(state, 0x50, 0xd5);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x51, regD5);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nerr:\r\nif (rc < 0) {\r\nstate->need_init = true;\r\nprintk(KERN_INFO "mb86a20s: Init failed. Will try again later\n");\r\n} else {\r\nstate->need_init = false;\r\ndprintk("Initialization succeeded.\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nunsigned rf_max, rf_min, rf;\r\nu8 val;\r\ndprintk("\n");\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrf_max = 0xfff;\r\nrf_min = 0;\r\ndo {\r\nrf = (rf_max + rf_min) / 2;\r\nmb86a20s_writereg(state, 0x04, 0x1f);\r\nmb86a20s_writereg(state, 0x05, rf >> 8);\r\nmb86a20s_writereg(state, 0x04, 0x20);\r\nmb86a20s_writereg(state, 0x04, rf);\r\nval = mb86a20s_readreg(state, 0x02);\r\nif (val & 0x08)\r\nrf_min = (rf_max + rf_min) / 2;\r\nelse\r\nrf_max = (rf_max + rf_min) / 2;\r\nif (rf_max - rf_min < 4) {\r\n*strength = (((rf_max + rf_min) / 2) * 65535) / 4095;\r\nbreak;\r\n}\r\n} while (1);\r\ndprintk("signal strength = %d\n", *strength);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nu8 val;\r\ndprintk("\n");\r\n*status = 0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nval = mb86a20s_readreg(state, 0x0a) & 0xf;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (val >= 2)\r\n*status |= FE_HAS_SIGNAL;\r\nif (val >= 4)\r\n*status |= FE_HAS_CARRIER;\r\nif (val >= 5)\r\n*status |= FE_HAS_VITERBI;\r\nif (val >= 7)\r\n*status |= FE_HAS_SYNC;\r\nif (val >= 8)\r\n*status |= FE_HAS_LOCK;\r\ndprintk("val = %d, status = 0x%02x\n", val, *status);\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc;\r\n#if 0\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\n#endif\r\ndprintk("\n");\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\ndprintk("Calling tuner set parameters\n");\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (state->need_init)\r\nmb86a20s_initfe(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrc = mb86a20s_writeregdata(state, mb86a20s_reset_reception);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_get_modulation(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x86,\r\n[1] = 0x8a,\r\n[2] = 0x8e,\r\n};\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\nswitch ((rc & 0x70) >> 4) {\r\ncase 0:\r\nreturn DQPSK;\r\ncase 1:\r\nreturn QPSK;\r\ncase 2:\r\nreturn QAM_16;\r\ncase 3:\r\nreturn QAM_64;\r\ndefault:\r\nreturn QAM_AUTO;\r\n}\r\n}\r\nstatic int mb86a20s_get_fec(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x87,\r\n[1] = 0x8b,\r\n[2] = 0x8f,\r\n};\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\nswitch (rc) {\r\ncase 0:\r\nreturn FEC_1_2;\r\ncase 1:\r\nreturn FEC_2_3;\r\ncase 2:\r\nreturn FEC_3_4;\r\ncase 3:\r\nreturn FEC_5_6;\r\ncase 4:\r\nreturn FEC_7_8;\r\ndefault:\r\nreturn FEC_AUTO;\r\n}\r\n}\r\nstatic int mb86a20s_get_interleaving(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x88,\r\n[1] = 0x8c,\r\n[2] = 0x90,\r\n};\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc > 3)\r\nreturn -EINVAL;\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_get_segment_count(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc, count;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x89,\r\n[1] = 0x8d,\r\n[2] = 0x91,\r\n};\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\ncount = (rc >> 4) & 0x0f;\r\nreturn count;\r\n}\r\nstatic int mb86a20s_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nint i, rc;\r\np->delivery_system = SYS_ISDBT;\r\np->bandwidth_hz = 6000000;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrc = mb86a20s_writereg(state, 0x6d, 0x85);\r\nif (rc >= 0)\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc >= 0)\r\np->isdbt_partial_reception = (rc & 0x10) ? 1 : 0;\r\np->isdbt_layer_enabled = 0;\r\nfor (i = 0; i < 3; i++) {\r\nrc = mb86a20s_get_segment_count(state, i);\r\nif (rc >= 0 && rc < 14)\r\np->layer[i].segment_count = rc;\r\nif (rc == 0x0f)\r\ncontinue;\r\np->isdbt_layer_enabled |= 1 << i;\r\nrc = mb86a20s_get_modulation(state, i);\r\nif (rc >= 0)\r\np->layer[i].modulation = rc;\r\nrc = mb86a20s_get_fec(state, i);\r\nif (rc >= 0)\r\np->layer[i].fec = rc;\r\nrc = mb86a20s_get_interleaving(state, i);\r\nif (rc >= 0)\r\np->layer[i].interleaving = rc;\r\n}\r\np->isdbt_sb_mode = 0;\r\nrc = mb86a20s_writereg(state, 0x6d, 0x84);\r\nif ((rc >= 0) && ((rc & 0x60) == 0x20)) {\r\np->isdbt_sb_mode = 1;\r\nif (!p->isdbt_sb_segment_count)\r\np->isdbt_sb_segment_count = 1;\r\n} else\r\np->isdbt_sb_segment_count = 0;\r\np->transmission_mode = TRANSMISSION_MODE_AUTO;\r\np->guard_interval = GUARD_INTERVAL_AUTO;\r\nrc = mb86a20s_readreg(state, 0x07);\r\nif (rc >= 0) {\r\nif ((rc & 0x60) == 0x20) {\r\nswitch (rc & 0x0c >> 2) {\r\ncase 0:\r\np->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\np->transmission_mode = TRANSMISSION_MODE_4K;\r\nbreak;\r\ncase 2:\r\np->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\n}\r\nif (!(rc & 0x10)) {\r\nswitch (rc & 0x3) {\r\ncase 0:\r\np->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\ncase 1:\r\np->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 2:\r\np->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_tune(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nfe_status_t *status)\r\n{\r\nint rc = 0;\r\ndprintk("\n");\r\nif (re_tune)\r\nrc = mb86a20s_set_frontend(fe);\r\nif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\r\nmb86a20s_read_status(fe, status);\r\nreturn rc;\r\n}\r\nstatic void mb86a20s_release(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\ndprintk("\n");\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *mb86a20s_attach(const struct mb86a20s_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nu8 rev;\r\nstruct mb86a20s_state *state =\r\nkzalloc(sizeof(struct mb86a20s_state), GFP_KERNEL);\r\ndprintk("\n");\r\nif (state == NULL) {\r\nrc("Unable to kzalloc\n");\r\ngoto error;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nmemcpy(&state->frontend.ops, &mb86a20s_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nrev = mb86a20s_readreg(state, 0);\r\nif (rev == 0x13) {\r\nprintk(KERN_INFO "Detected a Fujitsu mb86a20s frontend\n");\r\n} else {\r\nprintk(KERN_ERR "Frontend revision %d is unknown - aborting.\n",\r\nrev);\r\ngoto error;\r\n}\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
