int s5p_mfc_alloc_dec_temp_buffers(struct s5p_mfc_ctx *ctx)\r\n{\r\nvoid *desc_virt;\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nctx->desc_buf = vb2_dma_contig_memops.alloc(\r\ndev->alloc_ctx[MFC_BANK1_ALLOC_CTX], DESC_BUF_SIZE);\r\nif (IS_ERR_VALUE((int)ctx->desc_buf)) {\r\nctx->desc_buf = NULL;\r\nmfc_err("Allocating DESC buffer failed\n");\r\nreturn -ENOMEM;\r\n}\r\nctx->desc_phys = s5p_mfc_mem_cookie(\r\ndev->alloc_ctx[MFC_BANK1_ALLOC_CTX], ctx->desc_buf);\r\nBUG_ON(ctx->desc_phys & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\r\ndesc_virt = vb2_dma_contig_memops.vaddr(ctx->desc_buf);\r\nif (desc_virt == NULL) {\r\nvb2_dma_contig_memops.put(ctx->desc_buf);\r\nctx->desc_phys = 0;\r\nctx->desc_buf = NULL;\r\nmfc_err("Remapping DESC buffer failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(desc_virt, 0, DESC_BUF_SIZE);\r\nwmb();\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_release_dec_desc_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nif (ctx->desc_phys) {\r\nvb2_dma_contig_memops.put(ctx->desc_buf);\r\nctx->desc_phys = 0;\r\nctx->desc_buf = NULL;\r\n}\r\n}\r\nint s5p_mfc_alloc_codec_buffers(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int enc_ref_y_size = 0;\r\nunsigned int enc_ref_c_size = 0;\r\nunsigned int guard_width, guard_height;\r\nif (ctx->type == MFCINST_DECODER) {\r\nmfc_debug(2, "Luma size:%d Chroma size:%d MV size:%d\n",\r\nctx->luma_size, ctx->chroma_size, ctx->mv_size);\r\nmfc_debug(2, "Totals bufs: %d\n", ctx->total_dpb_count);\r\n} else if (ctx->type == MFCINST_ENCODER) {\r\nenc_ref_y_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_y_size = ALIGN(enc_ref_y_size, S5P_FIMV_NV12MT_SALIGN);\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_H264_ENC) {\r\nenc_ref_c_size = ALIGN(ctx->img_width,\r\nS5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN(ctx->img_height >> 1,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(enc_ref_c_size,\r\nS5P_FIMV_NV12MT_SALIGN);\r\n} else {\r\nguard_width = ALIGN(ctx->img_width + 16,\r\nS5P_FIMV_NV12MT_HALIGN);\r\nguard_height = ALIGN((ctx->img_height >> 1) + 4,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(guard_width * guard_height,\r\nS5P_FIMV_NV12MT_SALIGN);\r\n}\r\nmfc_debug(2, "recon luma size: %d chroma size: %d\n",\r\nenc_ref_y_size, enc_ref_c_size);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nswitch (ctx->codec_mode) {\r\ncase S5P_FIMV_CODEC_H264_DEC:\r\nctx->bank1_size =\r\nALIGN(S5P_FIMV_DEC_NB_IP_SIZE +\r\nS5P_FIMV_DEC_VERT_NB_MV_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2_size = ctx->total_dpb_count * ctx->mv_size;\r\nbreak;\r\ncase S5P_FIMV_CODEC_MPEG4_DEC:\r\nctx->bank1_size =\r\nALIGN(S5P_FIMV_DEC_NB_DCAC_SIZE +\r\nS5P_FIMV_DEC_UPNB_MV_SIZE +\r\nS5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\r\nS5P_FIMV_DEC_STX_PARSER_SIZE +\r\nS5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2_size = 0;\r\nbreak;\r\ncase S5P_FIMV_CODEC_VC1RCV_DEC:\r\ncase S5P_FIMV_CODEC_VC1_DEC:\r\nctx->bank1_size =\r\nALIGN(S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE +\r\nS5P_FIMV_DEC_UPNB_MV_SIZE +\r\nS5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\r\nS5P_FIMV_DEC_NB_DCAC_SIZE +\r\n3 * S5P_FIMV_DEC_VC1_BITPLANE_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2_size = 0;\r\nbreak;\r\ncase S5P_FIMV_CODEC_MPEG2_DEC:\r\nctx->bank1_size = 0;\r\nctx->bank2_size = 0;\r\nbreak;\r\ncase S5P_FIMV_CODEC_H263_DEC:\r\nctx->bank1_size =\r\nALIGN(S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE +\r\nS5P_FIMV_DEC_UPNB_MV_SIZE +\r\nS5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE +\r\nS5P_FIMV_DEC_NB_DCAC_SIZE,\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->bank2_size = 0;\r\nbreak;\r\ncase S5P_FIMV_CODEC_H264_ENC:\r\nctx->bank1_size = (enc_ref_y_size * 2) +\r\nS5P_FIMV_ENC_UPMV_SIZE +\r\nS5P_FIMV_ENC_COLFLG_SIZE +\r\nS5P_FIMV_ENC_INTRAMD_SIZE +\r\nS5P_FIMV_ENC_NBORINFO_SIZE;\r\nctx->bank2_size = (enc_ref_y_size * 2) +\r\n(enc_ref_c_size * 4) +\r\nS5P_FIMV_ENC_INTRAPRED_SIZE;\r\nbreak;\r\ncase S5P_FIMV_CODEC_MPEG4_ENC:\r\nctx->bank1_size = (enc_ref_y_size * 2) +\r\nS5P_FIMV_ENC_UPMV_SIZE +\r\nS5P_FIMV_ENC_COLFLG_SIZE +\r\nS5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nctx->bank2_size = (enc_ref_y_size * 2) +\r\n(enc_ref_c_size * 4);\r\nbreak;\r\ncase S5P_FIMV_CODEC_H263_ENC:\r\nctx->bank1_size = (enc_ref_y_size * 2) +\r\nS5P_FIMV_ENC_UPMV_SIZE +\r\nS5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nctx->bank2_size = (enc_ref_y_size * 2) +\r\n(enc_ref_c_size * 4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ctx->bank1_size > 0) {\r\nctx->bank1_buf = vb2_dma_contig_memops.alloc(\r\ndev->alloc_ctx[MFC_BANK1_ALLOC_CTX], ctx->bank1_size);\r\nif (IS_ERR(ctx->bank1_buf)) {\r\nctx->bank1_buf = NULL;\r\nprintk(KERN_ERR\r\n"Buf alloc for decoding failed (port A)\n");\r\nreturn -ENOMEM;\r\n}\r\nctx->bank1_phys = s5p_mfc_mem_cookie(\r\ndev->alloc_ctx[MFC_BANK1_ALLOC_CTX], ctx->bank1_buf);\r\nBUG_ON(ctx->bank1_phys & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\r\n}\r\nif (ctx->bank2_size > 0) {\r\nctx->bank2_buf = vb2_dma_contig_memops.alloc(\r\ndev->alloc_ctx[MFC_BANK2_ALLOC_CTX], ctx->bank2_size);\r\nif (IS_ERR(ctx->bank2_buf)) {\r\nctx->bank2_buf = NULL;\r\nmfc_err("Buf alloc for decoding failed (port B)\n");\r\nreturn -ENOMEM;\r\n}\r\nctx->bank2_phys = s5p_mfc_mem_cookie(\r\ndev->alloc_ctx[MFC_BANK2_ALLOC_CTX], ctx->bank2_buf);\r\nBUG_ON(ctx->bank2_phys & ((1 << MFC_BANK2_ALIGN_ORDER) - 1));\r\n}\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_release_codec_buffers(struct s5p_mfc_ctx *ctx)\r\n{\r\nif (ctx->bank1_buf) {\r\nvb2_dma_contig_memops.put(ctx->bank1_buf);\r\nctx->bank1_buf = NULL;\r\nctx->bank1_phys = 0;\r\nctx->bank1_size = 0;\r\n}\r\nif (ctx->bank2_buf) {\r\nvb2_dma_contig_memops.put(ctx->bank2_buf);\r\nctx->bank2_buf = NULL;\r\nctx->bank2_phys = 0;\r\nctx->bank2_size = 0;\r\n}\r\n}\r\nint s5p_mfc_alloc_instance_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nvoid *context_virt;\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_H264_DEC ||\r\nctx->codec_mode == S5P_FIMV_CODEC_H264_ENC)\r\nctx->ctx_size = MFC_H264_CTX_BUF_SIZE;\r\nelse\r\nctx->ctx_size = MFC_CTX_BUF_SIZE;\r\nctx->ctx_buf = vb2_dma_contig_memops.alloc(\r\ndev->alloc_ctx[MFC_BANK1_ALLOC_CTX], ctx->ctx_size);\r\nif (IS_ERR(ctx->ctx_buf)) {\r\nmfc_err("Allocating context buffer failed\n");\r\nctx->ctx_phys = 0;\r\nctx->ctx_buf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nctx->ctx_phys = s5p_mfc_mem_cookie(\r\ndev->alloc_ctx[MFC_BANK1_ALLOC_CTX], ctx->ctx_buf);\r\nBUG_ON(ctx->ctx_phys & ((1 << MFC_BANK1_ALIGN_ORDER) - 1));\r\nctx->ctx_ofs = OFFSETA(ctx->ctx_phys);\r\ncontext_virt = vb2_dma_contig_memops.vaddr(ctx->ctx_buf);\r\nif (context_virt == NULL) {\r\nmfc_err("Remapping instance buffer failed\n");\r\nvb2_dma_contig_memops.put(ctx->ctx_buf);\r\nctx->ctx_phys = 0;\r\nctx->ctx_buf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nmemset(context_virt, 0, ctx->ctx_size);\r\nwmb();\r\nif (s5p_mfc_init_shm(ctx) < 0) {\r\nvb2_dma_contig_memops.put(ctx->ctx_buf);\r\nctx->ctx_phys = 0;\r\nctx->ctx_buf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_release_instance_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nif (ctx->ctx_buf) {\r\nvb2_dma_contig_memops.put(ctx->ctx_buf);\r\nctx->ctx_phys = 0;\r\nctx->ctx_buf = NULL;\r\n}\r\nif (ctx->shm_alloc) {\r\nvb2_dma_contig_memops.put(ctx->shm_alloc);\r\nctx->shm_alloc = NULL;\r\nctx->shm = NULL;\r\n}\r\n}\r\nvoid s5p_mfc_set_dec_desc_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, OFFSETA(ctx->desc_phys), S5P_FIMV_SI_CH0_DESC_ADR);\r\nmfc_write(dev, DESC_BUF_SIZE, S5P_FIMV_SI_CH0_DESC_SIZE);\r\n}\r\nstatic void s5p_mfc_set_shared_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, ctx->shm_ofs, S5P_FIMV_SI_CH0_HOST_WR_ADR);\r\n}\r\nint s5p_mfc_set_dec_stream_buffer(struct s5p_mfc_ctx *ctx, int buf_addr,\r\nunsigned int start_num_byte, unsigned int buf_size)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, OFFSETA(buf_addr), S5P_FIMV_SI_CH0_SB_ST_ADR);\r\nmfc_write(dev, ctx->dec_src_buf_size, S5P_FIMV_SI_CH0_CPB_SIZE);\r\nmfc_write(dev, buf_size, S5P_FIMV_SI_CH0_SB_FRM_SIZE);\r\ns5p_mfc_write_shm(ctx, start_num_byte, START_BYTE_NUM);\r\nreturn 0;\r\n}\r\nint s5p_mfc_set_dec_frame_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nunsigned int frame_size, i;\r\nunsigned int frame_size_ch, frame_size_mv;\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int dpb;\r\nsize_t buf_addr1, buf_addr2;\r\nint buf_size1, buf_size2;\r\nbuf_addr1 = ctx->bank1_phys;\r\nbuf_size1 = ctx->bank1_size;\r\nbuf_addr2 = ctx->bank2_phys;\r\nbuf_size2 = ctx->bank2_size;\r\ndpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) &\r\n~S5P_FIMV_DPB_COUNT_MASK;\r\nmfc_write(dev, ctx->total_dpb_count | dpb,\r\nS5P_FIMV_SI_CH0_DPB_CONF_CTRL);\r\ns5p_mfc_set_shared_buffer(ctx);\r\nswitch (ctx->codec_mode) {\r\ncase S5P_FIMV_CODEC_H264_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_VERT_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VERT_NB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VERT_NB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H264_NB_IP_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_IP_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_IP_SIZE;\r\nbreak;\r\ncase S5P_FIMV_CODEC_MPEG4_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_NB_DCAC_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_UP_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_SA_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_SP_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_STX_PARSER_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_STX_PARSER_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_OT_LINE_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbreak;\r\ncase S5P_FIMV_CODEC_H263_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_OT_LINE_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_UP_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_SA_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_NB_DCAC_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbreak;\r\ncase S5P_FIMV_CODEC_VC1_DEC:\r\ncase S5P_FIMV_CODEC_VC1RCV_DEC:\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_NB_DCAC_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_NB_DCAC_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_OT_LINE_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_OVERLAP_TRANSFORM_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_UP_NB_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_UPNB_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_SA_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_SUB_ANCHOR_MV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE3_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE2_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_VC1_BITPLANE1_ADR);\r\nbuf_addr1 += S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbuf_size1 -= S5P_FIMV_DEC_VC1_BITPLANE_SIZE;\r\nbreak;\r\ncase S5P_FIMV_CODEC_MPEG2_DEC:\r\nbreak;\r\ndefault:\r\nmfc_err("Unknown codec for decoding (%x)\n",\r\nctx->codec_mode);\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nframe_size = ctx->luma_size;\r\nframe_size_ch = ctx->chroma_size;\r\nframe_size_mv = ctx->mv_size;\r\nmfc_debug(2, "Frm size: %d ch: %d mv: %d\n", frame_size, frame_size_ch,\r\nframe_size_mv);\r\nfor (i = 0; i < ctx->total_dpb_count; i++) {\r\nmfc_debug(2, "Luma %d: %x\n", i,\r\nctx->dst_bufs[i].cookie.raw.luma);\r\nmfc_write(dev, OFFSETB(ctx->dst_bufs[i].cookie.raw.luma),\r\nS5P_FIMV_DEC_LUMA_ADR + i * 4);\r\nmfc_debug(2, "\tChroma %d: %x\n", i,\r\nctx->dst_bufs[i].cookie.raw.chroma);\r\nmfc_write(dev, OFFSETA(ctx->dst_bufs[i].cookie.raw.chroma),\r\nS5P_FIMV_DEC_CHROMA_ADR + i * 4);\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_H264_DEC) {\r\nmfc_debug(2, "\tBuf2: %x, size: %d\n",\r\nbuf_addr2, buf_size2);\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_H264_MV_ADR + i * 4);\r\nbuf_addr2 += frame_size_mv;\r\nbuf_size2 -= frame_size_mv;\r\n}\r\n}\r\nmfc_debug(2, "Buf1: %u, buf_size1: %d\n", buf_addr1, buf_size1);\r\nmfc_debug(2, "Buf 1/2 size after: %d/%d (frames %d)\n",\r\nbuf_size1, buf_size2, ctx->total_dpb_count);\r\nif (buf_size1 < 0 || buf_size2 < 0) {\r\nmfc_debug(2, "Not enough memory has been allocated\n");\r\nreturn -ENOMEM;\r\n}\r\ns5p_mfc_write_shm(ctx, frame_size, ALLOC_LUMA_DPB_SIZE);\r\ns5p_mfc_write_shm(ctx, frame_size_ch, ALLOC_CHROMA_DPB_SIZE);\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_H264_DEC)\r\ns5p_mfc_write_shm(ctx, frame_size_mv, ALLOC_MV_SIZE);\r\nmfc_write(dev, ((S5P_FIMV_CH_INIT_BUFS & S5P_FIMV_CH_MASK)\r\n<< S5P_FIMV_CH_SHIFT) | (ctx->inst_no),\r\nS5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nint s5p_mfc_set_enc_stream_buffer(struct s5p_mfc_ctx *ctx,\r\nunsigned long addr, unsigned int size)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, OFFSETA(addr), S5P_FIMV_ENC_SI_CH0_SB_ADR);\r\nmfc_write(dev, size, S5P_FIMV_ENC_SI_CH0_SB_SIZE);\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_set_enc_frame_buffer(struct s5p_mfc_ctx *ctx,\r\nunsigned long y_addr, unsigned long c_addr)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, OFFSETB(y_addr), S5P_FIMV_ENC_SI_CH0_CUR_Y_ADR);\r\nmfc_write(dev, OFFSETB(c_addr), S5P_FIMV_ENC_SI_CH0_CUR_C_ADR);\r\n}\r\nvoid s5p_mfc_get_enc_frame_buffer(struct s5p_mfc_ctx *ctx,\r\nunsigned long *y_addr, unsigned long *c_addr)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\n*y_addr = dev->bank2 + (mfc_read(dev, S5P_FIMV_ENCODED_Y_ADDR)\r\n<< MFC_OFFSET_SHIFT);\r\n*c_addr = dev->bank2 + (mfc_read(dev, S5P_FIMV_ENCODED_C_ADDR)\r\n<< MFC_OFFSET_SHIFT);\r\n}\r\nint s5p_mfc_set_enc_ref_buffer(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nsize_t buf_addr1, buf_addr2;\r\nsize_t buf_size1, buf_size2;\r\nunsigned int enc_ref_y_size, enc_ref_c_size;\r\nunsigned int guard_width, guard_height;\r\nint i;\r\nbuf_addr1 = ctx->bank1_phys;\r\nbuf_size1 = ctx->bank1_size;\r\nbuf_addr2 = ctx->bank2_phys;\r\nbuf_size2 = ctx->bank2_size;\r\nenc_ref_y_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN(ctx->img_height, S5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_y_size = ALIGN(enc_ref_y_size, S5P_FIMV_NV12MT_SALIGN);\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_H264_ENC) {\r\nenc_ref_c_size = ALIGN(ctx->img_width, S5P_FIMV_NV12MT_HALIGN)\r\n* ALIGN((ctx->img_height >> 1), S5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(enc_ref_c_size, S5P_FIMV_NV12MT_SALIGN);\r\n} else {\r\nguard_width = ALIGN(ctx->img_width + 16,\r\nS5P_FIMV_NV12MT_HALIGN);\r\nguard_height = ALIGN((ctx->img_height >> 1) + 4,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nenc_ref_c_size = ALIGN(guard_width * guard_height,\r\nS5P_FIMV_NV12MT_SALIGN);\r\n}\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n", buf_size1, buf_size2);\r\nswitch (ctx->codec_mode) {\r\ncase S5P_FIMV_CODEC_H264_ENC:\r\nfor (i = 0; i < 2; i++) {\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\r\nbuf_addr1 += enc_ref_y_size;\r\nbuf_size1 -= enc_ref_y_size;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_y_size;\r\nbuf_size2 -= enc_ref_y_size;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_c_size;\r\nbuf_size2 -= enc_ref_c_size;\r\n}\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H264_UP_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_COZERO_FLAG_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_COLFLG_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_COLFLG_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_UP_INTRA_MD_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_INTRAMD_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_INTRAMD_SIZE;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_H264_UP_INTRA_PRED_ADR);\r\nbuf_addr2 += S5P_FIMV_ENC_INTRAPRED_SIZE;\r\nbuf_size2 -= S5P_FIMV_ENC_INTRAPRED_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_H264_NBOR_INFO_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_NBORINFO_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_NBORINFO_SIZE;\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n",\r\nbuf_size1, buf_size2);\r\nbreak;\r\ncase S5P_FIMV_CODEC_MPEG4_ENC:\r\nfor (i = 0; i < 2; i++) {\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\r\nbuf_addr1 += enc_ref_y_size;\r\nbuf_size1 -= enc_ref_y_size;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_y_size;\r\nbuf_size2 -= enc_ref_y_size;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_c_size;\r\nbuf_size2 -= enc_ref_c_size;\r\n}\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_MPEG4_UP_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_MPEG4_COZERO_FLAG_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_COLFLG_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_COLFLG_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_MPEG4_ACDC_COEF_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n",\r\nbuf_size1, buf_size2);\r\nbreak;\r\ncase S5P_FIMV_CODEC_H263_ENC:\r\nfor (i = 0; i < 2; i++) {\r\nmfc_write(dev, OFFSETA(buf_addr1),\r\nS5P_FIMV_ENC_REF0_LUMA_ADR + (4 * i));\r\nbuf_addr1 += enc_ref_y_size;\r\nbuf_size1 -= enc_ref_y_size;\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF2_LUMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_y_size;\r\nbuf_size2 -= enc_ref_y_size;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nmfc_write(dev, OFFSETB(buf_addr2),\r\nS5P_FIMV_ENC_REF0_CHROMA_ADR + (4 * i));\r\nbuf_addr2 += enc_ref_c_size;\r\nbuf_size2 -= enc_ref_c_size;\r\n}\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_UP_MV_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_UPMV_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_UPMV_SIZE;\r\nmfc_write(dev, OFFSETA(buf_addr1), S5P_FIMV_H263_ACDC_COEF_ADR);\r\nbuf_addr1 += S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nbuf_size1 -= S5P_FIMV_ENC_ACDCCOEF_SIZE;\r\nmfc_debug(2, "buf_size1: %d, buf_size2: %d\n",\r\nbuf_size1, buf_size2);\r\nbreak;\r\ndefault:\r\nmfc_err("Unknown codec set for encoding: %d\n",\r\nctx->codec_mode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nunsigned int reg;\r\nunsigned int shm;\r\nmfc_write(dev, ctx->img_width, S5P_FIMV_ENC_HSIZE_PX);\r\nmfc_write(dev, ctx->img_height, S5P_FIMV_ENC_VSIZE_PX);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg |= (1 << 18);\r\nreg &= ~(0xFFFF);\r\nreg |= p->gop_size;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nmfc_write(dev, 0, S5P_FIMV_ENC_B_RECON_WRITE_ON);\r\nmfc_write(dev, p->slice_mode, S5P_FIMV_ENC_MSLICE_CTRL);\r\nif (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB) {\r\nmfc_write(dev, p->slice_mb, S5P_FIMV_ENC_MSLICE_MB);\r\n} else if (p->slice_mode == V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES) {\r\nmfc_write(dev, p->slice_bit, S5P_FIMV_ENC_MSLICE_BIT);\r\n} else {\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MSLICE_MB);\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MSLICE_BIT);\r\n}\r\nmfc_write(dev, p->intra_refresh_mb, S5P_FIMV_ENC_CIR_CTRL);\r\nif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M)\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MAP_FOR_CUR);\r\nelse if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT)\r\nmfc_write(dev, 3, S5P_FIMV_ENC_MAP_FOR_CUR);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PADDING_CTRL);\r\nif (p->pad) {\r\nreg |= (1 << 31);\r\nreg &= ~(0xFF << 16);\r\nreg |= (p->pad_cr << 16);\r\nreg &= ~(0xFF << 8);\r\nreg |= (p->pad_cb << 8);\r\nreg &= ~(0xFF);\r\nreg |= (p->pad_luma);\r\n} else {\r\nreg = 0;\r\n}\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PADDING_CTRL);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x1 << 9);\r\nreg |= (p->rc_frame << 9);\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nif (p->rc_frame)\r\nmfc_write(dev, p->rc_bitrate,\r\nS5P_FIMV_ENC_RC_BIT_RATE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_BIT_RATE);\r\nif (p->rc_frame)\r\nmfc_write(dev, p->rc_reaction_coeff, S5P_FIMV_ENC_RC_RPARA);\r\nshm = s5p_mfc_read_shm(ctx, EXT_ENC_CONTROL);\r\nshm &= ~(0x1 << 3);\r\nshm |= (p->seq_hdr_mode << 3);\r\nshm &= ~(0x3 << 1);\r\nshm |= (p->frame_skip_mode << 1);\r\ns5p_mfc_write_shm(ctx, shm, EXT_ENC_CONTROL);\r\ns5p_mfc_write_shm(ctx, p->fixed_target_bit, RC_CONTROL_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params_h264(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nstruct s5p_mfc_h264_enc_params *p_264 = &p->codec.h264;\r\nunsigned int reg;\r\nunsigned int shm;\r\ns5p_mfc_set_enc_params(ctx);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg &= ~(0x3 << 16);\r\nreg |= (p->num_b_frame << 16);\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PROFILE);\r\nreg &= ~(0xFF << 8);\r\nreg |= (p_264->level << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_264->profile;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PROFILE);\r\nmfc_write(dev, p->interlace, S5P_FIMV_ENC_PIC_STRUCT);\r\nif (p->interlace)\r\nmfc_write(dev, ctx->img_height >> 1, S5P_FIMV_ENC_VSIZE_PX);\r\nmfc_write(dev, p_264->loop_filter_mode, S5P_FIMV_ENC_LF_CTRL);\r\nif (p_264->loop_filter_alpha < 0) {\r\nreg = 0x10;\r\nreg |= (0xFF - p_264->loop_filter_alpha) + 1;\r\n} else {\r\nreg = 0x00;\r\nreg |= (p_264->loop_filter_alpha & 0xF);\r\n}\r\nmfc_write(dev, reg, S5P_FIMV_ENC_ALPHA_OFF);\r\nif (p_264->loop_filter_beta < 0) {\r\nreg = 0x10;\r\nreg |= (0xFF - p_264->loop_filter_beta) + 1;\r\n} else {\r\nreg = 0x00;\r\nreg |= (p_264->loop_filter_beta & 0xF);\r\n}\r\nmfc_write(dev, reg, S5P_FIMV_ENC_BETA_OFF);\r\nif (p_264->entropy_mode == V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC)\r\nmfc_write(dev, 1, S5P_FIMV_ENC_H264_ENTROPY_MODE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_H264_ENTROPY_MODE);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_H264_NUM_OF_REF);\r\nreg &= ~(0x3 << 5);\r\nreg |= (p_264->num_ref_pic_4p << 5);\r\nreg &= ~(0x1F);\r\nreg |= p_264->max_ref_pic;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_H264_NUM_OF_REF);\r\nmfc_write(dev, p_264->_8x8_transform, S5P_FIMV_ENC_H264_TRANS_FLAG);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x1 << 8);\r\nreg |= (p_264->rc_mb << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_264->rc_frame_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nif (p->rc_frame && p->rc_framerate_denom)\r\nmfc_write(dev, p->rc_framerate_num * 1000\r\n/ p->rc_framerate_denom, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\r\nreg &= ~(0x3F << 8);\r\nreg |= (p_264->rc_max_qp << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_264->rc_min_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\r\nif (p_264->rc_mb) {\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_MB_CTRL);\r\nreg &= ~(0x1 << 3);\r\nreg |= (p_264->rc_mb_dark << 3);\r\nreg &= ~(0x1 << 2);\r\nreg |= (p_264->rc_mb_smooth << 2);\r\nreg &= ~(0x1 << 1);\r\nreg |= (p_264->rc_mb_static << 1);\r\nreg &= ~(0x1);\r\nreg |= p_264->rc_mb_activity;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_MB_CTRL);\r\n}\r\nif (!p->rc_frame &&\r\n!p_264->rc_mb) {\r\nshm = s5p_mfc_read_shm(ctx, P_B_FRAME_QP);\r\nshm &= ~(0xFFF);\r\nshm |= ((p_264->rc_b_frame_qp & 0x3F) << 6);\r\nshm |= (p_264->rc_p_frame_qp & 0x3F);\r\ns5p_mfc_write_shm(ctx, shm, P_B_FRAME_QP);\r\n}\r\nshm = s5p_mfc_read_shm(ctx, EXT_ENC_CONTROL);\r\nshm &= ~(0x1 << 15);\r\nshm |= (p_264->vui_sar << 1);\r\ns5p_mfc_write_shm(ctx, shm, EXT_ENC_CONTROL);\r\nif (p_264->vui_sar) {\r\nshm = s5p_mfc_read_shm(ctx, SAMPLE_ASPECT_RATIO_IDC);\r\nshm &= ~(0xFF);\r\nshm |= p_264->vui_sar_idc;\r\ns5p_mfc_write_shm(ctx, shm, SAMPLE_ASPECT_RATIO_IDC);\r\nif (p_264->vui_sar_idc == 0xFF) {\r\nshm = s5p_mfc_read_shm(ctx, EXTENDED_SAR);\r\nshm &= ~(0xFFFFFFFF);\r\nshm |= p_264->vui_ext_sar_width << 16;\r\nshm |= p_264->vui_ext_sar_height;\r\ns5p_mfc_write_shm(ctx, shm, EXTENDED_SAR);\r\n}\r\n}\r\nshm = s5p_mfc_read_shm(ctx, H264_I_PERIOD);\r\nshm &= ~(0x1 << 16);\r\nshm |= (p_264->open_gop << 16);\r\nif (p_264->open_gop) {\r\nshm &= ~(0xFFFF);\r\nshm |= p_264->open_gop_size;\r\n}\r\ns5p_mfc_write_shm(ctx, shm, H264_I_PERIOD);\r\nshm = s5p_mfc_read_shm(ctx, EXT_ENC_CONTROL);\r\nif (p->frame_skip_mode ==\r\nV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\r\nshm &= ~(0xFFFF << 16);\r\nshm |= (p_264->cpb_size << 16);\r\n}\r\ns5p_mfc_write_shm(ctx, shm, EXT_ENC_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params_mpeg4(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nstruct s5p_mfc_mpeg4_enc_params *p_mpeg4 = &p->codec.mpeg4;\r\nunsigned int reg;\r\nunsigned int shm;\r\nunsigned int framerate;\r\ns5p_mfc_set_enc_params(ctx);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg &= ~(0x3 << 16);\r\nreg |= (p->num_b_frame << 16);\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PIC_TYPE_CTRL);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_PROFILE);\r\nreg &= ~(0xFF << 8);\r\nreg |= (p_mpeg4->level << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_mpeg4->profile;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_PROFILE);\r\nmfc_write(dev, p_mpeg4->quarter_pixel, S5P_FIMV_ENC_MPEG4_QUART_PXL);\r\nif (!p->rc_frame) {\r\nshm = s5p_mfc_read_shm(ctx, P_B_FRAME_QP);\r\nshm &= ~(0xFFF);\r\nshm |= ((p_mpeg4->rc_b_frame_qp & 0x3F) << 6);\r\nshm |= (p_mpeg4->rc_p_frame_qp & 0x3F);\r\ns5p_mfc_write_shm(ctx, shm, P_B_FRAME_QP);\r\n}\r\nif (p->rc_frame) {\r\nif (p->rc_framerate_denom > 0) {\r\nframerate = p->rc_framerate_num * 1000 /\r\np->rc_framerate_denom;\r\nmfc_write(dev, framerate,\r\nS5P_FIMV_ENC_RC_FRAME_RATE);\r\nshm = s5p_mfc_read_shm(ctx, RC_VOP_TIMING);\r\nshm &= ~(0xFFFFFFFF);\r\nshm |= (1 << 31);\r\nshm |= ((p->rc_framerate_num & 0x7FFF) << 16);\r\nshm |= (p->rc_framerate_denom & 0xFFFF);\r\ns5p_mfc_write_shm(ctx, shm, RC_VOP_TIMING);\r\n}\r\n} else {\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\r\n}\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x3F);\r\nreg |= p_mpeg4->rc_frame_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\r\nreg &= ~(0x3F << 8);\r\nreg |= (p_mpeg4->rc_max_qp << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_mpeg4->rc_min_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\r\nshm = s5p_mfc_read_shm(ctx, EXT_ENC_CONTROL);\r\nif (p->frame_skip_mode ==\r\nV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\r\nshm &= ~(0xFFFF << 16);\r\nshm |= (p->vbv_size << 16);\r\n}\r\ns5p_mfc_write_shm(ctx, shm, EXT_ENC_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_set_enc_params_h263(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_enc_params *p = &ctx->enc_params;\r\nstruct s5p_mfc_mpeg4_enc_params *p_h263 = &p->codec.mpeg4;\r\nunsigned int reg;\r\nunsigned int shm;\r\ns5p_mfc_set_enc_params(ctx);\r\nif (!p->rc_frame) {\r\nshm = s5p_mfc_read_shm(ctx, P_B_FRAME_QP);\r\nshm &= ~(0xFFF);\r\nshm |= (p_h263->rc_p_frame_qp & 0x3F);\r\ns5p_mfc_write_shm(ctx, shm, P_B_FRAME_QP);\r\n}\r\nif (p->rc_frame && p->rc_framerate_denom)\r\nmfc_write(dev, p->rc_framerate_num * 1000\r\n/ p->rc_framerate_denom, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_RC_FRAME_RATE);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_CONFIG);\r\nreg &= ~(0x3F);\r\nreg |= p_h263->rc_frame_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_CONFIG);\r\nreg = mfc_read(dev, S5P_FIMV_ENC_RC_QBOUND);\r\nreg &= ~(0x3F << 8);\r\nreg |= (p_h263->rc_max_qp << 8);\r\nreg &= ~(0x3F);\r\nreg |= p_h263->rc_min_qp;\r\nmfc_write(dev, reg, S5P_FIMV_ENC_RC_QBOUND);\r\nshm = s5p_mfc_read_shm(ctx, EXT_ENC_CONTROL);\r\nif (p->frame_skip_mode ==\r\nV4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT) {\r\nshm &= ~(0xFFFF << 16);\r\nshm |= (p->vbv_size << 16);\r\n}\r\ns5p_mfc_write_shm(ctx, shm, EXT_ENC_CONTROL);\r\nreturn 0;\r\n}\r\nint s5p_mfc_init_decode(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\ns5p_mfc_set_shared_buffer(ctx);\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_MPEG4_DEC)\r\nmfc_write(dev, ctx->loop_filter_mpeg4, S5P_FIMV_ENC_LF_CTRL);\r\nelse\r\nmfc_write(dev, 0, S5P_FIMV_ENC_LF_CTRL);\r\nmfc_write(dev, ((ctx->slice_interface & S5P_FIMV_SLICE_INT_MASK) <<\r\nS5P_FIMV_SLICE_INT_SHIFT) | (ctx->display_delay_enable <<\r\nS5P_FIMV_DDELAY_ENA_SHIFT) | ((ctx->display_delay &\r\nS5P_FIMV_DDELAY_VAL_MASK) << S5P_FIMV_DDELAY_VAL_SHIFT),\r\nS5P_FIMV_SI_CH0_DPB_CONF_CTRL);\r\nmfc_write(dev,\r\n((S5P_FIMV_CH_SEQ_HEADER & S5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT)\r\n| (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_set_flush(struct s5p_mfc_ctx *ctx, int flush)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int dpb;\r\nif (flush)\r\ndpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) | (\r\nS5P_FIMV_DPB_FLUSH_MASK << S5P_FIMV_DPB_FLUSH_SHIFT);\r\nelse\r\ndpb = mfc_read(dev, S5P_FIMV_SI_CH0_DPB_CONF_CTRL) &\r\n~(S5P_FIMV_DPB_FLUSH_MASK << S5P_FIMV_DPB_FLUSH_SHIFT);\r\nmfc_write(dev, dpb, S5P_FIMV_SI_CH0_DPB_CONF_CTRL);\r\n}\r\nint s5p_mfc_decode_one_frame(struct s5p_mfc_ctx *ctx,\r\nenum s5p_mfc_decode_arg last_frame)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_write(dev, ctx->dec_dst_flag, S5P_FIMV_SI_CH0_RELEASE_BUF);\r\ns5p_mfc_set_shared_buffer(ctx);\r\ns5p_mfc_set_flush(ctx, ctx->dpb_flush_flag);\r\nswitch (last_frame) {\r\ncase MFC_DEC_FRAME:\r\nmfc_write(dev, ((S5P_FIMV_CH_FRAME_START & S5P_FIMV_CH_MASK) <<\r\nS5P_FIMV_CH_SHIFT) | (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nbreak;\r\ncase MFC_DEC_LAST_FRAME:\r\nmfc_write(dev, ((S5P_FIMV_CH_LAST_FRAME & S5P_FIMV_CH_MASK) <<\r\nS5P_FIMV_CH_SHIFT) | (ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nbreak;\r\ncase MFC_DEC_RES_CHANGE:\r\nmfc_write(dev, ((S5P_FIMV_CH_FRAME_START_REALLOC &\r\nS5P_FIMV_CH_MASK) << S5P_FIMV_CH_SHIFT) | (ctx->inst_no),\r\nS5P_FIMV_SI_CH0_INST_ID);\r\nbreak;\r\n}\r\nmfc_debug(2, "Decoding a usual frame\n");\r\nreturn 0;\r\n}\r\nint s5p_mfc_init_encode(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_H264_ENC)\r\ns5p_mfc_set_enc_params_h264(ctx);\r\nelse if (ctx->codec_mode == S5P_FIMV_CODEC_MPEG4_ENC)\r\ns5p_mfc_set_enc_params_mpeg4(ctx);\r\nelse if (ctx->codec_mode == S5P_FIMV_CODEC_H263_ENC)\r\ns5p_mfc_set_enc_params_h263(ctx);\r\nelse {\r\nmfc_err("Unknown codec for encoding (%x)\n",\r\nctx->codec_mode);\r\nreturn -EINVAL;\r\n}\r\ns5p_mfc_set_shared_buffer(ctx);\r\nmfc_write(dev, ((S5P_FIMV_CH_SEQ_HEADER << 16) & 0x70000) |\r\n(ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nint s5p_mfc_encode_one_frame(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12M)\r\nmfc_write(dev, 0, S5P_FIMV_ENC_MAP_FOR_CUR);\r\nelse if (ctx->src_fmt->fourcc == V4L2_PIX_FMT_NV12MT)\r\nmfc_write(dev, 3, S5P_FIMV_ENC_MAP_FOR_CUR);\r\ns5p_mfc_set_shared_buffer(ctx);\r\nmfc_write(dev, (S5P_FIMV_CH_FRAME_START << 16 & 0x70000) |\r\n(ctx->inst_no), S5P_FIMV_SI_CH0_INST_ID);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_get_new_ctx(struct s5p_mfc_dev *dev)\r\n{\r\nunsigned long flags;\r\nint new_ctx;\r\nint cnt;\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nnew_ctx = (dev->curr_ctx + 1) % MFC_NUM_CONTEXTS;\r\ncnt = 0;\r\nwhile (!test_bit(new_ctx, &dev->ctx_work_bits)) {\r\nnew_ctx = (new_ctx + 1) % MFC_NUM_CONTEXTS;\r\nif (++cnt > MFC_NUM_CONTEXTS) {\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\nreturn new_ctx;\r\n}\r\nstatic void s5p_mfc_run_res_change(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\ns5p_mfc_set_dec_stream_buffer(ctx, 0, 0, 0);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_decode_one_frame(ctx, MFC_DEC_RES_CHANGE);\r\n}\r\nstatic int s5p_mfc_run_dec_frame(struct s5p_mfc_ctx *ctx, int last_frame)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *temp_vb;\r\nunsigned long flags;\r\nunsigned int index;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue)) {\r\nmfc_debug(2, "No src buffers\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EAGAIN;\r\n}\r\ntemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\ntemp_vb->used = 1;\r\ns5p_mfc_set_dec_stream_buffer(ctx,\r\nvb2_dma_contig_plane_dma_addr(temp_vb->b, 0), ctx->consumed_stream,\r\ntemp_vb->b->v4l2_planes[0].bytesused);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nindex = temp_vb->b->v4l2_buf.index;\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nif (temp_vb->b->v4l2_planes[0].bytesused == 0) {\r\nlast_frame = MFC_DEC_LAST_FRAME;\r\nmfc_debug(2, "Setting ctx->state to FINISHING\n");\r\nctx->state = MFCINST_FINISHING;\r\n}\r\ns5p_mfc_decode_one_frame(ctx, last_frame);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_run_enc_frame(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *dst_mb;\r\nstruct s5p_mfc_buf *src_mb;\r\nunsigned long src_y_addr, src_c_addr, dst_addr;\r\nunsigned int dst_size;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue)) {\r\nmfc_debug(2, "no src buffers\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EAGAIN;\r\n}\r\nif (list_empty(&ctx->dst_queue)) {\r\nmfc_debug(2, "no dst buffers\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EAGAIN;\r\n}\r\nsrc_mb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\nsrc_mb->used = 1;\r\nsrc_y_addr = vb2_dma_contig_plane_dma_addr(src_mb->b, 0);\r\nsrc_c_addr = vb2_dma_contig_plane_dma_addr(src_mb->b, 1);\r\ns5p_mfc_set_enc_frame_buffer(ctx, src_y_addr, src_c_addr);\r\ndst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\r\ndst_mb->used = 1;\r\ndst_addr = vb2_dma_contig_plane_dma_addr(dst_mb->b, 0);\r\ndst_size = vb2_plane_size(dst_mb->b, 0);\r\ns5p_mfc_set_enc_stream_buffer(ctx, dst_addr, dst_size);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_encode_one_frame(ctx);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_run_init_dec(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *temp_vb;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nmfc_debug(2, "Preparing to init decoding\n");\r\ntemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\ns5p_mfc_set_dec_desc_buffer(ctx);\r\nmfc_debug(2, "Header size: %d\n", temp_vb->b->v4l2_planes[0].bytesused);\r\ns5p_mfc_set_dec_stream_buffer(ctx,\r\nvb2_dma_contig_plane_dma_addr(temp_vb->b, 0),\r\n0, temp_vb->b->v4l2_planes[0].bytesused);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_init_decode(ctx);\r\n}\r\nstatic void s5p_mfc_run_init_enc(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *dst_mb;\r\nunsigned long dst_addr;\r\nunsigned int dst_size;\r\ns5p_mfc_set_enc_ref_buffer(ctx);\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\ndst_mb = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf, list);\r\ndst_addr = vb2_dma_contig_plane_dma_addr(dst_mb->b, 0);\r\ndst_size = vb2_plane_size(dst_mb->b, 0);\r\ns5p_mfc_set_enc_stream_buffer(ctx, dst_addr, dst_size);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_init_encode(ctx);\r\n}\r\nstatic int s5p_mfc_run_init_dec_buffers(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *temp_vb;\r\nint ret;\r\nif (ctx->capture_state != QUEUE_BUFS_MMAPED) {\r\nmfc_err("It seems that not all destionation buffers were "\r\n"mmaped\nMFC requires that all destination are mmaped "\r\n"before starting processing\n");\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (list_empty(&ctx->src_queue)) {\r\nmfc_err("Header has been deallocated in the middle of"\r\n" initialization\n");\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn -EIO;\r\n}\r\ntemp_vb = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\nmfc_debug(2, "Header size: %d\n", temp_vb->b->v4l2_planes[0].bytesused);\r\ns5p_mfc_set_dec_stream_buffer(ctx,\r\nvb2_dma_contig_plane_dma_addr(temp_vb->b, 0),\r\n0, temp_vb->b->v4l2_planes[0].bytesused);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ndev->curr_ctx = ctx->num;\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_set_dec_frame_buffer(ctx);\r\nif (ret) {\r\nmfc_err("Failed to alloc frame mem\n");\r\nctx->state = MFCINST_ERROR;\r\n}\r\nreturn ret;\r\n}\r\nvoid s5p_mfc_try_run(struct s5p_mfc_dev *dev)\r\n{\r\nstruct s5p_mfc_ctx *ctx;\r\nint new_ctx;\r\nunsigned int ret = 0;\r\nif (test_bit(0, &dev->enter_suspend)) {\r\nmfc_debug(1, "Entering suspend so do not schedule any jobs\n");\r\nreturn;\r\n}\r\nif (test_and_set_bit(0, &dev->hw_lock) != 0) {\r\nmfc_debug(1, "Couldn't lock HW\n");\r\nreturn;\r\n}\r\nnew_ctx = s5p_mfc_get_new_ctx(dev);\r\nif (new_ctx < 0) {\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0) {\r\nmfc_err("Failed to unlock hardware\n");\r\nreturn;\r\n}\r\nmfc_debug(1, "No ctx is scheduled to be run\n");\r\nreturn;\r\n}\r\nctx = dev->ctx[new_ctx];\r\ns5p_mfc_clock_on();\r\nif (ctx->type == MFCINST_DECODER) {\r\ns5p_mfc_set_dec_desc_buffer(ctx);\r\nswitch (ctx->state) {\r\ncase MFCINST_FINISHING:\r\ns5p_mfc_run_dec_frame(ctx, MFC_DEC_LAST_FRAME);\r\nbreak;\r\ncase MFCINST_RUNNING:\r\nret = s5p_mfc_run_dec_frame(ctx, MFC_DEC_FRAME);\r\nbreak;\r\ncase MFCINST_INIT:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_open_inst_cmd(ctx);\r\nbreak;\r\ncase MFCINST_RETURN_INST:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_close_inst_cmd(ctx);\r\nbreak;\r\ncase MFCINST_GOT_INST:\r\ns5p_mfc_run_init_dec(ctx);\r\nbreak;\r\ncase MFCINST_HEAD_PARSED:\r\nret = s5p_mfc_run_init_dec_buffers(ctx);\r\nmfc_debug(1, "head parsed\n");\r\nbreak;\r\ncase MFCINST_RES_CHANGE_INIT:\r\ns5p_mfc_run_res_change(ctx);\r\nbreak;\r\ncase MFCINST_RES_CHANGE_FLUSH:\r\ns5p_mfc_run_dec_frame(ctx, MFC_DEC_FRAME);\r\nbreak;\r\ncase MFCINST_RES_CHANGE_END:\r\nmfc_debug(2, "Finished remaining frames after resolution change\n");\r\nctx->capture_state = QUEUE_FREE;\r\nmfc_debug(2, "Will re-init the codec\n");\r\ns5p_mfc_run_init_dec(ctx);\r\nbreak;\r\ndefault:\r\nret = -EAGAIN;\r\n}\r\n} else if (ctx->type == MFCINST_ENCODER) {\r\nswitch (ctx->state) {\r\ncase MFCINST_FINISHING:\r\ncase MFCINST_RUNNING:\r\nret = s5p_mfc_run_enc_frame(ctx);\r\nbreak;\r\ncase MFCINST_INIT:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_open_inst_cmd(ctx);\r\nbreak;\r\ncase MFCINST_RETURN_INST:\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\nret = s5p_mfc_close_inst_cmd(ctx);\r\nbreak;\r\ncase MFCINST_GOT_INST:\r\ns5p_mfc_run_init_enc(ctx);\r\nbreak;\r\ndefault:\r\nret = -EAGAIN;\r\n}\r\n} else {\r\nmfc_err("Invalid context type: %d\n", ctx->type);\r\nret = -EAGAIN;\r\n}\r\nif (ret) {\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nmfc_err("Failed to unlock hardware\n");\r\ns5p_mfc_clock_off();\r\n}\r\n}\r\nvoid s5p_mfc_cleanup_queue(struct list_head *lh, struct vb2_queue *vq)\r\n{\r\nstruct s5p_mfc_buf *b;\r\nint i;\r\nwhile (!list_empty(lh)) {\r\nb = list_entry(lh->next, struct s5p_mfc_buf, list);\r\nfor (i = 0; i < b->b->num_planes; i++)\r\nvb2_set_plane_payload(b->b, i, 0);\r\nvb2_buffer_done(b->b, VB2_BUF_STATE_ERROR);\r\nlist_del(&b->list);\r\n}\r\n}
