static int _omap_device_activate(struct omap_device *od, u8 ignore_lat)\r\n{\r\nstruct timespec a, b, c;\r\ndev_dbg(&od->pdev->dev, "omap_device: activating\n");\r\nwhile (od->pm_lat_level > 0) {\r\nstruct omap_device_pm_latency *odpl;\r\nunsigned long long act_lat = 0;\r\nod->pm_lat_level--;\r\nodpl = od->pm_lats + od->pm_lat_level;\r\nif (!ignore_lat &&\r\n(od->dev_wakeup_lat <= od->_dev_wakeup_lat_limit))\r\nbreak;\r\nread_persistent_clock(&a);\r\nodpl->activate_func(od);\r\nread_persistent_clock(&b);\r\nc = timespec_sub(b, a);\r\nact_lat = timespec_to_ns(&c);\r\ndev_dbg(&od->pdev->dev,\r\n"omap_device: pm_lat %d: activate: elapsed time "\r\n"%llu nsec\n", od->pm_lat_level, act_lat);\r\nif (act_lat > odpl->activate_lat) {\r\nodpl->activate_lat_worst = act_lat;\r\nif (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {\r\nodpl->activate_lat = act_lat;\r\ndev_dbg(&od->pdev->dev,\r\n"new worst case activate latency "\r\n"%d: %llu\n",\r\nod->pm_lat_level, act_lat);\r\n} else\r\ndev_warn(&od->pdev->dev,\r\n"activate latency %d "\r\n"higher than exptected. (%llu > %d)\n",\r\nod->pm_lat_level, act_lat,\r\nodpl->activate_lat);\r\n}\r\nod->dev_wakeup_lat -= odpl->activate_lat;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _omap_device_deactivate(struct omap_device *od, u8 ignore_lat)\r\n{\r\nstruct timespec a, b, c;\r\ndev_dbg(&od->pdev->dev, "omap_device: deactivating\n");\r\nwhile (od->pm_lat_level < od->pm_lats_cnt) {\r\nstruct omap_device_pm_latency *odpl;\r\nunsigned long long deact_lat = 0;\r\nodpl = od->pm_lats + od->pm_lat_level;\r\nif (!ignore_lat &&\r\n((od->dev_wakeup_lat + odpl->activate_lat) >\r\nod->_dev_wakeup_lat_limit))\r\nbreak;\r\nread_persistent_clock(&a);\r\nodpl->deactivate_func(od);\r\nread_persistent_clock(&b);\r\nc = timespec_sub(b, a);\r\ndeact_lat = timespec_to_ns(&c);\r\ndev_dbg(&od->pdev->dev,\r\n"omap_device: pm_lat %d: deactivate: elapsed time "\r\n"%llu nsec\n", od->pm_lat_level, deact_lat);\r\nif (deact_lat > odpl->deactivate_lat) {\r\nodpl->deactivate_lat_worst = deact_lat;\r\nif (odpl->flags & OMAP_DEVICE_LATENCY_AUTO_ADJUST) {\r\nodpl->deactivate_lat = deact_lat;\r\ndev_dbg(&od->pdev->dev,\r\n"new worst case deactivate latency "\r\n"%d: %llu\n",\r\nod->pm_lat_level, deact_lat);\r\n} else\r\ndev_warn(&od->pdev->dev,\r\n"deactivate latency %d "\r\n"higher than exptected. (%llu > %d)\n",\r\nod->pm_lat_level, deact_lat,\r\nodpl->deactivate_lat);\r\n}\r\nod->dev_wakeup_lat += odpl->activate_lat;\r\nod->pm_lat_level++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void _add_clkdev(struct omap_device *od, const char *clk_alias,\r\nconst char *clk_name)\r\n{\r\nstruct clk *r;\r\nstruct clk_lookup *l;\r\nif (!clk_alias || !clk_name)\r\nreturn;\r\ndev_dbg(&od->pdev->dev, "Creating %s -> %s\n", clk_alias, clk_name);\r\nr = clk_get_sys(dev_name(&od->pdev->dev), clk_alias);\r\nif (!IS_ERR(r)) {\r\ndev_warn(&od->pdev->dev,\r\n"alias %s already exists\n", clk_alias);\r\nclk_put(r);\r\nreturn;\r\n}\r\nr = omap_clk_get_by_name(clk_name);\r\nif (IS_ERR(r)) {\r\ndev_err(&od->pdev->dev,\r\n"omap_clk_get_by_name for %s failed\n", clk_name);\r\nreturn;\r\n}\r\nl = clkdev_alloc(r, clk_alias, dev_name(&od->pdev->dev));\r\nif (!l) {\r\ndev_err(&od->pdev->dev,\r\n"clkdev_alloc for %s failed\n", clk_alias);\r\nreturn;\r\n}\r\nclkdev_add(l);\r\n}\r\nstatic void _add_hwmod_clocks_clkdev(struct omap_device *od,\r\nstruct omap_hwmod *oh)\r\n{\r\nint i;\r\n_add_clkdev(od, "fck", oh->main_clk);\r\nfor (i = 0; i < oh->opt_clks_cnt; i++)\r\n_add_clkdev(od, oh->opt_clks[i].role, oh->opt_clks[i].clk);\r\n}\r\nstatic int omap_device_build_from_dt(struct platform_device *pdev)\r\n{\r\nstruct omap_hwmod **hwmods;\r\nstruct omap_device *od;\r\nstruct omap_hwmod *oh;\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst char *oh_name;\r\nint oh_cnt, i, ret = 0;\r\noh_cnt = of_property_count_strings(node, "ti,hwmods");\r\nif (!oh_cnt || IS_ERR_VALUE(oh_cnt)) {\r\ndev_dbg(&pdev->dev, "No 'hwmods' to build omap_device\n");\r\nreturn -ENODEV;\r\n}\r\nhwmods = kzalloc(sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);\r\nif (!hwmods) {\r\nret = -ENOMEM;\r\ngoto odbfd_exit;\r\n}\r\nfor (i = 0; i < oh_cnt; i++) {\r\nof_property_read_string_index(node, "ti,hwmods", i, &oh_name);\r\noh = omap_hwmod_lookup(oh_name);\r\nif (!oh) {\r\ndev_err(&pdev->dev, "Cannot lookup hwmod '%s'\n",\r\noh_name);\r\nret = -EINVAL;\r\ngoto odbfd_exit1;\r\n}\r\nhwmods[i] = oh;\r\n}\r\nod = omap_device_alloc(pdev, hwmods, oh_cnt, NULL, 0);\r\nif (!od) {\r\ndev_err(&pdev->dev, "Cannot allocate omap_device for :%s\n",\r\noh_name);\r\nret = PTR_ERR(od);\r\ngoto odbfd_exit1;\r\n}\r\nif (of_get_property(node, "ti,no_idle_on_suspend", NULL))\r\nomap_device_disable_idle_on_suspend(pdev);\r\npdev->dev.pm_domain = &omap_device_pm_domain;\r\nodbfd_exit1:\r\nkfree(hwmods);\r\nodbfd_exit:\r\nreturn ret;\r\n}\r\nstatic int _omap_device_notifier_call(struct notifier_block *nb,\r\nunsigned long event, void *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nswitch (event) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (pdev->dev.of_node)\r\nomap_device_build_from_dt(pdev);\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nif (pdev->archdata.od)\r\nomap_device_delete(pdev->archdata.od);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nint omap_device_get_context_loss_count(struct platform_device *pdev)\r\n{\r\nstruct omap_device *od;\r\nu32 ret = 0;\r\nod = to_omap_device(pdev);\r\nif (od->hwmods_cnt)\r\nret = omap_hwmod_get_context_loss_count(od->hwmods[0]);\r\nreturn ret;\r\n}\r\nstatic int omap_device_count_resources(struct omap_device *od)\r\n{\r\nint c = 0;\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nc += omap_hwmod_count_resources(od->hwmods[i]);\r\npr_debug("omap_device: %s: counted %d total resources across %d "\r\n"hwmods\n", od->pdev->name, c, od->hwmods_cnt);\r\nreturn c;\r\n}\r\nstatic int omap_device_fill_resources(struct omap_device *od,\r\nstruct resource *res)\r\n{\r\nint i, r;\r\nfor (i = 0; i < od->hwmods_cnt; i++) {\r\nr = omap_hwmod_fill_resources(od->hwmods[i], res);\r\nres += r;\r\n}\r\nreturn 0;\r\n}\r\nstruct omap_device *omap_device_alloc(struct platform_device *pdev,\r\nstruct omap_hwmod **ohs, int oh_cnt,\r\nstruct omap_device_pm_latency *pm_lats,\r\nint pm_lats_cnt)\r\n{\r\nint ret = -ENOMEM;\r\nstruct omap_device *od;\r\nstruct resource *res = NULL;\r\nint i, res_count;\r\nstruct omap_hwmod **hwmods;\r\nod = kzalloc(sizeof(struct omap_device), GFP_KERNEL);\r\nif (!od) {\r\nret = -ENOMEM;\r\ngoto oda_exit1;\r\n}\r\nod->hwmods_cnt = oh_cnt;\r\nhwmods = kmemdup(ohs, sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);\r\nif (!hwmods)\r\ngoto oda_exit2;\r\nod->hwmods = hwmods;\r\nod->pdev = pdev;\r\nif (pdev->num_resources && pdev->resource)\r\ndev_warn(&pdev->dev, "%s(): resources already allocated %d\n",\r\n__func__, pdev->num_resources);\r\nres_count = omap_device_count_resources(od);\r\nif (res_count > 0) {\r\ndev_dbg(&pdev->dev, "%s(): resources allocated from hwmod %d\n",\r\n__func__, res_count);\r\nres = kzalloc(sizeof(struct resource) * res_count, GFP_KERNEL);\r\nif (!res)\r\ngoto oda_exit3;\r\nomap_device_fill_resources(od, res);\r\nret = platform_device_add_resources(pdev, res, res_count);\r\nkfree(res);\r\nif (ret)\r\ngoto oda_exit3;\r\n}\r\nif (!pm_lats) {\r\npm_lats = omap_default_latency;\r\npm_lats_cnt = ARRAY_SIZE(omap_default_latency);\r\n}\r\nod->pm_lats_cnt = pm_lats_cnt;\r\nod->pm_lats = kmemdup(pm_lats,\r\nsizeof(struct omap_device_pm_latency) * pm_lats_cnt,\r\nGFP_KERNEL);\r\nif (!od->pm_lats)\r\ngoto oda_exit3;\r\npdev->archdata.od = od;\r\nfor (i = 0; i < oh_cnt; i++) {\r\nhwmods[i]->od = od;\r\n_add_hwmod_clocks_clkdev(od, hwmods[i]);\r\n}\r\nreturn od;\r\noda_exit3:\r\nkfree(hwmods);\r\noda_exit2:\r\nkfree(od);\r\noda_exit1:\r\ndev_err(&pdev->dev, "omap_device: build failed (%d)\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid omap_device_delete(struct omap_device *od)\r\n{\r\nif (!od)\r\nreturn;\r\nod->pdev->archdata.od = NULL;\r\nkfree(od->pm_lats);\r\nkfree(od->hwmods);\r\nkfree(od);\r\n}\r\nstruct platform_device __init *omap_device_build(const char *pdev_name, int pdev_id,\r\nstruct omap_hwmod *oh, void *pdata,\r\nint pdata_len,\r\nstruct omap_device_pm_latency *pm_lats,\r\nint pm_lats_cnt, int is_early_device)\r\n{\r\nstruct omap_hwmod *ohs[] = { oh };\r\nif (!oh)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn omap_device_build_ss(pdev_name, pdev_id, ohs, 1, pdata,\r\npdata_len, pm_lats, pm_lats_cnt,\r\nis_early_device);\r\n}\r\nstruct platform_device __init *omap_device_build_ss(const char *pdev_name, int pdev_id,\r\nstruct omap_hwmod **ohs, int oh_cnt,\r\nvoid *pdata, int pdata_len,\r\nstruct omap_device_pm_latency *pm_lats,\r\nint pm_lats_cnt, int is_early_device)\r\n{\r\nint ret = -ENOMEM;\r\nstruct platform_device *pdev;\r\nstruct omap_device *od;\r\nif (!ohs || oh_cnt == 0 || !pdev_name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!pdata && pdata_len > 0)\r\nreturn ERR_PTR(-EINVAL);\r\npdev = platform_device_alloc(pdev_name, pdev_id);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto odbs_exit;\r\n}\r\nif (pdev->id != -1)\r\ndev_set_name(&pdev->dev, "%s.%d", pdev->name, pdev->id);\r\nelse\r\ndev_set_name(&pdev->dev, "%s", pdev->name);\r\nod = omap_device_alloc(pdev, ohs, oh_cnt, pm_lats, pm_lats_cnt);\r\nif (!od)\r\ngoto odbs_exit1;\r\nret = platform_device_add_data(pdev, pdata, pdata_len);\r\nif (ret)\r\ngoto odbs_exit2;\r\nif (is_early_device)\r\nret = omap_early_device_register(pdev);\r\nelse\r\nret = omap_device_register(pdev);\r\nif (ret)\r\ngoto odbs_exit2;\r\nreturn pdev;\r\nodbs_exit2:\r\nomap_device_delete(od);\r\nodbs_exit1:\r\nplatform_device_put(pdev);\r\nodbs_exit:\r\npr_err("omap_device: %s: build failed (%d)\n", pdev_name, ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int __init omap_early_device_register(struct platform_device *pdev)\r\n{\r\nstruct platform_device *devices[1];\r\ndevices[0] = pdev;\r\nearly_platform_add_devices(devices, 1);\r\nreturn 0;\r\n}\r\nstatic int _od_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nint ret;\r\nret = pm_generic_runtime_suspend(dev);\r\nif (!ret)\r\nomap_device_idle(pdev);\r\nreturn ret;\r\n}\r\nstatic int _od_runtime_idle(struct device *dev)\r\n{\r\nreturn pm_generic_runtime_idle(dev);\r\n}\r\nstatic int _od_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nomap_device_enable(pdev);\r\nreturn pm_generic_runtime_resume(dev);\r\n}\r\nstatic int _od_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_device *od = to_omap_device(pdev);\r\nint ret;\r\nret = pm_generic_suspend_noirq(dev);\r\nif (!ret && !pm_runtime_status_suspended(dev)) {\r\nif (pm_generic_runtime_suspend(dev) == 0) {\r\nif (!(od->flags & OMAP_DEVICE_NO_IDLE_ON_SUSPEND))\r\nomap_device_idle(pdev);\r\nod->flags |= OMAP_DEVICE_SUSPENDED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int _od_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_device *od = to_omap_device(pdev);\r\nif ((od->flags & OMAP_DEVICE_SUSPENDED) &&\r\n!pm_runtime_status_suspended(dev)) {\r\nod->flags &= ~OMAP_DEVICE_SUSPENDED;\r\nif (!(od->flags & OMAP_DEVICE_NO_IDLE_ON_SUSPEND))\r\nomap_device_enable(pdev);\r\npm_generic_runtime_resume(dev);\r\n}\r\nreturn pm_generic_resume_noirq(dev);\r\n}\r\nint omap_device_register(struct platform_device *pdev)\r\n{\r\npr_debug("omap_device: %s: registering\n", pdev->name);\r\npdev->dev.pm_domain = &omap_device_pm_domain;\r\nreturn platform_device_add(pdev);\r\n}\r\nint omap_device_enable(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct omap_device *od;\r\nod = to_omap_device(pdev);\r\nif (od->_state == OMAP_DEVICE_STATE_ENABLED) {\r\ndev_warn(&pdev->dev,\r\n"omap_device: %s() called from invalid state %d\n",\r\n__func__, od->_state);\r\nreturn -EINVAL;\r\n}\r\nif (od->_state == OMAP_DEVICE_STATE_UNKNOWN)\r\nod->pm_lat_level = od->pm_lats_cnt;\r\nret = _omap_device_activate(od, IGNORE_WAKEUP_LAT);\r\nod->dev_wakeup_lat = 0;\r\nod->_dev_wakeup_lat_limit = UINT_MAX;\r\nod->_state = OMAP_DEVICE_STATE_ENABLED;\r\nreturn ret;\r\n}\r\nint omap_device_idle(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct omap_device *od;\r\nod = to_omap_device(pdev);\r\nif (od->_state != OMAP_DEVICE_STATE_ENABLED) {\r\ndev_warn(&pdev->dev,\r\n"omap_device: %s() called from invalid state %d\n",\r\n__func__, od->_state);\r\nreturn -EINVAL;\r\n}\r\nret = _omap_device_deactivate(od, USE_WAKEUP_LAT);\r\nod->_state = OMAP_DEVICE_STATE_IDLE;\r\nreturn ret;\r\n}\r\nint omap_device_shutdown(struct platform_device *pdev)\r\n{\r\nint ret, i;\r\nstruct omap_device *od;\r\nod = to_omap_device(pdev);\r\nif (od->_state != OMAP_DEVICE_STATE_ENABLED &&\r\nod->_state != OMAP_DEVICE_STATE_IDLE) {\r\ndev_warn(&pdev->dev,\r\n"omap_device: %s() called from invalid state %d\n",\r\n__func__, od->_state);\r\nreturn -EINVAL;\r\n}\r\nret = _omap_device_deactivate(od, IGNORE_WAKEUP_LAT);\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nomap_hwmod_shutdown(od->hwmods[i]);\r\nod->_state = OMAP_DEVICE_STATE_SHUTDOWN;\r\nreturn ret;\r\n}\r\nint omap_device_align_pm_lat(struct platform_device *pdev,\r\nu32 new_wakeup_lat_limit)\r\n{\r\nint ret = -EINVAL;\r\nstruct omap_device *od;\r\nod = to_omap_device(pdev);\r\nif (new_wakeup_lat_limit == od->dev_wakeup_lat)\r\nreturn 0;\r\nod->_dev_wakeup_lat_limit = new_wakeup_lat_limit;\r\nif (od->_state != OMAP_DEVICE_STATE_IDLE)\r\nreturn 0;\r\nelse if (new_wakeup_lat_limit > od->dev_wakeup_lat)\r\nret = _omap_device_deactivate(od, USE_WAKEUP_LAT);\r\nelse if (new_wakeup_lat_limit < od->dev_wakeup_lat)\r\nret = _omap_device_activate(od, USE_WAKEUP_LAT);\r\nreturn ret;\r\n}\r\nstruct powerdomain *omap_device_get_pwrdm(struct omap_device *od)\r\n{\r\nif (!od->hwmods_cnt)\r\nreturn NULL;\r\nreturn omap_hwmod_get_pwrdm(od->hwmods[0]);\r\n}\r\nvoid __iomem *omap_device_get_rt_va(struct omap_device *od)\r\n{\r\nif (od->hwmods_cnt != 1)\r\nreturn NULL;\r\nreturn omap_hwmod_get_mpu_rt_va(od->hwmods[0]);\r\n}\r\nstruct device *omap_device_get_by_hwmod_name(const char *oh_name)\r\n{\r\nstruct omap_hwmod *oh;\r\nif (!oh_name) {\r\nWARN(1, "%s: no hwmod name!\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\noh = omap_hwmod_lookup(oh_name);\r\nif (IS_ERR_OR_NULL(oh)) {\r\nWARN(1, "%s: no hwmod for %s\n", __func__,\r\noh_name);\r\nreturn ERR_PTR(oh ? PTR_ERR(oh) : -ENODEV);\r\n}\r\nif (IS_ERR_OR_NULL(oh->od)) {\r\nWARN(1, "%s: no omap_device for %s\n", __func__,\r\noh_name);\r\nreturn ERR_PTR(oh->od ? PTR_ERR(oh->od) : -ENODEV);\r\n}\r\nif (IS_ERR_OR_NULL(oh->od->pdev))\r\nreturn ERR_PTR(oh->od->pdev ? PTR_ERR(oh->od->pdev) : -ENODEV);\r\nreturn &oh->od->pdev->dev;\r\n}\r\nint omap_device_enable_hwmods(struct omap_device *od)\r\n{\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nomap_hwmod_enable(od->hwmods[i]);\r\nreturn 0;\r\n}\r\nint omap_device_idle_hwmods(struct omap_device *od)\r\n{\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nomap_hwmod_idle(od->hwmods[i]);\r\nreturn 0;\r\n}\r\nint omap_device_disable_clocks(struct omap_device *od)\r\n{\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nomap_hwmod_disable_clocks(od->hwmods[i]);\r\nreturn 0;\r\n}\r\nint omap_device_enable_clocks(struct omap_device *od)\r\n{\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nomap_hwmod_enable_clocks(od->hwmods[i]);\r\nreturn 0;\r\n}\r\nstatic int __init omap_device_init(void)\r\n{\r\nbus_register_notifier(&platform_bus_type, &platform_nb);\r\nreturn 0;\r\n}
