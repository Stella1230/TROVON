static int read_ad1843_reg(void *priv, int reg)\r\n{\r\nstruct snd_sgio2audio *chip = priv;\r\nint val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->ad1843_lock, flags);\r\nwriteq((reg << CODEC_CONTROL_ADDRESS_SHIFT) |\r\nCODEC_CONTROL_READ, &mace->perif.audio.codec_control);\r\nwmb();\r\nval = readq(&mace->perif.audio.codec_control);\r\nudelay(200);\r\nval = readq(&mace->perif.audio.codec_read);\r\nspin_unlock_irqrestore(&chip->ad1843_lock, flags);\r\nreturn val;\r\n}\r\nstatic int write_ad1843_reg(void *priv, int reg, int word)\r\n{\r\nstruct snd_sgio2audio *chip = priv;\r\nint val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->ad1843_lock, flags);\r\nwriteq((reg << CODEC_CONTROL_ADDRESS_SHIFT) |\r\n(word << CODEC_CONTROL_WORD_SHIFT),\r\n&mace->perif.audio.codec_control);\r\nwmb();\r\nval = readq(&mace->perif.audio.codec_control);\r\nudelay(200);\r\nspin_unlock_irqrestore(&chip->ad1843_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sgio2audio_gain_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = ad1843_get_gain_max(&chip->ad1843,\r\n(int)kcontrol->private_value);\r\nreturn 0;\r\n}\r\nstatic int sgio2audio_gain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\r\nint vol;\r\nvol = ad1843_get_gain(&chip->ad1843, (int)kcontrol->private_value);\r\nucontrol->value.integer.value[0] = (vol >> 8) & 0xFF;\r\nucontrol->value.integer.value[1] = vol & 0xFF;\r\nreturn 0;\r\n}\r\nstatic int sgio2audio_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\r\nint newvol, oldvol;\r\noldvol = ad1843_get_gain(&chip->ad1843, kcontrol->private_value);\r\nnewvol = (ucontrol->value.integer.value[0] << 8) |\r\nucontrol->value.integer.value[1];\r\nnewvol = ad1843_set_gain(&chip->ad1843, kcontrol->private_value,\r\nnewvol);\r\nreturn newvol != oldvol;\r\n}\r\nstatic int sgio2audio_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char *texts[3] = {\r\n"Cam Mic", "Mic", "Line"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= 3)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int sgio2audio_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = ad1843_get_recsrc(&chip->ad1843);\r\nreturn 0;\r\n}\r\nstatic int sgio2audio_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sgio2audio *chip = snd_kcontrol_chip(kcontrol);\r\nint newsrc, oldsrc;\r\noldsrc = ad1843_get_recsrc(&chip->ad1843);\r\nnewsrc = ad1843_set_recsrc(&chip->ad1843,\r\nucontrol->value.enumerated.item[0]);\r\nreturn newsrc != oldsrc;\r\n}\r\nstatic int __devinit snd_sgio2audio_new_mixer(struct snd_sgio2audio *chip)\r\n{\r\nint err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&sgio2audio_ctrl_pcm0, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&sgio2audio_ctrl_pcm1, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&sgio2audio_ctrl_reclevel, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&sgio2audio_ctrl_recsource, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&sgio2audio_ctrl_line, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&sgio2audio_ctrl_cd, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&sgio2audio_ctrl_mic, chip));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_dma_pull_frag(struct snd_sgio2audio *chip,\r\nunsigned int ch, unsigned int count)\r\n{\r\nint ret;\r\nunsigned long src_base, src_pos, dst_mask;\r\nunsigned char *dst_base;\r\nint dst_pos;\r\nu64 *src;\r\ns16 *dst;\r\nu64 x;\r\nunsigned long flags;\r\nstruct snd_pcm_runtime *runtime = chip->channel[ch].substream->runtime;\r\nspin_lock_irqsave(&chip->channel[ch].lock, flags);\r\nsrc_base = (unsigned long) chip->ring_base | (ch << CHANNEL_RING_SHIFT);\r\nsrc_pos = readq(&mace->perif.audio.chan[ch].read_ptr);\r\ndst_base = runtime->dma_area;\r\ndst_pos = chip->channel[ch].pos;\r\ndst_mask = frames_to_bytes(runtime, runtime->buffer_size) - 1;\r\nchip->channel[ch].size += (count >> 3);\r\nret = chip->channel[ch].size >= runtime->period_size;\r\nchip->channel[ch].size %= runtime->period_size;\r\nwhile (count) {\r\nsrc = (u64 *)(src_base + src_pos);\r\ndst = (s16 *)(dst_base + dst_pos);\r\nx = *src;\r\ndst[0] = (x >> CHANNEL_LEFT_SHIFT) & 0xffff;\r\ndst[1] = (x >> CHANNEL_RIGHT_SHIFT) & 0xffff;\r\nsrc_pos = (src_pos + sizeof(u64)) & CHANNEL_RING_MASK;\r\ndst_pos = (dst_pos + 2 * sizeof(s16)) & dst_mask;\r\ncount -= sizeof(u64);\r\n}\r\nwriteq(src_pos, &mace->perif.audio.chan[ch].read_ptr);\r\nchip->channel[ch].pos = dst_pos;\r\nspin_unlock_irqrestore(&chip->channel[ch].lock, flags);\r\nreturn ret;\r\n}\r\nstatic int snd_sgio2audio_dma_push_frag(struct snd_sgio2audio *chip,\r\nunsigned int ch, unsigned int count)\r\n{\r\nint ret;\r\ns64 l, r;\r\nunsigned long dst_base, dst_pos, src_mask;\r\nunsigned char *src_base;\r\nint src_pos;\r\nu64 *dst;\r\ns16 *src;\r\nunsigned long flags;\r\nstruct snd_pcm_runtime *runtime = chip->channel[ch].substream->runtime;\r\nspin_lock_irqsave(&chip->channel[ch].lock, flags);\r\ndst_base = (unsigned long)chip->ring_base | (ch << CHANNEL_RING_SHIFT);\r\ndst_pos = readq(&mace->perif.audio.chan[ch].write_ptr);\r\nsrc_base = runtime->dma_area;\r\nsrc_pos = chip->channel[ch].pos;\r\nsrc_mask = frames_to_bytes(runtime, runtime->buffer_size) - 1;\r\nchip->channel[ch].size += (count >> 3);\r\nret = chip->channel[ch].size >= runtime->period_size;\r\nchip->channel[ch].size %= runtime->period_size;\r\nwhile (count) {\r\nsrc = (s16 *)(src_base + src_pos);\r\ndst = (u64 *)(dst_base + dst_pos);\r\nl = src[0];\r\nr = src[1];\r\n*dst = ((l & 0x00ffffff) << CHANNEL_LEFT_SHIFT) |\r\n((r & 0x00ffffff) << CHANNEL_RIGHT_SHIFT);\r\ndst_pos = (dst_pos + sizeof(u64)) & CHANNEL_RING_MASK;\r\nsrc_pos = (src_pos + 2 * sizeof(s16)) & src_mask;\r\ncount -= sizeof(u64);\r\n}\r\nwriteq(dst_pos, &mace->perif.audio.chan[ch].write_ptr);\r\nchip->channel[ch].pos = src_pos;\r\nspin_unlock_irqrestore(&chip->channel[ch].lock, flags);\r\nreturn ret;\r\n}\r\nstatic int snd_sgio2audio_dma_start(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\r\nint ch = chan->idx;\r\nwriteq(CHANNEL_CONTROL_RESET, &mace->perif.audio.chan[ch].control);\r\nudelay(10);\r\nwriteq(0, &mace->perif.audio.chan[ch].control);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsnd_sgio2audio_dma_push_frag(chip, ch, CHANNEL_RING_SIZE - 32);\r\n}\r\nwriteq(CHANNEL_DMA_ENABLE | CHANNEL_INT_THRESHOLD_50,\r\n&mace->perif.audio.chan[ch].control);\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_dma_stop(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\r\nwriteq(0, &mace->perif.audio.chan[chan->idx].control);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_sgio2audio_dma_in_isr(int irq, void *dev_id)\r\n{\r\nstruct snd_sgio2audio_chan *chan = dev_id;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_sgio2audio *chip;\r\nint count, ch;\r\nsubstream = chan->substream;\r\nchip = snd_pcm_substream_chip(substream);\r\nch = chan->idx;\r\ncount = CHANNEL_RING_SIZE -\r\nreadq(&mace->perif.audio.chan[ch].depth) - 32;\r\nif (snd_sgio2audio_dma_pull_frag(chip, ch, count))\r\nsnd_pcm_period_elapsed(substream);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t snd_sgio2audio_dma_out_isr(int irq, void *dev_id)\r\n{\r\nstruct snd_sgio2audio_chan *chan = dev_id;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_sgio2audio *chip;\r\nint count, ch;\r\nsubstream = chan->substream;\r\nchip = snd_pcm_substream_chip(substream);\r\nch = chan->idx;\r\ncount = CHANNEL_RING_SIZE -\r\nreadq(&mace->perif.audio.chan[ch].depth) - 32;\r\nif (snd_sgio2audio_dma_push_frag(chip, ch, count))\r\nsnd_pcm_period_elapsed(substream);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t snd_sgio2audio_error_isr(int irq, void *dev_id)\r\n{\r\nstruct snd_sgio2audio_chan *chan = dev_id;\r\nstruct snd_pcm_substream *substream;\r\nsubstream = chan->substream;\r\nsnd_sgio2audio_dma_stop(substream);\r\nsnd_sgio2audio_dma_start(substream);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_sgio2audio_playback1_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw = snd_sgio2audio_pcm_hw;\r\nruntime->private_data = &chip->channel[1];\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_playback2_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw = snd_sgio2audio_pcm_hw;\r\nruntime->private_data = &chip->channel[2];\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw = snd_sgio2audio_pcm_hw;\r\nruntime->private_data = &chip->channel[0];\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_sgio2audio_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int snd_sgio2audio_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\r\nint ch = chan->idx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->channel[ch].lock, flags);\r\nchip->channel[ch].pos = 0;\r\nchip->channel[ch].size = 0;\r\nchip->channel[ch].substream = substream;\r\nswitch (substream->stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nad1843_setup_dac(&chip->ad1843,\r\nch - 1,\r\nruntime->rate,\r\nSNDRV_PCM_FORMAT_S16_LE,\r\nruntime->channels);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nad1843_setup_adc(&chip->ad1843,\r\nruntime->rate,\r\nSNDRV_PCM_FORMAT_S16_LE,\r\nruntime->channels);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&chip->channel[ch].lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_pcm_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_sgio2audio_dma_start(substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_sgio2audio_dma_stop(substream);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_sgio2audio_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sgio2audio *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_sgio2audio_chan *chan = substream->runtime->private_data;\r\nreturn bytes_to_frames(substream->runtime,\r\nchip->channel[chan->idx].pos);\r\n}\r\nstatic int __devinit snd_sgio2audio_new_pcm(struct snd_sgio2audio *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(chip->card, "SGI O2 Audio", 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "SGI O2 DAC1");\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_sgio2audio_playback1_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_sgio2audio_capture_ops);\r\nerr = snd_pcm_new(chip->card, "SGI O2 Audio", 1, 1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "SGI O2 DAC2");\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_sgio2audio_playback2_ops);\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_free(struct snd_sgio2audio *chip)\r\n{\r\nint i;\r\nwriteq(AUDIO_CONTROL_RESET, &mace->perif.audio.control);\r\nudelay(1);\r\nwriteq(0, &mace->perif.audio.control);\r\nfor (i = 0; i < ARRAY_SIZE(snd_sgio2_isr_table); i++)\r\nfree_irq(snd_sgio2_isr_table[i].irq,\r\n&chip->channel[snd_sgio2_isr_table[i].idx]);\r\ndma_free_coherent(NULL, MACEISA_RINGBUFFERS_SIZE,\r\nchip->ring_base, chip->ring_base_dma);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_sgio2audio_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_sgio2audio *chip = device->device_data;\r\nreturn snd_sgio2audio_free(chip);\r\n}\r\nstatic int __devinit snd_sgio2audio_create(struct snd_card *card,\r\nstruct snd_sgio2audio **rchip)\r\n{\r\nstruct snd_sgio2audio *chip;\r\nint i, err;\r\n*rchip = NULL;\r\nif (!(readq(&mace->perif.audio.control) & AUDIO_CONTROL_CODEC_PRESENT))\r\nreturn -ENOENT;\r\nchip = kzalloc(sizeof(struct snd_sgio2audio), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->card = card;\r\nchip->ring_base = dma_alloc_coherent(NULL, MACEISA_RINGBUFFERS_SIZE,\r\n&chip->ring_base_dma, GFP_USER);\r\nif (chip->ring_base == NULL) {\r\nprintk(KERN_ERR\r\n"sgio2audio: could not allocate ring buffers\n");\r\nkfree(chip);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->ad1843_lock);\r\nfor (i = 0; i < 3; i++) {\r\nspin_lock_init(&chip->channel[i].lock);\r\nchip->channel[i].idx = i;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(snd_sgio2_isr_table); i++) {\r\nif (request_irq(snd_sgio2_isr_table[i].irq,\r\nsnd_sgio2_isr_table[i].isr,\r\n0,\r\nsnd_sgio2_isr_table[i].desc,\r\n&chip->channel[snd_sgio2_isr_table[i].idx])) {\r\nsnd_sgio2audio_free(chip);\r\nprintk(KERN_ERR "sgio2audio: cannot allocate irq %d\n",\r\nsnd_sgio2_isr_table[i].irq);\r\nreturn -EBUSY;\r\n}\r\n}\r\nwriteq(AUDIO_CONTROL_RESET, &mace->perif.audio.control);\r\nudelay(1);\r\nwriteq(0, &mace->perif.audio.control);\r\nmsleep_interruptible(1);\r\nwriteq(chip->ring_base_dma, &mace->perif.ctrl.ringbase);\r\nchip->ad1843.read = read_ad1843_reg;\r\nchip->ad1843.write = write_ad1843_reg;\r\nchip->ad1843.chip = chip;\r\nerr = ad1843_init(&chip->ad1843);\r\nif (err < 0) {\r\nsnd_sgio2audio_free(chip);\r\nreturn err;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\nsnd_sgio2audio_free(chip);\r\nreturn err;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_sgio2audio_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_sgio2audio *chip;\r\nint err;\r\nerr = snd_card_create(index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_sgio2audio_create(card, &chip);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pdev->dev);\r\nerr = snd_sgio2audio_new_pcm(chip);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_sgio2audio_new_mixer(chip);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, "SGI O2 Audio");\r\nstrcpy(card->shortname, "SGI O2 Audio");\r\nsprintf(card->longname, "%s irq %i-%i",\r\ncard->shortname,\r\nMACEISA_AUDIO1_DMAT_IRQ,\r\nMACEISA_AUDIO3_MERR_IRQ);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nstatic int __devexit snd_sgio2audio_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nsnd_card_free(card);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
