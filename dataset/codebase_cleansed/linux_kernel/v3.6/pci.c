static void ath5k_pci_read_cachesize(struct ath_common *common, int *csz)\r\n{\r\nstruct ath5k_hw *ah = (struct ath5k_hw *) common->priv;\r\nu8 u8tmp;\r\npci_read_config_byte(ah->pdev, PCI_CACHE_LINE_SIZE, &u8tmp);\r\n*csz = (int)u8tmp;\r\nif (*csz == 0)\r\n*csz = L1_CACHE_BYTES >> 2;\r\n}\r\nstatic bool\r\nath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)\r\n{\r\nstruct ath5k_hw *ah = (struct ath5k_hw *) common->ah;\r\nu32 status, timeout;\r\nif (ah->ah_version == AR5K_AR5210) {\r\nAR5K_REG_ENABLE_BITS(ah, AR5K_PCICFG, AR5K_PCICFG_EEAE);\r\n(void)ath5k_hw_reg_read(ah, AR5K_EEPROM_BASE + (4 * offset));\r\n} else {\r\nath5k_hw_reg_write(ah, offset, AR5K_EEPROM_BASE);\r\nAR5K_REG_ENABLE_BITS(ah, AR5K_EEPROM_CMD,\r\nAR5K_EEPROM_CMD_READ);\r\n}\r\nfor (timeout = AR5K_TUNE_REGISTER_TIMEOUT; timeout > 0; timeout--) {\r\nstatus = ath5k_hw_reg_read(ah, AR5K_EEPROM_STATUS);\r\nif (status & AR5K_EEPROM_STAT_RDDONE) {\r\nif (status & AR5K_EEPROM_STAT_RDERR)\r\nreturn false;\r\n*data = (u16)(ath5k_hw_reg_read(ah, AR5K_EEPROM_DATA) &\r\n0xffff);\r\nreturn true;\r\n}\r\nusleep_range(15, 20);\r\n}\r\nreturn false;\r\n}\r\nint ath5k_hw_read_srev(struct ath5k_hw *ah)\r\n{\r\nah->ah_mac_srev = ath5k_hw_reg_read(ah, AR5K_SREV);\r\nreturn 0;\r\n}\r\nstatic int ath5k_pci_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)\r\n{\r\nu8 mac_d[ETH_ALEN] = {};\r\nu32 total, offset;\r\nu16 data;\r\nint octet;\r\nAR5K_EEPROM_READ(0x20, data);\r\nfor (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {\r\nAR5K_EEPROM_READ(offset, data);\r\ntotal += data;\r\nmac_d[octet + 1] = data & 0xff;\r\nmac_d[octet] = data >> 8;\r\noctet += 2;\r\n}\r\nif (!total || total == 3 * 0xffff)\r\nreturn -EINVAL;\r\nmemcpy(mac, mac_d, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nath5k_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nvoid __iomem *mem;\r\nstruct ath5k_hw *ah;\r\nstruct ieee80211_hw *hw;\r\nint ret;\r\nu8 csz;\r\npci_disable_link_state(pdev, PCIE_LINK_STATE_L0S);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't enable device\n");\r\ngoto err;\r\n}\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(&pdev->dev, "32-bit DMA not available\n");\r\ngoto err_dis;\r\n}\r\npci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &csz);\r\nif (csz == 0) {\r\ncsz = L1_CACHE_BYTES >> 2;\r\npci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, csz);\r\n}\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0xa8);\r\npci_set_master(pdev);\r\npci_write_config_byte(pdev, 0x41, 0);\r\nret = pci_request_region(pdev, 0, "ath5k");\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot reserve PCI memory region\n");\r\ngoto err_dis;\r\n}\r\nmem = pci_iomap(pdev, 0, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "cannot remap PCI memory region\n");\r\nret = -EIO;\r\ngoto err_reg;\r\n}\r\nhw = ieee80211_alloc_hw(sizeof(*ah), &ath5k_hw_ops);\r\nif (hw == NULL) {\r\ndev_err(&pdev->dev, "cannot allocate ieee80211_hw\n");\r\nret = -ENOMEM;\r\ngoto err_map;\r\n}\r\ndev_info(&pdev->dev, "registered as '%s'\n", wiphy_name(hw->wiphy));\r\nah = hw->priv;\r\nah->hw = hw;\r\nah->pdev = pdev;\r\nah->dev = &pdev->dev;\r\nah->irq = pdev->irq;\r\nah->devid = id->device;\r\nah->iobase = mem;\r\nret = ath5k_init_ah(ah, &ath_pci_bus_ops);\r\nif (ret)\r\ngoto err_free;\r\npci_set_drvdata(pdev, hw);\r\nreturn 0;\r\nerr_free:\r\nieee80211_free_hw(hw);\r\nerr_map:\r\npci_iounmap(pdev, mem);\r\nerr_reg:\r\npci_release_region(pdev, 0);\r\nerr_dis:\r\npci_disable_device(pdev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void __devexit\r\nath5k_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\r\nstruct ath5k_hw *ah = hw->priv;\r\nath5k_deinit_ah(ah);\r\npci_iounmap(pdev, ah->iobase);\r\npci_release_region(pdev, 0);\r\npci_disable_device(pdev);\r\nieee80211_free_hw(hw);\r\n}\r\nstatic int ath5k_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\r\nstruct ath5k_hw *ah = hw->priv;\r\nath5k_led_off(ah);\r\nreturn 0;\r\n}\r\nstatic int ath5k_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\r\nstruct ath5k_hw *ah = hw->priv;\r\npci_write_config_byte(pdev, 0x41, 0);\r\nath5k_led_enable(ah);\r\nreturn 0;\r\n}
