static int wdt_setload(struct watchdog_device *wdd, unsigned int timeout)\r\n{\r\nstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu64 load, rate;\r\nrate = clk_get_rate(wdt->clk);\r\nload = div_u64(rate, 2) * timeout - 1;\r\nload = (load > LOAD_MAX) ? LOAD_MAX : load;\r\nload = (load < LOAD_MIN) ? LOAD_MIN : load;\r\nspin_lock(&wdt->lock);\r\nwdt->load_val = load;\r\nwdt->timeout = div_u64((load + 1) * 2 + (rate / 2), rate);\r\nspin_unlock(&wdt->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int wdt_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu64 load, rate;\r\nrate = clk_get_rate(wdt->clk);\r\nspin_lock(&wdt->lock);\r\nload = readl_relaxed(wdt->base + WDTVALUE);\r\nif (!(readl_relaxed(wdt->base + WDTRIS) & INT_MASK))\r\nload += wdt->load_val + 1;\r\nspin_unlock(&wdt->lock);\r\nreturn div_u64(load, rate);\r\n}\r\nstatic int wdt_config(struct watchdog_device *wdd, bool ping)\r\n{\r\nstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\r\nint ret;\r\nif (!ping) {\r\nret = clk_prepare(wdt->clk);\r\nif (ret) {\r\ndev_err(&wdt->adev->dev, "clock prepare fail");\r\nreturn ret;\r\n}\r\nret = clk_enable(wdt->clk);\r\nif (ret) {\r\ndev_err(&wdt->adev->dev, "clock enable fail");\r\nclk_unprepare(wdt->clk);\r\nreturn ret;\r\n}\r\n}\r\nspin_lock(&wdt->lock);\r\nwritel_relaxed(UNLOCK, wdt->base + WDTLOCK);\r\nwritel_relaxed(wdt->load_val, wdt->base + WDTLOAD);\r\nif (!ping) {\r\nwritel_relaxed(INT_MASK, wdt->base + WDTINTCLR);\r\nwritel_relaxed(INT_ENABLE | RESET_ENABLE, wdt->base +\r\nWDTCONTROL);\r\n}\r\nwritel_relaxed(LOCK, wdt->base + WDTLOCK);\r\nreadl_relaxed(wdt->base + WDTLOCK);\r\nspin_unlock(&wdt->lock);\r\nreturn 0;\r\n}\r\nstatic int wdt_ping(struct watchdog_device *wdd)\r\n{\r\nreturn wdt_config(wdd, true);\r\n}\r\nstatic int wdt_enable(struct watchdog_device *wdd)\r\n{\r\nreturn wdt_config(wdd, false);\r\n}\r\nstatic int wdt_disable(struct watchdog_device *wdd)\r\n{\r\nstruct sp805_wdt *wdt = watchdog_get_drvdata(wdd);\r\nspin_lock(&wdt->lock);\r\nwritel_relaxed(UNLOCK, wdt->base + WDTLOCK);\r\nwritel_relaxed(0, wdt->base + WDTCONTROL);\r\nwritel_relaxed(LOCK, wdt->base + WDTLOCK);\r\nreadl_relaxed(wdt->base + WDTLOCK);\r\nspin_unlock(&wdt->lock);\r\nclk_disable(wdt->clk);\r\nclk_unprepare(wdt->clk);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nsp805_wdt_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nstruct sp805_wdt *wdt;\r\nint ret = 0;\r\nif (!devm_request_mem_region(&adev->dev, adev->res.start,\r\nresource_size(&adev->res), "sp805_wdt")) {\r\ndev_warn(&adev->dev, "Failed to get memory region resource\n");\r\nret = -ENOENT;\r\ngoto err;\r\n}\r\nwdt = devm_kzalloc(&adev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt) {\r\ndev_warn(&adev->dev, "Kzalloc failed\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nwdt->base = devm_ioremap(&adev->dev, adev->res.start,\r\nresource_size(&adev->res));\r\nif (!wdt->base) {\r\nret = -ENOMEM;\r\ndev_warn(&adev->dev, "ioremap fail\n");\r\ngoto err;\r\n}\r\nwdt->clk = clk_get(&adev->dev, NULL);\r\nif (IS_ERR(wdt->clk)) {\r\ndev_warn(&adev->dev, "Clock not found\n");\r\nret = PTR_ERR(wdt->clk);\r\ngoto err;\r\n}\r\nwdt->adev = adev;\r\nwdt->wdd.info = &wdt_info;\r\nwdt->wdd.ops = &wdt_ops;\r\nspin_lock_init(&wdt->lock);\r\nwatchdog_set_nowayout(&wdt->wdd, nowayout);\r\nwatchdog_set_drvdata(&wdt->wdd, wdt);\r\nwdt_setload(&wdt->wdd, DEFAULT_TIMEOUT);\r\nret = watchdog_register_device(&wdt->wdd);\r\nif (ret) {\r\ndev_err(&adev->dev, "watchdog_register_device() failed: %d\n",\r\nret);\r\ngoto err_register;\r\n}\r\namba_set_drvdata(adev, wdt);\r\ndev_info(&adev->dev, "registration successful\n");\r\nreturn 0;\r\nerr_register:\r\nclk_put(wdt->clk);\r\nerr:\r\ndev_err(&adev->dev, "Probe Failed!!!\n");\r\nreturn ret;\r\n}\r\nstatic int __devexit sp805_wdt_remove(struct amba_device *adev)\r\n{\r\nstruct sp805_wdt *wdt = amba_get_drvdata(adev);\r\nwatchdog_unregister_device(&wdt->wdd);\r\namba_set_drvdata(adev, NULL);\r\nwatchdog_set_drvdata(&wdt->wdd, NULL);\r\nclk_put(wdt->clk);\r\nreturn 0;\r\n}\r\nstatic int sp805_wdt_suspend(struct device *dev)\r\n{\r\nstruct sp805_wdt *wdt = dev_get_drvdata(dev);\r\nif (watchdog_active(&wdt->wdd))\r\nreturn wdt_disable(&wdt->wdd);\r\nreturn 0;\r\n}\r\nstatic int sp805_wdt_resume(struct device *dev)\r\n{\r\nstruct sp805_wdt *wdt = dev_get_drvdata(dev);\r\nif (watchdog_active(&wdt->wdd))\r\nreturn wdt_enable(&wdt->wdd);\r\nreturn 0;\r\n}
