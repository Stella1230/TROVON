static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)\r\n{\r\nunsigned long tmp;\r\nspin_lock(&scu_lock);\r\ntmp = readl(scu_base + 8);\r\ntmp &= ~clr;\r\ntmp |= set;\r\nwritel(tmp, scu_base + 8);\r\nspin_unlock(&scu_lock);\r\n}\r\nunsigned int __init emev2_get_core_count(void)\r\n{\r\nif (!scu_base) {\r\nscu_base = ioremap(EMEV2_SCU_BASE, PAGE_SIZE);\r\nemev2_clock_init();\r\n}\r\nWARN_ON_ONCE(!scu_base);\r\nreturn scu_base ? scu_get_core_count(scu_base) : 1;\r\n}\r\nint emev2_platform_cpu_kill(unsigned int cpu)\r\n{\r\nreturn 0;\r\n}\r\nvoid __cpuinit emev2_secondary_init(unsigned int cpu)\r\n{\r\ngic_secondary_init(0);\r\n}\r\nint __cpuinit emev2_boot_secondary(unsigned int cpu)\r\n{\r\ncpu = cpu_logical_map(cpu);\r\nmodify_scu_cpu_psr(0, 3 << (cpu * 8));\r\nemev2_set_boot_vector(__pa(shmobile_secondary_vector));\r\ngic_raise_softirq(cpumask_of(cpu), 1);\r\nreturn 0;\r\n}\r\nvoid __init emev2_smp_prepare_cpus(void)\r\n{\r\nint cpu = cpu_logical_map(0);\r\nscu_enable(scu_base);\r\nmodify_scu_cpu_psr(0, 3 << (cpu * 8));\r\n}
