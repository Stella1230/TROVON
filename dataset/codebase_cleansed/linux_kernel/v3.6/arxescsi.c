static fasdmatype_t\r\narxescsi_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,\r\nfasdmadir_t direction, fasdmatype_t min_type)\r\n{\r\nreturn fasdma_pseudo;\r\n}\r\nstatic void arxescsi_pseudo_dma_write(unsigned char *addr, void __iomem *base)\r\n{\r\n__asm__ __volatile__(\r\n" stmdb sp!, {r0-r12}\n"\r\n" mov r3, %0\n"\r\n" mov r1, %1\n"\r\n" add r2, r1, #512\n"\r\n" mov r4, #256\n"\r\n".loop_1: ldmia r3!, {r6, r8, r10, r12}\n"\r\n" mov r5, r6, lsl #16\n"\r\n" mov r7, r8, lsl #16\n"\r\n".loop_2: ldrb r0, [r1, #1536]\n"\r\n" tst r0, #1\n"\r\n" beq .loop_2\n"\r\n" stmia r2, {r5-r8}\n\t"\r\n" mov r9, r10, lsl #16\n"\r\n" mov r11, r12, lsl #16\n"\r\n".loop_3: ldrb r0, [r1, #1536]\n"\r\n" tst r0, #1\n"\r\n" beq .loop_3\n"\r\n" stmia r2, {r9-r12}\n"\r\n" subs r4, r4, #16\n"\r\n" bne .loop_1\n"\r\n" ldmia sp!, {r0-r12}\n"\r\n:\r\n: "r" (addr), "r" (base));\r\n}\r\nstatic void\r\narxescsi_dma_pseudo(struct Scsi_Host *host, struct scsi_pointer *SCp,\r\nfasdmadir_t direction, int transfer)\r\n{\r\nstruct arxescsi_info *info = (struct arxescsi_info *)host->hostdata;\r\nunsigned int length, error = 0;\r\nvoid __iomem *base = info->info.scsi.io_base;\r\nunsigned char *addr;\r\nlength = SCp->this_residual;\r\naddr = SCp->ptr;\r\nif (direction == DMA_OUT) {\r\nunsigned int word;\r\nwhile (length > 256) {\r\nif (readb(base + 0x80) & STAT_INT) {\r\nerror = 1;\r\nbreak;\r\n}\r\narxescsi_pseudo_dma_write(addr, base);\r\naddr += 256;\r\nlength -= 256;\r\n}\r\nif (!error)\r\nwhile (length > 0) {\r\nif (readb(base + 0x80) & STAT_INT)\r\nbreak;\r\nif (!(readb(base + DMASTAT_OFFSET) & DMASTAT_DRQ))\r\ncontinue;\r\nword = *addr | *(addr + 1) << 8;\r\nwritew(word, base + DMADATA_OFFSET);\r\nif (length > 1) {\r\naddr += 2;\r\nlength -= 2;\r\n} else {\r\naddr += 1;\r\nlength -= 1;\r\n}\r\n}\r\n}\r\nelse {\r\nif (transfer && (transfer & 255)) {\r\nwhile (length >= 256) {\r\nif (readb(base + 0x80) & STAT_INT) {\r\nerror = 1;\r\nbreak;\r\n}\r\nif (!(readb(base + DMASTAT_OFFSET) & DMASTAT_DRQ))\r\ncontinue;\r\nreadsw(base + DMADATA_OFFSET, addr, 256 >> 1);\r\naddr += 256;\r\nlength -= 256;\r\n}\r\n}\r\nif (!(error))\r\nwhile (length > 0) {\r\nunsigned long word;\r\nif (readb(base + 0x80) & STAT_INT)\r\nbreak;\r\nif (!(readb(base + DMASTAT_OFFSET) & DMASTAT_DRQ))\r\ncontinue;\r\nword = readw(base + DMADATA_OFFSET);\r\n*addr++ = word;\r\nif (--length > 0) {\r\n*addr++ = word >> 8;\r\nlength --;\r\n}\r\n}\r\n}\r\n}\r\nstatic void arxescsi_dma_stop(struct Scsi_Host *host, struct scsi_pointer *SCp)\r\n{\r\n}\r\nstatic const char *arxescsi_info(struct Scsi_Host *host)\r\n{\r\nstruct arxescsi_info *info = (struct arxescsi_info *)host->hostdata;\r\nstatic char string[150];\r\nsprintf(string, "%s (%s) in slot %d v%s",\r\nhost->hostt->name, info->info.scsi.type, info->ec->slot_no,\r\nVERSION);\r\nreturn string;\r\n}\r\nstatic int\r\narxescsi_proc_info(struct Scsi_Host *host, char *buffer, char **start, off_t offset, int length,\r\nint inout)\r\n{\r\nstruct arxescsi_info *info;\r\nchar *p = buffer;\r\nint pos;\r\ninfo = (struct arxescsi_info *)host->hostdata;\r\nif (inout == 1)\r\nreturn -EINVAL;\r\np += sprintf(p, "ARXE 16-bit SCSI driver v%s\n", VERSION);\r\np += fas216_print_host(&info->info, p);\r\np += fas216_print_stats(&info->info, p);\r\np += fas216_print_devices(&info->info, p);\r\n*start = buffer + offset;\r\npos = p - buffer - offset;\r\nif (pos > length)\r\npos = length;\r\nreturn pos;\r\n}\r\nstatic int __devinit\r\narxescsi_probe(struct expansion_card *ec, const struct ecard_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct arxescsi_info *info;\r\nvoid __iomem *base;\r\nint ret;\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\nbase = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\r\nif (!base) {\r\nret = -ENOMEM;\r\ngoto out_region;\r\n}\r\nhost = scsi_host_alloc(&arxescsi_template, sizeof(struct arxescsi_info));\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto out_region;\r\n}\r\ninfo = (struct arxescsi_info *)host->hostdata;\r\ninfo->ec = ec;\r\ninfo->base = base;\r\ninfo->info.scsi.io_base = base + 0x2000;\r\ninfo->info.scsi.irq = 0;\r\ninfo->info.scsi.dma = NO_DMA;\r\ninfo->info.scsi.io_shift = 5;\r\ninfo->info.ifcfg.clockrate = 24;\r\ninfo->info.ifcfg.select_timeout = 255;\r\ninfo->info.ifcfg.asyncperiod = 200;\r\ninfo->info.ifcfg.sync_max_depth = 0;\r\ninfo->info.ifcfg.cntl3 = CNTL3_FASTSCSI | CNTL3_FASTCLK;\r\ninfo->info.ifcfg.disconnect_ok = 0;\r\ninfo->info.ifcfg.wide_max_size = 0;\r\ninfo->info.ifcfg.capabilities = FASCAP_PSEUDODMA;\r\ninfo->info.dma.setup = arxescsi_dma_setup;\r\ninfo->info.dma.pseudo = arxescsi_dma_pseudo;\r\ninfo->info.dma.stop = arxescsi_dma_stop;\r\nec->irqaddr = base;\r\nec->irqmask = CSTATUS_IRQ;\r\nret = fas216_init(host);\r\nif (ret)\r\ngoto out_unregister;\r\nret = fas216_add(host, &ec->dev);\r\nif (ret == 0)\r\ngoto out;\r\nfas216_release(host);\r\nout_unregister:\r\nscsi_host_put(host);\r\nout_region:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __devexit arxescsi_remove(struct expansion_card *ec)\r\n{\r\nstruct Scsi_Host *host = ecard_get_drvdata(ec);\r\necard_set_drvdata(ec, NULL);\r\nfas216_remove(host);\r\nfas216_release(host);\r\nscsi_host_put(host);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init init_arxe_scsi_driver(void)\r\n{\r\nreturn ecard_register_driver(&arxescsi_driver);\r\n}\r\nstatic void __exit exit_arxe_scsi_driver(void)\r\n{\r\necard_remove_driver(&arxescsi_driver);\r\n}
