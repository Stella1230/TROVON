void\r\nNVWriteVgaSeq(struct drm_device *dev, int head, uint8_t index, uint8_t value)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_SRX, index);\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_SR, value);\r\n}\r\nuint8_t\r\nNVReadVgaSeq(struct drm_device *dev, int head, uint8_t index)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_SRX, index);\r\nreturn NVReadPRMVIO(dev, head, NV_PRMVIO_SR);\r\n}\r\nvoid\r\nNVWriteVgaGr(struct drm_device *dev, int head, uint8_t index, uint8_t value)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_GRX, index);\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_GX, value);\r\n}\r\nuint8_t\r\nNVReadVgaGr(struct drm_device *dev, int head, uint8_t index)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_GRX, index);\r\nreturn NVReadPRMVIO(dev, head, NV_PRMVIO_GX);\r\n}\r\nvoid\r\nNVSetOwner(struct drm_device *dev, int owner)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (owner == 1)\r\nowner *= 3;\r\nif (dev_priv->chipset == 0x11) {\r\nNVReadVgaCrtc(dev, 0, NV_CIO_SR_LOCK_INDEX);\r\nNVReadVgaCrtc(dev, 1, NV_CIO_SR_LOCK_INDEX);\r\n}\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_44, owner);\r\nif (dev_priv->chipset == 0x11) {\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_2E, owner);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_2E, owner);\r\n}\r\n}\r\nvoid\r\nNVBlankScreen(struct drm_device *dev, int head, bool blank)\r\n{\r\nunsigned char seq1;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, head);\r\nseq1 = NVReadVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX);\r\nNVVgaSeqReset(dev, head, true);\r\nif (blank)\r\nNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 | 0x20);\r\nelse\r\nNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 & ~0x20);\r\nNVVgaSeqReset(dev, head, false);\r\n}\r\nstatic int\r\npowerctrl_1_shift(int chip_version, int reg)\r\n{\r\nint shift = -4;\r\nif (chip_version < 0x17 || chip_version == 0x1a || chip_version == 0x20)\r\nreturn shift;\r\nswitch (reg) {\r\ncase NV_RAMDAC_VPLL2:\r\nshift += 4;\r\ncase NV_PRAMDAC_VPLL_COEFF:\r\nshift += 4;\r\ncase NV_PRAMDAC_MPLL_COEFF:\r\nshift += 4;\r\ncase NV_PRAMDAC_NVPLL_COEFF:\r\nshift += 4;\r\n}\r\nif (shift > 4 && (chip_version < 0x32 || chip_version == 0x35 ||\r\nchip_version == 0x36 || chip_version >= 0x40))\r\nshift = -4;\r\nreturn shift;\r\n}\r\nstatic void\r\nsetPLL_single(struct drm_device *dev, uint32_t reg, struct nouveau_pll_vals *pv)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint chip_version = dev_priv->vbios.chip_version;\r\nuint32_t oldpll = NVReadRAMDAC(dev, 0, reg);\r\nint oldN = (oldpll >> 8) & 0xff, oldM = oldpll & 0xff;\r\nuint32_t pll = (oldpll & 0xfff80000) | pv->log2P << 16 | pv->NM1;\r\nuint32_t saved_powerctrl_1 = 0;\r\nint shift_powerctrl_1 = powerctrl_1_shift(chip_version, reg);\r\nif (oldpll == pll)\r\nreturn;\r\nif (shift_powerctrl_1 >= 0) {\r\nsaved_powerctrl_1 = nvReadMC(dev, NV_PBUS_POWERCTRL_1);\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_1,\r\n(saved_powerctrl_1 & ~(0xf << shift_powerctrl_1)) |\r\n1 << shift_powerctrl_1);\r\n}\r\nif (oldM && pv->M1 && (oldN / oldM < pv->N1 / pv->M1))\r\nNVWriteRAMDAC(dev, 0, reg, pv->log2P << 16 | (oldpll & 0xffff));\r\nelse\r\nNVWriteRAMDAC(dev, 0, reg, (oldpll & 0xffff0000) | pv->NM1);\r\nif (chip_version < 0x17 && chip_version != 0x11)\r\nmsleep(64);\r\nNVReadRAMDAC(dev, 0, reg);\r\nNVWriteRAMDAC(dev, 0, reg, pll);\r\nif (shift_powerctrl_1 >= 0)\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_1, saved_powerctrl_1);\r\n}\r\nstatic uint32_t\r\nnew_ramdac580(uint32_t reg1, bool ss, uint32_t ramdac580)\r\n{\r\nbool head_a = (reg1 == NV_PRAMDAC_VPLL_COEFF);\r\nif (ss)\r\nramdac580 |= head_a ? NV_RAMDAC_580_VPLL1_ACTIVE :\r\nNV_RAMDAC_580_VPLL2_ACTIVE;\r\nelse\r\nramdac580 &= head_a ? ~NV_RAMDAC_580_VPLL1_ACTIVE :\r\n~NV_RAMDAC_580_VPLL2_ACTIVE;\r\nreturn ramdac580;\r\n}\r\nstatic void\r\nsetPLL_double_highregs(struct drm_device *dev, uint32_t reg1,\r\nstruct nouveau_pll_vals *pv)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint chip_version = dev_priv->vbios.chip_version;\r\nbool nv3035 = chip_version == 0x30 || chip_version == 0x35;\r\nuint32_t reg2 = reg1 + ((reg1 == NV_RAMDAC_VPLL2) ? 0x5c : 0x70);\r\nuint32_t oldpll1 = NVReadRAMDAC(dev, 0, reg1);\r\nuint32_t oldpll2 = !nv3035 ? NVReadRAMDAC(dev, 0, reg2) : 0;\r\nuint32_t pll1 = (oldpll1 & 0xfff80000) | pv->log2P << 16 | pv->NM1;\r\nuint32_t pll2 = (oldpll2 & 0x7fff0000) | 1 << 31 | pv->NM2;\r\nuint32_t oldramdac580 = 0, ramdac580 = 0;\r\nbool single_stage = !pv->NM2 || pv->N2 == pv->M2;\r\nuint32_t saved_powerctrl_1 = 0, savedc040 = 0;\r\nint shift_powerctrl_1 = powerctrl_1_shift(chip_version, reg1);\r\nif (nv3035) {\r\npll1 = (pll1 & 0xfcc7ffff) | (pv->N2 & 0x18) << 21 |\r\n(pv->N2 & 0x7) << 19 | 8 << 4 | (pv->M2 & 7) << 4;\r\npll2 = 0;\r\n}\r\nif (chip_version > 0x40 && reg1 >= NV_PRAMDAC_VPLL_COEFF) {\r\noldramdac580 = NVReadRAMDAC(dev, 0, NV_PRAMDAC_580);\r\nramdac580 = new_ramdac580(reg1, single_stage, oldramdac580);\r\nif (oldramdac580 != ramdac580)\r\noldpll1 = ~0;\r\nif (single_stage)\r\npll2 |= 0x011f;\r\n}\r\nif (chip_version > 0x70)\r\npll1 = (pll1 & 0x7fffffff) | (single_stage ? 0x4 : 0xc) << 28;\r\nif (oldpll1 == pll1 && oldpll2 == pll2)\r\nreturn;\r\nif (shift_powerctrl_1 >= 0) {\r\nsaved_powerctrl_1 = nvReadMC(dev, NV_PBUS_POWERCTRL_1);\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_1,\r\n(saved_powerctrl_1 & ~(0xf << shift_powerctrl_1)) |\r\n1 << shift_powerctrl_1);\r\n}\r\nif (chip_version >= 0x40) {\r\nint shift_c040 = 14;\r\nswitch (reg1) {\r\ncase NV_PRAMDAC_MPLL_COEFF:\r\nshift_c040 += 2;\r\ncase NV_PRAMDAC_NVPLL_COEFF:\r\nshift_c040 += 2;\r\ncase NV_RAMDAC_VPLL2:\r\nshift_c040 += 2;\r\ncase NV_PRAMDAC_VPLL_COEFF:\r\nshift_c040 += 2;\r\n}\r\nsavedc040 = nvReadMC(dev, 0xc040);\r\nif (shift_c040 != 14)\r\nnvWriteMC(dev, 0xc040, savedc040 & ~(3 << shift_c040));\r\n}\r\nif (oldramdac580 != ramdac580)\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_580, ramdac580);\r\nif (!nv3035)\r\nNVWriteRAMDAC(dev, 0, reg2, pll2);\r\nNVWriteRAMDAC(dev, 0, reg1, pll1);\r\nif (shift_powerctrl_1 >= 0)\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_1, saved_powerctrl_1);\r\nif (chip_version >= 0x40)\r\nnvWriteMC(dev, 0xc040, savedc040);\r\n}\r\nstatic void\r\nsetPLL_double_lowregs(struct drm_device *dev, uint32_t NMNMreg,\r\nstruct nouveau_pll_vals *pv)\r\n{\r\nuint32_t Preg = NMNMreg - 4;\r\nbool mpll = Preg == 0x4020;\r\nuint32_t oldPval = nvReadMC(dev, Preg);\r\nuint32_t NMNM = pv->NM2 << 16 | pv->NM1;\r\nuint32_t Pval = (oldPval & (mpll ? ~(0x77 << 16) : ~(7 << 16))) |\r\n0xc << 28 | pv->log2P << 16;\r\nuint32_t saved4600 = 0;\r\nuint32_t maskc040 = ~(3 << 14), savedc040;\r\nbool single_stage = !pv->NM2 || pv->N2 == pv->M2;\r\nif (nvReadMC(dev, NMNMreg) == NMNM && (oldPval & 0xc0070000) == Pval)\r\nreturn;\r\nif (Preg == 0x4000)\r\nmaskc040 = ~0x333;\r\nif (Preg == 0x4058)\r\nmaskc040 = ~(0xc << 24);\r\nif (mpll) {\r\nstruct pll_lims pll_lim;\r\nuint8_t Pval2;\r\nif (get_pll_limits(dev, Preg, &pll_lim))\r\nreturn;\r\nPval2 = pv->log2P + pll_lim.log2p_bias;\r\nif (Pval2 > pll_lim.max_log2p)\r\nPval2 = pll_lim.max_log2p;\r\nPval |= 1 << 28 | Pval2 << 20;\r\nsaved4600 = nvReadMC(dev, 0x4600);\r\nnvWriteMC(dev, 0x4600, saved4600 | 8 << 28);\r\n}\r\nif (single_stage)\r\nPval |= mpll ? 1 << 12 : 1 << 8;\r\nnvWriteMC(dev, Preg, oldPval | 1 << 28);\r\nnvWriteMC(dev, Preg, Pval & ~(4 << 28));\r\nif (mpll) {\r\nPval |= 8 << 20;\r\nnvWriteMC(dev, 0x4020, Pval & ~(0xc << 28));\r\nnvWriteMC(dev, 0x4038, Pval & ~(0xc << 28));\r\n}\r\nsavedc040 = nvReadMC(dev, 0xc040);\r\nnvWriteMC(dev, 0xc040, savedc040 & maskc040);\r\nnvWriteMC(dev, NMNMreg, NMNM);\r\nif (NMNMreg == 0x4024)\r\nnvWriteMC(dev, 0x403c, NMNM);\r\nnvWriteMC(dev, Preg, Pval);\r\nif (mpll) {\r\nPval &= ~(8 << 20);\r\nnvWriteMC(dev, 0x4020, Pval);\r\nnvWriteMC(dev, 0x4038, Pval);\r\nnvWriteMC(dev, 0x4600, saved4600);\r\n}\r\nnvWriteMC(dev, 0xc040, savedc040);\r\nif (mpll) {\r\nnvWriteMC(dev, 0x4020, Pval & ~(1 << 28));\r\nnvWriteMC(dev, 0x4038, Pval & ~(1 << 28));\r\n}\r\n}\r\nvoid\r\nnouveau_hw_setpll(struct drm_device *dev, uint32_t reg1,\r\nstruct nouveau_pll_vals *pv)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint cv = dev_priv->vbios.chip_version;\r\nif (cv == 0x30 || cv == 0x31 || cv == 0x35 || cv == 0x36 ||\r\ncv >= 0x40) {\r\nif (reg1 > 0x405c)\r\nsetPLL_double_highregs(dev, reg1, pv);\r\nelse\r\nsetPLL_double_lowregs(dev, reg1, pv);\r\n} else\r\nsetPLL_single(dev, reg1, pv);\r\n}\r\nstatic void\r\nnouveau_hw_decode_pll(struct drm_device *dev, uint32_t reg1, uint32_t pll1,\r\nuint32_t pll2, struct nouveau_pll_vals *pllvals)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\npllvals->log2P = (pll1 >> 16) & 0x7;\r\npllvals->N2 = pllvals->M2 = 1;\r\nif (reg1 <= 0x405c) {\r\npllvals->NM1 = pll2 & 0xffff;\r\nif (!(pll1 & 0x1100))\r\npllvals->NM2 = pll2 >> 16;\r\n} else {\r\npllvals->NM1 = pll1 & 0xffff;\r\nif (nv_two_reg_pll(dev) && pll2 & NV31_RAMDAC_ENABLE_VCO2)\r\npllvals->NM2 = pll2 & 0xffff;\r\nelse if (dev_priv->chipset == 0x30 || dev_priv->chipset == 0x35) {\r\npllvals->M1 &= 0xf;\r\nif (pll1 & NV30_RAMDAC_ENABLE_VCO2) {\r\npllvals->M2 = (pll1 >> 4) & 0x7;\r\npllvals->N2 = ((pll1 >> 21) & 0x18) |\r\n((pll1 >> 19) & 0x7);\r\n}\r\n}\r\n}\r\n}\r\nint\r\nnouveau_hw_get_pllvals(struct drm_device *dev, enum pll_types plltype,\r\nstruct nouveau_pll_vals *pllvals)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nuint32_t reg1 = get_pll_register(dev, plltype), pll1, pll2 = 0;\r\nstruct pll_lims pll_lim;\r\nint ret;\r\nif (reg1 == 0)\r\nreturn -ENOENT;\r\npll1 = nvReadMC(dev, reg1);\r\nif (reg1 <= 0x405c)\r\npll2 = nvReadMC(dev, reg1 + 4);\r\nelse if (nv_two_reg_pll(dev)) {\r\nuint32_t reg2 = reg1 + (reg1 == NV_RAMDAC_VPLL2 ? 0x5c : 0x70);\r\npll2 = nvReadMC(dev, reg2);\r\n}\r\nif (dev_priv->card_type == 0x40 && reg1 >= NV_PRAMDAC_VPLL_COEFF) {\r\nuint32_t ramdac580 = NVReadRAMDAC(dev, 0, NV_PRAMDAC_580);\r\nif (reg1 == NV_PRAMDAC_VPLL_COEFF) {\r\nif (ramdac580 & NV_RAMDAC_580_VPLL1_ACTIVE)\r\npll2 = 0;\r\n} else\r\nif (ramdac580 & NV_RAMDAC_580_VPLL2_ACTIVE)\r\npll2 = 0;\r\n}\r\nnouveau_hw_decode_pll(dev, reg1, pll1, pll2, pllvals);\r\nret = get_pll_limits(dev, plltype, &pll_lim);\r\nif (ret)\r\nreturn ret;\r\npllvals->refclk = pll_lim.refclk;\r\nreturn 0;\r\n}\r\nint\r\nnouveau_hw_pllvals_to_clk(struct nouveau_pll_vals *pv)\r\n{\r\nif (!pv->M1 || !pv->M2)\r\nreturn 0;\r\nreturn pv->N1 * pv->N2 * pv->refclk / (pv->M1 * pv->M2) >> pv->log2P;\r\n}\r\nint\r\nnouveau_hw_get_clock(struct drm_device *dev, enum pll_types plltype)\r\n{\r\nstruct nouveau_pll_vals pllvals;\r\nint ret;\r\nif (plltype == PLL_MEMORY &&\r\n(dev->pci_device & 0x0ff0) == CHIPSET_NFORCE) {\r\nuint32_t mpllP;\r\npci_read_config_dword(pci_get_bus_and_slot(0, 3), 0x6c, &mpllP);\r\nif (!mpllP)\r\nmpllP = 4;\r\nreturn 400000 / mpllP;\r\n} else\r\nif (plltype == PLL_MEMORY &&\r\n(dev->pci_device & 0xff0) == CHIPSET_NFORCE2) {\r\nuint32_t clock;\r\npci_read_config_dword(pci_get_bus_and_slot(0, 5), 0x4c, &clock);\r\nreturn clock;\r\n}\r\nret = nouveau_hw_get_pllvals(dev, plltype, &pllvals);\r\nif (ret)\r\nreturn ret;\r\nreturn nouveau_hw_pllvals_to_clk(&pllvals);\r\n}\r\nstatic void\r\nnouveau_hw_fix_bad_vpll(struct drm_device *dev, int head)\r\n{\r\nstruct pll_lims pll_lim;\r\nstruct nouveau_pll_vals pv;\r\nenum pll_types pll = head ? PLL_VPLL1 : PLL_VPLL0;\r\nif (get_pll_limits(dev, pll, &pll_lim))\r\nreturn;\r\nnouveau_hw_get_pllvals(dev, pll, &pv);\r\nif (pv.M1 >= pll_lim.vco1.min_m && pv.M1 <= pll_lim.vco1.max_m &&\r\npv.N1 >= pll_lim.vco1.min_n && pv.N1 <= pll_lim.vco1.max_n &&\r\npv.log2P <= pll_lim.max_log2p)\r\nreturn;\r\nNV_WARN(dev, "VPLL %d outwith limits, attempting to fix\n", head + 1);\r\npv.M1 = pll_lim.vco1.max_m;\r\npv.N1 = pll_lim.vco1.min_n;\r\npv.log2P = pll_lim.max_usable_log2p;\r\nnouveau_hw_setpll(dev, pll_lim.reg, &pv);\r\n}\r\nstatic void nouveau_vga_font_io(struct drm_device *dev,\r\nvoid __iomem *iovram,\r\nbool save, unsigned plane)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nunsigned i;\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX, 1 << plane);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX, plane);\r\nfor (i = 0; i < 16384; i++) {\r\nif (save) {\r\ndev_priv->saved_vga_font[plane][i] =\r\nioread32_native(iovram + i * 4);\r\n} else {\r\niowrite32_native(dev_priv->saved_vga_font[plane][i],\r\niovram + i * 4);\r\n}\r\n}\r\n}\r\nvoid\r\nnouveau_hw_save_vga_fonts(struct drm_device *dev, bool save)\r\n{\r\nuint8_t misc, gr4, gr5, gr6, seq2, seq4;\r\nbool graphicsmode;\r\nunsigned plane;\r\nvoid __iomem *iovram;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, 0);\r\nNVSetEnablePalette(dev, 0, true);\r\ngraphicsmode = NVReadVgaAttr(dev, 0, NV_CIO_AR_MODE_INDEX) & 1;\r\nNVSetEnablePalette(dev, 0, false);\r\nif (graphicsmode)\r\nreturn;\r\nNV_INFO(dev, "%sing VGA fonts\n", save ? "Sav" : "Restor");\r\niovram = ioremap(pci_resource_start(dev->pdev, 1), 65536);\r\nif (!iovram) {\r\nNV_ERROR(dev, "Failed to map VRAM, "\r\n"cannot save/restore VGA fonts.\n");\r\nreturn;\r\n}\r\nif (nv_two_heads(dev))\r\nNVBlankScreen(dev, 1, true);\r\nNVBlankScreen(dev, 0, true);\r\nmisc = NVReadPRMVIO(dev, 0, NV_PRMVIO_MISC__READ);\r\nseq2 = NVReadVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX);\r\nseq4 = NVReadVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX);\r\ngr4 = NVReadVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX);\r\ngr5 = NVReadVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX);\r\ngr6 = NVReadVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX);\r\nNVWritePRMVIO(dev, 0, NV_PRMVIO_MISC__WRITE, 0x67);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX, 0x6);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX, 0x0);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX, 0x5);\r\nfor (plane = 0; plane < 4; plane++)\r\nnouveau_vga_font_io(dev, iovram, save, plane);\r\nNVWritePRMVIO(dev, 0, NV_PRMVIO_MISC__WRITE, misc);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX, gr4);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX, gr5);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX, gr6);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX, seq2);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX, seq4);\r\nif (nv_two_heads(dev))\r\nNVBlankScreen(dev, 1, false);\r\nNVBlankScreen(dev, 0, false);\r\niounmap(iovram);\r\n}\r\nstatic void\r\nrd_cio_state(struct drm_device *dev, int head,\r\nstruct nv04_crtc_reg *crtcstate, int index)\r\n{\r\ncrtcstate->CRTC[index] = NVReadVgaCrtc(dev, head, index);\r\n}\r\nstatic void\r\nwr_cio_state(struct drm_device *dev, int head,\r\nstruct nv04_crtc_reg *crtcstate, int index)\r\n{\r\nNVWriteVgaCrtc(dev, head, index, crtcstate->CRTC[index]);\r\n}\r\nstatic void\r\nnv_save_state_ramdac(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nif (dev_priv->card_type >= NV_10)\r\nregp->nv10_cursync = NVReadRAMDAC(dev, head, NV_RAMDAC_NV10_CURSYNC);\r\nnouveau_hw_get_pllvals(dev, head ? PLL_VPLL1 : PLL_VPLL0, &regp->pllvals);\r\nstate->pllsel = NVReadRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT);\r\nif (nv_two_heads(dev))\r\nstate->sel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK);\r\nif (dev_priv->chipset == 0x11)\r\nregp->dither = NVReadRAMDAC(dev, head, NV_RAMDAC_DITHER_NV11);\r\nregp->ramdac_gen_ctrl = NVReadRAMDAC(dev, head, NV_PRAMDAC_GENERAL_CONTROL);\r\nif (nv_gf4_disp_arch(dev))\r\nregp->ramdac_630 = NVReadRAMDAC(dev, head, NV_PRAMDAC_630);\r\nif (dev_priv->chipset >= 0x30)\r\nregp->ramdac_634 = NVReadRAMDAC(dev, head, NV_PRAMDAC_634);\r\nregp->tv_setup = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP);\r\nregp->tv_vtotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VTOTAL);\r\nregp->tv_vskew = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VSKEW);\r\nregp->tv_vsync_delay = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VSYNC_DELAY);\r\nregp->tv_htotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HTOTAL);\r\nregp->tv_hskew = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSKEW);\r\nregp->tv_hsync_delay = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY);\r\nregp->tv_hsync_delay2 = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY2);\r\nfor (i = 0; i < 7; i++) {\r\nuint32_t ramdac_reg = NV_PRAMDAC_FP_VDISPLAY_END + (i * 4);\r\nregp->fp_vert_regs[i] = NVReadRAMDAC(dev, head, ramdac_reg);\r\nregp->fp_horiz_regs[i] = NVReadRAMDAC(dev, head, ramdac_reg + 0x20);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nregp->dither = NVReadRAMDAC(dev, head, NV_RAMDAC_FP_DITHER);\r\nfor (i = 0; i < 3; i++) {\r\nregp->dither_regs[i] = NVReadRAMDAC(dev, head, NV_PRAMDAC_850 + i * 4);\r\nregp->dither_regs[i + 3] = NVReadRAMDAC(dev, head, NV_PRAMDAC_85C + i * 4);\r\n}\r\n}\r\nregp->fp_control = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL);\r\nregp->fp_debug_0 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_0);\r\nif (!nv_gf4_disp_arch(dev) && head == 0) {\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_FP_DEBUG_0, regp->fp_debug_0 &\r\n~NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);\r\n}\r\nregp->fp_debug_1 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_1);\r\nregp->fp_debug_2 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_2);\r\nregp->fp_margin_color = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_MARGIN_COLOR);\r\nif (nv_gf4_disp_arch(dev))\r\nregp->ramdac_8c0 = NVReadRAMDAC(dev, head, NV_PRAMDAC_8C0);\r\nif (dev_priv->card_type == NV_40) {\r\nregp->ramdac_a20 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A20);\r\nregp->ramdac_a24 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A24);\r\nregp->ramdac_a34 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A34);\r\nfor (i = 0; i < 38; i++)\r\nregp->ctv_regs[i] = NVReadRAMDAC(dev, head,\r\nNV_PRAMDAC_CTV + 4*i);\r\n}\r\n}\r\nstatic void\r\nnv_load_state_ramdac(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nuint32_t pllreg = head ? NV_RAMDAC_VPLL2 : NV_PRAMDAC_VPLL_COEFF;\r\nint i;\r\nif (dev_priv->card_type >= NV_10)\r\nNVWriteRAMDAC(dev, head, NV_RAMDAC_NV10_CURSYNC, regp->nv10_cursync);\r\nnouveau_hw_setpll(dev, pllreg, &regp->pllvals);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT, state->pllsel);\r\nif (nv_two_heads(dev))\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, state->sel_clk);\r\nif (dev_priv->chipset == 0x11)\r\nNVWriteRAMDAC(dev, head, NV_RAMDAC_DITHER_NV11, regp->dither);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_GENERAL_CONTROL, regp->ramdac_gen_ctrl);\r\nif (nv_gf4_disp_arch(dev))\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_630, regp->ramdac_630);\r\nif (dev_priv->chipset >= 0x30)\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_634, regp->ramdac_634);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP, regp->tv_setup);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VTOTAL, regp->tv_vtotal);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VSKEW, regp->tv_vskew);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VSYNC_DELAY, regp->tv_vsync_delay);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HTOTAL, regp->tv_htotal);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSKEW, regp->tv_hskew);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY, regp->tv_hsync_delay);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY2, regp->tv_hsync_delay2);\r\nfor (i = 0; i < 7; i++) {\r\nuint32_t ramdac_reg = NV_PRAMDAC_FP_VDISPLAY_END + (i * 4);\r\nNVWriteRAMDAC(dev, head, ramdac_reg, regp->fp_vert_regs[i]);\r\nNVWriteRAMDAC(dev, head, ramdac_reg + 0x20, regp->fp_horiz_regs[i]);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nNVWriteRAMDAC(dev, head, NV_RAMDAC_FP_DITHER, regp->dither);\r\nfor (i = 0; i < 3; i++) {\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_850 + i * 4, regp->dither_regs[i]);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_85C + i * 4, regp->dither_regs[i + 3]);\r\n}\r\n}\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL, regp->fp_control);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_0, regp->fp_debug_0);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_1, regp->fp_debug_1);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_2, regp->fp_debug_2);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_MARGIN_COLOR, regp->fp_margin_color);\r\nif (nv_gf4_disp_arch(dev))\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_8C0, regp->ramdac_8c0);\r\nif (dev_priv->card_type == NV_40) {\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_A20, regp->ramdac_a20);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_A24, regp->ramdac_a24);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_A34, regp->ramdac_a34);\r\nfor (i = 0; i < 38; i++)\r\nNVWriteRAMDAC(dev, head,\r\nNV_PRAMDAC_CTV + 4*i, regp->ctv_regs[i]);\r\n}\r\n}\r\nstatic void\r\nnv_save_state_vga(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nregp->MiscOutReg = NVReadPRMVIO(dev, head, NV_PRMVIO_MISC__READ);\r\nfor (i = 0; i < 25; i++)\r\nrd_cio_state(dev, head, regp, i);\r\nNVSetEnablePalette(dev, head, true);\r\nfor (i = 0; i < 21; i++)\r\nregp->Attribute[i] = NVReadVgaAttr(dev, head, i);\r\nNVSetEnablePalette(dev, head, false);\r\nfor (i = 0; i < 9; i++)\r\nregp->Graphics[i] = NVReadVgaGr(dev, head, i);\r\nfor (i = 0; i < 5; i++)\r\nregp->Sequencer[i] = NVReadVgaSeq(dev, head, i);\r\n}\r\nstatic void\r\nnv_load_state_vga(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_MISC__WRITE, regp->MiscOutReg);\r\nfor (i = 0; i < 5; i++)\r\nNVWriteVgaSeq(dev, head, i, regp->Sequencer[i]);\r\nnv_lock_vga_crtc_base(dev, head, false);\r\nfor (i = 0; i < 25; i++)\r\nwr_cio_state(dev, head, regp, i);\r\nnv_lock_vga_crtc_base(dev, head, true);\r\nfor (i = 0; i < 9; i++)\r\nNVWriteVgaGr(dev, head, i, regp->Graphics[i]);\r\nNVSetEnablePalette(dev, head, true);\r\nfor (i = 0; i < 21; i++)\r\nNVWriteVgaAttr(dev, head, i, regp->Attribute[i]);\r\nNVSetEnablePalette(dev, head, false);\r\n}\r\nstatic void\r\nnv_save_state_ext(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_LCD__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_RPC0_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_RPC1_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_LSR_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_PIXEL_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HEB__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_ENH_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_FF_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_FFLWM__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_21);\r\nif (dev_priv->card_type >= NV_20)\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_47);\r\nif (dev_priv->card_type >= NV_30)\r\nrd_cio_state(dev, head, regp, 0x9f);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_49);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR0_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR1_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR2_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_ILACE__INDEX);\r\nif (dev_priv->card_type >= NV_10) {\r\nregp->crtc_830 = NVReadCRTC(dev, head, NV_PCRTC_830);\r\nregp->crtc_834 = NVReadCRTC(dev, head, NV_PCRTC_834);\r\nif (dev_priv->card_type >= NV_30)\r\nregp->gpio_ext = NVReadCRTC(dev, head, NV_PCRTC_GPIO_EXT);\r\nif (dev_priv->card_type == NV_40)\r\nregp->crtc_850 = NVReadCRTC(dev, head, NV_PCRTC_850);\r\nif (nv_two_heads(dev))\r\nregp->crtc_eng_ctrl = NVReadCRTC(dev, head, NV_PCRTC_ENGINE_CTRL);\r\nregp->cursor_cfg = NVReadCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG);\r\n}\r\nregp->crtc_cfg = NVReadCRTC(dev, head, NV_PCRTC_CONFIG);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH3__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH4__INDEX);\r\nif (dev_priv->card_type >= NV_10) {\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_EBR_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_CSB);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_4B);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_TVOUT_LATENCY);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_42);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_53);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_54);\r\nfor (i = 0; i < 0x10; i++)\r\nregp->CR58[i] = NVReadVgaCrtc5758(dev, head, i);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_59);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_5B);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_85);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_86);\r\n}\r\nregp->fb_start = NVReadCRTC(dev, head, NV_PCRTC_START);\r\n}\r\nstatic void\r\nnv_load_state_ext(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nuint32_t reg900;\r\nint i;\r\nif (dev_priv->card_type >= NV_10) {\r\nif (nv_two_heads(dev))\r\nNVWriteCRTC(dev, head, NV_PCRTC_ENGINE_CTRL, regp->crtc_eng_ctrl);\r\nnvWriteVIDEO(dev, NV_PVIDEO_STOP, 1);\r\nnvWriteVIDEO(dev, NV_PVIDEO_INTR_EN, 0);\r\nnvWriteVIDEO(dev, NV_PVIDEO_OFFSET_BUFF(0), 0);\r\nnvWriteVIDEO(dev, NV_PVIDEO_OFFSET_BUFF(1), 0);\r\nnvWriteVIDEO(dev, NV_PVIDEO_LIMIT(0), dev_priv->fb_available_size - 1);\r\nnvWriteVIDEO(dev, NV_PVIDEO_LIMIT(1), dev_priv->fb_available_size - 1);\r\nnvWriteVIDEO(dev, NV_PVIDEO_UVPLANE_LIMIT(0), dev_priv->fb_available_size - 1);\r\nnvWriteVIDEO(dev, NV_PVIDEO_UVPLANE_LIMIT(1), dev_priv->fb_available_size - 1);\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_2, 0);\r\nNVWriteCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG, regp->cursor_cfg);\r\nNVWriteCRTC(dev, head, NV_PCRTC_830, regp->crtc_830);\r\nNVWriteCRTC(dev, head, NV_PCRTC_834, regp->crtc_834);\r\nif (dev_priv->card_type >= NV_30)\r\nNVWriteCRTC(dev, head, NV_PCRTC_GPIO_EXT, regp->gpio_ext);\r\nif (dev_priv->card_type == NV_40) {\r\nNVWriteCRTC(dev, head, NV_PCRTC_850, regp->crtc_850);\r\nreg900 = NVReadRAMDAC(dev, head, NV_PRAMDAC_900);\r\nif (regp->crtc_cfg == NV10_PCRTC_CONFIG_START_ADDRESS_HSYNC)\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_900, reg900 | 0x10000);\r\nelse\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_900, reg900 & ~0x10000);\r\n}\r\n}\r\nNVWriteCRTC(dev, head, NV_PCRTC_CONFIG, regp->crtc_cfg);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_RPC0_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_RPC1_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_LSR_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_PIXEL_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_LCD__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HEB__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_ENH_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_FF_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_FFLWM__INDEX);\r\nif (dev_priv->card_type >= NV_20)\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_47);\r\nif (dev_priv->card_type >= NV_30)\r\nwr_cio_state(dev, head, regp, 0x9f);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_49);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR0_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR1_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR2_INDEX);\r\nif (dev_priv->card_type == NV_40)\r\nnv_fix_nv40_hw_cursor(dev, head);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_ILACE__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH3__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH4__INDEX);\r\nif (dev_priv->card_type >= NV_10) {\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_EBR_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_CSB);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_4B);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_TVOUT_LATENCY);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nif (dev_priv->card_type == NV_10) {\r\nnouveau_wait_eq(dev, 650000000, NV_PRMCIO_INP0__COLOR, 0x8, 0x8);\r\nnouveau_wait_eq(dev, 650000000, NV_PRMCIO_INP0__COLOR, 0x8, 0x0);\r\n}\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_42);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_53);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_54);\r\nfor (i = 0; i < 0x10; i++)\r\nNVWriteVgaCrtc5758(dev, head, i, regp->CR58[i]);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_59);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_5B);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_85);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_86);\r\n}\r\nNVWriteCRTC(dev, head, NV_PCRTC_START, regp->fb_start);\r\n}\r\nstatic void\r\nnv_save_state_palette(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nint head_offset = head * NV_PRMDIO_SIZE, i;\r\nnv_wr08(dev, NV_PRMDIO_PIXEL_MASK + head_offset,\r\nNV_PRMDIO_PIXEL_MASK_MASK);\r\nnv_wr08(dev, NV_PRMDIO_READ_MODE_ADDRESS + head_offset, 0x0);\r\nfor (i = 0; i < 768; i++) {\r\nstate->crtc_reg[head].DAC[i] = nv_rd08(dev,\r\nNV_PRMDIO_PALETTE_DATA + head_offset);\r\n}\r\nNVSetEnablePalette(dev, head, false);\r\n}\r\nvoid\r\nnouveau_hw_load_state_palette(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nint head_offset = head * NV_PRMDIO_SIZE, i;\r\nnv_wr08(dev, NV_PRMDIO_PIXEL_MASK + head_offset,\r\nNV_PRMDIO_PIXEL_MASK_MASK);\r\nnv_wr08(dev, NV_PRMDIO_WRITE_MODE_ADDRESS + head_offset, 0x0);\r\nfor (i = 0; i < 768; i++) {\r\nnv_wr08(dev, NV_PRMDIO_PALETTE_DATA + head_offset,\r\nstate->crtc_reg[head].DAC[i]);\r\n}\r\nNVSetEnablePalette(dev, head, false);\r\n}\r\nvoid nouveau_hw_save_state(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->chipset == 0x11)\r\nnouveau_hw_fix_bad_vpll(dev, head);\r\nnv_save_state_ramdac(dev, head, state);\r\nnv_save_state_vga(dev, head, state);\r\nnv_save_state_palette(dev, head, state);\r\nnv_save_state_ext(dev, head, state);\r\n}\r\nvoid nouveau_hw_load_state(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nNVVgaProtect(dev, head, true);\r\nnv_load_state_ramdac(dev, head, state);\r\nnv_load_state_ext(dev, head, state);\r\nnouveau_hw_load_state_palette(dev, head, state);\r\nnv_load_state_vga(dev, head, state);\r\nNVVgaProtect(dev, head, false);\r\n}
