static void mpc52xx_spi_chipsel(struct mpc52xx_spi *ms, int value)\r\n{\r\nint cs;\r\nif (ms->gpio_cs_count > 0) {\r\ncs = ms->message->spi->chip_select;\r\ngpio_set_value(ms->gpio_cs[cs], value ? 0 : 1);\r\n} else\r\nout_8(ms->regs + SPI_PORTDATA, value ? 0 : 0x08);\r\n}\r\nstatic void mpc52xx_spi_start_transfer(struct mpc52xx_spi *ms)\r\n{\r\nms->rx_buf = ms->transfer->rx_buf;\r\nms->tx_buf = ms->transfer->tx_buf;\r\nms->len = ms->transfer->len;\r\nif (ms->cs_change)\r\nmpc52xx_spi_chipsel(ms, 1);\r\nms->cs_change = ms->transfer->cs_change;\r\nms->wcol_tx_timestamp = get_tbl();\r\nif (ms->tx_buf)\r\nout_8(ms->regs + SPI_DATA, *ms->tx_buf++);\r\nelse\r\nout_8(ms->regs + SPI_DATA, 0);\r\n}\r\nstatic int\r\nmpc52xx_spi_fsmstate_idle(int irq, struct mpc52xx_spi *ms, u8 status, u8 data)\r\n{\r\nstruct spi_device *spi;\r\nint spr, sppr;\r\nu8 ctrl1;\r\nif (status && (irq != NO_IRQ))\r\ndev_err(&ms->master->dev, "spurious irq, status=0x%.2x\n",\r\nstatus);\r\nif (list_empty(&ms->queue))\r\nreturn FSM_STOP;\r\nms->message = list_first_entry(&ms->queue, struct spi_message, queue);\r\nlist_del_init(&ms->message->queue);\r\nctrl1 = SPI_CTRL1_SPIE | SPI_CTRL1_SPE | SPI_CTRL1_MSTR;\r\nspi = ms->message->spi;\r\nif (spi->mode & SPI_CPHA)\r\nctrl1 |= SPI_CTRL1_CPHA;\r\nif (spi->mode & SPI_CPOL)\r\nctrl1 |= SPI_CTRL1_CPOL;\r\nif (spi->mode & SPI_LSB_FIRST)\r\nctrl1 |= SPI_CTRL1_LSBFE;\r\nout_8(ms->regs + SPI_CTRL1, ctrl1);\r\nsppr = ((ms->ipb_freq / ms->message->spi->max_speed_hz) + 1) >> 1;\r\nspr = 0;\r\nif (sppr < 1)\r\nsppr = 1;\r\nwhile (((sppr - 1) & ~0x7) != 0) {\r\nsppr = (sppr + 1) >> 1;\r\nspr++;\r\n}\r\nsppr--;\r\nif (spr > 7) {\r\nspr = 7;\r\nsppr = 7;\r\n}\r\nout_8(ms->regs + SPI_BRR, sppr << 4 | spr);\r\nms->cs_change = 1;\r\nms->transfer = container_of(ms->message->transfers.next,\r\nstruct spi_transfer, transfer_list);\r\nmpc52xx_spi_start_transfer(ms);\r\nms->state = mpc52xx_spi_fsmstate_transfer;\r\nreturn FSM_CONTINUE;\r\n}\r\nstatic int mpc52xx_spi_fsmstate_transfer(int irq, struct mpc52xx_spi *ms,\r\nu8 status, u8 data)\r\n{\r\nif (!status)\r\nreturn ms->irq0 ? FSM_STOP : FSM_POLL;\r\nif (status & SPI_STATUS_WCOL) {\r\nms->wcol_count++;\r\nms->wcol_ticks += get_tbl() - ms->wcol_tx_timestamp;\r\nms->wcol_tx_timestamp = get_tbl();\r\ndata = 0;\r\nif (ms->tx_buf)\r\ndata = *(ms->tx_buf - 1);\r\nout_8(ms->regs + SPI_DATA, data);\r\nreturn FSM_CONTINUE;\r\n} else if (status & SPI_STATUS_MODF) {\r\nms->modf_count++;\r\ndev_err(&ms->master->dev, "mode fault\n");\r\nmpc52xx_spi_chipsel(ms, 0);\r\nms->message->status = -EIO;\r\nms->message->complete(ms->message->context);\r\nms->state = mpc52xx_spi_fsmstate_idle;\r\nreturn FSM_CONTINUE;\r\n}\r\nms->byte_count++;\r\nif (ms->rx_buf)\r\n*ms->rx_buf++ = data;\r\nms->len--;\r\nif (ms->len == 0) {\r\nms->timestamp = get_tbl();\r\nms->timestamp += ms->transfer->delay_usecs * tb_ticks_per_usec;\r\nms->state = mpc52xx_spi_fsmstate_wait;\r\nreturn FSM_CONTINUE;\r\n}\r\nms->wcol_tx_timestamp = get_tbl();\r\nif (ms->tx_buf)\r\nout_8(ms->regs + SPI_DATA, *ms->tx_buf++);\r\nelse\r\nout_8(ms->regs + SPI_DATA, 0);\r\nreturn FSM_CONTINUE;\r\n}\r\nstatic int\r\nmpc52xx_spi_fsmstate_wait(int irq, struct mpc52xx_spi *ms, u8 status, u8 data)\r\n{\r\nif (status && irq)\r\ndev_err(&ms->master->dev, "spurious irq, status=0x%.2x\n",\r\nstatus);\r\nif (((int)get_tbl()) - ms->timestamp < 0)\r\nreturn FSM_POLL;\r\nms->message->actual_length += ms->transfer->len;\r\nif (ms->transfer->transfer_list.next == &ms->message->transfers) {\r\nms->msg_count++;\r\nmpc52xx_spi_chipsel(ms, 0);\r\nms->message->status = 0;\r\nms->message->complete(ms->message->context);\r\nms->state = mpc52xx_spi_fsmstate_idle;\r\nreturn FSM_CONTINUE;\r\n}\r\nif (ms->cs_change)\r\nmpc52xx_spi_chipsel(ms, 0);\r\nms->transfer = container_of(ms->transfer->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\nmpc52xx_spi_start_transfer(ms);\r\nms->state = mpc52xx_spi_fsmstate_transfer;\r\nreturn FSM_CONTINUE;\r\n}\r\nstatic void mpc52xx_spi_fsm_process(int irq, struct mpc52xx_spi *ms)\r\n{\r\nint rc = FSM_CONTINUE;\r\nu8 status, data;\r\nwhile (rc == FSM_CONTINUE) {\r\nstatus = in_8(ms->regs + SPI_STATUS);\r\ndata = in_8(ms->regs + SPI_DATA);\r\nrc = ms->state(irq, ms, status, data);\r\n}\r\nif (rc == FSM_POLL)\r\nschedule_work(&ms->work);\r\n}\r\nstatic irqreturn_t mpc52xx_spi_irq(int irq, void *_ms)\r\n{\r\nstruct mpc52xx_spi *ms = _ms;\r\nspin_lock(&ms->lock);\r\nmpc52xx_spi_fsm_process(irq, ms);\r\nspin_unlock(&ms->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mpc52xx_spi_wq(struct work_struct *work)\r\n{\r\nstruct mpc52xx_spi *ms = container_of(work, struct mpc52xx_spi, work);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ms->lock, flags);\r\nmpc52xx_spi_fsm_process(0, ms);\r\nspin_unlock_irqrestore(&ms->lock, flags);\r\n}\r\nstatic int mpc52xx_spi_setup(struct spi_device *spi)\r\n{\r\nif (spi->bits_per_word % 8)\r\nreturn -EINVAL;\r\nif (spi->mode & ~(SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST))\r\nreturn -EINVAL;\r\nif (spi->chip_select >= spi->master->num_chipselect)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_spi_transfer(struct spi_device *spi, struct spi_message *m)\r\n{\r\nstruct mpc52xx_spi *ms = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nm->actual_length = 0;\r\nm->status = -EINPROGRESS;\r\nspin_lock_irqsave(&ms->lock, flags);\r\nlist_add_tail(&m->queue, &ms->queue);\r\nspin_unlock_irqrestore(&ms->lock, flags);\r\nschedule_work(&ms->work);\r\nreturn 0;\r\n}\r\nstatic int __devinit mpc52xx_spi_probe(struct platform_device *op)\r\n{\r\nstruct spi_master *master;\r\nstruct mpc52xx_spi *ms;\r\nvoid __iomem *regs;\r\nu8 ctrl1;\r\nint rc, i = 0;\r\nint gpio_cs;\r\ndev_dbg(&op->dev, "probing mpc5200 SPI device\n");\r\nregs = of_iomap(op->dev.of_node, 0);\r\nif (!regs)\r\nreturn -ENODEV;\r\nctrl1 = SPI_CTRL1_SPIE | SPI_CTRL1_SPE | SPI_CTRL1_MSTR;\r\nout_8(regs + SPI_CTRL1, ctrl1);\r\nout_8(regs + SPI_CTRL2, 0x0);\r\nout_8(regs + SPI_DATADIR, 0xe);\r\nout_8(regs + SPI_PORTDATA, 0x8);\r\nin_8(regs + SPI_STATUS);\r\nout_8(regs + SPI_CTRL1, ctrl1);\r\nin_8(regs + SPI_DATA);\r\nif (in_8(regs + SPI_STATUS) & SPI_STATUS_MODF) {\r\ndev_err(&op->dev, "mode fault; is port_config correct?\n");\r\nrc = -EIO;\r\ngoto err_init;\r\n}\r\ndev_dbg(&op->dev, "allocating spi_master struct\n");\r\nmaster = spi_alloc_master(&op->dev, sizeof *ms);\r\nif (!master) {\r\nrc = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nmaster->setup = mpc52xx_spi_setup;\r\nmaster->transfer = mpc52xx_spi_transfer;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\r\nmaster->dev.of_node = op->dev.of_node;\r\ndev_set_drvdata(&op->dev, master);\r\nms = spi_master_get_devdata(master);\r\nms->master = master;\r\nms->regs = regs;\r\nms->irq0 = irq_of_parse_and_map(op->dev.of_node, 0);\r\nms->irq1 = irq_of_parse_and_map(op->dev.of_node, 1);\r\nms->state = mpc52xx_spi_fsmstate_idle;\r\nms->ipb_freq = mpc5xxx_get_bus_frequency(op->dev.of_node);\r\nms->gpio_cs_count = of_gpio_count(op->dev.of_node);\r\nif (ms->gpio_cs_count > 0) {\r\nmaster->num_chipselect = ms->gpio_cs_count;\r\nms->gpio_cs = kmalloc(ms->gpio_cs_count * sizeof(unsigned int),\r\nGFP_KERNEL);\r\nif (!ms->gpio_cs) {\r\nrc = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nfor (i = 0; i < ms->gpio_cs_count; i++) {\r\ngpio_cs = of_get_gpio(op->dev.of_node, i);\r\nif (gpio_cs < 0) {\r\ndev_err(&op->dev,\r\n"could not parse the gpio field "\r\n"in oftree\n");\r\nrc = -ENODEV;\r\ngoto err_gpio;\r\n}\r\nrc = gpio_request(gpio_cs, dev_name(&op->dev));\r\nif (rc) {\r\ndev_err(&op->dev,\r\n"can't request spi cs gpio #%d "\r\n"on gpio line %d\n", i, gpio_cs);\r\ngoto err_gpio;\r\n}\r\ngpio_direction_output(gpio_cs, 1);\r\nms->gpio_cs[i] = gpio_cs;\r\n}\r\n}\r\nspin_lock_init(&ms->lock);\r\nINIT_LIST_HEAD(&ms->queue);\r\nINIT_WORK(&ms->work, mpc52xx_spi_wq);\r\nif (ms->irq0 && ms->irq1) {\r\nrc = request_irq(ms->irq0, mpc52xx_spi_irq, 0,\r\n"mpc5200-spi-modf", ms);\r\nrc |= request_irq(ms->irq1, mpc52xx_spi_irq, 0,\r\n"mpc5200-spi-spif", ms);\r\nif (rc) {\r\nfree_irq(ms->irq0, ms);\r\nfree_irq(ms->irq1, ms);\r\nms->irq0 = ms->irq1 = 0;\r\n}\r\n} else {\r\nms->irq0 = ms->irq1 = 0;\r\n}\r\nif (!ms->irq0)\r\ndev_info(&op->dev, "using polled mode\n");\r\ndev_dbg(&op->dev, "registering spi_master struct\n");\r\nrc = spi_register_master(master);\r\nif (rc)\r\ngoto err_register;\r\ndev_info(&ms->master->dev, "registered MPC5200 SPI bus\n");\r\nreturn rc;\r\nerr_register:\r\ndev_err(&ms->master->dev, "initialization failed\n");\r\nspi_master_put(master);\r\nerr_gpio:\r\nwhile (i-- > 0)\r\ngpio_free(ms->gpio_cs[i]);\r\nkfree(ms->gpio_cs);\r\nerr_alloc:\r\nerr_init:\r\niounmap(regs);\r\nreturn rc;\r\n}\r\nstatic int __devexit mpc52xx_spi_remove(struct platform_device *op)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(&op->dev);\r\nstruct mpc52xx_spi *ms = spi_master_get_devdata(master);\r\nint i;\r\nfree_irq(ms->irq0, ms);\r\nfree_irq(ms->irq1, ms);\r\nfor (i = 0; i < ms->gpio_cs_count; i++)\r\ngpio_free(ms->gpio_cs[i]);\r\nkfree(ms->gpio_cs);\r\nspi_unregister_master(master);\r\nspi_master_put(master);\r\niounmap(ms->regs);\r\nreturn 0;\r\n}
