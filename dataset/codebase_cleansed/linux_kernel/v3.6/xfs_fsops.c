int\r\nxfs_fs_geometry(\r\nxfs_mount_t *mp,\r\nxfs_fsop_geom_t *geo,\r\nint new_version)\r\n{\r\nmemset(geo, 0, sizeof(*geo));\r\ngeo->blocksize = mp->m_sb.sb_blocksize;\r\ngeo->rtextsize = mp->m_sb.sb_rextsize;\r\ngeo->agblocks = mp->m_sb.sb_agblocks;\r\ngeo->agcount = mp->m_sb.sb_agcount;\r\ngeo->logblocks = mp->m_sb.sb_logblocks;\r\ngeo->sectsize = mp->m_sb.sb_sectsize;\r\ngeo->inodesize = mp->m_sb.sb_inodesize;\r\ngeo->imaxpct = mp->m_sb.sb_imax_pct;\r\ngeo->datablocks = mp->m_sb.sb_dblocks;\r\ngeo->rtblocks = mp->m_sb.sb_rblocks;\r\ngeo->rtextents = mp->m_sb.sb_rextents;\r\ngeo->logstart = mp->m_sb.sb_logstart;\r\nASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\r\nmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\r\nif (new_version >= 2) {\r\ngeo->sunit = mp->m_sb.sb_unit;\r\ngeo->swidth = mp->m_sb.sb_width;\r\n}\r\nif (new_version >= 3) {\r\ngeo->version = XFS_FSOP_GEOM_VERSION;\r\ngeo->flags =\r\n(xfs_sb_version_hasattr(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\r\n(xfs_sb_version_hasnlink(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_NLINK : 0) |\r\n(xfs_sb_version_hasquota(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\r\n(xfs_sb_version_hasalign(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\r\n(xfs_sb_version_hasdalign(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\r\n(xfs_sb_version_hasshared(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_SHARED : 0) |\r\n(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\r\n(xfs_sb_version_hasdirv2(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_DIRV2 : 0) |\r\n(xfs_sb_version_hassector(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\r\n(xfs_sb_version_hasasciici(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\r\n(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\r\n(xfs_sb_version_hasattr2(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_ATTR2 : 0);\r\ngeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\r\nmp->m_sb.sb_logsectsize : BBSIZE;\r\ngeo->rtsectsize = mp->m_sb.sb_blocksize;\r\ngeo->dirblocksize = mp->m_dirblksize;\r\n}\r\nif (new_version >= 4) {\r\ngeo->flags |=\r\n(xfs_sb_version_haslogv2(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\r\ngeo->logsunit = mp->m_sb.sb_logsunit;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_growfs_data_private(\r\nxfs_mount_t *mp,\r\nxfs_growfs_data_t *in)\r\n{\r\nxfs_agf_t *agf;\r\nxfs_agi_t *agi;\r\nxfs_agnumber_t agno;\r\nxfs_extlen_t agsize;\r\nxfs_extlen_t tmpsize;\r\nxfs_alloc_rec_t *arec;\r\nstruct xfs_btree_block *block;\r\nxfs_buf_t *bp;\r\nint bucket;\r\nint dpct;\r\nint error;\r\nxfs_agnumber_t nagcount;\r\nxfs_agnumber_t nagimax = 0;\r\nxfs_rfsblock_t nb, nb_mod;\r\nxfs_rfsblock_t new;\r\nxfs_rfsblock_t nfree;\r\nxfs_agnumber_t oagcount;\r\nint pct;\r\nxfs_trans_t *tp;\r\nnb = in->newblocks;\r\npct = in->imaxpct;\r\nif (nb < mp->m_sb.sb_dblocks || pct < 0 || pct > 100)\r\nreturn XFS_ERROR(EINVAL);\r\nif ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))\r\nreturn error;\r\ndpct = pct - mp->m_sb.sb_imax_pct;\r\nbp = xfs_buf_read_uncached(mp->m_ddev_targp,\r\nXFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),\r\nXFS_FSS_TO_BB(mp, 1), 0);\r\nif (!bp)\r\nreturn EIO;\r\nxfs_buf_relse(bp);\r\nnew = nb;\r\nnb_mod = do_div(new, mp->m_sb.sb_agblocks);\r\nnagcount = new + (nb_mod != 0);\r\nif (nb_mod && nb_mod < XFS_MIN_AG_BLOCKS) {\r\nnagcount--;\r\nnb = (xfs_rfsblock_t)nagcount * mp->m_sb.sb_agblocks;\r\nif (nb < mp->m_sb.sb_dblocks)\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nnew = nb - mp->m_sb.sb_dblocks;\r\noagcount = mp->m_sb.sb_agcount;\r\nif (nagcount > oagcount) {\r\nerror = xfs_initialize_perag(mp, nagcount, &nagimax);\r\nif (error)\r\nreturn error;\r\n}\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_GROWFS);\r\ntp->t_flags |= XFS_TRANS_RESERVE;\r\nif ((error = xfs_trans_reserve(tp, XFS_GROWFS_SPACE_RES(mp),\r\nXFS_GROWDATA_LOG_RES(mp), 0, 0, 0))) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nnfree = 0;\r\nfor (agno = nagcount - 1; agno >= oagcount; agno--, new -= agsize) {\r\nbp = xfs_buf_get(mp->m_ddev_targp,\r\nXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0);\r\nif (!bp) {\r\nerror = ENOMEM;\r\ngoto error0;\r\n}\r\nagf = XFS_BUF_TO_AGF(bp);\r\nmemset(agf, 0, mp->m_sb.sb_sectsize);\r\nagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\r\nagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\r\nagf->agf_seqno = cpu_to_be32(agno);\r\nif (agno == nagcount - 1)\r\nagsize =\r\nnb -\r\n(agno * (xfs_rfsblock_t)mp->m_sb.sb_agblocks);\r\nelse\r\nagsize = mp->m_sb.sb_agblocks;\r\nagf->agf_length = cpu_to_be32(agsize);\r\nagf->agf_roots[XFS_BTNUM_BNOi] = cpu_to_be32(XFS_BNO_BLOCK(mp));\r\nagf->agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));\r\nagf->agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);\r\nagf->agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);\r\nagf->agf_flfirst = 0;\r\nagf->agf_fllast = cpu_to_be32(XFS_AGFL_SIZE(mp) - 1);\r\nagf->agf_flcount = 0;\r\ntmpsize = agsize - XFS_PREALLOC_BLOCKS(mp);\r\nagf->agf_freeblks = cpu_to_be32(tmpsize);\r\nagf->agf_longest = cpu_to_be32(tmpsize);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_buf_get(mp->m_ddev_targp,\r\nXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0);\r\nif (!bp) {\r\nerror = ENOMEM;\r\ngoto error0;\r\n}\r\nagi = XFS_BUF_TO_AGI(bp);\r\nmemset(agi, 0, mp->m_sb.sb_sectsize);\r\nagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\r\nagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\r\nagi->agi_seqno = cpu_to_be32(agno);\r\nagi->agi_length = cpu_to_be32(agsize);\r\nagi->agi_count = 0;\r\nagi->agi_root = cpu_to_be32(XFS_IBT_BLOCK(mp));\r\nagi->agi_level = cpu_to_be32(1);\r\nagi->agi_freecount = 0;\r\nagi->agi_newino = cpu_to_be32(NULLAGINO);\r\nagi->agi_dirino = cpu_to_be32(NULLAGINO);\r\nfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++)\r\nagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_buf_get(mp->m_ddev_targp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_BNO_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0);\r\nif (!bp) {\r\nerror = ENOMEM;\r\ngoto error0;\r\n}\r\nblock = XFS_BUF_TO_BLOCK(bp);\r\nmemset(block, 0, mp->m_sb.sb_blocksize);\r\nblock->bb_magic = cpu_to_be32(XFS_ABTB_MAGIC);\r\nblock->bb_level = 0;\r\nblock->bb_numrecs = cpu_to_be16(1);\r\nblock->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\r\nblock->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\r\narec = XFS_ALLOC_REC_ADDR(mp, block, 1);\r\narec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\r\narec->ar_blockcount = cpu_to_be32(\r\nagsize - be32_to_cpu(arec->ar_startblock));\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_buf_get(mp->m_ddev_targp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_CNT_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0);\r\nif (!bp) {\r\nerror = ENOMEM;\r\ngoto error0;\r\n}\r\nblock = XFS_BUF_TO_BLOCK(bp);\r\nmemset(block, 0, mp->m_sb.sb_blocksize);\r\nblock->bb_magic = cpu_to_be32(XFS_ABTC_MAGIC);\r\nblock->bb_level = 0;\r\nblock->bb_numrecs = cpu_to_be16(1);\r\nblock->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\r\nblock->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\r\narec = XFS_ALLOC_REC_ADDR(mp, block, 1);\r\narec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));\r\narec->ar_blockcount = cpu_to_be32(\r\nagsize - be32_to_cpu(arec->ar_startblock));\r\nnfree += be32_to_cpu(arec->ar_blockcount);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_buf_get(mp->m_ddev_targp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_IBT_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0);\r\nif (!bp) {\r\nerror = ENOMEM;\r\ngoto error0;\r\n}\r\nblock = XFS_BUF_TO_BLOCK(bp);\r\nmemset(block, 0, mp->m_sb.sb_blocksize);\r\nblock->bb_magic = cpu_to_be32(XFS_IBT_MAGIC);\r\nblock->bb_level = 0;\r\nblock->bb_numrecs = 0;\r\nblock->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\r\nblock->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\n}\r\nxfs_trans_agblocks_delta(tp, nfree);\r\nif (new) {\r\nerror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\r\nif (error) {\r\ngoto error0;\r\n}\r\nASSERT(bp);\r\nagi = XFS_BUF_TO_AGI(bp);\r\nbe32_add_cpu(&agi->agi_length, new);\r\nASSERT(nagcount == oagcount ||\r\nbe32_to_cpu(agi->agi_length) == mp->m_sb.sb_agblocks);\r\nxfs_ialloc_log_agi(tp, bp, XFS_AGI_LENGTH);\r\nerror = xfs_alloc_read_agf(mp, tp, agno, 0, &bp);\r\nif (error) {\r\ngoto error0;\r\n}\r\nASSERT(bp);\r\nagf = XFS_BUF_TO_AGF(bp);\r\nbe32_add_cpu(&agf->agf_length, new);\r\nASSERT(be32_to_cpu(agf->agf_length) ==\r\nbe32_to_cpu(agi->agi_length));\r\nxfs_alloc_log_agf(tp, bp, XFS_AGF_LENGTH);\r\nerror = xfs_free_extent(tp, XFS_AGB_TO_FSB(mp, agno,\r\nbe32_to_cpu(agf->agf_length) - new), new);\r\nif (error) {\r\ngoto error0;\r\n}\r\n}\r\nif (nagcount > oagcount)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_AGCOUNT, nagcount - oagcount);\r\nif (nb > mp->m_sb.sb_dblocks)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_DBLOCKS,\r\nnb - mp->m_sb.sb_dblocks);\r\nif (nfree)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, nfree);\r\nif (dpct)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_IMAXPCT, dpct);\r\nerror = xfs_trans_commit(tp, 0);\r\nif (error)\r\nreturn error;\r\nif (nagimax)\r\nmp->m_maxagi = nagimax;\r\nif (mp->m_sb.sb_imax_pct) {\r\n__uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;\r\ndo_div(icount, 100);\r\nmp->m_maxicount = icount << mp->m_sb.sb_inopblog;\r\n} else\r\nmp->m_maxicount = 0;\r\nxfs_set_low_space_thresholds(mp);\r\nfor (agno = 1; agno < nagcount; agno++) {\r\nerror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0, &bp);\r\nif (error) {\r\nxfs_warn(mp,\r\n"error %d reading secondary superblock for ag %d",\r\nerror, agno);\r\nbreak;\r\n}\r\nxfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb, XFS_SB_ALL_BITS);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error) {\r\nxfs_warn(mp,\r\n"write error %d updating secondary superblock for ag %d",\r\nerror, agno);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nerror0:\r\nxfs_trans_cancel(tp, XFS_TRANS_ABORT);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_growfs_log_private(\r\nxfs_mount_t *mp,\r\nxfs_growfs_log_t *in)\r\n{\r\nxfs_extlen_t nb;\r\nnb = in->newblocks;\r\nif (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))\r\nreturn XFS_ERROR(EINVAL);\r\nif (nb == mp->m_sb.sb_logblocks &&\r\nin->isint == (mp->m_sb.sb_logstart != 0))\r\nreturn XFS_ERROR(EINVAL);\r\nreturn XFS_ERROR(ENOSYS);\r\n}\r\nint\r\nxfs_growfs_data(\r\nxfs_mount_t *mp,\r\nxfs_growfs_data_t *in)\r\n{\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn XFS_ERROR(EPERM);\r\nif (!mutex_trylock(&mp->m_growlock))\r\nreturn XFS_ERROR(EWOULDBLOCK);\r\nerror = xfs_growfs_data_private(mp, in);\r\nmutex_unlock(&mp->m_growlock);\r\nreturn error;\r\n}\r\nint\r\nxfs_growfs_log(\r\nxfs_mount_t *mp,\r\nxfs_growfs_log_t *in)\r\n{\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn XFS_ERROR(EPERM);\r\nif (!mutex_trylock(&mp->m_growlock))\r\nreturn XFS_ERROR(EWOULDBLOCK);\r\nerror = xfs_growfs_log_private(mp, in);\r\nmutex_unlock(&mp->m_growlock);\r\nreturn error;\r\n}\r\nint\r\nxfs_fs_counts(\r\nxfs_mount_t *mp,\r\nxfs_fsop_counts_t *cnt)\r\n{\r\nxfs_icsb_sync_counters(mp, XFS_ICSB_LAZY_COUNT);\r\nspin_lock(&mp->m_sb_lock);\r\ncnt->freedata = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\r\ncnt->freertx = mp->m_sb.sb_frextents;\r\ncnt->freeino = mp->m_sb.sb_ifree;\r\ncnt->allocino = mp->m_sb.sb_icount;\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn 0;\r\n}\r\nint\r\nxfs_reserve_blocks(\r\nxfs_mount_t *mp,\r\n__uint64_t *inval,\r\nxfs_fsop_resblks_t *outval)\r\n{\r\n__int64_t lcounter, delta, fdblks_delta;\r\n__uint64_t request;\r\nif (inval == (__uint64_t *)NULL) {\r\nif (!outval)\r\nreturn EINVAL;\r\noutval->resblks = mp->m_resblks;\r\noutval->resblks_avail = mp->m_resblks_avail;\r\nreturn 0;\r\n}\r\nrequest = *inval;\r\nretry:\r\nspin_lock(&mp->m_sb_lock);\r\nxfs_icsb_sync_counters_locked(mp, 0);\r\nfdblks_delta = 0;\r\nif (mp->m_resblks > request) {\r\nlcounter = mp->m_resblks_avail - request;\r\nif (lcounter > 0) {\r\nfdblks_delta = lcounter;\r\nmp->m_resblks_avail -= lcounter;\r\n}\r\nmp->m_resblks = request;\r\n} else {\r\n__int64_t free;\r\nfree = mp->m_sb.sb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\r\nif (!free)\r\ngoto out;\r\ndelta = request - mp->m_resblks;\r\nlcounter = free - delta;\r\nif (lcounter < 0) {\r\nmp->m_resblks += free;\r\nmp->m_resblks_avail += free;\r\nfdblks_delta = -free;\r\n} else {\r\nfdblks_delta = -delta;\r\nmp->m_resblks = request;\r\nmp->m_resblks_avail += delta;\r\n}\r\n}\r\nout:\r\nif (outval) {\r\noutval->resblks = mp->m_resblks;\r\noutval->resblks_avail = mp->m_resblks_avail;\r\n}\r\nspin_unlock(&mp->m_sb_lock);\r\nif (fdblks_delta) {\r\nint error;\r\nerror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\r\nfdblks_delta, 0);\r\nif (error == ENOSPC)\r\ngoto retry;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_fs_log_dummy(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\ntp = _xfs_trans_alloc(mp, XFS_TRANS_DUMMY1, KM_SLEEP);\r\nerror = xfs_trans_reserve(tp, 0, mp->m_sb.sb_sectsize + 128, 0, 0,\r\nXFS_DEFAULT_LOG_COUNT);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nxfs_mod_sb(tp, XFS_SB_UUID);\r\nxfs_trans_set_sync(tp);\r\nreturn xfs_trans_commit(tp, 0);\r\n}\r\nint\r\nxfs_fs_goingdown(\r\nxfs_mount_t *mp,\r\n__uint32_t inflags)\r\n{\r\nswitch (inflags) {\r\ncase XFS_FSOP_GOING_FLAGS_DEFAULT: {\r\nstruct super_block *sb = freeze_bdev(mp->m_super->s_bdev);\r\nif (sb && !IS_ERR(sb)) {\r\nxfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\r\nthaw_bdev(sb->s_bdev, sb);\r\n}\r\nbreak;\r\n}\r\ncase XFS_FSOP_GOING_FLAGS_LOGFLUSH:\r\nxfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\r\nbreak;\r\ncase XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:\r\nxfs_force_shutdown(mp,\r\nSHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);\r\nbreak;\r\ndefault:\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_do_force_shutdown(\r\nxfs_mount_t *mp,\r\nint flags,\r\nchar *fname,\r\nint lnnum)\r\n{\r\nint logerror;\r\nlogerror = flags & SHUTDOWN_LOG_IO_ERROR;\r\nif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\r\nxfs_notice(mp,\r\n"%s(0x%x) called from line %d of file %s. Return address = 0x%p",\r\n__func__, flags, lnnum, fname, __return_address);\r\n}\r\nif (XFS_FORCED_SHUTDOWN(mp) && !logerror)\r\nreturn;\r\nif (xfs_log_force_umount(mp, logerror))\r\nreturn;\r\nif (flags & SHUTDOWN_CORRUPT_INCORE) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_CORRUPT,\r\n"Corruption of in-memory data detected. Shutting down filesystem");\r\nif (XFS_ERRLEVEL_HIGH <= xfs_error_level)\r\nxfs_stack_trace();\r\n} else if (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\r\nif (logerror) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_LOGERROR,\r\n"Log I/O Error Detected. Shutting down filesystem");\r\n} else if (flags & SHUTDOWN_DEVICE_REQ) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\r\n"All device paths lost. Shutting down filesystem");\r\n} else if (!(flags & SHUTDOWN_REMOTE_REQ)) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\r\n"I/O Error Detected. Shutting down filesystem");\r\n}\r\n}\r\nif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\r\nxfs_alert(mp,\r\n"Please umount the filesystem and rectify the problem(s)");\r\n}\r\n}
