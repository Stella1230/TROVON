static void __clk_enable(struct clk *clk)\r\n{\r\nif (clk->parent)\r\n__clk_enable(clk->parent);\r\nclk->usecount++;\r\n}\r\nstatic void __clk_disable(struct clk *clk)\r\n{\r\nif (WARN_ON(clk->usecount == 0))\r\nreturn;\r\n--clk->usecount;\r\nif (clk->parent)\r\n__clk_disable(clk->parent);\r\n}\r\nint clk_enable(struct clk *clk)\r\n{\r\nunsigned long flags;\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&clockfw_lock, flags);\r\n__clk_enable(clk);\r\nspin_unlock_irqrestore(&clockfw_lock, flags);\r\nreturn 0;\r\n}\r\nvoid clk_disable(struct clk *clk)\r\n{\r\nunsigned long flags;\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn;\r\nspin_lock_irqsave(&clockfw_lock, flags);\r\n__clk_disable(clk);\r\nspin_unlock_irqrestore(&clockfw_lock, flags);\r\n}\r\nunsigned long clk_get_rate(struct clk *clk)\r\n{\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn -EINVAL;\r\nreturn clk->rate;\r\n}\r\nlong clk_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn -EINVAL;\r\nif (clk->round_rate)\r\nreturn clk->round_rate(clk, rate);\r\nreturn clk->rate;\r\n}\r\nstatic void propagate_rate(struct clk *root)\r\n{\r\nstruct clk *clk;\r\nlist_for_each_entry(clk, &root->children, childnode) {\r\nif (clk->recalc)\r\nclk->rate = clk->recalc(clk);\r\npropagate_rate(clk);\r\n}\r\n}\r\nint clk_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn ret;\r\nif (clk->set_rate)\r\nret = clk->set_rate(clk, rate);\r\nspin_lock_irqsave(&clockfw_lock, flags);\r\nif (ret == 0) {\r\nif (clk->recalc)\r\nclk->rate = clk->recalc(clk);\r\npropagate_rate(clk);\r\n}\r\nspin_unlock_irqrestore(&clockfw_lock, flags);\r\nreturn ret;\r\n}\r\nint clk_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long flags;\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn -EINVAL;\r\nif (WARN_ON(clk->usecount))\r\nreturn -EINVAL;\r\nmutex_lock(&clocks_mutex);\r\nclk->parent = parent;\r\nlist_del_init(&clk->childnode);\r\nlist_add(&clk->childnode, &clk->parent->children);\r\nmutex_unlock(&clocks_mutex);\r\nspin_lock_irqsave(&clockfw_lock, flags);\r\nif (clk->recalc)\r\nclk->rate = clk->recalc(clk);\r\npropagate_rate(clk);\r\nspin_unlock_irqrestore(&clockfw_lock, flags);\r\nreturn 0;\r\n}\r\nint clk_register(struct clk *clk)\r\n{\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn -EINVAL;\r\nif (WARN(clk->parent && !clk->parent->rate,\r\n"CLK: %s parent %s has no rate!\n",\r\nclk->name, clk->parent->name))\r\nreturn -EINVAL;\r\nmutex_lock(&clocks_mutex);\r\nlist_add_tail(&clk->node, &clocks);\r\nif (clk->parent)\r\nlist_add_tail(&clk->childnode, &clk->parent->children);\r\nmutex_unlock(&clocks_mutex);\r\nif (clk->rate)\r\nreturn 0;\r\nif (clk->recalc)\r\nclk->rate = clk->recalc(clk);\r\nelse if (clk->parent)\r\nclk->rate = clk->parent->rate;\r\nreturn 0;\r\n}\r\nvoid clk_unregister(struct clk *clk)\r\n{\r\nif (clk == NULL || IS_ERR(clk))\r\nreturn;\r\nmutex_lock(&clocks_mutex);\r\nlist_del(&clk->node);\r\nlist_del(&clk->childnode);\r\nmutex_unlock(&clocks_mutex);\r\n}\r\nstatic u32 pll_read(struct pll_data *pll, int reg)\r\n{\r\nreturn soc_readl(pll->base + reg);\r\n}\r\nstatic unsigned long clk_sysclk_recalc(struct clk *clk)\r\n{\r\nu32 v, plldiv = 0;\r\nstruct pll_data *pll;\r\nunsigned long rate = clk->rate;\r\nif (WARN_ON(!clk->parent))\r\nreturn rate;\r\nrate = clk->parent->rate;\r\nif (WARN_ON(!clk->parent->pll_data))\r\nreturn rate;\r\npll = clk->parent->pll_data;\r\nif (clk->flags & PRE_PLL)\r\nrate = pll->input_rate;\r\nif (!clk->div) {\r\npr_debug("%s: (no divider) rate = %lu KHz\n",\r\nclk->name, rate / 1000);\r\nreturn rate;\r\n}\r\nif (clk->flags & FIXED_DIV_PLL) {\r\nrate /= clk->div;\r\npr_debug("%s: (fixed divide by %d) rate = %lu KHz\n",\r\nclk->name, clk->div, rate / 1000);\r\nreturn rate;\r\n}\r\nv = pll_read(pll, clk->div);\r\nif (v & PLLDIV_EN)\r\nplldiv = (v & PLLDIV_RATIO_MASK) + 1;\r\nif (plldiv == 0)\r\nplldiv = 1;\r\nrate /= plldiv;\r\npr_debug("%s: (divide by %d) rate = %lu KHz\n",\r\nclk->name, plldiv, rate / 1000);\r\nreturn rate;\r\n}\r\nstatic unsigned long clk_leafclk_recalc(struct clk *clk)\r\n{\r\nif (WARN_ON(!clk->parent))\r\nreturn clk->rate;\r\npr_debug("%s: (parent %s) rate = %lu KHz\n",\r\nclk->name, clk->parent->name, clk->parent->rate / 1000);\r\nreturn clk->parent->rate;\r\n}\r\nstatic unsigned long clk_pllclk_recalc(struct clk *clk)\r\n{\r\nu32 ctrl, mult = 0, prediv = 0, postdiv = 0;\r\nu8 bypass;\r\nstruct pll_data *pll = clk->pll_data;\r\nunsigned long rate = clk->rate;\r\nif (clk->flags & FIXED_RATE_PLL)\r\nreturn rate;\r\nctrl = pll_read(pll, PLLCTL);\r\nrate = pll->input_rate = clk->parent->rate;\r\nif (ctrl & PLLCTL_PLLEN)\r\nbypass = 0;\r\nelse\r\nbypass = 1;\r\nif (pll->flags & PLL_HAS_MUL) {\r\nmult = pll_read(pll, PLLM);\r\nmult = (mult & PLLM_PLLM_MASK) + 1;\r\n}\r\nif (pll->flags & PLL_HAS_PRE) {\r\nprediv = pll_read(pll, PLLPRE);\r\nif (prediv & PLLDIV_EN)\r\nprediv = (prediv & PLLDIV_RATIO_MASK) + 1;\r\nelse\r\nprediv = 0;\r\n}\r\nif (pll->flags & PLL_HAS_POST) {\r\npostdiv = pll_read(pll, PLLPOST);\r\nif (postdiv & PLLDIV_EN)\r\npostdiv = (postdiv & PLLDIV_RATIO_MASK) + 1;\r\nelse\r\npostdiv = 1;\r\n}\r\nif (!bypass) {\r\nif (prediv)\r\nrate /= prediv;\r\nif (mult)\r\nrate *= mult;\r\nif (postdiv)\r\nrate /= postdiv;\r\npr_debug("PLL%d: input = %luMHz, pre[%d] mul[%d] post[%d] "\r\n"--> %luMHz output.\n",\r\npll->num, clk->parent->rate / 1000000,\r\nprediv, mult, postdiv, rate / 1000000);\r\n} else\r\npr_debug("PLL%d: input = %luMHz, bypass mode.\n",\r\npll->num, clk->parent->rate / 1000000);\r\nreturn rate;\r\n}\r\nstatic void __init __init_clk(struct clk *clk)\r\n{\r\nINIT_LIST_HEAD(&clk->node);\r\nINIT_LIST_HEAD(&clk->children);\r\nINIT_LIST_HEAD(&clk->childnode);\r\nif (!clk->recalc) {\r\nif (clk->pll_data)\r\nclk->recalc = clk_pllclk_recalc;\r\nelse if (clk->flags & CLK_PLL)\r\nclk->recalc = clk_sysclk_recalc;\r\nelse if (clk->parent)\r\nclk->recalc = clk_leafclk_recalc;\r\n}\r\n}\r\nvoid __init c6x_clks_init(struct clk_lookup *clocks)\r\n{\r\nstruct clk_lookup *c;\r\nstruct clk *clk;\r\nsize_t num_clocks = 0;\r\nfor (c = clocks; c->clk; c++) {\r\nclk = c->clk;\r\n__init_clk(clk);\r\nclk_register(clk);\r\nnum_clocks++;\r\nif (clk->flags & ALWAYS_ENABLED)\r\nclk_enable(clk);\r\n}\r\nclkdev_add_table(clocks, num_clocks);\r\n}\r\nstatic void\r\ndump_clock(struct seq_file *s, unsigned nest, struct clk *parent)\r\n{\r\nchar *state;\r\nchar buf[CLKNAME_MAX + NEST_DELTA * NEST_MAX];\r\nstruct clk *clk;\r\nunsigned i;\r\nif (parent->flags & CLK_PLL)\r\nstate = "pll";\r\nelse\r\nstate = "";\r\nmemset(buf, ' ', sizeof(buf) - 1);\r\nbuf[sizeof(buf) - 1] = 0;\r\ni = strlen(parent->name);\r\nmemcpy(buf + nest, parent->name,\r\nmin(i, (unsigned)(sizeof(buf) - 1 - nest)));\r\nseq_printf(s, "%s users=%2d %-3s %9ld Hz\n",\r\nbuf, parent->usecount, state, clk_get_rate(parent));\r\nlist_for_each_entry(clk, &parent->children, childnode) {\r\ndump_clock(s, nest + NEST_DELTA, clk);\r\n}\r\n}\r\nstatic int c6x_ck_show(struct seq_file *m, void *v)\r\n{\r\nstruct clk *clk;\r\nmutex_lock(&clocks_mutex);\r\nlist_for_each_entry(clk, &clocks, node)\r\nif (!clk->parent)\r\ndump_clock(m, 0, clk);\r\nmutex_unlock(&clocks_mutex);\r\nreturn 0;\r\n}\r\nstatic int c6x_ck_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, c6x_ck_show, NULL);\r\n}\r\nstatic int __init c6x_clk_debugfs_init(void)\r\n{\r\ndebugfs_create_file("c6x_clocks", S_IFREG | S_IRUGO, NULL, NULL,\r\n&c6x_ck_operations);\r\nreturn 0;\r\n}
