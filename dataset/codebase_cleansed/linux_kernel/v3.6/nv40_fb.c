void\r\nnv40_fb_set_tile_region(struct drm_device *dev, int i)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_tile_reg *tile = &dev_priv->tile.reg[i];\r\nswitch (dev_priv->chipset) {\r\ncase 0x40:\r\nnv_wr32(dev, NV10_PFB_TLIMIT(i), tile->limit);\r\nnv_wr32(dev, NV10_PFB_TSIZE(i), tile->pitch);\r\nnv_wr32(dev, NV10_PFB_TILE(i), tile->addr);\r\nbreak;\r\ndefault:\r\nnv_wr32(dev, NV40_PFB_TLIMIT(i), tile->limit);\r\nnv_wr32(dev, NV40_PFB_TSIZE(i), tile->pitch);\r\nnv_wr32(dev, NV40_PFB_TILE(i), tile->addr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nnv40_fb_init_gart(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *gart = dev_priv->gart_info.sg_ctxdma;\r\nif (dev_priv->gart_info.type != NOUVEAU_GART_HW) {\r\nnv_wr32(dev, 0x100800, 0x00000001);\r\nreturn;\r\n}\r\nnv_wr32(dev, 0x100800, gart->pinst | 0x00000002);\r\nnv_mask(dev, 0x10008c, 0x00000100, 0x00000100);\r\nnv_wr32(dev, 0x100820, 0x00000000);\r\n}\r\nstatic void\r\nnv44_fb_init_gart(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *gart = dev_priv->gart_info.sg_ctxdma;\r\nu32 vinst;\r\nif (dev_priv->gart_info.type != NOUVEAU_GART_HW) {\r\nnv_wr32(dev, 0x100850, 0x80000000);\r\nnv_wr32(dev, 0x100800, 0x00000001);\r\nreturn;\r\n}\r\nvinst = nv_rd32(dev, 0x10020c);\r\nvinst -= ((gart->pinst >> 19) + 1) << 19;\r\nnv_wr32(dev, 0x100850, 0x80000000);\r\nnv_wr32(dev, 0x100818, dev_priv->gart_info.dummy.addr);\r\nnv_wr32(dev, 0x100804, dev_priv->gart_info.aper_size);\r\nnv_wr32(dev, 0x100850, 0x00008000);\r\nnv_mask(dev, 0x10008c, 0x00000200, 0x00000200);\r\nnv_wr32(dev, 0x100820, 0x00000000);\r\nnv_wr32(dev, 0x10082c, 0x00000001);\r\nnv_wr32(dev, 0x100800, vinst | 0x00000010);\r\n}\r\nint\r\nnv40_fb_vram_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->chipset == 0x40) {\r\nu32 pbus1218 = nv_rd32(dev, 0x001218);\r\nswitch (pbus1218 & 0x00000300) {\r\ncase 0x00000000: dev_priv->vram_type = NV_MEM_TYPE_SDRAM; break;\r\ncase 0x00000100: dev_priv->vram_type = NV_MEM_TYPE_DDR1; break;\r\ncase 0x00000200: dev_priv->vram_type = NV_MEM_TYPE_GDDR3; break;\r\ncase 0x00000300: dev_priv->vram_type = NV_MEM_TYPE_DDR2; break;\r\n}\r\n} else\r\nif (dev_priv->chipset == 0x49 || dev_priv->chipset == 0x4b) {\r\nu32 pfb914 = nv_rd32(dev, 0x100914);\r\nswitch (pfb914 & 0x00000003) {\r\ncase 0x00000000: dev_priv->vram_type = NV_MEM_TYPE_DDR1; break;\r\ncase 0x00000001: dev_priv->vram_type = NV_MEM_TYPE_DDR2; break;\r\ncase 0x00000002: dev_priv->vram_type = NV_MEM_TYPE_GDDR3; break;\r\ncase 0x00000003: break;\r\n}\r\n} else\r\nif (dev_priv->chipset != 0x4e) {\r\nu32 pfb474 = nv_rd32(dev, 0x100474);\r\nif (pfb474 & 0x00000004)\r\ndev_priv->vram_type = NV_MEM_TYPE_GDDR3;\r\nif (pfb474 & 0x00000002)\r\ndev_priv->vram_type = NV_MEM_TYPE_DDR2;\r\nif (pfb474 & 0x00000001)\r\ndev_priv->vram_type = NV_MEM_TYPE_DDR1;\r\n} else {\r\ndev_priv->vram_type = NV_MEM_TYPE_STOLEN;\r\n}\r\ndev_priv->vram_size = nv_rd32(dev, 0x10020c) & 0xff000000;\r\nreturn 0;\r\n}\r\nint\r\nnv40_fb_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fb_engine *pfb = &dev_priv->engine.fb;\r\nuint32_t tmp;\r\nint i;\r\nif (dev_priv->chipset != 0x40 && dev_priv->chipset != 0x45) {\r\nif (nv44_graph_class(dev))\r\nnv44_fb_init_gart(dev);\r\nelse\r\nnv40_fb_init_gart(dev);\r\n}\r\nswitch (dev_priv->chipset) {\r\ncase 0x40:\r\ncase 0x45:\r\ntmp = nv_rd32(dev, NV10_PFB_CLOSE_PAGE2);\r\nnv_wr32(dev, NV10_PFB_CLOSE_PAGE2, tmp & ~(1 << 15));\r\npfb->num_tiles = NV10_PFB_TILE__SIZE;\r\nbreak;\r\ncase 0x46:\r\ncase 0x47:\r\ncase 0x49:\r\ncase 0x4b:\r\ncase 0x4c:\r\npfb->num_tiles = NV40_PFB_TILE__SIZE_1;\r\nbreak;\r\ndefault:\r\npfb->num_tiles = NV40_PFB_TILE__SIZE_0;\r\nbreak;\r\n}\r\nfor (i = 0; i < pfb->num_tiles; i++)\r\npfb->set_tile_region(dev, i);\r\nreturn 0;\r\n}\r\nvoid\r\nnv40_fb_takedown(struct drm_device *dev)\r\n{\r\n}
