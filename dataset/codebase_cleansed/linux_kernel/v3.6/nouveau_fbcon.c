static void\r\nnouveau_fbcon_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct nouveau_fbdev *nfbdev = info->par;\r\nstruct drm_device *dev = nfbdev->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint ret;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nret = -ENODEV;\r\nif (!in_interrupt() && !(info->flags & FBINFO_HWACCEL_DISABLED) &&\r\nmutex_trylock(&dev_priv->channel->mutex)) {\r\nif (dev_priv->card_type < NV_50)\r\nret = nv04_fbcon_fillrect(info, rect);\r\nelse\r\nif (dev_priv->card_type < NV_C0)\r\nret = nv50_fbcon_fillrect(info, rect);\r\nelse\r\nret = nvc0_fbcon_fillrect(info, rect);\r\nmutex_unlock(&dev_priv->channel->mutex);\r\n}\r\nif (ret == 0)\r\nreturn;\r\nif (ret != -ENODEV)\r\nnouveau_fbcon_gpu_lockup(info);\r\ncfb_fillrect(info, rect);\r\n}\r\nstatic void\r\nnouveau_fbcon_copyarea(struct fb_info *info, const struct fb_copyarea *image)\r\n{\r\nstruct nouveau_fbdev *nfbdev = info->par;\r\nstruct drm_device *dev = nfbdev->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint ret;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nret = -ENODEV;\r\nif (!in_interrupt() && !(info->flags & FBINFO_HWACCEL_DISABLED) &&\r\nmutex_trylock(&dev_priv->channel->mutex)) {\r\nif (dev_priv->card_type < NV_50)\r\nret = nv04_fbcon_copyarea(info, image);\r\nelse\r\nif (dev_priv->card_type < NV_C0)\r\nret = nv50_fbcon_copyarea(info, image);\r\nelse\r\nret = nvc0_fbcon_copyarea(info, image);\r\nmutex_unlock(&dev_priv->channel->mutex);\r\n}\r\nif (ret == 0)\r\nreturn;\r\nif (ret != -ENODEV)\r\nnouveau_fbcon_gpu_lockup(info);\r\ncfb_copyarea(info, image);\r\n}\r\nstatic void\r\nnouveau_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct nouveau_fbdev *nfbdev = info->par;\r\nstruct drm_device *dev = nfbdev->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint ret;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nret = -ENODEV;\r\nif (!in_interrupt() && !(info->flags & FBINFO_HWACCEL_DISABLED) &&\r\nmutex_trylock(&dev_priv->channel->mutex)) {\r\nif (dev_priv->card_type < NV_50)\r\nret = nv04_fbcon_imageblit(info, image);\r\nelse\r\nif (dev_priv->card_type < NV_C0)\r\nret = nv50_fbcon_imageblit(info, image);\r\nelse\r\nret = nvc0_fbcon_imageblit(info, image);\r\nmutex_unlock(&dev_priv->channel->mutex);\r\n}\r\nif (ret == 0)\r\nreturn;\r\nif (ret != -ENODEV)\r\nnouveau_fbcon_gpu_lockup(info);\r\ncfb_imageblit(info, image);\r\n}\r\nstatic int\r\nnouveau_fbcon_sync(struct fb_info *info)\r\n{\r\nstruct nouveau_fbdev *nfbdev = info->par;\r\nstruct drm_device *dev = nfbdev->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_channel *chan = dev_priv->channel;\r\nint ret;\r\nif (!chan || !chan->accel_done || in_interrupt() ||\r\ninfo->state != FBINFO_STATE_RUNNING ||\r\ninfo->flags & FBINFO_HWACCEL_DISABLED)\r\nreturn 0;\r\nif (!mutex_trylock(&chan->mutex))\r\nreturn 0;\r\nret = nouveau_channel_idle(chan);\r\nmutex_unlock(&chan->mutex);\r\nif (ret) {\r\nnouveau_fbcon_gpu_lockup(info);\r\nreturn 0;\r\n}\r\nchan->accel_done = false;\r\nreturn 0;\r\n}\r\nstatic void nouveau_fbcon_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, int regno)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nnv_crtc->lut.r[regno] = red;\r\nnv_crtc->lut.g[regno] = green;\r\nnv_crtc->lut.b[regno] = blue;\r\n}\r\nstatic void nouveau_fbcon_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, int regno)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\n*red = nv_crtc->lut.r[regno];\r\n*green = nv_crtc->lut.g[regno];\r\n*blue = nv_crtc->lut.b[regno];\r\n}\r\nstatic void\r\nnouveau_fbcon_zfill(struct drm_device *dev, struct nouveau_fbdev *nfbdev)\r\n{\r\nstruct fb_info *info = nfbdev->helper.fbdev;\r\nstruct fb_fillrect rect;\r\nrect.dx = rect.dy = 0;\r\nrect.width = info->var.xres_virtual;\r\nrect.height = info->var.yres_virtual;\r\nrect.color = 0;\r\nrect.rop = ROP_COPY;\r\ninfo->fbops->fb_fillrect(info, &rect);\r\n}\r\nstatic int\r\nnouveau_fbcon_create(struct nouveau_fbdev *nfbdev,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct drm_device *dev = nfbdev->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb;\r\nstruct nouveau_framebuffer *nouveau_fb;\r\nstruct nouveau_channel *chan;\r\nstruct nouveau_bo *nvbo;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct pci_dev *pdev = dev->pdev;\r\nstruct device *device = &pdev->dev;\r\nint size, ret;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = mode_cmd.width * (sizes->surface_bpp >> 3);\r\nmode_cmd.pitches[0] = roundup(mode_cmd.pitches[0], 256);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nsize = roundup(size, PAGE_SIZE);\r\nret = nouveau_gem_new(dev, size, 0, NOUVEAU_GEM_DOMAIN_VRAM,\r\n0, 0x0000, &nvbo);\r\nif (ret) {\r\nNV_ERROR(dev, "failed to allocate framebuffer\n");\r\ngoto out;\r\n}\r\nret = nouveau_bo_pin(nvbo, TTM_PL_FLAG_VRAM);\r\nif (ret) {\r\nNV_ERROR(dev, "failed to pin fb: %d\n", ret);\r\nnouveau_bo_ref(NULL, &nvbo);\r\ngoto out;\r\n}\r\nret = nouveau_bo_map(nvbo);\r\nif (ret) {\r\nNV_ERROR(dev, "failed to map fb: %d\n", ret);\r\nnouveau_bo_unpin(nvbo);\r\nnouveau_bo_ref(NULL, &nvbo);\r\ngoto out;\r\n}\r\nchan = nouveau_nofbaccel ? NULL : dev_priv->channel;\r\nif (chan && dev_priv->card_type >= NV_50) {\r\nret = nouveau_bo_vma_add(nvbo, chan->vm, &nfbdev->nouveau_fb.vma);\r\nif (ret) {\r\nNV_ERROR(dev, "failed to map fb into chan: %d\n", ret);\r\nchan = NULL;\r\n}\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\ninfo = framebuffer_alloc(0, device);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\ninfo->par = nfbdev;\r\nnouveau_framebuffer_init(dev, &nfbdev->nouveau_fb, &mode_cmd, nvbo);\r\nnouveau_fb = &nfbdev->nouveau_fb;\r\nfb = &nouveau_fb->base;\r\nnfbdev->helper.fb = fb;\r\nnfbdev->helper.fbdev = info;\r\nstrcpy(info->fix.id, "nouveaufb");\r\nif (nouveau_nofbaccel)\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_DISABLED;\r\nelse\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT;\r\ninfo->flags |= FBINFO_CAN_FORCE_OUTPUT;\r\ninfo->fbops = &nouveau_fbcon_sw_ops;\r\ninfo->fix.smem_start = nvbo->bo.mem.bus.base +\r\nnvbo->bo.mem.bus.offset;\r\ninfo->fix.smem_len = size;\r\ninfo->screen_base = nvbo_kmap_obj_iovirtual(nouveau_fb->nvbo);\r\ninfo->screen_size = size;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, &nfbdev->helper, sizes->fb_width, sizes->fb_height);\r\ninfo->apertures = dev_priv->apertures;\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nif (dev_priv->channel && !nouveau_nofbaccel) {\r\nret = -ENODEV;\r\nif (dev_priv->card_type < NV_50)\r\nret = nv04_fbcon_accel_init(info);\r\nelse\r\nif (dev_priv->card_type < NV_C0)\r\nret = nv50_fbcon_accel_init(info);\r\nelse\r\nret = nvc0_fbcon_accel_init(info);\r\nif (ret == 0)\r\ninfo->fbops = &nouveau_fbcon_ops;\r\n}\r\nnouveau_fbcon_zfill(dev, nfbdev);\r\nNV_INFO(dev, "allocated %dx%d fb: 0x%lx, bo %p\n",\r\nnouveau_fb->base.width,\r\nnouveau_fb->base.height,\r\nnvbo->bo.offset, nvbo);\r\nvga_switcheroo_client_fb_set(dev->pdev, info);\r\nreturn 0;\r\nout_unref:\r\nmutex_unlock(&dev->struct_mutex);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_fbcon_find_or_create_single(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct nouveau_fbdev *nfbdev = (struct nouveau_fbdev *)helper;\r\nint new_fb = 0;\r\nint ret;\r\nif (!helper->fb) {\r\nret = nouveau_fbcon_create(nfbdev, sizes);\r\nif (ret)\r\nreturn ret;\r\nnew_fb = 1;\r\n}\r\nreturn new_fb;\r\n}\r\nvoid\r\nnouveau_fbcon_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\ndrm_fb_helper_hotplug_event(&dev_priv->nfbdev->helper);\r\n}\r\nstatic int\r\nnouveau_fbcon_destroy(struct drm_device *dev, struct nouveau_fbdev *nfbdev)\r\n{\r\nstruct nouveau_framebuffer *nouveau_fb = &nfbdev->nouveau_fb;\r\nstruct fb_info *info;\r\nif (nfbdev->helper.fbdev) {\r\ninfo = nfbdev->helper.fbdev;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nif (nouveau_fb->nvbo) {\r\nnouveau_bo_unmap(nouveau_fb->nvbo);\r\nnouveau_bo_vma_del(nouveau_fb->nvbo, &nouveau_fb->vma);\r\ndrm_gem_object_unreference_unlocked(nouveau_fb->nvbo->gem);\r\nnouveau_fb->nvbo = NULL;\r\n}\r\ndrm_fb_helper_fini(&nfbdev->helper);\r\ndrm_framebuffer_cleanup(&nouveau_fb->base);\r\nreturn 0;\r\n}\r\nvoid nouveau_fbcon_gpu_lockup(struct fb_info *info)\r\n{\r\nstruct nouveau_fbdev *nfbdev = info->par;\r\nstruct drm_device *dev = nfbdev->dev;\r\nNV_ERROR(dev, "GPU lockup - switching to software fbcon\n");\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\n}\r\nint nouveau_fbcon_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fbdev *nfbdev;\r\nint preferred_bpp;\r\nint ret;\r\nnfbdev = kzalloc(sizeof(struct nouveau_fbdev), GFP_KERNEL);\r\nif (!nfbdev)\r\nreturn -ENOMEM;\r\nnfbdev->dev = dev;\r\ndev_priv->nfbdev = nfbdev;\r\nnfbdev->helper.funcs = &nouveau_fbcon_helper_funcs;\r\nret = drm_fb_helper_init(dev, &nfbdev->helper,\r\ndev->mode_config.num_crtc, 4);\r\nif (ret) {\r\nkfree(nfbdev);\r\nreturn ret;\r\n}\r\ndrm_fb_helper_single_add_all_connectors(&nfbdev->helper);\r\nif (dev_priv->vram_size <= 32 * 1024 * 1024)\r\npreferred_bpp = 8;\r\nelse if (dev_priv->vram_size <= 64 * 1024 * 1024)\r\npreferred_bpp = 16;\r\nelse\r\npreferred_bpp = 32;\r\ndrm_fb_helper_initial_config(&nfbdev->helper, preferred_bpp);\r\nreturn 0;\r\n}\r\nvoid nouveau_fbcon_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (!dev_priv->nfbdev)\r\nreturn;\r\nnouveau_fbcon_destroy(dev, dev_priv->nfbdev);\r\nkfree(dev_priv->nfbdev);\r\ndev_priv->nfbdev = NULL;\r\n}\r\nvoid nouveau_fbcon_save_disable_accel(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\ndev_priv->nfbdev->saved_flags = dev_priv->nfbdev->helper.fbdev->flags;\r\ndev_priv->nfbdev->helper.fbdev->flags |= FBINFO_HWACCEL_DISABLED;\r\n}\r\nvoid nouveau_fbcon_restore_accel(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\ndev_priv->nfbdev->helper.fbdev->flags = dev_priv->nfbdev->saved_flags;\r\n}\r\nvoid nouveau_fbcon_set_suspend(struct drm_device *dev, int state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nconsole_lock();\r\nif (state == 0)\r\nnouveau_fbcon_save_disable_accel(dev);\r\nfb_set_suspend(dev_priv->nfbdev->helper.fbdev, state);\r\nif (state == 1)\r\nnouveau_fbcon_restore_accel(dev);\r\nconsole_unlock();\r\n}\r\nvoid nouveau_fbcon_zfill_all(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nnouveau_fbcon_zfill(dev, dev_priv->nfbdev);\r\n}
