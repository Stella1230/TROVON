static int r8a7779_sysc_pwr_on_off(struct r8a7779_pm_ch *r8a7779_ch,\r\nint sr_bit, int reg_offs)\r\n{\r\nint k;\r\nfor (k = 0; k < SYSCSR_RETRIES; k++) {\r\nif (ioread32(r8a7779_sysc_base + SYSCSR) & (1 << sr_bit))\r\nbreak;\r\nudelay(SYSCSR_DELAY_US);\r\n}\r\nif (k == SYSCSR_RETRIES)\r\nreturn -EAGAIN;\r\niowrite32(1 << r8a7779_ch->chan_bit,\r\nr8a7779_sysc_base + r8a7779_ch->chan_offs + reg_offs);\r\nreturn 0;\r\n}\r\nstatic int r8a7779_sysc_pwr_off(struct r8a7779_pm_ch *r8a7779_ch)\r\n{\r\nreturn r8a7779_sysc_pwr_on_off(r8a7779_ch, 0, PWROFFCR_OFFS);\r\n}\r\nstatic int r8a7779_sysc_pwr_on(struct r8a7779_pm_ch *r8a7779_ch)\r\n{\r\nreturn r8a7779_sysc_pwr_on_off(r8a7779_ch, 1, PWRONCR_OFFS);\r\n}\r\nstatic int r8a7779_sysc_update(struct r8a7779_pm_ch *r8a7779_ch,\r\nint (*on_off_fn)(struct r8a7779_pm_ch *))\r\n{\r\nunsigned int isr_mask = 1 << r8a7779_ch->isr_bit;\r\nunsigned int chan_mask = 1 << r8a7779_ch->chan_bit;\r\nunsigned int status;\r\nunsigned long flags;\r\nint ret = 0;\r\nint k;\r\nspin_lock_irqsave(&r8a7779_sysc_lock, flags);\r\niowrite32(isr_mask, r8a7779_sysc_base + SYSCISCR);\r\ndo {\r\nret = on_off_fn(r8a7779_ch);\r\nif (ret)\r\ngoto out;\r\nstatus = ioread32(r8a7779_sysc_base +\r\nr8a7779_ch->chan_offs + PWRER_OFFS);\r\n} while (status & chan_mask);\r\nfor (k = 0; k < SYSCISR_RETRIES; k++) {\r\nif (ioread32(r8a7779_sysc_base + SYSCISR) & isr_mask)\r\nbreak;\r\nudelay(SYSCISR_DELAY_US);\r\n}\r\nif (k == SYSCISR_RETRIES)\r\nret = -EIO;\r\niowrite32(isr_mask, r8a7779_sysc_base + SYSCISCR);\r\nout:\r\nspin_unlock_irqrestore(&r8a7779_sysc_lock, flags);\r\npr_debug("r8a7779 power domain %d: %02x %02x %02x %02x %02x -> %d\n",\r\nr8a7779_ch->isr_bit, ioread32(r8a7779_sysc_base + PWRSR0),\r\nioread32(r8a7779_sysc_base + PWRSR1),\r\nioread32(r8a7779_sysc_base + PWRSR2),\r\nioread32(r8a7779_sysc_base + PWRSR3),\r\nioread32(r8a7779_sysc_base + PWRSR4), ret);\r\nreturn ret;\r\n}\r\nint r8a7779_sysc_power_down(struct r8a7779_pm_ch *r8a7779_ch)\r\n{\r\nreturn r8a7779_sysc_update(r8a7779_ch, r8a7779_sysc_pwr_off);\r\n}\r\nint r8a7779_sysc_power_up(struct r8a7779_pm_ch *r8a7779_ch)\r\n{\r\nreturn r8a7779_sysc_update(r8a7779_ch, r8a7779_sysc_pwr_on);\r\n}\r\nstatic void __init r8a7779_sysc_init(void)\r\n{\r\nr8a7779_sysc_base = ioremap_nocache(0xffd85000, PAGE_SIZE);\r\nif (!r8a7779_sysc_base)\r\npanic("unable to ioremap r8a7779 SYSC hardware block\n");\r\niowrite32(0x0131000e, r8a7779_sysc_base + SYSCIER);\r\niowrite32(0, r8a7779_sysc_base + SYSCIMR);\r\n}\r\nstatic inline void r8a7779_sysc_init(void) {}\r\nstatic int pd_power_down(struct generic_pm_domain *genpd)\r\n{\r\nreturn r8a7779_sysc_power_down(to_r8a7779_ch(genpd));\r\n}\r\nstatic int pd_power_up(struct generic_pm_domain *genpd)\r\n{\r\nreturn r8a7779_sysc_power_up(to_r8a7779_ch(genpd));\r\n}\r\nstatic bool pd_is_off(struct generic_pm_domain *genpd)\r\n{\r\nstruct r8a7779_pm_ch *r8a7779_ch = to_r8a7779_ch(genpd);\r\nunsigned int st;\r\nst = ioread32(r8a7779_sysc_base + r8a7779_ch->chan_offs + PWRSR_OFFS);\r\nif (st & (1 << r8a7779_ch->chan_bit))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool pd_active_wakeup(struct device *dev)\r\n{\r\nreturn true;\r\n}\r\nvoid r8a7779_init_pm_domain(struct r8a7779_pm_domain *r8a7779_pd)\r\n{\r\nstruct generic_pm_domain *genpd = &r8a7779_pd->genpd;\r\npm_genpd_init(genpd, NULL, false);\r\ngenpd->dev_ops.stop = pm_clk_suspend;\r\ngenpd->dev_ops.start = pm_clk_resume;\r\ngenpd->dev_ops.active_wakeup = pd_active_wakeup;\r\ngenpd->dev_irq_safe = true;\r\ngenpd->power_off = pd_power_down;\r\ngenpd->power_on = pd_power_up;\r\nif (pd_is_off(&r8a7779_pd->genpd))\r\npd_power_up(&r8a7779_pd->genpd);\r\n}\r\nvoid r8a7779_add_device_to_domain(struct r8a7779_pm_domain *r8a7779_pd,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\npm_genpd_add_device(&r8a7779_pd->genpd, dev);\r\nif (pm_clk_no_clocks(dev))\r\npm_clk_add(dev, NULL);\r\n}\r\nvoid __init r8a7779_pm_init(void)\r\n{\r\nstatic int once;\r\nif (!once++)\r\nr8a7779_sysc_init();\r\n}
