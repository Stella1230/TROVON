void oz_event_init(void)\r\n{\r\noz_trace("Event tracing initialized\n");\r\nspin_lock_init(&g_evtdev.lock);\r\natomic_set(&g_evtdev.users, 0);\r\n}\r\nvoid oz_event_term(void)\r\n{\r\noz_trace("Event tracing terminated\n");\r\n}\r\nvoid oz_event_log2(u8 evt, u8 ctx1, u16 ctx2, void *ctx3, unsigned ctx4)\r\n{\r\nunsigned long irqstate;\r\nint ix;\r\nspin_lock_irqsave(&g_evtdev.lock, irqstate);\r\nix = (g_evtdev.evt_in + 1) & (OZ_MAX_EVTS - 1);\r\nif (ix != g_evtdev.evt_out) {\r\nstruct oz_event *e = &g_evtdev.evts[g_evtdev.evt_in];\r\ne->jiffies = jiffies;\r\ne->evt = evt;\r\ne->ctx1 = ctx1;\r\ne->ctx2 = ctx2;\r\ne->ctx3 = (__u32)(unsigned long)ctx3;\r\ne->ctx4 = ctx4;\r\ng_evtdev.evt_in = ix;\r\n} else {\r\ng_evtdev.missed_events++;\r\n}\r\nspin_unlock_irqrestore(&g_evtdev.lock, irqstate);\r\n}\r\nstatic void oz_events_clear(struct oz_evtdev *dev)\r\n{\r\nunsigned long irqstate;\r\noz_trace("Clearing events\n");\r\nspin_lock_irqsave(&dev->lock, irqstate);\r\ndev->evt_in = dev->evt_out = 0;\r\ndev->missed_events = 0;\r\nspin_unlock_irqrestore(&dev->lock, irqstate);\r\n}\r\nint oz_events_open(struct inode *inode, struct file *filp)\r\n{\r\noz_trace("oz_evt_open()\n");\r\noz_trace("Open flags: 0x%x\n", filp->f_flags);\r\nif (atomic_add_return(1, &g_evtdev.users) == 1) {\r\noz_events_clear(&g_evtdev);\r\nreturn nonseekable_open(inode, filp);\r\n} else {\r\natomic_dec(&g_evtdev.users);\r\nreturn -EBUSY;\r\n}\r\n}\r\nint oz_events_release(struct inode *inode, struct file *filp)\r\n{\r\noz_events_clear(&g_evtdev);\r\natomic_dec(&g_evtdev.users);\r\ng_evt_mask = 0;\r\noz_trace("oz_evt_release()\n");\r\nreturn 0;\r\n}\r\nssize_t oz_events_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *fpos)\r\n{\r\nstruct oz_evtdev *dev = &g_evtdev;\r\nint rc = 0;\r\nint nb_evts = count / sizeof(struct oz_event);\r\nint n;\r\nint sz;\r\nn = dev->evt_in - dev->evt_out;\r\nif (n < 0)\r\nn += OZ_MAX_EVTS;\r\nif (nb_evts > n)\r\nnb_evts = n;\r\nif (nb_evts == 0)\r\ngoto out;\r\nn = OZ_MAX_EVTS - dev->evt_out;\r\nif (n > nb_evts)\r\nn = nb_evts;\r\nsz = n * sizeof(struct oz_event);\r\nif (copy_to_user(buf, &dev->evts[dev->evt_out], sz)) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nif (n == nb_evts)\r\ngoto out2;\r\nn = nb_evts - n;\r\nif (copy_to_user(buf + sz, dev->evts, n * sizeof(struct oz_event))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nout2:\r\ndev->evt_out = (dev->evt_out + nb_evts) & (OZ_MAX_EVTS - 1);\r\nrc = nb_evts * sizeof(struct oz_event);\r\nout:\r\nreturn rc;\r\n}\r\nvoid oz_debugfs_init(void)\r\n{\r\nstruct dentry *parent;\r\nparent = debugfs_create_dir("ozwpan", NULL);\r\nif (parent == NULL) {\r\noz_trace("Failed to create debugfs directory ozmo\n");\r\nreturn;\r\n} else {\r\ng_evtdev.root_dir = parent;\r\nif (debugfs_create_file("events", S_IRUSR, parent, NULL,\r\n&oz_events_fops) == NULL)\r\noz_trace("Failed to create file ozmo/events\n");\r\nif (debugfs_create_x32("event_mask", S_IRUSR | S_IWUSR, parent,\r\n&g_evt_mask) == NULL)\r\noz_trace("Failed to create file ozmo/event_mask\n");\r\n}\r\n}\r\nvoid oz_debugfs_remove(void)\r\n{\r\ndebugfs_remove_recursive(g_evtdev.root_dir);\r\n}
