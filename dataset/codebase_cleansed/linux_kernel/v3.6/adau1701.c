static unsigned int adau1701_register_size(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ADAU1701_DSPCTRL:\r\ncase ADAU1701_SEROCTL:\r\ncase ADAU1701_AUXNPOW:\r\ncase ADAU1701_OSCIPOW:\r\ncase ADAU1701_DACSET:\r\nreturn 2;\r\ncase ADAU1701_SERICTL:\r\nreturn 1;\r\n}\r\ndev_err(codec->dev, "Unsupported register address: %d\n", reg);\r\nreturn 0;\r\n}\r\nstatic int adau1701_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nunsigned int i;\r\nunsigned int size;\r\nuint8_t buf[4];\r\nint ret;\r\nsize = adau1701_register_size(codec, reg);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nsnd_soc_cache_write(codec, reg, value);\r\nbuf[0] = 0x08;\r\nbuf[1] = reg;\r\nfor (i = size + 1; i >= 2; --i) {\r\nbuf[i] = value;\r\nvalue >>= 8;\r\n}\r\nret = i2c_master_send(to_i2c_client(codec->dev), buf, size + 2);\r\nif (ret == size + 2)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic unsigned int adau1701_read(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nunsigned int value;\r\nunsigned int ret;\r\nret = snd_soc_cache_read(codec, reg, &value);\r\nif (ret)\r\nreturn ret;\r\nreturn value;\r\n}\r\nstatic int adau1701_load_firmware(struct snd_soc_codec *codec)\r\n{\r\nreturn process_sigma_firmware(codec->control_data, ADAU1701_FIRMWARE);\r\n}\r\nstatic int adau1701_set_capture_pcm_format(struct snd_soc_codec *codec,\r\nsnd_pcm_format_t format)\r\n{\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int mask = ADAU1701_SEROCTL_WORD_LEN_MASK;\r\nunsigned int val;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval = ADAU1701_SEROCTL_WORD_LEN_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval = ADAU1701_SEROCTL_WORD_LEN_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval = ADAU1701_SEROCTL_WORD_LEN_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (adau1701->dai_fmt == SND_SOC_DAIFMT_RIGHT_J) {\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval |= ADAU1701_SEROCTL_MSB_DEALY16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval |= ADAU1701_SEROCTL_MSB_DEALY12;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval |= ADAU1701_SEROCTL_MSB_DEALY8;\r\nbreak;\r\n}\r\nmask |= ADAU1701_SEROCTL_MSB_DEALY_MASK;\r\n}\r\nsnd_soc_update_bits(codec, ADAU1701_SEROCTL, mask, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_set_playback_pcm_format(struct snd_soc_codec *codec,\r\nsnd_pcm_format_t format)\r\n{\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (adau1701->dai_fmt != SND_SOC_DAIFMT_RIGHT_J)\r\nreturn 0;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval = ADAU1701_SERICTL_RIGHTJ_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval = ADAU1701_SERICTL_RIGHTJ_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval = ADAU1701_SERICTL_RIGHTJ_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, ADAU1701_SERICTL,\r\nADAU1701_SERICTL_MODE_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nsnd_pcm_format_t format;\r\nunsigned int val;\r\nswitch (params_rate(params)) {\r\ncase 192000:\r\nval = ADAU1701_DSPCTRL_SR_192;\r\nbreak;\r\ncase 96000:\r\nval = ADAU1701_DSPCTRL_SR_96;\r\nbreak;\r\ncase 48000:\r\nval = ADAU1701_DSPCTRL_SR_48;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, ADAU1701_DSPCTRL,\r\nADAU1701_DSPCTRL_SR_MASK, val);\r\nformat = params_format(params);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn adau1701_set_playback_pcm_format(codec, format);\r\nelse\r\nreturn adau1701_set_capture_pcm_format(codec, format);\r\n}\r\nstatic int adau1701_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int serictl = 0x00, seroctl = 0x00;\r\nbool invert_lrclk;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nseroctl |= ADAU1701_SEROCTL_MASTER | ADAU1701_SEROCTL_OBF16\r\n| ADAU1701_SEROCTL_OLF1024;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ninvert_lrclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ninvert_lrclk = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ninvert_lrclk = false;\r\nserictl |= ADAU1701_SERICTL_INV_BCLK;\r\nseroctl |= ADAU1701_SEROCTL_INV_BCLK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ninvert_lrclk = true;\r\nserictl |= ADAU1701_SERICTL_INV_BCLK;\r\nseroctl |= ADAU1701_SEROCTL_INV_BCLK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nserictl |= ADAU1701_SERICTL_LEFTJ;\r\nseroctl |= ADAU1701_SEROCTL_MSB_DEALY0;\r\ninvert_lrclk = !invert_lrclk;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nserictl |= ADAU1701_SERICTL_RIGHTJ_24;\r\nseroctl |= ADAU1701_SEROCTL_MSB_DEALY8;\r\ninvert_lrclk = !invert_lrclk;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (invert_lrclk) {\r\nseroctl |= ADAU1701_SEROCTL_INV_LRCLK;\r\nserictl |= ADAU1701_SERICTL_INV_LRCLK;\r\n}\r\nadau1701->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nsnd_soc_write(codec, ADAU1701_SERICTL, serictl);\r\nsnd_soc_update_bits(codec, ADAU1701_SEROCTL,\r\n~ADAU1701_SEROCTL_WORD_LEN_MASK, seroctl);\r\nreturn 0;\r\n}\r\nstatic int adau1701_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nunsigned int mask = ADAU1701_AUXNPOW_VBPD | ADAU1701_AUXNPOW_VRPD;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, ADAU1701_AUXNPOW, mask, 0x00);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, ADAU1701_AUXNPOW, mask, mask);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int adau1701_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int mask = ADAU1701_DSPCTRL_DAM;\r\nunsigned int val;\r\nif (mute)\r\nval = 0;\r\nelse\r\nval = mask;\r\nsnd_soc_update_bits(codec, ADAU1701_DSPCTRL, mask, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nunsigned int val;\r\nswitch (clk_id) {\r\ncase ADAU1701_CLK_SRC_OSC:\r\nval = 0x0;\r\nbreak;\r\ncase ADAU1701_CLK_SRC_MCLK:\r\nval = ADAU1701_OSCIPOW_OPD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, ADAU1701_OSCIPOW, ADAU1701_OSCIPOW_OPD, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\ncodec->control_data = to_i2c_client(codec->dev);\r\nret = adau1701_load_firmware(codec);\r\nif (ret)\r\ndev_warn(codec->dev, "Failed to load firmware\n");\r\nsnd_soc_write(codec, ADAU1701_DACSET, ADAU1701_DACSET_DACINIT);\r\nsnd_soc_write(codec, ADAU1701_DSPCTRL, ADAU1701_DSPCTRL_CR);\r\nreturn 0;\r\n}\r\nstatic __devinit int adau1701_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adau1701 *adau1701;\r\nint ret;\r\nadau1701 = devm_kzalloc(&client->dev, sizeof(*adau1701), GFP_KERNEL);\r\nif (!adau1701)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, adau1701);\r\nret = snd_soc_register_codec(&client->dev, &adau1701_codec_drv,\r\n&adau1701_dai, 1);\r\nreturn ret;\r\n}\r\nstatic __devexit int adau1701_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init adau1701_init(void)\r\n{\r\nreturn i2c_add_driver(&adau1701_i2c_driver);\r\n}\r\nstatic void __exit adau1701_exit(void)\r\n{\r\ni2c_del_driver(&adau1701_i2c_driver);\r\n}
