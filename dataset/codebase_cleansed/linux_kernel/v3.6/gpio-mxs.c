static inline int is_imx23_gpio(struct mxs_gpio_port *port)\r\n{\r\nreturn port->devid == IMX23_GPIO;\r\n}\r\nstatic inline int is_imx28_gpio(struct mxs_gpio_port *port)\r\n{\r\nreturn port->devid == IMX28_GPIO;\r\n}\r\nstatic int mxs_gpio_set_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nu32 gpio = irq_to_gpio(d->irq);\r\nu32 pin_mask = 1 << (gpio & 31);\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxs_gpio_port *port = gc->private;\r\nvoid __iomem *pin_addr;\r\nint edge;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nedge = GPIO_INT_RISE_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nedge = GPIO_INT_FALL_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nedge = GPIO_INT_LOW_LEV;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nedge = GPIO_INT_HIGH_LEV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npin_addr = port->base + PINCTRL_IRQLEV(port);\r\nif (edge & GPIO_INT_LEV_MASK)\r\nwritel(pin_mask, pin_addr + MXS_SET);\r\nelse\r\nwritel(pin_mask, pin_addr + MXS_CLR);\r\npin_addr = port->base + PINCTRL_IRQPOL(port);\r\nif (edge & GPIO_INT_POL_MASK)\r\nwritel(pin_mask, pin_addr + MXS_SET);\r\nelse\r\nwritel(pin_mask, pin_addr + MXS_CLR);\r\nwritel(1 << (gpio & 0x1f),\r\nport->base + PINCTRL_IRQSTAT(port) + MXS_CLR);\r\nreturn 0;\r\n}\r\nstatic void mxs_gpio_irq_handler(u32 irq, struct irq_desc *desc)\r\n{\r\nu32 irq_stat;\r\nstruct mxs_gpio_port *port = irq_get_handler_data(irq);\r\nu32 gpio_irq_no_base = port->virtual_irq_start;\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nirq_stat = readl(port->base + PINCTRL_IRQSTAT(port)) &\r\nreadl(port->base + PINCTRL_IRQEN(port));\r\nwhile (irq_stat != 0) {\r\nint irqoffset = fls(irq_stat) - 1;\r\ngeneric_handle_irq(gpio_irq_no_base + irqoffset);\r\nirq_stat &= ~(1 << irqoffset);\r\n}\r\n}\r\nstatic int mxs_gpio_set_wake_irq(struct irq_data *d, unsigned int enable)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxs_gpio_port *port = gc->private;\r\nif (enable)\r\nenable_irq_wake(port->irq);\r\nelse\r\ndisable_irq_wake(port->irq);\r\nreturn 0;\r\n}\r\nstatic void __init mxs_gpio_init_gc(struct mxs_gpio_port *port)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("gpio-mxs", 1, port->virtual_irq_start,\r\nport->base, handle_level_irq);\r\ngc->private = port;\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_set_type = mxs_gpio_set_irq_type;\r\nct->chip.irq_set_wake = mxs_gpio_set_wake_irq;\r\nct->regs.ack = PINCTRL_IRQSTAT(port) + MXS_CLR;\r\nct->regs.mask = PINCTRL_IRQEN(port);\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), 0, IRQ_NOREQUEST, 0);\r\n}\r\nstatic int mxs_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nstruct mxs_gpio_port *port =\r\ncontainer_of(bgc, struct mxs_gpio_port, bgc);\r\nreturn port->virtual_irq_start + offset;\r\n}\r\nstatic int __devinit mxs_gpio_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_gpio_dt_ids, &pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *parent;\r\nstatic void __iomem *base;\r\nstruct mxs_gpio_port *port;\r\nstruct resource *iores = NULL;\r\nint err;\r\nport = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nif (np) {\r\nport->id = of_alias_get_id(np, "gpio");\r\nif (port->id < 0)\r\nreturn port->id;\r\nport->devid = (enum mxs_gpio_id) of_id->data;\r\n} else {\r\nport->id = pdev->id;\r\nport->devid = pdev->id_entry->driver_data;\r\n}\r\nport->virtual_irq_start = MXS_GPIO_IRQ_START + port->id * 32;\r\nport->irq = platform_get_irq(pdev, 0);\r\nif (port->irq < 0)\r\nreturn port->irq;\r\nif (!base) {\r\nif (np) {\r\nparent = of_get_parent(np);\r\nbase = of_iomap(parent, 0);\r\nof_node_put(parent);\r\n} else {\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_request_and_ioremap(&pdev->dev, iores);\r\n}\r\nif (!base)\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nport->base = base;\r\nwritel(~0U, port->base + PINCTRL_PIN2IRQ(port));\r\nwritel(0, port->base + PINCTRL_IRQEN(port));\r\nwritel(~0U, port->base + PINCTRL_IRQSTAT(port) + MXS_CLR);\r\nmxs_gpio_init_gc(port);\r\nirq_set_chained_handler(port->irq, mxs_gpio_irq_handler);\r\nirq_set_handler_data(port->irq, port);\r\nerr = bgpio_init(&port->bgc, &pdev->dev, 4,\r\nport->base + PINCTRL_DIN(port),\r\nport->base + PINCTRL_DOUT(port), NULL,\r\nport->base + PINCTRL_DOE(port), NULL, 0);\r\nif (err)\r\nreturn err;\r\nport->bgc.gc.to_irq = mxs_gpio_to_irq;\r\nport->bgc.gc.base = port->id * 32;\r\nerr = gpiochip_add(&port->bgc.gc);\r\nif (err) {\r\nbgpio_remove(&port->bgc);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mxs_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&mxs_gpio_driver);\r\n}
