static void mio_cs_win_out(struct comedi_device *dev, uint16_t data, int addr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nif (addr < 8) {\r\nni_writew(data, addr * 2);\r\n} else {\r\nni_writew(addr, Window_Address);\r\nni_writew(data, Window_Data);\r\n}\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nstatic uint16_t mio_cs_win_in(struct comedi_device *dev, int addr)\r\n{\r\nunsigned long flags;\r\nuint16_t ret;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nif (addr < 8) {\r\nret = ni_readw(addr * 2);\r\n} else {\r\nni_writew(addr, Window_Address);\r\nret = ni_readw(Window_Data);\r\n}\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void mio_cs_detach(struct comedi_device *dev)\r\n{\r\nmio_common_detach(dev);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\n}\r\nstatic int cs_attach(struct pcmcia_device *link)\r\n{\r\ncur_dev = link;\r\nmio_cs_config(link);\r\nreturn 0;\r\n}\r\nstatic void cs_release(struct pcmcia_device *link)\r\n{\r\npcmcia_disable_device(link);\r\n}\r\nstatic void cs_detach(struct pcmcia_device *link)\r\n{\r\ncs_release(link);\r\n}\r\nstatic int mio_cs_suspend(struct pcmcia_device *link)\r\n{\r\nDPRINTK("pm suspend\n");\r\nreturn 0;\r\n}\r\nstatic int mio_cs_resume(struct pcmcia_device *link)\r\n{\r\nDPRINTK("pm resume\n");\r\nreturn 0;\r\n}\r\nstatic int mio_pcmcia_config_loop(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint base, ret;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\r\nfor (base = 0x000; base < 0x400; base += 0x20) {\r\np_dev->resource[0]->start = base;\r\nret = pcmcia_request_io(p_dev);\r\nif (!ret)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void mio_cs_config(struct pcmcia_device *link)\r\n{\r\nint ret;\r\nDPRINTK("mio_cs_config(link=%p)\n", link);\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nret = pcmcia_loop_config(link, mio_pcmcia_config_loop, NULL);\r\nif (ret) {\r\ndev_warn(&link->dev, "no configuration found\n");\r\nreturn;\r\n}\r\nif (!link->irq)\r\ndev_info(&link->dev, "no IRQ available\n");\r\nret = pcmcia_enable_device(link);\r\n}\r\nstatic int mio_cs_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct pcmcia_device *link;\r\nunsigned int irq;\r\nint ret;\r\nDPRINTK("mio_cs_attach(dev=%p,it=%p)\n", dev, it);\r\nlink = cur_dev;\r\nif (!link)\r\nreturn -EIO;\r\ndev->driver = &driver_ni_mio_cs;\r\ndev->iobase = link->resource[0]->start;\r\nirq = link->irq;\r\nprintk("comedi%d: %s: DAQCard: io 0x%04lx, irq %u, ",\r\ndev->minor, dev->driver->driver_name, dev->iobase, irq);\r\n#if 0\r\n{\r\nint i;\r\nprintk(" board fingerprint:");\r\nfor (i = 0; i < 32; i += 2) {\r\nprintk(" %04x %02x", inw(dev->iobase + i),\r\ninb(dev->iobase + i + 1));\r\n}\r\nprintk("\n");\r\nprintk(" board fingerprint (windowed):");\r\nfor (i = 0; i < 10; i++)\r\nprintk(" 0x%04x", win_in(i));\r\nprintk("\n");\r\n}\r\n#endif\r\ndev->board_ptr = ni_boards + ni_getboardtype(dev, link);\r\nprintk(" %s", boardtype.name);\r\ndev->board_name = boardtype.name;\r\nret = request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,\r\n"ni_mio_cs", dev);\r\nif (ret < 0) {\r\nprintk(" irq not available\n");\r\nreturn -EINVAL;\r\n}\r\ndev->irq = irq;\r\nret = ni_alloc_private(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndevpriv->stc_writew = &mio_cs_win_out;\r\ndevpriv->stc_readw = &mio_cs_win_in;\r\ndevpriv->stc_writel = &win_out2;\r\ndevpriv->stc_readl = &win_in2;\r\nret = ni_E_init(dev, it);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ni_getboardtype(struct comedi_device *dev,\r\nstruct pcmcia_device *link)\r\n{\r\nint i;\r\nfor (i = 0; i < n_ni_boards; i++) {\r\nif (ni_boards[i].device_id == link->card_id)\r\nreturn i;\r\n}\r\nprintk("unknown board 0x%04x -- pretend it is a ", link->card_id);\r\nreturn 0;\r\n}\r\nint init_module(void)\r\n{\r\npcmcia_register_driver(&ni_mio_cs_driver);\r\ncomedi_driver_register(&driver_ni_mio_cs);\r\nreturn 0;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\npcmcia_unregister_driver(&ni_mio_cs_driver);\r\n#if 0\r\nwhile (cur_dev != NULL)\r\ncs_detach(cur_dev->handle);\r\n#endif\r\ncomedi_driver_unregister(&driver_ni_mio_cs);\r\n}
