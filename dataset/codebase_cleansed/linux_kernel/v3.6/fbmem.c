static struct fb_info *get_fb_info(unsigned int idx)\r\n{\r\nstruct fb_info *fb_info;\r\nif (idx >= FB_MAX)\r\nreturn ERR_PTR(-ENODEV);\r\nmutex_lock(&registration_lock);\r\nfb_info = registered_fb[idx];\r\nif (fb_info)\r\natomic_inc(&fb_info->count);\r\nmutex_unlock(&registration_lock);\r\nreturn fb_info;\r\n}\r\nstatic void put_fb_info(struct fb_info *fb_info)\r\n{\r\nif (!atomic_dec_and_test(&fb_info->count))\r\nreturn;\r\nif (fb_info->fbops->fb_destroy)\r\nfb_info->fbops->fb_destroy(fb_info);\r\n}\r\nint lock_fb_info(struct fb_info *info)\r\n{\r\nmutex_lock(&info->lock);\r\nif (!info->fbops) {\r\nmutex_unlock(&info->lock);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint fb_get_color_depth(struct fb_var_screeninfo *var,\r\nstruct fb_fix_screeninfo *fix)\r\n{\r\nint depth = 0;\r\nif (fix->visual == FB_VISUAL_MONO01 ||\r\nfix->visual == FB_VISUAL_MONO10)\r\ndepth = 1;\r\nelse {\r\nif (var->green.length == var->blue.length &&\r\nvar->green.length == var->red.length &&\r\nvar->green.offset == var->blue.offset &&\r\nvar->green.offset == var->red.offset)\r\ndepth = var->green.length;\r\nelse\r\ndepth = var->green.length + var->red.length +\r\nvar->blue.length;\r\n}\r\nreturn depth;\r\n}\r\nvoid fb_pad_aligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 s_pitch, u32 height)\r\n{\r\n__fb_pad_aligned_buffer(dst, d_pitch, src, s_pitch, height);\r\n}\r\nvoid fb_pad_unaligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 idx, u32 height,\r\nu32 shift_high, u32 shift_low, u32 mod)\r\n{\r\nu8 mask = (u8) (0xfff << shift_high), tmp;\r\nint i, j;\r\nfor (i = height; i--; ) {\r\nfor (j = 0; j < idx; j++) {\r\ntmp = dst[j];\r\ntmp &= mask;\r\ntmp |= *src >> shift_low;\r\ndst[j] = tmp;\r\ntmp = *src << shift_high;\r\ndst[j+1] = tmp;\r\nsrc++;\r\n}\r\ntmp = dst[idx];\r\ntmp &= mask;\r\ntmp |= *src >> shift_low;\r\ndst[idx] = tmp;\r\nif (shift_high < mod) {\r\ntmp = *src << shift_high;\r\ndst[idx+1] = tmp;\r\n}\r\nsrc++;\r\ndst += d_pitch;\r\n}\r\n}\r\nchar* fb_get_buffer_offset(struct fb_info *info, struct fb_pixmap *buf, u32 size)\r\n{\r\nu32 align = buf->buf_align - 1, offset;\r\nchar *addr = buf->addr;\r\nif (buf->flags & FB_PIXMAP_IO) {\r\nif (info->fbops->fb_sync && (buf->flags & FB_PIXMAP_SYNC))\r\ninfo->fbops->fb_sync(info);\r\nreturn addr;\r\n}\r\noffset = buf->offset + align;\r\noffset &= ~align;\r\nif (offset + size > buf->size) {\r\nif (info->fbops->fb_sync && (buf->flags & FB_PIXMAP_SYNC))\r\ninfo->fbops->fb_sync(info);\r\noffset = 0;\r\n}\r\nbuf->offset = offset + size;\r\naddr += offset;\r\nreturn addr;\r\n}\r\nstatic inline unsigned safe_shift(unsigned d, int n)\r\n{\r\nreturn n < 0 ? d >> -n : d << n;\r\n}\r\nstatic void fb_set_logocmap(struct fb_info *info,\r\nconst struct linux_logo *logo)\r\n{\r\nstruct fb_cmap palette_cmap;\r\nu16 palette_green[16];\r\nu16 palette_blue[16];\r\nu16 palette_red[16];\r\nint i, j, n;\r\nconst unsigned char *clut = logo->clut;\r\npalette_cmap.start = 0;\r\npalette_cmap.len = 16;\r\npalette_cmap.red = palette_red;\r\npalette_cmap.green = palette_green;\r\npalette_cmap.blue = palette_blue;\r\npalette_cmap.transp = NULL;\r\nfor (i = 0; i < logo->clutsize; i += n) {\r\nn = logo->clutsize - i;\r\nif (n > 16)\r\nn = 16;\r\npalette_cmap.start = 32 + i;\r\npalette_cmap.len = n;\r\nfor (j = 0; j < n; ++j) {\r\npalette_cmap.red[j] = clut[0] << 8 | clut[0];\r\npalette_cmap.green[j] = clut[1] << 8 | clut[1];\r\npalette_cmap.blue[j] = clut[2] << 8 | clut[2];\r\nclut += 3;\r\n}\r\nfb_set_cmap(&palette_cmap, info);\r\n}\r\n}\r\nstatic void fb_set_logo_truepalette(struct fb_info *info,\r\nconst struct linux_logo *logo,\r\nu32 *palette)\r\n{\r\nstatic const unsigned char mask[] = { 0,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff };\r\nunsigned char redmask, greenmask, bluemask;\r\nint redshift, greenshift, blueshift;\r\nint i;\r\nconst unsigned char *clut = logo->clut;\r\nredmask = mask[info->var.red.length < 8 ? info->var.red.length : 8];\r\ngreenmask = mask[info->var.green.length < 8 ? info->var.green.length : 8];\r\nbluemask = mask[info->var.blue.length < 8 ? info->var.blue.length : 8];\r\nredshift = info->var.red.offset - (8 - info->var.red.length);\r\ngreenshift = info->var.green.offset - (8 - info->var.green.length);\r\nblueshift = info->var.blue.offset - (8 - info->var.blue.length);\r\nfor ( i = 0; i < logo->clutsize; i++) {\r\npalette[i+32] = (safe_shift((clut[0] & redmask), redshift) |\r\nsafe_shift((clut[1] & greenmask), greenshift) |\r\nsafe_shift((clut[2] & bluemask), blueshift));\r\nclut += 3;\r\n}\r\n}\r\nstatic void fb_set_logo_directpalette(struct fb_info *info,\r\nconst struct linux_logo *logo,\r\nu32 *palette)\r\n{\r\nint redshift, greenshift, blueshift;\r\nint i;\r\nredshift = info->var.red.offset;\r\ngreenshift = info->var.green.offset;\r\nblueshift = info->var.blue.offset;\r\nfor (i = 32; i < 32 + logo->clutsize; i++)\r\npalette[i] = i << redshift | i << greenshift | i << blueshift;\r\n}\r\nstatic void fb_set_logo(struct fb_info *info,\r\nconst struct linux_logo *logo, u8 *dst,\r\nint depth)\r\n{\r\nint i, j, k;\r\nconst u8 *src = logo->data;\r\nu8 xor = (info->fix.visual == FB_VISUAL_MONO01) ? 0xff : 0;\r\nu8 fg = 1, d;\r\nswitch (fb_get_color_depth(&info->var, &info->fix)) {\r\ncase 1:\r\nfg = 1;\r\nbreak;\r\ncase 2:\r\nfg = 3;\r\nbreak;\r\ndefault:\r\nfg = 7;\r\nbreak;\r\n}\r\nif (info->fix.visual == FB_VISUAL_MONO01 ||\r\ninfo->fix.visual == FB_VISUAL_MONO10)\r\nfg = ~((u8) (0xfff << info->var.green.length));\r\nswitch (depth) {\r\ncase 4:\r\nfor (i = 0; i < logo->height; i++)\r\nfor (j = 0; j < logo->width; src++) {\r\n*dst++ = *src >> 4;\r\nj++;\r\nif (j < logo->width) {\r\n*dst++ = *src & 0x0f;\r\nj++;\r\n}\r\n}\r\nbreak;\r\ncase 1:\r\nfor (i = 0; i < logo->height; i++) {\r\nfor (j = 0; j < logo->width; src++) {\r\nd = *src ^ xor;\r\nfor (k = 7; k >= 0; k--) {\r\n*dst++ = ((d >> k) & 1) ? fg : 0;\r\nj++;\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void fb_rotate_logo_ud(const u8 *in, u8 *out, u32 width, u32 height)\r\n{\r\nu32 size = width * height, i;\r\nout += size - 1;\r\nfor (i = size; i--; )\r\n*out-- = *in++;\r\n}\r\nstatic void fb_rotate_logo_cw(const u8 *in, u8 *out, u32 width, u32 height)\r\n{\r\nint i, j, h = height - 1;\r\nfor (i = 0; i < height; i++)\r\nfor (j = 0; j < width; j++)\r\nout[height * j + h - i] = *in++;\r\n}\r\nstatic void fb_rotate_logo_ccw(const u8 *in, u8 *out, u32 width, u32 height)\r\n{\r\nint i, j, w = width - 1;\r\nfor (i = 0; i < height; i++)\r\nfor (j = 0; j < width; j++)\r\nout[height * (w - j) + i] = *in++;\r\n}\r\nstatic void fb_rotate_logo(struct fb_info *info, u8 *dst,\r\nstruct fb_image *image, int rotate)\r\n{\r\nu32 tmp;\r\nif (rotate == FB_ROTATE_UD) {\r\nfb_rotate_logo_ud(image->data, dst, image->width,\r\nimage->height);\r\nimage->dx = info->var.xres - image->width - image->dx;\r\nimage->dy = info->var.yres - image->height - image->dy;\r\n} else if (rotate == FB_ROTATE_CW) {\r\nfb_rotate_logo_cw(image->data, dst, image->width,\r\nimage->height);\r\ntmp = image->width;\r\nimage->width = image->height;\r\nimage->height = tmp;\r\ntmp = image->dy;\r\nimage->dy = image->dx;\r\nimage->dx = info->var.xres - image->width - tmp;\r\n} else if (rotate == FB_ROTATE_CCW) {\r\nfb_rotate_logo_ccw(image->data, dst, image->width,\r\nimage->height);\r\ntmp = image->width;\r\nimage->width = image->height;\r\nimage->height = tmp;\r\ntmp = image->dx;\r\nimage->dx = image->dy;\r\nimage->dy = info->var.yres - image->height - tmp;\r\n}\r\nimage->data = dst;\r\n}\r\nstatic void fb_do_show_logo(struct fb_info *info, struct fb_image *image,\r\nint rotate, unsigned int num)\r\n{\r\nunsigned int x;\r\nif (rotate == FB_ROTATE_UR) {\r\nfor (x = 0;\r\nx < num && image->dx + image->width <= info->var.xres;\r\nx++) {\r\ninfo->fbops->fb_imageblit(info, image);\r\nimage->dx += image->width + 8;\r\n}\r\n} else if (rotate == FB_ROTATE_UD) {\r\nfor (x = 0; x < num && image->dx >= 0; x++) {\r\ninfo->fbops->fb_imageblit(info, image);\r\nimage->dx -= image->width + 8;\r\n}\r\n} else if (rotate == FB_ROTATE_CW) {\r\nfor (x = 0;\r\nx < num && image->dy + image->height <= info->var.yres;\r\nx++) {\r\ninfo->fbops->fb_imageblit(info, image);\r\nimage->dy += image->height + 8;\r\n}\r\n} else if (rotate == FB_ROTATE_CCW) {\r\nfor (x = 0; x < num && image->dy >= 0; x++) {\r\ninfo->fbops->fb_imageblit(info, image);\r\nimage->dy -= image->height + 8;\r\n}\r\n}\r\n}\r\nstatic int fb_show_logo_line(struct fb_info *info, int rotate,\r\nconst struct linux_logo *logo, int y,\r\nunsigned int n)\r\n{\r\nu32 *palette = NULL, *saved_pseudo_palette = NULL;\r\nunsigned char *logo_new = NULL, *logo_rotate = NULL;\r\nstruct fb_image image;\r\nif (logo == NULL || info->state != FBINFO_STATE_RUNNING ||\r\ninfo->flags & FBINFO_MODULE)\r\nreturn 0;\r\nimage.depth = 8;\r\nimage.data = logo->data;\r\nif (fb_logo.needs_cmapreset)\r\nfb_set_logocmap(info, logo);\r\nif (fb_logo.needs_truepalette ||\r\nfb_logo.needs_directpalette) {\r\npalette = kmalloc(256 * 4, GFP_KERNEL);\r\nif (palette == NULL)\r\nreturn 0;\r\nif (fb_logo.needs_truepalette)\r\nfb_set_logo_truepalette(info, logo, palette);\r\nelse\r\nfb_set_logo_directpalette(info, logo, palette);\r\nsaved_pseudo_palette = info->pseudo_palette;\r\ninfo->pseudo_palette = palette;\r\n}\r\nif (fb_logo.depth <= 4) {\r\nlogo_new = kmalloc(logo->width * logo->height, GFP_KERNEL);\r\nif (logo_new == NULL) {\r\nkfree(palette);\r\nif (saved_pseudo_palette)\r\ninfo->pseudo_palette = saved_pseudo_palette;\r\nreturn 0;\r\n}\r\nimage.data = logo_new;\r\nfb_set_logo(info, logo, logo_new, fb_logo.depth);\r\n}\r\nimage.dx = 0;\r\nimage.dy = y;\r\nimage.width = logo->width;\r\nimage.height = logo->height;\r\nif (rotate) {\r\nlogo_rotate = kmalloc(logo->width *\r\nlogo->height, GFP_KERNEL);\r\nif (logo_rotate)\r\nfb_rotate_logo(info, logo_rotate, &image, rotate);\r\n}\r\nfb_do_show_logo(info, &image, rotate, n);\r\nkfree(palette);\r\nif (saved_pseudo_palette != NULL)\r\ninfo->pseudo_palette = saved_pseudo_palette;\r\nkfree(logo_new);\r\nkfree(logo_rotate);\r\nreturn logo->height;\r\n}\r\nvoid fb_append_extra_logo(const struct linux_logo *logo, unsigned int n)\r\n{\r\nif (!n || fb_logo_ex_num == FB_LOGO_EX_NUM_MAX)\r\nreturn;\r\nfb_logo_ex[fb_logo_ex_num].logo = logo;\r\nfb_logo_ex[fb_logo_ex_num].n = n;\r\nfb_logo_ex_num++;\r\n}\r\nstatic int fb_prepare_extra_logos(struct fb_info *info, unsigned int height,\r\nunsigned int yres)\r\n{\r\nunsigned int i;\r\nif (info->fix.visual != FB_VISUAL_TRUECOLOR)\r\nfb_logo_ex_num = 0;\r\nfor (i = 0; i < fb_logo_ex_num; i++) {\r\nif (fb_logo_ex[i].logo->type != fb_logo.logo->type) {\r\nfb_logo_ex[i].logo = NULL;\r\ncontinue;\r\n}\r\nheight += fb_logo_ex[i].logo->height;\r\nif (height > yres) {\r\nheight -= fb_logo_ex[i].logo->height;\r\nfb_logo_ex_num = i;\r\nbreak;\r\n}\r\n}\r\nreturn height;\r\n}\r\nstatic int fb_show_extra_logos(struct fb_info *info, int y, int rotate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < fb_logo_ex_num; i++)\r\ny += fb_show_logo_line(info, rotate,\r\nfb_logo_ex[i].logo, y, fb_logo_ex[i].n);\r\nreturn y;\r\n}\r\nstatic inline int fb_prepare_extra_logos(struct fb_info *info,\r\nunsigned int height,\r\nunsigned int yres)\r\n{\r\nreturn height;\r\n}\r\nstatic inline int fb_show_extra_logos(struct fb_info *info, int y, int rotate)\r\n{\r\nreturn y;\r\n}\r\nint fb_prepare_logo(struct fb_info *info, int rotate)\r\n{\r\nint depth = fb_get_color_depth(&info->var, &info->fix);\r\nunsigned int yres;\r\nmemset(&fb_logo, 0, sizeof(struct logo_data));\r\nif (info->flags & FBINFO_MISC_TILEBLITTING ||\r\ninfo->flags & FBINFO_MODULE)\r\nreturn 0;\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\ndepth = info->var.blue.length;\r\nif (info->var.red.length < depth)\r\ndepth = info->var.red.length;\r\nif (info->var.green.length < depth)\r\ndepth = info->var.green.length;\r\n}\r\nif (info->fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR && depth > 4) {\r\ndepth = 4;\r\n}\r\nfb_logo.logo = fb_find_logo(depth);\r\nif (!fb_logo.logo) {\r\nreturn 0;\r\n}\r\nif (rotate == FB_ROTATE_UR || rotate == FB_ROTATE_UD)\r\nyres = info->var.yres;\r\nelse\r\nyres = info->var.xres;\r\nif (fb_logo.logo->height > yres) {\r\nfb_logo.logo = NULL;\r\nreturn 0;\r\n}\r\nif (fb_logo.logo->type == LINUX_LOGO_CLUT224)\r\nfb_logo.depth = 8;\r\nelse if (fb_logo.logo->type == LINUX_LOGO_VGA16)\r\nfb_logo.depth = 4;\r\nelse\r\nfb_logo.depth = 1;\r\nif (fb_logo.depth > 4 && depth > 4) {\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nfb_logo.needs_truepalette = 1;\r\nbreak;\r\ncase FB_VISUAL_DIRECTCOLOR:\r\nfb_logo.needs_directpalette = 1;\r\nfb_logo.needs_cmapreset = 1;\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nfb_logo.needs_cmapreset = 1;\r\nbreak;\r\n}\r\n}\r\nreturn fb_prepare_extra_logos(info, fb_logo.logo->height, yres);\r\n}\r\nint fb_show_logo(struct fb_info *info, int rotate)\r\n{\r\nint y;\r\ny = fb_show_logo_line(info, rotate, fb_logo.logo, 0,\r\nnum_online_cpus());\r\ny = fb_show_extra_logos(info, y, rotate);\r\nreturn y;\r\n}\r\nint fb_prepare_logo(struct fb_info *info, int rotate) { return 0; }\r\nint fb_show_logo(struct fb_info *info, int rotate) { return 0; }\r\nstatic void *fb_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&registration_lock);\r\nreturn (*pos < FB_MAX) ? pos : NULL;\r\n}\r\nstatic void *fb_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn (*pos < FB_MAX) ? pos : NULL;\r\n}\r\nstatic void fb_seq_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&registration_lock);\r\n}\r\nstatic int fb_seq_show(struct seq_file *m, void *v)\r\n{\r\nint i = *(loff_t *)v;\r\nstruct fb_info *fi = registered_fb[i];\r\nif (fi)\r\nseq_printf(m, "%d %s\n", fi->node, fi->fix.id);\r\nreturn 0;\r\n}\r\nstatic int proc_fb_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &proc_fb_seq_ops);\r\n}\r\nstatic struct fb_info *file_fb_info(struct file *file)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nint fbidx = iminor(inode);\r\nstruct fb_info *info = registered_fb[fbidx];\r\nif (info != file->private_data)\r\ninfo = NULL;\r\nreturn info;\r\n}\r\nstatic ssize_t\r\nfb_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nstruct fb_info *info = file_fb_info(file);\r\nu8 *buffer, *dst;\r\nu8 __iomem *src;\r\nint c, cnt = 0, err = 0;\r\nunsigned long total_size;\r\nif (!info || ! info->screen_base)\r\nreturn -ENODEV;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\nif (info->fbops->fb_read)\r\nreturn info->fbops->fb_read(info, buf, count, ppos);\r\ntotal_size = info->screen_size;\r\nif (total_size == 0)\r\ntotal_size = info->fix.smem_len;\r\nif (p >= total_size)\r\nreturn 0;\r\nif (count >= total_size)\r\ncount = total_size;\r\nif (count + p > total_size)\r\ncount = total_size - p;\r\nbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count,\r\nGFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nsrc = (u8 __iomem *) (info->screen_base + p);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nwhile (count) {\r\nc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\r\ndst = buffer;\r\nfb_memcpy_fromfb(dst, src, c);\r\ndst += c;\r\nsrc += c;\r\nif (copy_to_user(buf, buffer, c)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\n*ppos += c;\r\nbuf += c;\r\ncnt += c;\r\ncount -= c;\r\n}\r\nkfree(buffer);\r\nreturn (err) ? err : cnt;\r\n}\r\nstatic ssize_t\r\nfb_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nstruct fb_info *info = file_fb_info(file);\r\nu8 *buffer, *src;\r\nu8 __iomem *dst;\r\nint c, cnt = 0, err = 0;\r\nunsigned long total_size;\r\nif (!info || !info->screen_base)\r\nreturn -ENODEV;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\nif (info->fbops->fb_write)\r\nreturn info->fbops->fb_write(info, buf, count, ppos);\r\ntotal_size = info->screen_size;\r\nif (total_size == 0)\r\ntotal_size = info->fix.smem_len;\r\nif (p > total_size)\r\nreturn -EFBIG;\r\nif (count > total_size) {\r\nerr = -EFBIG;\r\ncount = total_size;\r\n}\r\nif (count + p > total_size) {\r\nif (!err)\r\nerr = -ENOSPC;\r\ncount = total_size - p;\r\n}\r\nbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count,\r\nGFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\ndst = (u8 __iomem *) (info->screen_base + p);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\nwhile (count) {\r\nc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\r\nsrc = buffer;\r\nif (copy_from_user(src, buf, c)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nfb_memcpy_tofb(dst, src, c);\r\ndst += c;\r\nsrc += c;\r\n*ppos += c;\r\nbuf += c;\r\ncnt += c;\r\ncount -= c;\r\n}\r\nkfree(buffer);\r\nreturn (cnt) ? cnt : err;\r\n}\r\nint\r\nfb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var)\r\n{\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nunsigned int yres = info->var.yres;\r\nint err = 0;\r\nif (var->yoffset > 0) {\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (!fix->ywrapstep || (var->yoffset % fix->ywrapstep))\r\nerr = -EINVAL;\r\nelse\r\nyres = 0;\r\n} else if (!fix->ypanstep || (var->yoffset % fix->ypanstep))\r\nerr = -EINVAL;\r\n}\r\nif (var->xoffset > 0 && (!fix->xpanstep ||\r\n(var->xoffset % fix->xpanstep)))\r\nerr = -EINVAL;\r\nif (err || !info->fbops->fb_pan_display ||\r\nvar->yoffset > info->var.yres_virtual - yres ||\r\nvar->xoffset > info->var.xres_virtual - info->var.xres)\r\nreturn -EINVAL;\r\nif ((err = info->fbops->fb_pan_display(var, info)))\r\nreturn err;\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nreturn 0;\r\n}\r\nstatic int fb_check_caps(struct fb_info *info, struct fb_var_screeninfo *var,\r\nu32 activate)\r\n{\r\nstruct fb_event event;\r\nstruct fb_blit_caps caps, fbcaps;\r\nint err = 0;\r\nmemset(&caps, 0, sizeof(caps));\r\nmemset(&fbcaps, 0, sizeof(fbcaps));\r\ncaps.flags = (activate & FB_ACTIVATE_ALL) ? 1 : 0;\r\nevent.info = info;\r\nevent.data = &caps;\r\nfb_notifier_call_chain(FB_EVENT_GET_REQ, &event);\r\ninfo->fbops->fb_get_caps(info, &fbcaps, var);\r\nif (((fbcaps.x ^ caps.x) & caps.x) ||\r\n((fbcaps.y ^ caps.y) & caps.y) ||\r\n(fbcaps.len < caps.len))\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nint\r\nfb_set_var(struct fb_info *info, struct fb_var_screeninfo *var)\r\n{\r\nint flags = info->flags;\r\nint ret = 0;\r\nif (var->activate & FB_ACTIVATE_INV_MODE) {\r\nstruct fb_videomode mode1, mode2;\r\nfb_var_to_videomode(&mode1, var);\r\nfb_var_to_videomode(&mode2, &info->var);\r\nret = fb_mode_is_equal(&mode1, &mode2);\r\nif (!ret) {\r\nstruct fb_event event;\r\nevent.info = info;\r\nevent.data = &mode1;\r\nret = fb_notifier_call_chain(FB_EVENT_MODE_DELETE, &event);\r\n}\r\nif (!ret)\r\nfb_delete_videomode(&mode1, &info->modelist);\r\nret = (ret) ? -EINVAL : 0;\r\ngoto done;\r\n}\r\nif ((var->activate & FB_ACTIVATE_FORCE) ||\r\nmemcmp(&info->var, var, sizeof(struct fb_var_screeninfo))) {\r\nu32 activate = var->activate;\r\nif ((info->fix.capabilities & FB_CAP_FOURCC) &&\r\nvar->grayscale > 1) {\r\nif (var->red.offset || var->green.offset ||\r\nvar->blue.offset || var->transp.offset ||\r\nvar->red.length || var->green.length ||\r\nvar->blue.length || var->transp.length ||\r\nvar->red.msb_right || var->green.msb_right ||\r\nvar->blue.msb_right || var->transp.msb_right)\r\nreturn -EINVAL;\r\n}\r\nif (!info->fbops->fb_check_var) {\r\n*var = info->var;\r\ngoto done;\r\n}\r\nret = info->fbops->fb_check_var(var, info);\r\nif (ret)\r\ngoto done;\r\nif ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {\r\nstruct fb_var_screeninfo old_var;\r\nstruct fb_videomode mode;\r\nif (info->fbops->fb_get_caps) {\r\nret = fb_check_caps(info, var, activate);\r\nif (ret)\r\ngoto done;\r\n}\r\nold_var = info->var;\r\ninfo->var = *var;\r\nif (info->fbops->fb_set_par) {\r\nret = info->fbops->fb_set_par(info);\r\nif (ret) {\r\ninfo->var = old_var;\r\nprintk(KERN_WARNING "detected "\r\n"fb_set_par error, "\r\n"error code: %d\n", ret);\r\ngoto done;\r\n}\r\n}\r\nfb_pan_display(info, &info->var);\r\nfb_set_cmap(&info->cmap, info);\r\nfb_var_to_videomode(&mode, &info->var);\r\nif (info->modelist.prev && info->modelist.next &&\r\n!list_empty(&info->modelist))\r\nret = fb_add_videomode(&mode, &info->modelist);\r\nif (!ret && (flags & FBINFO_MISC_USEREVENT)) {\r\nstruct fb_event event;\r\nint evnt = (activate & FB_ACTIVATE_ALL) ?\r\nFB_EVENT_MODE_CHANGE_ALL :\r\nFB_EVENT_MODE_CHANGE;\r\ninfo->flags &= ~FBINFO_MISC_USEREVENT;\r\nevent.info = info;\r\nevent.data = &mode;\r\nfb_notifier_call_chain(evnt, &event);\r\n}\r\n}\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nint\r\nfb_blank(struct fb_info *info, int blank)\r\n{\r\nstruct fb_event event;\r\nint ret = -EINVAL, early_ret;\r\nif (blank > FB_BLANK_POWERDOWN)\r\nblank = FB_BLANK_POWERDOWN;\r\nevent.info = info;\r\nevent.data = &blank;\r\nearly_ret = fb_notifier_call_chain(FB_EARLY_EVENT_BLANK, &event);\r\nif (info->fbops->fb_blank)\r\nret = info->fbops->fb_blank(blank, info);\r\nif (!ret)\r\nfb_notifier_call_chain(FB_EVENT_BLANK, &event);\r\nelse {\r\nif (!early_ret)\r\nfb_notifier_call_chain(FB_R_EARLY_EVENT_BLANK, &event);\r\n}\r\nreturn ret;\r\n}\r\nstatic long do_fb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct fb_ops *fb;\r\nstruct fb_var_screeninfo var;\r\nstruct fb_fix_screeninfo fix;\r\nstruct fb_con2fbmap con2fb;\r\nstruct fb_cmap cmap_from;\r\nstruct fb_cmap_user cmap;\r\nstruct fb_event event;\r\nvoid __user *argp = (void __user *)arg;\r\nlong ret = 0;\r\nswitch (cmd) {\r\ncase FBIOGET_VSCREENINFO:\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nvar = info->var;\r\nunlock_fb_info(info);\r\nret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;\r\nbreak;\r\ncase FBIOPUT_VSCREENINFO:\r\nif (copy_from_user(&var, argp, sizeof(var)))\r\nreturn -EFAULT;\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nconsole_lock();\r\ninfo->flags |= FBINFO_MISC_USEREVENT;\r\nret = fb_set_var(info, &var);\r\ninfo->flags &= ~FBINFO_MISC_USEREVENT;\r\nconsole_unlock();\r\nunlock_fb_info(info);\r\nif (!ret && copy_to_user(argp, &var, sizeof(var)))\r\nret = -EFAULT;\r\nbreak;\r\ncase FBIOGET_FSCREENINFO:\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nfix = info->fix;\r\nunlock_fb_info(info);\r\nret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;\r\nbreak;\r\ncase FBIOPUTCMAP:\r\nif (copy_from_user(&cmap, argp, sizeof(cmap)))\r\nreturn -EFAULT;\r\nret = fb_set_user_cmap(&cmap, info);\r\nbreak;\r\ncase FBIOGETCMAP:\r\nif (copy_from_user(&cmap, argp, sizeof(cmap)))\r\nreturn -EFAULT;\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\ncmap_from = info->cmap;\r\nunlock_fb_info(info);\r\nret = fb_cmap_to_user(&cmap_from, &cmap);\r\nbreak;\r\ncase FBIOPAN_DISPLAY:\r\nif (copy_from_user(&var, argp, sizeof(var)))\r\nreturn -EFAULT;\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nconsole_lock();\r\nret = fb_pan_display(info, &var);\r\nconsole_unlock();\r\nunlock_fb_info(info);\r\nif (ret == 0 && copy_to_user(argp, &var, sizeof(var)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase FBIO_CURSOR:\r\nret = -EINVAL;\r\nbreak;\r\ncase FBIOGET_CON2FBMAP:\r\nif (copy_from_user(&con2fb, argp, sizeof(con2fb)))\r\nreturn -EFAULT;\r\nif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)\r\nreturn -EINVAL;\r\ncon2fb.framebuffer = -1;\r\nevent.data = &con2fb;\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nevent.info = info;\r\nfb_notifier_call_chain(FB_EVENT_GET_CONSOLE_MAP, &event);\r\nunlock_fb_info(info);\r\nret = copy_to_user(argp, &con2fb, sizeof(con2fb)) ? -EFAULT : 0;\r\nbreak;\r\ncase FBIOPUT_CON2FBMAP:\r\nif (copy_from_user(&con2fb, argp, sizeof(con2fb)))\r\nreturn -EFAULT;\r\nif (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)\r\nreturn -EINVAL;\r\nif (con2fb.framebuffer < 0 || con2fb.framebuffer >= FB_MAX)\r\nreturn -EINVAL;\r\nif (!registered_fb[con2fb.framebuffer])\r\nrequest_module("fb%d", con2fb.framebuffer);\r\nif (!registered_fb[con2fb.framebuffer]) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nevent.data = &con2fb;\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nevent.info = info;\r\nret = fb_notifier_call_chain(FB_EVENT_SET_CONSOLE_MAP, &event);\r\nunlock_fb_info(info);\r\nbreak;\r\ncase FBIOBLANK:\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nconsole_lock();\r\ninfo->flags |= FBINFO_MISC_USEREVENT;\r\nret = fb_blank(info, arg);\r\ninfo->flags &= ~FBINFO_MISC_USEREVENT;\r\nconsole_unlock();\r\nunlock_fb_info(info);\r\nbreak;\r\ndefault:\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nfb = info->fbops;\r\nif (fb->fb_ioctl)\r\nret = fb->fb_ioctl(info, cmd, arg);\r\nelse\r\nret = -ENOTTY;\r\nunlock_fb_info(info);\r\n}\r\nreturn ret;\r\n}\r\nstatic long fb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct fb_info *info = file_fb_info(file);\r\nif (!info)\r\nreturn -ENODEV;\r\nreturn do_fb_ioctl(info, cmd, arg);\r\n}\r\nstatic int fb_getput_cmap(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct fb_cmap_user __user *cmap;\r\nstruct fb_cmap32 __user *cmap32;\r\n__u32 data;\r\nint err;\r\ncmap = compat_alloc_user_space(sizeof(*cmap));\r\ncmap32 = compat_ptr(arg);\r\nif (copy_in_user(&cmap->start, &cmap32->start, 2 * sizeof(__u32)))\r\nreturn -EFAULT;\r\nif (get_user(data, &cmap32->red) ||\r\nput_user(compat_ptr(data), &cmap->red) ||\r\nget_user(data, &cmap32->green) ||\r\nput_user(compat_ptr(data), &cmap->green) ||\r\nget_user(data, &cmap32->blue) ||\r\nput_user(compat_ptr(data), &cmap->blue) ||\r\nget_user(data, &cmap32->transp) ||\r\nput_user(compat_ptr(data), &cmap->transp))\r\nreturn -EFAULT;\r\nerr = do_fb_ioctl(info, cmd, (unsigned long) cmap);\r\nif (!err) {\r\nif (copy_in_user(&cmap32->start,\r\n&cmap->start,\r\n2 * sizeof(__u32)))\r\nerr = -EFAULT;\r\n}\r\nreturn err;\r\n}\r\nstatic int do_fscreeninfo_to_user(struct fb_fix_screeninfo *fix,\r\nstruct fb_fix_screeninfo32 __user *fix32)\r\n{\r\n__u32 data;\r\nint err;\r\nerr = copy_to_user(&fix32->id, &fix->id, sizeof(fix32->id));\r\ndata = (__u32) (unsigned long) fix->smem_start;\r\nerr |= put_user(data, &fix32->smem_start);\r\nerr |= put_user(fix->smem_len, &fix32->smem_len);\r\nerr |= put_user(fix->type, &fix32->type);\r\nerr |= put_user(fix->type_aux, &fix32->type_aux);\r\nerr |= put_user(fix->visual, &fix32->visual);\r\nerr |= put_user(fix->xpanstep, &fix32->xpanstep);\r\nerr |= put_user(fix->ypanstep, &fix32->ypanstep);\r\nerr |= put_user(fix->ywrapstep, &fix32->ywrapstep);\r\nerr |= put_user(fix->line_length, &fix32->line_length);\r\ndata = (__u32) (unsigned long) fix->mmio_start;\r\nerr |= put_user(data, &fix32->mmio_start);\r\nerr |= put_user(fix->mmio_len, &fix32->mmio_len);\r\nerr |= put_user(fix->accel, &fix32->accel);\r\nerr |= copy_to_user(fix32->reserved, fix->reserved,\r\nsizeof(fix->reserved));\r\nreturn err;\r\n}\r\nstatic int fb_get_fscreeninfo(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nmm_segment_t old_fs;\r\nstruct fb_fix_screeninfo fix;\r\nstruct fb_fix_screeninfo32 __user *fix32;\r\nint err;\r\nfix32 = compat_ptr(arg);\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = do_fb_ioctl(info, cmd, (unsigned long) &fix);\r\nset_fs(old_fs);\r\nif (!err)\r\nerr = do_fscreeninfo_to_user(&fix, fix32);\r\nreturn err;\r\n}\r\nstatic long fb_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct fb_info *info = file_fb_info(file);\r\nstruct fb_ops *fb;\r\nlong ret = -ENOIOCTLCMD;\r\nif (!info)\r\nreturn -ENODEV;\r\nfb = info->fbops;\r\nswitch(cmd) {\r\ncase FBIOGET_VSCREENINFO:\r\ncase FBIOPUT_VSCREENINFO:\r\ncase FBIOPAN_DISPLAY:\r\ncase FBIOGET_CON2FBMAP:\r\ncase FBIOPUT_CON2FBMAP:\r\narg = (unsigned long) compat_ptr(arg);\r\ncase FBIOBLANK:\r\nret = do_fb_ioctl(info, cmd, arg);\r\nbreak;\r\ncase FBIOGET_FSCREENINFO:\r\nret = fb_get_fscreeninfo(info, cmd, arg);\r\nbreak;\r\ncase FBIOGETCMAP:\r\ncase FBIOPUTCMAP:\r\nret = fb_getput_cmap(info, cmd, arg);\r\nbreak;\r\ndefault:\r\nif (fb->fb_compat_ioctl)\r\nret = fb->fb_compat_ioctl(info, cmd, arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nfb_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nstruct fb_info *info = file_fb_info(file);\r\nstruct fb_ops *fb;\r\nunsigned long off;\r\nunsigned long start;\r\nu32 len;\r\nif (!info)\r\nreturn -ENODEV;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\noff = vma->vm_pgoff << PAGE_SHIFT;\r\nfb = info->fbops;\r\nif (!fb)\r\nreturn -ENODEV;\r\nmutex_lock(&info->mm_lock);\r\nif (fb->fb_mmap) {\r\nint res;\r\nres = fb->fb_mmap(info, vma);\r\nmutex_unlock(&info->mm_lock);\r\nreturn res;\r\n}\r\nstart = info->fix.smem_start;\r\nlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\r\nif (off >= len) {\r\noff -= len;\r\nif (info->var.accel_flags) {\r\nmutex_unlock(&info->mm_lock);\r\nreturn -EINVAL;\r\n}\r\nstart = info->fix.mmio_start;\r\nlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\r\n}\r\nmutex_unlock(&info->mm_lock);\r\nstart &= PAGE_MASK;\r\nif ((vma->vm_end - vma->vm_start + off) > len)\r\nreturn -EINVAL;\r\noff += start;\r\nvma->vm_pgoff = off >> PAGE_SHIFT;\r\nvma->vm_flags |= VM_IO | VM_RESERVED;\r\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\r\nfb_pgprotect(file, vma, off);\r\nif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int\r\nfb_open(struct inode *inode, struct file *file)\r\n__acquires(&info->lock\r\nstatic int\r\nfb_release(struct inode *inode, struct file *file)\r\n__acquires(&info->lock\r\nstatic int fb_check_foreignness(struct fb_info *fi)\r\n{\r\nconst bool foreign_endian = fi->flags & FBINFO_FOREIGN_ENDIAN;\r\nfi->flags &= ~FBINFO_FOREIGN_ENDIAN;\r\n#ifdef __BIG_ENDIAN\r\nfi->flags |= foreign_endian ? 0 : FBINFO_BE_MATH;\r\n#else\r\nfi->flags |= foreign_endian ? FBINFO_BE_MATH : 0;\r\n#endif\r\nif (fi->flags & FBINFO_BE_MATH && !fb_be_math(fi)) {\r\npr_err("%s: enable CONFIG_FB_BIG_ENDIAN to "\r\n"support this framebuffer\n", fi->fix.id);\r\nreturn -ENOSYS;\r\n} else if (!(fi->flags & FBINFO_BE_MATH) && fb_be_math(fi)) {\r\npr_err("%s: enable CONFIG_FB_LITTLE_ENDIAN to "\r\n"support this framebuffer\n", fi->fix.id);\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool apertures_overlap(struct aperture *gen, struct aperture *hw)\r\n{\r\nif (gen->base == hw->base)\r\nreturn true;\r\nif (gen->base > hw->base && gen->base < hw->base + hw->size)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool fb_do_apertures_overlap(struct apertures_struct *gena,\r\nstruct apertures_struct *hwa)\r\n{\r\nint i, j;\r\nif (!hwa || !gena)\r\nreturn false;\r\nfor (i = 0; i < hwa->count; ++i) {\r\nstruct aperture *h = &hwa->ranges[i];\r\nfor (j = 0; j < gena->count; ++j) {\r\nstruct aperture *g = &gena->ranges[j];\r\nprintk(KERN_DEBUG "checking generic (%llx %llx) vs hw (%llx %llx)\n",\r\n(unsigned long long)g->base,\r\n(unsigned long long)g->size,\r\n(unsigned long long)h->base,\r\n(unsigned long long)h->size);\r\nif (apertures_overlap(g, h))\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void do_remove_conflicting_framebuffers(struct apertures_struct *a,\r\nconst char *name, bool primary)\r\n{\r\nint i;\r\nfor (i = 0 ; i < FB_MAX; i++) {\r\nstruct apertures_struct *gen_aper;\r\nif (!registered_fb[i])\r\ncontinue;\r\nif (!(registered_fb[i]->flags & FBINFO_MISC_FIRMWARE))\r\ncontinue;\r\ngen_aper = registered_fb[i]->apertures;\r\nif (fb_do_apertures_overlap(gen_aper, a) ||\r\n(primary && gen_aper && gen_aper->count &&\r\ngen_aper->ranges[0].base == VGA_FB_PHYS)) {\r\nprintk(KERN_INFO "fb: conflicting fb hw usage "\r\n"%s vs %s - removing generic driver\n",\r\nname, registered_fb[i]->fix.id);\r\ndo_unregister_framebuffer(registered_fb[i]);\r\n}\r\n}\r\n}\r\nstatic int do_register_framebuffer(struct fb_info *fb_info)\r\n{\r\nint i;\r\nstruct fb_event event;\r\nstruct fb_videomode mode;\r\nif (fb_check_foreignness(fb_info))\r\nreturn -ENOSYS;\r\ndo_remove_conflicting_framebuffers(fb_info->apertures, fb_info->fix.id,\r\nfb_is_primary_device(fb_info));\r\nif (num_registered_fb == FB_MAX)\r\nreturn -ENXIO;\r\nnum_registered_fb++;\r\nfor (i = 0 ; i < FB_MAX; i++)\r\nif (!registered_fb[i])\r\nbreak;\r\nfb_info->node = i;\r\natomic_set(&fb_info->count, 1);\r\nmutex_init(&fb_info->lock);\r\nmutex_init(&fb_info->mm_lock);\r\nfb_info->dev = device_create(fb_class, fb_info->device,\r\nMKDEV(FB_MAJOR, i), NULL, "fb%d", i);\r\nif (IS_ERR(fb_info->dev)) {\r\nprintk(KERN_WARNING "Unable to create device for framebuffer %d; errno = %ld\n", i, PTR_ERR(fb_info->dev));\r\nfb_info->dev = NULL;\r\n} else\r\nfb_init_device(fb_info);\r\nif (fb_info->pixmap.addr == NULL) {\r\nfb_info->pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL);\r\nif (fb_info->pixmap.addr) {\r\nfb_info->pixmap.size = FBPIXMAPSIZE;\r\nfb_info->pixmap.buf_align = 1;\r\nfb_info->pixmap.scan_align = 1;\r\nfb_info->pixmap.access_align = 32;\r\nfb_info->pixmap.flags = FB_PIXMAP_DEFAULT;\r\n}\r\n}\r\nfb_info->pixmap.offset = 0;\r\nif (!fb_info->pixmap.blit_x)\r\nfb_info->pixmap.blit_x = ~(u32)0;\r\nif (!fb_info->pixmap.blit_y)\r\nfb_info->pixmap.blit_y = ~(u32)0;\r\nif (!fb_info->modelist.prev || !fb_info->modelist.next)\r\nINIT_LIST_HEAD(&fb_info->modelist);\r\nfb_var_to_videomode(&mode, &fb_info->var);\r\nfb_add_videomode(&mode, &fb_info->modelist);\r\nregistered_fb[i] = fb_info;\r\nevent.info = fb_info;\r\nif (!lock_fb_info(fb_info))\r\nreturn -ENODEV;\r\nfb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &event);\r\nunlock_fb_info(fb_info);\r\nreturn 0;\r\n}\r\nstatic int do_unregister_framebuffer(struct fb_info *fb_info)\r\n{\r\nstruct fb_event event;\r\nint i, ret = 0;\r\ni = fb_info->node;\r\nif (i < 0 || i >= FB_MAX || registered_fb[i] != fb_info)\r\nreturn -EINVAL;\r\nif (!lock_fb_info(fb_info))\r\nreturn -ENODEV;\r\nevent.info = fb_info;\r\nret = fb_notifier_call_chain(FB_EVENT_FB_UNBIND, &event);\r\nunlock_fb_info(fb_info);\r\nif (ret)\r\nreturn -EINVAL;\r\nunlink_framebuffer(fb_info);\r\nif (fb_info->pixmap.addr &&\r\n(fb_info->pixmap.flags & FB_PIXMAP_DEFAULT))\r\nkfree(fb_info->pixmap.addr);\r\nfb_destroy_modelist(&fb_info->modelist);\r\nregistered_fb[i] = NULL;\r\nnum_registered_fb--;\r\nfb_cleanup_device(fb_info);\r\nevent.info = fb_info;\r\nfb_notifier_call_chain(FB_EVENT_FB_UNREGISTERED, &event);\r\nput_fb_info(fb_info);\r\nreturn 0;\r\n}\r\nint unlink_framebuffer(struct fb_info *fb_info)\r\n{\r\nint i;\r\ni = fb_info->node;\r\nif (i < 0 || i >= FB_MAX || registered_fb[i] != fb_info)\r\nreturn -EINVAL;\r\nif (fb_info->dev) {\r\ndevice_destroy(fb_class, MKDEV(FB_MAJOR, i));\r\nfb_info->dev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nvoid remove_conflicting_framebuffers(struct apertures_struct *a,\r\nconst char *name, bool primary)\r\n{\r\nmutex_lock(&registration_lock);\r\ndo_remove_conflicting_framebuffers(a, name, primary);\r\nmutex_unlock(&registration_lock);\r\n}\r\nint\r\nregister_framebuffer(struct fb_info *fb_info)\r\n{\r\nint ret;\r\nmutex_lock(&registration_lock);\r\nret = do_register_framebuffer(fb_info);\r\nmutex_unlock(&registration_lock);\r\nreturn ret;\r\n}\r\nint\r\nunregister_framebuffer(struct fb_info *fb_info)\r\n{\r\nint ret;\r\nmutex_lock(&registration_lock);\r\nret = do_unregister_framebuffer(fb_info);\r\nmutex_unlock(&registration_lock);\r\nreturn ret;\r\n}\r\nvoid fb_set_suspend(struct fb_info *info, int state)\r\n{\r\nstruct fb_event event;\r\nevent.info = info;\r\nif (state) {\r\nfb_notifier_call_chain(FB_EVENT_SUSPEND, &event);\r\ninfo->state = FBINFO_STATE_SUSPENDED;\r\n} else {\r\ninfo->state = FBINFO_STATE_RUNNING;\r\nfb_notifier_call_chain(FB_EVENT_RESUME, &event);\r\n}\r\n}\r\nstatic int __init\r\nfbmem_init(void)\r\n{\r\nproc_create("fb", 0, NULL, &fb_proc_fops);\r\nif (register_chrdev(FB_MAJOR,"fb",&fb_fops))\r\nprintk("unable to get major %d for fb devs\n", FB_MAJOR);\r\nfb_class = class_create(THIS_MODULE, "graphics");\r\nif (IS_ERR(fb_class)) {\r\nprintk(KERN_WARNING "Unable to create fb class; errno = %ld\n", PTR_ERR(fb_class));\r\nfb_class = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nfbmem_exit(void)\r\n{\r\nremove_proc_entry("fb", NULL);\r\nclass_destroy(fb_class);\r\nunregister_chrdev(FB_MAJOR, "fb");\r\n}\r\nint fb_new_modelist(struct fb_info *info)\r\n{\r\nstruct fb_event event;\r\nstruct fb_var_screeninfo var = info->var;\r\nstruct list_head *pos, *n;\r\nstruct fb_modelist *modelist;\r\nstruct fb_videomode *m, mode;\r\nint err = 1;\r\nlist_for_each_safe(pos, n, &info->modelist) {\r\nmodelist = list_entry(pos, struct fb_modelist, list);\r\nm = &modelist->mode;\r\nfb_videomode_to_var(&var, m);\r\nvar.activate = FB_ACTIVATE_TEST;\r\nerr = fb_set_var(info, &var);\r\nfb_var_to_videomode(&mode, &var);\r\nif (err || !fb_mode_is_equal(m, &mode)) {\r\nlist_del(pos);\r\nkfree(pos);\r\n}\r\n}\r\nerr = 1;\r\nif (!list_empty(&info->modelist)) {\r\nif (!lock_fb_info(info))\r\nreturn -ENODEV;\r\nevent.info = info;\r\nerr = fb_notifier_call_chain(FB_EVENT_NEW_MODELIST, &event);\r\nunlock_fb_info(info);\r\n}\r\nreturn err;\r\n}\r\nint fb_get_options(char *name, char **option)\r\n{\r\nchar *opt, *options = NULL;\r\nint retval = 0;\r\nint name_len = strlen(name), i;\r\nif (name_len && ofonly && strncmp(name, "offb", 4))\r\nretval = 1;\r\nif (name_len && !retval) {\r\nfor (i = 0; i < FB_MAX; i++) {\r\nif (video_options[i] == NULL)\r\ncontinue;\r\nif (!video_options[i][0])\r\ncontinue;\r\nopt = video_options[i];\r\nif (!strncmp(name, opt, name_len) &&\r\nopt[name_len] == ':')\r\noptions = opt + name_len + 1;\r\n}\r\n}\r\nif (options && !strncmp(options, "off", 3))\r\nretval = 1;\r\nif (option)\r\n*option = options;\r\nreturn retval;\r\n}\r\nstatic int __init video_setup(char *options)\r\n{\r\nint i, global = 0;\r\nif (!options || !*options)\r\nglobal = 1;\r\nif (!global && !strncmp(options, "ofonly", 6)) {\r\nofonly = 1;\r\nglobal = 1;\r\n}\r\nif (!global && !strchr(options, ':')) {\r\nfb_mode_option = options;\r\nglobal = 1;\r\n}\r\nif (!global) {\r\nfor (i = 0; i < FB_MAX; i++) {\r\nif (video_options[i] == NULL) {\r\nvideo_options[i] = options;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}
