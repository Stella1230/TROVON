static void ircomm_tty_change_speed(struct ircomm_tty_cb *self)\r\n{\r\nunsigned int cflag, cval;\r\nint baud;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif (!self->tty || !self->tty->termios || !self->ircomm)\r\nreturn;\r\ncflag = self->tty->termios->c_cflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5: cval = IRCOMM_WSIZE_5; break;\r\ncase CS6: cval = IRCOMM_WSIZE_6; break;\r\ncase CS7: cval = IRCOMM_WSIZE_7; break;\r\ncase CS8: cval = IRCOMM_WSIZE_8; break;\r\ndefault: cval = IRCOMM_WSIZE_5; break;\r\n}\r\nif (cflag & CSTOPB)\r\ncval |= IRCOMM_2_STOP_BIT;\r\nif (cflag & PARENB)\r\ncval |= IRCOMM_PARITY_ENABLE;\r\nif (!(cflag & PARODD))\r\ncval |= IRCOMM_PARITY_EVEN;\r\nbaud = tty_get_baud_rate(self->tty);\r\nif (!baud)\r\nbaud = 9600;\r\nself->settings.data_rate = baud;\r\nircomm_param_request(self, IRCOMM_DATA_RATE, FALSE);\r\nif (cflag & CRTSCTS) {\r\nself->flags |= ASYNC_CTS_FLOW;\r\nself->settings.flow_control |= IRCOMM_RTS_CTS_IN;\r\nif (self->service_type == IRCOMM_3_WIRE_RAW)\r\nIRDA_WARNING("%s(), enabling RTS/CTS on link that doesn't support it (3-wire-raw)\n", __func__);\r\n} else {\r\nself->flags &= ~ASYNC_CTS_FLOW;\r\nself->settings.flow_control &= ~IRCOMM_RTS_CTS_IN;\r\n}\r\nif (cflag & CLOCAL)\r\nself->flags &= ~ASYNC_CHECK_CD;\r\nelse\r\nself->flags |= ASYNC_CHECK_CD;\r\n#if 0\r\nif (I_INPCK(self->tty))\r\ndriver->read_status_mask |= LSR_FE | LSR_PE;\r\nif (I_BRKINT(driver->tty) || I_PARMRK(driver->tty))\r\ndriver->read_status_mask |= LSR_BI;\r\ndriver->ignore_status_mask = 0;\r\nif (I_IGNPAR(driver->tty))\r\ndriver->ignore_status_mask |= LSR_PE | LSR_FE;\r\nif (I_IGNBRK(self->tty)) {\r\nself->ignore_status_mask |= LSR_BI;\r\nif (I_IGNPAR(self->tty))\r\nself->ignore_status_mask |= LSR_OE;\r\n}\r\n#endif\r\nself->settings.data_format = cval;\r\nircomm_param_request(self, IRCOMM_DATA_FORMAT, FALSE);\r\nircomm_param_request(self, IRCOMM_FLOW_CONTROL, TRUE);\r\n}\r\nvoid ircomm_tty_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned int cflag = tty->termios->c_cflag;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif ((cflag == old_termios->c_cflag) &&\r\n(RELEVANT_IFLAG(tty->termios->c_iflag) ==\r\nRELEVANT_IFLAG(old_termios->c_iflag)))\r\n{\r\nreturn;\r\n}\r\nircomm_tty_change_speed(self);\r\nif ((old_termios->c_cflag & CBAUD) &&\r\n!(cflag & CBAUD)) {\r\nself->settings.dte &= ~(IRCOMM_DTR|IRCOMM_RTS);\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) &&\r\n(cflag & CBAUD)) {\r\nself->settings.dte |= IRCOMM_DTR;\r\nif (!(tty->termios->c_cflag & CRTSCTS) ||\r\n!test_bit(TTY_THROTTLED, &tty->flags)) {\r\nself->settings.dte |= IRCOMM_RTS;\r\n}\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios->c_cflag & CRTSCTS))\r\n{\r\ntty->hw_stopped = 0;\r\nircomm_tty_start(tty);\r\n}\r\n}\r\nint ircomm_tty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nunsigned int result;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\nresult = ((self->settings.dte & IRCOMM_RTS) ? TIOCM_RTS : 0)\r\n| ((self->settings.dte & IRCOMM_DTR) ? TIOCM_DTR : 0)\r\n| ((self->settings.dce & IRCOMM_CD) ? TIOCM_CAR : 0)\r\n| ((self->settings.dce & IRCOMM_RI) ? TIOCM_RNG : 0)\r\n| ((self->settings.dce & IRCOMM_DSR) ? TIOCM_DSR : 0)\r\n| ((self->settings.dce & IRCOMM_CTS) ? TIOCM_CTS : 0);\r\nreturn result;\r\n}\r\nint ircomm_tty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nif (set & TIOCM_RTS)\r\nself->settings.dte |= IRCOMM_RTS;\r\nif (set & TIOCM_DTR)\r\nself->settings.dte |= IRCOMM_DTR;\r\nif (clear & TIOCM_RTS)\r\nself->settings.dte &= ~IRCOMM_RTS;\r\nif (clear & TIOCM_DTR)\r\nself->settings.dte &= ~IRCOMM_DTR;\r\nif ((set|clear) & TIOCM_RTS)\r\nself->settings.dte |= IRCOMM_DELTA_RTS;\r\nif ((set|clear) & TIOCM_DTR)\r\nself->settings.dte |= IRCOMM_DELTA_DTR;\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\nreturn 0;\r\n}\r\nstatic int ircomm_tty_get_serial_info(struct ircomm_tty_cb *self,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct info;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nmemset(&info, 0, sizeof(info));\r\ninfo.line = self->line;\r\ninfo.flags = self->flags;\r\ninfo.baud_base = self->settings.data_rate;\r\ninfo.close_delay = self->close_delay;\r\ninfo.closing_wait = self->closing_wait;\r\ninfo.type = PORT_16550A;\r\ninfo.port = 0;\r\ninfo.irq = 0;\r\ninfo.xmit_fifo_size = 0;\r\ninfo.hub6 = 0;\r\ninfo.custom_divisor = 0;\r\nif (copy_to_user(retinfo, &info, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ircomm_tty_set_serial_info(struct ircomm_tty_cb *self,\r\nstruct serial_struct __user *new_info)\r\n{\r\n#if 0\r\nstruct serial_struct new_serial;\r\nstruct ircomm_tty_cb old_state, *state;\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nif (copy_from_user(&new_serial,new_info,sizeof(new_serial)))\r\nreturn -EFAULT;\r\nstate = self\r\nold_state = *self;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((new_serial.baud_base != state->settings.data_rate) ||\r\n(new_serial.close_delay != state->close_delay) ||\r\n((new_serial.flags & ~ASYNC_USR_MASK) !=\r\n(self->flags & ~ASYNC_USR_MASK)))\r\nreturn -EPERM;\r\nstate->flags = ((state->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\nself->flags = ((self->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\ngoto check_and_exit;\r\n}\r\nif (self->settings.data_rate != new_serial.baud_base) {\r\nself->settings.data_rate = new_serial.baud_base;\r\nircomm_param_request(self, IRCOMM_DATA_RATE, TRUE);\r\n}\r\nself->close_delay = new_serial.close_delay * HZ/100;\r\nself->closing_wait = new_serial.closing_wait * HZ/100;\r\nself->flags = ((self->flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS));\r\nself->tty->low_latency = (self->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\ncheck_and_exit:\r\nif (self->flags & ASYNC_INITIALIZED) {\r\nif (((old_state.flags & ASYNC_SPD_MASK) !=\r\n(self->flags & ASYNC_SPD_MASK)) ||\r\n(old_driver.custom_divisor != driver->custom_divisor)) {\r\nif ((driver->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\ndriver->tty->alt_speed = 57600;\r\nif ((driver->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\ndriver->tty->alt_speed = 115200;\r\nif ((driver->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\ndriver->tty->alt_speed = 230400;\r\nif ((driver->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\ndriver->tty->alt_speed = 460800;\r\nircomm_tty_change_speed(driver);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint ircomm_tty_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;\r\nint ret = 0;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&\r\n(cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nret = ircomm_tty_get_serial_info(self, (struct serial_struct __user *) arg);\r\nbreak;\r\ncase TIOCSSERIAL:\r\nret = ircomm_tty_set_serial_info(self, (struct serial_struct __user *) arg);\r\nbreak;\r\ncase TIOCMIWAIT:\r\nIRDA_DEBUG(0, "(), TIOCMIWAIT, not impl!\n");\r\nbreak;\r\ncase TIOCGICOUNT:\r\nIRDA_DEBUG(0, "%s(), TIOCGICOUNT not impl!\n", __func__ );\r\n#if 0\r\nsave_flags(flags); cli();\r\ncnow = driver->icount;\r\nrestore_flags(flags);\r\np_cuser = (struct serial_icounter_struct __user *) arg;\r\nif (put_user(cnow.cts, &p_cuser->cts) ||\r\nput_user(cnow.dsr, &p_cuser->dsr) ||\r\nput_user(cnow.rng, &p_cuser->rng) ||\r\nput_user(cnow.dcd, &p_cuser->dcd) ||\r\nput_user(cnow.rx, &p_cuser->rx) ||\r\nput_user(cnow.tx, &p_cuser->tx) ||\r\nput_user(cnow.frame, &p_cuser->frame) ||\r\nput_user(cnow.overrun, &p_cuser->overrun) ||\r\nput_user(cnow.parity, &p_cuser->parity) ||\r\nput_user(cnow.brk, &p_cuser->brk) ||\r\nput_user(cnow.buf_overrun, &p_cuser->buf_overrun))\r\nreturn -EFAULT;\r\n#endif\r\nreturn 0;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}
