static bool alps_is_valid_first_byte(const struct alps_model_info *model,\r\nunsigned char data)\r\n{\r\nreturn (data & model->mask0) == model->byte0;\r\n}\r\nstatic void alps_report_buttons(struct psmouse *psmouse,\r\nstruct input_dev *dev1, struct input_dev *dev2,\r\nint left, int right, int middle)\r\n{\r\nstruct input_dev *dev;\r\ndev = test_bit(BTN_LEFT, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_LEFT, left);\r\ndev = test_bit(BTN_RIGHT, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ndev = test_bit(BTN_MIDDLE, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\ninput_sync(dev2);\r\n}\r\nstatic void alps_process_packet_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x, y, z, ges, fin, left, right, middle;\r\nint back = 0, forward = 0;\r\nif (model->proto_version == ALPS_PROTO_V1) {\r\nleft = packet[2] & 0x10;\r\nright = packet[2] & 0x08;\r\nmiddle = 0;\r\nx = packet[1] | ((packet[0] & 0x07) << 7);\r\ny = packet[4] | ((packet[3] & 0x07) << 7);\r\nz = packet[5];\r\n} else {\r\nleft = packet[3] & 1;\r\nright = packet[3] & 2;\r\nmiddle = packet[3] & 4;\r\nx = packet[1] | ((packet[2] & 0x78) << (7 - 3));\r\ny = packet[4] | ((packet[3] & 0x70) << (7 - 4));\r\nz = packet[5];\r\n}\r\nif (model->flags & ALPS_FW_BK_1) {\r\nback = packet[0] & 0x10;\r\nforward = packet[2] & 4;\r\n}\r\nif (model->flags & ALPS_FW_BK_2) {\r\nback = packet[3] & 4;\r\nforward = packet[2] & 4;\r\nif ((middle = forward && back))\r\nforward = back = 0;\r\n}\r\nges = packet[2] & 1;\r\nfin = packet[2] & 2;\r\nif ((model->flags & ALPS_DUALPOINT) && z == 127) {\r\ninput_report_rel(dev2, REL_X, (x > 383 ? (x - 768) : x));\r\ninput_report_rel(dev2, REL_Y, -(y > 255 ? (y - 512) : y));\r\nalps_report_buttons(psmouse, dev2, dev, left, right, middle);\r\ninput_sync(dev2);\r\nreturn;\r\n}\r\nalps_report_buttons(psmouse, dev, dev2, left, right, middle);\r\nif (ges && !fin)\r\nz = 40;\r\nif (ges && fin && !priv->prev_fin) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_report_abs(dev, ABS_PRESSURE, 0);\r\ninput_report_key(dev, BTN_TOOL_FINGER, 0);\r\ninput_sync(dev);\r\n}\r\npriv->prev_fin = fin;\r\nif (z > 30)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nif (z < 25)\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_report_key(dev, BTN_TOOL_FINGER, z > 0);\r\nif (model->flags & ALPS_WHEEL)\r\ninput_report_rel(dev, REL_WHEEL, ((packet[2] << 1) & 0x08) - ((packet[0] >> 4) & 0x07));\r\nif (model->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ninput_report_key(dev, BTN_FORWARD, forward);\r\ninput_report_key(dev, BTN_BACK, back);\r\n}\r\nif (model->flags & ALPS_FOUR_BUTTONS) {\r\ninput_report_key(dev, BTN_0, packet[2] & 4);\r\ninput_report_key(dev, BTN_1, packet[0] & 0x10);\r\ninput_report_key(dev, BTN_2, packet[3] & 4);\r\ninput_report_key(dev, BTN_3, packet[0] & 0x20);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic int alps_process_bitmap(unsigned int x_map, unsigned int y_map,\r\nint *x1, int *y1, int *x2, int *y2)\r\n{\r\nstruct alps_bitmap_point {\r\nint start_bit;\r\nint num_bits;\r\n};\r\nint fingers_x = 0, fingers_y = 0, fingers;\r\nint i, bit, prev_bit;\r\nstruct alps_bitmap_point x_low = {0,}, x_high = {0,};\r\nstruct alps_bitmap_point y_low = {0,}, y_high = {0,};\r\nstruct alps_bitmap_point *point;\r\nif (!x_map || !y_map)\r\nreturn 0;\r\n*x1 = *y1 = *x2 = *y2 = 0;\r\nprev_bit = 0;\r\npoint = &x_low;\r\nfor (i = 0; x_map != 0; i++, x_map >>= 1) {\r\nbit = x_map & 1;\r\nif (bit) {\r\nif (!prev_bit) {\r\npoint->start_bit = i;\r\nfingers_x++;\r\n}\r\npoint->num_bits++;\r\n} else {\r\nif (prev_bit)\r\npoint = &x_high;\r\nelse\r\npoint->num_bits = 0;\r\n}\r\nprev_bit = bit;\r\n}\r\ny_map = y_map << (sizeof(y_map) * BITS_PER_BYTE - ALPS_BITMAP_Y_BITS);\r\nprev_bit = 0;\r\npoint = &y_low;\r\nfor (i = 0; y_map != 0; i++, y_map <<= 1) {\r\nbit = y_map & (1 << (sizeof(y_map) * BITS_PER_BYTE - 1));\r\nif (bit) {\r\nif (!prev_bit) {\r\npoint->start_bit = i;\r\nfingers_y++;\r\n}\r\npoint->num_bits++;\r\n} else {\r\nif (prev_bit)\r\npoint = &y_high;\r\nelse\r\npoint->num_bits = 0;\r\n}\r\nprev_bit = bit;\r\n}\r\nfingers = max(fingers_x, fingers_y);\r\nif (fingers > 1) {\r\nif (fingers_x == 1) {\r\ni = x_low.num_bits / 2;\r\nx_low.num_bits = x_low.num_bits - i;\r\nx_high.start_bit = x_low.start_bit + i;\r\nx_high.num_bits = max(i, 1);\r\n} else if (fingers_y == 1) {\r\ni = y_low.num_bits / 2;\r\ny_low.num_bits = y_low.num_bits - i;\r\ny_high.start_bit = y_low.start_bit + i;\r\ny_high.num_bits = max(i, 1);\r\n}\r\n}\r\n*x1 = (ALPS_V3_X_MAX * (2 * x_low.start_bit + x_low.num_bits - 1)) /\r\n(2 * (ALPS_BITMAP_X_BITS - 1));\r\n*y1 = (ALPS_V3_Y_MAX * (2 * y_low.start_bit + y_low.num_bits - 1)) /\r\n(2 * (ALPS_BITMAP_Y_BITS - 1));\r\nif (fingers > 1) {\r\n*x2 = (ALPS_V3_X_MAX * (2 * x_high.start_bit + x_high.num_bits - 1)) /\r\n(2 * (ALPS_BITMAP_X_BITS - 1));\r\n*y2 = (ALPS_V3_Y_MAX * (2 * y_high.start_bit + y_high.num_bits - 1)) /\r\n(2 * (ALPS_BITMAP_Y_BITS - 1));\r\n}\r\nreturn fingers;\r\n}\r\nstatic void alps_set_slot(struct input_dev *dev, int slot, bool active,\r\nint x, int y)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\r\nif (active) {\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\nstatic void alps_report_semi_mt_data(struct input_dev *dev, int num_fingers,\r\nint x1, int y1, int x2, int y2)\r\n{\r\nalps_set_slot(dev, 0, num_fingers != 0, x1, y1);\r\nalps_set_slot(dev, 1, num_fingers == 2, x2, y2);\r\n}\r\nstatic void alps_process_trackstick_packet_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = priv->dev2;\r\nint x, y, z, left, right, middle;\r\nif (!(packet[0] & 0x40)) {\r\npsmouse_dbg(psmouse, "Bad trackstick packet, discarding\n");\r\nreturn;\r\n}\r\nif (packet[1] == 0x7f && packet[2] == 0x7f && packet[4] == 0x7f)\r\nreturn;\r\nx = (s8)(((packet[0] & 0x20) << 2) | (packet[1] & 0x7f));\r\ny = (s8)(((packet[0] & 0x10) << 3) | (packet[2] & 0x7f));\r\nz = (packet[4] & 0x7c) >> 2;\r\nx /= 8;\r\ny /= 8;\r\ninput_report_rel(dev, REL_X, x);\r\ninput_report_rel(dev, REL_Y, -y);\r\nleft = packet[3] & 0x01;\r\nright = packet[3] & 0x02;\r\nmiddle = packet[3] & 0x04;\r\nif (!(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) &&\r\n(left || right || middle))\r\npriv->quirks |= ALPS_QUIRK_TRACKSTICK_BUTTONS;\r\nif (priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) {\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\n}\r\ninput_sync(dev);\r\nreturn;\r\n}\r\nstatic void alps_process_touchpad_packet_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x, y, z;\r\nint left, right, middle;\r\nint x1 = 0, y1 = 0, x2 = 0, y2 = 0;\r\nint fingers = 0, bmap_fingers;\r\nunsigned int x_bitmap, y_bitmap;\r\nif (priv->multi_packet) {\r\nif (packet[0] & 0x40) {\r\nfingers = (packet[5] & 0x3) + 1;\r\nx_bitmap = ((packet[4] & 0x7e) << 8) |\r\n((packet[1] & 0x7f) << 2) |\r\n((packet[0] & 0x30) >> 4);\r\ny_bitmap = ((packet[3] & 0x70) << 4) |\r\n((packet[2] & 0x7f) << 1) |\r\n(packet[4] & 0x01);\r\nbmap_fingers = alps_process_bitmap(x_bitmap, y_bitmap,\r\n&x1, &y1, &x2, &y2);\r\nif (fingers > 1 && bmap_fingers < 2)\r\nfingers = bmap_fingers;\r\npacket = priv->multi_data;\r\n} else {\r\npriv->multi_packet = 0;\r\n}\r\n}\r\nif (packet[0] & 0x40)\r\nreturn;\r\nif (!priv->multi_packet && (packet[4] & 0x40)) {\r\npriv->multi_packet = 1;\r\nmemcpy(priv->multi_data, packet, sizeof(priv->multi_data));\r\nreturn;\r\n}\r\npriv->multi_packet = 0;\r\nleft = packet[3] & 0x01;\r\nright = packet[3] & 0x02;\r\nmiddle = packet[3] & 0x04;\r\nx = ((packet[1] & 0x7f) << 4) | ((packet[4] & 0x30) >> 2) |\r\n((packet[0] & 0x30) >> 4);\r\ny = ((packet[2] & 0x7f) << 4) | (packet[4] & 0x0f);\r\nz = packet[5] & 0x7f;\r\nif (x && y && !z)\r\nreturn;\r\nif (!fingers) {\r\nx1 = x;\r\ny1 = y;\r\nfingers = z > 0 ? 1 : 0;\r\n}\r\nif (z >= 64)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nelse\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nalps_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\r\ninput_mt_report_finger_count(dev, fingers);\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_sync(dev);\r\nif (!(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS)) {\r\nleft = packet[3] & 0x10;\r\nright = packet[3] & 0x20;\r\nmiddle = packet[3] & 0x40;\r\ninput_report_key(dev2, BTN_LEFT, left);\r\ninput_report_key(dev2, BTN_RIGHT, right);\r\ninput_report_key(dev2, BTN_MIDDLE, middle);\r\ninput_sync(dev2);\r\n}\r\n}\r\nstatic void alps_process_packet_v3(struct psmouse *psmouse)\r\n{\r\nunsigned char *packet = psmouse->packet;\r\nif (packet[5] == 0x3f) {\r\nalps_process_trackstick_packet_v3(psmouse);\r\nreturn;\r\n}\r\nalps_process_touchpad_packet_v3(psmouse);\r\n}\r\nstatic void alps_process_packet_v4(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nint offset;\r\nint x, y, z;\r\nint left, right;\r\nint x1, y1, x2, y2;\r\nint fingers = 0;\r\nunsigned int x_bitmap, y_bitmap;\r\nif (packet[6] & 0x40) {\r\npriv->multi_packet = 0;\r\n}\r\nif (WARN_ON_ONCE(priv->multi_packet > 2))\r\nreturn;\r\noffset = 2 * priv->multi_packet;\r\npriv->multi_data[offset] = packet[6];\r\npriv->multi_data[offset + 1] = packet[7];\r\nif (++priv->multi_packet > 2) {\r\npriv->multi_packet = 0;\r\nx_bitmap = ((priv->multi_data[2] & 0x1f) << 10) |\r\n((priv->multi_data[3] & 0x60) << 3) |\r\n((priv->multi_data[0] & 0x3f) << 2) |\r\n((priv->multi_data[1] & 0x60) >> 5);\r\ny_bitmap = ((priv->multi_data[5] & 0x01) << 10) |\r\n((priv->multi_data[3] & 0x1f) << 5) |\r\n(priv->multi_data[1] & 0x1f);\r\nfingers = alps_process_bitmap(x_bitmap, y_bitmap,\r\n&x1, &y1, &x2, &y2);\r\npriv->fingers = fingers;\r\npriv->x1 = x1;\r\npriv->x2 = x2;\r\npriv->y1 = y1;\r\npriv->y2 = y2;\r\n}\r\nleft = packet[4] & 0x01;\r\nright = packet[4] & 0x02;\r\nx = ((packet[1] & 0x7f) << 4) | ((packet[3] & 0x30) >> 2) |\r\n((packet[0] & 0x30) >> 4);\r\ny = ((packet[2] & 0x7f) << 4) | (packet[3] & 0x0f);\r\nz = packet[5] & 0x7f;\r\nif (priv->fingers < 2) {\r\nx1 = x;\r\ny1 = y;\r\nfingers = z > 0 ? 1 : 0;\r\n} else {\r\nfingers = priv->fingers;\r\nx1 = priv->x1;\r\nx2 = priv->x2;\r\ny1 = priv->y1;\r\ny2 = priv->y2;\r\n}\r\nif (z >= 64)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nelse\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nalps_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\r\ninput_mt_report_finger_count(dev, fingers);\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_sync(dev);\r\n}\r\nstatic void alps_process_packet(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nswitch (model->proto_version) {\r\ncase ALPS_PROTO_V1:\r\ncase ALPS_PROTO_V2:\r\nalps_process_packet_v1_v2(psmouse);\r\nbreak;\r\ncase ALPS_PROTO_V3:\r\nalps_process_packet_v3(psmouse);\r\nbreak;\r\ncase ALPS_PROTO_V4:\r\nalps_process_packet_v4(psmouse);\r\nbreak;\r\n}\r\n}\r\nstatic void alps_report_bare_ps2_packet(struct psmouse *psmouse,\r\nunsigned char packet[],\r\nbool report_buttons)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev2 = priv->dev2;\r\nif (report_buttons)\r\nalps_report_buttons(psmouse, dev2, psmouse->dev,\r\npacket[0] & 1, packet[0] & 2, packet[0] & 4);\r\ninput_report_rel(dev2, REL_X,\r\npacket[1] ? packet[1] - ((packet[0] << 4) & 0x100) : 0);\r\ninput_report_rel(dev2, REL_Y,\r\npacket[2] ? ((packet[0] << 3) & 0x100) - packet[2] : 0);\r\ninput_sync(dev2);\r\n}\r\nstatic psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif (psmouse->pktcnt < 6)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif (psmouse->pktcnt == 6) {\r\nmod_timer(&priv->timer, jiffies + msecs_to_jiffies(20));\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\ndel_timer(&priv->timer);\r\nif (psmouse->packet[6] & 0x80) {\r\nif (((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) ||\r\n(!alps_is_valid_first_byte(priv->i, psmouse->packet[6]))) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet %x %x %x %x (suspected interleaved ps/2)\n",\r\npsmouse->packet[3], psmouse->packet[4],\r\npsmouse->packet[5], psmouse->packet[6]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nalps_process_packet(psmouse);\r\npsmouse->packet[0] = psmouse->packet[6];\r\npsmouse->pktcnt = 1;\r\n} else {\r\nalps_report_bare_ps2_packet(psmouse, &psmouse->packet[3],\r\nfalse);\r\npsmouse->packet[3] = psmouse->packet[6] & 0xf7;\r\npsmouse->pktcnt = 4;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic void alps_flush_packet(unsigned long data)\r\n{\r\nstruct psmouse *psmouse = (struct psmouse *)data;\r\nserio_pause_rx(psmouse->ps2dev.serio);\r\nif (psmouse->pktcnt == psmouse->pktsize) {\r\nif ((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet %x %x %x (suspected interleaved ps/2)\n",\r\npsmouse->packet[3], psmouse->packet[4],\r\npsmouse->packet[5]);\r\n} else {\r\nalps_process_packet(psmouse);\r\n}\r\npsmouse->pktcnt = 0;\r\n}\r\nserio_continue_rx(psmouse->ps2dev.serio);\r\n}\r\nstatic psmouse_ret_t alps_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nif ((psmouse->packet[0] & 0xc8) == 0x08) {\r\nif (psmouse->pktcnt == 3) {\r\nalps_report_bare_ps2_packet(psmouse, psmouse->packet,\r\ntrue);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nif ((model->flags & ALPS_PS2_INTERLEAVED) &&\r\npsmouse->pktcnt >= 4 && (psmouse->packet[3] & 0x0f) == 0x0f) {\r\nreturn alps_handle_interleaved_ps2(psmouse);\r\n}\r\nif (!alps_is_valid_first_byte(model, psmouse->packet[0])) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet[0] = %x (mask0 = %x, byte0 = %x)\n",\r\npsmouse->packet[0], model->mask0, model->byte0);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (psmouse->pktcnt >= 2 && psmouse->pktcnt <= psmouse->pktsize &&\r\n(psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {\r\npsmouse_dbg(psmouse, "refusing packet[%i] = %x\n",\r\npsmouse->pktcnt - 1,\r\npsmouse->packet[psmouse->pktcnt - 1]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (psmouse->pktcnt == psmouse->pktsize) {\r\nalps_process_packet(psmouse);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic int alps_command_mode_send_nibble(struct psmouse *psmouse, int nibble)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct alps_data *priv = psmouse->private;\r\nint command;\r\nunsigned char *param;\r\nunsigned char dummy[4];\r\nBUG_ON(nibble > 0xf);\r\ncommand = priv->nibble_commands[nibble].command;\r\nparam = (command & 0x0f00) ?\r\ndummy : (unsigned char *)&priv->nibble_commands[nibble].data;\r\nif (ps2_command(ps2dev, param, command))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_command_mode_set_addr(struct psmouse *psmouse, int addr)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct alps_data *priv = psmouse->private;\r\nint i, nibble;\r\nif (ps2_command(ps2dev, NULL, priv->addr_command))\r\nreturn -1;\r\nfor (i = 12; i >= 0; i -= 4) {\r\nnibble = (addr >> i) & 0xf;\r\nif (alps_command_mode_send_nibble(psmouse, nibble))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nif (addr != ((param[0] << 8) | param[1]))\r\nreturn -1;\r\nreturn param[2];\r\n}\r\nstatic int alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\r\n{\r\nif (alps_command_mode_set_addr(psmouse, addr))\r\nreturn -1;\r\nreturn __alps_command_mode_read_reg(psmouse, addr);\r\n}\r\nstatic int __alps_command_mode_write_reg(struct psmouse *psmouse, u8 value)\r\n{\r\nif (alps_command_mode_send_nibble(psmouse, (value >> 4) & 0xf))\r\nreturn -1;\r\nif (alps_command_mode_send_nibble(psmouse, value & 0xf))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_command_mode_write_reg(struct psmouse *psmouse, int addr,\r\nu8 value)\r\n{\r\nif (alps_command_mode_set_addr(psmouse, addr))\r\nreturn -1;\r\nreturn __alps_command_mode_write_reg(psmouse, value);\r\n}\r\nstatic int alps_enter_command_mode(struct psmouse *psmouse,\r\nunsigned char *resp)\r\n{\r\nunsigned char param[4];\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_WRAP) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\npsmouse_err(psmouse, "failed to enter command mode\n");\r\nreturn -1;\r\n}\r\nif (param[0] != 0x88 && param[1] != 0x07) {\r\npsmouse_dbg(psmouse,\r\n"unknown response while entering command mode: %2.2x %2.2x %2.2x\n",\r\nparam[0], param[1], param[2]);\r\nreturn -1;\r\n}\r\nif (resp)\r\n*resp = param[2];\r\nreturn 0;\r\n}\r\nstatic inline int alps_exit_command_mode(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic const struct alps_model_info *alps_get_model(struct psmouse *psmouse, int *version)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstatic const unsigned char rates[] = { 0, 10, 20, 40, 60, 80, 100, 200 };\r\nunsigned char param[4];\r\nconst struct alps_model_info *model = NULL;\r\nint i;\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11))\r\nreturn NULL;\r\nparam[0] = param[1] = param[2] = 0xff;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn NULL;\r\npsmouse_dbg(psmouse, "E6 report: %2.2x %2.2x %2.2x",\r\nparam[0], param[1], param[2]);\r\nif ((param[0] & 0xf8) != 0 || param[1] != 0 ||\r\n(param[2] != 10 && param[2] != 100))\r\nreturn NULL;\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21))\r\nreturn NULL;\r\nparam[0] = param[1] = param[2] = 0xff;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn NULL;\r\npsmouse_dbg(psmouse, "E7 report: %2.2x %2.2x %2.2x",\r\nparam[0], param[1], param[2]);\r\nif (version) {\r\nfor (i = 0; i < ARRAY_SIZE(rates) && param[2] != rates[i]; i++)\r\n;\r\n*version = (param[0] << 8) | (param[1] << 4) | i;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(alps_model_data); i++) {\r\nif (!memcmp(param, alps_model_data[i].signature,\r\nsizeof(alps_model_data[i].signature))) {\r\nmodel = alps_model_data + i;\r\nbreak;\r\n}\r\n}\r\nif (model && model->proto_version > ALPS_PROTO_V2) {\r\nmodel = NULL;\r\nif (alps_enter_command_mode(psmouse, param)) {\r\npsmouse_warn(psmouse,\r\n"touchpad failed to enter command mode\n");\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(alps_model_data); i++) {\r\nif (alps_model_data[i].proto_version > ALPS_PROTO_V2 &&\r\nalps_model_data[i].command_mode_resp == param[0]) {\r\nmodel = alps_model_data + i;\r\nbreak;\r\n}\r\n}\r\nalps_exit_command_mode(psmouse);\r\nif (!model)\r\npsmouse_dbg(psmouse,\r\n"Unknown command mode response %2.2x\n",\r\nparam[0]);\r\n}\r\n}\r\nreturn model;\r\n}\r\nstatic int alps_passthrough_mode_v2(struct psmouse *psmouse, bool enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETSCALE21 : PSMOUSE_CMD_SETSCALE11;\r\nif (ps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))\r\nreturn -1;\r\nps2_drain(ps2dev, 3, 100);\r\nreturn 0;\r\n}\r\nstatic int alps_absolute_mode_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE))\r\nreturn -1;\r\nreturn ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETPOLL);\r\n}\r\nstatic int alps_get_status(struct psmouse *psmouse, char *param)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\npsmouse_dbg(psmouse, "Status: %2.2x %2.2x %2.2x",\r\nparam[0], param[1], param[2]);\r\nreturn 0;\r\n}\r\nstatic int alps_tap_mode(struct psmouse *psmouse, int enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETRATE : PSMOUSE_CMD_SETRES;\r\nunsigned char tap_arg = enable ? 0x0A : 0x00;\r\nunsigned char param[4];\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, &tap_arg, cmd))\r\nreturn -1;\r\nif (alps_get_status(psmouse, param))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_poll(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char buf[sizeof(psmouse->packet)];\r\nbool poll_failed;\r\nif (priv->i->flags & ALPS_PASS)\r\nalps_passthrough_mode_v2(psmouse, true);\r\npoll_failed = ps2_command(&psmouse->ps2dev, buf,\r\nPSMOUSE_CMD_POLL | (psmouse->pktsize << 8)) < 0;\r\nif (priv->i->flags & ALPS_PASS)\r\nalps_passthrough_mode_v2(psmouse, false);\r\nif (poll_failed || (buf[0] & priv->i->mask0) != priv->i->byte0)\r\nreturn -1;\r\nif ((psmouse->badbyte & 0xc8) == 0x08) {\r\nif (ps2_command(&psmouse->ps2dev, buf, PSMOUSE_CMD_POLL | (3 << 8)))\r\nreturn -1;\r\n}\r\nmemcpy(psmouse->packet, buf, sizeof(buf));\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nif ((model->flags & ALPS_PASS) &&\r\nalps_passthrough_mode_v2(psmouse, true)) {\r\nreturn -1;\r\n}\r\nif (alps_tap_mode(psmouse, true)) {\r\npsmouse_warn(psmouse, "Failed to enable hardware tapping\n");\r\nreturn -1;\r\n}\r\nif (alps_absolute_mode_v1_v2(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enable absolute mode\n");\r\nreturn -1;\r\n}\r\nif ((model->flags & ALPS_PASS) &&\r\nalps_passthrough_mode_v2(psmouse, false)) {\r\nreturn -1;\r\n}\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)) {\r\npsmouse_err(psmouse, "Failed to enable stream mode\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_passthrough_mode_v3(struct psmouse *psmouse, bool enable)\r\n{\r\nint reg_val;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0008);\r\nif (reg_val == -1)\r\nreturn -1;\r\nif (enable)\r\nreg_val |= 0x01;\r\nelse\r\nreg_val &= ~0x01;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_absolute_mode_v3(struct psmouse *psmouse)\r\n{\r\nint reg_val;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0004);\r\nif (reg_val == -1)\r\nreturn -1;\r\nreg_val |= 0x06;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint reg_val;\r\nunsigned char param[4];\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\nif (alps_enter_command_mode(psmouse, NULL))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0008);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (reg_val & 0x80) {\r\nif (alps_passthrough_mode_v3(psmouse, true))\r\ngoto error;\r\nif (alps_exit_command_mode(psmouse))\r\ngoto error;\r\nparam[0] = 0x64;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE21) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {\r\npsmouse_warn(psmouse, "trackstick E7 report failed\n");\r\n} else {\r\npsmouse_dbg(psmouse,\r\n"trackstick E7 report: %2.2x %2.2x %2.2x\n",\r\nparam[0], param[1], param[2]);\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nalps_command_mode_send_nibble(psmouse, 0x9) ||\r\nalps_command_mode_send_nibble(psmouse, 0x4)) {\r\npsmouse_err(psmouse,\r\n"Error sending magic E6 sequence\n");\r\ngoto error_passthrough;\r\n}\r\n}\r\nif (alps_enter_command_mode(psmouse, NULL))\r\ngoto error_passthrough;\r\nif (alps_passthrough_mode_v3(psmouse, false))\r\ngoto error;\r\n}\r\nif (alps_absolute_mode_v3(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enter absolute mode\n");\r\ngoto error;\r\n}\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0006);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0007);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0144) == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, 0x04))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0159) == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, 0x03))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0163) == -1)\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0163, 0x03))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0162) == -1)\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0162, 0x04))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0008, 0x82))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nparam[0] = 0x64;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\npsmouse_err(psmouse, "Failed to enable data reporting\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nerror_passthrough:\r\nif (!alps_enter_command_mode(psmouse, NULL))\r\nalps_passthrough_mode_v3(psmouse, false);\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn -1;\r\n}\r\nstatic int alps_absolute_mode_v4(struct psmouse *psmouse)\r\n{\r\nint reg_val;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0004);\r\nif (reg_val == -1)\r\nreturn -1;\r\nreg_val |= 0x02;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v4(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\npriv->nibble_commands = alps_v4_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_DISABLE;\r\nif (alps_enter_command_mode(psmouse, NULL))\r\ngoto error;\r\nif (alps_absolute_mode_v4(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enter absolute mode\n");\r\ngoto error;\r\n}\r\nif (alps_command_mode_write_reg(psmouse, 0x0007, 0x8c))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0149, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0160, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x017f, 0x15))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0151, 0x01))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0168, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x014a, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0161, 0x03))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nparam[0] = 0xc8;\r\nparam[1] = 0x64;\r\nparam[2] = 0x50;\r\nif (ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[2], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETID))\r\nreturn -1;\r\nparam[0] = 0x64;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\npsmouse_err(psmouse, "Failed to enable data reporting\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn -1;\r\n}\r\nstatic int alps_hw_init(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nconst struct alps_model_info *model = priv->i;\r\nint ret = -1;\r\nswitch (model->proto_version) {\r\ncase ALPS_PROTO_V1:\r\ncase ALPS_PROTO_V2:\r\nret = alps_hw_init_v1_v2(psmouse);\r\nbreak;\r\ncase ALPS_PROTO_V3:\r\nret = alps_hw_init_v3(psmouse);\r\nbreak;\r\ncase ALPS_PROTO_V4:\r\nret = alps_hw_init_v4(psmouse);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int alps_reconnect(struct psmouse *psmouse)\r\n{\r\nconst struct alps_model_info *model;\r\npsmouse_reset(psmouse);\r\nmodel = alps_get_model(psmouse, NULL);\r\nif (!model)\r\nreturn -1;\r\nreturn alps_hw_init(psmouse);\r\n}\r\nstatic void alps_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\npsmouse_reset(psmouse);\r\ndel_timer_sync(&priv->timer);\r\ninput_unregister_device(priv->dev2);\r\nkfree(priv);\r\n}\r\nint alps_init(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv;\r\nconst struct alps_model_info *model;\r\nstruct input_dev *dev1 = psmouse->dev, *dev2;\r\nint version;\r\npriv = kzalloc(sizeof(struct alps_data), GFP_KERNEL);\r\ndev2 = input_allocate_device();\r\nif (!priv || !dev2)\r\ngoto init_fail;\r\npriv->dev2 = dev2;\r\nsetup_timer(&priv->timer, alps_flush_packet, (unsigned long)psmouse);\r\npsmouse->private = priv;\r\npsmouse_reset(psmouse);\r\nmodel = alps_get_model(psmouse, &version);\r\nif (!model)\r\ngoto init_fail;\r\npriv->i = model;\r\nif (alps_hw_init(psmouse))\r\ngoto init_fail;\r\n__clear_bit(EV_REL, dev1->evbit);\r\n__clear_bit(REL_X, dev1->relbit);\r\n__clear_bit(REL_Y, dev1->relbit);\r\ndev1->evbit[BIT_WORD(EV_KEY)] |= BIT_MASK(EV_KEY);\r\ndev1->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);\r\ndev1->keybit[BIT_WORD(BTN_TOOL_FINGER)] |= BIT_MASK(BTN_TOOL_FINGER);\r\ndev1->keybit[BIT_WORD(BTN_LEFT)] |=\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\r\ndev1->evbit[BIT_WORD(EV_ABS)] |= BIT_MASK(EV_ABS);\r\nswitch (model->proto_version) {\r\ncase ALPS_PROTO_V1:\r\ncase ALPS_PROTO_V2:\r\ninput_set_abs_params(dev1, ABS_X, 0, 1023, 0, 0);\r\ninput_set_abs_params(dev1, ABS_Y, 0, 767, 0, 0);\r\nbreak;\r\ncase ALPS_PROTO_V3:\r\ncase ALPS_PROTO_V4:\r\nset_bit(INPUT_PROP_SEMI_MT, dev1->propbit);\r\ninput_mt_init_slots(dev1, 2);\r\ninput_set_abs_params(dev1, ABS_MT_POSITION_X, 0, ALPS_V3_X_MAX, 0, 0);\r\ninput_set_abs_params(dev1, ABS_MT_POSITION_Y, 0, ALPS_V3_Y_MAX, 0, 0);\r\nset_bit(BTN_TOOL_DOUBLETAP, dev1->keybit);\r\nset_bit(BTN_TOOL_TRIPLETAP, dev1->keybit);\r\nset_bit(BTN_TOOL_QUADTAP, dev1->keybit);\r\ninput_set_abs_params(dev1, ABS_X, 0, ALPS_V3_X_MAX, 0, 0);\r\ninput_set_abs_params(dev1, ABS_Y, 0, ALPS_V3_Y_MAX, 0, 0);\r\nbreak;\r\n}\r\ninput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\r\nif (model->flags & ALPS_WHEEL) {\r\ndev1->evbit[BIT_WORD(EV_REL)] |= BIT_MASK(EV_REL);\r\ndev1->relbit[BIT_WORD(REL_WHEEL)] |= BIT_MASK(REL_WHEEL);\r\n}\r\nif (model->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ndev1->keybit[BIT_WORD(BTN_FORWARD)] |= BIT_MASK(BTN_FORWARD);\r\ndev1->keybit[BIT_WORD(BTN_BACK)] |= BIT_MASK(BTN_BACK);\r\n}\r\nif (model->flags & ALPS_FOUR_BUTTONS) {\r\ndev1->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_0);\r\ndev1->keybit[BIT_WORD(BTN_1)] |= BIT_MASK(BTN_1);\r\ndev1->keybit[BIT_WORD(BTN_2)] |= BIT_MASK(BTN_2);\r\ndev1->keybit[BIT_WORD(BTN_3)] |= BIT_MASK(BTN_3);\r\n} else {\r\ndev1->keybit[BIT_WORD(BTN_MIDDLE)] |= BIT_MASK(BTN_MIDDLE);\r\n}\r\nsnprintf(priv->phys, sizeof(priv->phys), "%s/input1", psmouse->ps2dev.serio->phys);\r\ndev2->phys = priv->phys;\r\ndev2->name = (model->flags & ALPS_DUALPOINT) ? "DualPoint Stick" : "PS/2 Mouse";\r\ndev2->id.bustype = BUS_I8042;\r\ndev2->id.vendor = 0x0002;\r\ndev2->id.product = PSMOUSE_ALPS;\r\ndev2->id.version = 0x0000;\r\ndev2->dev.parent = &psmouse->ps2dev.serio->dev;\r\ndev2->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ndev2->relbit[BIT_WORD(REL_X)] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\ndev2->keybit[BIT_WORD(BTN_LEFT)] =\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\r\nif (input_register_device(priv->dev2))\r\ngoto init_fail;\r\npsmouse->protocol_handler = alps_process_byte;\r\npsmouse->poll = alps_poll;\r\npsmouse->disconnect = alps_disconnect;\r\npsmouse->reconnect = alps_reconnect;\r\npsmouse->pktsize = model->proto_version == ALPS_PROTO_V4 ? 8 : 6;\r\npsmouse->resync_time = 0;\r\nreturn 0;\r\ninit_fail:\r\npsmouse_reset(psmouse);\r\ninput_free_device(dev2);\r\nkfree(priv);\r\npsmouse->private = NULL;\r\nreturn -1;\r\n}\r\nint alps_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nint version;\r\nconst struct alps_model_info *model;\r\nmodel = alps_get_model(psmouse, &version);\r\nif (!model)\r\nreturn -1;\r\nif (set_properties) {\r\npsmouse->vendor = "ALPS";\r\npsmouse->name = model->flags & ALPS_DUALPOINT ?\r\n"DualPoint TouchPad" : "GlidePoint";\r\npsmouse->model = version;\r\n}\r\nreturn 0;\r\n}
