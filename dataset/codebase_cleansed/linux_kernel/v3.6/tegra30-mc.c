static inline u32 mc_readl(struct tegra30_mc *mc, u32 offs)\r\n{\r\nu32 val = 0;\r\nif (offs < 0x10)\r\nval = readl(mc->regs[0] + offs);\r\nif (offs < 0x1f0)\r\nval = readl(mc->regs[1] + offs - 0x3c);\r\nif (offs < 0x228)\r\nval = readl(mc->regs[2] + offs - 0x200);\r\nif (offs < 0x400)\r\nval = readl(mc->regs[3] + offs - 0x284);\r\nreturn val;\r\n}\r\nstatic inline void mc_writel(struct tegra30_mc *mc, u32 val, u32 offs)\r\n{\r\nif (offs < 0x10) {\r\nwritel(val, mc->regs[0] + offs);\r\nreturn;\r\n}\r\nif (offs < 0x1f0) {\r\nwritel(val, mc->regs[1] + offs - 0x3c);\r\nreturn;\r\n}\r\nif (offs < 0x228) {\r\nwritel(val, mc->regs[2] + offs - 0x200);\r\nreturn;\r\n}\r\nif (offs < 0x400) {\r\nwritel(val, mc->regs[3] + offs - 0x284);\r\nreturn;\r\n}\r\n}\r\nstatic void tegra30_mc_decode(struct tegra30_mc *mc, int n)\r\n{\r\nu32 err, addr;\r\nconst char * const mc_int_err[] = {\r\n"MC_DECERR",\r\n"Unknown",\r\n"MC_SECURITY_ERR",\r\n"MC_ARBITRATION_EMEM",\r\n"MC_SMMU_ERR",\r\n};\r\nconst char * const err_type[] = {\r\n"Unknown",\r\n"Unknown",\r\n"DECERR_EMEM",\r\n"SECURITY_TRUSTZONE",\r\n"SECURITY_CARVEOUT",\r\n"Unknown",\r\n"INVALID_SMMU_PAGE",\r\n"Unknown",\r\n};\r\nchar attr[6];\r\nint cid, perm, type, idx;\r\nconst char *client = "Unknown";\r\nidx = n - MC_INT_ERR_SHIFT;\r\nif ((idx < 0) || (idx >= ARRAY_SIZE(mc_int_err)) || (idx == 1)) {\r\ndev_err_ratelimited(mc->dev, "Unknown interrupt status %08lx\n",\r\nBIT(n));\r\nreturn;\r\n}\r\nerr = readl(mc + MC_ERR_STATUS);\r\ntype = (err & MC_ERR_TYPE_MASK) >> MC_ERR_TYPE_SHIFT;\r\nperm = (err & MC_ERR_INVALID_SMMU_PAGE_MASK) >>\r\nMC_ERR_INVALID_SMMU_PAGE_SHIFT;\r\nif (type == MC_ERR_TYPE_INVALID_SMMU_PAGE)\r\nsprintf(attr, "%c-%c-%c",\r\n(perm & BIT(2)) ? 'R' : '-',\r\n(perm & BIT(1)) ? 'W' : '-',\r\n(perm & BIT(0)) ? 'S' : '-');\r\nelse\r\nattr[0] = '\0';\r\ncid = err & MC_CLIENT_ID_MASK;\r\nif (cid < ARRAY_SIZE(tegra30_mc_client))\r\nclient = tegra30_mc_client[cid];\r\naddr = readl(mc + MC_ERR_ADR);\r\ndev_err_ratelimited(mc->dev, "%s (0x%08x): 0x%08x %s (%s %s %s %s)\n",\r\nmc_int_err[idx], err, addr, client,\r\n(err & MC_ERR_SECURITY) ? "secure" : "non-secure",\r\n(err & MC_ERR_RW) ? "write" : "read",\r\nerr_type[type], attr);\r\n}\r\nstatic int tegra30_mc_suspend(struct device *dev)\r\n{\r\nint i;\r\nstruct tegra30_mc *mc = dev_get_drvdata(dev);\r\nfor (i = 0; i < ARRAY_SIZE(tegra30_mc_ctx); i++)\r\nmc->ctx[i] = mc_readl(mc, tegra30_mc_ctx[i]);\r\nreturn 0;\r\n}\r\nstatic int tegra30_mc_resume(struct device *dev)\r\n{\r\nint i;\r\nstruct tegra30_mc *mc = dev_get_drvdata(dev);\r\nfor (i = 0; i < ARRAY_SIZE(tegra30_mc_ctx); i++)\r\nmc_writel(mc, mc->ctx[i], tegra30_mc_ctx[i]);\r\nmc_writel(mc, 1, MC_TIMING_CONTROL);\r\nmc_readl(mc, MC_TIMING_CONTROL);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tegra30_mc_isr(int irq, void *data)\r\n{\r\nu32 stat, mask, bit;\r\nstruct tegra30_mc *mc = data;\r\nstat = mc_readl(mc, MC_INTSTATUS);\r\nmask = mc_readl(mc, MC_INTMASK);\r\nmask &= stat;\r\nif (!mask)\r\nreturn IRQ_NONE;\r\nwhile ((bit = ffs(mask)) != 0)\r\ntegra30_mc_decode(mc, bit - 1);\r\nmc_writel(mc, stat, MC_INTSTATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit tegra30_mc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *irq;\r\nstruct tegra30_mc *mc;\r\nsize_t bytes;\r\nint err, i;\r\nu32 intmask;\r\nbytes = sizeof(*mc) + sizeof(u32) * ARRAY_SIZE(tegra30_mc_ctx);\r\nmc = devm_kzalloc(&pdev->dev, bytes, GFP_KERNEL);\r\nif (!mc)\r\nreturn -ENOMEM;\r\nmc->dev = &pdev->dev;\r\nfor (i = 0; i < ARRAY_SIZE(mc->regs); i++) {\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res)\r\nreturn -ENODEV;\r\nmc->regs[i] = devm_request_and_ioremap(&pdev->dev, res);\r\nif (!mc->regs[i])\r\nreturn -EBUSY;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq)\r\nreturn -ENODEV;\r\nerr = devm_request_irq(&pdev->dev, irq->start, tegra30_mc_isr,\r\nIRQF_SHARED, dev_name(&pdev->dev), mc);\r\nif (err)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, mc);\r\nintmask = MC_INT_INVALID_SMMU_PAGE |\r\nMC_INT_DECERR_EMEM | MC_INT_SECURITY_VIOLATION;\r\nmc_writel(mc, intmask, MC_INTMASK);\r\nreturn 0;\r\n}
