static inline void imx2_wdt_setup(void)\r\n{\r\nu16 val = __raw_readw(imx2_wdt.base + IMX2_WDT_WCR);\r\nval &= ~IMX2_WDT_WCR_WT;\r\nval &= ~IMX2_WDT_WCR_WRE;\r\nval &= ~IMX2_WDT_WCR_WDE;\r\nval |= WDOG_SEC_TO_COUNT(imx2_wdt.timeout);\r\n__raw_writew(val, imx2_wdt.base + IMX2_WDT_WCR);\r\nval |= IMX2_WDT_WCR_WDE;\r\n__raw_writew(val, imx2_wdt.base + IMX2_WDT_WCR);\r\n}\r\nstatic inline void imx2_wdt_ping(void)\r\n{\r\n__raw_writew(IMX2_WDT_SEQ1, imx2_wdt.base + IMX2_WDT_WSR);\r\n__raw_writew(IMX2_WDT_SEQ2, imx2_wdt.base + IMX2_WDT_WSR);\r\n}\r\nstatic void imx2_wdt_timer_ping(unsigned long arg)\r\n{\r\nimx2_wdt_ping();\r\nmod_timer(&imx2_wdt.timer, jiffies + imx2_wdt.timeout * HZ / 2);\r\n}\r\nstatic void imx2_wdt_start(void)\r\n{\r\nif (!test_and_set_bit(IMX2_WDT_STATUS_STARTED, &imx2_wdt.status)) {\r\nclk_prepare_enable(imx2_wdt.clk);\r\nimx2_wdt_setup();\r\n} else\r\ndel_timer_sync(&imx2_wdt.timer);\r\nimx2_wdt_ping();\r\n}\r\nstatic void imx2_wdt_stop(void)\r\n{\r\nimx2_wdt_timer_ping(0);\r\n}\r\nstatic void imx2_wdt_set_timeout(int new_timeout)\r\n{\r\nu16 val = __raw_readw(imx2_wdt.base + IMX2_WDT_WCR);\r\nval &= ~IMX2_WDT_WCR_WT;\r\nval |= WDOG_SEC_TO_COUNT(new_timeout);\r\n__raw_writew(val, imx2_wdt.base + IMX2_WDT_WCR);\r\n}\r\nstatic int imx2_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(IMX2_WDT_STATUS_OPEN, &imx2_wdt.status))\r\nreturn -EBUSY;\r\nimx2_wdt_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int imx2_wdt_close(struct inode *inode, struct file *file)\r\n{\r\nif (test_bit(IMX2_WDT_EXPECT_CLOSE, &imx2_wdt.status) && !nowayout)\r\nimx2_wdt_stop();\r\nelse {\r\ndev_crit(imx2_wdt_miscdev.parent,\r\n"Unexpected close: Expect reboot!\n");\r\nimx2_wdt_ping();\r\n}\r\nclear_bit(IMX2_WDT_EXPECT_CLOSE, &imx2_wdt.status);\r\nclear_bit(IMX2_WDT_STATUS_OPEN, &imx2_wdt.status);\r\nreturn 0;\r\n}\r\nstatic long imx2_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_value;\r\nu16 val;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &imx2_wdt_info,\r\nsizeof(struct watchdog_info)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_GETBOOTSTATUS:\r\nval = __raw_readw(imx2_wdt.base + IMX2_WDT_WRSR);\r\nnew_value = val & IMX2_WDT_WRSR_TOUT ? WDIOF_CARDRESET : 0;\r\nreturn put_user(new_value, p);\r\ncase WDIOC_KEEPALIVE:\r\nimx2_wdt_ping();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_value, p))\r\nreturn -EFAULT;\r\nif ((new_value < 1) || (new_value > IMX2_WDT_MAX_TIME))\r\nreturn -EINVAL;\r\nimx2_wdt_set_timeout(new_value);\r\nimx2_wdt.timeout = new_value;\r\nimx2_wdt_ping();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(imx2_wdt.timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic ssize_t imx2_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nsize_t i;\r\nchar c;\r\nif (len == 0)\r\nreturn 0;\r\nclear_bit(IMX2_WDT_EXPECT_CLOSE, &imx2_wdt.status);\r\nfor (i = 0; i != len; i++) {\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(IMX2_WDT_EXPECT_CLOSE, &imx2_wdt.status);\r\n}\r\nimx2_wdt_ping();\r\nreturn len;\r\n}\r\nstatic int __init imx2_wdt_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't get device resources\n");\r\nreturn -ENODEV;\r\n}\r\nimx2_wdt.base = devm_request_and_ioremap(&pdev->dev, res);\r\nif (!imx2_wdt.base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\nimx2_wdt.clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(imx2_wdt.clk)) {\r\ndev_err(&pdev->dev, "can't get Watchdog clock\n");\r\nreturn PTR_ERR(imx2_wdt.clk);\r\n}\r\nimx2_wdt.timeout = clamp_t(unsigned, timeout, 1, IMX2_WDT_MAX_TIME);\r\nif (imx2_wdt.timeout != timeout)\r\ndev_warn(&pdev->dev, "Initial timeout out of range! "\r\n"Clamped from %u to %u\n", timeout, imx2_wdt.timeout);\r\nsetup_timer(&imx2_wdt.timer, imx2_wdt_timer_ping, 0);\r\nimx2_wdt_miscdev.parent = &pdev->dev;\r\nret = misc_register(&imx2_wdt_miscdev);\r\nif (ret)\r\ngoto fail;\r\ndev_info(&pdev->dev,\r\n"IMX2+ Watchdog Timer enabled. timeout=%ds (nowayout=%d)\n",\r\nimx2_wdt.timeout, nowayout);\r\nreturn 0;\r\nfail:\r\nimx2_wdt_miscdev.parent = NULL;\r\nclk_put(imx2_wdt.clk);\r\nreturn ret;\r\n}\r\nstatic int __exit imx2_wdt_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&imx2_wdt_miscdev);\r\nif (test_bit(IMX2_WDT_STATUS_STARTED, &imx2_wdt.status)) {\r\ndel_timer_sync(&imx2_wdt.timer);\r\ndev_crit(imx2_wdt_miscdev.parent,\r\n"Device removed: Expect reboot!\n");\r\n} else\r\nclk_put(imx2_wdt.clk);\r\nimx2_wdt_miscdev.parent = NULL;\r\nreturn 0;\r\n}\r\nstatic void imx2_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nif (test_bit(IMX2_WDT_STATUS_STARTED, &imx2_wdt.status)) {\r\ndel_timer_sync(&imx2_wdt.timer);\r\nimx2_wdt_set_timeout(IMX2_WDT_MAX_TIME);\r\nimx2_wdt_ping();\r\ndev_crit(imx2_wdt_miscdev.parent,\r\n"Device shutdown: Expect reboot!\n");\r\n}\r\n}\r\nstatic int __init imx2_wdt_init(void)\r\n{\r\nreturn platform_driver_probe(&imx2_wdt_driver, imx2_wdt_probe);\r\n}\r\nstatic void __exit imx2_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&imx2_wdt_driver);\r\n}
