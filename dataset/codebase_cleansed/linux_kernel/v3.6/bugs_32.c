static void cmov_sigill_test_handler(int sig)\r\n{\r\nhost_has_cmov = 0;\r\nlongjmp(cmov_test_return, 1);\r\n}\r\nvoid arch_check_bugs(void)\r\n{\r\nstruct sigaction old, new;\r\nprintk(UM_KERN_INFO "Checking for host processor cmov support...");\r\nnew.sa_handler = cmov_sigill_test_handler;\r\nnew.sa_flags = SA_NODEFER;\r\nsigemptyset(&new.sa_mask);\r\nsigaction(SIGILL, &new, &old);\r\nif (setjmp(cmov_test_return) == 0) {\r\nunsigned long foo = 0;\r\n__asm__ __volatile__("cmovz %0, %1" : "=r" (foo) : "0" (foo));\r\nprintk(UM_KERN_CONT "Yes\n");\r\n} else\r\nprintk(UM_KERN_CONT "No\n");\r\nsigaction(SIGILL, &old, &new);\r\n}\r\nvoid arch_examine_signal(int sig, struct uml_pt_regs *regs)\r\n{\r\nunsigned char tmp[2];\r\nif ((sig != SIGILL) || (get_current_pid() != 1))\r\nreturn;\r\nif (copy_from_user_proc(tmp, (void *) UPT_IP(regs), 2)) {\r\nprintk(UM_KERN_ERR "SIGILL in init, could not read "\r\n"instructions!\n");\r\nreturn;\r\n}\r\nif ((tmp[0] != 0x0f) || ((tmp[1] & 0xf0) != 0x40))\r\nreturn;\r\nif (host_has_cmov == 0)\r\nprintk(UM_KERN_ERR "SIGILL caused by cmov, which this "\r\n"processor doesn't implement. Boot a filesystem "\r\n"compiled for older processors");\r\nelse if (host_has_cmov == 1)\r\nprintk(UM_KERN_ERR "SIGILL caused by cmov, which this "\r\n"processor claims to implement");\r\nelse\r\nprintk(UM_KERN_ERR "Bad value for host_has_cmov (%d)",\r\nhost_has_cmov);\r\n}
