static void via_print_sdchc(struct via_crdr_mmc_host *host)\r\n{\r\nvoid __iomem *addrbase = host->sdhc_mmiobase;\r\npr_debug("SDC MMIO Registers:\n");\r\npr_debug("SDCONTROL=%08x, SDCMDARG=%08x, SDBUSMODE=%08x\n",\r\nreadl(addrbase + VIA_CRDR_SDCTRL),\r\nreadl(addrbase + VIA_CRDR_SDCARG),\r\nreadl(addrbase + VIA_CRDR_SDBUSMODE));\r\npr_debug("SDBLKLEN=%08x, SDCURBLKCNT=%08x, SDINTMASK=%08x\n",\r\nreadl(addrbase + VIA_CRDR_SDBLKLEN),\r\nreadl(addrbase + VIA_CRDR_SDCURBLKCNT),\r\nreadl(addrbase + VIA_CRDR_SDINTMASK));\r\npr_debug("SDSTATUS=%08x, SDCLKSEL=%08x, SDEXTCTRL=%08x\n",\r\nreadl(addrbase + VIA_CRDR_SDSTATUS),\r\nreadl(addrbase + VIA_CRDR_SDCLKSEL),\r\nreadl(addrbase + VIA_CRDR_SDEXTCTRL));\r\n}\r\nstatic void via_print_pcictrl(struct via_crdr_mmc_host *host)\r\n{\r\nvoid __iomem *addrbase = host->pcictrl_mmiobase;\r\npr_debug("PCI Control Registers:\n");\r\npr_debug("PCICLKGATT=%02x, PCISDCCLK=%02x, PCIDMACLK=%02x\n",\r\nreadb(addrbase + VIA_CRDR_PCICLKGATT),\r\nreadb(addrbase + VIA_CRDR_PCISDCCLK),\r\nreadb(addrbase + VIA_CRDR_PCIDMACLK));\r\npr_debug("PCIINTCTRL=%02x, PCIINTSTATUS=%02x\n",\r\nreadb(addrbase + VIA_CRDR_PCIINTCTRL),\r\nreadb(addrbase + VIA_CRDR_PCIINTSTATUS));\r\n}\r\nstatic void via_save_pcictrlreg(struct via_crdr_mmc_host *host)\r\n{\r\nstruct pcictrlreg *pm_pcictrl_reg;\r\nvoid __iomem *addrbase;\r\npm_pcictrl_reg = &(host->pm_pcictrl_reg);\r\naddrbase = host->pcictrl_mmiobase;\r\npm_pcictrl_reg->pciclkgat_reg = readb(addrbase + VIA_CRDR_PCICLKGATT);\r\npm_pcictrl_reg->pciclkgat_reg |=\r\nVIA_CRDR_PCICLKGATT_3V3 | VIA_CRDR_PCICLKGATT_PAD_PWRON;\r\npm_pcictrl_reg->pcisdclk_reg = readb(addrbase + VIA_CRDR_PCISDCCLK);\r\npm_pcictrl_reg->pcidmaclk_reg = readb(addrbase + VIA_CRDR_PCIDMACLK);\r\npm_pcictrl_reg->pciintctrl_reg = readb(addrbase + VIA_CRDR_PCIINTCTRL);\r\npm_pcictrl_reg->pciintstatus_reg =\r\nreadb(addrbase + VIA_CRDR_PCIINTSTATUS);\r\npm_pcictrl_reg->pcitmoctrl_reg = readb(addrbase + VIA_CRDR_PCITMOCTRL);\r\n}\r\nstatic void via_restore_pcictrlreg(struct via_crdr_mmc_host *host)\r\n{\r\nstruct pcictrlreg *pm_pcictrl_reg;\r\nvoid __iomem *addrbase;\r\npm_pcictrl_reg = &(host->pm_pcictrl_reg);\r\naddrbase = host->pcictrl_mmiobase;\r\nwriteb(pm_pcictrl_reg->pciclkgat_reg, addrbase + VIA_CRDR_PCICLKGATT);\r\nwriteb(pm_pcictrl_reg->pcisdclk_reg, addrbase + VIA_CRDR_PCISDCCLK);\r\nwriteb(pm_pcictrl_reg->pcidmaclk_reg, addrbase + VIA_CRDR_PCIDMACLK);\r\nwriteb(pm_pcictrl_reg->pciintctrl_reg, addrbase + VIA_CRDR_PCIINTCTRL);\r\nwriteb(pm_pcictrl_reg->pciintstatus_reg,\r\naddrbase + VIA_CRDR_PCIINTSTATUS);\r\nwriteb(pm_pcictrl_reg->pcitmoctrl_reg, addrbase + VIA_CRDR_PCITMOCTRL);\r\n}\r\nstatic void via_save_sdcreg(struct via_crdr_mmc_host *host)\r\n{\r\nstruct sdhcreg *pm_sdhc_reg;\r\nvoid __iomem *addrbase;\r\npm_sdhc_reg = &(host->pm_sdhc_reg);\r\naddrbase = host->sdhc_mmiobase;\r\npm_sdhc_reg->sdcontrol_reg = readl(addrbase + VIA_CRDR_SDCTRL);\r\npm_sdhc_reg->sdcmdarg_reg = readl(addrbase + VIA_CRDR_SDCARG);\r\npm_sdhc_reg->sdbusmode_reg = readl(addrbase + VIA_CRDR_SDBUSMODE);\r\npm_sdhc_reg->sdblklen_reg = readl(addrbase + VIA_CRDR_SDBLKLEN);\r\npm_sdhc_reg->sdcurblkcnt_reg = readl(addrbase + VIA_CRDR_SDCURBLKCNT);\r\npm_sdhc_reg->sdintmask_reg = readl(addrbase + VIA_CRDR_SDINTMASK);\r\npm_sdhc_reg->sdstatus_reg = readl(addrbase + VIA_CRDR_SDSTATUS);\r\npm_sdhc_reg->sdrsptmo_reg = readl(addrbase + VIA_CRDR_SDRSPTMO);\r\npm_sdhc_reg->sdclksel_reg = readl(addrbase + VIA_CRDR_SDCLKSEL);\r\npm_sdhc_reg->sdextctrl_reg = readl(addrbase + VIA_CRDR_SDEXTCTRL);\r\n}\r\nstatic void via_restore_sdcreg(struct via_crdr_mmc_host *host)\r\n{\r\nstruct sdhcreg *pm_sdhc_reg;\r\nvoid __iomem *addrbase;\r\npm_sdhc_reg = &(host->pm_sdhc_reg);\r\naddrbase = host->sdhc_mmiobase;\r\nwritel(pm_sdhc_reg->sdcontrol_reg, addrbase + VIA_CRDR_SDCTRL);\r\nwritel(pm_sdhc_reg->sdcmdarg_reg, addrbase + VIA_CRDR_SDCARG);\r\nwritel(pm_sdhc_reg->sdbusmode_reg, addrbase + VIA_CRDR_SDBUSMODE);\r\nwritel(pm_sdhc_reg->sdblklen_reg, addrbase + VIA_CRDR_SDBLKLEN);\r\nwritel(pm_sdhc_reg->sdcurblkcnt_reg, addrbase + VIA_CRDR_SDCURBLKCNT);\r\nwritel(pm_sdhc_reg->sdintmask_reg, addrbase + VIA_CRDR_SDINTMASK);\r\nwritel(pm_sdhc_reg->sdstatus_reg, addrbase + VIA_CRDR_SDSTATUS);\r\nwritel(pm_sdhc_reg->sdrsptmo_reg, addrbase + VIA_CRDR_SDRSPTMO);\r\nwritel(pm_sdhc_reg->sdclksel_reg, addrbase + VIA_CRDR_SDCLKSEL);\r\nwritel(pm_sdhc_reg->sdextctrl_reg, addrbase + VIA_CRDR_SDEXTCTRL);\r\n}\r\nstatic void via_pwron_sleep(struct via_crdr_mmc_host *sdhost)\r\n{\r\nif (sdhost->quirks & VIA_CRDR_QUIRK_300MS_PWRDELAY)\r\nmsleep(300);\r\nelse\r\nmsleep(3);\r\n}\r\nstatic void via_set_ddma(struct via_crdr_mmc_host *host,\r\ndma_addr_t dmaaddr, u32 count, int dir, int enirq)\r\n{\r\nvoid __iomem *addrbase;\r\nu32 ctrl_data = 0;\r\nif (enirq)\r\nctrl_data |= VIA_CRDR_DMACTRL_ENIRQ;\r\nif (dir)\r\nctrl_data |= VIA_CRDR_DMACTRL_DIR;\r\naddrbase = host->ddma_mmiobase;\r\nwritel(dmaaddr, addrbase + VIA_CRDR_DMABASEADD);\r\nwritel(count, addrbase + VIA_CRDR_DMACOUNTER);\r\nwritel(ctrl_data, addrbase + VIA_CRDR_DMACTRL);\r\nwritel(0x01, addrbase + VIA_CRDR_DMASTART);\r\naddrbase = host->pcictrl_mmiobase;\r\nif (readb(addrbase + VIA_CRDR_PCISDCCLK) == PCI_CLK_375K) {\r\ndev_info(host->mmc->parent, "forcing card speed to 8MHz\n");\r\nwriteb(PCI_CLK_8M, addrbase + VIA_CRDR_PCISDCCLK);\r\n}\r\n}\r\nstatic void via_sdc_preparedata(struct via_crdr_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nvoid __iomem *addrbase;\r\nu32 blk_reg;\r\nint count;\r\nWARN_ON(host->data);\r\nBUG_ON(data->blksz > host->mmc->max_blk_size);\r\nBUG_ON(data->blocks > host->mmc->max_blk_count);\r\nhost->data = data;\r\ncount = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\n((data->flags & MMC_DATA_READ) ?\r\nPCI_DMA_FROMDEVICE : PCI_DMA_TODEVICE));\r\nBUG_ON(count != 1);\r\nvia_set_ddma(host, sg_dma_address(data->sg), sg_dma_len(data->sg),\r\n(data->flags & MMC_DATA_WRITE) ? 1 : 0, 1);\r\naddrbase = host->sdhc_mmiobase;\r\nblk_reg = data->blksz - 1;\r\nblk_reg |= VIA_CRDR_SDBLKLEN_GPIDET | VIA_CRDR_SDBLKLEN_INTEN;\r\nblk_reg |= (data->blocks) << 16;\r\nwritel(blk_reg, addrbase + VIA_CRDR_SDBLKLEN);\r\n}\r\nstatic void via_sdc_get_response(struct via_crdr_mmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nvoid __iomem *addrbase = host->sdhc_mmiobase;\r\nu32 dwdata0 = readl(addrbase + VIA_CRDR_SDRESP0);\r\nu32 dwdata1 = readl(addrbase + VIA_CRDR_SDRESP1);\r\nu32 dwdata2 = readl(addrbase + VIA_CRDR_SDRESP2);\r\nu32 dwdata3 = readl(addrbase + VIA_CRDR_SDRESP3);\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[0] = ((u8) (dwdata1)) |\r\n(((u8) (dwdata0 >> 24)) << 8) |\r\n(((u8) (dwdata0 >> 16)) << 16) |\r\n(((u8) (dwdata0 >> 8)) << 24);\r\ncmd->resp[1] = ((u8) (dwdata2)) |\r\n(((u8) (dwdata1 >> 24)) << 8) |\r\n(((u8) (dwdata1 >> 16)) << 16) |\r\n(((u8) (dwdata1 >> 8)) << 24);\r\ncmd->resp[2] = ((u8) (dwdata3)) |\r\n(((u8) (dwdata2 >> 24)) << 8) |\r\n(((u8) (dwdata2 >> 16)) << 16) |\r\n(((u8) (dwdata2 >> 8)) << 24);\r\ncmd->resp[3] = 0xff |\r\n((((u8) (dwdata3 >> 24))) << 8) |\r\n(((u8) (dwdata3 >> 16)) << 16) |\r\n(((u8) (dwdata3 >> 8)) << 24);\r\n} else {\r\ndwdata0 >>= 8;\r\ncmd->resp[0] = ((dwdata0 & 0xff) << 24) |\r\n(((dwdata0 >> 8) & 0xff) << 16) |\r\n(((dwdata0 >> 16) & 0xff) << 8) | (dwdata1 & 0xff);\r\ndwdata1 >>= 8;\r\ncmd->resp[1] = ((dwdata1 & 0xff) << 24) |\r\n(((dwdata1 >> 8) & 0xff) << 16) |\r\n(((dwdata1 >> 16) & 0xff) << 8);\r\n}\r\n}\r\nstatic void via_sdc_send_command(struct via_crdr_mmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nvoid __iomem *addrbase;\r\nstruct mmc_data *data;\r\nu32 cmdctrl = 0;\r\nWARN_ON(host->cmd);\r\ndata = cmd->data;\r\nmod_timer(&host->timer, jiffies + HZ);\r\nhost->cmd = cmd;\r\ncmdctrl = cmd->opcode << 8;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\ncmdctrl |= VIA_CRDR_SDCTRL_RSP_NONE;\r\nbreak;\r\ncase MMC_RSP_R1:\r\ncmdctrl |= VIA_CRDR_SDCTRL_RSP_R1;\r\nbreak;\r\ncase MMC_RSP_R1B:\r\ncmdctrl |= VIA_CRDR_SDCTRL_RSP_R1B;\r\nbreak;\r\ncase MMC_RSP_R2:\r\ncmdctrl |= VIA_CRDR_SDCTRL_RSP_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\ncmdctrl |= VIA_CRDR_SDCTRL_RSP_R3;\r\nbreak;\r\ndefault:\r\npr_err("%s: cmd->flag is not valid\n", mmc_hostname(host->mmc));\r\nbreak;\r\n}\r\nif (!(cmd->data))\r\ngoto nodata;\r\nvia_sdc_preparedata(host, data);\r\nif (data->blocks > 1) {\r\nif (data->flags & MMC_DATA_WRITE) {\r\ncmdctrl |= VIA_CRDR_SDCTRL_WRITE;\r\ncmdctrl |= VIA_CRDR_SDCTRL_MULTI_WR;\r\n} else {\r\ncmdctrl |= VIA_CRDR_SDCTRL_MULTI_RD;\r\n}\r\n} else {\r\nif (data->flags & MMC_DATA_WRITE) {\r\ncmdctrl |= VIA_CRDR_SDCTRL_WRITE;\r\ncmdctrl |= VIA_CRDR_SDCTRL_SINGLE_WR;\r\n} else {\r\ncmdctrl |= VIA_CRDR_SDCTRL_SINGLE_RD;\r\n}\r\n}\r\nnodata:\r\nif (cmd == host->mrq->stop)\r\ncmdctrl |= VIA_CRDR_SDCTRL_STOP;\r\ncmdctrl |= VIA_CRDR_SDCTRL_START;\r\naddrbase = host->sdhc_mmiobase;\r\nwritel(cmd->arg, addrbase + VIA_CRDR_SDCARG);\r\nwritel(cmdctrl, addrbase + VIA_CRDR_SDCTRL);\r\n}\r\nstatic void via_sdc_finish_data(struct via_crdr_mmc_host *host)\r\n{\r\nstruct mmc_data *data;\r\nBUG_ON(!host->data);\r\ndata = host->data;\r\nhost->data = NULL;\r\nif (data->error)\r\ndata->bytes_xfered = 0;\r\nelse\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\n((data->flags & MMC_DATA_READ) ?\r\nPCI_DMA_FROMDEVICE : PCI_DMA_TODEVICE));\r\nif (data->stop)\r\nvia_sdc_send_command(host, data->stop);\r\nelse\r\ntasklet_schedule(&host->finish_tasklet);\r\n}\r\nstatic void via_sdc_finish_command(struct via_crdr_mmc_host *host)\r\n{\r\nvia_sdc_get_response(host, host->cmd);\r\nhost->cmd->error = 0;\r\nif (!host->cmd->data)\r\ntasklet_schedule(&host->finish_tasklet);\r\nhost->cmd = NULL;\r\n}\r\nstatic void via_sdc_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nvoid __iomem *addrbase;\r\nstruct via_crdr_mmc_host *host;\r\nunsigned long flags;\r\nu16 status;\r\nhost = mmc_priv(mmc);\r\nspin_lock_irqsave(&host->lock, flags);\r\naddrbase = host->pcictrl_mmiobase;\r\nwriteb(VIA_CRDR_PCIDMACLK_SDC, addrbase + VIA_CRDR_PCIDMACLK);\r\nstatus = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\r\nstatus &= VIA_CRDR_SDSTS_W1C_MASK;\r\nwritew(status, host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = mrq;\r\nstatus = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\r\nif (!(status & VIA_CRDR_SDSTS_SLOTG) || host->reject) {\r\nhost->mrq->cmd->error = -ENOMEDIUM;\r\ntasklet_schedule(&host->finish_tasklet);\r\n} else {\r\nvia_sdc_send_command(host, mrq->cmd);\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void via_sdc_set_power(struct via_crdr_mmc_host *host,\r\nunsigned short power, unsigned int on)\r\n{\r\nunsigned long flags;\r\nu8 gatt;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->power = (1 << power);\r\ngatt = readb(host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nif (host->power == MMC_VDD_165_195)\r\ngatt &= ~VIA_CRDR_PCICLKGATT_3V3;\r\nelse\r\ngatt |= VIA_CRDR_PCICLKGATT_3V3;\r\nif (on)\r\ngatt |= VIA_CRDR_PCICLKGATT_PAD_PWRON;\r\nelse\r\ngatt &= ~VIA_CRDR_PCICLKGATT_PAD_PWRON;\r\nwriteb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nmmiowb();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nvia_pwron_sleep(host);\r\n}\r\nstatic void via_sdc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct via_crdr_mmc_host *host;\r\nunsigned long flags;\r\nvoid __iomem *addrbase;\r\nu32 org_data, sdextctrl;\r\nu8 clock;\r\nhost = mmc_priv(mmc);\r\nspin_lock_irqsave(&host->lock, flags);\r\naddrbase = host->sdhc_mmiobase;\r\norg_data = readl(addrbase + VIA_CRDR_SDBUSMODE);\r\nsdextctrl = readl(addrbase + VIA_CRDR_SDEXTCTRL);\r\nif (ios->bus_width == MMC_BUS_WIDTH_1)\r\norg_data &= ~VIA_CRDR_SDMODE_4BIT;\r\nelse\r\norg_data |= VIA_CRDR_SDMODE_4BIT;\r\nif (ios->power_mode == MMC_POWER_OFF)\r\norg_data &= ~VIA_CRDR_SDMODE_CLK_ON;\r\nelse\r\norg_data |= VIA_CRDR_SDMODE_CLK_ON;\r\nif (ios->timing == MMC_TIMING_SD_HS)\r\nsdextctrl |= VIA_CRDR_SDEXTCTRL_HISPD;\r\nelse\r\nsdextctrl &= ~VIA_CRDR_SDEXTCTRL_HISPD;\r\nwritel(org_data, addrbase + VIA_CRDR_SDBUSMODE);\r\nwritel(sdextctrl, addrbase + VIA_CRDR_SDEXTCTRL);\r\nif (ios->clock >= 48000000)\r\nclock = PCI_CLK_48M;\r\nelse if (ios->clock >= 33000000)\r\nclock = PCI_CLK_33M;\r\nelse if (ios->clock >= 24000000)\r\nclock = PCI_CLK_24M;\r\nelse if (ios->clock >= 16000000)\r\nclock = PCI_CLK_16M;\r\nelse if (ios->clock >= 12000000)\r\nclock = PCI_CLK_12M;\r\nelse if (ios->clock >= 8000000)\r\nclock = PCI_CLK_8M;\r\nelse\r\nclock = PCI_CLK_375K;\r\naddrbase = host->pcictrl_mmiobase;\r\nif (readb(addrbase + VIA_CRDR_PCISDCCLK) != clock)\r\nwriteb(clock, addrbase + VIA_CRDR_PCISDCCLK);\r\nmmiowb();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (ios->power_mode != MMC_POWER_OFF)\r\nvia_sdc_set_power(host, ios->vdd, 1);\r\nelse\r\nvia_sdc_set_power(host, ios->vdd, 0);\r\n}\r\nstatic int via_sdc_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct via_crdr_mmc_host *host;\r\nunsigned long flags;\r\nu16 status;\r\nhost = mmc_priv(mmc);\r\nspin_lock_irqsave(&host->lock, flags);\r\nstatus = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn !(status & VIA_CRDR_SDSTS_WP);\r\n}\r\nstatic void via_reset_pcictrl(struct via_crdr_mmc_host *host)\r\n{\r\nunsigned long flags;\r\nu8 gatt;\r\nspin_lock_irqsave(&host->lock, flags);\r\nvia_save_pcictrlreg(host);\r\nvia_save_sdcreg(host);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\ngatt = VIA_CRDR_PCICLKGATT_PAD_PWRON;\r\nif (host->power == MMC_VDD_165_195)\r\ngatt &= VIA_CRDR_PCICLKGATT_3V3;\r\nelse\r\ngatt |= VIA_CRDR_PCICLKGATT_3V3;\r\nwriteb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nvia_pwron_sleep(host);\r\ngatt |= VIA_CRDR_PCICLKGATT_SFTRST;\r\nwriteb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nmsleep(3);\r\nspin_lock_irqsave(&host->lock, flags);\r\nvia_restore_pcictrlreg(host);\r\nvia_restore_sdcreg(host);\r\nmmiowb();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void via_sdc_cmd_isr(struct via_crdr_mmc_host *host, u16 intmask)\r\n{\r\nBUG_ON(intmask == 0);\r\nif (!host->cmd) {\r\npr_err("%s: Got command interrupt 0x%x even "\r\n"though no command operation was in progress.\n",\r\nmmc_hostname(host->mmc), intmask);\r\nreturn;\r\n}\r\nif (intmask & VIA_CRDR_SDSTS_CRTO)\r\nhost->cmd->error = -ETIMEDOUT;\r\nelse if (intmask & VIA_CRDR_SDSTS_SC)\r\nhost->cmd->error = -EILSEQ;\r\nif (host->cmd->error)\r\ntasklet_schedule(&host->finish_tasklet);\r\nelse if (intmask & VIA_CRDR_SDSTS_CRD)\r\nvia_sdc_finish_command(host);\r\n}\r\nstatic void via_sdc_data_isr(struct via_crdr_mmc_host *host, u16 intmask)\r\n{\r\nBUG_ON(intmask == 0);\r\nif (intmask & VIA_CRDR_SDSTS_DT)\r\nhost->data->error = -ETIMEDOUT;\r\nelse if (intmask & (VIA_CRDR_SDSTS_RC | VIA_CRDR_SDSTS_WC))\r\nhost->data->error = -EILSEQ;\r\nvia_sdc_finish_data(host);\r\n}\r\nstatic irqreturn_t via_sdc_isr(int irq, void *dev_id)\r\n{\r\nstruct via_crdr_mmc_host *sdhost = dev_id;\r\nvoid __iomem *addrbase;\r\nu8 pci_status;\r\nu16 sd_status;\r\nirqreturn_t result;\r\nif (!sdhost)\r\nreturn IRQ_NONE;\r\nspin_lock(&sdhost->lock);\r\naddrbase = sdhost->pcictrl_mmiobase;\r\npci_status = readb(addrbase + VIA_CRDR_PCIINTSTATUS);\r\nif (!(pci_status & VIA_CRDR_PCIINTSTATUS_SDC)) {\r\nresult = IRQ_NONE;\r\ngoto out;\r\n}\r\naddrbase = sdhost->sdhc_mmiobase;\r\nsd_status = readw(addrbase + VIA_CRDR_SDSTATUS);\r\nsd_status &= VIA_CRDR_SDSTS_INT_MASK;\r\nsd_status &= ~VIA_CRDR_SDSTS_IGN_MASK;\r\nif (!sd_status) {\r\nresult = IRQ_NONE;\r\ngoto out;\r\n}\r\nif (sd_status & VIA_CRDR_SDSTS_CIR) {\r\nwritew(sd_status & VIA_CRDR_SDSTS_CIR,\r\naddrbase + VIA_CRDR_SDSTATUS);\r\nschedule_work(&sdhost->carddet_work);\r\n}\r\nsd_status &= ~VIA_CRDR_SDSTS_CIR;\r\nif (sd_status & VIA_CRDR_SDSTS_CMD_MASK) {\r\nwritew(sd_status & VIA_CRDR_SDSTS_CMD_MASK,\r\naddrbase + VIA_CRDR_SDSTATUS);\r\nvia_sdc_cmd_isr(sdhost, sd_status & VIA_CRDR_SDSTS_CMD_MASK);\r\n}\r\nif (sd_status & VIA_CRDR_SDSTS_DATA_MASK) {\r\nwritew(sd_status & VIA_CRDR_SDSTS_DATA_MASK,\r\naddrbase + VIA_CRDR_SDSTATUS);\r\nvia_sdc_data_isr(sdhost, sd_status & VIA_CRDR_SDSTS_DATA_MASK);\r\n}\r\nsd_status &= ~(VIA_CRDR_SDSTS_CMD_MASK | VIA_CRDR_SDSTS_DATA_MASK);\r\nif (sd_status) {\r\npr_err("%s: Unexpected interrupt 0x%x\n",\r\nmmc_hostname(sdhost->mmc), sd_status);\r\nwritew(sd_status, addrbase + VIA_CRDR_SDSTATUS);\r\n}\r\nresult = IRQ_HANDLED;\r\nmmiowb();\r\nout:\r\nspin_unlock(&sdhost->lock);\r\nreturn result;\r\n}\r\nstatic void via_sdc_timeout(unsigned long ulongdata)\r\n{\r\nstruct via_crdr_mmc_host *sdhost;\r\nunsigned long flags;\r\nsdhost = (struct via_crdr_mmc_host *)ulongdata;\r\nspin_lock_irqsave(&sdhost->lock, flags);\r\nif (sdhost->mrq) {\r\npr_err("%s: Timeout waiting for hardware interrupt."\r\n"cmd:0x%x\n", mmc_hostname(sdhost->mmc),\r\nsdhost->mrq->cmd->opcode);\r\nif (sdhost->data) {\r\nwritel(VIA_CRDR_DMACTRL_SFTRST,\r\nsdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);\r\nsdhost->data->error = -ETIMEDOUT;\r\nvia_sdc_finish_data(sdhost);\r\n} else {\r\nif (sdhost->cmd)\r\nsdhost->cmd->error = -ETIMEDOUT;\r\nelse\r\nsdhost->mrq->cmd->error = -ETIMEDOUT;\r\ntasklet_schedule(&sdhost->finish_tasklet);\r\n}\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&sdhost->lock, flags);\r\n}\r\nstatic void via_sdc_tasklet_finish(unsigned long param)\r\n{\r\nstruct via_crdr_mmc_host *host;\r\nunsigned long flags;\r\nstruct mmc_request *mrq;\r\nhost = (struct via_crdr_mmc_host *)param;\r\nspin_lock_irqsave(&host->lock, flags);\r\ndel_timer(&host->timer);\r\nmrq = host->mrq;\r\nhost->mrq = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void via_sdc_card_detect(struct work_struct *work)\r\n{\r\nstruct via_crdr_mmc_host *host;\r\nvoid __iomem *addrbase;\r\nunsigned long flags;\r\nu16 status;\r\nhost = container_of(work, struct via_crdr_mmc_host, carddet_work);\r\naddrbase = host->ddma_mmiobase;\r\nwritel(VIA_CRDR_DMACTRL_SFTRST, addrbase + VIA_CRDR_DMACTRL);\r\nspin_lock_irqsave(&host->lock, flags);\r\naddrbase = host->pcictrl_mmiobase;\r\nwriteb(VIA_CRDR_PCIDMACLK_SDC, addrbase + VIA_CRDR_PCIDMACLK);\r\naddrbase = host->sdhc_mmiobase;\r\nstatus = readw(addrbase + VIA_CRDR_SDSTATUS);\r\nif (!(status & VIA_CRDR_SDSTS_SLOTG)) {\r\nif (host->mrq) {\r\npr_err("%s: Card removed during transfer!\n",\r\nmmc_hostname(host->mmc));\r\nhost->mrq->cmd->error = -ENOMEDIUM;\r\ntasklet_schedule(&host->finish_tasklet);\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nvia_reset_pcictrl(host);\r\nspin_lock_irqsave(&host->lock, flags);\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nvia_print_pcictrl(host);\r\nvia_print_sdchc(host);\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(500));\r\n}\r\nstatic void via_init_mmc_host(struct via_crdr_mmc_host *host)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nvoid __iomem *addrbase;\r\nu32 lenreg;\r\nu32 status;\r\ninit_timer(&host->timer);\r\nhost->timer.data = (unsigned long)host;\r\nhost->timer.function = via_sdc_timeout;\r\nspin_lock_init(&host->lock);\r\nmmc->f_min = VIA_CRDR_MIN_CLOCK;\r\nmmc->f_max = VIA_CRDR_MAX_CLOCK;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED;\r\nmmc->ops = &via_sdc_ops;\r\nmmc->max_segs = 1;\r\nmmc->max_blk_size = VIA_CRDR_MAX_BLOCK_LENGTH;\r\nmmc->max_blk_count = VIA_CRDR_MAX_BLOCK_COUNT;\r\nmmc->max_seg_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_req_size = mmc->max_seg_size;\r\nINIT_WORK(&host->carddet_work, via_sdc_card_detect);\r\ntasklet_init(&host->finish_tasklet, via_sdc_tasklet_finish,\r\n(unsigned long)host);\r\naddrbase = host->sdhc_mmiobase;\r\nwritel(0x0, addrbase + VIA_CRDR_SDINTMASK);\r\nmsleep(1);\r\nlenreg = VIA_CRDR_SDBLKLEN_GPIDET | VIA_CRDR_SDBLKLEN_INTEN;\r\nwritel(lenreg, addrbase + VIA_CRDR_SDBLKLEN);\r\nstatus = readw(addrbase + VIA_CRDR_SDSTATUS);\r\nstatus &= VIA_CRDR_SDSTS_W1C_MASK;\r\nwritew(status, addrbase + VIA_CRDR_SDSTATUS);\r\nstatus = readw(addrbase + VIA_CRDR_SDSTATUS2);\r\nstatus |= VIA_CRDR_SDSTS_CFE;\r\nwritew(status, addrbase + VIA_CRDR_SDSTATUS2);\r\nwriteb(0x0, addrbase + VIA_CRDR_SDEXTCTRL);\r\nwritel(VIA_CRDR_SDACTIVE_INTMASK, addrbase + VIA_CRDR_SDINTMASK);\r\nmsleep(1);\r\n}\r\nstatic int __devinit via_sd_probe(struct pci_dev *pcidev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct via_crdr_mmc_host *sdhost;\r\nu32 base, len;\r\nu8 gatt;\r\nint ret;\r\npr_info(DRV_NAME\r\n": VIA SDMMC controller found at %s [%04x:%04x] (rev %x)\n",\r\npci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device,\r\n(int)pcidev->revision);\r\nret = pci_enable_device(pcidev);\r\nif (ret)\r\nreturn ret;\r\nret = pci_request_regions(pcidev, DRV_NAME);\r\nif (ret)\r\ngoto disable;\r\npci_write_config_byte(pcidev, VIA_CRDR_PCI_WORK_MODE, 0);\r\npci_write_config_byte(pcidev, VIA_CRDR_PCI_DBG_MODE, 0);\r\nmmc = mmc_alloc_host(sizeof(struct via_crdr_mmc_host), &pcidev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nsdhost = mmc_priv(mmc);\r\nsdhost->mmc = mmc;\r\ndev_set_drvdata(&pcidev->dev, sdhost);\r\nlen = pci_resource_len(pcidev, 0);\r\nbase = pci_resource_start(pcidev, 0);\r\nsdhost->mmiobase = ioremap_nocache(base, len);\r\nif (!sdhost->mmiobase) {\r\nret = -ENOMEM;\r\ngoto free_mmc_host;\r\n}\r\nsdhost->sdhc_mmiobase =\r\nsdhost->mmiobase + VIA_CRDR_SDC_OFF;\r\nsdhost->ddma_mmiobase =\r\nsdhost->mmiobase + VIA_CRDR_DDMA_OFF;\r\nsdhost->pcictrl_mmiobase =\r\nsdhost->mmiobase + VIA_CRDR_PCICTRL_OFF;\r\nsdhost->power = MMC_VDD_165_195;\r\ngatt = VIA_CRDR_PCICLKGATT_3V3 | VIA_CRDR_PCICLKGATT_PAD_PWRON;\r\nwriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nvia_pwron_sleep(sdhost);\r\ngatt |= VIA_CRDR_PCICLKGATT_SFTRST;\r\nwriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nmsleep(3);\r\nvia_init_mmc_host(sdhost);\r\nret =\r\nrequest_irq(pcidev->irq, via_sdc_isr, IRQF_SHARED, DRV_NAME,\r\nsdhost);\r\nif (ret)\r\ngoto unmap;\r\nwriteb(VIA_CRDR_PCIINTCTRL_SDCIRQEN,\r\nsdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);\r\nwriteb(VIA_CRDR_PCITMOCTRL_1024MS,\r\nsdhost->pcictrl_mmiobase + VIA_CRDR_PCITMOCTRL);\r\nif (pcidev->subsystem_vendor == PCI_VENDOR_ID_LENOVO &&\r\npcidev->subsystem_device == 0x3891)\r\nsdhost->quirks = VIA_CRDR_QUIRK_300MS_PWRDELAY;\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nunmap:\r\niounmap(sdhost->mmiobase);\r\nfree_mmc_host:\r\ndev_set_drvdata(&pcidev->dev, NULL);\r\nmmc_free_host(mmc);\r\nrelease:\r\npci_release_regions(pcidev);\r\ndisable:\r\npci_disable_device(pcidev);\r\nreturn ret;\r\n}\r\nstatic void __devexit via_sd_remove(struct pci_dev *pcidev)\r\n{\r\nstruct via_crdr_mmc_host *sdhost = pci_get_drvdata(pcidev);\r\nunsigned long flags;\r\nu8 gatt;\r\nspin_lock_irqsave(&sdhost->lock, flags);\r\nsdhost->reject = 1;\r\nwriteb(0x0, sdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);\r\nmmiowb();\r\nif (sdhost->mrq) {\r\npr_err("%s: Controller removed during "\r\n"transfer\n", mmc_hostname(sdhost->mmc));\r\nwritel(VIA_CRDR_DMACTRL_SFTRST,\r\nsdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);\r\nmmiowb();\r\nsdhost->mrq->cmd->error = -ENOMEDIUM;\r\nif (sdhost->mrq->stop)\r\nsdhost->mrq->stop->error = -ENOMEDIUM;\r\ntasklet_schedule(&sdhost->finish_tasklet);\r\n}\r\nspin_unlock_irqrestore(&sdhost->lock, flags);\r\nmmc_remove_host(sdhost->mmc);\r\nfree_irq(pcidev->irq, sdhost);\r\ndel_timer_sync(&sdhost->timer);\r\ntasklet_kill(&sdhost->finish_tasklet);\r\ngatt = readb(sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\ngatt &= ~VIA_CRDR_PCICLKGATT_PAD_PWRON;\r\nwriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\niounmap(sdhost->mmiobase);\r\ndev_set_drvdata(&pcidev->dev, NULL);\r\nmmc_free_host(sdhost->mmc);\r\npci_release_regions(pcidev);\r\npci_disable_device(pcidev);\r\npr_info(DRV_NAME\r\n": VIA SDMMC controller at %s [%04x:%04x] has been removed\n",\r\npci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device);\r\n}\r\nstatic void via_init_sdc_pm(struct via_crdr_mmc_host *host)\r\n{\r\nstruct sdhcreg *pm_sdhcreg;\r\nvoid __iomem *addrbase;\r\nu32 lenreg;\r\nu16 status;\r\npm_sdhcreg = &(host->pm_sdhc_reg);\r\naddrbase = host->sdhc_mmiobase;\r\nwritel(0x0, addrbase + VIA_CRDR_SDINTMASK);\r\nlenreg = VIA_CRDR_SDBLKLEN_GPIDET | VIA_CRDR_SDBLKLEN_INTEN;\r\nwritel(lenreg, addrbase + VIA_CRDR_SDBLKLEN);\r\nstatus = readw(addrbase + VIA_CRDR_SDSTATUS);\r\nstatus &= VIA_CRDR_SDSTS_W1C_MASK;\r\nwritew(status, addrbase + VIA_CRDR_SDSTATUS);\r\nstatus = readw(addrbase + VIA_CRDR_SDSTATUS2);\r\nstatus |= VIA_CRDR_SDSTS_CFE;\r\nwritew(status, addrbase + VIA_CRDR_SDSTATUS2);\r\nwritel(pm_sdhcreg->sdcontrol_reg, addrbase + VIA_CRDR_SDCTRL);\r\nwritel(pm_sdhcreg->sdcmdarg_reg, addrbase + VIA_CRDR_SDCARG);\r\nwritel(pm_sdhcreg->sdintmask_reg, addrbase + VIA_CRDR_SDINTMASK);\r\nwritel(pm_sdhcreg->sdrsptmo_reg, addrbase + VIA_CRDR_SDRSPTMO);\r\nwritel(pm_sdhcreg->sdclksel_reg, addrbase + VIA_CRDR_SDCLKSEL);\r\nwritel(pm_sdhcreg->sdextctrl_reg, addrbase + VIA_CRDR_SDEXTCTRL);\r\nvia_print_pcictrl(host);\r\nvia_print_sdchc(host);\r\n}\r\nstatic int via_sd_suspend(struct pci_dev *pcidev, pm_message_t state)\r\n{\r\nstruct via_crdr_mmc_host *host;\r\nint ret = 0;\r\nhost = pci_get_drvdata(pcidev);\r\nvia_save_pcictrlreg(host);\r\nvia_save_sdcreg(host);\r\nret = mmc_suspend_host(host->mmc);\r\npci_save_state(pcidev);\r\npci_enable_wake(pcidev, pci_choose_state(pcidev, state), 0);\r\npci_disable_device(pcidev);\r\npci_set_power_state(pcidev, pci_choose_state(pcidev, state));\r\nreturn ret;\r\n}\r\nstatic int via_sd_resume(struct pci_dev *pcidev)\r\n{\r\nstruct via_crdr_mmc_host *sdhost;\r\nint ret = 0;\r\nu8 gatt;\r\nsdhost = pci_get_drvdata(pcidev);\r\ngatt = VIA_CRDR_PCICLKGATT_PAD_PWRON;\r\nif (sdhost->power == MMC_VDD_165_195)\r\ngatt &= ~VIA_CRDR_PCICLKGATT_3V3;\r\nelse\r\ngatt |= VIA_CRDR_PCICLKGATT_3V3;\r\nwriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nvia_pwron_sleep(sdhost);\r\ngatt |= VIA_CRDR_PCICLKGATT_SFTRST;\r\nwriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\r\nmsleep(3);\r\nmsleep(100);\r\npci_set_power_state(pcidev, PCI_D0);\r\npci_restore_state(pcidev);\r\nret = pci_enable_device(pcidev);\r\nif (ret)\r\nreturn ret;\r\nvia_restore_pcictrlreg(sdhost);\r\nvia_init_sdc_pm(sdhost);\r\nret = mmc_resume_host(sdhost->mmc);\r\nreturn ret;\r\n}\r\nstatic int __init via_sd_drv_init(void)\r\n{\r\npr_info(DRV_NAME ": VIA SD/MMC Card Reader driver "\r\n"(C) 2008 VIA Technologies, Inc.\n");\r\nreturn pci_register_driver(&via_sd_driver);\r\n}\r\nstatic void __exit via_sd_drv_exit(void)\r\n{\r\npci_unregister_driver(&via_sd_driver);\r\n}
