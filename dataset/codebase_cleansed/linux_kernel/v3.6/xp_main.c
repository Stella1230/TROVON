static enum xp_retval\r\nxpc_notloaded(void)\r\n{\r\nreturn xpNotLoaded;\r\n}\r\nvoid\r\nxpc_clear_interface(void)\r\n{\r\nxpc_interface.connect = (void (*)(int))xpc_notloaded;\r\nxpc_interface.disconnect = (void (*)(int))xpc_notloaded;\r\nxpc_interface.send = (enum xp_retval(*)(short, int, u32, void *, u16))\r\nxpc_notloaded;\r\nxpc_interface.send_notify = (enum xp_retval(*)(short, int, u32, void *,\r\nu16, xpc_notify_func,\r\nvoid *))xpc_notloaded;\r\nxpc_interface.received = (void (*)(short, int, void *))\r\nxpc_notloaded;\r\nxpc_interface.partid_to_nasids = (enum xp_retval(*)(short, void *))\r\nxpc_notloaded;\r\n}\r\nenum xp_retval\r\nxpc_connect(int ch_number, xpc_channel_func func, void *key, u16 payload_size,\r\nu16 nentries, u32 assigned_limit, u32 idle_limit)\r\n{\r\nstruct xpc_registration *registration;\r\nDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\r\nDBUG_ON(payload_size == 0 || nentries == 0);\r\nDBUG_ON(func == NULL);\r\nDBUG_ON(assigned_limit == 0 || idle_limit > assigned_limit);\r\nif (XPC_MSG_SIZE(payload_size) > XPC_MSG_MAX_SIZE)\r\nreturn xpPayloadTooBig;\r\nregistration = &xpc_registrations[ch_number];\r\nif (mutex_lock_interruptible(&registration->mutex) != 0)\r\nreturn xpInterrupted;\r\nif (registration->func != NULL) {\r\nmutex_unlock(&registration->mutex);\r\nreturn xpAlreadyRegistered;\r\n}\r\nregistration->entry_size = XPC_MSG_SIZE(payload_size);\r\nregistration->nentries = nentries;\r\nregistration->assigned_limit = assigned_limit;\r\nregistration->idle_limit = idle_limit;\r\nregistration->key = key;\r\nregistration->func = func;\r\nmutex_unlock(&registration->mutex);\r\nxpc_interface.connect(ch_number);\r\nreturn xpSuccess;\r\n}\r\nvoid\r\nxpc_disconnect(int ch_number)\r\n{\r\nstruct xpc_registration *registration;\r\nDBUG_ON(ch_number < 0 || ch_number >= XPC_MAX_NCHANNELS);\r\nregistration = &xpc_registrations[ch_number];\r\nmutex_lock(&registration->mutex);\r\nif (registration->func == NULL) {\r\nmutex_unlock(&registration->mutex);\r\nreturn;\r\n}\r\nregistration->func = NULL;\r\nregistration->key = NULL;\r\nregistration->nentries = 0;\r\nregistration->entry_size = 0;\r\nregistration->assigned_limit = 0;\r\nregistration->idle_limit = 0;\r\nxpc_interface.disconnect(ch_number);\r\nmutex_unlock(&registration->mutex);\r\nreturn;\r\n}\r\nint __init\r\nxp_init(void)\r\n{\r\nenum xp_retval ret;\r\nint ch_number;\r\nfor (ch_number = 0; ch_number < XPC_MAX_NCHANNELS; ch_number++)\r\nmutex_init(&xpc_registrations[ch_number].mutex);\r\nif (is_shub())\r\nret = xp_init_sn2();\r\nelse if (is_uv())\r\nret = xp_init_uv();\r\nelse\r\nret = 0;\r\nif (ret != xpSuccess)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid __exit\r\nxp_exit(void)\r\n{\r\nif (is_shub())\r\nxp_exit_sn2();\r\nelse if (is_uv())\r\nxp_exit_uv();\r\n}
