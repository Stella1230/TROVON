static int af9015_rw_udev(struct usb_device *udev, struct req_t *req)\r\n{\r\n#define BUF_LEN 63\r\n#define REQ_HDR_LEN 8\r\n#define ACK_HDR_LEN 2\r\nint act_len, ret;\r\nu8 buf[BUF_LEN];\r\nu8 write = 1;\r\nu8 msg_len = REQ_HDR_LEN;\r\nstatic u8 seq;\r\nif (mutex_lock_interruptible(&af9015_usb_mutex) < 0)\r\nreturn -EAGAIN;\r\nbuf[0] = req->cmd;\r\nbuf[1] = seq++;\r\nbuf[2] = req->i2c_addr;\r\nbuf[3] = req->addr >> 8;\r\nbuf[4] = req->addr & 0xff;\r\nbuf[5] = req->mbox;\r\nbuf[6] = req->addr_len;\r\nbuf[7] = req->data_len;\r\nswitch (req->cmd) {\r\ncase GET_CONFIG:\r\ncase READ_MEMORY:\r\ncase RECONNECT_USB:\r\nwrite = 0;\r\nbreak;\r\ncase READ_I2C:\r\nwrite = 0;\r\nbuf[2] |= 0x01;\r\ncase WRITE_I2C:\r\nbuf[0] = READ_WRITE_I2C;\r\nbreak;\r\ncase WRITE_MEMORY:\r\nif (((req->addr & 0xff00) == 0xff00) ||\r\n((req->addr & 0xff00) == 0xae00))\r\nbuf[0] = WRITE_VIRTUAL_MEMORY;\r\ncase WRITE_VIRTUAL_MEMORY:\r\ncase COPY_FIRMWARE:\r\ncase DOWNLOAD_FIRMWARE:\r\ncase BOOT:\r\nbreak;\r\ndefault:\r\nerr("unknown command:%d", req->cmd);\r\nret = -1;\r\ngoto error_unlock;\r\n}\r\nif ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||\r\n(!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {\r\nerr("too much data; cmd:%d len:%d", req->cmd, req->data_len);\r\nret = -EINVAL;\r\ngoto error_unlock;\r\n}\r\nif (write) {\r\nmemcpy(&buf[REQ_HDR_LEN], req->data, req->data_len);\r\nmsg_len += req->data_len;\r\n}\r\ndeb_xfer(">>> ");\r\ndebug_dump(buf, msg_len, deb_xfer);\r\nret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 0x02), buf, msg_len,\r\n&act_len, AF9015_USB_TIMEOUT);\r\nif (ret)\r\nerr("bulk message failed:%d (%d/%d)", ret, msg_len, act_len);\r\nelse\r\nif (act_len != msg_len)\r\nret = -1;\r\nif (ret)\r\ngoto error_unlock;\r\nif (req->cmd == DOWNLOAD_FIRMWARE || req->cmd == RECONNECT_USB)\r\ngoto exit_unlock;\r\nmsg_len = ACK_HDR_LEN;\r\nif (!write)\r\nmsg_len += req->data_len;\r\nret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, 0x81), buf, msg_len,\r\n&act_len, AF9015_USB_TIMEOUT);\r\nif (ret) {\r\nerr("recv bulk message failed:%d", ret);\r\nret = -1;\r\ngoto error_unlock;\r\n}\r\ndeb_xfer("<<< ");\r\ndebug_dump(buf, act_len, deb_xfer);\r\nif (buf[1]) {\r\nerr("command failed:%d", buf[1]);\r\nret = -1;\r\ngoto error_unlock;\r\n}\r\nif (!write)\r\nmemcpy(req->data, &buf[ACK_HDR_LEN], req->data_len);\r\nerror_unlock:\r\nexit_unlock:\r\nmutex_unlock(&af9015_usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)\r\n{\r\nreturn af9015_rw_udev(d->udev, req);\r\n}\r\nstatic int af9015_write_regs(struct dvb_usb_device *d, u16 addr, u8 *val,\r\nu8 len)\r\n{\r\nstruct req_t req = {WRITE_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,\r\nval};\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_write_reg(struct dvb_usb_device *d, u16 addr, u8 val)\r\n{\r\nreturn af9015_write_regs(d, addr, &val, 1);\r\n}\r\nstatic int af9015_read_regs(struct dvb_usb_device *d, u16 addr, u8 *val, u8 len)\r\n{\r\nstruct req_t req = {READ_MEMORY, AF9015_I2C_DEMOD, addr, 0, 0, len,\r\nval};\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_read_reg(struct dvb_usb_device *d, u16 addr, u8 *val)\r\n{\r\nreturn af9015_read_regs(d, addr, val, 1);\r\n}\r\nstatic int af9015_write_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,\r\nu8 val)\r\n{\r\nstruct req_t req = {WRITE_I2C, addr, reg, 1, 1, 1, &val};\r\nif (addr == af9015_af9013_config[0].i2c_addr ||\r\naddr == af9015_af9013_config[1].i2c_addr)\r\nreq.addr_len = 3;\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_read_reg_i2c(struct dvb_usb_device *d, u8 addr, u16 reg,\r\nu8 *val)\r\n{\r\nstruct req_t req = {READ_I2C, addr, reg, 0, 1, 1, val};\r\nif (addr == af9015_af9013_config[0].i2c_addr ||\r\naddr == af9015_af9013_config[1].i2c_addr)\r\nreq.addr_len = 3;\r\nreturn af9015_ctrl_msg(d, &req);\r\n}\r\nstatic int af9015_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0, i = 0;\r\nu16 addr;\r\nu8 uninitialized_var(mbox), addr_len;\r\nstruct req_t req;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nwhile (i < num) {\r\nif (msg[i].addr == af9015_af9013_config[0].i2c_addr ||\r\nmsg[i].addr == af9015_af9013_config[1].i2c_addr) {\r\naddr = msg[i].buf[0] << 8;\r\naddr += msg[i].buf[1];\r\nmbox = msg[i].buf[2];\r\naddr_len = 3;\r\n} else {\r\naddr = msg[i].buf[0];\r\naddr_len = 1;\r\n}\r\nif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\r\nif (msg[i].len > 3 || msg[i+1].len > 61) {\r\nret = -EOPNOTSUPP;\r\ngoto error;\r\n}\r\nif (msg[i].addr == af9015_af9013_config[0].i2c_addr)\r\nreq.cmd = READ_MEMORY;\r\nelse\r\nreq.cmd = READ_I2C;\r\nreq.i2c_addr = msg[i].addr;\r\nreq.addr = addr;\r\nreq.mbox = mbox;\r\nreq.addr_len = addr_len;\r\nreq.data_len = msg[i+1].len;\r\nreq.data = &msg[i+1].buf[0];\r\nret = af9015_ctrl_msg(d, &req);\r\ni += 2;\r\n} else if (msg[i].flags & I2C_M_RD) {\r\nif (msg[i].len > 61) {\r\nret = -EOPNOTSUPP;\r\ngoto error;\r\n}\r\nif (msg[i].addr ==\r\naf9015_af9013_config[0].i2c_addr) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nreq.cmd = READ_I2C;\r\nreq.i2c_addr = msg[i].addr;\r\nreq.addr = addr;\r\nreq.mbox = mbox;\r\nreq.addr_len = addr_len;\r\nreq.data_len = msg[i].len;\r\nreq.data = &msg[i].buf[0];\r\nret = af9015_ctrl_msg(d, &req);\r\ni += 1;\r\n} else {\r\nif (msg[i].len > 21) {\r\nret = -EOPNOTSUPP;\r\ngoto error;\r\n}\r\nif (msg[i].addr == af9015_af9013_config[0].i2c_addr)\r\nreq.cmd = WRITE_MEMORY;\r\nelse\r\nreq.cmd = WRITE_I2C;\r\nreq.i2c_addr = msg[i].addr;\r\nreq.addr = addr;\r\nreq.mbox = mbox;\r\nreq.addr_len = addr_len;\r\nreq.data_len = msg[i].len-addr_len;\r\nreq.data = &msg[i].buf[addr_len];\r\nret = af9015_ctrl_msg(d, &req);\r\ni += 1;\r\n}\r\nif (ret)\r\ngoto error;\r\n}\r\nret = i;\r\nerror:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 af9015_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int af9015_do_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit, u8 op)\r\n{\r\nint ret;\r\nu8 val, mask = 0x01;\r\nret = af9015_read_reg(d, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nmask <<= bit;\r\nif (op) {\r\nval |= mask;\r\n} else {\r\nmask ^= 0xff;\r\nval &= mask;\r\n}\r\nreturn af9015_write_reg(d, addr, val);\r\n}\r\nstatic int af9015_set_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)\r\n{\r\nreturn af9015_do_reg_bit(d, addr, bit, 1);\r\n}\r\nstatic int af9015_clear_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)\r\n{\r\nreturn af9015_do_reg_bit(d, addr, bit, 0);\r\n}\r\nstatic int af9015_init_endpoint(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nu16 frame_size;\r\nu8 packet_size;\r\ndeb_info("%s: USB speed:%d\n", __func__, d->udev->speed);\r\n#define TS_PACKET_SIZE 188\r\n#define TS_USB20_PACKET_COUNT 87\r\n#define TS_USB20_FRAME_SIZE (TS_PACKET_SIZE*TS_USB20_PACKET_COUNT)\r\n#define TS_USB11_PACKET_COUNT 5\r\n#define TS_USB11_FRAME_SIZE (TS_PACKET_SIZE*TS_USB11_PACKET_COUNT)\r\n#define TS_USB20_MAX_PACKET_SIZE 512\r\n#define TS_USB11_MAX_PACKET_SIZE 64\r\nif (d->udev->speed == USB_SPEED_FULL) {\r\nframe_size = TS_USB11_FRAME_SIZE/4;\r\npacket_size = TS_USB11_MAX_PACKET_SIZE/4;\r\n} else {\r\nframe_size = TS_USB20_FRAME_SIZE/4;\r\npacket_size = TS_USB20_MAX_PACKET_SIZE/4;\r\n}\r\nret = af9015_set_reg_bit(d, 0xd507, 2);\r\nif (ret)\r\ngoto error;\r\nret = af9015_set_reg_bit(d, 0xd50b, 1);\r\nif (ret)\r\ngoto error;\r\nret = af9015_clear_reg_bit(d, 0xdd11, 5);\r\nif (ret)\r\ngoto error;\r\nret = af9015_clear_reg_bit(d, 0xdd11, 6);\r\nif (ret)\r\ngoto error;\r\nret = af9015_set_reg_bit(d, 0xdd11, 5);\r\nif (ret)\r\ngoto error;\r\nif (af9015_config.dual_mode) {\r\nret = af9015_set_reg_bit(d, 0xdd11, 6);\r\nif (ret)\r\ngoto error;\r\n}\r\nret = af9015_clear_reg_bit(d, 0xdd13, 5);\r\nif (ret)\r\ngoto error;\r\nif (af9015_config.dual_mode) {\r\nret = af9015_clear_reg_bit(d, 0xdd13, 6);\r\nif (ret)\r\ngoto error;\r\n}\r\nret = af9015_write_reg(d, 0xdd88, frame_size & 0xff);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd89, frame_size >> 8);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd8a, frame_size & 0xff);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd8b, frame_size >> 8);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd0c, packet_size);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(d, 0xdd0d, packet_size);\r\nif (ret)\r\ngoto error;\r\nret = af9015_clear_reg_bit(d, 0xd507, 2);\r\nif (ret)\r\ngoto error;\r\nif (af9015_config.dual_mode) {\r\nret = af9015_clear_reg_bit(d, 0xd50b, 1);\r\nif (ret)\r\ngoto error;\r\n}\r\nif (af9015_config.dual_mode)\r\nret = af9015_set_reg_bit(d, 0xd50b, 0);\r\nelse\r\nret = af9015_clear_reg_bit(d, 0xd50b, 0);\r\nerror:\r\nif (ret)\r\nerr("endpoint init failed:%d", ret);\r\nreturn ret;\r\n}\r\nstatic int af9015_copy_firmware(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nu8 fw_params[4];\r\nu8 val, i;\r\nstruct req_t req = {COPY_FIRMWARE, 0, 0x5100, 0, 0, sizeof(fw_params),\r\nfw_params };\r\ndeb_info("%s:\n", __func__);\r\nfw_params[0] = af9015_config.firmware_size >> 8;\r\nfw_params[1] = af9015_config.firmware_size & 0xff;\r\nfw_params[2] = af9015_config.firmware_checksum >> 8;\r\nfw_params[3] = af9015_config.firmware_checksum & 0xff;\r\nmsleep(100);\r\nret = af9015_read_reg_i2c(d,\r\naf9015_af9013_config[1].i2c_addr, 0x98be, &val);\r\nif (ret)\r\ngoto error;\r\nelse\r\ndeb_info("%s: firmware status:%02x\n", __func__, val);\r\nif (val == 0x0c)\r\ngoto exit;\r\nret = af9015_write_reg(d, 0xd416, 0x04);\r\nif (ret)\r\ngoto error;\r\nmsleep(50);\r\nret = af9015_ctrl_msg(d, &req);\r\nif (ret)\r\nerr("firmware copy cmd failed:%d", ret);\r\ndeb_info("%s: firmware copy done\n", __func__);\r\nret = af9015_write_reg(d, 0xd416, 0x14);\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg_i2c(d, af9015_af9013_config[1].i2c_addr,\r\n0xe205, 1);\r\ndeb_info("%s: firmware boot cmd status:%d\n", __func__, ret);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < 15; i++) {\r\nmsleep(100);\r\nret = af9015_read_reg_i2c(d,\r\naf9015_af9013_config[1].i2c_addr, 0x98be, &val);\r\ndeb_info("%s: firmware status cmd status:%d fw status:%02x\n",\r\n__func__, ret, val);\r\nif (ret)\r\ngoto error;\r\nif (val == 0x0c || val == 0x04)\r\nbreak;\r\n}\r\nif (val == 0x04) {\r\nerr("firmware did not run");\r\nret = -1;\r\n} else if (val != 0x0c) {\r\nerr("firmware boot timeout");\r\nret = -1;\r\n}\r\nerror:\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int af9015_eeprom_hash(struct usb_device *udev)\r\n{\r\nstatic const unsigned int eeprom_size = 256;\r\nunsigned int reg;\r\nint ret;\r\nu8 val, *eeprom;\r\nstruct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};\r\neeprom = kmalloc(eeprom_size, GFP_KERNEL);\r\nif (eeprom == NULL)\r\nreturn -ENOMEM;\r\nfor (reg = 0; reg < eeprom_size; reg++) {\r\nreq.addr = reg;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto free;\r\neeprom[reg] = val;\r\n}\r\nif (dvb_usb_af9015_debug & 0x01)\r\nprint_hex_dump_bytes("", DUMP_PREFIX_OFFSET, eeprom,\r\neeprom_size);\r\nBUG_ON(eeprom_size % 4);\r\naf9015_config.eeprom_sum = 0;\r\nfor (reg = 0; reg < eeprom_size / sizeof(u32); reg++) {\r\naf9015_config.eeprom_sum *= GOLDEN_RATIO_PRIME_32;\r\naf9015_config.eeprom_sum += le32_to_cpu(((u32 *)eeprom)[reg]);\r\n}\r\ndeb_info("%s: eeprom sum=%.8x\n", __func__, af9015_config.eeprom_sum);\r\nret = 0;\r\nfree:\r\nkfree(eeprom);\r\nreturn ret;\r\n}\r\nstatic int af9015_init(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\ndeb_info("%s:\n", __func__);\r\nret = af9015_write_reg(d, 0x98e9, 0xff);\r\nif (ret)\r\ngoto error;\r\nret = af9015_init_endpoint(d);\r\nif (ret)\r\ngoto error;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9015_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nint ret;\r\ndeb_info("%s: onoff:%d\n", __func__, onoff);\r\nif (onoff)\r\nret = af9015_set_reg_bit(adap->dev, 0xd503, 0);\r\nelse\r\nret = af9015_clear_reg_bit(adap->dev, 0xd503, 0);\r\nreturn ret;\r\n}\r\nstatic int af9015_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\r\nint onoff)\r\n{\r\nint ret;\r\nu8 idx;\r\ndeb_info("%s: set pid filter, index %d, pid %x, onoff %d\n",\r\n__func__, index, pid, onoff);\r\nret = af9015_write_reg(adap->dev, 0xd505, (pid & 0xff));\r\nif (ret)\r\ngoto error;\r\nret = af9015_write_reg(adap->dev, 0xd506, (pid >> 8));\r\nif (ret)\r\ngoto error;\r\nidx = ((index & 0x1f) | (1 << 5));\r\nret = af9015_write_reg(adap->dev, 0xd504, idx);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int af9015_download_firmware(struct usb_device *udev,\r\nconst struct firmware *fw)\r\n{\r\nint i, len, remaining, ret;\r\nstruct req_t req = {DOWNLOAD_FIRMWARE, 0, 0, 0, 0, 0, NULL};\r\nu16 checksum = 0;\r\ndeb_info("%s:\n", __func__);\r\nfor (i = 0; i < fw->size; i++)\r\nchecksum += fw->data[i];\r\naf9015_config.firmware_size = fw->size;\r\naf9015_config.firmware_checksum = checksum;\r\n#define FW_ADDR 0x5100\r\n#define LEN_MAX 55\r\nfor (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {\r\nlen = remaining;\r\nif (len > LEN_MAX)\r\nlen = LEN_MAX;\r\nreq.data_len = len;\r\nreq.data = (u8 *) &fw->data[fw->size - remaining];\r\nreq.addr = FW_ADDR + fw->size - remaining;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret) {\r\nerr("firmware download failed:%d", ret);\r\ngoto error;\r\n}\r\n}\r\nreq.cmd = BOOT;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret) {\r\nerr("firmware boot failed:%d", ret);\r\ngoto error;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic char *af9015_rc_setup_match(unsigned int id,\r\nconst struct af9015_rc_setup *table)\r\n{\r\nfor (; table->rc_codes; table++)\r\nif (table->id == id)\r\nreturn table->rc_codes;\r\nreturn NULL;\r\n}\r\nstatic void af9015_set_remote_config(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props)\r\n{\r\nu16 vid = le16_to_cpu(udev->descriptor.idVendor);\r\nu16 pid = le16_to_cpu(udev->descriptor.idProduct);\r\nprops->rc.core.rc_codes = af9015_rc_setup_match(\r\ndvb_usb_af9015_remote, af9015_rc_setup_modparam);\r\nif (!props->rc.core.rc_codes)\r\nprops->rc.core.rc_codes = af9015_rc_setup_match(\r\naf9015_config.eeprom_sum, af9015_rc_setup_hashes);\r\nif (!props->rc.core.rc_codes)\r\nprops->rc.core.rc_codes = af9015_rc_setup_match(\r\n(vid << 16) | pid, af9015_rc_setup_usbids);\r\nif (!props->rc.core.rc_codes && vid == USB_VID_AFATECH) {\r\nchar manufacturer[10];\r\nmemset(manufacturer, 0, sizeof(manufacturer));\r\nusb_string(udev, udev->descriptor.iManufacturer,\r\nmanufacturer, sizeof(manufacturer));\r\nif (!strcmp("MSI", manufacturer)) {\r\nprops->rc.core.rc_codes = af9015_rc_setup_match(\r\nAF9015_REMOTE_MSI_DIGIVOX_MINI_II_V3,\r\naf9015_rc_setup_modparam);\r\n}\r\n}\r\nif (!props->rc.core.rc_codes)\r\nprops->rc.core.rc_codes = RC_MAP_EMPTY;\r\nreturn;\r\n}\r\nstatic int af9015_read_config(struct usb_device *udev)\r\n{\r\nint ret;\r\nu8 val, i, offset = 0;\r\nstruct req_t req = {READ_I2C, AF9015_I2C_EEPROM, 0, 0, 1, 1, &val};\r\nreq.addr = AF9015_EEPROM_IR_MODE;\r\nfor (i = 0; i < 4; i++) {\r\nret = af9015_rw_udev(udev, &req);\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret)\r\ngoto error;\r\nret = af9015_eeprom_hash(udev);\r\nif (ret)\r\ngoto error;\r\ndeb_info("%s: IR mode=%d\n", __func__, val);\r\nfor (i = 0; i < af9015_properties_count; i++) {\r\nif (val == AF9015_IR_MODE_DISABLED)\r\naf9015_properties[i].rc.core.rc_codes = NULL;\r\nelse\r\naf9015_set_remote_config(udev, &af9015_properties[i]);\r\n}\r\nreq.addr = AF9015_EEPROM_TS_MODE;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\naf9015_config.dual_mode = val;\r\ndeb_info("%s: TS mode=%d\n", __func__, af9015_config.dual_mode);\r\nfor (i = 0; i < af9015_properties_count; i++) {\r\nif (udev->speed == USB_SPEED_FULL) {\r\naf9015_properties[i].adapter[0].fe[0].stream.u.bulk.buffersize\r\n= TS_USB11_FRAME_SIZE;\r\naf9015_config.dual_mode = 0;\r\n} else {\r\naf9015_properties[i].adapter[0].fe[0].stream.u.bulk.buffersize\r\n= TS_USB20_FRAME_SIZE;\r\n}\r\n}\r\nif (af9015_config.dual_mode) {\r\nreq.addr = AF9015_EEPROM_DEMOD2_I2C;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\naf9015_af9013_config[1].i2c_addr = val;\r\nfor (i = 0; i < af9015_properties_count; i++)\r\naf9015_properties[i].num_adapters = 2;\r\n} else {\r\nfor (i = 0; i < af9015_properties_count; i++)\r\naf9015_properties[i].num_adapters = 1;\r\n}\r\nfor (i = 0; i < af9015_properties[0].num_adapters; i++) {\r\nif (i == 1)\r\noffset = AF9015_EEPROM_OFFSET;\r\nreq.addr = AF9015_EEPROM_XTAL_TYPE1 + offset;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\nswitch (val) {\r\ncase 0:\r\naf9015_af9013_config[i].clock = 28800000;\r\nbreak;\r\ncase 1:\r\naf9015_af9013_config[i].clock = 20480000;\r\nbreak;\r\ncase 2:\r\naf9015_af9013_config[i].clock = 28000000;\r\nbreak;\r\ncase 3:\r\naf9015_af9013_config[i].clock = 25000000;\r\nbreak;\r\n};\r\ndeb_info("%s: [%d] xtal=%d set clock=%d\n", __func__, i,\r\nval, af9015_af9013_config[i].clock);\r\nreq.addr = AF9015_EEPROM_IF1H + offset;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\naf9015_af9013_config[i].if_frequency = val << 8;\r\nreq.addr = AF9015_EEPROM_IF1L + offset;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\naf9015_af9013_config[i].if_frequency += val;\r\naf9015_af9013_config[i].if_frequency *= 1000;\r\ndeb_info("%s: [%d] IF frequency=%d\n", __func__, i,\r\naf9015_af9013_config[0].if_frequency);\r\nreq.addr = AF9015_EEPROM_MT2060_IF1H + offset;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\naf9015_config.mt2060_if1[i] = val << 8;\r\nreq.addr = AF9015_EEPROM_MT2060_IF1L + offset;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\naf9015_config.mt2060_if1[i] += val;\r\ndeb_info("%s: [%d] MT2060 IF1=%d\n", __func__, i,\r\naf9015_config.mt2060_if1[i]);\r\nreq.addr = AF9015_EEPROM_TUNER_ID1 + offset;\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\ngoto error;\r\nswitch (val) {\r\ncase AF9013_TUNER_ENV77H11D5:\r\ncase AF9013_TUNER_MT2060:\r\ncase AF9013_TUNER_QT1010:\r\ncase AF9013_TUNER_UNKNOWN:\r\ncase AF9013_TUNER_MT2060_2:\r\ncase AF9013_TUNER_TDA18271:\r\ncase AF9013_TUNER_QT1010A:\r\ncase AF9013_TUNER_TDA18218:\r\naf9015_af9013_config[i].spec_inv = 1;\r\nbreak;\r\ncase AF9013_TUNER_MXL5003D:\r\ncase AF9013_TUNER_MXL5005D:\r\ncase AF9013_TUNER_MXL5005R:\r\ncase AF9013_TUNER_MXL5007T:\r\naf9015_af9013_config[i].spec_inv = 0;\r\nbreak;\r\ncase AF9013_TUNER_MC44S803:\r\naf9015_af9013_config[i].gpio[1] = AF9013_GPIO_LO;\r\naf9015_af9013_config[i].spec_inv = 1;\r\nbreak;\r\ndefault:\r\nwarn("tuner id=%d not supported, please report!", val);\r\nreturn -ENODEV;\r\n};\r\naf9015_af9013_config[i].tuner = val;\r\ndeb_info("%s: [%d] tuner id=%d\n", __func__, i, val);\r\n}\r\nerror:\r\nif (ret)\r\nerr("eeprom read failed=%d", ret);\r\nif (le16_to_cpu(udev->descriptor.idVendor) == USB_VID_AVERMEDIA &&\r\n((le16_to_cpu(udev->descriptor.idProduct) ==\r\nUSB_PID_AVERMEDIA_A850) ||\r\n(le16_to_cpu(udev->descriptor.idProduct) ==\r\nUSB_PID_AVERMEDIA_A850T))) {\r\ndeb_info("%s: AverMedia A850: overriding config\n", __func__);\r\naf9015_config.dual_mode = 0;\r\nfor (i = 0; i < af9015_properties_count; i++)\r\naf9015_properties[i].num_adapters = 1;\r\naf9015_af9013_config[0].if_frequency = 4570000;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9015_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\nint ret;\r\nu8 reply;\r\nstruct req_t req = {GET_CONFIG, 0, 0, 0, 0, 1, &reply};\r\nret = af9015_rw_udev(udev, &req);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("%s: reply:%02x\n", __func__, reply);\r\nif (reply == 0x02)\r\n*cold = 0;\r\nelse\r\n*cold = 1;\r\nreturn ret;\r\n}\r\nstatic int af9015_rc_query(struct dvb_usb_device *d)\r\n{\r\nstruct af9015_state *priv = d->priv;\r\nint ret;\r\nu8 buf[17];\r\nret = af9015_read_regs(d, 0x98d9, buf, sizeof(buf));\r\nif (ret)\r\ngoto error;\r\nif (buf[1] || buf[2] || buf[3])\r\nreturn ret;\r\nif ((priv->rc_repeat != buf[6] || buf[0]) &&\r\n!memcmp(&buf[12], priv->rc_last, 4)) {\r\ndeb_rc("%s: key repeated\n", __func__);\r\nrc_keydown(d->rc_dev, priv->rc_keycode, 0);\r\npriv->rc_repeat = buf[6];\r\nreturn ret;\r\n}\r\nif (buf[16] != 0xff && buf[0] != 0x01) {\r\ndeb_rc("%s: key pressed %02x %02x %02x %02x\n", __func__,\r\nbuf[12], buf[13], buf[14], buf[15]);\r\nret = af9015_write_reg(d, 0x98e9, 0xff);\r\nif (ret)\r\ngoto error;\r\nmemcpy(priv->rc_last, &buf[12], 4);\r\nif (buf[14] == (u8) ~buf[15]) {\r\nif (buf[12] == (u8) ~buf[13]) {\r\npriv->rc_keycode = buf[12] << 8 | buf[14];\r\n} else {\r\npriv->rc_keycode = buf[12] << 16 |\r\nbuf[13] << 8 | buf[14];\r\n}\r\n} else {\r\npriv->rc_keycode = buf[12] << 24 | buf[13] << 16 |\r\nbuf[14] << 8 | buf[15];\r\n}\r\nrc_keydown(d->rc_dev, priv->rc_keycode, 0);\r\n} else {\r\ndeb_rc("%s: no key press\n", __func__);\r\npriv->rc_last[2] = priv->rc_last[3];\r\n}\r\npriv->rc_repeat = buf[6];\r\nerror:\r\nif (ret)\r\nerr("%s: failed:%d", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_set_frontend(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct af9015_state *priv = adap->dev->priv;\r\nif (mutex_lock_interruptible(&adap->dev->usb_mutex))\r\nreturn -EAGAIN;\r\nret = priv->set_frontend[adap->id](fe);\r\nmutex_unlock(&adap->dev->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_read_status(struct dvb_frontend *fe,\r\nfe_status_t *status)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct af9015_state *priv = adap->dev->priv;\r\nif (mutex_lock_interruptible(&adap->dev->usb_mutex))\r\nreturn -EAGAIN;\r\nret = priv->read_status[adap->id](fe, status);\r\nmutex_unlock(&adap->dev->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_init(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct af9015_state *priv = adap->dev->priv;\r\nif (mutex_lock_interruptible(&adap->dev->usb_mutex))\r\nreturn -EAGAIN;\r\nret = priv->init[adap->id](fe);\r\nmutex_unlock(&adap->dev->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct af9015_state *priv = adap->dev->priv;\r\nif (mutex_lock_interruptible(&adap->dev->usb_mutex))\r\nreturn -EAGAIN;\r\nret = priv->sleep[adap->id](fe);\r\nmutex_unlock(&adap->dev->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_tuner_init(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct af9015_state *priv = adap->dev->priv;\r\nif (mutex_lock_interruptible(&adap->dev->usb_mutex))\r\nreturn -EAGAIN;\r\nret = priv->tuner_init[adap->id](fe);\r\nmutex_unlock(&adap->dev->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_tuner_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct af9015_state *priv = adap->dev->priv;\r\nif (mutex_lock_interruptible(&adap->dev->usb_mutex))\r\nreturn -EAGAIN;\r\nret = priv->tuner_sleep[adap->id](fe);\r\nmutex_unlock(&adap->dev->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int af9015_af9013_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct af9015_state *state = adap->dev->priv;\r\nif (adap->id == 1) {\r\nif (af9015_config.dual_mode) {\r\nret = af9015_copy_firmware(adap->dev);\r\nif (ret) {\r\nerr("firmware copy to 2nd frontend " \\r\n"failed, will disable it");\r\naf9015_config.dual_mode = 0;\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nreturn -ENODEV;\r\n}\r\n}\r\nadap->fe_adap[0].fe = dvb_attach(af9013_attach,\r\n&af9015_af9013_config[adap->id], &adap->dev->i2c_adap);\r\nif (adap->fe_adap[0].fe) {\r\nstate->set_frontend[adap->id] =\r\nadap->fe_adap[0].fe->ops.set_frontend;\r\nadap->fe_adap[0].fe->ops.set_frontend =\r\naf9015_af9013_set_frontend;\r\nstate->read_status[adap->id] =\r\nadap->fe_adap[0].fe->ops.read_status;\r\nadap->fe_adap[0].fe->ops.read_status =\r\naf9015_af9013_read_status;\r\nstate->init[adap->id] = adap->fe_adap[0].fe->ops.init;\r\nadap->fe_adap[0].fe->ops.init = af9015_af9013_init;\r\nstate->sleep[adap->id] = adap->fe_adap[0].fe->ops.sleep;\r\nadap->fe_adap[0].fe->ops.sleep = af9015_af9013_sleep;\r\n}\r\nreturn adap->fe_adap[0].fe == NULL ? -ENODEV : 0;\r\n}\r\nstatic int af9015_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct af9015_state *state = adap->dev->priv;\r\ndeb_info("%s:\n", __func__);\r\nswitch (af9015_af9013_config[adap->id].tuner) {\r\ncase AF9013_TUNER_MT2060:\r\ncase AF9013_TUNER_MT2060_2:\r\nret = dvb_attach(mt2060_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap, &af9015_mt2060_config,\r\naf9015_config.mt2060_if1[adap->id])\r\n== NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_QT1010:\r\ncase AF9013_TUNER_QT1010A:\r\nret = dvb_attach(qt1010_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap,\r\n&af9015_qt1010_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_TDA18271:\r\nret = dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0xc0,\r\n&adap->dev->i2c_adap,\r\n&af9015_tda18271_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_TDA18218:\r\nret = dvb_attach(tda18218_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap,\r\n&af9015_tda18218_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MXL5003D:\r\nret = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap,\r\n&af9015_mxl5003_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MXL5005D:\r\ncase AF9013_TUNER_MXL5005R:\r\nret = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap,\r\n&af9015_mxl5005_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_ENV77H11D5:\r\nret = dvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0xc0,\r\n&adap->dev->i2c_adap,\r\nDVB_PLL_TDA665X) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MC44S803:\r\nret = dvb_attach(mc44s803_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap,\r\n&af9015_mc44s803_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_MXL5007T:\r\nret = dvb_attach(mxl5007t_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap,\r\n0xc0, &af9015_mxl5007t_config) == NULL ? -ENODEV : 0;\r\nbreak;\r\ncase AF9013_TUNER_UNKNOWN:\r\ndefault:\r\nret = -ENODEV;\r\nerr("Unknown tuner id:%d",\r\naf9015_af9013_config[adap->id].tuner);\r\n}\r\nif (adap->fe_adap[0].fe->ops.tuner_ops.init) {\r\nstate->tuner_init[adap->id] =\r\nadap->fe_adap[0].fe->ops.tuner_ops.init;\r\nadap->fe_adap[0].fe->ops.tuner_ops.init = af9015_tuner_init;\r\n}\r\nif (adap->fe_adap[0].fe->ops.tuner_ops.sleep) {\r\nstate->tuner_sleep[adap->id] =\r\nadap->fe_adap[0].fe->ops.tuner_ops.sleep;\r\nadap->fe_adap[0].fe->ops.tuner_ops.sleep = af9015_tuner_sleep;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9015_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret = 0;\r\nstruct dvb_usb_device *d = NULL;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nu8 i;\r\ndeb_info("%s: interface:%d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber == 0) {\r\nret = af9015_read_config(udev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < af9015_properties_count; i++) {\r\nret = dvb_usb_device_init(intf, &af9015_properties[i],\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (!ret)\r\nbreak;\r\nif (ret != -ENODEV)\r\nreturn ret;\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (d)\r\nret = af9015_init(d);\r\n}\r\nreturn ret;\r\n}
