static void print_help(struct menu *menu)\r\n{\r\nstruct gstr help = str_new();\r\nmenu_get_ext_help(menu, &help);\r\nprintf("\n%s\n", str_get(&help));\r\nstr_free(&help);\r\n}\r\nstatic void strip(char *str)\r\n{\r\nchar *p = str;\r\nint l;\r\nwhile ((isspace(*p)))\r\np++;\r\nl = strlen(p);\r\nif (p != str)\r\nmemmove(str, p, l + 1);\r\nif (!l)\r\nreturn;\r\np = str + l - 1;\r\nwhile ((isspace(*p)))\r\n*p-- = 0;\r\n}\r\nstatic void check_stdin(void)\r\n{\r\nif (!valid_stdin) {\r\nprintf(_("aborted!\n\n"));\r\nprintf(_("Console input/output is redirected. "));\r\nprintf(_("Run 'make oldconfig' to update configuration.\n\n"));\r\nexit(1);\r\n}\r\n}\r\nstatic int conf_askvalue(struct symbol *sym, const char *def)\r\n{\r\nenum symbol_type type = sym_get_type(sym);\r\nif (!sym_has_value(sym))\r\nprintf(_("(NEW) "));\r\nline[0] = '\n';\r\nline[1] = 0;\r\nif (!sym_is_changable(sym)) {\r\nprintf("%s\n", def);\r\nline[0] = '\n';\r\nline[1] = 0;\r\nreturn 0;\r\n}\r\nswitch (input_mode) {\r\ncase oldconfig:\r\ncase silentoldconfig:\r\nif (sym_has_value(sym)) {\r\nprintf("%s\n", def);\r\nreturn 0;\r\n}\r\ncheck_stdin();\r\ncase oldaskconfig:\r\nfflush(stdout);\r\nxfgets(line, 128, stdin);\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (type) {\r\ncase S_INT:\r\ncase S_HEX:\r\ncase S_STRING:\r\nprintf("%s\n", def);\r\nreturn 1;\r\ndefault:\r\n;\r\n}\r\nprintf("%s", line);\r\nreturn 1;\r\n}\r\nstatic int conf_string(struct menu *menu)\r\n{\r\nstruct symbol *sym = menu->sym;\r\nconst char *def;\r\nwhile (1) {\r\nprintf("%*s%s ", indent - 1, "", _(menu->prompt->text));\r\nprintf("(%s) ", sym->name);\r\ndef = sym_get_string_value(sym);\r\nif (sym_get_string_value(sym))\r\nprintf("[%s] ", def);\r\nif (!conf_askvalue(sym, def))\r\nreturn 0;\r\nswitch (line[0]) {\r\ncase '\n':\r\nbreak;\r\ncase '?':\r\nif (line[1] == '\n') {\r\nprint_help(menu);\r\ndef = NULL;\r\nbreak;\r\n}\r\ndefault:\r\nline[strlen(line)-1] = 0;\r\ndef = line;\r\n}\r\nif (def && sym_set_string_value(sym, def))\r\nreturn 0;\r\n}\r\n}\r\nstatic int conf_sym(struct menu *menu)\r\n{\r\nstruct symbol *sym = menu->sym;\r\ntristate oldval, newval;\r\nwhile (1) {\r\nprintf("%*s%s ", indent - 1, "", _(menu->prompt->text));\r\nif (sym->name)\r\nprintf("(%s) ", sym->name);\r\nputchar('[');\r\noldval = sym_get_tristate_value(sym);\r\nswitch (oldval) {\r\ncase no:\r\nputchar('N');\r\nbreak;\r\ncase mod:\r\nputchar('M');\r\nbreak;\r\ncase yes:\r\nputchar('Y');\r\nbreak;\r\n}\r\nif (oldval != no && sym_tristate_within_range(sym, no))\r\nprintf("/n");\r\nif (oldval != mod && sym_tristate_within_range(sym, mod))\r\nprintf("/m");\r\nif (oldval != yes && sym_tristate_within_range(sym, yes))\r\nprintf("/y");\r\nif (menu_has_help(menu))\r\nprintf("/?");\r\nprintf("] ");\r\nif (!conf_askvalue(sym, sym_get_string_value(sym)))\r\nreturn 0;\r\nstrip(line);\r\nswitch (line[0]) {\r\ncase 'n':\r\ncase 'N':\r\nnewval = no;\r\nif (!line[1] || !strcmp(&line[1], "o"))\r\nbreak;\r\ncontinue;\r\ncase 'm':\r\ncase 'M':\r\nnewval = mod;\r\nif (!line[1])\r\nbreak;\r\ncontinue;\r\ncase 'y':\r\ncase 'Y':\r\nnewval = yes;\r\nif (!line[1] || !strcmp(&line[1], "es"))\r\nbreak;\r\ncontinue;\r\ncase 0:\r\nnewval = oldval;\r\nbreak;\r\ncase '?':\r\ngoto help;\r\ndefault:\r\ncontinue;\r\n}\r\nif (sym_set_tristate_value(sym, newval))\r\nreturn 0;\r\nhelp:\r\nprint_help(menu);\r\n}\r\n}\r\nstatic int conf_choice(struct menu *menu)\r\n{\r\nstruct symbol *sym, *def_sym;\r\nstruct menu *child;\r\nbool is_new;\r\nsym = menu->sym;\r\nis_new = !sym_has_value(sym);\r\nif (sym_is_changable(sym)) {\r\nconf_sym(menu);\r\nsym_calc_value(sym);\r\nswitch (sym_get_tristate_value(sym)) {\r\ncase no:\r\nreturn 1;\r\ncase mod:\r\nreturn 0;\r\ncase yes:\r\nbreak;\r\n}\r\n} else {\r\nswitch (sym_get_tristate_value(sym)) {\r\ncase no:\r\nreturn 1;\r\ncase mod:\r\nprintf("%*s%s\n", indent - 1, "", _(menu_get_prompt(menu)));\r\nreturn 0;\r\ncase yes:\r\nbreak;\r\n}\r\n}\r\nwhile (1) {\r\nint cnt, def;\r\nprintf("%*s%s\n", indent - 1, "", _(menu_get_prompt(menu)));\r\ndef_sym = sym_get_choice_value(sym);\r\ncnt = def = 0;\r\nline[0] = 0;\r\nfor (child = menu->list; child; child = child->next) {\r\nif (!menu_is_visible(child))\r\ncontinue;\r\nif (!child->sym) {\r\nprintf("%*c %s\n", indent, '*', _(menu_get_prompt(child)));\r\ncontinue;\r\n}\r\ncnt++;\r\nif (child->sym == def_sym) {\r\ndef = cnt;\r\nprintf("%*c", indent, '>');\r\n} else\r\nprintf("%*c", indent, ' ');\r\nprintf(" %d. %s", cnt, _(menu_get_prompt(child)));\r\nif (child->sym->name)\r\nprintf(" (%s)", child->sym->name);\r\nif (!sym_has_value(child->sym))\r\nprintf(_(" (NEW)"));\r\nprintf("\n");\r\n}\r\nprintf(_("%*schoice"), indent - 1, "");\r\nif (cnt == 1) {\r\nprintf("[1]: 1\n");\r\ngoto conf_childs;\r\n}\r\nprintf("[1-%d", cnt);\r\nif (menu_has_help(menu))\r\nprintf("?");\r\nprintf("]: ");\r\nswitch (input_mode) {\r\ncase oldconfig:\r\ncase silentoldconfig:\r\nif (!is_new) {\r\ncnt = def;\r\nprintf("%d\n", cnt);\r\nbreak;\r\n}\r\ncheck_stdin();\r\ncase oldaskconfig:\r\nfflush(stdout);\r\nxfgets(line, 128, stdin);\r\nstrip(line);\r\nif (line[0] == '?') {\r\nprint_help(menu);\r\ncontinue;\r\n}\r\nif (!line[0])\r\ncnt = def;\r\nelse if (isdigit(line[0]))\r\ncnt = atoi(line);\r\nelse\r\ncontinue;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nconf_childs:\r\nfor (child = menu->list; child; child = child->next) {\r\nif (!child->sym || !menu_is_visible(child))\r\ncontinue;\r\nif (!--cnt)\r\nbreak;\r\n}\r\nif (!child)\r\ncontinue;\r\nif (line[0] && line[strlen(line) - 1] == '?') {\r\nprint_help(child);\r\ncontinue;\r\n}\r\nsym_set_choice_value(sym, child->sym);\r\nfor (child = child->list; child; child = child->next) {\r\nindent += 2;\r\nconf(child);\r\nindent -= 2;\r\n}\r\nreturn 1;\r\n}\r\n}\r\nstatic void conf(struct menu *menu)\r\n{\r\nstruct symbol *sym;\r\nstruct property *prop;\r\nstruct menu *child;\r\nif (!menu_is_visible(menu))\r\nreturn;\r\nsym = menu->sym;\r\nprop = menu->prompt;\r\nif (prop) {\r\nconst char *prompt;\r\nswitch (prop->type) {\r\ncase P_MENU:\r\nif ((input_mode == silentoldconfig ||\r\ninput_mode == listnewconfig ||\r\ninput_mode == oldnoconfig) &&\r\nrootEntry != menu) {\r\ncheck_conf(menu);\r\nreturn;\r\n}\r\ncase P_COMMENT:\r\nprompt = menu_get_prompt(menu);\r\nif (prompt)\r\nprintf("%*c\n%*c %s\n%*c\n",\r\nindent, '*',\r\nindent, '*', _(prompt),\r\nindent, '*');\r\ndefault:\r\n;\r\n}\r\n}\r\nif (!sym)\r\ngoto conf_childs;\r\nif (sym_is_choice(sym)) {\r\nconf_choice(menu);\r\nif (sym->curr.tri != mod)\r\nreturn;\r\ngoto conf_childs;\r\n}\r\nswitch (sym->type) {\r\ncase S_INT:\r\ncase S_HEX:\r\ncase S_STRING:\r\nconf_string(menu);\r\nbreak;\r\ndefault:\r\nconf_sym(menu);\r\nbreak;\r\n}\r\nconf_childs:\r\nif (sym)\r\nindent += 2;\r\nfor (child = menu->list; child; child = child->next)\r\nconf(child);\r\nif (sym)\r\nindent -= 2;\r\n}\r\nstatic void check_conf(struct menu *menu)\r\n{\r\nstruct symbol *sym;\r\nstruct menu *child;\r\nif (!menu_is_visible(menu))\r\nreturn;\r\nsym = menu->sym;\r\nif (sym && !sym_has_value(sym)) {\r\nif (sym_is_changable(sym) ||\r\n(sym_is_choice(sym) && sym_get_tristate_value(sym) == yes)) {\r\nif (input_mode == listnewconfig) {\r\nif (sym->name && !sym_is_choice_value(sym)) {\r\nprintf("%s%s\n", CONFIG_, sym->name);\r\n}\r\n} else if (input_mode != oldnoconfig) {\r\nif (!conf_cnt++)\r\nprintf(_("*\n* Restart config...\n*\n"));\r\nrootEntry = menu_get_parent_menu(menu);\r\nconf(rootEntry);\r\n}\r\n}\r\n}\r\nfor (child = menu->list; child; child = child->next)\r\ncheck_conf(child);\r\n}\r\nstatic void conf_usage(const char *progname)\r\n{\r\nprintf("Usage: %s [option] <kconfig-file>\n", progname);\r\nprintf("[option] is _one_ of the following:\n");\r\nprintf(" --listnewconfig List new options\n");\r\nprintf(" --oldaskconfig Start a new configuration using a line-oriented program\n");\r\nprintf(" --oldconfig Update a configuration using a provided .config as base\n");\r\nprintf(" --silentoldconfig Same as oldconfig, but quietly, additionally update deps\n");\r\nprintf(" --oldnoconfig Same as silentoldconfig but set new symbols to no\n");\r\nprintf(" --defconfig <file> New config with default defined in <file>\n");\r\nprintf(" --savedefconfig <file> Save the minimal current configuration to <file>\n");\r\nprintf(" --allnoconfig New config where all options are answered with no\n");\r\nprintf(" --allyesconfig New config where all options are answered with yes\n");\r\nprintf(" --allmodconfig New config where all options are answered with mod\n");\r\nprintf(" --alldefconfig New config with all symbols set to default\n");\r\nprintf(" --randconfig New config with random answer to all options\n");\r\n}\r\nint main(int ac, char **av)\r\n{\r\nconst char *progname = av[0];\r\nint opt;\r\nconst char *name, *defconfig_file = NULL ;\r\nstruct stat tmpstat;\r\nsetlocale(LC_ALL, "");\r\nbindtextdomain(PACKAGE, LOCALEDIR);\r\ntextdomain(PACKAGE);\r\nwhile ((opt = getopt_long(ac, av, "", long_opts, NULL)) != -1) {\r\ninput_mode = (enum input_mode)opt;\r\nswitch (opt) {\r\ncase silentoldconfig:\r\nsync_kconfig = 1;\r\nbreak;\r\ncase defconfig:\r\ncase savedefconfig:\r\ndefconfig_file = optarg;\r\nbreak;\r\ncase randconfig:\r\n{\r\nstruct timeval now;\r\nunsigned int seed;\r\ngettimeofday(&now, NULL);\r\nseed = (unsigned int)((now.tv_sec + 1) * (now.tv_usec + 1));\r\nsrand(seed);\r\nbreak;\r\n}\r\ncase oldaskconfig:\r\ncase oldconfig:\r\ncase allnoconfig:\r\ncase allyesconfig:\r\ncase allmodconfig:\r\ncase alldefconfig:\r\ncase listnewconfig:\r\ncase oldnoconfig:\r\nbreak;\r\ncase '?':\r\nconf_usage(progname);\r\nexit(1);\r\nbreak;\r\n}\r\n}\r\nif (ac == optind) {\r\nprintf(_("%s: Kconfig file missing\n"), av[0]);\r\nconf_usage(progname);\r\nexit(1);\r\n}\r\nname = av[optind];\r\nconf_parse(name);\r\nif (sync_kconfig) {\r\nname = conf_get_configname();\r\nif (stat(name, &tmpstat)) {\r\nfprintf(stderr, _("***\n"\r\n"*** Configuration file \"%s\" not found!\n"\r\n"***\n"\r\n"*** Please run some configurator (e.g. \"make oldconfig\" or\n"\r\n"*** \"make menuconfig\" or \"make xconfig\").\n"\r\n"***\n"), name);\r\nexit(1);\r\n}\r\n}\r\nswitch (input_mode) {\r\ncase defconfig:\r\nif (!defconfig_file)\r\ndefconfig_file = conf_get_default_confname();\r\nif (conf_read(defconfig_file)) {\r\nprintf(_("***\n"\r\n"*** Can't find default configuration \"%s\"!\n"\r\n"***\n"), defconfig_file);\r\nexit(1);\r\n}\r\nbreak;\r\ncase savedefconfig:\r\ncase silentoldconfig:\r\ncase oldaskconfig:\r\ncase oldconfig:\r\ncase listnewconfig:\r\ncase oldnoconfig:\r\nconf_read(NULL);\r\nbreak;\r\ncase allnoconfig:\r\ncase allyesconfig:\r\ncase allmodconfig:\r\ncase alldefconfig:\r\ncase randconfig:\r\nname = getenv("KCONFIG_ALLCONFIG");\r\nif (!name)\r\nbreak;\r\nif ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {\r\nif (conf_read_simple(name, S_DEF_USER)) {\r\nfprintf(stderr,\r\n_("*** Can't read seed configuration \"%s\"!\n"),\r\nname);\r\nexit(1);\r\n}\r\nbreak;\r\n}\r\nswitch (input_mode) {\r\ncase allnoconfig: name = "allno.config"; break;\r\ncase allyesconfig: name = "allyes.config"; break;\r\ncase allmodconfig: name = "allmod.config"; break;\r\ncase alldefconfig: name = "alldef.config"; break;\r\ncase randconfig: name = "allrandom.config"; break;\r\ndefault: break;\r\n}\r\nif (conf_read_simple(name, S_DEF_USER) &&\r\nconf_read_simple("all.config", S_DEF_USER)) {\r\nfprintf(stderr,\r\n_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),\r\nname);\r\nexit(1);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (sync_kconfig) {\r\nif (conf_get_changed()) {\r\nname = getenv("KCONFIG_NOSILENTUPDATE");\r\nif (name && *name) {\r\nfprintf(stderr,\r\n_("\n*** The configuration requires explicit update.\n\n"));\r\nreturn 1;\r\n}\r\n}\r\nvalid_stdin = isatty(0) && isatty(1) && isatty(2);\r\n}\r\nswitch (input_mode) {\r\ncase allnoconfig:\r\nconf_set_all_new_symbols(def_no);\r\nbreak;\r\ncase allyesconfig:\r\nconf_set_all_new_symbols(def_yes);\r\nbreak;\r\ncase allmodconfig:\r\nconf_set_all_new_symbols(def_mod);\r\nbreak;\r\ncase alldefconfig:\r\nconf_set_all_new_symbols(def_default);\r\nbreak;\r\ncase randconfig:\r\nconf_set_all_new_symbols(def_random);\r\nbreak;\r\ncase defconfig:\r\nconf_set_all_new_symbols(def_default);\r\nbreak;\r\ncase savedefconfig:\r\nbreak;\r\ncase oldaskconfig:\r\nrootEntry = &rootmenu;\r\nconf(&rootmenu);\r\ninput_mode = silentoldconfig;\r\ncase oldconfig:\r\ncase listnewconfig:\r\ncase oldnoconfig:\r\ncase silentoldconfig:\r\ndo {\r\nconf_cnt = 0;\r\ncheck_conf(&rootmenu);\r\n} while (conf_cnt &&\r\n(input_mode != listnewconfig &&\r\ninput_mode != oldnoconfig));\r\nbreak;\r\n}\r\nif (sync_kconfig) {\r\nif (conf_get_changed() && conf_write(NULL)) {\r\nfprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));\r\nexit(1);\r\n}\r\nif (conf_write_autoconf()) {\r\nfprintf(stderr, _("\n*** Error during update of the configuration.\n\n"));\r\nreturn 1;\r\n}\r\n} else if (input_mode == savedefconfig) {\r\nif (conf_write_defconfig(defconfig_file)) {\r\nfprintf(stderr, _("n*** Error while saving defconfig to: %s\n\n"),\r\ndefconfig_file);\r\nreturn 1;\r\n}\r\n} else if (input_mode != listnewconfig) {\r\nif (conf_write(NULL)) {\r\nfprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));\r\nexit(1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid xfgets(char *str, int size, FILE *in)\r\n{\r\nif (fgets(str, size, in) == NULL)\r\nfprintf(stderr, "\nError in reading or end of file.\n");\r\n}
