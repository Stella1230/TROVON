static inline u16 nfc_read(struct mtd_info *mtd, uint reg)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nreturn in_be16(prv->regs + reg);\r\n}\r\nstatic inline void nfc_write(struct mtd_info *mtd, uint reg, u16 val)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nout_be16(prv->regs + reg, val);\r\n}\r\nstatic inline void nfc_set(struct mtd_info *mtd, uint reg, u16 bits)\r\n{\r\nnfc_write(mtd, reg, nfc_read(mtd, reg) | bits);\r\n}\r\nstatic inline void nfc_clear(struct mtd_info *mtd, uint reg, u16 bits)\r\n{\r\nnfc_write(mtd, reg, nfc_read(mtd, reg) & ~bits);\r\n}\r\nstatic inline void mpc5121_nfc_send_addr(struct mtd_info *mtd, u16 addr)\r\n{\r\nnfc_write(mtd, NFC_FLASH_ADDR, addr);\r\nnfc_write(mtd, NFC_CONFIG2, NFC_ADDRESS);\r\nmpc5121_nfc_done(mtd);\r\n}\r\nstatic inline void mpc5121_nfc_send_cmd(struct mtd_info *mtd, u16 cmd)\r\n{\r\nnfc_write(mtd, NFC_FLASH_CMD, cmd);\r\nnfc_write(mtd, NFC_CONFIG2, NFC_COMMAND);\r\nmpc5121_nfc_done(mtd);\r\n}\r\nstatic inline void mpc5121_nfc_send_prog_page(struct mtd_info *mtd)\r\n{\r\nnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\r\nnfc_write(mtd, NFC_CONFIG2, NFC_INPUT);\r\nmpc5121_nfc_done(mtd);\r\n}\r\nstatic inline void mpc5121_nfc_send_read_page(struct mtd_info *mtd)\r\n{\r\nnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\r\nnfc_write(mtd, NFC_CONFIG2, NFC_OUTPUT);\r\nmpc5121_nfc_done(mtd);\r\n}\r\nstatic inline void mpc5121_nfc_send_read_id(struct mtd_info *mtd)\r\n{\r\nnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\r\nnfc_write(mtd, NFC_CONFIG2, NFC_ID);\r\nmpc5121_nfc_done(mtd);\r\n}\r\nstatic inline void mpc5121_nfc_send_read_status(struct mtd_info *mtd)\r\n{\r\nnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\r\nnfc_write(mtd, NFC_CONFIG2, NFC_STATUS);\r\nmpc5121_nfc_done(mtd);\r\n}\r\nstatic irqreturn_t mpc5121_nfc_irq(int irq, void *data)\r\n{\r\nstruct mtd_info *mtd = data;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nnfc_set(mtd, NFC_CONFIG1, NFC_INT_MASK);\r\nwake_up(&prv->irq_waitq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mpc5121_nfc_done(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nint rv;\r\nif ((nfc_read(mtd, NFC_CONFIG2) & NFC_INT) == 0) {\r\nnfc_clear(mtd, NFC_CONFIG1, NFC_INT_MASK);\r\nrv = wait_event_timeout(prv->irq_waitq,\r\n(nfc_read(mtd, NFC_CONFIG2) & NFC_INT), NFC_TIMEOUT);\r\nif (!rv)\r\ndev_warn(prv->dev,\r\n"Timeout while waiting for interrupt.\n");\r\n}\r\nnfc_clear(mtd, NFC_CONFIG2, NFC_INT);\r\n}\r\nstatic void mpc5121_nfc_addr_cycle(struct mtd_info *mtd, int column, int page)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nu32 pagemask = chip->pagemask;\r\nif (column != -1) {\r\nmpc5121_nfc_send_addr(mtd, column);\r\nif (mtd->writesize > 512)\r\nmpc5121_nfc_send_addr(mtd, column >> 8);\r\n}\r\nif (page != -1) {\r\ndo {\r\nmpc5121_nfc_send_addr(mtd, page & 0xFF);\r\npage >>= 8;\r\npagemask >>= 8;\r\n} while (pagemask);\r\n}\r\n}\r\nstatic void mpc5121_nfc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nif (chip < 0) {\r\nnfc_clear(mtd, NFC_CONFIG1, NFC_CE);\r\nreturn;\r\n}\r\nnfc_clear(mtd, NFC_BUF_ADDR, NFC_ACTIVE_CS_MASK);\r\nnfc_set(mtd, NFC_BUF_ADDR, (chip << NFC_ACTIVE_CS_SHIFT) &\r\nNFC_ACTIVE_CS_MASK);\r\nnfc_set(mtd, NFC_CONFIG1, NFC_CE);\r\n}\r\nstatic int ads5121_chipselect_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nstruct device_node *dn;\r\ndn = of_find_compatible_node(NULL, NULL, "fsl,mpc5121ads-cpld");\r\nif (dn) {\r\nprv->csreg = of_iomap(dn, 0);\r\nof_node_put(dn);\r\nif (!prv->csreg)\r\nreturn -ENOMEM;\r\nprv->csreg += 9;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ads5121_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = nand->priv;\r\nu8 v;\r\nv = in_8(prv->csreg);\r\nv |= 0x0F;\r\nif (chip >= 0) {\r\nmpc5121_nfc_select_chip(mtd, 0);\r\nv &= ~(1 << chip);\r\n} else\r\nmpc5121_nfc_select_chip(mtd, -1);\r\nout_8(prv->csreg, v);\r\n}\r\nstatic int mpc5121_nfc_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn 1;\r\n}\r\nstatic void mpc5121_nfc_command(struct mtd_info *mtd, unsigned command,\r\nint column, int page)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nprv->column = (column >= 0) ? column : 0;\r\nprv->spareonly = 0;\r\nswitch (command) {\r\ncase NAND_CMD_PAGEPROG:\r\nmpc5121_nfc_send_prog_page(mtd);\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncolumn = 0;\r\nbreak;\r\ncase NAND_CMD_READ1:\r\nprv->column += 256;\r\ncommand = NAND_CMD_READ0;\r\ncolumn = 0;\r\nbreak;\r\ncase NAND_CMD_READOOB:\r\nprv->spareonly = 1;\r\ncommand = NAND_CMD_READ0;\r\ncolumn = 0;\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nmpc5121_nfc_command(mtd, NAND_CMD_READ0, column, page);\r\ncolumn = 0;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_READID:\r\ncase NAND_CMD_STATUS:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nmpc5121_nfc_send_cmd(mtd, command);\r\nmpc5121_nfc_addr_cycle(mtd, column, page);\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\nif (mtd->writesize > 512)\r\nmpc5121_nfc_send_cmd(mtd, NAND_CMD_READSTART);\r\nmpc5121_nfc_send_read_page(mtd);\r\nbreak;\r\ncase NAND_CMD_READID:\r\nmpc5121_nfc_send_read_id(mtd);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nmpc5121_nfc_send_read_status(mtd);\r\nif (chip->options & NAND_BUSWIDTH_16)\r\nprv->column = 1;\r\nelse\r\nprv->column = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void mpc5121_nfc_copy_spare(struct mtd_info *mtd, uint offset,\r\nu8 *buffer, uint size, int wr)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = nand->priv;\r\nuint o, s, sbsize, blksize;\r\nsbsize = (mtd->oobsize / (mtd->writesize / 512)) & ~1;\r\nwhile (size) {\r\ns = offset / sbsize;\r\nif (s > NFC_SPARE_BUFFERS - 1)\r\ns = NFC_SPARE_BUFFERS - 1;\r\no = offset - (s * sbsize);\r\nblksize = min(sbsize - o, size);\r\nif (wr)\r\nmemcpy_toio(prv->regs + NFC_SPARE_AREA(s) + o,\r\nbuffer, blksize);\r\nelse\r\nmemcpy_fromio(buffer,\r\nprv->regs + NFC_SPARE_AREA(s) + o, blksize);\r\nbuffer += blksize;\r\noffset += blksize;\r\nsize -= blksize;\r\n};\r\n}\r\nstatic void mpc5121_nfc_buf_copy(struct mtd_info *mtd, u_char *buf, int len,\r\nint wr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nuint c = prv->column;\r\nuint l;\r\nif (prv->spareonly || c >= mtd->writesize) {\r\nif (c >= mtd->writesize)\r\nc -= mtd->writesize;\r\nprv->column += len;\r\nmpc5121_nfc_copy_spare(mtd, c, buf, len, wr);\r\nreturn;\r\n}\r\nl = min((uint)len, mtd->writesize - c);\r\nprv->column += l;\r\nif (wr)\r\nmemcpy_toio(prv->regs + NFC_MAIN_AREA(0) + c, buf, l);\r\nelse\r\nmemcpy_fromio(buf, prv->regs + NFC_MAIN_AREA(0) + c, l);\r\nif (l != len) {\r\nbuf += l;\r\nlen -= l;\r\nmpc5121_nfc_buf_copy(mtd, buf, len, wr);\r\n}\r\n}\r\nstatic void mpc5121_nfc_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nmpc5121_nfc_buf_copy(mtd, buf, len, 0);\r\n}\r\nstatic void mpc5121_nfc_write_buf(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nmpc5121_nfc_buf_copy(mtd, (u_char *)buf, len, 1);\r\n}\r\nstatic int mpc5121_nfc_verify_buf(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nu_char tmp[256];\r\nuint bsize;\r\nwhile (len) {\r\nbsize = min(len, 256);\r\nmpc5121_nfc_read_buf(mtd, tmp, bsize);\r\nif (memcmp(buf, tmp, bsize))\r\nreturn 1;\r\nbuf += bsize;\r\nlen -= bsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 mpc5121_nfc_read_byte(struct mtd_info *mtd)\r\n{\r\nu8 tmp;\r\nmpc5121_nfc_read_buf(mtd, &tmp, sizeof(tmp));\r\nreturn tmp;\r\n}\r\nstatic u16 mpc5121_nfc_read_word(struct mtd_info *mtd)\r\n{\r\nu16 tmp;\r\nmpc5121_nfc_read_buf(mtd, (u_char *)&tmp, sizeof(tmp));\r\nreturn tmp;\r\n}\r\nstatic int mpc5121_nfc_read_hw_config(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nstruct mpc512x_reset_module *rm;\r\nstruct device_node *rmnode;\r\nuint rcw_pagesize = 0;\r\nuint rcw_sparesize = 0;\r\nuint rcw_width;\r\nuint rcwh;\r\nuint romloc, ps;\r\nint ret = 0;\r\nrmnode = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-reset");\r\nif (!rmnode) {\r\ndev_err(prv->dev, "Missing 'fsl,mpc5121-reset' "\r\n"node in device tree!\n");\r\nreturn -ENODEV;\r\n}\r\nrm = of_iomap(rmnode, 0);\r\nif (!rm) {\r\ndev_err(prv->dev, "Error mapping reset module node!\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nrcwh = in_be32(&rm->rcwhr);\r\nrcw_width = ((rcwh >> 6) & 0x1) ? 2 : 1;\r\nps = (rcwh >> 7) & 0x1;\r\nromloc = (rcwh >> 21) & 0x3;\r\nswitch ((ps << 2) | romloc) {\r\ncase 0x00:\r\ncase 0x01:\r\nrcw_pagesize = 512;\r\nrcw_sparesize = 16;\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\nrcw_pagesize = 4096;\r\nrcw_sparesize = 128;\r\nbreak;\r\ncase 0x04:\r\ncase 0x05:\r\nrcw_pagesize = 2048;\r\nrcw_sparesize = 64;\r\nbreak;\r\ncase 0x06:\r\ncase 0x07:\r\nrcw_pagesize = 4096;\r\nrcw_sparesize = 218;\r\nbreak;\r\n}\r\nmtd->writesize = rcw_pagesize;\r\nmtd->oobsize = rcw_sparesize;\r\nif (rcw_width == 2)\r\nchip->options |= NAND_BUSWIDTH_16;\r\ndev_notice(prv->dev, "Configured for "\r\n"%u-bit NAND, page size %u "\r\n"with %u spare.\n",\r\nrcw_width * 8, rcw_pagesize,\r\nrcw_sparesize);\r\niounmap(rm);\r\nout:\r\nof_node_put(rmnode);\r\nreturn ret;\r\n}\r\nstatic void mpc5121_nfc_free(struct device *dev, struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nif (prv->clk) {\r\nclk_disable(prv->clk);\r\nclk_put(prv->clk);\r\n}\r\nif (prv->csreg)\r\niounmap(prv->csreg);\r\n}\r\nstatic int __devinit mpc5121_nfc_probe(struct platform_device *op)\r\n{\r\nstruct device_node *rootnode, *dn = op->dev.of_node;\r\nstruct device *dev = &op->dev;\r\nstruct mpc5121_nfc_prv *prv;\r\nstruct resource res;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *chip;\r\nunsigned long regs_paddr, regs_size;\r\nconst __be32 *chips_no;\r\nint resettime = 0;\r\nint retval = 0;\r\nint rev, len;\r\nstruct mtd_part_parser_data ppdata;\r\nrev = (mfspr(SPRN_SVR) >> 4) & 0xF;\r\nif ((rev != 2) && (rev != 3)) {\r\ndev_err(dev, "SoC revision %u is not supported!\n", rev);\r\nreturn -ENXIO;\r\n}\r\nprv = devm_kzalloc(dev, sizeof(*prv), GFP_KERNEL);\r\nif (!prv) {\r\ndev_err(dev, "Memory exhausted!\n");\r\nreturn -ENOMEM;\r\n}\r\nmtd = &prv->mtd;\r\nchip = &prv->chip;\r\nmtd->priv = chip;\r\nchip->priv = prv;\r\nprv->dev = dev;\r\nretval = mpc5121_nfc_read_hw_config(mtd);\r\nif (retval) {\r\ndev_err(dev, "Unable to read NFC config!\n");\r\nreturn retval;\r\n}\r\nprv->irq = irq_of_parse_and_map(dn, 0);\r\nif (prv->irq == NO_IRQ) {\r\ndev_err(dev, "Error mapping IRQ!\n");\r\nreturn -EINVAL;\r\n}\r\nretval = of_address_to_resource(dn, 0, &res);\r\nif (retval) {\r\ndev_err(dev, "Error parsing memory region!\n");\r\nreturn retval;\r\n}\r\nchips_no = of_get_property(dn, "chips", &len);\r\nif (!chips_no || len != sizeof(*chips_no)) {\r\ndev_err(dev, "Invalid/missing 'chips' property!\n");\r\nreturn -EINVAL;\r\n}\r\nregs_paddr = res.start;\r\nregs_size = resource_size(&res);\r\nif (!devm_request_mem_region(dev, regs_paddr, regs_size, DRV_NAME)) {\r\ndev_err(dev, "Error requesting memory region!\n");\r\nreturn -EBUSY;\r\n}\r\nprv->regs = devm_ioremap(dev, regs_paddr, regs_size);\r\nif (!prv->regs) {\r\ndev_err(dev, "Error mapping memory region!\n");\r\nreturn -ENOMEM;\r\n}\r\nmtd->name = "MPC5121 NAND";\r\nppdata.of_node = dn;\r\nchip->dev_ready = mpc5121_nfc_dev_ready;\r\nchip->cmdfunc = mpc5121_nfc_command;\r\nchip->read_byte = mpc5121_nfc_read_byte;\r\nchip->read_word = mpc5121_nfc_read_word;\r\nchip->read_buf = mpc5121_nfc_read_buf;\r\nchip->write_buf = mpc5121_nfc_write_buf;\r\nchip->verify_buf = mpc5121_nfc_verify_buf;\r\nchip->select_chip = mpc5121_nfc_select_chip;\r\nchip->bbt_options = NAND_BBT_USE_FLASH;\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nrootnode = of_find_node_by_path("/");\r\nif (of_device_is_compatible(rootnode, "fsl,mpc5121ads")) {\r\nretval = ads5121_chipselect_init(mtd);\r\nif (retval) {\r\ndev_err(dev, "Chipselect init error!\n");\r\nof_node_put(rootnode);\r\nreturn retval;\r\n}\r\nchip->select_chip = ads5121_select_chip;\r\n}\r\nof_node_put(rootnode);\r\nprv->clk = clk_get(dev, "nfc_clk");\r\nif (IS_ERR(prv->clk)) {\r\ndev_err(dev, "Unable to acquire NFC clock!\n");\r\nretval = PTR_ERR(prv->clk);\r\ngoto error;\r\n}\r\nclk_enable(prv->clk);\r\nnfc_set(mtd, NFC_CONFIG1, NFC_RESET);\r\nwhile (nfc_read(mtd, NFC_CONFIG1) & NFC_RESET) {\r\nif (resettime++ >= NFC_RESET_TIMEOUT) {\r\ndev_err(dev, "Timeout while resetting NFC!\n");\r\nretval = -EINVAL;\r\ngoto error;\r\n}\r\nudelay(1);\r\n}\r\nnfc_write(mtd, NFC_CONFIG, NFC_BLS_UNLOCKED);\r\nnfc_write(mtd, NFC_UNLOCKSTART_BLK0, 0x0000);\r\nnfc_write(mtd, NFC_UNLOCKEND_BLK0, 0xFFFF);\r\nnfc_write(mtd, NFC_WRPROT, NFC_WPC_UNLOCK);\r\nnfc_write(mtd, NFC_CONFIG1, NFC_BIG_ENDIAN | NFC_INT_MASK |\r\nNFC_FULL_PAGE_INT);\r\nnfc_write(mtd, NFC_SPAS, mtd->oobsize >> 1);\r\ninit_waitqueue_head(&prv->irq_waitq);\r\nretval = devm_request_irq(dev, prv->irq, &mpc5121_nfc_irq, 0, DRV_NAME,\r\nmtd);\r\nif (retval) {\r\ndev_err(dev, "Error requesting IRQ!\n");\r\ngoto error;\r\n}\r\nif (nand_scan(mtd, be32_to_cpup(chips_no))) {\r\ndev_err(dev, "NAND Flash not found !\n");\r\ndevm_free_irq(dev, prv->irq, mtd);\r\nretval = -ENXIO;\r\ngoto error;\r\n}\r\nswitch (mtd->erasesize / mtd->writesize) {\r\ncase 32:\r\nnfc_set(mtd, NFC_CONFIG1, NFC_PPB_32);\r\nbreak;\r\ncase 64:\r\nnfc_set(mtd, NFC_CONFIG1, NFC_PPB_64);\r\nbreak;\r\ncase 128:\r\nnfc_set(mtd, NFC_CONFIG1, NFC_PPB_128);\r\nbreak;\r\ncase 256:\r\nnfc_set(mtd, NFC_CONFIG1, NFC_PPB_256);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Unsupported NAND flash!\n");\r\ndevm_free_irq(dev, prv->irq, mtd);\r\nretval = -ENXIO;\r\ngoto error;\r\n}\r\ndev_set_drvdata(dev, mtd);\r\nretval = mtd_device_parse_register(mtd, NULL, &ppdata, NULL, 0);\r\nif (retval) {\r\ndev_err(dev, "Error adding MTD device!\n");\r\ndevm_free_irq(dev, prv->irq, mtd);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nmpc5121_nfc_free(dev, mtd);\r\nreturn retval;\r\n}\r\nstatic int __devexit mpc5121_nfc_remove(struct platform_device *op)\r\n{\r\nstruct device *dev = &op->dev;\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mpc5121_nfc_prv *prv = chip->priv;\r\nnand_release(mtd);\r\ndevm_free_irq(dev, prv->irq, mtd);\r\nmpc5121_nfc_free(dev, mtd);\r\nreturn 0;\r\n}
