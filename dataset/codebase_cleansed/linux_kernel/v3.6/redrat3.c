static void redrat3_dump_signal_header(struct redrat3_signal_header *header)\r\n{\r\npr_info("%s:\n", __func__);\r\npr_info(" * length: %u, transfer_type: 0x%02x\n",\r\nheader->length, header->transfer_type);\r\npr_info(" * pause: %u, freq_count: %u, no_periods: %u\n",\r\nheader->pause, header->mod_freq_count, header->no_periods);\r\npr_info(" * lengths: %u (max: %u)\n",\r\nheader->no_lengths, header->max_lengths);\r\npr_info(" * sig_size: %u (max: %u)\n",\r\nheader->sig_size, header->max_sig_size);\r\npr_info(" * repeats: %u\n", header->no_repeats);\r\n}\r\nstatic void redrat3_dump_signal_data(char *buffer, u16 len)\r\n{\r\nint offset, i;\r\nchar *data_vals;\r\npr_info("%s:", __func__);\r\noffset = RR3_TX_HEADER_OFFSET + RR3_HEADER_LENGTH\r\n+ (RR3_DRIVER_MAXLENS * sizeof(u16));\r\ndata_vals = buffer + offset;\r\nfor (i = 0; i < len; i++) {\r\nif (i % 10 == 0)\r\npr_cont("\n * ");\r\npr_cont("%02x ", *data_vals++);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic void redrat3_issue_async(struct redrat3_dev *rr3)\r\n{\r\nint res;\r\nrr3_ftr(rr3->dev, "Entering %s\n", __func__);\r\nmemset(rr3->bulk_in_buf, 0, rr3->ep_in->wMaxPacketSize);\r\nres = usb_submit_urb(rr3->read_urb, GFP_ATOMIC);\r\nif (res)\r\nrr3_dbg(rr3->dev, "%s: receive request FAILED! "\r\n"(res %d, len %d)\n", __func__, res,\r\nrr3->read_urb->transfer_buffer_length);\r\n}\r\nstatic void redrat3_dump_fw_error(struct redrat3_dev *rr3, int code)\r\n{\r\nif (!rr3->transmitting && (code != 0x40))\r\ndev_info(rr3->dev, "fw error code 0x%02x: ", code);\r\nswitch (code) {\r\ncase 0x00:\r\npr_cont("No Error\n");\r\nbreak;\r\ncase 0x20:\r\npr_cont("Initial signal pulse not long enough "\r\n"to measure carrier frequency\n");\r\nbreak;\r\ncase 0x21:\r\npr_cont("Not enough length values allocated for signal\n");\r\nbreak;\r\ncase 0x22:\r\npr_cont("Not enough memory allocated for signal data\n");\r\nbreak;\r\ncase 0x23:\r\npr_cont("Too many signal repeats\n");\r\nbreak;\r\ncase 0x28:\r\npr_cont("Insufficient memory available for IR signal "\r\n"data memory allocation\n");\r\nbreak;\r\ncase 0x29:\r\npr_cont("Insufficient memory available "\r\n"for IrDa signal data memory allocation\n");\r\nbreak;\r\ncase 0x30:\r\npr_cont("Insufficient memory available for bulk "\r\n"transfer structure\n");\r\nbreak;\r\ncase 0x40:\r\nif (!rr3->transmitting)\r\npr_cont("Signal capture has been terminated\n");\r\nbreak;\r\ncase 0x41:\r\npr_cont("Attempt to set/get and unknown signal I/O "\r\n"algorithm parameter\n");\r\nbreak;\r\ncase 0x42:\r\npr_cont("Signal capture already started\n");\r\nbreak;\r\ndefault:\r\npr_cont("Unknown Error\n");\r\nbreak;\r\n}\r\n}\r\nstatic u32 redrat3_val_to_mod_freq(struct redrat3_signal_header *ph)\r\n{\r\nu32 mod_freq = 0;\r\nif (ph->mod_freq_count != 0)\r\nmod_freq = (RR3_CLK * ph->no_periods) /\r\n(ph->mod_freq_count * RR3_CLK_PER_COUNT);\r\nreturn mod_freq;\r\n}\r\nstatic u32 redrat3_len_to_us(u32 length)\r\n{\r\nu32 biglen = length * 1000;\r\nu32 divisor = (RR3_CLK_CONV_FACTOR) / 1000;\r\nu32 result = (u32) (biglen / divisor);\r\nreturn result ? result : 1;\r\n}\r\nstatic u32 redrat3_us_to_len(u32 microsec)\r\n{\r\nu32 result;\r\nu32 divisor;\r\nmicrosec &= IR_MAX_DURATION;\r\ndivisor = (RR3_CLK_CONV_FACTOR / 1000);\r\nresult = (u32)(microsec * divisor) / 1000;\r\nreturn result ? result : 1;\r\n}\r\nstatic void redrat3_rx_timeout(unsigned long data)\r\n{\r\nstruct redrat3_dev *rr3 = (struct redrat3_dev *)data;\r\nrr3_dbg(rr3->dev, "calling ir_raw_event_reset\n");\r\nir_raw_event_reset(rr3->rc);\r\n}\r\nstatic void redrat3_process_ir_data(struct redrat3_dev *rr3)\r\n{\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nstruct redrat3_signal_header header;\r\nstruct device *dev;\r\nint i, trailer = 0;\r\nunsigned long delay;\r\nu32 mod_freq, single_len;\r\nu16 *len_vals;\r\nu8 *data_vals;\r\nu32 tmp32;\r\nu16 tmp16;\r\nchar *sig_data;\r\nif (!rr3) {\r\npr_err("%s called with no context!\n", __func__);\r\nreturn;\r\n}\r\nrr3_ftr(rr3->dev, "Entered %s\n", __func__);\r\ndev = rr3->dev;\r\nsig_data = rr3->pbuf;\r\nheader.length = rr3->pktlen;\r\nheader.transfer_type = rr3->pkttype;\r\nif (!(header.length >= RR3_HEADER_LENGTH))\r\ndev_warn(dev, "read returned less than rr3 header len\n");\r\ndelay = usecs_to_jiffies(rr3->hw_timeout);\r\nmod_timer(&rr3->rx_timeout, jiffies + delay);\r\nmemcpy(&tmp32, sig_data + RR3_PAUSE_OFFSET, sizeof(tmp32));\r\nheader.pause = be32_to_cpu(tmp32);\r\nmemcpy(&tmp16, sig_data + RR3_FREQ_COUNT_OFFSET, sizeof(tmp16));\r\nheader.mod_freq_count = be16_to_cpu(tmp16);\r\nmemcpy(&tmp16, sig_data + RR3_NUM_PERIOD_OFFSET, sizeof(tmp16));\r\nheader.no_periods = be16_to_cpu(tmp16);\r\nheader.max_lengths = sig_data[RR3_MAX_LENGTHS_OFFSET];\r\nheader.no_lengths = sig_data[RR3_NUM_LENGTHS_OFFSET];\r\nmemcpy(&tmp16, sig_data + RR3_MAX_SIGS_OFFSET, sizeof(tmp16));\r\nheader.max_sig_size = be16_to_cpu(tmp16);\r\nmemcpy(&tmp16, sig_data + RR3_NUM_SIGS_OFFSET, sizeof(tmp16));\r\nheader.sig_size = be16_to_cpu(tmp16);\r\nheader.no_repeats= sig_data[RR3_REPEATS_OFFSET];\r\nif (debug) {\r\nredrat3_dump_signal_header(&header);\r\nredrat3_dump_signal_data(sig_data, header.sig_size);\r\n}\r\nmod_freq = redrat3_val_to_mod_freq(&header);\r\nrr3_dbg(dev, "Got mod_freq of %u\n", mod_freq);\r\nlen_vals = (u16 *)(sig_data + RR3_HEADER_LENGTH);\r\ndata_vals = sig_data + RR3_HEADER_LENGTH +\r\n(header.max_lengths * sizeof(u16));\r\nfor (i = 0; i < header.sig_size; i++) {\r\nu16 val = len_vals[data_vals[i]];\r\nsingle_len = redrat3_len_to_us((u32)be16_to_cpu(val));\r\nif (i % 2)\r\nrawir.pulse = false;\r\nelse\r\nrawir.pulse = true;\r\nrawir.duration = US_TO_NS(single_len);\r\nif (i == 0)\r\ntrailer = rawir.duration;\r\nrawir.duration &= IR_MAX_DURATION;\r\nrr3_dbg(dev, "storing %s with duration %d (i: %d)\n",\r\nrawir.pulse ? "pulse" : "space", rawir.duration, i);\r\nir_raw_event_store_with_filter(rr3->rc, &rawir);\r\n}\r\nif (i % 2) {\r\nrawir.pulse = false;\r\nif (trailer < US_TO_NS(1000))\r\nrawir.duration = US_TO_NS(2800);\r\nelse\r\nrawir.duration = trailer;\r\nrr3_dbg(dev, "storing trailing space with duration %d\n",\r\nrawir.duration);\r\nir_raw_event_store_with_filter(rr3->rc, &rawir);\r\n}\r\nrr3_dbg(dev, "calling ir_raw_event_handle\n");\r\nir_raw_event_handle(rr3->rc);\r\nreturn;\r\n}\r\nstatic u8 redrat3_send_cmd(int cmd, struct redrat3_dev *rr3)\r\n{\r\nstruct usb_device *udev;\r\nu8 *data;\r\nint res;\r\ndata = kzalloc(sizeof(u8), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nudev = rr3->udev;\r\nres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), cmd,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x0000, 0x0000, data, sizeof(u8), HZ * 10);\r\nif (res < 0) {\r\ndev_err(rr3->dev, "%s: Error sending rr3 cmd res %d, data %d",\r\n__func__, res, *data);\r\nres = -EIO;\r\n} else\r\nres = (u8)data[0];\r\nkfree(data);\r\nreturn res;\r\n}\r\nstatic int redrat3_enable_detector(struct redrat3_dev *rr3)\r\n{\r\nstruct device *dev = rr3->dev;\r\nu8 ret;\r\nrr3_ftr(dev, "Entering %s\n", __func__);\r\nret = redrat3_send_cmd(RR3_RC_DET_ENABLE, rr3);\r\nif (ret != 0)\r\ndev_dbg(dev, "%s: unexpected ret of %d\n",\r\n__func__, ret);\r\nret = redrat3_send_cmd(RR3_RC_DET_STATUS, rr3);\r\nif (ret != 1) {\r\ndev_err(dev, "%s: detector status: %d, should be 1\n",\r\n__func__, ret);\r\nreturn -EIO;\r\n}\r\nrr3->det_enabled = true;\r\nredrat3_issue_async(rr3);\r\nreturn 0;\r\n}\r\nstatic void redrat3_disable_detector(struct redrat3_dev *rr3)\r\n{\r\nstruct device *dev = rr3->dev;\r\nu8 ret;\r\nrr3_ftr(dev, "Entering %s\n", __func__);\r\nret = redrat3_send_cmd(RR3_RC_DET_DISABLE, rr3);\r\nif (ret != 0)\r\ndev_err(dev, "%s: failure!\n", __func__);\r\nret = redrat3_send_cmd(RR3_RC_DET_STATUS, rr3);\r\nif (ret != 0)\r\ndev_warn(dev, "%s: detector status: %d, should be 0\n",\r\n__func__, ret);\r\nrr3->det_enabled = false;\r\n}\r\nstatic inline void redrat3_delete(struct redrat3_dev *rr3,\r\nstruct usb_device *udev)\r\n{\r\nrr3_ftr(rr3->dev, "%s cleaning up\n", __func__);\r\nusb_kill_urb(rr3->read_urb);\r\nusb_kill_urb(rr3->write_urb);\r\nusb_free_urb(rr3->read_urb);\r\nusb_free_urb(rr3->write_urb);\r\nusb_free_coherent(udev, rr3->ep_in->wMaxPacketSize,\r\nrr3->bulk_in_buf, rr3->dma_in);\r\nusb_free_coherent(udev, rr3->ep_out->wMaxPacketSize,\r\nrr3->bulk_out_buf, rr3->dma_out);\r\nkfree(rr3);\r\n}\r\nstatic u32 redrat3_get_timeout(struct redrat3_dev *rr3)\r\n{\r\nu32 *tmp;\r\nu32 timeout = MS_TO_US(150);\r\nint len, ret, pipe;\r\nlen = sizeof(*tmp);\r\ntmp = kzalloc(len, GFP_KERNEL);\r\nif (!tmp) {\r\ndev_warn(rr3->dev, "Memory allocation faillure\n");\r\nreturn timeout;\r\n}\r\npipe = usb_rcvctrlpipe(rr3->udev, 0);\r\nret = usb_control_msg(rr3->udev, pipe, RR3_GET_IR_PARAM,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nRR3_IR_IO_SIG_TIMEOUT, 0, tmp, len, HZ * 5);\r\nif (ret != len) {\r\ndev_warn(rr3->dev, "Failed to read timeout from hardware\n");\r\nreturn timeout;\r\n}\r\ntimeout = redrat3_len_to_us(be32_to_cpu(*tmp));\r\nrr3_dbg(rr3->dev, "Got timeout of %d ms\n", timeout / 1000);\r\nreturn timeout;\r\n}\r\nstatic void redrat3_reset(struct redrat3_dev *rr3)\r\n{\r\nstruct usb_device *udev = rr3->udev;\r\nstruct device *dev = rr3->dev;\r\nint rc, rxpipe, txpipe;\r\nu8 *val;\r\nint len = sizeof(u8);\r\nrr3_ftr(dev, "Entering %s\n", __func__);\r\nrxpipe = usb_rcvctrlpipe(udev, 0);\r\ntxpipe = usb_sndctrlpipe(udev, 0);\r\nval = kzalloc(len, GFP_KERNEL);\r\nif (!val) {\r\ndev_err(dev, "Memory allocation failure\n");\r\nreturn;\r\n}\r\n*val = 0x01;\r\nrc = usb_control_msg(udev, rxpipe, RR3_RESET,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nRR3_CPUCS_REG_ADDR, 0, val, len, HZ * 25);\r\nrr3_dbg(dev, "reset returned 0x%02x\n", rc);\r\n*val = 5;\r\nrc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\nRR3_IR_IO_LENGTH_FUZZ, 0, val, len, HZ * 25);\r\nrr3_dbg(dev, "set ir parm len fuzz %d rc 0x%02x\n", *val, rc);\r\n*val = RR3_DRIVER_MAXLENS;\r\nrc = usb_control_msg(udev, txpipe, RR3_SET_IR_PARAM,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\nRR3_IR_IO_MAX_LENGTHS, 0, val, len, HZ * 25);\r\nrr3_dbg(dev, "set ir parm max lens %d rc 0x%02x\n", *val, rc);\r\nkfree(val);\r\n}\r\nstatic void redrat3_get_firmware_rev(struct redrat3_dev *rr3)\r\n{\r\nint rc = 0;\r\nchar *buffer;\r\nrr3_ftr(rr3->dev, "Entering %s\n", __func__);\r\nbuffer = kzalloc(sizeof(char) * (RR3_FW_VERSION_LEN + 1), GFP_KERNEL);\r\nif (!buffer) {\r\ndev_err(rr3->dev, "Memory allocation failure\n");\r\nreturn;\r\n}\r\nrc = usb_control_msg(rr3->udev, usb_rcvctrlpipe(rr3->udev, 0),\r\nRR3_FW_VERSION,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, 0, buffer, RR3_FW_VERSION_LEN, HZ * 5);\r\nif (rc >= 0)\r\ndev_info(rr3->dev, "Firmware rev: %s", buffer);\r\nelse\r\ndev_err(rr3->dev, "Problem fetching firmware ID\n");\r\nkfree(buffer);\r\nrr3_ftr(rr3->dev, "Exiting %s\n", __func__);\r\n}\r\nstatic void redrat3_read_packet_start(struct redrat3_dev *rr3, int len)\r\n{\r\nu16 tx_error;\r\nu16 hdrlen;\r\nrr3_ftr(rr3->dev, "Entering %s\n", __func__);\r\nmemcpy(&(rr3->pktlen), (unsigned char *) rr3->bulk_in_buf,\r\nsizeof(rr3->pktlen));\r\nmemcpy(&(rr3->pkttype), ((unsigned char *) rr3->bulk_in_buf +\r\nsizeof(rr3->pktlen)),\r\nsizeof(rr3->pkttype));\r\nrr3->pktlen = be16_to_cpu(rr3->pktlen);\r\nrr3->pkttype = be16_to_cpu(rr3->pkttype);\r\nswitch (rr3->pkttype) {\r\ncase RR3_ERROR:\r\nmemcpy(&tx_error, ((unsigned char *)rr3->bulk_in_buf\r\n+ (sizeof(rr3->pktlen) + sizeof(rr3->pkttype))),\r\nsizeof(tx_error));\r\ntx_error = be16_to_cpu(tx_error);\r\nredrat3_dump_fw_error(rr3, tx_error);\r\nbreak;\r\ncase RR3_MOD_SIGNAL_IN:\r\nhdrlen = sizeof(rr3->pktlen) + sizeof(rr3->pkttype);\r\nrr3->bytes_read = len;\r\nrr3->bytes_read -= hdrlen;\r\nrr3->datap = &(rr3->pbuf[0]);\r\nmemcpy(rr3->datap, ((unsigned char *)rr3->bulk_in_buf + hdrlen),\r\nrr3->bytes_read);\r\nrr3->datap += rr3->bytes_read;\r\nrr3_dbg(rr3->dev, "bytes_read %d, pktlen %d\n",\r\nrr3->bytes_read, rr3->pktlen);\r\nbreak;\r\ndefault:\r\nrr3_dbg(rr3->dev, "ignoring packet with type 0x%02x, "\r\n"len of %d, 0x%02x\n", rr3->pkttype, len, rr3->pktlen);\r\nbreak;\r\n}\r\n}\r\nstatic void redrat3_read_packet_continue(struct redrat3_dev *rr3, int len)\r\n{\r\nrr3_ftr(rr3->dev, "Entering %s\n", __func__);\r\nmemcpy(rr3->datap, (unsigned char *)rr3->bulk_in_buf, len);\r\nrr3->datap += len;\r\nrr3->bytes_read += len;\r\nrr3_dbg(rr3->dev, "bytes_read %d, pktlen %d\n",\r\nrr3->bytes_read, rr3->pktlen);\r\n}\r\nstatic int redrat3_get_ir_data(struct redrat3_dev *rr3, int len)\r\n{\r\nstruct device *dev = rr3->dev;\r\nint ret = 0;\r\nrr3_ftr(dev, "Entering %s\n", __func__);\r\nif (rr3->pktlen > RR3_MAX_BUF_SIZE) {\r\ndev_err(rr3->dev, "error: packet larger than buffer\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif ((rr3->bytes_read == 0) &&\r\n(len >= (sizeof(rr3->pkttype) + sizeof(rr3->pktlen)))) {\r\nredrat3_read_packet_start(rr3, len);\r\n} else if (rr3->bytes_read != 0) {\r\nredrat3_read_packet_continue(rr3, len);\r\n} else if (rr3->bytes_read == 0) {\r\ndev_err(dev, "error: no packet data read\n");\r\nret = -ENODATA;\r\ngoto out;\r\n}\r\nif (rr3->bytes_read > rr3->pktlen) {\r\ndev_err(dev, "bytes_read (%d) greater than pktlen (%d)\n",\r\nrr3->bytes_read, rr3->pktlen);\r\nret = -EINVAL;\r\ngoto out;\r\n} else if (rr3->bytes_read < rr3->pktlen)\r\nreturn 0;\r\nif (rr3->pkttype == RR3_MOD_SIGNAL_IN)\r\nredrat3_process_ir_data(rr3);\r\nelse\r\nrr3_dbg(dev, "discarding non-signal data packet "\r\n"(type 0x%02x)\n", rr3->pkttype);\r\nout:\r\nrr3->bytes_read = 0;\r\nrr3->pktlen = 0;\r\nrr3->pkttype = 0;\r\nreturn ret;\r\n}\r\nstatic void redrat3_handle_async(struct urb *urb, struct pt_regs *regs)\r\n{\r\nstruct redrat3_dev *rr3;\r\nint ret;\r\nif (!urb)\r\nreturn;\r\nrr3 = urb->context;\r\nif (!rr3) {\r\npr_err("%s called with invalid context!\n", __func__);\r\nusb_unlink_urb(urb);\r\nreturn;\r\n}\r\nrr3_ftr(rr3->dev, "Entering %s\n", __func__);\r\nswitch (urb->status) {\r\ncase 0:\r\nret = redrat3_get_ir_data(rr3, urb->actual_length);\r\nif (!ret) {\r\nredrat3_issue_async(rr3);\r\n}\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_warn(rr3->dev, "Error: urb status = %d\n", urb->status);\r\nrr3->bytes_read = 0;\r\nrr3->pktlen = 0;\r\nrr3->pkttype = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void redrat3_write_bulk_callback(struct urb *urb, struct pt_regs *regs)\r\n{\r\nstruct redrat3_dev *rr3;\r\nint len;\r\nif (!urb)\r\nreturn;\r\nrr3 = urb->context;\r\nif (rr3) {\r\nlen = urb->actual_length;\r\nrr3_ftr(rr3->dev, "%s: called (status=%d len=%d)\n",\r\n__func__, urb->status, len);\r\n}\r\n}\r\nstatic u16 mod_freq_to_val(unsigned int mod_freq)\r\n{\r\nint mult = 6000000;\r\nreturn (u16)(65536 - (mult / mod_freq));\r\n}\r\nstatic int redrat3_set_tx_carrier(struct rc_dev *rcdev, u32 carrier)\r\n{\r\nstruct redrat3_dev *rr3 = rcdev->priv;\r\nstruct device *dev = rr3->dev;\r\nrr3_dbg(dev, "Setting modulation frequency to %u", carrier);\r\nrr3->carrier = carrier;\r\nreturn carrier;\r\n}\r\nstatic int redrat3_transmit_ir(struct rc_dev *rcdev, unsigned *txbuf,\r\nunsigned count)\r\n{\r\nstruct redrat3_dev *rr3 = rcdev->priv;\r\nstruct device *dev = rr3->dev;\r\nstruct redrat3_signal_header header;\r\nint i, j, ret, ret_len, offset;\r\nint lencheck, cur_sample_len, pipe;\r\nchar *buffer = NULL, *sigdata = NULL;\r\nint *sample_lens = NULL;\r\nu32 tmpi;\r\nu16 tmps;\r\nu8 *datap;\r\nu8 curlencheck = 0;\r\nu16 *lengths_ptr;\r\nint sendbuf_len;\r\nrr3_ftr(dev, "Entering %s\n", __func__);\r\nif (rr3->transmitting) {\r\ndev_warn(dev, "%s: transmitter already in use\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nif (count > (RR3_DRIVER_MAXLENS * 2))\r\nreturn -EINVAL;\r\nrr3->det_enabled = false;\r\nrr3->transmitting = true;\r\nsample_lens = kzalloc(sizeof(int) * RR3_DRIVER_MAXLENS, GFP_KERNEL);\r\nif (!sample_lens) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nfor (lencheck = 0; lencheck < curlencheck; lencheck++) {\r\ncur_sample_len = redrat3_us_to_len(txbuf[i]);\r\nif (sample_lens[lencheck] == cur_sample_len)\r\nbreak;\r\n}\r\nif (lencheck == curlencheck) {\r\ncur_sample_len = redrat3_us_to_len(txbuf[i]);\r\nrr3_dbg(dev, "txbuf[%d]=%u, pos %d, enc %u\n",\r\ni, txbuf[i], curlencheck, cur_sample_len);\r\nif (curlencheck < 255) {\r\nsample_lens[curlencheck] = cur_sample_len;\r\ncurlencheck++;\r\n} else {\r\ndev_err(dev, "signal too long\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\n}\r\nsigdata = kzalloc((count + RR3_TX_TRAILER_LEN), GFP_KERNEL);\r\nif (!sigdata) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsigdata[count] = RR3_END_OF_SIGNAL;\r\nsigdata[count + 1] = RR3_END_OF_SIGNAL;\r\nfor (i = 0; i < count; i++) {\r\nfor (j = 0; j < curlencheck; j++) {\r\nif (sample_lens[j] == redrat3_us_to_len(txbuf[i]))\r\nsigdata[i] = j;\r\n}\r\n}\r\noffset = RR3_TX_HEADER_OFFSET;\r\nsendbuf_len = RR3_HEADER_LENGTH + (sizeof(u16) * RR3_DRIVER_MAXLENS)\r\n+ count + RR3_TX_TRAILER_LEN + offset;\r\nbuffer = kzalloc(sendbuf_len, GFP_KERNEL);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nheader.length = sendbuf_len - offset;\r\nheader.transfer_type = RR3_MOD_SIGNAL_OUT;\r\nheader.pause = redrat3_len_to_us(100);\r\nheader.mod_freq_count = mod_freq_to_val(rr3->carrier);\r\nheader.no_periods = 0;\r\nheader.max_lengths = RR3_DRIVER_MAXLENS;\r\nheader.no_lengths = curlencheck;\r\nheader.max_sig_size = RR3_MAX_SIG_SIZE;\r\nheader.sig_size = count + RR3_TX_TRAILER_LEN;\r\nheader.no_repeats = 0;\r\ntmps = cpu_to_be16(header.length);\r\nmemcpy(buffer, &tmps, 2);\r\ntmps = cpu_to_be16(header.transfer_type);\r\nmemcpy(buffer + 2, &tmps, 2);\r\ntmpi = cpu_to_be32(header.pause);\r\nmemcpy(buffer + offset, &tmpi, sizeof(tmpi));\r\ntmps = cpu_to_be16(header.mod_freq_count);\r\nmemcpy(buffer + offset + RR3_FREQ_COUNT_OFFSET, &tmps, 2);\r\nbuffer[offset + RR3_NUM_LENGTHS_OFFSET] = header.no_lengths;\r\ntmps = cpu_to_be16(header.sig_size);\r\nmemcpy(buffer + offset + RR3_NUM_SIGS_OFFSET, &tmps, 2);\r\nbuffer[offset + RR3_REPEATS_OFFSET] = header.no_repeats;\r\nlengths_ptr = (u16 *)(buffer + offset + RR3_HEADER_LENGTH);\r\nfor (i = 0; i < curlencheck; ++i)\r\nlengths_ptr[i] = cpu_to_be16(sample_lens[i]);\r\ndatap = (u8 *)(buffer + offset + RR3_HEADER_LENGTH +\r\n(sizeof(u16) * RR3_DRIVER_MAXLENS));\r\nmemcpy(datap, sigdata, (count + RR3_TX_TRAILER_LEN));\r\nif (debug) {\r\nredrat3_dump_signal_header(&header);\r\nredrat3_dump_signal_data(buffer, header.sig_size);\r\n}\r\npipe = usb_sndbulkpipe(rr3->udev, rr3->ep_out->bEndpointAddress);\r\ntmps = usb_bulk_msg(rr3->udev, pipe, buffer,\r\nsendbuf_len, &ret_len, 10 * HZ);\r\nrr3_dbg(dev, "sent %d bytes, (ret %d)\n", ret_len, tmps);\r\npipe = usb_rcvctrlpipe(rr3->udev, 0);\r\nret = usb_control_msg(rr3->udev, pipe, RR3_TX_SEND_SIGNAL,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, 0, buffer, 2, HZ * 10);\r\nif (ret < 0)\r\ndev_err(dev, "Error: control msg send failed, rc %d\n", ret);\r\nelse\r\nret = count;\r\nout:\r\nkfree(sample_lens);\r\nkfree(buffer);\r\nkfree(sigdata);\r\nrr3->transmitting = false;\r\nrr3->det_enabled = true;\r\nreturn ret;\r\n}\r\nstatic struct rc_dev *redrat3_init_rc_dev(struct redrat3_dev *rr3)\r\n{\r\nstruct device *dev = rr3->dev;\r\nstruct rc_dev *rc;\r\nint ret = -ENODEV;\r\nu16 prod = le16_to_cpu(rr3->udev->descriptor.idProduct);\r\nrc = rc_allocate_device();\r\nif (!rc) {\r\ndev_err(dev, "remote input dev allocation failed\n");\r\ngoto out;\r\n}\r\nsnprintf(rr3->name, sizeof(rr3->name), "RedRat3%s "\r\n"Infrared Remote Transceiver (%04x:%04x)",\r\nprod == USB_RR3IIUSB_PRODUCT_ID ? "-II" : "",\r\nle16_to_cpu(rr3->udev->descriptor.idVendor), prod);\r\nusb_make_path(rr3->udev, rr3->phys, sizeof(rr3->phys));\r\nrc->input_name = rr3->name;\r\nrc->input_phys = rr3->phys;\r\nusb_to_input_id(rr3->udev, &rc->input_id);\r\nrc->dev.parent = dev;\r\nrc->priv = rr3;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->allowed_protos = RC_TYPE_ALL;\r\nrc->timeout = US_TO_NS(2750);\r\nrc->tx_ir = redrat3_transmit_ir;\r\nrc->s_tx_carrier = redrat3_set_tx_carrier;\r\nrc->driver_name = DRIVER_NAME;\r\nrc->map_name = RC_MAP_HAUPPAUGE;\r\nret = rc_register_device(rc);\r\nif (ret < 0) {\r\ndev_err(dev, "remote dev registration failed\n");\r\ngoto out;\r\n}\r\nreturn rc;\r\nout:\r\nrc_free_device(rc);\r\nreturn NULL;\r\n}\r\nstatic int __devinit redrat3_dev_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct device *dev = &intf->dev;\r\nstruct usb_host_interface *uhi;\r\nstruct redrat3_dev *rr3;\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct usb_endpoint_descriptor *ep_in = NULL;\r\nstruct usb_endpoint_descriptor *ep_out = NULL;\r\nu8 addr, attrs;\r\nint pipe, i;\r\nint retval = -ENOMEM;\r\nrr3_ftr(dev, "%s called\n", __func__);\r\nuhi = intf->cur_altsetting;\r\nfor (i = 0; i < uhi->desc.bNumEndpoints; ++i) {\r\nep = &uhi->endpoint[i].desc;\r\naddr = ep->bEndpointAddress;\r\nattrs = ep->bmAttributes;\r\nif ((ep_in == NULL) &&\r\n((addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) &&\r\n((attrs & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_BULK)) {\r\nrr3_dbg(dev, "found bulk-in endpoint at 0x%02x\n",\r\nep->bEndpointAddress);\r\nif (ep->bEndpointAddress == RR3_BULK_IN_EP_ADDR)\r\nep_in = ep;\r\n}\r\nif ((ep_out == NULL) &&\r\n((addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT) &&\r\n((attrs & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_BULK)) {\r\nrr3_dbg(dev, "found bulk-out endpoint at 0x%02x\n",\r\nep->bEndpointAddress);\r\nep_out = ep;\r\n}\r\n}\r\nif (!ep_in || !ep_out) {\r\ndev_err(dev, "Couldn't find both in and out endpoints\n");\r\nretval = -ENODEV;\r\ngoto no_endpoints;\r\n}\r\nrr3 = kzalloc(sizeof(*rr3), GFP_KERNEL);\r\nif (rr3 == NULL) {\r\ndev_err(dev, "Memory allocation failure\n");\r\ngoto no_endpoints;\r\n}\r\nrr3->dev = &intf->dev;\r\nrr3->read_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rr3->read_urb) {\r\ndev_err(dev, "Read urb allocation failure\n");\r\ngoto error;\r\n}\r\nrr3->ep_in = ep_in;\r\nrr3->bulk_in_buf = usb_alloc_coherent(udev, ep_in->wMaxPacketSize,\r\nGFP_ATOMIC, &rr3->dma_in);\r\nif (!rr3->bulk_in_buf) {\r\ndev_err(dev, "Read buffer allocation failure\n");\r\ngoto error;\r\n}\r\npipe = usb_rcvbulkpipe(udev, ep_in->bEndpointAddress);\r\nusb_fill_bulk_urb(rr3->read_urb, udev, pipe,\r\nrr3->bulk_in_buf, ep_in->wMaxPacketSize,\r\n(usb_complete_t)redrat3_handle_async, rr3);\r\nrr3->write_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rr3->write_urb) {\r\ndev_err(dev, "Write urb allocation failure\n");\r\ngoto error;\r\n}\r\nrr3->ep_out = ep_out;\r\nrr3->bulk_out_buf = usb_alloc_coherent(udev, ep_out->wMaxPacketSize,\r\nGFP_ATOMIC, &rr3->dma_out);\r\nif (!rr3->bulk_out_buf) {\r\ndev_err(dev, "Write buffer allocation failure\n");\r\ngoto error;\r\n}\r\npipe = usb_sndbulkpipe(udev, ep_out->bEndpointAddress);\r\nusb_fill_bulk_urb(rr3->write_urb, udev, pipe,\r\nrr3->bulk_out_buf, ep_out->wMaxPacketSize,\r\n(usb_complete_t)redrat3_write_bulk_callback, rr3);\r\nmutex_init(&rr3->lock);\r\nrr3->udev = udev;\r\nredrat3_reset(rr3);\r\nredrat3_get_firmware_rev(rr3);\r\nretval = redrat3_enable_detector(rr3);\r\nif (retval < 0)\r\ngoto error;\r\nrr3->hw_timeout = redrat3_get_timeout(rr3);\r\nrr3->carrier = 38000;\r\nrr3->rc = redrat3_init_rc_dev(rr3);\r\nif (!rr3->rc)\r\ngoto error;\r\nsetup_timer(&rr3->rx_timeout, redrat3_rx_timeout, (unsigned long)rr3);\r\nusb_set_intfdata(intf, rr3);\r\nrr3_ftr(dev, "Exiting %s\n", __func__);\r\nreturn 0;\r\nerror:\r\nredrat3_delete(rr3, rr3->udev);\r\nno_endpoints:\r\ndev_err(dev, "%s: retval = %x", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic void __devexit redrat3_dev_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\r\nrr3_ftr(&intf->dev, "Entering %s\n", __func__);\r\nif (!rr3)\r\nreturn;\r\nredrat3_disable_detector(rr3);\r\nusb_set_intfdata(intf, NULL);\r\nrc_unregister_device(rr3->rc);\r\ndel_timer_sync(&rr3->rx_timeout);\r\nredrat3_delete(rr3, udev);\r\nrr3_ftr(&intf->dev, "RedRat3 IR Transceiver now disconnected\n");\r\n}\r\nstatic int redrat3_dev_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\r\nrr3_ftr(rr3->dev, "suspend\n");\r\nusb_kill_urb(rr3->read_urb);\r\nreturn 0;\r\n}\r\nstatic int redrat3_dev_resume(struct usb_interface *intf)\r\n{\r\nstruct redrat3_dev *rr3 = usb_get_intfdata(intf);\r\nrr3_ftr(rr3->dev, "resume\n");\r\nif (usb_submit_urb(rr3->read_urb, GFP_ATOMIC))\r\nreturn -EIO;\r\nreturn 0;\r\n}
