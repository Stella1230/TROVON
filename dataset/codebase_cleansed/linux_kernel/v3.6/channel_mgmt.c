void vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp,\r\nstruct icmsg_negotiate *negop, u8 *buf,\r\nint max_fw_version, int max_srv_version)\r\n{\r\nint icframe_vercnt;\r\nint icmsg_vercnt;\r\nint i;\r\nicmsghdrp->icmsgsize = 0x10;\r\nnegop = (struct icmsg_negotiate *)&buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nicframe_vercnt = negop->icframe_vercnt;\r\nicmsg_vercnt = negop->icmsg_vercnt;\r\nfor (i = 0; i < negop->icframe_vercnt; i++) {\r\nif (negop->icversion_data[i].major <= max_fw_version)\r\nicframe_vercnt = negop->icversion_data[i].major;\r\n}\r\nfor (i = negop->icframe_vercnt;\r\n(i < negop->icframe_vercnt + negop->icmsg_vercnt); i++) {\r\nif (negop->icversion_data[i].major <= max_srv_version)\r\nicmsg_vercnt = negop->icversion_data[i].major;\r\n}\r\nnegop->icframe_vercnt = 1;\r\nnegop->icmsg_vercnt = 1;\r\nnegop->icversion_data[0].major = icframe_vercnt;\r\nnegop->icversion_data[0].minor = 0;\r\nnegop->icversion_data[1].major = icmsg_vercnt;\r\nnegop->icversion_data[1].minor = 0;\r\n}\r\nstatic struct vmbus_channel *alloc_channel(void)\r\n{\r\nstruct vmbus_channel *channel;\r\nchannel = kzalloc(sizeof(*channel), GFP_ATOMIC);\r\nif (!channel)\r\nreturn NULL;\r\nspin_lock_init(&channel->inbound_lock);\r\nchannel->controlwq = create_workqueue("hv_vmbus_ctl");\r\nif (!channel->controlwq) {\r\nkfree(channel);\r\nreturn NULL;\r\n}\r\nreturn channel;\r\n}\r\nstatic void release_channel(struct work_struct *work)\r\n{\r\nstruct vmbus_channel *channel = container_of(work,\r\nstruct vmbus_channel,\r\nwork);\r\ndestroy_workqueue(channel->controlwq);\r\nkfree(channel);\r\n}\r\nstatic void free_channel(struct vmbus_channel *channel)\r\n{\r\nINIT_WORK(&channel->work, release_channel);\r\nqueue_work(vmbus_connection.work_queue, &channel->work);\r\n}\r\nstatic void vmbus_process_rescind_offer(struct work_struct *work)\r\n{\r\nstruct vmbus_channel *channel = container_of(work,\r\nstruct vmbus_channel,\r\nwork);\r\nvmbus_device_unregister(channel->device_obj);\r\n}\r\nvoid vmbus_free_channels(void)\r\n{\r\nstruct vmbus_channel *channel;\r\nlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\r\nvmbus_device_unregister(channel->device_obj);\r\nkfree(channel->device_obj);\r\nfree_channel(channel);\r\n}\r\n}\r\nstatic void vmbus_process_offer(struct work_struct *work)\r\n{\r\nstruct vmbus_channel *newchannel = container_of(work,\r\nstruct vmbus_channel,\r\nwork);\r\nstruct vmbus_channel *channel;\r\nbool fnew = true;\r\nint ret;\r\nunsigned long flags;\r\nINIT_WORK(&newchannel->work, vmbus_process_rescind_offer);\r\nspin_lock_irqsave(&vmbus_connection.channel_lock, flags);\r\nlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\r\nif (!uuid_le_cmp(channel->offermsg.offer.if_type,\r\nnewchannel->offermsg.offer.if_type) &&\r\n!uuid_le_cmp(channel->offermsg.offer.if_instance,\r\nnewchannel->offermsg.offer.if_instance)) {\r\nfnew = false;\r\nbreak;\r\n}\r\n}\r\nif (fnew)\r\nlist_add_tail(&newchannel->listentry,\r\n&vmbus_connection.chn_list);\r\nspin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);\r\nif (!fnew) {\r\nfree_channel(newchannel);\r\nreturn;\r\n}\r\nnewchannel->device_obj = vmbus_device_create(\r\n&newchannel->offermsg.offer.if_type,\r\n&newchannel->offermsg.offer.if_instance,\r\nnewchannel);\r\nret = vmbus_device_register(newchannel->device_obj);\r\nif (ret != 0) {\r\npr_err("unable to add child device object (relid %d)\n",\r\nnewchannel->offermsg.child_relid);\r\nspin_lock_irqsave(&vmbus_connection.channel_lock, flags);\r\nlist_del(&newchannel->listentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);\r\nkfree(newchannel->device_obj);\r\nfree_channel(newchannel);\r\n} else {\r\nnewchannel->state = CHANNEL_OPEN_STATE;\r\n}\r\n}\r\nstatic void vmbus_onoffer(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_offer_channel *offer;\r\nstruct vmbus_channel *newchannel;\r\nuuid_le *guidtype;\r\nuuid_le *guidinstance;\r\noffer = (struct vmbus_channel_offer_channel *)hdr;\r\nguidtype = &offer->offer.if_type;\r\nguidinstance = &offer->offer.if_instance;\r\nnewchannel = alloc_channel();\r\nif (!newchannel) {\r\npr_err("Unable to allocate channel object\n");\r\nreturn;\r\n}\r\nmemcpy(&newchannel->offermsg, offer,\r\nsizeof(struct vmbus_channel_offer_channel));\r\nnewchannel->monitor_grp = (u8)offer->monitorid / 32;\r\nnewchannel->monitor_bit = (u8)offer->monitorid % 32;\r\nINIT_WORK(&newchannel->work, vmbus_process_offer);\r\nqueue_work(newchannel->controlwq, &newchannel->work);\r\n}\r\nstatic void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_rescind_offer *rescind;\r\nstruct vmbus_channel *channel;\r\nrescind = (struct vmbus_channel_rescind_offer *)hdr;\r\nchannel = relid2channel(rescind->child_relid);\r\nif (channel == NULL)\r\nreturn;\r\nqueue_work(channel->controlwq, &channel->work);\r\n}\r\nstatic void vmbus_onoffers_delivered(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\n}\r\nstatic void vmbus_onopen_result(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_open_result *result;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_open_channel *openmsg;\r\nunsigned long flags;\r\nresult = (struct vmbus_channel_open_result *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_OPENCHANNEL) {\r\nopenmsg =\r\n(struct vmbus_channel_open_channel *)msginfo->msg;\r\nif (openmsg->child_relid == result->child_relid &&\r\nopenmsg->openid == result->openid) {\r\nmemcpy(&msginfo->response.open_result,\r\nresult,\r\nsizeof(\r\nstruct vmbus_channel_open_result));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_ongpadl_created(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_gpadl_created *gpadlcreated;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_gpadl_header *gpadlheader;\r\nunsigned long flags;\r\ngpadlcreated = (struct vmbus_channel_gpadl_created *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_GPADL_HEADER) {\r\ngpadlheader =\r\n(struct vmbus_channel_gpadl_header *)requestheader;\r\nif ((gpadlcreated->child_relid ==\r\ngpadlheader->child_relid) &&\r\n(gpadlcreated->gpadl == gpadlheader->gpadl)) {\r\nmemcpy(&msginfo->response.gpadl_created,\r\ngpadlcreated,\r\nsizeof(\r\nstruct vmbus_channel_gpadl_created));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_ongpadl_torndown(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_gpadl_torndown *gpadl_torndown;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_gpadl_teardown *gpadl_teardown;\r\nunsigned long flags;\r\ngpadl_torndown = (struct vmbus_channel_gpadl_torndown *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_GPADL_TEARDOWN) {\r\ngpadl_teardown =\r\n(struct vmbus_channel_gpadl_teardown *)requestheader;\r\nif (gpadl_torndown->gpadl == gpadl_teardown->gpadl) {\r\nmemcpy(&msginfo->response.gpadl_torndown,\r\ngpadl_torndown,\r\nsizeof(\r\nstruct vmbus_channel_gpadl_torndown));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_onversion_response(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_initiate_contact *initiate;\r\nstruct vmbus_channel_version_response *version_response;\r\nunsigned long flags;\r\nversion_response = (struct vmbus_channel_version_response *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype ==\r\nCHANNELMSG_INITIATE_CONTACT) {\r\ninitiate =\r\n(struct vmbus_channel_initiate_contact *)requestheader;\r\nmemcpy(&msginfo->response.version_response,\r\nversion_response,\r\nsizeof(struct vmbus_channel_version_response));\r\ncomplete(&msginfo->waitevent);\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nvoid vmbus_onmessage(void *context)\r\n{\r\nstruct hv_message *msg = context;\r\nstruct vmbus_channel_message_header *hdr;\r\nint size;\r\nhdr = (struct vmbus_channel_message_header *)msg->u.payload;\r\nsize = msg->header.payload_size;\r\nif (hdr->msgtype >= CHANNELMSG_COUNT) {\r\npr_err("Received invalid channel message type %d size %d\n",\r\nhdr->msgtype, size);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_NONE,\r\n(unsigned char *)msg->u.payload, size);\r\nreturn;\r\n}\r\nif (channel_message_table[hdr->msgtype].message_handler)\r\nchannel_message_table[hdr->msgtype].message_handler(hdr);\r\nelse\r\npr_err("Unhandled channel message type %d\n", hdr->msgtype);\r\n}\r\nint vmbus_request_offers(void)\r\n{\r\nstruct vmbus_channel_message_header *msg;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nint ret, t;\r\nmsginfo = kmalloc(sizeof(*msginfo) +\r\nsizeof(struct vmbus_channel_message_header),\r\nGFP_KERNEL);\r\nif (!msginfo)\r\nreturn -ENOMEM;\r\ninit_completion(&msginfo->waitevent);\r\nmsg = (struct vmbus_channel_message_header *)msginfo->msg;\r\nmsg->msgtype = CHANNELMSG_REQUESTOFFERS;\r\nret = vmbus_post_msg(msg,\r\nsizeof(struct vmbus_channel_message_header));\r\nif (ret != 0) {\r\npr_err("Unable to request offers - %d\n", ret);\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\ncleanup:\r\nkfree(msginfo);\r\nreturn ret;\r\n}
