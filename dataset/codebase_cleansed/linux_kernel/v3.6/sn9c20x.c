static void reg_r(struct gspca_dev *gspca_dev, u16 reg, u16 length)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint result;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x00,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nreg,\r\n0x00,\r\ngspca_dev->usb_buf,\r\nlength,\r\n500);\r\nif (unlikely(result < 0 || result != length)) {\r\npr_err("Read register %02x failed %d\n", reg, result);\r\ngspca_dev->usb_err = result;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 reg,\r\nconst u8 *buffer, int length)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint result;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nmemcpy(gspca_dev->usb_buf, buffer, length);\r\nresult = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nreg,\r\n0x00,\r\ngspca_dev->usb_buf,\r\nlength,\r\n500);\r\nif (unlikely(result < 0 || result != length)) {\r\npr_err("Write register %02x failed %d\n", reg, result);\r\ngspca_dev->usb_err = result;\r\n}\r\n}\r\nstatic void reg_w1(struct gspca_dev *gspca_dev, u16 reg, const u8 value)\r\n{\r\nreg_w(gspca_dev, reg, &value, 1);\r\n}\r\nstatic void i2c_w(struct gspca_dev *gspca_dev, const u8 *buffer)\r\n{\r\nint i;\r\nreg_w(gspca_dev, 0x10c0, buffer, 8);\r\nfor (i = 0; i < 5; i++) {\r\nreg_r(gspca_dev, 0x10c0, 1);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (gspca_dev->usb_buf[0] & 0x04) {\r\nif (gspca_dev->usb_buf[0] & 0x08) {\r\npr_err("i2c_w error\n");\r\ngspca_dev->usb_err = -EIO;\r\n}\r\nreturn;\r\n}\r\nmsleep(10);\r\n}\r\npr_err("i2c_w reg %02x no response\n", buffer[2]);\r\n}\r\nstatic void i2c_w1(struct gspca_dev *gspca_dev, u8 reg, u8 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = sd->i2c_intf | (2 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = val;\r\nrow[4] = 0x00;\r\nrow[5] = 0x00;\r\nrow[6] = 0x00;\r\nrow[7] = 0x10;\r\ni2c_w(gspca_dev, row);\r\n}\r\nstatic void i2c_w1_buf(struct gspca_dev *gspca_dev,\r\nconst struct i2c_reg_u8 *buf, int sz)\r\n{\r\nwhile (--sz >= 0) {\r\ni2c_w1(gspca_dev, buf->reg, buf->val);\r\nbuf++;\r\n}\r\n}\r\nstatic void i2c_w2(struct gspca_dev *gspca_dev, u8 reg, u16 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = sd->i2c_intf | (3 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = val >> 8;\r\nrow[4] = val;\r\nrow[5] = 0x00;\r\nrow[6] = 0x00;\r\nrow[7] = 0x10;\r\ni2c_w(gspca_dev, row);\r\n}\r\nstatic void i2c_w2_buf(struct gspca_dev *gspca_dev,\r\nconst struct i2c_reg_u16 *buf, int sz)\r\n{\r\nwhile (--sz >= 0) {\r\ni2c_w2(gspca_dev, buf->reg, buf->val);\r\nbuf++;\r\n}\r\n}\r\nstatic void i2c_r1(struct gspca_dev *gspca_dev, u8 reg, u8 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = sd->i2c_intf | (1 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = 0;\r\nrow[4] = 0;\r\nrow[5] = 0;\r\nrow[6] = 0;\r\nrow[7] = 0x10;\r\ni2c_w(gspca_dev, row);\r\nrow[0] = sd->i2c_intf | (1 << 4) | 0x02;\r\nrow[2] = 0;\r\ni2c_w(gspca_dev, row);\r\nreg_r(gspca_dev, 0x10c2, 5);\r\n*val = gspca_dev->usb_buf[4];\r\n}\r\nstatic void i2c_r2(struct gspca_dev *gspca_dev, u8 reg, u16 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 row[8];\r\nrow[0] = sd->i2c_intf | (1 << 4);\r\nrow[1] = sd->i2c_addr;\r\nrow[2] = reg;\r\nrow[3] = 0;\r\nrow[4] = 0;\r\nrow[5] = 0;\r\nrow[6] = 0;\r\nrow[7] = 0x10;\r\ni2c_w(gspca_dev, row);\r\nrow[0] = sd->i2c_intf | (2 << 4) | 0x02;\r\nrow[2] = 0;\r\ni2c_w(gspca_dev, row);\r\nreg_r(gspca_dev, 0x10c2, 5);\r\n*val = (gspca_dev->usb_buf[3] << 8) | gspca_dev->usb_buf[4];\r\n}\r\nstatic void ov9650_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nu16 id;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_r2(gspca_dev, 0x1c, &id);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (id != 0x7fa2) {\r\npr_err("sensor id for ov9650 doesn't match (0x%04x)\n", id);\r\ngspca_dev->usb_err = -ENODEV;\r\nreturn;\r\n}\r\ni2c_w1(gspca_dev, 0x12, 0x80);\r\nmsleep(200);\r\ni2c_w1_buf(gspca_dev, ov9650_init, ARRAY_SIZE(ov9650_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("OV9650 sensor initialization failed\n");\r\nsd->hstart = 1;\r\nsd->vstart = 7;\r\n}\r\nstatic void ov9655_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w1(gspca_dev, 0x12, 0x80);\r\nmsleep(200);\r\ni2c_w1_buf(gspca_dev, ov9655_init, ARRAY_SIZE(ov9655_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("OV9655 sensor initialization failed\n");\r\nsd->hstart = 1;\r\nsd->vstart = 2;\r\n}\r\nstatic void soi968_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w1(gspca_dev, 0x12, 0x80);\r\nmsleep(200);\r\ni2c_w1_buf(gspca_dev, soi968_init, ARRAY_SIZE(soi968_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("SOI968 sensor initialization failed\n");\r\nsd->hstart = 60;\r\nsd->vstart = 11;\r\n}\r\nstatic void ov7660_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w1(gspca_dev, 0x12, 0x80);\r\nmsleep(200);\r\ni2c_w1_buf(gspca_dev, ov7660_init, ARRAY_SIZE(ov7660_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("OV7660 sensor initialization failed\n");\r\nsd->hstart = 3;\r\nsd->vstart = 3;\r\n}\r\nstatic void ov7670_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w1(gspca_dev, 0x12, 0x80);\r\nmsleep(200);\r\ni2c_w1_buf(gspca_dev, ov7670_init, ARRAY_SIZE(ov7670_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("OV7670 sensor initialization failed\n");\r\nsd->hstart = 0;\r\nsd->vstart = 1;\r\n}\r\nstatic void mt9v_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 value;\r\nsd->i2c_addr = 0x5d;\r\ni2c_r2(gspca_dev, 0xff, &value);\r\nif (gspca_dev->usb_err >= 0\r\n&& value == 0x8243) {\r\ni2c_w2_buf(gspca_dev, mt9v011_init, ARRAY_SIZE(mt9v011_init));\r\nif (gspca_dev->usb_err < 0) {\r\npr_err("MT9V011 sensor initialization failed\n");\r\nreturn;\r\n}\r\nsd->hstart = 2;\r\nsd->vstart = 2;\r\nsd->sensor = SENSOR_MT9V011;\r\npr_info("MT9V011 sensor detected\n");\r\nreturn;\r\n}\r\ngspca_dev->usb_err = 0;\r\nsd->i2c_addr = 0x5c;\r\ni2c_w2(gspca_dev, 0x01, 0x0004);\r\ni2c_r2(gspca_dev, 0xff, &value);\r\nif (gspca_dev->usb_err >= 0\r\n&& value == 0x823a) {\r\ni2c_w2_buf(gspca_dev, mt9v111_init, ARRAY_SIZE(mt9v111_init));\r\nif (gspca_dev->usb_err < 0) {\r\npr_err("MT9V111 sensor initialization failed\n");\r\nreturn;\r\n}\r\nsd->hstart = 2;\r\nsd->vstart = 2;\r\nsd->sensor = SENSOR_MT9V111;\r\npr_info("MT9V111 sensor detected\n");\r\nreturn;\r\n}\r\ngspca_dev->usb_err = 0;\r\nsd->i2c_addr = 0x5d;\r\ni2c_w2(gspca_dev, 0xf0, 0x0000);\r\nif (gspca_dev->usb_err < 0) {\r\ngspca_dev->usb_err = 0;\r\nsd->i2c_addr = 0x48;\r\ni2c_w2(gspca_dev, 0xf0, 0x0000);\r\n}\r\ni2c_r2(gspca_dev, 0x00, &value);\r\nif (gspca_dev->usb_err >= 0\r\n&& value == 0x1229) {\r\ni2c_w2_buf(gspca_dev, mt9v112_init, ARRAY_SIZE(mt9v112_init));\r\nif (gspca_dev->usb_err < 0) {\r\npr_err("MT9V112 sensor initialization failed\n");\r\nreturn;\r\n}\r\nsd->hstart = 6;\r\nsd->vstart = 2;\r\nsd->sensor = SENSOR_MT9V112;\r\npr_info("MT9V112 sensor detected\n");\r\nreturn;\r\n}\r\ngspca_dev->usb_err = -ENODEV;\r\n}\r\nstatic void mt9m112_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w2_buf(gspca_dev, mt9m112_init, ARRAY_SIZE(mt9m112_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("MT9M112 sensor initialization failed\n");\r\nsd->hstart = 0;\r\nsd->vstart = 2;\r\n}\r\nstatic void mt9m111_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w2_buf(gspca_dev, mt9m111_init, ARRAY_SIZE(mt9m111_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("MT9M111 sensor initialization failed\n");\r\nsd->hstart = 0;\r\nsd->vstart = 2;\r\n}\r\nstatic void mt9m001_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 id;\r\ni2c_r2(gspca_dev, 0x00, &id);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nswitch (id) {\r\ncase 0x8411:\r\ncase 0x8421:\r\npr_info("MT9M001 color sensor detected\n");\r\nbreak;\r\ncase 0x8431:\r\npr_info("MT9M001 mono sensor detected\n");\r\nbreak;\r\ndefault:\r\npr_err("No MT9M001 chip detected, ID = %x\n\n", id);\r\ngspca_dev->usb_err = -ENODEV;\r\nreturn;\r\n}\r\ni2c_w2_buf(gspca_dev, mt9m001_init, ARRAY_SIZE(mt9m001_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("MT9M001 sensor initialization failed\n");\r\nsd->hstart = 1;\r\nsd->vstart = 1;\r\n}\r\nstatic void hv7131r_init_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w1_buf(gspca_dev, hv7131r_init, ARRAY_SIZE(hv7131r_init));\r\nif (gspca_dev->usb_err < 0)\r\npr_err("HV7131R Sensor initialization failed\n");\r\nsd->hstart = 0;\r\nsd->vstart = 1;\r\n}\r\nstatic void set_cmatrix(struct gspca_dev *gspca_dev,\r\ns32 brightness, s32 contrast, s32 satur, s32 hue)\r\n{\r\ns32 hue_coord, hue_index = 180 + hue;\r\nu8 cmatrix[21];\r\nmemset(cmatrix, 0, sizeof cmatrix);\r\ncmatrix[2] = (contrast * 0x25 / 0x100) + 0x26;\r\ncmatrix[0] = 0x13 + (cmatrix[2] - 0x26) * 0x13 / 0x25;\r\ncmatrix[4] = 0x07 + (cmatrix[2] - 0x26) * 0x07 / 0x25;\r\ncmatrix[18] = brightness - 0x80;\r\nhue_coord = (hsv_red_x[hue_index] * satur) >> 8;\r\ncmatrix[6] = hue_coord;\r\ncmatrix[7] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_red_y[hue_index] * satur) >> 8;\r\ncmatrix[8] = hue_coord;\r\ncmatrix[9] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_green_x[hue_index] * satur) >> 8;\r\ncmatrix[10] = hue_coord;\r\ncmatrix[11] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_green_y[hue_index] * satur) >> 8;\r\ncmatrix[12] = hue_coord;\r\ncmatrix[13] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_blue_x[hue_index] * satur) >> 8;\r\ncmatrix[14] = hue_coord;\r\ncmatrix[15] = (hue_coord >> 8) & 0x0f;\r\nhue_coord = (hsv_blue_y[hue_index] * satur) >> 8;\r\ncmatrix[16] = hue_coord;\r\ncmatrix[17] = (hue_coord >> 8) & 0x0f;\r\nreg_w(gspca_dev, 0x10e1, cmatrix, 21);\r\n}\r\nstatic void set_gamma(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu8 gamma[17];\r\nu8 gval = val * 0xb8 / 0x100;\r\ngamma[0] = 0x0a;\r\ngamma[1] = 0x13 + (gval * (0xcb - 0x13) / 0xb8);\r\ngamma[2] = 0x25 + (gval * (0xee - 0x25) / 0xb8);\r\ngamma[3] = 0x37 + (gval * (0xfa - 0x37) / 0xb8);\r\ngamma[4] = 0x45 + (gval * (0xfc - 0x45) / 0xb8);\r\ngamma[5] = 0x55 + (gval * (0xfb - 0x55) / 0xb8);\r\ngamma[6] = 0x65 + (gval * (0xfc - 0x65) / 0xb8);\r\ngamma[7] = 0x74 + (gval * (0xfd - 0x74) / 0xb8);\r\ngamma[8] = 0x83 + (gval * (0xfe - 0x83) / 0xb8);\r\ngamma[9] = 0x92 + (gval * (0xfc - 0x92) / 0xb8);\r\ngamma[10] = 0xa1 + (gval * (0xfc - 0xa1) / 0xb8);\r\ngamma[11] = 0xb0 + (gval * (0xfc - 0xb0) / 0xb8);\r\ngamma[12] = 0xbf + (gval * (0xfb - 0xbf) / 0xb8);\r\ngamma[13] = 0xce + (gval * (0xfb - 0xce) / 0xb8);\r\ngamma[14] = 0xdf + (gval * (0xfd - 0xdf) / 0xb8);\r\ngamma[15] = 0xea + (gval * (0xf9 - 0xea) / 0xb8);\r\ngamma[16] = 0xf5;\r\nreg_w(gspca_dev, 0x1190, gamma, 17);\r\n}\r\nstatic void set_redblue(struct gspca_dev *gspca_dev, s32 blue, s32 red)\r\n{\r\nreg_w1(gspca_dev, 0x118c, red);\r\nreg_w1(gspca_dev, 0x118f, blue);\r\n}\r\nstatic void set_hvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\r\n{\r\nu8 value, tslb;\r\nu16 value2;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif ((sd->flags & FLIP_DETECT) && dmi_check_system(flip_dmi_table)) {\r\nhflip = !hflip;\r\nvflip = !vflip;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7660:\r\nvalue = 0x01;\r\nif (hflip)\r\nvalue |= 0x20;\r\nif (vflip) {\r\nvalue |= 0x10;\r\nsd->vstart = 2;\r\n} else {\r\nsd->vstart = 3;\r\n}\r\nreg_w1(gspca_dev, 0x1182, sd->vstart);\r\ni2c_w1(gspca_dev, 0x1e, value);\r\nbreak;\r\ncase SENSOR_OV9650:\r\ni2c_r1(gspca_dev, 0x1e, &value);\r\nvalue &= ~0x30;\r\ntslb = 0x01;\r\nif (hflip)\r\nvalue |= 0x20;\r\nif (vflip) {\r\nvalue |= 0x10;\r\ntslb = 0x49;\r\n}\r\ni2c_w1(gspca_dev, 0x1e, value);\r\ni2c_w1(gspca_dev, 0x3a, tslb);\r\nbreak;\r\ncase SENSOR_MT9V111:\r\ncase SENSOR_MT9V011:\r\ni2c_r2(gspca_dev, 0x20, &value2);\r\nvalue2 &= ~0xc0a0;\r\nif (hflip)\r\nvalue2 |= 0x8080;\r\nif (vflip)\r\nvalue2 |= 0x4020;\r\ni2c_w2(gspca_dev, 0x20, value2);\r\nbreak;\r\ncase SENSOR_MT9M112:\r\ncase SENSOR_MT9M111:\r\ncase SENSOR_MT9V112:\r\ni2c_r2(gspca_dev, 0x20, &value2);\r\nvalue2 &= ~0x0003;\r\nif (hflip)\r\nvalue2 |= 0x0002;\r\nif (vflip)\r\nvalue2 |= 0x0001;\r\ni2c_w2(gspca_dev, 0x20, value2);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ni2c_r1(gspca_dev, 0x01, &value);\r\nvalue &= ~0x03;\r\nif (vflip)\r\nvalue |= 0x01;\r\nif (hflip)\r\nvalue |= 0x02;\r\ni2c_w1(gspca_dev, 0x01, value);\r\nbreak;\r\n}\r\n}\r\nstatic void set_exposure(struct gspca_dev *gspca_dev, s32 expo)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 exp[8] = {sd->i2c_intf, sd->i2c_addr,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x10};\r\nint expo2;\r\nif (gspca_dev->streaming)\r\nexp[7] = 0x1e;\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7660:\r\ncase SENSOR_OV7670:\r\ncase SENSOR_OV9655:\r\ncase SENSOR_OV9650:\r\nif (expo > 547)\r\nexpo2 = 547;\r\nelse\r\nexpo2 = expo;\r\nexp[0] |= (2 << 4);\r\nexp[2] = 0x10;\r\nexp[3] = expo2 >> 2;\r\nexp[7] = 0x10;\r\ni2c_w(gspca_dev, exp);\r\nexp[2] = 0x04;\r\nexp[3] = expo2 & 0x0003;\r\nexp[7] = 0x10;\r\ni2c_w(gspca_dev, exp);\r\nexpo -= expo2;\r\nexp[7] = 0x1e;\r\nexp[0] |= (3 << 4);\r\nexp[2] = 0x2d;\r\nexp[3] = expo;\r\nexp[4] = expo >> 8;\r\nbreak;\r\ncase SENSOR_MT9M001:\r\ncase SENSOR_MT9V112:\r\ncase SENSOR_MT9V011:\r\nexp[0] |= (3 << 4);\r\nexp[2] = 0x09;\r\nexp[3] = expo >> 8;\r\nexp[4] = expo;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nexp[0] |= (4 << 4);\r\nexp[2] = 0x25;\r\nexp[3] = expo >> 5;\r\nexp[4] = expo << 3;\r\nexp[5] = 0;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ni2c_w(gspca_dev, exp);\r\n}\r\nstatic void set_gain(struct gspca_dev *gspca_dev, s32 g)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 gain[8] = {sd->i2c_intf, sd->i2c_addr,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x10};\r\nif (gspca_dev->streaming)\r\ngain[7] = 0x15;\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7660:\r\ncase SENSOR_OV7670:\r\ncase SENSOR_SOI968:\r\ncase SENSOR_OV9655:\r\ncase SENSOR_OV9650:\r\ngain[0] |= (2 << 4);\r\ngain[3] = ov_gain[g];\r\nbreak;\r\ncase SENSOR_MT9V011:\r\ngain[0] |= (3 << 4);\r\ngain[2] = 0x35;\r\ngain[3] = micron1_gain[g] >> 8;\r\ngain[4] = micron1_gain[g];\r\nbreak;\r\ncase SENSOR_MT9V112:\r\ngain[0] |= (3 << 4);\r\ngain[2] = 0x2f;\r\ngain[3] = micron1_gain[g] >> 8;\r\ngain[4] = micron1_gain[g];\r\nbreak;\r\ncase SENSOR_MT9M001:\r\ngain[0] |= (3 << 4);\r\ngain[2] = 0x2f;\r\ngain[3] = micron2_gain[g] >> 8;\r\ngain[4] = micron2_gain[g];\r\nbreak;\r\ncase SENSOR_HV7131R:\r\ngain[0] |= (2 << 4);\r\ngain[2] = 0x30;\r\ngain[3] = hv7131r_gain[g];\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ni2c_w(gspca_dev, gain);\r\n}\r\nstatic void set_quality(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\njpeg_set_qual(sd->jpeg_hdr, val);\r\nreg_w1(gspca_dev, 0x1061, 0x01);\r\nreg_w1(gspca_dev, 0x10e0, sd->fmt | 0x20);\r\nreg_w(gspca_dev, 0x1100, &sd->jpeg_hdr[JPEG_QT0_OFFSET], 64);\r\nreg_w(gspca_dev, 0x1140, &sd->jpeg_hdr[JPEG_QT1_OFFSET], 64);\r\nreg_w1(gspca_dev, 0x1061, 0x03);\r\nreg_w1(gspca_dev, 0x10e0, sd->fmt);\r\nsd->fmt ^= 0x0c;\r\nreg_w1(gspca_dev, 0x10e0, sd->fmt);\r\n}\r\nstatic int sd_dbg_g_register(struct gspca_dev *gspca_dev,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\nif (reg->match.addr != 0)\r\nreturn -EINVAL;\r\nif (reg->reg < 0x1000 || reg->reg > 0x11ff)\r\nreturn -EINVAL;\r\nreg_r(gspca_dev, reg->reg, 1);\r\nreg->val = gspca_dev->usb_buf[0];\r\nreturn gspca_dev->usb_err;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nif (reg->match.addr != sd->i2c_addr)\r\nreturn -EINVAL;\r\nif (sd->sensor >= SENSOR_MT9V011 &&\r\nsd->sensor <= SENSOR_MT9M112) {\r\ni2c_r2(gspca_dev, reg->reg, (u16 *) &reg->val);\r\n} else {\r\ni2c_r1(gspca_dev, reg->reg, (u8 *) &reg->val);\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_dbg_s_register(struct gspca_dev *gspca_dev,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\nif (reg->match.addr != 0)\r\nreturn -EINVAL;\r\nif (reg->reg < 0x1000 || reg->reg > 0x11ff)\r\nreturn -EINVAL;\r\nreg_w1(gspca_dev, reg->reg, reg->val);\r\nreturn gspca_dev->usb_err;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nif (reg->match.addr != sd->i2c_addr)\r\nreturn -EINVAL;\r\nif (sd->sensor >= SENSOR_MT9V011 &&\r\nsd->sensor <= SENSOR_MT9M112) {\r\ni2c_w2(gspca_dev, reg->reg, reg->val);\r\n} else {\r\ni2c_w1(gspca_dev, reg->reg, reg->val);\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_chip_ident(struct gspca_dev *gspca_dev,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (chip->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\nif (chip->match.addr != 0)\r\nreturn -EINVAL;\r\nchip->revision = 0;\r\nchip->ident = V4L2_IDENT_SN9C20X;\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nif (chip->match.addr != sd->i2c_addr)\r\nreturn -EINVAL;\r\nchip->revision = 0;\r\nchip->ident = i2c_ident[sd->sensor];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\ncam->needs_full_bandwidth = 1;\r\nsd->sensor = id->driver_info >> 8;\r\nsd->i2c_addr = id->driver_info;\r\nsd->flags = id->driver_info >> 16;\r\nsd->i2c_intf = 0x80;\r\nswitch (sd->sensor) {\r\ncase SENSOR_MT9M112:\r\ncase SENSOR_MT9M111:\r\ncase SENSOR_OV9650:\r\ncase SENSOR_SOI968:\r\ncam->cam_mode = sxga_mode;\r\ncam->nmodes = ARRAY_SIZE(sxga_mode);\r\nbreak;\r\ncase SENSOR_MT9M001:\r\ncam->cam_mode = mono_mode;\r\ncam->nmodes = ARRAY_SIZE(mono_mode);\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nsd->i2c_intf = 0x81;\r\ndefault:\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nbreak;\r\n}\r\nsd->old_step = 0;\r\nsd->older_step = 0;\r\nsd->exposure_step = 16;\r\nINIT_WORK(&sd->work, qual_upd);\r\nreturn 0;\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nset_cmatrix(gspca_dev, sd->brightness->val,\r\nsd->contrast->val, sd->saturation->val, sd->hue->val);\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nset_gamma(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nset_redblue(gspca_dev, sd->blue->val, sd->red->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nset_hvflip(gspca_dev, sd->hflip->val, sd->vflip->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nset_exposure(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nset_gain(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nif (sd->sensor == SENSOR_SOI968)\r\nset_gain(gspca_dev, sd->gain->val);\r\nelse\r\nset_exposure(gspca_dev, sd->exposure->val);\r\nbreak;\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY:\r\nset_quality(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 13);\r\nsd->brightness = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\r\nsd->contrast = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 127);\r\nsd->saturation = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 127);\r\nsd->hue = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HUE, -180, 180, 1, 0);\r\nsd->gamma = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAMMA, 0, 255, 1, 0x10);\r\nsd->blue = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, 0, 127, 1, 0x28);\r\nsd->red = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, 0, 127, 1, 0x28);\r\nif (sd->sensor != SENSOR_OV9655 && sd->sensor != SENSOR_SOI968 &&\r\nsd->sensor != SENSOR_OV7670 && sd->sensor != SENSOR_MT9M001 &&\r\nsd->sensor != SENSOR_MT9VPRB) {\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\n}\r\nif (sd->sensor != SENSOR_SOI968 && sd->sensor != SENSOR_MT9VPRB &&\r\nsd->sensor != SENSOR_MT9M112 && sd->sensor != SENSOR_MT9M111 &&\r\nsd->sensor != SENSOR_MT9V111)\r\nsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 0x1780, 1, 0x33);\r\nif (sd->sensor != SENSOR_MT9VPRB && sd->sensor != SENSOR_MT9M112 &&\r\nsd->sensor != SENSOR_MT9M111 && sd->sensor != SENSOR_MT9V111) {\r\nsd->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 28, 1, 0);\r\nsd->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\n}\r\nsd->jpegqual = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_JPEG_COMPRESSION_QUALITY, 50, 90, 1, 80);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_cluster(4, &sd->brightness);\r\nv4l2_ctrl_cluster(2, &sd->blue);\r\nif (sd->hflip)\r\nv4l2_ctrl_cluster(2, &sd->hflip);\r\nif (sd->autogain) {\r\nif (sd->sensor == SENSOR_SOI968)\r\nv4l2_ctrl_auto_cluster(3, &sd->autogain, 0, false);\r\nelse\r\nv4l2_ctrl_auto_cluster(2, &sd->autogain, 0, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nu8 value;\r\nu8 i2c_init[9] =\r\n{0x80, sd->i2c_addr, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03};\r\nfor (i = 0; i < ARRAY_SIZE(bridge_init); i++) {\r\nvalue = bridge_init[i][1];\r\nreg_w(gspca_dev, bridge_init[i][0], &value, 1);\r\nif (gspca_dev->usb_err < 0) {\r\npr_err("Device initialization failed\n");\r\nreturn gspca_dev->usb_err;\r\n}\r\n}\r\nif (sd->flags & LED_REVERSE)\r\nreg_w1(gspca_dev, 0x1006, 0x00);\r\nelse\r\nreg_w1(gspca_dev, 0x1006, 0x20);\r\nreg_w(gspca_dev, 0x10c0, i2c_init, 9);\r\nif (gspca_dev->usb_err < 0) {\r\npr_err("Device initialization failed\n");\r\nreturn gspca_dev->usb_err;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV9650:\r\nov9650_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("OV9650 sensor detected\n");\r\nbreak;\r\ncase SENSOR_OV9655:\r\nov9655_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("OV9655 sensor detected\n");\r\nbreak;\r\ncase SENSOR_SOI968:\r\nsoi968_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("SOI968 sensor detected\n");\r\nbreak;\r\ncase SENSOR_OV7660:\r\nov7660_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("OV7660 sensor detected\n");\r\nbreak;\r\ncase SENSOR_OV7670:\r\nov7670_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("OV7670 sensor detected\n");\r\nbreak;\r\ncase SENSOR_MT9VPRB:\r\nmt9v_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("MT9VPRB sensor detected\n");\r\nbreak;\r\ncase SENSOR_MT9M111:\r\nmt9m111_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("MT9M111 sensor detected\n");\r\nbreak;\r\ncase SENSOR_MT9M112:\r\nmt9m112_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("MT9M112 sensor detected\n");\r\nbreak;\r\ncase SENSOR_MT9M001:\r\nmt9m001_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\nbreak;\r\ncase SENSOR_HV7131R:\r\nhv7131r_init_sensor(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nbreak;\r\npr_info("HV7131R sensor detected\n");\r\nbreak;\r\ndefault:\r\npr_err("Unsupported sensor\n");\r\ngspca_dev->usb_err = -ENODEV;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void configure_sensor_output(struct gspca_dev *gspca_dev, int mode)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 value;\r\nswitch (sd->sensor) {\r\ncase SENSOR_SOI968:\r\nif (mode & MODE_SXGA) {\r\ni2c_w1(gspca_dev, 0x17, 0x1d);\r\ni2c_w1(gspca_dev, 0x18, 0xbd);\r\ni2c_w1(gspca_dev, 0x19, 0x01);\r\ni2c_w1(gspca_dev, 0x1a, 0x81);\r\ni2c_w1(gspca_dev, 0x12, 0x00);\r\nsd->hstart = 140;\r\nsd->vstart = 19;\r\n} else {\r\ni2c_w1(gspca_dev, 0x17, 0x13);\r\ni2c_w1(gspca_dev, 0x18, 0x63);\r\ni2c_w1(gspca_dev, 0x19, 0x01);\r\ni2c_w1(gspca_dev, 0x1a, 0x79);\r\ni2c_w1(gspca_dev, 0x12, 0x40);\r\nsd->hstart = 60;\r\nsd->vstart = 11;\r\n}\r\nbreak;\r\ncase SENSOR_OV9650:\r\nif (mode & MODE_SXGA) {\r\ni2c_w1(gspca_dev, 0x17, 0x1b);\r\ni2c_w1(gspca_dev, 0x18, 0xbc);\r\ni2c_w1(gspca_dev, 0x19, 0x01);\r\ni2c_w1(gspca_dev, 0x1a, 0x82);\r\ni2c_r1(gspca_dev, 0x12, &value);\r\ni2c_w1(gspca_dev, 0x12, value & 0x07);\r\n} else {\r\ni2c_w1(gspca_dev, 0x17, 0x24);\r\ni2c_w1(gspca_dev, 0x18, 0xc5);\r\ni2c_w1(gspca_dev, 0x19, 0x00);\r\ni2c_w1(gspca_dev, 0x1a, 0x3c);\r\ni2c_r1(gspca_dev, 0x12, &value);\r\ni2c_w1(gspca_dev, 0x12, (value & 0x7) | 0x40);\r\n}\r\nbreak;\r\ncase SENSOR_MT9M112:\r\ncase SENSOR_MT9M111:\r\nif (mode & MODE_SXGA) {\r\ni2c_w2(gspca_dev, 0xf0, 0x0002);\r\ni2c_w2(gspca_dev, 0xc8, 0x970b);\r\ni2c_w2(gspca_dev, 0xf0, 0x0000);\r\n} else {\r\ni2c_w2(gspca_dev, 0xf0, 0x0002);\r\ni2c_w2(gspca_dev, 0xc8, 0x8000);\r\ni2c_w2(gspca_dev, 0xf0, 0x0000);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_interface *intf;\r\nu32 flags = gspca_dev->cam.cam_mode[(int)gspca_dev->curr_mode].priv;\r\nif (!(flags & (MODE_RAW | MODE_JPEG))) {\r\nintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\r\nif (intf->num_altsetting != 9) {\r\npr_warn("sn9c20x camera with unknown number of alt "\r\n"settings (%d), please report!\n",\r\nintf->num_altsetting);\r\ngspca_dev->alt = intf->num_altsetting;\r\nreturn 0;\r\n}\r\nswitch (gspca_dev->width) {\r\ncase 160:\r\ngspca_dev->alt = 2;\r\nbreak;\r\ncase 320:\r\ngspca_dev->alt = 6;\r\nbreak;\r\ndefault:\r\ngspca_dev->alt = 9;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint mode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\r\nint width = gspca_dev->width;\r\nint height = gspca_dev->height;\r\nu8 fmt, scale = 0;\r\njpeg_define(sd->jpeg_hdr, height, width,\r\n0x21);\r\njpeg_set_qual(sd->jpeg_hdr, v4l2_ctrl_g_ctrl(sd->jpegqual));\r\nif (mode & MODE_RAW)\r\nfmt = 0x2d;\r\nelse if (mode & MODE_JPEG)\r\nfmt = 0x24;\r\nelse\r\nfmt = 0x2f;\r\nsd->fmt = fmt;\r\nswitch (mode & SCALE_MASK) {\r\ncase SCALE_1280x1024:\r\nscale = 0xc0;\r\npr_info("Set 1280x1024\n");\r\nbreak;\r\ncase SCALE_640x480:\r\nscale = 0x80;\r\npr_info("Set 640x480\n");\r\nbreak;\r\ncase SCALE_320x240:\r\nscale = 0x90;\r\npr_info("Set 320x240\n");\r\nbreak;\r\ncase SCALE_160x120:\r\nscale = 0xa0;\r\npr_info("Set 160x120\n");\r\nbreak;\r\n}\r\nconfigure_sensor_output(gspca_dev, mode);\r\nreg_w(gspca_dev, 0x1100, &sd->jpeg_hdr[JPEG_QT0_OFFSET], 64);\r\nreg_w(gspca_dev, 0x1140, &sd->jpeg_hdr[JPEG_QT1_OFFSET], 64);\r\nreg_w(gspca_dev, 0x10fb, CLR_WIN(width, height), 5);\r\nreg_w(gspca_dev, 0x1180, HW_WIN(mode, sd->hstart, sd->vstart), 6);\r\nreg_w1(gspca_dev, 0x1189, scale);\r\nreg_w1(gspca_dev, 0x10e0, fmt);\r\nset_cmatrix(gspca_dev, v4l2_ctrl_g_ctrl(sd->brightness),\r\nv4l2_ctrl_g_ctrl(sd->contrast),\r\nv4l2_ctrl_g_ctrl(sd->saturation),\r\nv4l2_ctrl_g_ctrl(sd->hue));\r\nset_gamma(gspca_dev, v4l2_ctrl_g_ctrl(sd->gamma));\r\nset_redblue(gspca_dev, v4l2_ctrl_g_ctrl(sd->blue),\r\nv4l2_ctrl_g_ctrl(sd->red));\r\nif (sd->gain)\r\nset_gain(gspca_dev, v4l2_ctrl_g_ctrl(sd->gain));\r\nif (sd->exposure)\r\nset_exposure(gspca_dev, v4l2_ctrl_g_ctrl(sd->exposure));\r\nif (sd->hflip)\r\nset_hvflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->hflip),\r\nv4l2_ctrl_g_ctrl(sd->vflip));\r\nreg_w1(gspca_dev, 0x1007, 0x20);\r\nreg_w1(gspca_dev, 0x1061, 0x03);\r\nif (mode & MODE_JPEG) {\r\nsd->pktsz = sd->npkt = 0;\r\nsd->nchg = 0;\r\nsd->work_thread =\r\ncreate_singlethread_workqueue(KBUILD_MODNAME);\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w1(gspca_dev, 0x1007, 0x00);\r\nreg_w1(gspca_dev, 0x1061, 0x01);\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->work_thread != NULL) {\r\nmutex_unlock(&gspca_dev->usb_lock);\r\ndestroy_workqueue(sd->work_thread);\r\nmutex_lock(&gspca_dev->usb_lock);\r\nsd->work_thread = NULL;\r\n}\r\n}\r\nstatic void do_autoexposure(struct gspca_dev *gspca_dev, u16 avg_lum)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 cur_exp = v4l2_ctrl_g_ctrl(sd->exposure);\r\ns32 max = sd->exposure->maximum - sd->exposure_step;\r\ns32 min = sd->exposure->minimum + sd->exposure_step;\r\ns16 new_exp;\r\nif (avg_lum < MIN_AVG_LUM) {\r\nif (cur_exp > max)\r\nreturn;\r\nnew_exp = cur_exp + sd->exposure_step;\r\nif (new_exp > max)\r\nnew_exp = max;\r\nif (new_exp < min)\r\nnew_exp = min;\r\nv4l2_ctrl_s_ctrl(sd->exposure, new_exp);\r\nsd->older_step = sd->old_step;\r\nsd->old_step = 1;\r\nif (sd->old_step ^ sd->older_step)\r\nsd->exposure_step /= 2;\r\nelse\r\nsd->exposure_step += 2;\r\n}\r\nif (avg_lum > MAX_AVG_LUM) {\r\nif (cur_exp < min)\r\nreturn;\r\nnew_exp = cur_exp - sd->exposure_step;\r\nif (new_exp > max)\r\nnew_exp = max;\r\nif (new_exp < min)\r\nnew_exp = min;\r\nv4l2_ctrl_s_ctrl(sd->exposure, new_exp);\r\nsd->older_step = sd->old_step;\r\nsd->old_step = 0;\r\nif (sd->old_step ^ sd->older_step)\r\nsd->exposure_step /= 2;\r\nelse\r\nsd->exposure_step += 2;\r\n}\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev, u16 avg_lum)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 cur_gain = v4l2_ctrl_g_ctrl(sd->gain);\r\nif (avg_lum < MIN_AVG_LUM && cur_gain < sd->gain->maximum)\r\nv4l2_ctrl_s_ctrl(sd->gain, cur_gain + 1);\r\nif (avg_lum > MAX_AVG_LUM && cur_gain > sd->gain->minimum)\r\nv4l2_ctrl_s_ctrl(sd->gain, cur_gain - 1);\r\n}\r\nstatic void sd_dqcallback(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum;\r\nif (sd->autogain == NULL || !v4l2_ctrl_g_ctrl(sd->autogain))\r\nreturn;\r\navg_lum = atomic_read(&sd->avg_lum);\r\nif (sd->sensor == SENSOR_SOI968)\r\ndo_autogain(gspca_dev, avg_lum);\r\nelse\r\ndo_autoexposure(gspca_dev, avg_lum);\r\n}\r\nstatic void qual_upd(struct work_struct *work)\r\n{\r\nstruct sd *sd = container_of(work, struct sd, work);\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\ns32 qual = v4l2_ctrl_g_ctrl(sd->jpegqual);\r\nmutex_lock(&gspca_dev->usb_lock);\r\nPDEBUG(D_STREAM, "qual_upd %d%%", qual);\r\nset_quality(gspca_dev, qual);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!(sd->flags & HAS_NO_BUTTON) && len == 1) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void transfer_check(struct gspca_dev *gspca_dev,\r\nu8 *data)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint new_qual, r;\r\nnew_qual = 0;\r\nif (data[6] & 0x08) {\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nnew_qual = -5;\r\n} else {\r\nr = (sd->pktsz * 100) /\r\n(sd->npkt *\r\ngspca_dev->urb[0]->iso_frame_desc[0].length);\r\nif (r >= 85)\r\nnew_qual = -3;\r\nelse if (r < 75)\r\nnew_qual = 2;\r\n}\r\nif (new_qual != 0) {\r\nsd->nchg += new_qual;\r\nif (sd->nchg < -6 || sd->nchg >= 12) {\r\ns32 curqual = sd->jpegqual->cur.val;\r\nsd->nchg = 0;\r\nnew_qual += curqual;\r\nif (new_qual < sd->jpegqual->minimum)\r\nnew_qual = sd->jpegqual->minimum;\r\nelse if (new_qual > sd->jpegqual->maximum)\r\nnew_qual = sd->jpegqual->maximum;\r\nif (new_qual != curqual) {\r\nsd->jpegqual->cur.val = new_qual;\r\nqueue_work(sd->work_thread, &sd->work);\r\n}\r\n}\r\n} else {\r\nsd->nchg = 0;\r\n}\r\nsd->pktsz = sd->npkt = 0;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum, is_jpeg;\r\nstatic const u8 frame_header[] =\r\n{0xff, 0xff, 0x00, 0xc4, 0xc4, 0x96};\r\nis_jpeg = (sd->fmt & 0x03) == 0;\r\nif (len >= 64 && memcmp(data, frame_header, 6) == 0) {\r\navg_lum = ((data[35] >> 2) & 3) |\r\n(data[20] << 2) |\r\n(data[19] << 10);\r\navg_lum += ((data[35] >> 4) & 3) |\r\n(data[22] << 2) |\r\n(data[21] << 10);\r\navg_lum += ((data[35] >> 6) & 3) |\r\n(data[24] << 2) |\r\n(data[23] << 10);\r\navg_lum += (data[36] & 3) |\r\n(data[26] << 2) |\r\n(data[25] << 10);\r\navg_lum += ((data[36] >> 2) & 3) |\r\n(data[28] << 2) |\r\n(data[27] << 10);\r\navg_lum += ((data[36] >> 4) & 3) |\r\n(data[30] << 2) |\r\n(data[29] << 10);\r\navg_lum += ((data[36] >> 6) & 3) |\r\n(data[32] << 2) |\r\n(data[31] << 10);\r\navg_lum += ((data[44] >> 4) & 3) |\r\n(data[34] << 2) |\r\n(data[33] << 10);\r\navg_lum >>= 9;\r\natomic_set(&sd->avg_lum, avg_lum);\r\nif (is_jpeg)\r\ntransfer_check(gspca_dev, data);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\nlen -= 64;\r\nif (len == 0)\r\nreturn;\r\ndata += 64;\r\n}\r\nif (gspca_dev->last_packet_type == LAST_PACKET) {\r\nif (is_jpeg) {\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, len);\r\n} else {\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\ndata, len);\r\n}\r\n} else {\r\nif (is_jpeg) {\r\nsd->npkt++;\r\nsd->pktsz += len;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
