static irqreturn_t action_button_handler(int irq, void *dev_id)\r\n{\r\nint down = (GPLR & GPIO_BITSY_ACTION_BUTTON) ? 0 : 1;\r\nstruct input_dev *dev = dev_id;\r\ninput_report_key(dev, KEY_ENTER, down);\r\ninput_sync(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t npower_button_handler(int irq, void *dev_id)\r\n{\r\nint down = (GPLR & GPIO_BITSY_NPOWER_BUTTON) ? 0 : 1;\r\nstruct input_dev *dev = dev_id;\r\ninput_report_key(dev, KEY_SUSPEND, 1);\r\ninput_report_key(dev, KEY_SUSPEND, down);\r\ninput_sync(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nunsigned int h3600_flite_power(struct input_dev *dev, enum flite_pwr pwr)\r\n{\r\nunsigned char brightness = (pwr == FLITE_PWR_OFF) ? 0 : flite_brightness;\r\nstruct h3600_dev *ts = input_get_drvdata(dev);\r\nserio_write(ts->serio, 1);\r\nserio_write(ts->serio, pwr);\r\nserio_write(ts->serio, brightness);\r\nreturn 0;\r\n}\r\nstatic void h3600ts_process_packet(struct h3600_dev *ts)\r\n{\r\nstruct input_dev *dev = ts->dev;\r\nstatic int touched = 0;\r\nint key, down = 0;\r\nswitch (ts->event) {\r\ncase KEYBD_ID:\r\ndown = (ts->buf[0] & 0x80) ? 0 : 1;\r\nswitch (ts->buf[0] & 0x7f) {\r\ncase H3600_SCANCODE_RECORD:\r\nkey = KEY_RECORD;\r\nbreak;\r\ncase H3600_SCANCODE_CALENDAR:\r\nkey = KEY_PROG1;\r\nbreak;\r\ncase H3600_SCANCODE_CONTACTS:\r\nkey = KEY_PROG2;\r\nbreak;\r\ncase H3600_SCANCODE_Q:\r\nkey = KEY_Q;\r\nbreak;\r\ncase H3600_SCANCODE_START:\r\nkey = KEY_PROG3;\r\nbreak;\r\ncase H3600_SCANCODE_UP:\r\nkey = KEY_UP;\r\nbreak;\r\ncase H3600_SCANCODE_RIGHT:\r\nkey = KEY_RIGHT;\r\nbreak;\r\ncase H3600_SCANCODE_LEFT:\r\nkey = KEY_LEFT;\r\nbreak;\r\ncase H3600_SCANCODE_DOWN:\r\nkey = KEY_DOWN;\r\nbreak;\r\ndefault:\r\nkey = 0;\r\n}\r\nif (key)\r\ninput_report_key(dev, key, down);\r\nbreak;\r\ncase TOUCHS_ID:\r\nif (!touched) {\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\ntouched = 1;\r\n}\r\nif (ts->len) {\r\nunsigned short x, y;\r\nx = ts->buf[0]; x <<= 8; x += ts->buf[1];\r\ny = ts->buf[2]; y <<= 8; y += ts->buf[3];\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n} else {\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\ntouched = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic int h3600ts_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\n#if 0\r\nstruct h3600_dev *ts = input_get_drvdata(dev);\r\nswitch (type) {\r\ncase EV_LED: {\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic irqreturn_t h3600ts_interrupt(struct serio *serio, unsigned char data,\r\nunsigned int flags)\r\n{\r\nstruct h3600_dev *ts = serio_get_drvdata(serio);\r\nswitch (state) {\r\ncase STATE_SOF:\r\nif (data == CHAR_SOF)\r\nstate = STATE_ID;\r\nbreak;\r\ncase STATE_ID:\r\nts->event = (data & 0xf0) >> 4;\r\nts->len = (data & 0xf);\r\nts->idx = 0;\r\nif (ts->event >= MAX_ID) {\r\nstate = STATE_SOF;\r\nbreak;\r\n}\r\nts->chksum = data;\r\nstate = (ts->len > 0) ? STATE_DATA : STATE_EOF;\r\nbreak;\r\ncase STATE_DATA:\r\nts->chksum += data;\r\nts->buf[ts->idx]= data;\r\nif (++ts->idx == ts->len)\r\nstate = STATE_EOF;\r\nbreak;\r\ncase STATE_EOF:\r\nstate = STATE_SOF;\r\nif (data == CHAR_EOF || data == ts->chksum)\r\nh3600ts_process_packet(ts);\r\nbreak;\r\ndefault:\r\nprintk("Error3\n");\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int h3600ts_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct h3600_dev *ts;\r\nstruct input_dev *input_dev;\r\nint err;\r\nts = kzalloc(sizeof(struct h3600_dev), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nts->serio = serio;\r\nts->dev = input_dev;\r\nsnprintf(ts->phys, sizeof(ts->phys), "%s/input0", serio->phys);\r\ninput_dev->name = "H3600 TouchScreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_H3600;\r\ninput_dev->id.product = 0x0666;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_set_drvdata(input_dev, ts);\r\ninput_dev->event = h3600ts_event;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) |\r\nBIT_MASK(EV_LED) | BIT_MASK(EV_PWR);\r\ninput_dev->ledbit[0] = BIT_MASK(LED_SLEEP);\r\ninput_set_abs_params(input_dev, ABS_X, 60, 985, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 35, 1024, 0, 0);\r\nset_bit(KEY_RECORD, input_dev->keybit);\r\nset_bit(KEY_Q, input_dev->keybit);\r\nset_bit(KEY_PROG1, input_dev->keybit);\r\nset_bit(KEY_PROG2, input_dev->keybit);\r\nset_bit(KEY_PROG3, input_dev->keybit);\r\nset_bit(KEY_UP, input_dev->keybit);\r\nset_bit(KEY_RIGHT, input_dev->keybit);\r\nset_bit(KEY_LEFT, input_dev->keybit);\r\nset_bit(KEY_DOWN, input_dev->keybit);\r\nset_bit(KEY_ENTER, input_dev->keybit);\r\nset_bit(KEY_SUSPEND, input_dev->keybit);\r\nset_bit(BTN_TOUCH, input_dev->keybit);\r\nset_GPIO_IRQ_edge(GPIO_BITSY_ACTION_BUTTON, GPIO_BOTH_EDGES);\r\nset_GPIO_IRQ_edge(GPIO_BITSY_NPOWER_BUTTON, GPIO_RISING_EDGE);\r\nif (request_irq(IRQ_GPIO_BITSY_ACTION_BUTTON, action_button_handler,\r\nIRQF_SHARED, "h3600_action", ts->dev)) {\r\nprintk(KERN_ERR "h3600ts.c: Could not allocate Action Button IRQ!\n");\r\nerr = -EBUSY;\r\ngoto fail1;\r\n}\r\nif (request_irq(IRQ_GPIO_BITSY_NPOWER_BUTTON, npower_button_handler,\r\nIRQF_SHARED, "h3600_suspend", ts->dev)) {\r\nprintk(KERN_ERR "h3600ts.c: Could not allocate Power Button IRQ!\n");\r\nerr = -EBUSY;\r\ngoto fail2;\r\n}\r\nserio_set_drvdata(serio, ts);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail3;\r\nerr = input_register_device(ts->dev);\r\nif (err)\r\ngoto fail4;\r\nreturn 0;\r\nfail4: serio_close(serio);\r\nfail3: serio_set_drvdata(serio, NULL);\r\nfree_irq(IRQ_GPIO_BITSY_NPOWER_BUTTON, ts->dev);\r\nfail2: free_irq(IRQ_GPIO_BITSY_ACTION_BUTTON, ts->dev);\r\nfail1: input_free_device(input_dev);\r\nkfree(ts);\r\nreturn err;\r\n}\r\nstatic void h3600ts_disconnect(struct serio *serio)\r\n{\r\nstruct h3600_dev *ts = serio_get_drvdata(serio);\r\nfree_irq(IRQ_GPIO_BITSY_ACTION_BUTTON, ts->dev);\r\nfree_irq(IRQ_GPIO_BITSY_NPOWER_BUTTON, ts->dev);\r\ninput_get_device(ts->dev);\r\ninput_unregister_device(ts->dev);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_put_device(ts->dev);\r\nkfree(ts);\r\n}
