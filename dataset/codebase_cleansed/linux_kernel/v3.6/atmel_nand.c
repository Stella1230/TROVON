static int cpu_has_dma(void)\r\n{\r\nreturn cpu_is_at91sam9rl() || cpu_is_at91sam9g45();\r\n}\r\nstatic void atmel_nand_enable(struct atmel_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->board.enable_pin))\r\ngpio_set_value(host->board.enable_pin, 0);\r\n}\r\nstatic void atmel_nand_disable(struct atmel_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->board.enable_pin))\r\ngpio_set_value(host->board.enable_pin, 1);\r\n}\r\nstatic void atmel_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif (ctrl & NAND_NCE)\r\natmel_nand_enable(host);\r\nelse\r\natmel_nand_disable(host);\r\n}\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, host->io_base + (1 << host->board.cle));\r\nelse\r\nwriteb(cmd, host->io_base + (1 << host->board.ale));\r\n}\r\nstatic int atmel_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nreturn gpio_get_value(host->board.rdy_pin) ^\r\n!!host->board.rdy_pin_active_low;\r\n}\r\nstatic void atmel_read_buf8(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_readsb(nand_chip->IO_ADDR_R, buf, len);\r\n}\r\nstatic void atmel_read_buf16(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_readsw(nand_chip->IO_ADDR_R, buf, len / 2);\r\n}\r\nstatic void atmel_write_buf8(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_writesb(nand_chip->IO_ADDR_W, buf, len);\r\n}\r\nstatic void atmel_write_buf16(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_writesw(nand_chip->IO_ADDR_W, buf, len / 2);\r\n}\r\nstatic void dma_complete_func(void *completion)\r\n{\r\ncomplete(completion);\r\n}\r\nstatic int atmel_nand_dma_op(struct mtd_info *mtd, void *buf, int len,\r\nint is_read)\r\n{\r\nstruct dma_device *dma_dev;\r\nenum dma_ctrl_flags flags;\r\ndma_addr_t dma_src_addr, dma_dst_addr, phys_addr;\r\nstruct dma_async_tx_descriptor *tx = NULL;\r\ndma_cookie_t cookie;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nvoid *p = buf;\r\nint err = -EIO;\r\nenum dma_data_direction dir = is_read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nif (buf >= high_memory)\r\ngoto err_buf;\r\ndma_dev = host->dma_chan->device;\r\nflags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_SRC_UNMAP |\r\nDMA_COMPL_SKIP_DEST_UNMAP;\r\nphys_addr = dma_map_single(dma_dev->dev, p, len, dir);\r\nif (dma_mapping_error(dma_dev->dev, phys_addr)) {\r\ndev_err(host->dev, "Failed to dma_map_single\n");\r\ngoto err_buf;\r\n}\r\nif (is_read) {\r\ndma_src_addr = host->io_phys;\r\ndma_dst_addr = phys_addr;\r\n} else {\r\ndma_src_addr = phys_addr;\r\ndma_dst_addr = host->io_phys;\r\n}\r\ntx = dma_dev->device_prep_dma_memcpy(host->dma_chan, dma_dst_addr,\r\ndma_src_addr, len, flags);\r\nif (!tx) {\r\ndev_err(host->dev, "Failed to prepare DMA memcpy\n");\r\ngoto err_dma;\r\n}\r\ninit_completion(&host->comp);\r\ntx->callback = dma_complete_func;\r\ntx->callback_param = &host->comp;\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\ndev_err(host->dev, "Failed to do DMA tx_submit\n");\r\ngoto err_dma;\r\n}\r\ndma_async_issue_pending(host->dma_chan);\r\nwait_for_completion(&host->comp);\r\nerr = 0;\r\nerr_dma:\r\ndma_unmap_single(dma_dev->dev, phys_addr, len, dir);\r\nerr_buf:\r\nif (err != 0)\r\ndev_warn(host->dev, "Fall back to CPU I/O\n");\r\nreturn err;\r\n}\r\nstatic void atmel_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nif (use_dma && len > mtd->oobsize)\r\nif (atmel_nand_dma_op(mtd, buf, len, 1) == 0)\r\nreturn;\r\nif (host->board.bus_width_16)\r\natmel_read_buf16(mtd, buf, len);\r\nelse\r\natmel_read_buf8(mtd, buf, len);\r\n}\r\nstatic void atmel_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nif (use_dma && len > mtd->oobsize)\r\nif (atmel_nand_dma_op(mtd, (void *)buf, len, 0) == 0)\r\nreturn;\r\nif (host->board.bus_width_16)\r\natmel_write_buf16(mtd, buf, len);\r\nelse\r\natmel_write_buf8(mtd, buf, len);\r\n}\r\nstatic int atmel_nand_calculate(struct mtd_info *mtd,\r\nconst u_char *dat, unsigned char *ecc_code)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned int ecc_value;\r\necc_value = ecc_readl(host->ecc, PR);\r\necc_code[0] = ecc_value & 0xFF;\r\necc_code[1] = (ecc_value >> 8) & 0xFF;\r\necc_value = ecc_readl(host->ecc, NPR) & ATMEL_ECC_NPARITY;\r\necc_code[2] = ecc_value & 0xFF;\r\necc_code[3] = (ecc_value >> 8) & 0xFF;\r\nreturn 0;\r\n}\r\nstatic int atmel_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *p = buf;\r\nuint8_t *oob = chip->oob_poi;\r\nuint8_t *ecc_pos;\r\nint stat;\r\nunsigned int max_bitflips = 0;\r\nif (cpu_is_at32ap7000()) {\r\nstruct atmel_nand_host *host = chip->priv;\r\necc_writel(host->ecc, CR, ATMEL_ECC_RST);\r\n}\r\nchip->read_buf(mtd, p, eccsize);\r\nif (eccpos[0] != 0) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT,\r\nmtd->writesize + eccpos[0], -1);\r\n}\r\necc_pos = oob + eccpos[0];\r\nchip->read_buf(mtd, ecc_pos, eccbytes);\r\nstat = chip->ecc.correct(mtd, p, oob, NULL);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);\r\nchip->read_buf(mtd, oob, mtd->oobsize);\r\nreturn max_bitflips;\r\n}\r\nstatic int atmel_nand_correct(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *isnull)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned int ecc_status;\r\nunsigned int ecc_word, ecc_bit;\r\necc_status = ecc_readl(host->ecc, SR);\r\nif (likely(!(ecc_status & ATMEL_ECC_RECERR)))\r\nreturn 0;\r\necc_bit = ecc_readl(host->ecc, PR) & ATMEL_ECC_BITADDR;\r\necc_word = ecc_readl(host->ecc, PR) & ATMEL_ECC_WORDADDR;\r\necc_word >>= 4;\r\nif (ecc_status & ATMEL_ECC_MULERR) {\r\nif ((ecc_bit == ATMEL_ECC_BITADDR)\r\n&& (ecc_word == (ATMEL_ECC_WORDADDR >> 4))) {\r\nreturn 0;\r\n}\r\ndev_dbg(host->dev, "atmel_nand : multiple errors detected."\r\n" Unable to correct.\n");\r\nreturn -EIO;\r\n}\r\nif (ecc_status & ATMEL_ECC_ECCERR) {\r\ndev_dbg(host->dev, "atmel_nand : one bit error on ECC code."\r\n" Nothing to correct\n");\r\nreturn 0;\r\n}\r\ndev_dbg(host->dev, "atmel_nand : one bit error on data."\r\n" (word offset in the page :"\r\n" 0x%x bit offset : 0x%x)\n",\r\necc_word, ecc_bit);\r\nif (nand_chip->options & NAND_BUSWIDTH_16) {\r\n((unsigned short *) dat)[ecc_word] ^= (1 << ecc_bit);\r\n} else {\r\ndat[ecc_word] ^= (1 << ecc_bit);\r\n}\r\ndev_dbg(host->dev, "atmel_nand : error corrected\n");\r\nreturn 1;\r\n}\r\nstatic void atmel_nand_hwctl(struct mtd_info *mtd, int mode)\r\n{\r\nif (cpu_is_at32ap7000()) {\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\necc_writel(host->ecc, CR, ATMEL_ECC_RST);\r\n}\r\n}\r\nstatic int __devinit atmel_of_init_port(struct atmel_nand_host *host,\r\nstruct device_node *np)\r\n{\r\nu32 val;\r\nint ecc_mode;\r\nstruct atmel_nand_data *board = &host->board;\r\nenum of_gpio_flags flags;\r\nif (of_property_read_u32(np, "atmel,nand-addr-offset", &val) == 0) {\r\nif (val >= 32) {\r\ndev_err(host->dev, "invalid addr-offset %u\n", val);\r\nreturn -EINVAL;\r\n}\r\nboard->ale = val;\r\n}\r\nif (of_property_read_u32(np, "atmel,nand-cmd-offset", &val) == 0) {\r\nif (val >= 32) {\r\ndev_err(host->dev, "invalid cmd-offset %u\n", val);\r\nreturn -EINVAL;\r\n}\r\nboard->cle = val;\r\n}\r\necc_mode = of_get_nand_ecc_mode(np);\r\nboard->ecc_mode = ecc_mode < 0 ? NAND_ECC_SOFT : ecc_mode;\r\nboard->on_flash_bbt = of_get_nand_on_flash_bbt(np);\r\nif (of_get_nand_bus_width(np) == 16)\r\nboard->bus_width_16 = 1;\r\nboard->rdy_pin = of_get_gpio_flags(np, 0, &flags);\r\nboard->rdy_pin_active_low = (flags == OF_GPIO_ACTIVE_LOW);\r\nboard->enable_pin = of_get_gpio(np, 1);\r\nboard->det_pin = of_get_gpio(np, 2);\r\nreturn 0;\r\n}\r\nstatic int __devinit atmel_of_init_port(struct atmel_nand_host *host,\r\nstruct device_node *np)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int __init atmel_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nstruct resource *regs;\r\nstruct resource *mem;\r\nstruct mtd_part_parser_data ppdata = {};\r\nint res;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\nprintk(KERN_ERR "atmel_nand: can't get I/O resource mem\n");\r\nreturn -ENXIO;\r\n}\r\nhost = kzalloc(sizeof(struct atmel_nand_host), GFP_KERNEL);\r\nif (!host) {\r\nprintk(KERN_ERR "atmel_nand: failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nhost->io_phys = (dma_addr_t)mem->start;\r\nhost->io_base = ioremap(mem->start, resource_size(mem));\r\nif (host->io_base == NULL) {\r\nprintk(KERN_ERR "atmel_nand: ioremap failed\n");\r\nres = -EIO;\r\ngoto err_nand_ioremap;\r\n}\r\nmtd = &host->mtd;\r\nnand_chip = &host->nand_chip;\r\nhost->dev = &pdev->dev;\r\nif (pdev->dev.of_node) {\r\nres = atmel_of_init_port(host, pdev->dev.of_node);\r\nif (res)\r\ngoto err_nand_ioremap;\r\n} else {\r\nmemcpy(&host->board, pdev->dev.platform_data,\r\nsizeof(struct atmel_nand_data));\r\n}\r\nnand_chip->priv = host;\r\nmtd->priv = nand_chip;\r\nmtd->owner = THIS_MODULE;\r\nnand_chip->IO_ADDR_R = host->io_base;\r\nnand_chip->IO_ADDR_W = host->io_base;\r\nnand_chip->cmd_ctrl = atmel_nand_cmd_ctrl;\r\nif (gpio_is_valid(host->board.rdy_pin))\r\nnand_chip->dev_ready = atmel_nand_device_ready;\r\nnand_chip->ecc.mode = host->board.ecc_mode;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!regs && nand_chip->ecc.mode == NAND_ECC_HW) {\r\nprintk(KERN_ERR "atmel_nand: can't get I/O resource "\r\n"regs\nFalling back on software ECC\n");\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\n}\r\nif (nand_chip->ecc.mode == NAND_ECC_HW) {\r\nhost->ecc = ioremap(regs->start, resource_size(regs));\r\nif (host->ecc == NULL) {\r\nprintk(KERN_ERR "atmel_nand: ioremap failed\n");\r\nres = -EIO;\r\ngoto err_ecc_ioremap;\r\n}\r\nnand_chip->ecc.calculate = atmel_nand_calculate;\r\nnand_chip->ecc.correct = atmel_nand_correct;\r\nnand_chip->ecc.hwctl = atmel_nand_hwctl;\r\nnand_chip->ecc.read_page = atmel_nand_read_page;\r\nnand_chip->ecc.bytes = 4;\r\nnand_chip->ecc.strength = 1;\r\n}\r\nnand_chip->chip_delay = 20;\r\nif (host->board.bus_width_16)\r\nnand_chip->options |= NAND_BUSWIDTH_16;\r\nnand_chip->read_buf = atmel_read_buf;\r\nnand_chip->write_buf = atmel_write_buf;\r\nplatform_set_drvdata(pdev, host);\r\natmel_nand_enable(host);\r\nif (gpio_is_valid(host->board.det_pin)) {\r\nif (gpio_get_value(host->board.det_pin)) {\r\nprintk(KERN_INFO "No SmartMedia card inserted.\n");\r\nres = -ENXIO;\r\ngoto err_no_card;\r\n}\r\n}\r\nif (host->board.on_flash_bbt || on_flash_bbt) {\r\nprintk(KERN_INFO "atmel_nand: Use On Flash BBT\n");\r\nnand_chip->bbt_options |= NAND_BBT_USE_FLASH;\r\n}\r\nif (!cpu_has_dma())\r\nuse_dma = 0;\r\nif (use_dma) {\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\nhost->dma_chan = dma_request_channel(mask, NULL, NULL);\r\nif (!host->dma_chan) {\r\ndev_err(host->dev, "Failed to request DMA channel\n");\r\nuse_dma = 0;\r\n}\r\n}\r\nif (use_dma)\r\ndev_info(host->dev, "Using %s for DMA transfers.\n",\r\ndma_chan_name(host->dma_chan));\r\nelse\r\ndev_info(host->dev, "No DMA support for NAND access.\n");\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\nres = -ENXIO;\r\ngoto err_scan_ident;\r\n}\r\nif (nand_chip->ecc.mode == NAND_ECC_HW) {\r\nnand_chip->ecc.size = mtd->writesize;\r\nswitch (mtd->writesize) {\r\ncase 512:\r\nnand_chip->ecc.layout = &atmel_oobinfo_small;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_528);\r\nbreak;\r\ncase 1024:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_1056);\r\nbreak;\r\ncase 2048:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_2112);\r\nbreak;\r\ncase 4096:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_4224);\r\nbreak;\r\ndefault:\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nnand_chip->ecc.calculate = NULL;\r\nnand_chip->ecc.correct = NULL;\r\nnand_chip->ecc.hwctl = NULL;\r\nnand_chip->ecc.read_page = NULL;\r\nnand_chip->ecc.postpad = 0;\r\nnand_chip->ecc.prepad = 0;\r\nnand_chip->ecc.bytes = 0;\r\nbreak;\r\n}\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nres = -ENXIO;\r\ngoto err_scan_tail;\r\n}\r\nmtd->name = "atmel_nand";\r\nppdata.of_node = pdev->dev.of_node;\r\nres = mtd_device_parse_register(mtd, NULL, &ppdata,\r\nhost->board.parts, host->board.num_parts);\r\nif (!res)\r\nreturn res;\r\nerr_scan_tail:\r\nerr_scan_ident:\r\nerr_no_card:\r\natmel_nand_disable(host);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (host->dma_chan)\r\ndma_release_channel(host->dma_chan);\r\nif (host->ecc)\r\niounmap(host->ecc);\r\nerr_ecc_ioremap:\r\niounmap(host->io_base);\r\nerr_nand_ioremap:\r\nkfree(host);\r\nreturn res;\r\n}\r\nstatic int __exit atmel_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_nand_host *host = platform_get_drvdata(pdev);\r\nstruct mtd_info *mtd = &host->mtd;\r\nnand_release(mtd);\r\natmel_nand_disable(host);\r\nif (host->ecc)\r\niounmap(host->ecc);\r\nif (host->dma_chan)\r\ndma_release_channel(host->dma_chan);\r\niounmap(host->io_base);\r\nkfree(host);\r\nreturn 0;\r\n}\r\nstatic int __init atmel_nand_init(void)\r\n{\r\nreturn platform_driver_probe(&atmel_nand_driver, atmel_nand_probe);\r\n}\r\nstatic void __exit atmel_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&atmel_nand_driver);\r\n}
