static inline struct per_user_data *get_port_user(unsigned port)\r\n{\r\nreturn (struct per_user_data *)(port_user[port] & ~1);\r\n}\r\nstatic inline void set_port_user(unsigned port, struct per_user_data *u)\r\n{\r\nport_user[port] = (unsigned long)u;\r\n}\r\nstatic inline bool get_port_enabled(unsigned port)\r\n{\r\nreturn port_user[port] & 1;\r\n}\r\nstatic inline void set_port_enabled(unsigned port, bool enabled)\r\n{\r\nif (enabled)\r\nport_user[port] |= 1;\r\nelse\r\nport_user[port] &= ~1;\r\n}\r\nstatic irqreturn_t evtchn_interrupt(int irq, void *data)\r\n{\r\nunsigned int port = (unsigned long)data;\r\nstruct per_user_data *u;\r\nspin_lock(&port_user_lock);\r\nu = get_port_user(port);\r\nWARN(!get_port_enabled(port),\r\n"Interrupt for port %d, but apparently not enabled; per-user %p\n",\r\nport, u);\r\ndisable_irq_nosync(irq);\r\nset_port_enabled(port, false);\r\nif ((u->ring_prod - u->ring_cons) < EVTCHN_RING_SIZE) {\r\nu->ring[EVTCHN_RING_MASK(u->ring_prod)] = port;\r\nwmb();\r\nif (u->ring_cons == u->ring_prod++) {\r\nwake_up_interruptible(&u->evtchn_wait);\r\nkill_fasync(&u->evtchn_async_queue,\r\nSIGIO, POLL_IN);\r\n}\r\n} else\r\nu->ring_overflow = 1;\r\nspin_unlock(&port_user_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t evtchn_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint rc;\r\nunsigned int c, p, bytes1 = 0, bytes2 = 0;\r\nstruct per_user_data *u = file->private_data;\r\ncount &= ~(sizeof(evtchn_port_t)-1);\r\nif (count == 0)\r\nreturn 0;\r\nif (count > PAGE_SIZE)\r\ncount = PAGE_SIZE;\r\nfor (;;) {\r\nmutex_lock(&u->ring_cons_mutex);\r\nrc = -EFBIG;\r\nif (u->ring_overflow)\r\ngoto unlock_out;\r\nc = u->ring_cons;\r\np = u->ring_prod;\r\nif (c != p)\r\nbreak;\r\nmutex_unlock(&u->ring_cons_mutex);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nrc = wait_event_interruptible(u->evtchn_wait,\r\nu->ring_cons != u->ring_prod);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (((c ^ p) & EVTCHN_RING_SIZE) != 0) {\r\nbytes1 = (EVTCHN_RING_SIZE - EVTCHN_RING_MASK(c)) *\r\nsizeof(evtchn_port_t);\r\nbytes2 = EVTCHN_RING_MASK(p) * sizeof(evtchn_port_t);\r\n} else {\r\nbytes1 = (p - c) * sizeof(evtchn_port_t);\r\nbytes2 = 0;\r\n}\r\nif (bytes1 > count) {\r\nbytes1 = count;\r\nbytes2 = 0;\r\n} else if ((bytes1 + bytes2) > count) {\r\nbytes2 = count - bytes1;\r\n}\r\nrc = -EFAULT;\r\nrmb();\r\nif (copy_to_user(buf, &u->ring[EVTCHN_RING_MASK(c)], bytes1) ||\r\n((bytes2 != 0) &&\r\ncopy_to_user(&buf[bytes1], &u->ring[0], bytes2)))\r\ngoto unlock_out;\r\nu->ring_cons += (bytes1 + bytes2) / sizeof(evtchn_port_t);\r\nrc = bytes1 + bytes2;\r\nunlock_out:\r\nmutex_unlock(&u->ring_cons_mutex);\r\nreturn rc;\r\n}\r\nstatic ssize_t evtchn_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint rc, i;\r\nevtchn_port_t *kbuf = (evtchn_port_t *)__get_free_page(GFP_KERNEL);\r\nstruct per_user_data *u = file->private_data;\r\nif (kbuf == NULL)\r\nreturn -ENOMEM;\r\ncount &= ~(sizeof(evtchn_port_t)-1);\r\nrc = 0;\r\nif (count == 0)\r\ngoto out;\r\nif (count > PAGE_SIZE)\r\ncount = PAGE_SIZE;\r\nrc = -EFAULT;\r\nif (copy_from_user(kbuf, buf, count) != 0)\r\ngoto out;\r\nspin_lock_irq(&port_user_lock);\r\nfor (i = 0; i < (count/sizeof(evtchn_port_t)); i++) {\r\nunsigned port = kbuf[i];\r\nif (port < NR_EVENT_CHANNELS &&\r\nget_port_user(port) == u &&\r\n!get_port_enabled(port)) {\r\nset_port_enabled(port, true);\r\nenable_irq(irq_from_evtchn(port));\r\n}\r\n}\r\nspin_unlock_irq(&port_user_lock);\r\nrc = count;\r\nout:\r\nfree_page((unsigned long)kbuf);\r\nreturn rc;\r\n}\r\nstatic int evtchn_bind_to_user(struct per_user_data *u, int port)\r\n{\r\nint rc = 0;\r\nBUG_ON(get_port_user(port) != NULL);\r\nset_port_user(port, u);\r\nset_port_enabled(port, true);\r\nrc = bind_evtchn_to_irqhandler(port, evtchn_interrupt, IRQF_DISABLED,\r\nu->name, (void *)(unsigned long)port);\r\nif (rc >= 0)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nstatic void evtchn_unbind_from_user(struct per_user_data *u, int port)\r\n{\r\nint irq = irq_from_evtchn(port);\r\nunbind_from_irqhandler(irq, (void *)(unsigned long)port);\r\nset_port_user(port, NULL);\r\n}\r\nstatic long evtchn_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint rc;\r\nstruct per_user_data *u = file->private_data;\r\nvoid __user *uarg = (void __user *) arg;\r\nmutex_lock(&u->bind_mutex);\r\nswitch (cmd) {\r\ncase IOCTL_EVTCHN_BIND_VIRQ: {\r\nstruct ioctl_evtchn_bind_virq bind;\r\nstruct evtchn_bind_virq bind_virq;\r\nrc = -EFAULT;\r\nif (copy_from_user(&bind, uarg, sizeof(bind)))\r\nbreak;\r\nbind_virq.virq = bind.virq;\r\nbind_virq.vcpu = 0;\r\nrc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,\r\n&bind_virq);\r\nif (rc != 0)\r\nbreak;\r\nrc = evtchn_bind_to_user(u, bind_virq.port);\r\nif (rc == 0)\r\nrc = bind_virq.port;\r\nbreak;\r\n}\r\ncase IOCTL_EVTCHN_BIND_INTERDOMAIN: {\r\nstruct ioctl_evtchn_bind_interdomain bind;\r\nstruct evtchn_bind_interdomain bind_interdomain;\r\nrc = -EFAULT;\r\nif (copy_from_user(&bind, uarg, sizeof(bind)))\r\nbreak;\r\nbind_interdomain.remote_dom = bind.remote_domain;\r\nbind_interdomain.remote_port = bind.remote_port;\r\nrc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain,\r\n&bind_interdomain);\r\nif (rc != 0)\r\nbreak;\r\nrc = evtchn_bind_to_user(u, bind_interdomain.local_port);\r\nif (rc == 0)\r\nrc = bind_interdomain.local_port;\r\nbreak;\r\n}\r\ncase IOCTL_EVTCHN_BIND_UNBOUND_PORT: {\r\nstruct ioctl_evtchn_bind_unbound_port bind;\r\nstruct evtchn_alloc_unbound alloc_unbound;\r\nrc = -EFAULT;\r\nif (copy_from_user(&bind, uarg, sizeof(bind)))\r\nbreak;\r\nalloc_unbound.dom = DOMID_SELF;\r\nalloc_unbound.remote_dom = bind.remote_domain;\r\nrc = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound,\r\n&alloc_unbound);\r\nif (rc != 0)\r\nbreak;\r\nrc = evtchn_bind_to_user(u, alloc_unbound.port);\r\nif (rc == 0)\r\nrc = alloc_unbound.port;\r\nbreak;\r\n}\r\ncase IOCTL_EVTCHN_UNBIND: {\r\nstruct ioctl_evtchn_unbind unbind;\r\nrc = -EFAULT;\r\nif (copy_from_user(&unbind, uarg, sizeof(unbind)))\r\nbreak;\r\nrc = -EINVAL;\r\nif (unbind.port >= NR_EVENT_CHANNELS)\r\nbreak;\r\nspin_lock_irq(&port_user_lock);\r\nrc = -ENOTCONN;\r\nif (get_port_user(unbind.port) != u) {\r\nspin_unlock_irq(&port_user_lock);\r\nbreak;\r\n}\r\ndisable_irq(irq_from_evtchn(unbind.port));\r\nspin_unlock_irq(&port_user_lock);\r\nevtchn_unbind_from_user(u, unbind.port);\r\nrc = 0;\r\nbreak;\r\n}\r\ncase IOCTL_EVTCHN_NOTIFY: {\r\nstruct ioctl_evtchn_notify notify;\r\nrc = -EFAULT;\r\nif (copy_from_user(&notify, uarg, sizeof(notify)))\r\nbreak;\r\nif (notify.port >= NR_EVENT_CHANNELS) {\r\nrc = -EINVAL;\r\n} else if (get_port_user(notify.port) != u) {\r\nrc = -ENOTCONN;\r\n} else {\r\nnotify_remote_via_evtchn(notify.port);\r\nrc = 0;\r\n}\r\nbreak;\r\n}\r\ncase IOCTL_EVTCHN_RESET: {\r\nmutex_lock(&u->ring_cons_mutex);\r\nspin_lock_irq(&port_user_lock);\r\nu->ring_cons = u->ring_prod = u->ring_overflow = 0;\r\nspin_unlock_irq(&port_user_lock);\r\nmutex_unlock(&u->ring_cons_mutex);\r\nrc = 0;\r\nbreak;\r\n}\r\ndefault:\r\nrc = -ENOSYS;\r\nbreak;\r\n}\r\nmutex_unlock(&u->bind_mutex);\r\nreturn rc;\r\n}\r\nstatic unsigned int evtchn_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = POLLOUT | POLLWRNORM;\r\nstruct per_user_data *u = file->private_data;\r\npoll_wait(file, &u->evtchn_wait, wait);\r\nif (u->ring_cons != u->ring_prod)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (u->ring_overflow)\r\nmask = POLLERR;\r\nreturn mask;\r\n}\r\nstatic int evtchn_fasync(int fd, struct file *filp, int on)\r\n{\r\nstruct per_user_data *u = filp->private_data;\r\nreturn fasync_helper(fd, filp, on, &u->evtchn_async_queue);\r\n}\r\nstatic int evtchn_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct per_user_data *u;\r\nu = kzalloc(sizeof(*u), GFP_KERNEL);\r\nif (u == NULL)\r\nreturn -ENOMEM;\r\nu->name = kasprintf(GFP_KERNEL, "evtchn:%s", current->comm);\r\nif (u->name == NULL) {\r\nkfree(u);\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&u->evtchn_wait);\r\nu->ring = (evtchn_port_t *)__get_free_page(GFP_KERNEL);\r\nif (u->ring == NULL) {\r\nkfree(u->name);\r\nkfree(u);\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&u->bind_mutex);\r\nmutex_init(&u->ring_cons_mutex);\r\nfilp->private_data = u;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int evtchn_release(struct inode *inode, struct file *filp)\r\n{\r\nint i;\r\nstruct per_user_data *u = filp->private_data;\r\nspin_lock_irq(&port_user_lock);\r\nfree_page((unsigned long)u->ring);\r\nfor (i = 0; i < NR_EVENT_CHANNELS; i++) {\r\nif (get_port_user(i) != u)\r\ncontinue;\r\ndisable_irq(irq_from_evtchn(i));\r\n}\r\nspin_unlock_irq(&port_user_lock);\r\nfor (i = 0; i < NR_EVENT_CHANNELS; i++) {\r\nif (get_port_user(i) != u)\r\ncontinue;\r\nevtchn_unbind_from_user(get_port_user(i), i);\r\n}\r\nkfree(u->name);\r\nkfree(u);\r\nreturn 0;\r\n}\r\nstatic int __init evtchn_init(void)\r\n{\r\nint err;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nport_user = kcalloc(NR_EVENT_CHANNELS, sizeof(*port_user), GFP_KERNEL);\r\nif (port_user == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&port_user_lock);\r\nerr = misc_register(&evtchn_miscdev);\r\nif (err != 0) {\r\nprintk(KERN_ALERT "Could not register /dev/misc/evtchn\n");\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "Event-channel device installed.\n");\r\nreturn 0;\r\n}\r\nstatic void __exit evtchn_cleanup(void)\r\n{\r\nkfree(port_user);\r\nport_user = NULL;\r\nmisc_deregister(&evtchn_miscdev);\r\n}
