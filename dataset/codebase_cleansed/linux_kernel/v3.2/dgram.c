static inline struct dgram_sock *dgram_sk(const struct sock *sk)\r\n{\r\nreturn container_of(sk, struct dgram_sock, sk);\r\n}\r\nstatic void dgram_hash(struct sock *sk)\r\n{\r\nwrite_lock_bh(&dgram_lock);\r\nsk_add_node(sk, &dgram_head);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nwrite_unlock_bh(&dgram_lock);\r\n}\r\nstatic void dgram_unhash(struct sock *sk)\r\n{\r\nwrite_lock_bh(&dgram_lock);\r\nif (sk_del_node_init(sk))\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\r\nwrite_unlock_bh(&dgram_lock);\r\n}\r\nstatic int dgram_init(struct sock *sk)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nro->dst_addr.addr_type = IEEE802154_ADDR_LONG;\r\nro->dst_addr.pan_id = 0xffff;\r\nro->want_ack = 1;\r\nmemset(&ro->dst_addr.hwaddr, 0xff, sizeof(ro->dst_addr.hwaddr));\r\nreturn 0;\r\n}\r\nstatic void dgram_close(struct sock *sk, long timeout)\r\n{\r\nsk_common_release(sk);\r\n}\r\nstatic int dgram_bind(struct sock *sk, struct sockaddr *uaddr, int len)\r\n{\r\nstruct sockaddr_ieee802154 *addr = (struct sockaddr_ieee802154 *)uaddr;\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint err = -EINVAL;\r\nstruct net_device *dev;\r\nlock_sock(sk);\r\nro->bound = 0;\r\nif (len < sizeof(*addr))\r\ngoto out;\r\nif (addr->family != AF_IEEE802154)\r\ngoto out;\r\ndev = ieee802154_get_dev(sock_net(sk), &addr->addr);\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (dev->type != ARPHRD_IEEE802154) {\r\nerr = -ENODEV;\r\ngoto out_put;\r\n}\r\nmemcpy(&ro->src_addr, &addr->addr, sizeof(struct ieee802154_addr));\r\nro->bound = 1;\r\nerr = 0;\r\nout_put:\r\ndev_put(dev);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int dgram_ioctl(struct sock *sk, int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCOUTQ:\r\n{\r\nint amount = sk_wmem_alloc_get(sk);\r\nreturn put_user(amount, (int __user *)arg);\r\n}\r\ncase SIOCINQ:\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long amount;\r\namount = 0;\r\nspin_lock_bh(&sk->sk_receive_queue.lock);\r\nskb = skb_peek(&sk->sk_receive_queue);\r\nif (skb != NULL) {\r\namount = skb->len - (3+8+8);\r\n}\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\nreturn put_user(amount, (int __user *)arg);\r\n}\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int dgram_connect(struct sock *sk, struct sockaddr *uaddr,\r\nint len)\r\n{\r\nstruct sockaddr_ieee802154 *addr = (struct sockaddr_ieee802154 *)uaddr;\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint err = 0;\r\nif (len < sizeof(*addr))\r\nreturn -EINVAL;\r\nif (addr->family != AF_IEEE802154)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (!ro->bound) {\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\nmemcpy(&ro->dst_addr, &addr->addr, sizeof(struct ieee802154_addr));\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int dgram_disconnect(struct sock *sk, int flags)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nlock_sock(sk);\r\nro->dst_addr.addr_type = IEEE802154_ADDR_LONG;\r\nmemset(&ro->dst_addr.hwaddr, 0xff, sizeof(ro->dst_addr.hwaddr));\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nstatic int dgram_sendmsg(struct kiocb *iocb, struct sock *sk,\r\nstruct msghdr *msg, size_t size)\r\n{\r\nstruct net_device *dev;\r\nunsigned mtu;\r\nstruct sk_buff *skb;\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint err;\r\nif (msg->msg_flags & MSG_OOB) {\r\npr_debug("msg->msg_flags = 0x%x\n", msg->msg_flags);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!ro->bound)\r\ndev = dev_getfirstbyhwtype(sock_net(sk), ARPHRD_IEEE802154);\r\nelse\r\ndev = ieee802154_get_dev(sock_net(sk), &ro->src_addr);\r\nif (!dev) {\r\npr_debug("no dev\n");\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nmtu = dev->mtu;\r\npr_debug("name = %s, mtu = %u\n", dev->name, mtu);\r\nskb = sock_alloc_send_skb(sk, LL_ALLOCATED_SPACE(dev) + size,\r\nmsg->msg_flags & MSG_DONTWAIT,\r\n&err);\r\nif (!skb)\r\ngoto out_dev;\r\nskb_reserve(skb, LL_RESERVED_SPACE(dev));\r\nskb_reset_network_header(skb);\r\nmac_cb(skb)->flags = IEEE802154_FC_TYPE_DATA;\r\nif (ro->want_ack)\r\nmac_cb(skb)->flags |= MAC_CB_FLAG_ACKREQ;\r\nmac_cb(skb)->seq = ieee802154_mlme_ops(dev)->get_dsn(dev);\r\nerr = dev_hard_header(skb, dev, ETH_P_IEEE802154, &ro->dst_addr,\r\nro->bound ? &ro->src_addr : NULL, size);\r\nif (err < 0)\r\ngoto out_skb;\r\nskb_reset_mac_header(skb);\r\nerr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\r\nif (err < 0)\r\ngoto out_skb;\r\nif (size > mtu) {\r\npr_debug("size = %Zu, mtu = %u\n", size, mtu);\r\nerr = -EINVAL;\r\ngoto out_skb;\r\n}\r\nskb->dev = dev;\r\nskb->sk = sk;\r\nskb->protocol = htons(ETH_P_IEEE802154);\r\ndev_put(dev);\r\nerr = dev_queue_xmit(skb);\r\nif (err > 0)\r\nerr = net_xmit_errno(err);\r\nreturn err ?: size;\r\nout_skb:\r\nkfree_skb(skb);\r\nout_dev:\r\ndev_put(dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\r\nstruct msghdr *msg, size_t len, int noblock, int flags,\r\nint *addr_len)\r\n{\r\nsize_t copied = 0;\r\nint err = -EOPNOTSUPP;\r\nstruct sk_buff *skb;\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (err)\r\ngoto done;\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nif (flags & MSG_TRUNC)\r\ncopied = skb->len;\r\ndone:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nif (err)\r\nreturn err;\r\nreturn copied;\r\n}\r\nstatic int dgram_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\nif (sock_queue_rcv_skb(sk, skb) < 0) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic inline int ieee802154_match_sock(u8 *hw_addr, u16 pan_id,\r\nu16 short_addr, struct dgram_sock *ro)\r\n{\r\nif (!ro->bound)\r\nreturn 1;\r\nif (ro->src_addr.addr_type == IEEE802154_ADDR_LONG &&\r\n!memcmp(ro->src_addr.hwaddr, hw_addr, IEEE802154_ADDR_LEN))\r\nreturn 1;\r\nif (ro->src_addr.addr_type == IEEE802154_ADDR_SHORT &&\r\npan_id == ro->src_addr.pan_id &&\r\nshort_addr == ro->src_addr.short_addr)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint ieee802154_dgram_deliver(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct sock *sk, *prev = NULL;\r\nstruct hlist_node *node;\r\nint ret = NET_RX_SUCCESS;\r\nu16 pan_id, short_addr;\r\nBUG_ON(dev->type != ARPHRD_IEEE802154);\r\npan_id = ieee802154_mlme_ops(dev)->get_pan_id(dev);\r\nshort_addr = ieee802154_mlme_ops(dev)->get_short_addr(dev);\r\nread_lock(&dgram_lock);\r\nsk_for_each(sk, node, &dgram_head) {\r\nif (ieee802154_match_sock(dev->dev_addr, pan_id, short_addr,\r\ndgram_sk(sk))) {\r\nif (prev) {\r\nstruct sk_buff *clone;\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone)\r\ndgram_rcv_skb(prev, clone);\r\n}\r\nprev = sk;\r\n}\r\n}\r\nif (prev)\r\ndgram_rcv_skb(prev, skb);\r\nelse {\r\nkfree_skb(skb);\r\nret = NET_RX_DROP;\r\n}\r\nread_unlock(&dgram_lock);\r\nreturn ret;\r\n}\r\nstatic int dgram_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint val, len;\r\nif (level != SOL_IEEE802154)\r\nreturn -EOPNOTSUPP;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlen = min_t(unsigned int, len, sizeof(int));\r\nswitch (optname) {\r\ncase WPAN_WANTACK:\r\nval = ro->want_ack;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, &val, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dgram_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct dgram_sock *ro = dgram_sk(sk);\r\nint val;\r\nint err = 0;\r\nif (optlen < sizeof(int))\r\nreturn -EINVAL;\r\nif (get_user(val, (int __user *)optval))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase WPAN_WANTACK:\r\nro->want_ack = !!val;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}
