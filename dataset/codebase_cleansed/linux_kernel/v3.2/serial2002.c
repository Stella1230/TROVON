static long tty_ioctl(struct file *f, unsigned op, unsigned long param)\r\n{\r\nif (f->f_op->unlocked_ioctl)\r\nreturn f->f_op->unlocked_ioctl(f, op, param);\r\nreturn -ENOSYS;\r\n}\r\nstatic int tty_write(struct file *f, unsigned char *buf, int count)\r\n{\r\nint result;\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nf->f_pos = 0;\r\nresult = f->f_op->write(f, buf, count, &f->f_pos);\r\nset_fs(oldfs);\r\nreturn result;\r\n}\r\nstatic int tty_read(struct file *f, int timeout)\r\n{\r\nint result;\r\nresult = -1;\r\nif (!IS_ERR(f)) {\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nif (f->f_op->poll) {\r\nstruct poll_wqueues table;\r\nstruct timeval start, now;\r\ndo_gettimeofday(&start);\r\npoll_initwait(&table);\r\nwhile (1) {\r\nlong elapsed;\r\nint mask;\r\nmask = f->f_op->poll(f, &table.pt);\r\nif (mask & (POLLRDNORM | POLLRDBAND | POLLIN |\r\nPOLLHUP | POLLERR)) {\r\nbreak;\r\n}\r\ndo_gettimeofday(&now);\r\nelapsed =\r\n(1000000 * (now.tv_sec - start.tv_sec) +\r\nnow.tv_usec - start.tv_usec);\r\nif (elapsed > timeout)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(((timeout -\r\nelapsed) * HZ) / 10000);\r\n}\r\npoll_freewait(&table);\r\n{\r\nunsigned char ch;\r\nf->f_pos = 0;\r\nif (f->f_op->read(f, &ch, 1, &f->f_pos) == 1)\r\nresult = ch;\r\n}\r\n} else {\r\nint retries = 0;\r\nwhile (1) {\r\nunsigned char ch;\r\nretries++;\r\nif (retries >= timeout)\r\nbreak;\r\nf->f_pos = 0;\r\nif (f->f_op->read(f, &ch, 1, &f->f_pos) == 1) {\r\nresult = ch;\r\nbreak;\r\n}\r\nudelay(100);\r\n}\r\n}\r\nset_fs(oldfs);\r\n}\r\nreturn result;\r\n}\r\nstatic void tty_setspeed(struct file *f, int speed)\r\n{\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\n{\r\nstruct termios settings;\r\ntty_ioctl(f, TCGETS, (unsigned long)&settings);\r\nsettings.c_iflag = 0;\r\nsettings.c_oflag = 0;\r\nsettings.c_lflag = 0;\r\nsettings.c_cflag = CLOCAL | CS8 | CREAD;\r\nsettings.c_cc[VMIN] = 0;\r\nsettings.c_cc[VTIME] = 0;\r\nswitch (speed) {\r\ncase 2400:{\r\nsettings.c_cflag |= B2400;\r\n}\r\nbreak;\r\ncase 4800:{\r\nsettings.c_cflag |= B4800;\r\n}\r\nbreak;\r\ncase 9600:{\r\nsettings.c_cflag |= B9600;\r\n}\r\nbreak;\r\ncase 19200:{\r\nsettings.c_cflag |= B19200;\r\n}\r\nbreak;\r\ncase 38400:{\r\nsettings.c_cflag |= B38400;\r\n}\r\nbreak;\r\ncase 57600:{\r\nsettings.c_cflag |= B57600;\r\n}\r\nbreak;\r\ncase 115200:{\r\nsettings.c_cflag |= B115200;\r\n}\r\nbreak;\r\ndefault:{\r\nsettings.c_cflag |= B9600;\r\n}\r\nbreak;\r\n}\r\ntty_ioctl(f, TCSETS, (unsigned long)&settings);\r\n}\r\n{\r\nstruct serial_struct settings;\r\ntty_ioctl(f, TIOCGSERIAL, (unsigned long)&settings);\r\nsettings.flags |= ASYNC_LOW_LATENCY;\r\ntty_ioctl(f, TIOCSSERIAL, (unsigned long)&settings);\r\n}\r\nset_fs(oldfs);\r\n}\r\nstatic void poll_digital(struct file *f, int channel)\r\n{\r\nchar cmd;\r\ncmd = 0x40 | (channel & 0x1f);\r\ntty_write(f, &cmd, 1);\r\n}\r\nstatic void poll_channel(struct file *f, int channel)\r\n{\r\nchar cmd;\r\ncmd = 0x60 | (channel & 0x1f);\r\ntty_write(f, &cmd, 1);\r\n}\r\nstatic struct serial_data serial_read(struct file *f, int timeout)\r\n{\r\nstruct serial_data result;\r\nint length;\r\nresult.kind = is_invalid;\r\nresult.index = 0;\r\nresult.value = 0;\r\nlength = 0;\r\nwhile (1) {\r\nint data = tty_read(f, timeout);\r\nlength++;\r\nif (data < 0) {\r\nprintk(KERN_ERR "serial2002 error\n");\r\nbreak;\r\n} else if (data & 0x80) {\r\nresult.value = (result.value << 7) | (data & 0x7f);\r\n} else {\r\nif (length == 1) {\r\nswitch ((data >> 5) & 0x03) {\r\ncase 0:{\r\nresult.value = 0;\r\nresult.kind = is_digital;\r\n}\r\nbreak;\r\ncase 1:{\r\nresult.value = 1;\r\nresult.kind = is_digital;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nresult.value =\r\n(result.value << 2) | ((data & 0x60) >> 5);\r\nresult.kind = is_channel;\r\n}\r\nresult.index = data & 0x1f;\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void serial_write(struct file *f, struct serial_data data)\r\n{\r\nif (data.kind == is_digital) {\r\nunsigned char ch =\r\n((data.value << 5) & 0x20) | (data.index & 0x1f);\r\ntty_write(f, &ch, 1);\r\n} else {\r\nunsigned char ch[6];\r\nint i = 0;\r\nif (data.value >= (1L << 30)) {\r\nch[i] = 0x80 | ((data.value >> 30) & 0x03);\r\ni++;\r\n}\r\nif (data.value >= (1L << 23)) {\r\nch[i] = 0x80 | ((data.value >> 23) & 0x7f);\r\ni++;\r\n}\r\nif (data.value >= (1L << 16)) {\r\nch[i] = 0x80 | ((data.value >> 16) & 0x7f);\r\ni++;\r\n}\r\nif (data.value >= (1L << 9)) {\r\nch[i] = 0x80 | ((data.value >> 9) & 0x7f);\r\ni++;\r\n}\r\nch[i] = 0x80 | ((data.value >> 2) & 0x7f);\r\ni++;\r\nch[i] = ((data.value << 5) & 0x60) | (data.index & 0x1f);\r\ni++;\r\ntty_write(f, ch, i);\r\n}\r\n}\r\nstatic int serial_2002_open(struct comedi_device *dev)\r\n{\r\nint result;\r\nchar port[20];\r\nsprintf(port, "/dev/ttyS%d", devpriv->port);\r\ndevpriv->tty = filp_open(port, O_RDWR, 0);\r\nif (IS_ERR(devpriv->tty)) {\r\nresult = (int)PTR_ERR(devpriv->tty);\r\nprintk(KERN_ERR "serial_2002: file open error = %d\n", result);\r\n} else {\r\nstruct config_t {\r\nshort int kind;\r\nshort int bits;\r\nint min;\r\nint max;\r\n};\r\nstruct config_t *dig_in_config;\r\nstruct config_t *dig_out_config;\r\nstruct config_t *chan_in_config;\r\nstruct config_t *chan_out_config;\r\nint i;\r\nresult = 0;\r\ndig_in_config = kcalloc(32, sizeof(struct config_t),\r\nGFP_KERNEL);\r\ndig_out_config = kcalloc(32, sizeof(struct config_t),\r\nGFP_KERNEL);\r\nchan_in_config = kcalloc(32, sizeof(struct config_t),\r\nGFP_KERNEL);\r\nchan_out_config = kcalloc(32, sizeof(struct config_t),\r\nGFP_KERNEL);\r\nif (!dig_in_config || !dig_out_config\r\n|| !chan_in_config || !chan_out_config) {\r\nresult = -ENOMEM;\r\ngoto err_alloc_configs;\r\n}\r\ntty_setspeed(devpriv->tty, devpriv->speed);\r\npoll_channel(devpriv->tty, 31);\r\nwhile (1) {\r\nstruct serial_data data;\r\ndata = serial_read(devpriv->tty, 1000);\r\nif (data.kind != is_channel || data.index != 31\r\n|| !(data.value & 0xe0)) {\r\nbreak;\r\n} else {\r\nint command, channel, kind;\r\nstruct config_t *cur_config = NULL;\r\nchannel = data.value & 0x1f;\r\nkind = (data.value >> 5) & 0x7;\r\ncommand = (data.value >> 8) & 0x3;\r\nswitch (kind) {\r\ncase 1:{\r\ncur_config = dig_in_config;\r\n}\r\nbreak;\r\ncase 2:{\r\ncur_config = dig_out_config;\r\n}\r\nbreak;\r\ncase 3:{\r\ncur_config = chan_in_config;\r\n}\r\nbreak;\r\ncase 4:{\r\ncur_config = chan_out_config;\r\n}\r\nbreak;\r\ncase 5:{\r\ncur_config = chan_in_config;\r\n}\r\nbreak;\r\n}\r\nif (cur_config) {\r\ncur_config[channel].kind = kind;\r\nswitch (command) {\r\ncase 0:{\r\ncur_config[channel].bits\r\n=\r\n(data.value >> 10) &\r\n0x3f;\r\n}\r\nbreak;\r\ncase 1:{\r\nint unit, sign, min;\r\nunit =\r\n(data.value >> 10) &\r\n0x7;\r\nsign =\r\n(data.value >> 13) &\r\n0x1;\r\nmin =\r\n(data.value >> 14) &\r\n0xfffff;\r\nswitch (unit) {\r\ncase 0:{\r\nmin =\r\nmin\r\n*\r\n1000000;\r\n}\r\nbreak;\r\ncase 1:{\r\nmin =\r\nmin\r\n*\r\n1000;\r\n}\r\nbreak;\r\ncase 2:{\r\nmin =\r\nmin\r\n* 1;\r\n}\r\nbreak;\r\n}\r\nif (sign)\r\nmin = -min;\r\ncur_config[channel].min\r\n= min;\r\n}\r\nbreak;\r\ncase 2:{\r\nint unit, sign, max;\r\nunit =\r\n(data.value >> 10) &\r\n0x7;\r\nsign =\r\n(data.value >> 13) &\r\n0x1;\r\nmax =\r\n(data.value >> 14) &\r\n0xfffff;\r\nswitch (unit) {\r\ncase 0:{\r\nmax =\r\nmax\r\n*\r\n1000000;\r\n}\r\nbreak;\r\ncase 1:{\r\nmax =\r\nmax\r\n*\r\n1000;\r\n}\r\nbreak;\r\ncase 2:{\r\nmax =\r\nmax\r\n* 1;\r\n}\r\nbreak;\r\n}\r\nif (sign)\r\nmax = -max;\r\ncur_config[channel].max\r\n= max;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i <= 4; i++) {\r\nstruct config_t *c;\r\nunsigned char *mapping = NULL;\r\nstruct serial2002_range_table_t *range = NULL;\r\nint kind = 0;\r\nswitch (i) {\r\ncase 0:{\r\nc = dig_in_config;\r\nmapping = devpriv->digital_in_mapping;\r\nkind = 1;\r\n}\r\nbreak;\r\ncase 1:{\r\nc = dig_out_config;\r\nmapping = devpriv->digital_out_mapping;\r\nkind = 2;\r\n}\r\nbreak;\r\ncase 2:{\r\nc = chan_in_config;\r\nmapping = devpriv->analog_in_mapping;\r\nrange = devpriv->in_range;\r\nkind = 3;\r\n}\r\nbreak;\r\ncase 3:{\r\nc = chan_out_config;\r\nmapping = devpriv->analog_out_mapping;\r\nrange = devpriv->out_range;\r\nkind = 4;\r\n}\r\nbreak;\r\ncase 4:{\r\nc = chan_in_config;\r\nmapping = devpriv->encoder_in_mapping;\r\nrange = devpriv->in_range;\r\nkind = 5;\r\n}\r\nbreak;\r\ndefault:{\r\nc = NULL;\r\n}\r\nbreak;\r\n}\r\nif (c) {\r\nstruct comedi_subdevice *s;\r\nconst struct comedi_lrange **range_table_list =\r\nNULL;\r\nunsigned int *maxdata_list;\r\nint j, chan;\r\nfor (chan = 0, j = 0; j < 32; j++) {\r\nif (c[j].kind == kind)\r\nchan++;\r\n}\r\ns = &dev->subdevices[i];\r\ns->n_chan = chan;\r\ns->maxdata = 0;\r\nkfree(s->maxdata_list);\r\ns->maxdata_list = maxdata_list =\r\nkmalloc(sizeof(unsigned int) * s->n_chan,\r\nGFP_KERNEL);\r\nif (!s->maxdata_list)\r\nbreak;\r\nkfree(s->range_table_list);\r\ns->range_table = NULL;\r\ns->range_table_list = NULL;\r\nif (range) {\r\ns->range_table_list = range_table_list =\r\nkmalloc(sizeof\r\n(struct\r\nserial2002_range_table_t) *\r\ns->n_chan, GFP_KERNEL);\r\nif (!s->range_table_list)\r\nbreak;\r\n}\r\nfor (chan = 0, j = 0; j < 32; j++) {\r\nif (c[j].kind == kind) {\r\nif (mapping)\r\nmapping[chan] = j;\r\nif (range) {\r\nrange[j].length = 1;\r\nrange[j].range.min =\r\nc[j].min;\r\nrange[j].range.max =\r\nc[j].max;\r\nrange_table_list[chan] =\r\n(const struct\r\ncomedi_lrange *)\r\n&range[j];\r\n}\r\nmaxdata_list[chan] =\r\n((long long)1 << c[j].bits)\r\n- 1;\r\nchan++;\r\n}\r\n}\r\n}\r\n}\r\nif (i <= 4) {\r\nresult = -ENOMEM;\r\nfor (i = 0; i <= 4; i++) {\r\nstruct comedi_subdevice *s;\r\ns = &dev->subdevices[i];\r\nkfree(s->maxdata_list);\r\ns->maxdata_list = NULL;\r\nkfree(s->range_table_list);\r\ns->range_table_list = NULL;\r\n}\r\n}\r\nerr_alloc_configs:\r\nkfree(dig_in_config);\r\nkfree(dig_out_config);\r\nkfree(chan_in_config);\r\nkfree(chan_out_config);\r\nif (result) {\r\nif (devpriv->tty) {\r\nfilp_close(devpriv->tty, 0);\r\ndevpriv->tty = NULL;\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void serial_2002_close(struct comedi_device *dev)\r\n{\r\nif (!IS_ERR(devpriv->tty) && (devpriv->tty != 0))\r\nfilp_close(devpriv->tty, 0);\r\n}\r\nstatic int serial2002_di_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint chan;\r\nchan = devpriv->digital_in_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data read;\r\npoll_digital(devpriv->tty, chan);\r\nwhile (1) {\r\nread = serial_read(devpriv->tty, 1000);\r\nif (read.kind != is_digital || read.index == chan)\r\nbreak;\r\n}\r\ndata[n] = read.value;\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_do_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint chan;\r\nchan = devpriv->digital_out_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data write;\r\nwrite.kind = is_digital;\r\nwrite.index = chan;\r\nwrite.value = data[n];\r\nserial_write(devpriv->tty, write);\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint chan;\r\nchan = devpriv->analog_in_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data read;\r\npoll_channel(devpriv->tty, chan);\r\nwhile (1) {\r\nread = serial_read(devpriv->tty, 1000);\r\nif (read.kind != is_channel || read.index == chan)\r\nbreak;\r\n}\r\ndata[n] = read.value;\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_ao_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint chan;\r\nchan = devpriv->analog_out_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data write;\r\nwrite.kind = is_channel;\r\nwrite.index = chan;\r\nwrite.value = data[n];\r\nserial_write(devpriv->tty, write);\r\ndevpriv->ao_readback[chan] = data[n];\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_ao_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = devpriv->ao_readback[chan];\r\nreturn n;\r\n}\r\nstatic int serial2002_ei_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint chan;\r\nchan = devpriv->encoder_in_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data read;\r\npoll_channel(devpriv->tty, chan);\r\nwhile (1) {\r\nread = serial_read(devpriv->tty, 1000);\r\nif (read.kind != is_channel || read.index == chan)\r\nbreak;\r\n}\r\ndata[n] = read.value;\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nprintk("comedi%d: serial2002: ", dev->minor);\r\ndev->board_name = thisboard->name;\r\nif (alloc_private(dev, sizeof(struct serial2002_private)) < 0)\r\nreturn -ENOMEM;\r\ndev->open = serial_2002_open;\r\ndev->close = serial_2002_close;\r\ndevpriv->port = it->options[0];\r\ndevpriv->speed = it->options[1];\r\nprintk("/dev/ttyS%d @ %d\n", devpriv->port, devpriv->speed);\r\nif (alloc_subdevices(dev, 5) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_read = &serial2002_di_rinsn;\r\ns = dev->subdevices + 1;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_write = &serial2002_do_winsn;\r\ns = dev->subdevices + 2;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = 0;\r\ns->insn_read = &serial2002_ai_rinsn;\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = 0;\r\ns->insn_write = &serial2002_ao_winsn;\r\ns->insn_read = &serial2002_ao_rinsn;\r\ns = dev->subdevices + 4;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_LSAMPL;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = 0;\r\ns->insn_read = &serial2002_ei_rinsn;\r\nreturn 1;\r\n}\r\nstatic int serial2002_detach(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nint i;\r\nprintk("comedi%d: serial2002: remove\n", dev->minor);\r\nfor (i = 0; i < 5; i++) {\r\ns = &dev->subdevices[i];\r\nkfree(s->maxdata_list);\r\nkfree(s->range_table_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init driver_serial2002_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_serial2002);\r\n}\r\nstatic void __exit driver_serial2002_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_serial2002);\r\n}
