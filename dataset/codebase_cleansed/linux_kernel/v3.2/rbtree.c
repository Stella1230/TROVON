static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)\r\n{\r\nstruct rb_node *right = node->rb_right;\r\nstruct rb_node *parent = rb_parent(node);\r\nif ((node->rb_right = right->rb_left))\r\nrb_set_parent(right->rb_left, node);\r\nright->rb_left = node;\r\nrb_set_parent(right, parent);\r\nif (parent)\r\n{\r\nif (node == parent->rb_left)\r\nparent->rb_left = right;\r\nelse\r\nparent->rb_right = right;\r\n}\r\nelse\r\nroot->rb_node = right;\r\nrb_set_parent(node, right);\r\n}\r\nstatic void __rb_rotate_right(struct rb_node *node, struct rb_root *root)\r\n{\r\nstruct rb_node *left = node->rb_left;\r\nstruct rb_node *parent = rb_parent(node);\r\nif ((node->rb_left = left->rb_right))\r\nrb_set_parent(left->rb_right, node);\r\nleft->rb_right = node;\r\nrb_set_parent(left, parent);\r\nif (parent)\r\n{\r\nif (node == parent->rb_right)\r\nparent->rb_right = left;\r\nelse\r\nparent->rb_left = left;\r\n}\r\nelse\r\nroot->rb_node = left;\r\nrb_set_parent(node, left);\r\n}\r\nvoid rb_insert_color(struct rb_node *node, struct rb_root *root)\r\n{\r\nstruct rb_node *parent, *gparent;\r\nwhile ((parent = rb_parent(node)) && rb_is_red(parent))\r\n{\r\ngparent = rb_parent(parent);\r\nif (parent == gparent->rb_left)\r\n{\r\n{\r\nregister struct rb_node *uncle = gparent->rb_right;\r\nif (uncle && rb_is_red(uncle))\r\n{\r\nrb_set_black(uncle);\r\nrb_set_black(parent);\r\nrb_set_red(gparent);\r\nnode = gparent;\r\ncontinue;\r\n}\r\n}\r\nif (parent->rb_right == node)\r\n{\r\nregister struct rb_node *tmp;\r\n__rb_rotate_left(parent, root);\r\ntmp = parent;\r\nparent = node;\r\nnode = tmp;\r\n}\r\nrb_set_black(parent);\r\nrb_set_red(gparent);\r\n__rb_rotate_right(gparent, root);\r\n} else {\r\n{\r\nregister struct rb_node *uncle = gparent->rb_left;\r\nif (uncle && rb_is_red(uncle))\r\n{\r\nrb_set_black(uncle);\r\nrb_set_black(parent);\r\nrb_set_red(gparent);\r\nnode = gparent;\r\ncontinue;\r\n}\r\n}\r\nif (parent->rb_left == node)\r\n{\r\nregister struct rb_node *tmp;\r\n__rb_rotate_right(parent, root);\r\ntmp = parent;\r\nparent = node;\r\nnode = tmp;\r\n}\r\nrb_set_black(parent);\r\nrb_set_red(gparent);\r\n__rb_rotate_left(gparent, root);\r\n}\r\n}\r\nrb_set_black(root->rb_node);\r\n}\r\nstatic void __rb_erase_color(struct rb_node *node, struct rb_node *parent,\r\nstruct rb_root *root)\r\n{\r\nstruct rb_node *other;\r\nwhile ((!node || rb_is_black(node)) && node != root->rb_node)\r\n{\r\nif (parent->rb_left == node)\r\n{\r\nother = parent->rb_right;\r\nif (rb_is_red(other))\r\n{\r\nrb_set_black(other);\r\nrb_set_red(parent);\r\n__rb_rotate_left(parent, root);\r\nother = parent->rb_right;\r\n}\r\nif ((!other->rb_left || rb_is_black(other->rb_left)) &&\r\n(!other->rb_right || rb_is_black(other->rb_right)))\r\n{\r\nrb_set_red(other);\r\nnode = parent;\r\nparent = rb_parent(node);\r\n}\r\nelse\r\n{\r\nif (!other->rb_right || rb_is_black(other->rb_right))\r\n{\r\nrb_set_black(other->rb_left);\r\nrb_set_red(other);\r\n__rb_rotate_right(other, root);\r\nother = parent->rb_right;\r\n}\r\nrb_set_color(other, rb_color(parent));\r\nrb_set_black(parent);\r\nrb_set_black(other->rb_right);\r\n__rb_rotate_left(parent, root);\r\nnode = root->rb_node;\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nother = parent->rb_left;\r\nif (rb_is_red(other))\r\n{\r\nrb_set_black(other);\r\nrb_set_red(parent);\r\n__rb_rotate_right(parent, root);\r\nother = parent->rb_left;\r\n}\r\nif ((!other->rb_left || rb_is_black(other->rb_left)) &&\r\n(!other->rb_right || rb_is_black(other->rb_right)))\r\n{\r\nrb_set_red(other);\r\nnode = parent;\r\nparent = rb_parent(node);\r\n}\r\nelse\r\n{\r\nif (!other->rb_left || rb_is_black(other->rb_left))\r\n{\r\nrb_set_black(other->rb_right);\r\nrb_set_red(other);\r\n__rb_rotate_left(other, root);\r\nother = parent->rb_left;\r\n}\r\nrb_set_color(other, rb_color(parent));\r\nrb_set_black(parent);\r\nrb_set_black(other->rb_left);\r\n__rb_rotate_right(parent, root);\r\nnode = root->rb_node;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (node)\r\nrb_set_black(node);\r\n}\r\nvoid rb_erase(struct rb_node *node, struct rb_root *root)\r\n{\r\nstruct rb_node *child, *parent;\r\nint color;\r\nif (!node->rb_left)\r\nchild = node->rb_right;\r\nelse if (!node->rb_right)\r\nchild = node->rb_left;\r\nelse\r\n{\r\nstruct rb_node *old = node, *left;\r\nnode = node->rb_right;\r\nwhile ((left = node->rb_left) != NULL)\r\nnode = left;\r\nif (rb_parent(old)) {\r\nif (rb_parent(old)->rb_left == old)\r\nrb_parent(old)->rb_left = node;\r\nelse\r\nrb_parent(old)->rb_right = node;\r\n} else\r\nroot->rb_node = node;\r\nchild = node->rb_right;\r\nparent = rb_parent(node);\r\ncolor = rb_color(node);\r\nif (parent == old) {\r\nparent = node;\r\n} else {\r\nif (child)\r\nrb_set_parent(child, parent);\r\nparent->rb_left = child;\r\nnode->rb_right = old->rb_right;\r\nrb_set_parent(old->rb_right, node);\r\n}\r\nnode->rb_parent_color = old->rb_parent_color;\r\nnode->rb_left = old->rb_left;\r\nrb_set_parent(old->rb_left, node);\r\ngoto color;\r\n}\r\nparent = rb_parent(node);\r\ncolor = rb_color(node);\r\nif (child)\r\nrb_set_parent(child, parent);\r\nif (parent)\r\n{\r\nif (parent->rb_left == node)\r\nparent->rb_left = child;\r\nelse\r\nparent->rb_right = child;\r\n}\r\nelse\r\nroot->rb_node = child;\r\ncolor:\r\nif (color == RB_BLACK)\r\n__rb_erase_color(child, parent, root);\r\n}\r\nstatic void rb_augment_path(struct rb_node *node, rb_augment_f func, void *data)\r\n{\r\nstruct rb_node *parent;\r\nup:\r\nfunc(node, data);\r\nparent = rb_parent(node);\r\nif (!parent)\r\nreturn;\r\nif (node == parent->rb_left && parent->rb_right)\r\nfunc(parent->rb_right, data);\r\nelse if (parent->rb_left)\r\nfunc(parent->rb_left, data);\r\nnode = parent;\r\ngoto up;\r\n}\r\nvoid rb_augment_insert(struct rb_node *node, rb_augment_f func, void *data)\r\n{\r\nif (node->rb_left)\r\nnode = node->rb_left;\r\nelse if (node->rb_right)\r\nnode = node->rb_right;\r\nrb_augment_path(node, func, data);\r\n}\r\nstruct rb_node *rb_augment_erase_begin(struct rb_node *node)\r\n{\r\nstruct rb_node *deepest;\r\nif (!node->rb_right && !node->rb_left)\r\ndeepest = rb_parent(node);\r\nelse if (!node->rb_right)\r\ndeepest = node->rb_left;\r\nelse if (!node->rb_left)\r\ndeepest = node->rb_right;\r\nelse {\r\ndeepest = rb_next(node);\r\nif (deepest->rb_right)\r\ndeepest = deepest->rb_right;\r\nelse if (rb_parent(deepest) != node)\r\ndeepest = rb_parent(deepest);\r\n}\r\nreturn deepest;\r\n}\r\nvoid rb_augment_erase_end(struct rb_node *node, rb_augment_f func, void *data)\r\n{\r\nif (node)\r\nrb_augment_path(node, func, data);\r\n}\r\nstruct rb_node *rb_first(const struct rb_root *root)\r\n{\r\nstruct rb_node *n;\r\nn = root->rb_node;\r\nif (!n)\r\nreturn NULL;\r\nwhile (n->rb_left)\r\nn = n->rb_left;\r\nreturn n;\r\n}\r\nstruct rb_node *rb_last(const struct rb_root *root)\r\n{\r\nstruct rb_node *n;\r\nn = root->rb_node;\r\nif (!n)\r\nreturn NULL;\r\nwhile (n->rb_right)\r\nn = n->rb_right;\r\nreturn n;\r\n}\r\nstruct rb_node *rb_next(const struct rb_node *node)\r\n{\r\nstruct rb_node *parent;\r\nif (rb_parent(node) == node)\r\nreturn NULL;\r\nif (node->rb_right) {\r\nnode = node->rb_right;\r\nwhile (node->rb_left)\r\nnode=node->rb_left;\r\nreturn (struct rb_node *)node;\r\n}\r\nwhile ((parent = rb_parent(node)) && node == parent->rb_right)\r\nnode = parent;\r\nreturn parent;\r\n}\r\nstruct rb_node *rb_prev(const struct rb_node *node)\r\n{\r\nstruct rb_node *parent;\r\nif (rb_parent(node) == node)\r\nreturn NULL;\r\nif (node->rb_left) {\r\nnode = node->rb_left;\r\nwhile (node->rb_right)\r\nnode=node->rb_right;\r\nreturn (struct rb_node *)node;\r\n}\r\nwhile ((parent = rb_parent(node)) && node == parent->rb_left)\r\nnode = parent;\r\nreturn parent;\r\n}\r\nvoid rb_replace_node(struct rb_node *victim, struct rb_node *new,\r\nstruct rb_root *root)\r\n{\r\nstruct rb_node *parent = rb_parent(victim);\r\nif (parent) {\r\nif (victim == parent->rb_left)\r\nparent->rb_left = new;\r\nelse\r\nparent->rb_right = new;\r\n} else {\r\nroot->rb_node = new;\r\n}\r\nif (victim->rb_left)\r\nrb_set_parent(victim->rb_left, new);\r\nif (victim->rb_right)\r\nrb_set_parent(victim->rb_right, new);\r\n*new = *victim;\r\n}
