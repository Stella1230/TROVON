void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)\r\n{\r\nassert_spin_locked(&c->erase_completion_lock);\r\nif (c->gc_task && jffs2_thread_should_wake(c))\r\nsend_sig(SIGHUP, c->gc_task, 1);\r\n}\r\nint jffs2_start_garbage_collect_thread(struct jffs2_sb_info *c)\r\n{\r\nstruct task_struct *tsk;\r\nint ret = 0;\r\nBUG_ON(c->gc_task);\r\ninit_completion(&c->gc_thread_start);\r\ninit_completion(&c->gc_thread_exit);\r\ntsk = kthread_run(jffs2_garbage_collect_thread, c, "jffs2_gcd_mtd%d", c->mtd->index);\r\nif (IS_ERR(tsk)) {\r\nprintk(KERN_WARNING "fork failed for JFFS2 garbage collect thread: %ld\n", -PTR_ERR(tsk));\r\ncomplete(&c->gc_thread_exit);\r\nret = PTR_ERR(tsk);\r\n} else {\r\nD1(printk(KERN_DEBUG "JFFS2: Garbage collect thread is pid %d\n", tsk->pid));\r\nwait_for_completion(&c->gc_thread_start);\r\nret = tsk->pid;\r\n}\r\nreturn ret;\r\n}\r\nvoid jffs2_stop_garbage_collect_thread(struct jffs2_sb_info *c)\r\n{\r\nint wait = 0;\r\nspin_lock(&c->erase_completion_lock);\r\nif (c->gc_task) {\r\nD1(printk(KERN_DEBUG "jffs2: Killing GC task %d\n", c->gc_task->pid));\r\nsend_sig(SIGKILL, c->gc_task, 1);\r\nwait = 1;\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nif (wait)\r\nwait_for_completion(&c->gc_thread_exit);\r\n}\r\nstatic int jffs2_garbage_collect_thread(void *_c)\r\n{\r\nstruct jffs2_sb_info *c = _c;\r\nallow_signal(SIGKILL);\r\nallow_signal(SIGSTOP);\r\nallow_signal(SIGCONT);\r\nc->gc_task = current;\r\ncomplete(&c->gc_thread_start);\r\nset_user_nice(current, 10);\r\nset_freezable();\r\nfor (;;) {\r\nallow_signal(SIGHUP);\r\nagain:\r\nspin_lock(&c->erase_completion_lock);\r\nif (!jffs2_thread_should_wake(c)) {\r\nset_current_state (TASK_INTERRUPTIBLE);\r\nspin_unlock(&c->erase_completion_lock);\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_thread sleeping...\n"));\r\nschedule();\r\n} else\r\nspin_unlock(&c->erase_completion_lock);\r\nschedule_timeout_interruptible(msecs_to_jiffies(50));\r\nif (kthread_should_stop()) {\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): kthread_stop() called.\n"));\r\ngoto die;\r\n}\r\nwhile (signal_pending(current) || freezing(current)) {\r\nsiginfo_t info;\r\nunsigned long signr;\r\nif (try_to_freeze())\r\ngoto again;\r\nsignr = dequeue_signal_lock(current, &current->blocked, &info);\r\nswitch(signr) {\r\ncase SIGSTOP:\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGSTOP received.\n"));\r\nset_current_state(TASK_STOPPED);\r\nschedule();\r\nbreak;\r\ncase SIGKILL:\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGKILL received.\n"));\r\ngoto die;\r\ncase SIGHUP:\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGHUP received.\n"));\r\nbreak;\r\ndefault:\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): signal %ld received\n", signr));\r\n}\r\n}\r\ndisallow_signal(SIGHUP);\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): pass\n"));\r\nif (jffs2_garbage_collect_pass(c) == -ENOSPC) {\r\nprintk(KERN_NOTICE "No space for garbage collection. Aborting GC thread\n");\r\ngoto die;\r\n}\r\n}\r\ndie:\r\nspin_lock(&c->erase_completion_lock);\r\nc->gc_task = NULL;\r\nspin_unlock(&c->erase_completion_lock);\r\ncomplete_and_exit(&c->gc_thread_exit, 0);\r\n}
