int edac_mc_get_log_ue(void)\r\n{\r\nreturn edac_mc_log_ue;\r\n}\r\nint edac_mc_get_log_ce(void)\r\n{\r\nreturn edac_mc_log_ce;\r\n}\r\nint edac_mc_get_panic_on_ue(void)\r\n{\r\nreturn edac_mc_panic_on_ue;\r\n}\r\nint edac_mc_get_poll_msec(void)\r\n{\r\nreturn edac_mc_poll_msec;\r\n}\r\nstatic int edac_set_poll_msec(const char *val, struct kernel_param *kp)\r\n{\r\nlong l;\r\nint ret;\r\nif (!val)\r\nreturn -EINVAL;\r\nret = strict_strtol(val, 0, &l);\r\nif (ret == -EINVAL || ((int)l != l))\r\nreturn -EINVAL;\r\n*((int *)kp->arg) = l;\r\nedac_mc_reset_delay_period(l);\r\nreturn 0;\r\n}\r\nstatic ssize_t csrow_ue_count_show(struct csrow_info *csrow, char *data,\r\nint private)\r\n{\r\nreturn sprintf(data, "%u\n", csrow->ue_count);\r\n}\r\nstatic ssize_t csrow_ce_count_show(struct csrow_info *csrow, char *data,\r\nint private)\r\n{\r\nreturn sprintf(data, "%u\n", csrow->ce_count);\r\n}\r\nstatic ssize_t csrow_size_show(struct csrow_info *csrow, char *data,\r\nint private)\r\n{\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(csrow->nr_pages));\r\n}\r\nstatic ssize_t csrow_mem_type_show(struct csrow_info *csrow, char *data,\r\nint private)\r\n{\r\nreturn sprintf(data, "%s\n", mem_types[csrow->mtype]);\r\n}\r\nstatic ssize_t csrow_dev_type_show(struct csrow_info *csrow, char *data,\r\nint private)\r\n{\r\nreturn sprintf(data, "%s\n", dev_types[csrow->dtype]);\r\n}\r\nstatic ssize_t csrow_edac_mode_show(struct csrow_info *csrow, char *data,\r\nint private)\r\n{\r\nreturn sprintf(data, "%s\n", edac_caps[csrow->edac_mode]);\r\n}\r\nstatic ssize_t channel_dimm_label_show(struct csrow_info *csrow,\r\nchar *data, int channel)\r\n{\r\nif (!csrow->channels[channel].label[0])\r\nreturn 0;\r\nreturn snprintf(data, EDAC_MC_LABEL_LEN, "%s\n",\r\ncsrow->channels[channel].label);\r\n}\r\nstatic ssize_t channel_dimm_label_store(struct csrow_info *csrow,\r\nconst char *data,\r\nsize_t count, int channel)\r\n{\r\nssize_t max_size = 0;\r\nmax_size = min((ssize_t) count, (ssize_t) EDAC_MC_LABEL_LEN - 1);\r\nstrncpy(csrow->channels[channel].label, data, max_size);\r\ncsrow->channels[channel].label[max_size] = '\0';\r\nreturn max_size;\r\n}\r\nstatic ssize_t channel_ce_count_show(struct csrow_info *csrow,\r\nchar *data, int channel)\r\n{\r\nreturn sprintf(data, "%u\n", csrow->channels[channel].ce_count);\r\n}\r\nstatic ssize_t csrowdev_show(struct kobject *kobj,\r\nstruct attribute *attr, char *buffer)\r\n{\r\nstruct csrow_info *csrow = to_csrow(kobj);\r\nstruct csrowdev_attribute *csrowdev_attr = to_csrowdev_attr(attr);\r\nif (csrowdev_attr->show)\r\nreturn csrowdev_attr->show(csrow,\r\nbuffer, csrowdev_attr->private);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t csrowdev_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct csrow_info *csrow = to_csrow(kobj);\r\nstruct csrowdev_attribute *csrowdev_attr = to_csrowdev_attr(attr);\r\nif (csrowdev_attr->store)\r\nreturn csrowdev_attr->store(csrow,\r\nbuffer,\r\ncount, csrowdev_attr->private);\r\nreturn -EIO;\r\n}\r\nstatic int edac_create_channel_files(struct kobject *kobj, int chan)\r\n{\r\nint err = -ENODEV;\r\nif (chan >= EDAC_NR_CHANNELS)\r\nreturn err;\r\nerr = sysfs_create_file(kobj,\r\n(struct attribute *)\r\ndynamic_csrow_dimm_attr[chan]);\r\nif (!err) {\r\nerr = sysfs_create_file(kobj,\r\n(struct attribute *)\r\ndynamic_csrow_ce_count_attr[chan]);\r\n} else {\r\ndebugf1("%s() dimm labels and ce_count files created",\r\n__func__);\r\n}\r\nreturn err;\r\n}\r\nstatic void edac_csrow_instance_release(struct kobject *kobj)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct csrow_info *cs;\r\ndebugf1("%s()\n", __func__);\r\ncs = container_of(kobj, struct csrow_info, kobj);\r\nmci = cs->mci;\r\nkobject_put(&mci->edac_mci_kobj);\r\n}\r\nstatic int edac_create_csrow_object(struct mem_ctl_info *mci,\r\nstruct csrow_info *csrow, int index)\r\n{\r\nstruct kobject *kobj_mci = &mci->edac_mci_kobj;\r\nstruct kobject *kobj;\r\nint chan;\r\nint err;\r\nmemset(&csrow->kobj, 0, sizeof(csrow->kobj));\r\ncsrow->mci = mci;\r\nkobj = kobject_get(&mci->edac_mci_kobj);\r\nif (!kobj) {\r\nerr = -ENODEV;\r\ngoto err_out;\r\n}\r\nerr = kobject_init_and_add(&csrow->kobj, &ktype_csrow, kobj_mci,\r\n"csrow%d", index);\r\nif (err)\r\ngoto err_release_top_kobj;\r\nfor (chan = 0; chan < csrow->nr_channels; chan++) {\r\nerr = edac_create_channel_files(&csrow->kobj, chan);\r\nif (err) {\r\nkobject_put(&csrow->kobj);\r\ngoto err_out;\r\n}\r\n}\r\nkobject_uevent(&csrow->kobj, KOBJ_ADD);\r\nreturn 0;\r\nerr_release_top_kobj:\r\nkobject_put(&mci->edac_mci_kobj);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic ssize_t mci_reset_counters_store(struct mem_ctl_info *mci,\r\nconst char *data, size_t count)\r\n{\r\nint row, chan;\r\nmci->ue_noinfo_count = 0;\r\nmci->ce_noinfo_count = 0;\r\nmci->ue_count = 0;\r\nmci->ce_count = 0;\r\nfor (row = 0; row < mci->nr_csrows; row++) {\r\nstruct csrow_info *ri = &mci->csrows[row];\r\nri->ue_count = 0;\r\nri->ce_count = 0;\r\nfor (chan = 0; chan < ri->nr_channels; chan++)\r\nri->channels[chan].ce_count = 0;\r\n}\r\nmci->start_time = jiffies;\r\nreturn count;\r\n}\r\nstatic ssize_t mci_sdram_scrub_rate_store(struct mem_ctl_info *mci,\r\nconst char *data, size_t count)\r\n{\r\nunsigned long bandwidth = 0;\r\nint new_bw = 0;\r\nif (!mci->set_sdram_scrub_rate)\r\nreturn -EINVAL;\r\nif (strict_strtoul(data, 10, &bandwidth) < 0)\r\nreturn -EINVAL;\r\nnew_bw = mci->set_sdram_scrub_rate(mci, bandwidth);\r\nif (new_bw < 0) {\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"Error setting scrub rate to: %lu\n", bandwidth);\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t mci_sdram_scrub_rate_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nint bandwidth = 0;\r\nif (!mci->get_sdram_scrub_rate)\r\nreturn -EINVAL;\r\nbandwidth = mci->get_sdram_scrub_rate(mci);\r\nif (bandwidth < 0) {\r\nedac_printk(KERN_DEBUG, EDAC_MC, "Error reading scrub rate\n");\r\nreturn bandwidth;\r\n}\r\nreturn sprintf(data, "%d\n", bandwidth);\r\n}\r\nstatic ssize_t mci_ue_count_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nreturn sprintf(data, "%d\n", mci->ue_count);\r\n}\r\nstatic ssize_t mci_ce_count_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nreturn sprintf(data, "%d\n", mci->ce_count);\r\n}\r\nstatic ssize_t mci_ce_noinfo_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nreturn sprintf(data, "%d\n", mci->ce_noinfo_count);\r\n}\r\nstatic ssize_t mci_ue_noinfo_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nreturn sprintf(data, "%d\n", mci->ue_noinfo_count);\r\n}\r\nstatic ssize_t mci_seconds_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nreturn sprintf(data, "%ld\n", (jiffies - mci->start_time) / HZ);\r\n}\r\nstatic ssize_t mci_ctl_name_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nreturn sprintf(data, "%s\n", mci->ctl_name);\r\n}\r\nstatic ssize_t mci_size_mb_show(struct mem_ctl_info *mci, char *data)\r\n{\r\nint total_pages, csrow_idx;\r\nfor (total_pages = csrow_idx = 0; csrow_idx < mci->nr_csrows;\r\ncsrow_idx++) {\r\nstruct csrow_info *csrow = &mci->csrows[csrow_idx];\r\nif (!csrow->nr_pages)\r\ncontinue;\r\ntotal_pages += csrow->nr_pages;\r\n}\r\nreturn sprintf(data, "%u\n", PAGES_TO_MiB(total_pages));\r\n}\r\nstatic ssize_t mcidev_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mem_ctl_info *mem_ctl_info = to_mci(kobj);\r\nstruct mcidev_sysfs_attribute *mcidev_attr = to_mcidev_attr(attr);\r\ndebugf1("%s() mem_ctl_info %p\n", __func__, mem_ctl_info);\r\nif (mcidev_attr->show)\r\nreturn mcidev_attr->show(mem_ctl_info, buffer);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t mcidev_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct mem_ctl_info *mem_ctl_info = to_mci(kobj);\r\nstruct mcidev_sysfs_attribute *mcidev_attr = to_mcidev_attr(attr);\r\ndebugf1("%s() mem_ctl_info %p\n", __func__, mem_ctl_info);\r\nif (mcidev_attr->store)\r\nreturn mcidev_attr->store(mem_ctl_info, buffer, count);\r\nreturn -EIO;\r\n}\r\nstatic void edac_mci_control_release(struct kobject *kobj)\r\n{\r\nstruct mem_ctl_info *mci;\r\nmci = to_mci(kobj);\r\ndebugf0("%s() mci instance idx=%d releasing\n", __func__, mci->mc_idx);\r\nmodule_put(mci->owner);\r\n}\r\nint edac_mc_register_sysfs_main_kobj(struct mem_ctl_info *mci)\r\n{\r\nstruct kobject *kobj_mci;\r\nint err;\r\ndebugf1("%s()\n", __func__);\r\nkobj_mci = &mci->edac_mci_kobj;\r\nmemset(kobj_mci, 0, sizeof(*kobj_mci));\r\nmci->owner = THIS_MODULE;\r\nif (!try_module_get(mci->owner)) {\r\nerr = -ENODEV;\r\ngoto fail_out;\r\n}\r\nkobj_mci->kset = mc_kset;\r\nerr = kobject_init_and_add(kobj_mci, &ktype_mci, NULL,\r\n"mc%d", mci->mc_idx);\r\nif (err) {\r\ndebugf1("%s()Failed to register '.../edac/mc%d'\n",\r\n__func__, mci->mc_idx);\r\ngoto kobj_reg_fail;\r\n}\r\nkobject_uevent(kobj_mci, KOBJ_ADD);\r\ndebugf1("%s() Registered '.../edac/mc%d' kobject\n",\r\n__func__, mci->mc_idx);\r\nreturn 0;\r\nkobj_reg_fail:\r\nmodule_put(mci->owner);\r\nfail_out:\r\nreturn err;\r\n}\r\nvoid edac_mc_unregister_sysfs_main_kobj(struct mem_ctl_info *mci)\r\n{\r\ndebugf1("%s()\n", __func__);\r\nkobject_put(&mci->edac_mci_kobj);\r\n}\r\nstatic ssize_t inst_grp_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mem_ctl_info *mem_ctl_info = grp_to_mci(kobj);\r\nstruct mcidev_sysfs_attribute *mcidev_attr = to_mcidev_attr(attr);\r\ndebugf1("%s() mem_ctl_info %p\n", __func__, mem_ctl_info);\r\nif (mcidev_attr->show)\r\nreturn mcidev_attr->show(mem_ctl_info, buffer);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t inst_grp_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct mem_ctl_info *mem_ctl_info = grp_to_mci(kobj);\r\nstruct mcidev_sysfs_attribute *mcidev_attr = to_mcidev_attr(attr);\r\ndebugf1("%s() mem_ctl_info %p\n", __func__, mem_ctl_info);\r\nif (mcidev_attr->store)\r\nreturn mcidev_attr->store(mem_ctl_info, buffer, count);\r\nreturn -EIO;\r\n}\r\nstatic void edac_inst_grp_release(struct kobject *kobj)\r\n{\r\nstruct mcidev_sysfs_group_kobj *grp;\r\nstruct mem_ctl_info *mci;\r\ndebugf1("%s()\n", __func__);\r\ngrp = container_of(kobj, struct mcidev_sysfs_group_kobj, kobj);\r\nmci = grp->mci;\r\n}\r\nstatic int edac_create_mci_instance_attributes(struct mem_ctl_info *mci,\r\nconst struct mcidev_sysfs_attribute *sysfs_attrib,\r\nstruct kobject *kobj)\r\n{\r\nint err;\r\ndebugf4("%s()\n", __func__);\r\nwhile (sysfs_attrib) {\r\ndebugf4("%s() sysfs_attrib = %p\n",__func__, sysfs_attrib);\r\nif (sysfs_attrib->grp) {\r\nstruct mcidev_sysfs_group_kobj *grp_kobj;\r\ngrp_kobj = kzalloc(sizeof(*grp_kobj), GFP_KERNEL);\r\nif (!grp_kobj)\r\nreturn -ENOMEM;\r\ngrp_kobj->grp = sysfs_attrib->grp;\r\ngrp_kobj->mci = mci;\r\nlist_add_tail(&grp_kobj->list, &mci->grp_kobj_list);\r\ndebugf0("%s() grp %s, mci %p\n", __func__,\r\nsysfs_attrib->grp->name, mci);\r\nerr = kobject_init_and_add(&grp_kobj->kobj,\r\n&ktype_inst_grp,\r\n&mci->edac_mci_kobj,\r\nsysfs_attrib->grp->name);\r\nif (err < 0) {\r\nprintk(KERN_ERR "kobject_init_and_add failed: %d\n", err);\r\nreturn err;\r\n}\r\nerr = edac_create_mci_instance_attributes(mci,\r\ngrp_kobj->grp->mcidev_attr,\r\n&grp_kobj->kobj);\r\nif (err < 0)\r\nreturn err;\r\n} else if (sysfs_attrib->attr.name) {\r\ndebugf4("%s() file %s\n", __func__,\r\nsysfs_attrib->attr.name);\r\nerr = sysfs_create_file(kobj, &sysfs_attrib->attr);\r\nif (err < 0) {\r\nprintk(KERN_ERR "sysfs_create_file failed: %d\n", err);\r\nreturn err;\r\n}\r\n} else\r\nbreak;\r\nsysfs_attrib++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void edac_remove_mci_instance_attributes(struct mem_ctl_info *mci,\r\nconst struct mcidev_sysfs_attribute *sysfs_attrib,\r\nstruct kobject *kobj, int count)\r\n{\r\nstruct mcidev_sysfs_group_kobj *grp_kobj, *tmp;\r\ndebugf1("%s()\n", __func__);\r\nwhile (sysfs_attrib) {\r\ndebugf4("%s() sysfs_attrib = %p\n",__func__, sysfs_attrib);\r\nif (sysfs_attrib->grp) {\r\ndebugf4("%s() seeking for group %s\n",\r\n__func__, sysfs_attrib->grp->name);\r\nlist_for_each_entry(grp_kobj,\r\n&mci->grp_kobj_list, list) {\r\ndebugf4("%s() grp_kobj->grp = %p\n",__func__, grp_kobj->grp);\r\nif (grp_kobj->grp == sysfs_attrib->grp) {\r\nedac_remove_mci_instance_attributes(mci,\r\ngrp_kobj->grp->mcidev_attr,\r\n&grp_kobj->kobj, count + 1);\r\ndebugf4("%s() group %s\n", __func__,\r\nsysfs_attrib->grp->name);\r\nkobject_put(&grp_kobj->kobj);\r\n}\r\n}\r\ndebugf4("%s() end of seeking for group %s\n",\r\n__func__, sysfs_attrib->grp->name);\r\n} else if (sysfs_attrib->attr.name) {\r\ndebugf4("%s() file %s\n", __func__,\r\nsysfs_attrib->attr.name);\r\nsysfs_remove_file(kobj, &sysfs_attrib->attr);\r\n} else\r\nbreak;\r\nsysfs_attrib++;\r\n}\r\nif (count)\r\nreturn;\r\nlist_for_each_entry_safe(grp_kobj, tmp,\r\n&mci->grp_kobj_list, list) {\r\nlist_del(&grp_kobj->list);\r\nkfree(grp_kobj);\r\n}\r\n}\r\nint edac_create_sysfs_mci_device(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\nint err;\r\nstruct csrow_info *csrow;\r\nstruct kobject *kobj_mci = &mci->edac_mci_kobj;\r\ndebugf0("%s() idx=%d\n", __func__, mci->mc_idx);\r\nINIT_LIST_HEAD(&mci->grp_kobj_list);\r\nerr = sysfs_create_link(kobj_mci, &mci->dev->kobj,\r\nEDAC_DEVICE_SYMLINK);\r\nif (err) {\r\ndebugf1("%s() failure to create symlink\n", __func__);\r\ngoto fail0;\r\n}\r\nif (mci->mc_driver_sysfs_attributes) {\r\nerr = edac_create_mci_instance_attributes(mci,\r\nmci->mc_driver_sysfs_attributes,\r\n&mci->edac_mci_kobj);\r\nif (err) {\r\ndebugf1("%s() failure to create mci attributes\n",\r\n__func__);\r\ngoto fail0;\r\n}\r\n}\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\ncsrow = &mci->csrows[i];\r\nif (csrow->nr_pages > 0) {\r\nerr = edac_create_csrow_object(mci, csrow, i);\r\nif (err) {\r\ndebugf1("%s() failure: create csrow %d obj\n",\r\n__func__, i);\r\ngoto fail1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\nfor (i--; i >= 0; i--) {\r\nif (csrow->nr_pages > 0) {\r\nkobject_put(&mci->csrows[i].kobj);\r\n}\r\n}\r\nedac_remove_mci_instance_attributes(mci,\r\nmci->mc_driver_sysfs_attributes, &mci->edac_mci_kobj, 0);\r\nsysfs_remove_link(kobj_mci, EDAC_DEVICE_SYMLINK);\r\nfail0:\r\nreturn err;\r\n}\r\nvoid edac_remove_sysfs_mci_device(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\ndebugf0("%s()\n", __func__);\r\ndebugf4("%s() unregister this mci kobj\n", __func__);\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nif (mci->csrows[i].nr_pages > 0) {\r\ndebugf0("%s() unreg csrow-%d\n", __func__, i);\r\nkobject_put(&mci->csrows[i].kobj);\r\n}\r\n}\r\nif (mci->mc_driver_sysfs_attributes) {\r\ndebugf4("%s() unregister mci private attributes\n", __func__);\r\nedac_remove_mci_instance_attributes(mci,\r\nmci->mc_driver_sysfs_attributes,\r\n&mci->edac_mci_kobj, 0);\r\n}\r\ndebugf4("%s() remove_link\n", __func__);\r\nsysfs_remove_link(&mci->edac_mci_kobj, EDAC_DEVICE_SYMLINK);\r\ndebugf4("%s() remove_mci_instance\n", __func__);\r\nkobject_put(&mci->edac_mci_kobj);\r\n}\r\nint edac_sysfs_setup_mc_kset(void)\r\n{\r\nint err = -EINVAL;\r\nstruct sysdev_class *edac_class;\r\ndebugf1("%s()\n", __func__);\r\nedac_class = edac_get_sysfs_class();\r\nif (edac_class == NULL) {\r\ndebugf1("%s() no edac_class error=%d\n", __func__, err);\r\ngoto fail_out;\r\n}\r\nmc_kset = kset_create_and_add("mc", NULL, &edac_class->kset.kobj);\r\nif (!mc_kset) {\r\nerr = -ENOMEM;\r\ndebugf1("%s() Failed to register '.../edac/mc'\n", __func__);\r\ngoto fail_kset;\r\n}\r\ndebugf1("%s() Registered '.../edac/mc' kobject\n", __func__);\r\nreturn 0;\r\nfail_kset:\r\nedac_put_sysfs_class();\r\nfail_out:\r\nreturn err;\r\n}\r\nvoid edac_sysfs_teardown_mc_kset(void)\r\n{\r\nkset_unregister(mc_kset);\r\nedac_put_sysfs_class();\r\n}
