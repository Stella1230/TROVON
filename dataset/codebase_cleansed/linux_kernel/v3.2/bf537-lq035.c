static void set_vcomm(void)\r\n{\r\nint nr;\r\nif (!ad5280_client)\r\nreturn;\r\nnr = i2c_smbus_write_byte_data(ad5280_client, 0x00, vcomm_value);\r\nif (nr)\r\npr_err("i2c_smbus_write_byte_data fail: %d\n", nr);\r\n}\r\nstatic int __devinit ad5280_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "SMBUS Byte Data not Supported\n");\r\nreturn -EIO;\r\n}\r\nret = i2c_smbus_write_byte_data(client, 0x00, vcomm_value);\r\nif (ret) {\r\ndev_err(&client->dev, "write fail: %d\n", ret);\r\nreturn ret;\r\n}\r\nad5280_client = client;\r\nreturn 0;\r\n}\r\nstatic int __devexit ad5280_remove(struct i2c_client *client)\r\n{\r\nad5280_client = NULL;\r\nreturn 0;\r\n}\r\nstatic void start_timers(void)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nbfin_write_TIMER_ENABLE(TIMEN_REV);\r\nSSYNC();\r\nwhile (bfin_read_TIMER_REV_COUNTER() <= 11)\r\ncontinue;\r\nbfin_write_TIMER_ENABLE(TIMEN_LP);\r\nSSYNC();\r\nwhile (bfin_read_TIMER_LP_COUNTER() < 3)\r\ncontinue;\r\nbfin_write_TIMER_ENABLE(TIMEN_SP|TIMEN_SPS|TIMEN_PS_CLS);\r\nSSYNC();\r\nt_conf_done = 1;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void config_timers(void)\r\n{\r\nbfin_write_TIMER_DISABLE(TIMDIS_SP|TIMDIS_SPS|TIMDIS_REV|\r\nTIMDIS_LP|TIMDIS_PS_CLS);\r\nSSYNC();\r\nbfin_write_TIMER_LP_CONFIG(TIMER_CONFIG|PULSE_HI);\r\nbfin_write_TIMER_LP_WIDTH(1);\r\nbfin_write_TIMER_LP_PERIOD(DCLKS_PER_LINE);\r\nSSYNC();\r\nbfin_write_TIMER_SPS_CONFIG(TIMER_CONFIG|PULSE_HI);\r\nbfin_write_TIMER_SPS_WIDTH(DCLKS_PER_LINE*2);\r\nbfin_write_TIMER_SPS_PERIOD((DCLKS_PER_LINE * (LCD_Y_RES+U_LINES)));\r\nSSYNC();\r\nbfin_write_TIMER_SP_CONFIG(TIMER_CONFIG|PULSE_HI);\r\nbfin_write_TIMER_SP_WIDTH(1);\r\nbfin_write_TIMER_SP_PERIOD(DCLKS_PER_LINE);\r\nSSYNC();\r\nbfin_write_TIMER_PS_CLS_CONFIG(TIMER_CONFIG);\r\nbfin_write_TIMER_PS_CLS_WIDTH(LCD_X_RES + START_LINES);\r\nbfin_write_TIMER_PS_CLS_PERIOD(DCLKS_PER_LINE);\r\nSSYNC();\r\n#ifdef NO_BL\r\nbfin_write_TIMER_REV_CONFIG(TIMER_CONFIG|PULSE_HI);\r\nbfin_write_TIMER_REV_WIDTH(DCLKS_PER_LINE);\r\nbfin_write_TIMER_REV_PERIOD(DCLKS_PER_LINE*2);\r\nSSYNC();\r\n#endif\r\n}\r\nstatic void config_ppi(void)\r\n{\r\nbfin_write_PPI_DELAY(PPI_DELAY_VALUE);\r\nbfin_write_PPI_COUNT(LCD_X_RES-1);\r\nbfin_write_PPI_CONTROL((PPI_CONFIG_VALUE|0x10) & (~POLS));\r\n}\r\nstatic int config_dma(void)\r\n{\r\nu32 i;\r\nif (landscape) {\r\nfor (i = 0; i < U_LINES; ++i) {\r\ndma_desc_table[2*i] = (unsigned long)&dma_desc_table[2*i+2];\r\ndma_desc_table[2*i+1] = (unsigned long)fb_buffer;\r\n}\r\nfor (i = U_LINES; i < U_LINES + LCD_Y_RES; ++i) {\r\ndma_desc_table[2*i] = (unsigned long)&dma_desc_table[2*i+2];\r\ndma_desc_table[2*i+1] = (unsigned long)fb_buffer +\r\n(LCD_Y_RES+U_LINES-1-i)*2;\r\n}\r\ndma_desc_table[2*(LCD_Y_RES+U_LINES-1)] = (unsigned long)&dma_desc_table[0];\r\nset_dma_x_count(CH_PPI, LCD_X_RES);\r\nset_dma_x_modify(CH_PPI, LCD_Y_RES * (LCD_BBP / 8));\r\nset_dma_y_count(CH_PPI, 0);\r\nset_dma_y_modify(CH_PPI, 0);\r\nset_dma_next_desc_addr(CH_PPI, (void *)dma_desc_table[0]);\r\nset_dma_config(CH_PPI, DMAFLOW_LARGE | NDSIZE_4 | WDSIZE_16);\r\n} else {\r\nset_dma_config(CH_PPI, set_bfin_dma_config(DIR_READ,\r\nDMA_FLOW_AUTO,\r\nINTR_DISABLE,\r\nDIMENSION_2D,\r\nDATA_SIZE_16,\r\nDMA_NOSYNC_KEEP_DMA_BUF));\r\nset_dma_x_count(CH_PPI, LCD_X_RES);\r\nset_dma_x_modify(CH_PPI, LCD_BBP / 8);\r\nset_dma_y_count(CH_PPI, LCD_Y_RES+U_LINES);\r\nset_dma_y_modify(CH_PPI, LCD_BBP / 8);\r\nset_dma_start_addr(CH_PPI, (unsigned long) fb_buffer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit request_ports(void)\r\n{\r\nu16 tmr_req[] = TIMERS;\r\nif (peripheral_request_list(ppi_pins, KBUILD_MODNAME)) {\r\npr_err("requesting PPI peripheral failed\n");\r\nreturn -EBUSY;\r\n}\r\nif (peripheral_request_list(tmr_req, KBUILD_MODNAME)) {\r\nperipheral_free_list(ppi_pins);\r\npr_err("requesting timer peripheral failed\n");\r\nreturn -EBUSY;\r\n}\r\n#if (defined(UD) && defined(LBR))\r\nif (gpio_request(UD, KBUILD_MODNAME)) {\r\npr_err("requesting GPIO %d failed\n", UD);\r\nreturn -EBUSY;\r\n}\r\nif (gpio_request(LBR, KBUILD_MODNAME)) {\r\npr_err("requesting GPIO %d failed\n", LBR);\r\ngpio_free(UD);\r\nreturn -EBUSY;\r\n}\r\ngpio_direction_output(UD, 0);\r\ngpio_direction_output(LBR, 1);\r\n#endif\r\nif (gpio_request(MOD, KBUILD_MODNAME)) {\r\npr_err("requesting GPIO %d failed\n", MOD);\r\n#if (defined(UD) && defined(LBR))\r\ngpio_free(LBR);\r\ngpio_free(UD);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\ngpio_direction_output(MOD, 1);\r\nSSYNC();\r\nreturn 0;\r\n}\r\nstatic void free_ports(void)\r\n{\r\nu16 tmr_req[] = TIMERS;\r\nperipheral_free_list(ppi_pins);\r\nperipheral_free_list(tmr_req);\r\n#if defined(UD) && defined(LBR)\r\ngpio_free(LBR);\r\ngpio_free(UD);\r\n#endif\r\ngpio_free(MOD);\r\n}\r\nstatic int bfin_lq035_fb_open(struct fb_info *info, int user)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&bfin_lq035_lock, flags);\r\nlq035_open_cnt++;\r\nspin_unlock_irqrestore(&bfin_lq035_lock, flags);\r\nif (lq035_open_cnt <= 1) {\r\nbfin_write_PPI_CONTROL(0);\r\nSSYNC();\r\nset_vcomm();\r\nconfig_dma();\r\nconfig_ppi();\r\nenable_dma(CH_PPI);\r\nSSYNC();\r\nbfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() | PORT_EN);\r\nSSYNC();\r\nif (!t_conf_done) {\r\nconfig_timers();\r\nstart_timers();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035_fb_release(struct fb_info *info, int user)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&bfin_lq035_lock, flags);\r\nlq035_open_cnt--;\r\nspin_unlock_irqrestore(&bfin_lq035_lock, flags);\r\nif (lq035_open_cnt <= 0) {\r\nbfin_write_PPI_CONTROL(0);\r\nSSYNC();\r\ndisable_dma(CH_PPI);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nvar->red.offset = info->var.red.offset;\r\nvar->green.offset = info->var.green.offset;\r\nvar->blue.offset = info->var.blue.offset;\r\nvar->red.length = info->var.red.length;\r\nvar->green.length = info->var.green.length;\r\nvar->blue.length = info->var.blue.length;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nbreak;\r\ndefault:\r\npr_debug("%s: depth not supported: %u BPP\n", __func__,\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (info->var.xres != var->xres ||\r\ninfo->var.yres != var->yres ||\r\ninfo->var.xres_virtual != var->xres_virtual ||\r\ninfo->var.yres_virtual != var->yres_virtual) {\r\npr_debug("%s: Resolution not supported: X%u x Y%u\n",\r\n__func__, var->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif ((info->fix.line_length * var->yres_virtual) > info->fix.smem_len) {\r\npr_debug("%s: Memory Limit requested yres_virtual = %u\n",\r\n__func__, var->yres_virtual);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bfin_lq035_fb_rotate(struct fb_info *fbi, int angle)\r\n{\r\npr_debug("%s: %p %d", __func__, fbi, angle);\r\n#if (defined(UD) && defined(LBR))\r\nswitch (angle) {\r\ncase 180:\r\ngpio_set_value(LBR, 0);\r\ngpio_set_value(UD, 1);\r\nbreak;\r\ndefault:\r\ngpio_set_value(LBR, 1);\r\ngpio_set_value(UD, 0);\r\nbreak;\r\n}\r\n#endif\r\n}\r\nstatic int bfin_lq035_fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nif (nocursor)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int bfin_lq035_fb_setcolreg(u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp,\r\nstruct fb_info *info)\r\n{\r\nif (regno >= NBR_PALETTE)\r\nreturn -EINVAL;\r\nif (info->var.grayscale)\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 value;\r\nif (regno > 16)\r\nreturn -EINVAL;\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\nvalue = (red << info->var.red.offset) |\r\n(green << info->var.green.offset)|\r\n(blue << info->var.blue.offset);\r\nvalue &= 0xFFFF;\r\n((u32 *) (info->pseudo_palette))[regno] = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bl_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn current_brightness;\r\n}\r\nstatic int bfin_lcd_get_power(struct lcd_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_set_power(struct lcd_device *dev, int power)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_get_contrast(struct lcd_device *dev)\r\n{\r\nreturn (int)vcomm_value;\r\n}\r\nstatic int bfin_lcd_set_contrast(struct lcd_device *dev, int contrast)\r\n{\r\nif (contrast > 255)\r\ncontrast = 255;\r\nif (contrast < 0)\r\ncontrast = 0;\r\nvcomm_value = (unsigned char)contrast;\r\nset_vcomm();\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_check_fb(struct lcd_device *lcd, struct fb_info *fi)\r\n{\r\nif (!fi || (fi == &bfin_lq035_fb))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __devinit bfin_lq035_probe(struct platform_device *pdev)\r\n{\r\nstruct backlight_properties props;\r\ndma_addr_t dma_handle;\r\nint ret;\r\nif (request_dma(CH_PPI, KBUILD_MODNAME)) {\r\npr_err("couldn't request PPI DMA\n");\r\nreturn -EFAULT;\r\n}\r\nif (request_ports()) {\r\npr_err("couldn't request gpio port\n");\r\nret = -EFAULT;\r\ngoto out_ports;\r\n}\r\nfb_buffer = dma_alloc_coherent(NULL, TOTAL_VIDEO_MEM_SIZE,\r\n&dma_handle, GFP_KERNEL);\r\nif (fb_buffer == NULL) {\r\npr_err("couldn't allocate dma buffer\n");\r\nret = -ENOMEM;\r\ngoto out_dma_coherent;\r\n}\r\nif (L1_DATA_A_LENGTH)\r\ndma_desc_table = l1_data_sram_zalloc(TOTAL_DMA_DESC_SIZE);\r\nelse\r\ndma_desc_table = dma_alloc_coherent(NULL, TOTAL_DMA_DESC_SIZE,\r\n&dma_handle, 0);\r\nif (dma_desc_table == NULL) {\r\npr_err("couldn't allocate dma descriptor\n");\r\nret = -ENOMEM;\r\ngoto out_table;\r\n}\r\nbfin_lq035_fb.screen_base = (void *)fb_buffer;\r\nbfin_lq035_fb_fix.smem_start = (int)fb_buffer;\r\nif (landscape) {\r\nbfin_lq035_fb_defined.xres = LCD_Y_RES;\r\nbfin_lq035_fb_defined.yres = LCD_X_RES;\r\nbfin_lq035_fb_defined.xres_virtual = LCD_Y_RES;\r\nbfin_lq035_fb_defined.yres_virtual = LCD_X_RES;\r\nbfin_lq035_fb_fix.line_length = LCD_Y_RES*(LCD_BBP/8);\r\n} else {\r\nbfin_lq035_fb.screen_base += ACTIVE_VIDEO_MEM_OFFSET;\r\nbfin_lq035_fb_fix.smem_start += ACTIVE_VIDEO_MEM_OFFSET;\r\n}\r\nbfin_lq035_fb_defined.green.msb_right = 0;\r\nbfin_lq035_fb_defined.red.msb_right = 0;\r\nbfin_lq035_fb_defined.blue.msb_right = 0;\r\nbfin_lq035_fb_defined.green.offset = 5;\r\nbfin_lq035_fb_defined.green.length = 6;\r\nbfin_lq035_fb_defined.red.length = 5;\r\nbfin_lq035_fb_defined.blue.length = 5;\r\nif (bgr) {\r\nbfin_lq035_fb_defined.red.offset = 0;\r\nbfin_lq035_fb_defined.blue.offset = 11;\r\n} else {\r\nbfin_lq035_fb_defined.red.offset = 11;\r\nbfin_lq035_fb_defined.blue.offset = 0;\r\n}\r\nbfin_lq035_fb.fbops = &bfin_lq035_fb_ops;\r\nbfin_lq035_fb.var = bfin_lq035_fb_defined;\r\nbfin_lq035_fb.fix = bfin_lq035_fb_fix;\r\nbfin_lq035_fb.flags = FBINFO_DEFAULT;\r\nbfin_lq035_fb.pseudo_palette = kzalloc(sizeof(u32) * 16, GFP_KERNEL);\r\nif (bfin_lq035_fb.pseudo_palette == NULL) {\r\npr_err("failed to allocate pseudo_palette\n");\r\nret = -ENOMEM;\r\ngoto out_palette;\r\n}\r\nif (fb_alloc_cmap(&bfin_lq035_fb.cmap, NBR_PALETTE, 0) < 0) {\r\npr_err("failed to allocate colormap (%d entries)\n",\r\nNBR_PALETTE);\r\nret = -EFAULT;\r\ngoto out_cmap;\r\n}\r\nif (register_framebuffer(&bfin_lq035_fb) < 0) {\r\npr_err("unable to register framebuffer\n");\r\nret = -EINVAL;\r\ngoto out_reg;\r\n}\r\ni2c_add_driver(&ad5280_driver);\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = MAX_BRIGHENESS;\r\nbl_dev = backlight_device_register("bf537-bl", NULL, NULL,\r\n&bfin_lq035fb_bl_ops, &props);\r\nlcd_dev = lcd_device_register(KBUILD_MODNAME, &pdev->dev, NULL,\r\n&bfin_lcd_ops);\r\nif (IS_ERR(lcd_dev)) {\r\npr_err("unable to register lcd\n");\r\nret = PTR_ERR(lcd_dev);\r\ngoto out_lcd;\r\n}\r\nlcd_dev->props.max_contrast = 255,\r\npr_info("initialized");\r\nreturn 0;\r\nout_lcd:\r\nunregister_framebuffer(&bfin_lq035_fb);\r\nout_reg:\r\nfb_dealloc_cmap(&bfin_lq035_fb.cmap);\r\nout_cmap:\r\nkfree(bfin_lq035_fb.pseudo_palette);\r\nout_palette:\r\nout_table:\r\ndma_free_coherent(NULL, TOTAL_VIDEO_MEM_SIZE, fb_buffer, 0);\r\nfb_buffer = NULL;\r\nout_dma_coherent:\r\nfree_ports();\r\nout_ports:\r\nfree_dma(CH_PPI);\r\nreturn ret;\r\n}\r\nstatic int __devexit bfin_lq035_remove(struct platform_device *pdev)\r\n{\r\nif (fb_buffer != NULL)\r\ndma_free_coherent(NULL, TOTAL_VIDEO_MEM_SIZE, fb_buffer, 0);\r\nif (L1_DATA_A_LENGTH)\r\nl1_data_sram_free(dma_desc_table);\r\nelse\r\ndma_free_coherent(NULL, TOTAL_DMA_DESC_SIZE, NULL, 0);\r\nbfin_write_TIMER_DISABLE(TIMEN_SP|TIMEN_SPS|TIMEN_PS_CLS|\r\nTIMEN_LP|TIMEN_REV);\r\nt_conf_done = 0;\r\nfree_dma(CH_PPI);\r\nkfree(bfin_lq035_fb.pseudo_palette);\r\nfb_dealloc_cmap(&bfin_lq035_fb.cmap);\r\nlcd_device_unregister(lcd_dev);\r\nbacklight_device_unregister(bl_dev);\r\nunregister_framebuffer(&bfin_lq035_fb);\r\ni2c_del_driver(&ad5280_driver);\r\nfree_ports();\r\npr_info("unregistered LCD driver\n");\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nif (lq035_open_cnt > 0) {\r\nbfin_write_PPI_CONTROL(0);\r\nSSYNC();\r\ndisable_dma(CH_PPI);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035_resume(struct platform_device *pdev)\r\n{\r\nif (lq035_open_cnt > 0) {\r\nbfin_write_PPI_CONTROL(0);\r\nSSYNC();\r\nconfig_dma();\r\nconfig_ppi();\r\nenable_dma(CH_PPI);\r\nbfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() | PORT_EN);\r\nSSYNC();\r\nconfig_timers();\r\nstart_timers();\r\n} else {\r\nt_conf_done = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bfin_lq035_driver_init(void)\r\n{\r\nrequest_module("i2c-bfin-twi");\r\nreturn platform_driver_register(&bfin_lq035_driver);\r\n}\r\nstatic void __exit bfin_lq035_driver_cleanup(void)\r\n{\r\nplatform_driver_unregister(&bfin_lq035_driver);\r\n}
