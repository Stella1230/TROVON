static int ide_probe(struct pcmcia_device *link)\r\n{\r\nide_info_t *info;\r\ndev_dbg(&link->dev, "ide_attach()\n");\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO |\r\nCONF_AUTO_SET_VPP | CONF_AUTO_CHECK_VCC;\r\nreturn ide_config(link);\r\n}\r\nstatic void ide_detach(struct pcmcia_device *link)\r\n{\r\nide_info_t *info = link->priv;\r\ndev_dbg(&link->dev, "ide_detach(0x%p)\n", link);\r\nide_release(link);\r\nkfree(info);\r\n}\r\nstatic struct ide_host *idecs_register(unsigned long io, unsigned long ctl,\r\nunsigned long irq, struct pcmcia_device *handle)\r\n{\r\nstruct ide_host *host;\r\nide_hwif_t *hwif;\r\nint i, rc;\r\nstruct ide_hw hw, *hws[] = { &hw };\r\nif (!request_region(io, 8, DRV_NAME)) {\r\nprintk(KERN_ERR "%s: I/O resource 0x%lX-0x%lX not free.\n",\r\nDRV_NAME, io, io + 7);\r\nreturn NULL;\r\n}\r\nif (!request_region(ctl, 1, DRV_NAME)) {\r\nprintk(KERN_ERR "%s: I/O resource 0x%lX not free.\n",\r\nDRV_NAME, ctl);\r\nrelease_region(io, 8);\r\nreturn NULL;\r\n}\r\nmemset(&hw, 0, sizeof(hw));\r\nide_std_init_ports(&hw, io, ctl);\r\nhw.irq = irq;\r\nhw.dev = &handle->dev;\r\nrc = ide_host_add(&idecs_port_info, hws, 1, &host);\r\nif (rc)\r\ngoto out_release;\r\nhwif = host->ports[0];\r\nif (hwif->present)\r\nreturn host;\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(100);\r\nide_port_scan(hwif);\r\nif (hwif->present)\r\nreturn host;\r\n}\r\nreturn host;\r\nout_release:\r\nrelease_region(ctl, 1);\r\nrelease_region(io, 8);\r\nreturn NULL;\r\n}\r\nstatic int pcmcia_check_one_config(struct pcmcia_device *pdev, void *priv_data)\r\n{\r\nint *is_kme = priv_data;\r\nif (!(pdev->resource[0]->flags & IO_DATA_PATH_WIDTH_8)) {\r\npdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\npdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\n}\r\npdev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\r\npdev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\nif (pdev->resource[1]->end) {\r\npdev->resource[0]->end = 8;\r\npdev->resource[1]->end = (*is_kme) ? 2 : 1;\r\n} else {\r\nif (pdev->resource[0]->end < 16)\r\nreturn -ENODEV;\r\n}\r\nreturn pcmcia_request_io(pdev);\r\n}\r\nstatic int ide_config(struct pcmcia_device *link)\r\n{\r\nide_info_t *info = link->priv;\r\nint ret = 0, is_kme = 0;\r\nunsigned long io_base, ctl_base;\r\nstruct ide_host *host;\r\ndev_dbg(&link->dev, "ide_config(0x%p)\n", link);\r\nis_kme = ((link->manf_id == MANFID_KME) &&\r\n((link->card_id == PRODID_KME_KXLC005_A) ||\r\n(link->card_id == PRODID_KME_KXLC005_B)));\r\nif (pcmcia_loop_config(link, pcmcia_check_one_config, &is_kme)) {\r\nlink->config_flags &= ~CONF_AUTO_CHECK_VCC;\r\nif (pcmcia_loop_config(link, pcmcia_check_one_config, &is_kme))\r\ngoto failed;\r\n}\r\nio_base = link->resource[0]->start;\r\nif (link->resource[1]->end)\r\nctl_base = link->resource[1]->start;\r\nelse\r\nctl_base = link->resource[0]->start + 0x0e;\r\nif (!link->irq)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\noutb(0x02, ctl_base);\r\nif (is_kme)\r\noutb(0x81, ctl_base+1);\r\nhost = idecs_register(io_base, ctl_base, link->irq, link);\r\nif (host == NULL && resource_size(link->resource[0]) == 0x20) {\r\noutb(0x02, ctl_base + 0x10);\r\nhost = idecs_register(io_base + 0x10, ctl_base + 0x10,\r\nlink->irq, link);\r\n}\r\nif (host == NULL)\r\ngoto failed;\r\ninfo->ndev = 1;\r\ninfo->host = host;\r\ndev_info(&link->dev, "ide-cs: hd%c: Vpp = %d.%d\n",\r\n'a' + host->ports[0]->index * 2,\r\nlink->vpp / 10, link->vpp % 10);\r\nreturn 0;\r\nfailed:\r\nide_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void ide_release(struct pcmcia_device *link)\r\n{\r\nide_info_t *info = link->priv;\r\nstruct ide_host *host = info->host;\r\ndev_dbg(&link->dev, "ide_release(0x%p)\n", link);\r\nif (info->ndev) {\r\nide_hwif_t *hwif = host->ports[0];\r\nunsigned long data_addr, ctl_addr;\r\ndata_addr = hwif->io_ports.data_addr;\r\nctl_addr = hwif->io_ports.ctl_addr;\r\nide_host_remove(host);\r\ninfo->ndev = 0;\r\nrelease_region(ctl_addr, 1);\r\nrelease_region(data_addr, 8);\r\n}\r\npcmcia_disable_device(link);\r\n}\r\nstatic int __init init_ide_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&ide_cs_driver);\r\n}\r\nstatic void __exit exit_ide_cs(void)\r\n{\r\npcmcia_unregister_driver(&ide_cs_driver);\r\n}
