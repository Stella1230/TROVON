static inline int\r\npci_create_smbiosname_file(struct pci_dev *pdev)\r\n{\r\nreturn -1;\r\n}\r\nstatic inline void\r\npci_remove_smbiosname_file(struct pci_dev *pdev)\r\n{\r\n}\r\nstatic size_t\r\nfind_smbios_instance_string(struct pci_dev *pdev, char *buf,\r\nenum smbios_attr_enum attribute)\r\n{\r\nconst struct dmi_device *dmi;\r\nstruct dmi_dev_onboard *donboard;\r\nint bus;\r\nint devfn;\r\nbus = pdev->bus->number;\r\ndevfn = pdev->devfn;\r\ndmi = NULL;\r\nwhile ((dmi = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD,\r\nNULL, dmi)) != NULL) {\r\ndonboard = dmi->device_data;\r\nif (donboard && donboard->bus == bus &&\r\ndonboard->devfn == devfn) {\r\nif (buf) {\r\nif (attribute == SMBIOS_ATTR_INSTANCE_SHOW)\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"%d\n",\r\ndonboard->instance);\r\nelse if (attribute == SMBIOS_ATTR_LABEL_SHOW)\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"%s\n",\r\ndmi->name);\r\n}\r\nreturn strlen(dmi->name);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic mode_t\r\nsmbios_instance_string_exist(struct kobject *kobj, struct attribute *attr,\r\nint n)\r\n{\r\nstruct device *dev;\r\nstruct pci_dev *pdev;\r\ndev = container_of(kobj, struct device, kobj);\r\npdev = to_pci_dev(dev);\r\nreturn find_smbios_instance_string(pdev, NULL, SMBIOS_ATTR_NONE) ?\r\nS_IRUGO : 0;\r\n}\r\nstatic ssize_t\r\nsmbioslabel_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(dev);\r\nreturn find_smbios_instance_string(pdev, buf,\r\nSMBIOS_ATTR_LABEL_SHOW);\r\n}\r\nstatic ssize_t\r\nsmbiosinstance_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(dev);\r\nreturn find_smbios_instance_string(pdev, buf,\r\nSMBIOS_ATTR_INSTANCE_SHOW);\r\n}\r\nstatic int\r\npci_create_smbiosname_file(struct pci_dev *pdev)\r\n{\r\nreturn sysfs_create_group(&pdev->dev.kobj, &smbios_attr_group);\r\n}\r\nstatic void\r\npci_remove_smbiosname_file(struct pci_dev *pdev)\r\n{\r\nsysfs_remove_group(&pdev->dev.kobj, &smbios_attr_group);\r\n}\r\nstatic inline int\r\npci_create_acpi_index_label_files(struct pci_dev *pdev)\r\n{\r\nreturn -1;\r\n}\r\nstatic inline int\r\npci_remove_acpi_index_label_files(struct pci_dev *pdev)\r\n{\r\nreturn -1;\r\n}\r\nstatic inline bool\r\ndevice_has_dsm(struct device *dev)\r\n{\r\nreturn false;\r\n}\r\nstatic void dsm_label_utf16s_to_utf8s(union acpi_object *obj, char *buf)\r\n{\r\nint len;\r\nlen = utf16s_to_utf8s((const wchar_t *)obj->\r\npackage.elements[1].string.pointer,\r\nobj->package.elements[1].string.length,\r\nUTF16_LITTLE_ENDIAN,\r\nbuf, PAGE_SIZE);\r\nbuf[len] = '\n';\r\n}\r\nstatic int\r\ndsm_get_label(acpi_handle handle, int func,\r\nstruct acpi_buffer *output,\r\nchar *buf, enum acpi_attr_enum attribute)\r\n{\r\nstruct acpi_object_list input;\r\nunion acpi_object params[4];\r\nunion acpi_object *obj;\r\nint len = 0;\r\nint err;\r\ninput.count = 4;\r\ninput.pointer = params;\r\nparams[0].type = ACPI_TYPE_BUFFER;\r\nparams[0].buffer.length = sizeof(device_label_dsm_uuid);\r\nparams[0].buffer.pointer = (char *)device_label_dsm_uuid;\r\nparams[1].type = ACPI_TYPE_INTEGER;\r\nparams[1].integer.value = 0x02;\r\nparams[2].type = ACPI_TYPE_INTEGER;\r\nparams[2].integer.value = func;\r\nparams[3].type = ACPI_TYPE_PACKAGE;\r\nparams[3].package.count = 0;\r\nparams[3].package.elements = NULL;\r\nerr = acpi_evaluate_object(handle, "_DSM", &input, output);\r\nif (err)\r\nreturn -1;\r\nobj = (union acpi_object *)output->pointer;\r\nswitch (obj->type) {\r\ncase ACPI_TYPE_PACKAGE:\r\nif (obj->package.count != 2)\r\nbreak;\r\nlen = obj->package.elements[0].integer.value;\r\nif (buf) {\r\nif (attribute == ACPI_ATTR_INDEX_SHOW)\r\nscnprintf(buf, PAGE_SIZE, "%llu\n",\r\nobj->package.elements[0].integer.value);\r\nelse if (attribute == ACPI_ATTR_LABEL_SHOW)\r\ndsm_label_utf16s_to_utf8s(obj, buf);\r\nkfree(output->pointer);\r\nreturn strlen(buf);\r\n}\r\nkfree(output->pointer);\r\nreturn len;\r\nbreak;\r\ndefault:\r\nkfree(output->pointer);\r\n}\r\nreturn -1;\r\n}\r\nstatic bool\r\ndevice_has_dsm(struct device *dev)\r\n{\r\nacpi_handle handle;\r\nstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\r\nhandle = DEVICE_ACPI_HANDLE(dev);\r\nif (!handle)\r\nreturn FALSE;\r\nif (dsm_get_label(handle, DEVICE_LABEL_DSM, &output, NULL,\r\nACPI_ATTR_NONE) > 0)\r\nreturn TRUE;\r\nreturn FALSE;\r\n}\r\nstatic mode_t\r\nacpi_index_string_exist(struct kobject *kobj, struct attribute *attr, int n)\r\n{\r\nstruct device *dev;\r\ndev = container_of(kobj, struct device, kobj);\r\nif (device_has_dsm(dev))\r\nreturn S_IRUGO;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nacpilabel_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\r\nacpi_handle handle;\r\nint length;\r\nhandle = DEVICE_ACPI_HANDLE(dev);\r\nif (!handle)\r\nreturn -1;\r\nlength = dsm_get_label(handle, DEVICE_LABEL_DSM,\r\n&output, buf, ACPI_ATTR_LABEL_SHOW);\r\nif (length < 1)\r\nreturn -1;\r\nreturn length;\r\n}\r\nstatic ssize_t\r\nacpiindex_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\r\nacpi_handle handle;\r\nint length;\r\nhandle = DEVICE_ACPI_HANDLE(dev);\r\nif (!handle)\r\nreturn -1;\r\nlength = dsm_get_label(handle, DEVICE_LABEL_DSM,\r\n&output, buf, ACPI_ATTR_INDEX_SHOW);\r\nif (length < 0)\r\nreturn -1;\r\nreturn length;\r\n}\r\nstatic int\r\npci_create_acpi_index_label_files(struct pci_dev *pdev)\r\n{\r\nreturn sysfs_create_group(&pdev->dev.kobj, &acpi_attr_group);\r\n}\r\nstatic int\r\npci_remove_acpi_index_label_files(struct pci_dev *pdev)\r\n{\r\nsysfs_remove_group(&pdev->dev.kobj, &acpi_attr_group);\r\nreturn 0;\r\n}\r\nvoid pci_create_firmware_label_files(struct pci_dev *pdev)\r\n{\r\nif (device_has_dsm(&pdev->dev))\r\npci_create_acpi_index_label_files(pdev);\r\nelse\r\npci_create_smbiosname_file(pdev);\r\n}\r\nvoid pci_remove_firmware_label_files(struct pci_dev *pdev)\r\n{\r\nif (device_has_dsm(&pdev->dev))\r\npci_remove_acpi_index_label_files(pdev);\r\nelse\r\npci_remove_smbiosname_file(pdev);\r\n}
