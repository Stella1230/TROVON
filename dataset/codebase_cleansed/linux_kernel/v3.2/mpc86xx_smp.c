static void __init\r\nsmp_86xx_release_core(int nr)\r\n{\r\n__be32 __iomem *mcm_vaddr;\r\nunsigned long pcr;\r\nif (nr < 0 || nr >= NR_CPUS)\r\nreturn;\r\nmcm_vaddr = ioremap(get_immrbase() + MPC86xx_MCM_OFFSET,\r\nMPC86xx_MCM_SIZE);\r\npcr = in_be32(mcm_vaddr + (MCM_PORT_CONFIG_OFFSET >> 2));\r\npcr |= 1 << (nr + 24);\r\nout_be32(mcm_vaddr + (MCM_PORT_CONFIG_OFFSET >> 2), pcr);\r\niounmap(mcm_vaddr);\r\n}\r\nstatic int __init\r\nsmp_86xx_kick_cpu(int nr)\r\n{\r\nunsigned int save_vector;\r\nunsigned long target, flags;\r\nint n = 0;\r\nunsigned int *vector = (unsigned int *)(KERNELBASE + 0x100);\r\nif (nr < 0 || nr >= NR_CPUS)\r\nreturn -ENOENT;\r\npr_debug("smp_86xx_kick_cpu: kick CPU #%d\n", nr);\r\nlocal_irq_save(flags);\r\nsave_vector = *vector;\r\ntarget = (unsigned long) __secondary_start_mpc86xx;\r\npatch_branch(vector, target, BRANCH_SET_LINK);\r\nsmp_86xx_release_core(nr);\r\nwhile ((__secondary_hold_acknowledge != nr) && (n++, n < 1000))\r\nmdelay(1);\r\n*vector = save_vector;\r\nflush_icache_range((unsigned long) vector, (unsigned long) vector + 4);\r\nlocal_irq_restore(flags);\r\npr_debug("wait CPU #%d for %d msecs.\n", nr, n);\r\nreturn 0;\r\n}\r\nstatic void __init\r\nsmp_86xx_setup_cpu(int cpu_nr)\r\n{\r\nmpic_setup_this_cpu();\r\n}\r\nvoid __init\r\nmpc86xx_smp_init(void)\r\n{\r\nsmp_ops = &smp_86xx_ops;\r\n}
