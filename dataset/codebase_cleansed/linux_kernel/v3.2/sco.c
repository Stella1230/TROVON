static void sco_sock_timeout(unsigned long arg)\r\n{\r\nstruct sock *sk = (struct sock *) arg;\r\nBT_DBG("sock %p state %d", sk, sk->sk_state);\r\nbh_lock_sock(sk);\r\nsk->sk_err = ETIMEDOUT;\r\nsk->sk_state_change(sk);\r\nbh_unlock_sock(sk);\r\nsco_sock_kill(sk);\r\nsock_put(sk);\r\n}\r\nstatic void sco_sock_set_timer(struct sock *sk, long timeout)\r\n{\r\nBT_DBG("sock %p state %d timeout %ld", sk, sk->sk_state, timeout);\r\nsk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);\r\n}\r\nstatic void sco_sock_clear_timer(struct sock *sk)\r\n{\r\nBT_DBG("sock %p state %d", sk, sk->sk_state);\r\nsk_stop_timer(sk, &sk->sk_timer);\r\n}\r\nstatic struct sco_conn *sco_conn_add(struct hci_conn *hcon, __u8 status)\r\n{\r\nstruct hci_dev *hdev = hcon->hdev;\r\nstruct sco_conn *conn = hcon->sco_data;\r\nif (conn || status)\r\nreturn conn;\r\nconn = kzalloc(sizeof(struct sco_conn), GFP_ATOMIC);\r\nif (!conn)\r\nreturn NULL;\r\nspin_lock_init(&conn->lock);\r\nhcon->sco_data = conn;\r\nconn->hcon = hcon;\r\nconn->src = &hdev->bdaddr;\r\nconn->dst = &hcon->dst;\r\nif (hdev->sco_mtu > 0)\r\nconn->mtu = hdev->sco_mtu;\r\nelse\r\nconn->mtu = 60;\r\nBT_DBG("hcon %p conn %p", hcon, conn);\r\nreturn conn;\r\n}\r\nstatic inline struct sock *sco_chan_get(struct sco_conn *conn)\r\n{\r\nstruct sock *sk = NULL;\r\nsco_conn_lock(conn);\r\nsk = conn->sk;\r\nsco_conn_unlock(conn);\r\nreturn sk;\r\n}\r\nstatic int sco_conn_del(struct hci_conn *hcon, int err)\r\n{\r\nstruct sco_conn *conn = hcon->sco_data;\r\nstruct sock *sk;\r\nif (!conn)\r\nreturn 0;\r\nBT_DBG("hcon %p conn %p, err %d", hcon, conn, err);\r\nsk = sco_chan_get(conn);\r\nif (sk) {\r\nbh_lock_sock(sk);\r\nsco_sock_clear_timer(sk);\r\nsco_chan_del(sk, err);\r\nbh_unlock_sock(sk);\r\nsco_sock_kill(sk);\r\n}\r\nhcon->sco_data = NULL;\r\nkfree(conn);\r\nreturn 0;\r\n}\r\nstatic inline int sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\r\n{\r\nint err = 0;\r\nsco_conn_lock(conn);\r\nif (conn->sk)\r\nerr = -EBUSY;\r\nelse\r\n__sco_chan_add(conn, sk, parent);\r\nsco_conn_unlock(conn);\r\nreturn err;\r\n}\r\nstatic int sco_connect(struct sock *sk)\r\n{\r\nbdaddr_t *src = &bt_sk(sk)->src;\r\nbdaddr_t *dst = &bt_sk(sk)->dst;\r\nstruct sco_conn *conn;\r\nstruct hci_conn *hcon;\r\nstruct hci_dev *hdev;\r\nint err, type;\r\nBT_DBG("%s -> %s", batostr(src), batostr(dst));\r\nhdev = hci_get_route(dst, src);\r\nif (!hdev)\r\nreturn -EHOSTUNREACH;\r\nhci_dev_lock_bh(hdev);\r\nif (lmp_esco_capable(hdev) && !disable_esco)\r\ntype = ESCO_LINK;\r\nelse\r\ntype = SCO_LINK;\r\nhcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\r\nif (IS_ERR(hcon)) {\r\nerr = PTR_ERR(hcon);\r\ngoto done;\r\n}\r\nconn = sco_conn_add(hcon, 0);\r\nif (!conn) {\r\nhci_conn_put(hcon);\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nbacpy(src, conn->src);\r\nerr = sco_chan_add(conn, sk, NULL);\r\nif (err)\r\ngoto done;\r\nif (hcon->state == BT_CONNECTED) {\r\nsco_sock_clear_timer(sk);\r\nsk->sk_state = BT_CONNECTED;\r\n} else {\r\nsk->sk_state = BT_CONNECT;\r\nsco_sock_set_timer(sk, sk->sk_sndtimeo);\r\n}\r\ndone:\r\nhci_dev_unlock_bh(hdev);\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nstatic inline int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\r\n{\r\nstruct sco_conn *conn = sco_pi(sk)->conn;\r\nstruct sk_buff *skb;\r\nint err, count;\r\nif (len > conn->mtu)\r\nreturn -EINVAL;\r\nBT_DBG("sk %p len %d", sk, len);\r\ncount = min_t(unsigned int, conn->mtu, len);\r\nskb = bt_skb_send_alloc(sk, count,\r\nmsg->msg_flags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\nreturn err;\r\nif (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count)) {\r\nkfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\nhci_send_sco(conn->hcon, skb);\r\nreturn count;\r\n}\r\nstatic inline void sco_recv_frame(struct sco_conn *conn, struct sk_buff *skb)\r\n{\r\nstruct sock *sk = sco_chan_get(conn);\r\nif (!sk)\r\ngoto drop;\r\nBT_DBG("sk %p len %d", sk, skb->len);\r\nif (sk->sk_state != BT_CONNECTED)\r\ngoto drop;\r\nif (!sock_queue_rcv_skb(sk, skb))\r\nreturn;\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nstatic struct sock *__sco_get_sock_by_addr(bdaddr_t *ba)\r\n{\r\nstruct sock *sk;\r\nstruct hlist_node *node;\r\nsk_for_each(sk, node, &sco_sk_list.head)\r\nif (!bacmp(&bt_sk(sk)->src, ba))\r\ngoto found;\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic struct sock *sco_get_sock_listen(bdaddr_t *src)\r\n{\r\nstruct sock *sk = NULL, *sk1 = NULL;\r\nstruct hlist_node *node;\r\nread_lock(&sco_sk_list.lock);\r\nsk_for_each(sk, node, &sco_sk_list.head) {\r\nif (sk->sk_state != BT_LISTEN)\r\ncontinue;\r\nif (!bacmp(&bt_sk(sk)->src, src))\r\nbreak;\r\nif (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))\r\nsk1 = sk;\r\n}\r\nread_unlock(&sco_sk_list.lock);\r\nreturn node ? sk : sk1;\r\n}\r\nstatic void sco_sock_destruct(struct sock *sk)\r\n{\r\nBT_DBG("sk %p", sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nskb_queue_purge(&sk->sk_write_queue);\r\n}\r\nstatic void sco_sock_cleanup_listen(struct sock *parent)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("parent %p", parent);\r\nwhile ((sk = bt_accept_dequeue(parent, NULL))) {\r\nsco_sock_close(sk);\r\nsco_sock_kill(sk);\r\n}\r\nparent->sk_state = BT_CLOSED;\r\nsock_set_flag(parent, SOCK_ZAPPED);\r\n}\r\nstatic void sco_sock_kill(struct sock *sk)\r\n{\r\nif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\r\nreturn;\r\nBT_DBG("sk %p state %d", sk, sk->sk_state);\r\nbt_sock_unlink(&sco_sk_list, sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsock_put(sk);\r\n}\r\nstatic void __sco_sock_close(struct sock *sk)\r\n{\r\nBT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);\r\nswitch (sk->sk_state) {\r\ncase BT_LISTEN:\r\nsco_sock_cleanup_listen(sk);\r\nbreak;\r\ncase BT_CONNECTED:\r\ncase BT_CONFIG:\r\nif (sco_pi(sk)->conn) {\r\nsk->sk_state = BT_DISCONN;\r\nsco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);\r\nhci_conn_put(sco_pi(sk)->conn->hcon);\r\nsco_pi(sk)->conn->hcon = NULL;\r\n} else\r\nsco_chan_del(sk, ECONNRESET);\r\nbreak;\r\ncase BT_CONNECT:\r\ncase BT_DISCONN:\r\nsco_chan_del(sk, ECONNRESET);\r\nbreak;\r\ndefault:\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\nbreak;\r\n}\r\n}\r\nstatic void sco_sock_close(struct sock *sk)\r\n{\r\nsco_sock_clear_timer(sk);\r\nlock_sock(sk);\r\n__sco_sock_close(sk);\r\nrelease_sock(sk);\r\nsco_sock_kill(sk);\r\n}\r\nstatic void sco_sock_init(struct sock *sk, struct sock *parent)\r\n{\r\nBT_DBG("sk %p", sk);\r\nif (parent) {\r\nsk->sk_type = parent->sk_type;\r\nsecurity_sk_clone(parent, sk);\r\n}\r\n}\r\nstatic struct sock *sco_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\r\n{\r\nstruct sock *sk;\r\nsk = sk_alloc(net, PF_BLUETOOTH, prio, &sco_proto);\r\nif (!sk)\r\nreturn NULL;\r\nsock_init_data(sock, sk);\r\nINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\r\nsk->sk_destruct = sco_sock_destruct;\r\nsk->sk_sndtimeo = SCO_CONN_TIMEOUT;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nsk->sk_protocol = proto;\r\nsk->sk_state = BT_OPEN;\r\nsetup_timer(&sk->sk_timer, sco_sock_timeout, (unsigned long)sk);\r\nbt_sock_link(&sco_sk_list, sk);\r\nreturn sk;\r\n}\r\nstatic int sco_sock_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("sock %p", sock);\r\nsock->state = SS_UNCONNECTED;\r\nif (sock->type != SOCK_SEQPACKET)\r\nreturn -ESOCKTNOSUPPORT;\r\nsock->ops = &sco_sock_ops;\r\nsk = sco_sock_alloc(net, sock, protocol, GFP_ATOMIC);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsco_sock_init(sk, NULL);\r\nreturn 0;\r\n}\r\nstatic int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\r\n{\r\nstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\r\nstruct sock *sk = sock->sk;\r\nbdaddr_t *src = &sa->sco_bdaddr;\r\nint err = 0;\r\nBT_DBG("sk %p %s", sk, batostr(&sa->sco_bdaddr));\r\nif (!addr || addr->sa_family != AF_BLUETOOTH)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != BT_OPEN) {\r\nerr = -EBADFD;\r\ngoto done;\r\n}\r\nwrite_lock_bh(&sco_sk_list.lock);\r\nif (bacmp(src, BDADDR_ANY) && __sco_get_sock_by_addr(src)) {\r\nerr = -EADDRINUSE;\r\n} else {\r\nbacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);\r\nsk->sk_state = BT_BOUND;\r\n}\r\nwrite_unlock_bh(&sco_sk_list.lock);\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\r\n{\r\nstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sk %p", sk);\r\nif (alen < sizeof(struct sockaddr_sco) ||\r\naddr->sa_family != AF_BLUETOOTH)\r\nreturn -EINVAL;\r\nif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\r\nreturn -EBADFD;\r\nif (sk->sk_type != SOCK_SEQPACKET)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nbacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);\r\nerr = sco_connect(sk);\r\nif (err)\r\ngoto done;\r\nerr = bt_sock_wait_state(sk, BT_CONNECTED,\r\nsock_sndtimeo(sk, flags & O_NONBLOCK));\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sk %p backlog %d", sk, backlog);\r\nlock_sock(sk);\r\nif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\r\nerr = -EBADFD;\r\ngoto done;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_ack_backlog = 0;\r\nsk->sk_state = BT_LISTEN;\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct sock *sk = sock->sk, *ch;\r\nlong timeo;\r\nint err = 0;\r\nlock_sock(sk);\r\ntimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\r\nBT_DBG("sk %p timeo %ld", sk, timeo);\r\nadd_wait_queue_exclusive(sk_sleep(sk), &wait);\r\nwhile (1) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (sk->sk_state != BT_LISTEN) {\r\nerr = -EBADFD;\r\nbreak;\r\n}\r\nch = bt_accept_dequeue(sk, newsock);\r\nif (ch)\r\nbreak;\r\nif (!timeo) {\r\nerr = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock(sk);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto done;\r\nnewsock->state = SS_CONNECTED;\r\nBT_DBG("new socket %p", ch);\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\r\n{\r\nstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\r\nstruct sock *sk = sock->sk;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\naddr->sa_family = AF_BLUETOOTH;\r\n*len = sizeof(struct sockaddr_sco);\r\nif (peer)\r\nbacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);\r\nelse\r\nbacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);\r\nreturn 0;\r\n}\r\nstatic int sco_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nerr = sock_error(sk);\r\nif (err)\r\nreturn err;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nlock_sock(sk);\r\nif (sk->sk_state == BT_CONNECTED)\r\nerr = sco_send_frame(sk, msg, len);\r\nelse\r\nerr = -ENOTCONN;\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sk %p", sk);\r\nlock_sock(sk);\r\nswitch (optname) {\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sco_options opts;\r\nstruct sco_conninfo cinfo;\r\nint len, err = 0;\r\nBT_DBG("sk %p", sk);\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase SCO_OPTIONS:\r\nif (sk->sk_state != BT_CONNECTED) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nopts.mtu = sco_pi(sk)->conn->mtu;\r\nBT_DBG("mtu %d", opts.mtu);\r\nlen = min_t(unsigned int, len, sizeof(opts));\r\nif (copy_to_user(optval, (char *)&opts, len))\r\nerr = -EFAULT;\r\nbreak;\r\ncase SCO_CONNINFO:\r\nif (sk->sk_state != BT_CONNECTED) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nmemset(&cinfo, 0, sizeof(cinfo));\r\ncinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\r\nmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\r\nlen = min_t(unsigned int, len, sizeof(cinfo));\r\nif (copy_to_user(optval, (char *)&cinfo, len))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint len, err = 0;\r\nBT_DBG("sk %p", sk);\r\nif (level == SOL_SCO)\r\nreturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_shutdown(struct socket *sock, int how)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nlock_sock(sk);\r\nif (!sk->sk_shutdown) {\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nsco_sock_clear_timer(sk);\r\n__sco_sock_close(sk);\r\nif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)\r\nerr = bt_sock_wait_state(sk, BT_CLOSED,\r\nsk->sk_lingertime);\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nsco_sock_close(sk);\r\nif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime) {\r\nlock_sock(sk);\r\nerr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\r\nrelease_sock(sk);\r\n}\r\nsock_orphan(sk);\r\nsco_sock_kill(sk);\r\nreturn err;\r\n}\r\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent)\r\n{\r\nBT_DBG("conn %p", conn);\r\nsco_pi(sk)->conn = conn;\r\nconn->sk = sk;\r\nif (parent)\r\nbt_accept_enqueue(parent, sk);\r\n}\r\nstatic void sco_chan_del(struct sock *sk, int err)\r\n{\r\nstruct sco_conn *conn;\r\nconn = sco_pi(sk)->conn;\r\nBT_DBG("sk %p, conn %p, err %d", sk, conn, err);\r\nif (conn) {\r\nsco_conn_lock(conn);\r\nconn->sk = NULL;\r\nsco_pi(sk)->conn = NULL;\r\nsco_conn_unlock(conn);\r\nif (conn->hcon)\r\nhci_conn_put(conn->hcon);\r\n}\r\nsk->sk_state = BT_CLOSED;\r\nsk->sk_err = err;\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\n}\r\nstatic void sco_conn_ready(struct sco_conn *conn)\r\n{\r\nstruct sock *parent;\r\nstruct sock *sk = conn->sk;\r\nBT_DBG("conn %p", conn);\r\nsco_conn_lock(conn);\r\nif (sk) {\r\nsco_sock_clear_timer(sk);\r\nbh_lock_sock(sk);\r\nsk->sk_state = BT_CONNECTED;\r\nsk->sk_state_change(sk);\r\nbh_unlock_sock(sk);\r\n} else {\r\nparent = sco_get_sock_listen(conn->src);\r\nif (!parent)\r\ngoto done;\r\nbh_lock_sock(parent);\r\nsk = sco_sock_alloc(sock_net(parent), NULL,\r\nBTPROTO_SCO, GFP_ATOMIC);\r\nif (!sk) {\r\nbh_unlock_sock(parent);\r\ngoto done;\r\n}\r\nsco_sock_init(sk, parent);\r\nbacpy(&bt_sk(sk)->src, conn->src);\r\nbacpy(&bt_sk(sk)->dst, conn->dst);\r\nhci_conn_hold(conn->hcon);\r\n__sco_chan_add(conn, sk, parent);\r\nsk->sk_state = BT_CONNECTED;\r\nparent->sk_data_ready(parent, 1);\r\nbh_unlock_sock(parent);\r\n}\r\ndone:\r\nsco_conn_unlock(conn);\r\n}\r\nstatic int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)\r\n{\r\nregister struct sock *sk;\r\nstruct hlist_node *node;\r\nint lm = 0;\r\nif (type != SCO_LINK && type != ESCO_LINK)\r\nreturn -EINVAL;\r\nBT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));\r\nread_lock(&sco_sk_list.lock);\r\nsk_for_each(sk, node, &sco_sk_list.head) {\r\nif (sk->sk_state != BT_LISTEN)\r\ncontinue;\r\nif (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr) ||\r\n!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {\r\nlm |= HCI_LM_ACCEPT;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&sco_sk_list.lock);\r\nreturn lm;\r\n}\r\nstatic int sco_connect_cfm(struct hci_conn *hcon, __u8 status)\r\n{\r\nBT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);\r\nif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\r\nreturn -EINVAL;\r\nif (!status) {\r\nstruct sco_conn *conn;\r\nconn = sco_conn_add(hcon, status);\r\nif (conn)\r\nsco_conn_ready(conn);\r\n} else\r\nsco_conn_del(hcon, bt_to_errno(status));\r\nreturn 0;\r\n}\r\nstatic int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)\r\n{\r\nBT_DBG("hcon %p reason %d", hcon, reason);\r\nif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\r\nreturn -EINVAL;\r\nsco_conn_del(hcon, bt_to_errno(reason));\r\nreturn 0;\r\n}\r\nstatic int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\r\n{\r\nstruct sco_conn *conn = hcon->sco_data;\r\nif (!conn)\r\ngoto drop;\r\nBT_DBG("conn %p len %d", conn, skb->len);\r\nif (skb->len) {\r\nsco_recv_frame(conn, skb);\r\nreturn 0;\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int sco_debugfs_show(struct seq_file *f, void *p)\r\n{\r\nstruct sock *sk;\r\nstruct hlist_node *node;\r\nread_lock_bh(&sco_sk_list.lock);\r\nsk_for_each(sk, node, &sco_sk_list.head) {\r\nseq_printf(f, "%s %s %d\n", batostr(&bt_sk(sk)->src),\r\nbatostr(&bt_sk(sk)->dst), sk->sk_state);\r\n}\r\nread_unlock_bh(&sco_sk_list.lock);\r\nreturn 0;\r\n}\r\nstatic int sco_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sco_debugfs_show, inode->i_private);\r\n}\r\nint __init sco_init(void)\r\n{\r\nint err;\r\nerr = proto_register(&sco_proto, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = bt_sock_register(BTPROTO_SCO, &sco_sock_family_ops);\r\nif (err < 0) {\r\nBT_ERR("SCO socket registration failed");\r\ngoto error;\r\n}\r\nerr = hci_register_proto(&sco_hci_proto);\r\nif (err < 0) {\r\nBT_ERR("SCO protocol registration failed");\r\nbt_sock_unregister(BTPROTO_SCO);\r\ngoto error;\r\n}\r\nif (bt_debugfs) {\r\nsco_debugfs = debugfs_create_file("sco", 0444,\r\nbt_debugfs, NULL, &sco_debugfs_fops);\r\nif (!sco_debugfs)\r\nBT_ERR("Failed to create SCO debug file");\r\n}\r\nBT_INFO("SCO socket layer initialized");\r\nreturn 0;\r\nerror:\r\nproto_unregister(&sco_proto);\r\nreturn err;\r\n}\r\nvoid __exit sco_exit(void)\r\n{\r\ndebugfs_remove(sco_debugfs);\r\nif (bt_sock_unregister(BTPROTO_SCO) < 0)\r\nBT_ERR("SCO socket unregistration failed");\r\nif (hci_unregister_proto(&sco_hci_proto) < 0)\r\nBT_ERR("SCO protocol unregistration failed");\r\nproto_unregister(&sco_proto);\r\n}
