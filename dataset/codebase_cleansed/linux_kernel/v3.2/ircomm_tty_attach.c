int ircomm_tty_attach_cable(struct ircomm_tty_cb *self)\r\n{\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nif (ircomm_is_connected(self->ircomm)) {\r\nIRDA_DEBUG(0, "%s(), already connected!\n", __func__ );\r\nreturn 0;\r\n}\r\nself->tty->hw_stopped = 1;\r\nircomm_tty_ias_register(self);\r\nircomm_tty_do_event(self, IRCOMM_TTY_ATTACH_CABLE, NULL, NULL);\r\nreturn 0;\r\n}\r\nvoid ircomm_tty_detach_cable(struct ircomm_tty_cb *self)\r\n{\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\ndel_timer(&self->watchdog_timer);\r\nif (self->ckey) {\r\nirlmp_unregister_client(self->ckey);\r\nself->ckey = NULL;\r\n}\r\nif (self->skey) {\r\nirlmp_unregister_service(self->skey);\r\nself->skey = NULL;\r\n}\r\nif (self->iriap) {\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\n}\r\nif (self->obj) {\r\nirias_delete_object(self->obj);\r\nself->obj = NULL;\r\n}\r\nircomm_tty_do_event(self, IRCOMM_TTY_DETACH_CABLE, NULL, NULL);\r\nself->daddr = self->saddr = 0;\r\nself->dlsap_sel = self->slsap_sel = 0;\r\nmemset(&self->settings, 0, sizeof(struct ircomm_params));\r\n}\r\nstatic void ircomm_tty_ias_register(struct ircomm_tty_cb *self)\r\n{\r\n__u8 oct_seq[6];\r\n__u16 hints;\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nhints = irlmp_service_to_hint(S_COMM);\r\nif (self->service_type & IRCOMM_3_WIRE_RAW)\r\nhints |= irlmp_service_to_hint(S_PRINTER);\r\nif (!self->skey)\r\nself->skey = irlmp_register_service(hints);\r\nif (!self->ckey)\r\nself->ckey = irlmp_register_client(hints,\r\nircomm_tty_discovery_indication,\r\nNULL, (void *) self);\r\nif (self->obj)\r\nreturn;\r\nif (self->service_type & IRCOMM_3_WIRE_RAW) {\r\nself->obj = irias_new_object("IrLPT", IAS_IRLPT_ID);\r\nirias_add_integer_attrib(self->obj, "IrDA:IrLMP:LsapSel",\r\nself->slsap_sel, IAS_KERNEL_ATTR);\r\n} else {\r\nself->obj = irias_new_object("IrDA:IrCOMM", IAS_IRCOMM_ID);\r\nirias_add_integer_attrib(self->obj, "IrDA:TinyTP:LsapSel",\r\nself->slsap_sel, IAS_KERNEL_ATTR);\r\nirda_param_pack(oct_seq, "bbbbbb",\r\nIRCOMM_SERVICE_TYPE, 1, self->service_type,\r\nIRCOMM_PORT_TYPE, 1, IRCOMM_SERIAL);\r\nirias_add_octseq_attrib(self->obj, "Parameters", oct_seq, 6,\r\nIAS_KERNEL_ATTR);\r\n}\r\nirias_insert_object(self->obj);\r\n}\r\nstatic void ircomm_tty_ias_unregister(struct ircomm_tty_cb *self)\r\n{\r\nif (self->obj) {\r\nirias_delete_object(self->obj);\r\nself->obj = NULL;\r\n}\r\n#if 0\r\nif (self->ckey) {\r\nirlmp_unregister_client(self->ckey);\r\nself->ckey = NULL;\r\n}\r\n#endif\r\n}\r\nint ircomm_tty_send_initial_parameters(struct ircomm_tty_cb *self)\r\n{\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nif (self->service_type & IRCOMM_3_WIRE_RAW)\r\nreturn 0;\r\nIRDA_DEBUG(2, "%s(), data-rate = %d\n", __func__ ,\r\nself->settings.data_rate);\r\nif (!self->settings.data_rate)\r\nself->settings.data_rate = 9600;\r\nIRDA_DEBUG(2, "%s(), data-format = %d\n", __func__ ,\r\nself->settings.data_format);\r\nif (!self->settings.data_format)\r\nself->settings.data_format = IRCOMM_WSIZE_8;\r\nIRDA_DEBUG(2, "%s(), flow-control = %d\n", __func__ ,\r\nself->settings.flow_control);\r\nself->settings.dte = IRCOMM_DTR | IRCOMM_RTS;\r\nif (self->client)\r\nircomm_param_request(self, IRCOMM_SERVICE_TYPE, FALSE);\r\nircomm_param_request(self, IRCOMM_DATA_RATE, FALSE);\r\nircomm_param_request(self, IRCOMM_DATA_FORMAT, FALSE);\r\nif (self->settings.service_type == IRCOMM_3_WIRE) {\r\nircomm_param_request(self, IRCOMM_FLOW_CONTROL, TRUE);\r\nreturn 0;\r\n}\r\nircomm_param_request(self, IRCOMM_FLOW_CONTROL, FALSE);\r\n#if 0\r\nircomm_param_request(self, IRCOMM_XON_XOFF, FALSE);\r\nircomm_param_request(self, IRCOMM_ENQ_ACK, FALSE);\r\n#endif\r\nircomm_param_request(self, IRCOMM_DTE, TRUE);\r\nreturn 0;\r\n}\r\nstatic void ircomm_tty_discovery_indication(discinfo_t *discovery,\r\nDISCOVERY_MODE mode,\r\nvoid *priv)\r\n{\r\nstruct ircomm_tty_cb *self;\r\nstruct ircomm_tty_info info;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nif(mode == DISCOVERY_PASSIVE)\r\nreturn;\r\ninfo.daddr = discovery->daddr;\r\ninfo.saddr = discovery->saddr;\r\nself = priv;\r\nircomm_tty_do_event(self, IRCOMM_TTY_DISCOVERY_INDICATION,\r\nNULL, &info);\r\n}\r\nvoid ircomm_tty_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) instance;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nif (!self->tty)\r\nreturn;\r\nself->flow = FLOW_STOP;\r\nself->tty->hw_stopped = 1;\r\nircomm_tty_do_event(self, IRCOMM_TTY_DISCONNECT_INDICATION, NULL,\r\nNULL);\r\n}\r\nstatic void ircomm_tty_getvalue_confirm(int result, __u16 obj_id,\r\nstruct ias_value *value,\r\nvoid *priv)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) priv;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\nif (result != IAS_SUCCESS) {\r\nIRDA_DEBUG(4, "%s(), got NULL value!\n", __func__ );\r\nreturn;\r\n}\r\nswitch (value->type) {\r\ncase IAS_OCT_SEQ:\r\nIRDA_DEBUG(2, "%s(), got octet sequence\n", __func__ );\r\nirda_param_extract_all(self, value->t.oct_seq, value->len,\r\n&ircomm_param_info);\r\nircomm_tty_do_event(self, IRCOMM_TTY_GOT_PARAMETERS, NULL,\r\nNULL);\r\nbreak;\r\ncase IAS_INTEGER:\r\nIRDA_DEBUG(2, "%s(), got lsapsel = %d\n", __func__ ,\r\nvalue->t.integer);\r\nif (value->t.integer == -1) {\r\nIRDA_DEBUG(0, "%s(), invalid value!\n", __func__ );\r\n} else\r\nself->dlsap_sel = value->t.integer;\r\nircomm_tty_do_event(self, IRCOMM_TTY_GOT_LSAPSEL, NULL, NULL);\r\nbreak;\r\ncase IAS_MISSING:\r\nIRDA_DEBUG(0, "%s(), got IAS_MISSING\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), got unknown type!\n", __func__ );\r\nbreak;\r\n}\r\nirias_delete_value(value);\r\n}\r\nvoid ircomm_tty_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_data_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) instance;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nself->client = TRUE;\r\nself->max_data_size = max_data_size;\r\nself->max_header_size = max_header_size;\r\nself->flow = FLOW_START;\r\nircomm_tty_do_event(self, IRCOMM_TTY_CONNECT_CONFIRM, NULL, NULL);\r\n}\r\nvoid ircomm_tty_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_data_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) instance;\r\nint clen;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nself->client = FALSE;\r\nself->max_data_size = max_data_size;\r\nself->max_header_size = max_header_size;\r\nself->flow = FLOW_START;\r\nclen = skb->data[0];\r\nif (clen)\r\nirda_param_extract_all(self, skb->data+1,\r\nIRDA_MIN(skb->len, clen),\r\n&ircomm_param_info);\r\nircomm_tty_do_event(self, IRCOMM_TTY_CONNECT_INDICATION, NULL, NULL);\r\n}\r\nvoid ircomm_tty_link_established(struct ircomm_tty_cb *self)\r\n{\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nif (!self->tty)\r\nreturn;\r\ndel_timer(&self->watchdog_timer);\r\nif ((self->flags & ASYNC_CTS_FLOW) && ((self->settings.dce & IRCOMM_CTS) == 0)) {\r\nIRDA_DEBUG(0, "%s(), waiting for CTS ...\n", __func__ );\r\nreturn;\r\n} else {\r\nIRDA_DEBUG(1, "%s(), starting hardware!\n", __func__ );\r\nself->tty->hw_stopped = 0;\r\nwake_up_interruptible(&self->open_wait);\r\n}\r\nschedule_work(&self->tqueue);\r\n}\r\nstatic void ircomm_tty_start_watchdog_timer(struct ircomm_tty_cb *self,\r\nint timeout)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nirda_start_timer(&self->watchdog_timer, timeout, (void *) self,\r\nircomm_tty_watchdog_timer_expired);\r\n}\r\nstatic void ircomm_tty_watchdog_timer_expired(void *data)\r\n{\r\nstruct ircomm_tty_cb *self = (struct ircomm_tty_cb *) data;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return;);\r\nircomm_tty_do_event(self, IRCOMM_TTY_WD_TIMER_EXPIRED, NULL, NULL);\r\n}\r\nint ircomm_tty_do_event(struct ircomm_tty_cb *self, IRCOMM_TTY_EVENT event,\r\nstruct sk_buff *skb, struct ircomm_tty_info *info)\r\n{\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);\r\nIRDA_DEBUG(2, "%s: state=%s, event=%s\n", __func__ ,\r\nircomm_tty_state[self->state], ircomm_tty_event[event]);\r\nreturn (*state[self->state])(self, event, skb, info);\r\n}\r\nstatic inline void ircomm_tty_next_state(struct ircomm_tty_cb *self, IRCOMM_TTY_STATE state)\r\n{\r\nself->state = state;\r\n}\r\nstatic int ircomm_tty_state_idle(struct ircomm_tty_cb *self,\r\nIRCOMM_TTY_EVENT event,\r\nstruct sk_buff *skb,\r\nstruct ircomm_tty_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(2, "%s: state=%s, event=%s\n", __func__ ,\r\nircomm_tty_state[self->state], ircomm_tty_event[event]);\r\nswitch (event) {\r\ncase IRCOMM_TTY_ATTACH_CABLE:\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nircomm_tty_next_state(self, IRCOMM_TTY_SEARCH);\r\nirlmp_discovery_request(DISCOVERY_DEFAULT_SLOTS);\r\nbreak;\r\ncase IRCOMM_TTY_DISCOVERY_INDICATION:\r\nself->daddr = info->daddr;\r\nself->saddr = info->saddr;\r\nif (self->iriap) {\r\nIRDA_WARNING("%s(), busy with a previous query\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nircomm_tty_getvalue_confirm);\r\niriap_getvaluebyclass_request(self->iriap,\r\nself->saddr, self->daddr,\r\n"IrDA:IrCOMM", "Parameters");\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nircomm_tty_next_state(self, IRCOMM_TTY_QUERY_PARAMETERS);\r\nbreak;\r\ncase IRCOMM_TTY_CONNECT_INDICATION:\r\ndel_timer(&self->watchdog_timer);\r\nircomm_connect_response(self->ircomm, NULL);\r\nircomm_tty_next_state(self, IRCOMM_TTY_READY);\r\nbreak;\r\ncase IRCOMM_TTY_WD_TIMER_EXPIRED:\r\nbreak;\r\ncase IRCOMM_TTY_DETACH_CABLE:\r\nircomm_tty_next_state(self, IRCOMM_TTY_IDLE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown event: %s\n", __func__ ,\r\nircomm_tty_event[event]);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ircomm_tty_state_search(struct ircomm_tty_cb *self,\r\nIRCOMM_TTY_EVENT event,\r\nstruct sk_buff *skb,\r\nstruct ircomm_tty_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(2, "%s: state=%s, event=%s\n", __func__ ,\r\nircomm_tty_state[self->state], ircomm_tty_event[event]);\r\nswitch (event) {\r\ncase IRCOMM_TTY_DISCOVERY_INDICATION:\r\nself->daddr = info->daddr;\r\nself->saddr = info->saddr;\r\nif (self->iriap) {\r\nIRDA_WARNING("%s(), busy with a previous query\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nircomm_tty_getvalue_confirm);\r\nif (self->service_type == IRCOMM_3_WIRE_RAW) {\r\niriap_getvaluebyclass_request(self->iriap, self->saddr,\r\nself->daddr, "IrLPT",\r\n"IrDA:IrLMP:LsapSel");\r\nircomm_tty_next_state(self, IRCOMM_TTY_QUERY_LSAP_SEL);\r\n} else {\r\niriap_getvaluebyclass_request(self->iriap, self->saddr,\r\nself->daddr,\r\n"IrDA:IrCOMM",\r\n"Parameters");\r\nircomm_tty_next_state(self, IRCOMM_TTY_QUERY_PARAMETERS);\r\n}\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nbreak;\r\ncase IRCOMM_TTY_CONNECT_INDICATION:\r\ndel_timer(&self->watchdog_timer);\r\nircomm_tty_ias_unregister(self);\r\nircomm_connect_response(self->ircomm, NULL);\r\nircomm_tty_next_state(self, IRCOMM_TTY_READY);\r\nbreak;\r\ncase IRCOMM_TTY_WD_TIMER_EXPIRED:\r\n#if 1\r\n#else\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nirlmp_discovery_request(DISCOVERY_DEFAULT_SLOTS);\r\n#endif\r\nbreak;\r\ncase IRCOMM_TTY_DETACH_CABLE:\r\nircomm_tty_next_state(self, IRCOMM_TTY_IDLE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown event: %s\n", __func__ ,\r\nircomm_tty_event[event]);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ircomm_tty_state_query_parameters(struct ircomm_tty_cb *self,\r\nIRCOMM_TTY_EVENT event,\r\nstruct sk_buff *skb,\r\nstruct ircomm_tty_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(2, "%s: state=%s, event=%s\n", __func__ ,\r\nircomm_tty_state[self->state], ircomm_tty_event[event]);\r\nswitch (event) {\r\ncase IRCOMM_TTY_GOT_PARAMETERS:\r\nif (self->iriap) {\r\nIRDA_WARNING("%s(), busy with a previous query\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nircomm_tty_getvalue_confirm);\r\niriap_getvaluebyclass_request(self->iriap, self->saddr,\r\nself->daddr, "IrDA:IrCOMM",\r\n"IrDA:TinyTP:LsapSel");\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nircomm_tty_next_state(self, IRCOMM_TTY_QUERY_LSAP_SEL);\r\nbreak;\r\ncase IRCOMM_TTY_WD_TIMER_EXPIRED:\r\nircomm_tty_next_state(self, IRCOMM_TTY_SEARCH);\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nbreak;\r\ncase IRCOMM_TTY_CONNECT_INDICATION:\r\ndel_timer(&self->watchdog_timer);\r\nircomm_tty_ias_unregister(self);\r\nircomm_connect_response(self->ircomm, NULL);\r\nircomm_tty_next_state(self, IRCOMM_TTY_READY);\r\nbreak;\r\ncase IRCOMM_TTY_DETACH_CABLE:\r\nircomm_tty_next_state(self, IRCOMM_TTY_IDLE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown event: %s\n", __func__ ,\r\nircomm_tty_event[event]);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ircomm_tty_state_query_lsap_sel(struct ircomm_tty_cb *self,\r\nIRCOMM_TTY_EVENT event,\r\nstruct sk_buff *skb,\r\nstruct ircomm_tty_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(2, "%s: state=%s, event=%s\n", __func__ ,\r\nircomm_tty_state[self->state], ircomm_tty_event[event]);\r\nswitch (event) {\r\ncase IRCOMM_TTY_GOT_LSAPSEL:\r\nret = ircomm_connect_request(self->ircomm, self->dlsap_sel,\r\nself->saddr, self->daddr,\r\nNULL, self->service_type);\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nircomm_tty_next_state(self, IRCOMM_TTY_SETUP);\r\nbreak;\r\ncase IRCOMM_TTY_WD_TIMER_EXPIRED:\r\nircomm_tty_next_state(self, IRCOMM_TTY_SEARCH);\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nbreak;\r\ncase IRCOMM_TTY_CONNECT_INDICATION:\r\ndel_timer(&self->watchdog_timer);\r\nircomm_tty_ias_unregister(self);\r\nircomm_connect_response(self->ircomm, NULL);\r\nircomm_tty_next_state(self, IRCOMM_TTY_READY);\r\nbreak;\r\ncase IRCOMM_TTY_DETACH_CABLE:\r\nircomm_tty_next_state(self, IRCOMM_TTY_IDLE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown event: %s\n", __func__ ,\r\nircomm_tty_event[event]);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ircomm_tty_state_setup(struct ircomm_tty_cb *self,\r\nIRCOMM_TTY_EVENT event,\r\nstruct sk_buff *skb,\r\nstruct ircomm_tty_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(2, "%s: state=%s, event=%s\n", __func__ ,\r\nircomm_tty_state[self->state], ircomm_tty_event[event]);\r\nswitch (event) {\r\ncase IRCOMM_TTY_CONNECT_CONFIRM:\r\ndel_timer(&self->watchdog_timer);\r\nircomm_tty_ias_unregister(self);\r\nircomm_tty_send_initial_parameters(self);\r\nircomm_tty_link_established(self);\r\nircomm_tty_next_state(self, IRCOMM_TTY_READY);\r\nbreak;\r\ncase IRCOMM_TTY_CONNECT_INDICATION:\r\ndel_timer(&self->watchdog_timer);\r\nircomm_tty_ias_unregister(self);\r\nircomm_connect_response(self->ircomm, NULL);\r\nircomm_tty_next_state(self, IRCOMM_TTY_READY);\r\nbreak;\r\ncase IRCOMM_TTY_WD_TIMER_EXPIRED:\r\nircomm_tty_next_state(self, IRCOMM_TTY_SEARCH);\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nbreak;\r\ncase IRCOMM_TTY_DETACH_CABLE:\r\nircomm_tty_next_state(self, IRCOMM_TTY_IDLE);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown event: %s\n", __func__ ,\r\nircomm_tty_event[event]);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ircomm_tty_state_ready(struct ircomm_tty_cb *self,\r\nIRCOMM_TTY_EVENT event,\r\nstruct sk_buff *skb,\r\nstruct ircomm_tty_info *info)\r\n{\r\nint ret = 0;\r\nswitch (event) {\r\ncase IRCOMM_TTY_DATA_REQUEST:\r\nret = ircomm_data_request(self->ircomm, skb);\r\nbreak;\r\ncase IRCOMM_TTY_DETACH_CABLE:\r\nircomm_disconnect_request(self->ircomm, NULL);\r\nircomm_tty_next_state(self, IRCOMM_TTY_IDLE);\r\nbreak;\r\ncase IRCOMM_TTY_DISCONNECT_INDICATION:\r\nircomm_tty_ias_register(self);\r\nircomm_tty_next_state(self, IRCOMM_TTY_SEARCH);\r\nircomm_tty_start_watchdog_timer(self, 3*HZ);\r\nif (self->flags & ASYNC_CHECK_CD) {\r\nself->settings.dce = IRCOMM_DELTA_CD;\r\nircomm_tty_check_modem_status(self);\r\n} else {\r\nIRDA_DEBUG(0, "%s(), hanging up!\n", __func__ );\r\nif (self->tty)\r\ntty_hangup(self->tty);\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown event: %s\n", __func__ ,\r\nircomm_tty_event[event]);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}
