static void send_reset(struct sk_buff *oldskb, int hook)\r\n{\r\nstruct sk_buff *nskb;\r\nconst struct iphdr *oiph;\r\nstruct iphdr *niph;\r\nconst struct tcphdr *oth;\r\nstruct tcphdr _otcph, *tcph;\r\nif (ip_hdr(oldskb)->frag_off & htons(IP_OFFSET))\r\nreturn;\r\noth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),\r\nsizeof(_otcph), &_otcph);\r\nif (oth == NULL)\r\nreturn;\r\nif (oth->rst)\r\nreturn;\r\nif (skb_rtable(oldskb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\r\nreturn;\r\nif (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))\r\nreturn;\r\noiph = ip_hdr(oldskb);\r\nnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +\r\nLL_MAX_HEADER, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nskb_reserve(nskb, LL_MAX_HEADER);\r\nskb_reset_network_header(nskb);\r\nniph = (struct iphdr *)skb_put(nskb, sizeof(struct iphdr));\r\nniph->version = 4;\r\nniph->ihl = sizeof(struct iphdr) / 4;\r\nniph->tos = 0;\r\nniph->id = 0;\r\nniph->frag_off = htons(IP_DF);\r\nniph->protocol = IPPROTO_TCP;\r\nniph->check = 0;\r\nniph->saddr = oiph->daddr;\r\nniph->daddr = oiph->saddr;\r\ntcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));\r\nmemset(tcph, 0, sizeof(*tcph));\r\ntcph->source = oth->dest;\r\ntcph->dest = oth->source;\r\ntcph->doff = sizeof(struct tcphdr) / 4;\r\nif (oth->ack)\r\ntcph->seq = oth->ack_seq;\r\nelse {\r\ntcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +\r\noldskb->len - ip_hdrlen(oldskb) -\r\n(oth->doff << 2));\r\ntcph->ack = 1;\r\n}\r\ntcph->rst = 1;\r\ntcph->check = ~tcp_v4_check(sizeof(struct tcphdr), niph->saddr,\r\nniph->daddr, 0);\r\nnskb->ip_summed = CHECKSUM_PARTIAL;\r\nnskb->csum_start = (unsigned char *)tcph - nskb->head;\r\nnskb->csum_offset = offsetof(struct tcphdr, check);\r\nskb_dst_set_noref(nskb, skb_dst(oldskb));\r\nnskb->protocol = htons(ETH_P_IP);\r\nif (ip_route_me_harder(nskb, RTN_UNSPEC))\r\ngoto free_nskb;\r\nniph->ttl = ip4_dst_hoplimit(skb_dst(nskb));\r\nif (nskb->len > dst_mtu(skb_dst(nskb)))\r\ngoto free_nskb;\r\nnf_ct_attach(nskb, oldskb);\r\nip_local_out(nskb);\r\nreturn;\r\nfree_nskb:\r\nkfree_skb(nskb);\r\n}\r\nstatic inline void send_unreach(struct sk_buff *skb_in, int code)\r\n{\r\nicmp_send(skb_in, ICMP_DEST_UNREACH, code, 0);\r\n}\r\nstatic unsigned int\r\nreject_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ipt_reject_info *reject = par->targinfo;\r\nswitch (reject->with) {\r\ncase IPT_ICMP_NET_UNREACHABLE:\r\nsend_unreach(skb, ICMP_NET_UNREACH);\r\nbreak;\r\ncase IPT_ICMP_HOST_UNREACHABLE:\r\nsend_unreach(skb, ICMP_HOST_UNREACH);\r\nbreak;\r\ncase IPT_ICMP_PROT_UNREACHABLE:\r\nsend_unreach(skb, ICMP_PROT_UNREACH);\r\nbreak;\r\ncase IPT_ICMP_PORT_UNREACHABLE:\r\nsend_unreach(skb, ICMP_PORT_UNREACH);\r\nbreak;\r\ncase IPT_ICMP_NET_PROHIBITED:\r\nsend_unreach(skb, ICMP_NET_ANO);\r\nbreak;\r\ncase IPT_ICMP_HOST_PROHIBITED:\r\nsend_unreach(skb, ICMP_HOST_ANO);\r\nbreak;\r\ncase IPT_ICMP_ADMIN_PROHIBITED:\r\nsend_unreach(skb, ICMP_PKT_FILTERED);\r\nbreak;\r\ncase IPT_TCP_RESET:\r\nsend_reset(skb, par->hooknum);\r\ncase IPT_ICMP_ECHOREPLY:\r\nbreak;\r\n}\r\nreturn NF_DROP;\r\n}\r\nstatic int reject_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ipt_reject_info *rejinfo = par->targinfo;\r\nconst struct ipt_entry *e = par->entryinfo;\r\nif (rejinfo->with == IPT_ICMP_ECHOREPLY) {\r\npr_info("ECHOREPLY no longer supported.\n");\r\nreturn -EINVAL;\r\n} else if (rejinfo->with == IPT_TCP_RESET) {\r\nif (e->ip.proto != IPPROTO_TCP ||\r\n(e->ip.invflags & XT_INV_PROTO)) {\r\npr_info("TCP_RESET invalid for non-tcp\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init reject_tg_init(void)\r\n{\r\nreturn xt_register_target(&reject_tg_reg);\r\n}\r\nstatic void __exit reject_tg_exit(void)\r\n{\r\nxt_unregister_target(&reject_tg_reg);\r\n}
