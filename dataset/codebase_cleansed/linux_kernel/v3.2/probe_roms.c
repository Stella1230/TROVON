struct isci_orom *isci_request_oprom(struct pci_dev *pdev)\r\n{\r\nvoid __iomem *oprom = pci_map_biosrom(pdev);\r\nstruct isci_orom *rom = NULL;\r\nsize_t len, i;\r\nint j;\r\nchar oem_sig[4];\r\nstruct isci_oem_hdr oem_hdr;\r\nu8 *tmp, sum;\r\nif (!oprom)\r\nreturn NULL;\r\nlen = pci_biosrom_size(pdev);\r\nrom = devm_kzalloc(&pdev->dev, sizeof(*rom), GFP_KERNEL);\r\nif (!rom) {\r\ndev_warn(&pdev->dev,\r\n"Unable to allocate memory for orom\n");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < len && rom; i += ISCI_OEM_SIG_SIZE) {\r\nmemcpy_fromio(oem_sig, oprom + i, ISCI_OEM_SIG_SIZE);\r\nif (memcmp(oem_sig, ISCI_OEM_SIG, ISCI_OEM_SIG_SIZE) == 0) {\r\nsize_t copy_len;\r\nmemcpy_fromio(&oem_hdr, oprom + i, sizeof(oem_hdr));\r\ncopy_len = min(oem_hdr.len - sizeof(oem_hdr),\r\nsizeof(*rom));\r\nmemcpy_fromio(rom,\r\noprom + i + sizeof(oem_hdr),\r\ncopy_len);\r\ntmp = (u8 *)&oem_hdr;\r\nfor (j = 0, sum = 0; j < sizeof(oem_hdr); j++, tmp++)\r\nsum += *tmp;\r\ntmp = (u8 *)rom;\r\nfor (j = 0; j < sizeof(*rom); j++, tmp++)\r\nsum += *tmp;\r\nif (sum != 0) {\r\ndev_warn(&pdev->dev,\r\n"OEM table checksum failed\n");\r\ncontinue;\r\n}\r\nif (memcmp(rom->hdr.signature,\r\nISCI_ROM_SIG,\r\nISCI_ROM_SIG_SIZE) != 0)\r\ncontinue;\r\ndev_info(&pdev->dev,\r\n"OEM parameter table found in OROM\n");\r\nbreak;\r\n}\r\n}\r\nif (i >= len) {\r\ndev_err(&pdev->dev, "oprom parse error\n");\r\ndevm_kfree(&pdev->dev, rom);\r\nrom = NULL;\r\n}\r\npci_unmap_biosrom(oprom);\r\nreturn rom;\r\n}\r\nenum sci_status isci_parse_oem_parameters(struct sci_oem_params *oem,\r\nstruct isci_orom *orom, int scu_index)\r\n{\r\nif (scu_index < 0 || scu_index >= SCI_MAX_CONTROLLERS ||\r\nscu_index > orom->hdr.num_elements || !oem)\r\nreturn -EINVAL;\r\n*oem = orom->ctrl[scu_index];\r\nreturn 0;\r\n}\r\nstruct isci_orom *isci_request_firmware(struct pci_dev *pdev, const struct firmware *fw)\r\n{\r\nstruct isci_orom *orom = NULL, *data;\r\nint i, j;\r\nif (request_firmware(&fw, ISCI_FW_NAME, &pdev->dev) != 0)\r\nreturn NULL;\r\nif (fw->size < sizeof(*orom))\r\ngoto out;\r\ndata = (struct isci_orom *)fw->data;\r\nif (strncmp(ISCI_ROM_SIG, data->hdr.signature,\r\nstrlen(ISCI_ROM_SIG)) != 0)\r\ngoto out;\r\norom = devm_kzalloc(&pdev->dev, fw->size, GFP_KERNEL);\r\nif (!orom)\r\ngoto out;\r\nmemcpy(orom, fw->data, fw->size);\r\nif (is_c0(pdev))\r\ngoto out;\r\nfor (i = 0; i < ARRAY_SIZE(orom->ctrl); i++)\r\nfor (j = 0; j < ARRAY_SIZE(orom->ctrl[i].phys); j++) {\r\norom->ctrl[i].phys[j].afe_tx_amp_control0 = 0xe7c03;\r\norom->ctrl[i].phys[j].afe_tx_amp_control1 = 0xe7c03;\r\norom->ctrl[i].phys[j].afe_tx_amp_control2 = 0xe7c03;\r\norom->ctrl[i].phys[j].afe_tx_amp_control3 = 0xe7c03;\r\n}\r\nout:\r\nrelease_firmware(fw);\r\nreturn orom;\r\n}\r\nstatic struct efi *get_efi(void)\r\n{\r\n#ifdef CONFIG_EFI\r\nreturn &efi;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nstruct isci_orom *isci_get_efi_var(struct pci_dev *pdev)\r\n{\r\nefi_status_t status;\r\nstruct isci_orom *rom;\r\nstruct isci_oem_hdr *oem_hdr;\r\nu8 *tmp, sum;\r\nint j;\r\nunsigned long data_len;\r\nu8 *efi_data;\r\nu32 efi_attrib = 0;\r\ndata_len = 1024;\r\nefi_data = devm_kzalloc(&pdev->dev, data_len, GFP_KERNEL);\r\nif (!efi_data) {\r\ndev_warn(&pdev->dev,\r\n"Unable to allocate memory for EFI data\n");\r\nreturn NULL;\r\n}\r\nrom = (struct isci_orom *)(efi_data + sizeof(struct isci_oem_hdr));\r\nif (get_efi())\r\nstatus = get_efi()->get_variable(isci_efivar_name,\r\n&ISCI_EFI_VENDOR_GUID,\r\n&efi_attrib,\r\n&data_len,\r\nefi_data);\r\nelse\r\nstatus = EFI_NOT_FOUND;\r\nif (status != EFI_SUCCESS) {\r\ndev_warn(&pdev->dev,\r\n"Unable to obtain EFI var data for OEM parms\n");\r\nreturn NULL;\r\n}\r\noem_hdr = (struct isci_oem_hdr *)efi_data;\r\nif (memcmp(oem_hdr->sig, ISCI_OEM_SIG, ISCI_OEM_SIG_SIZE) != 0) {\r\ndev_warn(&pdev->dev,\r\n"Invalid OEM header signature\n");\r\nreturn NULL;\r\n}\r\ntmp = (u8 *)efi_data;\r\nfor (j = 0, sum = 0; j < (sizeof(*oem_hdr) + sizeof(*rom)); j++, tmp++)\r\nsum += *tmp;\r\nif (sum != 0) {\r\ndev_warn(&pdev->dev,\r\n"OEM table checksum failed\n");\r\nreturn NULL;\r\n}\r\nif (memcmp(rom->hdr.signature,\r\nISCI_ROM_SIG,\r\nISCI_ROM_SIG_SIZE) != 0) {\r\ndev_warn(&pdev->dev,\r\n"Invalid OEM table signature\n");\r\nreturn NULL;\r\n}\r\nreturn rom;\r\n}
