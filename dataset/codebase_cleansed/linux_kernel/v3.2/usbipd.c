static void usbipd_help(void)\r\n{\r\nprintf("%s\n", usbipd_help_string);\r\n}\r\nstatic int recv_request_import(int sockfd)\r\n{\r\nstruct op_import_request req;\r\nstruct op_common reply;\r\nstruct usbip_exported_device *edev;\r\nstruct usbip_usb_device pdu_udev;\r\nint found = 0;\r\nint error = 0;\r\nint rc;\r\nmemset(&req, 0, sizeof(req));\r\nmemset(&reply, 0, sizeof(reply));\r\nrc = usbip_net_recv(sockfd, &req, sizeof(req));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: import request");\r\nreturn -1;\r\n}\r\nPACK_OP_IMPORT_REQUEST(0, &req);\r\ndlist_for_each_data(host_driver->edev_list, edev,\r\nstruct usbip_exported_device) {\r\nif (!strncmp(req.busid, edev->udev.busid, SYSFS_BUS_ID_SIZE)) {\r\ninfo("found requested device: %s", req.busid);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nusbip_net_set_nodelay(sockfd);\r\nrc = usbip_host_export_device(edev, sockfd);\r\nif (rc < 0)\r\nerror = 1;\r\n} else {\r\ninfo("requested device not found: %s", req.busid);\r\nerror = 1;\r\n}\r\nrc = usbip_net_send_op_common(sockfd, OP_REP_IMPORT,\r\n(!error ? ST_OK : ST_NA));\r\nif (rc < 0) {\r\ndbg("usbip_net_send_op_common failed: %#0x", OP_REP_IMPORT);\r\nreturn -1;\r\n}\r\nif (error) {\r\ndbg("import request busid %s: failed", req.busid);\r\nreturn -1;\r\n}\r\nmemcpy(&pdu_udev, &edev->udev, sizeof(pdu_udev));\r\nusbip_net_pack_usb_device(1, &pdu_udev);\r\nrc = usbip_net_send(sockfd, &pdu_udev, sizeof(pdu_udev));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: devinfo");\r\nreturn -1;\r\n}\r\ndbg("import request busid %s: complete", req.busid);\r\nreturn 0;\r\n}\r\nstatic int send_reply_devlist(int connfd)\r\n{\r\nstruct usbip_exported_device *edev;\r\nstruct usbip_usb_device pdu_udev;\r\nstruct usbip_usb_interface pdu_uinf;\r\nstruct op_devlist_reply reply;\r\nint i;\r\nint rc;\r\nreply.ndev = 0;\r\ndlist_for_each_data(host_driver->edev_list, edev,\r\nstruct usbip_exported_device) {\r\nreply.ndev += 1;\r\n}\r\ninfo("exportable devices: %d", reply.ndev);\r\nrc = usbip_net_send_op_common(connfd, OP_REP_DEVLIST, ST_OK);\r\nif (rc < 0) {\r\ndbg("usbip_net_send_op_common failed: %#0x", OP_REP_DEVLIST);\r\nreturn -1;\r\n}\r\nPACK_OP_DEVLIST_REPLY(1, &reply);\r\nrc = usbip_net_send(connfd, &reply, sizeof(reply));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: %#0x", OP_REP_DEVLIST);\r\nreturn -1;\r\n}\r\ndlist_for_each_data(host_driver->edev_list, edev,\r\nstruct usbip_exported_device) {\r\ndump_usb_device(&edev->udev);\r\nmemcpy(&pdu_udev, &edev->udev, sizeof(pdu_udev));\r\nusbip_net_pack_usb_device(1, &pdu_udev);\r\nrc = usbip_net_send(connfd, &pdu_udev, sizeof(pdu_udev));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: pdu_udev");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < edev->udev.bNumInterfaces; i++) {\r\ndump_usb_interface(&edev->uinf[i]);\r\nmemcpy(&pdu_uinf, &edev->uinf[i], sizeof(pdu_uinf));\r\nusbip_net_pack_usb_interface(1, &pdu_uinf);\r\nrc = usbip_net_send(connfd, &pdu_uinf,\r\nsizeof(pdu_uinf));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: pdu_uinf");\r\nreturn -1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int recv_request_devlist(int connfd)\r\n{\r\nstruct op_devlist_request req;\r\nint rc;\r\nmemset(&req, 0, sizeof(req));\r\nrc = usbip_net_recv(connfd, &req, sizeof(req));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: devlist request");\r\nreturn -1;\r\n}\r\nrc = send_reply_devlist(connfd);\r\nif (rc < 0) {\r\ndbg("send_reply_devlist failed");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int recv_pdu(int connfd)\r\n{\r\nuint16_t code = OP_UNSPEC;\r\nint ret;\r\nret = usbip_net_recv_op_common(connfd, &code);\r\nif (ret < 0) {\r\ndbg("could not receive opcode: %#0x", code);\r\nreturn -1;\r\n}\r\nret = usbip_host_refresh_device_list();\r\nif (ret < 0) {\r\ndbg("could not refresh device list: %d", ret);\r\nreturn -1;\r\n}\r\ninfo("received request: %#0x(%d)", code, connfd);\r\nswitch (code) {\r\ncase OP_REQ_DEVLIST:\r\nret = recv_request_devlist(connfd);\r\nbreak;\r\ncase OP_REQ_IMPORT:\r\nret = recv_request_import(connfd);\r\nbreak;\r\ncase OP_REQ_DEVINFO:\r\ncase OP_REQ_CRYPKEY:\r\ndefault:\r\nerr("received an unknown opcode: %#0x", code);\r\nret = -1;\r\n}\r\nif (ret == 0)\r\ninfo("request %#0x(%d): complete", code, connfd);\r\nelse\r\ninfo("request %#0x(%d): failed", code, connfd);\r\nreturn ret;\r\n}\r\nstatic int tcpd_auth(int connfd)\r\n{\r\nstruct request_info request;\r\nint rc;\r\nrequest_init(&request, RQ_DAEMON, PROGNAME, RQ_FILE, connfd, 0);\r\nfromhost(&request);\r\nrc = hosts_access(&request);\r\nif (rc == 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int do_accept(int listenfd)\r\n{\r\nint connfd;\r\nstruct sockaddr_storage ss;\r\nsocklen_t len = sizeof(ss);\r\nchar host[NI_MAXHOST], port[NI_MAXSERV];\r\nint rc;\r\nmemset(&ss, 0, sizeof(ss));\r\nconnfd = accept(listenfd, (struct sockaddr *) &ss, &len);\r\nif (connfd < 0) {\r\nerr("failed to accept connection");\r\nreturn -1;\r\n}\r\nrc = getnameinfo((struct sockaddr *) &ss, len, host, sizeof(host),\r\nport, sizeof(port), NI_NUMERICHOST | NI_NUMERICSERV);\r\nif (rc)\r\nerr("getnameinfo: %s", gai_strerror(rc));\r\n#ifdef HAVE_LIBWRAP\r\nrc = tcpd_auth(connfd);\r\nif (rc < 0) {\r\ninfo("denied access from %s", host);\r\nclose(connfd);\r\nreturn -1;\r\n}\r\n#endif\r\ninfo("connection from %s:%s", host, port);\r\nreturn connfd;\r\n}\r\ngboolean process_request(GIOChannel *gio, GIOCondition condition,\r\ngpointer unused_data)\r\n{\r\nint listenfd;\r\nint connfd;\r\n(void) unused_data;\r\nif (condition & (G_IO_ERR | G_IO_HUP | G_IO_NVAL)) {\r\nerr("unknown condition");\r\nBUG();\r\n}\r\nif (condition & G_IO_IN) {\r\nlistenfd = g_io_channel_unix_get_fd(gio);\r\nconnfd = do_accept(listenfd);\r\nif (connfd < 0)\r\nreturn TRUE;\r\nrecv_pdu(connfd);\r\nclose(connfd);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void log_addrinfo(struct addrinfo *ai)\r\n{\r\nchar hbuf[NI_MAXHOST];\r\nchar sbuf[NI_MAXSERV];\r\nint rc;\r\nrc = getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, sizeof(hbuf),\r\nsbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);\r\nif (rc)\r\nerr("getnameinfo: %s", gai_strerror(rc));\r\ninfo("listening on %s:%s", hbuf, sbuf);\r\n}\r\nstatic int listen_all_addrinfo(struct addrinfo *ai_head, int sockfdlist[])\r\n{\r\nstruct addrinfo *ai;\r\nint ret, nsockfd = 0;\r\nfor (ai = ai_head; ai && nsockfd < MAXSOCKFD; ai = ai->ai_next) {\r\nsockfdlist[nsockfd] = socket(ai->ai_family, ai->ai_socktype,\r\nai->ai_protocol);\r\nif (sockfdlist[nsockfd] < 0)\r\ncontinue;\r\nusbip_net_set_reuseaddr(sockfdlist[nsockfd]);\r\nusbip_net_set_nodelay(sockfdlist[nsockfd]);\r\nif (sockfdlist[nsockfd] >= FD_SETSIZE) {\r\nclose(sockfdlist[nsockfd]);\r\nsockfdlist[nsockfd] = -1;\r\ncontinue;\r\n}\r\nret = bind(sockfdlist[nsockfd], ai->ai_addr, ai->ai_addrlen);\r\nif (ret < 0) {\r\nclose(sockfdlist[nsockfd]);\r\nsockfdlist[nsockfd] = -1;\r\ncontinue;\r\n}\r\nret = listen(sockfdlist[nsockfd], SOMAXCONN);\r\nif (ret < 0) {\r\nclose(sockfdlist[nsockfd]);\r\nsockfdlist[nsockfd] = -1;\r\ncontinue;\r\n}\r\nlog_addrinfo(ai);\r\nnsockfd++;\r\n}\r\nif (nsockfd == 0)\r\nreturn -1;\r\ndbg("listening on %d address%s", nsockfd, (nsockfd == 1) ? "" : "es");\r\nreturn nsockfd;\r\n}\r\nstatic struct addrinfo *do_getaddrinfo(char *host, int ai_family)\r\n{\r\nstruct addrinfo hints, *ai_head;\r\nint rc;\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_family = ai_family;\r\nhints.ai_socktype = SOCK_STREAM;\r\nhints.ai_flags = AI_PASSIVE;\r\nrc = getaddrinfo(host, USBIP_PORT_STRING, &hints, &ai_head);\r\nif (rc) {\r\nerr("failed to get a network address %s: %s", USBIP_PORT_STRING,\r\ngai_strerror(rc));\r\nreturn NULL;\r\n}\r\nreturn ai_head;\r\n}\r\nstatic void signal_handler(int i)\r\n{\r\ndbg("received signal: code %d", i);\r\nif (main_loop)\r\ng_main_loop_quit(main_loop);\r\n}\r\nstatic void set_signal(void)\r\n{\r\nstruct sigaction act;\r\nmemset(&act, 0, sizeof(act));\r\nact.sa_handler = signal_handler;\r\nsigemptyset(&act.sa_mask);\r\nsigaction(SIGTERM, &act, NULL);\r\nsigaction(SIGINT, &act, NULL);\r\n}\r\nstatic int do_standalone_mode(gboolean daemonize)\r\n{\r\nstruct addrinfo *ai_head;\r\nint sockfdlist[MAXSOCKFD];\r\nint nsockfd;\r\nint i;\r\nif (usbip_names_init(USBIDS_FILE))\r\nerr("failed to open %s", USBIDS_FILE);\r\nif (usbip_host_driver_open()) {\r\nerr("please load " USBIP_CORE_MOD_NAME ".ko and "\r\nUSBIP_HOST_DRV_NAME ".ko!");\r\nreturn -1;\r\n}\r\nif (daemonize) {\r\nif (daemon(0,0) < 0) {\r\nerr("daemonizing failed: %s", strerror(errno));\r\nreturn -1;\r\n}\r\nusbip_use_syslog = 1;\r\n}\r\nset_signal();\r\nai_head = do_getaddrinfo(NULL, PF_UNSPEC);\r\nif (!ai_head)\r\nreturn -1;\r\ninfo("starting " PROGNAME " (%s)", usbip_version_string);\r\nnsockfd = listen_all_addrinfo(ai_head, sockfdlist);\r\nif (nsockfd <= 0) {\r\nerr("failed to open a listening socket");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < nsockfd; i++) {\r\nGIOChannel *gio;\r\ngio = g_io_channel_unix_new(sockfdlist[i]);\r\ng_io_add_watch(gio, (G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL),\r\nprocess_request, NULL);\r\n}\r\nmain_loop = g_main_loop_new(FALSE, FALSE);\r\ng_main_loop_run(main_loop);\r\ninfo("shutting down " PROGNAME);\r\nfreeaddrinfo(ai_head);\r\nusbip_host_driver_close();\r\nusbip_names_free();\r\nreturn 0;\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nstatic const struct option longopts[] = {\r\n{ "daemon", no_argument, NULL, 'D' },\r\n{ "debug", no_argument, NULL, 'd' },\r\n{ "help", no_argument, NULL, 'h' },\r\n{ "version", no_argument, NULL, 'v' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nenum {\r\ncmd_standalone_mode = 1,\r\ncmd_help,\r\ncmd_version\r\n} cmd;\r\ngboolean daemonize = FALSE;\r\nint opt, rc = -1;\r\nusbip_use_stderr = 1;\r\nusbip_use_syslog = 0;\r\nif (geteuid() != 0)\r\nerr("not running as root?");\r\ncmd = cmd_standalone_mode;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "Ddhv", longopts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'D':\r\ndaemonize = TRUE;\r\nbreak;\r\ncase 'd':\r\nusbip_use_debug = 1;\r\nbreak;\r\ncase 'h':\r\ncmd = cmd_help;\r\nbreak;\r\ncase 'v':\r\ncmd = cmd_version;\r\nbreak;\r\ncase '?':\r\nusbipd_help();\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nswitch (cmd) {\r\ncase cmd_standalone_mode:\r\nrc = do_standalone_mode(daemonize);\r\nbreak;\r\ncase cmd_version:\r\nprintf(PROGNAME " (%s)\n", usbip_version_string);\r\nrc = 0;\r\nbreak;\r\ncase cmd_help:\r\nusbipd_help();\r\nrc = 0;\r\nbreak;\r\ndefault:\r\nusbipd_help();\r\ngoto err_out;\r\n}\r\nerr_out:\r\nreturn (rc > -1 ? EXIT_SUCCESS : EXIT_FAILURE);\r\n}
