static irqreturn_t wl1251_irq(int irq, void *cookie)\r\n{\r\nstruct wl1251 *wl;\r\nwl1251_debug(DEBUG_IRQ, "IRQ");\r\nwl = cookie;\r\nieee80211_queue_work(wl->hw, &wl->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct spi_device *wl_to_spi(struct wl1251 *wl)\r\n{\r\nreturn wl->if_priv;\r\n}\r\nstatic void wl1251_spi_reset(struct wl1251 *wl)\r\n{\r\nu8 *cmd;\r\nstruct spi_transfer t;\r\nstruct spi_message m;\r\ncmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);\r\nif (!cmd) {\r\nwl1251_error("could not allocate cmd for spi reset");\r\nreturn;\r\n}\r\nmemset(&t, 0, sizeof(t));\r\nspi_message_init(&m);\r\nmemset(cmd, 0xff, WSPI_INIT_CMD_LEN);\r\nt.tx_buf = cmd;\r\nt.len = WSPI_INIT_CMD_LEN;\r\nspi_message_add_tail(&t, &m);\r\nspi_sync(wl_to_spi(wl), &m);\r\nwl1251_dump(DEBUG_SPI, "spi reset -> ", cmd, WSPI_INIT_CMD_LEN);\r\n}\r\nstatic void wl1251_spi_wake(struct wl1251 *wl)\r\n{\r\nu8 crc[WSPI_INIT_CMD_CRC_LEN], *cmd;\r\nstruct spi_transfer t;\r\nstruct spi_message m;\r\ncmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);\r\nif (!cmd) {\r\nwl1251_error("could not allocate cmd for spi init");\r\nreturn;\r\n}\r\nmemset(crc, 0, sizeof(crc));\r\nmemset(&t, 0, sizeof(t));\r\nspi_message_init(&m);\r\ncmd[2] = 0xff;\r\ncmd[3] = 0xff;\r\ncmd[1] = WSPI_INIT_CMD_START | WSPI_INIT_CMD_TX;\r\ncmd[0] = 0;\r\ncmd[7] = 0;\r\ncmd[6] |= HW_ACCESS_WSPI_INIT_CMD_MASK << 3;\r\ncmd[6] |= HW_ACCESS_WSPI_FIXED_BUSY_LEN & WSPI_INIT_CMD_FIXEDBUSY_LEN;\r\nif (HW_ACCESS_WSPI_FIXED_BUSY_LEN == 0)\r\ncmd[5] |= WSPI_INIT_CMD_DIS_FIXEDBUSY;\r\nelse\r\ncmd[5] |= WSPI_INIT_CMD_EN_FIXEDBUSY;\r\ncmd[5] |= WSPI_INIT_CMD_IOD | WSPI_INIT_CMD_IP | WSPI_INIT_CMD_CS\r\n| WSPI_INIT_CMD_WSPI | WSPI_INIT_CMD_WS;\r\ncrc[0] = cmd[1];\r\ncrc[1] = cmd[0];\r\ncrc[2] = cmd[7];\r\ncrc[3] = cmd[6];\r\ncrc[4] = cmd[5];\r\ncmd[4] |= crc7(0, crc, WSPI_INIT_CMD_CRC_LEN) << 1;\r\ncmd[4] |= WSPI_INIT_CMD_END;\r\nt.tx_buf = cmd;\r\nt.len = WSPI_INIT_CMD_LEN;\r\nspi_message_add_tail(&t, &m);\r\nspi_sync(wl_to_spi(wl), &m);\r\nwl1251_dump(DEBUG_SPI, "spi init -> ", cmd, WSPI_INIT_CMD_LEN);\r\n}\r\nstatic void wl1251_spi_reset_wake(struct wl1251 *wl)\r\n{\r\nwl1251_spi_reset(wl);\r\nwl1251_spi_wake(wl);\r\n}\r\nstatic void wl1251_spi_read(struct wl1251 *wl, int addr, void *buf,\r\nsize_t len)\r\n{\r\nstruct spi_transfer t[3];\r\nstruct spi_message m;\r\nu8 *busy_buf;\r\nu32 *cmd;\r\ncmd = &wl->buffer_cmd;\r\nbusy_buf = wl->buffer_busyword;\r\n*cmd = 0;\r\n*cmd |= WSPI_CMD_READ;\r\n*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;\r\n*cmd |= addr & WSPI_CMD_BYTE_ADDR;\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = cmd;\r\nt[0].len = 4;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = busy_buf;\r\nt[1].len = WL1251_BUSY_WORD_LEN;\r\nspi_message_add_tail(&t[1], &m);\r\nt[2].rx_buf = buf;\r\nt[2].len = len;\r\nspi_message_add_tail(&t[2], &m);\r\nspi_sync(wl_to_spi(wl), &m);\r\nwl1251_dump(DEBUG_SPI, "spi_read cmd -> ", cmd, sizeof(*cmd));\r\nwl1251_dump(DEBUG_SPI, "spi_read buf <- ", buf, len);\r\n}\r\nstatic void wl1251_spi_write(struct wl1251 *wl, int addr, void *buf,\r\nsize_t len)\r\n{\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nu32 *cmd;\r\ncmd = &wl->buffer_cmd;\r\n*cmd = 0;\r\n*cmd |= WSPI_CMD_WRITE;\r\n*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;\r\n*cmd |= addr & WSPI_CMD_BYTE_ADDR;\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = cmd;\r\nt[0].len = sizeof(*cmd);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nt[1].len = len;\r\nspi_message_add_tail(&t[1], &m);\r\nspi_sync(wl_to_spi(wl), &m);\r\nwl1251_dump(DEBUG_SPI, "spi_write cmd -> ", cmd, sizeof(*cmd));\r\nwl1251_dump(DEBUG_SPI, "spi_write buf -> ", buf, len);\r\n}\r\nstatic void wl1251_spi_enable_irq(struct wl1251 *wl)\r\n{\r\nreturn enable_irq(wl->irq);\r\n}\r\nstatic void wl1251_spi_disable_irq(struct wl1251 *wl)\r\n{\r\nreturn disable_irq(wl->irq);\r\n}\r\nstatic int wl1251_spi_set_power(struct wl1251 *wl, bool enable)\r\n{\r\nif (wl->set_power)\r\nwl->set_power(enable);\r\nreturn 0;\r\n}\r\nstatic int __devinit wl1251_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wl12xx_platform_data *pdata;\r\nstruct ieee80211_hw *hw;\r\nstruct wl1251 *wl;\r\nint ret;\r\npdata = spi->dev.platform_data;\r\nif (!pdata) {\r\nwl1251_error("no platform data");\r\nreturn -ENODEV;\r\n}\r\nhw = wl1251_alloc_hw();\r\nif (IS_ERR(hw))\r\nreturn PTR_ERR(hw);\r\nwl = hw->priv;\r\nSET_IEEE80211_DEV(hw, &spi->dev);\r\ndev_set_drvdata(&spi->dev, wl);\r\nwl->if_priv = spi;\r\nwl->if_ops = &wl1251_spi_ops;\r\nspi->bits_per_word = 32;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\nwl1251_error("spi_setup failed");\r\ngoto out_free;\r\n}\r\nwl->set_power = pdata->set_power;\r\nif (!wl->set_power) {\r\nwl1251_error("set power function missing in platform data");\r\nreturn -ENODEV;\r\n}\r\nwl->irq = spi->irq;\r\nif (wl->irq < 0) {\r\nwl1251_error("irq missing in platform data");\r\nreturn -ENODEV;\r\n}\r\nwl->use_eeprom = pdata->use_eeprom;\r\nret = request_irq(wl->irq, wl1251_irq, 0, DRIVER_NAME, wl);\r\nif (ret < 0) {\r\nwl1251_error("request_irq() failed: %d", ret);\r\ngoto out_free;\r\n}\r\nirq_set_irq_type(wl->irq, IRQ_TYPE_EDGE_RISING);\r\ndisable_irq(wl->irq);\r\nret = wl1251_init_ieee80211(wl);\r\nif (ret)\r\ngoto out_irq;\r\nreturn 0;\r\nout_irq:\r\nfree_irq(wl->irq, wl);\r\nout_free:\r\nieee80211_free_hw(hw);\r\nreturn ret;\r\n}\r\nstatic int __devexit wl1251_spi_remove(struct spi_device *spi)\r\n{\r\nstruct wl1251 *wl = dev_get_drvdata(&spi->dev);\r\nfree_irq(wl->irq, wl);\r\nwl1251_free_hw(wl);\r\nreturn 0;\r\n}\r\nstatic int __init wl1251_spi_init(void)\r\n{\r\nint ret;\r\nret = spi_register_driver(&wl1251_spi_driver);\r\nif (ret < 0) {\r\nwl1251_error("failed to register spi driver: %d", ret);\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit wl1251_spi_exit(void)\r\n{\r\nspi_unregister_driver(&wl1251_spi_driver);\r\nwl1251_notice("unloaded");\r\n}
