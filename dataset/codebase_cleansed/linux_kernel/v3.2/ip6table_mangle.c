static unsigned int\r\nip6t_mangle_out(struct sk_buff *skb, const struct net_device *out)\r\n{\r\nunsigned int ret;\r\nstruct in6_addr saddr, daddr;\r\nu_int8_t hop_limit;\r\nu_int32_t flowlabel, mark;\r\n#if 0\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr)) {\r\nif (net_ratelimit())\r\npr_warning("ip6t_hook: happy cracking.\n");\r\nreturn NF_ACCEPT;\r\n}\r\n#endif\r\nmemcpy(&saddr, &ipv6_hdr(skb)->saddr, sizeof(saddr));\r\nmemcpy(&daddr, &ipv6_hdr(skb)->daddr, sizeof(daddr));\r\nmark = skb->mark;\r\nhop_limit = ipv6_hdr(skb)->hop_limit;\r\nflowlabel = *((u_int32_t *)ipv6_hdr(skb));\r\nret = ip6t_do_table(skb, NF_INET_LOCAL_OUT, NULL, out,\r\ndev_net(out)->ipv6.ip6table_mangle);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(memcmp(&ipv6_hdr(skb)->saddr, &saddr, sizeof(saddr)) ||\r\nmemcmp(&ipv6_hdr(skb)->daddr, &daddr, sizeof(daddr)) ||\r\nskb->mark != mark ||\r\nipv6_hdr(skb)->hop_limit != hop_limit ||\r\nflowlabel != *((u_int32_t *)ipv6_hdr(skb))))\r\nreturn ip6_route_me_harder(skb) == 0 ? ret : NF_DROP;\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nip6table_mangle_hook(unsigned int hook, struct sk_buff *skb,\r\nconst struct net_device *in, const struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nif (hook == NF_INET_LOCAL_OUT)\r\nreturn ip6t_mangle_out(skb, out);\r\nif (hook == NF_INET_POST_ROUTING)\r\nreturn ip6t_do_table(skb, hook, in, out,\r\ndev_net(out)->ipv6.ip6table_mangle);\r\nreturn ip6t_do_table(skb, hook, in, out,\r\ndev_net(in)->ipv6.ip6table_mangle);\r\n}\r\nstatic int __net_init ip6table_mangle_net_init(struct net *net)\r\n{\r\nstruct ip6t_replace *repl;\r\nrepl = ip6t_alloc_initial_table(&packet_mangler);\r\nif (repl == NULL)\r\nreturn -ENOMEM;\r\nnet->ipv6.ip6table_mangle =\r\nip6t_register_table(net, &packet_mangler, repl);\r\nkfree(repl);\r\nif (IS_ERR(net->ipv6.ip6table_mangle))\r\nreturn PTR_ERR(net->ipv6.ip6table_mangle);\r\nreturn 0;\r\n}\r\nstatic void __net_exit ip6table_mangle_net_exit(struct net *net)\r\n{\r\nip6t_unregister_table(net, net->ipv6.ip6table_mangle);\r\n}\r\nstatic int __init ip6table_mangle_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&ip6table_mangle_net_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nmangle_ops = xt_hook_link(&packet_mangler, ip6table_mangle_hook);\r\nif (IS_ERR(mangle_ops)) {\r\nret = PTR_ERR(mangle_ops);\r\ngoto cleanup_table;\r\n}\r\nreturn ret;\r\ncleanup_table:\r\nunregister_pernet_subsys(&ip6table_mangle_net_ops);\r\nreturn ret;\r\n}\r\nstatic void __exit ip6table_mangle_fini(void)\r\n{\r\nxt_hook_unlink(&packet_mangler, mangle_ops);\r\nunregister_pernet_subsys(&ip6table_mangle_net_ops);\r\n}
