static void vsxxxaa_drop_bytes(struct vsxxxaa *mouse, int num)\r\n{\r\nif (num >= mouse->count) {\r\nmouse->count = 0;\r\n} else {\r\nmemmove(mouse->buf, mouse->buf + num - 1, BUFLEN - num);\r\nmouse->count -= num;\r\n}\r\n}\r\nstatic void vsxxxaa_queue_byte(struct vsxxxaa *mouse, unsigned char byte)\r\n{\r\nif (mouse->count == BUFLEN) {\r\nprintk(KERN_ERR "%s on %s: Dropping a byte of full buffer.\n",\r\nmouse->name, mouse->phys);\r\nvsxxxaa_drop_bytes(mouse, 1);\r\n}\r\nDBG(KERN_INFO "Queueing byte 0x%02x\n", byte);\r\nmouse->buf[mouse->count++] = byte;\r\n}\r\nstatic void vsxxxaa_detection_done(struct vsxxxaa *mouse)\r\n{\r\nswitch (mouse->type) {\r\ncase 0x02:\r\nstrlcpy(mouse->name, "DEC VSXXX-AA/-GA mouse",\r\nsizeof(mouse->name));\r\nbreak;\r\ncase 0x04:\r\nstrlcpy(mouse->name, "DEC VSXXX-AB digitizer",\r\nsizeof(mouse->name));\r\nbreak;\r\ndefault:\r\nsnprintf(mouse->name, sizeof(mouse->name),\r\n"unknown DEC pointer device (type = 0x%02x)",\r\nmouse->type);\r\nbreak;\r\n}\r\nprintk(KERN_INFO\r\n"Found %s version 0x%02x from country 0x%02x on port %s\n",\r\nmouse->name, mouse->version, mouse->country, mouse->phys);\r\n}\r\nstatic int vsxxxaa_check_packet(struct vsxxxaa *mouse, int packet_len)\r\n{\r\nint i;\r\nif (!IS_HDR_BYTE(mouse->buf[0])) {\r\nDBG("vsck: len=%d, 1st=0x%02x\n", packet_len, mouse->buf[0]);\r\nreturn 1;\r\n}\r\nfor (i = 1; i < packet_len; i++) {\r\nif (IS_HDR_BYTE(mouse->buf[i])) {\r\nprintk(KERN_ERR\r\n"Need to drop %d bytes of a broken packet.\n",\r\ni - 1);\r\nDBG(KERN_INFO "check: len=%d, b[%d]=0x%02x\n",\r\npacket_len, i, mouse->buf[i]);\r\nreturn i - 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int vsxxxaa_smells_like_packet(struct vsxxxaa *mouse,\r\nunsigned char type, size_t len)\r\n{\r\nreturn mouse->count >= len && MATCH_PACKET_TYPE(mouse->buf[0], type);\r\n}\r\nstatic void vsxxxaa_handle_REL_packet(struct vsxxxaa *mouse)\r\n{\r\nstruct input_dev *dev = mouse->dev;\r\nunsigned char *buf = mouse->buf;\r\nint left, middle, right;\r\nint dx, dy;\r\ndx = buf[1] & 0x7f;\r\ndx *= ((buf[0] >> 4) & 0x01) ? 1 : -1;\r\ndy = buf[2] & 0x7f;\r\ndy *= ((buf[0] >> 3) & 0x01) ? -1 : 1;\r\nleft = buf[0] & 0x04;\r\nmiddle = buf[0] & 0x02;\r\nright = buf[0] & 0x01;\r\nvsxxxaa_drop_bytes(mouse, 3);\r\nDBG(KERN_INFO "%s on %s: dx=%d, dy=%d, buttons=%s%s%s\n",\r\nmouse->name, mouse->phys, dx, dy,\r\nleft ? "L" : "l", middle ? "M" : "m", right ? "R" : "r");\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\ninput_report_rel(dev, REL_X, dx);\r\ninput_report_rel(dev, REL_Y, dy);\r\ninput_sync(dev);\r\n}\r\nstatic void vsxxxaa_handle_ABS_packet(struct vsxxxaa *mouse)\r\n{\r\nstruct input_dev *dev = mouse->dev;\r\nunsigned char *buf = mouse->buf;\r\nint left, middle, right, touch;\r\nint x, y;\r\nx = ((buf[2] & 0x3f) << 6) | (buf[1] & 0x3f);\r\ny = ((buf[4] & 0x3f) << 6) | (buf[3] & 0x3f);\r\ny = 1023 - y;\r\nleft = buf[0] & 0x02;\r\nmiddle = buf[0] & 0x04;\r\nright = buf[0] & 0x08;\r\ntouch = buf[0] & 0x10;\r\nvsxxxaa_drop_bytes(mouse, 5);\r\nDBG(KERN_INFO "%s on %s: x=%d, y=%d, buttons=%s%s%s%s\n",\r\nmouse->name, mouse->phys, x, y,\r\nleft ? "L" : "l", middle ? "M" : "m",\r\nright ? "R" : "r", touch ? "T" : "t");\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_key(dev, BTN_TOUCH, touch);\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_sync(dev);\r\n}\r\nstatic void vsxxxaa_handle_POR_packet(struct vsxxxaa *mouse)\r\n{\r\nstruct input_dev *dev = mouse->dev;\r\nunsigned char *buf = mouse->buf;\r\nint left, middle, right;\r\nunsigned char error;\r\nmouse->version = buf[0] & 0x0f;\r\nmouse->country = (buf[1] >> 4) & 0x07;\r\nmouse->type = buf[1] & 0x0f;\r\nerror = buf[2] & 0x7f;\r\nleft = buf[0] & 0x04;\r\nmiddle = buf[0] & 0x02;\r\nright = buf[0] & 0x01;\r\nvsxxxaa_drop_bytes(mouse, 4);\r\nvsxxxaa_detection_done(mouse);\r\nif (error <= 0x1f) {\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\ninput_sync(dev);\r\nif (error != 0)\r\nprintk(KERN_INFO "Your %s on %s reports error=0x%02x\n",\r\nmouse->name, mouse->phys, error);\r\n}\r\nprintk(KERN_NOTICE\r\n"%s on %s: Forcing standard packet format, "\r\n"incremental streaming mode and 72 samples/sec\n",\r\nmouse->name, mouse->phys);\r\nserio_write(mouse->serio, 'S');\r\nmdelay(50);\r\nserio_write(mouse->serio, 'R');\r\nmdelay(50);\r\nserio_write(mouse->serio, 'L');\r\n}\r\nstatic void vsxxxaa_parse_buffer(struct vsxxxaa *mouse)\r\n{\r\nunsigned char *buf = mouse->buf;\r\nint stray_bytes;\r\ndo {\r\nwhile (mouse->count > 0 && !IS_HDR_BYTE(buf[0])) {\r\nprintk(KERN_ERR "%s on %s: Dropping a byte to regain "\r\n"sync with mouse data stream...\n",\r\nmouse->name, mouse->phys);\r\nvsxxxaa_drop_bytes(mouse, 1);\r\n}\r\nif (vsxxxaa_smells_like_packet(mouse, VSXXXAA_PACKET_REL, 3)) {\r\nstray_bytes = vsxxxaa_check_packet(mouse, 3);\r\nif (!stray_bytes)\r\nvsxxxaa_handle_REL_packet(mouse);\r\n} else if (vsxxxaa_smells_like_packet(mouse,\r\nVSXXXAA_PACKET_ABS, 5)) {\r\nstray_bytes = vsxxxaa_check_packet(mouse, 5);\r\nif (!stray_bytes)\r\nvsxxxaa_handle_ABS_packet(mouse);\r\n} else if (vsxxxaa_smells_like_packet(mouse,\r\nVSXXXAA_PACKET_POR, 4)) {\r\nstray_bytes = vsxxxaa_check_packet(mouse, 4);\r\nif (!stray_bytes)\r\nvsxxxaa_handle_POR_packet(mouse);\r\n} else {\r\nbreak;\r\n}\r\nif (stray_bytes > 0) {\r\nprintk(KERN_ERR "Dropping %d bytes now...\n",\r\nstray_bytes);\r\nvsxxxaa_drop_bytes(mouse, stray_bytes);\r\n}\r\n} while (1);\r\n}\r\nstatic irqreturn_t vsxxxaa_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct vsxxxaa *mouse = serio_get_drvdata(serio);\r\nvsxxxaa_queue_byte(mouse, data);\r\nvsxxxaa_parse_buffer(mouse);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void vsxxxaa_disconnect(struct serio *serio)\r\n{\r\nstruct vsxxxaa *mouse = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(mouse->dev);\r\nkfree(mouse);\r\n}\r\nstatic int vsxxxaa_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct vsxxxaa *mouse;\r\nstruct input_dev *input_dev;\r\nint err = -ENOMEM;\r\nmouse = kzalloc(sizeof(struct vsxxxaa), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!mouse || !input_dev)\r\ngoto fail1;\r\nmouse->dev = input_dev;\r\nmouse->serio = serio;\r\nstrlcat(mouse->name, "DEC VSXXX-AA/-GA mouse or VSXXX-AB digitizer",\r\nsizeof(mouse->name));\r\nsnprintf(mouse->phys, sizeof(mouse->phys), "%s/input0", serio->phys);\r\ninput_dev->name = mouse->name;\r\ninput_dev->phys = mouse->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->dev.parent = &serio->dev;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_REL, input_dev->evbit);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_MIDDLE, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\n__set_bit(REL_X, input_dev->relbit);\r\n__set_bit(REL_Y, input_dev->relbit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, 1023, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 1023, 0, 0);\r\nserio_set_drvdata(serio, mouse);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nserio_write(serio, 'T');\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(mouse);\r\nreturn err;\r\n}\r\nstatic int __init vsxxxaa_init(void)\r\n{\r\nreturn serio_register_driver(&vsxxxaa_drv);\r\n}\r\nstatic void __exit vsxxxaa_exit(void)\r\n{\r\nserio_unregister_driver(&vsxxxaa_drv);\r\n}
