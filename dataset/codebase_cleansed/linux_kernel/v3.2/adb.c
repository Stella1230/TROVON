static int adb_scan_bus(void)\r\n{\r\nint i, highFree=0, noMovement;\r\nint devmask = 0;\r\nstruct adb_request req;\r\nfor (i = 1; i < 16; i++) {\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\n(i << 4) | 0xf);\r\nif (req.reply_len > 1)\r\nadb_handler[i].original_address = i;\r\nelse if (i > highFree)\r\nhighFree = i;\r\n}\r\nfor (noMovement = 1; noMovement < 2 && highFree > 0; noMovement++) {\r\nfor (i = 1; i < 16; i++) {\r\nif (adb_handler[i].original_address == 0)\r\ncontinue;\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\n(i << 4) | 0xf);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\n(i<< 4) | 0xb, (highFree | 0x60), 0xfe);\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\n(highFree << 4) | 0xf);\r\nif (req.reply_len <= 1) continue;\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\n(i << 4) | 0xf);\r\nif (req.reply_len > 1) {\r\nadb_handler[highFree].original_address =\r\nadb_handler[i].original_address;\r\nwhile (highFree > 0 &&\r\nadb_handler[highFree].original_address)\r\nhighFree--;\r\nif (highFree <= 0)\r\nbreak;\r\nnoMovement = 0;\r\n}\r\nelse {\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\n(highFree << 4) | 0xb,\r\n(i | 0x60), 0xfe);\r\n}\r\n}\r\n}\r\nprintk(KERN_DEBUG "adb devices:");\r\nfor (i = 1; i < 16; i++) {\r\nif (adb_handler[i].original_address == 0)\r\ncontinue;\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\n(i << 4) | 0xf);\r\nadb_handler[i].handler_id = req.reply[2];\r\nprintk(" [%d]: %d %x", i, adb_handler[i].original_address,\r\nadb_handler[i].handler_id);\r\ndevmask |= 1 << i;\r\n}\r\nprintk("\n");\r\nreturn devmask;\r\n}\r\nstatic int\r\nadb_probe_task(void *x)\r\n{\r\nprintk(KERN_INFO "adb: starting probe task...\n");\r\ndo_adb_reset_bus();\r\nprintk(KERN_INFO "adb: finished probe task...\n");\r\nup(&adb_probe_mutex);\r\nreturn 0;\r\n}\r\nstatic void\r\n__adb_probe_task(struct work_struct *bullshit)\r\n{\r\nkthread_run(adb_probe_task, NULL, "kadbprobe");\r\n}\r\nint\r\nadb_reset_bus(void)\r\n{\r\nif (__adb_probe_sync) {\r\ndo_adb_reset_bus();\r\nreturn 0;\r\n}\r\ndown(&adb_probe_mutex);\r\nschedule_work(&adb_reset_work);\r\nreturn 0;\r\n}\r\nstatic int adb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nadb_got_sleep = 1;\r\ndown(&adb_probe_mutex);\r\nif (adb_controller->autopoll)\r\nadb_controller->autopoll(0);\r\nblocking_notifier_call_chain(&adb_client_list, ADB_MSG_POWERDOWN, NULL);\r\nreturn 0;\r\n}\r\nstatic int adb_resume(struct platform_device *dev)\r\n{\r\nadb_got_sleep = 0;\r\nup(&adb_probe_mutex);\r\nadb_reset_bus();\r\nreturn 0;\r\n}\r\nstatic int __init adb_init(void)\r\n{\r\nstruct adb_driver *driver;\r\nint i;\r\n#ifdef CONFIG_PPC32\r\nif (!machine_is(chrp) && !machine_is(powermac))\r\nreturn 0;\r\n#endif\r\n#ifdef CONFIG_MAC\r\nif (!MACH_IS_MAC)\r\nreturn 0;\r\n#endif\r\nif (adb_inited)\r\nreturn 0;\r\nadb_inited = 1;\r\nadb_controller = NULL;\r\ni = 0;\r\nwhile ((driver = adb_driver_list[i++]) != NULL) {\r\nif (!driver->probe()) {\r\nadb_controller = driver;\r\nbreak;\r\n}\r\n}\r\nif (adb_controller != NULL && adb_controller->init &&\r\nadb_controller->init())\r\nadb_controller = NULL;\r\nif (adb_controller == NULL) {\r\nprintk(KERN_WARNING "Warning: no ADB interface detected\n");\r\n} else {\r\n#ifdef CONFIG_PPC\r\nif (of_machine_is_compatible("AAPL,PowerBook1998") ||\r\nof_machine_is_compatible("PowerBook1,1"))\r\nsleepy_trackpad = 1;\r\n#endif\r\nadbdev_init();\r\nadb_reset_bus();\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_adb_reset_bus(void)\r\n{\r\nint ret;\r\nif (adb_controller == NULL)\r\nreturn -ENXIO;\r\nif (adb_controller->autopoll)\r\nadb_controller->autopoll(0);\r\nblocking_notifier_call_chain(&adb_client_list,\r\nADB_MSG_PRE_RESET, NULL);\r\nif (sleepy_trackpad) {\r\nmsleep(500);\r\n}\r\nmutex_lock(&adb_handler_mutex);\r\nwrite_lock_irq(&adb_handler_lock);\r\nmemset(adb_handler, 0, sizeof(adb_handler));\r\nwrite_unlock_irq(&adb_handler_lock);\r\nif (adb_controller->reset_bus)\r\nret = adb_controller->reset_bus();\r\nelse\r\nret = 0;\r\nif (sleepy_trackpad) {\r\nmsleep(1500);\r\n}\r\nif (!ret) {\r\nautopoll_devs = adb_scan_bus();\r\nif (adb_controller->autopoll)\r\nadb_controller->autopoll(autopoll_devs);\r\n}\r\nmutex_unlock(&adb_handler_mutex);\r\nblocking_notifier_call_chain(&adb_client_list,\r\nADB_MSG_POST_RESET, NULL);\r\nreturn ret;\r\n}\r\nvoid\r\nadb_poll(void)\r\n{\r\nif ((adb_controller == NULL)||(adb_controller->poll == NULL))\r\nreturn;\r\nadb_controller->poll();\r\n}\r\nstatic void adb_sync_req_done(struct adb_request *req)\r\n{\r\nstruct completion *comp = req->arg;\r\ncomplete(comp);\r\n}\r\nint\r\nadb_request(struct adb_request *req, void (*done)(struct adb_request *),\r\nint flags, int nbytes, ...)\r\n{\r\nva_list list;\r\nint i;\r\nint rc;\r\nstruct completion comp;\r\nif ((adb_controller == NULL) || (adb_controller->send_request == NULL))\r\nreturn -ENXIO;\r\nif (nbytes < 1)\r\nreturn -EINVAL;\r\nreq->nbytes = nbytes+1;\r\nreq->done = done;\r\nreq->reply_expected = flags & ADBREQ_REPLY;\r\nreq->data[0] = ADB_PACKET;\r\nva_start(list, nbytes);\r\nfor (i = 0; i < nbytes; ++i)\r\nreq->data[i+1] = va_arg(list, int);\r\nva_end(list);\r\nif (flags & ADBREQ_NOSEND)\r\nreturn 0;\r\nif (flags & ADBREQ_SYNC) {\r\nWARN_ON(done);\r\nreq->done = adb_sync_req_done;\r\nreq->arg = &comp;\r\ninit_completion(&comp);\r\n}\r\nrc = adb_controller->send_request(req, 0);\r\nif ((flags & ADBREQ_SYNC) && !rc && !req->complete)\r\nwait_for_completion(&comp);\r\nreturn rc;\r\n}\r\nint\r\nadb_register(int default_id, int handler_id, struct adb_ids *ids,\r\nvoid (*handler)(unsigned char *, int, int))\r\n{\r\nint i;\r\nmutex_lock(&adb_handler_mutex);\r\nids->nids = 0;\r\nfor (i = 1; i < 16; i++) {\r\nif ((adb_handler[i].original_address == default_id) &&\r\n(!handler_id || (handler_id == adb_handler[i].handler_id) ||\r\ntry_handler_change(i, handler_id))) {\r\nif (adb_handler[i].handler != 0) {\r\nprintk(KERN_ERR\r\n"Two handlers for ADB device %d\n",\r\ndefault_id);\r\ncontinue;\r\n}\r\nwrite_lock_irq(&adb_handler_lock);\r\nadb_handler[i].handler = handler;\r\nwrite_unlock_irq(&adb_handler_lock);\r\nids->id[ids->nids++] = i;\r\n}\r\n}\r\nmutex_unlock(&adb_handler_mutex);\r\nreturn ids->nids;\r\n}\r\nint\r\nadb_unregister(int index)\r\n{\r\nint ret = -ENODEV;\r\nmutex_lock(&adb_handler_mutex);\r\nwrite_lock_irq(&adb_handler_lock);\r\nif (adb_handler[index].handler) {\r\nwhile(adb_handler[index].busy) {\r\nwrite_unlock_irq(&adb_handler_lock);\r\nyield();\r\nwrite_lock_irq(&adb_handler_lock);\r\n}\r\nret = 0;\r\nadb_handler[index].handler = NULL;\r\n}\r\nwrite_unlock_irq(&adb_handler_lock);\r\nmutex_unlock(&adb_handler_mutex);\r\nreturn ret;\r\n}\r\nvoid\r\nadb_input(unsigned char *buf, int nb, int autopoll)\r\n{\r\nint i, id;\r\nstatic int dump_adb_input = 0;\r\nunsigned long flags;\r\nvoid (*handler)(unsigned char *, int, int);\r\nif (adb_got_sleep)\r\nreturn;\r\nid = buf[0] >> 4;\r\nif (dump_adb_input) {\r\nprintk(KERN_INFO "adb packet: ");\r\nfor (i = 0; i < nb; ++i)\r\nprintk(" %x", buf[i]);\r\nprintk(", id = %d\n", id);\r\n}\r\nwrite_lock_irqsave(&adb_handler_lock, flags);\r\nhandler = adb_handler[id].handler;\r\nif (handler != NULL)\r\nadb_handler[id].busy = 1;\r\nwrite_unlock_irqrestore(&adb_handler_lock, flags);\r\nif (handler != NULL) {\r\n(*handler)(buf, nb, autopoll);\r\nwmb();\r\nadb_handler[id].busy = 0;\r\n}\r\n}\r\nstatic int try_handler_change(int address, int new_id)\r\n{\r\nstruct adb_request req;\r\nif (adb_handler[address].handler_id == new_id)\r\nreturn 1;\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(address, 3), address | 0x20, new_id);\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\nADB_READREG(address, 3));\r\nif (req.reply_len < 2)\r\nreturn 0;\r\nif (req.reply[2] != new_id)\r\nreturn 0;\r\nadb_handler[address].handler_id = req.reply[2];\r\nreturn 1;\r\n}\r\nint\r\nadb_try_handler_change(int address, int new_id)\r\n{\r\nint ret;\r\nmutex_lock(&adb_handler_mutex);\r\nret = try_handler_change(address, new_id);\r\nmutex_unlock(&adb_handler_mutex);\r\nreturn ret;\r\n}\r\nint\r\nadb_get_infos(int address, int *original_address, int *handler_id)\r\n{\r\nmutex_lock(&adb_handler_mutex);\r\n*original_address = adb_handler[address].original_address;\r\n*handler_id = adb_handler[address].handler_id;\r\nmutex_unlock(&adb_handler_mutex);\r\nreturn (*original_address != 0);\r\n}\r\nstatic void adb_write_done(struct adb_request *req)\r\n{\r\nstruct adbdev_state *state = (struct adbdev_state *) req->arg;\r\nunsigned long flags;\r\nif (!req->complete) {\r\nreq->reply_len = 0;\r\nreq->complete = 1;\r\n}\r\nspin_lock_irqsave(&state->lock, flags);\r\natomic_dec(&state->n_pending);\r\nif (!state->inuse) {\r\nkfree(req);\r\nif (atomic_read(&state->n_pending) == 0) {\r\nspin_unlock_irqrestore(&state->lock, flags);\r\nkfree(state);\r\nreturn;\r\n}\r\n} else {\r\nstruct adb_request **ap = &state->completed;\r\nwhile (*ap != NULL)\r\nap = &(*ap)->next;\r\nreq->next = NULL;\r\n*ap = req;\r\nwake_up_interruptible(&state->wait_queue);\r\n}\r\nspin_unlock_irqrestore(&state->lock, flags);\r\n}\r\nstatic int\r\ndo_adb_query(struct adb_request *req)\r\n{\r\nint ret = -EINVAL;\r\nswitch(req->data[1])\r\n{\r\ncase ADB_QUERY_GETDEVINFO:\r\nif (req->nbytes < 3)\r\nbreak;\r\nmutex_lock(&adb_handler_mutex);\r\nreq->reply[0] = adb_handler[req->data[2]].original_address;\r\nreq->reply[1] = adb_handler[req->data[2]].handler_id;\r\nmutex_unlock(&adb_handler_mutex);\r\nreq->complete = 1;\r\nreq->reply_len = 2;\r\nadb_write_done(req);\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int adb_open(struct inode *inode, struct file *file)\r\n{\r\nstruct adbdev_state *state;\r\nint ret = 0;\r\nmutex_lock(&adb_mutex);\r\nif (iminor(inode) > 0 || adb_controller == NULL) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nstate = kmalloc(sizeof(struct adbdev_state), GFP_KERNEL);\r\nif (state == 0) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfile->private_data = state;\r\nspin_lock_init(&state->lock);\r\natomic_set(&state->n_pending, 0);\r\nstate->completed = NULL;\r\ninit_waitqueue_head(&state->wait_queue);\r\nstate->inuse = 1;\r\nout:\r\nmutex_unlock(&adb_mutex);\r\nreturn ret;\r\n}\r\nstatic int adb_release(struct inode *inode, struct file *file)\r\n{\r\nstruct adbdev_state *state = file->private_data;\r\nunsigned long flags;\r\nmutex_lock(&adb_mutex);\r\nif (state) {\r\nfile->private_data = NULL;\r\nspin_lock_irqsave(&state->lock, flags);\r\nif (atomic_read(&state->n_pending) == 0\r\n&& state->completed == NULL) {\r\nspin_unlock_irqrestore(&state->lock, flags);\r\nkfree(state);\r\n} else {\r\nstate->inuse = 0;\r\nspin_unlock_irqrestore(&state->lock, flags);\r\n}\r\n}\r\nmutex_unlock(&adb_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t adb_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint ret = 0;\r\nstruct adbdev_state *state = file->private_data;\r\nstruct adb_request *req;\r\nwait_queue_t wait = __WAITQUEUE_INITIALIZER(wait,current);\r\nunsigned long flags;\r\nif (count < 2)\r\nreturn -EINVAL;\r\nif (count > sizeof(req->reply))\r\ncount = sizeof(req->reply);\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nreq = NULL;\r\nspin_lock_irqsave(&state->lock, flags);\r\nadd_wait_queue(&state->wait_queue, &wait);\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nfor (;;) {\r\nreq = state->completed;\r\nif (req != NULL)\r\nstate->completed = req->next;\r\nelse if (atomic_read(&state->n_pending) == 0)\r\nret = -EIO;\r\nif (req != NULL || ret != 0)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&state->lock, flags);\r\nschedule();\r\nspin_lock_irqsave(&state->lock, flags);\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&state->wait_queue, &wait);\r\nspin_unlock_irqrestore(&state->lock, flags);\r\nif (ret)\r\nreturn ret;\r\nret = req->reply_len;\r\nif (ret > count)\r\nret = count;\r\nif (ret > 0 && copy_to_user(buf, req->reply, ret))\r\nret = -EFAULT;\r\nkfree(req);\r\nreturn ret;\r\n}\r\nstatic ssize_t adb_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint ret;\r\nstruct adbdev_state *state = file->private_data;\r\nstruct adb_request *req;\r\nif (count < 2 || count > sizeof(req->data))\r\nreturn -EINVAL;\r\nif (adb_controller == NULL)\r\nreturn -ENXIO;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nreq = kmalloc(sizeof(struct adb_request),\r\nGFP_KERNEL);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->nbytes = count;\r\nreq->done = adb_write_done;\r\nreq->arg = (void *) state;\r\nreq->complete = 0;\r\nret = -EFAULT;\r\nif (copy_from_user(req->data, buf, count))\r\ngoto out;\r\natomic_inc(&state->n_pending);\r\ndown(&adb_probe_mutex);\r\nif (req->data[0] == ADB_QUERY) {\r\nif (count > 1)\r\nret = do_adb_query(req);\r\nelse\r\nret = -EINVAL;\r\nup(&adb_probe_mutex);\r\n}\r\nelse if ((req->data[0] == ADB_PACKET)&&(count > 1)\r\n&&(req->data[1] == ADB_BUSRESET)) {\r\nret = do_adb_reset_bus();\r\nup(&adb_probe_mutex);\r\natomic_dec(&state->n_pending);\r\nif (ret == 0)\r\nret = count;\r\ngoto out;\r\n} else {\r\nreq->reply_expected = ((req->data[1] & 0xc) == 0xc);\r\nif (adb_controller && adb_controller->send_request)\r\nret = adb_controller->send_request(req, 0);\r\nelse\r\nret = -ENXIO;\r\nup(&adb_probe_mutex);\r\n}\r\nif (ret != 0) {\r\natomic_dec(&state->n_pending);\r\ngoto out;\r\n}\r\nreturn count;\r\nout:\r\nkfree(req);\r\nreturn ret;\r\n}\r\nstatic int __init\r\nadb_dummy_probe(struct platform_device *dev)\r\n{\r\nif (dev == &adb_pfdev)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic void __init\r\nadbdev_init(void)\r\n{\r\nif (register_chrdev(ADB_MAJOR, "adb", &adb_fops)) {\r\nprintk(KERN_ERR "adb: unable to get major %d\n", ADB_MAJOR);\r\nreturn;\r\n}\r\nadb_dev_class = class_create(THIS_MODULE, "adb");\r\nif (IS_ERR(adb_dev_class))\r\nreturn;\r\ndevice_create(adb_dev_class, NULL, MKDEV(ADB_MAJOR, 0), NULL, "adb");\r\nplatform_device_register(&adb_pfdev);\r\nplatform_driver_probe(&adb_pfdrv, adb_dummy_probe);\r\n}
