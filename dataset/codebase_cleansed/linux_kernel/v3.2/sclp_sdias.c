static void sdias_callback(struct sclp_req *request, void *data)\r\n{\r\nsclp_req_done = 1;\r\nwake_up(&sdias_wq);\r\nTRACE("callback done\n");\r\n}\r\nstatic int sdias_sclp_send(struct sclp_req *req)\r\n{\r\nint retries;\r\nint rc;\r\nfor (retries = SDIAS_RETRIES; retries; retries--) {\r\nsclp_req_done = 0;\r\nTRACE("add request\n");\r\nrc = sclp_add_request(req);\r\nif (rc) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nTRACE("add request failed: rc = %i\n",rc);\r\nschedule_timeout(SDIAS_SLEEP_TICKS);\r\ncontinue;\r\n}\r\nwait_event(sdias_wq, (sclp_req_done == 1));\r\nif (req->status == SCLP_REQ_FAILED) {\r\nTRACE("sclp request failed\n");\r\nrc = -EIO;\r\ncontinue;\r\n}\r\nTRACE("request done\n");\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint sclp_sdias_blk_count(void)\r\n{\r\nstruct sclp_req request;\r\nint rc;\r\nmutex_lock(&sdias_mutex);\r\nmemset(&sccb, 0, sizeof(sccb));\r\nmemset(&request, 0, sizeof(request));\r\nsccb.hdr.length = sizeof(sccb);\r\nsccb.evbuf.hdr.length = sizeof(struct sdias_evbuf);\r\nsccb.evbuf.hdr.type = EVTYP_SDIAS;\r\nsccb.evbuf.event_qual = EQ_SIZE;\r\nsccb.evbuf.data_id = DI_FCP_DUMP;\r\nsccb.evbuf.event_id = 4712;\r\nsccb.evbuf.dbs = 1;\r\nrequest.sccb = &sccb;\r\nrequest.command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nrequest.status = SCLP_REQ_FILLED;\r\nrequest.callback = sdias_callback;\r\nrc = sdias_sclp_send(&request);\r\nif (rc) {\r\npr_err("sclp_send failed for get_nr_blocks\n");\r\ngoto out;\r\n}\r\nif (sccb.hdr.response_code != 0x0020) {\r\nTRACE("send failed: %x\n", sccb.hdr.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nswitch (sccb.evbuf.event_status) {\r\ncase 0:\r\nrc = sccb.evbuf.blk_cnt;\r\nbreak;\r\ndefault:\r\npr_err("SCLP error: %x\n",\r\nsccb.evbuf.event_status);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nTRACE("%i blocks\n", rc);\r\nout:\r\nmutex_unlock(&sdias_mutex);\r\nreturn rc;\r\n}\r\nint sclp_sdias_copy(void *dest, int start_blk, int nr_blks)\r\n{\r\nstruct sclp_req request;\r\nint rc;\r\nmutex_lock(&sdias_mutex);\r\nmemset(&sccb, 0, sizeof(sccb));\r\nmemset(&request, 0, sizeof(request));\r\nsccb.hdr.length = sizeof(sccb);\r\nsccb.evbuf.hdr.length = sizeof(struct sdias_evbuf);\r\nsccb.evbuf.hdr.type = EVTYP_SDIAS;\r\nsccb.evbuf.hdr.flags = 0;\r\nsccb.evbuf.event_qual = EQ_STORE_DATA;\r\nsccb.evbuf.data_id = DI_FCP_DUMP;\r\nsccb.evbuf.event_id = 4712;\r\n#ifdef __s390x__\r\nsccb.evbuf.asa_size = ASA_SIZE_64;\r\n#else\r\nsccb.evbuf.asa_size = ASA_SIZE_32;\r\n#endif\r\nsccb.evbuf.event_status = 0;\r\nsccb.evbuf.blk_cnt = nr_blks;\r\nsccb.evbuf.asa = (unsigned long)dest;\r\nsccb.evbuf.fbn = start_blk;\r\nsccb.evbuf.lbn = 0;\r\nsccb.evbuf.dbs = 1;\r\nrequest.sccb = &sccb;\r\nrequest.command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nrequest.status = SCLP_REQ_FILLED;\r\nrequest.callback = sdias_callback;\r\nrc = sdias_sclp_send(&request);\r\nif (rc) {\r\npr_err("sclp_send failed: %x\n", rc);\r\ngoto out;\r\n}\r\nif (sccb.hdr.response_code != 0x0020) {\r\nTRACE("copy failed: %x\n", sccb.hdr.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nswitch (sccb.evbuf.event_status) {\r\ncase EVSTATE_ALL_STORED:\r\nTRACE("all stored\n");\r\ncase EVSTATE_PART_STORED:\r\nTRACE("part stored: %i\n", sccb.evbuf.blk_cnt);\r\nbreak;\r\ncase EVSTATE_NO_DATA:\r\nTRACE("no data\n");\r\ndefault:\r\npr_err("Error from SCLP while copying hsa. "\r\n"Event status = %x\n",\r\nsccb.evbuf.event_status);\r\nrc = -EIO;\r\n}\r\nout:\r\nmutex_unlock(&sdias_mutex);\r\nreturn rc;\r\n}\r\nint __init sclp_sdias_init(void)\r\n{\r\nint rc;\r\nif (ipl_info.type != IPL_TYPE_FCP_DUMP)\r\nreturn 0;\r\nsdias_dbf = debug_register("dump_sdias", 4, 1, 4 * sizeof(long));\r\ndebug_register_view(sdias_dbf, &debug_sprintf_view);\r\ndebug_set_level(sdias_dbf, 6);\r\nrc = sclp_register(&sclp_sdias_register);\r\nif (rc)\r\nreturn rc;\r\ninit_waitqueue_head(&sdias_wq);\r\nTRACE("init done\n");\r\nreturn 0;\r\n}\r\nvoid __exit sclp_sdias_exit(void)\r\n{\r\ndebug_unregister(sdias_dbf);\r\nsclp_unregister(&sclp_sdias_register);\r\n}
