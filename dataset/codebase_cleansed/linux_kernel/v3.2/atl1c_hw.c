int atl1c_check_eeprom_exist(struct atl1c_hw *hw)\r\n{\r\nu32 data;\r\nAT_READ_REG(hw, REG_TWSI_DEBUG, &data);\r\nif (data & TWSI_DEBUG_DEV_EXIST)\r\nreturn 1;\r\nAT_READ_REG(hw, REG_MASTER_CTRL, &data);\r\nif (data & MASTER_CTRL_OTP_SEL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid atl1c_hw_set_mac_addr(struct atl1c_hw *hw)\r\n{\r\nu32 value;\r\nvalue = (((u32)hw->mac_addr[2]) << 24) |\r\n(((u32)hw->mac_addr[3]) << 16) |\r\n(((u32)hw->mac_addr[4]) << 8) |\r\n(((u32)hw->mac_addr[5])) ;\r\nAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 0, value);\r\nvalue = (((u32)hw->mac_addr[0]) << 8) |\r\n(((u32)hw->mac_addr[1])) ;\r\nAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 1, value);\r\n}\r\nstatic int atl1c_get_permanent_address(struct atl1c_hw *hw)\r\n{\r\nu32 addr[2];\r\nu32 i;\r\nu32 otp_ctrl_data;\r\nu32 twsi_ctrl_data;\r\nu32 ltssm_ctrl_data;\r\nu32 wol_data;\r\nu8 eth_addr[ETH_ALEN];\r\nu16 phy_data;\r\nbool raise_vol = false;\r\naddr[0] = addr[1] = 0;\r\nAT_READ_REG(hw, REG_OTP_CTRL, &otp_ctrl_data);\r\nif (atl1c_check_eeprom_exist(hw)) {\r\nif (hw->nic_type == athr_l1c || hw->nic_type == athr_l2c) {\r\nif (!(otp_ctrl_data & OTP_CTRL_CLK_EN)) {\r\notp_ctrl_data |= OTP_CTRL_CLK_EN;\r\nAT_WRITE_REG(hw, REG_OTP_CTRL, otp_ctrl_data);\r\nAT_WRITE_FLUSH(hw);\r\nmsleep(1);\r\n}\r\n}\r\nif (hw->nic_type == athr_l2c_b ||\r\nhw->nic_type == athr_l2c_b2 ||\r\nhw->nic_type == athr_l1d) {\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x00);\r\nif (atl1c_read_phy_reg(hw, MII_DBG_DATA, &phy_data))\r\ngoto out;\r\nphy_data &= 0xFF7F;\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, phy_data);\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x3B);\r\nif (atl1c_read_phy_reg(hw, MII_DBG_DATA, &phy_data))\r\ngoto out;\r\nphy_data |= 0x8;\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, phy_data);\r\nudelay(20);\r\nraise_vol = true;\r\n}\r\nAT_READ_REG(hw, REG_LTSSM_ID_CTRL, &ltssm_ctrl_data);\r\nltssm_ctrl_data &= ~LTSSM_ID_EN_WRO;\r\nAT_WRITE_REG(hw, REG_LTSSM_ID_CTRL, ltssm_ctrl_data);\r\nAT_WRITE_REG(hw, REG_WOL_CTRL, 0);\r\nAT_READ_REG(hw, REG_WOL_CTRL, &wol_data);\r\nAT_READ_REG(hw, REG_TWSI_CTRL, &twsi_ctrl_data);\r\ntwsi_ctrl_data |= TWSI_CTRL_SW_LDSTART;\r\nAT_WRITE_REG(hw, REG_TWSI_CTRL, twsi_ctrl_data);\r\nfor (i = 0; i < AT_TWSI_EEPROM_TIMEOUT; i++) {\r\nmsleep(10);\r\nAT_READ_REG(hw, REG_TWSI_CTRL, &twsi_ctrl_data);\r\nif ((twsi_ctrl_data & TWSI_CTRL_SW_LDSTART) == 0)\r\nbreak;\r\n}\r\nif (i >= AT_TWSI_EEPROM_TIMEOUT)\r\nreturn -1;\r\n}\r\nif ((hw->nic_type == athr_l1c || hw->nic_type == athr_l2c)) {\r\notp_ctrl_data &= ~OTP_CTRL_CLK_EN;\r\nAT_WRITE_REG(hw, REG_OTP_CTRL, otp_ctrl_data);\r\nmsleep(1);\r\n}\r\nif (raise_vol) {\r\nif (hw->nic_type == athr_l2c_b ||\r\nhw->nic_type == athr_l2c_b2 ||\r\nhw->nic_type == athr_l1d ||\r\nhw->nic_type == athr_l1d_2) {\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x00);\r\nif (atl1c_read_phy_reg(hw, MII_DBG_DATA, &phy_data))\r\ngoto out;\r\nphy_data |= 0x80;\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, phy_data);\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x3B);\r\nif (atl1c_read_phy_reg(hw, MII_DBG_DATA, &phy_data))\r\ngoto out;\r\nphy_data &= 0xFFF7;\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, phy_data);\r\nudelay(20);\r\n}\r\n}\r\nAT_READ_REG(hw, REG_MAC_STA_ADDR, &addr[0]);\r\nAT_READ_REG(hw, REG_MAC_STA_ADDR + 4, &addr[1]);\r\n*(u32 *) &eth_addr[2] = swab32(addr[0]);\r\n*(u16 *) &eth_addr[0] = swab16(*(u16 *)&addr[1]);\r\nif (is_valid_ether_addr(eth_addr)) {\r\nmemcpy(hw->perm_mac_addr, eth_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nout:\r\nreturn -1;\r\n}\r\nbool atl1c_read_eeprom(struct atl1c_hw *hw, u32 offset, u32 *p_value)\r\n{\r\nint i;\r\nint ret = false;\r\nu32 otp_ctrl_data;\r\nu32 control;\r\nu32 data;\r\nif (offset & 3)\r\nreturn ret;\r\nAT_READ_REG(hw, REG_OTP_CTRL, &otp_ctrl_data);\r\nif (!(otp_ctrl_data & OTP_CTRL_CLK_EN))\r\nAT_WRITE_REG(hw, REG_OTP_CTRL,\r\n(otp_ctrl_data | OTP_CTRL_CLK_EN));\r\nAT_WRITE_REG(hw, REG_EEPROM_DATA_LO, 0);\r\ncontrol = (offset & EEPROM_CTRL_ADDR_MASK) << EEPROM_CTRL_ADDR_SHIFT;\r\nAT_WRITE_REG(hw, REG_EEPROM_CTRL, control);\r\nfor (i = 0; i < 10; i++) {\r\nudelay(100);\r\nAT_READ_REG(hw, REG_EEPROM_CTRL, &control);\r\nif (control & EEPROM_CTRL_RW)\r\nbreak;\r\n}\r\nif (control & EEPROM_CTRL_RW) {\r\nAT_READ_REG(hw, REG_EEPROM_CTRL, &data);\r\nAT_READ_REG(hw, REG_EEPROM_DATA_LO, p_value);\r\ndata = data & 0xFFFF;\r\n*p_value = swab32((data << 16) | (*p_value >> 16));\r\nret = true;\r\n}\r\nif (!(otp_ctrl_data & OTP_CTRL_CLK_EN))\r\nAT_WRITE_REG(hw, REG_OTP_CTRL, otp_ctrl_data);\r\nreturn ret;\r\n}\r\nint atl1c_read_mac_addr(struct atl1c_hw *hw)\r\n{\r\nint err = 0;\r\nerr = atl1c_get_permanent_address(hw);\r\nif (err)\r\nrandom_ether_addr(hw->perm_mac_addr);\r\nmemcpy(hw->mac_addr, hw->perm_mac_addr, sizeof(hw->perm_mac_addr));\r\nreturn 0;\r\n}\r\nu32 atl1c_hash_mc_addr(struct atl1c_hw *hw, u8 *mc_addr)\r\n{\r\nu32 crc32;\r\nu32 value = 0;\r\nint i;\r\ncrc32 = ether_crc_le(6, mc_addr);\r\nfor (i = 0; i < 32; i++)\r\nvalue |= (((crc32 >> i) & 1) << (31 - i));\r\nreturn value;\r\n}\r\nvoid atl1c_hash_set(struct atl1c_hw *hw, u32 hash_value)\r\n{\r\nu32 hash_bit, hash_reg;\r\nu32 mta;\r\nhash_reg = (hash_value >> 31) & 0x1;\r\nhash_bit = (hash_value >> 26) & 0x1F;\r\nmta = AT_READ_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg);\r\nmta |= (1 << hash_bit);\r\nAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg, mta);\r\n}\r\nint atl1c_read_phy_reg(struct atl1c_hw *hw, u16 reg_addr, u16 *phy_data)\r\n{\r\nu32 val;\r\nint i;\r\nval = ((u32)(reg_addr & MDIO_REG_ADDR_MASK)) << MDIO_REG_ADDR_SHIFT |\r\nMDIO_START | MDIO_SUP_PREAMBLE | MDIO_RW |\r\nMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\r\nAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\r\nfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\r\nudelay(2);\r\nAT_READ_REG(hw, REG_MDIO_CTRL, &val);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\n}\r\nif (!(val & (MDIO_START | MDIO_BUSY))) {\r\n*phy_data = (u16)val;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nint atl1c_write_phy_reg(struct atl1c_hw *hw, u32 reg_addr, u16 phy_data)\r\n{\r\nint i;\r\nu32 val;\r\nval = ((u32)(phy_data & MDIO_DATA_MASK)) << MDIO_DATA_SHIFT |\r\n(reg_addr & MDIO_REG_ADDR_MASK) << MDIO_REG_ADDR_SHIFT |\r\nMDIO_SUP_PREAMBLE | MDIO_START |\r\nMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\r\nAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\r\nfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\r\nudelay(2);\r\nAT_READ_REG(hw, REG_MDIO_CTRL, &val);\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nbreak;\r\n}\r\nif (!(val & (MDIO_START | MDIO_BUSY)))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic int atl1c_phy_setup_adv(struct atl1c_hw *hw)\r\n{\r\nu16 mii_adv_data = ADVERTISE_DEFAULT_CAP & ~ADVERTISE_ALL;\r\nu16 mii_giga_ctrl_data = GIGA_CR_1000T_DEFAULT_CAP &\r\n~GIGA_CR_1000T_SPEED_MASK;\r\nif (hw->autoneg_advertised & ADVERTISED_10baseT_Half)\r\nmii_adv_data |= ADVERTISE_10HALF;\r\nif (hw->autoneg_advertised & ADVERTISED_10baseT_Full)\r\nmii_adv_data |= ADVERTISE_10FULL;\r\nif (hw->autoneg_advertised & ADVERTISED_100baseT_Half)\r\nmii_adv_data |= ADVERTISE_100HALF;\r\nif (hw->autoneg_advertised & ADVERTISED_100baseT_Full)\r\nmii_adv_data |= ADVERTISE_100FULL;\r\nif (hw->autoneg_advertised & ADVERTISED_Autoneg)\r\nmii_adv_data |= ADVERTISE_10HALF | ADVERTISE_10FULL |\r\nADVERTISE_100HALF | ADVERTISE_100FULL;\r\nif (hw->link_cap_flags & ATL1C_LINK_CAP_1000M) {\r\nif (hw->autoneg_advertised & ADVERTISED_1000baseT_Half)\r\nmii_giga_ctrl_data |= ADVERTISE_1000HALF;\r\nif (hw->autoneg_advertised & ADVERTISED_1000baseT_Full)\r\nmii_giga_ctrl_data |= ADVERTISE_1000FULL;\r\nif (hw->autoneg_advertised & ADVERTISED_Autoneg)\r\nmii_giga_ctrl_data |= ADVERTISE_1000HALF |\r\nADVERTISE_1000FULL;\r\n}\r\nif (atl1c_write_phy_reg(hw, MII_ADVERTISE, mii_adv_data) != 0 ||\r\natl1c_write_phy_reg(hw, MII_CTRL1000, mii_giga_ctrl_data) != 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid atl1c_phy_disable(struct atl1c_hw *hw)\r\n{\r\nAT_WRITE_REGW(hw, REG_GPHY_CTRL,\r\nGPHY_CTRL_PW_WOL_DIS | GPHY_CTRL_EXT_RESET);\r\n}\r\nstatic void atl1c_phy_magic_data(struct atl1c_hw *hw)\r\n{\r\nu16 data;\r\ndata = ANA_LOOP_SEL_10BT | ANA_EN_MASK_TB | ANA_EN_10BT_IDLE |\r\n((1 & ANA_INTERVAL_SEL_TIMER_MASK) <<\r\nANA_INTERVAL_SEL_TIMER_SHIFT);\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, MII_ANA_CTRL_18);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, data);\r\ndata = (2 & ANA_SERDES_CDR_BW_MASK) | ANA_MS_PAD_DBG |\r\nANA_SERDES_EN_DEEM | ANA_SERDES_SEL_HSP | ANA_SERDES_EN_PLL |\r\nANA_SERDES_EN_LCKDT;\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, MII_ANA_CTRL_5);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, data);\r\ndata = (44 & ANA_LONG_CABLE_TH_100_MASK) |\r\n((33 & ANA_SHORT_CABLE_TH_100_MASK) <<\r\nANA_SHORT_CABLE_TH_100_SHIFT) | ANA_BP_BAD_LINK_ACCUM |\r\nANA_BP_SMALL_BW;\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, MII_ANA_CTRL_54);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, data);\r\ndata = (11 & ANA_IECHO_ADJ_MASK) | ((11 & ANA_IECHO_ADJ_MASK) <<\r\nANA_IECHO_ADJ_2_SHIFT) | ((8 & ANA_IECHO_ADJ_MASK) <<\r\nANA_IECHO_ADJ_1_SHIFT) | ((8 & ANA_IECHO_ADJ_MASK) <<\r\nANA_IECHO_ADJ_0_SHIFT);\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, MII_ANA_CTRL_4);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, data);\r\ndata = ANA_RESTART_CAL | ((7 & ANA_MANUL_SWICH_ON_MASK) <<\r\nANA_MANUL_SWICH_ON_SHIFT) | ANA_MAN_ENABLE |\r\nANA_SEL_HSP | ANA_EN_HB | ANA_OEN_125M;\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, MII_ANA_CTRL_0);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, data);\r\nif (hw->ctrl_flags & ATL1C_HIB_DISABLE) {\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, MII_ANA_CTRL_41);\r\nif (atl1c_read_phy_reg(hw, MII_DBG_DATA, &data) != 0)\r\nreturn;\r\ndata &= ~ANA_TOP_PS_EN;\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, data);\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, MII_ANA_CTRL_11);\r\nif (atl1c_read_phy_reg(hw, MII_DBG_DATA, &data) != 0)\r\nreturn;\r\ndata &= ~ANA_PS_HIB_EN;\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, data);\r\n}\r\n}\r\nint atl1c_phy_reset(struct atl1c_hw *hw)\r\n{\r\nstruct atl1c_adapter *adapter = hw->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nu16 phy_data;\r\nu32 phy_ctrl_data = GPHY_CTRL_DEFAULT;\r\nu32 mii_ier_data = IER_LINK_UP | IER_LINK_DOWN;\r\nint err;\r\nif (hw->ctrl_flags & ATL1C_HIB_DISABLE)\r\nphy_ctrl_data &= ~GPHY_CTRL_HIB_EN;\r\nAT_WRITE_REG(hw, REG_GPHY_CTRL, phy_ctrl_data);\r\nAT_WRITE_FLUSH(hw);\r\nmsleep(40);\r\nphy_ctrl_data |= GPHY_CTRL_EXT_RESET;\r\nAT_WRITE_REG(hw, REG_GPHY_CTRL, phy_ctrl_data);\r\nAT_WRITE_FLUSH(hw);\r\nmsleep(10);\r\nif (hw->nic_type == athr_l2c_b) {\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x0A);\r\natl1c_read_phy_reg(hw, MII_DBG_DATA, &phy_data);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, phy_data & 0xDFFF);\r\n}\r\nif (hw->nic_type == athr_l2c_b ||\r\nhw->nic_type == athr_l2c_b2 ||\r\nhw->nic_type == athr_l1d ||\r\nhw->nic_type == athr_l1d_2) {\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x3B);\r\natl1c_read_phy_reg(hw, MII_DBG_DATA, &phy_data);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, phy_data & 0xFFF7);\r\nmsleep(20);\r\n}\r\nif (hw->nic_type == athr_l1d) {\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x29);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, 0x929D);\r\n}\r\nif (hw->nic_type == athr_l1c || hw->nic_type == athr_l2c_b2\r\n|| hw->nic_type == athr_l2c) {\r\natl1c_write_phy_reg(hw, MII_DBG_ADDR, 0x29);\r\natl1c_write_phy_reg(hw, MII_DBG_DATA, 0xB6DD);\r\n}\r\nerr = atl1c_write_phy_reg(hw, MII_IER, mii_ier_data);\r\nif (err) {\r\nif (netif_msg_hw(adapter))\r\ndev_err(&pdev->dev,\r\n"Error enable PHY linkChange Interrupt\n");\r\nreturn err;\r\n}\r\nif (!(hw->ctrl_flags & ATL1C_FPGA_VERSION))\r\natl1c_phy_magic_data(hw);\r\nreturn 0;\r\n}\r\nint atl1c_phy_init(struct atl1c_hw *hw)\r\n{\r\nstruct atl1c_adapter *adapter = (struct atl1c_adapter *)hw->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint ret_val;\r\nu16 mii_bmcr_data = BMCR_RESET;\r\nif ((atl1c_read_phy_reg(hw, MII_PHYSID1, &hw->phy_id1) != 0) ||\r\n(atl1c_read_phy_reg(hw, MII_PHYSID2, &hw->phy_id2) != 0)) {\r\ndev_err(&pdev->dev, "Error get phy ID\n");\r\nreturn -1;\r\n}\r\nswitch (hw->media_type) {\r\ncase MEDIA_TYPE_AUTO_SENSOR:\r\nret_val = atl1c_phy_setup_adv(hw);\r\nif (ret_val) {\r\nif (netif_msg_link(adapter))\r\ndev_err(&pdev->dev,\r\n"Error Setting up Auto-Negotiation\n");\r\nreturn ret_val;\r\n}\r\nmii_bmcr_data |= BMCR_ANENABLE | BMCR_ANRESTART;\r\nbreak;\r\ncase MEDIA_TYPE_100M_FULL:\r\nmii_bmcr_data |= BMCR_SPEED100 | BMCR_FULLDPLX;\r\nbreak;\r\ncase MEDIA_TYPE_100M_HALF:\r\nmii_bmcr_data |= BMCR_SPEED100;\r\nbreak;\r\ncase MEDIA_TYPE_10M_FULL:\r\nmii_bmcr_data |= BMCR_FULLDPLX;\r\nbreak;\r\ncase MEDIA_TYPE_10M_HALF:\r\nbreak;\r\ndefault:\r\nif (netif_msg_link(adapter))\r\ndev_err(&pdev->dev, "Wrong Media type %d\n",\r\nhw->media_type);\r\nreturn -1;\r\nbreak;\r\n}\r\nret_val = atl1c_write_phy_reg(hw, MII_BMCR, mii_bmcr_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->phy_configured = true;\r\nreturn 0;\r\n}\r\nint atl1c_get_speed_and_duplex(struct atl1c_hw *hw, u16 *speed, u16 *duplex)\r\n{\r\nint err;\r\nu16 phy_data;\r\nerr = atl1c_read_phy_reg(hw, MII_GIGA_PSSR, &phy_data);\r\nif (err)\r\nreturn err;\r\nif (!(phy_data & GIGA_PSSR_SPD_DPLX_RESOLVED))\r\nreturn -1;\r\nswitch (phy_data & GIGA_PSSR_SPEED) {\r\ncase GIGA_PSSR_1000MBS:\r\n*speed = SPEED_1000;\r\nbreak;\r\ncase GIGA_PSSR_100MBS:\r\n*speed = SPEED_100;\r\nbreak;\r\ncase GIGA_PSSR_10MBS:\r\n*speed = SPEED_10;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nif (phy_data & GIGA_PSSR_DPLX)\r\n*duplex = FULL_DUPLEX;\r\nelse\r\n*duplex = HALF_DUPLEX;\r\nreturn 0;\r\n}\r\nint atl1c_phy_power_saving(struct atl1c_hw *hw)\r\n{\r\nstruct atl1c_adapter *adapter = (struct atl1c_adapter *)hw->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint ret = 0;\r\nu16 autoneg_advertised = ADVERTISED_10baseT_Half;\r\nu16 save_autoneg_advertised;\r\nu16 phy_data;\r\nu16 mii_lpa_data;\r\nu16 speed = SPEED_0;\r\nu16 duplex = FULL_DUPLEX;\r\nint i;\r\natl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\r\natl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\r\nif (phy_data & BMSR_LSTATUS) {\r\natl1c_read_phy_reg(hw, MII_LPA, &mii_lpa_data);\r\nif (mii_lpa_data & LPA_10FULL)\r\nautoneg_advertised = ADVERTISED_10baseT_Full;\r\nelse if (mii_lpa_data & LPA_10HALF)\r\nautoneg_advertised = ADVERTISED_10baseT_Half;\r\nelse if (mii_lpa_data & LPA_100HALF)\r\nautoneg_advertised = ADVERTISED_100baseT_Half;\r\nelse if (mii_lpa_data & LPA_100FULL)\r\nautoneg_advertised = ADVERTISED_100baseT_Full;\r\nsave_autoneg_advertised = hw->autoneg_advertised;\r\nhw->phy_configured = false;\r\nhw->autoneg_advertised = autoneg_advertised;\r\nif (atl1c_restart_autoneg(hw) != 0) {\r\ndev_dbg(&pdev->dev, "phy autoneg failed\n");\r\nret = -1;\r\n}\r\nhw->autoneg_advertised = save_autoneg_advertised;\r\nif (mii_lpa_data) {\r\nfor (i = 0; i < AT_SUSPEND_LINK_TIMEOUT; i++) {\r\nmdelay(100);\r\natl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\r\natl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\r\nif (phy_data & BMSR_LSTATUS) {\r\nif (atl1c_get_speed_and_duplex(hw, &speed,\r\n&duplex) != 0)\r\ndev_dbg(&pdev->dev,\r\n"get speed and duplex failed\n");\r\nbreak;\r\n}\r\n}\r\n}\r\n} else {\r\nspeed = SPEED_10;\r\nduplex = HALF_DUPLEX;\r\n}\r\nadapter->link_speed = speed;\r\nadapter->link_duplex = duplex;\r\nreturn ret;\r\n}\r\nint atl1c_restart_autoneg(struct atl1c_hw *hw)\r\n{\r\nint err = 0;\r\nu16 mii_bmcr_data = BMCR_RESET;\r\nerr = atl1c_phy_setup_adv(hw);\r\nif (err)\r\nreturn err;\r\nmii_bmcr_data |= BMCR_ANENABLE | BMCR_ANRESTART;\r\nreturn atl1c_write_phy_reg(hw, MII_BMCR, mii_bmcr_data);\r\n}
