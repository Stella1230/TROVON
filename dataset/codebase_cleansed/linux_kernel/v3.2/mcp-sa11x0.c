static void\r\nmcp_sa11x0_set_telecom_divisor(struct mcp *mcp, unsigned int divisor)\r\n{\r\nunsigned int mccr0;\r\ndivisor /= 32;\r\nmccr0 = Ser4MCCR0 & ~0x00007f00;\r\nmccr0 |= divisor << 8;\r\nSer4MCCR0 = mccr0;\r\n}\r\nstatic void\r\nmcp_sa11x0_set_audio_divisor(struct mcp *mcp, unsigned int divisor)\r\n{\r\nunsigned int mccr0;\r\ndivisor /= 32;\r\nmccr0 = Ser4MCCR0 & ~0x0000007f;\r\nmccr0 |= divisor;\r\nSer4MCCR0 = mccr0;\r\n}\r\nstatic void\r\nmcp_sa11x0_write(struct mcp *mcp, unsigned int reg, unsigned int val)\r\n{\r\nint ret = -ETIME;\r\nint i;\r\nSer4MCDR2 = reg << 17 | MCDR2_Wr | (val & 0xffff);\r\nfor (i = 0; i < 2; i++) {\r\nudelay(mcp->rw_timeout);\r\nif (Ser4MCSR & MCSR_CWC) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret < 0)\r\nprintk(KERN_WARNING "mcp: write timed out\n");\r\n}\r\nstatic unsigned int\r\nmcp_sa11x0_read(struct mcp *mcp, unsigned int reg)\r\n{\r\nint ret = -ETIME;\r\nint i;\r\nSer4MCDR2 = reg << 17 | MCDR2_Rd;\r\nfor (i = 0; i < 2; i++) {\r\nudelay(mcp->rw_timeout);\r\nif (Ser4MCSR & MCSR_CRC) {\r\nret = Ser4MCDR2 & 0xffff;\r\nbreak;\r\n}\r\n}\r\nif (ret < 0)\r\nprintk(KERN_WARNING "mcp: read timed out\n");\r\nreturn ret;\r\n}\r\nstatic void mcp_sa11x0_enable(struct mcp *mcp)\r\n{\r\nSer4MCSR = -1;\r\nSer4MCCR0 |= MCCR0_MCE;\r\n}\r\nstatic void mcp_sa11x0_disable(struct mcp *mcp)\r\n{\r\nSer4MCCR0 &= ~MCCR0_MCE;\r\n}\r\nstatic int mcp_sa11x0_probe(struct platform_device *pdev)\r\n{\r\nstruct mcp_plat_data *data = pdev->dev.platform_data;\r\nstruct mcp *mcp;\r\nint ret;\r\nif (!data)\r\nreturn -ENODEV;\r\nif (!request_mem_region(0x80060000, 0x60, "sa11x0-mcp"))\r\nreturn -EBUSY;\r\nmcp = mcp_host_alloc(&pdev->dev, sizeof(struct mcp_sa11x0));\r\nif (!mcp) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nmcp->owner = THIS_MODULE;\r\nmcp->ops = &mcp_sa11x0;\r\nmcp->sclk_rate = data->sclk_rate;\r\nmcp->dma_audio_rd = DMA_Ser4MCP0Rd;\r\nmcp->dma_audio_wr = DMA_Ser4MCP0Wr;\r\nmcp->dma_telco_rd = DMA_Ser4MCP1Rd;\r\nmcp->dma_telco_wr = DMA_Ser4MCP1Wr;\r\nmcp->gpio_base = data->gpio_base;\r\nplatform_set_drvdata(pdev, mcp);\r\nif (machine_is_assabet()) {\r\nASSABET_BCR_set(ASSABET_BCR_CODEC_RST);\r\n}\r\nPPDR &= ~PPC_RXD4;\r\nPPDR |= PPC_TXD4 | PPC_SCLK | PPC_SFRM;\r\nPSDR |= PPC_RXD4;\r\nPSDR &= ~(PPC_TXD4 | PPC_SCLK | PPC_SFRM);\r\nPPSR &= ~(PPC_TXD4 | PPC_SCLK | PPC_SFRM);\r\nSer4MCSR = -1;\r\nSer4MCCR1 = data->mccr1;\r\nSer4MCCR0 = data->mccr0 | 0x7f7f;\r\nmcp->rw_timeout = (64 * 3 * 1000000 + mcp->sclk_rate - 1) /\r\nmcp->sclk_rate;\r\nret = mcp_host_register(mcp);\r\nif (ret == 0)\r\ngoto out;\r\nrelease:\r\nrelease_mem_region(0x80060000, 0x60);\r\nplatform_set_drvdata(pdev, NULL);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int mcp_sa11x0_remove(struct platform_device *dev)\r\n{\r\nstruct mcp *mcp = platform_get_drvdata(dev);\r\nplatform_set_drvdata(dev, NULL);\r\nmcp_host_unregister(mcp);\r\nrelease_mem_region(0x80060000, 0x60);\r\nreturn 0;\r\n}\r\nstatic int mcp_sa11x0_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct mcp *mcp = platform_get_drvdata(dev);\r\npriv(mcp)->mccr0 = Ser4MCCR0;\r\npriv(mcp)->mccr1 = Ser4MCCR1;\r\nSer4MCCR0 &= ~MCCR0_MCE;\r\nreturn 0;\r\n}\r\nstatic int mcp_sa11x0_resume(struct platform_device *dev)\r\n{\r\nstruct mcp *mcp = platform_get_drvdata(dev);\r\nSer4MCCR1 = priv(mcp)->mccr1;\r\nSer4MCCR0 = priv(mcp)->mccr0;\r\nreturn 0;\r\n}\r\nstatic int __init mcp_sa11x0_init(void)\r\n{\r\nreturn platform_driver_register(&mcp_sa11x0_driver);\r\n}\r\nstatic void __exit mcp_sa11x0_exit(void)\r\n{\r\nplatform_driver_unregister(&mcp_sa11x0_driver);\r\n}
