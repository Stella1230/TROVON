static void pti_write_to_aperture(struct pti_masterchannel *mc,\r\nu8 *buf,\r\nint len)\r\n{\r\nint dwordcnt;\r\nint final;\r\nint i;\r\nu32 ptiword;\r\nu32 __iomem *aperture;\r\nu8 *p = buf;\r\naperture = drv_data->pti_ioaddr + (mc->master << 15)\r\n+ (mc->channel << 8);\r\ndwordcnt = len >> 2;\r\nfinal = len - (dwordcnt << 2);\r\nif (final == 0 && dwordcnt != 0) {\r\nfinal += 4;\r\ndwordcnt--;\r\n}\r\nfor (i = 0; i < dwordcnt; i++) {\r\nptiword = be32_to_cpu(*(u32 *)p);\r\np += 4;\r\niowrite32(ptiword, aperture);\r\n}\r\naperture += PTI_LASTDWORD_DTS;\r\nptiword = 0;\r\nfor (i = 0; i < final; i++)\r\nptiword |= *p++ << (24-(8*i));\r\niowrite32(ptiword, aperture);\r\nreturn;\r\n}\r\nstatic void pti_control_frame_built_and_sent(struct pti_masterchannel *mc,\r\nconst char *thread_name)\r\n{\r\nchar comm[TASK_COMM_LEN];\r\nstruct pti_masterchannel mccontrol = {.master = CONTROL_ID,\r\n.channel = 0};\r\nconst char *thread_name_p;\r\nconst char *control_format = "%3d %3d %s";\r\nu8 control_frame[CONTROL_FRAME_LEN];\r\nif (!thread_name) {\r\nif (!in_interrupt())\r\nget_task_comm(comm, current);\r\nelse\r\nstrncpy(comm, "Interrupt", TASK_COMM_LEN);\r\ncomm[TASK_COMM_LEN-1] = 0;\r\nthread_name_p = comm;\r\n} else {\r\nthread_name_p = thread_name;\r\n}\r\nmccontrol.channel = pti_control_channel;\r\npti_control_channel = (pti_control_channel + 1) & 0x7f;\r\nsnprintf(control_frame, CONTROL_FRAME_LEN, control_format, mc->master,\r\nmc->channel, thread_name_p);\r\npti_write_to_aperture(&mccontrol, control_frame, strlen(control_frame));\r\n}\r\nstatic void pti_write_full_frame_to_aperture(struct pti_masterchannel *mc,\r\nconst unsigned char *buf,\r\nint len)\r\n{\r\npti_control_frame_built_and_sent(mc, NULL);\r\npti_write_to_aperture(mc, (u8 *)buf, len);\r\n}\r\nstatic struct pti_masterchannel *get_id(u8 *id_array,\r\nint max_ids,\r\nint base_id,\r\nconst char *thread_name)\r\n{\r\nstruct pti_masterchannel *mc;\r\nint i, j, mask;\r\nmc = kmalloc(sizeof(struct pti_masterchannel), GFP_KERNEL);\r\nif (mc == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < max_ids; i++)\r\nif (id_array[i] != 0xff)\r\nbreak;\r\nif (i == max_ids) {\r\nkfree(mc);\r\nreturn NULL;\r\n}\r\nmask = 0x80;\r\nfor (j = 0; j < 8; j++) {\r\nif ((id_array[i] & mask) == 0)\r\nbreak;\r\nmask >>= 1;\r\n}\r\nid_array[i] |= mask;\r\nmc->master = base_id;\r\nmc->channel = ((i & 0xf)<<3) + j;\r\npti_control_frame_built_and_sent(mc, thread_name);\r\nreturn mc;\r\n}\r\nstruct pti_masterchannel *pti_request_masterchannel(u8 type,\r\nconst char *thread_name)\r\n{\r\nstruct pti_masterchannel *mc;\r\nmutex_lock(&alloclock);\r\nswitch (type) {\r\ncase 0:\r\nmc = get_id(drv_data->ia_app, MAX_APP_IDS,\r\nAPP_BASE_ID, thread_name);\r\nbreak;\r\ncase 1:\r\nmc = get_id(drv_data->ia_os, MAX_OS_IDS,\r\nOS_BASE_ID, thread_name);\r\nbreak;\r\ncase 2:\r\nmc = get_id(drv_data->ia_modem, MAX_MODEM_IDS,\r\nMODEM_BASE_ID, thread_name);\r\nbreak;\r\ndefault:\r\nmc = NULL;\r\n}\r\nmutex_unlock(&alloclock);\r\nreturn mc;\r\n}\r\nvoid pti_release_masterchannel(struct pti_masterchannel *mc)\r\n{\r\nu8 master, channel, i;\r\nmutex_lock(&alloclock);\r\nif (mc) {\r\nmaster = mc->master;\r\nchannel = mc->channel;\r\nif (master == APP_BASE_ID) {\r\ni = channel >> 3;\r\ndrv_data->ia_app[i] &= ~(0x80>>(channel & 0x7));\r\n} else if (master == OS_BASE_ID) {\r\ni = channel >> 3;\r\ndrv_data->ia_os[i] &= ~(0x80>>(channel & 0x7));\r\n} else {\r\ni = channel >> 3;\r\ndrv_data->ia_modem[i] &= ~(0x80>>(channel & 0x7));\r\n}\r\nkfree(mc);\r\n}\r\nmutex_unlock(&alloclock);\r\n}\r\nvoid pti_writedata(struct pti_masterchannel *mc, u8 *buf, int count)\r\n{\r\nif ((mc != NULL) && (buf != NULL) && (count > 0))\r\npti_write_to_aperture(mc, buf, count);\r\nreturn;\r\n}\r\nstatic void __devexit pti_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct pti_dev *drv_data;\r\ndrv_data = pci_get_drvdata(pdev);\r\nif (drv_data != NULL) {\r\npci_iounmap(pdev, drv_data->pti_ioaddr);\r\npci_set_drvdata(pdev, NULL);\r\nkfree(drv_data);\r\npci_release_region(pdev, 1);\r\npci_disable_device(pdev);\r\n}\r\n}\r\nstatic int pti_tty_driver_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nreturn tty_port_open(&drv_data->port, tty, filp);\r\n}\r\nstatic void pti_tty_driver_close(struct tty_struct *tty, struct file *filp)\r\n{\r\ntty_port_close(&drv_data->port, tty, filp);\r\n}\r\nstatic int pti_tty_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nint idx = tty->index;\r\nstruct pti_tty *pti_tty_data;\r\nint ret = tty_init_termios(tty);\r\nif (ret == 0) {\r\ntty_driver_kref_get(driver);\r\ntty->count++;\r\ndriver->ttys[idx] = tty;\r\npti_tty_data = kmalloc(sizeof(struct pti_tty), GFP_KERNEL);\r\nif (pti_tty_data == NULL)\r\nreturn -ENOMEM;\r\nif (idx == PTITTY_MINOR_START)\r\npti_tty_data->mc = pti_request_masterchannel(0, NULL);\r\nelse\r\npti_tty_data->mc = pti_request_masterchannel(2, NULL);\r\nif (pti_tty_data->mc == NULL) {\r\nkfree(pti_tty_data);\r\nreturn -ENXIO;\r\n}\r\ntty->driver_data = pti_tty_data;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pti_tty_cleanup(struct tty_struct *tty)\r\n{\r\nstruct pti_tty *pti_tty_data = tty->driver_data;\r\nif (pti_tty_data == NULL)\r\nreturn;\r\npti_release_masterchannel(pti_tty_data->mc);\r\nkfree(pti_tty_data);\r\ntty->driver_data = NULL;\r\n}\r\nstatic int pti_tty_driver_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int len)\r\n{\r\nstruct pti_tty *pti_tty_data = tty->driver_data;\r\nif ((pti_tty_data != NULL) && (pti_tty_data->mc != NULL)) {\r\npti_write_to_aperture(pti_tty_data->mc, (u8 *)buf, len);\r\nreturn len;\r\n}\r\nelse\r\nreturn -EFAULT;\r\n}\r\nstatic int pti_tty_write_room(struct tty_struct *tty)\r\n{\r\nreturn 2048;\r\n}\r\nstatic int pti_char_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct pti_masterchannel *mc;\r\nmc = pti_request_masterchannel(0, NULL);\r\nif (mc == NULL)\r\nreturn -ENOMEM;\r\nfilp->private_data = mc;\r\nreturn 0;\r\n}\r\nstatic int pti_char_release(struct inode *inode, struct file *filp)\r\n{\r\npti_release_masterchannel(filp->private_data);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t pti_char_write(struct file *filp, const char __user *data,\r\nsize_t len, loff_t *ppose)\r\n{\r\nstruct pti_masterchannel *mc;\r\nvoid *kbuf;\r\nconst char __user *tmp;\r\nsize_t size = USER_COPY_SIZE;\r\nsize_t n = 0;\r\ntmp = data;\r\nmc = filp->private_data;\r\nkbuf = kmalloc(size, GFP_KERNEL);\r\nif (kbuf == NULL) {\r\npr_err("%s(%d): buf allocation failed\n",\r\n__func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\ndo {\r\nif (len - n > USER_COPY_SIZE)\r\nsize = USER_COPY_SIZE;\r\nelse\r\nsize = len - n;\r\nif (copy_from_user(kbuf, tmp, size)) {\r\nkfree(kbuf);\r\nreturn n ? n : -EFAULT;\r\n}\r\npti_write_to_aperture(mc, kbuf, size);\r\nn += size;\r\ntmp += size;\r\n} while (len > n);\r\nkfree(kbuf);\r\nreturn len;\r\n}\r\nstatic void pti_console_write(struct console *c, const char *buf, unsigned len)\r\n{\r\nstatic struct pti_masterchannel mc = {.master = CONSOLE_ID,\r\n.channel = 0};\r\nmc.channel = pti_console_channel;\r\npti_console_channel = (pti_console_channel + 1) & 0x7f;\r\npti_write_full_frame_to_aperture(&mc, buf, len);\r\n}\r\nstatic struct tty_driver *pti_console_device(struct console *c, int *index)\r\n{\r\n*index = c->index;\r\nreturn pti_tty_driver;\r\n}\r\nstatic int pti_console_setup(struct console *c, char *opts)\r\n{\r\npti_console_channel = 0;\r\npti_control_channel = 0;\r\nreturn 0;\r\n}\r\nstatic int pti_port_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nif (port->tty->index == PTITTY_MINOR_START)\r\nconsole_start(&pti_console);\r\nreturn 0;\r\n}\r\nstatic void pti_port_shutdown(struct tty_port *port)\r\n{\r\nif (port->tty->index == PTITTY_MINOR_START)\r\nconsole_stop(&pti_console);\r\n}\r\nstatic int __devinit pti_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint retval = -EINVAL;\r\nint pci_bar = 1;\r\ndev_dbg(&pdev->dev, "%s %s(%d): PTI PCI ID %04x:%04x\n", __FILE__,\r\n__func__, __LINE__, pdev->vendor, pdev->device);\r\nretval = misc_register(&pti_char_driver);\r\nif (retval) {\r\npr_err("%s(%d): CHAR registration failed of pti driver\n",\r\n__func__, __LINE__);\r\npr_err("%s(%d): Error value returned: %d\n",\r\n__func__, __LINE__, retval);\r\nreturn retval;\r\n}\r\nretval = pci_enable_device(pdev);\r\nif (retval != 0) {\r\ndev_err(&pdev->dev,\r\n"%s: pci_enable_device() returned error %d\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\ndrv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);\r\nif (drv_data == NULL) {\r\nretval = -ENOMEM;\r\ndev_err(&pdev->dev,\r\n"%s(%d): kmalloc() returned NULL memory.\n",\r\n__func__, __LINE__);\r\nreturn retval;\r\n}\r\ndrv_data->pti_addr = pci_resource_start(pdev, pci_bar);\r\nretval = pci_request_region(pdev, pci_bar, dev_name(&pdev->dev));\r\nif (retval != 0) {\r\ndev_err(&pdev->dev,\r\n"%s(%d): pci_request_region() returned error %d\n",\r\n__func__, __LINE__, retval);\r\nkfree(drv_data);\r\nreturn retval;\r\n}\r\ndrv_data->aperture_base = drv_data->pti_addr+APERTURE_14;\r\ndrv_data->pti_ioaddr =\r\nioremap_nocache((u32)drv_data->aperture_base,\r\nAPERTURE_LEN);\r\nif (!drv_data->pti_ioaddr) {\r\npci_release_region(pdev, pci_bar);\r\nretval = -ENOMEM;\r\nkfree(drv_data);\r\nreturn retval;\r\n}\r\npci_set_drvdata(pdev, drv_data);\r\ntty_port_init(&drv_data->port);\r\ndrv_data->port.ops = &tty_port_ops;\r\ntty_register_device(pti_tty_driver, 0, &pdev->dev);\r\ntty_register_device(pti_tty_driver, 1, &pdev->dev);\r\nregister_console(&pti_console);\r\nreturn retval;\r\n}\r\nstatic int __init pti_init(void)\r\n{\r\nint retval = -EINVAL;\r\npti_tty_driver = alloc_tty_driver(1);\r\nif (pti_tty_driver == NULL) {\r\npr_err("%s(%d): Memory allocation failed for ptiTTY driver\n",\r\n__func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\npti_tty_driver->owner = THIS_MODULE;\r\npti_tty_driver->magic = TTY_DRIVER_MAGIC;\r\npti_tty_driver->driver_name = DRIVERNAME;\r\npti_tty_driver->name = TTYNAME;\r\npti_tty_driver->major = 0;\r\npti_tty_driver->minor_start = PTITTY_MINOR_START;\r\npti_tty_driver->minor_num = PTITTY_MINOR_NUM;\r\npti_tty_driver->num = PTITTY_MINOR_NUM;\r\npti_tty_driver->type = TTY_DRIVER_TYPE_SYSTEM;\r\npti_tty_driver->subtype = SYSTEM_TYPE_SYSCONS;\r\npti_tty_driver->flags = TTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV;\r\npti_tty_driver->init_termios = tty_std_termios;\r\ntty_set_operations(pti_tty_driver, &pti_tty_driver_ops);\r\nretval = tty_register_driver(pti_tty_driver);\r\nif (retval) {\r\npr_err("%s(%d): TTY registration failed of pti driver\n",\r\n__func__, __LINE__);\r\npr_err("%s(%d): Error value returned: %d\n",\r\n__func__, __LINE__, retval);\r\npti_tty_driver = NULL;\r\nreturn retval;\r\n}\r\nretval = pci_register_driver(&pti_pci_driver);\r\nif (retval) {\r\npr_err("%s(%d): PCI registration failed of pti driver\n",\r\n__func__, __LINE__);\r\npr_err("%s(%d): Error value returned: %d\n",\r\n__func__, __LINE__, retval);\r\ntty_unregister_driver(pti_tty_driver);\r\npr_err("%s(%d): Unregistering TTY part of pti driver\n",\r\n__func__, __LINE__);\r\npti_tty_driver = NULL;\r\nreturn retval;\r\n}\r\nreturn retval;\r\n}\r\nstatic void __exit pti_exit(void)\r\n{\r\nint retval;\r\ntty_unregister_device(pti_tty_driver, 0);\r\ntty_unregister_device(pti_tty_driver, 1);\r\nretval = tty_unregister_driver(pti_tty_driver);\r\nif (retval) {\r\npr_err("%s(%d): TTY unregistration failed of pti driver\n",\r\n__func__, __LINE__);\r\npr_err("%s(%d): Error value returned: %d\n",\r\n__func__, __LINE__, retval);\r\n}\r\npci_unregister_driver(&pti_pci_driver);\r\nretval = misc_deregister(&pti_char_driver);\r\nif (retval) {\r\npr_err("%s(%d): CHAR unregistration failed of pti driver\n",\r\n__func__, __LINE__);\r\npr_err("%s(%d): Error value returned: %d\n",\r\n__func__, __LINE__, retval);\r\n}\r\nunregister_console(&pti_console);\r\nreturn;\r\n}
