static acpi_status\r\nacpi_tb_check_xsdt(acpi_physical_address address)\r\n{\r\nstruct acpi_table_header *table;\r\nu32 length;\r\nu64 xsdt_entry_address;\r\nu8 *table_entry;\r\nu32 table_count;\r\nint i;\r\ntable = acpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!table)\r\nreturn AE_NO_MEMORY;\r\nlength = table->length;\r\nacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\r\nif (length < sizeof(struct acpi_table_header))\r\nreturn AE_INVALID_TABLE_LENGTH;\r\ntable = acpi_os_map_memory(address, length);\r\nif (!table)\r\nreturn AE_NO_MEMORY;\r\ntable_count =\r\n(u32) ((table->length -\r\nsizeof(struct acpi_table_header)) / sizeof(u64));\r\ntable_entry =\r\nACPI_CAST_PTR(u8, table) + sizeof(struct acpi_table_header);\r\nfor (i = 0; i < table_count; i++) {\r\nACPI_MOVE_64_TO_64(&xsdt_entry_address, table_entry);\r\nif (!xsdt_entry_address) {\r\nbreak;\r\n}\r\ntable_entry += sizeof(u64);\r\n}\r\nacpi_os_unmap_memory(table, length);\r\nif (i < table_count)\r\nreturn AE_NULL_ENTRY;\r\nelse\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_tb_initialize_facs(void)\r\n{\r\nacpi_status status;\r\nstatus = acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,\r\nACPI_CAST_INDIRECT_PTR(struct\r\nacpi_table_header,\r\n&acpi_gbl_FACS));\r\nreturn status;\r\n}\r\nu8 acpi_tb_tables_loaded(void)\r\n{\r\nif (acpi_gbl_root_table_list.current_table_count >= 3) {\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nstatic void acpi_tb_fix_string(char *string, acpi_size length)\r\n{\r\nwhile (length && *string) {\r\nif (!ACPI_IS_PRINT(*string)) {\r\n*string = '?';\r\n}\r\nstring++;\r\nlength--;\r\n}\r\n}\r\nstatic void\r\nacpi_tb_cleanup_table_header(struct acpi_table_header *out_header,\r\nstruct acpi_table_header *header)\r\n{\r\nACPI_MEMCPY(out_header, header, sizeof(struct acpi_table_header));\r\nacpi_tb_fix_string(out_header->signature, ACPI_NAME_SIZE);\r\nacpi_tb_fix_string(out_header->oem_id, ACPI_OEM_ID_SIZE);\r\nacpi_tb_fix_string(out_header->oem_table_id, ACPI_OEM_TABLE_ID_SIZE);\r\nacpi_tb_fix_string(out_header->asl_compiler_id, ACPI_NAME_SIZE);\r\n}\r\nvoid\r\nacpi_tb_print_table_header(acpi_physical_address address,\r\nstruct acpi_table_header *header)\r\n{\r\nstruct acpi_table_header local_header;\r\nif (ACPI_COMPARE_NAME(header->signature, ACPI_SIG_FACS)) {\r\nACPI_INFO((AE_INFO, "%4.4s %p %05X",\r\nheader->signature, ACPI_CAST_PTR(void, address),\r\nheader->length));\r\n} else if (ACPI_COMPARE_NAME(header->signature, ACPI_SIG_RSDP)) {\r\nACPI_MEMCPY(local_header.oem_id,\r\nACPI_CAST_PTR(struct acpi_table_rsdp,\r\nheader)->oem_id, ACPI_OEM_ID_SIZE);\r\nacpi_tb_fix_string(local_header.oem_id, ACPI_OEM_ID_SIZE);\r\nACPI_INFO((AE_INFO, "RSDP %p %05X (v%.2d %6.6s)",\r\nACPI_CAST_PTR (void, address),\r\n(ACPI_CAST_PTR(struct acpi_table_rsdp, header)->\r\nrevision >\r\n0) ? ACPI_CAST_PTR(struct acpi_table_rsdp,\r\nheader)->length : 20,\r\nACPI_CAST_PTR(struct acpi_table_rsdp,\r\nheader)->revision,\r\nlocal_header.oem_id));\r\n} else {\r\nacpi_tb_cleanup_table_header(&local_header, header);\r\nACPI_INFO((AE_INFO,\r\n"%4.4s %p %05X (v%.2d %6.6s %8.8s %08X %4.4s %08X)",\r\nlocal_header.signature, ACPI_CAST_PTR(void, address),\r\nlocal_header.length, local_header.revision,\r\nlocal_header.oem_id, local_header.oem_table_id,\r\nlocal_header.oem_revision,\r\nlocal_header.asl_compiler_id,\r\nlocal_header.asl_compiler_revision));\r\n}\r\n}\r\nacpi_status acpi_tb_verify_checksum(struct acpi_table_header *table, u32 length)\r\n{\r\nu8 checksum;\r\nchecksum = acpi_tb_checksum(ACPI_CAST_PTR(u8, table), length);\r\nif (checksum) {\r\nACPI_WARNING((AE_INFO,\r\n"Incorrect checksum in table [%4.4s] - 0x%2.2X, should be 0x%2.2X",\r\ntable->signature, table->checksum,\r\n(u8) (table->checksum - checksum)));\r\n#if (ACPI_CHECKSUM_ABORT)\r\nreturn (AE_BAD_CHECKSUM);\r\n#endif\r\n}\r\nreturn (AE_OK);\r\n}\r\nu8 acpi_tb_checksum(u8 *buffer, u32 length)\r\n{\r\nu8 sum = 0;\r\nu8 *end = buffer + length;\r\nwhile (buffer < end) {\r\nsum = (u8) (sum + *(buffer++));\r\n}\r\nreturn sum;\r\n}\r\nvoid acpi_tb_check_dsdt_header(void)\r\n{\r\nif (acpi_gbl_original_dsdt_header.length != acpi_gbl_DSDT->length ||\r\nacpi_gbl_original_dsdt_header.checksum != acpi_gbl_DSDT->checksum) {\r\nACPI_ERROR((AE_INFO,\r\n"The DSDT has been corrupted or replaced - old, new headers below"));\r\nacpi_tb_print_table_header(0, &acpi_gbl_original_dsdt_header);\r\nacpi_tb_print_table_header(0, acpi_gbl_DSDT);\r\nACPI_ERROR((AE_INFO,\r\n"Please send DMI info to linux-acpi@vger.kernel.org\n"\r\n"If system does not work as expected, please boot with acpi=copy_dsdt"));\r\nacpi_gbl_original_dsdt_header.length = acpi_gbl_DSDT->length;\r\nacpi_gbl_original_dsdt_header.checksum =\r\nacpi_gbl_DSDT->checksum;\r\n}\r\n}\r\nstruct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index)\r\n{\r\nstruct acpi_table_header *new_table;\r\nstruct acpi_table_desc *table_desc;\r\ntable_desc = &acpi_gbl_root_table_list.tables[table_index];\r\nnew_table = ACPI_ALLOCATE(table_desc->length);\r\nif (!new_table) {\r\nACPI_ERROR((AE_INFO, "Could not copy DSDT of length 0x%X",\r\ntable_desc->length));\r\nreturn (NULL);\r\n}\r\nACPI_MEMCPY(new_table, table_desc->pointer, table_desc->length);\r\nacpi_tb_delete_table(table_desc);\r\ntable_desc->pointer = new_table;\r\ntable_desc->flags = ACPI_TABLE_ORIGIN_ALLOCATED;\r\nACPI_INFO((AE_INFO,\r\n"Forced DSDT copy: length 0x%05X copied locally, original unmapped",\r\nnew_table->length));\r\nreturn (new_table);\r\n}\r\nvoid\r\nacpi_tb_install_table(acpi_physical_address address,\r\nchar *signature, u32 table_index)\r\n{\r\nu8 flags;\r\nacpi_status status;\r\nstruct acpi_table_header *table_to_install;\r\nstruct acpi_table_header *mapped_table;\r\nstruct acpi_table_header *override_table = NULL;\r\nif (!address) {\r\nACPI_ERROR((AE_INFO,\r\n"Null physical address for ACPI table [%s]",\r\nsignature));\r\nreturn;\r\n}\r\nmapped_table =\r\nacpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!mapped_table) {\r\nreturn;\r\n}\r\nif (signature && !ACPI_COMPARE_NAME(mapped_table->signature, signature)) {\r\nACPI_ERROR((AE_INFO,\r\n"Invalid signature 0x%X for ACPI table, expected [%s]",\r\n*ACPI_CAST_PTR(u32, mapped_table->signature),\r\nsignature));\r\ngoto unmap_and_exit;\r\n}\r\nstatus = acpi_os_table_override(mapped_table, &override_table);\r\nif (ACPI_SUCCESS(status) && override_table) {\r\nACPI_INFO((AE_INFO,\r\n"%4.4s @ 0x%p Table override, replaced with:",\r\nmapped_table->signature, ACPI_CAST_PTR(void,\r\naddress)));\r\nacpi_gbl_root_table_list.tables[table_index].pointer =\r\noverride_table;\r\naddress = ACPI_PTR_TO_PHYSADDR(override_table);\r\ntable_to_install = override_table;\r\nflags = ACPI_TABLE_ORIGIN_OVERRIDE;\r\n} else {\r\ntable_to_install = mapped_table;\r\nflags = ACPI_TABLE_ORIGIN_MAPPED;\r\n}\r\nacpi_gbl_root_table_list.tables[table_index].address = address;\r\nacpi_gbl_root_table_list.tables[table_index].length =\r\ntable_to_install->length;\r\nacpi_gbl_root_table_list.tables[table_index].flags = flags;\r\nACPI_MOVE_32_TO_32(&\r\n(acpi_gbl_root_table_list.tables[table_index].\r\nsignature), table_to_install->signature);\r\nacpi_tb_print_table_header(address, table_to_install);\r\nif (table_index == ACPI_TABLE_INDEX_DSDT) {\r\nacpi_ut_set_integer_width(table_to_install->revision);\r\n}\r\nunmap_and_exit:\r\nacpi_os_unmap_memory(mapped_table, sizeof(struct acpi_table_header));\r\n}\r\nstatic acpi_physical_address\r\nacpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size)\r\n{\r\nu64 address64;\r\nif (table_entry_size == sizeof(u32)) {\r\nreturn ((acpi_physical_address)\r\n(*ACPI_CAST_PTR(u32, table_entry)));\r\n} else {\r\nACPI_MOVE_64_TO_64(&address64, table_entry);\r\n#if ACPI_MACHINE_WIDTH == 32\r\nif (address64 > ACPI_UINT32_MAX) {\r\nACPI_WARNING((AE_INFO,\r\n"64-bit Physical Address in XSDT is too large (0x%8.8X%8.8X),"\r\n" truncating",\r\nACPI_FORMAT_UINT64(address64)));\r\n}\r\n#endif\r\nreturn ((acpi_physical_address) (address64));\r\n}\r\n}\r\nacpi_status __init\r\nacpi_tb_parse_root_table(acpi_physical_address rsdp_address)\r\n{\r\nstruct acpi_table_rsdp *rsdp;\r\nu32 table_entry_size;\r\nu32 i;\r\nu32 table_count;\r\nstruct acpi_table_header *table;\r\nacpi_physical_address address;\r\nacpi_physical_address uninitialized_var(rsdt_address);\r\nu32 length;\r\nu8 *table_entry;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(tb_parse_root_table);\r\nrsdp = acpi_os_map_memory(rsdp_address, sizeof(struct acpi_table_rsdp));\r\nif (!rsdp) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_tb_print_table_header(rsdp_address,\r\nACPI_CAST_PTR(struct acpi_table_header,\r\nrsdp));\r\nif (rsdp->revision > 1 && rsdp->xsdt_physical_address\r\n&& !acpi_rsdt_forced) {\r\naddress = (acpi_physical_address) rsdp->xsdt_physical_address;\r\ntable_entry_size = sizeof(u64);\r\nrsdt_address = (acpi_physical_address)\r\nrsdp->rsdt_physical_address;\r\n} else {\r\naddress = (acpi_physical_address) rsdp->rsdt_physical_address;\r\ntable_entry_size = sizeof(u32);\r\n}\r\nacpi_os_unmap_memory(rsdp, sizeof(struct acpi_table_rsdp));\r\nif (table_entry_size == sizeof(u64)) {\r\nif (acpi_tb_check_xsdt(address) == AE_NULL_ENTRY) {\r\naddress = rsdt_address;\r\ntable_entry_size = sizeof(u32);\r\nACPI_WARNING((AE_INFO, "BIOS XSDT has NULL entry, "\r\n"using RSDT"));\r\n}\r\n}\r\ntable = acpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_tb_print_table_header(address, table);\r\nlength = table->length;\r\nacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\r\nif (length < sizeof(struct acpi_table_header)) {\r\nACPI_ERROR((AE_INFO, "Invalid length 0x%X in RSDT/XSDT",\r\nlength));\r\nreturn_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);\r\n}\r\ntable = acpi_os_map_memory(address, length);\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus = acpi_tb_verify_checksum(table, length);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_unmap_memory(table, length);\r\nreturn_ACPI_STATUS(status);\r\n}\r\ntable_count = (u32)((table->length - sizeof(struct acpi_table_header)) /\r\ntable_entry_size);\r\ntable_entry =\r\nACPI_CAST_PTR(u8, table) + sizeof(struct acpi_table_header);\r\nacpi_gbl_root_table_list.current_table_count = 2;\r\nfor (i = 0; i < table_count; i++) {\r\nif (acpi_gbl_root_table_list.current_table_count >=\r\nacpi_gbl_root_table_list.max_table_count) {\r\nstatus = acpi_tb_resize_root_table_list();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO,\r\n"Truncating %u table entries!",\r\n(unsigned) (table_count -\r\n(acpi_gbl_root_table_list.\r\ncurrent_table_count -\r\n2))));\r\nbreak;\r\n}\r\n}\r\nacpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.\r\ncurrent_table_count].address =\r\nacpi_tb_get_root_table_entry(table_entry, table_entry_size);\r\ntable_entry += table_entry_size;\r\nacpi_gbl_root_table_list.current_table_count++;\r\n}\r\nacpi_os_unmap_memory(table, length);\r\nfor (i = 2; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\nacpi_tb_install_table(acpi_gbl_root_table_list.tables[i].\r\naddress, NULL, i);\r\nif (ACPI_COMPARE_NAME\r\n(&acpi_gbl_root_table_list.tables[i].signature,\r\nACPI_SIG_FADT)) {\r\nacpi_tb_parse_fadt(i);\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
