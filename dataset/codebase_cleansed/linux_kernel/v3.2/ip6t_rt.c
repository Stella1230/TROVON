static inline bool\r\nsegsleft_match(u_int32_t min, u_int32_t max, u_int32_t id, bool invert)\r\n{\r\nbool r;\r\npr_debug("segsleft_match:%c 0x%x <= 0x%x <= 0x%x\n",\r\ninvert ? '!' : ' ', min, id, max);\r\nr = (id >= min && id <= max) ^ invert;\r\npr_debug(" result %s\n", r ? "PASS" : "FAILED");\r\nreturn r;\r\n}\r\nstatic bool rt_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct ipv6_rt_hdr _route;\r\nconst struct ipv6_rt_hdr *rh;\r\nconst struct ip6t_rt *rtinfo = par->matchinfo;\r\nunsigned int temp;\r\nunsigned int ptr;\r\nunsigned int hdrlen = 0;\r\nbool ret = false;\r\nstruct in6_addr _addr;\r\nconst struct in6_addr *ap;\r\nint err;\r\nerr = ipv6_find_hdr(skb, &ptr, NEXTHDR_ROUTING, NULL);\r\nif (err < 0) {\r\nif (err != -ENOENT)\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nrh = skb_header_pointer(skb, ptr, sizeof(_route), &_route);\r\nif (rh == NULL) {\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nhdrlen = ipv6_optlen(rh);\r\nif (skb->len - ptr < hdrlen) {\r\nreturn false;\r\n}\r\npr_debug("IPv6 RT LEN %u %u ", hdrlen, rh->hdrlen);\r\npr_debug("TYPE %04X ", rh->type);\r\npr_debug("SGS_LEFT %u %02X\n", rh->segments_left, rh->segments_left);\r\npr_debug("IPv6 RT segsleft %02X ",\r\nsegsleft_match(rtinfo->segsleft[0], rtinfo->segsleft[1],\r\nrh->segments_left,\r\n!!(rtinfo->invflags & IP6T_RT_INV_SGS)));\r\npr_debug("type %02X %02X %02X ",\r\nrtinfo->rt_type, rh->type,\r\n(!(rtinfo->flags & IP6T_RT_TYP) ||\r\n((rtinfo->rt_type == rh->type) ^\r\n!!(rtinfo->invflags & IP6T_RT_INV_TYP))));\r\npr_debug("len %02X %04X %02X ",\r\nrtinfo->hdrlen, hdrlen,\r\n!(rtinfo->flags & IP6T_RT_LEN) ||\r\n((rtinfo->hdrlen == hdrlen) ^\r\n!!(rtinfo->invflags & IP6T_RT_INV_LEN)));\r\npr_debug("res %02X %02X %02X ",\r\nrtinfo->flags & IP6T_RT_RES,\r\n((const struct rt0_hdr *)rh)->reserved,\r\n!((rtinfo->flags & IP6T_RT_RES) &&\r\n(((const struct rt0_hdr *)rh)->reserved)));\r\nret = (rh != NULL) &&\r\n(segsleft_match(rtinfo->segsleft[0], rtinfo->segsleft[1],\r\nrh->segments_left,\r\n!!(rtinfo->invflags & IP6T_RT_INV_SGS))) &&\r\n(!(rtinfo->flags & IP6T_RT_LEN) ||\r\n((rtinfo->hdrlen == hdrlen) ^\r\n!!(rtinfo->invflags & IP6T_RT_INV_LEN))) &&\r\n(!(rtinfo->flags & IP6T_RT_TYP) ||\r\n((rtinfo->rt_type == rh->type) ^\r\n!!(rtinfo->invflags & IP6T_RT_INV_TYP)));\r\nif (ret && (rtinfo->flags & IP6T_RT_RES)) {\r\nconst u_int32_t *rp;\r\nu_int32_t _reserved;\r\nrp = skb_header_pointer(skb,\r\nptr + offsetof(struct rt0_hdr,\r\nreserved),\r\nsizeof(_reserved),\r\n&_reserved);\r\nret = (*rp == 0);\r\n}\r\npr_debug("#%d ", rtinfo->addrnr);\r\nif (!(rtinfo->flags & IP6T_RT_FST)) {\r\nreturn ret;\r\n} else if (rtinfo->flags & IP6T_RT_FST_NSTRICT) {\r\npr_debug("Not strict ");\r\nif (rtinfo->addrnr > (unsigned int)((hdrlen - 8) / 16)) {\r\npr_debug("There isn't enough space\n");\r\nreturn false;\r\n} else {\r\nunsigned int i = 0;\r\npr_debug("#%d ", rtinfo->addrnr);\r\nfor (temp = 0;\r\ntemp < (unsigned int)((hdrlen - 8) / 16);\r\ntemp++) {\r\nap = skb_header_pointer(skb,\r\nptr\r\n+ sizeof(struct rt0_hdr)\r\n+ temp * sizeof(_addr),\r\nsizeof(_addr),\r\n&_addr);\r\nBUG_ON(ap == NULL);\r\nif (ipv6_addr_equal(ap, &rtinfo->addrs[i])) {\r\npr_debug("i=%d temp=%d;\n", i, temp);\r\ni++;\r\n}\r\nif (i == rtinfo->addrnr)\r\nbreak;\r\n}\r\npr_debug("i=%d #%d\n", i, rtinfo->addrnr);\r\nif (i == rtinfo->addrnr)\r\nreturn ret;\r\nelse\r\nreturn false;\r\n}\r\n} else {\r\npr_debug("Strict ");\r\nif (rtinfo->addrnr > (unsigned int)((hdrlen - 8) / 16)) {\r\npr_debug("There isn't enough space\n");\r\nreturn false;\r\n} else {\r\npr_debug("#%d ", rtinfo->addrnr);\r\nfor (temp = 0; temp < rtinfo->addrnr; temp++) {\r\nap = skb_header_pointer(skb,\r\nptr\r\n+ sizeof(struct rt0_hdr)\r\n+ temp * sizeof(_addr),\r\nsizeof(_addr),\r\n&_addr);\r\nBUG_ON(ap == NULL);\r\nif (!ipv6_addr_equal(ap, &rtinfo->addrs[temp]))\r\nbreak;\r\n}\r\npr_debug("temp=%d #%d\n", temp, rtinfo->addrnr);\r\nif (temp == rtinfo->addrnr &&\r\ntemp == (unsigned int)((hdrlen - 8) / 16))\r\nreturn ret;\r\nelse\r\nreturn false;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int rt_mt6_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ip6t_rt *rtinfo = par->matchinfo;\r\nif (rtinfo->invflags & ~IP6T_RT_INV_MASK) {\r\npr_debug("unknown flags %X\n", rtinfo->invflags);\r\nreturn -EINVAL;\r\n}\r\nif ((rtinfo->flags & (IP6T_RT_RES | IP6T_RT_FST_MASK)) &&\r\n(!(rtinfo->flags & IP6T_RT_TYP) ||\r\n(rtinfo->rt_type != 0) ||\r\n(rtinfo->invflags & IP6T_RT_INV_TYP))) {\r\npr_debug("`--rt-type 0' required before `--rt-0-*'");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rt_mt6_init(void)\r\n{\r\nreturn xt_register_match(&rt_mt6_reg);\r\n}\r\nstatic void __exit rt_mt6_exit(void)\r\n{\r\nxt_unregister_match(&rt_mt6_reg);\r\n}
