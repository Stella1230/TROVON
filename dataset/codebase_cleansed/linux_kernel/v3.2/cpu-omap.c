static int omap_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nif (freq_table)\r\nreturn cpufreq_frequency_table_verify(policy, freq_table);\r\nif (policy->cpu)\r\nreturn -EINVAL;\r\ncpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\npolicy->min = clk_round_rate(mpu_clk, policy->min * 1000) / 1000;\r\npolicy->max = clk_round_rate(mpu_clk, policy->max * 1000) / 1000;\r\ncpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\nreturn 0;\r\n}\r\nstatic unsigned int omap_getspeed(unsigned int cpu)\r\n{\r\nunsigned long rate;\r\nif (cpu)\r\nreturn 0;\r\nrate = clk_get_rate(mpu_clk) / 1000;\r\nreturn rate;\r\n}\r\nstatic int omap_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nstruct cpufreq_freqs freqs;\r\nint ret = 0;\r\nif (target_freq < policy->min)\r\ntarget_freq = policy->min;\r\nif (target_freq > policy->max)\r\ntarget_freq = policy->max;\r\nfreqs.old = omap_getspeed(0);\r\nfreqs.new = clk_round_rate(mpu_clk, target_freq * 1000) / 1000;\r\nfreqs.cpu = 0;\r\nif (freqs.old == freqs.new)\r\nreturn ret;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\n#ifdef CONFIG_CPU_FREQ_DEBUG\r\nprintk(KERN_DEBUG "cpufreq-omap: transition: %u --> %u\n",\r\nfreqs.old, freqs.new);\r\n#endif\r\nret = clk_set_rate(mpu_clk, freqs.new * 1000);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nreturn ret;\r\n}\r\nstatic int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint result = 0;\r\nmpu_clk = clk_get(NULL, MPU_CLK);\r\nif (IS_ERR(mpu_clk))\r\nreturn PTR_ERR(mpu_clk);\r\nif (policy->cpu != 0)\r\nreturn -EINVAL;\r\npolicy->cur = policy->min = policy->max = omap_getspeed(0);\r\nclk_init_cpufreq_table(&freq_table);\r\nif (freq_table) {\r\nresult = cpufreq_frequency_table_cpuinfo(policy, freq_table);\r\nif (!result)\r\ncpufreq_frequency_table_get_attr(freq_table,\r\npolicy->cpu);\r\n} else {\r\npolicy->cpuinfo.min_freq = clk_round_rate(mpu_clk, 0) / 1000;\r\npolicy->cpuinfo.max_freq = clk_round_rate(mpu_clk,\r\nVERY_HI_RATE) / 1000;\r\n}\r\npolicy->cpuinfo.transition_latency = 300 * 1000;\r\nreturn 0;\r\n}\r\nstatic int omap_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nclk_exit_cpufreq_table(&freq_table);\r\nclk_put(mpu_clk);\r\nreturn 0;\r\n}\r\nstatic int __init omap_cpufreq_init(void)\r\n{\r\nreturn cpufreq_register_driver(&omap_driver);\r\n}
