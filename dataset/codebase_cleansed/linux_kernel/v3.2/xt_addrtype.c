static u32 match_lookup_rt6(struct net *net, const struct net_device *dev,\r\nconst struct in6_addr *addr)\r\n{\r\nconst struct nf_afinfo *afinfo;\r\nstruct flowi6 flow;\r\nstruct rt6_info *rt;\r\nu32 ret;\r\nint route_err;\r\nmemset(&flow, 0, sizeof(flow));\r\nipv6_addr_copy(&flow.daddr, addr);\r\nif (dev)\r\nflow.flowi6_oif = dev->ifindex;\r\nrcu_read_lock();\r\nafinfo = nf_get_afinfo(NFPROTO_IPV6);\r\nif (afinfo != NULL)\r\nroute_err = afinfo->route(net, (struct dst_entry **)&rt,\r\nflowi6_to_flowi(&flow), !!dev);\r\nelse\r\nroute_err = 1;\r\nrcu_read_unlock();\r\nif (route_err)\r\nreturn XT_ADDRTYPE_UNREACHABLE;\r\nif (rt->rt6i_flags & RTF_REJECT)\r\nret = XT_ADDRTYPE_UNREACHABLE;\r\nelse\r\nret = 0;\r\nif (rt->rt6i_flags & RTF_LOCAL)\r\nret |= XT_ADDRTYPE_LOCAL;\r\nif (rt->rt6i_flags & RTF_ANYCAST)\r\nret |= XT_ADDRTYPE_ANYCAST;\r\ndst_release(&rt->dst);\r\nreturn ret;\r\n}\r\nstatic bool match_type6(struct net *net, const struct net_device *dev,\r\nconst struct in6_addr *addr, u16 mask)\r\n{\r\nint addr_type = ipv6_addr_type(addr);\r\nif ((mask & XT_ADDRTYPE_MULTICAST) &&\r\n!(addr_type & IPV6_ADDR_MULTICAST))\r\nreturn false;\r\nif ((mask & XT_ADDRTYPE_UNICAST) && !(addr_type & IPV6_ADDR_UNICAST))\r\nreturn false;\r\nif ((mask & XT_ADDRTYPE_UNSPEC) && addr_type != IPV6_ADDR_ANY)\r\nreturn false;\r\nif ((XT_ADDRTYPE_LOCAL | XT_ADDRTYPE_ANYCAST |\r\nXT_ADDRTYPE_UNREACHABLE) & mask)\r\nreturn !!(mask & match_lookup_rt6(net, dev, addr));\r\nreturn true;\r\n}\r\nstatic bool\r\naddrtype_mt6(struct net *net, const struct net_device *dev,\r\nconst struct sk_buff *skb, const struct xt_addrtype_info_v1 *info)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nbool ret = true;\r\nif (info->source)\r\nret &= match_type6(net, dev, &iph->saddr, info->source) ^\r\n(info->flags & XT_ADDRTYPE_INVERT_SOURCE);\r\nif (ret && info->dest)\r\nret &= match_type6(net, dev, &iph->daddr, info->dest) ^\r\n!!(info->flags & XT_ADDRTYPE_INVERT_DEST);\r\nreturn ret;\r\n}\r\nstatic inline bool match_type(struct net *net, const struct net_device *dev,\r\n__be32 addr, u_int16_t mask)\r\n{\r\nreturn !!(mask & (1 << inet_dev_addr_type(net, dev, addr)));\r\n}\r\nstatic bool\r\naddrtype_mt_v0(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct net *net = dev_net(par->in ? par->in : par->out);\r\nconst struct xt_addrtype_info *info = par->matchinfo;\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nbool ret = true;\r\nif (info->source)\r\nret &= match_type(net, NULL, iph->saddr, info->source) ^\r\ninfo->invert_source;\r\nif (info->dest)\r\nret &= match_type(net, NULL, iph->daddr, info->dest) ^\r\ninfo->invert_dest;\r\nreturn ret;\r\n}\r\nstatic bool\r\naddrtype_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct net *net = dev_net(par->in ? par->in : par->out);\r\nconst struct xt_addrtype_info_v1 *info = par->matchinfo;\r\nconst struct iphdr *iph;\r\nconst struct net_device *dev = NULL;\r\nbool ret = true;\r\nif (info->flags & XT_ADDRTYPE_LIMIT_IFACE_IN)\r\ndev = par->in;\r\nelse if (info->flags & XT_ADDRTYPE_LIMIT_IFACE_OUT)\r\ndev = par->out;\r\n#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)\r\nif (par->family == NFPROTO_IPV6)\r\nreturn addrtype_mt6(net, dev, skb, info);\r\n#endif\r\niph = ip_hdr(skb);\r\nif (info->source)\r\nret &= match_type(net, dev, iph->saddr, info->source) ^\r\n(info->flags & XT_ADDRTYPE_INVERT_SOURCE);\r\nif (ret && info->dest)\r\nret &= match_type(net, dev, iph->daddr, info->dest) ^\r\n!!(info->flags & XT_ADDRTYPE_INVERT_DEST);\r\nreturn ret;\r\n}\r\nstatic int addrtype_mt_checkentry_v1(const struct xt_mtchk_param *par)\r\n{\r\nstruct xt_addrtype_info_v1 *info = par->matchinfo;\r\nif (info->flags & XT_ADDRTYPE_LIMIT_IFACE_IN &&\r\ninfo->flags & XT_ADDRTYPE_LIMIT_IFACE_OUT) {\r\npr_info("both incoming and outgoing "\r\n"interface limitation cannot be selected\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->hook_mask & ((1 << NF_INET_PRE_ROUTING) |\r\n(1 << NF_INET_LOCAL_IN)) &&\r\ninfo->flags & XT_ADDRTYPE_LIMIT_IFACE_OUT) {\r\npr_info("output interface limitation "\r\n"not valid in PREROUTING and INPUT\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->hook_mask & ((1 << NF_INET_POST_ROUTING) |\r\n(1 << NF_INET_LOCAL_OUT)) &&\r\ninfo->flags & XT_ADDRTYPE_LIMIT_IFACE_IN) {\r\npr_info("input interface limitation "\r\n"not valid in POSTROUTING and OUTPUT\n");\r\nreturn -EINVAL;\r\n}\r\n#if defined(CONFIG_IP6_NF_IPTABLES) || defined(CONFIG_IP6_NF_IPTABLES_MODULE)\r\nif (par->family == NFPROTO_IPV6) {\r\nif ((info->source | info->dest) & XT_ADDRTYPE_BLACKHOLE) {\r\npr_err("ipv6 BLACKHOLE matching not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((info->source | info->dest) >= XT_ADDRTYPE_PROHIBIT) {\r\npr_err("ipv6 PROHIBT (THROW, NAT ..) matching not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((info->source | info->dest) & XT_ADDRTYPE_BROADCAST) {\r\npr_err("ipv6 does not support BROADCAST matching\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init addrtype_mt_init(void)\r\n{\r\nreturn xt_register_matches(addrtype_mt_reg,\r\nARRAY_SIZE(addrtype_mt_reg));\r\n}\r\nstatic void __exit addrtype_mt_exit(void)\r\n{\r\nxt_unregister_matches(addrtype_mt_reg, ARRAY_SIZE(addrtype_mt_reg));\r\n}
