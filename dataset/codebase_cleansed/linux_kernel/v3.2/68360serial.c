static inline int serial_paranoia_check(ser_info_t *info,\r\nchar *name, const char *routine)\r\n{\r\n#ifdef SERIAL_PARANOIA_CHECK\r\nstatic const char *badmagic =\r\n"Warning: bad magic number for serial struct (%s) in %s\n";\r\nstatic const char *badinfo =\r\n"Warning: null async_struct for (%s) in %s\n";\r\nif (!info) {\r\nprintk(badinfo, name, routine);\r\nreturn 1;\r\n}\r\nif (info->magic != SERIAL_MAGIC) {\r\nprintk(badmagic, name, routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void rs_360_stop(struct tty_struct *tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nint idx;\r\nunsigned long flags;\r\nvolatile struct scc_regs *sccp;\r\nvolatile struct smc_regs *smcp;\r\nif (serial_paranoia_check(info, tty->name, "rs_stop"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC) {\r\nsccp = &pquicc->scc_regs[idx];\r\nsccp->scc_sccm &= ~UART_SCCM_TX;\r\n} else {\r\nsmcp = &pquicc->smc_regs[idx];\r\nsmcp->smc_smcm &= ~SMCM_TX;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_360_start(struct tty_struct *tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nint idx;\r\nunsigned long flags;\r\nvolatile struct scc_regs *sccp;\r\nvolatile struct smc_regs *smcp;\r\nif (serial_paranoia_check(info, tty->name, "rs_stop"))\r\nreturn;\r\nlocal_irq_save(flags);\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC) {\r\nsccp = &pquicc->scc_regs[idx];\r\nsccp->scc_sccm |= UART_SCCM_TX;\r\n} else {\r\nsmcp = &pquicc->smc_regs[idx];\r\nsmcp->smc_smcm |= SMCM_TX;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic _INLINE_ void receive_chars(ser_info_t *info)\r\n{\r\nstruct tty_struct *tty = info->port.tty;\r\nunsigned char ch, flag, *cp;\r\nint i;\r\nushort status;\r\nstruct async_icount *icount;\r\nvolatile QUICC_BD *bdp;\r\nicount = &info->state->icount;\r\nbdp = info->rx_cur;\r\nfor (;;) {\r\nif (bdp->status & BD_SC_EMPTY)\r\nbreak;\r\nif (!(info->read_status_mask & BD_SC_EMPTY)) {\r\nbdp->status |= BD_SC_EMPTY;\r\nbdp->status &=\r\n~(BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV);\r\nif (bdp->status & BD_SC_WRAP)\r\nbdp = info->rx_bd_base;\r\nelse\r\nbdp++;\r\ncontinue;\r\n}\r\ni = bdp->length;\r\ncp = (char *)bdp->buf;\r\nstatus = bdp->status;\r\nwhile (i-- > 0) {\r\nch = *cp++;\r\nicount->rx++;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("DR%02x:%02x...", ch, status);\r\n#endif\r\nflag = TTY_NORMAL;\r\nif (status & (BD_SC_BR | BD_SC_FR |\r\nBD_SC_PR | BD_SC_OV)) {\r\nif (status & BD_SC_BR)\r\nicount->brk++;\r\nelse if (status & BD_SC_PR)\r\nicount->parity++;\r\nelse if (status & BD_SC_FR)\r\nicount->frame++;\r\nif (status & BD_SC_OV)\r\nicount->overrun++;\r\nstatus &= info->read_status_mask;\r\nif (status & (BD_SC_BR)) {\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("handling break....");\r\n#endif\r\n*tty->flip.flag_buf_ptr = TTY_BREAK;\r\nif (info->flags & ASYNC_SAK)\r\ndo_SAK(tty);\r\n} else if (status & BD_SC_PR)\r\nflag = TTY_PARITY;\r\nelse if (status & BD_SC_FR)\r\nflag = TTY_FRAME;\r\n}\r\ntty_insert_flip_char(tty, ch, flag);\r\nif (status & BD_SC_OV)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\n}\r\nbdp->status |= BD_SC_EMPTY;\r\nbdp->status &= ~(BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV);\r\nif (bdp->status & BD_SC_WRAP)\r\nbdp = info->rx_bd_base;\r\nelse\r\nbdp++;\r\n}\r\ninfo->rx_cur = (QUICC_BD *)bdp;\r\ntty_schedule_flip(tty);\r\n}\r\nstatic _INLINE_ void receive_break(ser_info_t *info)\r\n{\r\nstruct tty_struct *tty = info->port.tty;\r\ninfo->state->icount.brk++;\r\ntty_insert_flip_char(tty, 0, TTY_BREAK);\r\ntty_schedule_flip(tty);\r\n}\r\nstatic _INLINE_ void transmit_chars(ser_info_t *info)\r\n{\r\nif ((info->flags & TX_WAKEUP) ||\r\n(info->port.tty->flags & (1 << TTY_DO_WRITE_WAKEUP))) {\r\nschedule_work(&info->tqueue);\r\n}\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("THRE...");\r\n#endif\r\n}\r\nstatic _INLINE_ void check_modem_status(struct async_struct *info)\r\n{\r\nint status;\r\nstruct async_icount_24 *icount;\r\nstatus = serial_in(info, UART_MSR);\r\nif (status & UART_MSR_ANY_DELTA) {\r\nicount = &info->state->icount;\r\nif (status & UART_MSR_TERI)\r\nicount->rng++;\r\nif (status & UART_MSR_DDSR)\r\nicount->dsr++;\r\nif (status & UART_MSR_DDCD) {\r\nicount->dcd++;\r\n#ifdef CONFIG_HARD_PPS\r\nif ((info->flags & ASYNC_HARDPPS_CD) &&\r\n(status & UART_MSR_DCD))\r\nhardpps();\r\n#endif\r\n}\r\nif (status & UART_MSR_DCTS)\r\nicount->cts++;\r\nwake_up_interruptible(&info->delta_msr_wait);\r\n}\r\nif ((info->flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {\r\n#if (defined(SERIAL_DEBUG_OPEN) || defined(SERIAL_DEBUG_INTR))\r\nprintk("ttys%d CD now %s...", info->line,\r\n(status & UART_MSR_DCD) ? "on" : "off");\r\n#endif\r\nif (status & UART_MSR_DCD)\r\nwake_up_interruptible(&info->open_wait);\r\nelse {\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("scheduling hangup...");\r\n#endif\r\nqueue_task(&info->tqueue_hangup,\r\n&tq_scheduler);\r\n}\r\n}\r\nif (info->flags & ASYNC_CTS_FLOW) {\r\nif (info->port.tty->hw_stopped) {\r\nif (status & UART_MSR_CTS) {\r\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\r\nprintk("CTS tx start...");\r\n#endif\r\ninfo->port.tty->hw_stopped = 0;\r\ninfo->IER |= UART_IER_THRI;\r\nserial_out(info, UART_IER, info->IER);\r\nrs_sched_event(info, RS_EVENT_WRITE_WAKEUP);\r\nreturn;\r\n}\r\n} else {\r\nif (!(status & UART_MSR_CTS)) {\r\n#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))\r\nprintk("CTS tx stop...");\r\n#endif\r\ninfo->port.tty->hw_stopped = 1;\r\ninfo->IER &= ~UART_IER_THRI;\r\nserial_out(info, UART_IER, info->IER);\r\n}\r\n}\r\n}\r\n}\r\nstatic void rs_360_interrupt(int vec, void *dev_id)\r\n{\r\nu_char events;\r\nint idx;\r\nser_info_t *info;\r\nvolatile struct smc_regs *smcp;\r\nvolatile struct scc_regs *sccp;\r\ninfo = dev_id;\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC) {\r\nsccp = &pquicc->scc_regs[idx];\r\nevents = sccp->scc_scce;\r\nif (events & SCCM_RX)\r\nreceive_chars(info);\r\nif (events & SCCM_TX)\r\ntransmit_chars(info);\r\nsccp->scc_scce = events;\r\n} else {\r\nsmcp = &pquicc->smc_regs[idx];\r\nevents = smcp->smc_smce;\r\nif (events & SMCM_BRKE)\r\nreceive_break(info);\r\nif (events & SMCM_RX)\r\nreceive_chars(info);\r\nif (events & SMCM_TX)\r\ntransmit_chars(info);\r\nsmcp->smc_smce = events;\r\n}\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("rs_interrupt_single(%d, %x)...",\r\ninfo->state->smc_scc_num, events);\r\n#endif\r\n#ifdef modem_control\r\ncheck_modem_status(info);\r\n#endif\r\ninfo->last_active = jiffies;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("end.\n");\r\n#endif\r\n}\r\nstatic void do_softint(void *private_)\r\n{\r\nser_info_t *info = (ser_info_t *) private_;\r\nstruct tty_struct *tty;\r\ntty = info->port.tty;\r\nif (!tty)\r\nreturn;\r\nif (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event))\r\ntty_wakeup(tty);\r\n}\r\nstatic void do_serial_hangup(void *private_)\r\n{\r\nstruct async_struct *info = (struct async_struct *) private_;\r\nstruct tty_struct *tty;\r\ntty = info->port.tty;\r\nif (!tty)\r\nreturn;\r\ntty_hangup(tty);\r\n}\r\nstatic int startup(ser_info_t *info)\r\n{\r\nunsigned long flags;\r\nint retval=0;\r\nint idx;\r\nvolatile struct smc_regs *smcp;\r\nvolatile struct scc_regs *sccp;\r\nvolatile struct smc_uart_pram *up;\r\nvolatile struct uart_pram *scup;\r\nlocal_irq_save(flags);\r\nif (info->flags & ASYNC_INITIALIZED) {\r\ngoto errout;\r\n}\r\n#ifdef maybe\r\nif (!state->port || !state->type) {\r\nif (info->port.tty)\r\nset_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ngoto errout;\r\n}\r\n#endif\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("starting up ttys%d (irq %d)...", info->line, state->irq);\r\n#endif\r\n#ifdef modem_control\r\ninfo->MCR = 0;\r\nif (info->port.tty->termios->c_cflag & CBAUD)\r\ninfo->MCR = UART_MCR_DTR | UART_MCR_RTS;\r\n#endif\r\nif (info->port.tty)\r\nclear_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\nchange_speed(info);\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC) {\r\nsccp = &pquicc->scc_regs[idx];\r\nscup = &pquicc->pram[info->state->port].scc.pscc.u;\r\nscup->mrblr = RX_BUF_SIZE;\r\nscup->max_idl = RX_BUF_SIZE;\r\nsccp->scc_sccm |= (UART_SCCM_TX | UART_SCCM_RX);\r\nsccp->scc_gsmr.w.low |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n} else {\r\nsmcp = &pquicc->smc_regs[idx];\r\nsmcp->smc_smcm |= (SMCM_RX | SMCM_TX);\r\nsmcp->smc_smcmr |= (SMCMR_REN | SMCMR_TEN);\r\nup = &pquicc->pram[info->state->port].scc.pothers.idma_smc.psmc.u;\r\nup->mrblr = RX_BUF_SIZE;\r\nup->max_idl = RX_BUF_SIZE;\r\nup->brkcr = 1;\r\n}\r\ninfo->flags |= ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\nerrout:\r\nlocal_irq_restore(flags);\r\nreturn retval;\r\n}\r\nstatic void shutdown(ser_info_t *info)\r\n{\r\nunsigned long flags;\r\nstruct serial_state *state;\r\nint idx;\r\nvolatile struct smc_regs *smcp;\r\nvolatile struct scc_regs *sccp;\r\nif (!(info->flags & ASYNC_INITIALIZED))\r\nreturn;\r\nstate = info->state;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("Shutting down serial port %d (irq %d)....", info->line,\r\nstate->irq);\r\n#endif\r\nlocal_irq_save(flags);\r\nidx = PORT_NUM(state->smc_scc_num);\r\nif (state->smc_scc_num & NUM_IS_SCC) {\r\nsccp = &pquicc->scc_regs[idx];\r\nsccp->scc_gsmr.w.low &= ~(SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n#ifdef CONFIG_SERIAL_CONSOLE\r\nif ((state - rs_table) != CONFIG_SERIAL_CONSOLE_PORT)\r\n#endif\r\nsccp->scc_sccm &= ~(UART_SCCM_TX | UART_SCCM_RX);\r\n} else {\r\nsmcp = &pquicc->smc_regs[idx];\r\nsmcp->smc_smcm &= ~(SMCM_RX | SMCM_TX);\r\n#ifdef CONFIG_SERIAL_CONSOLE\r\nif ((state - rs_table) != CONFIG_SERIAL_CONSOLE_PORT)\r\n#endif\r\nsmcp->smc_smcmr &= ~(SMCMR_REN | SMCMR_TEN);\r\n}\r\nif (info->port.tty)\r\nset_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->flags &= ~ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void change_speed(ser_info_t *info)\r\n{\r\nint baud_rate;\r\nunsigned cflag, cval, scval, prev_mode;\r\nint i, bits, sbits, idx;\r\nunsigned long flags;\r\nstruct serial_state *state;\r\nvolatile struct smc_regs *smcp;\r\nvolatile struct scc_regs *sccp;\r\nif (!info->port.tty || !info->port.tty->termios)\r\nreturn;\r\ncflag = info->port.tty->termios->c_cflag;\r\nstate = info->state;\r\ncval = 0;\r\nscval = 0;\r\nswitch (cflag & CSIZE) {\r\ncase CS5: bits = 5; break;\r\ncase CS6: bits = 6; break;\r\ncase CS7: bits = 7; break;\r\ncase CS8: bits = 8; break;\r\ndefault: bits = 8; break;\r\n}\r\nsbits = bits - 5;\r\nif (cflag & CSTOPB) {\r\ncval |= SMCMR_SL;\r\nscval |= SCU_PMSR_SL;\r\nbits++;\r\n}\r\nif (cflag & PARENB) {\r\ncval |= SMCMR_PEN;\r\nscval |= SCU_PMSR_PEN;\r\nbits++;\r\n}\r\nif (!(cflag & PARODD)) {\r\ncval |= SMCMR_PM_EVEN;\r\nscval |= (SCU_PMSR_REVP | SCU_PMSR_TEVP);\r\n}\r\ni = cflag & CBAUD;\r\nif (i >= (sizeof(baud_table)/sizeof(int)))\r\nbaud_rate = 9600;\r\nelse\r\nbaud_rate = baud_table[i];\r\ninfo->timeout = (TX_BUF_SIZE*HZ*bits);\r\ninfo->timeout += HZ/50;\r\n#ifdef modem_control\r\ninfo->IER &= ~UART_IER_MSI;\r\nif (info->flags & ASYNC_HARDPPS_CD)\r\ninfo->IER |= UART_IER_MSI;\r\nif (cflag & CRTSCTS) {\r\ninfo->flags |= ASYNC_CTS_FLOW;\r\ninfo->IER |= UART_IER_MSI;\r\n} else\r\ninfo->flags &= ~ASYNC_CTS_FLOW;\r\nif (cflag & CLOCAL)\r\ninfo->flags &= ~ASYNC_CHECK_CD;\r\nelse {\r\ninfo->flags |= ASYNC_CHECK_CD;\r\ninfo->IER |= UART_IER_MSI;\r\n}\r\nserial_out(info, UART_IER, info->IER);\r\n#endif\r\ninfo->read_status_mask = (BD_SC_EMPTY | BD_SC_OV);\r\nif (I_INPCK(info->port.tty))\r\ninfo->read_status_mask |= BD_SC_FR | BD_SC_PR;\r\nif (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))\r\ninfo->read_status_mask |= BD_SC_BR;\r\ninfo->ignore_status_mask = 0;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask |= BD_SC_PR | BD_SC_FR;\r\nif (I_IGNBRK(info->port.tty)) {\r\ninfo->ignore_status_mask |= BD_SC_BR;\r\nif (I_IGNPAR(info->port.tty))\r\ninfo->ignore_status_mask |= BD_SC_OV;\r\n}\r\nif ((cflag & CREAD) == 0)\r\ninfo->read_status_mask &= ~BD_SC_EMPTY;\r\nlocal_irq_save(flags);\r\nbits++;\r\nidx = PORT_NUM(state->smc_scc_num);\r\nif (state->smc_scc_num & NUM_IS_SCC) {\r\nsccp = &pquicc->scc_regs[idx];\r\nsccp->scc_psmr = (sbits << 12) | scval;\r\n} else {\r\nsmcp = &pquicc->smc_regs[idx];\r\nprev_mode = smcp->smc_smcmr;\r\nsmcp->smc_smcmr = smcr_mk_clen(bits) | cval | SMCMR_SM_UART;\r\nsmcp->smc_smcmr |= (prev_mode & (SMCMR_REN | SMCMR_TEN));\r\n}\r\nm360_cpm_setbrg((state - rs_table), baud_rate);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_360_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nvolatile QUICC_BD *bdp;\r\nif (serial_paranoia_check(info, tty->name, "rs_put_char"))\r\nreturn 0;\r\nif (!tty)\r\nreturn 0;\r\nbdp = info->tx_cur;\r\nwhile (bdp->status & BD_SC_READY);\r\n*((char *)bdp->buf) = ch;\r\nbdp->length = 1;\r\nbdp->status |= BD_SC_READY;\r\nif (bdp->status & BD_SC_WRAP)\r\nbdp = info->tx_bd_base;\r\nelse\r\nbdp++;\r\ninfo->tx_cur = (QUICC_BD *)bdp;\r\nreturn 1;\r\n}\r\nstatic int rs_360_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nvolatile QUICC_BD *bdp;\r\n#ifdef CONFIG_KGDB\r\nif (kgdb_output_string(buf, count))\r\nreturn ret;\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "rs_write"))\r\nreturn 0;\r\nif (!tty)\r\nreturn 0;\r\nbdp = info->tx_cur;\r\nwhile (1) {\r\nc = min(count, TX_BUF_SIZE);\r\nif (c <= 0)\r\nbreak;\r\nif (bdp->status & BD_SC_READY) {\r\ninfo->flags |= TX_WAKEUP;\r\nbreak;\r\n}\r\nmemcpy((void *)bdp->buf, buf, c);\r\nbdp->length = c;\r\nbdp->status |= BD_SC_READY;\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\nif (bdp->status & BD_SC_WRAP)\r\nbdp = info->tx_bd_base;\r\nelse\r\nbdp++;\r\ninfo->tx_cur = (QUICC_BD *)bdp;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rs_360_write_room(struct tty_struct *tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nint ret;\r\nif (serial_paranoia_check(info, tty->name, "rs_write_room"))\r\nreturn 0;\r\nif ((info->tx_cur->status & BD_SC_READY) == 0) {\r\ninfo->flags &= ~TX_WAKEUP;\r\nret = TX_BUF_SIZE;\r\n}\r\nelse {\r\ninfo->flags |= TX_WAKEUP;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rs_360_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_chars_in_buffer"))\r\nreturn 0;\r\nreturn 0;\r\n}\r\nstatic void rs_360_flush_buffer(struct tty_struct *tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))\r\nreturn;\r\ntty_wakeup(tty);\r\ninfo->flags &= ~TX_WAKEUP;\r\n}\r\nstatic void rs_360_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nvolatile QUICC_BD *bdp;\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nif (serial_paranoia_check(info, tty->name, "rs_send_char"))\r\nreturn;\r\nbdp = info->tx_cur;\r\nwhile (bdp->status & BD_SC_READY);\r\n*((char *)bdp->buf) = ch;\r\nbdp->length = 1;\r\nbdp->status |= BD_SC_READY;\r\nif (bdp->status & BD_SC_WRAP)\r\nbdp = info->tx_bd_base;\r\nelse\r\nbdp++;\r\ninfo->tx_cur = (QUICC_BD *)bdp;\r\n}\r\nstatic void rs_360_throttle(struct tty_struct * tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk("throttle %s: %d....\n", _tty_name(tty, buf),\r\ntty->ldisc.chars_in_buffer(tty));\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "rs_throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nrs_360_send_xchar(tty, STOP_CHAR(tty));\r\n#ifdef modem_control\r\nif (tty->termios->c_cflag & CRTSCTS)\r\ninfo->MCR &= ~UART_MCR_RTS;\r\nlocal_irq_disable();\r\nserial_out(info, UART_MCR, info->MCR);\r\nlocal_irq_enable();\r\n#endif\r\n}\r\nstatic void rs_360_unthrottle(struct tty_struct * tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk("unthrottle %s: %d....\n", _tty_name(tty, buf),\r\ntty->ldisc.chars_in_buffer(tty));\r\n#endif\r\nif (serial_paranoia_check(info, tty->name, "rs_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nrs_360_send_xchar(tty, START_CHAR(tty));\r\n}\r\n#ifdef modem_control\r\nif (tty->termios->c_cflag & CRTSCTS)\r\ninfo->MCR |= UART_MCR_RTS;\r\nlocal_irq_disable();\r\nserial_out(info, UART_MCR, info->MCR);\r\nlocal_irq_enable();\r\n#endif\r\n}\r\nstatic int get_lsr_info(struct async_struct * info, unsigned int *value)\r\n{\r\nunsigned char status;\r\nunsigned int result;\r\nlocal_irq_disable();\r\nstatus = serial_in(info, UART_LSR);\r\nlocal_irq_enable();\r\nresult = ((status & UART_LSR_TEMT) ? TIOCSER_TEMT : 0);\r\nreturn put_user(result,value);\r\n}\r\nstatic int rs_360_tiocmget(struct tty_struct *tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nunsigned int result = 0;\r\n#ifdef modem_control\r\nunsigned char control, status;\r\nif (serial_paranoia_check(info, tty->name, __func__))\r\nreturn -ENODEV;\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\ncontrol = info->MCR;\r\nlocal_irq_disable();\r\nstatus = serial_in(info, UART_MSR);\r\nlocal_irq_enable();\r\nresult = ((control & UART_MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((control & UART_MCR_DTR) ? TIOCM_DTR : 0)\r\n#ifdef TIOCM_OUT1\r\n| ((control & UART_MCR_OUT1) ? TIOCM_OUT1 : 0)\r\n| ((control & UART_MCR_OUT2) ? TIOCM_OUT2 : 0)\r\n#endif\r\n| ((status & UART_MSR_DCD) ? TIOCM_CAR : 0)\r\n| ((status & UART_MSR_RI) ? TIOCM_RNG : 0)\r\n| ((status & UART_MSR_DSR) ? TIOCM_DSR : 0)\r\n| ((status & UART_MSR_CTS) ? TIOCM_CTS : 0);\r\n#endif\r\nreturn result;\r\n}\r\nstatic int rs_360_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\n#ifdef modem_control\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nunsigned int arg;\r\nif (serial_paranoia_check(info, tty->name, __func__))\r\nreturn -ENODEV;\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\nif (set & TIOCM_RTS)\r\ninfo->mcr |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->mcr |= UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->MCR &= ~UART_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->MCR &= ~UART_MCR_DTR;\r\n#ifdef TIOCM_OUT1\r\nif (set & TIOCM_OUT1)\r\ninfo->MCR |= UART_MCR_OUT1;\r\nif (set & TIOCM_OUT2)\r\ninfo->MCR |= UART_MCR_OUT2;\r\nif (clear & TIOCM_OUT1)\r\ninfo->MCR &= ~UART_MCR_OUT1;\r\nif (clear & TIOCM_OUT2)\r\ninfo->MCR &= ~UART_MCR_OUT2;\r\n#endif\r\nlocal_irq_disable();\r\nserial_out(info, UART_MCR, info->MCR);\r\nlocal_irq_enable();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void begin_break(ser_info_t *info)\r\n{\r\nvolatile QUICC *cp;\r\nushort chan;\r\nint idx;\r\ncp = pquicc;\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC)\r\nchan = scc_chan_map[idx];\r\nelse\r\nchan = smc_chan_map[idx];\r\ncp->cp_cr = mk_cr_cmd(chan, CPM_CR_STOP_TX) | CPM_CR_FLG;\r\nwhile (cp->cp_cr & CPM_CR_FLG);\r\n}\r\nstatic void end_break(ser_info_t *info)\r\n{\r\nvolatile QUICC *cp;\r\nushort chan;\r\nint idx;\r\ncp = pquicc;\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC)\r\nchan = scc_chan_map[idx];\r\nelse\r\nchan = smc_chan_map[idx];\r\ncp->cp_cr = mk_cr_cmd(chan, CPM_CR_RESTART_TX) | CPM_CR_FLG;\r\nwhile (cp->cp_cr & CPM_CR_FLG);\r\n}\r\nstatic void send_break(ser_info_t *info, unsigned int duration)\r\n{\r\n#ifdef SERIAL_DEBUG_SEND_BREAK\r\nprintk("rs_send_break(%d) jiff=%lu...", duration, jiffies);\r\n#endif\r\nbegin_break(info);\r\nmsleep_interruptible(duration);\r\nend_break(info);\r\n#ifdef SERIAL_DEBUG_SEND_BREAK\r\nprintk("done jiffies=%lu\n", jiffies);\r\n#endif\r\n}\r\nstatic int rs_360_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nstruct async_icount cnow;\r\nlocal_irq_disable();\r\ncnow = info->state->icount;\r\nlocal_irq_enable();\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nreturn 0;\r\n}\r\nstatic int rs_360_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint error;\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nint retval;\r\nstruct async_icount cnow;\r\nstruct serial_icounter_struct *p_cuser;\r\nif (serial_paranoia_check(info, tty->name, "rs_ioctl"))\r\nreturn -ENODEV;\r\nif (cmd != TIOCMIWAIT) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TCSBRK:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\ntty_wait_until_sent(tty, 0);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (!arg) {\r\nsend_break(info, 250);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\nreturn 0;\r\ncase TCSBRKP:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\ntty_wait_until_sent(tty, 0);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nsend_break(info, arg ? arg*100 : 250);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nreturn 0;\r\ncase TIOCSBRK:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\ntty_wait_until_sent(tty, 0);\r\nbegin_break(info);\r\nreturn 0;\r\ncase TIOCCBRK:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\nend_break(info);\r\nreturn 0;\r\n#ifdef maybe\r\ncase TIOCSERGETLSR:\r\nreturn get_lsr_info(info, (unsigned int *) arg);\r\n#endif\r\ncase TIOCMIWAIT:\r\n#ifdef modem_control\r\nlocal_irq_disable();\r\ncprev = info->state->icount;\r\nlocal_irq_enable();\r\nwhile (1) {\r\ninterruptible_sleep_on(&info->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nlocal_irq_disable();\r\ncnow = info->state->icount;\r\nlocal_irq_enable();\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts)\r\nreturn -EIO;\r\nif ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {\r\nreturn 0;\r\n}\r\ncprev = cnow;\r\n}\r\n#else\r\nreturn 0;\r\n#endif\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rs_360_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nchange_speed(info);\r\n#ifdef modem_control\r\nif ((old_termios->c_cflag & CBAUD) &&\r\n!(tty->termios->c_cflag & CBAUD)) {\r\ninfo->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);\r\nlocal_irq_disable();\r\nserial_out(info, UART_MCR, info->MCR);\r\nlocal_irq_enable();\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) &&\r\n(tty->termios->c_cflag & CBAUD)) {\r\ninfo->MCR |= UART_MCR_DTR;\r\nif (!tty->hw_stopped ||\r\n!(tty->termios->c_cflag & CRTSCTS)) {\r\ninfo->MCR |= UART_MCR_RTS;\r\n}\r\nlocal_irq_disable();\r\nserial_out(info, UART_MCR, info->MCR);\r\nlocal_irq_enable();\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios->c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\nrs_360_start(tty);\r\n}\r\n#endif\r\n#if 0\r\nif (!(old_termios->c_cflag & CLOCAL) &&\r\n(tty->termios->c_cflag & CLOCAL))\r\nwake_up_interruptible(&info->open_wait);\r\n#endif\r\n}\r\nstatic void rs_360_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nstruct serial_state *state;\r\nunsigned long flags;\r\nint idx;\r\nvolatile struct smc_regs *smcp;\r\nvolatile struct scc_regs *sccp;\r\nif (!info || serial_paranoia_check(info, tty->name, "rs_close"))\r\nreturn;\r\nstate = info->state;\r\nlocal_irq_save(flags);\r\nif (tty_hung_up_p(filp)) {\r\nDBG_CNT("before DEC-hung");\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_close ttys%d, count = %d\n", info->line, state->count);\r\n#endif\r\nif ((tty->count == 1) && (state->count != 1)) {\r\nprintk("rs_close: bad serial port count; tty->count is 1, "\r\n"state->count is %d\n", state->count);\r\nstate->count = 1;\r\n}\r\nif (--state->count < 0) {\r\nprintk("rs_close: bad serial port count for ttys%d: %d\n",\r\ninfo->line, state->count);\r\nstate->count = 0;\r\n}\r\nif (state->count) {\r\nDBG_CNT("before DEC-2");\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\ninfo->flags |= ASYNC_CLOSING;\r\ntty->closing = 1;\r\nif (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)\r\ntty_wait_until_sent(tty, info->closing_wait);\r\ninfo->read_status_mask &= ~BD_SC_EMPTY;\r\nif (info->flags & ASYNC_INITIALIZED) {\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC) {\r\nsccp = &pquicc->scc_regs[idx];\r\nsccp->scc_sccm &= ~UART_SCCM_RX;\r\nsccp->scc_gsmr.w.low &= ~SCC_GSMRL_ENR;\r\n} else {\r\nsmcp = &pquicc->smc_regs[idx];\r\nsmcp->smc_smcm &= ~SMCM_RX;\r\nsmcp->smc_smcmr &= ~SMCMR_REN;\r\n}\r\nrs_360_wait_until_sent(tty, info->timeout);\r\n}\r\nshutdown(info);\r\nrs_360_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\ntty->closing = 0;\r\ninfo->event = 0;\r\ninfo->port.tty = NULL;\r\nif (info->blocked_open) {\r\nif (info->close_delay) {\r\nmsleep_interruptible(jiffies_to_msecs(info->close_delay));\r\n}\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\ninfo->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);\r\nwake_up_interruptible(&info->close_wait);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_360_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nvolatile QUICC_BD *bdp;\r\nif (serial_paranoia_check(info, tty->name, "rs_wait_until_sent"))\r\nreturn;\r\n#ifdef maybe\r\nif (info->state->type == PORT_UNKNOWN)\r\nreturn;\r\n#endif\r\norig_jiffies = jiffies;\r\nchar_time = 1;\r\nif (timeout)\r\nchar_time = min(char_time, (unsigned long)timeout);\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("In rs_wait_until_sent(%d) check=%lu...", timeout, char_time);\r\nprintk("jiff=%lu...", jiffies);\r\n#endif\r\ndo {\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("lsr = %d (jiff=%lu)...", lsr, jiffies);\r\n#endif\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && (time_after(jiffies, orig_jiffies + timeout)))\r\nbreak;\r\nbdp = info->tx_cur;\r\nif (bdp == info->tx_bd_base)\r\nbdp += (TX_NUM_FIFO-1);\r\nelse\r\nbdp--;\r\n} while (bdp->status & BD_SC_READY);\r\ncurrent->state = TASK_RUNNING;\r\n#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT\r\nprintk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);\r\n#endif\r\n}\r\nstatic void rs_360_hangup(struct tty_struct *tty)\r\n{\r\nser_info_t *info = (ser_info_t *)tty->driver_data;\r\nstruct serial_state *state = info->state;\r\nif (serial_paranoia_check(info, tty->name, "rs_hangup"))\r\nreturn;\r\nstate = info->state;\r\nrs_360_flush_buffer(tty);\r\nshutdown(info);\r\ninfo->event = 0;\r\nstate->count = 0;\r\ninfo->flags &= ~ASYNC_NORMAL_ACTIVE;\r\ninfo->port.tty = NULL;\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\nstatic int block_til_ready(struct tty_struct *tty, struct file * filp,\r\nser_info_t *info)\r\n{\r\n#ifdef DO_THIS_LATER\r\nDECLARE_WAITQUEUE(wait, current);\r\n#endif\r\nstruct serial_state *state = info->state;\r\nint retval;\r\nint do_clocal = 0;\r\nif (tty_hung_up_p(filp) ||\r\n(info->flags & ASYNC_CLOSING)) {\r\nif (info->flags & ASYNC_CLOSING)\r\ninterruptible_sleep_on(&info->close_wait);\r\n#ifdef SERIAL_DO_RESTART\r\nif (info->flags & ASYNC_HUP_NOTIFY)\r\nreturn -EAGAIN;\r\nelse\r\nreturn -ERESTARTSYS;\r\n#else\r\nreturn -EAGAIN;\r\n#endif\r\n}\r\nif ((filp->f_flags & O_NONBLOCK) ||\r\n(tty->flags & (1 << TTY_IO_ERROR)) ||\r\n!(info->state->smc_scc_num & NUM_IS_SCC)) {\r\ninfo->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nif (tty->termios->c_cflag & CLOCAL)\r\ndo_clocal = 1;\r\nretval = 0;\r\n#ifdef DO_THIS_LATER\r\nadd_wait_queue(&info->open_wait, &wait);\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready before block: ttys%d, count = %d\n",\r\nstate->line, state->count);\r\n#endif\r\nlocal_irq_disable();\r\nif (!tty_hung_up_p(filp))\r\nstate->count--;\r\nlocal_irq_enable();\r\ninfo->blocked_open++;\r\nwhile (1) {\r\nlocal_irq_disable();\r\nif (tty->termios->c_cflag & CBAUD)\r\nserial_out(info, UART_MCR,\r\nserial_inp(info, UART_MCR) |\r\n(UART_MCR_DTR | UART_MCR_RTS));\r\nlocal_irq_enable();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (tty_hung_up_p(filp) ||\r\n!(info->flags & ASYNC_INITIALIZED)) {\r\n#ifdef SERIAL_DO_RESTART\r\nif (info->flags & ASYNC_HUP_NOTIFY)\r\nretval = -EAGAIN;\r\nelse\r\nretval = -ERESTARTSYS;\r\n#else\r\nretval = -EAGAIN;\r\n#endif\r\nbreak;\r\n}\r\nif (!(info->flags & ASYNC_CLOSING) &&\r\n(do_clocal || (serial_in(info, UART_MSR) &\r\nUART_MSR_DCD)))\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready blocking: ttys%d, count = %d\n",\r\ninfo->line, state->count);\r\n#endif\r\ntty_unlock();\r\nschedule();\r\ntty_lock();\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&info->open_wait, &wait);\r\nif (!tty_hung_up_p(filp))\r\nstate->count++;\r\ninfo->blocked_open--;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready after blocking: ttys%d, count = %d\n",\r\ninfo->line, state->count);\r\n#endif\r\n#endif\r\nif (retval)\r\nreturn retval;\r\ninfo->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int get_async_struct(int line, ser_info_t **ret_info)\r\n{\r\nstruct serial_state *sstate;\r\nsstate = rs_table + line;\r\nif (sstate->info) {\r\nsstate->count++;\r\n*ret_info = (ser_info_t *)sstate->info;\r\nreturn 0;\r\n}\r\nelse {\r\nreturn -ENOMEM;\r\n}\r\n}\r\nstatic int rs_360_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nser_info_t *info;\r\nint retval, line;\r\nline = tty->index;\r\nif ((line < 0) || (line >= NR_PORTS))\r\nreturn -ENODEV;\r\nretval = get_async_struct(line, &info);\r\nif (retval)\r\nreturn retval;\r\nif (serial_paranoia_check(info, tty->name, "rs_open"))\r\nreturn -ENODEV;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open %s, count = %d\n", tty->name, info->state->count);\r\n#endif\r\ntty->driver_data = info;\r\ninfo->port.tty = tty;\r\nretval = startup(info);\r\nif (retval)\r\nreturn retval;\r\nretval = block_til_ready(tty, filp, info);\r\nif (retval) {\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open returning after block_til_ready with %d\n",\r\nretval);\r\n#endif\r\nreturn retval;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open %s successful...", tty->name);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline int line_info(char *buf, struct serial_state *state)\r\n{\r\n#ifdef notdef\r\nstruct async_struct *info = state->info, scr_info;\r\nchar stat_buf[30], control, status;\r\n#endif\r\nint ret;\r\nret = sprintf(buf, "%d: uart:%s port:%X irq:%d",\r\nstate->line,\r\n(state->smc_scc_num & NUM_IS_SCC) ? "SCC" : "SMC",\r\n(unsigned int)(state->port), state->irq);\r\nif (!state->port || (state->type == PORT_UNKNOWN)) {\r\nret += sprintf(buf+ret, "\n");\r\nreturn ret;\r\n}\r\n#ifdef notdef\r\nif (!info) {\r\ninfo = &scr_info;\r\ninfo->magic = SERIAL_MAGIC;\r\ninfo->port = state->port;\r\ninfo->flags = state->flags;\r\ninfo->quot = 0;\r\ninfo->port.tty = NULL;\r\n}\r\nlocal_irq_disable();\r\nstatus = serial_in(info, UART_MSR);\r\ncontrol = info ? info->MCR : serial_in(info, UART_MCR);\r\nlocal_irq_enable();\r\nstat_buf[0] = 0;\r\nstat_buf[1] = 0;\r\nif (control & UART_MCR_RTS)\r\nstrcat(stat_buf, "|RTS");\r\nif (status & UART_MSR_CTS)\r\nstrcat(stat_buf, "|CTS");\r\nif (control & UART_MCR_DTR)\r\nstrcat(stat_buf, "|DTR");\r\nif (status & UART_MSR_DSR)\r\nstrcat(stat_buf, "|DSR");\r\nif (status & UART_MSR_DCD)\r\nstrcat(stat_buf, "|CD");\r\nif (status & UART_MSR_RI)\r\nstrcat(stat_buf, "|RI");\r\nif (info->quot) {\r\nret += sprintf(buf+ret, " baud:%d",\r\nstate->baud_base / info->quot);\r\n}\r\nret += sprintf(buf+ret, " tx:%d rx:%d",\r\nstate->icount.tx, state->icount.rx);\r\nif (state->icount.frame)\r\nret += sprintf(buf+ret, " fe:%d", state->icount.frame);\r\nif (state->icount.parity)\r\nret += sprintf(buf+ret, " pe:%d", state->icount.parity);\r\nif (state->icount.brk)\r\nret += sprintf(buf+ret, " brk:%d", state->icount.brk);\r\nif (state->icount.overrun)\r\nret += sprintf(buf+ret, " oe:%d", state->icount.overrun);\r\nret += sprintf(buf+ret, " %s\n", stat_buf+1);\r\n#endif\r\nreturn ret;\r\n}\r\nint rs_360_read_proc(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nint i, len = 0;\r\noff_t begin = 0;\r\nlen += sprintf(page, "serinfo:1.0 driver:%s\n", serial_version);\r\nfor (i = 0; i < NR_PORTS && len < 4000; i++) {\r\nlen += line_info(page + len, &rs_table[i]);\r\nif (len+begin > off+count)\r\ngoto done;\r\nif (len+begin < off) {\r\nbegin += len;\r\nlen = 0;\r\n}\r\n}\r\n*eof = 1;\r\ndone:\r\nif (off >= len+begin)\r\nreturn 0;\r\n*start = page + (begin-off);\r\nreturn ((count < begin+len-off) ? count : begin+len-off);\r\n}\r\nstatic _INLINE_ void show_serial_version(void)\r\n{\r\nprintk(KERN_INFO "%s version %s\n", serial_name, serial_version);\r\n}\r\nstatic void my_console_write(int idx, const char *s,\r\nunsigned count)\r\n{\r\nstruct serial_state *ser;\r\nser_info_t *info;\r\nunsigned i;\r\nQUICC_BD *bdp, *bdbase;\r\nvolatile struct smc_uart_pram *up;\r\nvolatile u_char *cp;\r\nser = rs_table + idx;\r\nif ((info = (ser_info_t *)ser->info) != NULL) {\r\nbdp = info->tx_cur;\r\nbdbase = info->tx_bd_base;\r\n}\r\nelse {\r\nup = &pquicc->pram[ser->port].scc.pothers.idma_smc.psmc.u;\r\nbdp = bdbase = (QUICC_BD *)((uint)pquicc + (uint)up->tbase);\r\n}\r\nfor (i = 0; i < count; i++, s++) {\r\nwhile (bdp->status & BD_SC_READY);\r\ncp = bdp->buf;\r\n*cp = *s;\r\nbdp->length = 1;\r\nbdp->status |= BD_SC_READY;\r\nif (bdp->status & BD_SC_WRAP)\r\nbdp = bdbase;\r\nelse\r\nbdp++;\r\nif (*s == 10) {\r\nwhile (bdp->status & BD_SC_READY);\r\ncp = bdp->buf;\r\n*cp = 13;\r\nbdp->length = 1;\r\nbdp->status |= BD_SC_READY;\r\nif (bdp->status & BD_SC_WRAP) {\r\nbdp = bdbase;\r\n}\r\nelse {\r\nbdp++;\r\n}\r\n}\r\n}\r\nwhile (bdp->status & BD_SC_READY);\r\nif (info)\r\ninfo->tx_cur = (QUICC_BD *)bdp;\r\n}\r\nstatic void serial_console_write(struct console *c, const char *s,\r\nunsigned count)\r\n{\r\n#ifdef CONFIG_KGDB\r\nif (kgdb_output_string(s, count))\r\nreturn;\r\n#endif\r\nmy_console_write(c->index, s, count);\r\n}\r\nint\r\nxmon_360_write(const char *s, unsigned count)\r\n{\r\nmy_console_write(0, s, count);\r\nreturn(count);\r\n}\r\nvoid\r\nputDebugChar(char ch)\r\n{\r\nmy_console_write(0, &ch, 1);\r\n}\r\nstatic int my_console_wait_key(int idx, int xmon, char *obuf)\r\n{\r\nstruct serial_state *ser;\r\nu_char c, *cp;\r\nser_info_t *info;\r\nQUICC_BD *bdp;\r\nvolatile struct smc_uart_pram *up;\r\nint i;\r\nser = rs_table + idx;\r\nif ((info = (ser_info_t *)ser->info))\r\nbdp = info->rx_cur;\r\nelse\r\nbdp = (QUICC_BD *)((uint)pquicc + (uint)up->tbase);\r\nup = &pquicc->pram[info->state->port].scc.pothers.idma_smc.psmc.u;\r\nif (!xmon) {\r\nwhile (bdp->status & BD_SC_EMPTY);\r\n}\r\nelse {\r\nif (bdp->status & BD_SC_EMPTY)\r\nreturn -1;\r\n}\r\ncp = (char *)bdp->buf;\r\nif (obuf) {\r\ni = c = bdp->length;\r\nwhile (i-- > 0)\r\n*obuf++ = *cp++;\r\n}\r\nelse {\r\nc = *cp;\r\n}\r\nbdp->status |= BD_SC_EMPTY;\r\nif (info) {\r\nif (bdp->status & BD_SC_WRAP) {\r\nbdp = info->rx_bd_base;\r\n}\r\nelse {\r\nbdp++;\r\n}\r\ninfo->rx_cur = (QUICC_BD *)bdp;\r\n}\r\nreturn((int)c);\r\n}\r\nstatic int serial_console_wait_key(struct console *co)\r\n{\r\nreturn(my_console_wait_key(co->index, 0, NULL));\r\n}\r\nint\r\nxmon_360_read_poll(void)\r\n{\r\nreturn(my_console_wait_key(0, 1, NULL));\r\n}\r\nint\r\nxmon_360_read_char(void)\r\n{\r\nreturn(my_console_wait_key(0, 0, NULL));\r\n}\r\nunsigned char\r\ngetDebugChar(void)\r\n{\r\nif (kgdb_chars <= 0) {\r\nkgdb_chars = my_console_wait_key(0, 0, kgdb_buf);\r\nkgdp = kgdb_buf;\r\n}\r\nkgdb_chars--;\r\nreturn(*kgdp++);\r\n}\r\nvoid kgdb_interruptible(int state)\r\n{\r\n}\r\nvoid kgdb_map_scc(void)\r\n{\r\nstruct serial_state *ser;\r\nuint mem_addr;\r\nvolatile QUICC_BD *bdp;\r\nvolatile smc_uart_t *up;\r\ncpmp = (cpm360_t *)&(((immap_t *)IMAP_ADDR)->im_cpm);\r\nser = rs_table;\r\nup = (smc_uart_t *)&cpmp->cp_dparam[ser->port];\r\nmem_addr = (uint)(&cpmp->cp_dpmem[0x1000]);\r\nbdp = (QUICC_BD *)&cpmp->cp_dpmem[up->smc_rbase];\r\nbdp->buf = mem_addr;\r\nbdp = (QUICC_BD *)&cpmp->cp_dpmem[up->smc_tbase];\r\nbdp->buf = mem_addr+RX_BUF_SIZE;\r\nup->smc_mrblr = RX_BUF_SIZE;\r\nup->smc_maxidl = RX_BUF_SIZE;\r\n}\r\nstatic struct tty_struct *serial_console_device(struct console *c, int *index)\r\n{\r\n*index = c->index;\r\nreturn serial_driver;\r\n}\r\nlong console_360_init(long kmem_start, long kmem_end)\r\n{\r\nregister_console(&sercons);\r\nreturn kmem_start;\r\n}\r\nstatic int __init rs_360_init(void)\r\n{\r\nstruct serial_state * state;\r\nser_info_t *info;\r\nvoid *mem_addr;\r\nuint dp_addr, iobits;\r\nint i, j, idx;\r\nushort chan;\r\nQUICC_BD *bdp;\r\nvolatile QUICC *cp;\r\nvolatile struct smc_regs *sp;\r\nvolatile struct smc_uart_pram *up;\r\nvolatile struct scc_regs *scp;\r\nvolatile struct uart_pram *sup;\r\nserial_driver = alloc_tty_driver(NR_PORTS);\r\nif (!serial_driver)\r\nreturn -1;\r\nshow_serial_version();\r\nserial_driver->name = "ttyS";\r\nserial_driver->major = TTY_MAJOR;\r\nserial_driver->minor_start = 64;\r\nserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nserial_driver->init_termios = tty_std_termios;\r\nserial_driver->init_termios.c_cflag =\r\nbaud_idx | CS8 | CREAD | HUPCL | CLOCAL;\r\nserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(serial_driver, &rs_360_ops);\r\nif (tty_register_driver(serial_driver))\r\npanic("Couldn't register serial driver\n");\r\ncp = pquicc;\r\ncp->pio_papar |= 0x00fc;\r\ncp->pio_padir &= ~0x00fc;\r\ncp->si_sicr &= ~0x00ffff00;\r\ncp->si_sicr |= 0x001b1200;\r\n#ifdef CONFIG_PP04\r\nimmap->im_ioport.iop_pcdir |= 0x000c;\r\nimmap->im_ioport.iop_pcpar &= ~0x000c;\r\nimmap->im_ioport.iop_pcdat &= ~0x000c;\r\ncp->cp_pbpar &= ~0x6000;\r\ncp->cp_pbdat &= ~0x6000;\r\n#endif\r\nfor (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {\r\nstate->magic = SSTATE_MAGIC;\r\nstate->line = i;\r\nstate->type = PORT_UNKNOWN;\r\nstate->custom_divisor = 0;\r\nstate->close_delay = 5*HZ/10;\r\nstate->closing_wait = 30*HZ;\r\nstate->icount.cts = state->icount.dsr =\r\nstate->icount.rng = state->icount.dcd = 0;\r\nstate->icount.rx = state->icount.tx = 0;\r\nstate->icount.frame = state->icount.parity = 0;\r\nstate->icount.overrun = state->icount.brk = 0;\r\nprintk(KERN_INFO "ttyS%d at irq 0x%02x is an %s\n",\r\ni, (unsigned int)(state->irq),\r\n(state->smc_scc_num & NUM_IS_SCC) ? "SCC" : "SMC");\r\n#ifdef CONFIG_SERIAL_CONSOLE\r\nif (i == CONFIG_SERIAL_CONSOLE_PORT)\r\nmdelay(8);\r\n#endif\r\ninfo = &quicc_ser_info[i];\r\nif (info) {\r\nmemset (info, 0, sizeof(ser_info_t));\r\ninfo->magic = SERIAL_MAGIC;\r\ninfo->line = i;\r\ninfo->flags = state->flags;\r\nINIT_WORK(&info->tqueue, do_softint, info);\r\nINIT_WORK(&info->tqueue_hangup, do_serial_hangup, info);\r\ninit_waitqueue_head(&info->open_wait);\r\ninit_waitqueue_head(&info->close_wait);\r\ninfo->state = state;\r\nstate->info = (struct async_struct *)info;\r\ndp_addr = m360_cpm_dpalloc(sizeof(QUICC_BD) * RX_NUM_FIFO);\r\nmem_addr = &rx_buf_pool[i * RX_NUM_FIFO * RX_BUF_SIZE];\r\nbdp = (QUICC_BD *)((uint)pquicc + dp_addr);\r\ninfo->rx_cur = info->rx_bd_base = bdp;\r\nfor (j=0; j<(RX_NUM_FIFO-1); j++) {\r\nbdp->buf = &rx_buf_pool[(i * RX_NUM_FIFO + j ) * RX_BUF_SIZE];\r\nbdp->status = BD_SC_EMPTY | BD_SC_INTRPT;\r\nmem_addr += RX_BUF_SIZE;\r\nbdp++;\r\n}\r\nbdp->buf = &rx_buf_pool[(i * RX_NUM_FIFO + j ) * RX_BUF_SIZE];\r\nbdp->status = BD_SC_WRAP | BD_SC_EMPTY | BD_SC_INTRPT;\r\nidx = PORT_NUM(info->state->smc_scc_num);\r\nif (info->state->smc_scc_num & NUM_IS_SCC) {\r\n#if defined (CONFIG_UCQUICC) && 1\r\nsipex_mode_bits &= ~(uint)SIPEX_MODE(idx,0x0f);\r\nsipex_mode_bits |= (uint)SIPEX_MODE(idx,0x02);\r\n*(uint *)_periph_base = sipex_mode_bits;\r\n#endif\r\n}\r\ndp_addr = m360_cpm_dpalloc(sizeof(QUICC_BD) * TX_NUM_FIFO);\r\nmem_addr = &tx_buf_pool[i * TX_NUM_FIFO * TX_BUF_SIZE];\r\nbdp = (QUICC_BD *)((uint)pquicc + dp_addr);\r\ninfo->tx_cur = info->tx_bd_base = (QUICC_BD *)bdp;\r\nfor (j=0; j<(TX_NUM_FIFO-1); j++) {\r\nbdp->buf = &tx_buf_pool[(i * TX_NUM_FIFO + j ) * TX_BUF_SIZE];\r\nbdp->status = BD_SC_INTRPT;\r\nmem_addr += TX_BUF_SIZE;\r\nbdp++;\r\n}\r\nbdp->buf = &tx_buf_pool[(i * TX_NUM_FIFO + j ) * TX_BUF_SIZE];\r\nbdp->status = (BD_SC_WRAP | BD_SC_INTRPT);\r\nif (info->state->smc_scc_num & NUM_IS_SCC) {\r\nscp = &pquicc->scc_regs[idx];\r\nsup = &pquicc->pram[info->state->port].scc.pscc.u;\r\nsup->rbase = dp_addr;\r\nsup->tbase = dp_addr;\r\nsup->rfcr = SMC_EB;\r\nsup->tfcr = SMC_EB;\r\nsup->mrblr = 1;\r\nsup->max_idl = 0;\r\nsup->brkcr = 1;\r\nsup->parec = 0;\r\nsup->frmer = 0;\r\nsup->nosec = 0;\r\nsup->brkec = 0;\r\nsup->uaddr1 = 0;\r\nsup->uaddr2 = 0;\r\nsup->toseq = 0;\r\n{\r\nint i;\r\nfor (i=0;i<8;i++)\r\nsup->cc[i] = 0x8000;\r\n}\r\nsup->rccm = 0xc0ff;\r\nchan = scc_chan_map[idx];\r\ncp->cp_cr = mk_cr_cmd(chan, CPM_CR_INIT_TRX) | CPM_CR_FLG;\r\nwhile (cp->cp_cr & CPM_CR_FLG);\r\nscp->scc_gsmr.w.high = 0;\r\nscp->scc_gsmr.w.low =\r\n(SCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);\r\nscp->scc_sccm = 0;\r\nscp->scc_scce = 0xffff;\r\nscp->scc_dsr = 0x7e7e;\r\nscp->scc_psmr = 0x3000;\r\n#ifdef CONFIG_SERIAL_CONSOLE\r\nif (i == CONFIG_SERIAL_CONSOLE_PORT)\r\nscp->scc_gsmr.w.low |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n#endif\r\n}\r\nelse {\r\nup = &pquicc->pram[info->state->port].scc.pothers.idma_smc.psmc.u;\r\nup->rbase = dp_addr;\r\niobits = 0xc0 << (idx * 4);\r\ncp->pip_pbpar |= iobits;\r\ncp->pip_pbdir &= ~iobits;\r\ncp->pip_pbodr &= ~iobits;\r\ncp->si_simode &= ~(0xffff << (idx * 16));\r\ncp->si_simode |= (i << ((idx * 16) + 12));\r\nup->tbase = dp_addr;\r\nup->rfcr = SMC_EB;\r\nup->tfcr = SMC_EB;\r\nup->mrblr = 1;\r\nup->max_idl = 0;\r\nup->brkcr = 1;\r\nchan = smc_chan_map[idx];\r\ncp->cp_cr = mk_cr_cmd(chan,\r\nCPM_CR_INIT_TRX) | CPM_CR_FLG;\r\n#ifdef CONFIG_SERIAL_CONSOLE\r\nif (i == CONFIG_SERIAL_CONSOLE_PORT)\r\nprintk("");\r\n#endif\r\nwhile (cp->cp_cr & CPM_CR_FLG);\r\nsp = &cp->smc_regs[idx];\r\nsp->smc_smcmr = smcr_mk_clen(9) | SMCMR_SM_UART;\r\nsp->smc_smcm = 0;\r\nsp->smc_smce = 0xff;\r\n#ifdef CONFIG_SERIAL_CONSOLE\r\nif (i == CONFIG_SERIAL_CONSOLE_PORT)\r\nsp->smc_smcmr |= SMCMR_REN | SMCMR_TEN;\r\n#endif\r\n}\r\nrequest_irq(state->irq, rs_360_interrupt,\r\nIRQ_FLG_LOCK, "ttyS", (void *)info);\r\nm360_cpm_setbrg(i, baud_table[baud_idx]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint serial_console_setup( struct console *co, char *options)\r\n{\r\nstruct serial_state *ser;\r\nuint mem_addr, dp_addr, bidx, idx, iobits;\r\nushort chan;\r\nQUICC_BD *bdp;\r\nvolatile QUICC *cp;\r\nvolatile struct smc_regs *sp;\r\nvolatile struct scc_regs *scp;\r\nvolatile struct smc_uart_pram *up;\r\nvolatile struct uart_pram *sup;\r\nfor (bidx = 0; bidx < (sizeof(baud_table) / sizeof(int)); bidx++)\r\nif (CONSOLE_BAUDRATE == baud_table[bidx])\r\nbreak;\r\nbaud_idx = bidx;\r\nser = rs_table + CONFIG_SERIAL_CONSOLE_PORT;\r\ncp = pquicc;\r\nidx = PORT_NUM(ser->smc_scc_num);\r\nif (ser->smc_scc_num & NUM_IS_SCC) {\r\n}\r\nelse {\r\niobits = 0xc0 << (idx * 4);\r\ncp->pip_pbpar |= iobits;\r\ncp->pip_pbdir &= ~iobits;\r\ncp->pip_pbodr &= ~iobits;\r\ncp->si_simode &= ~(0xffff << (idx * 16));\r\ncp->si_simode |= (idx << ((idx * 16) + 12));\r\n}\r\ndp_addr = m360_cpm_dpalloc(sizeof(QUICC_BD) * CONSOLE_NUM_FIFO);\r\nmem_addr = (uint)console_fifos;\r\nbdp = (QUICC_BD *)((uint)pquicc + dp_addr);\r\nbdp->buf = (char *)mem_addr;\r\n(bdp+1)->buf = (char *)(mem_addr+4);\r\nbdp->status = BD_SC_EMPTY | BD_SC_WRAP;\r\n(bdp+1)->status = BD_SC_WRAP;\r\nif (ser->smc_scc_num & NUM_IS_SCC) {\r\nscp = &cp->scc_regs[idx];\r\nsup = &pquicc->pram[ser->port].scc.pscc.u;\r\nsup->rbase = dp_addr;\r\nsup->tbase = dp_addr + sizeof(QUICC_BD);\r\nsup->rfcr = SMC_EB;\r\nsup->tfcr = SMC_EB;\r\nsup->mrblr = 1;\r\nsup->max_idl = 0;\r\nsup->brkcr = 1;\r\nsup->parec = 0;\r\nsup->frmer = 0;\r\nsup->nosec = 0;\r\nsup->brkec = 0;\r\nsup->uaddr1 = 0;\r\nsup->uaddr2 = 0;\r\nsup->toseq = 0;\r\n{\r\nint i;\r\nfor (i=0;i<8;i++)\r\nsup->cc[i] = 0x8000;\r\n}\r\nsup->rccm = 0xc0ff;\r\nchan = scc_chan_map[idx];\r\ncp->cp_cr = mk_cr_cmd(chan, CPM_CR_INIT_TRX) | CPM_CR_FLG;\r\nwhile (cp->cp_cr & CPM_CR_FLG);\r\nscp->scc_gsmr.w.high = 0;\r\nscp->scc_gsmr.w.low =\r\n(SCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);\r\nscp->scc_sccm = 0;\r\nscp->scc_scce = 0xffff;\r\nscp->scc_dsr = 0x7e7e;\r\nscp->scc_psmr = 0x3000;\r\nscp->scc_gsmr.w.low |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n}\r\nelse {\r\nup = &pquicc->pram[ser->port].scc.pothers.idma_smc.psmc.u;\r\nup->rbase = dp_addr;\r\nup->tbase = dp_addr+sizeof(QUICC_BD);\r\nup->rfcr = SMC_EB;\r\nup->tfcr = SMC_EB;\r\nup->mrblr = 1;\r\nup->max_idl = 0;\r\nchan = smc_chan_map[idx];\r\ncp->cp_cr = mk_cr_cmd(chan, CPM_CR_INIT_TRX) | CPM_CR_FLG;\r\nwhile (cp->cp_cr & CPM_CR_FLG);\r\nsp = &cp->smc_regs[idx];\r\nsp->smc_smcmr = smcr_mk_clen(9) | SMCMR_SM_UART;\r\nsp->smc_smcmr |= SMCMR_REN | SMCMR_TEN;\r\n}\r\nm360_cpm_setbrg((ser - rs_table), CONSOLE_BAUDRATE);\r\nreturn 0;\r\n}
