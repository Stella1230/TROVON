static struct thread *thread__new(pid_t pid)\r\n{\r\nstruct thread *self = zalloc(sizeof(*self));\r\nif (self != NULL) {\r\nmap_groups__init(&self->mg);\r\nself->pid = pid;\r\nself->comm = malloc(32);\r\nif (self->comm)\r\nsnprintf(self->comm, 32, ":%d", self->pid);\r\n}\r\nreturn self;\r\n}\r\nvoid thread__delete(struct thread *self)\r\n{\r\nmap_groups__exit(&self->mg);\r\nfree(self->comm);\r\nfree(self);\r\n}\r\nint thread__set_comm(struct thread *self, const char *comm)\r\n{\r\nint err;\r\nif (self->comm)\r\nfree(self->comm);\r\nself->comm = strdup(comm);\r\nerr = self->comm == NULL ? -ENOMEM : 0;\r\nif (!err) {\r\nself->comm_set = true;\r\nmap_groups__flush(&self->mg);\r\n}\r\nreturn err;\r\n}\r\nint thread__comm_len(struct thread *self)\r\n{\r\nif (!self->comm_len) {\r\nif (!self->comm)\r\nreturn 0;\r\nself->comm_len = strlen(self->comm);\r\n}\r\nreturn self->comm_len;\r\n}\r\nstatic size_t thread__fprintf(struct thread *self, FILE *fp)\r\n{\r\nreturn fprintf(fp, "Thread %d %s\n", self->pid, self->comm) +\r\nmap_groups__fprintf(&self->mg, verbose, fp);\r\n}\r\nstruct thread *perf_session__findnew(struct perf_session *self, pid_t pid)\r\n{\r\nstruct rb_node **p = &self->threads.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct thread *th;\r\nif (self->last_match && self->last_match->pid == pid)\r\nreturn self->last_match;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nth = rb_entry(parent, struct thread, rb_node);\r\nif (th->pid == pid) {\r\nself->last_match = th;\r\nreturn th;\r\n}\r\nif (pid < th->pid)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nth = thread__new(pid);\r\nif (th != NULL) {\r\nrb_link_node(&th->rb_node, parent, p);\r\nrb_insert_color(&th->rb_node, &self->threads);\r\nself->last_match = th;\r\n}\r\nreturn th;\r\n}\r\nvoid thread__insert_map(struct thread *self, struct map *map)\r\n{\r\nmap_groups__fixup_overlappings(&self->mg, map, verbose, stderr);\r\nmap_groups__insert(&self->mg, map);\r\n}\r\nint thread__fork(struct thread *self, struct thread *parent)\r\n{\r\nint i;\r\nif (parent->comm_set) {\r\nif (self->comm)\r\nfree(self->comm);\r\nself->comm = strdup(parent->comm);\r\nif (!self->comm)\r\nreturn -ENOMEM;\r\nself->comm_set = true;\r\n}\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nif (map_groups__clone(&self->mg, &parent->mg, i) < 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nsize_t perf_session__fprintf(struct perf_session *self, FILE *fp)\r\n{\r\nsize_t ret = 0;\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&self->threads); nd; nd = rb_next(nd)) {\r\nstruct thread *pos = rb_entry(nd, struct thread, rb_node);\r\nret += thread__fprintf(pos, fp);\r\n}\r\nreturn ret;\r\n}
