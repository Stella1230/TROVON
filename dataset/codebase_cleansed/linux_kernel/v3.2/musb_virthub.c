static void musb_port_suspend(struct musb *musb, bool do_suspend)\r\n{\r\nu8 power;\r\nvoid __iomem *mbase = musb->mregs;\r\nif (!is_host_active(musb))\r\nreturn;\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (do_suspend) {\r\nint retries = 10000;\r\npower &= ~MUSB_POWER_RESUME;\r\npower |= MUSB_POWER_SUSPENDM;\r\nmusb_writeb(mbase, MUSB_POWER, power);\r\npower = musb_readb(mbase, MUSB_POWER);\r\nwhile (power & MUSB_POWER_SUSPENDM) {\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (retries-- < 1)\r\nbreak;\r\n}\r\ndev_dbg(musb->controller, "Root port suspended, power %02x\n", power);\r\nmusb->port1_status |= USB_PORT_STAT_SUSPEND;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_HOST:\r\nmusb->xceiv->state = OTG_STATE_A_SUSPEND;\r\nmusb->is_active = is_otg_enabled(musb)\r\n&& musb->xceiv->host->b_hnp_enable;\r\nif (musb->is_active)\r\nmod_timer(&musb->otg_timer, jiffies\r\n+ msecs_to_jiffies(\r\nOTG_TIME_A_AIDL_BDIS));\r\nmusb_platform_try_idle(musb, 0);\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nmusb->xceiv->state = OTG_STATE_B_WAIT_ACON;\r\nmusb->is_active = is_otg_enabled(musb)\r\n&& musb->xceiv->host->b_hnp_enable;\r\nmusb_platform_try_idle(musb, 0);\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "bogus rh suspend? %s\n",\r\notg_state_string(musb->xceiv->state));\r\n}\r\n} else if (power & MUSB_POWER_SUSPENDM) {\r\npower &= ~MUSB_POWER_SUSPENDM;\r\npower |= MUSB_POWER_RESUME;\r\nmusb_writeb(mbase, MUSB_POWER, power);\r\ndev_dbg(musb->controller, "Root port resuming, power %02x\n", power);\r\nmusb->port1_status |= MUSB_PORT_STAT_RESUME;\r\nmusb->rh_timer = jiffies + msecs_to_jiffies(20);\r\n}\r\n}\r\nstatic void musb_port_reset(struct musb *musb, bool do_reset)\r\n{\r\nu8 power;\r\nvoid __iomem *mbase = musb->mregs;\r\nif (musb->xceiv->state == OTG_STATE_B_IDLE) {\r\ndev_dbg(musb->controller, "HNP: Returning from HNP; no hub reset from b_idle\n");\r\nmusb->port1_status &= ~USB_PORT_STAT_RESET;\r\nreturn;\r\n}\r\nif (!is_host_active(musb))\r\nreturn;\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (do_reset) {\r\nif (power & MUSB_POWER_RESUME) {\r\nwhile (time_before(jiffies, musb->rh_timer))\r\nmsleep(1);\r\nmusb_writeb(mbase, MUSB_POWER,\r\npower & ~MUSB_POWER_RESUME);\r\nmsleep(1);\r\n}\r\nmusb->ignore_disconnect = true;\r\npower &= 0xf0;\r\nmusb_writeb(mbase, MUSB_POWER,\r\npower | MUSB_POWER_RESET);\r\nmusb->port1_status |= USB_PORT_STAT_RESET;\r\nmusb->port1_status &= ~USB_PORT_STAT_ENABLE;\r\nmusb->rh_timer = jiffies + msecs_to_jiffies(50);\r\n} else {\r\ndev_dbg(musb->controller, "root port reset stopped\n");\r\nmusb_writeb(mbase, MUSB_POWER,\r\npower & ~MUSB_POWER_RESET);\r\nmusb->ignore_disconnect = false;\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (power & MUSB_POWER_HSMODE) {\r\ndev_dbg(musb->controller, "high-speed device connected\n");\r\nmusb->port1_status |= USB_PORT_STAT_HIGH_SPEED;\r\n}\r\nmusb->port1_status &= ~USB_PORT_STAT_RESET;\r\nmusb->port1_status |= USB_PORT_STAT_ENABLE\r\n| (USB_PORT_STAT_C_RESET << 16)\r\n| (USB_PORT_STAT_C_ENABLE << 16);\r\nusb_hcd_poll_rh_status(musb_to_hcd(musb));\r\nmusb->vbuserr_retry = VBUSERR_RETRY_COUNT;\r\n}\r\n}\r\nvoid musb_root_disconnect(struct musb *musb)\r\n{\r\nmusb->port1_status = USB_PORT_STAT_POWER\r\n| (USB_PORT_STAT_C_CONNECTION << 16);\r\nusb_hcd_poll_rh_status(musb_to_hcd(musb));\r\nmusb->is_active = 0;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_SUSPEND:\r\nif (is_otg_enabled(musb)\r\n&& musb->xceiv->host->b_hnp_enable) {\r\nmusb->xceiv->state = OTG_STATE_A_PERIPHERAL;\r\nmusb->g.is_a_peripheral = 1;\r\nbreak;\r\n}\r\ncase OTG_STATE_A_HOST:\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_BCON;\r\nmusb->is_active = 0;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "host disconnect (%s)\n",\r\notg_state_string(musb->xceiv->state));\r\n}\r\n}\r\nint musb_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nint retval = 0;\r\nif (musb->port1_status & 0xffff0000) {\r\n*buf = 0x02;\r\nretval = 1;\r\n}\r\nreturn retval;\r\n}\r\nint musb_hub_control(\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nu32 temp;\r\nint retval = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(hcd))) {\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif ((wIndex & 0xff) != 1)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nmusb_port_suspend(musb, false);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (!(is_otg_enabled(musb) && hcd->self.is_b_host))\r\nmusb_platform_set_vbus(musb, 0);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ncase USB_PORT_FEAT_C_RESET:\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\ndev_dbg(musb->controller, "clear feature %d\n", wValue);\r\nmusb->port1_status &= ~(1 << wValue);\r\nbreak;\r\ncase GetHubDescriptor:\r\n{\r\nstruct usb_hub_descriptor *desc = (void *)buf;\r\ndesc->bDescLength = 9;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bNbrPorts = 1;\r\ndesc->wHubCharacteristics = cpu_to_le16(\r\n0x0001\r\n| 0x0010\r\n);\r\ndesc->bPwrOn2PwrGood = 5;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->u.hs.DeviceRemovable[0] = 0x02;\r\ndesc->u.hs.DeviceRemovable[1] = 0xff;\r\n}\r\nbreak;\r\ncase GetHubStatus:\r\ntemp = 0;\r\n*(__le32 *) buf = cpu_to_le32(temp);\r\nbreak;\r\ncase GetPortStatus:\r\nif (wIndex != 1)\r\ngoto error;\r\nif ((musb->port1_status & USB_PORT_STAT_RESET)\r\n&& time_after_eq(jiffies, musb->rh_timer))\r\nmusb_port_reset(musb, false);\r\nif ((musb->port1_status & MUSB_PORT_STAT_RESUME)\r\n&& time_after_eq(jiffies, musb->rh_timer)) {\r\nu8 power;\r\npower = musb_readb(musb->mregs, MUSB_POWER);\r\npower &= ~MUSB_POWER_RESUME;\r\ndev_dbg(musb->controller, "root port resume stopped, power %02x\n",\r\npower);\r\nmusb_writeb(musb->mregs, MUSB_POWER, power);\r\nmusb->is_active = 1;\r\nmusb->port1_status &= ~(USB_PORT_STAT_SUSPEND\r\n| MUSB_PORT_STAT_RESUME);\r\nmusb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;\r\nusb_hcd_poll_rh_status(musb_to_hcd(musb));\r\nmusb->xceiv->state = OTG_STATE_A_HOST;\r\n}\r\nput_unaligned(cpu_to_le32(musb->port1_status\r\n& ~MUSB_PORT_STAT_RESUME),\r\n(__le32 *) buf);\r\ndev_dbg(musb->controller, "port status %08x\n",\r\nmusb->port1_status);\r\nbreak;\r\ncase SetPortFeature:\r\nif ((wIndex & 0xff) != 1)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_POWER:\r\nif (!(is_otg_enabled(musb) && hcd->self.is_b_host))\r\nmusb_start(musb);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nmusb_port_reset(musb, true);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nmusb_port_suspend(musb, true);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\nif (unlikely(is_host_active(musb)))\r\ngoto error;\r\nwIndex >>= 8;\r\nswitch (wIndex) {\r\ncase 1:\r\npr_debug("TEST_J\n");\r\ntemp = MUSB_TEST_J;\r\nbreak;\r\ncase 2:\r\npr_debug("TEST_K\n");\r\ntemp = MUSB_TEST_K;\r\nbreak;\r\ncase 3:\r\npr_debug("TEST_SE0_NAK\n");\r\ntemp = MUSB_TEST_SE0_NAK;\r\nbreak;\r\ncase 4:\r\npr_debug("TEST_PACKET\n");\r\ntemp = MUSB_TEST_PACKET;\r\nmusb_load_testpacket(musb);\r\nbreak;\r\ncase 5:\r\npr_debug("TEST_FORCE_ENABLE\n");\r\ntemp = MUSB_TEST_FORCE_HOST\r\n| MUSB_TEST_FORCE_HS;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL,\r\nMUSB_DEVCTL_SESSION);\r\nbreak;\r\ncase 6:\r\npr_debug("TEST_FIFO_ACCESS\n");\r\ntemp = MUSB_TEST_FIFO_ACCESS;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nmusb_writeb(musb->mregs, MUSB_TESTMODE, temp);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\ndev_dbg(musb->controller, "set feature %d\n", wValue);\r\nmusb->port1_status |= 1 << wValue;\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn retval;\r\n}
