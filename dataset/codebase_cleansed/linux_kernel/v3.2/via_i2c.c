static void via_i2c_setscl(void *data, int state)\r\n{\r\nu8 val;\r\nstruct via_port_cfg *adap_data = data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\r\nval = via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0xF0;\r\nif (state)\r\nval |= 0x20;\r\nelse\r\nval &= ~0x20;\r\nswitch (adap_data->type) {\r\ncase VIA_PORT_I2C:\r\nval |= 0x01;\r\nbreak;\r\ncase VIA_PORT_GPIO:\r\nval |= 0x80;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "viafb_i2c: specify wrong i2c type.\n");\r\n}\r\nvia_write_reg(adap_data->io_port, adap_data->ioport_index, val);\r\nspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\r\n}\r\nstatic int via_i2c_getscl(void *data)\r\n{\r\nstruct via_port_cfg *adap_data = data;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\r\nif (via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0x08)\r\nret = 1;\r\nspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int via_i2c_getsda(void *data)\r\n{\r\nstruct via_port_cfg *adap_data = data;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\r\nif (via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0x04)\r\nret = 1;\r\nspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void via_i2c_setsda(void *data, int state)\r\n{\r\nu8 val;\r\nstruct via_port_cfg *adap_data = data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&i2c_vdev->reg_lock, flags);\r\nval = via_read_reg(adap_data->io_port, adap_data->ioport_index) & 0xF0;\r\nif (state)\r\nval |= 0x10;\r\nelse\r\nval &= ~0x10;\r\nswitch (adap_data->type) {\r\ncase VIA_PORT_I2C:\r\nval |= 0x01;\r\nbreak;\r\ncase VIA_PORT_GPIO:\r\nval |= 0x40;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "viafb_i2c: specify wrong i2c type.\n");\r\n}\r\nvia_write_reg(adap_data->io_port, adap_data->ioport_index, val);\r\nspin_unlock_irqrestore(&i2c_vdev->reg_lock, flags);\r\n}\r\nint viafb_i2c_readbyte(u8 adap, u8 slave_addr, u8 index, u8 *pdata)\r\n{\r\nint ret;\r\nu8 mm1[] = {0x00};\r\nstruct i2c_msg msgs[2];\r\nif (!via_i2c_par[adap].is_active)\r\nreturn -ENODEV;\r\n*pdata = 0;\r\nmsgs[0].flags = 0;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[0].addr = msgs[1].addr = slave_addr / 2;\r\nmm1[0] = index;\r\nmsgs[0].len = 1; msgs[1].len = 1;\r\nmsgs[0].buf = mm1; msgs[1].buf = pdata;\r\nret = i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);\r\nif (ret == 2)\r\nret = 0;\r\nelse if (ret >= 0)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nint viafb_i2c_writebyte(u8 adap, u8 slave_addr, u8 index, u8 data)\r\n{\r\nint ret;\r\nu8 msg[2] = { index, data };\r\nstruct i2c_msg msgs;\r\nif (!via_i2c_par[adap].is_active)\r\nreturn -ENODEV;\r\nmsgs.flags = 0;\r\nmsgs.addr = slave_addr / 2;\r\nmsgs.len = 2;\r\nmsgs.buf = msg;\r\nret = i2c_transfer(&via_i2c_par[adap].adapter, &msgs, 1);\r\nif (ret == 1)\r\nret = 0;\r\nelse if (ret >= 0)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nint viafb_i2c_readbytes(u8 adap, u8 slave_addr, u8 index, u8 *buff, int buff_len)\r\n{\r\nint ret;\r\nu8 mm1[] = {0x00};\r\nstruct i2c_msg msgs[2];\r\nif (!via_i2c_par[adap].is_active)\r\nreturn -ENODEV;\r\nmsgs[0].flags = 0;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[0].addr = msgs[1].addr = slave_addr / 2;\r\nmm1[0] = index;\r\nmsgs[0].len = 1; msgs[1].len = buff_len;\r\nmsgs[0].buf = mm1; msgs[1].buf = buff;\r\nret = i2c_transfer(&via_i2c_par[adap].adapter, msgs, 2);\r\nif (ret == 2)\r\nret = 0;\r\nelse if (ret >= 0)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nstruct i2c_adapter *viafb_find_i2c_adapter(enum viafb_i2c_adap which)\r\n{\r\nstruct via_i2c_stuff *stuff = &via_i2c_par[which];\r\nreturn &stuff->adapter;\r\n}\r\nstatic int create_i2c_bus(struct i2c_adapter *adapter,\r\nstruct i2c_algo_bit_data *algo,\r\nstruct via_port_cfg *adap_cfg,\r\nstruct pci_dev *pdev)\r\n{\r\nalgo->setsda = via_i2c_setsda;\r\nalgo->setscl = via_i2c_setscl;\r\nalgo->getsda = via_i2c_getsda;\r\nalgo->getscl = via_i2c_getscl;\r\nalgo->udelay = 10;\r\nalgo->timeout = 2;\r\nalgo->data = adap_cfg;\r\nsprintf(adapter->name, "viafb i2c io_port idx 0x%02x",\r\nadap_cfg->ioport_index);\r\nadapter->owner = THIS_MODULE;\r\nadapter->class = I2C_CLASS_DDC;\r\nadapter->algo_data = algo;\r\nif (pdev)\r\nadapter->dev.parent = &pdev->dev;\r\nelse\r\nadapter->dev.parent = NULL;\r\nvia_i2c_setsda(adap_cfg, 1);\r\nvia_i2c_setscl(adap_cfg, 1);\r\nudelay(20);\r\nreturn i2c_bit_add_bus(adapter);\r\n}\r\nstatic int viafb_i2c_probe(struct platform_device *platdev)\r\n{\r\nint i, ret;\r\nstruct via_port_cfg *configs;\r\ni2c_vdev = platdev->dev.platform_data;\r\nconfigs = i2c_vdev->port_cfg;\r\nfor (i = 0; i < VIAFB_NUM_PORTS; i++) {\r\nstruct via_port_cfg *adap_cfg = configs++;\r\nstruct via_i2c_stuff *i2c_stuff = &via_i2c_par[i];\r\ni2c_stuff->is_active = 0;\r\nif (adap_cfg->type == 0 || adap_cfg->mode != VIA_MODE_I2C)\r\ncontinue;\r\nret = create_i2c_bus(&i2c_stuff->adapter,\r\n&i2c_stuff->algo, adap_cfg,\r\nNULL);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "viafb: cannot create i2c bus %u:%d\n",\r\ni, ret);\r\ncontinue;\r\n}\r\ni2c_stuff->is_active = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int viafb_i2c_remove(struct platform_device *platdev)\r\n{\r\nint i;\r\nfor (i = 0; i < VIAFB_NUM_PORTS; i++) {\r\nstruct via_i2c_stuff *i2c_stuff = &via_i2c_par[i];\r\nif (i2c_stuff->is_active)\r\ni2c_del_adapter(&i2c_stuff->adapter);\r\n}\r\nreturn 0;\r\n}\r\nint viafb_i2c_init(void)\r\n{\r\nreturn platform_driver_register(&via_i2c_driver);\r\n}\r\nvoid viafb_i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&via_i2c_driver);\r\n}
