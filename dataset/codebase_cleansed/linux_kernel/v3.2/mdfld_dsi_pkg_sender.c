static int wait_for_gen_fifo_empty(struct mdfld_dsi_pkg_sender *sender,\r\nu32 mask)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 gen_fifo_stat_reg = sender->mipi_gen_fifo_stat_reg;\r\nint retry = 0xffff;\r\nwhile (retry--) {\r\nif ((mask & REG_READ(gen_fifo_stat_reg)) == mask)\r\nreturn 0;\r\nudelay(100);\r\n}\r\ndev_err(dev->dev, "fifo is NOT empty 0x%08x\n",\r\nREG_READ(gen_fifo_stat_reg));\r\nreturn -EIO;\r\n}\r\nstatic int wait_for_all_fifos_empty(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nreturn wait_for_gen_fifo_empty(sender, (1 << 2) | (1 << 10) | (1 << 18)\r\n| (1 << 26) | (1 << 27) | (1 << 28));\r\n}\r\nstatic int wait_for_lp_fifos_empty(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nreturn wait_for_gen_fifo_empty(sender, (1 << 10) | (1 << 26));\r\n}\r\nstatic int wait_for_hs_fifos_empty(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nreturn wait_for_gen_fifo_empty(sender, (1 << 2) | (1 << 18));\r\n}\r\nstatic int wait_for_dbi_fifo_empty(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nreturn wait_for_gen_fifo_empty(sender, (1 << 27));\r\n}\r\nstatic int handle_dsi_error(struct mdfld_dsi_pkg_sender *sender, u32 mask)\r\n{\r\nu32 intr_stat_reg = sender->mipi_intr_stat_reg;\r\nstruct drm_device *dev = sender->dev;\r\nswitch (mask) {\r\ncase (1 << 0):\r\ncase (1 << 1):\r\ncase (1 << 2):\r\ncase (1 << 3):\r\ncase (1 << 4):\r\ncase (1 << 5):\r\ncase (1 << 6):\r\ncase (1 << 7):\r\ncase (1 << 8):\r\ncase (1 << 9):\r\ncase (1 << 10):\r\ncase (1 << 11):\r\ncase (1 << 12):\r\ncase (1 << 13):\r\nbreak;\r\ncase (1 << 14):\r\n;\r\nbreak;\r\ncase (1 << 15):\r\nbreak;\r\ncase (1 << 16):\r\nbreak;\r\ncase (1 << 17):\r\nbreak;\r\ncase (1 << 18):\r\ncase (1 << 19):\r\nif (0)\r\nwait_for_all_fifos_empty(sender);\r\nbreak;\r\ncase (1 << 20):\r\nbreak;\r\ncase (1 << 21):\r\nbreak;\r\ncase (1 << 22):\r\nbreak;\r\ncase (1 << 23):\r\ncase (1 << 24):\r\ncase (1 << 25):\r\ncase (1 << 26):\r\ncase (1 << 27):\r\nREG_WRITE(intr_stat_reg, mask);\r\nwait_for_hs_fifos_empty(sender);\r\nbreak;\r\ncase (1 << 28):\r\nREG_WRITE(intr_stat_reg, mask);\r\nwait_for_lp_fifos_empty(sender);\r\nbreak;\r\ncase (1 << 29):\r\ncase (1 << 30):\r\ncase (1 << 31):\r\nbreak;\r\n}\r\nif (mask & REG_READ(intr_stat_reg))\r\ndev_warn(dev->dev, "Cannot clean interrupt 0x%08x\n", mask);\r\nreturn 0;\r\n}\r\nstatic int dsi_error_handler(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 intr_stat_reg = sender->mipi_intr_stat_reg;\r\nu32 mask;\r\nu32 intr_stat;\r\nint i;\r\nint err = 0;\r\nintr_stat = REG_READ(intr_stat_reg);\r\nfor (i = 0; i < 32; i++) {\r\nmask = (0x00000001UL) << i;\r\nif (intr_stat & mask) {\r\ndev_dbg(dev->dev, "[DSI]: %s\n", dsi_errors[i]);\r\nerr = handle_dsi_error(sender, mask);\r\nif (err)\r\ndev_err(dev->dev, "Cannot handle error\n");\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic inline int dbi_cmd_sent(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 retry = 0xffff;\r\nu32 dbi_cmd_addr_reg = sender->mipi_cmd_addr_reg;\r\nwhile (retry--) {\r\nif (!(REG_READ(dbi_cmd_addr_reg) & (1 << 0)))\r\nbreak;\r\n}\r\nif (!retry) {\r\ndev_err(dev->dev, "Timeout waiting for DBI Command status\n");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int send_dcs_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nstruct mdfld_dsi_dcs_pkg *dcs_pkg = &pkg->pkg.dcs_pkg;\r\nu32 dbi_cmd_len_reg = sender->mipi_cmd_len_reg;\r\nu32 dbi_cmd_addr_reg = sender->mipi_cmd_addr_reg;\r\nu32 cb_phy = sender->dbi_cb_phy;\r\nu32 index = 0;\r\nu8 *cb = (u8 *)sender->dbi_cb_addr;\r\nint i;\r\nint ret;\r\nif (!sender->dbi_pkg_support) {\r\ndev_err(dev->dev, "Trying to send DCS on a non DBI output, abort!\n");\r\nreturn -ENOTSUPP;\r\n}\r\nwait_for_dbi_fifo_empty(sender);\r\n*(cb + (index++)) = dcs_pkg->cmd;\r\nif (dcs_pkg->param_num) {\r\nfor (i = 0; i < dcs_pkg->param_num; i++)\r\n*(cb + (index++)) = *(dcs_pkg->param + i);\r\n}\r\nREG_WRITE(dbi_cmd_len_reg, (1 + dcs_pkg->param_num));\r\nREG_WRITE(dbi_cmd_addr_reg,\r\n(cb_phy << CMD_MEM_ADDR_OFFSET)\r\n| (1 << 0)\r\n| ((dcs_pkg->data_src == CMD_DATA_SRC_PIPE) ? (1 << 1) : 0));\r\nret = dbi_cmd_sent(sender);\r\nif (ret) {\r\ndev_err(dev->dev, "command 0x%x not complete\n", dcs_pkg->cmd);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __send_short_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 hs_gen_ctrl_reg = sender->mipi_hs_gen_ctrl_reg;\r\nu32 lp_gen_ctrl_reg = sender->mipi_lp_gen_ctrl_reg;\r\nu32 gen_ctrl_val = 0;\r\nstruct mdfld_dsi_gen_short_pkg *short_pkg = &pkg->pkg.short_pkg;\r\ngen_ctrl_val |= short_pkg->cmd << MCS_COMMANDS_POS;\r\ngen_ctrl_val |= 0 << DCS_CHANNEL_NUMBER_POS;\r\ngen_ctrl_val |= pkg->pkg_type;\r\ngen_ctrl_val |= short_pkg->param << MCS_PARAMETER_POS;\r\nif (pkg->transmission_type == MDFLD_DSI_HS_TRANSMISSION) {\r\nREG_WRITE(hs_gen_ctrl_reg, gen_ctrl_val);\r\n} else if (pkg->transmission_type == MDFLD_DSI_LP_TRANSMISSION) {\r\nREG_WRITE(lp_gen_ctrl_reg, gen_ctrl_val);\r\n} else {\r\ndev_err(dev->dev, "Unknown transmission type %d\n",\r\npkg->transmission_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __send_long_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 hs_gen_ctrl_reg = sender->mipi_hs_gen_ctrl_reg;\r\nu32 hs_gen_data_reg = sender->mipi_hs_gen_data_reg;\r\nu32 lp_gen_ctrl_reg = sender->mipi_lp_gen_ctrl_reg;\r\nu32 lp_gen_data_reg = sender->mipi_lp_gen_data_reg;\r\nu32 gen_ctrl_val = 0;\r\nu32 *dp;\r\nint i;\r\nstruct mdfld_dsi_gen_long_pkg *long_pkg = &pkg->pkg.long_pkg;\r\ndp = long_pkg->data;\r\ngen_ctrl_val |= (long_pkg->len << 2) << WORD_COUNTS_POS;\r\ngen_ctrl_val |= 0 << DCS_CHANNEL_NUMBER_POS;\r\ngen_ctrl_val |= pkg->pkg_type;\r\nif (pkg->transmission_type == MDFLD_DSI_HS_TRANSMISSION) {\r\nfor (i = 0; i < long_pkg->len; i++)\r\nREG_WRITE(hs_gen_data_reg, *(dp + i));\r\nREG_WRITE(hs_gen_ctrl_reg, gen_ctrl_val);\r\n} else if (pkg->transmission_type == MDFLD_DSI_LP_TRANSMISSION) {\r\nfor (i = 0; i < long_pkg->len; i++)\r\nREG_WRITE(lp_gen_data_reg, *(dp + i));\r\nREG_WRITE(lp_gen_ctrl_reg, gen_ctrl_val);\r\n} else {\r\ndev_err(dev->dev, "Unknown transmission type %d\n",\r\npkg->transmission_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int send_mcs_short_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nreturn __send_short_pkg(sender, pkg);\r\n}\r\nstatic int send_mcs_long_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nreturn __send_long_pkg(sender, pkg);\r\n}\r\nstatic int send_gen_short_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nreturn __send_short_pkg(sender, pkg);\r\n}\r\nstatic int send_gen_long_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nreturn __send_long_pkg(sender, pkg);\r\n}\r\nstatic int send_pkg_prepare(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nu8 cmd;\r\nu8 *data;\r\nswitch (pkg->pkg_type) {\r\ncase MDFLD_DSI_PKG_DCS:\r\ncmd = pkg->pkg.dcs_pkg.cmd;\r\nbreak;\r\ncase MDFLD_DSI_PKG_MCS_SHORT_WRITE_0:\r\ncase MDFLD_DSI_PKG_MCS_SHORT_WRITE_1:\r\ncmd = pkg->pkg.short_pkg.cmd;\r\nbreak;\r\ncase MDFLD_DSI_PKG_MCS_LONG_WRITE:\r\ndata = (u8 *)pkg->pkg.long_pkg.data;\r\ncmd = *data;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsender->status = MDFLD_DSI_PKG_SENDER_BUSY;\r\nif ((sender->panel_mode & MDFLD_DSI_PANEL_MODE_SLEEP) &&\r\ncmd != exit_sleep_mode) {\r\ndev_err(sender->dev->dev,\r\n"sending 0x%x when panel sleep in\n", cmd);\r\nsender->status = MDFLD_DSI_PKG_SENDER_FREE;\r\nreturn -EINVAL;\r\n}\r\nif (cmd == DCS_ENTER_SLEEP_MODE) {\r\nmdelay(120);\r\n}\r\nreturn 0;\r\n}\r\nstatic int send_pkg_done(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nu8 cmd;\r\nu8 *data;\r\nswitch (pkg->pkg_type) {\r\ncase MDFLD_DSI_PKG_DCS:\r\ncmd = pkg->pkg.dcs_pkg.cmd;\r\nbreak;\r\ncase MDFLD_DSI_PKG_MCS_SHORT_WRITE_0:\r\ncase MDFLD_DSI_PKG_MCS_SHORT_WRITE_1:\r\ncmd = pkg->pkg.short_pkg.cmd;\r\nbreak;\r\ncase MDFLD_DSI_PKG_MCS_LONG_WRITE:\r\ndata = (u8 *)pkg->pkg.long_pkg.data;\r\ncmd = *data;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (cmd == DCS_ENTER_SLEEP_MODE) {\r\nsender->panel_mode |= MDFLD_DSI_PANEL_MODE_SLEEP;\r\nmdelay(120);\r\n} else if (cmd == DCS_EXIT_SLEEP_MODE) {\r\nsender->panel_mode &= ~MDFLD_DSI_PANEL_MODE_SLEEP;\r\nmdelay(120);\r\n} else if (unlikely(cmd == DCS_SOFT_RESET)) {\r\nmdelay(5);\r\n}\r\nsender->status = MDFLD_DSI_PKG_SENDER_FREE;\r\nreturn 0;\r\n}\r\nstatic int do_send_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nint ret;\r\nif (sender->status == MDFLD_DSI_PKG_SENDER_BUSY) {\r\ndev_err(sender->dev->dev, "sender is busy\n");\r\nreturn -EAGAIN;\r\n}\r\nret = send_pkg_prepare(sender, pkg);\r\nif (ret) {\r\ndev_err(sender->dev->dev, "send_pkg_prepare error\n");\r\nreturn ret;\r\n}\r\nswitch (pkg->pkg_type) {\r\ncase MDFLD_DSI_PKG_DCS:\r\nret = send_dcs_pkg(sender, pkg);\r\nbreak;\r\ncase MDFLD_DSI_PKG_GEN_SHORT_WRITE_0:\r\ncase MDFLD_DSI_PKG_GEN_SHORT_WRITE_1:\r\ncase MDFLD_DSI_PKG_GEN_SHORT_WRITE_2:\r\ncase MDFLD_DSI_PKG_GEN_READ_0:\r\ncase MDFLD_DSI_PKG_GEN_READ_1:\r\ncase MDFLD_DSI_PKG_GEN_READ_2:\r\nret = send_gen_short_pkg(sender, pkg);\r\nbreak;\r\ncase MDFLD_DSI_PKG_GEN_LONG_WRITE:\r\nret = send_gen_long_pkg(sender, pkg);\r\nbreak;\r\ncase MDFLD_DSI_PKG_MCS_SHORT_WRITE_0:\r\ncase MDFLD_DSI_PKG_MCS_SHORT_WRITE_1:\r\ncase MDFLD_DSI_PKG_MCS_READ:\r\nret = send_mcs_short_pkg(sender, pkg);\r\nbreak;\r\ncase MDFLD_DSI_PKG_MCS_LONG_WRITE:\r\nret = send_mcs_long_pkg(sender, pkg);\r\nbreak;\r\ndefault:\r\ndev_err(sender->dev->dev, "Invalid pkg type 0x%x\n",\r\npkg->pkg_type);\r\nret = -EINVAL;\r\n}\r\nsend_pkg_done(sender, pkg);\r\nreturn ret;\r\n}\r\nstatic int send_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nint err ;\r\nerr = dsi_error_handler(sender);\r\nif (err) {\r\ndev_err(sender->dev->dev, "Error handling failed\n");\r\nerr = -EAGAIN;\r\ngoto send_pkg_err;\r\n}\r\nerr = do_send_pkg(sender, pkg);\r\nif (err) {\r\ndev_err(sender->dev->dev, "sent pkg failed\n");\r\nerr = -EAGAIN;\r\ngoto send_pkg_err;\r\n}\r\nsend_pkg_err:\r\nreturn err;\r\n}\r\nstatic struct mdfld_dsi_pkg *pkg_sender_get_pkg_locked(\r\nstruct mdfld_dsi_pkg_sender *sender)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nif (list_empty(&sender->free_list)) {\r\ndev_err(sender->dev->dev, "No free pkg left\n");\r\nreturn NULL;\r\n}\r\npkg = list_first_entry(&sender->free_list, struct mdfld_dsi_pkg, entry);\r\nlist_del_init(&pkg->entry);\r\nreturn pkg;\r\n}\r\nstatic void pkg_sender_put_pkg_locked(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg)\r\n{\r\nmemset(pkg, 0, sizeof(struct mdfld_dsi_pkg));\r\nINIT_LIST_HEAD(&pkg->entry);\r\nlist_add_tail(&pkg->entry, &sender->free_list);\r\n}\r\nstatic int mdfld_dbi_cb_init(struct mdfld_dsi_pkg_sender *sender,\r\nstruct psb_gtt *pg, int pipe)\r\n{\r\nunsigned long phys;\r\nvoid *virt_addr = NULL;\r\nswitch (pipe) {\r\ncase 0:\r\nphys = pg->gtt_phys_start - 0x1000;\r\nbreak;\r\ncase 2:\r\nphys = pg->gtt_phys_start - 0x800;\r\nbreak;\r\ndefault:\r\ndev_err(sender->dev->dev, "Unsupported channel %d\n", pipe);\r\nreturn -EINVAL;\r\n}\r\nvirt_addr = ioremap_nocache(phys, 0x800);\r\nif (!virt_addr) {\r\ndev_err(sender->dev->dev, "Map DBI command buffer error\n");\r\nreturn -ENOMEM;\r\n}\r\nsender->dbi_cb_phy = phys;\r\nsender->dbi_cb_addr = virt_addr;\r\nreturn 0;\r\n}\r\nstatic void mdfld_dbi_cb_destroy(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nif (sender && sender->dbi_cb_addr)\r\niounmap(sender->dbi_cb_addr);\r\n}\r\nstatic void pkg_sender_queue_pkg(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg,\r\nint delay)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\nif (!delay) {\r\nsend_pkg(sender, pkg);\r\npkg_sender_put_pkg_locked(sender, pkg);\r\n} else {\r\nlist_add_tail(&pkg->entry, &sender->pkg_list);\r\n}\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\n}\r\nstatic void process_pkg_list(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\nwhile (!list_empty(&sender->pkg_list)) {\r\npkg = list_first_entry(&sender->pkg_list,\r\nstruct mdfld_dsi_pkg, entry);\r\nsend_pkg(sender, pkg);\r\nlist_del_init(&pkg->entry);\r\npkg_sender_put_pkg_locked(sender, pkg);\r\n}\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\n}\r\nstatic int mdfld_dsi_send_mcs_long(struct mdfld_dsi_pkg_sender *sender,\r\nu32 *data, u32 len, u8 transmission, int delay)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\npkg = pkg_sender_get_pkg_locked(sender);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nif (!pkg) {\r\ndev_err(sender->dev->dev, "No memory\n");\r\nreturn -ENOMEM;\r\n}\r\npkg->pkg_type = MDFLD_DSI_PKG_MCS_LONG_WRITE;\r\npkg->transmission_type = transmission;\r\npkg->pkg.long_pkg.data = data;\r\npkg->pkg.long_pkg.len = len;\r\nINIT_LIST_HEAD(&pkg->entry);\r\npkg_sender_queue_pkg(sender, pkg, delay);\r\nreturn 0;\r\n}\r\nstatic int mdfld_dsi_send_mcs_short(struct mdfld_dsi_pkg_sender *sender,\r\nu8 cmd, u8 param, u8 param_num,\r\nu8 transmission,\r\nint delay)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\npkg = pkg_sender_get_pkg_locked(sender);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nif (!pkg) {\r\ndev_err(sender->dev->dev, "No memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (param_num) {\r\npkg->pkg_type = MDFLD_DSI_PKG_MCS_SHORT_WRITE_1;\r\npkg->pkg.short_pkg.param = param;\r\n} else {\r\npkg->pkg_type = MDFLD_DSI_PKG_MCS_SHORT_WRITE_0;\r\npkg->pkg.short_pkg.param = 0;\r\n}\r\npkg->transmission_type = transmission;\r\npkg->pkg.short_pkg.cmd = cmd;\r\nINIT_LIST_HEAD(&pkg->entry);\r\npkg_sender_queue_pkg(sender, pkg, delay);\r\nreturn 0;\r\n}\r\nstatic int mdfld_dsi_send_gen_short(struct mdfld_dsi_pkg_sender *sender,\r\nu8 param0, u8 param1, u8 param_num,\r\nu8 transmission,\r\nint delay)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\npkg = pkg_sender_get_pkg_locked(sender);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nif (!pkg) {\r\ndev_err(sender->dev->dev, "No pkg memory\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (param_num) {\r\ncase 0:\r\npkg->pkg_type = MDFLD_DSI_PKG_GEN_SHORT_WRITE_0;\r\npkg->pkg.short_pkg.cmd = 0;\r\npkg->pkg.short_pkg.param = 0;\r\nbreak;\r\ncase 1:\r\npkg->pkg_type = MDFLD_DSI_PKG_GEN_SHORT_WRITE_1;\r\npkg->pkg.short_pkg.cmd = param0;\r\npkg->pkg.short_pkg.param = 0;\r\nbreak;\r\ncase 2:\r\npkg->pkg_type = MDFLD_DSI_PKG_GEN_SHORT_WRITE_2;\r\npkg->pkg.short_pkg.cmd = param0;\r\npkg->pkg.short_pkg.param = param1;\r\nbreak;\r\n}\r\npkg->transmission_type = transmission;\r\nINIT_LIST_HEAD(&pkg->entry);\r\npkg_sender_queue_pkg(sender, pkg, delay);\r\nreturn 0;\r\n}\r\nstatic int mdfld_dsi_send_gen_long(struct mdfld_dsi_pkg_sender *sender,\r\nu32 *data, u32 len, u8 transmission, int delay)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\npkg = pkg_sender_get_pkg_locked(sender);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nif (!pkg) {\r\ndev_err(sender->dev->dev, "No pkg memory\n");\r\nreturn -ENOMEM;\r\n}\r\npkg->pkg_type = MDFLD_DSI_PKG_GEN_LONG_WRITE;\r\npkg->transmission_type = transmission;\r\npkg->pkg.long_pkg.data = data;\r\npkg->pkg.long_pkg.len = len;\r\nINIT_LIST_HEAD(&pkg->entry);\r\npkg_sender_queue_pkg(sender, pkg, delay);\r\nreturn 0;\r\n}\r\nstatic int __read_panel_data(struct mdfld_dsi_pkg_sender *sender,\r\nstruct mdfld_dsi_pkg *pkg,\r\nu32 *data,\r\nu16 len)\r\n{\r\nunsigned long flags;\r\nstruct drm_device *dev = sender->dev;\r\nint i;\r\nu32 gen_data_reg;\r\nint retry = MDFLD_DSI_READ_MAX_COUNT;\r\nu8 transmission = pkg->transmission_type;\r\nspin_lock_irqsave(&sender->lock, flags);\r\nREG_WRITE(sender->mipi_intr_stat_reg, 1 << 29);\r\nif ((REG_READ(sender->mipi_intr_stat_reg) & (1 << 29)))\r\nDRM_ERROR("Can NOT clean read data valid interrupt\n");\r\nsend_pkg(sender, pkg);\r\npkg_sender_put_pkg_locked(sender, pkg);\r\nwhile (retry && !(REG_READ(sender->mipi_intr_stat_reg) & (1 << 29))) {\r\nudelay(100);\r\nretry--;\r\n}\r\nif (!retry) {\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn -ETIMEDOUT;\r\n}\r\nREG_WRITE(sender->mipi_intr_stat_reg, (1 << 29));\r\nif (transmission == MDFLD_DSI_HS_TRANSMISSION)\r\ngen_data_reg = sender->mipi_hs_gen_data_reg;\r\nelse if (transmission == MDFLD_DSI_LP_TRANSMISSION)\r\ngen_data_reg = sender->mipi_lp_gen_data_reg;\r\nelse {\r\nDRM_ERROR("Unknown transmission");\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nfor (i=0; i<len; i++)\r\n*(data + i) = REG_READ(gen_data_reg);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mdfld_dsi_read_gen(struct mdfld_dsi_pkg_sender *sender,\r\nu8 param0,\r\nu8 param1,\r\nu8 param_num,\r\nu32 *data,\r\nu16 len,\r\nu8 transmission)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\npkg = pkg_sender_get_pkg_locked(sender);\r\nspin_unlock_irqrestore(&sender->lock,flags);\r\nif (!pkg) {\r\ndev_err(sender->dev->dev, "No pkg memory\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (param_num) {\r\ncase 0:\r\npkg->pkg_type = MDFLD_DSI_PKG_GEN_READ_0;\r\npkg->pkg.short_pkg.cmd = 0;\r\npkg->pkg.short_pkg.param = 0;\r\nbreak;\r\ncase 1:\r\npkg->pkg_type = MDFLD_DSI_PKG_GEN_READ_1;\r\npkg->pkg.short_pkg.cmd = param0;\r\npkg->pkg.short_pkg.param = 0;\r\nbreak;\r\ncase 2:\r\npkg->pkg_type = MDFLD_DSI_PKG_GEN_READ_2;\r\npkg->pkg.short_pkg.cmd = param0;\r\npkg->pkg.short_pkg.param = param1;\r\nbreak;\r\n}\r\npkg->transmission_type = transmission;\r\nINIT_LIST_HEAD(&pkg->entry);\r\nreturn __read_panel_data(sender, pkg, data, len);\r\n}\r\nstatic int mdfld_dsi_read_mcs(struct mdfld_dsi_pkg_sender *sender,\r\nu8 cmd,\r\nu32 *data,\r\nu16 len,\r\nu8 transmission)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sender->lock, flags);\r\npkg = pkg_sender_get_pkg_locked(sender);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nif (!pkg) {\r\ndev_err(sender->dev->dev, "No pkg memory\n");\r\nreturn -ENOMEM;\r\n}\r\npkg->pkg_type = MDFLD_DSI_PKG_MCS_READ;\r\npkg->pkg.short_pkg.cmd = cmd;\r\npkg->pkg.short_pkg.param = 0;\r\npkg->transmission_type = transmission;\r\nINIT_LIST_HEAD(&pkg->entry);\r\nreturn __read_panel_data(sender, pkg, data, len);\r\n}\r\nvoid dsi_controller_dbi_init(struct mdfld_dsi_config * dsi_config, int pipe)\r\n{\r\nstruct drm_device * dev = dsi_config->dev;\r\nu32 reg_offset = pipe ? MIPIC_REG_OFFSET : 0;\r\nint lane_count = dsi_config->lane_count;\r\nu32 val = 0;\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_CONTROL_REG + reg_offset), 0x00000018);\r\nREG_WRITE((MIPIA_DPHY_PARAM_REG + reg_offset), 0x150c3408);\r\nREG_WRITE((MIPIA_CLK_LANE_SWITCH_TIME_CNT_REG + reg_offset), 0x000a0014);\r\nREG_WRITE((MIPIA_DBI_BW_CTRL_REG + reg_offset), 0x00000400);\r\nREG_WRITE((MIPIA_DBI_FIFO_THROTTLE_REG + reg_offset), 0x00000001);\r\nREG_WRITE((MIPIA_HS_LS_DBI_ENABLE_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_INTR_EN_REG + reg_offset), 0xffffffff);\r\nREG_WRITE((MIPIA_TURN_AROUND_TIMEOUT_REG + reg_offset), 0x0000001f);\r\nREG_WRITE((MIPIA_DEVICE_RESET_TIMER_REG + reg_offset), 0x0000ffff);\r\nREG_WRITE((MIPIA_INIT_COUNT_REG + reg_offset), 0x00000fa0);\r\nREG_WRITE((MIPIA_MAX_RETURN_PACK_SIZE_REG + reg_offset),\r\nMDFLD_DSI_MAX_RETURN_PACKET_SIZE);\r\nval |= lane_count;\r\nval |= (dsi_config->channel_num << DSI_DBI_VIRT_CHANNEL_OFFSET);\r\nval |= DSI_DBI_COLOR_FORMAT_OPTION2;\r\nREG_WRITE((MIPIA_DSI_FUNC_PRG_REG + reg_offset), val);\r\nREG_WRITE((MIPIA_HS_TX_TIMEOUT_REG + reg_offset), 0x3fffff);\r\nREG_WRITE((MIPIA_LP_RX_TIMEOUT_REG + reg_offset), 0xffff);\r\nREG_WRITE((MIPIA_HIGH_LOW_SWITCH_COUNT_REG + reg_offset), 0x46);\r\nREG_WRITE((MIPIA_EOT_DISABLE_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_LP_BYTECLK_REG + reg_offset), 0x00000004);\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000001);\r\n}\r\nvoid dsi_controller_dpi_init(struct mdfld_dsi_config * dsi_config, int pipe)\r\n{\r\nstruct drm_device * dev = dsi_config->dev;\r\nu32 reg_offset = pipe ? MIPIC_REG_OFFSET : 0;\r\nint lane_count = dsi_config->lane_count;\r\nstruct mdfld_dsi_dpi_timing dpi_timing;\r\nstruct drm_display_mode * mode = dsi_config->mode;\r\nu32 val = 0;\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_CONTROL_REG + reg_offset), 0x00000018);\r\nREG_WRITE((MIPIA_INTR_EN_REG + reg_offset), 0xffffffff);\r\nval |= lane_count;\r\nval |= dsi_config->channel_num << DSI_DPI_VIRT_CHANNEL_OFFSET;\r\nswitch(dsi_config->bpp) {\r\ncase 16:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB565;\r\nbreak;\r\ncase 18:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB666;\r\nbreak;\r\ncase 24:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB888;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported color format, bpp = %d\n", dsi_config->bpp);\r\n}\r\nREG_WRITE((MIPIA_DSI_FUNC_PRG_REG + reg_offset), val);\r\nREG_WRITE((MIPIA_HS_TX_TIMEOUT_REG + reg_offset),\r\n(mode->vtotal * mode->htotal * dsi_config->bpp / (8 * lane_count)) & DSI_HS_TX_TIMEOUT_MASK);\r\nREG_WRITE((MIPIA_LP_RX_TIMEOUT_REG + reg_offset), 0xffff & DSI_LP_RX_TIMEOUT_MASK);\r\nREG_WRITE((MIPIA_TURN_AROUND_TIMEOUT_REG + reg_offset), 0x14 & DSI_TURN_AROUND_TIMEOUT_MASK);\r\nREG_WRITE((MIPIA_DEVICE_RESET_TIMER_REG + reg_offset), 0xffff & DSI_RESET_TIMER_MASK);\r\nREG_WRITE((MIPIA_DPI_RESOLUTION_REG + reg_offset), mode->vdisplay << 16 | mode->hdisplay);\r\nmdfld_dsi_dpi_timing_calculation(mode, &dpi_timing, dsi_config->lane_count, dsi_config->bpp);\r\nREG_WRITE((MIPIA_HSYNC_COUNT_REG + reg_offset), dpi_timing.hsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HBP_COUNT_REG + reg_offset), dpi_timing.hbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HFP_COUNT_REG + reg_offset), dpi_timing.hfp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HACTIVE_COUNT_REG + reg_offset), dpi_timing.hactive_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_VSYNC_COUNT_REG + reg_offset), dpi_timing.vsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_VBP_COUNT_REG + reg_offset), dpi_timing.vbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_VFP_COUNT_REG + reg_offset), dpi_timing.vfp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HIGH_LOW_SWITCH_COUNT_REG + reg_offset), 0x46);\r\nREG_WRITE((MIPIA_INIT_COUNT_REG + reg_offset), 0x000007d0);\r\nval = dsi_config->video_mode | DSI_DPI_COMPLETE_LAST_LINE;\r\nREG_WRITE((MIPIA_VIDEO_MODE_FORMAT_REG + reg_offset), val);\r\nREG_WRITE((MIPIA_EOT_DISABLE_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_LP_BYTECLK_REG + reg_offset), 0x00000004);\r\nREG_WRITE((MIPIA_DPHY_PARAM_REG + reg_offset), 0x150c3408);\r\nREG_WRITE((MIPIA_CLK_LANE_SWITCH_TIME_CNT_REG + reg_offset), (0xa << 16) | 0x14);\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000001);\r\n}\r\nstatic void dsi_controller_init(struct mdfld_dsi_config * dsi_config, int pipe)\r\n{\r\nif (!dsi_config || ((pipe != 0) && (pipe != 2))) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn;\r\n}\r\nif (dsi_config->type == MDFLD_DSI_ENCODER_DPI)\r\ndsi_controller_dpi_init(dsi_config, pipe);\r\nelse if (dsi_config->type == MDFLD_DSI_ENCODER_DBI)\r\ndsi_controller_dbi_init(dsi_config, pipe);\r\nelse\r\nDRM_ERROR("Bad DSI encoder type\n");\r\n}\r\nvoid mdfld_dsi_cmds_kick_out(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nprocess_pkg_list(sender);\r\n}\r\nint mdfld_dsi_send_dcs(struct mdfld_dsi_pkg_sender *sender,\r\nu8 dcs, u8 *param, u32 param_num, u8 data_src,\r\nint delay)\r\n{\r\nstruct mdfld_dsi_pkg *pkg;\r\nu32 cb_phy = sender->dbi_cb_phy;\r\nstruct drm_device *dev = sender->dev;\r\nu32 index = 0;\r\nu8 *cb = (u8 *)sender->dbi_cb_addr;\r\nunsigned long flags;\r\nint retry;\r\nu8 *dst = NULL;\r\nu32 len;\r\nif (!sender) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (!sender->dbi_pkg_support) {\r\ndev_err(dev->dev, "No DBI pkg sending on this sender\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (param_num > MDFLD_MAX_DCS_PARAM) {\r\ndev_err(dev->dev, "Sender only supports up to %d DCS params\n",\r\nMDFLD_MAX_DCS_PARAM);\r\nreturn -EINVAL;\r\n}\r\nif (dcs == DCS_WRITE_MEM_START) {\r\nif (!spin_trylock(&sender->lock))\r\nreturn -EAGAIN;\r\nretry = MDFLD_DSI_DBI_FIFO_TIMEOUT;\r\nwhile (retry &&\r\n!(REG_READ(sender->mipi_gen_fifo_stat_reg) & (1 << 27))) {\r\nudelay(500);\r\nretry--;\r\n}\r\nif (!retry) {\r\nspin_unlock(&sender->lock);\r\nreturn 0;\r\n}\r\n*(cb + (index++)) = write_mem_start;\r\nREG_WRITE(sender->mipi_cmd_len_reg, 1);\r\nREG_WRITE(sender->mipi_cmd_addr_reg,\r\ncb_phy | (1 << 0) | (1 << 1));\r\nretry = MDFLD_DSI_DBI_FIFO_TIMEOUT;\r\nwhile (retry &&\r\n(REG_READ(sender->mipi_cmd_addr_reg) & (1 << 0))) {\r\nudelay(1);\r\nretry--;\r\n}\r\nspin_unlock(&sender->lock);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&sender->lock, flags);\r\npkg = pkg_sender_get_pkg_locked(sender);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nif (!pkg) {\r\ndev_err(dev->dev, "No packages memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndst = pkg->pkg.dcs_pkg.param;\r\nmemcpy(dst, param, param_num);\r\npkg->pkg_type = MDFLD_DSI_PKG_DCS;\r\npkg->transmission_type = MDFLD_DSI_DCS;\r\npkg->pkg.dcs_pkg.cmd = dcs;\r\npkg->pkg.dcs_pkg.param_num = param_num;\r\npkg->pkg.dcs_pkg.data_src = data_src;\r\nINIT_LIST_HEAD(&pkg->entry);\r\nif (param_num == 0)\r\nreturn mdfld_dsi_send_mcs_short_hs(sender, dcs, 0, 0, delay);\r\nelse if (param_num == 1)\r\nreturn mdfld_dsi_send_mcs_short_hs(sender, dcs,\r\nparam[0], 1, delay);\r\nelse if (param_num > 1) {\r\nlen = (param_num + 1) / 4;\r\nif ((param_num + 1) % 4)\r\nlen++;\r\nreturn mdfld_dsi_send_mcs_long_hs(sender,\r\n(u32 *)&pkg->pkg.dcs_pkg, len, delay);\r\n}\r\nreturn 0;\r\n}\r\nint mdfld_dsi_send_mcs_short_hs(struct mdfld_dsi_pkg_sender *sender,\r\nu8 cmd, u8 param, u8 param_num, int delay)\r\n{\r\nif (!sender) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_mcs_short(sender, cmd, param, param_num,\r\nMDFLD_DSI_HS_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_send_mcs_short_lp(struct mdfld_dsi_pkg_sender *sender,\r\nu8 cmd, u8 param, u8 param_num, int delay)\r\n{\r\nif (!sender) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_mcs_short(sender, cmd, param, param_num,\r\nMDFLD_DSI_LP_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_send_mcs_long_hs(struct mdfld_dsi_pkg_sender *sender,\r\nu32 *data,\r\nu32 len,\r\nint delay)\r\n{\r\nif (!sender || !data || !len) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_mcs_long(sender, data, len,\r\nMDFLD_DSI_HS_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_send_mcs_long_lp(struct mdfld_dsi_pkg_sender *sender,\r\nu32 *data,\r\nu32 len,\r\nint delay)\r\n{\r\nif (!sender || !data || !len) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_mcs_long(sender, data, len,\r\nMDFLD_DSI_LP_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_send_gen_short_hs(struct mdfld_dsi_pkg_sender *sender,\r\nu8 param0, u8 param1, u8 param_num, int delay)\r\n{\r\nif (!sender) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_gen_short(sender, param0, param1, param_num,\r\nMDFLD_DSI_HS_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_send_gen_short_lp(struct mdfld_dsi_pkg_sender *sender,\r\nu8 param0, u8 param1, u8 param_num, int delay)\r\n{\r\nif (!sender || param_num < 0 || param_num > 2) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_gen_short(sender, param0, param1, param_num,\r\nMDFLD_DSI_LP_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_send_gen_long_hs(struct mdfld_dsi_pkg_sender *sender,\r\nu32 *data,\r\nu32 len,\r\nint delay)\r\n{\r\nif (!sender || !data || !len) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_gen_long(sender, data, len,\r\nMDFLD_DSI_HS_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_send_gen_long_lp(struct mdfld_dsi_pkg_sender *sender,\r\nu32 *data,\r\nu32 len,\r\nint delay)\r\n{\r\nif (!sender || !data || !len) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_send_gen_long(sender, data, len,\r\nMDFLD_DSI_LP_TRANSMISSION, delay);\r\n}\r\nint mdfld_dsi_read_gen_hs(struct mdfld_dsi_pkg_sender *sender,\r\nu8 param0,\r\nu8 param1,\r\nu8 param_num,\r\nu32 *data,\r\nu16 len)\r\n{\r\nif (!sender || !data || param_num < 0 || param_num > 2\r\n|| !data || !len) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_read_gen(sender, param0, param1, param_num,\r\ndata, len, MDFLD_DSI_HS_TRANSMISSION);\r\n}\r\nint mdfld_dsi_read_gen_lp(struct mdfld_dsi_pkg_sender *sender,\r\nu8 param0,\r\nu8 param1,\r\nu8 param_num,\r\nu32 *data,\r\nu16 len)\r\n{\r\nif (!sender || !data || param_num < 0 || param_num > 2\r\n|| !data || !len) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_read_gen(sender, param0, param1, param_num,\r\ndata, len, MDFLD_DSI_LP_TRANSMISSION);\r\n}\r\nint mdfld_dsi_read_mcs_hs(struct mdfld_dsi_pkg_sender *sender,\r\nu8 cmd,\r\nu32 *data,\r\nu16 len)\r\n{\r\nif (!sender || !data || !len) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_read_mcs(sender, cmd, data, len,\r\nMDFLD_DSI_HS_TRANSMISSION);\r\n}\r\nint mdfld_dsi_read_mcs_lp(struct mdfld_dsi_pkg_sender *sender,\r\nu8 cmd,\r\nu32 *data,\r\nu16 len)\r\n{\r\nif (!sender || !data || !len) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn mdfld_dsi_read_mcs(sender, cmd, data, len,\r\nMDFLD_DSI_LP_TRANSMISSION);\r\n}\r\nint mdfld_dsi_pkg_sender_init(struct mdfld_dsi_connector *dsi_connector,\r\nint pipe)\r\n{\r\nint ret;\r\nstruct mdfld_dsi_pkg_sender *pkg_sender;\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_get_config(dsi_connector);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_gtt *pg = &dev_priv->gtt;\r\nint i;\r\nstruct mdfld_dsi_pkg *pkg, *tmp;\r\nu32 mipi_val = 0;\r\nif (!dsi_connector) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\npkg_sender = dsi_connector->pkg_sender;\r\nif (!pkg_sender || IS_ERR(pkg_sender)) {\r\npkg_sender = kzalloc(sizeof(struct mdfld_dsi_pkg_sender),\r\nGFP_KERNEL);\r\nif (!pkg_sender) {\r\ndev_err(dev->dev, "Create DSI pkg sender failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndsi_connector->pkg_sender = (void *)pkg_sender;\r\n}\r\npkg_sender->dev = dev;\r\npkg_sender->dsi_connector = dsi_connector;\r\npkg_sender->pipe = pipe;\r\npkg_sender->pkg_num = 0;\r\npkg_sender->panel_mode = 0;\r\npkg_sender->status = MDFLD_DSI_PKG_SENDER_FREE;\r\nif (dsi_config->type == MDFLD_DSI_ENCODER_DBI) {\r\npkg_sender->dbi_pkg_support = 1;\r\nret = mdfld_dbi_cb_init(pkg_sender, pg, pipe);\r\nif (ret) {\r\ndev_err(dev->dev, "DBI command buffer map failed\n");\r\ngoto mapping_err;\r\n}\r\n}\r\nif (pipe == 0) {\r\npkg_sender->dpll_reg = MRST_DPLL_A;\r\npkg_sender->dspcntr_reg = DSPACNTR;\r\npkg_sender->pipeconf_reg = PIPEACONF;\r\npkg_sender->dsplinoff_reg = DSPALINOFF;\r\npkg_sender->dspsurf_reg = DSPASURF;\r\npkg_sender->pipestat_reg = PIPEASTAT;\r\npkg_sender->mipi_intr_stat_reg = MIPIA_INTR_STAT_REG;\r\npkg_sender->mipi_lp_gen_data_reg = MIPIA_LP_GEN_DATA_REG;\r\npkg_sender->mipi_hs_gen_data_reg = MIPIA_HS_GEN_DATA_REG;\r\npkg_sender->mipi_lp_gen_ctrl_reg = MIPIA_LP_GEN_CTRL_REG;\r\npkg_sender->mipi_hs_gen_ctrl_reg = MIPIA_HS_GEN_CTRL_REG;\r\npkg_sender->mipi_gen_fifo_stat_reg = MIPIA_GEN_FIFO_STAT_REG;\r\npkg_sender->mipi_data_addr_reg = MIPIA_DATA_ADD_REG;\r\npkg_sender->mipi_data_len_reg = MIPIA_DATA_LEN_REG;\r\npkg_sender->mipi_cmd_addr_reg = MIPIA_CMD_ADD_REG;\r\npkg_sender->mipi_cmd_len_reg = MIPIA_CMD_LEN_REG;\r\n} else if (pipe == 2) {\r\npkg_sender->dpll_reg = MRST_DPLL_A;\r\npkg_sender->dspcntr_reg = DSPCCNTR;\r\npkg_sender->pipeconf_reg = PIPECCONF;\r\npkg_sender->dsplinoff_reg = DSPCLINOFF;\r\npkg_sender->dspsurf_reg = DSPCSURF;\r\npkg_sender->pipestat_reg = PIPECSTAT;\r\npkg_sender->mipi_intr_stat_reg =\r\nMIPIA_INTR_STAT_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_lp_gen_data_reg =\r\nMIPIA_LP_GEN_DATA_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_hs_gen_data_reg =\r\nMIPIA_HS_GEN_DATA_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_lp_gen_ctrl_reg =\r\nMIPIA_LP_GEN_CTRL_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_hs_gen_ctrl_reg =\r\nMIPIA_HS_GEN_CTRL_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_gen_fifo_stat_reg =\r\nMIPIA_GEN_FIFO_STAT_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_data_addr_reg =\r\nMIPIA_DATA_ADD_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_data_len_reg =\r\nMIPIA_DATA_LEN_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_cmd_addr_reg =\r\nMIPIA_CMD_ADD_REG + MIPIC_REG_OFFSET;\r\npkg_sender->mipi_cmd_len_reg =\r\nMIPIA_CMD_LEN_REG + MIPIC_REG_OFFSET;\r\n}\r\nINIT_LIST_HEAD(&pkg_sender->pkg_list);\r\nINIT_LIST_HEAD(&pkg_sender->free_list);\r\nspin_lock_init(&pkg_sender->lock);\r\nfor (i = 0; i < MDFLD_MAX_PKG_NUM; i++) {\r\npkg = kzalloc(sizeof(struct mdfld_dsi_pkg), GFP_KERNEL);\r\nif (!pkg) {\r\ndev_err(dev->dev, "Out of memory allocating pkg pool");\r\nret = -ENOMEM;\r\ngoto pkg_alloc_err;\r\n}\r\nINIT_LIST_HEAD(&pkg->entry);\r\nlist_add_tail(&pkg->entry, &pkg_sender->free_list);\r\n}\r\nif (dsi_config->type == MDFLD_DSI_ENCODER_DPI)\r\nmipi_val = PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX;\r\nelse if (dsi_config->type == MDFLD_DSI_ENCODER_DBI)\r\nmipi_val = PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX\r\n| TE_TRIGGER_GPIO_PIN;\r\nelse\r\nDRM_ERROR("Bad DSI encoder type\n");\r\nif (pipe == 0) {\r\nmipi_val |= 0x2;\r\nREG_WRITE(MIPI, mipi_val);\r\nREG_READ(MIPI);\r\n} else if (pipe == 2) {\r\nREG_WRITE(MIPI_C, mipi_val);\r\nREG_READ(MIPI_C);\r\n}\r\ndsi_controller_init(dsi_config, pipe);\r\nreturn 0;\r\npkg_alloc_err:\r\nlist_for_each_entry_safe(pkg, tmp, &pkg_sender->free_list, entry) {\r\nlist_del(&pkg->entry);\r\nkfree(pkg);\r\n}\r\nmdfld_dbi_cb_destroy(pkg_sender);\r\nmapping_err:\r\nkfree(pkg_sender);\r\ndsi_connector->pkg_sender = NULL;\r\nreturn ret;\r\n}\r\nvoid mdfld_dsi_pkg_sender_destroy(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nstruct mdfld_dsi_pkg *pkg, *tmp;\r\nif (!sender || IS_ERR(sender))\r\nreturn;\r\nlist_for_each_entry_safe(pkg, tmp, &sender->free_list, entry) {\r\nlist_del(&pkg->entry);\r\nkfree(pkg);\r\n}\r\nlist_for_each_entry_safe(pkg, tmp, &sender->pkg_list, entry) {\r\nlist_del(&pkg->entry);\r\nkfree(pkg);\r\n}\r\nmdfld_dbi_cb_destroy(sender);\r\nkfree(sender);\r\n}
