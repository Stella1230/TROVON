int mlx4_SENSE_PORT(struct mlx4_dev *dev, int port,\r\nenum mlx4_port_type *type)\r\n{\r\nu64 out_param;\r\nint err = 0;\r\nerr = mlx4_cmd_imm(dev, 0, &out_param, port, 0,\r\nMLX4_CMD_SENSE_PORT, MLX4_CMD_TIME_CLASS_B);\r\nif (err) {\r\nmlx4_err(dev, "Sense command failed for port: %d\n", port);\r\nreturn err;\r\n}\r\nif (out_param > 2) {\r\nmlx4_err(dev, "Sense returned illegal value: 0x%llx\n", out_param);\r\nreturn -EINVAL;\r\n}\r\n*type = out_param;\r\nreturn 0;\r\n}\r\nvoid mlx4_do_sense_ports(struct mlx4_dev *dev,\r\nenum mlx4_port_type *stype,\r\nenum mlx4_port_type *defaults)\r\n{\r\nstruct mlx4_sense *sense = &mlx4_priv(dev)->sense;\r\nint err;\r\nint i;\r\nfor (i = 1; i <= dev->caps.num_ports; i++) {\r\nstype[i - 1] = 0;\r\nif (sense->do_sense_port[i] && sense->sense_allowed[i] &&\r\ndev->caps.possible_type[i] == MLX4_PORT_TYPE_AUTO) {\r\nerr = mlx4_SENSE_PORT(dev, i, &stype[i - 1]);\r\nif (err)\r\nstype[i - 1] = defaults[i - 1];\r\n} else\r\nstype[i - 1] = defaults[i - 1];\r\n}\r\nif (stype[0] == MLX4_PORT_TYPE_ETH) {\r\nfor (i = 1; i < dev->caps.num_ports; i++)\r\nstype[i] = stype[i] ? stype[i] : MLX4_PORT_TYPE_ETH;\r\n}\r\nif (stype[dev->caps.num_ports - 1] == MLX4_PORT_TYPE_IB) {\r\nfor (i = 0; i < dev->caps.num_ports - 1; i++)\r\nstype[i] = stype[i] ? stype[i] : MLX4_PORT_TYPE_IB;\r\n}\r\nfor (i = 0; i < dev->caps.num_ports; i++)\r\nstype[i] = stype[i] ? stype[i] : defaults[i];\r\n}\r\nstatic void mlx4_sense_port(struct work_struct *work)\r\n{\r\nstruct delayed_work *delay = to_delayed_work(work);\r\nstruct mlx4_sense *sense = container_of(delay, struct mlx4_sense,\r\nsense_poll);\r\nstruct mlx4_dev *dev = sense->dev;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nenum mlx4_port_type stype[MLX4_MAX_PORTS];\r\nmutex_lock(&priv->port_mutex);\r\nmlx4_do_sense_ports(dev, stype, &dev->caps.port_type[1]);\r\nif (mlx4_check_port_params(dev, stype))\r\ngoto sense_again;\r\nif (mlx4_change_port_types(dev, stype))\r\nmlx4_err(dev, "Failed to change port_types\n");\r\nsense_again:\r\nmutex_unlock(&priv->port_mutex);\r\nqueue_delayed_work(mlx4_wq , &sense->sense_poll,\r\nround_jiffies_relative(MLX4_SENSE_RANGE));\r\n}\r\nvoid mlx4_start_sense(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_sense *sense = &priv->sense;\r\nif (!(dev->caps.flags & MLX4_DEV_CAP_FLAG_DPDP))\r\nreturn;\r\nqueue_delayed_work(mlx4_wq , &sense->sense_poll,\r\nround_jiffies_relative(MLX4_SENSE_RANGE));\r\n}\r\nvoid mlx4_stop_sense(struct mlx4_dev *dev)\r\n{\r\ncancel_delayed_work_sync(&mlx4_priv(dev)->sense.sense_poll);\r\n}\r\nvoid mlx4_sense_init(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_sense *sense = &priv->sense;\r\nint port;\r\nsense->dev = dev;\r\nfor (port = 1; port <= dev->caps.num_ports; port++)\r\nsense->do_sense_port[port] = 1;\r\nINIT_DELAYED_WORK_DEFERRABLE(&sense->sense_poll, mlx4_sense_port);\r\n}
