static inline u32 ipic_read(volatile u32 __iomem *base, unsigned int reg)\r\n{\r\nreturn in_be32(base + (reg >> 2));\r\n}\r\nstatic inline void ipic_write(volatile u32 __iomem *base, unsigned int reg, u32 value)\r\n{\r\nout_be32(base + (reg >> 2), value);\r\n}\r\nstatic inline struct ipic * ipic_from_irq(unsigned int virq)\r\n{\r\nreturn primary_ipic;\r\n}\r\nstatic void ipic_unmask_irq(struct irq_data *d)\r\n{\r\nstruct ipic *ipic = ipic_from_irq(d->irq);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 temp;\r\nraw_spin_lock_irqsave(&ipic_lock, flags);\r\ntemp = ipic_read(ipic->regs, ipic_info[src].mask);\r\ntemp |= (1 << (31 - ipic_info[src].bit));\r\nipic_write(ipic->regs, ipic_info[src].mask, temp);\r\nraw_spin_unlock_irqrestore(&ipic_lock, flags);\r\n}\r\nstatic void ipic_mask_irq(struct irq_data *d)\r\n{\r\nstruct ipic *ipic = ipic_from_irq(d->irq);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 temp;\r\nraw_spin_lock_irqsave(&ipic_lock, flags);\r\ntemp = ipic_read(ipic->regs, ipic_info[src].mask);\r\ntemp &= ~(1 << (31 - ipic_info[src].bit));\r\nipic_write(ipic->regs, ipic_info[src].mask, temp);\r\nmb();\r\nraw_spin_unlock_irqrestore(&ipic_lock, flags);\r\n}\r\nstatic void ipic_ack_irq(struct irq_data *d)\r\n{\r\nstruct ipic *ipic = ipic_from_irq(d->irq);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 temp;\r\nraw_spin_lock_irqsave(&ipic_lock, flags);\r\ntemp = 1 << (31 - ipic_info[src].bit);\r\nipic_write(ipic->regs, ipic_info[src].ack, temp);\r\nmb();\r\nraw_spin_unlock_irqrestore(&ipic_lock, flags);\r\n}\r\nstatic void ipic_mask_irq_and_ack(struct irq_data *d)\r\n{\r\nstruct ipic *ipic = ipic_from_irq(d->irq);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 temp;\r\nraw_spin_lock_irqsave(&ipic_lock, flags);\r\ntemp = ipic_read(ipic->regs, ipic_info[src].mask);\r\ntemp &= ~(1 << (31 - ipic_info[src].bit));\r\nipic_write(ipic->regs, ipic_info[src].mask, temp);\r\ntemp = 1 << (31 - ipic_info[src].bit);\r\nipic_write(ipic->regs, ipic_info[src].ack, temp);\r\nmb();\r\nraw_spin_unlock_irqrestore(&ipic_lock, flags);\r\n}\r\nstatic int ipic_set_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct ipic *ipic = ipic_from_irq(d->irq);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned int vold, vnew, edibit;\r\nif (flow_type == IRQ_TYPE_NONE)\r\nflow_type = IRQ_TYPE_LEVEL_LOW;\r\nif (!(flow_type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_EDGE_FALLING))) {\r\nprintk(KERN_ERR "ipic: sense type 0x%x not supported\n",\r\nflow_type);\r\nreturn -EINVAL;\r\n}\r\nif ((flow_type & IRQ_TYPE_EDGE_FALLING) && !ipic_info[src].ack) {\r\nprintk(KERN_ERR "ipic: edge sense not supported on internal "\r\n"interrupts\n");\r\nreturn -EINVAL;\r\n}\r\nirqd_set_trigger_type(d, flow_type);\r\nif (flow_type & IRQ_TYPE_LEVEL_LOW) {\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\nd->chip = &ipic_level_irq_chip;\r\n} else {\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nd->chip = &ipic_edge_irq_chip;\r\n}\r\nif (src == IPIC_IRQ_EXT0)\r\nedibit = 15;\r\nelse\r\nif (src >= IPIC_IRQ_EXT1 && src <= IPIC_IRQ_EXT7)\r\nedibit = (14 - (src - IPIC_IRQ_EXT1));\r\nelse\r\nreturn (flow_type & IRQ_TYPE_LEVEL_LOW) ? 0 : -EINVAL;\r\nvold = ipic_read(ipic->regs, IPIC_SECNR);\r\nif ((flow_type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_FALLING) {\r\nvnew = vold | (1 << edibit);\r\n} else {\r\nvnew = vold & ~(1 << edibit);\r\n}\r\nif (vold != vnew)\r\nipic_write(ipic->regs, IPIC_SECNR, vnew);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\n}\r\nstatic int ipic_host_match(struct irq_host *h, struct device_node *node)\r\n{\r\nreturn h->of_node == NULL || h->of_node == node;\r\n}\r\nstatic int ipic_host_map(struct irq_host *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct ipic *ipic = h->host_data;\r\nirq_set_chip_data(virq, ipic);\r\nirq_set_chip_and_handler(virq, &ipic_level_irq_chip, handle_level_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int ipic_host_xlate(struct irq_host *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\n*out_hwirq = intspec[0];\r\nif (intsize > 1)\r\n*out_flags = intspec[1];\r\nelse\r\n*out_flags = IRQ_TYPE_NONE;\r\nreturn 0;\r\n}\r\nstruct ipic * __init ipic_init(struct device_node *node, unsigned int flags)\r\n{\r\nstruct ipic *ipic;\r\nstruct resource res;\r\nu32 temp = 0, ret;\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret)\r\nreturn NULL;\r\nipic = kzalloc(sizeof(*ipic), GFP_KERNEL);\r\nif (ipic == NULL)\r\nreturn NULL;\r\nipic->irqhost = irq_alloc_host(node, IRQ_HOST_MAP_LINEAR,\r\nNR_IPIC_INTS,\r\n&ipic_host_ops, 0);\r\nif (ipic->irqhost == NULL) {\r\nkfree(ipic);\r\nreturn NULL;\r\n}\r\nipic->regs = ioremap(res.start, resource_size(&res));\r\nipic->irqhost->host_data = ipic;\r\nipic_write(ipic->regs, IPIC_SICNR, 0x0);\r\nif (flags & IPIC_SPREADMODE_GRP_A)\r\ntemp |= SICFR_IPSA;\r\nif (flags & IPIC_SPREADMODE_GRP_B)\r\ntemp |= SICFR_IPSB;\r\nif (flags & IPIC_SPREADMODE_GRP_C)\r\ntemp |= SICFR_IPSC;\r\nif (flags & IPIC_SPREADMODE_GRP_D)\r\ntemp |= SICFR_IPSD;\r\nif (flags & IPIC_SPREADMODE_MIX_A)\r\ntemp |= SICFR_MPSA;\r\nif (flags & IPIC_SPREADMODE_MIX_B)\r\ntemp |= SICFR_MPSB;\r\nipic_write(ipic->regs, IPIC_SICFR, temp);\r\ntemp = 0;\r\nif (flags & IPIC_DISABLE_MCP_OUT)\r\ntemp = SERCR_MCPR;\r\nipic_write(ipic->regs, IPIC_SERCR, temp);\r\ntemp = ipic_read(ipic->regs, IPIC_SEMSR);\r\nif (flags & IPIC_IRQ0_MCP)\r\ntemp |= SEMSR_SIRQ0;\r\nelse\r\ntemp &= ~SEMSR_SIRQ0;\r\nipic_write(ipic->regs, IPIC_SEMSR, temp);\r\nprimary_ipic = ipic;\r\nirq_set_default_host(primary_ipic->irqhost);\r\nipic_write(ipic->regs, IPIC_SIMSR_H, 0);\r\nipic_write(ipic->regs, IPIC_SIMSR_L, 0);\r\nprintk ("IPIC (%d IRQ sources) at %p\n", NR_IPIC_INTS,\r\nprimary_ipic->regs);\r\nreturn ipic;\r\n}\r\nint ipic_set_priority(unsigned int virq, unsigned int priority)\r\n{\r\nstruct ipic *ipic = ipic_from_irq(virq);\r\nunsigned int src = virq_to_hw(virq);\r\nu32 temp;\r\nif (priority > 7)\r\nreturn -EINVAL;\r\nif (src > 127)\r\nreturn -EINVAL;\r\nif (ipic_info[src].prio == 0)\r\nreturn -EINVAL;\r\ntemp = ipic_read(ipic->regs, ipic_info[src].prio);\r\nif (priority < 4) {\r\ntemp &= ~(0x7 << (20 + (3 - priority) * 3));\r\ntemp |= ipic_info[src].prio_mask << (20 + (3 - priority) * 3);\r\n} else {\r\ntemp &= ~(0x7 << (4 + (7 - priority) * 3));\r\ntemp |= ipic_info[src].prio_mask << (4 + (7 - priority) * 3);\r\n}\r\nipic_write(ipic->regs, ipic_info[src].prio, temp);\r\nreturn 0;\r\n}\r\nvoid ipic_set_highest_priority(unsigned int virq)\r\n{\r\nstruct ipic *ipic = ipic_from_irq(virq);\r\nunsigned int src = virq_to_hw(virq);\r\nu32 temp;\r\ntemp = ipic_read(ipic->regs, IPIC_SICFR);\r\ntemp &= 0x7f000000;\r\ntemp |= (src & 0x7f) << 24;\r\nipic_write(ipic->regs, IPIC_SICFR, temp);\r\n}\r\nvoid ipic_set_default_priority(void)\r\n{\r\nipic_write(primary_ipic->regs, IPIC_SIPRR_A, IPIC_PRIORITY_DEFAULT);\r\nipic_write(primary_ipic->regs, IPIC_SIPRR_B, IPIC_PRIORITY_DEFAULT);\r\nipic_write(primary_ipic->regs, IPIC_SIPRR_C, IPIC_PRIORITY_DEFAULT);\r\nipic_write(primary_ipic->regs, IPIC_SIPRR_D, IPIC_PRIORITY_DEFAULT);\r\nipic_write(primary_ipic->regs, IPIC_SMPRR_A, IPIC_PRIORITY_DEFAULT);\r\nipic_write(primary_ipic->regs, IPIC_SMPRR_B, IPIC_PRIORITY_DEFAULT);\r\n}\r\nvoid ipic_enable_mcp(enum ipic_mcp_irq mcp_irq)\r\n{\r\nstruct ipic *ipic = primary_ipic;\r\nu32 temp;\r\ntemp = ipic_read(ipic->regs, IPIC_SERMR);\r\ntemp |= (1 << (31 - mcp_irq));\r\nipic_write(ipic->regs, IPIC_SERMR, temp);\r\n}\r\nvoid ipic_disable_mcp(enum ipic_mcp_irq mcp_irq)\r\n{\r\nstruct ipic *ipic = primary_ipic;\r\nu32 temp;\r\ntemp = ipic_read(ipic->regs, IPIC_SERMR);\r\ntemp &= (1 << (31 - mcp_irq));\r\nipic_write(ipic->regs, IPIC_SERMR, temp);\r\n}\r\nu32 ipic_get_mcp_status(void)\r\n{\r\nreturn ipic_read(primary_ipic->regs, IPIC_SERMR);\r\n}\r\nvoid ipic_clear_mcp_status(u32 mask)\r\n{\r\nipic_write(primary_ipic->regs, IPIC_SERMR, mask);\r\n}\r\nunsigned int ipic_get_irq(void)\r\n{\r\nint irq;\r\nBUG_ON(primary_ipic == NULL);\r\n#define IPIC_SIVCR_VECTOR_MASK 0x7f\r\nirq = ipic_read(primary_ipic->regs, IPIC_SIVCR) & IPIC_SIVCR_VECTOR_MASK;\r\nif (irq == 0)\r\nreturn NO_IRQ;\r\nreturn irq_linear_revmap(primary_ipic->irqhost, irq);\r\n}\r\nstatic int ipic_suspend(void)\r\n{\r\nstruct ipic *ipic = primary_ipic;\r\nipic_saved_state.sicfr = ipic_read(ipic->regs, IPIC_SICFR);\r\nipic_saved_state.siprr[0] = ipic_read(ipic->regs, IPIC_SIPRR_A);\r\nipic_saved_state.siprr[1] = ipic_read(ipic->regs, IPIC_SIPRR_D);\r\nipic_saved_state.simsr[0] = ipic_read(ipic->regs, IPIC_SIMSR_H);\r\nipic_saved_state.simsr[1] = ipic_read(ipic->regs, IPIC_SIMSR_L);\r\nipic_saved_state.sicnr = ipic_read(ipic->regs, IPIC_SICNR);\r\nipic_saved_state.smprr[0] = ipic_read(ipic->regs, IPIC_SMPRR_A);\r\nipic_saved_state.smprr[1] = ipic_read(ipic->regs, IPIC_SMPRR_B);\r\nipic_saved_state.semsr = ipic_read(ipic->regs, IPIC_SEMSR);\r\nipic_saved_state.secnr = ipic_read(ipic->regs, IPIC_SECNR);\r\nipic_saved_state.sermr = ipic_read(ipic->regs, IPIC_SERMR);\r\nipic_saved_state.sercr = ipic_read(ipic->regs, IPIC_SERCR);\r\nif (fsl_deep_sleep()) {\r\nipic_write(ipic->regs, IPIC_SIMSR_H, 0);\r\nipic_write(ipic->regs, IPIC_SIMSR_L, 0);\r\nipic_write(ipic->regs, IPIC_SEMSR, 0);\r\nipic_write(ipic->regs, IPIC_SERMR, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipic_resume(void)\r\n{\r\nstruct ipic *ipic = primary_ipic;\r\nipic_write(ipic->regs, IPIC_SICFR, ipic_saved_state.sicfr);\r\nipic_write(ipic->regs, IPIC_SIPRR_A, ipic_saved_state.siprr[0]);\r\nipic_write(ipic->regs, IPIC_SIPRR_D, ipic_saved_state.siprr[1]);\r\nipic_write(ipic->regs, IPIC_SIMSR_H, ipic_saved_state.simsr[0]);\r\nipic_write(ipic->regs, IPIC_SIMSR_L, ipic_saved_state.simsr[1]);\r\nipic_write(ipic->regs, IPIC_SICNR, ipic_saved_state.sicnr);\r\nipic_write(ipic->regs, IPIC_SMPRR_A, ipic_saved_state.smprr[0]);\r\nipic_write(ipic->regs, IPIC_SMPRR_B, ipic_saved_state.smprr[1]);\r\nipic_write(ipic->regs, IPIC_SEMSR, ipic_saved_state.semsr);\r\nipic_write(ipic->regs, IPIC_SECNR, ipic_saved_state.secnr);\r\nipic_write(ipic->regs, IPIC_SERMR, ipic_saved_state.sermr);\r\nipic_write(ipic->regs, IPIC_SERCR, ipic_saved_state.sercr);\r\n}\r\nstatic int __init init_ipic_syscore(void)\r\n{\r\nif (!primary_ipic || !primary_ipic->regs)\r\nreturn -ENODEV;\r\nprintk(KERN_DEBUG "Registering ipic system core operations\n");\r\nregister_syscore_ops(&ipic_syscore_ops);\r\nreturn 0;\r\n}
