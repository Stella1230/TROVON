static int prng_open(struct inode *inode, struct file *file)\r\n{\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic void prng_add_entropy(void)\r\n{\r\n__u64 entropy[4];\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < 16; i++) {\r\nret = crypt_s390_kmc(KMC_PRNG, parm_block, (char *)entropy,\r\n(char *)entropy, sizeof(entropy));\r\nBUG_ON(ret < 0 || ret != sizeof(entropy));\r\nmemcpy(parm_block, entropy, sizeof(entropy));\r\n}\r\n}\r\nstatic void prng_seed(int nbytes)\r\n{\r\nchar buf[16];\r\nint i = 0;\r\nBUG_ON(nbytes > 16);\r\nget_random_bytes(buf, nbytes);\r\nwhile (nbytes >= 8) {\r\n*((__u64 *)parm_block) ^= *((__u64 *)(buf+i));\r\nprng_add_entropy();\r\ni += 8;\r\nnbytes -= 8;\r\n}\r\nprng_add_entropy();\r\n}\r\nstatic ssize_t prng_read(struct file *file, char __user *ubuf, size_t nbytes,\r\nloff_t *ppos)\r\n{\r\nint chunk, n;\r\nint ret = 0;\r\nint tmp;\r\nwhile (nbytes) {\r\nif (need_resched()) {\r\nif (signal_pending(current)) {\r\nif (ret == 0)\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nchunk = min_t(int, nbytes, prng_chunk_size);\r\nn = (chunk + 7) & -8;\r\nif (p->count > prng_entropy_limit)\r\nprng_seed(8);\r\nasm volatile(".insn s,0xb27c0000,%0"\r\n: "=m" (*((unsigned long long *)p->buf)) : : "cc");\r\ntmp = crypt_s390_kmc(KMC_PRNG, parm_block, p->buf, p->buf, n);\r\nBUG_ON((tmp < 0) || (tmp != n));\r\np->count += n;\r\nif (copy_to_user(ubuf, p->buf, chunk))\r\nreturn -EFAULT;\r\nnbytes -= chunk;\r\nret += chunk;\r\nubuf += chunk;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init prng_init(void)\r\n{\r\nint ret;\r\nif (!crypt_s390_func_available(KMC_PRNG, CRYPT_S390_MSA))\r\nreturn -EOPNOTSUPP;\r\nif (prng_chunk_size < 8)\r\nreturn -EINVAL;\r\np = kmalloc(sizeof(struct s390_prng_data), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->count = 0;\r\np->buf = kmalloc(prng_chunk_size, GFP_KERNEL);\r\nif (!p->buf) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nprng_seed(16);\r\nret = misc_register(&prng_dev);\r\nif (ret)\r\ngoto out_buf;\r\nreturn 0;\r\nout_buf:\r\nkfree(p->buf);\r\nout_free:\r\nkfree(p);\r\nreturn ret;\r\n}\r\nstatic void __exit prng_exit(void)\r\n{\r\nkzfree(p->buf);\r\nkfree(p);\r\nmisc_deregister(&prng_dev);\r\n}
