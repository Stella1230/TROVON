static int intel_sst_check_device(void)\r\n{\r\nint retval = 0;\r\nif (sst_drv_ctx->pmic_state != SND_MAD_INIT_DONE) {\r\npr_warn("Sound card not available\n");\r\nreturn -EIO;\r\n}\r\nif (sst_drv_ctx->sst_state == SST_SUSPENDED) {\r\npr_debug("Resuming from Suspended state\n");\r\nretval = intel_sst_resume(sst_drv_ctx->pci);\r\nif (retval) {\r\npr_debug("Resume Failed= %#x,abort\n", retval);\r\nreturn retval;\r\n}\r\n}\r\nif (sst_drv_ctx->sst_state == SST_UN_INIT) {\r\nretval = sst_download_fw();\r\nif (retval)\r\nreturn -ENODEV;\r\nif (sst_drv_ctx->pci_id == SST_MRST_PCI_ID) {\r\nretval = sst_drv_ctx->rx_time_slot_status;\r\nif (retval != RX_TIMESLOT_UNINIT\r\n&& sst_drv_ctx->pmic_vendor != SND_NC)\r\nsst_enable_rx_timeslot(retval);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint intel_sst_open(struct inode *i_node, struct file *file_ptr)\r\n{\r\nunsigned int retval;\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\npm_runtime_get_sync(&sst_drv_ctx->pci->dev);\r\nretval = intel_sst_check_device();\r\nif (retval) {\r\npm_runtime_put(&sst_drv_ctx->pci->dev);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\nreturn retval;\r\n}\r\nif (sst_drv_ctx->encoded_cnt < MAX_ENC_STREAM) {\r\nstruct ioctl_pvt_data *data =\r\nkzalloc(sizeof(struct ioctl_pvt_data), GFP_KERNEL);\r\nif (!data) {\r\npm_runtime_put(&sst_drv_ctx->pci->dev);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\nreturn -ENOMEM;\r\n}\r\nsst_drv_ctx->encoded_cnt++;\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\ndata->pvt_id = sst_assign_pvt_id(sst_drv_ctx);\r\ndata->str_id = 0;\r\nfile_ptr->private_data = (void *)data;\r\npr_debug("pvt_id handle = %d!\n", data->pvt_id);\r\n} else {\r\nretval = -EUSERS;\r\npm_runtime_put(&sst_drv_ctx->pci->dev);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\n}\r\nreturn retval;\r\n}\r\nint intel_sst_open_cntrl(struct inode *i_node, struct file *file_ptr)\r\n{\r\nunsigned int retval;\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\npm_runtime_get_sync(&sst_drv_ctx->pci->dev);\r\nretval = intel_sst_check_device();\r\nif (retval) {\r\npm_runtime_put(&sst_drv_ctx->pci->dev);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\nreturn retval;\r\n}\r\nif (sst_drv_ctx->am_cnt < MAX_AM_HANDLES) {\r\nsst_drv_ctx->am_cnt++;\r\npr_debug("AM handle opened...\n");\r\nfile_ptr->private_data = NULL;\r\n} else {\r\nretval = -EACCES;\r\npm_runtime_put(&sst_drv_ctx->pci->dev);\r\n}\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\nreturn retval;\r\n}\r\nint intel_sst_release(struct inode *i_node, struct file *file_ptr)\r\n{\r\nstruct ioctl_pvt_data *data = file_ptr->private_data;\r\npr_debug("Release called, closing app handle\n");\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nsst_drv_ctx->encoded_cnt--;\r\nsst_drv_ctx->stream_cnt--;\r\npm_runtime_put(&sst_drv_ctx->pci->dev);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\nfree_stream_context(data->str_id);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nint intel_sst_release_cntrl(struct inode *i_node, struct file *file_ptr)\r\n{\r\nmutex_lock(&sst_drv_ctx->stream_lock);\r\nsst_drv_ctx->am_cnt--;\r\npm_runtime_put(&sst_drv_ctx->pci->dev);\r\nmutex_unlock(&sst_drv_ctx->stream_lock);\r\npr_debug("AM handle closed\n");\r\nreturn 0;\r\n}\r\nint intel_sst_mmap(struct file *file_ptr, struct vm_area_struct *vma)\r\n{\r\nint retval, length;\r\nstruct ioctl_pvt_data *data =\r\n(struct ioctl_pvt_data *)file_ptr->private_data;\r\nint str_id = data->str_id;\r\nvoid *mem_area;\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn -EINVAL;\r\nlength = vma->vm_end - vma->vm_start;\r\npr_debug("called for stream %d length 0x%x\n", str_id, length);\r\nif (length > sst_drv_ctx->mmap_len)\r\nreturn -ENOMEM;\r\nif (!sst_drv_ctx->mmap_mem)\r\nreturn -EIO;\r\nmem_area = (void *) PAGE_ALIGN((unsigned int) sst_drv_ctx->mmap_mem);\r\nretval = remap_pfn_range(vma,\r\nvma->vm_start,\r\nvirt_to_phys((void *)mem_area) >> PAGE_SHIFT,\r\nlength,\r\nvma->vm_page_prot);\r\nif (retval)\r\nsst_drv_ctx->streams[str_id].mmapped = false;\r\nelse\r\nsst_drv_ctx->streams[str_id].mmapped = true;\r\npr_debug("mmap ret 0x%x\n", retval);\r\nreturn retval;\r\n}\r\nstatic int intel_sst_mmap_play_capture(u32 str_id,\r\nstruct snd_sst_mmap_buffs *mmap_buf)\r\n{\r\nstruct sst_stream_bufs *bufs;\r\nint retval, i;\r\nstruct stream_info *stream;\r\nstruct snd_sst_mmap_buff_entry *buf_entry;\r\nstruct snd_sst_mmap_buff_entry *tmp_buf;\r\npr_debug("called for str_id %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn -EINVAL;\r\nstream = &sst_drv_ctx->streams[str_id];\r\nif (stream->mmapped != true)\r\nreturn -EIO;\r\nif (stream->status == STREAM_UN_INIT ||\r\nstream->status == STREAM_DECODE) {\r\nreturn -EBADRQC;\r\n}\r\nstream->curr_bytes = 0;\r\nstream->cumm_bytes = 0;\r\ntmp_buf = kcalloc(mmap_buf->entries, sizeof(*tmp_buf), GFP_KERNEL);\r\nif (!tmp_buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(tmp_buf, (void __user *)mmap_buf->buff,\r\nmmap_buf->entries * sizeof(*tmp_buf))) {\r\nretval = -EFAULT;\r\ngoto out_free;\r\n}\r\npr_debug("new buffers count %d status %d\n",\r\nmmap_buf->entries, stream->status);\r\nbuf_entry = tmp_buf;\r\nfor (i = 0; i < mmap_buf->entries; i++) {\r\nbufs = kzalloc(sizeof(*bufs), GFP_KERNEL);\r\nif (!bufs) {\r\nretval = -ENOMEM;\r\ngoto out_free;\r\n}\r\nbufs->size = buf_entry->size;\r\nbufs->offset = buf_entry->offset;\r\nbufs->addr = sst_drv_ctx->mmap_mem;\r\nbufs->in_use = false;\r\nbuf_entry++;\r\nmutex_lock(&stream->lock);\r\nlist_add_tail(&bufs->node, &stream->bufs);\r\nmutex_unlock(&stream->lock);\r\n}\r\nmutex_lock(&stream->lock);\r\nstream->data_blk.condition = false;\r\nstream->data_blk.ret_code = 0;\r\nif (stream->status == STREAM_INIT &&\r\nstream->prev != STREAM_UN_INIT &&\r\nstream->need_draining != true) {\r\nstream->prev = stream->status;\r\nstream->status = STREAM_RUNNING;\r\nif (stream->ops == STREAM_OPS_PLAYBACK) {\r\nif (sst_play_frame(str_id) < 0) {\r\npr_warn("play frames fail\n");\r\nmutex_unlock(&stream->lock);\r\nretval = -EIO;\r\ngoto out_free;\r\n}\r\n} else if (stream->ops == STREAM_OPS_CAPTURE) {\r\nif (sst_capture_frame(str_id) < 0) {\r\npr_warn("capture frame fail\n");\r\nmutex_unlock(&stream->lock);\r\nretval = -EIO;\r\ngoto out_free;\r\n}\r\n}\r\n}\r\nmutex_unlock(&stream->lock);\r\nif (!list_empty(&stream->bufs)) {\r\nstream->data_blk.on = true;\r\nretval = sst_wait_interruptible(sst_drv_ctx,\r\n&stream->data_blk);\r\n}\r\nif (retval >= 0)\r\nretval = stream->cumm_bytes;\r\npr_debug("end of play/rec ioctl bytes = %d!!\n", retval);\r\nout_free:\r\nkfree(tmp_buf);\r\nreturn retval;\r\n}\r\nstatic int intel_sst_play_capture(struct stream_info *stream, int str_id)\r\n{\r\nint retval;\r\nstream->data_blk.ret_code = 0;\r\nstream->data_blk.on = true;\r\nstream->data_blk.condition = false;\r\nmutex_lock(&stream->lock);\r\nif (stream->status == STREAM_INIT && stream->prev != STREAM_UN_INIT) {\r\nstream->prev = stream->status;\r\nstream->status = STREAM_RUNNING;\r\n}\r\nif (stream->status == STREAM_INIT && stream->prev == STREAM_UN_INIT) {\r\npr_debug("Stream isn't in started state %d, prev %d\n",\r\nstream->status, stream->prev);\r\n} else if ((stream->status == STREAM_RUNNING ||\r\nstream->status == STREAM_PAUSED) &&\r\nstream->need_draining != true) {\r\nif (stream->ops == STREAM_OPS_PLAYBACK ||\r\nstream->ops == STREAM_OPS_PLAYBACK_DRM) {\r\nif (sst_play_frame(str_id) < 0) {\r\npr_warn("play frames failed\n");\r\nmutex_unlock(&stream->lock);\r\nreturn -EIO;\r\n}\r\n} else if (stream->ops == STREAM_OPS_CAPTURE) {\r\nif (sst_capture_frame(str_id) < 0) {\r\npr_warn("capture frames failed\n");\r\nmutex_unlock(&stream->lock);\r\nreturn -EIO;\r\n}\r\n}\r\n} else {\r\nmutex_unlock(&stream->lock);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&stream->lock);\r\nretval = sst_wait_interruptible(sst_drv_ctx, &stream->data_blk);\r\nif (retval) {\r\nstream->status = STREAM_INIT;\r\npr_debug("wait returned error...\n");\r\n}\r\nreturn retval;\r\n}\r\nstatic int snd_sst_fill_kernel_list(struct stream_info *stream,\r\nconst struct iovec *iovec, unsigned long nr_segs,\r\nstruct list_head *copy_to_list)\r\n{\r\nstruct sst_stream_bufs *stream_bufs;\r\nunsigned long index, mmap_len;\r\nunsigned char __user *bufp;\r\nunsigned long size, copied_size;\r\nint retval = 0, add_to_list = 0;\r\nstatic int sent_offset;\r\nstatic unsigned long sent_index;\r\n#ifdef CONFIG_MRST_RAR_HANDLER\r\nif (stream->ops == STREAM_OPS_PLAYBACK_DRM) {\r\nfor (index = stream->sg_index; index < nr_segs; index++) {\r\n__u32 rar_handle;\r\nstruct sst_stream_bufs *stream_bufs =\r\nkzalloc(sizeof(*stream_bufs), GFP_KERNEL);\r\nstream->sg_index = index;\r\nif (!stream_bufs)\r\nreturn -ENOMEM;\r\nif (copy_from_user((void *) &rar_handle,\r\niovec[index].iov_base,\r\nsizeof(__u32))) {\r\nkfree(stream_bufs);\r\nreturn -EFAULT;\r\n}\r\nstream_bufs->addr = (char *)rar_handle;\r\nstream_bufs->in_use = false;\r\nstream_bufs->size = iovec[0].iov_len;\r\nmutex_lock(&stream->lock);\r\nlist_add_tail(&stream_bufs->node, &stream->bufs);\r\nmutex_unlock(&stream->lock);\r\n}\r\nstream->sg_index = index;\r\nreturn retval;\r\n}\r\n#endif\r\nstream_bufs = kzalloc(sizeof(*stream_bufs), GFP_KERNEL);\r\nif (!stream_bufs)\r\nreturn -ENOMEM;\r\nstream_bufs->addr = sst_drv_ctx->mmap_mem;\r\nmmap_len = sst_drv_ctx->mmap_len;\r\nstream_bufs->addr = sst_drv_ctx->mmap_mem;\r\nbufp = stream->cur_ptr;\r\ncopied_size = 0;\r\nif (!stream->sg_index)\r\nsent_index = sent_offset = 0;\r\nfor (index = stream->sg_index; index < nr_segs; index++) {\r\nstream->sg_index = index;\r\nif (!stream->cur_ptr)\r\nbufp = iovec[index].iov_base;\r\nsize = ((unsigned long)iovec[index].iov_base\r\n+ iovec[index].iov_len) - (unsigned long) bufp;\r\nif ((copied_size + size) > mmap_len)\r\nsize = mmap_len - copied_size;\r\nif (stream->ops == STREAM_OPS_PLAYBACK) {\r\nif (copy_from_user((void *)\r\n(stream_bufs->addr + copied_size),\r\nbufp, size)) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\n} else if (stream->ops == STREAM_OPS_CAPTURE) {\r\nstruct snd_sst_user_cap_list *entry =\r\nkzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nkfree(stream_bufs);\r\nreturn -ENOMEM;\r\n}\r\nentry->iov_index = index;\r\nentry->iov_offset = (unsigned long) bufp -\r\n(unsigned long)iovec[index].iov_base;\r\nentry->offset = copied_size;\r\nentry->size = size;\r\nlist_add_tail(&entry->node, copy_to_list);\r\n}\r\nstream->cur_ptr = bufp + size;\r\nif (((unsigned long)iovec[index].iov_base\r\n+ iovec[index].iov_len) <\r\n((unsigned long)iovec[index].iov_base)) {\r\npr_debug("Buffer overflows\n");\r\nkfree(stream_bufs);\r\nreturn -EINVAL;\r\n}\r\nif (((unsigned long)iovec[index].iov_base\r\n+ iovec[index].iov_len) ==\r\n(unsigned long)stream->cur_ptr) {\r\nstream->cur_ptr = NULL;\r\nstream->sg_index++;\r\n}\r\ncopied_size += size;\r\npr_debug("copied_size - %lx\n", copied_size);\r\nif ((copied_size >= mmap_len) ||\r\n(stream->sg_index == nr_segs)) {\r\nadd_to_list = 1;\r\n}\r\nif (add_to_list) {\r\nstream_bufs->in_use = false;\r\nstream_bufs->size = copied_size;\r\nmutex_lock(&stream->lock);\r\nlist_add_tail(&stream_bufs->node, &stream->bufs);\r\nmutex_unlock(&stream->lock);\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int snd_sst_copy_userbuf_capture(struct stream_info *stream,\r\nconst struct iovec *iovec,\r\nstruct list_head *copy_to_list)\r\n{\r\nstruct snd_sst_user_cap_list *entry, *_entry;\r\nstruct sst_stream_bufs *kbufs = NULL, *_kbufs;\r\nint retval = 0;\r\npr_debug("capture stream copying to user now...\n");\r\nlist_for_each_entry_safe(kbufs, _kbufs, &stream->bufs, node) {\r\nif (kbufs->in_use == true) {\r\nlist_for_each_entry_safe(entry, _entry,\r\ncopy_to_list, node) {\r\nif (copy_to_user(iovec[entry->iov_index].iov_base + entry->iov_offset,\r\nkbufs->addr + entry->offset,\r\nentry->size)) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nlist_del(&entry->node);\r\nkfree(entry);\r\n}\r\n}\r\n}\r\npr_debug("end of cap copy\n");\r\nreturn retval;\r\n}\r\nstatic int snd_sst_userbufs_play_cap(const struct iovec *iovec,\r\nunsigned long nr_segs, unsigned int str_id,\r\nstruct stream_info *stream)\r\n{\r\nint retval;\r\nLIST_HEAD(copy_to_list);\r\nretval = snd_sst_fill_kernel_list(stream, iovec, nr_segs,\r\n&copy_to_list);\r\nretval = intel_sst_play_capture(stream, str_id);\r\nif (retval < 0)\r\nreturn retval;\r\nif (stream->ops == STREAM_OPS_CAPTURE) {\r\nretval = snd_sst_copy_userbuf_capture(stream, iovec,\r\n&copy_to_list);\r\n}\r\nreturn retval;\r\n}\r\nstatic int intel_sst_read_write(unsigned int str_id, char __user *buf,\r\nsize_t count)\r\n{\r\nint retval;\r\nstruct stream_info *stream;\r\nstruct iovec iovec;\r\nunsigned long nr_segs;\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn -EINVAL;\r\nstream = &sst_drv_ctx->streams[str_id];\r\nif (stream->mmapped == true) {\r\npr_warn("user write and stream is mapped\n");\r\nreturn -EIO;\r\n}\r\nif (!count)\r\nreturn -EINVAL;\r\nstream->curr_bytes = 0;\r\nstream->cumm_bytes = 0;\r\npr_debug("new buffers %p, copy size %d, status %d\n" ,\r\nbuf, (int) count, (int) stream->status);\r\nstream->buf_type = SST_BUF_USER_STATIC;\r\niovec.iov_base = buf;\r\niovec.iov_len = count;\r\nnr_segs = 1;\r\ndo {\r\nretval = snd_sst_userbufs_play_cap(\r\n&iovec, nr_segs, str_id, stream);\r\nif (retval < 0)\r\nbreak;\r\n} while (stream->sg_index < nr_segs);\r\nstream->sg_index = 0;\r\nstream->cur_ptr = NULL;\r\nif (retval >= 0)\r\nretval = stream->cumm_bytes;\r\npr_debug("end of play/rec bytes = %d!!\n", retval);\r\nreturn retval;\r\n}\r\nint intel_sst_write(struct file *file_ptr, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct ioctl_pvt_data *data = file_ptr->private_data;\r\nint str_id = data->str_id;\r\nstruct stream_info *stream = &sst_drv_ctx->streams[str_id];\r\npr_debug("called for %d\n", str_id);\r\nif (stream->status == STREAM_UN_INIT ||\r\nstream->status == STREAM_DECODE) {\r\nreturn -EBADRQC;\r\n}\r\nreturn intel_sst_read_write(str_id, (char __user *)buf, count);\r\n}\r\nssize_t intel_sst_aio_write(struct kiocb *kiocb, const struct iovec *iov,\r\nunsigned long nr_segs, loff_t offset)\r\n{\r\nint retval;\r\nstruct ioctl_pvt_data *data = kiocb->ki_filp->private_data;\r\nint str_id = data->str_id;\r\nstruct stream_info *stream;\r\npr_debug("entry - %ld\n", nr_segs);\r\nif (is_sync_kiocb(kiocb) == false)\r\nreturn -EINVAL;\r\npr_debug("called for str_id %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn -EINVAL;\r\nstream = &sst_drv_ctx->streams[str_id];\r\nif (stream->mmapped == true)\r\nreturn -EIO;\r\nif (stream->status == STREAM_UN_INIT ||\r\nstream->status == STREAM_DECODE) {\r\nreturn -EBADRQC;\r\n}\r\nstream->curr_bytes = 0;\r\nstream->cumm_bytes = 0;\r\npr_debug("new segs %ld, offset %d, status %d\n" ,\r\nnr_segs, (int) offset, (int) stream->status);\r\nstream->buf_type = SST_BUF_USER_STATIC;\r\ndo {\r\nretval = snd_sst_userbufs_play_cap(iov, nr_segs,\r\nstr_id, stream);\r\nif (retval < 0)\r\nbreak;\r\n} while (stream->sg_index < nr_segs);\r\nstream->sg_index = 0;\r\nstream->cur_ptr = NULL;\r\nif (retval >= 0)\r\nretval = stream->cumm_bytes;\r\npr_debug("end of play/rec bytes = %d!!\n", retval);\r\nreturn retval;\r\n}\r\nint intel_sst_read(struct file *file_ptr, char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct ioctl_pvt_data *data = file_ptr->private_data;\r\nint str_id = data->str_id;\r\nstruct stream_info *stream = &sst_drv_ctx->streams[str_id];\r\npr_debug("called for %d\n", str_id);\r\nif (stream->status == STREAM_UN_INIT ||\r\nstream->status == STREAM_DECODE)\r\nreturn -EBADRQC;\r\nreturn intel_sst_read_write(str_id, buf, count);\r\n}\r\nssize_t intel_sst_aio_read(struct kiocb *kiocb, const struct iovec *iov,\r\nunsigned long nr_segs, loff_t offset)\r\n{\r\nint retval;\r\nstruct ioctl_pvt_data *data = kiocb->ki_filp->private_data;\r\nint str_id = data->str_id;\r\nstruct stream_info *stream;\r\npr_debug("entry - %ld\n", nr_segs);\r\nif (is_sync_kiocb(kiocb) == false) {\r\npr_debug("aio_read from user space is not allowed\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("called for str_id %d\n", str_id);\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nreturn -EINVAL;\r\nstream = &sst_drv_ctx->streams[str_id];\r\nif (stream->mmapped == true)\r\nreturn -EIO;\r\nif (stream->status == STREAM_UN_INIT ||\r\nstream->status == STREAM_DECODE)\r\nreturn -EBADRQC;\r\nstream->curr_bytes = 0;\r\nstream->cumm_bytes = 0;\r\npr_debug("new segs %ld, offset %d, status %d\n" ,\r\nnr_segs, (int) offset, (int) stream->status);\r\nstream->buf_type = SST_BUF_USER_STATIC;\r\ndo {\r\nretval = snd_sst_userbufs_play_cap(iov, nr_segs,\r\nstr_id, stream);\r\nif (retval < 0)\r\nbreak;\r\n} while (stream->sg_index < nr_segs);\r\nstream->sg_index = 0;\r\nstream->cur_ptr = NULL;\r\nif (retval >= 0)\r\nretval = stream->cumm_bytes;\r\npr_debug("end of play/rec bytes = %d!!\n", retval);\r\nreturn retval;\r\n}\r\nstatic void sst_print_stream_params(struct snd_sst_get_stream_params *get_prm)\r\n{\r\npr_debug("codec params:result = %d\n",\r\nget_prm->codec_params.result);\r\npr_debug("codec params:stream = %d\n",\r\nget_prm->codec_params.stream_id);\r\npr_debug("codec params:codec = %d\n",\r\nget_prm->codec_params.codec);\r\npr_debug("codec params:ops = %d\n",\r\nget_prm->codec_params.ops);\r\npr_debug("codec params:stream_type = %d\n",\r\nget_prm->codec_params.stream_type);\r\npr_debug("pcmparams:sfreq = %d\n",\r\nget_prm->pcm_params.sfreq);\r\npr_debug("pcmparams:num_chan = %d\n",\r\nget_prm->pcm_params.num_chan);\r\npr_debug("pcmparams:pcm_wd_sz = %d\n",\r\nget_prm->pcm_params.pcm_wd_sz);\r\nreturn;\r\n}\r\nint sst_create_algo_ipc(struct snd_ppp_params *algo_params,\r\nstruct ipc_post **msg)\r\n{\r\nif (sst_create_large_msg(msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&(*msg)->header,\r\nIPC_IA_ALG_PARAMS, 1, algo_params->str_id);\r\n(*msg)->header.part.data = sizeof(u32) +\r\nsizeof(*algo_params) + algo_params->size;\r\nmemcpy((*msg)->mailbox_data, &(*msg)->header, sizeof(u32));\r\nmemcpy((*msg)->mailbox_data + sizeof(u32),\r\nalgo_params, sizeof(*algo_params));\r\nreturn 0;\r\n}\r\nint sst_send_algo_ipc(struct ipc_post **msg)\r\n{\r\nsst_drv_ctx->ppp_params_blk.condition = false;\r\nsst_drv_ctx->ppp_params_blk.ret_code = 0;\r\nsst_drv_ctx->ppp_params_blk.on = true;\r\nsst_drv_ctx->ppp_params_blk.data = NULL;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&(*msg)->node, &sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nreturn sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&sst_drv_ctx->ppp_params_blk, SST_BLOCK_TIMEOUT);\r\n}\r\nlong intel_sst_ioctl_dsp(unsigned int cmd, unsigned long arg)\r\n{\r\nint retval = 0;\r\nstruct snd_ppp_params algo_params;\r\nstruct snd_ppp_params *algo_params_copied;\r\nstruct ipc_post *msg;\r\nswitch (_IOC_NR(cmd)) {\r\ncase _IOC_NR(SNDRV_SST_SET_ALGO):\r\nif (copy_from_user(&algo_params, (void __user *)arg,\r\nsizeof(algo_params)))\r\nreturn -EFAULT;\r\nif (algo_params.size > SST_MAILBOX_SIZE)\r\nreturn -EMSGSIZE;\r\npr_debug("Algo ID %d Str id %d Enable %d Size %d\n",\r\nalgo_params.algo_id, algo_params.str_id,\r\nalgo_params.enable, algo_params.size);\r\nretval = sst_create_algo_ipc(&algo_params, &msg);\r\nif (retval)\r\nbreak;\r\nalgo_params.reserved = 0;\r\nif (copy_from_user(msg->mailbox_data + sizeof(algo_params),\r\nalgo_params.params, algo_params.size))\r\nreturn -EFAULT;\r\nretval = sst_send_algo_ipc(&msg);\r\nif (retval) {\r\npr_debug("Error in sst_set_algo = %d\n", retval);\r\nretval = -EIO;\r\n}\r\nbreak;\r\ncase _IOC_NR(SNDRV_SST_GET_ALGO):\r\nif (copy_from_user(&algo_params, (void __user *)arg,\r\nsizeof(algo_params)))\r\nreturn -EFAULT;\r\npr_debug("Algo ID %d Str id %d Enable %d Size %d\n",\r\nalgo_params.algo_id, algo_params.str_id,\r\nalgo_params.enable, algo_params.size);\r\nretval = sst_create_algo_ipc(&algo_params, &msg);\r\nif (retval)\r\nbreak;\r\nalgo_params.reserved = 1;\r\nretval = sst_send_algo_ipc(&msg);\r\nif (retval) {\r\npr_debug("Error in sst_get_algo = %d\n", retval);\r\nretval = -EIO;\r\nbreak;\r\n}\r\nalgo_params_copied = (struct snd_ppp_params *)\r\nsst_drv_ctx->ppp_params_blk.data;\r\nif (algo_params_copied->size > algo_params.size) {\r\npr_debug("mem insufficient to copy\n");\r\nretval = -EMSGSIZE;\r\ngoto free_mem;\r\n} else {\r\nchar __user *tmp;\r\nif (copy_to_user(algo_params.params,\r\nalgo_params_copied->params,\r\nalgo_params_copied->size)) {\r\nretval = -EFAULT;\r\ngoto free_mem;\r\n}\r\ntmp = (char __user *)arg + offsetof(\r\nstruct snd_ppp_params, size);\r\nif (copy_to_user(tmp, &algo_params_copied->size,\r\nsizeof(__u32))) {\r\nretval = -EFAULT;\r\ngoto free_mem;\r\n}\r\n}\r\nfree_mem:\r\nkfree(algo_params_copied->params);\r\nkfree(algo_params_copied);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nint sst_ioctl_tuning_params(unsigned long arg)\r\n{\r\nstruct snd_sst_tuning_params params;\r\nstruct ipc_post *msg;\r\nif (copy_from_user(&params, (void __user *)arg, sizeof(params)))\r\nreturn -EFAULT;\r\nif (params.size > SST_MAILBOX_SIZE)\r\nreturn -ENOMEM;\r\npr_debug("Parameter %d, Stream %d, Size %d\n", params.type,\r\nparams.str_id, params.size);\r\nif (sst_create_large_msg(&msg))\r\nreturn -ENOMEM;\r\nsst_fill_header(&msg->header, IPC_IA_TUNING_PARAMS, 1, params.str_id);\r\nmsg->header.part.data = sizeof(u32) + sizeof(params) + params.size;\r\nmemcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));\r\nmemcpy(msg->mailbox_data + sizeof(u32), &params, sizeof(params));\r\nif (copy_from_user(msg->mailbox_data + sizeof(params),\r\n(void __user *)(unsigned long)params.addr,\r\nparams.size)) {\r\nkfree(msg->mailbox_data);\r\nkfree(msg);\r\nreturn -EFAULT;\r\n}\r\nreturn sst_send_algo_ipc(&msg);\r\n}\r\nlong intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)\r\n{\r\nint retval = 0;\r\nstruct ioctl_pvt_data *data = NULL;\r\nint str_id = 0, minor = 0;\r\ndata = file_ptr->private_data;\r\nif (data) {\r\nminor = 0;\r\nstr_id = data->str_id;\r\n} else\r\nminor = 1;\r\nif (sst_drv_ctx->sst_state != SST_FW_RUNNING)\r\nreturn -EBUSY;\r\nswitch (_IOC_NR(cmd)) {\r\ncase _IOC_NR(SNDRV_SST_STREAM_PAUSE):\r\npr_debug("IOCTL_PAUSE received for %d!\n", str_id);\r\nif (minor != STREAM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nretval = sst_pause_stream(str_id);\r\nbreak;\r\ncase _IOC_NR(SNDRV_SST_STREAM_RESUME):\r\npr_debug("SNDRV_SST_IOCTL_RESUME received!\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nretval = sst_resume_stream(str_id);\r\nbreak;\r\ncase _IOC_NR(SNDRV_SST_STREAM_SET_PARAMS): {\r\nstruct snd_sst_params str_param;\r\npr_debug("IOCTL_SET_PARAMS received!\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nif (copy_from_user(&str_param, (void __user *)arg,\r\nsizeof(str_param))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nif (!str_id) {\r\nretval = sst_get_stream(&str_param);\r\nif (retval > 0) {\r\nstruct stream_info *str_info;\r\nchar __user *dest;\r\nsst_drv_ctx->stream_cnt++;\r\ndata->str_id = retval;\r\nstr_info = &sst_drv_ctx->streams[retval];\r\nstr_info->src = SST_DRV;\r\ndest = (char __user *)arg + offsetof(struct snd_sst_params, stream_id);\r\nretval = copy_to_user(dest, &retval, sizeof(__u32));\r\nif (retval)\r\nretval = -EFAULT;\r\n} else {\r\nif (retval == -SST_ERR_INVALID_PARAMS)\r\nretval = -EINVAL;\r\n}\r\n} else {\r\npr_debug("SET_STREAM_PARAMS received!\n");\r\nretval = sst_set_stream_param(str_id, &str_param);\r\nif (!retval) {\r\nint sfreq = 0, word_size = 0, num_channel = 0;\r\nsfreq = str_param.sparams.uc.pcm_params.sfreq;\r\nword_size = str_param.sparams.uc.pcm_params.pcm_wd_sz;\r\nnum_channel = str_param.sparams.uc.pcm_params.num_chan;\r\nif (str_param.ops == STREAM_OPS_CAPTURE) {\r\nsst_drv_ctx->scard_ops->\\r\nset_pcm_audio_params(sfreq,\r\nword_size, num_channel);\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_SET_VOL): {\r\nstruct snd_sst_vol set_vol;\r\nif (copy_from_user(&set_vol, (void __user *)arg,\r\nsizeof(set_vol))) {\r\npr_debug("copy failed\n");\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\npr_debug("SET_VOLUME received for %d!\n",\r\nset_vol.stream_id);\r\nif (minor == STREAM_MODULE && set_vol.stream_id == 0) {\r\npr_debug("invalid operation!\n");\r\nretval = -EPERM;\r\nbreak;\r\n}\r\nretval = sst_set_vol(&set_vol);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_GET_VOL): {\r\nstruct snd_sst_vol get_vol;\r\nif (copy_from_user(&get_vol, (void __user *)arg,\r\nsizeof(get_vol))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\npr_debug("IOCTL_GET_VOLUME received for stream = %d!\n",\r\nget_vol.stream_id);\r\nif (minor == STREAM_MODULE && get_vol.stream_id == 0) {\r\npr_debug("invalid operation!\n");\r\nretval = -EPERM;\r\nbreak;\r\n}\r\nretval = sst_get_vol(&get_vol);\r\nif (retval) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\npr_debug("id:%d\n, vol:%d, ramp_dur:%d, ramp_type:%d\n",\r\nget_vol.stream_id, get_vol.volume,\r\nget_vol.ramp_duration, get_vol.ramp_type);\r\nif (copy_to_user((struct snd_sst_vol __user *)arg,\r\n&get_vol, sizeof(get_vol))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_MUTE): {\r\nstruct snd_sst_mute set_mute;\r\nif (copy_from_user(&set_mute, (void __user *)arg,\r\nsizeof(set_mute))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\npr_debug("SNDRV_SST_SET_VOLUME received for %d!\n",\r\nset_mute.stream_id);\r\nif (minor == STREAM_MODULE && set_mute.stream_id == 0) {\r\nretval = -EPERM;\r\nbreak;\r\n}\r\nretval = sst_set_mute(&set_mute);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_STREAM_GET_PARAMS): {\r\nstruct snd_sst_get_stream_params get_params;\r\npr_debug("IOCTL_GET_PARAMS received!\n");\r\nif (minor != 0) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nretval = sst_get_stream_params(str_id, &get_params);\r\nif (retval) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user((struct snd_sst_get_stream_params __user *)arg,\r\n&get_params, sizeof(get_params))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nsst_print_stream_params(&get_params);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_MMAP_PLAY):\r\ncase _IOC_NR(SNDRV_SST_MMAP_CAPTURE): {\r\nstruct snd_sst_mmap_buffs mmap_buf;\r\npr_debug("SNDRV_SST_MMAP_PLAY/CAPTURE received!\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nif (copy_from_user(&mmap_buf, (void __user *)arg,\r\nsizeof(mmap_buf))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nretval = intel_sst_mmap_play_capture(str_id, &mmap_buf);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_STREAM_DROP):\r\npr_debug("SNDRV_SST_IOCTL_DROP received!\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nretval = sst_drop_stream(str_id);\r\nbreak;\r\ncase _IOC_NR(SNDRV_SST_STREAM_GET_TSTAMP): {\r\nstruct snd_sst_tstamp tstamp = {0};\r\nunsigned long long time, freq, mod;\r\npr_debug("SNDRV_SST_STREAM_GET_TSTAMP received!\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nmemcpy_fromio(&tstamp,\r\nsst_drv_ctx->mailbox + SST_TIME_STAMP + str_id * sizeof(tstamp),\r\nsizeof(tstamp));\r\ntime = tstamp.samples_rendered;\r\nfreq = (unsigned long long) tstamp.sampling_frequency;\r\ntime = time * 1000;\r\nmod = do_div(time, freq);\r\nif (copy_to_user((void __user *)arg, &time,\r\nsizeof(unsigned long long)))\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_STREAM_START):{\r\nstruct stream_info *stream;\r\npr_debug("SNDRV_SST_STREAM_START received!\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nretval = sst_validate_strid(str_id);\r\nif (retval)\r\nbreak;\r\nstream = &sst_drv_ctx->streams[str_id];\r\nmutex_lock(&stream->lock);\r\nif (stream->status == STREAM_INIT &&\r\nstream->need_draining != true) {\r\nstream->prev = stream->status;\r\nstream->status = STREAM_RUNNING;\r\nif (stream->ops == STREAM_OPS_PLAYBACK ||\r\nstream->ops == STREAM_OPS_PLAYBACK_DRM) {\r\nretval = sst_play_frame(str_id);\r\n} else if (stream->ops == STREAM_OPS_CAPTURE)\r\nretval = sst_capture_frame(str_id);\r\nelse {\r\nretval = -EINVAL;\r\nmutex_unlock(&stream->lock);\r\nbreak;\r\n}\r\nif (retval < 0) {\r\nstream->status = STREAM_INIT;\r\nmutex_unlock(&stream->lock);\r\nbreak;\r\n}\r\n} else {\r\nretval = -EINVAL;\r\n}\r\nmutex_unlock(&stream->lock);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_SET_TARGET_DEVICE): {\r\nstruct snd_sst_target_device target_device;\r\npr_debug("SET_TARGET_DEVICE received!\n");\r\nif (copy_from_user(&target_device, (void __user *)arg,\r\nsizeof(target_device))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nif (minor != AM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nretval = sst_target_device_select(&target_device);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_DRIVER_INFO): {\r\nstruct snd_sst_driver_info info;\r\npr_debug("SNDRV_SST_DRIVER_INFO received\n");\r\ninfo.version = SST_VERSION_NUM;\r\ninfo.active_pcm_streams = sst_drv_ctx->stream_cnt -\r\nsst_drv_ctx->encoded_cnt;\r\ninfo.active_enc_streams = sst_drv_ctx->encoded_cnt;\r\ninfo.max_pcm_streams = MAX_ACTIVE_STREAM - MAX_ENC_STREAM;\r\ninfo.max_enc_streams = MAX_ENC_STREAM;\r\ninfo.buf_per_stream = sst_drv_ctx->mmap_len;\r\nif (copy_to_user((void __user *)arg, &info,\r\nsizeof(info)))\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_STREAM_DECODE): {\r\nstruct snd_sst_dbufs param;\r\nstruct snd_sst_dbufs dbufs_local;\r\nstruct snd_sst_buffs ibufs, obufs;\r\nstruct snd_sst_buff_entry *ibuf_tmp, *obuf_tmp;\r\nchar __user *dest;\r\npr_debug("SNDRV_SST_STREAM_DECODE received\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nif (copy_from_user(&param, (void __user *)arg,\r\nsizeof(param))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\ndbufs_local.input_bytes_consumed = param.input_bytes_consumed;\r\ndbufs_local.output_bytes_produced =\r\nparam.output_bytes_produced;\r\nif (copy_from_user(&ibufs, (void __user *)param.ibufs, sizeof(ibufs))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nif (copy_from_user(&obufs, (void __user *)param.obufs, sizeof(obufs))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nibuf_tmp = kcalloc(ibufs.entries, sizeof(*ibuf_tmp), GFP_KERNEL);\r\nobuf_tmp = kcalloc(obufs.entries, sizeof(*obuf_tmp), GFP_KERNEL);\r\nif (!ibuf_tmp || !obuf_tmp) {\r\nretval = -ENOMEM;\r\ngoto free_iobufs;\r\n}\r\nif (copy_from_user(ibuf_tmp, (void __user *)ibufs.buff_entry,\r\nibufs.entries * sizeof(*ibuf_tmp))) {\r\nretval = -EFAULT;\r\ngoto free_iobufs;\r\n}\r\nibufs.buff_entry = ibuf_tmp;\r\ndbufs_local.ibufs = &ibufs;\r\nif (copy_from_user(obuf_tmp, (void __user *)obufs.buff_entry,\r\nobufs.entries * sizeof(*obuf_tmp))) {\r\nretval = -EFAULT;\r\ngoto free_iobufs;\r\n}\r\nobufs.buff_entry = obuf_tmp;\r\ndbufs_local.obufs = &obufs;\r\nretval = sst_decode(str_id, &dbufs_local);\r\nif (retval) {\r\nretval = -EAGAIN;\r\ngoto free_iobufs;\r\n}\r\ndest = (char __user *)arg + offsetof(struct snd_sst_dbufs, input_bytes_consumed);\r\nif (copy_to_user(dest,\r\n&dbufs_local.input_bytes_consumed,\r\nsizeof(unsigned long long))) {\r\nretval = -EFAULT;\r\ngoto free_iobufs;\r\n}\r\ndest = (char __user *)arg + offsetof(struct snd_sst_dbufs, input_bytes_consumed);\r\nif (copy_to_user(dest,\r\n&dbufs_local.output_bytes_produced,\r\nsizeof(unsigned long long))) {\r\nretval = -EFAULT;\r\ngoto free_iobufs;\r\n}\r\nfree_iobufs:\r\nkfree(ibuf_tmp);\r\nkfree(obuf_tmp);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_STREAM_DRAIN):\r\npr_debug("SNDRV_SST_STREAM_DRAIN received\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nretval = sst_drain_stream(str_id);\r\nbreak;\r\ncase _IOC_NR(SNDRV_SST_STREAM_BYTES_DECODED): {\r\nunsigned long long __user *bytes = (unsigned long long __user *)arg;\r\nstruct snd_sst_tstamp tstamp = {0};\r\npr_debug("STREAM_BYTES_DECODED received!\n");\r\nif (minor != STREAM_MODULE) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nmemcpy_fromio(&tstamp,\r\nsst_drv_ctx->mailbox + SST_TIME_STAMP + str_id * sizeof(tstamp),\r\nsizeof(tstamp));\r\nif (copy_to_user(bytes, &tstamp.bytes_processed,\r\nsizeof(*bytes)))\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_FW_INFO): {\r\nstruct snd_sst_fw_info *fw_info;\r\npr_debug("SNDRV_SST_FW_INFO received\n");\r\nfw_info = kzalloc(sizeof(*fw_info), GFP_ATOMIC);\r\nif (!fw_info) {\r\nretval = -ENOMEM;\r\nbreak;\r\n}\r\nretval = sst_get_fw_info(fw_info);\r\nif (retval) {\r\nretval = -EIO;\r\nkfree(fw_info);\r\nbreak;\r\n}\r\nif (copy_to_user((struct snd_sst_dbufs __user *)arg,\r\nfw_info, sizeof(*fw_info))) {\r\nkfree(fw_info);\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nkfree(fw_info);\r\nbreak;\r\n}\r\ncase _IOC_NR(SNDRV_SST_GET_ALGO):\r\ncase _IOC_NR(SNDRV_SST_SET_ALGO):\r\nif (minor != AM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nretval = intel_sst_ioctl_dsp(cmd, arg);\r\nbreak;\r\ncase _IOC_NR(SNDRV_SST_TUNING_PARAMS):\r\nif (minor != AM_MODULE) {\r\nretval = -EBADRQC;\r\nbreak;\r\n}\r\nretval = sst_ioctl_tuning_params(arg);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\npr_debug("intel_sst_ioctl:complete ret code = %d\n", retval);\r\nreturn retval;\r\n}
