static void spia_hwcontrol(struct mtd_info *mtd, int cmd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nvoid __iomem *addr = spia_io_base + spia_pedr;\r\nunsigned char bits;\r\nbits = (ctrl & NAND_CNE) << 2;\r\nbits |= (ctrl & NAND_CLE | NAND_ALE) >> 1;\r\nwriteb((readb(addr) & ~0x7) | bits, addr);\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, chip->IO_ADDR_W);\r\n}\r\nstatic int __init spia_init(void)\r\n{\r\nstruct nand_chip *this;\r\nspia_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);\r\nif (!spia_mtd) {\r\nprintk("Unable to allocate SPIA NAND MTD device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nthis = (struct nand_chip *)(&spia_mtd[1]);\r\nmemset(spia_mtd, 0, sizeof(struct mtd_info));\r\nmemset(this, 0, sizeof(struct nand_chip));\r\nspia_mtd->priv = this;\r\nspia_mtd->owner = THIS_MODULE;\r\n(*(volatile unsigned char *)(spia_io_base + spia_peddr)) = 0x07;\r\nthis->IO_ADDR_R = (void __iomem *)spia_fio_base;\r\nthis->IO_ADDR_W = (void __iomem *)spia_fio_base;\r\nthis->cmd_ctrl = spia_hwcontrol;\r\nthis->chip_delay = 15;\r\nif (nand_scan(spia_mtd, 1)) {\r\nkfree(spia_mtd);\r\nreturn -ENXIO;\r\n}\r\nmtd_device_register(spia_mtd, partition_info, NUM_PARTITIONS);\r\nreturn 0;\r\n}\r\nstatic void __exit spia_cleanup(void)\r\n{\r\nnand_release(spia_mtd);\r\nkfree(spia_mtd);\r\n}
