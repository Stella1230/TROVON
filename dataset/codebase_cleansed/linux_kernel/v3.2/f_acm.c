static inline struct f_acm *func_to_acm(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_acm, port.func);\r\n}\r\nstatic inline struct f_acm *port_to_acm(struct gserial *p)\r\n{\r\nreturn container_of(p, struct f_acm, port);\r\n}\r\nstatic void acm_complete_set_line_coding(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct f_acm *acm = ep->driver_data;\r\nstruct usb_composite_dev *cdev = acm->port.func.config->cdev;\r\nif (req->status != 0) {\r\nDBG(cdev, "acm ttyGS%d completion, err %d\n",\r\nacm->port_num, req->status);\r\nreturn;\r\n}\r\nif (req->actual != sizeof(acm->port_line_coding)) {\r\nDBG(cdev, "acm ttyGS%d short resp, len %d\n",\r\nacm->port_num, req->actual);\r\nusb_ep_set_halt(ep);\r\n} else {\r\nstruct usb_cdc_line_coding *value = req->buf;\r\nacm->port_line_coding = *value;\r\n}\r\n}\r\nstatic int acm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_REQ_SET_LINE_CODING:\r\nif (w_length != sizeof(struct usb_cdc_line_coding)\r\n|| w_index != acm->ctrl_id)\r\ngoto invalid;\r\nvalue = w_length;\r\ncdev->gadget->ep0->driver_data = acm;\r\nreq->complete = acm_complete_set_line_coding;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_REQ_GET_LINE_CODING:\r\nif (w_index != acm->ctrl_id)\r\ngoto invalid;\r\nvalue = min_t(unsigned, w_length,\r\nsizeof(struct usb_cdc_line_coding));\r\nmemcpy(req->buf, &acm->port_line_coding, value);\r\nbreak;\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_REQ_SET_CONTROL_LINE_STATE:\r\nif (w_index != acm->ctrl_id)\r\ngoto invalid;\r\nvalue = 0;\r\nacm->port_handshake_bits = w_value;\r\nbreak;\r\ndefault:\r\ninvalid:\r\nVDBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nDBG(cdev, "acm ttyGS%d req%02x.%02x v%04x i%04x l%d\n",\r\nacm->port_num, ctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = 0;\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "acm response on ttyGS%d, err %d\n",\r\nacm->port_num, value);\r\n}\r\nreturn value;\r\n}\r\nstatic int acm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (intf == acm->ctrl_id) {\r\nif (acm->notify->driver_data) {\r\nVDBG(cdev, "reset acm control interface %d\n", intf);\r\nusb_ep_disable(acm->notify);\r\n} else {\r\nVDBG(cdev, "init acm ctrl interface %d\n", intf);\r\nif (config_ep_by_speed(cdev->gadget, f, acm->notify))\r\nreturn -EINVAL;\r\n}\r\nusb_ep_enable(acm->notify);\r\nacm->notify->driver_data = acm;\r\n} else if (intf == acm->data_id) {\r\nif (acm->port.in->driver_data) {\r\nDBG(cdev, "reset acm ttyGS%d\n", acm->port_num);\r\ngserial_disconnect(&acm->port);\r\n}\r\nif (!acm->port.in->desc || !acm->port.out->desc) {\r\nDBG(cdev, "activate acm ttyGS%d\n", acm->port_num);\r\nif (config_ep_by_speed(cdev->gadget, f,\r\nacm->port.in) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\nacm->port.out)) {\r\nacm->port.in->desc = NULL;\r\nacm->port.out->desc = NULL;\r\nreturn -EINVAL;\r\n}\r\n}\r\ngserial_connect(&acm->port, acm->port_num);\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void acm_disable(struct usb_function *f)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "acm ttyGS%d deactivated\n", acm->port_num);\r\ngserial_disconnect(&acm->port);\r\nusb_ep_disable(acm->notify);\r\nacm->notify->driver_data = NULL;\r\n}\r\nstatic int acm_cdc_notify(struct f_acm *acm, u8 type, u16 value,\r\nvoid *data, unsigned length)\r\n{\r\nstruct usb_ep *ep = acm->notify;\r\nstruct usb_request *req;\r\nstruct usb_cdc_notification *notify;\r\nconst unsigned len = sizeof(*notify) + length;\r\nvoid *buf;\r\nint status;\r\nreq = acm->notify_req;\r\nacm->notify_req = NULL;\r\nacm->pending = false;\r\nreq->length = len;\r\nnotify = req->buf;\r\nbuf = notify + 1;\r\nnotify->bmRequestType = USB_DIR_IN | USB_TYPE_CLASS\r\n| USB_RECIP_INTERFACE;\r\nnotify->bNotificationType = type;\r\nnotify->wValue = cpu_to_le16(value);\r\nnotify->wIndex = cpu_to_le16(acm->ctrl_id);\r\nnotify->wLength = cpu_to_le16(length);\r\nmemcpy(buf, data, length);\r\nspin_unlock(&acm->lock);\r\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nspin_lock(&acm->lock);\r\nif (status < 0) {\r\nERROR(acm->port.func.config->cdev,\r\n"acm ttyGS%d can't notify serial state, %d\n",\r\nacm->port_num, status);\r\nacm->notify_req = req;\r\n}\r\nreturn status;\r\n}\r\nstatic int acm_notify_serial_state(struct f_acm *acm)\r\n{\r\nstruct usb_composite_dev *cdev = acm->port.func.config->cdev;\r\nint status;\r\nspin_lock(&acm->lock);\r\nif (acm->notify_req) {\r\nDBG(cdev, "acm ttyGS%d serial state %04x\n",\r\nacm->port_num, acm->serial_state);\r\nstatus = acm_cdc_notify(acm, USB_CDC_NOTIFY_SERIAL_STATE,\r\n0, &acm->serial_state, sizeof(acm->serial_state));\r\n} else {\r\nacm->pending = true;\r\nstatus = 0;\r\n}\r\nspin_unlock(&acm->lock);\r\nreturn status;\r\n}\r\nstatic void acm_cdc_notify_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_acm *acm = req->context;\r\nu8 doit = false;\r\nspin_lock(&acm->lock);\r\nif (req->status != -ESHUTDOWN)\r\ndoit = acm->pending;\r\nacm->notify_req = req;\r\nspin_unlock(&acm->lock);\r\nif (doit)\r\nacm_notify_serial_state(acm);\r\n}\r\nstatic void acm_connect(struct gserial *port)\r\n{\r\nstruct f_acm *acm = port_to_acm(port);\r\nacm->serial_state |= ACM_CTRL_DSR | ACM_CTRL_DCD;\r\nacm_notify_serial_state(acm);\r\n}\r\nstatic void acm_disconnect(struct gserial *port)\r\n{\r\nstruct f_acm *acm = port_to_acm(port);\r\nacm->serial_state &= ~(ACM_CTRL_DSR | ACM_CTRL_DCD);\r\nacm_notify_serial_state(acm);\r\n}\r\nstatic int acm_send_break(struct gserial *port, int duration)\r\n{\r\nstruct f_acm *acm = port_to_acm(port);\r\nu16 state;\r\nstate = acm->serial_state;\r\nstate &= ~ACM_CTRL_BRK;\r\nif (duration)\r\nstate |= ACM_CTRL_BRK;\r\nacm->serial_state = state;\r\nreturn acm_notify_serial_state(acm);\r\n}\r\nstatic int\r\nacm_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_acm *acm = func_to_acm(f);\r\nint status;\r\nstruct usb_ep *ep;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nacm->ctrl_id = status;\r\nacm_iad_descriptor.bFirstInterface = status;\r\nacm_control_interface_desc.bInterfaceNumber = status;\r\nacm_union_desc .bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nacm->data_id = status;\r\nacm_data_interface_desc.bInterfaceNumber = status;\r\nacm_union_desc.bSlaveInterface0 = status;\r\nacm_call_mgmt_descriptor.bDataInterface = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &acm_fs_in_desc);\r\nif (!ep)\r\ngoto fail;\r\nacm->port.in = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &acm_fs_out_desc);\r\nif (!ep)\r\ngoto fail;\r\nacm->port.out = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &acm_fs_notify_desc);\r\nif (!ep)\r\ngoto fail;\r\nacm->notify = ep;\r\nep->driver_data = cdev;\r\nacm->notify_req = gs_alloc_req(ep,\r\nsizeof(struct usb_cdc_notification) + 2,\r\nGFP_KERNEL);\r\nif (!acm->notify_req)\r\ngoto fail;\r\nacm->notify_req->complete = acm_cdc_notify_complete;\r\nacm->notify_req->context = acm;\r\nf->descriptors = usb_copy_descriptors(acm_fs_function);\r\nif (!f->descriptors)\r\ngoto fail;\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\nacm_hs_in_desc.bEndpointAddress =\r\nacm_fs_in_desc.bEndpointAddress;\r\nacm_hs_out_desc.bEndpointAddress =\r\nacm_fs_out_desc.bEndpointAddress;\r\nacm_hs_notify_desc.bEndpointAddress =\r\nacm_fs_notify_desc.bEndpointAddress;\r\nf->hs_descriptors = usb_copy_descriptors(acm_hs_function);\r\n}\r\nDBG(cdev, "acm ttyGS%d: %s speed IN/%s OUT/%s NOTIFY/%s\n",\r\nacm->port_num,\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\nacm->port.in->name, acm->port.out->name,\r\nacm->notify->name);\r\nreturn 0;\r\nfail:\r\nif (acm->notify_req)\r\ngs_free_req(acm->notify, acm->notify_req);\r\nif (acm->notify)\r\nacm->notify->driver_data = NULL;\r\nif (acm->port.out)\r\nacm->port.out->driver_data = NULL;\r\nif (acm->port.in)\r\nacm->port.in->driver_data = NULL;\r\nERROR(cdev, "%s/%p: can't bind, err %d\n", f->name, f, status);\r\nreturn status;\r\n}\r\nstatic void\r\nacm_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nif (gadget_is_dualspeed(c->cdev->gadget))\r\nusb_free_descriptors(f->hs_descriptors);\r\nusb_free_descriptors(f->descriptors);\r\ngs_free_req(acm->notify, acm->notify_req);\r\nkfree(acm);\r\n}\r\nstatic inline bool can_support_cdc(struct usb_configuration *c)\r\n{\r\nreturn true;\r\n}\r\nint acm_bind_config(struct usb_configuration *c, u8 port_num)\r\n{\r\nstruct f_acm *acm;\r\nint status;\r\nif (!can_support_cdc(c))\r\nreturn -EINVAL;\r\nif (acm_string_defs[ACM_CTRL_IDX].id == 0) {\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nacm_string_defs[ACM_CTRL_IDX].id = status;\r\nacm_control_interface_desc.iInterface = status;\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nacm_string_defs[ACM_DATA_IDX].id = status;\r\nacm_data_interface_desc.iInterface = status;\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nacm_string_defs[ACM_IAD_IDX].id = status;\r\nacm_iad_descriptor.iFunction = status;\r\n}\r\nacm = kzalloc(sizeof *acm, GFP_KERNEL);\r\nif (!acm)\r\nreturn -ENOMEM;\r\nspin_lock_init(&acm->lock);\r\nacm->port_num = port_num;\r\nacm->port.connect = acm_connect;\r\nacm->port.disconnect = acm_disconnect;\r\nacm->port.send_break = acm_send_break;\r\nacm->port.func.name = "acm";\r\nacm->port.func.strings = acm_strings;\r\nacm->port.func.bind = acm_bind;\r\nacm->port.func.unbind = acm_unbind;\r\nacm->port.func.set_alt = acm_set_alt;\r\nacm->port.func.setup = acm_setup;\r\nacm->port.func.disable = acm_disable;\r\nstatus = usb_add_function(c, &acm->port.func);\r\nif (status)\r\nkfree(acm);\r\nreturn status;\r\n}
