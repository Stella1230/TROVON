static inline struct pci_dev *__pci_get_device_by_addr(unsigned long addr)\r\n{\r\nstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\r\nwhile (n) {\r\nstruct pci_io_addr_range *piar;\r\npiar = rb_entry(n, struct pci_io_addr_range, rb_node);\r\nif (addr < piar->addr_lo) {\r\nn = n->rb_left;\r\n} else {\r\nif (addr > piar->addr_hi) {\r\nn = n->rb_right;\r\n} else {\r\npci_dev_get(piar->pcidev);\r\nreturn piar->pcidev;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct pci_dev *pci_get_device_by_addr(unsigned long addr)\r\n{\r\nstruct pci_dev *dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\r\ndev = __pci_get_device_by_addr(addr);\r\nspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\r\nreturn dev;\r\n}\r\nstatic void pci_addr_cache_print(struct pci_io_addr_cache *cache)\r\n{\r\nstruct rb_node *n;\r\nint cnt = 0;\r\nn = rb_first(&cache->rb_root);\r\nwhile (n) {\r\nstruct pci_io_addr_range *piar;\r\npiar = rb_entry(n, struct pci_io_addr_range, rb_node);\r\nprintk(KERN_DEBUG "PCI: %s addr range %d [%lx-%lx]: %s\n",\r\n(piar->flags & IORESOURCE_IO) ? "i/o" : "mem", cnt,\r\npiar->addr_lo, piar->addr_hi, pci_name(piar->pcidev));\r\ncnt++;\r\nn = rb_next(n);\r\n}\r\n}\r\nstatic struct pci_io_addr_range *\r\npci_addr_cache_insert(struct pci_dev *dev, unsigned long alo,\r\nunsigned long ahi, unsigned int flags)\r\n{\r\nstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct pci_io_addr_range *piar;\r\nwhile (*p) {\r\nparent = *p;\r\npiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\r\nif (ahi < piar->addr_lo) {\r\np = &parent->rb_left;\r\n} else if (alo > piar->addr_hi) {\r\np = &parent->rb_right;\r\n} else {\r\nif (dev != piar->pcidev ||\r\nalo != piar->addr_lo || ahi != piar->addr_hi) {\r\nprintk(KERN_WARNING "PIAR: overlapping address range\n");\r\n}\r\nreturn piar;\r\n}\r\n}\r\npiar = kmalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\r\nif (!piar)\r\nreturn NULL;\r\npci_dev_get(dev);\r\npiar->addr_lo = alo;\r\npiar->addr_hi = ahi;\r\npiar->pcidev = dev;\r\npiar->flags = flags;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "PIAR: insert range=[%lx:%lx] dev=%s\n",\r\nalo, ahi, pci_name (dev));\r\n#endif\r\nrb_link_node(&piar->rb_node, parent, p);\r\nrb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\r\nreturn piar;\r\n}\r\nstatic void __pci_addr_cache_insert_device(struct pci_dev *dev)\r\n{\r\nstruct device_node *dn;\r\nstruct pci_dn *pdn;\r\nint i;\r\ndn = pci_device_to_OF_node(dev);\r\nif (!dn) {\r\nprintk(KERN_WARNING "PCI: no pci dn found for dev=%s\n", pci_name(dev));\r\nreturn;\r\n}\r\npdn = PCI_DN(dn);\r\nif (!(pdn->eeh_mode & EEH_MODE_SUPPORTED) ||\r\npdn->eeh_mode & EEH_MODE_NOCHECK) {\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "PCI: skip building address cache for=%s - %s\n",\r\npci_name(dev), pdn->node->full_name);\r\n#endif\r\nreturn;\r\n}\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nunsigned long start = pci_resource_start(dev,i);\r\nunsigned long end = pci_resource_end(dev,i);\r\nunsigned int flags = pci_resource_flags(dev,i);\r\nif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\r\ncontinue;\r\nif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\r\ncontinue;\r\npci_addr_cache_insert(dev, start, end, flags);\r\n}\r\n}\r\nvoid pci_addr_cache_insert_device(struct pci_dev *dev)\r\n{\r\nunsigned long flags;\r\nif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\r\nreturn;\r\nspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\r\n__pci_addr_cache_insert_device(dev);\r\nspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\r\n}\r\nstatic inline void __pci_addr_cache_remove_device(struct pci_dev *dev)\r\n{\r\nstruct rb_node *n;\r\nrestart:\r\nn = rb_first(&pci_io_addr_cache_root.rb_root);\r\nwhile (n) {\r\nstruct pci_io_addr_range *piar;\r\npiar = rb_entry(n, struct pci_io_addr_range, rb_node);\r\nif (piar->pcidev == dev) {\r\nrb_erase(n, &pci_io_addr_cache_root.rb_root);\r\npci_dev_put(piar->pcidev);\r\nkfree(piar);\r\ngoto restart;\r\n}\r\nn = rb_next(n);\r\n}\r\n}\r\nvoid pci_addr_cache_remove_device(struct pci_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\r\n__pci_addr_cache_remove_device(dev);\r\nspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\r\n}\r\nvoid __init pci_addr_cache_build(void)\r\n{\r\nstruct device_node *dn;\r\nstruct pci_dev *dev = NULL;\r\nspin_lock_init(&pci_io_addr_cache_root.piar_lock);\r\nfor_each_pci_dev(dev) {\r\npci_addr_cache_insert_device(dev);\r\ndn = pci_device_to_OF_node(dev);\r\nif (!dn)\r\ncontinue;\r\npci_dev_get(dev);\r\nPCI_DN(dn)->pcidev = dev;\r\neeh_sysfs_add_device(dev);\r\n}\r\n#ifdef DEBUG\r\npci_addr_cache_print(&pci_io_addr_cache_root);\r\n#endif\r\n}
