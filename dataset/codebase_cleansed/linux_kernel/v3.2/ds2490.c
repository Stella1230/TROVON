static int ds_send_control_cmd(struct ds_device *dev, u16 value, u16 index)\r\n{\r\nint err;\r\nerr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\r\nCONTROL_CMD, 0x40, value, index, NULL, 0, 1000);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to send command control message %x.%x: err=%d.\n",\r\nvalue, index, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int ds_send_control_mode(struct ds_device *dev, u16 value, u16 index)\r\n{\r\nint err;\r\nerr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\r\nMODE_CMD, 0x40, value, index, NULL, 0, 1000);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to send mode control message %x.%x: err=%d.\n",\r\nvalue, index, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int ds_send_control(struct ds_device *dev, u16 value, u16 index)\r\n{\r\nint err;\r\nerr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\r\nCOMM_CMD, 0x40, value, index, NULL, 0, 1000);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to send control message %x.%x: err=%d.\n",\r\nvalue, index, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int ds_recv_status_nodump(struct ds_device *dev, struct ds_status *st,\r\nunsigned char *buf, int size)\r\n{\r\nint count, err;\r\nmemset(st, 0, sizeof(*st));\r\ncount = 0;\r\nerr = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_STATUS]), buf, size, &count, 100);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to read 1-wire data from 0x%x: err=%d.\n", dev->ep[EP_STATUS], err);\r\nreturn err;\r\n}\r\nif (count >= sizeof(*st))\r\nmemcpy(st, buf, sizeof(*st));\r\nreturn count;\r\n}\r\nstatic inline void ds_print_msg(unsigned char *buf, unsigned char *str, int off)\r\n{\r\nprintk(KERN_INFO "%45s: %8x\n", str, buf[off]);\r\n}\r\nstatic void ds_dump_status(struct ds_device *dev, unsigned char *buf, int count)\r\n{\r\nint i;\r\nprintk(KERN_INFO "0x%x: count=%d, status: ", dev->ep[EP_STATUS], count);\r\nfor (i=0; i<count; ++i)\r\nprintk("%02x ", buf[i]);\r\nprintk(KERN_INFO "\n");\r\nif (count >= 16) {\r\nds_print_msg(buf, "enable flag", 0);\r\nds_print_msg(buf, "1-wire speed", 1);\r\nds_print_msg(buf, "strong pullup duration", 2);\r\nds_print_msg(buf, "programming pulse duration", 3);\r\nds_print_msg(buf, "pulldown slew rate control", 4);\r\nds_print_msg(buf, "write-1 low time", 5);\r\nds_print_msg(buf, "data sample offset/write-0 recovery time",\r\n6);\r\nds_print_msg(buf, "reserved (test register)", 7);\r\nds_print_msg(buf, "device status flags", 8);\r\nds_print_msg(buf, "communication command byte 1", 9);\r\nds_print_msg(buf, "communication command byte 2", 10);\r\nds_print_msg(buf, "communication command buffer status", 11);\r\nds_print_msg(buf, "1-wire data output buffer status", 12);\r\nds_print_msg(buf, "1-wire data input buffer status", 13);\r\nds_print_msg(buf, "reserved", 14);\r\nds_print_msg(buf, "reserved", 15);\r\n}\r\nfor (i = 16; i < count; ++i) {\r\nif (buf[i] == RR_DETECT) {\r\nds_print_msg(buf, "new device detect", i);\r\ncontinue;\r\n}\r\nds_print_msg(buf, "Result Register Value: ", i);\r\nif (buf[i] & RR_NRS)\r\nprintk(KERN_INFO "NRS: Reset no presence or ...\n");\r\nif (buf[i] & RR_SH)\r\nprintk(KERN_INFO "SH: short on reset or set path\n");\r\nif (buf[i] & RR_APP)\r\nprintk(KERN_INFO "APP: alarming presence on reset\n");\r\nif (buf[i] & RR_VPP)\r\nprintk(KERN_INFO "VPP: 12V expected not seen\n");\r\nif (buf[i] & RR_CMP)\r\nprintk(KERN_INFO "CMP: compare error\n");\r\nif (buf[i] & RR_CRC)\r\nprintk(KERN_INFO "CRC: CRC error detected\n");\r\nif (buf[i] & RR_RDP)\r\nprintk(KERN_INFO "RDP: redirected page\n");\r\nif (buf[i] & RR_EOS)\r\nprintk(KERN_INFO "EOS: end of search error\n");\r\n}\r\n}\r\nstatic void ds_reset_device(struct ds_device *dev)\r\n{\r\nds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);\r\nif (ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_SPUE))\r\nprintk(KERN_ERR "ds_reset_device: "\r\n"Error allowing strong pullup\n");\r\nif (dev->spu_sleep) {\r\nu8 del = dev->spu_sleep>>4;\r\nif (ds_send_control(dev, COMM_SET_DURATION | COMM_IM, del))\r\nprintk(KERN_ERR "ds_reset_device: "\r\n"Error setting duration\n");\r\n}\r\n}\r\nstatic int ds_recv_data(struct ds_device *dev, unsigned char *buf, int size)\r\n{\r\nint count, err;\r\nstruct ds_status st;\r\ncount = 0;\r\nerr = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]),\r\nbuf, size, &count, 1000);\r\nif (err < 0) {\r\nu8 buf[0x20];\r\nint count;\r\nprintk(KERN_INFO "Clearing ep0x%x.\n", dev->ep[EP_DATA_IN]);\r\nusb_clear_halt(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]));\r\ncount = ds_recv_status_nodump(dev, &st, buf, sizeof(buf));\r\nds_dump_status(dev, buf, count);\r\nreturn err;\r\n}\r\n#if 0\r\n{\r\nint i;\r\nprintk("%s: count=%d: ", __func__, count);\r\nfor (i=0; i<count; ++i)\r\nprintk("%02x ", buf[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\nreturn count;\r\n}\r\nstatic int ds_send_data(struct ds_device *dev, unsigned char *buf, int len)\r\n{\r\nint count, err;\r\ncount = 0;\r\nerr = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, dev->ep[EP_DATA_OUT]), buf, len, &count, 1000);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to write 1-wire data to ep0x%x: "\r\n"err=%d.\n", dev->ep[EP_DATA_OUT], err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int ds_wait_status(struct ds_device *dev, struct ds_status *st)\r\n{\r\nu8 buf[0x20];\r\nint err, count = 0;\r\ndo {\r\nerr = ds_recv_status_nodump(dev, st, buf, sizeof(buf));\r\n#if 0\r\nif (err >= 0) {\r\nint i;\r\nprintk("0x%x: count=%d, status: ", dev->ep[EP_STATUS], err);\r\nfor (i=0; i<err; ++i)\r\nprintk("%02x ", buf[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\n} while (!(buf[0x08] & ST_IDLE) && !(err < 0) && ++count < 100);\r\nif (err >= 16 && st->status & ST_EPOF) {\r\nprintk(KERN_INFO "Resetting device after ST_EPOF.\n");\r\nds_reset_device(dev);\r\ncount = 101;\r\n}\r\nif (err > 16 || count >= 100 || err < 0)\r\nds_dump_status(dev, buf, err);\r\nif (count >= 100 || err < 0)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int ds_reset(struct ds_device *dev)\r\n{\r\nint err;\r\nerr = ds_send_control(dev, COMM_1_WIRE_RESET | COMM_IM, SPEED_NORMAL);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ds_set_pullup(struct ds_device *dev, int delay)\r\n{\r\nint err = 0;\r\nu8 del = 1 + (u8)(delay >> 4);\r\nint ms = del<<4;\r\ndev->spu_bit = delay ? COMM_SPU : 0;\r\nif (delay == 0 || ms == dev->spu_sleep)\r\nreturn err;\r\nerr = ds_send_control(dev, COMM_SET_DURATION | COMM_IM, del);\r\nif (err)\r\nreturn err;\r\ndev->spu_sleep = ms;\r\nreturn err;\r\n}\r\nstatic int ds_touch_bit(struct ds_device *dev, u8 bit, u8 *tbit)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nerr = ds_send_control(dev, COMM_BIT_IO | COMM_IM | (bit ? COMM_D : 0),\r\n0);\r\nif (err)\r\nreturn err;\r\nds_wait_status(dev, &st);\r\nerr = ds_recv_data(dev, tbit, sizeof(*tbit));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ds_write_byte(struct ds_device *dev, u8 byte)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nu8 rbyte;\r\nerr = ds_send_control(dev, COMM_BYTE_IO | COMM_IM | dev->spu_bit, byte);\r\nif (err)\r\nreturn err;\r\nif (dev->spu_bit)\r\nmsleep(dev->spu_sleep);\r\nerr = ds_wait_status(dev, &st);\r\nif (err)\r\nreturn err;\r\nerr = ds_recv_data(dev, &rbyte, sizeof(rbyte));\r\nif (err < 0)\r\nreturn err;\r\nreturn !(byte == rbyte);\r\n}\r\nstatic int ds_read_byte(struct ds_device *dev, u8 *byte)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nerr = ds_send_control(dev, COMM_BYTE_IO | COMM_IM , 0xff);\r\nif (err)\r\nreturn err;\r\nds_wait_status(dev, &st);\r\nerr = ds_recv_data(dev, byte, sizeof(*byte));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ds_read_block(struct ds_device *dev, u8 *buf, int len)\r\n{\r\nstruct ds_status st;\r\nint err;\r\nif (len > 64*1024)\r\nreturn -E2BIG;\r\nmemset(buf, 0xFF, len);\r\nerr = ds_send_data(dev, buf, len);\r\nif (err < 0)\r\nreturn err;\r\nerr = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM, len);\r\nif (err)\r\nreturn err;\r\nds_wait_status(dev, &st);\r\nmemset(buf, 0x00, len);\r\nerr = ds_recv_data(dev, buf, len);\r\nreturn err;\r\n}\r\nstatic int ds_write_block(struct ds_device *dev, u8 *buf, int len)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nerr = ds_send_data(dev, buf, len);\r\nif (err < 0)\r\nreturn err;\r\nerr = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM | dev->spu_bit, len);\r\nif (err)\r\nreturn err;\r\nif (dev->spu_bit)\r\nmsleep(dev->spu_sleep);\r\nds_wait_status(dev, &st);\r\nerr = ds_recv_data(dev, buf, len);\r\nif (err < 0)\r\nreturn err;\r\nreturn !(err == len);\r\n}\r\nstatic u8 ds9490r_touch_bit(void *data, u8 bit)\r\n{\r\nu8 ret;\r\nstruct ds_device *dev = data;\r\nif (ds_touch_bit(dev, bit, &ret))\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic void ds9490r_write_byte(void *data, u8 byte)\r\n{\r\nstruct ds_device *dev = data;\r\nds_write_byte(dev, byte);\r\n}\r\nstatic u8 ds9490r_read_byte(void *data)\r\n{\r\nstruct ds_device *dev = data;\r\nint err;\r\nu8 byte = 0;\r\nerr = ds_read_byte(dev, &byte);\r\nif (err)\r\nreturn 0;\r\nreturn byte;\r\n}\r\nstatic void ds9490r_write_block(void *data, const u8 *buf, int len)\r\n{\r\nstruct ds_device *dev = data;\r\nds_write_block(dev, (u8 *)buf, len);\r\n}\r\nstatic u8 ds9490r_read_block(void *data, u8 *buf, int len)\r\n{\r\nstruct ds_device *dev = data;\r\nint err;\r\nerr = ds_read_block(dev, buf, len);\r\nif (err < 0)\r\nreturn 0;\r\nreturn len;\r\n}\r\nstatic u8 ds9490r_reset(void *data)\r\n{\r\nstruct ds_device *dev = data;\r\nint err;\r\nerr = ds_reset(dev);\r\nif (err)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic u8 ds9490r_set_pullup(void *data, int delay)\r\n{\r\nstruct ds_device *dev = data;\r\nif (ds_set_pullup(dev, delay))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ds_w1_init(struct ds_device *dev)\r\n{\r\nmemset(&dev->master, 0, sizeof(struct w1_bus_master));\r\nds_reset_device(dev);\r\ndev->master.data = dev;\r\ndev->master.touch_bit = &ds9490r_touch_bit;\r\ndev->master.read_byte = &ds9490r_read_byte;\r\ndev->master.write_byte = &ds9490r_write_byte;\r\ndev->master.read_block = &ds9490r_read_block;\r\ndev->master.write_block = &ds9490r_write_block;\r\ndev->master.reset_bus = &ds9490r_reset;\r\ndev->master.set_pullup = &ds9490r_set_pullup;\r\nreturn w1_add_master_device(&dev->master);\r\n}\r\nstatic void ds_w1_fini(struct ds_device *dev)\r\n{\r\nw1_remove_master_device(&dev->master);\r\n}\r\nstatic int ds_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *udev_id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_host_interface *iface_desc;\r\nstruct ds_device *dev;\r\nint i, err;\r\ndev = kmalloc(sizeof(struct ds_device), GFP_KERNEL);\r\nif (!dev) {\r\nprintk(KERN_INFO "Failed to allocate new DS9490R structure.\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->spu_sleep = 0;\r\ndev->spu_bit = 0;\r\ndev->udev = usb_get_dev(udev);\r\nif (!dev->udev) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nmemset(dev->ep, 0, sizeof(dev->ep));\r\nusb_set_intfdata(intf, dev);\r\nerr = usb_set_interface(dev->udev, intf->altsetting[0].desc.bInterfaceNumber, 3);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to set alternative setting 3 for %d interface: err=%d.\n",\r\nintf->altsetting[0].desc.bInterfaceNumber, err);\r\ngoto err_out_clear;\r\n}\r\nerr = usb_reset_configuration(dev->udev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to reset configuration: err=%d.\n", err);\r\ngoto err_out_clear;\r\n}\r\niface_desc = &intf->altsetting[0];\r\nif (iface_desc->desc.bNumEndpoints != NUM_EP-1) {\r\nprintk(KERN_INFO "Num endpoints=%d. It is not DS9490R.\n", iface_desc->desc.bNumEndpoints);\r\nerr = -EINVAL;\r\ngoto err_out_clear;\r\n}\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\ndev->ep[i+1] = endpoint->bEndpointAddress;\r\n#if 0\r\nprintk("%d: addr=%x, size=%d, dir=%s, type=%x\n",\r\ni, endpoint->bEndpointAddress, le16_to_cpu(endpoint->wMaxPacketSize),\r\n(endpoint->bEndpointAddress & USB_DIR_IN)?"IN":"OUT",\r\nendpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\r\n#endif\r\n}\r\nerr = ds_w1_init(dev);\r\nif (err)\r\ngoto err_out_clear;\r\nmutex_lock(&ds_mutex);\r\nlist_add_tail(&dev->ds_entry, &ds_devices);\r\nmutex_unlock(&ds_mutex);\r\nreturn 0;\r\nerr_out_clear:\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(dev->udev);\r\nerr_out_free:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void ds_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ds_device *dev;\r\ndev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn;\r\nmutex_lock(&ds_mutex);\r\nlist_del(&dev->ds_entry);\r\nmutex_unlock(&ds_mutex);\r\nds_w1_fini(dev);\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(dev->udev);\r\nkfree(dev);\r\n}\r\nstatic int ds_init(void)\r\n{\r\nint err;\r\nerr = usb_register(&ds_driver);\r\nif (err) {\r\nprintk(KERN_INFO "Failed to register DS9490R USB device: err=%d.\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ds_fini(void)\r\n{\r\nusb_deregister(&ds_driver);\r\n}
