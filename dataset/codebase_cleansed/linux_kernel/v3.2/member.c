static void add_ordered_member(struct dlm_ls *ls, struct dlm_member *new)\r\n{\r\nstruct dlm_member *memb = NULL;\r\nstruct list_head *tmp;\r\nstruct list_head *newlist = &new->list;\r\nstruct list_head *head = &ls->ls_nodes;\r\nlist_for_each(tmp, head) {\r\nmemb = list_entry(tmp, struct dlm_member, list);\r\nif (new->nodeid < memb->nodeid)\r\nbreak;\r\n}\r\nif (!memb)\r\nlist_add_tail(newlist, head);\r\nelse {\r\nnewlist->prev = tmp->prev;\r\nnewlist->next = tmp;\r\ntmp->prev->next = newlist;\r\ntmp->prev = newlist;\r\n}\r\n}\r\nstatic int dlm_add_member(struct dlm_ls *ls, int nodeid)\r\n{\r\nstruct dlm_member *memb;\r\nint w, error;\r\nmemb = kzalloc(sizeof(struct dlm_member), GFP_NOFS);\r\nif (!memb)\r\nreturn -ENOMEM;\r\nw = dlm_node_weight(ls->ls_name, nodeid);\r\nif (w < 0) {\r\nkfree(memb);\r\nreturn w;\r\n}\r\nerror = dlm_lowcomms_connect_node(nodeid);\r\nif (error < 0) {\r\nkfree(memb);\r\nreturn error;\r\n}\r\nmemb->nodeid = nodeid;\r\nmemb->weight = w;\r\nadd_ordered_member(ls, memb);\r\nls->ls_num_nodes++;\r\nreturn 0;\r\n}\r\nstatic void dlm_remove_member(struct dlm_ls *ls, struct dlm_member *memb)\r\n{\r\nlist_move(&memb->list, &ls->ls_nodes_gone);\r\nls->ls_num_nodes--;\r\n}\r\nint dlm_is_member(struct dlm_ls *ls, int nodeid)\r\n{\r\nstruct dlm_member *memb;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (memb->nodeid == nodeid)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\r\n{\r\nstruct dlm_member *memb;\r\nlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\r\nif (memb->nodeid == nodeid)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void clear_memb_list(struct list_head *head)\r\n{\r\nstruct dlm_member *memb;\r\nwhile (!list_empty(head)) {\r\nmemb = list_entry(head->next, struct dlm_member, list);\r\nlist_del(&memb->list);\r\nkfree(memb);\r\n}\r\n}\r\nvoid dlm_clear_members(struct dlm_ls *ls)\r\n{\r\nclear_memb_list(&ls->ls_nodes);\r\nls->ls_num_nodes = 0;\r\n}\r\nvoid dlm_clear_members_gone(struct dlm_ls *ls)\r\n{\r\nclear_memb_list(&ls->ls_nodes_gone);\r\n}\r\nstatic void make_member_array(struct dlm_ls *ls)\r\n{\r\nstruct dlm_member *memb;\r\nint i, w, x = 0, total = 0, all_zero = 0, *array;\r\nkfree(ls->ls_node_array);\r\nls->ls_node_array = NULL;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (memb->weight)\r\ntotal += memb->weight;\r\n}\r\nif (!total) {\r\ntotal = ls->ls_num_nodes;\r\nall_zero = 1;\r\n}\r\nls->ls_total_weight = total;\r\narray = kmalloc(sizeof(int) * total, GFP_NOFS);\r\nif (!array)\r\nreturn;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (!all_zero && !memb->weight)\r\ncontinue;\r\nif (all_zero)\r\nw = 1;\r\nelse\r\nw = memb->weight;\r\nDLM_ASSERT(x < total, printk("total %d x %d\n", total, x););\r\nfor (i = 0; i < w; i++)\r\narray[x++] = memb->nodeid;\r\n}\r\nls->ls_node_array = array;\r\n}\r\nstatic int ping_members(struct dlm_ls *ls)\r\n{\r\nstruct dlm_member *memb;\r\nint error = 0;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nerror = dlm_recovery_stopped(ls);\r\nif (error)\r\nbreak;\r\nerror = dlm_rcom_status(ls, memb->nodeid);\r\nif (error)\r\nbreak;\r\n}\r\nif (error)\r\nlog_debug(ls, "ping_members aborted %d last nodeid %d",\r\nerror, ls->ls_recover_nodeid);\r\nreturn error;\r\n}\r\nint dlm_recover_members(struct dlm_ls *ls, struct dlm_recover *rv, int *neg_out)\r\n{\r\nstruct dlm_member *memb, *safe;\r\nint i, error, found, pos = 0, neg = 0, low = -1;\r\nlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\r\nlog_debug(ls, "prev removed member %d", memb->nodeid);\r\nneg++;\r\n}\r\nlist_for_each_entry_safe(memb, safe, &ls->ls_nodes, list) {\r\nfound = 0;\r\nfor (i = 0; i < rv->node_count; i++) {\r\nif (memb->nodeid == rv->nodeids[i]) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nneg++;\r\ndlm_remove_member(ls, memb);\r\nlog_debug(ls, "remove member %d", memb->nodeid);\r\n}\r\n}\r\nfor (i = 0; i < rv->new_count; i++) {\r\nif (!dlm_is_member(ls, rv->new[i]))\r\ncontinue;\r\nlog_debug(ls, "new nodeid %d is a re-added member", rv->new[i]);\r\nmemb = kzalloc(sizeof(struct dlm_member), GFP_NOFS);\r\nif (!memb)\r\nreturn -ENOMEM;\r\nmemb->nodeid = rv->new[i];\r\nlist_add_tail(&memb->list, &ls->ls_nodes_gone);\r\nneg++;\r\n}\r\nfor (i = 0; i < rv->node_count; i++) {\r\nif (dlm_is_member(ls, rv->nodeids[i]))\r\ncontinue;\r\ndlm_add_member(ls, rv->nodeids[i]);\r\npos++;\r\nlog_debug(ls, "add member %d", rv->nodeids[i]);\r\n}\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (low == -1 || memb->nodeid < low)\r\nlow = memb->nodeid;\r\n}\r\nls->ls_low_nodeid = low;\r\nmake_member_array(ls);\r\ndlm_set_recover_status(ls, DLM_RS_NODES);\r\n*neg_out = neg;\r\nerror = ping_members(ls);\r\nif (!error || error == -EPROTO) {\r\nls->ls_members_result = error;\r\ncomplete(&ls->ls_members_done);\r\n}\r\nif (error)\r\ngoto out;\r\nerror = dlm_recover_members_wait(ls);\r\nout:\r\nlog_debug(ls, "total members %d error %d", ls->ls_num_nodes, error);\r\nreturn error;\r\n}\r\nint dlm_ls_stop(struct dlm_ls *ls)\r\n{\r\nint new;\r\ndown_write(&ls->ls_recv_active);\r\nspin_lock(&ls->ls_recover_lock);\r\nset_bit(LSFL_RECOVERY_STOP, &ls->ls_flags);\r\nnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\r\nls->ls_recover_seq++;\r\nspin_unlock(&ls->ls_recover_lock);\r\nup_write(&ls->ls_recv_active);\r\nif (new)\r\ndown_write(&ls->ls_in_recovery);\r\ndlm_recoverd_suspend(ls);\r\nls->ls_recover_status = 0;\r\ndlm_recoverd_resume(ls);\r\nif (!ls->ls_recover_begin)\r\nls->ls_recover_begin = jiffies;\r\nreturn 0;\r\n}\r\nint dlm_ls_start(struct dlm_ls *ls)\r\n{\r\nstruct dlm_recover *rv = NULL, *rv_old;\r\nint *ids = NULL, *new = NULL;\r\nint error, ids_count = 0, new_count = 0;\r\nrv = kzalloc(sizeof(struct dlm_recover), GFP_NOFS);\r\nif (!rv)\r\nreturn -ENOMEM;\r\nerror = dlm_nodeid_list(ls->ls_name, &ids, &ids_count,\r\n&new, &new_count);\r\nif (error < 0)\r\ngoto fail;\r\nspin_lock(&ls->ls_recover_lock);\r\nif (!dlm_locking_stopped(ls)) {\r\nspin_unlock(&ls->ls_recover_lock);\r\nlog_error(ls, "start ignored: lockspace running");\r\nerror = -EINVAL;\r\ngoto fail;\r\n}\r\nrv->nodeids = ids;\r\nrv->node_count = ids_count;\r\nrv->new = new;\r\nrv->new_count = new_count;\r\nrv->seq = ++ls->ls_recover_seq;\r\nrv_old = ls->ls_recover_args;\r\nls->ls_recover_args = rv;\r\nspin_unlock(&ls->ls_recover_lock);\r\nif (rv_old) {\r\nlog_error(ls, "unused recovery %llx %d",\r\n(unsigned long long)rv_old->seq, rv_old->node_count);\r\nkfree(rv_old->nodeids);\r\nkfree(rv_old->new);\r\nkfree(rv_old);\r\n}\r\ndlm_recoverd_kick(ls);\r\nreturn 0;\r\nfail:\r\nkfree(rv);\r\nkfree(ids);\r\nkfree(new);\r\nreturn error;\r\n}
