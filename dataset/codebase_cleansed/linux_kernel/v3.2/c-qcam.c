static inline void qcam_set_ack(struct qcam *qcam, unsigned int i)\r\n{\r\nparport_frob_control(qcam->pport, 8, i ? 8 : 0);\r\n}\r\nstatic inline unsigned int qcam_ready1(struct qcam *qcam)\r\n{\r\nreturn (parport_read_status(qcam->pport) & 0x8) ? 1 : 0;\r\n}\r\nstatic inline unsigned int qcam_ready2(struct qcam *qcam)\r\n{\r\nreturn (parport_read_data(qcam->pport) & 0x1) ? 1 : 0;\r\n}\r\nstatic unsigned int qcam_await_ready1(struct qcam *qcam, int value)\r\n{\r\nstruct v4l2_device *v4l2_dev = &qcam->v4l2_dev;\r\nunsigned long oldjiffies = jiffies;\r\nunsigned int i;\r\nfor (oldjiffies = jiffies;\r\ntime_before(jiffies, oldjiffies + msecs_to_jiffies(40));)\r\nif (qcam_ready1(qcam) == value)\r\nreturn 0;\r\nfor (i = 0; i < 50; i++) {\r\nif (qcam_ready1(qcam) == value)\r\nreturn 0;\r\nmsleep_interruptible(100);\r\n}\r\nv4l2_err(v4l2_dev, "ready1 timeout (%d) %x %x\n", value,\r\nparport_read_status(qcam->pport),\r\nparport_read_control(qcam->pport));\r\nreturn 1;\r\n}\r\nstatic unsigned int qcam_await_ready2(struct qcam *qcam, int value)\r\n{\r\nstruct v4l2_device *v4l2_dev = &qcam->v4l2_dev;\r\nunsigned long oldjiffies = jiffies;\r\nunsigned int i;\r\nfor (oldjiffies = jiffies;\r\ntime_before(jiffies, oldjiffies + msecs_to_jiffies(40));)\r\nif (qcam_ready2(qcam) == value)\r\nreturn 0;\r\nfor (i = 0; i < 50; i++) {\r\nif (qcam_ready2(qcam) == value)\r\nreturn 0;\r\nmsleep_interruptible(100);\r\n}\r\nv4l2_err(v4l2_dev, "ready2 timeout (%d) %x %x %x\n", value,\r\nparport_read_status(qcam->pport),\r\nparport_read_control(qcam->pport),\r\nparport_read_data(qcam->pport));\r\nreturn 1;\r\n}\r\nstatic int qcam_read_data(struct qcam *qcam)\r\n{\r\nunsigned int idata;\r\nqcam_set_ack(qcam, 0);\r\nif (qcam_await_ready1(qcam, 1))\r\nreturn -1;\r\nidata = parport_read_status(qcam->pport) & 0xf0;\r\nqcam_set_ack(qcam, 1);\r\nif (qcam_await_ready1(qcam, 0))\r\nreturn -1;\r\nidata |= parport_read_status(qcam->pport) >> 4;\r\nreturn idata;\r\n}\r\nstatic int qcam_write_data(struct qcam *qcam, unsigned int data)\r\n{\r\nstruct v4l2_device *v4l2_dev = &qcam->v4l2_dev;\r\nunsigned int idata;\r\nparport_write_data(qcam->pport, data);\r\nidata = qcam_read_data(qcam);\r\nif (data != idata) {\r\nv4l2_warn(v4l2_dev, "sent %x but received %x\n", data,\r\nidata);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int qcam_set(struct qcam *qcam, unsigned int cmd, unsigned int data)\r\n{\r\nif (qcam_write_data(qcam, cmd))\r\nreturn -1;\r\nif (qcam_write_data(qcam, data))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic inline int qcam_get(struct qcam *qcam, unsigned int cmd)\r\n{\r\nif (qcam_write_data(qcam, cmd))\r\nreturn -1;\r\nreturn qcam_read_data(qcam);\r\n}\r\nstatic int qc_detect(struct qcam *qcam)\r\n{\r\nunsigned int stat, ostat, i, count = 0;\r\nif (qcam->pport->probe_info[0].class == PARPORT_CLASS_MEDIA\r\n&& qcam->pport->probe_info[0].model\r\n&& !strcmp(qcam->pdev->port->probe_info[0].model,\r\n"Color QuickCam 2.0")) {\r\nprintk(KERN_DEBUG "QuickCam: Found by IEEE1284 probe.\n");\r\nreturn 1;\r\n}\r\nif (probe < 2)\r\nreturn 0;\r\nparport_write_control(qcam->pport, 0xc);\r\nostat = stat = parport_read_status(qcam->pport);\r\nfor (i = 0; i < 250; i++) {\r\nmdelay(1);\r\nstat = parport_read_status(qcam->pport);\r\nif (ostat != stat) {\r\nif (++count >= 3)\r\nreturn 1;\r\nostat = stat;\r\n}\r\n}\r\nparport_write_control(qcam->pport, 0xc);\r\nparport_write_control(qcam->pport, 0x8);\r\nmdelay(1);\r\nparport_write_control(qcam->pport, 0xc);\r\nmdelay(1);\r\ncount = 0;\r\nostat = stat = parport_read_status(qcam->pport);\r\nfor (i = 0; i < 250; i++) {\r\nmdelay(1);\r\nstat = parport_read_status(qcam->pport);\r\nif (ostat != stat) {\r\nif (++count >= 3)\r\nreturn 1;\r\nostat = stat;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qc_reset(struct qcam *qcam)\r\n{\r\nparport_write_control(qcam->pport, 0xc);\r\nparport_write_control(qcam->pport, 0x8);\r\nmdelay(1);\r\nparport_write_control(qcam->pport, 0xc);\r\nmdelay(1);\r\n}\r\nstatic void qc_setup(struct qcam *qcam)\r\n{\r\nqc_reset(qcam);\r\nqcam_set(qcam, 11, qcam->brightness);\r\nqcam_set(qcam, 17, qcam->ccd_height);\r\nqcam_set(qcam, 19, qcam->ccd_width / 2);\r\nqcam_set(qcam, 0xd, qcam->top);\r\nqcam_set(qcam, 0xf, qcam->left);\r\nqcam_set(qcam, 0x19, qcam->contrast);\r\nqcam_set(qcam, 0x1f, qcam->whitebal);\r\nqcam_set(qcam, 45, 2);\r\n}\r\nstatic unsigned int qcam_read_bytes(struct qcam *qcam, unsigned char *buf, unsigned int nbytes)\r\n{\r\nunsigned int bytes = 0;\r\nqcam_set_ack(qcam, 0);\r\nif (qcam->bidirectional) {\r\nwhile (bytes < nbytes) {\r\nunsigned int lo1, hi1, lo2, hi2;\r\nunsigned char r, g, b;\r\nif (qcam_await_ready2(qcam, 1))\r\nreturn bytes;\r\nlo1 = parport_read_data(qcam->pport) >> 1;\r\nhi1 = ((parport_read_status(qcam->pport) >> 3) & 0x1f) ^ 0x10;\r\nqcam_set_ack(qcam, 1);\r\nif (qcam_await_ready2(qcam, 0))\r\nreturn bytes;\r\nlo2 = parport_read_data(qcam->pport) >> 1;\r\nhi2 = ((parport_read_status(qcam->pport) >> 3) & 0x1f) ^ 0x10;\r\nqcam_set_ack(qcam, 0);\r\nr = lo1 | ((hi1 & 1) << 7);\r\ng = ((hi1 & 0x1e) << 3) | ((hi2 & 0x1e) >> 1);\r\nb = lo2 | ((hi2 & 1) << 7);\r\nif (force_rgb) {\r\nbuf[bytes++] = r;\r\nbuf[bytes++] = g;\r\nbuf[bytes++] = b;\r\n} else {\r\nbuf[bytes++] = b;\r\nbuf[bytes++] = g;\r\nbuf[bytes++] = r;\r\n}\r\n}\r\n} else {\r\nint i = 0, n = bytes;\r\nunsigned char rgb[3];\r\nwhile (bytes < nbytes) {\r\nunsigned int hi, lo;\r\nif (qcam_await_ready1(qcam, 1))\r\nreturn bytes;\r\nhi = (parport_read_status(qcam->pport) & 0xf0);\r\nqcam_set_ack(qcam, 1);\r\nif (qcam_await_ready1(qcam, 0))\r\nreturn bytes;\r\nlo = (parport_read_status(qcam->pport) & 0xf0);\r\nqcam_set_ack(qcam, 0);\r\nrgb[(i = bytes++ % 3)] = (hi | (lo >> 4)) ^ 0x88;\r\nif (i >= 2) {\r\nget_fragment:\r\nif (force_rgb) {\r\nbuf[n++] = rgb[0];\r\nbuf[n++] = rgb[1];\r\nbuf[n++] = rgb[2];\r\n} else {\r\nbuf[n++] = rgb[2];\r\nbuf[n++] = rgb[1];\r\nbuf[n++] = rgb[0];\r\n}\r\n}\r\n}\r\nif (i) {\r\ni = 0;\r\ngoto get_fragment;\r\n}\r\n}\r\nreturn bytes;\r\n}\r\nstatic long qc_capture(struct qcam *qcam, char __user *buf, unsigned long len)\r\n{\r\nstruct v4l2_device *v4l2_dev = &qcam->v4l2_dev;\r\nunsigned lines, pixelsperline, bitsperxfer;\r\nunsigned int is_bi_dir = qcam->bidirectional;\r\nsize_t wantlen, outptr = 0;\r\nchar tmpbuf[BUFSZ];\r\nif (!access_ok(VERIFY_WRITE, buf, len))\r\nreturn -EFAULT;\r\nfor (;;) {\r\nint i = qcam_get(qcam, 41);\r\nif (i == -1) {\r\nqc_setup(qcam);\r\nreturn -EIO;\r\n}\r\nif ((i & 0x80) == 0)\r\nbreak;\r\nschedule();\r\n}\r\nif (qcam_set(qcam, 7, (qcam->mode | (is_bi_dir ? 1 : 0)) + 1))\r\nreturn -EIO;\r\nlines = qcam->height;\r\npixelsperline = qcam->width;\r\nbitsperxfer = (is_bi_dir) ? 24 : 8;\r\nif (is_bi_dir) {\r\nparport_data_reverse(qcam->pport);\r\nmdelay(3);\r\nqcam_set_ack(qcam, 0);\r\nif (qcam_await_ready1(qcam, 1)) {\r\nqc_setup(qcam);\r\nreturn -EIO;\r\n}\r\nqcam_set_ack(qcam, 1);\r\nif (qcam_await_ready1(qcam, 0)) {\r\nqc_setup(qcam);\r\nreturn -EIO;\r\n}\r\n}\r\nwantlen = lines * pixelsperline * 24 / 8;\r\nwhile (wantlen) {\r\nsize_t t, s;\r\ns = (wantlen > BUFSZ) ? BUFSZ : wantlen;\r\nt = qcam_read_bytes(qcam, tmpbuf, s);\r\nif (outptr < len) {\r\nsize_t sz = len - outptr;\r\nif (sz > t)\r\nsz = t;\r\nif (__copy_to_user(buf + outptr, tmpbuf, sz))\r\nbreak;\r\noutptr += sz;\r\n}\r\nwantlen -= t;\r\nif (t < s)\r\nbreak;\r\ncond_resched();\r\n}\r\nlen = outptr;\r\nif (wantlen) {\r\nv4l2_err(v4l2_dev, "short read.\n");\r\nif (is_bi_dir)\r\nparport_data_forward(qcam->pport);\r\nqc_setup(qcam);\r\nreturn len;\r\n}\r\nif (is_bi_dir) {\r\nint l;\r\ndo {\r\nl = qcam_read_bytes(qcam, tmpbuf, 3);\r\ncond_resched();\r\n} while (l && (tmpbuf[0] == 0x7e || tmpbuf[1] == 0x7e || tmpbuf[2] == 0x7e));\r\nif (force_rgb) {\r\nif (tmpbuf[0] != 0xe || tmpbuf[1] != 0x0 || tmpbuf[2] != 0xf)\r\nv4l2_err(v4l2_dev, "bad EOF\n");\r\n} else {\r\nif (tmpbuf[0] != 0xf || tmpbuf[1] != 0x0 || tmpbuf[2] != 0xe)\r\nv4l2_err(v4l2_dev, "bad EOF\n");\r\n}\r\nqcam_set_ack(qcam, 0);\r\nif (qcam_await_ready1(qcam, 1)) {\r\nv4l2_err(v4l2_dev, "no ack after EOF\n");\r\nparport_data_forward(qcam->pport);\r\nqc_setup(qcam);\r\nreturn len;\r\n}\r\nparport_data_forward(qcam->pport);\r\nmdelay(3);\r\nqcam_set_ack(qcam, 1);\r\nif (qcam_await_ready1(qcam, 0)) {\r\nv4l2_err(v4l2_dev, "no ack to port turnaround\n");\r\nqc_setup(qcam);\r\nreturn len;\r\n}\r\n} else {\r\nint l;\r\ndo {\r\nl = qcam_read_bytes(qcam, tmpbuf, 1);\r\ncond_resched();\r\n} while (l && tmpbuf[0] == 0x7e);\r\nl = qcam_read_bytes(qcam, tmpbuf + 1, 2);\r\nif (force_rgb) {\r\nif (tmpbuf[0] != 0xe || tmpbuf[1] != 0x0 || tmpbuf[2] != 0xf)\r\nv4l2_err(v4l2_dev, "bad EOF\n");\r\n} else {\r\nif (tmpbuf[0] != 0xf || tmpbuf[1] != 0x0 || tmpbuf[2] != 0xe)\r\nv4l2_err(v4l2_dev, "bad EOF\n");\r\n}\r\n}\r\nqcam_write_data(qcam, 0);\r\nreturn len;\r\n}\r\nstatic int qcam_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *vcap)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nstrlcpy(vcap->driver, qcam->v4l2_dev.name, sizeof(vcap->driver));\r\nstrlcpy(vcap->card, "Color Quickcam", sizeof(vcap->card));\r\nstrlcpy(vcap->bus_info, "parport", sizeof(vcap->bus_info));\r\nvcap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int qcam_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\r\n{\r\nif (vin->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(vin->name, "Camera", sizeof(vin->name));\r\nvin->type = V4L2_INPUT_TYPE_CAMERA;\r\nvin->audioset = 0;\r\nvin->tuner = 0;\r\nvin->std = 0;\r\nvin->status = 0;\r\nreturn 0;\r\n}\r\nstatic int qcam_g_input(struct file *file, void *fh, unsigned int *inp)\r\n{\r\n*inp = 0;\r\nreturn 0;\r\n}\r\nstatic int qcam_s_input(struct file *file, void *fh, unsigned int inp)\r\n{\r\nreturn (inp > 0) ? -EINVAL : 0;\r\n}\r\nstatic int qcam_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 255, 1, 240);\r\ncase V4L2_CID_CONTRAST:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 255, 1, 192);\r\ncase V4L2_CID_GAMMA:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int qcam_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = qcam->brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->value = qcam->contrast;\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nctrl->value = qcam->whitebal;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int qcam_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nint ret = 0;\r\nmutex_lock(&qcam->lock);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nqcam->brightness = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nqcam->contrast = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nqcam->whitebal = ctrl->value;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret == 0) {\r\nparport_claim_or_block(qcam->pdev);\r\nqc_setup(qcam);\r\nparport_release(qcam->pdev);\r\n}\r\nmutex_unlock(&qcam->lock);\r\nreturn ret;\r\n}\r\nstatic int qcam_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\npix->width = qcam->width;\r\npix->height = qcam->height;\r\npix->pixelformat = V4L2_PIX_FMT_RGB24;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = 3 * qcam->width;\r\npix->sizeimage = 3 * qcam->width * qcam->height;\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int qcam_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nif (pix->height < 60 || pix->width < 80) {\r\npix->height = 60;\r\npix->width = 80;\r\n} else if (pix->height < 120 || pix->width < 160) {\r\npix->height = 120;\r\npix->width = 160;\r\n} else {\r\npix->height = 240;\r\npix->width = 320;\r\n}\r\npix->pixelformat = V4L2_PIX_FMT_RGB24;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = 3 * pix->width;\r\npix->sizeimage = 3 * pix->width * pix->height;\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int qcam_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nint ret = qcam_try_fmt_vid_cap(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\nswitch (pix->height) {\r\ncase 60:\r\nqcam->mode = QC_DECIMATION_4;\r\nbreak;\r\ncase 120:\r\nqcam->mode = QC_DECIMATION_2;\r\nbreak;\r\ndefault:\r\nqcam->mode = QC_DECIMATION_1;\r\nbreak;\r\n}\r\nmutex_lock(&qcam->lock);\r\nqcam->mode |= QC_MILLIONS;\r\nqcam->height = pix->height;\r\nqcam->width = pix->width;\r\nparport_claim_or_block(qcam->pdev);\r\nqc_setup(qcam);\r\nparport_release(qcam->pdev);\r\nmutex_unlock(&qcam->lock);\r\nreturn 0;\r\n}\r\nstatic int qcam_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\r\n{\r\nstatic struct v4l2_fmtdesc formats[] = {\r\n{ 0, 0, 0,\r\n"RGB 8:8:8", V4L2_PIX_FMT_RGB24,\r\n{ 0, 0, 0, 0 }\r\n},\r\n};\r\nenum v4l2_buf_type type = fmt->type;\r\nif (fmt->index > 0)\r\nreturn -EINVAL;\r\n*fmt = formats[fmt->index];\r\nfmt->type = type;\r\nreturn 0;\r\n}\r\nstatic ssize_t qcam_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nint len;\r\nmutex_lock(&qcam->lock);\r\nparport_claim_or_block(qcam->pdev);\r\nlen = qc_capture(qcam, buf, count);\r\nparport_release(qcam->pdev);\r\nmutex_unlock(&qcam->lock);\r\nreturn len;\r\n}\r\nstatic struct qcam *qcam_init(struct parport *port)\r\n{\r\nstruct qcam *qcam;\r\nstruct v4l2_device *v4l2_dev;\r\nqcam = kzalloc(sizeof(*qcam), GFP_KERNEL);\r\nif (qcam == NULL)\r\nreturn NULL;\r\nv4l2_dev = &qcam->v4l2_dev;\r\nstrlcpy(v4l2_dev->name, "c-qcam", sizeof(v4l2_dev->name));\r\nif (v4l2_device_register(NULL, v4l2_dev) < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nkfree(qcam);\r\nreturn NULL;\r\n}\r\nqcam->pport = port;\r\nqcam->pdev = parport_register_device(port, "c-qcam", NULL, NULL,\r\nNULL, 0, NULL);\r\nqcam->bidirectional = (qcam->pport->modes & PARPORT_MODE_TRISTATE) ? 1 : 0;\r\nif (qcam->pdev == NULL) {\r\nv4l2_err(v4l2_dev, "couldn't register for %s.\n", port->name);\r\nkfree(qcam);\r\nreturn NULL;\r\n}\r\nstrlcpy(qcam->vdev.name, "Colour QuickCam", sizeof(qcam->vdev.name));\r\nqcam->vdev.v4l2_dev = v4l2_dev;\r\nqcam->vdev.fops = &qcam_fops;\r\nqcam->vdev.ioctl_ops = &qcam_ioctl_ops;\r\nqcam->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&qcam->vdev, qcam);\r\nmutex_init(&qcam->lock);\r\nqcam->width = qcam->ccd_width = 320;\r\nqcam->height = qcam->ccd_height = 240;\r\nqcam->mode = QC_MILLIONS | QC_DECIMATION_1;\r\nqcam->contrast = 192;\r\nqcam->brightness = 240;\r\nqcam->whitebal = 128;\r\nqcam->top = 1;\r\nqcam->left = 14;\r\nreturn qcam;\r\n}\r\nstatic int init_cqcam(struct parport *port)\r\n{\r\nstruct qcam *qcam;\r\nstruct v4l2_device *v4l2_dev;\r\nif (parport[0] != -1) {\r\nint i, found = 0;\r\nfor (i = 0; i < MAX_CAMS && parport[i] != -1; i++) {\r\nif (parport[0] == port->number)\r\nfound = 1;\r\n}\r\nif (!found)\r\nreturn -ENODEV;\r\n}\r\nif (num_cams == MAX_CAMS)\r\nreturn -ENOSPC;\r\nqcam = qcam_init(port);\r\nif (qcam == NULL)\r\nreturn -ENODEV;\r\nv4l2_dev = &qcam->v4l2_dev;\r\nparport_claim_or_block(qcam->pdev);\r\nqc_reset(qcam);\r\nif (probe && qc_detect(qcam) == 0) {\r\nparport_release(qcam->pdev);\r\nparport_unregister_device(qcam->pdev);\r\nkfree(qcam);\r\nreturn -ENODEV;\r\n}\r\nqc_setup(qcam);\r\nparport_release(qcam->pdev);\r\nif (video_register_device(&qcam->vdev, VFL_TYPE_GRABBER, video_nr) < 0) {\r\nv4l2_err(v4l2_dev, "Unable to register Colour QuickCam on %s\n",\r\nqcam->pport->name);\r\nparport_unregister_device(qcam->pdev);\r\nkfree(qcam);\r\nreturn -ENODEV;\r\n}\r\nv4l2_info(v4l2_dev, "%s: Colour QuickCam found on %s\n",\r\nvideo_device_node_name(&qcam->vdev), qcam->pport->name);\r\nqcams[num_cams++] = qcam;\r\nreturn 0;\r\n}\r\nstatic void close_cqcam(struct qcam *qcam)\r\n{\r\nvideo_unregister_device(&qcam->vdev);\r\nparport_unregister_device(qcam->pdev);\r\nkfree(qcam);\r\n}\r\nstatic void cq_attach(struct parport *port)\r\n{\r\ninit_cqcam(port);\r\n}\r\nstatic void cq_detach(struct parport *port)\r\n{\r\n}\r\nstatic int __init cqcam_init(void)\r\n{\r\nprintk(KERN_INFO BANNER "\n");\r\nreturn parport_register_driver(&cqcam_driver);\r\n}\r\nstatic void __exit cqcam_cleanup(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_cams; i++)\r\nclose_cqcam(qcams[i]);\r\nparport_unregister_driver(&cqcam_driver);\r\n}
