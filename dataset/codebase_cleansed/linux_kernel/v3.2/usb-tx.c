static\r\nint i2400mu_tx(struct i2400mu *i2400mu, struct i2400m_msg_hdr *tx_msg,\r\nsize_t tx_msg_size)\r\n{\r\nint result = 0;\r\nstruct i2400m *i2400m = &i2400mu->i2400m;\r\nstruct device *dev = &i2400mu->usb_iface->dev;\r\nint usb_pipe, sent_size, do_autopm;\r\nstruct usb_endpoint_descriptor *epd;\r\nd_fnstart(4, dev, "(i2400mu %p)\n", i2400mu);\r\ndo_autopm = atomic_read(&i2400mu->do_autopm);\r\nresult = do_autopm ?\r\nusb_autopm_get_interface(i2400mu->usb_iface) : 0;\r\nif (result < 0) {\r\ndev_err(dev, "TX: can't get autopm: %d\n", result);\r\ndo_autopm = 0;\r\n}\r\nepd = usb_get_epd(i2400mu->usb_iface, i2400mu->endpoint_cfg.bulk_out);\r\nusb_pipe = usb_sndbulkpipe(i2400mu->usb_dev, epd->bEndpointAddress);\r\nretry:\r\nresult = usb_bulk_msg(i2400mu->usb_dev, usb_pipe,\r\ntx_msg, tx_msg_size, &sent_size, 200);\r\nusb_mark_last_busy(i2400mu->usb_dev);\r\nswitch (result) {\r\ncase 0:\r\nif (sent_size != tx_msg_size) {\r\ndev_err(dev, "TX: short write (%d B vs %zu "\r\n"expected)\n", sent_size, tx_msg_size);\r\nresult = -EIO;\r\n}\r\nbreak;\r\ncase -EPIPE:\r\nif (edc_inc(&i2400mu->urb_edc,\r\n10 * EDC_MAX_ERRORS, EDC_ERROR_TIMEFRAME)) {\r\ndev_err(dev, "BM-CMD: too many stalls in "\r\n"URB; resetting device\n");\r\nusb_queue_reset_device(i2400mu->usb_iface);\r\n} else {\r\nusb_clear_halt(i2400mu->usb_dev, usb_pipe);\r\nmsleep(10);\r\ngoto retry;\r\n}\r\ncase -EINVAL:\r\ncase -ENODEV:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNRESET:\r\nresult = -ESHUTDOWN;\r\nbreak;\r\ndefault:\r\nif (edc_inc(&i2400mu->urb_edc,\r\nEDC_MAX_ERRORS, EDC_ERROR_TIMEFRAME)) {\r\ndev_err(dev, "TX: maximum errors in URB "\r\n"exceeded; resetting device\n");\r\nusb_queue_reset_device(i2400mu->usb_iface);\r\n} else {\r\ndev_err(dev, "TX: cannot send URB; retrying. "\r\n"tx_msg @%zu %zu B [%d sent]: %d\n",\r\n(void *) tx_msg - i2400m->tx_buf,\r\ntx_msg_size, sent_size, result);\r\ngoto retry;\r\n}\r\n}\r\nif (do_autopm)\r\nusb_autopm_put_interface(i2400mu->usb_iface);\r\nd_fnend(4, dev, "(i2400mu %p) = result\n", i2400mu);\r\nreturn result;\r\n}\r\nstatic\r\nint i2400mu_txd(void *_i2400mu)\r\n{\r\nint result = 0;\r\nstruct i2400mu *i2400mu = _i2400mu;\r\nstruct i2400m *i2400m = &i2400mu->i2400m;\r\nstruct device *dev = &i2400mu->usb_iface->dev;\r\nstruct i2400m_msg_hdr *tx_msg;\r\nsize_t tx_msg_size;\r\nunsigned long flags;\r\nd_fnstart(4, dev, "(i2400mu %p)\n", i2400mu);\r\nspin_lock_irqsave(&i2400m->tx_lock, flags);\r\nBUG_ON(i2400mu->tx_kthread != NULL);\r\ni2400mu->tx_kthread = current;\r\nspin_unlock_irqrestore(&i2400m->tx_lock, flags);\r\nwhile (1) {\r\nd_printf(2, dev, "TX: waiting for messages\n");\r\ntx_msg = NULL;\r\nwait_event_interruptible(\r\ni2400mu->tx_wq,\r\n(kthread_should_stop()\r\n|| (tx_msg = i2400m_tx_msg_get(i2400m, &tx_msg_size)))\r\n);\r\nif (kthread_should_stop())\r\nbreak;\r\nWARN_ON(tx_msg == NULL);\r\nd_printf(2, dev, "TX: submitting %zu bytes\n", tx_msg_size);\r\nd_dump(5, dev, tx_msg, tx_msg_size);\r\ni2400mu_tx(i2400mu, tx_msg, tx_msg_size);\r\ni2400m_tx_msg_sent(i2400m);\r\nif (result < 0)\r\nbreak;\r\n}\r\nspin_lock_irqsave(&i2400m->tx_lock, flags);\r\ni2400mu->tx_kthread = NULL;\r\nspin_unlock_irqrestore(&i2400m->tx_lock, flags);\r\nd_fnend(4, dev, "(i2400mu %p) = %d\n", i2400mu, result);\r\nreturn result;\r\n}\r\nvoid i2400mu_bus_tx_kick(struct i2400m *i2400m)\r\n{\r\nstruct i2400mu *i2400mu = container_of(i2400m, struct i2400mu, i2400m);\r\nstruct device *dev = &i2400mu->usb_iface->dev;\r\nd_fnstart(3, dev, "(i2400m %p) = void\n", i2400m);\r\nwake_up_all(&i2400mu->tx_wq);\r\nd_fnend(3, dev, "(i2400m %p) = void\n", i2400m);\r\n}\r\nint i2400mu_tx_setup(struct i2400mu *i2400mu)\r\n{\r\nint result = 0;\r\nstruct i2400m *i2400m = &i2400mu->i2400m;\r\nstruct device *dev = &i2400mu->usb_iface->dev;\r\nstruct wimax_dev *wimax_dev = &i2400m->wimax_dev;\r\nstruct task_struct *kthread;\r\nkthread = kthread_run(i2400mu_txd, i2400mu, "%s-tx",\r\nwimax_dev->name);\r\nif (IS_ERR(kthread)) {\r\nresult = PTR_ERR(kthread);\r\ndev_err(dev, "TX: cannot start thread: %d\n", result);\r\n}\r\nreturn result;\r\n}\r\nvoid i2400mu_tx_release(struct i2400mu *i2400mu)\r\n{\r\nunsigned long flags;\r\nstruct i2400m *i2400m = &i2400mu->i2400m;\r\nstruct device *dev = i2400m_dev(i2400m);\r\nstruct task_struct *kthread;\r\nspin_lock_irqsave(&i2400m->tx_lock, flags);\r\nkthread = i2400mu->tx_kthread;\r\ni2400mu->tx_kthread = NULL;\r\nspin_unlock_irqrestore(&i2400m->tx_lock, flags);\r\nif (kthread)\r\nkthread_stop(kthread);\r\nelse\r\nd_printf(1, dev, "TX: kthread had already exited\n");\r\n}
