static void fm3130_rtc_mode(struct device *dev, int mode)\r\n{\r\nstruct fm3130 *fm3130 = dev_get_drvdata(dev);\r\nfm3130->regs[FM3130_RTC_CONTROL] =\r\ni2c_smbus_read_byte_data(fm3130->client, FM3130_RTC_CONTROL);\r\nswitch (mode) {\r\ncase FM3130_MODE_NORMAL:\r\nfm3130->regs[FM3130_RTC_CONTROL] &=\r\n~(FM3130_RTC_CONTROL_BIT_WRITE |\r\nFM3130_RTC_CONTROL_BIT_READ);\r\nbreak;\r\ncase FM3130_MODE_WRITE:\r\nfm3130->regs[FM3130_RTC_CONTROL] |= FM3130_RTC_CONTROL_BIT_WRITE;\r\nbreak;\r\ncase FM3130_MODE_READ:\r\nfm3130->regs[FM3130_RTC_CONTROL] |= FM3130_RTC_CONTROL_BIT_READ;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "invalid mode %d\n", mode);\r\nbreak;\r\n}\r\ni2c_smbus_write_byte_data(fm3130->client,\r\nFM3130_RTC_CONTROL, fm3130->regs[FM3130_RTC_CONTROL]);\r\n}\r\nstatic int fm3130_get_time(struct device *dev, struct rtc_time *t)\r\n{\r\nstruct fm3130 *fm3130 = dev_get_drvdata(dev);\r\nint tmp;\r\nif (!fm3130->data_valid) {\r\nreturn -EIO;\r\n}\r\nfm3130_rtc_mode(dev, FM3130_MODE_READ);\r\ntmp = i2c_transfer(to_i2c_adapter(fm3130->client->dev.parent),\r\nfm3130->msg, 2);\r\nif (tmp != 2) {\r\ndev_err(dev, "%s error %d\n", "read", tmp);\r\nreturn -EIO;\r\n}\r\nfm3130_rtc_mode(dev, FM3130_MODE_NORMAL);\r\ndev_dbg(dev, "%s: %02x %02x %02x %02x %02x %02x %02x %02x"\r\n"%02x %02x %02x %02x %02x %02x %02x\n",\r\n"read",\r\nfm3130->regs[0], fm3130->regs[1],\r\nfm3130->regs[2], fm3130->regs[3],\r\nfm3130->regs[4], fm3130->regs[5],\r\nfm3130->regs[6], fm3130->regs[7],\r\nfm3130->regs[8], fm3130->regs[9],\r\nfm3130->regs[0xa], fm3130->regs[0xb],\r\nfm3130->regs[0xc], fm3130->regs[0xd],\r\nfm3130->regs[0xe]);\r\nt->tm_sec = bcd2bin(fm3130->regs[FM3130_RTC_SECONDS] & 0x7f);\r\nt->tm_min = bcd2bin(fm3130->regs[FM3130_RTC_MINUTES] & 0x7f);\r\ntmp = fm3130->regs[FM3130_RTC_HOURS] & 0x3f;\r\nt->tm_hour = bcd2bin(tmp);\r\nt->tm_wday = bcd2bin(fm3130->regs[FM3130_RTC_DAY] & 0x07) - 1;\r\nt->tm_mday = bcd2bin(fm3130->regs[FM3130_RTC_DATE] & 0x3f);\r\ntmp = fm3130->regs[FM3130_RTC_MONTHS] & 0x1f;\r\nt->tm_mon = bcd2bin(tmp) - 1;\r\nt->tm_year = bcd2bin(fm3130->regs[FM3130_RTC_YEARS]) + 100;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"read", t->tm_sec, t->tm_min,\r\nt->tm_hour, t->tm_mday,\r\nt->tm_mon, t->tm_year, t->tm_wday);\r\nreturn rtc_valid_tm(t);\r\n}\r\nstatic int fm3130_set_time(struct device *dev, struct rtc_time *t)\r\n{\r\nstruct fm3130 *fm3130 = dev_get_drvdata(dev);\r\nint tmp, i;\r\nu8 *buf = fm3130->regs;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"write", t->tm_sec, t->tm_min,\r\nt->tm_hour, t->tm_mday,\r\nt->tm_mon, t->tm_year, t->tm_wday);\r\nbuf[FM3130_RTC_SECONDS] = bin2bcd(t->tm_sec);\r\nbuf[FM3130_RTC_MINUTES] = bin2bcd(t->tm_min);\r\nbuf[FM3130_RTC_HOURS] = bin2bcd(t->tm_hour);\r\nbuf[FM3130_RTC_DAY] = bin2bcd(t->tm_wday + 1);\r\nbuf[FM3130_RTC_DATE] = bin2bcd(t->tm_mday);\r\nbuf[FM3130_RTC_MONTHS] = bin2bcd(t->tm_mon + 1);\r\ntmp = t->tm_year - 100;\r\nbuf[FM3130_RTC_YEARS] = bin2bcd(tmp);\r\ndev_dbg(dev, "%s: %02x %02x %02x %02x %02x %02x %02x"\r\n"%02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n"write", buf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7],\r\nbuf[8], buf[9], buf[0xa], buf[0xb],\r\nbuf[0xc], buf[0xd], buf[0xe]);\r\nfm3130_rtc_mode(dev, FM3130_MODE_WRITE);\r\nfor (i = 0; i < FM3130_CLOCK_REGS; i++) {\r\ni2c_smbus_write_byte_data(fm3130->client,\r\nFM3130_RTC_SECONDS + i,\r\nfm3130->regs[FM3130_RTC_SECONDS + i]);\r\n}\r\nfm3130_rtc_mode(dev, FM3130_MODE_NORMAL);\r\nif (!fm3130->data_valid)\r\nfm3130->data_valid = 1;\r\nreturn 0;\r\n}\r\nstatic int fm3130_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct fm3130 *fm3130 = dev_get_drvdata(dev);\r\nint tmp;\r\nstruct rtc_time *tm = &alrm->time;\r\nif (!fm3130->alarm_valid) {\r\nreturn -EIO;\r\n}\r\ntmp = i2c_transfer(to_i2c_adapter(fm3130->client->dev.parent),\r\n&fm3130->msg[2], 2);\r\nif (tmp != 2) {\r\ndev_err(dev, "%s error %d\n", "read", tmp);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "alarm read %02x %02x %02x %02x %02x\n",\r\nfm3130->regs[FM3130_ALARM_SECONDS],\r\nfm3130->regs[FM3130_ALARM_MINUTES],\r\nfm3130->regs[FM3130_ALARM_HOURS],\r\nfm3130->regs[FM3130_ALARM_DATE],\r\nfm3130->regs[FM3130_ALARM_MONTHS]);\r\ntm->tm_sec = bcd2bin(fm3130->regs[FM3130_ALARM_SECONDS] & 0x7F);\r\ntm->tm_min = bcd2bin(fm3130->regs[FM3130_ALARM_MINUTES] & 0x7F);\r\ntm->tm_hour = bcd2bin(fm3130->regs[FM3130_ALARM_HOURS] & 0x3F);\r\ntm->tm_mday = bcd2bin(fm3130->regs[FM3130_ALARM_DATE] & 0x3F);\r\ntm->tm_mon = bcd2bin(fm3130->regs[FM3130_ALARM_MONTHS] & 0x1F);\r\nif (tm->tm_mon > 0)\r\ntm->tm_mon -= 1;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"read alarm", tm->tm_sec, tm->tm_min,\r\ntm->tm_hour, tm->tm_mday,\r\ntm->tm_mon, tm->tm_year, tm->tm_wday);\r\nfm3130->regs[FM3130_RTC_CONTROL] =\r\ni2c_smbus_read_byte_data(fm3130->client, FM3130_RTC_CONTROL);\r\nif ((fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_AEN) &&\r\n(~fm3130->regs[FM3130_RTC_CONTROL] &\r\nFM3130_RTC_CONTROL_BIT_CAL)) {\r\nalrm->enabled = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fm3130_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct fm3130 *fm3130 = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nint i;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"write alarm", tm->tm_sec, tm->tm_min,\r\ntm->tm_hour, tm->tm_mday,\r\ntm->tm_mon, tm->tm_year, tm->tm_wday);\r\nfm3130->regs[FM3130_ALARM_SECONDS] =\r\n(tm->tm_sec != -1) ? bin2bcd(tm->tm_sec) : 0x80;\r\nfm3130->regs[FM3130_ALARM_MINUTES] =\r\n(tm->tm_min != -1) ? bin2bcd(tm->tm_min) : 0x80;\r\nfm3130->regs[FM3130_ALARM_HOURS] =\r\n(tm->tm_hour != -1) ? bin2bcd(tm->tm_hour) : 0x80;\r\nfm3130->regs[FM3130_ALARM_DATE] =\r\n(tm->tm_mday != -1) ? bin2bcd(tm->tm_mday) : 0x80;\r\nfm3130->regs[FM3130_ALARM_MONTHS] =\r\n(tm->tm_mon != -1) ? bin2bcd(tm->tm_mon + 1) : 0x80;\r\ndev_dbg(dev, "alarm write %02x %02x %02x %02x %02x\n",\r\nfm3130->regs[FM3130_ALARM_SECONDS],\r\nfm3130->regs[FM3130_ALARM_MINUTES],\r\nfm3130->regs[FM3130_ALARM_HOURS],\r\nfm3130->regs[FM3130_ALARM_DATE],\r\nfm3130->regs[FM3130_ALARM_MONTHS]);\r\nfor (i = 0; i < FM3130_ALARM_REGS; i++) {\r\ni2c_smbus_write_byte_data(fm3130->client,\r\nFM3130_ALARM_SECONDS + i,\r\nfm3130->regs[FM3130_ALARM_SECONDS + i]);\r\n}\r\nfm3130->regs[FM3130_RTC_CONTROL] =\r\ni2c_smbus_read_byte_data(fm3130->client, FM3130_RTC_CONTROL);\r\nif (alrm->enabled) {\r\ni2c_smbus_write_byte_data(fm3130->client, FM3130_RTC_CONTROL,\r\n(fm3130->regs[FM3130_RTC_CONTROL] &\r\n~(FM3130_RTC_CONTROL_BIT_CAL)) |\r\nFM3130_RTC_CONTROL_BIT_AEN);\r\n} else {\r\ni2c_smbus_write_byte_data(fm3130->client, FM3130_RTC_CONTROL,\r\nfm3130->regs[FM3130_RTC_CONTROL] &\r\n~(FM3130_RTC_CONTROL_BIT_CAL) &\r\n~(FM3130_RTC_CONTROL_BIT_AEN));\r\n}\r\nif (!fm3130->alarm_valid)\r\nfm3130->alarm_valid = 1;\r\nreturn 0;\r\n}\r\nstatic int fm3130_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct fm3130 *fm3130 = dev_get_drvdata(dev);\r\nint ret = 0;\r\nfm3130->regs[FM3130_RTC_CONTROL] =\r\ni2c_smbus_read_byte_data(fm3130->client, FM3130_RTC_CONTROL);\r\ndev_dbg(dev, "alarm_irq_enable: enable=%d, FM3130_RTC_CONTROL=%02x\n",\r\nenabled, fm3130->regs[FM3130_RTC_CONTROL]);\r\nswitch (enabled) {\r\ncase 0:\r\nret = i2c_smbus_write_byte_data(fm3130->client,\r\nFM3130_RTC_CONTROL, fm3130->regs[FM3130_RTC_CONTROL] &\r\n~(FM3130_RTC_CONTROL_BIT_CAL) &\r\n~(FM3130_RTC_CONTROL_BIT_AEN));\r\nbreak;\r\ncase 1:\r\nret = i2c_smbus_write_byte_data(fm3130->client,\r\nFM3130_RTC_CONTROL, (fm3130->regs[FM3130_RTC_CONTROL] &\r\n~(FM3130_RTC_CONTROL_BIT_CAL)) |\r\nFM3130_RTC_CONTROL_BIT_AEN);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit fm3130_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct fm3130 *fm3130;\r\nint err = -ENODEV;\r\nint tmp;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nif (!i2c_check_functionality(adapter,\r\nI2C_FUNC_I2C | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -EIO;\r\nfm3130 = kzalloc(sizeof(struct fm3130), GFP_KERNEL);\r\nif (!fm3130)\r\nreturn -ENOMEM;\r\nfm3130->client = client;\r\ni2c_set_clientdata(client, fm3130);\r\nfm3130->reg_addr_time = FM3130_RTC_SECONDS;\r\nfm3130->reg_addr_alarm = FM3130_ALARM_SECONDS;\r\nfm3130->msg[0].addr = client->addr;\r\nfm3130->msg[0].flags = 0;\r\nfm3130->msg[0].len = 1;\r\nfm3130->msg[0].buf = &fm3130->reg_addr_time;\r\nfm3130->msg[1].addr = client->addr;\r\nfm3130->msg[1].flags = I2C_M_RD;\r\nfm3130->msg[1].len = FM3130_CLOCK_REGS;\r\nfm3130->msg[1].buf = &fm3130->regs[FM3130_RTC_SECONDS];\r\nfm3130->msg[2].addr = client->addr;\r\nfm3130->msg[2].flags = 0;\r\nfm3130->msg[2].len = 1;\r\nfm3130->msg[2].buf = &fm3130->reg_addr_alarm;\r\nfm3130->msg[3].addr = client->addr;\r\nfm3130->msg[3].flags = I2C_M_RD;\r\nfm3130->msg[3].len = FM3130_ALARM_REGS;\r\nfm3130->msg[3].buf = &fm3130->regs[FM3130_ALARM_SECONDS];\r\nfm3130->alarm_valid = 0;\r\nfm3130->data_valid = 0;\r\ntmp = i2c_transfer(adapter, fm3130->msg, 4);\r\nif (tmp != 4) {\r\npr_debug("read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\nfm3130->regs[FM3130_RTC_CONTROL] =\r\ni2c_smbus_read_byte_data(client, FM3130_RTC_CONTROL);\r\nfm3130->regs[FM3130_CAL_CONTROL] =\r\ni2c_smbus_read_byte_data(client, FM3130_CAL_CONTROL);\r\nif (fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_CAL) {\r\ni2c_smbus_write_byte_data(client, FM3130_RTC_CONTROL,\r\nfm3130->regs[FM3130_RTC_CONTROL] &\r\n~(FM3130_RTC_CONTROL_BIT_CAL));\r\ndev_warn(&client->dev, "Disabling calibration mode!\n");\r\n}\r\nif (fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_WRITE ||\r\nfm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_READ) {\r\ni2c_smbus_write_byte_data(client, FM3130_RTC_CONTROL,\r\nfm3130->regs[FM3130_RTC_CONTROL] &\r\n~(FM3130_RTC_CONTROL_BIT_READ |\r\nFM3130_RTC_CONTROL_BIT_WRITE));\r\ndev_warn(&client->dev, "Disabling READ or WRITE mode!\n");\r\n}\r\nif (fm3130->regs[FM3130_CAL_CONTROL] & FM3130_CAL_CONTROL_BIT_nOSCEN)\r\ni2c_smbus_write_byte_data(client, FM3130_CAL_CONTROL,\r\nfm3130->regs[FM3130_CAL_CONTROL] &\r\n~(FM3130_CAL_CONTROL_BIT_nOSCEN));\r\nif (fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_LB) {\r\ni2c_smbus_write_byte_data(client, FM3130_RTC_CONTROL,\r\nfm3130->regs[FM3130_RTC_CONTROL] &\r\n~(FM3130_RTC_CONTROL_BIT_LB));\r\ndev_warn(&client->dev, "Low battery!\n");\r\n}\r\nif (fm3130->regs[FM3130_RTC_CONTROL] & FM3130_RTC_CONTROL_BIT_POR) {\r\ni2c_smbus_write_byte_data(client, FM3130_RTC_CONTROL,\r\nfm3130->regs[FM3130_RTC_CONTROL] &\r\n~FM3130_RTC_CONTROL_BIT_POR);\r\ndev_dbg(&client->dev, "POR bit is set\n");\r\n}\r\ni2c_smbus_write_byte_data(client, FM3130_ALARM_WP_CONTROL, 0x80);\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_SECONDS] & 0x7f);\r\nif (tmp > 59)\r\ngoto bad_alarm;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_MINUTES] & 0x7f);\r\nif (tmp > 59)\r\ngoto bad_alarm;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_HOURS] & 0x3f);\r\nif (tmp > 23)\r\ngoto bad_alarm;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_DATE] & 0x3f);\r\nif (tmp == 0 || tmp > 31)\r\ngoto bad_alarm;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_MONTHS] & 0x1f);\r\nif (tmp == 0 || tmp > 12)\r\ngoto bad_alarm;\r\nfm3130->alarm_valid = 1;\r\nbad_alarm:\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_SECONDS] & 0x7f);\r\nif (tmp > 59)\r\ngoto bad_clock;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_MINUTES] & 0x7f);\r\nif (tmp > 59)\r\ngoto bad_clock;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_HOURS] & 0x3f);\r\nif (tmp > 23)\r\ngoto bad_clock;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_DAY] & 0x7);\r\nif (tmp == 0 || tmp > 7)\r\ngoto bad_clock;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_DATE] & 0x3f);\r\nif (tmp == 0 || tmp > 31)\r\ngoto bad_clock;\r\ntmp = bcd2bin(fm3130->regs[FM3130_RTC_MONTHS] & 0x1f);\r\nif (tmp == 0 || tmp > 12)\r\ngoto bad_clock;\r\nfm3130->data_valid = 1;\r\nbad_clock:\r\nif (!fm3130->data_valid || !fm3130->alarm_valid)\r\ndev_dbg(&client->dev,\r\n"%s: %02x %02x %02x %02x %02x %02x %02x %02x"\r\n"%02x %02x %02x %02x %02x %02x %02x\n",\r\n"bogus registers",\r\nfm3130->regs[0], fm3130->regs[1],\r\nfm3130->regs[2], fm3130->regs[3],\r\nfm3130->regs[4], fm3130->regs[5],\r\nfm3130->regs[6], fm3130->regs[7],\r\nfm3130->regs[8], fm3130->regs[9],\r\nfm3130->regs[0xa], fm3130->regs[0xb],\r\nfm3130->regs[0xc], fm3130->regs[0xd],\r\nfm3130->regs[0xe]);\r\nfm3130->rtc = rtc_device_register(client->name, &client->dev,\r\n&fm3130_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(fm3130->rtc)) {\r\nerr = PTR_ERR(fm3130->rtc);\r\ndev_err(&client->dev,\r\n"unable to register the class device\n");\r\ngoto exit_free;\r\n}\r\nreturn 0;\r\nexit_free:\r\nkfree(fm3130);\r\nreturn err;\r\n}\r\nstatic int __devexit fm3130_remove(struct i2c_client *client)\r\n{\r\nstruct fm3130 *fm3130 = i2c_get_clientdata(client);\r\nrtc_device_unregister(fm3130->rtc);\r\nkfree(fm3130);\r\nreturn 0;\r\n}\r\nstatic int __init fm3130_init(void)\r\n{\r\nreturn i2c_add_driver(&fm3130_driver);\r\n}\r\nstatic void __exit fm3130_exit(void)\r\n{\r\ni2c_del_driver(&fm3130_driver);\r\n}
