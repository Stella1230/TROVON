static inline u8 sis630_read(u8 reg)\r\n{\r\nreturn inb(acpi_base + reg);\r\n}\r\nstatic inline void sis630_write(u8 reg, u8 data)\r\n{\r\noutb(data, acpi_base + reg);\r\n}\r\nstatic int sis630_transaction_start(struct i2c_adapter *adap, int size, u8 *oldclock)\r\n{\r\nint temp;\r\nif ((temp = sis630_read(SMB_CNT) & 0x03) != 0x00) {\r\ndev_dbg(&adap->dev, "SMBus busy (%02x).Resetting...\n",temp);\r\nsis630_write(SMBHOST_CNT, 0x20);\r\nif ((temp = sis630_read(SMB_CNT) & 0x03) != 0x00) {\r\ndev_dbg(&adap->dev, "Failed! (%02x)\n", temp);\r\nreturn -EBUSY;\r\n} else {\r\ndev_dbg(&adap->dev, "Successful!\n");\r\n}\r\n}\r\n*oldclock = sis630_read(SMB_CNT);\r\ndev_dbg(&adap->dev, "saved clock 0x%02x\n", *oldclock);\r\nif (high_clock)\r\nsis630_write(SMB_CNT, 0x20);\r\nelse\r\nsis630_write(SMB_CNT, (*oldclock & ~0x40));\r\ntemp = sis630_read(SMB_STS);\r\nsis630_write(SMB_STS, temp & 0x1e);\r\nsis630_write(SMBHOST_CNT,0x10 | (size & 0x07));\r\nreturn 0;\r\n}\r\nstatic int sis630_transaction_wait(struct i2c_adapter *adap, int size)\r\n{\r\nint temp, result = 0, timeout = 0;\r\ndo {\r\nmsleep(1);\r\ntemp = sis630_read(SMB_STS);\r\nif (size == SIS630_BLOCK_DATA && (temp & 0x10))\r\nbreak;\r\n} while (!(temp & 0x0e) && (timeout++ < MAX_TIMEOUT));\r\nif (timeout > MAX_TIMEOUT) {\r\ndev_dbg(&adap->dev, "SMBus Timeout!\n");\r\nresult = -ETIMEDOUT;\r\n}\r\nif (temp & 0x02) {\r\ndev_dbg(&adap->dev, "Error: Failed bus transaction\n");\r\nresult = -ENXIO;\r\n}\r\nif (temp & 0x04) {\r\ndev_err(&adap->dev, "Bus collision!\n");\r\nresult = -EIO;\r\n}\r\nreturn result;\r\n}\r\nstatic void sis630_transaction_end(struct i2c_adapter *adap, u8 oldclock)\r\n{\r\nint temp = 0;\r\nsis630_write(SMB_STS, temp);\r\ndev_dbg(&adap->dev, "SMB_CNT before clock restore 0x%02x\n", sis630_read(SMB_CNT));\r\nif (high_clock && !(oldclock & 0x20))\r\nsis630_write(SMB_CNT,(sis630_read(SMB_CNT) & ~0x20));\r\ndev_dbg(&adap->dev, "SMB_CNT after clock restore 0x%02x\n", sis630_read(SMB_CNT));\r\n}\r\nstatic int sis630_transaction(struct i2c_adapter *adap, int size)\r\n{\r\nint result = 0;\r\nu8 oldclock = 0;\r\nresult = sis630_transaction_start(adap, size, &oldclock);\r\nif (!result) {\r\nresult = sis630_transaction_wait(adap, size);\r\nsis630_transaction_end(adap, oldclock);\r\n}\r\nreturn result;\r\n}\r\nstatic int sis630_block_data(struct i2c_adapter *adap, union i2c_smbus_data *data, int read_write)\r\n{\r\nint i, len = 0, rc = 0;\r\nu8 oldclock = 0;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\nif (len < 0)\r\nlen = 0;\r\nelse if (len > 32)\r\nlen = 32;\r\nsis630_write(SMB_COUNT, len);\r\nfor (i=1; i <= len; i++) {\r\ndev_dbg(&adap->dev, "set data 0x%02x\n", data->block[i]);\r\nsis630_write(SMB_BYTE+(i-1)%8, data->block[i]);\r\nif (i==8 || (len<8 && i==len)) {\r\ndev_dbg(&adap->dev, "start trans len=%d i=%d\n",len ,i);\r\nrc = sis630_transaction_start(adap,\r\nSIS630_BLOCK_DATA, &oldclock);\r\nif (rc)\r\nreturn rc;\r\n}\r\nelse if ((i-1)%8 == 7 || i==len) {\r\ndev_dbg(&adap->dev, "trans_wait len=%d i=%d\n",len,i);\r\nif (i>8) {\r\ndev_dbg(&adap->dev, "clear smbary_sts len=%d i=%d\n",len,i);\r\nsis630_write(SMB_STS,0x10);\r\n}\r\nrc = sis630_transaction_wait(adap,\r\nSIS630_BLOCK_DATA);\r\nif (rc) {\r\ndev_dbg(&adap->dev, "trans_wait failed\n");\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\ndata->block[0] = len = 0;\r\nrc = sis630_transaction_start(adap,\r\nSIS630_BLOCK_DATA, &oldclock);\r\nif (rc)\r\nreturn rc;\r\ndo {\r\nrc = sis630_transaction_wait(adap, SIS630_BLOCK_DATA);\r\nif (rc) {\r\ndev_dbg(&adap->dev, "trans_wait failed\n");\r\nbreak;\r\n}\r\nif (len == 0)\r\ndata->block[0] = sis630_read(SMB_COUNT);\r\nif (data->block[0] > 32)\r\ndata->block[0] = 32;\r\ndev_dbg(&adap->dev, "block data read len=0x%x\n", data->block[0]);\r\nfor (i=0; i < 8 && len < data->block[0]; i++,len++) {\r\ndev_dbg(&adap->dev, "read i=%d len=%d\n", i, len);\r\ndata->block[len+1] = sis630_read(SMB_BYTE+i);\r\n}\r\ndev_dbg(&adap->dev, "clear smbary_sts len=%d i=%d\n",len,i);\r\nsis630_write(SMB_STS,0x10);\r\n} while(len < data->block[0]);\r\n}\r\nsis630_transaction_end(adap, oldclock);\r\nreturn rc;\r\n}\r\nstatic s32 sis630_access(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data *data)\r\n{\r\nint status;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nsis630_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\r\nsize = SIS630_QUICK;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nsis630_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\r\nif (read_write == I2C_SMBUS_WRITE)\r\nsis630_write(SMB_CMD, command);\r\nsize = SIS630_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nsis630_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\r\nsis630_write(SMB_CMD, command);\r\nif (read_write == I2C_SMBUS_WRITE)\r\nsis630_write(SMB_BYTE, data->byte);\r\nsize = SIS630_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\ncase I2C_SMBUS_WORD_DATA:\r\nsis630_write(SMB_ADDR,((addr & 0x7f) << 1) | (read_write & 0x01));\r\nsis630_write(SMB_CMD, command);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nsis630_write(SMB_BYTE, data->word & 0xff);\r\nsis630_write(SMB_BYTE + 1,(data->word & 0xff00) >> 8);\r\n}\r\nsize = (size == I2C_SMBUS_PROC_CALL ? SIS630_PCALL : SIS630_WORD_DATA);\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nsis630_write(SMB_ADDR,((addr & 0x7f) << 1) | (read_write & 0x01));\r\nsis630_write(SMB_CMD, command);\r\nsize = SIS630_BLOCK_DATA;\r\nreturn sis630_block_data(adap, data, read_write);\r\ndefault:\r\ndev_warn(&adap->dev, "Unsupported transaction %d\n",\r\nsize);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatus = sis630_transaction(adap, size);\r\nif (status)\r\nreturn status;\r\nif ((size != SIS630_PCALL) &&\r\n((read_write == I2C_SMBUS_WRITE) || (size == SIS630_QUICK))) {\r\nreturn 0;\r\n}\r\nswitch(size) {\r\ncase SIS630_BYTE:\r\ncase SIS630_BYTE_DATA:\r\ndata->byte = sis630_read(SMB_BYTE);\r\nbreak;\r\ncase SIS630_PCALL:\r\ncase SIS630_WORD_DATA:\r\ndata->word = sis630_read(SMB_BYTE) + (sis630_read(SMB_BYTE + 1) << 8);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 sis630_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_PROC_CALL |\r\nI2C_FUNC_SMBUS_BLOCK_DATA;\r\n}\r\nstatic int __devinit sis630_setup(struct pci_dev *sis630_dev)\r\n{\r\nunsigned char b;\r\nstruct pci_dev *dummy = NULL;\r\nint retval = -ENODEV, i;\r\nfor (i=0; supported[i] > 0 ; i++) {\r\nif ((dummy = pci_get_device(PCI_VENDOR_ID_SI, supported[i], dummy)))\r\nbreak;\r\n}\r\nif (dummy) {\r\npci_dev_put(dummy);\r\n}\r\nelse if (force) {\r\ndev_err(&sis630_dev->dev, "WARNING: Can't detect SIS630 compatible device, but "\r\n"loading because of force option enabled\n");\r\n}\r\nelse {\r\nreturn -ENODEV;\r\n}\r\nif (pci_read_config_byte(sis630_dev, SIS630_BIOS_CTL_REG,&b)) {\r\ndev_err(&sis630_dev->dev, "Error: Can't read bios ctl reg\n");\r\ngoto exit;\r\n}\r\nif (!(b & 0x80) &&\r\npci_write_config_byte(sis630_dev, SIS630_BIOS_CTL_REG, b | 0x80)) {\r\ndev_err(&sis630_dev->dev, "Error: Can't enable ACPI\n");\r\ngoto exit;\r\n}\r\nif (pci_read_config_word(sis630_dev,SIS630_ACPI_BASE_REG,&acpi_base)) {\r\ndev_err(&sis630_dev->dev, "Error: Can't determine ACPI base address\n");\r\ngoto exit;\r\n}\r\ndev_dbg(&sis630_dev->dev, "ACPI base at 0x%04x\n", acpi_base);\r\nretval = acpi_check_region(acpi_base + SMB_STS, SIS630_SMB_IOREGION,\r\nsis630_driver.name);\r\nif (retval)\r\ngoto exit;\r\nif (!request_region(acpi_base + SMB_STS, SIS630_SMB_IOREGION,\r\nsis630_driver.name)) {\r\ndev_err(&sis630_dev->dev, "SMBus registers 0x%04x-0x%04x already "\r\n"in use!\n", acpi_base + SMB_STS, acpi_base + SMB_SAA);\r\ngoto exit;\r\n}\r\nretval = 0;\r\nexit:\r\nif (retval)\r\nacpi_base = 0;\r\nreturn retval;\r\n}\r\nstatic int __devinit sis630_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nif (sis630_setup(dev)) {\r\ndev_err(&dev->dev, "SIS630 comp. bus not detected, module not inserted.\n");\r\nreturn -ENODEV;\r\n}\r\nsis630_adapter.dev.parent = &dev->dev;\r\nsnprintf(sis630_adapter.name, sizeof(sis630_adapter.name),\r\n"SMBus SIS630 adapter at %04x", acpi_base + SMB_STS);\r\nreturn i2c_add_adapter(&sis630_adapter);\r\n}\r\nstatic void __devexit sis630_remove(struct pci_dev *dev)\r\n{\r\nif (acpi_base) {\r\ni2c_del_adapter(&sis630_adapter);\r\nrelease_region(acpi_base + SMB_STS, SIS630_SMB_IOREGION);\r\nacpi_base = 0;\r\n}\r\n}\r\nstatic int __init i2c_sis630_init(void)\r\n{\r\nreturn pci_register_driver(&sis630_driver);\r\n}\r\nstatic void __exit i2c_sis630_exit(void)\r\n{\r\npci_unregister_driver(&sis630_driver);\r\n}
