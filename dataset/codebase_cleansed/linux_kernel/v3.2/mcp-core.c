static int mcp_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nreturn 1;\r\n}\r\nstatic int mcp_bus_probe(struct device *dev)\r\n{\r\nstruct mcp *mcp = to_mcp(dev);\r\nstruct mcp_driver *drv = to_mcp_driver(dev->driver);\r\nreturn drv->probe(mcp);\r\n}\r\nstatic int mcp_bus_remove(struct device *dev)\r\n{\r\nstruct mcp *mcp = to_mcp(dev);\r\nstruct mcp_driver *drv = to_mcp_driver(dev->driver);\r\ndrv->remove(mcp);\r\nreturn 0;\r\n}\r\nstatic int mcp_bus_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct mcp *mcp = to_mcp(dev);\r\nint ret = 0;\r\nif (dev->driver) {\r\nstruct mcp_driver *drv = to_mcp_driver(dev->driver);\r\nret = drv->suspend(mcp, state);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mcp_bus_resume(struct device *dev)\r\n{\r\nstruct mcp *mcp = to_mcp(dev);\r\nint ret = 0;\r\nif (dev->driver) {\r\nstruct mcp_driver *drv = to_mcp_driver(dev->driver);\r\nret = drv->resume(mcp);\r\n}\r\nreturn ret;\r\n}\r\nvoid mcp_set_telecom_divisor(struct mcp *mcp, unsigned int div)\r\n{\r\nspin_lock_irq(&mcp->lock);\r\nmcp->ops->set_telecom_divisor(mcp, div);\r\nspin_unlock_irq(&mcp->lock);\r\n}\r\nvoid mcp_set_audio_divisor(struct mcp *mcp, unsigned int div)\r\n{\r\nspin_lock_irq(&mcp->lock);\r\nmcp->ops->set_audio_divisor(mcp, div);\r\nspin_unlock_irq(&mcp->lock);\r\n}\r\nvoid mcp_reg_write(struct mcp *mcp, unsigned int reg, unsigned int val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mcp->lock, flags);\r\nmcp->ops->reg_write(mcp, reg, val);\r\nspin_unlock_irqrestore(&mcp->lock, flags);\r\n}\r\nunsigned int mcp_reg_read(struct mcp *mcp, unsigned int reg)\r\n{\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&mcp->lock, flags);\r\nval = mcp->ops->reg_read(mcp, reg);\r\nspin_unlock_irqrestore(&mcp->lock, flags);\r\nreturn val;\r\n}\r\nvoid mcp_enable(struct mcp *mcp)\r\n{\r\nspin_lock_irq(&mcp->lock);\r\nif (mcp->use_count++ == 0)\r\nmcp->ops->enable(mcp);\r\nspin_unlock_irq(&mcp->lock);\r\n}\r\nvoid mcp_disable(struct mcp *mcp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mcp->lock, flags);\r\nif (--mcp->use_count == 0)\r\nmcp->ops->disable(mcp);\r\nspin_unlock_irqrestore(&mcp->lock, flags);\r\n}\r\nstatic void mcp_release(struct device *dev)\r\n{\r\nstruct mcp *mcp = container_of(dev, struct mcp, attached_device);\r\nkfree(mcp);\r\n}\r\nstruct mcp *mcp_host_alloc(struct device *parent, size_t size)\r\n{\r\nstruct mcp *mcp;\r\nmcp = kzalloc(sizeof(struct mcp) + size, GFP_KERNEL);\r\nif (mcp) {\r\nspin_lock_init(&mcp->lock);\r\nmcp->attached_device.parent = parent;\r\nmcp->attached_device.bus = &mcp_bus_type;\r\nmcp->attached_device.dma_mask = parent->dma_mask;\r\nmcp->attached_device.release = mcp_release;\r\n}\r\nreturn mcp;\r\n}\r\nint mcp_host_register(struct mcp *mcp)\r\n{\r\ndev_set_name(&mcp->attached_device, "mcp0");\r\nreturn device_register(&mcp->attached_device);\r\n}\r\nvoid mcp_host_unregister(struct mcp *mcp)\r\n{\r\ndevice_unregister(&mcp->attached_device);\r\n}\r\nint mcp_driver_register(struct mcp_driver *mcpdrv)\r\n{\r\nmcpdrv->drv.bus = &mcp_bus_type;\r\nreturn driver_register(&mcpdrv->drv);\r\n}\r\nvoid mcp_driver_unregister(struct mcp_driver *mcpdrv)\r\n{\r\ndriver_unregister(&mcpdrv->drv);\r\n}\r\nstatic int __init mcp_init(void)\r\n{\r\nreturn bus_register(&mcp_bus_type);\r\n}\r\nstatic void __exit mcp_exit(void)\r\n{\r\nbus_unregister(&mcp_bus_type);\r\n}
