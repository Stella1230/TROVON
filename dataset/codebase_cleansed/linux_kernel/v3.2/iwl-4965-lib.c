void iwl4965_check_abort_status(struct iwl_priv *priv,\r\nu8 frame_count, u32 status)\r\n{\r\nif (frame_count == 1 && status == TX_STATUS_FAIL_RFKILL_FLUSH) {\r\nIWL_ERR(priv, "Tx flush command to flush out all frames\n");\r\nif (!test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nqueue_work(priv->workqueue, &priv->tx_flush);\r\n}\r\n}\r\nvoid iwl4965_rx_queue_reset(struct iwl_priv *priv, struct iwl_rx_queue *rxq)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nINIT_LIST_HEAD(&rxq->rx_free);\r\nINIT_LIST_HEAD(&rxq->rx_used);\r\nfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\r\nif (rxq->pool[i].page != NULL) {\r\npci_unmap_page(priv->pci_dev, rxq->pool[i].page_dma,\r\nPAGE_SIZE << priv->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__iwl_legacy_free_pages(priv, rxq->pool[i].page);\r\nrxq->pool[i].page = NULL;\r\n}\r\nlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\r\n}\r\nfor (i = 0; i < RX_QUEUE_SIZE; i++)\r\nrxq->queue[i] = NULL;\r\nrxq->read = rxq->write = 0;\r\nrxq->write_actual = 0;\r\nrxq->free_count = 0;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n}\r\nint iwl4965_rx_init(struct iwl_priv *priv, struct iwl_rx_queue *rxq)\r\n{\r\nu32 rb_size;\r\nconst u32 rfdnlog = RX_QUEUE_SIZE_LOG;\r\nu32 rb_timeout = 0;\r\nif (priv->cfg->mod_params->amsdu_size_8K)\r\nrb_size = FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K;\r\nelse\r\nrb_size = FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K;\r\niwl_legacy_write_direct32(priv, FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);\r\niwl_legacy_write_direct32(priv, FH_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);\r\niwl_legacy_write_direct32(priv, FH_RSCSR_CHNL0_RBDCB_BASE_REG,\r\n(u32)(rxq->bd_dma >> 8));\r\niwl_legacy_write_direct32(priv, FH_RSCSR_CHNL0_STTS_WPTR_REG,\r\nrxq->rb_stts_dma >> 4);\r\niwl_legacy_write_direct32(priv, FH_MEM_RCSR_CHNL0_CONFIG_REG,\r\nFH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL |\r\nFH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL |\r\nFH_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK |\r\nrb_size|\r\n(rb_timeout << FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS)|\r\n(rfdnlog << FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS));\r\niwl_write8(priv, CSR_INT_COALESCING, IWL_HOST_INT_TIMEOUT_DEF);\r\nreturn 0;\r\n}\r\nstatic void iwl4965_set_pwr_vmain(struct iwl_priv *priv)\r\n{\r\niwl_legacy_set_bits_mask_prph(priv, APMG_PS_CTRL_REG,\r\nAPMG_PS_CTRL_VAL_PWR_SRC_VMAIN,\r\n~APMG_PS_CTRL_MSK_PWR_SRC);\r\n}\r\nint iwl4965_hw_nic_init(struct iwl_priv *priv)\r\n{\r\nunsigned long flags;\r\nstruct iwl_rx_queue *rxq = &priv->rxq;\r\nint ret;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->cfg->ops->lib->apm_ops.init(priv);\r\niwl_write8(priv, CSR_INT_COALESCING, IWL_HOST_INT_CALIB_TIMEOUT_DEF);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\niwl4965_set_pwr_vmain(priv);\r\npriv->cfg->ops->lib->apm_ops.config(priv);\r\nif (!rxq->bd) {\r\nret = iwl_legacy_rx_queue_alloc(priv);\r\nif (ret) {\r\nIWL_ERR(priv, "Unable to initialize Rx queue\n");\r\nreturn -ENOMEM;\r\n}\r\n} else\r\niwl4965_rx_queue_reset(priv, rxq);\r\niwl4965_rx_replenish(priv);\r\niwl4965_rx_init(priv, rxq);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrxq->need_update = 1;\r\niwl_legacy_rx_queue_update_write_ptr(priv, rxq);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (!priv->txq) {\r\nret = iwl4965_txq_ctx_alloc(priv);\r\nif (ret)\r\nreturn ret;\r\n} else\r\niwl4965_txq_ctx_reset(priv);\r\nset_bit(STATUS_INIT, &priv->status);\r\nreturn 0;\r\n}\r\nstatic inline __le32 iwl4965_dma_addr2rbd_ptr(struct iwl_priv *priv,\r\ndma_addr_t dma_addr)\r\n{\r\nreturn cpu_to_le32((u32)(dma_addr >> 8));\r\n}\r\nvoid iwl4965_rx_queue_restock(struct iwl_priv *priv)\r\n{\r\nstruct iwl_rx_queue *rxq = &priv->rxq;\r\nstruct list_head *element;\r\nstruct iwl_rx_mem_buffer *rxb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nwhile ((iwl_legacy_rx_queue_space(rxq) > 0) && (rxq->free_count)) {\r\nrxb = rxq->queue[rxq->write];\r\nBUG_ON(rxb && rxb->page);\r\nelement = rxq->rx_free.next;\r\nrxb = list_entry(element, struct iwl_rx_mem_buffer, list);\r\nlist_del(element);\r\nrxq->bd[rxq->write] = iwl4965_dma_addr2rbd_ptr(priv,\r\nrxb->page_dma);\r\nrxq->queue[rxq->write] = rxb;\r\nrxq->write = (rxq->write + 1) & RX_QUEUE_MASK;\r\nrxq->free_count--;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nif (rxq->free_count <= RX_LOW_WATERMARK)\r\nqueue_work(priv->workqueue, &priv->rx_replenish);\r\nif (rxq->write_actual != (rxq->write & ~0x7)) {\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nrxq->need_update = 1;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\niwl_legacy_rx_queue_update_write_ptr(priv, rxq);\r\n}\r\n}\r\nstatic void iwl4965_rx_allocate(struct iwl_priv *priv, gfp_t priority)\r\n{\r\nstruct iwl_rx_queue *rxq = &priv->rxq;\r\nstruct list_head *element;\r\nstruct iwl_rx_mem_buffer *rxb;\r\nstruct page *page;\r\nunsigned long flags;\r\ngfp_t gfp_mask = priority;\r\nwhile (1) {\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (list_empty(&rxq->rx_used)) {\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nif (rxq->free_count > RX_LOW_WATERMARK)\r\ngfp_mask |= __GFP_NOWARN;\r\nif (priv->hw_params.rx_page_order > 0)\r\ngfp_mask |= __GFP_COMP;\r\npage = alloc_pages(gfp_mask, priv->hw_params.rx_page_order);\r\nif (!page) {\r\nif (net_ratelimit())\r\nIWL_DEBUG_INFO(priv, "alloc_pages failed, "\r\n"order: %d\n",\r\npriv->hw_params.rx_page_order);\r\nif ((rxq->free_count <= RX_LOW_WATERMARK) &&\r\nnet_ratelimit())\r\nIWL_CRIT(priv,\r\n"Failed to alloc_pages with %s. "\r\n"Only %u free buffers remaining.\n",\r\npriority == GFP_ATOMIC ?\r\n"GFP_ATOMIC" : "GFP_KERNEL",\r\nrxq->free_count);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (list_empty(&rxq->rx_used)) {\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n__free_pages(page, priv->hw_params.rx_page_order);\r\nreturn;\r\n}\r\nelement = rxq->rx_used.next;\r\nrxb = list_entry(element, struct iwl_rx_mem_buffer, list);\r\nlist_del(element);\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nBUG_ON(rxb->page);\r\nrxb->page = page;\r\nrxb->page_dma = pci_map_page(priv->pci_dev, page, 0,\r\nPAGE_SIZE << priv->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\nBUG_ON(rxb->page_dma & ~DMA_BIT_MASK(36));\r\nBUG_ON(rxb->page_dma & DMA_BIT_MASK(8));\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nlist_add_tail(&rxb->list, &rxq->rx_free);\r\nrxq->free_count++;\r\npriv->alloc_rxb_page++;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n}\r\n}\r\nvoid iwl4965_rx_replenish(struct iwl_priv *priv)\r\n{\r\nunsigned long flags;\r\niwl4965_rx_allocate(priv, GFP_KERNEL);\r\nspin_lock_irqsave(&priv->lock, flags);\r\niwl4965_rx_queue_restock(priv);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nvoid iwl4965_rx_replenish_now(struct iwl_priv *priv)\r\n{\r\niwl4965_rx_allocate(priv, GFP_ATOMIC);\r\niwl4965_rx_queue_restock(priv);\r\n}\r\nvoid iwl4965_rx_queue_free(struct iwl_priv *priv, struct iwl_rx_queue *rxq)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\r\nif (rxq->pool[i].page != NULL) {\r\npci_unmap_page(priv->pci_dev, rxq->pool[i].page_dma,\r\nPAGE_SIZE << priv->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__iwl_legacy_free_pages(priv, rxq->pool[i].page);\r\nrxq->pool[i].page = NULL;\r\n}\r\n}\r\ndma_free_coherent(&priv->pci_dev->dev, 4 * RX_QUEUE_SIZE, rxq->bd,\r\nrxq->bd_dma);\r\ndma_free_coherent(&priv->pci_dev->dev, sizeof(struct iwl_rb_status),\r\nrxq->rb_stts, rxq->rb_stts_dma);\r\nrxq->bd = NULL;\r\nrxq->rb_stts = NULL;\r\n}\r\nint iwl4965_rxq_stop(struct iwl_priv *priv)\r\n{\r\niwl_legacy_write_direct32(priv, FH_MEM_RCSR_CHNL0_CONFIG_REG, 0);\r\niwl_poll_direct_bit(priv, FH_MEM_RSSR_RX_STATUS_REG,\r\nFH_RSSR_CHNL0_RX_STATUS_CHNL_IDLE, 1000);\r\nreturn 0;\r\n}\r\nint iwl4965_hwrate_to_mac80211_idx(u32 rate_n_flags, enum ieee80211_band band)\r\n{\r\nint idx = 0;\r\nint band_offset = 0;\r\nif (rate_n_flags & RATE_MCS_HT_MSK) {\r\nidx = (rate_n_flags & 0xff);\r\nreturn idx;\r\n} else {\r\nif (band == IEEE80211_BAND_5GHZ)\r\nband_offset = IWL_FIRST_OFDM_RATE;\r\nfor (idx = band_offset; idx < IWL_RATE_COUNT_LEGACY; idx++)\r\nif (iwlegacy_rates[idx].plcp == (rate_n_flags & 0xFF))\r\nreturn idx - band_offset;\r\n}\r\nreturn -1;\r\n}\r\nstatic int iwl4965_calc_rssi(struct iwl_priv *priv,\r\nstruct iwl_rx_phy_res *rx_resp)\r\n{\r\nstruct iwl4965_rx_non_cfg_phy *ncphy =\r\n(struct iwl4965_rx_non_cfg_phy *)rx_resp->non_cfg_phy_buf;\r\nu32 agc = (le16_to_cpu(ncphy->agc_info) & IWL49_AGC_DB_MASK)\r\n>> IWL49_AGC_DB_POS;\r\nu32 valid_antennae =\r\n(le16_to_cpu(rx_resp->phy_flags) & IWL49_RX_PHY_FLAGS_ANTENNAE_MASK)\r\n>> IWL49_RX_PHY_FLAGS_ANTENNAE_OFFSET;\r\nu8 max_rssi = 0;\r\nu32 i;\r\nfor (i = 0; i < 3; i++)\r\nif (valid_antennae & (1 << i))\r\nmax_rssi = max(ncphy->rssi_info[i << 1], max_rssi);\r\nIWL_DEBUG_STATS(priv, "Rssi In A %d B %d C %d Max %d AGC dB %d\n",\r\nncphy->rssi_info[0], ncphy->rssi_info[2], ncphy->rssi_info[4],\r\nmax_rssi, agc);\r\nreturn max_rssi - agc - IWL4965_RSSI_OFFSET;\r\n}\r\nstatic u32 iwl4965_translate_rx_status(struct iwl_priv *priv, u32 decrypt_in)\r\n{\r\nu32 decrypt_out = 0;\r\nif ((decrypt_in & RX_RES_STATUS_STATION_FOUND) ==\r\nRX_RES_STATUS_STATION_FOUND)\r\ndecrypt_out |= (RX_RES_STATUS_STATION_FOUND |\r\nRX_RES_STATUS_NO_STATION_INFO_MISMATCH);\r\ndecrypt_out |= (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK);\r\nif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\r\nRX_RES_STATUS_SEC_TYPE_NONE)\r\nreturn decrypt_out;\r\nif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\r\nRX_RES_STATUS_SEC_TYPE_ERR)\r\nreturn decrypt_out;\r\nif ((decrypt_in & RX_MPDU_RES_STATUS_DEC_DONE_MSK) !=\r\nRX_MPDU_RES_STATUS_DEC_DONE_MSK)\r\nreturn decrypt_out;\r\nswitch (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) {\r\ncase RX_RES_STATUS_SEC_TYPE_CCMP:\r\nif (!(decrypt_in & RX_MPDU_RES_STATUS_MIC_OK))\r\ndecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\r\nelse\r\ndecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\r\nbreak;\r\ncase RX_RES_STATUS_SEC_TYPE_TKIP:\r\nif (!(decrypt_in & RX_MPDU_RES_STATUS_TTAK_OK)) {\r\ndecrypt_out |= RX_RES_STATUS_BAD_KEY_TTAK;\r\nbreak;\r\n}\r\ndefault:\r\nif (!(decrypt_in & RX_MPDU_RES_STATUS_ICV_OK))\r\ndecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\r\nelse\r\ndecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\r\nbreak;\r\n}\r\nIWL_DEBUG_RX(priv, "decrypt_in:0x%x decrypt_out = 0x%x\n",\r\ndecrypt_in, decrypt_out);\r\nreturn decrypt_out;\r\n}\r\nstatic void iwl4965_pass_packet_to_mac80211(struct iwl_priv *priv,\r\nstruct ieee80211_hdr *hdr,\r\nu16 len,\r\nu32 ampdu_status,\r\nstruct iwl_rx_mem_buffer *rxb,\r\nstruct ieee80211_rx_status *stats)\r\n{\r\nstruct sk_buff *skb;\r\n__le16 fc = hdr->frame_control;\r\nif (unlikely(!priv->is_open)) {\r\nIWL_DEBUG_DROP_LIMIT(priv,\r\n"Dropping packet while interface is not open.\n");\r\nreturn;\r\n}\r\nif (!priv->cfg->mod_params->sw_crypto &&\r\niwl_legacy_set_decrypted_flag(priv, hdr, ampdu_status, stats))\r\nreturn;\r\nskb = dev_alloc_skb(128);\r\nif (!skb) {\r\nIWL_ERR(priv, "dev_alloc_skb failed\n");\r\nreturn;\r\n}\r\nskb_add_rx_frag(skb, 0, rxb->page, (void *)hdr - rxb_addr(rxb), len);\r\niwl_legacy_update_stats(priv, false, fc, len);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));\r\nieee80211_rx(priv->hw, skb);\r\npriv->alloc_rxb_page--;\r\nrxb->page = NULL;\r\n}\r\nvoid iwl4965_rx_reply_rx(struct iwl_priv *priv,\r\nstruct iwl_rx_mem_buffer *rxb)\r\n{\r\nstruct ieee80211_hdr *header;\r\nstruct ieee80211_rx_status rx_status;\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct iwl_rx_phy_res *phy_res;\r\n__le32 rx_pkt_status;\r\nstruct iwl_rx_mpdu_res_start *amsdu;\r\nu32 len;\r\nu32 ampdu_status;\r\nu32 rate_n_flags;\r\nif (pkt->hdr.cmd == REPLY_RX) {\r\nphy_res = (struct iwl_rx_phy_res *)pkt->u.raw;\r\nheader = (struct ieee80211_hdr *)(pkt->u.raw + sizeof(*phy_res)\r\n+ phy_res->cfg_phy_cnt);\r\nlen = le16_to_cpu(phy_res->byte_count);\r\nrx_pkt_status = *(__le32 *)(pkt->u.raw + sizeof(*phy_res) +\r\nphy_res->cfg_phy_cnt + len);\r\nampdu_status = le32_to_cpu(rx_pkt_status);\r\n} else {\r\nif (!priv->_4965.last_phy_res_valid) {\r\nIWL_ERR(priv, "MPDU frame without cached PHY data\n");\r\nreturn;\r\n}\r\nphy_res = &priv->_4965.last_phy_res;\r\namsdu = (struct iwl_rx_mpdu_res_start *)pkt->u.raw;\r\nheader = (struct ieee80211_hdr *)(pkt->u.raw + sizeof(*amsdu));\r\nlen = le16_to_cpu(amsdu->byte_count);\r\nrx_pkt_status = *(__le32 *)(pkt->u.raw + sizeof(*amsdu) + len);\r\nampdu_status = iwl4965_translate_rx_status(priv,\r\nle32_to_cpu(rx_pkt_status));\r\n}\r\nif ((unlikely(phy_res->cfg_phy_cnt > 20))) {\r\nIWL_DEBUG_DROP(priv, "dsp size out of range [0,20]: %d/n",\r\nphy_res->cfg_phy_cnt);\r\nreturn;\r\n}\r\nif (!(rx_pkt_status & RX_RES_STATUS_NO_CRC32_ERROR) ||\r\n!(rx_pkt_status & RX_RES_STATUS_NO_RXE_OVERFLOW)) {\r\nIWL_DEBUG_RX(priv, "Bad CRC or FIFO: 0x%08X.\n",\r\nle32_to_cpu(rx_pkt_status));\r\nreturn;\r\n}\r\nrate_n_flags = le32_to_cpu(phy_res->rate_n_flags);\r\nrx_status.mactime = le64_to_cpu(phy_res->timestamp);\r\nrx_status.band = (phy_res->phy_flags & RX_RES_PHY_FLAGS_BAND_24_MSK) ?\r\nIEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;\r\nrx_status.freq =\r\nieee80211_channel_to_frequency(le16_to_cpu(phy_res->channel),\r\nrx_status.band);\r\nrx_status.rate_idx =\r\niwl4965_hwrate_to_mac80211_idx(rate_n_flags, rx_status.band);\r\nrx_status.flag = 0;\r\npriv->ucode_beacon_time = le32_to_cpu(phy_res->beacon_time_stamp);\r\nrx_status.signal = iwl4965_calc_rssi(priv, phy_res);\r\niwl_legacy_dbg_log_rx_data_frame(priv, len, header);\r\nIWL_DEBUG_STATS_LIMIT(priv, "Rssi %d, TSF %llu\n",\r\nrx_status.signal, (unsigned long long)rx_status.mactime);\r\nrx_status.antenna =\r\n(le16_to_cpu(phy_res->phy_flags) & RX_RES_PHY_FLAGS_ANTENNA_MSK)\r\n>> RX_RES_PHY_FLAGS_ANTENNA_POS;\r\nif (phy_res->phy_flags & RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK)\r\nrx_status.flag |= RX_FLAG_SHORTPRE;\r\nif (rate_n_flags & RATE_MCS_HT_MSK)\r\nrx_status.flag |= RX_FLAG_HT;\r\nif (rate_n_flags & RATE_MCS_HT40_MSK)\r\nrx_status.flag |= RX_FLAG_40MHZ;\r\nif (rate_n_flags & RATE_MCS_SGI_MSK)\r\nrx_status.flag |= RX_FLAG_SHORT_GI;\r\niwl4965_pass_packet_to_mac80211(priv, header, len, ampdu_status,\r\nrxb, &rx_status);\r\n}\r\nvoid iwl4965_rx_reply_rx_phy(struct iwl_priv *priv,\r\nstruct iwl_rx_mem_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\npriv->_4965.last_phy_res_valid = true;\r\nmemcpy(&priv->_4965.last_phy_res, pkt->u.raw,\r\nsizeof(struct iwl_rx_phy_res));\r\n}\r\nstatic int iwl4965_get_channels_for_scan(struct iwl_priv *priv,\r\nstruct ieee80211_vif *vif,\r\nenum ieee80211_band band,\r\nu8 is_active, u8 n_probes,\r\nstruct iwl_scan_channel *scan_ch)\r\n{\r\nstruct ieee80211_channel *chan;\r\nconst struct ieee80211_supported_band *sband;\r\nconst struct iwl_channel_info *ch_info;\r\nu16 passive_dwell = 0;\r\nu16 active_dwell = 0;\r\nint added, i;\r\nu16 channel;\r\nsband = iwl_get_hw_mode(priv, band);\r\nif (!sband)\r\nreturn 0;\r\nactive_dwell = iwl_legacy_get_active_dwell_time(priv, band, n_probes);\r\npassive_dwell = iwl_legacy_get_passive_dwell_time(priv, band, vif);\r\nif (passive_dwell <= active_dwell)\r\npassive_dwell = active_dwell + 1;\r\nfor (i = 0, added = 0; i < priv->scan_request->n_channels; i++) {\r\nchan = priv->scan_request->channels[i];\r\nif (chan->band != band)\r\ncontinue;\r\nchannel = chan->hw_value;\r\nscan_ch->channel = cpu_to_le16(channel);\r\nch_info = iwl_legacy_get_channel_info(priv, band, channel);\r\nif (!iwl_legacy_is_channel_valid(ch_info)) {\r\nIWL_DEBUG_SCAN(priv,\r\n"Channel %d is INVALID for this band.\n",\r\nchannel);\r\ncontinue;\r\n}\r\nif (!is_active || iwl_legacy_is_channel_passive(ch_info) ||\r\n(chan->flags & IEEE80211_CHAN_PASSIVE_SCAN))\r\nscan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;\r\nelse\r\nscan_ch->type = SCAN_CHANNEL_TYPE_ACTIVE;\r\nif (n_probes)\r\nscan_ch->type |= IWL_SCAN_PROBE_MASK(n_probes);\r\nscan_ch->active_dwell = cpu_to_le16(active_dwell);\r\nscan_ch->passive_dwell = cpu_to_le16(passive_dwell);\r\nscan_ch->dsp_atten = 110;\r\nif (band == IEEE80211_BAND_5GHZ)\r\nscan_ch->tx_gain = ((1 << 5) | (3 << 3)) | 3;\r\nelse\r\nscan_ch->tx_gain = ((1 << 5) | (5 << 3));\r\nIWL_DEBUG_SCAN(priv, "Scanning ch=%d prob=0x%X [%s %d]\n",\r\nchannel, le32_to_cpu(scan_ch->type),\r\n(scan_ch->type & SCAN_CHANNEL_TYPE_ACTIVE) ?\r\n"ACTIVE" : "PASSIVE",\r\n(scan_ch->type & SCAN_CHANNEL_TYPE_ACTIVE) ?\r\nactive_dwell : passive_dwell);\r\nscan_ch++;\r\nadded++;\r\n}\r\nIWL_DEBUG_SCAN(priv, "total channels to scan %d\n", added);\r\nreturn added;\r\n}\r\nint iwl4965_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)\r\n{\r\nstruct iwl_host_cmd cmd = {\r\n.id = REPLY_SCAN_CMD,\r\n.len = sizeof(struct iwl_scan_cmd),\r\n.flags = CMD_SIZE_HUGE,\r\n};\r\nstruct iwl_scan_cmd *scan;\r\nstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\r\nu32 rate_flags = 0;\r\nu16 cmd_len;\r\nu16 rx_chain = 0;\r\nenum ieee80211_band band;\r\nu8 n_probes = 0;\r\nu8 rx_ant = priv->hw_params.valid_rx_ant;\r\nu8 rate;\r\nbool is_active = false;\r\nint chan_mod;\r\nu8 active_chains;\r\nu8 scan_tx_antennas = priv->hw_params.valid_tx_ant;\r\nint ret;\r\nlockdep_assert_held(&priv->mutex);\r\nif (vif)\r\nctx = iwl_legacy_rxon_ctx_from_vif(vif);\r\nif (!priv->scan_cmd) {\r\npriv->scan_cmd = kmalloc(sizeof(struct iwl_scan_cmd) +\r\nIWL_MAX_SCAN_SIZE, GFP_KERNEL);\r\nif (!priv->scan_cmd) {\r\nIWL_DEBUG_SCAN(priv,\r\n"fail to allocate memory for scan\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nscan = priv->scan_cmd;\r\nmemset(scan, 0, sizeof(struct iwl_scan_cmd) + IWL_MAX_SCAN_SIZE);\r\nscan->quiet_plcp_th = IWL_PLCP_QUIET_THRESH;\r\nscan->quiet_time = IWL_ACTIVE_QUIET_TIME;\r\nif (iwl_legacy_is_any_associated(priv)) {\r\nu16 interval;\r\nu32 extra;\r\nu32 suspend_time = 100;\r\nu32 scan_suspend_time = 100;\r\nIWL_DEBUG_INFO(priv, "Scanning while associated...\n");\r\ninterval = vif->bss_conf.beacon_int;\r\nscan->suspend_time = 0;\r\nscan->max_out_time = cpu_to_le32(200 * 1024);\r\nif (!interval)\r\ninterval = suspend_time;\r\nextra = (suspend_time / interval) << 22;\r\nscan_suspend_time = (extra |\r\n((suspend_time % interval) * 1024));\r\nscan->suspend_time = cpu_to_le32(scan_suspend_time);\r\nIWL_DEBUG_SCAN(priv, "suspend_time 0x%X beacon interval %d\n",\r\nscan_suspend_time, interval);\r\n}\r\nif (priv->scan_request->n_ssids) {\r\nint i, p = 0;\r\nIWL_DEBUG_SCAN(priv, "Kicking off active scan\n");\r\nfor (i = 0; i < priv->scan_request->n_ssids; i++) {\r\nif (!priv->scan_request->ssids[i].ssid_len)\r\ncontinue;\r\nscan->direct_scan[p].id = WLAN_EID_SSID;\r\nscan->direct_scan[p].len =\r\npriv->scan_request->ssids[i].ssid_len;\r\nmemcpy(scan->direct_scan[p].ssid,\r\npriv->scan_request->ssids[i].ssid,\r\npriv->scan_request->ssids[i].ssid_len);\r\nn_probes++;\r\np++;\r\n}\r\nis_active = true;\r\n} else\r\nIWL_DEBUG_SCAN(priv, "Start passive scan.\n");\r\nscan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;\r\nscan->tx_cmd.sta_id = ctx->bcast_sta_id;\r\nscan->tx_cmd.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\nswitch (priv->scan_band) {\r\ncase IEEE80211_BAND_2GHZ:\r\nscan->flags = RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK;\r\nchan_mod = le32_to_cpu(\r\npriv->contexts[IWL_RXON_CTX_BSS].active.flags &\r\nRXON_FLG_CHANNEL_MODE_MSK)\r\n>> RXON_FLG_CHANNEL_MODE_POS;\r\nif (chan_mod == CHANNEL_MODE_PURE_40) {\r\nrate = IWL_RATE_6M_PLCP;\r\n} else {\r\nrate = IWL_RATE_1M_PLCP;\r\nrate_flags = RATE_MCS_CCK_MSK;\r\n}\r\nbreak;\r\ncase IEEE80211_BAND_5GHZ:\r\nrate = IWL_RATE_6M_PLCP;\r\nbreak;\r\ndefault:\r\nIWL_WARN(priv, "Invalid scan band\n");\r\nreturn -EIO;\r\n}\r\nscan->good_CRC_th = is_active ? IWL_GOOD_CRC_TH_DEFAULT :\r\nIWL_GOOD_CRC_TH_NEVER;\r\nband = priv->scan_band;\r\nif (priv->cfg->scan_rx_antennas[band])\r\nrx_ant = priv->cfg->scan_rx_antennas[band];\r\npriv->scan_tx_ant[band] = iwl4965_toggle_tx_ant(priv,\r\npriv->scan_tx_ant[band],\r\nscan_tx_antennas);\r\nrate_flags |= iwl4965_ant_idx_to_flags(priv->scan_tx_ant[band]);\r\nscan->tx_cmd.rate_n_flags = iwl4965_hw_set_rate_n_flags(rate, rate_flags);\r\nif (test_bit(STATUS_POWER_PMI, &priv->status)) {\r\nactive_chains = rx_ant &\r\n((u8)(priv->chain_noise_data.active_chains));\r\nif (!active_chains)\r\nactive_chains = rx_ant;\r\nIWL_DEBUG_SCAN(priv, "chain_noise_data.active_chains: %u\n",\r\npriv->chain_noise_data.active_chains);\r\nrx_ant = iwl4965_first_antenna(active_chains);\r\n}\r\nrx_chain |= priv->hw_params.valid_rx_ant << RXON_RX_CHAIN_VALID_POS;\r\nrx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_MIMO_SEL_POS;\r\nrx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_SEL_POS;\r\nrx_chain |= 0x1 << RXON_RX_CHAIN_DRIVER_FORCE_POS;\r\nscan->rx_chain = cpu_to_le16(rx_chain);\r\ncmd_len = iwl_legacy_fill_probe_req(priv,\r\n(struct ieee80211_mgmt *)scan->data,\r\nvif->addr,\r\npriv->scan_request->ie,\r\npriv->scan_request->ie_len,\r\nIWL_MAX_SCAN_SIZE - sizeof(*scan));\r\nscan->tx_cmd.len = cpu_to_le16(cmd_len);\r\nscan->filter_flags |= (RXON_FILTER_ACCEPT_GRP_MSK |\r\nRXON_FILTER_BCON_AWARE_MSK);\r\nscan->channel_count = iwl4965_get_channels_for_scan(priv, vif, band,\r\nis_active, n_probes,\r\n(void *)&scan->data[cmd_len]);\r\nif (scan->channel_count == 0) {\r\nIWL_DEBUG_SCAN(priv, "channel count %d\n", scan->channel_count);\r\nreturn -EIO;\r\n}\r\ncmd.len += le16_to_cpu(scan->tx_cmd.len) +\r\nscan->channel_count * sizeof(struct iwl_scan_channel);\r\ncmd.data = scan;\r\nscan->len = cpu_to_le16(cmd.len);\r\nset_bit(STATUS_SCAN_HW, &priv->status);\r\nret = iwl_legacy_send_cmd_sync(priv, &cmd);\r\nif (ret)\r\nclear_bit(STATUS_SCAN_HW, &priv->status);\r\nreturn ret;\r\n}\r\nint iwl4965_manage_ibss_station(struct iwl_priv *priv,\r\nstruct ieee80211_vif *vif, bool add)\r\n{\r\nstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\r\nif (add)\r\nreturn iwl4965_add_bssid_station(priv, vif_priv->ctx,\r\nvif->bss_conf.bssid,\r\n&vif_priv->ibss_bssid_sta_id);\r\nreturn iwl_legacy_remove_station(priv, vif_priv->ibss_bssid_sta_id,\r\nvif->bss_conf.bssid);\r\n}\r\nvoid iwl4965_free_tfds_in_queue(struct iwl_priv *priv,\r\nint sta_id, int tid, int freed)\r\n{\r\nlockdep_assert_held(&priv->sta_lock);\r\nif (priv->stations[sta_id].tid[tid].tfds_in_queue >= freed)\r\npriv->stations[sta_id].tid[tid].tfds_in_queue -= freed;\r\nelse {\r\nIWL_DEBUG_TX(priv, "free more than tfds_in_queue (%u:%d)\n",\r\npriv->stations[sta_id].tid[tid].tfds_in_queue,\r\nfreed);\r\npriv->stations[sta_id].tid[tid].tfds_in_queue = 0;\r\n}\r\n}\r\nstatic bool iwl4965_is_single_rx_stream(struct iwl_priv *priv)\r\n{\r\nreturn priv->current_ht_config.smps == IEEE80211_SMPS_STATIC ||\r\npriv->current_ht_config.single_chain_sufficient;\r\n}\r\nstatic int iwl4965_get_active_rx_chain_count(struct iwl_priv *priv)\r\n{\r\nif (iwl4965_is_single_rx_stream(priv))\r\nreturn IWL_NUM_RX_CHAINS_SINGLE;\r\nelse\r\nreturn IWL_NUM_RX_CHAINS_MULTIPLE;\r\n}\r\nstatic int\r\niwl4965_get_idle_rx_chain_count(struct iwl_priv *priv, int active_cnt)\r\n{\r\nswitch (priv->current_ht_config.smps) {\r\ncase IEEE80211_SMPS_STATIC:\r\ncase IEEE80211_SMPS_DYNAMIC:\r\nreturn IWL_NUM_IDLE_CHAINS_SINGLE;\r\ncase IEEE80211_SMPS_OFF:\r\nreturn active_cnt;\r\ndefault:\r\nWARN(1, "invalid SMPS mode %d",\r\npriv->current_ht_config.smps);\r\nreturn active_cnt;\r\n}\r\n}\r\nstatic u8 iwl4965_count_chain_bitmap(u32 chain_bitmap)\r\n{\r\nu8 res;\r\nres = (chain_bitmap & BIT(0)) >> 0;\r\nres += (chain_bitmap & BIT(1)) >> 1;\r\nres += (chain_bitmap & BIT(2)) >> 2;\r\nres += (chain_bitmap & BIT(3)) >> 3;\r\nreturn res;\r\n}\r\nvoid iwl4965_set_rxon_chain(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\r\n{\r\nbool is_single = iwl4965_is_single_rx_stream(priv);\r\nbool is_cam = !test_bit(STATUS_POWER_PMI, &priv->status);\r\nu8 idle_rx_cnt, active_rx_cnt, valid_rx_cnt;\r\nu32 active_chains;\r\nu16 rx_chain;\r\nif (priv->chain_noise_data.active_chains)\r\nactive_chains = priv->chain_noise_data.active_chains;\r\nelse\r\nactive_chains = priv->hw_params.valid_rx_ant;\r\nrx_chain = active_chains << RXON_RX_CHAIN_VALID_POS;\r\nactive_rx_cnt = iwl4965_get_active_rx_chain_count(priv);\r\nidle_rx_cnt = iwl4965_get_idle_rx_chain_count(priv, active_rx_cnt);\r\nvalid_rx_cnt = iwl4965_count_chain_bitmap(active_chains);\r\nif (valid_rx_cnt < active_rx_cnt)\r\nactive_rx_cnt = valid_rx_cnt;\r\nif (valid_rx_cnt < idle_rx_cnt)\r\nidle_rx_cnt = valid_rx_cnt;\r\nrx_chain |= active_rx_cnt << RXON_RX_CHAIN_MIMO_CNT_POS;\r\nrx_chain |= idle_rx_cnt << RXON_RX_CHAIN_CNT_POS;\r\nctx->staging.rx_chain = cpu_to_le16(rx_chain);\r\nif (!is_single && (active_rx_cnt >= IWL_NUM_RX_CHAINS_SINGLE) && is_cam)\r\nctx->staging.rx_chain |= RXON_RX_CHAIN_MIMO_FORCE_MSK;\r\nelse\r\nctx->staging.rx_chain &= ~RXON_RX_CHAIN_MIMO_FORCE_MSK;\r\nIWL_DEBUG_ASSOC(priv, "rx_chain=0x%X active=%d idle=%d\n",\r\nctx->staging.rx_chain,\r\nactive_rx_cnt, idle_rx_cnt);\r\nWARN_ON(active_rx_cnt == 0 || idle_rx_cnt == 0 ||\r\nactive_rx_cnt < idle_rx_cnt);\r\n}\r\nu8 iwl4965_toggle_tx_ant(struct iwl_priv *priv, u8 ant, u8 valid)\r\n{\r\nint i;\r\nu8 ind = ant;\r\nfor (i = 0; i < RATE_ANT_NUM - 1; i++) {\r\nind = (ind + 1) < RATE_ANT_NUM ? ind + 1 : 0;\r\nif (valid & BIT(ind))\r\nreturn ind;\r\n}\r\nreturn ant;\r\n}\r\nstatic const char *iwl4965_get_fh_string(int cmd)\r\n{\r\nswitch (cmd) {\r\nIWL_CMD(FH_RSCSR_CHNL0_STTS_WPTR_REG);\r\nIWL_CMD(FH_RSCSR_CHNL0_RBDCB_BASE_REG);\r\nIWL_CMD(FH_RSCSR_CHNL0_WPTR);\r\nIWL_CMD(FH_MEM_RCSR_CHNL0_CONFIG_REG);\r\nIWL_CMD(FH_MEM_RSSR_SHARED_CTRL_REG);\r\nIWL_CMD(FH_MEM_RSSR_RX_STATUS_REG);\r\nIWL_CMD(FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV);\r\nIWL_CMD(FH_TSSR_TX_STATUS_REG);\r\nIWL_CMD(FH_TSSR_TX_ERROR_REG);\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nint iwl4965_dump_fh(struct iwl_priv *priv, char **buf, bool display)\r\n{\r\nint i;\r\n#ifdef CONFIG_IWLWIFI_LEGACY_DEBUG\r\nint pos = 0;\r\nsize_t bufsz = 0;\r\n#endif\r\nstatic const u32 fh_tbl[] = {\r\nFH_RSCSR_CHNL0_STTS_WPTR_REG,\r\nFH_RSCSR_CHNL0_RBDCB_BASE_REG,\r\nFH_RSCSR_CHNL0_WPTR,\r\nFH_MEM_RCSR_CHNL0_CONFIG_REG,\r\nFH_MEM_RSSR_SHARED_CTRL_REG,\r\nFH_MEM_RSSR_RX_STATUS_REG,\r\nFH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV,\r\nFH_TSSR_TX_STATUS_REG,\r\nFH_TSSR_TX_ERROR_REG\r\n};\r\n#ifdef CONFIG_IWLWIFI_LEGACY_DEBUG\r\nif (display) {\r\nbufsz = ARRAY_SIZE(fh_tbl) * 48 + 40;\r\n*buf = kmalloc(bufsz, GFP_KERNEL);\r\nif (!*buf)\r\nreturn -ENOMEM;\r\npos += scnprintf(*buf + pos, bufsz - pos,\r\n"FH register values:\n");\r\nfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\r\npos += scnprintf(*buf + pos, bufsz - pos,\r\n" %34s: 0X%08x\n",\r\niwl4965_get_fh_string(fh_tbl[i]),\r\niwl_legacy_read_direct32(priv, fh_tbl[i]));\r\n}\r\nreturn pos;\r\n}\r\n#endif\r\nIWL_ERR(priv, "FH register values:\n");\r\nfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\r\nIWL_ERR(priv, " %34s: 0X%08x\n",\r\niwl4965_get_fh_string(fh_tbl[i]),\r\niwl_legacy_read_direct32(priv, fh_tbl[i]));\r\n}\r\nreturn 0;\r\n}
