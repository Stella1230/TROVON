static inline void buffer_info_init_left(struct tree_balance *tb,\r\nstruct buffer_info *bi)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = tb->L[0];\r\nbi->bi_parent = tb->FL[0];\r\nbi->bi_position = get_left_neighbor_position(tb, 0);\r\n}\r\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\r\nstruct buffer_info *bi)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = tb->R[0];\r\nbi->bi_parent = tb->FR[0];\r\nbi->bi_position = get_right_neighbor_position(tb, 0);\r\n}\r\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\r\nstruct buffer_info *bi)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\r\nbi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\r\nbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\r\n}\r\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\r\nstruct buffer_info *bi,\r\nstruct buffer_head *bh)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = bh;\r\nbi->bi_parent = NULL;\r\nbi->bi_position = 0;\r\n}\r\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\r\nstruct buffer_head *bh, int flag)\r\n{\r\njournal_mark_dirty(tb->transaction_handle,\r\ntb->transaction_handle->t_super, bh);\r\n}\r\nstatic int balance_leaf_when_delete(struct tree_balance *tb, int flag)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint item_pos = PATH_LAST_POSITION(tb->tb_path);\r\nint pos_in_item = tb->tb_path->pos_in_item;\r\nstruct buffer_info bi;\r\nint n;\r\nstruct item_head *ih;\r\nRFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,\r\n"vs- 12000: level: wrong FR %z", tb->FR[0]);\r\nRFALSE(tb->blknum[0] > 1,\r\n"PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);\r\nRFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),\r\n"PAP-12010: tree can not be empty");\r\nih = B_N_PITEM_HEAD(tbS0, item_pos);\r\nbuffer_info_init_tbS0(tb, &bi);\r\nswitch (flag) {\r\ncase M_DELETE:\r\nRFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],\r\n"vs-12013: mode Delete, insert size %d, ih to be deleted %h",\r\n-tb->insert_size[0], ih);\r\nleaf_delete_items(&bi, 0, item_pos, 1, -1);\r\nif (!item_pos && tb->CFL[0]) {\r\nif (B_NR_ITEMS(tbS0)) {\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0,\r\n0);\r\n} else {\r\nif (!PATH_H_POSITION(tb->tb_path, 1))\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0],\r\nPATH_H_PPARENT(tb->tb_path,\r\n0), 0);\r\n}\r\n}\r\nRFALSE(!item_pos && !tb->CFL[0],\r\n"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0],\r\ntb->L[0]);\r\nbreak;\r\ncase M_CUT:{\r\nif (is_direntry_le_ih(ih)) {\r\ntb->insert_size[0] = -1;\r\nleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\r\n-tb->insert_size[0]);\r\nRFALSE(!item_pos && !pos_in_item && !tb->CFL[0],\r\n"PAP-12030: can not change delimiting key. CFL[0]=%p",\r\ntb->CFL[0]);\r\nif (!item_pos && !pos_in_item && tb->CFL[0]) {\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0],\r\ntbS0, 0);\r\n}\r\n} else {\r\nleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\r\n-tb->insert_size[0]);\r\nRFALSE(!ih_item_len(ih),\r\n"PAP-12035: cut must leave non-zero dynamic length of item");\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nprint_cur_tb("12040");\r\nreiserfs_panic(tb->tb_sb, "PAP-12040",\r\n"unexpected mode: %s(%d)",\r\n(flag ==\r\nM_PASTE) ? "PASTE" : ((flag ==\r\nM_INSERT) ? "INSERT" :\r\n"UNKNOWN"), flag);\r\n}\r\nn = B_NR_ITEMS(tbS0);\r\nif (tb->lnum[0]) {\r\nif (tb->lnum[0] == -1) {\r\nif (tb->rnum[0] == -1) {\r\nif (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {\r\nif (PATH_H_POSITION(tb->tb_path, 1) == 0\r\n&& 1 < B_NR_ITEMS(tb->FR[0]))\r\nreplace_key(tb, tb->CFL[0],\r\ntb->lkey[0],\r\ntb->FR[0], 1);\r\nleaf_move_items(LEAF_FROM_S_TO_L, tb, n,\r\n-1, NULL);\r\nleaf_move_items(LEAF_FROM_R_TO_L, tb,\r\nB_NR_ITEMS(tb->R[0]),\r\n-1, NULL);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreiserfs_invalidate_buffer(tb,\r\ntb->R[0]);\r\nreturn 0;\r\n}\r\nleaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1,\r\nNULL);\r\nleaf_move_items(LEAF_FROM_L_TO_R, tb,\r\nB_NR_ITEMS(tb->L[0]), -1, NULL);\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0],\r\ntb->R[0], 0);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreiserfs_invalidate_buffer(tb, tb->L[0]);\r\nreturn -1;\r\n}\r\nRFALSE(tb->rnum[0] != 0,\r\n"PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);\r\nleaf_shift_left(tb, n, -1);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nRFALSE((tb->lnum[0] + tb->rnum[0] < n) ||\r\n(tb->lnum[0] + tb->rnum[0] > n + 1),\r\n"PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",\r\ntb->rnum[0], tb->lnum[0], n);\r\nRFALSE((tb->lnum[0] + tb->rnum[0] == n) &&\r\n(tb->lbytes != -1 || tb->rbytes != -1),\r\n"PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split",\r\ntb->rbytes, tb->lbytes);\r\nRFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&\r\n(tb->lbytes < 1 || tb->rbytes != -1),\r\n"PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split",\r\ntb->rbytes, tb->lbytes);\r\nleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nif (tb->rnum[0] == -1) {\r\nleaf_shift_right(tb, n, -1);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nRFALSE(tb->rnum[0],\r\n"PAP-12065: bad rnum parameter must be 0 (%d)", tb->rnum[0]);\r\nreturn 0;\r\n}\r\nstatic int balance_leaf(struct tree_balance *tb, struct item_head *ih,\r\nconst char *body,\r\nint flag,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr\r\n)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint item_pos = PATH_LAST_POSITION(tb->tb_path);\r\nstruct buffer_info bi;\r\nstruct buffer_head *S_new[2];\r\nint snum[2];\r\nint sbytes[2];\r\nint n, i;\r\nint ret_val;\r\nint pos_in_item;\r\nint zeros_num;\r\nPROC_INFO_INC(tb->tb_sb, balance_at[0]);\r\nif (tb->insert_size[0] < 0)\r\nreturn balance_leaf_when_delete(tb, flag);\r\nzeros_num = 0;\r\nif (flag == M_INSERT && !body)\r\nzeros_num = ih_item_len(ih);\r\npos_in_item = tb->tb_path->pos_in_item;\r\nif (flag != M_INSERT\r\n&& is_indirect_le_ih(B_N_PITEM_HEAD(tbS0, item_pos)))\r\npos_in_item *= UNFM_P_SIZE;\r\nif (tb->lnum[0] > 0) {\r\nif (item_pos < tb->lnum[0]) {\r\nn = B_NR_ITEMS(tb->L[0]);\r\nswitch (flag) {\r\ncase M_INSERT:\r\nif (item_pos == tb->lnum[0] - 1\r\n&& tb->lbytes != -1) {\r\nint new_item_len;\r\nint version;\r\nret_val =\r\nleaf_shift_left(tb, tb->lnum[0] - 1,\r\n-1);\r\nnew_item_len =\r\nih_item_len(ih) - tb->lbytes;\r\nput_ih_item_len(ih,\r\nih_item_len(ih) -\r\nnew_item_len);\r\nRFALSE(ih_item_len(ih) <= 0,\r\n"PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",\r\nih_item_len(ih));\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_insert_into_buf(&bi,\r\nn + item_pos -\r\nret_val, ih, body,\r\nzeros_num >\r\nih_item_len(ih) ?\r\nih_item_len(ih) :\r\nzeros_num);\r\nversion = ih_version(ih);\r\nset_le_ih_k_offset(ih,\r\nle_ih_k_offset(ih) +\r\n(tb->\r\nlbytes <<\r\n(is_indirect_le_ih\r\n(ih) ? tb->tb_sb->\r\ns_blocksize_bits -\r\nUNFM_P_SHIFT :\r\n0)));\r\nput_ih_item_len(ih, new_item_len);\r\nif (tb->lbytes > zeros_num) {\r\nbody +=\r\n(tb->lbytes - zeros_num);\r\nzeros_num = 0;\r\n} else\r\nzeros_num -= tb->lbytes;\r\nRFALSE(ih_item_len(ih) <= 0,\r\n"PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",\r\nih_item_len(ih));\r\n} else {\r\nret_val =\r\nleaf_shift_left(tb, tb->lnum[0] - 1,\r\ntb->lbytes);\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_insert_into_buf(&bi,\r\nn + item_pos -\r\nret_val, ih, body,\r\nzeros_num);\r\ntb->insert_size[0] = 0;\r\nzeros_num = 0;\r\n}\r\nbreak;\r\ncase M_PASTE:\r\nif (item_pos == tb->lnum[0] - 1\r\n&& tb->lbytes != -1) {\r\nif (is_direntry_le_ih\r\n(B_N_PITEM_HEAD(tbS0, item_pos))) {\r\nRFALSE(zeros_num,\r\n"PAP-12090: invalid parameter in case of a directory");\r\nif (tb->lbytes > pos_in_item) {\r\nstruct item_head\r\n*pasted;\r\nint l_pos_in_item =\r\npos_in_item;\r\nret_val =\r\nleaf_shift_left(tb,\r\ntb->\r\nlnum\r\n[0],\r\ntb->\r\nlbytes\r\n-\r\n1);\r\nif (ret_val\r\n&& !item_pos) {\r\npasted =\r\nB_N_PITEM_HEAD\r\n(tb->L[0],\r\nB_NR_ITEMS\r\n(tb->\r\nL[0]) -\r\n1);\r\nl_pos_in_item +=\r\nI_ENTRY_COUNT\r\n(pasted) -\r\n(tb->\r\nlbytes -\r\n1);\r\n}\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_paste_in_buffer\r\n(&bi,\r\nn + item_pos -\r\nret_val,\r\nl_pos_in_item,\r\ntb->insert_size[0],\r\nbody, zeros_num);\r\nleaf_paste_entries(&bi,\r\nn +\r\nitem_pos\r\n-\r\nret_val,\r\nl_pos_in_item,\r\n1,\r\n(struct\r\nreiserfs_de_head\r\n*)\r\nbody,\r\nbody\r\n+\r\nDEH_SIZE,\r\ntb->\r\ninsert_size\r\n[0]\r\n);\r\ntb->insert_size[0] = 0;\r\n} else {\r\nleaf_shift_left(tb,\r\ntb->\r\nlnum[0],\r\ntb->\r\nlbytes);\r\n}\r\npos_in_item -= tb->lbytes;\r\n} else {\r\nRFALSE(tb->lbytes <= 0,\r\n"PAP-12095: there is nothing to shift to L[0]. lbytes=%d",\r\ntb->lbytes);\r\nRFALSE(pos_in_item !=\r\nih_item_len\r\n(B_N_PITEM_HEAD\r\n(tbS0, item_pos)),\r\n"PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",\r\nih_item_len\r\n(B_N_PITEM_HEAD\r\n(tbS0, item_pos)),\r\npos_in_item);\r\nif (tb->lbytes >= pos_in_item) {\r\nint l_n;\r\nl_n =\r\ntb->lbytes -\r\npos_in_item;\r\ntb->insert_size[0] -=\r\nl_n;\r\nRFALSE(tb->\r\ninsert_size[0] <=\r\n0,\r\n"PAP-12105: there is nothing to paste into L[0]. insert_size=%d",\r\ntb->\r\ninsert_size[0]);\r\nret_val =\r\nleaf_shift_left(tb,\r\ntb->\r\nlnum\r\n[0],\r\nih_item_len\r\n(B_N_PITEM_HEAD\r\n(tbS0,\r\nitem_pos)));\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_paste_in_buffer\r\n(&bi,\r\nn + item_pos -\r\nret_val,\r\nih_item_len\r\n(B_N_PITEM_HEAD\r\n(tb->L[0],\r\nn + item_pos -\r\nret_val)), l_n,\r\nbody,\r\nzeros_num >\r\nl_n ? l_n :\r\nzeros_num);\r\n{\r\nint version;\r\nint temp_l =\r\nl_n;\r\nRFALSE\r\n(ih_item_len\r\n(B_N_PITEM_HEAD\r\n(tbS0,\r\n0)),\r\n"PAP-12106: item length must be 0");\r\nRFALSE\r\n(comp_short_le_keys\r\n(B_N_PKEY\r\n(tbS0, 0),\r\nB_N_PKEY\r\n(tb->L[0],\r\nn +\r\nitem_pos\r\n-\r\nret_val)),\r\n"PAP-12107: items must be of the same file");\r\nif (is_indirect_le_ih(B_N_PITEM_HEAD(tb->L[0], n + item_pos - ret_val))) {\r\ntemp_l =\r\nl_n\r\n<<\r\n(tb->\r\ntb_sb->\r\ns_blocksize_bits\r\n-\r\nUNFM_P_SHIFT);\r\n}\r\nversion =\r\nih_version\r\n(B_N_PITEM_HEAD\r\n(tbS0, 0));\r\nset_le_key_k_offset\r\n(version,\r\nB_N_PKEY\r\n(tbS0, 0),\r\nle_key_k_offset\r\n(version,\r\nB_N_PKEY\r\n(tbS0,\r\n0)) +\r\ntemp_l);\r\nset_le_key_k_offset\r\n(version,\r\nB_N_PDELIM_KEY\r\n(tb->\r\nCFL[0],\r\ntb->\r\nlkey[0]),\r\nle_key_k_offset\r\n(version,\r\nB_N_PDELIM_KEY\r\n(tb->\r\nCFL[0],\r\ntb->\r\nlkey[0]))\r\n+ temp_l);\r\n}\r\nif (l_n > zeros_num) {\r\nbody +=\r\n(l_n -\r\nzeros_num);\r\nzeros_num = 0;\r\n} else\r\nzeros_num -=\r\nl_n;\r\npos_in_item = 0;\r\nRFALSE\r\n(comp_short_le_keys\r\n(B_N_PKEY(tbS0, 0),\r\nB_N_PKEY(tb->L[0],\r\nB_NR_ITEMS\r\n(tb->\r\nL[0]) -\r\n1))\r\n||\r\n!op_is_left_mergeable\r\n(B_N_PKEY(tbS0, 0),\r\ntbS0->b_size)\r\n||\r\n!op_is_left_mergeable\r\n(B_N_PDELIM_KEY\r\n(tb->CFL[0],\r\ntb->lkey[0]),\r\ntbS0->b_size),\r\n"PAP-12120: item must be merge-able with left neighboring item");\r\n} else {\r\npos_in_item -=\r\ntb->lbytes;\r\nRFALSE(pos_in_item <= 0,\r\n"PAP-12125: no place for paste. pos_in_item=%d",\r\npos_in_item);\r\nleaf_shift_left(tb,\r\ntb->\r\nlnum[0],\r\ntb->\r\nlbytes);\r\n}\r\n}\r\n} else {\r\nstruct item_head *pasted;\r\nif (!item_pos && op_is_left_mergeable(B_N_PKEY(tbS0, 0), tbS0->b_size)) {\r\npasted =\r\nB_N_PITEM_HEAD(tb->L[0],\r\nn - 1);\r\nif (is_direntry_le_ih(pasted))\r\npos_in_item +=\r\nih_entry_count\r\n(pasted);\r\nelse\r\npos_in_item +=\r\nih_item_len(pasted);\r\n}\r\nret_val =\r\nleaf_shift_left(tb, tb->lnum[0],\r\ntb->lbytes);\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_paste_in_buffer(&bi,\r\nn + item_pos -\r\nret_val,\r\npos_in_item,\r\ntb->insert_size[0],\r\nbody, zeros_num);\r\npasted =\r\nB_N_PITEM_HEAD(tb->L[0],\r\nn + item_pos -\r\nret_val);\r\nif (is_direntry_le_ih(pasted))\r\nleaf_paste_entries(&bi,\r\nn +\r\nitem_pos -\r\nret_val,\r\npos_in_item,\r\n1,\r\n(struct\r\nreiserfs_de_head\r\n*)body,\r\nbody +\r\nDEH_SIZE,\r\ntb->\r\ninsert_size\r\n[0]\r\n);\r\nif (is_indirect_le_ih(pasted))\r\nset_ih_free_space(pasted, 0);\r\ntb->insert_size[0] = 0;\r\nzeros_num = 0;\r\n}\r\nbreak;\r\ndefault:\r\nreiserfs_panic(tb->tb_sb, "PAP-12130",\r\n"lnum > 0: unexpected mode: "\r\n" %s(%d)",\r\n(flag ==\r\nM_DELETE) ? "DELETE" : ((flag ==\r\nM_CUT)\r\n? "CUT"\r\n:\r\n"UNKNOWN"),\r\nflag);\r\n}\r\n} else {\r\nleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\r\n}\r\n}\r\nitem_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));\r\nif (tb->rnum[0] > 0) {\r\nn = B_NR_ITEMS(tbS0);\r\nswitch (flag) {\r\ncase M_INSERT:\r\nif (n - tb->rnum[0] < item_pos) {\r\nif (item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {\r\nloff_t old_key_comp, old_len,\r\nr_zeros_number;\r\nconst char *r_body;\r\nint version;\r\nloff_t offset;\r\nleaf_shift_right(tb, tb->rnum[0] - 1,\r\n-1);\r\nversion = ih_version(ih);\r\nold_key_comp = le_ih_k_offset(ih);\r\nold_len = ih_item_len(ih);\r\noffset =\r\nle_ih_k_offset(ih) +\r\n((old_len -\r\ntb->\r\nrbytes) << (is_indirect_le_ih(ih)\r\n? tb->tb_sb->\r\ns_blocksize_bits -\r\nUNFM_P_SHIFT : 0));\r\nset_le_ih_k_offset(ih, offset);\r\nput_ih_item_len(ih, tb->rbytes);\r\nbuffer_info_init_right(tb, &bi);\r\nif ((old_len - tb->rbytes) > zeros_num) {\r\nr_zeros_number = 0;\r\nr_body =\r\nbody + (old_len -\r\ntb->rbytes) -\r\nzeros_num;\r\n} else {\r\nr_body = body;\r\nr_zeros_number =\r\nzeros_num - (old_len -\r\ntb->rbytes);\r\nzeros_num -= r_zeros_number;\r\n}\r\nleaf_insert_into_buf(&bi, 0, ih, r_body,\r\nr_zeros_number);\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0],\r\ntb->R[0], 0);\r\nset_le_ih_k_offset(ih, old_key_comp);\r\nput_ih_item_len(ih,\r\nold_len - tb->rbytes);\r\ntb->insert_size[0] -= tb->rbytes;\r\n} else {\r\nret_val =\r\nleaf_shift_right(tb,\r\ntb->rnum[0] - 1,\r\ntb->rbytes);\r\nbuffer_info_init_right(tb, &bi);\r\nleaf_insert_into_buf(&bi,\r\nitem_pos - n +\r\ntb->rnum[0] - 1,\r\nih, body,\r\nzeros_num);\r\nif (item_pos - n + tb->rnum[0] - 1 == 0) {\r\nreplace_key(tb, tb->CFR[0],\r\ntb->rkey[0],\r\ntb->R[0], 0);\r\n}\r\nzeros_num = tb->insert_size[0] = 0;\r\n}\r\n} else {\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\n}\r\nbreak;\r\ncase M_PASTE:\r\nif (n - tb->rnum[0] <= item_pos) {\r\nif (item_pos == n - tb->rnum[0] && tb->rbytes != -1) {\r\nif (is_direntry_le_ih(B_N_PITEM_HEAD(tbS0, item_pos))) {\r\nint entry_count;\r\nRFALSE(zeros_num,\r\n"PAP-12145: invalid parameter in case of a directory");\r\nentry_count =\r\nI_ENTRY_COUNT(B_N_PITEM_HEAD\r\n(tbS0,\r\nitem_pos));\r\nif (entry_count - tb->rbytes <\r\npos_in_item)\r\n{\r\nint paste_entry_position;\r\nRFALSE(tb->rbytes - 1 >=\r\nentry_count\r\n|| !tb->\r\ninsert_size[0],\r\n"PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",\r\ntb->rbytes,\r\nentry_count);\r\nleaf_shift_right(tb,\r\ntb->\r\nrnum\r\n[0],\r\ntb->\r\nrbytes\r\n- 1);\r\npaste_entry_position =\r\npos_in_item -\r\nentry_count +\r\ntb->rbytes - 1;\r\nbuffer_info_init_right(tb, &bi);\r\nleaf_paste_in_buffer\r\n(&bi, 0,\r\npaste_entry_position,\r\ntb->insert_size[0],\r\nbody, zeros_num);\r\nleaf_paste_entries(&bi,\r\n0,\r\npaste_entry_position,\r\n1,\r\n(struct\r\nreiserfs_de_head\r\n*)\r\nbody,\r\nbody\r\n+\r\nDEH_SIZE,\r\ntb->\r\ninsert_size\r\n[0]\r\n);\r\nif (paste_entry_position\r\n== 0) {\r\nreplace_key(tb,\r\ntb->\r\nCFR\r\n[0],\r\ntb->\r\nrkey\r\n[0],\r\ntb->\r\nR\r\n[0],\r\n0);\r\n}\r\ntb->insert_size[0] = 0;\r\npos_in_item++;\r\n} else {\r\nleaf_shift_right(tb,\r\ntb->\r\nrnum\r\n[0],\r\ntb->\r\nrbytes);\r\n}\r\n} else {\r\nint n_shift, n_rem,\r\nr_zeros_number;\r\nconst char *r_body;\r\nif ((n_shift =\r\ntb->rbytes -\r\ntb->insert_size[0]) < 0)\r\nn_shift = 0;\r\nRFALSE(pos_in_item !=\r\nih_item_len\r\n(B_N_PITEM_HEAD\r\n(tbS0, item_pos)),\r\n"PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",\r\npos_in_item,\r\nih_item_len\r\n(B_N_PITEM_HEAD\r\n(tbS0, item_pos)));\r\nleaf_shift_right(tb,\r\ntb->rnum[0],\r\nn_shift);\r\nif ((n_rem =\r\ntb->insert_size[0] -\r\ntb->rbytes) < 0)\r\nn_rem = 0;\r\n{\r\nint version;\r\nunsigned long temp_rem =\r\nn_rem;\r\nversion =\r\nih_version\r\n(B_N_PITEM_HEAD\r\n(tb->R[0], 0));\r\nif (is_indirect_le_key\r\n(version,\r\nB_N_PKEY(tb->R[0],\r\n0))) {\r\ntemp_rem =\r\nn_rem <<\r\n(tb->tb_sb->\r\ns_blocksize_bits\r\n-\r\nUNFM_P_SHIFT);\r\n}\r\nset_le_key_k_offset\r\n(version,\r\nB_N_PKEY(tb->R[0],\r\n0),\r\nle_key_k_offset\r\n(version,\r\nB_N_PKEY(tb->R[0],\r\n0)) +\r\ntemp_rem);\r\nset_le_key_k_offset\r\n(version,\r\nB_N_PDELIM_KEY(tb->\r\nCFR\r\n[0],\r\ntb->\r\nrkey\r\n[0]),\r\nle_key_k_offset\r\n(version,\r\nB_N_PDELIM_KEY\r\n(tb->CFR[0],\r\ntb->rkey[0])) +\r\ntemp_rem);\r\n}\r\ndo_balance_mark_internal_dirty\r\n(tb, tb->CFR[0], 0);\r\nbuffer_info_init_right(tb, &bi);\r\nif (n_rem > zeros_num) {\r\nr_zeros_number = 0;\r\nr_body =\r\nbody + n_rem -\r\nzeros_num;\r\n} else {\r\nr_body = body;\r\nr_zeros_number =\r\nzeros_num - n_rem;\r\nzeros_num -=\r\nr_zeros_number;\r\n}\r\nleaf_paste_in_buffer(&bi, 0,\r\nn_shift,\r\ntb->\r\ninsert_size\r\n[0] -\r\nn_rem,\r\nr_body,\r\nr_zeros_number);\r\nif (is_indirect_le_ih\r\n(B_N_PITEM_HEAD\r\n(tb->R[0], 0))) {\r\n#if 0\r\nRFALSE(n_rem,\r\n"PAP-12160: paste more than one unformatted node pointer");\r\n#endif\r\nset_ih_free_space\r\n(B_N_PITEM_HEAD\r\n(tb->R[0], 0), 0);\r\n}\r\ntb->insert_size[0] = n_rem;\r\nif (!n_rem)\r\npos_in_item++;\r\n}\r\n} else {\r\nstruct item_head *pasted;\r\nret_val =\r\nleaf_shift_right(tb, tb->rnum[0],\r\ntb->rbytes);\r\nif (pos_in_item >= 0) {\r\nbuffer_info_init_right(tb, &bi);\r\nleaf_paste_in_buffer(&bi,\r\nitem_pos -\r\nn +\r\ntb->\r\nrnum[0],\r\npos_in_item,\r\ntb->\r\ninsert_size\r\n[0], body,\r\nzeros_num);\r\n}\r\npasted =\r\nB_N_PITEM_HEAD(tb->R[0],\r\nitem_pos - n +\r\ntb->rnum[0]);\r\nif (is_direntry_le_ih(pasted)\r\n&& pos_in_item >= 0) {\r\nleaf_paste_entries(&bi,\r\nitem_pos -\r\nn +\r\ntb->rnum[0],\r\npos_in_item,\r\n1,\r\n(struct\r\nreiserfs_de_head\r\n*)body,\r\nbody +\r\nDEH_SIZE,\r\ntb->\r\ninsert_size\r\n[0]\r\n);\r\nif (!pos_in_item) {\r\nRFALSE(item_pos - n +\r\ntb->rnum[0],\r\n"PAP-12165: directory item must be first item of node when pasting is in 0th position");\r\nreplace_key(tb,\r\ntb->CFR[0],\r\ntb->rkey[0],\r\ntb->R[0],\r\n0);\r\n}\r\n}\r\nif (is_indirect_le_ih(pasted))\r\nset_ih_free_space(pasted, 0);\r\nzeros_num = tb->insert_size[0] = 0;\r\n}\r\n} else {\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\n}\r\nbreak;\r\ndefault:\r\nreiserfs_panic(tb->tb_sb, "PAP-12175",\r\n"rnum > 0: unexpected mode: %s(%d)",\r\n(flag ==\r\nM_DELETE) ? "DELETE" : ((flag ==\r\nM_CUT) ? "CUT"\r\n: "UNKNOWN"),\r\nflag);\r\n}\r\n}\r\nRFALSE(tb->blknum[0] > 3,\r\n"PAP-12180: blknum can not be %d. It must be <= 3",\r\ntb->blknum[0]);\r\nRFALSE(tb->blknum[0] < 0,\r\n"PAP-12185: blknum can not be %d. It must be >= 0",\r\ntb->blknum[0]);\r\nif (tb->blknum[0] == 0) {\r\nRFALSE(!tb->lnum[0] || !tb->rnum[0],\r\n"PAP-12190: lnum and rnum must not be zero");\r\nif (tb->CFL[0]) {\r\nif (!tb->CFR[0])\r\nreiserfs_panic(tb->tb_sb, "vs-12195",\r\n"CFR not initialized");\r\ncopy_key(B_N_PDELIM_KEY(tb->CFL[0], tb->lkey[0]),\r\nB_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0]));\r\ndo_balance_mark_internal_dirty(tb, tb->CFL[0], 0);\r\n}\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nsnum[0] = tb->s1num, snum[1] = tb->s2num;\r\nsbytes[0] = tb->s1bytes;\r\nsbytes[1] = tb->s2bytes;\r\nfor (i = tb->blknum[0] - 2; i >= 0; i--) {\r\nRFALSE(!snum[i], "PAP-12200: snum[%d] == %d. Must be > 0", i,\r\nsnum[i]);\r\nS_new[i] = get_FEB(tb);\r\nset_blkh_level(B_BLK_HEAD(S_new[i]), DISK_LEAF_NODE_LEVEL);\r\nn = B_NR_ITEMS(tbS0);\r\nswitch (flag) {\r\ncase M_INSERT:\r\nif (n - snum[i] < item_pos) {\r\nif (item_pos == n - snum[i] + 1 && sbytes[i] != -1) {\r\nint old_key_comp, old_len,\r\nr_zeros_number;\r\nconst char *r_body;\r\nint version;\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\r\nsnum[i] - 1, -1,\r\nS_new[i]);\r\nversion = ih_version(ih);\r\nold_key_comp = le_ih_k_offset(ih);\r\nold_len = ih_item_len(ih);\r\nset_le_ih_k_offset(ih,\r\nle_ih_k_offset(ih) +\r\n((old_len -\r\nsbytes[i]) <<\r\n(is_indirect_le_ih\r\n(ih) ? tb->tb_sb->\r\ns_blocksize_bits -\r\nUNFM_P_SHIFT :\r\n0)));\r\nput_ih_item_len(ih, sbytes[i]);\r\nbuffer_info_init_bh(tb, &bi, S_new[i]);\r\nif ((old_len - sbytes[i]) > zeros_num) {\r\nr_zeros_number = 0;\r\nr_body =\r\nbody + (old_len -\r\nsbytes[i]) -\r\nzeros_num;\r\n} else {\r\nr_body = body;\r\nr_zeros_number =\r\nzeros_num - (old_len -\r\nsbytes[i]);\r\nzeros_num -= r_zeros_number;\r\n}\r\nleaf_insert_into_buf(&bi, 0, ih, r_body,\r\nr_zeros_number);\r\nset_le_ih_k_offset(ih, old_key_comp);\r\nput_ih_item_len(ih,\r\nold_len - sbytes[i]);\r\ntb->insert_size[0] -= sbytes[i];\r\n} else {\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\r\nsnum[i] - 1, sbytes[i],\r\nS_new[i]);\r\nbuffer_info_init_bh(tb, &bi, S_new[i]);\r\nleaf_insert_into_buf(&bi,\r\nitem_pos - n +\r\nsnum[i] - 1, ih,\r\nbody, zeros_num);\r\nzeros_num = tb->insert_size[0] = 0;\r\n}\r\n}\r\nelse {\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\r\nsnum[i], sbytes[i], S_new[i]);\r\n}\r\nbreak;\r\ncase M_PASTE:\r\nif (n - snum[i] <= item_pos) {\r\nif (item_pos == n - snum[i] && sbytes[i] != -1) {\r\nstruct item_head *aux_ih;\r\nRFALSE(ih, "PAP-12210: ih must be 0");\r\naux_ih = B_N_PITEM_HEAD(tbS0, item_pos);\r\nif (is_direntry_le_ih(aux_ih)) {\r\nint entry_count;\r\nentry_count =\r\nih_entry_count(aux_ih);\r\nif (entry_count - sbytes[i] <\r\npos_in_item\r\n&& pos_in_item <=\r\nentry_count) {\r\nRFALSE(!tb->\r\ninsert_size[0],\r\n"PAP-12215: insert_size is already 0");\r\nRFALSE(sbytes[i] - 1 >=\r\nentry_count,\r\n"PAP-12220: there are no so much entries (%d), only %d",\r\nsbytes[i] - 1,\r\nentry_count);\r\nleaf_move_items\r\n(LEAF_FROM_S_TO_SNEW,\r\ntb, snum[i],\r\nsbytes[i] - 1,\r\nS_new[i]);\r\nbuffer_info_init_bh(tb, &bi, S_new[i]);\r\nleaf_paste_in_buffer\r\n(&bi, 0,\r\npos_in_item -\r\nentry_count +\r\nsbytes[i] - 1,\r\ntb->insert_size[0],\r\nbody, zeros_num);\r\nleaf_paste_entries(&bi,\r\n0,\r\npos_in_item\r\n-\r\nentry_count\r\n+\r\nsbytes\r\n[i] -\r\n1, 1,\r\n(struct\r\nreiserfs_de_head\r\n*)\r\nbody,\r\nbody\r\n+\r\nDEH_SIZE,\r\ntb->\r\ninsert_size\r\n[0]\r\n);\r\ntb->insert_size[0] = 0;\r\npos_in_item++;\r\n} else {\r\nleaf_move_items\r\n(LEAF_FROM_S_TO_SNEW,\r\ntb, snum[i],\r\nsbytes[i],\r\nS_new[i]);\r\n}\r\n} else {\r\nint n_shift, n_rem,\r\nr_zeros_number;\r\nconst char *r_body;\r\nRFALSE(pos_in_item !=\r\nih_item_len\r\n(B_N_PITEM_HEAD\r\n(tbS0, item_pos))\r\n|| tb->insert_size[0] <=\r\n0,\r\n"PAP-12225: item too short or insert_size <= 0");\r\nn_shift =\r\nsbytes[i] -\r\ntb->insert_size[0];\r\nif (n_shift < 0)\r\nn_shift = 0;\r\nleaf_move_items\r\n(LEAF_FROM_S_TO_SNEW, tb,\r\nsnum[i], n_shift,\r\nS_new[i]);\r\nn_rem =\r\ntb->insert_size[0] -\r\nsbytes[i];\r\nif (n_rem < 0)\r\nn_rem = 0;\r\nbuffer_info_init_bh(tb, &bi, S_new[i]);\r\nif (n_rem > zeros_num) {\r\nr_zeros_number = 0;\r\nr_body =\r\nbody + n_rem -\r\nzeros_num;\r\n} else {\r\nr_body = body;\r\nr_zeros_number =\r\nzeros_num - n_rem;\r\nzeros_num -=\r\nr_zeros_number;\r\n}\r\nleaf_paste_in_buffer(&bi, 0,\r\nn_shift,\r\ntb->\r\ninsert_size\r\n[0] -\r\nn_rem,\r\nr_body,\r\nr_zeros_number);\r\n{\r\nstruct item_head *tmp;\r\ntmp =\r\nB_N_PITEM_HEAD(S_new\r\n[i],\r\n0);\r\nif (is_indirect_le_ih\r\n(tmp)) {\r\nset_ih_free_space\r\n(tmp, 0);\r\nset_le_ih_k_offset\r\n(tmp,\r\nle_ih_k_offset\r\n(tmp) +\r\n(n_rem <<\r\n(tb->\r\ntb_sb->\r\ns_blocksize_bits\r\n-\r\nUNFM_P_SHIFT)));\r\n} else {\r\nset_le_ih_k_offset\r\n(tmp,\r\nle_ih_k_offset\r\n(tmp) +\r\nn_rem);\r\n}\r\n}\r\ntb->insert_size[0] = n_rem;\r\nif (!n_rem)\r\npos_in_item++;\r\n}\r\n} else\r\n{\r\nint leaf_mi;\r\nstruct item_head *pasted;\r\n#ifdef CONFIG_REISERFS_CHECK\r\nstruct item_head *ih_check =\r\nB_N_PITEM_HEAD(tbS0, item_pos);\r\nif (!is_direntry_le_ih(ih_check)\r\n&& (pos_in_item != ih_item_len(ih_check)\r\n|| tb->insert_size[0] <= 0))\r\nreiserfs_panic(tb->tb_sb,\r\n"PAP-12235",\r\n"pos_in_item "\r\n"must be equal "\r\n"to ih_item_len");\r\n#endif\r\nleaf_mi =\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW,\r\ntb, snum[i],\r\nsbytes[i],\r\nS_new[i]);\r\nRFALSE(leaf_mi,\r\n"PAP-12240: unexpected value returned by leaf_move_items (%d)",\r\nleaf_mi);\r\nbuffer_info_init_bh(tb, &bi, S_new[i]);\r\nleaf_paste_in_buffer(&bi,\r\nitem_pos - n +\r\nsnum[i],\r\npos_in_item,\r\ntb->insert_size[0],\r\nbody, zeros_num);\r\npasted =\r\nB_N_PITEM_HEAD(S_new[i],\r\nitem_pos - n +\r\nsnum[i]);\r\nif (is_direntry_le_ih(pasted)) {\r\nleaf_paste_entries(&bi,\r\nitem_pos -\r\nn + snum[i],\r\npos_in_item,\r\n1,\r\n(struct\r\nreiserfs_de_head\r\n*)body,\r\nbody +\r\nDEH_SIZE,\r\ntb->\r\ninsert_size\r\n[0]\r\n);\r\n}\r\nif (is_indirect_le_ih(pasted))\r\nset_ih_free_space(pasted, 0);\r\nzeros_num = tb->insert_size[0] = 0;\r\n}\r\n}\r\nelse {\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\r\nsnum[i], sbytes[i], S_new[i]);\r\n}\r\nbreak;\r\ndefault:\r\nreiserfs_panic(tb->tb_sb, "PAP-12245",\r\n"blknum > 2: unexpected mode: %s(%d)",\r\n(flag ==\r\nM_DELETE) ? "DELETE" : ((flag ==\r\nM_CUT) ? "CUT"\r\n: "UNKNOWN"),\r\nflag);\r\n}\r\nmemcpy(insert_key + i, B_N_PKEY(S_new[i], 0), KEY_SIZE);\r\ninsert_ptr[i] = S_new[i];\r\nRFALSE(!buffer_journaled(S_new[i])\r\n|| buffer_journal_dirty(S_new[i])\r\n|| buffer_dirty(S_new[i]), "PAP-12247: S_new[%d] : (%b)",\r\ni, S_new[i]);\r\n}\r\nif (0 <= item_pos && item_pos < tb->s0num) {\r\nswitch (flag) {\r\ncase M_INSERT:\r\nbuffer_info_init_tbS0(tb, &bi);\r\nleaf_insert_into_buf(&bi, item_pos, ih, body,\r\nzeros_num);\r\nif (item_pos == 0) {\r\nif (tb->CFL[0])\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0],\r\ntbS0, 0);\r\n}\r\nbreak;\r\ncase M_PASTE:{\r\nstruct item_head *pasted;\r\npasted = B_N_PITEM_HEAD(tbS0, item_pos);\r\nif (is_direntry_le_ih(pasted)) {\r\nif (pos_in_item >= 0 &&\r\npos_in_item <=\r\nih_entry_count(pasted)) {\r\nRFALSE(!tb->insert_size[0],\r\n"PAP-12260: insert_size is 0 already");\r\nbuffer_info_init_tbS0(tb, &bi);\r\nleaf_paste_in_buffer(&bi,\r\nitem_pos,\r\npos_in_item,\r\ntb->\r\ninsert_size\r\n[0], body,\r\nzeros_num);\r\nleaf_paste_entries(&bi,\r\nitem_pos,\r\npos_in_item,\r\n1,\r\n(struct\r\nreiserfs_de_head\r\n*)body,\r\nbody +\r\nDEH_SIZE,\r\ntb->\r\ninsert_size\r\n[0]\r\n);\r\nif (!item_pos && !pos_in_item) {\r\nRFALSE(!tb->CFL[0]\r\n|| !tb->L[0],\r\n"PAP-12270: CFL[0]/L[0] must be specified");\r\nif (tb->CFL[0]) {\r\nreplace_key(tb,\r\ntb->\r\nCFL\r\n[0],\r\ntb->\r\nlkey\r\n[0],\r\ntbS0,\r\n0);\r\n}\r\n}\r\ntb->insert_size[0] = 0;\r\n}\r\n} else {\r\nif (pos_in_item == ih_item_len(pasted)) {\r\nRFALSE(tb->insert_size[0] <= 0,\r\n"PAP-12275: insert size must not be %d",\r\ntb->insert_size[0]);\r\nbuffer_info_init_tbS0(tb, &bi);\r\nleaf_paste_in_buffer(&bi,\r\nitem_pos,\r\npos_in_item,\r\ntb->\r\ninsert_size\r\n[0], body,\r\nzeros_num);\r\nif (is_indirect_le_ih(pasted)) {\r\n#if 0\r\nRFALSE(tb->\r\ninsert_size[0] !=\r\nUNFM_P_SIZE,\r\n"PAP-12280: insert_size for indirect item must be %d, not %d",\r\nUNFM_P_SIZE,\r\ntb->\r\ninsert_size[0]);\r\n#endif\r\nset_ih_free_space\r\n(pasted, 0);\r\n}\r\ntb->insert_size[0] = 0;\r\n}\r\n#ifdef CONFIG_REISERFS_CHECK\r\nelse {\r\nif (tb->insert_size[0]) {\r\nprint_cur_tb("12285");\r\nreiserfs_panic(tb->\r\ntb_sb,\r\n"PAP-12285",\r\n"insert_size "\r\n"must be 0 "\r\n"(%d)",\r\ntb->insert_size[0]);\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (flag == M_PASTE && tb->insert_size[0]) {\r\nprint_cur_tb("12290");\r\nreiserfs_panic(tb->tb_sb,\r\n"PAP-12290", "insert_size is still not 0 (%d)",\r\ntb->insert_size[0]);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid make_empty_node(struct buffer_info *bi)\r\n{\r\nstruct block_head *blkh;\r\nRFALSE(bi->bi_bh == NULL, "PAP-12295: pointer to the buffer is NULL");\r\nblkh = B_BLK_HEAD(bi->bi_bh);\r\nset_blkh_nr_item(blkh, 0);\r\nset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\r\nif (bi->bi_parent)\r\nB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\r\n}\r\nstruct buffer_head *get_FEB(struct tree_balance *tb)\r\n{\r\nint i;\r\nstruct buffer_info bi;\r\nfor (i = 0; i < MAX_FEB_SIZE; i++)\r\nif (tb->FEB[i] != NULL)\r\nbreak;\r\nif (i == MAX_FEB_SIZE)\r\nreiserfs_panic(tb->tb_sb, "vs-12300", "FEB list is empty");\r\nbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\r\nmake_empty_node(&bi);\r\nset_buffer_uptodate(tb->FEB[i]);\r\ntb->used[i] = tb->FEB[i];\r\ntb->FEB[i] = NULL;\r\nreturn tb->used[i];\r\n}\r\nstatic void store_thrown(struct tree_balance *tb, struct buffer_head *bh)\r\n{\r\nint i;\r\nif (buffer_dirty(bh))\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12320",\r\n"called with dirty buffer");\r\nfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++)\r\nif (!tb->thrown[i]) {\r\ntb->thrown[i] = bh;\r\nget_bh(bh);\r\nreturn;\r\n}\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12321",\r\n"too many thrown buffers");\r\n}\r\nstatic void free_thrown(struct tree_balance *tb)\r\n{\r\nint i;\r\nb_blocknr_t blocknr;\r\nfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {\r\nif (tb->thrown[i]) {\r\nblocknr = tb->thrown[i]->b_blocknr;\r\nif (buffer_dirty(tb->thrown[i]))\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12322",\r\n"called with dirty buffer %d",\r\nblocknr);\r\nbrelse(tb->thrown[i]);\r\nreiserfs_free_block(tb->transaction_handle, NULL,\r\nblocknr, 0);\r\n}\r\n}\r\n}\r\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\r\n{\r\nstruct block_head *blkh;\r\nblkh = B_BLK_HEAD(bh);\r\nset_blkh_level(blkh, FREE_LEVEL);\r\nset_blkh_nr_item(blkh, 0);\r\nclear_buffer_dirty(bh);\r\nstore_thrown(tb, bh);\r\n}\r\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\r\nstruct buffer_head *src, int n_src)\r\n{\r\nRFALSE(dest == NULL || src == NULL,\r\n"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)",\r\nsrc, dest);\r\nRFALSE(!B_IS_KEYS_LEVEL(dest),\r\n"vs-12310: invalid level (%z) for destination buffer. dest must be leaf",\r\ndest);\r\nRFALSE(n_dest < 0 || n_src < 0,\r\n"vs-12315: src(%d) or dest(%d) key number < 0", n_src, n_dest);\r\nRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\r\n"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big",\r\nn_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\r\nif (B_IS_ITEMS_LEVEL(src))\r\nmemcpy(B_N_PDELIM_KEY(dest, n_dest), B_N_PITEM_HEAD(src, n_src),\r\nKEY_SIZE);\r\nelse\r\nmemcpy(B_N_PDELIM_KEY(dest, n_dest), B_N_PDELIM_KEY(src, n_src),\r\nKEY_SIZE);\r\ndo_balance_mark_internal_dirty(tb, dest, 0);\r\n}\r\nint get_left_neighbor_position(struct tree_balance *tb, int h)\r\n{\r\nint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\nRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\r\n"vs-12325: FL[%d](%p) or F[%d](%p) does not exist",\r\nh, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\r\nif (Sh_position == 0)\r\nreturn B_NR_ITEMS(tb->FL[h]);\r\nelse\r\nreturn Sh_position - 1;\r\n}\r\nint get_right_neighbor_position(struct tree_balance *tb, int h)\r\n{\r\nint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\nRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\r\n"vs-12330: F[%d](%p) or FR[%d](%p) does not exist",\r\nh, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\r\nif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\r\nreturn 0;\r\nelse\r\nreturn Sh_position + 1;\r\n}\r\nstatic void check_internal_node(struct super_block *s, struct buffer_head *bh,\r\nchar *mes)\r\n{\r\nstruct disk_child *dc;\r\nint i;\r\nRFALSE(!bh, "PAP-12336: bh == 0");\r\nif (!bh || !B_IS_IN_TREE(bh))\r\nreturn;\r\nRFALSE(!buffer_dirty(bh) &&\r\n!(buffer_journaled(bh) || buffer_journal_dirty(bh)),\r\n"PAP-12337: buffer (%b) must be dirty", bh);\r\ndc = B_N_CHILD(bh, 0);\r\nfor (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {\r\nif (!is_reusable(s, dc_block_number(dc), 1)) {\r\nprint_cur_tb(mes);\r\nreiserfs_panic(s, "PAP-12338",\r\n"invalid child pointer %y in %b",\r\ndc, bh);\r\n}\r\n}\r\n}\r\nstatic int locked_or_not_in_tree(struct tree_balance *tb,\r\nstruct buffer_head *bh, char *which)\r\n{\r\nif ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||\r\n!B_IS_IN_TREE(bh)) {\r\nreiserfs_warning(tb->tb_sb, "vs-12339", "%s (%b)", which, bh);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_before_balancing(struct tree_balance *tb)\r\n{\r\nint retval = 0;\r\nif (REISERFS_SB(tb->tb_sb)->cur_tb) {\r\nreiserfs_panic(tb->tb_sb, "vs-12335", "suspect that schedule "\r\n"occurred based on cur_tb not being null at "\r\n"this point in code. do_balance cannot properly "\r\n"handle concurrent tree accesses on a same "\r\n"mount point.");\r\n}\r\nif (tb->lnum[0]) {\r\nretval |= locked_or_not_in_tree(tb, tb->L[0], "L[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->FL[0], "FL[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->CFL[0], "CFL[0]");\r\ncheck_leaf(tb->L[0]);\r\n}\r\nif (tb->rnum[0]) {\r\nretval |= locked_or_not_in_tree(tb, tb->R[0], "R[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->FR[0], "FR[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->CFR[0], "CFR[0]");\r\ncheck_leaf(tb->R[0]);\r\n}\r\nretval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),\r\n"S[0]");\r\ncheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\r\nreturn retval;\r\n}\r\nstatic void check_after_balance_leaf(struct tree_balance *tb)\r\n{\r\nif (tb->lnum[0]) {\r\nif (B_FREE_SPACE(tb->L[0]) !=\r\nMAX_CHILD_SIZE(tb->L[0]) -\r\ndc_size(B_N_CHILD\r\n(tb->FL[0], get_left_neighbor_position(tb, 0)))) {\r\nprint_cur_tb("12221");\r\nreiserfs_panic(tb->tb_sb, "PAP-12355",\r\n"shift to left was incorrect");\r\n}\r\n}\r\nif (tb->rnum[0]) {\r\nif (B_FREE_SPACE(tb->R[0]) !=\r\nMAX_CHILD_SIZE(tb->R[0]) -\r\ndc_size(B_N_CHILD\r\n(tb->FR[0], get_right_neighbor_position(tb, 0)))) {\r\nprint_cur_tb("12222");\r\nreiserfs_panic(tb->tb_sb, "PAP-12360",\r\n"shift to right was incorrect");\r\n}\r\n}\r\nif (PATH_H_PBUFFER(tb->tb_path, 1) &&\r\n(B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=\r\n(MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\r\ndc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path, 1)))))) {\r\nint left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));\r\nint right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\r\ndc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path,\r\n1))));\r\nprint_cur_tb("12223");\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12363",\r\n"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "\r\n"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",\r\nleft,\r\nMAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),\r\nPATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path, 1),\r\ndc_size(B_N_CHILD\r\n(PATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path, 1))),\r\nright);\r\nreiserfs_panic(tb->tb_sb, "PAP-12365", "S is incorrect");\r\n}\r\n}\r\nstatic void check_leaf_level(struct tree_balance *tb)\r\n{\r\ncheck_leaf(tb->L[0]);\r\ncheck_leaf(tb->R[0]);\r\ncheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\r\n}\r\nstatic void check_internal_levels(struct tree_balance *tb)\r\n{\r\nint h;\r\nfor (h = 1; tb->insert_size[h]; h++) {\r\ncheck_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),\r\n"BAD BUFFER ON PATH");\r\nif (tb->lnum[h])\r\ncheck_internal_node(tb->tb_sb, tb->L[h], "BAD L");\r\nif (tb->rnum[h])\r\ncheck_internal_node(tb->tb_sb, tb->R[h], "BAD R");\r\n}\r\n}\r\nstatic inline void do_balance_starts(struct tree_balance *tb)\r\n{\r\nRFALSE(check_before_balancing(tb), "PAP-12340: locked buffers in TB");\r\n#ifdef CONFIG_REISERFS_CHECK\r\nREISERFS_SB(tb->tb_sb)->cur_tb = tb;\r\n#endif\r\n}\r\nstatic inline void do_balance_completed(struct tree_balance *tb)\r\n{\r\n#ifdef CONFIG_REISERFS_CHECK\r\ncheck_leaf_level(tb);\r\ncheck_internal_levels(tb);\r\nREISERFS_SB(tb->tb_sb)->cur_tb = NULL;\r\n#endif\r\nREISERFS_SB(tb->tb_sb)->s_do_balance++;\r\nunfix_nodes(tb);\r\nfree_thrown(tb);\r\n}\r\nvoid do_balance(struct tree_balance *tb,\r\nstruct item_head *ih,\r\nconst char *body,\r\nint flag)\r\n{\r\nint child_pos,\r\nh;\r\nstruct item_head insert_key[2];\r\nstruct buffer_head *insert_ptr[2];\r\ntb->tb_mode = flag;\r\ntb->need_balance_dirty = 0;\r\nif (FILESYSTEM_CHANGED_TB(tb)) {\r\nreiserfs_panic(tb->tb_sb, "clm-6000", "fs generation has "\r\n"changed");\r\n}\r\nif (!tb->insert_size[0]) {\r\nreiserfs_warning(tb->tb_sb, "PAP-12350",\r\n"insert_size == 0, mode == %c", flag);\r\nunfix_nodes(tb);\r\nreturn;\r\n}\r\natomic_inc(&(fs_generation(tb->tb_sb)));\r\ndo_balance_starts(tb);\r\nchild_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +\r\nbalance_leaf(tb, ih, body, flag, insert_key, insert_ptr);\r\n#ifdef CONFIG_REISERFS_CHECK\r\ncheck_after_balance_leaf(tb);\r\n#endif\r\nfor (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)\r\nchild_pos =\r\nbalance_internal(tb, h, child_pos, insert_key, insert_ptr);\r\ndo_balance_completed(tb);\r\n}
