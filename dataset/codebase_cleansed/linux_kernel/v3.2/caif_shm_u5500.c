static int shmdev_send_msg(u32 dev_id, u32 mbx_msg)\r\n{\r\nmbox_send(shmdev_lyr[dev_id].hmbx, mbx_msg, true);\r\nreturn 0;\r\n}\r\nstatic int shmdev_mbx_setup(void *pshmdrv_cb, struct shmdev_layer *pshm_dev,\r\nvoid *pshm_drv)\r\n{\r\npshm_dev->hmbx = mbox_setup(MBX_ACC0, pshmdrv_cb, pshm_drv);\r\nif (!pshm_dev->hmbx)\r\nreturn -ENODEV;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int __init caif_shmdev_init(void)\r\n{\r\nint i, result;\r\nfor (i = 0; i < MAX_SHM_INSTANCES; i++) {\r\nshmdev_lyr[i].shm_base_addr = shm_start;\r\nshmdev_lyr[i].shm_total_sz = shm_size;\r\nif (((char *)shmdev_lyr[i].shm_base_addr == NULL)\r\n|| (shmdev_lyr[i].shm_total_sz <= 0)) {\r\npr_warn("ERROR,"\r\n"Shared memory Address and/or Size incorrect"\r\n", Bailing out ...\n");\r\nresult = -EINVAL;\r\ngoto clean;\r\n}\r\npr_info("SHM AREA (instance %d) STARTS"\r\n" AT %p\n", i, (char *)shmdev_lyr[i].shm_base_addr);\r\nshmdev_lyr[i].shm_id = i;\r\nshmdev_lyr[i].pshmdev_mbxsend = shmdev_send_msg;\r\nshmdev_lyr[i].pshmdev_mbxsetup = shmdev_mbx_setup;\r\nresult = caif_shmcore_probe(&shmdev_lyr[i]);\r\nif (result) {\r\npr_warn("ERROR[%d],"\r\n"Could not probe SHM core (instance %d)"\r\n" Bailing out ...\n", result, i);\r\ngoto clean;\r\n}\r\n}\r\nreturn 0;\r\nclean:\r\nfor (i = 0; i < MAX_SHM_INSTANCES; i++) {\r\nif (shmdev_lyr[i].pshm_netdev)\r\nunregister_netdev(shmdev_lyr[i].pshm_netdev);\r\n}\r\nreturn result;\r\n}\r\nstatic void __exit caif_shmdev_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_SHM_INSTANCES; i++) {\r\ncaif_shmcore_remove(shmdev_lyr[i].pshm_netdev);\r\nkfree((void *)shmdev_lyr[i].shm_base_addr);\r\n}\r\n}
