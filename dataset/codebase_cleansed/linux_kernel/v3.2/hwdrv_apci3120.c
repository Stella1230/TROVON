int i_APCI3120_InsnConfigAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int i;\r\nif ((data[0] != APCI3120_EOC_MODE) && (data[0] != APCI3120_EOS_MODE))\r\nreturn -1;\r\ndevpriv->ui_EocEosConversionTime = data[2];\r\nif (data[0] == APCI3120_EOS_MODE) {\r\nfor (i = 0; i < data[3]; i++) {\r\nif (CR_CHAN(data[4 + i]) >=\r\ndevpriv->s_EeParameters.i_NbrAiChannel) {\r\nprintk("bad channel list\n");\r\nreturn -2;\r\n}\r\n}\r\ndevpriv->b_InterruptMode = APCI3120_EOS_MODE;\r\nif (data[1])\r\ndevpriv->b_EocEosInterrupt = APCI3120_ENABLE;\r\nelse\r\ndevpriv->b_EocEosInterrupt = APCI3120_DISABLE;\r\ndevpriv->ui_AiNbrofChannels = data[3];\r\nfor (i = 0; i < devpriv->ui_AiNbrofChannels; i++)\r\ndevpriv->ui_AiChannelList[i] = data[4 + i];\r\n} else {\r\ndevpriv->b_InterruptMode = APCI3120_EOC_MODE;\r\nif (data[1])\r\ndevpriv->b_EocEosInterrupt = APCI3120_ENABLE;\r\nelse\r\ndevpriv->b_EocEosInterrupt = APCI3120_DISABLE;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnReadAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned short us_ConvertTiming, us_TmpValue, i;\r\nunsigned char b_Tmp;\r\nif (!devpriv->ui_EocEosConversionTime) {\r\nprintk("No timer0 Value using 10 us\n");\r\nus_ConvertTiming = 10;\r\n} else\r\nus_ConvertTiming = (unsigned short) (devpriv->ui_EocEosConversionTime / 1000);\r\ndevpriv->b_TimerSelectMode = 0;\r\ndevpriv->b_ModeSelectRegister = 0;\r\ndevpriv->us_OutputRegister = 0;\r\nif (insn->unused[0] == 222) {\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ui_AiReadData[i];\r\n} else {\r\ndevpriv->tsk_Current = current;\r\nus_TmpValue =\r\n(unsigned short) inw(devpriv->iobase + APCI3120_RD_STATUS);\r\nif ((us_TmpValue & 0x00B0) == 0x00B0\r\n|| !strcmp(this_board->pc_DriverName, "apci3001")) {\r\nus_ConvertTiming = (us_ConvertTiming * 2) - 2;\r\n} else {\r\nus_ConvertTiming =\r\n((us_ConvertTiming * 12926) / 10000) - 1;\r\n}\r\nus_TmpValue = (unsigned short) devpriv->b_InterruptMode;\r\nswitch (us_TmpValue) {\r\ncase APCI3120_EOC_MODE:\r\ninw(devpriv->iobase + APCI3120_RESET_FIFO);\r\nif (!i_APCI3120_SetupChannelList(dev, s, 1,\r\n&insn->chanspec, 0))\r\nreturn -EINVAL;\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0xFC) |\r\nAPCI3120_TIMER_0_MODE_4;\r\noutb(devpriv->b_TimerSelectMode,\r\ndevpriv->iobase + APCI3120_TIMER_CRT1);\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_SCAN;\r\nif (devpriv->b_EocEosInterrupt == APCI3120_ENABLE) {\r\ndevpriv->b_ModeSelectRegister =\r\n(devpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_EOS_INT) |\r\nAPCI3120_ENABLE_EOC_INT;\r\ninw(devpriv->iobase);\r\n} else {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_ALL_INTERRUPT_WITHOUT_TIMER;\r\n}\r\noutb(devpriv->b_ModeSelectRegister,\r\ndevpriv->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndevpriv->us_OutputRegister =\r\n(devpriv->\r\nus_OutputRegister & APCI3120_CLEAR_PA_PR) |\r\nAPCI3120_ENABLE_TIMER0;\r\noutw(devpriv->us_OutputRegister,\r\ndevpriv->iobase + APCI3120_WR_ADDRESS);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_0_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(us_ConvertTiming,\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\nus_TmpValue =\r\n(unsigned short) inw(dev->iobase + APCI3120_RD_STATUS);\r\nif (devpriv->b_EocEosInterrupt == APCI3120_DISABLE) {\r\ndo {\r\nus_TmpValue =\r\ninw(devpriv->iobase +\r\nAPCI3120_RD_STATUS);\r\n} while ((us_TmpValue & APCI3120_EOC) ==\r\nAPCI3120_EOC);\r\nus_TmpValue = inw(devpriv->iobase + 0);\r\n*data = us_TmpValue;\r\ninw(devpriv->iobase + APCI3120_RESET_FIFO);\r\n}\r\nbreak;\r\ncase APCI3120_EOS_MODE:\r\ninw(devpriv->iobase);\r\ninw(devpriv->iobase + APCI3120_RESET_FIFO);\r\ndevpriv->us_OutputRegister =\r\n(devpriv->\r\nus_OutputRegister & APCI3120_CLEAR_PA_PR) |\r\nAPCI3120_DISABLE_TIMER0;\r\noutw(devpriv->us_OutputRegister,\r\ndevpriv->iobase + APCI3120_WR_ADDRESS);\r\nif (!i_APCI3120_SetupChannelList(dev, s,\r\ndevpriv->ui_AiNbrofChannels,\r\ndevpriv->ui_AiChannelList, 0))\r\nreturn -EINVAL;\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0xFC) |\r\nAPCI3120_TIMER_0_MODE_2;\r\noutb(devpriv->b_TimerSelectMode,\r\ndevpriv->iobase + APCI3120_TIMER_CRT1);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_0_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(us_ConvertTiming,\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister | APCI3120_ENABLE_SCAN;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndevpriv->iobase + APCI3120_WRITE_MODE_SELECT);\r\nif (devpriv->b_EocEosInterrupt == APCI3120_ENABLE) {\r\ndevpriv->b_ModeSelectRegister =\r\n(devpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_EOC_INT) |\r\nAPCI3120_ENABLE_EOS_INT;\r\ninw(devpriv->iobase);\r\n} else\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_ALL_INTERRUPT_WITHOUT_TIMER;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndevpriv->iobase + APCI3120_WRITE_MODE_SELECT);\r\ninw(devpriv->iobase + APCI3120_RD_STATUS);\r\ndevpriv->us_OutputRegister =\r\ndevpriv->\r\nus_OutputRegister | APCI3120_ENABLE_TIMER0;\r\noutw(devpriv->us_OutputRegister,\r\ndevpriv->iobase + APCI3120_WR_ADDRESS);\r\noutw(0, devpriv->iobase + APCI3120_START_CONVERSION);\r\nif (devpriv->b_EocEosInterrupt == APCI3120_DISABLE) {\r\ndo {\r\nus_TmpValue =\r\ninw(devpriv->iobase +\r\nAPCI3120_RD_STATUS);\r\n} while ((us_TmpValue & APCI3120_EOS) !=\r\nAPCI3120_EOS);\r\nfor (i = 0; i < devpriv->ui_AiNbrofChannels;\r\ni++) {\r\nus_TmpValue = inw(devpriv->iobase);\r\ndata[i] = (unsigned int) us_TmpValue;\r\n}\r\ndevpriv->b_InterruptMode = APCI3120_EOC_MODE;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("inputs wrong\n");\r\n}\r\ndevpriv->ui_EocEosConversionTime = 0;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_StopCyclicAcquisition(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\noutw(0, devpriv->i_IobaseAddon + 4);\r\noutw(APCI3120_ADD_ON_AGCSTS_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(0, devpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_AGCSTS_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(0, devpriv->i_IobaseAddon + 2);\r\noutl(0, devpriv->i_IobaseAmcc + AMCC_OP_REG_MCSR);\r\ni_APCI3120_ExttrigDisable(dev);\r\ndevpriv->us_OutputRegister = 0;\r\noutw(devpriv->\r\nus_OutputRegister & APCI3120_DISABLE_TIMER0 &\r\nAPCI3120_DISABLE_TIMER1, dev->iobase + APCI3120_WR_ADDRESS);\r\noutw(APCI3120_DISABLE_ALL_TIMER, dev->iobase + APCI3120_WR_ADDRESS);\r\noutb(APCI3120_DISABLE_ALL_INTERRUPT,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\ninb(dev->iobase + APCI3120_RESET_FIFO);\r\ninw(dev->iobase + APCI3120_RD_STATUS);\r\ndevpriv->ui_AiActualScan = 0;\r\ndevpriv->ui_AiActualScanPosition = 0;\r\ns->async->cur_chan = 0;\r\ndevpriv->ui_AiBufferPtr = 0;\r\ndevpriv->b_AiContinuous = 0;\r\ndevpriv->ui_DmaActualBuffer = 0;\r\ndevpriv->b_AiCyclicAcquisition = APCI3120_DISABLE;\r\ndevpriv->b_InterruptMode = APCI3120_EOC_MODE;\r\ndevpriv->b_EocEosInterrupt = APCI3120_DISABLE;\r\ni_APCI3120_Reset(dev);\r\nreturn 0;\r\n}\r\nint i_APCI3120_CommandTestAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_FOLLOW)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER)\r\nerr++;\r\nif (cmd->scan_end_src != TRIG_COUNT) {\r\ncmd->scan_end_src = TRIG_COUNT;\r\nerr++;\r\n}\r\nif (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg <\r\ndevpriv->s_EeParameters.ui_MinDelaytimeNs) {\r\ncmd->scan_begin_arg =\r\ndevpriv->s_EeParameters.ui_MinDelaytimeNs;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif ((cmd->convert_arg)\r\n&& (cmd->convert_arg <\r\ndevpriv->s_EeParameters.\r\nui_MinAcquisitiontimeNs)) {\r\ncmd->convert_arg = devpriv->s_EeParameters.\r\nui_MinAcquisitiontimeNs;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->convert_arg <\r\ndevpriv->s_EeParameters.ui_MinAcquisitiontimeNs\r\n) {\r\ncmd->convert_arg = devpriv->s_EeParameters.\r\nui_MinAcquisitiontimeNs;\r\nerr++;\r\n}\r\n}\r\n}\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 1;\r\nerr++;\r\n}\r\nif (cmd->chanlist_len > this_board->i_AiChannelList) {\r\ncmd->chanlist_len = this_board->i_AiChannelList;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->scan_begin_arg <\r\ncmd->convert_arg * cmd->scan_end_arg) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg * cmd->scan_end_arg;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nint i_APCI3120_CommandAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\ndevpriv->ui_AiFlags = cmd->flags;\r\ndevpriv->ui_AiNbrofChannels = cmd->chanlist_len;\r\ndevpriv->ui_AiScanLength = cmd->scan_end_arg;\r\ndevpriv->pui_AiChannelList = cmd->chanlist;\r\ndevpriv->AiData = s->async->prealloc_buf;\r\ndevpriv->ui_AiDataLength = s->async->prealloc_bufsz;\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->ui_AiNbrofScans = cmd->stop_arg;\r\nelse\r\ndevpriv->ui_AiNbrofScans = 0;\r\ndevpriv->ui_AiTimer0 = 0;\r\ndevpriv->ui_AiTimer1 = 0;\r\nif ((devpriv->ui_AiNbrofScans == 0) || (devpriv->ui_AiNbrofScans == -1))\r\ndevpriv->b_AiContinuous = 1;\r\nif (cmd->start_src == TRIG_EXT)\r\ndevpriv->b_ExttrigEnable = APCI3120_ENABLE;\r\nelse\r\ndevpriv->b_ExttrigEnable = APCI3120_DISABLE;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ui_AiTimer0 = cmd->convert_arg;\r\nreturn i_APCI3120_CyclicAnalogInput(1, dev, s);\r\n}\r\n}\r\nif ((cmd->scan_begin_src == TRIG_TIMER)\r\n&& (cmd->convert_src == TRIG_TIMER)) {\r\ndevpriv->ui_AiTimer1 = cmd->scan_begin_arg;\r\ndevpriv->ui_AiTimer0 = cmd->convert_arg;\r\nreturn i_APCI3120_CyclicAnalogInput(2, dev, s);\r\n}\r\nreturn -1;\r\n}\r\nint i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned char b_Tmp;\r\nunsigned int ui_Tmp, ui_DelayTiming = 0, ui_TimerValue1 = 0, dmalen0 =\r\n0, dmalen1 = 0, ui_TimerValue2 =\r\n0, ui_TimerValue0, ui_ConvertTiming;\r\nunsigned short us_TmpValue;\r\ninb(dev->iobase + APCI3120_RESET_FIFO);\r\ndevpriv->b_AiCyclicAcquisition = APCI3120_ENABLE;\r\ndevpriv->b_TimerSelectMode = 0;\r\ndevpriv->us_OutputRegister = 0;\r\ndevpriv->b_ModeSelectRegister = 0;\r\noutl(APCI3120_CLEAR_WRITE_TC_INT,\r\ndevpriv->i_IobaseAmcc + APCI3120_AMCC_OP_REG_INTCSR);\r\ndevpriv->us_OutputRegister = devpriv->us_OutputRegister &\r\nAPCI3120_DISABLE_TIMER0 &\r\nAPCI3120_DISABLE_TIMER1 & APCI3120_CLEAR_PA_PR;\r\noutw(devpriv->us_OutputRegister, dev->iobase + APCI3120_WR_ADDRESS);\r\ninb(devpriv->iobase + APCI3120_RESET_FIFO);\r\ndevpriv->ui_AiActualScan = 0;\r\ndevpriv->ui_AiActualScanPosition = 0;\r\ns->async->cur_chan = 0;\r\ndevpriv->ui_AiBufferPtr = 0;\r\ndevpriv->ui_DmaActualBuffer = 0;\r\nui_TimerValue2 = devpriv->ui_AiNbrofScans - 2;\r\nui_ConvertTiming = devpriv->ui_AiTimer0;\r\nif (mode == 2)\r\nui_DelayTiming = devpriv->ui_AiTimer1;\r\nif (!i_APCI3120_SetupChannelList(dev, s, devpriv->ui_AiNbrofChannels,\r\ndevpriv->pui_AiChannelList, 0))\r\nreturn -EINVAL;\r\nus_TmpValue = (unsigned short) inw(dev->iobase + APCI3120_RD_STATUS);\r\nif ((us_TmpValue & 0x00B0) == 0x00B0\r\n|| !strcmp(this_board->pc_DriverName, "apci3001")) {\r\nui_TimerValue0 = ui_ConvertTiming * 2 - 2000;\r\nui_TimerValue0 = ui_TimerValue0 / 1000;\r\nif (mode == 2) {\r\nui_DelayTiming = ui_DelayTiming / 1000;\r\nui_TimerValue1 = ui_DelayTiming * 2 - 200;\r\nui_TimerValue1 = ui_TimerValue1 / 100;\r\n}\r\n} else {\r\nui_ConvertTiming = ui_ConvertTiming / 1000;\r\nui_TimerValue0 = ui_ConvertTiming * 12926 - 10000;\r\nui_TimerValue0 = ui_TimerValue0 / 10000;\r\nif (mode == 2) {\r\nui_DelayTiming = ui_DelayTiming / 1000;\r\nui_TimerValue1 = ui_DelayTiming * 12926 - 1;\r\nui_TimerValue1 = ui_TimerValue1 / 1000000;\r\n}\r\n}\r\nif (devpriv->b_ExttrigEnable == APCI3120_ENABLE)\r\ni_APCI3120_ExttrigEnable(dev);\r\nswitch (mode) {\r\ncase 1:\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0xFC) | APCI3120_TIMER_0_MODE_2;\r\noutb(devpriv->b_TimerSelectMode,\r\ndev->iobase + APCI3120_TIMER_CRT1);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_0_WORD;\r\noutb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);\r\noutw(((unsigned short) ui_TimerValue0),\r\ndev->iobase + APCI3120_TIMER_VALUE);\r\nbreak;\r\ncase 2:\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0xF3) | APCI3120_TIMER_1_MODE_2;\r\noutb(devpriv->b_TimerSelectMode,\r\ndev->iobase + APCI3120_TIMER_CRT1);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_1_WORD;\r\noutb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);\r\noutw(((unsigned short) ui_TimerValue1),\r\ndev->iobase + APCI3120_TIMER_VALUE);\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0xFC) | APCI3120_TIMER_0_MODE_2;\r\noutb(devpriv->b_TimerSelectMode,\r\ndev->iobase + APCI3120_TIMER_CRT1);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_0_WORD;\r\noutb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);\r\noutw(((unsigned short) ui_TimerValue0),\r\ndev->iobase + APCI3120_TIMER_VALUE);\r\nbreak;\r\n}\r\ndevpriv->b_ModeSelectRegister = devpriv->b_ModeSelectRegister &\r\nAPCI3120_DISABLE_SCAN;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\nif (devpriv->us_UseDma == APCI3120_DISABLE) {\r\ndevpriv->b_InterruptMode = APCI3120_EOS_MODE;\r\ndevpriv->b_EocEosInterrupt = APCI3120_ENABLE;\r\ndevpriv->b_ModeSelectRegister =\r\n(devpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_EOC_INT) |\r\nAPCI3120_ENABLE_EOS_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\nif (!devpriv->b_AiContinuous) {\r\ndevpriv->us_OutputRegister =\r\ndevpriv->\r\nus_OutputRegister & APCI3120_DISABLE_TIMER2;\r\noutw(devpriv->us_OutputRegister,\r\ndev->iobase + APCI3120_WR_ADDRESS);\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_TIMER_INT & 0xEF;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0x0F) |\r\nAPCI3120_TIMER_2_MODE_0;\r\noutb(devpriv->b_TimerSelectMode,\r\ndev->iobase + APCI3120_TIMER_CRT1);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_LOW_WORD;\r\noutb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);\r\noutw(LOWORD(ui_TimerValue2),\r\ndev->iobase + APCI3120_TIMER_VALUE);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_HIGH_WORD;\r\noutb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);\r\noutw(HIWORD(ui_TimerValue2),\r\ndev->iobase + APCI3120_TIMER_VALUE);\r\ninb(dev->iobase + APCI3120_TIMER_STATUS_REGISTER);\r\ndevpriv->b_ModeSelectRegister =\r\n(devpriv->\r\nb_ModeSelectRegister |\r\nAPCI3120_ENABLE_TIMER_COUNTER) &\r\nAPCI3120_DISABLE_WATCHDOG;\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister |\r\nAPCI3120_TIMER2_SELECT_EOS;\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister |\r\nAPCI3120_ENABLE_TIMER_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndevpriv->b_Timer2Mode = APCI3120_COUNTER;\r\ndevpriv->b_Timer2Interrupt = APCI3120_ENABLE;\r\n}\r\n} else {\r\ndevpriv->b_InterruptMode = APCI3120_DMA_MODE;\r\ndevpriv->b_ModeSelectRegister = devpriv->b_ModeSelectRegister &\r\nAPCI3120_DISABLE_EOC_INT & APCI3120_DISABLE_EOS_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndmalen0 = devpriv->ui_DmaBufferSize[0];\r\ndmalen1 = devpriv->ui_DmaBufferSize[1];\r\nif (!devpriv->b_AiContinuous) {\r\nif (dmalen0 > (devpriv->ui_AiNbrofScans * devpriv->ui_AiScanLength * 2)) {\r\ndmalen0 =\r\ndevpriv->ui_AiNbrofScans *\r\ndevpriv->ui_AiScanLength * 2;\r\n} else if (dmalen1 > (devpriv->ui_AiNbrofScans * devpriv->ui_AiScanLength * 2 - dmalen0))\r\ndmalen1 =\r\ndevpriv->ui_AiNbrofScans *\r\ndevpriv->ui_AiScanLength * 2 - dmalen0;\r\n}\r\nif (devpriv->ui_AiFlags & TRIG_WAKE_EOS) {\r\nif (dmalen0 > (devpriv->ui_AiScanLength * 2)) {\r\ndmalen0 = devpriv->ui_AiScanLength * 2;\r\nif (devpriv->ui_AiScanLength & 1)\r\ndmalen0 += 2;\r\n}\r\nif (dmalen1 > (devpriv->ui_AiScanLength * 2)) {\r\ndmalen1 = devpriv->ui_AiScanLength * 2;\r\nif (devpriv->ui_AiScanLength & 1)\r\ndmalen1 -= 2;\r\nif (dmalen1 < 4)\r\ndmalen1 = 4;\r\n}\r\n} else {\r\nif (dmalen0 > (devpriv->ui_AiDataLength))\r\ndmalen0 = devpriv->ui_AiDataLength;\r\nif (dmalen1 > (devpriv->ui_AiDataLength))\r\ndmalen1 = devpriv->ui_AiDataLength;\r\n}\r\ndevpriv->ui_DmaBufferUsesize[0] = dmalen0;\r\ndevpriv->ui_DmaBufferUsesize[1] = dmalen1;\r\nui_Tmp = AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO;\r\noutl(ui_Tmp, devpriv->i_IobaseAmcc + AMCC_OP_REG_AGCSTS);\r\noutw(APCI3120_ADD_ON_AGCSTS_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(APCI3120_ENABLE_TRANSFER_ADD_ON_LOW,\r\ndevpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_AGCSTS_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH,\r\ndevpriv->i_IobaseAddon + 2);\r\noutw(0x1000, devpriv->i_IobaseAddon + 2);\r\noutl(APCI3120_A2P_FIFO_MANAGEMENT, devpriv->i_IobaseAmcc +\r\nAPCI3120_AMCC_OP_MCSR);\r\noutw(APCI3120_ADD_ON_MWAR_LOW, devpriv->i_IobaseAddon + 0);\r\noutw((devpriv->ul_DmaBufferHw[0] & 0xFFFF),\r\ndevpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_MWAR_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw((devpriv->ul_DmaBufferHw[0] / 65536),\r\ndevpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_MWTC_LOW, devpriv->i_IobaseAddon + 0);\r\noutw((devpriv->ui_DmaBufferUsesize[0] & 0xFFFF),\r\ndevpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_MWTC_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw((devpriv->ui_DmaBufferUsesize[0] / 65536),\r\ndevpriv->i_IobaseAddon + 2);\r\noutl(0x04000000UL, devpriv->i_IobaseAmcc + AMCC_OP_REG_MCSR);\r\noutl((APCI3120_FIFO_ADVANCE_ON_BYTE_2 |\r\nAPCI3120_ENABLE_WRITE_TC_INT),\r\ndevpriv->i_IobaseAmcc + AMCC_OP_REG_INTCSR);\r\noutw(3, devpriv->i_IobaseAddon + 4);\r\noutl(0x04000000UL,\r\ndevpriv->i_IobaseAmcc + APCI3120_AMCC_OP_MCSR);\r\n}\r\nif ((devpriv->us_UseDma == APCI3120_DISABLE)\r\n&& !devpriv->b_AiContinuous) {\r\ndevpriv->us_OutputRegister =\r\ndevpriv->us_OutputRegister | APCI3120_ENABLE_TIMER2;\r\noutw(devpriv->us_OutputRegister,\r\ndev->iobase + APCI3120_WR_ADDRESS);\r\n}\r\nswitch (mode) {\r\ncase 1:\r\ndevpriv->us_OutputRegister =\r\ndevpriv->us_OutputRegister | APCI3120_ENABLE_TIMER0;\r\noutw(devpriv->us_OutputRegister,\r\ndev->iobase + APCI3120_WR_ADDRESS);\r\nbreak;\r\ncase 2:\r\ndevpriv->us_OutputRegister =\r\ndevpriv->us_OutputRegister | APCI3120_ENABLE_TIMER1;\r\ndevpriv->us_OutputRegister =\r\ndevpriv->us_OutputRegister | APCI3120_ENABLE_TIMER0;\r\noutw(devpriv->us_OutputRegister,\r\ndev->iobase + APCI3120_WR_ADDRESS);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3120_Reset(struct comedi_device *dev)\r\n{\r\nunsigned int i;\r\nunsigned short us_TmpValue;\r\ndevpriv->b_AiCyclicAcquisition = APCI3120_DISABLE;\r\ndevpriv->b_EocEosInterrupt = APCI3120_DISABLE;\r\ndevpriv->b_InterruptMode = APCI3120_EOC_MODE;\r\ndevpriv->ui_EocEosConversionTime = 0;\r\ndevpriv->b_OutputMemoryStatus = 0;\r\ndevpriv->b_Timer2Mode = 0;\r\ndevpriv->b_Timer2Interrupt = 0;\r\ndevpriv->b_ExttrigEnable = 0;\r\ndevpriv->b_ModeSelectRegister = 0;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndevpriv->us_OutputRegister = 0;\r\noutw(devpriv->us_OutputRegister, dev->iobase + APCI3120_WR_ADDRESS);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_1, dev->iobase + APCI3120_ANALOG_OUTPUT_1);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_2, dev->iobase + APCI3120_ANALOG_OUTPUT_1);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_3, dev->iobase + APCI3120_ANALOG_OUTPUT_1);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_4, dev->iobase + APCI3120_ANALOG_OUTPUT_1);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_5, dev->iobase + APCI3120_ANALOG_OUTPUT_2);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_6, dev->iobase + APCI3120_ANALOG_OUTPUT_2);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_7, dev->iobase + APCI3120_ANALOG_OUTPUT_2);\r\noutw(8191 | APCI3120_ANALOG_OP_CHANNEL_8, dev->iobase + APCI3120_ANALOG_OUTPUT_2);\r\nudelay(10);\r\ninw(dev->iobase + 0);\r\ninb(dev->iobase + APCI3120_RESET_FIFO);\r\ninw(dev->iobase + APCI3120_RD_STATUS);\r\nfor (i = 0; i < 16; i++) {\r\nus_TmpValue = i << 8;\r\noutw(us_TmpValue, dev->iobase + APCI3120_SEQ_RAM_ADDRESS);\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3120_SetupChannelList(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint n_chan, unsigned int *chanlist, char check)\r\n{\r\nunsigned int i;\r\nunsigned int gain;\r\nunsigned short us_TmpValue;\r\nif (n_chan < 1) {\r\nif (!check)\r\ncomedi_error(dev, "range/channel list is empty!");\r\nreturn 0;\r\n}\r\nif (check)\r\nreturn 1;\r\ndevpriv->us_OutputRegister =\r\ndevpriv->us_OutputRegister & APCI3120_CLEAR_PA_PR;\r\ndevpriv->us_OutputRegister = ((n_chan - 1) & 0xf) << 8;\r\noutw(devpriv->us_OutputRegister, dev->iobase + APCI3120_WR_ADDRESS);\r\nfor (i = 0; i < n_chan; i++) {\r\nus_TmpValue = CR_CHAN(chanlist[i]);\r\nif (CR_RANGE(chanlist[i]) < APCI3120_BIPOLAR_RANGES)\r\nus_TmpValue &= ((~APCI3120_UNIPOLAR) & 0xff);\r\nelse\r\nus_TmpValue |= APCI3120_UNIPOLAR;\r\ngain = CR_RANGE(chanlist[i]);\r\nus_TmpValue |= ((gain & 0x03) << 4);\r\nus_TmpValue |= i << 8;\r\noutw(us_TmpValue, dev->iobase + APCI3120_SEQ_RAM_ADDRESS);\r\nprintk("\n Gain = %i",\r\n(((unsigned char)CR_RANGE(chanlist[i]) & 0x03) << 2));\r\nprintk("\n Channel = %i", CR_CHAN(chanlist[i]));\r\nprintk("\n Polarity = %i", us_TmpValue & APCI3120_UNIPOLAR);\r\n}\r\nreturn 1;\r\n}\r\nint i_APCI3120_ExttrigEnable(struct comedi_device *dev)\r\n{\r\ndevpriv->us_OutputRegister |= APCI3120_ENABLE_EXT_TRIGGER;\r\noutw(devpriv->us_OutputRegister, dev->iobase + APCI3120_WR_ADDRESS);\r\nreturn 0;\r\n}\r\nint i_APCI3120_ExttrigDisable(struct comedi_device *dev)\r\n{\r\ndevpriv->us_OutputRegister &= ~APCI3120_ENABLE_EXT_TRIGGER;\r\noutw(devpriv->us_OutputRegister, dev->iobase + APCI3120_WR_ADDRESS);\r\nreturn 0;\r\n}\r\nvoid v_APCI3120_Interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned short int_daq;\r\nunsigned int int_amcc, ui_Check, i;\r\nunsigned short us_TmpValue;\r\nunsigned char b_DummyRead;\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nui_Check = 1;\r\nint_daq = inw(dev->iobase + APCI3120_RD_STATUS) & 0xf000;\r\nint_amcc = inl(devpriv->i_IobaseAmcc + AMCC_OP_REG_INTCSR);\r\nif ((!int_daq) && (!(int_amcc & ANY_S593X_INT))) {\r\ncomedi_error(dev, "IRQ from unknown source");\r\nreturn;\r\n}\r\noutl(int_amcc | 0x00ff0000, devpriv->i_IobaseAmcc + AMCC_OP_REG_INTCSR);\r\nint_daq = (int_daq >> 12) & 0xF;\r\nif (devpriv->b_ExttrigEnable == APCI3120_ENABLE) {\r\ni_APCI3120_ExttrigDisable(dev);\r\ndevpriv->b_ExttrigEnable = APCI3120_DISABLE;\r\n}\r\ninb(devpriv->i_IobaseAmcc + APCI3120_TIMER_STATUS_REGISTER);\r\nif (int_amcc & MASTER_ABORT_INT)\r\ncomedi_error(dev, "AMCC IRQ - MASTER DMA ABORT!");\r\nif (int_amcc & TARGET_ABORT_INT)\r\ncomedi_error(dev, "AMCC IRQ - TARGET DMA ABORT!");\r\nif (((int_daq & 0x8) == 0)\r\n&& (devpriv->b_InterruptMode == APCI3120_EOC_MODE)) {\r\nif (devpriv->b_EocEosInterrupt == APCI3120_ENABLE) {\r\ndevpriv->ui_AiReadData[0] =\r\n(unsigned int) inw(devpriv->iobase + 0);\r\ndevpriv->b_EocEosInterrupt = APCI3120_DISABLE;\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\n} else {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_EOC_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndevpriv->iobase + APCI3120_WRITE_MODE_SELECT);\r\n}\r\n}\r\nif ((int_daq & 0x2) && (devpriv->b_InterruptMode == APCI3120_EOS_MODE)) {\r\nif (devpriv->b_EocEosInterrupt == APCI3120_ENABLE) {\r\nif (devpriv->b_AiCyclicAcquisition == APCI3120_ENABLE) {\r\nui_Check = 0;\r\ni_APCI3120_InterruptHandleEos(dev);\r\ndevpriv->ui_AiActualScan++;\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister |\r\nAPCI3120_ENABLE_EOS_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase +\r\nAPCI3120_WRITE_MODE_SELECT);\r\n} else {\r\nui_Check = 0;\r\nfor (i = 0; i < devpriv->ui_AiNbrofChannels;\r\ni++) {\r\nus_TmpValue = inw(devpriv->iobase + 0);\r\ndevpriv->ui_AiReadData[i] =\r\n(unsigned int) us_TmpValue;\r\n}\r\ndevpriv->b_EocEosInterrupt = APCI3120_DISABLE;\r\ndevpriv->b_InterruptMode = APCI3120_EOC_MODE;\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\n}\r\n} else {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_EOS_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndevpriv->b_EocEosInterrupt = APCI3120_DISABLE;\r\ndevpriv->b_InterruptMode = APCI3120_EOC_MODE;\r\n}\r\n}\r\nif (int_daq & 0x1) {\r\nswitch (devpriv->b_Timer2Mode) {\r\ncase APCI3120_COUNTER:\r\ndevpriv->b_AiCyclicAcquisition = APCI3120_DISABLE;\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_EOS_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndevpriv->us_OutputRegister =\r\ndevpriv->\r\nus_OutputRegister & APCI3120_DISABLE_ALL_TIMER;\r\noutw(devpriv->us_OutputRegister,\r\ndev->iobase + APCI3120_WR_ADDRESS);\r\ni_APCI3120_StopCyclicAcquisition(dev, s);\r\ndevpriv->b_AiCyclicAcquisition = APCI3120_DISABLE;\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nbreak;\r\ncase APCI3120_TIMER:\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\nbreak;\r\ncase APCI3120_WATCHDOG:\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\nbreak;\r\ndefault:\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_TIMER_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndev->iobase + APCI3120_WRITE_MODE_SELECT);\r\n}\r\nb_DummyRead = inb(dev->iobase + APCI3120_TIMER_STATUS_REGISTER);\r\n}\r\nif ((int_daq & 0x4) && (devpriv->b_InterruptMode == APCI3120_DMA_MODE)) {\r\nif (devpriv->b_AiCyclicAcquisition == APCI3120_ENABLE) {\r\noutl(APCI3120_CLEAR_WRITE_TC_INT,\r\ndevpriv->i_IobaseAmcc +\r\nAPCI3120_AMCC_OP_REG_INTCSR);\r\ninw(dev->iobase + APCI3120_TIMER_STATUS_REGISTER);\r\nv_APCI3120_InterruptDma(irq, d);\r\n} else {\r\noutw(devpriv->\r\nus_OutputRegister & APCI3120_DISABLE_TIMER0 &\r\nAPCI3120_DISABLE_TIMER1,\r\ndev->iobase + APCI3120_WR_ADDRESS);\r\n}\r\n}\r\nreturn;\r\n}\r\nint i_APCI3120_InterruptHandleEos(struct comedi_device *dev)\r\n{\r\nint n_chan, i;\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nint err = 1;\r\nn_chan = devpriv->ui_AiNbrofChannels;\r\ns->async->events = 0;\r\nfor (i = 0; i < n_chan; i++)\r\nerr &= comedi_buf_put(s->async, inw(dev->iobase + 0));\r\ns->async->events |= COMEDI_CB_EOS;\r\nif (err == 0)\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\ncomedi_event(dev, s);\r\nreturn 0;\r\n}\r\nvoid v_APCI3120_InterruptDma(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nunsigned int next_dma_buf, samplesinbuf;\r\nunsigned long low_word, high_word, var;\r\nunsigned int ui_Tmp;\r\nsamplesinbuf =\r\ndevpriv->ui_DmaBufferUsesize[devpriv->ui_DmaActualBuffer] -\r\ninl(devpriv->i_IobaseAmcc + AMCC_OP_REG_MWTC);\r\nif (samplesinbuf <\r\ndevpriv->ui_DmaBufferUsesize[devpriv->ui_DmaActualBuffer]) {\r\ncomedi_error(dev, "Interrupted DMA transfer!");\r\n}\r\nif (samplesinbuf & 1) {\r\ncomedi_error(dev, "Odd count of bytes in DMA ring!");\r\ni_APCI3120_StopCyclicAcquisition(dev, s);\r\ndevpriv->b_AiCyclicAcquisition = APCI3120_DISABLE;\r\nreturn;\r\n}\r\nsamplesinbuf = samplesinbuf >> 1;\r\nif (devpriv->b_DmaDoubleBuffer) {\r\nnext_dma_buf = 1 - devpriv->ui_DmaActualBuffer;\r\nui_Tmp = AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO;\r\noutl(ui_Tmp, devpriv->i_IobaseAddon + AMCC_OP_REG_AGCSTS);\r\noutw(APCI3120_ADD_ON_AGCSTS_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(APCI3120_ENABLE_TRANSFER_ADD_ON_LOW,\r\ndevpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_AGCSTS_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH, devpriv->i_IobaseAddon + 2);\r\nvar = devpriv->ul_DmaBufferHw[next_dma_buf];\r\nlow_word = var & 0xffff;\r\nvar = devpriv->ul_DmaBufferHw[next_dma_buf];\r\nhigh_word = var / 65536;\r\noutw(APCI3120_ADD_ON_MWAR_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(low_word, devpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_MWAR_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(high_word, devpriv->i_IobaseAddon + 2);\r\nvar = devpriv->ui_DmaBufferUsesize[next_dma_buf];\r\nlow_word = var & 0xffff;\r\nvar = devpriv->ui_DmaBufferUsesize[next_dma_buf];\r\nhigh_word = var / 65536;\r\noutw(APCI3120_ADD_ON_MWTC_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(low_word, devpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_MWTC_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(high_word, devpriv->i_IobaseAddon + 2);\r\noutw(3, devpriv->i_IobaseAddon + 4);\r\noutl((APCI3120_FIFO_ADVANCE_ON_BYTE_2 |\r\nAPCI3120_ENABLE_WRITE_TC_INT),\r\ndevpriv->i_IobaseAmcc + AMCC_OP_REG_INTCSR);\r\n}\r\nif (samplesinbuf) {\r\nv_APCI3120_InterruptDmaMoveBlock16bit(dev, s,\r\ndevpriv->ul_DmaBufferVirtual[devpriv->\r\nui_DmaActualBuffer], samplesinbuf);\r\nif (!(devpriv->ui_AiFlags & TRIG_WAKE_EOS)) {\r\ns->async->events |= COMEDI_CB_EOS;\r\ncomedi_event(dev, s);\r\n}\r\n}\r\nif (!devpriv->b_AiContinuous)\r\nif (devpriv->ui_AiActualScan >= devpriv->ui_AiNbrofScans) {\r\ni_APCI3120_StopCyclicAcquisition(dev, s);\r\ndevpriv->b_AiCyclicAcquisition = APCI3120_DISABLE;\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nif (devpriv->b_DmaDoubleBuffer) {\r\ndevpriv->ui_DmaActualBuffer = 1 - devpriv->ui_DmaActualBuffer;\r\n} else {\r\nui_Tmp = AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO;\r\noutl(ui_Tmp, devpriv->i_IobaseAddon + AMCC_OP_REG_AGCSTS);\r\noutw(APCI3120_ADD_ON_AGCSTS_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(APCI3120_ENABLE_TRANSFER_ADD_ON_LOW,\r\ndevpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_AGCSTS_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH, devpriv->i_IobaseAddon + 2);\r\noutl(APCI3120_A2P_FIFO_MANAGEMENT,\r\ndevpriv->i_IobaseAmcc + AMCC_OP_REG_MCSR);\r\nvar = devpriv->ul_DmaBufferHw[0];\r\nlow_word = var & 0xffff;\r\nvar = devpriv->ul_DmaBufferHw[0];\r\nhigh_word = var / 65536;\r\noutw(APCI3120_ADD_ON_MWAR_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(low_word, devpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_MWAR_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(high_word, devpriv->i_IobaseAddon + 2);\r\nvar = devpriv->ui_DmaBufferUsesize[0];\r\nlow_word = var & 0xffff;\r\nvar = devpriv->ui_DmaBufferUsesize[0];\r\nhigh_word = var / 65536;\r\noutw(APCI3120_ADD_ON_MWTC_LOW, devpriv->i_IobaseAddon + 0);\r\noutw(low_word, devpriv->i_IobaseAddon + 2);\r\noutw(APCI3120_ADD_ON_MWTC_HIGH, devpriv->i_IobaseAddon + 0);\r\noutw(high_word, devpriv->i_IobaseAddon + 2);\r\noutw(3, devpriv->i_IobaseAddon + 4);\r\noutl((APCI3120_FIFO_ADVANCE_ON_BYTE_2 |\r\nAPCI3120_ENABLE_WRITE_TC_INT),\r\ndevpriv->i_IobaseAmcc + AMCC_OP_REG_INTCSR);\r\n}\r\n}\r\nvoid v_APCI3120_InterruptDmaMoveBlock16bit(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, short *dma_buffer, unsigned int num_samples)\r\n{\r\ndevpriv->ui_AiActualScan +=\r\n(s->async->cur_chan + num_samples) / devpriv->ui_AiScanLength;\r\ns->async->cur_chan += num_samples;\r\ns->async->cur_chan %= devpriv->ui_AiScanLength;\r\ncfc_write_array_to_buffer(s, dma_buffer, num_samples * sizeof(short));\r\n}\r\nint i_APCI3120_InsnConfigTimer(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Timervalue2;\r\nunsigned short us_TmpValue;\r\nunsigned char b_Tmp;\r\nif (!data[1])\r\ncomedi_error(dev, "config:No timer constant !");\r\ndevpriv->b_Timer2Interrupt = (unsigned char) data[2];\r\nui_Timervalue2 = data[1] / 1000;\r\nus_TmpValue = (unsigned short) inw(devpriv->iobase + APCI3120_RD_STATUS);\r\nif ((us_TmpValue & 0x00B0) == 0x00B0\r\n|| !strcmp(this_board->pc_DriverName, "apci3001")) {\r\nui_Timervalue2 = ui_Timervalue2 / 50;\r\n} else {\r\nui_Timervalue2 = ui_Timervalue2 / 70;\r\n}\r\ndevpriv->us_OutputRegister =\r\ndevpriv->us_OutputRegister & APCI3120_DISABLE_TIMER2;\r\noutw(devpriv->us_OutputRegister, devpriv->iobase + APCI3120_WR_ADDRESS);\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_TIMER_INT & 0xEF;\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_EOC_INT &\r\nAPCI3120_DISABLE_EOS_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndevpriv->iobase + APCI3120_WRITE_MODE_SELECT);\r\nif (data[0] == APCI3120_TIMER) {\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0x0F) | APCI3120_TIMER_2_MODE_2;\r\noutb(devpriv->b_TimerSelectMode,\r\ndevpriv->iobase + APCI3120_TIMER_CRT1);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_LOW_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(LOWORD(ui_Timervalue2),\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_HIGH_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(HIWORD(ui_Timervalue2),\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\ndevpriv->b_Timer2Mode = APCI3120_TIMER;\r\n} else {\r\ndevpriv->b_TimerSelectMode =\r\n(devpriv->\r\nb_TimerSelectMode & 0x0F) | APCI3120_TIMER_2_MODE_5;\r\noutb(devpriv->b_TimerSelectMode,\r\ndevpriv->iobase + APCI3120_TIMER_CRT1);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_LOW_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(LOWORD(ui_Timervalue2),\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_HIGH_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(HIWORD(ui_Timervalue2),\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\ndevpriv->b_Timer2Mode = APCI3120_WATCHDOG;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnWriteTimer(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Timervalue2 = 0;\r\nunsigned short us_TmpValue;\r\nunsigned char b_Tmp;\r\nif ((devpriv->b_Timer2Mode != APCI3120_WATCHDOG)\r\n&& (devpriv->b_Timer2Mode != APCI3120_TIMER)) {\r\ncomedi_error(dev, "\nwrite:timer2 not configured ");\r\nreturn -EINVAL;\r\n}\r\nif (data[0] == 2) {\r\nif (devpriv->b_Timer2Mode != APCI3120_TIMER) {\r\ncomedi_error(dev,\r\n"write :timer2 not configured in TIMER MODE");\r\nreturn -EINVAL;\r\n}\r\nif (data[1])\r\nui_Timervalue2 = data[1];\r\nelse\r\nui_Timervalue2 = 0;\r\n}\r\nswitch (data[0]) {\r\ncase APCI3120_START:\r\ninb(devpriv->iobase + APCI3120_TIMER_STATUS_REGISTER);\r\nif (devpriv->b_Timer2Mode == APCI3120_TIMER) {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->b_ModeSelectRegister & 0x0B;\r\n} else {\r\ndevpriv->b_ModeSelectRegister =\r\n(devpriv->\r\nb_ModeSelectRegister & 0x0B) |\r\nAPCI3120_ENABLE_WATCHDOG;\r\n}\r\nif ((devpriv->b_Timer2Interrupt) == APCI3120_ENABLE) {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister |\r\nAPCI3120_ENABLE_TIMER_INT;\r\ndevpriv->tsk_Current = current;\r\n} else {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_TIMER_INT;\r\n}\r\noutb(devpriv->b_ModeSelectRegister,\r\ndevpriv->iobase + APCI3120_WRITE_MODE_SELECT);\r\nif (devpriv->b_Timer2Mode == APCI3120_TIMER) {\r\ndevpriv->us_OutputRegister =\r\ndevpriv->\r\nus_OutputRegister | APCI3120_ENABLE_TIMER2;\r\noutw(devpriv->us_OutputRegister,\r\ndevpriv->iobase + APCI3120_WR_ADDRESS);\r\n}\r\nbreak;\r\ncase APCI3120_STOP:\r\nif (devpriv->b_Timer2Mode == APCI3120_TIMER) {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_TIMER_COUNTER;\r\n} else {\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister &\r\nAPCI3120_DISABLE_WATCHDOG;\r\n}\r\ndevpriv->b_ModeSelectRegister =\r\ndevpriv->\r\nb_ModeSelectRegister & APCI3120_DISABLE_TIMER_INT;\r\noutb(devpriv->b_ModeSelectRegister,\r\ndevpriv->iobase + APCI3120_WRITE_MODE_SELECT);\r\ndevpriv->us_OutputRegister =\r\ndevpriv->us_OutputRegister & APCI3120_DISABLE_TIMER_INT;\r\noutw(devpriv->us_OutputRegister,\r\ndevpriv->iobase + APCI3120_WR_ADDRESS);\r\ninb(devpriv->iobase + APCI3120_TIMER_STATUS_REGISTER);\r\nbreak;\r\ncase 2:\r\nif (devpriv->b_Timer2Mode != APCI3120_TIMER) {\r\ncomedi_error(dev,\r\n"write :timer2 not configured in TIMER MODE");\r\nreturn -EINVAL;\r\n}\r\nus_TmpValue =\r\n(unsigned short) inw(devpriv->iobase + APCI3120_RD_STATUS);\r\nif ((us_TmpValue & 0x00B0) == 0x00B0\r\n|| !strcmp(this_board->pc_DriverName, "apci3001")) {\r\nui_Timervalue2 = ui_Timervalue2 / 50;\r\n} else {\r\nui_Timervalue2 = ui_Timervalue2 / 70;\r\n}\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_LOW_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(LOWORD(ui_Timervalue2),\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_HIGH_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\noutw(HIWORD(ui_Timervalue2),\r\ndevpriv->iobase + APCI3120_TIMER_VALUE);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnReadTimer(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned char b_Tmp;\r\nunsigned short us_TmpValue, us_TmpValue_2, us_StatusValue;\r\nif ((devpriv->b_Timer2Mode != APCI3120_WATCHDOG)\r\n&& (devpriv->b_Timer2Mode != APCI3120_TIMER)) {\r\ncomedi_error(dev, "\nread:timer2 not configured ");\r\n}\r\nif (devpriv->b_Timer2Mode == APCI3120_TIMER) {\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_LOW_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\nus_TmpValue = inw(devpriv->iobase + APCI3120_TIMER_VALUE);\r\nb_Tmp = ((devpriv->\r\nb_DigitalOutputRegister) & 0xF0) |\r\nAPCI3120_SELECT_TIMER_2_HIGH_WORD;\r\noutb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);\r\nus_TmpValue_2 = inw(devpriv->iobase + APCI3120_TIMER_VALUE);\r\ndata[0] = (unsigned int) ((us_TmpValue) | ((us_TmpValue_2) << 16));\r\n} else {\r\nus_StatusValue = inw(devpriv->iobase + APCI3120_RD_STATUS);\r\nus_StatusValue =\r\n((us_StatusValue & APCI3120_FC_TIMER) >> 12) & 1;\r\nif (us_StatusValue == 1) {\r\ninb(devpriv->iobase + APCI3120_TIMER_STATUS_REGISTER);\r\n}\r\ndata[0] = us_StatusValue;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnReadDigitalInput(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int ui_Chan, ui_TmpValue;\r\nui_Chan = CR_CHAN(insn->chanspec);\r\nif (ui_Chan <= 3) {\r\nui_TmpValue = (unsigned int) inw(devpriv->iobase + APCI3120_RD_STATUS);\r\n*data = (ui_TmpValue >> (ui_Chan + 8)) & 1;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnBitsDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_TmpValue;\r\nui_TmpValue = (unsigned int) inw(devpriv->iobase + APCI3120_RD_STATUS);\r\n*data = (ui_TmpValue >> 8) & 0xf;\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnConfigDigitalOutput(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)\r\n{\r\nif ((data[0] != 0) && (data[0] != 1)) {\r\ncomedi_error(dev,\r\n"Not a valid Data !!! ,Data should be 1 or 0\n");\r\nreturn -EINVAL;\r\n}\r\nif (data[0]) {\r\ndevpriv->b_OutputMemoryStatus = APCI3120_ENABLE;\r\n} else {\r\ndevpriv->b_OutputMemoryStatus = APCI3120_DISABLE;\r\ndevpriv->b_DigitalOutputRegister = 0;\r\n}\r\nif (!devpriv->b_OutputMemoryStatus)\r\nui_Temp = 0;\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnBitsDigitalOutput(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif ((data[0] > devpriv->s_EeParameters.i_DoMaxdata) || (data[0] < 0)) {\r\ncomedi_error(dev, "Data is not valid !!! \n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[1]) {\r\ncase 1:\r\ndata[0] = (data[0] << 4) | devpriv->b_DigitalOutputRegister;\r\nbreak;\r\ncase 2:\r\ndata[0] = data[0];\r\nbreak;\r\ndefault:\r\nprintk("\nThe parameter passed is in error \n");\r\nreturn -EINVAL;\r\n}\r\noutb(data[0], devpriv->iobase + APCI3120_DIGITAL_OUTPUT);\r\ndevpriv->b_DigitalOutputRegister = data[0] & 0xF0;\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnWriteDigitalOutput(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int ui_Temp1;\r\nunsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);\r\nif ((data[0] != 0) && (data[0] != 1)) {\r\ncomedi_error(dev,\r\n"Not a valid Data !!! ,Data should be 1 or 0\n");\r\nreturn -EINVAL;\r\n}\r\nif (ui_NoOfChannel > devpriv->s_EeParameters.i_NbrDoChannel - 1) {\r\ncomedi_error(dev,\r\n"This board doesn't have specified channel !!! \n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[1]) {\r\ncase 1:\r\ndata[0] = (data[0] << ui_NoOfChannel);\r\ndata[0] = (data[0] << 4) | devpriv->b_DigitalOutputRegister;\r\nbreak;\r\ncase 2:\r\ndata[0] = ~data[0] & 0x1;\r\nui_Temp1 = 1;\r\nui_Temp1 = ui_Temp1 << ui_NoOfChannel;\r\nui_Temp1 = ui_Temp1 << 4;\r\ndevpriv->b_DigitalOutputRegister =\r\ndevpriv->b_DigitalOutputRegister | ui_Temp1;\r\ndata[0] = (data[0] << ui_NoOfChannel) ^ 0xf;\r\ndata[0] = data[0] << 4;\r\ndata[0] = data[0] & devpriv->b_DigitalOutputRegister;\r\nbreak;\r\ndefault:\r\nprintk("\nThe parameter passed is in error \n");\r\nreturn -EINVAL;\r\n}\r\noutb(data[0], devpriv->iobase + APCI3120_DIGITAL_OUTPUT);\r\ndevpriv->b_DigitalOutputRegister = data[0] & 0xf0;\r\nreturn insn->n;\r\n}\r\nint i_APCI3120_InsnWriteAnalogOutput(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int ui_Range, ui_Channel;\r\nunsigned short us_TmpValue;\r\nui_Range = CR_RANGE(insn->chanspec);\r\nui_Channel = CR_CHAN(insn->chanspec);\r\nif (ui_Range) {\r\nif (data[0] != 0)\r\ndata[0] =\r\n((((ui_Channel & 0x03) << 14) & 0xC000) | (1 <<\r\n13) | (data[0] + 8191));\r\nelse\r\ndata[0] =\r\n((((ui_Channel & 0x03) << 14) & 0xC000) | (1 <<\r\n13) | 8192);\r\n} else {\r\ndata[0] =\r\n((((ui_Channel & 0x03) << 14) & 0xC000) | (0 << 13) |\r\ndata[0]);\r\n}\r\ndo {\r\nus_TmpValue =\r\n((unsigned short) inw(devpriv->iobase +\r\nAPCI3120_RD_STATUS)) & 0x0001;\r\n} while (us_TmpValue != 0x0001);\r\nif (ui_Channel <= 3)\r\noutw((unsigned short) data[0],\r\ndevpriv->iobase + APCI3120_ANALOG_OUTPUT_1);\r\nelse\r\noutw((unsigned short) data[0],\r\ndevpriv->iobase + APCI3120_ANALOG_OUTPUT_2);\r\nreturn insn->n;\r\n}
