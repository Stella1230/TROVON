void ax25_ds_setup_timer(ax25_dev *ax25_dev)\r\n{\r\nsetup_timer(&ax25_dev->dama.slave_timer, ax25_ds_timeout,\r\n(unsigned long)ax25_dev);\r\n}\r\nvoid ax25_ds_del_timer(ax25_dev *ax25_dev)\r\n{\r\nif (ax25_dev)\r\ndel_timer(&ax25_dev->dama.slave_timer);\r\n}\r\nvoid ax25_ds_set_timer(ax25_dev *ax25_dev)\r\n{\r\nif (ax25_dev == NULL)\r\nreturn;\r\nax25_dev->dama.slave_timeout =\r\nmsecs_to_jiffies(ax25_dev->values[AX25_VALUES_DS_TIMEOUT]) / 10;\r\nmod_timer(&ax25_dev->dama.slave_timer, jiffies + HZ);\r\n}\r\nstatic void ax25_ds_timeout(unsigned long arg)\r\n{\r\nax25_dev *ax25_dev = (struct ax25_dev *) arg;\r\nax25_cb *ax25;\r\nstruct hlist_node *node;\r\nif (ax25_dev == NULL || !ax25_dev->dama.slave)\r\nreturn;\r\nif (!ax25_dev->dama.slave_timeout || --ax25_dev->dama.slave_timeout) {\r\nax25_ds_set_timer(ax25_dev);\r\nreturn;\r\n}\r\nspin_lock(&ax25_list_lock);\r\nax25_for_each(ax25, node, &ax25_list) {\r\nif (ax25->ax25_dev != ax25_dev || !(ax25->condition & AX25_COND_DAMA_MODE))\r\ncontinue;\r\nax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\r\nax25_disconnect(ax25, ETIMEDOUT);\r\n}\r\nspin_unlock(&ax25_list_lock);\r\nax25_dev_dama_off(ax25_dev);\r\n}\r\nvoid ax25_ds_heartbeat_expiry(ax25_cb *ax25)\r\n{\r\nstruct sock *sk=ax25->sk;\r\nif (sk)\r\nbh_lock_sock(sk);\r\nswitch (ax25->state) {\r\ncase AX25_STATE_0:\r\nif (!sk || sock_flag(sk, SOCK_DESTROY) ||\r\n(sk->sk_state == TCP_LISTEN &&\r\nsock_flag(sk, SOCK_DEAD))) {\r\nif (sk) {\r\nsock_hold(sk);\r\nax25_destroy_socket(ax25);\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n} else\r\nax25_destroy_socket(ax25);\r\nreturn;\r\n}\r\nbreak;\r\ncase AX25_STATE_3:\r\nif (sk != NULL) {\r\nif (atomic_read(&sk->sk_rmem_alloc) <\r\n(sk->sk_rcvbuf >> 1) &&\r\n(ax25->condition & AX25_COND_OWN_RX_BUSY)) {\r\nax25->condition &= ~AX25_COND_OWN_RX_BUSY;\r\nax25->condition &= ~AX25_COND_ACK_PENDING;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nif (sk)\r\nbh_unlock_sock(sk);\r\nax25_start_heartbeat(ax25);\r\n}\r\nvoid ax25_ds_t3timer_expiry(ax25_cb *ax25)\r\n{\r\nax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\r\nax25_dama_off(ax25);\r\nax25_disconnect(ax25, ETIMEDOUT);\r\n}\r\nvoid ax25_ds_idletimer_expiry(ax25_cb *ax25)\r\n{\r\nax25_clear_queues(ax25);\r\nax25->n2count = 0;\r\nax25->state = AX25_STATE_2;\r\nax25_calculate_t1(ax25);\r\nax25_start_t1timer(ax25);\r\nax25_stop_t3timer(ax25);\r\nif (ax25->sk != NULL) {\r\nbh_lock_sock(ax25->sk);\r\nax25->sk->sk_state = TCP_CLOSE;\r\nax25->sk->sk_err = 0;\r\nax25->sk->sk_shutdown |= SEND_SHUTDOWN;\r\nif (!sock_flag(ax25->sk, SOCK_DEAD)) {\r\nax25->sk->sk_state_change(ax25->sk);\r\nsock_set_flag(ax25->sk, SOCK_DEAD);\r\n}\r\nbh_unlock_sock(ax25->sk);\r\n}\r\n}\r\nvoid ax25_ds_t1_timeout(ax25_cb *ax25)\r\n{\r\nswitch (ax25->state) {\r\ncase AX25_STATE_1:\r\nif (ax25->n2count == ax25->n2) {\r\nif (ax25->modulus == AX25_MODULUS) {\r\nax25_disconnect(ax25, ETIMEDOUT);\r\nreturn;\r\n} else {\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\r\nax25->n2count = 0;\r\nax25_send_control(ax25, AX25_SABM, AX25_POLLOFF, AX25_COMMAND);\r\n}\r\n} else {\r\nax25->n2count++;\r\nif (ax25->modulus == AX25_MODULUS)\r\nax25_send_control(ax25, AX25_SABM, AX25_POLLOFF, AX25_COMMAND);\r\nelse\r\nax25_send_control(ax25, AX25_SABME, AX25_POLLOFF, AX25_COMMAND);\r\n}\r\nbreak;\r\ncase AX25_STATE_2:\r\nif (ax25->n2count == ax25->n2) {\r\nax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\r\nax25_disconnect(ax25, ETIMEDOUT);\r\nreturn;\r\n} else {\r\nax25->n2count++;\r\n}\r\nbreak;\r\ncase AX25_STATE_3:\r\nif (ax25->n2count == ax25->n2) {\r\nax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);\r\nax25_disconnect(ax25, ETIMEDOUT);\r\nreturn;\r\n} else {\r\nax25->n2count++;\r\n}\r\nbreak;\r\n}\r\nax25_calculate_t1(ax25);\r\nax25_start_t1timer(ax25);\r\n}
