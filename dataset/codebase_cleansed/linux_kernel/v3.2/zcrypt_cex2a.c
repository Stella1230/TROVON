static int ICAMEX_msg_to_type50MEX_msg(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nunsigned char *mod, *exp, *inp;\r\nint mod_len;\r\nmod_len = mex->inputdatalength;\r\nif (mod_len <= 128) {\r\nstruct type50_meb1_msg *meb1 = ap_msg->message;\r\nmemset(meb1, 0, sizeof(*meb1));\r\nap_msg->length = sizeof(*meb1);\r\nmeb1->header.msg_type_code = TYPE50_TYPE_CODE;\r\nmeb1->header.msg_len = sizeof(*meb1);\r\nmeb1->keyblock_type = TYPE50_MEB1_FMT;\r\nmod = meb1->modulus + sizeof(meb1->modulus) - mod_len;\r\nexp = meb1->exponent + sizeof(meb1->exponent) - mod_len;\r\ninp = meb1->message + sizeof(meb1->message) - mod_len;\r\n} else if (mod_len <= 256) {\r\nstruct type50_meb2_msg *meb2 = ap_msg->message;\r\nmemset(meb2, 0, sizeof(*meb2));\r\nap_msg->length = sizeof(*meb2);\r\nmeb2->header.msg_type_code = TYPE50_TYPE_CODE;\r\nmeb2->header.msg_len = sizeof(*meb2);\r\nmeb2->keyblock_type = TYPE50_MEB2_FMT;\r\nmod = meb2->modulus + sizeof(meb2->modulus) - mod_len;\r\nexp = meb2->exponent + sizeof(meb2->exponent) - mod_len;\r\ninp = meb2->message + sizeof(meb2->message) - mod_len;\r\n} else {\r\nstruct type50_meb3_msg *meb3 = ap_msg->message;\r\nmemset(meb3, 0, sizeof(*meb3));\r\nap_msg->length = sizeof(*meb3);\r\nmeb3->header.msg_type_code = TYPE50_TYPE_CODE;\r\nmeb3->header.msg_len = sizeof(*meb3);\r\nmeb3->keyblock_type = TYPE50_MEB3_FMT;\r\nmod = meb3->modulus + sizeof(meb3->modulus) - mod_len;\r\nexp = meb3->exponent + sizeof(meb3->exponent) - mod_len;\r\ninp = meb3->message + sizeof(meb3->message) - mod_len;\r\n}\r\nif (copy_from_user(mod, mex->n_modulus, mod_len) ||\r\ncopy_from_user(exp, mex->b_key, mod_len) ||\r\ncopy_from_user(inp, mex->inputdata, mod_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ICACRT_msg_to_type50CRT_msg(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nint mod_len, short_len, long_len, long_offset, limit;\r\nunsigned char *p, *q, *dp, *dq, *u, *inp;\r\nmod_len = crt->inputdatalength;\r\nshort_len = mod_len / 2;\r\nlong_len = mod_len / 2 + 8;\r\nif (zdev->max_mod_size == CEX3A_MAX_MOD_SIZE)\r\nlimit = 256;\r\nelse\r\nlimit = 128;\r\nif (long_len > limit) {\r\nlong_offset = long_len - limit;\r\nlong_len = limit;\r\n} else\r\nlong_offset = 0;\r\nif (long_len <= 64) {\r\nstruct type50_crb1_msg *crb1 = ap_msg->message;\r\nmemset(crb1, 0, sizeof(*crb1));\r\nap_msg->length = sizeof(*crb1);\r\ncrb1->header.msg_type_code = TYPE50_TYPE_CODE;\r\ncrb1->header.msg_len = sizeof(*crb1);\r\ncrb1->keyblock_type = TYPE50_CRB1_FMT;\r\np = crb1->p + sizeof(crb1->p) - long_len;\r\nq = crb1->q + sizeof(crb1->q) - short_len;\r\ndp = crb1->dp + sizeof(crb1->dp) - long_len;\r\ndq = crb1->dq + sizeof(crb1->dq) - short_len;\r\nu = crb1->u + sizeof(crb1->u) - long_len;\r\ninp = crb1->message + sizeof(crb1->message) - mod_len;\r\n} else if (long_len <= 128) {\r\nstruct type50_crb2_msg *crb2 = ap_msg->message;\r\nmemset(crb2, 0, sizeof(*crb2));\r\nap_msg->length = sizeof(*crb2);\r\ncrb2->header.msg_type_code = TYPE50_TYPE_CODE;\r\ncrb2->header.msg_len = sizeof(*crb2);\r\ncrb2->keyblock_type = TYPE50_CRB2_FMT;\r\np = crb2->p + sizeof(crb2->p) - long_len;\r\nq = crb2->q + sizeof(crb2->q) - short_len;\r\ndp = crb2->dp + sizeof(crb2->dp) - long_len;\r\ndq = crb2->dq + sizeof(crb2->dq) - short_len;\r\nu = crb2->u + sizeof(crb2->u) - long_len;\r\ninp = crb2->message + sizeof(crb2->message) - mod_len;\r\n} else {\r\nstruct type50_crb3_msg *crb3 = ap_msg->message;\r\nmemset(crb3, 0, sizeof(*crb3));\r\nap_msg->length = sizeof(*crb3);\r\ncrb3->header.msg_type_code = TYPE50_TYPE_CODE;\r\ncrb3->header.msg_len = sizeof(*crb3);\r\ncrb3->keyblock_type = TYPE50_CRB3_FMT;\r\np = crb3->p + sizeof(crb3->p) - long_len;\r\nq = crb3->q + sizeof(crb3->q) - short_len;\r\ndp = crb3->dp + sizeof(crb3->dp) - long_len;\r\ndq = crb3->dq + sizeof(crb3->dq) - short_len;\r\nu = crb3->u + sizeof(crb3->u) - long_len;\r\ninp = crb3->message + sizeof(crb3->message) - mod_len;\r\n}\r\nif (copy_from_user(p, crt->np_prime + long_offset, long_len) ||\r\ncopy_from_user(q, crt->nq_prime, short_len) ||\r\ncopy_from_user(dp, crt->bp_key + long_offset, long_len) ||\r\ncopy_from_user(dq, crt->bq_key, short_len) ||\r\ncopy_from_user(u, crt->u_mult_inv + long_offset, long_len) ||\r\ncopy_from_user(inp, crt->inputdata, mod_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_type80(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstruct type80_hdr *t80h = reply->message;\r\nunsigned char *data;\r\nif (t80h->len < sizeof(*t80h) + outputdatalength) {\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\nif (zdev->user_space_type == ZCRYPT_CEX2A)\r\nBUG_ON(t80h->len > CEX2A_MAX_RESPONSE_SIZE);\r\nelse\r\nBUG_ON(t80h->len > CEX3A_MAX_RESPONSE_SIZE);\r\ndata = reply->message + t80h->len - outputdatalength;\r\nif (copy_to_user(outputdata, data, outputdatalength))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_response(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nswitch (((unsigned char *) reply->message)[1]) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn convert_error(zdev, reply);\r\ncase TYPE80_RSP_CODE:\r\nreturn convert_type80(zdev, reply,\r\noutputdata, outputdatalength);\r\ndefault:\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void zcrypt_cex2a_receive(struct ap_device *ap_dev,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct type80_hdr *t80h;\r\nint length;\r\nif (IS_ERR(reply)) {\r\nmemcpy(msg->message, &error_reply, sizeof(error_reply));\r\ngoto out;\r\n}\r\nt80h = reply->message;\r\nif (t80h->type == TYPE80_RSP_CODE) {\r\nif (ap_dev->device_type == AP_DEVICE_TYPE_CEX2A)\r\nlength = min(CEX2A_MAX_RESPONSE_SIZE, (int) t80h->len);\r\nelse\r\nlength = min(CEX3A_MAX_RESPONSE_SIZE, (int) t80h->len);\r\nmemcpy(msg->message, reply->message, length);\r\n} else\r\nmemcpy(msg->message, reply->message, sizeof error_reply);\r\nout:\r\ncomplete((struct completion *) msg->private);\r\n}\r\nstatic long zcrypt_cex2a_modexpo(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nif (zdev->user_space_type == ZCRYPT_CEX2A)\r\nap_msg.message = kmalloc(CEX2A_MAX_MESSAGE_SIZE, GFP_KERNEL);\r\nelse\r\nap_msg.message = kmalloc(CEX3A_MAX_MESSAGE_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICAMEX_msg_to_type50MEX_msg(zdev, &ap_msg, mex);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0)\r\nrc = convert_response(zdev, &ap_msg, mex->outputdata,\r\nmex->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_cex2a_modexpo_crt(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nif (zdev->user_space_type == ZCRYPT_CEX2A)\r\nap_msg.message = kmalloc(CEX2A_MAX_MESSAGE_SIZE, GFP_KERNEL);\r\nelse\r\nap_msg.message = kmalloc(CEX3A_MAX_MESSAGE_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICACRT_msg_to_type50CRT_msg(zdev, &ap_msg, crt);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0)\r\nrc = convert_response(zdev, &ap_msg, crt->outputdata,\r\ncrt->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic int zcrypt_cex2a_probe(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev = NULL;\r\nint rc = 0;\r\nswitch (ap_dev->device_type) {\r\ncase AP_DEVICE_TYPE_CEX2A:\r\nzdev = zcrypt_device_alloc(CEX2A_MAX_RESPONSE_SIZE);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->user_space_type = ZCRYPT_CEX2A;\r\nzdev->type_string = "CEX2A";\r\nzdev->min_mod_size = CEX2A_MIN_MOD_SIZE;\r\nzdev->max_mod_size = CEX2A_MAX_MOD_SIZE;\r\nzdev->short_crt = 1;\r\nzdev->speed_rating = CEX2A_SPEED_RATING;\r\nzdev->max_exp_bit_length = CEX2A_MAX_MOD_SIZE;\r\nbreak;\r\ncase AP_DEVICE_TYPE_CEX3A:\r\nzdev = zcrypt_device_alloc(CEX3A_MAX_RESPONSE_SIZE);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->user_space_type = ZCRYPT_CEX3A;\r\nzdev->type_string = "CEX3A";\r\nzdev->min_mod_size = CEX2A_MIN_MOD_SIZE;\r\nzdev->max_mod_size = CEX2A_MAX_MOD_SIZE;\r\nzdev->max_exp_bit_length = CEX2A_MAX_MOD_SIZE;\r\nif (ap_4096_commands_available(ap_dev->qid)) {\r\nzdev->max_mod_size = CEX3A_MAX_MOD_SIZE;\r\nzdev->max_exp_bit_length = CEX3A_MAX_MOD_SIZE;\r\n}\r\nzdev->short_crt = 1;\r\nzdev->speed_rating = CEX3A_SPEED_RATING;\r\nbreak;\r\n}\r\nif (zdev != NULL) {\r\nzdev->ap_dev = ap_dev;\r\nzdev->ops = &zcrypt_cex2a_ops;\r\nzdev->online = 1;\r\nap_dev->reply = &zdev->reply;\r\nap_dev->private = zdev;\r\nrc = zcrypt_device_register(zdev);\r\n}\r\nif (rc) {\r\nap_dev->private = NULL;\r\nzcrypt_device_free(zdev);\r\n}\r\nreturn rc;\r\n}\r\nstatic void zcrypt_cex2a_remove(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev = ap_dev->private;\r\nzcrypt_device_unregister(zdev);\r\n}\r\nint __init zcrypt_cex2a_init(void)\r\n{\r\nreturn ap_driver_register(&zcrypt_cex2a_driver, THIS_MODULE, "cex2a");\r\n}\r\nvoid __exit zcrypt_cex2a_exit(void)\r\n{\r\nap_driver_unregister(&zcrypt_cex2a_driver);\r\n}
