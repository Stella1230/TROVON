void die(const char *str, ...)\r\n{\r\nva_list args;\r\nva_start(args, str);\r\nvfprintf(stderr, str, args);\r\nfputc('\n', stderr);\r\nexit(1);\r\n}\r\nvoid file_open(const char *name)\r\n{\r\nfd = open(name, O_RDONLY, 0);\r\nif (fd < 0)\r\ndie("Unable to open `%s': %m", name);\r\n}\r\nvoid usage(void)\r\n{\r\ndie("Usage: build [-b] bootsect setup system [rootdev] [> image]");\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nunsigned int i, c, sz, setup_sectors;\r\nuint32_t sys_size;\r\nuint8_t major_root, minor_root;\r\nstruct stat sb;\r\nif (argc > 2 && !strcmp(argv[1], "-b")) {\r\nis_big_kernel = 1;\r\nargc--, argv++;\r\n}\r\nif ((argc < 4) || (argc > 5))\r\nusage();\r\nif (argc > 4) {\r\nif (!strcmp(argv[4], "CURRENT")) {\r\nif (stat("/", &sb)) {\r\nperror("/");\r\ndie("Couldn't stat /");\r\n}\r\nmajor_root = major(sb.st_dev);\r\nminor_root = minor(sb.st_dev);\r\n} else if (strcmp(argv[4], "FLOPPY")) {\r\nif (stat(argv[4], &sb)) {\r\nperror(argv[4]);\r\ndie("Couldn't stat root device.");\r\n}\r\nmajor_root = major(sb.st_rdev);\r\nminor_root = minor(sb.st_rdev);\r\n} else {\r\nmajor_root = 0;\r\nminor_root = 0;\r\n}\r\n} else {\r\nmajor_root = DEFAULT_MAJOR_ROOT;\r\nminor_root = DEFAULT_MINOR_ROOT;\r\n}\r\nfprintf(stderr, "Root device is (%d, %d)\n", major_root, minor_root);\r\nfile_open(argv[1]);\r\ni = read(fd, buf, sizeof(buf));\r\nfprintf(stderr, "Boot sector %d bytes.\n", i);\r\nif (i != 512)\r\ndie("Boot block must be exactly 512 bytes");\r\nif (buf[510] != 0x55 || buf[511] != 0xaa)\r\ndie("Boot block hasn't got boot flag (0xAA55)");\r\nbuf[508] = minor_root;\r\nbuf[509] = major_root;\r\nif (write(1, buf, 512) != 512)\r\ndie("Write call failed");\r\nclose(fd);\r\nfile_open(argv[2]);\r\nfor (i = 0; (c = read(fd, buf, sizeof(buf))) > 0; i += c)\r\nif (write(1, buf, c) != c)\r\ndie("Write call failed");\r\nif (c != 0)\r\ndie("read-error on `setup'");\r\nclose(fd);\r\nsetup_sectors = (i + 511) / 512;\r\nif (setup_sectors < SETUP_SECTS)\r\nsetup_sectors = SETUP_SECTS;\r\nfprintf(stderr, "Setup is %d bytes.\n", i);\r\nmemset(buf, 0, sizeof(buf));\r\nwhile (i < setup_sectors * 512) {\r\nc = setup_sectors * 512 - i;\r\nif (c > sizeof(buf))\r\nc = sizeof(buf);\r\nif (write(1, buf, c) != c)\r\ndie("Write call failed");\r\ni += c;\r\n}\r\nfile_open(argv[3]);\r\nif (fstat(fd, &sb))\r\ndie("Unable to stat `%s': %m", argv[3]);\r\nsz = sb.st_size;\r\nfprintf(stderr, "System is %d kB\n", sz / 1024);\r\nsys_size = (sz + 15) / 16;\r\nif (sys_size > (is_big_kernel ? 0x28000 : DEF_SYSSIZE))\r\ndie("System is too big. Try using %smodules.",\r\nis_big_kernel ? "" : "bzImage or ");\r\nif (sys_size > 0xffff)\r\nfprintf(stderr,\r\n"warning: kernel is too big for standalone boot "\r\n"from floppy\n");\r\nwhile (sz > 0) {\r\nint l, n;\r\nl = (sz > sizeof(buf)) ? sizeof(buf) : sz;\r\nn = read(fd, buf, l);\r\nif (n != l) {\r\nif (n < 0)\r\ndie("Error reading %s: %m", argv[3]);\r\nelse\r\ndie("%s: Unexpected EOF", argv[3]);\r\n}\r\nif (write(1, buf, l) != l)\r\ndie("Write failed");\r\nsz -= l;\r\n}\r\nclose(fd);\r\nif (lseek(1, 497, SEEK_SET) != 497)\r\ndie("Output: seek failed");\r\nbuf[0] = setup_sectors;\r\nif (write(1, buf, 1) != 1)\r\ndie("Write of setup sector count failed");\r\nif (lseek(1, 500, SEEK_SET) != 500)\r\ndie("Output: seek failed");\r\nbuf[0] = (sys_size & 0xff);\r\nbuf[1] = ((sys_size >> 8) & 0xff);\r\nif (write(1, buf, 2) != 2)\r\ndie("Write of image length failed");\r\nreturn 0;\r\n}
