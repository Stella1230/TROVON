static int __init driver_a2150_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_a2150);\r\n}\r\nstatic void __exit driver_a2150_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_a2150);\r\n}\r\nstatic void ni_dump_regs(struct comedi_device *dev)\r\n{\r\nprintk("config bits 0x%x\n", devpriv->config_bits);\r\nprintk("irq dma bits 0x%x\n", devpriv->irq_dma_bits);\r\nprintk("status bits 0x%x\n", inw(dev->iobase + STATUS_REG));\r\n}\r\nstatic irqreturn_t a2150_interrupt(int irq, void *d)\r\n{\r\nint i;\r\nint status;\r\nunsigned long flags;\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nunsigned int max_points, num_points, residue, leftover;\r\nshort dpnt;\r\nstatic const int sample_size = sizeof(devpriv->dma_buffer[0]);\r\nif (dev->attached == 0) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nasync = s->async;\r\nasync->events = 0;\r\ncmd = &async->cmd;\r\nstatus = inw(dev->iobase + STATUS_REG);\r\nif ((status & INTR_BIT) == 0) {\r\ncomedi_error(dev, "spurious interrupt");\r\nreturn IRQ_NONE;\r\n}\r\nif (status & OVFL_BIT) {\r\ncomedi_error(dev, "fifo overflow");\r\na2150_cancel(dev, s);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\n}\r\nif ((status & DMA_TC_BIT) == 0) {\r\ncomedi_error(dev, "caught non-dma interrupt? Aborting.");\r\na2150_cancel(dev, s);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma);\r\nclear_dma_ff(devpriv->dma);\r\nmax_points = devpriv->dma_transfer_size / sample_size;\r\nresidue = get_dma_residue(devpriv->dma) / sample_size;\r\nnum_points = max_points - residue;\r\nif (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)\r\nnum_points = devpriv->count;\r\nleftover = 0;\r\nif (cmd->stop_src == TRIG_NONE) {\r\nleftover = devpriv->dma_transfer_size / sample_size;\r\n} else if (devpriv->count > max_points) {\r\nleftover = devpriv->count - max_points;\r\nif (leftover > max_points)\r\nleftover = max_points;\r\n}\r\nif (residue)\r\nleftover = 0;\r\nfor (i = 0; i < num_points; i++) {\r\ndpnt = devpriv->dma_buffer[i];\r\ndpnt ^= 0x8000;\r\ncfc_write_to_buffer(s, dpnt);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (--devpriv->count == 0) {\r\na2150_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (leftover) {\r\nset_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));\r\nset_dma_count(devpriv->dma, leftover * sample_size);\r\nenable_dma(devpriv->dma);\r\n}\r\nrelease_dma_lock(flags);\r\nasync->events |= COMEDI_CB_BLOCK;\r\ncomedi_event(dev, s);\r\noutw(0x00, dev->iobase + DMA_TC_CLEAR_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int a2150_probe(struct comedi_device *dev)\r\n{\r\nint status = inw(dev->iobase + STATUS_REG);\r\nreturn ID_BITS(status);\r\n}\r\nstatic int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nunsigned long iobase = it->options[0];\r\nunsigned int irq = it->options[1];\r\nunsigned int dma = it->options[2];\r\nstatic const int timeout = 2000;\r\nint i;\r\nprintk("comedi%d: %s: io 0x%lx", dev->minor, driver_a2150.driver_name,\r\niobase);\r\nif (irq) {\r\nprintk(", irq %u", irq);\r\n} else {\r\nprintk(", no irq");\r\n}\r\nif (dma) {\r\nprintk(", dma %u", dma);\r\n} else {\r\nprintk(", no dma");\r\n}\r\nprintk("\n");\r\nif (alloc_private(dev, sizeof(struct a2150_private)) < 0)\r\nreturn -ENOMEM;\r\nif (iobase == 0) {\r\nprintk(" io base address required\n");\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(iobase, A2150_SIZE, driver_a2150.driver_name)) {\r\nprintk(" I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\nif (irq) {\r\nif (irq < 3 || irq == 8 || irq == 13 || irq > 15) {\r\nprintk(" invalid irq line %u\n", irq);\r\nreturn -EINVAL;\r\n}\r\nif (request_irq(irq, a2150_interrupt, 0,\r\ndriver_a2150.driver_name, dev)) {\r\nprintk("unable to allocate irq %u\n", irq);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->irq_dma_bits |= IRQ_LVL_BITS(irq);\r\ndev->irq = irq;\r\n}\r\nif (dma) {\r\nif (dma == 4 || dma > 7) {\r\nprintk(" invalid dma channel %u\n", dma);\r\nreturn -EINVAL;\r\n}\r\nif (request_dma(dma, driver_a2150.driver_name)) {\r\nprintk(" failed to allocate dma channel %u\n", dma);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->dma = dma;\r\ndevpriv->dma_buffer =\r\nkmalloc(A2150_DMA_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (devpriv->dma_buffer == NULL)\r\nreturn -ENOMEM;\r\ndisable_dma(dma);\r\nset_dma_mode(dma, DMA_MODE_READ);\r\ndevpriv->irq_dma_bits |= DMA_CHAN_BITS(dma);\r\n}\r\ndev->board_ptr = a2150_boards + a2150_probe(dev);\r\ndev->board_name = thisboard->name;\r\nif (alloc_subdevices(dev, 1) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER | SDF_CMD_READ;\r\ns->n_chan = 4;\r\ns->len_chanlist = 4;\r\ns->maxdata = 0xffff;\r\ns->range_table = &range_a2150;\r\ns->do_cmd = a2150_ai_cmd;\r\ns->do_cmdtest = a2150_ai_cmdtest;\r\ns->insn_read = a2150_ai_rinsn;\r\ns->cancel = a2150_cancel;\r\noutw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\noutw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);\r\noutw_p(DPD_BIT, dev->iobase + CONFIG_REG);\r\ndevpriv->config_bits = 0;\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\nfor (i = 0; i < timeout; i++) {\r\nif ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)\r\nbreak;\r\nudelay(1000);\r\n}\r\nif (i == timeout) {\r\nprintk\r\n(" timed out waiting for offset calibration to complete\n");\r\nreturn -ETIME;\r\n}\r\ndevpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\nreturn 0;\r\n}\r\nstatic int a2150_detach(struct comedi_device *dev)\r\n{\r\nprintk("comedi%d: %s: remove\n", dev->minor, driver_a2150.driver_name);\r\nif (dev->iobase) {\r\noutw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);\r\nrelease_region(dev->iobase, A2150_SIZE);\r\n}\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->dma)\r\nfree_dma(devpriv->dma);\r\nkfree(devpriv->dma_buffer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\ndevpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\ndisable_dma(devpriv->dma);\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nreturn 0;\r\n}\r\nstatic int a2150_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nint startChan;\r\nint i;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < thisboard->ai_speed) {\r\ncmd->convert_arg = thisboard->ai_speed;\r\nerr++;\r\n}\r\n}\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 1;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\na2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nstartChan = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) != (startChan + i)) {\r\ncomedi_error(dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nerr++;\r\n}\r\n}\r\nif (cmd->chanlist_len == 2 && CR_CHAN(cmd->chanlist[0]) == 1) {\r\ncomedi_error(dev,\r\n"length 2 chanlist must be channels 0,1 or channels 2,3");\r\nerr++;\r\n}\r\nif (cmd->chanlist_len == 3) {\r\ncomedi_error(dev,\r\n"chanlist must have 1,2 or 4 channels");\r\nerr++;\r\n}\r\nif (CR_AREF(cmd->chanlist[0]) != CR_AREF(cmd->chanlist[1]) ||\r\nCR_AREF(cmd->chanlist[2]) != CR_AREF(cmd->chanlist[3])) {\r\ncomedi_error(dev,\r\n"channels 0/1 and 2/3 must have the same analog reference");\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long lock_flags;\r\nunsigned int old_config_bits = devpriv->config_bits;\r\nunsigned int trigger_bits;\r\nif (!dev->irq || !devpriv->dma) {\r\ncomedi_error(dev,\r\n" irq and dma required, cannot do hardware conversions");\r\nreturn -1;\r\n}\r\nif (cmd->flags & TRIG_RT) {\r\ncomedi_error(dev,\r\n" dma incompatible with hard real-time interrupt (TRIG_RT), aborting");\r\nreturn -1;\r\n}\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nif (a2150_set_chanlist(dev, CR_CHAN(cmd->chanlist[0]),\r\ncmd->chanlist_len) < 0)\r\nreturn -1;\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_OTHER)\r\ndevpriv->config_bits |= AC0_BIT;\r\nelse\r\ndevpriv->config_bits &= ~AC0_BIT;\r\nif (CR_AREF(cmd->chanlist[2]) == AREF_OTHER)\r\ndevpriv->config_bits |= AC1_BIT;\r\nelse\r\ndevpriv->config_bits &= ~AC1_BIT;\r\na2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\ndevpriv->count = cmd->stop_arg * cmd->chanlist_len;\r\nlock_flags = claim_dma_lock();\r\ndisable_dma(devpriv->dma);\r\nclear_dma_ff(devpriv->dma);\r\nset_dma_addr(devpriv->dma, virt_to_bus(devpriv->dma_buffer));\r\n#define ONE_THIRD_SECOND 333333333\r\ndevpriv->dma_transfer_size =\r\nsizeof(devpriv->dma_buffer[0]) * cmd->chanlist_len *\r\nONE_THIRD_SECOND / cmd->scan_begin_arg;\r\nif (devpriv->dma_transfer_size > A2150_DMA_BUFFER_SIZE)\r\ndevpriv->dma_transfer_size = A2150_DMA_BUFFER_SIZE;\r\nif (devpriv->dma_transfer_size < sizeof(devpriv->dma_buffer[0]))\r\ndevpriv->dma_transfer_size = sizeof(devpriv->dma_buffer[0]);\r\ndevpriv->dma_transfer_size -=\r\ndevpriv->dma_transfer_size % sizeof(devpriv->dma_buffer[0]);\r\nset_dma_count(devpriv->dma, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma);\r\nrelease_dma_lock(lock_flags);\r\noutw(0x00, dev->iobase + DMA_TC_CLEAR_REG);\r\ndevpriv->irq_dma_bits |= DMA_INTR_EN_BIT | DMA_EN_BIT;\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\ni8254_load(dev->iobase + I8253_BASE_REG, 0, 2, 72, 0);\r\ntrigger_bits = 0;\r\nif (cmd->start_src == TRIG_NOW &&\r\n(old_config_bits & CLOCK_MASK) !=\r\n(devpriv->config_bits & CLOCK_MASK)) {\r\ntrigger_bits |= DELAY_TRIGGER_BITS;\r\n} else {\r\ntrigger_bits |= POST_TRIGGER_BITS;\r\n}\r\nif (cmd->start_src == TRIG_EXT) {\r\ntrigger_bits |= HW_TRIG_EN;\r\n} else if (cmd->start_src == TRIG_OTHER) {\r\ncomedi_error(dev, "you shouldn't see this?");\r\n}\r\noutw(trigger_bits, dev->iobase + TRIGGER_REG);\r\nif (cmd->start_src == TRIG_NOW) {\r\noutw(0, dev->iobase + FIFO_START_REG);\r\n}\r\n#ifdef A2150_DEBUG\r\nni_dump_regs(dev);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int i, n;\r\nstatic const int timeout = 100000;\r\nstatic const int filter_delay = 36;\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nif (a2150_set_chanlist(dev, CR_CHAN(insn->chanspec), 1) < 0)\r\nreturn -1;\r\ndevpriv->config_bits &= ~AC0_BIT;\r\ndevpriv->config_bits &= ~AC1_BIT;\r\noutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\r\ndevpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;\r\noutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\r\noutw(0, dev->iobase + TRIGGER_REG);\r\noutw(0, dev->iobase + FIFO_START_REG);\r\nfor (n = 0; n < filter_delay; n++) {\r\nfor (i = 0; i < timeout; i++) {\r\nif (inw(dev->iobase + STATUS_REG) & FNE_BIT)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "timeout");\r\nreturn -ETIME;\r\n}\r\ninw(dev->iobase + FIFO_DATA_REG);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nfor (i = 0; i < timeout; i++) {\r\nif (inw(dev->iobase + STATUS_REG) & FNE_BIT)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "timeout");\r\nreturn -ETIME;\r\n}\r\n#ifdef A2150_DEBUG\r\nni_dump_regs(dev);\r\n#endif\r\ndata[n] = inw(dev->iobase + FIFO_DATA_REG);\r\n#ifdef A2150_DEBUG\r\nprintk(" data is %i\n", data[n]);\r\n#endif\r\ndata[n] ^= 0x8000;\r\n}\r\noutw(0, dev->iobase + FIFO_RESET_REG);\r\nreturn n;\r\n}\r\nstatic int a2150_get_timing(struct comedi_device *dev, unsigned int *period,\r\nint flags)\r\n{\r\nint lub, glb, temp;\r\nint lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;\r\nint i, j;\r\nlub_divisor_shift = 3;\r\nlub_index = 0;\r\nlub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);\r\nglb_divisor_shift = 0;\r\nglb_index = thisboard->num_clocks - 1;\r\nglb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);\r\nif (*period < glb)\r\n*period = glb;\r\nif (*period > lub)\r\n*period = lub;\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0; j < thisboard->num_clocks; j++) {\r\ntemp = thisboard->clock[j] * (1 << i);\r\nif (temp < lub && temp >= *period) {\r\nlub_divisor_shift = i;\r\nlub_index = j;\r\nlub = temp;\r\n}\r\nif (temp > glb && temp <= *period) {\r\nglb_divisor_shift = i;\r\nglb_index = j;\r\nglb = temp;\r\n}\r\n}\r\n}\r\nflags &= TRIG_ROUND_MASK;\r\nswitch (flags) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\nif (lub - *period < *period - glb) {\r\n*period = lub;\r\n} else {\r\n*period = glb;\r\n}\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\n*period = lub;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\n*period = glb;\r\nbreak;\r\n}\r\ndevpriv->config_bits &= ~CLOCK_MASK;\r\nif (*period == lub) {\r\ndevpriv->config_bits |=\r\nCLOCK_SELECT_BITS(lub_index) |\r\nCLOCK_DIVISOR_BITS(lub_divisor_shift);\r\n} else {\r\ndevpriv->config_bits |=\r\nCLOCK_SELECT_BITS(glb_index) |\r\nCLOCK_DIVISOR_BITS(glb_divisor_shift);\r\n}\r\nreturn 0;\r\n}\r\nstatic int a2150_set_chanlist(struct comedi_device *dev,\r\nunsigned int start_channel,\r\nunsigned int num_channels)\r\n{\r\nif (start_channel + num_channels > 4)\r\nreturn -1;\r\ndevpriv->config_bits &= ~CHANNEL_MASK;\r\nswitch (num_channels) {\r\ncase 1:\r\ndevpriv->config_bits |= CHANNEL_BITS(0x4 | start_channel);\r\nbreak;\r\ncase 2:\r\nif (start_channel == 0) {\r\ndevpriv->config_bits |= CHANNEL_BITS(0x2);\r\n} else if (start_channel == 2) {\r\ndevpriv->config_bits |= CHANNEL_BITS(0x3);\r\n} else {\r\nreturn -1;\r\n}\r\nbreak;\r\ncase 4:\r\ndevpriv->config_bits |= CHANNEL_BITS(0x1);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}
