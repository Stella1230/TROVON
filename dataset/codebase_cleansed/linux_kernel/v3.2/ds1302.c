static void tempudelay(int usecs)\r\n{\r\nvolatile int loops;\r\nfor(loops = usecs * 12; loops > 0; loops--)\r\n;\r\n}\r\nstatic void\r\nout_byte(unsigned char x)\r\n{\r\nint i;\r\nTK_SDA_DIR(1);\r\nfor (i = 8; i--;) {\r\nTK_SCL_OUT(0);\r\nTK_SDA_OUT(x & 1);\r\ntempudelay(1);\r\nTK_SCL_OUT(1);\r\ntempudelay(1);\r\nx >>= 1;\r\n}\r\nTK_SDA_DIR(0);\r\n}\r\nstatic unsigned char\r\nin_byte(void)\r\n{\r\nunsigned char x = 0;\r\nint i;\r\nTK_SDA_DIR(0);\r\nfor (i = 8; i--;) {\r\nTK_SCL_OUT(0);\r\ntempudelay(1);\r\nx >>= 1;\r\nx |= (TK_SDA_IN() << 7);\r\nTK_SCL_OUT(1);\r\ntempudelay(1);\r\n}\r\nreturn x;\r\n}\r\nstatic void\r\nstart(void)\r\n{\r\nTK_SCL_OUT(0);\r\ntempudelay(1);\r\nTK_RST_OUT(0);\r\ntempudelay(5);\r\nTK_RST_OUT(1);\r\n}\r\nstatic void\r\nstop(void)\r\n{\r\ntempudelay(2);\r\nTK_RST_OUT(0);\r\n}\r\nstatic void\r\nds1302_wenable(void)\r\n{\r\nstart();\r\nout_byte(0x8e);\r\nout_byte(0x00);\r\nstop();\r\n}\r\nstatic void\r\nds1302_wdisable(void)\r\n{\r\nstart();\r\nout_byte(0x8e);\r\nout_byte(0x80);\r\nstop();\r\n}\r\nunsigned char\r\nds1302_readreg(int reg)\r\n{\r\nunsigned char x;\r\nstart();\r\nout_byte(0x81 | (reg << 1));\r\nx = in_byte();\r\nstop();\r\nreturn x;\r\n}\r\nvoid\r\nds1302_writereg(int reg, unsigned char val)\r\n{\r\n#ifndef CONFIG_ETRAX_RTC_READONLY\r\nint do_writereg = 1;\r\n#else\r\nint do_writereg = 0;\r\nif (reg == RTC_TRICKLECHARGER)\r\ndo_writereg = 1;\r\n#endif\r\nif (do_writereg) {\r\nds1302_wenable();\r\nstart();\r\nout_byte(0x80 | (reg << 1));\r\nout_byte(val);\r\nstop();\r\nds1302_wdisable();\r\n}\r\n}\r\nvoid\r\nget_rtc_time(struct rtc_time *rtc_tm)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nrtc_tm->tm_sec = CMOS_READ(RTC_SECONDS);\r\nrtc_tm->tm_min = CMOS_READ(RTC_MINUTES);\r\nrtc_tm->tm_hour = CMOS_READ(RTC_HOURS);\r\nrtc_tm->tm_mday = CMOS_READ(RTC_DAY_OF_MONTH);\r\nrtc_tm->tm_mon = CMOS_READ(RTC_MONTH);\r\nrtc_tm->tm_year = CMOS_READ(RTC_YEAR);\r\nlocal_irq_restore(flags);\r\nrtc_tm->tm_sec = bcd2bin(rtc_tm->tm_sec);\r\nrtc_tm->tm_min = bcd2bin(rtc_tm->tm_min);\r\nrtc_tm->tm_hour = bcd2bin(rtc_tm->tm_hour);\r\nrtc_tm->tm_mday = bcd2bin(rtc_tm->tm_mday);\r\nrtc_tm->tm_mon = bcd2bin(rtc_tm->tm_mon);\r\nrtc_tm->tm_year = bcd2bin(rtc_tm->tm_year);\r\nif (rtc_tm->tm_year <= 69)\r\nrtc_tm->tm_year += 100;\r\nrtc_tm->tm_mon--;\r\n}\r\nstatic int rtc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned long flags;\r\nswitch(cmd) {\r\ncase RTC_RD_TIME:\r\n{\r\nstruct rtc_time rtc_tm;\r\nmemset(&rtc_tm, 0, sizeof (struct rtc_time));\r\nget_rtc_time(&rtc_tm);\r\nif (copy_to_user((struct rtc_time*)arg, &rtc_tm, sizeof(struct rtc_time)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase RTC_SET_TIME:\r\n{\r\nstruct rtc_time rtc_tm;\r\nunsigned char mon, day, hrs, min, sec, leap_yr;\r\nunsigned int yrs;\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nif (copy_from_user(&rtc_tm, (struct rtc_time*)arg, sizeof(struct rtc_time)))\r\nreturn -EFAULT;\r\nyrs = rtc_tm.tm_year + 1900;\r\nmon = rtc_tm.tm_mon + 1;\r\nday = rtc_tm.tm_mday;\r\nhrs = rtc_tm.tm_hour;\r\nmin = rtc_tm.tm_min;\r\nsec = rtc_tm.tm_sec;\r\nif ((yrs < 1970) || (yrs > 2069))\r\nreturn -EINVAL;\r\nleap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));\r\nif ((mon > 12) || (day == 0))\r\nreturn -EINVAL;\r\nif (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))\r\nreturn -EINVAL;\r\nif ((hrs >= 24) || (min >= 60) || (sec >= 60))\r\nreturn -EINVAL;\r\nif (yrs >= 2000)\r\nyrs -= 2000;\r\nelse\r\nyrs -= 1900;\r\nsec = bin2bcd(sec);\r\nmin = bin2bcd(min);\r\nhrs = bin2bcd(hrs);\r\nday = bin2bcd(day);\r\nmon = bin2bcd(mon);\r\nyrs = bin2bcd(yrs);\r\nlocal_irq_save(flags);\r\nCMOS_WRITE(yrs, RTC_YEAR);\r\nCMOS_WRITE(mon, RTC_MONTH);\r\nCMOS_WRITE(day, RTC_DAY_OF_MONTH);\r\nCMOS_WRITE(hrs, RTC_HOURS);\r\nCMOS_WRITE(min, RTC_MINUTES);\r\nCMOS_WRITE(sec, RTC_SECONDS);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\ncase RTC_SET_CHARGE:\r\n{\r\nint tcs_val;\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nif(copy_from_user(&tcs_val, (int*)arg, sizeof(int)))\r\nreturn -EFAULT;\r\ntcs_val = RTC_TCR_PATTERN | (tcs_val & 0x0F);\r\nds1302_writereg(RTC_TRICKLECHARGER, tcs_val);\r\nreturn 0;\r\n}\r\ncase RTC_VL_READ:\r\n{\r\nprintk(KERN_WARNING "DS1302: RTC Voltage Low detection"\r\n" is not supported\n");\r\nreturn 0;\r\n}\r\ncase RTC_VL_CLR:\r\n{\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic long rtc_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&ds1302_mutex);\r\nret = rtc_ioctl(file, cmd, arg);\r\nmutex_unlock(&ds1302_mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nprint_rtc_status(void)\r\n{\r\nstruct rtc_time tm;\r\nget_rtc_time(&tm);\r\nprintk(KERN_INFO "rtc_time\t: %02d:%02d:%02d\n",\r\ntm.tm_hour, tm.tm_min, tm.tm_sec);\r\nprintk(KERN_INFO "rtc_date\t: %04d-%02d-%02d\n",\r\ntm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\r\n}\r\nstatic int __init\r\nds1302_probe(void)\r\n{\r\nint retval, res;\r\nTK_RST_DIR(1);\r\nTK_SCL_DIR(1);\r\nTK_SDA_DIR(0);\r\nds1302_wenable();\r\nstart();\r\nout_byte(0xc0);\r\nout_byte(MAGIC_PATTERN);\r\nstart();\r\nout_byte(0xc1);\r\nif((res = in_byte()) == MAGIC_PATTERN) {\r\nstop();\r\nds1302_wdisable();\r\nprintk(KERN_INFO "%s: RTC found.\n", ds1302_name);\r\nprintk(KERN_INFO "%s: SDA, SCL, RST on PB%i, PB%i, %s%i\n",\r\nds1302_name,\r\nCONFIG_ETRAX_DS1302_SDABIT,\r\nCONFIG_ETRAX_DS1302_SCLBIT,\r\n#ifdef CONFIG_ETRAX_DS1302_RST_ON_GENERIC_PORT\r\n"GENIO",\r\n#else\r\n"PB",\r\n#endif\r\nCONFIG_ETRAX_DS1302_RSTBIT);\r\nprint_rtc_status();\r\nretval = 1;\r\n} else {\r\nstop();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\nint __init\r\nds1302_init(void)\r\n{\r\n#ifdef CONFIG_ETRAX_I2C\r\ni2c_init();\r\n#endif\r\nif (!ds1302_probe()) {\r\n#ifdef CONFIG_ETRAX_DS1302_RST_ON_GENERIC_PORT\r\n#if CONFIG_ETRAX_DS1302_RSTBIT == 27\r\nif (cris_request_io_interface(if_ata, "ds1302/ATA")) {\r\nprintk(KERN_WARNING "ds1302: Failed to get IO interface\n");\r\nreturn -1;\r\n}\r\n#elif CONFIG_ETRAX_DS1302_RSTBIT == 0\r\nif (cris_io_interface_allocate_pins(if_gpio_grp_a,\r\n'g',\r\nCONFIG_ETRAX_DS1302_RSTBIT,\r\nCONFIG_ETRAX_DS1302_RSTBIT)) {\r\nprintk(KERN_WARNING "ds1302: Failed to get IO interface\n");\r\nreturn -1;\r\n}\r\ngenconfig_shadow = ((genconfig_shadow &\r\n~IO_MASK(R_GEN_CONFIG, g0dir)) |\r\n(IO_STATE(R_GEN_CONFIG, g0dir, out)));\r\n*R_GEN_CONFIG = genconfig_shadow;\r\n#endif\r\nif (!ds1302_probe()) {\r\nprintk(KERN_WARNING "%s: RTC not found.\n", ds1302_name);\r\nreturn -1;\r\n}\r\n#else\r\nprintk(KERN_WARNING "%s: RTC not found.\n", ds1302_name);\r\nreturn -1;\r\n#endif\r\n}\r\nds1302_writereg(RTC_TRICKLECHARGER,\r\nRTC_TCR_PATTERN |(CONFIG_ETRAX_DS1302_TRICKLE_CHARGE & 0x0F));\r\nds1302_writereg(RTC_SECONDS, (ds1302_readreg(RTC_SECONDS) & 0x7F));\r\nreturn 0;\r\n}\r\nstatic int __init ds1302_register(void)\r\n{\r\nds1302_init();\r\nif (register_chrdev(RTC_MAJOR_NR, ds1302_name, &rtc_fops)) {\r\nprintk(KERN_INFO "%s: unable to get major %d for rtc\n",\r\nds1302_name, RTC_MAJOR_NR);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}
