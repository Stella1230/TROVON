static void audio_dma_irq(void *data)\r\n{\r\nstruct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\niprtd->offset += iprtd->period_bytes;\r\niprtd->offset %= iprtd->period_bytes * iprtd->periods;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct imx_pcm_runtime_data *iprtd = param;\r\nif (!imx_dma_is_general_purpose(chan))\r\nreturn false;\r\nchan->private = &iprtd->dma_data;\r\nreturn true;\r\n}\r\nstatic int imx_ssi_dma_alloc(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct imx_pcm_dma_params *dma_params;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nstruct dma_slave_config slave_config;\r\ndma_cap_mask_t mask;\r\nenum dma_slave_buswidth buswidth;\r\nint ret;\r\ndma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\niprtd->dma_data.peripheral_type = IMX_DMATYPE_SSI;\r\niprtd->dma_data.priority = DMA_PRIO_HIGH;\r\niprtd->dma_data.dma_request = dma_params->dma;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\niprtd->dma_chan = dma_request_channel(mask, filter, iprtd);\r\nif (!iprtd->dma_chan)\r\nreturn -EINVAL;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nslave_config.direction = DMA_TO_DEVICE;\r\nslave_config.dst_addr = dma_params->dma_addr;\r\nslave_config.dst_addr_width = buswidth;\r\nslave_config.dst_maxburst = dma_params->burstsize;\r\n} else {\r\nslave_config.direction = DMA_FROM_DEVICE;\r\nslave_config.src_addr = dma_params->dma_addr;\r\nslave_config.src_addr_width = buswidth;\r\nslave_config.src_maxburst = dma_params->burstsize;\r\n}\r\nret = dmaengine_slave_config(iprtd->dma_chan, &slave_config);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int snd_imx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nunsigned long dma_addr;\r\nstruct dma_chan *chan;\r\nstruct imx_pcm_dma_params *dma_params;\r\nint ret;\r\ndma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nret = imx_ssi_dma_alloc(substream, params);\r\nif (ret)\r\nreturn ret;\r\nchan = iprtd->dma_chan;\r\niprtd->size = params_buffer_bytes(params);\r\niprtd->periods = params_periods(params);\r\niprtd->period_bytes = params_period_bytes(params);\r\niprtd->offset = 0;\r\niprtd->period_time = HZ / (params_rate(params) /\r\nparams_period_size(params));\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\ndma_addr = runtime->dma_addr;\r\niprtd->buf = (unsigned int *)substream->dma_buffer.area;\r\niprtd->desc = chan->device->device_prep_dma_cyclic(chan, dma_addr,\r\niprtd->period_bytes * iprtd->periods,\r\niprtd->period_bytes,\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\nDMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (!iprtd->desc) {\r\ndev_err(&chan->dev->device, "cannot prepare slave dma\n");\r\nreturn -EINVAL;\r\n}\r\niprtd->desc->callback = audio_dma_irq;\r\niprtd->desc->callback_param = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_imx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nif (iprtd->dma_chan) {\r\ndma_release_channel(iprtd->dma_chan);\r\niprtd->dma_chan = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_imx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct imx_pcm_dma_params *dma_params;\r\ndma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ndmaengine_submit(iprtd->desc);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndmaengine_terminate_all(iprtd->dma_chan);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_imx_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\npr_debug("%s: %ld %ld\n", __func__, iprtd->offset,\r\nbytes_to_frames(substream->runtime, iprtd->offset));\r\nreturn bytes_to_frames(substream->runtime, iprtd->offset);\r\n}\r\nstatic int snd_imx_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd;\r\nint ret;\r\niprtd = kzalloc(sizeof(*iprtd), GFP_KERNEL);\r\nif (iprtd == NULL)\r\nreturn -ENOMEM;\r\nruntime->private_data = iprtd;\r\nret = snd_pcm_hw_constraint_integer(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0) {\r\nkfree(iprtd);\r\nreturn ret;\r\n}\r\nsnd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);\r\nreturn 0;\r\n}\r\nstatic int snd_imx_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\r\nkfree(iprtd);\r\nreturn 0;\r\n}\r\nstatic int __devinit imx_soc_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct imx_ssi *ssi = platform_get_drvdata(pdev);\r\nssi->dma_params_tx.burstsize = 6;\r\nssi->dma_params_rx.burstsize = 4;\r\nreturn snd_soc_register_platform(&pdev->dev, &imx_soc_platform_mx2);\r\n}\r\nstatic int __devexit imx_soc_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init snd_imx_pcm_init(void)\r\n{\r\nreturn platform_driver_register(&imx_pcm_driver);\r\n}\r\nstatic void __exit snd_imx_pcm_exit(void)\r\n{\r\nplatform_driver_unregister(&imx_pcm_driver);\r\n}
