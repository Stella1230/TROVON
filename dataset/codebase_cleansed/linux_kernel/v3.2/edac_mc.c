static void edac_mc_dump_channel(struct channel_info *chan)\r\n{\r\ndebugf4("\tchannel = %p\n", chan);\r\ndebugf4("\tchannel->chan_idx = %d\n", chan->chan_idx);\r\ndebugf4("\tchannel->ce_count = %d\n", chan->ce_count);\r\ndebugf4("\tchannel->label = '%s'\n", chan->label);\r\ndebugf4("\tchannel->csrow = %p\n\n", chan->csrow);\r\n}\r\nstatic void edac_mc_dump_csrow(struct csrow_info *csrow)\r\n{\r\ndebugf4("\tcsrow = %p\n", csrow);\r\ndebugf4("\tcsrow->csrow_idx = %d\n", csrow->csrow_idx);\r\ndebugf4("\tcsrow->first_page = 0x%lx\n", csrow->first_page);\r\ndebugf4("\tcsrow->last_page = 0x%lx\n", csrow->last_page);\r\ndebugf4("\tcsrow->page_mask = 0x%lx\n", csrow->page_mask);\r\ndebugf4("\tcsrow->nr_pages = 0x%x\n", csrow->nr_pages);\r\ndebugf4("\tcsrow->nr_channels = %d\n", csrow->nr_channels);\r\ndebugf4("\tcsrow->channels = %p\n", csrow->channels);\r\ndebugf4("\tcsrow->mci = %p\n\n", csrow->mci);\r\n}\r\nstatic void edac_mc_dump_mci(struct mem_ctl_info *mci)\r\n{\r\ndebugf3("\tmci = %p\n", mci);\r\ndebugf3("\tmci->mtype_cap = %lx\n", mci->mtype_cap);\r\ndebugf3("\tmci->edac_ctl_cap = %lx\n", mci->edac_ctl_cap);\r\ndebugf3("\tmci->edac_cap = %lx\n", mci->edac_cap);\r\ndebugf4("\tmci->edac_check = %p\n", mci->edac_check);\r\ndebugf3("\tmci->nr_csrows = %d, csrows = %p\n",\r\nmci->nr_csrows, mci->csrows);\r\ndebugf3("\tdev = %p\n", mci->dev);\r\ndebugf3("\tmod_name:ctl_name = %s:%s\n", mci->mod_name, mci->ctl_name);\r\ndebugf3("\tpvt_info = %p\n\n", mci->pvt_info);\r\n}\r\nvoid *edac_align_ptr(void *ptr, unsigned size)\r\n{\r\nunsigned align, r;\r\nif (size > sizeof(long))\r\nalign = sizeof(long long);\r\nelse if (size > sizeof(int))\r\nalign = sizeof(long);\r\nelse if (size > sizeof(short))\r\nalign = sizeof(int);\r\nelse if (size > sizeof(char))\r\nalign = sizeof(short);\r\nelse\r\nreturn (char *)ptr;\r\nr = size % align;\r\nif (r == 0)\r\nreturn (char *)ptr;\r\nreturn (void *)(((unsigned long)ptr) + align - r);\r\n}\r\nstruct mem_ctl_info *edac_mc_alloc(unsigned sz_pvt, unsigned nr_csrows,\r\nunsigned nr_chans, int edac_index)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct csrow_info *csi, *csrow;\r\nstruct channel_info *chi, *chp, *chan;\r\nvoid *pvt;\r\nunsigned size;\r\nint row, chn;\r\nint err;\r\nmci = (struct mem_ctl_info *)0;\r\ncsi = edac_align_ptr(&mci[1], sizeof(*csi));\r\nchi = edac_align_ptr(&csi[nr_csrows], sizeof(*chi));\r\npvt = edac_align_ptr(&chi[nr_chans * nr_csrows], sz_pvt);\r\nsize = ((unsigned long)pvt) + sz_pvt;\r\nmci = kzalloc(size, GFP_KERNEL);\r\nif (mci == NULL)\r\nreturn NULL;\r\ncsi = (struct csrow_info *)(((char *)mci) + ((unsigned long)csi));\r\nchi = (struct channel_info *)(((char *)mci) + ((unsigned long)chi));\r\npvt = sz_pvt ? (((char *)mci) + ((unsigned long)pvt)) : NULL;\r\nmci->mc_idx = edac_index;\r\nmci->csrows = csi;\r\nmci->pvt_info = pvt;\r\nmci->nr_csrows = nr_csrows;\r\nfor (row = 0; row < nr_csrows; row++) {\r\ncsrow = &csi[row];\r\ncsrow->csrow_idx = row;\r\ncsrow->mci = mci;\r\ncsrow->nr_channels = nr_chans;\r\nchp = &chi[row * nr_chans];\r\ncsrow->channels = chp;\r\nfor (chn = 0; chn < nr_chans; chn++) {\r\nchan = &chp[chn];\r\nchan->chan_idx = chn;\r\nchan->csrow = csrow;\r\n}\r\n}\r\nmci->op_state = OP_ALLOC;\r\nINIT_LIST_HEAD(&mci->grp_kobj_list);\r\nerr = edac_mc_register_sysfs_main_kobj(mci);\r\nif (err) {\r\nkfree(mci);\r\nreturn NULL;\r\n}\r\nreturn mci;\r\n}\r\nvoid edac_mc_free(struct mem_ctl_info *mci)\r\n{\r\ndebugf1("%s()\n", __func__);\r\nedac_mc_unregister_sysfs_main_kobj(mci);\r\nkfree(mci);\r\n}\r\nstruct mem_ctl_info *find_mci_by_dev(struct device *dev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct list_head *item;\r\ndebugf3("%s()\n", __func__);\r\nlist_for_each(item, &mc_devices) {\r\nmci = list_entry(item, struct mem_ctl_info, link);\r\nif (mci->dev == dev)\r\nreturn mci;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int edac_mc_assert_error_check_and_clear(void)\r\n{\r\nint old_state;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nreturn 1;\r\nold_state = edac_err_assert;\r\nedac_err_assert = 0;\r\nreturn old_state;\r\n}\r\nstatic void edac_mc_workq_function(struct work_struct *work_req)\r\n{\r\nstruct delayed_work *d_work = to_delayed_work(work_req);\r\nstruct mem_ctl_info *mci = to_edac_mem_ctl_work(d_work);\r\nmutex_lock(&mem_ctls_mutex);\r\nif (mci->op_state == OP_OFFLINE) {\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn;\r\n}\r\nif (edac_mc_assert_error_check_and_clear() && (mci->edac_check != NULL))\r\nmci->edac_check(mci);\r\nmutex_unlock(&mem_ctls_mutex);\r\nqueue_delayed_work(edac_workqueue, &mci->work,\r\nmsecs_to_jiffies(edac_mc_get_poll_msec()));\r\n}\r\nstatic void edac_mc_workq_setup(struct mem_ctl_info *mci, unsigned msec)\r\n{\r\ndebugf0("%s()\n", __func__);\r\nif (mci->op_state != OP_RUNNING_POLL)\r\nreturn;\r\nINIT_DELAYED_WORK(&mci->work, edac_mc_workq_function);\r\nqueue_delayed_work(edac_workqueue, &mci->work, msecs_to_jiffies(msec));\r\n}\r\nstatic void edac_mc_workq_teardown(struct mem_ctl_info *mci)\r\n{\r\nint status;\r\nif (mci->op_state != OP_RUNNING_POLL)\r\nreturn;\r\nstatus = cancel_delayed_work(&mci->work);\r\nif (status == 0) {\r\ndebugf0("%s() not canceled, flush the queue\n",\r\n__func__);\r\nflush_workqueue(edac_workqueue);\r\n}\r\n}\r\nvoid edac_mc_reset_delay_period(int value)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct list_head *item;\r\nmutex_lock(&mem_ctls_mutex);\r\nlist_for_each(item, &mc_devices) {\r\nmci = list_entry(item, struct mem_ctl_info, link);\r\nif (mci->op_state == OP_RUNNING_POLL)\r\ncancel_delayed_work(&mci->work);\r\n}\r\nmutex_unlock(&mem_ctls_mutex);\r\nmutex_lock(&mem_ctls_mutex);\r\nlist_for_each(item, &mc_devices) {\r\nmci = list_entry(item, struct mem_ctl_info, link);\r\nedac_mc_workq_setup(mci, (unsigned long) value);\r\n}\r\nmutex_unlock(&mem_ctls_mutex);\r\n}\r\nstatic int add_mc_to_global_list(struct mem_ctl_info *mci)\r\n{\r\nstruct list_head *item, *insert_before;\r\nstruct mem_ctl_info *p;\r\ninsert_before = &mc_devices;\r\np = find_mci_by_dev(mci->dev);\r\nif (unlikely(p != NULL))\r\ngoto fail0;\r\nlist_for_each(item, &mc_devices) {\r\np = list_entry(item, struct mem_ctl_info, link);\r\nif (p->mc_idx >= mci->mc_idx) {\r\nif (unlikely(p->mc_idx == mci->mc_idx))\r\ngoto fail1;\r\ninsert_before = item;\r\nbreak;\r\n}\r\n}\r\nlist_add_tail_rcu(&mci->link, insert_before);\r\natomic_inc(&edac_handlers);\r\nreturn 0;\r\nfail0:\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"%s (%s) %s %s already assigned %d\n", dev_name(p->dev),\r\nedac_dev_name(mci), p->mod_name, p->ctl_name, p->mc_idx);\r\nreturn 1;\r\nfail1:\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"bug in low-level driver: attempt to assign\n"\r\n" duplicate mc_idx %d in %s()\n", p->mc_idx, __func__);\r\nreturn 1;\r\n}\r\nstatic void del_mc_from_global_list(struct mem_ctl_info *mci)\r\n{\r\natomic_dec(&edac_handlers);\r\nlist_del_rcu(&mci->link);\r\nsynchronize_rcu();\r\nINIT_LIST_HEAD(&mci->link);\r\n}\r\nstruct mem_ctl_info *edac_mc_find(int idx)\r\n{\r\nstruct list_head *item;\r\nstruct mem_ctl_info *mci;\r\nlist_for_each(item, &mc_devices) {\r\nmci = list_entry(item, struct mem_ctl_info, link);\r\nif (mci->mc_idx >= idx) {\r\nif (mci->mc_idx == idx)\r\nreturn mci;\r\nbreak;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint edac_mc_add_mc(struct mem_ctl_info *mci)\r\n{\r\ndebugf0("%s()\n", __func__);\r\n#ifdef CONFIG_EDAC_DEBUG\r\nif (edac_debug_level >= 3)\r\nedac_mc_dump_mci(mci);\r\nif (edac_debug_level >= 4) {\r\nint i;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nint j;\r\nedac_mc_dump_csrow(&mci->csrows[i]);\r\nfor (j = 0; j < mci->csrows[i].nr_channels; j++)\r\nedac_mc_dump_channel(&mci->csrows[i].\r\nchannels[j]);\r\n}\r\n}\r\n#endif\r\nmutex_lock(&mem_ctls_mutex);\r\nif (add_mc_to_global_list(mci))\r\ngoto fail0;\r\nmci->start_time = jiffies;\r\nif (edac_create_sysfs_mci_device(mci)) {\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"failed to create sysfs device\n");\r\ngoto fail1;\r\n}\r\nif (mci->edac_check != NULL) {\r\nmci->op_state = OP_RUNNING_POLL;\r\nedac_mc_workq_setup(mci, edac_mc_get_poll_msec());\r\n} else {\r\nmci->op_state = OP_RUNNING_INTERRUPT;\r\n}\r\nedac_mc_printk(mci, KERN_INFO, "Giving out device to '%s' '%s':"\r\n" DEV %s\n", mci->mod_name, mci->ctl_name, edac_dev_name(mci));\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn 0;\r\nfail1:\r\ndel_mc_from_global_list(mci);\r\nfail0:\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn 1;\r\n}\r\nstruct mem_ctl_info *edac_mc_del_mc(struct device *dev)\r\n{\r\nstruct mem_ctl_info *mci;\r\ndebugf0("%s()\n", __func__);\r\nmutex_lock(&mem_ctls_mutex);\r\nmci = find_mci_by_dev(dev);\r\nif (mci == NULL) {\r\nmutex_unlock(&mem_ctls_mutex);\r\nreturn NULL;\r\n}\r\ndel_mc_from_global_list(mci);\r\nmutex_unlock(&mem_ctls_mutex);\r\nedac_mc_workq_teardown(mci);\r\nmci->op_state = OP_OFFLINE;\r\nedac_remove_sysfs_mci_device(mci);\r\nedac_printk(KERN_INFO, EDAC_MC,\r\n"Removed device %d for %s %s: DEV %s\n", mci->mc_idx,\r\nmci->mod_name, mci->ctl_name, edac_dev_name(mci));\r\nreturn mci;\r\n}\r\nstatic void edac_mc_scrub_block(unsigned long page, unsigned long offset,\r\nu32 size)\r\n{\r\nstruct page *pg;\r\nvoid *virt_addr;\r\nunsigned long flags = 0;\r\ndebugf3("%s()\n", __func__);\r\nif (!pfn_valid(page))\r\nreturn;\r\npg = pfn_to_page(page);\r\nif (PageHighMem(pg))\r\nlocal_irq_save(flags);\r\nvirt_addr = kmap_atomic(pg, KM_BOUNCE_READ);\r\natomic_scrub(virt_addr + offset, size);\r\nkunmap_atomic(virt_addr, KM_BOUNCE_READ);\r\nif (PageHighMem(pg))\r\nlocal_irq_restore(flags);\r\n}\r\nint edac_mc_find_csrow_by_page(struct mem_ctl_info *mci, unsigned long page)\r\n{\r\nstruct csrow_info *csrows = mci->csrows;\r\nint row, i;\r\ndebugf1("MC%d: %s(): 0x%lx\n", mci->mc_idx, __func__, page);\r\nrow = -1;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nstruct csrow_info *csrow = &csrows[i];\r\nif (csrow->nr_pages == 0)\r\ncontinue;\r\ndebugf3("MC%d: %s(): first(0x%lx) page(0x%lx) last(0x%lx) "\r\n"mask(0x%lx)\n", mci->mc_idx, __func__,\r\ncsrow->first_page, page, csrow->last_page,\r\ncsrow->page_mask);\r\nif ((page >= csrow->first_page) &&\r\n(page <= csrow->last_page) &&\r\n((page & csrow->page_mask) ==\r\n(csrow->first_page & csrow->page_mask))) {\r\nrow = i;\r\nbreak;\r\n}\r\n}\r\nif (row == -1)\r\nedac_mc_printk(mci, KERN_ERR,\r\n"could not look up page error address %lx\n",\r\n(unsigned long)page);\r\nreturn row;\r\n}\r\nvoid edac_mc_handle_ce(struct mem_ctl_info *mci,\r\nunsigned long page_frame_number,\r\nunsigned long offset_in_page, unsigned long syndrome,\r\nint row, int channel, const char *msg)\r\n{\r\nunsigned long remapped_page;\r\ndebugf3("MC%d: %s()\n", mci->mc_idx, __func__);\r\nif (row >= mci->nr_csrows || row < 0) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: row out of range "\r\n"(%d >= %d)\n", row, mci->nr_csrows);\r\nedac_mc_handle_ce_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nif (channel >= mci->csrows[row].nr_channels || channel < 0) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: channel out of range "\r\n"(%d >= %d)\n", channel,\r\nmci->csrows[row].nr_channels);\r\nedac_mc_handle_ce_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nif (edac_mc_get_log_ce())\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"CE page 0x%lx, offset 0x%lx, grain %d, syndrome "\r\n"0x%lx, row %d, channel %d, label \"%s\": %s\n",\r\npage_frame_number, offset_in_page,\r\nmci->csrows[row].grain, syndrome, row, channel,\r\nmci->csrows[row].channels[channel].label, msg);\r\nmci->ce_count++;\r\nmci->csrows[row].ce_count++;\r\nmci->csrows[row].channels[channel].ce_count++;\r\nif (mci->scrub_mode & SCRUB_SW_SRC) {\r\nremapped_page = mci->ctl_page_to_phys ?\r\nmci->ctl_page_to_phys(mci, page_frame_number) :\r\npage_frame_number;\r\nedac_mc_scrub_block(remapped_page, offset_in_page,\r\nmci->csrows[row].grain);\r\n}\r\n}\r\nvoid edac_mc_handle_ce_no_info(struct mem_ctl_info *mci, const char *msg)\r\n{\r\nif (edac_mc_get_log_ce())\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"CE - no information available: %s\n", msg);\r\nmci->ce_noinfo_count++;\r\nmci->ce_count++;\r\n}\r\nvoid edac_mc_handle_ue(struct mem_ctl_info *mci,\r\nunsigned long page_frame_number,\r\nunsigned long offset_in_page, int row, const char *msg)\r\n{\r\nint len = EDAC_MC_LABEL_LEN * 4;\r\nchar labels[len + 1];\r\nchar *pos = labels;\r\nint chan;\r\nint chars;\r\ndebugf3("MC%d: %s()\n", mci->mc_idx, __func__);\r\nif (row >= mci->nr_csrows || row < 0) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: row out of range "\r\n"(%d >= %d)\n", row, mci->nr_csrows);\r\nedac_mc_handle_ue_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nchars = snprintf(pos, len + 1, "%s",\r\nmci->csrows[row].channels[0].label);\r\nlen -= chars;\r\npos += chars;\r\nfor (chan = 1; (chan < mci->csrows[row].nr_channels) && (len > 0);\r\nchan++) {\r\nchars = snprintf(pos, len + 1, ":%s",\r\nmci->csrows[row].channels[chan].label);\r\nlen -= chars;\r\npos += chars;\r\n}\r\nif (edac_mc_get_log_ue())\r\nedac_mc_printk(mci, KERN_EMERG,\r\n"UE page 0x%lx, offset 0x%lx, grain %d, row %d, "\r\n"labels \"%s\": %s\n", page_frame_number,\r\noffset_in_page, mci->csrows[row].grain, row,\r\nlabels, msg);\r\nif (edac_mc_get_panic_on_ue())\r\npanic("EDAC MC%d: UE page 0x%lx, offset 0x%lx, grain %d, "\r\n"row %d, labels \"%s\": %s\n", mci->mc_idx,\r\npage_frame_number, offset_in_page,\r\nmci->csrows[row].grain, row, labels, msg);\r\nmci->ue_count++;\r\nmci->csrows[row].ue_count++;\r\n}\r\nvoid edac_mc_handle_ue_no_info(struct mem_ctl_info *mci, const char *msg)\r\n{\r\nif (edac_mc_get_panic_on_ue())\r\npanic("EDAC MC%d: Uncorrected Error", mci->mc_idx);\r\nif (edac_mc_get_log_ue())\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"UE - no information available: %s\n", msg);\r\nmci->ue_noinfo_count++;\r\nmci->ue_count++;\r\n}\r\nvoid edac_mc_handle_fbd_ue(struct mem_ctl_info *mci,\r\nunsigned int csrow,\r\nunsigned int channela,\r\nunsigned int channelb, char *msg)\r\n{\r\nint len = EDAC_MC_LABEL_LEN * 4;\r\nchar labels[len + 1];\r\nchar *pos = labels;\r\nint chars;\r\nif (csrow >= mci->nr_csrows) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: row out of range (%d >= %d)\n",\r\ncsrow, mci->nr_csrows);\r\nedac_mc_handle_ue_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nif (channela >= mci->csrows[csrow].nr_channels) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: channel-a out of range "\r\n"(%d >= %d)\n",\r\nchannela, mci->csrows[csrow].nr_channels);\r\nedac_mc_handle_ue_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nif (channelb >= mci->csrows[csrow].nr_channels) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: channel-b out of range "\r\n"(%d >= %d)\n",\r\nchannelb, mci->csrows[csrow].nr_channels);\r\nedac_mc_handle_ue_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nmci->ue_count++;\r\nmci->csrows[csrow].ue_count++;\r\nchars = snprintf(pos, len + 1, "%s",\r\nmci->csrows[csrow].channels[channela].label);\r\nlen -= chars;\r\npos += chars;\r\nchars = snprintf(pos, len + 1, "-%s",\r\nmci->csrows[csrow].channels[channelb].label);\r\nif (edac_mc_get_log_ue())\r\nedac_mc_printk(mci, KERN_EMERG,\r\n"UE row %d, channel-a= %d channel-b= %d "\r\n"labels \"%s\": %s\n", csrow, channela, channelb,\r\nlabels, msg);\r\nif (edac_mc_get_panic_on_ue())\r\npanic("UE row %d, channel-a= %d channel-b= %d "\r\n"labels \"%s\": %s\n", csrow, channela,\r\nchannelb, labels, msg);\r\n}\r\nvoid edac_mc_handle_fbd_ce(struct mem_ctl_info *mci,\r\nunsigned int csrow, unsigned int channel, char *msg)\r\n{\r\nif (csrow >= mci->nr_csrows) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: row out of range (%d >= %d)\n",\r\ncsrow, mci->nr_csrows);\r\nedac_mc_handle_ce_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nif (channel >= mci->csrows[csrow].nr_channels) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"INTERNAL ERROR: channel out of range (%d >= %d)\n",\r\nchannel, mci->csrows[csrow].nr_channels);\r\nedac_mc_handle_ce_no_info(mci, "INTERNAL ERROR");\r\nreturn;\r\n}\r\nif (edac_mc_get_log_ce())\r\nedac_mc_printk(mci, KERN_WARNING,\r\n"CE row %d, channel %d, label \"%s\": %s\n",\r\ncsrow, channel,\r\nmci->csrows[csrow].channels[channel].label, msg);\r\nmci->ce_count++;\r\nmci->csrows[csrow].ce_count++;\r\nmci->csrows[csrow].channels[channel].ce_count++;\r\n}
