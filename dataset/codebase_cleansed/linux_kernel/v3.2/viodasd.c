static int viodasd_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct viodasd_device *d = bdev->bd_disk->private_data;\r\nHvLpEvent_Rc hvrc;\r\nstruct viodasd_waitevent we;\r\nu16 flags = 0;\r\nif (d->read_only) {\r\nif (mode & FMODE_WRITE)\r\nreturn -EROFS;\r\nflags = vioblockflags_ro;\r\n}\r\ninit_completion(&we.com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_blockio | vioblockopen,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)&we, VIOVERSION << 16,\r\n((u64)DEVICE_NO(d) << 48) | ((u64)flags << 32),\r\n0, 0, 0);\r\nif (hvrc != 0) {\r\npr_warning("HV open failed %d\n", (int)hvrc);\r\nreturn -EIO;\r\n}\r\nwait_for_completion(&we.com);\r\nif (we.rc != 0) {\r\nconst struct vio_error_entry *err =\r\nvio_lookup_rc(viodasd_err_table, we.sub_result);\r\npr_warning("bad rc opening disk: %d:0x%04x (%s)\n",\r\n(int)we.rc, we.sub_result, err->msg);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int viodasd_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&viodasd_mutex);\r\nret = viodasd_open(bdev, mode);\r\nmutex_unlock(&viodasd_mutex);\r\nreturn ret;\r\n}\r\nstatic int viodasd_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct viodasd_device *d = disk->private_data;\r\nHvLpEvent_Rc hvrc;\r\nmutex_lock(&viodasd_mutex);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_blockio | vioblockclose,\r\nHvLpEvent_AckInd_NoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n0, VIOVERSION << 16,\r\n((u64)DEVICE_NO(d) << 48) ,\r\n0, 0, 0);\r\nif (hvrc != 0)\r\npr_warning("HV close call failed %d\n", (int)hvrc);\r\nmutex_unlock(&viodasd_mutex);\r\nreturn 0;\r\n}\r\nstatic int viodasd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nstruct viodasd_device *d = disk->private_data;\r\ngeo->sectors = d->sectors ? d->sectors : 32;\r\ngeo->heads = d->tracks ? d->tracks : 64;\r\ngeo->cylinders = d->cylinders ? d->cylinders :\r\nget_capacity(disk) / (geo->sectors * geo->heads);\r\nreturn 0;\r\n}\r\nstatic void viodasd_end_request(struct request *req, int error,\r\nint num_sectors)\r\n{\r\n__blk_end_request(req, error, num_sectors << 9);\r\n}\r\nstatic int send_request(struct request *req)\r\n{\r\nu64 start;\r\nint direction;\r\nint nsg;\r\nu16 viocmd;\r\nHvLpEvent_Rc hvrc;\r\nstruct vioblocklpevent *bevent;\r\nstruct HvLpEvent *hev;\r\nstruct scatterlist sg[VIOMAXBLOCKDMA];\r\nint sgindex;\r\nstruct viodasd_device *d;\r\nunsigned long flags;\r\nstart = (u64)blk_rq_pos(req) << 9;\r\nif (rq_data_dir(req) == READ) {\r\ndirection = DMA_FROM_DEVICE;\r\nviocmd = viomajorsubtype_blockio | vioblockread;\r\n} else {\r\ndirection = DMA_TO_DEVICE;\r\nviocmd = viomajorsubtype_blockio | vioblockwrite;\r\n}\r\nd = req->rq_disk->private_data;\r\nsg_init_table(sg, VIOMAXBLOCKDMA);\r\nnsg = blk_rq_map_sg(req->q, req, sg);\r\nnsg = dma_map_sg(d->dev, sg, nsg, direction);\r\nspin_lock_irqsave(&viodasd_spinlock, flags);\r\nnum_req_outstanding++;\r\nif (nsg == 1)\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo, viocmd,\r\nHvLpEvent_AckInd_DoAck,\r\nHvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)req, VIOVERSION << 16,\r\n((u64)DEVICE_NO(d) << 48), start,\r\n((u64)sg_dma_address(&sg[0])) << 32,\r\nsg_dma_len(&sg[0]));\r\nelse {\r\nbevent = (struct vioblocklpevent *)\r\nvio_get_event_buffer(viomajorsubtype_blockio);\r\nif (bevent == NULL) {\r\npr_warning("error allocating disk event buffer\n");\r\ngoto error_ret;\r\n}\r\nmemset(bevent, 0, sizeof(struct vioblocklpevent));\r\nhev = &bevent->event;\r\nhev->flags = HV_LP_EVENT_VALID | HV_LP_EVENT_DO_ACK |\r\nHV_LP_EVENT_INT;\r\nhev->xType = HvLpEvent_Type_VirtualIo;\r\nhev->xSubtype = viocmd;\r\nhev->xSourceLp = HvLpConfig_getLpIndex();\r\nhev->xTargetLp = viopath_hostLp;\r\nhev->xSizeMinus1 =\r\noffsetof(struct vioblocklpevent, u.rw_data.dma_info) +\r\n(sizeof(bevent->u.rw_data.dma_info[0]) * nsg) - 1;\r\nhev->xSourceInstanceId = viopath_sourceinst(viopath_hostLp);\r\nhev->xTargetInstanceId = viopath_targetinst(viopath_hostLp);\r\nhev->xCorrelationToken = (u64)req;\r\nbevent->version = VIOVERSION;\r\nbevent->disk = DEVICE_NO(d);\r\nbevent->u.rw_data.offset = start;\r\nfor (sgindex = 0; sgindex < nsg; sgindex++) {\r\nbevent->u.rw_data.dma_info[sgindex].token =\r\nsg_dma_address(&sg[sgindex]);\r\nbevent->u.rw_data.dma_info[sgindex].len =\r\nsg_dma_len(&sg[sgindex]);\r\n}\r\nhvrc = HvCallEvent_signalLpEvent(&bevent->event);\r\nvio_free_event_buffer(viomajorsubtype_blockio, bevent);\r\n}\r\nif (hvrc != HvLpEvent_Rc_Good) {\r\npr_warning("error sending disk event to OS/400 (rc %d)\n",\r\n(int)hvrc);\r\ngoto error_ret;\r\n}\r\nspin_unlock_irqrestore(&viodasd_spinlock, flags);\r\nreturn 0;\r\nerror_ret:\r\nnum_req_outstanding--;\r\nspin_unlock_irqrestore(&viodasd_spinlock, flags);\r\ndma_unmap_sg(d->dev, sg, nsg, direction);\r\nreturn -1;\r\n}\r\nstatic void do_viodasd_request(struct request_queue *q)\r\n{\r\nstruct request *req;\r\nwhile (num_req_outstanding < VIOMAXREQ) {\r\nreq = blk_fetch_request(q);\r\nif (req == NULL)\r\nreturn;\r\nif (req->cmd_type != REQ_TYPE_FS) {\r\nviodasd_end_request(req, -EIO, blk_rq_sectors(req));\r\ncontinue;\r\n}\r\nif (send_request(req) != 0)\r\nviodasd_end_request(req, -EIO, blk_rq_sectors(req));\r\n}\r\n}\r\nstatic int probe_disk(struct viodasd_device *d)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nstruct viodasd_waitevent we;\r\nint dev_no = DEVICE_NO(d);\r\nstruct gendisk *g;\r\nstruct request_queue *q;\r\nu16 flags = 0;\r\nretry:\r\ninit_completion(&we.com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_blockio | vioblockopen,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)(unsigned long)&we, VIOVERSION << 16,\r\n((u64)dev_no << 48) | ((u64)flags<< 32),\r\n0, 0, 0);\r\nif (hvrc != 0) {\r\npr_warning("bad rc on HV open %d\n", (int)hvrc);\r\nreturn 0;\r\n}\r\nwait_for_completion(&we.com);\r\nif (we.rc != 0) {\r\nif (flags != 0)\r\nreturn 0;\r\nflags = vioblockflags_ro;\r\ngoto retry;\r\n}\r\nif (we.max_disk > (MAX_DISKNO - 1)) {\r\nprintk_once(KERN_INFO pr_fmt("Only examining the first %d of %d disks connected\n"),\r\nMAX_DISKNO, we.max_disk + 1);\r\n}\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_blockio | vioblockclose,\r\nHvLpEvent_AckInd_NoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n0, VIOVERSION << 16,\r\n((u64)dev_no << 48) | ((u64)flags << 32),\r\n0, 0, 0);\r\nif (hvrc != 0) {\r\npr_warning("bad rc sending event to OS/400 %d\n", (int)hvrc);\r\nreturn 0;\r\n}\r\nif (d->dev == NULL) {\r\nif (vio_create_viodasd(dev_no) == NULL) {\r\npr_warning("cannot allocate virtual device for disk %d\n",\r\ndev_no);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nspin_lock_init(&d->q_lock);\r\nq = blk_init_queue(do_viodasd_request, &d->q_lock);\r\nif (q == NULL) {\r\npr_warning("cannot allocate queue for disk %d\n", dev_no);\r\nreturn 0;\r\n}\r\ng = alloc_disk(1 << PARTITION_SHIFT);\r\nif (g == NULL) {\r\npr_warning("cannot allocate disk structure for disk %d\n",\r\ndev_no);\r\nblk_cleanup_queue(q);\r\nreturn 0;\r\n}\r\nd->disk = g;\r\nblk_queue_max_segments(q, VIOMAXBLOCKDMA);\r\nblk_queue_max_hw_sectors(q, VIODASD_MAXSECTORS);\r\ng->major = VIODASD_MAJOR;\r\ng->first_minor = dev_no << PARTITION_SHIFT;\r\nif (dev_no >= 26)\r\nsnprintf(g->disk_name, sizeof(g->disk_name),\r\nVIOD_GENHD_NAME "%c%c",\r\n'a' + (dev_no / 26) - 1, 'a' + (dev_no % 26));\r\nelse\r\nsnprintf(g->disk_name, sizeof(g->disk_name),\r\nVIOD_GENHD_NAME "%c", 'a' + (dev_no % 26));\r\ng->fops = &viodasd_fops;\r\ng->queue = q;\r\ng->private_data = d;\r\ng->driverfs_dev = d->dev;\r\nset_capacity(g, d->size >> 9);\r\npr_info("disk %d: %lu sectors (%lu MB) CHS=%d/%d/%d sector size %d%s\n",\r\ndev_no, (unsigned long)(d->size >> 9),\r\n(unsigned long)(d->size >> 20),\r\n(int)d->cylinders, (int)d->tracks,\r\n(int)d->sectors, (int)d->bytes_per_sector,\r\nd->read_only ? " (RO)" : "");\r\nadd_disk(g);\r\nreturn 1;\r\n}\r\nstatic int block_event_to_scatterlist(const struct vioblocklpevent *bevent,\r\nstruct scatterlist *sg, int *total_len)\r\n{\r\nint i, numsg;\r\nconst struct rw_data *rw_data = &bevent->u.rw_data;\r\nstatic const int offset =\r\noffsetof(struct vioblocklpevent, u.rw_data.dma_info);\r\nstatic const int element_size = sizeof(rw_data->dma_info[0]);\r\nnumsg = ((bevent->event.xSizeMinus1 + 1) - offset) / element_size;\r\nif (numsg > VIOMAXBLOCKDMA)\r\nnumsg = VIOMAXBLOCKDMA;\r\n*total_len = 0;\r\nsg_init_table(sg, VIOMAXBLOCKDMA);\r\nfor (i = 0; (i < numsg) && (rw_data->dma_info[i].len > 0); ++i) {\r\nsg_dma_address(&sg[i]) = rw_data->dma_info[i].token;\r\nsg_dma_len(&sg[i]) = rw_data->dma_info[i].len;\r\n*total_len += rw_data->dma_info[i].len;\r\n}\r\nreturn i;\r\n}\r\nstatic void viodasd_restart_all_queues_starting_from(int first_index)\r\n{\r\nint i;\r\nfor (i = first_index + 1; i < MAX_DISKNO; ++i)\r\nif (viodasd_devices[i].disk)\r\nblk_run_queue(viodasd_devices[i].disk->queue);\r\nfor (i = 0; i <= first_index; ++i)\r\nif (viodasd_devices[i].disk)\r\nblk_run_queue(viodasd_devices[i].disk->queue);\r\n}\r\nstatic int viodasd_handle_read_write(struct vioblocklpevent *bevent)\r\n{\r\nint num_sg, num_sect, pci_direction, total_len;\r\nstruct request *req;\r\nstruct scatterlist sg[VIOMAXBLOCKDMA];\r\nstruct HvLpEvent *event = &bevent->event;\r\nunsigned long irq_flags;\r\nstruct viodasd_device *d;\r\nint error;\r\nspinlock_t *qlock;\r\nnum_sg = block_event_to_scatterlist(bevent, sg, &total_len);\r\nnum_sect = total_len >> 9;\r\nif (event->xSubtype == (viomajorsubtype_blockio | vioblockread))\r\npci_direction = DMA_FROM_DEVICE;\r\nelse\r\npci_direction = DMA_TO_DEVICE;\r\nreq = (struct request *)bevent->event.xCorrelationToken;\r\nd = req->rq_disk->private_data;\r\ndma_unmap_sg(d->dev, sg, num_sg, pci_direction);\r\nspin_lock_irqsave(&viodasd_spinlock, irq_flags);\r\nnum_req_outstanding--;\r\nspin_unlock_irqrestore(&viodasd_spinlock, irq_flags);\r\nerror = (event->xRc == HvLpEvent_Rc_Good) ? 0 : -EIO;\r\nif (error) {\r\nconst struct vio_error_entry *err;\r\nerr = vio_lookup_rc(viodasd_err_table, bevent->sub_result);\r\npr_warning("read/write error %d:0x%04x (%s)\n",\r\nevent->xRc, bevent->sub_result, err->msg);\r\nnum_sect = blk_rq_sectors(req);\r\n}\r\nqlock = req->q->queue_lock;\r\nspin_lock_irqsave(qlock, irq_flags);\r\nviodasd_end_request(req, error, num_sect);\r\nspin_unlock_irqrestore(qlock, irq_flags);\r\nviodasd_restart_all_queues_starting_from(DEVICE_NO(d));\r\nreturn 0;\r\n}\r\nstatic void handle_block_event(struct HvLpEvent *event)\r\n{\r\nstruct vioblocklpevent *bevent = (struct vioblocklpevent *)event;\r\nstruct viodasd_waitevent *pwe;\r\nif (event == NULL)\r\nreturn;\r\nif (hvlpevent_is_int(event)) {\r\npr_warning("Yikes! got an int in viodasd event handler!\n");\r\nif (hvlpevent_need_ack(event)) {\r\nevent->xRc = HvLpEvent_Rc_InvalidSubtype;\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\n}\r\nswitch (event->xSubtype & VIOMINOR_SUBTYPE_MASK) {\r\ncase vioblockopen:\r\npwe = (struct viodasd_waitevent *)event->xCorrelationToken;\r\npwe->rc = event->xRc;\r\npwe->sub_result = bevent->sub_result;\r\nif (event->xRc == HvLpEvent_Rc_Good) {\r\nconst struct open_data *data = &bevent->u.open_data;\r\nstruct viodasd_device *device =\r\n&viodasd_devices[bevent->disk];\r\ndevice->read_only =\r\nbevent->flags & vioblockflags_ro;\r\ndevice->size = data->disk_size;\r\ndevice->cylinders = data->cylinders;\r\ndevice->tracks = data->tracks;\r\ndevice->sectors = data->sectors;\r\ndevice->bytes_per_sector = data->bytes_per_sector;\r\npwe->max_disk = data->max_disk;\r\n}\r\ncomplete(&pwe->com);\r\nbreak;\r\ncase vioblockclose:\r\nbreak;\r\ncase vioblockread:\r\ncase vioblockwrite:\r\nviodasd_handle_read_write(bevent);\r\nbreak;\r\ndefault:\r\npr_warning("invalid subtype!");\r\nif (hvlpevent_need_ack(event)) {\r\nevent->xRc = HvLpEvent_Rc_InvalidSubtype;\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\n}\r\n}\r\nstatic ssize_t probe_disks(struct device_driver *drv, const char *buf,\r\nsize_t count)\r\n{\r\nstruct viodasd_device *d;\r\nfor (d = viodasd_devices; d < &viodasd_devices[MAX_DISKNO]; d++) {\r\nif (d->disk == NULL)\r\nprobe_disk(d);\r\n}\r\nreturn count;\r\n}\r\nstatic int viodasd_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nstruct viodasd_device *d = &viodasd_devices[vdev->unit_address];\r\nd->dev = &vdev->dev;\r\nif (!probe_disk(d))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int viodasd_remove(struct vio_dev *vdev)\r\n{\r\nstruct viodasd_device *d;\r\nd = &viodasd_devices[vdev->unit_address];\r\nif (d->disk) {\r\ndel_gendisk(d->disk);\r\nblk_cleanup_queue(d->disk->queue);\r\nput_disk(d->disk);\r\nd->disk = NULL;\r\n}\r\nd->dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init viodasd_init(void)\r\n{\r\nint rc;\r\nif (!firmware_has_feature(FW_FEATURE_ISERIES)) {\r\nrc = -ENODEV;\r\ngoto early_fail;\r\n}\r\nif (viopath_hostLp == HvLpIndexInvalid)\r\nvio_set_hostlp();\r\nif (viopath_hostLp == HvLpIndexInvalid) {\r\npr_warning("invalid hosting partition\n");\r\nrc = -EIO;\r\ngoto early_fail;\r\n}\r\npr_info("vers " VIOD_VERS ", hosting partition %d\n", viopath_hostLp);\r\nrc = register_blkdev(VIODASD_MAJOR, VIOD_GENHD_NAME);\r\nif (rc) {\r\npr_warning("Unable to get major number %d for %s\n",\r\nVIODASD_MAJOR, VIOD_GENHD_NAME);\r\ngoto early_fail;\r\n}\r\nrc = viopath_open(viopath_hostLp, viomajorsubtype_blockio,\r\nVIOMAXREQ + 2);\r\nif (rc) {\r\npr_warning("error opening path to host partition %d\n",\r\nviopath_hostLp);\r\ngoto unregister_blk;\r\n}\r\nvio_setHandler(viomajorsubtype_blockio, handle_block_event);\r\nrc = vio_register_driver(&viodasd_driver);\r\nif (rc) {\r\npr_warning("vio_register_driver failed\n");\r\ngoto unset_handler;\r\n}\r\nif (!driver_create_file(&viodasd_driver.driver, &driver_attr_probe))\r\nneed_delete_probe = 1;\r\nreturn 0;\r\nunset_handler:\r\nvio_clearHandler(viomajorsubtype_blockio);\r\nviopath_close(viopath_hostLp, viomajorsubtype_blockio, VIOMAXREQ + 2);\r\nunregister_blk:\r\nunregister_blkdev(VIODASD_MAJOR, VIOD_GENHD_NAME);\r\nearly_fail:\r\nreturn rc;\r\n}\r\nvoid __exit viodasd_exit(void)\r\n{\r\nif (need_delete_probe)\r\ndriver_remove_file(&viodasd_driver.driver, &driver_attr_probe);\r\nvio_unregister_driver(&viodasd_driver);\r\nvio_clearHandler(viomajorsubtype_blockio);\r\nviopath_close(viopath_hostLp, viomajorsubtype_blockio, VIOMAXREQ + 2);\r\nunregister_blkdev(VIODASD_MAJOR, VIOD_GENHD_NAME);\r\n}
