static unsigned int jsf_inl(unsigned long addr)\r\n{\r\nunsigned long retval;\r\n__asm__ __volatile__("lda [%1] %2, %0\n\t" :\r\n"=r" (retval) :\r\n"r" (addr), "i" (ASI_M_BYPASS));\r\nreturn retval;\r\n}\r\nstatic void jsf_outl(unsigned long addr, __u32 data)\r\n{\r\n__asm__ __volatile__("sta %0, [%1] %2\n\t" : :\r\n"r" (data), "r" (addr), "i" (ASI_M_BYPASS) :\r\n"memory");\r\n}\r\nstatic void jsf_wait(unsigned long p) {\r\nunsigned int x1, x2;\r\nfor (;;) {\r\nx1 = jsf_inl(p);\r\nx2 = jsf_inl(p);\r\nif ((x1 & 0x40404040) == (x2 & 0x40404040)) return;\r\n}\r\n}\r\nstatic void jsf_write4(unsigned long fa, u32 data) {\r\njsf_outl(fa, 0xAAAAAAAA);\r\njsf_outl(fa, 0x55555555);\r\njsf_outl(fa, 0xA0A0A0A0);\r\njsf_outl(fa, data);\r\njsf_wait(fa);\r\n}\r\nstatic void jsfd_read(char *buf, unsigned long p, size_t togo) {\r\nunion byte4 {\r\nchar s[4];\r\nunsigned int n;\r\n} b;\r\nwhile (togo >= 4) {\r\ntogo -= 4;\r\nb.n = jsf_inl(p);\r\nmemcpy(buf, b.s, 4);\r\np += 4;\r\nbuf += 4;\r\n}\r\n}\r\nstatic void jsfd_do_request(struct request_queue *q)\r\n{\r\nstruct request *req;\r\nreq = blk_fetch_request(q);\r\nwhile (req) {\r\nstruct jsfd_part *jdp = req->rq_disk->private_data;\r\nunsigned long offset = blk_rq_pos(req) << 9;\r\nsize_t len = blk_rq_cur_bytes(req);\r\nint err = -EIO;\r\nif ((offset + len) > jdp->dsize)\r\ngoto end;\r\nif (rq_data_dir(req) != READ) {\r\nprintk(KERN_ERR "jsfd: write\n");\r\ngoto end;\r\n}\r\nif ((jdp->dbase & 0xff000000) != 0x20000000) {\r\nprintk(KERN_ERR "jsfd: bad base %x\n", (int)jdp->dbase);\r\ngoto end;\r\n}\r\njsfd_read(req->buffer, jdp->dbase + offset, len);\r\nerr = 0;\r\nend:\r\nif (!__blk_end_request_cur(req, err))\r\nreq = blk_fetch_request(q);\r\n}\r\n}\r\nstatic loff_t jsf_lseek(struct file * file, loff_t offset, int orig)\r\n{\r\nloff_t ret;\r\nmutex_lock(&jsf_mutex);\r\nswitch (orig) {\r\ncase 0:\r\nfile->f_pos = offset;\r\nret = file->f_pos;\r\nbreak;\r\ncase 1:\r\nfile->f_pos += offset;\r\nret = file->f_pos;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&jsf_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t jsf_read(struct file * file, char __user * buf,\r\nsize_t togo, loff_t *ppos)\r\n{\r\nunsigned long p = *ppos;\r\nchar __user *tmp = buf;\r\nunion byte4 {\r\nchar s[4];\r\nunsigned int n;\r\n} b;\r\nif (p < JSF_BASE_ALL || p >= JSF_BASE_TOP) {\r\nreturn 0;\r\n}\r\nif ((p + togo) < p\r\n|| (p + togo) >= JSF_BASE_TOP) {\r\ntogo = JSF_BASE_TOP - p;\r\n}\r\nif (p < JSF_BASE_ALL && togo != 0) {\r\n#if 0\r\nsize_t x = JSF_BASE_ALL - p;\r\nif (x > togo) x = togo;\r\nclear_user(tmp, x);\r\ntmp += x;\r\np += x;\r\ntogo -= x;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nwhile (togo >= 4) {\r\ntogo -= 4;\r\nb.n = jsf_inl(p);\r\nif (copy_to_user(tmp, b.s, 4))\r\nreturn -EFAULT;\r\ntmp += 4;\r\np += 4;\r\n}\r\n*ppos = p;\r\nreturn tmp-buf;\r\n}\r\nstatic ssize_t jsf_write(struct file * file, const char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn -ENOSPC;\r\n}\r\nstatic int jsf_ioctl_erase(unsigned long arg)\r\n{\r\nunsigned long p;\r\np = 0x20400000;\r\njsf_outl(p, 0xAAAAAAAA);\r\njsf_outl(p, 0x55555555);\r\njsf_outl(p, 0x80808080);\r\njsf_outl(p, 0xAAAAAAAA);\r\njsf_outl(p, 0x55555555);\r\njsf_outl(p, 0x10101010);\r\n#if 0\r\n{\r\nint i;\r\n__u32 x;\r\nfor (i = 0; i < 1000000; i++) {\r\nx = jsf_inl(p);\r\nif ((x & 0x80808080) == 0x80808080) break;\r\n}\r\nif ((x & 0x80808080) != 0x80808080) {\r\nprintk("jsf0: erase timeout with 0x%08x\n", x);\r\n} else {\r\nprintk("jsf0: erase done with 0x%08x\n", x);\r\n}\r\n}\r\n#else\r\njsf_wait(p);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int jsf_ioctl_program(void __user *arg)\r\n{\r\nstruct jsflash_program_arg abuf;\r\nchar __user *uptr;\r\nunsigned long p;\r\nunsigned int togo;\r\nunion {\r\nunsigned int n;\r\nchar s[4];\r\n} b;\r\nif (copy_from_user(&abuf, arg, JSFPRGSZ))\r\nreturn -EFAULT;\r\np = abuf.off;\r\ntogo = abuf.size;\r\nif ((togo & 3) || (p & 3)) return -EINVAL;\r\nuptr = (char __user *) (unsigned long) abuf.data;\r\nwhile (togo != 0) {\r\ntogo -= 4;\r\nif (copy_from_user(&b.s[0], uptr, 4))\r\nreturn -EFAULT;\r\njsf_write4(p, b.n);\r\np += 4;\r\nuptr += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic long jsf_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nmutex_lock(&jsf_mutex);\r\nint error = -ENOTTY;\r\nvoid __user *argp = (void __user *)arg;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nmutex_unlock(&jsf_mutex);\r\nreturn -EPERM;\r\n}\r\nswitch (cmd) {\r\ncase JSFLASH_IDENT:\r\nif (copy_to_user(argp, &jsf0.id, JSFIDSZ)) {\r\nmutex_unlock(&jsf_mutex);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase JSFLASH_ERASE:\r\nerror = jsf_ioctl_erase(arg);\r\nbreak;\r\ncase JSFLASH_PROGRAM:\r\nerror = jsf_ioctl_program(argp);\r\nbreak;\r\n}\r\nmutex_unlock(&jsf_mutex);\r\nreturn error;\r\n}\r\nstatic int jsf_mmap(struct file * file, struct vm_area_struct * vma)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic int jsf_open(struct inode * inode, struct file * filp)\r\n{\r\nmutex_lock(&jsf_mutex);\r\nif (jsf0.base == 0) {\r\nmutex_unlock(&jsf_mutex);\r\nreturn -ENXIO;\r\n}\r\nif (test_and_set_bit(0, (void *)&jsf0.busy) != 0) {\r\nmutex_unlock(&jsf_mutex);\r\nreturn -EBUSY;\r\n}\r\nmutex_unlock(&jsf_mutex);\r\nreturn 0;\r\n}\r\nstatic int jsf_release(struct inode *inode, struct file *file)\r\n{\r\njsf0.busy = 0;\r\nreturn 0;\r\n}\r\nstatic int jsflash_init(void)\r\n{\r\nint rc;\r\nstruct jsflash *jsf;\r\nphandle node;\r\nchar banner[128];\r\nstruct linux_prom_registers reg0;\r\nnode = prom_getchild(prom_root_node);\r\nnode = prom_searchsiblings(node, "flash-memory");\r\nif (node != 0 && (s32)node != -1) {\r\nif (prom_getproperty(node, "reg",\r\n(char *)&reg0, sizeof(reg0)) == -1) {\r\nprintk("jsflash: no \"reg\" property\n");\r\nreturn -ENXIO;\r\n}\r\nif (reg0.which_io != 0) {\r\nprintk("jsflash: bus number nonzero: 0x%x:%x\n",\r\nreg0.which_io, reg0.phys_addr);\r\nreturn -ENXIO;\r\n}\r\n#if 0\r\nif ((reg0.phys_addr >> 24) != 0x20) {\r\nprintk("jsflash: suspicious address: 0x%x:%x\n",\r\nreg0.which_io, reg0.phys_addr);\r\nreturn -ENXIO;\r\n}\r\n#endif\r\nif ((int)reg0.reg_size <= 0) {\r\nprintk("jsflash: bad size 0x%x\n", (int)reg0.reg_size);\r\nreturn -ENXIO;\r\n}\r\n} else {\r\nprintk("jsflash: no /flash-memory node, use PROLL >= 12\n");\r\nprom_getproperty(prom_root_node, "banner-name", banner, 128);\r\nif (strcmp (banner, "JavaStation-NC") != 0 &&\r\nstrcmp (banner, "JavaStation-E") != 0) {\r\nreturn -ENXIO;\r\n}\r\nreg0.which_io = 0;\r\nreg0.phys_addr = 0x20400000;\r\nreg0.reg_size = 0x00800000;\r\n}\r\nif (sparc_cpu_model != sun4m) {\r\nreturn -ENXIO;\r\n}\r\nif (jsf0.base == 0) {\r\njsf = &jsf0;\r\njsf->base = reg0.phys_addr;\r\njsf->size = reg0.reg_size;\r\njsf->id.off = JSF_BASE_ALL;\r\njsf->id.size = 0x01000000;\r\nstrcpy(jsf->id.name, "Krups_all");\r\njsf->dv[0].dbase = jsf->base;\r\njsf->dv[0].dsize = jsf->size;\r\njsf->dv[1].dbase = jsf->base + 1024;\r\njsf->dv[1].dsize = jsf->size - 1024;\r\njsf->dv[2].dbase = JSF_BASE_ALL;\r\njsf->dv[2].dsize = 0x01000000;\r\nprintk("Espresso Flash @0x%lx [%d MB]\n", jsf->base,\r\n(int) (jsf->size / (1024*1024)));\r\n}\r\nif ((rc = misc_register(&jsf_dev)) != 0) {\r\nprintk(KERN_ERR "jsf: unable to get misc minor %d\n",\r\nJSF_MINOR);\r\njsf0.base = 0;\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jsfd_init(void)\r\n{\r\nstatic DEFINE_SPINLOCK(lock);\r\nstruct jsflash *jsf;\r\nstruct jsfd_part *jdp;\r\nint err;\r\nint i;\r\nif (jsf0.base == 0)\r\nreturn -ENXIO;\r\nerr = -ENOMEM;\r\nfor (i = 0; i < JSF_MAX; i++) {\r\nstruct gendisk *disk = alloc_disk(1);\r\nif (!disk)\r\ngoto out;\r\njsfd_disk[i] = disk;\r\n}\r\nif (register_blkdev(JSFD_MAJOR, "jsfd")) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\njsf_queue = blk_init_queue(jsfd_do_request, &lock);\r\nif (!jsf_queue) {\r\nerr = -ENOMEM;\r\nunregister_blkdev(JSFD_MAJOR, "jsfd");\r\ngoto out;\r\n}\r\nfor (i = 0; i < JSF_MAX; i++) {\r\nstruct gendisk *disk = jsfd_disk[i];\r\nif ((i & JSF_PART_MASK) >= JSF_NPART) continue;\r\njsf = &jsf0;\r\njdp = &jsf->dv[i&JSF_PART_MASK];\r\ndisk->major = JSFD_MAJOR;\r\ndisk->first_minor = i;\r\nsprintf(disk->disk_name, "jsfd%d", i);\r\ndisk->fops = &jsfd_fops;\r\nset_capacity(disk, jdp->dsize >> 9);\r\ndisk->private_data = jdp;\r\ndisk->queue = jsf_queue;\r\nadd_disk(disk);\r\nset_disk_ro(disk, 1);\r\n}\r\nreturn 0;\r\nout:\r\nwhile (i--)\r\nput_disk(jsfd_disk[i]);\r\nreturn err;\r\n}\r\nstatic int __init jsflash_init_module(void) {\r\nint rc;\r\nif ((rc = jsflash_init()) == 0) {\r\njsfd_init();\r\nreturn 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit jsflash_cleanup_module(void)\r\n{\r\nint i;\r\nfor (i = 0; i < JSF_MAX; i++) {\r\nif ((i & JSF_PART_MASK) >= JSF_NPART) continue;\r\ndel_gendisk(jsfd_disk[i]);\r\nput_disk(jsfd_disk[i]);\r\n}\r\nif (jsf0.busy)\r\nprintk("jsf0: cleaning busy unit\n");\r\njsf0.base = 0;\r\njsf0.busy = 0;\r\nmisc_deregister(&jsf_dev);\r\nunregister_blkdev(JSFD_MAJOR, "jsfd");\r\nblk_cleanup_queue(jsf_queue);\r\n}
