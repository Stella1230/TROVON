static inline int get_tx_head_mb(struct ti_hecc_priv *priv)\r\n{\r\nreturn priv->tx_head & HECC_TX_MB_MASK;\r\n}\r\nstatic inline int get_tx_tail_mb(struct ti_hecc_priv *priv)\r\n{\r\nreturn priv->tx_tail & HECC_TX_MB_MASK;\r\n}\r\nstatic inline int get_tx_head_prio(struct ti_hecc_priv *priv)\r\n{\r\nreturn (priv->tx_head >> HECC_TX_PRIO_SHIFT) & MAX_TX_PRIO;\r\n}\r\nstatic inline void hecc_write_lam(struct ti_hecc_priv *priv, u32 mbxno, u32 val)\r\n{\r\n__raw_writel(val, priv->base + priv->hecc_ram_offset + mbxno * 4);\r\n}\r\nstatic inline void hecc_write_mbx(struct ti_hecc_priv *priv, u32 mbxno,\r\nu32 reg, u32 val)\r\n{\r\n__raw_writel(val, priv->base + priv->mbx_offset + mbxno * 0x10 +\r\nreg);\r\n}\r\nstatic inline u32 hecc_read_mbx(struct ti_hecc_priv *priv, u32 mbxno, u32 reg)\r\n{\r\nreturn __raw_readl(priv->base + priv->mbx_offset + mbxno * 0x10 +\r\nreg);\r\n}\r\nstatic inline void hecc_write(struct ti_hecc_priv *priv, u32 reg, u32 val)\r\n{\r\n__raw_writel(val, priv->base + reg);\r\n}\r\nstatic inline u32 hecc_read(struct ti_hecc_priv *priv, int reg)\r\n{\r\nreturn __raw_readl(priv->base + reg);\r\n}\r\nstatic inline void hecc_set_bit(struct ti_hecc_priv *priv, int reg,\r\nu32 bit_mask)\r\n{\r\nhecc_write(priv, reg, hecc_read(priv, reg) | bit_mask);\r\n}\r\nstatic inline void hecc_clear_bit(struct ti_hecc_priv *priv, int reg,\r\nu32 bit_mask)\r\n{\r\nhecc_write(priv, reg, hecc_read(priv, reg) & ~bit_mask);\r\n}\r\nstatic inline u32 hecc_get_bit(struct ti_hecc_priv *priv, int reg, u32 bit_mask)\r\n{\r\nreturn (hecc_read(priv, reg) & bit_mask) ? 1 : 0;\r\n}\r\nstatic int ti_hecc_get_state(const struct net_device *ndev,\r\nenum can_state *state)\r\n{\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\n*state = priv->can.state;\r\nreturn 0;\r\n}\r\nstatic int ti_hecc_set_btc(struct ti_hecc_priv *priv)\r\n{\r\nstruct can_bittiming *bit_timing = &priv->can.bittiming;\r\nu32 can_btc;\r\ncan_btc = (bit_timing->phase_seg2 - 1) & 0x7;\r\ncan_btc |= ((bit_timing->phase_seg1 + bit_timing->prop_seg - 1)\r\n& 0xF) << 3;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) {\r\nif (bit_timing->brp > 4)\r\ncan_btc |= HECC_CANBTC_SAM;\r\nelse\r\ndev_warn(priv->ndev->dev.parent, "WARN: Triple" \\r\n"sampling not set due to h/w limitations");\r\n}\r\ncan_btc |= ((bit_timing->sjw - 1) & 0x3) << 8;\r\ncan_btc |= ((bit_timing->brp - 1) & 0xFF) << 16;\r\nhecc_write(priv, HECC_CANBTC, can_btc);\r\ndev_info(priv->ndev->dev.parent, "setting CANBTC=%#x\n", can_btc);\r\nreturn 0;\r\n}\r\nstatic void ti_hecc_transceiver_switch(const struct ti_hecc_priv *priv,\r\nint on)\r\n{\r\nif (priv->transceiver_switch)\r\npriv->transceiver_switch(on);\r\n}\r\nstatic void ti_hecc_reset(struct net_device *ndev)\r\n{\r\nu32 cnt;\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\ndev_dbg(ndev->dev.parent, "resetting hecc ...\n");\r\nhecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SRES);\r\nhecc_set_bit(priv, HECC_CANMC, HECC_CANMC_CCR);\r\ncnt = HECC_CCE_WAIT_COUNT;\r\nwhile (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) && cnt != 0) {\r\n--cnt;\r\nudelay(10);\r\n}\r\nti_hecc_set_btc(priv);\r\nhecc_write(priv, HECC_CANMC, 0);\r\ncnt = HECC_CCE_WAIT_COUNT;\r\nwhile (hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) && cnt != 0) {\r\n--cnt;\r\nudelay(10);\r\n}\r\nhecc_write(priv, HECC_CANTIOC, HECC_CANTIOC_EN);\r\nhecc_write(priv, HECC_CANRIOC, HECC_CANRIOC_EN);\r\nhecc_write(priv, HECC_CANTA, HECC_SET_REG);\r\nhecc_write(priv, HECC_CANRMP, HECC_SET_REG);\r\nhecc_write(priv, HECC_CANGIF0, HECC_SET_REG);\r\nhecc_write(priv, HECC_CANGIF1, HECC_SET_REG);\r\nhecc_write(priv, HECC_CANME, 0);\r\nhecc_write(priv, HECC_CANMD, 0);\r\nhecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SCM);\r\n}\r\nstatic void ti_hecc_start(struct net_device *ndev)\r\n{\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nu32 cnt, mbxno, mbx_mask;\r\nti_hecc_reset(ndev);\r\npriv->tx_head = priv->tx_tail = HECC_TX_MASK;\r\npriv->rx_next = HECC_RX_FIRST_MBOX;\r\nhecc_write(priv, HECC_CANGAM, HECC_SET_REG);\r\nfor (cnt = 0; cnt < HECC_MAX_RX_MBOX; cnt++) {\r\nmbxno = HECC_MAX_MAILBOXES - 1 - cnt;\r\nmbx_mask = BIT(mbxno);\r\nhecc_clear_bit(priv, HECC_CANME, mbx_mask);\r\nhecc_write_mbx(priv, mbxno, HECC_CANMID, HECC_CANMID_AME);\r\nhecc_write_lam(priv, mbxno, HECC_SET_REG);\r\nhecc_set_bit(priv, HECC_CANMD, mbx_mask);\r\nhecc_set_bit(priv, HECC_CANME, mbx_mask);\r\nhecc_set_bit(priv, HECC_CANMIM, mbx_mask);\r\n}\r\nhecc_write(priv, HECC_CANOPC, HECC_SET_REG);\r\nif (priv->int_line) {\r\nhecc_write(priv, HECC_CANMIL, HECC_SET_REG);\r\nhecc_write(priv, HECC_CANGIM, HECC_CANGIM_DEF_MASK |\r\nHECC_CANGIM_I1EN | HECC_CANGIM_SIL);\r\n} else {\r\nhecc_write(priv, HECC_CANMIL, 0);\r\nhecc_write(priv, HECC_CANGIM,\r\nHECC_CANGIM_DEF_MASK | HECC_CANGIM_I0EN);\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nstatic void ti_hecc_stop(struct net_device *ndev)\r\n{\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nhecc_write(priv, HECC_CANGIM, 0);\r\nhecc_write(priv, HECC_CANMIM, 0);\r\nhecc_write(priv, HECC_CANME, 0);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int ti_hecc_do_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nint ret = 0;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nti_hecc_start(ndev);\r\nnetif_wake_queue(ndev);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic netdev_tx_t ti_hecc_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu32 mbxno, mbx_mask, data;\r\nunsigned long flags;\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\nmbxno = get_tx_head_mb(priv);\r\nmbx_mask = BIT(mbxno);\r\nspin_lock_irqsave(&priv->mbx_lock, flags);\r\nif (unlikely(hecc_read(priv, HECC_CANME) & mbx_mask)) {\r\nspin_unlock_irqrestore(&priv->mbx_lock, flags);\r\nnetif_stop_queue(ndev);\r\ndev_err(priv->ndev->dev.parent,\r\n"BUG: TX mbx not ready tx_head=%08X, tx_tail=%08X\n",\r\npriv->tx_head, priv->tx_tail);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nspin_unlock_irqrestore(&priv->mbx_lock, flags);\r\ndata = cf->can_dlc | (get_tx_head_prio(priv) << 8);\r\nif (cf->can_id & CAN_RTR_FLAG)\r\ndata |= HECC_CANMCF_RTR;\r\nhecc_write_mbx(priv, mbxno, HECC_CANMCF, data);\r\nif (cf->can_id & CAN_EFF_FLAG)\r\ndata = (cf->can_id & CAN_EFF_MASK) | HECC_CANMID_IDE;\r\nelse\r\ndata = (cf->can_id & CAN_SFF_MASK) << 18;\r\nhecc_write_mbx(priv, mbxno, HECC_CANMID, data);\r\nhecc_write_mbx(priv, mbxno, HECC_CANMDL,\r\nbe32_to_cpu(*(u32 *)(cf->data)));\r\nif (cf->can_dlc > 4)\r\nhecc_write_mbx(priv, mbxno, HECC_CANMDH,\r\nbe32_to_cpu(*(u32 *)(cf->data + 4)));\r\nelse\r\n*(u32 *)(cf->data + 4) = 0;\r\ncan_put_echo_skb(skb, ndev, mbxno);\r\nspin_lock_irqsave(&priv->mbx_lock, flags);\r\n--priv->tx_head;\r\nif ((hecc_read(priv, HECC_CANME) & BIT(get_tx_head_mb(priv))) ||\r\n(priv->tx_head & HECC_TX_MASK) == HECC_TX_MASK) {\r\nnetif_stop_queue(ndev);\r\n}\r\nhecc_set_bit(priv, HECC_CANME, mbx_mask);\r\nspin_unlock_irqrestore(&priv->mbx_lock, flags);\r\nhecc_clear_bit(priv, HECC_CANMD, mbx_mask);\r\nhecc_set_bit(priv, HECC_CANMIM, mbx_mask);\r\nhecc_write(priv, HECC_CANTRS, mbx_mask);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ti_hecc_rx_pkt(struct ti_hecc_priv *priv, int mbxno)\r\n{\r\nstruct net_device_stats *stats = &priv->ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 data, mbx_mask;\r\nunsigned long flags;\r\nskb = alloc_can_skb(priv->ndev, &cf);\r\nif (!skb) {\r\nif (printk_ratelimit())\r\ndev_err(priv->ndev->dev.parent,\r\n"ti_hecc_rx_pkt: alloc_can_skb() failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmbx_mask = BIT(mbxno);\r\ndata = hecc_read_mbx(priv, mbxno, HECC_CANMID);\r\nif (data & HECC_CANMID_IDE)\r\ncf->can_id = (data & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = (data >> 18) & CAN_SFF_MASK;\r\ndata = hecc_read_mbx(priv, mbxno, HECC_CANMCF);\r\nif (data & HECC_CANMCF_RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\ncf->can_dlc = get_can_dlc(data & 0xF);\r\ndata = hecc_read_mbx(priv, mbxno, HECC_CANMDL);\r\n*(u32 *)(cf->data) = cpu_to_be32(data);\r\nif (cf->can_dlc > 4) {\r\ndata = hecc_read_mbx(priv, mbxno, HECC_CANMDH);\r\n*(u32 *)(cf->data + 4) = cpu_to_be32(data);\r\n} else {\r\n*(u32 *)(cf->data + 4) = 0;\r\n}\r\nspin_lock_irqsave(&priv->mbx_lock, flags);\r\nhecc_clear_bit(priv, HECC_CANME, mbx_mask);\r\nhecc_write(priv, HECC_CANRMP, mbx_mask);\r\nif (priv->rx_next < HECC_RX_BUFFER_MBOX)\r\nhecc_set_bit(priv, HECC_CANME, mbx_mask);\r\nspin_unlock_irqrestore(&priv->mbx_lock, flags);\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nreturn 0;\r\n}\r\nstatic int ti_hecc_rx_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *ndev = napi->dev;\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nu32 num_pkts = 0;\r\nu32 mbx_mask;\r\nunsigned long pending_pkts, flags;\r\nif (!netif_running(ndev))\r\nreturn 0;\r\nwhile ((pending_pkts = hecc_read(priv, HECC_CANRMP)) &&\r\nnum_pkts < quota) {\r\nmbx_mask = BIT(priv->rx_next);\r\nif (mbx_mask & pending_pkts) {\r\nif (ti_hecc_rx_pkt(priv, priv->rx_next) < 0)\r\nreturn num_pkts;\r\n++num_pkts;\r\n} else if (priv->rx_next > HECC_RX_BUFFER_MBOX) {\r\nbreak;\r\n}\r\n--priv->rx_next;\r\nif (priv->rx_next == HECC_RX_BUFFER_MBOX) {\r\nspin_lock_irqsave(&priv->mbx_lock, flags);\r\nmbx_mask = hecc_read(priv, HECC_CANME);\r\nmbx_mask |= HECC_RX_HIGH_MBOX_MASK;\r\nhecc_write(priv, HECC_CANME, mbx_mask);\r\nspin_unlock_irqrestore(&priv->mbx_lock, flags);\r\n} else if (priv->rx_next == HECC_MAX_TX_MBOX - 1) {\r\npriv->rx_next = HECC_RX_FIRST_MBOX;\r\nbreak;\r\n}\r\n}\r\nif (hecc_read(priv, HECC_CANRMP) == 0) {\r\nnapi_complete(napi);\r\nmbx_mask = hecc_read(priv, HECC_CANMIM);\r\nmbx_mask |= HECC_TX_MBOX_MASK;\r\nhecc_write(priv, HECC_CANMIM, mbx_mask);\r\n}\r\nreturn num_pkts;\r\n}\r\nstatic int ti_hecc_error(struct net_device *ndev, int int_status,\r\nint err_status)\r\n{\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (!skb) {\r\nif (printk_ratelimit())\r\ndev_err(priv->ndev->dev.parent,\r\n"ti_hecc_error: alloc_can_err_skb() failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (int_status & HECC_CANGIF_WLIF) {\r\nif ((int_status & HECC_CANGIF_BOIF) == 0) {\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\n++priv->can.can_stats.error_warning;\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (hecc_read(priv, HECC_CANTEC) > 96)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_WARNING;\r\nif (hecc_read(priv, HECC_CANREC) > 96)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_WARNING;\r\n}\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_EW);\r\ndev_dbg(priv->ndev->dev.parent, "Error Warning interrupt\n");\r\nhecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);\r\n}\r\nif (int_status & HECC_CANGIF_EPIF) {\r\nif ((int_status & HECC_CANGIF_BOIF) == 0) {\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\n++priv->can.can_stats.error_passive;\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (hecc_read(priv, HECC_CANTEC) > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\nif (hecc_read(priv, HECC_CANREC) > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_EP);\r\ndev_dbg(priv->ndev->dev.parent, "Error passive interrupt\n");\r\nhecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);\r\n}\r\nif ((int_status & HECC_CANGIF_BOIF) || (err_status & HECC_CANES_BO)) {\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_BO);\r\nhecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_CCR);\r\nhecc_write(priv, HECC_CANGIM, 0);\r\ncan_bus_off(ndev);\r\n}\r\nif (err_status & HECC_BUS_ERROR) {\r\n++priv->can.can_stats.bus_error;\r\ncf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\r\ncf->data[2] |= CAN_ERR_PROT_UNSPEC;\r\nif (err_status & HECC_CANES_FE) {\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_FE);\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\n}\r\nif (err_status & HECC_CANES_BE) {\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_BE);\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\n}\r\nif (err_status & HECC_CANES_SE) {\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_SE);\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\n}\r\nif (err_status & HECC_CANES_CRCE) {\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_CRCE);\r\ncf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |\r\nCAN_ERR_PROT_LOC_CRC_DEL;\r\n}\r\nif (err_status & HECC_CANES_ACKE) {\r\nhecc_set_bit(priv, HECC_CANES, HECC_CANES_ACKE);\r\ncf->data[2] |= CAN_ERR_PROT_LOC_ACK |\r\nCAN_ERR_PROT_LOC_ACK_DEL;\r\n}\r\n}\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ti_hecc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nu32 mbxno, mbx_mask, int_status, err_status;\r\nunsigned long ack, flags;\r\nint_status = hecc_read(priv,\r\n(priv->int_line) ? HECC_CANGIF1 : HECC_CANGIF0);\r\nif (!int_status)\r\nreturn IRQ_NONE;\r\nerr_status = hecc_read(priv, HECC_CANES);\r\nif (err_status & (HECC_BUS_ERROR | HECC_CANES_BO |\r\nHECC_CANES_EP | HECC_CANES_EW))\r\nti_hecc_error(ndev, int_status, err_status);\r\nif (int_status & HECC_CANGIF_GMIF) {\r\nwhile (priv->tx_tail - priv->tx_head > 0) {\r\nmbxno = get_tx_tail_mb(priv);\r\nmbx_mask = BIT(mbxno);\r\nif (!(mbx_mask & hecc_read(priv, HECC_CANTA)))\r\nbreak;\r\nhecc_clear_bit(priv, HECC_CANMIM, mbx_mask);\r\nhecc_write(priv, HECC_CANTA, mbx_mask);\r\nspin_lock_irqsave(&priv->mbx_lock, flags);\r\nhecc_clear_bit(priv, HECC_CANME, mbx_mask);\r\nspin_unlock_irqrestore(&priv->mbx_lock, flags);\r\nstats->tx_bytes += hecc_read_mbx(priv, mbxno,\r\nHECC_CANMCF) & 0xF;\r\nstats->tx_packets++;\r\ncan_get_echo_skb(ndev, mbxno);\r\n--priv->tx_tail;\r\n}\r\nif (((priv->tx_head == priv->tx_tail) &&\r\n((priv->tx_head & HECC_TX_MASK) != HECC_TX_MASK)) ||\r\n(((priv->tx_tail & HECC_TX_MASK) == HECC_TX_MASK) &&\r\n((priv->tx_head & HECC_TX_MASK) == HECC_TX_MASK)))\r\nnetif_wake_queue(ndev);\r\nif (hecc_read(priv, HECC_CANRMP)) {\r\nack = hecc_read(priv, HECC_CANMIM);\r\nack &= BIT(HECC_MAX_TX_MBOX) - 1;\r\nhecc_write(priv, HECC_CANMIM, ack);\r\nnapi_schedule(&priv->napi);\r\n}\r\n}\r\nif (priv->int_line) {\r\nhecc_write(priv, HECC_CANGIF1, HECC_SET_REG);\r\nint_status = hecc_read(priv, HECC_CANGIF1);\r\n} else {\r\nhecc_write(priv, HECC_CANGIF0, HECC_SET_REG);\r\nint_status = hecc_read(priv, HECC_CANGIF0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ti_hecc_open(struct net_device *ndev)\r\n{\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nint err;\r\nerr = request_irq(ndev->irq, ti_hecc_interrupt, IRQF_SHARED,\r\nndev->name, ndev);\r\nif (err) {\r\ndev_err(ndev->dev.parent, "error requesting interrupt\n");\r\nreturn err;\r\n}\r\nti_hecc_transceiver_switch(priv, 1);\r\nerr = open_candev(ndev);\r\nif (err) {\r\ndev_err(ndev->dev.parent, "open_candev() failed %d\n", err);\r\nti_hecc_transceiver_switch(priv, 0);\r\nfree_irq(ndev->irq, ndev);\r\nreturn err;\r\n}\r\nti_hecc_start(ndev);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\n}\r\nstatic int ti_hecc_close(struct net_device *ndev)\r\n{\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nnapi_disable(&priv->napi);\r\nti_hecc_stop(ndev);\r\nfree_irq(ndev->irq, ndev);\r\nclose_candev(ndev);\r\nti_hecc_transceiver_switch(priv, 0);\r\nreturn 0;\r\n}\r\nstatic int ti_hecc_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = (struct net_device *)0;\r\nstruct ti_hecc_priv *priv;\r\nstruct ti_hecc_platform_data *pdata;\r\nstruct resource *mem, *irq;\r\nvoid __iomem *addr;\r\nint err = -ENODEV;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data\n");\r\ngoto probe_exit;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "No mem resources\n");\r\ngoto probe_exit;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "No irq resource\n");\r\ngoto probe_exit;\r\n}\r\nif (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {\r\ndev_err(&pdev->dev, "HECC region already claimed\n");\r\nerr = -EBUSY;\r\ngoto probe_exit;\r\n}\r\naddr = ioremap(mem->start, resource_size(mem));\r\nif (!addr) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nerr = -ENOMEM;\r\ngoto probe_exit_free_region;\r\n}\r\nndev = alloc_candev(sizeof(struct ti_hecc_priv), HECC_MAX_TX_MBOX);\r\nif (!ndev) {\r\ndev_err(&pdev->dev, "alloc_candev failed\n");\r\nerr = -ENOMEM;\r\ngoto probe_exit_iounmap;\r\n}\r\npriv = netdev_priv(ndev);\r\npriv->ndev = ndev;\r\npriv->base = addr;\r\npriv->scc_ram_offset = pdata->scc_ram_offset;\r\npriv->hecc_ram_offset = pdata->hecc_ram_offset;\r\npriv->mbx_offset = pdata->mbx_offset;\r\npriv->int_line = pdata->int_line;\r\npriv->transceiver_switch = pdata->transceiver_switch;\r\npriv->can.bittiming_const = &ti_hecc_bittiming_const;\r\npriv->can.do_set_mode = ti_hecc_do_set_mode;\r\npriv->can.do_get_state = ti_hecc_get_state;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nspin_lock_init(&priv->mbx_lock);\r\nndev->irq = irq->start;\r\nndev->flags |= IFF_ECHO;\r\nplatform_set_drvdata(pdev, ndev);\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nndev->netdev_ops = &ti_hecc_netdev_ops;\r\npriv->clk = clk_get(&pdev->dev, "hecc_ck");\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&pdev->dev, "No clock available\n");\r\nerr = PTR_ERR(priv->clk);\r\npriv->clk = NULL;\r\ngoto probe_exit_candev;\r\n}\r\npriv->can.clock.freq = clk_get_rate(priv->clk);\r\nnetif_napi_add(ndev, &priv->napi, ti_hecc_rx_poll,\r\nHECC_DEF_NAPI_WEIGHT);\r\nclk_enable(priv->clk);\r\nerr = register_candev(ndev);\r\nif (err) {\r\ndev_err(&pdev->dev, "register_candev() failed\n");\r\ngoto probe_exit_clk;\r\n}\r\ndev_info(&pdev->dev, "device registered (reg_base=%p, irq=%u)\n",\r\npriv->base, (u32) ndev->irq);\r\nreturn 0;\r\nprobe_exit_clk:\r\nclk_put(priv->clk);\r\nprobe_exit_candev:\r\nfree_candev(ndev);\r\nprobe_exit_iounmap:\r\niounmap(addr);\r\nprobe_exit_free_region:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nprobe_exit:\r\nreturn err;\r\n}\r\nstatic int __devexit ti_hecc_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct ti_hecc_priv *priv = netdev_priv(ndev);\r\nclk_disable(priv->clk);\r\nclk_put(priv->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niounmap(priv->base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nunregister_candev(ndev);\r\nfree_candev(ndev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int ti_hecc_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct ti_hecc_priv *priv = netdev_priv(dev);\r\nif (netif_running(dev)) {\r\nnetif_stop_queue(dev);\r\nnetif_device_detach(dev);\r\n}\r\nhecc_set_bit(priv, HECC_CANMC, HECC_CANMC_PDR);\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nclk_disable(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int ti_hecc_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct ti_hecc_priv *priv = netdev_priv(dev);\r\nclk_enable(priv->clk);\r\nhecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_PDR);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(dev)) {\r\nnetif_device_attach(dev);\r\nnetif_start_queue(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ti_hecc_init_driver(void)\r\n{\r\nprintk(KERN_INFO DRV_DESC "\n");\r\nreturn platform_driver_register(&ti_hecc_driver);\r\n}\r\nstatic void __exit ti_hecc_exit_driver(void)\r\n{\r\nprintk(KERN_INFO DRV_DESC " unloaded\n");\r\nplatform_driver_unregister(&ti_hecc_driver);\r\n}
