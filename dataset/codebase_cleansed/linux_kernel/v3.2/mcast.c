int ipv6_sock_mc_join(struct sock *sk, int ifindex, const struct in6_addr *addr)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct ipv6_mc_socklist *mc_lst;\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nint err;\r\nif (!ipv6_addr_is_multicast(addr))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(np, mc_lst) {\r\nif ((ifindex == 0 || mc_lst->ifindex == ifindex) &&\r\nipv6_addr_equal(&mc_lst->addr, addr)) {\r\nrcu_read_unlock();\r\nreturn -EADDRINUSE;\r\n}\r\n}\r\nrcu_read_unlock();\r\nmc_lst = sock_kmalloc(sk, sizeof(struct ipv6_mc_socklist), GFP_KERNEL);\r\nif (mc_lst == NULL)\r\nreturn -ENOMEM;\r\nmc_lst->next = NULL;\r\nipv6_addr_copy(&mc_lst->addr, addr);\r\nrcu_read_lock();\r\nif (ifindex == 0) {\r\nstruct rt6_info *rt;\r\nrt = rt6_lookup(net, addr, NULL, 0, 0);\r\nif (rt) {\r\ndev = rt->rt6i_dev;\r\ndst_release(&rt->dst);\r\n}\r\n} else\r\ndev = dev_get_by_index_rcu(net, ifindex);\r\nif (dev == NULL) {\r\nrcu_read_unlock();\r\nsock_kfree_s(sk, mc_lst, sizeof(*mc_lst));\r\nreturn -ENODEV;\r\n}\r\nmc_lst->ifindex = dev->ifindex;\r\nmc_lst->sfmode = MCAST_EXCLUDE;\r\nrwlock_init(&mc_lst->sflock);\r\nmc_lst->sflist = NULL;\r\nerr = ipv6_dev_mc_inc(dev, addr);\r\nif (err) {\r\nrcu_read_unlock();\r\nsock_kfree_s(sk, mc_lst, sizeof(*mc_lst));\r\nreturn err;\r\n}\r\nspin_lock(&ipv6_sk_mc_lock);\r\nmc_lst->next = np->ipv6_mc_list;\r\nrcu_assign_pointer(np->ipv6_mc_list, mc_lst);\r\nspin_unlock(&ipv6_sk_mc_lock);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint ipv6_sock_mc_drop(struct sock *sk, int ifindex, const struct in6_addr *addr)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_mc_socklist *mc_lst;\r\nstruct ipv6_mc_socklist __rcu **lnk;\r\nstruct net *net = sock_net(sk);\r\nspin_lock(&ipv6_sk_mc_lock);\r\nfor (lnk = &np->ipv6_mc_list;\r\n(mc_lst = rcu_dereference_protected(*lnk,\r\nlockdep_is_held(&ipv6_sk_mc_lock))) !=NULL ;\r\nlnk = &mc_lst->next) {\r\nif ((ifindex == 0 || mc_lst->ifindex == ifindex) &&\r\nipv6_addr_equal(&mc_lst->addr, addr)) {\r\nstruct net_device *dev;\r\n*lnk = mc_lst->next;\r\nspin_unlock(&ipv6_sk_mc_lock);\r\nrcu_read_lock();\r\ndev = dev_get_by_index_rcu(net, mc_lst->ifindex);\r\nif (dev != NULL) {\r\nstruct inet6_dev *idev = __in6_dev_get(dev);\r\n(void) ip6_mc_leave_src(sk, mc_lst, idev);\r\nif (idev)\r\n__ipv6_dev_mc_dec(idev, &mc_lst->addr);\r\n} else\r\n(void) ip6_mc_leave_src(sk, mc_lst, NULL);\r\nrcu_read_unlock();\r\natomic_sub(sizeof(*mc_lst), &sk->sk_omem_alloc);\r\nkfree_rcu(mc_lst, rcu);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock(&ipv6_sk_mc_lock);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic struct inet6_dev *ip6_mc_find_dev_rcu(struct net *net,\r\nconst struct in6_addr *group,\r\nint ifindex)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct inet6_dev *idev = NULL;\r\nif (ifindex == 0) {\r\nstruct rt6_info *rt = rt6_lookup(net, group, NULL, 0, 0);\r\nif (rt) {\r\ndev = rt->rt6i_dev;\r\ndev_hold(dev);\r\ndst_release(&rt->dst);\r\n}\r\n} else\r\ndev = dev_get_by_index_rcu(net, ifindex);\r\nif (!dev)\r\nreturn NULL;\r\nidev = __in6_dev_get(dev);\r\nif (!idev)\r\nreturn NULL;\r\nread_lock_bh(&idev->lock);\r\nif (idev->dead) {\r\nread_unlock_bh(&idev->lock);\r\nreturn NULL;\r\n}\r\nreturn idev;\r\n}\r\nvoid ipv6_sock_mc_close(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_mc_socklist *mc_lst;\r\nstruct net *net = sock_net(sk);\r\nspin_lock(&ipv6_sk_mc_lock);\r\nwhile ((mc_lst = rcu_dereference_protected(np->ipv6_mc_list,\r\nlockdep_is_held(&ipv6_sk_mc_lock))) != NULL) {\r\nstruct net_device *dev;\r\nnp->ipv6_mc_list = mc_lst->next;\r\nspin_unlock(&ipv6_sk_mc_lock);\r\nrcu_read_lock();\r\ndev = dev_get_by_index_rcu(net, mc_lst->ifindex);\r\nif (dev) {\r\nstruct inet6_dev *idev = __in6_dev_get(dev);\r\n(void) ip6_mc_leave_src(sk, mc_lst, idev);\r\nif (idev)\r\n__ipv6_dev_mc_dec(idev, &mc_lst->addr);\r\n} else\r\n(void) ip6_mc_leave_src(sk, mc_lst, NULL);\r\nrcu_read_unlock();\r\natomic_sub(sizeof(*mc_lst), &sk->sk_omem_alloc);\r\nkfree_rcu(mc_lst, rcu);\r\nspin_lock(&ipv6_sk_mc_lock);\r\n}\r\nspin_unlock(&ipv6_sk_mc_lock);\r\n}\r\nint ip6_mc_source(int add, int omode, struct sock *sk,\r\nstruct group_source_req *pgsr)\r\n{\r\nstruct in6_addr *source, *group;\r\nstruct ipv6_mc_socklist *pmc;\r\nstruct inet6_dev *idev;\r\nstruct ipv6_pinfo *inet6 = inet6_sk(sk);\r\nstruct ip6_sf_socklist *psl;\r\nstruct net *net = sock_net(sk);\r\nint i, j, rv;\r\nint leavegroup = 0;\r\nint pmclocked = 0;\r\nint err;\r\nsource = &((struct sockaddr_in6 *)&pgsr->gsr_source)->sin6_addr;\r\ngroup = &((struct sockaddr_in6 *)&pgsr->gsr_group)->sin6_addr;\r\nif (!ipv6_addr_is_multicast(group))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nidev = ip6_mc_find_dev_rcu(net, group, pgsr->gsr_interface);\r\nif (!idev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\nerr = -EADDRNOTAVAIL;\r\nfor_each_pmc_rcu(inet6, pmc) {\r\nif (pgsr->gsr_interface && pmc->ifindex != pgsr->gsr_interface)\r\ncontinue;\r\nif (ipv6_addr_equal(&pmc->addr, group))\r\nbreak;\r\n}\r\nif (!pmc) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (pmc->sflist) {\r\nif (pmc->sfmode != omode) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\n} else if (pmc->sfmode != omode) {\r\nip6_mc_add_src(idev, group, omode, 0, NULL, 0);\r\nip6_mc_del_src(idev, group, pmc->sfmode, 0, NULL, 0);\r\npmc->sfmode = omode;\r\n}\r\nwrite_lock(&pmc->sflock);\r\npmclocked = 1;\r\npsl = pmc->sflist;\r\nif (!add) {\r\nif (!psl)\r\ngoto done;\r\nrv = !0;\r\nfor (i=0; i<psl->sl_count; i++) {\r\nrv = memcmp(&psl->sl_addr[i], source,\r\nsizeof(struct in6_addr));\r\nif (rv == 0)\r\nbreak;\r\n}\r\nif (rv)\r\ngoto done;\r\nif (psl->sl_count == 1 && omode == MCAST_INCLUDE) {\r\nleavegroup = 1;\r\ngoto done;\r\n}\r\nip6_mc_del_src(idev, group, omode, 1, source, 1);\r\nfor (j=i+1; j<psl->sl_count; j++)\r\npsl->sl_addr[j-1] = psl->sl_addr[j];\r\npsl->sl_count--;\r\nerr = 0;\r\ngoto done;\r\n}\r\nif (psl && psl->sl_count >= sysctl_mld_max_msf) {\r\nerr = -ENOBUFS;\r\ngoto done;\r\n}\r\nif (!psl || psl->sl_count == psl->sl_max) {\r\nstruct ip6_sf_socklist *newpsl;\r\nint count = IP6_SFBLOCK;\r\nif (psl)\r\ncount += psl->sl_max;\r\nnewpsl = sock_kmalloc(sk, IP6_SFLSIZE(count), GFP_ATOMIC);\r\nif (!newpsl) {\r\nerr = -ENOBUFS;\r\ngoto done;\r\n}\r\nnewpsl->sl_max = count;\r\nnewpsl->sl_count = count - IP6_SFBLOCK;\r\nif (psl) {\r\nfor (i=0; i<psl->sl_count; i++)\r\nnewpsl->sl_addr[i] = psl->sl_addr[i];\r\nsock_kfree_s(sk, psl, IP6_SFLSIZE(psl->sl_max));\r\n}\r\npmc->sflist = psl = newpsl;\r\n}\r\nrv = 1;\r\nfor (i=0; i<psl->sl_count; i++) {\r\nrv = memcmp(&psl->sl_addr[i], source, sizeof(struct in6_addr));\r\nif (rv == 0)\r\nbreak;\r\n}\r\nif (rv == 0)\r\ngoto done;\r\nfor (j=psl->sl_count-1; j>=i; j--)\r\npsl->sl_addr[j+1] = psl->sl_addr[j];\r\npsl->sl_addr[i] = *source;\r\npsl->sl_count++;\r\nerr = 0;\r\nip6_mc_add_src(idev, group, omode, 1, source, 1);\r\ndone:\r\nif (pmclocked)\r\nwrite_unlock(&pmc->sflock);\r\nread_unlock_bh(&idev->lock);\r\nrcu_read_unlock();\r\nif (leavegroup)\r\nreturn ipv6_sock_mc_drop(sk, pgsr->gsr_interface, group);\r\nreturn err;\r\n}\r\nint ip6_mc_msfilter(struct sock *sk, struct group_filter *gsf)\r\n{\r\nconst struct in6_addr *group;\r\nstruct ipv6_mc_socklist *pmc;\r\nstruct inet6_dev *idev;\r\nstruct ipv6_pinfo *inet6 = inet6_sk(sk);\r\nstruct ip6_sf_socklist *newpsl, *psl;\r\nstruct net *net = sock_net(sk);\r\nint leavegroup = 0;\r\nint i, err;\r\ngroup = &((struct sockaddr_in6 *)&gsf->gf_group)->sin6_addr;\r\nif (!ipv6_addr_is_multicast(group))\r\nreturn -EINVAL;\r\nif (gsf->gf_fmode != MCAST_INCLUDE &&\r\ngsf->gf_fmode != MCAST_EXCLUDE)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nidev = ip6_mc_find_dev_rcu(net, group, gsf->gf_interface);\r\nif (!idev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\nerr = 0;\r\nif (gsf->gf_fmode == MCAST_INCLUDE && gsf->gf_numsrc == 0) {\r\nleavegroup = 1;\r\ngoto done;\r\n}\r\nfor_each_pmc_rcu(inet6, pmc) {\r\nif (pmc->ifindex != gsf->gf_interface)\r\ncontinue;\r\nif (ipv6_addr_equal(&pmc->addr, group))\r\nbreak;\r\n}\r\nif (!pmc) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (gsf->gf_numsrc) {\r\nnewpsl = sock_kmalloc(sk, IP6_SFLSIZE(gsf->gf_numsrc),\r\nGFP_ATOMIC);\r\nif (!newpsl) {\r\nerr = -ENOBUFS;\r\ngoto done;\r\n}\r\nnewpsl->sl_max = newpsl->sl_count = gsf->gf_numsrc;\r\nfor (i=0; i<newpsl->sl_count; ++i) {\r\nstruct sockaddr_in6 *psin6;\r\npsin6 = (struct sockaddr_in6 *)&gsf->gf_slist[i];\r\nnewpsl->sl_addr[i] = psin6->sin6_addr;\r\n}\r\nerr = ip6_mc_add_src(idev, group, gsf->gf_fmode,\r\nnewpsl->sl_count, newpsl->sl_addr, 0);\r\nif (err) {\r\nsock_kfree_s(sk, newpsl, IP6_SFLSIZE(newpsl->sl_max));\r\ngoto done;\r\n}\r\n} else {\r\nnewpsl = NULL;\r\n(void) ip6_mc_add_src(idev, group, gsf->gf_fmode, 0, NULL, 0);\r\n}\r\nwrite_lock(&pmc->sflock);\r\npsl = pmc->sflist;\r\nif (psl) {\r\n(void) ip6_mc_del_src(idev, group, pmc->sfmode,\r\npsl->sl_count, psl->sl_addr, 0);\r\nsock_kfree_s(sk, psl, IP6_SFLSIZE(psl->sl_max));\r\n} else\r\n(void) ip6_mc_del_src(idev, group, pmc->sfmode, 0, NULL, 0);\r\npmc->sflist = newpsl;\r\npmc->sfmode = gsf->gf_fmode;\r\nwrite_unlock(&pmc->sflock);\r\nerr = 0;\r\ndone:\r\nread_unlock_bh(&idev->lock);\r\nrcu_read_unlock();\r\nif (leavegroup)\r\nerr = ipv6_sock_mc_drop(sk, gsf->gf_interface, group);\r\nreturn err;\r\n}\r\nint ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,\r\nstruct group_filter __user *optval, int __user *optlen)\r\n{\r\nint err, i, count, copycount;\r\nconst struct in6_addr *group;\r\nstruct ipv6_mc_socklist *pmc;\r\nstruct inet6_dev *idev;\r\nstruct ipv6_pinfo *inet6 = inet6_sk(sk);\r\nstruct ip6_sf_socklist *psl;\r\nstruct net *net = sock_net(sk);\r\ngroup = &((struct sockaddr_in6 *)&gsf->gf_group)->sin6_addr;\r\nif (!ipv6_addr_is_multicast(group))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nidev = ip6_mc_find_dev_rcu(net, group, gsf->gf_interface);\r\nif (!idev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\nerr = -EADDRNOTAVAIL;\r\nfor_each_pmc_rcu(inet6, pmc) {\r\nif (pmc->ifindex != gsf->gf_interface)\r\ncontinue;\r\nif (ipv6_addr_equal(group, &pmc->addr))\r\nbreak;\r\n}\r\nif (!pmc)\r\ngoto done;\r\ngsf->gf_fmode = pmc->sfmode;\r\npsl = pmc->sflist;\r\ncount = psl ? psl->sl_count : 0;\r\nread_unlock_bh(&idev->lock);\r\nrcu_read_unlock();\r\ncopycount = count < gsf->gf_numsrc ? count : gsf->gf_numsrc;\r\ngsf->gf_numsrc = count;\r\nif (put_user(GROUP_FILTER_SIZE(copycount), optlen) ||\r\ncopy_to_user(optval, gsf, GROUP_FILTER_SIZE(0))) {\r\nreturn -EFAULT;\r\n}\r\nfor (i=0; i<copycount; i++) {\r\nstruct sockaddr_in6 *psin6;\r\nstruct sockaddr_storage ss;\r\npsin6 = (struct sockaddr_in6 *)&ss;\r\nmemset(&ss, 0, sizeof(ss));\r\npsin6->sin6_family = AF_INET6;\r\npsin6->sin6_addr = psl->sl_addr[i];\r\nif (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\ndone:\r\nread_unlock_bh(&idev->lock);\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nint inet6_mc_check(struct sock *sk, const struct in6_addr *mc_addr,\r\nconst struct in6_addr *src_addr)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_mc_socklist *mc;\r\nstruct ip6_sf_socklist *psl;\r\nint rv = 1;\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(np, mc) {\r\nif (ipv6_addr_equal(&mc->addr, mc_addr))\r\nbreak;\r\n}\r\nif (!mc) {\r\nrcu_read_unlock();\r\nreturn 1;\r\n}\r\nread_lock(&mc->sflock);\r\npsl = mc->sflist;\r\nif (!psl) {\r\nrv = mc->sfmode == MCAST_EXCLUDE;\r\n} else {\r\nint i;\r\nfor (i=0; i<psl->sl_count; i++) {\r\nif (ipv6_addr_equal(&psl->sl_addr[i], src_addr))\r\nbreak;\r\n}\r\nif (mc->sfmode == MCAST_INCLUDE && i >= psl->sl_count)\r\nrv = 0;\r\nif (mc->sfmode == MCAST_EXCLUDE && i < psl->sl_count)\r\nrv = 0;\r\n}\r\nread_unlock(&mc->sflock);\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic void ma_put(struct ifmcaddr6 *mc)\r\n{\r\nif (atomic_dec_and_test(&mc->mca_refcnt)) {\r\nin6_dev_put(mc->idev);\r\nkfree(mc);\r\n}\r\n}\r\nstatic void igmp6_group_added(struct ifmcaddr6 *mc)\r\n{\r\nstruct net_device *dev = mc->idev->dev;\r\nchar buf[MAX_ADDR_LEN];\r\nspin_lock_bh(&mc->mca_lock);\r\nif (!(mc->mca_flags&MAF_LOADED)) {\r\nmc->mca_flags |= MAF_LOADED;\r\nif (ndisc_mc_map(&mc->mca_addr, buf, dev, 0) == 0)\r\ndev_mc_add(dev, buf);\r\n}\r\nspin_unlock_bh(&mc->mca_lock);\r\nif (!(dev->flags & IFF_UP) || (mc->mca_flags & MAF_NOREPORT))\r\nreturn;\r\nif (MLD_V1_SEEN(mc->idev)) {\r\nigmp6_join_group(mc);\r\nreturn;\r\n}\r\nmc->mca_crcount = mc->idev->mc_qrv;\r\nmld_ifc_event(mc->idev);\r\n}\r\nstatic void igmp6_group_dropped(struct ifmcaddr6 *mc)\r\n{\r\nstruct net_device *dev = mc->idev->dev;\r\nchar buf[MAX_ADDR_LEN];\r\nspin_lock_bh(&mc->mca_lock);\r\nif (mc->mca_flags&MAF_LOADED) {\r\nmc->mca_flags &= ~MAF_LOADED;\r\nif (ndisc_mc_map(&mc->mca_addr, buf, dev, 0) == 0)\r\ndev_mc_del(dev, buf);\r\n}\r\nif (mc->mca_flags & MAF_NOREPORT)\r\ngoto done;\r\nspin_unlock_bh(&mc->mca_lock);\r\nif (!mc->idev->dead)\r\nigmp6_leave_group(mc);\r\nspin_lock_bh(&mc->mca_lock);\r\nif (del_timer(&mc->mca_timer))\r\natomic_dec(&mc->mca_refcnt);\r\ndone:\r\nip6_mc_clear_src(mc);\r\nspin_unlock_bh(&mc->mca_lock);\r\n}\r\nstatic void mld_add_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)\r\n{\r\nstruct ifmcaddr6 *pmc;\r\npmc = kzalloc(sizeof(*pmc), GFP_ATOMIC);\r\nif (!pmc)\r\nreturn;\r\nspin_lock_bh(&im->mca_lock);\r\nspin_lock_init(&pmc->mca_lock);\r\npmc->idev = im->idev;\r\nin6_dev_hold(idev);\r\npmc->mca_addr = im->mca_addr;\r\npmc->mca_crcount = idev->mc_qrv;\r\npmc->mca_sfmode = im->mca_sfmode;\r\nif (pmc->mca_sfmode == MCAST_INCLUDE) {\r\nstruct ip6_sf_list *psf;\r\npmc->mca_tomb = im->mca_tomb;\r\npmc->mca_sources = im->mca_sources;\r\nim->mca_tomb = im->mca_sources = NULL;\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next)\r\npsf->sf_crcount = pmc->mca_crcount;\r\n}\r\nspin_unlock_bh(&im->mca_lock);\r\nspin_lock_bh(&idev->mc_lock);\r\npmc->next = idev->mc_tomb;\r\nidev->mc_tomb = pmc;\r\nspin_unlock_bh(&idev->mc_lock);\r\n}\r\nstatic void mld_del_delrec(struct inet6_dev *idev, const struct in6_addr *pmca)\r\n{\r\nstruct ifmcaddr6 *pmc, *pmc_prev;\r\nstruct ip6_sf_list *psf, *psf_next;\r\nspin_lock_bh(&idev->mc_lock);\r\npmc_prev = NULL;\r\nfor (pmc=idev->mc_tomb; pmc; pmc=pmc->next) {\r\nif (ipv6_addr_equal(&pmc->mca_addr, pmca))\r\nbreak;\r\npmc_prev = pmc;\r\n}\r\nif (pmc) {\r\nif (pmc_prev)\r\npmc_prev->next = pmc->next;\r\nelse\r\nidev->mc_tomb = pmc->next;\r\n}\r\nspin_unlock_bh(&idev->mc_lock);\r\nif (pmc) {\r\nfor (psf=pmc->mca_tomb; psf; psf=psf_next) {\r\npsf_next = psf->sf_next;\r\nkfree(psf);\r\n}\r\nin6_dev_put(pmc->idev);\r\nkfree(pmc);\r\n}\r\n}\r\nstatic void mld_clear_delrec(struct inet6_dev *idev)\r\n{\r\nstruct ifmcaddr6 *pmc, *nextpmc;\r\nspin_lock_bh(&idev->mc_lock);\r\npmc = idev->mc_tomb;\r\nidev->mc_tomb = NULL;\r\nspin_unlock_bh(&idev->mc_lock);\r\nfor (; pmc; pmc = nextpmc) {\r\nnextpmc = pmc->next;\r\nip6_mc_clear_src(pmc);\r\nin6_dev_put(pmc->idev);\r\nkfree(pmc);\r\n}\r\nread_lock_bh(&idev->lock);\r\nfor (pmc=idev->mc_list; pmc; pmc=pmc->next) {\r\nstruct ip6_sf_list *psf, *psf_next;\r\nspin_lock_bh(&pmc->mca_lock);\r\npsf = pmc->mca_tomb;\r\npmc->mca_tomb = NULL;\r\nspin_unlock_bh(&pmc->mca_lock);\r\nfor (; psf; psf=psf_next) {\r\npsf_next = psf->sf_next;\r\nkfree(psf);\r\n}\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nint ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr)\r\n{\r\nstruct ifmcaddr6 *mc;\r\nstruct inet6_dev *idev;\r\nidev = in6_dev_get(dev);\r\nif (idev == NULL)\r\nreturn -EINVAL;\r\nwrite_lock_bh(&idev->lock);\r\nif (idev->dead) {\r\nwrite_unlock_bh(&idev->lock);\r\nin6_dev_put(idev);\r\nreturn -ENODEV;\r\n}\r\nfor (mc = idev->mc_list; mc; mc = mc->next) {\r\nif (ipv6_addr_equal(&mc->mca_addr, addr)) {\r\nmc->mca_users++;\r\nwrite_unlock_bh(&idev->lock);\r\nip6_mc_add_src(idev, &mc->mca_addr, MCAST_EXCLUDE, 0,\r\nNULL, 0);\r\nin6_dev_put(idev);\r\nreturn 0;\r\n}\r\n}\r\nmc = kzalloc(sizeof(struct ifmcaddr6), GFP_ATOMIC);\r\nif (mc == NULL) {\r\nwrite_unlock_bh(&idev->lock);\r\nin6_dev_put(idev);\r\nreturn -ENOMEM;\r\n}\r\nsetup_timer(&mc->mca_timer, igmp6_timer_handler, (unsigned long)mc);\r\nipv6_addr_copy(&mc->mca_addr, addr);\r\nmc->idev = idev;\r\nmc->mca_users = 1;\r\nmc->mca_cstamp = mc->mca_tstamp = jiffies;\r\natomic_set(&mc->mca_refcnt, 2);\r\nspin_lock_init(&mc->mca_lock);\r\nmc->mca_sfmode = MCAST_EXCLUDE;\r\nmc->mca_sfcount[MCAST_EXCLUDE] = 1;\r\nif (ipv6_addr_is_ll_all_nodes(&mc->mca_addr) ||\r\nIPV6_ADDR_MC_SCOPE(&mc->mca_addr) < IPV6_ADDR_SCOPE_LINKLOCAL)\r\nmc->mca_flags |= MAF_NOREPORT;\r\nmc->next = idev->mc_list;\r\nidev->mc_list = mc;\r\nwrite_unlock_bh(&idev->lock);\r\nmld_del_delrec(idev, &mc->mca_addr);\r\nigmp6_group_added(mc);\r\nma_put(mc);\r\nreturn 0;\r\n}\r\nint __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr)\r\n{\r\nstruct ifmcaddr6 *ma, **map;\r\nwrite_lock_bh(&idev->lock);\r\nfor (map = &idev->mc_list; (ma=*map) != NULL; map = &ma->next) {\r\nif (ipv6_addr_equal(&ma->mca_addr, addr)) {\r\nif (--ma->mca_users == 0) {\r\n*map = ma->next;\r\nwrite_unlock_bh(&idev->lock);\r\nigmp6_group_dropped(ma);\r\nma_put(ma);\r\nreturn 0;\r\n}\r\nwrite_unlock_bh(&idev->lock);\r\nreturn 0;\r\n}\r\n}\r\nwrite_unlock_bh(&idev->lock);\r\nreturn -ENOENT;\r\n}\r\nint ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr)\r\n{\r\nstruct inet6_dev *idev;\r\nint err;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (!idev)\r\nerr = -ENODEV;\r\nelse\r\nerr = __ipv6_dev_mc_dec(idev, addr);\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nint ipv6_is_mld(struct sk_buff *skb, int nexthdr)\r\n{\r\nstruct icmp6hdr *pic;\r\nif (nexthdr != IPPROTO_ICMPV6)\r\nreturn 0;\r\nif (!pskb_may_pull(skb, sizeof(struct icmp6hdr)))\r\nreturn 0;\r\npic = icmp6_hdr(skb);\r\nswitch (pic->icmp6_type) {\r\ncase ICMPV6_MGM_QUERY:\r\ncase ICMPV6_MGM_REPORT:\r\ncase ICMPV6_MGM_REDUCTION:\r\ncase ICMPV6_MLD2_REPORT:\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,\r\nconst struct in6_addr *src_addr)\r\n{\r\nstruct inet6_dev *idev;\r\nstruct ifmcaddr6 *mc;\r\nint rv = 0;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (idev) {\r\nread_lock_bh(&idev->lock);\r\nfor (mc = idev->mc_list; mc; mc=mc->next) {\r\nif (ipv6_addr_equal(&mc->mca_addr, group))\r\nbreak;\r\n}\r\nif (mc) {\r\nif (src_addr && !ipv6_addr_any(src_addr)) {\r\nstruct ip6_sf_list *psf;\r\nspin_lock_bh(&mc->mca_lock);\r\nfor (psf=mc->mca_sources;psf;psf=psf->sf_next) {\r\nif (ipv6_addr_equal(&psf->sf_addr, src_addr))\r\nbreak;\r\n}\r\nif (psf)\r\nrv = psf->sf_count[MCAST_INCLUDE] ||\r\npsf->sf_count[MCAST_EXCLUDE] !=\r\nmc->mca_sfcount[MCAST_EXCLUDE];\r\nelse\r\nrv = mc->mca_sfcount[MCAST_EXCLUDE] !=0;\r\nspin_unlock_bh(&mc->mca_lock);\r\n} else\r\nrv = 1;\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic void mld_gq_start_timer(struct inet6_dev *idev)\r\n{\r\nint tv = net_random() % idev->mc_maxdelay;\r\nidev->mc_gq_running = 1;\r\nif (!mod_timer(&idev->mc_gq_timer, jiffies+tv+2))\r\nin6_dev_hold(idev);\r\n}\r\nstatic void mld_ifc_start_timer(struct inet6_dev *idev, int delay)\r\n{\r\nint tv = net_random() % delay;\r\nif (!mod_timer(&idev->mc_ifc_timer, jiffies+tv+2))\r\nin6_dev_hold(idev);\r\n}\r\nstatic void igmp6_group_queried(struct ifmcaddr6 *ma, unsigned long resptime)\r\n{\r\nunsigned long delay = resptime;\r\nif (ipv6_addr_is_ll_all_nodes(&ma->mca_addr) ||\r\nIPV6_ADDR_MC_SCOPE(&ma->mca_addr) < IPV6_ADDR_SCOPE_LINKLOCAL)\r\nreturn;\r\nif (del_timer(&ma->mca_timer)) {\r\natomic_dec(&ma->mca_refcnt);\r\ndelay = ma->mca_timer.expires - jiffies;\r\n}\r\nif (delay >= resptime) {\r\nif (resptime)\r\ndelay = net_random() % resptime;\r\nelse\r\ndelay = 1;\r\n}\r\nma->mca_timer.expires = jiffies + delay;\r\nif (!mod_timer(&ma->mca_timer, jiffies + delay))\r\natomic_inc(&ma->mca_refcnt);\r\nma->mca_flags |= MAF_TIMER_RUNNING;\r\n}\r\nstatic int mld_xmarksources(struct ifmcaddr6 *pmc, int nsrcs,\r\nconst struct in6_addr *srcs)\r\n{\r\nstruct ip6_sf_list *psf;\r\nint i, scount;\r\nscount = 0;\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next) {\r\nif (scount == nsrcs)\r\nbreak;\r\nfor (i=0; i<nsrcs; i++) {\r\nif (psf->sf_count[MCAST_INCLUDE] ||\r\npmc->mca_sfcount[MCAST_EXCLUDE] !=\r\npsf->sf_count[MCAST_EXCLUDE])\r\ncontinue;\r\nif (ipv6_addr_equal(&srcs[i], &psf->sf_addr)) {\r\nscount++;\r\nbreak;\r\n}\r\n}\r\n}\r\npmc->mca_flags &= ~MAF_GSQUERY;\r\nif (scount == nsrcs)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int mld_marksources(struct ifmcaddr6 *pmc, int nsrcs,\r\nconst struct in6_addr *srcs)\r\n{\r\nstruct ip6_sf_list *psf;\r\nint i, scount;\r\nif (pmc->mca_sfmode == MCAST_EXCLUDE)\r\nreturn mld_xmarksources(pmc, nsrcs, srcs);\r\nscount = 0;\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next) {\r\nif (scount == nsrcs)\r\nbreak;\r\nfor (i=0; i<nsrcs; i++) {\r\nif (ipv6_addr_equal(&srcs[i], &psf->sf_addr)) {\r\npsf->sf_gsresp = 1;\r\nscount++;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!scount) {\r\npmc->mca_flags &= ~MAF_GSQUERY;\r\nreturn 0;\r\n}\r\npmc->mca_flags |= MAF_GSQUERY;\r\nreturn 1;\r\n}\r\nint igmp6_event_query(struct sk_buff *skb)\r\n{\r\nstruct mld2_query *mlh2 = NULL;\r\nstruct ifmcaddr6 *ma;\r\nconst struct in6_addr *group;\r\nunsigned long max_delay;\r\nstruct inet6_dev *idev;\r\nstruct mld_msg *mld;\r\nint group_type;\r\nint mark = 0;\r\nint len;\r\nif (!pskb_may_pull(skb, sizeof(struct in6_addr)))\r\nreturn -EINVAL;\r\nlen = ntohs(ipv6_hdr(skb)->payload_len) + sizeof(struct ipv6hdr);\r\nlen -= skb_network_header_len(skb);\r\nif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL))\r\nreturn -EINVAL;\r\nidev = __in6_dev_get(skb->dev);\r\nif (idev == NULL)\r\nreturn 0;\r\nmld = (struct mld_msg *)icmp6_hdr(skb);\r\ngroup = &mld->mld_mca;\r\ngroup_type = ipv6_addr_type(group);\r\nif (group_type != IPV6_ADDR_ANY &&\r\n!(group_type&IPV6_ADDR_MULTICAST))\r\nreturn -EINVAL;\r\nif (len == 24) {\r\nint switchback;\r\nmax_delay = (ntohs(mld->mld_maxdelay)*HZ)/1000;\r\nswitchback = (idev->mc_qrv + 1) * max_delay;\r\nidev->mc_v1_seen = jiffies + switchback;\r\nidev->mc_ifc_count = 0;\r\nif (del_timer(&idev->mc_ifc_timer))\r\n__in6_dev_put(idev);\r\nmld_clear_delrec(idev);\r\n} else if (len >= 28) {\r\nint srcs_offset = sizeof(struct mld2_query) -\r\nsizeof(struct icmp6hdr);\r\nif (!pskb_may_pull(skb, srcs_offset))\r\nreturn -EINVAL;\r\nmlh2 = (struct mld2_query *)skb_transport_header(skb);\r\nmax_delay = (MLDV2_MRC(ntohs(mlh2->mld2q_mrc))*HZ)/1000;\r\nif (!max_delay)\r\nmax_delay = 1;\r\nidev->mc_maxdelay = max_delay;\r\nif (mlh2->mld2q_qrv)\r\nidev->mc_qrv = mlh2->mld2q_qrv;\r\nif (group_type == IPV6_ADDR_ANY) {\r\nif (mlh2->mld2q_nsrcs)\r\nreturn -EINVAL;\r\nmld_gq_start_timer(idev);\r\nreturn 0;\r\n}\r\nif (mlh2->mld2q_nsrcs != 0) {\r\nif (!pskb_may_pull(skb, srcs_offset +\r\nntohs(mlh2->mld2q_nsrcs) * sizeof(struct in6_addr)))\r\nreturn -EINVAL;\r\nmlh2 = (struct mld2_query *)skb_transport_header(skb);\r\nmark = 1;\r\n}\r\n} else\r\nreturn -EINVAL;\r\nread_lock_bh(&idev->lock);\r\nif (group_type == IPV6_ADDR_ANY) {\r\nfor (ma = idev->mc_list; ma; ma=ma->next) {\r\nspin_lock_bh(&ma->mca_lock);\r\nigmp6_group_queried(ma, max_delay);\r\nspin_unlock_bh(&ma->mca_lock);\r\n}\r\n} else {\r\nfor (ma = idev->mc_list; ma; ma=ma->next) {\r\nif (!ipv6_addr_equal(group, &ma->mca_addr))\r\ncontinue;\r\nspin_lock_bh(&ma->mca_lock);\r\nif (ma->mca_flags & MAF_TIMER_RUNNING) {\r\nif (!mark)\r\nma->mca_flags &= ~MAF_GSQUERY;\r\n} else {\r\nif (mark)\r\nma->mca_flags |= MAF_GSQUERY;\r\nelse\r\nma->mca_flags &= ~MAF_GSQUERY;\r\n}\r\nif (!(ma->mca_flags & MAF_GSQUERY) ||\r\nmld_marksources(ma, ntohs(mlh2->mld2q_nsrcs), mlh2->mld2q_srcs))\r\nigmp6_group_queried(ma, max_delay);\r\nspin_unlock_bh(&ma->mca_lock);\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&idev->lock);\r\nreturn 0;\r\n}\r\nint igmp6_event_report(struct sk_buff *skb)\r\n{\r\nstruct ifmcaddr6 *ma;\r\nstruct inet6_dev *idev;\r\nstruct mld_msg *mld;\r\nint addr_type;\r\nif (skb->pkt_type == PACKET_LOOPBACK)\r\nreturn 0;\r\nif (skb->pkt_type != PACKET_MULTICAST &&\r\nskb->pkt_type != PACKET_BROADCAST)\r\nreturn 0;\r\nif (!pskb_may_pull(skb, sizeof(*mld) - sizeof(struct icmp6hdr)))\r\nreturn -EINVAL;\r\nmld = (struct mld_msg *)icmp6_hdr(skb);\r\naddr_type = ipv6_addr_type(&ipv6_hdr(skb)->saddr);\r\nif (addr_type != IPV6_ADDR_ANY &&\r\n!(addr_type&IPV6_ADDR_LINKLOCAL))\r\nreturn -EINVAL;\r\nidev = __in6_dev_get(skb->dev);\r\nif (idev == NULL)\r\nreturn -ENODEV;\r\nread_lock_bh(&idev->lock);\r\nfor (ma = idev->mc_list; ma; ma=ma->next) {\r\nif (ipv6_addr_equal(&ma->mca_addr, &mld->mld_mca)) {\r\nspin_lock(&ma->mca_lock);\r\nif (del_timer(&ma->mca_timer))\r\natomic_dec(&ma->mca_refcnt);\r\nma->mca_flags &= ~(MAF_LAST_REPORTER|MAF_TIMER_RUNNING);\r\nspin_unlock(&ma->mca_lock);\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&idev->lock);\r\nreturn 0;\r\n}\r\nstatic int is_in(struct ifmcaddr6 *pmc, struct ip6_sf_list *psf, int type,\r\nint gdeleted, int sdeleted)\r\n{\r\nswitch (type) {\r\ncase MLD2_MODE_IS_INCLUDE:\r\ncase MLD2_MODE_IS_EXCLUDE:\r\nif (gdeleted || sdeleted)\r\nreturn 0;\r\nif (!((pmc->mca_flags & MAF_GSQUERY) && !psf->sf_gsresp)) {\r\nif (pmc->mca_sfmode == MCAST_INCLUDE)\r\nreturn 1;\r\nif (psf->sf_count[MCAST_INCLUDE])\r\nreturn type == MLD2_MODE_IS_INCLUDE;\r\nreturn pmc->mca_sfcount[MCAST_EXCLUDE] ==\r\npsf->sf_count[MCAST_EXCLUDE];\r\n}\r\nreturn 0;\r\ncase MLD2_CHANGE_TO_INCLUDE:\r\nif (gdeleted || sdeleted)\r\nreturn 0;\r\nreturn psf->sf_count[MCAST_INCLUDE] != 0;\r\ncase MLD2_CHANGE_TO_EXCLUDE:\r\nif (gdeleted || sdeleted)\r\nreturn 0;\r\nif (pmc->mca_sfcount[MCAST_EXCLUDE] == 0 ||\r\npsf->sf_count[MCAST_INCLUDE])\r\nreturn 0;\r\nreturn pmc->mca_sfcount[MCAST_EXCLUDE] ==\r\npsf->sf_count[MCAST_EXCLUDE];\r\ncase MLD2_ALLOW_NEW_SOURCES:\r\nif (gdeleted || !psf->sf_crcount)\r\nreturn 0;\r\nreturn (pmc->mca_sfmode == MCAST_INCLUDE) ^ sdeleted;\r\ncase MLD2_BLOCK_OLD_SOURCES:\r\nif (pmc->mca_sfmode == MCAST_INCLUDE)\r\nreturn gdeleted || (psf->sf_crcount && sdeleted);\r\nreturn psf->sf_crcount && !gdeleted && !sdeleted;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmld_scount(struct ifmcaddr6 *pmc, int type, int gdeleted, int sdeleted)\r\n{\r\nstruct ip6_sf_list *psf;\r\nint scount = 0;\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next) {\r\nif (!is_in(pmc, psf, type, gdeleted, sdeleted))\r\ncontinue;\r\nscount++;\r\n}\r\nreturn scount;\r\n}\r\nstatic struct sk_buff *mld_newpack(struct net_device *dev, int size)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct sock *sk = net->ipv6.igmp_sk;\r\nstruct sk_buff *skb;\r\nstruct mld2_report *pmr;\r\nstruct in6_addr addr_buf;\r\nconst struct in6_addr *saddr;\r\nint err;\r\nu8 ra[8] = { IPPROTO_ICMPV6, 0,\r\nIPV6_TLV_ROUTERALERT, 2, 0, 0,\r\nIPV6_TLV_PADN, 0 };\r\nsize += LL_ALLOCATED_SPACE(dev);\r\nsize = min_t(int, size, SKB_MAX_ORDER(0, 0));\r\nskb = sock_alloc_send_skb(sk, size, 1, &err);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, LL_RESERVED_SPACE(dev));\r\nif (ipv6_get_lladdr(dev, &addr_buf, IFA_F_TENTATIVE)) {\r\nsaddr = &in6addr_any;\r\n} else\r\nsaddr = &addr_buf;\r\nip6_nd_hdr(sk, skb, dev, saddr, &mld2_all_mcr, NEXTHDR_HOP, 0);\r\nmemcpy(skb_put(skb, sizeof(ra)), ra, sizeof(ra));\r\nskb_set_transport_header(skb, skb_tail_pointer(skb) - skb->data);\r\nskb_put(skb, sizeof(*pmr));\r\npmr = (struct mld2_report *)skb_transport_header(skb);\r\npmr->mld2r_type = ICMPV6_MLD2_REPORT;\r\npmr->mld2r_resv1 = 0;\r\npmr->mld2r_cksum = 0;\r\npmr->mld2r_resv2 = 0;\r\npmr->mld2r_ngrec = 0;\r\nreturn skb;\r\n}\r\nstatic void mld_sendpack(struct sk_buff *skb)\r\n{\r\nstruct ipv6hdr *pip6 = ipv6_hdr(skb);\r\nstruct mld2_report *pmr =\r\n(struct mld2_report *)skb_transport_header(skb);\r\nint payload_len, mldlen;\r\nstruct inet6_dev *idev;\r\nstruct net *net = dev_net(skb->dev);\r\nint err;\r\nstruct flowi6 fl6;\r\nstruct dst_entry *dst;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(skb->dev);\r\nIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\r\npayload_len = (skb->tail - skb->network_header) - sizeof(*pip6);\r\nmldlen = skb->tail - skb->transport_header;\r\npip6->payload_len = htons(payload_len);\r\npmr->mld2r_cksum = csum_ipv6_magic(&pip6->saddr, &pip6->daddr, mldlen,\r\nIPPROTO_ICMPV6,\r\ncsum_partial(skb_transport_header(skb),\r\nmldlen, 0));\r\ndst = icmp6_dst_alloc(skb->dev, NULL, &ipv6_hdr(skb)->daddr);\r\nif (!dst) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nicmpv6_flow_init(net->ipv6.igmp_sk, &fl6, ICMPV6_MLD2_REPORT,\r\n&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\r\nskb->dev->ifindex);\r\ndst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\r\nerr = 0;\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ndst = NULL;\r\n}\r\nskb_dst_set(skb, dst);\r\nif (err)\r\ngoto err_out;\r\npayload_len = skb->len;\r\nerr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, skb->dev,\r\ndst_output);\r\nout:\r\nif (!err) {\r\nICMP6MSGOUT_INC_STATS_BH(net, idev, ICMPV6_MLD2_REPORT);\r\nICMP6_INC_STATS_BH(net, idev, ICMP6_MIB_OUTMSGS);\r\nIP6_UPD_PO_STATS_BH(net, idev, IPSTATS_MIB_OUTMCAST, payload_len);\r\n} else\r\nIP6_INC_STATS_BH(net, idev, IPSTATS_MIB_OUTDISCARDS);\r\nrcu_read_unlock();\r\nreturn;\r\nerr_out:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int grec_size(struct ifmcaddr6 *pmc, int type, int gdel, int sdel)\r\n{\r\nreturn sizeof(struct mld2_grec) + 16 * mld_scount(pmc,type,gdel,sdel);\r\n}\r\nstatic struct sk_buff *add_grhead(struct sk_buff *skb, struct ifmcaddr6 *pmc,\r\nint type, struct mld2_grec **ppgr)\r\n{\r\nstruct net_device *dev = pmc->idev->dev;\r\nstruct mld2_report *pmr;\r\nstruct mld2_grec *pgr;\r\nif (!skb)\r\nskb = mld_newpack(dev, dev->mtu);\r\nif (!skb)\r\nreturn NULL;\r\npgr = (struct mld2_grec *)skb_put(skb, sizeof(struct mld2_grec));\r\npgr->grec_type = type;\r\npgr->grec_auxwords = 0;\r\npgr->grec_nsrcs = 0;\r\npgr->grec_mca = pmc->mca_addr;\r\npmr = (struct mld2_report *)skb_transport_header(skb);\r\npmr->mld2r_ngrec = htons(ntohs(pmr->mld2r_ngrec)+1);\r\n*ppgr = pgr;\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,\r\nint type, int gdeleted, int sdeleted)\r\n{\r\nstruct net_device *dev = pmc->idev->dev;\r\nstruct mld2_report *pmr;\r\nstruct mld2_grec *pgr = NULL;\r\nstruct ip6_sf_list *psf, *psf_next, *psf_prev, **psf_list;\r\nint scount, stotal, first, isquery, truncate;\r\nif (pmc->mca_flags & MAF_NOREPORT)\r\nreturn skb;\r\nisquery = type == MLD2_MODE_IS_INCLUDE ||\r\ntype == MLD2_MODE_IS_EXCLUDE;\r\ntruncate = type == MLD2_MODE_IS_EXCLUDE ||\r\ntype == MLD2_CHANGE_TO_EXCLUDE;\r\nstotal = scount = 0;\r\npsf_list = sdeleted ? &pmc->mca_tomb : &pmc->mca_sources;\r\nif (!*psf_list)\r\ngoto empty_source;\r\npmr = skb ? (struct mld2_report *)skb_transport_header(skb) : NULL;\r\nif (truncate) {\r\nif (pmr && pmr->mld2r_ngrec &&\r\nAVAILABLE(skb) < grec_size(pmc, type, gdeleted, sdeleted)) {\r\nif (skb)\r\nmld_sendpack(skb);\r\nskb = mld_newpack(dev, dev->mtu);\r\n}\r\n}\r\nfirst = 1;\r\npsf_prev = NULL;\r\nfor (psf=*psf_list; psf; psf=psf_next) {\r\nstruct in6_addr *psrc;\r\npsf_next = psf->sf_next;\r\nif (!is_in(pmc, psf, type, gdeleted, sdeleted)) {\r\npsf_prev = psf;\r\ncontinue;\r\n}\r\nif (isquery)\r\npsf->sf_gsresp = 0;\r\nif (AVAILABLE(skb) < sizeof(*psrc) +\r\nfirst*sizeof(struct mld2_grec)) {\r\nif (truncate && !first)\r\nbreak;\r\nif (pgr)\r\npgr->grec_nsrcs = htons(scount);\r\nif (skb)\r\nmld_sendpack(skb);\r\nskb = mld_newpack(dev, dev->mtu);\r\nfirst = 1;\r\nscount = 0;\r\n}\r\nif (first) {\r\nskb = add_grhead(skb, pmc, type, &pgr);\r\nfirst = 0;\r\n}\r\nif (!skb)\r\nreturn NULL;\r\npsrc = (struct in6_addr *)skb_put(skb, sizeof(*psrc));\r\n*psrc = psf->sf_addr;\r\nscount++; stotal++;\r\nif ((type == MLD2_ALLOW_NEW_SOURCES ||\r\ntype == MLD2_BLOCK_OLD_SOURCES) && psf->sf_crcount) {\r\npsf->sf_crcount--;\r\nif ((sdeleted || gdeleted) && psf->sf_crcount == 0) {\r\nif (psf_prev)\r\npsf_prev->sf_next = psf->sf_next;\r\nelse\r\n*psf_list = psf->sf_next;\r\nkfree(psf);\r\ncontinue;\r\n}\r\n}\r\npsf_prev = psf;\r\n}\r\nempty_source:\r\nif (!stotal) {\r\nif (type == MLD2_ALLOW_NEW_SOURCES ||\r\ntype == MLD2_BLOCK_OLD_SOURCES)\r\nreturn skb;\r\nif (pmc->mca_crcount || isquery) {\r\nif (skb && AVAILABLE(skb) < sizeof(struct mld2_grec)) {\r\nmld_sendpack(skb);\r\nskb = NULL;\r\n}\r\nskb = add_grhead(skb, pmc, type, &pgr);\r\n}\r\n}\r\nif (pgr)\r\npgr->grec_nsrcs = htons(scount);\r\nif (isquery)\r\npmc->mca_flags &= ~MAF_GSQUERY;\r\nreturn skb;\r\n}\r\nstatic void mld_send_report(struct inet6_dev *idev, struct ifmcaddr6 *pmc)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nint type;\r\nif (!pmc) {\r\nread_lock_bh(&idev->lock);\r\nfor (pmc=idev->mc_list; pmc; pmc=pmc->next) {\r\nif (pmc->mca_flags & MAF_NOREPORT)\r\ncontinue;\r\nspin_lock_bh(&pmc->mca_lock);\r\nif (pmc->mca_sfcount[MCAST_EXCLUDE])\r\ntype = MLD2_MODE_IS_EXCLUDE;\r\nelse\r\ntype = MLD2_MODE_IS_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\nspin_unlock_bh(&pmc->mca_lock);\r\n}\r\nread_unlock_bh(&idev->lock);\r\n} else {\r\nspin_lock_bh(&pmc->mca_lock);\r\nif (pmc->mca_sfcount[MCAST_EXCLUDE])\r\ntype = MLD2_MODE_IS_EXCLUDE;\r\nelse\r\ntype = MLD2_MODE_IS_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\nspin_unlock_bh(&pmc->mca_lock);\r\n}\r\nif (skb)\r\nmld_sendpack(skb);\r\n}\r\nstatic void mld_clear_zeros(struct ip6_sf_list **ppsf)\r\n{\r\nstruct ip6_sf_list *psf_prev, *psf_next, *psf;\r\npsf_prev = NULL;\r\nfor (psf=*ppsf; psf; psf = psf_next) {\r\npsf_next = psf->sf_next;\r\nif (psf->sf_crcount == 0) {\r\nif (psf_prev)\r\npsf_prev->sf_next = psf->sf_next;\r\nelse\r\n*ppsf = psf->sf_next;\r\nkfree(psf);\r\n} else\r\npsf_prev = psf;\r\n}\r\n}\r\nstatic void mld_send_cr(struct inet6_dev *idev)\r\n{\r\nstruct ifmcaddr6 *pmc, *pmc_prev, *pmc_next;\r\nstruct sk_buff *skb = NULL;\r\nint type, dtype;\r\nread_lock_bh(&idev->lock);\r\nspin_lock(&idev->mc_lock);\r\npmc_prev = NULL;\r\nfor (pmc=idev->mc_tomb; pmc; pmc=pmc_next) {\r\npmc_next = pmc->next;\r\nif (pmc->mca_sfmode == MCAST_INCLUDE) {\r\ntype = MLD2_BLOCK_OLD_SOURCES;\r\ndtype = MLD2_BLOCK_OLD_SOURCES;\r\nskb = add_grec(skb, pmc, type, 1, 0);\r\nskb = add_grec(skb, pmc, dtype, 1, 1);\r\n}\r\nif (pmc->mca_crcount) {\r\nif (pmc->mca_sfmode == MCAST_EXCLUDE) {\r\ntype = MLD2_CHANGE_TO_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 1, 0);\r\n}\r\npmc->mca_crcount--;\r\nif (pmc->mca_crcount == 0) {\r\nmld_clear_zeros(&pmc->mca_tomb);\r\nmld_clear_zeros(&pmc->mca_sources);\r\n}\r\n}\r\nif (pmc->mca_crcount == 0 && !pmc->mca_tomb &&\r\n!pmc->mca_sources) {\r\nif (pmc_prev)\r\npmc_prev->next = pmc_next;\r\nelse\r\nidev->mc_tomb = pmc_next;\r\nin6_dev_put(pmc->idev);\r\nkfree(pmc);\r\n} else\r\npmc_prev = pmc;\r\n}\r\nspin_unlock(&idev->mc_lock);\r\nfor (pmc=idev->mc_list; pmc; pmc=pmc->next) {\r\nspin_lock_bh(&pmc->mca_lock);\r\nif (pmc->mca_sfcount[MCAST_EXCLUDE]) {\r\ntype = MLD2_BLOCK_OLD_SOURCES;\r\ndtype = MLD2_ALLOW_NEW_SOURCES;\r\n} else {\r\ntype = MLD2_ALLOW_NEW_SOURCES;\r\ndtype = MLD2_BLOCK_OLD_SOURCES;\r\n}\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\nskb = add_grec(skb, pmc, dtype, 0, 1);\r\nif (pmc->mca_crcount) {\r\nif (pmc->mca_sfmode == MCAST_EXCLUDE)\r\ntype = MLD2_CHANGE_TO_EXCLUDE;\r\nelse\r\ntype = MLD2_CHANGE_TO_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\npmc->mca_crcount--;\r\n}\r\nspin_unlock_bh(&pmc->mca_lock);\r\n}\r\nread_unlock_bh(&idev->lock);\r\nif (!skb)\r\nreturn;\r\n(void) mld_sendpack(skb);\r\n}\r\nstatic void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct sock *sk = net->ipv6.igmp_sk;\r\nstruct inet6_dev *idev;\r\nstruct sk_buff *skb;\r\nstruct mld_msg *hdr;\r\nconst struct in6_addr *snd_addr, *saddr;\r\nstruct in6_addr addr_buf;\r\nint err, len, payload_len, full_len;\r\nu8 ra[8] = { IPPROTO_ICMPV6, 0,\r\nIPV6_TLV_ROUTERALERT, 2, 0, 0,\r\nIPV6_TLV_PADN, 0 };\r\nstruct flowi6 fl6;\r\nstruct dst_entry *dst;\r\nif (type == ICMPV6_MGM_REDUCTION)\r\nsnd_addr = &in6addr_linklocal_allrouters;\r\nelse\r\nsnd_addr = addr;\r\nlen = sizeof(struct icmp6hdr) + sizeof(struct in6_addr);\r\npayload_len = len + sizeof(ra);\r\nfull_len = sizeof(struct ipv6hdr) + payload_len;\r\nrcu_read_lock();\r\nIP6_UPD_PO_STATS(net, __in6_dev_get(dev),\r\nIPSTATS_MIB_OUT, full_len);\r\nrcu_read_unlock();\r\nskb = sock_alloc_send_skb(sk, LL_ALLOCATED_SPACE(dev) + full_len, 1, &err);\r\nif (skb == NULL) {\r\nrcu_read_lock();\r\nIP6_INC_STATS(net, __in6_dev_get(dev),\r\nIPSTATS_MIB_OUTDISCARDS);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nskb_reserve(skb, LL_RESERVED_SPACE(dev));\r\nif (ipv6_get_lladdr(dev, &addr_buf, IFA_F_TENTATIVE)) {\r\nsaddr = &in6addr_any;\r\n} else\r\nsaddr = &addr_buf;\r\nip6_nd_hdr(sk, skb, dev, saddr, snd_addr, NEXTHDR_HOP, payload_len);\r\nmemcpy(skb_put(skb, sizeof(ra)), ra, sizeof(ra));\r\nhdr = (struct mld_msg *) skb_put(skb, sizeof(struct mld_msg));\r\nmemset(hdr, 0, sizeof(struct mld_msg));\r\nhdr->mld_type = type;\r\nipv6_addr_copy(&hdr->mld_mca, addr);\r\nhdr->mld_cksum = csum_ipv6_magic(saddr, snd_addr, len,\r\nIPPROTO_ICMPV6,\r\ncsum_partial(hdr, len, 0));\r\nrcu_read_lock();\r\nidev = __in6_dev_get(skb->dev);\r\ndst = icmp6_dst_alloc(skb->dev, NULL, &ipv6_hdr(skb)->daddr);\r\nif (!dst) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nicmpv6_flow_init(sk, &fl6, type,\r\n&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\r\nskb->dev->ifindex);\r\ndst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ngoto err_out;\r\n}\r\nskb_dst_set(skb, dst);\r\nerr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, skb->dev,\r\ndst_output);\r\nout:\r\nif (!err) {\r\nICMP6MSGOUT_INC_STATS(net, idev, type);\r\nICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\r\nIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, full_len);\r\n} else\r\nIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\r\nrcu_read_unlock();\r\nreturn;\r\nerr_out:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int ip6_mc_del1_src(struct ifmcaddr6 *pmc, int sfmode,\r\nconst struct in6_addr *psfsrc)\r\n{\r\nstruct ip6_sf_list *psf, *psf_prev;\r\nint rv = 0;\r\npsf_prev = NULL;\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next) {\r\nif (ipv6_addr_equal(&psf->sf_addr, psfsrc))\r\nbreak;\r\npsf_prev = psf;\r\n}\r\nif (!psf || psf->sf_count[sfmode] == 0) {\r\nreturn -ESRCH;\r\n}\r\npsf->sf_count[sfmode]--;\r\nif (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {\r\nstruct inet6_dev *idev = pmc->idev;\r\nif (psf_prev)\r\npsf_prev->sf_next = psf->sf_next;\r\nelse\r\npmc->mca_sources = psf->sf_next;\r\nif (psf->sf_oldin && !(pmc->mca_flags & MAF_NOREPORT) &&\r\n!MLD_V1_SEEN(idev)) {\r\npsf->sf_crcount = idev->mc_qrv;\r\npsf->sf_next = pmc->mca_tomb;\r\npmc->mca_tomb = psf;\r\nrv = 1;\r\n} else\r\nkfree(psf);\r\n}\r\nreturn rv;\r\n}\r\nstatic int ip6_mc_del_src(struct inet6_dev *idev, const struct in6_addr *pmca,\r\nint sfmode, int sfcount, const struct in6_addr *psfsrc,\r\nint delta)\r\n{\r\nstruct ifmcaddr6 *pmc;\r\nint changerec = 0;\r\nint i, err;\r\nif (!idev)\r\nreturn -ENODEV;\r\nread_lock_bh(&idev->lock);\r\nfor (pmc=idev->mc_list; pmc; pmc=pmc->next) {\r\nif (ipv6_addr_equal(pmca, &pmc->mca_addr))\r\nbreak;\r\n}\r\nif (!pmc) {\r\nread_unlock_bh(&idev->lock);\r\nreturn -ESRCH;\r\n}\r\nspin_lock_bh(&pmc->mca_lock);\r\nsf_markstate(pmc);\r\nif (!delta) {\r\nif (!pmc->mca_sfcount[sfmode]) {\r\nspin_unlock_bh(&pmc->mca_lock);\r\nread_unlock_bh(&idev->lock);\r\nreturn -EINVAL;\r\n}\r\npmc->mca_sfcount[sfmode]--;\r\n}\r\nerr = 0;\r\nfor (i=0; i<sfcount; i++) {\r\nint rv = ip6_mc_del1_src(pmc, sfmode, &psfsrc[i]);\r\nchangerec |= rv > 0;\r\nif (!err && rv < 0)\r\nerr = rv;\r\n}\r\nif (pmc->mca_sfmode == MCAST_EXCLUDE &&\r\npmc->mca_sfcount[MCAST_EXCLUDE] == 0 &&\r\npmc->mca_sfcount[MCAST_INCLUDE]) {\r\nstruct ip6_sf_list *psf;\r\npmc->mca_sfmode = MCAST_INCLUDE;\r\npmc->mca_crcount = idev->mc_qrv;\r\nidev->mc_ifc_count = pmc->mca_crcount;\r\nfor (psf=pmc->mca_sources; psf; psf = psf->sf_next)\r\npsf->sf_crcount = 0;\r\nmld_ifc_event(pmc->idev);\r\n} else if (sf_setstate(pmc) || changerec)\r\nmld_ifc_event(pmc->idev);\r\nspin_unlock_bh(&pmc->mca_lock);\r\nread_unlock_bh(&idev->lock);\r\nreturn err;\r\n}\r\nstatic int ip6_mc_add1_src(struct ifmcaddr6 *pmc, int sfmode,\r\nconst struct in6_addr *psfsrc, int delta)\r\n{\r\nstruct ip6_sf_list *psf, *psf_prev;\r\npsf_prev = NULL;\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next) {\r\nif (ipv6_addr_equal(&psf->sf_addr, psfsrc))\r\nbreak;\r\npsf_prev = psf;\r\n}\r\nif (!psf) {\r\npsf = kzalloc(sizeof(*psf), GFP_ATOMIC);\r\nif (!psf)\r\nreturn -ENOBUFS;\r\npsf->sf_addr = *psfsrc;\r\nif (psf_prev) {\r\npsf_prev->sf_next = psf;\r\n} else\r\npmc->mca_sources = psf;\r\n}\r\npsf->sf_count[sfmode]++;\r\nreturn 0;\r\n}\r\nstatic void sf_markstate(struct ifmcaddr6 *pmc)\r\n{\r\nstruct ip6_sf_list *psf;\r\nint mca_xcount = pmc->mca_sfcount[MCAST_EXCLUDE];\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next)\r\nif (pmc->mca_sfcount[MCAST_EXCLUDE]) {\r\npsf->sf_oldin = mca_xcount ==\r\npsf->sf_count[MCAST_EXCLUDE] &&\r\n!psf->sf_count[MCAST_INCLUDE];\r\n} else\r\npsf->sf_oldin = psf->sf_count[MCAST_INCLUDE] != 0;\r\n}\r\nstatic int sf_setstate(struct ifmcaddr6 *pmc)\r\n{\r\nstruct ip6_sf_list *psf, *dpsf;\r\nint mca_xcount = pmc->mca_sfcount[MCAST_EXCLUDE];\r\nint qrv = pmc->idev->mc_qrv;\r\nint new_in, rv;\r\nrv = 0;\r\nfor (psf=pmc->mca_sources; psf; psf=psf->sf_next) {\r\nif (pmc->mca_sfcount[MCAST_EXCLUDE]) {\r\nnew_in = mca_xcount == psf->sf_count[MCAST_EXCLUDE] &&\r\n!psf->sf_count[MCAST_INCLUDE];\r\n} else\r\nnew_in = psf->sf_count[MCAST_INCLUDE] != 0;\r\nif (new_in) {\r\nif (!psf->sf_oldin) {\r\nstruct ip6_sf_list *prev = NULL;\r\nfor (dpsf=pmc->mca_tomb; dpsf;\r\ndpsf=dpsf->sf_next) {\r\nif (ipv6_addr_equal(&dpsf->sf_addr,\r\n&psf->sf_addr))\r\nbreak;\r\nprev = dpsf;\r\n}\r\nif (dpsf) {\r\nif (prev)\r\nprev->sf_next = dpsf->sf_next;\r\nelse\r\npmc->mca_tomb = dpsf->sf_next;\r\nkfree(dpsf);\r\n}\r\npsf->sf_crcount = qrv;\r\nrv++;\r\n}\r\n} else if (psf->sf_oldin) {\r\npsf->sf_crcount = 0;\r\nfor (dpsf=pmc->mca_tomb; dpsf; dpsf=dpsf->sf_next)\r\nif (ipv6_addr_equal(&dpsf->sf_addr,\r\n&psf->sf_addr))\r\nbreak;\r\nif (!dpsf) {\r\ndpsf = kmalloc(sizeof(*dpsf), GFP_ATOMIC);\r\nif (!dpsf)\r\ncontinue;\r\n*dpsf = *psf;\r\ndpsf->sf_next = pmc->mca_tomb;\r\npmc->mca_tomb = dpsf;\r\n}\r\ndpsf->sf_crcount = qrv;\r\nrv++;\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic int ip6_mc_add_src(struct inet6_dev *idev, const struct in6_addr *pmca,\r\nint sfmode, int sfcount, const struct in6_addr *psfsrc,\r\nint delta)\r\n{\r\nstruct ifmcaddr6 *pmc;\r\nint isexclude;\r\nint i, err;\r\nif (!idev)\r\nreturn -ENODEV;\r\nread_lock_bh(&idev->lock);\r\nfor (pmc=idev->mc_list; pmc; pmc=pmc->next) {\r\nif (ipv6_addr_equal(pmca, &pmc->mca_addr))\r\nbreak;\r\n}\r\nif (!pmc) {\r\nread_unlock_bh(&idev->lock);\r\nreturn -ESRCH;\r\n}\r\nspin_lock_bh(&pmc->mca_lock);\r\nsf_markstate(pmc);\r\nisexclude = pmc->mca_sfmode == MCAST_EXCLUDE;\r\nif (!delta)\r\npmc->mca_sfcount[sfmode]++;\r\nerr = 0;\r\nfor (i=0; i<sfcount; i++) {\r\nerr = ip6_mc_add1_src(pmc, sfmode, &psfsrc[i], delta);\r\nif (err)\r\nbreak;\r\n}\r\nif (err) {\r\nint j;\r\nif (!delta)\r\npmc->mca_sfcount[sfmode]--;\r\nfor (j=0; j<i; j++)\r\n(void) ip6_mc_del1_src(pmc, sfmode, &psfsrc[i]);\r\n} else if (isexclude != (pmc->mca_sfcount[MCAST_EXCLUDE] != 0)) {\r\nstruct ip6_sf_list *psf;\r\nif (pmc->mca_sfcount[MCAST_EXCLUDE])\r\npmc->mca_sfmode = MCAST_EXCLUDE;\r\nelse if (pmc->mca_sfcount[MCAST_INCLUDE])\r\npmc->mca_sfmode = MCAST_INCLUDE;\r\npmc->mca_crcount = idev->mc_qrv;\r\nidev->mc_ifc_count = pmc->mca_crcount;\r\nfor (psf=pmc->mca_sources; psf; psf = psf->sf_next)\r\npsf->sf_crcount = 0;\r\nmld_ifc_event(idev);\r\n} else if (sf_setstate(pmc))\r\nmld_ifc_event(idev);\r\nspin_unlock_bh(&pmc->mca_lock);\r\nread_unlock_bh(&idev->lock);\r\nreturn err;\r\n}\r\nstatic void ip6_mc_clear_src(struct ifmcaddr6 *pmc)\r\n{\r\nstruct ip6_sf_list *psf, *nextpsf;\r\nfor (psf=pmc->mca_tomb; psf; psf=nextpsf) {\r\nnextpsf = psf->sf_next;\r\nkfree(psf);\r\n}\r\npmc->mca_tomb = NULL;\r\nfor (psf=pmc->mca_sources; psf; psf=nextpsf) {\r\nnextpsf = psf->sf_next;\r\nkfree(psf);\r\n}\r\npmc->mca_sources = NULL;\r\npmc->mca_sfmode = MCAST_EXCLUDE;\r\npmc->mca_sfcount[MCAST_INCLUDE] = 0;\r\npmc->mca_sfcount[MCAST_EXCLUDE] = 1;\r\n}\r\nstatic void igmp6_join_group(struct ifmcaddr6 *ma)\r\n{\r\nunsigned long delay;\r\nif (ma->mca_flags & MAF_NOREPORT)\r\nreturn;\r\nigmp6_send(&ma->mca_addr, ma->idev->dev, ICMPV6_MGM_REPORT);\r\ndelay = net_random() % IGMP6_UNSOLICITED_IVAL;\r\nspin_lock_bh(&ma->mca_lock);\r\nif (del_timer(&ma->mca_timer)) {\r\natomic_dec(&ma->mca_refcnt);\r\ndelay = ma->mca_timer.expires - jiffies;\r\n}\r\nif (!mod_timer(&ma->mca_timer, jiffies + delay))\r\natomic_inc(&ma->mca_refcnt);\r\nma->mca_flags |= MAF_TIMER_RUNNING | MAF_LAST_REPORTER;\r\nspin_unlock_bh(&ma->mca_lock);\r\n}\r\nstatic int ip6_mc_leave_src(struct sock *sk, struct ipv6_mc_socklist *iml,\r\nstruct inet6_dev *idev)\r\n{\r\nint err;\r\nif (!iml->sflist) {\r\nreturn ip6_mc_del_src(idev, &iml->addr, iml->sfmode, 0, NULL, 0);\r\n}\r\nerr = ip6_mc_del_src(idev, &iml->addr, iml->sfmode,\r\niml->sflist->sl_count, iml->sflist->sl_addr, 0);\r\nsock_kfree_s(sk, iml->sflist, IP6_SFLSIZE(iml->sflist->sl_max));\r\niml->sflist = NULL;\r\nreturn err;\r\n}\r\nstatic void igmp6_leave_group(struct ifmcaddr6 *ma)\r\n{\r\nif (MLD_V1_SEEN(ma->idev)) {\r\nif (ma->mca_flags & MAF_LAST_REPORTER)\r\nigmp6_send(&ma->mca_addr, ma->idev->dev,\r\nICMPV6_MGM_REDUCTION);\r\n} else {\r\nmld_add_delrec(ma->idev, ma);\r\nmld_ifc_event(ma->idev);\r\n}\r\n}\r\nstatic void mld_gq_timer_expire(unsigned long data)\r\n{\r\nstruct inet6_dev *idev = (struct inet6_dev *)data;\r\nidev->mc_gq_running = 0;\r\nmld_send_report(idev, NULL);\r\n__in6_dev_put(idev);\r\n}\r\nstatic void mld_ifc_timer_expire(unsigned long data)\r\n{\r\nstruct inet6_dev *idev = (struct inet6_dev *)data;\r\nmld_send_cr(idev);\r\nif (idev->mc_ifc_count) {\r\nidev->mc_ifc_count--;\r\nif (idev->mc_ifc_count)\r\nmld_ifc_start_timer(idev, idev->mc_maxdelay);\r\n}\r\n__in6_dev_put(idev);\r\n}\r\nstatic void mld_ifc_event(struct inet6_dev *idev)\r\n{\r\nif (MLD_V1_SEEN(idev))\r\nreturn;\r\nidev->mc_ifc_count = idev->mc_qrv;\r\nmld_ifc_start_timer(idev, 1);\r\n}\r\nstatic void igmp6_timer_handler(unsigned long data)\r\n{\r\nstruct ifmcaddr6 *ma = (struct ifmcaddr6 *) data;\r\nif (MLD_V1_SEEN(ma->idev))\r\nigmp6_send(&ma->mca_addr, ma->idev->dev, ICMPV6_MGM_REPORT);\r\nelse\r\nmld_send_report(ma->idev, ma);\r\nspin_lock(&ma->mca_lock);\r\nma->mca_flags |= MAF_LAST_REPORTER;\r\nma->mca_flags &= ~MAF_TIMER_RUNNING;\r\nspin_unlock(&ma->mca_lock);\r\nma_put(ma);\r\n}\r\nvoid ipv6_mc_unmap(struct inet6_dev *idev)\r\n{\r\nstruct ifmcaddr6 *i;\r\nread_lock_bh(&idev->lock);\r\nfor (i = idev->mc_list; i; i = i->next)\r\nigmp6_group_dropped(i);\r\nread_unlock_bh(&idev->lock);\r\n}\r\nvoid ipv6_mc_remap(struct inet6_dev *idev)\r\n{\r\nipv6_mc_up(idev);\r\n}\r\nvoid ipv6_mc_down(struct inet6_dev *idev)\r\n{\r\nstruct ifmcaddr6 *i;\r\nread_lock_bh(&idev->lock);\r\nidev->mc_ifc_count = 0;\r\nif (del_timer(&idev->mc_ifc_timer))\r\n__in6_dev_put(idev);\r\nidev->mc_gq_running = 0;\r\nif (del_timer(&idev->mc_gq_timer))\r\n__in6_dev_put(idev);\r\nfor (i = idev->mc_list; i; i=i->next)\r\nigmp6_group_dropped(i);\r\nread_unlock_bh(&idev->lock);\r\nmld_clear_delrec(idev);\r\n}\r\nvoid ipv6_mc_up(struct inet6_dev *idev)\r\n{\r\nstruct ifmcaddr6 *i;\r\nread_lock_bh(&idev->lock);\r\nfor (i = idev->mc_list; i; i=i->next)\r\nigmp6_group_added(i);\r\nread_unlock_bh(&idev->lock);\r\n}\r\nvoid ipv6_mc_init_dev(struct inet6_dev *idev)\r\n{\r\nwrite_lock_bh(&idev->lock);\r\nspin_lock_init(&idev->mc_lock);\r\nidev->mc_gq_running = 0;\r\nsetup_timer(&idev->mc_gq_timer, mld_gq_timer_expire,\r\n(unsigned long)idev);\r\nidev->mc_tomb = NULL;\r\nidev->mc_ifc_count = 0;\r\nsetup_timer(&idev->mc_ifc_timer, mld_ifc_timer_expire,\r\n(unsigned long)idev);\r\nidev->mc_qrv = MLD_QRV_DEFAULT;\r\nidev->mc_maxdelay = IGMP6_UNSOLICITED_IVAL;\r\nidev->mc_v1_seen = 0;\r\nwrite_unlock_bh(&idev->lock);\r\n}\r\nvoid ipv6_mc_destroy_dev(struct inet6_dev *idev)\r\n{\r\nstruct ifmcaddr6 *i;\r\nipv6_mc_down(idev);\r\n__ipv6_dev_mc_dec(idev, &in6addr_linklocal_allnodes);\r\nif (idev->cnf.forwarding)\r\n__ipv6_dev_mc_dec(idev, &in6addr_linklocal_allrouters);\r\nwrite_lock_bh(&idev->lock);\r\nwhile ((i = idev->mc_list) != NULL) {\r\nidev->mc_list = i->next;\r\nwrite_unlock_bh(&idev->lock);\r\nigmp6_group_dropped(i);\r\nma_put(i);\r\nwrite_lock_bh(&idev->lock);\r\n}\r\nwrite_unlock_bh(&idev->lock);\r\n}\r\nstatic inline struct ifmcaddr6 *igmp6_mc_get_first(struct seq_file *seq)\r\n{\r\nstruct ifmcaddr6 *im = NULL;\r\nstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\r\nstruct net *net = seq_file_net(seq);\r\nstate->idev = NULL;\r\nfor_each_netdev_rcu(net, state->dev) {\r\nstruct inet6_dev *idev;\r\nidev = __in6_dev_get(state->dev);\r\nif (!idev)\r\ncontinue;\r\nread_lock_bh(&idev->lock);\r\nim = idev->mc_list;\r\nif (im) {\r\nstate->idev = idev;\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nreturn im;\r\n}\r\nstatic struct ifmcaddr6 *igmp6_mc_get_next(struct seq_file *seq, struct ifmcaddr6 *im)\r\n{\r\nstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\r\nim = im->next;\r\nwhile (!im) {\r\nif (likely(state->idev != NULL))\r\nread_unlock_bh(&state->idev->lock);\r\nstate->dev = next_net_device_rcu(state->dev);\r\nif (!state->dev) {\r\nstate->idev = NULL;\r\nbreak;\r\n}\r\nstate->idev = __in6_dev_get(state->dev);\r\nif (!state->idev)\r\ncontinue;\r\nread_lock_bh(&state->idev->lock);\r\nim = state->idev->mc_list;\r\n}\r\nreturn im;\r\n}\r\nstatic struct ifmcaddr6 *igmp6_mc_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct ifmcaddr6 *im = igmp6_mc_get_first(seq);\r\nif (im)\r\nwhile (pos && (im = igmp6_mc_get_next(seq, im)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : im;\r\n}\r\nstatic void *igmp6_mc_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn igmp6_mc_get_idx(seq, *pos);\r\n}\r\nstatic void *igmp6_mc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ifmcaddr6 *im = igmp6_mc_get_next(seq, v);\r\n++*pos;\r\nreturn im;\r\n}\r\nstatic void igmp6_mc_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\r\nif (likely(state->idev != NULL)) {\r\nread_unlock_bh(&state->idev->lock);\r\nstate->idev = NULL;\r\n}\r\nstate->dev = NULL;\r\nrcu_read_unlock();\r\n}\r\nstatic int igmp6_mc_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct ifmcaddr6 *im = (struct ifmcaddr6 *)v;\r\nstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\r\nseq_printf(seq,\r\n"%-4d %-15s %pi6 %5d %08X %ld\n",\r\nstate->dev->ifindex, state->dev->name,\r\n&im->mca_addr,\r\nim->mca_users, im->mca_flags,\r\n(im->mca_flags&MAF_TIMER_RUNNING) ?\r\njiffies_to_clock_t(im->mca_timer.expires-jiffies) : 0);\r\nreturn 0;\r\n}\r\nstatic int igmp6_mc_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &igmp6_mc_seq_ops,\r\nsizeof(struct igmp6_mc_iter_state));\r\n}\r\nstatic inline struct ip6_sf_list *igmp6_mcf_get_first(struct seq_file *seq)\r\n{\r\nstruct ip6_sf_list *psf = NULL;\r\nstruct ifmcaddr6 *im = NULL;\r\nstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\r\nstruct net *net = seq_file_net(seq);\r\nstate->idev = NULL;\r\nstate->im = NULL;\r\nfor_each_netdev_rcu(net, state->dev) {\r\nstruct inet6_dev *idev;\r\nidev = __in6_dev_get(state->dev);\r\nif (unlikely(idev == NULL))\r\ncontinue;\r\nread_lock_bh(&idev->lock);\r\nim = idev->mc_list;\r\nif (likely(im != NULL)) {\r\nspin_lock_bh(&im->mca_lock);\r\npsf = im->mca_sources;\r\nif (likely(psf != NULL)) {\r\nstate->im = im;\r\nstate->idev = idev;\r\nbreak;\r\n}\r\nspin_unlock_bh(&im->mca_lock);\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nreturn psf;\r\n}\r\nstatic struct ip6_sf_list *igmp6_mcf_get_next(struct seq_file *seq, struct ip6_sf_list *psf)\r\n{\r\nstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\r\npsf = psf->sf_next;\r\nwhile (!psf) {\r\nspin_unlock_bh(&state->im->mca_lock);\r\nstate->im = state->im->next;\r\nwhile (!state->im) {\r\nif (likely(state->idev != NULL))\r\nread_unlock_bh(&state->idev->lock);\r\nstate->dev = next_net_device_rcu(state->dev);\r\nif (!state->dev) {\r\nstate->idev = NULL;\r\ngoto out;\r\n}\r\nstate->idev = __in6_dev_get(state->dev);\r\nif (!state->idev)\r\ncontinue;\r\nread_lock_bh(&state->idev->lock);\r\nstate->im = state->idev->mc_list;\r\n}\r\nif (!state->im)\r\nbreak;\r\nspin_lock_bh(&state->im->mca_lock);\r\npsf = state->im->mca_sources;\r\n}\r\nout:\r\nreturn psf;\r\n}\r\nstatic struct ip6_sf_list *igmp6_mcf_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct ip6_sf_list *psf = igmp6_mcf_get_first(seq);\r\nif (psf)\r\nwhile (pos && (psf = igmp6_mcf_get_next(seq, psf)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : psf;\r\n}\r\nstatic void *igmp6_mcf_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn *pos ? igmp6_mcf_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *igmp6_mcf_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ip6_sf_list *psf;\r\nif (v == SEQ_START_TOKEN)\r\npsf = igmp6_mcf_get_first(seq);\r\nelse\r\npsf = igmp6_mcf_get_next(seq, v);\r\n++*pos;\r\nreturn psf;\r\n}\r\nstatic void igmp6_mcf_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\r\nif (likely(state->im != NULL)) {\r\nspin_unlock_bh(&state->im->mca_lock);\r\nstate->im = NULL;\r\n}\r\nif (likely(state->idev != NULL)) {\r\nread_unlock_bh(&state->idev->lock);\r\nstate->idev = NULL;\r\n}\r\nstate->dev = NULL;\r\nrcu_read_unlock();\r\n}\r\nstatic int igmp6_mcf_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct ip6_sf_list *psf = (struct ip6_sf_list *)v;\r\nstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq,\r\n"%3s %6s "\r\n"%32s %32s %6s %6s\n", "Idx",\r\n"Device", "Multicast Address",\r\n"Source Address", "INC", "EXC");\r\n} else {\r\nseq_printf(seq,\r\n"%3d %6.6s %pi6 %pi6 %6lu %6lu\n",\r\nstate->dev->ifindex, state->dev->name,\r\n&state->im->mca_addr,\r\n&psf->sf_addr,\r\npsf->sf_count[MCAST_INCLUDE],\r\npsf->sf_count[MCAST_EXCLUDE]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int igmp6_mcf_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &igmp6_mcf_seq_ops,\r\nsizeof(struct igmp6_mcf_iter_state));\r\n}\r\nstatic int __net_init igmp6_proc_init(struct net *net)\r\n{\r\nint err;\r\nerr = -ENOMEM;\r\nif (!proc_net_fops_create(net, "igmp6", S_IRUGO, &igmp6_mc_seq_fops))\r\ngoto out;\r\nif (!proc_net_fops_create(net, "mcfilter6", S_IRUGO,\r\n&igmp6_mcf_seq_fops))\r\ngoto out_proc_net_igmp6;\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_proc_net_igmp6:\r\nproc_net_remove(net, "igmp6");\r\ngoto out;\r\n}\r\nstatic void __net_exit igmp6_proc_exit(struct net *net)\r\n{\r\nproc_net_remove(net, "mcfilter6");\r\nproc_net_remove(net, "igmp6");\r\n}\r\nstatic inline int igmp6_proc_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void igmp6_proc_exit(struct net *net)\r\n{\r\n}\r\nstatic int __net_init igmp6_net_init(struct net *net)\r\n{\r\nint err;\r\nerr = inet_ctl_sock_create(&net->ipv6.igmp_sk, PF_INET6,\r\nSOCK_RAW, IPPROTO_ICMPV6, net);\r\nif (err < 0) {\r\nprintk(KERN_ERR\r\n"Failed to initialize the IGMP6 control socket (err %d).\n",\r\nerr);\r\ngoto out;\r\n}\r\ninet6_sk(net->ipv6.igmp_sk)->hop_limit = 1;\r\nerr = igmp6_proc_init(net);\r\nif (err)\r\ngoto out_sock_create;\r\nout:\r\nreturn err;\r\nout_sock_create:\r\ninet_ctl_sock_destroy(net->ipv6.igmp_sk);\r\ngoto out;\r\n}\r\nstatic void __net_exit igmp6_net_exit(struct net *net)\r\n{\r\ninet_ctl_sock_destroy(net->ipv6.igmp_sk);\r\nigmp6_proc_exit(net);\r\n}\r\nint __init igmp6_init(void)\r\n{\r\nreturn register_pernet_subsys(&igmp6_net_ops);\r\n}\r\nvoid igmp6_cleanup(void)\r\n{\r\nunregister_pernet_subsys(&igmp6_net_ops);\r\n}
