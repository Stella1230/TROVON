static void mdio_set_bit(struct cphy *cphy, int reg, u32 bitval)\r\n{\r\nu32 val;\r\n(void) simple_mdio_read(cphy, reg, &val);\r\n(void) simple_mdio_write(cphy, reg, val | bitval);\r\n}\r\nstatic void mdio_clear_bit(struct cphy *cphy, int reg, u32 bitval)\r\n{\r\nu32 val;\r\n(void) simple_mdio_read(cphy, reg, &val);\r\n(void) simple_mdio_write(cphy, reg, val & ~bitval);\r\n}\r\nstatic int mv88e1xxx_reset(struct cphy *cphy, int wait)\r\n{\r\nu32 ctl;\r\nint time_out = 1000;\r\nmdio_set_bit(cphy, MII_BMCR, BMCR_RESET);\r\ndo {\r\n(void) simple_mdio_read(cphy, MII_BMCR, &ctl);\r\nctl &= BMCR_RESET;\r\nif (ctl)\r\nudelay(1);\r\n} while (ctl && --time_out);\r\nreturn ctl ? -1 : 0;\r\n}\r\nstatic int mv88e1xxx_interrupt_enable(struct cphy *cphy)\r\n{\r\n(void) simple_mdio_write(cphy, MV88E1XXX_INTERRUPT_ENABLE_REGISTER,\r\nINTR_ENABLE_MASK);\r\nif (t1_is_asic(cphy->adapter)) {\r\nu32 elmer;\r\nt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\r\nelmer |= ELMER0_GP_BIT1;\r\nif (is_T2(cphy->adapter))\r\nelmer |= ELMER0_GP_BIT2 | ELMER0_GP_BIT3 | ELMER0_GP_BIT4;\r\nt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_interrupt_disable(struct cphy *cphy)\r\n{\r\n(void) simple_mdio_write(cphy, MV88E1XXX_INTERRUPT_ENABLE_REGISTER, 0);\r\nif (t1_is_asic(cphy->adapter)) {\r\nu32 elmer;\r\nt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\r\nelmer &= ~ELMER0_GP_BIT1;\r\nif (is_T2(cphy->adapter))\r\nelmer &= ~(ELMER0_GP_BIT2|ELMER0_GP_BIT3|ELMER0_GP_BIT4);\r\nt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_interrupt_clear(struct cphy *cphy)\r\n{\r\nu32 elmer;\r\n(void) simple_mdio_read(cphy,\r\nMV88E1XXX_INTERRUPT_STATUS_REGISTER, &elmer);\r\nif (t1_is_asic(cphy->adapter)) {\r\nt1_tpi_read(cphy->adapter, A_ELMER0_INT_CAUSE, &elmer);\r\nelmer |= ELMER0_GP_BIT1;\r\nif (is_T2(cphy->adapter))\r\nelmer |= ELMER0_GP_BIT2|ELMER0_GP_BIT3|ELMER0_GP_BIT4;\r\nt1_tpi_write(cphy->adapter, A_ELMER0_INT_CAUSE, elmer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_set_speed_duplex(struct cphy *phy, int speed, int duplex)\r\n{\r\nu32 ctl;\r\n(void) simple_mdio_read(phy, MII_BMCR, &ctl);\r\nif (speed >= 0) {\r\nctl &= ~(BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);\r\nif (speed == SPEED_100)\r\nctl |= BMCR_SPEED100;\r\nelse if (speed == SPEED_1000)\r\nctl |= BMCR_SPEED1000;\r\n}\r\nif (duplex >= 0) {\r\nctl &= ~(BMCR_FULLDPLX | BMCR_ANENABLE);\r\nif (duplex == DUPLEX_FULL)\r\nctl |= BMCR_FULLDPLX;\r\n}\r\nif (ctl & BMCR_SPEED1000)\r\nctl |= BMCR_ANENABLE;\r\n(void) simple_mdio_write(phy, MII_BMCR, ctl);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_crossover_set(struct cphy *cphy, int crossover)\r\n{\r\nu32 data32;\r\n(void) simple_mdio_read(cphy,\r\nMV88E1XXX_SPECIFIC_CNTRL_REGISTER, &data32);\r\ndata32 &= ~V_PSCR_MDI_XOVER_MODE(M_PSCR_MDI_XOVER_MODE);\r\ndata32 |= V_PSCR_MDI_XOVER_MODE(crossover);\r\n(void) simple_mdio_write(cphy,\r\nMV88E1XXX_SPECIFIC_CNTRL_REGISTER, data32);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_autoneg_enable(struct cphy *cphy)\r\n{\r\nu32 ctl;\r\n(void) mv88e1xxx_crossover_set(cphy, CROSSOVER_AUTO);\r\n(void) simple_mdio_read(cphy, MII_BMCR, &ctl);\r\nctl |= BMCR_ANENABLE | BMCR_ANRESTART;\r\n(void) simple_mdio_write(cphy, MII_BMCR, ctl);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_autoneg_disable(struct cphy *cphy)\r\n{\r\nu32 ctl;\r\n(void) mv88e1xxx_crossover_set(cphy, CROSSOVER_MDI);\r\n(void) simple_mdio_read(cphy, MII_BMCR, &ctl);\r\nctl &= ~BMCR_ANENABLE;\r\n(void) simple_mdio_write(cphy, MII_BMCR, ctl | BMCR_ANRESTART);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_autoneg_restart(struct cphy *cphy)\r\n{\r\nmdio_set_bit(cphy, MII_BMCR, BMCR_ANRESTART);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_advertise(struct cphy *phy, unsigned int advertise_map)\r\n{\r\nu32 val = 0;\r\nif (advertise_map &\r\n(ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full)) {\r\n(void) simple_mdio_read(phy, MII_GBCR, &val);\r\nval &= ~(GBCR_ADV_1000HALF | GBCR_ADV_1000FULL);\r\nif (advertise_map & ADVERTISED_1000baseT_Half)\r\nval |= GBCR_ADV_1000HALF;\r\nif (advertise_map & ADVERTISED_1000baseT_Full)\r\nval |= GBCR_ADV_1000FULL;\r\n}\r\n(void) simple_mdio_write(phy, MII_GBCR, val);\r\nval = 1;\r\nif (advertise_map & ADVERTISED_10baseT_Half)\r\nval |= ADVERTISE_10HALF;\r\nif (advertise_map & ADVERTISED_10baseT_Full)\r\nval |= ADVERTISE_10FULL;\r\nif (advertise_map & ADVERTISED_100baseT_Half)\r\nval |= ADVERTISE_100HALF;\r\nif (advertise_map & ADVERTISED_100baseT_Full)\r\nval |= ADVERTISE_100FULL;\r\nif (advertise_map & ADVERTISED_PAUSE)\r\nval |= ADVERTISE_PAUSE;\r\nif (advertise_map & ADVERTISED_ASYM_PAUSE)\r\nval |= ADVERTISE_PAUSE_ASYM;\r\n(void) simple_mdio_write(phy, MII_ADVERTISE, val);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_set_loopback(struct cphy *cphy, int on)\r\n{\r\nif (on)\r\nmdio_set_bit(cphy, MII_BMCR, BMCR_LOOPBACK);\r\nelse\r\nmdio_clear_bit(cphy, MII_BMCR, BMCR_LOOPBACK);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_get_link_status(struct cphy *cphy, int *link_ok,\r\nint *speed, int *duplex, int *fc)\r\n{\r\nu32 status;\r\nint sp = -1, dplx = -1, pause = 0;\r\n(void) simple_mdio_read(cphy,\r\nMV88E1XXX_SPECIFIC_STATUS_REGISTER, &status);\r\nif ((status & V_PSSR_STATUS_RESOLVED) != 0) {\r\nif (status & V_PSSR_RX_PAUSE)\r\npause |= PAUSE_RX;\r\nif (status & V_PSSR_TX_PAUSE)\r\npause |= PAUSE_TX;\r\ndplx = (status & V_PSSR_DUPLEX) ? DUPLEX_FULL : DUPLEX_HALF;\r\nsp = G_PSSR_SPEED(status);\r\nif (sp == 0)\r\nsp = SPEED_10;\r\nelse if (sp == 1)\r\nsp = SPEED_100;\r\nelse\r\nsp = SPEED_1000;\r\n}\r\nif (link_ok)\r\n*link_ok = (status & V_PSSR_LINK) != 0;\r\nif (speed)\r\n*speed = sp;\r\nif (duplex)\r\n*duplex = dplx;\r\nif (fc)\r\n*fc = pause;\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_downshift_set(struct cphy *cphy, int downshift_enable)\r\n{\r\nu32 val;\r\n(void) simple_mdio_read(cphy,\r\nMV88E1XXX_EXT_PHY_SPECIFIC_CNTRL_REGISTER, &val);\r\nval &= ~(V_DOWNSHIFT_ENABLE | V_DOWNSHIFT_CNT(M_DOWNSHIFT_CNT));\r\nif (downshift_enable)\r\nval |= V_DOWNSHIFT_ENABLE | V_DOWNSHIFT_CNT(2);\r\n(void) simple_mdio_write(cphy,\r\nMV88E1XXX_EXT_PHY_SPECIFIC_CNTRL_REGISTER, val);\r\nreturn 0;\r\n}\r\nstatic int mv88e1xxx_interrupt_handler(struct cphy *cphy)\r\n{\r\nint cphy_cause = 0;\r\nu32 status;\r\nwhile (1) {\r\nu32 cause;\r\n(void) simple_mdio_read(cphy,\r\nMV88E1XXX_INTERRUPT_STATUS_REGISTER,\r\n&cause);\r\ncause &= INTR_ENABLE_MASK;\r\nif (!cause)\r\nbreak;\r\nif (cause & MV88E1XXX_INTR_LINK_CHNG) {\r\n(void) simple_mdio_read(cphy,\r\nMV88E1XXX_SPECIFIC_STATUS_REGISTER, &status);\r\nif (status & MV88E1XXX_INTR_LINK_CHNG)\r\ncphy->state |= PHY_LINK_UP;\r\nelse {\r\ncphy->state &= ~PHY_LINK_UP;\r\nif (cphy->state & PHY_AUTONEG_EN)\r\ncphy->state &= ~PHY_AUTONEG_RDY;\r\ncphy_cause |= cphy_cause_link_change;\r\n}\r\n}\r\nif (cause & MV88E1XXX_INTR_AUTONEG_DONE)\r\ncphy->state |= PHY_AUTONEG_RDY;\r\nif ((cphy->state & (PHY_LINK_UP | PHY_AUTONEG_RDY)) ==\r\n(PHY_LINK_UP | PHY_AUTONEG_RDY))\r\ncphy_cause |= cphy_cause_link_change;\r\n}\r\nreturn cphy_cause;\r\n}\r\nstatic void mv88e1xxx_destroy(struct cphy *cphy)\r\n{\r\nkfree(cphy);\r\n}\r\nstatic struct cphy *mv88e1xxx_phy_create(struct net_device *dev, int phy_addr,\r\nconst struct mdio_ops *mdio_ops)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct cphy *cphy = kzalloc(sizeof(*cphy), GFP_KERNEL);\r\nif (!cphy)\r\nreturn NULL;\r\ncphy_init(cphy, dev, phy_addr, &mv88e1xxx_ops, mdio_ops);\r\nif ((board_info(adapter)->caps & SUPPORTED_TP) &&\r\nboard_info(adapter)->chip_phy == CHBT_PHY_88E1111) {\r\n(void) simple_mdio_write(cphy,\r\nMV88E1XXX_EXTENDED_ADDR_REGISTER, 0xB);\r\n(void) simple_mdio_write(cphy,\r\nMV88E1XXX_EXTENDED_REGISTER, 0x8004);\r\n}\r\n(void) mv88e1xxx_downshift_set(cphy, 1);\r\nif (is_T2(adapter)) {\r\n(void) simple_mdio_write(cphy,\r\nMV88E1XXX_LED_CONTROL_REGISTER, 0x1);\r\n}\r\nreturn cphy;\r\n}\r\nstatic int mv88e1xxx_phy_reset(adapter_t* adapter)\r\n{\r\nreturn 0;\r\n}
