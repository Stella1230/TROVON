static int memory_get_max_bandwidth(struct thermal_cooling_device *cdev,\r\nunsigned long *max_state)\r\n{\r\nstruct acpi_device *device = cdev->devdata;\r\nacpi_handle handle = device->handle;\r\nunsigned long long value;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status = AE_OK;\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = MEMORY_ARG_MAX_BANDWIDTH;\r\nstatus = acpi_evaluate_integer(handle, MEMORY_GET_BANDWIDTH,\r\n&arg_list, &value);\r\nif (ACPI_FAILURE(status))\r\nreturn -EFAULT;\r\nif (!value)\r\nreturn -EINVAL;\r\n*max_state = value - 1;\r\nreturn 0;\r\n}\r\nstatic int memory_get_cur_bandwidth(struct thermal_cooling_device *cdev,\r\nunsigned long *value)\r\n{\r\nstruct acpi_device *device = cdev->devdata;\r\nacpi_handle handle = device->handle;\r\nunsigned long long result;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status = AE_OK;\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = MEMORY_ARG_CUR_BANDWIDTH;\r\nstatus = acpi_evaluate_integer(handle, MEMORY_GET_BANDWIDTH,\r\n&arg_list, &result);\r\nif (ACPI_FAILURE(status))\r\nreturn -EFAULT;\r\n*value = result;\r\nreturn 0;\r\n}\r\nstatic int memory_set_cur_bandwidth(struct thermal_cooling_device *cdev,\r\nunsigned long state)\r\n{\r\nstruct acpi_device *device = cdev->devdata;\r\nacpi_handle handle = device->handle;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\nunsigned long long temp;\r\nunsigned long max_state;\r\nif (memory_get_max_bandwidth(cdev, &max_state))\r\nreturn -EFAULT;\r\nif (state > max_state)\r\nreturn -EINVAL;\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = state;\r\nstatus =\r\nacpi_evaluate_integer(handle, MEMORY_SET_BANDWIDTH, &arg_list,\r\n&temp);\r\npr_info("Bandwidth value was %ld: status is %d\n", state, status);\r\nif (ACPI_FAILURE(status))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int intel_menlow_memory_add(struct acpi_device *device)\r\n{\r\nint result = -ENODEV;\r\nacpi_status status = AE_OK;\r\nacpi_handle dummy;\r\nstruct thermal_cooling_device *cdev;\r\nif (!device)\r\nreturn -EINVAL;\r\nstatus = acpi_get_handle(device->handle, MEMORY_GET_BANDWIDTH, &dummy);\r\nif (ACPI_FAILURE(status))\r\ngoto end;\r\nstatus = acpi_get_handle(device->handle, MEMORY_SET_BANDWIDTH, &dummy);\r\nif (ACPI_FAILURE(status))\r\ngoto end;\r\ncdev = thermal_cooling_device_register("Memory controller", device,\r\n&memory_cooling_ops);\r\nif (IS_ERR(cdev)) {\r\nresult = PTR_ERR(cdev);\r\ngoto end;\r\n}\r\ndevice->driver_data = cdev;\r\nresult = sysfs_create_link(&device->dev.kobj,\r\n&cdev->device.kobj, "thermal_cooling");\r\nif (result)\r\ngoto unregister;\r\nresult = sysfs_create_link(&cdev->device.kobj,\r\n&device->dev.kobj, "device");\r\nif (result) {\r\nsysfs_remove_link(&device->dev.kobj, "thermal_cooling");\r\ngoto unregister;\r\n}\r\nend:\r\nreturn result;\r\nunregister:\r\nthermal_cooling_device_unregister(cdev);\r\nreturn result;\r\n}\r\nstatic int intel_menlow_memory_remove(struct acpi_device *device, int type)\r\n{\r\nstruct thermal_cooling_device *cdev = acpi_driver_data(device);\r\nif (!device || !cdev)\r\nreturn -EINVAL;\r\nsysfs_remove_link(&device->dev.kobj, "thermal_cooling");\r\nsysfs_remove_link(&cdev->device.kobj, "device");\r\nthermal_cooling_device_unregister(cdev);\r\nreturn 0;\r\n}\r\nstatic int sensor_get_auxtrip(acpi_handle handle, int index,\r\nunsigned long long *value)\r\n{\r\nacpi_status status;\r\nif ((index != 0 && index != 1) || !value)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(handle, index ? GET_AUX1 : GET_AUX0,\r\nNULL, value);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int sensor_set_auxtrip(acpi_handle handle, int index, int value)\r\n{\r\nacpi_status status;\r\nunion acpi_object arg = {\r\nACPI_TYPE_INTEGER\r\n};\r\nstruct acpi_object_list args = {\r\n1, &arg\r\n};\r\nunsigned long long temp;\r\nif (index != 0 && index != 1)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(handle, index ? GET_AUX0 : GET_AUX1,\r\nNULL, &temp);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nif ((index && value < temp) || (!index && value > temp))\r\nreturn -EINVAL;\r\narg.integer.value = value;\r\nstatus = acpi_evaluate_integer(handle, index ? SET_AUX1 : SET_AUX0,\r\n&args, &temp);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t aux0_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct intel_menlow_attribute *attr = to_intel_menlow_attr(dev_attr);\r\nunsigned long long value;\r\nint result;\r\nresult = sensor_get_auxtrip(attr->handle, 0, &value);\r\nreturn result ? result : sprintf(buf, "%lu", KELVIN_TO_CELSIUS(value));\r\n}\r\nstatic ssize_t aux1_show(struct device *dev,\r\nstruct device_attribute *dev_attr, char *buf)\r\n{\r\nstruct intel_menlow_attribute *attr = to_intel_menlow_attr(dev_attr);\r\nunsigned long long value;\r\nint result;\r\nresult = sensor_get_auxtrip(attr->handle, 1, &value);\r\nreturn result ? result : sprintf(buf, "%lu", KELVIN_TO_CELSIUS(value));\r\n}\r\nstatic ssize_t aux0_store(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct intel_menlow_attribute *attr = to_intel_menlow_attr(dev_attr);\r\nint value;\r\nint result;\r\nif (!sscanf(buf, "%d", &value))\r\nreturn -EINVAL;\r\nif (value < 0)\r\nreturn -EINVAL;\r\nresult = sensor_set_auxtrip(attr->handle, 0, CELSIUS_TO_KELVIN(value));\r\nreturn result ? result : count;\r\n}\r\nstatic ssize_t aux1_store(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct intel_menlow_attribute *attr = to_intel_menlow_attr(dev_attr);\r\nint value;\r\nint result;\r\nif (!sscanf(buf, "%d", &value))\r\nreturn -EINVAL;\r\nif (value < 0)\r\nreturn -EINVAL;\r\nresult = sensor_set_auxtrip(attr->handle, 1, CELSIUS_TO_KELVIN(value));\r\nreturn result ? result : count;\r\n}\r\nstatic ssize_t bios_enabled_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nacpi_status status;\r\nunsigned long long bios_enabled;\r\nstatus = acpi_evaluate_integer(NULL, BIOS_ENABLED, NULL, &bios_enabled);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%s\n", bios_enabled ? "enabled" : "disabled");\r\n}\r\nstatic int intel_menlow_add_one_attribute(char *name, int mode, void *show,\r\nvoid *store, struct device *dev,\r\nacpi_handle handle)\r\n{\r\nstruct intel_menlow_attribute *attr;\r\nint result;\r\nattr = kzalloc(sizeof(struct intel_menlow_attribute), GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nsysfs_attr_init(&attr->attr.attr);\r\nattr->attr.attr.name = name;\r\nattr->attr.attr.mode = mode;\r\nattr->attr.show = show;\r\nattr->attr.store = store;\r\nattr->device = dev;\r\nattr->handle = handle;\r\nresult = device_create_file(dev, &attr->attr);\r\nif (result) {\r\nkfree(attr);\r\nreturn result;\r\n}\r\nmutex_lock(&intel_menlow_attr_lock);\r\nlist_add_tail(&attr->node, &intel_menlow_attr_list);\r\nmutex_unlock(&intel_menlow_attr_lock);\r\nreturn 0;\r\n}\r\nstatic acpi_status intel_menlow_register_sensor(acpi_handle handle, u32 lvl,\r\nvoid *context, void **rv)\r\n{\r\nacpi_status status;\r\nacpi_handle dummy;\r\nstruct thermal_zone_device *thermal;\r\nint result;\r\nresult = acpi_bus_get_private_data(handle, (void **)&thermal);\r\nif (result)\r\nreturn 0;\r\nstatus = acpi_get_handle(handle, GET_AUX0, &dummy);\r\nif (ACPI_FAILURE(status))\r\nreturn (status == AE_NOT_FOUND) ? AE_OK : status;\r\nstatus = acpi_get_handle(handle, SET_AUX0, &dummy);\r\nif (ACPI_FAILURE(status))\r\nreturn (status == AE_NOT_FOUND) ? AE_OK : status;\r\nresult = intel_menlow_add_one_attribute("aux0", 0644,\r\naux0_show, aux0_store,\r\n&thermal->device, handle);\r\nif (result)\r\nreturn AE_ERROR;\r\nstatus = acpi_get_handle(handle, GET_AUX1, &dummy);\r\nif (ACPI_FAILURE(status))\r\ngoto aux1_not_found;\r\nstatus = acpi_get_handle(handle, SET_AUX1, &dummy);\r\nif (ACPI_FAILURE(status))\r\ngoto aux1_not_found;\r\nresult = intel_menlow_add_one_attribute("aux1", 0644,\r\naux1_show, aux1_store,\r\n&thermal->device, handle);\r\nif (result) {\r\nintel_menlow_unregister_sensor();\r\nreturn AE_ERROR;\r\n}\r\nresult = intel_menlow_add_one_attribute("bios_enabled", 0444,\r\nbios_enabled_show, NULL,\r\n&thermal->device, handle);\r\nif (result) {\r\nintel_menlow_unregister_sensor();\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\naux1_not_found:\r\nif (status == AE_NOT_FOUND)\r\nreturn AE_OK;\r\nintel_menlow_unregister_sensor();\r\nreturn status;\r\n}\r\nstatic void intel_menlow_unregister_sensor(void)\r\n{\r\nstruct intel_menlow_attribute *pos, *next;\r\nmutex_lock(&intel_menlow_attr_lock);\r\nlist_for_each_entry_safe(pos, next, &intel_menlow_attr_list, node) {\r\nlist_del(&pos->node);\r\ndevice_remove_file(pos->device, &pos->attr);\r\nkfree(pos);\r\n}\r\nmutex_unlock(&intel_menlow_attr_lock);\r\nreturn;\r\n}\r\nstatic int __init intel_menlow_module_init(void)\r\n{\r\nint result = -ENODEV;\r\nacpi_status status;\r\nunsigned long long enable;\r\nif (acpi_disabled)\r\nreturn result;\r\nstatus = acpi_evaluate_integer(NULL, BIOS_ENABLED, NULL, &enable);\r\nif (ACPI_FAILURE(status) || !enable)\r\nreturn -ENODEV;\r\nresult = acpi_bus_register_driver(&intel_menlow_memory_driver);\r\nif (result)\r\nreturn result;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_THERMAL, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nintel_menlow_register_sensor, NULL, NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_bus_unregister_driver(&intel_menlow_memory_driver);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit intel_menlow_module_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&intel_menlow_memory_driver);\r\nintel_menlow_unregister_sensor();\r\n}
