int acpi_pci_register_driver(struct acpi_pci_driver *driver)\r\n{\r\nint n = 0;\r\nstruct acpi_pci_root *root;\r\nstruct acpi_pci_driver **pptr = &sub_driver;\r\nwhile (*pptr)\r\npptr = &(*pptr)->next;\r\n*pptr = driver;\r\nif (!driver->add)\r\nreturn 0;\r\nlist_for_each_entry(root, &acpi_pci_roots, node) {\r\ndriver->add(root->device->handle);\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nvoid acpi_pci_unregister_driver(struct acpi_pci_driver *driver)\r\n{\r\nstruct acpi_pci_root *root;\r\nstruct acpi_pci_driver **pptr = &sub_driver;\r\nwhile (*pptr) {\r\nif (*pptr == driver)\r\nbreak;\r\npptr = &(*pptr)->next;\r\n}\r\nBUG_ON(!*pptr);\r\n*pptr = (*pptr)->next;\r\nif (!driver->remove)\r\nreturn;\r\nlist_for_each_entry(root, &acpi_pci_roots, node)\r\ndriver->remove(root->device->handle);\r\n}\r\nacpi_handle acpi_get_pci_rootbridge_handle(unsigned int seg, unsigned int bus)\r\n{\r\nstruct acpi_pci_root *root;\r\nlist_for_each_entry(root, &acpi_pci_roots, node)\r\nif ((root->segment == (u16) seg) &&\r\n(root->secondary.start == (u16) bus))\r\nreturn root->device->handle;\r\nreturn NULL;\r\n}\r\nint acpi_is_root_bridge(acpi_handle handle)\r\n{\r\nint ret;\r\nstruct acpi_device *device;\r\nret = acpi_bus_get_device(handle, &device);\r\nif (ret)\r\nreturn 0;\r\nret = acpi_match_device_ids(device, root_device_ids);\r\nif (ret)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic acpi_status\r\nget_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)\r\n{\r\nstruct resource *res = data;\r\nstruct acpi_resource_address64 address;\r\nif (resource->type != ACPI_RESOURCE_TYPE_ADDRESS16 &&\r\nresource->type != ACPI_RESOURCE_TYPE_ADDRESS32 &&\r\nresource->type != ACPI_RESOURCE_TYPE_ADDRESS64)\r\nreturn AE_OK;\r\nacpi_resource_to_address64(resource, &address);\r\nif ((address.address_length > 0) &&\r\n(address.resource_type == ACPI_BUS_NUMBER_RANGE)) {\r\nres->start = address.minimum;\r\nres->end = address.minimum + address.address_length - 1;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status try_get_root_bridge_busnr(acpi_handle handle,\r\nstruct resource *res)\r\n{\r\nacpi_status status;\r\nres->start = -1;\r\nstatus =\r\nacpi_walk_resources(handle, METHOD_NAME__CRS,\r\nget_root_bridge_busnr_callback, res);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nif (res->start == -1)\r\nreturn AE_ERROR;\r\nreturn AE_OK;\r\n}\r\nstatic void acpi_pci_bridge_scan(struct acpi_device *device)\r\n{\r\nint status;\r\nstruct acpi_device *child = NULL;\r\nif (device->flags.bus_address)\r\nif (device->parent && device->parent->ops.bind) {\r\nstatus = device->parent->ops.bind(device);\r\nif (!status) {\r\nlist_for_each_entry(child, &device->children, node)\r\nacpi_pci_bridge_scan(child);\r\n}\r\n}\r\n}\r\nstatic acpi_status acpi_pci_run_osc(acpi_handle handle,\r\nconst u32 *capbuf, u32 *retval)\r\n{\r\nstruct acpi_osc_context context = {\r\n.uuid_str = pci_osc_uuid_str,\r\n.rev = 1,\r\n.cap.length = 12,\r\n.cap.pointer = (void *)capbuf,\r\n};\r\nacpi_status status;\r\nstatus = acpi_run_osc(handle, &context);\r\nif (ACPI_SUCCESS(status)) {\r\n*retval = *((u32 *)(context.ret.pointer + 8));\r\nkfree(context.ret.pointer);\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_pci_query_osc(struct acpi_pci_root *root,\r\nu32 support,\r\nu32 *control)\r\n{\r\nacpi_status status;\r\nu32 result, capbuf[3];\r\nsupport &= OSC_PCI_SUPPORT_MASKS;\r\nsupport |= root->osc_support_set;\r\ncapbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;\r\ncapbuf[OSC_SUPPORT_TYPE] = support;\r\nif (control) {\r\n*control &= OSC_PCI_CONTROL_MASKS;\r\ncapbuf[OSC_CONTROL_TYPE] = *control | root->osc_control_set;\r\n} else {\r\ncapbuf[OSC_CONTROL_TYPE] = OSC_PCI_CONTROL_MASKS;\r\n}\r\nstatus = acpi_pci_run_osc(root->device->handle, capbuf, &result);\r\nif (ACPI_SUCCESS(status)) {\r\nroot->osc_support_set = support;\r\nif (control)\r\n*control = result;\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_pci_osc_support(struct acpi_pci_root *root, u32 flags)\r\n{\r\nacpi_status status;\r\nacpi_handle tmp;\r\nstatus = acpi_get_handle(root->device->handle, "_OSC", &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nmutex_lock(&osc_lock);\r\nstatus = acpi_pci_query_osc(root, flags, NULL);\r\nmutex_unlock(&osc_lock);\r\nreturn status;\r\n}\r\nstruct acpi_pci_root *acpi_pci_find_root(acpi_handle handle)\r\n{\r\nstruct acpi_pci_root *root;\r\nlist_for_each_entry(root, &acpi_pci_roots, node) {\r\nif (root->device->handle == handle)\r\nreturn root;\r\n}\r\nreturn NULL;\r\n}\r\nstruct pci_dev *acpi_get_pci_dev(acpi_handle handle)\r\n{\r\nint dev, fn;\r\nunsigned long long adr;\r\nacpi_status status;\r\nacpi_handle phandle;\r\nstruct pci_bus *pbus;\r\nstruct pci_dev *pdev = NULL;\r\nstruct acpi_handle_node *node, *tmp;\r\nstruct acpi_pci_root *root;\r\nLIST_HEAD(device_list);\r\nphandle = handle;\r\nwhile (!acpi_is_root_bridge(phandle)) {\r\nnode = kzalloc(sizeof(struct acpi_handle_node), GFP_KERNEL);\r\nif (!node)\r\ngoto out;\r\nINIT_LIST_HEAD(&node->node);\r\nnode->handle = phandle;\r\nlist_add(&node->node, &device_list);\r\nstatus = acpi_get_parent(phandle, &phandle);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\n}\r\nroot = acpi_pci_find_root(phandle);\r\nif (!root)\r\ngoto out;\r\npbus = root->bus;\r\nlist_for_each_entry(node, &device_list, node) {\r\nacpi_handle hnd = node->handle;\r\nstatus = acpi_evaluate_integer(hnd, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\ndev = (adr >> 16) & 0xffff;\r\nfn = adr & 0xffff;\r\npdev = pci_get_slot(pbus, PCI_DEVFN(dev, fn));\r\nif (!pdev || hnd == handle)\r\nbreak;\r\npbus = pdev->subordinate;\r\npci_dev_put(pdev);\r\nif (!pbus) {\r\ndev_dbg(&pdev->dev, "Not a PCI-to-PCI bridge\n");\r\npdev = NULL;\r\nbreak;\r\n}\r\n}\r\nout:\r\nlist_for_each_entry_safe(node, tmp, &device_list, node)\r\nkfree(node);\r\nreturn pdev;\r\n}\r\nacpi_status acpi_pci_osc_control_set(acpi_handle handle, u32 *mask, u32 req)\r\n{\r\nstruct acpi_pci_root *root;\r\nacpi_status status;\r\nu32 ctrl, capbuf[3];\r\nacpi_handle tmp;\r\nif (!mask)\r\nreturn AE_BAD_PARAMETER;\r\nctrl = *mask & OSC_PCI_CONTROL_MASKS;\r\nif ((ctrl & req) != req)\r\nreturn AE_TYPE;\r\nroot = acpi_pci_find_root(handle);\r\nif (!root)\r\nreturn AE_NOT_EXIST;\r\nstatus = acpi_get_handle(handle, "_OSC", &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nmutex_lock(&osc_lock);\r\n*mask = ctrl | root->osc_control_set;\r\nif ((root->osc_control_set & ctrl) == ctrl)\r\ngoto out;\r\nwhile (*mask) {\r\nstatus = acpi_pci_query_osc(root, root->osc_support_set, mask);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nif (ctrl == *mask)\r\nbreak;\r\nctrl = *mask;\r\n}\r\nif ((ctrl & req) != req) {\r\nstatus = AE_SUPPORT;\r\ngoto out;\r\n}\r\ncapbuf[OSC_QUERY_TYPE] = 0;\r\ncapbuf[OSC_SUPPORT_TYPE] = root->osc_support_set;\r\ncapbuf[OSC_CONTROL_TYPE] = ctrl;\r\nstatus = acpi_pci_run_osc(handle, capbuf, mask);\r\nif (ACPI_SUCCESS(status))\r\nroot->osc_control_set = *mask;\r\nout:\r\nmutex_unlock(&osc_lock);\r\nreturn status;\r\n}\r\nstatic int __devinit acpi_pci_root_add(struct acpi_device *device)\r\n{\r\nunsigned long long segment, bus;\r\nacpi_status status;\r\nint result;\r\nstruct acpi_pci_root *root;\r\nacpi_handle handle;\r\nstruct acpi_device *child;\r\nu32 flags, base_flags;\r\nroot = kzalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);\r\nif (!root)\r\nreturn -ENOMEM;\r\nsegment = 0;\r\nstatus = acpi_evaluate_integer(device->handle, METHOD_NAME__SEG, NULL,\r\n&segment);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nprintk(KERN_ERR PREFIX "can't evaluate _SEG\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nroot->secondary.flags = IORESOURCE_BUS;\r\nstatus = try_get_root_bridge_busnr(device->handle, &root->secondary);\r\nif (ACPI_FAILURE(status)) {\r\nroot->secondary.end = 0xFF;\r\nprintk(KERN_WARNING FW_BUG PREFIX\r\n"no secondary bus range in _CRS\n");\r\nstatus = acpi_evaluate_integer(device->handle, METHOD_NAME__BBN,\r\nNULL, &bus);\r\nif (ACPI_SUCCESS(status))\r\nroot->secondary.start = bus;\r\nelse if (status == AE_NOT_FOUND)\r\nroot->secondary.start = 0;\r\nelse {\r\nprintk(KERN_ERR PREFIX "can't evaluate _BBN\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\n}\r\nINIT_LIST_HEAD(&root->node);\r\nroot->device = device;\r\nroot->segment = segment & 0xFFFF;\r\nstrcpy(acpi_device_name(device), ACPI_PCI_ROOT_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PCI_ROOT_CLASS);\r\ndevice->driver_data = root;\r\nflags = base_flags = OSC_PCI_SEGMENT_GROUPS_SUPPORT;\r\nacpi_pci_osc_support(root, flags);\r\nlist_add_tail(&root->node, &acpi_pci_roots);\r\nprintk(KERN_INFO PREFIX "%s [%s] (domain %04x %pR)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\nroot->segment, &root->secondary);\r\nroot->bus = pci_acpi_scan_root(root);\r\nif (!root->bus) {\r\nprintk(KERN_ERR PREFIX\r\n"Bus %04x:%02x not present in PCI namespace\n",\r\nroot->segment, (unsigned int)root->secondary.start);\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nresult = acpi_pci_bind_root(device);\r\nif (result)\r\ngoto end;\r\nstatus = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);\r\nif (ACPI_SUCCESS(status))\r\nresult = acpi_pci_irq_add_prt(device->handle, root->bus);\r\nlist_for_each_entry(child, &device->children, node)\r\nacpi_pci_bridge_scan(child);\r\nif (pci_ext_cfg_avail(root->bus->self))\r\nflags |= OSC_EXT_PCI_CONFIG_SUPPORT;\r\nif (pcie_aspm_support_enabled())\r\nflags |= OSC_ACTIVE_STATE_PWR_SUPPORT |\r\nOSC_CLOCK_PWR_CAPABILITY_SUPPORT;\r\nif (pci_msi_enabled())\r\nflags |= OSC_MSI_SUPPORT;\r\nif (flags != base_flags)\r\nacpi_pci_osc_support(root, flags);\r\nif (!pcie_ports_disabled\r\n&& (flags & ACPI_PCIE_REQ_SUPPORT) == ACPI_PCIE_REQ_SUPPORT) {\r\nflags = OSC_PCI_EXPRESS_CAP_STRUCTURE_CONTROL\r\n| OSC_PCI_EXPRESS_NATIVE_HP_CONTROL\r\n| OSC_PCI_EXPRESS_PME_CONTROL;\r\nif (pci_aer_available()) {\r\nif (aer_acpi_firmware_first())\r\ndev_dbg(root->bus->bridge,\r\n"PCIe errors handled by BIOS.\n");\r\nelse\r\nflags |= OSC_PCI_EXPRESS_AER_CONTROL;\r\n}\r\ndev_info(root->bus->bridge,\r\n"Requesting ACPI _OSC control (0x%02x)\n", flags);\r\nstatus = acpi_pci_osc_control_set(device->handle, &flags,\r\nOSC_PCI_EXPRESS_CAP_STRUCTURE_CONTROL);\r\nif (ACPI_SUCCESS(status)) {\r\ndev_info(root->bus->bridge,\r\n"ACPI _OSC control (0x%02x) granted\n", flags);\r\n} else {\r\ndev_info(root->bus->bridge,\r\n"ACPI _OSC request failed (%s), "\r\n"returned control mask: 0x%02x\n",\r\nacpi_format_exception(status), flags);\r\npr_info("ACPI _OSC control for PCIe not granted, "\r\n"disabling ASPM\n");\r\npcie_no_aspm();\r\n}\r\n} else {\r\ndev_info(root->bus->bridge,\r\n"Unable to request _OSC control "\r\n"(_OSC support mask: 0x%02x)\n", flags);\r\n}\r\npci_acpi_add_bus_pm_notifier(device, root->bus);\r\nif (device->wakeup.flags.run_wake)\r\ndevice_set_run_wake(root->bus->bridge, true);\r\nreturn 0;\r\nend:\r\nif (!list_empty(&root->node))\r\nlist_del(&root->node);\r\nkfree(root);\r\nreturn result;\r\n}\r\nstatic int acpi_pci_root_start(struct acpi_device *device)\r\n{\r\nstruct acpi_pci_root *root = acpi_driver_data(device);\r\npci_bus_add_devices(root->bus);\r\nreturn 0;\r\n}\r\nstatic int acpi_pci_root_remove(struct acpi_device *device, int type)\r\n{\r\nstruct acpi_pci_root *root = acpi_driver_data(device);\r\ndevice_set_run_wake(root->bus->bridge, false);\r\npci_acpi_remove_bus_pm_notifier(device);\r\nkfree(root);\r\nreturn 0;\r\n}\r\nstatic int __init acpi_pci_root_init(void)\r\n{\r\nacpi_hest_init();\r\nif (acpi_pci_disabled)\r\nreturn 0;\r\npci_acpi_crs_quirks();\r\nif (acpi_bus_register_driver(&acpi_pci_root_driver) < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}
