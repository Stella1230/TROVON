static struct drm_display_mode *pyr_cmd_get_config_mode(struct drm_device *dev)\r\n{\r\nstruct drm_display_mode *mode;\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode) {\r\ndev_err(dev->dev, "Out of memory\n");\r\nreturn NULL;\r\n}\r\ndev_dbg(dev->dev, "hdisplay is %d\n", mode->hdisplay);\r\ndev_dbg(dev->dev, "vdisplay is %d\n", mode->vdisplay);\r\ndev_dbg(dev->dev, "HSS is %d\n", mode->hsync_start);\r\ndev_dbg(dev->dev, "HSE is %d\n", mode->hsync_end);\r\ndev_dbg(dev->dev, "htotal is %d\n", mode->htotal);\r\ndev_dbg(dev->dev, "VSS is %d\n", mode->vsync_start);\r\ndev_dbg(dev->dev, "VSE is %d\n", mode->vsync_end);\r\ndev_dbg(dev->dev, "vtotal is %d\n", mode->vtotal);\r\ndev_dbg(dev->dev, "clock is %d\n", mode->clock);\r\nmode->hdisplay = 480;\r\nmode->vdisplay = 864;\r\nmode->hsync_start = 487;\r\nmode->hsync_end = 490;\r\nmode->htotal = 499;\r\nmode->vsync_start = 874;\r\nmode->vsync_end = 878;\r\nmode->vtotal = 886;\r\nmode->clock = 25777;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_set_crtcinfo(mode, 0);\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\nreturn mode;\r\n}\r\nstatic bool pyr_dsi_dbi_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_display_mode *fixed_mode = pyr_cmd_get_config_mode(dev);\r\nif (fixed_mode) {\r\nadjusted_mode->hdisplay = fixed_mode->hdisplay;\r\nadjusted_mode->hsync_start = fixed_mode->hsync_start;\r\nadjusted_mode->hsync_end = fixed_mode->hsync_end;\r\nadjusted_mode->htotal = fixed_mode->htotal;\r\nadjusted_mode->vdisplay = fixed_mode->vdisplay;\r\nadjusted_mode->vsync_start = fixed_mode->vsync_start;\r\nadjusted_mode->vsync_end = fixed_mode->vsync_end;\r\nadjusted_mode->vtotal = fixed_mode->vtotal;\r\nadjusted_mode->clock = fixed_mode->clock;\r\ndrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\r\nkfree(fixed_mode);\r\n}\r\nreturn true;\r\n}\r\nstatic void pyr_dsi_dbi_set_power(struct drm_encoder *encoder, bool on)\r\n{\r\nint ret = 0;\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 reg_offset = 0;\r\nint pipe = (dbi_output->channel_num == 0) ? 0 : 2;\r\ndev_dbg(dev->dev, "pipe %d : %s, panel on: %s\n", pipe,\r\non ? "On" : "Off",\r\ndbi_output->dbi_panel_on ? "True" : "False");\r\nif (pipe == 2) {\r\nif (on)\r\ndev_priv->dual_mipi = true;\r\nelse\r\ndev_priv->dual_mipi = false;\r\nreg_offset = MIPIC_REG_OFFSET;\r\n} else {\r\nif (!on)\r\ndev_priv->dual_mipi = false;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nif (on) {\r\nif (dbi_output->dbi_panel_on)\r\ngoto out_err;\r\nret = mdfld_dsi_dbi_update_power(dbi_output, DRM_MODE_DPMS_ON);\r\nif (ret) {\r\ndev_err(dev->dev, "power on error\n");\r\ngoto out_err;\r\n}\r\ndbi_output->dbi_panel_on = true;\r\nif (pipe == 2) {\r\ndev_priv->dbi_panel_on2 = true;\r\n} else {\r\ndev_priv->dbi_panel_on = true;\r\nmdfld_enable_te(dev, 0);\r\n}\r\n} else {\r\nif (!dbi_output->dbi_panel_on && !dbi_output->first_boot)\r\ngoto out_err;\r\ndbi_output->dbi_panel_on = false;\r\ndbi_output->first_boot = false;\r\nif (pipe == 2) {\r\ndev_priv->dbi_panel_on2 = false;\r\nmdfld_disable_te(dev, 2);\r\n} else {\r\ndev_priv->dbi_panel_on = false;\r\nmdfld_disable_te(dev, 0);\r\nif (dev_priv->dbi_panel_on2)\r\nmdfld_enable_te(dev, 2);\r\n}\r\nret = mdfld_dsi_dbi_update_power(dbi_output, DRM_MODE_DPMS_OFF);\r\nif (ret) {\r\ndev_err(dev->dev, "power on error\n");\r\ngoto out_err;\r\n}\r\n}\r\nout_err:\r\ngma_power_end(dev);\r\nif (ret)\r\ndev_err(dev->dev, "failed\n");\r\n}\r\nstatic void pyr_dsi_controller_dbi_init(struct mdfld_dsi_config *dsi_config,\r\nint pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nu32 reg_offset = pipe ? MIPIC_REG_OFFSET : 0;\r\nint lane_count = dsi_config->lane_count;\r\nu32 val = 0;\r\ndev_dbg(dev->dev, "Init DBI interface on pipe %d...\n", pipe);\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_CONTROL_REG + reg_offset), 0x00000018);\r\nREG_WRITE((MIPIA_DPHY_PARAM_REG + reg_offset), 0x150c600F);\r\nREG_WRITE((MIPIA_CLK_LANE_SWITCH_TIME_CNT_REG + reg_offset),\r\n0x000a0014);\r\nREG_WRITE((MIPIA_DBI_BW_CTRL_REG + reg_offset), 0x00000400);\r\nREG_WRITE((MIPIA_HS_LS_DBI_ENABLE_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_INTR_EN_REG + reg_offset), 0xffffffff);\r\nREG_WRITE((MIPIA_TURN_AROUND_TIMEOUT_REG + reg_offset), 0x0000001f);\r\nREG_WRITE((MIPIA_DEVICE_RESET_TIMER_REG + reg_offset), 0x0000ffff);\r\nREG_WRITE((MIPIA_INIT_COUNT_REG + reg_offset), 0x00000fa0);\r\nval |= lane_count;\r\nval |= (dsi_config->channel_num << DSI_DBI_VIRT_CHANNEL_OFFSET);\r\nval |= DSI_DBI_COLOR_FORMAT_OPTION2;\r\nREG_WRITE((MIPIA_DSI_FUNC_PRG_REG + reg_offset), val);\r\nREG_WRITE((MIPIA_HS_TX_TIMEOUT_REG + reg_offset), 0x3fffff);\r\nREG_WRITE((MIPIA_LP_RX_TIMEOUT_REG + reg_offset), 0xffff);\r\nREG_WRITE((MIPIA_HIGH_LOW_SWITCH_COUNT_REG + reg_offset), 0x46);\r\nREG_WRITE((MIPIA_EOT_DISABLE_REG + reg_offset), 0x00000002);\r\nREG_WRITE((MIPIA_LP_BYTECLK_REG + reg_offset), 0x00000004);\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000001);\r\n}\r\nstatic void pyr_dsi_dbi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nint ret = 0;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dsi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct mdfld_dsi_connector *dsi_connector = dsi_config->connector;\r\nint pipe = dsi_connector->pipe;\r\nu8 param = 0;\r\nu32 mipi_reg = MIPI;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 reg_offset = 0;\r\nu32 dspcntr_val = dev_priv->dspcntr;\r\nu32 pipeconf_val = dev_priv->pipeconf;\r\nu32 h_active_area = mode->hdisplay;\r\nu32 v_active_area = mode->vdisplay;\r\nu32 mipi_val = (PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX |\r\nTE_TRIGGER_GPIO_PIN);\r\ndev_dbg(dev->dev, "mipi_val =0x%x\n", mipi_val);\r\ndev_dbg(dev->dev, "type %s\n", (pipe == 2) ? "MIPI2" : "MIPI");\r\ndev_dbg(dev->dev, "h %d v %d\n", mode->hdisplay, mode->vdisplay);\r\nif (pipe == 2) {\r\nmipi_reg = MIPI_C;\r\ndspcntr_reg = DSPCCNTR;\r\npipeconf_reg = PIPECCONF;\r\nreg_offset = MIPIC_REG_OFFSET;\r\ndspcntr_val = dev_priv->dspcntr2;\r\npipeconf_val = dev_priv->pipeconf2;\r\n} else {\r\nmipi_val |= 0x2;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nREG_WRITE(mipi_reg, mipi_val);\r\nREG_READ(mipi_reg);\r\npyr_dsi_controller_dbi_init(dsi_config, pipe);\r\nmsleep(20);\r\nREG_WRITE(dspcntr_reg, dspcntr_val);\r\nREG_READ(dspcntr_reg);\r\nmsleep(20);\r\nret = mdfld_dsi_dbi_send_dcs(dsi_output, exit_sleep_mode, NULL,\r\n0, CMD_DATA_SRC_SYSTEM_MEM);\r\nif (ret) {\r\ndev_err(dev->dev, "sent exit_sleep_mode faild\n");\r\ngoto out_err;\r\n}\r\nret = mdfld_dsi_dbi_send_dcs(dsi_output, set_tear_on,\r\n&param, 1, CMD_DATA_SRC_SYSTEM_MEM);\r\nif (ret) {\r\ndev_err(dev->dev, "%s - sent set_tear_on faild\n", __func__);\r\ngoto out_err;\r\n}\r\nmdfld_dsi_brightness_init(dsi_config, pipe);\r\nmdfld_dsi_gen_fifo_ready(dev, (MIPIA_GEN_FIFO_STAT_REG + reg_offset),\r\nHS_CTRL_FIFO_EMPTY | HS_DATA_FIFO_EMPTY);\r\nREG_WRITE(pipeconf_reg, pipeconf_val | PIPEACONF_DSR);\r\nREG_READ(pipeconf_reg);\r\nif (pipe == 2)\r\ndev_priv->pipeconf2 |= PIPEACONF_DSR;\r\nelse\r\ndev_priv->pipeconf |= PIPEACONF_DSR;\r\ndev_dbg(dev->dev, "pipeconf %x\n", REG_READ(pipeconf_reg));\r\nret = mdfld_dsi_dbi_update_area(dsi_output, 0, 0,\r\nh_active_area - 1, v_active_area - 1);\r\nif (ret) {\r\ndev_err(dev->dev, "update area failed\n");\r\ngoto out_err;\r\n}\r\nout_err:\r\ngma_power_end(dev);\r\nif (ret)\r\ndev_err(dev->dev, "mode set failed\n");\r\nelse\r\ndev_dbg(dev->dev, "mode set done successfully\n");\r\n}\r\nstatic void pyr_dsi_dbi_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\ndbi_output->mode_flags |= MODE_SETTING_IN_ENCODER;\r\ndbi_output->mode_flags &= ~MODE_SETTING_ENCODER_DONE;\r\npyr_dsi_dbi_set_power(encoder, false);\r\n}\r\nstatic void pyr_dsi_dbi_commit(struct drm_encoder *encoder)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_drm_dpu_rect rect;\r\npyr_dsi_dbi_set_power(encoder, true);\r\ndbi_output->mode_flags &= ~MODE_SETTING_IN_ENCODER;\r\nrect.x = rect.y = 0;\r\nrect.width = 864;\r\nrect.height = 480;\r\nif (dbi_output->channel_num == 1) {\r\ndev_priv->dsr_fb_update |= MDFLD_DSR_2D_3D_2;\r\nmdfld_dbi_dpu_report_damage(dev, MDFLD_PLANEC, &rect);\r\n} else {\r\ndev_priv->dsr_fb_update |= MDFLD_DSR_2D_3D_0;\r\nmdfld_dbi_dpu_report_damage(dev, MDFLD_PLANEA, &rect);\r\n}\r\ndbi_output->mode_flags |= MODE_SETTING_ENCODER_DONE;\r\n}\r\nstatic void pyr_dsi_dbi_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct drm_device *dev = dbi_output->dev;\r\ndev_dbg(dev->dev, "%s\n", (mode == DRM_MODE_DPMS_ON ? "on" : "off"));\r\nif (mode == DRM_MODE_DPMS_ON)\r\npyr_dsi_dbi_set_power(encoder, true);\r\nelse\r\npyr_dsi_dbi_set_power(encoder, false);\r\n}\r\nstatic void pyr_dsi_dbi_update_fb(struct mdfld_dsi_dbi_output *dbi_output,\r\nint pipe)\r\n{\r\nstruct mdfld_dsi_pkg_sender *sender =\r\nmdfld_dsi_encoder_get_pkg_sender(&dbi_output->base);\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_crtc *crtc = dbi_output->base.base.crtc;\r\nstruct psb_intel_crtc *psb_crtc = (crtc) ?\r\nto_psb_intel_crtc(crtc) : NULL;\r\nu32 dpll_reg = MRST_DPLL_A;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dsplinoff_reg = DSPALINOFF;\r\nu32 dspsurf_reg = DSPASURF;\r\nu32 hs_gen_ctrl_reg = HS_GEN_CTRL_REG;\r\nu32 gen_fifo_stat_reg = GEN_FIFO_STAT_REG;\r\nu32 reg_offset = 0;\r\nu32 intr_status;\r\nu32 fifo_stat_reg_val;\r\nu32 dpll_reg_val;\r\nu32 dspcntr_reg_val;\r\nu32 pipeconf_reg_val;\r\nif ((dbi_output->mode_flags & MODE_SETTING_ON_GOING) ||\r\n(psb_crtc && psb_crtc->mode_flags & MODE_SETTING_ON_GOING) ||\r\n!(dbi_output->mode_flags & MODE_SETTING_ENCODER_DONE))\r\nreturn;\r\nintr_status = REG_READ(INTR_STAT_REG);\r\nif ((intr_status & 0x26FFFFFF) != 0) {\r\nintr_status &= 0x26F3FFFF;\r\nREG_WRITE(INTR_STAT_REG, intr_status);\r\n}\r\nif (pipe == 2) {\r\ndspcntr_reg = DSPCCNTR;\r\npipeconf_reg = PIPECCONF;\r\ndsplinoff_reg = DSPCLINOFF;\r\ndspsurf_reg = DSPCSURF;\r\nhs_gen_ctrl_reg = HS_GEN_CTRL_REG + MIPIC_REG_OFFSET;\r\ngen_fifo_stat_reg = GEN_FIFO_STAT_REG + MIPIC_REG_OFFSET,\r\nreg_offset = MIPIC_REG_OFFSET;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nfifo_stat_reg_val = REG_READ(MIPIA_GEN_FIFO_STAT_REG + reg_offset);\r\ndpll_reg_val = REG_READ(dpll_reg);\r\ndspcntr_reg_val = REG_READ(dspcntr_reg);\r\npipeconf_reg_val = REG_READ(pipeconf_reg);\r\nif (!(fifo_stat_reg_val & (1 << 27)) ||\r\n(dpll_reg_val & DPLL_VCO_ENABLE) ||\r\n!(dspcntr_reg_val & DISPLAY_PLANE_ENABLE) ||\r\n!(pipeconf_reg_val & DISPLAY_PLANE_ENABLE)) {\r\ngoto update_fb_out0;\r\n}\r\nREG_WRITE(dsplinoff_reg, REG_READ(dsplinoff_reg));\r\nREG_WRITE(dspsurf_reg, REG_READ(dspsurf_reg));\r\nREG_READ(dspsurf_reg);\r\nmdfld_dsi_send_dcs(sender,\r\nwrite_mem_start,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_PIPE,\r\nMDFLD_DSI_SEND_PACKAGE);\r\nmdfld_dsi_gen_fifo_ready(dev, gen_fifo_stat_reg,\r\nHS_CTRL_FIFO_EMPTY | HS_DATA_FIFO_EMPTY);\r\nREG_WRITE(hs_gen_ctrl_reg, (1 << WORD_COUNTS_POS) | GEN_READ_0);\r\ndbi_output->dsr_fb_update_done = true;\r\nupdate_fb_out0:\r\ngma_power_end(dev);\r\n}\r\nvoid pyr_dsi_adapter_init(struct mdfld_dsi_config *dsi_config, int pipe)\r\n{\r\nif (!dsi_config || (pipe != 0 && pipe != 2)) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npyr_dsi_controller_dbi_init(dsi_config, pipe);\r\n}\r\nstatic int pyr_cmd_get_panel_info(struct drm_device *dev, int pipe,\r\nstruct panel_info *pi)\r\n{\r\nif (!dev || !pi)\r\nreturn -EINVAL;\r\npi->width_mm = PYR_PANEL_WIDTH;\r\npi->height_mm = PYR_PANEL_HEIGHT;\r\nreturn 0;\r\n}\r\nvoid pyr_cmd_init(struct drm_device *dev, struct panel_funcs *p_funcs)\r\n{\r\np_funcs->encoder_funcs = &mdfld_dsi_dbi_encoder_funcs;\r\np_funcs->encoder_helper_funcs = &pyr_dsi_dbi_helper_funcs;\r\np_funcs->get_config_mode = &pyr_cmd_get_config_mode;\r\np_funcs->update_fb = pyr_dsi_dbi_update_fb;\r\np_funcs->get_panel_info = pyr_cmd_get_panel_info;\r\n}
