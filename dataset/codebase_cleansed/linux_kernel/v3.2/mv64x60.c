u32 mv64x60_cfg_read(u8 *bridge_base, u8 hose, u8 bus, u8 devfn, u8 offset)\r\n{\r\nout_le32((u32 *)(bridge_base + mv64x60_pci_cfgio[hose].addr),\r\n(1 << 31) | (bus << 16) | (devfn << 8) | offset);\r\nreturn in_le32((u32 *)(bridge_base + mv64x60_pci_cfgio[hose].data));\r\n}\r\nvoid mv64x60_cfg_write(u8 *bridge_base, u8 hose, u8 bus, u8 devfn, u8 offset,\r\nu32 val)\r\n{\r\nout_le32((u32 *)(bridge_base + mv64x60_pci_cfgio[hose].addr),\r\n(1 << 31) | (bus << 16) | (devfn << 8) | offset);\r\nout_le32((u32 *)(bridge_base + mv64x60_pci_cfgio[hose].data), val);\r\n}\r\nvoid mv64x60_config_ctlr_windows(u8 *bridge_base, u8 *bridge_pbase,\r\nu8 is_coherent)\r\n{\r\nu32 i, base, size, enables, prot = 0, snoop_bits = 0;\r\nout_le32((u32 *)(bridge_base + MV64x60_ENET2MEM_BAR_ENABLE), 0x3f);\r\nout_le32((u32 *)(bridge_base + MV64x60_MPSC2MEM_BAR_ENABLE), 0xf);\r\nout_le32((u32 *)(bridge_base + MV64x60_ENET2MEM_BAR_ENABLE), 0xff);\r\nif (is_coherent)\r\nsnoop_bits = 0x2 << 12;\r\nenables = in_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE)) & 0xf;\r\nfor (i=0; i<MV64x60_CPU2MEM_WINDOWS; i++) {\r\nif (enables & (1 << i))\r\ncontinue;\r\nbase = in_le32((u32 *)(bridge_base + mv64x60_cpu2mem[i].lo))\r\n<< 16;\r\nbase |= snoop_bits | (mv64x60_dram_selects[i] << 8);\r\nsize = in_le32((u32 *)(bridge_base + mv64x60_cpu2mem[i].size))\r\n<< 16;\r\nprot |= (0x3 << (i << 1));\r\nout_le32((u32 *)(bridge_base + mv64x60_enet2mem[i].lo), base);\r\nout_le32((u32 *)(bridge_base + mv64x60_enet2mem[i].size), size);\r\nout_le32((u32 *)(bridge_base + mv64x60_mpsc2mem[i].lo), base);\r\nout_le32((u32 *)(bridge_base + mv64x60_mpsc2mem[i].size), size);\r\nout_le32((u32 *)(bridge_base + mv64x60_idma2mem[i].lo), base);\r\nout_le32((u32 *)(bridge_base + mv64x60_idma2mem[i].size), size);\r\n}\r\nout_le32((u32 *)(bridge_base + MV64x60_ENET2MEM_ACC_PROT_0), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_ENET2MEM_ACC_PROT_1), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_ENET2MEM_ACC_PROT_2), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_MPSC2MEM_ACC_PROT_0), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_MPSC2MEM_ACC_PROT_1), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_IDMA2MEM_ACC_PROT_0), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_IDMA2MEM_ACC_PROT_1), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_IDMA2MEM_ACC_PROT_2), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_IDMA2MEM_ACC_PROT_3), prot);\r\nout_le32((u32 *)(bridge_base + MV64x60_MPSC2REGS_BASE),\r\n(u32)bridge_pbase);\r\nout_le32((u32 *)(bridge_base + MV64x60_ENET2MEM_BAR_ENABLE), enables);\r\nout_le32((u32 *)(bridge_base + MV64x60_MPSC2MEM_BAR_ENABLE), enables);\r\nout_le32((u32 *)(bridge_base + MV64x60_IDMA2MEM_BAR_ENABLE), enables);\r\n}\r\nvoid mv64x60_config_pci_windows(u8 *bridge_base, u8 *bridge_pbase, u8 hose,\r\nu8 bus, u32 mem_size, u32 acc_bits)\r\n{\r\nu32 i, offset, bar_enable, enables;\r\nenables = ~(1 << 9);\r\nbar_enable = hose ? MV64x60_PCI1_BAR_ENABLE : MV64x60_PCI0_BAR_ENABLE;\r\nout_le32((u32 *)(bridge_base + bar_enable), enables);\r\nfor (i=0; i<MV64x60_PCI_ACC_CNTL_WINDOWS; i++)\r\nout_le32((u32 *)(bridge_base + mv64x60_pci_acc[hose][i].lo), 0);\r\nif (mem_size == 0)\r\nreturn;\r\noffset = hose ?\r\nMV64x60_PCI1_PCI_DECODE_CNTL : MV64x60_PCI0_PCI_DECODE_CNTL;\r\ni = in_le32((u32 *)(bridge_base + offset));\r\nout_le32((u32 *)(bridge_base + offset), i & ~0x1);\r\nmem_size = (mem_size - 1) & 0xfffff000;\r\nmv64x60_cfg_write(bridge_base, hose, bus,\r\nPCI_DEVFN(0, mv64x60_pci2mem[hose].fcn),\r\nmv64x60_pci2mem[hose].hi, 0);\r\nmv64x60_cfg_write(bridge_base, hose, bus,\r\nPCI_DEVFN(0, mv64x60_pci2mem[hose].fcn),\r\nmv64x60_pci2mem[hose].lo, 0);\r\nout_le32((u32 *)(bridge_base + mv64x60_pci2mem[hose].size),mem_size);\r\nacc_bits |= MV64x60_PCI_ACC_CNTL_ENABLE;\r\nout_le32((u32 *)(bridge_base + mv64x60_pci_acc[hose][0].hi), 0);\r\nout_le32((u32 *)(bridge_base + mv64x60_pci_acc[hose][0].lo), acc_bits);\r\nout_le32((u32 *)(bridge_base + mv64x60_pci_acc[hose][0].size),mem_size);\r\ni = (u32)bridge_base;\r\ni &= 0xffff0000;\r\ni |= (0x2 << 1);\r\nmv64x60_cfg_write(bridge_base, hose, bus, PCI_DEVFN(0,0),\r\nmv64x60_pci2reg[hose].hi, 0);\r\nmv64x60_cfg_write(bridge_base, hose, bus, PCI_DEVFN(0,0),\r\nmv64x60_pci2reg[hose].lo, i);\r\nenables &= ~0x1;\r\nout_le32((u32 *)(bridge_base + bar_enable), enables);\r\n}\r\nvoid mv64x60_config_cpu2pci_window(u8 *bridge_base, u8 hose, u32 pci_base_hi,\r\nu32 pci_base_lo, u32 cpu_base, u32 size,\r\nstruct mv64x60_cpu2pci_win *offset_tbl)\r\n{\r\ncpu_base >>= 16;\r\ncpu_base |= MV64x60_CPU2PCI_SWAP_NONE;\r\nout_le32((u32 *)(bridge_base + offset_tbl[hose].lo), cpu_base);\r\nif (offset_tbl[hose].remap_hi != 0)\r\nout_le32((u32 *)(bridge_base + offset_tbl[hose].remap_hi),\r\npci_base_hi);\r\nout_le32((u32 *)(bridge_base + offset_tbl[hose].remap_lo),\r\npci_base_lo >> 16);\r\nsize = (size - 1) >> 16;\r\nout_le32((u32 *)(bridge_base + offset_tbl[hose].size), size);\r\n}\r\nu32 mv64x60_get_mem_size(u8 *bridge_base)\r\n{\r\nu32 enables, i, v;\r\nu32 mem = 0;\r\nenables = in_le32((u32 *)(bridge_base + MV64x60_CPU_BAR_ENABLE)) & 0xf;\r\nfor (i=0; i<MV64x60_CPU2MEM_WINDOWS; i++)\r\nif (!(enables & (1<<i))) {\r\nv = in_le32((u32*)(bridge_base\r\n+ mv64x60_cpu2mem[i].size));\r\nv = ((v & 0xffff) + 1) << 16;\r\nmem += v;\r\n}\r\nreturn mem;\r\n}\r\nu8 *mv64x60_get_bridge_pbase(void)\r\n{\r\nu32 v[2];\r\nvoid *devp;\r\ndevp = find_node_by_compatible(NULL, "marvell,mv64360");\r\nif (devp == NULL)\r\ngoto err_out;\r\nif (getprop(devp, "reg", v, sizeof(v)) != sizeof(v))\r\ngoto err_out;\r\nreturn (u8 *)v[0];\r\nerr_out:\r\nreturn 0;\r\n}\r\nu8 *mv64x60_get_bridge_base(void)\r\n{\r\nu32 v;\r\nvoid *devp;\r\ndevp = find_node_by_compatible(NULL, "marvell,mv64360");\r\nif (devp == NULL)\r\ngoto err_out;\r\nif (getprop(devp, "virtual-reg", &v, sizeof(v)) != sizeof(v))\r\ngoto err_out;\r\nreturn (u8 *)v;\r\nerr_out:\r\nreturn 0;\r\n}\r\nu8 mv64x60_is_coherent(void)\r\n{\r\nu32 v;\r\nvoid *devp;\r\ndevp = finddevice("/");\r\nif (devp == NULL)\r\nreturn 1;\r\nif (getprop(devp, "coherency-off", &v, sizeof(v)) < 0)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}
