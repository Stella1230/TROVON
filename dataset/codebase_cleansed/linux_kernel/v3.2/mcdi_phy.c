static int\r\nefx_mcdi_get_phy_cfg(struct efx_nic *efx, struct efx_mcdi_phy_data *cfg)\r\n{\r\nu8 outbuf[MC_CMD_GET_PHY_CFG_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_PHY_CFG_IN_LEN != 0);\r\nBUILD_BUG_ON(MC_CMD_GET_PHY_CFG_OUT_NAME_LEN != sizeof(cfg->name));\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_CFG, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_GET_PHY_CFG_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\ncfg->flags = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_FLAGS);\r\ncfg->type = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_TYPE);\r\ncfg->supported_cap =\r\nMCDI_DWORD(outbuf, GET_PHY_CFG_OUT_SUPPORTED_CAP);\r\ncfg->channel = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_CHANNEL);\r\ncfg->port = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_PRT);\r\ncfg->stats_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_STATS_MASK);\r\nmemcpy(cfg->name, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_NAME),\r\nsizeof(cfg->name));\r\ncfg->media = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MEDIA_TYPE);\r\ncfg->mmd_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MMD_MASK);\r\nmemcpy(cfg->revision, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_REVISION),\r\nsizeof(cfg->revision));\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_set_link(struct efx_nic *efx, u32 capabilities,\r\nu32 flags, u32 loopback_mode,\r\nu32 loopback_speed)\r\n{\r\nu8 inbuf[MC_CMD_SET_LINK_IN_LEN];\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_SET_LINK_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_CAP, capabilities);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_FLAGS, flags);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_MODE, loopback_mode);\r\nMCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_SPEED, loopback_speed);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_SET_LINK, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_loopback_modes(struct efx_nic *efx, u64 *loopback_modes)\r\n{\r\nu8 outbuf[MC_CMD_GET_LOOPBACK_MODES_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LOOPBACK_MODES, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_GET_LOOPBACK_MODES_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*loopback_modes = MCDI_QWORD(outbuf, GET_LOOPBACK_MODES_SUGGESTED);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_mdio_read(struct efx_nic *efx, unsigned int bus,\r\nunsigned int prtad, unsigned int devad, u16 addr,\r\nu16 *value_out, u32 *status_out)\r\n{\r\nu8 inbuf[MC_CMD_MDIO_READ_IN_LEN];\r\nu8 outbuf[MC_CMD_MDIO_READ_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_BUS, bus);\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_PRTAD, prtad);\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_DEVAD, devad);\r\nMCDI_SET_DWORD(inbuf, MDIO_READ_IN_ADDR, addr);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_MDIO_READ, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\n*value_out = (u16)MCDI_DWORD(outbuf, MDIO_READ_OUT_VALUE);\r\n*status_out = MCDI_DWORD(outbuf, MDIO_READ_OUT_STATUS);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_mdio_write(struct efx_nic *efx, unsigned int bus,\r\nunsigned int prtad, unsigned int devad, u16 addr,\r\nu16 value, u32 *status_out)\r\n{\r\nu8 inbuf[MC_CMD_MDIO_WRITE_IN_LEN];\r\nu8 outbuf[MC_CMD_MDIO_WRITE_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_BUS, bus);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_PRTAD, prtad);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_DEVAD, devad);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_ADDR, addr);\r\nMCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_VALUE, value);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_MDIO_WRITE, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\n*status_out = MCDI_DWORD(outbuf, MDIO_WRITE_OUT_STATUS);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic u32 mcdi_to_ethtool_cap(u32 media, u32 cap)\r\n{\r\nu32 result = 0;\r\nswitch (media) {\r\ncase MC_CMD_MEDIA_KX4:\r\nresult |= SUPPORTED_Backplane;\r\nif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))\r\nresult |= SUPPORTED_1000baseKX_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))\r\nresult |= SUPPORTED_10000baseKX4_Full;\r\nbreak;\r\ncase MC_CMD_MEDIA_XFP:\r\ncase MC_CMD_MEDIA_SFP_PLUS:\r\nresult |= SUPPORTED_FIBRE;\r\nbreak;\r\ncase MC_CMD_MEDIA_BASE_T:\r\nresult |= SUPPORTED_TP;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10HDX_LBN))\r\nresult |= SUPPORTED_10baseT_Half;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10FDX_LBN))\r\nresult |= SUPPORTED_10baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_100HDX_LBN))\r\nresult |= SUPPORTED_100baseT_Half;\r\nif (cap & (1 << MC_CMD_PHY_CAP_100FDX_LBN))\r\nresult |= SUPPORTED_100baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_1000HDX_LBN))\r\nresult |= SUPPORTED_1000baseT_Half;\r\nif (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))\r\nresult |= SUPPORTED_1000baseT_Full;\r\nif (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))\r\nresult |= SUPPORTED_10000baseT_Full;\r\nbreak;\r\n}\r\nif (cap & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))\r\nresult |= SUPPORTED_Pause;\r\nif (cap & (1 << MC_CMD_PHY_CAP_ASYM_LBN))\r\nresult |= SUPPORTED_Asym_Pause;\r\nif (cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nresult |= SUPPORTED_Autoneg;\r\nreturn result;\r\n}\r\nstatic u32 ethtool_to_mcdi_cap(u32 cap)\r\n{\r\nu32 result = 0;\r\nif (cap & SUPPORTED_10baseT_Half)\r\nresult |= (1 << MC_CMD_PHY_CAP_10HDX_LBN);\r\nif (cap & SUPPORTED_10baseT_Full)\r\nresult |= (1 << MC_CMD_PHY_CAP_10FDX_LBN);\r\nif (cap & SUPPORTED_100baseT_Half)\r\nresult |= (1 << MC_CMD_PHY_CAP_100HDX_LBN);\r\nif (cap & SUPPORTED_100baseT_Full)\r\nresult |= (1 << MC_CMD_PHY_CAP_100FDX_LBN);\r\nif (cap & SUPPORTED_1000baseT_Half)\r\nresult |= (1 << MC_CMD_PHY_CAP_1000HDX_LBN);\r\nif (cap & (SUPPORTED_1000baseT_Full | SUPPORTED_1000baseKX_Full))\r\nresult |= (1 << MC_CMD_PHY_CAP_1000FDX_LBN);\r\nif (cap & (SUPPORTED_10000baseT_Full | SUPPORTED_10000baseKX4_Full))\r\nresult |= (1 << MC_CMD_PHY_CAP_10000FDX_LBN);\r\nif (cap & SUPPORTED_Pause)\r\nresult |= (1 << MC_CMD_PHY_CAP_PAUSE_LBN);\r\nif (cap & SUPPORTED_Asym_Pause)\r\nresult |= (1 << MC_CMD_PHY_CAP_ASYM_LBN);\r\nif (cap & SUPPORTED_Autoneg)\r\nresult |= (1 << MC_CMD_PHY_CAP_AN_LBN);\r\nreturn result;\r\n}\r\nstatic u32 efx_get_mcdi_phy_flags(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nenum efx_phy_mode mode, supported;\r\nu32 flags;\r\nsupported = 0;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_TXDIS_LBN))\r\nsupported |= PHY_MODE_TX_DISABLED;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_LOWPOWER_LBN))\r\nsupported |= PHY_MODE_LOW_POWER;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_POWEROFF_LBN))\r\nsupported |= PHY_MODE_OFF;\r\nmode = efx->phy_mode & supported;\r\nflags = 0;\r\nif (mode & PHY_MODE_TX_DISABLED)\r\nflags |= (1 << MC_CMD_SET_LINK_TXDIS_LBN);\r\nif (mode & PHY_MODE_LOW_POWER)\r\nflags |= (1 << MC_CMD_SET_LINK_LOWPOWER_LBN);\r\nif (mode & PHY_MODE_OFF)\r\nflags |= (1 << MC_CMD_SET_LINK_POWEROFF_LBN);\r\nreturn flags;\r\n}\r\nstatic u32 mcdi_to_ethtool_media(u32 media)\r\n{\r\nswitch (media) {\r\ncase MC_CMD_MEDIA_XAUI:\r\ncase MC_CMD_MEDIA_CX4:\r\ncase MC_CMD_MEDIA_KX4:\r\nreturn PORT_OTHER;\r\ncase MC_CMD_MEDIA_XFP:\r\ncase MC_CMD_MEDIA_SFP_PLUS:\r\nreturn PORT_FIBRE;\r\ncase MC_CMD_MEDIA_BASE_T:\r\nreturn PORT_TP;\r\ndefault:\r\nreturn PORT_OTHER;\r\n}\r\n}\r\nstatic int efx_mcdi_phy_probe(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_data;\r\nu8 outbuf[MC_CMD_GET_LINK_OUT_LEN];\r\nu32 caps;\r\nint rc;\r\nphy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);\r\nif (phy_data == NULL)\r\nreturn -ENOMEM;\r\nrc = efx_mcdi_get_phy_cfg(efx, phy_data);\r\nif (rc != 0)\r\ngoto fail;\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\ngoto fail;\r\nefx->phy_data = phy_data;\r\nefx->phy_type = phy_data->type;\r\nefx->mdio_bus = phy_data->channel;\r\nefx->mdio.prtad = phy_data->port;\r\nefx->mdio.mmds = phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22);\r\nefx->mdio.mode_support = 0;\r\nif (phy_data->mmd_mask & (1 << MC_CMD_MMD_CLAUSE22))\r\nefx->mdio.mode_support |= MDIO_SUPPORTS_C22;\r\nif (phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22))\r\nefx->mdio.mode_support |= MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\r\ncaps = MCDI_DWORD(outbuf, GET_LINK_OUT_CAP);\r\nif (caps & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nefx->link_advertising =\r\nmcdi_to_ethtool_cap(phy_data->media, caps);\r\nelse\r\nphy_data->forced_cap = caps;\r\nBUILD_BUG_ON(LOOPBACK_NONE != MC_CMD_LOOPBACK_NONE);\r\nBUILD_BUG_ON(LOOPBACK_DATA != MC_CMD_LOOPBACK_DATA);\r\nBUILD_BUG_ON(LOOPBACK_GMAC != MC_CMD_LOOPBACK_GMAC);\r\nBUILD_BUG_ON(LOOPBACK_XGMII != MC_CMD_LOOPBACK_XGMII);\r\nBUILD_BUG_ON(LOOPBACK_XGXS != MC_CMD_LOOPBACK_XGXS);\r\nBUILD_BUG_ON(LOOPBACK_XAUI != MC_CMD_LOOPBACK_XAUI);\r\nBUILD_BUG_ON(LOOPBACK_GMII != MC_CMD_LOOPBACK_GMII);\r\nBUILD_BUG_ON(LOOPBACK_SGMII != MC_CMD_LOOPBACK_SGMII);\r\nBUILD_BUG_ON(LOOPBACK_XGBR != MC_CMD_LOOPBACK_XGBR);\r\nBUILD_BUG_ON(LOOPBACK_XFI != MC_CMD_LOOPBACK_XFI);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_FAR != MC_CMD_LOOPBACK_XAUI_FAR);\r\nBUILD_BUG_ON(LOOPBACK_GMII_FAR != MC_CMD_LOOPBACK_GMII_FAR);\r\nBUILD_BUG_ON(LOOPBACK_SGMII_FAR != MC_CMD_LOOPBACK_SGMII_FAR);\r\nBUILD_BUG_ON(LOOPBACK_XFI_FAR != MC_CMD_LOOPBACK_XFI_FAR);\r\nBUILD_BUG_ON(LOOPBACK_GPHY != MC_CMD_LOOPBACK_GPHY);\r\nBUILD_BUG_ON(LOOPBACK_PHYXS != MC_CMD_LOOPBACK_PHYXS);\r\nBUILD_BUG_ON(LOOPBACK_PCS != MC_CMD_LOOPBACK_PCS);\r\nBUILD_BUG_ON(LOOPBACK_PMAPMD != MC_CMD_LOOPBACK_PMAPMD);\r\nBUILD_BUG_ON(LOOPBACK_XPORT != MC_CMD_LOOPBACK_XPORT);\r\nBUILD_BUG_ON(LOOPBACK_XGMII_WS != MC_CMD_LOOPBACK_XGMII_WS);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_WS != MC_CMD_LOOPBACK_XAUI_WS);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_WS_FAR != MC_CMD_LOOPBACK_XAUI_WS_FAR);\r\nBUILD_BUG_ON(LOOPBACK_XAUI_WS_NEAR != MC_CMD_LOOPBACK_XAUI_WS_NEAR);\r\nBUILD_BUG_ON(LOOPBACK_GMII_WS != MC_CMD_LOOPBACK_GMII_WS);\r\nBUILD_BUG_ON(LOOPBACK_XFI_WS != MC_CMD_LOOPBACK_XFI_WS);\r\nBUILD_BUG_ON(LOOPBACK_XFI_WS_FAR != MC_CMD_LOOPBACK_XFI_WS_FAR);\r\nBUILD_BUG_ON(LOOPBACK_PHYXS_WS != MC_CMD_LOOPBACK_PHYXS_WS);\r\nrc = efx_mcdi_loopback_modes(efx, &efx->loopback_modes);\r\nif (rc != 0)\r\ngoto fail;\r\nefx->loopback_modes &= ~(1 << LOOPBACK_NONE);\r\nefx_mcdi_phy_decode_link(\r\nefx, &efx->link_state,\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));\r\nefx->wanted_fc = EFX_FC_RX | EFX_FC_TX;\r\nif (phy_data->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nefx->wanted_fc |= EFX_FC_AUTO;\r\nefx_link_set_wanted_fc(efx, efx->wanted_fc);\r\nreturn 0;\r\nfail:\r\nkfree(phy_data);\r\nreturn rc;\r\n}\r\nint efx_mcdi_phy_reconfigure(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 caps = (efx->link_advertising ?\r\nethtool_to_mcdi_cap(efx->link_advertising) :\r\nphy_cfg->forced_cap);\r\nreturn efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),\r\nefx->loopback_mode, 0);\r\n}\r\nvoid efx_mcdi_phy_decode_link(struct efx_nic *efx,\r\nstruct efx_link_state *link_state,\r\nu32 speed, u32 flags, u32 fcntl)\r\n{\r\nswitch (fcntl) {\r\ncase MC_CMD_FCNTL_AUTO:\r\nWARN_ON(1);\r\nlink_state->fc = EFX_FC_AUTO | EFX_FC_TX | EFX_FC_RX;\r\nbreak;\r\ncase MC_CMD_FCNTL_BIDIR:\r\nlink_state->fc = EFX_FC_TX | EFX_FC_RX;\r\nbreak;\r\ncase MC_CMD_FCNTL_RESPOND:\r\nlink_state->fc = EFX_FC_RX;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ncase MC_CMD_FCNTL_OFF:\r\nlink_state->fc = 0;\r\nbreak;\r\n}\r\nlink_state->up = !!(flags & (1 << MC_CMD_GET_LINK_LINK_UP_LBN));\r\nlink_state->fd = !!(flags & (1 << MC_CMD_GET_LINK_FULL_DUPLEX_LBN));\r\nlink_state->speed = speed;\r\n}\r\nvoid efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 rmtadv;\r\nif (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))\r\nreturn;\r\nif (efx->wanted_fc & EFX_FC_AUTO)\r\nreturn;\r\nrmtadv = 0;\r\nif (lpa & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))\r\nrmtadv |= ADVERTISED_Pause;\r\nif (lpa & (1 << MC_CMD_PHY_CAP_ASYM_LBN))\r\nrmtadv |= ADVERTISED_Asym_Pause;\r\nif ((efx->wanted_fc & EFX_FC_TX) && rmtadv == ADVERTISED_Asym_Pause)\r\nnetif_err(efx, link, efx->net_dev,\r\n"warning: link partner doesn't support pause frames");\r\n}\r\nstatic bool efx_mcdi_phy_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_link_state old_state = efx->link_state;\r\nu8 outbuf[MC_CMD_GET_LINK_OUT_LEN];\r\nint rc;\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc) {\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",\r\n__func__, rc);\r\nefx->link_state.up = false;\r\n} else {\r\nefx_mcdi_phy_decode_link(\r\nefx, &efx->link_state,\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));\r\n}\r\nreturn !efx_link_state_equal(&efx->link_state, &old_state);\r\n}\r\nstatic void efx_mcdi_phy_remove(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_phy_data *phy_data = efx->phy_data;\r\nefx->phy_data = NULL;\r\nkfree(phy_data);\r\n}\r\nstatic void efx_mcdi_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu8 outbuf[MC_CMD_GET_LINK_OUT_LEN];\r\nint rc;\r\necmd->supported =\r\nmcdi_to_ethtool_cap(phy_cfg->media, phy_cfg->supported_cap);\r\necmd->advertising = efx->link_advertising;\r\nethtool_cmd_speed_set(ecmd, efx->link_state.speed);\r\necmd->duplex = efx->link_state.fd;\r\necmd->port = mcdi_to_ethtool_media(phy_cfg->media);\r\necmd->phy_address = phy_cfg->port;\r\necmd->transceiver = XCVR_INTERNAL;\r\necmd->autoneg = !!(efx->link_advertising & ADVERTISED_Autoneg);\r\necmd->mdio_support = (efx->mdio.mode_support &\r\n(MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22));\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc) {\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",\r\n__func__, rc);\r\nreturn;\r\n}\r\necmd->lp_advertising =\r\nmcdi_to_ethtool_cap(phy_cfg->media,\r\nMCDI_DWORD(outbuf, GET_LINK_OUT_LP_CAP));\r\n}\r\nstatic int efx_mcdi_phy_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 caps;\r\nint rc;\r\nif (ecmd->autoneg) {\r\ncaps = (ethtool_to_mcdi_cap(ecmd->advertising) |\r\n1 << MC_CMD_PHY_CAP_AN_LBN);\r\n} else if (ecmd->duplex) {\r\nswitch (ethtool_cmd_speed(ecmd)) {\r\ncase 10: caps = 1 << MC_CMD_PHY_CAP_10FDX_LBN; break;\r\ncase 100: caps = 1 << MC_CMD_PHY_CAP_100FDX_LBN; break;\r\ncase 1000: caps = 1 << MC_CMD_PHY_CAP_1000FDX_LBN; break;\r\ncase 10000: caps = 1 << MC_CMD_PHY_CAP_10000FDX_LBN; break;\r\ndefault: return -EINVAL;\r\n}\r\n} else {\r\nswitch (ethtool_cmd_speed(ecmd)) {\r\ncase 10: caps = 1 << MC_CMD_PHY_CAP_10HDX_LBN; break;\r\ncase 100: caps = 1 << MC_CMD_PHY_CAP_100HDX_LBN; break;\r\ncase 1000: caps = 1 << MC_CMD_PHY_CAP_1000HDX_LBN; break;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nrc = efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),\r\nefx->loopback_mode, 0);\r\nif (rc)\r\nreturn rc;\r\nif (ecmd->autoneg) {\r\nefx_link_set_advertising(\r\nefx, ecmd->advertising | ADVERTISED_Autoneg);\r\nphy_cfg->forced_cap = 0;\r\n} else {\r\nefx_link_set_advertising(efx, 0);\r\nphy_cfg->forced_cap = caps;\r\n}\r\nreturn 0;\r\n}\r\nstatic int efx_mcdi_phy_test_alive(struct efx_nic *efx)\r\n{\r\nu8 outbuf[MC_CMD_GET_PHY_STATE_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_PHY_STATE_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_STATE, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (outlen < MC_CMD_GET_PHY_STATE_OUT_LEN)\r\nreturn -EIO;\r\nif (MCDI_DWORD(outbuf, GET_PHY_STATE_STATE) != MC_CMD_PHY_STATE_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int efx_mcdi_bist(struct efx_nic *efx, unsigned int bist_mode,\r\nint *results)\r\n{\r\nunsigned int retry, i, count = 0;\r\nsize_t outlen;\r\nu32 status;\r\nu8 *buf, *ptr;\r\nint rc;\r\nbuf = kzalloc(0x100, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nBUILD_BUG_ON(MC_CMD_START_BIST_OUT_LEN != 0);\r\nMCDI_SET_DWORD(buf, START_BIST_IN_TYPE, bist_mode);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_START_BIST, buf, MC_CMD_START_BIST_IN_LEN,\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto out;\r\nfor (retry = 0; retry < 100; ++retry) {\r\nBUILD_BUG_ON(MC_CMD_POLL_BIST_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_POLL_BIST, NULL, 0,\r\nbuf, 0x100, &outlen);\r\nif (rc)\r\ngoto out;\r\nstatus = MCDI_DWORD(buf, POLL_BIST_OUT_RESULT);\r\nif (status != MC_CMD_POLL_BIST_RUNNING)\r\ngoto finished;\r\nmsleep(100);\r\n}\r\nrc = -ETIMEDOUT;\r\ngoto out;\r\nfinished:\r\nresults[count++] = (status == MC_CMD_POLL_BIST_PASSED) ? 1 : -1;\r\nif (efx->phy_type == PHY_TYPE_SFT9001B &&\r\n(bist_mode == MC_CMD_PHY_BIST_CABLE_SHORT ||\r\nbist_mode == MC_CMD_PHY_BIST_CABLE_LONG)) {\r\nptr = MCDI_PTR(buf, POLL_BIST_OUT_SFT9001_CABLE_LENGTH_A);\r\nif (status == MC_CMD_POLL_BIST_PASSED &&\r\noutlen >= MC_CMD_POLL_BIST_OUT_SFT9001_LEN) {\r\nfor (i = 0; i < 8; i++) {\r\nresults[count + i] =\r\nEFX_DWORD_FIELD(((efx_dword_t *)ptr)[i],\r\nEFX_DWORD_0);\r\n}\r\n}\r\ncount += 8;\r\n}\r\nrc = count;\r\nout:\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_phy_run_tests(struct efx_nic *efx, int *results,\r\nunsigned flags)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nu32 mode;\r\nint rc;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_BIST_LBN)) {\r\nrc = efx_mcdi_bist(efx, MC_CMD_PHY_BIST, results);\r\nif (rc < 0)\r\nreturn rc;\r\nresults += rc;\r\n}\r\nmode = 0;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_BIST_CABLE_SHORT_LBN)) {\r\nif ((flags & ETH_TEST_FL_OFFLINE) &&\r\n(phy_cfg->flags &\r\n(1 << MC_CMD_GET_PHY_CFG_BIST_CABLE_LONG_LBN)))\r\nmode = MC_CMD_PHY_BIST_CABLE_LONG;\r\nelse\r\nmode = MC_CMD_PHY_BIST_CABLE_SHORT;\r\n} else if (phy_cfg->flags &\r\n(1 << MC_CMD_GET_PHY_CFG_BIST_CABLE_LONG_LBN))\r\nmode = MC_CMD_PHY_BIST_CABLE_LONG;\r\nif (mode != 0) {\r\nrc = efx_mcdi_bist(efx, mode, results);\r\nif (rc < 0)\r\nreturn rc;\r\nresults += rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *efx_mcdi_phy_test_name(struct efx_nic *efx,\r\nunsigned int index)\r\n{\r\nstruct efx_mcdi_phy_data *phy_cfg = efx->phy_data;\r\nif (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_BIST_LBN)) {\r\nif (index == 0)\r\nreturn "bist";\r\n--index;\r\n}\r\nif (phy_cfg->flags & ((1 << MC_CMD_GET_PHY_CFG_BIST_CABLE_SHORT_LBN) |\r\n(1 << MC_CMD_GET_PHY_CFG_BIST_CABLE_LONG_LBN))) {\r\nif (index == 0)\r\nreturn "cable";\r\n--index;\r\nif (efx->phy_type == PHY_TYPE_SFT9001B) {\r\nif (index < ARRAY_SIZE(mcdi_sft9001_cable_diag_names))\r\nreturn mcdi_sft9001_cable_diag_names[index];\r\nindex -= ARRAY_SIZE(mcdi_sft9001_cable_diag_names);\r\n}\r\n}\r\nreturn NULL;\r\n}
