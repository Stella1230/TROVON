static inline int superio_enter(void)\r\n{\r\nif (!request_muxed_region(REG, 2, WATCHDOG_NAME))\r\nreturn -EBUSY;\r\noutb(0x87, REG);\r\noutb(0x01, REG);\r\noutb(0x55, REG);\r\noutb(0x55, REG);\r\nreturn 0;\r\n}\r\nstatic inline void superio_exit(void)\r\n{\r\noutb(0x02, REG);\r\noutb(0x02, VAL);\r\nrelease_region(REG, 2);\r\n}\r\nstatic inline void superio_select(int ldn)\r\n{\r\noutb(LDNREG, REG);\r\noutb(ldn, VAL);\r\n}\r\nstatic inline int superio_inb(int reg)\r\n{\r\noutb(reg, REG);\r\nreturn inb(VAL);\r\n}\r\nstatic inline void superio_outb(int val, int reg)\r\n{\r\noutb(reg, REG);\r\noutb(val, VAL);\r\n}\r\nstatic inline int superio_inw(int reg)\r\n{\r\nint val;\r\noutb(reg++, REG);\r\nval = inb(VAL) << 8;\r\noutb(reg, REG);\r\nval |= inb(VAL);\r\nreturn val;\r\n}\r\nstatic inline void superio_outw(int val, int reg)\r\n{\r\noutb(reg++, REG);\r\noutb(val >> 8, VAL);\r\noutb(reg, REG);\r\noutb(val, VAL);\r\n}\r\nstatic void wdt_update_timeout(void)\r\n{\r\nunsigned char cfg = WDT_KRST;\r\nint tm = timeout;\r\nif (testmode)\r\ncfg = 0;\r\nif (tm <= max_units)\r\ncfg |= WDT_TOV1;\r\nelse\r\ntm /= 60;\r\nif (chip_type != IT8721_ID)\r\ncfg |= WDT_PWROK;\r\nsuperio_outb(cfg, WDTCFG);\r\nsuperio_outb(tm, WDTVALLSB);\r\nif (max_units > 255)\r\nsuperio_outb(tm>>8, WDTVALMSB);\r\n}\r\nstatic int wdt_round_time(int t)\r\n{\r\nt += 59;\r\nt -= t % 60;\r\nreturn t;\r\n}\r\nstatic void wdt_keepalive(void)\r\n{\r\nif (test_bit(WDTS_USE_GP, &wdt_status))\r\ninb(base);\r\nelse\r\noutb(0x55, CIR_DR(base));\r\nset_bit(WDTS_KEEPALIVE, &wdt_status);\r\n}\r\nstatic int wdt_start(void)\r\n{\r\nint ret = superio_enter();\r\nif (ret)\r\nreturn ret;\r\nsuperio_select(GPIO);\r\nif (test_bit(WDTS_USE_GP, &wdt_status))\r\nsuperio_outb(WDT_GAMEPORT, WDTCTRL);\r\nelse\r\nsuperio_outb(WDT_CIRINT, WDTCTRL);\r\nwdt_update_timeout();\r\nsuperio_exit();\r\nreturn 0;\r\n}\r\nstatic int wdt_stop(void)\r\n{\r\nint ret = superio_enter();\r\nif (ret)\r\nreturn ret;\r\nsuperio_select(GPIO);\r\nsuperio_outb(0x00, WDTCTRL);\r\nsuperio_outb(WDT_TOV1, WDTCFG);\r\nsuperio_outb(0x00, WDTVALLSB);\r\nif (max_units > 255)\r\nsuperio_outb(0x00, WDTVALMSB);\r\nsuperio_exit();\r\nreturn 0;\r\n}\r\nstatic int wdt_set_timeout(int t)\r\n{\r\nif (t < 1 || t > max_units * 60)\r\nreturn -EINVAL;\r\nif (t > max_units)\r\ntimeout = wdt_round_time(t);\r\nelse\r\ntimeout = t;\r\nif (test_bit(WDTS_TIMER_RUN, &wdt_status)) {\r\nint ret = superio_enter();\r\nif (ret)\r\nreturn ret;\r\nsuperio_select(GPIO);\r\nwdt_update_timeout();\r\nsuperio_exit();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdt_get_status(int *status)\r\n{\r\n*status = 0;\r\nif (testmode) {\r\nint ret = superio_enter();\r\nif (ret)\r\nreturn ret;\r\nsuperio_select(GPIO);\r\nif (superio_inb(WDTCTRL) & WDT_ZERO) {\r\nsuperio_outb(0x00, WDTCTRL);\r\nclear_bit(WDTS_TIMER_RUN, &wdt_status);\r\n*status |= WDIOF_CARDRESET;\r\n}\r\nsuperio_exit();\r\n}\r\nif (test_and_clear_bit(WDTS_KEEPALIVE, &wdt_status))\r\n*status |= WDIOF_KEEPALIVEPING;\r\nif (test_bit(WDTS_EXPECTED, &wdt_status))\r\n*status |= WDIOF_MAGICCLOSE;\r\nreturn 0;\r\n}\r\nstatic int wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (exclusive && test_and_set_bit(WDTS_DEV_OPEN, &wdt_status))\r\nreturn -EBUSY;\r\nif (!test_and_set_bit(WDTS_TIMER_RUN, &wdt_status)) {\r\nint ret;\r\nif (nowayout && !test_and_set_bit(WDTS_LOCKED, &wdt_status))\r\n__module_get(THIS_MODULE);\r\nret = wdt_start();\r\nif (ret) {\r\nclear_bit(WDTS_LOCKED, &wdt_status);\r\nclear_bit(WDTS_TIMER_RUN, &wdt_status);\r\nclear_bit(WDTS_DEV_OPEN, &wdt_status);\r\nreturn ret;\r\n}\r\n}\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (test_bit(WDTS_TIMER_RUN, &wdt_status)) {\r\nif (test_and_clear_bit(WDTS_EXPECTED, &wdt_status)) {\r\nint ret = wdt_stop();\r\nif (ret) {\r\nset_bit(WDTS_EXPECTED, &wdt_status);\r\nwdt_keepalive();\r\nreturn ret;\r\n}\r\nclear_bit(WDTS_TIMER_RUN, &wdt_status);\r\n} else {\r\nwdt_keepalive();\r\nprintk(KERN_CRIT PFX\r\n"unexpected close, not stopping watchdog!\n");\r\n}\r\n}\r\nclear_bit(WDTS_DEV_OPEN, &wdt_status);\r\nreturn 0;\r\n}\r\nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nclear_bit(WDTS_EXPECTED, &wdt_status);\r\nwdt_keepalive();\r\n}\r\nif (!nowayout) {\r\nsize_t ofs;\r\nfor (ofs = 0; ofs != count; ofs++) {\r\nchar c;\r\nif (get_user(c, buf + ofs))\r\nreturn -EFAULT;\r\nif (c == WD_MAGIC)\r\nset_bit(WDTS_EXPECTED, &wdt_status);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic long wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint rc = 0, status, new_options, new_timeout;\r\nunion {\r\nstruct watchdog_info __user *ident;\r\nint __user *i;\r\n} uarg;\r\nuarg.i = (int __user *)arg;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(uarg.ident,\r\n&ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\nrc = wdt_get_status(&status);\r\nif (rc)\r\nreturn rc;\r\nreturn put_user(status, uarg.i);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, uarg.i);\r\ncase WDIOC_KEEPALIVE:\r\nwdt_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(new_options, uarg.i))\r\nreturn -EFAULT;\r\nswitch (new_options) {\r\ncase WDIOS_DISABLECARD:\r\nif (test_bit(WDTS_TIMER_RUN, &wdt_status)) {\r\nrc = wdt_stop();\r\nif (rc)\r\nreturn rc;\r\n}\r\nclear_bit(WDTS_TIMER_RUN, &wdt_status);\r\nreturn 0;\r\ncase WDIOS_ENABLECARD:\r\nif (!test_and_set_bit(WDTS_TIMER_RUN, &wdt_status)) {\r\nrc = wdt_start();\r\nif (rc) {\r\nclear_bit(WDTS_TIMER_RUN, &wdt_status);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, uarg.i))\r\nreturn -EFAULT;\r\nrc = wdt_set_timeout(new_timeout);\r\ncase WDIOC_GETTIMEOUT:\r\nif (put_user(timeout, uarg.i))\r\nreturn -EFAULT;\r\nreturn rc;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdt_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init it87_wdt_init(void)\r\n{\r\nint rc = 0;\r\nint try_gameport = !nogameport;\r\nu8 chip_rev;\r\nint gp_rreq_fail = 0;\r\nwdt_status = 0;\r\nrc = superio_enter();\r\nif (rc)\r\nreturn rc;\r\nchip_type = superio_inw(CHIPID);\r\nchip_rev = superio_inb(CHIPREV) & 0x0f;\r\nsuperio_exit();\r\nswitch (chip_type) {\r\ncase IT8702_ID:\r\nmax_units = 255;\r\nbreak;\r\ncase IT8712_ID:\r\nmax_units = (chip_rev < 8) ? 255 : 65535;\r\nbreak;\r\ncase IT8716_ID:\r\ncase IT8726_ID:\r\nmax_units = 65535;\r\nbreak;\r\ncase IT8718_ID:\r\ncase IT8720_ID:\r\ncase IT8721_ID:\r\nmax_units = 65535;\r\ntry_gameport = 0;\r\nbreak;\r\ncase IT8705_ID:\r\nprintk(KERN_ERR PFX\r\n"Unsupported Chip found, Chip %04x Revision %02x\n",\r\nchip_type, chip_rev);\r\nreturn -ENODEV;\r\ncase NO_DEV_ID:\r\nprintk(KERN_ERR PFX "no device\n");\r\nreturn -ENODEV;\r\ndefault:\r\nprintk(KERN_ERR PFX\r\n"Unknown Chip found, Chip %04x Revision %04x\n",\r\nchip_type, chip_rev);\r\nreturn -ENODEV;\r\n}\r\nrc = superio_enter();\r\nif (rc)\r\nreturn rc;\r\nsuperio_select(GPIO);\r\nsuperio_outb(WDT_TOV1, WDTCFG);\r\nsuperio_outb(0x00, WDTCTRL);\r\nif (try_gameport) {\r\nsuperio_select(GAMEPORT);\r\nbase = superio_inw(BASEREG);\r\nif (!base) {\r\nbase = GP_BASE_DEFAULT;\r\nsuperio_outw(base, BASEREG);\r\n}\r\ngpact = superio_inb(ACTREG);\r\nsuperio_outb(0x01, ACTREG);\r\nif (request_region(base, 1, WATCHDOG_NAME))\r\nset_bit(WDTS_USE_GP, &wdt_status);\r\nelse\r\ngp_rreq_fail = 1;\r\n}\r\nif (!test_bit(WDTS_USE_GP, &wdt_status)) {\r\nif (!request_region(CIR_BASE, 8, WATCHDOG_NAME)) {\r\nif (gp_rreq_fail)\r\nprintk(KERN_ERR PFX\r\n"I/O Address 0x%04x and 0x%04x"\r\n" already in use\n", base, CIR_BASE);\r\nelse\r\nprintk(KERN_ERR PFX\r\n"I/O Address 0x%04x already in use\n",\r\nCIR_BASE);\r\nrc = -EIO;\r\ngoto err_out;\r\n}\r\nbase = CIR_BASE;\r\nsuperio_select(CIR);\r\nsuperio_outw(base, BASEREG);\r\nsuperio_outb(0x00, CIR_ILS);\r\nciract = superio_inb(ACTREG);\r\nsuperio_outb(0x01, ACTREG);\r\nif (gp_rreq_fail) {\r\nsuperio_select(GAMEPORT);\r\nsuperio_outb(gpact, ACTREG);\r\n}\r\n}\r\nif (timeout < 1 || timeout > max_units * 60) {\r\ntimeout = DEFAULT_TIMEOUT;\r\nprintk(KERN_WARNING PFX\r\n"Timeout value out of range, use default %d sec\n",\r\nDEFAULT_TIMEOUT);\r\n}\r\nif (timeout > max_units)\r\ntimeout = wdt_round_time(timeout);\r\nrc = register_reboot_notifier(&wdt_notifier);\r\nif (rc) {\r\nprintk(KERN_ERR PFX\r\n"Cannot register reboot notifier (err=%d)\n", rc);\r\ngoto err_out_region;\r\n}\r\nrc = misc_register(&wdt_miscdev);\r\nif (rc) {\r\nprintk(KERN_ERR PFX\r\n"Cannot register miscdev on minor=%d (err=%d)\n",\r\nwdt_miscdev.minor, rc);\r\ngoto err_out_reboot;\r\n}\r\nif (!test_bit(WDTS_USE_GP, &wdt_status)) {\r\noutb(0x00, CIR_RCR(base));\r\noutb(0xc0, CIR_TCR1(base));\r\noutb(0x5c, CIR_TCR2(base));\r\noutb(0x10, CIR_IER(base));\r\noutb(0x00, CIR_BDHR(base));\r\noutb(0x01, CIR_BDLR(base));\r\noutb(0x09, CIR_IER(base));\r\n}\r\nprintk(KERN_INFO PFX "Chip IT%04x revision %d initialized. "\r\n"timeout=%d sec (nowayout=%d testmode=%d exclusive=%d "\r\n"nogameport=%d)\n", chip_type, chip_rev, timeout,\r\nnowayout, testmode, exclusive, nogameport);\r\nsuperio_exit();\r\nreturn 0;\r\nerr_out_reboot:\r\nunregister_reboot_notifier(&wdt_notifier);\r\nerr_out_region:\r\nrelease_region(base, test_bit(WDTS_USE_GP, &wdt_status) ? 1 : 8);\r\nif (!test_bit(WDTS_USE_GP, &wdt_status)) {\r\nsuperio_select(CIR);\r\nsuperio_outb(ciract, ACTREG);\r\n}\r\nerr_out:\r\nif (try_gameport) {\r\nsuperio_select(GAMEPORT);\r\nsuperio_outb(gpact, ACTREG);\r\n}\r\nsuperio_exit();\r\nreturn rc;\r\n}\r\nstatic void __exit it87_wdt_exit(void)\r\n{\r\nif (superio_enter() == 0) {\r\nsuperio_select(GPIO);\r\nsuperio_outb(0x00, WDTCTRL);\r\nsuperio_outb(0x00, WDTCFG);\r\nsuperio_outb(0x00, WDTVALLSB);\r\nif (max_units > 255)\r\nsuperio_outb(0x00, WDTVALMSB);\r\nif (test_bit(WDTS_USE_GP, &wdt_status)) {\r\nsuperio_select(GAMEPORT);\r\nsuperio_outb(gpact, ACTREG);\r\n} else {\r\nsuperio_select(CIR);\r\nsuperio_outb(ciract, ACTREG);\r\n}\r\nsuperio_exit();\r\n}\r\nmisc_deregister(&wdt_miscdev);\r\nunregister_reboot_notifier(&wdt_notifier);\r\nrelease_region(base, test_bit(WDTS_USE_GP, &wdt_status) ? 1 : 8);\r\n}
