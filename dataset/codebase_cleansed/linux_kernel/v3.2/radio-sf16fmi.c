static void outbits(int bits, unsigned int data, int io)\r\n{\r\nwhile (bits--) {\r\nif (data & 1) {\r\noutb(5, io);\r\nudelay(6);\r\noutb(7, io);\r\nudelay(6);\r\n} else {\r\noutb(1, io);\r\nudelay(6);\r\noutb(3, io);\r\nudelay(6);\r\n}\r\ndata >>= 1;\r\n}\r\n}\r\nstatic inline void fmi_mute(struct fmi *fmi)\r\n{\r\nmutex_lock(&fmi->lock);\r\noutb(0x00, fmi->io);\r\nmutex_unlock(&fmi->lock);\r\n}\r\nstatic inline void fmi_unmute(struct fmi *fmi)\r\n{\r\nmutex_lock(&fmi->lock);\r\noutb(0x08, fmi->io);\r\nmutex_unlock(&fmi->lock);\r\n}\r\nstatic inline int fmi_setfreq(struct fmi *fmi, unsigned long freq)\r\n{\r\nmutex_lock(&fmi->lock);\r\nfmi->curfreq = freq;\r\noutbits(16, RSF16_ENCODE(freq), fmi->io);\r\noutbits(8, 0xC0, fmi->io);\r\nmsleep(143);\r\nmutex_unlock(&fmi->lock);\r\nif (!fmi->mute)\r\nfmi_unmute(fmi);\r\nreturn 0;\r\n}\r\nstatic inline int fmi_getsigstr(struct fmi *fmi)\r\n{\r\nint val;\r\nint res;\r\nmutex_lock(&fmi->lock);\r\nval = fmi->mute ? 0x00 : 0x08;\r\noutb(val, fmi->io);\r\noutb(val | 0x10, fmi->io);\r\nmsleep(143);\r\nres = (int)inb(fmi->io + 1);\r\noutb(val, fmi->io);\r\nmutex_unlock(&fmi->lock);\r\nreturn (res & 2) ? 0 : 0xFFFF;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));\r\nstrlcpy(v->card, "SF16-FMx radio", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = RSF16_MINFREQ;\r\nv->rangehigh = RSF16_MAXFREQ;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nv->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW;\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nv->signal = fmi_getsigstr(fmi);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nif (f->frequency < RSF16_MINFREQ ||\r\nf->frequency > RSF16_MAXFREQ)\r\nreturn -EINVAL;\r\nfmi_setfreq(fmi, (f->frequency / 800) * 800);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = fmi->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = fmi->mute;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value)\r\nfmi_mute(fmi);\r\nelse\r\nfmi_unmute(fmi);\r\nfmi->mute = ctrl->value;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn a->index ? -EINVAL : 0;\r\n}\r\nstatic int __init isapnp_fmi_probe(void)\r\n{\r\nint i = 0;\r\nwhile (id_table[i].card_vendor != 0 && dev == NULL) {\r\ndev = pnp_find_dev(NULL, id_table[i].vendor,\r\nid_table[i].function, NULL);\r\ni++;\r\n}\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (pnp_device_attach(dev) < 0)\r\nreturn -EAGAIN;\r\nif (pnp_activate_dev(dev) < 0) {\r\nprintk(KERN_ERR "radio-sf16fmi: PnP configure failed (out of resources?)\n");\r\npnp_device_detach(dev);\r\nreturn -ENOMEM;\r\n}\r\nif (!pnp_port_valid(dev, 0)) {\r\npnp_device_detach(dev);\r\nreturn -ENODEV;\r\n}\r\ni = pnp_port_start(dev, 0);\r\nprintk(KERN_INFO "radio-sf16fmi: PnP reports card at %#x\n", i);\r\nreturn i;\r\n}\r\nstatic int __init fmi_init(void)\r\n{\r\nstruct fmi *fmi = &fmi_card;\r\nstruct v4l2_device *v4l2_dev = &fmi->v4l2_dev;\r\nint res, i;\r\nint probe_ports[] = { 0, 0x284, 0x384 };\r\nif (io < 0) {\r\nfor (i = 0; i < ARRAY_SIZE(probe_ports); i++) {\r\nio = probe_ports[i];\r\nif (io == 0) {\r\nio = isapnp_fmi_probe();\r\nif (io < 0)\r\ncontinue;\r\npnp_attached = 1;\r\n}\r\nif (!request_region(io, 2, "radio-sf16fmi")) {\r\nif (pnp_attached)\r\npnp_device_detach(dev);\r\nio = -1;\r\ncontinue;\r\n}\r\nif (pnp_attached ||\r\n((inb(io) & 0xf9) == 0xf9 && (inb(io) & 0x4) == 0))\r\nbreak;\r\nrelease_region(io, 2);\r\nio = -1;\r\n}\r\n} else {\r\nif (!request_region(io, 2, "radio-sf16fmi")) {\r\nprintk(KERN_ERR "radio-sf16fmi: port %#x already in use\n", io);\r\nreturn -EBUSY;\r\n}\r\nif (inb(io) == 0xff) {\r\nprintk(KERN_ERR "radio-sf16fmi: card not present at %#x\n", io);\r\nrelease_region(io, 2);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (io < 0) {\r\nprintk(KERN_ERR "radio-sf16fmi: no cards found\n");\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(v4l2_dev->name, "sf16fmi", sizeof(v4l2_dev->name));\r\nfmi->io = io;\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(fmi->io, 2);\r\nif (pnp_attached)\r\npnp_device_detach(dev);\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn res;\r\n}\r\nstrlcpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));\r\nfmi->vdev.v4l2_dev = v4l2_dev;\r\nfmi->vdev.fops = &fmi_fops;\r\nfmi->vdev.ioctl_ops = &fmi_ioctl_ops;\r\nfmi->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&fmi->vdev, fmi);\r\nmutex_init(&fmi->lock);\r\nfmi_mute(fmi);\r\nif (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_device_unregister(v4l2_dev);\r\nrelease_region(fmi->io, 2);\r\nif (pnp_attached)\r\npnp_device_detach(dev);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(v4l2_dev, "card driver at 0x%x\n", fmi->io);\r\nreturn 0;\r\n}\r\nstatic void __exit fmi_exit(void)\r\n{\r\nstruct fmi *fmi = &fmi_card;\r\nvideo_unregister_device(&fmi->vdev);\r\nv4l2_device_unregister(&fmi->v4l2_dev);\r\nrelease_region(fmi->io, 2);\r\nif (dev && pnp_attached)\r\npnp_device_detach(dev);\r\n}
