long kvmppc_alloc_hpt(struct kvm *kvm)\r\n{\r\nunsigned long hpt;\r\nunsigned long lpid;\r\nhpt = __get_free_pages(GFP_KERNEL|__GFP_ZERO|__GFP_REPEAT|__GFP_NOWARN,\r\nHPT_ORDER - PAGE_SHIFT);\r\nif (!hpt) {\r\npr_err("kvm_alloc_hpt: Couldn't alloc HPT\n");\r\nreturn -ENOMEM;\r\n}\r\nkvm->arch.hpt_virt = hpt;\r\ndo {\r\nlpid = find_first_zero_bit(lpid_inuse, NR_LPIDS);\r\nif (lpid >= NR_LPIDS) {\r\npr_err("kvm_alloc_hpt: No LPIDs free\n");\r\nfree_pages(hpt, HPT_ORDER - PAGE_SHIFT);\r\nreturn -ENOMEM;\r\n}\r\n} while (test_and_set_bit(lpid, lpid_inuse));\r\nkvm->arch.sdr1 = __pa(hpt) | (HPT_ORDER - 18);\r\nkvm->arch.lpid = lpid;\r\npr_info("KVM guest htab at %lx, LPID %lx\n", hpt, lpid);\r\nreturn 0;\r\n}\r\nvoid kvmppc_free_hpt(struct kvm *kvm)\r\n{\r\nclear_bit(kvm->arch.lpid, lpid_inuse);\r\nfree_pages(kvm->arch.hpt_virt, HPT_ORDER - PAGE_SHIFT);\r\n}\r\nvoid kvmppc_map_vrma(struct kvm *kvm, struct kvm_userspace_memory_region *mem)\r\n{\r\nunsigned long i;\r\nunsigned long npages = kvm->arch.ram_npages;\r\nunsigned long pfn;\r\nunsigned long *hpte;\r\nunsigned long hash;\r\nstruct kvmppc_pginfo *pginfo = kvm->arch.ram_pginfo;\r\nif (!pginfo)\r\nreturn;\r\nif (npages > 1ul << (40 - kvm->arch.ram_porder))\r\nnpages = 1ul << (40 - kvm->arch.ram_porder);\r\nif (npages > HPT_NPTEG)\r\nnpages = HPT_NPTEG;\r\nfor (i = 0; i < npages; ++i) {\r\npfn = pginfo[i].pfn;\r\nif (!pfn)\r\nbreak;\r\nhash = (i ^ (VRMA_VSID ^ (VRMA_VSID << 25))) & HPT_HASH_MASK;\r\nhpte = (unsigned long *) (kvm->arch.hpt_virt + (hash << 7));\r\nhpte += 7 * 2;\r\nhpte[1] = (pfn << PAGE_SHIFT) | HPTE_R_R | HPTE_R_C |\r\nHPTE_R_M | PP_RWXX;\r\nwmb();\r\nhpte[0] = HPTE_V_1TB_SEG | (VRMA_VSID << (40 - 16)) |\r\n(i << (VRMA_PAGE_ORDER - 16)) | HPTE_V_BOLTED |\r\nHPTE_V_LARGE | HPTE_V_VALID;\r\n}\r\n}\r\nint kvmppc_mmu_hv_init(void)\r\n{\r\nunsigned long host_lpid, rsvd_lpid;\r\nif (!cpu_has_feature(CPU_FTR_HVMODE))\r\nreturn -EINVAL;\r\nmemset(lpid_inuse, 0, sizeof(lpid_inuse));\r\nif (cpu_has_feature(CPU_FTR_ARCH_206)) {\r\nhost_lpid = mfspr(SPRN_LPID);\r\nrsvd_lpid = LPID_RSVD;\r\n} else {\r\nhost_lpid = 0;\r\nrsvd_lpid = MAX_LPID_970;\r\n}\r\nset_bit(host_lpid, lpid_inuse);\r\nset_bit(rsvd_lpid, lpid_inuse);\r\nreturn 0;\r\n}\r\nvoid kvmppc_mmu_destroy(struct kvm_vcpu *vcpu)\r\n{\r\n}\r\nstatic void kvmppc_mmu_book3s_64_hv_reset_msr(struct kvm_vcpu *vcpu)\r\n{\r\nkvmppc_set_msr(vcpu, MSR_SF | MSR_ME);\r\n}\r\nstatic int kvmppc_mmu_book3s_64_hv_xlate(struct kvm_vcpu *vcpu, gva_t eaddr,\r\nstruct kvmppc_pte *gpte, bool data)\r\n{\r\nreturn -ENOENT;\r\n}\r\nvoid kvmppc_mmu_book3s_hv_init(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_mmu *mmu = &vcpu->arch.mmu;\r\nif (cpu_has_feature(CPU_FTR_ARCH_206))\r\nvcpu->arch.slb_nr = 32;\r\nelse\r\nvcpu->arch.slb_nr = 64;\r\nmmu->xlate = kvmppc_mmu_book3s_64_hv_xlate;\r\nmmu->reset_msr = kvmppc_mmu_book3s_64_hv_reset_msr;\r\nvcpu->arch.hflags |= BOOK3S_HFLAG_SLB;\r\n}
