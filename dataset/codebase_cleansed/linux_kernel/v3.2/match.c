static struct table_header *unpack_table(char *blob, size_t bsize)\r\n{\r\nstruct table_header *table = NULL;\r\nstruct table_header th;\r\nsize_t tsize;\r\nif (bsize < sizeof(struct table_header))\r\ngoto out;\r\nth.td_id = be16_to_cpu(*(u16 *) (blob)) - 1;\r\nth.td_flags = be16_to_cpu(*(u16 *) (blob + 2));\r\nth.td_lolen = be32_to_cpu(*(u32 *) (blob + 8));\r\nblob += sizeof(struct table_header);\r\nif (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||\r\nth.td_flags == YYTD_DATA8))\r\ngoto out;\r\ntsize = table_size(th.td_lolen, th.td_flags);\r\nif (bsize < tsize)\r\ngoto out;\r\ntable = kvmalloc(tsize);\r\nif (table) {\r\n*table = th;\r\nif (th.td_flags == YYTD_DATA8)\r\nUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\r\nu8, byte_to_byte);\r\nelse if (th.td_flags == YYTD_DATA16)\r\nUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\r\nu16, be16_to_cpu);\r\nelse if (th.td_flags == YYTD_DATA32)\r\nUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\r\nu32, be32_to_cpu);\r\nelse\r\ngoto fail;\r\n}\r\nout:\r\nif (is_vmalloc_addr(table))\r\nvm_unmap_aliases();\r\nreturn table;\r\nfail:\r\nkvfree(table);\r\nreturn NULL;\r\n}\r\nstatic int verify_dfa(struct aa_dfa *dfa, int flags)\r\n{\r\nsize_t i, state_count, trans_count;\r\nint error = -EPROTO;\r\nif (!(dfa->tables[YYTD_ID_DEF] &&\r\ndfa->tables[YYTD_ID_BASE] &&\r\ndfa->tables[YYTD_ID_NXT] && dfa->tables[YYTD_ID_CHK]))\r\ngoto out;\r\nstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\r\nif (ACCEPT1_FLAGS(flags)) {\r\nif (!dfa->tables[YYTD_ID_ACCEPT])\r\ngoto out;\r\nif (state_count != dfa->tables[YYTD_ID_ACCEPT]->td_lolen)\r\ngoto out;\r\n}\r\nif (ACCEPT2_FLAGS(flags)) {\r\nif (!dfa->tables[YYTD_ID_ACCEPT2])\r\ngoto out;\r\nif (state_count != dfa->tables[YYTD_ID_ACCEPT2]->td_lolen)\r\ngoto out;\r\n}\r\nif (state_count != dfa->tables[YYTD_ID_DEF]->td_lolen)\r\ngoto out;\r\ntrans_count = dfa->tables[YYTD_ID_NXT]->td_lolen;\r\nif (trans_count != dfa->tables[YYTD_ID_CHK]->td_lolen)\r\ngoto out;\r\nif (dfa->tables[YYTD_ID_EC] &&\r\ndfa->tables[YYTD_ID_EC]->td_lolen != 256)\r\ngoto out;\r\nif (flags & DFA_FLAG_VERIFY_STATES) {\r\nfor (i = 0; i < state_count; i++) {\r\nif (DEFAULT_TABLE(dfa)[i] >= state_count)\r\ngoto out;\r\nif (BASE_TABLE(dfa)[i] + 255 >= trans_count) {\r\nprintk(KERN_ERR "AppArmor DFA next/check upper "\r\n"bounds error\n");\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < trans_count; i++) {\r\nif (NEXT_TABLE(dfa)[i] >= state_count)\r\ngoto out;\r\nif (CHECK_TABLE(dfa)[i] >= state_count)\r\ngoto out;\r\n}\r\n}\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nstatic void dfa_free(struct aa_dfa *dfa)\r\n{\r\nif (dfa) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dfa->tables); i++) {\r\nkvfree(dfa->tables[i]);\r\ndfa->tables[i] = NULL;\r\n}\r\nkfree(dfa);\r\n}\r\n}\r\nvoid aa_dfa_free_kref(struct kref *kref)\r\n{\r\nstruct aa_dfa *dfa = container_of(kref, struct aa_dfa, count);\r\ndfa_free(dfa);\r\n}\r\nstruct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\r\n{\r\nint hsize;\r\nint error = -ENOMEM;\r\nchar *data = blob;\r\nstruct table_header *table = NULL;\r\nstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\r\nif (!dfa)\r\ngoto fail;\r\nkref_init(&dfa->count);\r\nerror = -EPROTO;\r\nif (size < sizeof(struct table_set_header))\r\ngoto fail;\r\nif (ntohl(*(u32 *) data) != YYTH_MAGIC)\r\ngoto fail;\r\nhsize = ntohl(*(u32 *) (data + 4));\r\nif (size < hsize)\r\ngoto fail;\r\ndfa->flags = ntohs(*(u16 *) (data + 12));\r\ndata += hsize;\r\nsize -= hsize;\r\nwhile (size > 0) {\r\ntable = unpack_table(data, size);\r\nif (!table)\r\ngoto fail;\r\nswitch (table->td_id) {\r\ncase YYTD_ID_ACCEPT:\r\nif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\r\ngoto fail;\r\nbreak;\r\ncase YYTD_ID_ACCEPT2:\r\nif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\r\ngoto fail;\r\nbreak;\r\ncase YYTD_ID_BASE:\r\nif (table->td_flags != YYTD_DATA32)\r\ngoto fail;\r\nbreak;\r\ncase YYTD_ID_DEF:\r\ncase YYTD_ID_NXT:\r\ncase YYTD_ID_CHK:\r\nif (table->td_flags != YYTD_DATA16)\r\ngoto fail;\r\nbreak;\r\ncase YYTD_ID_EC:\r\nif (table->td_flags != YYTD_DATA8)\r\ngoto fail;\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\nif (dfa->tables[table->td_id])\r\ngoto fail;\r\ndfa->tables[table->td_id] = table;\r\ndata += table_size(table->td_lolen, table->td_flags);\r\nsize -= table_size(table->td_lolen, table->td_flags);\r\ntable = NULL;\r\n}\r\nerror = verify_dfa(dfa, flags);\r\nif (error)\r\ngoto fail;\r\nreturn dfa;\r\nfail:\r\nkvfree(table);\r\ndfa_free(dfa);\r\nreturn ERR_PTR(error);\r\n}\r\nunsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\r\nconst char *str, int len)\r\n{\r\nu16 *def = DEFAULT_TABLE(dfa);\r\nu32 *base = BASE_TABLE(dfa);\r\nu16 *next = NEXT_TABLE(dfa);\r\nu16 *check = CHECK_TABLE(dfa);\r\nunsigned int state = start, pos;\r\nif (state == 0)\r\nreturn 0;\r\nif (dfa->tables[YYTD_ID_EC]) {\r\nu8 *equiv = EQUIV_TABLE(dfa);\r\nfor (; len; len--) {\r\npos = base[state] + equiv[(u8) *str++];\r\nif (check[pos] == state)\r\nstate = next[pos];\r\nelse\r\nstate = def[state];\r\n}\r\n} else {\r\nfor (; len; len--) {\r\npos = base[state] + (u8) *str++;\r\nif (check[pos] == state)\r\nstate = next[pos];\r\nelse\r\nstate = def[state];\r\n}\r\n}\r\nreturn state;\r\n}\r\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\r\nconst char *str)\r\n{\r\nreturn aa_dfa_match_len(dfa, start, str, strlen(str));\r\n}
