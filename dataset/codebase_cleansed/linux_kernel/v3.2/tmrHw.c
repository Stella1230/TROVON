uint32_t tmrHw_getTimerCapability(tmrHw_ID_t timerId,\r\ntmrHw_CAPABILITY_e capability\r\n) {\r\nswitch (capability) {\r\ncase tmrHw_CAPABILITY_CLOCK:\r\nreturn (timerId <=\r\n1) ? tmrHw_LOW_RESOLUTION_CLOCK :\r\ntmrHw_HIGH_RESOLUTION_CLOCK;\r\ncase tmrHw_CAPABILITY_RESOLUTION:\r\nreturn 32;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ResetTimer(tmrHw_ID_t timerId\r\n) {\r\npTmrHw[timerId].LoadValue = 0;\r\npTmrHw[timerId].CurrentValue = 0xFFFFFFFF;\r\npTmrHw[timerId].Control = 0;\r\npTmrHw[timerId].BackgroundLoad = 0;\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_32BIT;\r\nif (pTmrHw[timerId].RawInterruptStatus) {\r\npTmrHw[timerId].InterruptClear = 0xFFFFFFFF;\r\n}\r\n}\r\nstatic tmrHw_INTERVAL_t SetTimerPeriod(tmrHw_ID_t timerId,\r\ntmrHw_INTERVAL_t msec\r\n) {\r\nuint32_t scale = 0;\r\nuint32_t count = 0;\r\nif (timerId == 0 || timerId == 1) {\r\nif (msec <= tmrHw_LOW_1_MAX_MILLISEC) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_1;\r\nscale = tmrHw_LOW_1_RESOLUTION_COUNT;\r\n} else if (msec <= tmrHw_LOW_16_MAX_MILLISEC) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_16;\r\nscale = tmrHw_LOW_16_RESOLUTION_COUNT;\r\n} else if (msec <= tmrHw_LOW_256_MAX_MILLISEC) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_256;\r\nscale = tmrHw_LOW_256_RESOLUTION_COUNT;\r\n} else {\r\nreturn 0;\r\n}\r\ncount = msec * scale;\r\npTmrHw[timerId].LoadValue = count;\r\npTmrHw[timerId].BackgroundLoad = count;\r\n} else if (timerId == 2 || timerId == 3) {\r\nif (msec <= tmrHw_HIGH_1_MAX_MILLISEC) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_1;\r\nscale = tmrHw_HIGH_1_RESOLUTION_COUNT;\r\n} else if (msec <= tmrHw_HIGH_16_MAX_MILLISEC) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_16;\r\nscale = tmrHw_HIGH_16_RESOLUTION_COUNT;\r\n} else if (msec <= tmrHw_HIGH_256_MAX_MILLISEC) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_256;\r\nscale = tmrHw_HIGH_256_RESOLUTION_COUNT;\r\n} else {\r\nreturn 0;\r\n}\r\ncount = msec * scale;\r\npTmrHw[timerId].LoadValue = count;\r\npTmrHw[timerId].BackgroundLoad = count;\r\n}\r\nreturn count / scale;\r\n}\r\ntmrHw_RATE_t tmrHw_setPeriodicTimerRate(tmrHw_ID_t timerId,\r\ntmrHw_RATE_t rate\r\n) {\r\nuint32_t resolution = 0;\r\nuint32_t count = 0;\r\nResetTimer(timerId);\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PERIODIC;\r\npTmrHw[timerId].Control &= ~tmrHw_CONTROL_ONESHOT;\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_1;\r\nif (rate && (timerId == 0 || timerId == 1)) {\r\nif (rate > tmrHw_LOW_RESOLUTION_CLOCK) {\r\nreturn 0;\r\n}\r\nresolution = tmrHw_LOW_RESOLUTION_CLOCK;\r\n} else if (rate && (timerId == 2 || timerId == 3)) {\r\nif (rate > tmrHw_HIGH_RESOLUTION_CLOCK) {\r\nreturn 0;\r\n} else {\r\nresolution = tmrHw_HIGH_RESOLUTION_CLOCK;\r\n}\r\n} else {\r\nreturn 0;\r\n}\r\ncount = resolution / rate;\r\npTmrHw[timerId].LoadValue = count;\r\npTmrHw[timerId].BackgroundLoad = count;\r\nreturn resolution / count;\r\n}\r\ntmrHw_INTERVAL_t tmrHw_setPeriodicTimerInterval(tmrHw_ID_t timerId,\r\ntmrHw_INTERVAL_t msec\r\n) {\r\nResetTimer(timerId);\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PERIODIC;\r\npTmrHw[timerId].Control &= ~tmrHw_CONTROL_ONESHOT;\r\nreturn SetTimerPeriod(timerId, msec);\r\n}\r\ntmrHw_INTERVAL_t tmrHw_setOneshotTimerInterval(tmrHw_ID_t timerId,\r\ntmrHw_INTERVAL_t msec\r\n) {\r\nResetTimer(timerId);\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PERIODIC;\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_ONESHOT;\r\nreturn SetTimerPeriod(timerId, msec);\r\n}\r\ntmrHw_RATE_t tmrHw_setFreeRunningTimer(tmrHw_ID_t timerId,\r\nuint32_t divider\r\n) {\r\nuint32_t scale = 0;\r\nResetTimer(timerId);\r\npTmrHw[timerId].Control &= ~tmrHw_CONTROL_PERIODIC;\r\npTmrHw[timerId].Control &= ~tmrHw_CONTROL_ONESHOT;\r\nif (divider >= 64) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_256;\r\nscale = 256;\r\n} else if (divider >= 8) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_16;\r\nscale = 16;\r\n} else {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_PRESCALE_1;\r\nscale = 1;\r\n}\r\nif (timerId == 0 || timerId == 1) {\r\nreturn tmrHw_divide(tmrHw_LOW_RESOLUTION_CLOCK, scale);\r\n} else if (timerId == 2 || timerId == 3) {\r\nreturn tmrHw_divide(tmrHw_HIGH_RESOLUTION_CLOCK, scale);\r\n}\r\nreturn 0;\r\n}\r\nint tmrHw_startTimer(tmrHw_ID_t timerId\r\n) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_TIMER_ENABLE;\r\nreturn 0;\r\n}\r\nint tmrHw_stopTimer(tmrHw_ID_t timerId\r\n) {\r\npTmrHw[timerId].Control &= ~tmrHw_CONTROL_TIMER_ENABLE;\r\nreturn 0;\r\n}\r\nuint32_t tmrHw_GetCurrentCount(tmrHw_ID_t timerId\r\n) {\r\nswitch (pTmrHw[timerId].Control & tmrHw_CONTROL_MODE_MASK) {\r\ncase tmrHw_CONTROL_FREE_RUNNING:\r\nif (pTmrHw[timerId].CurrentValue) {\r\nreturn tmrHw_MAX_COUNT - pTmrHw[timerId].CurrentValue;\r\n}\r\nbreak;\r\ncase tmrHw_CONTROL_PERIODIC:\r\ncase tmrHw_CONTROL_ONESHOT:\r\nreturn pTmrHw[timerId].BackgroundLoad -\r\npTmrHw[timerId].CurrentValue;\r\n}\r\nreturn 0;\r\n}\r\ntmrHw_RATE_t tmrHw_getCountRate(tmrHw_ID_t timerId\r\n) {\r\nuint32_t divider = 0;\r\nswitch (pTmrHw[timerId].Control & tmrHw_CONTROL_PRESCALE_MASK) {\r\ncase tmrHw_CONTROL_PRESCALE_1:\r\ndivider = 1;\r\nbreak;\r\ncase tmrHw_CONTROL_PRESCALE_16:\r\ndivider = 16;\r\nbreak;\r\ncase tmrHw_CONTROL_PRESCALE_256:\r\ndivider = 256;\r\nbreak;\r\ndefault:\r\ntmrHw_ASSERT(0);\r\n}\r\nif (timerId == 0 || timerId == 1) {\r\nreturn tmrHw_divide(tmrHw_LOW_RESOLUTION_CLOCK, divider);\r\n} else {\r\nreturn tmrHw_divide(tmrHw_HIGH_RESOLUTION_CLOCK, divider);\r\n}\r\nreturn 0;\r\n}\r\nvoid tmrHw_enableInterrupt(tmrHw_ID_t timerId\r\n) {\r\npTmrHw[timerId].Control |= tmrHw_CONTROL_INTERRUPT_ENABLE;\r\n}\r\nvoid tmrHw_disableInterrupt(tmrHw_ID_t timerId\r\n) {\r\npTmrHw[timerId].Control &= ~tmrHw_CONTROL_INTERRUPT_ENABLE;\r\n}\r\nvoid tmrHw_clearInterrupt(tmrHw_ID_t timerId\r\n) {\r\npTmrHw[timerId].InterruptClear = 0x1;\r\n}\r\ntmrHw_INTERRUPT_STATUS_e tmrHw_getInterruptStatus(tmrHw_ID_t timerId\r\n) {\r\nif (pTmrHw[timerId].InterruptStatus) {\r\nreturn tmrHw_INTERRUPT_STATUS_SET;\r\n} else {\r\nreturn tmrHw_INTERRUPT_STATUS_UNSET;\r\n}\r\n}\r\ntmrHw_ID_t tmrHw_getInterruptSource(void\r\n) {\r\nint i;\r\nfor (i = 0; i < tmrHw_TIMER_NUM_COUNT; i++) {\r\nif (pTmrHw[i].InterruptStatus) {\r\nreturn i;\r\n}\r\n}\r\nreturn 0xFFFFFFFF;\r\n}\r\nvoid tmrHw_printDebugInfo(tmrHw_ID_t timerId,\r\nint (*fpPrint) (const char *, ...)\r\n) {\r\n(*fpPrint) ("Displaying register contents \n\n");\r\n(*fpPrint) ("Timer %d: Load value 0x%X\n", timerId,\r\npTmrHw[timerId].LoadValue);\r\n(*fpPrint) ("Timer %d: Background load value 0x%X\n", timerId,\r\npTmrHw[timerId].BackgroundLoad);\r\n(*fpPrint) ("Timer %d: Control 0x%X\n", timerId,\r\npTmrHw[timerId].Control);\r\n(*fpPrint) ("Timer %d: Interrupt clear 0x%X\n", timerId,\r\npTmrHw[timerId].InterruptClear);\r\n(*fpPrint) ("Timer %d: Interrupt raw interrupt 0x%X\n", timerId,\r\npTmrHw[timerId].RawInterruptStatus);\r\n(*fpPrint) ("Timer %d: Interrupt status 0x%X\n", timerId,\r\npTmrHw[timerId].InterruptStatus);\r\n}\r\nvoid tmrHw_udelay(tmrHw_ID_t timerId,\r\nunsigned long usecs\r\n) {\r\ntmrHw_RATE_t usec_tick_rate;\r\ntmrHw_COUNT_t start_time;\r\ntmrHw_COUNT_t delta_time;\r\nstart_time = tmrHw_GetCurrentCount(timerId);\r\nusec_tick_rate = tmrHw_divide(tmrHw_getCountRate(timerId), 1000000);\r\ndelta_time = usecs * usec_tick_rate;\r\nwhile (delta_time > (tmrHw_GetCurrentCount(timerId) - start_time))\r\n;\r\n}\r\nstatic int tmrHw_divide(int num, int denom)\r\n{\r\nint r;\r\nint t = 1;\r\nwhile ((denom & 0x40000000) == 0) {\r\ndenom = denom << 1;\r\nt = t << 1;\r\n}\r\nr = 0;\r\ndo {\r\nif ((num - denom) >= 0) {\r\nnum = num - denom;\r\nr = r + t;\r\n}\r\ndenom = denom >> 1;\r\nt = t >> 1;\r\n} while (t != 0);\r\nreturn r;\r\n}
