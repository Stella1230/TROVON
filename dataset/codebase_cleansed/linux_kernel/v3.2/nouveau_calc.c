static void\r\nnv04_calc_arb(struct nv_fifo_info *fifo, struct nv_sim_state *arb)\r\n{\r\nint pagemiss, cas, width, bpp;\r\nint nvclks, mclks, pclks, crtpagemiss;\r\nint found, mclk_extra, mclk_loop, cbs, m1, p1;\r\nint mclk_freq, pclk_freq, nvclk_freq;\r\nint us_m, us_n, us_p, crtc_drain_rate;\r\nint cpm_us, us_crt, clwm;\r\npclk_freq = arb->pclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\npagemiss = arb->mem_page_miss;\r\ncas = arb->mem_latency;\r\nwidth = arb->memory_width >> 6;\r\nbpp = arb->bpp;\r\ncbs = 128;\r\npclks = 2;\r\nnvclks = 10;\r\nmclks = 13 + cas;\r\nmclk_extra = 3;\r\nfound = 0;\r\nwhile (!found) {\r\nfound = 1;\r\nmclk_loop = mclks + mclk_extra;\r\nus_m = mclk_loop * 1000 * 1000 / mclk_freq;\r\nus_n = nvclks * 1000 * 1000 / nvclk_freq;\r\nus_p = nvclks * 1000 * 1000 / pclk_freq;\r\ncrtc_drain_rate = pclk_freq * bpp / 8;\r\ncrtpagemiss = 2;\r\ncrtpagemiss += 1;\r\ncpm_us = crtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\r\nus_crt = cpm_us + us_m + us_n + us_p;\r\nclwm = us_crt * crtc_drain_rate / (1000 * 1000);\r\nclwm++;\r\nm1 = clwm + cbs - 512;\r\np1 = m1 * pclk_freq / mclk_freq;\r\np1 = p1 * bpp / 8;\r\nif ((p1 < m1 && m1 > 0) || clwm > 519) {\r\nfound = !mclk_extra;\r\nmclk_extra--;\r\n}\r\nif (clwm < 384)\r\nclwm = 384;\r\nfifo->lwm = clwm;\r\nfifo->burst = cbs;\r\n}\r\n}\r\nstatic void\r\nnv10_calc_arb(struct nv_fifo_info *fifo, struct nv_sim_state *arb)\r\n{\r\nint fill_rate, drain_rate;\r\nint pclks, nvclks, mclks, xclks;\r\nint pclk_freq, nvclk_freq, mclk_freq;\r\nint fill_lat, extra_lat;\r\nint max_burst_o, max_burst_l;\r\nint fifo_len, min_lwm, max_lwm;\r\nconst int burst_lat = 80;\r\npclk_freq = arb->pclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nfill_rate = mclk_freq * arb->memory_width / 8;\r\ndrain_rate = pclk_freq * arb->bpp / 8;\r\nfifo_len = arb->two_heads ? 1536 : 1024;\r\npclks = 4;\r\nnvclks = 3\r\n+ 2\r\n+ 1\r\n+ 1\r\n+ 1\r\n+ 1;\r\nmclks = 1\r\n+ 1\r\n+ 5\r\n+ 2\r\n+ 2\r\n+ 7;\r\nmclks += (arb->memory_type == 0 ? 2 : 1)\r\n* arb->memory_width / 32;\r\nfill_lat = mclks * 1000 * 1000 / mclk_freq\r\n+ nvclks * 1000 * 1000 / nvclk_freq\r\n+ pclks * 1000 * 1000 / pclk_freq;\r\nxclks = 2 * arb->mem_page_miss + mclks\r\n+ 2 * arb->mem_page_miss\r\n+ (arb->bpp == 32 ? 8 : 4);\r\nextra_lat = xclks * 1000 * 1000 / mclk_freq;\r\nif (arb->two_heads)\r\nextra_lat += fill_lat + extra_lat + burst_lat;\r\nmax_burst_o = (1 + fifo_len - extra_lat * drain_rate / (1000 * 1000))\r\n* (fill_rate / 1000) / ((fill_rate - drain_rate) / 1000);\r\nfifo->burst = min(max_burst_o, 1024);\r\nmax_burst_l = burst_lat * fill_rate / (1000 * 1000);\r\nfifo->burst = min(max_burst_l, fifo->burst);\r\nfifo->burst = rounddown_pow_of_two(fifo->burst);\r\nmin_lwm = (fill_lat + extra_lat) * drain_rate / (1000 * 1000) + 1;\r\nmax_lwm = fifo_len - fifo->burst\r\n+ fill_lat * drain_rate / (1000 * 1000)\r\n+ fifo->burst * drain_rate / fill_rate;\r\nfifo->lwm = min_lwm + 10 * (max_lwm - min_lwm) / 100;\r\n}\r\nstatic void\r\nnv04_update_arb(struct drm_device *dev, int VClk, int bpp,\r\nint *burst, int *lwm)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv_fifo_info fifo_data;\r\nstruct nv_sim_state sim_data;\r\nint MClk = nouveau_hw_get_clock(dev, PLL_MEMORY);\r\nint NVClk = nouveau_hw_get_clock(dev, PLL_CORE);\r\nuint32_t cfg1 = nvReadFB(dev, NV04_PFB_CFG1);\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nsim_data.bpp = bpp;\r\nsim_data.two_heads = nv_two_heads(dev);\r\nif ((dev->pci_device & 0xffff) == 0x01a0 ||\r\n(dev->pci_device & 0xffff) == 0x01f0 ) {\r\nuint32_t type;\r\npci_read_config_dword(pci_get_bus_and_slot(0, 1), 0x7c, &type);\r\nsim_data.memory_type = (type >> 12) & 1;\r\nsim_data.memory_width = 64;\r\nsim_data.mem_latency = 3;\r\nsim_data.mem_page_miss = 10;\r\n} else {\r\nsim_data.memory_type = nvReadFB(dev, NV04_PFB_CFG0) & 0x1;\r\nsim_data.memory_width = (nvReadEXTDEV(dev, NV_PEXTDEV_BOOT_0) & 0x10) ? 128 : 64;\r\nsim_data.mem_latency = cfg1 & 0xf;\r\nsim_data.mem_page_miss = ((cfg1 >> 4) & 0xf) + ((cfg1 >> 31) & 0x1);\r\n}\r\nif (dev_priv->card_type == NV_04)\r\nnv04_calc_arb(&fifo_data, &sim_data);\r\nelse\r\nnv10_calc_arb(&fifo_data, &sim_data);\r\n*burst = ilog2(fifo_data.burst >> 4);\r\n*lwm = fifo_data.lwm >> 3;\r\n}\r\nstatic void\r\nnv20_update_arb(int *burst, int *lwm)\r\n{\r\nunsigned int fifo_size, burst_size, graphics_lwm;\r\nfifo_size = 2048;\r\nburst_size = 512;\r\ngraphics_lwm = fifo_size - burst_size;\r\n*burst = ilog2(burst_size >> 5);\r\n*lwm = graphics_lwm >> 3;\r\n}\r\nvoid\r\nnouveau_calc_arb(struct drm_device *dev, int vclk, int bpp, int *burst, int *lwm)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->card_type < NV_20)\r\nnv04_update_arb(dev, vclk, bpp, burst, lwm);\r\nelse if ((dev->pci_device & 0xfff0) == 0x0240 ||\r\n(dev->pci_device & 0xfff0) == 0x03d0 ) {\r\n*burst = 128;\r\n*lwm = 0x0480;\r\n} else\r\nnv20_update_arb(burst, lwm);\r\n}\r\nstatic int\r\ngetMNP_single(struct drm_device *dev, struct pll_lims *pll_lim, int clk,\r\nstruct nouveau_pll_vals *bestpv)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint cv = dev_priv->vbios.chip_version;\r\nint minvco = pll_lim->vco1.minfreq, maxvco = pll_lim->vco1.maxfreq;\r\nint minM = pll_lim->vco1.min_m, maxM = pll_lim->vco1.max_m;\r\nint minN = pll_lim->vco1.min_n, maxN = pll_lim->vco1.max_n;\r\nint minU = pll_lim->vco1.min_inputfreq;\r\nint maxU = pll_lim->vco1.max_inputfreq;\r\nint minP = pll_lim->max_p ? pll_lim->min_p : 0;\r\nint maxP = pll_lim->max_p ? pll_lim->max_p : pll_lim->max_usable_log2p;\r\nint crystal = pll_lim->refclk;\r\nint M, N, thisP, P;\r\nint clkP, calcclk;\r\nint delta, bestdelta = INT_MAX;\r\nint bestclk = 0;\r\nif (dev_priv->card_type < NV_50) {\r\nif (cv < 0x17 || cv == 0x1a || cv == 0x20) {\r\nif (clk > 250000)\r\nmaxM = 6;\r\nif (clk > 340000)\r\nmaxM = 2;\r\n} else if (cv < 0x40) {\r\nif (clk > 150000)\r\nmaxM = 6;\r\nif (clk > 200000)\r\nmaxM = 4;\r\nif (clk > 340000)\r\nmaxM = 2;\r\n}\r\n}\r\nP = pll_lim->max_p ? maxP : (1 << maxP);\r\nif ((clk * P) < minvco) {\r\nminvco = clk * maxP;\r\nmaxvco = minvco * 2;\r\n}\r\nif (clk + clk/200 > maxvco)\r\nmaxvco = clk + clk/200;\r\nfor (thisP = minP; thisP <= maxP; thisP++) {\r\nP = pll_lim->max_p ? thisP : (1 << thisP);\r\nclkP = clk * P;\r\nif (clkP < minvco)\r\ncontinue;\r\nif (clkP > maxvco)\r\nreturn bestclk;\r\nfor (M = minM; M <= maxM; M++) {\r\nif (crystal/M < minU)\r\nreturn bestclk;\r\nif (crystal/M > maxU)\r\ncontinue;\r\nN = (clkP * M + crystal/2) / crystal;\r\nif (N < minN)\r\ncontinue;\r\nif (N > maxN)\r\nbreak;\r\ncalcclk = ((N * crystal + P/2) / P + M/2) / M;\r\ndelta = abs(calcclk - clk);\r\nif (delta < bestdelta) {\r\nbestdelta = delta;\r\nbestclk = calcclk;\r\nbestpv->N1 = N;\r\nbestpv->M1 = M;\r\nbestpv->log2P = thisP;\r\nif (delta == 0)\r\nreturn bestclk;\r\n}\r\n}\r\n}\r\nreturn bestclk;\r\n}\r\nstatic int\r\ngetMNP_double(struct drm_device *dev, struct pll_lims *pll_lim, int clk,\r\nstruct nouveau_pll_vals *bestpv)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint chip_version = dev_priv->vbios.chip_version;\r\nint minvco1 = pll_lim->vco1.minfreq, maxvco1 = pll_lim->vco1.maxfreq;\r\nint minvco2 = pll_lim->vco2.minfreq, maxvco2 = pll_lim->vco2.maxfreq;\r\nint minU1 = pll_lim->vco1.min_inputfreq, minU2 = pll_lim->vco2.min_inputfreq;\r\nint maxU1 = pll_lim->vco1.max_inputfreq, maxU2 = pll_lim->vco2.max_inputfreq;\r\nint minM1 = pll_lim->vco1.min_m, maxM1 = pll_lim->vco1.max_m;\r\nint minN1 = pll_lim->vco1.min_n, maxN1 = pll_lim->vco1.max_n;\r\nint minM2 = pll_lim->vco2.min_m, maxM2 = pll_lim->vco2.max_m;\r\nint minN2 = pll_lim->vco2.min_n, maxN2 = pll_lim->vco2.max_n;\r\nint maxlog2P = pll_lim->max_usable_log2p;\r\nint crystal = pll_lim->refclk;\r\nbool fixedgain2 = (minM2 == maxM2 && minN2 == maxN2);\r\nint M1, N1, M2, N2, log2P;\r\nint clkP, calcclk1, calcclk2, calcclkout;\r\nint delta, bestdelta = INT_MAX;\r\nint bestclk = 0;\r\nint vco2 = (maxvco2 - maxvco2/200) / 2;\r\nfor (log2P = 0; clk && log2P < maxlog2P && clk <= (vco2 >> log2P); log2P++)\r\n;\r\nclkP = clk << log2P;\r\nif (maxvco2 < clk + clk/200)\r\nmaxvco2 = clk + clk/200;\r\nfor (M1 = minM1; M1 <= maxM1; M1++) {\r\nif (crystal/M1 < minU1)\r\nreturn bestclk;\r\nif (crystal/M1 > maxU1)\r\ncontinue;\r\nfor (N1 = minN1; N1 <= maxN1; N1++) {\r\ncalcclk1 = crystal * N1 / M1;\r\nif (calcclk1 < minvco1)\r\ncontinue;\r\nif (calcclk1 > maxvco1)\r\nbreak;\r\nfor (M2 = minM2; M2 <= maxM2; M2++) {\r\nif (calcclk1/M2 < minU2)\r\nbreak;\r\nif (calcclk1/M2 > maxU2)\r\ncontinue;\r\nN2 = (clkP * M2 + calcclk1/2) / calcclk1;\r\nif (N2 < minN2)\r\ncontinue;\r\nif (N2 > maxN2)\r\nbreak;\r\nif (!fixedgain2) {\r\nif (chip_version < 0x60)\r\nif (N2/M2 < 4 || N2/M2 > 10)\r\ncontinue;\r\ncalcclk2 = calcclk1 * N2 / M2;\r\nif (calcclk2 < minvco2)\r\nbreak;\r\nif (calcclk2 > maxvco2)\r\ncontinue;\r\n} else\r\ncalcclk2 = calcclk1;\r\ncalcclkout = calcclk2 >> log2P;\r\ndelta = abs(calcclkout - clk);\r\nif (delta < bestdelta) {\r\nbestdelta = delta;\r\nbestclk = calcclkout;\r\nbestpv->N1 = N1;\r\nbestpv->M1 = M1;\r\nbestpv->N2 = N2;\r\nbestpv->M2 = M2;\r\nbestpv->log2P = log2P;\r\nif (delta == 0)\r\nreturn bestclk;\r\n}\r\n}\r\n}\r\n}\r\nreturn bestclk;\r\n}\r\nint\r\nnouveau_calc_pll_mnp(struct drm_device *dev, struct pll_lims *pll_lim, int clk,\r\nstruct nouveau_pll_vals *pv)\r\n{\r\nint outclk;\r\nif (!pll_lim->vco2.maxfreq)\r\noutclk = getMNP_single(dev, pll_lim, clk, pv);\r\nelse\r\noutclk = getMNP_double(dev, pll_lim, clk, pv);\r\nif (!outclk)\r\nNV_ERROR(dev, "Could not find a compatible set of PLL values\n");\r\nreturn outclk;\r\n}
