static inline __u64 readq(const volatile void __iomem *addr)\r\n{\r\nconst volatile u32 __iomem *p = addr;\r\nu32 low, high;\r\nlow = readl(p);\r\nhigh = readl(p + 1);\r\nreturn low + ((u64)high << 32);\r\n}\r\nstatic int how_many_channels(struct pci_dev *pdev)\r\n{\r\nunsigned char capid0_8b;\r\npci_read_config_byte(pdev, I3200_CAPID0 + 8, &capid0_8b);\r\nif (capid0_8b & 0x20) {\r\ndebugf0("In single channel mode.\n");\r\nreturn 1;\r\n} else {\r\ndebugf0("In dual channel mode.\n");\r\nreturn 2;\r\n}\r\n}\r\nstatic unsigned long eccerrlog_syndrome(u64 log)\r\n{\r\nreturn (log & I3200_ECCERRLOG_SYNDROME_BITS) >>\r\nI3200_ECCERRLOG_SYNDROME_SHIFT;\r\n}\r\nstatic int eccerrlog_row(int channel, u64 log)\r\n{\r\nu64 rank = ((log & I3200_ECCERRLOG_RANK_BITS) >>\r\nI3200_ECCERRLOG_RANK_SHIFT);\r\nreturn rank | (channel * I3200_RANKS_PER_CHANNEL);\r\n}\r\nstatic void i3200_clear_error_info(struct mem_ctl_info *mci)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->dev);\r\npci_write_bits16(pdev, I3200_ERRSTS, I3200_ERRSTS_BITS,\r\nI3200_ERRSTS_BITS);\r\n}\r\nstatic void i3200_get_and_clear_error_info(struct mem_ctl_info *mci,\r\nstruct i3200_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct i3200_priv *priv = mci->pvt_info;\r\nvoid __iomem *window = priv->window;\r\npdev = to_pci_dev(mci->dev);\r\npci_read_config_word(pdev, I3200_ERRSTS, &info->errsts);\r\nif (!(info->errsts & I3200_ERRSTS_BITS))\r\nreturn;\r\ninfo->eccerrlog[0] = readq(window + I3200_C0ECCERRLOG);\r\nif (nr_channels == 2)\r\ninfo->eccerrlog[1] = readq(window + I3200_C1ECCERRLOG);\r\npci_read_config_word(pdev, I3200_ERRSTS, &info->errsts2);\r\nif ((info->errsts ^ info->errsts2) & I3200_ERRSTS_BITS) {\r\ninfo->eccerrlog[0] = readq(window + I3200_C0ECCERRLOG);\r\nif (nr_channels == 2)\r\ninfo->eccerrlog[1] = readq(window + I3200_C1ECCERRLOG);\r\n}\r\ni3200_clear_error_info(mci);\r\n}\r\nstatic void i3200_process_error_info(struct mem_ctl_info *mci,\r\nstruct i3200_error_info *info)\r\n{\r\nint channel;\r\nu64 log;\r\nif (!(info->errsts & I3200_ERRSTS_BITS))\r\nreturn;\r\nif ((info->errsts ^ info->errsts2) & I3200_ERRSTS_BITS) {\r\nedac_mc_handle_ce_no_info(mci, "UE overwrote CE");\r\ninfo->errsts = info->errsts2;\r\n}\r\nfor (channel = 0; channel < nr_channels; channel++) {\r\nlog = info->eccerrlog[channel];\r\nif (log & I3200_ECCERRLOG_UE) {\r\nedac_mc_handle_ue(mci, 0, 0,\r\neccerrlog_row(channel, log),\r\n"i3200 UE");\r\n} else if (log & I3200_ECCERRLOG_CE) {\r\nedac_mc_handle_ce(mci, 0, 0,\r\neccerrlog_syndrome(log),\r\neccerrlog_row(channel, log), 0,\r\n"i3200 CE");\r\n}\r\n}\r\n}\r\nstatic void i3200_check(struct mem_ctl_info *mci)\r\n{\r\nstruct i3200_error_info info;\r\ndebugf1("MC%d: %s()\n", mci->mc_idx, __func__);\r\ni3200_get_and_clear_error_info(mci, &info);\r\ni3200_process_error_info(mci, &info);\r\n}\r\nvoid __iomem *i3200_map_mchbar(struct pci_dev *pdev)\r\n{\r\nunion {\r\nu64 mchbar;\r\nstruct {\r\nu32 mchbar_low;\r\nu32 mchbar_high;\r\n};\r\n} u;\r\nvoid __iomem *window;\r\npci_read_config_dword(pdev, I3200_MCHBAR_LOW, &u.mchbar_low);\r\npci_read_config_dword(pdev, I3200_MCHBAR_HIGH, &u.mchbar_high);\r\nu.mchbar &= I3200_MCHBAR_MASK;\r\nif (u.mchbar != (resource_size_t)u.mchbar) {\r\nprintk(KERN_ERR\r\n"i3200: mmio space beyond accessible range (0x%llx)\n",\r\n(unsigned long long)u.mchbar);\r\nreturn NULL;\r\n}\r\nwindow = ioremap_nocache(u.mchbar, I3200_MMR_WINDOW_SIZE);\r\nif (!window)\r\nprintk(KERN_ERR "i3200: cannot map mmio space at 0x%llx\n",\r\n(unsigned long long)u.mchbar);\r\nreturn window;\r\n}\r\nstatic void i3200_get_drbs(void __iomem *window,\r\nu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL])\r\n{\r\nint i;\r\nfor (i = 0; i < I3200_RANKS_PER_CHANNEL; i++) {\r\ndrbs[0][i] = readw(window + I3200_C0DRB + 2*i) & I3200_DRB_MASK;\r\ndrbs[1][i] = readw(window + I3200_C1DRB + 2*i) & I3200_DRB_MASK;\r\n}\r\n}\r\nstatic bool i3200_is_stacked(struct pci_dev *pdev,\r\nu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL])\r\n{\r\nu16 tom;\r\npci_read_config_word(pdev, I3200_TOM, &tom);\r\ntom &= I3200_TOM_MASK;\r\nreturn drbs[I3200_CHANNELS - 1][I3200_RANKS_PER_CHANNEL - 1] == tom;\r\n}\r\nstatic unsigned long drb_to_nr_pages(\r\nu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL], bool stacked,\r\nint channel, int rank)\r\n{\r\nint n;\r\nn = drbs[channel][rank];\r\nif (rank > 0)\r\nn -= drbs[channel][rank - 1];\r\nif (stacked && (channel == 1) &&\r\ndrbs[channel][rank] == drbs[channel][I3200_RANKS_PER_CHANNEL - 1])\r\nn -= drbs[0][I3200_RANKS_PER_CHANNEL - 1];\r\nn <<= (I3200_DRB_SHIFT - PAGE_SHIFT);\r\nreturn n;\r\n}\r\nstatic int i3200_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint rc;\r\nint i;\r\nstruct mem_ctl_info *mci = NULL;\r\nunsigned long last_page;\r\nu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL];\r\nbool stacked;\r\nvoid __iomem *window;\r\nstruct i3200_priv *priv;\r\ndebugf0("MC: %s()\n", __func__);\r\nwindow = i3200_map_mchbar(pdev);\r\nif (!window)\r\nreturn -ENODEV;\r\ni3200_get_drbs(window, drbs);\r\nnr_channels = how_many_channels(pdev);\r\nmci = edac_mc_alloc(sizeof(struct i3200_priv), I3200_RANKS,\r\nnr_channels, 0);\r\nif (!mci)\r\nreturn -ENOMEM;\r\ndebugf3("MC: %s(): init mci\n", __func__);\r\nmci->dev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = I3200_REVISION;\r\nmci->ctl_name = i3200_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = i3200_check;\r\nmci->ctl_page_to_phys = NULL;\r\npriv = mci->pvt_info;\r\npriv->window = window;\r\nstacked = i3200_is_stacked(pdev, drbs);\r\nlast_page = -1UL;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nunsigned long nr_pages;\r\nstruct csrow_info *csrow = &mci->csrows[i];\r\nnr_pages = drb_to_nr_pages(drbs, stacked,\r\ni / I3200_RANKS_PER_CHANNEL,\r\ni % I3200_RANKS_PER_CHANNEL);\r\nif (nr_pages == 0) {\r\ncsrow->mtype = MEM_EMPTY;\r\ncontinue;\r\n}\r\ncsrow->first_page = last_page + 1;\r\nlast_page += nr_pages;\r\ncsrow->last_page = last_page;\r\ncsrow->nr_pages = nr_pages;\r\ncsrow->grain = nr_pages << PAGE_SHIFT;\r\ncsrow->mtype = MEM_DDR2;\r\ncsrow->dtype = DEV_UNKNOWN;\r\ncsrow->edac_mode = EDAC_UNKNOWN;\r\n}\r\ni3200_clear_error_info(mci);\r\nrc = -ENODEV;\r\nif (edac_mc_add_mc(mci)) {\r\ndebugf3("MC: %s(): failed edac_mc_add_mc()\n", __func__);\r\ngoto fail;\r\n}\r\ndebugf3("MC: %s(): success\n", __func__);\r\nreturn 0;\r\nfail:\r\niounmap(window);\r\nif (mci)\r\nedac_mc_free(mci);\r\nreturn rc;\r\n}\r\nstatic int __devinit i3200_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rc;\r\ndebugf0("MC: %s()\n", __func__);\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nrc = i3200_probe1(pdev, ent->driver_data);\r\nif (!mci_pdev)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void __devexit i3200_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i3200_priv *priv;\r\ndebugf0("%s()\n", __func__);\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\npriv = mci->pvt_info;\r\niounmap(priv->window);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i3200_init(void)\r\n{\r\nint pci_rc;\r\ndebugf3("MC: %s()\n", __func__);\r\nopstate_init();\r\npci_rc = pci_register_driver(&i3200_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (!mci_pdev) {\r\ni3200_registered = 0;\r\nmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_3200_HB, NULL);\r\nif (!mci_pdev) {\r\ndebugf0("i3200 pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = i3200_init_one(mci_pdev, i3200_pci_tbl);\r\nif (pci_rc < 0) {\r\ndebugf0("i3200 init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&i3200_driver);\r\nfail0:\r\nif (mci_pdev)\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit i3200_exit(void)\r\n{\r\ndebugf3("MC: %s()\n", __func__);\r\npci_unregister_driver(&i3200_driver);\r\nif (!i3200_registered) {\r\ni3200_remove_one(mci_pdev);\r\npci_dev_put(mci_pdev);\r\n}\r\n}
