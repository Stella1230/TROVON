static int samsung_keypad_is_s5pv210(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nenum samsung_keypad_type type =\r\nplatform_get_device_id(pdev)->driver_data;\r\nreturn type == KEYPAD_TYPE_S5PV210;\r\n}\r\nstatic void samsung_keypad_scan(struct samsung_keypad *keypad,\r\nunsigned int *row_state)\r\n{\r\nstruct device *dev = keypad->input_dev->dev.parent;\r\nunsigned int col;\r\nunsigned int val;\r\nfor (col = 0; col < keypad->cols; col++) {\r\nif (samsung_keypad_is_s5pv210(dev)) {\r\nval = S5PV210_KEYIFCOLEN_MASK;\r\nval &= ~(1 << col) << 8;\r\n} else {\r\nval = SAMSUNG_KEYIFCOL_MASK;\r\nval &= ~(1 << col);\r\n}\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCOL);\r\nmdelay(1);\r\nval = readl(keypad->base + SAMSUNG_KEYIFROW);\r\nrow_state[col] = ~val & ((1 << keypad->rows) - 1);\r\n}\r\nwritel(0, keypad->base + SAMSUNG_KEYIFCOL);\r\n}\r\nstatic bool samsung_keypad_report(struct samsung_keypad *keypad,\r\nunsigned int *row_state)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nunsigned int changed;\r\nunsigned int pressed;\r\nunsigned int key_down = 0;\r\nunsigned int val;\r\nunsigned int col, row;\r\nfor (col = 0; col < keypad->cols; col++) {\r\nchanged = row_state[col] ^ keypad->row_state[col];\r\nkey_down |= row_state[col];\r\nif (!changed)\r\ncontinue;\r\nfor (row = 0; row < keypad->rows; row++) {\r\nif (!(changed & (1 << row)))\r\ncontinue;\r\npressed = row_state[col] & (1 << row);\r\ndev_dbg(&keypad->input_dev->dev,\r\n"key %s, row: %d, col: %d\n",\r\npressed ? "pressed" : "released", row, col);\r\nval = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, val);\r\ninput_report_key(input_dev,\r\nkeypad->keycodes[val], pressed);\r\n}\r\ninput_sync(keypad->input_dev);\r\n}\r\nmemcpy(keypad->row_state, row_state, sizeof(keypad->row_state));\r\nreturn key_down;\r\n}\r\nstatic irqreturn_t samsung_keypad_irq(int irq, void *dev_id)\r\n{\r\nstruct samsung_keypad *keypad = dev_id;\r\nunsigned int row_state[SAMSUNG_MAX_COLS];\r\nunsigned int val;\r\nbool key_down;\r\ndo {\r\nval = readl(keypad->base + SAMSUNG_KEYIFSTSCLR);\r\nwritel(~0x0, keypad->base + SAMSUNG_KEYIFSTSCLR);\r\nsamsung_keypad_scan(keypad, row_state);\r\nkey_down = samsung_keypad_report(keypad, row_state);\r\nif (key_down)\r\nwait_event_timeout(keypad->wait, keypad->stopped,\r\nmsecs_to_jiffies(50));\r\n} while (key_down && !keypad->stopped);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void samsung_keypad_start(struct samsung_keypad *keypad)\r\n{\r\nunsigned int val;\r\nkeypad->stopped = false;\r\nclk_enable(keypad->clk);\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nval |= SAMSUNG_KEYIFCON_INT_F_EN | SAMSUNG_KEYIFCON_INT_R_EN;\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nwritel(0, keypad->base + SAMSUNG_KEYIFCOL);\r\n}\r\nstatic void samsung_keypad_stop(struct samsung_keypad *keypad)\r\n{\r\nunsigned int val;\r\nkeypad->stopped = true;\r\nwake_up(&keypad->wait);\r\ndisable_irq(keypad->irq);\r\nwritel(~0x0, keypad->base + SAMSUNG_KEYIFSTSCLR);\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nval &= ~(SAMSUNG_KEYIFCON_INT_F_EN | SAMSUNG_KEYIFCON_INT_R_EN);\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nclk_disable(keypad->clk);\r\nenable_irq(keypad->irq);\r\n}\r\nstatic int samsung_keypad_open(struct input_dev *input_dev)\r\n{\r\nstruct samsung_keypad *keypad = input_get_drvdata(input_dev);\r\nsamsung_keypad_start(keypad);\r\nreturn 0;\r\n}\r\nstatic void samsung_keypad_close(struct input_dev *input_dev)\r\n{\r\nstruct samsung_keypad *keypad = input_get_drvdata(input_dev);\r\nsamsung_keypad_stop(keypad);\r\n}\r\nstatic int __devinit samsung_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct samsung_keypad_platdata *pdata;\r\nconst struct matrix_keymap_data *keymap_data;\r\nstruct samsung_keypad *keypad;\r\nstruct resource *res;\r\nstruct input_dev *input_dev;\r\nunsigned int row_shift;\r\nunsigned int keymap_size;\r\nint error;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nkeymap_data = pdata->keymap_data;\r\nif (!keymap_data) {\r\ndev_err(&pdev->dev, "no keymap data defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->rows || pdata->rows > SAMSUNG_MAX_ROWS)\r\nreturn -EINVAL;\r\nif (!pdata->cols || pdata->cols > SAMSUNG_MAX_COLS)\r\nreturn -EINVAL;\r\nif (pdata->cfg_gpio)\r\npdata->cfg_gpio(pdata->rows, pdata->cols);\r\nrow_shift = get_count_order(pdata->cols);\r\nkeymap_size = (pdata->rows << row_shift) * sizeof(keypad->keycodes[0]);\r\nkeypad = kzalloc(sizeof(*keypad) + keymap_size, GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!keypad || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerror = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nkeypad->base = ioremap(res->start, resource_size(res));\r\nif (!keypad->base) {\r\nerror = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nkeypad->clk = clk_get(&pdev->dev, "keypad");\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "failed to get keypad clk\n");\r\nerror = PTR_ERR(keypad->clk);\r\ngoto err_unmap_base;\r\n}\r\nkeypad->input_dev = input_dev;\r\nkeypad->row_shift = row_shift;\r\nkeypad->rows = pdata->rows;\r\nkeypad->cols = pdata->cols;\r\ninit_waitqueue_head(&keypad->wait);\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_set_drvdata(input_dev, keypad);\r\ninput_dev->open = samsung_keypad_open;\r\ninput_dev->close = samsung_keypad_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY);\r\nif (!pdata->no_autorepeat)\r\ninput_dev->evbit[0] |= BIT_MASK(EV_REP);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_dev->keycode = keypad->keycodes;\r\ninput_dev->keycodesize = sizeof(keypad->keycodes[0]);\r\ninput_dev->keycodemax = pdata->rows << row_shift;\r\nmatrix_keypad_build_keymap(keymap_data, row_shift,\r\ninput_dev->keycode, input_dev->keybit);\r\nkeypad->irq = platform_get_irq(pdev, 0);\r\nif (keypad->irq < 0) {\r\nerror = keypad->irq;\r\ngoto err_put_clk;\r\n}\r\nerror = request_threaded_irq(keypad->irq, NULL, samsung_keypad_irq,\r\nIRQF_ONESHOT, dev_name(&pdev->dev), keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register keypad interrupt\n");\r\ngoto err_put_clk;\r\n}\r\nerror = input_register_device(keypad->input_dev);\r\nif (error)\r\ngoto err_free_irq;\r\ndevice_init_wakeup(&pdev->dev, pdata->wakeup);\r\nplatform_set_drvdata(pdev, keypad);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(keypad->irq, keypad);\r\nerr_put_clk:\r\nclk_put(keypad->clk);\r\nerr_unmap_base:\r\niounmap(keypad->base);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(keypad);\r\nreturn error;\r\n}\r\nstatic int __devexit samsung_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\ninput_unregister_device(keypad->input_dev);\r\nfree_irq(keypad->irq, keypad);\r\nclk_put(keypad->clk);\r\niounmap(keypad->base);\r\nkfree(keypad);\r\nreturn 0;\r\n}\r\nstatic void samsung_keypad_toggle_wakeup(struct samsung_keypad *keypad,\r\nbool enable)\r\n{\r\nstruct device *dev = keypad->input_dev->dev.parent;\r\nunsigned int val;\r\nclk_enable(keypad->clk);\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nif (enable) {\r\nval |= SAMSUNG_KEYIFCON_WAKEUPEN;\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(keypad->irq);\r\n} else {\r\nval &= ~SAMSUNG_KEYIFCON_WAKEUPEN;\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(keypad->irq);\r\n}\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nclk_disable(keypad->clk);\r\n}\r\nstatic int samsung_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nsamsung_keypad_stop(keypad);\r\nsamsung_keypad_toggle_wakeup(keypad, true);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int samsung_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nsamsung_keypad_toggle_wakeup(keypad, false);\r\nif (input_dev->users)\r\nsamsung_keypad_start(keypad);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int __init samsung_keypad_init(void)\r\n{\r\nreturn platform_driver_register(&samsung_keypad_driver);\r\n}\r\nstatic void __exit samsung_keypad_exit(void)\r\n{\r\nplatform_driver_unregister(&samsung_keypad_driver);\r\n}
