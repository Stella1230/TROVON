static struct alauda_card *get_card(u8 id)\r\n{\r\nstruct alauda_card *card;\r\nfor (card = alauda_card_ids; card->id; card++)\r\nif (card->id == id)\r\nreturn card;\r\nreturn NULL;\r\n}\r\nstatic void alauda_delete(struct kref *kref)\r\n{\r\nstruct alauda *al = container_of(kref, struct alauda, kref);\r\nif (al->mtd) {\r\nmtd_device_unregister(al->mtd);\r\nkfree(al->mtd);\r\n}\r\nusb_put_dev(al->dev);\r\nkfree(al);\r\n}\r\nstatic int alauda_get_media_status(struct alauda *al, void *buf)\r\n{\r\nint ret;\r\nmutex_lock(&al->card_mutex);\r\nret = usb_control_msg(al->dev, usb_rcvctrlpipe(al->dev, 0),\r\nALAUDA_GET_XD_MEDIA_STATUS, 0xc0, 0, 1, buf, 2, HZ);\r\nmutex_unlock(&al->card_mutex);\r\nreturn ret;\r\n}\r\nstatic int alauda_ack_media(struct alauda *al)\r\n{\r\nint ret;\r\nmutex_lock(&al->card_mutex);\r\nret = usb_control_msg(al->dev, usb_sndctrlpipe(al->dev, 0),\r\nALAUDA_ACK_XD_MEDIA_CHANGE, 0x40, 0, 1, NULL, 0, HZ);\r\nmutex_unlock(&al->card_mutex);\r\nreturn ret;\r\n}\r\nstatic int alauda_get_media_signatures(struct alauda *al, void *buf)\r\n{\r\nint ret;\r\nmutex_lock(&al->card_mutex);\r\nret = usb_control_msg(al->dev, usb_rcvctrlpipe(al->dev, 0),\r\nALAUDA_GET_XD_MEDIA_SIG, 0xc0, 0, 0, buf, 4, HZ);\r\nmutex_unlock(&al->card_mutex);\r\nreturn ret;\r\n}\r\nstatic void alauda_reset(struct alauda *al)\r\n{\r\nu8 command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_RESET_MEDIA, 0, 0,\r\n0, 0, 0, 0, al->port\r\n};\r\nmutex_lock(&al->card_mutex);\r\nusb_bulk_msg(al->dev, al->bulk_out, command, 9, NULL, HZ);\r\nmutex_unlock(&al->card_mutex);\r\n}\r\nstatic void correct_data(void *buf, void *read_ecc,\r\nint *corrected, int *uncorrected)\r\n{\r\nu8 calc_ecc[3];\r\nint err;\r\nnand_calculate_ecc(NULL, buf, calc_ecc);\r\nerr = nand_correct_data(NULL, buf, read_ecc, calc_ecc);\r\nif (err) {\r\nif (err > 0)\r\n(*corrected)++;\r\nelse\r\n(*uncorrected)++;\r\n}\r\n}\r\nstatic void alauda_complete(struct urb *urb)\r\n{\r\nstruct completion *comp = urb->context;\r\nif (comp)\r\ncomplete(comp);\r\n}\r\nstatic int __alauda_read_page(struct mtd_info *mtd, loff_t from, void *buf,\r\nvoid *oob)\r\n{\r\nstruct alauda_sg_request sg;\r\nstruct alauda *al = mtd->priv;\r\nu32 pba = from >> al->card->blockshift;\r\nu32 page = (from >> al->card->pageshift) & al->pagemask;\r\nu8 command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_READ_PAGE, PBA_HI(pba),\r\nPBA_ZONE(pba), 0, PBA_LO(pba) + page, 1, 0, al->port\r\n};\r\nint i, err;\r\nfor (i=0; i<3; i++)\r\nsg.urb[i] = NULL;\r\nerr = -ENOMEM;\r\nfor (i=0; i<3; i++) {\r\nsg.urb[i] = usb_alloc_urb(0, GFP_NOIO);\r\nif (!sg.urb[i])\r\ngoto out;\r\n}\r\ninit_completion(&sg.comp);\r\nusb_fill_bulk_urb(sg.urb[0], al->dev, al->bulk_out, command, 9,\r\nalauda_complete, NULL);\r\nusb_fill_bulk_urb(sg.urb[1], al->dev, al->bulk_in, buf, mtd->writesize,\r\nalauda_complete, NULL);\r\nusb_fill_bulk_urb(sg.urb[2], al->dev, al->bulk_in, oob, 16,\r\nalauda_complete, &sg.comp);\r\nmutex_lock(&al->card_mutex);\r\nfor (i=0; i<3; i++) {\r\nerr = usb_submit_urb(sg.urb[i], GFP_NOIO);\r\nif (err)\r\ngoto cancel;\r\n}\r\nif (!wait_for_completion_timeout(&sg.comp, TIMEOUT)) {\r\nerr = -ETIMEDOUT;\r\ncancel:\r\nfor (i=0; i<3; i++) {\r\nusb_kill_urb(sg.urb[i]);\r\n}\r\n}\r\nmutex_unlock(&al->card_mutex);\r\nout:\r\nusb_free_urb(sg.urb[0]);\r\nusb_free_urb(sg.urb[1]);\r\nusb_free_urb(sg.urb[2]);\r\nreturn err;\r\n}\r\nstatic int alauda_read_page(struct mtd_info *mtd, loff_t from,\r\nvoid *buf, u8 *oob, int *corrected, int *uncorrected)\r\n{\r\nint err;\r\nerr = __alauda_read_page(mtd, from, buf, oob);\r\nif (err)\r\nreturn err;\r\ncorrect_data(buf, oob+13, corrected, uncorrected);\r\ncorrect_data(buf+256, oob+8, corrected, uncorrected);\r\nreturn 0;\r\n}\r\nstatic int alauda_write_page(struct mtd_info *mtd, loff_t to, void *buf,\r\nvoid *oob)\r\n{\r\nstruct alauda_sg_request sg;\r\nstruct alauda *al = mtd->priv;\r\nu32 pba = to >> al->card->blockshift;\r\nu32 page = (to >> al->card->pageshift) & al->pagemask;\r\nu8 command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_WRITE_PAGE, PBA_HI(pba),\r\nPBA_ZONE(pba), 0, PBA_LO(pba) + page, 32, 0, al->port\r\n};\r\nint i, err;\r\nfor (i=0; i<3; i++)\r\nsg.urb[i] = NULL;\r\nerr = -ENOMEM;\r\nfor (i=0; i<3; i++) {\r\nsg.urb[i] = usb_alloc_urb(0, GFP_NOIO);\r\nif (!sg.urb[i])\r\ngoto out;\r\n}\r\ninit_completion(&sg.comp);\r\nusb_fill_bulk_urb(sg.urb[0], al->dev, al->bulk_out, command, 9,\r\nalauda_complete, NULL);\r\nusb_fill_bulk_urb(sg.urb[1], al->dev, al->write_out, buf,mtd->writesize,\r\nalauda_complete, NULL);\r\nusb_fill_bulk_urb(sg.urb[2], al->dev, al->write_out, oob, 16,\r\nalauda_complete, &sg.comp);\r\nmutex_lock(&al->card_mutex);\r\nfor (i=0; i<3; i++) {\r\nerr = usb_submit_urb(sg.urb[i], GFP_NOIO);\r\nif (err)\r\ngoto cancel;\r\n}\r\nif (!wait_for_completion_timeout(&sg.comp, TIMEOUT)) {\r\nerr = -ETIMEDOUT;\r\ncancel:\r\nfor (i=0; i<3; i++) {\r\nusb_kill_urb(sg.urb[i]);\r\n}\r\n}\r\nmutex_unlock(&al->card_mutex);\r\nout:\r\nusb_free_urb(sg.urb[0]);\r\nusb_free_urb(sg.urb[1]);\r\nusb_free_urb(sg.urb[2]);\r\nreturn err;\r\n}\r\nstatic int alauda_erase_block(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct alauda_sg_request sg;\r\nstruct alauda *al = mtd->priv;\r\nu32 pba = ofs >> al->card->blockshift;\r\nu8 command[] = {\r\nALAUDA_BULK_CMD, ALAUDA_BULK_ERASE_BLOCK, PBA_HI(pba),\r\nPBA_ZONE(pba), 0, PBA_LO(pba), 0x02, 0, al->port\r\n};\r\nu8 buf[2];\r\nint i, err;\r\nfor (i=0; i<2; i++)\r\nsg.urb[i] = NULL;\r\nerr = -ENOMEM;\r\nfor (i=0; i<2; i++) {\r\nsg.urb[i] = usb_alloc_urb(0, GFP_NOIO);\r\nif (!sg.urb[i])\r\ngoto out;\r\n}\r\ninit_completion(&sg.comp);\r\nusb_fill_bulk_urb(sg.urb[0], al->dev, al->bulk_out, command, 9,\r\nalauda_complete, NULL);\r\nusb_fill_bulk_urb(sg.urb[1], al->dev, al->bulk_in, buf, 2,\r\nalauda_complete, &sg.comp);\r\nmutex_lock(&al->card_mutex);\r\nfor (i=0; i<2; i++) {\r\nerr = usb_submit_urb(sg.urb[i], GFP_NOIO);\r\nif (err)\r\ngoto cancel;\r\n}\r\nif (!wait_for_completion_timeout(&sg.comp, TIMEOUT)) {\r\nerr = -ETIMEDOUT;\r\ncancel:\r\nfor (i=0; i<2; i++) {\r\nusb_kill_urb(sg.urb[i]);\r\n}\r\n}\r\nmutex_unlock(&al->card_mutex);\r\nout:\r\nusb_free_urb(sg.urb[0]);\r\nusb_free_urb(sg.urb[1]);\r\nreturn err;\r\n}\r\nstatic int alauda_read_oob(struct mtd_info *mtd, loff_t from, void *oob)\r\n{\r\nstatic u8 ignore_buf[512];\r\nreturn __alauda_read_page(mtd, from, ignore_buf, oob);\r\n}\r\nstatic int alauda_isbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nu8 oob[16];\r\nint err;\r\nerr = alauda_read_oob(mtd, ofs, oob);\r\nif (err)\r\nreturn err;\r\nreturn hweight8(oob[5]) >= 7 ? 0 : 1;\r\n}\r\nstatic int alauda_bounce_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct alauda *al = mtd->priv;\r\nvoid *bounce_buf;\r\nint err, corrected=0, uncorrected=0;\r\nbounce_buf = kmalloc(mtd->writesize, GFP_KERNEL);\r\nif (!bounce_buf)\r\nreturn -ENOMEM;\r\n*retlen = len;\r\nwhile (len) {\r\nu8 oob[16];\r\nsize_t byte = from & al->bytemask;\r\nsize_t cplen = min(len, mtd->writesize - byte);\r\nerr = alauda_read_page(mtd, from, bounce_buf, oob,\r\n&corrected, &uncorrected);\r\nif (err)\r\ngoto out;\r\nmemcpy(buf, bounce_buf + byte, cplen);\r\nbuf += cplen;\r\nfrom += cplen;\r\nlen -= cplen;\r\n}\r\nerr = 0;\r\nif (corrected)\r\nerr = -EUCLEAN;\r\nif (uncorrected)\r\nerr = -EBADMSG;\r\nout:\r\nkfree(bounce_buf);\r\nreturn err;\r\n}\r\nstatic int alauda_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct alauda *al = mtd->priv;\r\nint err, corrected=0, uncorrected=0;\r\nif ((from & al->bytemask) || (len & al->bytemask))\r\nreturn alauda_bounce_read(mtd, from, len, retlen, buf);\r\n*retlen = len;\r\nwhile (len) {\r\nu8 oob[16];\r\nerr = alauda_read_page(mtd, from, buf, oob,\r\n&corrected, &uncorrected);\r\nif (err)\r\nreturn err;\r\nbuf += mtd->writesize;\r\nfrom += mtd->writesize;\r\nlen -= mtd->writesize;\r\n}\r\nerr = 0;\r\nif (corrected)\r\nerr = -EUCLEAN;\r\nif (uncorrected)\r\nerr = -EBADMSG;\r\nreturn err;\r\n}\r\nstatic int alauda_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct alauda *al = mtd->priv;\r\nint err;\r\nif ((to & al->bytemask) || (len & al->bytemask))\r\nreturn -EINVAL;\r\n*retlen = len;\r\nwhile (len) {\r\nu32 page = (to >> al->card->pageshift) & al->pagemask;\r\nu8 oob[16] = { 'h', 'e', 'l', 'l', 'o', 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nif (page == 0) {\r\nerr = alauda_isbad(mtd, to);\r\nif (err) {\r\nreturn -EIO;\r\n}\r\n}\r\nnand_calculate_ecc(mtd, buf, &oob[13]);\r\nnand_calculate_ecc(mtd, buf+256, &oob[8]);\r\nerr = alauda_write_page(mtd, to, (void*)buf, oob);\r\nif (err)\r\nreturn err;\r\nbuf += mtd->writesize;\r\nto += mtd->writesize;\r\nlen -= mtd->writesize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __alauda_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct alauda *al = mtd->priv;\r\nu32 ofs = instr->addr;\r\nu32 len = instr->len;\r\nint err;\r\nif ((ofs & al->blockmask) || (len & al->blockmask))\r\nreturn -EINVAL;\r\nwhile (len) {\r\nerr = alauda_isbad(mtd, ofs);\r\nif (err > 0)\r\nerr = -EIO;\r\nif (err < 0)\r\nreturn err;\r\nerr = alauda_erase_block(mtd, ofs);\r\nif (err < 0)\r\nreturn err;\r\nofs += mtd->erasesize;\r\nlen -= mtd->erasesize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alauda_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nint err;\r\nerr = __alauda_erase(mtd, instr);\r\ninstr->state = err ? MTD_ERASE_FAILED : MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn err;\r\n}\r\nstatic int alauda_init_media(struct alauda *al)\r\n{\r\nu8 buf[4], *b0=buf, *b1=buf+1;\r\nstruct alauda_card *card;\r\nstruct mtd_info *mtd;\r\nint err;\r\nmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\r\nif (!mtd)\r\nreturn -ENOMEM;\r\nfor (;;) {\r\nerr = alauda_get_media_status(al, buf);\r\nif (err < 0)\r\ngoto error;\r\nif (*b0 & 0x10)\r\nbreak;\r\nmsleep(20);\r\n}\r\nerr = alauda_ack_media(al);\r\nif (err)\r\ngoto error;\r\nmsleep(10);\r\nerr = alauda_get_media_status(al, buf);\r\nif (err < 0)\r\ngoto error;\r\nif (*b0 != 0x14) {\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nerr = alauda_get_media_signatures(al, buf);\r\nif (err < 0)\r\ngoto error;\r\ncard = get_card(*b1);\r\nif (!card) {\r\nprintk(KERN_ERR"Alauda: unknown card id %02x\n", *b1);\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nprintk(KERN_INFO"pagesize=%x\nerasesize=%x\nsize=%xMiB\n",\r\n1<<card->pageshift, 1<<card->blockshift,\r\n1<<(card->chipshift-20));\r\nal->card = card;\r\nal->pagemask = (1 << (card->blockshift - card->pageshift)) - 1;\r\nal->bytemask = (1 << card->pageshift) - 1;\r\nal->blockmask = (1 << card->blockshift) - 1;\r\nmtd->name = "alauda";\r\nmtd->size = 1<<card->chipshift;\r\nmtd->erasesize = 1<<card->blockshift;\r\nmtd->writesize = 1<<card->pageshift;\r\nmtd->type = MTD_NANDFLASH;\r\nmtd->flags = MTD_CAP_NANDFLASH;\r\nmtd->read = alauda_read;\r\nmtd->write = alauda_write;\r\nmtd->erase = alauda_erase;\r\nmtd->block_isbad = alauda_isbad;\r\nmtd->priv = al;\r\nmtd->owner = THIS_MODULE;\r\nerr = mtd_device_register(mtd, NULL, 0);\r\nif (err) {\r\nerr = -ENFILE;\r\ngoto error;\r\n}\r\nal->mtd = mtd;\r\nalauda_reset(al);\r\nreturn 0;\r\nerror:\r\nkfree(mtd);\r\nreturn err;\r\n}\r\nstatic int alauda_check_media(struct alauda *al)\r\n{\r\nu8 buf[2], *b0 = buf, *b1 = buf+1;\r\nint err;\r\nerr = alauda_get_media_status(al, buf);\r\nif (err < 0)\r\nreturn err;\r\nif ((*b1 & 0x01) == 0) {\r\nreturn -EIO;\r\n}\r\nif ((*b0 & 0x80) || ((*b0 & 0x1F) == 0x10)) {\r\nreturn -EIO;\r\n}\r\nif (*b0 & 0x08) {\r\nreturn alauda_init_media(al);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alauda_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct alauda *al;\r\nstruct usb_host_interface *iface;\r\nstruct usb_endpoint_descriptor *ep,\r\n*ep_in=NULL, *ep_out=NULL, *ep_wr=NULL;\r\nint i, err = -ENOMEM;\r\nal = kzalloc(2*sizeof(*al), GFP_KERNEL);\r\nif (!al)\r\ngoto error;\r\nkref_init(&al->kref);\r\nusb_set_intfdata(interface, al);\r\nal->dev = usb_get_dev(interface_to_usbdev(interface));\r\nal->interface = interface;\r\niface = interface->cur_altsetting;\r\nfor (i = 0; i < iface->desc.bNumEndpoints; ++i) {\r\nep = &iface->endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(ep)) {\r\nep_in = ep;\r\n} else if (usb_endpoint_is_bulk_out(ep)) {\r\nif (i==0)\r\nep_wr = ep;\r\nelse\r\nep_out = ep;\r\n}\r\n}\r\nerr = -EIO;\r\nif (!ep_wr || !ep_in || !ep_out)\r\ngoto error;\r\nal->write_out = usb_sndbulkpipe(al->dev,\r\nusb_endpoint_num(ep_wr));\r\nal->bulk_in = usb_rcvbulkpipe(al->dev,\r\nusb_endpoint_num(ep_in));\r\nal->bulk_out = usb_sndbulkpipe(al->dev,\r\nusb_endpoint_num(ep_out));\r\nmemcpy(al+1, al, sizeof(*al));\r\nmutex_init(&al[0].card_mutex);\r\nmutex_init(&al[1].card_mutex);\r\nal[0].port = ALAUDA_PORT_XD;\r\nal[1].port = ALAUDA_PORT_SM;\r\ndev_info(&interface->dev, "alauda probed\n");\r\nalauda_check_media(al);\r\nalauda_check_media(al+1);\r\nreturn 0;\r\nerror:\r\nif (al)\r\nkref_put(&al->kref, alauda_delete);\r\nreturn err;\r\n}\r\nstatic void alauda_disconnect(struct usb_interface *interface)\r\n{\r\nstruct alauda *al;\r\nal = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (al)\r\nkref_put(&al->kref, alauda_delete);\r\ndev_info(&interface->dev, "alauda gone");\r\n}\r\nstatic int __init alauda_init(void)\r\n{\r\nreturn usb_register(&alauda_driver);\r\n}\r\nstatic void __exit alauda_exit(void)\r\n{\r\nusb_deregister(&alauda_driver);\r\n}
