int kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\r\n{\r\nif (KDB_DEBUG(AR))\r\nkdb_printf("kdbgetsymval: symname=%s, symtab=%p\n", symname,\r\nsymtab);\r\nmemset(symtab, 0, sizeof(*symtab));\r\nsymtab->sym_start = kallsyms_lookup_name(symname);\r\nif (symtab->sym_start) {\r\nif (KDB_DEBUG(AR))\r\nkdb_printf("kdbgetsymval: returns 1, "\r\n"symtab->sym_start=0x%lx\n",\r\nsymtab->sym_start);\r\nreturn 1;\r\n}\r\nif (KDB_DEBUG(AR))\r\nkdb_printf("kdbgetsymval: returns 0\n");\r\nreturn 0;\r\n}\r\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\r\n{\r\nint ret = 0;\r\nunsigned long symbolsize = 0;\r\nunsigned long offset = 0;\r\n#define knt1_size 128\r\nchar *knt1 = NULL;\r\nif (KDB_DEBUG(AR))\r\nkdb_printf("kdbnearsym: addr=0x%lx, symtab=%p\n", addr, symtab);\r\nmemset(symtab, 0, sizeof(*symtab));\r\nif (addr < 4096)\r\ngoto out;\r\nknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\r\nif (!knt1) {\r\nkdb_printf("kdbnearsym: addr=0x%lx cannot kmalloc knt1\n",\r\naddr);\r\ngoto out;\r\n}\r\nsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\r\n(char **)(&symtab->mod_name), knt1);\r\nif (offset > 8*1024*1024) {\r\nsymtab->sym_name = NULL;\r\naddr = offset = symbolsize = 0;\r\n}\r\nsymtab->sym_start = addr - offset;\r\nsymtab->sym_end = symtab->sym_start + symbolsize;\r\nret = symtab->sym_name != NULL && *(symtab->sym_name) != '\0';\r\nif (ret) {\r\nint i;\r\nif (symtab->sym_name != knt1) {\r\nstrncpy(knt1, symtab->sym_name, knt1_size);\r\nknt1[knt1_size-1] = '\0';\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\r\nif (kdb_name_table[i] &&\r\nstrcmp(kdb_name_table[i], knt1) == 0)\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(kdb_name_table)) {\r\ndebug_kfree(kdb_name_table[0]);\r\nmemcpy(kdb_name_table, kdb_name_table+1,\r\nsizeof(kdb_name_table[0]) *\r\n(ARRAY_SIZE(kdb_name_table)-1));\r\n} else {\r\ndebug_kfree(knt1);\r\nknt1 = kdb_name_table[i];\r\nmemcpy(kdb_name_table+i, kdb_name_table+i+1,\r\nsizeof(kdb_name_table[0]) *\r\n(ARRAY_SIZE(kdb_name_table)-i-1));\r\n}\r\ni = ARRAY_SIZE(kdb_name_table) - 1;\r\nkdb_name_table[i] = knt1;\r\nsymtab->sym_name = kdb_name_table[i];\r\nknt1 = NULL;\r\n}\r\nif (symtab->mod_name == NULL)\r\nsymtab->mod_name = "kernel";\r\nif (KDB_DEBUG(AR))\r\nkdb_printf("kdbnearsym: returns %d symtab->sym_start=0x%lx, "\r\n"symtab->mod_name=%p, symtab->sym_name=%p (%s)\n", ret,\r\nsymtab->sym_start, symtab->mod_name, symtab->sym_name,\r\nsymtab->sym_name);\r\nout:\r\ndebug_kfree(knt1);\r\nreturn ret;\r\n}\r\nvoid kdbnearsym_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\r\nif (kdb_name_table[i]) {\r\ndebug_kfree(kdb_name_table[i]);\r\nkdb_name_table[i] = NULL;\r\n}\r\n}\r\n}\r\nint kallsyms_symbol_complete(char *prefix_name, int max_len)\r\n{\r\nloff_t pos = 0;\r\nint prefix_len = strlen(prefix_name), prev_len = 0;\r\nint i, number = 0;\r\nconst char *name;\r\nwhile ((name = kdb_walk_kallsyms(&pos))) {\r\nif (strncmp(name, prefix_name, prefix_len) == 0) {\r\nstrcpy(ks_namebuf, name);\r\nif (++number == 1) {\r\nprev_len = min_t(int, max_len-1,\r\nstrlen(ks_namebuf));\r\nmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\r\nks_namebuf_prev[prev_len] = '\0';\r\ncontinue;\r\n}\r\nfor (i = 0; i < prev_len; i++) {\r\nif (ks_namebuf[i] != ks_namebuf_prev[i]) {\r\nprev_len = i;\r\nks_namebuf_prev[i] = '\0';\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (prev_len > prefix_len)\r\nmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\r\nreturn number;\r\n}\r\nint kallsyms_symbol_next(char *prefix_name, int flag)\r\n{\r\nint prefix_len = strlen(prefix_name);\r\nstatic loff_t pos;\r\nconst char *name;\r\nif (!flag)\r\npos = 0;\r\nwhile ((name = kdb_walk_kallsyms(&pos))) {\r\nif (strncmp(name, prefix_name, prefix_len) == 0) {\r\nstrncpy(prefix_name, name, strlen(name)+1);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\r\nunsigned int punc)\r\n{\r\nkdb_symtab_t symtab, *symtab_p2;\r\nif (symtab_p) {\r\nsymtab_p2 = (kdb_symtab_t *)symtab_p;\r\n} else {\r\nsymtab_p2 = &symtab;\r\nkdbnearsym(addr, symtab_p2);\r\n}\r\nif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\r\nreturn;\r\nif (punc & KDB_SP_SPACEB)\r\nkdb_printf(" ");\r\nif (punc & KDB_SP_VALUE)\r\nkdb_printf(kdb_machreg_fmt0, addr);\r\nif (symtab_p2->sym_name) {\r\nif (punc & KDB_SP_VALUE)\r\nkdb_printf(" ");\r\nif (punc & KDB_SP_PAREN)\r\nkdb_printf("(");\r\nif (strcmp(symtab_p2->mod_name, "kernel"))\r\nkdb_printf("[%s]", symtab_p2->mod_name);\r\nkdb_printf("%s", symtab_p2->sym_name);\r\nif (addr != symtab_p2->sym_start)\r\nkdb_printf("+0x%lx", addr - symtab_p2->sym_start);\r\nif (punc & KDB_SP_SYMSIZE)\r\nkdb_printf("/0x%lx",\r\nsymtab_p2->sym_end - symtab_p2->sym_start);\r\nif (punc & KDB_SP_PAREN)\r\nkdb_printf(")");\r\n}\r\nif (punc & KDB_SP_SPACEA)\r\nkdb_printf(" ");\r\nif (punc & KDB_SP_NEWLINE)\r\nkdb_printf("\n");\r\n}\r\nchar *kdb_strdup(const char *str, gfp_t type)\r\n{\r\nint n = strlen(str)+1;\r\nchar *s = kmalloc(n, type);\r\nif (!s)\r\nreturn NULL;\r\nreturn strcpy(s, str);\r\n}\r\nint kdb_getarea_size(void *res, unsigned long addr, size_t size)\r\n{\r\nint ret = probe_kernel_read((char *)res, (char *)addr, size);\r\nif (ret) {\r\nif (!KDB_STATE(SUPPRESS)) {\r\nkdb_printf("kdb_getarea: Bad address 0x%lx\n", addr);\r\nKDB_STATE_SET(SUPPRESS);\r\n}\r\nret = KDB_BADADDR;\r\n} else {\r\nKDB_STATE_CLEAR(SUPPRESS);\r\n}\r\nreturn ret;\r\n}\r\nint kdb_putarea_size(unsigned long addr, void *res, size_t size)\r\n{\r\nint ret = probe_kernel_read((char *)addr, (char *)res, size);\r\nif (ret) {\r\nif (!KDB_STATE(SUPPRESS)) {\r\nkdb_printf("kdb_putarea: Bad address 0x%lx\n", addr);\r\nKDB_STATE_SET(SUPPRESS);\r\n}\r\nret = KDB_BADADDR;\r\n} else {\r\nKDB_STATE_CLEAR(SUPPRESS);\r\n}\r\nreturn ret;\r\n}\r\nstatic int kdb_getphys(void *res, unsigned long addr, size_t size)\r\n{\r\nunsigned long pfn;\r\nvoid *vaddr;\r\nstruct page *page;\r\npfn = (addr >> PAGE_SHIFT);\r\nif (!pfn_valid(pfn))\r\nreturn 1;\r\npage = pfn_to_page(pfn);\r\nvaddr = kmap_atomic(page, KM_KDB);\r\nmemcpy(res, vaddr + (addr & (PAGE_SIZE - 1)), size);\r\nkunmap_atomic(vaddr, KM_KDB);\r\nreturn 0;\r\n}\r\nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\r\n{\r\nint diag;\r\n__u8 w1;\r\n__u16 w2;\r\n__u32 w4;\r\n__u64 w8;\r\n*word = 0;\r\nswitch (size) {\r\ncase 1:\r\ndiag = kdb_getphys(&w1, addr, sizeof(w1));\r\nif (!diag)\r\n*word = w1;\r\nbreak;\r\ncase 2:\r\ndiag = kdb_getphys(&w2, addr, sizeof(w2));\r\nif (!diag)\r\n*word = w2;\r\nbreak;\r\ncase 4:\r\ndiag = kdb_getphys(&w4, addr, sizeof(w4));\r\nif (!diag)\r\n*word = w4;\r\nbreak;\r\ncase 8:\r\nif (size <= sizeof(*word)) {\r\ndiag = kdb_getphys(&w8, addr, sizeof(w8));\r\nif (!diag)\r\n*word = w8;\r\nbreak;\r\n}\r\ndefault:\r\ndiag = KDB_BADWIDTH;\r\nkdb_printf("kdb_getphysword: bad width %ld\n", (long) size);\r\n}\r\nreturn diag;\r\n}\r\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\r\n{\r\nint diag;\r\n__u8 w1;\r\n__u16 w2;\r\n__u32 w4;\r\n__u64 w8;\r\n*word = 0;\r\nswitch (size) {\r\ncase 1:\r\ndiag = kdb_getarea(w1, addr);\r\nif (!diag)\r\n*word = w1;\r\nbreak;\r\ncase 2:\r\ndiag = kdb_getarea(w2, addr);\r\nif (!diag)\r\n*word = w2;\r\nbreak;\r\ncase 4:\r\ndiag = kdb_getarea(w4, addr);\r\nif (!diag)\r\n*word = w4;\r\nbreak;\r\ncase 8:\r\nif (size <= sizeof(*word)) {\r\ndiag = kdb_getarea(w8, addr);\r\nif (!diag)\r\n*word = w8;\r\nbreak;\r\n}\r\ndefault:\r\ndiag = KDB_BADWIDTH;\r\nkdb_printf("kdb_getword: bad width %ld\n", (long) size);\r\n}\r\nreturn diag;\r\n}\r\nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\r\n{\r\nint diag;\r\n__u8 w1;\r\n__u16 w2;\r\n__u32 w4;\r\n__u64 w8;\r\nswitch (size) {\r\ncase 1:\r\nw1 = word;\r\ndiag = kdb_putarea(addr, w1);\r\nbreak;\r\ncase 2:\r\nw2 = word;\r\ndiag = kdb_putarea(addr, w2);\r\nbreak;\r\ncase 4:\r\nw4 = word;\r\ndiag = kdb_putarea(addr, w4);\r\nbreak;\r\ncase 8:\r\nif (size <= sizeof(word)) {\r\nw8 = word;\r\ndiag = kdb_putarea(addr, w8);\r\nbreak;\r\n}\r\ndefault:\r\ndiag = KDB_BADWIDTH;\r\nkdb_printf("kdb_putword: bad width %ld\n", (long) size);\r\n}\r\nreturn diag;\r\n}\r\nunsigned long kdb_task_state_string(const char *s)\r\n{\r\nlong res = 0;\r\nif (!s) {\r\ns = kdbgetenv("PS");\r\nif (!s)\r\ns = "DRSTCZEU";\r\n}\r\nwhile (*s) {\r\nswitch (*s) {\r\ncase 'D':\r\nres |= TASK_UNINTERRUPTIBLE;\r\nbreak;\r\ncase 'R':\r\nres |= RUNNING;\r\nbreak;\r\ncase 'S':\r\nres |= TASK_INTERRUPTIBLE;\r\nbreak;\r\ncase 'T':\r\nres |= TASK_STOPPED;\r\nbreak;\r\ncase 'C':\r\nres |= TASK_TRACED;\r\nbreak;\r\ncase 'Z':\r\nres |= EXIT_ZOMBIE << 16;\r\nbreak;\r\ncase 'E':\r\nres |= EXIT_DEAD << 16;\r\nbreak;\r\ncase 'U':\r\nres |= UNRUNNABLE;\r\nbreak;\r\ncase 'I':\r\nres |= IDLE;\r\nbreak;\r\ncase 'M':\r\nres |= DAEMON;\r\nbreak;\r\ncase 'A':\r\nres = ~0UL;\r\nbreak;\r\ndefault:\r\nkdb_printf("%s: unknown flag '%c' ignored\n",\r\n__func__, *s);\r\nbreak;\r\n}\r\n++s;\r\n}\r\nreturn res;\r\n}\r\nchar kdb_task_state_char (const struct task_struct *p)\r\n{\r\nint cpu;\r\nchar state;\r\nunsigned long tmp;\r\nif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\r\nreturn 'E';\r\ncpu = kdb_process_cpu(p);\r\nstate = (p->state == 0) ? 'R' :\r\n(p->state < 0) ? 'U' :\r\n(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\r\n(p->state & TASK_STOPPED) ? 'T' :\r\n(p->state & TASK_TRACED) ? 'C' :\r\n(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\r\n(p->exit_state & EXIT_DEAD) ? 'E' :\r\n(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\r\nif (p->pid == 0) {\r\nif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\r\nif (cpu != kdb_initial_cpu)\r\nstate = 'I';\r\n}\r\n} else if (!p->mm && state == 'S') {\r\nstate = 'M';\r\n}\r\nreturn state;\r\n}\r\nunsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\r\n{\r\nchar state[] = { kdb_task_state_char(p), '\0' };\r\nreturn (mask & kdb_task_state_string(state)) != 0;\r\n}\r\nvoid kdb_print_nameval(const char *name, unsigned long val)\r\n{\r\nkdb_symtab_t symtab;\r\nkdb_printf(" %-11.11s ", name);\r\nif (kdbnearsym(val, &symtab))\r\nkdb_symbol_print(val, &symtab,\r\nKDB_SP_VALUE|KDB_SP_SYMSIZE|KDB_SP_NEWLINE);\r\nelse\r\nkdb_printf("0x%lx\n", val);\r\n}\r\nstatic int get_dap_lock(void)\r\n__acquires(dap_lock)\r\n{\r\nstatic int dap_locked = -1;\r\nint count;\r\nif (dap_locked == smp_processor_id())\r\ncount = 1;\r\nelse\r\ncount = 1000;\r\nwhile (1) {\r\nif (spin_trylock(&dap_lock)) {\r\ndap_locked = -1;\r\nreturn 1;\r\n}\r\nif (!count--)\r\nbreak;\r\nudelay(1000);\r\n}\r\ndap_locked = smp_processor_id();\r\n__acquire(dap_lock);\r\nreturn 0;\r\n}\r\nvoid *debug_kmalloc(size_t size, gfp_t flags)\r\n{\r\nunsigned int rem, h_offset;\r\nstruct debug_alloc_header *best, *bestprev, *prev, *h;\r\nvoid *p = NULL;\r\nif (!get_dap_lock()) {\r\n__release(dap_lock);\r\nreturn NULL;\r\n}\r\nh = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\r\nif (dah_first_call) {\r\nh->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\r\ndah_first_call = 0;\r\n}\r\nsize = ALIGN(size, dah_align);\r\nprev = best = bestprev = NULL;\r\nwhile (1) {\r\nif (h->size >= size && (!best || h->size < best->size)) {\r\nbest = h;\r\nbestprev = prev;\r\nif (h->size == size)\r\nbreak;\r\n}\r\nif (!h->next)\r\nbreak;\r\nprev = h;\r\nh = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\r\n}\r\nif (!best)\r\ngoto out;\r\nrem = best->size - size;\r\nif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\r\ngoto out;\r\nif (rem >= dah_overhead) {\r\nbest->size = size;\r\nh_offset = ((char *)best - debug_alloc_pool) +\r\ndah_overhead + best->size;\r\nh = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\r\nh->size = rem - dah_overhead;\r\nh->next = best->next;\r\n} else\r\nh_offset = best->next;\r\nbest->caller = __builtin_return_address(0);\r\ndah_used += best->size;\r\ndah_used_max = max(dah_used, dah_used_max);\r\nif (bestprev)\r\nbestprev->next = h_offset;\r\nelse\r\ndah_first = h_offset;\r\np = (char *)best + dah_overhead;\r\nmemset(p, POISON_INUSE, best->size - 1);\r\n*((char *)p + best->size - 1) = POISON_END;\r\nout:\r\nspin_unlock(&dap_lock);\r\nreturn p;\r\n}\r\nvoid debug_kfree(void *p)\r\n{\r\nstruct debug_alloc_header *h;\r\nunsigned int h_offset;\r\nif (!p)\r\nreturn;\r\nif ((char *)p < debug_alloc_pool ||\r\n(char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\r\nkfree(p);\r\nreturn;\r\n}\r\nif (!get_dap_lock()) {\r\n__release(dap_lock);\r\nreturn;\r\n}\r\nh = (struct debug_alloc_header *)((char *)p - dah_overhead);\r\nmemset(p, POISON_FREE, h->size - 1);\r\n*((char *)p + h->size - 1) = POISON_END;\r\nh->caller = NULL;\r\ndah_used -= h->size;\r\nh_offset = (char *)h - debug_alloc_pool;\r\nif (h_offset < dah_first) {\r\nh->next = dah_first;\r\ndah_first = h_offset;\r\n} else {\r\nstruct debug_alloc_header *prev;\r\nunsigned int prev_offset;\r\nprev = (struct debug_alloc_header *)(debug_alloc_pool +\r\ndah_first);\r\nwhile (1) {\r\nif (!prev->next || prev->next > h_offset)\r\nbreak;\r\nprev = (struct debug_alloc_header *)\r\n(debug_alloc_pool + prev->next);\r\n}\r\nprev_offset = (char *)prev - debug_alloc_pool;\r\nif (prev_offset + dah_overhead + prev->size == h_offset) {\r\nprev->size += dah_overhead + h->size;\r\nmemset(h, POISON_FREE, dah_overhead - 1);\r\n*((char *)h + dah_overhead - 1) = POISON_END;\r\nh = prev;\r\nh_offset = prev_offset;\r\n} else {\r\nh->next = prev->next;\r\nprev->next = h_offset;\r\n}\r\n}\r\nif (h_offset + dah_overhead + h->size == h->next) {\r\nstruct debug_alloc_header *next;\r\nnext = (struct debug_alloc_header *)\r\n(debug_alloc_pool + h->next);\r\nh->size += dah_overhead + next->size;\r\nh->next = next->next;\r\nmemset(next, POISON_FREE, dah_overhead - 1);\r\n*((char *)next + dah_overhead - 1) = POISON_END;\r\n}\r\nspin_unlock(&dap_lock);\r\n}\r\nvoid debug_kusage(void)\r\n{\r\nstruct debug_alloc_header *h_free, *h_used;\r\n#ifdef CONFIG_IA64\r\nstatic int debug_kusage_one_time;\r\n#else\r\nstatic int debug_kusage_one_time = 1;\r\n#endif\r\nif (!get_dap_lock()) {\r\n__release(dap_lock);\r\nreturn;\r\n}\r\nh_free = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\r\nif (dah_first == 0 &&\r\n(h_free->size == sizeof(debug_alloc_pool_aligned) - dah_overhead ||\r\ndah_first_call))\r\ngoto out;\r\nif (!debug_kusage_one_time)\r\ngoto out;\r\ndebug_kusage_one_time = 0;\r\nkdb_printf("%s: debug_kmalloc memory leak dah_first %d\n",\r\n__func__, dah_first);\r\nif (dah_first) {\r\nh_used = (struct debug_alloc_header *)debug_alloc_pool;\r\nkdb_printf("%s: h_used %p size %d\n", __func__, h_used,\r\nh_used->size);\r\n}\r\ndo {\r\nh_used = (struct debug_alloc_header *)\r\n((char *)h_free + dah_overhead + h_free->size);\r\nkdb_printf("%s: h_used %p size %d caller %p\n",\r\n__func__, h_used, h_used->size, h_used->caller);\r\nh_free = (struct debug_alloc_header *)\r\n(debug_alloc_pool + h_free->next);\r\n} while (h_free->next);\r\nh_used = (struct debug_alloc_header *)\r\n((char *)h_free + dah_overhead + h_free->size);\r\nif ((char *)h_used - debug_alloc_pool !=\r\nsizeof(debug_alloc_pool_aligned))\r\nkdb_printf("%s: h_used %p size %d caller %p\n",\r\n__func__, h_used, h_used->size, h_used->caller);\r\nout:\r\nspin_unlock(&dap_lock);\r\n}\r\nvoid kdb_save_flags(void)\r\n{\r\nBUG_ON(kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack));\r\nkdb_flags_stack[kdb_flags_index++] = kdb_flags;\r\n}\r\nvoid kdb_restore_flags(void)\r\n{\r\nBUG_ON(kdb_flags_index <= 0);\r\nkdb_flags = kdb_flags_stack[--kdb_flags_index];\r\n}
