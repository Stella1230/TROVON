static void __iomem *detect_HRT_floating_pointer(void __iomem *begin, void __iomem *end)\r\n{\r\nvoid __iomem *fp;\r\nvoid __iomem *endp;\r\nu8 temp1, temp2, temp3, temp4;\r\nint status = 0;\r\nendp = (end - sizeof(struct hrt) + 1);\r\nfor (fp = begin; fp <= endp; fp += 16) {\r\ntemp1 = readb(fp + SIG0);\r\ntemp2 = readb(fp + SIG1);\r\ntemp3 = readb(fp + SIG2);\r\ntemp4 = readb(fp + SIG3);\r\nif (temp1 == '$' &&\r\ntemp2 == 'H' &&\r\ntemp3 == 'R' &&\r\ntemp4 == 'T') {\r\nstatus = 1;\r\nbreak;\r\n}\r\n}\r\nif (!status)\r\nfp = NULL;\r\ndbg("Discovered Hotplug Resource Table at %p\n", fp);\r\nreturn fp;\r\n}\r\nint cpqhp_configure_device (struct controller* ctrl, struct pci_func* func)\r\n{\r\nunsigned char bus;\r\nstruct pci_bus *child;\r\nint num;\r\nif (func->pci_dev == NULL)\r\nfunc->pci_dev = pci_get_bus_and_slot(func->bus,PCI_DEVFN(func->device, func->function));\r\nif (func->pci_dev == NULL) {\r\ndbg("INFO: pci_dev still null\n");\r\nnum = pci_scan_slot(ctrl->pci_dev->bus, PCI_DEVFN(func->device, func->function));\r\nif (num)\r\npci_bus_add_devices(ctrl->pci_dev->bus);\r\nfunc->pci_dev = pci_get_bus_and_slot(func->bus, PCI_DEVFN(func->device, func->function));\r\nif (func->pci_dev == NULL) {\r\ndbg("ERROR: pci_dev still null\n");\r\nreturn 0;\r\n}\r\n}\r\nif (func->pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\npci_read_config_byte(func->pci_dev, PCI_SECONDARY_BUS, &bus);\r\nchild = (struct pci_bus*) pci_add_new_bus(func->pci_dev->bus, (func->pci_dev), bus);\r\npci_do_scan_bus(child);\r\n}\r\npci_dev_put(func->pci_dev);\r\nreturn 0;\r\n}\r\nint cpqhp_unconfigure_device(struct pci_func* func)\r\n{\r\nint j;\r\ndbg("%s: bus/dev/func = %x/%x/%x\n", __func__, func->bus, func->device, func->function);\r\nfor (j=0; j<8 ; j++) {\r\nstruct pci_dev* temp = pci_get_bus_and_slot(func->bus, PCI_DEVFN(func->device, j));\r\nif (temp) {\r\npci_dev_put(temp);\r\npci_remove_bus_device(temp);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int PCI_RefinedAccessConfig(struct pci_bus *bus, unsigned int devfn, u8 offset, u32 *value)\r\n{\r\nu32 vendID = 0;\r\nif (pci_bus_read_config_dword (bus, devfn, PCI_VENDOR_ID, &vendID) == -1)\r\nreturn -1;\r\nif (vendID == 0xffffffff)\r\nreturn -1;\r\nreturn pci_bus_read_config_dword (bus, devfn, offset, value);\r\n}\r\nint cpqhp_set_irq (u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num)\r\n{\r\nint rc = 0;\r\nif (cpqhp_legacy_mode) {\r\nstruct pci_dev *fakedev;\r\nstruct pci_bus *fakebus;\r\nu16 temp_word;\r\nfakedev = kmalloc(sizeof(*fakedev), GFP_KERNEL);\r\nfakebus = kmalloc(sizeof(*fakebus), GFP_KERNEL);\r\nif (!fakedev || !fakebus) {\r\nkfree(fakedev);\r\nkfree(fakebus);\r\nreturn -ENOMEM;\r\n}\r\nfakedev->devfn = dev_num << 3;\r\nfakedev->bus = fakebus;\r\nfakebus->number = bus_num;\r\ndbg("%s: dev %d, bus %d, pin %d, num %d\n",\r\n__func__, dev_num, bus_num, int_pin, irq_num);\r\nrc = pcibios_set_irq_routing(fakedev, int_pin - 1, irq_num);\r\nkfree(fakedev);\r\nkfree(fakebus);\r\ndbg("%s: rc %d\n", __func__, rc);\r\nif (!rc)\r\nreturn !rc;\r\ntemp_word = inb(0x4d0);\r\ntemp_word |= inb(0x4d1) << 8;\r\ntemp_word |= 0x01 << irq_num;\r\noutb((u8) (temp_word & 0xFF), 0x4d0); outb((u8) ((temp_word &\r\n0xFF00) >> 8), 0x4d1); rc = 0; }\r\nreturn rc;\r\n}\r\nstatic int PCI_ScanBusForNonBridge(struct controller *ctrl, u8 bus_num, u8 * dev_num)\r\n{\r\nu16 tdevice;\r\nu32 work;\r\nu8 tbus;\r\nctrl->pci_bus->number = bus_num;\r\nfor (tdevice = 0; tdevice < 0xFF; tdevice++) {\r\nif (PCI_RefinedAccessConfig(ctrl->pci_bus, tdevice, 0x08, &work) == -1)\r\ncontinue;\r\ndbg("Looking for nonbridge bus_num %d dev_num %d\n", bus_num, tdevice);\r\nif ((work >> 8) != PCI_TO_PCI_BRIDGE_CLASS) {\r\n*dev_num = tdevice;\r\ndbg("found it !\n");\r\nreturn 0;\r\n}\r\n}\r\nfor (tdevice = 0; tdevice < 0xFF; tdevice++) {\r\nif (PCI_RefinedAccessConfig(ctrl->pci_bus, tdevice, 0x08, &work) == -1)\r\ncontinue;\r\ndbg("Looking for bridge bus_num %d dev_num %d\n", bus_num, tdevice);\r\nif ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {\r\npci_bus_read_config_byte (ctrl->pci_bus, PCI_DEVFN(tdevice, 0), PCI_SECONDARY_BUS, &tbus);\r\ndbg("Recurse on bus_num %d tdevice %d\n", tbus, tdevice);\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int PCI_GetBusDevHelper(struct controller *ctrl, u8 *bus_num, u8 *dev_num, u8 slot, u8 nobridge)\r\n{\r\nint loop, len;\r\nu32 work;\r\nu8 tbus, tdevice, tslot;\r\nlen = cpqhp_routing_table_length();\r\nfor (loop = 0; loop < len; ++loop) {\r\ntbus = cpqhp_routing_table->slots[loop].bus;\r\ntdevice = cpqhp_routing_table->slots[loop].devfn;\r\ntslot = cpqhp_routing_table->slots[loop].slot;\r\nif (tslot == slot) {\r\n*bus_num = tbus;\r\n*dev_num = tdevice;\r\nctrl->pci_bus->number = tbus;\r\npci_bus_read_config_dword (ctrl->pci_bus, *dev_num, PCI_VENDOR_ID, &work);\r\nif (!nobridge || (work == 0xffffffff))\r\nreturn 0;\r\ndbg("bus_num %d devfn %d\n", *bus_num, *dev_num);\r\npci_bus_read_config_dword (ctrl->pci_bus, *dev_num, PCI_CLASS_REVISION, &work);\r\ndbg("work >> 8 (%x) = BRIDGE (%x)\n", work >> 8, PCI_TO_PCI_BRIDGE_CLASS);\r\nif ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {\r\npci_bus_read_config_byte (ctrl->pci_bus, *dev_num, PCI_SECONDARY_BUS, &tbus);\r\ndbg("Scan bus for Non Bridge: bus %d\n", tbus);\r\nif (PCI_ScanBusForNonBridge(ctrl, tbus, dev_num) == 0) {\r\n*bus_num = tbus;\r\nreturn 0;\r\n}\r\n} else\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint cpqhp_get_bus_dev (struct controller *ctrl, u8 * bus_num, u8 * dev_num, u8 slot)\r\n{\r\nreturn PCI_GetBusDevHelper(ctrl, bus_num, dev_num, slot, 0);\r\n}\r\nint cpqhp_save_config(struct controller *ctrl, int busnumber, int is_hot_plug)\r\n{\r\nlong rc;\r\nu8 class_code;\r\nu8 header_type;\r\nu32 ID;\r\nu8 secondary_bus;\r\nstruct pci_func *new_slot;\r\nint sub_bus;\r\nint FirstSupported;\r\nint LastSupported;\r\nint max_functions;\r\nint function;\r\nu8 DevError;\r\nint device = 0;\r\nint cloop = 0;\r\nint stop_it;\r\nint index;\r\nif (is_hot_plug) {\r\nFirstSupported = is_hot_plug >> 4;\r\nLastSupported = FirstSupported + (is_hot_plug & 0x0F) - 1;\r\n} else {\r\nFirstSupported = 0;\r\nLastSupported = 0x1F;\r\n}\r\nctrl->pci_bus->number = busnumber;\r\nfor (device = FirstSupported; device <= LastSupported; device++) {\r\nID = 0xFFFFFFFF;\r\nrc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, 0), PCI_VENDOR_ID, &ID);\r\nif (ID == 0xFFFFFFFF) {\r\nif (is_hot_plug) {\r\nnew_slot = cpqhp_slot_create(busnumber);\r\nif (new_slot == NULL)\r\nreturn 1;\r\nnew_slot->bus = (u8) busnumber;\r\nnew_slot->device = (u8) device;\r\nnew_slot->function = 0;\r\nnew_slot->is_a_board = 0;\r\nnew_slot->presence_save = 0;\r\nnew_slot->switch_save = 0;\r\n}\r\ncontinue;\r\n}\r\nrc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, 0), 0x0B, &class_code);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, 0), PCI_HEADER_TYPE, &header_type);\r\nif (rc)\r\nreturn rc;\r\nif (header_type & 0x80)\r\nmax_functions = 8;\r\nelse\r\nmax_functions = 1;\r\nfunction = 0;\r\ndo {\r\nDevError = 0;\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\nrc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_SECONDARY_BUS, &secondary_bus);\r\nif (rc) {\r\nreturn rc;\r\n} else {\r\nsub_bus = (int) secondary_bus;\r\nrc = cpqhp_save_config(ctrl, sub_bus, 0);\r\nif (rc)\r\nreturn rc;\r\nctrl->pci_bus->number = busnumber;\r\n}\r\n}\r\nindex = 0;\r\nnew_slot = cpqhp_slot_find(busnumber, device, index++);\r\nwhile (new_slot &&\r\n(new_slot->function != (u8) function))\r\nnew_slot = cpqhp_slot_find(busnumber, device, index++);\r\nif (!new_slot) {\r\nnew_slot = cpqhp_slot_create(busnumber);\r\nif (new_slot == NULL)\r\nreturn 1;\r\n}\r\nnew_slot->bus = (u8) busnumber;\r\nnew_slot->device = (u8) device;\r\nnew_slot->function = (u8) function;\r\nnew_slot->is_a_board = 1;\r\nnew_slot->switch_save = 0x10;\r\nnew_slot->status = DevError;\r\nnew_slot->pci_dev = pci_get_bus_and_slot(new_slot->bus, (new_slot->device << 3) | new_slot->function);\r\nfor (cloop = 0; cloop < 0x20; cloop++) {\r\nrc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, function), cloop << 2, (u32 *) & (new_slot-> config_space [cloop]));\r\nif (rc)\r\nreturn rc;\r\n}\r\npci_dev_put(new_slot->pci_dev);\r\nfunction++;\r\nstop_it = 0;\r\nwhile ((function < max_functions) && (!stop_it)) {\r\nrc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_VENDOR_ID, &ID);\r\nif (ID == 0xFFFFFFFF) {\r\nfunction++;\r\ncontinue;\r\n}\r\nrc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), 0x0B, &class_code);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_HEADER_TYPE, &header_type);\r\nif (rc)\r\nreturn rc;\r\nstop_it++;\r\n}\r\n} while (function < max_functions);\r\n}\r\nreturn 0;\r\n}\r\nint cpqhp_save_slot_config (struct controller *ctrl, struct pci_func * new_slot)\r\n{\r\nlong rc;\r\nu8 class_code;\r\nu8 header_type;\r\nu32 ID;\r\nu8 secondary_bus;\r\nint sub_bus;\r\nint max_functions;\r\nint function = 0;\r\nint cloop = 0;\r\nint stop_it;\r\nID = 0xFFFFFFFF;\r\nctrl->pci_bus->number = new_slot->bus;\r\npci_bus_read_config_dword (ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), PCI_VENDOR_ID, &ID);\r\nif (ID == 0xFFFFFFFF)\r\nreturn 2;\r\npci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), 0x0B, &class_code);\r\npci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), PCI_HEADER_TYPE, &header_type);\r\nif (header_type & 0x80)\r\nmax_functions = 8;\r\nelse\r\nmax_functions = 1;\r\nwhile (function < max_functions) {\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\npci_bus_read_config_byte (ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_SECONDARY_BUS, &secondary_bus);\r\nsub_bus = (int) secondary_bus;\r\nrc = cpqhp_save_config(ctrl, sub_bus, 0);\r\nif (rc)\r\nreturn(rc);\r\nctrl->pci_bus->number = new_slot->bus;\r\n}\r\nnew_slot->status = 0;\r\nfor (cloop = 0; cloop < 0x20; cloop++)\r\npci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), cloop << 2, (u32 *) & (new_slot-> config_space [cloop]));\r\nfunction++;\r\nstop_it = 0;\r\nwhile ((function < max_functions) && (!stop_it)) {\r\npci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_VENDOR_ID, &ID);\r\nif (ID == 0xFFFFFFFF)\r\nfunction++;\r\nelse {\r\npci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), 0x0B, &class_code);\r\npci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_HEADER_TYPE, &header_type);\r\nstop_it++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cpqhp_save_base_addr_length(struct controller *ctrl, struct pci_func * func)\r\n{\r\nu8 cloop;\r\nu8 header_type;\r\nu8 secondary_bus;\r\nu8 type;\r\nint sub_bus;\r\nu32 temp_register;\r\nu32 base;\r\nu32 rc;\r\nstruct pci_func *next;\r\nint index = 0;\r\nstruct pci_bus *pci_bus = ctrl->pci_bus;\r\nunsigned int devfn;\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\nwhile (func != NULL) {\r\npci_bus->number = func->bus;\r\ndevfn = PCI_DEVFN(func->device, func->function);\r\npci_bus_read_config_byte (pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\npci_bus_read_config_byte (pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);\r\nsub_bus = (int) secondary_bus;\r\nnext = cpqhp_slot_list[sub_bus];\r\nwhile (next != NULL) {\r\nrc = cpqhp_save_base_addr_length(ctrl, next);\r\nif (rc)\r\nreturn rc;\r\nnext = next->next;\r\n}\r\npci_bus->number = func->bus;\r\nfor (cloop = 0x10; cloop <= 0x14; cloop += 4) {\r\ntemp_register = 0xFFFFFFFF;\r\npci_bus_write_config_dword (pci_bus, devfn, cloop, temp_register);\r\npci_bus_read_config_dword (pci_bus, devfn, cloop, &base);\r\nif (base) {\r\nif (base & 0x01L) {\r\nbase = base & 0xFFFFFFFE;\r\nbase = (~base) + 1;\r\ntype = 1;\r\n} else {\r\nbase = base & 0xFFFFFFF0;\r\nbase = (~base) + 1;\r\ntype = 0;\r\n}\r\n} else {\r\nbase = 0x0L;\r\ntype = 0;\r\n}\r\nfunc->base_length[(cloop - 0x10) >> 2] =\r\nbase;\r\nfunc->base_type[(cloop - 0x10) >> 2] = type;\r\n}\r\n} else if ((header_type & 0x7F) == 0x00) {\r\nfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\r\ntemp_register = 0xFFFFFFFF;\r\npci_bus_write_config_dword (pci_bus, devfn, cloop, temp_register);\r\npci_bus_read_config_dword (pci_bus, devfn, cloop, &base);\r\nif (base) {\r\nif (base & 0x01L) {\r\nbase = base & 0xFFFFFFFE;\r\nbase = (~base) + 1;\r\ntype = 1;\r\n} else {\r\nbase = base & 0xFFFFFFF0;\r\nbase = (~base) + 1;\r\ntype = 0;\r\n}\r\n} else {\r\nbase = 0x0L;\r\ntype = 0;\r\n}\r\nfunc->base_length[(cloop - 0x10) >> 2] = base;\r\nfunc->base_type[(cloop - 0x10) >> 2] = type;\r\n}\r\n} else {\r\n}\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\n}\r\nreturn(0);\r\n}\r\nint cpqhp_save_used_resources (struct controller *ctrl, struct pci_func * func)\r\n{\r\nu8 cloop;\r\nu8 header_type;\r\nu8 secondary_bus;\r\nu8 temp_byte;\r\nu8 b_base;\r\nu8 b_length;\r\nu16 command;\r\nu16 save_command;\r\nu16 w_base;\r\nu16 w_length;\r\nu32 temp_register;\r\nu32 save_base;\r\nu32 base;\r\nint index = 0;\r\nstruct pci_resource *mem_node;\r\nstruct pci_resource *p_mem_node;\r\nstruct pci_resource *io_node;\r\nstruct pci_resource *bus_node;\r\nstruct pci_bus *pci_bus = ctrl->pci_bus;\r\nunsigned int devfn;\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\nwhile ((func != NULL) && func->is_a_board) {\r\npci_bus->number = func->bus;\r\ndevfn = PCI_DEVFN(func->device, func->function);\r\npci_bus_read_config_word(pci_bus, devfn, PCI_COMMAND, &save_command);\r\ncommand = 0x00;\r\npci_bus_write_config_word(pci_bus, devfn, PCI_COMMAND, command);\r\npci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\ncommand = 0x00;\r\npci_bus_write_config_word(pci_bus, devfn, PCI_BRIDGE_CONTROL, command);\r\npci_bus_read_config_byte(pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);\r\npci_bus_read_config_byte(pci_bus, devfn, PCI_SUBORDINATE_BUS, &temp_byte);\r\nbus_node = kmalloc(sizeof(*bus_node), GFP_KERNEL);\r\nif (!bus_node)\r\nreturn -ENOMEM;\r\nbus_node->base = secondary_bus;\r\nbus_node->length = temp_byte - secondary_bus + 1;\r\nbus_node->next = func->bus_head;\r\nfunc->bus_head = bus_node;\r\npci_bus_read_config_byte(pci_bus, devfn, PCI_IO_BASE, &b_base);\r\npci_bus_read_config_byte(pci_bus, devfn, PCI_IO_LIMIT, &b_length);\r\nif ((b_base <= b_length) && (save_command & 0x01)) {\r\nio_node = kmalloc(sizeof(*io_node), GFP_KERNEL);\r\nif (!io_node)\r\nreturn -ENOMEM;\r\nio_node->base = (b_base & 0xF0) << 8;\r\nio_node->length = (b_length - b_base + 0x10) << 8;\r\nio_node->next = func->io_head;\r\nfunc->io_head = io_node;\r\n}\r\npci_bus_read_config_word(pci_bus, devfn, PCI_MEMORY_BASE, &w_base);\r\npci_bus_read_config_word(pci_bus, devfn, PCI_MEMORY_LIMIT, &w_length);\r\nif ((w_base <= w_length) && (save_command & 0x02)) {\r\nmem_node = kmalloc(sizeof(*mem_node), GFP_KERNEL);\r\nif (!mem_node)\r\nreturn -ENOMEM;\r\nmem_node->base = w_base << 16;\r\nmem_node->length = (w_length - w_base + 0x10) << 16;\r\nmem_node->next = func->mem_head;\r\nfunc->mem_head = mem_node;\r\n}\r\npci_bus_read_config_word(pci_bus, devfn, PCI_PREF_MEMORY_BASE, &w_base);\r\npci_bus_read_config_word(pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, &w_length);\r\nif ((w_base <= w_length) && (save_command & 0x02)) {\r\np_mem_node = kmalloc(sizeof(*p_mem_node), GFP_KERNEL);\r\nif (!p_mem_node)\r\nreturn -ENOMEM;\r\np_mem_node->base = w_base << 16;\r\np_mem_node->length = (w_length - w_base + 0x10) << 16;\r\np_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = p_mem_node;\r\n}\r\nfor (cloop = 0x10; cloop <= 0x14; cloop += 4) {\r\npci_bus_read_config_dword (pci_bus, devfn, cloop, &save_base);\r\ntemp_register = 0xFFFFFFFF;\r\npci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\r\npci_bus_read_config_dword(pci_bus, devfn, cloop, &base);\r\ntemp_register = base;\r\nif (base) {\r\nif (((base & 0x03L) == 0x01)\r\n&& (save_command & 0x01)) {\r\ntemp_register = base & 0xFFFFFFFE;\r\ntemp_register = (~temp_register) + 1;\r\nio_node = kmalloc(sizeof(*io_node),\r\nGFP_KERNEL);\r\nif (!io_node)\r\nreturn -ENOMEM;\r\nio_node->base =\r\nsave_base & (~0x03L);\r\nio_node->length = temp_register;\r\nio_node->next = func->io_head;\r\nfunc->io_head = io_node;\r\n} else\r\nif (((base & 0x0BL) == 0x08)\r\n&& (save_command & 0x02)) {\r\ntemp_register = base & 0xFFFFFFF0;\r\ntemp_register = (~temp_register) + 1;\r\np_mem_node = kmalloc(sizeof(*p_mem_node),\r\nGFP_KERNEL);\r\nif (!p_mem_node)\r\nreturn -ENOMEM;\r\np_mem_node->base = save_base & (~0x0FL);\r\np_mem_node->length = temp_register;\r\np_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = p_mem_node;\r\n} else\r\nif (((base & 0x0BL) == 0x00)\r\n&& (save_command & 0x02)) {\r\ntemp_register = base & 0xFFFFFFF0;\r\ntemp_register = (~temp_register) + 1;\r\nmem_node = kmalloc(sizeof(*mem_node),\r\nGFP_KERNEL);\r\nif (!mem_node)\r\nreturn -ENOMEM;\r\nmem_node->base = save_base & (~0x0FL);\r\nmem_node->length = temp_register;\r\nmem_node->next = func->mem_head;\r\nfunc->mem_head = mem_node;\r\n} else\r\nreturn(1);\r\n}\r\n}\r\n} else if ((header_type & 0x7F) == 0x00) {\r\nfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\r\npci_bus_read_config_dword(pci_bus, devfn, cloop, &save_base);\r\ntemp_register = 0xFFFFFFFF;\r\npci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\r\npci_bus_read_config_dword(pci_bus, devfn, cloop, &base);\r\ntemp_register = base;\r\nif (base) {\r\nif (((base & 0x03L) == 0x01)\r\n&& (save_command & 0x01)) {\r\ntemp_register = base & 0xFFFFFFFE;\r\ntemp_register = (~temp_register) + 1;\r\nio_node = kmalloc(sizeof(*io_node),\r\nGFP_KERNEL);\r\nif (!io_node)\r\nreturn -ENOMEM;\r\nio_node->base = save_base & (~0x01L);\r\nio_node->length = temp_register;\r\nio_node->next = func->io_head;\r\nfunc->io_head = io_node;\r\n} else\r\nif (((base & 0x0BL) == 0x08)\r\n&& (save_command & 0x02)) {\r\ntemp_register = base & 0xFFFFFFF0;\r\ntemp_register = (~temp_register) + 1;\r\np_mem_node = kmalloc(sizeof(*p_mem_node),\r\nGFP_KERNEL);\r\nif (!p_mem_node)\r\nreturn -ENOMEM;\r\np_mem_node->base = save_base & (~0x0FL);\r\np_mem_node->length = temp_register;\r\np_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = p_mem_node;\r\n} else\r\nif (((base & 0x0BL) == 0x00)\r\n&& (save_command & 0x02)) {\r\ntemp_register = base & 0xFFFFFFF0;\r\ntemp_register = (~temp_register) + 1;\r\nmem_node = kmalloc(sizeof(*mem_node),\r\nGFP_KERNEL);\r\nif (!mem_node)\r\nreturn -ENOMEM;\r\nmem_node->base = save_base & (~0x0FL);\r\nmem_node->length = temp_register;\r\nmem_node->next = func->mem_head;\r\nfunc->mem_head = mem_node;\r\n} else\r\nreturn(1);\r\n}\r\n}\r\n}\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\n}\r\nreturn 0;\r\n}\r\nint cpqhp_configure_board(struct controller *ctrl, struct pci_func * func)\r\n{\r\nint cloop;\r\nu8 header_type;\r\nu8 secondary_bus;\r\nint sub_bus;\r\nstruct pci_func *next;\r\nu32 temp;\r\nu32 rc;\r\nint index = 0;\r\nstruct pci_bus *pci_bus = ctrl->pci_bus;\r\nunsigned int devfn;\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\nwhile (func != NULL) {\r\npci_bus->number = func->bus;\r\ndevfn = PCI_DEVFN(func->device, func->function);\r\nfor (cloop = 0x3C; cloop > 0; cloop -= 4)\r\npci_bus_write_config_dword (pci_bus, devfn, cloop, func->config_space[cloop >> 2]);\r\npci_bus_read_config_byte (pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\npci_bus_read_config_byte (pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);\r\nsub_bus = (int) secondary_bus;\r\nnext = cpqhp_slot_list[sub_bus];\r\nwhile (next != NULL) {\r\nrc = cpqhp_configure_board(ctrl, next);\r\nif (rc)\r\nreturn rc;\r\nnext = next->next;\r\n}\r\n} else {\r\nfor (cloop = 16; cloop < 40; cloop += 4) {\r\npci_bus_read_config_dword (pci_bus, devfn, cloop, &temp);\r\nif (temp != func->config_space[cloop >> 2]) {\r\ndbg("Config space compare failure!!! offset = %x\n", cloop);\r\ndbg("bus = %x, device = %x, function = %x\n", func->bus, func->device, func->function);\r\ndbg("temp = %x, config space = %x\n\n", temp, func->config_space[cloop >> 2]);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nfunc->configured = 1;\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\n}\r\nreturn 0;\r\n}\r\nint cpqhp_valid_replace(struct controller *ctrl, struct pci_func * func)\r\n{\r\nu8 cloop;\r\nu8 header_type;\r\nu8 secondary_bus;\r\nu8 type;\r\nu32 temp_register = 0;\r\nu32 base;\r\nu32 rc;\r\nstruct pci_func *next;\r\nint index = 0;\r\nstruct pci_bus *pci_bus = ctrl->pci_bus;\r\nunsigned int devfn;\r\nif (!func->is_a_board)\r\nreturn(ADD_NOT_SUPPORTED);\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\nwhile (func != NULL) {\r\npci_bus->number = func->bus;\r\ndevfn = PCI_DEVFN(func->device, func->function);\r\npci_bus_read_config_dword (pci_bus, devfn, PCI_VENDOR_ID, &temp_register);\r\nif (temp_register == 0xFFFFFFFF)\r\nreturn(NO_ADAPTER_PRESENT);\r\nif (temp_register != func->config_space[0])\r\nreturn(ADAPTER_NOT_SAME);\r\npci_bus_read_config_dword (pci_bus, devfn, PCI_CLASS_REVISION, &temp_register);\r\nif (temp_register != func->config_space[0x08 >> 2])\r\nreturn(ADAPTER_NOT_SAME);\r\npci_bus_read_config_byte (pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\ntemp_register = func->config_space[0x18 >> 2];\r\npci_bus_write_config_dword (pci_bus, devfn, PCI_PRIMARY_BUS, temp_register);\r\nsecondary_bus = (temp_register >> 8) & 0xFF;\r\nnext = cpqhp_slot_list[secondary_bus];\r\nwhile (next != NULL) {\r\nrc = cpqhp_valid_replace(ctrl, next);\r\nif (rc)\r\nreturn rc;\r\nnext = next->next;\r\n}\r\n}\r\nelse if ((header_type & 0x7F) == PCI_HEADER_TYPE_NORMAL) {\r\npci_bus_read_config_dword (pci_bus, devfn, PCI_SUBSYSTEM_VENDOR_ID, &temp_register);\r\nif (temp_register != func->config_space[0x2C >> 2]) {\r\nif (!((func->config_space[0] == 0xAE100E11)\r\n&& (temp_register == 0x00L)))\r\nreturn(ADAPTER_NOT_SAME);\r\n}\r\nfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\r\ntemp_register = 0xFFFFFFFF;\r\npci_bus_write_config_dword (pci_bus, devfn, cloop, temp_register);\r\npci_bus_read_config_dword (pci_bus, devfn, cloop, &base);\r\nif (base) {\r\nif (base & 0x01L) {\r\nbase = base & 0xFFFFFFFE;\r\nbase = (~base) + 1;\r\ntype = 1;\r\n} else {\r\nbase = base & 0xFFFFFFF0;\r\nbase = (~base) + 1;\r\ntype = 0;\r\n}\r\n} else {\r\nbase = 0x0L;\r\ntype = 0;\r\n}\r\nif (func->base_length[(cloop - 0x10) >> 2] != base)\r\nreturn(ADAPTER_NOT_SAME);\r\nif (func->base_type[(cloop - 0x10) >> 2] != type)\r\nreturn(ADAPTER_NOT_SAME);\r\n}\r\n}\r\nelse {\r\nreturn(DEVICE_TYPE_NOT_SUPPORTED);\r\n}\r\nfunc = cpqhp_slot_find(func->bus, func->device, index++);\r\n}\r\nreturn 0;\r\n}\r\nint cpqhp_find_available_resources(struct controller *ctrl, void __iomem *rom_start)\r\n{\r\nu8 temp;\r\nu8 populated_slot;\r\nu8 bridged_slot;\r\nvoid __iomem *one_slot;\r\nvoid __iomem *rom_resource_table;\r\nstruct pci_func *func = NULL;\r\nint i = 10, index;\r\nu32 temp_dword, rc;\r\nstruct pci_resource *mem_node;\r\nstruct pci_resource *p_mem_node;\r\nstruct pci_resource *io_node;\r\nstruct pci_resource *bus_node;\r\nrom_resource_table = detect_HRT_floating_pointer(rom_start, rom_start+0xffff);\r\ndbg("rom_resource_table = %p\n", rom_resource_table);\r\nif (rom_resource_table == NULL)\r\nreturn -ENODEV;\r\nunused_IRQ = readl(rom_resource_table + UNUSED_IRQ);\r\ndbg("unused_IRQ = %x\n", unused_IRQ);\r\ntemp = 0;\r\nwhile (unused_IRQ) {\r\nif (unused_IRQ & 1) {\r\ncpqhp_disk_irq = temp;\r\nbreak;\r\n}\r\nunused_IRQ = unused_IRQ >> 1;\r\ntemp++;\r\n}\r\ndbg("cpqhp_disk_irq= %d\n", cpqhp_disk_irq);\r\nunused_IRQ = unused_IRQ >> 1;\r\ntemp++;\r\nwhile (unused_IRQ) {\r\nif (unused_IRQ & 1) {\r\ncpqhp_nic_irq = temp;\r\nbreak;\r\n}\r\nunused_IRQ = unused_IRQ >> 1;\r\ntemp++;\r\n}\r\ndbg("cpqhp_nic_irq= %d\n", cpqhp_nic_irq);\r\nunused_IRQ = readl(rom_resource_table + PCIIRQ);\r\ntemp = 0;\r\nif (!cpqhp_nic_irq)\r\ncpqhp_nic_irq = ctrl->cfgspc_irq;\r\nif (!cpqhp_disk_irq)\r\ncpqhp_disk_irq = ctrl->cfgspc_irq;\r\ndbg("cpqhp_disk_irq, cpqhp_nic_irq= %d, %d\n", cpqhp_disk_irq, cpqhp_nic_irq);\r\nrc = compaq_nvram_load(rom_start, ctrl);\r\nif (rc)\r\nreturn rc;\r\none_slot = rom_resource_table + sizeof (struct hrt);\r\ni = readb(rom_resource_table + NUMBER_OF_ENTRIES);\r\ndbg("number_of_entries = %d\n", i);\r\nif (!readb(one_slot + SECONDARY_BUS))\r\nreturn 1;\r\ndbg("dev|IO base|length|Mem base|length|Pre base|length|PB SB MB\n");\r\nwhile (i && readb(one_slot + SECONDARY_BUS)) {\r\nu8 dev_func = readb(one_slot + DEV_FUNC);\r\nu8 primary_bus = readb(one_slot + PRIMARY_BUS);\r\nu8 secondary_bus = readb(one_slot + SECONDARY_BUS);\r\nu8 max_bus = readb(one_slot + MAX_BUS);\r\nu16 io_base = readw(one_slot + IO_BASE);\r\nu16 io_length = readw(one_slot + IO_LENGTH);\r\nu16 mem_base = readw(one_slot + MEM_BASE);\r\nu16 mem_length = readw(one_slot + MEM_LENGTH);\r\nu16 pre_mem_base = readw(one_slot + PRE_MEM_BASE);\r\nu16 pre_mem_length = readw(one_slot + PRE_MEM_LENGTH);\r\ndbg("%2.2x | %4.4x | %4.4x | %4.4x | %4.4x | %4.4x | %4.4x |%2.2x %2.2x %2.2x\n",\r\ndev_func, io_base, io_length, mem_base, mem_length, pre_mem_base, pre_mem_length,\r\nprimary_bus, secondary_bus, max_bus);\r\nif (primary_bus != ctrl->bus) {\r\ni--;\r\none_slot += sizeof (struct slot_rt);\r\ncontinue;\r\n}\r\nctrl->pci_bus->number = primary_bus;\r\npci_bus_read_config_dword (ctrl->pci_bus, dev_func, PCI_VENDOR_ID, &temp_dword);\r\ndbg("temp_D_word = %x\n", temp_dword);\r\nif (temp_dword != 0xFFFFFFFF) {\r\nindex = 0;\r\nfunc = cpqhp_slot_find(primary_bus, dev_func >> 3, 0);\r\nwhile (func && (func->function != (dev_func & 0x07))) {\r\ndbg("func = %p (bus, dev, fun) = (%d, %d, %d)\n", func, primary_bus, dev_func >> 3, index);\r\nfunc = cpqhp_slot_find(primary_bus, dev_func >> 3, index++);\r\n}\r\nif (!func) {\r\ni--;\r\none_slot += sizeof (struct slot_rt);\r\ncontinue;\r\n}\r\nif (secondary_bus != primary_bus)\r\nbridged_slot = 1;\r\nelse\r\nbridged_slot = 0;\r\npopulated_slot = 1;\r\n} else {\r\npopulated_slot = 0;\r\nbridged_slot = 0;\r\n}\r\ntemp_dword = io_base + io_length;\r\nif ((io_base) && (temp_dword < 0x10000)) {\r\nio_node = kmalloc(sizeof(*io_node), GFP_KERNEL);\r\nif (!io_node)\r\nreturn -ENOMEM;\r\nio_node->base = io_base;\r\nio_node->length = io_length;\r\ndbg("found io_node(base, length) = %x, %x\n",\r\nio_node->base, io_node->length);\r\ndbg("populated slot =%d \n", populated_slot);\r\nif (!populated_slot) {\r\nio_node->next = ctrl->io_head;\r\nctrl->io_head = io_node;\r\n} else {\r\nio_node->next = func->io_head;\r\nfunc->io_head = io_node;\r\n}\r\n}\r\ntemp_dword = mem_base + mem_length;\r\nif ((mem_base) && (temp_dword < 0x10000)) {\r\nmem_node = kmalloc(sizeof(*mem_node), GFP_KERNEL);\r\nif (!mem_node)\r\nreturn -ENOMEM;\r\nmem_node->base = mem_base << 16;\r\nmem_node->length = mem_length << 16;\r\ndbg("found mem_node(base, length) = %x, %x\n",\r\nmem_node->base, mem_node->length);\r\ndbg("populated slot =%d \n", populated_slot);\r\nif (!populated_slot) {\r\nmem_node->next = ctrl->mem_head;\r\nctrl->mem_head = mem_node;\r\n} else {\r\nmem_node->next = func->mem_head;\r\nfunc->mem_head = mem_node;\r\n}\r\n}\r\ntemp_dword = pre_mem_base + pre_mem_length;\r\nif ((pre_mem_base) && (temp_dword < 0x10000)) {\r\np_mem_node = kmalloc(sizeof(*p_mem_node), GFP_KERNEL);\r\nif (!p_mem_node)\r\nreturn -ENOMEM;\r\np_mem_node->base = pre_mem_base << 16;\r\np_mem_node->length = pre_mem_length << 16;\r\ndbg("found p_mem_node(base, length) = %x, %x\n",\r\np_mem_node->base, p_mem_node->length);\r\ndbg("populated slot =%d \n", populated_slot);\r\nif (!populated_slot) {\r\np_mem_node->next = ctrl->p_mem_head;\r\nctrl->p_mem_head = p_mem_node;\r\n} else {\r\np_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = p_mem_node;\r\n}\r\n}\r\nif (secondary_bus && (secondary_bus != primary_bus)) {\r\nbus_node = kmalloc(sizeof(*bus_node), GFP_KERNEL);\r\nif (!bus_node)\r\nreturn -ENOMEM;\r\nbus_node->base = secondary_bus;\r\nbus_node->length = max_bus - secondary_bus + 1;\r\ndbg("found bus_node(base, length) = %x, %x\n",\r\nbus_node->base, bus_node->length);\r\ndbg("populated slot =%d \n", populated_slot);\r\nif (!populated_slot) {\r\nbus_node->next = ctrl->bus_head;\r\nctrl->bus_head = bus_node;\r\n} else {\r\nbus_node->next = func->bus_head;\r\nfunc->bus_head = bus_node;\r\n}\r\n}\r\ni--;\r\none_slot += sizeof (struct slot_rt);\r\n}\r\nrc = 1;\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->mem_head));\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->io_head));\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->bus_head));\r\nreturn rc;\r\n}\r\nint cpqhp_return_board_resources(struct pci_func * func, struct resource_lists * resources)\r\n{\r\nint rc = 0;\r\nstruct pci_resource *node;\r\nstruct pci_resource *t_node;\r\ndbg("%s\n", __func__);\r\nif (!func)\r\nreturn 1;\r\nnode = func->io_head;\r\nfunc->io_head = NULL;\r\nwhile (node) {\r\nt_node = node->next;\r\nreturn_resource(&(resources->io_head), node);\r\nnode = t_node;\r\n}\r\nnode = func->mem_head;\r\nfunc->mem_head = NULL;\r\nwhile (node) {\r\nt_node = node->next;\r\nreturn_resource(&(resources->mem_head), node);\r\nnode = t_node;\r\n}\r\nnode = func->p_mem_head;\r\nfunc->p_mem_head = NULL;\r\nwhile (node) {\r\nt_node = node->next;\r\nreturn_resource(&(resources->p_mem_head), node);\r\nnode = t_node;\r\n}\r\nnode = func->bus_head;\r\nfunc->bus_head = NULL;\r\nwhile (node) {\r\nt_node = node->next;\r\nreturn_resource(&(resources->bus_head), node);\r\nnode = t_node;\r\n}\r\nrc |= cpqhp_resource_sort_and_combine(&(resources->mem_head));\r\nrc |= cpqhp_resource_sort_and_combine(&(resources->p_mem_head));\r\nrc |= cpqhp_resource_sort_and_combine(&(resources->io_head));\r\nrc |= cpqhp_resource_sort_and_combine(&(resources->bus_head));\r\nreturn rc;\r\n}\r\nvoid cpqhp_destroy_resource_list (struct resource_lists * resources)\r\n{\r\nstruct pci_resource *res, *tres;\r\nres = resources->io_head;\r\nresources->io_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = resources->mem_head;\r\nresources->mem_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = resources->p_mem_head;\r\nresources->p_mem_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = resources->bus_head;\r\nresources->bus_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\n}\r\nvoid cpqhp_destroy_board_resources (struct pci_func * func)\r\n{\r\nstruct pci_resource *res, *tres;\r\nres = func->io_head;\r\nfunc->io_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = func->mem_head;\r\nfunc->mem_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = func->p_mem_head;\r\nfunc->p_mem_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = func->bus_head;\r\nfunc->bus_head = NULL;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\n}
