static int quanta_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nswitch (usage->hid & HID_USAGE_PAGE) {\r\ncase HID_UP_GENDESK:\r\nswitch (usage->hid) {\r\ncase HID_GD_X:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_POSITION_X);\r\ninput_set_abs_params(hi->input, ABS_X,\r\nfield->logical_minimum,\r\nfield->logical_maximum, 0, 0);\r\nreturn 1;\r\ncase HID_GD_Y:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_POSITION_Y);\r\ninput_set_abs_params(hi->input, ABS_Y,\r\nfield->logical_minimum,\r\nfield->logical_maximum, 0, 0);\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase HID_UP_DIGITIZER:\r\nswitch (usage->hid) {\r\ncase HID_DG_CONFIDENCE:\r\ncase HID_DG_TIPSWITCH:\r\ncase HID_DG_INPUTMODE:\r\ncase HID_DG_DEVICEINDEX:\r\ncase HID_DG_CONTACTCOUNT:\r\ncase HID_DG_CONTACTMAX:\r\ncase HID_DG_TIPPRESSURE:\r\ncase HID_DG_WIDTH:\r\ncase HID_DG_HEIGHT:\r\nreturn -1;\r\ncase HID_DG_INRANGE:\r\nhid_map_usage(hi, usage, bit, max, EV_KEY, BTN_TOUCH);\r\nreturn 1;\r\ncase HID_DG_CONTACTID:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_TRACKING_ID);\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase 0xff000000:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int quanta_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif (usage->type == EV_KEY || usage->type == EV_ABS)\r\nclear_bit(usage->code, *bit);\r\nreturn 0;\r\n}\r\nstatic void quanta_filter_event(struct quanta_data *td, struct input_dev *input)\r\n{\r\ntd->first = !td->first;\r\nif (!td->valid) {\r\nif (!td->first && !td->activity_now && td->activity) {\r\ninput_event(input, EV_KEY, BTN_TOUCH, 0);\r\ntd->activity = false;\r\n}\r\nreturn;\r\n}\r\ninput_event(input, EV_ABS, ABS_MT_TRACKING_ID, td->id);\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_X, td->x);\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_Y, td->y);\r\ninput_mt_sync(input);\r\ntd->valid = false;\r\nif (!td->activity_now) {\r\nif (!td->activity) {\r\ninput_event(input, EV_KEY, BTN_TOUCH, 1);\r\ntd->activity = true;\r\n}\r\ntd->activity_now = true;\r\ninput_event(input, EV_ABS, ABS_X, td->x);\r\ninput_event(input, EV_ABS, ABS_Y, td->y);\r\n}\r\n}\r\nstatic int quanta_event(struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct quanta_data *td = hid_get_drvdata(hid);\r\nif (hid->claimed & HID_CLAIMED_INPUT) {\r\nstruct input_dev *input = field->hidinput->input;\r\nswitch (usage->hid) {\r\ncase HID_DG_INRANGE:\r\ntd->valid = !!value;\r\nbreak;\r\ncase HID_GD_X:\r\ntd->x = value;\r\nbreak;\r\ncase HID_GD_Y:\r\ntd->y = value;\r\nquanta_filter_event(td, input);\r\nbreak;\r\ncase HID_DG_CONTACTID:\r\ntd->id = value;\r\nbreak;\r\ncase HID_DG_CONTACTCOUNT:\r\ntd->first = false;\r\ntd->activity_now = false;\r\nbreak;\r\ncase HID_DG_CONFIDENCE:\r\ncase HID_DG_TIPSWITCH:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nif (hid->claimed & HID_CLAIMED_HIDDEV && hid->hiddev_hid_event)\r\nhid->hiddev_hid_event(hid, field, usage, value);\r\nreturn 1;\r\n}\r\nstatic int quanta_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct quanta_data *td;\r\ntd = kmalloc(sizeof(struct quanta_data), GFP_KERNEL);\r\nif (!td) {\r\nhid_err(hdev, "cannot allocate Quanta Touch data\n");\r\nreturn -ENOMEM;\r\n}\r\ntd->valid = false;\r\ntd->activity = false;\r\ntd->activity_now = false;\r\ntd->first = false;\r\nhid_set_drvdata(hdev, td);\r\nret = hid_parse(hdev);\r\nif (!ret)\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret)\r\nkfree(td);\r\nreturn ret;\r\n}\r\nstatic void quanta_remove(struct hid_device *hdev)\r\n{\r\nhid_hw_stop(hdev);\r\nkfree(hid_get_drvdata(hdev));\r\nhid_set_drvdata(hdev, NULL);\r\n}\r\nstatic int __init quanta_init(void)\r\n{\r\nreturn hid_register_driver(&quanta_driver);\r\n}\r\nstatic void __exit quanta_exit(void)\r\n{\r\nhid_unregister_driver(&quanta_driver);\r\n}
