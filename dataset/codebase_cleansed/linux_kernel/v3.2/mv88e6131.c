static char *mv88e6131_probe(struct mii_bus *bus, int sw_addr)\r\n{\r\nint ret;\r\nret = __mv88e6xxx_reg_read(bus, sw_addr, REG_PORT(0), 0x03);\r\nif (ret >= 0) {\r\nret &= 0xfff0;\r\nif (ret == ID_6085)\r\nreturn "Marvell 88E6085";\r\nif (ret == ID_6095)\r\nreturn "Marvell 88E6095/88E6095F";\r\nif (ret == ID_6131)\r\nreturn "Marvell 88E6131";\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mv88e6131_switch_reset(struct dsa_switch *ds)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < 11; i++) {\r\nret = REG_READ(REG_PORT(i), 0x04);\r\nREG_WRITE(REG_PORT(i), 0x04, ret & 0xfffc);\r\n}\r\nmsleep(2);\r\nREG_WRITE(REG_GLOBAL, 0x04, 0xc400);\r\nfor (i = 0; i < 1000; i++) {\r\nret = REG_READ(REG_GLOBAL, 0x00);\r\nif ((ret & 0xc800) == 0xc800)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (i == 1000)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int mv88e6131_setup_global(struct dsa_switch *ds)\r\n{\r\nint ret;\r\nint i;\r\nREG_WRITE(REG_GLOBAL, 0x04, 0x4400);\r\nREG_WRITE(REG_GLOBAL, 0x0a, 0x0148);\r\nret = mv88e6xxx_config_prio(ds);\r\nif (ret < 0)\r\nreturn ret;\r\nREG_WRITE(REG_GLOBAL, 0x19, 0x8100);\r\nREG_WRITE(REG_GLOBAL, 0x1a, (dsa_upstream_port(ds) * 0x1100) | 0x00f0);\r\nif (ds->dst->pd->nr_chips > 1)\r\nREG_WRITE(REG_GLOBAL, 0x1c, 0xf000 | (ds->index & 0x1f));\r\nelse\r\nREG_WRITE(REG_GLOBAL, 0x1c, 0xe000 | (ds->index & 0x1f));\r\nREG_WRITE(REG_GLOBAL2, 0x03, 0xffff);\r\nREG_WRITE(REG_GLOBAL2, 0x05, 0x00ff);\r\nfor (i = 0; i < 32; i++) {\r\nint nexthop;\r\nnexthop = 0x1f;\r\nif (i != ds->index && i < ds->dst->pd->nr_chips)\r\nnexthop = ds->pd->rtable[i] & 0x1f;\r\nREG_WRITE(REG_GLOBAL2, 0x06, 0x8000 | (i << 8) | nexthop);\r\n}\r\nfor (i = 0; i < 8; i++)\r\nREG_WRITE(REG_GLOBAL2, 0x07, 0x8000 | (i << 12) | 0x7ff);\r\nfor (i = 0; i < 16; i++)\r\nREG_WRITE(REG_GLOBAL2, 0x08, 0x8000 | (i << 11));\r\nREG_WRITE(REG_GLOBAL2, 0x0f, 0x00ff);\r\nreturn 0;\r\n}\r\nstatic int mv88e6131_setup_port(struct dsa_switch *ds, int p)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nint addr = REG_PORT(p);\r\nu16 val;\r\nif (dsa_is_cpu_port(ds, p) || ds->dsa_port_mask & (1 << p))\r\nif (ps->id == ID_6085)\r\nREG_WRITE(addr, 0x01, 0x003d);\r\nelse\r\nREG_WRITE(addr, 0x01, 0x003e);\r\nelse\r\nREG_WRITE(addr, 0x01, 0x0003);\r\nval = 0x0433;\r\nif (p == dsa_upstream_port(ds)) {\r\nval |= 0x0104;\r\nif (ps->id == ID_6085)\r\nval |= 0x0008;\r\n}\r\nif (ds->dsa_port_mask & (1 << p))\r\nval |= 0x0100;\r\nREG_WRITE(addr, 0x04, val);\r\nREG_WRITE(addr, 0x05, dsa_is_cpu_port(ds, p) ? 0x8000 : 0x0000);\r\nval = (p & 0xf) << 12;\r\nif (dsa_is_cpu_port(ds, p))\r\nval |= ds->phys_port_mask;\r\nelse\r\nval |= 1 << dsa_upstream_port(ds);\r\nREG_WRITE(addr, 0x06, val);\r\nREG_WRITE(addr, 0x07, 0x0000);\r\nif (ps->id == ID_6085)\r\nREG_WRITE(addr, 0x08, 0x0080);\r\nelse {\r\nval = 0x0080 | dsa_upstream_port(ds);\r\nif (p == dsa_upstream_port(ds))\r\nval |= 0x0040;\r\nREG_WRITE(addr, 0x08, val);\r\n}\r\nREG_WRITE(addr, 0x09, 0x0000);\r\nREG_WRITE(addr, 0x0a, 0x0000);\r\nREG_WRITE(addr, 0x0b, 1 << p);\r\nREG_WRITE(addr, 0x18, 0x3210);\r\nREG_WRITE(addr, 0x19, 0x7654);\r\nreturn 0;\r\n}\r\nstatic int mv88e6131_setup(struct dsa_switch *ds)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nint i;\r\nint ret;\r\nmutex_init(&ps->smi_mutex);\r\nmv88e6xxx_ppu_state_init(ds);\r\nmutex_init(&ps->stats_mutex);\r\nps->id = REG_READ(REG_PORT(0), 0x03) & 0xfff0;\r\nret = mv88e6131_switch_reset(ds);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mv88e6131_setup_global(ds);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < 11; i++) {\r\nret = mv88e6131_setup_port(ds, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88e6131_port_to_phy_addr(int port)\r\n{\r\nif (port >= 0 && port <= 11)\r\nreturn port;\r\nreturn -1;\r\n}\r\nstatic int\r\nmv88e6131_phy_read(struct dsa_switch *ds, int port, int regnum)\r\n{\r\nint addr = mv88e6131_port_to_phy_addr(port);\r\nreturn mv88e6xxx_phy_read_ppu(ds, addr, regnum);\r\n}\r\nstatic int\r\nmv88e6131_phy_write(struct dsa_switch *ds,\r\nint port, int regnum, u16 val)\r\n{\r\nint addr = mv88e6131_port_to_phy_addr(port);\r\nreturn mv88e6xxx_phy_write_ppu(ds, addr, regnum, val);\r\n}\r\nstatic void\r\nmv88e6131_get_strings(struct dsa_switch *ds, int port, uint8_t *data)\r\n{\r\nmv88e6xxx_get_strings(ds, ARRAY_SIZE(mv88e6131_hw_stats),\r\nmv88e6131_hw_stats, port, data);\r\n}\r\nstatic void\r\nmv88e6131_get_ethtool_stats(struct dsa_switch *ds,\r\nint port, uint64_t *data)\r\n{\r\nmv88e6xxx_get_ethtool_stats(ds, ARRAY_SIZE(mv88e6131_hw_stats),\r\nmv88e6131_hw_stats, port, data);\r\n}\r\nstatic int mv88e6131_get_sset_count(struct dsa_switch *ds)\r\n{\r\nreturn ARRAY_SIZE(mv88e6131_hw_stats);\r\n}\r\nstatic int __init mv88e6131_init(void)\r\n{\r\nregister_switch_driver(&mv88e6131_switch_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit mv88e6131_cleanup(void)\r\n{\r\nunregister_switch_driver(&mv88e6131_switch_driver);\r\n}
