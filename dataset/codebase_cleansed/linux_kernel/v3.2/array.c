static inline void task_name(struct seq_file *m, struct task_struct *p)\r\n{\r\nint i;\r\nchar *buf, *end;\r\nchar *name;\r\nchar tcomm[sizeof(p->comm)];\r\nget_task_comm(tcomm, p);\r\nseq_puts(m, "Name:\t");\r\nend = m->buf + m->size;\r\nbuf = m->buf + m->count;\r\nname = tcomm;\r\ni = sizeof(tcomm);\r\nwhile (i && (buf < end)) {\r\nunsigned char c = *name;\r\nname++;\r\ni--;\r\n*buf = c;\r\nif (!c)\r\nbreak;\r\nif (c == '\\') {\r\nbuf++;\r\nif (buf < end)\r\n*buf++ = c;\r\ncontinue;\r\n}\r\nif (c == '\n') {\r\n*buf++ = '\\';\r\nif (buf < end)\r\n*buf++ = 'n';\r\ncontinue;\r\n}\r\nbuf++;\r\n}\r\nm->count = buf - m->buf;\r\nseq_putc(m, '\n');\r\n}\r\nstatic inline const char *get_task_state(struct task_struct *tsk)\r\n{\r\nunsigned int state = (tsk->state & TASK_REPORT) | tsk->exit_state;\r\nconst char * const *p = &task_state_array[0];\r\nBUILD_BUG_ON(1 + ilog2(TASK_STATE_MAX) != ARRAY_SIZE(task_state_array));\r\nwhile (state) {\r\np++;\r\nstate >>= 1;\r\n}\r\nreturn *p;\r\n}\r\nstatic inline void task_state(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *p)\r\n{\r\nstruct group_info *group_info;\r\nint g;\r\nstruct fdtable *fdt = NULL;\r\nconst struct cred *cred;\r\npid_t ppid, tpid;\r\nrcu_read_lock();\r\nppid = pid_alive(p) ?\r\ntask_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;\r\ntpid = 0;\r\nif (pid_alive(p)) {\r\nstruct task_struct *tracer = ptrace_parent(p);\r\nif (tracer)\r\ntpid = task_pid_nr_ns(tracer, ns);\r\n}\r\ncred = get_task_cred(p);\r\nseq_printf(m,\r\n"State:\t%s\n"\r\n"Tgid:\t%d\n"\r\n"Pid:\t%d\n"\r\n"PPid:\t%d\n"\r\n"TracerPid:\t%d\n"\r\n"Uid:\t%d\t%d\t%d\t%d\n"\r\n"Gid:\t%d\t%d\t%d\t%d\n",\r\nget_task_state(p),\r\ntask_tgid_nr_ns(p, ns),\r\npid_nr_ns(pid, ns),\r\nppid, tpid,\r\ncred->uid, cred->euid, cred->suid, cred->fsuid,\r\ncred->gid, cred->egid, cred->sgid, cred->fsgid);\r\ntask_lock(p);\r\nif (p->files)\r\nfdt = files_fdtable(p->files);\r\nseq_printf(m,\r\n"FDSize:\t%d\n"\r\n"Groups:\t",\r\nfdt ? fdt->max_fds : 0);\r\nrcu_read_unlock();\r\ngroup_info = cred->group_info;\r\ntask_unlock(p);\r\nfor (g = 0; g < min(group_info->ngroups, NGROUPS_SMALL); g++)\r\nseq_printf(m, "%d ", GROUP_AT(group_info, g));\r\nput_cred(cred);\r\nseq_putc(m, '\n');\r\n}\r\nstatic void render_sigset_t(struct seq_file *m, const char *header,\r\nsigset_t *set)\r\n{\r\nint i;\r\nseq_puts(m, header);\r\ni = _NSIG;\r\ndo {\r\nint x = 0;\r\ni -= 4;\r\nif (sigismember(set, i+1)) x |= 1;\r\nif (sigismember(set, i+2)) x |= 2;\r\nif (sigismember(set, i+3)) x |= 4;\r\nif (sigismember(set, i+4)) x |= 8;\r\nseq_printf(m, "%x", x);\r\n} while (i >= 4);\r\nseq_putc(m, '\n');\r\n}\r\nstatic void collect_sigign_sigcatch(struct task_struct *p, sigset_t *ign,\r\nsigset_t *catch)\r\n{\r\nstruct k_sigaction *k;\r\nint i;\r\nk = p->sighand->action;\r\nfor (i = 1; i <= _NSIG; ++i, ++k) {\r\nif (k->sa.sa_handler == SIG_IGN)\r\nsigaddset(ign, i);\r\nelse if (k->sa.sa_handler != SIG_DFL)\r\nsigaddset(catch, i);\r\n}\r\n}\r\nstatic inline void task_sig(struct seq_file *m, struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nsigset_t pending, shpending, blocked, ignored, caught;\r\nint num_threads = 0;\r\nunsigned long qsize = 0;\r\nunsigned long qlim = 0;\r\nsigemptyset(&pending);\r\nsigemptyset(&shpending);\r\nsigemptyset(&blocked);\r\nsigemptyset(&ignored);\r\nsigemptyset(&caught);\r\nif (lock_task_sighand(p, &flags)) {\r\npending = p->pending.signal;\r\nshpending = p->signal->shared_pending.signal;\r\nblocked = p->blocked;\r\ncollect_sigign_sigcatch(p, &ignored, &caught);\r\nnum_threads = get_nr_threads(p);\r\nrcu_read_lock();\r\nqsize = atomic_read(&__task_cred(p)->user->sigpending);\r\nrcu_read_unlock();\r\nqlim = task_rlimit(p, RLIMIT_SIGPENDING);\r\nunlock_task_sighand(p, &flags);\r\n}\r\nseq_printf(m, "Threads:\t%d\n", num_threads);\r\nseq_printf(m, "SigQ:\t%lu/%lu\n", qsize, qlim);\r\nrender_sigset_t(m, "SigPnd:\t", &pending);\r\nrender_sigset_t(m, "ShdPnd:\t", &shpending);\r\nrender_sigset_t(m, "SigBlk:\t", &blocked);\r\nrender_sigset_t(m, "SigIgn:\t", &ignored);\r\nrender_sigset_t(m, "SigCgt:\t", &caught);\r\n}\r\nstatic void render_cap_t(struct seq_file *m, const char *header,\r\nkernel_cap_t *a)\r\n{\r\nunsigned __capi;\r\nseq_puts(m, header);\r\nCAP_FOR_EACH_U32(__capi) {\r\nseq_printf(m, "%08x",\r\na->cap[(_KERNEL_CAPABILITY_U32S-1) - __capi]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic inline void task_cap(struct seq_file *m, struct task_struct *p)\r\n{\r\nconst struct cred *cred;\r\nkernel_cap_t cap_inheritable, cap_permitted, cap_effective, cap_bset;\r\nrcu_read_lock();\r\ncred = __task_cred(p);\r\ncap_inheritable = cred->cap_inheritable;\r\ncap_permitted = cred->cap_permitted;\r\ncap_effective = cred->cap_effective;\r\ncap_bset = cred->cap_bset;\r\nrcu_read_unlock();\r\nrender_cap_t(m, "CapInh:\t", &cap_inheritable);\r\nrender_cap_t(m, "CapPrm:\t", &cap_permitted);\r\nrender_cap_t(m, "CapEff:\t", &cap_effective);\r\nrender_cap_t(m, "CapBnd:\t", &cap_bset);\r\n}\r\nstatic inline void task_context_switch_counts(struct seq_file *m,\r\nstruct task_struct *p)\r\n{\r\nseq_printf(m, "voluntary_ctxt_switches:\t%lu\n"\r\n"nonvoluntary_ctxt_switches:\t%lu\n",\r\np->nvcsw,\r\np->nivcsw);\r\n}\r\nstatic void task_cpus_allowed(struct seq_file *m, struct task_struct *task)\r\n{\r\nseq_puts(m, "Cpus_allowed:\t");\r\nseq_cpumask(m, &task->cpus_allowed);\r\nseq_putc(m, '\n');\r\nseq_puts(m, "Cpus_allowed_list:\t");\r\nseq_cpumask_list(m, &task->cpus_allowed);\r\nseq_putc(m, '\n');\r\n}\r\nint proc_pid_status(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nstruct mm_struct *mm = get_task_mm(task);\r\ntask_name(m, task);\r\ntask_state(m, ns, pid, task);\r\nif (mm) {\r\ntask_mem(m, mm);\r\nmmput(mm);\r\n}\r\ntask_sig(m, task);\r\ntask_cap(m, task);\r\ntask_cpus_allowed(m, task);\r\ncpuset_task_status_allowed(m, task);\r\ntask_context_switch_counts(m, task);\r\nreturn 0;\r\n}\r\nstatic int do_task_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task, int whole)\r\n{\r\nunsigned long vsize, eip, esp, wchan = ~0UL;\r\nlong priority, nice;\r\nint tty_pgrp = -1, tty_nr = 0;\r\nsigset_t sigign, sigcatch;\r\nchar state;\r\npid_t ppid = 0, pgid = -1, sid = -1;\r\nint num_threads = 0;\r\nint permitted;\r\nstruct mm_struct *mm;\r\nunsigned long long start_time;\r\nunsigned long cmin_flt = 0, cmaj_flt = 0;\r\nunsigned long min_flt = 0, maj_flt = 0;\r\ncputime_t cutime, cstime, utime, stime;\r\ncputime_t cgtime, gtime;\r\nunsigned long rsslim = 0;\r\nchar tcomm[sizeof(task->comm)];\r\nunsigned long flags;\r\nstate = *get_task_state(task);\r\nvsize = eip = esp = 0;\r\npermitted = ptrace_may_access(task, PTRACE_MODE_READ);\r\nmm = get_task_mm(task);\r\nif (mm) {\r\nvsize = task_vsize(mm);\r\nif (permitted) {\r\neip = KSTK_EIP(task);\r\nesp = KSTK_ESP(task);\r\n}\r\n}\r\nget_task_comm(tcomm, task);\r\nsigemptyset(&sigign);\r\nsigemptyset(&sigcatch);\r\ncutime = cstime = utime = stime = cputime_zero;\r\ncgtime = gtime = cputime_zero;\r\nif (lock_task_sighand(task, &flags)) {\r\nstruct signal_struct *sig = task->signal;\r\nif (sig->tty) {\r\nstruct pid *pgrp = tty_get_pgrp(sig->tty);\r\ntty_pgrp = pid_nr_ns(pgrp, ns);\r\nput_pid(pgrp);\r\ntty_nr = new_encode_dev(tty_devnum(sig->tty));\r\n}\r\nnum_threads = get_nr_threads(task);\r\ncollect_sigign_sigcatch(task, &sigign, &sigcatch);\r\ncmin_flt = sig->cmin_flt;\r\ncmaj_flt = sig->cmaj_flt;\r\ncutime = sig->cutime;\r\ncstime = sig->cstime;\r\ncgtime = sig->cgtime;\r\nrsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);\r\nif (whole) {\r\nstruct task_struct *t = task;\r\ndo {\r\nmin_flt += t->min_flt;\r\nmaj_flt += t->maj_flt;\r\ngtime = cputime_add(gtime, t->gtime);\r\nt = next_thread(t);\r\n} while (t != task);\r\nmin_flt += sig->min_flt;\r\nmaj_flt += sig->maj_flt;\r\nthread_group_times(task, &utime, &stime);\r\ngtime = cputime_add(gtime, sig->gtime);\r\n}\r\nsid = task_session_nr_ns(task, ns);\r\nppid = task_tgid_nr_ns(task->real_parent, ns);\r\npgid = task_pgrp_nr_ns(task, ns);\r\nunlock_task_sighand(task, &flags);\r\n}\r\nif (permitted && (!whole || num_threads < 2))\r\nwchan = get_wchan(task);\r\nif (!whole) {\r\nmin_flt = task->min_flt;\r\nmaj_flt = task->maj_flt;\r\ntask_times(task, &utime, &stime);\r\ngtime = task->gtime;\r\n}\r\npriority = task_prio(task);\r\nnice = task_nice(task);\r\nstart_time =\r\n(unsigned long long)task->real_start_time.tv_sec * NSEC_PER_SEC\r\n+ task->real_start_time.tv_nsec;\r\nstart_time = nsec_to_clock_t(start_time);\r\nseq_printf(m, "%d (%s) %c %d %d %d %d %d %u %lu \\r\n%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \\r\n%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\n",\r\npid_nr_ns(pid, ns),\r\ntcomm,\r\nstate,\r\nppid,\r\npgid,\r\nsid,\r\ntty_nr,\r\ntty_pgrp,\r\ntask->flags,\r\nmin_flt,\r\ncmin_flt,\r\nmaj_flt,\r\ncmaj_flt,\r\ncputime_to_clock_t(utime),\r\ncputime_to_clock_t(stime),\r\ncputime_to_clock_t(cutime),\r\ncputime_to_clock_t(cstime),\r\npriority,\r\nnice,\r\nnum_threads,\r\nstart_time,\r\nvsize,\r\nmm ? get_mm_rss(mm) : 0,\r\nrsslim,\r\nmm ? (permitted ? mm->start_code : 1) : 0,\r\nmm ? (permitted ? mm->end_code : 1) : 0,\r\n(permitted && mm) ? mm->start_stack : 0,\r\nesp,\r\neip,\r\ntask->pending.signal.sig[0] & 0x7fffffffUL,\r\ntask->blocked.sig[0] & 0x7fffffffUL,\r\nsigign .sig[0] & 0x7fffffffUL,\r\nsigcatch .sig[0] & 0x7fffffffUL,\r\nwchan,\r\n0UL,\r\n0UL,\r\ntask->exit_signal,\r\ntask_cpu(task),\r\ntask->rt_priority,\r\ntask->policy,\r\n(unsigned long long)delayacct_blkio_ticks(task),\r\ncputime_to_clock_t(gtime),\r\ncputime_to_clock_t(cgtime));\r\nif (mm)\r\nmmput(mm);\r\nreturn 0;\r\n}\r\nint proc_tid_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nreturn do_task_stat(m, ns, pid, task, 0);\r\n}\r\nint proc_tgid_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nreturn do_task_stat(m, ns, pid, task, 1);\r\n}\r\nint proc_pid_statm(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nunsigned long size = 0, resident = 0, shared = 0, text = 0, data = 0;\r\nstruct mm_struct *mm = get_task_mm(task);\r\nif (mm) {\r\nsize = task_statm(mm, &shared, &text, &data, &resident);\r\nmmput(mm);\r\n}\r\nseq_printf(m, "%lu %lu %lu %lu 0 %lu 0\n",\r\nsize, resident, shared, text, data);\r\nreturn 0;\r\n}
