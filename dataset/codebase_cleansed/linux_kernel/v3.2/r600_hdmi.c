static void r600_hdmi_calc_CTS(uint32_t clock, int *CTS, int N, int freq)\r\n{\r\nif (*CTS == 0)\r\n*CTS = clock * N / (128 * freq) * 1000;\r\nDRM_DEBUG("Using ACR timing N=%d CTS=%d for frequency %d\n",\r\nN, *CTS, freq);\r\n}\r\nstatic void r600_hdmi_update_ACR(struct drm_encoder *encoder, uint32_t clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t offset = to_radeon_encoder(encoder)->hdmi_offset;\r\nint CTS;\r\nint N;\r\nint i;\r\nfor (i = 0; r600_hdmi_ACR[i].Clock != clock && r600_hdmi_ACR[i].Clock != 0; i++);\r\nCTS = r600_hdmi_ACR[i].CTS_32kHz;\r\nN = r600_hdmi_ACR[i].N_32kHz;\r\nr600_hdmi_calc_CTS(clock, &CTS, N, 32000);\r\nWREG32(offset+R600_HDMI_32kHz_CTS, CTS << 12);\r\nWREG32(offset+R600_HDMI_32kHz_N, N);\r\nCTS = r600_hdmi_ACR[i].CTS_44_1kHz;\r\nN = r600_hdmi_ACR[i].N_44_1kHz;\r\nr600_hdmi_calc_CTS(clock, &CTS, N, 44100);\r\nWREG32(offset+R600_HDMI_44_1kHz_CTS, CTS << 12);\r\nWREG32(offset+R600_HDMI_44_1kHz_N, N);\r\nCTS = r600_hdmi_ACR[i].CTS_48kHz;\r\nN = r600_hdmi_ACR[i].N_48kHz;\r\nr600_hdmi_calc_CTS(clock, &CTS, N, 48000);\r\nWREG32(offset+R600_HDMI_48kHz_CTS, CTS << 12);\r\nWREG32(offset+R600_HDMI_48kHz_N, N);\r\n}\r\nstatic void r600_hdmi_infoframe_checksum(uint8_t packetType,\r\nuint8_t versionNumber,\r\nuint8_t length,\r\nuint8_t *frame)\r\n{\r\nint i;\r\nframe[0] = packetType + versionNumber + length;\r\nfor (i = 1; i <= length; i++)\r\nframe[0] += frame[i];\r\nframe[0] = 0x100 - frame[0];\r\n}\r\nstatic void r600_hdmi_videoinfoframe(\r\nstruct drm_encoder *encoder,\r\nenum r600_hdmi_color_format color_format,\r\nint active_information_present,\r\nuint8_t active_format_aspect_ratio,\r\nuint8_t scan_information,\r\nuint8_t colorimetry,\r\nuint8_t ex_colorimetry,\r\nuint8_t quantization,\r\nint ITC,\r\nuint8_t picture_aspect_ratio,\r\nuint8_t video_format_identification,\r\nuint8_t pixel_repetition,\r\nuint8_t non_uniform_picture_scaling,\r\nuint8_t bar_info_data_valid,\r\nuint16_t top_bar,\r\nuint16_t bottom_bar,\r\nuint16_t left_bar,\r\nuint16_t right_bar\r\n)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t offset = to_radeon_encoder(encoder)->hdmi_offset;\r\nuint8_t frame[14];\r\nframe[0x0] = 0;\r\nframe[0x1] =\r\n(scan_information & 0x3) |\r\n((bar_info_data_valid & 0x3) << 2) |\r\n((active_information_present & 0x1) << 4) |\r\n((color_format & 0x3) << 5);\r\nframe[0x2] =\r\n(active_format_aspect_ratio & 0xF) |\r\n((picture_aspect_ratio & 0x3) << 4) |\r\n((colorimetry & 0x3) << 6);\r\nframe[0x3] =\r\n(non_uniform_picture_scaling & 0x3) |\r\n((quantization & 0x3) << 2) |\r\n((ex_colorimetry & 0x7) << 4) |\r\n((ITC & 0x1) << 7);\r\nframe[0x4] = (video_format_identification & 0x7F);\r\nframe[0x5] = (pixel_repetition & 0xF);\r\nframe[0x6] = (top_bar & 0xFF);\r\nframe[0x7] = (top_bar >> 8);\r\nframe[0x8] = (bottom_bar & 0xFF);\r\nframe[0x9] = (bottom_bar >> 8);\r\nframe[0xA] = (left_bar & 0xFF);\r\nframe[0xB] = (left_bar >> 8);\r\nframe[0xC] = (right_bar & 0xFF);\r\nframe[0xD] = (right_bar >> 8);\r\nr600_hdmi_infoframe_checksum(0x82, 0x02, 0x0D, frame);\r\nWREG32(offset+R600_HDMI_VIDEOINFOFRAME_0,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(offset+R600_HDMI_VIDEOINFOFRAME_1,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\r\nWREG32(offset+R600_HDMI_VIDEOINFOFRAME_2,\r\nframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\r\nWREG32(offset+R600_HDMI_VIDEOINFOFRAME_3,\r\nframe[0xC] | (frame[0xD] << 8));\r\n}\r\nstatic void r600_hdmi_audioinfoframe(\r\nstruct drm_encoder *encoder,\r\nuint8_t channel_count,\r\nuint8_t coding_type,\r\nuint8_t sample_size,\r\nuint8_t sample_frequency,\r\nuint8_t format,\r\nuint8_t channel_allocation,\r\nuint8_t level_shift,\r\nint downmix_inhibit\r\n)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t offset = to_radeon_encoder(encoder)->hdmi_offset;\r\nuint8_t frame[11];\r\nframe[0x0] = 0;\r\nframe[0x1] = (channel_count & 0x7) | ((coding_type & 0xF) << 4);\r\nframe[0x2] = (sample_size & 0x3) | ((sample_frequency & 0x7) << 2);\r\nframe[0x3] = format;\r\nframe[0x4] = channel_allocation;\r\nframe[0x5] = ((level_shift & 0xF) << 3) | ((downmix_inhibit & 0x1) << 7);\r\nframe[0x6] = 0;\r\nframe[0x7] = 0;\r\nframe[0x8] = 0;\r\nframe[0x9] = 0;\r\nframe[0xA] = 0;\r\nr600_hdmi_infoframe_checksum(0x84, 0x01, 0x0A, frame);\r\nWREG32(offset+R600_HDMI_AUDIOINFOFRAME_0,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(offset+R600_HDMI_AUDIOINFOFRAME_1,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x8] << 24));\r\n}\r\nstatic int r600_hdmi_is_audio_buffer_filled(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t offset = to_radeon_encoder(encoder)->hdmi_offset;\r\nreturn (RREG32(offset+R600_HDMI_STATUS) & 0x10) != 0;\r\n}\r\nint r600_hdmi_buffer_status_changed(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nint status, result;\r\nif (!radeon_encoder->hdmi_offset)\r\nreturn 0;\r\nstatus = r600_hdmi_is_audio_buffer_filled(encoder);\r\nresult = radeon_encoder->hdmi_buffer_status != status;\r\nradeon_encoder->hdmi_buffer_status = status;\r\nreturn result;\r\n}\r\nvoid r600_hdmi_audio_workaround(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t offset = radeon_encoder->hdmi_offset;\r\nif (!offset)\r\nreturn;\r\nif (!radeon_encoder->hdmi_audio_workaround ||\r\nr600_hdmi_is_audio_buffer_filled(encoder)) {\r\nWREG32_P(offset+R600_HDMI_CNTL, 0x00000001, ~0x00001001);\r\n} else {\r\nWREG32_P(offset+R600_HDMI_CNTL, 0x00001001, ~0x00001001);\r\n}\r\n}\r\nvoid r600_hdmi_setmode(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t offset = to_radeon_encoder(encoder)->hdmi_offset;\r\nif (ASIC_IS_DCE4(rdev))\r\nreturn;\r\nif (!offset)\r\nreturn;\r\nr600_audio_set_clock(encoder, mode->clock);\r\nWREG32(offset+R600_HDMI_UNKNOWN_0, 0x1000);\r\nWREG32(offset+R600_HDMI_UNKNOWN_1, 0x0);\r\nWREG32(offset+R600_HDMI_UNKNOWN_2, 0x1000);\r\nr600_hdmi_update_ACR(encoder, mode->clock);\r\nWREG32(offset+R600_HDMI_VIDEOCNTL, 0x13);\r\nWREG32(offset+R600_HDMI_VERSION, 0x202);\r\nr600_hdmi_videoinfoframe(encoder, RGB, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\nWREG32(offset+R600_HDMI_AUDIO_DEBUG_0, 0x00FFFFFF);\r\nWREG32(offset+R600_HDMI_AUDIO_DEBUG_1, 0x007FFFFF);\r\nWREG32(offset+R600_HDMI_AUDIO_DEBUG_2, 0x00000001);\r\nWREG32(offset+R600_HDMI_AUDIO_DEBUG_3, 0x00000001);\r\nr600_hdmi_audio_workaround(encoder);\r\nWREG32_P(offset+R600_HDMI_CNTL, 0x00040000, ~0x001F0000);\r\n}\r\nvoid r600_hdmi_update_audio_settings(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t offset = to_radeon_encoder(encoder)->hdmi_offset;\r\nint channels = r600_audio_channels(rdev);\r\nint rate = r600_audio_rate(rdev);\r\nint bps = r600_audio_bits_per_sample(rdev);\r\nuint8_t status_bits = r600_audio_status_bits(rdev);\r\nuint8_t category_code = r600_audio_category_code(rdev);\r\nuint32_t iec;\r\nif (!offset)\r\nreturn;\r\nDRM_DEBUG("%s with %d channels, %d Hz sampling rate, %d bits per sample,\n",\r\nr600_hdmi_is_audio_buffer_filled(encoder) ? "playing" : "stopped",\r\nchannels, rate, bps);\r\nDRM_DEBUG("0x%02X IEC60958 status bits and 0x%02X category code\n",\r\n(int)status_bits, (int)category_code);\r\niec = 0;\r\nif (status_bits & AUDIO_STATUS_PROFESSIONAL)\r\niec |= 1 << 0;\r\nif (status_bits & AUDIO_STATUS_NONAUDIO)\r\niec |= 1 << 1;\r\nif (status_bits & AUDIO_STATUS_COPYRIGHT)\r\niec |= 1 << 2;\r\nif (status_bits & AUDIO_STATUS_EMPHASIS)\r\niec |= 1 << 3;\r\niec |= category_code << 8;\r\nswitch (rate) {\r\ncase 32000: iec |= 0x3 << 24; break;\r\ncase 44100: iec |= 0x0 << 24; break;\r\ncase 88200: iec |= 0x8 << 24; break;\r\ncase 176400: iec |= 0xc << 24; break;\r\ncase 48000: iec |= 0x2 << 24; break;\r\ncase 96000: iec |= 0xa << 24; break;\r\ncase 192000: iec |= 0xe << 24; break;\r\n}\r\nWREG32(offset+R600_HDMI_IEC60958_1, iec);\r\niec = 0;\r\nswitch (bps) {\r\ncase 16: iec |= 0x2; break;\r\ncase 20: iec |= 0x3; break;\r\ncase 24: iec |= 0xb; break;\r\n}\r\nif (status_bits & AUDIO_STATUS_V)\r\niec |= 0x5 << 16;\r\nWREG32_P(offset+R600_HDMI_IEC60958_2, iec, ~0x5000f);\r\nWREG32(offset+R600_HDMI_AUDIOCNTL, 0x31);\r\nr600_hdmi_audioinfoframe(encoder, channels-1, 0, 0, 0, 0, 0, 0, 0);\r\nr600_hdmi_audio_workaround(encoder);\r\n}\r\nstatic int r600_hdmi_find_free_block(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct radeon_encoder *radeon_encoder;\r\nbool free_blocks[3] = { true, true, true };\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nswitch (radeon_encoder->hdmi_offset) {\r\ncase R600_HDMI_BLOCK1:\r\nfree_blocks[0] = false;\r\nbreak;\r\ncase R600_HDMI_BLOCK2:\r\nfree_blocks[1] = false;\r\nbreak;\r\ncase R600_HDMI_BLOCK3:\r\nfree_blocks[2] = false;\r\nbreak;\r\n}\r\n}\r\nif (rdev->family == CHIP_RS600 || rdev->family == CHIP_RS690 ||\r\nrdev->family == CHIP_RS740) {\r\nreturn free_blocks[0] ? R600_HDMI_BLOCK1 : 0;\r\n} else if (rdev->family >= CHIP_R600) {\r\nif (free_blocks[0])\r\nreturn R600_HDMI_BLOCK1;\r\nelse if (free_blocks[1])\r\nreturn R600_HDMI_BLOCK2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void r600_hdmi_assign_block(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nif (!dig) {\r\ndev_err(rdev->dev, "Enabling HDMI on non-dig encoder\n");\r\nreturn;\r\n}\r\nif (ASIC_IS_DCE4(rdev)) {\r\n} else if (ASIC_IS_DCE3(rdev)) {\r\nradeon_encoder->hdmi_offset = dig->dig_encoder ?\r\nR600_HDMI_BLOCK3 : R600_HDMI_BLOCK1;\r\nif (ASIC_IS_DCE32(rdev))\r\nradeon_encoder->hdmi_config_offset = dig->dig_encoder ?\r\nR600_HDMI_CONFIG2 : R600_HDMI_CONFIG1;\r\n} else if (rdev->family >= CHIP_R600 || rdev->family == CHIP_RS600 ||\r\nrdev->family == CHIP_RS690 || rdev->family == CHIP_RS740) {\r\nradeon_encoder->hdmi_offset = r600_hdmi_find_free_block(dev);\r\n}\r\n}\r\nvoid r600_hdmi_enable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t offset;\r\nif (ASIC_IS_DCE4(rdev))\r\nreturn;\r\nif (!radeon_encoder->hdmi_offset) {\r\nr600_hdmi_assign_block(encoder);\r\nif (!radeon_encoder->hdmi_offset) {\r\ndev_warn(rdev->dev, "Could not find HDMI block for "\r\n"0x%x encoder\n", radeon_encoder->encoder_id);\r\nreturn;\r\n}\r\n}\r\noffset = radeon_encoder->hdmi_offset;\r\nif (ASIC_IS_DCE32(rdev) && !ASIC_IS_DCE4(rdev)) {\r\nWREG32_P(radeon_encoder->hdmi_config_offset + 0x4, 0x1, ~0x1);\r\n} else if (rdev->family >= CHIP_R600 && !ASIC_IS_DCE3(rdev)) {\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nWREG32_P(AVIVO_TMDSA_CNTL, 0x4, ~0x4);\r\nWREG32(offset + R600_HDMI_ENABLE, 0x101);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nWREG32_P(AVIVO_LVTMA_CNTL, 0x4, ~0x4);\r\nWREG32(offset + R600_HDMI_ENABLE, 0x105);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unknown HDMI output type\n");\r\nbreak;\r\n}\r\n}\r\nif (rdev->irq.installed\r\n&& rdev->family != CHIP_RS600\r\n&& rdev->family != CHIP_RS690\r\n&& rdev->family != CHIP_RS740) {\r\nrdev->irq.hdmi[offset == R600_HDMI_BLOCK1 ? 0 : 1] = true;\r\nradeon_irq_set(rdev);\r\nr600_audio_disable_polling(encoder);\r\n} else {\r\nr600_audio_enable_polling(encoder);\r\n}\r\nDRM_DEBUG("Enabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\nradeon_encoder->hdmi_offset, radeon_encoder->encoder_id);\r\n}\r\nvoid r600_hdmi_disable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nuint32_t offset;\r\nif (ASIC_IS_DCE4(rdev))\r\nreturn;\r\noffset = radeon_encoder->hdmi_offset;\r\nif (!offset) {\r\ndev_err(rdev->dev, "Disabling not enabled HDMI\n");\r\nreturn;\r\n}\r\nDRM_DEBUG("Disabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\noffset, radeon_encoder->encoder_id);\r\nrdev->irq.hdmi[offset == R600_HDMI_BLOCK1 ? 0 : 1] = false;\r\nradeon_irq_set(rdev);\r\nr600_audio_disable_polling(encoder);\r\nif (ASIC_IS_DCE32(rdev) && !ASIC_IS_DCE4(rdev)) {\r\nWREG32_P(radeon_encoder->hdmi_config_offset + 0x4, 0, ~0x1);\r\n} else if (rdev->family >= CHIP_R600 && !ASIC_IS_DCE3(rdev)) {\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nWREG32_P(AVIVO_TMDSA_CNTL, 0, ~0x4);\r\nWREG32(offset + R600_HDMI_ENABLE, 0);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nWREG32_P(AVIVO_LVTMA_CNTL, 0, ~0x4);\r\nWREG32(offset + R600_HDMI_ENABLE, 0);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unknown HDMI output type\n");\r\nbreak;\r\n}\r\n}\r\nradeon_encoder->hdmi_offset = 0;\r\nradeon_encoder->hdmi_config_offset = 0;\r\n}
