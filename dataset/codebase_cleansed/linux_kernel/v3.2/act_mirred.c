static int tcf_mirred_release(struct tcf_mirred *m, int bind)\r\n{\r\nif (m) {\r\nif (bind)\r\nm->tcf_bindcnt--;\r\nm->tcf_refcnt--;\r\nif (!m->tcf_bindcnt && m->tcf_refcnt <= 0) {\r\nlist_del(&m->tcfm_list);\r\nif (m->tcfm_dev)\r\ndev_put(m->tcfm_dev);\r\ntcf_hash_destroy(&m->common, &mirred_hash_info);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcf_mirred_init(struct nlattr *nla, struct nlattr *est,\r\nstruct tc_action *a, int ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_MIRRED_MAX + 1];\r\nstruct tc_mirred *parm;\r\nstruct tcf_mirred *m;\r\nstruct tcf_common *pc;\r\nstruct net_device *dev;\r\nint ret, ok_push = 0;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nret = nla_parse_nested(tb, TCA_MIRRED_MAX, nla, mirred_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nif (tb[TCA_MIRRED_PARMS] == NULL)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_MIRRED_PARMS]);\r\nswitch (parm->eaction) {\r\ncase TCA_EGRESS_MIRROR:\r\ncase TCA_EGRESS_REDIR:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (parm->ifindex) {\r\ndev = __dev_get_by_index(&init_net, parm->ifindex);\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nswitch (dev->type) {\r\ncase ARPHRD_TUNNEL:\r\ncase ARPHRD_TUNNEL6:\r\ncase ARPHRD_SIT:\r\ncase ARPHRD_IPGRE:\r\ncase ARPHRD_VOID:\r\ncase ARPHRD_NONE:\r\nok_push = 0;\r\nbreak;\r\ndefault:\r\nok_push = 1;\r\nbreak;\r\n}\r\n} else {\r\ndev = NULL;\r\n}\r\npc = tcf_hash_check(parm->index, a, bind, &mirred_hash_info);\r\nif (!pc) {\r\nif (dev == NULL)\r\nreturn -EINVAL;\r\npc = tcf_hash_create(parm->index, est, a, sizeof(*m), bind,\r\n&mirred_idx_gen, &mirred_hash_info);\r\nif (IS_ERR(pc))\r\nreturn PTR_ERR(pc);\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (!ovr) {\r\ntcf_mirred_release(to_mirred(pc), bind);\r\nreturn -EEXIST;\r\n}\r\n}\r\nm = to_mirred(pc);\r\nspin_lock_bh(&m->tcf_lock);\r\nm->tcf_action = parm->action;\r\nm->tcfm_eaction = parm->eaction;\r\nif (dev != NULL) {\r\nm->tcfm_ifindex = parm->ifindex;\r\nif (ret != ACT_P_CREATED)\r\ndev_put(m->tcfm_dev);\r\ndev_hold(dev);\r\nm->tcfm_dev = dev;\r\nm->tcfm_ok_push = ok_push;\r\n}\r\nspin_unlock_bh(&m->tcf_lock);\r\nif (ret == ACT_P_CREATED) {\r\nlist_add(&m->tcfm_list, &mirred_list);\r\ntcf_hash_insert(pc, &mirred_hash_info);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tcf_mirred_cleanup(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_mirred *m = a->priv;\r\nif (m)\r\nreturn tcf_mirred_release(m, bind);\r\nreturn 0;\r\n}\r\nstatic int tcf_mirred(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_mirred *m = a->priv;\r\nstruct net_device *dev;\r\nstruct sk_buff *skb2;\r\nu32 at;\r\nint retval, err = 1;\r\nspin_lock(&m->tcf_lock);\r\nm->tcf_tm.lastuse = jiffies;\r\nbstats_update(&m->tcf_bstats, skb);\r\ndev = m->tcfm_dev;\r\nif (!dev) {\r\nprintk_once(KERN_NOTICE "tc mirred: target device is gone\n");\r\ngoto out;\r\n}\r\nif (!(dev->flags & IFF_UP)) {\r\nif (net_ratelimit())\r\npr_notice("tc mirred to Houston: device %s is down\n",\r\ndev->name);\r\ngoto out;\r\n}\r\nat = G_TC_AT(skb->tc_verd);\r\nskb2 = skb_act_clone(skb, GFP_ATOMIC, m->tcf_action);\r\nif (skb2 == NULL)\r\ngoto out;\r\nif (!(at & AT_EGRESS)) {\r\nif (m->tcfm_ok_push)\r\nskb_push(skb2, skb2->dev->hard_header_len);\r\n}\r\nif (m->tcfm_eaction != TCA_EGRESS_MIRROR)\r\nskb2->tc_verd = SET_TC_FROM(skb2->tc_verd, at);\r\nskb2->skb_iif = skb->dev->ifindex;\r\nskb2->dev = dev;\r\nerr = dev_queue_xmit(skb2);\r\nout:\r\nif (err) {\r\nm->tcf_qstats.overlimits++;\r\nretval = TC_ACT_SHOT;\r\n} else {\r\nretval = m->tcf_action;\r\n}\r\nspin_unlock(&m->tcf_lock);\r\nreturn retval;\r\n}\r\nstatic int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_mirred *m = a->priv;\r\nstruct tc_mirred opt = {\r\n.index = m->tcf_index,\r\n.action = m->tcf_action,\r\n.refcnt = m->tcf_refcnt - ref,\r\n.bindcnt = m->tcf_bindcnt - bind,\r\n.eaction = m->tcfm_eaction,\r\n.ifindex = m->tcfm_ifindex,\r\n};\r\nstruct tcf_t t;\r\nNLA_PUT(skb, TCA_MIRRED_PARMS, sizeof(opt), &opt);\r\nt.install = jiffies_to_clock_t(jiffies - m->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - m->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(m->tcf_tm.expires);\r\nNLA_PUT(skb, TCA_MIRRED_TM, sizeof(t), &t);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int mirred_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nstruct tcf_mirred *m;\r\nif (event == NETDEV_UNREGISTER)\r\nlist_for_each_entry(m, &mirred_list, tcfm_list) {\r\nif (m->tcfm_dev == dev) {\r\ndev_put(dev);\r\nm->tcfm_dev = NULL;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init mirred_init_module(void)\r\n{\r\nint err = register_netdevice_notifier(&mirred_device_notifier);\r\nif (err)\r\nreturn err;\r\npr_info("Mirror/redirect action on\n");\r\nreturn tcf_register_action(&act_mirred_ops);\r\n}\r\nstatic void __exit mirred_cleanup_module(void)\r\n{\r\nunregister_netdevice_notifier(&mirred_device_notifier);\r\ntcf_unregister_action(&act_mirred_ops);\r\n}
