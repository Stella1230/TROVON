bits64 extractFloat64Frac(float64 a)\r\n{\r\nreturn a & LIT64(0x000FFFFFFFFFFFFF);\r\n}\r\nflag extractFloat64Sign(float64 a)\r\n{\r\nreturn a >> 63;\r\n}\r\nint16 extractFloat64Exp(float64 a)\r\n{\r\nreturn (a >> 52) & 0x7FF;\r\n}\r\nint16 extractFloat32Exp(float32 a)\r\n{\r\nreturn (a >> 23) & 0xFF;\r\n}\r\nflag extractFloat32Sign(float32 a)\r\n{\r\nreturn a >> 31;\r\n}\r\nbits32 extractFloat32Frac(float32 a)\r\n{\r\nreturn a & 0x007FFFFF;\r\n}\r\nfloat64 packFloat64(flag zSign, int16 zExp, bits64 zSig)\r\n{\r\nreturn (((bits64) zSign) << 63) + (((bits64) zExp) << 52) + zSig;\r\n}\r\nvoid shift64RightJamming(bits64 a, int16 count, bits64 * zPtr)\r\n{\r\nbits64 z;\r\nif (count == 0) {\r\nz = a;\r\n} else if (count < 64) {\r\nz = (a >> count) | ((a << ((-count) & 63)) != 0);\r\n} else {\r\nz = (a != 0);\r\n}\r\n*zPtr = z;\r\n}\r\nstatic int8 countLeadingZeros32(bits32 a)\r\n{\r\nstatic const int8 countLeadingZerosHigh[] = {\r\n8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,\r\n3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\r\n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\r\n2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\r\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\r\n};\r\nint8 shiftCount;\r\nshiftCount = 0;\r\nif (a < 0x10000) {\r\nshiftCount += 16;\r\na <<= 16;\r\n}\r\nif (a < 0x1000000) {\r\nshiftCount += 8;\r\na <<= 8;\r\n}\r\nshiftCount += countLeadingZerosHigh[a >> 24];\r\nreturn shiftCount;\r\n}\r\nstatic int8 countLeadingZeros64(bits64 a)\r\n{\r\nint8 shiftCount;\r\nshiftCount = 0;\r\nif (a < ((bits64) 1) << 32) {\r\nshiftCount += 32;\r\n} else {\r\na >>= 32;\r\n}\r\nshiftCount += countLeadingZeros32(a);\r\nreturn shiftCount;\r\n}\r\nstatic float64 normalizeRoundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)\r\n{\r\nint8 shiftCount;\r\nshiftCount = countLeadingZeros64(zSig) - 1;\r\nreturn roundAndPackFloat64(zSign, zExp - shiftCount,\r\nzSig << shiftCount);\r\n}\r\nstatic float64 subFloat64Sigs(float64 a, float64 b, flag zSign)\r\n{\r\nint16 aExp, bExp, zExp;\r\nbits64 aSig, bSig, zSig;\r\nint16 expDiff;\r\naSig = extractFloat64Frac(a);\r\naExp = extractFloat64Exp(a);\r\nbSig = extractFloat64Frac(b);\r\nbExp = extractFloat64Exp(b);\r\nexpDiff = aExp - bExp;\r\naSig <<= 10;\r\nbSig <<= 10;\r\nif (0 < expDiff)\r\ngoto aExpBigger;\r\nif (expDiff < 0)\r\ngoto bExpBigger;\r\nif (aExp == 0) {\r\naExp = 1;\r\nbExp = 1;\r\n}\r\nif (bSig < aSig)\r\ngoto aBigger;\r\nif (aSig < bSig)\r\ngoto bBigger;\r\nreturn packFloat64(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);\r\nbExpBigger:\r\nif (bExp == 0x7FF) {\r\nreturn packFloat64(zSign ^ 1, 0x7FF, 0);\r\n}\r\nif (aExp == 0) {\r\n++expDiff;\r\n} else {\r\naSig |= LIT64(0x4000000000000000);\r\n}\r\nshift64RightJamming(aSig, -expDiff, &aSig);\r\nbSig |= LIT64(0x4000000000000000);\r\nbBigger:\r\nzSig = bSig - aSig;\r\nzExp = bExp;\r\nzSign ^= 1;\r\ngoto normalizeRoundAndPack;\r\naExpBigger:\r\nif (aExp == 0x7FF) {\r\nreturn a;\r\n}\r\nif (bExp == 0) {\r\n--expDiff;\r\n} else {\r\nbSig |= LIT64(0x4000000000000000);\r\n}\r\nshift64RightJamming(bSig, expDiff, &bSig);\r\naSig |= LIT64(0x4000000000000000);\r\naBigger:\r\nzSig = aSig - bSig;\r\nzExp = aExp;\r\nnormalizeRoundAndPack:\r\n--zExp;\r\nreturn normalizeRoundAndPackFloat64(zSign, zExp, zSig);\r\n}\r\nstatic float64 addFloat64Sigs(float64 a, float64 b, flag zSign)\r\n{\r\nint16 aExp, bExp, zExp;\r\nbits64 aSig, bSig, zSig;\r\nint16 expDiff;\r\naSig = extractFloat64Frac(a);\r\naExp = extractFloat64Exp(a);\r\nbSig = extractFloat64Frac(b);\r\nbExp = extractFloat64Exp(b);\r\nexpDiff = aExp - bExp;\r\naSig <<= 9;\r\nbSig <<= 9;\r\nif (0 < expDiff) {\r\nif (aExp == 0x7FF) {\r\nreturn a;\r\n}\r\nif (bExp == 0) {\r\n--expDiff;\r\n} else {\r\nbSig |= LIT64(0x2000000000000000);\r\n}\r\nshift64RightJamming(bSig, expDiff, &bSig);\r\nzExp = aExp;\r\n} else if (expDiff < 0) {\r\nif (bExp == 0x7FF) {\r\nreturn packFloat64(zSign, 0x7FF, 0);\r\n}\r\nif (aExp == 0) {\r\n++expDiff;\r\n} else {\r\naSig |= LIT64(0x2000000000000000);\r\n}\r\nshift64RightJamming(aSig, -expDiff, &aSig);\r\nzExp = bExp;\r\n} else {\r\nif (aExp == 0x7FF) {\r\nreturn a;\r\n}\r\nif (aExp == 0)\r\nreturn packFloat64(zSign, 0, (aSig + bSig) >> 9);\r\nzSig = LIT64(0x4000000000000000) + aSig + bSig;\r\nzExp = aExp;\r\ngoto roundAndPack;\r\n}\r\naSig |= LIT64(0x2000000000000000);\r\nzSig = (aSig + bSig) << 1;\r\n--zExp;\r\nif ((sbits64) zSig < 0) {\r\nzSig = aSig + bSig;\r\n++zExp;\r\n}\r\nroundAndPack:\r\nreturn roundAndPackFloat64(zSign, zExp, zSig);\r\n}\r\nfloat32 packFloat32(flag zSign, int16 zExp, bits32 zSig)\r\n{\r\nreturn (((bits32) zSign) << 31) + (((bits32) zExp) << 23) + zSig;\r\n}\r\nvoid shift32RightJamming(bits32 a, int16 count, bits32 * zPtr)\r\n{\r\nbits32 z;\r\nif (count == 0) {\r\nz = a;\r\n} else if (count < 32) {\r\nz = (a >> count) | ((a << ((-count) & 31)) != 0);\r\n} else {\r\nz = (a != 0);\r\n}\r\n*zPtr = z;\r\n}\r\nstatic float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)\r\n{\r\nflag roundNearestEven;\r\nint8 roundIncrement, roundBits;\r\nflag isTiny;\r\nroundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);\r\nroundIncrement = 0x40;\r\nif (!roundNearestEven) {\r\nroundIncrement = 0;\r\n}\r\nroundBits = zSig & 0x7F;\r\nif (0xFD <= (bits16) zExp) {\r\nif ((0xFD < zExp)\r\n|| ((zExp == 0xFD)\r\n&& ((sbits32) (zSig + roundIncrement) < 0))\r\n) {\r\nfloat_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);\r\nreturn packFloat32(zSign, 0xFF,\r\n0) - (roundIncrement == 0);\r\n}\r\nif (zExp < 0) {\r\nisTiny = (zExp < -1)\r\n|| (zSig + roundIncrement < 0x80000000);\r\nshift32RightJamming(zSig, -zExp, &zSig);\r\nzExp = 0;\r\nroundBits = zSig & 0x7F;\r\nif (isTiny && roundBits)\r\nfloat_raise(FPSCR_CAUSE_UNDERFLOW);\r\n}\r\n}\r\nif (roundBits)\r\nfloat_raise(FPSCR_CAUSE_INEXACT);\r\nzSig = (zSig + roundIncrement) >> 7;\r\nzSig &= ~(((roundBits ^ 0x40) == 0) & roundNearestEven);\r\nif (zSig == 0)\r\nzExp = 0;\r\nreturn packFloat32(zSign, zExp, zSig);\r\n}\r\nstatic float32 normalizeRoundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)\r\n{\r\nint8 shiftCount;\r\nshiftCount = countLeadingZeros32(zSig) - 1;\r\nreturn roundAndPackFloat32(zSign, zExp - shiftCount,\r\nzSig << shiftCount);\r\n}\r\nstatic float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)\r\n{\r\nflag roundNearestEven;\r\nint16 roundIncrement, roundBits;\r\nflag isTiny;\r\nroundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);\r\nroundIncrement = 0x200;\r\nif (!roundNearestEven) {\r\nroundIncrement = 0;\r\n}\r\nroundBits = zSig & 0x3FF;\r\nif (0x7FD <= (bits16) zExp) {\r\nif ((0x7FD < zExp)\r\n|| ((zExp == 0x7FD)\r\n&& ((sbits64) (zSig + roundIncrement) < 0))\r\n) {\r\nfloat_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);\r\nreturn packFloat64(zSign, 0x7FF,\r\n0) - (roundIncrement == 0);\r\n}\r\nif (zExp < 0) {\r\nisTiny = (zExp < -1)\r\n|| (zSig + roundIncrement <\r\nLIT64(0x8000000000000000));\r\nshift64RightJamming(zSig, -zExp, &zSig);\r\nzExp = 0;\r\nroundBits = zSig & 0x3FF;\r\nif (isTiny && roundBits)\r\nfloat_raise(FPSCR_CAUSE_UNDERFLOW);\r\n}\r\n}\r\nif (roundBits)\r\nfloat_raise(FPSCR_CAUSE_INEXACT);\r\nzSig = (zSig + roundIncrement) >> 10;\r\nzSig &= ~(((roundBits ^ 0x200) == 0) & roundNearestEven);\r\nif (zSig == 0)\r\nzExp = 0;\r\nreturn packFloat64(zSign, zExp, zSig);\r\n}\r\nstatic float32 subFloat32Sigs(float32 a, float32 b, flag zSign)\r\n{\r\nint16 aExp, bExp, zExp;\r\nbits32 aSig, bSig, zSig;\r\nint16 expDiff;\r\naSig = extractFloat32Frac(a);\r\naExp = extractFloat32Exp(a);\r\nbSig = extractFloat32Frac(b);\r\nbExp = extractFloat32Exp(b);\r\nexpDiff = aExp - bExp;\r\naSig <<= 7;\r\nbSig <<= 7;\r\nif (0 < expDiff)\r\ngoto aExpBigger;\r\nif (expDiff < 0)\r\ngoto bExpBigger;\r\nif (aExp == 0) {\r\naExp = 1;\r\nbExp = 1;\r\n}\r\nif (bSig < aSig)\r\ngoto aBigger;\r\nif (aSig < bSig)\r\ngoto bBigger;\r\nreturn packFloat32(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);\r\nbExpBigger:\r\nif (bExp == 0xFF) {\r\nreturn packFloat32(zSign ^ 1, 0xFF, 0);\r\n}\r\nif (aExp == 0) {\r\n++expDiff;\r\n} else {\r\naSig |= 0x40000000;\r\n}\r\nshift32RightJamming(aSig, -expDiff, &aSig);\r\nbSig |= 0x40000000;\r\nbBigger:\r\nzSig = bSig - aSig;\r\nzExp = bExp;\r\nzSign ^= 1;\r\ngoto normalizeRoundAndPack;\r\naExpBigger:\r\nif (aExp == 0xFF) {\r\nreturn a;\r\n}\r\nif (bExp == 0) {\r\n--expDiff;\r\n} else {\r\nbSig |= 0x40000000;\r\n}\r\nshift32RightJamming(bSig, expDiff, &bSig);\r\naSig |= 0x40000000;\r\naBigger:\r\nzSig = aSig - bSig;\r\nzExp = aExp;\r\nnormalizeRoundAndPack:\r\n--zExp;\r\nreturn normalizeRoundAndPackFloat32(zSign, zExp, zSig);\r\n}\r\nstatic float32 addFloat32Sigs(float32 a, float32 b, flag zSign)\r\n{\r\nint16 aExp, bExp, zExp;\r\nbits32 aSig, bSig, zSig;\r\nint16 expDiff;\r\naSig = extractFloat32Frac(a);\r\naExp = extractFloat32Exp(a);\r\nbSig = extractFloat32Frac(b);\r\nbExp = extractFloat32Exp(b);\r\nexpDiff = aExp - bExp;\r\naSig <<= 6;\r\nbSig <<= 6;\r\nif (0 < expDiff) {\r\nif (aExp == 0xFF) {\r\nreturn a;\r\n}\r\nif (bExp == 0) {\r\n--expDiff;\r\n} else {\r\nbSig |= 0x20000000;\r\n}\r\nshift32RightJamming(bSig, expDiff, &bSig);\r\nzExp = aExp;\r\n} else if (expDiff < 0) {\r\nif (bExp == 0xFF) {\r\nreturn packFloat32(zSign, 0xFF, 0);\r\n}\r\nif (aExp == 0) {\r\n++expDiff;\r\n} else {\r\naSig |= 0x20000000;\r\n}\r\nshift32RightJamming(aSig, -expDiff, &aSig);\r\nzExp = bExp;\r\n} else {\r\nif (aExp == 0xFF) {\r\nreturn a;\r\n}\r\nif (aExp == 0)\r\nreturn packFloat32(zSign, 0, (aSig + bSig) >> 6);\r\nzSig = 0x40000000 + aSig + bSig;\r\nzExp = aExp;\r\ngoto roundAndPack;\r\n}\r\naSig |= 0x20000000;\r\nzSig = (aSig + bSig) << 1;\r\n--zExp;\r\nif ((sbits32) zSig < 0) {\r\nzSig = aSig + bSig;\r\n++zExp;\r\n}\r\nroundAndPack:\r\nreturn roundAndPackFloat32(zSign, zExp, zSig);\r\n}\r\nfloat64 float64_sub(float64 a, float64 b)\r\n{\r\nflag aSign, bSign;\r\naSign = extractFloat64Sign(a);\r\nbSign = extractFloat64Sign(b);\r\nif (aSign == bSign) {\r\nreturn subFloat64Sigs(a, b, aSign);\r\n} else {\r\nreturn addFloat64Sigs(a, b, aSign);\r\n}\r\n}\r\nfloat32 float32_sub(float32 a, float32 b)\r\n{\r\nflag aSign, bSign;\r\naSign = extractFloat32Sign(a);\r\nbSign = extractFloat32Sign(b);\r\nif (aSign == bSign) {\r\nreturn subFloat32Sigs(a, b, aSign);\r\n} else {\r\nreturn addFloat32Sigs(a, b, aSign);\r\n}\r\n}\r\nfloat32 float32_add(float32 a, float32 b)\r\n{\r\nflag aSign, bSign;\r\naSign = extractFloat32Sign(a);\r\nbSign = extractFloat32Sign(b);\r\nif (aSign == bSign) {\r\nreturn addFloat32Sigs(a, b, aSign);\r\n} else {\r\nreturn subFloat32Sigs(a, b, aSign);\r\n}\r\n}\r\nfloat64 float64_add(float64 a, float64 b)\r\n{\r\nflag aSign, bSign;\r\naSign = extractFloat64Sign(a);\r\nbSign = extractFloat64Sign(b);\r\nif (aSign == bSign) {\r\nreturn addFloat64Sigs(a, b, aSign);\r\n} else {\r\nreturn subFloat64Sigs(a, b, aSign);\r\n}\r\n}\r\nstatic void\r\nnormalizeFloat64Subnormal(bits64 aSig, int16 * zExpPtr, bits64 * zSigPtr)\r\n{\r\nint8 shiftCount;\r\nshiftCount = countLeadingZeros64(aSig) - 11;\r\n*zSigPtr = aSig << shiftCount;\r\n*zExpPtr = 1 - shiftCount;\r\n}\r\nvoid add128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,\r\nbits64 * z1Ptr)\r\n{\r\nbits64 z1;\r\nz1 = a1 + b1;\r\n*z1Ptr = z1;\r\n*z0Ptr = a0 + b0 + (z1 < a1);\r\n}\r\nvoid\r\nsub128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,\r\nbits64 * z1Ptr)\r\n{\r\n*z1Ptr = a1 - b1;\r\n*z0Ptr = a0 - b0 - (a1 < b1);\r\n}\r\nstatic bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b)\r\n{\r\nbits64 b0, b1;\r\nbits64 rem0, rem1, term0, term1;\r\nbits64 z, tmp;\r\nif (b <= a0)\r\nreturn LIT64(0xFFFFFFFFFFFFFFFF);\r\nb0 = b >> 32;\r\ntmp = a0;\r\ndo_div(tmp, b0);\r\nz = (b0 << 32 <= a0) ? LIT64(0xFFFFFFFF00000000) : tmp << 32;\r\nmul64To128(b, z, &term0, &term1);\r\nsub128(a0, a1, term0, term1, &rem0, &rem1);\r\nwhile (((sbits64) rem0) < 0) {\r\nz -= LIT64(0x100000000);\r\nb1 = b << 32;\r\nadd128(rem0, rem1, b0, b1, &rem0, &rem1);\r\n}\r\nrem0 = (rem0 << 32) | (rem1 >> 32);\r\ntmp = rem0;\r\ndo_div(tmp, b0);\r\nz |= (b0 << 32 <= rem0) ? 0xFFFFFFFF : tmp;\r\nreturn z;\r\n}\r\nvoid mul64To128(bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr)\r\n{\r\nbits32 aHigh, aLow, bHigh, bLow;\r\nbits64 z0, zMiddleA, zMiddleB, z1;\r\naLow = a;\r\naHigh = a >> 32;\r\nbLow = b;\r\nbHigh = b >> 32;\r\nz1 = ((bits64) aLow) * bLow;\r\nzMiddleA = ((bits64) aLow) * bHigh;\r\nzMiddleB = ((bits64) aHigh) * bLow;\r\nz0 = ((bits64) aHigh) * bHigh;\r\nzMiddleA += zMiddleB;\r\nz0 += (((bits64) (zMiddleA < zMiddleB)) << 32) + (zMiddleA >> 32);\r\nzMiddleA <<= 32;\r\nz1 += zMiddleA;\r\nz0 += (z1 < zMiddleA);\r\n*z1Ptr = z1;\r\n*z0Ptr = z0;\r\n}\r\nstatic void normalizeFloat32Subnormal(bits32 aSig, int16 * zExpPtr,\r\nbits32 * zSigPtr)\r\n{\r\nint8 shiftCount;\r\nshiftCount = countLeadingZeros32(aSig) - 8;\r\n*zSigPtr = aSig << shiftCount;\r\n*zExpPtr = 1 - shiftCount;\r\n}\r\nfloat64 float64_div(float64 a, float64 b)\r\n{\r\nflag aSign, bSign, zSign;\r\nint16 aExp, bExp, zExp;\r\nbits64 aSig, bSig, zSig;\r\nbits64 rem0, rem1;\r\nbits64 term0, term1;\r\naSig = extractFloat64Frac(a);\r\naExp = extractFloat64Exp(a);\r\naSign = extractFloat64Sign(a);\r\nbSig = extractFloat64Frac(b);\r\nbExp = extractFloat64Exp(b);\r\nbSign = extractFloat64Sign(b);\r\nzSign = aSign ^ bSign;\r\nif (aExp == 0x7FF) {\r\nif (bExp == 0x7FF) {\r\n}\r\nreturn packFloat64(zSign, 0x7FF, 0);\r\n}\r\nif (bExp == 0x7FF) {\r\nreturn packFloat64(zSign, 0, 0);\r\n}\r\nif (bExp == 0) {\r\nif (bSig == 0) {\r\nif ((aExp | aSig) == 0) {\r\nfloat_raise(FPSCR_CAUSE_INVALID);\r\n}\r\nreturn packFloat64(zSign, 0x7FF, 0);\r\n}\r\nnormalizeFloat64Subnormal(bSig, &bExp, &bSig);\r\n}\r\nif (aExp == 0) {\r\nif (aSig == 0)\r\nreturn packFloat64(zSign, 0, 0);\r\nnormalizeFloat64Subnormal(aSig, &aExp, &aSig);\r\n}\r\nzExp = aExp - bExp + 0x3FD;\r\naSig = (aSig | LIT64(0x0010000000000000)) << 10;\r\nbSig = (bSig | LIT64(0x0010000000000000)) << 11;\r\nif (bSig <= (aSig + aSig)) {\r\naSig >>= 1;\r\n++zExp;\r\n}\r\nzSig = estimateDiv128To64(aSig, 0, bSig);\r\nif ((zSig & 0x1FF) <= 2) {\r\nmul64To128(bSig, zSig, &term0, &term1);\r\nsub128(aSig, 0, term0, term1, &rem0, &rem1);\r\nwhile ((sbits64) rem0 < 0) {\r\n--zSig;\r\nadd128(rem0, rem1, 0, bSig, &rem0, &rem1);\r\n}\r\nzSig |= (rem1 != 0);\r\n}\r\nreturn roundAndPackFloat64(zSign, zExp, zSig);\r\n}\r\nfloat32 float32_div(float32 a, float32 b)\r\n{\r\nflag aSign, bSign, zSign;\r\nint16 aExp, bExp, zExp;\r\nbits32 aSig, bSig;\r\nuint64_t zSig;\r\naSig = extractFloat32Frac(a);\r\naExp = extractFloat32Exp(a);\r\naSign = extractFloat32Sign(a);\r\nbSig = extractFloat32Frac(b);\r\nbExp = extractFloat32Exp(b);\r\nbSign = extractFloat32Sign(b);\r\nzSign = aSign ^ bSign;\r\nif (aExp == 0xFF) {\r\nif (bExp == 0xFF) {\r\n}\r\nreturn packFloat32(zSign, 0xFF, 0);\r\n}\r\nif (bExp == 0xFF) {\r\nreturn packFloat32(zSign, 0, 0);\r\n}\r\nif (bExp == 0) {\r\nif (bSig == 0) {\r\nreturn packFloat32(zSign, 0xFF, 0);\r\n}\r\nnormalizeFloat32Subnormal(bSig, &bExp, &bSig);\r\n}\r\nif (aExp == 0) {\r\nif (aSig == 0)\r\nreturn packFloat32(zSign, 0, 0);\r\nnormalizeFloat32Subnormal(aSig, &aExp, &aSig);\r\n}\r\nzExp = aExp - bExp + 0x7D;\r\naSig = (aSig | 0x00800000) << 7;\r\nbSig = (bSig | 0x00800000) << 8;\r\nif (bSig <= (aSig + aSig)) {\r\naSig >>= 1;\r\n++zExp;\r\n}\r\nzSig = (((bits64) aSig) << 32);\r\ndo_div(zSig, bSig);\r\nif ((zSig & 0x3F) == 0) {\r\nzSig |= (((bits64) bSig) * zSig != ((bits64) aSig) << 32);\r\n}\r\nreturn roundAndPackFloat32(zSign, zExp, (bits32)zSig);\r\n}\r\nfloat32 float32_mul(float32 a, float32 b)\r\n{\r\nchar aSign, bSign, zSign;\r\nint aExp, bExp, zExp;\r\nunsigned int aSig, bSig;\r\nunsigned long long zSig64;\r\nunsigned int zSig;\r\naSig = extractFloat32Frac(a);\r\naExp = extractFloat32Exp(a);\r\naSign = extractFloat32Sign(a);\r\nbSig = extractFloat32Frac(b);\r\nbExp = extractFloat32Exp(b);\r\nbSign = extractFloat32Sign(b);\r\nzSign = aSign ^ bSign;\r\nif (aExp == 0) {\r\nif (aSig == 0)\r\nreturn packFloat32(zSign, 0, 0);\r\nnormalizeFloat32Subnormal(aSig, &aExp, &aSig);\r\n}\r\nif (bExp == 0) {\r\nif (bSig == 0)\r\nreturn packFloat32(zSign, 0, 0);\r\nnormalizeFloat32Subnormal(bSig, &bExp, &bSig);\r\n}\r\nif ((bExp == 0xff && bSig == 0) || (aExp == 0xff && aSig == 0))\r\nreturn roundAndPackFloat32(zSign, 0xff, 0);\r\nzExp = aExp + bExp - 0x7F;\r\naSig = (aSig | 0x00800000) << 7;\r\nbSig = (bSig | 0x00800000) << 8;\r\nshift64RightJamming(((unsigned long long)aSig) * bSig, 32, &zSig64);\r\nzSig = zSig64;\r\nif (0 <= (signed int)(zSig << 1)) {\r\nzSig <<= 1;\r\n--zExp;\r\n}\r\nreturn roundAndPackFloat32(zSign, zExp, zSig);\r\n}\r\nfloat64 float64_mul(float64 a, float64 b)\r\n{\r\nchar aSign, bSign, zSign;\r\nint aExp, bExp, zExp;\r\nunsigned long long int aSig, bSig, zSig0, zSig1;\r\naSig = extractFloat64Frac(a);\r\naExp = extractFloat64Exp(a);\r\naSign = extractFloat64Sign(a);\r\nbSig = extractFloat64Frac(b);\r\nbExp = extractFloat64Exp(b);\r\nbSign = extractFloat64Sign(b);\r\nzSign = aSign ^ bSign;\r\nif (aExp == 0) {\r\nif (aSig == 0)\r\nreturn packFloat64(zSign, 0, 0);\r\nnormalizeFloat64Subnormal(aSig, &aExp, &aSig);\r\n}\r\nif (bExp == 0) {\r\nif (bSig == 0)\r\nreturn packFloat64(zSign, 0, 0);\r\nnormalizeFloat64Subnormal(bSig, &bExp, &bSig);\r\n}\r\nif ((aExp == 0x7ff && aSig == 0) || (bExp == 0x7ff && bSig == 0))\r\nreturn roundAndPackFloat64(zSign, 0x7ff, 0);\r\nzExp = aExp + bExp - 0x3FF;\r\naSig = (aSig | 0x0010000000000000LL) << 10;\r\nbSig = (bSig | 0x0010000000000000LL) << 11;\r\nmul64To128(aSig, bSig, &zSig0, &zSig1);\r\nzSig0 |= (zSig1 != 0);\r\nif (0 <= (signed long long int)(zSig0 << 1)) {\r\nzSig0 <<= 1;\r\n--zExp;\r\n}\r\nreturn roundAndPackFloat64(zSign, zExp, zSig0);\r\n}\r\nfloat32 float64_to_float32(float64 a)\r\n{\r\nflag aSign;\r\nint16 aExp;\r\nbits64 aSig;\r\nbits32 zSig;\r\naSig = extractFloat64Frac( a );\r\naExp = extractFloat64Exp( a );\r\naSign = extractFloat64Sign( a );\r\nshift64RightJamming( aSig, 22, &aSig );\r\nzSig = aSig;\r\nif ( aExp || zSig ) {\r\nzSig |= 0x40000000;\r\naExp -= 0x381;\r\n}\r\nreturn roundAndPackFloat32(aSign, aExp, zSig);\r\n}
