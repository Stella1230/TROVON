static unsigned long z2_read_bat(struct z2_charger *charger)\r\n{\r\nint data;\r\ndata = i2c_smbus_read_byte_data(charger->client,\r\ncharger->info->batt_I2C_reg);\r\nif (data < 0)\r\nreturn 0;\r\nreturn data * charger->info->batt_mult / charger->info->batt_div;\r\n}\r\nstatic int z2_batt_get_property(struct power_supply *batt_ps,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct z2_charger *charger = container_of(batt_ps, struct z2_charger,\r\nbatt_ps);\r\nstruct z2_battery_info *info = charger->info;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = charger->bat_status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = info->batt_tech;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (info->batt_I2C_reg >= 0)\r\nval->intval = z2_read_bat(charger);\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX:\r\nif (info->max_voltage >= 0)\r\nval->intval = info->max_voltage;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN:\r\nif (info->min_voltage >= 0)\r\nval->intval = info->min_voltage;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void z2_batt_ext_power_changed(struct power_supply *batt_ps)\r\n{\r\nstruct z2_charger *charger = container_of(batt_ps, struct z2_charger,\r\nbatt_ps);\r\nschedule_work(&charger->bat_work);\r\n}\r\nstatic void z2_batt_update(struct z2_charger *charger)\r\n{\r\nint old_status = charger->bat_status;\r\nstruct z2_battery_info *info;\r\ninfo = charger->info;\r\nmutex_lock(&charger->work_lock);\r\ncharger->bat_status = (info->charge_gpio >= 0) ?\r\n(gpio_get_value(info->charge_gpio) ?\r\nPOWER_SUPPLY_STATUS_CHARGING :\r\nPOWER_SUPPLY_STATUS_DISCHARGING) :\r\nPOWER_SUPPLY_STATUS_UNKNOWN;\r\nif (old_status != charger->bat_status) {\r\npr_debug("%s: %i -> %i\n", charger->batt_ps.name, old_status,\r\ncharger->bat_status);\r\npower_supply_changed(&charger->batt_ps);\r\n}\r\nmutex_unlock(&charger->work_lock);\r\n}\r\nstatic void z2_batt_work(struct work_struct *work)\r\n{\r\nstruct z2_charger *charger;\r\ncharger = container_of(work, struct z2_charger, bat_work);\r\nz2_batt_update(charger);\r\n}\r\nstatic irqreturn_t z2_charge_switch_irq(int irq, void *devid)\r\n{\r\nstruct z2_charger *charger = devid;\r\nschedule_work(&charger->bat_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int z2_batt_ps_init(struct z2_charger *charger, int props)\r\n{\r\nint i = 0;\r\nenum power_supply_property *prop;\r\nstruct z2_battery_info *info = charger->info;\r\nif (info->charge_gpio >= 0)\r\nprops++;\r\nif (info->batt_tech >= 0)\r\nprops++;\r\nif (info->batt_I2C_reg >= 0)\r\nprops++;\r\nif (info->max_voltage >= 0)\r\nprops++;\r\nif (info->min_voltage >= 0)\r\nprops++;\r\nprop = kzalloc(props * sizeof(*prop), GFP_KERNEL);\r\nif (!prop)\r\nreturn -ENOMEM;\r\nprop[i++] = POWER_SUPPLY_PROP_PRESENT;\r\nif (info->charge_gpio >= 0)\r\nprop[i++] = POWER_SUPPLY_PROP_STATUS;\r\nif (info->batt_tech >= 0)\r\nprop[i++] = POWER_SUPPLY_PROP_TECHNOLOGY;\r\nif (info->batt_I2C_reg >= 0)\r\nprop[i++] = POWER_SUPPLY_PROP_VOLTAGE_NOW;\r\nif (info->max_voltage >= 0)\r\nprop[i++] = POWER_SUPPLY_PROP_VOLTAGE_MAX;\r\nif (info->min_voltage >= 0)\r\nprop[i++] = POWER_SUPPLY_PROP_VOLTAGE_MIN;\r\nif (!info->batt_name) {\r\ndev_info(&charger->client->dev,\r\n"Please consider setting proper battery "\r\n"name in platform definition file, falling "\r\n"back to name \" Z2_DEFAULT_NAME \"\n");\r\ncharger->batt_ps.name = Z2_DEFAULT_NAME;\r\n} else\r\ncharger->batt_ps.name = info->batt_name;\r\ncharger->batt_ps.properties = prop;\r\ncharger->batt_ps.num_properties = props;\r\ncharger->batt_ps.type = POWER_SUPPLY_TYPE_BATTERY;\r\ncharger->batt_ps.get_property = z2_batt_get_property;\r\ncharger->batt_ps.external_power_changed = z2_batt_ext_power_changed;\r\ncharger->batt_ps.use_for_apm = 1;\r\nreturn 0;\r\n}\r\nstatic int __devinit z2_batt_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret = 0;\r\nint props = 1;\r\nstruct z2_charger *charger;\r\nstruct z2_battery_info *info = client->dev.platform_data;\r\nif (info == NULL) {\r\ndev_err(&client->dev,\r\n"Please set platform device platform_data"\r\n" to a valid z2_battery_info pointer!\n");\r\nreturn -EINVAL;\r\n}\r\ncharger = kzalloc(sizeof(*charger), GFP_KERNEL);\r\nif (charger == NULL)\r\nreturn -ENOMEM;\r\ncharger->bat_status = POWER_SUPPLY_STATUS_UNKNOWN;\r\ncharger->info = info;\r\ncharger->client = client;\r\ni2c_set_clientdata(client, charger);\r\nmutex_init(&charger->work_lock);\r\nif (info->charge_gpio >= 0 && gpio_is_valid(info->charge_gpio)) {\r\nret = gpio_request(info->charge_gpio, "BATT CHRG");\r\nif (ret)\r\ngoto err;\r\nret = gpio_direction_input(info->charge_gpio);\r\nif (ret)\r\ngoto err2;\r\nirq_set_irq_type(gpio_to_irq(info->charge_gpio),\r\nIRQ_TYPE_EDGE_BOTH);\r\nret = request_irq(gpio_to_irq(info->charge_gpio),\r\nz2_charge_switch_irq, IRQF_DISABLED,\r\n"AC Detect", charger);\r\nif (ret)\r\ngoto err3;\r\n}\r\nret = z2_batt_ps_init(charger, props);\r\nif (ret)\r\ngoto err3;\r\nINIT_WORK(&charger->bat_work, z2_batt_work);\r\nret = power_supply_register(&client->dev, &charger->batt_ps);\r\nif (ret)\r\ngoto err4;\r\nschedule_work(&charger->bat_work);\r\nreturn 0;\r\nerr4:\r\nkfree(charger->batt_ps.properties);\r\nerr3:\r\nif (info->charge_gpio >= 0 && gpio_is_valid(info->charge_gpio))\r\nfree_irq(gpio_to_irq(info->charge_gpio), charger);\r\nerr2:\r\nif (info->charge_gpio >= 0 && gpio_is_valid(info->charge_gpio))\r\ngpio_free(info->charge_gpio);\r\nerr:\r\nkfree(charger);\r\nreturn ret;\r\n}\r\nstatic int __devexit z2_batt_remove(struct i2c_client *client)\r\n{\r\nstruct z2_charger *charger = i2c_get_clientdata(client);\r\nstruct z2_battery_info *info = charger->info;\r\ncancel_work_sync(&charger->bat_work);\r\npower_supply_unregister(&charger->batt_ps);\r\nkfree(charger->batt_ps.properties);\r\nif (info->charge_gpio >= 0 && gpio_is_valid(info->charge_gpio)) {\r\nfree_irq(gpio_to_irq(info->charge_gpio), charger);\r\ngpio_free(info->charge_gpio);\r\n}\r\nkfree(charger);\r\nreturn 0;\r\n}\r\nstatic int z2_batt_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct z2_charger *charger = i2c_get_clientdata(client);\r\nflush_work_sync(&charger->bat_work);\r\nreturn 0;\r\n}\r\nstatic int z2_batt_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct z2_charger *charger = i2c_get_clientdata(client);\r\nschedule_work(&charger->bat_work);\r\nreturn 0;\r\n}\r\nstatic int __init z2_batt_init(void)\r\n{\r\nreturn i2c_add_driver(&z2_batt_driver);\r\n}\r\nstatic void __exit z2_batt_exit(void)\r\n{\r\ni2c_del_driver(&z2_batt_driver);\r\n}
