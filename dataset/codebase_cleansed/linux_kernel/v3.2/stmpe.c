static int __stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nreturn stmpe->variant->enable(stmpe, blocks, true);\r\n}\r\nstatic int __stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nreturn stmpe->variant->enable(stmpe, blocks, false);\r\n}\r\nstatic int __stmpe_reg_read(struct stmpe *stmpe, u8 reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(stmpe->i2c, reg);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to read reg %#x: %d\n",\r\nreg, ret);\r\ndev_vdbg(stmpe->dev, "rd: reg %#x => data %#x\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\r\n{\r\nint ret;\r\ndev_vdbg(stmpe->dev, "wr: reg %#x <= %#x\n", reg, val);\r\nret = i2c_smbus_write_byte_data(stmpe->i2c, reg, val);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to write reg %#x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nret = __stmpe_reg_read(stmpe, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~mask;\r\nret |= val;\r\nreturn __stmpe_reg_write(stmpe, reg, ret);\r\n}\r\nstatic int __stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length,\r\nu8 *values)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data(stmpe->i2c, reg, length, values);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to read regs %#x: %d\n",\r\nreg, ret);\r\ndev_vdbg(stmpe->dev, "rd: reg %#x (%d) => ret %#x\n", reg, length, ret);\r\nstmpe_dump_bytes("stmpe rd: ", values, length);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nint ret;\r\ndev_vdbg(stmpe->dev, "wr: regs %#x (%d)\n", reg, length);\r\nstmpe_dump_bytes("stmpe wr: ", values, length);\r\nret = i2c_smbus_write_i2c_block_data(stmpe->i2c, reg, length,\r\nvalues);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to write regs %#x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nint stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_enable(stmpe, blocks);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_disable(stmpe, blocks);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_reg_read(struct stmpe *stmpe, u8 reg)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_reg_read(stmpe, reg);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_reg_write(stmpe, reg, val);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_set_bits(stmpe, reg, mask, val);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length, u8 *values)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_block_read(stmpe, reg, length, values);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_block_write(stmpe, reg, length, values);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_set_altfunc(struct stmpe *stmpe, u32 pins, enum stmpe_block block)\r\n{\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nu8 regaddr = stmpe->regs[STMPE_IDX_GPAFR_U_MSB];\r\nint af_bits = variant->af_bits;\r\nint numregs = DIV_ROUND_UP(stmpe->num_gpios * af_bits, 8);\r\nint afperreg = 8 / af_bits;\r\nint mask = (1 << af_bits) - 1;\r\nu8 regs[numregs];\r\nint af;\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\r\nif (ret < 0)\r\ngoto out;\r\nret = __stmpe_block_read(stmpe, regaddr, numregs, regs);\r\nif (ret < 0)\r\ngoto out;\r\naf = variant->get_altfunc(stmpe, block);\r\nwhile (pins) {\r\nint pin = __ffs(pins);\r\nint regoffset = numregs - (pin / afperreg) - 1;\r\nint pos = (pin % afperreg) * (8 / afperreg);\r\nregs[regoffset] &= ~(mask << pos);\r\nregs[regoffset] |= af << pos;\r\npins &= ~(1 << pin);\r\n}\r\nret = __stmpe_block_write(stmpe, regaddr, numregs, regs);\r\nout:\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nstatic int stmpe811_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE811_SYS_CTRL2_GPIO_OFF;\r\nif (blocks & STMPE_BLOCK_ADC)\r\nmask |= STMPE811_SYS_CTRL2_ADC_OFF;\r\nif (blocks & STMPE_BLOCK_TOUCHSCREEN)\r\nmask |= STMPE811_SYS_CTRL2_TSC_OFF;\r\nreturn __stmpe_set_bits(stmpe, STMPE811_REG_SYS_CTRL2, mask,\r\nenable ? 0 : mask);\r\n}\r\nstatic int stmpe811_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nreturn block != STMPE_BLOCK_TOUCHSCREEN;\r\n}\r\nstatic int stmpe_round_timeout(int timeout)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(stmpe_autosleep_delay); i++) {\r\nif (stmpe_autosleep_delay[i] >= timeout)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stmpe_autosleep(struct stmpe *stmpe, int autosleep_timeout)\r\n{\r\nint ret;\r\nif (!stmpe->variant->enable_autosleep)\r\nreturn -ENOSYS;\r\nmutex_lock(&stmpe->lock);\r\nret = stmpe->variant->enable_autosleep(stmpe, autosleep_timeout);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nstatic int stmpe1601_autosleep(struct stmpe *stmpe,\r\nint autosleep_timeout)\r\n{\r\nint ret, timeout;\r\ntimeout = stmpe_round_timeout(autosleep_timeout);\r\nif (timeout < 0) {\r\ndev_err(stmpe->dev, "invalid timeout\n");\r\nreturn timeout;\r\n}\r\nret = __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL2,\r\nSTMPE1601_AUTOSLEEP_TIMEOUT_MASK,\r\ntimeout);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL2,\r\nSTPME1601_AUTOSLEEP_ENABLE,\r\nSTPME1601_AUTOSLEEP_ENABLE);\r\n}\r\nstatic int stmpe1601_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE1601_SYS_CTRL_ENABLE_GPIO;\r\nif (blocks & STMPE_BLOCK_KEYPAD)\r\nmask |= STMPE1601_SYS_CTRL_ENABLE_KPC;\r\nreturn __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL, mask,\r\nenable ? mask : 0);\r\n}\r\nstatic int stmpe1601_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nswitch (block) {\r\ncase STMPE_BLOCK_PWM:\r\nreturn 2;\r\ncase STMPE_BLOCK_KEYPAD:\r\nreturn 1;\r\ncase STMPE_BLOCK_GPIO:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int stmpe24xx_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE24XX_SYS_CTRL_ENABLE_GPIO;\r\nif (blocks & STMPE_BLOCK_KEYPAD)\r\nmask |= STMPE24XX_SYS_CTRL_ENABLE_KPC;\r\nreturn __stmpe_set_bits(stmpe, STMPE24XX_REG_SYS_CTRL, mask,\r\nenable ? mask : 0);\r\n}\r\nstatic int stmpe24xx_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nswitch (block) {\r\ncase STMPE_BLOCK_ROTATOR:\r\nreturn 2;\r\ncase STMPE_BLOCK_KEYPAD:\r\nreturn 1;\r\ncase STMPE_BLOCK_GPIO:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic irqreturn_t stmpe_irq(int irq, void *data)\r\n{\r\nstruct stmpe *stmpe = data;\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nint num = DIV_ROUND_UP(variant->num_irqs, 8);\r\nu8 israddr = stmpe->regs[STMPE_IDX_ISR_MSB];\r\nu8 isr[num];\r\nint ret;\r\nint i;\r\nret = stmpe_block_read(stmpe, israddr, num, isr);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < num; i++) {\r\nint bank = num - i - 1;\r\nu8 status = isr[i];\r\nu8 clear;\r\nstatus &= stmpe->ier[bank];\r\nif (!status)\r\ncontinue;\r\nclear = status;\r\nwhile (status) {\r\nint bit = __ffs(status);\r\nint line = bank * 8 + bit;\r\nhandle_nested_irq(stmpe->irq_base + line);\r\nstatus &= ~(1 << bit);\r\n}\r\nstmpe_reg_write(stmpe, israddr + i, clear);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void stmpe_irq_lock(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&stmpe->irq_lock);\r\n}\r\nstatic void stmpe_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nint num = DIV_ROUND_UP(variant->num_irqs, 8);\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nu8 new = stmpe->ier[i];\r\nu8 old = stmpe->oldier[i];\r\nif (new == old)\r\ncontinue;\r\nstmpe->oldier[i] = new;\r\nstmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_IER_LSB] - i, new);\r\n}\r\nmutex_unlock(&stmpe->irq_lock);\r\n}\r\nstatic void stmpe_irq_mask(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nint offset = data->irq - stmpe->irq_base;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe->ier[regoffset] &= ~mask;\r\n}\r\nstatic void stmpe_irq_unmask(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nint offset = data->irq - stmpe->irq_base;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe->ier[regoffset] |= mask;\r\n}\r\nstatic int __devinit stmpe_irq_init(struct stmpe *stmpe)\r\n{\r\nint num_irqs = stmpe->variant->num_irqs;\r\nint base = stmpe->irq_base;\r\nint irq;\r\nfor (irq = base; irq < base + num_irqs; irq++) {\r\nirq_set_chip_data(irq, stmpe);\r\nirq_set_chip_and_handler(irq, &stmpe_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_nested_thread(irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void stmpe_irq_remove(struct stmpe *stmpe)\r\n{\r\nint num_irqs = stmpe->variant->num_irqs;\r\nint base = stmpe->irq_base;\r\nint irq;\r\nfor (irq = base; irq < base + num_irqs; irq++) {\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, 0);\r\n#endif\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nirq_set_chip_data(irq, NULL);\r\n}\r\n}\r\nstatic int __devinit stmpe_chip_init(struct stmpe *stmpe)\r\n{\r\nunsigned int irq_trigger = stmpe->pdata->irq_trigger;\r\nint autosleep_timeout = stmpe->pdata->autosleep_timeout;\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nu8 icr = STMPE_ICR_LSB_GIM;\r\nunsigned int id;\r\nu8 data[2];\r\nint ret;\r\nret = stmpe_block_read(stmpe, stmpe->regs[STMPE_IDX_CHIP_ID],\r\nARRAY_SIZE(data), data);\r\nif (ret < 0)\r\nreturn ret;\r\nid = (data[0] << 8) | data[1];\r\nif ((id & variant->id_mask) != variant->id_val) {\r\ndev_err(stmpe->dev, "unknown chip id: %#x\n", id);\r\nreturn -EINVAL;\r\n}\r\ndev_info(stmpe->dev, "%s detected, chip id: %#x\n", variant->name, id);\r\nret = stmpe_disable(stmpe, ~0);\r\nif (ret)\r\nreturn ret;\r\nif (irq_trigger == IRQF_TRIGGER_FALLING ||\r\nirq_trigger == IRQF_TRIGGER_RISING)\r\nicr |= STMPE_ICR_LSB_EDGE;\r\nif (irq_trigger == IRQF_TRIGGER_RISING ||\r\nirq_trigger == IRQF_TRIGGER_HIGH)\r\nicr |= STMPE_ICR_LSB_HIGH;\r\nif (stmpe->pdata->irq_invert_polarity)\r\nicr ^= STMPE_ICR_LSB_HIGH;\r\nif (stmpe->pdata->autosleep) {\r\nret = stmpe_autosleep(stmpe, autosleep_timeout);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn stmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_ICR_LSB], icr);\r\n}\r\nstatic int __devinit stmpe_add_device(struct stmpe *stmpe,\r\nstruct mfd_cell *cell, int irq)\r\n{\r\nreturn mfd_add_devices(stmpe->dev, stmpe->pdata->id, cell, 1,\r\nNULL, stmpe->irq_base + irq);\r\n}\r\nstatic int __devinit stmpe_devices_init(struct stmpe *stmpe)\r\n{\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nunsigned int platform_blocks = stmpe->pdata->blocks;\r\nint ret = -EINVAL;\r\nint i;\r\nfor (i = 0; i < variant->num_blocks; i++) {\r\nstruct stmpe_variant_block *block = &variant->blocks[i];\r\nif (!(platform_blocks & block->block))\r\ncontinue;\r\nplatform_blocks &= ~block->block;\r\nret = stmpe_add_device(stmpe, block->cell, block->irq);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (platform_blocks)\r\ndev_warn(stmpe->dev,\r\n"platform wants blocks (%#x) not present on variant",\r\nplatform_blocks);\r\nreturn ret;\r\n}\r\nstatic int stmpe_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nif (device_may_wakeup(&i2c->dev))\r\nenable_irq_wake(i2c->irq);\r\nreturn 0;\r\n}\r\nstatic int stmpe_resume(struct device *dev)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nif (device_may_wakeup(&i2c->dev))\r\ndisable_irq_wake(i2c->irq);\r\nreturn 0;\r\n}\r\nstatic int __devinit stmpe_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct stmpe_platform_data *pdata = i2c->dev.platform_data;\r\nstruct stmpe *stmpe;\r\nint ret;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nstmpe = kzalloc(sizeof(struct stmpe), GFP_KERNEL);\r\nif (!stmpe)\r\nreturn -ENOMEM;\r\nmutex_init(&stmpe->irq_lock);\r\nmutex_init(&stmpe->lock);\r\nstmpe->dev = &i2c->dev;\r\nstmpe->i2c = i2c;\r\nstmpe->pdata = pdata;\r\nstmpe->irq_base = pdata->irq_base;\r\nstmpe->partnum = id->driver_data;\r\nstmpe->variant = stmpe_variant_info[stmpe->partnum];\r\nstmpe->regs = stmpe->variant->regs;\r\nstmpe->num_gpios = stmpe->variant->num_gpios;\r\ni2c_set_clientdata(i2c, stmpe);\r\nret = stmpe_chip_init(stmpe);\r\nif (ret)\r\ngoto out_free;\r\nret = stmpe_irq_init(stmpe);\r\nif (ret)\r\ngoto out_free;\r\nret = request_threaded_irq(stmpe->i2c->irq, NULL, stmpe_irq,\r\npdata->irq_trigger | IRQF_ONESHOT,\r\n"stmpe", stmpe);\r\nif (ret) {\r\ndev_err(stmpe->dev, "failed to request IRQ: %d\n", ret);\r\ngoto out_removeirq;\r\n}\r\nret = stmpe_devices_init(stmpe);\r\nif (ret) {\r\ndev_err(stmpe->dev, "failed to add children\n");\r\ngoto out_removedevs;\r\n}\r\nreturn 0;\r\nout_removedevs:\r\nmfd_remove_devices(stmpe->dev);\r\nfree_irq(stmpe->i2c->irq, stmpe);\r\nout_removeirq:\r\nstmpe_irq_remove(stmpe);\r\nout_free:\r\nkfree(stmpe);\r\nreturn ret;\r\n}\r\nstatic int __devexit stmpe_remove(struct i2c_client *client)\r\n{\r\nstruct stmpe *stmpe = i2c_get_clientdata(client);\r\nmfd_remove_devices(stmpe->dev);\r\nfree_irq(stmpe->i2c->irq, stmpe);\r\nstmpe_irq_remove(stmpe);\r\nkfree(stmpe);\r\nreturn 0;\r\n}\r\nstatic int __init stmpe_init(void)\r\n{\r\nreturn i2c_add_driver(&stmpe_driver);\r\n}\r\nstatic void __exit stmpe_exit(void)\r\n{\r\ni2c_del_driver(&stmpe_driver);\r\n}
