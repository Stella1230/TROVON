static inline int pohmelfs_mcache_cmp(u64 gen, u64 new)\r\n{\r\nif (gen < new)\r\nreturn 1;\r\nif (gen > new)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstruct pohmelfs_mcache *pohmelfs_mcache_search(struct pohmelfs_sb *psb, u64 gen)\r\n{\r\nstruct rb_root *root = &psb->mcache_root;\r\nstruct rb_node *n = root->rb_node;\r\nstruct pohmelfs_mcache *tmp, *ret = NULL;\r\nint cmp;\r\nwhile (n) {\r\ntmp = rb_entry(n, struct pohmelfs_mcache, mcache_entry);\r\ncmp = pohmelfs_mcache_cmp(tmp->gen, gen);\r\nif (cmp < 0)\r\nn = n->rb_left;\r\nelse if (cmp > 0)\r\nn = n->rb_right;\r\nelse {\r\nret = tmp;\r\npohmelfs_mcache_get(ret);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int pohmelfs_mcache_insert(struct pohmelfs_sb *psb, struct pohmelfs_mcache *m)\r\n{\r\nstruct rb_root *root = &psb->mcache_root;\r\nstruct rb_node **n = &root->rb_node, *parent = NULL;\r\nstruct pohmelfs_mcache *ret = NULL, *tmp;\r\nint cmp;\r\nwhile (*n) {\r\nparent = *n;\r\ntmp = rb_entry(parent, struct pohmelfs_mcache, mcache_entry);\r\ncmp = pohmelfs_mcache_cmp(tmp->gen, m->gen);\r\nif (cmp < 0)\r\nn = &parent->rb_left;\r\nelse if (cmp > 0)\r\nn = &parent->rb_right;\r\nelse {\r\nret = tmp;\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nreturn -EEXIST;\r\nrb_link_node(&m->mcache_entry, parent, n);\r\nrb_insert_color(&m->mcache_entry, root);\r\nreturn 0;\r\n}\r\nstatic int pohmelfs_mcache_remove(struct pohmelfs_sb *psb, struct pohmelfs_mcache *m)\r\n{\r\nif (m && m->mcache_entry.rb_parent_color) {\r\nrb_erase(&m->mcache_entry, &psb->mcache_root);\r\nm->mcache_entry.rb_parent_color = 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid pohmelfs_mcache_remove_locked(struct pohmelfs_sb *psb, struct pohmelfs_mcache *m)\r\n{\r\nmutex_lock(&psb->mcache_lock);\r\npohmelfs_mcache_remove(psb, m);\r\nmutex_unlock(&psb->mcache_lock);\r\n}\r\nstruct pohmelfs_mcache *pohmelfs_mcache_alloc(struct pohmelfs_sb *psb, u64 start,\r\nunsigned int size, void *data)\r\n{\r\nstruct pohmelfs_mcache *m;\r\nint err = -ENOMEM;\r\nm = mempool_alloc(pohmelfs_mcache_pool, GFP_KERNEL);\r\nif (!m)\r\ngoto err_out_exit;\r\ninit_completion(&m->complete);\r\nm->err = 0;\r\natomic_set(&m->refcnt, 1);\r\nm->data = data;\r\nm->start = start;\r\nm->size = size;\r\nm->gen = atomic_long_inc_return(&psb->mcache_gen);\r\nmutex_lock(&psb->mcache_lock);\r\nerr = pohmelfs_mcache_insert(psb, m);\r\nmutex_unlock(&psb->mcache_lock);\r\nif (err)\r\ngoto err_out_free;\r\nreturn m;\r\nerr_out_free:\r\nmempool_free(m, pohmelfs_mcache_pool);\r\nerr_out_exit:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid pohmelfs_mcache_free(struct pohmelfs_sb *psb, struct pohmelfs_mcache *m)\r\n{\r\npohmelfs_mcache_remove_locked(psb, m);\r\nmempool_free(m, pohmelfs_mcache_pool);\r\n}\r\nint __init pohmelfs_mcache_init(void)\r\n{\r\npohmelfs_mcache_cache = kmem_cache_create("pohmelfs_mcache_cache",\r\nsizeof(struct pohmelfs_mcache),\r\n0, (SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD), NULL);\r\nif (!pohmelfs_mcache_cache)\r\ngoto err_out_exit;\r\npohmelfs_mcache_pool = mempool_create_slab_pool(256, pohmelfs_mcache_cache);\r\nif (!pohmelfs_mcache_pool)\r\ngoto err_out_free;\r\nreturn 0;\r\nerr_out_free:\r\nkmem_cache_destroy(pohmelfs_mcache_cache);\r\nerr_out_exit:\r\nreturn -ENOMEM;\r\n}\r\nvoid pohmelfs_mcache_exit(void)\r\n{\r\nmempool_destroy(pohmelfs_mcache_pool);\r\nkmem_cache_destroy(pohmelfs_mcache_cache);\r\n}
