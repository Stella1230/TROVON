static struct b43_lo_calib *b43_find_lo_calib(struct b43_txpower_lo_control *lo,\r\nconst struct b43_bbatt *bbatt,\r\nconst struct b43_rfatt *rfatt)\r\n{\r\nstruct b43_lo_calib *c;\r\nlist_for_each_entry(c, &lo->calib_list, list) {\r\nif (!b43_compare_bbatt(&c->bbatt, bbatt))\r\ncontinue;\r\nif (!b43_compare_rfatt(&c->rfatt, rfatt))\r\ncontinue;\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void b43_lo_write(struct b43_wldev *dev, struct b43_loctl *control)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nu16 value;\r\nif (B43_DEBUG) {\r\nif (unlikely(abs(control->i) > 16 || abs(control->q) > 16)) {\r\nb43dbg(dev->wl, "Invalid LO control pair "\r\n"(I: %d, Q: %d)\n", control->i, control->q);\r\ndump_stack();\r\nreturn;\r\n}\r\n}\r\nB43_WARN_ON(phy->type != B43_PHYTYPE_G);\r\nvalue = (u8) (control->q);\r\nvalue |= ((u8) (control->i)) << 8;\r\nb43_phy_write(dev, B43_PHY_LO_CTL, value);\r\n}\r\nstatic u16 lo_measure_feedthrough(struct b43_wldev *dev,\r\nu16 lna, u16 pga, u16 trsw_rx)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nu16 rfover;\r\nu16 feedthrough;\r\nif (phy->gmode) {\r\nlna <<= B43_PHY_RFOVERVAL_LNA_SHIFT;\r\npga <<= B43_PHY_RFOVERVAL_PGA_SHIFT;\r\nB43_WARN_ON(lna & ~B43_PHY_RFOVERVAL_LNA);\r\nB43_WARN_ON(pga & ~B43_PHY_RFOVERVAL_PGA);\r\ntrsw_rx &= (B43_PHY_RFOVERVAL_TRSWRX | B43_PHY_RFOVERVAL_BW);\r\nrfover = B43_PHY_RFOVERVAL_UNK;\r\nrfover |= pga;\r\nrfover |= lna;\r\nrfover |= trsw_rx;\r\nif ((dev->dev->bus_sprom->boardflags_lo & B43_BFL_EXTLNA)\r\n&& phy->rev > 6)\r\nrfover |= B43_PHY_RFOVERVAL_EXTLNA;\r\nb43_phy_write(dev, B43_PHY_PGACTL, 0xE300);\r\nb43_phy_write(dev, B43_PHY_RFOVERVAL, rfover);\r\nudelay(10);\r\nrfover |= B43_PHY_RFOVERVAL_BW_LBW;\r\nb43_phy_write(dev, B43_PHY_RFOVERVAL, rfover);\r\nudelay(10);\r\nrfover |= B43_PHY_RFOVERVAL_BW_LPF;\r\nb43_phy_write(dev, B43_PHY_RFOVERVAL, rfover);\r\nudelay(10);\r\nb43_phy_write(dev, B43_PHY_PGACTL, 0xF300);\r\n} else {\r\npga |= B43_PHY_PGACTL_UNKNOWN;\r\nb43_phy_write(dev, B43_PHY_PGACTL, pga);\r\nudelay(10);\r\npga |= B43_PHY_PGACTL_LOWBANDW;\r\nb43_phy_write(dev, B43_PHY_PGACTL, pga);\r\nudelay(10);\r\npga |= B43_PHY_PGACTL_LPF;\r\nb43_phy_write(dev, B43_PHY_PGACTL, pga);\r\n}\r\nudelay(21);\r\nfeedthrough = b43_phy_read(dev, B43_PHY_LO_LEAKAGE);\r\ncond_resched();\r\nreturn feedthrough;\r\n}\r\nstatic u16 lo_txctl_register_table(struct b43_wldev *dev,\r\nu16 *value, u16 *pad_mix_gain)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nu16 reg, v, padmix;\r\nif (phy->type == B43_PHYTYPE_B) {\r\nv = 0x30;\r\nif (phy->radio_rev <= 5) {\r\nreg = 0x43;\r\npadmix = 0;\r\n} else {\r\nreg = 0x52;\r\npadmix = 5;\r\n}\r\n} else {\r\nif (phy->rev >= 2 && phy->radio_rev == 8) {\r\nreg = 0x43;\r\nv = 0x10;\r\npadmix = 2;\r\n} else {\r\nreg = 0x52;\r\nv = 0x30;\r\npadmix = 5;\r\n}\r\n}\r\nif (value)\r\n*value = v;\r\nif (pad_mix_gain)\r\n*pad_mix_gain = padmix;\r\nreturn reg;\r\n}\r\nstatic void lo_measure_txctl_values(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_txpower_lo_control *lo = gphy->lo_control;\r\nu16 reg, mask;\r\nu16 trsw_rx, pga;\r\nu16 radio_pctl_reg;\r\nstatic const u8 tx_bias_values[] = {\r\n0x09, 0x08, 0x0A, 0x01, 0x00,\r\n0x02, 0x05, 0x04, 0x06,\r\n};\r\nstatic const u8 tx_magn_values[] = {\r\n0x70, 0x40,\r\n};\r\nif (!has_loopback_gain(phy)) {\r\nradio_pctl_reg = 6;\r\ntrsw_rx = 2;\r\npga = 0;\r\n} else {\r\nint lb_gain;\r\ntrsw_rx = 0;\r\nlb_gain = gphy->max_lb_gain / 2;\r\nif (lb_gain > 10) {\r\nradio_pctl_reg = 0;\r\npga = abs(10 - lb_gain) / 6;\r\npga = clamp_val(pga, 0, 15);\r\n} else {\r\nint cmp_val;\r\nint tmp;\r\npga = 0;\r\ncmp_val = 0x24;\r\nif ((phy->rev >= 2) &&\r\n(phy->radio_ver == 0x2050) && (phy->radio_rev == 8))\r\ncmp_val = 0x3C;\r\ntmp = lb_gain;\r\nif ((10 - lb_gain) < cmp_val)\r\ntmp = (10 - lb_gain);\r\nif (tmp < 0)\r\ntmp += 6;\r\nelse\r\ntmp += 3;\r\ncmp_val /= 4;\r\ntmp /= 4;\r\nif (tmp >= cmp_val)\r\nradio_pctl_reg = cmp_val;\r\nelse\r\nradio_pctl_reg = tmp;\r\n}\r\n}\r\nb43_radio_maskset(dev, 0x43, 0xFFF0, radio_pctl_reg);\r\nb43_gphy_set_baseband_attenuation(dev, 2);\r\nreg = lo_txctl_register_table(dev, &mask, NULL);\r\nmask = ~mask;\r\nb43_radio_mask(dev, reg, mask);\r\nif (has_tx_magnification(phy)) {\r\nint i, j;\r\nint feedthrough;\r\nint min_feedth = 0xFFFF;\r\nu8 tx_magn, tx_bias;\r\nfor (i = 0; i < ARRAY_SIZE(tx_magn_values); i++) {\r\ntx_magn = tx_magn_values[i];\r\nb43_radio_maskset(dev, 0x52, 0xFF0F, tx_magn);\r\nfor (j = 0; j < ARRAY_SIZE(tx_bias_values); j++) {\r\ntx_bias = tx_bias_values[j];\r\nb43_radio_maskset(dev, 0x52, 0xFFF0, tx_bias);\r\nfeedthrough =\r\nlo_measure_feedthrough(dev, 0, pga,\r\ntrsw_rx);\r\nif (feedthrough < min_feedth) {\r\nlo->tx_bias = tx_bias;\r\nlo->tx_magn = tx_magn;\r\nmin_feedth = feedthrough;\r\n}\r\nif (lo->tx_bias == 0)\r\nbreak;\r\n}\r\nb43_radio_write16(dev, 0x52,\r\n(b43_radio_read16(dev, 0x52)\r\n& 0xFF00) | lo->tx_bias | lo->\r\ntx_magn);\r\n}\r\n} else {\r\nlo->tx_magn = 0;\r\nlo->tx_bias = 0;\r\nb43_radio_mask(dev, 0x52, 0xFFF0);\r\n}\r\nlo->txctl_measured_time = jiffies;\r\n}\r\nstatic void lo_read_power_vector(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_txpower_lo_control *lo = gphy->lo_control;\r\nint i;\r\nu64 tmp;\r\nu64 power_vector = 0;\r\nfor (i = 0; i < 8; i += 2) {\r\ntmp = b43_shm_read16(dev, B43_SHM_SHARED, 0x310 + i);\r\npower_vector |= (tmp << (i * 8));\r\nb43_shm_write16(dev, B43_SHM_SHARED, 0x310 + i, 0);\r\n}\r\nif (power_vector)\r\nlo->power_vector = power_vector;\r\nlo->pwr_vec_read_time = jiffies;\r\n}\r\nstatic void lo_measure_gain_values(struct b43_wldev *dev,\r\ns16 max_rx_gain, int use_trsw_rx)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nu16 tmp;\r\nif (max_rx_gain < 0)\r\nmax_rx_gain = 0;\r\nif (has_loopback_gain(phy)) {\r\nint trsw_rx_gain;\r\nif (use_trsw_rx) {\r\ntrsw_rx_gain = gphy->trsw_rx_gain / 2;\r\nif (max_rx_gain >= trsw_rx_gain) {\r\ntrsw_rx_gain = max_rx_gain - trsw_rx_gain;\r\n}\r\n} else\r\ntrsw_rx_gain = max_rx_gain;\r\nif (trsw_rx_gain < 9) {\r\ngphy->lna_lod_gain = 0;\r\n} else {\r\ngphy->lna_lod_gain = 1;\r\ntrsw_rx_gain -= 8;\r\n}\r\ntrsw_rx_gain = clamp_val(trsw_rx_gain, 0, 0x2D);\r\ngphy->pga_gain = trsw_rx_gain / 3;\r\nif (gphy->pga_gain >= 5) {\r\ngphy->pga_gain -= 5;\r\ngphy->lna_gain = 2;\r\n} else\r\ngphy->lna_gain = 0;\r\n} else {\r\ngphy->lna_gain = 0;\r\ngphy->trsw_rx_gain = 0x20;\r\nif (max_rx_gain >= 0x14) {\r\ngphy->lna_lod_gain = 1;\r\ngphy->pga_gain = 2;\r\n} else if (max_rx_gain >= 0x12) {\r\ngphy->lna_lod_gain = 1;\r\ngphy->pga_gain = 1;\r\n} else if (max_rx_gain >= 0xF) {\r\ngphy->lna_lod_gain = 1;\r\ngphy->pga_gain = 0;\r\n} else {\r\ngphy->lna_lod_gain = 0;\r\ngphy->pga_gain = 0;\r\n}\r\n}\r\ntmp = b43_radio_read16(dev, 0x7A);\r\nif (gphy->lna_lod_gain == 0)\r\ntmp &= ~0x0008;\r\nelse\r\ntmp |= 0x0008;\r\nb43_radio_write16(dev, 0x7A, tmp);\r\n}\r\nstatic void lo_measure_setup(struct b43_wldev *dev,\r\nstruct lo_g_saved_values *sav)\r\n{\r\nstruct ssb_sprom *sprom = dev->dev->bus_sprom;\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_txpower_lo_control *lo = gphy->lo_control;\r\nu16 tmp;\r\nif (b43_has_hardware_pctl(dev)) {\r\nsav->phy_lo_mask = b43_phy_read(dev, B43_PHY_LO_MASK);\r\nsav->phy_extg_01 = b43_phy_read(dev, B43_PHY_EXTG(0x01));\r\nsav->phy_dacctl_hwpctl = b43_phy_read(dev, B43_PHY_DACCTL);\r\nsav->phy_cck_14 = b43_phy_read(dev, B43_PHY_CCK(0x14));\r\nsav->phy_hpwr_tssictl = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);\r\nb43_phy_set(dev, B43_PHY_HPWR_TSSICTL, 0x100);\r\nb43_phy_set(dev, B43_PHY_EXTG(0x01), 0x40);\r\nb43_phy_set(dev, B43_PHY_DACCTL, 0x40);\r\nb43_phy_set(dev, B43_PHY_CCK(0x14), 0x200);\r\n}\r\nif (phy->type == B43_PHYTYPE_B &&\r\nphy->radio_ver == 0x2050 && phy->radio_rev < 6) {\r\nb43_phy_write(dev, B43_PHY_CCK(0x16), 0x410);\r\nb43_phy_write(dev, B43_PHY_CCK(0x17), 0x820);\r\n}\r\nif (phy->rev >= 2) {\r\nsav->phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);\r\nsav->phy_analogoverval =\r\nb43_phy_read(dev, B43_PHY_ANALOGOVERVAL);\r\nsav->phy_rfover = b43_phy_read(dev, B43_PHY_RFOVER);\r\nsav->phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);\r\nsav->phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);\r\nsav->phy_cck_3E = b43_phy_read(dev, B43_PHY_CCK(0x3E));\r\nsav->phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);\r\nb43_phy_mask(dev, B43_PHY_CLASSCTL, 0xFFFC);\r\nb43_phy_mask(dev, B43_PHY_CRS0, 0x7FFF);\r\nb43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0003);\r\nb43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFC);\r\nif (phy->type == B43_PHYTYPE_G) {\r\nif ((phy->rev >= 7) &&\r\n(sprom->boardflags_lo & B43_BFL_EXTLNA)) {\r\nb43_phy_write(dev, B43_PHY_RFOVER, 0x933);\r\n} else {\r\nb43_phy_write(dev, B43_PHY_RFOVER, 0x133);\r\n}\r\n} else {\r\nb43_phy_write(dev, B43_PHY_RFOVER, 0);\r\n}\r\nb43_phy_write(dev, B43_PHY_CCK(0x3E), 0);\r\n}\r\nsav->reg_3F4 = b43_read16(dev, 0x3F4);\r\nsav->reg_3E2 = b43_read16(dev, 0x3E2);\r\nsav->radio_43 = b43_radio_read16(dev, 0x43);\r\nsav->radio_7A = b43_radio_read16(dev, 0x7A);\r\nsav->phy_pgactl = b43_phy_read(dev, B43_PHY_PGACTL);\r\nsav->phy_cck_2A = b43_phy_read(dev, B43_PHY_CCK(0x2A));\r\nsav->phy_syncctl = b43_phy_read(dev, B43_PHY_SYNCCTL);\r\nsav->phy_dacctl = b43_phy_read(dev, B43_PHY_DACCTL);\r\nif (!has_tx_magnification(phy)) {\r\nsav->radio_52 = b43_radio_read16(dev, 0x52);\r\nsav->radio_52 &= 0x00F0;\r\n}\r\nif (phy->type == B43_PHYTYPE_B) {\r\nsav->phy_cck_30 = b43_phy_read(dev, B43_PHY_CCK(0x30));\r\nsav->phy_cck_06 = b43_phy_read(dev, B43_PHY_CCK(0x06));\r\nb43_phy_write(dev, B43_PHY_CCK(0x30), 0x00FF);\r\nb43_phy_write(dev, B43_PHY_CCK(0x06), 0x3F3F);\r\n} else {\r\nb43_write16(dev, 0x3E2, b43_read16(dev, 0x3E2)\r\n| 0x8000);\r\n}\r\nb43_write16(dev, 0x3F4, b43_read16(dev, 0x3F4)\r\n& 0xF000);\r\ntmp =\r\n(phy->type == B43_PHYTYPE_G) ? B43_PHY_LO_MASK : B43_PHY_CCK(0x2E);\r\nb43_phy_write(dev, tmp, 0x007F);\r\ntmp = sav->phy_syncctl;\r\nb43_phy_write(dev, B43_PHY_SYNCCTL, tmp & 0xFF7F);\r\ntmp = sav->radio_7A;\r\nb43_radio_write16(dev, 0x007A, tmp & 0xFFF0);\r\nb43_phy_write(dev, B43_PHY_CCK(0x2A), 0x8A3);\r\nif (phy->type == B43_PHYTYPE_G ||\r\n(phy->type == B43_PHYTYPE_B &&\r\nphy->radio_ver == 0x2050 && phy->radio_rev >= 6)) {\r\nb43_phy_write(dev, B43_PHY_CCK(0x2B), 0x1003);\r\n} else\r\nb43_phy_write(dev, B43_PHY_CCK(0x2B), 0x0802);\r\nif (phy->rev >= 2)\r\nb43_dummy_transmission(dev, false, true);\r\nb43_gphy_channel_switch(dev, 6, 0);\r\nb43_radio_read16(dev, 0x51);\r\nif (phy->type == B43_PHYTYPE_G)\r\nb43_phy_write(dev, B43_PHY_CCK(0x2F), 0);\r\nif (time_before(lo->txctl_measured_time,\r\njiffies - B43_LO_TXCTL_EXPIRE))\r\nlo_measure_txctl_values(dev);\r\nif (phy->type == B43_PHYTYPE_G && phy->rev >= 3) {\r\nb43_phy_write(dev, B43_PHY_LO_MASK, 0xC078);\r\n} else {\r\nif (phy->type == B43_PHYTYPE_B)\r\nb43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8078);\r\nelse\r\nb43_phy_write(dev, B43_PHY_LO_MASK, 0x8078);\r\n}\r\n}\r\nstatic void lo_measure_restore(struct b43_wldev *dev,\r\nstruct lo_g_saved_values *sav)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nu16 tmp;\r\nif (phy->rev >= 2) {\r\nb43_phy_write(dev, B43_PHY_PGACTL, 0xE300);\r\ntmp = (gphy->pga_gain << 8);\r\nb43_phy_write(dev, B43_PHY_RFOVERVAL, tmp | 0xA0);\r\nudelay(5);\r\nb43_phy_write(dev, B43_PHY_RFOVERVAL, tmp | 0xA2);\r\nudelay(2);\r\nb43_phy_write(dev, B43_PHY_RFOVERVAL, tmp | 0xA3);\r\n} else {\r\ntmp = (gphy->pga_gain | 0xEFA0);\r\nb43_phy_write(dev, B43_PHY_PGACTL, tmp);\r\n}\r\nif (phy->type == B43_PHYTYPE_G) {\r\nif (phy->rev >= 3)\r\nb43_phy_write(dev, B43_PHY_CCK(0x2E), 0xC078);\r\nelse\r\nb43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8078);\r\nif (phy->rev >= 2)\r\nb43_phy_write(dev, B43_PHY_CCK(0x2F), 0x0202);\r\nelse\r\nb43_phy_write(dev, B43_PHY_CCK(0x2F), 0x0101);\r\n}\r\nb43_write16(dev, 0x3F4, sav->reg_3F4);\r\nb43_phy_write(dev, B43_PHY_PGACTL, sav->phy_pgactl);\r\nb43_phy_write(dev, B43_PHY_CCK(0x2A), sav->phy_cck_2A);\r\nb43_phy_write(dev, B43_PHY_SYNCCTL, sav->phy_syncctl);\r\nb43_phy_write(dev, B43_PHY_DACCTL, sav->phy_dacctl);\r\nb43_radio_write16(dev, 0x43, sav->radio_43);\r\nb43_radio_write16(dev, 0x7A, sav->radio_7A);\r\nif (!has_tx_magnification(phy)) {\r\ntmp = sav->radio_52;\r\nb43_radio_maskset(dev, 0x52, 0xFF0F, tmp);\r\n}\r\nb43_write16(dev, 0x3E2, sav->reg_3E2);\r\nif (phy->type == B43_PHYTYPE_B &&\r\nphy->radio_ver == 0x2050 && phy->radio_rev <= 5) {\r\nb43_phy_write(dev, B43_PHY_CCK(0x30), sav->phy_cck_30);\r\nb43_phy_write(dev, B43_PHY_CCK(0x06), sav->phy_cck_06);\r\n}\r\nif (phy->rev >= 2) {\r\nb43_phy_write(dev, B43_PHY_ANALOGOVER, sav->phy_analogover);\r\nb43_phy_write(dev, B43_PHY_ANALOGOVERVAL,\r\nsav->phy_analogoverval);\r\nb43_phy_write(dev, B43_PHY_CLASSCTL, sav->phy_classctl);\r\nb43_phy_write(dev, B43_PHY_RFOVER, sav->phy_rfover);\r\nb43_phy_write(dev, B43_PHY_RFOVERVAL, sav->phy_rfoverval);\r\nb43_phy_write(dev, B43_PHY_CCK(0x3E), sav->phy_cck_3E);\r\nb43_phy_write(dev, B43_PHY_CRS0, sav->phy_crs0);\r\n}\r\nif (b43_has_hardware_pctl(dev)) {\r\ntmp = (sav->phy_lo_mask & 0xBFFF);\r\nb43_phy_write(dev, B43_PHY_LO_MASK, tmp);\r\nb43_phy_write(dev, B43_PHY_EXTG(0x01), sav->phy_extg_01);\r\nb43_phy_write(dev, B43_PHY_DACCTL, sav->phy_dacctl_hwpctl);\r\nb43_phy_write(dev, B43_PHY_CCK(0x14), sav->phy_cck_14);\r\nb43_phy_write(dev, B43_PHY_HPWR_TSSICTL, sav->phy_hpwr_tssictl);\r\n}\r\nb43_gphy_channel_switch(dev, sav->old_channel, 1);\r\n}\r\nstatic int lo_probe_possible_loctls(struct b43_wldev *dev,\r\nstruct b43_loctl *probe_loctl,\r\nstruct b43_lo_g_statemachine *d)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_loctl test_loctl;\r\nstruct b43_loctl orig_loctl;\r\nstruct b43_loctl prev_loctl = {\r\n.i = -100,\r\n.q = -100,\r\n};\r\nint i;\r\nint begin, end;\r\nint found_lower = 0;\r\nu16 feedth;\r\nstatic const struct b43_loctl modifiers[] = {\r\n{.i = 1,.q = 1,},\r\n{.i = 1,.q = 0,},\r\n{.i = 1,.q = -1,},\r\n{.i = 0,.q = -1,},\r\n{.i = -1,.q = -1,},\r\n{.i = -1,.q = 0,},\r\n{.i = -1,.q = 1,},\r\n{.i = 0,.q = 1,},\r\n};\r\nif (d->current_state == 0) {\r\nbegin = 1;\r\nend = 8;\r\n} else if (d->current_state % 2 == 0) {\r\nbegin = d->current_state - 1;\r\nend = d->current_state + 1;\r\n} else {\r\nbegin = d->current_state - 2;\r\nend = d->current_state + 2;\r\n}\r\nif (begin < 1)\r\nbegin += 8;\r\nif (end > 8)\r\nend -= 8;\r\nmemcpy(&orig_loctl, probe_loctl, sizeof(struct b43_loctl));\r\ni = begin;\r\nd->current_state = i;\r\nwhile (1) {\r\nB43_WARN_ON(!(i >= 1 && i <= 8));\r\nmemcpy(&test_loctl, &orig_loctl, sizeof(struct b43_loctl));\r\ntest_loctl.i += modifiers[i - 1].i * d->state_val_multiplier;\r\ntest_loctl.q += modifiers[i - 1].q * d->state_val_multiplier;\r\nif ((test_loctl.i != prev_loctl.i ||\r\ntest_loctl.q != prev_loctl.q) &&\r\n(abs(test_loctl.i) <= 16 && abs(test_loctl.q) <= 16)) {\r\nb43_lo_write(dev, &test_loctl);\r\nfeedth = lo_measure_feedthrough(dev, gphy->lna_gain,\r\ngphy->pga_gain,\r\ngphy->trsw_rx_gain);\r\nif (feedth < d->lowest_feedth) {\r\nmemcpy(probe_loctl, &test_loctl,\r\nsizeof(struct b43_loctl));\r\nfound_lower = 1;\r\nd->lowest_feedth = feedth;\r\nif ((d->nr_measured < 2) &&\r\n!has_loopback_gain(phy))\r\nbreak;\r\n}\r\n}\r\nmemcpy(&prev_loctl, &test_loctl, sizeof(prev_loctl));\r\nif (i == end)\r\nbreak;\r\nif (i == 8)\r\ni = 1;\r\nelse\r\ni++;\r\nd->current_state = i;\r\n}\r\nreturn found_lower;\r\n}\r\nstatic void lo_probe_loctls_statemachine(struct b43_wldev *dev,\r\nstruct b43_loctl *loctl,\r\nint *max_rx_gain)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_lo_g_statemachine d;\r\nu16 feedth;\r\nint found_lower;\r\nstruct b43_loctl probe_loctl;\r\nint max_repeat = 1, repeat_cnt = 0;\r\nd.nr_measured = 0;\r\nd.state_val_multiplier = 1;\r\nif (has_loopback_gain(phy))\r\nd.state_val_multiplier = 3;\r\nmemcpy(&d.min_loctl, loctl, sizeof(struct b43_loctl));\r\nif (has_loopback_gain(phy))\r\nmax_repeat = 4;\r\ndo {\r\nb43_lo_write(dev, &d.min_loctl);\r\nfeedth = lo_measure_feedthrough(dev, gphy->lna_gain,\r\ngphy->pga_gain,\r\ngphy->trsw_rx_gain);\r\nif (feedth < 0x258) {\r\nif (feedth >= 0x12C)\r\n*max_rx_gain += 6;\r\nelse\r\n*max_rx_gain += 3;\r\nfeedth = lo_measure_feedthrough(dev, gphy->lna_gain,\r\ngphy->pga_gain,\r\ngphy->trsw_rx_gain);\r\n}\r\nd.lowest_feedth = feedth;\r\nd.current_state = 0;\r\ndo {\r\nB43_WARN_ON(!\r\n(d.current_state >= 0\r\n&& d.current_state <= 8));\r\nmemcpy(&probe_loctl, &d.min_loctl,\r\nsizeof(struct b43_loctl));\r\nfound_lower =\r\nlo_probe_possible_loctls(dev, &probe_loctl, &d);\r\nif (!found_lower)\r\nbreak;\r\nif ((probe_loctl.i == d.min_loctl.i) &&\r\n(probe_loctl.q == d.min_loctl.q))\r\nbreak;\r\nmemcpy(&d.min_loctl, &probe_loctl,\r\nsizeof(struct b43_loctl));\r\nd.nr_measured++;\r\n} while (d.nr_measured < 24);\r\nmemcpy(loctl, &d.min_loctl, sizeof(struct b43_loctl));\r\nif (has_loopback_gain(phy)) {\r\nif (d.lowest_feedth > 0x1194)\r\n*max_rx_gain -= 6;\r\nelse if (d.lowest_feedth < 0x5DC)\r\n*max_rx_gain += 3;\r\nif (repeat_cnt == 0) {\r\nif (d.lowest_feedth <= 0x5DC) {\r\nd.state_val_multiplier = 1;\r\nrepeat_cnt++;\r\n} else\r\nd.state_val_multiplier = 2;\r\n} else if (repeat_cnt == 2)\r\nd.state_val_multiplier = 1;\r\n}\r\nlo_measure_gain_values(dev, *max_rx_gain,\r\nhas_loopback_gain(phy));\r\n} while (++repeat_cnt < max_repeat);\r\n}\r\nstatic\r\nstruct b43_lo_calib *b43_calibrate_lo_setting(struct b43_wldev *dev,\r\nconst struct b43_bbatt *bbatt,\r\nconst struct b43_rfatt *rfatt)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_loctl loctl = {\r\n.i = 0,\r\n.q = 0,\r\n};\r\nint max_rx_gain;\r\nstruct b43_lo_calib *cal;\r\nstruct lo_g_saved_values uninitialized_var(saved_regs);\r\nu16 txctl_reg;\r\nu16 txctl_value;\r\nu16 pad_mix_gain;\r\nsaved_regs.old_channel = phy->channel;\r\nb43_mac_suspend(dev);\r\nlo_measure_setup(dev, &saved_regs);\r\ntxctl_reg = lo_txctl_register_table(dev, &txctl_value, &pad_mix_gain);\r\nb43_radio_maskset(dev, 0x43, 0xFFF0, rfatt->att);\r\nb43_radio_maskset(dev, txctl_reg, ~txctl_value, (rfatt->with_padmix ? txctl_value :0));\r\nmax_rx_gain = rfatt->att * 2;\r\nmax_rx_gain += bbatt->att / 2;\r\nif (rfatt->with_padmix)\r\nmax_rx_gain -= pad_mix_gain;\r\nif (has_loopback_gain(phy))\r\nmax_rx_gain += gphy->max_lb_gain;\r\nlo_measure_gain_values(dev, max_rx_gain,\r\nhas_loopback_gain(phy));\r\nb43_gphy_set_baseband_attenuation(dev, bbatt->att);\r\nlo_probe_loctls_statemachine(dev, &loctl, &max_rx_gain);\r\nlo_measure_restore(dev, &saved_regs);\r\nb43_mac_enable(dev);\r\nif (b43_debug(dev, B43_DBG_LO)) {\r\nb43dbg(dev->wl, "LO: Calibrated for BB(%u), RF(%u,%u) "\r\n"=> I=%d Q=%d\n",\r\nbbatt->att, rfatt->att, rfatt->with_padmix,\r\nloctl.i, loctl.q);\r\n}\r\ncal = kmalloc(sizeof(*cal), GFP_KERNEL);\r\nif (!cal) {\r\nb43warn(dev->wl, "LO calib: out of memory\n");\r\nreturn NULL;\r\n}\r\nmemcpy(&cal->bbatt, bbatt, sizeof(*bbatt));\r\nmemcpy(&cal->rfatt, rfatt, sizeof(*rfatt));\r\nmemcpy(&cal->ctl, &loctl, sizeof(loctl));\r\ncal->calib_time = jiffies;\r\nINIT_LIST_HEAD(&cal->list);\r\nreturn cal;\r\n}\r\nstatic\r\nstruct b43_lo_calib *b43_get_calib_lo_settings(struct b43_wldev *dev,\r\nconst struct b43_bbatt *bbatt,\r\nconst struct b43_rfatt *rfatt)\r\n{\r\nstruct b43_txpower_lo_control *lo = dev->phy.g->lo_control;\r\nstruct b43_lo_calib *c;\r\nc = b43_find_lo_calib(lo, bbatt, rfatt);\r\nif (c)\r\nreturn c;\r\nc = b43_calibrate_lo_setting(dev, bbatt, rfatt);\r\nif (!c)\r\nreturn NULL;\r\nlist_add(&c->list, &lo->calib_list);\r\nreturn c;\r\n}\r\nvoid b43_gphy_dc_lt_init(struct b43_wldev *dev, bool update_all)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_txpower_lo_control *lo = gphy->lo_control;\r\nint i;\r\nint rf_offset, bb_offset;\r\nconst struct b43_rfatt *rfatt;\r\nconst struct b43_bbatt *bbatt;\r\nu64 power_vector;\r\nbool table_changed = 0;\r\nBUILD_BUG_ON(B43_DC_LT_SIZE != 32);\r\nB43_WARN_ON(lo->rfatt_list.len * lo->bbatt_list.len > 64);\r\npower_vector = lo->power_vector;\r\nif (!update_all && !power_vector)\r\nreturn;\r\nb43_mac_suspend(dev);\r\nfor (i = 0; i < B43_DC_LT_SIZE * 2; i++) {\r\nstruct b43_lo_calib *cal;\r\nint idx;\r\nu16 val;\r\nif (!update_all && !(power_vector & (((u64)1ULL) << i)))\r\ncontinue;\r\nbb_offset = i / lo->rfatt_list.len;\r\nrf_offset = i % lo->rfatt_list.len;\r\nbbatt = &(lo->bbatt_list.list[bb_offset]);\r\nrfatt = &(lo->rfatt_list.list[rf_offset]);\r\ncal = b43_calibrate_lo_setting(dev, bbatt, rfatt);\r\nif (!cal) {\r\nb43warn(dev->wl, "LO: Could not "\r\n"calibrate DC table entry\n");\r\ncontinue;\r\n}\r\nval = (u8)(cal->ctl.q);\r\nval |= ((u8)(cal->ctl.i)) << 4;\r\nkfree(cal);\r\nidx = i / 2;\r\nif (i % 2) {\r\nlo->dc_lt[idx] = (lo->dc_lt[idx] & 0x00FF)\r\n| ((val & 0x00FF) << 8);\r\n} else {\r\nlo->dc_lt[idx] = (lo->dc_lt[idx] & 0xFF00)\r\n| (val & 0x00FF);\r\n}\r\ntable_changed = 1;\r\n}\r\nif (table_changed) {\r\nfor (i = 0; i < B43_DC_LT_SIZE; i++)\r\nb43_phy_write(dev, 0x3A0 + i, lo->dc_lt[i]);\r\n}\r\nb43_mac_enable(dev);\r\n}\r\nstatic inline void b43_lo_fixup_rfatt(struct b43_rfatt *rf)\r\n{\r\nif (!rf->with_padmix)\r\nreturn;\r\nif ((rf->att != 1) && (rf->att != 2) && (rf->att != 3))\r\nrf->att = 4;\r\n}\r\nvoid b43_lo_g_adjust(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy_g *gphy = dev->phy.g;\r\nstruct b43_lo_calib *cal;\r\nstruct b43_rfatt rf;\r\nmemcpy(&rf, &gphy->rfatt, sizeof(rf));\r\nb43_lo_fixup_rfatt(&rf);\r\ncal = b43_get_calib_lo_settings(dev, &gphy->bbatt, &rf);\r\nif (!cal)\r\nreturn;\r\nb43_lo_write(dev, &cal->ctl);\r\n}\r\nvoid b43_lo_g_adjust_to(struct b43_wldev *dev,\r\nu16 rfatt, u16 bbatt, u16 tx_control)\r\n{\r\nstruct b43_rfatt rf;\r\nstruct b43_bbatt bb;\r\nstruct b43_lo_calib *cal;\r\nmemset(&rf, 0, sizeof(rf));\r\nmemset(&bb, 0, sizeof(bb));\r\nrf.att = rfatt;\r\nbb.att = bbatt;\r\nb43_lo_fixup_rfatt(&rf);\r\ncal = b43_get_calib_lo_settings(dev, &bb, &rf);\r\nif (!cal)\r\nreturn;\r\nb43_lo_write(dev, &cal->ctl);\r\n}\r\nvoid b43_lo_g_maintanance_work(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nstruct b43_phy_g *gphy = phy->g;\r\nstruct b43_txpower_lo_control *lo = gphy->lo_control;\r\nunsigned long now;\r\nunsigned long expire;\r\nstruct b43_lo_calib *cal, *tmp;\r\nbool current_item_expired = 0;\r\nbool hwpctl;\r\nif (!lo)\r\nreturn;\r\nnow = jiffies;\r\nhwpctl = b43_has_hardware_pctl(dev);\r\nif (hwpctl) {\r\nexpire = now - B43_LO_PWRVEC_EXPIRE;\r\nif (time_before(lo->pwr_vec_read_time, expire)) {\r\nlo_read_power_vector(dev);\r\nb43_gphy_dc_lt_init(dev, 0);\r\n}\r\n}\r\nif (hwpctl)\r\nreturn;\r\nexpire = now - B43_LO_CALIB_EXPIRE;\r\nlist_for_each_entry_safe(cal, tmp, &lo->calib_list, list) {\r\nif (!time_before(cal->calib_time, expire))\r\ncontinue;\r\nif (b43_compare_bbatt(&cal->bbatt, &gphy->bbatt) &&\r\nb43_compare_rfatt(&cal->rfatt, &gphy->rfatt)) {\r\nB43_WARN_ON(current_item_expired);\r\ncurrent_item_expired = 1;\r\n}\r\nif (b43_debug(dev, B43_DBG_LO)) {\r\nb43dbg(dev->wl, "LO: Item BB(%u), RF(%u,%u), "\r\n"I=%d, Q=%d expired\n",\r\ncal->bbatt.att, cal->rfatt.att,\r\ncal->rfatt.with_padmix,\r\ncal->ctl.i, cal->ctl.q);\r\n}\r\nlist_del(&cal->list);\r\nkfree(cal);\r\n}\r\nif (current_item_expired || unlikely(list_empty(&lo->calib_list))) {\r\nif (b43_debug(dev, B43_DBG_LO))\r\nb43dbg(dev->wl, "LO: Recalibrating current LO setting\n");\r\ncal = b43_calibrate_lo_setting(dev, &gphy->bbatt, &gphy->rfatt);\r\nif (cal) {\r\nlist_add(&cal->list, &lo->calib_list);\r\nb43_lo_write(dev, &cal->ctl);\r\n} else\r\nb43warn(dev->wl, "Failed to recalibrate current LO setting\n");\r\n}\r\n}\r\nvoid b43_lo_g_cleanup(struct b43_wldev *dev)\r\n{\r\nstruct b43_txpower_lo_control *lo = dev->phy.g->lo_control;\r\nstruct b43_lo_calib *cal, *tmp;\r\nif (!lo)\r\nreturn;\r\nlist_for_each_entry_safe(cal, tmp, &lo->calib_list, list) {\r\nlist_del(&cal->list);\r\nkfree(cal);\r\n}\r\n}\r\nvoid b43_lo_g_init(struct b43_wldev *dev)\r\n{\r\nif (b43_has_hardware_pctl(dev)) {\r\nlo_read_power_vector(dev);\r\nb43_gphy_dc_lt_init(dev, 1);\r\n}\r\n}
