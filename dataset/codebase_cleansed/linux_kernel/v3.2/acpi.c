static int __init set_use_crs(const struct dmi_system_id *id)\r\n{\r\npci_use_crs = true;\r\nreturn 0;\r\n}\r\nvoid __init pci_acpi_crs_quirks(void)\r\n{\r\nint year;\r\nif (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year < 2008)\r\npci_use_crs = false;\r\ndmi_check_system(pci_use_crs_table);\r\nif (pci_probe & PCI_ROOT_NO_CRS)\r\npci_use_crs = false;\r\nelse if (pci_probe & PCI_USE__CRS)\r\npci_use_crs = true;\r\nprintk(KERN_INFO "PCI: %s host bridge windows from ACPI; "\r\n"if necessary, use \"pci=%s\" and report a bug\n",\r\npci_use_crs ? "Using" : "Ignoring",\r\npci_use_crs ? "nocrs" : "use_crs");\r\n}\r\nstatic acpi_status\r\nresource_to_addr(struct acpi_resource *resource,\r\nstruct acpi_resource_address64 *addr)\r\n{\r\nacpi_status status;\r\nstruct acpi_resource_memory24 *memory24;\r\nstruct acpi_resource_memory32 *memory32;\r\nstruct acpi_resource_fixed_memory32 *fixed_memory32;\r\nmemset(addr, 0, sizeof(*addr));\r\nswitch (resource->type) {\r\ncase ACPI_RESOURCE_TYPE_MEMORY24:\r\nmemory24 = &resource->data.memory24;\r\naddr->resource_type = ACPI_MEMORY_RANGE;\r\naddr->minimum = memory24->minimum;\r\naddr->address_length = memory24->address_length;\r\naddr->maximum = addr->minimum + addr->address_length - 1;\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_MEMORY32:\r\nmemory32 = &resource->data.memory32;\r\naddr->resource_type = ACPI_MEMORY_RANGE;\r\naddr->minimum = memory32->minimum;\r\naddr->address_length = memory32->address_length;\r\naddr->maximum = addr->minimum + addr->address_length - 1;\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_FIXED_MEMORY32:\r\nfixed_memory32 = &resource->data.fixed_memory32;\r\naddr->resource_type = ACPI_MEMORY_RANGE;\r\naddr->minimum = fixed_memory32->address;\r\naddr->address_length = fixed_memory32->address_length;\r\naddr->maximum = addr->minimum + addr->address_length - 1;\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_ADDRESS16:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS32:\r\ncase ACPI_RESOURCE_TYPE_ADDRESS64:\r\nstatus = acpi_resource_to_address64(resource, addr);\r\nif (ACPI_SUCCESS(status) &&\r\n(addr->resource_type == ACPI_MEMORY_RANGE ||\r\naddr->resource_type == ACPI_IO_RANGE) &&\r\naddr->address_length > 0) {\r\nreturn AE_OK;\r\n}\r\nbreak;\r\n}\r\nreturn AE_ERROR;\r\n}\r\nstatic acpi_status\r\ncount_resource(struct acpi_resource *acpi_res, void *data)\r\n{\r\nstruct pci_root_info *info = data;\r\nstruct acpi_resource_address64 addr;\r\nacpi_status status;\r\nstatus = resource_to_addr(acpi_res, &addr);\r\nif (ACPI_SUCCESS(status))\r\ninfo->res_num++;\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nsetup_resource(struct acpi_resource *acpi_res, void *data)\r\n{\r\nstruct pci_root_info *info = data;\r\nstruct resource *res;\r\nstruct acpi_resource_address64 addr;\r\nacpi_status status;\r\nunsigned long flags;\r\nu64 start, end;\r\nstatus = resource_to_addr(acpi_res, &addr);\r\nif (!ACPI_SUCCESS(status))\r\nreturn AE_OK;\r\nif (addr.resource_type == ACPI_MEMORY_RANGE) {\r\nflags = IORESOURCE_MEM;\r\nif (addr.info.mem.caching == ACPI_PREFETCHABLE_MEMORY)\r\nflags |= IORESOURCE_PREFETCH;\r\n} else if (addr.resource_type == ACPI_IO_RANGE) {\r\nflags = IORESOURCE_IO;\r\n} else\r\nreturn AE_OK;\r\nstart = addr.minimum + addr.translation_offset;\r\nend = addr.maximum + addr.translation_offset;\r\nres = &info->res[info->res_num];\r\nres->name = info->name;\r\nres->flags = flags;\r\nres->start = start;\r\nres->end = end;\r\nres->child = NULL;\r\nif (!pci_use_crs) {\r\ndev_printk(KERN_DEBUG, &info->bridge->dev,\r\n"host bridge window %pR (ignored)\n", res);\r\nreturn AE_OK;\r\n}\r\ninfo->res_num++;\r\nif (addr.translation_offset)\r\ndev_info(&info->bridge->dev, "host bridge window %pR "\r\n"(PCI address [%#llx-%#llx])\n",\r\nres, res->start - addr.translation_offset,\r\nres->end - addr.translation_offset);\r\nelse\r\ndev_info(&info->bridge->dev, "host bridge window %pR\n", res);\r\nreturn AE_OK;\r\n}\r\nstatic bool resource_contains(struct resource *res, resource_size_t point)\r\n{\r\nif (res->start <= point && point <= res->end)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void coalesce_windows(struct pci_root_info *info, unsigned long type)\r\n{\r\nint i, j;\r\nstruct resource *res1, *res2;\r\nfor (i = 0; i < info->res_num; i++) {\r\nres1 = &info->res[i];\r\nif (!(res1->flags & type))\r\ncontinue;\r\nfor (j = i + 1; j < info->res_num; j++) {\r\nres2 = &info->res[j];\r\nif (!(res2->flags & type))\r\ncontinue;\r\nif (resource_contains(res1, res2->start) ||\r\nresource_contains(res1, res2->end) ||\r\nresource_contains(res2, res1->start) ||\r\nresource_contains(res2, res1->end)) {\r\nres1->start = min(res1->start, res2->start);\r\nres1->end = max(res1->end, res2->end);\r\ndev_info(&info->bridge->dev,\r\n"host bridge window expanded to %pR; %pR ignored\n",\r\nres1, res2);\r\nres2->flags = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic void add_resources(struct pci_root_info *info)\r\n{\r\nint i;\r\nstruct resource *res, *root, *conflict;\r\nif (!pci_use_crs)\r\nreturn;\r\ncoalesce_windows(info, IORESOURCE_MEM);\r\ncoalesce_windows(info, IORESOURCE_IO);\r\nfor (i = 0; i < info->res_num; i++) {\r\nres = &info->res[i];\r\nif (res->flags & IORESOURCE_MEM)\r\nroot = &iomem_resource;\r\nelse if (res->flags & IORESOURCE_IO)\r\nroot = &ioport_resource;\r\nelse\r\ncontinue;\r\nconflict = insert_resource_conflict(root, res);\r\nif (conflict)\r\ndev_info(&info->bridge->dev,\r\n"ignoring host bridge window %pR (conflicts with %s %pR)\n",\r\nres, conflict->name, conflict);\r\nelse\r\npci_bus_add_resource(info->bus, res, 0);\r\n}\r\n}\r\nstatic void\r\nget_current_resources(struct acpi_device *device, int busnum,\r\nint domain, struct pci_bus *bus)\r\n{\r\nstruct pci_root_info info;\r\nsize_t size;\r\nif (pci_use_crs)\r\npci_bus_remove_resources(bus);\r\ninfo.bridge = device;\r\ninfo.bus = bus;\r\ninfo.res_num = 0;\r\nacpi_walk_resources(device->handle, METHOD_NAME__CRS, count_resource,\r\n&info);\r\nif (!info.res_num)\r\nreturn;\r\nsize = sizeof(*info.res) * info.res_num;\r\ninfo.res = kmalloc(size, GFP_KERNEL);\r\nif (!info.res)\r\ngoto res_alloc_fail;\r\ninfo.name = kasprintf(GFP_KERNEL, "PCI Bus %04x:%02x", domain, busnum);\r\nif (!info.name)\r\ngoto name_alloc_fail;\r\ninfo.res_num = 0;\r\nacpi_walk_resources(device->handle, METHOD_NAME__CRS, setup_resource,\r\n&info);\r\nadd_resources(&info);\r\nreturn;\r\nname_alloc_fail:\r\nkfree(info.res);\r\nres_alloc_fail:\r\nreturn;\r\n}\r\nstruct pci_bus * __devinit pci_acpi_scan_root(struct acpi_pci_root *root)\r\n{\r\nstruct acpi_device *device = root->device;\r\nint domain = root->segment;\r\nint busnum = root->secondary.start;\r\nstruct pci_bus *bus;\r\nstruct pci_sysdata *sd;\r\nint node;\r\n#ifdef CONFIG_ACPI_NUMA\r\nint pxm;\r\n#endif\r\nif (domain && !pci_domains_supported) {\r\nprintk(KERN_WARNING "pci_bus %04x:%02x: "\r\n"ignored (multiple domains not supported)\n",\r\ndomain, busnum);\r\nreturn NULL;\r\n}\r\nnode = -1;\r\n#ifdef CONFIG_ACPI_NUMA\r\npxm = acpi_get_pxm(device->handle);\r\nif (pxm >= 0)\r\nnode = pxm_to_node(pxm);\r\nif (node != -1)\r\nset_mp_bus_to_node(busnum, node);\r\nelse\r\n#endif\r\nnode = get_mp_bus_to_node(busnum);\r\nif (node != -1 && !node_online(node))\r\nnode = -1;\r\nsd = kzalloc(sizeof(*sd), GFP_KERNEL);\r\nif (!sd) {\r\nprintk(KERN_WARNING "pci_bus %04x:%02x: "\r\n"ignored (out of memory)\n", domain, busnum);\r\nreturn NULL;\r\n}\r\nsd->domain = domain;\r\nsd->node = node;\r\nbus = pci_find_bus(domain, busnum);\r\nif (bus) {\r\nmemcpy(bus->sysdata, sd, sizeof(*sd));\r\nkfree(sd);\r\n} else {\r\nbus = pci_create_bus(NULL, busnum, &pci_root_ops, sd);\r\nif (bus) {\r\nget_current_resources(device, busnum, domain, bus);\r\nbus->subordinate = pci_scan_child_bus(bus);\r\n}\r\n}\r\nif (bus) {\r\nstruct pci_bus *child;\r\nlist_for_each_entry(child, &bus->children, node) {\r\nstruct pci_dev *self = child->self;\r\nif (!self)\r\ncontinue;\r\npcie_bus_configure_settings(child, self->pcie_mpss);\r\n}\r\n}\r\nif (!bus)\r\nkfree(sd);\r\nif (bus && node != -1) {\r\n#ifdef CONFIG_ACPI_NUMA\r\nif (pxm >= 0)\r\ndev_printk(KERN_DEBUG, &bus->dev,\r\n"on NUMA node %d (pxm %d)\n", node, pxm);\r\n#else\r\ndev_printk(KERN_DEBUG, &bus->dev, "on NUMA node %d\n", node);\r\n#endif\r\n}\r\nreturn bus;\r\n}\r\nint __init pci_acpi_init(void)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nif (acpi_noirq)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "PCI: Using ACPI for IRQ routing\n");\r\nacpi_irq_penalty_init();\r\npcibios_enable_irq = acpi_pci_irq_enable;\r\npcibios_disable_irq = acpi_pci_irq_disable;\r\nx86_init.pci.init_irq = x86_init_noop;\r\nif (pci_routeirq) {\r\nprintk(KERN_INFO "PCI: Routing PCI interrupts for all devices because \"pci=routeirq\" specified\n");\r\nfor_each_pci_dev(dev)\r\nacpi_pci_irq_enable(dev);\r\n}\r\nreturn 0;\r\n}
