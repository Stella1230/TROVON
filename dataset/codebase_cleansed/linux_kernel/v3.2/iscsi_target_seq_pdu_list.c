void iscsit_dump_seq_list(struct iscsi_cmd *cmd)\r\n{\r\nint i;\r\nstruct iscsi_seq *seq;\r\npr_debug("Dumping Sequence List for ITT: 0x%08x:\n",\r\ncmd->init_task_tag);\r\nfor (i = 0; i < cmd->seq_count; i++) {\r\nseq = &cmd->seq_list[i];\r\npr_debug("i: %d, pdu_start: %d, pdu_count: %d,"\r\n" offset: %d, xfer_len: %d, seq_send_order: %d,"\r\n" seq_no: %d\n", i, seq->pdu_start, seq->pdu_count,\r\nseq->offset, seq->xfer_len, seq->seq_send_order,\r\nseq->seq_no);\r\n}\r\n}\r\nvoid iscsit_dump_pdu_list(struct iscsi_cmd *cmd)\r\n{\r\nint i;\r\nstruct iscsi_pdu *pdu;\r\npr_debug("Dumping PDU List for ITT: 0x%08x:\n",\r\ncmd->init_task_tag);\r\nfor (i = 0; i < cmd->pdu_count; i++) {\r\npdu = &cmd->pdu_list[i];\r\npr_debug("i: %d, offset: %d, length: %d,"\r\n" pdu_send_order: %d, seq_no: %d\n", i, pdu->offset,\r\npdu->length, pdu->pdu_send_order, pdu->seq_no);\r\n}\r\n}\r\nstatic void iscsit_ordered_seq_lists(\r\nstruct iscsi_cmd *cmd,\r\nu8 type)\r\n{\r\nu32 i, seq_count = 0;\r\nfor (i = 0; i < cmd->seq_count; i++) {\r\nif (cmd->seq_list[i].type != SEQTYPE_NORMAL)\r\ncontinue;\r\ncmd->seq_list[i].seq_send_order = seq_count++;\r\n}\r\n}\r\nstatic void iscsit_ordered_pdu_lists(\r\nstruct iscsi_cmd *cmd,\r\nu8 type)\r\n{\r\nu32 i, pdu_send_order = 0, seq_no = 0;\r\nfor (i = 0; i < cmd->pdu_count; i++) {\r\nredo:\r\nif (cmd->pdu_list[i].seq_no == seq_no) {\r\ncmd->pdu_list[i].pdu_send_order = pdu_send_order++;\r\ncontinue;\r\n}\r\nseq_no++;\r\npdu_send_order = 0;\r\ngoto redo;\r\n}\r\n}\r\nstatic void iscsit_create_random_array(u32 *array, u32 count)\r\n{\r\nint i, j, k;\r\nif (count == 1) {\r\narray[0] = 0;\r\nreturn;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nredo:\r\nget_random_bytes(&j, sizeof(u32));\r\nj = (1 + (int) (9999 + 1) - j) % count;\r\nfor (k = 0; k < i + 1; k++) {\r\nj |= 0x80000000;\r\nif ((array[k] & 0x80000000) && (array[k] == j))\r\ngoto redo;\r\n}\r\narray[i] = j;\r\n}\r\nfor (i = 0; i < count; i++)\r\narray[i] &= ~0x80000000;\r\n}\r\nstatic int iscsit_randomize_pdu_lists(\r\nstruct iscsi_cmd *cmd,\r\nu8 type)\r\n{\r\nint i = 0;\r\nu32 *array, pdu_count, seq_count = 0, seq_no = 0, seq_offset = 0;\r\nfor (pdu_count = 0; pdu_count < cmd->pdu_count; pdu_count++) {\r\nredo:\r\nif (cmd->pdu_list[pdu_count].seq_no == seq_no) {\r\nseq_count++;\r\ncontinue;\r\n}\r\narray = kzalloc(seq_count * sizeof(u32), GFP_KERNEL);\r\nif (!array) {\r\npr_err("Unable to allocate memory"\r\n" for random array.\n");\r\nreturn -1;\r\n}\r\niscsit_create_random_array(array, seq_count);\r\nfor (i = 0; i < seq_count; i++)\r\ncmd->pdu_list[seq_offset+i].pdu_send_order = array[i];\r\nkfree(array);\r\nseq_offset += seq_count;\r\nseq_count = 0;\r\nseq_no++;\r\ngoto redo;\r\n}\r\nif (seq_count) {\r\narray = kzalloc(seq_count * sizeof(u32), GFP_KERNEL);\r\nif (!array) {\r\npr_err("Unable to allocate memory for"\r\n" random array.\n");\r\nreturn -1;\r\n}\r\niscsit_create_random_array(array, seq_count);\r\nfor (i = 0; i < seq_count; i++)\r\ncmd->pdu_list[seq_offset+i].pdu_send_order = array[i];\r\nkfree(array);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsit_randomize_seq_lists(\r\nstruct iscsi_cmd *cmd,\r\nu8 type)\r\n{\r\nint i, j = 0;\r\nu32 *array, seq_count = cmd->seq_count;\r\nif ((type == PDULIST_IMMEDIATE) || (type == PDULIST_UNSOLICITED))\r\nseq_count--;\r\nelse if (type == PDULIST_IMMEDIATE_AND_UNSOLICITED)\r\nseq_count -= 2;\r\nif (!seq_count)\r\nreturn 0;\r\narray = kzalloc(seq_count * sizeof(u32), GFP_KERNEL);\r\nif (!array) {\r\npr_err("Unable to allocate memory for random array.\n");\r\nreturn -1;\r\n}\r\niscsit_create_random_array(array, seq_count);\r\nfor (i = 0; i < cmd->seq_count; i++) {\r\nif (cmd->seq_list[i].type != SEQTYPE_NORMAL)\r\ncontinue;\r\ncmd->seq_list[i].seq_send_order = array[j++];\r\n}\r\nkfree(array);\r\nreturn 0;\r\n}\r\nstatic void iscsit_determine_counts_for_list(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_build_list *bl,\r\nu32 *seq_count,\r\nu32 *pdu_count)\r\n{\r\nint check_immediate = 0;\r\nu32 burstlength = 0, offset = 0;\r\nu32 unsolicited_data_length = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nif ((bl->type == PDULIST_IMMEDIATE) ||\r\n(bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\r\ncheck_immediate = 1;\r\nif ((bl->type == PDULIST_UNSOLICITED) ||\r\n(bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\r\nunsolicited_data_length = (cmd->data_length >\r\nconn->sess->sess_ops->FirstBurstLength) ?\r\nconn->sess->sess_ops->FirstBurstLength : cmd->data_length;\r\nwhile (offset < cmd->data_length) {\r\n*pdu_count += 1;\r\nif (check_immediate) {\r\ncheck_immediate = 0;\r\noffset += bl->immediate_data_length;\r\n*seq_count += 1;\r\nif (unsolicited_data_length)\r\nunsolicited_data_length -=\r\nbl->immediate_data_length;\r\ncontinue;\r\n}\r\nif (unsolicited_data_length > 0) {\r\nif ((offset + conn->conn_ops->MaxRecvDataSegmentLength)\r\n>= cmd->data_length) {\r\nunsolicited_data_length -=\r\n(cmd->data_length - offset);\r\noffset += (cmd->data_length - offset);\r\ncontinue;\r\n}\r\nif ((offset + conn->conn_ops->MaxRecvDataSegmentLength)\r\n>= conn->sess->sess_ops->FirstBurstLength) {\r\nunsolicited_data_length -=\r\n(conn->sess->sess_ops->FirstBurstLength -\r\noffset);\r\noffset += (conn->sess->sess_ops->FirstBurstLength -\r\noffset);\r\nburstlength = 0;\r\n*seq_count += 1;\r\ncontinue;\r\n}\r\noffset += conn->conn_ops->MaxRecvDataSegmentLength;\r\nunsolicited_data_length -=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\ncontinue;\r\n}\r\nif ((offset + conn->conn_ops->MaxRecvDataSegmentLength) >=\r\ncmd->data_length) {\r\noffset += (cmd->data_length - offset);\r\ncontinue;\r\n}\r\nif ((burstlength + conn->conn_ops->MaxRecvDataSegmentLength) >=\r\nconn->sess->sess_ops->MaxBurstLength) {\r\noffset += (conn->sess->sess_ops->MaxBurstLength -\r\nburstlength);\r\nburstlength = 0;\r\n*seq_count += 1;\r\ncontinue;\r\n}\r\nburstlength += conn->conn_ops->MaxRecvDataSegmentLength;\r\noffset += conn->conn_ops->MaxRecvDataSegmentLength;\r\n}\r\n}\r\nstatic int iscsit_build_pdu_and_seq_list(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_build_list *bl)\r\n{\r\nint check_immediate = 0, datapduinorder, datasequenceinorder;\r\nu32 burstlength = 0, offset = 0, i = 0;\r\nu32 pdu_count = 0, seq_no = 0, unsolicited_data_length = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_pdu *pdu = cmd->pdu_list;\r\nstruct iscsi_seq *seq = cmd->seq_list;\r\ndatapduinorder = conn->sess->sess_ops->DataPDUInOrder;\r\ndatasequenceinorder = conn->sess->sess_ops->DataSequenceInOrder;\r\nif ((bl->type == PDULIST_IMMEDIATE) ||\r\n(bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\r\ncheck_immediate = 1;\r\nif ((bl->type == PDULIST_UNSOLICITED) ||\r\n(bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\r\nunsolicited_data_length = (cmd->data_length >\r\nconn->sess->sess_ops->FirstBurstLength) ?\r\nconn->sess->sess_ops->FirstBurstLength : cmd->data_length;\r\nwhile (offset < cmd->data_length) {\r\npdu_count++;\r\nif (!datapduinorder) {\r\npdu[i].offset = offset;\r\npdu[i].seq_no = seq_no;\r\n}\r\nif (!datasequenceinorder && (pdu_count == 1)) {\r\nseq[seq_no].pdu_start = i;\r\nseq[seq_no].seq_no = seq_no;\r\nseq[seq_no].offset = offset;\r\nseq[seq_no].orig_offset = offset;\r\n}\r\nif (check_immediate) {\r\ncheck_immediate = 0;\r\nif (!datapduinorder) {\r\npdu[i].type = PDUTYPE_IMMEDIATE;\r\npdu[i++].length = bl->immediate_data_length;\r\n}\r\nif (!datasequenceinorder) {\r\nseq[seq_no].type = SEQTYPE_IMMEDIATE;\r\nseq[seq_no].pdu_count = 1;\r\nseq[seq_no].xfer_len =\r\nbl->immediate_data_length;\r\n}\r\noffset += bl->immediate_data_length;\r\npdu_count = 0;\r\nseq_no++;\r\nif (unsolicited_data_length)\r\nunsolicited_data_length -=\r\nbl->immediate_data_length;\r\ncontinue;\r\n}\r\nif (unsolicited_data_length > 0) {\r\nif ((offset +\r\nconn->conn_ops->MaxRecvDataSegmentLength) >=\r\ncmd->data_length) {\r\nif (!datapduinorder) {\r\npdu[i].type = PDUTYPE_UNSOLICITED;\r\npdu[i].length =\r\n(cmd->data_length - offset);\r\n}\r\nif (!datasequenceinorder) {\r\nseq[seq_no].type = SEQTYPE_UNSOLICITED;\r\nseq[seq_no].pdu_count = pdu_count;\r\nseq[seq_no].xfer_len = (burstlength +\r\n(cmd->data_length - offset));\r\n}\r\nunsolicited_data_length -=\r\n(cmd->data_length - offset);\r\noffset += (cmd->data_length - offset);\r\ncontinue;\r\n}\r\nif ((offset +\r\nconn->conn_ops->MaxRecvDataSegmentLength) >=\r\nconn->sess->sess_ops->FirstBurstLength) {\r\nif (!datapduinorder) {\r\npdu[i].type = PDUTYPE_UNSOLICITED;\r\npdu[i++].length =\r\n(conn->sess->sess_ops->FirstBurstLength -\r\noffset);\r\n}\r\nif (!datasequenceinorder) {\r\nseq[seq_no].type = SEQTYPE_UNSOLICITED;\r\nseq[seq_no].pdu_count = pdu_count;\r\nseq[seq_no].xfer_len = (burstlength +\r\n(conn->sess->sess_ops->FirstBurstLength -\r\noffset));\r\n}\r\nunsolicited_data_length -=\r\n(conn->sess->sess_ops->FirstBurstLength -\r\noffset);\r\noffset += (conn->sess->sess_ops->FirstBurstLength -\r\noffset);\r\nburstlength = 0;\r\npdu_count = 0;\r\nseq_no++;\r\ncontinue;\r\n}\r\nif (!datapduinorder) {\r\npdu[i].type = PDUTYPE_UNSOLICITED;\r\npdu[i++].length =\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\n}\r\nburstlength += conn->conn_ops->MaxRecvDataSegmentLength;\r\noffset += conn->conn_ops->MaxRecvDataSegmentLength;\r\nunsolicited_data_length -=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\ncontinue;\r\n}\r\nif ((offset + conn->conn_ops->MaxRecvDataSegmentLength) >=\r\ncmd->data_length) {\r\nif (!datapduinorder) {\r\npdu[i].type = PDUTYPE_NORMAL;\r\npdu[i].length = (cmd->data_length - offset);\r\n}\r\nif (!datasequenceinorder) {\r\nseq[seq_no].type = SEQTYPE_NORMAL;\r\nseq[seq_no].pdu_count = pdu_count;\r\nseq[seq_no].xfer_len = (burstlength +\r\n(cmd->data_length - offset));\r\n}\r\noffset += (cmd->data_length - offset);\r\ncontinue;\r\n}\r\nif ((burstlength + conn->conn_ops->MaxRecvDataSegmentLength) >=\r\nconn->sess->sess_ops->MaxBurstLength) {\r\nif (!datapduinorder) {\r\npdu[i].type = PDUTYPE_NORMAL;\r\npdu[i++].length =\r\n(conn->sess->sess_ops->MaxBurstLength -\r\nburstlength);\r\n}\r\nif (!datasequenceinorder) {\r\nseq[seq_no].type = SEQTYPE_NORMAL;\r\nseq[seq_no].pdu_count = pdu_count;\r\nseq[seq_no].xfer_len = (burstlength +\r\n(conn->sess->sess_ops->MaxBurstLength -\r\nburstlength));\r\n}\r\noffset += (conn->sess->sess_ops->MaxBurstLength -\r\nburstlength);\r\nburstlength = 0;\r\npdu_count = 0;\r\nseq_no++;\r\ncontinue;\r\n}\r\nif (!datapduinorder) {\r\npdu[i].type = PDUTYPE_NORMAL;\r\npdu[i++].length =\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\n}\r\nburstlength += conn->conn_ops->MaxRecvDataSegmentLength;\r\noffset += conn->conn_ops->MaxRecvDataSegmentLength;\r\n}\r\nif (!datasequenceinorder) {\r\nif (bl->data_direction & ISCSI_PDU_WRITE) {\r\nif (bl->randomize & RANDOM_R2T_OFFSETS) {\r\nif (iscsit_randomize_seq_lists(cmd, bl->type)\r\n< 0)\r\nreturn -1;\r\n} else\r\niscsit_ordered_seq_lists(cmd, bl->type);\r\n} else if (bl->data_direction & ISCSI_PDU_READ) {\r\nif (bl->randomize & RANDOM_DATAIN_SEQ_OFFSETS) {\r\nif (iscsit_randomize_seq_lists(cmd, bl->type)\r\n< 0)\r\nreturn -1;\r\n} else\r\niscsit_ordered_seq_lists(cmd, bl->type);\r\n}\r\n#if 0\r\niscsit_dump_seq_list(cmd);\r\n#endif\r\n}\r\nif (!datapduinorder) {\r\nif (bl->data_direction & ISCSI_PDU_WRITE) {\r\nif (bl->randomize & RANDOM_DATAOUT_PDU_OFFSETS) {\r\nif (iscsit_randomize_pdu_lists(cmd, bl->type)\r\n< 0)\r\nreturn -1;\r\n} else\r\niscsit_ordered_pdu_lists(cmd, bl->type);\r\n} else if (bl->data_direction & ISCSI_PDU_READ) {\r\nif (bl->randomize & RANDOM_DATAIN_PDU_OFFSETS) {\r\nif (iscsit_randomize_pdu_lists(cmd, bl->type)\r\n< 0)\r\nreturn -1;\r\n} else\r\niscsit_ordered_pdu_lists(cmd, bl->type);\r\n}\r\n#if 0\r\niscsit_dump_pdu_list(cmd);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_do_build_list(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_build_list *bl)\r\n{\r\nu32 pdu_count = 0, seq_count = 1;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_pdu *pdu = NULL;\r\nstruct iscsi_seq *seq = NULL;\r\niscsit_determine_counts_for_list(cmd, bl, &seq_count, &pdu_count);\r\nif (!conn->sess->sess_ops->DataSequenceInOrder) {\r\nseq = kzalloc(seq_count * sizeof(struct iscsi_seq), GFP_ATOMIC);\r\nif (!seq) {\r\npr_err("Unable to allocate struct iscsi_seq list\n");\r\nreturn -1;\r\n}\r\ncmd->seq_list = seq;\r\ncmd->seq_count = seq_count;\r\n}\r\nif (!conn->sess->sess_ops->DataPDUInOrder) {\r\npdu = kzalloc(pdu_count * sizeof(struct iscsi_pdu), GFP_ATOMIC);\r\nif (!pdu) {\r\npr_err("Unable to allocate struct iscsi_pdu list.\n");\r\nkfree(seq);\r\nreturn -1;\r\n}\r\ncmd->pdu_list = pdu;\r\ncmd->pdu_count = pdu_count;\r\n}\r\nreturn iscsit_build_pdu_and_seq_list(cmd, bl);\r\n}\r\nstruct iscsi_pdu *iscsit_get_pdu_holder(\r\nstruct iscsi_cmd *cmd,\r\nu32 offset,\r\nu32 length)\r\n{\r\nu32 i;\r\nstruct iscsi_pdu *pdu = NULL;\r\nif (!cmd->pdu_list) {\r\npr_err("struct iscsi_cmd->pdu_list is NULL!\n");\r\nreturn NULL;\r\n}\r\npdu = &cmd->pdu_list[0];\r\nfor (i = 0; i < cmd->pdu_count; i++)\r\nif ((pdu[i].offset == offset) && (pdu[i].length == length))\r\nreturn &pdu[i];\r\npr_err("Unable to locate PDU holder for ITT: 0x%08x, Offset:"\r\n" %u, Length: %u\n", cmd->init_task_tag, offset, length);\r\nreturn NULL;\r\n}\r\nstruct iscsi_pdu *iscsit_get_pdu_holder_for_seq(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_seq *seq)\r\n{\r\nu32 i;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_pdu *pdu = NULL;\r\nif (!cmd->pdu_list) {\r\npr_err("struct iscsi_cmd->pdu_list is NULL!\n");\r\nreturn NULL;\r\n}\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nredo:\r\npdu = &cmd->pdu_list[cmd->pdu_start];\r\nfor (i = 0; pdu[i].seq_no != cmd->seq_no; i++) {\r\n#if 0\r\npr_debug("pdu[i].seq_no: %d, pdu[i].pdu"\r\n"_send_order: %d, pdu[i].offset: %d,"\r\n" pdu[i].length: %d\n", pdu[i].seq_no,\r\npdu[i].pdu_send_order, pdu[i].offset,\r\npdu[i].length);\r\n#endif\r\nif (pdu[i].pdu_send_order == cmd->pdu_send_order) {\r\ncmd->pdu_send_order++;\r\nreturn &pdu[i];\r\n}\r\n}\r\ncmd->pdu_start += cmd->pdu_send_order;\r\ncmd->pdu_send_order = 0;\r\ncmd->seq_no++;\r\nif (cmd->pdu_start < cmd->pdu_count)\r\ngoto redo;\r\npr_err("Command ITT: 0x%08x unable to locate"\r\n" struct iscsi_pdu for cmd->pdu_send_order: %u.\n",\r\ncmd->init_task_tag, cmd->pdu_send_order);\r\nreturn NULL;\r\n} else {\r\nif (!seq) {\r\npr_err("struct iscsi_seq is NULL!\n");\r\nreturn NULL;\r\n}\r\n#if 0\r\npr_debug("seq->pdu_start: %d, seq->pdu_count: %d,"\r\n" seq->seq_no: %d\n", seq->pdu_start, seq->pdu_count,\r\nseq->seq_no);\r\n#endif\r\npdu = &cmd->pdu_list[seq->pdu_start];\r\nif (seq->pdu_send_order == seq->pdu_count) {\r\npr_err("Command ITT: 0x%08x seq->pdu_send"\r\n"_order: %u equals seq->pdu_count: %u\n",\r\ncmd->init_task_tag, seq->pdu_send_order,\r\nseq->pdu_count);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < seq->pdu_count; i++) {\r\nif (pdu[i].pdu_send_order == seq->pdu_send_order) {\r\nseq->pdu_send_order++;\r\nreturn &pdu[i];\r\n}\r\n}\r\npr_err("Command ITT: 0x%08x unable to locate iscsi"\r\n"_pdu_t for seq->pdu_send_order: %u.\n",\r\ncmd->init_task_tag, seq->pdu_send_order);\r\nreturn NULL;\r\n}\r\nreturn NULL;\r\n}\r\nstruct iscsi_seq *iscsit_get_seq_holder(\r\nstruct iscsi_cmd *cmd,\r\nu32 offset,\r\nu32 length)\r\n{\r\nu32 i;\r\nif (!cmd->seq_list) {\r\npr_err("struct iscsi_cmd->seq_list is NULL!\n");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < cmd->seq_count; i++) {\r\n#if 0\r\npr_debug("seq_list[i].orig_offset: %d, seq_list[i]."\r\n"xfer_len: %d, seq_list[i].seq_no %u\n",\r\ncmd->seq_list[i].orig_offset, cmd->seq_list[i].xfer_len,\r\ncmd->seq_list[i].seq_no);\r\n#endif\r\nif ((cmd->seq_list[i].orig_offset +\r\ncmd->seq_list[i].xfer_len) >=\r\n(offset + length))\r\nreturn &cmd->seq_list[i];\r\n}\r\npr_err("Unable to locate Sequence holder for ITT: 0x%08x,"\r\n" Offset: %u, Length: %u\n", cmd->init_task_tag, offset,\r\nlength);\r\nreturn NULL;\r\n}
