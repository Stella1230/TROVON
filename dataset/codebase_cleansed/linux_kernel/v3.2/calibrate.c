static int __init lpj_setup(char *str)\r\n{\r\npreset_lpj = simple_strtoul(str,NULL,0);\r\nreturn 1;\r\n}\r\nstatic unsigned long __cpuinit calibrate_delay_direct(void)\r\n{\r\nunsigned long pre_start, start, post_start;\r\nunsigned long pre_end, end, post_end;\r\nunsigned long start_jiffies;\r\nunsigned long timer_rate_min, timer_rate_max;\r\nunsigned long good_timer_sum = 0;\r\nunsigned long good_timer_count = 0;\r\nunsigned long measured_times[MAX_DIRECT_CALIBRATION_RETRIES];\r\nint max = -1;\r\nint min = -1;\r\nint i;\r\nif (read_current_timer(&pre_start) < 0 )\r\nreturn 0;\r\nfor (i = 0; i < MAX_DIRECT_CALIBRATION_RETRIES; i++) {\r\npre_start = 0;\r\nread_current_timer(&start);\r\nstart_jiffies = jiffies;\r\nwhile (time_before_eq(jiffies, start_jiffies + 1)) {\r\npre_start = start;\r\nread_current_timer(&start);\r\n}\r\nread_current_timer(&post_start);\r\npre_end = 0;\r\nend = post_start;\r\nwhile (time_before_eq(jiffies, start_jiffies + 1 +\r\nDELAY_CALIBRATION_TICKS)) {\r\npre_end = end;\r\nread_current_timer(&end);\r\n}\r\nread_current_timer(&post_end);\r\ntimer_rate_max = (post_end - pre_start) /\r\nDELAY_CALIBRATION_TICKS;\r\ntimer_rate_min = (pre_end - post_start) /\r\nDELAY_CALIBRATION_TICKS;\r\nif (start >= post_end)\r\nprintk(KERN_NOTICE "calibrate_delay_direct() ignoring "\r\n"timer_rate as we had a TSC wrap around"\r\n" start=%lu >=post_end=%lu\n",\r\nstart, post_end);\r\nif (start < post_end && pre_start != 0 && pre_end != 0 &&\r\n(timer_rate_max - timer_rate_min) < (timer_rate_max >> 3)) {\r\ngood_timer_count++;\r\ngood_timer_sum += timer_rate_max;\r\nmeasured_times[i] = timer_rate_max;\r\nif (max < 0 || timer_rate_max > measured_times[max])\r\nmax = i;\r\nif (min < 0 || timer_rate_max < measured_times[min])\r\nmin = i;\r\n} else\r\nmeasured_times[i] = 0;\r\n}\r\nwhile (good_timer_count > 1) {\r\nunsigned long estimate;\r\nunsigned long maxdiff;\r\nestimate = (good_timer_sum/good_timer_count);\r\nmaxdiff = estimate >> 3;\r\nif ((measured_times[max] - measured_times[min]) < maxdiff)\r\nreturn estimate;\r\ngood_timer_sum = 0;\r\ngood_timer_count = 0;\r\nif ((measured_times[max] - estimate) <\r\n(estimate - measured_times[min])) {\r\nprintk(KERN_NOTICE "calibrate_delay_direct() dropping "\r\n"min bogoMips estimate %d = %lu\n",\r\nmin, measured_times[min]);\r\nmeasured_times[min] = 0;\r\nmin = max;\r\n} else {\r\nprintk(KERN_NOTICE "calibrate_delay_direct() dropping "\r\n"max bogoMips estimate %d = %lu\n",\r\nmax, measured_times[max]);\r\nmeasured_times[max] = 0;\r\nmax = min;\r\n}\r\nfor (i = 0; i < MAX_DIRECT_CALIBRATION_RETRIES; i++) {\r\nif (measured_times[i] == 0)\r\ncontinue;\r\ngood_timer_count++;\r\ngood_timer_sum += measured_times[i];\r\nif (measured_times[i] < measured_times[min])\r\nmin = i;\r\nif (measured_times[i] > measured_times[max])\r\nmax = i;\r\n}\r\n}\r\nprintk(KERN_NOTICE "calibrate_delay_direct() failed to get a good "\r\n"estimate for loops_per_jiffy.\nProbably due to long platform "\r\n"interrupts. Consider using \"lpj=\" boot option.\n");\r\nreturn 0;\r\n}\r\nstatic unsigned long __cpuinit calibrate_delay_direct(void) {return 0;}\r\nstatic unsigned long __cpuinit calibrate_delay_converge(void)\r\n{\r\nunsigned long lpj, lpj_base, ticks, loopadd, loopadd_base, chop_limit;\r\nint trials = 0, band = 0, trial_in_band = 0;\r\nlpj = (1<<12);\r\nticks = jiffies;\r\nwhile (ticks == jiffies)\r\n;\r\nticks = jiffies;\r\ndo {\r\nif (++trial_in_band == (1<<band)) {\r\n++band;\r\ntrial_in_band = 0;\r\n}\r\n__delay(lpj * band);\r\ntrials += band;\r\n} while (ticks == jiffies);\r\ntrials -= band;\r\nloopadd_base = lpj * band;\r\nlpj_base = lpj * trials;\r\nrecalibrate:\r\nlpj = lpj_base;\r\nloopadd = loopadd_base;\r\nchop_limit = lpj >> LPS_PREC;\r\nwhile (loopadd > chop_limit) {\r\nlpj += loopadd;\r\nticks = jiffies;\r\nwhile (ticks == jiffies)\r\n;\r\nticks = jiffies;\r\n__delay(lpj);\r\nif (jiffies != ticks)\r\nlpj -= loopadd;\r\nloopadd >>= 1;\r\n}\r\nif (lpj + loopadd * 2 == lpj_base + loopadd_base * 2) {\r\nlpj_base = lpj;\r\nloopadd_base <<= 2;\r\ngoto recalibrate;\r\n}\r\nreturn lpj;\r\n}\r\nvoid __cpuinit calibrate_delay(void)\r\n{\r\nunsigned long lpj;\r\nstatic bool printed;\r\nint this_cpu = smp_processor_id();\r\nif (per_cpu(cpu_loops_per_jiffy, this_cpu)) {\r\nlpj = per_cpu(cpu_loops_per_jiffy, this_cpu);\r\npr_info("Calibrating delay loop (skipped) "\r\n"already calibrated this CPU");\r\n} else if (preset_lpj) {\r\nlpj = preset_lpj;\r\nif (!printed)\r\npr_info("Calibrating delay loop (skipped) "\r\n"preset value.. ");\r\n} else if ((!printed) && lpj_fine) {\r\nlpj = lpj_fine;\r\npr_info("Calibrating delay loop (skipped), "\r\n"value calculated using timer frequency.. ");\r\n} else if ((lpj = calibrate_delay_direct()) != 0) {\r\nif (!printed)\r\npr_info("Calibrating delay using timer "\r\n"specific routine.. ");\r\n} else {\r\nif (!printed)\r\npr_info("Calibrating delay loop... ");\r\nlpj = calibrate_delay_converge();\r\n}\r\nper_cpu(cpu_loops_per_jiffy, this_cpu) = lpj;\r\nif (!printed)\r\npr_cont("%lu.%02lu BogoMIPS (lpj=%lu)\n",\r\nlpj/(500000/HZ),\r\n(lpj/(5000/HZ)) % 100, lpj);\r\nloops_per_jiffy = lpj;\r\nprinted = true;\r\n}
