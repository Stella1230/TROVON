void res_counter_init(struct res_counter *counter, struct res_counter *parent)\r\n{\r\nspin_lock_init(&counter->lock);\r\ncounter->limit = RESOURCE_MAX;\r\ncounter->soft_limit = RESOURCE_MAX;\r\ncounter->parent = parent;\r\n}\r\nint res_counter_charge_locked(struct res_counter *counter, unsigned long val)\r\n{\r\nif (counter->usage + val > counter->limit) {\r\ncounter->failcnt++;\r\nreturn -ENOMEM;\r\n}\r\ncounter->usage += val;\r\nif (counter->usage > counter->max_usage)\r\ncounter->max_usage = counter->usage;\r\nreturn 0;\r\n}\r\nint res_counter_charge(struct res_counter *counter, unsigned long val,\r\nstruct res_counter **limit_fail_at)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct res_counter *c, *u;\r\n*limit_fail_at = NULL;\r\nlocal_irq_save(flags);\r\nfor (c = counter; c != NULL; c = c->parent) {\r\nspin_lock(&c->lock);\r\nret = res_counter_charge_locked(c, val);\r\nspin_unlock(&c->lock);\r\nif (ret < 0) {\r\n*limit_fail_at = c;\r\ngoto undo;\r\n}\r\n}\r\nret = 0;\r\ngoto done;\r\nundo:\r\nfor (u = counter; u != c; u = u->parent) {\r\nspin_lock(&u->lock);\r\nres_counter_uncharge_locked(u, val);\r\nspin_unlock(&u->lock);\r\n}\r\ndone:\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nvoid res_counter_uncharge_locked(struct res_counter *counter, unsigned long val)\r\n{\r\nif (WARN_ON(counter->usage < val))\r\nval = counter->usage;\r\ncounter->usage -= val;\r\n}\r\nvoid res_counter_uncharge(struct res_counter *counter, unsigned long val)\r\n{\r\nunsigned long flags;\r\nstruct res_counter *c;\r\nlocal_irq_save(flags);\r\nfor (c = counter; c != NULL; c = c->parent) {\r\nspin_lock(&c->lock);\r\nres_counter_uncharge_locked(c, val);\r\nspin_unlock(&c->lock);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline unsigned long long *\r\nres_counter_member(struct res_counter *counter, int member)\r\n{\r\nswitch (member) {\r\ncase RES_USAGE:\r\nreturn &counter->usage;\r\ncase RES_MAX_USAGE:\r\nreturn &counter->max_usage;\r\ncase RES_LIMIT:\r\nreturn &counter->limit;\r\ncase RES_FAILCNT:\r\nreturn &counter->failcnt;\r\ncase RES_SOFT_LIMIT:\r\nreturn &counter->soft_limit;\r\n};\r\nBUG();\r\nreturn NULL;\r\n}\r\nssize_t res_counter_read(struct res_counter *counter, int member,\r\nconst char __user *userbuf, size_t nbytes, loff_t *pos,\r\nint (*read_strategy)(unsigned long long val, char *st_buf))\r\n{\r\nunsigned long long *val;\r\nchar buf[64], *s;\r\ns = buf;\r\nval = res_counter_member(counter, member);\r\nif (read_strategy)\r\ns += read_strategy(*val, s);\r\nelse\r\ns += sprintf(s, "%llu\n", *val);\r\nreturn simple_read_from_buffer((void __user *)userbuf, nbytes,\r\npos, buf, s - buf);\r\n}\r\nu64 res_counter_read_u64(struct res_counter *counter, int member)\r\n{\r\nunsigned long flags;\r\nu64 ret;\r\nspin_lock_irqsave(&counter->lock, flags);\r\nret = *res_counter_member(counter, member);\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nreturn ret;\r\n}\r\nu64 res_counter_read_u64(struct res_counter *counter, int member)\r\n{\r\nreturn *res_counter_member(counter, member);\r\n}\r\nint res_counter_memparse_write_strategy(const char *buf,\r\nunsigned long long *res)\r\n{\r\nchar *end;\r\nif (*buf == '-') {\r\n*res = simple_strtoull(buf + 1, &end, 10);\r\nif (*res != 1 || *end != '\0')\r\nreturn -EINVAL;\r\n*res = RESOURCE_MAX;\r\nreturn 0;\r\n}\r\n*res = memparse((char *)buf, &end);\r\nif (*end != '\0')\r\nreturn -EINVAL;\r\n*res = PAGE_ALIGN(*res);\r\nreturn 0;\r\n}\r\nint res_counter_write(struct res_counter *counter, int member,\r\nconst char *buf, write_strategy_fn write_strategy)\r\n{\r\nchar *end;\r\nunsigned long flags;\r\nunsigned long long tmp, *val;\r\nif (write_strategy) {\r\nif (write_strategy(buf, &tmp))\r\nreturn -EINVAL;\r\n} else {\r\ntmp = simple_strtoull(buf, &end, 10);\r\nif (*end != '\0')\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&counter->lock, flags);\r\nval = res_counter_member(counter, member);\r\n*val = tmp;\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nreturn 0;\r\n}
