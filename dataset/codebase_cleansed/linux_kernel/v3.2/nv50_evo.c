static void\r\nnv50_evo_channel_del(struct nouveau_channel **pevo)\r\n{\r\nstruct nouveau_channel *evo = *pevo;\r\nif (!evo)\r\nreturn;\r\n*pevo = NULL;\r\nnouveau_ramht_ref(NULL, &evo->ramht, evo);\r\nnouveau_gpuobj_channel_takedown(evo);\r\nnouveau_bo_unmap(evo->pushbuf_bo);\r\nnouveau_bo_ref(NULL, &evo->pushbuf_bo);\r\nif (evo->user)\r\niounmap(evo->user);\r\nkfree(evo);\r\n}\r\nvoid\r\nnv50_evo_dmaobj_init(struct nouveau_gpuobj *obj, u32 memtype, u64 base, u64 size)\r\n{\r\nstruct drm_nouveau_private *dev_priv = obj->dev->dev_private;\r\nu32 flags5;\r\nif (dev_priv->chipset < 0xc0) {\r\nif (dev_priv->chipset == 0x50)\r\nmemtype = 0;\r\nflags5 = 0x00010000;\r\n} else {\r\nif (memtype & 0x80000000)\r\nflags5 = 0x00000000;\r\nelse\r\nflags5 = 0x00020000;\r\n}\r\nnv50_gpuobj_dma_init(obj, 0, 0x3d, base, size, NV_MEM_TARGET_VRAM,\r\nNV_MEM_ACCESS_RW, (memtype >> 8) & 0xff, 0);\r\nnv_wo32(obj, 0x14, flags5);\r\ndev_priv->engine.instmem.flush(obj->dev);\r\n}\r\nint\r\nnv50_evo_dmaobj_new(struct nouveau_channel *evo, u32 handle, u32 memtype,\r\nu64 base, u64 size, struct nouveau_gpuobj **pobj)\r\n{\r\nstruct nv50_display *disp = nv50_display(evo->dev);\r\nstruct nouveau_gpuobj *obj = NULL;\r\nint ret;\r\nret = nouveau_gpuobj_new(evo->dev, disp->master, 6*4, 32, 0, &obj);\r\nif (ret)\r\nreturn ret;\r\nobj->engine = NVOBJ_ENGINE_DISPLAY;\r\nnv50_evo_dmaobj_init(obj, memtype, base, size);\r\nret = nouveau_ramht_insert(evo, handle, obj);\r\nif (ret)\r\ngoto out;\r\nif (pobj)\r\nnouveau_gpuobj_ref(obj, pobj);\r\nout:\r\nnouveau_gpuobj_ref(NULL, &obj);\r\nreturn ret;\r\n}\r\nstatic int\r\nnv50_evo_channel_new(struct drm_device *dev, int chid,\r\nstruct nouveau_channel **pevo)\r\n{\r\nstruct nv50_display *disp = nv50_display(dev);\r\nstruct nouveau_channel *evo;\r\nint ret;\r\nevo = kzalloc(sizeof(struct nouveau_channel), GFP_KERNEL);\r\nif (!evo)\r\nreturn -ENOMEM;\r\n*pevo = evo;\r\nevo->id = chid;\r\nevo->dev = dev;\r\nevo->user_get = 4;\r\nevo->user_put = 0;\r\nret = nouveau_bo_new(dev, 4096, 0, TTM_PL_FLAG_VRAM, 0, 0,\r\n&evo->pushbuf_bo);\r\nif (ret == 0)\r\nret = nouveau_bo_pin(evo->pushbuf_bo, TTM_PL_FLAG_VRAM);\r\nif (ret) {\r\nNV_ERROR(dev, "Error creating EVO DMA push buffer: %d\n", ret);\r\nnv50_evo_channel_del(pevo);\r\nreturn ret;\r\n}\r\nret = nouveau_bo_map(evo->pushbuf_bo);\r\nif (ret) {\r\nNV_ERROR(dev, "Error mapping EVO DMA push buffer: %d\n", ret);\r\nnv50_evo_channel_del(pevo);\r\nreturn ret;\r\n}\r\nevo->user = ioremap(pci_resource_start(dev->pdev, 0) +\r\nNV50_PDISPLAY_USER(evo->id), PAGE_SIZE);\r\nif (!evo->user) {\r\nNV_ERROR(dev, "Error mapping EVO control regs.\n");\r\nnv50_evo_channel_del(pevo);\r\nreturn -ENOMEM;\r\n}\r\nif (disp->master && evo != disp->master)\r\nnouveau_ramht_ref(disp->master->ramht, &evo->ramht, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_evo_channel_init(struct nouveau_channel *evo)\r\n{\r\nstruct drm_device *dev = evo->dev;\r\nint id = evo->id, ret, i;\r\nu64 pushbuf = evo->pushbuf_bo->bo.offset;\r\nu32 tmp;\r\ntmp = nv_rd32(dev, NV50_PDISPLAY_EVO_CTRL(id));\r\nif ((tmp & 0x009f0000) == 0x00020000)\r\nnv_wr32(dev, NV50_PDISPLAY_EVO_CTRL(id), tmp | 0x00800000);\r\ntmp = nv_rd32(dev, NV50_PDISPLAY_EVO_CTRL(id));\r\nif ((tmp & 0x003f0000) == 0x00030000)\r\nnv_wr32(dev, NV50_PDISPLAY_EVO_CTRL(id), tmp | 0x00600000);\r\nnv_wr32(dev, NV50_PDISPLAY_EVO_DMA_CB(id), pushbuf >> 8 |\r\nNV50_PDISPLAY_EVO_DMA_CB_LOCATION_VRAM |\r\nNV50_PDISPLAY_EVO_DMA_CB_VALID);\r\nnv_wr32(dev, NV50_PDISPLAY_EVO_UNK2(id), 0x00010000);\r\nnv_wr32(dev, NV50_PDISPLAY_EVO_HASH_TAG(id), id);\r\nnv_mask(dev, NV50_PDISPLAY_EVO_CTRL(id), NV50_PDISPLAY_EVO_CTRL_DMA,\r\nNV50_PDISPLAY_EVO_CTRL_DMA_ENABLED);\r\nnv_wr32(dev, NV50_PDISPLAY_USER_PUT(id), 0x00000000);\r\nnv_wr32(dev, NV50_PDISPLAY_EVO_CTRL(id), 0x01000003 |\r\nNV50_PDISPLAY_EVO_CTRL_DMA_ENABLED);\r\nif (!nv_wait(dev, NV50_PDISPLAY_EVO_CTRL(id), 0x80000000, 0x00000000)) {\r\nNV_ERROR(dev, "EvoCh %d init timeout: 0x%08x\n", id,\r\nnv_rd32(dev, NV50_PDISPLAY_EVO_CTRL(id)));\r\nreturn -EBUSY;\r\n}\r\nnv_mask(dev, 0x610028, 0x00000000, 0x00010001 << id);\r\nevo->dma.max = (4096/4) - 2;\r\nevo->dma.max &= ~7;\r\nevo->dma.put = 0;\r\nevo->dma.cur = evo->dma.put;\r\nevo->dma.free = evo->dma.max - evo->dma.cur;\r\nret = RING_SPACE(evo, NOUVEAU_DMA_SKIPS);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < NOUVEAU_DMA_SKIPS; i++)\r\nOUT_RING(evo, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_evo_channel_fini(struct nouveau_channel *evo)\r\n{\r\nstruct drm_device *dev = evo->dev;\r\nint id = evo->id;\r\nnv_mask(dev, 0x610028, 0x00010001 << id, 0x00000000);\r\nnv_mask(dev, NV50_PDISPLAY_EVO_CTRL(id), 0x00001010, 0x00001000);\r\nnv_wr32(dev, NV50_PDISPLAY_INTR_0, (1 << id));\r\nnv_mask(dev, NV50_PDISPLAY_EVO_CTRL(id), 0x00000003, 0x00000000);\r\nif (!nv_wait(dev, NV50_PDISPLAY_EVO_CTRL(id), 0x001e0000, 0x00000000)) {\r\nNV_ERROR(dev, "EvoCh %d takedown timeout: 0x%08x\n", id,\r\nnv_rd32(dev, NV50_PDISPLAY_EVO_CTRL(id)));\r\n}\r\n}\r\nstatic void\r\nnv50_evo_destroy(struct drm_device *dev)\r\n{\r\nstruct nv50_display *disp = nv50_display(dev);\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (disp->crtc[i].sem.bo) {\r\nnouveau_bo_unmap(disp->crtc[i].sem.bo);\r\nnouveau_bo_ref(NULL, &disp->crtc[i].sem.bo);\r\n}\r\nnv50_evo_channel_del(&disp->crtc[i].sync);\r\n}\r\nnouveau_gpuobj_ref(NULL, &disp->ntfy);\r\nnv50_evo_channel_del(&disp->master);\r\n}\r\nstatic int\r\nnv50_evo_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_display *disp = nv50_display(dev);\r\nstruct nouveau_gpuobj *ramht = NULL;\r\nstruct nouveau_channel *evo;\r\nint ret, i, j;\r\nret = nv50_evo_channel_new(dev, 0, &disp->master);\r\nif (ret)\r\nreturn ret;\r\nevo = disp->master;\r\nret = nouveau_gpuobj_new(dev, NULL, 32768, 65536,\r\nNVOBJ_FLAG_ZERO_ALLOC, &evo->ramin);\r\nif (ret) {\r\nNV_ERROR(dev, "Error allocating EVO channel memory: %d\n", ret);\r\ngoto err;\r\n}\r\nret = drm_mm_init(&evo->ramin_heap, 0, 32768);\r\nif (ret) {\r\nNV_ERROR(dev, "Error initialising EVO PRAMIN heap: %d\n", ret);\r\ngoto err;\r\n}\r\nret = nouveau_gpuobj_new(dev, evo, 4096, 16, 0, &ramht);\r\nif (ret) {\r\nNV_ERROR(dev, "Unable to allocate EVO RAMHT: %d\n", ret);\r\ngoto err;\r\n}\r\nret = nouveau_ramht_new(dev, ramht, &evo->ramht);\r\nnouveau_gpuobj_ref(NULL, &ramht);\r\nif (ret)\r\ngoto err;\r\nret = nouveau_gpuobj_new(dev, disp->master, 0x1000, 0,\r\nNVOBJ_FLAG_ZERO_ALLOC, &disp->ntfy);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(disp->master, NvEvoSync, 0x0000,\r\ndisp->ntfy->vinst, disp->ntfy->size, NULL);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(disp->master, NvEvoVRAM, 0x0000,\r\n0, dev_priv->vram_size, NULL);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(disp->master, NvEvoVRAM_LP, 0x80000000,\r\n0, dev_priv->vram_size, NULL);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(disp->master, NvEvoFB32, 0x80000000 |\r\n(dev_priv->chipset < 0xc0 ? 0x7a00 : 0xfe00),\r\n0, dev_priv->vram_size, NULL);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(disp->master, NvEvoFB16, 0x80000000 |\r\n(dev_priv->chipset < 0xc0 ? 0x7000 : 0xfe00),\r\n0, dev_priv->vram_size, NULL);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < 2; i++) {\r\nstruct nv50_display_crtc *dispc = &disp->crtc[i];\r\nu64 offset;\r\nret = nv50_evo_channel_new(dev, 1 + i, &dispc->sync);\r\nif (ret)\r\ngoto err;\r\nret = nouveau_bo_new(dev, 4096, 0x1000, TTM_PL_FLAG_VRAM,\r\n0, 0x0000, &dispc->sem.bo);\r\nif (!ret) {\r\nret = nouveau_bo_pin(dispc->sem.bo, TTM_PL_FLAG_VRAM);\r\nif (!ret)\r\nret = nouveau_bo_map(dispc->sem.bo);\r\nif (ret)\r\nnouveau_bo_ref(NULL, &dispc->sem.bo);\r\noffset = dispc->sem.bo->bo.offset;\r\n}\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(dispc->sync, NvEvoSync, 0x0000,\r\noffset, 4096, NULL);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(dispc->sync, NvEvoVRAM_LP, 0x80000000,\r\n0, dev_priv->vram_size, NULL);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(dispc->sync, NvEvoFB32, 0x80000000 |\r\n(dev_priv->chipset < 0xc0 ?\r\n0x7a00 : 0xfe00),\r\n0, dev_priv->vram_size, NULL);\r\nif (ret)\r\ngoto err;\r\nret = nv50_evo_dmaobj_new(dispc->sync, NvEvoFB16, 0x80000000 |\r\n(dev_priv->chipset < 0xc0 ?\r\n0x7000 : 0xfe00),\r\n0, dev_priv->vram_size, NULL);\r\nif (ret)\r\ngoto err;\r\nfor (j = 0; j < 4096; j += 4)\r\nnouveau_bo_wr32(dispc->sem.bo, j / 4, 0x74b1e000);\r\ndispc->sem.offset = 0;\r\n}\r\nreturn 0;\r\nerr:\r\nnv50_evo_destroy(dev);\r\nreturn ret;\r\n}\r\nint\r\nnv50_evo_init(struct drm_device *dev)\r\n{\r\nstruct nv50_display *disp = nv50_display(dev);\r\nint ret, i;\r\nif (!disp->master) {\r\nret = nv50_evo_create(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = nv50_evo_channel_init(disp->master);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 2; i++) {\r\nret = nv50_evo_channel_init(disp->crtc[i].sync);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_evo_fini(struct drm_device *dev)\r\n{\r\nstruct nv50_display *disp = nv50_display(dev);\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (disp->crtc[i].sync)\r\nnv50_evo_channel_fini(disp->crtc[i].sync);\r\n}\r\nif (disp->master)\r\nnv50_evo_channel_fini(disp->master);\r\nnv50_evo_destroy(dev);\r\n}
