static int __init keyspan_init(void)\r\n{\r\nint retval;\r\nretval = usb_serial_register(&keyspan_pre_device);\r\nif (retval)\r\ngoto failed_pre_device_register;\r\nretval = usb_serial_register(&keyspan_1port_device);\r\nif (retval)\r\ngoto failed_1port_device_register;\r\nretval = usb_serial_register(&keyspan_2port_device);\r\nif (retval)\r\ngoto failed_2port_device_register;\r\nretval = usb_serial_register(&keyspan_4port_device);\r\nif (retval)\r\ngoto failed_4port_device_register;\r\nretval = usb_register(&keyspan_driver);\r\nif (retval)\r\ngoto failed_usb_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nreturn 0;\r\nfailed_usb_register:\r\nusb_serial_deregister(&keyspan_4port_device);\r\nfailed_4port_device_register:\r\nusb_serial_deregister(&keyspan_2port_device);\r\nfailed_2port_device_register:\r\nusb_serial_deregister(&keyspan_1port_device);\r\nfailed_1port_device_register:\r\nusb_serial_deregister(&keyspan_pre_device);\r\nfailed_pre_device_register:\r\nreturn retval;\r\n}\r\nstatic void __exit keyspan_exit(void)\r\n{\r\nusb_deregister(&keyspan_driver);\r\nusb_serial_deregister(&keyspan_pre_device);\r\nusb_serial_deregister(&keyspan_1port_device);\r\nusb_serial_deregister(&keyspan_2port_device);\r\nusb_serial_deregister(&keyspan_4port_device);\r\n}\r\nstatic void keyspan_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct keyspan_port_private *p_priv;\r\ndbg("%s", __func__);\r\np_priv = usb_get_serial_port_data(port);\r\nif (break_state == -1)\r\np_priv->break_on = 1;\r\nelse\r\np_priv->break_on = 0;\r\nkeyspan_send_setup(port, 0);\r\n}\r\nstatic void keyspan_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nint baud_rate, device_port;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nunsigned int cflag;\r\ndbg("%s", __func__);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = p_priv->device_details;\r\ncflag = tty->termios->c_cflag;\r\ndevice_port = port->number - port->serial->minor;\r\nbaud_rate = tty_get_baud_rate(tty);\r\nif (d_details->calculate_baud_rate(baud_rate, d_details->baudclk,\r\nNULL, NULL, NULL, device_port) == KEYSPAN_BAUD_RATE_OK) {\r\np_priv->baud = baud_rate;\r\n} else\r\nbaud_rate = tty_termios_baud_rate(old_termios);\r\ntty_encode_baud_rate(tty, baud_rate, baud_rate);\r\np_priv->cflag = cflag;\r\np_priv->flow_control = (cflag & CRTSCTS)? flow_cts: flow_none;\r\ntty->termios->c_cflag &= ~CMSPAR;\r\nkeyspan_send_setup(port, 0);\r\n}\r\nstatic int keyspan_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct keyspan_port_private *p_priv = usb_get_serial_port_data(port);\r\nunsigned int value;\r\nvalue = ((p_priv->rts_state) ? TIOCM_RTS : 0) |\r\n((p_priv->dtr_state) ? TIOCM_DTR : 0) |\r\n((p_priv->cts_state) ? TIOCM_CTS : 0) |\r\n((p_priv->dsr_state) ? TIOCM_DSR : 0) |\r\n((p_priv->dcd_state) ? TIOCM_CAR : 0) |\r\n((p_priv->ri_state) ? TIOCM_RNG : 0);\r\nreturn value;\r\n}\r\nstatic int keyspan_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct keyspan_port_private *p_priv = usb_get_serial_port_data(port);\r\nif (set & TIOCM_RTS)\r\np_priv->rts_state = 1;\r\nif (set & TIOCM_DTR)\r\np_priv->dtr_state = 1;\r\nif (clear & TIOCM_RTS)\r\np_priv->rts_state = 0;\r\nif (clear & TIOCM_DTR)\r\np_priv->dtr_state = 0;\r\nkeyspan_send_setup(port, 0);\r\nreturn 0;\r\n}\r\nstatic int keyspan_write(struct tty_struct *tty,\r\nstruct usb_serial_port *port, const unsigned char *buf, int count)\r\n{\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nint flip;\r\nint left, todo;\r\nstruct urb *this_urb;\r\nint err, maxDataLen, dataOffset;\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = p_priv->device_details;\r\nif (d_details->msg_format == msg_usa90) {\r\nmaxDataLen = 64;\r\ndataOffset = 0;\r\n} else {\r\nmaxDataLen = 63;\r\ndataOffset = 1;\r\n}\r\ndbg("%s - for port %d (%d chars), flip=%d",\r\n__func__, port->number, count, p_priv->out_flip);\r\nfor (left = count; left > 0; left -= todo) {\r\ntodo = left;\r\nif (todo > maxDataLen)\r\ntodo = maxDataLen;\r\nflip = p_priv->out_flip;\r\nthis_urb = p_priv->out_urbs[flip];\r\nif (this_urb == NULL) {\r\ndbg("%s - no output urb :(", __func__);\r\nreturn count;\r\n}\r\ndbg("%s - endpoint %d flip %d",\r\n__func__, usb_pipeendpoint(this_urb->pipe), flip);\r\nif (this_urb->status == -EINPROGRESS) {\r\nif (time_before(jiffies,\r\np_priv->tx_start_time[flip] + 10 * HZ))\r\nbreak;\r\nusb_unlink_urb(this_urb);\r\nbreak;\r\n}\r\n((char *)this_urb->transfer_buffer)[0] = 0;\r\nmemcpy(this_urb->transfer_buffer + dataOffset, buf, todo);\r\nbuf += todo;\r\nthis_urb->transfer_buffer_length = todo + dataOffset;\r\nthis_urb->dev = port->serial->dev;\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("usb_submit_urb(write bulk) failed (%d)", err);\r\np_priv->tx_start_time[flip] = jiffies;\r\np_priv->out_flip = (flip + 1) & d_details->outdat_endp_flip;\r\n}\r\nreturn count - left;\r\n}\r\nstatic void usa26_indat_callback(struct urb *urb)\r\n{\r\nint i, err;\r\nint endpoint;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nendpoint = usb_pipeendpoint(urb->pipe);\r\nif (status) {\r\ndbg("%s - nonzero status: %x on endpoint %d.",\r\n__func__, status, endpoint);\r\nreturn;\r\n}\r\nport = urb->context;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && urb->actual_length) {\r\nif ((data[0] & 0x80) == 0) {\r\nif (data[0] & RXERROR_OVERRUN)\r\nerr = TTY_OVERRUN;\r\nelse\r\nerr = 0;\r\nfor (i = 1; i < urb->actual_length ; ++i)\r\ntty_insert_flip_char(tty, data[i], err);\r\n} else {\r\ndbg("%s - RX error!!!!", __func__);\r\nfor (i = 0; i + 1 < urb->actual_length; i += 2) {\r\nint stat = data[i], flag = 0;\r\nif (stat & RXERROR_OVERRUN)\r\nflag |= TTY_OVERRUN;\r\nif (stat & RXERROR_FRAMING)\r\nflag |= TTY_FRAME;\r\nif (stat & RXERROR_PARITY)\r\nflag |= TTY_PARITY;\r\ntty_insert_flip_char(tty, data[i+1], flag);\r\n}\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\nurb->dev = port->serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\n}\r\nstatic void usa2x_outdat_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nport = urb->context;\r\np_priv = usb_get_serial_port_data(port);\r\ndbg("%s - urb %d", __func__, urb == p_priv->out_urbs[1]);\r\nusb_serial_port_softint(port);\r\n}\r\nstatic void usa26_inack_callback(struct urb *urb)\r\n{\r\ndbg("%s", __func__);\r\n}\r\nstatic void usa26_outcont_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nport = urb->context;\r\np_priv = usb_get_serial_port_data(port);\r\nif (p_priv->resend_cont) {\r\ndbg("%s - sending setup", __func__);\r\nkeyspan_usa26_send_setup(port->serial, port,\r\np_priv->resend_cont - 1);\r\n}\r\n}\r\nstatic void usa26_instat_callback(struct urb *urb)\r\n{\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct keyspan_usa26_portStatusMessage *msg;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nstruct tty_struct *tty;\r\nint old_dcd_state, err;\r\nint status = urb->status;\r\nserial = urb->context;\r\nif (status) {\r\ndbg("%s - nonzero status: %x", __func__, status);\r\nreturn;\r\n}\r\nif (urb->actual_length != 9) {\r\ndbg("%s - %d byte report??", __func__, urb->actual_length);\r\ngoto exit;\r\n}\r\nmsg = (struct keyspan_usa26_portStatusMessage *)data;\r\n#if 0\r\ndbg("%s - port status: port %d cts %d dcd %d dsr %d ri %d toff %d txoff %d rxen %d cr %d",\r\n__func__, msg->port, msg->hskia_cts, msg->gpia_dcd, msg->dsr, msg->ri, msg->_txOff,\r\nmsg->_txXoff, msg->rxEnabled, msg->controlResponse);\r\n#endif\r\nif (msg->port >= serial->num_ports) {\r\ndbg("%s - Unexpected port number %d", __func__, msg->port);\r\ngoto exit;\r\n}\r\nport = serial->port[msg->port];\r\np_priv = usb_get_serial_port_data(port);\r\nold_dcd_state = p_priv->dcd_state;\r\np_priv->cts_state = ((msg->hskia_cts) ? 1 : 0);\r\np_priv->dsr_state = ((msg->dsr) ? 1 : 0);\r\np_priv->dcd_state = ((msg->gpia_dcd) ? 1 : 0);\r\np_priv->ri_state = ((msg->ri) ? 1 : 0);\r\nif (old_dcd_state != p_priv->dcd_state) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && !C_CLOCAL(tty))\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nurb->dev = serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\nexit: ;\r\n}\r\nstatic void usa26_glocont_callback(struct urb *urb)\r\n{\r\ndbg("%s", __func__);\r\n}\r\nstatic void usa28_indat_callback(struct urb *urb)\r\n{\r\nint err;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nunsigned char *data;\r\nstruct keyspan_port_private *p_priv;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nport = urb->context;\r\np_priv = usb_get_serial_port_data(port);\r\ndata = urb->transfer_buffer;\r\nif (urb != p_priv->in_urbs[p_priv->in_flip])\r\nreturn;\r\ndo {\r\nif (status) {\r\ndbg("%s - nonzero status: %x on endpoint %d.",\r\n__func__, status, usb_pipeendpoint(urb->pipe));\r\nreturn;\r\n}\r\nport = urb->context;\r\np_priv = usb_get_serial_port_data(port);\r\ndata = urb->transfer_buffer;\r\ntty =tty_port_tty_get(&port->port);\r\nif (tty && urb->actual_length) {\r\ntty_insert_flip_string(tty, data, urb->actual_length);\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\nurb->dev = port->serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)",\r\n__func__, err);\r\np_priv->in_flip ^= 1;\r\nurb = p_priv->in_urbs[p_priv->in_flip];\r\n} while (urb->status != -EINPROGRESS);\r\n}\r\nstatic void usa28_inack_callback(struct urb *urb)\r\n{\r\ndbg("%s", __func__);\r\n}\r\nstatic void usa28_outcont_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nport = urb->context;\r\np_priv = usb_get_serial_port_data(port);\r\nif (p_priv->resend_cont) {\r\ndbg("%s - sending setup", __func__);\r\nkeyspan_usa28_send_setup(port->serial, port,\r\np_priv->resend_cont - 1);\r\n}\r\n}\r\nstatic void usa28_instat_callback(struct urb *urb)\r\n{\r\nint err;\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct keyspan_usa28_portStatusMessage *msg;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nstruct tty_struct *tty;\r\nint old_dcd_state;\r\nint status = urb->status;\r\nserial = urb->context;\r\nif (status) {\r\ndbg("%s - nonzero status: %x", __func__, status);\r\nreturn;\r\n}\r\nif (urb->actual_length != sizeof(struct keyspan_usa28_portStatusMessage)) {\r\ndbg("%s - bad length %d", __func__, urb->actual_length);\r\ngoto exit;\r\n}\r\nmsg = (struct keyspan_usa28_portStatusMessage *)data;\r\nif (msg->port >= serial->num_ports) {\r\ndbg("%s - Unexpected port number %d", __func__, msg->port);\r\ngoto exit;\r\n}\r\nport = serial->port[msg->port];\r\np_priv = usb_get_serial_port_data(port);\r\nold_dcd_state = p_priv->dcd_state;\r\np_priv->cts_state = ((msg->cts) ? 1 : 0);\r\np_priv->dsr_state = ((msg->dsr) ? 1 : 0);\r\np_priv->dcd_state = ((msg->dcd) ? 1 : 0);\r\np_priv->ri_state = ((msg->ri) ? 1 : 0);\r\nif( old_dcd_state != p_priv->dcd_state && old_dcd_state) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && !C_CLOCAL(tty))\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nurb->dev = serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\nexit: ;\r\n}\r\nstatic void usa28_glocont_callback(struct urb *urb)\r\n{\r\ndbg("%s", __func__);\r\n}\r\nstatic void usa49_glocont_callback(struct urb *urb)\r\n{\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nint i;\r\ndbg("%s", __func__);\r\nserial = urb->context;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\np_priv = usb_get_serial_port_data(port);\r\nif (p_priv->resend_cont) {\r\ndbg("%s - sending setup", __func__);\r\nkeyspan_usa49_send_setup(serial, port,\r\np_priv->resend_cont - 1);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void usa49_instat_callback(struct urb *urb)\r\n{\r\nint err;\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct keyspan_usa49_portStatusMessage *msg;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nint old_dcd_state;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nserial = urb->context;\r\nif (status) {\r\ndbg("%s - nonzero status: %x", __func__, status);\r\nreturn;\r\n}\r\nif (urb->actual_length !=\r\nsizeof(struct keyspan_usa49_portStatusMessage)) {\r\ndbg("%s - bad length %d", __func__, urb->actual_length);\r\ngoto exit;\r\n}\r\nmsg = (struct keyspan_usa49_portStatusMessage *)data;\r\nif (msg->portNumber >= serial->num_ports) {\r\ndbg("%s - Unexpected port number %d",\r\n__func__, msg->portNumber);\r\ngoto exit;\r\n}\r\nport = serial->port[msg->portNumber];\r\np_priv = usb_get_serial_port_data(port);\r\nold_dcd_state = p_priv->dcd_state;\r\np_priv->cts_state = ((msg->cts) ? 1 : 0);\r\np_priv->dsr_state = ((msg->dsr) ? 1 : 0);\r\np_priv->dcd_state = ((msg->dcd) ? 1 : 0);\r\np_priv->ri_state = ((msg->ri) ? 1 : 0);\r\nif (old_dcd_state != p_priv->dcd_state && old_dcd_state) {\r\nstruct tty_struct *tty = tty_port_tty_get(&port->port);\r\nif (tty && !C_CLOCAL(tty))\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nurb->dev = serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\nexit: ;\r\n}\r\nstatic void usa49_inack_callback(struct urb *urb)\r\n{\r\ndbg("%s", __func__);\r\n}\r\nstatic void usa49_indat_callback(struct urb *urb)\r\n{\r\nint i, err;\r\nint endpoint;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nendpoint = usb_pipeendpoint(urb->pipe);\r\nif (status) {\r\ndbg("%s - nonzero status: %x on endpoint %d.", __func__,\r\nstatus, endpoint);\r\nreturn;\r\n}\r\nport = urb->context;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && urb->actual_length) {\r\nif ((data[0] & 0x80) == 0) {\r\ntty_insert_flip_string(tty, data + 1,\r\nurb->actual_length - 1);\r\n} else {\r\nfor (i = 0; i + 1 < urb->actual_length; i += 2) {\r\nint stat = data[i], flag = 0;\r\nif (stat & RXERROR_OVERRUN)\r\nflag |= TTY_OVERRUN;\r\nif (stat & RXERROR_FRAMING)\r\nflag |= TTY_FRAME;\r\nif (stat & RXERROR_PARITY)\r\nflag |= TTY_PARITY;\r\ntty_insert_flip_char(tty, data[i+1], flag);\r\n}\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\nurb->dev = port->serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\n}\r\nstatic void usa49wg_indat_callback(struct urb *urb)\r\n{\r\nint i, len, x, err;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nserial = urb->context;\r\nif (status) {\r\ndbg("%s - nonzero status: %x", __func__, status);\r\nreturn;\r\n}\r\ni = 0;\r\nlen = 0;\r\nif (urb->actual_length) {\r\nwhile (i < urb->actual_length) {\r\nif (data[i] >= serial->num_ports) {\r\ndbg("%s - Unexpected port number %d",\r\n__func__, data[i]);\r\nreturn;\r\n}\r\nport = serial->port[data[i++]];\r\ntty = tty_port_tty_get(&port->port);\r\nlen = data[i++];\r\nif ((data[i] & 0x80) == 0) {\r\ni++;\r\nfor (x = 1; x < len ; ++x)\r\ntty_insert_flip_char(tty, data[i++], 0);\r\n} else {\r\nfor (x = 0; x + 1 < len; x += 2) {\r\nint stat = data[i], flag = 0;\r\nif (stat & RXERROR_OVERRUN)\r\nflag |= TTY_OVERRUN;\r\nif (stat & RXERROR_FRAMING)\r\nflag |= TTY_FRAME;\r\nif (stat & RXERROR_PARITY)\r\nflag |= TTY_PARITY;\r\ntty_insert_flip_char(tty,\r\ndata[i+1], flag);\r\ni += 2;\r\n}\r\n}\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nurb->dev = serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\n}\r\nstatic void usa49_outcont_callback(struct urb *urb)\r\n{\r\ndbg("%s", __func__);\r\n}\r\nstatic void usa90_indat_callback(struct urb *urb)\r\n{\r\nint i, err;\r\nint endpoint;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nendpoint = usb_pipeendpoint(urb->pipe);\r\nif (status) {\r\ndbg("%s - nonzero status: %x on endpoint %d.",\r\n__func__, status, endpoint);\r\nreturn;\r\n}\r\nport = urb->context;\r\np_priv = usb_get_serial_port_data(port);\r\nif (urb->actual_length) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (p_priv->baud > 57600)\r\ntty_insert_flip_string(tty, data, urb->actual_length);\r\nelse {\r\nif ((data[0] & 0x80) == 0) {\r\nif (data[0] & RXERROR_OVERRUN)\r\nerr = TTY_OVERRUN;\r\nelse\r\nerr = 0;\r\nfor (i = 1; i < urb->actual_length ; ++i)\r\ntty_insert_flip_char(tty, data[i],\r\nerr);\r\n} else {\r\ndbg("%s - RX error!!!!", __func__);\r\nfor (i = 0; i + 1 < urb->actual_length; i += 2) {\r\nint stat = data[i], flag = 0;\r\nif (stat & RXERROR_OVERRUN)\r\nflag |= TTY_OVERRUN;\r\nif (stat & RXERROR_FRAMING)\r\nflag |= TTY_FRAME;\r\nif (stat & RXERROR_PARITY)\r\nflag |= TTY_PARITY;\r\ntty_insert_flip_char(tty, data[i+1],\r\nflag);\r\n}\r\n}\r\n}\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\nurb->dev = port->serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\n}\r\nstatic void usa90_instat_callback(struct urb *urb)\r\n{\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct keyspan_usa90_portStatusMessage *msg;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nstruct tty_struct *tty;\r\nint old_dcd_state, err;\r\nint status = urb->status;\r\nserial = urb->context;\r\nif (status) {\r\ndbg("%s - nonzero status: %x", __func__, status);\r\nreturn;\r\n}\r\nif (urb->actual_length < 14) {\r\ndbg("%s - %d byte report??", __func__, urb->actual_length);\r\ngoto exit;\r\n}\r\nmsg = (struct keyspan_usa90_portStatusMessage *)data;\r\nport = serial->port[0];\r\np_priv = usb_get_serial_port_data(port);\r\nold_dcd_state = p_priv->dcd_state;\r\np_priv->cts_state = ((msg->cts) ? 1 : 0);\r\np_priv->dsr_state = ((msg->dsr) ? 1 : 0);\r\np_priv->dcd_state = ((msg->dcd) ? 1 : 0);\r\np_priv->ri_state = ((msg->ri) ? 1 : 0);\r\nif (old_dcd_state != p_priv->dcd_state && old_dcd_state) {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && !C_CLOCAL(tty))\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nurb->dev = serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\nexit:\r\n;\r\n}\r\nstatic void usa90_outcont_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nport = urb->context;\r\np_priv = usb_get_serial_port_data(port);\r\nif (p_priv->resend_cont) {\r\ndbg("%s - sending setup", __func__);\r\nkeyspan_usa90_send_setup(port->serial, port,\r\np_priv->resend_cont - 1);\r\n}\r\n}\r\nstatic void usa67_instat_callback(struct urb *urb)\r\n{\r\nint err;\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct keyspan_usa67_portStatusMessage *msg;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nint old_dcd_state;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nserial = urb->context;\r\nif (status) {\r\ndbg("%s - nonzero status: %x", __func__, status);\r\nreturn;\r\n}\r\nif (urb->actual_length !=\r\nsizeof(struct keyspan_usa67_portStatusMessage)) {\r\ndbg("%s - bad length %d", __func__, urb->actual_length);\r\nreturn;\r\n}\r\nmsg = (struct keyspan_usa67_portStatusMessage *)data;\r\nif (msg->port >= serial->num_ports) {\r\ndbg("%s - Unexpected port number %d", __func__, msg->port);\r\nreturn;\r\n}\r\nport = serial->port[msg->port];\r\np_priv = usb_get_serial_port_data(port);\r\nold_dcd_state = p_priv->dcd_state;\r\np_priv->cts_state = ((msg->hskia_cts) ? 1 : 0);\r\np_priv->dcd_state = ((msg->gpia_dcd) ? 1 : 0);\r\nif (old_dcd_state != p_priv->dcd_state && old_dcd_state) {\r\nstruct tty_struct *tty = tty_port_tty_get(&port->port);\r\nif (tty && !C_CLOCAL(tty))\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nurb->dev = serial->dev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - resubmit read urb failed. (%d)", __func__, err);\r\n}\r\nstatic void usa67_glocont_callback(struct urb *urb)\r\n{\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nint i;\r\ndbg("%s", __func__);\r\nserial = urb->context;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\np_priv = usb_get_serial_port_data(port);\r\nif (p_priv->resend_cont) {\r\ndbg("%s - sending setup", __func__);\r\nkeyspan_usa67_send_setup(serial, port,\r\np_priv->resend_cont - 1);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int keyspan_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nint flip;\r\nint data_len;\r\nstruct urb *this_urb;\r\ndbg("%s", __func__);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = p_priv->device_details;\r\nif (d_details->msg_format == msg_usa90)\r\ndata_len = 64;\r\nelse\r\ndata_len = 63;\r\nflip = p_priv->out_flip;\r\nthis_urb = p_priv->out_urbs[flip];\r\nif (this_urb != NULL) {\r\nif (this_urb->status != -EINPROGRESS)\r\nreturn data_len;\r\nflip = (flip + 1) & d_details->outdat_endp_flip;\r\nthis_urb = p_priv->out_urbs[flip];\r\nif (this_urb != NULL) {\r\nif (this_urb->status != -EINPROGRESS)\r\nreturn data_len;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int keyspan_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct keyspan_port_private *p_priv;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct usb_serial *serial = port->serial;\r\nconst struct keyspan_device_details *d_details;\r\nint i, err;\r\nint baud_rate, device_port;\r\nstruct urb *urb;\r\nunsigned int cflag = 0;\r\ns_priv = usb_get_serial_data(serial);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = p_priv->device_details;\r\ndbg("%s - port%d.", __func__, port->number);\r\np_priv->rts_state = 1;\r\np_priv->dtr_state = 1;\r\np_priv->baud = 9600;\r\np_priv->old_baud = 0;\r\np_priv->old_cflag = 0;\r\np_priv->out_flip = 0;\r\np_priv->in_flip = 0;\r\nfor (i = 0; i < 2; i++) {\r\nurb = p_priv->in_urbs[i];\r\nif (urb == NULL)\r\ncontinue;\r\nurb->dev = serial->dev;\r\nusb_clear_halt(urb->dev, urb->pipe);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err != 0)\r\ndbg("%s - submit urb %d failed (%d)",\r\n__func__, i, err);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nurb = p_priv->out_urbs[i];\r\nif (urb == NULL)\r\ncontinue;\r\nurb->dev = serial->dev;\r\n}\r\ndevice_port = port->number - port->serial->minor;\r\nif (tty) {\r\ncflag = tty->termios->c_cflag;\r\nbaud_rate = tty_get_baud_rate(tty);\r\nif (baud_rate >= 0\r\n&& d_details->calculate_baud_rate(baud_rate, d_details->baudclk,\r\nNULL, NULL, NULL, device_port) == KEYSPAN_BAUD_RATE_OK) {\r\np_priv->baud = baud_rate;\r\n}\r\n}\r\np_priv->cflag = cflag;\r\np_priv->flow_control = (cflag & CRTSCTS)? flow_cts: flow_none;\r\nkeyspan_send_setup(port, 1);\r\nreturn 0;\r\n}\r\nstatic inline void stop_urb(struct urb *urb)\r\n{\r\nif (urb && urb->status == -EINPROGRESS)\r\nusb_kill_urb(urb);\r\n}\r\nstatic void keyspan_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct keyspan_port_private *p_priv = usb_get_serial_port_data(port);\r\np_priv->rts_state = on;\r\np_priv->dtr_state = on;\r\nkeyspan_send_setup(port, 0);\r\n}\r\nstatic void keyspan_close(struct usb_serial_port *port)\r\n{\r\nint i;\r\nstruct usb_serial *serial = port->serial;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\np_priv = usb_get_serial_port_data(port);\r\np_priv->rts_state = 0;\r\np_priv->dtr_state = 0;\r\nif (serial->dev) {\r\nkeyspan_send_setup(port, 2);\r\nmdelay(100);\r\n}\r\np_priv->out_flip = 0;\r\np_priv->in_flip = 0;\r\nif (serial->dev) {\r\nstop_urb(p_priv->inack_urb);\r\nfor (i = 0; i < 2; i++) {\r\nstop_urb(p_priv->in_urbs[i]);\r\nstop_urb(p_priv->out_urbs[i]);\r\n}\r\n}\r\n}\r\nstatic int keyspan_fake_startup(struct usb_serial *serial)\r\n{\r\nint response;\r\nconst struct ihex_binrec *record;\r\nchar *fw_name;\r\nconst struct firmware *fw;\r\ndbg("Keyspan startup version %04x product %04x",\r\nle16_to_cpu(serial->dev->descriptor.bcdDevice),\r\nle16_to_cpu(serial->dev->descriptor.idProduct));\r\nif ((le16_to_cpu(serial->dev->descriptor.bcdDevice) & 0x8000)\r\n!= 0x8000) {\r\ndbg("Firmware already loaded. Quitting.");\r\nreturn 1;\r\n}\r\nswitch (le16_to_cpu(serial->dev->descriptor.idProduct)) {\r\ncase keyspan_usa28_pre_product_id:\r\nfw_name = "keyspan/usa28.fw";\r\nbreak;\r\ncase keyspan_usa28x_pre_product_id:\r\nfw_name = "keyspan/usa28x.fw";\r\nbreak;\r\ncase keyspan_usa28xa_pre_product_id:\r\nfw_name = "keyspan/usa28xa.fw";\r\nbreak;\r\ncase keyspan_usa28xb_pre_product_id:\r\nfw_name = "keyspan/usa28xb.fw";\r\nbreak;\r\ncase keyspan_usa19_pre_product_id:\r\nfw_name = "keyspan/usa19.fw";\r\nbreak;\r\ncase keyspan_usa19qi_pre_product_id:\r\nfw_name = "keyspan/usa19qi.fw";\r\nbreak;\r\ncase keyspan_mpr_pre_product_id:\r\nfw_name = "keyspan/mpr.fw";\r\nbreak;\r\ncase keyspan_usa19qw_pre_product_id:\r\nfw_name = "keyspan/usa19qw.fw";\r\nbreak;\r\ncase keyspan_usa18x_pre_product_id:\r\nfw_name = "keyspan/usa18x.fw";\r\nbreak;\r\ncase keyspan_usa19w_pre_product_id:\r\nfw_name = "keyspan/usa19w.fw";\r\nbreak;\r\ncase keyspan_usa49w_pre_product_id:\r\nfw_name = "keyspan/usa49w.fw";\r\nbreak;\r\ncase keyspan_usa49wlc_pre_product_id:\r\nfw_name = "keyspan/usa49wlc.fw";\r\nbreak;\r\ndefault:\r\ndev_err(&serial->dev->dev, "Unknown product ID (%04x)\n",\r\nle16_to_cpu(serial->dev->descriptor.idProduct));\r\nreturn 1;\r\n}\r\nif (request_ihex_firmware(&fw, fw_name, &serial->dev->dev)) {\r\ndev_err(&serial->dev->dev, "Required keyspan firmware image (%s) unavailable.\n", fw_name);\r\nreturn(1);\r\n}\r\ndbg("Uploading Keyspan %s firmware.", fw_name);\r\nresponse = ezusb_set_reset(serial, 1);\r\nrecord = (const struct ihex_binrec *)fw->data;\r\nwhile (record) {\r\nresponse = ezusb_writememory(serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa0);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "ezusb_writememory failed for Keyspan firmware (%d %04X %p %d)\n",\r\nresponse, be32_to_cpu(record->addr),\r\nrecord->data, be16_to_cpu(record->len));\r\nbreak;\r\n}\r\nrecord = ihex_next_binrec(record);\r\n}\r\nrelease_firmware(fw);\r\nresponse = ezusb_set_reset(serial, 0);\r\nreturn 1;\r\n}\r\nstatic struct usb_endpoint_descriptor const *find_ep(struct usb_serial const *serial,\r\nint endpoint)\r\n{\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *ep;\r\nint i;\r\niface_desc = serial->interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nep = &iface_desc->endpoint[i].desc;\r\nif (ep->bEndpointAddress == endpoint)\r\nreturn ep;\r\n}\r\ndev_warn(&serial->interface->dev, "found no endpoint descriptor for "\r\n"endpoint %x\n", endpoint);\r\nreturn NULL;\r\n}\r\nstatic struct urb *keyspan_setup_urb(struct usb_serial *serial, int endpoint,\r\nint dir, void *ctx, char *buf, int len,\r\nvoid (*callback)(struct urb *))\r\n{\r\nstruct urb *urb;\r\nstruct usb_endpoint_descriptor const *ep_desc;\r\nchar const *ep_type_name;\r\nif (endpoint == -1)\r\nreturn NULL;\r\ndbg("%s - alloc for endpoint %d.", __func__, endpoint);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndbg("%s - alloc for endpoint %d failed.", __func__, endpoint);\r\nreturn NULL;\r\n}\r\nif (endpoint == 0) {\r\nreturn urb;\r\n}\r\nep_desc = find_ep(serial, endpoint);\r\nif (!ep_desc) {\r\nreturn urb;\r\n}\r\nif (usb_endpoint_xfer_int(ep_desc)) {\r\nep_type_name = "INT";\r\nusb_fill_int_urb(urb, serial->dev,\r\nusb_sndintpipe(serial->dev, endpoint) | dir,\r\nbuf, len, callback, ctx,\r\nep_desc->bInterval);\r\n} else if (usb_endpoint_xfer_bulk(ep_desc)) {\r\nep_type_name = "BULK";\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev, endpoint) | dir,\r\nbuf, len, callback, ctx);\r\n} else {\r\ndev_warn(&serial->interface->dev,\r\n"unsupported endpoint type %x\n",\r\nusb_endpoint_type(ep_desc));\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\ndbg("%s - using urb %p for %s endpoint %x",\r\n__func__, urb, ep_type_name, endpoint);\r\nreturn urb;\r\n}\r\nstatic void keyspan_setup_urbs(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct keyspan_serial_private *s_priv;\r\nconst struct keyspan_device_details *d_details;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_port_private *p_priv;\r\nstruct callbacks *cback;\r\nint endp;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\nd_details = s_priv->device_details;\r\ncback = &keyspan_callbacks[d_details->msg_format];\r\ns_priv->instat_urb = keyspan_setup_urb\r\n(serial, d_details->instat_endpoint, USB_DIR_IN,\r\nserial, s_priv->instat_buf, INSTAT_BUFLEN,\r\ncback->instat_callback);\r\ns_priv->indat_urb = keyspan_setup_urb\r\n(serial, d_details->indat_endpoint, USB_DIR_IN,\r\nserial, s_priv->indat_buf, INDAT49W_BUFLEN,\r\nusa49wg_indat_callback);\r\ns_priv->glocont_urb = keyspan_setup_urb\r\n(serial, d_details->glocont_endpoint, USB_DIR_OUT,\r\nserial, s_priv->glocont_buf, GLOCONT_BUFLEN,\r\ncback->glocont_callback);\r\nfor (i = 0; i < d_details->num_ports; i++) {\r\nport = serial->port[i];\r\np_priv = usb_get_serial_port_data(port);\r\nendp = d_details->indat_endpoints[i];\r\nfor (j = 0; j <= d_details->indat_endp_flip; ++j, ++endp) {\r\np_priv->in_urbs[j] = keyspan_setup_urb\r\n(serial, endp, USB_DIR_IN, port,\r\np_priv->in_buffer[j], 64,\r\ncback->indat_callback);\r\n}\r\nfor (; j < 2; ++j)\r\np_priv->in_urbs[j] = NULL;\r\nendp = d_details->outdat_endpoints[i];\r\nfor (j = 0; j <= d_details->outdat_endp_flip; ++j, ++endp) {\r\np_priv->out_urbs[j] = keyspan_setup_urb\r\n(serial, endp, USB_DIR_OUT, port,\r\np_priv->out_buffer[j], 64,\r\ncback->outdat_callback);\r\n}\r\nfor (; j < 2; ++j)\r\np_priv->out_urbs[j] = NULL;\r\np_priv->inack_urb = keyspan_setup_urb\r\n(serial, d_details->inack_endpoints[i], USB_DIR_IN,\r\nport, p_priv->inack_buffer, 1, cback->inack_callback);\r\np_priv->outcont_urb = keyspan_setup_urb\r\n(serial, d_details->outcont_endpoints[i], USB_DIR_OUT,\r\nport, p_priv->outcont_buffer, 64,\r\ncback->outcont_callback);\r\n}\r\n}\r\nstatic int keyspan_usa19_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,\r\nu8 *rate_low, u8 *prescaler, int portnum)\r\n{\r\nu32 b16,\r\ndiv,\r\ncnt;\r\ndbg("%s - %d.", __func__, baud_rate);\r\nb16 = baud_rate * 16L;\r\nif (b16 == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nif (baud_rate > 57600)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\ndiv = baudclk / b16;\r\nif (div == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nelse\r\ncnt = 0 - div;\r\nif (div > 0xffff)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nif (rate_low)\r\n*rate_low = (u8) (cnt & 0xff);\r\nif (rate_hi)\r\n*rate_hi = (u8) ((cnt >> 8) & 0xff);\r\nif (rate_low && rate_hi)\r\ndbg("%s - %d %02x %02x.",\r\n__func__, baud_rate, *rate_hi, *rate_low);\r\nreturn KEYSPAN_BAUD_RATE_OK;\r\n}\r\nstatic int keyspan_usa19hs_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,\r\nu8 *rate_low, u8 *prescaler, int portnum)\r\n{\r\nu32 b16,\r\ndiv;\r\ndbg("%s - %d.", __func__, baud_rate);\r\nb16 = baud_rate * 16L;\r\nif (b16 == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\ndiv = baudclk / b16;\r\nif (div == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nif (div > 0xffff)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nif (rate_low)\r\n*rate_low = (u8) (div & 0xff);\r\nif (rate_hi)\r\n*rate_hi = (u8) ((div >> 8) & 0xff);\r\nif (rate_low && rate_hi)\r\ndbg("%s - %d %02x %02x.",\r\n__func__, baud_rate, *rate_hi, *rate_low);\r\nreturn KEYSPAN_BAUD_RATE_OK;\r\n}\r\nstatic int keyspan_usa19w_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,\r\nu8 *rate_low, u8 *prescaler, int portnum)\r\n{\r\nu32 b16,\r\nclk,\r\ndiv,\r\nres,\r\ndiff,\r\nsmallest_diff;\r\nu8 best_prescaler;\r\nint i;\r\ndbg("%s - %d.", __func__, baud_rate);\r\nb16 = baud_rate * 16L;\r\nif (b16 == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nsmallest_diff = 0xffffffff;\r\nbest_prescaler = 0;\r\nfor (i = 8; i <= 0xff; ++i) {\r\nclk = (baudclk * 8) / (u32) i;\r\ndiv = clk / b16;\r\nif (div == 0)\r\ncontinue;\r\nres = clk / div;\r\ndiff = (res > b16) ? (res-b16) : (b16-res);\r\nif (diff < smallest_diff) {\r\nbest_prescaler = i;\r\nsmallest_diff = diff;\r\n}\r\n}\r\nif (best_prescaler == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nclk = (baudclk * 8) / (u32) best_prescaler;\r\ndiv = clk / b16;\r\nif (rate_low)\r\n*rate_low = (u8) (div & 0xff);\r\nif (rate_hi)\r\n*rate_hi = (u8) ((div >> 8) & 0xff);\r\nif (prescaler) {\r\n*prescaler = best_prescaler;\r\n}\r\nreturn KEYSPAN_BAUD_RATE_OK;\r\n}\r\nstatic int keyspan_usa28_calc_baud(u32 baud_rate, u32 baudclk, u8 *rate_hi,\r\nu8 *rate_low, u8 *prescaler, int portnum)\r\n{\r\nu32 b16,\r\ndiv,\r\ncnt;\r\ndbg("%s - %d.", __func__, baud_rate);\r\nb16 = baud_rate * 16L;\r\nif (b16 == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\ndiv = KEYSPAN_USA28_BAUDCLK / b16;\r\nif (div == 0)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\nelse\r\ncnt = 0 - div;\r\nif (portnum == 0) {\r\nif (div > 0xffff)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\n} else {\r\nif (portnum == 1) {\r\nif (div > 0xff)\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\n} else\r\nreturn KEYSPAN_INVALID_BAUD_RATE;\r\n}\r\nif (rate_low)\r\n*rate_low = (u8) (cnt & 0xff);\r\nif (rate_hi)\r\n*rate_hi = (u8) ((cnt >> 8) & 0xff);\r\ndbg("%s - %d OK.", __func__, baud_rate);\r\nreturn KEYSPAN_BAUD_RATE_OK;\r\n}\r\nstatic int keyspan_usa26_send_setup(struct usb_serial *serial,\r\nstruct usb_serial_port *port,\r\nint reset_port)\r\n{\r\nstruct keyspan_usa26_portControlMessage msg;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nint outcont_urb;\r\nstruct urb *this_urb;\r\nint device_port, err;\r\ndbg("%s reset=%d", __func__, reset_port);\r\ns_priv = usb_get_serial_data(serial);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = s_priv->device_details;\r\ndevice_port = port->number - port->serial->minor;\r\noutcont_urb = d_details->outcont_endpoints[port->number];\r\nthis_urb = p_priv->outcont_urb;\r\ndbg("%s - endpoint %d", __func__, usb_pipeendpoint(this_urb->pipe));\r\nif (this_urb == NULL) {\r\ndbg("%s - oops no urb.", __func__);\r\nreturn -1;\r\n}\r\nif ((reset_port + 1) > p_priv->resend_cont)\r\np_priv->resend_cont = reset_port + 1;\r\nif (this_urb->status == -EINPROGRESS) {\r\nmdelay(5);\r\nreturn -1;\r\n}\r\nmemset(&msg, 0, sizeof(struct keyspan_usa26_portControlMessage));\r\nif (p_priv->old_baud != p_priv->baud) {\r\np_priv->old_baud = p_priv->baud;\r\nmsg.setClocking = 0xff;\r\nif (d_details->calculate_baud_rate\r\n(p_priv->baud, d_details->baudclk, &msg.baudHi,\r\n&msg.baudLo, &msg.prescaler, device_port) == KEYSPAN_INVALID_BAUD_RATE) {\r\ndbg("%s - Invalid baud rate %d requested, using 9600.",\r\n__func__, p_priv->baud);\r\nmsg.baudLo = 0;\r\nmsg.baudHi = 125;\r\nmsg.prescaler = 10;\r\n}\r\nmsg.setPrescaler = 0xff;\r\n}\r\nmsg.lcr = (p_priv->cflag & CSTOPB)? STOPBITS_678_2: STOPBITS_5678_1;\r\nswitch (p_priv->cflag & CSIZE) {\r\ncase CS5:\r\nmsg.lcr |= USA_DATABITS_5;\r\nbreak;\r\ncase CS6:\r\nmsg.lcr |= USA_DATABITS_6;\r\nbreak;\r\ncase CS7:\r\nmsg.lcr |= USA_DATABITS_7;\r\nbreak;\r\ncase CS8:\r\nmsg.lcr |= USA_DATABITS_8;\r\nbreak;\r\n}\r\nif (p_priv->cflag & PARENB) {\r\nmsg.lcr |= (p_priv->cflag & PARODD)?\r\nUSA_PARITY_ODD : USA_PARITY_EVEN;\r\n}\r\nmsg.setLcr = 0xff;\r\nmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\r\nmsg.xonFlowControl = 0;\r\nmsg.setFlowControl = 0xff;\r\nmsg.forwardingLength = 16;\r\nmsg.xonChar = 17;\r\nmsg.xoffChar = 19;\r\nif (reset_port == 1) {\r\nmsg._txOn = 1;\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 1;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0xff;\r\n}\r\nelse if (reset_port == 2) {\r\nmsg._txOn = 0;\r\nmsg._txOff = 1;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 1;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0;\r\n}\r\nelse {\r\nmsg._txOn = (!p_priv->break_on);\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = (p_priv->break_on);\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 0;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0x0;\r\n}\r\nmsg.setTxTriState_setRts = 0xff;\r\nmsg.txTriState_rts = p_priv->rts_state;\r\nmsg.setHskoa_setDtr = 0xff;\r\nmsg.hskoa_dtr = p_priv->dtr_state;\r\np_priv->resend_cont = 0;\r\nmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\r\nthis_urb->transfer_buffer_length = sizeof(msg);\r\nthis_urb->dev = serial->dev;\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - usb_submit_urb(setup) failed (%d)", __func__, err);\r\n#if 0\r\nelse {\r\ndbg("%s - usb_submit_urb(%d) OK %d bytes (end %d)", __func__\r\noutcont_urb, this_urb->transfer_buffer_length,\r\nusb_pipeendpoint(this_urb->pipe));\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int keyspan_usa28_send_setup(struct usb_serial *serial,\r\nstruct usb_serial_port *port,\r\nint reset_port)\r\n{\r\nstruct keyspan_usa28_portControlMessage msg;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nstruct urb *this_urb;\r\nint device_port, err;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = s_priv->device_details;\r\ndevice_port = port->number - port->serial->minor;\r\nthis_urb = p_priv->outcont_urb;\r\nif (this_urb == NULL) {\r\ndbg("%s - oops no urb.", __func__);\r\nreturn -1;\r\n}\r\nif ((reset_port + 1) > p_priv->resend_cont)\r\np_priv->resend_cont = reset_port + 1;\r\nif (this_urb->status == -EINPROGRESS) {\r\ndbg("%s already writing", __func__);\r\nmdelay(5);\r\nreturn -1;\r\n}\r\nmemset(&msg, 0, sizeof(struct keyspan_usa28_portControlMessage));\r\nmsg.setBaudRate = 1;\r\nif (d_details->calculate_baud_rate(p_priv->baud, d_details->baudclk,\r\n&msg.baudHi, &msg.baudLo, NULL, device_port) == KEYSPAN_INVALID_BAUD_RATE) {\r\ndbg("%s - Invalid baud rate requested %d.",\r\n__func__, p_priv->baud);\r\nmsg.baudLo = 0xff;\r\nmsg.baudHi = 0xb2;\r\n}\r\nmsg.parity = 0;\r\nmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\r\nmsg.xonFlowControl = 0;\r\nmsg.rts = p_priv->rts_state;\r\nmsg.dtr = p_priv->dtr_state;\r\nmsg.forwardingLength = 16;\r\nmsg.forwardMs = 10;\r\nmsg.breakThreshold = 45;\r\nmsg.xonChar = 17;\r\nmsg.xoffChar = 19;\r\nif (reset_port == 1) {\r\nmsg._txOn = 1;\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txForceXoff = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 1;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0xff;\r\n}\r\nelse if (reset_port == 2) {\r\nmsg._txOn = 0;\r\nmsg._txOff = 1;\r\nmsg.txFlush = 0;\r\nmsg.txForceXoff = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 1;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0;\r\n}\r\nelse {\r\nmsg._txOn = (!p_priv->break_on);\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txForceXoff = 0;\r\nmsg.txBreak = (p_priv->break_on);\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 0;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0x0;\r\n}\r\np_priv->resend_cont = 0;\r\nmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\r\nthis_urb->transfer_buffer_length = sizeof(msg);\r\nthis_urb->dev = serial->dev;\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - usb_submit_urb(setup) failed", __func__);\r\n#if 0\r\nelse {\r\ndbg("%s - usb_submit_urb(setup) OK %d bytes", __func__,\r\nthis_urb->transfer_buffer_length);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int keyspan_usa49_send_setup(struct usb_serial *serial,\r\nstruct usb_serial_port *port,\r\nint reset_port)\r\n{\r\nstruct keyspan_usa49_portControlMessage msg;\r\nstruct usb_ctrlrequest *dr = NULL;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nstruct urb *this_urb;\r\nint err, device_port;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = s_priv->device_details;\r\nthis_urb = s_priv->glocont_urb;\r\ndevice_port = port->number - port->serial->minor;\r\nif (this_urb == NULL) {\r\ndbg("%s - oops no urb for port %d.", __func__, port->number);\r\nreturn -1;\r\n}\r\ndbg("%s - endpoint %d port %d (%d)",\r\n__func__, usb_pipeendpoint(this_urb->pipe),\r\nport->number, device_port);\r\nif ((reset_port + 1) > p_priv->resend_cont)\r\np_priv->resend_cont = reset_port + 1;\r\nif (this_urb->status == -EINPROGRESS) {\r\nmdelay(5);\r\nreturn -1;\r\n}\r\nmemset(&msg, 0, sizeof(struct keyspan_usa49_portControlMessage));\r\nmsg.portNumber = device_port;\r\nif (p_priv->old_baud != p_priv->baud) {\r\np_priv->old_baud = p_priv->baud;\r\nmsg.setClocking = 0xff;\r\nif (d_details->calculate_baud_rate\r\n(p_priv->baud, d_details->baudclk, &msg.baudHi,\r\n&msg.baudLo, &msg.prescaler, device_port) == KEYSPAN_INVALID_BAUD_RATE) {\r\ndbg("%s - Invalid baud rate %d requested, using 9600.",\r\n__func__, p_priv->baud);\r\nmsg.baudLo = 0;\r\nmsg.baudHi = 125;\r\nmsg.prescaler = 10;\r\n}\r\n}\r\nmsg.lcr = (p_priv->cflag & CSTOPB)? STOPBITS_678_2: STOPBITS_5678_1;\r\nswitch (p_priv->cflag & CSIZE) {\r\ncase CS5:\r\nmsg.lcr |= USA_DATABITS_5;\r\nbreak;\r\ncase CS6:\r\nmsg.lcr |= USA_DATABITS_6;\r\nbreak;\r\ncase CS7:\r\nmsg.lcr |= USA_DATABITS_7;\r\nbreak;\r\ncase CS8:\r\nmsg.lcr |= USA_DATABITS_8;\r\nbreak;\r\n}\r\nif (p_priv->cflag & PARENB) {\r\nmsg.lcr |= (p_priv->cflag & PARODD)?\r\nUSA_PARITY_ODD : USA_PARITY_EVEN;\r\n}\r\nmsg.setLcr = 0xff;\r\nmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\r\nmsg.xonFlowControl = 0;\r\nmsg.setFlowControl = 0xff;\r\nmsg.forwardingLength = 16;\r\nmsg.xonChar = 17;\r\nmsg.xoffChar = 19;\r\nif (reset_port == 1) {\r\nmsg._txOn = 1;\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 1;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0xff;\r\nmsg.enablePort = 1;\r\nmsg.disablePort = 0;\r\n}\r\nelse if (reset_port == 2) {\r\nmsg._txOn = 0;\r\nmsg._txOff = 1;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 1;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0;\r\nmsg.enablePort = 0;\r\nmsg.disablePort = 1;\r\n}\r\nelse {\r\nmsg._txOn = (!p_priv->break_on);\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = (p_priv->break_on);\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 0;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0x0;\r\nmsg.enablePort = 0;\r\nmsg.disablePort = 0;\r\n}\r\nmsg.setRts = 0xff;\r\nmsg.rts = p_priv->rts_state;\r\nmsg.setDtr = 0xff;\r\nmsg.dtr = p_priv->dtr_state;\r\np_priv->resend_cont = 0;\r\nif (d_details->product_id == keyspan_usa49wg_product_id) {\r\ndr = (void *)(s_priv->ctrl_buf);\r\ndr->bRequestType = USB_TYPE_VENDOR | USB_DIR_OUT;\r\ndr->bRequest = 0xB0; ;\r\ndr->wValue = 0;\r\ndr->wIndex = 0;\r\ndr->wLength = cpu_to_le16(sizeof(msg));\r\nmemcpy(s_priv->glocont_buf, &msg, sizeof(msg));\r\nusb_fill_control_urb(this_urb, serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\n(unsigned char *)dr, s_priv->glocont_buf,\r\nsizeof(msg), usa49_glocont_callback, serial);\r\n} else {\r\nmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\r\nthis_urb->transfer_buffer_length = sizeof(msg);\r\nthis_urb->dev = serial->dev;\r\n}\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - usb_submit_urb(setup) failed (%d)", __func__, err);\r\n#if 0\r\nelse {\r\ndbg("%s - usb_submit_urb(%d) OK %d bytes (end %d)", __func__,\r\noutcont_urb, this_urb->transfer_buffer_length,\r\nusb_pipeendpoint(this_urb->pipe));\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int keyspan_usa90_send_setup(struct usb_serial *serial,\r\nstruct usb_serial_port *port,\r\nint reset_port)\r\n{\r\nstruct keyspan_usa90_portControlMessage msg;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nstruct urb *this_urb;\r\nint err;\r\nu8 prescaler;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = s_priv->device_details;\r\nthis_urb = p_priv->outcont_urb;\r\nif (this_urb == NULL) {\r\ndbg("%s - oops no urb.", __func__);\r\nreturn -1;\r\n}\r\nif ((reset_port + 1) > p_priv->resend_cont)\r\np_priv->resend_cont = reset_port + 1;\r\nif (this_urb->status == -EINPROGRESS) {\r\ndbg("%s already writing", __func__);\r\nmdelay(5);\r\nreturn -1;\r\n}\r\nmemset(&msg, 0, sizeof(struct keyspan_usa90_portControlMessage));\r\nif (p_priv->old_baud != p_priv->baud) {\r\np_priv->old_baud = p_priv->baud;\r\nmsg.setClocking = 0x01;\r\nif (d_details->calculate_baud_rate\r\n(p_priv->baud, d_details->baudclk, &msg.baudHi,\r\n&msg.baudLo, &prescaler, 0) == KEYSPAN_INVALID_BAUD_RATE) {\r\ndbg("%s - Invalid baud rate %d requested, using 9600.",\r\n__func__, p_priv->baud);\r\np_priv->baud = 9600;\r\nd_details->calculate_baud_rate(p_priv->baud, d_details->baudclk,\r\n&msg.baudHi, &msg.baudLo, &prescaler, 0);\r\n}\r\nmsg.setRxMode = 1;\r\nmsg.setTxMode = 1;\r\n}\r\nif (p_priv->baud > 57600) {\r\nmsg.rxMode = RXMODE_DMA;\r\nmsg.txMode = TXMODE_DMA;\r\n} else {\r\nmsg.rxMode = RXMODE_BYHAND;\r\nmsg.txMode = TXMODE_BYHAND;\r\n}\r\nmsg.lcr = (p_priv->cflag & CSTOPB)? STOPBITS_678_2: STOPBITS_5678_1;\r\nswitch (p_priv->cflag & CSIZE) {\r\ncase CS5:\r\nmsg.lcr |= USA_DATABITS_5;\r\nbreak;\r\ncase CS6:\r\nmsg.lcr |= USA_DATABITS_6;\r\nbreak;\r\ncase CS7:\r\nmsg.lcr |= USA_DATABITS_7;\r\nbreak;\r\ncase CS8:\r\nmsg.lcr |= USA_DATABITS_8;\r\nbreak;\r\n}\r\nif (p_priv->cflag & PARENB) {\r\nmsg.lcr |= (p_priv->cflag & PARODD)?\r\nUSA_PARITY_ODD : USA_PARITY_EVEN;\r\n}\r\nif (p_priv->old_cflag != p_priv->cflag) {\r\np_priv->old_cflag = p_priv->cflag;\r\nmsg.setLcr = 0x01;\r\n}\r\nif (p_priv->flow_control == flow_cts)\r\nmsg.txFlowControl = TXFLOW_CTS;\r\nmsg.setTxFlowControl = 0x01;\r\nmsg.setRxFlowControl = 0x01;\r\nmsg.rxForwardingLength = 16;\r\nmsg.rxForwardingTimeout = 16;\r\nmsg.txAckSetting = 0;\r\nmsg.xonChar = 17;\r\nmsg.xoffChar = 19;\r\nif (reset_port == 1) {\r\nmsg.portEnabled = 1;\r\nmsg.rxFlush = 1;\r\nmsg.txBreak = (p_priv->break_on);\r\n}\r\nelse if (reset_port == 2)\r\nmsg.portEnabled = 0;\r\nelse {\r\nmsg.portEnabled = 1;\r\nmsg.txBreak = (p_priv->break_on);\r\n}\r\nmsg.setRts = 0x01;\r\nmsg.rts = p_priv->rts_state;\r\nmsg.setDtr = 0x01;\r\nmsg.dtr = p_priv->dtr_state;\r\np_priv->resend_cont = 0;\r\nmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\r\nthis_urb->transfer_buffer_length = sizeof(msg);\r\nthis_urb->dev = serial->dev;\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - usb_submit_urb(setup) failed (%d)", __func__, err);\r\nreturn 0;\r\n}\r\nstatic int keyspan_usa67_send_setup(struct usb_serial *serial,\r\nstruct usb_serial_port *port,\r\nint reset_port)\r\n{\r\nstruct keyspan_usa67_portControlMessage msg;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\nstruct urb *this_urb;\r\nint err, device_port;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\np_priv = usb_get_serial_port_data(port);\r\nd_details = s_priv->device_details;\r\nthis_urb = s_priv->glocont_urb;\r\ndevice_port = port->number - port->serial->minor;\r\nif (this_urb == NULL) {\r\ndbg("%s - oops no urb for port %d.", __func__,\r\nport->number);\r\nreturn -1;\r\n}\r\nif ((reset_port + 1) > p_priv->resend_cont)\r\np_priv->resend_cont = reset_port + 1;\r\nif (this_urb->status == -EINPROGRESS) {\r\nmdelay(5);\r\nreturn -1;\r\n}\r\nmemset(&msg, 0, sizeof(struct keyspan_usa67_portControlMessage));\r\nmsg.port = device_port;\r\nif (p_priv->old_baud != p_priv->baud) {\r\np_priv->old_baud = p_priv->baud;\r\nmsg.setClocking = 0xff;\r\nif (d_details->calculate_baud_rate\r\n(p_priv->baud, d_details->baudclk, &msg.baudHi,\r\n&msg.baudLo, &msg.prescaler, device_port) == KEYSPAN_INVALID_BAUD_RATE) {\r\ndbg("%s - Invalid baud rate %d requested, using 9600.",\r\n__func__, p_priv->baud);\r\nmsg.baudLo = 0;\r\nmsg.baudHi = 125;\r\nmsg.prescaler = 10;\r\n}\r\nmsg.setPrescaler = 0xff;\r\n}\r\nmsg.lcr = (p_priv->cflag & CSTOPB) ? STOPBITS_678_2 : STOPBITS_5678_1;\r\nswitch (p_priv->cflag & CSIZE) {\r\ncase CS5:\r\nmsg.lcr |= USA_DATABITS_5;\r\nbreak;\r\ncase CS6:\r\nmsg.lcr |= USA_DATABITS_6;\r\nbreak;\r\ncase CS7:\r\nmsg.lcr |= USA_DATABITS_7;\r\nbreak;\r\ncase CS8:\r\nmsg.lcr |= USA_DATABITS_8;\r\nbreak;\r\n}\r\nif (p_priv->cflag & PARENB) {\r\nmsg.lcr |= (p_priv->cflag & PARODD)?\r\nUSA_PARITY_ODD : USA_PARITY_EVEN;\r\n}\r\nmsg.setLcr = 0xff;\r\nmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\r\nmsg.xonFlowControl = 0;\r\nmsg.setFlowControl = 0xff;\r\nmsg.forwardingLength = 16;\r\nmsg.xonChar = 17;\r\nmsg.xoffChar = 19;\r\nif (reset_port == 1) {\r\nmsg._txOn = 1;\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 1;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0xff;\r\n} else if (reset_port == 2) {\r\nmsg._txOn = 0;\r\nmsg._txOff = 1;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = 0;\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 1;\r\nmsg.rxFlush = 1;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0;\r\n} else {\r\nmsg._txOn = (!p_priv->break_on);\r\nmsg._txOff = 0;\r\nmsg.txFlush = 0;\r\nmsg.txBreak = (p_priv->break_on);\r\nmsg.rxOn = 0;\r\nmsg.rxOff = 0;\r\nmsg.rxFlush = 0;\r\nmsg.rxForward = 0;\r\nmsg.returnStatus = 0;\r\nmsg.resetDataToggle = 0x0;\r\n}\r\nmsg.setTxTriState_setRts = 0xff;\r\nmsg.txTriState_rts = p_priv->rts_state;\r\nmsg.setHskoa_setDtr = 0xff;\r\nmsg.hskoa_dtr = p_priv->dtr_state;\r\np_priv->resend_cont = 0;\r\nmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\r\nthis_urb->transfer_buffer_length = sizeof(msg);\r\nthis_urb->dev = serial->dev;\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err != 0)\r\ndbg("%s - usb_submit_urb(setup) failed (%d)", __func__,\r\nerr);\r\nreturn 0;\r\n}\r\nstatic void keyspan_send_setup(struct usb_serial_port *port, int reset_port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct keyspan_serial_private *s_priv;\r\nconst struct keyspan_device_details *d_details;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\nd_details = s_priv->device_details;\r\nswitch (d_details->msg_format) {\r\ncase msg_usa26:\r\nkeyspan_usa26_send_setup(serial, port, reset_port);\r\nbreak;\r\ncase msg_usa28:\r\nkeyspan_usa28_send_setup(serial, port, reset_port);\r\nbreak;\r\ncase msg_usa49:\r\nkeyspan_usa49_send_setup(serial, port, reset_port);\r\nbreak;\r\ncase msg_usa90:\r\nkeyspan_usa90_send_setup(serial, port, reset_port);\r\nbreak;\r\ncase msg_usa67:\r\nkeyspan_usa67_send_setup(serial, port, reset_port);\r\nbreak;\r\n}\r\n}\r\nstatic int keyspan_startup(struct usb_serial *serial)\r\n{\r\nint i, err;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\nconst struct keyspan_device_details *d_details;\r\ndbg("%s", __func__);\r\nfor (i = 0; (d_details = keyspan_devices[i]) != NULL; ++i)\r\nif (d_details->product_id ==\r\nle16_to_cpu(serial->dev->descriptor.idProduct))\r\nbreak;\r\nif (d_details == NULL) {\r\ndev_err(&serial->dev->dev, "%s - unknown product id %x\n",\r\n__func__, le16_to_cpu(serial->dev->descriptor.idProduct));\r\nreturn 1;\r\n}\r\ns_priv = kzalloc(sizeof(struct keyspan_serial_private), GFP_KERNEL);\r\nif (!s_priv) {\r\ndbg("%s - kmalloc for keyspan_serial_private failed.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\ns_priv->device_details = d_details;\r\nusb_set_serial_data(serial, s_priv);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\np_priv = kzalloc(sizeof(struct keyspan_port_private),\r\nGFP_KERNEL);\r\nif (!p_priv) {\r\ndbg("%s - kmalloc for keyspan_port_private (%d) failed!.", __func__, i);\r\nreturn 1;\r\n}\r\np_priv->device_details = d_details;\r\nusb_set_serial_port_data(port, p_priv);\r\n}\r\nkeyspan_setup_urbs(serial);\r\nif (s_priv->instat_urb != NULL) {\r\ns_priv->instat_urb->dev = serial->dev;\r\nerr = usb_submit_urb(s_priv->instat_urb, GFP_KERNEL);\r\nif (err != 0)\r\ndbg("%s - submit instat urb failed %d", __func__,\r\nerr);\r\n}\r\nif (s_priv->indat_urb != NULL) {\r\ns_priv->indat_urb->dev = serial->dev;\r\nerr = usb_submit_urb(s_priv->indat_urb, GFP_KERNEL);\r\nif (err != 0)\r\ndbg("%s - submit indat urb failed %d", __func__,\r\nerr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void keyspan_disconnect(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_serial_private *s_priv;\r\nstruct keyspan_port_private *p_priv;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\nstop_urb(s_priv->instat_urb);\r\nstop_urb(s_priv->glocont_urb);\r\nstop_urb(s_priv->indat_urb);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\np_priv = usb_get_serial_port_data(port);\r\nstop_urb(p_priv->inack_urb);\r\nstop_urb(p_priv->outcont_urb);\r\nfor (j = 0; j < 2; j++) {\r\nstop_urb(p_priv->in_urbs[j]);\r\nstop_urb(p_priv->out_urbs[j]);\r\n}\r\n}\r\nusb_free_urb(s_priv->instat_urb);\r\nusb_free_urb(s_priv->indat_urb);\r\nusb_free_urb(s_priv->glocont_urb);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\np_priv = usb_get_serial_port_data(port);\r\nusb_free_urb(p_priv->inack_urb);\r\nusb_free_urb(p_priv->outcont_urb);\r\nfor (j = 0; j < 2; j++) {\r\nusb_free_urb(p_priv->in_urbs[j]);\r\nusb_free_urb(p_priv->out_urbs[j]);\r\n}\r\n}\r\n}\r\nstatic void keyspan_release(struct usb_serial *serial)\r\n{\r\nint i;\r\nstruct usb_serial_port *port;\r\nstruct keyspan_serial_private *s_priv;\r\ndbg("%s", __func__);\r\ns_priv = usb_get_serial_data(serial);\r\nkfree(s_priv);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nkfree(usb_get_serial_port_data(port));\r\n}\r\n}
