static inline int rxrpc_writable(struct sock *sk)\r\n{\r\nreturn atomic_read(&sk->sk_wmem_alloc) < (size_t) sk->sk_sndbuf;\r\n}\r\nstatic void rxrpc_write_space(struct sock *sk)\r\n{\r\n_enter("%p", sk);\r\nrcu_read_lock();\r\nif (rxrpc_writable(sk)) {\r\nstruct socket_wq *wq = rcu_dereference(sk->sk_wq);\r\nif (wq_has_sleeper(wq))\r\nwake_up_interruptible(&wq->wait);\r\nsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int rxrpc_validate_address(struct rxrpc_sock *rx,\r\nstruct sockaddr_rxrpc *srx,\r\nint len)\r\n{\r\nif (len < sizeof(struct sockaddr_rxrpc))\r\nreturn -EINVAL;\r\nif (srx->srx_family != AF_RXRPC)\r\nreturn -EAFNOSUPPORT;\r\nif (srx->transport_type != SOCK_DGRAM)\r\nreturn -ESOCKTNOSUPPORT;\r\nlen -= offsetof(struct sockaddr_rxrpc, transport);\r\nif (srx->transport_len < sizeof(sa_family_t) ||\r\nsrx->transport_len > len)\r\nreturn -EINVAL;\r\nif (srx->transport.family != rx->proto)\r\nreturn -EAFNOSUPPORT;\r\nswitch (srx->transport.family) {\r\ncase AF_INET:\r\n_debug("INET: %x @ %pI4",\r\nntohs(srx->transport.sin.sin_port),\r\n&srx->transport.sin.sin_addr);\r\nif (srx->transport_len > 8)\r\nmemset((void *)&srx->transport + 8, 0,\r\nsrx->transport_len - 8);\r\nbreak;\r\ncase AF_INET6:\r\ndefault:\r\nreturn -EAFNOSUPPORT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rxrpc_bind(struct socket *sock, struct sockaddr *saddr, int len)\r\n{\r\nstruct sockaddr_rxrpc *srx = (struct sockaddr_rxrpc *) saddr;\r\nstruct sock *sk = sock->sk;\r\nstruct rxrpc_local *local;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk), *prx;\r\n__be16 service_id;\r\nint ret;\r\n_enter("%p,%p,%d", rx, saddr, len);\r\nret = rxrpc_validate_address(rx, srx, len);\r\nif (ret < 0)\r\ngoto error;\r\nlock_sock(&rx->sk);\r\nif (rx->sk.sk_state != RXRPC_UNCONNECTED) {\r\nret = -EINVAL;\r\ngoto error_unlock;\r\n}\r\nmemcpy(&rx->srx, srx, sizeof(rx->srx));\r\nlocal = rxrpc_lookup_local(&rx->srx);\r\nif (IS_ERR(local)) {\r\nret = PTR_ERR(local);\r\ngoto error_unlock;\r\n}\r\nrx->local = local;\r\nif (srx->srx_service) {\r\nservice_id = htons(srx->srx_service);\r\nwrite_lock_bh(&local->services_lock);\r\nlist_for_each_entry(prx, &local->services, listen_link) {\r\nif (prx->service_id == service_id)\r\ngoto service_in_use;\r\n}\r\nrx->service_id = service_id;\r\nlist_add_tail(&rx->listen_link, &local->services);\r\nwrite_unlock_bh(&local->services_lock);\r\nrx->sk.sk_state = RXRPC_SERVER_BOUND;\r\n} else {\r\nrx->sk.sk_state = RXRPC_CLIENT_BOUND;\r\n}\r\nrelease_sock(&rx->sk);\r\n_leave(" = 0");\r\nreturn 0;\r\nservice_in_use:\r\nret = -EADDRINUSE;\r\nwrite_unlock_bh(&local->services_lock);\r\nerror_unlock:\r\nrelease_sock(&rx->sk);\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\nint ret;\r\n_enter("%p,%d", rx, backlog);\r\nlock_sock(&rx->sk);\r\nswitch (rx->sk.sk_state) {\r\ncase RXRPC_UNCONNECTED:\r\nret = -EADDRNOTAVAIL;\r\nbreak;\r\ncase RXRPC_CLIENT_BOUND:\r\ncase RXRPC_CLIENT_CONNECTED:\r\ndefault:\r\nret = -EBUSY;\r\nbreak;\r\ncase RXRPC_SERVER_BOUND:\r\nASSERT(rx->local != NULL);\r\nsk->sk_max_ack_backlog = backlog;\r\nrx->sk.sk_state = RXRPC_SERVER_LISTENING;\r\nret = 0;\r\nbreak;\r\n}\r\nrelease_sock(&rx->sk);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic struct rxrpc_transport *rxrpc_name_to_transport(struct socket *sock,\r\nstruct sockaddr *addr,\r\nint addr_len, int flags,\r\ngfp_t gfp)\r\n{\r\nstruct sockaddr_rxrpc *srx = (struct sockaddr_rxrpc *) addr;\r\nstruct rxrpc_transport *trans;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nstruct rxrpc_peer *peer;\r\n_enter("%p,%p,%d,%d", rx, addr, addr_len, flags);\r\nASSERT(rx->local != NULL);\r\nASSERT(rx->sk.sk_state > RXRPC_UNCONNECTED);\r\nif (rx->srx.transport_type != srx->transport_type)\r\nreturn ERR_PTR(-ESOCKTNOSUPPORT);\r\nif (rx->srx.transport.family != srx->transport.family)\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\npeer = rxrpc_get_peer(srx, gfp);\r\nif (IS_ERR(peer))\r\nreturn ERR_CAST(peer);\r\ntrans = rxrpc_get_transport(rx->local, peer, gfp);\r\nrxrpc_put_peer(peer);\r\n_leave(" = %p", trans);\r\nreturn trans;\r\n}\r\nstruct rxrpc_call *rxrpc_kernel_begin_call(struct socket *sock,\r\nstruct sockaddr_rxrpc *srx,\r\nstruct key *key,\r\nunsigned long user_call_ID,\r\ngfp_t gfp)\r\n{\r\nstruct rxrpc_conn_bundle *bundle;\r\nstruct rxrpc_transport *trans;\r\nstruct rxrpc_call *call;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\n__be16 service_id;\r\n_enter(",,%x,%lx", key_serial(key), user_call_ID);\r\nlock_sock(&rx->sk);\r\nif (srx) {\r\ntrans = rxrpc_name_to_transport(sock, (struct sockaddr *) srx,\r\nsizeof(*srx), 0, gfp);\r\nif (IS_ERR(trans)) {\r\ncall = ERR_CAST(trans);\r\ntrans = NULL;\r\ngoto out_notrans;\r\n}\r\n} else {\r\ntrans = rx->trans;\r\nif (!trans) {\r\ncall = ERR_PTR(-ENOTCONN);\r\ngoto out_notrans;\r\n}\r\natomic_inc(&trans->usage);\r\n}\r\nservice_id = rx->service_id;\r\nif (srx)\r\nservice_id = htons(srx->srx_service);\r\nif (!key)\r\nkey = rx->key;\r\nif (key && !key->payload.data)\r\nkey = NULL;\r\nbundle = rxrpc_get_bundle(rx, trans, key, service_id, gfp);\r\nif (IS_ERR(bundle)) {\r\ncall = ERR_CAST(bundle);\r\ngoto out;\r\n}\r\ncall = rxrpc_get_client_call(rx, trans, bundle, user_call_ID, true,\r\ngfp);\r\nrxrpc_put_bundle(trans, bundle);\r\nout:\r\nrxrpc_put_transport(trans);\r\nout_notrans:\r\nrelease_sock(&rx->sk);\r\n_leave(" = %p", call);\r\nreturn call;\r\n}\r\nvoid rxrpc_kernel_end_call(struct rxrpc_call *call)\r\n{\r\n_enter("%d{%d}", call->debug_id, atomic_read(&call->usage));\r\nrxrpc_remove_user_ID(call->socket, call);\r\nrxrpc_put_call(call);\r\n}\r\nvoid rxrpc_kernel_intercept_rx_messages(struct socket *sock,\r\nrxrpc_interceptor_t interceptor)\r\n{\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\n_enter("");\r\nrx->interceptor = interceptor;\r\n}\r\nstatic int rxrpc_connect(struct socket *sock, struct sockaddr *addr,\r\nint addr_len, int flags)\r\n{\r\nstruct sockaddr_rxrpc *srx = (struct sockaddr_rxrpc *) addr;\r\nstruct sock *sk = sock->sk;\r\nstruct rxrpc_transport *trans;\r\nstruct rxrpc_local *local;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\nint ret;\r\n_enter("%p,%p,%d,%d", rx, addr, addr_len, flags);\r\nret = rxrpc_validate_address(rx, srx, addr_len);\r\nif (ret < 0) {\r\n_leave(" = %d [bad addr]", ret);\r\nreturn ret;\r\n}\r\nlock_sock(&rx->sk);\r\nswitch (rx->sk.sk_state) {\r\ncase RXRPC_UNCONNECTED:\r\nASSERTCMP(rx->local, ==, NULL);\r\nrx->srx.srx_family = AF_RXRPC;\r\nrx->srx.srx_service = 0;\r\nrx->srx.transport_type = srx->transport_type;\r\nrx->srx.transport_len = sizeof(sa_family_t);\r\nrx->srx.transport.family = srx->transport.family;\r\nlocal = rxrpc_lookup_local(&rx->srx);\r\nif (IS_ERR(local)) {\r\nrelease_sock(&rx->sk);\r\nreturn PTR_ERR(local);\r\n}\r\nrx->local = local;\r\nrx->sk.sk_state = RXRPC_CLIENT_BOUND;\r\ncase RXRPC_CLIENT_BOUND:\r\nbreak;\r\ncase RXRPC_CLIENT_CONNECTED:\r\nrelease_sock(&rx->sk);\r\nreturn -EISCONN;\r\ndefault:\r\nrelease_sock(&rx->sk);\r\nreturn -EBUSY;\r\n}\r\ntrans = rxrpc_name_to_transport(sock, addr, addr_len, flags,\r\nGFP_KERNEL);\r\nif (IS_ERR(trans)) {\r\nrelease_sock(&rx->sk);\r\n_leave(" = %ld", PTR_ERR(trans));\r\nreturn PTR_ERR(trans);\r\n}\r\nrx->trans = trans;\r\nrx->service_id = htons(srx->srx_service);\r\nrx->sk.sk_state = RXRPC_CLIENT_CONNECTED;\r\nrelease_sock(&rx->sk);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *m, size_t len)\r\n{\r\nstruct rxrpc_transport *trans;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nint ret;\r\n_enter(",{%d},,%zu", rx->sk.sk_state, len);\r\nif (m->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nif (m->msg_name) {\r\nret = rxrpc_validate_address(rx, m->msg_name, m->msg_namelen);\r\nif (ret < 0) {\r\n_leave(" = %d [bad addr]", ret);\r\nreturn ret;\r\n}\r\n}\r\ntrans = NULL;\r\nlock_sock(&rx->sk);\r\nif (m->msg_name) {\r\nret = -EISCONN;\r\ntrans = rxrpc_name_to_transport(sock, m->msg_name,\r\nm->msg_namelen, 0, GFP_KERNEL);\r\nif (IS_ERR(trans)) {\r\nret = PTR_ERR(trans);\r\ntrans = NULL;\r\ngoto out;\r\n}\r\n} else {\r\ntrans = rx->trans;\r\nif (trans)\r\natomic_inc(&trans->usage);\r\n}\r\nswitch (rx->sk.sk_state) {\r\ncase RXRPC_SERVER_LISTENING:\r\nif (!m->msg_name) {\r\nret = rxrpc_server_sendmsg(iocb, rx, m, len);\r\nbreak;\r\n}\r\ncase RXRPC_SERVER_BOUND:\r\ncase RXRPC_CLIENT_BOUND:\r\nif (!m->msg_name) {\r\nret = -ENOTCONN;\r\nbreak;\r\n}\r\ncase RXRPC_CLIENT_CONNECTED:\r\nret = rxrpc_client_sendmsg(iocb, rx, trans, m, len);\r\nbreak;\r\ndefault:\r\nret = -ENOTCONN;\r\nbreak;\r\n}\r\nout:\r\nrelease_sock(&rx->sk);\r\nif (trans)\r\nrxrpc_put_transport(trans);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nunsigned min_sec_level;\r\nint ret;\r\n_enter(",%d,%d,,%d", level, optname, optlen);\r\nlock_sock(&rx->sk);\r\nret = -EOPNOTSUPP;\r\nif (level == SOL_RXRPC) {\r\nswitch (optname) {\r\ncase RXRPC_EXCLUSIVE_CONNECTION:\r\nret = -EINVAL;\r\nif (optlen != 0)\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNCONNECTED)\r\ngoto error;\r\nset_bit(RXRPC_SOCK_EXCLUSIVE_CONN, &rx->flags);\r\ngoto success;\r\ncase RXRPC_SECURITY_KEY:\r\nret = -EINVAL;\r\nif (rx->key)\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNCONNECTED)\r\ngoto error;\r\nret = rxrpc_request_key(rx, optval, optlen);\r\ngoto error;\r\ncase RXRPC_SECURITY_KEYRING:\r\nret = -EINVAL;\r\nif (rx->key)\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNCONNECTED)\r\ngoto error;\r\nret = rxrpc_server_keyring(rx, optval, optlen);\r\ngoto error;\r\ncase RXRPC_MIN_SECURITY_LEVEL:\r\nret = -EINVAL;\r\nif (optlen != sizeof(unsigned))\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNCONNECTED)\r\ngoto error;\r\nret = get_user(min_sec_level,\r\n(unsigned __user *) optval);\r\nif (ret < 0)\r\ngoto error;\r\nret = -EINVAL;\r\nif (min_sec_level > RXRPC_SECURITY_MAX)\r\ngoto error;\r\nrx->min_sec_level = min_sec_level;\r\ngoto success;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nsuccess:\r\nret = 0;\r\nerror:\r\nrelease_sock(&rx->sk);\r\nreturn ret;\r\n}\r\nstatic unsigned int rxrpc_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nunsigned int mask;\r\nstruct sock *sk = sock->sk;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (!skb_queue_empty(&sk->sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (rxrpc_writable(sk))\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic int rxrpc_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct rxrpc_sock *rx;\r\nstruct sock *sk;\r\n_enter("%p,%d", sock, protocol);\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (protocol != PF_INET)\r\nreturn -EPROTONOSUPPORT;\r\nif (sock->type != SOCK_DGRAM)\r\nreturn -ESOCKTNOSUPPORT;\r\nsock->ops = &rxrpc_rpc_ops;\r\nsock->state = SS_UNCONNECTED;\r\nsk = sk_alloc(net, PF_RXRPC, GFP_KERNEL, &rxrpc_proto);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsock_init_data(sock, sk);\r\nsk->sk_state = RXRPC_UNCONNECTED;\r\nsk->sk_write_space = rxrpc_write_space;\r\nsk->sk_max_ack_backlog = sysctl_rxrpc_max_qlen;\r\nsk->sk_destruct = rxrpc_sock_destructor;\r\nrx = rxrpc_sk(sk);\r\nrx->proto = protocol;\r\nrx->calls = RB_ROOT;\r\nINIT_LIST_HEAD(&rx->listen_link);\r\nINIT_LIST_HEAD(&rx->secureq);\r\nINIT_LIST_HEAD(&rx->acceptq);\r\nrwlock_init(&rx->call_lock);\r\nmemset(&rx->srx, 0, sizeof(rx->srx));\r\n_leave(" = 0 [%p]", rx);\r\nreturn 0;\r\n}\r\nstatic void rxrpc_sock_destructor(struct sock *sk)\r\n{\r\n_enter("%p", sk);\r\nrxrpc_purge_queue(&sk->sk_receive_queue);\r\nWARN_ON(atomic_read(&sk->sk_wmem_alloc));\r\nWARN_ON(!sk_unhashed(sk));\r\nWARN_ON(sk->sk_socket);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nprintk("Attempt to release alive rxrpc socket: %p\n", sk);\r\nreturn;\r\n}\r\n}\r\nstatic int rxrpc_release_sock(struct sock *sk)\r\n{\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\n_enter("%p{%d,%d}", sk, sk->sk_state, atomic_read(&sk->sk_refcnt));\r\nsock_orphan(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nspin_lock_bh(&sk->sk_receive_queue.lock);\r\nsk->sk_state = RXRPC_CLOSE;\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\nASSERTCMP(rx->listen_link.next, !=, LIST_POISON1);\r\nif (!list_empty(&rx->listen_link)) {\r\nwrite_lock_bh(&rx->local->services_lock);\r\nlist_del(&rx->listen_link);\r\nwrite_unlock_bh(&rx->local->services_lock);\r\n}\r\nrxrpc_release_calls_on_socket(rx);\r\nflush_workqueue(rxrpc_workqueue);\r\nrxrpc_purge_queue(&sk->sk_receive_queue);\r\nif (rx->conn) {\r\nrxrpc_put_connection(rx->conn);\r\nrx->conn = NULL;\r\n}\r\nif (rx->bundle) {\r\nrxrpc_put_bundle(rx->trans, rx->bundle);\r\nrx->bundle = NULL;\r\n}\r\nif (rx->trans) {\r\nrxrpc_put_transport(rx->trans);\r\nrx->trans = NULL;\r\n}\r\nif (rx->local) {\r\nrxrpc_put_local(rx->local);\r\nrx->local = NULL;\r\n}\r\nkey_put(rx->key);\r\nrx->key = NULL;\r\nkey_put(rx->securities);\r\nrx->securities = NULL;\r\nsock_put(sk);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxrpc_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\n_enter("%p{%p}", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nsock->sk = NULL;\r\nreturn rxrpc_release_sock(sk);\r\n}\r\nstatic int __init af_rxrpc_init(void)\r\n{\r\nstruct sk_buff *dummy_skb;\r\nint ret = -1;\r\nBUILD_BUG_ON(sizeof(struct rxrpc_skb_priv) > sizeof(dummy_skb->cb));\r\nrxrpc_epoch = htonl(get_seconds());\r\nret = -ENOMEM;\r\nrxrpc_call_jar = kmem_cache_create(\r\n"rxrpc_call_jar", sizeof(struct rxrpc_call), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!rxrpc_call_jar) {\r\nprintk(KERN_NOTICE "RxRPC: Failed to allocate call jar\n");\r\ngoto error_call_jar;\r\n}\r\nrxrpc_workqueue = alloc_workqueue("krxrpcd", 0, 1);\r\nif (!rxrpc_workqueue) {\r\nprintk(KERN_NOTICE "RxRPC: Failed to allocate work queue\n");\r\ngoto error_work_queue;\r\n}\r\nret = proto_register(&rxrpc_proto, 1);\r\nif (ret < 0) {\r\nprintk(KERN_CRIT "RxRPC: Cannot register protocol\n");\r\ngoto error_proto;\r\n}\r\nret = sock_register(&rxrpc_family_ops);\r\nif (ret < 0) {\r\nprintk(KERN_CRIT "RxRPC: Cannot register socket family\n");\r\ngoto error_sock;\r\n}\r\nret = register_key_type(&key_type_rxrpc);\r\nif (ret < 0) {\r\nprintk(KERN_CRIT "RxRPC: Cannot register client key type\n");\r\ngoto error_key_type;\r\n}\r\nret = register_key_type(&key_type_rxrpc_s);\r\nif (ret < 0) {\r\nprintk(KERN_CRIT "RxRPC: Cannot register server key type\n");\r\ngoto error_key_type_s;\r\n}\r\n#ifdef CONFIG_PROC_FS\r\nproc_net_fops_create(&init_net, "rxrpc_calls", 0, &rxrpc_call_seq_fops);\r\nproc_net_fops_create(&init_net, "rxrpc_conns", 0, &rxrpc_connection_seq_fops);\r\n#endif\r\nreturn 0;\r\nerror_key_type_s:\r\nunregister_key_type(&key_type_rxrpc);\r\nerror_key_type:\r\nsock_unregister(PF_RXRPC);\r\nerror_sock:\r\nproto_unregister(&rxrpc_proto);\r\nerror_proto:\r\ndestroy_workqueue(rxrpc_workqueue);\r\nerror_work_queue:\r\nkmem_cache_destroy(rxrpc_call_jar);\r\nerror_call_jar:\r\nreturn ret;\r\n}\r\nstatic void __exit af_rxrpc_exit(void)\r\n{\r\n_enter("");\r\nunregister_key_type(&key_type_rxrpc_s);\r\nunregister_key_type(&key_type_rxrpc);\r\nsock_unregister(PF_RXRPC);\r\nproto_unregister(&rxrpc_proto);\r\nrxrpc_destroy_all_calls();\r\nrxrpc_destroy_all_connections();\r\nrxrpc_destroy_all_transports();\r\nrxrpc_destroy_all_peers();\r\nrxrpc_destroy_all_locals();\r\nASSERTCMP(atomic_read(&rxrpc_n_skbs), ==, 0);\r\n_debug("flush scheduled work");\r\nflush_workqueue(rxrpc_workqueue);\r\nproc_net_remove(&init_net, "rxrpc_conns");\r\nproc_net_remove(&init_net, "rxrpc_calls");\r\ndestroy_workqueue(rxrpc_workqueue);\r\nkmem_cache_destroy(rxrpc_call_jar);\r\n_leave("");\r\n}
