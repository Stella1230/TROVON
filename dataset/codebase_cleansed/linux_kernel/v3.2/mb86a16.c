static int mb86a16_write(struct mb86a16_state *state, u8 reg, u8 val)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, val };\r\nstruct i2c_msg msg = {\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\ndprintk(verbose, MB86A16_DEBUG, 1,\r\n"writing to [0x%02x],Reg[0x%02x],Data[0x%02x]",\r\nstate->config->demod_address, buf[0], buf[1]);\r\nret = i2c_transfer(state->i2c_adap, &msg, 1);\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic int mb86a16_read(struct mb86a16_state *state, u8 reg, u8 *val)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n}, {\r\n.addr = state->config->demod_address,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n}\r\n};\r\nret = i2c_transfer(state->i2c_adap, msg, 2);\r\nif (ret != 2) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "read error(reg=0x%02x, ret=0x%i)",\r\nreg, ret);\r\nreturn -EREMOTEIO;\r\n}\r\n*val = b1[0];\r\nreturn ret;\r\n}\r\nstatic int CNTM_set(struct mb86a16_state *state,\r\nunsigned char timint1,\r\nunsigned char timint2,\r\nunsigned char cnext)\r\n{\r\nunsigned char val;\r\nval = (timint1 << 4) | (timint2 << 2) | cnext;\r\nif (mb86a16_write(state, MB86A16_CNTMR, val) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int smrt_set(struct mb86a16_state *state, int rate)\r\n{\r\nint tmp ;\r\nint m ;\r\nunsigned char STOFS0, STOFS1;\r\nm = 1 << state->deci;\r\ntmp = (8192 * state->master_clk - 2 * m * rate * 8192 + state->master_clk / 2) / state->master_clk;\r\nSTOFS0 = tmp & 0x0ff;\r\nSTOFS1 = (tmp & 0xf00) >> 8;\r\nif (mb86a16_write(state, MB86A16_SRATE1, (state->deci << 2) |\r\n(state->csel << 1) |\r\nstate->rsel) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_SRATE2, STOFS0) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_SRATE3, STOFS1) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -1;\r\n}\r\nstatic int srst(struct mb86a16_state *state)\r\n{\r\nif (mb86a16_write(state, MB86A16_RESET, 0x04) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int afcex_data_set(struct mb86a16_state *state,\r\nunsigned char AFCEX_L,\r\nunsigned char AFCEX_H)\r\n{\r\nif (mb86a16_write(state, MB86A16_AFCEXL, AFCEX_L) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_AFCEXH, AFCEX_H) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -1;\r\n}\r\nstatic int afcofs_data_set(struct mb86a16_state *state,\r\nunsigned char AFCEX_L,\r\nunsigned char AFCEX_H)\r\n{\r\nif (mb86a16_write(state, 0x58, AFCEX_L) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, 0x59, AFCEX_H) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int stlp_set(struct mb86a16_state *state,\r\nunsigned char STRAS,\r\nunsigned char STRBS)\r\n{\r\nif (mb86a16_write(state, MB86A16_STRFILTCOEF1, (STRBS << 3) | (STRAS)) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int Vi_set(struct mb86a16_state *state, unsigned char ETH, unsigned char VIA)\r\n{\r\nif (mb86a16_write(state, MB86A16_VISET2, 0x04) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_VISET3, 0xf5) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int initial_set(struct mb86a16_state *state)\r\n{\r\nif (stlp_set(state, 5, 7))\r\ngoto err;\r\nudelay(100);\r\nif (afcex_data_set(state, 0, 0))\r\ngoto err;\r\nudelay(100);\r\nif (afcofs_data_set(state, 0, 0))\r\ngoto err;\r\nudelay(100);\r\nif (mb86a16_write(state, MB86A16_CRLFILTCOEF1, 0x16) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, 0x2f, 0x21) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_VIMAG, 0x38) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_FAGCS1, 0x00) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_FAGCS2, 0x1c) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_FAGCS3, 0x20) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_FAGCS4, 0x1e) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_FAGCS5, 0x23) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, 0x54, 0xff) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_TSOUT, 0x00) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int S01T_set(struct mb86a16_state *state,\r\nunsigned char s1t,\r\nunsigned s0t)\r\n{\r\nif (mb86a16_write(state, 0x33, (s1t << 3) | s0t) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int EN_set(struct mb86a16_state *state,\r\nint cren,\r\nint afcen)\r\n{\r\nunsigned char val;\r\nval = 0x7a | (cren << 7) | (afcen << 2);\r\nif (mb86a16_write(state, 0x49, val) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int AFCEXEN_set(struct mb86a16_state *state,\r\nint afcexen,\r\nint smrt)\r\n{\r\nunsigned char AFCA ;\r\nif (smrt > 18875)\r\nAFCA = 4;\r\nelse if (smrt > 9375)\r\nAFCA = 3;\r\nelse if (smrt > 2250)\r\nAFCA = 2;\r\nelse\r\nAFCA = 1;\r\nif (mb86a16_write(state, 0x2a, 0x02 | (afcexen << 5) | (AFCA << 2)) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int DAGC_data_set(struct mb86a16_state *state,\r\nunsigned char DAGCA,\r\nunsigned char DAGCW)\r\n{\r\nif (mb86a16_write(state, 0x2d, (DAGCA << 3) | DAGCW) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic void smrt_info_get(struct mb86a16_state *state, int rate)\r\n{\r\nif (rate >= 37501) {\r\nstate->deci = 0; state->csel = 0; state->rsel = 0;\r\n} else if (rate >= 30001) {\r\nstate->deci = 0; state->csel = 0; state->rsel = 1;\r\n} else if (rate >= 26251) {\r\nstate->deci = 0; state->csel = 1; state->rsel = 0;\r\n} else if (rate >= 22501) {\r\nstate->deci = 0; state->csel = 1; state->rsel = 1;\r\n} else if (rate >= 18751) {\r\nstate->deci = 1; state->csel = 0; state->rsel = 0;\r\n} else if (rate >= 15001) {\r\nstate->deci = 1; state->csel = 0; state->rsel = 1;\r\n} else if (rate >= 13126) {\r\nstate->deci = 1; state->csel = 1; state->rsel = 0;\r\n} else if (rate >= 11251) {\r\nstate->deci = 1; state->csel = 1; state->rsel = 1;\r\n} else if (rate >= 9376) {\r\nstate->deci = 2; state->csel = 0; state->rsel = 0;\r\n} else if (rate >= 7501) {\r\nstate->deci = 2; state->csel = 0; state->rsel = 1;\r\n} else if (rate >= 6563) {\r\nstate->deci = 2; state->csel = 1; state->rsel = 0;\r\n} else if (rate >= 5626) {\r\nstate->deci = 2; state->csel = 1; state->rsel = 1;\r\n} else if (rate >= 4688) {\r\nstate->deci = 3; state->csel = 0; state->rsel = 0;\r\n} else if (rate >= 3751) {\r\nstate->deci = 3; state->csel = 0; state->rsel = 1;\r\n} else if (rate >= 3282) {\r\nstate->deci = 3; state->csel = 1; state->rsel = 0;\r\n} else if (rate >= 2814) {\r\nstate->deci = 3; state->csel = 1; state->rsel = 1;\r\n} else if (rate >= 2344) {\r\nstate->deci = 4; state->csel = 0; state->rsel = 0;\r\n} else if (rate >= 1876) {\r\nstate->deci = 4; state->csel = 0; state->rsel = 1;\r\n} else if (rate >= 1641) {\r\nstate->deci = 4; state->csel = 1; state->rsel = 0;\r\n} else if (rate >= 1407) {\r\nstate->deci = 4; state->csel = 1; state->rsel = 1;\r\n} else if (rate >= 1172) {\r\nstate->deci = 5; state->csel = 0; state->rsel = 0;\r\n} else if (rate >= 939) {\r\nstate->deci = 5; state->csel = 0; state->rsel = 1;\r\n} else if (rate >= 821) {\r\nstate->deci = 5; state->csel = 1; state->rsel = 0;\r\n} else {\r\nstate->deci = 5; state->csel = 1; state->rsel = 1;\r\n}\r\nif (state->csel == 0)\r\nstate->master_clk = 92000;\r\nelse\r\nstate->master_clk = 61333;\r\n}\r\nstatic int signal_det(struct mb86a16_state *state,\r\nint smrt,\r\nunsigned char *SIG)\r\n{\r\nint ret ;\r\nint smrtd ;\r\nint wait_sym ;\r\nu32 wait_t;\r\nunsigned char S[3] ;\r\nint i ;\r\nif (*SIG > 45) {\r\nif (CNTM_set(state, 2, 1, 2) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "CNTM set Error");\r\nreturn -1;\r\n}\r\nwait_sym = 40000;\r\n} else {\r\nif (CNTM_set(state, 3, 1, 2) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "CNTM set Error");\r\nreturn -1;\r\n}\r\nwait_sym = 80000;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (i == 0)\r\nsmrtd = smrt * 98 / 100;\r\nelse if (i == 1)\r\nsmrtd = smrt;\r\nelse\r\nsmrtd = smrt * 102 / 100;\r\nsmrt_info_get(state, smrtd);\r\nsmrt_set(state, smrtd);\r\nsrst(state);\r\nwait_t = (wait_sym + 99 * smrtd / 100) / smrtd;\r\nif (wait_t == 0)\r\nwait_t = 1;\r\nmsleep_interruptible(10);\r\nif (mb86a16_read(state, 0x37, &(S[i])) != 2) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nif ((S[1] > S[0] * 112 / 100) &&\r\n(S[1] > S[2] * 112 / 100)) {\r\nret = 1;\r\n} else {\r\nret = 0;\r\n}\r\n*SIG = S[1];\r\nif (CNTM_set(state, 0, 1, 2) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "CNTM set Error");\r\nreturn -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rf_val_set(struct mb86a16_state *state,\r\nint f,\r\nint smrt,\r\nunsigned char R)\r\n{\r\nunsigned char C, F, B;\r\nint M;\r\nunsigned char rf_val[5];\r\nint ack = -1;\r\nif (smrt > 37750)\r\nC = 1;\r\nelse if (smrt > 18875)\r\nC = 2;\r\nelse if (smrt > 5500)\r\nC = 3;\r\nelse\r\nC = 4;\r\nif (smrt > 30500)\r\nF = 3;\r\nelse if (smrt > 9375)\r\nF = 1;\r\nelse if (smrt > 4625)\r\nF = 0;\r\nelse\r\nF = 2;\r\nif (f < 1060)\r\nB = 0;\r\nelse if (f < 1175)\r\nB = 1;\r\nelse if (f < 1305)\r\nB = 2;\r\nelse if (f < 1435)\r\nB = 3;\r\nelse if (f < 1570)\r\nB = 4;\r\nelse if (f < 1715)\r\nB = 5;\r\nelse if (f < 1845)\r\nB = 6;\r\nelse if (f < 1980)\r\nB = 7;\r\nelse if (f < 2080)\r\nB = 8;\r\nelse\r\nB = 9;\r\nM = f * (1 << R) / 2;\r\nrf_val[0] = 0x01 | (C << 3) | (F << 1);\r\nrf_val[1] = (R << 5) | ((M & 0x1f000) >> 12);\r\nrf_val[2] = (M & 0x00ff0) >> 4;\r\nrf_val[3] = ((M & 0x0000f) << 4) | B;\r\nif (mb86a16_write(state, 0x21, rf_val[0]) < 0)\r\nack = 0;\r\nif (mb86a16_write(state, 0x22, rf_val[1]) < 0)\r\nack = 0;\r\nif (mb86a16_write(state, 0x23, rf_val[2]) < 0)\r\nack = 0;\r\nif (mb86a16_write(state, 0x24, rf_val[3]) < 0)\r\nack = 0;\r\nif (mb86a16_write(state, 0x25, 0x01) < 0)\r\nack = 0;\r\nif (ack == 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "RF Setup - I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int afcerr_chk(struct mb86a16_state *state)\r\n{\r\nunsigned char AFCM_L, AFCM_H ;\r\nint AFCM ;\r\nint afcm, afcerr ;\r\nif (mb86a16_read(state, 0x0e, &AFCM_L) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, 0x0f, &AFCM_H) != 2)\r\ngoto err;\r\nAFCM = (AFCM_H << 8) + AFCM_L;\r\nif (AFCM > 2048)\r\nafcm = AFCM - 4096;\r\nelse\r\nafcm = AFCM;\r\nafcerr = afcm * state->master_clk / 8192;\r\nreturn afcerr;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int dagcm_val_get(struct mb86a16_state *state)\r\n{\r\nint DAGCM;\r\nunsigned char DAGCM_H, DAGCM_L;\r\nif (mb86a16_read(state, 0x45, &DAGCM_L) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, 0x46, &DAGCM_H) != 2)\r\ngoto err;\r\nDAGCM = (DAGCM_H << 8) + DAGCM_L;\r\nreturn DAGCM;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int mb86a16_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nu8 stat, stat2;\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\n*status = 0;\r\nif (mb86a16_read(state, MB86A16_SIG1, &stat) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, MB86A16_SIG2, &stat2) != 2)\r\ngoto err;\r\nif ((stat > 25) && (stat2 > 25))\r\n*status |= FE_HAS_SIGNAL;\r\nif ((stat > 45) && (stat2 > 45))\r\n*status |= FE_HAS_CARRIER;\r\nif (mb86a16_read(state, MB86A16_STATUS, &stat) != 2)\r\ngoto err;\r\nif (stat & 0x01)\r\n*status |= FE_HAS_SYNC;\r\nif (stat & 0x01)\r\n*status |= FE_HAS_VITERBI;\r\nif (mb86a16_read(state, MB86A16_FRAMESYNC, &stat) != 2)\r\ngoto err;\r\nif ((stat & 0x0f) && (*status & FE_HAS_VITERBI))\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int sync_chk(struct mb86a16_state *state,\r\nunsigned char *VIRM)\r\n{\r\nunsigned char val;\r\nint sync;\r\nif (mb86a16_read(state, 0x0d, &val) != 2)\r\ngoto err;\r\ndprintk(verbose, MB86A16_INFO, 1, "Status = %02x,", val);\r\nsync = val & 0x01;\r\n*VIRM = (val & 0x1c) >> 2;\r\nreturn sync;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int freqerr_chk(struct mb86a16_state *state,\r\nint fTP,\r\nint smrt,\r\nint unit)\r\n{\r\nunsigned char CRM, AFCML, AFCMH;\r\nunsigned char temp1, temp2, temp3;\r\nint crm, afcm, AFCM;\r\nint crrerr, afcerr;\r\nint frqerr;\r\nint afcen, afcexen = 0;\r\nint R, M, fOSC, fOSC_OFS;\r\nif (mb86a16_read(state, 0x43, &CRM) != 2)\r\ngoto err;\r\nif (CRM > 127)\r\ncrm = CRM - 256;\r\nelse\r\ncrm = CRM;\r\ncrrerr = smrt * crm / 256;\r\nif (mb86a16_read(state, 0x49, &temp1) != 2)\r\ngoto err;\r\nafcen = (temp1 & 0x04) >> 2;\r\nif (afcen == 0) {\r\nif (mb86a16_read(state, 0x2a, &temp1) != 2)\r\ngoto err;\r\nafcexen = (temp1 & 0x20) >> 5;\r\n}\r\nif (afcen == 1) {\r\nif (mb86a16_read(state, 0x0e, &AFCML) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, 0x0f, &AFCMH) != 2)\r\ngoto err;\r\n} else if (afcexen == 1) {\r\nif (mb86a16_read(state, 0x2b, &AFCML) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, 0x2c, &AFCMH) != 2)\r\ngoto err;\r\n}\r\nif ((afcen == 1) || (afcexen == 1)) {\r\nsmrt_info_get(state, smrt);\r\nAFCM = ((AFCMH & 0x01) << 8) + AFCML;\r\nif (AFCM > 255)\r\nafcm = AFCM - 512;\r\nelse\r\nafcm = AFCM;\r\nafcerr = afcm * state->master_clk / 8192;\r\n} else\r\nafcerr = 0;\r\nif (mb86a16_read(state, 0x22, &temp1) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, 0x23, &temp2) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, 0x24, &temp3) != 2)\r\ngoto err;\r\nR = (temp1 & 0xe0) >> 5;\r\nM = ((temp1 & 0x1f) << 12) + (temp2 << 4) + (temp3 >> 4);\r\nif (R == 0)\r\nfOSC = 2 * M;\r\nelse\r\nfOSC = M;\r\nfOSC_OFS = fOSC - fTP;\r\nif (unit == 0) {\r\nif (crrerr + afcerr + fOSC_OFS * 1000 >= 0)\r\nfrqerr = (crrerr + afcerr + fOSC_OFS * 1000 + 500) / 1000;\r\nelse\r\nfrqerr = (crrerr + afcerr + fOSC_OFS * 1000 - 500) / 1000;\r\n} else {\r\nfrqerr = crrerr + afcerr + fOSC_OFS * 1000;\r\n}\r\nreturn frqerr;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic unsigned char vco_dev_get(struct mb86a16_state *state, int smrt)\r\n{\r\nunsigned char R;\r\nif (smrt > 9375)\r\nR = 0;\r\nelse\r\nR = 1;\r\nreturn R;\r\n}\r\nstatic void swp_info_get(struct mb86a16_state *state,\r\nint fOSC_start,\r\nint smrt,\r\nint v, int R,\r\nint swp_ofs,\r\nint *fOSC,\r\nint *afcex_freq,\r\nunsigned char *AFCEX_L,\r\nunsigned char *AFCEX_H)\r\n{\r\nint AFCEX ;\r\nint crnt_swp_freq ;\r\ncrnt_swp_freq = fOSC_start * 1000 + v * swp_ofs;\r\nif (R == 0)\r\n*fOSC = (crnt_swp_freq + 1000) / 2000 * 2;\r\nelse\r\n*fOSC = (crnt_swp_freq + 500) / 1000;\r\nif (*fOSC >= crnt_swp_freq)\r\n*afcex_freq = *fOSC * 1000 - crnt_swp_freq;\r\nelse\r\n*afcex_freq = crnt_swp_freq - *fOSC * 1000;\r\nAFCEX = *afcex_freq * 8192 / state->master_clk;\r\n*AFCEX_L = AFCEX & 0x00ff;\r\n*AFCEX_H = (AFCEX & 0x0f00) >> 8;\r\n}\r\nstatic int swp_freq_calcuation(struct mb86a16_state *state, int i, int v, int *V, int vmax, int vmin,\r\nint SIGMIN, int fOSC, int afcex_freq, int swp_ofs, unsigned char *SIG1)\r\n{\r\nint swp_freq ;\r\nif ((i % 2 == 1) && (v <= vmax)) {\r\nif ((v - 1 == vmin) &&\r\n(*(V + 30 + v) >= 0) &&\r\n(*(V + 30 + v - 1) >= 0) &&\r\n(*(V + 30 + v - 1) > *(V + 30 + v)) &&\r\n(*(V + 30 + v - 1) > SIGMIN)) {\r\nswp_freq = fOSC * 1000 + afcex_freq - swp_ofs;\r\n*SIG1 = *(V + 30 + v - 1);\r\n} else if ((v == vmax) &&\r\n(*(V + 30 + v) >= 0) &&\r\n(*(V + 30 + v - 1) >= 0) &&\r\n(*(V + 30 + v) > *(V + 30 + v - 1)) &&\r\n(*(V + 30 + v) > SIGMIN)) {\r\nswp_freq = fOSC * 1000 + afcex_freq;\r\n*SIG1 = *(V + 30 + v);\r\n} else if ((*(V + 30 + v) > 0) &&\r\n(*(V + 30 + v - 1) > 0) &&\r\n(*(V + 30 + v - 2) > 0) &&\r\n(*(V + 30 + v - 3) > 0) &&\r\n(*(V + 30 + v - 1) > *(V + 30 + v)) &&\r\n(*(V + 30 + v - 2) > *(V + 30 + v - 3)) &&\r\n((*(V + 30 + v - 1) > SIGMIN) ||\r\n(*(V + 30 + v - 2) > SIGMIN))) {\r\nif (*(V + 30 + v - 1) >= *(V + 30 + v - 2)) {\r\nswp_freq = fOSC * 1000 + afcex_freq - swp_ofs;\r\n*SIG1 = *(V + 30 + v - 1);\r\n} else {\r\nswp_freq = fOSC * 1000 + afcex_freq - swp_ofs * 2;\r\n*SIG1 = *(V + 30 + v - 2);\r\n}\r\n} else if ((v == vmax) &&\r\n(*(V + 30 + v) >= 0) &&\r\n(*(V + 30 + v - 1) >= 0) &&\r\n(*(V + 30 + v - 2) >= 0) &&\r\n(*(V + 30 + v) > *(V + 30 + v - 2)) &&\r\n(*(V + 30 + v - 1) > *(V + 30 + v - 2)) &&\r\n((*(V + 30 + v) > SIGMIN) ||\r\n(*(V + 30 + v - 1) > SIGMIN))) {\r\nif (*(V + 30 + v) >= *(V + 30 + v - 1)) {\r\nswp_freq = fOSC * 1000 + afcex_freq;\r\n*SIG1 = *(V + 30 + v);\r\n} else {\r\nswp_freq = fOSC * 1000 + afcex_freq - swp_ofs;\r\n*SIG1 = *(V + 30 + v - 1);\r\n}\r\n} else {\r\nswp_freq = -1 ;\r\n}\r\n} else if ((i % 2 == 0) && (v >= vmin)) {\r\nif ((*(V + 30 + v) > 0) &&\r\n(*(V + 30 + v + 1) > 0) &&\r\n(*(V + 30 + v + 2) > 0) &&\r\n(*(V + 30 + v + 1) > *(V + 30 + v)) &&\r\n(*(V + 30 + v + 1) > *(V + 30 + v + 2)) &&\r\n(*(V + 30 + v + 1) > SIGMIN)) {\r\nswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\r\n*SIG1 = *(V + 30 + v + 1);\r\n} else if ((v + 1 == vmax) &&\r\n(*(V + 30 + v) >= 0) &&\r\n(*(V + 30 + v + 1) >= 0) &&\r\n(*(V + 30 + v + 1) > *(V + 30 + v)) &&\r\n(*(V + 30 + v + 1) > SIGMIN)) {\r\nswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\r\n*SIG1 = *(V + 30 + v);\r\n} else if ((v == vmin) &&\r\n(*(V + 30 + v) > 0) &&\r\n(*(V + 30 + v + 1) > 0) &&\r\n(*(V + 30 + v + 2) > 0) &&\r\n(*(V + 30 + v) > *(V + 30 + v + 1)) &&\r\n(*(V + 30 + v) > *(V + 30 + v + 2)) &&\r\n(*(V + 30 + v) > SIGMIN)) {\r\nswp_freq = fOSC * 1000 + afcex_freq;\r\n*SIG1 = *(V + 30 + v);\r\n} else if ((*(V + 30 + v) >= 0) &&\r\n(*(V + 30 + v + 1) >= 0) &&\r\n(*(V + 30 + v + 2) >= 0) &&\r\n(*(V + 30 + v + 3) >= 0) &&\r\n(*(V + 30 + v + 1) > *(V + 30 + v)) &&\r\n(*(V + 30 + v + 2) > *(V + 30 + v + 3)) &&\r\n((*(V + 30 + v + 1) > SIGMIN) ||\r\n(*(V + 30 + v + 2) > SIGMIN))) {\r\nif (*(V + 30 + v + 1) >= *(V + 30 + v + 2)) {\r\nswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\r\n*SIG1 = *(V + 30 + v + 1);\r\n} else {\r\nswp_freq = fOSC * 1000 + afcex_freq + swp_ofs * 2;\r\n*SIG1 = *(V + 30 + v + 2);\r\n}\r\n} else if ((*(V + 30 + v) >= 0) &&\r\n(*(V + 30 + v + 1) >= 0) &&\r\n(*(V + 30 + v + 2) >= 0) &&\r\n(*(V + 30 + v + 3) >= 0) &&\r\n(*(V + 30 + v) > *(V + 30 + v + 2)) &&\r\n(*(V + 30 + v + 1) > *(V + 30 + v + 2)) &&\r\n(*(V + 30 + v) > *(V + 30 + v + 3)) &&\r\n(*(V + 30 + v + 1) > *(V + 30 + v + 3)) &&\r\n((*(V + 30 + v) > SIGMIN) ||\r\n(*(V + 30 + v + 1) > SIGMIN))) {\r\nif (*(V + 30 + v) >= *(V + 30 + v + 1)) {\r\nswp_freq = fOSC * 1000 + afcex_freq;\r\n*SIG1 = *(V + 30 + v);\r\n} else {\r\nswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\r\n*SIG1 = *(V + 30 + v + 1);\r\n}\r\n} else if ((v + 2 == vmin) &&\r\n(*(V + 30 + v) >= 0) &&\r\n(*(V + 30 + v + 1) >= 0) &&\r\n(*(V + 30 + v + 2) >= 0) &&\r\n(*(V + 30 + v + 1) > *(V + 30 + v)) &&\r\n(*(V + 30 + v + 2) > *(V + 30 + v)) &&\r\n((*(V + 30 + v + 1) > SIGMIN) ||\r\n(*(V + 30 + v + 2) > SIGMIN))) {\r\nif (*(V + 30 + v + 1) >= *(V + 30 + v + 2)) {\r\nswp_freq = fOSC * 1000 + afcex_freq + swp_ofs;\r\n*SIG1 = *(V + 30 + v + 1);\r\n} else {\r\nswp_freq = fOSC * 1000 + afcex_freq + swp_ofs * 2;\r\n*SIG1 = *(V + 30 + v + 2);\r\n}\r\n} else if ((vmax == 0) && (vmin == 0) && (*(V + 30 + v) > SIGMIN)) {\r\nswp_freq = fOSC * 1000;\r\n*SIG1 = *(V + 30 + v);\r\n} else\r\nswp_freq = -1;\r\n} else\r\nswp_freq = -1;\r\nreturn swp_freq;\r\n}\r\nstatic void swp_info_get2(struct mb86a16_state *state,\r\nint smrt,\r\nint R,\r\nint swp_freq,\r\nint *afcex_freq,\r\nint *fOSC,\r\nunsigned char *AFCEX_L,\r\nunsigned char *AFCEX_H)\r\n{\r\nint AFCEX ;\r\nif (R == 0)\r\n*fOSC = (swp_freq + 1000) / 2000 * 2;\r\nelse\r\n*fOSC = (swp_freq + 500) / 1000;\r\nif (*fOSC >= swp_freq)\r\n*afcex_freq = *fOSC * 1000 - swp_freq;\r\nelse\r\n*afcex_freq = swp_freq - *fOSC * 1000;\r\nAFCEX = *afcex_freq * 8192 / state->master_clk;\r\n*AFCEX_L = AFCEX & 0x00ff;\r\n*AFCEX_H = (AFCEX & 0x0f00) >> 8;\r\n}\r\nstatic void afcex_info_get(struct mb86a16_state *state,\r\nint afcex_freq,\r\nunsigned char *AFCEX_L,\r\nunsigned char *AFCEX_H)\r\n{\r\nint AFCEX ;\r\nAFCEX = afcex_freq * 8192 / state->master_clk;\r\n*AFCEX_L = AFCEX & 0x00ff;\r\n*AFCEX_H = (AFCEX & 0x0f00) >> 8;\r\n}\r\nstatic int SEQ_set(struct mb86a16_state *state, unsigned char loop)\r\n{\r\nif (mb86a16_write(state, 0x32, 0x02 | (loop << 2)) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iq_vt_set(struct mb86a16_state *state, unsigned char IQINV)\r\n{\r\nif (mb86a16_write(state, 0x06, 0xdf | (IQINV << 5)) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int FEC_srst(struct mb86a16_state *state)\r\n{\r\nif (mb86a16_write(state, MB86A16_RESET, 0x02) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int S2T_set(struct mb86a16_state *state, unsigned char S2T)\r\n{\r\nif (mb86a16_write(state, 0x34, 0x70 | S2T) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int S45T_set(struct mb86a16_state *state, unsigned char S4T, unsigned char S5T)\r\n{\r\nif (mb86a16_write(state, 0x35, 0x00 | (S5T << 4) | S4T) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb86a16_set_fe(struct mb86a16_state *state)\r\n{\r\nu8 agcval, cnmval;\r\nint i, j;\r\nint fOSC = 0;\r\nint fOSC_start = 0;\r\nint wait_t;\r\nint fcp;\r\nint swp_ofs;\r\nint V[60];\r\nu8 SIG1MIN;\r\nunsigned char CREN, AFCEN, AFCEXEN;\r\nunsigned char SIG1;\r\nunsigned char TIMINT1, TIMINT2, TIMEXT;\r\nunsigned char S0T, S1T;\r\nunsigned char S2T;\r\nunsigned char S4T, S5T;\r\nunsigned char AFCEX_L, AFCEX_H;\r\nunsigned char R;\r\nunsigned char VIRM;\r\nunsigned char ETH, VIA;\r\nunsigned char junk;\r\nint loop;\r\nint ftemp;\r\nint v, vmax, vmin;\r\nint vmax_his, vmin_his;\r\nint swp_freq, prev_swp_freq[20];\r\nint prev_freq_num;\r\nint signal_dupl;\r\nint afcex_freq;\r\nint signal;\r\nint afcerr;\r\nint temp_freq, delta_freq;\r\nint dagcm[4];\r\nint smrt_d;\r\nint n;\r\nint ret = -1;\r\nint sync;\r\ndprintk(verbose, MB86A16_INFO, 1, "freq=%d Mhz, symbrt=%d Ksps", state->frequency, state->srate);\r\nfcp = 3000;\r\nswp_ofs = state->srate / 4;\r\nfor (i = 0; i < 60; i++)\r\nV[i] = -1;\r\nfor (i = 0; i < 20; i++)\r\nprev_swp_freq[i] = 0;\r\nSIG1MIN = 25;\r\nfor (n = 0; ((n < 3) && (ret == -1)); n++) {\r\nSEQ_set(state, 0);\r\niq_vt_set(state, 0);\r\nCREN = 0;\r\nAFCEN = 0;\r\nAFCEXEN = 1;\r\nTIMINT1 = 0;\r\nTIMINT2 = 1;\r\nTIMEXT = 2;\r\nS1T = 0;\r\nS0T = 0;\r\nif (initial_set(state) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "initial set failed");\r\nreturn -1;\r\n}\r\nif (DAGC_data_set(state, 3, 2) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "DAGC data set error");\r\nreturn -1;\r\n}\r\nif (EN_set(state, CREN, AFCEN) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "EN set error");\r\nreturn -1;\r\n}\r\nif (AFCEXEN_set(state, AFCEXEN, state->srate) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "AFCEXEN set error");\r\nreturn -1;\r\n}\r\nif (CNTM_set(state, TIMINT1, TIMINT2, TIMEXT) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "CNTM set error");\r\nreturn -1;\r\n}\r\nif (S01T_set(state, S1T, S0T) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "S01T set error");\r\nreturn -1;\r\n}\r\nsmrt_info_get(state, state->srate);\r\nif (smrt_set(state, state->srate) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "smrt info get error");\r\nreturn -1;\r\n}\r\nR = vco_dev_get(state, state->srate);\r\nif (R == 1)\r\nfOSC_start = state->frequency;\r\nelse if (R == 0) {\r\nif (state->frequency % 2 == 0) {\r\nfOSC_start = state->frequency;\r\n} else {\r\nfOSC_start = state->frequency + 1;\r\nif (fOSC_start > 2150)\r\nfOSC_start = state->frequency - 1;\r\n}\r\n}\r\nloop = 1;\r\nftemp = fOSC_start * 1000;\r\nvmax = 0 ;\r\nwhile (loop == 1) {\r\nftemp = ftemp + swp_ofs;\r\nvmax++;\r\nif (ftemp > 2150000) {\r\nloop = 0;\r\nvmax--;\r\n} else {\r\nif ((ftemp == 2150000) ||\r\n(ftemp - state->frequency * 1000 >= fcp + state->srate / 4))\r\nloop = 0;\r\n}\r\n}\r\nloop = 1;\r\nftemp = fOSC_start * 1000;\r\nvmin = 0 ;\r\nwhile (loop == 1) {\r\nftemp = ftemp - swp_ofs;\r\nvmin--;\r\nif (ftemp < 950000) {\r\nloop = 0;\r\nvmin++;\r\n} else {\r\nif ((ftemp == 950000) ||\r\n(state->frequency * 1000 - ftemp >= fcp + state->srate / 4))\r\nloop = 0;\r\n}\r\n}\r\nwait_t = (8000 + state->srate / 2) / state->srate;\r\nif (wait_t == 0)\r\nwait_t = 1;\r\ni = 0;\r\nj = 0;\r\nprev_freq_num = 0;\r\nloop = 1;\r\nsignal = 0;\r\nvmax_his = 0;\r\nvmin_his = 0;\r\nv = 0;\r\nwhile (loop == 1) {\r\nswp_info_get(state, fOSC_start, state->srate,\r\nv, R, swp_ofs, &fOSC,\r\n&afcex_freq, &AFCEX_L, &AFCEX_H);\r\nudelay(100);\r\nif (rf_val_set(state, fOSC, state->srate, R) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "rf val set error");\r\nreturn -1;\r\n}\r\nudelay(100);\r\nif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "afcex data set error");\r\nreturn -1;\r\n}\r\nif (srst(state) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "srst error");\r\nreturn -1;\r\n}\r\nmsleep_interruptible(wait_t);\r\nif (mb86a16_read(state, 0x37, &SIG1) != 2) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -1;\r\n}\r\nV[30 + v] = SIG1 ;\r\nswp_freq = swp_freq_calcuation(state, i, v, V, vmax, vmin,\r\nSIG1MIN, fOSC, afcex_freq,\r\nswp_ofs, &SIG1);\r\nsignal_dupl = 0;\r\nfor (j = 0; j < prev_freq_num; j++) {\r\nif ((ABS(prev_swp_freq[j] - swp_freq)) < (swp_ofs * 3 / 2)) {\r\nsignal_dupl = 1;\r\ndprintk(verbose, MB86A16_INFO, 1, "Probably Duplicate Signal, j = %d", j);\r\n}\r\n}\r\nif ((signal_dupl == 0) && (swp_freq > 0) && (ABS(swp_freq - state->frequency * 1000) < fcp + state->srate / 6)) {\r\ndprintk(verbose, MB86A16_DEBUG, 1, "------ Signal detect ------ [swp_freq=[%07d, srate=%05d]]", swp_freq, state->srate);\r\nprev_swp_freq[prev_freq_num] = swp_freq;\r\nprev_freq_num++;\r\nswp_info_get2(state, state->srate, R, swp_freq,\r\n&afcex_freq, &fOSC,\r\n&AFCEX_L, &AFCEX_H);\r\nif (rf_val_set(state, fOSC, state->srate, R) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "rf val set error");\r\nreturn -1;\r\n}\r\nif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "afcex data set error");\r\nreturn -1;\r\n}\r\nsignal = signal_det(state, state->srate, &SIG1);\r\nif (signal == 1) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "***** Signal Found *****");\r\nloop = 0;\r\n} else {\r\ndprintk(verbose, MB86A16_ERROR, 1, "!!!!! No signal !!!!!, try again...");\r\nsmrt_info_get(state, state->srate);\r\nif (smrt_set(state, state->srate) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "smrt set error");\r\nreturn -1;\r\n}\r\n}\r\n}\r\nif (v > vmax)\r\nvmax_his = 1 ;\r\nif (v < vmin)\r\nvmin_his = 1 ;\r\ni++;\r\nif ((i % 2 == 1) && (vmax_his == 1))\r\ni++;\r\nif ((i % 2 == 0) && (vmin_his == 1))\r\ni++;\r\nif (i % 2 == 1)\r\nv = (i + 1) / 2;\r\nelse\r\nv = -i / 2;\r\nif ((vmax_his == 1) && (vmin_his == 1))\r\nloop = 0 ;\r\n}\r\nif (signal == 1) {\r\ndprintk(verbose, MB86A16_INFO, 1, " Start Freq Error Check");\r\nS1T = 7 ;\r\nS0T = 1 ;\r\nCREN = 0 ;\r\nAFCEN = 1 ;\r\nAFCEXEN = 0 ;\r\nif (S01T_set(state, S1T, S0T) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "S01T set error");\r\nreturn -1;\r\n}\r\nsmrt_info_get(state, state->srate);\r\nif (smrt_set(state, state->srate) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "smrt set error");\r\nreturn -1;\r\n}\r\nif (EN_set(state, CREN, AFCEN) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "EN set error");\r\nreturn -1;\r\n}\r\nif (AFCEXEN_set(state, AFCEXEN, state->srate) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "AFCEXEN set error");\r\nreturn -1;\r\n}\r\nafcex_info_get(state, afcex_freq, &AFCEX_L, &AFCEX_H);\r\nif (afcofs_data_set(state, AFCEX_L, AFCEX_H) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "AFCOFS data set error");\r\nreturn -1;\r\n}\r\nif (srst(state) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "srst error");\r\nreturn -1;\r\n}\r\nwait_t = 200000 / state->master_clk + 200000 / state->srate;\r\nmsleep(wait_t);\r\nafcerr = afcerr_chk(state);\r\nif (afcerr == -1)\r\nreturn -1;\r\nswp_freq = fOSC * 1000 + afcerr ;\r\nAFCEXEN = 1 ;\r\nif (state->srate >= 1500)\r\nsmrt_d = state->srate / 3;\r\nelse\r\nsmrt_d = state->srate / 2;\r\nsmrt_info_get(state, smrt_d);\r\nif (smrt_set(state, smrt_d) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "smrt set error");\r\nreturn -1;\r\n}\r\nif (AFCEXEN_set(state, AFCEXEN, smrt_d) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "AFCEXEN set error");\r\nreturn -1;\r\n}\r\nR = vco_dev_get(state, smrt_d);\r\nif (DAGC_data_set(state, 2, 0) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "DAGC data set error");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\ntemp_freq = swp_freq + (i - 1) * state->srate / 8;\r\nswp_info_get2(state, smrt_d, R, temp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\r\nif (rf_val_set(state, fOSC, smrt_d, R) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "rf val set error");\r\nreturn -1;\r\n}\r\nif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "afcex data set error");\r\nreturn -1;\r\n}\r\nwait_t = 200000 / state->master_clk + 40000 / smrt_d;\r\nmsleep(wait_t);\r\ndagcm[i] = dagcm_val_get(state);\r\n}\r\nif ((dagcm[0] > dagcm[1]) &&\r\n(dagcm[0] > dagcm[2]) &&\r\n(dagcm[0] - dagcm[1] > 2 * (dagcm[2] - dagcm[1]))) {\r\ntemp_freq = swp_freq - 2 * state->srate / 8;\r\nswp_info_get2(state, smrt_d, R, temp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\r\nif (rf_val_set(state, fOSC, smrt_d, R) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "rf val set error");\r\nreturn -1;\r\n}\r\nif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "afcex data set");\r\nreturn -1;\r\n}\r\nwait_t = 200000 / state->master_clk + 40000 / smrt_d;\r\nmsleep(wait_t);\r\ndagcm[3] = dagcm_val_get(state);\r\nif (dagcm[3] > dagcm[1])\r\ndelta_freq = (dagcm[2] - dagcm[0] + dagcm[1] - dagcm[3]) * state->srate / 300;\r\nelse\r\ndelta_freq = 0;\r\n} else if ((dagcm[2] > dagcm[1]) &&\r\n(dagcm[2] > dagcm[0]) &&\r\n(dagcm[2] - dagcm[1] > 2 * (dagcm[0] - dagcm[1]))) {\r\ntemp_freq = swp_freq + 2 * state->srate / 8;\r\nswp_info_get2(state, smrt_d, R, temp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\r\nif (rf_val_set(state, fOSC, smrt_d, R) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "rf val set");\r\nreturn -1;\r\n}\r\nif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "afcex data set");\r\nreturn -1;\r\n}\r\nwait_t = 200000 / state->master_clk + 40000 / smrt_d;\r\nmsleep(wait_t);\r\ndagcm[3] = dagcm_val_get(state);\r\nif (dagcm[3] > dagcm[1])\r\ndelta_freq = (dagcm[2] - dagcm[0] + dagcm[3] - dagcm[1]) * state->srate / 300;\r\nelse\r\ndelta_freq = 0 ;\r\n} else {\r\ndelta_freq = 0 ;\r\n}\r\ndprintk(verbose, MB86A16_INFO, 1, "SWEEP Frequency = %d", swp_freq);\r\nswp_freq += delta_freq;\r\ndprintk(verbose, MB86A16_INFO, 1, "Adjusting .., DELTA Freq = %d, SWEEP Freq=%d", delta_freq, swp_freq);\r\nif (ABS(state->frequency * 1000 - swp_freq) > 3800) {\r\ndprintk(verbose, MB86A16_INFO, 1, "NO -- SIGNAL !");\r\n} else {\r\nS1T = 0;\r\nS0T = 3;\r\nCREN = 1;\r\nAFCEN = 0;\r\nAFCEXEN = 1;\r\nif (S01T_set(state, S1T, S0T) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "S01T set error");\r\nreturn -1;\r\n}\r\nif (DAGC_data_set(state, 0, 0) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "DAGC data set error");\r\nreturn -1;\r\n}\r\nR = vco_dev_get(state, state->srate);\r\nsmrt_info_get(state, state->srate);\r\nif (smrt_set(state, state->srate) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "smrt set error");\r\nreturn -1;\r\n}\r\nif (EN_set(state, CREN, AFCEN) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "EN set error");\r\nreturn -1;\r\n}\r\nif (AFCEXEN_set(state, AFCEXEN, state->srate) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "AFCEXEN set error");\r\nreturn -1;\r\n}\r\nswp_info_get2(state, state->srate, R, swp_freq, &afcex_freq, &fOSC, &AFCEX_L, &AFCEX_H);\r\nif (rf_val_set(state, fOSC, state->srate, R) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "rf val set error");\r\nreturn -1;\r\n}\r\nif (afcex_data_set(state, AFCEX_L, AFCEX_H) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "afcex data set error");\r\nreturn -1;\r\n}\r\nif (srst(state) < 0) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "srst error");\r\nreturn -1;\r\n}\r\nwait_t = 7 + (10000 + state->srate / 2) / state->srate;\r\nif (wait_t == 0)\r\nwait_t = 1;\r\nmsleep_interruptible(wait_t);\r\nif (mb86a16_read(state, 0x37, &SIG1) != 2) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nif (SIG1 > 110) {\r\nS2T = 4; S4T = 1; S5T = 6; ETH = 4; VIA = 6;\r\nwait_t = 7 + (917504 + state->srate / 2) / state->srate;\r\n} else if (SIG1 > 105) {\r\nS2T = 4; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\r\nwait_t = 7 + (1048576 + state->srate / 2) / state->srate;\r\n} else if (SIG1 > 85) {\r\nS2T = 5; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\r\nwait_t = 7 + (1310720 + state->srate / 2) / state->srate;\r\n} else if (SIG1 > 65) {\r\nS2T = 6; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\r\nwait_t = 7 + (1572864 + state->srate / 2) / state->srate;\r\n} else {\r\nS2T = 7; S4T = 2; S5T = 8; ETH = 7; VIA = 2;\r\nwait_t = 7 + (2097152 + state->srate / 2) / state->srate;\r\n}\r\nwait_t *= 2;\r\nS2T_set(state, S2T);\r\nS45T_set(state, S4T, S5T);\r\nVi_set(state, ETH, VIA);\r\nsrst(state);\r\nmsleep_interruptible(wait_t);\r\nsync = sync_chk(state, &VIRM);\r\ndprintk(verbose, MB86A16_INFO, 1, "-------- Viterbi=[%d] SYNC=[%d] ---------", VIRM, sync);\r\nif (VIRM) {\r\nif (VIRM == 4) {\r\nif (SIG1 > 110)\r\nwait_t = (786432 + state->srate / 2) / state->srate;\r\nelse\r\nwait_t = (1572864 + state->srate / 2) / state->srate;\r\nif (state->srate < 5000)\r\nmsleep_interruptible(wait_t);\r\nelse\r\nmsleep_interruptible(wait_t);\r\nif (sync_chk(state, &junk) == 0) {\r\niq_vt_set(state, 1);\r\nFEC_srst(state);\r\n}\r\n}\r\nif (SIG1 > 110)\r\nwait_t = (786432 + state->srate / 2) / state->srate;\r\nelse\r\nwait_t = (1572864 + state->srate / 2) / state->srate;\r\nmsleep_interruptible(wait_t);\r\nSEQ_set(state, 1);\r\n} else {\r\ndprintk(verbose, MB86A16_INFO, 1, "NO -- SYNC");\r\nSEQ_set(state, 1);\r\nret = -1;\r\n}\r\n}\r\n} else {\r\ndprintk(verbose, MB86A16_INFO, 1, "NO -- SIGNAL");\r\nret = -1;\r\n}\r\nsync = sync_chk(state, &junk);\r\nif (sync) {\r\ndprintk(verbose, MB86A16_INFO, 1, "******* SYNC *******");\r\nfreqerr_chk(state, state->frequency, state->srate, 1);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nmb86a16_read(state, 0x15, &agcval);\r\nmb86a16_read(state, 0x26, &cnmval);\r\ndprintk(verbose, MB86A16_INFO, 1, "AGC = %02x CNM = %02x", agcval, cnmval);\r\nreturn ret;\r\n}\r\nstatic int mb86a16_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *cmd)\r\n{\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 regs;\r\nif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCCOUT, 0x00) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_TONEOUT2, 0x04) < 0)\r\ngoto err;\r\nregs = 0x18;\r\nif (cmd->msg_len > 5 || cmd->msg_len < 4)\r\nreturn -EINVAL;\r\nfor (i = 0; i < cmd->msg_len; i++) {\r\nif (mb86a16_write(state, regs, cmd->msg[i]) < 0)\r\ngoto err;\r\nregs++;\r\n}\r\ni += 0x90;\r\nmsleep_interruptible(10);\r\nif (mb86a16_write(state, MB86A16_DCC1, i) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int mb86a16_send_diseqc_burst(struct dvb_frontend *fe, fe_sec_mini_cmd_t burst)\r\n{\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\nswitch (burst) {\r\ncase SEC_MINI_A:\r\nif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA |\r\nMB86A16_DCC1_TBEN |\r\nMB86A16_DCC1_TBO) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\r\ngoto err;\r\nbreak;\r\ncase SEC_MINI_B:\r\nif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA |\r\nMB86A16_DCC1_TBEN) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int mb86a16_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nif (mb86a16_write(state, MB86A16_TONEOUT2, 0x00) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA |\r\nMB86A16_DCC1_CTOE) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCCOUT, MB86A16_DCCOUT_DISEN) < 0)\r\ngoto err;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\nif (mb86a16_write(state, MB86A16_TONEOUT2, 0x04) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCC1, MB86A16_DCC1_DISTA) < 0)\r\ngoto err;\r\nif (mb86a16_write(state, MB86A16_DCCOUT, 0x00) < 0)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic enum dvbfe_search mb86a16_search(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\nstate->frequency = p->frequency / 1000;\r\nstate->srate = p->u.qpsk.symbol_rate / 1000;\r\nif (!mb86a16_set_fe(state)) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "Successfully acquired LOCK");\r\nreturn DVBFE_ALGO_SEARCH_SUCCESS;\r\n}\r\ndprintk(verbose, MB86A16_ERROR, 1, "Lock acquisition failed!");\r\nreturn DVBFE_ALGO_SEARCH_FAILED;\r\n}\r\nstatic void mb86a16_release(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstatic int mb86a16_init(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mb86a16_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mb86a16_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nu8 ber_mon, ber_tab, ber_lsb, ber_mid, ber_msb, ber_tim, ber_rst;\r\nu32 timer;\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\n*ber = 0;\r\nif (mb86a16_read(state, MB86A16_BERMON, &ber_mon) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, MB86A16_BERTAB, &ber_tab) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, MB86A16_BERLSB, &ber_lsb) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, MB86A16_BERMID, &ber_mid) != 2)\r\ngoto err;\r\nif (mb86a16_read(state, MB86A16_BERMSB, &ber_msb) != 2)\r\ngoto err;\r\nif (ber_mon & 0x04) {\r\n*ber = ber_tab & 0x1f;\r\ndprintk(verbose, MB86A16_DEBUG, 1, "BER coarse=[0x%02x]", *ber);\r\nif (ber_mon & 0x01) {\r\nber_rst = ber_mon >> 3;\r\n*ber = (((ber_msb << 8) | ber_mid) << 8) | ber_lsb;\r\nif (ber_rst == 0)\r\ntimer = 12500000;\r\nif (ber_rst == 1)\r\ntimer = 25000000;\r\nif (ber_rst == 2)\r\ntimer = 50000000;\r\nif (ber_rst == 3)\r\ntimer = 100000000;\r\n*ber /= timer;\r\ndprintk(verbose, MB86A16_DEBUG, 1, "BER fine=[0x%02x]", *ber);\r\n} else {\r\nber_tim = ber_mon >> 1;\r\n*ber = (((ber_msb << 8) | ber_mid) << 8) | ber_lsb;\r\nif (ber_tim == 0)\r\ntimer = 16;\r\nif (ber_tim == 1)\r\ntimer = 24;\r\n*ber /= 2 ^ timer;\r\ndprintk(verbose, MB86A16_DEBUG, 1, "BER fine=[0x%02x]", *ber);\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int mb86a16_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nu8 agcm = 0;\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\n*strength = 0;\r\nif (mb86a16_read(state, MB86A16_AGCM, &agcm) != 2) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\n*strength = ((0xff - agcm) * 100) / 256;\r\ndprintk(verbose, MB86A16_DEBUG, 1, "Signal strength=[%d %%]", (u8) *strength);\r\n*strength = (0xffff - 0xff) + agcm;\r\nreturn 0;\r\n}\r\nstatic int mb86a16_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\nint i = 0;\r\nint low_tide = 2, high_tide = 30, q_level;\r\nu8 cn;\r\n*snr = 0;\r\nif (mb86a16_read(state, 0x26, &cn) != 2) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cnr_tab); i++) {\r\nif (cn < cnr_tab[i].cn_reg) {\r\n*snr = cnr_tab[i].cn_val;\r\nbreak;\r\n}\r\n}\r\nq_level = (*snr * 100) / (high_tide - low_tide);\r\ndprintk(verbose, MB86A16_ERROR, 1, "SNR (Quality) = [%d dB], Level=%d %%", *snr, q_level);\r\n*snr = (0xffff - 0xff) + *snr;\r\nreturn 0;\r\n}\r\nstatic int mb86a16_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nu8 dist;\r\nstruct mb86a16_state *state = fe->demodulator_priv;\r\nif (mb86a16_read(state, MB86A16_DISTMON, &dist) != 2) {\r\ndprintk(verbose, MB86A16_ERROR, 1, "I2C transfer error");\r\nreturn -EREMOTEIO;\r\n}\r\n*ucblocks = dist;\r\nreturn 0;\r\n}\r\nstatic enum dvbfe_algo mb86a16_frontend_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_CUSTOM;\r\n}\r\nstruct dvb_frontend *mb86a16_attach(const struct mb86a16_config *config,\r\nstruct i2c_adapter *i2c_adap)\r\n{\r\nu8 dev_id = 0;\r\nstruct mb86a16_state *state = NULL;\r\nstate = kmalloc(sizeof(struct mb86a16_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c_adap = i2c_adap;\r\nmb86a16_read(state, 0x7f, &dev_id);\r\nif (dev_id != 0xfe)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &mb86a16_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nstate->frontend.ops.set_voltage = state->config->set_voltage;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
