static inline port_t* dev_to_port(struct net_device *dev)\r\n{\r\nreturn (port_t *)dev_to_hdlc(dev)->priv;\r\n}\r\nstatic inline port_status_t* get_status(port_t *port)\r\n{\r\nreturn &port->card->status->port_status[port->node];\r\n}\r\nstatic inline dma_addr_t pci_map_single_debug(struct pci_dev *pdev, void *ptr,\r\nsize_t size, int direction)\r\n{\r\ndma_addr_t addr = pci_map_single(pdev, ptr, size, direction);\r\nif (addr + size > 0x100000000LL)\r\npr_crit("%s: pci_map_single() returned memory at 0x%llx!\n",\r\npci_name(pdev), (unsigned long long)addr);\r\nreturn addr;\r\n}\r\nstatic inline void wanxl_cable_intr(port_t *port)\r\n{\r\nu32 value = get_status(port)->cable;\r\nint valid = 1;\r\nconst char *cable, *pm, *dte = "", *dsr = "", *dcd = "";\r\nswitch(value & 0x7) {\r\ncase STATUS_CABLE_V35: cable = "V.35"; break;\r\ncase STATUS_CABLE_X21: cable = "X.21"; break;\r\ncase STATUS_CABLE_V24: cable = "V.24"; break;\r\ncase STATUS_CABLE_EIA530: cable = "EIA530"; break;\r\ncase STATUS_CABLE_NONE: cable = "no"; break;\r\ndefault: cable = "invalid";\r\n}\r\nswitch((value >> STATUS_CABLE_PM_SHIFT) & 0x7) {\r\ncase STATUS_CABLE_V35: pm = "V.35"; break;\r\ncase STATUS_CABLE_X21: pm = "X.21"; break;\r\ncase STATUS_CABLE_V24: pm = "V.24"; break;\r\ncase STATUS_CABLE_EIA530: pm = "EIA530"; break;\r\ncase STATUS_CABLE_NONE: pm = "no personality"; valid = 0; break;\r\ndefault: pm = "invalid personality"; valid = 0;\r\n}\r\nif (valid) {\r\nif ((value & 7) == ((value >> STATUS_CABLE_PM_SHIFT) & 7)) {\r\ndsr = (value & STATUS_CABLE_DSR) ? ", DSR ON" :\r\n", DSR off";\r\ndcd = (value & STATUS_CABLE_DCD) ? ", carrier ON" :\r\n", carrier off";\r\n}\r\ndte = (value & STATUS_CABLE_DCE) ? " DCE" : " DTE";\r\n}\r\nnetdev_info(port->dev, "%s%s module, %s cable%s%s\n",\r\npm, dte, cable, dsr, dcd);\r\nif (value & STATUS_CABLE_DCD)\r\nnetif_carrier_on(port->dev);\r\nelse\r\nnetif_carrier_off(port->dev);\r\n}\r\nstatic inline void wanxl_tx_intr(port_t *port)\r\n{\r\nstruct net_device *dev = port->dev;\r\nwhile (1) {\r\ndesc_t *desc = &get_status(port)->tx_descs[port->tx_in];\r\nstruct sk_buff *skb = port->tx_skbs[port->tx_in];\r\nswitch (desc->stat) {\r\ncase PACKET_FULL:\r\ncase PACKET_EMPTY:\r\nnetif_wake_queue(dev);\r\nreturn;\r\ncase PACKET_UNDERRUN:\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_fifo_errors++;\r\nbreak;\r\ndefault:\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\n}\r\ndesc->stat = PACKET_EMPTY;\r\npci_unmap_single(port->card->pdev, desc->address, skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\nport->tx_in = (port->tx_in + 1) % TX_BUFFERS;\r\n}\r\n}\r\nstatic inline void wanxl_rx_intr(card_t *card)\r\n{\r\ndesc_t *desc;\r\nwhile (desc = &card->status->rx_descs[card->rx_in],\r\ndesc->stat != PACKET_EMPTY) {\r\nif ((desc->stat & PACKET_PORT_MASK) > card->n_ports)\r\npr_crit("%s: received packet for nonexistent port\n",\r\npci_name(card->pdev));\r\nelse {\r\nstruct sk_buff *skb = card->rx_skbs[card->rx_in];\r\nport_t *port = &card->ports[desc->stat &\r\nPACKET_PORT_MASK];\r\nstruct net_device *dev = port->dev;\r\nif (!skb)\r\ndev->stats.rx_dropped++;\r\nelse {\r\npci_unmap_single(card->pdev, desc->address,\r\nBUFFER_LENGTH,\r\nPCI_DMA_FROMDEVICE);\r\nskb_put(skb, desc->length);\r\n#ifdef DEBUG_PKT\r\nprintk(KERN_DEBUG "%s RX(%i):", dev->name,\r\nskb->len);\r\ndebug_frame(skb);\r\n#endif\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nskb = NULL;\r\n}\r\nif (!skb) {\r\nskb = dev_alloc_skb(BUFFER_LENGTH);\r\ndesc->address = skb ?\r\npci_map_single(card->pdev, skb->data,\r\nBUFFER_LENGTH,\r\nPCI_DMA_FROMDEVICE) : 0;\r\ncard->rx_skbs[card->rx_in] = skb;\r\n}\r\n}\r\ndesc->stat = PACKET_EMPTY;\r\ncard->rx_in = (card->rx_in + 1) % RX_QUEUE_LENGTH;\r\n}\r\n}\r\nstatic irqreturn_t wanxl_intr(int irq, void* dev_id)\r\n{\r\ncard_t *card = dev_id;\r\nint i;\r\nu32 stat;\r\nint handled = 0;\r\nwhile((stat = readl(card->plx + PLX_DOORBELL_FROM_CARD)) != 0) {\r\nhandled = 1;\r\nwritel(stat, card->plx + PLX_DOORBELL_FROM_CARD);\r\nfor (i = 0; i < card->n_ports; i++) {\r\nif (stat & (1 << (DOORBELL_FROM_CARD_TX_0 + i)))\r\nwanxl_tx_intr(&card->ports[i]);\r\nif (stat & (1 << (DOORBELL_FROM_CARD_CABLE_0 + i)))\r\nwanxl_cable_intr(&card->ports[i]);\r\n}\r\nif (stat & (1 << DOORBELL_FROM_CARD_RX))\r\nwanxl_rx_intr(card);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic netdev_tx_t wanxl_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\ndesc_t *desc;\r\nspin_lock(&port->lock);\r\ndesc = &get_status(port)->tx_descs[port->tx_out];\r\nif (desc->stat != PACKET_EMPTY) {\r\n#ifdef DEBUG_PKT\r\nprintk(KERN_DEBUG "%s: transmitter buffer full\n", dev->name);\r\n#endif\r\nnetif_stop_queue(dev);\r\nspin_unlock(&port->lock);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n#ifdef DEBUG_PKT\r\nprintk(KERN_DEBUG "%s TX(%i):", dev->name, skb->len);\r\ndebug_frame(skb);\r\n#endif\r\nport->tx_skbs[port->tx_out] = skb;\r\ndesc->address = pci_map_single(port->card->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\ndesc->length = skb->len;\r\ndesc->stat = PACKET_FULL;\r\nwritel(1 << (DOORBELL_TO_CARD_TX_0 + port->node),\r\nport->card->plx + PLX_DOORBELL_TO_CARD);\r\nport->tx_out = (port->tx_out + 1) % TX_BUFFERS;\r\nif (get_status(port)->tx_descs[port->tx_out].stat != PACKET_EMPTY) {\r\nnetif_stop_queue(dev);\r\n#ifdef DEBUG_PKT\r\nprintk(KERN_DEBUG "%s: transmitter buffer full\n", dev->name);\r\n#endif\r\n}\r\nspin_unlock(&port->lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int wanxl_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nif (encoding != ENCODING_NRZ &&\r\nencoding != ENCODING_NRZI)\r\nreturn -EINVAL;\r\nif (parity != PARITY_NONE &&\r\nparity != PARITY_CRC32_PR1_CCITT &&\r\nparity != PARITY_CRC16_PR1_CCITT &&\r\nparity != PARITY_CRC32_PR0_CCITT &&\r\nparity != PARITY_CRC16_PR0_CCITT)\r\nreturn -EINVAL;\r\nget_status(port)->encoding = encoding;\r\nget_status(port)->parity = parity;\r\nreturn 0;\r\n}\r\nstatic int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings line;\r\nport_t *port = dev_to_port(dev);\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nline.clock_type = get_status(port)->clocking;\r\nline.clock_rate = 0;\r\nline.loopback = 0;\r\nif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\r\nsize))\r\nreturn -EFAULT;\r\nif (line.clock_type != CLOCK_EXT &&\r\nline.clock_type != CLOCK_TXFROMRX)\r\nreturn -EINVAL;\r\nif (line.loopback != 0)\r\nreturn -EINVAL;\r\nget_status(port)->clocking = line.clock_type;\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic int wanxl_open(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nu8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;\r\nunsigned long timeout;\r\nint i;\r\nif (get_status(port)->open) {\r\nnetdev_err(dev, "port already open\n");\r\nreturn -EIO;\r\n}\r\nif ((i = hdlc_open(dev)) != 0)\r\nreturn i;\r\nport->tx_in = port->tx_out = 0;\r\nfor (i = 0; i < TX_BUFFERS; i++)\r\nget_status(port)->tx_descs[i].stat = PACKET_EMPTY;\r\nwritel(1 << (DOORBELL_TO_CARD_OPEN_0 + port->node), dbr);\r\ntimeout = jiffies + HZ;\r\ndo {\r\nif (get_status(port)->open) {\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\n} while (time_after(timeout, jiffies));\r\nnetdev_err(dev, "unable to open port\n");\r\nwritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node), dbr);\r\nreturn -EFAULT;\r\n}\r\nstatic int wanxl_close(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nunsigned long timeout;\r\nint i;\r\nhdlc_close(dev);\r\nwritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node),\r\nport->card->plx + PLX_DOORBELL_TO_CARD);\r\ntimeout = jiffies + HZ;\r\ndo {\r\nif (!get_status(port)->open)\r\nbreak;\r\n} while (time_after(timeout, jiffies));\r\nif (get_status(port)->open)\r\nnetdev_err(dev, "unable to close port\n");\r\nnetif_stop_queue(dev);\r\nfor (i = 0; i < TX_BUFFERS; i++) {\r\ndesc_t *desc = &get_status(port)->tx_descs[i];\r\nif (desc->stat != PACKET_EMPTY) {\r\ndesc->stat = PACKET_EMPTY;\r\npci_unmap_single(port->card->pdev, desc->address,\r\nport->tx_skbs[i]->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb(port->tx_skbs[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *wanxl_get_stats(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\ndev->stats.rx_over_errors = get_status(port)->rx_overruns;\r\ndev->stats.rx_frame_errors = get_status(port)->rx_frame_errors;\r\ndev->stats.rx_errors = dev->stats.rx_over_errors +\r\ndev->stats.rx_frame_errors;\r\nreturn &dev->stats;\r\n}\r\nstatic int wanxl_puts_command(card_t *card, u32 cmd)\r\n{\r\nunsigned long timeout = jiffies + 5 * HZ;\r\nwritel(cmd, card->plx + PLX_MAILBOX_1);\r\ndo {\r\nif (readl(card->plx + PLX_MAILBOX_1) == 0)\r\nreturn 0;\r\nschedule();\r\n}while (time_after(timeout, jiffies));\r\nreturn -1;\r\n}\r\nstatic void wanxl_reset(card_t *card)\r\n{\r\nu32 old_value = readl(card->plx + PLX_CONTROL) & ~PLX_CTL_RESET;\r\nwritel(0x80, card->plx + PLX_MAILBOX_0);\r\nwritel(old_value | PLX_CTL_RESET, card->plx + PLX_CONTROL);\r\nreadl(card->plx + PLX_CONTROL);\r\nudelay(1);\r\nwritel(old_value, card->plx + PLX_CONTROL);\r\nreadl(card->plx + PLX_CONTROL);\r\n}\r\nstatic void wanxl_pci_remove_one(struct pci_dev *pdev)\r\n{\r\ncard_t *card = pci_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < card->n_ports; i++) {\r\nunregister_hdlc_device(card->ports[i].dev);\r\nfree_netdev(card->ports[i].dev);\r\n}\r\nif (card->irq)\r\nfree_irq(card->irq, card);\r\nwanxl_reset(card);\r\nfor (i = 0; i < RX_QUEUE_LENGTH; i++)\r\nif (card->rx_skbs[i]) {\r\npci_unmap_single(card->pdev,\r\ncard->status->rx_descs[i].address,\r\nBUFFER_LENGTH, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(card->rx_skbs[i]);\r\n}\r\nif (card->plx)\r\niounmap(card->plx);\r\nif (card->status)\r\npci_free_consistent(pdev, sizeof(card_status_t),\r\ncard->status, card->status_address);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nkfree(card);\r\n}\r\nstatic int __devinit wanxl_pci_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\ncard_t *card;\r\nu32 ramsize, stat;\r\nunsigned long timeout;\r\nu32 plx_phy;\r\nu32 mem_phy;\r\nu8 __iomem *mem;\r\nint i, ports, alloc_size;\r\n#ifndef MODULE\r\npr_info_once("%s\n", version);\r\n#endif\r\ni = pci_enable_device(pdev);\r\nif (i)\r\nreturn i;\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(28)) ||\r\npci_set_dma_mask(pdev, DMA_BIT_MASK(28))) {\r\npr_err("No usable DMA configuration\n");\r\nreturn -EIO;\r\n}\r\ni = pci_request_regions(pdev, "wanXL");\r\nif (i) {\r\npci_disable_device(pdev);\r\nreturn i;\r\n}\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_SBE_WANXL100: ports = 1; break;\r\ncase PCI_DEVICE_ID_SBE_WANXL200: ports = 2; break;\r\ndefault: ports = 4;\r\n}\r\nalloc_size = sizeof(card_t) + ports * sizeof(port_t);\r\ncard = kzalloc(alloc_size, GFP_KERNEL);\r\nif (card == NULL) {\r\npr_err("%s: unable to allocate memory\n", pci_name(pdev));\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nreturn -ENOBUFS;\r\n}\r\npci_set_drvdata(pdev, card);\r\ncard->pdev = pdev;\r\ncard->status = pci_alloc_consistent(pdev, sizeof(card_status_t),\r\n&card->status_address);\r\nif (card->status == NULL) {\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENOBUFS;\r\n}\r\n#ifdef DEBUG_PCI\r\nprintk(KERN_DEBUG "wanXL %s: pci_alloc_consistent() returned memory"\r\n" at 0x%LX\n", pci_name(pdev),\r\n(unsigned long long)card->status_address);\r\n#endif\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)) ||\r\npci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\npr_err("No usable DMA configuration\n");\r\nwanxl_pci_remove_one(pdev);\r\nreturn -EIO;\r\n}\r\nplx_phy = pci_resource_start(pdev, 0);\r\ncard->plx = ioremap_nocache(plx_phy, 0x70);\r\nif (!card->plx) {\r\npr_err("ioremap() failed\n");\r\nwanxl_pci_remove_one(pdev);\r\nreturn -EFAULT;\r\n}\r\n#if RESET_WHILE_LOADING\r\nwanxl_reset(card);\r\n#endif\r\ntimeout = jiffies + 20 * HZ;\r\nwhile ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {\r\nif (time_before(timeout, jiffies)) {\r\npr_warn("%s: timeout waiting for PUTS to complete\n",\r\npci_name(pdev));\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENODEV;\r\n}\r\nswitch(stat & 0xC0) {\r\ncase 0x00:\r\ncase 0x80:\r\nbreak;\r\ndefault:\r\npr_warn("%s: PUTS test 0x%X failed\n",\r\npci_name(pdev), stat & 0x30);\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENODEV;\r\n}\r\nschedule();\r\n}\r\nramsize = readl(card->plx + PLX_MAILBOX_2) & MBX2_MEMSZ_MASK;\r\nmem_phy = pci_resource_start(pdev, 2);\r\nif (ramsize < BUFFERS_ADDR +\r\n(TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports) {\r\npr_warn("%s: no enough on-board RAM (%u bytes detected, %u bytes required)\n",\r\npci_name(pdev), ramsize,\r\nBUFFERS_ADDR +\r\n(TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports);\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENODEV;\r\n}\r\nif (wanxl_puts_command(card, MBX1_CMD_BSWAP)) {\r\npr_warn("%s: unable to Set Byte Swap Mode\n", pci_name(pdev));\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\r\nstruct sk_buff *skb = dev_alloc_skb(BUFFER_LENGTH);\r\ncard->rx_skbs[i] = skb;\r\nif (skb)\r\ncard->status->rx_descs[i].address =\r\npci_map_single(card->pdev, skb->data,\r\nBUFFER_LENGTH,\r\nPCI_DMA_FROMDEVICE);\r\n}\r\nmem = ioremap_nocache(mem_phy, PDM_OFFSET + sizeof(firmware));\r\nif (!mem) {\r\npr_err("ioremap() failed\n");\r\nwanxl_pci_remove_one(pdev);\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < sizeof(firmware); i += 4)\r\nwritel(ntohl(*(__be32*)(firmware + i)), mem + PDM_OFFSET + i);\r\nfor (i = 0; i < ports; i++)\r\nwritel(card->status_address +\r\n(void *)&card->status->port_status[i] -\r\n(void *)card->status, mem + PDM_OFFSET + 4 + i * 4);\r\nwritel(card->status_address, mem + PDM_OFFSET + 20);\r\nwritel(PDM_OFFSET, mem);\r\niounmap(mem);\r\nwritel(0, card->plx + PLX_MAILBOX_5);\r\nif (wanxl_puts_command(card, MBX1_CMD_ABORTJ)) {\r\npr_warn("%s: unable to Abort and Jump\n", pci_name(pdev));\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENODEV;\r\n}\r\nstat = 0;\r\ntimeout = jiffies + 5 * HZ;\r\ndo {\r\nif ((stat = readl(card->plx + PLX_MAILBOX_5)) != 0)\r\nbreak;\r\nschedule();\r\n}while (time_after(timeout, jiffies));\r\nif (!stat) {\r\npr_warn("%s: timeout while initializing card firmware\n",\r\npci_name(pdev));\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENODEV;\r\n}\r\n#if DETECT_RAM\r\nramsize = stat;\r\n#endif\r\npr_info("%s: at 0x%X, %u KB of RAM at 0x%X, irq %u\n",\r\npci_name(pdev), plx_phy, ramsize / 1024, mem_phy, pdev->irq);\r\nif (request_irq(pdev->irq, wanxl_intr, IRQF_SHARED, "wanXL", card)) {\r\npr_warn("%s: could not allocate IRQ%i\n",\r\npci_name(pdev), pdev->irq);\r\nwanxl_pci_remove_one(pdev);\r\nreturn -EBUSY;\r\n}\r\ncard->irq = pdev->irq;\r\nfor (i = 0; i < ports; i++) {\r\nhdlc_device *hdlc;\r\nport_t *port = &card->ports[i];\r\nstruct net_device *dev = alloc_hdlcdev(port);\r\nif (!dev) {\r\npr_err("%s: unable to allocate memory\n",\r\npci_name(pdev));\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENOMEM;\r\n}\r\nport->dev = dev;\r\nhdlc = dev_to_hdlc(dev);\r\nspin_lock_init(&port->lock);\r\ndev->tx_queue_len = 50;\r\ndev->netdev_ops = &wanxl_ops;\r\nhdlc->attach = wanxl_attach;\r\nhdlc->xmit = wanxl_xmit;\r\nport->card = card;\r\nport->node = i;\r\nget_status(port)->clocking = CLOCK_EXT;\r\nif (register_hdlc_device(dev)) {\r\npr_err("%s: unable to register hdlc device\n",\r\npci_name(pdev));\r\nfree_netdev(dev);\r\nwanxl_pci_remove_one(pdev);\r\nreturn -ENOBUFS;\r\n}\r\ncard->n_ports++;\r\n}\r\npr_info("%s: port", pci_name(pdev));\r\nfor (i = 0; i < ports; i++)\r\npr_cont("%s #%i: %s",\r\ni ? "," : "", i, card->ports[i].dev->name);\r\npr_cont("\n");\r\nfor (i = 0; i < ports; i++)\r\nwanxl_cable_intr(&card->ports[i]);\r\nreturn 0;\r\n}\r\nstatic int __init wanxl_init_module(void)\r\n{\r\n#ifdef MODULE\r\npr_info("%s\n", version);\r\n#endif\r\nreturn pci_register_driver(&wanxl_pci_driver);\r\n}\r\nstatic void __exit wanxl_cleanup_module(void)\r\n{\r\npci_unregister_driver(&wanxl_pci_driver);\r\n}
