static void get_index(const struct prio_tree_root *root,\r\nconst struct prio_tree_node *node,\r\nunsigned long *radix, unsigned long *heap)\r\n{\r\nif (root->raw) {\r\nstruct vm_area_struct *vma = prio_tree_entry(\r\nnode, struct vm_area_struct, shared.prio_tree_node);\r\n*radix = RADIX_INDEX(vma);\r\n*heap = HEAP_INDEX(vma);\r\n}\r\nelse {\r\n*radix = node->start;\r\n*heap = node->last;\r\n}\r\n}\r\nvoid __init prio_tree_init(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(index_bits_to_maxindex) - 1; i++)\r\nindex_bits_to_maxindex[i] = (1UL << (i + 1)) - 1;\r\nindex_bits_to_maxindex[ARRAY_SIZE(index_bits_to_maxindex) - 1] = ~0UL;\r\n}\r\nstatic inline unsigned long prio_tree_maxindex(unsigned int bits)\r\n{\r\nreturn index_bits_to_maxindex[bits - 1];\r\n}\r\nstatic struct prio_tree_node *prio_tree_expand(struct prio_tree_root *root,\r\nstruct prio_tree_node *node, unsigned long max_heap_index)\r\n{\r\nstruct prio_tree_node *first = NULL, *prev, *last = NULL;\r\nif (max_heap_index > prio_tree_maxindex(root->index_bits))\r\nroot->index_bits++;\r\nwhile (max_heap_index > prio_tree_maxindex(root->index_bits)) {\r\nroot->index_bits++;\r\nif (prio_tree_empty(root))\r\ncontinue;\r\nif (first == NULL) {\r\nfirst = root->prio_tree_node;\r\nprio_tree_remove(root, root->prio_tree_node);\r\nINIT_PRIO_TREE_NODE(first);\r\nlast = first;\r\n} else {\r\nprev = last;\r\nlast = root->prio_tree_node;\r\nprio_tree_remove(root, root->prio_tree_node);\r\nINIT_PRIO_TREE_NODE(last);\r\nprev->left = last;\r\nlast->parent = prev;\r\n}\r\n}\r\nINIT_PRIO_TREE_NODE(node);\r\nif (first) {\r\nnode->left = first;\r\nfirst->parent = node;\r\n} else\r\nlast = node;\r\nif (!prio_tree_empty(root)) {\r\nlast->left = root->prio_tree_node;\r\nlast->left->parent = last;\r\n}\r\nroot->prio_tree_node = node;\r\nreturn node;\r\n}\r\nstruct prio_tree_node *prio_tree_replace(struct prio_tree_root *root,\r\nstruct prio_tree_node *old, struct prio_tree_node *node)\r\n{\r\nINIT_PRIO_TREE_NODE(node);\r\nif (prio_tree_root(old)) {\r\nBUG_ON(root->prio_tree_node != old);\r\nnode->parent = node;\r\nroot->prio_tree_node = node;\r\n} else {\r\nnode->parent = old->parent;\r\nif (old->parent->left == old)\r\nold->parent->left = node;\r\nelse\r\nold->parent->right = node;\r\n}\r\nif (!prio_tree_left_empty(old)) {\r\nnode->left = old->left;\r\nold->left->parent = node;\r\n}\r\nif (!prio_tree_right_empty(old)) {\r\nnode->right = old->right;\r\nold->right->parent = node;\r\n}\r\nreturn old;\r\n}\r\nstruct prio_tree_node *prio_tree_insert(struct prio_tree_root *root,\r\nstruct prio_tree_node *node)\r\n{\r\nstruct prio_tree_node *cur, *res = node;\r\nunsigned long radix_index, heap_index;\r\nunsigned long r_index, h_index, index, mask;\r\nint size_flag = 0;\r\nget_index(root, node, &radix_index, &heap_index);\r\nif (prio_tree_empty(root) ||\r\nheap_index > prio_tree_maxindex(root->index_bits))\r\nreturn prio_tree_expand(root, node, heap_index);\r\ncur = root->prio_tree_node;\r\nmask = 1UL << (root->index_bits - 1);\r\nwhile (mask) {\r\nget_index(root, cur, &r_index, &h_index);\r\nif (r_index == radix_index && h_index == heap_index)\r\nreturn cur;\r\nif (h_index < heap_index ||\r\n(h_index == heap_index && r_index > radix_index)) {\r\nstruct prio_tree_node *tmp = node;\r\nnode = prio_tree_replace(root, cur, node);\r\ncur = tmp;\r\nindex = r_index;\r\nr_index = radix_index;\r\nradix_index = index;\r\nindex = h_index;\r\nh_index = heap_index;\r\nheap_index = index;\r\n}\r\nif (size_flag)\r\nindex = heap_index - radix_index;\r\nelse\r\nindex = radix_index;\r\nif (index & mask) {\r\nif (prio_tree_right_empty(cur)) {\r\nINIT_PRIO_TREE_NODE(node);\r\ncur->right = node;\r\nnode->parent = cur;\r\nreturn res;\r\n} else\r\ncur = cur->right;\r\n} else {\r\nif (prio_tree_left_empty(cur)) {\r\nINIT_PRIO_TREE_NODE(node);\r\ncur->left = node;\r\nnode->parent = cur;\r\nreturn res;\r\n} else\r\ncur = cur->left;\r\n}\r\nmask >>= 1;\r\nif (!mask) {\r\nmask = 1UL << (BITS_PER_LONG - 1);\r\nsize_flag = 1;\r\n}\r\n}\r\nBUG();\r\nreturn NULL;\r\n}\r\nvoid prio_tree_remove(struct prio_tree_root *root, struct prio_tree_node *node)\r\n{\r\nstruct prio_tree_node *cur;\r\nunsigned long r_index, h_index_right, h_index_left;\r\ncur = node;\r\nwhile (!prio_tree_left_empty(cur) || !prio_tree_right_empty(cur)) {\r\nif (!prio_tree_left_empty(cur))\r\nget_index(root, cur->left, &r_index, &h_index_left);\r\nelse {\r\ncur = cur->right;\r\ncontinue;\r\n}\r\nif (!prio_tree_right_empty(cur))\r\nget_index(root, cur->right, &r_index, &h_index_right);\r\nelse {\r\ncur = cur->left;\r\ncontinue;\r\n}\r\nif (h_index_left >= h_index_right)\r\ncur = cur->left;\r\nelse\r\ncur = cur->right;\r\n}\r\nif (prio_tree_root(cur)) {\r\nBUG_ON(root->prio_tree_node != cur);\r\n__INIT_PRIO_TREE_ROOT(root, root->raw);\r\nreturn;\r\n}\r\nif (cur->parent->right == cur)\r\ncur->parent->right = cur->parent;\r\nelse\r\ncur->parent->left = cur->parent;\r\nwhile (cur != node)\r\ncur = prio_tree_replace(root, cur->parent, cur);\r\n}\r\nstatic struct prio_tree_node *prio_tree_left(struct prio_tree_iter *iter,\r\nunsigned long *r_index, unsigned long *h_index)\r\n{\r\nif (prio_tree_left_empty(iter->cur))\r\nreturn NULL;\r\nget_index(iter->root, iter->cur->left, r_index, h_index);\r\nif (iter->r_index <= *h_index) {\r\niter->cur = iter->cur->left;\r\niter->mask >>= 1;\r\nif (iter->mask) {\r\nif (iter->size_level)\r\niter->size_level++;\r\n} else {\r\nif (iter->size_level) {\r\nBUG_ON(!prio_tree_left_empty(iter->cur));\r\nBUG_ON(!prio_tree_right_empty(iter->cur));\r\niter->size_level++;\r\niter->mask = ULONG_MAX;\r\n} else {\r\niter->size_level = 1;\r\niter->mask = 1UL << (BITS_PER_LONG - 1);\r\n}\r\n}\r\nreturn iter->cur;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct prio_tree_node *prio_tree_right(struct prio_tree_iter *iter,\r\nunsigned long *r_index, unsigned long *h_index)\r\n{\r\nunsigned long value;\r\nif (prio_tree_right_empty(iter->cur))\r\nreturn NULL;\r\nif (iter->size_level)\r\nvalue = iter->value;\r\nelse\r\nvalue = iter->value | iter->mask;\r\nif (iter->h_index < value)\r\nreturn NULL;\r\nget_index(iter->root, iter->cur->right, r_index, h_index);\r\nif (iter->r_index <= *h_index) {\r\niter->cur = iter->cur->right;\r\niter->mask >>= 1;\r\niter->value = value;\r\nif (iter->mask) {\r\nif (iter->size_level)\r\niter->size_level++;\r\n} else {\r\nif (iter->size_level) {\r\nBUG_ON(!prio_tree_left_empty(iter->cur));\r\nBUG_ON(!prio_tree_right_empty(iter->cur));\r\niter->size_level++;\r\niter->mask = ULONG_MAX;\r\n} else {\r\niter->size_level = 1;\r\niter->mask = 1UL << (BITS_PER_LONG - 1);\r\n}\r\n}\r\nreturn iter->cur;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct prio_tree_node *prio_tree_parent(struct prio_tree_iter *iter)\r\n{\r\niter->cur = iter->cur->parent;\r\nif (iter->mask == ULONG_MAX)\r\niter->mask = 1UL;\r\nelse if (iter->size_level == 1)\r\niter->mask = 1UL;\r\nelse\r\niter->mask <<= 1;\r\nif (iter->size_level)\r\niter->size_level--;\r\nif (!iter->size_level && (iter->value & iter->mask))\r\niter->value ^= iter->mask;\r\nreturn iter->cur;\r\n}\r\nstatic inline int overlap(struct prio_tree_iter *iter,\r\nunsigned long r_index, unsigned long h_index)\r\n{\r\nreturn iter->h_index >= r_index && iter->r_index <= h_index;\r\n}\r\nstatic struct prio_tree_node *prio_tree_first(struct prio_tree_iter *iter)\r\n{\r\nstruct prio_tree_root *root;\r\nunsigned long r_index, h_index;\r\nINIT_PRIO_TREE_ITER(iter);\r\nroot = iter->root;\r\nif (prio_tree_empty(root))\r\nreturn NULL;\r\nget_index(root, root->prio_tree_node, &r_index, &h_index);\r\nif (iter->r_index > h_index)\r\nreturn NULL;\r\niter->mask = 1UL << (root->index_bits - 1);\r\niter->cur = root->prio_tree_node;\r\nwhile (1) {\r\nif (overlap(iter, r_index, h_index))\r\nreturn iter->cur;\r\nif (prio_tree_left(iter, &r_index, &h_index))\r\ncontinue;\r\nif (prio_tree_right(iter, &r_index, &h_index))\r\ncontinue;\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstruct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter)\r\n{\r\nunsigned long r_index, h_index;\r\nif (iter->cur == NULL)\r\nreturn prio_tree_first(iter);\r\nrepeat:\r\nwhile (prio_tree_left(iter, &r_index, &h_index))\r\nif (overlap(iter, r_index, h_index))\r\nreturn iter->cur;\r\nwhile (!prio_tree_right(iter, &r_index, &h_index)) {\r\nwhile (!prio_tree_root(iter->cur) &&\r\niter->cur->parent->right == iter->cur)\r\nprio_tree_parent(iter);\r\nif (prio_tree_root(iter->cur))\r\nreturn NULL;\r\nprio_tree_parent(iter);\r\n}\r\nif (overlap(iter, r_index, h_index))\r\nreturn iter->cur;\r\ngoto repeat;\r\n}
