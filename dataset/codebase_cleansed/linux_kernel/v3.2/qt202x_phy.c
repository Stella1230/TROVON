void falcon_qt202x_set_led(struct efx_nic *p, int led, int mode)\r\n{\r\nint addr = MDIO_QUAKE_LED0_REG + led;\r\nefx_mdio_write(p, MDIO_MMD_PMAPMD, addr, mode);\r\n}\r\nstatic int qt2025c_wait_heartbeat(struct efx_nic *efx)\r\n{\r\nunsigned long timeout = jiffies + QT2025C_MAX_HEARTB_TIME;\r\nint reg, old_counter = 0;\r\nfor (;;) {\r\nint counter;\r\nreg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_FW_HEARTBEAT_REG);\r\nif (reg < 0)\r\nreturn reg;\r\ncounter = ((reg >> PCS_FW_HEARTB_LBN) &\r\n((1 << PCS_FW_HEARTB_WIDTH) - 1));\r\nif (old_counter == 0)\r\nold_counter = counter;\r\nelse if (counter != old_counter)\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"If an SFP+ direct attach cable is"\r\n" connected, please check that it complies"\r\n" with the SFP+ specification\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(QT2025C_HEARTB_WAIT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt2025c_wait_fw_status_good(struct efx_nic *efx)\r\n{\r\nunsigned long timeout = jiffies + QT2025C_MAX_FWSTART_TIME;\r\nint reg;\r\nfor (;;) {\r\nreg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_UC8051_STATUS_REG);\r\nif (reg < 0)\r\nreturn reg;\r\nif ((reg &\r\n((1 << PCS_UC_STATUS_WIDTH) - 1) << PCS_UC_STATUS_LBN) >=\r\nPCS_UC_STATUS_FW_SAVE)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nmsleep(QT2025C_FWSTART_WAIT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void qt2025c_restart_firmware(struct efx_nic *efx)\r\n{\r\nefx_mdio_write(efx, 3, 0xe854, 0x00c0);\r\nefx_mdio_write(efx, 3, 0xe854, 0x0040);\r\nmsleep(50);\r\n}\r\nstatic int qt2025c_wait_reset(struct efx_nic *efx)\r\n{\r\nint rc;\r\nrc = qt2025c_wait_heartbeat(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = qt2025c_wait_fw_status_good(efx);\r\nif (rc == -ETIMEDOUT) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"bashing QT2025C microcontroller\n");\r\nqt2025c_restart_firmware(efx);\r\nrc = qt2025c_wait_heartbeat(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = qt2025c_wait_fw_status_good(efx);\r\n}\r\nreturn rc;\r\n}\r\nstatic void qt2025c_firmware_id(struct efx_nic *efx)\r\n{\r\nstruct qt202x_phy_data *phy_data = efx->phy_data;\r\nu8 firmware_id[9];\r\nsize_t i;\r\nfor (i = 0; i < sizeof(firmware_id); i++)\r\nfirmware_id[i] = efx_mdio_read(efx, MDIO_MMD_PCS,\r\nPCS_FW_PRODUCT_CODE_1 + i);\r\nnetif_info(efx, probe, efx->net_dev,\r\n"QT2025C firmware %xr%d v%d.%d.%d.%d [20%02d-%02d-%02d]\n",\r\n(firmware_id[0] << 8) | firmware_id[1], firmware_id[2],\r\nfirmware_id[3] >> 4, firmware_id[3] & 0xf,\r\nfirmware_id[4], firmware_id[5],\r\nfirmware_id[6], firmware_id[7], firmware_id[8]);\r\nphy_data->firmware_ver = ((firmware_id[3] & 0xf0) << 20) |\r\n((firmware_id[3] & 0x0f) << 16) |\r\n(firmware_id[4] << 8) | firmware_id[5];\r\n}\r\nstatic void qt2025c_bug17190_workaround(struct efx_nic *efx)\r\n{\r\nstruct qt202x_phy_data *phy_data = efx->phy_data;\r\nif (efx->link_state.up ||\r\n!efx_mdio_links_ok(efx, MDIO_DEVS_PMAPMD | MDIO_DEVS_PHYXS)) {\r\nphy_data->bug17190_in_bad_state = false;\r\nreturn;\r\n}\r\nif (!phy_data->bug17190_in_bad_state) {\r\nphy_data->bug17190_in_bad_state = true;\r\nphy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;\r\nreturn;\r\n}\r\nif (time_after_eq(jiffies, phy_data->bug17190_timer)) {\r\nnetif_dbg(efx, hw, efx->net_dev, "bashing QT2025C PMA/PMD\n");\r\nefx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,\r\nMDIO_PMA_CTRL1_LOOPBACK, true);\r\nmsleep(100);\r\nefx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,\r\nMDIO_PMA_CTRL1_LOOPBACK, false);\r\nphy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;\r\n}\r\n}\r\nstatic int qt2025c_select_phy_mode(struct efx_nic *efx)\r\n{\r\nstruct qt202x_phy_data *phy_data = efx->phy_data;\r\nstruct falcon_board *board = falcon_board(efx);\r\nint reg, rc, i;\r\nuint16_t phy_op_mode;\r\nif (phy_data->firmware_ver < 0x02000100)\r\nreturn 0;\r\nphy_op_mode = (efx->loopback_mode == LOOPBACK_NONE) ? 0x0038 : 0x0020;\r\nreg = efx_mdio_read(efx, 1, 0xc319);\r\nif ((reg & 0x0038) == phy_op_mode)\r\nreturn 0;\r\nnetif_dbg(efx, hw, efx->net_dev, "Switching PHY to mode 0x%04x\n",\r\nphy_op_mode);\r\nefx_mdio_write(efx, 1, 0xc300, 0x0000);\r\nif (board->major == 0 && board->minor < 2) {\r\nefx_mdio_write(efx, 1, 0xc303, 0x4498);\r\nfor (i = 0; i < 9; i++) {\r\nefx_mdio_write(efx, 1, 0xc303, 0x4488);\r\nefx_mdio_write(efx, 1, 0xc303, 0x4480);\r\nefx_mdio_write(efx, 1, 0xc303, 0x4490);\r\nefx_mdio_write(efx, 1, 0xc303, 0x4498);\r\n}\r\n} else {\r\nefx_mdio_write(efx, 1, 0xc303, 0x0920);\r\nefx_mdio_write(efx, 1, 0xd008, 0x0004);\r\nfor (i = 0; i < 9; i++) {\r\nefx_mdio_write(efx, 1, 0xc303, 0x0900);\r\nefx_mdio_write(efx, 1, 0xd008, 0x0005);\r\nefx_mdio_write(efx, 1, 0xc303, 0x0920);\r\nefx_mdio_write(efx, 1, 0xd008, 0x0004);\r\n}\r\nefx_mdio_write(efx, 1, 0xc303, 0x4900);\r\n}\r\nefx_mdio_write(efx, 1, 0xc303, 0x4900);\r\nefx_mdio_write(efx, 1, 0xc302, 0x0004);\r\nefx_mdio_write(efx, 1, 0xc316, 0x0013);\r\nefx_mdio_write(efx, 1, 0xc318, 0x0054);\r\nefx_mdio_write(efx, 1, 0xc319, phy_op_mode);\r\nefx_mdio_write(efx, 1, 0xc31a, 0x0098);\r\nefx_mdio_write(efx, 3, 0x0026, 0x0e00);\r\nefx_mdio_write(efx, 3, 0x0027, 0x0013);\r\nefx_mdio_write(efx, 3, 0x0028, 0xa528);\r\nefx_mdio_write(efx, 1, 0xd006, 0x000a);\r\nefx_mdio_write(efx, 1, 0xd007, 0x0009);\r\nefx_mdio_write(efx, 1, 0xd008, 0x0004);\r\nefx_mdio_write(efx, 1, 0xc317, 0x00ff);\r\nefx_mdio_set_flag(efx, 1, PMA_PMD_MODE_REG,\r\n1 << PMA_PMD_RXIN_SEL_LBN, false);\r\nefx_mdio_write(efx, 1, 0xc300, 0x0002);\r\nmsleep(20);\r\nqt2025c_restart_firmware(efx);\r\nrc = qt2025c_wait_reset(efx);\r\nif (rc < 0) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PHY microcontroller reset during mode switch "\r\n"timed out\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt202x_reset_phy(struct efx_nic *efx)\r\n{\r\nint rc;\r\nif (efx->phy_type == PHY_TYPE_QT2025C) {\r\nrc = qt2025c_wait_reset(efx);\r\nif (rc < 0)\r\ngoto fail;\r\n} else {\r\nrc = efx_mdio_reset_mmd(efx, MDIO_MMD_PHYXS,\r\nQT2022C2_MAX_RESET_TIME /\r\nQT2022C2_RESET_WAIT,\r\nQT2022C2_RESET_WAIT);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nmsleep(250);\r\nfalcon_board(efx)->type->init_phy(efx);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "PHY reset timed out\n");\r\nreturn rc;\r\n}\r\nstatic int qt202x_phy_probe(struct efx_nic *efx)\r\n{\r\nstruct qt202x_phy_data *phy_data;\r\nphy_data = kzalloc(sizeof(struct qt202x_phy_data), GFP_KERNEL);\r\nif (!phy_data)\r\nreturn -ENOMEM;\r\nefx->phy_data = phy_data;\r\nphy_data->phy_mode = efx->phy_mode;\r\nphy_data->bug17190_in_bad_state = false;\r\nphy_data->bug17190_timer = 0;\r\nefx->mdio.mmds = QT202X_REQUIRED_DEVS;\r\nefx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\r\nefx->loopback_modes = QT202X_LOOPBACKS | FALCON_XMAC_LOOPBACKS;\r\nreturn 0;\r\n}\r\nstatic int qt202x_phy_init(struct efx_nic *efx)\r\n{\r\nu32 devid;\r\nint rc;\r\nrc = qt202x_reset_phy(efx);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev, "PHY init failed\n");\r\nreturn rc;\r\n}\r\ndevid = efx_mdio_read_id(efx, MDIO_MMD_PHYXS);\r\nnetif_info(efx, probe, efx->net_dev,\r\n"PHY ID reg %x (OUI %06x model %02x revision %x)\n",\r\ndevid, efx_mdio_id_oui(devid), efx_mdio_id_model(devid),\r\nefx_mdio_id_rev(devid));\r\nif (efx->phy_type == PHY_TYPE_QT2025C)\r\nqt2025c_firmware_id(efx);\r\nreturn 0;\r\n}\r\nstatic int qt202x_link_ok(struct efx_nic *efx)\r\n{\r\nreturn efx_mdio_links_ok(efx, QT202X_REQUIRED_DEVS);\r\n}\r\nstatic bool qt202x_phy_poll(struct efx_nic *efx)\r\n{\r\nbool was_up = efx->link_state.up;\r\nefx->link_state.up = qt202x_link_ok(efx);\r\nefx->link_state.speed = 10000;\r\nefx->link_state.fd = true;\r\nefx->link_state.fc = efx->wanted_fc;\r\nif (efx->phy_type == PHY_TYPE_QT2025C)\r\nqt2025c_bug17190_workaround(efx);\r\nreturn efx->link_state.up != was_up;\r\n}\r\nstatic int qt202x_phy_reconfigure(struct efx_nic *efx)\r\n{\r\nstruct qt202x_phy_data *phy_data = efx->phy_data;\r\nif (efx->phy_type == PHY_TYPE_QT2025C) {\r\nint rc = qt2025c_select_phy_mode(efx);\r\nif (rc)\r\nreturn rc;\r\nmdio_set_flag(\r\n&efx->mdio, efx->mdio.prtad, MDIO_MMD_PMAPMD,\r\nPMA_PMD_FTX_CTRL2_REG, 1 << PMA_PMD_FTX_STATIC_LBN,\r\nefx->phy_mode & PHY_MODE_TX_DISABLED ||\r\nefx->phy_mode & PHY_MODE_LOW_POWER ||\r\nefx->loopback_mode == LOOPBACK_PCS ||\r\nefx->loopback_mode == LOOPBACK_PMAPMD);\r\n} else {\r\nif (!(efx->phy_mode & PHY_MODE_TX_DISABLED) &&\r\n(phy_data->phy_mode & PHY_MODE_TX_DISABLED))\r\nqt202x_reset_phy(efx);\r\nefx_mdio_transmit_disable(efx);\r\n}\r\nefx_mdio_phy_reconfigure(efx);\r\nphy_data->phy_mode = efx->phy_mode;\r\nreturn 0;\r\n}\r\nstatic void qt202x_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)\r\n{\r\nmdio45_ethtool_gset(&efx->mdio, ecmd);\r\n}\r\nstatic void qt202x_phy_remove(struct efx_nic *efx)\r\n{\r\nkfree(efx->phy_data);\r\nefx->phy_data = NULL;\r\n}
