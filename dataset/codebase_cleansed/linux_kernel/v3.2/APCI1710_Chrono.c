int i_APCI1710_InsnConfigInitChrono(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int ul_TimerValue = 0;\r\nunsigned int ul_TimingInterval = 0;\r\nunsigned int ul_RealTimingInterval = 0;\r\ndouble d_RealTimingInterval = 0;\r\nunsigned int dw_ModeArray[8] =\r\n{ 0x01, 0x05, 0x00, 0x04, 0x02, 0x0E, 0x0A, 0x06 };\r\nunsigned char b_ModulNbr, b_ChronoMode, b_PCIInputClock, b_TimingUnit;\r\nb_ModulNbr = CR_AREF(insn->chanspec);\r\nb_ChronoMode = (unsigned char) data[0];\r\nb_PCIInputClock = (unsigned char) data[1];\r\nb_TimingUnit = (unsigned char) data[2];\r\nul_TimingInterval = (unsigned int) data[3];\r\ni_ReturnValue = insn->n;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_CHRONOMETER) {\r\nif (b_ChronoMode <= 7) {\r\nif ((b_PCIInputClock == APCI1710_30MHZ) ||\r\n(b_PCIInputClock == APCI1710_33MHZ) ||\r\n(b_PCIInputClock == APCI1710_40MHZ)) {\r\nif (b_TimingUnit <= 4) {\r\nif (((b_PCIInputClock == APCI1710_30MHZ) && (b_TimingUnit == 0) && (ul_TimingInterval >= 66) && (ul_TimingInterval <= 0xFFFFFFFFUL)) || ((b_PCIInputClock == APCI1710_30MHZ) && (b_TimingUnit == 1) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 143165576UL)) || ((b_PCIInputClock == APCI1710_30MHZ) && (b_TimingUnit == 2) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 143165UL)) || ((b_PCIInputClock == APCI1710_30MHZ) && (b_TimingUnit == 3) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 143UL)) || ((b_PCIInputClock == APCI1710_30MHZ) && (b_TimingUnit == 4) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 2UL)) || ((b_PCIInputClock == APCI1710_33MHZ) && (b_TimingUnit == 0) && (ul_TimingInterval >= 60) && (ul_TimingInterval <= 0xFFFFFFFFUL)) || ((b_PCIInputClock == APCI1710_33MHZ) && (b_TimingUnit == 1) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 130150240UL)) || ((b_PCIInputClock == APCI1710_33MHZ) && (b_TimingUnit == 2) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 130150UL)) || ((b_PCIInputClock == APCI1710_33MHZ) && (b_TimingUnit == 3) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 130UL)) || ((b_PCIInputClock == APCI1710_33MHZ) && (b_TimingUnit == 4) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 2UL)) || ((b_PCIInputClock == APCI1710_40MHZ) && (b_TimingUnit == 0) && (ul_TimingInterval >= 50) && (ul_TimingInterval <= 0xFFFFFFFFUL)) || ((b_PCIInputClock == APCI1710_40MHZ) && (b_TimingUnit == 1) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 107374182UL)) || ((b_PCIInputClock == APCI1710_40MHZ) && (b_TimingUnit == 2) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 107374UL)) || ((b_PCIInputClock == APCI1710_40MHZ) && (b_TimingUnit == 3) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 107UL)) || ((b_PCIInputClock == APCI1710_40MHZ) && (b_TimingUnit == 4) && (ul_TimingInterval >= 1) && (ul_TimingInterval <= 1UL))) {\r\nif (((b_PCIInputClock == APCI1710_40MHZ) && (devpriv->s_BoardInfos.b_BoardVersion > 0)) || (b_PCIInputClock != APCI1710_40MHZ)) {\r\nif (((b_PCIInputClock == APCI1710_40MHZ) && ((devpriv->s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] & 0xFFFF) >= 0x3131)) || (b_PCIInputClock != APCI1710_40MHZ)) {\r\nfpu_begin\r\n();\r\nswitch (b_TimingUnit) {\r\ncase 0:\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(ul_TimingInterval\r\n*\r\n(0.001 * b_PCIInputClock));\r\nif ((double)((double)ul_TimingInterval * (0.001 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\nul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(0.001 * (double)b_PCIInputClock));\r\nd_RealTimingInterval\r\n=\r\n(double)\r\nul_TimerValue\r\n/\r\n(0.001\r\n*\r\n(double)\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimerValue / (0.001 * (double)b_PCIInputClock)) >= (double)((double)ul_RealTimingInterval + 0.5)) {\r\nul_RealTimingInterval\r\n=\r\nul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nif (b_PCIInputClock != APCI1710_40MHZ) {\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(\r\n(double)\r\n(ul_TimerValue)\r\n*\r\n0.99392);\r\n}\r\nbreak;\r\ncase 1:\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(ul_TimingInterval\r\n*\r\n(1.0 * b_PCIInputClock));\r\nif ((double)((double)ul_TimingInterval * (1.0 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\nul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(1.0 * (double)b_PCIInputClock));\r\nd_RealTimingInterval\r\n=\r\n(double)\r\nul_TimerValue\r\n/\r\n(\r\n(double)\r\n1.0\r\n*\r\n(double)\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimerValue / (1.0 * (double)b_PCIInputClock)) >= (double)((double)ul_RealTimingInterval + 0.5)) {\r\nul_RealTimingInterval\r\n=\r\nul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nif (b_PCIInputClock != APCI1710_40MHZ) {\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(\r\n(double)\r\n(ul_TimerValue)\r\n*\r\n0.99392);\r\n}\r\nbreak;\r\ncase 2:\r\nul_TimerValue\r\n=\r\nul_TimingInterval\r\n*\r\n(1000\r\n*\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimingInterval * (1000.0 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\nul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(1000.0 * (double)b_PCIInputClock));\r\nd_RealTimingInterval\r\n=\r\n(double)\r\nul_TimerValue\r\n/\r\n(1000.0\r\n*\r\n(double)\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimerValue / (1000.0 * (double)b_PCIInputClock)) >= (double)((double)ul_RealTimingInterval + 0.5)) {\r\nul_RealTimingInterval\r\n=\r\nul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nif (b_PCIInputClock != APCI1710_40MHZ) {\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(\r\n(double)\r\n(ul_TimerValue)\r\n*\r\n0.99392);\r\n}\r\nbreak;\r\ncase 3:\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(ul_TimingInterval\r\n*\r\n(1000000.0\r\n*\r\nb_PCIInputClock));\r\nif ((double)((double)ul_TimingInterval * (1000000.0 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\nul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(1000000.0\r\n*\r\n(double)\r\nb_PCIInputClock));\r\nd_RealTimingInterval\r\n=\r\n(double)\r\nul_TimerValue\r\n/\r\n(1000000.0\r\n*\r\n(double)\r\nb_PCIInputClock);\r\nif ((double)((double)ul_TimerValue / (1000000.0 * (double)b_PCIInputClock)) >= (double)((double)ul_RealTimingInterval + 0.5)) {\r\nul_RealTimingInterval\r\n=\r\nul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nif (b_PCIInputClock != APCI1710_40MHZ) {\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(\r\n(double)\r\n(ul_TimerValue)\r\n*\r\n0.99392);\r\n}\r\nbreak;\r\ncase 4:\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(\r\n(ul_TimingInterval\r\n*\r\n60)\r\n*\r\n(1000000.0\r\n*\r\nb_PCIInputClock));\r\nif ((double)((double)(ul_TimingInterval * 60.0) * (1000000.0 * (double)b_PCIInputClock)) >= ((double)((double)ul_TimerValue + 0.5))) {\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n+\r\n1;\r\n}\r\nul_RealTimingInterval\r\n=\r\n(unsigned int)\r\n(ul_TimerValue\r\n/\r\n(1000000.0\r\n*\r\n(double)\r\nb_PCIInputClock))\r\n/\r\n60;\r\nd_RealTimingInterval\r\n=\r\n(\r\n(double)\r\nul_TimerValue\r\n/\r\n(0.001 * (double)b_PCIInputClock)) / 60.0;\r\nif ((double)(((double)ul_TimerValue / (1000000.0 * (double)b_PCIInputClock)) / 60.0) >= (double)((double)ul_RealTimingInterval + 0.5)) {\r\nul_RealTimingInterval\r\n=\r\nul_RealTimingInterval\r\n+\r\n1;\r\n}\r\nul_TimingInterval\r\n=\r\nul_TimingInterval\r\n-\r\n1;\r\nul_TimerValue\r\n=\r\nul_TimerValue\r\n-\r\n2;\r\nif (b_PCIInputClock != APCI1710_40MHZ) {\r\nul_TimerValue\r\n=\r\n(unsigned int)\r\n(\r\n(double)\r\n(ul_TimerValue)\r\n*\r\n0.99392);\r\n}\r\nbreak;\r\n}\r\nfpu_end();\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_PCIInputClock\r\n=\r\nb_PCIInputClock;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_TimingUnit\r\n=\r\nb_TimingUnit;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nd_TimingInterval\r\n=\r\nd_RealTimingInterval;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg\r\n=\r\ndw_ModeArray\r\n[b_ChronoMode];\r\nif (b_PCIInputClock == APCI1710_40MHZ) {\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg\r\n=\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg\r\n|\r\n0x80;\r\n}\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].s_ChronoModuleInfo.dw_ConfigReg, devpriv->s_BoardInfos.ui_Address + 16 + (64 * b_ModulNbr));\r\noutl(ul_TimerValue, devpriv->s_BoardInfos.ui_Address + (64 * b_ModulNbr));\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_ChronoInit\r\n=\r\n1;\r\n} else {\r\nDPRINTK("TOR version error for 40MHz clock selection\n");\r\ni_ReturnValue\r\n=\r\n-9;\r\n}\r\n} else {\r\nDPRINTK("You can not used the 40MHz clock selection with this board\n");\r\ni_ReturnValue =\r\n-8;\r\n}\r\n} else {\r\nDPRINTK("Base timing selection is wrong\n");\r\ni_ReturnValue = -7;\r\n}\r\n}\r\nelse {\r\nDPRINTK("Timing unity selection is wrong\n");\r\ni_ReturnValue = -6;\r\n}\r\n}\r\nelse {\r\nDPRINTK("The selected PCI input clock is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n}\r\nelse {\r\nDPRINTK("Chronometer mode selection is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a Chronometer module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\ndata[0] = ul_RealTimingInterval;\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnWriteEnableDisableChrono(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned char b_ModulNbr, b_CycleMode, b_InterruptEnable, b_Action;\r\nb_ModulNbr = CR_AREF(insn->chanspec);\r\nb_Action = (unsigned char) data[0];\r\nb_CycleMode = (unsigned char) data[1];\r\nb_InterruptEnable = (unsigned char) data[2];\r\ni_ReturnValue = insn->n;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_CHRONOMETER) {\r\nif (devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.b_ChronoInit == 1) {\r\nswitch (b_Action) {\r\ncase APCI1710_ENABLE:\r\nif ((b_CycleMode == APCI1710_SINGLE)\r\n|| (b_CycleMode ==\r\nAPCI1710_CONTINUOUS)) {\r\nif ((b_InterruptEnable ==\r\nAPCI1710_ENABLE)\r\n|| (b_InterruptEnable ==\r\nAPCI1710_DISABLE))\r\n{\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_InterruptMask\r\n=\r\nb_InterruptEnable;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_CycleMode =\r\nb_CycleMode;\r\ndevpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg =\r\n(devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg &\r\n0x8F) | ((1 &\r\nb_InterruptEnable)\r\n<< 5) | ((1 &\r\nb_CycleMode)\r\n<< 6) | 0x10;\r\nif (b_InterruptEnable ==\r\nAPCI1710_ENABLE)\r\n{\r\noutl(devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg,\r\ndevpriv->\r\ns_BoardInfos.\r\nui_Address\r\n+ 32 +\r\n(64 * b_ModulNbr));\r\ndevpriv->tsk_Current = current;\r\n}\r\noutl(devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg,\r\ndevpriv->\r\ns_BoardInfos.\r\nui_Address +\r\n16 +\r\n(64 * b_ModulNbr));\r\noutl(0, devpriv->\r\ns_BoardInfos.\r\nui_Address +\r\n36 +\r\n(64 * b_ModulNbr));\r\n}\r\nelse {\r\nDPRINTK("Interrupt parameter is wrong\n");\r\ni_ReturnValue = -6;\r\n}\r\n}\r\nelse {\r\nDPRINTK("Chronometer acquisition mode cycle is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\nbreak;\r\ncase APCI1710_DISABLE:\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_InterruptMask = 0;\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg =\r\ndevpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\ndw_ConfigReg & 0x2F;\r\noutl(devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.dw_ConfigReg,\r\ndevpriv->s_BoardInfos.\r\nui_Address + 16 +\r\n(64 * b_ModulNbr));\r\nif (devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_CycleMode ==\r\nAPCI1710_CONTINUOUS) {\r\noutl(0, devpriv->s_BoardInfos.\r\nui_Address + 36 +\r\n(64 * b_ModulNbr));\r\n}\r\nbreak;\r\ndefault:\r\nDPRINTK("Inputs wrong! Enable or Disable chrono\n");\r\ni_ReturnValue = -8;\r\n}\r\n} else {\r\nDPRINTK("Chronometer not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a Chronometer module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnReadChrono(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned char b_ReadType;\r\nint i_ReturnValue = insn->n;\r\nb_ReadType = CR_CHAN(insn->chanspec);\r\nswitch (b_ReadType) {\r\ncase APCI1710_CHRONO_PROGRESS_STATUS:\r\ni_ReturnValue = i_APCI1710_GetChronoProgressStatus(dev,\r\n(unsigned char) CR_AREF(insn->chanspec), (unsigned char *) &data[0]);\r\nbreak;\r\ncase APCI1710_CHRONO_READVALUE:\r\ni_ReturnValue = i_APCI1710_ReadChronoValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned int) insn->unused[0],\r\n(unsigned char *) &data[0], (unsigned int *) &data[1]);\r\nbreak;\r\ncase APCI1710_CHRONO_CONVERTVALUE:\r\ni_ReturnValue = i_APCI1710_ConvertChronoValue(dev,\r\n(unsigned char) CR_AREF(insn->chanspec),\r\n(unsigned int) insn->unused[0],\r\n(unsigned int *) &data[0],\r\n(unsigned char *) &data[1],\r\n(unsigned char *) &data[2],\r\n(unsigned int *) &data[3],\r\n(unsigned int *) &data[4], (unsigned int *) &data[5]);\r\nbreak;\r\ncase APCI1710_CHRONO_READINTERRUPT:\r\nprintk("In Chrono Read Interrupt\n");\r\ndata[0] = devpriv->s_InterruptParameters.\r\ns_FIFOInterruptParameters[devpriv->\r\ns_InterruptParameters.ui_Read].b_OldModuleMask;\r\ndata[1] = devpriv->s_InterruptParameters.\r\ns_FIFOInterruptParameters[devpriv->\r\ns_InterruptParameters.ui_Read].ul_OldInterruptMask;\r\ndata[2] = devpriv->s_InterruptParameters.\r\ns_FIFOInterruptParameters[devpriv->\r\ns_InterruptParameters.ui_Read].ul_OldCounterLatchValue;\r\ndevpriv->\r\ns_InterruptParameters.\r\nui_Read = (devpriv->\r\ns_InterruptParameters.\r\nui_Read + 1) % APCI1710_SAVE_INTERRUPT;\r\nbreak;\r\ndefault:\r\nprintk("ReadType Parameter wrong\n");\r\n}\r\nif (i_ReturnValue >= 0)\r\ni_ReturnValue = insn->n;\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_GetChronoProgressStatus(struct comedi_device *dev,\r\nunsigned char b_ModulNbr, unsigned char *pb_ChronoStatus)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_Status;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_CHRONOMETER) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.b_ChronoInit == 1) {\r\ndw_Status = inl(devpriv->s_BoardInfos.\r\nui_Address + 8 + (64 * b_ModulNbr));\r\nif ((dw_Status & 8) == 8) {\r\n*pb_ChronoStatus = 3;\r\n}\r\nelse {\r\nif ((dw_Status & 2) == 2) {\r\n*pb_ChronoStatus = 2;\r\n}\r\nelse {\r\nif ((dw_Status & 1) == 1) {\r\n*pb_ChronoStatus = 1;\r\n}\r\nelse {\r\n*pb_ChronoStatus = 0;\r\n}\r\n}\r\n}\r\n} else {\r\nDPRINTK("Chronometer not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a Chronometer module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_ReadChronoValue(struct comedi_device *dev,\r\nunsigned char b_ModulNbr,\r\nunsigned int ui_TimeOut, unsigned char *pb_ChronoStatus, unsigned int *pul_ChronoValue)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned int dw_Status;\r\nunsigned int dw_TimeOut = 0;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_CHRONOMETER) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.b_ChronoInit == 1) {\r\nif (ui_TimeOut <= 65535UL) {\r\nfor (;;) {\r\ndw_Status =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address + 8 +\r\n(64 * b_ModulNbr));\r\nif ((dw_Status & 8) == 8) {\r\n*pb_ChronoStatus = 3;\r\nif (devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_CycleMode ==\r\nAPCI1710_CONTINUOUS)\r\n{\r\noutl(0, devpriv->s_BoardInfos.ui_Address + 36 + (64 * b_ModulNbr));\r\n}\r\nbreak;\r\n}\r\nelse {\r\nif ((dw_Status & 2) ==\r\n2) {\r\n*pb_ChronoStatus\r\n= 2;\r\nif (devpriv->\r\ns_ModuleInfo\r\n[b_ModulNbr].\r\ns_ChronoModuleInfo.\r\nb_CycleMode\r\n==\r\nAPCI1710_CONTINUOUS)\r\n{\r\noutl(0, devpriv->s_BoardInfos.ui_Address + 36 + (64 * b_ModulNbr));\r\n}\r\nbreak;\r\n}\r\nelse {\r\nif ((dw_Status & 1) == 1) {\r\n*pb_ChronoStatus\r\n=\r\n1;\r\n}\r\nelse {\r\n*pb_ChronoStatus\r\n=\r\n0;\r\n}\r\n}\r\n}\r\nif (dw_TimeOut == ui_TimeOut) {\r\nbreak;\r\n} else {\r\ndw_TimeOut =\r\ndw_TimeOut + 1;\r\nmdelay(1000);\r\n}\r\n}\r\nif (*pb_ChronoStatus == 2) {\r\n*pul_ChronoValue =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address + 4 +\r\n(64 * b_ModulNbr));\r\nif (*pul_ChronoValue != 0) {\r\n*pul_ChronoValue =\r\n*pul_ChronoValue\r\n- 1;\r\n}\r\n} else {\r\nif ((*pb_ChronoStatus != 3)\r\n&& (dw_TimeOut ==\r\nui_TimeOut)\r\n&& (ui_TimeOut != 0)) {\r\n*pb_ChronoStatus = 4;\r\n}\r\n}\r\n} else {\r\nDPRINTK("Timeout parameter is wrong\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("Chronometer not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a Chronometer module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_ConvertChronoValue(struct comedi_device *dev,\r\nunsigned char b_ModulNbr,\r\nunsigned int ul_ChronoValue,\r\nunsigned int *pul_Hour,\r\nunsigned char *pb_Minute,\r\nunsigned char *pb_Second,\r\nunsigned int *pui_MilliSecond, unsigned int *pui_MicroSecond, unsigned int *pui_NanoSecond)\r\n{\r\nint i_ReturnValue = 0;\r\ndouble d_Hour;\r\ndouble d_Minute;\r\ndouble d_Second;\r\ndouble d_MilliSecond;\r\ndouble d_MicroSecond;\r\ndouble d_NanoSecond;\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_CHRONOMETER) {\r\nif (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.b_ChronoInit == 1) {\r\nfpu_begin();\r\nd_Hour = (double)ul_ChronoValue *(double)\r\ndevpriv->s_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.d_TimingInterval;\r\nswitch (devpriv->\r\ns_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.b_TimingUnit) {\r\ncase 0:\r\nd_Hour = d_Hour / (double)1000.0;\r\ncase 1:\r\nd_Hour = d_Hour / (double)1000.0;\r\ncase 2:\r\nd_Hour = d_Hour / (double)1000.0;\r\ncase 3:\r\nd_Hour = d_Hour / (double)60.0;\r\ncase 4:\r\nd_Hour = d_Hour / (double)60.0;\r\n*pul_Hour = (unsigned int) d_Hour;\r\nd_Minute = d_Hour - *pul_Hour;\r\nd_Minute = d_Minute * 60;\r\n*pb_Minute = (unsigned char) d_Minute;\r\nd_Second = d_Minute - *pb_Minute;\r\nd_Second = d_Second * 60;\r\n*pb_Second = (unsigned char) d_Second;\r\nd_MilliSecond = d_Second - *pb_Second;\r\nd_MilliSecond = d_MilliSecond * 1000;\r\n*pui_MilliSecond = (unsigned int) d_MilliSecond;\r\nd_MicroSecond =\r\nd_MilliSecond -\r\n*pui_MilliSecond;\r\nd_MicroSecond = d_MicroSecond * 1000;\r\n*pui_MicroSecond = (unsigned int) d_MicroSecond;\r\nd_NanoSecond =\r\nd_MicroSecond -\r\n*pui_MicroSecond;\r\nd_NanoSecond = d_NanoSecond * 1000;\r\n*pui_NanoSecond = (unsigned int) d_NanoSecond;\r\nbreak;\r\n}\r\nfpu_end();\r\n} else {\r\nDPRINTK("Chronometer not initialised\n");\r\ni_ReturnValue = -4;\r\n}\r\n} else {\r\nDPRINTK("The module is not a Chronometer module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}\r\nint i_APCI1710_InsnBitsChronoDigitalIO(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i_ReturnValue = 0;\r\nunsigned char b_ModulNbr, b_OutputChannel, b_InputChannel, b_IOType;\r\nunsigned int dw_Status;\r\nunsigned char *pb_ChannelStatus;\r\nunsigned char *pb_PortValue;\r\nb_ModulNbr = CR_AREF(insn->chanspec);\r\ni_ReturnValue = insn->n;\r\nb_IOType = (unsigned char) data[0];\r\nif (b_ModulNbr < 4) {\r\nif ((devpriv->s_BoardInfos.\r\ndw_MolduleConfiguration[b_ModulNbr] &\r\n0xFFFF0000UL) == APCI1710_CHRONOMETER) {\r\nif (devpriv->s_ModuleInfo[b_ModulNbr].\r\ns_ChronoModuleInfo.b_ChronoInit == 1) {\r\nswitch (b_IOType) {\r\ncase APCI1710_CHRONO_SET_CHANNELOFF:\r\nb_OutputChannel =\r\n(unsigned char) CR_CHAN(insn->chanspec);\r\nif (b_OutputChannel <= 2) {\r\noutl(0, devpriv->s_BoardInfos.\r\nui_Address + 20 +\r\n(b_OutputChannel * 4) +\r\n(64 * b_ModulNbr));\r\n}\r\nelse {\r\nDPRINTK("The selected digital output is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\nbreak;\r\ncase APCI1710_CHRONO_SET_CHANNELON:\r\nb_OutputChannel =\r\n(unsigned char) CR_CHAN(insn->chanspec);\r\nif (b_OutputChannel <= 2) {\r\noutl(1, devpriv->s_BoardInfos.\r\nui_Address + 20 +\r\n(b_OutputChannel * 4) +\r\n(64 * b_ModulNbr));\r\n}\r\nelse {\r\nDPRINTK("The selected digital output is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\nbreak;\r\ncase APCI1710_CHRONO_READ_CHANNEL:\r\npb_ChannelStatus = (unsigned char *) &data[0];\r\nb_InputChannel =\r\n(unsigned char) CR_CHAN(insn->chanspec);\r\nif (b_InputChannel <= 2) {\r\ndw_Status =\r\ninl(devpriv->\r\ns_BoardInfos.\r\nui_Address + 12 +\r\n(64 * b_ModulNbr));\r\n*pb_ChannelStatus =\r\n(unsigned char) (((dw_Status >>\r\nb_InputChannel)\r\n& 1) ^ 1);\r\n}\r\nelse {\r\nDPRINTK("The selected digital input is wrong\n");\r\ni_ReturnValue = -4;\r\n}\r\nbreak;\r\ncase APCI1710_CHRONO_READ_PORT:\r\npb_PortValue = (unsigned char *) &data[0];\r\ndw_Status =\r\ninl(devpriv->s_BoardInfos.\r\nui_Address + 12 +\r\n(64 * b_ModulNbr));\r\n*pb_PortValue =\r\n(unsigned char) ((dw_Status & 0x7) ^ 7);\r\nbreak;\r\n}\r\n} else {\r\nDPRINTK("Chronometer not initialised\n");\r\ni_ReturnValue = -5;\r\n}\r\n} else {\r\nDPRINTK("The module is not a Chronometer module\n");\r\ni_ReturnValue = -3;\r\n}\r\n} else {\r\nDPRINTK("Module number error\n");\r\ni_ReturnValue = -2;\r\n}\r\nreturn i_ReturnValue;\r\n}
