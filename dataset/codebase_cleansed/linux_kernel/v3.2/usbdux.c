static int usbduxsub_unlink_InURBs(struct usbduxsub *usbduxsub_tmp)\r\n{\r\nint i = 0;\r\nint err = 0;\r\nif (usbduxsub_tmp && usbduxsub_tmp->urbIn) {\r\nfor (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {\r\nif (usbduxsub_tmp->urbIn[i]) {\r\nusb_kill_urb(usbduxsub_tmp->urbIn[i]);\r\n}\r\ndev_dbg(&usbduxsub_tmp->interface->dev,\r\n"comedi: usbdux: unlinked InURB %d, err=%d\n",\r\ni, err);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int usbdux_ai_stop(struct usbduxsub *this_usbduxsub, int do_unlink)\r\n{\r\nint ret = 0;\r\nif (!this_usbduxsub) {\r\npr_err("comedi?: usbdux_ai_stop: this_usbduxsub=NULL!\n");\r\nreturn -EFAULT;\r\n}\r\ndev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_stop\n");\r\nif (do_unlink) {\r\nret = usbduxsub_unlink_InURBs(this_usbduxsub);\r\n}\r\nthis_usbduxsub->ai_cmd_running = 0;\r\nreturn ret;\r\n}\r\nstatic int usbdux_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsub *this_usbduxsub;\r\nint res = 0;\r\nthis_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ai_cancel\n");\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nres = usbdux_ai_stop(this_usbduxsub, this_usbduxsub->ai_cmd_running);\r\nup(&this_usbduxsub->sem);\r\nreturn res;\r\n}\r\nstatic void usbduxsub_ai_IsocIrq(struct urb *urb)\r\n{\r\nint i, err, n;\r\nstruct usbduxsub *this_usbduxsub;\r\nstruct comedi_device *this_comedidev;\r\nstruct comedi_subdevice *s;\r\nthis_comedidev = urb->context;\r\nthis_usbduxsub = this_comedidev->private;\r\ns = this_comedidev->subdevices + SUBDEV_AD;\r\nswitch (urb->status) {\r\ncase 0:\r\nmemcpy(this_usbduxsub->inBuffer,\r\nurb->transfer_buffer, SIZEINBUF);\r\nbreak;\r\ncase -EILSEQ:\r\ndev_dbg(&urb->dev->dev,\r\n"comedi%d: usbdux: CRC error in ISO IN stream.\n",\r\nthis_usbduxsub->comedidev->minor);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nif (this_usbduxsub->ai_cmd_running) {\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_ERROR;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nusbdux_ai_stop(this_usbduxsub, 0);\r\n}\r\nreturn;\r\ndefault:\r\nif (this_usbduxsub->ai_cmd_running) {\r\ndev_err(&urb->dev->dev,\r\n"Non-zero urb status received in ai intr "\r\n"context: %d\n", urb->status);\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_ERROR;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nusbdux_ai_stop(this_usbduxsub, 0);\r\n}\r\nreturn;\r\n}\r\nif (unlikely((!(this_usbduxsub->ai_cmd_running)))) {\r\nreturn;\r\n}\r\nurb->dev = this_usbduxsub->usbdev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(err < 0)) {\r\ndev_err(&urb->dev->dev,\r\n"comedi_: urb resubmit failed in int-context! err=%d\n",\r\nerr);\r\nif (err == -EL2NSYNC)\r\ndev_err(&urb->dev->dev,\r\n"buggy USB host controller or bug in IRQ "\r\n"handler!\n");\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_ERROR;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nusbdux_ai_stop(this_usbduxsub, 0);\r\nreturn;\r\n}\r\nthis_usbduxsub->ai_counter--;\r\nif (likely(this_usbduxsub->ai_counter > 0))\r\nreturn;\r\nthis_usbduxsub->ai_counter = this_usbduxsub->ai_timer;\r\nif (!(this_usbduxsub->ai_continous)) {\r\nthis_usbduxsub->ai_sample_count--;\r\nif (this_usbduxsub->ai_sample_count < 0) {\r\nusbdux_ai_stop(this_usbduxsub, 0);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nreturn;\r\n}\r\n}\r\nn = s->async->cmd.chanlist_len;\r\nfor (i = 0; i < n; i++) {\r\nif (CR_RANGE(s->async->cmd.chanlist[i]) <= 1) {\r\nerr = comedi_buf_put\r\n(s->async,\r\nle16_to_cpu(this_usbduxsub->inBuffer[i]) ^ 0x800);\r\n} else {\r\nerr = comedi_buf_put\r\n(s->async,\r\nle16_to_cpu(this_usbduxsub->inBuffer[i]));\r\n}\r\nif (unlikely(err == 0)) {\r\nusbdux_ai_stop(this_usbduxsub, 0);\r\nreturn;\r\n}\r\n}\r\ns->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\n}\r\nstatic int usbduxsub_unlink_OutURBs(struct usbduxsub *usbduxsub_tmp)\r\n{\r\nint i = 0;\r\nint err = 0;\r\nif (usbduxsub_tmp && usbduxsub_tmp->urbOut) {\r\nfor (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {\r\nif (usbduxsub_tmp->urbOut[i])\r\nusb_kill_urb(usbduxsub_tmp->urbOut[i]);\r\ndev_dbg(&usbduxsub_tmp->interface->dev,\r\n"comedi: usbdux: unlinked OutURB %d: res=%d\n",\r\ni, err);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int usbdux_ao_stop(struct usbduxsub *this_usbduxsub, int do_unlink)\r\n{\r\nint ret = 0;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndev_dbg(&this_usbduxsub->interface->dev, "comedi: usbdux_ao_cancel\n");\r\nif (do_unlink)\r\nret = usbduxsub_unlink_OutURBs(this_usbduxsub);\r\nthis_usbduxsub->ao_cmd_running = 0;\r\nreturn ret;\r\n}\r\nstatic int usbdux_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint res = 0;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nres = usbdux_ao_stop(this_usbduxsub, this_usbduxsub->ao_cmd_running);\r\nup(&this_usbduxsub->sem);\r\nreturn res;\r\n}\r\nstatic void usbduxsub_ao_IsocIrq(struct urb *urb)\r\n{\r\nint i, ret;\r\nint8_t *datap;\r\nstruct usbduxsub *this_usbduxsub;\r\nstruct comedi_device *this_comedidev;\r\nstruct comedi_subdevice *s;\r\nthis_comedidev = urb->context;\r\nthis_usbduxsub = this_comedidev->private;\r\ns = this_comedidev->subdevices + SUBDEV_DA;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nif (this_usbduxsub->ao_cmd_running) {\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nusbdux_ao_stop(this_usbduxsub, 0);\r\n}\r\nreturn;\r\ndefault:\r\nif (this_usbduxsub->ao_cmd_running) {\r\ndev_err(&urb->dev->dev,\r\n"comedi_: Non-zero urb status received in ao "\r\n"intr context: %d\n", urb->status);\r\ns->async->events |= COMEDI_CB_ERROR;\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nusbdux_ao_stop(this_usbduxsub, 0);\r\n}\r\nreturn;\r\n}\r\nif (!(this_usbduxsub->ao_cmd_running))\r\nreturn;\r\nthis_usbduxsub->ao_counter--;\r\nif ((int)this_usbduxsub->ao_counter <= 0) {\r\nthis_usbduxsub->ao_counter = this_usbduxsub->ao_timer;\r\nif (!(this_usbduxsub->ao_continous)) {\r\nthis_usbduxsub->ao_sample_count--;\r\nif (this_usbduxsub->ao_sample_count < 0) {\r\nusbdux_ao_stop(this_usbduxsub, 0);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nreturn;\r\n}\r\n}\r\n((uint8_t *) (urb->transfer_buffer))[0] =\r\ns->async->cmd.chanlist_len;\r\nfor (i = 0; i < s->async->cmd.chanlist_len; i++) {\r\nshort temp;\r\nif (i >= NUMOUTCHANNELS)\r\nbreak;\r\ndatap =\r\n(&(((int8_t *) urb->transfer_buffer)[i * 3 + 1]));\r\nret = comedi_buf_get(s->async, &temp);\r\ndatap[0] = temp;\r\ndatap[1] = temp >> 8;\r\ndatap[2] = this_usbduxsub->dac_commands[i];\r\nif (ret < 0) {\r\ndev_err(&urb->dev->dev,\r\n"comedi: buffer underflow\n");\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\ns->async->events |= COMEDI_CB_BLOCK;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\n}\r\n}\r\nurb->transfer_buffer_length = SIZEOUTBUF;\r\nurb->dev = this_usbduxsub->usbdev;\r\nurb->status = 0;\r\nif (this_usbduxsub->ao_cmd_running) {\r\nif (this_usbduxsub->high_speed) {\r\nurb->interval = 8;\r\n} else {\r\nurb->interval = 1;\r\n}\r\nurb->number_of_packets = 1;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = SIZEOUTBUF;\r\nurb->iso_frame_desc[0].status = 0;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(&urb->dev->dev,\r\n"comedi_: ao urb resubm failed in int-cont. "\r\n"ret=%d", ret);\r\nif (ret == EL2NSYNC)\r\ndev_err(&urb->dev->dev,\r\n"buggy USB host controller or bug in "\r\n"IRQ handling!\n");\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_ERROR;\r\ncomedi_event(this_usbduxsub->comedidev, s);\r\nusbdux_ao_stop(this_usbduxsub, 0);\r\n}\r\n}\r\n}\r\nstatic int usbduxsub_start(struct usbduxsub *usbduxsub)\r\n{\r\nint errcode = 0;\r\nuint8_t local_transfer_buffer[16];\r\nlocal_transfer_buffer[0] = 0;\r\nerrcode = usb_control_msg(usbduxsub->usbdev,\r\nusb_sndctrlpipe(usbduxsub->usbdev, 0),\r\nUSBDUXSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXSUB_CPUCS,\r\n0x0000,\r\nlocal_transfer_buffer,\r\n1,\r\nBULK_TIMEOUT);\r\nif (errcode < 0) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: control msg failed (start)\n");\r\nreturn errcode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxsub_stop(struct usbduxsub *usbduxsub)\r\n{\r\nint errcode = 0;\r\nuint8_t local_transfer_buffer[16];\r\nlocal_transfer_buffer[0] = 1;\r\nerrcode = usb_control_msg(usbduxsub->usbdev,\r\nusb_sndctrlpipe(usbduxsub->usbdev, 0),\r\nUSBDUXSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nUSBDUXSUB_CPUCS,\r\n0x0000, local_transfer_buffer,\r\n1,\r\nBULK_TIMEOUT);\r\nif (errcode < 0) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: control msg failed (stop)\n");\r\nreturn errcode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxsub_upload(struct usbduxsub *usbduxsub,\r\nuint8_t *local_transfer_buffer,\r\nunsigned int startAddr, unsigned int len)\r\n{\r\nint errcode;\r\nerrcode = usb_control_msg(usbduxsub->usbdev,\r\nusb_sndctrlpipe(usbduxsub->usbdev, 0),\r\nUSBDUXSUB_FIRMWARE,\r\nVENDOR_DIR_OUT,\r\nstartAddr,\r\n0x0000,\r\nlocal_transfer_buffer,\r\nlen,\r\nBULK_TIMEOUT);\r\ndev_dbg(&usbduxsub->interface->dev, "comedi_: result=%d\n", errcode);\r\nif (errcode < 0) {\r\ndev_err(&usbduxsub->interface->dev, "comedi_: upload failed\n");\r\nreturn errcode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int firmwareUpload(struct usbduxsub *usbduxsub,\r\nconst u8 *firmwareBinary, int sizeFirmware)\r\n{\r\nint ret;\r\nuint8_t *fwBuf;\r\nif (!firmwareBinary)\r\nreturn 0;\r\nif (sizeFirmware > FIRMWARE_MAX_LEN) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"usbdux firmware binary it too large for FX2.\n");\r\nreturn -ENOMEM;\r\n}\r\nfwBuf = kmemdup(firmwareBinary, sizeFirmware, GFP_KERNEL);\r\nif (!fwBuf) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: mem alloc for firmware failed\n");\r\nreturn -ENOMEM;\r\n}\r\nret = usbduxsub_stop(usbduxsub);\r\nif (ret < 0) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: can not stop firmware\n");\r\nkfree(fwBuf);\r\nreturn ret;\r\n}\r\nret = usbduxsub_upload(usbduxsub, fwBuf, 0, sizeFirmware);\r\nif (ret < 0) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: firmware upload failed\n");\r\nkfree(fwBuf);\r\nreturn ret;\r\n}\r\nret = usbduxsub_start(usbduxsub);\r\nif (ret < 0) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: can not start firmware\n");\r\nkfree(fwBuf);\r\nreturn ret;\r\n}\r\nkfree(fwBuf);\r\nreturn 0;\r\n}\r\nstatic int usbduxsub_submit_InURBs(struct usbduxsub *usbduxsub)\r\n{\r\nint i, errFlag;\r\nif (!usbduxsub)\r\nreturn -EFAULT;\r\nfor (i = 0; i < usbduxsub->numOfInBuffers; i++) {\r\nusbduxsub->urbIn[i]->interval = usbduxsub->ai_interval;\r\nusbduxsub->urbIn[i]->context = usbduxsub->comedidev;\r\nusbduxsub->urbIn[i]->dev = usbduxsub->usbdev;\r\nusbduxsub->urbIn[i]->status = 0;\r\nusbduxsub->urbIn[i]->transfer_flags = URB_ISO_ASAP;\r\ndev_dbg(&usbduxsub->interface->dev,\r\n"comedi%d: submitting in-urb[%d]: %p,%p intv=%d\n",\r\nusbduxsub->comedidev->minor, i,\r\n(usbduxsub->urbIn[i]->context),\r\n(usbduxsub->urbIn[i]->dev),\r\n(usbduxsub->urbIn[i]->interval));\r\nerrFlag = usb_submit_urb(usbduxsub->urbIn[i], GFP_ATOMIC);\r\nif (errFlag) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: ai: usb_submit_urb(%d) error %d\n",\r\ni, errFlag);\r\nreturn errFlag;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbduxsub_submit_OutURBs(struct usbduxsub *usbduxsub)\r\n{\r\nint i, errFlag;\r\nif (!usbduxsub)\r\nreturn -EFAULT;\r\nfor (i = 0; i < usbduxsub->numOfOutBuffers; i++) {\r\ndev_dbg(&usbduxsub->interface->dev,\r\n"comedi_: submitting out-urb[%d]\n", i);\r\nusbduxsub->urbOut[i]->context = usbduxsub->comedidev;\r\nusbduxsub->urbOut[i]->dev = usbduxsub->usbdev;\r\nusbduxsub->urbOut[i]->status = 0;\r\nusbduxsub->urbOut[i]->transfer_flags = URB_ISO_ASAP;\r\nerrFlag = usb_submit_urb(usbduxsub->urbOut[i], GFP_ATOMIC);\r\nif (errFlag) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: ao: usb_submit_urb(%d) error %d\n",\r\ni, errFlag);\r\nreturn errFlag;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbdux_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0, tmp, i;\r\nunsigned int tmpTimer;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!(this_usbduxsub->probed))\r\nreturn -ENODEV;\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ai_cmdtest\n", dev->minor);\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->scan_begin_src != TRIG_EXT &&\r\ncmd->scan_begin_src != TRIG_TIMER)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (this_usbduxsub->high_speed) {\r\ni = 1;\r\nwhile (i < (cmd->chanlist_len))\r\ni = i * 2;\r\nif (cmd->scan_begin_arg < (1000000 / 8 * i)) {\r\ncmd->scan_begin_arg = 1000000 / 8 * i;\r\nerr++;\r\n}\r\ntmpTimer =\r\n((unsigned int)(cmd->scan_begin_arg / 125000)) *\r\n125000;\r\nif (cmd->scan_begin_arg != tmpTimer) {\r\ncmd->scan_begin_arg = tmpTimer;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->scan_begin_arg < 1000000) {\r\ncmd->scan_begin_arg = 1000000;\r\nerr++;\r\n}\r\ntmpTimer = ((unsigned int)(cmd->scan_begin_arg /\r\n1000000)) * 1000000;\r\nif (cmd->scan_begin_arg != tmpTimer) {\r\ncmd->scan_begin_arg = tmpTimer;\r\nerr++;\r\n}\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int8_t create_adc_command(unsigned int chan, int range)\r\n{\r\nint8_t p = (range <= 1);\r\nint8_t r = ((range % 2) == 0);\r\nreturn (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);\r\n}\r\nstatic int send_dux_commands(struct usbduxsub *this_usbduxsub, int cmd_type)\r\n{\r\nint result, nsent;\r\nthis_usbduxsub->dux_commands[0] = cmd_type;\r\n#ifdef NOISY_DUX_DEBUGBUG\r\nprintk(KERN_DEBUG "comedi%d: usbdux: dux_commands: ",\r\nthis_usbduxsub->comedidev->minor);\r\nfor (result = 0; result < SIZEOFDUXBUFFER; result++)\r\nprintk(" %02x", this_usbduxsub->dux_commands[result]);\r\nprintk("\n");\r\n#endif\r\nresult = usb_bulk_msg(this_usbduxsub->usbdev,\r\nusb_sndbulkpipe(this_usbduxsub->usbdev,\r\nCOMMAND_OUT_EP),\r\nthis_usbduxsub->dux_commands, SIZEOFDUXBUFFER,\r\n&nsent, BULK_TIMEOUT);\r\nif (result < 0)\r\ndev_err(&this_usbduxsub->interface->dev, "comedi%d: "\r\n"could not transmit dux_command to the usb-device, "\r\n"err=%d\n", this_usbduxsub->comedidev->minor, result);\r\nreturn result;\r\n}\r\nstatic int receive_dux_commands(struct usbduxsub *this_usbduxsub, int command)\r\n{\r\nint result = (-EFAULT);\r\nint nrec;\r\nint i;\r\nfor (i = 0; i < RETRIES; i++) {\r\nresult = usb_bulk_msg(this_usbduxsub->usbdev,\r\nusb_rcvbulkpipe(this_usbduxsub->usbdev,\r\nCOMMAND_IN_EP),\r\nthis_usbduxsub->insnBuffer, SIZEINSNBUF,\r\n&nrec, BULK_TIMEOUT);\r\nif (result < 0) {\r\ndev_err(&this_usbduxsub->interface->dev, "comedi%d: "\r\n"insn: USB error %d while receiving DUX command"\r\n"\n", this_usbduxsub->comedidev->minor, result);\r\nreturn result;\r\n}\r\nif (le16_to_cpu(this_usbduxsub->insnBuffer[0]) == command)\r\nreturn result;\r\n}\r\ndev_err(&this_usbduxsub->interface->dev, "comedi%d: insn: "\r\n"wrong data returned from firmware: want cmd %d, got cmd %d.\n",\r\nthis_usbduxsub->comedidev->minor, command,\r\nle16_to_cpu(this_usbduxsub->insnBuffer[0]));\r\nreturn -EFAULT;\r\n}\r\nstatic int usbdux_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int trignum)\r\n{\r\nint ret;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ai_inttrig\n", dev->minor);\r\nif (trignum != 0) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ai_inttrig: invalid trignum\n",\r\ndev->minor);\r\nup(&this_usbduxsub->sem);\r\nreturn -EINVAL;\r\n}\r\nif (!(this_usbduxsub->ai_cmd_running)) {\r\nthis_usbduxsub->ai_cmd_running = 1;\r\nret = usbduxsub_submit_InURBs(this_usbduxsub);\r\nif (ret < 0) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ai_inttrig: "\r\n"urbSubmit: err=%d\n", dev->minor, ret);\r\nthis_usbduxsub->ai_cmd_running = 0;\r\nup(&this_usbduxsub->sem);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: ai_inttrig but acqu is already running\n",\r\ndev->minor);\r\n}\r\nup(&this_usbduxsub->sem);\r\nreturn 1;\r\n}\r\nstatic int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int chan, range;\r\nint i, ret;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint result;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ai_cmd\n", dev->minor);\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nif (this_usbduxsub->ai_cmd_running) {\r\ndev_err(&this_usbduxsub->interface->dev, "comedi%d: "\r\n"ai_cmd not possible. Another ai_cmd is running.\n",\r\ndev->minor);\r\nup(&this_usbduxsub->sem);\r\nreturn -EBUSY;\r\n}\r\ns->async->cur_chan = 0;\r\nthis_usbduxsub->dux_commands[1] = cmd->chanlist_len;\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nif (i >= NUMCHANNELS) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: channel list too long\n",\r\ndev->minor);\r\nbreak;\r\n}\r\nthis_usbduxsub->dux_commands[i + 2] =\r\ncreate_adc_command(chan, range);\r\n}\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi %d: sending commands to the usb device: size=%u\n",\r\ndev->minor, NUMCHANNELS);\r\nresult = send_dux_commands(this_usbduxsub, SENDADCOMMANDS);\r\nif (result < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn result;\r\n}\r\nif (this_usbduxsub->high_speed) {\r\nthis_usbduxsub->ai_interval = 1;\r\nwhile ((this_usbduxsub->ai_interval) < (cmd->chanlist_len)) {\r\nthis_usbduxsub->ai_interval =\r\n(this_usbduxsub->ai_interval) * 2;\r\n}\r\nthis_usbduxsub->ai_timer = cmd->scan_begin_arg / (125000 *\r\n(this_usbduxsub->\r\nai_interval));\r\n} else {\r\nthis_usbduxsub->ai_interval = 1;\r\nthis_usbduxsub->ai_timer = cmd->scan_begin_arg / 1000000;\r\n}\r\nif (this_usbduxsub->ai_timer < 1) {\r\ndev_err(&this_usbduxsub->interface->dev, "comedi%d: ai_cmd: "\r\n"timer=%d, scan_begin_arg=%d. "\r\n"Not properly tested by cmdtest?\n", dev->minor,\r\nthis_usbduxsub->ai_timer, cmd->scan_begin_arg);\r\nup(&this_usbduxsub->sem);\r\nreturn -EINVAL;\r\n}\r\nthis_usbduxsub->ai_counter = this_usbduxsub->ai_timer;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nthis_usbduxsub->ai_sample_count = cmd->stop_arg;\r\nthis_usbduxsub->ai_continous = 0;\r\n} else {\r\nthis_usbduxsub->ai_continous = 1;\r\nthis_usbduxsub->ai_sample_count = 0;\r\n}\r\nif (cmd->start_src == TRIG_NOW) {\r\nthis_usbduxsub->ai_cmd_running = 1;\r\nret = usbduxsub_submit_InURBs(this_usbduxsub);\r\nif (ret < 0) {\r\nthis_usbduxsub->ai_cmd_running = 0;\r\nup(&this_usbduxsub->sem);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbdux_ai_inttrig;\r\n}\r\nup(&this_usbduxsub->sem);\r\nreturn 0;\r\n}\r\nstatic int usbdux_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nunsigned int one = 0;\r\nint chan, range;\r\nint err;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn 0;\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",\r\ndev->minor, insn->n, insn->subdev);\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nif (this_usbduxsub->ai_cmd_running) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: ai_insn_read not possible. "\r\n"Async Command is running.\n", dev->minor);\r\nup(&this_usbduxsub->sem);\r\nreturn 0;\r\n}\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\nthis_usbduxsub->dux_commands[1] = create_adc_command(chan, range);\r\nerr = send_dux_commands(this_usbduxsub, SENDSINGLEAD);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn err;\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\nerr = receive_dux_commands(this_usbduxsub, SENDSINGLEAD);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn 0;\r\n}\r\none = le16_to_cpu(this_usbduxsub->insnBuffer[1]);\r\nif (CR_RANGE(insn->chanspec) <= 1)\r\none = one ^ 0x800;\r\ndata[i] = one;\r\n}\r\nup(&this_usbduxsub->sem);\r\nreturn i;\r\n}\r\nstatic int usbdux_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = this_usbduxsub->outBuffer[chan];\r\nup(&this_usbduxsub->sem);\r\nreturn i;\r\n}\r\nstatic int usbdux_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i, err;\r\nint chan = CR_CHAN(insn->chanspec);\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: ao_insn_write\n", dev->minor);\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nif (this_usbduxsub->ao_cmd_running) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: ao_insn_write: "\r\n"ERROR: asynchronous ao_cmd is running\n", dev->minor);\r\nup(&this_usbduxsub->sem);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: ao_insn_write: data[chan=%d,i=%d]=%d\n",\r\ndev->minor, chan, i, data[i]);\r\nthis_usbduxsub->dux_commands[1] = 1;\r\n*((int16_t *) (this_usbduxsub->dux_commands + 2)) =\r\ncpu_to_le16(data[i]);\r\nthis_usbduxsub->outBuffer[chan] = data[i];\r\nthis_usbduxsub->dux_commands[4] = (chan << 6);\r\nerr = send_dux_commands(this_usbduxsub, SENDDACOMMANDS);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn err;\r\n}\r\n}\r\nup(&this_usbduxsub->sem);\r\nreturn i;\r\n}\r\nstatic int usbdux_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int trignum)\r\n{\r\nint ret;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nif (trignum != 0) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ao_inttrig: invalid trignum\n",\r\ndev->minor);\r\nup(&this_usbduxsub->sem);\r\nreturn -EINVAL;\r\n}\r\nif (!(this_usbduxsub->ao_cmd_running)) {\r\nthis_usbduxsub->ao_cmd_running = 1;\r\nret = usbduxsub_submit_OutURBs(this_usbduxsub);\r\nif (ret < 0) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ao_inttrig: submitURB: "\r\n"err=%d\n", dev->minor, ret);\r\nthis_usbduxsub->ao_cmd_running = 0;\r\nup(&this_usbduxsub->sem);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: ao_inttrig but acqu is already running.\n",\r\ndev->minor);\r\n}\r\nup(&this_usbduxsub->sem);\r\nreturn 1;\r\n}\r\nstatic int usbdux_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0, tmp;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\nif (!(this_usbduxsub->probed))\r\nreturn -ENODEV;\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux_ao_cmdtest\n", dev->minor);\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\nif (0) {\r\ncmd->scan_begin_src &= TRIG_FOLLOW;\r\n} else {\r\ncmd->scan_begin_src &= TRIG_TIMER;\r\n}\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\nif (0) {\r\ncmd->convert_src &= TRIG_TIMER;\r\n} else {\r\ncmd->convert_src &= TRIG_NOW;\r\n}\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->scan_begin_src != TRIG_EXT &&\r\ncmd->scan_begin_src != TRIG_TIMER)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < 1000000) {\r\ncmd->scan_begin_arg = 1000000;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < 125000) {\r\ncmd->convert_arg = 125000;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\ndev_dbg(&this_usbduxsub->interface->dev, "comedi%d: err=%d, "\r\n"scan_begin_src=%d, scan_begin_arg=%d, convert_src=%d, "\r\n"convert_arg=%d\n", dev->minor, err, cmd->scan_begin_src,\r\ncmd->scan_begin_arg, cmd->convert_src, cmd->convert_arg);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int chan, gain;\r\nint i, ret;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: %s\n", dev->minor, __func__);\r\ns->async->cur_chan = 0;\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\ngain = CR_RANGE(cmd->chanlist[i]);\r\nif (i >= NUMOUTCHANNELS) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: %s: channel list too long\n",\r\ndev->minor, __func__);\r\nbreak;\r\n}\r\nthis_usbduxsub->dac_commands[i] = (chan << 6);\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: dac command for ch %d is %x\n",\r\ndev->minor, i, this_usbduxsub->dac_commands[i]);\r\n}\r\nif (0) {\r\nthis_usbduxsub->ao_timer = cmd->convert_arg / 125000;\r\n} else {\r\nthis_usbduxsub->ao_timer = cmd->scan_begin_arg / 1000000;\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: scan_begin_src=%d, scan_begin_arg=%d, "\r\n"convert_src=%d, convert_arg=%d\n", dev->minor,\r\ncmd->scan_begin_src, cmd->scan_begin_arg,\r\ncmd->convert_src, cmd->convert_arg);\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: ao_timer=%d (ms)\n",\r\ndev->minor, this_usbduxsub->ao_timer);\r\nif (this_usbduxsub->ao_timer < 1) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: usbdux: ao_timer=%d, "\r\n"scan_begin_arg=%d. "\r\n"Not properly tested by cmdtest?\n",\r\ndev->minor, this_usbduxsub->ao_timer,\r\ncmd->scan_begin_arg);\r\nup(&this_usbduxsub->sem);\r\nreturn -EINVAL;\r\n}\r\n}\r\nthis_usbduxsub->ao_counter = this_usbduxsub->ao_timer;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (0) {\r\nthis_usbduxsub->ao_sample_count =\r\n(cmd->stop_arg) * (cmd->scan_end_arg);\r\n} else {\r\nthis_usbduxsub->ao_sample_count = cmd->stop_arg;\r\n}\r\nthis_usbduxsub->ao_continous = 0;\r\n} else {\r\nthis_usbduxsub->ao_continous = 1;\r\nthis_usbduxsub->ao_sample_count = 0;\r\n}\r\nif (cmd->start_src == TRIG_NOW) {\r\nthis_usbduxsub->ao_cmd_running = 1;\r\nret = usbduxsub_submit_OutURBs(this_usbduxsub);\r\nif (ret < 0) {\r\nthis_usbduxsub->ao_cmd_running = 0;\r\nup(&this_usbduxsub->sem);\r\nreturn ret;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbdux_ao_inttrig;\r\n}\r\nup(&this_usbduxsub->sem);\r\nreturn 0;\r\n}\r\nstatic int usbdux_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= 1 << chan;\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~(1 << chan);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int usbdux_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint err;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\ns->state &= ~data[0];\r\ns->state |= data[0] & data[1];\r\nthis_usbduxsub->dux_commands[1] = s->io_bits;\r\nthis_usbduxsub->dux_commands[2] = s->state;\r\nerr = send_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn err;\r\n}\r\nerr = receive_dux_commands(this_usbduxsub, SENDDIOBITSCOMMAND);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn err;\r\n}\r\ndata[1] = le16_to_cpu(this_usbduxsub->insnBuffer[1]);\r\nup(&this_usbduxsub->sem);\r\nreturn 2;\r\n}\r\nstatic int usbdux_counter_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint chan = insn->chanspec;\r\nint err;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nerr = send_dux_commands(this_usbduxsub, READCOUNTERCOMMAND);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn err;\r\n}\r\nerr = receive_dux_commands(this_usbduxsub, READCOUNTERCOMMAND);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn err;\r\n}\r\ndata[0] = le16_to_cpu(this_usbduxsub->insnBuffer[chan + 1]);\r\nup(&this_usbduxsub->sem);\r\nreturn 1;\r\n}\r\nstatic int usbdux_counter_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint err;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndown(&this_usbduxsub->sem);\r\nif (!(this_usbduxsub->probed)) {\r\nup(&this_usbduxsub->sem);\r\nreturn -ENODEV;\r\n}\r\nthis_usbduxsub->dux_commands[1] = insn->chanspec;\r\n*((int16_t *) (this_usbduxsub->dux_commands + 2)) = cpu_to_le16(*data);\r\nerr = send_dux_commands(this_usbduxsub, WRITECOUNTERCOMMAND);\r\nif (err < 0) {\r\nup(&this_usbduxsub->sem);\r\nreturn err;\r\n}\r\nup(&this_usbduxsub->sem);\r\nreturn 1;\r\n}\r\nstatic int usbdux_counter_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn 2;\r\n}\r\nstatic int usbduxsub_unlink_PwmURBs(struct usbduxsub *usbduxsub_tmp)\r\n{\r\nint err = 0;\r\nif (usbduxsub_tmp && usbduxsub_tmp->urbPwm) {\r\nif (usbduxsub_tmp->urbPwm)\r\nusb_kill_urb(usbduxsub_tmp->urbPwm);\r\ndev_dbg(&usbduxsub_tmp->interface->dev,\r\n"comedi: unlinked PwmURB: res=%d\n", err);\r\n}\r\nreturn err;\r\n}\r\nstatic int usbdux_pwm_stop(struct usbduxsub *this_usbduxsub, int do_unlink)\r\n{\r\nint ret = 0;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\ndev_dbg(&this_usbduxsub->interface->dev, "comedi: %s\n", __func__);\r\nif (do_unlink)\r\nret = usbduxsub_unlink_PwmURBs(this_usbduxsub);\r\nthis_usbduxsub->pwm_cmd_running = 0;\r\nreturn ret;\r\n}\r\nstatic int usbdux_pwm_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint res = 0;\r\nres = usbdux_pwm_stop(this_usbduxsub, this_usbduxsub->pwm_cmd_running);\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi %d: sending pwm off command to the usb device.\n",\r\ndev->minor);\r\nreturn send_dux_commands(this_usbduxsub, SENDPWMOFF);\r\n}\r\nstatic void usbduxsub_pwm_irq(struct urb *urb)\r\n{\r\nint ret;\r\nstruct usbduxsub *this_usbduxsub;\r\nstruct comedi_device *this_comedidev;\r\nstruct comedi_subdevice *s;\r\nthis_comedidev = urb->context;\r\nthis_usbduxsub = this_comedidev->private;\r\ns = this_comedidev->subdevices + SUBDEV_DA;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nif (this_usbduxsub->pwm_cmd_running)\r\nusbdux_pwm_stop(this_usbduxsub, 0);\r\nreturn;\r\ndefault:\r\nif (this_usbduxsub->pwm_cmd_running) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi_: Non-zero urb status received in "\r\n"pwm intr context: %d\n", urb->status);\r\nusbdux_pwm_stop(this_usbduxsub, 0);\r\n}\r\nreturn;\r\n}\r\nif (!(this_usbduxsub->pwm_cmd_running))\r\nreturn;\r\nurb->transfer_buffer_length = this_usbduxsub->sizePwmBuf;\r\nurb->dev = this_usbduxsub->usbdev;\r\nurb->status = 0;\r\nif (this_usbduxsub->pwm_cmd_running) {\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi_: pwm urb resubm failed in int-cont. "\r\n"ret=%d", ret);\r\nif (ret == EL2NSYNC)\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"buggy USB host controller or bug in "\r\n"IRQ handling!\n");\r\nusbdux_pwm_stop(this_usbduxsub, 0);\r\n}\r\n}\r\n}\r\nstatic int usbduxsub_submit_PwmURBs(struct usbduxsub *usbduxsub)\r\n{\r\nint errFlag;\r\nif (!usbduxsub)\r\nreturn -EFAULT;\r\ndev_dbg(&usbduxsub->interface->dev, "comedi_: submitting pwm-urb\n");\r\nusb_fill_bulk_urb(usbduxsub->urbPwm,\r\nusbduxsub->usbdev,\r\nusb_sndbulkpipe(usbduxsub->usbdev, PWM_EP),\r\nusbduxsub->urbPwm->transfer_buffer,\r\nusbduxsub->sizePwmBuf, usbduxsub_pwm_irq,\r\nusbduxsub->comedidev);\r\nerrFlag = usb_submit_urb(usbduxsub->urbPwm, GFP_ATOMIC);\r\nif (errFlag) {\r\ndev_err(&usbduxsub->interface->dev,\r\n"comedi_: usbdux: pwm: usb_submit_urb error %d\n",\r\nerrFlag);\r\nreturn errFlag;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbdux_pwm_period(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int period)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint fx2delay = 255;\r\nif (period < MIN_PWM_PERIOD) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: illegal period setting for pwm.\n",\r\ndev->minor);\r\nreturn -EAGAIN;\r\n} else {\r\nfx2delay = period / ((int)(6 * 512 * (1.0 / 0.033))) - 6;\r\nif (fx2delay > 255) {\r\ndev_err(&this_usbduxsub->interface->dev,\r\n"comedi%d: period %d for pwm is too low.\n",\r\ndev->minor, period);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nthis_usbduxsub->pwmDelay = fx2delay;\r\nthis_usbduxsub->pwmPeriod = period;\r\ndev_dbg(&this_usbduxsub->interface->dev, "%s: frequ=%d, period=%d\n",\r\n__func__, period, fx2delay);\r\nreturn 0;\r\n}\r\nstatic int usbdux_pwm_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint ret, i;\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\ndev_dbg(&this_usbduxsub->interface->dev, "comedi%d: %s\n",\r\ndev->minor, __func__);\r\nif (this_usbduxsub->pwm_cmd_running) {\r\nreturn 0;\r\n}\r\nthis_usbduxsub->dux_commands[1] = ((int8_t) this_usbduxsub->pwmDelay);\r\nret = send_dux_commands(this_usbduxsub, SENDPWMON);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < this_usbduxsub->sizePwmBuf; i++)\r\n((char *)(this_usbduxsub->urbPwm->transfer_buffer))[i] = 0;\r\nthis_usbduxsub->pwm_cmd_running = 1;\r\nret = usbduxsub_submit_PwmURBs(this_usbduxsub);\r\nif (ret < 0) {\r\nthis_usbduxsub->pwm_cmd_running = 0;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbdux_pwm_pattern(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int channel,\r\nunsigned int value, unsigned int sign)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nint i, szbuf;\r\nchar *pBuf;\r\nchar pwm_mask;\r\nchar sgn_mask;\r\nchar c;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\npwm_mask = (1 << channel);\r\nsgn_mask = (16 << channel);\r\nszbuf = this_usbduxsub->sizePwmBuf;\r\npBuf = (char *)(this_usbduxsub->urbPwm->transfer_buffer);\r\nfor (i = 0; i < szbuf; i++) {\r\nc = *pBuf;\r\nc = c & (~pwm_mask);\r\nif (i < value)\r\nc = c | pwm_mask;\r\nif (!sign) {\r\nc = c & (~sgn_mask);\r\n} else {\r\nc = c | sgn_mask;\r\n}\r\n*(pBuf++) = c;\r\n}\r\nreturn 1;\r\n}\r\nstatic int usbdux_pwm_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\nif ((insn->n) != 1) {\r\nreturn -EINVAL;\r\n}\r\nreturn usbdux_pwm_pattern(dev, s, CR_CHAN(insn->chanspec), data[0], 0);\r\n}\r\nstatic int usbdux_pwm_read(struct comedi_device *x1,\r\nstruct comedi_subdevice *x2, struct comedi_insn *x3,\r\nunsigned int *x4)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int usbdux_pwm_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct usbduxsub *this_usbduxsub = dev->private;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ARM:\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: %s: pwm on\n", dev->minor, __func__);\r\nif (data[1] != 0)\r\nreturn -EINVAL;\r\nreturn usbdux_pwm_start(dev, s);\r\ncase INSN_CONFIG_DISARM:\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: %s: pwm off\n", dev->minor, __func__);\r\nreturn usbdux_pwm_cancel(dev, s);\r\ncase INSN_CONFIG_GET_PWM_STATUS:\r\ndata[1] = this_usbduxsub->pwm_cmd_running;\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_SET_PERIOD:\r\ndev_dbg(&this_usbduxsub->interface->dev,\r\n"comedi%d: %s: setting period\n", dev->minor, __func__);\r\nreturn usbdux_pwm_period(dev, s, data[1]);\r\ncase INSN_CONFIG_PWM_GET_PERIOD:\r\ndata[1] = this_usbduxsub->pwmPeriod;\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_SET_H_BRIDGE:\r\nreturn usbdux_pwm_pattern(dev, s,\r\nCR_CHAN(insn->chanspec),\r\ndata[1],\r\n(data[2] != 0));\r\ncase INSN_CONFIG_PWM_GET_H_BRIDGE:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void tidy_up(struct usbduxsub *usbduxsub_tmp)\r\n{\r\nint i;\r\nif (!usbduxsub_tmp)\r\nreturn;\r\ndev_dbg(&usbduxsub_tmp->interface->dev, "comedi_: tiding up\n");\r\nif (usbduxsub_tmp->interface)\r\nusb_set_intfdata(usbduxsub_tmp->interface, NULL);\r\nusbduxsub_tmp->probed = 0;\r\nif (usbduxsub_tmp->urbIn) {\r\nif (usbduxsub_tmp->ai_cmd_running) {\r\nusbduxsub_tmp->ai_cmd_running = 0;\r\nusbduxsub_unlink_InURBs(usbduxsub_tmp);\r\n}\r\nfor (i = 0; i < usbduxsub_tmp->numOfInBuffers; i++) {\r\nkfree(usbduxsub_tmp->urbIn[i]->transfer_buffer);\r\nusbduxsub_tmp->urbIn[i]->transfer_buffer = NULL;\r\nusb_kill_urb(usbduxsub_tmp->urbIn[i]);\r\nusb_free_urb(usbduxsub_tmp->urbIn[i]);\r\nusbduxsub_tmp->urbIn[i] = NULL;\r\n}\r\nkfree(usbduxsub_tmp->urbIn);\r\nusbduxsub_tmp->urbIn = NULL;\r\n}\r\nif (usbduxsub_tmp->urbOut) {\r\nif (usbduxsub_tmp->ao_cmd_running) {\r\nusbduxsub_tmp->ao_cmd_running = 0;\r\nusbduxsub_unlink_OutURBs(usbduxsub_tmp);\r\n}\r\nfor (i = 0; i < usbduxsub_tmp->numOfOutBuffers; i++) {\r\nkfree(usbduxsub_tmp->urbOut[i]->transfer_buffer);\r\nusbduxsub_tmp->urbOut[i]->transfer_buffer = NULL;\r\nif (usbduxsub_tmp->urbOut[i]) {\r\nusb_kill_urb(usbduxsub_tmp->urbOut[i]);\r\nusb_free_urb(usbduxsub_tmp->urbOut[i]);\r\nusbduxsub_tmp->urbOut[i] = NULL;\r\n}\r\n}\r\nkfree(usbduxsub_tmp->urbOut);\r\nusbduxsub_tmp->urbOut = NULL;\r\n}\r\nif (usbduxsub_tmp->urbPwm) {\r\nif (usbduxsub_tmp->pwm_cmd_running) {\r\nusbduxsub_tmp->pwm_cmd_running = 0;\r\nusbduxsub_unlink_PwmURBs(usbduxsub_tmp);\r\n}\r\nkfree(usbduxsub_tmp->urbPwm->transfer_buffer);\r\nusbduxsub_tmp->urbPwm->transfer_buffer = NULL;\r\nusb_kill_urb(usbduxsub_tmp->urbPwm);\r\nusb_free_urb(usbduxsub_tmp->urbPwm);\r\nusbduxsub_tmp->urbPwm = NULL;\r\n}\r\nkfree(usbduxsub_tmp->inBuffer);\r\nusbduxsub_tmp->inBuffer = NULL;\r\nkfree(usbduxsub_tmp->insnBuffer);\r\nusbduxsub_tmp->insnBuffer = NULL;\r\nkfree(usbduxsub_tmp->outBuffer);\r\nusbduxsub_tmp->outBuffer = NULL;\r\nkfree(usbduxsub_tmp->dac_commands);\r\nusbduxsub_tmp->dac_commands = NULL;\r\nkfree(usbduxsub_tmp->dux_commands);\r\nusbduxsub_tmp->dux_commands = NULL;\r\nusbduxsub_tmp->ai_cmd_running = 0;\r\nusbduxsub_tmp->ao_cmd_running = 0;\r\nusbduxsub_tmp->pwm_cmd_running = 0;\r\n}\r\nstatic void usbdux_firmware_request_complete_handler(const struct firmware *fw,\r\nvoid *context)\r\n{\r\nstruct usbduxsub *usbduxsub_tmp = context;\r\nstruct usb_device *usbdev = usbduxsub_tmp->usbdev;\r\nint ret;\r\nif (fw == NULL) {\r\ndev_err(&usbdev->dev,\r\n"Firmware complete handler without firmware!\n");\r\nreturn;\r\n}\r\nret = firmwareUpload(usbduxsub_tmp, fw->data, fw->size);\r\nif (ret) {\r\ndev_err(&usbdev->dev,\r\n"Could not upload firmware (err=%d)\n", ret);\r\ngoto out;\r\n}\r\ncomedi_usb_auto_config(usbdev, BOARDNAME);\r\nout:\r\nrelease_firmware(fw);\r\n}\r\nstatic int usbduxsub_probe(struct usb_interface *uinterf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(uinterf);\r\nstruct device *dev = &uinterf->dev;\r\nint i;\r\nint index;\r\nint ret;\r\ndev_dbg(dev, "comedi_: usbdux_: "\r\n"finding a free structure for the usb-device\n");\r\ndown(&start_stop_sem);\r\nindex = -1;\r\nfor (i = 0; i < NUMUSBDUX; i++) {\r\nif (!(usbduxsub[i].probed)) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nif (index == -1) {\r\ndev_err(dev, "Too many usbdux-devices connected.\n");\r\nup(&start_stop_sem);\r\nreturn -EMFILE;\r\n}\r\ndev_dbg(dev, "comedi_: usbdux: "\r\n"usbduxsub[%d] is ready to connect to comedi.\n", index);\r\nsema_init(&(usbduxsub[index].sem), 1);\r\nusbduxsub[index].usbdev = udev;\r\nusbduxsub[index].interface = uinterf;\r\nusbduxsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;\r\nusb_set_intfdata(uinterf, &(usbduxsub[index]));\r\ndev_dbg(dev, "comedi_: usbdux: ifnum=%d\n", usbduxsub[index].ifnum);\r\nusbduxsub[index].high_speed =\r\n(usbduxsub[index].usbdev->speed == USB_SPEED_HIGH);\r\nusbduxsub[index].dac_commands = kzalloc(NUMOUTCHANNELS, GFP_KERNEL);\r\nif (!usbduxsub[index].dac_commands) {\r\ndev_err(dev, "comedi_: usbdux: "\r\n"error alloc space for dac commands\n");\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);\r\nif (!usbduxsub[index].dux_commands) {\r\ndev_err(dev, "comedi_: usbdux: "\r\n"error alloc space for dux commands\n");\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].inBuffer = kzalloc(SIZEINBUF, GFP_KERNEL);\r\nif (!(usbduxsub[index].inBuffer)) {\r\ndev_err(dev, "comedi_: usbdux: "\r\n"could not alloc space for inBuffer\n");\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].insnBuffer = kzalloc(SIZEINSNBUF, GFP_KERNEL);\r\nif (!(usbduxsub[index].insnBuffer)) {\r\ndev_err(dev, "comedi_: usbdux: "\r\n"could not alloc space for insnBuffer\n");\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].outBuffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);\r\nif (!(usbduxsub[index].outBuffer)) {\r\ndev_err(dev, "comedi_: usbdux: "\r\n"could not alloc space for outBuffer\n");\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\ni = usb_set_interface(usbduxsub[index].usbdev,\r\nusbduxsub[index].ifnum, 3);\r\nif (i < 0) {\r\ndev_err(dev, "comedi_: usbdux%d: "\r\n"could not set alternate setting 3 in high speed.\n",\r\nindex);\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENODEV;\r\n}\r\nif (usbduxsub[index].high_speed)\r\nusbduxsub[index].numOfInBuffers = NUMOFINBUFFERSHIGH;\r\nelse\r\nusbduxsub[index].numOfInBuffers = NUMOFINBUFFERSFULL;\r\nusbduxsub[index].urbIn =\r\nkzalloc(sizeof(struct urb *) * usbduxsub[index].numOfInBuffers,\r\nGFP_KERNEL);\r\nif (!(usbduxsub[index].urbIn)) {\r\ndev_err(dev, "comedi_: usbdux: Could not alloc. urbIn array\n");\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < usbduxsub[index].numOfInBuffers; i++) {\r\nusbduxsub[index].urbIn[i] = usb_alloc_urb(1, GFP_KERNEL);\r\nif (usbduxsub[index].urbIn[i] == NULL) {\r\ndev_err(dev, "comedi_: usbdux%d: "\r\n"Could not alloc. urb(%d)\n", index, i);\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].urbIn[i]->dev = usbduxsub[index].usbdev;\r\nusbduxsub[index].urbIn[i]->context = NULL;\r\nusbduxsub[index].urbIn[i]->pipe =\r\nusb_rcvisocpipe(usbduxsub[index].usbdev, ISOINEP);\r\nusbduxsub[index].urbIn[i]->transfer_flags = URB_ISO_ASAP;\r\nusbduxsub[index].urbIn[i]->transfer_buffer =\r\nkzalloc(SIZEINBUF, GFP_KERNEL);\r\nif (!(usbduxsub[index].urbIn[i]->transfer_buffer)) {\r\ndev_err(dev, "comedi_: usbdux%d: "\r\n"could not alloc. transb.\n", index);\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].urbIn[i]->complete = usbduxsub_ai_IsocIrq;\r\nusbduxsub[index].urbIn[i]->number_of_packets = 1;\r\nusbduxsub[index].urbIn[i]->transfer_buffer_length = SIZEINBUF;\r\nusbduxsub[index].urbIn[i]->iso_frame_desc[0].offset = 0;\r\nusbduxsub[index].urbIn[i]->iso_frame_desc[0].length = SIZEINBUF;\r\n}\r\nif (usbduxsub[index].high_speed)\r\nusbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSHIGH;\r\nelse\r\nusbduxsub[index].numOfOutBuffers = NUMOFOUTBUFFERSFULL;\r\nusbduxsub[index].urbOut =\r\nkzalloc(sizeof(struct urb *) * usbduxsub[index].numOfOutBuffers,\r\nGFP_KERNEL);\r\nif (!(usbduxsub[index].urbOut)) {\r\ndev_err(dev, "comedi_: usbdux: "\r\n"Could not alloc. urbOut array\n");\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < usbduxsub[index].numOfOutBuffers; i++) {\r\nusbduxsub[index].urbOut[i] = usb_alloc_urb(1, GFP_KERNEL);\r\nif (usbduxsub[index].urbOut[i] == NULL) {\r\ndev_err(dev, "comedi_: usbdux%d: "\r\n"Could not alloc. urb(%d)\n", index, i);\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].urbOut[i]->dev = usbduxsub[index].usbdev;\r\nusbduxsub[index].urbOut[i]->context = NULL;\r\nusbduxsub[index].urbOut[i]->pipe =\r\nusb_sndisocpipe(usbduxsub[index].usbdev, ISOOUTEP);\r\nusbduxsub[index].urbOut[i]->transfer_flags = URB_ISO_ASAP;\r\nusbduxsub[index].urbOut[i]->transfer_buffer =\r\nkzalloc(SIZEOUTBUF, GFP_KERNEL);\r\nif (!(usbduxsub[index].urbOut[i]->transfer_buffer)) {\r\ndev_err(dev, "comedi_: usbdux%d: "\r\n"could not alloc. transb.\n", index);\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].urbOut[i]->complete = usbduxsub_ao_IsocIrq;\r\nusbduxsub[index].urbOut[i]->number_of_packets = 1;\r\nusbduxsub[index].urbOut[i]->transfer_buffer_length = SIZEOUTBUF;\r\nusbduxsub[index].urbOut[i]->iso_frame_desc[0].offset = 0;\r\nusbduxsub[index].urbOut[i]->iso_frame_desc[0].length =\r\nSIZEOUTBUF;\r\nif (usbduxsub[index].high_speed) {\r\nusbduxsub[index].urbOut[i]->interval = 8;\r\n} else {\r\nusbduxsub[index].urbOut[i]->interval = 1;\r\n}\r\n}\r\nif (usbduxsub[index].high_speed) {\r\nusbduxsub[index].sizePwmBuf = 512;\r\nusbduxsub[index].urbPwm = usb_alloc_urb(0, GFP_KERNEL);\r\nif (usbduxsub[index].urbPwm == NULL) {\r\ndev_err(dev, "comedi_: usbdux%d: "\r\n"Could not alloc. pwm urb\n", index);\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\nusbduxsub[index].urbPwm->transfer_buffer =\r\nkzalloc(usbduxsub[index].sizePwmBuf, GFP_KERNEL);\r\nif (!(usbduxsub[index].urbPwm->transfer_buffer)) {\r\ndev_err(dev, "comedi_: usbdux%d: "\r\n"could not alloc. transb. for pwm\n", index);\r\ntidy_up(&(usbduxsub[index]));\r\nup(&start_stop_sem);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nusbduxsub[index].urbPwm = NULL;\r\nusbduxsub[index].sizePwmBuf = 0;\r\n}\r\nusbduxsub[index].ai_cmd_running = 0;\r\nusbduxsub[index].ao_cmd_running = 0;\r\nusbduxsub[index].pwm_cmd_running = 0;\r\nusbduxsub[index].probed = 1;\r\nup(&start_stop_sem);\r\nret = request_firmware_nowait(THIS_MODULE,\r\nFW_ACTION_HOTPLUG,\r\n"usbdux_firmware.bin",\r\n&udev->dev,\r\nGFP_KERNEL,\r\nusbduxsub + index,\r\nusbdux_firmware_request_complete_handler);\r\nif (ret) {\r\ndev_err(dev, "Could not load firmware (err=%d)\n", ret);\r\nreturn ret;\r\n}\r\ndev_info(dev, "comedi_: usbdux%d "\r\n"has been successfully initialised.\n", index);\r\nreturn 0;\r\n}\r\nstatic void usbduxsub_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbduxsub *usbduxsub_tmp = usb_get_intfdata(intf);\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (!usbduxsub_tmp) {\r\ndev_err(&intf->dev,\r\n"comedi_: disconnect called with null pointer.\n");\r\nreturn;\r\n}\r\nif (usbduxsub_tmp->usbdev != udev) {\r\ndev_err(&intf->dev, "comedi_: BUG! called with wrong ptr!!!\n");\r\nreturn;\r\n}\r\ncomedi_usb_auto_unconfig(udev);\r\ndown(&start_stop_sem);\r\ndown(&usbduxsub_tmp->sem);\r\ntidy_up(usbduxsub_tmp);\r\nup(&usbduxsub_tmp->sem);\r\nup(&start_stop_sem);\r\ndev_dbg(&intf->dev, "comedi_: disconnected from the usb\n");\r\n}\r\nstatic int usbdux_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nint ret;\r\nint index;\r\nint i;\r\nstruct usbduxsub *udev;\r\nstruct comedi_subdevice *s = NULL;\r\ndev->private = NULL;\r\ndown(&start_stop_sem);\r\nindex = -1;\r\nfor (i = 0; i < NUMUSBDUX; i++) {\r\nif ((usbduxsub[i].probed) && (!usbduxsub[i].attached)) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nif (index < 0) {\r\nprintk(KERN_ERR "comedi%d: usbdux: error: attach failed, no "\r\n"usbdux devs connected to the usb bus.\n", dev->minor);\r\nup(&start_stop_sem);\r\nreturn -ENODEV;\r\n}\r\nudev = &usbduxsub[index];\r\ndown(&udev->sem);\r\nudev->comedidev = dev;\r\nif (comedi_aux_data(it->options, 0) &&\r\nit->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {\r\nfirmwareUpload(udev, comedi_aux_data(it->options, 0),\r\nit->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]);\r\n}\r\ndev->board_name = BOARDNAME;\r\nif (udev->high_speed) {\r\ndev->n_subdevices = 5;\r\n} else {\r\ndev->n_subdevices = 4;\r\n}\r\nret = alloc_subdevices(dev, dev->n_subdevices);\r\nif (ret < 0) {\r\ndev_err(&udev->interface->dev,\r\n"comedi%d: error alloc space for subdev\n", dev->minor);\r\nup(&udev->sem);\r\nup(&start_stop_sem);\r\nreturn ret;\r\n}\r\ndev_info(&udev->interface->dev,\r\n"comedi%d: usb-device %d is attached to comedi.\n",\r\ndev->minor, index);\r\ndev->private = udev;\r\ns = dev->subdevices + SUBDEV_AD;\r\ndev->read_subdev = s;\r\ns->private = NULL;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\r\ns->n_chan = 8;\r\ns->len_chanlist = 8;\r\ns->insn_read = usbdux_ai_insn_read;\r\ns->do_cmdtest = usbdux_ai_cmdtest;\r\ns->do_cmd = usbdux_ai_cmd;\r\ns->cancel = usbdux_ai_cancel;\r\ns->maxdata = 0xfff;\r\ns->range_table = (&range_usbdux_ai_range);\r\ns = dev->subdevices + SUBDEV_DA;\r\ns->type = COMEDI_SUBD_AO;\r\ndev->write_subdev = s;\r\ns->private = NULL;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\r\ns->n_chan = 4;\r\ns->len_chanlist = 4;\r\ns->maxdata = 0x0fff;\r\ns->range_table = (&range_usbdux_ao_range);\r\ns->do_cmdtest = usbdux_ao_cmdtest;\r\ns->do_cmd = usbdux_ao_cmd;\r\ns->cancel = usbdux_ao_cancel;\r\ns->insn_read = usbdux_ao_insn_read;\r\ns->insn_write = usbdux_ao_insn_write;\r\ns = dev->subdevices + SUBDEV_DIO;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = (&range_digital);\r\ns->insn_bits = usbdux_dio_insn_bits;\r\ns->insn_config = usbdux_dio_insn_config;\r\ns->private = NULL;\r\ns = dev->subdevices + SUBDEV_COUNTER;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 0xFFFF;\r\ns->insn_read = usbdux_counter_read;\r\ns->insn_write = usbdux_counter_write;\r\ns->insn_config = usbdux_counter_config;\r\nif (udev->high_speed) {\r\ns = dev->subdevices + SUBDEV_PWM;\r\ns->type = COMEDI_SUBD_PWM;\r\ns->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;\r\ns->n_chan = 8;\r\ns->maxdata = udev->sizePwmBuf;\r\ns->insn_write = usbdux_pwm_write;\r\ns->insn_read = usbdux_pwm_read;\r\ns->insn_config = usbdux_pwm_config;\r\nusbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);\r\n}\r\nudev->attached = 1;\r\nup(&udev->sem);\r\nup(&start_stop_sem);\r\ndev_info(&udev->interface->dev, "comedi%d: attached to usbdux.\n",\r\ndev->minor);\r\nreturn 0;\r\n}\r\nstatic int usbdux_detach(struct comedi_device *dev)\r\n{\r\nstruct usbduxsub *usbduxsub_tmp;\r\nif (!dev) {\r\nprintk(KERN_ERR\r\n"comedi?: usbdux: detach without dev variable...\n");\r\nreturn -EFAULT;\r\n}\r\nusbduxsub_tmp = dev->private;\r\nif (!usbduxsub_tmp) {\r\nprintk(KERN_ERR\r\n"comedi?: usbdux: detach without ptr to usbduxsub[]\n");\r\nreturn -EFAULT;\r\n}\r\ndev_dbg(&usbduxsub_tmp->interface->dev, "comedi%d: detach usb device\n",\r\ndev->minor);\r\ndown(&usbduxsub_tmp->sem);\r\ndev->private = NULL;\r\nusbduxsub_tmp->attached = 0;\r\nusbduxsub_tmp->comedidev = NULL;\r\ndev_dbg(&usbduxsub_tmp->interface->dev,\r\n"comedi%d: detach: successfully removed\n", dev->minor);\r\nup(&usbduxsub_tmp->sem);\r\nreturn 0;\r\n}\r\nstatic int __init init_usbdux(void)\r\n{\r\nprintk(KERN_INFO KBUILD_MODNAME ": "\r\nDRIVER_VERSION ":" DRIVER_DESC "\n");\r\nusb_register(&usbduxsub_driver);\r\ncomedi_driver_register(&driver_usbdux);\r\nreturn 0;\r\n}\r\nstatic void __exit exit_usbdux(void)\r\n{\r\ncomedi_driver_unregister(&driver_usbdux);\r\nusb_deregister(&usbduxsub_driver);\r\n}
