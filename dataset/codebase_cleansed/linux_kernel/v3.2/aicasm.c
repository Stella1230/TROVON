int\r\nmain(int argc, char *argv[])\r\n{\r\nextern char *optarg;\r\nextern int optind;\r\nint ch;\r\nint retval;\r\nchar *inputfilename;\r\nscope_t *sentinal;\r\nSTAILQ_INIT(&patches);\r\nSLIST_INIT(&search_path);\r\nSTAILQ_INIT(&seq_program);\r\nTAILQ_INIT(&cs_tailq);\r\nSLIST_INIT(&scope_stack);\r\nsentinal = scope_alloc();\r\nsentinal->type = SCOPE_ROOT;\r\nincludes_search_curdir = 1;\r\nappname = *argv;\r\nregfile = NULL;\r\nlistfile = NULL;\r\n#if DEBUG\r\nyy_flex_debug = 0;\r\nmm_flex_debug = 0;\r\nyydebug = 0;\r\nmmdebug = 0;\r\n#endif\r\nwhile ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:")) != -1) {\r\nswitch(ch) {\r\ncase 'd':\r\n#if DEBUG\r\nif (strcmp(optarg, "s") == 0) {\r\nyy_flex_debug = 1;\r\nmm_flex_debug = 1;\r\n} else if (strcmp(optarg, "p") == 0) {\r\nyydebug = 1;\r\nmmdebug = 1;\r\n} else {\r\nfprintf(stderr, "%s: -d Requires either an "\r\n"'s' or 'p' argument\n", appname);\r\nusage();\r\n}\r\n#else\r\nstop("-d: Assembler not built with debugging "\r\n"information", EX_SOFTWARE);\r\n#endif\r\nbreak;\r\ncase 'i':\r\nstock_include_file = optarg;\r\nbreak;\r\ncase 'l':\r\nif ((listfile = fopen(optarg, "w")) == NULL) {\r\nperror(optarg);\r\nstop(NULL, EX_CANTCREAT);\r\n}\r\nlistfilename = optarg;\r\nbreak;\r\ncase 'n':\r\nif (strcmp(optarg, "ostdinc")) {\r\nfprintf(stderr, "%s: Unknown option -%c%s\n",\r\nappname, ch, optarg);\r\nusage();\r\n}\r\nbreak;\r\ncase 'o':\r\nif ((ofile = fopen(optarg, "w")) == NULL) {\r\nperror(optarg);\r\nstop(NULL, EX_CANTCREAT);\r\n}\r\nofilename = optarg;\r\nbreak;\r\ncase 'p':\r\nif ((regdiagfile = fopen(optarg, "w")) == NULL) {\r\nperror(optarg);\r\nstop(NULL, EX_CANTCREAT);\r\n}\r\nregdiagfilename = optarg;\r\nbreak;\r\ncase 'r':\r\nif ((regfile = fopen(optarg, "w")) == NULL) {\r\nperror(optarg);\r\nstop(NULL, EX_CANTCREAT);\r\n}\r\nregfilename = optarg;\r\nbreak;\r\ncase 'I':\r\n{\r\npath_entry_t include_dir;\r\nif (strcmp(optarg, "-") == 0) {\r\nif (includes_search_curdir == 0) {\r\nfprintf(stderr, "%s: Warning - '-I-' "\r\n"specified multiple "\r\n"times\n", appname);\r\n}\r\nincludes_search_curdir = 0;\r\nfor (include_dir = SLIST_FIRST(&search_path);\r\ninclude_dir != NULL;\r\ninclude_dir = SLIST_NEXT(include_dir,\r\nlinks))\r\ninclude_dir->quoted_includes_only = 1;\r\n} else {\r\ninclude_dir =\r\n(path_entry_t)malloc(sizeof(*include_dir));\r\nif (include_dir == NULL) {\r\nperror(optarg);\r\nstop(NULL, EX_OSERR);\r\n}\r\ninclude_dir->directory = strdup(optarg);\r\nif (include_dir->directory == NULL) {\r\nperror(optarg);\r\nstop(NULL, EX_OSERR);\r\n}\r\ninclude_dir->quoted_includes_only = 0;\r\nSLIST_INSERT_HEAD(&search_path, include_dir,\r\nlinks);\r\n}\r\nbreak;\r\n}\r\ncase '?':\r\ndefault:\r\nusage();\r\n}\r\n}\r\nargc -= optind;\r\nargv += optind;\r\nif (argc != 1) {\r\nfprintf(stderr, "%s: No input file specifiled\n", appname);\r\nusage();\r\n}\r\nif (regdiagfile != NULL\r\n&& (regfile == NULL || stock_include_file == NULL)) {\r\nfprintf(stderr,\r\n"%s: The -p option requires the -r and -i options.\n",\r\nappname);\r\nusage();\r\n}\r\nsymtable_open();\r\ninputfilename = *argv;\r\ninclude_file(*argv, SOURCE_FILE);\r\nretval = yyparse();\r\nif (retval == 0) {\r\nif (SLIST_FIRST(&scope_stack) == NULL\r\n|| SLIST_FIRST(&scope_stack)->type != SCOPE_ROOT) {\r\nstop("Unterminated conditional expression", EX_DATAERR);\r\n}\r\nprocess_scope(SLIST_FIRST(&scope_stack));\r\ndump_scope(SLIST_FIRST(&scope_stack));\r\nback_patch();\r\nif (ofile != NULL)\r\noutput_code();\r\nif (regfile != NULL)\r\nsymtable_dump(regfile, regdiagfile);\r\nif (listfile != NULL)\r\noutput_listing(inputfilename);\r\n}\r\nstop(NULL, 0);\r\nreturn (0);\r\n}\r\nstatic void\r\nusage()\r\n{\r\n(void)fprintf(stderr,\r\n"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n"\r\n" [-r register_output_file [-p register_diag_file -i includefile]]\n"\r\n" [-l program_list_file]\n"\r\n" input_file\n", appname);\r\nexit(EX_USAGE);\r\n}\r\nstatic void\r\nback_patch()\r\n{\r\nstruct instruction *cur_instr;\r\nfor (cur_instr = STAILQ_FIRST(&seq_program);\r\ncur_instr != NULL;\r\ncur_instr = STAILQ_NEXT(cur_instr, links)) {\r\nif (cur_instr->patch_label != NULL) {\r\nstruct ins_format3 *f3_instr;\r\nu_int address;\r\nif (cur_instr->patch_label->type != LABEL) {\r\nchar buf[255];\r\nsnprintf(buf, sizeof(buf),\r\n"Undefined label %s",\r\ncur_instr->patch_label->name);\r\nstop(buf, EX_DATAERR);\r\n}\r\nf3_instr = &cur_instr->format.format3;\r\naddress = f3_instr->address;\r\naddress += cur_instr->patch_label->info.linfo->address;\r\nf3_instr->address = address;\r\n}\r\n}\r\n}\r\nstatic void\r\noutput_code()\r\n{\r\nstruct instruction *cur_instr;\r\npatch_t *cur_patch;\r\ncritical_section_t *cs;\r\nsymbol_node_t *cur_node;\r\nint instrcount;\r\ninstrcount = 0;\r\nfprintf(ofile,\r\n"/*\n"\r\n" * DO NOT EDIT - This file is automatically generated\n"\r\n" * from the following source files:\n"\r\n" *\n"\r\n"%s */\n", versions);\r\nfprintf(ofile, "static const uint8_t seqprog[] = {\n");\r\nfor (cur_instr = STAILQ_FIRST(&seq_program);\r\ncur_instr != NULL;\r\ncur_instr = STAILQ_NEXT(cur_instr, links)) {\r\nfprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",\r\ncur_instr == STAILQ_FIRST(&seq_program) ? "" : ",\n",\r\n#ifdef __LITTLE_ENDIAN\r\ncur_instr->format.bytes[0],\r\ncur_instr->format.bytes[1],\r\ncur_instr->format.bytes[2],\r\ncur_instr->format.bytes[3]);\r\n#else\r\ncur_instr->format.bytes[3],\r\ncur_instr->format.bytes[2],\r\ncur_instr->format.bytes[1],\r\ncur_instr->format.bytes[0]);\r\n#endif\r\ninstrcount++;\r\n}\r\nvoid\r\ndump_scope(scope_t *scope)\r\n{\r\nscope_t *cur_scope;\r\nemit_patch(scope, 0);\r\ncur_scope = TAILQ_FIRST(&scope->inner_scope);\r\nwhile (cur_scope != NULL) {\r\ndump_scope(cur_scope);\r\ncur_scope = TAILQ_NEXT(cur_scope, scope_links);\r\n}\r\nemit_patch(scope, 1);\r\n}\r\nvoid\r\nemit_patch(scope_t *scope, int patch)\r\n{\r\npatch_info_t *pinfo;\r\npatch_t *new_patch;\r\npinfo = &scope->patches[patch];\r\nif (pinfo->skip_instr == 0)\r\nreturn;\r\nnew_patch = (patch_t *)malloc(sizeof(*new_patch));\r\nif (new_patch == NULL)\r\nstop("Could not malloc patch structure", EX_OSERR);\r\nmemset(new_patch, 0, sizeof(*new_patch));\r\nif (patch == 0) {\r\nnew_patch->patch_func = scope->func_num;\r\nnew_patch->begin = scope->begin_addr;\r\n} else {\r\nnew_patch->patch_func = 0;\r\nnew_patch->begin = scope->end_addr;\r\n}\r\nnew_patch->skip_instr = pinfo->skip_instr;\r\nnew_patch->skip_patch = pinfo->skip_patch;\r\nSTAILQ_INSERT_TAIL(&patches, new_patch, links);\r\n}\r\nvoid\r\noutput_listing(char *ifilename)\r\n{\r\nchar buf[1024];\r\nFILE *ifile;\r\nstruct instruction *cur_instr;\r\npatch_t *cur_patch;\r\nsymbol_node_t *cur_func;\r\nint *func_values;\r\nint instrcount;\r\nint instrptr;\r\nint line;\r\nint func_count;\r\nint skip_addr;\r\ninstrcount = 0;\r\ninstrptr = 0;\r\nline = 1;\r\nskip_addr = 0;\r\nif ((ifile = fopen(ifilename, "r")) == NULL) {\r\nperror(ifilename);\r\nstop(NULL, EX_DATAERR);\r\n}\r\nfor (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);\r\ncur_func != NULL;\r\ncur_func = SLIST_NEXT(cur_func, links))\r\nfunc_count++;\r\nfunc_values = NULL;\r\nif (func_count != 0) {\r\nfunc_values = (int *)malloc(func_count * sizeof(int));\r\nif (func_values == NULL)\r\nstop("Could not malloc", EX_OSERR);\r\nfunc_values[0] = 0;\r\nfunc_count--;\r\nfor (cur_func = SLIST_FIRST(&patch_functions);\r\ncur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;\r\ncur_func = SLIST_NEXT(cur_func, links), func_count--) {\r\nint input;\r\nfprintf(stdout, "\n(%s)\n", cur_func->symbol->name);\r\nfprintf(stdout,\r\n"Enter the return value for "\r\n"this expression[T/F]:");\r\nwhile (1) {\r\ninput = getchar();\r\ninput = toupper(input);\r\nif (input == 'T') {\r\nfunc_values[func_count] = 1;\r\nbreak;\r\n} else if (input == 'F') {\r\nfunc_values[func_count] = 0;\r\nbreak;\r\n}\r\n}\r\nif (isatty(fileno(stdin)) == 0)\r\nputchar(input);\r\n}\r\nfprintf(stdout, "\nThanks!\n");\r\n}\r\ncur_patch = STAILQ_FIRST(&patches);\r\nfor (cur_instr = STAILQ_FIRST(&seq_program);\r\ncur_instr != NULL;\r\ncur_instr = STAILQ_NEXT(cur_instr, links), instrcount++) {\r\nif (check_patch(&cur_patch, instrcount,\r\n&skip_addr, func_values) == 0) {\r\ncontinue;\r\n}\r\nwhile (line < cur_instr->srcline) {\r\nfgets(buf, sizeof(buf), ifile);\r\nfprintf(listfile, " \t%s", buf);\r\nline++;\r\n}\r\nfprintf(listfile, "%04x %02x%02x%02x%02x", instrptr,\r\n#ifdef __LITTLE_ENDIAN\r\ncur_instr->format.bytes[0],\r\ncur_instr->format.bytes[1],\r\ncur_instr->format.bytes[2],\r\ncur_instr->format.bytes[3]);\r\n#else\r\ncur_instr->format.bytes[3],\r\ncur_instr->format.bytes[2],\r\ncur_instr->format.bytes[1],\r\ncur_instr->format.bytes[0]);\r\n#endif\r\nif (line == cur_instr->srcline) {\r\nfgets(buf, sizeof(buf), ifile);\r\nfprintf(listfile, "\t%s", buf);\r\nline++;\r\n} else {\r\nfprintf(listfile, "\n");\r\n}\r\ninstrptr++;\r\n}\r\nint\r\ncheck_patch(patch_t **start_patch, int start_instr,\r\nint *skip_addr, int *func_vals)\r\n{\r\npatch_t *cur_patch;\r\ncur_patch = *start_patch;\r\nwhile (cur_patch != NULL && start_instr == cur_patch->begin) {\r\nif (func_vals[cur_patch->patch_func] == 0) {\r\nint skip;\r\n*skip_addr = start_instr + cur_patch->skip_instr;\r\nfor (skip = cur_patch->skip_patch;\r\nskip > 0 && cur_patch != NULL;\r\nskip--)\r\ncur_patch = STAILQ_NEXT(cur_patch, links);\r\n} else {\r\ncur_patch = STAILQ_NEXT(cur_patch, links);\r\n}\r\n}\r\n*start_patch = cur_patch;\r\nif (start_instr < *skip_addr)\r\nreturn (0);\r\nreturn (1);\r\n}\r\nvoid\r\nstop(const char *string, int err_code)\r\n{\r\nif (string != NULL) {\r\nfprintf(stderr, "%s: ", appname);\r\nif (yyfilename != NULL) {\r\nfprintf(stderr, "Stopped at file %s, line %d - ",\r\nyyfilename, yylineno);\r\n}\r\nfprintf(stderr, "%s\n", string);\r\n}\r\nif (ofile != NULL) {\r\nfclose(ofile);\r\nif (err_code != 0) {\r\nfprintf(stderr, "%s: Removing %s due to error\n",\r\nappname, ofilename);\r\nunlink(ofilename);\r\n}\r\n}\r\nif (regfile != NULL) {\r\nfclose(regfile);\r\nif (err_code != 0) {\r\nfprintf(stderr, "%s: Removing %s due to error\n",\r\nappname, regfilename);\r\nunlink(regfilename);\r\n}\r\n}\r\nif (listfile != NULL) {\r\nfclose(listfile);\r\nif (err_code != 0) {\r\nfprintf(stderr, "%s: Removing %s due to error\n",\r\nappname, listfilename);\r\nunlink(listfilename);\r\n}\r\n}\r\nsymlist_free(&patch_functions);\r\nsymtable_close();\r\nexit(err_code);\r\n}\r\nstruct instruction *\r\nseq_alloc()\r\n{\r\nstruct instruction *new_instr;\r\nnew_instr = (struct instruction *)malloc(sizeof(struct instruction));\r\nif (new_instr == NULL)\r\nstop("Unable to malloc instruction object", EX_SOFTWARE);\r\nmemset(new_instr, 0, sizeof(*new_instr));\r\nSTAILQ_INSERT_TAIL(&seq_program, new_instr, links);\r\nnew_instr->srcline = yylineno;\r\nreturn new_instr;\r\n}\r\ncritical_section_t *\r\ncs_alloc()\r\n{\r\ncritical_section_t *new_cs;\r\nnew_cs= (critical_section_t *)malloc(sizeof(critical_section_t));\r\nif (new_cs == NULL)\r\nstop("Unable to malloc critical_section object", EX_SOFTWARE);\r\nmemset(new_cs, 0, sizeof(*new_cs));\r\nTAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);\r\nreturn new_cs;\r\n}\r\nscope_t *\r\nscope_alloc()\r\n{\r\nscope_t *new_scope;\r\nnew_scope = (scope_t *)malloc(sizeof(scope_t));\r\nif (new_scope == NULL)\r\nstop("Unable to malloc scope object", EX_SOFTWARE);\r\nmemset(new_scope, 0, sizeof(*new_scope));\r\nTAILQ_INIT(&new_scope->inner_scope);\r\nif (SLIST_FIRST(&scope_stack) != NULL) {\r\nTAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,\r\nnew_scope, scope_links);\r\n}\r\nSLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);\r\nreturn new_scope;\r\n}\r\nvoid\r\nprocess_scope(scope_t *scope)\r\n{\r\nscope_t *cur_scope;\r\nu_int skip_patch_count;\r\nu_int skip_instr_count;\r\ncur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);\r\nskip_patch_count = 0;\r\nskip_instr_count = 0;\r\nwhile (cur_scope != NULL) {\r\nu_int patch0_patch_skip;\r\npatch0_patch_skip = 0;\r\nswitch (cur_scope->type) {\r\ncase SCOPE_IF:\r\ncase SCOPE_ELSE_IF:\r\nif (skip_instr_count != 0) {\r\npatch0_patch_skip++;\r\ncur_scope->patches[1].skip_patch =\r\nskip_patch_count + 1;\r\ncur_scope->patches[1].skip_instr =\r\nskip_instr_count;\r\n}\r\npatch0_patch_skip++;\r\npatch0_patch_skip += cur_scope->inner_scope_patches;\r\ncur_scope->patches[0].skip_patch = patch0_patch_skip;\r\ncur_scope->patches[0].skip_instr =\r\ncur_scope->end_addr - cur_scope->begin_addr;\r\nskip_instr_count += cur_scope->patches[0].skip_instr;\r\nskip_patch_count += patch0_patch_skip;\r\nif (cur_scope->type == SCOPE_IF) {\r\nscope->inner_scope_patches += skip_patch_count;\r\nskip_patch_count = 0;\r\nskip_instr_count = 0;\r\n}\r\nbreak;\r\ncase SCOPE_ELSE:\r\nskip_patch_count += cur_scope->inner_scope_patches;\r\nskip_instr_count += cur_scope->end_addr\r\n- cur_scope->begin_addr;\r\nbreak;\r\ncase SCOPE_ROOT:\r\nstop("Unexpected scope type encountered", EX_SOFTWARE);\r\n}\r\ncur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);\r\n}\r\n}
