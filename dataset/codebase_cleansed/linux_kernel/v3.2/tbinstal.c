acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(tb_verify_table);\r\nif (!table_desc->pointer) {\r\nif ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==\r\nACPI_TABLE_ORIGIN_MAPPED) {\r\ntable_desc->pointer =\r\nacpi_os_map_memory(table_desc->address,\r\ntable_desc->length);\r\n}\r\nif (!table_desc->pointer) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\n}\r\nif (!ACPI_COMPARE_NAME(&table_desc->signature, ACPI_SIG_FACS)) {\r\nstatus =\r\nacpi_tb_verify_checksum(table_desc->pointer,\r\ntable_desc->length);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)\r\n{\r\nu32 i;\r\nacpi_status status = AE_OK;\r\nstruct acpi_table_header *override_table = NULL;\r\nACPI_FUNCTION_TRACE(tb_add_table);\r\nif (!table_desc->pointer) {\r\nstatus = acpi_tb_verify_table(table_desc);\r\nif (ACPI_FAILURE(status) || !table_desc->pointer) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif ((table_desc->pointer->signature[0] != 0x00) &&\r\n(!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))\r\n&& (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {\r\nACPI_ERROR((AE_INFO,\r\n"Table has invalid signature [%4.4s] (0x%8.8X), must be SSDT or OEMx",\r\nacpi_ut_valid_acpi_name(*(u32 *)table_desc->\r\npointer->\r\nsignature) ? table_desc->\r\npointer->signature : "????",\r\n*(u32 *)table_desc->pointer->signature));\r\nreturn_ACPI_STATUS(AE_BAD_SIGNATURE);\r\n}\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\r\nif (!acpi_gbl_root_table_list.tables[i].pointer) {\r\nstatus =\r\nacpi_tb_verify_table(&acpi_gbl_root_table_list.\r\ntables[i]);\r\nif (ACPI_FAILURE(status)\r\n|| !acpi_gbl_root_table_list.tables[i].pointer) {\r\ncontinue;\r\n}\r\n}\r\nif (table_desc->length !=\r\nacpi_gbl_root_table_list.tables[i].length) {\r\ncontinue;\r\n}\r\nif (ACPI_MEMCMP(table_desc->pointer,\r\nacpi_gbl_root_table_list.tables[i].pointer,\r\nacpi_gbl_root_table_list.tables[i].length)) {\r\ncontinue;\r\n}\r\nacpi_tb_delete_table(table_desc);\r\n*table_index = i;\r\nif (acpi_gbl_root_table_list.tables[i].\r\nflags & ACPI_TABLE_IS_LOADED) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto release;\r\n} else {\r\ntable_desc->pointer =\r\nacpi_gbl_root_table_list.tables[i].pointer;\r\ntable_desc->address =\r\nacpi_gbl_root_table_list.tables[i].address;\r\nstatus = AE_OK;\r\ngoto print_header;\r\n}\r\n}\r\nstatus = acpi_os_table_override(table_desc->pointer, &override_table);\r\nif (ACPI_SUCCESS(status) && override_table) {\r\nACPI_INFO((AE_INFO,\r\n"%4.4s @ 0x%p Table override, replaced with:",\r\ntable_desc->pointer->signature,\r\nACPI_CAST_PTR(void, table_desc->address)));\r\nacpi_tb_delete_table(table_desc);\r\ntable_desc->address = ACPI_PTR_TO_PHYSADDR(override_table);\r\ntable_desc->pointer = override_table;\r\ntable_desc->length = override_table->length;\r\ntable_desc->flags = ACPI_TABLE_ORIGIN_OVERRIDE;\r\n}\r\nstatus = acpi_tb_store_table(table_desc->address, table_desc->pointer,\r\ntable_desc->length, table_desc->flags,\r\ntable_index);\r\nif (ACPI_FAILURE(status)) {\r\ngoto release;\r\n}\r\nprint_header:\r\nacpi_tb_print_table_header(table_desc->address, table_desc->pointer);\r\nrelease:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_resize_root_table_list(void)\r\n{\r\nstruct acpi_table_desc *tables;\r\nACPI_FUNCTION_TRACE(tb_resize_root_table_list);\r\nif (!(acpi_gbl_root_table_list.flags & ACPI_ROOT_ALLOW_RESIZE)) {\r\nACPI_ERROR((AE_INFO,\r\n"Resize of Root Table Array is not allowed"));\r\nreturn_ACPI_STATUS(AE_SUPPORT);\r\n}\r\ntables = ACPI_ALLOCATE_ZEROED(((acpi_size) acpi_gbl_root_table_list.\r\nmax_table_count +\r\nACPI_ROOT_TABLE_SIZE_INCREMENT) *\r\nsizeof(struct acpi_table_desc));\r\nif (!tables) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not allocate new root table array"));\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nif (acpi_gbl_root_table_list.tables) {\r\nACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,\r\n(acpi_size) acpi_gbl_root_table_list.\r\nmax_table_count * sizeof(struct acpi_table_desc));\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nACPI_FREE(acpi_gbl_root_table_list.tables);\r\n}\r\n}\r\nacpi_gbl_root_table_list.tables = tables;\r\nacpi_gbl_root_table_list.max_table_count +=\r\nACPI_ROOT_TABLE_SIZE_INCREMENT;\r\nacpi_gbl_root_table_list.flags |= (u8)ACPI_ROOT_ORIGIN_ALLOCATED;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_tb_store_table(acpi_physical_address address,\r\nstruct acpi_table_header *table,\r\nu32 length, u8 flags, u32 *table_index)\r\n{\r\nacpi_status status;\r\nstruct acpi_table_desc *new_table;\r\nif (acpi_gbl_root_table_list.current_table_count >=\r\nacpi_gbl_root_table_list.max_table_count) {\r\nstatus = acpi_tb_resize_root_table_list();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nnew_table =\r\n&acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.\r\ncurrent_table_count];\r\nnew_table->address = address;\r\nnew_table->pointer = table;\r\nnew_table->length = length;\r\nnew_table->owner_id = 0;\r\nnew_table->flags = flags;\r\nACPI_MOVE_32_TO_32(&new_table->signature, table->signature);\r\n*table_index = acpi_gbl_root_table_list.current_table_count;\r\nacpi_gbl_root_table_list.current_table_count++;\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_tb_delete_table(struct acpi_table_desc *table_desc)\r\n{\r\nif (!table_desc->pointer) {\r\nreturn;\r\n}\r\nswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\r\ncase ACPI_TABLE_ORIGIN_MAPPED:\r\nacpi_os_unmap_memory(table_desc->pointer, table_desc->length);\r\nbreak;\r\ncase ACPI_TABLE_ORIGIN_ALLOCATED:\r\nACPI_FREE(table_desc->pointer);\r\nbreak;\r\ndefault:;\r\n}\r\ntable_desc->pointer = NULL;\r\n}\r\nvoid acpi_tb_terminate(void)\r\n{\r\nu32 i;\r\nACPI_FUNCTION_TRACE(tb_terminate);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\nacpi_tb_delete_table(&acpi_gbl_root_table_list.tables[i]);\r\n}\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nACPI_FREE(acpi_gbl_root_table_list.tables);\r\n}\r\nacpi_gbl_root_table_list.tables = NULL;\r\nacpi_gbl_root_table_list.flags = 0;\r\nacpi_gbl_root_table_list.current_table_count = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n}\r\nacpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)\r\n{\r\nacpi_owner_id owner_id;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(tb_delete_namespace_by_owner);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (table_index >= acpi_gbl_root_table_list.current_table_count) {\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nowner_id = acpi_gbl_root_table_list.tables[table_index].owner_id;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\r\nstatus = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);\r\nacpi_ns_delete_namespace_by_owner(owner_id);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ut_release_write_lock(&acpi_gbl_namespace_rw_lock);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_allocate_owner_id(u32 table_index)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_allocate_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nstatus = acpi_ut_allocate_owner_id\r\n(&(acpi_gbl_root_table_list.tables[table_index].owner_id));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_release_owner_id(u32 table_index)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_release_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nacpi_ut_release_owner_id(&\r\n(acpi_gbl_root_table_list.\r\ntables[table_index].owner_id));\r\nstatus = AE_OK;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id *owner_id)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_get_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\n*owner_id =\r\nacpi_gbl_root_table_list.tables[table_index].owner_id;\r\nstatus = AE_OK;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nu8 acpi_tb_is_table_loaded(u32 table_index)\r\n{\r\nu8 is_loaded = FALSE;\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nis_loaded = (u8)\r\n(acpi_gbl_root_table_list.tables[table_index].flags &\r\nACPI_TABLE_IS_LOADED);\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn (is_loaded);\r\n}\r\nvoid acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)\r\n{\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nif (is_loaded) {\r\nacpi_gbl_root_table_list.tables[table_index].flags |=\r\nACPI_TABLE_IS_LOADED;\r\n} else {\r\nacpi_gbl_root_table_list.tables[table_index].flags &=\r\n~ACPI_TABLE_IS_LOADED;\r\n}\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n}
