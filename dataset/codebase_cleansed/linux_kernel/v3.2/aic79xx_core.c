void\r\nahd_set_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)\r\n{\r\nif (ahd->src_mode == src && ahd->dst_mode == dst)\r\nreturn;\r\n#ifdef AHD_DEBUG\r\nif (ahd->src_mode == AHD_MODE_UNKNOWN\r\n|| ahd->dst_mode == AHD_MODE_UNKNOWN)\r\npanic("Setting mode prior to saving it.\n");\r\nif ((ahd_debug & AHD_SHOW_MODEPTR) != 0)\r\nprintk("%s: Setting mode 0x%x\n", ahd_name(ahd),\r\nahd_build_mode_state(ahd, src, dst));\r\n#endif\r\nahd_outb(ahd, MODE_PTR, ahd_build_mode_state(ahd, src, dst));\r\nahd->src_mode = src;\r\nahd->dst_mode = dst;\r\n}\r\nstatic void\r\nahd_update_modes(struct ahd_softc *ahd)\r\n{\r\nahd_mode_state mode_ptr;\r\nahd_mode src;\r\nahd_mode dst;\r\nmode_ptr = ahd_inb(ahd, MODE_PTR);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MODEPTR) != 0)\r\nprintk("Reading mode 0x%x\n", mode_ptr);\r\n#endif\r\nahd_extract_mode_state(ahd, mode_ptr, &src, &dst);\r\nahd_known_modes(ahd, src, dst);\r\n}\r\nstatic void\r\nahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,\r\nahd_mode dstmode, const char *file, int line)\r\n{\r\n#ifdef AHD_DEBUG\r\nif ((srcmode & AHD_MK_MSK(ahd->src_mode)) == 0\r\n|| (dstmode & AHD_MK_MSK(ahd->dst_mode)) == 0) {\r\npanic("%s:%s:%d: Mode assertion failed.\n",\r\nahd_name(ahd), file, line);\r\n}\r\n#endif\r\n}\r\nahd_mode_state\r\nahd_save_modes(struct ahd_softc *ahd)\r\n{\r\nif (ahd->src_mode == AHD_MODE_UNKNOWN\r\n|| ahd->dst_mode == AHD_MODE_UNKNOWN)\r\nahd_update_modes(ahd);\r\nreturn (ahd_build_mode_state(ahd, ahd->src_mode, ahd->dst_mode));\r\n}\r\nvoid\r\nahd_restore_modes(struct ahd_softc *ahd, ahd_mode_state state)\r\n{\r\nahd_mode src;\r\nahd_mode dst;\r\nahd_extract_mode_state(ahd, state, &src, &dst);\r\nahd_set_modes(ahd, src, dst);\r\n}\r\nint\r\nahd_is_paused(struct ahd_softc *ahd)\r\n{\r\nreturn ((ahd_inb(ahd, HCNTRL) & PAUSE) != 0);\r\n}\r\nvoid\r\nahd_pause(struct ahd_softc *ahd)\r\n{\r\nahd_outb(ahd, HCNTRL, ahd->pause);\r\nwhile (ahd_is_paused(ahd) == 0)\r\n;\r\n}\r\nvoid\r\nahd_unpause(struct ahd_softc *ahd)\r\n{\r\nif (ahd->saved_src_mode != AHD_MODE_UNKNOWN\r\n&& ahd->saved_dst_mode != AHD_MODE_UNKNOWN) {\r\nif ((ahd->flags & AHD_UPDATE_PEND_CMDS) != 0)\r\nahd_reset_cmds_pending(ahd);\r\nahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);\r\n}\r\nif ((ahd_inb(ahd, INTSTAT) & ~CMDCMPLT) == 0)\r\nahd_outb(ahd, HCNTRL, ahd->unpause);\r\nahd_known_modes(ahd, AHD_MODE_UNKNOWN, AHD_MODE_UNKNOWN);\r\n}\r\nvoid *\r\nahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,\r\nvoid *sgptr, dma_addr_t addr, bus_size_t len, int last)\r\n{\r\nscb->sg_count++;\r\nif (sizeof(dma_addr_t) > 4\r\n&& (ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\r\nstruct ahd_dma64_seg *sg;\r\nsg = (struct ahd_dma64_seg *)sgptr;\r\nsg->addr = ahd_htole64(addr);\r\nsg->len = ahd_htole32(len | (last ? AHD_DMA_LAST_SEG : 0));\r\nreturn (sg + 1);\r\n} else {\r\nstruct ahd_dma_seg *sg;\r\nsg = (struct ahd_dma_seg *)sgptr;\r\nsg->addr = ahd_htole32(addr & 0xFFFFFFFF);\r\nsg->len = ahd_htole32(len | ((addr >> 8) & 0x7F000000)\r\n| (last ? AHD_DMA_LAST_SEG : 0));\r\nreturn (sg + 1);\r\n}\r\n}\r\nstatic void\r\nahd_setup_scb_common(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nscb->crc_retry_count = 0;\r\nif ((scb->flags & SCB_PACKETIZED) != 0) {\r\nscb->hscb->task_attribute = scb->hscb->control & SCB_TAG_TYPE;\r\n} else {\r\nif (ahd_get_transfer_length(scb) & 0x01)\r\nscb->hscb->task_attribute = SCB_XFERLEN_ODD;\r\nelse\r\nscb->hscb->task_attribute = 0;\r\n}\r\nif (scb->hscb->cdb_len <= MAX_CDB_LEN_WITH_SENSE_ADDR\r\n|| (scb->hscb->cdb_len & SCB_CDB_LEN_PTR) != 0)\r\nscb->hscb->shared_data.idata.cdb_plus_saddr.sense_addr =\r\nahd_htole32(scb->sense_busaddr);\r\n}\r\nstatic void\r\nahd_setup_data_scb(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\r\nstruct ahd_dma64_seg *sg;\r\nsg = (struct ahd_dma64_seg *)scb->sg_list;\r\nscb->hscb->dataptr = sg->addr;\r\nscb->hscb->datacnt = sg->len;\r\n} else {\r\nstruct ahd_dma_seg *sg;\r\nuint32_t *dataptr_words;\r\nsg = (struct ahd_dma_seg *)scb->sg_list;\r\ndataptr_words = (uint32_t*)&scb->hscb->dataptr;\r\ndataptr_words[0] = sg->addr;\r\ndataptr_words[1] = 0;\r\nif ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {\r\nuint64_t high_addr;\r\nhigh_addr = ahd_le32toh(sg->len) & 0x7F000000;\r\nscb->hscb->dataptr |= ahd_htole64(high_addr << 8);\r\n}\r\nscb->hscb->datacnt = sg->len;\r\n}\r\nscb->hscb->sgptr = ahd_htole32(scb->sg_list_busaddr|SG_FULL_RESID);\r\n}\r\nstatic void\r\nahd_setup_noxfer_scb(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nscb->hscb->sgptr = ahd_htole32(SG_LIST_NULL);\r\nscb->hscb->dataptr = 0;\r\nscb->hscb->datacnt = 0;\r\n}\r\nstatic void *\r\nahd_sg_bus_to_virt(struct ahd_softc *ahd, struct scb *scb, uint32_t sg_busaddr)\r\n{\r\ndma_addr_t sg_offset;\r\nsg_offset = sg_busaddr - (scb->sg_list_busaddr - ahd_sg_size(ahd));\r\nreturn ((uint8_t *)scb->sg_list + sg_offset);\r\n}\r\nstatic uint32_t\r\nahd_sg_virt_to_bus(struct ahd_softc *ahd, struct scb *scb, void *sg)\r\n{\r\ndma_addr_t sg_offset;\r\nsg_offset = ((uint8_t *)sg - (uint8_t *)scb->sg_list)\r\n- ahd_sg_size(ahd);\r\nreturn (scb->sg_list_busaddr + sg_offset);\r\n}\r\nstatic void\r\nahd_sync_scb(struct ahd_softc *ahd, struct scb *scb, int op)\r\n{\r\nahd_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,\r\nscb->hscb_map->dmamap,\r\n(uint8_t*)scb->hscb - scb->hscb_map->vaddr,\r\nsizeof(*scb->hscb), op);\r\n}\r\nvoid\r\nahd_sync_sglist(struct ahd_softc *ahd, struct scb *scb, int op)\r\n{\r\nif (scb->sg_count == 0)\r\nreturn;\r\nahd_dmamap_sync(ahd, ahd->scb_data.sg_dmat,\r\nscb->sg_map->dmamap,\r\nscb->sg_list_busaddr - ahd_sg_size(ahd),\r\nahd_sg_size(ahd) * scb->sg_count, op);\r\n}\r\nstatic void\r\nahd_sync_sense(struct ahd_softc *ahd, struct scb *scb, int op)\r\n{\r\nahd_dmamap_sync(ahd, ahd->scb_data.sense_dmat,\r\nscb->sense_map->dmamap,\r\nscb->sense_busaddr,\r\nAHD_SENSE_BUFSIZE, op);\r\n}\r\nstatic uint32_t\r\nahd_targetcmd_offset(struct ahd_softc *ahd, u_int index)\r\n{\r\nreturn (((uint8_t *)&ahd->targetcmds[index])\r\n- (uint8_t *)ahd->qoutfifo);\r\n}\r\nstruct ahd_initiator_tinfo *\r\nahd_fetch_transinfo(struct ahd_softc *ahd, char channel, u_int our_id,\r\nu_int remote_id, struct ahd_tmode_tstate **tstate)\r\n{\r\nif (channel == 'B')\r\nour_id += 8;\r\n*tstate = ahd->enabled_targets[our_id];\r\nreturn (&(*tstate)->transinfo[remote_id]);\r\n}\r\nuint16_t\r\nahd_inw(struct ahd_softc *ahd, u_int port)\r\n{\r\nuint16_t r = ahd_inb(ahd, port+1) << 8;\r\nreturn r | ahd_inb(ahd, port);\r\n}\r\nvoid\r\nahd_outw(struct ahd_softc *ahd, u_int port, u_int value)\r\n{\r\nahd_outb(ahd, port, value & 0xFF);\r\nahd_outb(ahd, port+1, (value >> 8) & 0xFF);\r\n}\r\nuint32_t\r\nahd_inl(struct ahd_softc *ahd, u_int port)\r\n{\r\nreturn ((ahd_inb(ahd, port))\r\n| (ahd_inb(ahd, port+1) << 8)\r\n| (ahd_inb(ahd, port+2) << 16)\r\n| (ahd_inb(ahd, port+3) << 24));\r\n}\r\nvoid\r\nahd_outl(struct ahd_softc *ahd, u_int port, uint32_t value)\r\n{\r\nahd_outb(ahd, port, (value) & 0xFF);\r\nahd_outb(ahd, port+1, ((value) >> 8) & 0xFF);\r\nahd_outb(ahd, port+2, ((value) >> 16) & 0xFF);\r\nahd_outb(ahd, port+3, ((value) >> 24) & 0xFF);\r\n}\r\nuint64_t\r\nahd_inq(struct ahd_softc *ahd, u_int port)\r\n{\r\nreturn ((ahd_inb(ahd, port))\r\n| (ahd_inb(ahd, port+1) << 8)\r\n| (ahd_inb(ahd, port+2) << 16)\r\n| (ahd_inb(ahd, port+3) << 24)\r\n| (((uint64_t)ahd_inb(ahd, port+4)) << 32)\r\n| (((uint64_t)ahd_inb(ahd, port+5)) << 40)\r\n| (((uint64_t)ahd_inb(ahd, port+6)) << 48)\r\n| (((uint64_t)ahd_inb(ahd, port+7)) << 56));\r\n}\r\nvoid\r\nahd_outq(struct ahd_softc *ahd, u_int port, uint64_t value)\r\n{\r\nahd_outb(ahd, port, value & 0xFF);\r\nahd_outb(ahd, port+1, (value >> 8) & 0xFF);\r\nahd_outb(ahd, port+2, (value >> 16) & 0xFF);\r\nahd_outb(ahd, port+3, (value >> 24) & 0xFF);\r\nahd_outb(ahd, port+4, (value >> 32) & 0xFF);\r\nahd_outb(ahd, port+5, (value >> 40) & 0xFF);\r\nahd_outb(ahd, port+6, (value >> 48) & 0xFF);\r\nahd_outb(ahd, port+7, (value >> 56) & 0xFF);\r\n}\r\nu_int\r\nahd_get_scbptr(struct ahd_softc *ahd)\r\n{\r\nAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\r\n~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\r\nreturn (ahd_inb(ahd, SCBPTR) | (ahd_inb(ahd, SCBPTR + 1) << 8));\r\n}\r\nvoid\r\nahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr)\r\n{\r\nAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\r\n~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\r\nahd_outb(ahd, SCBPTR, scbptr & 0xFF);\r\nahd_outb(ahd, SCBPTR+1, (scbptr >> 8) & 0xFF);\r\n}\r\nstatic void\r\nahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value)\r\n{\r\nahd_outw_atomic(ahd, HNSCB_QOFF, value);\r\n}\r\nstatic void\r\nahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value)\r\n{\r\nahd_outb(ahd, HESCB_QOFF, value);\r\n}\r\nstatic u_int\r\nahd_get_snscb_qoff(struct ahd_softc *ahd)\r\n{\r\nu_int oldvalue;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\r\noldvalue = ahd_inw(ahd, SNSCB_QOFF);\r\nahd_outw(ahd, SNSCB_QOFF, oldvalue);\r\nreturn (oldvalue);\r\n}\r\nstatic void\r\nahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value)\r\n{\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\r\nahd_outw(ahd, SNSCB_QOFF, value);\r\n}\r\nstatic void\r\nahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value)\r\n{\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\r\nahd_outb(ahd, SESCB_QOFF, value);\r\n}\r\nstatic void\r\nahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value)\r\n{\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\r\nahd_outb(ahd, SDSCB_QOFF, value & 0xFF);\r\nahd_outb(ahd, SDSCB_QOFF+1, (value >> 8) & 0xFF);\r\n}\r\nu_int\r\nahd_inb_scbram(struct ahd_softc *ahd, u_int offset)\r\n{\r\nu_int value;\r\nvalue = ahd_inb(ahd, offset);\r\nif ((ahd->bugs & AHD_PCIX_SCBRAM_RD_BUG) != 0)\r\nahd_inb(ahd, MODE_PTR);\r\nreturn (value);\r\n}\r\nu_int\r\nahd_inw_scbram(struct ahd_softc *ahd, u_int offset)\r\n{\r\nreturn (ahd_inb_scbram(ahd, offset)\r\n| (ahd_inb_scbram(ahd, offset+1) << 8));\r\n}\r\nstatic uint32_t\r\nahd_inl_scbram(struct ahd_softc *ahd, u_int offset)\r\n{\r\nreturn (ahd_inw_scbram(ahd, offset)\r\n| (ahd_inw_scbram(ahd, offset+2) << 16));\r\n}\r\nstatic uint64_t\r\nahd_inq_scbram(struct ahd_softc *ahd, u_int offset)\r\n{\r\nreturn (ahd_inl_scbram(ahd, offset)\r\n| ((uint64_t)ahd_inl_scbram(ahd, offset+4)) << 32);\r\n}\r\nstruct scb *\r\nahd_lookup_scb(struct ahd_softc *ahd, u_int tag)\r\n{\r\nstruct scb* scb;\r\nif (tag >= AHD_SCB_MAX)\r\nreturn (NULL);\r\nscb = ahd->scb_data.scbindex[tag];\r\nif (scb != NULL)\r\nahd_sync_scb(ahd, scb,\r\nBUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);\r\nreturn (scb);\r\n}\r\nstatic void\r\nahd_swap_with_next_hscb(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nstruct hardware_scb *q_hscb;\r\nstruct map_node *q_hscb_map;\r\nuint32_t saved_hscb_busaddr;\r\nq_hscb = ahd->next_queued_hscb;\r\nq_hscb_map = ahd->next_queued_hscb_map;\r\nsaved_hscb_busaddr = q_hscb->hscb_busaddr;\r\nmemcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));\r\nq_hscb->hscb_busaddr = saved_hscb_busaddr;\r\nq_hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;\r\nahd->next_queued_hscb = scb->hscb;\r\nahd->next_queued_hscb_map = scb->hscb_map;\r\nscb->hscb = q_hscb;\r\nscb->hscb_map = q_hscb_map;\r\nahd->scb_data.scbindex[SCB_GET_TAG(scb)] = scb;\r\n}\r\nvoid\r\nahd_queue_scb(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nahd_swap_with_next_hscb(ahd, scb);\r\nif (SCBID_IS_NULL(SCB_GET_TAG(scb)))\r\npanic("Attempt to queue invalid SCB tag %x\n",\r\nSCB_GET_TAG(scb));\r\nahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);\r\nahd->qinfifonext++;\r\nif (scb->sg_count != 0)\r\nahd_setup_data_scb(ahd, scb);\r\nelse\r\nahd_setup_noxfer_scb(ahd, scb);\r\nahd_setup_scb_common(ahd, scb);\r\nahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_QUEUE) != 0) {\r\nuint64_t host_dataptr;\r\nhost_dataptr = ahd_le64toh(scb->hscb->dataptr);\r\nprintk("%s: Queueing SCB %d:0x%x bus addr 0x%x - 0x%x%x/0x%x\n",\r\nahd_name(ahd),\r\nSCB_GET_TAG(scb), scb->hscb->scsiid,\r\nahd_le32toh(scb->hscb->hscb_busaddr),\r\n(u_int)((host_dataptr >> 32) & 0xFFFFFFFF),\r\n(u_int)(host_dataptr & 0xFFFFFFFF),\r\nahd_le32toh(scb->hscb->datacnt));\r\n}\r\n#endif\r\nahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\r\n}\r\nstatic void\r\nahd_sync_qoutfifo(struct ahd_softc *ahd, int op)\r\n{\r\nahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,\r\n0,\r\nAHD_SCB_MAX * sizeof(struct ahd_completion), op);\r\n}\r\nstatic void\r\nahd_sync_tqinfifo(struct ahd_softc *ahd, int op)\r\n{\r\n#ifdef AHD_TARGET_MODE\r\nif ((ahd->flags & AHD_TARGETROLE) != 0) {\r\nahd_dmamap_sync(ahd, ahd->shared_data_dmat,\r\nahd->shared_data_map.dmamap,\r\nahd_targetcmd_offset(ahd, 0),\r\nsizeof(struct target_cmd) * AHD_TMODE_CMDS,\r\nop);\r\n}\r\n#endif\r\n}\r\nstatic u_int\r\nahd_check_cmdcmpltqueues(struct ahd_softc *ahd)\r\n{\r\nu_int retval;\r\nretval = 0;\r\nahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,\r\nahd->qoutfifonext * sizeof(*ahd->qoutfifo),\r\nsizeof(*ahd->qoutfifo), BUS_DMASYNC_POSTREAD);\r\nif (ahd->qoutfifo[ahd->qoutfifonext].valid_tag\r\n== ahd->qoutfifonext_valid_tag)\r\nretval |= AHD_RUN_QOUTFIFO;\r\n#ifdef AHD_TARGET_MODE\r\nif ((ahd->flags & AHD_TARGETROLE) != 0\r\n&& (ahd->flags & AHD_TQINFIFO_BLOCKED) == 0) {\r\nahd_dmamap_sync(ahd, ahd->shared_data_dmat,\r\nahd->shared_data_map.dmamap,\r\nahd_targetcmd_offset(ahd, ahd->tqinfifofnext),\r\nsizeof(struct target_cmd),\r\nBUS_DMASYNC_POSTREAD);\r\nif (ahd->targetcmds[ahd->tqinfifonext].cmd_valid != 0)\r\nretval |= AHD_RUN_TQINFIFO;\r\n}\r\n#endif\r\nreturn (retval);\r\n}\r\nint\r\nahd_intr(struct ahd_softc *ahd)\r\n{\r\nu_int intstat;\r\nif ((ahd->pause & INTEN) == 0) {\r\nreturn (0);\r\n}\r\nif ((ahd->flags & AHD_ALL_INTERRUPTS) == 0\r\n&& (ahd_check_cmdcmpltqueues(ahd) != 0))\r\nintstat = CMDCMPLT;\r\nelse\r\nintstat = ahd_inb(ahd, INTSTAT);\r\nif ((intstat & INT_PEND) == 0)\r\nreturn (0);\r\nif (intstat & CMDCMPLT) {\r\nahd_outb(ahd, CLRINT, CLRCMDINT);\r\nif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\r\nif (ahd_is_paused(ahd)) {\r\nif (ahd_inb(ahd, SEQINTCODE) != NO_SEQINT)\r\nintstat |= SEQINT;\r\n}\r\n} else {\r\nahd_flush_device_writes(ahd);\r\n}\r\nahd_run_qoutfifo(ahd);\r\nahd->cmdcmplt_counts[ahd->cmdcmplt_bucket]++;\r\nahd->cmdcmplt_total++;\r\n#ifdef AHD_TARGET_MODE\r\nif ((ahd->flags & AHD_TARGETROLE) != 0)\r\nahd_run_tqinfifo(ahd, FALSE);\r\n#endif\r\n}\r\nif (intstat == 0xFF && (ahd->features & AHD_REMOVABLE) != 0) {\r\n} else if (intstat & HWERRINT) {\r\nahd_handle_hwerrint(ahd);\r\n} else if ((intstat & (PCIINT|SPLTINT)) != 0) {\r\nahd->bus_intr(ahd);\r\n} else {\r\nif ((intstat & SEQINT) != 0)\r\nahd_handle_seqint(ahd, intstat);\r\nif ((intstat & SCSIINT) != 0)\r\nahd_handle_scsiint(ahd, intstat);\r\n}\r\nreturn (1);\r\n}\r\nstatic inline void\r\nahd_assert_atn(struct ahd_softc *ahd)\r\n{\r\nahd_outb(ahd, SCSISIGO, ATNO);\r\n}\r\nstatic int\r\nahd_currently_packetized(struct ahd_softc *ahd)\r\n{\r\nahd_mode_state saved_modes;\r\nint packetized;\r\nsaved_modes = ahd_save_modes(ahd);\r\nif ((ahd->bugs & AHD_PKTIZED_STATUS_BUG) != 0) {\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\npacketized = ahd_inb(ahd, LQISTATE) != 0;\r\n} else {\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\npacketized = ahd_inb(ahd, LQISTAT2) & PACKETIZED;\r\n}\r\nahd_restore_modes(ahd, saved_modes);\r\nreturn (packetized);\r\n}\r\nstatic inline int\r\nahd_set_active_fifo(struct ahd_softc *ahd)\r\n{\r\nu_int active_fifo;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nactive_fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;\r\nswitch (active_fifo) {\r\ncase 0:\r\ncase 1:\r\nahd_set_modes(ahd, active_fifo, active_fifo);\r\nreturn (1);\r\ndefault:\r\nreturn (0);\r\n}\r\n}\r\nstatic inline void\r\nahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl)\r\n{\r\nahd_busy_tcl(ahd, tcl, SCB_LIST_NULL);\r\n}\r\nstatic inline void\r\nahd_update_residual(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nuint32_t sgptr;\r\nsgptr = ahd_le32toh(scb->hscb->sgptr);\r\nif ((sgptr & SG_STATUS_VALID) != 0)\r\nahd_calc_residual(ahd, scb);\r\n}\r\nstatic inline void\r\nahd_complete_scb(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nuint32_t sgptr;\r\nsgptr = ahd_le32toh(scb->hscb->sgptr);\r\nif ((sgptr & SG_STATUS_VALID) != 0)\r\nahd_handle_scb_status(ahd, scb);\r\nelse\r\nahd_done(ahd, scb);\r\n}\r\nstatic void\r\nahd_restart(struct ahd_softc *ahd)\r\n{\r\nahd_pause(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_clear_msg_state(ahd);\r\nahd_outb(ahd, SCSISIGO, 0);\r\nahd_outb(ahd, MSG_OUT, MSG_NOOP);\r\nahd_outb(ahd, SXFRCTL1, ahd_inb(ahd, SXFRCTL1) & ~BITBUCKET);\r\nahd_outb(ahd, SEQINTCTL, 0);\r\nahd_outb(ahd, LASTPHASE, P_BUSFREE);\r\nahd_outb(ahd, SEQ_FLAGS, 0);\r\nahd_outb(ahd, SAVED_SCSIID, 0xFF);\r\nahd_outb(ahd, SAVED_LUN, 0xFF);\r\nahd_outb(ahd, TQINPOS, ahd->tqinfifonext);\r\nahd_outb(ahd, SCSISEQ1,\r\nahd_inb(ahd, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));\r\nahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\r\nahd_outb(ahd, CLRINT, CLRSEQINT);\r\nahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);\r\nahd_unpause(ahd);\r\n}\r\nstatic void\r\nahd_clear_fifo(struct ahd_softc *ahd, u_int fifo)\r\n{\r\nahd_mode_state saved_modes;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_FIFOS) != 0)\r\nprintk("%s: Clearing FIFO %d\n", ahd_name(ahd), fifo);\r\n#endif\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, fifo, fifo);\r\nahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);\r\nif ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)\r\nahd_outb(ahd, CCSGCTL, CCSGRESET);\r\nahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);\r\nahd_outb(ahd, SG_STATE, 0);\r\nahd_restore_modes(ahd, saved_modes);\r\n}\r\nstatic void\r\nahd_flush_qoutfifo(struct ahd_softc *ahd)\r\n{\r\nstruct scb *scb;\r\nahd_mode_state saved_modes;\r\nu_int saved_scbptr;\r\nu_int ccscbctl;\r\nu_int scbid;\r\nu_int next_scbid;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nsaved_scbptr = ahd_get_scbptr(ahd);\r\nwhile ((ahd_inb(ahd, LQISTAT2) & LQIGSAVAIL) != 0) {\r\nu_int fifo_mode;\r\nu_int i;\r\nscbid = ahd_inw(ahd, GSFIFO);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: Warning - GSFIFO SCB %d invalid\n",\r\nahd_name(ahd), scbid);\r\ncontinue;\r\n}\r\nfifo_mode = 0;\r\nrescan_fifos:\r\nfor (i = 0; i < 2; i++) {\r\nfifo_mode ^= 1;\r\nahd_set_modes(ahd, fifo_mode, fifo_mode);\r\nif (ahd_scb_active_in_fifo(ahd, scb) == 0)\r\ncontinue;\r\nahd_run_data_fifo(ahd, scb);\r\nahd_delay(200);\r\ngoto rescan_fifos;\r\n}\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_set_scbptr(ahd, scbid);\r\nif ((ahd_inb_scbram(ahd, SCB_SGPTR) & SG_LIST_NULL) == 0\r\n&& ((ahd_inb_scbram(ahd, SCB_SGPTR) & SG_FULL_RESID) != 0\r\n|| (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR)\r\n& SG_LIST_NULL) != 0)) {\r\nu_int comp_head;\r\nahd_outb(ahd, SCB_SCSI_STATUS, 0);\r\nahd_outb(ahd, SCB_SGPTR,\r\nahd_inb_scbram(ahd, SCB_SGPTR)\r\n| SG_STATUS_VALID);\r\nahd_outw(ahd, SCB_TAG, scbid);\r\nahd_outw(ahd, SCB_NEXT_COMPLETE, SCB_LIST_NULL);\r\ncomp_head = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);\r\nif (SCBID_IS_NULL(comp_head)) {\r\nahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, scbid);\r\nahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, scbid);\r\n} else {\r\nu_int tail;\r\ntail = ahd_inw(ahd, COMPLETE_DMA_SCB_TAIL);\r\nahd_set_scbptr(ahd, tail);\r\nahd_outw(ahd, SCB_NEXT_COMPLETE, scbid);\r\nahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, scbid);\r\nahd_set_scbptr(ahd, scbid);\r\n}\r\n} else\r\nahd_complete_scb(ahd, scb);\r\n}\r\nahd_set_scbptr(ahd, saved_scbptr);\r\nahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\r\nwhile (((ccscbctl = ahd_inb(ahd, CCSCBCTL)) & (CCARREN|CCSCBEN)) != 0) {\r\nif ((ccscbctl & (CCSCBDIR|CCARREN)) == (CCSCBDIR|CCARREN)) {\r\nif ((ccscbctl & ARRDONE) != 0)\r\nbreak;\r\n} else if ((ccscbctl & CCSCBDONE) != 0)\r\nbreak;\r\nahd_delay(200);\r\n}\r\nif ((ccscbctl & CCSCBDIR) != 0 || (ccscbctl & ARRDONE) != 0)\r\nahd_outb(ahd, CCSCBCTL, ccscbctl & ~(CCARREN|CCSCBEN));\r\nahd_run_qoutfifo(ahd);\r\nsaved_scbptr = ahd_get_scbptr(ahd);\r\nscbid = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);\r\nwhile (!SCBID_IS_NULL(scbid)) {\r\nuint8_t *hscb_ptr;\r\nu_int i;\r\nahd_set_scbptr(ahd, scbid);\r\nnext_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: Warning - DMA-up and complete "\r\n"SCB %d invalid\n", ahd_name(ahd), scbid);\r\ncontinue;\r\n}\r\nhscb_ptr = (uint8_t *)scb->hscb;\r\nfor (i = 0; i < sizeof(struct hardware_scb); i++)\r\n*hscb_ptr++ = ahd_inb_scbram(ahd, SCB_BASE + i);\r\nahd_complete_scb(ahd, scb);\r\nscbid = next_scbid;\r\n}\r\nahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);\r\nahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, SCB_LIST_NULL);\r\nscbid = ahd_inw(ahd, COMPLETE_ON_QFREEZE_HEAD);\r\nwhile (!SCBID_IS_NULL(scbid)) {\r\nahd_set_scbptr(ahd, scbid);\r\nnext_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: Warning - Complete Qfrz SCB %d invalid\n",\r\nahd_name(ahd), scbid);\r\ncontinue;\r\n}\r\nahd_complete_scb(ahd, scb);\r\nscbid = next_scbid;\r\n}\r\nahd_outw(ahd, COMPLETE_ON_QFREEZE_HEAD, SCB_LIST_NULL);\r\nscbid = ahd_inw(ahd, COMPLETE_SCB_HEAD);\r\nwhile (!SCBID_IS_NULL(scbid)) {\r\nahd_set_scbptr(ahd, scbid);\r\nnext_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: Warning - Complete SCB %d invalid\n",\r\nahd_name(ahd), scbid);\r\ncontinue;\r\n}\r\nahd_complete_scb(ahd, scb);\r\nscbid = next_scbid;\r\n}\r\nahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);\r\nahd_set_scbptr(ahd, saved_scbptr);\r\nahd_restore_modes(ahd, saved_modes);\r\nahd->flags |= AHD_UPDATE_PEND_CMDS;\r\n}\r\nstatic int\r\nahd_scb_active_in_fifo(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nif (ahd_get_scbptr(ahd) != SCB_GET_TAG(scb)\r\n|| ((ahd_inb(ahd, LONGJMP_ADDR+1) & INVALID_ADDR) != 0\r\n&& (ahd_inb(ahd, SEQINTSRC) & (CFG4DATA|SAVEPTRS)) == 0))\r\nreturn (0);\r\nreturn (1);\r\n}\r\nstatic void\r\nahd_run_data_fifo(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nu_int seqintsrc;\r\nseqintsrc = ahd_inb(ahd, SEQINTSRC);\r\nif ((seqintsrc & CFG4DATA) != 0) {\r\nuint32_t datacnt;\r\nuint32_t sgptr;\r\nsgptr = ahd_inl_scbram(ahd, SCB_SGPTR) & ~SG_FULL_RESID;\r\nahd_outb(ahd, SCB_SGPTR, sgptr);\r\ndatacnt = ahd_inl_scbram(ahd, SCB_DATACNT);\r\nif ((datacnt & AHD_DMA_LAST_SEG) != 0) {\r\nsgptr |= LAST_SEG;\r\nahd_outb(ahd, SG_STATE, 0);\r\n} else\r\nahd_outb(ahd, SG_STATE, LOADING_NEEDED);\r\nahd_outq(ahd, HADDR, ahd_inq_scbram(ahd, SCB_DATAPTR));\r\nahd_outl(ahd, HCNT, datacnt & AHD_SG_LEN_MASK);\r\nahd_outb(ahd, SG_CACHE_PRE, sgptr);\r\nahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);\r\nahd_outb(ahd, SCB_RESIDUAL_DATACNT+3, datacnt >> 24);\r\nahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr & SG_PTR_MASK);\r\nahd_outb(ahd, SCB_FIFO_USE_COUNT,\r\nahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) + 1);\r\nahd_outw(ahd, LONGJMP_ADDR, 0);\r\nahd_outb(ahd, CLRSEQINTSRC, CLRCFG4DATA);\r\n} else if ((seqintsrc & SAVEPTRS) != 0) {\r\nuint32_t sgptr;\r\nuint32_t resid;\r\nif ((ahd_inb(ahd, LONGJMP_ADDR+1)&INVALID_ADDR) != 0) {\r\ngoto clrchn;\r\n}\r\nif ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)\r\nahd_outb(ahd, CCSGCTL, 0);\r\nahd_outb(ahd, SG_STATE, 0);\r\nahd_outb(ahd, DFCNTRL, ahd_inb(ahd, DFCNTRL) | FIFOFLUSH);\r\nsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\r\nresid = ahd_inl(ahd, SHCNT);\r\nresid |= ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+3) << 24;\r\nahd_outl(ahd, SCB_RESIDUAL_DATACNT, resid);\r\nif ((ahd_inb(ahd, SG_CACHE_SHADOW) & LAST_SEG) == 0) {\r\nif ((ahd_inb(ahd, SG_CACHE_SHADOW) & 0x80) != 0\r\n&& (sgptr & 0x80) == 0)\r\nsgptr -= 0x100;\r\nsgptr &= ~0xFF;\r\nsgptr |= ahd_inb(ahd, SG_CACHE_SHADOW)\r\n& SG_ADDR_MASK;\r\nahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);\r\nahd_outb(ahd, SCB_RESIDUAL_DATACNT + 3, 0);\r\n} else if ((resid & AHD_SG_LEN_MASK) == 0) {\r\nahd_outb(ahd, SCB_RESIDUAL_SGPTR,\r\nsgptr | SG_LIST_NULL);\r\n}\r\nahd_outq(ahd, SCB_DATAPTR, ahd_inq(ahd, SHADDR));\r\nahd_outl(ahd, SCB_DATACNT, resid);\r\nahd_outl(ahd, SCB_SGPTR, sgptr);\r\nahd_outb(ahd, CLRSEQINTSRC, CLRSAVEPTRS);\r\nahd_outb(ahd, SEQIMODE,\r\nahd_inb(ahd, SEQIMODE) | ENSAVEPTRS);\r\nif ((ahd_inb(ahd, DFCNTRL) & DIRECTION) != 0)\r\ngoto clrchn;\r\n} else if ((ahd_inb(ahd, SG_STATE) & LOADING_NEEDED) != 0) {\r\nuint32_t sgptr;\r\nuint64_t data_addr;\r\nuint32_t data_len;\r\nu_int dfcntrl;\r\nif ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0) {\r\nahd_outb(ahd, CCSGCTL, 0);\r\nahd_outb(ahd, SG_STATE, LOADING_NEEDED);\r\n}\r\nif ((ahd_inb(ahd, DFSTATUS) & PRELOAD_AVAIL) != 0\r\n&& (ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0) {\r\nsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\r\nsgptr &= SG_PTR_MASK;\r\nif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\r\nstruct ahd_dma64_seg *sg;\r\nsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\r\ndata_addr = sg->addr;\r\ndata_len = sg->len;\r\nsgptr += sizeof(*sg);\r\n} else {\r\nstruct ahd_dma_seg *sg;\r\nsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\r\ndata_addr = sg->len & AHD_SG_HIGH_ADDR_MASK;\r\ndata_addr <<= 8;\r\ndata_addr |= sg->addr;\r\ndata_len = sg->len;\r\nsgptr += sizeof(*sg);\r\n}\r\nahd_outb(ahd, SCB_RESIDUAL_DATACNT+3, data_len >> 24);\r\nahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);\r\nif (data_len & AHD_DMA_LAST_SEG) {\r\nsgptr |= LAST_SEG;\r\nahd_outb(ahd, SG_STATE, 0);\r\n}\r\nahd_outq(ahd, HADDR, data_addr);\r\nahd_outl(ahd, HCNT, data_len & AHD_SG_LEN_MASK);\r\nahd_outb(ahd, SG_CACHE_PRE, sgptr & 0xFF);\r\ndfcntrl = ahd_inb(ahd, DFCNTRL)|PRELOADEN|HDMAEN;\r\nif ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0) {\r\ndfcntrl |= SCSIENWRDIS;\r\n}\r\nahd_outb(ahd, DFCNTRL, dfcntrl);\r\n}\r\n} else if ((ahd_inb(ahd, SG_CACHE_SHADOW) & LAST_SEG_DONE) != 0) {\r\nahd_outb(ahd, SCB_SGPTR,\r\nahd_inb_scbram(ahd, SCB_SGPTR) | SG_LIST_NULL);\r\ngoto clrchn;\r\n} else if ((ahd_inb(ahd, DFSTATUS) & FIFOEMP) != 0) {\r\nclrchn:\r\nahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);\r\nahd_outb(ahd, SCB_FIFO_USE_COUNT,\r\nahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT) - 1);\r\nahd_outb(ahd, DFFSXFRCTL, CLRCHN);\r\n}\r\n}\r\nstatic void\r\nahd_run_qoutfifo(struct ahd_softc *ahd)\r\n{\r\nstruct ahd_completion *completion;\r\nstruct scb *scb;\r\nu_int scb_index;\r\nif ((ahd->flags & AHD_RUNNING_QOUTFIFO) != 0)\r\npanic("ahd_run_qoutfifo recursion");\r\nahd->flags |= AHD_RUNNING_QOUTFIFO;\r\nahd_sync_qoutfifo(ahd, BUS_DMASYNC_POSTREAD);\r\nfor (;;) {\r\ncompletion = &ahd->qoutfifo[ahd->qoutfifonext];\r\nif (completion->valid_tag != ahd->qoutfifonext_valid_tag)\r\nbreak;\r\nscb_index = ahd_le16toh(completion->tag);\r\nscb = ahd_lookup_scb(ahd, scb_index);\r\nif (scb == NULL) {\r\nprintk("%s: WARNING no command for scb %d "\r\n"(cmdcmplt)\nQOUTPOS = %d\n",\r\nahd_name(ahd), scb_index,\r\nahd->qoutfifonext);\r\nahd_dump_card_state(ahd);\r\n} else if ((completion->sg_status & SG_STATUS_VALID) != 0) {\r\nahd_handle_scb_status(ahd, scb);\r\n} else {\r\nahd_done(ahd, scb);\r\n}\r\nahd->qoutfifonext = (ahd->qoutfifonext+1) & (AHD_QOUT_SIZE-1);\r\nif (ahd->qoutfifonext == 0)\r\nahd->qoutfifonext_valid_tag ^= QOUTFIFO_ENTRY_VALID;\r\n}\r\nahd->flags &= ~AHD_RUNNING_QOUTFIFO;\r\n}\r\nstatic void\r\nahd_handle_hwerrint(struct ahd_softc *ahd)\r\n{\r\nint i;\r\nint error;\r\nerror = ahd_inb(ahd, ERROR);\r\nfor (i = 0; i < num_errors; i++) {\r\nif ((error & ahd_hard_errors[i].errno) != 0)\r\nprintk("%s: hwerrint, %s\n",\r\nahd_name(ahd), ahd_hard_errors[i].errmesg);\r\n}\r\nahd_dump_card_state(ahd);\r\npanic("BRKADRINT");\r\nahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,\r\nCAM_NO_HBA);\r\nahd_free(ahd);\r\n}\r\nstatic void\r\nahd_dump_sglist(struct scb *scb)\r\n{\r\nint i;\r\nif (scb->sg_count > 0) {\r\nif ((scb->ahd_softc->flags & AHD_64BIT_ADDRESSING) != 0) {\r\nstruct ahd_dma64_seg *sg_list;\r\nsg_list = (struct ahd_dma64_seg*)scb->sg_list;\r\nfor (i = 0; i < scb->sg_count; i++) {\r\nuint64_t addr;\r\nuint32_t len;\r\naddr = ahd_le64toh(sg_list[i].addr);\r\nlen = ahd_le32toh(sg_list[i].len);\r\nprintk("sg[%d] - Addr 0x%x%x : Length %d%s\n",\r\ni,\r\n(uint32_t)((addr >> 32) & 0xFFFFFFFF),\r\n(uint32_t)(addr & 0xFFFFFFFF),\r\nsg_list[i].len & AHD_SG_LEN_MASK,\r\n(sg_list[i].len & AHD_DMA_LAST_SEG)\r\n? " Last" : "");\r\n}\r\n} else {\r\nstruct ahd_dma_seg *sg_list;\r\nsg_list = (struct ahd_dma_seg*)scb->sg_list;\r\nfor (i = 0; i < scb->sg_count; i++) {\r\nuint32_t len;\r\nlen = ahd_le32toh(sg_list[i].len);\r\nprintk("sg[%d] - Addr 0x%x%x : Length %d%s\n",\r\ni,\r\n(len & AHD_SG_HIGH_ADDR_MASK) >> 24,\r\nahd_le32toh(sg_list[i].addr),\r\nlen & AHD_SG_LEN_MASK,\r\nlen & AHD_DMA_LAST_SEG ? " Last" : "");\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nahd_handle_seqint(struct ahd_softc *ahd, u_int intstat)\r\n{\r\nu_int seqintcode;\r\nseqintcode = ahd_inb(ahd, SEQINTCODE);\r\nahd_outb(ahd, CLRINT, CLRSEQINT);\r\nif ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {\r\nahd_unpause(ahd);\r\nwhile (!ahd_is_paused(ahd))\r\n;\r\nahd_outb(ahd, CLRINT, CLRSEQINT);\r\n}\r\nahd_update_modes(ahd);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("%s: Handle Seqint Called for code %d\n",\r\nahd_name(ahd), seqintcode);\r\n#endif\r\nswitch (seqintcode) {\r\ncase ENTERING_NONPACK:\r\n{\r\nstruct scb *scb;\r\nu_int scbid;\r\nAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\r\n~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\n} else {\r\nahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);\r\nahd_outb(ahd, SAVED_LUN, scb->hscb->lun);\r\nahd_outb(ahd, SEQ_FLAGS, 0x0);\r\n}\r\nif ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0\r\n&& (ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\r\nprintk("%s: Assuming LQIPHASE_NLQ with "\r\n"P0 assertion\n", ahd_name(ahd));\r\n#endif\r\n}\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\r\nprintk("%s: Entering NONPACK\n", ahd_name(ahd));\r\n#endif\r\nbreak;\r\n}\r\ncase INVALID_SEQINT:\r\nprintk("%s: Invalid Sequencer interrupt occurred, "\r\n"resetting channel.\n",\r\nahd_name(ahd));\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\r\nahd_dump_card_state(ahd);\r\n#endif\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nbreak;\r\ncase STATUS_OVERRUN:\r\n{\r\nstruct scb *scb;\r\nu_int scbid;\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb != NULL)\r\nahd_print_path(ahd, scb);\r\nelse\r\nprintk("%s: ", ahd_name(ahd));\r\nprintk("SCB %d Packetized Status Overrun", scbid);\r\nahd_dump_card_state(ahd);\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nbreak;\r\n}\r\ncase CFG4ISTAT_INTR:\r\n{\r\nstruct scb *scb;\r\nu_int scbid;\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nahd_dump_card_state(ahd);\r\nprintk("CFG4ISTAT: Free SCB %d referenced", scbid);\r\npanic("For safety");\r\n}\r\nahd_outq(ahd, HADDR, scb->sense_busaddr);\r\nahd_outw(ahd, HCNT, AHD_SENSE_BUFSIZE);\r\nahd_outb(ahd, HCNT + 2, 0);\r\nahd_outb(ahd, SG_CACHE_PRE, SG_LAST_SEG);\r\nahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);\r\nbreak;\r\n}\r\ncase ILLEGAL_PHASE:\r\n{\r\nu_int bus_phase;\r\nbus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\r\nprintk("%s: ILLEGAL_PHASE 0x%x\n",\r\nahd_name(ahd), bus_phase);\r\nswitch (bus_phase) {\r\ncase P_DATAOUT:\r\ncase P_DATAIN:\r\ncase P_DATAOUT_DT:\r\ncase P_DATAIN_DT:\r\ncase P_MESGOUT:\r\ncase P_STATUS:\r\ncase P_MESGIN:\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nprintk("%s: Issued Bus Reset.\n", ahd_name(ahd));\r\nbreak;\r\ncase P_COMMAND:\r\n{\r\nstruct ahd_devinfo devinfo;\r\nstruct scb *scb;\r\nstruct ahd_initiator_tinfo *targ_info;\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_transinfo *tinfo;\r\nu_int scbid;\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("Invalid phase with no valid SCB. "\r\n"Resetting bus.\n");\r\nahd_reset_channel(ahd, 'A',\r\nTRUE);\r\nbreak;\r\n}\r\nahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),\r\nSCB_GET_TARGET(ahd, scb),\r\nSCB_GET_LUN(scb),\r\nSCB_GET_CHANNEL(ahd, scb),\r\nROLE_INITIATOR);\r\ntarg_info = ahd_fetch_transinfo(ahd,\r\ndevinfo.channel,\r\ndevinfo.our_scsiid,\r\ndevinfo.target,\r\n&tstate);\r\ntinfo = &targ_info->curr;\r\nahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_ACTIVE, TRUE);\r\nahd_set_syncrate(ahd, &devinfo, 0,\r\n0, 0,\r\nAHD_TRANS_ACTIVE, TRUE);\r\nahd_outb(ahd, SCB_CDB_STORE, 0);\r\nahd_outb(ahd, SCB_CDB_STORE+1, 0);\r\nahd_outb(ahd, SCB_CDB_STORE+2, 0);\r\nahd_outb(ahd, SCB_CDB_STORE+3, 0);\r\nahd_outb(ahd, SCB_CDB_STORE+4, 0);\r\nahd_outb(ahd, SCB_CDB_STORE+5, 0);\r\nahd_outb(ahd, SCB_CDB_LEN, 6);\r\nscb->hscb->control &= ~(TAG_ENB|SCB_TAG_TYPE);\r\nscb->hscb->control |= MK_MESSAGE;\r\nahd_outb(ahd, SCB_CONTROL, scb->hscb->control);\r\nahd_outb(ahd, MSG_OUT, HOST_MSG);\r\nahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);\r\nahd_outb(ahd, SAVED_LUN, 0);\r\nahd_outb(ahd, SEQ_FLAGS, 0);\r\nahd_assert_atn(ahd);\r\nscb->flags &= ~SCB_PACKETIZED;\r\nscb->flags |= SCB_ABORT|SCB_EXTERNAL_RESET;\r\nahd_freeze_devq(ahd, scb);\r\nahd_set_transaction_status(scb, CAM_REQUEUE_REQ);\r\nahd_freeze_scb(scb);\r\nahd_send_async(ahd, devinfo.channel, devinfo.target,\r\nCAM_LUN_WILDCARD, AC_SENT_BDR);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, CLRLQOINT1, CLRLQOPHACHGINPKT);\r\nif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {\r\nahd_outb(ahd, CLRLQOINT1, 0);\r\n}\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("Unexpected command phase from "\r\n"packetized target\n");\r\n}\r\n#endif\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase CFG4OVERRUN:\r\n{\r\nstruct scb *scb;\r\nu_int scb_index;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\r\nprintk("%s: CFG4OVERRUN mode = %x\n", ahd_name(ahd),\r\nahd_inb(ahd, MODE_PTR));\r\n}\r\n#endif\r\nscb_index = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scb_index);\r\nif (scb == NULL) {\r\nahd_assert_atn(ahd);\r\nahd_outb(ahd, MSG_OUT, HOST_MSG);\r\nahd->msgout_buf[0] = MSG_ABORT_TASK;\r\nahd->msgout_len = 1;\r\nahd->msgout_index = 0;\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\nahd_outb(ahd, SCB_CONTROL,\r\nahd_inb_scbram(ahd, SCB_CONTROL)\r\n& ~STATUS_RCVD);\r\n}\r\nbreak;\r\n}\r\ncase DUMP_CARD_STATE:\r\n{\r\nahd_dump_card_state(ahd);\r\nbreak;\r\n}\r\ncase PDATA_REINIT:\r\n{\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\r\nprintk("%s: PDATA_REINIT - DFCNTRL = 0x%x "\r\n"SG_CACHE_SHADOW = 0x%x\n",\r\nahd_name(ahd), ahd_inb(ahd, DFCNTRL),\r\nahd_inb(ahd, SG_CACHE_SHADOW));\r\n}\r\n#endif\r\nahd_reinitialize_dataptrs(ahd);\r\nbreak;\r\n}\r\ncase HOST_MSG_LOOP:\r\n{\r\nstruct ahd_devinfo devinfo;\r\nahd_fetch_devinfo(ahd, &devinfo);\r\nif (ahd->msg_type == MSG_TYPE_NONE) {\r\nstruct scb *scb;\r\nu_int scb_index;\r\nu_int bus_phase;\r\nbus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\r\nif (bus_phase != P_MESGIN\r\n&& bus_phase != P_MESGOUT) {\r\nprintk("ahd_intr: HOST_MSG_LOOP bad "\r\n"phase 0x%x\n", bus_phase);\r\nahd_dump_card_state(ahd);\r\nahd_clear_intstat(ahd);\r\nahd_restart(ahd);\r\nreturn;\r\n}\r\nscb_index = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scb_index);\r\nif (devinfo.role == ROLE_INITIATOR) {\r\nif (bus_phase == P_MESGOUT)\r\nahd_setup_initiator_msgout(ahd,\r\n&devinfo,\r\nscb);\r\nelse {\r\nahd->msg_type =\r\nMSG_TYPE_INITIATOR_MSGIN;\r\nahd->msgin_index = 0;\r\n}\r\n}\r\n#ifdef AHD_TARGET_MODE\r\nelse {\r\nif (bus_phase == P_MESGOUT) {\r\nahd->msg_type =\r\nMSG_TYPE_TARGET_MSGOUT;\r\nahd->msgin_index = 0;\r\n}\r\nelse\r\nahd_setup_target_msgin(ahd,\r\n&devinfo,\r\nscb);\r\n}\r\n#endif\r\n}\r\nahd_handle_message_phase(ahd);\r\nbreak;\r\n}\r\ncase NO_MATCH:\r\n{\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);\r\nprintk("%s:%c:%d: no active SCB for reconnecting "\r\n"target - issuing BUS DEVICE RESET\n",\r\nahd_name(ahd), 'A', ahd_inb(ahd, SELID) >> 4);\r\nprintk("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "\r\n"REG0 == 0x%x ACCUM = 0x%x\n",\r\nahd_inb(ahd, SAVED_SCSIID), ahd_inb(ahd, SAVED_LUN),\r\nahd_inw(ahd, REG0), ahd_inb(ahd, ACCUM));\r\nprintk("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "\r\n"SINDEX == 0x%x\n",\r\nahd_inb(ahd, SEQ_FLAGS), ahd_get_scbptr(ahd),\r\nahd_find_busy_tcl(ahd,\r\nBUILD_TCL(ahd_inb(ahd, SAVED_SCSIID),\r\nahd_inb(ahd, SAVED_LUN))),\r\nahd_inw(ahd, SINDEX));\r\nprintk("SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "\r\n"SCB_CONTROL == 0x%x\n",\r\nahd_inb(ahd, SELID), ahd_inb_scbram(ahd, SCB_SCSIID),\r\nahd_inb_scbram(ahd, SCB_LUN),\r\nahd_inb_scbram(ahd, SCB_CONTROL));\r\nprintk("SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x\n",\r\nahd_inb(ahd, SCSIBUS), ahd_inb(ahd, SCSISIGI));\r\nprintk("SXFRCTL0 == 0x%x\n", ahd_inb(ahd, SXFRCTL0));\r\nprintk("SEQCTL0 == 0x%x\n", ahd_inb(ahd, SEQCTL0));\r\nahd_dump_card_state(ahd);\r\nahd->msgout_buf[0] = MSG_BUS_DEV_RESET;\r\nahd->msgout_len = 1;\r\nahd->msgout_index = 0;\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\nahd_outb(ahd, MSG_OUT, HOST_MSG);\r\nahd_assert_atn(ahd);\r\nbreak;\r\n}\r\ncase PROTO_VIOLATION:\r\n{\r\nahd_handle_proto_violation(ahd);\r\nbreak;\r\n}\r\ncase IGN_WIDE_RES:\r\n{\r\nstruct ahd_devinfo devinfo;\r\nahd_fetch_devinfo(ahd, &devinfo);\r\nahd_handle_ign_wide_residue(ahd, &devinfo);\r\nbreak;\r\n}\r\ncase BAD_PHASE:\r\n{\r\nu_int lastphase;\r\nlastphase = ahd_inb(ahd, LASTPHASE);\r\nprintk("%s:%c:%d: unknown scsi bus phase %x, "\r\n"lastphase = 0x%x. Attempting to continue\n",\r\nahd_name(ahd), 'A',\r\nSCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),\r\nlastphase, ahd_inb(ahd, SCSISIGI));\r\nbreak;\r\n}\r\ncase MISSED_BUSFREE:\r\n{\r\nu_int lastphase;\r\nlastphase = ahd_inb(ahd, LASTPHASE);\r\nprintk("%s:%c:%d: Missed busfree. "\r\n"Lastphase = 0x%x, Curphase = 0x%x\n",\r\nahd_name(ahd), 'A',\r\nSCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),\r\nlastphase, ahd_inb(ahd, SCSISIGI));\r\nahd_restart(ahd);\r\nreturn;\r\n}\r\ncase DATA_OVERRUN:\r\n{\r\nstruct scb *scb;\r\nu_int scbindex;\r\n#ifdef AHD_DEBUG\r\nu_int lastphase;\r\n#endif\r\nscbindex = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbindex);\r\n#ifdef AHD_DEBUG\r\nlastphase = ahd_inb(ahd, LASTPHASE);\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("data overrun detected %s. Tag == 0x%x.\n",\r\nahd_lookup_phase_entry(lastphase)->phasemsg,\r\nSCB_GET_TAG(scb));\r\nahd_print_path(ahd, scb);\r\nprintk("%s seen Data Phase. Length = %ld. "\r\n"NumSGs = %d.\n",\r\nahd_inb(ahd, SEQ_FLAGS) & DPHASE\r\n? "Have" : "Haven't",\r\nahd_get_transfer_length(scb), scb->sg_count);\r\nahd_dump_sglist(scb);\r\n}\r\n#endif\r\nahd_freeze_devq(ahd, scb);\r\nahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);\r\nahd_freeze_scb(scb);\r\nbreak;\r\n}\r\ncase MKMSG_FAILED:\r\n{\r\nstruct ahd_devinfo devinfo;\r\nstruct scb *scb;\r\nu_int scbid;\r\nahd_fetch_devinfo(ahd, &devinfo);\r\nprintk("%s:%c:%d:%d: Attempt to issue message failed\n",\r\nahd_name(ahd), devinfo.channel, devinfo.target,\r\ndevinfo.lun);\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb != NULL\r\n&& (scb->flags & SCB_RECOVERY_SCB) != 0)\r\nahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),\r\nSCB_GET_CHANNEL(ahd, scb),\r\nSCB_GET_LUN(scb), SCB_GET_TAG(scb),\r\nROLE_INITIATOR, 0,\r\nSEARCH_REMOVE);\r\nahd_outb(ahd, SCB_CONTROL,\r\nahd_inb_scbram(ahd, SCB_CONTROL) & ~MK_MESSAGE);\r\nbreak;\r\n}\r\ncase TASKMGMT_FUNC_COMPLETE:\r\n{\r\nu_int scbid;\r\nstruct scb *scb;\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb != NULL) {\r\nu_int lun;\r\nu_int tag;\r\ncam_status error;\r\nahd_print_path(ahd, scb);\r\nprintk("Task Management Func 0x%x Complete\n",\r\nscb->hscb->task_management);\r\nlun = CAM_LUN_WILDCARD;\r\ntag = SCB_LIST_NULL;\r\nswitch (scb->hscb->task_management) {\r\ncase SIU_TASKMGMT_ABORT_TASK:\r\ntag = SCB_GET_TAG(scb);\r\ncase SIU_TASKMGMT_ABORT_TASK_SET:\r\ncase SIU_TASKMGMT_CLEAR_TASK_SET:\r\nlun = scb->hscb->lun;\r\nerror = CAM_REQ_ABORTED;\r\nahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),\r\n'A', lun, tag, ROLE_INITIATOR,\r\nerror);\r\nbreak;\r\ncase SIU_TASKMGMT_LUN_RESET:\r\nlun = scb->hscb->lun;\r\ncase SIU_TASKMGMT_TARGET_RESET:\r\n{\r\nstruct ahd_devinfo devinfo;\r\nahd_scb_devinfo(ahd, &devinfo, scb);\r\nerror = CAM_BDR_SENT;\r\nahd_handle_devreset(ahd, &devinfo, lun,\r\nCAM_BDR_SENT,\r\nlun != CAM_LUN_WILDCARD\r\n? "Lun Reset"\r\n: "Target Reset",\r\n0);\r\nbreak;\r\n}\r\ndefault:\r\npanic("Unexpected TaskMgmt Func\n");\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase TASKMGMT_CMD_CMPLT_OKAY:\r\n{\r\nu_int scbid;\r\nstruct scb *scb;\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb != NULL) {\r\nahd_print_path(ahd, scb);\r\nprintk("SCB completes before TMF\n");\r\nwhile ((ahd_inb(ahd, SCSISEQ0) & ENSELO) != 0\r\n&& (ahd_inb(ahd, SSTAT0) & SELDO) == 0\r\n&& (ahd_inb(ahd, SSTAT1) & SELTO) == 0)\r\n;\r\nahd_outb(ahd, SCB_TASK_MANAGEMENT, 0);\r\nahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),\r\nSCB_GET_CHANNEL(ahd, scb),\r\nSCB_GET_LUN(scb), SCB_GET_TAG(scb),\r\nROLE_INITIATOR, 0,\r\nSEARCH_REMOVE);\r\n}\r\nbreak;\r\n}\r\ncase TRACEPOINT0:\r\ncase TRACEPOINT1:\r\ncase TRACEPOINT2:\r\ncase TRACEPOINT3:\r\nprintk("%s: Tracepoint %d\n", ahd_name(ahd),\r\nseqintcode - TRACEPOINT0);\r\nbreak;\r\ncase NO_SEQINT:\r\nbreak;\r\ncase SAW_HWERR:\r\nahd_handle_hwerrint(ahd);\r\nbreak;\r\ndefault:\r\nprintk("%s: Unexpected SEQINTCODE %d\n", ahd_name(ahd),\r\nseqintcode);\r\nbreak;\r\n}\r\nahd_unpause(ahd);\r\n}\r\nstatic void\r\nahd_handle_scsiint(struct ahd_softc *ahd, u_int intstat)\r\n{\r\nstruct scb *scb;\r\nu_int status0;\r\nu_int status3;\r\nu_int status;\r\nu_int lqistat1;\r\nu_int lqostat0;\r\nu_int scbid;\r\nu_int busfreetime;\r\nahd_update_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nstatus3 = ahd_inb(ahd, SSTAT3) & (NTRAMPERR|OSRAMPERR);\r\nstatus0 = ahd_inb(ahd, SSTAT0) & (IOERR|OVERRUN|SELDI|SELDO);\r\nstatus = ahd_inb(ahd, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);\r\nlqistat1 = ahd_inb(ahd, LQISTAT1);\r\nlqostat0 = ahd_inb(ahd, LQOSTAT0);\r\nbusfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;\r\nif (((status & SCSIRSTI) != 0) && (ahd->flags & AHD_BUS_RESET_ACTIVE)) {\r\nahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);\r\nreturn;\r\n}\r\nahd->flags &= ~AHD_BUS_RESET_ACTIVE;\r\nif ((status0 & (SELDI|SELDO)) != 0) {\r\nu_int simode0;\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nsimode0 = ahd_inb(ahd, SIMODE0);\r\nstatus0 &= simode0 & (IOERR|OVERRUN|SELDI|SELDO);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\n}\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb != NULL\r\n&& (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)\r\nscb = NULL;\r\nif ((status0 & IOERR) != 0) {\r\nu_int now_lvd;\r\nnow_lvd = ahd_inb(ahd, SBLKCTL) & ENAB40;\r\nprintk("%s: Transceiver State Has Changed to %s mode\n",\r\nahd_name(ahd), now_lvd ? "LVD" : "SE");\r\nahd_outb(ahd, CLRSINT0, CLRIOERR);\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nahd_pause(ahd);\r\nahd_setup_iocell_workaround(ahd);\r\nahd_unpause(ahd);\r\n} else if ((status0 & OVERRUN) != 0) {\r\nprintk("%s: SCSI offset overrun detected. Resetting bus.\n",\r\nahd_name(ahd));\r\nahd_reset_channel(ahd, 'A', TRUE);\r\n} else if ((status & SCSIRSTI) != 0) {\r\nprintk("%s: Someone reset channel A\n", ahd_name(ahd));\r\nahd_reset_channel(ahd, 'A', FALSE);\r\n} else if ((status & SCSIPERR) != 0) {\r\nahd_clear_critical_section(ahd);\r\nahd_handle_transmission_error(ahd);\r\n} else if (lqostat0 != 0) {\r\nprintk("%s: lqostat0 == 0x%x!\n", ahd_name(ahd), lqostat0);\r\nahd_outb(ahd, CLRLQOINT0, lqostat0);\r\nif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0)\r\nahd_outb(ahd, CLRLQOINT1, 0);\r\n} else if ((status & SELTO) != 0) {\r\nahd_outb(ahd, SCSISEQ0, 0);\r\nahd_clear_critical_section(ahd);\r\nahd_clear_msg_state(ahd);\r\nahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\r\nahd_outb(ahd, CLRSINT0, CLRSELINGO);\r\nscbid = ahd_inw(ahd, WAITING_TID_HEAD);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: ahd_intr - referenced scb not "\r\n"valid during SELTO scb(0x%x)\n",\r\nahd_name(ahd), scbid);\r\nahd_dump_card_state(ahd);\r\n} else {\r\nstruct ahd_devinfo devinfo;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_SELTO) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("Saw Selection Timeout for SCB 0x%x\n",\r\nscbid);\r\n}\r\n#endif\r\nahd_scb_devinfo(ahd, &devinfo, scb);\r\nahd_set_transaction_status(scb, CAM_SEL_TIMEOUT);\r\nahd_freeze_devq(ahd, scb);\r\nahd_handle_devreset(ahd, &devinfo,\r\nCAM_LUN_WILDCARD,\r\nCAM_SEL_TIMEOUT,\r\n"Selection Timeout",\r\n1);\r\n}\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\nahd_iocell_first_selection(ahd);\r\nahd_unpause(ahd);\r\n} else if ((status0 & (SELDI|SELDO)) != 0) {\r\nahd_iocell_first_selection(ahd);\r\nahd_unpause(ahd);\r\n} else if (status3 != 0) {\r\nprintk("%s: SCSI Cell parity error SSTAT3 == 0x%x\n",\r\nahd_name(ahd), status3);\r\nahd_outb(ahd, CLRSINT3, status3);\r\n} else if ((lqistat1 & (LQIPHASE_LQ|LQIPHASE_NLQ)) != 0) {\r\nahd_clear_critical_section(ahd);\r\nahd_handle_lqiphase_error(ahd, lqistat1);\r\n} else if ((lqistat1 & LQICRCI_NLQ) != 0) {\r\nahd_outb(ahd, CLRLQIINT1, CLRLQICRCI_NLQ);\r\n} else if ((status & BUSFREE) != 0\r\n|| (lqistat1 & LQOBUSFREE) != 0) {\r\nu_int lqostat1;\r\nint restart;\r\nint clear_fifo;\r\nint packetized;\r\nu_int mode;\r\nahd_outb(ahd, SCSISEQ0, 0);\r\nahd_clear_critical_section(ahd);\r\nmode = AHD_MODE_SCSI;\r\nbusfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;\r\nlqostat1 = ahd_inb(ahd, LQOSTAT1);\r\nswitch (busfreetime) {\r\ncase BUSFREE_DFF0:\r\ncase BUSFREE_DFF1:\r\n{\r\nmode = busfreetime == BUSFREE_DFF0\r\n? AHD_MODE_DFF0 : AHD_MODE_DFF1;\r\nahd_set_modes(ahd, mode, mode);\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: Invalid SCB %d in DFF%d "\r\n"during unexpected busfree\n",\r\nahd_name(ahd), scbid, mode);\r\npacketized = 0;\r\n} else\r\npacketized = (scb->flags & SCB_PACKETIZED) != 0;\r\nclear_fifo = 1;\r\nbreak;\r\n}\r\ncase BUSFREE_LQO:\r\nclear_fifo = 0;\r\npacketized = 1;\r\nbreak;\r\ndefault:\r\nclear_fifo = 0;\r\npacketized = (lqostat1 & LQOBUSFREE) != 0;\r\nif (!packetized\r\n&& ahd_inb(ahd, LASTPHASE) == P_BUSFREE\r\n&& (ahd_inb(ahd, SSTAT0) & SELDI) == 0\r\n&& ((ahd_inb(ahd, SSTAT0) & SELDO) == 0\r\n|| (ahd_inb(ahd, SCSISEQ0) & ENSELO) == 0))\r\npacketized = 1;\r\nbreak;\r\n}\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("Saw Busfree. Busfreetime = 0x%x.\n",\r\nbusfreetime);\r\n#endif\r\nif (packetized && ahd_inb(ahd, LASTPHASE) == P_BUSFREE) {\r\nrestart = ahd_handle_pkt_busfree(ahd, busfreetime);\r\n} else {\r\npacketized = 0;\r\nrestart = ahd_handle_nonpkt_busfree(ahd);\r\n}\r\nahd_outb(ahd, CLRSINT1, CLRBUSFREE);\r\nif (packetized == 0\r\n&& (ahd->bugs & AHD_BUSFREEREV_BUG) != 0)\r\nahd_outb(ahd, SIMODE1,\r\nahd_inb(ahd, SIMODE1) & ~ENBUSFREE);\r\nif (clear_fifo)\r\nahd_clear_fifo(ahd, mode);\r\nahd_clear_msg_state(ahd);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\nif (restart) {\r\nahd_restart(ahd);\r\n} else {\r\nahd_unpause(ahd);\r\n}\r\n} else {\r\nprintk("%s: Missing case in ahd_handle_scsiint. status = %x\n",\r\nahd_name(ahd), status);\r\nahd_dump_card_state(ahd);\r\nahd_clear_intstat(ahd);\r\nahd_unpause(ahd);\r\n}\r\n}\r\nstatic void\r\nahd_handle_transmission_error(struct ahd_softc *ahd)\r\n{\r\nstruct scb *scb;\r\nu_int scbid;\r\nu_int lqistat1;\r\nu_int lqistat2;\r\nu_int msg_out;\r\nu_int curphase;\r\nu_int lastphase;\r\nu_int perrdiag;\r\nu_int cur_col;\r\nint silent;\r\nscb = NULL;\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nlqistat1 = ahd_inb(ahd, LQISTAT1) & ~(LQIPHASE_LQ|LQIPHASE_NLQ);\r\nlqistat2 = ahd_inb(ahd, LQISTAT2);\r\nif ((lqistat1 & (LQICRCI_NLQ|LQICRCI_LQ)) == 0\r\n&& (ahd->bugs & AHD_NLQICRC_DELAYED_BUG) != 0) {\r\nu_int lqistate;\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nlqistate = ahd_inb(ahd, LQISTATE);\r\nif ((lqistate >= 0x1E && lqistate <= 0x24)\r\n|| (lqistate == 0x29)) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {\r\nprintk("%s: NLQCRC found via LQISTATE\n",\r\nahd_name(ahd));\r\n}\r\n#endif\r\nlqistat1 |= LQICRCI_NLQ;\r\n}\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\n}\r\nahd_outb(ahd, CLRLQIINT1, lqistat1);\r\nlastphase = ahd_inb(ahd, LASTPHASE);\r\ncurphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\r\nperrdiag = ahd_inb(ahd, PERRDIAG);\r\nmsg_out = MSG_INITIATOR_DET_ERR;\r\nahd_outb(ahd, CLRSINT1, CLRSCSIPERR);\r\nsilent = FALSE;\r\nif (lqistat1 == 0\r\n|| (lqistat1 & LQICRCI_NLQ) != 0) {\r\nif ((lqistat1 & (LQICRCI_NLQ|LQIOVERI_NLQ)) != 0)\r\nahd_set_active_fifo(ahd);\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb != NULL && SCB_IS_SILENT(scb))\r\nsilent = TRUE;\r\n}\r\ncur_col = 0;\r\nif (silent == FALSE) {\r\nprintk("%s: Transmission error detected\n", ahd_name(ahd));\r\nahd_lqistat1_print(lqistat1, &cur_col, 50);\r\nahd_lastphase_print(lastphase, &cur_col, 50);\r\nahd_scsisigi_print(curphase, &cur_col, 50);\r\nahd_perrdiag_print(perrdiag, &cur_col, 50);\r\nprintk("\n");\r\nahd_dump_card_state(ahd);\r\n}\r\nif ((lqistat1 & (LQIOVERI_LQ|LQIOVERI_NLQ)) != 0) {\r\nif (silent == FALSE) {\r\nprintk("%s: Gross protocol error during incoming "\r\n"packet. lqistat1 == 0x%x. Resetting bus.\n",\r\nahd_name(ahd), lqistat1);\r\n}\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nreturn;\r\n} else if ((lqistat1 & LQICRCI_LQ) != 0) {\r\nahd_outb(ahd, LQCTL2, LQIRETRY);\r\nprintk("LQIRetry for LQICRCI_LQ to release ACK\n");\r\n} else if ((lqistat1 & LQICRCI_NLQ) != 0) {\r\nif (silent == FALSE)\r\nprintk("LQICRC_NLQ\n");\r\nif (scb == NULL) {\r\nprintk("%s: No SCB valid for LQICRC_NLQ. "\r\n"Resetting bus\n", ahd_name(ahd));\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nreturn;\r\n}\r\n} else if ((lqistat1 & LQIBADLQI) != 0) {\r\nprintk("Need to handle BADLQI!\n");\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nreturn;\r\n} else if ((perrdiag & (PARITYERR|PREVPHASE)) == PARITYERR) {\r\nif ((curphase & ~P_DATAIN_DT) != 0) {\r\nif (silent == FALSE)\r\nprintk("Acking %s to clear perror\n",\r\nahd_lookup_phase_entry(curphase)->phasemsg);\r\nahd_inb(ahd, SCSIDAT);\r\n}\r\nif (curphase == P_MESGIN)\r\nmsg_out = MSG_PARITY_ERROR;\r\n}\r\nahd->send_msg_perror = msg_out;\r\nif (scb != NULL && msg_out == MSG_INITIATOR_DET_ERR)\r\nscb->flags |= SCB_TRANSMISSION_ERROR;\r\nahd_outb(ahd, MSG_OUT, HOST_MSG);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\nahd_unpause(ahd);\r\n}\r\nstatic void\r\nahd_handle_lqiphase_error(struct ahd_softc *ahd, u_int lqistat1)\r\n{\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, CLRLQIINT1, lqistat1);\r\nahd_set_active_fifo(ahd);\r\nif ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0\r\n&& (ahd_inb(ahd, MDFFSTAT) & DLZERO) != 0) {\r\nif ((lqistat1 & LQIPHASE_LQ) != 0) {\r\nprintk("LQIRETRY for LQIPHASE_LQ\n");\r\nahd_outb(ahd, LQCTL2, LQIRETRY);\r\n} else if ((lqistat1 & LQIPHASE_NLQ) != 0) {\r\nprintk("LQIRETRY for LQIPHASE_NLQ\n");\r\nahd_outb(ahd, LQCTL2, LQIRETRY);\r\n} else\r\npanic("ahd_handle_lqiphase_error: No phase errors\n");\r\nahd_dump_card_state(ahd);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\nahd_unpause(ahd);\r\n} else {\r\nprintk("Reseting Channel for LQI Phase error\n");\r\nahd_dump_card_state(ahd);\r\nahd_reset_channel(ahd, 'A', TRUE);\r\n}\r\n}\r\nstatic int\r\nahd_handle_pkt_busfree(struct ahd_softc *ahd, u_int busfreetime)\r\n{\r\nu_int lqostat1;\r\nAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\r\n~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\r\nlqostat1 = ahd_inb(ahd, LQOSTAT1);\r\nif ((lqostat1 & LQOBUSFREE) != 0) {\r\nstruct scb *scb;\r\nu_int scbid;\r\nu_int saved_scbptr;\r\nu_int waiting_h;\r\nu_int waiting_t;\r\nu_int next;\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nscbid = ahd_inw(ahd, CURRSCB);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL)\r\npanic("SCB not valid during LQOBUSFREE");\r\nahd_outb(ahd, CLRLQOINT1, CLRLQOBUSFREE);\r\nif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0)\r\nahd_outb(ahd, CLRLQOINT1, 0);\r\nahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);\r\nahd_flush_device_writes(ahd);\r\nahd_outb(ahd, CLRSINT0, CLRSELDO);\r\nahd_outb(ahd, LQCTL2, ahd_inb(ahd, LQCTL2) | LQOTOIDLE);\r\nwaiting_h = ahd_inw(ahd, WAITING_TID_HEAD);\r\nsaved_scbptr = ahd_get_scbptr(ahd);\r\nif (waiting_h != scbid) {\r\nahd_outw(ahd, WAITING_TID_HEAD, scbid);\r\nwaiting_t = ahd_inw(ahd, WAITING_TID_TAIL);\r\nif (waiting_t == waiting_h) {\r\nahd_outw(ahd, WAITING_TID_TAIL, scbid);\r\nnext = SCB_LIST_NULL;\r\n} else {\r\nahd_set_scbptr(ahd, waiting_h);\r\nnext = ahd_inw_scbram(ahd, SCB_NEXT2);\r\n}\r\nahd_set_scbptr(ahd, scbid);\r\nahd_outw(ahd, SCB_NEXT2, next);\r\n}\r\nahd_set_scbptr(ahd, saved_scbptr);\r\nif (scb->crc_retry_count < AHD_MAX_LQ_CRC_ERRORS) {\r\nif (SCB_IS_SILENT(scb) == FALSE) {\r\nahd_print_path(ahd, scb);\r\nprintk("Probable outgoing LQ CRC error. "\r\n"Retrying command\n");\r\n}\r\nscb->crc_retry_count++;\r\n} else {\r\nahd_set_transaction_status(scb, CAM_UNCOR_PARITY);\r\nahd_freeze_scb(scb);\r\nahd_freeze_devq(ahd, scb);\r\n}\r\nreturn (0);\r\n} else if ((ahd_inb(ahd, PERRDIAG) & PARITYERR) != 0) {\r\nahd_outb(ahd, CLRSINT1, CLRSCSIPERR|CLRBUSFREE);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MASKED_ERRORS) != 0)\r\nprintk("%s: Parity on last REQ detected "\r\n"during busfree phase.\n",\r\nahd_name(ahd));\r\n#endif\r\nreturn (0);\r\n}\r\nif (ahd->src_mode != AHD_MODE_SCSI) {\r\nu_int scbid;\r\nstruct scb *scb;\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nahd_print_path(ahd, scb);\r\nprintk("Unexpected PKT busfree condition\n");\r\nahd_dump_card_state(ahd);\r\nahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb), 'A',\r\nSCB_GET_LUN(scb), SCB_GET_TAG(scb),\r\nROLE_INITIATOR, CAM_UNEXP_BUSFREE);\r\nreturn (1);\r\n}\r\nprintk("%s: Unexpected PKT busfree condition\n", ahd_name(ahd));\r\nahd_dump_card_state(ahd);\r\nreturn (1);\r\n}\r\nstatic int\r\nahd_handle_nonpkt_busfree(struct ahd_softc *ahd)\r\n{\r\nstruct ahd_devinfo devinfo;\r\nstruct scb *scb;\r\nu_int lastphase;\r\nu_int saved_scsiid;\r\nu_int saved_lun;\r\nu_int target;\r\nu_int initiator_role_id;\r\nu_int scbid;\r\nu_int ppr_busfree;\r\nint printerror;\r\nlastphase = ahd_inb(ahd, LASTPHASE);\r\nsaved_scsiid = ahd_inb(ahd, SAVED_SCSIID);\r\nsaved_lun = ahd_inb(ahd, SAVED_LUN);\r\ntarget = SCSIID_TARGET(ahd, saved_scsiid);\r\ninitiator_role_id = SCSIID_OUR_ID(saved_scsiid);\r\nahd_compile_devinfo(&devinfo, initiator_role_id,\r\ntarget, saved_lun, 'A', ROLE_INITIATOR);\r\nprinterror = 1;\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb != NULL\r\n&& (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)\r\nscb = NULL;\r\nppr_busfree = (ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0;\r\nif (lastphase == P_MESGOUT) {\r\nu_int tag;\r\ntag = SCB_LIST_NULL;\r\nif (ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT_TAG, TRUE)\r\n|| ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT, TRUE)) {\r\nint found;\r\nint sent_msg;\r\nif (scb == NULL) {\r\nahd_print_devinfo(ahd, &devinfo);\r\nprintk("Abort for unidentified "\r\n"connection completed.\n");\r\nreturn (1);\r\n}\r\nsent_msg = ahd->msgout_buf[ahd->msgout_index - 1];\r\nahd_print_path(ahd, scb);\r\nprintk("SCB %d - Abort%s Completed.\n",\r\nSCB_GET_TAG(scb),\r\nsent_msg == MSG_ABORT_TAG ? "" : " Tag");\r\nif (sent_msg == MSG_ABORT_TAG)\r\ntag = SCB_GET_TAG(scb);\r\nif ((scb->flags & SCB_EXTERNAL_RESET) != 0) {\r\ntag = SCB_GET_TAG(scb);\r\nsaved_lun = scb->hscb->lun;\r\n}\r\nfound = ahd_abort_scbs(ahd, target, 'A', saved_lun,\r\ntag, ROLE_INITIATOR,\r\nCAM_REQ_ABORTED);\r\nprintk("found == 0x%x\n", found);\r\nprinterror = 0;\r\n} else if (ahd_sent_msg(ahd, AHDMSG_1B,\r\nMSG_BUS_DEV_RESET, TRUE)) {\r\n#ifdef __FreeBSD__\r\nif (scb != NULL\r\n&& scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV\r\n&& ahd_match_scb(ahd, scb, target, 'A',\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL,\r\nROLE_INITIATOR))\r\nahd_set_transaction_status(scb, CAM_REQ_CMP);\r\n#endif\r\nahd_handle_devreset(ahd, &devinfo, CAM_LUN_WILDCARD,\r\nCAM_BDR_SENT, "Bus Device Reset",\r\n0);\r\nprinterror = 0;\r\n} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, FALSE)\r\n&& ppr_busfree == 0) {\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("PPR negotiation rejected busfree.\n");\r\n#endif\r\ntinfo = ahd_fetch_transinfo(ahd, devinfo.channel,\r\ndevinfo.our_scsiid,\r\ndevinfo.target, &tstate);\r\nif ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ)!=0) {\r\nahd_set_width(ahd, &devinfo,\r\nMSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_CUR,\r\nTRUE);\r\nahd_set_syncrate(ahd, &devinfo,\r\n0, 0,\r\n0,\r\nAHD_TRANS_CUR,\r\nTRUE);\r\n} else {\r\ntinfo->curr.transport_version = 2;\r\ntinfo->goal.transport_version = 2;\r\ntinfo->goal.ppr_options = 0;\r\nif (scb != NULL) {\r\nahd_freeze_devq(ahd, scb);\r\nahd_qinfifo_requeue_tail(ahd, scb);\r\n}\r\nprinterror = 0;\r\n}\r\n} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, FALSE)\r\n&& ppr_busfree == 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("WDTR negotiation rejected busfree.\n");\r\n#endif\r\nahd_set_width(ahd, &devinfo,\r\nMSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_CUR|AHD_TRANS_GOAL,\r\nTRUE);\r\nif (scb != NULL) {\r\nahd_freeze_devq(ahd, scb);\r\nahd_qinfifo_requeue_tail(ahd, scb);\r\n}\r\nprinterror = 0;\r\n} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, FALSE)\r\n&& ppr_busfree == 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("SDTR negotiation rejected busfree.\n");\r\n#endif\r\nahd_set_syncrate(ahd, &devinfo,\r\n0, 0,\r\n0,\r\nAHD_TRANS_CUR|AHD_TRANS_GOAL,\r\nTRUE);\r\nif (scb != NULL) {\r\nahd_freeze_devq(ahd, scb);\r\nahd_qinfifo_requeue_tail(ahd, scb);\r\n}\r\nprinterror = 0;\r\n} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_IDE_BUSFREE) != 0\r\n&& ahd_sent_msg(ahd, AHDMSG_1B,\r\nMSG_INITIATOR_DET_ERR, TRUE)) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("Expected IDE Busfree\n");\r\n#endif\r\nprinterror = 0;\r\n} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_QASREJ_BUSFREE)\r\n&& ahd_sent_msg(ahd, AHDMSG_1B,\r\nMSG_MESSAGE_REJECT, TRUE)) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("Expected QAS Reject Busfree\n");\r\n#endif\r\nprinterror = 0;\r\n}\r\n}\r\nif (scb != NULL && printerror != 0\r\n&& (lastphase == P_MESGIN || lastphase == P_MESGOUT)\r\n&& ((ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0)) {\r\nahd_freeze_devq(ahd, scb);\r\nahd_set_transaction_status(scb, CAM_REQUEUE_REQ);\r\nahd_freeze_scb(scb);\r\nif ((ahd->msg_flags & MSG_FLAG_IU_REQ_CHANGED) != 0) {\r\nahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),\r\nSCB_GET_CHANNEL(ahd, scb),\r\nSCB_GET_LUN(scb), SCB_LIST_NULL,\r\nROLE_INITIATOR, CAM_REQ_ABORTED);\r\n} else {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("PPR Negotiation Busfree.\n");\r\n#endif\r\nahd_done(ahd, scb);\r\n}\r\nprinterror = 0;\r\n}\r\nif (printerror != 0) {\r\nint aborted;\r\naborted = 0;\r\nif (scb != NULL) {\r\nu_int tag;\r\nif ((scb->hscb->control & TAG_ENB) != 0)\r\ntag = SCB_GET_TAG(scb);\r\nelse\r\ntag = SCB_LIST_NULL;\r\nahd_print_path(ahd, scb);\r\naborted = ahd_abort_scbs(ahd, target, 'A',\r\nSCB_GET_LUN(scb), tag,\r\nROLE_INITIATOR,\r\nCAM_UNEXP_BUSFREE);\r\n} else {\r\nprintk("%s: ", ahd_name(ahd));\r\n}\r\nprintk("Unexpected busfree %s, %d SCBs aborted, "\r\n"PRGMCNT == 0x%x\n",\r\nahd_lookup_phase_entry(lastphase)->phasemsg,\r\naborted,\r\nahd_inw(ahd, PRGMCNT));\r\nahd_dump_card_state(ahd);\r\nif (lastphase != P_BUSFREE)\r\nahd_force_renegotiation(ahd, &devinfo);\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nahd_handle_proto_violation(struct ahd_softc *ahd)\r\n{\r\nstruct ahd_devinfo devinfo;\r\nstruct scb *scb;\r\nu_int scbid;\r\nu_int seq_flags;\r\nu_int curphase;\r\nu_int lastphase;\r\nint found;\r\nahd_fetch_devinfo(ahd, &devinfo);\r\nscbid = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nseq_flags = ahd_inb(ahd, SEQ_FLAGS);\r\ncurphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;\r\nlastphase = ahd_inb(ahd, LASTPHASE);\r\nif ((seq_flags & NOT_IDENTIFIED) != 0) {\r\nahd_print_devinfo(ahd, &devinfo);\r\nprintk("Target did not send an IDENTIFY message. "\r\n"LASTPHASE = 0x%x.\n", lastphase);\r\nscb = NULL;\r\n} else if (scb == NULL) {\r\nahd_print_devinfo(ahd, &devinfo);\r\nprintk("No SCB found during protocol violation\n");\r\ngoto proto_violation_reset;\r\n} else {\r\nahd_set_transaction_status(scb, CAM_SEQUENCE_FAIL);\r\nif ((seq_flags & NO_CDB_SENT) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("No or incomplete CDB sent to device.\n");\r\n} else if ((ahd_inb_scbram(ahd, SCB_CONTROL)\r\n& STATUS_RCVD) == 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("Completed command without status.\n");\r\n} else {\r\nahd_print_path(ahd, scb);\r\nprintk("Unknown protocol violation.\n");\r\nahd_dump_card_state(ahd);\r\n}\r\n}\r\nif ((lastphase & ~P_DATAIN_DT) == 0\r\n|| lastphase == P_COMMAND) {\r\nproto_violation_reset:\r\nfound = ahd_reset_channel(ahd, 'A', TRUE);\r\nprintk("%s: Issued Channel %c Bus Reset. "\r\n"%d SCBs aborted\n", ahd_name(ahd), 'A', found);\r\n} else {\r\nahd_outb(ahd, SCSISEQ0,\r\nahd_inb(ahd, SCSISEQ0) & ~ENSELO);\r\nahd_assert_atn(ahd);\r\nahd_outb(ahd, MSG_OUT, HOST_MSG);\r\nif (scb == NULL) {\r\nahd_print_devinfo(ahd, &devinfo);\r\nahd->msgout_buf[0] = MSG_ABORT_TASK;\r\nahd->msgout_len = 1;\r\nahd->msgout_index = 0;\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\n} else {\r\nahd_print_path(ahd, scb);\r\nscb->flags |= SCB_ABORT;\r\n}\r\nprintk("Protocol violation %s. Attempting to abort.\n",\r\nahd_lookup_phase_entry(curphase)->phasemsg);\r\n}\r\n}\r\nstatic void\r\nahd_force_renegotiation(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nstruct ahd_initiator_tinfo *targ_info;\r\nstruct ahd_tmode_tstate *tstate;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\r\nahd_print_devinfo(ahd, devinfo);\r\nprintk("Forcing renegotiation\n");\r\n}\r\n#endif\r\ntarg_info = ahd_fetch_transinfo(ahd,\r\ndevinfo->channel,\r\ndevinfo->our_scsiid,\r\ndevinfo->target,\r\n&tstate);\r\nahd_update_neg_request(ahd, devinfo, tstate,\r\ntarg_info, AHD_NEG_IF_NON_ASYNC);\r\n}\r\nstatic void\r\nahd_clear_critical_section(struct ahd_softc *ahd)\r\n{\r\nahd_mode_state saved_modes;\r\nint stepping;\r\nint steps;\r\nint first_instr;\r\nu_int simode0;\r\nu_int simode1;\r\nu_int simode3;\r\nu_int lqimode0;\r\nu_int lqimode1;\r\nu_int lqomode0;\r\nu_int lqomode1;\r\nif (ahd->num_critical_sections == 0)\r\nreturn;\r\nstepping = FALSE;\r\nsteps = 0;\r\nfirst_instr = 0;\r\nsimode0 = 0;\r\nsimode1 = 0;\r\nsimode3 = 0;\r\nlqimode0 = 0;\r\nlqimode1 = 0;\r\nlqomode0 = 0;\r\nlqomode1 = 0;\r\nsaved_modes = ahd_save_modes(ahd);\r\nfor (;;) {\r\nstruct cs *cs;\r\nu_int seqaddr;\r\nu_int i;\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nseqaddr = ahd_inw(ahd, CURADDR);\r\ncs = ahd->critical_sections;\r\nfor (i = 0; i < ahd->num_critical_sections; i++, cs++) {\r\nif (cs->begin < seqaddr && cs->end >= seqaddr)\r\nbreak;\r\n}\r\nif (i == ahd->num_critical_sections)\r\nbreak;\r\nif (steps > AHD_MAX_STEPS) {\r\nprintk("%s: Infinite loop in critical section\n"\r\n"%s: First Instruction 0x%x now 0x%x\n",\r\nahd_name(ahd), ahd_name(ahd), first_instr,\r\nseqaddr);\r\nahd_dump_card_state(ahd);\r\npanic("critical section loop");\r\n}\r\nsteps++;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("%s: Single stepping at 0x%x\n", ahd_name(ahd),\r\nseqaddr);\r\n#endif\r\nif (stepping == FALSE) {\r\nfirst_instr = seqaddr;\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nsimode0 = ahd_inb(ahd, SIMODE0);\r\nsimode3 = ahd_inb(ahd, SIMODE3);\r\nlqimode0 = ahd_inb(ahd, LQIMODE0);\r\nlqimode1 = ahd_inb(ahd, LQIMODE1);\r\nlqomode0 = ahd_inb(ahd, LQOMODE0);\r\nlqomode1 = ahd_inb(ahd, LQOMODE1);\r\nahd_outb(ahd, SIMODE0, 0);\r\nahd_outb(ahd, SIMODE3, 0);\r\nahd_outb(ahd, LQIMODE0, 0);\r\nahd_outb(ahd, LQIMODE1, 0);\r\nahd_outb(ahd, LQOMODE0, 0);\r\nahd_outb(ahd, LQOMODE1, 0);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nsimode1 = ahd_inb(ahd, SIMODE1);\r\nahd_outb(ahd, SIMODE1, simode1 & ENBUSFREE);\r\nahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) | STEP);\r\nstepping = TRUE;\r\n}\r\nahd_outb(ahd, CLRSINT1, CLRBUSFREE);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\nahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);\r\nahd_outb(ahd, HCNTRL, ahd->unpause);\r\nwhile (!ahd_is_paused(ahd))\r\nahd_delay(200);\r\nahd_update_modes(ahd);\r\n}\r\nif (stepping) {\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nahd_outb(ahd, SIMODE0, simode0);\r\nahd_outb(ahd, SIMODE3, simode3);\r\nahd_outb(ahd, LQIMODE0, lqimode0);\r\nahd_outb(ahd, LQIMODE1, lqimode1);\r\nahd_outb(ahd, LQOMODE0, lqomode0);\r\nahd_outb(ahd, LQOMODE1, lqomode1);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) & ~STEP);\r\nahd_outb(ahd, SIMODE1, simode1);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\n}\r\nahd_restore_modes(ahd, saved_modes);\r\n}\r\nstatic void\r\nahd_clear_intstat(struct ahd_softc *ahd)\r\n{\r\nAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\r\n~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\r\nahd_outb(ahd, CLRLQIINT0, CLRLQIATNQAS|CLRLQICRCT1|CLRLQICRCT2\r\n|CLRLQIBADLQT|CLRLQIATNLQ|CLRLQIATNCMD);\r\nahd_outb(ahd, CLRLQIINT1, CLRLQIPHASE_LQ|CLRLQIPHASE_NLQ|CLRLIQABORT\r\n|CLRLQICRCI_LQ|CLRLQICRCI_NLQ|CLRLQIBADLQI\r\n|CLRLQIOVERI_LQ|CLRLQIOVERI_NLQ|CLRNONPACKREQ);\r\nahd_outb(ahd, CLRLQOINT0, CLRLQOTARGSCBPERR|CLRLQOSTOPT2|CLRLQOATNLQ\r\n|CLRLQOATNPKT|CLRLQOTCRC);\r\nahd_outb(ahd, CLRLQOINT1, CLRLQOINITSCBPERR|CLRLQOSTOPI2|CLRLQOBADQAS\r\n|CLRLQOBUSFREE|CLRLQOPHACHGINPKT);\r\nif ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {\r\nahd_outb(ahd, CLRLQOINT0, 0);\r\nahd_outb(ahd, CLRLQOINT1, 0);\r\n}\r\nahd_outb(ahd, CLRSINT3, CLRNTRAMPERR|CLROSRAMPERR);\r\nahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\r\n|CLRBUSFREE|CLRSCSIPERR|CLRREQINIT);\r\nahd_outb(ahd, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO\r\n|CLRIOERR|CLROVERRUN);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\n}\r\nstatic struct ahd_tmode_tstate *\r\nahd_alloc_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel)\r\n{\r\nstruct ahd_tmode_tstate *master_tstate;\r\nstruct ahd_tmode_tstate *tstate;\r\nint i;\r\nmaster_tstate = ahd->enabled_targets[ahd->our_id];\r\nif (ahd->enabled_targets[scsi_id] != NULL\r\n&& ahd->enabled_targets[scsi_id] != master_tstate)\r\npanic("%s: ahd_alloc_tstate - Target already allocated",\r\nahd_name(ahd));\r\ntstate = kmalloc(sizeof(*tstate), GFP_ATOMIC);\r\nif (tstate == NULL)\r\nreturn (NULL);\r\nif (master_tstate != NULL) {\r\nmemcpy(tstate, master_tstate, sizeof(*tstate));\r\nmemset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));\r\nfor (i = 0; i < 16; i++) {\r\nmemset(&tstate->transinfo[i].curr, 0,\r\nsizeof(tstate->transinfo[i].curr));\r\nmemset(&tstate->transinfo[i].goal, 0,\r\nsizeof(tstate->transinfo[i].goal));\r\n}\r\n} else\r\nmemset(tstate, 0, sizeof(*tstate));\r\nahd->enabled_targets[scsi_id] = tstate;\r\nreturn (tstate);\r\n}\r\nstatic void\r\nahd_free_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel, int force)\r\n{\r\nstruct ahd_tmode_tstate *tstate;\r\nif (scsi_id == ahd->our_id\r\n&& force == FALSE)\r\nreturn;\r\ntstate = ahd->enabled_targets[scsi_id];\r\nif (tstate != NULL)\r\nkfree(tstate);\r\nahd->enabled_targets[scsi_id] = NULL;\r\n}\r\nstatic void\r\nahd_devlimited_syncrate(struct ahd_softc *ahd,\r\nstruct ahd_initiator_tinfo *tinfo,\r\nu_int *period, u_int *ppr_options, role_t role)\r\n{\r\nstruct ahd_transinfo *transinfo;\r\nu_int maxsync;\r\nif ((ahd_inb(ahd, SBLKCTL) & ENAB40) != 0\r\n&& (ahd_inb(ahd, SSTAT2) & EXP_ACTIVE) == 0) {\r\nmaxsync = AHD_SYNCRATE_PACED;\r\n} else {\r\nmaxsync = AHD_SYNCRATE_ULTRA;\r\n*ppr_options &= MSG_EXT_PPR_QAS_REQ;\r\n}\r\nif (role == ROLE_TARGET)\r\ntransinfo = &tinfo->user;\r\nelse\r\ntransinfo = &tinfo->goal;\r\n*ppr_options &= (transinfo->ppr_options|MSG_EXT_PPR_PCOMP_EN);\r\nif (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {\r\nmaxsync = max(maxsync, (u_int)AHD_SYNCRATE_ULTRA2);\r\n*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\r\n}\r\nif (transinfo->period == 0) {\r\n*period = 0;\r\n*ppr_options = 0;\r\n} else {\r\n*period = max(*period, (u_int)transinfo->period);\r\nahd_find_syncrate(ahd, period, ppr_options, maxsync);\r\n}\r\n}\r\nvoid\r\nahd_find_syncrate(struct ahd_softc *ahd, u_int *period,\r\nu_int *ppr_options, u_int maxsync)\r\n{\r\nif (*period < maxsync)\r\n*period = maxsync;\r\nif ((*ppr_options & MSG_EXT_PPR_DT_REQ) != 0\r\n&& *period > AHD_SYNCRATE_MIN_DT)\r\n*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\r\nif (*period > AHD_SYNCRATE_MIN)\r\n*period = 0;\r\nif (*period > AHD_SYNCRATE_PACED)\r\n*ppr_options &= ~MSG_EXT_PPR_RTI;\r\nif ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0)\r\n*ppr_options &= (MSG_EXT_PPR_DT_REQ|MSG_EXT_PPR_QAS_REQ);\r\nif ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0)\r\n*ppr_options &= MSG_EXT_PPR_QAS_REQ;\r\nif ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0\r\n&& *period < AHD_SYNCRATE_DT)\r\n*period = AHD_SYNCRATE_DT;\r\nif ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0\r\n&& *period < AHD_SYNCRATE_ULTRA2)\r\n*period = AHD_SYNCRATE_ULTRA2;\r\n}\r\nstatic void\r\nahd_validate_offset(struct ahd_softc *ahd,\r\nstruct ahd_initiator_tinfo *tinfo,\r\nu_int period, u_int *offset, int wide,\r\nrole_t role)\r\n{\r\nu_int maxoffset;\r\nif (period == 0)\r\nmaxoffset = 0;\r\nelse if (period <= AHD_SYNCRATE_PACED) {\r\nif ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0)\r\nmaxoffset = MAX_OFFSET_PACED_BUG;\r\nelse\r\nmaxoffset = MAX_OFFSET_PACED;\r\n} else\r\nmaxoffset = MAX_OFFSET_NON_PACED;\r\n*offset = min(*offset, maxoffset);\r\nif (tinfo != NULL) {\r\nif (role == ROLE_TARGET)\r\n*offset = min(*offset, (u_int)tinfo->user.offset);\r\nelse\r\n*offset = min(*offset, (u_int)tinfo->goal.offset);\r\n}\r\n}\r\nstatic void\r\nahd_validate_width(struct ahd_softc *ahd, struct ahd_initiator_tinfo *tinfo,\r\nu_int *bus_width, role_t role)\r\n{\r\nswitch (*bus_width) {\r\ndefault:\r\nif (ahd->features & AHD_WIDE) {\r\n*bus_width = MSG_EXT_WDTR_BUS_16_BIT;\r\nbreak;\r\n}\r\ncase MSG_EXT_WDTR_BUS_8_BIT:\r\n*bus_width = MSG_EXT_WDTR_BUS_8_BIT;\r\nbreak;\r\n}\r\nif (tinfo != NULL) {\r\nif (role == ROLE_TARGET)\r\n*bus_width = min((u_int)tinfo->user.width, *bus_width);\r\nelse\r\n*bus_width = min((u_int)tinfo->goal.width, *bus_width);\r\n}\r\n}\r\nint\r\nahd_update_neg_request(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nstruct ahd_tmode_tstate *tstate,\r\nstruct ahd_initiator_tinfo *tinfo, ahd_neg_type neg_type)\r\n{\r\nu_int auto_negotiate_orig;\r\nauto_negotiate_orig = tstate->auto_negotiate;\r\nif (neg_type == AHD_NEG_ALWAYS) {\r\nif ((ahd->features & AHD_WIDE) != 0)\r\ntinfo->curr.width = AHD_WIDTH_UNKNOWN;\r\ntinfo->curr.period = AHD_PERIOD_UNKNOWN;\r\ntinfo->curr.offset = AHD_OFFSET_UNKNOWN;\r\n}\r\nif (tinfo->curr.period != tinfo->goal.period\r\n|| tinfo->curr.width != tinfo->goal.width\r\n|| tinfo->curr.offset != tinfo->goal.offset\r\n|| tinfo->curr.ppr_options != tinfo->goal.ppr_options\r\n|| (neg_type == AHD_NEG_IF_NON_ASYNC\r\n&& (tinfo->goal.offset != 0\r\n|| tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT\r\n|| tinfo->goal.ppr_options != 0)))\r\ntstate->auto_negotiate |= devinfo->target_mask;\r\nelse\r\ntstate->auto_negotiate &= ~devinfo->target_mask;\r\nreturn (auto_negotiate_orig != tstate->auto_negotiate);\r\n}\r\nvoid\r\nahd_set_syncrate(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nu_int period, u_int offset, u_int ppr_options,\r\nu_int type, int paused)\r\n{\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nu_int old_period;\r\nu_int old_offset;\r\nu_int old_ppr;\r\nint active;\r\nint update_needed;\r\nactive = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;\r\nupdate_needed = 0;\r\nif (period == 0 || offset == 0) {\r\nperiod = 0;\r\noffset = 0;\r\n}\r\ntinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nif ((type & AHD_TRANS_USER) != 0) {\r\ntinfo->user.period = period;\r\ntinfo->user.offset = offset;\r\ntinfo->user.ppr_options = ppr_options;\r\n}\r\nif ((type & AHD_TRANS_GOAL) != 0) {\r\ntinfo->goal.period = period;\r\ntinfo->goal.offset = offset;\r\ntinfo->goal.ppr_options = ppr_options;\r\n}\r\nold_period = tinfo->curr.period;\r\nold_offset = tinfo->curr.offset;\r\nold_ppr = tinfo->curr.ppr_options;\r\nif ((type & AHD_TRANS_CUR) != 0\r\n&& (old_period != period\r\n|| old_offset != offset\r\n|| old_ppr != ppr_options)) {\r\nupdate_needed++;\r\ntinfo->curr.period = period;\r\ntinfo->curr.offset = offset;\r\ntinfo->curr.ppr_options = ppr_options;\r\nahd_send_async(ahd, devinfo->channel, devinfo->target,\r\nCAM_LUN_WILDCARD, AC_TRANSFER_NEG);\r\nif (bootverbose) {\r\nif (offset != 0) {\r\nint options;\r\nprintk("%s: target %d synchronous with "\r\n"period = 0x%x, offset = 0x%x",\r\nahd_name(ahd), devinfo->target,\r\nperiod, offset);\r\noptions = 0;\r\nif ((ppr_options & MSG_EXT_PPR_RD_STRM) != 0) {\r\nprintk("(RDSTRM");\r\noptions++;\r\n}\r\nif ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {\r\nprintk("%s", options ? "|DT" : "(DT");\r\noptions++;\r\n}\r\nif ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\r\nprintk("%s", options ? "|IU" : "(IU");\r\noptions++;\r\n}\r\nif ((ppr_options & MSG_EXT_PPR_RTI) != 0) {\r\nprintk("%s", options ? "|RTI" : "(RTI");\r\noptions++;\r\n}\r\nif ((ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {\r\nprintk("%s", options ? "|QAS" : "(QAS");\r\noptions++;\r\n}\r\nif (options != 0)\r\nprintk(")\n");\r\nelse\r\nprintk("\n");\r\n} else {\r\nprintk("%s: target %d using "\r\n"asynchronous transfers%s\n",\r\nahd_name(ahd), devinfo->target,\r\n(ppr_options & MSG_EXT_PPR_QAS_REQ) != 0\r\n? "(QAS)" : "");\r\n}\r\n}\r\n}\r\nif ((type & AHD_TRANS_CUR) != 0) {\r\nif (!paused)\r\nahd_pause(ahd);\r\nahd_update_neg_table(ahd, devinfo, &tinfo->curr);\r\nif (!paused)\r\nahd_unpause(ahd);\r\nif (ahd->msg_type != MSG_TYPE_NONE) {\r\nif ((old_ppr & MSG_EXT_PPR_IU_REQ)\r\n!= (ppr_options & MSG_EXT_PPR_IU_REQ)) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\r\nahd_print_devinfo(ahd, devinfo);\r\nprintk("Expecting IU Change busfree\n");\r\n}\r\n#endif\r\nahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE\r\n| MSG_FLAG_IU_REQ_CHANGED;\r\n}\r\nif ((old_ppr & MSG_EXT_PPR_IU_REQ) != 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("PPR with IU_REQ outstanding\n");\r\n#endif\r\nahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE;\r\n}\r\n}\r\n}\r\nupdate_needed += ahd_update_neg_request(ahd, devinfo, tstate,\r\ntinfo, AHD_NEG_TO_GOAL);\r\nif (update_needed && active)\r\nahd_update_pending_scbs(ahd);\r\n}\r\nvoid\r\nahd_set_width(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nu_int width, u_int type, int paused)\r\n{\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nu_int oldwidth;\r\nint active;\r\nint update_needed;\r\nactive = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;\r\nupdate_needed = 0;\r\ntinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nif ((type & AHD_TRANS_USER) != 0)\r\ntinfo->user.width = width;\r\nif ((type & AHD_TRANS_GOAL) != 0)\r\ntinfo->goal.width = width;\r\noldwidth = tinfo->curr.width;\r\nif ((type & AHD_TRANS_CUR) != 0 && oldwidth != width) {\r\nupdate_needed++;\r\ntinfo->curr.width = width;\r\nahd_send_async(ahd, devinfo->channel, devinfo->target,\r\nCAM_LUN_WILDCARD, AC_TRANSFER_NEG);\r\nif (bootverbose) {\r\nprintk("%s: target %d using %dbit transfers\n",\r\nahd_name(ahd), devinfo->target,\r\n8 * (0x01 << width));\r\n}\r\n}\r\nif ((type & AHD_TRANS_CUR) != 0) {\r\nif (!paused)\r\nahd_pause(ahd);\r\nahd_update_neg_table(ahd, devinfo, &tinfo->curr);\r\nif (!paused)\r\nahd_unpause(ahd);\r\n}\r\nupdate_needed += ahd_update_neg_request(ahd, devinfo, tstate,\r\ntinfo, AHD_NEG_TO_GOAL);\r\nif (update_needed && active)\r\nahd_update_pending_scbs(ahd);\r\n}\r\nstatic void\r\nahd_set_tags(struct ahd_softc *ahd, struct scsi_cmnd *cmd,\r\nstruct ahd_devinfo *devinfo, ahd_queue_alg alg)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nahd_platform_set_tags(ahd, sdev, devinfo, alg);\r\nahd_send_async(ahd, devinfo->channel, devinfo->target,\r\ndevinfo->lun, AC_TRANSFER_NEG);\r\n}\r\nstatic void\r\nahd_update_neg_table(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nstruct ahd_transinfo *tinfo)\r\n{\r\nahd_mode_state saved_modes;\r\nu_int period;\r\nu_int ppr_opts;\r\nu_int con_opts;\r\nu_int offset;\r\nu_int saved_negoaddr;\r\nuint8_t iocell_opts[sizeof(ahd->iocell_opts)];\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nsaved_negoaddr = ahd_inb(ahd, NEGOADDR);\r\nahd_outb(ahd, NEGOADDR, devinfo->target);\r\nperiod = tinfo->period;\r\noffset = tinfo->offset;\r\nmemcpy(iocell_opts, ahd->iocell_opts, sizeof(ahd->iocell_opts));\r\nppr_opts = tinfo->ppr_options & (MSG_EXT_PPR_QAS_REQ|MSG_EXT_PPR_DT_REQ\r\n|MSG_EXT_PPR_IU_REQ|MSG_EXT_PPR_RTI);\r\ncon_opts = 0;\r\nif (period == 0)\r\nperiod = AHD_SYNCRATE_ASYNC;\r\nif (period == AHD_SYNCRATE_160) {\r\nif ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0) {\r\nppr_opts |= PPROPT_PACE;\r\noffset *= 2;\r\nperiod = AHD_SYNCRATE_REVA_160;\r\n}\r\nif ((tinfo->ppr_options & MSG_EXT_PPR_PCOMP_EN) == 0)\r\niocell_opts[AHD_PRECOMP_SLEW_INDEX] &=\r\n~AHD_PRECOMP_MASK;\r\n} else {\r\niocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;\r\nif ((ahd->features & AHD_NEW_IOCELL_OPTS) != 0\r\n&& (ppr_opts & MSG_EXT_PPR_DT_REQ) != 0\r\n&& (ppr_opts & MSG_EXT_PPR_IU_REQ) == 0) {\r\ncon_opts |= ENSLOWCRC;\r\n}\r\nif ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0) {\r\niocell_opts[AHD_PRECOMP_SLEW_INDEX] &=\r\n~AHD_SLEWRATE_MASK;\r\n}\r\n}\r\nahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PRECOMP_SLEW);\r\nahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_PRECOMP_SLEW_INDEX]);\r\nahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_AMPLITUDE);\r\nahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_AMPLITUDE_INDEX]);\r\nahd_outb(ahd, NEGPERIOD, period);\r\nahd_outb(ahd, NEGPPROPTS, ppr_opts);\r\nahd_outb(ahd, NEGOFFSET, offset);\r\nif (tinfo->width == MSG_EXT_WDTR_BUS_16_BIT)\r\ncon_opts |= WIDEXFER;\r\nif (ahd->features & AHD_AIC79XXB_SLOWCRC) {\r\ncon_opts |= ENSLOWCRC;\r\n}\r\nif ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) == 0)\r\ncon_opts |= ENAUTOATNO;\r\nahd_outb(ahd, NEGCONOPTS, con_opts);\r\nahd_outb(ahd, NEGOADDR, saved_negoaddr);\r\nahd_restore_modes(ahd, saved_modes);\r\n}\r\nstatic void\r\nahd_update_pending_scbs(struct ahd_softc *ahd)\r\n{\r\nstruct scb *pending_scb;\r\nint pending_scb_count;\r\nint paused;\r\nu_int saved_scbptr;\r\nahd_mode_state saved_modes;\r\npending_scb_count = 0;\r\nLIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nahd_scb_devinfo(ahd, &devinfo, pending_scb);\r\ntinfo = ahd_fetch_transinfo(ahd, devinfo.channel,\r\ndevinfo.our_scsiid,\r\ndevinfo.target, &tstate);\r\nif ((tstate->auto_negotiate & devinfo.target_mask) == 0\r\n&& (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {\r\npending_scb->flags &= ~SCB_AUTO_NEGOTIATE;\r\npending_scb->hscb->control &= ~MK_MESSAGE;\r\n}\r\nahd_sync_scb(ahd, pending_scb,\r\nBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\npending_scb_count++;\r\n}\r\nif (pending_scb_count == 0)\r\nreturn;\r\nif (ahd_is_paused(ahd)) {\r\npaused = 1;\r\n} else {\r\npaused = 0;\r\nahd_pause(ahd);\r\n}\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nif ((ahd_inb(ahd, SCSISIGI) & BSYI) != 0\r\n&& (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) == 0)\r\nahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);\r\nsaved_scbptr = ahd_get_scbptr(ahd);\r\nLIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {\r\nu_int scb_tag;\r\nu_int control;\r\nscb_tag = SCB_GET_TAG(pending_scb);\r\nahd_set_scbptr(ahd, scb_tag);\r\ncontrol = ahd_inb_scbram(ahd, SCB_CONTROL);\r\ncontrol &= ~MK_MESSAGE;\r\ncontrol |= pending_scb->hscb->control & MK_MESSAGE;\r\nahd_outb(ahd, SCB_CONTROL, control);\r\n}\r\nahd_set_scbptr(ahd, saved_scbptr);\r\nahd_restore_modes(ahd, saved_modes);\r\nif (paused == 0)\r\nahd_unpause(ahd);\r\n}\r\nstatic void\r\nahd_fetch_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nahd_mode_state saved_modes;\r\nu_int saved_scsiid;\r\nrole_t role;\r\nint our_id;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nif (ahd_inb(ahd, SSTAT0) & TARGET)\r\nrole = ROLE_TARGET;\r\nelse\r\nrole = ROLE_INITIATOR;\r\nif (role == ROLE_TARGET\r\n&& (ahd_inb(ahd, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {\r\nour_id = ahd_inb(ahd, TARGIDIN) & OID;\r\n} else if (role == ROLE_TARGET)\r\nour_id = ahd_inb(ahd, TOWNID);\r\nelse\r\nour_id = ahd_inb(ahd, IOWNID);\r\nsaved_scsiid = ahd_inb(ahd, SAVED_SCSIID);\r\nahd_compile_devinfo(devinfo,\r\nour_id,\r\nSCSIID_TARGET(ahd, saved_scsiid),\r\nahd_inb(ahd, SAVED_LUN),\r\nSCSIID_CHANNEL(ahd, saved_scsiid),\r\nrole);\r\nahd_restore_modes(ahd, saved_modes);\r\n}\r\nvoid\r\nahd_print_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nprintk("%s:%c:%d:%d: ", ahd_name(ahd), 'A',\r\ndevinfo->target, devinfo->lun);\r\n}\r\nstatic const struct ahd_phase_table_entry*\r\nahd_lookup_phase_entry(int phase)\r\n{\r\nconst struct ahd_phase_table_entry *entry;\r\nconst struct ahd_phase_table_entry *last_entry;\r\nlast_entry = &ahd_phase_table[num_phases];\r\nfor (entry = ahd_phase_table; entry < last_entry; entry++) {\r\nif (phase == entry->phase)\r\nbreak;\r\n}\r\nreturn (entry);\r\n}\r\nvoid\r\nahd_compile_devinfo(struct ahd_devinfo *devinfo, u_int our_id, u_int target,\r\nu_int lun, char channel, role_t role)\r\n{\r\ndevinfo->our_scsiid = our_id;\r\ndevinfo->target = target;\r\ndevinfo->lun = lun;\r\ndevinfo->target_offset = target;\r\ndevinfo->channel = channel;\r\ndevinfo->role = role;\r\nif (channel == 'B')\r\ndevinfo->target_offset += 8;\r\ndevinfo->target_mask = (0x01 << devinfo->target_offset);\r\n}\r\nstatic void\r\nahd_scb_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nstruct scb *scb)\r\n{\r\nrole_t role;\r\nint our_id;\r\nour_id = SCSIID_OUR_ID(scb->hscb->scsiid);\r\nrole = ROLE_INITIATOR;\r\nif ((scb->hscb->control & TARGET_SCB) != 0)\r\nrole = ROLE_TARGET;\r\nahd_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahd, scb),\r\nSCB_GET_LUN(scb), SCB_GET_CHANNEL(ahd, scb), role);\r\n}\r\nstatic void\r\nahd_setup_initiator_msgout(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nstruct scb *scb)\r\n{\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nif (ahd_currently_packetized(ahd))\r\nahd->msg_flags |= MSG_FLAG_PACKETIZED;\r\nif (ahd->send_msg_perror\r\n&& ahd_inb(ahd, MSG_OUT) == HOST_MSG) {\r\nahd->msgout_buf[ahd->msgout_index++] = ahd->send_msg_perror;\r\nahd->msgout_len++;\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("Setting up for Parity Error delivery\n");\r\n#endif\r\nreturn;\r\n} else if (scb == NULL) {\r\nprintk("%s: WARNING. No pending message for "\r\n"I_T msgin. Issuing NO-OP\n", ahd_name(ahd));\r\nahd->msgout_buf[ahd->msgout_index++] = MSG_NOOP;\r\nahd->msgout_len++;\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\nreturn;\r\n}\r\nif ((scb->flags & SCB_DEVICE_RESET) == 0\r\n&& (scb->flags & SCB_PACKETIZED) == 0\r\n&& ahd_inb(ahd, MSG_OUT) == MSG_IDENTIFYFLAG) {\r\nu_int identify_msg;\r\nidentify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);\r\nif ((scb->hscb->control & DISCENB) != 0)\r\nidentify_msg |= MSG_IDENTIFY_DISCFLAG;\r\nahd->msgout_buf[ahd->msgout_index++] = identify_msg;\r\nahd->msgout_len++;\r\nif ((scb->hscb->control & TAG_ENB) != 0) {\r\nahd->msgout_buf[ahd->msgout_index++] =\r\nscb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);\r\nahd->msgout_buf[ahd->msgout_index++] = SCB_GET_TAG(scb);\r\nahd->msgout_len += 2;\r\n}\r\n}\r\nif (scb->flags & SCB_DEVICE_RESET) {\r\nahd->msgout_buf[ahd->msgout_index++] = MSG_BUS_DEV_RESET;\r\nahd->msgout_len++;\r\nahd_print_path(ahd, scb);\r\nprintk("Bus Device Reset Message Sent\n");\r\nahd_outb(ahd, SCSISEQ0, 0);\r\n} else if ((scb->flags & SCB_ABORT) != 0) {\r\nif ((scb->hscb->control & TAG_ENB) != 0) {\r\nahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT_TAG;\r\n} else {\r\nahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT;\r\n}\r\nahd->msgout_len++;\r\nahd_print_path(ahd, scb);\r\nprintk("Abort%s Message Sent\n",\r\n(scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");\r\nahd_outb(ahd, SCSISEQ0, 0);\r\n} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {\r\nahd_build_transfer_msg(ahd, devinfo);\r\nahd_outb(ahd, SCSISEQ0, 0);\r\n} else {\r\nprintk("ahd_intr: AWAITING_MSG for an SCB that "\r\n"does not have a waiting message\n");\r\nprintk("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,\r\ndevinfo->target_mask);\r\npanic("SCB = %d, SCB Control = %x:%x, MSG_OUT = %x "\r\n"SCB flags = %x", SCB_GET_TAG(scb), scb->hscb->control,\r\nahd_inb_scbram(ahd, SCB_CONTROL), ahd_inb(ahd, MSG_OUT),\r\nscb->flags);\r\n}\r\nahd_outb(ahd, SCB_CONTROL,\r\nahd_inb_scbram(ahd, SCB_CONTROL) & ~MK_MESSAGE);\r\nscb->hscb->control &= ~MK_MESSAGE;\r\nahd->msgout_index = 0;\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\n}\r\nstatic void\r\nahd_build_transfer_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nint dowide;\r\nint dosync;\r\nint doppr;\r\nu_int period;\r\nu_int ppr_options;\r\nu_int offset;\r\ntinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nperiod = tinfo->goal.period;\r\noffset = tinfo->goal.offset;\r\nppr_options = tinfo->goal.ppr_options;\r\nif (devinfo->role == ROLE_TARGET)\r\nppr_options = 0;\r\nahd_devlimited_syncrate(ahd, tinfo, &period,\r\n&ppr_options, devinfo->role);\r\ndowide = tinfo->curr.width != tinfo->goal.width;\r\ndosync = tinfo->curr.offset != offset || tinfo->curr.period != period;\r\ndoppr = ppr_options != 0;\r\nif (!dowide && !dosync && !doppr) {\r\ndowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\r\ndosync = tinfo->goal.offset != 0;\r\n}\r\nif (!dowide && !dosync && !doppr) {\r\nif ((ahd->features & AHD_WIDE) != 0)\r\ndowide = 1;\r\nelse\r\ndosync = 1;\r\nif (bootverbose) {\r\nahd_print_devinfo(ahd, devinfo);\r\nprintk("Ensuring async\n");\r\n}\r\n}\r\nif (devinfo->role == ROLE_TARGET)\r\ndoppr = 0;\r\nif (doppr || (dosync && !dowide)) {\r\noffset = tinfo->goal.offset;\r\nahd_validate_offset(ahd, tinfo, period, &offset,\r\ndoppr ? tinfo->goal.width\r\n: tinfo->curr.width,\r\ndevinfo->role);\r\nif (doppr) {\r\nahd_construct_ppr(ahd, devinfo, period, offset,\r\ntinfo->goal.width, ppr_options);\r\n} else {\r\nahd_construct_sdtr(ahd, devinfo, period, offset);\r\n}\r\n} else {\r\nahd_construct_wdtr(ahd, devinfo, tinfo->goal.width);\r\n}\r\n}\r\nstatic void\r\nahd_construct_sdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nu_int period, u_int offset)\r\n{\r\nif (offset == 0)\r\nperiod = AHD_ASYNC_XFER_PERIOD;\r\nahd->msgout_index += spi_populate_sync_msg(\r\nahd->msgout_buf + ahd->msgout_index, period, offset);\r\nahd->msgout_len += 5;\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",\r\nahd_name(ahd), devinfo->channel, devinfo->target,\r\ndevinfo->lun, period, offset);\r\n}\r\n}\r\nstatic void\r\nahd_construct_wdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nu_int bus_width)\r\n{\r\nahd->msgout_index += spi_populate_width_msg(\r\nahd->msgout_buf + ahd->msgout_index, bus_width);\r\nahd->msgout_len += 4;\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Sending WDTR %x\n",\r\nahd_name(ahd), devinfo->channel, devinfo->target,\r\ndevinfo->lun, bus_width);\r\n}\r\n}\r\nstatic void\r\nahd_construct_ppr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nu_int period, u_int offset, u_int bus_width,\r\nu_int ppr_options)\r\n{\r\nif (period <= AHD_SYNCRATE_PACED)\r\nppr_options |= MSG_EXT_PPR_PCOMP_EN;\r\nif (offset == 0)\r\nperiod = AHD_ASYNC_XFER_PERIOD;\r\nahd->msgout_index += spi_populate_ppr_msg(\r\nahd->msgout_buf + ahd->msgout_index, period, offset,\r\nbus_width, ppr_options);\r\nahd->msgout_len += 8;\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "\r\n"offset %x, ppr_options %x\n", ahd_name(ahd),\r\ndevinfo->channel, devinfo->target, devinfo->lun,\r\nbus_width, period, offset, ppr_options);\r\n}\r\n}\r\nstatic void\r\nahd_clear_msg_state(struct ahd_softc *ahd)\r\n{\r\nahd_mode_state saved_modes;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd->send_msg_perror = 0;\r\nahd->msg_flags = MSG_FLAG_NONE;\r\nahd->msgout_len = 0;\r\nahd->msgin_index = 0;\r\nahd->msg_type = MSG_TYPE_NONE;\r\nif ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {\r\nahd_outb(ahd, CLRSINT1, CLRATNO);\r\n}\r\nahd_outb(ahd, MSG_OUT, MSG_NOOP);\r\nahd_outb(ahd, SEQ_FLAGS2,\r\nahd_inb(ahd, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);\r\nahd_restore_modes(ahd, saved_modes);\r\n}\r\nstatic void\r\nahd_handle_message_phase(struct ahd_softc *ahd)\r\n{\r\nstruct ahd_devinfo devinfo;\r\nu_int bus_phase;\r\nint end_session;\r\nahd_fetch_devinfo(ahd, &devinfo);\r\nend_session = FALSE;\r\nbus_phase = ahd_inb(ahd, LASTPHASE);\r\nif ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0) {\r\nprintk("LQIRETRY for LQIPHASE_OUTPKT\n");\r\nahd_outb(ahd, LQCTL2, LQIRETRY);\r\n}\r\nreswitch:\r\nswitch (ahd->msg_type) {\r\ncase MSG_TYPE_INITIATOR_MSGOUT:\r\n{\r\nint lastbyte;\r\nint phasemis;\r\nint msgdone;\r\nif (ahd->msgout_len == 0 && ahd->send_msg_perror == 0)\r\npanic("HOST_MSG_LOOP interrupt with no active message");\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\r\nahd_print_devinfo(ahd, &devinfo);\r\nprintk("INITIATOR_MSG_OUT");\r\n}\r\n#endif\r\nphasemis = bus_phase != P_MESGOUT;\r\nif (phasemis) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\r\nprintk(" PHASEMIS %s\n",\r\nahd_lookup_phase_entry(bus_phase)\r\n->phasemsg);\r\n}\r\n#endif\r\nif (bus_phase == P_MESGIN) {\r\nahd_outb(ahd, CLRSINT1, CLRATNO);\r\nahd->send_msg_perror = 0;\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGIN;\r\nahd->msgin_index = 0;\r\ngoto reswitch;\r\n}\r\nend_session = TRUE;\r\nbreak;\r\n}\r\nif (ahd->send_msg_perror) {\r\nahd_outb(ahd, CLRSINT1, CLRATNO);\r\nahd_outb(ahd, CLRSINT1, CLRREQINIT);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk(" byte 0x%x\n", ahd->send_msg_perror);\r\n#endif\r\nif ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0\r\n&& ahd->send_msg_perror == MSG_INITIATOR_DET_ERR)\r\nahd->msg_flags |= MSG_FLAG_EXPECT_IDE_BUSFREE;\r\nahd_outb(ahd, RETURN_2, ahd->send_msg_perror);\r\nahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);\r\nbreak;\r\n}\r\nmsgdone = ahd->msgout_index == ahd->msgout_len;\r\nif (msgdone) {\r\nahd->msgout_index = 0;\r\nahd_assert_atn(ahd);\r\n}\r\nlastbyte = ahd->msgout_index == (ahd->msgout_len - 1);\r\nif (lastbyte) {\r\nahd_outb(ahd, CLRSINT1, CLRATNO);\r\n}\r\nahd_outb(ahd, CLRSINT1, CLRREQINIT);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk(" byte 0x%x\n",\r\nahd->msgout_buf[ahd->msgout_index]);\r\n#endif\r\nahd_outb(ahd, RETURN_2, ahd->msgout_buf[ahd->msgout_index++]);\r\nahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);\r\nbreak;\r\n}\r\ncase MSG_TYPE_INITIATOR_MSGIN:\r\n{\r\nint phasemis;\r\nint message_done;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\r\nahd_print_devinfo(ahd, &devinfo);\r\nprintk("INITIATOR_MSG_IN");\r\n}\r\n#endif\r\nphasemis = bus_phase != P_MESGIN;\r\nif (phasemis) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\r\nprintk(" PHASEMIS %s\n",\r\nahd_lookup_phase_entry(bus_phase)\r\n->phasemsg);\r\n}\r\n#endif\r\nahd->msgin_index = 0;\r\nif (bus_phase == P_MESGOUT\r\n&& (ahd->send_msg_perror != 0\r\n|| (ahd->msgout_len != 0\r\n&& ahd->msgout_index == 0))) {\r\nahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\ngoto reswitch;\r\n}\r\nend_session = TRUE;\r\nbreak;\r\n}\r\nahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIBUS);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk(" byte 0x%x\n",\r\nahd->msgin_buf[ahd->msgin_index]);\r\n#endif\r\nmessage_done = ahd_parse_msg(ahd, &devinfo);\r\nif (message_done) {\r\nahd->msgin_index = 0;\r\nif (ahd->msgout_len != 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {\r\nahd_print_devinfo(ahd, &devinfo);\r\nprintk("Asserting ATN for response\n");\r\n}\r\n#endif\r\nahd_assert_atn(ahd);\r\n}\r\n} else\r\nahd->msgin_index++;\r\nif (message_done == MSGLOOP_TERMINATED) {\r\nend_session = TRUE;\r\n} else {\r\nahd_outb(ahd, CLRSINT1, CLRREQINIT);\r\nahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_READ);\r\n}\r\nbreak;\r\n}\r\ncase MSG_TYPE_TARGET_MSGIN:\r\n{\r\nint msgdone;\r\nint msgout_request;\r\nahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);\r\nif (ahd->msgout_len == 0)\r\npanic("Target MSGIN with no active message");\r\nif ((ahd_inb(ahd, SCSISIGI) & ATNI) != 0\r\n&& ahd->msgout_index > 0)\r\nmsgout_request = TRUE;\r\nelse\r\nmsgout_request = FALSE;\r\nif (msgout_request) {\r\nahd->msg_type = MSG_TYPE_TARGET_MSGOUT;\r\nahd_outb(ahd, SCSISIGO, P_MESGOUT | BSYO);\r\nahd->msgin_index = 0;\r\nahd_inb(ahd, SCSIDAT);\r\nahd_outb(ahd, SXFRCTL0,\r\nahd_inb(ahd, SXFRCTL0) | SPIOEN);\r\nbreak;\r\n}\r\nmsgdone = ahd->msgout_index == ahd->msgout_len;\r\nif (msgdone) {\r\nahd_outb(ahd, SXFRCTL0,\r\nahd_inb(ahd, SXFRCTL0) & ~SPIOEN);\r\nend_session = TRUE;\r\nbreak;\r\n}\r\nahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) | SPIOEN);\r\nahd_outb(ahd, SCSIDAT, ahd->msgout_buf[ahd->msgout_index++]);\r\nbreak;\r\n}\r\ncase MSG_TYPE_TARGET_MSGOUT:\r\n{\r\nint lastbyte;\r\nint msgdone;\r\nahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);\r\nlastbyte = (ahd_inb(ahd, SCSISIGI) & ATNI) == 0;\r\nahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);\r\nahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIDAT);\r\nmsgdone = ahd_parse_msg(ahd, &devinfo);\r\nif (msgdone == MSGLOOP_TERMINATED) {\r\nreturn;\r\n}\r\nahd->msgin_index++;\r\nif (msgdone == MSGLOOP_MSGCOMPLETE) {\r\nahd->msgin_index = 0;\r\nif (ahd->msgout_len != 0) {\r\nahd_outb(ahd, SCSISIGO, P_MESGIN | BSYO);\r\nahd_outb(ahd, SXFRCTL0,\r\nahd_inb(ahd, SXFRCTL0) | SPIOEN);\r\nahd->msg_type = MSG_TYPE_TARGET_MSGIN;\r\nahd->msgin_index = 0;\r\nbreak;\r\n}\r\n}\r\nif (lastbyte)\r\nend_session = TRUE;\r\nelse {\r\nahd_outb(ahd, SXFRCTL0,\r\nahd_inb(ahd, SXFRCTL0) | SPIOEN);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\npanic("Unknown REQINIT message type");\r\n}\r\nif (end_session) {\r\nif ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0) {\r\nprintk("%s: Returning to Idle Loop\n",\r\nahd_name(ahd));\r\nahd_clear_msg_state(ahd);\r\nahd_outb(ahd, LASTPHASE, P_BUSFREE);\r\nahd_outb(ahd, SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT);\r\nahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);\r\n} else {\r\nahd_clear_msg_state(ahd);\r\nahd_outb(ahd, RETURN_1, EXIT_MSG_LOOP);\r\n}\r\n}\r\n}\r\nstatic int\r\nahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type, u_int msgval, int full)\r\n{\r\nint found;\r\nu_int index;\r\nfound = FALSE;\r\nindex = 0;\r\nwhile (index < ahd->msgout_len) {\r\nif (ahd->msgout_buf[index] == MSG_EXTENDED) {\r\nu_int end_index;\r\nend_index = index + 1 + ahd->msgout_buf[index + 1];\r\nif (ahd->msgout_buf[index+2] == msgval\r\n&& type == AHDMSG_EXT) {\r\nif (full) {\r\nif (ahd->msgout_index > end_index)\r\nfound = TRUE;\r\n} else if (ahd->msgout_index > index)\r\nfound = TRUE;\r\n}\r\nindex = end_index;\r\n} else if (ahd->msgout_buf[index] >= MSG_SIMPLE_TASK\r\n&& ahd->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\r\nindex += 2;\r\n} else {\r\nif (type == AHDMSG_1B\r\n&& ahd->msgout_index > index\r\n&& (ahd->msgout_buf[index] == msgval\r\n|| ((ahd->msgout_buf[index] & MSG_IDENTIFYFLAG) != 0\r\n&& msgval == MSG_IDENTIFYFLAG)))\r\nfound = TRUE;\r\nindex++;\r\n}\r\nif (found)\r\nbreak;\r\n}\r\nreturn (found);\r\n}\r\nstatic int\r\nahd_parse_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nint reject;\r\nint done;\r\nint response;\r\ndone = MSGLOOP_IN_PROG;\r\nresponse = FALSE;\r\nreject = FALSE;\r\ntinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nswitch (ahd->msgin_buf[0]) {\r\ncase MSG_DISCONNECT:\r\ncase MSG_SAVEDATAPOINTER:\r\ncase MSG_CMDCOMPLETE:\r\ncase MSG_RESTOREPOINTERS:\r\ncase MSG_IGN_WIDE_RESIDUE:\r\ndone = MSGLOOP_TERMINATED;\r\nbreak;\r\ncase MSG_MESSAGE_REJECT:\r\nresponse = ahd_handle_msg_reject(ahd, devinfo);\r\ncase MSG_NOOP:\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\ncase MSG_EXTENDED:\r\n{\r\nif (ahd->msgin_index < 2)\r\nbreak;\r\nswitch (ahd->msgin_buf[2]) {\r\ncase MSG_EXT_SDTR:\r\n{\r\nu_int period;\r\nu_int ppr_options;\r\nu_int offset;\r\nu_int saved_offset;\r\nif (ahd->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (ahd->msgin_index < (MSG_EXT_SDTR_LEN + 1))\r\nbreak;\r\nperiod = ahd->msgin_buf[3];\r\nppr_options = 0;\r\nsaved_offset = offset = ahd->msgin_buf[4];\r\nahd_devlimited_syncrate(ahd, tinfo, &period,\r\n&ppr_options, devinfo->role);\r\nahd_validate_offset(ahd, tinfo, period, &offset,\r\ntinfo->curr.width, devinfo->role);\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Received "\r\n"SDTR period %x, offset %x\n\t"\r\n"Filtered to period %x, offset %x\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\nahd->msgin_buf[3], saved_offset,\r\nperiod, offset);\r\n}\r\nahd_set_syncrate(ahd, devinfo, period,\r\noffset, ppr_options,\r\nAHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\r\nTRUE);\r\nif (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, TRUE)) {\r\nif (saved_offset != offset) {\r\nreject = TRUE;\r\n}\r\n} else {\r\nif (bootverbose\r\n&& devinfo->role == ROLE_INITIATOR) {\r\nprintk("(%s:%c:%d:%d): Target "\r\n"Initiated SDTR\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nahd_construct_sdtr(ahd, devinfo,\r\nperiod, offset);\r\nahd->msgout_index = 0;\r\nresponse = TRUE;\r\n}\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\n}\r\ncase MSG_EXT_WDTR:\r\n{\r\nu_int bus_width;\r\nu_int saved_width;\r\nu_int sending_reply;\r\nsending_reply = FALSE;\r\nif (ahd->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (ahd->msgin_index < (MSG_EXT_WDTR_LEN + 1))\r\nbreak;\r\nbus_width = ahd->msgin_buf[3];\r\nsaved_width = bus_width;\r\nahd_validate_width(ahd, tinfo, &bus_width,\r\ndevinfo->role);\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Received WDTR "\r\n"%x filtered to %x\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\nsaved_width, bus_width);\r\n}\r\nif (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, TRUE)) {\r\nif (saved_width > bus_width) {\r\nreject = TRUE;\r\nprintk("(%s:%c:%d:%d): requested %dBit "\r\n"transfers. Rejecting...\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\n8 * (0x01 << bus_width));\r\nbus_width = 0;\r\n}\r\n} else {\r\nif (bootverbose\r\n&& devinfo->role == ROLE_INITIATOR) {\r\nprintk("(%s:%c:%d:%d): Target "\r\n"Initiated WDTR\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nahd_construct_wdtr(ahd, devinfo, bus_width);\r\nahd->msgout_index = 0;\r\nresponse = TRUE;\r\nsending_reply = TRUE;\r\n}\r\nahd_update_neg_request(ahd, devinfo, tstate,\r\ntinfo, AHD_NEG_ALWAYS);\r\nahd_set_width(ahd, devinfo, bus_width,\r\nAHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\r\nTRUE);\r\nif (sending_reply == FALSE && reject == FALSE) {\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nahd_build_transfer_msg(ahd, devinfo);\r\nahd->msgout_index = 0;\r\nresponse = TRUE;\r\n}\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\n}\r\ncase MSG_EXT_PPR:\r\n{\r\nu_int period;\r\nu_int offset;\r\nu_int bus_width;\r\nu_int ppr_options;\r\nu_int saved_width;\r\nu_int saved_offset;\r\nu_int saved_ppr_options;\r\nif (ahd->msgin_buf[1] != MSG_EXT_PPR_LEN) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (ahd->msgin_index < (MSG_EXT_PPR_LEN + 1))\r\nbreak;\r\nperiod = ahd->msgin_buf[3];\r\noffset = ahd->msgin_buf[5];\r\nbus_width = ahd->msgin_buf[6];\r\nsaved_width = bus_width;\r\nppr_options = ahd->msgin_buf[7];\r\nif ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0\r\n&& period <= 9)\r\noffset = 0;\r\nsaved_ppr_options = ppr_options;\r\nsaved_offset = offset;\r\nif (bus_width == 0)\r\nppr_options &= MSG_EXT_PPR_QAS_REQ;\r\nahd_validate_width(ahd, tinfo, &bus_width,\r\ndevinfo->role);\r\nahd_devlimited_syncrate(ahd, tinfo, &period,\r\n&ppr_options, devinfo->role);\r\nahd_validate_offset(ahd, tinfo, period, &offset,\r\nbus_width, devinfo->role);\r\nif (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, TRUE)) {\r\nif (saved_width > bus_width\r\n|| saved_offset != offset\r\n|| saved_ppr_options != ppr_options) {\r\nreject = TRUE;\r\nperiod = 0;\r\noffset = 0;\r\nbus_width = 0;\r\nppr_options = 0;\r\n}\r\n} else {\r\nif (devinfo->role != ROLE_TARGET)\r\nprintk("(%s:%c:%d:%d): Target "\r\n"Initiated PPR\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\nelse\r\nprintk("(%s:%c:%d:%d): Initiator "\r\n"Initiated PPR\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nahd_construct_ppr(ahd, devinfo, period, offset,\r\nbus_width, ppr_options);\r\nahd->msgout_index = 0;\r\nresponse = TRUE;\r\n}\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Received PPR width %x, "\r\n"period %x, offset %x,options %x\n"\r\n"\tFiltered to width %x, period %x, "\r\n"offset %x, options %x\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\nsaved_width, ahd->msgin_buf[3],\r\nsaved_offset, saved_ppr_options,\r\nbus_width, period, offset, ppr_options);\r\n}\r\nahd_set_width(ahd, devinfo, bus_width,\r\nAHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\r\nTRUE);\r\nahd_set_syncrate(ahd, devinfo, period,\r\noffset, ppr_options,\r\nAHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\r\nTRUE);\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\n}\r\ndefault:\r\nreject = TRUE;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n#ifdef AHD_TARGET_MODE\r\ncase MSG_BUS_DEV_RESET:\r\nahd_handle_devreset(ahd, devinfo, CAM_LUN_WILDCARD,\r\nCAM_BDR_SENT,\r\n"Bus Device Reset Received",\r\n0);\r\nahd_restart(ahd);\r\ndone = MSGLOOP_TERMINATED;\r\nbreak;\r\ncase MSG_ABORT_TAG:\r\ncase MSG_ABORT:\r\ncase MSG_CLEAR_QUEUE:\r\n{\r\nint tag;\r\nif (devinfo->role != ROLE_TARGET) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\ntag = SCB_LIST_NULL;\r\nif (ahd->msgin_buf[0] == MSG_ABORT_TAG)\r\ntag = ahd_inb(ahd, INITIATOR_TAG);\r\nahd_abort_scbs(ahd, devinfo->target, devinfo->channel,\r\ndevinfo->lun, tag, ROLE_TARGET,\r\nCAM_REQ_ABORTED);\r\ntstate = ahd->enabled_targets[devinfo->our_scsiid];\r\nif (tstate != NULL) {\r\nstruct ahd_tmode_lstate* lstate;\r\nlstate = tstate->enabled_luns[devinfo->lun];\r\nif (lstate != NULL) {\r\nahd_queue_lstate_event(ahd, lstate,\r\ndevinfo->our_scsiid,\r\nahd->msgin_buf[0],\r\ntag);\r\nahd_send_lstate_events(ahd, lstate);\r\n}\r\n}\r\nahd_restart(ahd);\r\ndone = MSGLOOP_TERMINATED;\r\nbreak;\r\n}\r\n#endif\r\ncase MSG_QAS_REQUEST:\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MESSAGES) != 0)\r\nprintk("%s: QAS request. SCSISIGI == 0x%x\n",\r\nahd_name(ahd), ahd_inb(ahd, SCSISIGI));\r\n#endif\r\nahd->msg_flags |= MSG_FLAG_EXPECT_QASREJ_BUSFREE;\r\ncase MSG_TERM_IO_PROC:\r\ndefault:\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (reject) {\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 1;\r\nahd->msgout_buf[0] = MSG_MESSAGE_REJECT;\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nresponse = TRUE;\r\n}\r\nif (done != MSGLOOP_IN_PROG && !response)\r\nahd->msgout_len = 0;\r\nreturn (done);\r\n}\r\nstatic int\r\nahd_handle_msg_reject(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nstruct scb *scb;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nu_int scb_index;\r\nu_int last_msg;\r\nint response = 0;\r\nscb_index = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scb_index);\r\ntinfo = ahd_fetch_transinfo(ahd, devinfo->channel,\r\ndevinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nlast_msg = ahd_inb(ahd, LAST_MSG);\r\nif (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, FALSE)) {\r\nif (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, TRUE)\r\n&& tinfo->goal.period <= AHD_SYNCRATE_PACED) {\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): PPR Rejected. "\r\n"Trying simple U160 PPR\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\ntinfo->goal.period = AHD_SYNCRATE_DT;\r\ntinfo->goal.ppr_options &= MSG_EXT_PPR_IU_REQ\r\n| MSG_EXT_PPR_QAS_REQ\r\n| MSG_EXT_PPR_DT_REQ;\r\n} else {\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): PPR Rejected. "\r\n"Trying WDTR/SDTR\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\ntinfo->goal.ppr_options = 0;\r\ntinfo->curr.transport_version = 2;\r\ntinfo->goal.transport_version = 2;\r\n}\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nahd_build_transfer_msg(ahd, devinfo);\r\nahd->msgout_index = 0;\r\nresponse = 1;\r\n} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, FALSE)) {\r\nprintk("(%s:%c:%d:%d): refuses WIDE negotiation. Using "\r\n"8bit transfers\n", ahd_name(ahd),\r\ndevinfo->channel, devinfo->target, devinfo->lun);\r\nahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\r\nTRUE);\r\nif (tinfo->goal.offset != tinfo->curr.offset) {\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nahd_build_transfer_msg(ahd, devinfo);\r\nahd->msgout_index = 0;\r\nresponse = 1;\r\n}\r\n} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, FALSE)) {\r\nahd_set_syncrate(ahd, devinfo, 0,\r\n0, 0,\r\nAHD_TRANS_ACTIVE|AHD_TRANS_GOAL,\r\nTRUE);\r\nprintk("(%s:%c:%d:%d): refuses synchronous negotiation. "\r\n"Using asynchronous transfers\n",\r\nahd_name(ahd), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {\r\nint tag_type;\r\nint mask;\r\ntag_type = (scb->hscb->control & MSG_SIMPLE_TASK);\r\nif (tag_type == MSG_SIMPLE_TASK) {\r\nprintk("(%s:%c:%d:%d): refuses tagged commands. "\r\n"Performing non-tagged I/O\n", ahd_name(ahd),\r\ndevinfo->channel, devinfo->target, devinfo->lun);\r\nahd_set_tags(ahd, scb->io_ctx, devinfo, AHD_QUEUE_NONE);\r\nmask = ~0x23;\r\n} else {\r\nprintk("(%s:%c:%d:%d): refuses %s tagged commands. "\r\n"Performing simple queue tagged I/O only\n",\r\nahd_name(ahd), devinfo->channel, devinfo->target,\r\ndevinfo->lun, tag_type == MSG_ORDERED_TASK\r\n? "ordered" : "head of queue");\r\nahd_set_tags(ahd, scb->io_ctx, devinfo, AHD_QUEUE_BASIC);\r\nmask = ~0x03;\r\n}\r\nahd_outb(ahd, SCB_CONTROL,\r\nahd_inb_scbram(ahd, SCB_CONTROL) & mask);\r\nscb->hscb->control &= mask;\r\nahd_set_transaction_tag(scb, FALSE,\r\nMSG_SIMPLE_TASK);\r\nahd_outb(ahd, MSG_OUT, MSG_IDENTIFYFLAG);\r\nahd_assert_atn(ahd);\r\nahd_busy_tcl(ahd, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),\r\nSCB_GET_TAG(scb));\r\nahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),\r\nSCB_GET_CHANNEL(ahd, scb),\r\nSCB_GET_LUN(scb), SCB_LIST_NULL,\r\nROLE_INITIATOR, CAM_REQUEUE_REQ,\r\nSEARCH_COMPLETE);\r\n} else if (ahd_sent_msg(ahd, AHDMSG_1B, MSG_IDENTIFYFLAG, TRUE)) {\r\nahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE\r\n| MSG_FLAG_IU_REQ_CHANGED;\r\nahd_force_renegotiation(ahd, devinfo);\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nahd_build_transfer_msg(ahd, devinfo);\r\nahd->msgout_index = 0;\r\nresponse = 1;\r\n} else {\r\nprintk("%s:%c:%d: Message reject for %x -- ignored\n",\r\nahd_name(ahd), devinfo->channel, devinfo->target,\r\nlast_msg);\r\n}\r\nreturn (response);\r\n}\r\nstatic void\r\nahd_handle_ign_wide_residue(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nu_int scb_index;\r\nstruct scb *scb;\r\nscb_index = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scb_index);\r\nif ((ahd_inb(ahd, SEQ_FLAGS) & DPHASE) == 0\r\n|| ahd_get_transfer_dir(scb) != CAM_DIR_IN) {\r\n} else {\r\nuint32_t sgptr;\r\nsgptr = ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);\r\nif ((sgptr & SG_LIST_NULL) != 0\r\n&& (ahd_inb_scbram(ahd, SCB_TASK_ATTRIBUTE)\r\n& SCB_XFERLEN_ODD) != 0) {\r\n} else {\r\nuint32_t data_cnt;\r\nuint64_t data_addr;\r\nuint32_t sglen;\r\nsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\r\ndata_cnt = ahd_inl_scbram(ahd, SCB_RESIDUAL_DATACNT);\r\nif ((sgptr & SG_LIST_NULL) != 0) {\r\ndata_cnt &= ~AHD_SG_LEN_MASK;\r\n}\r\ndata_addr = ahd_inq(ahd, SHADDR);\r\ndata_cnt += 1;\r\ndata_addr -= 1;\r\nsgptr &= SG_PTR_MASK;\r\nif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\r\nstruct ahd_dma64_seg *sg;\r\nsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\r\nsg--;\r\nsglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;\r\nif (sg != scb->sg_list\r\n&& sglen < (data_cnt & AHD_SG_LEN_MASK)) {\r\nsg--;\r\nsglen = ahd_le32toh(sg->len);\r\ndata_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));\r\ndata_addr = ahd_le64toh(sg->addr)\r\n+ (sglen & AHD_SG_LEN_MASK)\r\n- 1;\r\nsg++;\r\nsgptr = ahd_sg_virt_to_bus(ahd, scb,\r\nsg);\r\n}\r\n} else {\r\nstruct ahd_dma_seg *sg;\r\nsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\r\nsg--;\r\nsglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;\r\nif (sg != scb->sg_list\r\n&& sglen < (data_cnt & AHD_SG_LEN_MASK)) {\r\nsg--;\r\nsglen = ahd_le32toh(sg->len);\r\ndata_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));\r\ndata_addr = ahd_le32toh(sg->addr)\r\n+ (sglen & AHD_SG_LEN_MASK)\r\n- 1;\r\nsg++;\r\nsgptr = ahd_sg_virt_to_bus(ahd, scb,\r\nsg);\r\n}\r\n}\r\nahd_outb(ahd, SCB_TASK_ATTRIBUTE,\r\nahd_inb_scbram(ahd, SCB_TASK_ATTRIBUTE)\r\n^ SCB_XFERLEN_ODD);\r\nahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);\r\nahd_outl(ahd, SCB_RESIDUAL_DATACNT, data_cnt);\r\n}\r\n}\r\n}\r\nstatic void\r\nahd_reinitialize_dataptrs(struct ahd_softc *ahd)\r\n{\r\nstruct scb *scb;\r\nahd_mode_state saved_modes;\r\nu_int scb_index;\r\nu_int wait;\r\nuint32_t sgptr;\r\nuint32_t resid;\r\nuint64_t dataptr;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK,\r\nAHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK);\r\nscb_index = ahd_get_scbptr(ahd);\r\nscb = ahd_lookup_scb(ahd, scb_index);\r\nahd_outb(ahd, DFFSXFRCTL, CLRCHN);\r\nwait = 1000;\r\nwhile (--wait && !(ahd_inb(ahd, MDFFSTAT) & FIFOFREE))\r\nahd_delay(100);\r\nif (wait == 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("ahd_reinitialize_dataptrs: Forcing FIFO free.\n");\r\nahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);\r\n}\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, DFFSTAT,\r\nahd_inb(ahd, DFFSTAT)\r\n| (saved_modes == 0x11 ? CURRFIFO_1 : CURRFIFO_0));\r\nsgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);\r\nsgptr &= SG_PTR_MASK;\r\nresid = (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 2) << 16)\r\n| (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 1) << 8)\r\n| ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT);\r\nif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {\r\nstruct ahd_dma64_seg *sg;\r\nsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\r\nsg--;\r\ndataptr = ahd_le64toh(sg->addr)\r\n+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)\r\n- resid;\r\nahd_outl(ahd, HADDR + 4, dataptr >> 32);\r\n} else {\r\nstruct ahd_dma_seg *sg;\r\nsg = ahd_sg_bus_to_virt(ahd, scb, sgptr);\r\nsg--;\r\ndataptr = ahd_le32toh(sg->addr)\r\n+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)\r\n- resid;\r\nahd_outb(ahd, HADDR + 4,\r\n(ahd_le32toh(sg->len) & ~AHD_SG_LEN_MASK) >> 24);\r\n}\r\nahd_outl(ahd, HADDR, dataptr);\r\nahd_outb(ahd, HCNT + 2, resid >> 16);\r\nahd_outb(ahd, HCNT + 1, resid >> 8);\r\nahd_outb(ahd, HCNT, resid);\r\n}\r\nstatic void\r\nahd_handle_devreset(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nu_int lun, cam_status status, char *message,\r\nint verbose_level)\r\n{\r\n#ifdef AHD_TARGET_MODE\r\nstruct ahd_tmode_tstate* tstate;\r\n#endif\r\nint found;\r\nfound = ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,\r\nlun, SCB_LIST_NULL, devinfo->role,\r\nstatus);\r\n#ifdef AHD_TARGET_MODE\r\ntstate = ahd->enabled_targets[devinfo->our_scsiid];\r\nif (tstate != NULL) {\r\nu_int cur_lun;\r\nu_int max_lun;\r\nif (lun != CAM_LUN_WILDCARD) {\r\ncur_lun = 0;\r\nmax_lun = AHD_NUM_LUNS - 1;\r\n} else {\r\ncur_lun = lun;\r\nmax_lun = lun;\r\n}\r\nfor (;cur_lun <= max_lun; cur_lun++) {\r\nstruct ahd_tmode_lstate* lstate;\r\nlstate = tstate->enabled_luns[cur_lun];\r\nif (lstate == NULL)\r\ncontinue;\r\nahd_queue_lstate_event(ahd, lstate, devinfo->our_scsiid,\r\nMSG_BUS_DEV_RESET, 0);\r\nahd_send_lstate_events(ahd, lstate);\r\n}\r\n}\r\n#endif\r\nahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_CUR, TRUE);\r\nahd_set_syncrate(ahd, devinfo, 0, 0,\r\n0, AHD_TRANS_CUR,\r\nTRUE);\r\nif (status != CAM_SEL_TIMEOUT)\r\nahd_send_async(ahd, devinfo->channel, devinfo->target,\r\nCAM_LUN_WILDCARD, AC_SENT_BDR);\r\nif (message != NULL && bootverbose)\r\nprintk("%s: %s on %c:%d. %d SCBs aborted\n", ahd_name(ahd),\r\nmessage, devinfo->channel, devinfo->target, found);\r\n}\r\nstatic void\r\nahd_setup_target_msgin(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,\r\nstruct scb *scb)\r\n{\r\nahd->msgout_index = 0;\r\nahd->msgout_len = 0;\r\nif (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)\r\nahd_build_transfer_msg(ahd, devinfo);\r\nelse\r\npanic("ahd_intr: AWAITING target message with no message");\r\nahd->msgout_index = 0;\r\nahd->msg_type = MSG_TYPE_TARGET_MSGIN;\r\n}\r\nstatic u_int\r\nahd_sglist_size(struct ahd_softc *ahd)\r\n{\r\nbus_size_t list_size;\r\nlist_size = sizeof(struct ahd_dma_seg) * AHD_NSEG;\r\nif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)\r\nlist_size = sizeof(struct ahd_dma64_seg) * AHD_NSEG;\r\nreturn (list_size);\r\n}\r\nstatic u_int\r\nahd_sglist_allocsize(struct ahd_softc *ahd)\r\n{\r\nbus_size_t sg_list_increment;\r\nbus_size_t sg_list_size;\r\nbus_size_t max_list_size;\r\nbus_size_t best_list_size;\r\nsg_list_increment = ahd_sglist_size(ahd);\r\nsg_list_size = sg_list_increment;\r\nwhile ((sg_list_size + sg_list_increment) <= PAGE_SIZE)\r\nsg_list_size += sg_list_increment;\r\nbest_list_size = sg_list_size;\r\nmax_list_size = roundup(sg_list_increment, PAGE_SIZE);\r\nif (max_list_size < 4 * PAGE_SIZE)\r\nmax_list_size = 4 * PAGE_SIZE;\r\nif (max_list_size > (AHD_SCB_MAX_ALLOC * sg_list_increment))\r\nmax_list_size = (AHD_SCB_MAX_ALLOC * sg_list_increment);\r\nwhile ((sg_list_size + sg_list_increment) <= max_list_size\r\n&& (sg_list_size % PAGE_SIZE) != 0) {\r\nbus_size_t new_mod;\r\nbus_size_t best_mod;\r\nsg_list_size += sg_list_increment;\r\nnew_mod = sg_list_size % PAGE_SIZE;\r\nbest_mod = best_list_size % PAGE_SIZE;\r\nif (new_mod > best_mod || new_mod == 0) {\r\nbest_list_size = sg_list_size;\r\n}\r\n}\r\nreturn (best_list_size);\r\n}\r\nstruct ahd_softc *\r\nahd_alloc(void *platform_arg, char *name)\r\n{\r\nstruct ahd_softc *ahd;\r\n#ifndef __FreeBSD__\r\nahd = kmalloc(sizeof(*ahd), GFP_ATOMIC);\r\nif (!ahd) {\r\nprintk("aic7xxx: cannot malloc softc!\n");\r\nkfree(name);\r\nreturn NULL;\r\n}\r\n#else\r\nahd = device_get_softc((device_t)platform_arg);\r\n#endif\r\nmemset(ahd, 0, sizeof(*ahd));\r\nahd->seep_config = kmalloc(sizeof(*ahd->seep_config), GFP_ATOMIC);\r\nif (ahd->seep_config == NULL) {\r\n#ifndef __FreeBSD__\r\nkfree(ahd);\r\n#endif\r\nkfree(name);\r\nreturn (NULL);\r\n}\r\nLIST_INIT(&ahd->pending_scbs);\r\nahd->name = name;\r\nahd->unit = -1;\r\nahd->description = NULL;\r\nahd->bus_description = NULL;\r\nahd->channel = 'A';\r\nahd->chip = AHD_NONE;\r\nahd->features = AHD_FENONE;\r\nahd->bugs = AHD_BUGNONE;\r\nahd->flags = AHD_SPCHK_ENB_A|AHD_RESET_BUS_A|AHD_TERM_ENB_A\r\n| AHD_EXTENDED_TRANS_A|AHD_STPWLEVEL_A;\r\nahd_timer_init(&ahd->reset_timer);\r\nahd_timer_init(&ahd->stat_timer);\r\nahd->int_coalescing_timer = AHD_INT_COALESCING_TIMER_DEFAULT;\r\nahd->int_coalescing_maxcmds = AHD_INT_COALESCING_MAXCMDS_DEFAULT;\r\nahd->int_coalescing_mincmds = AHD_INT_COALESCING_MINCMDS_DEFAULT;\r\nahd->int_coalescing_threshold = AHD_INT_COALESCING_THRESHOLD_DEFAULT;\r\nahd->int_coalescing_stop_threshold =\r\nAHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT;\r\nif (ahd_platform_alloc(ahd, platform_arg) != 0) {\r\nahd_free(ahd);\r\nahd = NULL;\r\n}\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MEMORY) != 0) {\r\nprintk("%s: scb size = 0x%x, hscb size = 0x%x\n",\r\nahd_name(ahd), (u_int)sizeof(struct scb),\r\n(u_int)sizeof(struct hardware_scb));\r\n}\r\n#endif\r\nreturn (ahd);\r\n}\r\nint\r\nahd_softc_init(struct ahd_softc *ahd)\r\n{\r\nahd->unpause = 0;\r\nahd->pause = PAUSE;\r\nreturn (0);\r\n}\r\nvoid\r\nahd_set_unit(struct ahd_softc *ahd, int unit)\r\n{\r\nahd->unit = unit;\r\n}\r\nvoid\r\nahd_set_name(struct ahd_softc *ahd, char *name)\r\n{\r\nif (ahd->name != NULL)\r\nkfree(ahd->name);\r\nahd->name = name;\r\n}\r\nvoid\r\nahd_free(struct ahd_softc *ahd)\r\n{\r\nint i;\r\nswitch (ahd->init_level) {\r\ndefault:\r\ncase 5:\r\nahd_shutdown(ahd);\r\ncase 4:\r\nahd_dmamap_unload(ahd, ahd->shared_data_dmat,\r\nahd->shared_data_map.dmamap);\r\ncase 3:\r\nahd_dmamem_free(ahd, ahd->shared_data_dmat, ahd->qoutfifo,\r\nahd->shared_data_map.dmamap);\r\nahd_dmamap_destroy(ahd, ahd->shared_data_dmat,\r\nahd->shared_data_map.dmamap);\r\ncase 2:\r\nahd_dma_tag_destroy(ahd, ahd->shared_data_dmat);\r\ncase 1:\r\n#ifndef __linux__\r\nahd_dma_tag_destroy(ahd, ahd->buffer_dmat);\r\n#endif\r\nbreak;\r\ncase 0:\r\nbreak;\r\n}\r\n#ifndef __linux__\r\nahd_dma_tag_destroy(ahd, ahd->parent_dmat);\r\n#endif\r\nahd_platform_free(ahd);\r\nahd_fini_scbdata(ahd);\r\nfor (i = 0; i < AHD_NUM_TARGETS; i++) {\r\nstruct ahd_tmode_tstate *tstate;\r\ntstate = ahd->enabled_targets[i];\r\nif (tstate != NULL) {\r\n#ifdef AHD_TARGET_MODE\r\nint j;\r\nfor (j = 0; j < AHD_NUM_LUNS; j++) {\r\nstruct ahd_tmode_lstate *lstate;\r\nlstate = tstate->enabled_luns[j];\r\nif (lstate != NULL) {\r\nxpt_free_path(lstate->path);\r\nkfree(lstate);\r\n}\r\n}\r\n#endif\r\nkfree(tstate);\r\n}\r\n}\r\n#ifdef AHD_TARGET_MODE\r\nif (ahd->black_hole != NULL) {\r\nxpt_free_path(ahd->black_hole->path);\r\nkfree(ahd->black_hole);\r\n}\r\n#endif\r\nif (ahd->name != NULL)\r\nkfree(ahd->name);\r\nif (ahd->seep_config != NULL)\r\nkfree(ahd->seep_config);\r\nif (ahd->saved_stack != NULL)\r\nkfree(ahd->saved_stack);\r\n#ifndef __FreeBSD__\r\nkfree(ahd);\r\n#endif\r\nreturn;\r\n}\r\nstatic void\r\nahd_shutdown(void *arg)\r\n{\r\nstruct ahd_softc *ahd;\r\nahd = (struct ahd_softc *)arg;\r\nahd_timer_stop(&ahd->reset_timer);\r\nahd_timer_stop(&ahd->stat_timer);\r\nahd_reset(ahd, FALSE);\r\n}\r\nint\r\nahd_reset(struct ahd_softc *ahd, int reinit)\r\n{\r\nu_int sxfrctl1;\r\nint wait;\r\nuint32_t cmd;\r\nahd_pause(ahd);\r\nahd_update_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nsxfrctl1 = ahd_inb(ahd, SXFRCTL1);\r\ncmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 2);\r\nif ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {\r\nuint32_t mod_cmd;\r\nmod_cmd = cmd & ~(PCIM_CMD_PERRESPEN|PCIM_CMD_SERRESPEN);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\r\nmod_cmd, 2);\r\n}\r\nahd_outb(ahd, HCNTRL, CHIPRST | ahd->pause);\r\nwait = 1000;\r\ndo {\r\nahd_delay(1000);\r\n} while (--wait && !(ahd_inb(ahd, HCNTRL) & CHIPRSTACK));\r\nif (wait == 0) {\r\nprintk("%s: WARNING - Failed chip reset! "\r\n"Trying to initialize anyway.\n", ahd_name(ahd));\r\n}\r\nahd_outb(ahd, HCNTRL, ahd->pause);\r\nif ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {\r\nahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\r\n0xFF, 1);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\r\ncmd, 2);\r\n}\r\nahd_known_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, MODE_PTR,\r\nahd_build_mode_state(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI));\r\nahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);\r\nahd_outb(ahd, SXFRCTL1, sxfrctl1);\r\nahd->features &= ~AHD_WIDE;\r\nif ((ahd_inb(ahd, SBLKCTL) & SELWIDE) != 0)\r\nahd->features |= AHD_WIDE;\r\nif (reinit != 0)\r\nahd_chip_init(ahd);\r\nreturn (0);\r\n}\r\nstatic int\r\nahd_probe_scbs(struct ahd_softc *ahd) {\r\nint i;\r\nAHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),\r\n~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));\r\nfor (i = 0; i < AHD_SCB_MAX; i++) {\r\nint j;\r\nahd_set_scbptr(ahd, i);\r\nahd_outw(ahd, SCB_BASE, i);\r\nfor (j = 2; j < 64; j++)\r\nahd_outb(ahd, SCB_BASE+j, 0);\r\nahd_outb(ahd, SCB_CONTROL, MK_MESSAGE);\r\nif (ahd_inw_scbram(ahd, SCB_BASE) != i)\r\nbreak;\r\nahd_set_scbptr(ahd, 0);\r\nif (ahd_inw_scbram(ahd, SCB_BASE) != 0)\r\nbreak;\r\n}\r\nreturn (i);\r\n}\r\nstatic void\r\nahd_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error)\r\n{\r\ndma_addr_t *baddr;\r\nbaddr = (dma_addr_t *)arg;\r\n*baddr = segs->ds_addr;\r\n}\r\nstatic void\r\nahd_initialize_hscbs(struct ahd_softc *ahd)\r\n{\r\nint i;\r\nfor (i = 0; i < ahd->scb_data.maxhscbs; i++) {\r\nahd_set_scbptr(ahd, i);\r\nahd_outb(ahd, SCB_CONTROL, 0);\r\nahd_outw(ahd, SCB_NEXT, SCB_LIST_NULL);\r\n}\r\n}\r\nstatic int\r\nahd_init_scbdata(struct ahd_softc *ahd)\r\n{\r\nstruct scb_data *scb_data;\r\nint i;\r\nscb_data = &ahd->scb_data;\r\nTAILQ_INIT(&scb_data->free_scbs);\r\nfor (i = 0; i < AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT; i++)\r\nLIST_INIT(&scb_data->free_scb_lists[i]);\r\nLIST_INIT(&scb_data->any_dev_free_scb_list);\r\nSLIST_INIT(&scb_data->hscb_maps);\r\nSLIST_INIT(&scb_data->sg_maps);\r\nSLIST_INIT(&scb_data->sense_maps);\r\nscb_data->maxhscbs = ahd_probe_scbs(ahd);\r\nif (scb_data->maxhscbs == 0) {\r\nprintk("%s: No SCB space found\n", ahd_name(ahd));\r\nreturn (ENXIO);\r\n}\r\nahd_initialize_hscbs(ahd);\r\nif (ahd_dma_tag_create(ahd, ahd->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\nPAGE_SIZE, 1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &scb_data->hscb_dmat) != 0) {\r\ngoto error_exit;\r\n}\r\nscb_data->init_level++;\r\nif (ahd_dma_tag_create(ahd, ahd->parent_dmat, 8,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\nahd_sglist_allocsize(ahd), 1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &scb_data->sg_dmat) != 0) {\r\ngoto error_exit;\r\n}\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MEMORY) != 0)\r\nprintk("%s: ahd_sglist_allocsize = 0x%x\n", ahd_name(ahd),\r\nahd_sglist_allocsize(ahd));\r\n#endif\r\nscb_data->init_level++;\r\nif (ahd_dma_tag_create(ahd, ahd->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\nPAGE_SIZE, 1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &scb_data->sense_dmat) != 0) {\r\ngoto error_exit;\r\n}\r\nscb_data->init_level++;\r\nahd_alloc_scbs(ahd);\r\nif (scb_data->numscbs == 0) {\r\nprintk("%s: ahd_init_scbdata - "\r\n"Unable to allocate initial scbs\n",\r\nahd_name(ahd));\r\ngoto error_exit;\r\n}\r\nreturn (0);\r\nerror_exit:\r\nreturn (ENOMEM);\r\n}\r\nstatic struct scb *\r\nahd_find_scb_by_tag(struct ahd_softc *ahd, u_int tag)\r\n{\r\nstruct scb *scb;\r\nLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\r\nif (SCB_GET_TAG(scb) == tag)\r\nreturn (scb);\r\n}\r\nTAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {\r\nstruct scb *list_scb;\r\nlist_scb = scb;\r\ndo {\r\nif (SCB_GET_TAG(list_scb) == tag)\r\nreturn (list_scb);\r\nlist_scb = LIST_NEXT(list_scb, collision_links);\r\n} while (list_scb);\r\n}\r\nLIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {\r\nif (SCB_GET_TAG(scb) == tag)\r\nreturn (scb);\r\n}\r\nreturn (NULL);\r\n}\r\nstatic void\r\nahd_fini_scbdata(struct ahd_softc *ahd)\r\n{\r\nstruct scb_data *scb_data;\r\nscb_data = &ahd->scb_data;\r\nif (scb_data == NULL)\r\nreturn;\r\nswitch (scb_data->init_level) {\r\ndefault:\r\ncase 7:\r\n{\r\nstruct map_node *sns_map;\r\nwhile ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {\r\nSLIST_REMOVE_HEAD(&scb_data->sense_maps, links);\r\nahd_dmamap_unload(ahd, scb_data->sense_dmat,\r\nsns_map->dmamap);\r\nahd_dmamem_free(ahd, scb_data->sense_dmat,\r\nsns_map->vaddr, sns_map->dmamap);\r\nkfree(sns_map);\r\n}\r\nahd_dma_tag_destroy(ahd, scb_data->sense_dmat);\r\n}\r\ncase 6:\r\n{\r\nstruct map_node *sg_map;\r\nwhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {\r\nSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\r\nahd_dmamap_unload(ahd, scb_data->sg_dmat,\r\nsg_map->dmamap);\r\nahd_dmamem_free(ahd, scb_data->sg_dmat,\r\nsg_map->vaddr, sg_map->dmamap);\r\nkfree(sg_map);\r\n}\r\nahd_dma_tag_destroy(ahd, scb_data->sg_dmat);\r\n}\r\ncase 5:\r\n{\r\nstruct map_node *hscb_map;\r\nwhile ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {\r\nSLIST_REMOVE_HEAD(&scb_data->hscb_maps, links);\r\nahd_dmamap_unload(ahd, scb_data->hscb_dmat,\r\nhscb_map->dmamap);\r\nahd_dmamem_free(ahd, scb_data->hscb_dmat,\r\nhscb_map->vaddr, hscb_map->dmamap);\r\nkfree(hscb_map);\r\n}\r\nahd_dma_tag_destroy(ahd, scb_data->hscb_dmat);\r\n}\r\ncase 4:\r\ncase 3:\r\ncase 2:\r\ncase 1:\r\ncase 0:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nahd_setup_iocell_workaround(struct ahd_softc *ahd)\r\n{\r\nahd_mode_state saved_modes;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nahd_outb(ahd, DSPDATACTL, ahd_inb(ahd, DSPDATACTL)\r\n| BYPASSENAB | RCVROFFSTDIS | XMITOFFSTDIS);\r\nahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) | (ENSELDO|ENSELDI));\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("%s: Setting up iocell workaround\n", ahd_name(ahd));\r\n#endif\r\nahd_restore_modes(ahd, saved_modes);\r\nahd->flags &= ~AHD_HAD_FIRST_SEL;\r\n}\r\nstatic void\r\nahd_iocell_first_selection(struct ahd_softc *ahd)\r\n{\r\nahd_mode_state saved_modes;\r\nu_int sblkctl;\r\nif ((ahd->flags & AHD_HAD_FIRST_SEL) != 0)\r\nreturn;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nsblkctl = ahd_inb(ahd, SBLKCTL);\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("%s: iocell first selection\n", ahd_name(ahd));\r\n#endif\r\nif ((sblkctl & ENAB40) != 0) {\r\nahd_outb(ahd, DSPDATACTL,\r\nahd_inb(ahd, DSPDATACTL) & ~BYPASSENAB);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("%s: BYPASS now disabled\n", ahd_name(ahd));\r\n#endif\r\n}\r\nahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) & ~(ENSELDO|ENSELDI));\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\nahd_restore_modes(ahd, saved_modes);\r\nahd->flags |= AHD_HAD_FIRST_SEL;\r\n}\r\nstatic void\r\nahd_add_col_list(struct ahd_softc *ahd, struct scb *scb, u_int col_idx)\r\n{\r\nstruct scb_list *free_list;\r\nstruct scb_tailq *free_tailq;\r\nstruct scb *first_scb;\r\nscb->flags |= SCB_ON_COL_LIST;\r\nAHD_SET_SCB_COL_IDX(scb, col_idx);\r\nfree_list = &ahd->scb_data.free_scb_lists[col_idx];\r\nfree_tailq = &ahd->scb_data.free_scbs;\r\nfirst_scb = LIST_FIRST(free_list);\r\nif (first_scb != NULL) {\r\nLIST_INSERT_AFTER(first_scb, scb, collision_links);\r\n} else {\r\nLIST_INSERT_HEAD(free_list, scb, collision_links);\r\nTAILQ_INSERT_TAIL(free_tailq, scb, links.tqe);\r\n}\r\n}\r\nstatic void\r\nahd_rem_col_list(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nstruct scb_list *free_list;\r\nstruct scb_tailq *free_tailq;\r\nstruct scb *first_scb;\r\nu_int col_idx;\r\nscb->flags &= ~SCB_ON_COL_LIST;\r\ncol_idx = AHD_GET_SCB_COL_IDX(ahd, scb);\r\nfree_list = &ahd->scb_data.free_scb_lists[col_idx];\r\nfree_tailq = &ahd->scb_data.free_scbs;\r\nfirst_scb = LIST_FIRST(free_list);\r\nif (first_scb == scb) {\r\nstruct scb *next_scb;\r\nnext_scb = LIST_NEXT(scb, collision_links);\r\nif (next_scb != NULL) {\r\nTAILQ_INSERT_AFTER(free_tailq, scb,\r\nnext_scb, links.tqe);\r\n}\r\nTAILQ_REMOVE(free_tailq, scb, links.tqe);\r\n}\r\nLIST_REMOVE(scb, collision_links);\r\n}\r\nstruct scb *\r\nahd_get_scb(struct ahd_softc *ahd, u_int col_idx)\r\n{\r\nstruct scb *scb;\r\nint tries;\r\ntries = 0;\r\nlook_again:\r\nTAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {\r\nif (AHD_GET_SCB_COL_IDX(ahd, scb) != col_idx) {\r\nahd_rem_col_list(ahd, scb);\r\ngoto found;\r\n}\r\n}\r\nif ((scb = LIST_FIRST(&ahd->scb_data.any_dev_free_scb_list)) == NULL) {\r\nif (tries++ != 0)\r\nreturn (NULL);\r\nahd_alloc_scbs(ahd);\r\ngoto look_again;\r\n}\r\nLIST_REMOVE(scb, links.le);\r\nif (col_idx != AHD_NEVER_COL_IDX\r\n&& (scb->col_scb != NULL)\r\n&& (scb->col_scb->flags & SCB_ACTIVE) == 0) {\r\nLIST_REMOVE(scb->col_scb, links.le);\r\nahd_add_col_list(ahd, scb->col_scb, col_idx);\r\n}\r\nfound:\r\nscb->flags |= SCB_ACTIVE;\r\nreturn (scb);\r\n}\r\nvoid\r\nahd_free_scb(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nscb->flags = SCB_FLAG_NONE;\r\nscb->hscb->control = 0;\r\nahd->scb_data.scbindex[SCB_GET_TAG(scb)] = NULL;\r\nif (scb->col_scb == NULL) {\r\nLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\r\nscb, links.le);\r\n} else if ((scb->col_scb->flags & SCB_ON_COL_LIST) != 0) {\r\nahd_rem_col_list(ahd, scb->col_scb);\r\nLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\r\nscb, links.le);\r\nLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\r\nscb->col_scb, links.le);\r\n} else if ((scb->col_scb->flags\r\n& (SCB_PACKETIZED|SCB_ACTIVE)) == SCB_ACTIVE\r\n&& (scb->col_scb->hscb->control & TAG_ENB) != 0) {\r\nahd_add_col_list(ahd, scb,\r\nAHD_GET_SCB_COL_IDX(ahd, scb->col_scb));\r\n} else {\r\nLIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,\r\nscb, links.le);\r\n}\r\nahd_platform_scb_free(ahd, scb);\r\n}\r\nstatic void\r\nahd_alloc_scbs(struct ahd_softc *ahd)\r\n{\r\nstruct scb_data *scb_data;\r\nstruct scb *next_scb;\r\nstruct hardware_scb *hscb;\r\nstruct map_node *hscb_map;\r\nstruct map_node *sg_map;\r\nstruct map_node *sense_map;\r\nuint8_t *segs;\r\nuint8_t *sense_data;\r\ndma_addr_t hscb_busaddr;\r\ndma_addr_t sg_busaddr;\r\ndma_addr_t sense_busaddr;\r\nint newcount;\r\nint i;\r\nscb_data = &ahd->scb_data;\r\nif (scb_data->numscbs >= AHD_SCB_MAX_ALLOC)\r\nreturn;\r\nif (scb_data->scbs_left != 0) {\r\nint offset;\r\noffset = (PAGE_SIZE / sizeof(*hscb)) - scb_data->scbs_left;\r\nhscb_map = SLIST_FIRST(&scb_data->hscb_maps);\r\nhscb = &((struct hardware_scb *)hscb_map->vaddr)[offset];\r\nhscb_busaddr = hscb_map->physaddr + (offset * sizeof(*hscb));\r\n} else {\r\nhscb_map = kmalloc(sizeof(*hscb_map), GFP_ATOMIC);\r\nif (hscb_map == NULL)\r\nreturn;\r\nif (ahd_dmamem_alloc(ahd, scb_data->hscb_dmat,\r\n(void **)&hscb_map->vaddr,\r\nBUS_DMA_NOWAIT, &hscb_map->dmamap) != 0) {\r\nkfree(hscb_map);\r\nreturn;\r\n}\r\nSLIST_INSERT_HEAD(&scb_data->hscb_maps, hscb_map, links);\r\nahd_dmamap_load(ahd, scb_data->hscb_dmat, hscb_map->dmamap,\r\nhscb_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,\r\n&hscb_map->physaddr, 0);\r\nhscb = (struct hardware_scb *)hscb_map->vaddr;\r\nhscb_busaddr = hscb_map->physaddr;\r\nscb_data->scbs_left = PAGE_SIZE / sizeof(*hscb);\r\n}\r\nif (scb_data->sgs_left != 0) {\r\nint offset;\r\noffset = ((ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd))\r\n- scb_data->sgs_left) * ahd_sglist_size(ahd);\r\nsg_map = SLIST_FIRST(&scb_data->sg_maps);\r\nsegs = sg_map->vaddr + offset;\r\nsg_busaddr = sg_map->physaddr + offset;\r\n} else {\r\nsg_map = kmalloc(sizeof(*sg_map), GFP_ATOMIC);\r\nif (sg_map == NULL)\r\nreturn;\r\nif (ahd_dmamem_alloc(ahd, scb_data->sg_dmat,\r\n(void **)&sg_map->vaddr,\r\nBUS_DMA_NOWAIT, &sg_map->dmamap) != 0) {\r\nkfree(sg_map);\r\nreturn;\r\n}\r\nSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\r\nahd_dmamap_load(ahd, scb_data->sg_dmat, sg_map->dmamap,\r\nsg_map->vaddr, ahd_sglist_allocsize(ahd),\r\nahd_dmamap_cb, &sg_map->physaddr, 0);\r\nsegs = sg_map->vaddr;\r\nsg_busaddr = sg_map->physaddr;\r\nscb_data->sgs_left =\r\nahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd);\r\n#ifdef AHD_DEBUG\r\nif (ahd_debug & AHD_SHOW_MEMORY)\r\nprintk("Mapped SG data\n");\r\n#endif\r\n}\r\nif (scb_data->sense_left != 0) {\r\nint offset;\r\noffset = PAGE_SIZE - (AHD_SENSE_BUFSIZE * scb_data->sense_left);\r\nsense_map = SLIST_FIRST(&scb_data->sense_maps);\r\nsense_data = sense_map->vaddr + offset;\r\nsense_busaddr = sense_map->physaddr + offset;\r\n} else {\r\nsense_map = kmalloc(sizeof(*sense_map), GFP_ATOMIC);\r\nif (sense_map == NULL)\r\nreturn;\r\nif (ahd_dmamem_alloc(ahd, scb_data->sense_dmat,\r\n(void **)&sense_map->vaddr,\r\nBUS_DMA_NOWAIT, &sense_map->dmamap) != 0) {\r\nkfree(sense_map);\r\nreturn;\r\n}\r\nSLIST_INSERT_HEAD(&scb_data->sense_maps, sense_map, links);\r\nahd_dmamap_load(ahd, scb_data->sense_dmat, sense_map->dmamap,\r\nsense_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,\r\n&sense_map->physaddr, 0);\r\nsense_data = sense_map->vaddr;\r\nsense_busaddr = sense_map->physaddr;\r\nscb_data->sense_left = PAGE_SIZE / AHD_SENSE_BUFSIZE;\r\n#ifdef AHD_DEBUG\r\nif (ahd_debug & AHD_SHOW_MEMORY)\r\nprintk("Mapped sense data\n");\r\n#endif\r\n}\r\nnewcount = min(scb_data->sense_left, scb_data->scbs_left);\r\nnewcount = min(newcount, scb_data->sgs_left);\r\nnewcount = min(newcount, (AHD_SCB_MAX_ALLOC - scb_data->numscbs));\r\nfor (i = 0; i < newcount; i++) {\r\nstruct scb_platform_data *pdata;\r\nu_int col_tag;\r\n#ifndef __linux__\r\nint error;\r\n#endif\r\nnext_scb = kmalloc(sizeof(*next_scb), GFP_ATOMIC);\r\nif (next_scb == NULL)\r\nbreak;\r\npdata = kmalloc(sizeof(*pdata), GFP_ATOMIC);\r\nif (pdata == NULL) {\r\nkfree(next_scb);\r\nbreak;\r\n}\r\nnext_scb->platform_data = pdata;\r\nnext_scb->hscb_map = hscb_map;\r\nnext_scb->sg_map = sg_map;\r\nnext_scb->sense_map = sense_map;\r\nnext_scb->sg_list = segs;\r\nnext_scb->sense_data = sense_data;\r\nnext_scb->sense_busaddr = sense_busaddr;\r\nmemset(hscb, 0, sizeof(*hscb));\r\nnext_scb->hscb = hscb;\r\nhscb->hscb_busaddr = ahd_htole32(hscb_busaddr);\r\nnext_scb->sg_list_busaddr = sg_busaddr;\r\nif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)\r\nnext_scb->sg_list_busaddr\r\n+= sizeof(struct ahd_dma64_seg);\r\nelse\r\nnext_scb->sg_list_busaddr += sizeof(struct ahd_dma_seg);\r\nnext_scb->ahd_softc = ahd;\r\nnext_scb->flags = SCB_FLAG_NONE;\r\n#ifndef __linux__\r\nerror = ahd_dmamap_create(ahd, ahd->buffer_dmat, 0,\r\n&next_scb->dmamap);\r\nif (error != 0) {\r\nkfree(next_scb);\r\nkfree(pdata);\r\nbreak;\r\n}\r\n#endif\r\nnext_scb->hscb->tag = ahd_htole16(scb_data->numscbs);\r\ncol_tag = scb_data->numscbs ^ 0x100;\r\nnext_scb->col_scb = ahd_find_scb_by_tag(ahd, col_tag);\r\nif (next_scb->col_scb != NULL)\r\nnext_scb->col_scb->col_scb = next_scb;\r\nahd_free_scb(ahd, next_scb);\r\nhscb++;\r\nhscb_busaddr += sizeof(*hscb);\r\nsegs += ahd_sglist_size(ahd);\r\nsg_busaddr += ahd_sglist_size(ahd);\r\nsense_data += AHD_SENSE_BUFSIZE;\r\nsense_busaddr += AHD_SENSE_BUFSIZE;\r\nscb_data->numscbs++;\r\nscb_data->sense_left--;\r\nscb_data->scbs_left--;\r\nscb_data->sgs_left--;\r\n}\r\n}\r\nvoid\r\nahd_controller_info(struct ahd_softc *ahd, char *buf)\r\n{\r\nconst char *speed;\r\nconst char *type;\r\nint len;\r\nlen = sprintf(buf, "%s: ", ahd_chip_names[ahd->chip & AHD_CHIPID_MASK]);\r\nbuf += len;\r\nspeed = "Ultra320 ";\r\nif ((ahd->features & AHD_WIDE) != 0) {\r\ntype = "Wide ";\r\n} else {\r\ntype = "Single ";\r\n}\r\nlen = sprintf(buf, "%s%sChannel %c, SCSI Id=%d, ",\r\nspeed, type, ahd->channel, ahd->our_id);\r\nbuf += len;\r\nsprintf(buf, "%s, %d SCBs", ahd->bus_description,\r\nahd->scb_data.maxhscbs);\r\n}\r\nstatic void\r\nahd_timer_reset(ahd_timer_t *timer, int usec, ahd_callback_t *func, void *arg)\r\n{\r\nstruct ahd_softc *ahd;\r\nahd = (struct ahd_softc *)arg;\r\ndel_timer(timer);\r\ntimer->data = (u_long)arg;\r\ntimer->expires = jiffies + (usec * HZ)/1000000;\r\ntimer->function = (ahd_linux_callback_t*)func;\r\nadd_timer(timer);\r\n}\r\nint\r\nahd_init(struct ahd_softc *ahd)\r\n{\r\nuint8_t *next_vaddr;\r\ndma_addr_t next_baddr;\r\nsize_t driver_data_size;\r\nint i;\r\nint error;\r\nu_int warn_user;\r\nuint8_t current_sensing;\r\nuint8_t fstat;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nahd->stack_size = ahd_probe_stack_size(ahd);\r\nahd->saved_stack = kmalloc(ahd->stack_size * sizeof(uint16_t), GFP_ATOMIC);\r\nif (ahd->saved_stack == NULL)\r\nreturn (ENOMEM);\r\nif (sizeof(struct hardware_scb) != 64)\r\npanic("Hardware SCB size is incorrect");\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_DEBUG_SEQUENCER) != 0)\r\nahd->flags |= AHD_SEQUENCER_DEBUG;\r\n#endif\r\nahd->flags |= AHD_INITIATORROLE;\r\nif ((AHD_TMODE_ENABLE & (0x1 << ahd->unit)) == 0)\r\nahd->features &= ~AHD_TARGETMODE;\r\n#ifndef __linux__\r\nif (ahd_dma_tag_create(ahd, ahd->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nahd->flags & AHD_39BIT_ADDRESSING\r\n? (dma_addr_t)0x7FFFFFFFFFULL\r\n: BUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\n(AHD_NSEG - 1) * PAGE_SIZE,\r\nAHD_NSEG,\r\nAHD_MAXTRANSFER_SIZE,\r\nBUS_DMA_ALLOCNOW,\r\n&ahd->buffer_dmat) != 0) {\r\nreturn (ENOMEM);\r\n}\r\n#endif\r\nahd->init_level++;\r\ndriver_data_size = AHD_SCB_MAX * sizeof(*ahd->qoutfifo)\r\n+ sizeof(struct hardware_scb);\r\nif ((ahd->features & AHD_TARGETMODE) != 0)\r\ndriver_data_size += AHD_TMODE_CMDS * sizeof(struct target_cmd);\r\nif ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0)\r\ndriver_data_size += PKT_OVERRUN_BUFSIZE;\r\nif (ahd_dma_tag_create(ahd, ahd->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\ndriver_data_size,\r\n1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &ahd->shared_data_dmat) != 0) {\r\nreturn (ENOMEM);\r\n}\r\nahd->init_level++;\r\nif (ahd_dmamem_alloc(ahd, ahd->shared_data_dmat,\r\n(void **)&ahd->shared_data_map.vaddr,\r\nBUS_DMA_NOWAIT,\r\n&ahd->shared_data_map.dmamap) != 0) {\r\nreturn (ENOMEM);\r\n}\r\nahd->init_level++;\r\nahd_dmamap_load(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,\r\nahd->shared_data_map.vaddr, driver_data_size,\r\nahd_dmamap_cb, &ahd->shared_data_map.physaddr,\r\n0);\r\nahd->qoutfifo = (struct ahd_completion *)ahd->shared_data_map.vaddr;\r\nnext_vaddr = (uint8_t *)&ahd->qoutfifo[AHD_QOUT_SIZE];\r\nnext_baddr = ahd->shared_data_map.physaddr\r\n+ AHD_QOUT_SIZE*sizeof(struct ahd_completion);\r\nif ((ahd->features & AHD_TARGETMODE) != 0) {\r\nahd->targetcmds = (struct target_cmd *)next_vaddr;\r\nnext_vaddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);\r\nnext_baddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);\r\n}\r\nif ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {\r\nahd->overrun_buf = next_vaddr;\r\nnext_vaddr += PKT_OVERRUN_BUFSIZE;\r\nnext_baddr += PKT_OVERRUN_BUFSIZE;\r\n}\r\nahd->next_queued_hscb = (struct hardware_scb *)next_vaddr;\r\nahd->next_queued_hscb_map = &ahd->shared_data_map;\r\nahd->next_queued_hscb->hscb_busaddr = ahd_htole32(next_baddr);\r\nahd->init_level++;\r\nif (ahd_init_scbdata(ahd) != 0)\r\nreturn (ENOMEM);\r\nif ((ahd->flags & AHD_INITIATORROLE) == 0)\r\nahd->flags &= ~AHD_RESET_BUS_A;\r\nahd_platform_init(ahd);\r\nahd_chip_init(ahd);\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nif ((ahd->flags & AHD_CURRENT_SENSING) == 0)\r\ngoto init_done;\r\nerror = ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL,\r\nCURSENSE_ENB);\r\nif (error != 0) {\r\nprintk("%s: current sensing timeout 1\n", ahd_name(ahd));\r\ngoto init_done;\r\n}\r\nfor (i = 20, fstat = FLX_FSTAT_BUSY;\r\n(fstat & FLX_FSTAT_BUSY) != 0 && i; i--) {\r\nerror = ahd_read_flexport(ahd, FLXADDR_FLEXSTAT, &fstat);\r\nif (error != 0) {\r\nprintk("%s: current sensing timeout 2\n",\r\nahd_name(ahd));\r\ngoto init_done;\r\n}\r\n}\r\nif (i == 0) {\r\nprintk("%s: Timedout during current-sensing test\n",\r\nahd_name(ahd));\r\ngoto init_done;\r\n}\r\nerror = ahd_read_flexport(ahd, FLXADDR_CURRENT_STAT, &current_sensing);\r\nif (error != 0) {\r\nprintk("%s: current sensing timeout 3\n", ahd_name(ahd));\r\ngoto init_done;\r\n}\r\nahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_TERMCTL) != 0) {\r\nprintk("%s: current_sensing == 0x%x\n",\r\nahd_name(ahd), current_sensing);\r\n}\r\n#endif\r\nwarn_user = 0;\r\nfor (i = 0; i < 4; i++, current_sensing >>= FLX_CSTAT_SHIFT) {\r\nu_int term_stat;\r\nterm_stat = (current_sensing & FLX_CSTAT_MASK);\r\nswitch (term_stat) {\r\ncase FLX_CSTAT_OVER:\r\ncase FLX_CSTAT_UNDER:\r\nwarn_user++;\r\ncase FLX_CSTAT_INVALID:\r\ncase FLX_CSTAT_OKAY:\r\nif (warn_user == 0 && bootverbose == 0)\r\nbreak;\r\nprintk("%s: %s Channel %s\n", ahd_name(ahd),\r\nchannel_strings[i], termstat_strings[term_stat]);\r\nbreak;\r\n}\r\n}\r\nif (warn_user) {\r\nprintk("%s: WARNING. Termination is not configured correctly.\n"\r\n"%s: WARNING. SCSI bus operations may FAIL.\n",\r\nahd_name(ahd), ahd_name(ahd));\r\n}\r\ninit_done:\r\nahd_restart(ahd);\r\nahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,\r\nahd_stat_timer, ahd);\r\nreturn (0);\r\n}\r\nstatic void\r\nahd_chip_init(struct ahd_softc *ahd)\r\n{\r\nuint32_t busaddr;\r\nu_int sxfrctl1;\r\nu_int scsiseq_template;\r\nu_int wait;\r\nu_int i;\r\nu_int target;\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, SBLKCTL, ahd_inb(ahd, SBLKCTL) & ~(DIAGLEDEN|DIAGLEDON));\r\nahd->hs_mailbox = 0;\r\nahd_outb(ahd, HS_MAILBOX, 0);\r\nahd_outb(ahd, IOWNID, ahd->our_id);\r\nahd_outb(ahd, TOWNID, ahd->our_id);\r\nsxfrctl1 = (ahd->flags & AHD_TERM_ENB_A) != 0 ? STPWEN : 0;\r\nsxfrctl1 |= (ahd->flags & AHD_SPCHK_ENB_A) != 0 ? ENSPCHK : 0;\r\nif ((ahd->bugs & AHD_LONG_SETIMO_BUG)\r\n&& (ahd->seltime != STIMESEL_MIN)) {\r\nsxfrctl1 |= ahd->seltime + STIMESEL_BUG_ADJ;\r\n} else {\r\nsxfrctl1 |= ahd->seltime;\r\n}\r\nahd_outb(ahd, SXFRCTL0, DFON);\r\nahd_outb(ahd, SXFRCTL1, sxfrctl1|ahd->seltime|ENSTIMER|ACTNEGEN);\r\nahd_outb(ahd, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\r\nfor (wait = 10000;\r\n(ahd_inb(ahd, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;\r\nwait--)\r\nahd_delay(100);\r\nahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\nfor (i = 0; i < 2; i++) {\r\nahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);\r\nahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);\r\nahd_outb(ahd, SG_STATE, 0);\r\nahd_outb(ahd, CLRSEQINTSRC, 0xFF);\r\nahd_outb(ahd, SEQIMODE,\r\nENSAVEPTRS|ENCFG4DATA|ENCFG4ISTAT\r\n|ENCFG4TSTAT|ENCFG4ICMD|ENCFG4TCMD);\r\n}\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nahd_outb(ahd, DSCOMMAND0, ahd_inb(ahd, DSCOMMAND0)|MPARCKEN|CACHETHEN);\r\nahd_outb(ahd, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);\r\nahd_outb(ahd, SIMODE0, ENIOERR|ENOVERRUN);\r\nahd_outb(ahd, SIMODE3, ENNTRAMPERR|ENOSRAMPERR);\r\nif ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {\r\nahd_outb(ahd, OPTIONMODE, AUTOACKEN|AUTO_MSGOUT_DE);\r\n} else {\r\nahd_outb(ahd, OPTIONMODE, AUTOACKEN|BUSFREEREV|AUTO_MSGOUT_DE);\r\n}\r\nahd_outb(ahd, SCSCHKN, CURRFIFODEF|WIDERESEN|SHVALIDSTDIS);\r\nif ((ahd->chip & AHD_BUS_MASK) == AHD_PCIX)\r\nahd_outb(ahd, PCIXCTL, ahd_inb(ahd, PCIXCTL) | SPLTSTADIS);\r\nif ((ahd->bugs & AHD_LQOOVERRUN_BUG) != 0)\r\nahd_outb(ahd, LQOSCSCTL, LQONOCHKOVER);\r\nif ((ahd->flags & AHD_HP_BOARD) != 0) {\r\nfor (i = 0; i < NUMDSPS; i++) {\r\nahd_outb(ahd, DSPSELECT, i);\r\nahd_outb(ahd, WRTBIASCTL, WRTBIASCTL_HP_DEFAULT);\r\n}\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("%s: WRTBIASCTL now 0x%x\n", ahd_name(ahd),\r\nWRTBIASCTL_HP_DEFAULT);\r\n#endif\r\n}\r\nahd_setup_iocell_workaround(ahd);\r\nahd_outb(ahd, LQIMODE1, ENLQIPHASE_LQ|ENLQIPHASE_NLQ|ENLIQABORT\r\n| ENLQICRCI_LQ|ENLQICRCI_NLQ|ENLQIBADLQI\r\n| ENLQIOVERI_LQ|ENLQIOVERI_NLQ);\r\nahd_outb(ahd, LQOMODE0, ENLQOATNLQ|ENLQOATNPKT|ENLQOTCRC);\r\nahd_outb(ahd, LQOMODE1, ENLQOBUSFREE);\r\nahd_outw(ahd, INTVEC1_ADDR, ahd_resolve_seqaddr(ahd, LABEL_seq_isr));\r\nahd_outw(ahd, INTVEC2_ADDR, ahd_resolve_seqaddr(ahd, LABEL_timer_isr));\r\nif ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {\r\nahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb,\r\npkt_long_lun));\r\n} else {\r\nahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb, lun));\r\n}\r\nahd_outb(ahd, CMDLENPTR, offsetof(struct hardware_scb, cdb_len));\r\nahd_outb(ahd, ATTRPTR, offsetof(struct hardware_scb, task_attribute));\r\nahd_outb(ahd, FLAGPTR, offsetof(struct hardware_scb, task_management));\r\nahd_outb(ahd, CMDPTR, offsetof(struct hardware_scb,\r\nshared_data.idata.cdb));\r\nahd_outb(ahd, QNEXTPTR,\r\noffsetof(struct hardware_scb, next_hscb_busaddr));\r\nahd_outb(ahd, ABRTBITPTR, MK_MESSAGE_BIT_OFFSET);\r\nahd_outb(ahd, ABRTBYTEPTR, offsetof(struct hardware_scb, control));\r\nif ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {\r\nahd_outb(ahd, LUNLEN,\r\nsizeof(ahd->next_queued_hscb->pkt_long_lun) - 1);\r\n} else {\r\nahd_outb(ahd, LUNLEN, LUNLEN_SINGLE_LEVEL_LUN);\r\n}\r\nahd_outb(ahd, CDBLIMIT, SCB_CDB_LEN_PTR - 1);\r\nahd_outb(ahd, MAXCMD, 0xFF);\r\nahd_outb(ahd, SCBAUTOPTR,\r\nAUSCBPTR_EN | offsetof(struct hardware_scb, tag));\r\nahd_outb(ahd, MULTARGID, 0);\r\nahd_outb(ahd, MULTARGID + 1, 0);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nif ((ahd->features & AHD_NEW_IOCELL_OPTS) == 0) {\r\nfor (target = 0; target < AHD_NUM_TARGETS; target++) {\r\nahd_outb(ahd, NEGOADDR, target);\r\nahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PER_DEV0);\r\nfor (i = 0; i < AHD_NUM_PER_DEV_ANNEXCOLS; i++)\r\nahd_outb(ahd, ANNEXDAT, 0);\r\n}\r\n}\r\nfor (target = 0; target < AHD_NUM_TARGETS; target++) {\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\ntinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\r\ntarget, &tstate);\r\nahd_compile_devinfo(&devinfo, ahd->our_id,\r\ntarget, CAM_LUN_WILDCARD,\r\n'A', ROLE_INITIATOR);\r\nahd_update_neg_table(ahd, &devinfo, &tinfo->curr);\r\n}\r\nahd_outb(ahd, CLRSINT3, NTRAMPERR|OSRAMPERR);\r\nahd_outb(ahd, CLRINT, CLRSCSIINT);\r\n#ifdef NEEDS_MORE_TESTING\r\nif ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0)\r\nahd_outb(ahd, LQCTL1, ABORTPENDING);\r\nelse\r\n#endif\r\nahd_outb(ahd, LQCTL1, 0);\r\nahd->qoutfifonext = 0;\r\nahd->qoutfifonext_valid_tag = QOUTFIFO_ENTRY_VALID;\r\nahd_outb(ahd, QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID);\r\nfor (i = 0; i < AHD_QOUT_SIZE; i++)\r\nahd->qoutfifo[i].valid_tag = 0;\r\nahd_sync_qoutfifo(ahd, BUS_DMASYNC_PREREAD);\r\nahd->qinfifonext = 0;\r\nfor (i = 0; i < AHD_QIN_SIZE; i++)\r\nahd->qinfifo[i] = SCB_LIST_NULL;\r\nif ((ahd->features & AHD_TARGETMODE) != 0) {\r\nfor (i = 0; i < AHD_TMODE_CMDS; i++)\r\nahd->targetcmds[i].cmd_valid = 0;\r\nahd_sync_tqinfifo(ahd, BUS_DMASYNC_PREREAD);\r\nahd->tqinfifonext = 1;\r\nahd_outb(ahd, KERNEL_TQINPOS, ahd->tqinfifonext - 1);\r\nahd_outb(ahd, TQINPOS, ahd->tqinfifonext);\r\n}\r\nahd_outb(ahd, SEQ_FLAGS, 0);\r\nahd_outb(ahd, SEQ_FLAGS2, 0);\r\nahd_outw(ahd, WAITING_TID_HEAD, SCB_LIST_NULL);\r\nahd_outw(ahd, WAITING_TID_TAIL, SCB_LIST_NULL);\r\nahd_outw(ahd, MK_MESSAGE_SCB, SCB_LIST_NULL);\r\nahd_outw(ahd, MK_MESSAGE_SCSIID, 0xFF);\r\nfor (i = 0; i < AHD_NUM_TARGETS; i++)\r\nahd_outw(ahd, WAITING_SCB_TAILS + (2 * i), SCB_LIST_NULL);\r\nahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);\r\nahd_outw(ahd, COMPLETE_SCB_DMAINPROG_HEAD, SCB_LIST_NULL);\r\nahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);\r\nahd_outw(ahd, COMPLETE_DMA_SCB_TAIL, SCB_LIST_NULL);\r\nahd_outw(ahd, COMPLETE_ON_QFREEZE_HEAD, SCB_LIST_NULL);\r\nahd->qfreeze_cnt = 0;\r\nahd_outw(ahd, QFREEZE_COUNT, 0);\r\nahd_outw(ahd, KERNEL_QFREEZE_COUNT, 0);\r\nbusaddr = ahd->shared_data_map.physaddr;\r\nahd_outl(ahd, SHARED_DATA_ADDR, busaddr);\r\nahd_outl(ahd, QOUTFIFO_NEXT_ADDR, busaddr);\r\nscsiseq_template = ENAUTOATNP;\r\nif ((ahd->flags & AHD_INITIATORROLE) != 0)\r\nscsiseq_template |= ENRSELI;\r\nahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq_template);\r\nfor (target = 0; target < AHD_NUM_TARGETS; target++) {\r\nint lun;\r\nfor (lun = 0; lun < AHD_NUM_LUNS_NONPKT; lun++)\r\nahd_unbusy_tcl(ahd, BUILD_TCL_RAW(target, 'A', lun));\r\n}\r\nahd_outb(ahd, CMDSIZE_TABLE, 5);\r\nahd_outb(ahd, CMDSIZE_TABLE + 1, 9);\r\nahd_outb(ahd, CMDSIZE_TABLE + 2, 9);\r\nahd_outb(ahd, CMDSIZE_TABLE + 3, 0);\r\nahd_outb(ahd, CMDSIZE_TABLE + 4, 15);\r\nahd_outb(ahd, CMDSIZE_TABLE + 5, 11);\r\nahd_outb(ahd, CMDSIZE_TABLE + 6, 0);\r\nahd_outb(ahd, CMDSIZE_TABLE + 7, 0);\r\nahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\r\nahd_outb(ahd, QOFF_CTLSTA, SCB_QSIZE_512);\r\nahd->qinfifonext = 0;\r\nahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\r\nahd_set_hescb_qoff(ahd, 0);\r\nahd_set_snscb_qoff(ahd, 0);\r\nahd_set_sescb_qoff(ahd, 0);\r\nahd_set_sdscb_qoff(ahd, 0);\r\nbusaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);\r\nahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);\r\nahd_outw(ahd, INT_COALESCING_CMDCOUNT, 0);\r\nahd_outw(ahd, CMDS_PENDING, 0);\r\nahd_update_coalescing_values(ahd, ahd->int_coalescing_timer,\r\nahd->int_coalescing_maxcmds,\r\nahd->int_coalescing_mincmds);\r\nahd_enable_coalescing(ahd, FALSE);\r\nahd_loadseq(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nif (ahd->features & AHD_AIC79XXB_SLOWCRC) {\r\nu_int negodat3 = ahd_inb(ahd, NEGCONOPTS);\r\nnegodat3 |= ENSLOWCRC;\r\nahd_outb(ahd, NEGCONOPTS, negodat3);\r\nnegodat3 = ahd_inb(ahd, NEGCONOPTS);\r\nif (!(negodat3 & ENSLOWCRC))\r\nprintk("aic79xx: failed to set the SLOWCRC bit\n");\r\nelse\r\nprintk("aic79xx: SLOWCRC bit set\n");\r\n}\r\n}\r\nint\r\nahd_default_config(struct ahd_softc *ahd)\r\n{\r\nint targ;\r\nahd->our_id = 7;\r\nif (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {\r\nprintk("%s: unable to allocate ahd_tmode_tstate. "\r\n"Failing attach\n", ahd_name(ahd));\r\nreturn (ENOMEM);\r\n}\r\nfor (targ = 0; targ < AHD_NUM_TARGETS; targ++) {\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nuint16_t target_mask;\r\ntinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\r\ntarg, &tstate);\r\ntinfo->user.protocol_version = 4;\r\ntinfo->user.transport_version = 4;\r\ntarget_mask = 0x01 << targ;\r\nahd->user_discenable |= target_mask;\r\ntstate->discenable |= target_mask;\r\nahd->user_tagenable |= target_mask;\r\n#ifdef AHD_FORCE_160\r\ntinfo->user.period = AHD_SYNCRATE_DT;\r\n#else\r\ntinfo->user.period = AHD_SYNCRATE_160;\r\n#endif\r\ntinfo->user.offset = MAX_OFFSET;\r\ntinfo->user.ppr_options = MSG_EXT_PPR_RD_STRM\r\n| MSG_EXT_PPR_WR_FLOW\r\n| MSG_EXT_PPR_HOLD_MCS\r\n| MSG_EXT_PPR_IU_REQ\r\n| MSG_EXT_PPR_QAS_REQ\r\n| MSG_EXT_PPR_DT_REQ;\r\nif ((ahd->features & AHD_RTI) != 0)\r\ntinfo->user.ppr_options |= MSG_EXT_PPR_RTI;\r\ntinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\r\ntinfo->goal.protocol_version = 2;\r\ntinfo->goal.transport_version = 2;\r\ntinfo->curr.protocol_version = 2;\r\ntinfo->curr.transport_version = 2;\r\nahd_compile_devinfo(&devinfo, ahd->our_id,\r\ntarg, CAM_LUN_WILDCARD,\r\n'A', ROLE_INITIATOR);\r\ntstate->tagenable &= ~target_mask;\r\nahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_CUR|AHD_TRANS_GOAL, TRUE);\r\nahd_set_syncrate(ahd, &devinfo, 0, 0,\r\n0, AHD_TRANS_CUR|AHD_TRANS_GOAL,\r\nTRUE);\r\n}\r\nreturn (0);\r\n}\r\nint\r\nahd_parse_cfgdata(struct ahd_softc *ahd, struct seeprom_config *sc)\r\n{\r\nint targ;\r\nint max_targ;\r\nmax_targ = sc->max_targets & CFMAXTARG;\r\nahd->our_id = sc->brtime_id & CFSCSIID;\r\nif (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {\r\nprintk("%s: unable to allocate ahd_tmode_tstate. "\r\n"Failing attach\n", ahd_name(ahd));\r\nreturn (ENOMEM);\r\n}\r\nfor (targ = 0; targ < max_targ; targ++) {\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_transinfo *user_tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nuint16_t target_mask;\r\ntinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\r\ntarg, &tstate);\r\nuser_tinfo = &tinfo->user;\r\ntinfo->user.protocol_version = 4;\r\ntinfo->user.transport_version = 4;\r\ntarget_mask = 0x01 << targ;\r\nahd->user_discenable &= ~target_mask;\r\ntstate->discenable &= ~target_mask;\r\nahd->user_tagenable &= ~target_mask;\r\nif (sc->device_flags[targ] & CFDISC) {\r\ntstate->discenable |= target_mask;\r\nahd->user_discenable |= target_mask;\r\nahd->user_tagenable |= target_mask;\r\n} else {\r\nsc->device_flags[targ] &= ~CFPACKETIZED;\r\n}\r\nuser_tinfo->ppr_options = 0;\r\nuser_tinfo->period = (sc->device_flags[targ] & CFXFER);\r\nif (user_tinfo->period < CFXFER_ASYNC) {\r\nif (user_tinfo->period <= AHD_PERIOD_10MHz)\r\nuser_tinfo->ppr_options |= MSG_EXT_PPR_DT_REQ;\r\nuser_tinfo->offset = MAX_OFFSET;\r\n} else {\r\nuser_tinfo->offset = 0;\r\nuser_tinfo->period = AHD_ASYNC_XFER_PERIOD;\r\n}\r\n#ifdef AHD_FORCE_160\r\nif (user_tinfo->period <= AHD_SYNCRATE_160)\r\nuser_tinfo->period = AHD_SYNCRATE_DT;\r\n#endif\r\nif ((sc->device_flags[targ] & CFPACKETIZED) != 0) {\r\nuser_tinfo->ppr_options |= MSG_EXT_PPR_RD_STRM\r\n| MSG_EXT_PPR_WR_FLOW\r\n| MSG_EXT_PPR_HOLD_MCS\r\n| MSG_EXT_PPR_IU_REQ;\r\nif ((ahd->features & AHD_RTI) != 0)\r\nuser_tinfo->ppr_options |= MSG_EXT_PPR_RTI;\r\n}\r\nif ((sc->device_flags[targ] & CFQAS) != 0)\r\nuser_tinfo->ppr_options |= MSG_EXT_PPR_QAS_REQ;\r\nif ((sc->device_flags[targ] & CFWIDEB) != 0)\r\nuser_tinfo->width = MSG_EXT_WDTR_BUS_16_BIT;\r\nelse\r\nuser_tinfo->width = MSG_EXT_WDTR_BUS_8_BIT;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0)\r\nprintk("(%d): %x:%x:%x:%x\n", targ, user_tinfo->width,\r\nuser_tinfo->period, user_tinfo->offset,\r\nuser_tinfo->ppr_options);\r\n#endif\r\ntstate->tagenable &= ~target_mask;\r\ntinfo->goal.protocol_version = 2;\r\ntinfo->goal.transport_version = 2;\r\ntinfo->curr.protocol_version = 2;\r\ntinfo->curr.transport_version = 2;\r\nahd_compile_devinfo(&devinfo, ahd->our_id,\r\ntarg, CAM_LUN_WILDCARD,\r\n'A', ROLE_INITIATOR);\r\nahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_CUR|AHD_TRANS_GOAL, TRUE);\r\nahd_set_syncrate(ahd, &devinfo, 0, 0,\r\n0, AHD_TRANS_CUR|AHD_TRANS_GOAL,\r\nTRUE);\r\n}\r\nahd->flags &= ~AHD_SPCHK_ENB_A;\r\nif (sc->bios_control & CFSPARITY)\r\nahd->flags |= AHD_SPCHK_ENB_A;\r\nahd->flags &= ~AHD_RESET_BUS_A;\r\nif (sc->bios_control & CFRESETB)\r\nahd->flags |= AHD_RESET_BUS_A;\r\nahd->flags &= ~AHD_EXTENDED_TRANS_A;\r\nif (sc->bios_control & CFEXTEND)\r\nahd->flags |= AHD_EXTENDED_TRANS_A;\r\nahd->flags &= ~AHD_BIOS_ENABLED;\r\nif ((sc->bios_control & CFBIOSSTATE) == CFBS_ENABLED)\r\nahd->flags |= AHD_BIOS_ENABLED;\r\nahd->flags &= ~AHD_STPWLEVEL_A;\r\nif ((sc->adapter_control & CFSTPWLEVEL) != 0)\r\nahd->flags |= AHD_STPWLEVEL_A;\r\nreturn (0);\r\n}\r\nint\r\nahd_parse_vpddata(struct ahd_softc *ahd, struct vpd_config *vpd)\r\n{\r\nint error;\r\nerror = ahd_verify_vpd_cksum(vpd);\r\nif (error == 0)\r\nreturn (EINVAL);\r\nif ((vpd->bios_flags & VPDBOOTHOST) != 0)\r\nahd->flags |= AHD_BOOT_CHANNEL;\r\nreturn (0);\r\n}\r\nvoid\r\nahd_intr_enable(struct ahd_softc *ahd, int enable)\r\n{\r\nu_int hcntrl;\r\nhcntrl = ahd_inb(ahd, HCNTRL);\r\nhcntrl &= ~INTEN;\r\nahd->pause &= ~INTEN;\r\nahd->unpause &= ~INTEN;\r\nif (enable) {\r\nhcntrl |= INTEN;\r\nahd->pause |= INTEN;\r\nahd->unpause |= INTEN;\r\n}\r\nahd_outb(ahd, HCNTRL, hcntrl);\r\n}\r\nstatic void\r\nahd_update_coalescing_values(struct ahd_softc *ahd, u_int timer, u_int maxcmds,\r\nu_int mincmds)\r\n{\r\nif (timer > AHD_TIMER_MAX_US)\r\ntimer = AHD_TIMER_MAX_US;\r\nahd->int_coalescing_timer = timer;\r\nif (maxcmds > AHD_INT_COALESCING_MAXCMDS_MAX)\r\nmaxcmds = AHD_INT_COALESCING_MAXCMDS_MAX;\r\nif (mincmds > AHD_INT_COALESCING_MINCMDS_MAX)\r\nmincmds = AHD_INT_COALESCING_MINCMDS_MAX;\r\nahd->int_coalescing_maxcmds = maxcmds;\r\nahd_outw(ahd, INT_COALESCING_TIMER, timer / AHD_TIMER_US_PER_TICK);\r\nahd_outb(ahd, INT_COALESCING_MAXCMDS, -maxcmds);\r\nahd_outb(ahd, INT_COALESCING_MINCMDS, -mincmds);\r\n}\r\nstatic void\r\nahd_enable_coalescing(struct ahd_softc *ahd, int enable)\r\n{\r\nahd->hs_mailbox &= ~ENINT_COALESCE;\r\nif (enable)\r\nahd->hs_mailbox |= ENINT_COALESCE;\r\nahd_outb(ahd, HS_MAILBOX, ahd->hs_mailbox);\r\nahd_flush_device_writes(ahd);\r\nahd_run_qoutfifo(ahd);\r\n}\r\nvoid\r\nahd_pause_and_flushwork(struct ahd_softc *ahd)\r\n{\r\nu_int intstat;\r\nu_int maxloops;\r\nmaxloops = 1000;\r\nahd->flags |= AHD_ALL_INTERRUPTS;\r\nahd_pause(ahd);\r\nahd->qfreeze_cnt--;\r\nahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);\r\nahd_outb(ahd, SEQ_FLAGS2, ahd_inb(ahd, SEQ_FLAGS2) | SELECTOUT_QFROZEN);\r\ndo {\r\nahd_unpause(ahd);\r\nahd_delay(500);\r\nahd_intr(ahd);\r\nahd_pause(ahd);\r\nintstat = ahd_inb(ahd, INTSTAT);\r\nif ((intstat & INT_PEND) == 0) {\r\nahd_clear_critical_section(ahd);\r\nintstat = ahd_inb(ahd, INTSTAT);\r\n}\r\n} while (--maxloops\r\n&& (intstat != 0xFF || (ahd->features & AHD_REMOVABLE) == 0)\r\n&& ((intstat & INT_PEND) != 0\r\n|| (ahd_inb(ahd, SCSISEQ0) & ENSELO) != 0\r\n|| (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) != 0));\r\nif (maxloops == 0) {\r\nprintk("Infinite interrupt loop, INTSTAT = %x",\r\nahd_inb(ahd, INTSTAT));\r\n}\r\nahd->qfreeze_cnt++;\r\nahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);\r\nahd_flush_qoutfifo(ahd);\r\nahd->flags &= ~AHD_ALL_INTERRUPTS;\r\n}\r\nint\r\nahd_suspend(struct ahd_softc *ahd)\r\n{\r\nahd_pause_and_flushwork(ahd);\r\nif (LIST_FIRST(&ahd->pending_scbs) != NULL) {\r\nahd_unpause(ahd);\r\nreturn (EBUSY);\r\n}\r\nahd_shutdown(ahd);\r\nreturn (0);\r\n}\r\nvoid\r\nahd_resume(struct ahd_softc *ahd)\r\n{\r\nahd_reset(ahd, TRUE);\r\nahd_intr_enable(ahd, TRUE);\r\nahd_restart(ahd);\r\n}\r\nstatic inline u_int\r\nahd_index_busy_tcl(struct ahd_softc *ahd, u_int *saved_scbid, u_int tcl)\r\n{\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\n*saved_scbid = ahd_get_scbptr(ahd);\r\nahd_set_scbptr(ahd, TCL_LUN(tcl)\r\n| ((TCL_TARGET_OFFSET(tcl) & 0xC) << 4));\r\nreturn (((TCL_TARGET_OFFSET(tcl) & 0x3) << 1) + SCB_DISCONNECTED_LISTS);\r\n}\r\nstatic u_int\r\nahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl)\r\n{\r\nu_int scbid;\r\nu_int scb_offset;\r\nu_int saved_scbptr;\r\nscb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);\r\nscbid = ahd_inw_scbram(ahd, scb_offset);\r\nahd_set_scbptr(ahd, saved_scbptr);\r\nreturn (scbid);\r\n}\r\nstatic void\r\nahd_busy_tcl(struct ahd_softc *ahd, u_int tcl, u_int scbid)\r\n{\r\nu_int scb_offset;\r\nu_int saved_scbptr;\r\nscb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);\r\nahd_outw(ahd, scb_offset, scbid);\r\nahd_set_scbptr(ahd, saved_scbptr);\r\n}\r\nstatic int\r\nahd_match_scb(struct ahd_softc *ahd, struct scb *scb, int target,\r\nchar channel, int lun, u_int tag, role_t role)\r\n{\r\nint targ = SCB_GET_TARGET(ahd, scb);\r\nchar chan = SCB_GET_CHANNEL(ahd, scb);\r\nint slun = SCB_GET_LUN(scb);\r\nint match;\r\nmatch = ((chan == channel) || (channel == ALL_CHANNELS));\r\nif (match != 0)\r\nmatch = ((targ == target) || (target == CAM_TARGET_WILDCARD));\r\nif (match != 0)\r\nmatch = ((lun == slun) || (lun == CAM_LUN_WILDCARD));\r\nif (match != 0) {\r\n#ifdef AHD_TARGET_MODE\r\nint group;\r\ngroup = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);\r\nif (role == ROLE_INITIATOR) {\r\nmatch = (group != XPT_FC_GROUP_TMODE)\r\n&& ((tag == SCB_GET_TAG(scb))\r\n|| (tag == SCB_LIST_NULL));\r\n} else if (role == ROLE_TARGET) {\r\nmatch = (group == XPT_FC_GROUP_TMODE)\r\n&& ((tag == scb->io_ctx->csio.tag_id)\r\n|| (tag == SCB_LIST_NULL));\r\n}\r\n#else\r\nmatch = ((tag == SCB_GET_TAG(scb)) || (tag == SCB_LIST_NULL));\r\n#endif\r\n}\r\nreturn match;\r\n}\r\nstatic void\r\nahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nint target;\r\nchar channel;\r\nint lun;\r\ntarget = SCB_GET_TARGET(ahd, scb);\r\nlun = SCB_GET_LUN(scb);\r\nchannel = SCB_GET_CHANNEL(ahd, scb);\r\nahd_search_qinfifo(ahd, target, channel, lun,\r\nSCB_LIST_NULL, ROLE_UNKNOWN,\r\nCAM_REQUEUE_REQ, SEARCH_COMPLETE);\r\nahd_platform_freeze_devq(ahd, scb);\r\n}\r\nvoid\r\nahd_qinfifo_requeue_tail(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nstruct scb *prev_scb;\r\nahd_mode_state saved_modes;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\r\nprev_scb = NULL;\r\nif (ahd_qinfifo_count(ahd) != 0) {\r\nu_int prev_tag;\r\nu_int prev_pos;\r\nprev_pos = AHD_QIN_WRAP(ahd->qinfifonext - 1);\r\nprev_tag = ahd->qinfifo[prev_pos];\r\nprev_scb = ahd_lookup_scb(ahd, prev_tag);\r\n}\r\nahd_qinfifo_requeue(ahd, prev_scb, scb);\r\nahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\r\nahd_restore_modes(ahd, saved_modes);\r\n}\r\nstatic void\r\nahd_qinfifo_requeue(struct ahd_softc *ahd, struct scb *prev_scb,\r\nstruct scb *scb)\r\n{\r\nif (prev_scb == NULL) {\r\nuint32_t busaddr;\r\nbusaddr = ahd_le32toh(scb->hscb->hscb_busaddr);\r\nahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);\r\n} else {\r\nprev_scb->hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;\r\nahd_sync_scb(ahd, prev_scb,\r\nBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\n}\r\nahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);\r\nahd->qinfifonext++;\r\nscb->hscb->next_hscb_busaddr = ahd->next_queued_hscb->hscb_busaddr;\r\nahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\n}\r\nstatic int\r\nahd_qinfifo_count(struct ahd_softc *ahd)\r\n{\r\nu_int qinpos;\r\nu_int wrap_qinpos;\r\nu_int wrap_qinfifonext;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);\r\nqinpos = ahd_get_snscb_qoff(ahd);\r\nwrap_qinpos = AHD_QIN_WRAP(qinpos);\r\nwrap_qinfifonext = AHD_QIN_WRAP(ahd->qinfifonext);\r\nif (wrap_qinfifonext >= wrap_qinpos)\r\nreturn (wrap_qinfifonext - wrap_qinpos);\r\nelse\r\nreturn (wrap_qinfifonext\r\n+ ARRAY_SIZE(ahd->qinfifo) - wrap_qinpos);\r\n}\r\nstatic void\r\nahd_reset_cmds_pending(struct ahd_softc *ahd)\r\n{\r\nstruct scb *scb;\r\nahd_mode_state saved_modes;\r\nu_int pending_cmds;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\r\nahd_flush_qoutfifo(ahd);\r\npending_cmds = 0;\r\nLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\r\npending_cmds++;\r\n}\r\nahd_outw(ahd, CMDS_PENDING, pending_cmds - ahd_qinfifo_count(ahd));\r\nahd_restore_modes(ahd, saved_modes);\r\nahd->flags &= ~AHD_UPDATE_PEND_CMDS;\r\n}\r\nstatic void\r\nahd_done_with_status(struct ahd_softc *ahd, struct scb *scb, uint32_t status)\r\n{\r\ncam_status ostat;\r\ncam_status cstat;\r\nostat = ahd_get_transaction_status(scb);\r\nif (ostat == CAM_REQ_INPROG)\r\nahd_set_transaction_status(scb, status);\r\ncstat = ahd_get_transaction_status(scb);\r\nif (cstat != CAM_REQ_CMP)\r\nahd_freeze_scb(scb);\r\nahd_done(ahd, scb);\r\n}\r\nint\r\nahd_search_qinfifo(struct ahd_softc *ahd, int target, char channel,\r\nint lun, u_int tag, role_t role, uint32_t status,\r\nahd_search_action action)\r\n{\r\nstruct scb *scb;\r\nstruct scb *mk_msg_scb;\r\nstruct scb *prev_scb;\r\nahd_mode_state saved_modes;\r\nu_int qinstart;\r\nu_int qinpos;\r\nu_int qintail;\r\nu_int tid_next;\r\nu_int tid_prev;\r\nu_int scbid;\r\nu_int seq_flags2;\r\nu_int savedscbptr;\r\nuint32_t busaddr;\r\nint found;\r\nint targets;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\r\nif ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN|CCSCBDIR))\r\n== (CCARREN|CCSCBEN|CCSCBDIR)) {\r\nahd_outb(ahd, CCSCBCTL,\r\nahd_inb(ahd, CCSCBCTL) & ~(CCARREN|CCSCBEN));\r\nwhile ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN)) != 0)\r\n;\r\n}\r\nqintail = AHD_QIN_WRAP(ahd->qinfifonext);\r\nqinstart = ahd_get_snscb_qoff(ahd);\r\nqinpos = AHD_QIN_WRAP(qinstart);\r\nfound = 0;\r\nprev_scb = NULL;\r\nif (action == SEARCH_PRINT) {\r\nprintk("qinstart = %d qinfifonext = %d\nQINFIFO:",\r\nqinstart, ahd->qinfifonext);\r\n}\r\nahd->qinfifonext = qinstart;\r\nbusaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);\r\nahd_outl(ahd, NEXT_QUEUED_SCB_ADDR, busaddr);\r\nwhile (qinpos != qintail) {\r\nscb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);\r\nif (scb == NULL) {\r\nprintk("qinpos = %d, SCB index = %d\n",\r\nqinpos, ahd->qinfifo[qinpos]);\r\npanic("Loop 1\n");\r\n}\r\nif (ahd_match_scb(ahd, scb, target, channel, lun, tag, role)) {\r\nfound++;\r\nswitch (action) {\r\ncase SEARCH_COMPLETE:\r\nif ((scb->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB in qinfifo\n");\r\nahd_done_with_status(ahd, scb, status);\r\ncase SEARCH_REMOVE:\r\nbreak;\r\ncase SEARCH_PRINT:\r\nprintk(" 0x%x", ahd->qinfifo[qinpos]);\r\ncase SEARCH_COUNT:\r\nahd_qinfifo_requeue(ahd, prev_scb, scb);\r\nprev_scb = scb;\r\nbreak;\r\n}\r\n} else {\r\nahd_qinfifo_requeue(ahd, prev_scb, scb);\r\nprev_scb = scb;\r\n}\r\nqinpos = AHD_QIN_WRAP(qinpos+1);\r\n}\r\nahd_set_hnscb_qoff(ahd, ahd->qinfifonext);\r\nif (action == SEARCH_PRINT)\r\nprintk("\nWAITING_TID_QUEUES:\n");\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nseq_flags2 = ahd_inb(ahd, SEQ_FLAGS2);\r\nif ((seq_flags2 & PENDING_MK_MESSAGE) != 0) {\r\nscbid = ahd_inw(ahd, MK_MESSAGE_SCB);\r\nmk_msg_scb = ahd_lookup_scb(ahd, scbid);\r\n} else\r\nmk_msg_scb = NULL;\r\nsavedscbptr = ahd_get_scbptr(ahd);\r\ntid_next = ahd_inw(ahd, WAITING_TID_HEAD);\r\ntid_prev = SCB_LIST_NULL;\r\ntargets = 0;\r\nfor (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {\r\nu_int tid_head;\r\nu_int tid_tail;\r\ntargets++;\r\nif (targets > AHD_NUM_TARGETS)\r\npanic("TID LIST LOOP");\r\nif (scbid >= ahd->scb_data.numscbs) {\r\nprintk("%s: Waiting TID List inconsistency. "\r\n"SCB index == 0x%x, yet numscbs == 0x%x.",\r\nahd_name(ahd), scbid, ahd->scb_data.numscbs);\r\nahd_dump_card_state(ahd);\r\npanic("for safety");\r\n}\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: SCB = 0x%x Not Active!\n",\r\nahd_name(ahd), scbid);\r\npanic("Waiting TID List traversal\n");\r\n}\r\nahd_set_scbptr(ahd, scbid);\r\ntid_next = ahd_inw_scbram(ahd, SCB_NEXT2);\r\nif (ahd_match_scb(ahd, scb, target, channel, CAM_LUN_WILDCARD,\r\nSCB_LIST_NULL, ROLE_UNKNOWN) == 0) {\r\ntid_prev = scbid;\r\ncontinue;\r\n}\r\nif (action == SEARCH_PRINT)\r\nprintk(" %d ( ", SCB_GET_TARGET(ahd, scb));\r\ntid_head = scbid;\r\nfound += ahd_search_scb_list(ahd, target, channel,\r\nlun, tag, role, status,\r\naction, &tid_head, &tid_tail,\r\nSCB_GET_TARGET(ahd, scb));\r\nif (mk_msg_scb != NULL\r\n&& ahd_match_scb(ahd, mk_msg_scb, target, channel,\r\nlun, tag, role)) {\r\nfound++;\r\nswitch (action) {\r\ncase SEARCH_COMPLETE:\r\nif ((mk_msg_scb->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB pending MK_MSG\n");\r\nahd_done_with_status(ahd, mk_msg_scb, status);\r\ncase SEARCH_REMOVE:\r\n{\r\nu_int tail_offset;\r\nprintk("Removing MK_MSG scb\n");\r\ntail_offset = WAITING_SCB_TAILS\r\n+ (2 * SCB_GET_TARGET(ahd, mk_msg_scb));\r\nahd_outw(ahd, tail_offset, tid_tail);\r\nseq_flags2 &= ~PENDING_MK_MESSAGE;\r\nahd_outb(ahd, SEQ_FLAGS2, seq_flags2);\r\nahd_outw(ahd, CMDS_PENDING,\r\nahd_inw(ahd, CMDS_PENDING)-1);\r\nmk_msg_scb = NULL;\r\nbreak;\r\n}\r\ncase SEARCH_PRINT:\r\nprintk(" 0x%x", SCB_GET_TAG(scb));\r\ncase SEARCH_COUNT:\r\nbreak;\r\n}\r\n}\r\nif (mk_msg_scb != NULL\r\n&& SCBID_IS_NULL(tid_head)\r\n&& ahd_match_scb(ahd, scb, target, channel, CAM_LUN_WILDCARD,\r\nSCB_LIST_NULL, ROLE_UNKNOWN)) {\r\nprintk("Queueing mk_msg_scb\n");\r\ntid_head = ahd_inw(ahd, MK_MESSAGE_SCB);\r\nseq_flags2 &= ~PENDING_MK_MESSAGE;\r\nahd_outb(ahd, SEQ_FLAGS2, seq_flags2);\r\nmk_msg_scb = NULL;\r\n}\r\nif (tid_head != scbid)\r\nahd_stitch_tid_list(ahd, tid_prev, tid_head, tid_next);\r\nif (!SCBID_IS_NULL(tid_head))\r\ntid_prev = tid_head;\r\nif (action == SEARCH_PRINT)\r\nprintk(")\n");\r\n}\r\nahd_set_scbptr(ahd, savedscbptr);\r\nahd_restore_modes(ahd, saved_modes);\r\nreturn (found);\r\n}\r\nstatic int\r\nahd_search_scb_list(struct ahd_softc *ahd, int target, char channel,\r\nint lun, u_int tag, role_t role, uint32_t status,\r\nahd_search_action action, u_int *list_head,\r\nu_int *list_tail, u_int tid)\r\n{\r\nstruct scb *scb;\r\nu_int scbid;\r\nu_int next;\r\nu_int prev;\r\nint found;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nfound = 0;\r\nprev = SCB_LIST_NULL;\r\nnext = *list_head;\r\n*list_tail = SCB_LIST_NULL;\r\nfor (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {\r\nif (scbid >= ahd->scb_data.numscbs) {\r\nprintk("%s:SCB List inconsistency. "\r\n"SCB == 0x%x, yet numscbs == 0x%x.",\r\nahd_name(ahd), scbid, ahd->scb_data.numscbs);\r\nahd_dump_card_state(ahd);\r\npanic("for safety");\r\n}\r\nscb = ahd_lookup_scb(ahd, scbid);\r\nif (scb == NULL) {\r\nprintk("%s: SCB = %d Not Active!\n",\r\nahd_name(ahd), scbid);\r\npanic("Waiting List traversal\n");\r\n}\r\nahd_set_scbptr(ahd, scbid);\r\n*list_tail = scbid;\r\nnext = ahd_inw_scbram(ahd, SCB_NEXT);\r\nif (ahd_match_scb(ahd, scb, target, channel,\r\nlun, SCB_LIST_NULL, role) == 0) {\r\nprev = scbid;\r\ncontinue;\r\n}\r\nfound++;\r\nswitch (action) {\r\ncase SEARCH_COMPLETE:\r\nif ((scb->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB in Waiting List\n");\r\nahd_done_with_status(ahd, scb, status);\r\ncase SEARCH_REMOVE:\r\nahd_rem_wscb(ahd, scbid, prev, next, tid);\r\n*list_tail = prev;\r\nif (SCBID_IS_NULL(prev))\r\n*list_head = next;\r\nbreak;\r\ncase SEARCH_PRINT:\r\nprintk("0x%x ", scbid);\r\ncase SEARCH_COUNT:\r\nprev = scbid;\r\nbreak;\r\n}\r\nif (found > AHD_SCB_MAX)\r\npanic("SCB LIST LOOP");\r\n}\r\nif (action == SEARCH_COMPLETE\r\n|| action == SEARCH_REMOVE)\r\nahd_outw(ahd, CMDS_PENDING, ahd_inw(ahd, CMDS_PENDING) - found);\r\nreturn (found);\r\n}\r\nstatic void\r\nahd_stitch_tid_list(struct ahd_softc *ahd, u_int tid_prev,\r\nu_int tid_cur, u_int tid_next)\r\n{\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nif (SCBID_IS_NULL(tid_cur)) {\r\nif (SCBID_IS_NULL(tid_prev)) {\r\nahd_outw(ahd, WAITING_TID_HEAD, tid_next);\r\n} else {\r\nahd_set_scbptr(ahd, tid_prev);\r\nahd_outw(ahd, SCB_NEXT2, tid_next);\r\n}\r\nif (SCBID_IS_NULL(tid_next))\r\nahd_outw(ahd, WAITING_TID_TAIL, tid_prev);\r\n} else {\r\nif (SCBID_IS_NULL(tid_prev)) {\r\nahd_outw(ahd, WAITING_TID_HEAD, tid_cur);\r\n} else {\r\nahd_set_scbptr(ahd, tid_prev);\r\nahd_outw(ahd, SCB_NEXT2, tid_cur);\r\n}\r\nahd_set_scbptr(ahd, tid_cur);\r\nahd_outw(ahd, SCB_NEXT2, tid_next);\r\nif (SCBID_IS_NULL(tid_next))\r\nahd_outw(ahd, WAITING_TID_TAIL, tid_cur);\r\n}\r\n}\r\nstatic u_int\r\nahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,\r\nu_int prev, u_int next, u_int tid)\r\n{\r\nu_int tail_offset;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nif (!SCBID_IS_NULL(prev)) {\r\nahd_set_scbptr(ahd, prev);\r\nahd_outw(ahd, SCB_NEXT, next);\r\n}\r\ntail_offset = WAITING_SCB_TAILS + (2 * tid);\r\nif (SCBID_IS_NULL(next)\r\n&& ahd_inw(ahd, tail_offset) == scbid)\r\nahd_outw(ahd, tail_offset, prev);\r\nahd_add_scb_to_free_list(ahd, scbid);\r\nreturn (next);\r\n}\r\nstatic void\r\nahd_add_scb_to_free_list(struct ahd_softc *ahd, u_int scbid)\r\n{\r\n}\r\nstatic int\r\nahd_abort_scbs(struct ahd_softc *ahd, int target, char channel,\r\nint lun, u_int tag, role_t role, uint32_t status)\r\n{\r\nstruct scb *scbp;\r\nstruct scb *scbp_next;\r\nu_int i, j;\r\nu_int maxtarget;\r\nu_int minlun;\r\nu_int maxlun;\r\nint found;\r\nahd_mode_state saved_modes;\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nfound = ahd_search_qinfifo(ahd, target, channel, lun, SCB_LIST_NULL,\r\nrole, CAM_REQUEUE_REQ, SEARCH_COMPLETE);\r\ni = 0;\r\nmaxtarget = 16;\r\nif (target != CAM_TARGET_WILDCARD) {\r\ni = target;\r\nif (channel == 'B')\r\ni += 8;\r\nmaxtarget = i + 1;\r\n}\r\nif (lun == CAM_LUN_WILDCARD) {\r\nminlun = 0;\r\nmaxlun = AHD_NUM_LUNS_NONPKT;\r\n} else if (lun >= AHD_NUM_LUNS_NONPKT) {\r\nminlun = maxlun = 0;\r\n} else {\r\nminlun = lun;\r\nmaxlun = lun + 1;\r\n}\r\nif (role != ROLE_TARGET) {\r\nfor (;i < maxtarget; i++) {\r\nfor (j = minlun;j < maxlun; j++) {\r\nu_int scbid;\r\nu_int tcl;\r\ntcl = BUILD_TCL_RAW(i, 'A', j);\r\nscbid = ahd_find_busy_tcl(ahd, tcl);\r\nscbp = ahd_lookup_scb(ahd, scbid);\r\nif (scbp == NULL\r\n|| ahd_match_scb(ahd, scbp, target, channel,\r\nlun, tag, role) == 0)\r\ncontinue;\r\nahd_unbusy_tcl(ahd, BUILD_TCL_RAW(i, 'A', j));\r\n}\r\n}\r\n}\r\nahd_flush_qoutfifo(ahd);\r\nscbp_next = LIST_FIRST(&ahd->pending_scbs);\r\nwhile (scbp_next != NULL) {\r\nscbp = scbp_next;\r\nscbp_next = LIST_NEXT(scbp, pending_links);\r\nif (ahd_match_scb(ahd, scbp, target, channel, lun, tag, role)) {\r\ncam_status ostat;\r\nostat = ahd_get_transaction_status(scbp);\r\nif (ostat == CAM_REQ_INPROG)\r\nahd_set_transaction_status(scbp, status);\r\nif (ahd_get_transaction_status(scbp) != CAM_REQ_CMP)\r\nahd_freeze_scb(scbp);\r\nif ((scbp->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB on pending list\n");\r\nahd_done(ahd, scbp);\r\nfound++;\r\n}\r\n}\r\nahd_restore_modes(ahd, saved_modes);\r\nahd_platform_abort_scbs(ahd, target, channel, lun, tag, role, status);\r\nahd->flags |= AHD_UPDATE_PEND_CMDS;\r\nreturn found;\r\n}\r\nstatic void\r\nahd_reset_current_bus(struct ahd_softc *ahd)\r\n{\r\nuint8_t scsiseq;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) & ~ENSCSIRST);\r\nscsiseq = ahd_inb(ahd, SCSISEQ0) & ~(ENSELO|ENARBO|SCSIRSTO);\r\nahd_outb(ahd, SCSISEQ0, scsiseq | SCSIRSTO);\r\nahd_flush_device_writes(ahd);\r\nahd_delay(AHD_BUSRESET_DELAY);\r\nahd_outb(ahd, SCSISEQ0, scsiseq);\r\nahd_flush_device_writes(ahd);\r\nahd_delay(AHD_BUSRESET_DELAY);\r\nif ((ahd->bugs & AHD_SCSIRST_BUG) != 0) {\r\nahd_reset(ahd, TRUE);\r\nahd_intr_enable(ahd, TRUE);\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\n}\r\nahd_clear_intstat(ahd);\r\n}\r\nint\r\nahd_reset_channel(struct ahd_softc *ahd, char channel, int initiate_reset)\r\n{\r\nstruct ahd_devinfo caminfo;\r\nu_int initiator;\r\nu_int target;\r\nu_int max_scsiid;\r\nint found;\r\nu_int fifo;\r\nu_int next_fifo;\r\nuint8_t scsiseq;\r\nif (ahd->flags & AHD_BUS_RESET_ACTIVE) {\r\nprintk("%s: bus reset still active\n",\r\nahd_name(ahd));\r\nreturn 0;\r\n}\r\nahd->flags |= AHD_BUS_RESET_ACTIVE;\r\nahd->pending_device = NULL;\r\nahd_compile_devinfo(&caminfo,\r\nCAM_TARGET_WILDCARD,\r\nCAM_TARGET_WILDCARD,\r\nCAM_LUN_WILDCARD,\r\nchannel, ROLE_UNKNOWN);\r\nahd_pause(ahd);\r\nahd_clear_critical_section(ahd);\r\nahd_run_qoutfifo(ahd);\r\n#ifdef AHD_TARGET_MODE\r\nif ((ahd->flags & AHD_TARGETROLE) != 0) {\r\nahd_run_tqinfifo(ahd, TRUE);\r\n}\r\n#endif\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, SCSISEQ0, 0);\r\nahd_outb(ahd, SCSISEQ1, 0);\r\nnext_fifo = fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;\r\nif (next_fifo > CURRFIFO_1)\r\nnext_fifo = fifo = 0;\r\ndo {\r\nnext_fifo ^= CURRFIFO_1;\r\nahd_set_modes(ahd, next_fifo, next_fifo);\r\nahd_outb(ahd, DFCNTRL,\r\nahd_inb(ahd, DFCNTRL) & ~(SCSIEN|HDMAEN));\r\nwhile ((ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0)\r\nahd_delay(10);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, DFFSTAT, next_fifo);\r\n} while (next_fifo != fifo);\r\nahd_clear_msg_state(ahd);\r\nahd_outb(ahd, SIMODE1,\r\nahd_inb(ahd, SIMODE1) & ~(ENBUSFREE|ENSCSIRST));\r\nif (initiate_reset)\r\nahd_reset_current_bus(ahd);\r\nahd_clear_intstat(ahd);\r\nfound = ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, channel,\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL,\r\nROLE_UNKNOWN, CAM_SCSI_BUS_RESET);\r\nahd_clear_fifo(ahd, 0);\r\nahd_clear_fifo(ahd, 1);\r\nahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);\r\nahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) | ENSCSIRST);\r\nscsiseq = ahd_inb(ahd, SCSISEQ_TEMPLATE);\r\nahd_outb(ahd, SCSISEQ1, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));\r\nmax_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;\r\n#ifdef AHD_TARGET_MODE\r\nfor (target = 0; target <= max_scsiid; target++) {\r\nstruct ahd_tmode_tstate* tstate;\r\nu_int lun;\r\ntstate = ahd->enabled_targets[target];\r\nif (tstate == NULL)\r\ncontinue;\r\nfor (lun = 0; lun < AHD_NUM_LUNS; lun++) {\r\nstruct ahd_tmode_lstate* lstate;\r\nlstate = tstate->enabled_luns[lun];\r\nif (lstate == NULL)\r\ncontinue;\r\nahd_queue_lstate_event(ahd, lstate, CAM_TARGET_WILDCARD,\r\nEVENT_TYPE_BUS_RESET, 0);\r\nahd_send_lstate_events(ahd, lstate);\r\n}\r\n}\r\n#endif\r\nfor (target = 0; target <= max_scsiid; target++) {\r\nif (ahd->enabled_targets[target] == NULL)\r\ncontinue;\r\nfor (initiator = 0; initiator <= max_scsiid; initiator++) {\r\nstruct ahd_devinfo devinfo;\r\nahd_compile_devinfo(&devinfo, target, initiator,\r\nCAM_LUN_WILDCARD,\r\n'A', ROLE_UNKNOWN);\r\nahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_CUR, TRUE);\r\nahd_set_syncrate(ahd, &devinfo, 0,\r\n0, 0,\r\nAHD_TRANS_CUR, TRUE);\r\n}\r\n}\r\nahd_send_async(ahd, caminfo.channel, CAM_TARGET_WILDCARD,\r\nCAM_LUN_WILDCARD, AC_BUS_RESET);\r\nahd_restart(ahd);\r\nreturn (found);\r\n}\r\nstatic void\r\nahd_stat_timer(void *arg)\r\n{\r\nstruct ahd_softc *ahd = arg;\r\nu_long s;\r\nint enint_coal;\r\nahd_lock(ahd, &s);\r\nenint_coal = ahd->hs_mailbox & ENINT_COALESCE;\r\nif (ahd->cmdcmplt_total > ahd->int_coalescing_threshold)\r\nenint_coal |= ENINT_COALESCE;\r\nelse if (ahd->cmdcmplt_total < ahd->int_coalescing_stop_threshold)\r\nenint_coal &= ~ENINT_COALESCE;\r\nif (enint_coal != (ahd->hs_mailbox & ENINT_COALESCE)) {\r\nahd_enable_coalescing(ahd, enint_coal);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_INT_COALESCING) != 0)\r\nprintk("%s: Interrupt coalescing "\r\n"now %sabled. Cmds %d\n",\r\nahd_name(ahd),\r\n(enint_coal & ENINT_COALESCE) ? "en" : "dis",\r\nahd->cmdcmplt_total);\r\n#endif\r\n}\r\nahd->cmdcmplt_bucket = (ahd->cmdcmplt_bucket+1) & (AHD_STAT_BUCKETS-1);\r\nahd->cmdcmplt_total -= ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket];\r\nahd->cmdcmplt_counts[ahd->cmdcmplt_bucket] = 0;\r\nahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,\r\nahd_stat_timer, ahd);\r\nahd_unlock(ahd, &s);\r\n}\r\nstatic void\r\nahd_handle_scsi_status(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nstruct hardware_scb *hscb;\r\nint paused;\r\nhscb = scb->hscb;\r\nif (ahd_is_paused(ahd)) {\r\npaused = 1;\r\n} else {\r\npaused = 0;\r\nahd_pause(ahd);\r\n}\r\nahd_freeze_devq(ahd, scb);\r\nahd_freeze_scb(scb);\r\nahd->qfreeze_cnt++;\r\nahd_outw(ahd, KERNEL_QFREEZE_COUNT, ahd->qfreeze_cnt);\r\nif (paused == 0)\r\nahd_unpause(ahd);\r\nif ((scb->flags & SCB_SENSE) != 0) {\r\nscb->flags &= ~SCB_SENSE;\r\nahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);\r\nahd_done(ahd, scb);\r\nreturn;\r\n}\r\nahd_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);\r\nahd_set_scsi_status(scb, hscb->shared_data.istatus.scsi_status);\r\nswitch (hscb->shared_data.istatus.scsi_status) {\r\ncase STATUS_PKT_SENSE:\r\n{\r\nstruct scsi_status_iu_header *siu;\r\nahd_sync_sense(ahd, scb, BUS_DMASYNC_POSTREAD);\r\nsiu = (struct scsi_status_iu_header *)scb->sense_data;\r\nahd_set_scsi_status(scb, siu->status);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_SENSE) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("SCB 0x%x Received PKT Status of 0x%x\n",\r\nSCB_GET_TAG(scb), siu->status);\r\nprintk("\tflags = 0x%x, sense len = 0x%x, "\r\n"pktfail = 0x%x\n",\r\nsiu->flags, scsi_4btoul(siu->sense_length),\r\nscsi_4btoul(siu->pkt_failures_length));\r\n}\r\n#endif\r\nif ((siu->flags & SIU_RSPVALID) != 0) {\r\nahd_print_path(ahd, scb);\r\nif (scsi_4btoul(siu->pkt_failures_length) < 4) {\r\nprintk("Unable to parse pkt_failures\n");\r\n} else {\r\nswitch (SIU_PKTFAIL_CODE(siu)) {\r\ncase SIU_PFC_NONE:\r\nprintk("No packet failure found\n");\r\nbreak;\r\ncase SIU_PFC_CIU_FIELDS_INVALID:\r\nprintk("Invalid Command IU Field\n");\r\nbreak;\r\ncase SIU_PFC_TMF_NOT_SUPPORTED:\r\nprintk("TMF not supportd\n");\r\nbreak;\r\ncase SIU_PFC_TMF_FAILED:\r\nprintk("TMF failed\n");\r\nbreak;\r\ncase SIU_PFC_INVALID_TYPE_CODE:\r\nprintk("Invalid L_Q Type code\n");\r\nbreak;\r\ncase SIU_PFC_ILLEGAL_REQUEST:\r\nprintk("Illegal request\n");\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (siu->status == SCSI_STATUS_OK)\r\nahd_set_transaction_status(scb,\r\nCAM_REQ_CMP_ERR);\r\n}\r\nif ((siu->flags & SIU_SNSVALID) != 0) {\r\nscb->flags |= SCB_PKT_SENSE;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_SENSE) != 0)\r\nprintk("Sense data available\n");\r\n#endif\r\n}\r\nahd_done(ahd, scb);\r\nbreak;\r\n}\r\ncase SCSI_STATUS_CMD_TERMINATED:\r\ncase SCSI_STATUS_CHECK_COND:\r\n{\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_dma_seg *sg;\r\nstruct scsi_sense *sc;\r\nstruct ahd_initiator_tinfo *targ_info;\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_transinfo *tinfo;\r\n#ifdef AHD_DEBUG\r\nif (ahd_debug & AHD_SHOW_SENSE) {\r\nahd_print_path(ahd, scb);\r\nprintk("SCB %d: requests Check Status\n",\r\nSCB_GET_TAG(scb));\r\n}\r\n#endif\r\nif (ahd_perform_autosense(scb) == 0)\r\nbreak;\r\nahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),\r\nSCB_GET_TARGET(ahd, scb),\r\nSCB_GET_LUN(scb),\r\nSCB_GET_CHANNEL(ahd, scb),\r\nROLE_INITIATOR);\r\ntarg_info = ahd_fetch_transinfo(ahd,\r\ndevinfo.channel,\r\ndevinfo.our_scsiid,\r\ndevinfo.target,\r\n&tstate);\r\ntinfo = &targ_info->curr;\r\nsg = scb->sg_list;\r\nsc = (struct scsi_sense *)hscb->shared_data.idata.cdb;\r\nahd_update_residual(ahd, scb);\r\n#ifdef AHD_DEBUG\r\nif (ahd_debug & AHD_SHOW_SENSE) {\r\nahd_print_path(ahd, scb);\r\nprintk("Sending Sense\n");\r\n}\r\n#endif\r\nscb->sg_count = 0;\r\nsg = ahd_sg_setup(ahd, scb, sg, ahd_get_sense_bufaddr(ahd, scb),\r\nahd_get_sense_bufsize(ahd, scb),\r\nTRUE);\r\nsc->opcode = REQUEST_SENSE;\r\nsc->byte2 = 0;\r\nif (tinfo->protocol_version <= SCSI_REV_2\r\n&& SCB_GET_LUN(scb) < 8)\r\nsc->byte2 = SCB_GET_LUN(scb) << 5;\r\nsc->unused[0] = 0;\r\nsc->unused[1] = 0;\r\nsc->length = ahd_get_sense_bufsize(ahd, scb);\r\nsc->control = 0;\r\nhscb->control = 0;\r\nif (ahd_get_residual(scb) == ahd_get_transfer_length(scb)) {\r\nahd_update_neg_request(ahd, &devinfo,\r\ntstate, targ_info,\r\nAHD_NEG_IF_NON_ASYNC);\r\n}\r\nif (tstate->auto_negotiate & devinfo.target_mask) {\r\nhscb->control |= MK_MESSAGE;\r\nscb->flags &=\r\n~(SCB_NEGOTIATE|SCB_ABORT|SCB_DEVICE_RESET);\r\nscb->flags |= SCB_AUTO_NEGOTIATE;\r\n}\r\nhscb->cdb_len = sizeof(*sc);\r\nahd_setup_data_scb(ahd, scb);\r\nscb->flags |= SCB_SENSE;\r\nahd_queue_scb(ahd, scb);\r\nbreak;\r\n}\r\ncase SCSI_STATUS_OK:\r\nprintk("%s: Interrupted for staus of 0???\n",\r\nahd_name(ahd));\r\ndefault:\r\nahd_done(ahd, scb);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nahd_handle_scb_status(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nif (scb->hscb->shared_data.istatus.scsi_status != 0) {\r\nahd_handle_scsi_status(ahd, scb);\r\n} else {\r\nahd_calc_residual(ahd, scb);\r\nahd_done(ahd, scb);\r\n}\r\n}\r\nstatic void\r\nahd_calc_residual(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nstruct hardware_scb *hscb;\r\nstruct initiator_status *spkt;\r\nuint32_t sgptr;\r\nuint32_t resid_sgptr;\r\nuint32_t resid;\r\nhscb = scb->hscb;\r\nsgptr = ahd_le32toh(hscb->sgptr);\r\nif ((sgptr & SG_STATUS_VALID) == 0)\r\nreturn;\r\nsgptr &= ~SG_STATUS_VALID;\r\nif ((sgptr & SG_LIST_NULL) != 0)\r\nreturn;\r\nspkt = &hscb->shared_data.istatus;\r\nresid_sgptr = ahd_le32toh(spkt->residual_sgptr);\r\nif ((sgptr & SG_FULL_RESID) != 0) {\r\nresid = ahd_get_transfer_length(scb);\r\n} else if ((resid_sgptr & SG_LIST_NULL) != 0) {\r\nreturn;\r\n} else if ((resid_sgptr & SG_OVERRUN_RESID) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("data overrun detected Tag == 0x%x.\n",\r\nSCB_GET_TAG(scb));\r\nahd_freeze_devq(ahd, scb);\r\nahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);\r\nahd_freeze_scb(scb);\r\nreturn;\r\n} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {\r\npanic("Bogus resid sgptr value 0x%x\n", resid_sgptr);\r\n} else {\r\nstruct ahd_dma_seg *sg;\r\nresid = ahd_le32toh(spkt->residual_datacnt) & AHD_SG_LEN_MASK;\r\nsg = ahd_sg_bus_to_virt(ahd, scb, resid_sgptr & SG_PTR_MASK);\r\nsg--;\r\nwhile ((ahd_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {\r\nsg++;\r\nresid += ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;\r\n}\r\n}\r\nif ((scb->flags & SCB_SENSE) == 0)\r\nahd_set_residual(scb, resid);\r\nelse\r\nahd_set_sense_residual(scb, resid);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("Handled %sResidual of %d bytes\n",\r\n(scb->flags & SCB_SENSE) ? "Sense " : "", resid);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nahd_queue_lstate_event(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate,\r\nu_int initiator_id, u_int event_type, u_int event_arg)\r\n{\r\nstruct ahd_tmode_event *event;\r\nint pending;\r\nxpt_freeze_devq(lstate->path, 1);\r\nif (lstate->event_w_idx >= lstate->event_r_idx)\r\npending = lstate->event_w_idx - lstate->event_r_idx;\r\nelse\r\npending = AHD_TMODE_EVENT_BUFFER_SIZE + 1\r\n- (lstate->event_r_idx - lstate->event_w_idx);\r\nif (event_type == EVENT_TYPE_BUS_RESET\r\n|| event_type == MSG_BUS_DEV_RESET) {\r\nlstate->event_r_idx = 0;\r\nlstate->event_w_idx = 0;\r\nxpt_release_devq(lstate->path, pending, FALSE);\r\n}\r\nif (pending == AHD_TMODE_EVENT_BUFFER_SIZE) {\r\nxpt_print_path(lstate->path);\r\nprintk("immediate event %x:%x lost\n",\r\nlstate->event_buffer[lstate->event_r_idx].event_type,\r\nlstate->event_buffer[lstate->event_r_idx].event_arg);\r\nlstate->event_r_idx++;\r\nif (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)\r\nlstate->event_r_idx = 0;\r\nxpt_release_devq(lstate->path, 1, FALSE);\r\n}\r\nevent = &lstate->event_buffer[lstate->event_w_idx];\r\nevent->initiator_id = initiator_id;\r\nevent->event_type = event_type;\r\nevent->event_arg = event_arg;\r\nlstate->event_w_idx++;\r\nif (lstate->event_w_idx == AHD_TMODE_EVENT_BUFFER_SIZE)\r\nlstate->event_w_idx = 0;\r\n}\r\nvoid\r\nahd_send_lstate_events(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate)\r\n{\r\nstruct ccb_hdr *ccbh;\r\nstruct ccb_immed_notify *inot;\r\nwhile (lstate->event_r_idx != lstate->event_w_idx\r\n&& (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {\r\nstruct ahd_tmode_event *event;\r\nevent = &lstate->event_buffer[lstate->event_r_idx];\r\nSLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);\r\ninot = (struct ccb_immed_notify *)ccbh;\r\nswitch (event->event_type) {\r\ncase EVENT_TYPE_BUS_RESET:\r\nccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;\r\nbreak;\r\ndefault:\r\nccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;\r\ninot->message_args[0] = event->event_type;\r\ninot->message_args[1] = event->event_arg;\r\nbreak;\r\n}\r\ninot->initiator_id = event->initiator_id;\r\ninot->sense_len = 0;\r\nxpt_done((union ccb *)inot);\r\nlstate->event_r_idx++;\r\nif (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)\r\nlstate->event_r_idx = 0;\r\n}\r\n}\r\nvoid\r\nahd_dumpseq(struct ahd_softc* ahd)\r\n{\r\nint i;\r\nint max_prog;\r\nmax_prog = 2048;\r\nahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\r\nahd_outw(ahd, PRGMCNT, 0);\r\nfor (i = 0; i < max_prog; i++) {\r\nuint8_t ins_bytes[4];\r\nahd_insb(ahd, SEQRAM, ins_bytes, 4);\r\nprintk("0x%08x\n", ins_bytes[0] << 24\r\n| ins_bytes[1] << 16\r\n| ins_bytes[2] << 8\r\n| ins_bytes[3]);\r\n}\r\n}\r\nstatic void\r\nahd_loadseq(struct ahd_softc *ahd)\r\n{\r\nstruct cs cs_table[num_critical_sections];\r\nu_int begin_set[num_critical_sections];\r\nu_int end_set[num_critical_sections];\r\nconst struct patch *cur_patch;\r\nu_int cs_count;\r\nu_int cur_cs;\r\nu_int i;\r\nint downloaded;\r\nu_int skip_addr;\r\nu_int sg_prefetch_cnt;\r\nu_int sg_prefetch_cnt_limit;\r\nu_int sg_prefetch_align;\r\nu_int sg_size;\r\nu_int cacheline_mask;\r\nuint8_t download_consts[DOWNLOAD_CONST_COUNT];\r\nif (bootverbose)\r\nprintk("%s: Downloading Sequencer Program...",\r\nahd_name(ahd));\r\n#if DOWNLOAD_CONST_COUNT != 8\r\n#error "Download Const Mismatch"\r\n#endif\r\ncs_count = 0;\r\ncur_cs = 0;\r\nmemset(begin_set, 0, sizeof(begin_set));\r\nmemset(end_set, 0, sizeof(end_set));\r\nsg_prefetch_align = ahd->pci_cachesize;\r\nif (sg_prefetch_align == 0)\r\nsg_prefetch_align = 8;\r\nwhile (powerof2(sg_prefetch_align) == 0)\r\nsg_prefetch_align--;\r\ncacheline_mask = sg_prefetch_align - 1;\r\nif (sg_prefetch_align > CCSGADDR_MAX/2)\r\nsg_prefetch_align = CCSGADDR_MAX/2;\r\nsg_prefetch_cnt = sg_prefetch_align;\r\nsg_size = sizeof(struct ahd_dma_seg);\r\nif ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)\r\nsg_size = sizeof(struct ahd_dma64_seg);\r\nwhile (sg_prefetch_cnt < sg_size)\r\nsg_prefetch_cnt += sg_prefetch_align;\r\nif ((sg_prefetch_align % sg_size) != 0\r\n&& (sg_prefetch_cnt < CCSGADDR_MAX))\r\nsg_prefetch_cnt += sg_prefetch_align;\r\nsg_prefetch_cnt_limit = -(sg_prefetch_cnt - sg_size + 1);\r\ndownload_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;\r\ndownload_consts[SG_PREFETCH_CNT_LIMIT] = sg_prefetch_cnt_limit;\r\ndownload_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_align - 1);\r\ndownload_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_align - 1);\r\ndownload_consts[SG_SIZEOF] = sg_size;\r\ndownload_consts[PKT_OVERRUN_BUFOFFSET] =\r\n(ahd->overrun_buf - (uint8_t *)ahd->qoutfifo) / 256;\r\ndownload_consts[SCB_TRANSFER_SIZE] = SCB_TRANSFER_SIZE_1BYTE_LUN;\r\ndownload_consts[CACHELINE_MASK] = cacheline_mask;\r\ncur_patch = patches;\r\ndownloaded = 0;\r\nskip_addr = 0;\r\nahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\r\nahd_outw(ahd, PRGMCNT, 0);\r\nfor (i = 0; i < sizeof(seqprog)/4; i++) {\r\nif (ahd_check_patch(ahd, &cur_patch, i, &skip_addr) == 0) {\r\ncontinue;\r\n}\r\nfor (; cur_cs < num_critical_sections; cur_cs++) {\r\nif (critical_sections[cur_cs].end <= i) {\r\nif (begin_set[cs_count] == TRUE\r\n&& end_set[cs_count] == FALSE) {\r\ncs_table[cs_count].end = downloaded;\r\nend_set[cs_count] = TRUE;\r\ncs_count++;\r\n}\r\ncontinue;\r\n}\r\nif (critical_sections[cur_cs].begin <= i\r\n&& begin_set[cs_count] == FALSE) {\r\ncs_table[cs_count].begin = downloaded;\r\nbegin_set[cs_count] = TRUE;\r\n}\r\nbreak;\r\n}\r\nahd_download_instr(ahd, i, download_consts);\r\ndownloaded++;\r\n}\r\nahd->num_critical_sections = cs_count;\r\nif (cs_count != 0) {\r\ncs_count *= sizeof(struct cs);\r\nahd->critical_sections = kmalloc(cs_count, GFP_ATOMIC);\r\nif (ahd->critical_sections == NULL)\r\npanic("ahd_loadseq: Could not malloc");\r\nmemcpy(ahd->critical_sections, cs_table, cs_count);\r\n}\r\nahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE);\r\nif (bootverbose) {\r\nprintk(" %d instructions downloaded\n", downloaded);\r\nprintk("%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n",\r\nahd_name(ahd), ahd->features, ahd->bugs, ahd->flags);\r\n}\r\n}\r\nstatic int\r\nahd_check_patch(struct ahd_softc *ahd, const struct patch **start_patch,\r\nu_int start_instr, u_int *skip_addr)\r\n{\r\nconst struct patch *cur_patch;\r\nconst struct patch *last_patch;\r\nu_int num_patches;\r\nnum_patches = ARRAY_SIZE(patches);\r\nlast_patch = &patches[num_patches];\r\ncur_patch = *start_patch;\r\nwhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\r\nif (cur_patch->patch_func(ahd) == 0) {\r\n*skip_addr = start_instr + cur_patch->skip_instr;\r\ncur_patch += cur_patch->skip_patch;\r\n} else {\r\ncur_patch++;\r\n}\r\n}\r\n*start_patch = cur_patch;\r\nif (start_instr < *skip_addr)\r\nreturn (0);\r\nreturn (1);\r\n}\r\nstatic u_int\r\nahd_resolve_seqaddr(struct ahd_softc *ahd, u_int address)\r\n{\r\nconst struct patch *cur_patch;\r\nint address_offset;\r\nu_int skip_addr;\r\nu_int i;\r\naddress_offset = 0;\r\ncur_patch = patches;\r\nskip_addr = 0;\r\nfor (i = 0; i < address;) {\r\nahd_check_patch(ahd, &cur_patch, i, &skip_addr);\r\nif (skip_addr > i) {\r\nint end_addr;\r\nend_addr = min(address, skip_addr);\r\naddress_offset += end_addr - i;\r\ni = skip_addr;\r\n} else {\r\ni++;\r\n}\r\n}\r\nreturn (address - address_offset);\r\n}\r\nstatic void\r\nahd_download_instr(struct ahd_softc *ahd, u_int instrptr, uint8_t *dconsts)\r\n{\r\nunion ins_formats instr;\r\nstruct ins_format1 *fmt1_ins;\r\nstruct ins_format3 *fmt3_ins;\r\nu_int opcode;\r\ninstr.integer = ahd_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);\r\nfmt1_ins = &instr.format1;\r\nfmt3_ins = NULL;\r\nopcode = instr.format1.opcode;\r\nswitch (opcode) {\r\ncase AIC_OP_JMP:\r\ncase AIC_OP_JC:\r\ncase AIC_OP_JNC:\r\ncase AIC_OP_CALL:\r\ncase AIC_OP_JNE:\r\ncase AIC_OP_JNZ:\r\ncase AIC_OP_JE:\r\ncase AIC_OP_JZ:\r\n{\r\nfmt3_ins = &instr.format3;\r\nfmt3_ins->address = ahd_resolve_seqaddr(ahd, fmt3_ins->address);\r\n}\r\ncase AIC_OP_OR:\r\ncase AIC_OP_AND:\r\ncase AIC_OP_XOR:\r\ncase AIC_OP_ADD:\r\ncase AIC_OP_ADC:\r\ncase AIC_OP_BMOV:\r\nif (fmt1_ins->parity != 0) {\r\nfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\r\n}\r\nfmt1_ins->parity = 0;\r\ncase AIC_OP_ROL:\r\n{\r\nint i, count;\r\nfor (i = 0, count = 0; i < 31; i++) {\r\nuint32_t mask;\r\nmask = 0x01 << i;\r\nif ((instr.integer & mask) != 0)\r\ncount++;\r\n}\r\nif ((count & 0x01) == 0)\r\ninstr.format1.parity = 1;\r\ninstr.integer = ahd_htole32(instr.integer);\r\nahd_outsb(ahd, SEQRAM, instr.bytes, 4);\r\nbreak;\r\n}\r\ndefault:\r\npanic("Unknown opcode encountered in seq program");\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nahd_probe_stack_size(struct ahd_softc *ahd)\r\n{\r\nint last_probe;\r\nlast_probe = 0;\r\nwhile (1) {\r\nint i;\r\nfor (i = 1; i <= last_probe+1; i++) {\r\nahd_outb(ahd, STACK, i & 0xFF);\r\nahd_outb(ahd, STACK, (i >> 8) & 0xFF);\r\n}\r\nfor (i = last_probe+1; i > 0; i--) {\r\nu_int stack_entry;\r\nstack_entry = ahd_inb(ahd, STACK)\r\n|(ahd_inb(ahd, STACK) << 8);\r\nif (stack_entry != i)\r\ngoto sized;\r\n}\r\nlast_probe++;\r\n}\r\nsized:\r\nreturn (last_probe);\r\n}\r\nint\r\nahd_print_register(const ahd_reg_parse_entry_t *table, u_int num_entries,\r\nconst char *name, u_int address, u_int value,\r\nu_int *cur_column, u_int wrap_point)\r\n{\r\nint printed;\r\nu_int printed_mask;\r\nif (cur_column != NULL && *cur_column >= wrap_point) {\r\nprintk("\n");\r\n*cur_column = 0;\r\n}\r\nprinted = printk("%s[0x%x]", name, value);\r\nif (table == NULL) {\r\nprinted += printk(" ");\r\n*cur_column += printed;\r\nreturn (printed);\r\n}\r\nprinted_mask = 0;\r\nwhile (printed_mask != 0xFF) {\r\nint entry;\r\nfor (entry = 0; entry < num_entries; entry++) {\r\nif (((value & table[entry].mask)\r\n!= table[entry].value)\r\n|| ((printed_mask & table[entry].mask)\r\n== table[entry].mask))\r\ncontinue;\r\nprinted += printk("%s%s",\r\nprinted_mask == 0 ? ":(" : "|",\r\ntable[entry].name);\r\nprinted_mask |= table[entry].mask;\r\nbreak;\r\n}\r\nif (entry >= num_entries)\r\nbreak;\r\n}\r\nif (printed_mask != 0)\r\nprinted += printk(") ");\r\nelse\r\nprinted += printk(" ");\r\nif (cur_column != NULL)\r\n*cur_column += printed;\r\nreturn (printed);\r\n}\r\nvoid\r\nahd_dump_card_state(struct ahd_softc *ahd)\r\n{\r\nstruct scb *scb;\r\nahd_mode_state saved_modes;\r\nu_int dffstat;\r\nint paused;\r\nu_int scb_index;\r\nu_int saved_scb_index;\r\nu_int cur_col;\r\nint i;\r\nif (ahd_is_paused(ahd)) {\r\npaused = 1;\r\n} else {\r\npaused = 0;\r\nahd_pause(ahd);\r\n}\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nprintk(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"\r\n"%s: Dumping Card State at program address 0x%x Mode 0x%x\n",\r\nahd_name(ahd),\r\nahd_inw(ahd, CURADDR),\r\nahd_build_mode_state(ahd, ahd->saved_src_mode,\r\nahd->saved_dst_mode));\r\nif (paused)\r\nprintk("Card was paused\n");\r\nif (ahd_check_cmdcmpltqueues(ahd))\r\nprintk("Completions are pending\n");\r\ncur_col = 0;\r\nahd_intstat_print(ahd_inb(ahd, INTSTAT), &cur_col, 50);\r\nahd_seloid_print(ahd_inb(ahd, SELOID), &cur_col, 50);\r\nahd_selid_print(ahd_inb(ahd, SELID), &cur_col, 50);\r\nahd_hs_mailbox_print(ahd_inb(ahd, LOCAL_HS_MAILBOX), &cur_col, 50);\r\nahd_intctl_print(ahd_inb(ahd, INTCTL), &cur_col, 50);\r\nahd_seqintstat_print(ahd_inb(ahd, SEQINTSTAT), &cur_col, 50);\r\nahd_saved_mode_print(ahd_inb(ahd, SAVED_MODE), &cur_col, 50);\r\nahd_dffstat_print(ahd_inb(ahd, DFFSTAT), &cur_col, 50);\r\nahd_scsisigi_print(ahd_inb(ahd, SCSISIGI), &cur_col, 50);\r\nahd_scsiphase_print(ahd_inb(ahd, SCSIPHASE), &cur_col, 50);\r\nahd_scsibus_print(ahd_inb(ahd, SCSIBUS), &cur_col, 50);\r\nahd_lastphase_print(ahd_inb(ahd, LASTPHASE), &cur_col, 50);\r\nahd_scsiseq0_print(ahd_inb(ahd, SCSISEQ0), &cur_col, 50);\r\nahd_scsiseq1_print(ahd_inb(ahd, SCSISEQ1), &cur_col, 50);\r\nahd_seqctl0_print(ahd_inb(ahd, SEQCTL0), &cur_col, 50);\r\nahd_seqintctl_print(ahd_inb(ahd, SEQINTCTL), &cur_col, 50);\r\nahd_seq_flags_print(ahd_inb(ahd, SEQ_FLAGS), &cur_col, 50);\r\nahd_seq_flags2_print(ahd_inb(ahd, SEQ_FLAGS2), &cur_col, 50);\r\nahd_qfreeze_count_print(ahd_inw(ahd, QFREEZE_COUNT), &cur_col, 50);\r\nahd_kernel_qfreeze_count_print(ahd_inw(ahd, KERNEL_QFREEZE_COUNT),\r\n&cur_col, 50);\r\nahd_mk_message_scb_print(ahd_inw(ahd, MK_MESSAGE_SCB), &cur_col, 50);\r\nahd_mk_message_scsiid_print(ahd_inb(ahd, MK_MESSAGE_SCSIID),\r\n&cur_col, 50);\r\nahd_sstat0_print(ahd_inb(ahd, SSTAT0), &cur_col, 50);\r\nahd_sstat1_print(ahd_inb(ahd, SSTAT1), &cur_col, 50);\r\nahd_sstat2_print(ahd_inb(ahd, SSTAT2), &cur_col, 50);\r\nahd_sstat3_print(ahd_inb(ahd, SSTAT3), &cur_col, 50);\r\nahd_perrdiag_print(ahd_inb(ahd, PERRDIAG), &cur_col, 50);\r\nahd_simode1_print(ahd_inb(ahd, SIMODE1), &cur_col, 50);\r\nahd_lqistat0_print(ahd_inb(ahd, LQISTAT0), &cur_col, 50);\r\nahd_lqistat1_print(ahd_inb(ahd, LQISTAT1), &cur_col, 50);\r\nahd_lqistat2_print(ahd_inb(ahd, LQISTAT2), &cur_col, 50);\r\nahd_lqostat0_print(ahd_inb(ahd, LQOSTAT0), &cur_col, 50);\r\nahd_lqostat1_print(ahd_inb(ahd, LQOSTAT1), &cur_col, 50);\r\nahd_lqostat2_print(ahd_inb(ahd, LQOSTAT2), &cur_col, 50);\r\nprintk("\n");\r\nprintk("\nSCB Count = %d CMDS_PENDING = %d LASTSCB 0x%x "\r\n"CURRSCB 0x%x NEXTSCB 0x%x\n",\r\nahd->scb_data.numscbs, ahd_inw(ahd, CMDS_PENDING),\r\nahd_inw(ahd, LASTSCB), ahd_inw(ahd, CURRSCB),\r\nahd_inw(ahd, NEXTSCB));\r\ncur_col = 0;\r\nahd_search_qinfifo(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL,\r\nROLE_UNKNOWN, 0, SEARCH_PRINT);\r\nsaved_scb_index = ahd_get_scbptr(ahd);\r\nprintk("Pending list:");\r\ni = 0;\r\nLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\r\nif (i++ > AHD_SCB_MAX)\r\nbreak;\r\ncur_col = printk("\n%3d FIFO_USE[0x%x] ", SCB_GET_TAG(scb),\r\nahd_inb_scbram(ahd, SCB_FIFO_USE_COUNT));\r\nahd_set_scbptr(ahd, SCB_GET_TAG(scb));\r\nahd_scb_control_print(ahd_inb_scbram(ahd, SCB_CONTROL),\r\n&cur_col, 60);\r\nahd_scb_scsiid_print(ahd_inb_scbram(ahd, SCB_SCSIID),\r\n&cur_col, 60);\r\n}\r\nprintk("\nTotal %d\n", i);\r\nprintk("Kernel Free SCB list: ");\r\ni = 0;\r\nTAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {\r\nstruct scb *list_scb;\r\nlist_scb = scb;\r\ndo {\r\nprintk("%d ", SCB_GET_TAG(list_scb));\r\nlist_scb = LIST_NEXT(list_scb, collision_links);\r\n} while (list_scb && i++ < AHD_SCB_MAX);\r\n}\r\nLIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {\r\nif (i++ > AHD_SCB_MAX)\r\nbreak;\r\nprintk("%d ", SCB_GET_TAG(scb));\r\n}\r\nprintk("\n");\r\nprintk("Sequencer Complete DMA-inprog list: ");\r\nscb_index = ahd_inw(ahd, COMPLETE_SCB_DMAINPROG_HEAD);\r\ni = 0;\r\nwhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\r\nahd_set_scbptr(ahd, scb_index);\r\nprintk("%d ", scb_index);\r\nscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\r\n}\r\nprintk("\n");\r\nprintk("Sequencer Complete list: ");\r\nscb_index = ahd_inw(ahd, COMPLETE_SCB_HEAD);\r\ni = 0;\r\nwhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\r\nahd_set_scbptr(ahd, scb_index);\r\nprintk("%d ", scb_index);\r\nscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\r\n}\r\nprintk("\n");\r\nprintk("Sequencer DMA-Up and Complete list: ");\r\nscb_index = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);\r\ni = 0;\r\nwhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\r\nahd_set_scbptr(ahd, scb_index);\r\nprintk("%d ", scb_index);\r\nscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\r\n}\r\nprintk("\n");\r\nprintk("Sequencer On QFreeze and Complete list: ");\r\nscb_index = ahd_inw(ahd, COMPLETE_ON_QFREEZE_HEAD);\r\ni = 0;\r\nwhile (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {\r\nahd_set_scbptr(ahd, scb_index);\r\nprintk("%d ", scb_index);\r\nscb_index = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);\r\n}\r\nprintk("\n");\r\nahd_set_scbptr(ahd, saved_scb_index);\r\ndffstat = ahd_inb(ahd, DFFSTAT);\r\nfor (i = 0; i < 2; i++) {\r\n#ifdef AHD_DEBUG\r\nstruct scb *fifo_scb;\r\n#endif\r\nu_int fifo_scbptr;\r\nahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);\r\nfifo_scbptr = ahd_get_scbptr(ahd);\r\nprintk("\n\n%s: FIFO%d %s, LONGJMP == 0x%x, SCB 0x%x\n",\r\nahd_name(ahd), i,\r\n(dffstat & (FIFO0FREE << i)) ? "Free" : "Active",\r\nahd_inw(ahd, LONGJMP_ADDR), fifo_scbptr);\r\ncur_col = 0;\r\nahd_seqimode_print(ahd_inb(ahd, SEQIMODE), &cur_col, 50);\r\nahd_seqintsrc_print(ahd_inb(ahd, SEQINTSRC), &cur_col, 50);\r\nahd_dfcntrl_print(ahd_inb(ahd, DFCNTRL), &cur_col, 50);\r\nahd_dfstatus_print(ahd_inb(ahd, DFSTATUS), &cur_col, 50);\r\nahd_sg_cache_shadow_print(ahd_inb(ahd, SG_CACHE_SHADOW),\r\n&cur_col, 50);\r\nahd_sg_state_print(ahd_inb(ahd, SG_STATE), &cur_col, 50);\r\nahd_dffsxfrctl_print(ahd_inb(ahd, DFFSXFRCTL), &cur_col, 50);\r\nahd_soffcnt_print(ahd_inb(ahd, SOFFCNT), &cur_col, 50);\r\nahd_mdffstat_print(ahd_inb(ahd, MDFFSTAT), &cur_col, 50);\r\nif (cur_col > 50) {\r\nprintk("\n");\r\ncur_col = 0;\r\n}\r\ncur_col += printk("SHADDR = 0x%x%x, SHCNT = 0x%x ",\r\nahd_inl(ahd, SHADDR+4),\r\nahd_inl(ahd, SHADDR),\r\n(ahd_inb(ahd, SHCNT)\r\n| (ahd_inb(ahd, SHCNT + 1) << 8)\r\n| (ahd_inb(ahd, SHCNT + 2) << 16)));\r\nif (cur_col > 50) {\r\nprintk("\n");\r\ncur_col = 0;\r\n}\r\ncur_col += printk("HADDR = 0x%x%x, HCNT = 0x%x ",\r\nahd_inl(ahd, HADDR+4),\r\nahd_inl(ahd, HADDR),\r\n(ahd_inb(ahd, HCNT)\r\n| (ahd_inb(ahd, HCNT + 1) << 8)\r\n| (ahd_inb(ahd, HCNT + 2) << 16)));\r\nahd_ccsgctl_print(ahd_inb(ahd, CCSGCTL), &cur_col, 50);\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_SG) != 0) {\r\nfifo_scb = ahd_lookup_scb(ahd, fifo_scbptr);\r\nif (fifo_scb != NULL)\r\nahd_dump_sglist(fifo_scb);\r\n}\r\n#endif\r\n}\r\nprintk("\nLQIN: ");\r\nfor (i = 0; i < 20; i++)\r\nprintk("0x%x ", ahd_inb(ahd, LQIN + i));\r\nprintk("\n");\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nprintk("%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x\n",\r\nahd_name(ahd), ahd_inb(ahd, LQISTATE), ahd_inb(ahd, LQOSTATE),\r\nahd_inb(ahd, OPTIONMODE));\r\nprintk("%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x\n",\r\nahd_name(ahd), ahd_inb(ahd, OS_SPACE_CNT),\r\nahd_inb(ahd, MAXCMDCNT));\r\nprintk("%s: SAVED_SCSIID = 0x%x SAVED_LUN = 0x%x\n",\r\nahd_name(ahd), ahd_inb(ahd, SAVED_SCSIID),\r\nahd_inb(ahd, SAVED_LUN));\r\nahd_simode0_print(ahd_inb(ahd, SIMODE0), &cur_col, 50);\r\nprintk("\n");\r\nahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);\r\ncur_col = 0;\r\nahd_ccscbctl_print(ahd_inb(ahd, CCSCBCTL), &cur_col, 50);\r\nprintk("\n");\r\nahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);\r\nprintk("%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x\n",\r\nahd_name(ahd), ahd_inw(ahd, REG0), ahd_inw(ahd, SINDEX),\r\nahd_inw(ahd, DINDEX));\r\nprintk("%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x\n",\r\nahd_name(ahd), ahd_get_scbptr(ahd),\r\nahd_inw_scbram(ahd, SCB_NEXT),\r\nahd_inw_scbram(ahd, SCB_NEXT2));\r\nprintk("CDB %x %x %x %x %x %x\n",\r\nahd_inb_scbram(ahd, SCB_CDB_STORE),\r\nahd_inb_scbram(ahd, SCB_CDB_STORE+1),\r\nahd_inb_scbram(ahd, SCB_CDB_STORE+2),\r\nahd_inb_scbram(ahd, SCB_CDB_STORE+3),\r\nahd_inb_scbram(ahd, SCB_CDB_STORE+4),\r\nahd_inb_scbram(ahd, SCB_CDB_STORE+5));\r\nprintk("STACK:");\r\nfor (i = 0; i < ahd->stack_size; i++) {\r\nahd->saved_stack[i] =\r\nahd_inb(ahd, STACK)|(ahd_inb(ahd, STACK) << 8);\r\nprintk(" 0x%x", ahd->saved_stack[i]);\r\n}\r\nfor (i = ahd->stack_size-1; i >= 0; i--) {\r\nahd_outb(ahd, STACK, ahd->saved_stack[i] & 0xFF);\r\nahd_outb(ahd, STACK, (ahd->saved_stack[i] >> 8) & 0xFF);\r\n}\r\nprintk("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");\r\nahd_restore_modes(ahd, saved_modes);\r\nif (paused == 0)\r\nahd_unpause(ahd);\r\n}\r\nint\r\nahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,\r\nu_int start_addr, u_int count, int bytestream)\r\n{\r\nu_int cur_addr;\r\nu_int end_addr;\r\nint error;\r\nerror = EINVAL;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nend_addr = start_addr + count;\r\nfor (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {\r\nahd_outb(ahd, SEEADR, cur_addr);\r\nahd_outb(ahd, SEECTL, SEEOP_READ | SEESTART);\r\nerror = ahd_wait_seeprom(ahd);\r\nif (error)\r\nbreak;\r\nif (bytestream != 0) {\r\nuint8_t *bytestream_ptr;\r\nbytestream_ptr = (uint8_t *)buf;\r\n*bytestream_ptr++ = ahd_inb(ahd, SEEDAT);\r\n*bytestream_ptr = ahd_inb(ahd, SEEDAT+1);\r\n} else {\r\n*buf = ahd_inw(ahd, SEEDAT);\r\n}\r\nbuf++;\r\n}\r\nreturn (error);\r\n}\r\nint\r\nahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,\r\nu_int start_addr, u_int count)\r\n{\r\nu_int cur_addr;\r\nu_int end_addr;\r\nint error;\r\nint retval;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nerror = ENOENT;\r\nahd_outb(ahd, SEEADR, SEEOP_EWEN_ADDR);\r\nahd_outb(ahd, SEECTL, SEEOP_EWEN | SEESTART);\r\nerror = ahd_wait_seeprom(ahd);\r\nif (error)\r\nreturn (error);\r\nretval = EINVAL;\r\nend_addr = start_addr + count;\r\nfor (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {\r\nahd_outw(ahd, SEEDAT, *buf++);\r\nahd_outb(ahd, SEEADR, cur_addr);\r\nahd_outb(ahd, SEECTL, SEEOP_WRITE | SEESTART);\r\nretval = ahd_wait_seeprom(ahd);\r\nif (retval)\r\nbreak;\r\n}\r\nahd_outb(ahd, SEEADR, SEEOP_EWDS_ADDR);\r\nahd_outb(ahd, SEECTL, SEEOP_EWDS | SEESTART);\r\nerror = ahd_wait_seeprom(ahd);\r\nif (error)\r\nreturn (error);\r\nreturn (retval);\r\n}\r\nstatic int\r\nahd_wait_seeprom(struct ahd_softc *ahd)\r\n{\r\nint cnt;\r\ncnt = 5000;\r\nwhile ((ahd_inb(ahd, SEESTAT) & (SEEARBACK|SEEBUSY)) != 0 && --cnt)\r\nahd_delay(5);\r\nif (cnt == 0)\r\nreturn (ETIMEDOUT);\r\nreturn (0);\r\n}\r\nstatic int\r\nahd_verify_vpd_cksum(struct vpd_config *vpd)\r\n{\r\nint i;\r\nint maxaddr;\r\nuint32_t checksum;\r\nuint8_t *vpdarray;\r\nvpdarray = (uint8_t *)vpd;\r\nmaxaddr = offsetof(struct vpd_config, vpd_checksum);\r\nchecksum = 0;\r\nfor (i = offsetof(struct vpd_config, resource_type); i < maxaddr; i++)\r\nchecksum = checksum + vpdarray[i];\r\nif (checksum == 0\r\n|| (-checksum & 0xFF) != vpd->vpd_checksum)\r\nreturn (0);\r\nchecksum = 0;\r\nmaxaddr = offsetof(struct vpd_config, checksum);\r\nfor (i = offsetof(struct vpd_config, default_target_flags);\r\ni < maxaddr; i++)\r\nchecksum = checksum + vpdarray[i];\r\nif (checksum == 0\r\n|| (-checksum & 0xFF) != vpd->checksum)\r\nreturn (0);\r\nreturn (1);\r\n}\r\nint\r\nahd_verify_cksum(struct seeprom_config *sc)\r\n{\r\nint i;\r\nint maxaddr;\r\nuint32_t checksum;\r\nuint16_t *scarray;\r\nmaxaddr = (sizeof(*sc)/2) - 1;\r\nchecksum = 0;\r\nscarray = (uint16_t *)sc;\r\nfor (i = 0; i < maxaddr; i++)\r\nchecksum = checksum + scarray[i];\r\nif (checksum == 0\r\n|| (checksum & 0xFFFF) != sc->checksum) {\r\nreturn (0);\r\n} else {\r\nreturn (1);\r\n}\r\n}\r\nint\r\nahd_acquire_seeprom(struct ahd_softc *ahd)\r\n{\r\nreturn (1);\r\n#if 0\r\nuint8_t seetype;\r\nint error;\r\nerror = ahd_read_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, &seetype);\r\nif (error != 0\r\n|| ((seetype & FLX_ROMSTAT_SEECFG) == FLX_ROMSTAT_SEE_NONE))\r\nreturn (0);\r\nreturn (1);\r\n#endif\r\n}\r\nvoid\r\nahd_release_seeprom(struct ahd_softc *ahd)\r\n{\r\n}\r\nstatic int\r\nahd_wait_flexport(struct ahd_softc *ahd)\r\n{\r\nint cnt;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\ncnt = 1000000 * 2 / 5;\r\nwhile ((ahd_inb(ahd, BRDCTL) & FLXARBACK) == 0 && --cnt)\r\nahd_delay(5);\r\nif (cnt == 0)\r\nreturn (ETIMEDOUT);\r\nreturn (0);\r\n}\r\nint\r\nahd_write_flexport(struct ahd_softc *ahd, u_int addr, u_int value)\r\n{\r\nint error;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nif (addr > 7)\r\npanic("ahd_write_flexport: address out of range");\r\nahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));\r\nerror = ahd_wait_flexport(ahd);\r\nif (error != 0)\r\nreturn (error);\r\nahd_outb(ahd, BRDDAT, value);\r\nahd_flush_device_writes(ahd);\r\nahd_outb(ahd, BRDCTL, BRDSTB|BRDEN|(addr << 3));\r\nahd_flush_device_writes(ahd);\r\nahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));\r\nahd_flush_device_writes(ahd);\r\nahd_outb(ahd, BRDCTL, 0);\r\nahd_flush_device_writes(ahd);\r\nreturn (0);\r\n}\r\nint\r\nahd_read_flexport(struct ahd_softc *ahd, u_int addr, uint8_t *value)\r\n{\r\nint error;\r\nAHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);\r\nif (addr > 7)\r\npanic("ahd_read_flexport: address out of range");\r\nahd_outb(ahd, BRDCTL, BRDRW|BRDEN|(addr << 3));\r\nerror = ahd_wait_flexport(ahd);\r\nif (error != 0)\r\nreturn (error);\r\n*value = ahd_inb(ahd, BRDDAT);\r\nahd_outb(ahd, BRDCTL, 0);\r\nahd_flush_device_writes(ahd);\r\nreturn (0);\r\n}\r\ncam_status\r\nahd_find_tmode_devs(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb,\r\nstruct ahd_tmode_tstate **tstate,\r\nstruct ahd_tmode_lstate **lstate,\r\nint notfound_failure)\r\n{\r\nif ((ahd->features & AHD_TARGETMODE) == 0)\r\nreturn (CAM_REQ_INVALID);\r\nif (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD\r\n&& ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {\r\n*tstate = NULL;\r\n*lstate = ahd->black_hole;\r\n} else {\r\nu_int max_id;\r\nmax_id = (ahd->features & AHD_WIDE) ? 16 : 8;\r\nif (ccb->ccb_h.target_id >= max_id)\r\nreturn (CAM_TID_INVALID);\r\nif (ccb->ccb_h.target_lun >= AHD_NUM_LUNS)\r\nreturn (CAM_LUN_INVALID);\r\n*tstate = ahd->enabled_targets[ccb->ccb_h.target_id];\r\n*lstate = NULL;\r\nif (*tstate != NULL)\r\n*lstate =\r\n(*tstate)->enabled_luns[ccb->ccb_h.target_lun];\r\n}\r\nif (notfound_failure != 0 && *lstate == NULL)\r\nreturn (CAM_PATH_INVALID);\r\nreturn (CAM_REQ_CMP);\r\n}\r\nvoid\r\nahd_handle_en_lun(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb)\r\n{\r\n#if NOT_YET\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_tmode_lstate *lstate;\r\nstruct ccb_en_lun *cel;\r\ncam_status status;\r\nu_int target;\r\nu_int lun;\r\nu_int target_mask;\r\nu_long s;\r\nchar channel;\r\nstatus = ahd_find_tmode_devs(ahd, sim, ccb, &tstate, &lstate,\r\nFALSE);\r\nif (status != CAM_REQ_CMP) {\r\nccb->ccb_h.status = status;\r\nreturn;\r\n}\r\nif ((ahd->features & AHD_MULTIROLE) != 0) {\r\nu_int our_id;\r\nour_id = ahd->our_id;\r\nif (ccb->ccb_h.target_id != our_id) {\r\nif ((ahd->features & AHD_MULTI_TID) != 0\r\n&& (ahd->flags & AHD_INITIATORROLE) != 0) {\r\nstatus = CAM_TID_INVALID;\r\n} else if ((ahd->flags & AHD_INITIATORROLE) != 0\r\n|| ahd->enabled_luns > 0) {\r\nstatus = CAM_TID_INVALID;\r\n}\r\n}\r\n}\r\nif (status != CAM_REQ_CMP) {\r\nccb->ccb_h.status = status;\r\nreturn;\r\n}\r\nif ((ahd->flags & AHD_TARGETROLE) == 0\r\n&& ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {\r\nu_long s;\r\nprintk("Configuring Target Mode\n");\r\nahd_lock(ahd, &s);\r\nif (LIST_FIRST(&ahd->pending_scbs) != NULL) {\r\nccb->ccb_h.status = CAM_BUSY;\r\nahd_unlock(ahd, &s);\r\nreturn;\r\n}\r\nahd->flags |= AHD_TARGETROLE;\r\nif ((ahd->features & AHD_MULTIROLE) == 0)\r\nahd->flags &= ~AHD_INITIATORROLE;\r\nahd_pause(ahd);\r\nahd_loadseq(ahd);\r\nahd_restart(ahd);\r\nahd_unlock(ahd, &s);\r\n}\r\ncel = &ccb->cel;\r\ntarget = ccb->ccb_h.target_id;\r\nlun = ccb->ccb_h.target_lun;\r\nchannel = SIM_CHANNEL(ahd, sim);\r\ntarget_mask = 0x01 << target;\r\nif (channel == 'B')\r\ntarget_mask <<= 8;\r\nif (cel->enable != 0) {\r\nu_int scsiseq1;\r\nif (lstate != NULL) {\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Lun already enabled\n");\r\nccb->ccb_h.status = CAM_LUN_ALRDY_ENA;\r\nreturn;\r\n}\r\nif (cel->grp6_len != 0\r\n|| cel->grp7_len != 0) {\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\nprintk("Non-zero Group Codes\n");\r\nreturn;\r\n}\r\nif (target != CAM_TARGET_WILDCARD && tstate == NULL) {\r\ntstate = ahd_alloc_tstate(ahd, target, channel);\r\nif (tstate == NULL) {\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Couldn't allocate tstate\n");\r\nccb->ccb_h.status = CAM_RESRC_UNAVAIL;\r\nreturn;\r\n}\r\n}\r\nlstate = kmalloc(sizeof(*lstate), GFP_ATOMIC);\r\nif (lstate == NULL) {\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Couldn't allocate lstate\n");\r\nccb->ccb_h.status = CAM_RESRC_UNAVAIL;\r\nreturn;\r\n}\r\nmemset(lstate, 0, sizeof(*lstate));\r\nstatus = xpt_create_path(&lstate->path, NULL,\r\nxpt_path_path_id(ccb->ccb_h.path),\r\nxpt_path_target_id(ccb->ccb_h.path),\r\nxpt_path_lun_id(ccb->ccb_h.path));\r\nif (status != CAM_REQ_CMP) {\r\nkfree(lstate);\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Couldn't allocate path\n");\r\nccb->ccb_h.status = CAM_RESRC_UNAVAIL;\r\nreturn;\r\n}\r\nSLIST_INIT(&lstate->accept_tios);\r\nSLIST_INIT(&lstate->immed_notifies);\r\nahd_lock(ahd, &s);\r\nahd_pause(ahd);\r\nif (target != CAM_TARGET_WILDCARD) {\r\ntstate->enabled_luns[lun] = lstate;\r\nahd->enabled_luns++;\r\nif ((ahd->features & AHD_MULTI_TID) != 0) {\r\nu_int targid_mask;\r\ntargid_mask = ahd_inw(ahd, TARGID);\r\ntargid_mask |= target_mask;\r\nahd_outw(ahd, TARGID, targid_mask);\r\nahd_update_scsiid(ahd, targid_mask);\r\n} else {\r\nu_int our_id;\r\nchar channel;\r\nchannel = SIM_CHANNEL(ahd, sim);\r\nour_id = SIM_SCSI_ID(ahd, sim);\r\nif (target != our_id) {\r\nu_int sblkctl;\r\nchar cur_channel;\r\nint swap;\r\nsblkctl = ahd_inb(ahd, SBLKCTL);\r\ncur_channel = (sblkctl & SELBUSB)\r\n? 'B' : 'A';\r\nif ((ahd->features & AHD_TWIN) == 0)\r\ncur_channel = 'A';\r\nswap = cur_channel != channel;\r\nahd->our_id = target;\r\nif (swap)\r\nahd_outb(ahd, SBLKCTL,\r\nsblkctl ^ SELBUSB);\r\nahd_outb(ahd, SCSIID, target);\r\nif (swap)\r\nahd_outb(ahd, SBLKCTL, sblkctl);\r\n}\r\n}\r\n} else\r\nahd->black_hole = lstate;\r\nif (ahd->black_hole != NULL && ahd->enabled_luns > 0) {\r\nscsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);\r\nscsiseq1 |= ENSELI;\r\nahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);\r\nscsiseq1 = ahd_inb(ahd, SCSISEQ1);\r\nscsiseq1 |= ENSELI;\r\nahd_outb(ahd, SCSISEQ1, scsiseq1);\r\n}\r\nahd_unpause(ahd);\r\nahd_unlock(ahd, &s);\r\nccb->ccb_h.status = CAM_REQ_CMP;\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Lun now enabled for target mode\n");\r\n} else {\r\nstruct scb *scb;\r\nint i, empty;\r\nif (lstate == NULL) {\r\nccb->ccb_h.status = CAM_LUN_INVALID;\r\nreturn;\r\n}\r\nahd_lock(ahd, &s);\r\nccb->ccb_h.status = CAM_REQ_CMP;\r\nLIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {\r\nstruct ccb_hdr *ccbh;\r\nccbh = &scb->io_ctx->ccb_h;\r\nif (ccbh->func_code == XPT_CONT_TARGET_IO\r\n&& !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){\r\nprintk("CTIO pending\n");\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\nahd_unlock(ahd, &s);\r\nreturn;\r\n}\r\n}\r\nif (SLIST_FIRST(&lstate->accept_tios) != NULL) {\r\nprintk("ATIOs pending\n");\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\n}\r\nif (SLIST_FIRST(&lstate->immed_notifies) != NULL) {\r\nprintk("INOTs pending\n");\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\n}\r\nif (ccb->ccb_h.status != CAM_REQ_CMP) {\r\nahd_unlock(ahd, &s);\r\nreturn;\r\n}\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Target mode disabled\n");\r\nxpt_free_path(lstate->path);\r\nkfree(lstate);\r\nahd_pause(ahd);\r\nif (target != CAM_TARGET_WILDCARD) {\r\ntstate->enabled_luns[lun] = NULL;\r\nahd->enabled_luns--;\r\nfor (empty = 1, i = 0; i < 8; i++)\r\nif (tstate->enabled_luns[i] != NULL) {\r\nempty = 0;\r\nbreak;\r\n}\r\nif (empty) {\r\nahd_free_tstate(ahd, target, channel,\r\nFALSE);\r\nif (ahd->features & AHD_MULTI_TID) {\r\nu_int targid_mask;\r\ntargid_mask = ahd_inw(ahd, TARGID);\r\ntargid_mask &= ~target_mask;\r\nahd_outw(ahd, TARGID, targid_mask);\r\nahd_update_scsiid(ahd, targid_mask);\r\n}\r\n}\r\n} else {\r\nahd->black_hole = NULL;\r\nempty = TRUE;\r\n}\r\nif (ahd->enabled_luns == 0) {\r\nu_int scsiseq1;\r\nscsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);\r\nscsiseq1 &= ~ENSELI;\r\nahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);\r\nscsiseq1 = ahd_inb(ahd, SCSISEQ1);\r\nscsiseq1 &= ~ENSELI;\r\nahd_outb(ahd, SCSISEQ1, scsiseq1);\r\nif ((ahd->features & AHD_MULTIROLE) == 0) {\r\nprintk("Configuring Initiator Mode\n");\r\nahd->flags &= ~AHD_TARGETROLE;\r\nahd->flags |= AHD_INITIATORROLE;\r\nahd_pause(ahd);\r\nahd_loadseq(ahd);\r\nahd_restart(ahd);\r\n}\r\n}\r\nahd_unpause(ahd);\r\nahd_unlock(ahd, &s);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nahd_update_scsiid(struct ahd_softc *ahd, u_int targid_mask)\r\n{\r\n#if NOT_YET\r\nu_int scsiid_mask;\r\nu_int scsiid;\r\nif ((ahd->features & AHD_MULTI_TID) == 0)\r\npanic("ahd_update_scsiid called on non-multitid unit\n");\r\nif ((ahd->features & AHD_ULTRA2) != 0)\r\nscsiid = ahd_inb(ahd, SCSIID_ULTRA2);\r\nelse\r\nscsiid = ahd_inb(ahd, SCSIID);\r\nscsiid_mask = 0x1 << (scsiid & OID);\r\nif ((targid_mask & scsiid_mask) == 0) {\r\nu_int our_id;\r\nour_id = ffs(targid_mask);\r\nif (our_id == 0)\r\nour_id = ahd->our_id;\r\nelse\r\nour_id--;\r\nscsiid &= TID;\r\nscsiid |= our_id;\r\n}\r\nif ((ahd->features & AHD_ULTRA2) != 0)\r\nahd_outb(ahd, SCSIID_ULTRA2, scsiid);\r\nelse\r\nahd_outb(ahd, SCSIID, scsiid);\r\n#endif\r\n}\r\nstatic void\r\nahd_run_tqinfifo(struct ahd_softc *ahd, int paused)\r\n{\r\nstruct target_cmd *cmd;\r\nahd_sync_tqinfifo(ahd, BUS_DMASYNC_POSTREAD);\r\nwhile ((cmd = &ahd->targetcmds[ahd->tqinfifonext])->cmd_valid != 0) {\r\nif (ahd_handle_target_cmd(ahd, cmd) != 0)\r\nbreak;\r\ncmd->cmd_valid = 0;\r\nahd_dmamap_sync(ahd, ahd->shared_data_dmat,\r\nahd->shared_data_map.dmamap,\r\nahd_targetcmd_offset(ahd, ahd->tqinfifonext),\r\nsizeof(struct target_cmd),\r\nBUS_DMASYNC_PREREAD);\r\nahd->tqinfifonext++;\r\nif ((ahd->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {\r\nu_int hs_mailbox;\r\nhs_mailbox = ahd_inb(ahd, HS_MAILBOX);\r\nhs_mailbox &= ~HOST_TQINPOS;\r\nhs_mailbox |= ahd->tqinfifonext & HOST_TQINPOS;\r\nahd_outb(ahd, HS_MAILBOX, hs_mailbox);\r\n}\r\n}\r\n}\r\nstatic int\r\nahd_handle_target_cmd(struct ahd_softc *ahd, struct target_cmd *cmd)\r\n{\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_tmode_lstate *lstate;\r\nstruct ccb_accept_tio *atio;\r\nuint8_t *byte;\r\nint initiator;\r\nint target;\r\nint lun;\r\ninitiator = SCSIID_TARGET(ahd, cmd->scsiid);\r\ntarget = SCSIID_OUR_ID(cmd->scsiid);\r\nlun = (cmd->identify & MSG_IDENTIFY_LUNMASK);\r\nbyte = cmd->bytes;\r\ntstate = ahd->enabled_targets[target];\r\nlstate = NULL;\r\nif (tstate != NULL)\r\nlstate = tstate->enabled_luns[lun];\r\nif (lstate == NULL)\r\nlstate = ahd->black_hole;\r\natio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);\r\nif (atio == NULL) {\r\nahd->flags |= AHD_TQINFIFO_BLOCKED;\r\nreturn (1);\r\n} else\r\nahd->flags &= ~AHD_TQINFIFO_BLOCKED;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_TQIN) != 0)\r\nprintk("Incoming command from %d for %d:%d%s\n",\r\ninitiator, target, lun,\r\nlstate == ahd->black_hole ? "(Black Holed)" : "");\r\n#endif\r\nSLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);\r\nif (lstate == ahd->black_hole) {\r\natio->ccb_h.target_id = target;\r\natio->ccb_h.target_lun = lun;\r\n}\r\natio->sense_len = 0;\r\natio->init_id = initiator;\r\nif (byte[0] != 0xFF) {\r\natio->tag_action = *byte++;\r\natio->tag_id = *byte++;\r\natio->ccb_h.flags = CAM_TAG_ACTION_VALID;\r\n} else {\r\natio->ccb_h.flags = 0;\r\n}\r\nbyte++;\r\nswitch (*byte >> CMD_GROUP_CODE_SHIFT) {\r\ncase 0:\r\natio->cdb_len = 6;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\natio->cdb_len = 10;\r\nbreak;\r\ncase 4:\r\natio->cdb_len = 16;\r\nbreak;\r\ncase 5:\r\natio->cdb_len = 12;\r\nbreak;\r\ncase 3:\r\ndefault:\r\natio->cdb_len = 1;\r\nprintk("Reserved or VU command code type encountered\n");\r\nbreak;\r\n}\r\nmemcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);\r\natio->ccb_h.status |= CAM_CDB_RECVD;\r\nif ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_TQIN) != 0)\r\nprintk("Received Immediate Command %d:%d:%d - %p\n",\r\ninitiator, target, lun, ahd->pending_device);\r\n#endif\r\nahd->pending_device = lstate;\r\nahd_freeze_ccb((union ccb *)atio);\r\natio->ccb_h.flags |= CAM_DIS_DISCONNECT;\r\n}\r\nxpt_done((union ccb*)atio);\r\nreturn (0);\r\n}
