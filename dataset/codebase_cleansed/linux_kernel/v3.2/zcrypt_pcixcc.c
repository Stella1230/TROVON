static int ICAMEX_msg_to_type6MEX_msgX(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {'C','A',},\r\n.function_code = {'P','K'},\r\n};\r\nstatic struct function_and_rules_block static_pke_fnr = {\r\n.function_code = {'P','K'},\r\n.ulen = 10,\r\n.only_rule = {'M','R','P',' ',' ',' ',' ',' '}\r\n};\r\nstatic struct function_and_rules_block static_pke_fnr_MCL2 = {\r\n.function_code = {'P','K'},\r\n.ulen = 10,\r\n.only_rule = {'Z','E','R','O','-','P','A','D'}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __attribute__((packed)) *msg = ap_msg->message;\r\nint size;\r\nmsg->length = mex->inputdatalength + 2;\r\nif (copy_from_user(msg->text, mex->inputdata, mex->inputdatalength))\r\nreturn -EFAULT;\r\nsize = zcrypt_type6_mex_key_en(mex, msg->text+mex->inputdatalength, 1);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + mex->inputdatalength;\r\nmsg->hdr = static_type6_hdrX;\r\nmsg->hdr.ToCardLen1 = size - sizeof(msg->hdr);\r\nmsg->hdr.FromCardLen1 = PCIXCC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprbx = static_cprbx;\r\nmsg->cprbx.domain = AP_QID_QUEUE(zdev->ap_dev->qid);\r\nmsg->cprbx.rpl_msgbl = msg->hdr.FromCardLen1;\r\nmsg->fr = (zdev->user_space_type == ZCRYPT_PCIXCC_MCL2) ?\r\nstatic_pke_fnr_MCL2 : static_pke_fnr;\r\nmsg->cprbx.req_parml = size - sizeof(msg->hdr) - sizeof(msg->cprbx);\r\nap_msg->length = size;\r\nreturn 0;\r\n}\r\nstatic int ICACRT_msg_to_type6CRT_msgX(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {'C','A',},\r\n.function_code = {'P','D'},\r\n};\r\nstatic struct function_and_rules_block static_pkd_fnr = {\r\n.function_code = {'P','D'},\r\n.ulen = 10,\r\n.only_rule = {'Z','E','R','O','-','P','A','D'}\r\n};\r\nstatic struct function_and_rules_block static_pkd_fnr_MCL2 = {\r\n.function_code = {'P','D'},\r\n.ulen = 10,\r\n.only_rule = {'P','K','C','S','-','1','.','2'}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __attribute__((packed)) *msg = ap_msg->message;\r\nint size;\r\nmsg->length = crt->inputdatalength + 2;\r\nif (copy_from_user(msg->text, crt->inputdata, crt->inputdatalength))\r\nreturn -EFAULT;\r\nsize = zcrypt_type6_crt_key(crt, msg->text + crt->inputdatalength, 1);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + crt->inputdatalength;\r\nmsg->hdr = static_type6_hdrX;\r\nmsg->hdr.ToCardLen1 = size - sizeof(msg->hdr);\r\nmsg->hdr.FromCardLen1 = PCIXCC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprbx = static_cprbx;\r\nmsg->cprbx.domain = AP_QID_QUEUE(zdev->ap_dev->qid);\r\nmsg->cprbx.req_parml = msg->cprbx.rpl_msgbl =\r\nsize - sizeof(msg->hdr) - sizeof(msg->cprbx);\r\nmsg->fr = (zdev->user_space_type == ZCRYPT_PCIXCC_MCL2) ?\r\nstatic_pkd_fnr_MCL2 : static_pkd_fnr;\r\nap_msg->length = size;\r\nreturn 0;\r\n}\r\nstatic int XCRB_msg_to_type6CPRB_msgX(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\n} __attribute__((packed)) *msg = ap_msg->message;\r\nint rcblen = CEIL4(xcRB->request_control_blk_length);\r\nint replylen;\r\nchar *req_data = ap_msg->message + sizeof(struct type6_hdr) + rcblen;\r\nchar *function_code;\r\nap_msg->length = sizeof(struct type6_hdr) +\r\nCEIL4(xcRB->request_control_blk_length) +\r\nxcRB->request_data_length;\r\nif (ap_msg->length > PCIXCC_MAX_XCRB_MESSAGE_SIZE)\r\nreturn -EFAULT;\r\nif (CEIL4(xcRB->reply_control_blk_length) > PCIXCC_MAX_XCRB_REPLY_SIZE)\r\nreturn -EFAULT;\r\nif (CEIL4(xcRB->reply_data_length) > PCIXCC_MAX_XCRB_DATA_SIZE)\r\nreturn -EFAULT;\r\nreplylen = CEIL4(xcRB->reply_control_blk_length) +\r\nCEIL4(xcRB->reply_data_length) +\r\nsizeof(struct type86_fmt2_msg);\r\nif (replylen > PCIXCC_MAX_XCRB_RESPONSE_SIZE) {\r\nxcRB->reply_control_blk_length = PCIXCC_MAX_XCRB_RESPONSE_SIZE -\r\n(sizeof(struct type86_fmt2_msg) +\r\nCEIL4(xcRB->reply_data_length));\r\n}\r\nmsg->hdr = static_type6_hdrX;\r\nmemcpy(msg->hdr.agent_id , &(xcRB->agent_ID), sizeof(xcRB->agent_ID));\r\nmsg->hdr.ToCardLen1 = xcRB->request_control_blk_length;\r\nif (xcRB->request_data_length) {\r\nmsg->hdr.offset2 = msg->hdr.offset1 + rcblen;\r\nmsg->hdr.ToCardLen2 = xcRB->request_data_length;\r\n}\r\nmsg->hdr.FromCardLen1 = xcRB->reply_control_blk_length;\r\nmsg->hdr.FromCardLen2 = xcRB->reply_data_length;\r\nif (copy_from_user(&(msg->cprbx), xcRB->request_control_blk_addr,\r\nxcRB->request_control_blk_length))\r\nreturn -EFAULT;\r\nif (msg->cprbx.cprb_len + sizeof(msg->hdr.function_code) >\r\nxcRB->request_control_blk_length)\r\nreturn -EFAULT;\r\nfunction_code = ((unsigned char *)&msg->cprbx) + msg->cprbx.cprb_len;\r\nmemcpy(msg->hdr.function_code, function_code, sizeof(msg->hdr.function_code));\r\nif (memcmp(function_code, "US", 2) == 0)\r\nap_msg->special = 1;\r\nelse\r\nap_msg->special = 0;\r\nif (xcRB->request_data_length &&\r\ncopy_from_user(req_data, xcRB->request_data_address,\r\nxcRB->request_data_length))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void rng_type6CPRB_msgX(struct ap_device *ap_dev,\r\nstruct ap_message *ap_msg,\r\nunsigned random_number_length)\r\n{\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nchar function_code[2];\r\nshort int rule_length;\r\nchar rule[8];\r\nshort int verb_length;\r\nshort int key_length;\r\n} __attribute__((packed)) *msg = ap_msg->message;\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {'C', 'A'},\r\n.function_code = {'R', 'L'},\r\n.ToCardLen1 = sizeof *msg - sizeof(msg->hdr),\r\n.FromCardLen1 = sizeof *msg - sizeof(msg->hdr),\r\n};\r\nstatic struct CPRBX local_cprbx = {\r\n.cprb_len = 0x00dc,\r\n.cprb_ver_id = 0x02,\r\n.func_id = {0x54, 0x32},\r\n.req_parml = sizeof *msg - sizeof(msg->hdr) -\r\nsizeof(msg->cprbx),\r\n.rpl_msgbl = sizeof *msg - sizeof(msg->hdr),\r\n};\r\nmsg->hdr = static_type6_hdrX;\r\nmsg->hdr.FromCardLen2 = random_number_length,\r\nmsg->cprbx = local_cprbx;\r\nmsg->cprbx.rpl_datal = random_number_length,\r\nmsg->cprbx.domain = AP_QID_QUEUE(ap_dev->qid);\r\nmemcpy(msg->function_code, msg->hdr.function_code, 0x02);\r\nmsg->rule_length = 0x0a;\r\nmemcpy(msg->rule, "RANDOM ", 8);\r\nmsg->verb_length = 0x02;\r\nmsg->key_length = 0x02;\r\nap_msg->length = sizeof *msg;\r\n}\r\nstatic int convert_type86_ica(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstatic unsigned char static_pad[] = {\r\n0x00,0x02,\r\n0x1B,0x7B,0x5D,0xB5,0x75,0x01,0x3D,0xFD,\r\n0x8D,0xD1,0xC7,0x03,0x2D,0x09,0x23,0x57,\r\n0x89,0x49,0xB9,0x3F,0xBB,0x99,0x41,0x5B,\r\n0x75,0x21,0x7B,0x9D,0x3B,0x6B,0x51,0x39,\r\n0xBB,0x0D,0x35,0xB9,0x89,0x0F,0x93,0xA5,\r\n0x0B,0x47,0xF1,0xD3,0xBB,0xCB,0xF1,0x9D,\r\n0x23,0x73,0x71,0xFF,0xF3,0xF5,0x45,0xFB,\r\n0x61,0x29,0x23,0xFD,0xF1,0x29,0x3F,0x7F,\r\n0x17,0xB7,0x1B,0xA9,0x19,0xBD,0x57,0xA9,\r\n0xD7,0x95,0xA3,0xCB,0xED,0x1D,0xDB,0x45,\r\n0x7D,0x11,0xD1,0x51,0x1B,0xED,0x71,0xE9,\r\n0xB1,0xD1,0xAB,0xAB,0x21,0x2B,0x1B,0x9F,\r\n0x3B,0x9F,0xF7,0xF7,0xBD,0x63,0xEB,0xAD,\r\n0xDF,0xB3,0x6F,0x5B,0xDB,0x8D,0xA9,0x5D,\r\n0xE3,0x7D,0x77,0x49,0x47,0xF5,0xA7,0xFD,\r\n0xAB,0x2F,0x27,0x35,0x77,0xD3,0x49,0xC9,\r\n0x09,0xEB,0xB1,0xF9,0xBF,0x4B,0xCB,0x2B,\r\n0xEB,0xEB,0x05,0xFF,0x7D,0xC7,0x91,0x8B,\r\n0x09,0x83,0xB9,0xB9,0x69,0x33,0x39,0x6B,\r\n0x79,0x75,0x19,0xBF,0xBB,0x07,0x1D,0xBD,\r\n0x29,0xBF,0x39,0x95,0x93,0x1D,0x35,0xC7,\r\n0xC9,0x4D,0xE5,0x97,0x0B,0x43,0x9B,0xF1,\r\n0x16,0x93,0x03,0x1F,0xA5,0xFB,0xDB,0xF3,\r\n0x27,0x4F,0x27,0x61,0x05,0x1F,0xB9,0x23,\r\n0x2F,0xC3,0x81,0xA9,0x23,0x71,0x55,0x55,\r\n0xEB,0xED,0x41,0xE5,0xF3,0x11,0xF1,0x43,\r\n0x69,0x03,0xBD,0x0B,0x37,0x0F,0x51,0x8F,\r\n0x0B,0xB5,0x89,0x5B,0x67,0xA9,0xD9,0x4F,\r\n0x01,0xF9,0x21,0x77,0x37,0x73,0x79,0xC5,\r\n0x7F,0x51,0xC1,0xCF,0x97,0xA1,0x75,0xAD,\r\n0x35,0x9D,0xD3,0xD3,0xA7,0x9D,0x5D,0x41,\r\n0x6F,0x65,0x1B,0xCF,0xA9,0x87,0x91,0x09\r\n};\r\nstruct type86x_reply *msg = reply->message;\r\nunsigned short service_rc, service_rs;\r\nunsigned int reply_len, pad_len;\r\nchar *data;\r\nservice_rc = msg->cprbx.ccp_rtcode;\r\nif (unlikely(service_rc != 0)) {\r\nservice_rs = msg->cprbx.ccp_rscode;\r\nif (service_rc == 8 && service_rs == 66)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 65)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 770)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 783) {\r\nzdev->min_mod_size = PCIXCC_MIN_MOD_SIZE_OLD;\r\nreturn -EAGAIN;\r\n}\r\nif (service_rc == 12 && service_rs == 769)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 72)\r\nreturn -EINVAL;\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\ndata = msg->text;\r\nreply_len = msg->length - 2;\r\nif (reply_len > outputdatalength)\r\nreturn -EINVAL;\r\npad_len = outputdatalength - reply_len;\r\nif (pad_len > 0) {\r\nif (pad_len < 10)\r\nreturn -EINVAL;\r\nif (copy_to_user(outputdata, static_pad, pad_len - 1))\r\nreturn -EFAULT;\r\nif (put_user(0, outputdata + pad_len - 1))\r\nreturn -EFAULT;\r\n}\r\nif (copy_to_user(outputdata + pad_len, data, reply_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_xcrb(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct type86_fmt2_msg *msg = reply->message;\r\nchar *data = reply->message;\r\nif (copy_to_user(xcRB->reply_control_blk_addr,\r\ndata + msg->fmt2.offset1, msg->fmt2.count1))\r\nreturn -EFAULT;\r\nxcRB->reply_control_blk_length = msg->fmt2.count1;\r\nif (msg->fmt2.count2)\r\nif (copy_to_user(xcRB->reply_data_addr,\r\ndata + msg->fmt2.offset2, msg->fmt2.count2))\r\nreturn -EFAULT;\r\nxcRB->reply_data_length = msg->fmt2.count2;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_rng(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar *buffer)\r\n{\r\nstruct {\r\nstruct type86_hdr hdr;\r\nstruct type86_fmt2_ext fmt2;\r\nstruct CPRBX cprbx;\r\n} __attribute__((packed)) *msg = reply->message;\r\nchar *data = reply->message;\r\nif (msg->cprbx.ccp_rtcode != 0 || msg->cprbx.ccp_rscode != 0)\r\nreturn -EINVAL;\r\nmemcpy(buffer, data + msg->fmt2.offset2, msg->fmt2.count2);\r\nreturn msg->fmt2.count2;\r\n}\r\nstatic int convert_response_ica(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (((unsigned char *) reply->message)[1]) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn convert_error(zdev, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->cprbx.ccp_rtcode &&\r\n(msg->cprbx.ccp_rscode == 0x14f) &&\r\n(outputdatalength > 256)) {\r\nif (zdev->max_exp_bit_length <= 17) {\r\nzdev->max_exp_bit_length = 17;\r\nreturn -EAGAIN;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nif (msg->hdr.reply_code)\r\nreturn convert_error(zdev, reply);\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_ica(zdev, reply,\r\noutputdata, outputdatalength);\r\ndefault:\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int convert_response_xcrb(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (((unsigned char *) reply->message)[1]) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nxcRB->status = 0x0008044DL;\r\nreturn convert_error(zdev, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code) {\r\nmemcpy(&(xcRB->status), msg->fmt2.apfs, sizeof(u32));\r\nreturn convert_error(zdev, reply);\r\n}\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_xcrb(zdev, reply, xcRB);\r\ndefault:\r\nxcRB->status = 0x0008044DL;\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int convert_response_rng(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar *data)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (msg->hdr.type) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn -EINVAL;\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code)\r\nreturn -EINVAL;\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_rng(zdev, reply, data);\r\ndefault:\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void zcrypt_pcixcc_receive(struct ap_device *ap_dev,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct response_type *resp_type =\r\n(struct response_type *) msg->private;\r\nstruct type86x_reply *t86r;\r\nint length;\r\nif (IS_ERR(reply)) {\r\nmemcpy(msg->message, &error_reply, sizeof(error_reply));\r\ngoto out;\r\n}\r\nt86r = reply->message;\r\nif (t86r->hdr.type == TYPE86_RSP_CODE &&\r\nt86r->cprbx.cprb_ver_id == 0x02) {\r\nswitch (resp_type->type) {\r\ncase PCIXCC_RESPONSE_TYPE_ICA:\r\nlength = sizeof(struct type86x_reply)\r\n+ t86r->length - 2;\r\nlength = min(PCIXCC_MAX_ICA_RESPONSE_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\nbreak;\r\ncase PCIXCC_RESPONSE_TYPE_XCRB:\r\nlength = t86r->fmt2.offset2 + t86r->fmt2.count2;\r\nlength = min(PCIXCC_MAX_XCRB_RESPONSE_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\nbreak;\r\ndefault:\r\nmemcpy(msg->message, &error_reply, sizeof error_reply);\r\n}\r\n} else\r\nmemcpy(msg->message, reply->message, sizeof error_reply);\r\nout:\r\ncomplete(&(resp_type->work));\r\n}\r\nstatic long zcrypt_pcixcc_modexpo(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_ICA,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = ICAMEX_msg_to_type6MEX_msgX(zdev, &ap_msg, mex);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_ica(zdev, &ap_msg, mex->outputdata,\r\nmex->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_pcixcc_modexpo_crt(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_ICA,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = ICACRT_msg_to_type6CRT_msgX(zdev, &ap_msg, crt);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_ica(zdev, &ap_msg, crt->outputdata,\r\ncrt->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_pcixcc_send_cprb(struct zcrypt_device *zdev,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_XCRB,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = kmalloc(PCIXCC_MAX_XCRB_MESSAGE_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = XCRB_msg_to_type6CPRB_msgX(zdev, &ap_msg, xcRB);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_xcrb(zdev, &ap_msg, xcRB);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nkzfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_pcixcc_rng(struct zcrypt_device *zdev,\r\nchar *buffer)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_XCRB,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = kmalloc(PCIXCC_MAX_XCRB_MESSAGE_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrng_type6CPRB_msgX(zdev->ap_dev, &ap_msg, ZCRYPT_RNG_BUFFER_SIZE);\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_rng(zdev, &ap_msg, buffer);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic int zcrypt_pcixcc_mcl(struct ap_device *ap_dev)\r\n{\r\nstatic unsigned char msg[] = {\r\n0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x58,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x43,0x41,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x50,0x4B,0x00,0x00,\r\n0x00,0x00,0x01,0xC4,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x07,0x24,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0xDC,0x02,0x00,0x00,0x00,0x54,0x32,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE8,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x24,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x50,0x4B,0x00,0x0A,\r\n0x4D,0x52,0x50,0x20,0x20,0x20,0x20,0x20,\r\n0x00,0x42,0x00,0x01,0x02,0x03,0x04,0x05,\r\n0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,\r\n0x0E,0x0F,0x00,0x11,0x22,0x33,0x44,0x55,\r\n0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,\r\n0xEE,0xFF,0xFF,0xEE,0xDD,0xCC,0xBB,0xAA,\r\n0x99,0x88,0x77,0x66,0x55,0x44,0x33,0x22,\r\n0x11,0x00,0x01,0x23,0x45,0x67,0x89,0xAB,\r\n0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,\r\n0x32,0x10,0x00,0x9A,0x00,0x98,0x00,0x00,\r\n0x1E,0x00,0x00,0x94,0x00,0x00,0x00,0x00,\r\n0x04,0x00,0x00,0x8C,0x00,0x00,0x00,0x40,\r\n0x02,0x00,0x00,0x40,0xBA,0xE8,0x23,0x3C,\r\n0x75,0xF3,0x91,0x61,0xD6,0x73,0x39,0xCF,\r\n0x7B,0x6D,0x8E,0x61,0x97,0x63,0x9E,0xD9,\r\n0x60,0x55,0xD6,0xC7,0xEF,0xF8,0x1E,0x63,\r\n0x95,0x17,0xCC,0x28,0x45,0x60,0x11,0xC5,\r\n0xC4,0x4E,0x66,0xC6,0xE6,0xC3,0xDE,0x8A,\r\n0x19,0x30,0xCF,0x0E,0xD7,0xAA,0xDB,0x01,\r\n0xD8,0x00,0xBB,0x8F,0x39,0x9F,0x64,0x28,\r\n0xF5,0x7A,0x77,0x49,0xCC,0x6B,0xA3,0x91,\r\n0x97,0x70,0xE7,0x60,0x1E,0x39,0xE1,0xE5,\r\n0x33,0xE1,0x15,0x63,0x69,0x08,0x80,0x4C,\r\n0x67,0xC4,0x41,0x8F,0x48,0xDF,0x26,0x98,\r\n0xF1,0xD5,0x8D,0x88,0xD9,0x6A,0xA4,0x96,\r\n0xC5,0x84,0xD9,0x30,0x49,0x67,0x7D,0x19,\r\n0xB1,0xB3,0x45,0x4D,0xB2,0x53,0x9A,0x47,\r\n0x3C,0x7C,0x55,0xBF,0xCC,0x85,0x00,0x36,\r\n0xF1,0x3D,0x93,0x53\r\n};\r\nunsigned long long psmid;\r\nstruct CPRBX *cprbx;\r\nchar *reply;\r\nint rc, i;\r\nreply = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!reply)\r\nreturn -ENOMEM;\r\nrc = ap_send(ap_dev->qid, 0x0102030405060708ULL, msg, sizeof(msg));\r\nif (rc)\r\ngoto out_free;\r\nfor (i = 0; i < 6; i++) {\r\nmdelay(300);\r\nrc = ap_recv(ap_dev->qid, &psmid, reply, 4096);\r\nif (rc == 0 && psmid == 0x0102030405060708ULL)\r\nbreak;\r\n}\r\nif (i >= 6) {\r\nrc = -ENODEV;\r\ngoto out_free;\r\n}\r\ncprbx = (struct CPRBX *) (reply + 48);\r\nif (cprbx->ccp_rtcode == 8 && cprbx->ccp_rscode == 33)\r\nrc = ZCRYPT_PCIXCC_MCL2;\r\nelse\r\nrc = ZCRYPT_PCIXCC_MCL3;\r\nout_free:\r\nfree_page((unsigned long) reply);\r\nreturn rc;\r\n}\r\nstatic int zcrypt_pcixcc_rng_supported(struct ap_device *ap_dev)\r\n{\r\nstruct ap_message ap_msg;\r\nunsigned long long psmid;\r\nstruct {\r\nstruct type86_hdr hdr;\r\nstruct type86_fmt2_ext fmt2;\r\nstruct CPRBX cprbx;\r\n} __attribute__((packed)) *reply;\r\nint rc, i;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nrng_type6CPRB_msgX(ap_dev, &ap_msg, 4);\r\nrc = ap_send(ap_dev->qid, 0x0102030405060708ULL, ap_msg.message,\r\nap_msg.length);\r\nif (rc)\r\ngoto out_free;\r\nfor (i = 0; i < 2 * HZ; i++) {\r\nmsleep(1000 / HZ);\r\nrc = ap_recv(ap_dev->qid, &psmid, ap_msg.message, 4096);\r\nif (rc == 0 && psmid == 0x0102030405060708ULL)\r\nbreak;\r\n}\r\nif (i >= 2 * HZ) {\r\nrc = -ENODEV;\r\ngoto out_free;\r\n}\r\nreply = ap_msg.message;\r\nif (reply->cprbx.ccp_rtcode == 0 && reply->cprbx.ccp_rscode == 0)\r\nrc = 1;\r\nelse\r\nrc = 0;\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic int zcrypt_pcixcc_probe(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint rc = 0;\r\nzdev = zcrypt_device_alloc(PCIXCC_MAX_RESPONSE_SIZE);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->ap_dev = ap_dev;\r\nzdev->online = 1;\r\nswitch (ap_dev->device_type) {\r\ncase AP_DEVICE_TYPE_PCIXCC:\r\nrc = zcrypt_pcixcc_mcl(ap_dev);\r\nif (rc < 0) {\r\nzcrypt_device_free(zdev);\r\nreturn rc;\r\n}\r\nzdev->user_space_type = rc;\r\nif (rc == ZCRYPT_PCIXCC_MCL2) {\r\nzdev->type_string = "PCIXCC_MCL2";\r\nzdev->speed_rating = PCIXCC_MCL2_SPEED_RATING;\r\nzdev->min_mod_size = PCIXCC_MIN_MOD_SIZE_OLD;\r\nzdev->max_mod_size = PCIXCC_MAX_MOD_SIZE;\r\nzdev->max_exp_bit_length = PCIXCC_MAX_MOD_SIZE;\r\n} else {\r\nzdev->type_string = "PCIXCC_MCL3";\r\nzdev->speed_rating = PCIXCC_MCL3_SPEED_RATING;\r\nzdev->min_mod_size = PCIXCC_MIN_MOD_SIZE;\r\nzdev->max_mod_size = PCIXCC_MAX_MOD_SIZE;\r\nzdev->max_exp_bit_length = PCIXCC_MAX_MOD_SIZE;\r\n}\r\nbreak;\r\ncase AP_DEVICE_TYPE_CEX2C:\r\nzdev->user_space_type = ZCRYPT_CEX2C;\r\nzdev->type_string = "CEX2C";\r\nzdev->speed_rating = CEX2C_SPEED_RATING;\r\nzdev->min_mod_size = PCIXCC_MIN_MOD_SIZE;\r\nzdev->max_mod_size = PCIXCC_MAX_MOD_SIZE;\r\nzdev->max_exp_bit_length = PCIXCC_MAX_MOD_SIZE;\r\nbreak;\r\ncase AP_DEVICE_TYPE_CEX3C:\r\nzdev->user_space_type = ZCRYPT_CEX3C;\r\nzdev->type_string = "CEX3C";\r\nzdev->speed_rating = CEX3C_SPEED_RATING;\r\nzdev->min_mod_size = CEX3C_MIN_MOD_SIZE;\r\nzdev->max_mod_size = CEX3C_MAX_MOD_SIZE;\r\nzdev->max_exp_bit_length = CEX3C_MAX_MOD_SIZE;\r\nbreak;\r\ndefault:\r\ngoto out_free;\r\n}\r\nrc = zcrypt_pcixcc_rng_supported(ap_dev);\r\nif (rc < 0) {\r\nzcrypt_device_free(zdev);\r\nreturn rc;\r\n}\r\nif (rc)\r\nzdev->ops = &zcrypt_pcixcc_with_rng_ops;\r\nelse\r\nzdev->ops = &zcrypt_pcixcc_ops;\r\nap_dev->reply = &zdev->reply;\r\nap_dev->private = zdev;\r\nrc = zcrypt_device_register(zdev);\r\nif (rc)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nap_dev->private = NULL;\r\nzcrypt_device_free(zdev);\r\nreturn rc;\r\n}\r\nstatic void zcrypt_pcixcc_remove(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev = ap_dev->private;\r\nzcrypt_device_unregister(zdev);\r\n}\r\nint __init zcrypt_pcixcc_init(void)\r\n{\r\nreturn ap_driver_register(&zcrypt_pcixcc_driver, THIS_MODULE, "pcixcc");\r\n}\r\nvoid zcrypt_pcixcc_exit(void)\r\n{\r\nap_driver_unregister(&zcrypt_pcixcc_driver);\r\n}
