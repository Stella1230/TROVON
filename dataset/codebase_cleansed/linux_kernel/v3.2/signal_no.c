asmlinkage int\r\nsys_sigsuspend(int unused0, int unused1, old_sigset_t mask)\r\n{\r\nmask &= _BLOCKABLE;\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->saved_sigmask = current->blocked;\r\nsiginitset(&current->blocked, mask);\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule();\r\nset_restore_sigmask();\r\nreturn -ERESTARTNOHAND;\r\n}\r\nasmlinkage int\r\nsys_sigaction(int sig, const struct old_sigaction __user *act,\r\nstruct old_sigaction __user *oact)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\nif (act) {\r\nold_sigset_t mask;\r\nif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\r\n__get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\r\n__get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\r\n__get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\r\n__get_user(mask, &act->sa_mask))\r\nreturn -EFAULT;\r\nsiginitset(&new_ka.sa.sa_mask, mask);\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\r\n__put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\r\n__put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\r\n__put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\r\n__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage int\r\nsys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)\r\n{\r\nreturn do_sigaltstack(uss, uoss, rdusp());\r\n}\r\nstatic inline int restore_fpu_state(struct sigcontext *sc)\r\n{\r\nint err = 1;\r\nif (FPU_IS_EMU) {\r\nmemcpy(current->thread.fpcntl, sc->sc_fpcntl, 12);\r\nmemcpy(current->thread.fp, sc->sc_fpregs, 24);\r\nreturn 0;\r\n}\r\nif (sc->sc_fpstate[0]) {\r\nif (sc->sc_fpstate[0] != fpu_version)\r\ngoto out;\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %0,%%fp0-%%fp1\n\t"\r\n"fmoveml %1,%%fpcr/%%fpsr/%%fpiar\n\t"\r\n".chip 68k"\r\n:\r\n: "m" (*sc->sc_fpregs), "m" (*sc->sc_fpcntl));\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"frestore %0\n\t"\r\n".chip 68k" : : "m" (*sc->sc_fpstate));\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic inline int rt_restore_fpu_state(struct ucontext __user *uc)\r\n{\r\nunsigned char fpstate[FPCONTEXT_SIZE];\r\nint context_size = 0;\r\nfpregset_t fpregs;\r\nint err = 1;\r\nif (FPU_IS_EMU) {\r\nif (__copy_from_user(current->thread.fpcntl,\r\nuc->uc_mcontext.fpregs.f_fpcntl, 12))\r\ngoto out;\r\nif (__copy_from_user(current->thread.fp,\r\nuc->uc_mcontext.fpregs.f_fpregs, 96))\r\ngoto out;\r\nreturn 0;\r\n}\r\nif (__get_user(*(long *)fpstate, (long __user *)&uc->uc_fpstate))\r\ngoto out;\r\nif (fpstate[0]) {\r\ncontext_size = fpstate[1];\r\nif (fpstate[0] != fpu_version)\r\ngoto out;\r\nif (__copy_from_user(&fpregs, &uc->uc_mcontext.fpregs,\r\nsizeof(fpregs)))\r\ngoto out;\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %0,%%fp0-%%fp7\n\t"\r\n"fmoveml %1,%%fpcr/%%fpsr/%%fpiar\n\t"\r\n".chip 68k"\r\n:\r\n: "m" (*fpregs.f_fpregs),\r\n"m" (*fpregs.f_fpcntl));\r\n}\r\nif (context_size &&\r\n__copy_from_user(fpstate + 4, (long __user *)&uc->uc_fpstate + 1,\r\ncontext_size))\r\ngoto out;\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"frestore %0\n\t"\r\n".chip 68k" : : "m" (*fpstate));\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic inline int\r\nrestore_sigcontext(struct pt_regs *regs, struct sigcontext __user *usc, void __user *fp,\r\nint *pd0)\r\n{\r\nint formatvec;\r\nstruct sigcontext context;\r\nint err = 0;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nif (copy_from_user(&context, usc, sizeof(context)))\r\ngoto badframe;\r\nregs->d1 = context.sc_d1;\r\nregs->a0 = context.sc_a0;\r\nregs->a1 = context.sc_a1;\r\n((struct switch_stack *)regs - 1)->a5 = context.sc_a5;\r\nregs->sr = (regs->sr & 0xff00) | (context.sc_sr & 0xff);\r\nregs->pc = context.sc_pc;\r\nregs->orig_d0 = -1;\r\nwrusp(context.sc_usp);\r\nformatvec = context.sc_formatvec;\r\nregs->format = formatvec >> 12;\r\nregs->vector = formatvec & 0xfff;\r\n#ifdef CONFIG_FPU\r\nerr = restore_fpu_state(&context);\r\n#endif\r\n*pd0 = context.sc_d0;\r\nreturn err;\r\nbadframe:\r\nreturn 1;\r\n}\r\nstatic inline int\r\nrt_restore_ucontext(struct pt_regs *regs, struct switch_stack *sw,\r\nstruct ucontext __user *uc, int *pd0)\r\n{\r\nint temp;\r\ngreg_t __user *gregs = uc->uc_mcontext.gregs;\r\nunsigned long usp;\r\nint err;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nerr = __get_user(temp, &uc->uc_mcontext.version);\r\nif (temp != MCONTEXT_VERSION)\r\ngoto badframe;\r\nerr |= __get_user(regs->d0, &gregs[0]);\r\nerr |= __get_user(regs->d1, &gregs[1]);\r\nerr |= __get_user(regs->d2, &gregs[2]);\r\nerr |= __get_user(regs->d3, &gregs[3]);\r\nerr |= __get_user(regs->d4, &gregs[4]);\r\nerr |= __get_user(regs->d5, &gregs[5]);\r\nerr |= __get_user(sw->d6, &gregs[6]);\r\nerr |= __get_user(sw->d7, &gregs[7]);\r\nerr |= __get_user(regs->a0, &gregs[8]);\r\nerr |= __get_user(regs->a1, &gregs[9]);\r\nerr |= __get_user(regs->a2, &gregs[10]);\r\nerr |= __get_user(sw->a3, &gregs[11]);\r\nerr |= __get_user(sw->a4, &gregs[12]);\r\nerr |= __get_user(sw->a5, &gregs[13]);\r\nerr |= __get_user(sw->a6, &gregs[14]);\r\nerr |= __get_user(usp, &gregs[15]);\r\nwrusp(usp);\r\nerr |= __get_user(regs->pc, &gregs[16]);\r\nerr |= __get_user(temp, &gregs[17]);\r\nregs->sr = (regs->sr & 0xff00) | (temp & 0xff);\r\nregs->orig_d0 = -1;\r\nregs->format = temp >> 12;\r\nregs->vector = temp & 0xfff;\r\nif (do_sigaltstack(&uc->uc_stack, NULL, usp) == -EFAULT)\r\ngoto badframe;\r\n*pd0 = regs->d0;\r\nreturn err;\r\nbadframe:\r\nreturn 1;\r\n}\r\nasmlinkage int do_sigreturn(unsigned long __unused)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *) &__unused;\r\nstruct pt_regs *regs = (struct pt_regs *) (sw + 1);\r\nunsigned long usp = rdusp();\r\nstruct sigframe __user *frame = (struct sigframe __user *)(usp - 4);\r\nsigset_t set;\r\nint d0;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__get_user(set.sig[0], &frame->sc.sc_mask) ||\r\n(_NSIG_WORDS > 1 &&\r\n__copy_from_user(&set.sig[1], &frame->extramask,\r\nsizeof(frame->extramask))))\r\ngoto badframe;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->blocked = set;\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (restore_sigcontext(regs, &frame->sc, frame + 1, &d0))\r\ngoto badframe;\r\nreturn d0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nasmlinkage int do_rt_sigreturn(unsigned long __unused)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *) &__unused;\r\nstruct pt_regs *regs = (struct pt_regs *) (sw + 1);\r\nunsigned long usp = rdusp();\r\nstruct rt_sigframe __user *frame = (struct rt_sigframe __user *)(usp - 4);\r\nsigset_t set;\r\nint d0;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->blocked = set;\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (rt_restore_ucontext(regs, sw, &frame->uc, &d0))\r\ngoto badframe;\r\nreturn d0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nstatic inline void save_fpu_state(struct sigcontext *sc, struct pt_regs *regs)\r\n{\r\nif (FPU_IS_EMU) {\r\nmemcpy(sc->sc_fpcntl, current->thread.fpcntl, 12);\r\nmemcpy(sc->sc_fpregs, current->thread.fp, 24);\r\nreturn;\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fsave %0\n\t"\r\n".chip 68k"\r\n: : "m" (*sc->sc_fpstate) : "memory");\r\nif (sc->sc_fpstate[0]) {\r\nfpu_version = sc->sc_fpstate[0];\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %%fp0-%%fp1,%0\n\t"\r\n"fmoveml %%fpcr/%%fpsr/%%fpiar,%1\n\t"\r\n".chip 68k"\r\n: "=m" (*sc->sc_fpregs),\r\n"=m" (*sc->sc_fpcntl)\r\n:\r\n: "memory");\r\n}\r\n}\r\nstatic inline int rt_save_fpu_state(struct ucontext __user *uc, struct pt_regs *regs)\r\n{\r\nunsigned char fpstate[FPCONTEXT_SIZE];\r\nint context_size = 0;\r\nint err = 0;\r\nif (FPU_IS_EMU) {\r\nerr |= copy_to_user(uc->uc_mcontext.fpregs.f_pcntl,\r\ncurrent->thread.fpcntl, 12);\r\nerr |= copy_to_user(uc->uc_mcontext.fpregs.f_fpregs,\r\ncurrent->thread.fp, 96);\r\nreturn err;\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fsave %0\n\t"\r\n".chip 68k"\r\n: : "m" (*fpstate) : "memory");\r\nerr |= __put_user(*(long *)fpstate, (long __user *)&uc->uc_fpstate);\r\nif (fpstate[0]) {\r\nfpregset_t fpregs;\r\ncontext_size = fpstate[1];\r\nfpu_version = fpstate[0];\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %%fp0-%%fp7,%0\n\t"\r\n"fmoveml %%fpcr/%%fpsr/%%fpiar,%1\n\t"\r\n".chip 68k"\r\n: "=m" (*fpregs.f_fpregs),\r\n"=m" (*fpregs.f_fpcntl)\r\n:\r\n: "memory");\r\nerr |= copy_to_user(&uc->uc_mcontext.fpregs, &fpregs,\r\nsizeof(fpregs));\r\n}\r\nif (context_size)\r\nerr |= copy_to_user((long __user *)&uc->uc_fpstate + 1, fpstate + 4,\r\ncontext_size);\r\nreturn err;\r\n}\r\nstatic void setup_sigcontext(struct sigcontext *sc, struct pt_regs *regs,\r\nunsigned long mask)\r\n{\r\nsc->sc_mask = mask;\r\nsc->sc_usp = rdusp();\r\nsc->sc_d0 = regs->d0;\r\nsc->sc_d1 = regs->d1;\r\nsc->sc_a0 = regs->a0;\r\nsc->sc_a1 = regs->a1;\r\nsc->sc_a5 = ((struct switch_stack *)regs - 1)->a5;\r\nsc->sc_sr = regs->sr;\r\nsc->sc_pc = regs->pc;\r\nsc->sc_formatvec = regs->format << 12 | regs->vector;\r\n#ifdef CONFIG_FPU\r\nsave_fpu_state(sc, regs);\r\n#endif\r\n}\r\nstatic inline int rt_setup_ucontext(struct ucontext __user *uc, struct pt_regs *regs)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *)regs - 1;\r\ngreg_t __user *gregs = uc->uc_mcontext.gregs;\r\nint err = 0;\r\nerr |= __put_user(MCONTEXT_VERSION, &uc->uc_mcontext.version);\r\nerr |= __put_user(regs->d0, &gregs[0]);\r\nerr |= __put_user(regs->d1, &gregs[1]);\r\nerr |= __put_user(regs->d2, &gregs[2]);\r\nerr |= __put_user(regs->d3, &gregs[3]);\r\nerr |= __put_user(regs->d4, &gregs[4]);\r\nerr |= __put_user(regs->d5, &gregs[5]);\r\nerr |= __put_user(sw->d6, &gregs[6]);\r\nerr |= __put_user(sw->d7, &gregs[7]);\r\nerr |= __put_user(regs->a0, &gregs[8]);\r\nerr |= __put_user(regs->a1, &gregs[9]);\r\nerr |= __put_user(regs->a2, &gregs[10]);\r\nerr |= __put_user(sw->a3, &gregs[11]);\r\nerr |= __put_user(sw->a4, &gregs[12]);\r\nerr |= __put_user(sw->a5, &gregs[13]);\r\nerr |= __put_user(sw->a6, &gregs[14]);\r\nerr |= __put_user(rdusp(), &gregs[15]);\r\nerr |= __put_user(regs->pc, &gregs[16]);\r\nerr |= __put_user(regs->sr, &gregs[17]);\r\n#ifdef CONFIG_FPU\r\nerr |= rt_save_fpu_state(uc, regs);\r\n#endif\r\nreturn err;\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size)\r\n{\r\nunsigned long usp;\r\nusp = rdusp();\r\nif (ka->sa.sa_flags & SA_ONSTACK) {\r\nif (!sas_ss_flags(usp))\r\nusp = current->sas_ss_sp + current->sas_ss_size;\r\n}\r\nreturn (void __user *)((usp - frame_size) & -8UL);\r\n}\r\nstatic int setup_frame (int sig, struct k_sigaction *ka,\r\nsigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct sigframe __user *frame;\r\nstruct sigcontext context;\r\nint err = 0;\r\nframe = get_sigframe(ka, regs, sizeof(*frame));\r\nerr |= __put_user((current_thread_info()->exec_domain\r\n&& current_thread_info()->exec_domain->signal_invmap\r\n&& sig < 32\r\n? current_thread_info()->exec_domain->signal_invmap[sig]\r\n: sig),\r\n&frame->sig);\r\nerr |= __put_user(regs->vector, &frame->code);\r\nerr |= __put_user(&frame->sc, &frame->psc);\r\nif (_NSIG_WORDS > 1)\r\nerr |= copy_to_user(frame->extramask, &set->sig[1],\r\nsizeof(frame->extramask));\r\nsetup_sigcontext(&context, regs, set->sig[0]);\r\nerr |= copy_to_user (&frame->sc, &context, sizeof(context));\r\nerr |= __put_user((void *) ret_from_user_signal, &frame->pretcode);\r\nif (err)\r\ngoto give_sigsegv;\r\nwrusp ((unsigned long) frame);\r\nregs->pc = (unsigned long) ka->sa.sa_handler;\r\n((struct switch_stack *)regs - 1)->a5 = current->mm->start_data;\r\nregs->format = 0x4;\r\nadjust_stack:\r\nif (regs->stkadj) {\r\nstruct pt_regs *tregs =\r\n(struct pt_regs *)((ulong)regs + regs->stkadj);\r\n#if defined(DEBUG)\r\nprintk(KERN_DEBUG "Performing stackadjust=%04x\n", regs->stkadj);\r\n#endif\r\ntregs->vector = 0;\r\ntregs->format = 0;\r\ntregs->pc = regs->pc;\r\ntregs->sr = regs->sr;\r\n}\r\nreturn err;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\ngoto adjust_stack;\r\n}\r\nstatic int setup_rt_frame (int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct rt_sigframe __user *frame;\r\nint err = 0;\r\nframe = get_sigframe(ka, regs, sizeof(*frame));\r\nerr |= __put_user((current_thread_info()->exec_domain\r\n&& current_thread_info()->exec_domain->signal_invmap\r\n&& sig < 32\r\n? current_thread_info()->exec_domain->signal_invmap[sig]\r\n: sig),\r\n&frame->sig);\r\nerr |= __put_user(&frame->info, &frame->pinfo);\r\nerr |= __put_user(&frame->uc, &frame->puc);\r\nerr |= copy_siginfo_to_user(&frame->info, info);\r\nerr |= __put_user(0, &frame->uc.uc_flags);\r\nerr |= __put_user(NULL, &frame->uc.uc_link);\r\nerr |= __put_user((void __user *)current->sas_ss_sp,\r\n&frame->uc.uc_stack.ss_sp);\r\nerr |= __put_user(sas_ss_flags(rdusp()),\r\n&frame->uc.uc_stack.ss_flags);\r\nerr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\r\nerr |= rt_setup_ucontext(&frame->uc, regs);\r\nerr |= copy_to_user (&frame->uc.uc_sigmask, set, sizeof(*set));\r\nerr |= __put_user((void *) ret_from_user_rt_signal, &frame->pretcode);\r\nif (err)\r\ngoto give_sigsegv;\r\nwrusp ((unsigned long) frame);\r\nregs->pc = (unsigned long) ka->sa.sa_handler;\r\n((struct switch_stack *)regs - 1)->a5 = current->mm->start_data;\r\nregs->format = 0x4;\r\nadjust_stack:\r\nif (regs->stkadj) {\r\nstruct pt_regs *tregs =\r\n(struct pt_regs *)((ulong)regs + regs->stkadj);\r\n#if defined(DEBUG)\r\nprintk(KERN_DEBUG "Performing stackadjust=%04x\n", regs->stkadj);\r\n#endif\r\ntregs->vector = 0;\r\ntregs->format = 0;\r\ntregs->pc = regs->pc;\r\ntregs->sr = regs->sr;\r\n}\r\nreturn err;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\ngoto adjust_stack;\r\n}\r\nstatic inline void\r\nhandle_restart(struct pt_regs *regs, struct k_sigaction *ka, int has_handler)\r\n{\r\nswitch (regs->d0) {\r\ncase -ERESTARTNOHAND:\r\nif (!has_handler)\r\ngoto do_restart;\r\nregs->d0 = -EINTR;\r\nbreak;\r\ncase -ERESTART_RESTARTBLOCK:\r\nif (!has_handler) {\r\nregs->d0 = __NR_restart_syscall;\r\nregs->pc -= 2;\r\nbreak;\r\n}\r\nregs->d0 = -EINTR;\r\nbreak;\r\ncase -ERESTARTSYS:\r\nif (has_handler && !(ka->sa.sa_flags & SA_RESTART)) {\r\nregs->d0 = -EINTR;\r\nbreak;\r\n}\r\ncase -ERESTARTNOINTR:\r\ndo_restart:\r\nregs->d0 = regs->orig_d0;\r\nregs->pc -= 2;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nhandle_signal(int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *oldset, struct pt_regs *regs)\r\n{\r\nint err;\r\nif (regs->orig_d0 >= 0)\r\nhandle_restart(regs, ka, 1);\r\nif (ka->sa.sa_flags & SA_SIGINFO)\r\nerr = setup_rt_frame(sig, ka, info, oldset, regs);\r\nelse\r\nerr = setup_frame(sig, ka, oldset, regs);\r\nif (err)\r\nreturn;\r\nspin_lock_irq(&current->sighand->siglock);\r\nsigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);\r\nif (!(ka->sa.sa_flags & SA_NODEFER))\r\nsigaddset(&current->blocked,sig);\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\nclear_thread_flag(TIF_RESTORE_SIGMASK);\r\n}\r\nasmlinkage void do_signal(struct pt_regs *regs)\r\n{\r\nstruct k_sigaction ka;\r\nsiginfo_t info;\r\nint signr;\r\nsigset_t *oldset;\r\nif (!user_mode(regs))\r\nreturn;\r\nif (test_thread_flag(TIF_RESTORE_SIGMASK))\r\noldset = &current->saved_sigmask;\r\nelse\r\noldset = &current->blocked;\r\nsignr = get_signal_to_deliver(&info, &ka, regs, NULL);\r\nif (signr > 0) {\r\nhandle_signal(signr, &ka, &info, oldset, regs);\r\nreturn;\r\n}\r\nif (regs->orig_d0 >= 0) {\r\nhandle_restart(regs, NULL, 0);\r\n}\r\nif (test_thread_flag(TIF_RESTORE_SIGMASK)) {\r\nclear_thread_flag(TIF_RESTORE_SIGMASK);\r\nsigprocmask(SIG_SETMASK, &current->saved_sigmask, NULL);\r\n}\r\n}
