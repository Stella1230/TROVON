static int __read_reg(struct tps6524x *hw, int reg)\r\n{\r\nint error = 0;\r\nu16 cmd = CMD_READ(reg), in;\r\nu8 status;\r\nstruct spi_message m;\r\nstruct spi_transfer t[3];\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = &cmd;\r\nt[0].len = 2;\r\nt[0].bits_per_word = 12;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = &in;\r\nt[1].len = 2;\r\nt[1].bits_per_word = 16;\r\nspi_message_add_tail(&t[1], &m);\r\nt[2].rx_buf = &status;\r\nt[2].len = 1;\r\nt[2].bits_per_word = 4;\r\nspi_message_add_tail(&t[2], &m);\r\nerror = spi_sync(hw->spi, &m);\r\nif (error < 0)\r\nreturn error;\r\ndev_dbg(hw->dev, "read reg %d, data %x, status %x\n",\r\nreg, in, status);\r\nif (!(status & STAT_CLK) || (status & STAT_WRITE))\r\nreturn -EIO;\r\nif (status & STAT_INVALID)\r\nreturn -EINVAL;\r\nreturn in;\r\n}\r\nstatic int read_reg(struct tps6524x *hw, int reg)\r\n{\r\nint ret;\r\nmutex_lock(&hw->lock);\r\nret = __read_reg(hw, reg);\r\nmutex_unlock(&hw->lock);\r\nreturn ret;\r\n}\r\nstatic int __write_reg(struct tps6524x *hw, int reg, int val)\r\n{\r\nint error = 0;\r\nu16 cmd = CMD_WRITE(reg), out = val;\r\nu8 status;\r\nstruct spi_message m;\r\nstruct spi_transfer t[3];\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = &cmd;\r\nt[0].len = 2;\r\nt[0].bits_per_word = 12;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = &out;\r\nt[1].len = 2;\r\nt[1].bits_per_word = 16;\r\nspi_message_add_tail(&t[1], &m);\r\nt[2].rx_buf = &status;\r\nt[2].len = 1;\r\nt[2].bits_per_word = 4;\r\nspi_message_add_tail(&t[2], &m);\r\nerror = spi_sync(hw->spi, &m);\r\nif (error < 0)\r\nreturn error;\r\ndev_dbg(hw->dev, "wrote reg %d, data %x, status %x\n",\r\nreg, out, status);\r\nif (!(status & STAT_CLK) || !(status & STAT_WRITE))\r\nreturn -EIO;\r\nif (status & (STAT_INVALID | STAT_WP))\r\nreturn -EINVAL;\r\nreturn error;\r\n}\r\nstatic int __rmw_reg(struct tps6524x *hw, int reg, int mask, int val)\r\n{\r\nint ret;\r\nret = __read_reg(hw, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~mask;\r\nret |= val;\r\nret = __write_reg(hw, reg, ret);\r\nreturn (ret < 0) ? ret : 0;\r\n}\r\nstatic int rmw_protect(struct tps6524x *hw, int reg, int mask, int val)\r\n{\r\nint ret;\r\nmutex_lock(&hw->lock);\r\nret = __write_reg(hw, REG_WRITE_ENABLE, 1);\r\nif (ret) {\r\ndev_err(hw->dev, "failed to set write enable\n");\r\ngoto error;\r\n}\r\nret = __rmw_reg(hw, reg, mask, val);\r\nif (ret)\r\ndev_err(hw->dev, "failed to rmw register %d\n", reg);\r\nret = __write_reg(hw, REG_WRITE_ENABLE, 0);\r\nif (ret) {\r\ndev_err(hw->dev, "failed to clear write enable\n");\r\ngoto error;\r\n}\r\nerror:\r\nmutex_unlock(&hw->lock);\r\nreturn ret;\r\n}\r\nstatic int read_field(struct tps6524x *hw, const struct field *field)\r\n{\r\nint tmp;\r\ntmp = read_reg(hw, field->reg);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn (tmp >> field->shift) & field->mask;\r\n}\r\nstatic int write_field(struct tps6524x *hw, const struct field *field,\r\nint val)\r\n{\r\nif (val & ~field->mask)\r\nreturn -EOVERFLOW;\r\nreturn rmw_protect(hw, field->reg,\r\nfield->mask << field->shift,\r\nval << field->shift);\r\n}\r\nstatic int list_voltage(struct regulator_dev *rdev, unsigned selector)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nif (info->flags & FIXED_VOLTAGE)\r\nreturn selector ? -EINVAL : info->fixed_voltage;\r\nreturn ((selector < info->n_voltages) ?\r\ninfo->voltages[selector] : -EINVAL);\r\n}\r\nstatic int set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,\r\nunsigned *selector)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nunsigned i;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nif (info->flags & FIXED_VOLTAGE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < info->n_voltages; i++)\r\nif (min_uV <= info->voltages[i] &&\r\nmax_uV >= info->voltages[i])\r\nbreak;\r\nif (i >= info->n_voltages)\r\ni = info->n_voltages - 1;\r\n*selector = info->voltages[i];\r\nreturn write_field(hw, &info->voltage, i);\r\n}\r\nstatic int get_voltage(struct regulator_dev *rdev)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nint ret;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nif (info->flags & FIXED_VOLTAGE)\r\nreturn info->fixed_voltage;\r\nret = read_field(hw, &info->voltage);\r\nif (ret < 0)\r\nreturn ret;\r\nif (WARN_ON(ret >= info->n_voltages))\r\nreturn -EIO;\r\nreturn info->voltages[ret];\r\n}\r\nstatic int set_current_limit(struct regulator_dev *rdev, int min_uA,\r\nint max_uA)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nint i;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nif (info->flags & FIXED_ILIMSEL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < info->n_ilimsels; i++)\r\nif (min_uA <= info->ilimsels[i] &&\r\nmax_uA >= info->ilimsels[i])\r\nbreak;\r\nif (i >= info->n_ilimsels)\r\nreturn -EINVAL;\r\nreturn write_field(hw, &info->ilimsel, i);\r\n}\r\nstatic int get_current_limit(struct regulator_dev *rdev)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nint ret;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nif (info->flags & FIXED_ILIMSEL)\r\nreturn info->fixed_ilimsel;\r\nret = read_field(hw, &info->ilimsel);\r\nif (ret < 0)\r\nreturn ret;\r\nif (WARN_ON(ret >= info->n_ilimsels))\r\nreturn -EIO;\r\nreturn info->ilimsels[ret];\r\n}\r\nstatic int enable_supply(struct regulator_dev *rdev)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nreturn write_field(hw, &info->enable, 1);\r\n}\r\nstatic int disable_supply(struct regulator_dev *rdev)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nreturn write_field(hw, &info->enable, 0);\r\n}\r\nstatic int is_supply_enabled(struct regulator_dev *rdev)\r\n{\r\nconst struct supply_info *info;\r\nstruct tps6524x *hw;\r\nhw = rdev_get_drvdata(rdev);\r\ninfo = &supply_info[rdev_get_id(rdev)];\r\nreturn read_field(hw, &info->enable);\r\n}\r\nstatic int pmic_remove(struct spi_device *spi)\r\n{\r\nstruct tps6524x *hw = spi_get_drvdata(spi);\r\nint i;\r\nif (!hw)\r\nreturn 0;\r\nfor (i = 0; i < N_REGULATORS; i++) {\r\nif (hw->rdev[i])\r\nregulator_unregister(hw->rdev[i]);\r\nhw->rdev[i] = NULL;\r\n}\r\nspi_set_drvdata(spi, NULL);\r\nkfree(hw);\r\nreturn 0;\r\n}\r\nstatic int __devinit pmic_probe(struct spi_device *spi)\r\n{\r\nstruct tps6524x *hw;\r\nstruct device *dev = &spi->dev;\r\nconst struct supply_info *info = supply_info;\r\nstruct regulator_init_data *init_data;\r\nint ret = 0, i;\r\ninit_data = dev->platform_data;\r\nif (!init_data) {\r\ndev_err(dev, "could not find regulator platform data\n");\r\nreturn -EINVAL;\r\n}\r\nhw = kzalloc(sizeof(struct tps6524x), GFP_KERNEL);\r\nif (!hw) {\r\ndev_err(dev, "cannot allocate regulator private data\n");\r\nreturn -ENOMEM;\r\n}\r\nspi_set_drvdata(spi, hw);\r\nmemset(hw, 0, sizeof(struct tps6524x));\r\nhw->dev = dev;\r\nhw->spi = spi_dev_get(spi);\r\nmutex_init(&hw->lock);\r\nfor (i = 0; i < N_REGULATORS; i++, info++, init_data++) {\r\nhw->desc[i].name = info->name;\r\nhw->desc[i].id = i;\r\nhw->desc[i].n_voltages = info->n_voltages;\r\nhw->desc[i].ops = &regulator_ops;\r\nhw->desc[i].type = REGULATOR_VOLTAGE;\r\nhw->desc[i].owner = THIS_MODULE;\r\nif (info->flags & FIXED_VOLTAGE)\r\nhw->desc[i].n_voltages = 1;\r\nhw->rdev[i] = regulator_register(&hw->desc[i], dev,\r\ninit_data, hw);\r\nif (IS_ERR(hw->rdev[i])) {\r\nret = PTR_ERR(hw->rdev[i]);\r\nhw->rdev[i] = NULL;\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\npmic_remove(spi);\r\nreturn ret;\r\n}\r\nstatic int __init pmic_driver_init(void)\r\n{\r\nreturn spi_register_driver(&pmic_driver);\r\n}\r\nstatic void __exit pmic_driver_exit(void)\r\n{\r\nspi_unregister_driver(&pmic_driver);\r\n}
