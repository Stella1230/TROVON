static void wait_for_vblank(struct drm_device *dev)\r\n{\r\nmdelay(20);\r\n}\r\nstatic void scu_busy_loop(void *scu_base)\r\n{\r\nu32 status = 0;\r\nu32 loop_count = 0;\r\nstatus = readl(scu_base + 0x04);\r\nwhile (status & 1) {\r\nudelay(1);\r\nstatus = readl(scu_base + 0x04);\r\nloop_count++;\r\nif (loop_count > 1000) {\r\nDRM_DEBUG_KMS("SCU IPC timed out");\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void mrst_hdmi_reset(struct drm_device *dev)\r\n{\r\nvoid *base;\r\nunsigned int scu_ipc_mmio = 0xff11c000;\r\nint scu_len = 1024;\r\nbase = ioremap((resource_size_t)scu_ipc_mmio, scu_len);\r\nif (base == NULL) {\r\nDRM_ERROR("failed to map SCU mmio\n");\r\nreturn;\r\n}\r\nwritel(0xff11d118, base + 0x0c);\r\nwritel(0x7fffffdf, base + 0x80);\r\nwritel(0x42005, base + 0x0);\r\nscu_busy_loop(base);\r\nwritel(0xff11d118, base + 0x0c);\r\nwritel(0x7fffffff, base + 0x80);\r\nwritel(0x42005, base + 0x0);\r\nscu_busy_loop(base);\r\niounmap(base);\r\n}\r\nstatic void mrst_hdmi_audio_enable(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nHDMI_WRITE(HDMI_HCR, 0x67);\r\nHDMI_READ(HDMI_HCR);\r\nHDMI_WRITE(0x51a8, 0x10);\r\nHDMI_READ(0x51a8);\r\nHDMI_WRITE(HDMI_AUDIO_CTRL, 0x1);\r\nHDMI_READ(HDMI_AUDIO_CTRL);\r\n}\r\nstatic void mrst_hdmi_audio_disable(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nHDMI_WRITE(0x51a8, 0x0);\r\nHDMI_READ(0x51a8);\r\nHDMI_WRITE(HDMI_AUDIO_CTRL, 0x0);\r\nHDMI_READ(HDMI_AUDIO_CTRL);\r\nHDMI_WRITE(HDMI_HCR, 0x47);\r\nHDMI_READ(HDMI_HCR);\r\n}\r\nvoid mrst_crtc_hdmi_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nu32 temp;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_OFF:\r\nREG_WRITE(VGACNTRL, 0x80000000);\r\ntemp = REG_READ(DSPBCNTR);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE(DSPBCNTR, temp & ~DISPLAY_PLANE_ENABLE);\r\nREG_READ(DSPBCNTR);\r\nREG_WRITE(DSPBSURF, REG_READ(DSPBSURF));\r\nREG_READ(DSPBSURF);\r\n}\r\ntemp = REG_READ(PIPEBCONF);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\nREG_WRITE(PIPEBCONF, temp & ~PIPEACONF_ENABLE);\r\nREG_READ(PIPEBCONF);\r\n}\r\ntemp = REG_READ(PCH_PIPEBCONF);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\nREG_WRITE(PCH_PIPEBCONF, temp & ~PIPEACONF_ENABLE);\r\nREG_READ(PCH_PIPEBCONF);\r\n}\r\nudelay(150);\r\ntemp = REG_READ(DPLL_CTRL);\r\nif ((temp & DPLL_PWRDN) == 0) {\r\nREG_WRITE(DPLL_CTRL, temp | (DPLL_PWRDN | DPLL_RESET));\r\nREG_WRITE(DPLL_STATUS, 0x1);\r\n}\r\nudelay(150);\r\nbreak;\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ntemp = REG_READ(DPLL_CTRL);\r\nif ((temp & DPLL_PWRDN) != 0) {\r\nREG_WRITE(DPLL_CTRL, temp & ~(DPLL_PWRDN | DPLL_RESET));\r\ntemp = REG_READ(DPLL_CLK_ENABLE);\r\nREG_WRITE(DPLL_CLK_ENABLE, temp | DPLL_EN_DISP | DPLL_SEL_HDMI | DPLL_EN_HDMI);\r\nREG_READ(DPLL_CLK_ENABLE);\r\n}\r\nudelay(150);\r\ntemp = REG_READ(PIPEBCONF);\r\nif ((temp & PIPEACONF_ENABLE) == 0) {\r\nREG_WRITE(PIPEBCONF, temp | PIPEACONF_ENABLE);\r\nREG_READ(PIPEBCONF);\r\n}\r\ntemp = REG_READ(PCH_PIPEBCONF);\r\nif ((temp & PIPEACONF_ENABLE) == 0) {\r\nREG_WRITE(PCH_PIPEBCONF, temp | PIPEACONF_ENABLE);\r\nREG_READ(PCH_PIPEBCONF);\r\n}\r\nwait_for_vblank(dev);\r\ntemp = REG_READ(DSPBCNTR);\r\nif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\r\nREG_WRITE(DSPBCNTR, temp | DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(DSPBSURF, REG_READ(DSPBSURF));\r\nREG_READ(DSPBSURF);\r\n}\r\npsb_intel_crtc_load_lut(crtc);\r\n}\r\nREG_WRITE(DSPARB, 0x00003fbf);\r\nREG_WRITE(0x70034, 0x3f880a0a);\r\nREG_WRITE(0x70038, 0x0b060808);\r\nREG_WRITE(0x70050, 0x08030404);\r\nREG_WRITE(0x70054, 0x04040404);\r\nREG_WRITE(0x70400, 0x4000);\r\n}\r\nstatic void mrst_hdmi_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstatic int dpms_mode = -1;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nu32 temp;\r\nif (dpms_mode == mode)\r\nreturn;\r\nif (mode != DRM_MODE_DPMS_ON)\r\ntemp = 0x0;\r\nelse\r\ntemp = 0x99;\r\ndpms_mode = mode;\r\nHDMI_WRITE(HDMI_VIDEO_REG, temp);\r\n}\r\nstatic unsigned int htotal_calculate(struct drm_display_mode *mode)\r\n{\r\nu32 htotal, new_crtc_htotal;\r\nhtotal = (mode->crtc_hdisplay - 1) | ((mode->crtc_htotal - 1) << 16);\r\nnew_crtc_htotal = (mode->crtc_htotal - 1) * 200 * 1000 / mode->clock;\r\nreturn (mode->crtc_hdisplay - 1) | (new_crtc_htotal << 16);\r\n}\r\nstatic void mrst_hdmi_find_dpll(struct drm_crtc *crtc, int target,\r\nint refclk, struct mrst_hdmi_clock *best_clock)\r\n{\r\nint np_min, np_max, nr_min, nr_max;\r\nint np, nr, nf;\r\nnp_min = DIV_ROUND_UP(mrst_hdmi_limit.vco.min, target * 10);\r\nnp_max = mrst_hdmi_limit.vco.max / (target * 10);\r\nif (np_min < mrst_hdmi_limit.np.min)\r\nnp_min = mrst_hdmi_limit.np.min;\r\nif (np_max > mrst_hdmi_limit.np.max)\r\nnp_max = mrst_hdmi_limit.np.max;\r\nnr_min = DIV_ROUND_UP((refclk * 1000), (target * 10 * np_max));\r\nnr_max = DIV_ROUND_UP((refclk * 1000), (target * 10 * np_min));\r\nif (nr_min < mrst_hdmi_limit.nr.min)\r\nnr_min = mrst_hdmi_limit.nr.min;\r\nif (nr_max > mrst_hdmi_limit.nr.max)\r\nnr_max = mrst_hdmi_limit.nr.max;\r\nnp = DIV_ROUND_UP((refclk * 1000), (target * 10 * nr_max));\r\nnr = DIV_ROUND_UP((refclk * 1000), (target * 10 * np));\r\nnf = DIV_ROUND_CLOSEST((target * 10 * np * nr), refclk);\r\nDRM_DEBUG_KMS("np, nr, nf %d %d %d\n", np, nr, nf);\r\nbest_clock->np = np;\r\nbest_clock->nr = nr - 1;\r\nbest_clock->nf = (nf << 14);\r\n}\r\nint mrst_crtc_hdmi_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nint pipe = 1;\r\nint htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;\r\nint hblank_reg = (pipe == 0) ? HBLANK_A : HBLANK_B;\r\nint hsync_reg = (pipe == 0) ? HSYNC_A : HSYNC_B;\r\nint vtot_reg = (pipe == 0) ? VTOTAL_A : VTOTAL_B;\r\nint vblank_reg = (pipe == 0) ? VBLANK_A : VBLANK_B;\r\nint vsync_reg = (pipe == 0) ? VSYNC_A : VSYNC_B;\r\nint dspsize_reg = (pipe == 0) ? DSPASIZE : DSPBSIZE;\r\nint dsppos_reg = (pipe == 0) ? DSPAPOS : DSPBPOS;\r\nint pipesrc_reg = (pipe == 0) ? PIPEASRC : PIPEBSRC;\r\nint pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;\r\nint refclk;\r\nstruct mrst_hdmi_clock clock;\r\nu32 dspcntr, pipeconf, dpll, temp;\r\nint dspcntr_reg = DSPBCNTR;\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\ndpll = REG_READ(DPLL_CTRL);\r\nif ((dpll & DPLL_PWRDN) == 0) {\r\nREG_WRITE(DPLL_CTRL, dpll | (DPLL_PWRDN | DPLL_RESET));\r\nREG_WRITE(DPLL_DIV_CTRL, 0x00000000);\r\nREG_WRITE(DPLL_STATUS, 0x1);\r\n}\r\nudelay(150);\r\niounmap(hdmi_dev->regs);\r\nmrst_hdmi_reset(dev);\r\nrefclk = 25000;\r\nmrst_hdmi_find_dpll(crtc, adjusted_mode->clock, refclk, &clock);\r\ndpll = REG_READ(DPLL_CTRL);\r\ndpll &= ~DPLL_PDIV_MASK;\r\ndpll &= ~(DPLL_PWRDN | DPLL_RESET);\r\nREG_WRITE(DPLL_CTRL, 0x00000008);\r\nREG_WRITE(DPLL_DIV_CTRL, ((clock.nf << 6) | clock.nr));\r\nREG_WRITE(DPLL_ADJUST, ((clock.nf >> 14) - 1));\r\nREG_WRITE(DPLL_CTRL, (dpll | (clock.np << DPLL_PDIV_SHIFT) | DPLL_ENSTAT | DPLL_DITHEN));\r\nREG_WRITE(DPLL_UPDATE, 0x80000000);\r\nREG_WRITE(DPLL_CLK_ENABLE, 0x80050102);\r\nudelay(150);\r\nhdmi_dev->regs = ioremap(hdmi_dev->mmio, hdmi_dev->mmio_len);\r\nif (hdmi_dev->regs == NULL) {\r\nDRM_ERROR("failed to do hdmi mmio mapping\n");\r\nreturn -ENOMEM;\r\n}\r\nHDMI_WRITE(0x1004, 0x1fd);\r\nHDMI_WRITE(0x2000, 0x1);\r\nHDMI_WRITE(0x2008, 0x0);\r\nHDMI_WRITE(0x3130, 0x8);\r\nHDMI_WRITE(0x101c, 0x1800810);\r\ntemp = htotal_calculate(adjusted_mode);\r\nREG_WRITE(htot_reg, temp);\r\nREG_WRITE(hblank_reg, (adjusted_mode->crtc_hblank_start - 1) | ((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(hsync_reg, (adjusted_mode->crtc_hsync_start - 1) | ((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(vtot_reg, (adjusted_mode->crtc_vdisplay - 1) | ((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(vblank_reg, (adjusted_mode->crtc_vblank_start - 1) | ((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(vsync_reg, (adjusted_mode->crtc_vsync_start - 1) | ((adjusted_mode->crtc_vsync_end - 1) << 16));\r\nREG_WRITE(pipesrc_reg,\r\n((mode->crtc_hdisplay - 1) << 16) | (mode->crtc_vdisplay - 1));\r\nREG_WRITE(PCH_HTOTAL_B, (adjusted_mode->crtc_hdisplay - 1) | ((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(PCH_HBLANK_B, (adjusted_mode->crtc_hblank_start - 1) | ((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(PCH_HSYNC_B, (adjusted_mode->crtc_hsync_start - 1) | ((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(PCH_VTOTAL_B, (adjusted_mode->crtc_vdisplay - 1) | ((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(PCH_VBLANK_B, (adjusted_mode->crtc_vblank_start - 1) | ((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(PCH_VSYNC_B, (adjusted_mode->crtc_vsync_start - 1) | ((adjusted_mode->crtc_vsync_end - 1) << 16));\r\nREG_WRITE(PCH_PIPEBSRC,\r\n((mode->crtc_hdisplay - 1) << 16) | (mode->crtc_vdisplay - 1));\r\ntemp = adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start;\r\nHDMI_WRITE(HDMI_HBLANK_A, ((adjusted_mode->crtc_hdisplay - 1) << 16) | temp);\r\nREG_WRITE(dspsize_reg,\r\n((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(dsppos_reg, 0);\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\n}\r\ndspcntr = REG_READ(dspcntr_reg);\r\ndspcntr |= DISPPLANE_GAMMA_ENABLE;\r\ndspcntr |= DISPPLANE_SEL_PIPE_B;\r\ndspcntr |= DISPLAY_PLANE_ENABLE;\r\npipeconf = REG_READ(pipeconf_reg);\r\npipeconf |= PIPEACONF_ENABLE;\r\nREG_WRITE(pipeconf_reg, pipeconf);\r\nREG_READ(pipeconf_reg);\r\nREG_WRITE(PCH_PIPEBCONF, pipeconf);\r\nREG_READ(PCH_PIPEBCONF);\r\nwait_for_vblank(dev);\r\nREG_WRITE(dspcntr_reg, dspcntr);\r\nwait_for_vblank(dev);\r\nreturn 0;\r\n}\r\nstatic int mrst_hdmi_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock > 165000)\r\nreturn MODE_CLOCK_HIGH;\r\nif (mode->clock < 20000)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nreturn MODE_OK;\r\n}\r\nstatic bool mrst_hdmi_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic enum drm_connector_status\r\nmrst_hdmi_detect(struct drm_connector *connector, bool force)\r\n{\r\nenum drm_connector_status status;\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nu32 temp;\r\ntemp = HDMI_READ(HDMI_HSR);\r\nDRM_DEBUG_KMS("HDMI_HSR %x\n", temp);\r\nif ((temp & HDMI_DETECT_HDP) != 0)\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = connector_status_disconnected;\r\nreturn status;\r\n}\r\nstatic int mrst_hdmi_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct edid *edid;\r\nstruct drm_display_mode *mode, *t;\r\nint i = 0, ret = 0;\r\ni2c_adap = i2c_get_adapter(3);\r\nif (i2c_adap == NULL) {\r\nDRM_ERROR("No ddc adapter available!\n");\r\nedid = (struct edid *)raw_edid;\r\n} else {\r\nedid = (struct edid *)raw_edid;\r\n}\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nconnector->display_info.raw_edid = NULL;\r\n}\r\nlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\r\nif ((mode->hdisplay * mode->vdisplay * 4) >= dev_priv->vram_stolen_size) {\r\ni++;\r\ndrm_mode_remove(connector, mode);\r\n}\r\n}\r\nreturn ret - i;\r\n}\r\nstatic void mrst_hdmi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nmrst_hdmi_audio_enable(dev);\r\nreturn;\r\n}\r\nstatic void mrst_hdmi_destroy(struct drm_connector *connector)\r\n{\r\nreturn;\r\n}\r\nstatic void mrst_hdmi_enc_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nvoid mrst_hdmi_init(struct drm_device *dev,\r\nstruct psb_intel_mode_device *mode_dev)\r\n{\r\nstruct psb_intel_output *psb_intel_output;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\npsb_intel_output = kzalloc(sizeof(struct psb_intel_output), GFP_KERNEL);\r\nif (!psb_intel_output)\r\nreturn;\r\npsb_intel_output->mode_dev = mode_dev;\r\nconnector = &psb_intel_output->base;\r\nencoder = &psb_intel_output->enc;\r\ndrm_connector_init(dev, &psb_intel_output->base,\r\n&mrst_hdmi_connector_funcs,\r\nDRM_MODE_CONNECTOR_DVID);\r\ndrm_encoder_init(dev, &psb_intel_output->enc,\r\n&mrst_hdmi_enc_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\ndrm_mode_connector_attach_encoder(&psb_intel_output->base,\r\n&psb_intel_output->enc);\r\npsb_intel_output->type = INTEL_OUTPUT_HDMI;\r\ndrm_encoder_helper_add(encoder, &mrst_hdmi_helper_funcs);\r\ndrm_connector_helper_add(connector, &mrst_hdmi_connector_helper_funcs);\r\nconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_sysfs_connector_add(connector);\r\nreturn;\r\n}\r\nvoid mrst_hdmi_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct pci_dev *pdev;\r\nstruct mrst_hdmi_dev *hdmi_dev;\r\nint ret;\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x080d, NULL);\r\nif (!pdev)\r\nreturn;\r\nhdmi_dev = kzalloc(sizeof(struct mrst_hdmi_dev), GFP_KERNEL);\r\nif (!hdmi_dev) {\r\ndev_err(dev->dev, "failed to allocate memory\n");\r\ngoto out;\r\n}\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to enable hdmi controller\n");\r\ngoto free;\r\n}\r\nhdmi_dev->mmio = pci_resource_start(pdev, 0);\r\nhdmi_dev->mmio_len = pci_resource_len(pdev, 0);\r\nhdmi_dev->regs = ioremap(hdmi_dev->mmio, hdmi_dev->mmio_len);\r\nif (!hdmi_dev->regs) {\r\ndev_err(dev->dev, "failed to map hdmi mmio\n");\r\ngoto free;\r\n}\r\nhdmi_dev->dev = pdev;\r\npci_set_drvdata(pdev, hdmi_dev);\r\nret = mrst_hdmi_i2c_init(hdmi_dev->dev);\r\nif (ret)\r\ndev_err(dev->dev, "HDMI I2C initialization failed\n");\r\ndev_priv->hdmi_priv = hdmi_dev;\r\nmrst_hdmi_audio_disable(dev);\r\nreturn;\r\nfree:\r\nkfree(hdmi_dev);\r\nout:\r\nreturn;\r\n}\r\nvoid mrst_hdmi_teardown(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nstruct pci_dev *pdev;\r\nif (hdmi_dev) {\r\npdev = hdmi_dev->dev;\r\npci_set_drvdata(pdev, NULL);\r\nmrst_hdmi_i2c_exit(pdev);\r\niounmap(hdmi_dev->regs);\r\nkfree(hdmi_dev);\r\npci_dev_put(pdev);\r\n}\r\n}\r\nvoid mrst_hdmi_save(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nint i;\r\nhdmi_dev->saveDPLL_CTRL = PSB_RVDC32(DPLL_CTRL);\r\nhdmi_dev->saveDPLL_DIV_CTRL = PSB_RVDC32(DPLL_DIV_CTRL);\r\nhdmi_dev->saveDPLL_ADJUST = PSB_RVDC32(DPLL_ADJUST);\r\nhdmi_dev->saveDPLL_UPDATE = PSB_RVDC32(DPLL_UPDATE);\r\nhdmi_dev->saveDPLL_CLK_ENABLE = PSB_RVDC32(DPLL_CLK_ENABLE);\r\ndev_priv->savePIPEBCONF = PSB_RVDC32(PIPEBCONF);\r\ndev_priv->savePIPEBSRC = PSB_RVDC32(PIPEBSRC);\r\ndev_priv->saveHTOTAL_B = PSB_RVDC32(HTOTAL_B);\r\ndev_priv->saveHBLANK_B = PSB_RVDC32(HBLANK_B);\r\ndev_priv->saveHSYNC_B = PSB_RVDC32(HSYNC_B);\r\ndev_priv->saveVTOTAL_B = PSB_RVDC32(VTOTAL_B);\r\ndev_priv->saveVBLANK_B = PSB_RVDC32(VBLANK_B);\r\ndev_priv->saveVSYNC_B = PSB_RVDC32(VSYNC_B);\r\nhdmi_dev->savePCH_PIPEBCONF = PSB_RVDC32(PCH_PIPEBCONF);\r\nhdmi_dev->savePCH_PIPEBSRC = PSB_RVDC32(PCH_PIPEBSRC);\r\nhdmi_dev->savePCH_HTOTAL_B = PSB_RVDC32(PCH_HTOTAL_B);\r\nhdmi_dev->savePCH_HBLANK_B = PSB_RVDC32(PCH_HBLANK_B);\r\nhdmi_dev->savePCH_HSYNC_B = PSB_RVDC32(PCH_HSYNC_B);\r\nhdmi_dev->savePCH_VTOTAL_B = PSB_RVDC32(PCH_VTOTAL_B);\r\nhdmi_dev->savePCH_VBLANK_B = PSB_RVDC32(PCH_VBLANK_B);\r\nhdmi_dev->savePCH_VSYNC_B = PSB_RVDC32(PCH_VSYNC_B);\r\ndev_priv->saveDSPBCNTR = PSB_RVDC32(DSPBCNTR);\r\ndev_priv->saveDSPBSTRIDE = PSB_RVDC32(DSPBSTRIDE);\r\ndev_priv->saveDSPBADDR = PSB_RVDC32(DSPBBASE);\r\ndev_priv->saveDSPBSURF = PSB_RVDC32(DSPBSURF);\r\ndev_priv->saveDSPBLINOFF = PSB_RVDC32(DSPBLINOFF);\r\ndev_priv->saveDSPBTILEOFF = PSB_RVDC32(DSPBTILEOFF);\r\ndev_priv->saveDSPBCURSOR_CTRL = PSB_RVDC32(CURBCNTR);\r\ndev_priv->saveDSPBCURSOR_BASE = PSB_RVDC32(CURBBASE);\r\ndev_priv->saveDSPBCURSOR_POS = PSB_RVDC32(CURBPOS);\r\nfor (i = 0; i < 256; i++)\r\ndev_priv->save_palette_b[i] = PSB_RVDC32(PALETTE_B + (i << 2));\r\n}\r\nvoid mrst_hdmi_restore(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_hdmi_dev *hdmi_dev = dev_priv->hdmi_priv;\r\nint i;\r\nPSB_WVDC32(hdmi_dev->saveDPLL_CTRL, DPLL_CTRL);\r\nPSB_WVDC32(hdmi_dev->saveDPLL_DIV_CTRL, DPLL_DIV_CTRL);\r\nPSB_WVDC32(hdmi_dev->saveDPLL_ADJUST, DPLL_ADJUST);\r\nPSB_WVDC32(hdmi_dev->saveDPLL_UPDATE, DPLL_UPDATE);\r\nPSB_WVDC32(hdmi_dev->saveDPLL_CLK_ENABLE, DPLL_CLK_ENABLE);\r\nDRM_UDELAY(150);\r\nPSB_WVDC32(dev_priv->savePIPEBSRC, PIPEBSRC);\r\nPSB_WVDC32(dev_priv->saveHTOTAL_B, HTOTAL_B);\r\nPSB_WVDC32(dev_priv->saveHBLANK_B, HBLANK_B);\r\nPSB_WVDC32(dev_priv->saveHSYNC_B, HSYNC_B);\r\nPSB_WVDC32(dev_priv->saveVTOTAL_B, VTOTAL_B);\r\nPSB_WVDC32(dev_priv->saveVBLANK_B, VBLANK_B);\r\nPSB_WVDC32(dev_priv->saveVSYNC_B, VSYNC_B);\r\nPSB_WVDC32(hdmi_dev->savePCH_PIPEBSRC, PCH_PIPEBSRC);\r\nPSB_WVDC32(hdmi_dev->savePCH_HTOTAL_B, PCH_HTOTAL_B);\r\nPSB_WVDC32(hdmi_dev->savePCH_HBLANK_B, PCH_HBLANK_B);\r\nPSB_WVDC32(hdmi_dev->savePCH_HSYNC_B, PCH_HSYNC_B);\r\nPSB_WVDC32(hdmi_dev->savePCH_VTOTAL_B, PCH_VTOTAL_B);\r\nPSB_WVDC32(hdmi_dev->savePCH_VBLANK_B, PCH_VBLANK_B);\r\nPSB_WVDC32(hdmi_dev->savePCH_VSYNC_B, PCH_VSYNC_B);\r\nPSB_WVDC32(dev_priv->savePIPEBCONF, PIPEBCONF);\r\nPSB_WVDC32(hdmi_dev->savePCH_PIPEBCONF, PCH_PIPEBCONF);\r\nPSB_WVDC32(dev_priv->saveDSPBLINOFF, DSPBLINOFF);\r\nPSB_WVDC32(dev_priv->saveDSPBSTRIDE, DSPBSTRIDE);\r\nPSB_WVDC32(dev_priv->saveDSPBTILEOFF, DSPBTILEOFF);\r\nPSB_WVDC32(dev_priv->saveDSPBCNTR, DSPBCNTR);\r\nPSB_WVDC32(dev_priv->saveDSPBSURF, DSPBSURF);\r\nPSB_WVDC32(dev_priv->saveDSPBCURSOR_CTRL, CURBCNTR);\r\nPSB_WVDC32(dev_priv->saveDSPBCURSOR_POS, CURBPOS);\r\nPSB_WVDC32(dev_priv->saveDSPBCURSOR_BASE, CURBBASE);\r\nfor (i = 0; i < 256; i++)\r\nPSB_WVDC32(dev_priv->save_palette_b[i], PALETTE_B + (i << 2));\r\n}
