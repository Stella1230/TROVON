static int tua6100_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int tua6100_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tua6100_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 reg0[] = { 0x00, 0x00 };\r\nstruct i2c_msg msg = { .addr = priv->i2c_address, .flags = 0, .buf = reg0, .len = 2 };\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif ((ret = i2c_transfer (priv->i2c, &msg, 1)) != 1) {\r\nprintk("%s: i2c error\n", __func__);\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn (ret == 1) ? 0 : ret;\r\n}\r\nstatic int tua6100_set_params(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *params)\r\n{\r\nstruct tua6100_priv *priv = fe->tuner_priv;\r\nu32 div;\r\nu32 prediv;\r\nu8 reg0[] = { 0x00, 0x00 };\r\nu8 reg1[] = { 0x01, 0x00, 0x00, 0x00 };\r\nu8 reg2[] = { 0x02, 0x00, 0x00 };\r\nstruct i2c_msg msg0 = { .addr = priv->i2c_address, .flags = 0, .buf = reg0, .len = 2 };\r\nstruct i2c_msg msg1 = { .addr = priv->i2c_address, .flags = 0, .buf = reg1, .len = 4 };\r\nstruct i2c_msg msg2 = { .addr = priv->i2c_address, .flags = 0, .buf = reg2, .len = 3 };\r\n#define _R 4\r\n#define _P 32\r\n#define _ri 4000000\r\nif (params->frequency < 2000000) {\r\nreg0[1] = 0x03;\r\n} else {\r\nreg0[1] = 0x07;\r\n}\r\nif (params->frequency < 1630000) {\r\nreg1[1] = 0x2c;\r\n} else {\r\nreg1[1] = 0x0c;\r\n}\r\nif (_P == 64)\r\nreg1[1] |= 0x40;\r\nif (params->frequency >= 1525000)\r\nreg1[1] |= 0x80;\r\nreg2[1] = (_R >> 8) & 0x03;\r\nreg2[2] = _R;\r\nif (params->frequency < 1455000) {\r\nreg2[1] |= 0x1c;\r\n} else if (params->frequency < 1630000) {\r\nreg2[1] |= 0x0c;\r\n} else {\r\nreg2[1] |= 0x1c;\r\n}\r\nprediv = (params->frequency * _R) / (_ri / 1000);\r\ndiv = prediv / _P;\r\nreg1[1] |= (div >> 9) & 0x03;\r\nreg1[2] = div >> 1;\r\nreg1[3] = (div << 7);\r\npriv->frequency = ((div * _P) * (_ri / 1000)) / _R;\r\nreg1[3] |= (prediv - (div*_P)) & 0x7f;\r\n#undef _R\r\n#undef _P\r\n#undef _ri\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(priv->i2c, &msg0, 1) != 1)\r\nreturn -EIO;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(priv->i2c, &msg2, 1) != 1)\r\nreturn -EIO;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(priv->i2c, &msg1, 1) != 1)\r\nreturn -EIO;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int tua6100_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tua6100_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tua6100_attach(struct dvb_frontend *fe, int addr, struct i2c_adapter *i2c)\r\n{\r\nstruct tua6100_priv *priv = NULL;\r\nu8 b1 [] = { 0x80 };\r\nu8 b2 [] = { 0x00 };\r\nstruct i2c_msg msg [] = { { .addr = addr, .flags = 0, .buf = b1, .len = 1 },\r\n{ .addr = addr, .flags = I2C_M_RD, .buf = b2, .len = 1 } };\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer (i2c, msg, 2);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret != 2)\r\nreturn NULL;\r\npriv = kzalloc(sizeof(struct tua6100_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = addr;\r\npriv->i2c = i2c;\r\nmemcpy(&fe->ops.tuner_ops, &tua6100_tuner_ops, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\nreturn fe;\r\n}
