static inline struct amradio_device *to_amradio_dev(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct amradio_device, v4l2_dev);\r\n}\r\nstatic int amradio_set_mute(struct amradio_device *radio, char argument)\r\n{\r\nint retval;\r\nint size;\r\nradio->buffer[0] = 0x00;\r\nradio->buffer[1] = 0x55;\r\nradio->buffer[2] = 0xaa;\r\nradio->buffer[3] = 0x00;\r\nradio->buffer[4] = AMRADIO_SET_MUTE;\r\nradio->buffer[5] = argument;\r\nradio->buffer[6] = 0x00;\r\nradio->buffer[7] = 0x00;\r\nretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\r\n(void *) (radio->buffer), BUFFER_LENGTH, &size, USB_TIMEOUT);\r\nif (retval < 0 || size != BUFFER_LENGTH) {\r\namradio_dev_warn(&radio->videodev.dev, "set mute failed\n");\r\nreturn retval;\r\n}\r\nradio->muted = argument;\r\nreturn retval;\r\n}\r\nstatic int amradio_setfreq(struct amradio_device *radio, int freq)\r\n{\r\nint retval;\r\nint size;\r\nunsigned short freq_send = 0x10 + (freq >> 3) / 25;\r\nradio->buffer[0] = 0x00;\r\nradio->buffer[1] = 0x55;\r\nradio->buffer[2] = 0xaa;\r\nradio->buffer[3] = 0x03;\r\nradio->buffer[4] = AMRADIO_SET_FREQ;\r\nradio->buffer[5] = 0x00;\r\nradio->buffer[6] = 0x00;\r\nradio->buffer[7] = 0x08;\r\nretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\r\n(void *) (radio->buffer), BUFFER_LENGTH, &size, USB_TIMEOUT);\r\nif (retval < 0 || size != BUFFER_LENGTH)\r\ngoto out_err;\r\nradio->buffer[0] = (freq_send >> 8) & 0xff;\r\nradio->buffer[1] = freq_send & 0xff;\r\nradio->buffer[2] = 0x01;\r\nradio->buffer[3] = 0x00;\r\nradio->buffer[4] = 0x00;\r\nradio->buffer[7] = 0x00;\r\nretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\r\n(void *) (radio->buffer), BUFFER_LENGTH, &size, USB_TIMEOUT);\r\nif (retval < 0 || size != BUFFER_LENGTH)\r\ngoto out_err;\r\nradio->curfreq = freq;\r\ngoto out;\r\nout_err:\r\namradio_dev_warn(&radio->videodev.dev, "set frequency failed\n");\r\nout:\r\nreturn retval;\r\n}\r\nstatic int amradio_set_stereo(struct amradio_device *radio, char argument)\r\n{\r\nint retval;\r\nint size;\r\nradio->buffer[0] = 0x00;\r\nradio->buffer[1] = 0x55;\r\nradio->buffer[2] = 0xaa;\r\nradio->buffer[3] = 0x00;\r\nradio->buffer[4] = AMRADIO_SET_MONO;\r\nradio->buffer[5] = argument;\r\nradio->buffer[6] = 0x00;\r\nradio->buffer[7] = 0x00;\r\nretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\r\n(void *) (radio->buffer), BUFFER_LENGTH, &size, USB_TIMEOUT);\r\nif (retval < 0 || size != BUFFER_LENGTH) {\r\namradio_dev_warn(&radio->videodev.dev, "set stereo failed\n");\r\nreturn retval;\r\n}\r\nif (argument == WANT_STEREO)\r\nradio->stereo = 1;\r\nelse\r\nradio->stereo = 0;\r\nreturn retval;\r\n}\r\nstatic void usb_amradio_disconnect(struct usb_interface *intf)\r\n{\r\nstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\r\nmutex_lock(&radio->lock);\r\nget_device(&radio->videodev.dev);\r\nv4l2_device_disconnect(&radio->v4l2_dev);\r\nvideo_unregister_device(&radio->videodev);\r\nmutex_unlock(&radio->lock);\r\nput_device(&radio->videodev.dev);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nstrlcpy(v->driver, "radio-mr800", sizeof(v->driver));\r\nstrlcpy(v->card, "AverMedia MR 800 USB FM Radio", sizeof(v->card));\r\nusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nint retval;\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nretval = amradio_set_stereo(radio, WANT_STEREO);\r\nstrcpy(v->name, "FM");\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = FREQ_MIN * FREQ_MUL;\r\nv->rangehigh = FREQ_MAX * FREQ_MUL;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nif (radio->stereo)\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nelse\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nv->signal = 0xffff;\r\nv->afc = 0;\r\nreturn retval;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nint retval = -EINVAL;\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nswitch (v->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nretval = amradio_set_stereo(radio, WANT_MONO);\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nretval = amradio_set_stereo(radio, WANT_STEREO);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nreturn amradio_setfreq(radio, f->frequency);\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = radio->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = radio->muted;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nint retval = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value)\r\nretval = amradio_set_mute(radio, AMRADIO_STOP);\r\nelse\r\nretval = amradio_set_mute(radio, AMRADIO_START);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nif (a->index > 1)\r\nreturn -EINVAL;\r\nstrcpy(a->name, "Radio");\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nif (a->index != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int usb_amradio_init(struct amradio_device *radio)\r\n{\r\nint retval;\r\nretval = amradio_set_mute(radio, AMRADIO_STOP);\r\nif (retval)\r\ngoto out_err;\r\nretval = amradio_set_stereo(radio, WANT_STEREO);\r\nif (retval)\r\ngoto out_err;\r\nradio->initialized = 1;\r\ngoto out;\r\nout_err:\r\namradio_dev_err(&radio->videodev.dev, "initialization failed\n");\r\nout:\r\nreturn retval;\r\n}\r\nstatic int usb_amradio_open(struct file *file)\r\n{\r\nstruct amradio_device *radio = video_drvdata(file);\r\nint retval;\r\nfile->private_data = radio;\r\nretval = usb_autopm_get_interface(radio->intf);\r\nif (retval)\r\nreturn retval;\r\nif (unlikely(!radio->initialized)) {\r\nretval = usb_amradio_init(radio);\r\nif (retval)\r\nusb_autopm_put_interface(radio->intf);\r\n}\r\nreturn retval;\r\n}\r\nstatic int usb_amradio_close(struct file *file)\r\n{\r\nstruct amradio_device *radio = file->private_data;\r\nif (video_is_registered(&radio->videodev))\r\nusb_autopm_put_interface(radio->intf);\r\nreturn 0;\r\n}\r\nstatic int usb_amradio_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\r\nmutex_lock(&radio->lock);\r\nif (!radio->muted && radio->initialized) {\r\namradio_set_mute(radio, AMRADIO_STOP);\r\nradio->muted = 0;\r\n}\r\nmutex_unlock(&radio->lock);\r\ndev_info(&intf->dev, "going into suspend..\n");\r\nreturn 0;\r\n}\r\nstatic int usb_amradio_resume(struct usb_interface *intf)\r\n{\r\nstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\r\nmutex_lock(&radio->lock);\r\nif (unlikely(!radio->initialized))\r\ngoto unlock;\r\nif (radio->stereo)\r\namradio_set_stereo(radio, WANT_STEREO);\r\nelse\r\namradio_set_stereo(radio, WANT_MONO);\r\namradio_setfreq(radio, radio->curfreq);\r\nif (!radio->muted)\r\namradio_set_mute(radio, AMRADIO_START);\r\nunlock:\r\nmutex_unlock(&radio->lock);\r\ndev_info(&intf->dev, "coming out of suspend..\n");\r\nreturn 0;\r\n}\r\nstatic void usb_amradio_video_device_release(struct video_device *videodev)\r\n{\r\nstruct amradio_device *radio = video_get_drvdata(videodev);\r\nkfree(radio->buffer);\r\nkfree(radio);\r\n}\r\nstatic int usb_amradio_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct amradio_device *radio;\r\nint retval = 0;\r\nradio = kzalloc(sizeof(struct amradio_device), GFP_KERNEL);\r\nif (!radio) {\r\ndev_err(&intf->dev, "kmalloc for amradio_device failed\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\r\nif (!radio->buffer) {\r\ndev_err(&intf->dev, "kmalloc for radio->buffer failed\n");\r\nretval = -ENOMEM;\r\ngoto err_nobuf;\r\n}\r\nretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "couldn't register v4l2_device\n");\r\ngoto err_v4l2;\r\n}\r\nmutex_init(&radio->lock);\r\nstrlcpy(radio->videodev.name, radio->v4l2_dev.name,\r\nsizeof(radio->videodev.name));\r\nradio->videodev.v4l2_dev = &radio->v4l2_dev;\r\nradio->videodev.fops = &usb_amradio_fops;\r\nradio->videodev.ioctl_ops = &usb_amradio_ioctl_ops;\r\nradio->videodev.release = usb_amradio_video_device_release;\r\nradio->videodev.lock = &radio->lock;\r\nradio->usbdev = interface_to_usbdev(intf);\r\nradio->intf = intf;\r\nradio->curfreq = 95.16 * FREQ_MUL;\r\nvideo_set_drvdata(&radio->videodev, radio);\r\nretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,\r\nradio_nr);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "could not register video device\n");\r\ngoto err_vdev;\r\n}\r\nreturn 0;\r\nerr_vdev:\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nerr_v4l2:\r\nkfree(radio->buffer);\r\nerr_nobuf:\r\nkfree(radio);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int __init amradio_init(void)\r\n{\r\nint retval = usb_register(&usb_amradio_driver);\r\npr_info(KBUILD_MODNAME\r\n": version " DRIVER_VERSION " " DRIVER_DESC "\n");\r\nif (retval)\r\npr_err(KBUILD_MODNAME\r\n": usb_register failed. Error number %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic void __exit amradio_exit(void)\r\n{\r\nusb_deregister(&usb_amradio_driver);\r\n}
