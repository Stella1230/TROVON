static bool fw_get_builtin_firmware(struct firmware *fw, const char *name)\r\n{\r\nstruct builtin_fw *b_fw;\r\nfor (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {\r\nif (strcmp(name, b_fw->name) == 0) {\r\nfw->size = b_fw->size;\r\nfw->data = b_fw->data;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool fw_is_builtin_firmware(const struct firmware *fw)\r\n{\r\nstruct builtin_fw *b_fw;\r\nfor (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++)\r\nif (fw->data == b_fw->data)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool fw_get_builtin_firmware(struct firmware *fw, const char *name)\r\n{\r\nreturn false;\r\n}\r\nstatic inline bool fw_is_builtin_firmware(const struct firmware *fw)\r\n{\r\nreturn false;\r\n}\r\nstatic struct firmware_priv *to_firmware_priv(struct device *dev)\r\n{\r\nreturn container_of(dev, struct firmware_priv, dev);\r\n}\r\nstatic void fw_load_abort(struct firmware_priv *fw_priv)\r\n{\r\nset_bit(FW_STATUS_ABORT, &fw_priv->status);\r\nwmb();\r\ncomplete(&fw_priv->completion);\r\n}\r\nstatic ssize_t firmware_timeout_show(struct class *class,\r\nstruct class_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", loading_timeout);\r\n}\r\nstatic ssize_t firmware_timeout_store(struct class *class,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nloading_timeout = simple_strtol(buf, NULL, 10);\r\nif (loading_timeout < 0)\r\nloading_timeout = 0;\r\nreturn count;\r\n}\r\nstatic void fw_dev_release(struct device *dev)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nint i;\r\nfor (i = 0; i < fw_priv->nr_pages; i++)\r\n__free_page(fw_priv->pages[i]);\r\nkfree(fw_priv->pages);\r\nkfree(fw_priv);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nif (add_uevent_var(env, "FIRMWARE=%s", fw_priv->fw_id))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "TIMEOUT=%i", loading_timeout))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "ASYNC=%d", fw_priv->nowait))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic ssize_t firmware_loading_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nint loading = test_bit(FW_STATUS_LOADING, &fw_priv->status);\r\nreturn sprintf(buf, "%d\n", loading);\r\n}\r\nstatic void firmware_free_data(const struct firmware *fw)\r\n{\r\nint i;\r\nvunmap(fw->data);\r\nif (fw->pages) {\r\nfor (i = 0; i < PFN_UP(fw->size); i++)\r\n__free_page(fw->pages[i]);\r\nkfree(fw->pages);\r\n}\r\n}\r\nstatic ssize_t firmware_loading_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nint loading = simple_strtol(buf, NULL, 10);\r\nint i;\r\nswitch (loading) {\r\ncase 1:\r\nmutex_lock(&fw_lock);\r\nif (!fw_priv->fw) {\r\nmutex_unlock(&fw_lock);\r\nbreak;\r\n}\r\nfirmware_free_data(fw_priv->fw);\r\nmemset(fw_priv->fw, 0, sizeof(struct firmware));\r\nfor (i = 0; i < fw_priv->nr_pages; i++)\r\n__free_page(fw_priv->pages[i]);\r\nkfree(fw_priv->pages);\r\nfw_priv->pages = NULL;\r\nfw_priv->page_array_size = 0;\r\nfw_priv->nr_pages = 0;\r\nset_bit(FW_STATUS_LOADING, &fw_priv->status);\r\nmutex_unlock(&fw_lock);\r\nbreak;\r\ncase 0:\r\nif (test_bit(FW_STATUS_LOADING, &fw_priv->status)) {\r\nvunmap(fw_priv->fw->data);\r\nfw_priv->fw->data = vmap(fw_priv->pages,\r\nfw_priv->nr_pages,\r\n0, PAGE_KERNEL_RO);\r\nif (!fw_priv->fw->data) {\r\ndev_err(dev, "%s: vmap() failed\n", __func__);\r\ngoto err;\r\n}\r\nfw_priv->fw->pages = fw_priv->pages;\r\nfw_priv->pages = NULL;\r\nfw_priv->page_array_size = 0;\r\nfw_priv->nr_pages = 0;\r\ncomplete(&fw_priv->completion);\r\nclear_bit(FW_STATUS_LOADING, &fw_priv->status);\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(dev, "%s: unexpected value (%d)\n", __func__, loading);\r\ncase -1:\r\nerr:\r\nfw_load_abort(fw_priv);\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t firmware_data_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = to_dev(kobj);\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nstruct firmware *fw;\r\nssize_t ret_count;\r\nmutex_lock(&fw_lock);\r\nfw = fw_priv->fw;\r\nif (!fw || test_bit(FW_STATUS_DONE, &fw_priv->status)) {\r\nret_count = -ENODEV;\r\ngoto out;\r\n}\r\nif (offset > fw->size) {\r\nret_count = 0;\r\ngoto out;\r\n}\r\nif (count > fw->size - offset)\r\ncount = fw->size - offset;\r\nret_count = count;\r\nwhile (count) {\r\nvoid *page_data;\r\nint page_nr = offset >> PAGE_SHIFT;\r\nint page_ofs = offset & (PAGE_SIZE-1);\r\nint page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);\r\npage_data = kmap(fw_priv->pages[page_nr]);\r\nmemcpy(buffer, page_data + page_ofs, page_cnt);\r\nkunmap(fw_priv->pages[page_nr]);\r\nbuffer += page_cnt;\r\noffset += page_cnt;\r\ncount -= page_cnt;\r\n}\r\nout:\r\nmutex_unlock(&fw_lock);\r\nreturn ret_count;\r\n}\r\nstatic int fw_realloc_buffer(struct firmware_priv *fw_priv, int min_size)\r\n{\r\nint pages_needed = ALIGN(min_size, PAGE_SIZE) >> PAGE_SHIFT;\r\nif (fw_priv->page_array_size < pages_needed) {\r\nint new_array_size = max(pages_needed,\r\nfw_priv->page_array_size * 2);\r\nstruct page **new_pages;\r\nnew_pages = kmalloc(new_array_size * sizeof(void *),\r\nGFP_KERNEL);\r\nif (!new_pages) {\r\nfw_load_abort(fw_priv);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(new_pages, fw_priv->pages,\r\nfw_priv->page_array_size * sizeof(void *));\r\nmemset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *\r\n(new_array_size - fw_priv->page_array_size));\r\nkfree(fw_priv->pages);\r\nfw_priv->pages = new_pages;\r\nfw_priv->page_array_size = new_array_size;\r\n}\r\nwhile (fw_priv->nr_pages < pages_needed) {\r\nfw_priv->pages[fw_priv->nr_pages] =\r\nalloc_page(GFP_KERNEL | __GFP_HIGHMEM);\r\nif (!fw_priv->pages[fw_priv->nr_pages]) {\r\nfw_load_abort(fw_priv);\r\nreturn -ENOMEM;\r\n}\r\nfw_priv->nr_pages++;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t firmware_data_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = to_dev(kobj);\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nstruct firmware *fw;\r\nssize_t retval;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nmutex_lock(&fw_lock);\r\nfw = fw_priv->fw;\r\nif (!fw || test_bit(FW_STATUS_DONE, &fw_priv->status)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nretval = fw_realloc_buffer(fw_priv, offset + count);\r\nif (retval)\r\ngoto out;\r\nretval = count;\r\nwhile (count) {\r\nvoid *page_data;\r\nint page_nr = offset >> PAGE_SHIFT;\r\nint page_ofs = offset & (PAGE_SIZE - 1);\r\nint page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);\r\npage_data = kmap(fw_priv->pages[page_nr]);\r\nmemcpy(page_data + page_ofs, buffer, page_cnt);\r\nkunmap(fw_priv->pages[page_nr]);\r\nbuffer += page_cnt;\r\noffset += page_cnt;\r\ncount -= page_cnt;\r\n}\r\nfw->size = max_t(size_t, offset, fw->size);\r\nout:\r\nmutex_unlock(&fw_lock);\r\nreturn retval;\r\n}\r\nstatic void firmware_class_timeout(u_long data)\r\n{\r\nstruct firmware_priv *fw_priv = (struct firmware_priv *) data;\r\nfw_load_abort(fw_priv);\r\n}\r\nstatic struct firmware_priv *\r\nfw_create_instance(struct firmware *firmware, const char *fw_name,\r\nstruct device *device, bool uevent, bool nowait)\r\n{\r\nstruct firmware_priv *fw_priv;\r\nstruct device *f_dev;\r\nint error;\r\nfw_priv = kzalloc(sizeof(*fw_priv) + strlen(fw_name) + 1 , GFP_KERNEL);\r\nif (!fw_priv) {\r\ndev_err(device, "%s: kmalloc failed\n", __func__);\r\nerror = -ENOMEM;\r\ngoto err_out;\r\n}\r\nfw_priv->fw = firmware;\r\nfw_priv->nowait = nowait;\r\nstrcpy(fw_priv->fw_id, fw_name);\r\ninit_completion(&fw_priv->completion);\r\nsetup_timer(&fw_priv->timeout,\r\nfirmware_class_timeout, (u_long) fw_priv);\r\nf_dev = &fw_priv->dev;\r\ndevice_initialize(f_dev);\r\ndev_set_name(f_dev, "%s", dev_name(device));\r\nf_dev->parent = device;\r\nf_dev->class = &firmware_class;\r\ndev_set_uevent_suppress(f_dev, true);\r\n__module_get(THIS_MODULE);\r\nerror = device_add(f_dev);\r\nif (error) {\r\ndev_err(device, "%s: device_register failed\n", __func__);\r\ngoto err_put_dev;\r\n}\r\nerror = device_create_bin_file(f_dev, &firmware_attr_data);\r\nif (error) {\r\ndev_err(device, "%s: sysfs_create_bin_file failed\n", __func__);\r\ngoto err_del_dev;\r\n}\r\nerror = device_create_file(f_dev, &dev_attr_loading);\r\nif (error) {\r\ndev_err(device, "%s: device_create_file failed\n", __func__);\r\ngoto err_del_bin_attr;\r\n}\r\nif (uevent)\r\ndev_set_uevent_suppress(f_dev, false);\r\nreturn fw_priv;\r\nerr_del_bin_attr:\r\ndevice_remove_bin_file(f_dev, &firmware_attr_data);\r\nerr_del_dev:\r\ndevice_del(f_dev);\r\nerr_put_dev:\r\nput_device(f_dev);\r\nerr_out:\r\nreturn ERR_PTR(error);\r\n}\r\nstatic void fw_destroy_instance(struct firmware_priv *fw_priv)\r\n{\r\nstruct device *f_dev = &fw_priv->dev;\r\ndevice_remove_file(f_dev, &dev_attr_loading);\r\ndevice_remove_bin_file(f_dev, &firmware_attr_data);\r\ndevice_unregister(f_dev);\r\n}\r\nstatic int _request_firmware(const struct firmware **firmware_p,\r\nconst char *name, struct device *device,\r\nbool uevent, bool nowait)\r\n{\r\nstruct firmware_priv *fw_priv;\r\nstruct firmware *firmware;\r\nint retval = 0;\r\nif (!firmware_p)\r\nreturn -EINVAL;\r\n*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);\r\nif (!firmware) {\r\ndev_err(device, "%s: kmalloc(struct firmware) failed\n",\r\n__func__);\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nif (fw_get_builtin_firmware(firmware, name)) {\r\ndev_dbg(device, "firmware: using built-in firmware %s\n", name);\r\nreturn 0;\r\n}\r\nif (WARN_ON(usermodehelper_is_disabled())) {\r\ndev_err(device, "firmware: %s will not be loaded\n", name);\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\nif (uevent)\r\ndev_dbg(device, "firmware: requesting %s\n", name);\r\nfw_priv = fw_create_instance(firmware, name, device, uevent, nowait);\r\nif (IS_ERR(fw_priv)) {\r\nretval = PTR_ERR(fw_priv);\r\ngoto out;\r\n}\r\nif (uevent) {\r\nif (loading_timeout > 0)\r\nmod_timer(&fw_priv->timeout,\r\nround_jiffies_up(jiffies +\r\nloading_timeout * HZ));\r\nkobject_uevent(&fw_priv->dev.kobj, KOBJ_ADD);\r\n}\r\nwait_for_completion(&fw_priv->completion);\r\nset_bit(FW_STATUS_DONE, &fw_priv->status);\r\ndel_timer_sync(&fw_priv->timeout);\r\nmutex_lock(&fw_lock);\r\nif (!fw_priv->fw->size || test_bit(FW_STATUS_ABORT, &fw_priv->status))\r\nretval = -ENOENT;\r\nfw_priv->fw = NULL;\r\nmutex_unlock(&fw_lock);\r\nfw_destroy_instance(fw_priv);\r\nout:\r\nif (retval) {\r\nrelease_firmware(firmware);\r\n*firmware_p = NULL;\r\n}\r\nreturn retval;\r\n}\r\nint\r\nrequest_firmware(const struct firmware **firmware_p, const char *name,\r\nstruct device *device)\r\n{\r\nreturn _request_firmware(firmware_p, name, device, true, false);\r\n}\r\nvoid release_firmware(const struct firmware *fw)\r\n{\r\nif (fw) {\r\nif (!fw_is_builtin_firmware(fw))\r\nfirmware_free_data(fw);\r\nkfree(fw);\r\n}\r\n}\r\nstatic int request_firmware_work_func(void *arg)\r\n{\r\nstruct firmware_work *fw_work = arg;\r\nconst struct firmware *fw;\r\nint ret;\r\nif (!arg) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nret = _request_firmware(&fw, fw_work->name, fw_work->device,\r\nfw_work->uevent, true);\r\nfw_work->cont(fw, fw_work->context);\r\nmodule_put(fw_work->module);\r\nkfree(fw_work);\r\nreturn ret;\r\n}\r\nint\r\nrequest_firmware_nowait(\r\nstruct module *module, bool uevent,\r\nconst char *name, struct device *device, gfp_t gfp, void *context,\r\nvoid (*cont)(const struct firmware *fw, void *context))\r\n{\r\nstruct task_struct *task;\r\nstruct firmware_work *fw_work;\r\nfw_work = kzalloc(sizeof (struct firmware_work), gfp);\r\nif (!fw_work)\r\nreturn -ENOMEM;\r\nfw_work->module = module;\r\nfw_work->name = name;\r\nfw_work->device = device;\r\nfw_work->context = context;\r\nfw_work->cont = cont;\r\nfw_work->uevent = uevent;\r\nif (!try_module_get(module)) {\r\nkfree(fw_work);\r\nreturn -EFAULT;\r\n}\r\ntask = kthread_run(request_firmware_work_func, fw_work,\r\n"firmware/%s", name);\r\nif (IS_ERR(task)) {\r\nfw_work->cont(NULL, fw_work->context);\r\nmodule_put(fw_work->module);\r\nkfree(fw_work);\r\nreturn PTR_ERR(task);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init firmware_class_init(void)\r\n{\r\nreturn class_register(&firmware_class);\r\n}\r\nstatic void __exit firmware_class_exit(void)\r\n{\r\nclass_unregister(&firmware_class);\r\n}
