static u16 c_can_plat_read_reg_aligned_to_16bit(struct c_can_priv *priv,\r\nvoid *reg)\r\n{\r\nreturn readw(reg);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_16bit(struct c_can_priv *priv,\r\nvoid *reg, u16 val)\r\n{\r\nwritew(val, reg);\r\n}\r\nstatic u16 c_can_plat_read_reg_aligned_to_32bit(struct c_can_priv *priv,\r\nvoid *reg)\r\n{\r\nreturn readw(reg + (long)reg - (long)priv->regs);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_32bit(struct c_can_priv *priv,\r\nvoid *reg, u16 val)\r\n{\r\nwritew(val, reg + (long)reg - (long)priv->regs);\r\n}\r\nstatic int __devinit c_can_plat_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nvoid __iomem *addr;\r\nstruct net_device *dev;\r\nstruct c_can_priv *priv;\r\nstruct resource *mem;\r\nint irq;\r\n#ifdef CONFIG_HAVE_CLK\r\nstruct clk *clk;\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "no clock defined\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\n#endif\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!mem || irq <= 0) {\r\nret = -ENODEV;\r\ngoto exit_free_clk;\r\n}\r\nif (!request_mem_region(mem->start, resource_size(mem),\r\nKBUILD_MODNAME)) {\r\ndev_err(&pdev->dev, "resource unavailable\n");\r\nret = -ENODEV;\r\ngoto exit_free_clk;\r\n}\r\naddr = ioremap(mem->start, resource_size(mem));\r\nif (!addr) {\r\ndev_err(&pdev->dev, "failed to map can port\n");\r\nret = -ENOMEM;\r\ngoto exit_release_mem;\r\n}\r\ndev = alloc_c_can_dev();\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto exit_iounmap;\r\n}\r\npriv = netdev_priv(dev);\r\ndev->irq = irq;\r\npriv->regs = addr;\r\n#ifdef CONFIG_HAVE_CLK\r\npriv->can.clock.freq = clk_get_rate(clk);\r\npriv->priv = clk;\r\n#endif\r\nswitch (mem->flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_32bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_32bit;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\ndefault:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\r\nbreak;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_c_can_dev(dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nKBUILD_MODNAME, ret);\r\ngoto exit_free_device;\r\n}\r\ndev_info(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",\r\nKBUILD_MODNAME, priv->regs, dev->irq);\r\nreturn 0;\r\nexit_free_device:\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_c_can_dev(dev);\r\nexit_iounmap:\r\niounmap(addr);\r\nexit_release_mem:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nexit_free_clk:\r\n#ifdef CONFIG_HAVE_CLK\r\nclk_put(clk);\r\nexit:\r\n#endif\r\ndev_err(&pdev->dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int __devexit c_can_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct resource *mem;\r\nunregister_c_can_dev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_c_can_dev(dev);\r\niounmap(priv->regs);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\n#ifdef CONFIG_HAVE_CLK\r\nclk_put(priv->priv);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init c_can_plat_init(void)\r\n{\r\nreturn platform_driver_register(&c_can_plat_driver);\r\n}\r\nstatic void __exit c_can_plat_exit(void)\r\n{\r\nplatform_driver_unregister(&c_can_plat_driver);\r\n}
