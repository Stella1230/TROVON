int\r\nxfs_dir_ialloc(\r\nxfs_trans_t **tpp,\r\nxfs_inode_t *dp,\r\nmode_t mode,\r\nxfs_nlink_t nlink,\r\nxfs_dev_t rdev,\r\nprid_t prid,\r\nint okalloc,\r\nxfs_inode_t **ipp,\r\nint *committed)\r\n{\r\nxfs_trans_t *tp;\r\nxfs_trans_t *ntp;\r\nxfs_inode_t *ip;\r\nxfs_buf_t *ialloc_context = NULL;\r\nboolean_t call_again = B_FALSE;\r\nint code;\r\nuint log_res;\r\nuint log_count;\r\nvoid *dqinfo;\r\nuint tflags;\r\ntp = *tpp;\r\nASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\r\ncode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\r\n&ialloc_context, &call_again, &ip);\r\nif (code) {\r\n*ipp = NULL;\r\nreturn code;\r\n}\r\nif (!call_again && (ip == NULL)) {\r\n*ipp = NULL;\r\nreturn XFS_ERROR(ENOSPC);\r\n}\r\nif (call_again) {\r\nxfs_trans_bhold(tp, ialloc_context);\r\nlog_res = xfs_trans_get_log_res(tp);\r\nlog_count = xfs_trans_get_log_count(tp);\r\ndqinfo = NULL;\r\ntflags = 0;\r\nif (tp->t_dqinfo) {\r\ndqinfo = (void *)tp->t_dqinfo;\r\ntp->t_dqinfo = NULL;\r\ntflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\r\ntp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\r\n}\r\nntp = xfs_trans_dup(tp);\r\ncode = xfs_trans_commit(tp, 0);\r\ntp = ntp;\r\nif (committed != NULL) {\r\n*committed = 1;\r\n}\r\nif (code) {\r\nxfs_buf_relse(ialloc_context);\r\nif (dqinfo) {\r\ntp->t_dqinfo = dqinfo;\r\nxfs_trans_free_dqinfo(tp);\r\n}\r\n*tpp = ntp;\r\n*ipp = NULL;\r\nreturn code;\r\n}\r\nxfs_log_ticket_put(tp->t_ticket);\r\ncode = xfs_trans_reserve(tp, 0, log_res, 0,\r\nXFS_TRANS_PERM_LOG_RES, log_count);\r\nif (dqinfo) {\r\ntp->t_dqinfo = dqinfo;\r\ntp->t_flags |= tflags;\r\n}\r\nif (code) {\r\nxfs_buf_relse(ialloc_context);\r\n*tpp = ntp;\r\n*ipp = NULL;\r\nreturn code;\r\n}\r\nxfs_trans_bjoin(tp, ialloc_context);\r\ncode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\r\nokalloc, &ialloc_context, &call_again, &ip);\r\nif (code) {\r\n*tpp = tp;\r\n*ipp = NULL;\r\nreturn code;\r\n}\r\nASSERT ((!call_again) && (ip != NULL));\r\n} else {\r\nif (committed != NULL) {\r\n*committed = 0;\r\n}\r\n}\r\n*ipp = ip;\r\n*tpp = tp;\r\nreturn 0;\r\n}\r\nint\r\nxfs_droplink(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *ip)\r\n{\r\nint error;\r\nxfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\r\nASSERT (ip->i_d.di_nlink > 0);\r\nip->i_d.di_nlink--;\r\ndrop_nlink(VFS_I(ip));\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nerror = 0;\r\nif (ip->i_d.di_nlink == 0) {\r\nerror = xfs_iunlink(tp, ip);\r\n}\r\nreturn error;\r\n}\r\nvoid\r\nxfs_bump_ino_vers2(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *ip)\r\n{\r\nxfs_mount_t *mp;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nASSERT(ip->i_d.di_version == 1);\r\nip->i_d.di_version = 2;\r\nip->i_d.di_onlink = 0;\r\nmemset(&(ip->i_d.di_pad[0]), 0, sizeof(ip->i_d.di_pad));\r\nmp = tp->t_mountp;\r\nif (!xfs_sb_version_hasnlink(&mp->m_sb)) {\r\nspin_lock(&mp->m_sb_lock);\r\nif (!xfs_sb_version_hasnlink(&mp->m_sb)) {\r\nxfs_sb_version_addnlink(&mp->m_sb);\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_mod_sb(tp, XFS_SB_VERSIONNUM);\r\n} else {\r\nspin_unlock(&mp->m_sb_lock);\r\n}\r\n}\r\n}\r\nint\r\nxfs_bumplink(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *ip)\r\n{\r\nif (ip->i_d.di_nlink >= XFS_MAXLINK)\r\nreturn XFS_ERROR(EMLINK);\r\nxfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\r\nASSERT(ip->i_d.di_nlink > 0);\r\nip->i_d.di_nlink++;\r\ninc_nlink(VFS_I(ip));\r\nif ((ip->i_d.di_version == 1) &&\r\n(ip->i_d.di_nlink > XFS_MAXLINK_1)) {\r\nxfs_bump_ino_vers2(tp, ip);\r\n}\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nreturn 0;\r\n}
