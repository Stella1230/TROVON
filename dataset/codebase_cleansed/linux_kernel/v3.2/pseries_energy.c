static int check_for_h_best_energy(void)\r\n{\r\nstruct device_node *rtas = NULL;\r\nconst char *hypertas, *s;\r\nint length;\r\nint rc = 0;\r\nrtas = of_find_node_by_path("/rtas");\r\nif (!rtas)\r\nreturn 0;\r\nhypertas = of_get_property(rtas, "ibm,hypertas-functions", &length);\r\nif (!hypertas) {\r\nof_node_put(rtas);\r\nreturn 0;\r\n}\r\nfor (s = hypertas; s < hypertas + length; s += strlen(s) + 1) {\r\nif (!strncmp("hcall-best-energy-1", s, 19)) {\r\nrc = 1;\r\nbreak;\r\n}\r\n}\r\nof_node_put(rtas);\r\nreturn rc;\r\n}\r\nstatic u32 cpu_to_drc_index(int cpu)\r\n{\r\nstruct device_node *dn = NULL;\r\nconst int *indexes;\r\nint i;\r\nint rc = 1;\r\nu32 ret = 0;\r\ndn = of_find_node_by_path("/cpus");\r\nif (dn == NULL)\r\ngoto err;\r\nindexes = of_get_property(dn, "ibm,drc-indexes", NULL);\r\nif (indexes == NULL)\r\ngoto err_of_node_put;\r\ni = cpu_core_index_of_thread(cpu);\r\nWARN_ON(i > indexes[0]);\r\nret = indexes[i + 1];\r\nrc = 0;\r\nerr_of_node_put:\r\nof_node_put(dn);\r\nerr:\r\nif (rc)\r\nprintk(KERN_WARNING "cpu_to_drc_index(%d) failed", cpu);\r\nreturn ret;\r\n}\r\nstatic int drc_index_to_cpu(u32 drc_index)\r\n{\r\nstruct device_node *dn = NULL;\r\nconst int *indexes;\r\nint i, cpu = 0;\r\nint rc = 1;\r\ndn = of_find_node_by_path("/cpus");\r\nif (dn == NULL)\r\ngoto err;\r\nindexes = of_get_property(dn, "ibm,drc-indexes", NULL);\r\nif (indexes == NULL)\r\ngoto err_of_node_put;\r\nfor (i = 0; i < indexes[0]; i++) {\r\nif (indexes[i + 1] == drc_index)\r\nbreak;\r\n}\r\ncpu = cpu_first_thread_of_core(i);\r\nrc = 0;\r\nerr_of_node_put:\r\nof_node_put(dn);\r\nerr:\r\nif (rc)\r\nprintk(KERN_WARNING "drc_index_to_cpu(%d) failed", drc_index);\r\nreturn cpu;\r\n}\r\nstatic ssize_t get_best_energy_list(char *page, int activate)\r\n{\r\nint rc, cnt, i, cpu;\r\nunsigned long retbuf[PLPAR_HCALL9_BUFSIZE];\r\nunsigned long flags = 0;\r\nu32 *buf_page;\r\nchar *s = page;\r\nbuf_page = (u32 *) get_zeroed_page(GFP_KERNEL);\r\nif (!buf_page)\r\nreturn -ENOMEM;\r\nflags = FLAGS_MODE1;\r\nif (activate)\r\nflags |= FLAGS_ACTIVATE;\r\nrc = plpar_hcall9(H_BEST_ENERGY, retbuf, flags, 0, __pa(buf_page),\r\n0, 0, 0, 0, 0, 0);\r\nif (rc != H_SUCCESS) {\r\nfree_page((unsigned long) buf_page);\r\nreturn -EINVAL;\r\n}\r\ncnt = retbuf[0];\r\nfor (i = 0; i < cnt; i++) {\r\ncpu = drc_index_to_cpu(buf_page[2*i+1]);\r\nif ((cpu_online(cpu) && !activate) ||\r\n(!cpu_online(cpu) && activate))\r\ns += sprintf(s, "%d,", cpu);\r\n}\r\nif (s > page) {\r\ns--;\r\ns += sprintf(s, "\n");\r\n}\r\nfree_page((unsigned long) buf_page);\r\nreturn s-page;\r\n}\r\nstatic ssize_t get_best_energy_data(struct sys_device *dev,\r\nchar *page, int activate)\r\n{\r\nint rc;\r\nunsigned long retbuf[PLPAR_HCALL9_BUFSIZE];\r\nunsigned long flags = 0;\r\nflags = FLAGS_MODE2;\r\nif (activate)\r\nflags |= FLAGS_ACTIVATE;\r\nrc = plpar_hcall9(H_BEST_ENERGY, retbuf, flags,\r\ncpu_to_drc_index(dev->id),\r\n0, 0, 0, 0, 0, 0, 0);\r\nif (rc != H_SUCCESS)\r\nreturn -EINVAL;\r\nreturn sprintf(page, "%lu\n", retbuf[1] >> 32);\r\n}\r\nstatic ssize_t cpu_activate_hint_list_show(struct sysdev_class *class,\r\nstruct sysdev_class_attribute *attr, char *page)\r\n{\r\nreturn get_best_energy_list(page, 1);\r\n}\r\nstatic ssize_t cpu_deactivate_hint_list_show(struct sysdev_class *class,\r\nstruct sysdev_class_attribute *attr, char *page)\r\n{\r\nreturn get_best_energy_list(page, 0);\r\n}\r\nstatic ssize_t percpu_activate_hint_show(struct sys_device *dev,\r\nstruct sysdev_attribute *attr, char *page)\r\n{\r\nreturn get_best_energy_data(dev, page, 1);\r\n}\r\nstatic ssize_t percpu_deactivate_hint_show(struct sys_device *dev,\r\nstruct sysdev_attribute *attr, char *page)\r\n{\r\nreturn get_best_energy_data(dev, page, 0);\r\n}\r\nstatic int __init pseries_energy_init(void)\r\n{\r\nint cpu, err;\r\nstruct sys_device *cpu_sys_dev;\r\nif (!check_for_h_best_energy()) {\r\nprintk(KERN_INFO "Hypercall H_BEST_ENERGY not supported\n");\r\nreturn 0;\r\n}\r\nerr = sysfs_create_file(&cpu_sysdev_class.kset.kobj,\r\n&attr_cpu_activate_hint_list.attr);\r\nif (!err)\r\nerr = sysfs_create_file(&cpu_sysdev_class.kset.kobj,\r\n&attr_cpu_deactivate_hint_list.attr);\r\nif (err)\r\nreturn err;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_sys_dev = get_cpu_sysdev(cpu);\r\nerr = sysfs_create_file(&cpu_sys_dev->kobj,\r\n&attr_percpu_activate_hint.attr);\r\nif (err)\r\nbreak;\r\nerr = sysfs_create_file(&cpu_sys_dev->kobj,\r\n&attr_percpu_deactivate_hint.attr);\r\nif (err)\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nsysfs_entries = 1;\r\nreturn 0;\r\n}\r\nstatic void __exit pseries_energy_cleanup(void)\r\n{\r\nint cpu;\r\nstruct sys_device *cpu_sys_dev;\r\nif (!sysfs_entries)\r\nreturn;\r\nsysfs_remove_file(&cpu_sysdev_class.kset.kobj,\r\n&attr_cpu_activate_hint_list.attr);\r\nsysfs_remove_file(&cpu_sysdev_class.kset.kobj,\r\n&attr_cpu_deactivate_hint_list.attr);\r\nfor_each_possible_cpu(cpu) {\r\ncpu_sys_dev = get_cpu_sysdev(cpu);\r\nsysfs_remove_file(&cpu_sys_dev->kobj,\r\n&attr_percpu_activate_hint.attr);\r\nsysfs_remove_file(&cpu_sys_dev->kobj,\r\n&attr_percpu_deactivate_hint.attr);\r\n}\r\n}
