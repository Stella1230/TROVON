struct ias_object *irias_new_object( char *name, int id)\r\n{\r\nstruct ias_object *obj;\r\nIRDA_DEBUG( 4, "%s()\n", __func__);\r\nobj = kzalloc(sizeof(struct ias_object), GFP_ATOMIC);\r\nif (obj == NULL) {\r\nIRDA_WARNING("%s(), Unable to allocate object!\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nobj->magic = IAS_OBJECT_MAGIC;\r\nobj->name = kstrndup(name, IAS_MAX_CLASSNAME, GFP_ATOMIC);\r\nif (!obj->name) {\r\nIRDA_WARNING("%s(), Unable to allocate name!\n",\r\n__func__);\r\nkfree(obj);\r\nreturn NULL;\r\n}\r\nobj->id = id;\r\nobj->attribs = hashbin_new(HB_LOCK);\r\nif (obj->attribs == NULL) {\r\nIRDA_WARNING("%s(), Unable to allocate attribs!\n",\r\n__func__);\r\nkfree(obj->name);\r\nkfree(obj);\r\nreturn NULL;\r\n}\r\nreturn obj;\r\n}\r\nstatic void __irias_delete_attrib(struct ias_attrib *attrib)\r\n{\r\nIRDA_ASSERT(attrib != NULL, return;);\r\nIRDA_ASSERT(attrib->magic == IAS_ATTRIB_MAGIC, return;);\r\nkfree(attrib->name);\r\nirias_delete_value(attrib->value);\r\nattrib->magic = ~IAS_ATTRIB_MAGIC;\r\nkfree(attrib);\r\n}\r\nvoid __irias_delete_object(struct ias_object *obj)\r\n{\r\nIRDA_ASSERT(obj != NULL, return;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return;);\r\nkfree(obj->name);\r\nhashbin_delete(obj->attribs, (FREE_FUNC) __irias_delete_attrib);\r\nobj->magic = ~IAS_OBJECT_MAGIC;\r\nkfree(obj);\r\n}\r\nint irias_delete_object(struct ias_object *obj)\r\n{\r\nstruct ias_object *node;\r\nIRDA_ASSERT(obj != NULL, return -1;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return -1;);\r\nnode = hashbin_remove_this(irias_objects, (irda_queue_t *) obj);\r\nif (!node)\r\nIRDA_DEBUG( 0, "%s(), object already removed!\n",\r\n__func__);\r\n__irias_delete_object(obj);\r\nreturn 0;\r\n}\r\nint irias_delete_attrib(struct ias_object *obj, struct ias_attrib *attrib,\r\nint cleanobject)\r\n{\r\nstruct ias_attrib *node;\r\nIRDA_ASSERT(obj != NULL, return -1;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return -1;);\r\nIRDA_ASSERT(attrib != NULL, return -1;);\r\nnode = hashbin_remove_this(obj->attribs, (irda_queue_t *) attrib);\r\nif (!node)\r\nreturn 0;\r\n__irias_delete_attrib(node);\r\nnode = (struct ias_attrib *) hashbin_get_first(obj->attribs);\r\nif (cleanobject && !node)\r\nirias_delete_object(obj);\r\nreturn 0;\r\n}\r\nvoid irias_insert_object(struct ias_object *obj)\r\n{\r\nIRDA_ASSERT(obj != NULL, return;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return;);\r\nhashbin_insert(irias_objects, (irda_queue_t *) obj, 0, obj->name);\r\n}\r\nstruct ias_object *irias_find_object(char *name)\r\n{\r\nIRDA_ASSERT(name != NULL, return NULL;);\r\nreturn hashbin_lock_find(irias_objects, 0, name);\r\n}\r\nstruct ias_attrib *irias_find_attrib(struct ias_object *obj, char *name)\r\n{\r\nstruct ias_attrib *attrib;\r\nIRDA_ASSERT(obj != NULL, return NULL;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return NULL;);\r\nIRDA_ASSERT(name != NULL, return NULL;);\r\nattrib = hashbin_lock_find(obj->attribs, 0, name);\r\nif (attrib == NULL)\r\nreturn NULL;\r\nreturn attrib;\r\n}\r\nstatic void irias_add_attrib(struct ias_object *obj, struct ias_attrib *attrib,\r\nint owner)\r\n{\r\nIRDA_ASSERT(obj != NULL, return;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return;);\r\nIRDA_ASSERT(attrib != NULL, return;);\r\nIRDA_ASSERT(attrib->magic == IAS_ATTRIB_MAGIC, return;);\r\nattrib->value->owner = owner;\r\nhashbin_insert(obj->attribs, (irda_queue_t *) attrib, 0, attrib->name);\r\n}\r\nint irias_object_change_attribute(char *obj_name, char *attrib_name,\r\nstruct ias_value *new_value)\r\n{\r\nstruct ias_object *obj;\r\nstruct ias_attrib *attrib;\r\nunsigned long flags;\r\nobj = hashbin_lock_find(irias_objects, 0, obj_name);\r\nif (obj == NULL) {\r\nIRDA_WARNING("%s: Unable to find object: %s\n", __func__,\r\nobj_name);\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&obj->attribs->hb_spinlock, flags);\r\nattrib = hashbin_find(obj->attribs, 0, attrib_name);\r\nif (attrib == NULL) {\r\nIRDA_WARNING("%s: Unable to find attribute: %s\n",\r\n__func__, attrib_name);\r\nspin_unlock_irqrestore(&obj->attribs->hb_spinlock, flags);\r\nreturn -1;\r\n}\r\nif ( attrib->value->type != new_value->type) {\r\nIRDA_DEBUG( 0, "%s(), changing value type not allowed!\n",\r\n__func__);\r\nspin_unlock_irqrestore(&obj->attribs->hb_spinlock, flags);\r\nreturn -1;\r\n}\r\nirias_delete_value(attrib->value);\r\nattrib->value = new_value;\r\nspin_unlock_irqrestore(&obj->attribs->hb_spinlock, flags);\r\nreturn 0;\r\n}\r\nvoid irias_add_integer_attrib(struct ias_object *obj, char *name, int value,\r\nint owner)\r\n{\r\nstruct ias_attrib *attrib;\r\nIRDA_ASSERT(obj != NULL, return;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return;);\r\nIRDA_ASSERT(name != NULL, return;);\r\nattrib = kzalloc(sizeof(struct ias_attrib), GFP_ATOMIC);\r\nif (attrib == NULL) {\r\nIRDA_WARNING("%s: Unable to allocate attribute!\n",\r\n__func__);\r\nreturn;\r\n}\r\nattrib->magic = IAS_ATTRIB_MAGIC;\r\nattrib->name = kstrndup(name, IAS_MAX_ATTRIBNAME, GFP_ATOMIC);\r\nattrib->value = irias_new_integer_value(value);\r\nif (!attrib->name || !attrib->value) {\r\nIRDA_WARNING("%s: Unable to allocate attribute!\n",\r\n__func__);\r\nif (attrib->value)\r\nirias_delete_value(attrib->value);\r\nkfree(attrib->name);\r\nkfree(attrib);\r\nreturn;\r\n}\r\nirias_add_attrib(obj, attrib, owner);\r\n}\r\nvoid irias_add_octseq_attrib(struct ias_object *obj, char *name, __u8 *octets,\r\nint len, int owner)\r\n{\r\nstruct ias_attrib *attrib;\r\nIRDA_ASSERT(obj != NULL, return;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return;);\r\nIRDA_ASSERT(name != NULL, return;);\r\nIRDA_ASSERT(octets != NULL, return;);\r\nattrib = kzalloc(sizeof(struct ias_attrib), GFP_ATOMIC);\r\nif (attrib == NULL) {\r\nIRDA_WARNING("%s: Unable to allocate attribute!\n",\r\n__func__);\r\nreturn;\r\n}\r\nattrib->magic = IAS_ATTRIB_MAGIC;\r\nattrib->name = kstrndup(name, IAS_MAX_ATTRIBNAME, GFP_ATOMIC);\r\nattrib->value = irias_new_octseq_value( octets, len);\r\nif (!attrib->name || !attrib->value) {\r\nIRDA_WARNING("%s: Unable to allocate attribute!\n",\r\n__func__);\r\nif (attrib->value)\r\nirias_delete_value(attrib->value);\r\nkfree(attrib->name);\r\nkfree(attrib);\r\nreturn;\r\n}\r\nirias_add_attrib(obj, attrib, owner);\r\n}\r\nvoid irias_add_string_attrib(struct ias_object *obj, char *name, char *value,\r\nint owner)\r\n{\r\nstruct ias_attrib *attrib;\r\nIRDA_ASSERT(obj != NULL, return;);\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return;);\r\nIRDA_ASSERT(name != NULL, return;);\r\nIRDA_ASSERT(value != NULL, return;);\r\nattrib = kzalloc(sizeof( struct ias_attrib), GFP_ATOMIC);\r\nif (attrib == NULL) {\r\nIRDA_WARNING("%s: Unable to allocate attribute!\n",\r\n__func__);\r\nreturn;\r\n}\r\nattrib->magic = IAS_ATTRIB_MAGIC;\r\nattrib->name = kstrndup(name, IAS_MAX_ATTRIBNAME, GFP_ATOMIC);\r\nattrib->value = irias_new_string_value(value);\r\nif (!attrib->name || !attrib->value) {\r\nIRDA_WARNING("%s: Unable to allocate attribute!\n",\r\n__func__);\r\nif (attrib->value)\r\nirias_delete_value(attrib->value);\r\nkfree(attrib->name);\r\nkfree(attrib);\r\nreturn;\r\n}\r\nirias_add_attrib(obj, attrib, owner);\r\n}\r\nstruct ias_value *irias_new_integer_value(int integer)\r\n{\r\nstruct ias_value *value;\r\nvalue = kzalloc(sizeof(struct ias_value), GFP_ATOMIC);\r\nif (value == NULL) {\r\nIRDA_WARNING("%s: Unable to kmalloc!\n", __func__);\r\nreturn NULL;\r\n}\r\nvalue->type = IAS_INTEGER;\r\nvalue->len = 4;\r\nvalue->t.integer = integer;\r\nreturn value;\r\n}\r\nstruct ias_value *irias_new_string_value(char *string)\r\n{\r\nstruct ias_value *value;\r\nvalue = kzalloc(sizeof(struct ias_value), GFP_ATOMIC);\r\nif (value == NULL) {\r\nIRDA_WARNING("%s: Unable to kmalloc!\n", __func__);\r\nreturn NULL;\r\n}\r\nvalue->type = IAS_STRING;\r\nvalue->charset = CS_ASCII;\r\nvalue->t.string = kstrndup(string, IAS_MAX_STRING, GFP_ATOMIC);\r\nif (!value->t.string) {\r\nIRDA_WARNING("%s: Unable to kmalloc!\n", __func__);\r\nkfree(value);\r\nreturn NULL;\r\n}\r\nvalue->len = strlen(value->t.string);\r\nreturn value;\r\n}\r\nstruct ias_value *irias_new_octseq_value(__u8 *octseq , int len)\r\n{\r\nstruct ias_value *value;\r\nvalue = kzalloc(sizeof(struct ias_value), GFP_ATOMIC);\r\nif (value == NULL) {\r\nIRDA_WARNING("%s: Unable to kmalloc!\n", __func__);\r\nreturn NULL;\r\n}\r\nvalue->type = IAS_OCT_SEQ;\r\nif(len > IAS_MAX_OCTET_STRING)\r\nlen = IAS_MAX_OCTET_STRING;\r\nvalue->len = len;\r\nvalue->t.oct_seq = kmemdup(octseq, len, GFP_ATOMIC);\r\nif (value->t.oct_seq == NULL){\r\nIRDA_WARNING("%s: Unable to kmalloc!\n", __func__);\r\nkfree(value);\r\nreturn NULL;\r\n}\r\nreturn value;\r\n}\r\nstruct ias_value *irias_new_missing_value(void)\r\n{\r\nstruct ias_value *value;\r\nvalue = kzalloc(sizeof(struct ias_value), GFP_ATOMIC);\r\nif (value == NULL) {\r\nIRDA_WARNING("%s: Unable to kmalloc!\n", __func__);\r\nreturn NULL;\r\n}\r\nvalue->type = IAS_MISSING;\r\nreturn value;\r\n}\r\nvoid irias_delete_value(struct ias_value *value)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(value != NULL, return;);\r\nswitch (value->type) {\r\ncase IAS_INTEGER:\r\ncase IAS_MISSING:\r\nbreak;\r\ncase IAS_STRING:\r\nkfree(value->t.string);\r\nbreak;\r\ncase IAS_OCT_SEQ:\r\nkfree(value->t.oct_seq);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown value type!\n", __func__);\r\nbreak;\r\n}\r\nkfree(value);\r\n}
