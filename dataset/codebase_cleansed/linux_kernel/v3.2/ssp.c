struct ssp_device *pxa_ssp_request(int port, const char *label)\r\n{\r\nstruct ssp_device *ssp = NULL;\r\nmutex_lock(&ssp_lock);\r\nlist_for_each_entry(ssp, &ssp_list, node) {\r\nif (ssp->port_id == port && ssp->use_count == 0) {\r\nssp->use_count++;\r\nssp->label = label;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ssp_lock);\r\nif (&ssp->node == &ssp_list)\r\nreturn NULL;\r\nreturn ssp;\r\n}\r\nvoid pxa_ssp_free(struct ssp_device *ssp)\r\n{\r\nmutex_lock(&ssp_lock);\r\nif (ssp->use_count) {\r\nssp->use_count--;\r\nssp->label = NULL;\r\n} else\r\ndev_err(&ssp->pdev->dev, "device already free\n");\r\nmutex_unlock(&ssp_lock);\r\n}\r\nstatic int __devinit pxa_ssp_probe(struct platform_device *pdev)\r\n{\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nstruct resource *res;\r\nstruct ssp_device *ssp;\r\nint ret = 0;\r\nssp = kzalloc(sizeof(struct ssp_device), GFP_KERNEL);\r\nif (ssp == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate memory");\r\nreturn -ENOMEM;\r\n}\r\nssp->pdev = pdev;\r\nssp->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ssp->clk)) {\r\nret = PTR_ERR(ssp->clk);\r\ngoto err_free;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no SSP RX DRCMR defined\n");\r\nret = -ENODEV;\r\ngoto err_free_clk;\r\n}\r\nssp->drcmr_rx = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no SSP TX DRCMR defined\n");\r\nret = -ENODEV;\r\ngoto err_free_clk;\r\n}\r\nssp->drcmr_tx = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no memory resource defined\n");\r\nret = -ENODEV;\r\ngoto err_free_clk;\r\n}\r\nres = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to request memory resource\n");\r\nret = -EBUSY;\r\ngoto err_free_clk;\r\n}\r\nssp->phys_base = res->start;\r\nssp->mmio_base = ioremap(res->start, resource_size(res));\r\nif (ssp->mmio_base == NULL) {\r\ndev_err(&pdev->dev, "failed to ioremap() registers\n");\r\nret = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nssp->irq = platform_get_irq(pdev, 0);\r\nif (ssp->irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ resource defined\n");\r\nret = -ENODEV;\r\ngoto err_free_io;\r\n}\r\nssp->port_id = pdev->id + 1;\r\nssp->use_count = 0;\r\nssp->type = (int)id->driver_data;\r\nmutex_lock(&ssp_lock);\r\nlist_add(&ssp->node, &ssp_list);\r\nmutex_unlock(&ssp_lock);\r\nplatform_set_drvdata(pdev, ssp);\r\nreturn 0;\r\nerr_free_io:\r\niounmap(ssp->mmio_base);\r\nerr_free_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free_clk:\r\nclk_put(ssp->clk);\r\nerr_free:\r\nkfree(ssp);\r\nreturn ret;\r\n}\r\nstatic int __devexit pxa_ssp_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct ssp_device *ssp;\r\nssp = platform_get_drvdata(pdev);\r\nif (ssp == NULL)\r\nreturn -ENODEV;\r\niounmap(ssp->mmio_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_put(ssp->clk);\r\nmutex_lock(&ssp_lock);\r\nlist_del(&ssp->node);\r\nmutex_unlock(&ssp_lock);\r\nkfree(ssp);\r\nreturn 0;\r\n}\r\nstatic int __init pxa_ssp_init(void)\r\n{\r\nreturn platform_driver_register(&pxa_ssp_driver);\r\n}\r\nstatic void __exit pxa_ssp_exit(void)\r\n{\r\nplatform_driver_unregister(&pxa_ssp_driver);\r\n}
