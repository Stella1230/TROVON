static void eem_linkcmd_complete(struct urb *urb)\r\n{\r\ndev_kfree_skb(urb->context);\r\nusb_free_urb(urb);\r\n}\r\nstatic void eem_linkcmd(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct urb *urb;\r\nint status;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\ngoto fail;\r\nusb_fill_bulk_urb(urb, dev->udev, dev->out,\r\nskb->data, skb->len, eem_linkcmd_complete, skb);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\nusb_free_urb(urb);\r\nfail:\r\ndev_kfree_skb(skb);\r\nnetdev_warn(dev->net, "link cmd failure\n");\r\nreturn;\r\n}\r\n}\r\nstatic int eem_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status = 0;\r\nstatus = usbnet_get_endpoints(dev, intf);\r\nif (status < 0) {\r\nusb_set_intfdata(intf, NULL);\r\nusb_driver_release_interface(driver_of(intf), intf);\r\nreturn status;\r\n}\r\ndev->net->hard_header_len += EEM_HEAD + ETH_FCS_LEN;\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *eem_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nstruct sk_buff *skb2 = NULL;\r\nu16 len = skb->len;\r\nu32 crc = 0;\r\nint padlen = 0;\r\nif (!((len + EEM_HEAD + ETH_FCS_LEN) % dev->maxpacket))\r\npadlen += 2;\r\nif (!skb_cloned(skb)) {\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nif ((tailroom >= ETH_FCS_LEN + padlen) &&\r\n(headroom >= EEM_HEAD))\r\ngoto done;\r\nif ((headroom + tailroom)\r\n> (EEM_HEAD + ETH_FCS_LEN + padlen)) {\r\nskb->data = memmove(skb->head +\r\nEEM_HEAD,\r\nskb->data,\r\nskb->len);\r\nskb_set_tail_pointer(skb, len);\r\ngoto done;\r\n}\r\n}\r\nskb2 = skb_copy_expand(skb, EEM_HEAD, ETH_FCS_LEN + padlen, flags);\r\nif (!skb2)\r\nreturn NULL;\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\ndone:\r\ncrc = crc32_le(~0, skb->data, skb->len);\r\ncrc = ~crc;\r\nput_unaligned_le32(crc, skb_put(skb, 4));\r\nlen = skb->len;\r\nput_unaligned_le16(BIT(14) | len, skb_push(skb, 2));\r\nif (padlen)\r\nput_unaligned_le16(0, skb_put(skb, 2));\r\nreturn skb;\r\n}\r\nstatic int eem_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\ndo {\r\nstruct sk_buff *skb2 = NULL;\r\nu16 header;\r\nu16 len = 0;\r\nif (skb->len < EEM_HEAD)\r\nreturn 0;\r\nheader = get_unaligned_le16(skb->data);\r\nskb_pull(skb, EEM_HEAD);\r\nif (header & BIT(15)) {\r\nu16 bmEEMCmd;\r\nif (header & BIT(14)) {\r\nnetdev_dbg(dev->net, "reserved command %04x\n",\r\nheader);\r\ncontinue;\r\n}\r\nbmEEMCmd = (header >> 11) & 0x7;\r\nswitch (bmEEMCmd) {\r\ncase 0:\r\nlen = header & 0x7FF;\r\nif (skb->len < len)\r\nreturn 0;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!skb2))\r\ngoto next;\r\nskb_trim(skb2, len);\r\nput_unaligned_le16(BIT(15) | (1 << 11) | len,\r\nskb_push(skb2, 2));\r\neem_linkcmd(dev, skb2);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncontinue;\r\ncase 1:\r\ncase 5:\r\ndefault:\r\nnetdev_warn(dev->net,\r\n"unexpected link command %d\n",\r\nbmEEMCmd);\r\ncontinue;\r\n}\r\n} else {\r\nu32 crc, crc2;\r\nint is_last;\r\nif (header == 0)\r\ncontinue;\r\nlen = header & 0x3FFF;\r\nif (skb->len < len)\r\nreturn 0;\r\nif (len < (ETH_HLEN + ETH_FCS_LEN))\r\ngoto next;\r\nis_last = (len == skb->len);\r\nif (is_last)\r\nskb2 = skb;\r\nelse {\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!skb2))\r\nreturn 0;\r\n}\r\nif (header & BIT(14)) {\r\ncrc = get_unaligned_le32(skb2->data\r\n+ len - ETH_FCS_LEN);\r\ncrc2 = ~crc32_le(~0, skb2->data, skb2->len\r\n- ETH_FCS_LEN);\r\n} else {\r\ncrc = get_unaligned_be32(skb2->data\r\n+ len - ETH_FCS_LEN);\r\ncrc2 = 0xdeadbeef;\r\n}\r\nskb_trim(skb2, len - ETH_FCS_LEN);\r\nif (is_last)\r\nreturn crc == crc2;\r\nif (unlikely(crc != crc2)) {\r\ndev->net->stats.rx_errors++;\r\ndev_kfree_skb_any(skb2);\r\n} else\r\nusbnet_skb_return(dev, skb2);\r\n}\r\nnext:\r\nskb_pull(skb, len);\r\n} while (skb->len);\r\nreturn 1;\r\n}\r\nstatic int __init eem_init(void)\r\n{\r\nreturn usb_register(&eem_driver);\r\n}\r\nstatic void __exit eem_exit(void)\r\n{\r\nusb_deregister(&eem_driver);\r\n}
