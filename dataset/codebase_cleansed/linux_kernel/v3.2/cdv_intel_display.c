static int cdv_sb_read(struct drm_device *dev, u32 reg, u32 *val)\r\n{\r\nint ret;\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle before read\n");\r\nreturn ret;\r\n}\r\nREG_WRITE(SB_ADDR, reg);\r\nREG_WRITE(SB_PCKT,\r\nSET_FIELD(SB_OPCODE_READ, SB_OPCODE) |\r\nSET_FIELD(SB_DEST_DPLL, SB_DEST) |\r\nSET_FIELD(0xf, SB_BYTE_ENABLE));\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle after read\n");\r\nreturn ret;\r\n}\r\n*val = REG_READ(SB_DATA);\r\nreturn 0;\r\n}\r\nstatic int cdv_sb_write(struct drm_device *dev, u32 reg, u32 val)\r\n{\r\nint ret;\r\nstatic bool dpio_debug = true;\r\nu32 temp;\r\nif (dpio_debug) {\r\nif (cdv_sb_read(dev, reg, &temp) == 0)\r\nDRM_DEBUG_KMS("0x%08x: 0x%08x (before)\n", reg, temp);\r\nDRM_DEBUG_KMS("0x%08x: 0x%08x\n", reg, val);\r\n}\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle before write\n");\r\nreturn ret;\r\n}\r\nREG_WRITE(SB_ADDR, reg);\r\nREG_WRITE(SB_DATA, val);\r\nREG_WRITE(SB_PCKT,\r\nSET_FIELD(SB_OPCODE_WRITE, SB_OPCODE) |\r\nSET_FIELD(SB_DEST_DPLL, SB_DEST) |\r\nSET_FIELD(0xf, SB_BYTE_ENABLE));\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle after write\n");\r\nreturn ret;\r\n}\r\nif (dpio_debug) {\r\nif (cdv_sb_read(dev, reg, &temp) == 0)\r\nDRM_DEBUG_KMS("0x%08x: 0x%08x (after)\n", reg, temp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cdv_sb_reset(struct drm_device *dev)\r\n{\r\nREG_WRITE(DPIO_CFG, 0);\r\nREG_READ(DPIO_CFG);\r\nREG_WRITE(DPIO_CFG, DPIO_MODE_SELECT_0 | DPIO_CMN_RESET_N);\r\n}\r\nstatic int\r\ncdv_dpll_set_clock_cdv(struct drm_device *dev, struct drm_crtc *crtc,\r\nstruct cdv_intel_clock_t *clock)\r\n{\r\nstruct psb_intel_crtc *psb_crtc =\r\nto_psb_intel_crtc(crtc);\r\nint pipe = psb_crtc->pipe;\r\nu32 m, n_vco, p;\r\nint ret = 0;\r\nint dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;\r\nu32 ref_value;\r\ncdv_sb_reset(dev);\r\nif ((REG_READ(dpll_reg) & DPLL_SYNCLOCK_ENABLE) == 0) {\r\nDRM_ERROR("Attempting to set DPLL with refclk disabled\n");\r\nreturn -EBUSY;\r\n}\r\nref_value = 0x68A701;\r\ncdv_sb_write(dev, SB_REF_SFR(pipe), ref_value);\r\nret = cdv_sb_read(dev, SB_M(pipe), &m);\r\nif (ret)\r\nreturn ret;\r\nm &= ~SB_M_DIVIDER_MASK;\r\nm |= ((clock->m2) << SB_M_DIVIDER_SHIFT);\r\nret = cdv_sb_write(dev, SB_M(pipe), m);\r\nif (ret)\r\nreturn ret;\r\nret = cdv_sb_read(dev, SB_N_VCO(pipe), &n_vco);\r\nif (ret)\r\nreturn ret;\r\nn_vco &= 0xFFFF;\r\nn_vco |= 0x107;\r\nn_vco &= ~(SB_N_VCO_SEL_MASK |\r\nSB_N_DIVIDER_MASK |\r\nSB_N_CB_TUNE_MASK);\r\nn_vco |= ((clock->n) << SB_N_DIVIDER_SHIFT);\r\nif (clock->vco < 2250000) {\r\nn_vco |= (2 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (0 << SB_N_VCO_SEL_SHIFT);\r\n} else if (clock->vco < 2750000) {\r\nn_vco |= (1 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (1 << SB_N_VCO_SEL_SHIFT);\r\n} else if (clock->vco < 3300000) {\r\nn_vco |= (0 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (2 << SB_N_VCO_SEL_SHIFT);\r\n} else {\r\nn_vco |= (0 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (3 << SB_N_VCO_SEL_SHIFT);\r\n}\r\nret = cdv_sb_write(dev, SB_N_VCO(pipe), n_vco);\r\nif (ret)\r\nreturn ret;\r\nret = cdv_sb_read(dev, SB_P(pipe), &p);\r\nif (ret)\r\nreturn ret;\r\np &= ~(SB_P2_DIVIDER_MASK | SB_P1_DIVIDER_MASK);\r\np |= SET_FIELD(clock->p1, SB_P1_DIVIDER);\r\nswitch (clock->p2) {\r\ncase 5:\r\np |= SET_FIELD(SB_P2_5, SB_P2_DIVIDER);\r\nbreak;\r\ncase 10:\r\np |= SET_FIELD(SB_P2_10, SB_P2_DIVIDER);\r\nbreak;\r\ncase 14:\r\np |= SET_FIELD(SB_P2_14, SB_P2_DIVIDER);\r\nbreak;\r\ncase 7:\r\np |= SET_FIELD(SB_P2_7, SB_P2_DIVIDER);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad P2 clock: %d\n", clock->p2);\r\nreturn -EINVAL;\r\n}\r\nret = cdv_sb_write(dev, SB_P(pipe), p);\r\nif (ret)\r\nreturn ret;\r\nif (pipe == 0) {\r\nu32 lane_reg, lane_value;\r\nlane_reg = PSB_LANE0;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE;\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\nlane_reg = PSB_LANE1;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE;\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\nlane_reg = PSB_LANE2;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE;\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\nlane_reg = PSB_LANE3;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE;\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\n}\r\nreturn 0;\r\n}\r\nbool cdv_intel_pipe_has_type(struct drm_crtc *crtc, int type)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *l_entry;\r\nlist_for_each_entry(l_entry, &mode_config->connector_list, head) {\r\nif (l_entry->encoder && l_entry->encoder->crtc == crtc) {\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(l_entry);\r\nif (psb_intel_output->type == type)\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic const struct cdv_intel_limit_t *cdv_intel_limit(struct drm_crtc *crtc,\r\nint refclk)\r\n{\r\nconst struct cdv_intel_limit_t *limit;\r\nif (cdv_intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {\r\nif (refclk == 96000)\r\nlimit = &cdv_intel_limits[CDV_LIMIT_SINGLE_LVDS_96];\r\nelse\r\nlimit = &cdv_intel_limits[CDV_LIMIT_SINGLE_LVDS_100];\r\n} else {\r\nif (refclk == 27000)\r\nlimit = &cdv_intel_limits[CDV_LIMIT_DAC_HDMI_27];\r\nelse\r\nlimit = &cdv_intel_limits[CDV_LIMIT_DAC_HDMI_96];\r\n}\r\nreturn limit;\r\n}\r\nstatic void cdv_intel_clock(struct drm_device *dev,\r\nint refclk, struct cdv_intel_clock_t *clock)\r\n{\r\nclock->m = clock->m2 + 2;\r\nclock->p = clock->p1 * clock->p2;\r\nclock->vco = (refclk * clock->m) / clock->n;\r\nclock->dot = clock->vco / clock->p;\r\n}\r\nstatic bool cdv_intel_PLL_is_valid(struct drm_crtc *crtc,\r\nconst struct cdv_intel_limit_t *limit,\r\nstruct cdv_intel_clock_t *clock)\r\n{\r\nif (clock->p1 < limit->p1.min || limit->p1.max < clock->p1)\r\nINTELPllInvalid("p1 out of range\n");\r\nif (clock->p < limit->p.min || limit->p.max < clock->p)\r\nINTELPllInvalid("p out of range\n");\r\nif (clock->vco < limit->vco.min || limit->vco.max < clock->vco)\r\nINTELPllInvalid("vco out of range\n");\r\nif (clock->dot < limit->dot.min || limit->dot.max < clock->dot)\r\nINTELPllInvalid("dot out of range\n");\r\nreturn true;\r\n}\r\nstatic bool cdv_intel_find_best_PLL(struct drm_crtc *crtc, int target,\r\nint refclk,\r\nstruct cdv_intel_clock_t *best_clock)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct cdv_intel_clock_t clock;\r\nconst struct cdv_intel_limit_t *limit = cdv_intel_limit(crtc, refclk);\r\nint err = target;\r\nif (cdv_intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&\r\n(REG_READ(LVDS) & LVDS_PORT_EN) != 0) {\r\nif ((REG_READ(LVDS) & LVDS_CLKB_POWER_MASK) ==\r\nLVDS_CLKB_POWER_UP)\r\nclock.p2 = limit->p2.p2_fast;\r\nelse\r\nclock.p2 = limit->p2.p2_slow;\r\n} else {\r\nif (target < limit->p2.dot_limit)\r\nclock.p2 = limit->p2.p2_slow;\r\nelse\r\nclock.p2 = limit->p2.p2_fast;\r\n}\r\nmemset(best_clock, 0, sizeof(*best_clock));\r\nclock.m1 = 0;\r\nfor (clock.n = limit->n.min; clock.n <= limit->n.max; clock.n++) {\r\nfor (clock.m2 = limit->m2.min; clock.m2 <= limit->m2.max;\r\nclock.m2++) {\r\nfor (clock.p1 = limit->p1.min;\r\nclock.p1 <= limit->p1.max;\r\nclock.p1++) {\r\nint this_err;\r\ncdv_intel_clock(dev, refclk, &clock);\r\nif (!cdv_intel_PLL_is_valid(crtc,\r\nlimit, &clock))\r\ncontinue;\r\nthis_err = abs(clock.dot - target);\r\nif (this_err < err) {\r\n*best_clock = clock;\r\nerr = this_err;\r\n}\r\n}\r\n}\r\n}\r\nreturn err != target;\r\n}\r\nint cdv_intel_pipe_set_base(struct drm_crtc *crtc,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_framebuffer *psbfb = to_psb_fb(crtc->fb);\r\nint pipe = psb_intel_crtc->pipe;\r\nunsigned long start, offset;\r\nint dspbase = (pipe == 0 ? DSPABASE : DSPBBASE);\r\nint dspsurf = (pipe == 0 ? DSPASURF : DSPBSURF);\r\nint dspstride = (pipe == 0) ? DSPASTRIDE : DSPBSTRIDE;\r\nint dspcntr_reg = (pipe == 0) ? DSPACNTR : DSPBCNTR;\r\nu32 dspcntr;\r\nint ret = 0;\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nif (!crtc->fb) {\r\ndev_err(dev->dev, "No FB bound\n");\r\ngoto psb_intel_pipe_cleaner;\r\n}\r\nret = psb_gtt_pin(psbfb->gtt);\r\nif (ret < 0)\r\ngoto psb_intel_pipe_set_base_exit;\r\nstart = psbfb->gtt->offset;\r\noffset = y * crtc->fb->pitch + x * (crtc->fb->bits_per_pixel / 8);\r\nREG_WRITE(dspstride, crtc->fb->pitch);\r\ndspcntr = REG_READ(dspcntr_reg);\r\ndspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\r\nswitch (crtc->fb->bits_per_pixel) {\r\ncase 8:\r\ndspcntr |= DISPPLANE_8BPP;\r\nbreak;\r\ncase 16:\r\nif (crtc->fb->depth == 15)\r\ndspcntr |= DISPPLANE_15_16BPP;\r\nelse\r\ndspcntr |= DISPPLANE_16BPP;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndspcntr |= DISPPLANE_32BPP_NO_ALPHA;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown color depth\n");\r\nret = -EINVAL;\r\ngoto psb_intel_pipe_set_base_exit;\r\n}\r\nREG_WRITE(dspcntr_reg, dspcntr);\r\ndev_dbg(dev->dev,\r\n"Writing base %08lX %08lX %d %d\n", start, offset, x, y);\r\nREG_WRITE(dspbase, offset);\r\nREG_READ(dspbase);\r\nREG_WRITE(dspsurf, start);\r\nREG_READ(dspsurf);\r\npsb_intel_pipe_cleaner:\r\nif (old_fb)\r\npsb_gtt_unpin(to_psb_fb(old_fb)->gtt);\r\npsb_intel_pipe_set_base_exit:\r\ngma_power_end(dev);\r\nreturn ret;\r\n}\r\nstatic void cdv_intel_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nint dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;\r\nint dspcntr_reg = (pipe == 0) ? DSPACNTR : DSPBCNTR;\r\nint dspbase_reg = (pipe == 0) ? DSPABASE : DSPBBASE;\r\nint pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;\r\nu32 temp;\r\nbool enabled;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ntemp = REG_READ(dpll_reg);\r\nif ((temp & DPLL_VCO_ENABLE) == 0) {\r\nREG_WRITE(dpll_reg, temp);\r\nREG_READ(dpll_reg);\r\nudelay(150);\r\nREG_WRITE(dpll_reg, temp | DPLL_VCO_ENABLE);\r\nREG_READ(dpll_reg);\r\nudelay(150);\r\nREG_WRITE(dpll_reg, temp | DPLL_VCO_ENABLE);\r\nREG_READ(dpll_reg);\r\nudelay(150);\r\n}\r\ntemp = REG_READ(dspcntr_reg);\r\nif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\r\nREG_WRITE(dspcntr_reg,\r\ntemp | DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(dspbase_reg, REG_READ(dspbase_reg));\r\n}\r\nudelay(150);\r\ntemp = REG_READ(pipeconf_reg);\r\nif ((temp & PIPEACONF_ENABLE) == 0)\r\nREG_WRITE(pipeconf_reg, temp | PIPEACONF_ENABLE);\r\npsb_intel_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\ncdv_intel_wait_for_vblank(dev);\r\ntemp = REG_READ(pipeconf_reg);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\nREG_WRITE(pipeconf_reg, temp & ~PIPEACONF_ENABLE);\r\nREG_READ(pipeconf_reg);\r\n}\r\ncdv_intel_wait_for_vblank(dev);\r\nudelay(150);\r\ntemp = REG_READ(dspcntr_reg);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE(dspcntr_reg,\r\ntemp & ~DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(dspbase_reg, REG_READ(dspbase_reg));\r\nREG_READ(dspbase_reg);\r\n}\r\ntemp = REG_READ(dpll_reg);\r\nif ((temp & DPLL_VCO_ENABLE) != 0) {\r\nREG_WRITE(dpll_reg, temp & ~DPLL_VCO_ENABLE);\r\nREG_READ(dpll_reg);\r\n}\r\nudelay(150);\r\nbreak;\r\n}\r\nenabled = crtc->enabled && mode != DRM_MODE_DPMS_OFF;\r\nREG_WRITE(DSPARB, 0x3F3E);\r\n}\r\nstatic void cdv_intel_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void cdv_intel_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nvoid cdv_intel_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_OFF);\r\n}\r\nvoid cdv_intel_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nstatic bool cdv_intel_crtc_mode_fixup(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int cdv_intel_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nu32 pfit_control;\r\npfit_control = REG_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nreturn (pfit_control >> 29) & 0x3;\r\n}\r\nstatic int cdv_intel_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nint dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;\r\nint dpll_md_reg = (psb_intel_crtc->pipe == 0) ? DPLL_A_MD : DPLL_B_MD;\r\nint dspcntr_reg = (pipe == 0) ? DSPACNTR : DSPBCNTR;\r\nint pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;\r\nint htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;\r\nint hblank_reg = (pipe == 0) ? HBLANK_A : HBLANK_B;\r\nint hsync_reg = (pipe == 0) ? HSYNC_A : HSYNC_B;\r\nint vtot_reg = (pipe == 0) ? VTOTAL_A : VTOTAL_B;\r\nint vblank_reg = (pipe == 0) ? VBLANK_A : VBLANK_B;\r\nint vsync_reg = (pipe == 0) ? VSYNC_A : VSYNC_B;\r\nint dspsize_reg = (pipe == 0) ? DSPASIZE : DSPBSIZE;\r\nint dsppos_reg = (pipe == 0) ? DSPAPOS : DSPBPOS;\r\nint pipesrc_reg = (pipe == 0) ? PIPEASRC : PIPEBSRC;\r\nint refclk;\r\nstruct cdv_intel_clock_t clock;\r\nu32 dpll = 0, dspcntr, pipeconf;\r\nbool ok, is_sdvo = false, is_dvo = false;\r\nbool is_crt = false, is_lvds = false, is_tv = false;\r\nbool is_hdmi = false;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector;\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\nif (!connector->encoder\r\n|| connector->encoder->crtc != crtc)\r\ncontinue;\r\nswitch (psb_intel_output->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\nis_lvds = true;\r\nbreak;\r\ncase INTEL_OUTPUT_SDVO:\r\nis_sdvo = true;\r\nbreak;\r\ncase INTEL_OUTPUT_DVO:\r\nis_dvo = true;\r\nbreak;\r\ncase INTEL_OUTPUT_TVOUT:\r\nis_tv = true;\r\nbreak;\r\ncase INTEL_OUTPUT_ANALOG:\r\nis_crt = true;\r\nbreak;\r\ncase INTEL_OUTPUT_HDMI:\r\nis_hdmi = true;\r\nbreak;\r\n}\r\n}\r\nrefclk = 96000;\r\nif (is_crt || is_hdmi)\r\nrefclk = 27000;\r\ndrm_mode_debug_printmodeline(adjusted_mode);\r\nok = cdv_intel_find_best_PLL(crtc, adjusted_mode->clock, refclk,\r\n&clock);\r\nif (!ok) {\r\ndev_err(dev->dev, "Couldn't find PLL settings for mode!\n");\r\nreturn 0;\r\n}\r\ndpll = DPLL_VGA_MODE_DIS;\r\nif (is_tv) {\r\ndpll |= 3;\r\n}\r\ndpll |= PLL_REF_INPUT_DREFCLK;\r\ndpll |= DPLL_SYNCLOCK_ENABLE;\r\ndpll |= DPLL_VGA_MODE_DIS;\r\nif (is_lvds)\r\ndpll |= DPLLB_MODE_LVDS;\r\nelse\r\ndpll |= DPLLB_MODE_DAC_SERIAL;\r\npipeconf = REG_READ(pipeconf_reg);\r\ndspcntr = DISPPLANE_GAMMA_ENABLE;\r\nif (pipe == 0)\r\ndspcntr |= DISPPLANE_SEL_PIPE_A;\r\nelse\r\ndspcntr |= DISPPLANE_SEL_PIPE_B;\r\ndspcntr |= DISPLAY_PLANE_ENABLE;\r\npipeconf |= PIPEACONF_ENABLE;\r\nREG_WRITE(dpll_reg, dpll | DPLL_VGA_MODE_DIS | DPLL_SYNCLOCK_ENABLE);\r\nREG_READ(dpll_reg);\r\ncdv_dpll_set_clock_cdv(dev, crtc, &clock);\r\nudelay(150);\r\nif (is_lvds) {\r\nu32 lvds = REG_READ(LVDS);\r\nlvds |=\r\nLVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP |\r\nLVDS_PIPEB_SELECT;\r\nif (clock.p2 == 7)\r\nlvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;\r\nelse\r\nlvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);\r\nREG_WRITE(LVDS, lvds);\r\nREG_READ(LVDS);\r\n}\r\ndpll |= DPLL_VCO_ENABLE;\r\nif (cdv_intel_panel_fitter_pipe(dev) == pipe)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\nDRM_DEBUG_KMS("Mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');\r\ndrm_mode_debug_printmodeline(mode);\r\nREG_WRITE(dpll_reg,\r\n(REG_READ(dpll_reg) & ~DPLL_LOCK) | DPLL_VCO_ENABLE);\r\nREG_READ(dpll_reg);\r\nudelay(150);\r\nif (!(REG_READ(dpll_reg) & DPLL_LOCK)) {\r\ndev_err(dev->dev, "Failed to get DPLL lock\n");\r\nreturn -EBUSY;\r\n}\r\n{\r\nint sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;\r\nREG_WRITE(dpll_md_reg, (0 << DPLL_MD_UDI_DIVIDER_SHIFT) | ((sdvo_pixel_multiply - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT));\r\n}\r\nREG_WRITE(htot_reg, (adjusted_mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(hblank_reg, (adjusted_mode->crtc_hblank_start - 1) |\r\n((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(hsync_reg, (adjusted_mode->crtc_hsync_start - 1) |\r\n((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(vtot_reg, (adjusted_mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(vblank_reg, (adjusted_mode->crtc_vblank_start - 1) |\r\n((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(vsync_reg, (adjusted_mode->crtc_vsync_start - 1) |\r\n((adjusted_mode->crtc_vsync_end - 1) << 16));\r\nREG_WRITE(dspsize_reg,\r\n((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(dsppos_reg, 0);\r\nREG_WRITE(pipesrc_reg,\r\n((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));\r\nREG_WRITE(pipeconf_reg, pipeconf);\r\nREG_READ(pipeconf_reg);\r\ncdv_intel_wait_for_vblank(dev);\r\nREG_WRITE(dspcntr_reg, dspcntr);\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs =\r\ncrtc->helper_private;\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\n}\r\ncdv_intel_wait_for_vblank(dev);\r\nreturn 0;\r\n}\r\nvoid cdv_intel_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv =\r\n(struct drm_psb_private *)dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint palreg = PALETTE_A;\r\nint i;\r\nif (!crtc->enabled)\r\nreturn;\r\nswitch (psb_intel_crtc->pipe) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\npalreg = PALETTE_B;\r\nbreak;\r\ncase 2:\r\npalreg = PALETTE_C;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Illegal Pipe Number.\n");\r\nreturn;\r\n}\r\nif (gma_power_begin(dev, false)) {\r\nfor (i = 0; i < 256; i++) {\r\nREG_WRITE(palreg + 4 * i,\r\n((psb_intel_crtc->lut_r[i] +\r\npsb_intel_crtc->lut_adj[i]) << 16) |\r\n((psb_intel_crtc->lut_g[i] +\r\npsb_intel_crtc->lut_adj[i]) << 8) |\r\n(psb_intel_crtc->lut_b[i] +\r\npsb_intel_crtc->lut_adj[i]));\r\n}\r\ngma_power_end(dev);\r\n} else {\r\nfor (i = 0; i < 256; i++) {\r\ndev_priv->save_palette_a[i] =\r\n((psb_intel_crtc->lut_r[i] +\r\npsb_intel_crtc->lut_adj[i]) << 16) |\r\n((psb_intel_crtc->lut_g[i] +\r\npsb_intel_crtc->lut_adj[i]) << 8) |\r\n(psb_intel_crtc->lut_b[i] +\r\npsb_intel_crtc->lut_adj[i]);\r\n}\r\n}\r\n}\r\nstatic void cdv_intel_crtc_save(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_intel_crtc_state *crtc_state = psb_intel_crtc->crtc_state;\r\nint pipeA = (psb_intel_crtc->pipe == 0);\r\nuint32_t paletteReg;\r\nint i;\r\nif (!crtc_state) {\r\ndev_dbg(dev->dev, "No CRTC state found\n");\r\nreturn;\r\n}\r\ncrtc_state->saveDSPCNTR = REG_READ(pipeA ? DSPACNTR : DSPBCNTR);\r\ncrtc_state->savePIPECONF = REG_READ(pipeA ? PIPEACONF : PIPEBCONF);\r\ncrtc_state->savePIPESRC = REG_READ(pipeA ? PIPEASRC : PIPEBSRC);\r\ncrtc_state->saveFP0 = REG_READ(pipeA ? FPA0 : FPB0);\r\ncrtc_state->saveFP1 = REG_READ(pipeA ? FPA1 : FPB1);\r\ncrtc_state->saveDPLL = REG_READ(pipeA ? DPLL_A : DPLL_B);\r\ncrtc_state->saveHTOTAL = REG_READ(pipeA ? HTOTAL_A : HTOTAL_B);\r\ncrtc_state->saveHBLANK = REG_READ(pipeA ? HBLANK_A : HBLANK_B);\r\ncrtc_state->saveHSYNC = REG_READ(pipeA ? HSYNC_A : HSYNC_B);\r\ncrtc_state->saveVTOTAL = REG_READ(pipeA ? VTOTAL_A : VTOTAL_B);\r\ncrtc_state->saveVBLANK = REG_READ(pipeA ? VBLANK_A : VBLANK_B);\r\ncrtc_state->saveVSYNC = REG_READ(pipeA ? VSYNC_A : VSYNC_B);\r\ncrtc_state->saveDSPSTRIDE = REG_READ(pipeA ? DSPASTRIDE : DSPBSTRIDE);\r\ncrtc_state->saveDSPSIZE = REG_READ(pipeA ? DSPASIZE : DSPBSIZE);\r\ncrtc_state->saveDSPPOS = REG_READ(pipeA ? DSPAPOS : DSPBPOS);\r\ncrtc_state->saveDSPBASE = REG_READ(pipeA ? DSPABASE : DSPBBASE);\r\nDRM_DEBUG("(%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x)\n",\r\ncrtc_state->saveDSPCNTR,\r\ncrtc_state->savePIPECONF,\r\ncrtc_state->savePIPESRC,\r\ncrtc_state->saveFP0,\r\ncrtc_state->saveFP1,\r\ncrtc_state->saveDPLL,\r\ncrtc_state->saveHTOTAL,\r\ncrtc_state->saveHBLANK,\r\ncrtc_state->saveHSYNC,\r\ncrtc_state->saveVTOTAL,\r\ncrtc_state->saveVBLANK,\r\ncrtc_state->saveVSYNC,\r\ncrtc_state->saveDSPSTRIDE,\r\ncrtc_state->saveDSPSIZE,\r\ncrtc_state->saveDSPPOS,\r\ncrtc_state->saveDSPBASE\r\n);\r\npaletteReg = pipeA ? PALETTE_A : PALETTE_B;\r\nfor (i = 0; i < 256; ++i)\r\ncrtc_state->savePalette[i] = REG_READ(paletteReg + (i << 2));\r\n}\r\nstatic void cdv_intel_crtc_restore(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_intel_crtc_state *crtc_state = psb_intel_crtc->crtc_state;\r\nint pipeA = (psb_intel_crtc->pipe == 0);\r\nuint32_t paletteReg;\r\nint i;\r\nif (!crtc_state) {\r\ndev_dbg(dev->dev, "No crtc state\n");\r\nreturn;\r\n}\r\nDRM_DEBUG(\r\n"current:(%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x)\n",\r\nREG_READ(pipeA ? DSPACNTR : DSPBCNTR),\r\nREG_READ(pipeA ? PIPEACONF : PIPEBCONF),\r\nREG_READ(pipeA ? PIPEASRC : PIPEBSRC),\r\nREG_READ(pipeA ? FPA0 : FPB0),\r\nREG_READ(pipeA ? FPA1 : FPB1),\r\nREG_READ(pipeA ? DPLL_A : DPLL_B),\r\nREG_READ(pipeA ? HTOTAL_A : HTOTAL_B),\r\nREG_READ(pipeA ? HBLANK_A : HBLANK_B),\r\nREG_READ(pipeA ? HSYNC_A : HSYNC_B),\r\nREG_READ(pipeA ? VTOTAL_A : VTOTAL_B),\r\nREG_READ(pipeA ? VBLANK_A : VBLANK_B),\r\nREG_READ(pipeA ? VSYNC_A : VSYNC_B),\r\nREG_READ(pipeA ? DSPASTRIDE : DSPBSTRIDE),\r\nREG_READ(pipeA ? DSPASIZE : DSPBSIZE),\r\nREG_READ(pipeA ? DSPAPOS : DSPBPOS),\r\nREG_READ(pipeA ? DSPABASE : DSPBBASE)\r\n);\r\nDRM_DEBUG(\r\n"saved: (%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x)\n",\r\ncrtc_state->saveDSPCNTR,\r\ncrtc_state->savePIPECONF,\r\ncrtc_state->savePIPESRC,\r\ncrtc_state->saveFP0,\r\ncrtc_state->saveFP1,\r\ncrtc_state->saveDPLL,\r\ncrtc_state->saveHTOTAL,\r\ncrtc_state->saveHBLANK,\r\ncrtc_state->saveHSYNC,\r\ncrtc_state->saveVTOTAL,\r\ncrtc_state->saveVBLANK,\r\ncrtc_state->saveVSYNC,\r\ncrtc_state->saveDSPSTRIDE,\r\ncrtc_state->saveDSPSIZE,\r\ncrtc_state->saveDSPPOS,\r\ncrtc_state->saveDSPBASE\r\n);\r\nif (crtc_state->saveDPLL & DPLL_VCO_ENABLE) {\r\nREG_WRITE(pipeA ? DPLL_A : DPLL_B,\r\ncrtc_state->saveDPLL & ~DPLL_VCO_ENABLE);\r\nREG_READ(pipeA ? DPLL_A : DPLL_B);\r\nDRM_DEBUG("write dpll: %x\n",\r\nREG_READ(pipeA ? DPLL_A : DPLL_B));\r\nudelay(150);\r\n}\r\nREG_WRITE(pipeA ? FPA0 : FPB0, crtc_state->saveFP0);\r\nREG_READ(pipeA ? FPA0 : FPB0);\r\nREG_WRITE(pipeA ? FPA1 : FPB1, crtc_state->saveFP1);\r\nREG_READ(pipeA ? FPA1 : FPB1);\r\nREG_WRITE(pipeA ? DPLL_A : DPLL_B, crtc_state->saveDPLL);\r\nREG_READ(pipeA ? DPLL_A : DPLL_B);\r\nudelay(150);\r\nREG_WRITE(pipeA ? HTOTAL_A : HTOTAL_B, crtc_state->saveHTOTAL);\r\nREG_WRITE(pipeA ? HBLANK_A : HBLANK_B, crtc_state->saveHBLANK);\r\nREG_WRITE(pipeA ? HSYNC_A : HSYNC_B, crtc_state->saveHSYNC);\r\nREG_WRITE(pipeA ? VTOTAL_A : VTOTAL_B, crtc_state->saveVTOTAL);\r\nREG_WRITE(pipeA ? VBLANK_A : VBLANK_B, crtc_state->saveVBLANK);\r\nREG_WRITE(pipeA ? VSYNC_A : VSYNC_B, crtc_state->saveVSYNC);\r\nREG_WRITE(pipeA ? DSPASTRIDE : DSPBSTRIDE, crtc_state->saveDSPSTRIDE);\r\nREG_WRITE(pipeA ? DSPASIZE : DSPBSIZE, crtc_state->saveDSPSIZE);\r\nREG_WRITE(pipeA ? DSPAPOS : DSPBPOS, crtc_state->saveDSPPOS);\r\nREG_WRITE(pipeA ? PIPEASRC : PIPEBSRC, crtc_state->savePIPESRC);\r\nREG_WRITE(pipeA ? DSPABASE : DSPBBASE, crtc_state->saveDSPBASE);\r\nREG_WRITE(pipeA ? PIPEACONF : PIPEBCONF, crtc_state->savePIPECONF);\r\ncdv_intel_wait_for_vblank(dev);\r\nREG_WRITE(pipeA ? DSPACNTR : DSPBCNTR, crtc_state->saveDSPCNTR);\r\nREG_WRITE(pipeA ? DSPABASE : DSPBBASE, crtc_state->saveDSPBASE);\r\ncdv_intel_wait_for_vblank(dev);\r\npaletteReg = pipeA ? PALETTE_A : PALETTE_B;\r\nfor (i = 0; i < 256; ++i)\r\nREG_WRITE(paletteReg + (i << 2), crtc_state->savePalette[i]);\r\n}\r\nstatic int cdv_intel_crtc_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file_priv,\r\nuint32_t handle,\r\nuint32_t width, uint32_t height)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nuint32_t control = (pipe == 0) ? CURACNTR : CURBCNTR;\r\nuint32_t base = (pipe == 0) ? CURABASE : CURBBASE;\r\nuint32_t temp;\r\nsize_t addr = 0;\r\nstruct gtt_range *gt;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nif (!handle) {\r\ntemp = CURSOR_MODE_DISABLE;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE(control, temp);\r\nREG_WRITE(base, 0);\r\ngma_power_end(dev);\r\n}\r\nif (psb_intel_crtc->cursor_obj) {\r\ngt = container_of(psb_intel_crtc->cursor_obj,\r\nstruct gtt_range, gem);\r\npsb_gtt_unpin(gt);\r\ndrm_gem_object_unreference(psb_intel_crtc->cursor_obj);\r\npsb_intel_crtc->cursor_obj = NULL;\r\n}\r\nreturn 0;\r\n}\r\nif (width != 64 || height != 64) {\r\ndev_dbg(dev->dev, "we currently only support 64x64 cursors\n");\r\nreturn -EINVAL;\r\n}\r\nobj = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nif (obj->size < width * height * 4) {\r\ndev_dbg(dev->dev, "buffer is to small\n");\r\nreturn -ENOMEM;\r\n}\r\ngt = container_of(obj, struct gtt_range, gem);\r\nret = psb_gtt_pin(gt);\r\nif (ret) {\r\ndev_err(dev->dev, "Can not pin down handle 0x%x\n", handle);\r\nreturn ret;\r\n}\r\naddr = gt->offset;\r\npsb_intel_crtc->cursor_addr = addr;\r\ntemp = 0;\r\ntemp |= (pipe << 28);\r\ntemp |= CURSOR_MODE_64_ARGB_AX | MCURSOR_GAMMA_ENABLE;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE(control, temp);\r\nREG_WRITE(base, addr);\r\ngma_power_end(dev);\r\n}\r\nif (psb_intel_crtc->cursor_obj) {\r\ngt = container_of(psb_intel_crtc->cursor_obj,\r\nstruct gtt_range, gem);\r\npsb_gtt_unpin(gt);\r\ndrm_gem_object_unreference(psb_intel_crtc->cursor_obj);\r\npsb_intel_crtc->cursor_obj = obj;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdv_intel_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nuint32_t temp = 0;\r\nuint32_t adder;\r\nif (x < 0) {\r\ntemp |= (CURSOR_POS_SIGN << CURSOR_X_SHIFT);\r\nx = -x;\r\n}\r\nif (y < 0) {\r\ntemp |= (CURSOR_POS_SIGN << CURSOR_Y_SHIFT);\r\ny = -y;\r\n}\r\ntemp |= ((x & CURSOR_POS_MASK) << CURSOR_X_SHIFT);\r\ntemp |= ((y & CURSOR_POS_MASK) << CURSOR_Y_SHIFT);\r\nadder = psb_intel_crtc->cursor_addr;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE((pipe == 0) ? CURAPOS : CURBPOS, temp);\r\nREG_WRITE((pipe == 0) ? CURABASE : CURBBASE, adder);\r\ngma_power_end(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cdv_intel_crtc_gamma_set(struct drm_crtc *crtc, u16 *red,\r\nu16 *green, u16 *blue, uint32_t start, uint32_t size)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint i;\r\nint end = (start + size > 256) ? 256 : start + size;\r\nfor (i = start; i < end; i++) {\r\npsb_intel_crtc->lut_r[i] = red[i] >> 8;\r\npsb_intel_crtc->lut_g[i] = green[i] >> 8;\r\npsb_intel_crtc->lut_b[i] = blue[i] >> 8;\r\n}\r\ncdv_intel_crtc_load_lut(crtc);\r\n}\r\nstatic int cdv_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nint ret = 0;\r\nstruct drm_device *dev = set->crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (!dev_priv->rpm_enabled)\r\nreturn drm_crtc_helper_set_config(set);\r\npm_runtime_forbid(&dev->pdev->dev);\r\nret = drm_crtc_helper_set_config(set);\r\npm_runtime_allow(&dev->pdev->dev);\r\nreturn ret;\r\n}\r\nstatic void i8xx_clock(int refclk, struct cdv_intel_clock_t *clock)\r\n{\r\nclock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);\r\nclock->p = clock->p1 * clock->p2;\r\nclock->vco = refclk * clock->m / (clock->n + 2);\r\nclock->dot = clock->vco / clock->p;\r\n}\r\nstatic int cdv_intel_crtc_clock_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nu32 dpll;\r\nu32 fp;\r\nstruct cdv_intel_clock_t clock;\r\nbool is_lvds;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (gma_power_begin(dev, false)) {\r\ndpll = REG_READ((pipe == 0) ? DPLL_A : DPLL_B);\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = REG_READ((pipe == 0) ? FPA0 : FPB0);\r\nelse\r\nfp = REG_READ((pipe == 0) ? FPA1 : FPB1);\r\nis_lvds = (pipe == 1) && (REG_READ(LVDS) & LVDS_PORT_EN);\r\ngma_power_end(dev);\r\n} else {\r\ndpll = (pipe == 0) ?\r\ndev_priv->saveDPLL_A : dev_priv->saveDPLL_B;\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = (pipe == 0) ?\r\ndev_priv->saveFPA0 :\r\ndev_priv->saveFPB0;\r\nelse\r\nfp = (pipe == 0) ?\r\ndev_priv->saveFPA1 :\r\ndev_priv->saveFPB1;\r\nis_lvds = (pipe == 1) && (dev_priv->saveLVDS & LVDS_PORT_EN);\r\n}\r\nclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\r\nclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\r\nclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\r\nif (is_lvds) {\r\nclock.p1 =\r\nffs((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT);\r\nif (clock.p1 == 0) {\r\nclock.p1 = 4;\r\ndev_err(dev->dev, "PLL %d\n", dpll);\r\n}\r\nclock.p2 = 14;\r\nif ((dpll & PLL_REF_INPUT_MASK) ==\r\nPLLB_REF_INPUT_SPREADSPECTRUMIN) {\r\ni8xx_clock(66000, &clock);\r\n} else\r\ni8xx_clock(48000, &clock);\r\n} else {\r\nif (dpll & PLL_P1_DIVIDE_BY_TWO)\r\nclock.p1 = 2;\r\nelse {\r\nclock.p1 =\r\n((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\r\n}\r\nif (dpll & PLL_P2_DIVIDE_BY_4)\r\nclock.p2 = 4;\r\nelse\r\nclock.p2 = 2;\r\ni8xx_clock(48000, &clock);\r\n}\r\nreturn clock.dot;\r\n}\r\nstruct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nstruct drm_display_mode *mode;\r\nint htot;\r\nint hsync;\r\nint vtot;\r\nint vsync;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (gma_power_begin(dev, false)) {\r\nhtot = REG_READ((pipe == 0) ? HTOTAL_A : HTOTAL_B);\r\nhsync = REG_READ((pipe == 0) ? HSYNC_A : HSYNC_B);\r\nvtot = REG_READ((pipe == 0) ? VTOTAL_A : VTOTAL_B);\r\nvsync = REG_READ((pipe == 0) ? VSYNC_A : VSYNC_B);\r\ngma_power_end(dev);\r\n} else {\r\nhtot = (pipe == 0) ?\r\ndev_priv->saveHTOTAL_A : dev_priv->saveHTOTAL_B;\r\nhsync = (pipe == 0) ?\r\ndev_priv->saveHSYNC_A : dev_priv->saveHSYNC_B;\r\nvtot = (pipe == 0) ?\r\ndev_priv->saveVTOTAL_A : dev_priv->saveVTOTAL_B;\r\nvsync = (pipe == 0) ?\r\ndev_priv->saveVSYNC_A : dev_priv->saveVSYNC_B;\r\n}\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode)\r\nreturn NULL;\r\nmode->clock = cdv_intel_crtc_clock_get(dev, crtc);\r\nmode->hdisplay = (htot & 0xffff) + 1;\r\nmode->htotal = ((htot & 0xffff0000) >> 16) + 1;\r\nmode->hsync_start = (hsync & 0xffff) + 1;\r\nmode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;\r\nmode->vdisplay = (vtot & 0xffff) + 1;\r\nmode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;\r\nmode->vsync_start = (vsync & 0xffff) + 1;\r\nmode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_set_crtcinfo(mode, 0);\r\nreturn mode;\r\n}\r\nstatic void cdv_intel_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nkfree(psb_intel_crtc->crtc_state);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(psb_intel_crtc);\r\n}\r\nvoid cdv_intel_cursor_init(struct drm_device *dev, int pipe)\r\n{\r\nuint32_t control;\r\nuint32_t base;\r\nswitch (pipe) {\r\ncase 0:\r\ncontrol = CURACNTR;\r\nbase = CURABASE;\r\nbreak;\r\ncase 1:\r\ncontrol = CURBCNTR;\r\nbase = CURBBASE;\r\nbreak;\r\ncase 2:\r\ncontrol = CURCCNTR;\r\nbase = CURCBASE;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nREG_WRITE(control, 0);\r\nREG_WRITE(base, 0);\r\n}
