static inline long get_reg(struct task_struct *task, int regno)\r\n{\r\nunsigned long *addr;\r\nif (regno == PT_USP)\r\naddr = &task->thread.usp;\r\nelse if (regno < ARRAY_SIZE(regoff))\r\naddr = (unsigned long *)(task->thread.esp0 + regoff[regno]);\r\nelse\r\nreturn 0;\r\nreturn *addr;\r\n}\r\nstatic inline int put_reg(struct task_struct *task, int regno,\r\nunsigned long data)\r\n{\r\nunsigned long *addr;\r\nif (regno == PT_USP)\r\naddr = &task->thread.usp;\r\nelse if (regno < ARRAY_SIZE(regoff))\r\naddr = (unsigned long *) (task->thread.esp0 + regoff[regno]);\r\nelse\r\nreturn -1;\r\n*addr = data;\r\nreturn 0;\r\n}\r\nvoid user_enable_single_step(struct task_struct *task)\r\n{\r\nunsigned long srflags;\r\nsrflags = get_reg(task, PT_SR) | (TRACE_BITS << 16);\r\nput_reg(task, PT_SR, srflags);\r\n}\r\nvoid user_disable_single_step(struct task_struct *task)\r\n{\r\nunsigned long srflags;\r\nsrflags = get_reg(task, PT_SR) & ~(TRACE_BITS << 16);\r\nput_reg(task, PT_SR, srflags);\r\n}\r\nvoid ptrace_disable(struct task_struct *child)\r\n{\r\nuser_disable_single_step(child);\r\n}\r\nlong arch_ptrace(struct task_struct *child, long request,\r\nunsigned long addr, unsigned long data)\r\n{\r\nint ret;\r\nint regno = addr >> 2;\r\nunsigned long __user *datap = (unsigned long __user *) data;\r\nswitch (request) {\r\ncase PTRACE_PEEKUSR: {\r\nunsigned long tmp;\r\nret = -EIO;\r\nif ((addr & 3) || addr > sizeof(struct user) - 3)\r\nbreak;\r\ntmp = 0;\r\nret = -EIO;\r\nif (regno < 19) {\r\ntmp = get_reg(child, regno);\r\nif (regno == PT_SR)\r\ntmp >>= 16;\r\n} else if (regno >= 21 && regno < 49) {\r\ntmp = child->thread.fp[regno - 21];\r\n} else if (regno == 49) {\r\ntmp = child->mm->start_code;\r\n} else if (regno == 50) {\r\ntmp = child->mm->start_data;\r\n} else if (regno == 51) {\r\ntmp = child->mm->end_code;\r\n} else\r\nbreak;\r\nret = put_user(tmp, datap);\r\nbreak;\r\n}\r\ncase PTRACE_POKEUSR:\r\nret = -EIO;\r\nif ((addr & 3) || addr > sizeof(struct user) - 3)\r\nbreak;\r\nif (regno == PT_SR) {\r\ndata &= SR_MASK;\r\ndata <<= 16;\r\ndata |= get_reg(child, PT_SR) & ~(SR_MASK << 16);\r\n}\r\nif (regno < 19) {\r\nif (put_reg(child, regno, data))\r\nbreak;\r\nret = 0;\r\nbreak;\r\n}\r\nif (regno >= 21 && regno < 48)\r\n{\r\nchild->thread.fp[regno - 21] = data;\r\nret = 0;\r\n}\r\nbreak;\r\ncase PTRACE_GETREGS: {\r\nint i;\r\nunsigned long tmp;\r\nfor (i = 0; i < 19; i++) {\r\ntmp = get_reg(child, i);\r\nif (i == PT_SR)\r\ntmp >>= 16;\r\nif (put_user(tmp, datap)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ndatap++;\r\n}\r\nret = 0;\r\nbreak;\r\n}\r\ncase PTRACE_SETREGS: {\r\nint i;\r\nunsigned long tmp;\r\nfor (i = 0; i < 19; i++) {\r\nif (get_user(tmp, datap)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (i == PT_SR) {\r\ntmp &= SR_MASK;\r\ntmp <<= 16;\r\ntmp |= get_reg(child, PT_SR) & ~(SR_MASK << 16);\r\n}\r\nput_reg(child, i, tmp);\r\ndatap++;\r\n}\r\nret = 0;\r\nbreak;\r\n}\r\n#ifdef PTRACE_GETFPREGS\r\ncase PTRACE_GETFPREGS: {\r\nret = 0;\r\nif (copy_to_user(datap, &child->thread.fp,\r\nsizeof(struct user_m68kfp_struct)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n#endif\r\n#ifdef PTRACE_SETFPREGS\r\ncase PTRACE_SETFPREGS: {\r\nret = 0;\r\nif (copy_from_user(&child->thread.fp, datap,\r\nsizeof(struct user_m68kfp_struct)))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n#endif\r\ncase PTRACE_GET_THREAD_AREA:\r\nret = put_user(task_thread_info(child)->tp_value, datap);\r\nbreak;\r\ndefault:\r\nret = ptrace_request(child, request, addr, data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage int syscall_trace_enter(void)\r\n{\r\nint ret = 0;\r\nif (test_thread_flag(TIF_SYSCALL_TRACE))\r\nret = tracehook_report_syscall_entry(task_pt_regs(current));\r\nreturn ret;\r\n}\r\nasmlinkage void syscall_trace_leave(void)\r\n{\r\nif (test_thread_flag(TIF_SYSCALL_TRACE))\r\ntracehook_report_syscall_exit(task_pt_regs(current), 0);\r\n}
