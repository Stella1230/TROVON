static inline u64 time_to_nsec(u32 value)\r\n{\r\nreturn ((u64)value) * 128000ull;\r\n}\r\nstatic inline u64 time_to_avg_nsec(u32 value, u32 count)\r\n{\r\nu64 ret;\r\nif (count == 0)\r\nreturn 0;\r\nret = time_to_nsec(value);\r\ndo_div(ret, count);\r\nreturn ret;\r\n}\r\nstatic inline void cmf_activate(void *area, unsigned int onoff)\r\n{\r\nregister void * __gpr2 asm("2");\r\nregister long __gpr1 asm("1");\r\n__gpr2 = area;\r\n__gpr1 = onoff ? 2 : 0;\r\nasm("schm" : : "d" (__gpr2), "d" (__gpr1) );\r\n}\r\nstatic int set_schib(struct ccw_device *cdev, u32 mme, int mbfc,\r\nunsigned long address)\r\n{\r\nstruct subchannel *sch;\r\nsch = to_subchannel(cdev->dev.parent);\r\nsch->config.mme = mme;\r\nsch->config.mbfc = mbfc;\r\nif (mbfc)\r\nsch->config.mba = address;\r\nelse\r\nsch->config.mbi = address;\r\nreturn cio_commit_config(sch);\r\n}\r\nstatic void cmf_set_schib_release(struct kref *kref)\r\n{\r\nstruct set_schib_struct *set_data;\r\nset_data = container_of(kref, struct set_schib_struct, kref);\r\nkfree(set_data);\r\n}\r\nstatic int set_schib_wait(struct ccw_device *cdev, u32 mme,\r\nint mbfc, unsigned long address)\r\n{\r\nstruct set_schib_struct *set_data;\r\nint ret;\r\nspin_lock_irq(cdev->ccwlock);\r\nif (!cdev->private->cmb) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nset_data = kzalloc(sizeof(struct set_schib_struct), GFP_ATOMIC);\r\nif (!set_data) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ninit_waitqueue_head(&set_data->wait);\r\nkref_init(&set_data->kref);\r\nset_data->mme = mme;\r\nset_data->mbfc = mbfc;\r\nset_data->address = address;\r\nret = set_schib(cdev, mme, mbfc, address);\r\nif (ret != -EBUSY)\r\ngoto out_put;\r\nif (cdev->private->state != DEV_STATE_ONLINE) {\r\nret = -EBUSY;\r\ngoto out_put;\r\n}\r\ncdev->private->state = DEV_STATE_CMFCHANGE;\r\nset_data->ret = CMF_PENDING;\r\ncdev->private->cmb_wait = set_data;\r\nspin_unlock_irq(cdev->ccwlock);\r\nif (wait_event_interruptible(set_data->wait,\r\nset_data->ret != CMF_PENDING)) {\r\nspin_lock_irq(cdev->ccwlock);\r\nif (set_data->ret == CMF_PENDING) {\r\nset_data->ret = -ERESTARTSYS;\r\nif (cdev->private->state == DEV_STATE_CMFCHANGE)\r\ncdev->private->state = DEV_STATE_ONLINE;\r\n}\r\nspin_unlock_irq(cdev->ccwlock);\r\n}\r\nspin_lock_irq(cdev->ccwlock);\r\ncdev->private->cmb_wait = NULL;\r\nret = set_data->ret;\r\nout_put:\r\nkref_put(&set_data->kref, cmf_set_schib_release);\r\nout:\r\nspin_unlock_irq(cdev->ccwlock);\r\nreturn ret;\r\n}\r\nvoid retry_set_schib(struct ccw_device *cdev)\r\n{\r\nstruct set_schib_struct *set_data;\r\nset_data = cdev->private->cmb_wait;\r\nif (!set_data) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nkref_get(&set_data->kref);\r\nset_data->ret = set_schib(cdev, set_data->mme, set_data->mbfc,\r\nset_data->address);\r\nwake_up(&set_data->wait);\r\nkref_put(&set_data->kref, cmf_set_schib_release);\r\n}\r\nstatic int cmf_copy_block(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nvoid *reference_buf;\r\nvoid *hw_block;\r\nstruct cmb_data *cmb_data;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_update_schib(sch))\r\nreturn -ENODEV;\r\nif (scsw_fctl(&sch->schib.scsw) & SCSW_FCTL_START_FUNC) {\r\nif ((!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_SUSPENDED)) &&\r\n(scsw_actl(&sch->schib.scsw) &\r\n(SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT)) &&\r\n(!(scsw_stctl(&sch->schib.scsw) & SCSW_STCTL_SEC_STATUS)))\r\nreturn -EBUSY;\r\n}\r\ncmb_data = cdev->private->cmb;\r\nhw_block = cmbops->align(cmb_data->hw_block);\r\nif (!memcmp(cmb_data->last_block, hw_block, cmb_data->size))\r\nreturn 0;\r\nreference_buf = kzalloc(cmb_data->size, GFP_ATOMIC);\r\nif (!reference_buf)\r\nreturn -ENOMEM;\r\ndo {\r\nmemcpy(cmb_data->last_block, hw_block, cmb_data->size);\r\nmemcpy(reference_buf, hw_block, cmb_data->size);\r\n} while (memcmp(cmb_data->last_block, reference_buf, cmb_data->size));\r\ncmb_data->last_update = get_clock();\r\nkfree(reference_buf);\r\nreturn 0;\r\n}\r\nstatic void cmf_copy_block_release(struct kref *kref)\r\n{\r\nstruct copy_block_struct *copy_block;\r\ncopy_block = container_of(kref, struct copy_block_struct, kref);\r\nkfree(copy_block);\r\n}\r\nstatic int cmf_cmb_copy_wait(struct ccw_device *cdev)\r\n{\r\nstruct copy_block_struct *copy_block;\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\nif (!cdev->private->cmb) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ncopy_block = kzalloc(sizeof(struct copy_block_struct), GFP_ATOMIC);\r\nif (!copy_block) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ninit_waitqueue_head(&copy_block->wait);\r\nkref_init(&copy_block->kref);\r\nret = cmf_copy_block(cdev);\r\nif (ret != -EBUSY)\r\ngoto out_put;\r\nif (cdev->private->state != DEV_STATE_ONLINE) {\r\nret = -EBUSY;\r\ngoto out_put;\r\n}\r\ncdev->private->state = DEV_STATE_CMFUPDATE;\r\ncopy_block->ret = CMF_PENDING;\r\ncdev->private->cmb_wait = copy_block;\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nif (wait_event_interruptible(copy_block->wait,\r\ncopy_block->ret != CMF_PENDING)) {\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\nif (copy_block->ret == CMF_PENDING) {\r\ncopy_block->ret = -ERESTARTSYS;\r\nif (cdev->private->state == DEV_STATE_CMFUPDATE)\r\ncdev->private->state = DEV_STATE_ONLINE;\r\n}\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\n}\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\ncdev->private->cmb_wait = NULL;\r\nret = copy_block->ret;\r\nout_put:\r\nkref_put(&copy_block->kref, cmf_copy_block_release);\r\nout:\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn ret;\r\n}\r\nvoid cmf_retry_copy_block(struct ccw_device *cdev)\r\n{\r\nstruct copy_block_struct *copy_block;\r\ncopy_block = cdev->private->cmb_wait;\r\nif (!copy_block) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nkref_get(&copy_block->kref);\r\ncopy_block->ret = cmf_copy_block(cdev);\r\nwake_up(&copy_block->wait);\r\nkref_put(&copy_block->kref, cmf_copy_block_release);\r\n}\r\nstatic void cmf_generic_reset(struct ccw_device *cdev)\r\n{\r\nstruct cmb_data *cmb_data;\r\nspin_lock_irq(cdev->ccwlock);\r\ncmb_data = cdev->private->cmb;\r\nif (cmb_data) {\r\nmemset(cmb_data->last_block, 0, cmb_data->size);\r\nmemset(cmbops->align(cmb_data->hw_block), 0, cmb_data->size);\r\ncmb_data->last_update = 0;\r\n}\r\ncdev->private->cmb_start_time = get_clock();\r\nspin_unlock_irq(cdev->ccwlock);\r\n}\r\nstatic int alloc_cmb_single(struct ccw_device *cdev,\r\nstruct cmb_data *cmb_data)\r\n{\r\nstruct cmb *cmb;\r\nstruct ccw_device_private *node;\r\nint ret;\r\nspin_lock_irq(cdev->ccwlock);\r\nif (!list_empty(&cdev->private->cmb_list)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncmb = cmb_area.mem;\r\nlist_for_each_entry(node, &cmb_area.list, cmb_list) {\r\nstruct cmb_data *data;\r\ndata = node->cmb;\r\nif ((struct cmb*)data->hw_block > cmb)\r\nbreak;\r\ncmb++;\r\n}\r\nif (cmb - cmb_area.mem >= cmb_area.num_channels) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nlist_add_tail(&cdev->private->cmb_list, &node->cmb_list);\r\ncmb_data->hw_block = cmb;\r\ncdev->private->cmb = cmb_data;\r\nret = 0;\r\nout:\r\nspin_unlock_irq(cdev->ccwlock);\r\nreturn ret;\r\n}\r\nstatic int alloc_cmb(struct ccw_device *cdev)\r\n{\r\nint ret;\r\nstruct cmb *mem;\r\nssize_t size;\r\nstruct cmb_data *cmb_data;\r\ncmb_data = kzalloc(sizeof(struct cmb_data), GFP_KERNEL);\r\nif (!cmb_data)\r\nreturn -ENOMEM;\r\ncmb_data->last_block = kzalloc(sizeof(struct cmb), GFP_KERNEL);\r\nif (!cmb_data->last_block) {\r\nkfree(cmb_data);\r\nreturn -ENOMEM;\r\n}\r\ncmb_data->size = sizeof(struct cmb);\r\nspin_lock(&cmb_area.lock);\r\nif (!cmb_area.mem) {\r\nsize = sizeof(struct cmb) * cmb_area.num_channels;\r\nWARN_ON(!list_empty(&cmb_area.list));\r\nspin_unlock(&cmb_area.lock);\r\nmem = (void*)__get_free_pages(GFP_KERNEL | GFP_DMA,\r\nget_order(size));\r\nspin_lock(&cmb_area.lock);\r\nif (cmb_area.mem) {\r\nfree_pages((unsigned long)mem, get_order(size));\r\n} else if (!mem) {\r\nret = -ENOMEM;\r\ngoto out;\r\n} else {\r\nmemset(mem, 0, size);\r\ncmb_area.mem = mem;\r\ncmf_activate(cmb_area.mem, 1);\r\n}\r\n}\r\nret = alloc_cmb_single(cdev, cmb_data);\r\nout:\r\nspin_unlock(&cmb_area.lock);\r\nif (ret) {\r\nkfree(cmb_data->last_block);\r\nkfree(cmb_data);\r\n}\r\nreturn ret;\r\n}\r\nstatic void free_cmb(struct ccw_device *cdev)\r\n{\r\nstruct ccw_device_private *priv;\r\nstruct cmb_data *cmb_data;\r\nspin_lock(&cmb_area.lock);\r\nspin_lock_irq(cdev->ccwlock);\r\npriv = cdev->private;\r\nif (list_empty(&priv->cmb_list)) {\r\ngoto out;\r\n}\r\ncmb_data = priv->cmb;\r\npriv->cmb = NULL;\r\nif (cmb_data)\r\nkfree(cmb_data->last_block);\r\nkfree(cmb_data);\r\nlist_del_init(&priv->cmb_list);\r\nif (list_empty(&cmb_area.list)) {\r\nssize_t size;\r\nsize = sizeof(struct cmb) * cmb_area.num_channels;\r\ncmf_activate(NULL, 0);\r\nfree_pages((unsigned long)cmb_area.mem, get_order(size));\r\ncmb_area.mem = NULL;\r\n}\r\nout:\r\nspin_unlock_irq(cdev->ccwlock);\r\nspin_unlock(&cmb_area.lock);\r\n}\r\nstatic int set_cmb(struct ccw_device *cdev, u32 mme)\r\n{\r\nu16 offset;\r\nstruct cmb_data *cmb_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\nif (!cdev->private->cmb) {\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn -EINVAL;\r\n}\r\ncmb_data = cdev->private->cmb;\r\noffset = mme ? (struct cmb *)cmb_data->hw_block - cmb_area.mem : 0;\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn set_schib_wait(cdev, mme, 0, offset);\r\n}\r\nstatic u64 read_cmb(struct ccw_device *cdev, int index)\r\n{\r\nstruct cmb *cmb;\r\nu32 val;\r\nint ret;\r\nunsigned long flags;\r\nret = cmf_cmb_copy_wait(cdev);\r\nif (ret < 0)\r\nreturn 0;\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\nif (!cdev->private->cmb) {\r\nret = 0;\r\ngoto out;\r\n}\r\ncmb = ((struct cmb_data *)cdev->private->cmb)->last_block;\r\nswitch (index) {\r\ncase cmb_ssch_rsch_count:\r\nret = cmb->ssch_rsch_count;\r\ngoto out;\r\ncase cmb_sample_count:\r\nret = cmb->sample_count;\r\ngoto out;\r\ncase cmb_device_connect_time:\r\nval = cmb->device_connect_time;\r\nbreak;\r\ncase cmb_function_pending_time:\r\nval = cmb->function_pending_time;\r\nbreak;\r\ncase cmb_device_disconnect_time:\r\nval = cmb->device_disconnect_time;\r\nbreak;\r\ncase cmb_control_unit_queuing_time:\r\nval = cmb->control_unit_queuing_time;\r\nbreak;\r\ncase cmb_device_active_only_time:\r\nval = cmb->device_active_only_time;\r\nbreak;\r\ndefault:\r\nret = 0;\r\ngoto out;\r\n}\r\nret = time_to_avg_nsec(val, cmb->sample_count);\r\nout:\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn ret;\r\n}\r\nstatic int readall_cmb(struct ccw_device *cdev, struct cmbdata *data)\r\n{\r\nstruct cmb *cmb;\r\nstruct cmb_data *cmb_data;\r\nu64 time;\r\nunsigned long flags;\r\nint ret;\r\nret = cmf_cmb_copy_wait(cdev);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\ncmb_data = cdev->private->cmb;\r\nif (!cmb_data) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (cmb_data->last_update == 0) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\ncmb = cmb_data->last_block;\r\ntime = cmb_data->last_update - cdev->private->cmb_start_time;\r\nmemset(data, 0, sizeof(struct cmbdata));\r\ndata->size = offsetof(struct cmbdata, device_busy_time);\r\ndata->elapsed_time = (time * 1000) >> 12;\r\ndata->ssch_rsch_count = cmb->ssch_rsch_count;\r\ndata->sample_count = cmb->sample_count;\r\ndata->device_connect_time = time_to_nsec(cmb->device_connect_time);\r\ndata->function_pending_time = time_to_nsec(cmb->function_pending_time);\r\ndata->device_disconnect_time =\r\ntime_to_nsec(cmb->device_disconnect_time);\r\ndata->control_unit_queuing_time\r\n= time_to_nsec(cmb->control_unit_queuing_time);\r\ndata->device_active_only_time\r\n= time_to_nsec(cmb->device_active_only_time);\r\nret = 0;\r\nout:\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn ret;\r\n}\r\nstatic void reset_cmb(struct ccw_device *cdev)\r\n{\r\ncmf_generic_reset(cdev);\r\n}\r\nstatic void * align_cmb(void *area)\r\n{\r\nreturn area;\r\n}\r\nstatic inline struct cmbe *cmbe_align(struct cmbe *c)\r\n{\r\nunsigned long addr;\r\naddr = ((unsigned long)c + sizeof (struct cmbe) - sizeof(long)) &\r\n~(sizeof (struct cmbe) - sizeof(long));\r\nreturn (struct cmbe*)addr;\r\n}\r\nstatic int alloc_cmbe(struct ccw_device *cdev)\r\n{\r\nstruct cmbe *cmbe;\r\nstruct cmb_data *cmb_data;\r\nint ret;\r\ncmbe = kzalloc (sizeof (*cmbe) * 2, GFP_KERNEL);\r\nif (!cmbe)\r\nreturn -ENOMEM;\r\ncmb_data = kzalloc(sizeof(struct cmb_data), GFP_KERNEL);\r\nif (!cmb_data) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\ncmb_data->last_block = kzalloc(sizeof(struct cmbe), GFP_KERNEL);\r\nif (!cmb_data->last_block) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\ncmb_data->size = sizeof(struct cmbe);\r\nspin_lock_irq(cdev->ccwlock);\r\nif (cdev->private->cmb) {\r\nspin_unlock_irq(cdev->ccwlock);\r\nret = -EBUSY;\r\ngoto out_free;\r\n}\r\ncmb_data->hw_block = cmbe;\r\ncdev->private->cmb = cmb_data;\r\nspin_unlock_irq(cdev->ccwlock);\r\nspin_lock(&cmb_area.lock);\r\nif (list_empty(&cmb_area.list))\r\ncmf_activate(NULL, 1);\r\nlist_add_tail(&cdev->private->cmb_list, &cmb_area.list);\r\nspin_unlock(&cmb_area.lock);\r\nreturn 0;\r\nout_free:\r\nif (cmb_data)\r\nkfree(cmb_data->last_block);\r\nkfree(cmb_data);\r\nkfree(cmbe);\r\nreturn ret;\r\n}\r\nstatic void free_cmbe(struct ccw_device *cdev)\r\n{\r\nstruct cmb_data *cmb_data;\r\nspin_lock_irq(cdev->ccwlock);\r\ncmb_data = cdev->private->cmb;\r\ncdev->private->cmb = NULL;\r\nif (cmb_data)\r\nkfree(cmb_data->last_block);\r\nkfree(cmb_data);\r\nspin_unlock_irq(cdev->ccwlock);\r\nspin_lock(&cmb_area.lock);\r\nlist_del_init(&cdev->private->cmb_list);\r\nif (list_empty(&cmb_area.list))\r\ncmf_activate(NULL, 0);\r\nspin_unlock(&cmb_area.lock);\r\n}\r\nstatic int set_cmbe(struct ccw_device *cdev, u32 mme)\r\n{\r\nunsigned long mba;\r\nstruct cmb_data *cmb_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\nif (!cdev->private->cmb) {\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn -EINVAL;\r\n}\r\ncmb_data = cdev->private->cmb;\r\nmba = mme ? (unsigned long) cmbe_align(cmb_data->hw_block) : 0;\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn set_schib_wait(cdev, mme, 1, mba);\r\n}\r\nstatic u64 read_cmbe(struct ccw_device *cdev, int index)\r\n{\r\nstruct cmbe *cmb;\r\nstruct cmb_data *cmb_data;\r\nu32 val;\r\nint ret;\r\nunsigned long flags;\r\nret = cmf_cmb_copy_wait(cdev);\r\nif (ret < 0)\r\nreturn 0;\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\ncmb_data = cdev->private->cmb;\r\nif (!cmb_data) {\r\nret = 0;\r\ngoto out;\r\n}\r\ncmb = cmb_data->last_block;\r\nswitch (index) {\r\ncase cmb_ssch_rsch_count:\r\nret = cmb->ssch_rsch_count;\r\ngoto out;\r\ncase cmb_sample_count:\r\nret = cmb->sample_count;\r\ngoto out;\r\ncase cmb_device_connect_time:\r\nval = cmb->device_connect_time;\r\nbreak;\r\ncase cmb_function_pending_time:\r\nval = cmb->function_pending_time;\r\nbreak;\r\ncase cmb_device_disconnect_time:\r\nval = cmb->device_disconnect_time;\r\nbreak;\r\ncase cmb_control_unit_queuing_time:\r\nval = cmb->control_unit_queuing_time;\r\nbreak;\r\ncase cmb_device_active_only_time:\r\nval = cmb->device_active_only_time;\r\nbreak;\r\ncase cmb_device_busy_time:\r\nval = cmb->device_busy_time;\r\nbreak;\r\ncase cmb_initial_command_response_time:\r\nval = cmb->initial_command_response_time;\r\nbreak;\r\ndefault:\r\nret = 0;\r\ngoto out;\r\n}\r\nret = time_to_avg_nsec(val, cmb->sample_count);\r\nout:\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn ret;\r\n}\r\nstatic int readall_cmbe(struct ccw_device *cdev, struct cmbdata *data)\r\n{\r\nstruct cmbe *cmb;\r\nstruct cmb_data *cmb_data;\r\nu64 time;\r\nunsigned long flags;\r\nint ret;\r\nret = cmf_cmb_copy_wait(cdev);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_irqsave(cdev->ccwlock, flags);\r\ncmb_data = cdev->private->cmb;\r\nif (!cmb_data) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (cmb_data->last_update == 0) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\ntime = cmb_data->last_update - cdev->private->cmb_start_time;\r\nmemset (data, 0, sizeof(struct cmbdata));\r\ndata->size = offsetof(struct cmbdata, device_busy_time);\r\ndata->elapsed_time = (time * 1000) >> 12;\r\ncmb = cmb_data->last_block;\r\ndata->ssch_rsch_count = cmb->ssch_rsch_count;\r\ndata->sample_count = cmb->sample_count;\r\ndata->device_connect_time = time_to_nsec(cmb->device_connect_time);\r\ndata->function_pending_time = time_to_nsec(cmb->function_pending_time);\r\ndata->device_disconnect_time =\r\ntime_to_nsec(cmb->device_disconnect_time);\r\ndata->control_unit_queuing_time\r\n= time_to_nsec(cmb->control_unit_queuing_time);\r\ndata->device_active_only_time\r\n= time_to_nsec(cmb->device_active_only_time);\r\ndata->device_busy_time = time_to_nsec(cmb->device_busy_time);\r\ndata->initial_command_response_time\r\n= time_to_nsec(cmb->initial_command_response_time);\r\nret = 0;\r\nout:\r\nspin_unlock_irqrestore(cdev->ccwlock, flags);\r\nreturn ret;\r\n}\r\nstatic void reset_cmbe(struct ccw_device *cdev)\r\n{\r\ncmf_generic_reset(cdev);\r\n}\r\nstatic void * align_cmbe(void *area)\r\n{\r\nreturn cmbe_align(area);\r\n}\r\nstatic ssize_t cmb_show_attr(struct device *dev, char *buf, enum cmb_index idx)\r\n{\r\nreturn sprintf(buf, "%lld\n",\r\n(unsigned long long) cmf_read(to_ccwdev(dev), idx));\r\n}\r\nstatic ssize_t cmb_show_avg_sample_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ccw_device *cdev;\r\nlong interval;\r\nunsigned long count;\r\nstruct cmb_data *cmb_data;\r\ncdev = to_ccwdev(dev);\r\ncount = cmf_read(cdev, cmb_sample_count);\r\nspin_lock_irq(cdev->ccwlock);\r\ncmb_data = cdev->private->cmb;\r\nif (count) {\r\ninterval = cmb_data->last_update -\r\ncdev->private->cmb_start_time;\r\ninterval = (interval * 1000) >> 12;\r\ninterval /= count;\r\n} else\r\ninterval = -1;\r\nspin_unlock_irq(cdev->ccwlock);\r\nreturn sprintf(buf, "%ld\n", interval);\r\n}\r\nstatic ssize_t cmb_show_avg_utilization(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct cmbdata data;\r\nu64 utilization;\r\nunsigned long t, u;\r\nint ret;\r\nret = cmf_readall(to_ccwdev(dev), &data);\r\nif (ret == -EAGAIN || ret == -ENODEV)\r\nreturn sprintf(buf, "n/a\n");\r\nelse if (ret)\r\nreturn ret;\r\nutilization = data.device_connect_time +\r\ndata.function_pending_time +\r\ndata.device_disconnect_time;\r\nwhile (-1ul < (data.elapsed_time | utilization)) {\r\nutilization >>= 8;\r\ndata.elapsed_time >>= 8;\r\n}\r\nt = (unsigned long) data.elapsed_time / 1000;\r\nu = (unsigned long) utilization / t;\r\nreturn sprintf(buf, "%02ld.%01ld%%\n", u/ 10, u - (u/ 10) * 10);\r\n}\r\nstatic ssize_t cmb_enable_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", to_ccwdev(dev)->private->cmb ? 1 : 0);\r\n}\r\nstatic ssize_t cmb_enable_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t c)\r\n{\r\nstruct ccw_device *cdev;\r\nint ret;\r\nunsigned long val;\r\nret = strict_strtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ncdev = to_ccwdev(dev);\r\nswitch (val) {\r\ncase 0:\r\nret = disable_cmf(cdev);\r\nbreak;\r\ncase 1:\r\nret = enable_cmf(cdev);\r\nbreak;\r\n}\r\nreturn c;\r\n}\r\nint ccw_set_cmf(struct ccw_device *cdev, int enable)\r\n{\r\nreturn cmbops->set(cdev, enable ? 2 : 0);\r\n}\r\nint enable_cmf(struct ccw_device *cdev)\r\n{\r\nint ret;\r\nret = cmbops->alloc(cdev);\r\ncmbops->reset(cdev);\r\nif (ret)\r\nreturn ret;\r\nret = cmbops->set(cdev, 2);\r\nif (ret) {\r\ncmbops->free(cdev);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&cdev->dev.kobj, cmbops->attr_group);\r\nif (!ret)\r\nreturn 0;\r\ncmbops->set(cdev, 0);\r\ncmbops->free(cdev);\r\nreturn ret;\r\n}\r\nint disable_cmf(struct ccw_device *cdev)\r\n{\r\nint ret;\r\nret = cmbops->set(cdev, 0);\r\nif (ret)\r\nreturn ret;\r\ncmbops->free(cdev);\r\nsysfs_remove_group(&cdev->dev.kobj, cmbops->attr_group);\r\nreturn ret;\r\n}\r\nu64 cmf_read(struct ccw_device *cdev, int index)\r\n{\r\nreturn cmbops->read(cdev, index);\r\n}\r\nint cmf_readall(struct ccw_device *cdev, struct cmbdata *data)\r\n{\r\nreturn cmbops->readall(cdev, data);\r\n}\r\nint cmf_reenable(struct ccw_device *cdev)\r\n{\r\ncmbops->reset(cdev);\r\nreturn cmbops->set(cdev, 2);\r\n}\r\nstatic int __init init_cmf(void)\r\n{\r\nchar *format_string;\r\nchar *detect_string = "parameter";\r\nif (format == CMF_AUTODETECT) {\r\nif (!css_general_characteristics.ext_mb) {\r\nformat = CMF_BASIC;\r\n} else {\r\nformat = CMF_EXTENDED;\r\n}\r\ndetect_string = "autodetected";\r\n} else {\r\ndetect_string = "parameter";\r\n}\r\nswitch (format) {\r\ncase CMF_BASIC:\r\nformat_string = "basic";\r\ncmbops = &cmbops_basic;\r\nbreak;\r\ncase CMF_EXTENDED:\r\nformat_string = "extended";\r\ncmbops = &cmbops_extended;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\npr_info("Channel measurement facility initialized using format "\r\n"%s (mode %s)\n", format_string, detect_string);\r\nreturn 0;\r\n}
