static int load_em86(struct linux_binprm *bprm,struct pt_regs *regs)\r\n{\r\nchar *interp, *i_name, *i_arg;\r\nstruct file * file;\r\nint retval;\r\nstruct elfhdr elf_ex;\r\nelf_ex = *((struct elfhdr *)bprm->buf);\r\nif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\r\nreturn -ENOEXEC;\r\nif ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\r\n(!((elf_ex.e_machine == EM_386) || (elf_ex.e_machine == EM_486))) ||\r\n(!bprm->file->f_op || !bprm->file->f_op->mmap)) {\r\nreturn -ENOEXEC;\r\n}\r\nbprm->recursion_depth++;\r\nallow_write_access(bprm->file);\r\nfput(bprm->file);\r\nbprm->file = NULL;\r\ninterp = EM86_INTERP;\r\ni_name = EM86_I_NAME;\r\ni_arg = NULL;\r\nremove_arg_zero(bprm);\r\nretval = copy_strings_kernel(1, &bprm->filename, bprm);\r\nif (retval < 0) return retval;\r\nbprm->argc++;\r\nif (i_arg) {\r\nretval = copy_strings_kernel(1, &i_arg, bprm);\r\nif (retval < 0) return retval;\r\nbprm->argc++;\r\n}\r\nretval = copy_strings_kernel(1, &i_name, bprm);\r\nif (retval < 0) return retval;\r\nbprm->argc++;\r\nfile = open_exec(interp);\r\nif (IS_ERR(file))\r\nreturn PTR_ERR(file);\r\nbprm->file = file;\r\nretval = prepare_binprm(bprm);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn search_binary_handler(bprm, regs);\r\n}\r\nstatic int __init init_em86_binfmt(void)\r\n{\r\nreturn register_binfmt(&em86_format);\r\n}\r\nstatic void __exit exit_em86_binfmt(void)\r\n{\r\nunregister_binfmt(&em86_format);\r\n}
