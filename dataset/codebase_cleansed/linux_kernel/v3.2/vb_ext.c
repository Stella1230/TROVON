static unsigned char XGINew_Is301B(struct vb_device_info *pVBInfo)\r\n{\r\nunsigned short flag;\r\nflag = xgifb_reg_get(pVBInfo->Part4Port, 0x01);\r\nif (flag > 0x0B0)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic unsigned char XGINew_Sense(unsigned short tempbx,\r\nunsigned short tempcx,\r\nstruct vb_device_info *pVBInfo)\r\n{\r\nunsigned short temp, i, tempch;\r\ntemp = tempbx & 0xFF;\r\nxgifb_reg_set(pVBInfo->Part4Port, 0x11, temp);\r\ntemp = (tempbx & 0xFF00) >> 8;\r\ntemp |= (tempcx & 0x00FF);\r\nxgifb_reg_and_or(pVBInfo->Part4Port, 0x10, ~0x1F, temp);\r\nfor (i = 0; i < 10; i++)\r\nXGI_LongWait(pVBInfo);\r\ntempch = (tempcx & 0x7F00) >> 8;\r\ntemp = xgifb_reg_get(pVBInfo->Part4Port, 0x03);\r\ntemp = temp ^ (0x0E);\r\ntemp &= tempch;\r\nif (temp > 0)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned char\r\nXGINew_GetLCDDDCInfo(struct xgi_hw_device_info *HwDeviceExtension,\r\nstruct vb_device_info *pVBInfo)\r\n{\r\nunsigned short temp;\r\nif (HwDeviceExtension->ulCRT2LCDType == LCD_UNKNOWN) {\r\nreturn 0;\r\n} else {\r\ntemp = (unsigned short) HwDeviceExtension->ulCRT2LCDType;\r\nswitch (HwDeviceExtension->ulCRT2LCDType) {\r\ncase LCD_INVALID:\r\ncase LCD_800x600:\r\ncase LCD_1024x768:\r\ncase LCD_1280x1024:\r\nbreak;\r\ncase LCD_640x480:\r\ncase LCD_1024x600:\r\ncase LCD_1152x864:\r\ncase LCD_1280x960:\r\ncase LCD_1152x768:\r\ntemp = 0;\r\nbreak;\r\ncase LCD_1400x1050:\r\ncase LCD_1280x768:\r\ncase LCD_1600x1200:\r\nbreak;\r\ncase LCD_1920x1440:\r\ncase LCD_2048x1536:\r\ntemp = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nxgifb_reg_and_or(pVBInfo->P3d4, 0x36, 0xF0, temp);\r\nreturn 1;\r\n}\r\n}\r\nstatic unsigned char XGINew_GetPanelID(struct vb_device_info *pVBInfo)\r\n{\r\nunsigned short PanelTypeTable[16] = { SyncNN | PanelRGB18Bit\r\n| Panel800x600 | _PanelType00, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType01, SyncNN | PanelRGB18Bit\r\n| Panel800x600 | _PanelType02, SyncNN | PanelRGB18Bit\r\n| Panel640x480 | _PanelType03, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType04, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType05, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType06, SyncNN | PanelRGB24Bit\r\n| Panel1024x768 | _PanelType07, SyncNN | PanelRGB18Bit\r\n| Panel800x600 | _PanelType08, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType09, SyncNN | PanelRGB18Bit\r\n| Panel800x600 | _PanelType0A, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType0B, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType0C, SyncNN | PanelRGB24Bit\r\n| Panel1024x768 | _PanelType0D, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType0E, SyncNN | PanelRGB18Bit\r\n| Panel1024x768 | _PanelType0F };\r\nunsigned short tempax, tempbx, temp;\r\ntempax = xgifb_reg_get(pVBInfo->P3c4, 0x1A);\r\ntempbx = tempax & 0x1E;\r\nif (tempax == 0)\r\nreturn 0;\r\nelse {\r\ntempbx = tempbx >> 1;\r\ntemp = tempbx & 0x00F;\r\nxgifb_reg_set(pVBInfo->P3d4, 0x36, temp);\r\ntempbx--;\r\ntempbx = PanelTypeTable[tempbx];\r\ntemp = (tempbx & 0xFF00) >> 8;\r\nxgifb_reg_and_or(pVBInfo->P3d4, 0x37, ~(LCDSyncBit\r\n| LCDRGB18Bit), temp);\r\nreturn 1;\r\n}\r\n}\r\nstatic unsigned char\r\nXGINew_BridgeIsEnable(struct xgi_hw_device_info *HwDeviceExtension,\r\nstruct vb_device_info *pVBInfo)\r\n{\r\nunsigned short flag;\r\nif (XGI_BridgeIsOn(pVBInfo) == 0) {\r\nflag = xgifb_reg_get(pVBInfo->Part1Port, 0x0);\r\nif (flag & 0x050)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char\r\nXGINew_SenseHiTV(struct xgi_hw_device_info *HwDeviceExtension,\r\nstruct vb_device_info *pVBInfo)\r\n{\r\nunsigned short tempbx, tempcx, temp, i, tempch;\r\ntempbx = *pVBInfo->pYCSenseData2;\r\ntempcx = 0x0604;\r\ntemp = tempbx & 0xFF;\r\nxgifb_reg_set(pVBInfo->Part4Port, 0x11, temp);\r\ntemp = (tempbx & 0xFF00) >> 8;\r\ntemp |= (tempcx & 0x00FF);\r\nxgifb_reg_and_or(pVBInfo->Part4Port, 0x10, ~0x1F, temp);\r\nfor (i = 0; i < 10; i++)\r\nXGI_LongWait(pVBInfo);\r\ntempch = (tempcx & 0xFF00) >> 8;\r\ntemp = xgifb_reg_get(pVBInfo->Part4Port, 0x03);\r\ntemp = temp ^ (0x0E);\r\ntemp &= tempch;\r\nif (temp != tempch)\r\nreturn 0;\r\ntempbx = *pVBInfo->pVideoSenseData2;\r\ntempcx = 0x0804;\r\ntemp = tempbx & 0xFF;\r\nxgifb_reg_set(pVBInfo->Part4Port, 0x11, temp);\r\ntemp = (tempbx & 0xFF00) >> 8;\r\ntemp |= (tempcx & 0x00FF);\r\nxgifb_reg_and_or(pVBInfo->Part4Port, 0x10, ~0x1F, temp);\r\nfor (i = 0; i < 10; i++)\r\nXGI_LongWait(pVBInfo);\r\ntempch = (tempcx & 0xFF00) >> 8;\r\ntemp = xgifb_reg_get(pVBInfo->Part4Port, 0x03);\r\ntemp = temp ^ (0x0E);\r\ntemp &= tempch;\r\nif (temp != tempch) {\r\nreturn 0;\r\n} else {\r\ntempbx = 0x3FF;\r\ntempcx = 0x0804;\r\ntemp = tempbx & 0xFF;\r\nxgifb_reg_set(pVBInfo->Part4Port, 0x11, temp);\r\ntemp = (tempbx & 0xFF00) >> 8;\r\ntemp |= (tempcx & 0x00FF);\r\nxgifb_reg_and_or(pVBInfo->Part4Port, 0x10, ~0x1F, temp);\r\nfor (i = 0; i < 10; i++)\r\nXGI_LongWait(pVBInfo);\r\ntempch = (tempcx & 0xFF00) >> 8;\r\ntemp = xgifb_reg_get(pVBInfo->Part4Port, 0x03);\r\ntemp = temp ^ (0x0E);\r\ntemp &= tempch;\r\nif (temp != tempch)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\n}\r\nvoid XGI_GetSenseStatus(struct xgi_hw_device_info *HwDeviceExtension,\r\nstruct vb_device_info *pVBInfo)\r\n{\r\nunsigned short tempax = 0, tempbx, tempcx, temp,\r\nP2reg0 = 0, SenseModeNo = 0,\r\nOutputSelect = *pVBInfo->pOutputSelect,\r\nModeIdIndex, i;\r\npVBInfo->BaseAddr = (unsigned long) HwDeviceExtension->pjIOAddress;\r\nif (pVBInfo->IF_DEF_LVDS == 1) {\r\ntempax = xgifb_reg_get(pVBInfo->P3c4, 0x1A);\r\ntempbx = xgifb_reg_get(pVBInfo->P3c4, 0x1B);\r\ntempax = ((tempax & 0xFE) >> 1) | (tempbx << 8);\r\nif (tempax == 0x00) {\r\ntemp = XGINew_GetLCDDDCInfo(HwDeviceExtension, pVBInfo);\r\nif (temp == 1) {\r\nxgifb_reg_and_or(pVBInfo->P3d4,\r\n0x39, 0xFF, 0x01);\r\nxgifb_reg_and_or(pVBInfo->P3d4,\r\n0x37, 0xEF, 0x00);\r\ntemp = LCDSense;\r\n} else {\r\ntemp = 0;\r\n}\r\n} else {\r\nXGINew_GetPanelID(pVBInfo);\r\ntemp = LCDSense;\r\n}\r\ntempbx = ~(LCDSense | AVIDEOSense | SVIDEOSense);\r\nxgifb_reg_and_or(pVBInfo->P3d4, 0x32, tempbx, temp);\r\n} else {\r\nif (pVBInfo->VBInfo & SetCRT2ToHiVisionTV) {\r\ntempax = xgifb_reg_get(pVBInfo->P3c4, 0x38);\r\ntemp = tempax & 0x01;\r\ntempax = xgifb_reg_get(pVBInfo->P3c4, 0x3A);\r\ntemp = temp | (tempax & 0x02);\r\nxgifb_reg_and_or(pVBInfo->P3d4, 0x32, 0xA0, temp);\r\n} else {\r\nif (XGI_BridgeIsOn(pVBInfo)) {\r\nP2reg0 = xgifb_reg_get(pVBInfo->Part2Port,\r\n0x00);\r\nif (!XGINew_BridgeIsEnable(HwDeviceExtension,\r\npVBInfo)) {\r\nSenseModeNo = 0x2e;\r\ntemp = XGI_SearchModeID(SenseModeNo,\r\n&ModeIdIndex,\r\npVBInfo);\r\nXGI_GetVGAType(HwDeviceExtension,\r\npVBInfo);\r\nXGI_GetVBType(pVBInfo);\r\npVBInfo->SetFlag = 0x00;\r\npVBInfo->ModeType = ModeVGA;\r\npVBInfo->VBInfo = SetCRT2ToRAMDAC |\r\nLoadDACFlag |\r\nSetInSlaveMode;\r\nXGI_GetLCDInfo(0x2e,\r\nModeIdIndex,\r\npVBInfo);\r\nXGI_GetTVInfo(0x2e,\r\nModeIdIndex,\r\npVBInfo);\r\nXGI_EnableBridge(HwDeviceExtension,\r\npVBInfo);\r\nXGI_SetCRT2Group301(SenseModeNo,\r\nHwDeviceExtension,\r\npVBInfo);\r\nXGI_SetCRT2ModeRegs(0x2e,\r\nHwDeviceExtension,\r\npVBInfo);\r\nxgifb_reg_and_or(pVBInfo->P3c4,\r\n0x01,\r\n0xDF,\r\n0x20);\r\nfor (i = 0; i < 20; i++)\r\nXGI_LongWait(pVBInfo);\r\n}\r\nxgifb_reg_set(pVBInfo->Part2Port, 0x00, 0x1c);\r\ntempax = 0;\r\ntempbx = *pVBInfo->pRGBSenseData;\r\nif (!(XGINew_Is301B(pVBInfo)))\r\ntempbx = *pVBInfo->pRGBSenseData2;\r\ntempcx = 0x0E08;\r\nif (XGINew_Sense(tempbx, tempcx, pVBInfo)) {\r\nif (XGINew_Sense(tempbx,\r\ntempcx,\r\npVBInfo))\r\ntempax |= Monitor2Sense;\r\n}\r\nif (pVBInfo->VBType & VB_XGI301C)\r\nxgifb_reg_or(pVBInfo->Part4Port,\r\n0x0d,\r\n0x04);\r\nif (XGINew_SenseHiTV(HwDeviceExtension,\r\npVBInfo)) {\r\ntempax |= HiTVSense;\r\nif ((pVBInfo->VBType & VB_XGI301C))\r\ntempax ^= (HiTVSense |\r\nYPbPrSense);\r\n}\r\nif (!(tempax & (HiTVSense | YPbPrSense))) {\r\ntempbx = *pVBInfo->pYCSenseData;\r\nif (!(XGINew_Is301B(pVBInfo)))\r\ntempbx = *pVBInfo->pYCSenseData2;\r\ntempcx = 0x0604;\r\nif (XGINew_Sense(tempbx,\r\ntempcx,\r\npVBInfo)) {\r\nif (XGINew_Sense(tempbx,\r\ntempcx,\r\npVBInfo))\r\ntempax |= SVIDEOSense;\r\n}\r\nif (OutputSelect & BoardTVType) {\r\ntempbx = *pVBInfo->pVideoSenseData;\r\nif (!(XGINew_Is301B(pVBInfo)))\r\ntempbx = *pVBInfo->pVideoSenseData2;\r\ntempcx = 0x0804;\r\nif (XGINew_Sense(tempbx,\r\ntempcx,\r\npVBInfo)) {\r\nif (XGINew_Sense(tempbx,\r\ntempcx,\r\npVBInfo))\r\ntempax |= AVIDEOSense;\r\n}\r\n} else {\r\nif (!(tempax & SVIDEOSense)) {\r\ntempbx = *pVBInfo->pVideoSenseData;\r\nif (!(XGINew_Is301B(pVBInfo)))\r\ntempbx = *pVBInfo->pVideoSenseData2;\r\ntempcx = 0x0804;\r\nif (XGINew_Sense(tempbx,\r\ntempcx,\r\npVBInfo)) {\r\nif (XGINew_Sense(tempbx, tempcx, pVBInfo))\r\ntempax |= AVIDEOSense;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (!(tempax & Monitor2Sense)) {\r\nif (XGINew_SenseLCD(HwDeviceExtension, pVBInfo))\r\ntempax |= LCDSense;\r\n}\r\ntempbx = 0;\r\ntempcx = 0;\r\nXGINew_Sense(tempbx, tempcx, pVBInfo);\r\nxgifb_reg_and_or(pVBInfo->P3d4, 0x32, ~0xDF, tempax);\r\nxgifb_reg_set(pVBInfo->Part2Port, 0x00, P2reg0);\r\nif (!(P2reg0 & 0x20)) {\r\npVBInfo->VBInfo = DisableCRT2Display;\r\n}\r\n}\r\n}\r\nXGI_DisableBridge(HwDeviceExtension, pVBInfo);\r\n}\r\nunsigned short XGINew_SenseLCD(struct xgi_hw_device_info *HwDeviceExtension,\r\nstruct vb_device_info *pVBInfo)\r\n{\r\nunsigned short temp;\r\ntemp = XGINew_GetLCDDDCInfo(HwDeviceExtension, pVBInfo);\r\nreturn temp;\r\n}
