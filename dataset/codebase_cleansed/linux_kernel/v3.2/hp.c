static int __init do_hp_probe(struct net_device *dev)\r\n{\r\nint i;\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\nif (base_addr > 0x1ff)\r\nreturn hp_probe1(dev, base_addr);\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nfor (i = 0; hppclan_portlist[i]; i++) {\r\nif (hp_probe1(dev, hppclan_portlist[i]) == 0)\r\nreturn 0;\r\ndev->irq = irq;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init hp_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_eip_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_hp_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init hp_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i, retval, board_id, wordmode;\r\nconst char *name;\r\nstatic unsigned version_printed;\r\nif (!request_region(ioaddr, HP_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\nif (inb(ioaddr) != 0x08\r\n|| inb(ioaddr+1) != 0x00\r\n|| inb(ioaddr+2) != 0x09\r\n|| inb(ioaddr+14) == 0x57) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif ((board_id = inb(ioaddr + HP_ID)) & 0x80) {\r\nname = "HP27247";\r\nwordmode = 1;\r\n} else {\r\nname = "HP27250";\r\nwordmode = 0;\r\n}\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(version);\r\nprintk("%s: %s (ID %02x) at %#3x,", dev->name, name, board_id, ioaddr);\r\nfor(i = 0; i < ETHER_ADDR_LEN; i++)\r\ndev->dev_addr[i] = inb(ioaddr + i);\r\nprintk(" %pM", dev->dev_addr);\r\nif (dev->irq < 2) {\r\nstatic const int irq_16list[] = { 11, 10, 5, 3, 4, 7, 9, 0};\r\nstatic const int irq_8list[] = { 7, 5, 3, 4, 9, 0};\r\nconst int *irqp = wordmode ? irq_16list : irq_8list;\r\ndo {\r\nint irq = *irqp;\r\nif (request_irq (irq, NULL, 0, "bogus", NULL) != -EBUSY) {\r\nunsigned long cookie = probe_irq_on();\r\noutb_p(irqmap[irq] | HP_RUN, ioaddr + HP_CONFIGURE);\r\noutb_p( 0x00 | HP_RUN, ioaddr + HP_CONFIGURE);\r\nif (irq == probe_irq_off(cookie)\r\n&& request_irq (irq, eip_interrupt, 0, DRV_NAME, dev) == 0) {\r\nprintk(" selecting IRQ %d.\n", irq);\r\ndev->irq = *irqp;\r\nbreak;\r\n}\r\n}\r\n} while (*++irqp);\r\nif (*irqp == 0) {\r\nprintk(" no free IRQ lines.\n");\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\n} else {\r\nif (dev->irq == 2)\r\ndev->irq = 9;\r\nif ((retval = request_irq(dev->irq, eip_interrupt, 0, DRV_NAME, dev))) {\r\nprintk (" unable to get IRQ %d.\n", dev->irq);\r\ngoto out;\r\n}\r\n}\r\ndev->base_addr = ioaddr + NIC_OFFSET;\r\ndev->netdev_ops = &eip_netdev_ops;\r\nei_status.name = name;\r\nei_status.word16 = wordmode;\r\nei_status.tx_start_page = HP_START_PG;\r\nei_status.rx_start_page = HP_START_PG + TX_PAGES;\r\nei_status.stop_page = wordmode ? HP_16BSTOP_PG : HP_8BSTOP_PG;\r\nei_status.reset_8390 = hp_reset_8390;\r\nei_status.get_8390_hdr = hp_get_8390_hdr;\r\nei_status.block_input = hp_block_input;\r\nei_status.block_output = hp_block_output;\r\nhp_init_card(dev);\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out1;\r\nreturn 0;\r\nout1:\r\nfree_irq(dev->irq, dev);\r\nout:\r\nrelease_region(ioaddr, HP_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic void\r\nhp_reset_8390(struct net_device *dev)\r\n{\r\nint hp_base = dev->base_addr - NIC_OFFSET;\r\nint saved_config = inb_p(hp_base + HP_CONFIGURE);\r\nif (ei_debug > 1) printk("resetting the 8390 time=%ld...", jiffies);\r\noutb_p(0x00, hp_base + HP_CONFIGURE);\r\nei_status.txing = 0;\r\nudelay(5);\r\noutb_p(saved_config, hp_base + HP_CONFIGURE);\r\nudelay(5);\r\nif ((inb_p(hp_base+NIC_OFFSET+EN0_ISR) & ENISR_RESET) == 0)\r\nprintk("%s: hp_reset_8390() did not complete.\n", dev->name);\r\nif (ei_debug > 1) printk("8390 reset done (%ld).", jiffies);\r\n}\r\nstatic void\r\nhp_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint nic_base = dev->base_addr;\r\nint saved_config = inb_p(nic_base - NIC_OFFSET + HP_CONFIGURE);\r\noutb_p(saved_config | HP_DATAON, nic_base - NIC_OFFSET + HP_CONFIGURE);\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base);\r\noutb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\r\noutb_p(0, nic_base + EN0_RCNTHI);\r\noutb_p(0, nic_base + EN0_RSARLO);\r\noutb_p(ring_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base);\r\nif (ei_status.word16)\r\ninsw(nic_base - NIC_OFFSET + HP_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);\r\nelse\r\ninsb(nic_base - NIC_OFFSET + HP_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));\r\noutb_p(saved_config & (~HP_DATAON), nic_base - NIC_OFFSET + HP_CONFIGURE);\r\n}\r\nstatic void\r\nhp_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nint nic_base = dev->base_addr;\r\nint saved_config = inb_p(nic_base - NIC_OFFSET + HP_CONFIGURE);\r\nint xfer_count = count;\r\nchar *buf = skb->data;\r\noutb_p(saved_config | HP_DATAON, nic_base - NIC_OFFSET + HP_CONFIGURE);\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base);\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\r\noutb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base);\r\nif (ei_status.word16) {\r\ninsw(nic_base - NIC_OFFSET + HP_DATAPORT,buf,count>>1);\r\nif (count & 0x01)\r\nbuf[count-1] = inb(nic_base - NIC_OFFSET + HP_DATAPORT), xfer_count++;\r\n} else {\r\ninsb(nic_base - NIC_OFFSET + HP_DATAPORT, buf, count);\r\n}\r\nif (ei_debug > 0) {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\nint addr = (high << 8) + low;\r\nif (((ring_offset + xfer_count) & 0xff) != (addr & 0xff))\r\nprintk("%s: RX transfer address mismatch, %#4.4x vs. %#4.4x (actual).\n",\r\ndev->name, ring_offset + xfer_count, addr);\r\n}\r\noutb_p(saved_config & (~HP_DATAON), nic_base - NIC_OFFSET + HP_CONFIGURE);\r\n}\r\nstatic void\r\nhp_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nint nic_base = dev->base_addr;\r\nint saved_config = inb_p(nic_base - NIC_OFFSET + HP_CONFIGURE);\r\noutb_p(saved_config | HP_DATAON, nic_base - NIC_OFFSET + HP_CONFIGURE);\r\nif (ei_status.word16 && (count & 0x01))\r\ncount++;\r\noutb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base);\r\n#ifdef NE8390_RW_BUGFIX\r\noutb_p(0x42, nic_base + EN0_RCNTLO);\r\noutb_p(0, nic_base + EN0_RCNTHI);\r\noutb_p(0xff, nic_base + EN0_RSARLO);\r\noutb_p(0x00, nic_base + EN0_RSARHI);\r\n#define NE_CMD 0x00\r\noutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\ninb_p(0x61);\r\ninb_p(0x61);\r\n#endif\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(0x00, nic_base + EN0_RSARLO);\r\noutb_p(start_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RWRITE+E8390_START, nic_base);\r\nif (ei_status.word16) {\r\noutsw(nic_base - NIC_OFFSET + HP_DATAPORT, buf, count>>1);\r\n} else {\r\noutsb(nic_base - NIC_OFFSET + HP_DATAPORT, buf, count);\r\n}\r\nif (ei_debug > 0) {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\nint addr = (high << 8) + low;\r\nif ((start_page << 8) + count != addr)\r\nprintk("%s: TX Transfer address mismatch, %#4.4x vs. %#4.4x.\n",\r\ndev->name, (start_page << 8) + count, addr);\r\n}\r\noutb_p(saved_config & (~HP_DATAON), nic_base - NIC_OFFSET + HP_CONFIGURE);\r\n}\r\nstatic void __init\r\nhp_init_card(struct net_device *dev)\r\n{\r\nint irq = dev->irq;\r\nNS8390p_init(dev, 0);\r\noutb_p(irqmap[irq&0x0f] | HP_RUN,\r\ndev->base_addr - NIC_OFFSET + HP_CONFIGURE);\r\n}\r\nint __init\r\ninit_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_HP_CARDS; this_dev++) {\r\nif (io[this_dev] == 0) {\r\nif (this_dev != 0) break;\r\nprintk(KERN_NOTICE "hp.c: Presently autoprobing (not recommended) for a single card.\n");\r\n}\r\ndev = alloc_eip_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\nif (do_hp_probe(dev) == 0) {\r\ndev_hp[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nprintk(KERN_WARNING "hp.c: No HP card found (i/o = 0x%x).\n", io[this_dev]);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr - NIC_OFFSET, HP_IO_EXTENT);\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_HP_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_hp[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
