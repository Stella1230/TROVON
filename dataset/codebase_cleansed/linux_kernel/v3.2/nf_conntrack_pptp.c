static void pptp_expectfn(struct nf_conn *ct,\r\nstruct nf_conntrack_expect *exp)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\ntypeof(nf_nat_pptp_hook_expectfn) nf_nat_pptp_expectfn;\r\npr_debug("increasing timeouts\n");\r\nct->proto.gre.timeout = PPTP_GRE_TIMEOUT;\r\nct->proto.gre.stream_timeout = PPTP_GRE_STREAM_TIMEOUT;\r\nrcu_read_lock();\r\nnf_nat_pptp_expectfn = rcu_dereference(nf_nat_pptp_hook_expectfn);\r\nif (nf_nat_pptp_expectfn && ct->master->status & IPS_NAT_MASK)\r\nnf_nat_pptp_expectfn(ct, exp);\r\nelse {\r\nstruct nf_conntrack_tuple inv_t;\r\nstruct nf_conntrack_expect *exp_other;\r\nnf_ct_invert_tuplepr(&inv_t, &exp->tuple);\r\npr_debug("trying to unexpect other dir: ");\r\nnf_ct_dump_tuple(&inv_t);\r\nexp_other = nf_ct_expect_find_get(net, nf_ct_zone(ct), &inv_t);\r\nif (exp_other) {\r\npr_debug("found\n");\r\nnf_ct_unexpect_related(exp_other);\r\nnf_ct_expect_put(exp_other);\r\n} else {\r\npr_debug("not found\n");\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int destroy_sibling_or_exp(struct net *net, struct nf_conn *ct,\r\nconst struct nf_conntrack_tuple *t)\r\n{\r\nconst struct nf_conntrack_tuple_hash *h;\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conn *sibling;\r\nu16 zone = nf_ct_zone(ct);\r\npr_debug("trying to timeout ct or exp for tuple ");\r\nnf_ct_dump_tuple(t);\r\nh = nf_conntrack_find_get(net, zone, t);\r\nif (h) {\r\nsibling = nf_ct_tuplehash_to_ctrack(h);\r\npr_debug("setting timeout of conntrack %p to 0\n", sibling);\r\nsibling->proto.gre.timeout = 0;\r\nsibling->proto.gre.stream_timeout = 0;\r\nif (del_timer(&sibling->timeout))\r\nsibling->timeout.function((unsigned long)sibling);\r\nnf_ct_put(sibling);\r\nreturn 1;\r\n} else {\r\nexp = nf_ct_expect_find_get(net, zone, t);\r\nif (exp) {\r\npr_debug("unexpect_related of expect %p\n", exp);\r\nnf_ct_unexpect_related(exp);\r\nnf_ct_expect_put(exp);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pptp_destroy_siblings(struct nf_conn *ct)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nconst struct nf_conn_help *help = nfct_help(ct);\r\nstruct nf_conntrack_tuple t;\r\nnf_ct_gre_keymap_destroy(ct);\r\nmemcpy(&t, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple, sizeof(t));\r\nt.dst.protonum = IPPROTO_GRE;\r\nt.src.u.gre.key = help->help.ct_pptp_info.pns_call_id;\r\nt.dst.u.gre.key = help->help.ct_pptp_info.pac_call_id;\r\nif (!destroy_sibling_or_exp(net, ct, &t))\r\npr_debug("failed to timeout original pns->pac ct/exp\n");\r\nmemcpy(&t, &ct->tuplehash[IP_CT_DIR_REPLY].tuple, sizeof(t));\r\nt.dst.protonum = IPPROTO_GRE;\r\nt.src.u.gre.key = help->help.ct_pptp_info.pac_call_id;\r\nt.dst.u.gre.key = help->help.ct_pptp_info.pns_call_id;\r\nif (!destroy_sibling_or_exp(net, ct, &t))\r\npr_debug("failed to timeout reply pac->pns ct/exp\n");\r\n}\r\nstatic int exp_gre(struct nf_conn *ct, __be16 callid, __be16 peer_callid)\r\n{\r\nstruct nf_conntrack_expect *exp_orig, *exp_reply;\r\nenum ip_conntrack_dir dir;\r\nint ret = 1;\r\ntypeof(nf_nat_pptp_hook_exp_gre) nf_nat_pptp_exp_gre;\r\nexp_orig = nf_ct_expect_alloc(ct);\r\nif (exp_orig == NULL)\r\ngoto out;\r\nexp_reply = nf_ct_expect_alloc(ct);\r\nif (exp_reply == NULL)\r\ngoto out_put_orig;\r\ndir = IP_CT_DIR_ORIGINAL;\r\nnf_ct_expect_init(exp_orig, NF_CT_EXPECT_CLASS_DEFAULT,\r\nnf_ct_l3num(ct),\r\n&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[dir].tuple.dst.u3,\r\nIPPROTO_GRE, &peer_callid, &callid);\r\nexp_orig->expectfn = pptp_expectfn;\r\ndir = IP_CT_DIR_REPLY;\r\nnf_ct_expect_init(exp_reply, NF_CT_EXPECT_CLASS_DEFAULT,\r\nnf_ct_l3num(ct),\r\n&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[dir].tuple.dst.u3,\r\nIPPROTO_GRE, &callid, &peer_callid);\r\nexp_reply->expectfn = pptp_expectfn;\r\nnf_nat_pptp_exp_gre = rcu_dereference(nf_nat_pptp_hook_exp_gre);\r\nif (nf_nat_pptp_exp_gre && ct->status & IPS_NAT_MASK)\r\nnf_nat_pptp_exp_gre(exp_orig, exp_reply);\r\nif (nf_ct_expect_related(exp_orig) != 0)\r\ngoto out_put_both;\r\nif (nf_ct_expect_related(exp_reply) != 0)\r\ngoto out_unexpect_orig;\r\nif (nf_ct_gre_keymap_add(ct, IP_CT_DIR_ORIGINAL, &exp_orig->tuple) != 0)\r\ngoto out_unexpect_both;\r\nif (nf_ct_gre_keymap_add(ct, IP_CT_DIR_REPLY, &exp_reply->tuple) != 0) {\r\nnf_ct_gre_keymap_destroy(ct);\r\ngoto out_unexpect_both;\r\n}\r\nret = 0;\r\nout_put_both:\r\nnf_ct_expect_put(exp_reply);\r\nout_put_orig:\r\nnf_ct_expect_put(exp_orig);\r\nout:\r\nreturn ret;\r\nout_unexpect_both:\r\nnf_ct_unexpect_related(exp_reply);\r\nout_unexpect_orig:\r\nnf_ct_unexpect_related(exp_orig);\r\ngoto out_put_both;\r\n}\r\nstatic inline int\r\npptp_inbound_pkt(struct sk_buff *skb,\r\nstruct PptpControlHeader *ctlh,\r\nunion pptp_ctrl_union *pptpReq,\r\nunsigned int reqlen,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nstruct nf_ct_pptp_master *info = &nfct_help(ct)->help.ct_pptp_info;\r\nu_int16_t msg;\r\n__be16 cid = 0, pcid = 0;\r\ntypeof(nf_nat_pptp_hook_inbound) nf_nat_pptp_inbound;\r\nmsg = ntohs(ctlh->messageType);\r\npr_debug("inbound control message %s\n", pptp_msg_name[msg]);\r\nswitch (msg) {\r\ncase PPTP_START_SESSION_REPLY:\r\nif (info->sstate < PPTP_SESSION_REQUESTED)\r\ngoto invalid;\r\nif (pptpReq->srep.resultCode == PPTP_START_OK)\r\ninfo->sstate = PPTP_SESSION_CONFIRMED;\r\nelse\r\ninfo->sstate = PPTP_SESSION_ERROR;\r\nbreak;\r\ncase PPTP_STOP_SESSION_REPLY:\r\nif (info->sstate > PPTP_SESSION_STOPREQ)\r\ngoto invalid;\r\nif (pptpReq->strep.resultCode == PPTP_STOP_OK)\r\ninfo->sstate = PPTP_SESSION_NONE;\r\nelse\r\ninfo->sstate = PPTP_SESSION_ERROR;\r\nbreak;\r\ncase PPTP_OUT_CALL_REPLY:\r\nif (info->sstate != PPTP_SESSION_CONFIRMED)\r\ngoto invalid;\r\nif (info->cstate != PPTP_CALL_OUT_REQ &&\r\ninfo->cstate != PPTP_CALL_OUT_CONF)\r\ngoto invalid;\r\ncid = pptpReq->ocack.callID;\r\npcid = pptpReq->ocack.peersCallID;\r\nif (info->pns_call_id != pcid)\r\ngoto invalid;\r\npr_debug("%s, CID=%X, PCID=%X\n", pptp_msg_name[msg],\r\nntohs(cid), ntohs(pcid));\r\nif (pptpReq->ocack.resultCode == PPTP_OUTCALL_CONNECT) {\r\ninfo->cstate = PPTP_CALL_OUT_CONF;\r\ninfo->pac_call_id = cid;\r\nexp_gre(ct, cid, pcid);\r\n} else\r\ninfo->cstate = PPTP_CALL_NONE;\r\nbreak;\r\ncase PPTP_IN_CALL_REQUEST:\r\nif (info->sstate != PPTP_SESSION_CONFIRMED)\r\ngoto invalid;\r\ncid = pptpReq->icreq.callID;\r\npr_debug("%s, CID=%X\n", pptp_msg_name[msg], ntohs(cid));\r\ninfo->cstate = PPTP_CALL_IN_REQ;\r\ninfo->pac_call_id = cid;\r\nbreak;\r\ncase PPTP_IN_CALL_CONNECT:\r\nif (info->sstate != PPTP_SESSION_CONFIRMED)\r\ngoto invalid;\r\nif (info->cstate != PPTP_CALL_IN_REP &&\r\ninfo->cstate != PPTP_CALL_IN_CONF)\r\ngoto invalid;\r\npcid = pptpReq->iccon.peersCallID;\r\ncid = info->pac_call_id;\r\nif (info->pns_call_id != pcid)\r\ngoto invalid;\r\npr_debug("%s, PCID=%X\n", pptp_msg_name[msg], ntohs(pcid));\r\ninfo->cstate = PPTP_CALL_IN_CONF;\r\nexp_gre(ct, cid, pcid);\r\nbreak;\r\ncase PPTP_CALL_DISCONNECT_NOTIFY:\r\ncid = pptpReq->disc.callID;\r\npr_debug("%s, CID=%X\n", pptp_msg_name[msg], ntohs(cid));\r\ninfo->cstate = PPTP_CALL_NONE;\r\npptp_destroy_siblings(ct);\r\nbreak;\r\ncase PPTP_WAN_ERROR_NOTIFY:\r\ncase PPTP_SET_LINK_INFO:\r\ncase PPTP_ECHO_REQUEST:\r\ncase PPTP_ECHO_REPLY:\r\nbreak;\r\ndefault:\r\ngoto invalid;\r\n}\r\nnf_nat_pptp_inbound = rcu_dereference(nf_nat_pptp_hook_inbound);\r\nif (nf_nat_pptp_inbound && ct->status & IPS_NAT_MASK)\r\nreturn nf_nat_pptp_inbound(skb, ct, ctinfo, ctlh, pptpReq);\r\nreturn NF_ACCEPT;\r\ninvalid:\r\npr_debug("invalid %s: type=%d cid=%u pcid=%u "\r\n"cstate=%d sstate=%d pns_cid=%u pac_cid=%u\n",\r\nmsg <= PPTP_MSG_MAX ? pptp_msg_name[msg] : pptp_msg_name[0],\r\nmsg, ntohs(cid), ntohs(pcid), info->cstate, info->sstate,\r\nntohs(info->pns_call_id), ntohs(info->pac_call_id));\r\nreturn NF_ACCEPT;\r\n}\r\nstatic inline int\r\npptp_outbound_pkt(struct sk_buff *skb,\r\nstruct PptpControlHeader *ctlh,\r\nunion pptp_ctrl_union *pptpReq,\r\nunsigned int reqlen,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nstruct nf_ct_pptp_master *info = &nfct_help(ct)->help.ct_pptp_info;\r\nu_int16_t msg;\r\n__be16 cid = 0, pcid = 0;\r\ntypeof(nf_nat_pptp_hook_outbound) nf_nat_pptp_outbound;\r\nmsg = ntohs(ctlh->messageType);\r\npr_debug("outbound control message %s\n", pptp_msg_name[msg]);\r\nswitch (msg) {\r\ncase PPTP_START_SESSION_REQUEST:\r\nif (info->sstate != PPTP_SESSION_NONE)\r\ngoto invalid;\r\ninfo->sstate = PPTP_SESSION_REQUESTED;\r\nbreak;\r\ncase PPTP_STOP_SESSION_REQUEST:\r\ninfo->sstate = PPTP_SESSION_STOPREQ;\r\nbreak;\r\ncase PPTP_OUT_CALL_REQUEST:\r\nif (info->sstate != PPTP_SESSION_CONFIRMED)\r\ngoto invalid;\r\ninfo->cstate = PPTP_CALL_OUT_REQ;\r\ncid = pptpReq->ocreq.callID;\r\npr_debug("%s, CID=%X\n", pptp_msg_name[msg], ntohs(cid));\r\ninfo->pns_call_id = cid;\r\nbreak;\r\ncase PPTP_IN_CALL_REPLY:\r\nif (info->cstate != PPTP_CALL_IN_REQ &&\r\ninfo->cstate != PPTP_CALL_IN_REP)\r\ngoto invalid;\r\ncid = pptpReq->icack.callID;\r\npcid = pptpReq->icack.peersCallID;\r\nif (info->pac_call_id != pcid)\r\ngoto invalid;\r\npr_debug("%s, CID=%X PCID=%X\n", pptp_msg_name[msg],\r\nntohs(cid), ntohs(pcid));\r\nif (pptpReq->icack.resultCode == PPTP_INCALL_ACCEPT) {\r\ninfo->cstate = PPTP_CALL_IN_REP;\r\ninfo->pns_call_id = cid;\r\n} else\r\ninfo->cstate = PPTP_CALL_NONE;\r\nbreak;\r\ncase PPTP_CALL_CLEAR_REQUEST:\r\nif (info->sstate != PPTP_SESSION_CONFIRMED)\r\ngoto invalid;\r\ninfo->cstate = PPTP_CALL_CLEAR_REQ;\r\nbreak;\r\ncase PPTP_SET_LINK_INFO:\r\ncase PPTP_ECHO_REQUEST:\r\ncase PPTP_ECHO_REPLY:\r\nbreak;\r\ndefault:\r\ngoto invalid;\r\n}\r\nnf_nat_pptp_outbound = rcu_dereference(nf_nat_pptp_hook_outbound);\r\nif (nf_nat_pptp_outbound && ct->status & IPS_NAT_MASK)\r\nreturn nf_nat_pptp_outbound(skb, ct, ctinfo, ctlh, pptpReq);\r\nreturn NF_ACCEPT;\r\ninvalid:\r\npr_debug("invalid %s: type=%d cid=%u pcid=%u "\r\n"cstate=%d sstate=%d pns_cid=%u pac_cid=%u\n",\r\nmsg <= PPTP_MSG_MAX ? pptp_msg_name[msg] : pptp_msg_name[0],\r\nmsg, ntohs(cid), ntohs(pcid), info->cstate, info->sstate,\r\nntohs(info->pns_call_id), ntohs(info->pac_call_id));\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int\r\nconntrack_pptp_help(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nconst struct nf_ct_pptp_master *info = &nfct_help(ct)->help.ct_pptp_info;\r\nconst struct tcphdr *tcph;\r\nstruct tcphdr _tcph;\r\nconst struct pptp_pkt_hdr *pptph;\r\nstruct pptp_pkt_hdr _pptph;\r\nstruct PptpControlHeader _ctlh, *ctlh;\r\nunion pptp_ctrl_union _pptpReq, *pptpReq;\r\nunsigned int tcplen = skb->len - protoff;\r\nunsigned int datalen, reqlen, nexthdr_off;\r\nint oldsstate, oldcstate;\r\nint ret;\r\nu_int16_t msg;\r\nif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\r\nreturn NF_ACCEPT;\r\nnexthdr_off = protoff;\r\ntcph = skb_header_pointer(skb, nexthdr_off, sizeof(_tcph), &_tcph);\r\nBUG_ON(!tcph);\r\nnexthdr_off += tcph->doff * 4;\r\ndatalen = tcplen - tcph->doff * 4;\r\npptph = skb_header_pointer(skb, nexthdr_off, sizeof(_pptph), &_pptph);\r\nif (!pptph) {\r\npr_debug("no full PPTP header, can't track\n");\r\nreturn NF_ACCEPT;\r\n}\r\nnexthdr_off += sizeof(_pptph);\r\ndatalen -= sizeof(_pptph);\r\nif (ntohs(pptph->packetType) != PPTP_PACKET_CONTROL ||\r\nntohl(pptph->magicCookie) != PPTP_MAGIC_COOKIE) {\r\npr_debug("not a control packet\n");\r\nreturn NF_ACCEPT;\r\n}\r\nctlh = skb_header_pointer(skb, nexthdr_off, sizeof(_ctlh), &_ctlh);\r\nif (!ctlh)\r\nreturn NF_ACCEPT;\r\nnexthdr_off += sizeof(_ctlh);\r\ndatalen -= sizeof(_ctlh);\r\nreqlen = datalen;\r\nmsg = ntohs(ctlh->messageType);\r\nif (msg > 0 && msg <= PPTP_MSG_MAX && reqlen < pptp_msg_size[msg])\r\nreturn NF_ACCEPT;\r\nif (reqlen > sizeof(*pptpReq))\r\nreqlen = sizeof(*pptpReq);\r\npptpReq = skb_header_pointer(skb, nexthdr_off, reqlen, &_pptpReq);\r\nif (!pptpReq)\r\nreturn NF_ACCEPT;\r\noldsstate = info->sstate;\r\noldcstate = info->cstate;\r\nspin_lock_bh(&nf_pptp_lock);\r\nif (dir == IP_CT_DIR_ORIGINAL)\r\nret = pptp_outbound_pkt(skb, ctlh, pptpReq, reqlen, ct,\r\nctinfo);\r\nelse\r\nret = pptp_inbound_pkt(skb, ctlh, pptpReq, reqlen, ct,\r\nctinfo);\r\npr_debug("sstate: %d->%d, cstate: %d->%d\n",\r\noldsstate, info->sstate, oldcstate, info->cstate);\r\nspin_unlock_bh(&nf_pptp_lock);\r\nreturn ret;\r\n}\r\nstatic void nf_conntrack_pptp_net_exit(struct net *net)\r\n{\r\nnf_ct_gre_keymap_flush(net);\r\n}\r\nstatic int __init nf_conntrack_pptp_init(void)\r\n{\r\nint rv;\r\nrv = nf_conntrack_helper_register(&pptp);\r\nif (rv < 0)\r\nreturn rv;\r\nrv = register_pernet_subsys(&nf_conntrack_pptp_net_ops);\r\nif (rv < 0)\r\nnf_conntrack_helper_unregister(&pptp);\r\nreturn rv;\r\n}\r\nstatic void __exit nf_conntrack_pptp_fini(void)\r\n{\r\nnf_conntrack_helper_unregister(&pptp);\r\nunregister_pernet_subsys(&nf_conntrack_pptp_net_ops);\r\n}
