static int mips_next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long flags;\r\nunsigned int mtflags;\r\nunsigned long timestamp, reference, previous;\r\nunsigned long nextcomp = 0L;\r\nint vpe = current_cpu_data.vpe_id;\r\nint cpu = smp_processor_id();\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nreference = (unsigned long)read_c0_count();\r\ntimestamp = MAKEVALID(reference + delta);\r\nprevious = smtc_nexttime[vpe][cpu];\r\nif (cpu == smtc_nextinvpe[vpe] && ISVALID(previous)\r\n&& IS_SOONER(previous, timestamp, reference)) {\r\nint i;\r\nint soonest = cpu;\r\nsmtc_nexttime[vpe][cpu] = timestamp;\r\nfor_each_online_cpu(i) {\r\nif (ISVALID(smtc_nexttime[vpe][i])\r\n&& IS_SOONER(smtc_nexttime[vpe][i],\r\nsmtc_nexttime[vpe][soonest], reference)) {\r\nsoonest = i;\r\n}\r\n}\r\nsmtc_nextinvpe[vpe] = soonest;\r\nnextcomp = smtc_nexttime[vpe][soonest];\r\n} else {\r\nif (!ISVALID(smtc_nexttime[vpe][smtc_nextinvpe[vpe]]) ||\r\nIS_SOONER(timestamp,\r\nsmtc_nexttime[vpe][smtc_nextinvpe[vpe]], reference)) {\r\nsmtc_nextinvpe[vpe] = cpu;\r\nnextcomp = timestamp;\r\n}\r\nsmtc_nexttime[vpe][cpu] = timestamp;\r\n}\r\nif (ISVALID(nextcomp)) {\r\nwrite_c0_compare(nextcomp);\r\nehb();\r\nwhile ((nextcomp - (unsigned long)read_c0_count())\r\n> (unsigned long)LONG_MAX) {\r\nnextcomp += CATCHUP_INCREMENT;\r\nwrite_c0_compare(nextcomp);\r\nehb();\r\n}\r\n}\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nvoid smtc_distribute_timer(int vpe)\r\n{\r\nunsigned long flags;\r\nunsigned int mtflags;\r\nint cpu;\r\nstruct clock_event_device *cd;\r\nunsigned long nextstamp;\r\nunsigned long reference;\r\nrepeat:\r\nnextstamp = 0L;\r\nfor_each_online_cpu(cpu) {\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nif (cpu_data[cpu].vpe_id == vpe &&\r\nISVALID(smtc_nexttime[vpe][cpu])) {\r\nreference = (unsigned long)read_c0_count();\r\nif ((smtc_nexttime[vpe][cpu] - reference)\r\n> (unsigned long)LONG_MAX) {\r\nsmtc_nexttime[vpe][cpu] = 0L;\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\nif (cpu != smp_processor_id()) {\r\nsmtc_send_ipi(cpu, SMTC_CLOCK_TICK, 0);\r\n} else {\r\ncd = &per_cpu(mips_clockevent_device, cpu);\r\ncd->event_handler(cd);\r\n}\r\n} else {\r\nif (!ISVALID(nextstamp) ||\r\nIS_SOONER(smtc_nexttime[vpe][cpu], nextstamp,\r\nreference)) {\r\nsmtc_nextinvpe[vpe] = cpu;\r\nnextstamp = smtc_nexttime[vpe][cpu];\r\n}\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\n}\r\n} else {\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nif (ISVALID(nextstamp)) {\r\nwrite_c0_compare(nextstamp);\r\nehb();\r\nif ((nextstamp - (unsigned long)read_c0_count())\r\n> (unsigned long)LONG_MAX)\r\ngoto repeat;\r\n}\r\n}\r\nirqreturn_t c0_compare_interrupt(int irq, void *dev_id)\r\n{\r\nint cpu = smp_processor_id();\r\nhandle_perf_irq(1);\r\nif (read_c0_cause() & (1 << 30)) {\r\nwrite_c0_compare(read_c0_compare());\r\nsmtc_distribute_timer(cpu_data[cpu].vpe_id);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint __cpuinit smtc_clockevent_init(void)\r\n{\r\nuint64_t mips_freq = mips_hpt_frequency;\r\nunsigned int cpu = smp_processor_id();\r\nstruct clock_event_device *cd;\r\nunsigned int irq;\r\nint i;\r\nint j;\r\nif (!cpu_has_counter || !mips_hpt_frequency)\r\nreturn -ENXIO;\r\nif (cpu == 0) {\r\nfor (i = 0; i < num_possible_cpus(); i++) {\r\nsmtc_nextinvpe[i] = 0;\r\nfor (j = 0; j < num_possible_cpus(); j++)\r\nsmtc_nexttime[i][j] = 0L;\r\n}\r\nif (!c0_compare_int_usable())\r\nreturn -ENXIO;\r\n}\r\nirq = MIPS_CPU_IRQ_BASE + cp0_compare_irq;\r\nif (get_c0_compare_int)\r\nirq = get_c0_compare_int();\r\ncd = &per_cpu(mips_clockevent_device, cpu);\r\ncd->name = "MIPS";\r\ncd->features = CLOCK_EVT_FEAT_ONESHOT;\r\ncd->mult = div_sc((unsigned long) mips_freq, NSEC_PER_SEC, 32);\r\ncd->shift = 32;\r\ncd->max_delta_ns = clockevent_delta2ns(0x7fffffff, cd);\r\ncd->min_delta_ns = clockevent_delta2ns(0x300, cd);\r\ncd->rating = 300;\r\ncd->irq = irq;\r\ncd->cpumask = cpumask_of(cpu);\r\ncd->set_next_event = mips_next_event;\r\ncd->set_mode = mips_set_clock_mode;\r\ncd->event_handler = mips_event_handler;\r\nclockevents_register_device(cd);\r\nif (cpu)\r\nreturn 0;\r\nirq_hwmask[irq] = (0x100 << cp0_compare_irq);\r\nif (cp0_timer_irq_installed)\r\nreturn 0;\r\ncp0_timer_irq_installed = 1;\r\nsetup_irq(irq, &c0_compare_irqaction);\r\nreturn 0;\r\n}
