static inline unsigned int dac_convert_reg(unsigned int channel)\r\n{\r\nreturn 0x70 + (2 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int dac_lsb_4020_reg(unsigned int channel)\r\n{\r\nreturn 0x70 + (4 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int dac_msb_4020_reg(unsigned int channel)\r\n{\r\nreturn 0x72 + (4 * (channel & 0x1));\r\n}\r\nstatic inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)\r\n{\r\nreturn threshold & 0xfff;\r\n}\r\nstatic inline uint16_t adc_lo_chan_4020_bits(unsigned int channel)\r\n{\r\nreturn (channel & 0x3) << 8;\r\n}\r\nstatic inline uint16_t adc_hi_chan_4020_bits(unsigned int channel)\r\n{\r\nreturn (channel & 0x3) << 10;\r\n}\r\nstatic inline uint16_t adc_mode_bits(unsigned int mode)\r\n{\r\nreturn (mode & 0xf) << 12;\r\n}\r\nstatic inline uint16_t adc_src_bits(unsigned int source)\r\n{\r\nreturn (source & 0xf) << 3;\r\n}\r\nstatic inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)\r\n{\r\nreturn (channel & 0x3) << 8;\r\n}\r\nstatic inline uint16_t adc_chan_bits(unsigned int channel)\r\n{\r\nreturn channel & 0x3f;\r\n}\r\nstatic inline uint16_t pipe_full_bits(uint16_t hw_status_bits)\r\n{\r\nreturn (hw_status_bits >> 10) & 0x3;\r\n}\r\nstatic inline unsigned int dma_chain_flag_bits(uint16_t prepost_bits)\r\n{\r\nreturn (prepost_bits >> 6) & 0x3;\r\n}\r\nstatic inline unsigned int adc_upper_read_ptr_code(uint16_t prepost_bits)\r\n{\r\nreturn (prepost_bits >> 12) & 0x3;\r\n}\r\nstatic inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)\r\n{\r\nreturn (prepost_bits >> 14) & 0x3;\r\n}\r\nstatic inline uint8_t adc_src_4020_bits(unsigned int source)\r\n{\r\nreturn (source << 4) & ADC_SRC_4020_MASK;\r\n}\r\nstatic inline uint8_t attenuate_bit(unsigned int channel)\r\n{\r\nreturn 1 << (channel & 0x3);\r\n}\r\nstatic inline unsigned int ai_dma_ring_count(struct pcidas64_board *board)\r\n{\r\nif (board->layout == LAYOUT_4020)\r\nreturn MAX_AI_DMA_RING_COUNT;\r\nelse\r\nreturn MIN_AI_DMA_RING_COUNT;\r\n}\r\nstatic inline struct pcidas64_board *board(const struct comedi_device *dev)\r\n{\r\nreturn (struct pcidas64_board *)dev->board_ptr;\r\n}\r\nstatic inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,\r\nint use_differential)\r\n{\r\nif ((board(dev)->layout == LAYOUT_64XX && !use_differential) ||\r\n(board(dev)->layout == LAYOUT_60XX && use_differential))\r\nreturn ADC_SE_DIFF_BIT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline struct pcidas64_private *priv(struct comedi_device *dev)\r\n{\r\nreturn dev->private;\r\n}\r\nstatic int __devinit driver_cb_pcidas_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_cb_pcidas.driver_name);\r\n}\r\nstatic void __devexit driver_cb_pcidas_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_cb_pcidas_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_cb_pcidas);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_cb_pcidas_pci_driver.name = (char *)driver_cb_pcidas.driver_name;\r\nreturn pci_register_driver(&driver_cb_pcidas_pci_driver);\r\n}\r\nstatic void __exit driver_cb_pcidas_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_cb_pcidas_pci_driver);\r\ncomedi_driver_unregister(&driver_cb_pcidas);\r\n}\r\nstatic unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,\r\nunsigned int range_index)\r\n{\r\nconst struct comedi_krange *range =\r\n&board(dev)->ai_range_table->range[range_index];\r\nunsigned int bits = 0;\r\nswitch (range->max) {\r\ncase 10000000:\r\nbits = 0x000;\r\nbreak;\r\ncase 5000000:\r\nbits = 0x100;\r\nbreak;\r\ncase 2000000:\r\ncase 2500000:\r\nbits = 0x200;\r\nbreak;\r\ncase 1000000:\r\ncase 1250000:\r\nbits = 0x300;\r\nbreak;\r\ncase 500000:\r\nbits = 0x400;\r\nbreak;\r\ncase 200000:\r\ncase 250000:\r\nbits = 0x500;\r\nbreak;\r\ncase 100000:\r\nbits = 0x600;\r\nbreak;\r\ncase 50000:\r\nbits = 0x700;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "bug! in ai_range_bits_6xxx");\r\nbreak;\r\n}\r\nif (range->min == 0)\r\nbits += 0x900;\r\nreturn bits;\r\n}\r\nstatic unsigned int hw_revision(const struct comedi_device *dev,\r\nuint16_t hw_status_bits)\r\n{\r\nif (board(dev)->layout == LAYOUT_4020)\r\nreturn (hw_status_bits >> 13) & 0x7;\r\nreturn (hw_status_bits >> 12) & 0xf;\r\n}\r\nstatic void set_dac_range_bits(struct comedi_device *dev,\r\nvolatile uint16_t * bits, unsigned int channel,\r\nunsigned int range)\r\n{\r\nunsigned int code = board(dev)->ao_range_code[range];\r\nif (channel > 1)\r\ncomedi_error(dev, "bug! bad channel?");\r\nif (code & ~0x3)\r\ncomedi_error(dev, "bug! bad range code?");\r\n*bits &= ~(0x3 << (2 * channel));\r\n*bits |= code << (2 * channel);\r\n}\r\nstatic inline int ao_cmd_is_supported(const struct pcidas64_board *board)\r\n{\r\nreturn board->ao_nchan && board->layout != LAYOUT_4020;\r\n}\r\nstatic void init_plx9080(struct comedi_device *dev)\r\n{\r\nuint32_t bits;\r\nvoid __iomem *plx_iobase = priv(dev)->plx9080_iobase;\r\npriv(dev)->plx_control_bits =\r\nreadl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG);\r\nDEBUG_PRINT(" plx interrupt status 0x%x\n",\r\nreadl(plx_iobase + PLX_INTRCS_REG));\r\nDEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));\r\nDEBUG_PRINT(" plx control reg 0x%x\n", priv(dev)->plx_control_bits);\r\nDEBUG_PRINT(" plx mode/arbitration reg 0x%x\n",\r\nreadl(plx_iobase + PLX_MARB_REG));\r\nDEBUG_PRINT(" plx region0 reg 0x%x\n",\r\nreadl(plx_iobase + PLX_REGION0_REG));\r\nDEBUG_PRINT(" plx region1 reg 0x%x\n",\r\nreadl(plx_iobase + PLX_REGION1_REG));\r\nDEBUG_PRINT(" plx revision 0x%x\n",\r\nreadl(plx_iobase + PLX_REVISION_REG));\r\nDEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_MODE_REG));\r\nDEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA1_MODE_REG));\r\nDEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));\r\nDEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));\r\nDEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",\r\nreadb(plx_iobase + PLX_DMA0_CS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_THRESHOLD_REG));\r\nDEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));\r\n#ifdef __BIG_ENDIAN\r\nbits = BIGEND_DMA0 | BIGEND_DMA1;\r\n#else\r\nbits = 0;\r\n#endif\r\nwritel(bits, priv(dev)->plx9080_iobase + PLX_BIGEND_REG);\r\ndisable_plx_interrupts(dev);\r\nabort_dma(dev, 0);\r\nabort_dma(dev, 1);\r\nbits = 0;\r\nbits |= PLX_DMA_EN_READYIN_BIT;\r\nbits |= PLX_EN_BTERM_BIT;\r\nbits |= PLX_EN_CHAIN_BIT;\r\nbits |= PLX_EN_DMA_DONE_INTR_BIT;\r\nbits |= PLX_LOCAL_ADDR_CONST_BIT;\r\nbits |= PLX_DMA_INTR_PCI_BIT;\r\nbits |= PLX_DEMAND_MODE_BIT;\r\nbits |= PLX_DMA_LOCAL_BURST_EN_BIT;\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nbits |= PLX_LOCAL_BUS_32_WIDE_BITS;\r\n} else {\r\nbits |= PLX_LOCAL_BUS_16_WIDE_BITS;\r\n}\r\nwritel(bits, plx_iobase + PLX_DMA1_MODE_REG);\r\nif (ao_cmd_is_supported(board(dev)))\r\nwritel(bits, plx_iobase + PLX_DMA0_MODE_REG);\r\npriv(dev)->plx_intcsr_bits |=\r\nICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |\r\nICS_DMA0_E | ICS_DMA1_E;\r\nwritel(priv(dev)->plx_intcsr_bits,\r\npriv(dev)->plx9080_iobase + PLX_INTRCS_REG);\r\n}\r\nstatic int setup_subdevices(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nvoid __iomem *dio_8255_iobase;\r\nint i;\r\nif (alloc_subdevices(dev, 10) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;\r\nif (board(dev)->layout == LAYOUT_60XX)\r\ns->subdev_flags |= SDF_COMMON | SDF_DIFF;\r\nelse if (board(dev)->layout == LAYOUT_64XX)\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = board(dev)->ai_se_chans;\r\ns->len_chanlist = 0x2000;\r\ns->maxdata = (1 << board(dev)->ai_bits) - 1;\r\ns->range_table = board(dev)->ai_range_table;\r\ns->insn_read = ai_rinsn;\r\ns->insn_config = ai_config_insn;\r\ns->do_cmd = ai_cmd;\r\ns->do_cmdtest = ai_cmdtest;\r\ns->cancel = ai_cancel;\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nuint8_t data;\r\npriv(dev)->i2c_cal_range_bits = adc_src_4020_bits(4);\r\nfor (i = 0; i < s->n_chan; i++)\r\npriv(dev)->i2c_cal_range_bits |= attenuate_bit(i);\r\ndata = priv(dev)->i2c_cal_range_bits;\r\ni2c_write(dev, RANGE_CAL_I2C_ADDR, &data, sizeof(data));\r\n}\r\ns = dev->subdevices + 1;\r\nif (board(dev)->ao_nchan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\r\ns->n_chan = board(dev)->ao_nchan;\r\ns->maxdata = (1 << board(dev)->ao_bits) - 1;\r\ns->range_table = board(dev)->ao_range_table;\r\ns->insn_read = ao_readback_insn;\r\ns->insn_write = ao_winsn;\r\nif (ao_cmd_is_supported(board(dev))) {\r\ndev->write_subdev = s;\r\ns->do_cmdtest = ao_cmdtest;\r\ns->do_cmd = ao_cmd;\r\ns->len_chanlist = board(dev)->ao_nchan;\r\ns->cancel = ao_cancel;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 2;\r\nif (board(dev)->layout == LAYOUT_64XX) {\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = di_rbits;\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\nif (board(dev)->layout == LAYOUT_64XX) {\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = do_wbits;\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = dev->subdevices + 4;\r\nif (board(dev)->has_8255) {\r\nif (board(dev)->layout == LAYOUT_4020) {\r\ndio_8255_iobase =\r\npriv(dev)->main_iobase + I8255_4020_REG;\r\nsubdev_8255_init(dev, s, dio_callback_4020,\r\n(unsigned long)dio_8255_iobase);\r\n} else {\r\ndio_8255_iobase =\r\npriv(dev)->dio_counter_iobase + DIO_8255_OFFSET;\r\nsubdev_8255_init(dev, s, dio_callback,\r\n(unsigned long)dio_8255_iobase);\r\n}\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = dev->subdevices + 5;\r\nif (board(dev)->layout == LAYOUT_60XX) {\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_config = dio_60xx_config_insn;\r\ns->insn_bits = dio_60xx_wbits;\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = dev->subdevices + 6;\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 8;\r\nif (board(dev)->layout == LAYOUT_4020)\r\ns->maxdata = 0xfff;\r\nelse\r\ns->maxdata = 0xff;\r\ns->insn_read = calib_read_insn;\r\ns->insn_write = calib_write_insn;\r\nfor (i = 0; i < s->n_chan; i++)\r\ncaldac_write(dev, i, s->maxdata / 2);\r\ns = dev->subdevices + 7;\r\nif (board(dev)->layout == LAYOUT_64XX) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 2;\r\ns->insn_read = ad8402_read_insn;\r\ns->insn_write = ad8402_write_insn;\r\ns->maxdata = 0xff;\r\nfor (i = 0; i < s->n_chan; i++)\r\nad8402_write(dev, i, s->maxdata / 2);\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = dev->subdevices + 8;\r\nif (readl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_INTERNAL;\r\ns->n_chan = 128;\r\ns->maxdata = 0xffff;\r\ns->insn_read = eeprom_read_insn;\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = dev->subdevices + 9;\r\ns->type = COMEDI_SUBD_UNUSED;\r\nreturn 0;\r\n}\r\nstatic void disable_plx_interrupts(struct comedi_device *dev)\r\n{\r\npriv(dev)->plx_intcsr_bits = 0;\r\nwritel(priv(dev)->plx_intcsr_bits,\r\npriv(dev)->plx9080_iobase + PLX_INTRCS_REG);\r\n}\r\nstatic void init_stc_registers(struct comedi_device *dev)\r\n{\r\nuint16_t bits;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (1)\r\npriv(dev)->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;\r\nwritew(priv(dev)->adc_control1_bits,\r\npriv(dev)->main_iobase + ADC_CONTROL1_REG);\r\nwritew(0xff, priv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\r\nbits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;\r\nif (board(dev)->layout == LAYOUT_4020)\r\nbits |= INTERNAL_CLOCK_4020_BITS;\r\npriv(dev)->hw_config_bits |= bits;\r\nwritew(priv(dev)->hw_config_bits,\r\npriv(dev)->main_iobase + HW_CONFIG_REG);\r\nwritew(0, priv(dev)->main_iobase + DAQ_SYNC_REG);\r\nwritew(0, priv(dev)->main_iobase + CALIBRATION_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\npriv(dev)->fifo_size_bits |= DAC_FIFO_BITS;\r\nset_ai_fifo_segment_length(dev,\r\nboard(dev)->ai_fifo->max_segment_length);\r\npriv(dev)->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;\r\npriv(dev)->intr_enable_bits =\r\nEN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;\r\nwritew(priv(dev)->intr_enable_bits,\r\npriv(dev)->main_iobase + INTR_ENABLE_REG);\r\ndisable_ai_pacing(dev);\r\n}\r\nstatic int alloc_and_init_dma_members(struct comedi_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ai_dma_ring_count(board(dev)); i++) {\r\npriv(dev)->ai_buffer[i] =\r\npci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,\r\n&priv(dev)->ai_buffer_bus_addr[i]);\r\nif (priv(dev)->ai_buffer[i] == NULL)\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\r\nif (ao_cmd_is_supported(board(dev))) {\r\npriv(dev)->ao_buffer[i] =\r\npci_alloc_consistent(priv(dev)->hw_dev,\r\nDMA_BUFFER_SIZE,\r\n&priv(dev)->\r\nao_buffer_bus_addr[i]);\r\nif (priv(dev)->ao_buffer[i] == NULL)\r\nreturn -ENOMEM;\r\n}\r\n}\r\npriv(dev)->ai_dma_desc =\r\npci_alloc_consistent(priv(dev)->hw_dev,\r\nsizeof(struct plx_dma_desc) *\r\nai_dma_ring_count(board(dev)),\r\n&priv(dev)->ai_dma_desc_bus_addr);\r\nif (priv(dev)->ai_dma_desc == NULL)\r\nreturn -ENOMEM;\r\nDEBUG_PRINT("ai dma descriptors start at bus addr 0x%x\n",\r\npriv(dev)->ai_dma_desc_bus_addr);\r\nif (ao_cmd_is_supported(board(dev))) {\r\npriv(dev)->ao_dma_desc =\r\npci_alloc_consistent(priv(dev)->hw_dev,\r\nsizeof(struct plx_dma_desc) *\r\nAO_DMA_RING_COUNT,\r\n&priv(dev)->ao_dma_desc_bus_addr);\r\nif (priv(dev)->ao_dma_desc == NULL)\r\nreturn -ENOMEM;\r\nDEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",\r\npriv(dev)->ao_dma_desc_bus_addr);\r\n}\r\nfor (i = 0; i < ai_dma_ring_count(board(dev)); i++) {\r\npriv(dev)->ai_dma_desc[i].pci_start_addr =\r\ncpu_to_le32(priv(dev)->ai_buffer_bus_addr[i]);\r\nif (board(dev)->layout == LAYOUT_4020)\r\npriv(dev)->ai_dma_desc[i].local_start_addr =\r\ncpu_to_le32(priv(dev)->local1_iobase +\r\nADC_FIFO_REG);\r\nelse\r\npriv(dev)->ai_dma_desc[i].local_start_addr =\r\ncpu_to_le32(priv(dev)->local0_iobase +\r\nADC_FIFO_REG);\r\npriv(dev)->ai_dma_desc[i].transfer_size = cpu_to_le32(0);\r\npriv(dev)->ai_dma_desc[i].next =\r\ncpu_to_le32((priv(dev)->ai_dma_desc_bus_addr + ((i +\r\n1) %\r\nai_dma_ring_count\r\n(board\r\n(dev))) *\r\nsizeof(priv(dev)->ai_dma_desc[0])) |\r\nPLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |\r\nPLX_XFER_LOCAL_TO_PCI);\r\n}\r\nif (ao_cmd_is_supported(board(dev))) {\r\nfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\r\npriv(dev)->ao_dma_desc[i].pci_start_addr =\r\ncpu_to_le32(priv(dev)->ao_buffer_bus_addr[i]);\r\npriv(dev)->ao_dma_desc[i].local_start_addr =\r\ncpu_to_le32(priv(dev)->local0_iobase +\r\nDAC_FIFO_REG);\r\npriv(dev)->ao_dma_desc[i].transfer_size =\r\ncpu_to_le32(0);\r\npriv(dev)->ao_dma_desc[i].next =\r\ncpu_to_le32((priv(dev)->ao_dma_desc_bus_addr +\r\n((i + 1) % (AO_DMA_RING_COUNT)) *\r\nsizeof(priv(dev)->ao_dma_desc[0])) |\r\nPLX_DESC_IN_PCI_BIT |\r\nPLX_INTR_TERM_COUNT);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void warn_external_queue(struct comedi_device *dev)\r\n{\r\ncomedi_error(dev,\r\n"AO command and AI external channel queue cannot be used simultaneously.");\r\ncomedi_error(dev,\r\n"Use internal AI channel queue (channels must be consecutive and use same range/aref)");\r\n}\r\nstatic int attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct pci_dev *pcidev = NULL;\r\nint index;\r\nuint32_t local_range, local_decode;\r\nint retval;\r\nprintk("comedi%d: cb_pcidas64\n", dev->minor);\r\nif (alloc_private(dev, sizeof(struct pcidas64_private)) < 0)\r\nreturn -ENOMEM;\r\nfor_each_pci_dev(pcidev) {\r\nif (pcidev->vendor != PCI_VENDOR_ID_COMPUTERBOARDS)\r\ncontinue;\r\nfor (index = 0; index < ARRAY_SIZE(pcidas64_boards); index++) {\r\nif (pcidas64_boards[index].device_id != pcidev->device)\r\ncontinue;\r\nif (it->options[0] || it->options[1]) {\r\nif (pcidev->bus->number != it->options[0] ||\r\nPCI_SLOT(pcidev->devfn) != it->options[1]) {\r\ncontinue;\r\n}\r\n}\r\npriv(dev)->hw_dev = pcidev;\r\ndev->board_ptr = pcidas64_boards + index;\r\nbreak;\r\n}\r\nif (dev->board_ptr)\r\nbreak;\r\n}\r\nif (dev->board_ptr == NULL) {\r\nprintk\r\n("No supported ComputerBoards/MeasurementComputing card found\n");\r\nreturn -EIO;\r\n}\r\nprintk("Found %s on bus %i, slot %i\n", board(dev)->name,\r\npcidev->bus->number, PCI_SLOT(pcidev->devfn));\r\nif (comedi_pci_enable(pcidev, driver_cb_pcidas.driver_name)) {\r\nprintk(KERN_WARNING\r\n" failed to enable PCI device and request regions\n");\r\nreturn -EIO;\r\n}\r\npci_set_master(pcidev);\r\ndev->board_name = board(dev)->name;\r\npriv(dev)->plx9080_phys_iobase =\r\npci_resource_start(pcidev, PLX9080_BADDRINDEX);\r\npriv(dev)->main_phys_iobase =\r\npci_resource_start(pcidev, MAIN_BADDRINDEX);\r\npriv(dev)->dio_counter_phys_iobase =\r\npci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);\r\npriv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,\r\npci_resource_len(pcidev,\r\nPLX9080_BADDRINDEX));\r\npriv(dev)->main_iobase =\r\nioremap(priv(dev)->main_phys_iobase,\r\npci_resource_len(pcidev, MAIN_BADDRINDEX));\r\npriv(dev)->dio_counter_iobase =\r\nioremap(priv(dev)->dio_counter_phys_iobase,\r\npci_resource_len(pcidev, DIO_COUNTER_BADDRINDEX));\r\nif (!priv(dev)->plx9080_iobase || !priv(dev)->main_iobase\r\n|| !priv(dev)->dio_counter_iobase) {\r\nprintk(" failed to remap io memory\n");\r\nreturn -ENOMEM;\r\n}\r\nDEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);\r\nDEBUG_PRINT(" main remapped to 0x%p\n", priv(dev)->main_iobase);\r\nDEBUG_PRINT(" diocounter remapped to 0x%p\n",\r\npriv(dev)->dio_counter_iobase);\r\nlocal_range =\r\nreadl(priv(dev)->plx9080_iobase + PLX_LAS0RNG_REG) & LRNG_MEM_MASK;\r\nlocal_decode =\r\nreadl(priv(dev)->plx9080_iobase +\r\nPLX_LAS0MAP_REG) & local_range & LMAP_MEM_MASK;\r\npriv(dev)->local0_iobase =\r\n((uint32_t) priv(dev)->main_phys_iobase & ~local_range) |\r\nlocal_decode;\r\nlocal_range =\r\nreadl(priv(dev)->plx9080_iobase + PLX_LAS1RNG_REG) & LRNG_MEM_MASK;\r\nlocal_decode =\r\nreadl(priv(dev)->plx9080_iobase +\r\nPLX_LAS1MAP_REG) & local_range & LMAP_MEM_MASK;\r\npriv(dev)->local1_iobase =\r\n((uint32_t) priv(dev)->dio_counter_phys_iobase & ~local_range) |\r\nlocal_decode;\r\nDEBUG_PRINT(" local 0 io addr 0x%x\n", priv(dev)->local0_iobase);\r\nDEBUG_PRINT(" local 1 io addr 0x%x\n", priv(dev)->local1_iobase);\r\nretval = alloc_and_init_dma_members(dev);\r\nif (retval < 0)\r\nreturn retval;\r\npriv(dev)->hw_revision =\r\nhw_revision(dev, readw(priv(dev)->main_iobase + HW_STATUS_REG));\r\nprintk(" stc hardware revision %i\n", priv(dev)->hw_revision);\r\ninit_plx9080(dev);\r\ninit_stc_registers(dev);\r\nif (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,\r\n"cb_pcidas64", dev)) {\r\nprintk(" unable to allocate irq %u\n", pcidev->irq);\r\nreturn -EINVAL;\r\n}\r\ndev->irq = pcidev->irq;\r\nprintk(" irq %u\n", dev->irq);\r\nretval = setup_subdevices(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic int detach(struct comedi_device *dev)\r\n{\r\nunsigned int i;\r\nprintk("comedi%d: cb_pcidas: remove\n", dev->minor);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (priv(dev)) {\r\nif (priv(dev)->hw_dev) {\r\nif (priv(dev)->plx9080_iobase) {\r\ndisable_plx_interrupts(dev);\r\niounmap(priv(dev)->plx9080_iobase);\r\n}\r\nif (priv(dev)->main_iobase)\r\niounmap(priv(dev)->main_iobase);\r\nif (priv(dev)->dio_counter_iobase)\r\niounmap(priv(dev)->dio_counter_iobase);\r\nfor (i = 0; i < ai_dma_ring_count(board(dev)); i++) {\r\nif (priv(dev)->ai_buffer[i])\r\npci_free_consistent(priv(dev)->hw_dev,\r\nDMA_BUFFER_SIZE,\r\npriv(dev)->\r\nai_buffer[i],\r\npriv\r\n(dev)->ai_buffer_bus_addr\r\n[i]);\r\n}\r\nfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\r\nif (priv(dev)->ao_buffer[i])\r\npci_free_consistent(priv(dev)->hw_dev,\r\nDMA_BUFFER_SIZE,\r\npriv(dev)->\r\nao_buffer[i],\r\npriv\r\n(dev)->ao_buffer_bus_addr\r\n[i]);\r\n}\r\nif (priv(dev)->ai_dma_desc)\r\npci_free_consistent(priv(dev)->hw_dev,\r\nsizeof(struct plx_dma_desc)\r\n*\r\nai_dma_ring_count(board\r\n(dev)),\r\npriv(dev)->ai_dma_desc,\r\npriv(dev)->\r\nai_dma_desc_bus_addr);\r\nif (priv(dev)->ao_dma_desc)\r\npci_free_consistent(priv(dev)->hw_dev,\r\nsizeof(struct plx_dma_desc)\r\n* AO_DMA_RING_COUNT,\r\npriv(dev)->ao_dma_desc,\r\npriv(dev)->\r\nao_dma_desc_bus_addr);\r\nif (priv(dev)->main_phys_iobase)\r\ncomedi_pci_disable(priv(dev)->hw_dev);\r\npci_dev_put(priv(dev)->hw_dev);\r\n}\r\n}\r\nif (dev->subdevices)\r\nsubdev_8255_cleanup(dev, dev->subdevices + 4);\r\nreturn 0;\r\n}\r\nstatic int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int bits = 0, n, i;\r\nunsigned int channel, range, aref;\r\nunsigned long flags;\r\nstatic const int timeout = 100;\r\nDEBUG_PRINT("chanspec 0x%x\n", insn->chanspec);\r\nchannel = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\naref = CR_AREF(insn->chanspec);\r\ndisable_ai_pacing(dev);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (insn->chanspec & CR_ALT_FILTER)\r\npriv(dev)->adc_control1_bits |= ADC_DITHER_BIT;\r\nelse\r\npriv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;\r\nwritew(priv(dev)->adc_control1_bits,\r\npriv(dev)->main_iobase + ADC_CONTROL1_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (board(dev)->layout != LAYOUT_4020) {\r\npriv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;\r\nwritew(priv(dev)->hw_config_bits,\r\npriv(dev)->main_iobase + HW_CONFIG_REG);\r\nif (insn->chanspec & CR_ALT_SOURCE) {\r\nunsigned int cal_en_bit;\r\nDEBUG_PRINT("reading calibration source\n");\r\nif (board(dev)->layout == LAYOUT_60XX)\r\ncal_en_bit = CAL_EN_60XX_BIT;\r\nelse\r\ncal_en_bit = CAL_EN_64XX_BIT;\r\nwritew(cal_en_bit |\r\nadc_src_bits(priv(dev)->calibration_source),\r\npriv(dev)->main_iobase + CALIBRATION_REG);\r\n} else {\r\nwritew(0, priv(dev)->main_iobase + CALIBRATION_REG);\r\n}\r\nbits = 0;\r\nbits |= ai_range_bits_6xxx(dev, CR_RANGE(insn->chanspec));\r\nbits |= se_diff_bit_6xxx(dev, aref == AREF_DIFF);\r\nif (aref == AREF_COMMON)\r\nbits |= ADC_COMMON_BIT;\r\nbits |= adc_chan_bits(channel);\r\nwritew(adc_chan_bits(channel),\r\npriv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);\r\nwritew(bits, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);\r\n} else {\r\nuint8_t old_cal_range_bits = priv(dev)->i2c_cal_range_bits;\r\npriv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;\r\nif (insn->chanspec & CR_ALT_SOURCE) {\r\nDEBUG_PRINT("reading calibration source\n");\r\npriv(dev)->i2c_cal_range_bits |=\r\nadc_src_4020_bits(priv(dev)->calibration_source);\r\n} else {\r\npriv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);\r\n}\r\nif (range == 0)\r\npriv(dev)->i2c_cal_range_bits |= attenuate_bit(channel);\r\nelse\r\npriv(dev)->i2c_cal_range_bits &=\r\n~attenuate_bit(channel);\r\nif (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {\r\nuint8_t i2c_data = priv(dev)->i2c_cal_range_bits;\r\ni2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,\r\nsizeof(i2c_data));\r\n}\r\nwritew(0,\r\npriv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\r\nwritew(2,\r\npriv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nwritew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);\r\nwritew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),\r\npriv(dev)->main_iobase + ADC_CONVERT_REG);\r\nfor (i = 0; i < timeout; i++) {\r\nbits = readw(priv(dev)->main_iobase + HW_STATUS_REG);\r\nDEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nif (readw(priv(dev)->main_iobase +\r\nADC_WRITE_PNTR_REG))\r\nbreak;\r\n} else {\r\nif (pipe_full_bits(bits))\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nDEBUG_PRINT(" looped %i times waiting for data\n", i);\r\nif (i == timeout) {\r\ncomedi_error(dev, " analog input read insn timed out");\r\nprintk(" status 0x%x\n", bits);\r\nreturn -ETIME;\r\n}\r\nif (board(dev)->layout == LAYOUT_4020)\r\ndata[n] =\r\nreadl(priv(dev)->dio_counter_iobase +\r\nADC_FIFO_REG) & 0xffff;\r\nelse\r\ndata[n] =\r\nreadw(priv(dev)->main_iobase + PIPE1_READ_REG);\r\n}\r\nreturn n;\r\n}\r\nstatic int ai_config_calibration_source(struct comedi_device *dev,\r\nunsigned int *data)\r\n{\r\nunsigned int source = data[1];\r\nint num_calibration_sources;\r\nif (board(dev)->layout == LAYOUT_60XX)\r\nnum_calibration_sources = 16;\r\nelse\r\nnum_calibration_sources = 8;\r\nif (source >= num_calibration_sources) {\r\nprintk("invalid calibration source: %i\n", source);\r\nreturn -EINVAL;\r\n}\r\nDEBUG_PRINT("setting calibration source to %i\n", source);\r\npriv(dev)->calibration_source = source;\r\nreturn 2;\r\n}\r\nstatic int ai_config_block_size(struct comedi_device *dev, unsigned int *data)\r\n{\r\nint fifo_size;\r\nconst struct hw_fifo_info *const fifo = board(dev)->ai_fifo;\r\nunsigned int block_size, requested_block_size;\r\nint retval;\r\nrequested_block_size = data[1];\r\nif (requested_block_size) {\r\nfifo_size =\r\nrequested_block_size * fifo->num_segments / bytes_in_sample;\r\nretval = set_ai_fifo_size(dev, fifo_size);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nblock_size = ai_fifo_size(dev) / fifo->num_segments * bytes_in_sample;\r\ndata[1] = block_size;\r\nreturn 2;\r\n}\r\nstatic int ai_config_master_clock_4020(struct comedi_device *dev,\r\nunsigned int *data)\r\n{\r\nunsigned int divisor = data[4];\r\nint retval = 0;\r\nif (divisor < 2) {\r\ndivisor = 2;\r\nretval = -EAGAIN;\r\n}\r\nswitch (data[1]) {\r\ncase COMEDI_EV_SCAN_BEGIN:\r\npriv(dev)->ext_clock.divisor = divisor;\r\npriv(dev)->ext_clock.chanspec = data[2];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ndata[4] = divisor;\r\nreturn retval ? retval : 5;\r\n}\r\nstatic int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)\r\n{\r\nswitch (board(dev)->layout) {\r\ncase LAYOUT_4020:\r\nreturn ai_config_master_clock_4020(dev, data);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint id = data[0];\r\nswitch (id) {\r\ncase INSN_CONFIG_ALT_SOURCE:\r\nreturn ai_config_calibration_source(dev, data);\r\nbreak;\r\ncase INSN_CONFIG_BLOCK_SIZE:\r\nreturn ai_config_block_size(dev, data);\r\nbreak;\r\ncase INSN_CONFIG_TIMER_1:\r\nreturn ai_config_master_clock(dev, data);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nunsigned int tmp_arg, tmp_arg2;\r\nint i;\r\nint aref;\r\nunsigned int triggers;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ntriggers = TRIG_TIMER;\r\nif (board(dev)->layout == LAYOUT_4020)\r\ntriggers |= TRIG_OTHER;\r\nelse\r\ntriggers |= TRIG_FOLLOW;\r\ncmd->scan_begin_src &= triggers;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ntriggers = TRIG_TIMER;\r\nif (board(dev)->layout == LAYOUT_4020)\r\ntriggers |= TRIG_NOW;\r\nelse\r\ntriggers |= TRIG_EXT;\r\ncmd->convert_src &= triggers;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_OTHER &&\r\ncmd->scan_begin_src != TRIG_FOLLOW)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER &&\r\ncmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nif (cmd->convert_arg) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->convert_arg < board(dev)->ai_speed) {\r\ncmd->convert_arg = board(dev)->ai_speed;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->convert_arg * cmd->chanlist_len >\r\ncmd->scan_begin_arg) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg *\r\ncmd->chanlist_len;\r\nerr++;\r\n}\r\n}\r\n}\r\n}\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 1;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_EXT:\r\nbreak;\r\ncase TRIG_COUNT:\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp_arg = cmd->convert_arg;\r\ntmp_arg2 = cmd->scan_begin_arg;\r\ncheck_adc_timing(dev, cmd);\r\nif (tmp_arg != cmd->convert_arg)\r\nerr++;\r\nif (tmp_arg2 != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\naref = CR_AREF(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (aref != CR_AREF(cmd->chanlist[i])) {\r\ncomedi_error(dev,\r\n"all elements in chanlist must use the same analog reference");\r\nerr++;\r\nbreak;\r\n}\r\n}\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nunsigned int first_channel = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) !=\r\nfirst_channel + i) {\r\ncomedi_error(dev,\r\n"chanlist must use consecutive channels");\r\nerr++;\r\nbreak;\r\n}\r\n}\r\nif (cmd->chanlist_len == 3) {\r\ncomedi_error(dev,\r\n"chanlist cannot be 3 channels long, use 1, 2, or 4 channels");\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int use_hw_sample_counter(struct comedi_cmd *cmd)\r\n{\r\nreturn 0;\r\nif (cmd->stop_src == TRIG_COUNT && cmd->stop_arg <= max_counter_value)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void setup_sample_counters(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nif (cmd->stop_src == TRIG_COUNT) {\r\npriv(dev)->ai_count = cmd->stop_arg * cmd->chanlist_len;\r\n}\r\nif (use_hw_sample_counter(cmd)) {\r\nwritew(cmd->stop_arg & 0xffff,\r\npriv(dev)->main_iobase + ADC_COUNT_LOWER_REG);\r\nwritew((cmd->stop_arg >> 16) & 0xff,\r\npriv(dev)->main_iobase + ADC_COUNT_UPPER_REG);\r\n} else {\r\nwritew(1, priv(dev)->main_iobase + ADC_COUNT_LOWER_REG);\r\n}\r\n}\r\nstatic inline unsigned int dma_transfer_size(struct comedi_device *dev)\r\n{\r\nunsigned int num_samples;\r\nnum_samples =\r\npriv(dev)->ai_fifo_segment_length *\r\nboard(dev)->ai_fifo->sample_packing_ratio;\r\nif (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))\r\nnum_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);\r\nreturn num_samples;\r\n}\r\nstatic void disable_ai_pacing(struct comedi_device *dev)\r\n{\r\nunsigned long flags;\r\ndisable_ai_interrupts(dev);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\npriv(dev)->adc_control1_bits &= ~ADC_SW_GATE_BIT;\r\nwritew(priv(dev)->adc_control1_bits,\r\npriv(dev)->main_iobase + ADC_CONTROL1_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nwritew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,\r\npriv(dev)->main_iobase + ADC_CONTROL0_REG);\r\n}\r\nstatic void disable_ai_interrupts(struct comedi_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\npriv(dev)->intr_enable_bits &=\r\n~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &\r\n~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &\r\n~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;\r\nwritew(priv(dev)->intr_enable_bits,\r\npriv(dev)->main_iobase + INTR_ENABLE_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nDEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);\r\n}\r\nstatic void enable_ai_interrupts(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nuint32_t bits;\r\nunsigned long flags;\r\nbits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |\r\nEN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;\r\nif (cmd->flags & TRIG_WAKE_EOS) {\r\nif (board(dev)->layout != LAYOUT_4020)\r\nbits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\npriv(dev)->intr_enable_bits |= bits;\r\nwritew(priv(dev)->intr_enable_bits,\r\npriv(dev)->main_iobase + INTR_ENABLE_REG);\r\nDEBUG_PRINT("intr enable bits 0x%x\n", priv(dev)->intr_enable_bits);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nreturn cmd->convert_arg / TIMER_BASE - 3;\r\n}\r\nstatic uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nuint32_t count;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ncount = (cmd->scan_begin_arg -\r\n(cmd->convert_arg * (cmd->chanlist_len - 1)))\r\n/ TIMER_BASE;\r\nbreak;\r\ncase TRIG_FOLLOW:\r\ncount = cmd->convert_arg / TIMER_BASE;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn count - 3;\r\n}\r\nstatic uint32_t ai_convert_counter_4020(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int divisor;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ndivisor = cmd->scan_begin_arg / TIMER_BASE;\r\nbreak;\r\ncase TRIG_OTHER:\r\ndivisor = priv(dev)->ext_clock.divisor;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "bug! failed to set ai pacing!");\r\ndivisor = 1000;\r\nbreak;\r\n}\r\nreturn divisor - 2;\r\n}\r\nstatic void select_master_clock_4020(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\npriv(dev)->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;\r\nif (cmd->scan_begin_src == TRIG_OTHER) {\r\nint chanspec = priv(dev)->ext_clock.chanspec;\r\nif (CR_CHAN(chanspec))\r\npriv(dev)->hw_config_bits |= BNC_CLOCK_4020_BITS;\r\nelse\r\npriv(dev)->hw_config_bits |= EXT_CLOCK_4020_BITS;\r\n} else {\r\npriv(dev)->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;\r\n}\r\nwritew(priv(dev)->hw_config_bits,\r\npriv(dev)->main_iobase + HW_CONFIG_REG);\r\n}\r\nstatic void select_master_clock(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nswitch (board(dev)->layout) {\r\ncase LAYOUT_4020:\r\nselect_master_clock_4020(dev, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic inline void dma_start_sync(struct comedi_device *dev,\r\nunsigned int channel)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (channel)\r\nwriteb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |\r\nPLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);\r\nelse\r\nwriteb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |\r\nPLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)\r\n{\r\nuint32_t convert_counter = 0, scan_counter = 0;\r\ncheck_adc_timing(dev, cmd);\r\nselect_master_clock(dev, cmd);\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nconvert_counter = ai_convert_counter_4020(dev, cmd);\r\n} else {\r\nconvert_counter = ai_convert_counter_6xxx(dev, cmd);\r\nscan_counter = ai_scan_counter_6xxx(dev, cmd);\r\n}\r\nwritew(convert_counter & 0xffff,\r\npriv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);\r\nDEBUG_PRINT("convert counter 0x%x\n", convert_counter);\r\nwritew((convert_counter >> 16) & 0xff,\r\npriv(dev)->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\r\nwritew(scan_counter & 0xffff,\r\npriv(dev)->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);\r\nwritew((scan_counter >> 16) & 0xff,\r\npriv(dev)->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);\r\nDEBUG_PRINT("scan counter 0x%x\n", scan_counter);\r\n}\r\nstatic int use_internal_queue_6xxx(const struct comedi_cmd *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i + 1 < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i + 1]) !=\r\nCR_CHAN(cmd->chanlist[i]) + 1)\r\nreturn 0;\r\nif (CR_RANGE(cmd->chanlist[i + 1]) !=\r\nCR_RANGE(cmd->chanlist[i]))\r\nreturn 0;\r\nif (CR_AREF(cmd->chanlist[i + 1]) != CR_AREF(cmd->chanlist[i]))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int setup_channel_queue(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nunsigned short bits;\r\nint i;\r\nif (board(dev)->layout != LAYOUT_4020) {\r\nif (use_internal_queue_6xxx(cmd)) {\r\npriv(dev)->hw_config_bits &= ~EXT_QUEUE_BIT;\r\nwritew(priv(dev)->hw_config_bits,\r\npriv(dev)->main_iobase + HW_CONFIG_REG);\r\nbits = 0;\r\nbits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));\r\nbits |= ai_range_bits_6xxx(dev,\r\nCR_RANGE(cmd->chanlist[0]));\r\nbits |= se_diff_bit_6xxx(dev,\r\nCR_AREF(cmd->chanlist[0]) ==\r\nAREF_DIFF);\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)\r\nbits |= ADC_COMMON_BIT;\r\nwritew(adc_chan_bits\r\n(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])),\r\npriv(dev)->main_iobase + ADC_QUEUE_HIGH_REG);\r\nwritew(bits,\r\npriv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);\r\n} else {\r\nif (dev->write_subdev && dev->write_subdev->busy) {\r\nwarn_external_queue(dev);\r\nreturn -EBUSY;\r\n}\r\npriv(dev)->hw_config_bits |= EXT_QUEUE_BIT;\r\nwritew(priv(dev)->hw_config_bits,\r\npriv(dev)->main_iobase + HW_CONFIG_REG);\r\nwritew(0,\r\npriv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);\r\nwritew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nbits = 0;\r\nbits |=\r\nadc_chan_bits(CR_CHAN(cmd->chanlist[i]));\r\nbits |= ai_range_bits_6xxx(dev,\r\nCR_RANGE(cmd->\r\nchanlist\r\n[i]));\r\nbits |= se_diff_bit_6xxx(dev,\r\nCR_AREF(cmd->\r\nchanlist[i]) ==\r\nAREF_DIFF);\r\nif (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)\r\nbits |= ADC_COMMON_BIT;\r\nif (i == cmd->chanlist_len - 1)\r\nbits |= QUEUE_EOSCAN_BIT |\r\nQUEUE_EOSEQ_BIT;\r\nwritew(bits,\r\npriv(dev)->main_iobase +\r\nADC_QUEUE_FIFO_REG);\r\nDEBUG_PRINT\r\n("wrote 0x%x to external channel queue\n",\r\nbits);\r\n}\r\nwritew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);\r\nwritew(0, priv(dev)->main_iobase + ADC_QUEUE_LOAD_REG);\r\n}\r\n} else {\r\nunsigned short old_cal_range_bits =\r\npriv(dev)->i2c_cal_range_bits;\r\npriv(dev)->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;\r\npriv(dev)->i2c_cal_range_bits |= adc_src_4020_bits(4);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int channel = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nif (range == 0)\r\npriv(dev)->i2c_cal_range_bits |=\r\nattenuate_bit(channel);\r\nelse\r\npriv(dev)->i2c_cal_range_bits &=\r\n~attenuate_bit(channel);\r\n}\r\nif (old_cal_range_bits != priv(dev)->i2c_cal_range_bits) {\r\nuint8_t i2c_data = priv(dev)->i2c_cal_range_bits;\r\ni2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,\r\nsizeof(i2c_data));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void load_first_dma_descriptor(struct comedi_device *dev,\r\nunsigned int dma_channel,\r\nunsigned int descriptor_bits)\r\n{\r\nif (dma_channel) {\r\nwritel(0,\r\npriv(dev)->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);\r\nwritel(0, priv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);\r\nwritel(0,\r\npriv(dev)->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);\r\nwritel(descriptor_bits,\r\npriv(dev)->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);\r\n} else {\r\nwritel(0,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);\r\nwritel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);\r\nwritel(0,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);\r\nwritel(descriptor_bits,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);\r\n}\r\n}\r\nstatic int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nuint32_t bits;\r\nunsigned int i;\r\nunsigned long flags;\r\nint retval;\r\ndisable_ai_pacing(dev);\r\nabort_dma(dev, 1);\r\nretval = setup_channel_queue(dev, cmd);\r\nif (retval < 0)\r\nreturn retval;\r\nwritew(0, priv(dev)->main_iobase + CALIBRATION_REG);\r\nset_ai_pacing(dev, cmd);\r\nsetup_sample_counters(dev, cmd);\r\nenable_ai_interrupts(dev, cmd);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\npriv(dev)->adc_control1_bits |= ADC_SW_GATE_BIT;\r\npriv(dev)->adc_control1_bits &= ~ADC_DITHER_BIT;\r\nif (board(dev)->layout != LAYOUT_4020) {\r\npriv(dev)->adc_control1_bits &= ~ADC_MODE_MASK;\r\nif (cmd->convert_src == TRIG_EXT)\r\npriv(dev)->adc_control1_bits |= adc_mode_bits(13);\r\nelse\r\npriv(dev)->adc_control1_bits |= adc_mode_bits(8);\r\n} else {\r\npriv(dev)->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;\r\nif (cmd->chanlist_len == 4)\r\npriv(dev)->adc_control1_bits |= FOUR_CHANNEL_4020_BITS;\r\nelse if (cmd->chanlist_len == 2)\r\npriv(dev)->adc_control1_bits |= TWO_CHANNEL_4020_BITS;\r\npriv(dev)->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;\r\npriv(dev)->adc_control1_bits |=\r\nadc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));\r\npriv(dev)->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;\r\npriv(dev)->adc_control1_bits |=\r\nadc_hi_chan_4020_bits(CR_CHAN\r\n(cmd->\r\nchanlist[cmd->chanlist_len - 1]));\r\n}\r\nwritew(priv(dev)->adc_control1_bits,\r\npriv(dev)->main_iobase + ADC_CONTROL1_REG);\r\nDEBUG_PRINT("control1 bits 0x%x\n", priv(dev)->adc_control1_bits);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nwritew(0, priv(dev)->main_iobase + ADC_BUFFER_CLEAR_REG);\r\nif ((cmd->flags & TRIG_WAKE_EOS) == 0 ||\r\nboard(dev)->layout == LAYOUT_4020) {\r\npriv(dev)->ai_dma_index = 0;\r\nfor (i = 0; i < ai_dma_ring_count(board(dev)); i++)\r\npriv(dev)->ai_dma_desc[i].transfer_size =\r\ncpu_to_le32(dma_transfer_size(dev) *\r\nsizeof(uint16_t));\r\nload_first_dma_descriptor(dev, 1,\r\npriv(dev)->ai_dma_desc_bus_addr |\r\nPLX_DESC_IN_PCI_BIT |\r\nPLX_INTR_TERM_COUNT |\r\nPLX_XFER_LOCAL_TO_PCI);\r\ndma_start_sync(dev, 1);\r\n}\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nbits = 0;\r\nif (cmd->start_src == TRIG_EXT && CR_CHAN(cmd->start_arg))\r\nbits |= EXT_START_TRIG_BNC_BIT;\r\nif (cmd->stop_src == TRIG_EXT && CR_CHAN(cmd->stop_arg))\r\nbits |= EXT_STOP_TRIG_BNC_BIT;\r\nwritew(bits, priv(dev)->main_iobase + DAQ_ATRIG_LOW_4020_REG);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nbits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;\r\nif (cmd->flags & TRIG_WAKE_EOS)\r\nbits |= ADC_DMA_DISABLE_BIT;\r\nif (cmd->start_src == TRIG_EXT) {\r\nbits |= ADC_START_TRIG_EXT_BITS;\r\nif (cmd->start_arg & CR_INVERT)\r\nbits |= ADC_START_TRIG_FALLING_BIT;\r\n} else if (cmd->start_src == TRIG_NOW)\r\nbits |= ADC_START_TRIG_SOFT_BITS;\r\nif (use_hw_sample_counter(cmd))\r\nbits |= ADC_SAMPLE_COUNTER_EN_BIT;\r\nwritew(bits, priv(dev)->main_iobase + ADC_CONTROL0_REG);\r\nDEBUG_PRINT("control0 bits 0x%x\n", bits);\r\npriv(dev)->ai_cmd_running = 1;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (cmd->start_src == TRIG_NOW) {\r\nwritew(0, priv(dev)->main_iobase + ADC_START_REG);\r\nDEBUG_PRINT("soft trig\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void pio_drain_ai_fifo_16(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int i;\r\nuint16_t prepost_bits;\r\nint read_segment, read_index, write_segment, write_index;\r\nint num_samples;\r\ndo {\r\nread_index =\r\nreadw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;\r\nwrite_index =\r\nreadw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;\r\nprepost_bits = readw(priv(dev)->main_iobase + PREPOST_REG);\r\nread_segment = adc_upper_read_ptr_code(prepost_bits);\r\nwrite_segment = adc_upper_write_ptr_code(prepost_bits);\r\nDEBUG_PRINT(" rd seg %i, wrt seg %i, rd idx %i, wrt idx %i\n",\r\nread_segment, write_segment, read_index,\r\nwrite_index);\r\nif (read_segment != write_segment)\r\nnum_samples =\r\npriv(dev)->ai_fifo_segment_length - read_index;\r\nelse\r\nnum_samples = write_index - read_index;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (priv(dev)->ai_count == 0)\r\nbreak;\r\nif (num_samples > priv(dev)->ai_count)\r\nnum_samples = priv(dev)->ai_count;\r\npriv(dev)->ai_count -= num_samples;\r\n}\r\nif (num_samples < 0) {\r\nprintk(" cb_pcidas64: bug! num_samples < 0\n");\r\nbreak;\r\n}\r\nDEBUG_PRINT(" read %i samples from fifo\n", num_samples);\r\nfor (i = 0; i < num_samples; i++) {\r\ncfc_write_to_buffer(s,\r\nreadw(priv(dev)->main_iobase +\r\nADC_FIFO_REG));\r\n}\r\n} while (read_segment != write_segment);\r\n}\r\nstatic void pio_drain_ai_fifo_32(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int i;\r\nunsigned int max_transfer = 100000;\r\nuint32_t fifo_data;\r\nint write_code =\r\nreadw(priv(dev)->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;\r\nint read_code =\r\nreadw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (max_transfer > priv(dev)->ai_count)\r\nmax_transfer = priv(dev)->ai_count;\r\n}\r\nfor (i = 0; read_code != write_code && i < max_transfer;) {\r\nfifo_data = readl(priv(dev)->dio_counter_iobase + ADC_FIFO_REG);\r\ncfc_write_to_buffer(s, fifo_data & 0xffff);\r\ni++;\r\nif (i < max_transfer) {\r\ncfc_write_to_buffer(s, (fifo_data >> 16) & 0xffff);\r\ni++;\r\n}\r\nread_code =\r\nreadw(priv(dev)->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;\r\n}\r\npriv(dev)->ai_count -= i;\r\n}\r\nstatic void pio_drain_ai_fifo(struct comedi_device *dev)\r\n{\r\nif (board(dev)->layout == LAYOUT_4020)\r\npio_drain_ai_fifo_32(dev);\r\nelse\r\npio_drain_ai_fifo_16(dev);\r\n}\r\nstatic void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)\r\n{\r\nstruct comedi_async *async = dev->read_subdev->async;\r\nuint32_t next_transfer_addr;\r\nint j;\r\nint num_samples = 0;\r\nvoid __iomem *pci_addr_reg;\r\nif (channel)\r\npci_addr_reg =\r\npriv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;\r\nelse\r\npci_addr_reg =\r\npriv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;\r\nfor (j = 0, next_transfer_addr = readl(pci_addr_reg);\r\n(next_transfer_addr <\r\npriv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index]\r\n|| next_transfer_addr >=\r\npriv(dev)->ai_buffer_bus_addr[priv(dev)->ai_dma_index] +\r\nDMA_BUFFER_SIZE) && j < ai_dma_ring_count(board(dev)); j++) {\r\nnum_samples = dma_transfer_size(dev);\r\nif (async->cmd.stop_src == TRIG_COUNT) {\r\nif (num_samples > priv(dev)->ai_count)\r\nnum_samples = priv(dev)->ai_count;\r\npriv(dev)->ai_count -= num_samples;\r\n}\r\ncfc_write_array_to_buffer(dev->read_subdev,\r\npriv(dev)->ai_buffer[priv(dev)->\r\nai_dma_index],\r\nnum_samples * sizeof(uint16_t));\r\npriv(dev)->ai_dma_index =\r\n(priv(dev)->ai_dma_index +\r\n1) % ai_dma_ring_count(board(dev));\r\nDEBUG_PRINT("next buffer addr 0x%lx\n",\r\n(unsigned long)priv(dev)->\r\nai_buffer_bus_addr[priv(dev)->ai_dma_index]);\r\nDEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);\r\n}\r\n}\r\nstatic void handle_ai_interrupt(struct comedi_device *dev,\r\nunsigned short status,\r\nunsigned int plx_status)\r\n{\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nuint8_t dma1_status;\r\nunsigned long flags;\r\nif (status & ADC_OVERRUN_BIT) {\r\ncomedi_error(dev, "fifo overrun");\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);\r\nif (plx_status & ICS_DMA1_A) {\r\nwriteb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);\r\nDEBUG_PRINT("dma1 status 0x%x\n", dma1_status);\r\nif (dma1_status & PLX_DMA_EN_BIT)\r\ndrain_dma_buffers(dev, 1);\r\nDEBUG_PRINT(" cleared dma ch1 interrupt\n");\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (status & ADC_DONE_BIT)\r\nDEBUG_PRINT("adc done interrupt\n");\r\nif ((status & ADC_DONE_BIT) ||\r\n((cmd->flags & TRIG_WAKE_EOS) &&\r\n(status & ADC_INTR_PENDING_BIT) &&\r\n(board(dev)->layout != LAYOUT_4020))) {\r\nDEBUG_PRINT("pio fifo drain\n");\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (priv(dev)->ai_cmd_running) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\npio_drain_ai_fifo(dev);\r\n} else\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nif ((cmd->stop_src == TRIG_COUNT && (int)priv(dev)->ai_count <= 0) ||\r\n(cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT))) {\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\ncfc_handle_events(dev, s);\r\n}\r\nstatic inline unsigned int prev_ao_dma_index(struct comedi_device *dev)\r\n{\r\nunsigned int buffer_index;\r\nif (priv(dev)->ao_dma_index == 0)\r\nbuffer_index = AO_DMA_RING_COUNT - 1;\r\nelse\r\nbuffer_index = priv(dev)->ao_dma_index - 1;\r\nreturn buffer_index;\r\n}\r\nstatic int last_ao_dma_load_completed(struct comedi_device *dev)\r\n{\r\nunsigned int buffer_index;\r\nunsigned int transfer_address;\r\nunsigned short dma_status;\r\nbuffer_index = prev_ao_dma_index(dev);\r\ndma_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nif ((dma_status & PLX_DMA_DONE_BIT) == 0)\r\nreturn 0;\r\ntransfer_address =\r\nreadl(priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);\r\nif (transfer_address != priv(dev)->ao_buffer_bus_addr[buffer_index])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ao_stopped_by_error(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nif (cmd->stop_src == TRIG_NONE)\r\nreturn 1;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (priv(dev)->ao_count)\r\nreturn 1;\r\nif (last_ao_dma_load_completed(dev) == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int ao_dma_needs_restart(struct comedi_device *dev,\r\nunsigned short dma_status)\r\n{\r\nif ((dma_status & PLX_DMA_DONE_BIT) == 0 ||\r\n(dma_status & PLX_DMA_EN_BIT) == 0)\r\nreturn 0;\r\nif (last_ao_dma_load_completed(dev))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void restart_ao_dma(struct comedi_device *dev)\r\n{\r\nunsigned int dma_desc_bits;\r\ndma_desc_bits =\r\nreadl(priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);\r\ndma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;\r\nDEBUG_PRINT("restarting ao dma, descriptor reg 0x%x\n", dma_desc_bits);\r\nload_first_dma_descriptor(dev, 0, dma_desc_bits);\r\ndma_start_sync(dev, 0);\r\n}\r\nstatic void handle_ao_interrupt(struct comedi_device *dev,\r\nunsigned short status, unsigned int plx_status)\r\n{\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nuint8_t dma0_status;\r\nunsigned long flags;\r\nif (s == NULL)\r\nreturn;\r\nasync = s->async;\r\ncmd = &async->cmd;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nif (plx_status & ICS_DMA0_A) {\r\nif ((dma0_status & PLX_DMA_EN_BIT)\r\n&& !(dma0_status & PLX_DMA_DONE_BIT))\r\nwriteb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nelse\r\nwriteb(PLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nDEBUG_PRINT("dma0 status 0x%x\n", dma0_status);\r\nif (dma0_status & PLX_DMA_EN_BIT) {\r\nload_ao_dma(dev, cmd);\r\nif (ao_dma_needs_restart(dev, dma0_status))\r\nrestart_ao_dma(dev);\r\n}\r\nDEBUG_PRINT(" cleared dma ch0 interrupt\n");\r\n} else\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif ((status & DAC_DONE_BIT)) {\r\nasync->events |= COMEDI_CB_EOA;\r\nif (ao_stopped_by_error(dev, cmd))\r\nasync->events |= COMEDI_CB_ERROR;\r\nDEBUG_PRINT("plx dma0 desc reg 0x%x\n",\r\nreadl(priv(dev)->plx9080_iobase +\r\nPLX_DMA0_DESCRIPTOR_REG));\r\nDEBUG_PRINT("plx dma0 address reg 0x%x\n",\r\nreadl(priv(dev)->plx9080_iobase +\r\nPLX_DMA0_PCI_ADDRESS_REG));\r\n}\r\ncfc_handle_events(dev, s);\r\n}\r\nstatic irqreturn_t handle_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned short status;\r\nuint32_t plx_status;\r\nuint32_t plx_bits;\r\nplx_status = readl(priv(dev)->plx9080_iobase + PLX_INTRCS_REG);\r\nstatus = readw(priv(dev)->main_iobase + HW_STATUS_REG);\r\nDEBUG_PRINT("cb_pcidas64: hw status 0x%x ", status);\r\nDEBUG_PRINT("plx status 0x%x\n", plx_status);\r\nif (dev->attached == 0) {\r\nDEBUG_PRINT("cb_pcidas64: premature interrupt, ignoring",\r\nstatus);\r\nreturn IRQ_HANDLED;\r\n}\r\nhandle_ai_interrupt(dev, status, plx_status);\r\nhandle_ao_interrupt(dev, status, plx_status);\r\nif (plx_status & ICS_LDIA) {\r\nplx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);\r\nwritel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);\r\nDEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);\r\n}\r\nDEBUG_PRINT("exiting handler\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void abort_dma(struct comedi_device *dev, unsigned int channel)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nplx9080_abort_dma(priv(dev)->plx9080_iobase, channel);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (priv(dev)->ai_cmd_running == 0) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\npriv(dev)->ai_cmd_running = 0;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndisable_ai_pacing(dev);\r\nabort_dma(dev, 1);\r\nDEBUG_PRINT("ai canceled\n");\r\nreturn 0;\r\n}\r\nstatic int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec);\r\nint range = CR_RANGE(insn->chanspec);\r\nwritew(0, priv(dev)->main_iobase + DAC_CONTROL0_REG);\r\nset_dac_range_bits(dev, &priv(dev)->dac_control1_bits, chan, range);\r\nwritew(priv(dev)->dac_control1_bits,\r\npriv(dev)->main_iobase + DAC_CONTROL1_REG);\r\nif (board(dev)->layout == LAYOUT_4020) {\r\nwritew(data[0] & 0xff,\r\npriv(dev)->main_iobase + dac_lsb_4020_reg(chan));\r\nwritew((data[0] >> 8) & 0xf,\r\npriv(dev)->main_iobase + dac_msb_4020_reg(chan));\r\n} else {\r\nwritew(data[0], priv(dev)->main_iobase + dac_convert_reg(chan));\r\n}\r\npriv(dev)->ao_value[chan] = data[0];\r\nreturn 1;\r\n}\r\nstatic int ao_readback_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = priv(dev)->ao_value[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic void set_dac_control0_reg(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nunsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |\r\nWAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;\r\nif (cmd->start_src == TRIG_EXT) {\r\nbits |= WAVEFORM_TRIG_EXT_BITS;\r\nif (cmd->start_arg & CR_INVERT)\r\nbits |= WAVEFORM_TRIG_FALLING_BIT;\r\n} else {\r\nbits |= WAVEFORM_TRIG_SOFT_BITS;\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nbits |= DAC_EXT_UPDATE_ENABLE_BIT;\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\nbits |= DAC_EXT_UPDATE_FALLING_BIT;\r\n}\r\nwritew(bits, priv(dev)->main_iobase + DAC_CONTROL0_REG);\r\n}\r\nstatic void set_dac_control1_reg(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nint channel, range;\r\nchannel = CR_CHAN(cmd->chanlist[i]);\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nset_dac_range_bits(dev, &priv(dev)->dac_control1_bits, channel,\r\nrange);\r\n}\r\npriv(dev)->dac_control1_bits |= DAC_SW_GATE_BIT;\r\nwritew(priv(dev)->dac_control1_bits,\r\npriv(dev)->main_iobase + DAC_CONTROL1_REG);\r\n}\r\nstatic void set_dac_select_reg(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nuint16_t bits;\r\nunsigned int first_channel, last_channel;\r\nfirst_channel = CR_CHAN(cmd->chanlist[0]);\r\nlast_channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\r\nif (last_channel < first_channel)\r\ncomedi_error(dev, "bug! last ao channel < first ao channel");\r\nbits = (first_channel & 0x7) | (last_channel & 0x7) << 3;\r\nwritew(bits, priv(dev)->main_iobase + DAC_SELECT_REG);\r\n}\r\nstatic void set_dac_interval_regs(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nunsigned int divisor;\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn;\r\ndivisor = get_ao_divisor(cmd->scan_begin_arg, cmd->flags);\r\nif (divisor > max_counter_value) {\r\ncomedi_error(dev, "bug! ao divisor too big");\r\ndivisor = max_counter_value;\r\n}\r\nwritew(divisor & 0xffff,\r\npriv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);\r\nwritew((divisor >> 16) & 0xff,\r\npriv(dev)->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);\r\n}\r\nstatic unsigned int load_ao_dma_buffer(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nunsigned int num_bytes, buffer_index, prev_buffer_index;\r\nunsigned int next_bits;\r\nbuffer_index = priv(dev)->ao_dma_index;\r\nprev_buffer_index = prev_ao_dma_index(dev);\r\nDEBUG_PRINT("attempting to load ao buffer %i (0x%x)\n", buffer_index,\r\npriv(dev)->ao_buffer_bus_addr[buffer_index]);\r\nnum_bytes = comedi_buf_read_n_available(dev->write_subdev->async);\r\nif (num_bytes > DMA_BUFFER_SIZE)\r\nnum_bytes = DMA_BUFFER_SIZE;\r\nif (cmd->stop_src == TRIG_COUNT && num_bytes > priv(dev)->ao_count)\r\nnum_bytes = priv(dev)->ao_count;\r\nnum_bytes -= num_bytes % bytes_in_sample;\r\nif (num_bytes == 0)\r\nreturn 0;\r\nDEBUG_PRINT("loading %i bytes\n", num_bytes);\r\nnum_bytes = cfc_read_array_from_buffer(dev->write_subdev,\r\npriv(dev)->\r\nao_buffer[buffer_index],\r\nnum_bytes);\r\npriv(dev)->ao_dma_desc[buffer_index].transfer_size =\r\ncpu_to_le32(num_bytes);\r\nnext_bits = le32_to_cpu(priv(dev)->ao_dma_desc[buffer_index].next);\r\nnext_bits |= PLX_END_OF_CHAIN_BIT;\r\npriv(dev)->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);\r\nnext_bits = le32_to_cpu(priv(dev)->ao_dma_desc[prev_buffer_index].next);\r\nnext_bits &= ~PLX_END_OF_CHAIN_BIT;\r\npriv(dev)->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);\r\npriv(dev)->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;\r\npriv(dev)->ao_count -= num_bytes;\r\nreturn num_bytes;\r\n}\r\nstatic void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)\r\n{\r\nunsigned int num_bytes;\r\nunsigned int next_transfer_addr;\r\nvoid __iomem *pci_addr_reg =\r\npriv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;\r\nunsigned int buffer_index;\r\ndo {\r\nbuffer_index = priv(dev)->ao_dma_index;\r\nnext_transfer_addr = readl(pci_addr_reg);\r\nif (next_transfer_addr >=\r\npriv(dev)->ao_buffer_bus_addr[buffer_index]\r\n&& next_transfer_addr <\r\npriv(dev)->ao_buffer_bus_addr[buffer_index] +\r\nDMA_BUFFER_SIZE)\r\nreturn;\r\nnum_bytes = load_ao_dma_buffer(dev, cmd);\r\n} while (num_bytes >= DMA_BUFFER_SIZE);\r\n}\r\nstatic int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)\r\n{\r\nunsigned int num_bytes;\r\nint i;\r\nwritew(0, priv(dev)->main_iobase + ADC_QUEUE_CLEAR_REG);\r\nwritew(0, priv(dev)->main_iobase + DAC_BUFFER_CLEAR_REG);\r\nnum_bytes = (DAC_FIFO_SIZE / 2) * bytes_in_sample;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nnum_bytes / bytes_in_sample > priv(dev)->ao_count)\r\nnum_bytes = priv(dev)->ao_count * bytes_in_sample;\r\nnum_bytes = cfc_read_array_from_buffer(dev->write_subdev,\r\npriv(dev)->ao_bounce_buffer,\r\nnum_bytes);\r\nfor (i = 0; i < num_bytes / bytes_in_sample; i++) {\r\nwritew(priv(dev)->ao_bounce_buffer[i],\r\npriv(dev)->main_iobase + DAC_FIFO_REG);\r\n}\r\npriv(dev)->ao_count -= num_bytes / bytes_in_sample;\r\nif (cmd->stop_src == TRIG_COUNT && priv(dev)->ao_count == 0)\r\nreturn 0;\r\nnum_bytes = load_ao_dma_buffer(dev, cmd);\r\nif (num_bytes == 0)\r\nreturn -1;\r\nif (num_bytes >= DMA_BUFFER_SIZE) ;\r\nload_ao_dma(dev, cmd);\r\ndma_start_sync(dev, 0);\r\nreturn 0;\r\n}\r\nstatic inline int external_ai_queue_in_use(struct comedi_device *dev)\r\n{\r\nif (dev->read_subdev->busy)\r\nreturn 0;\r\nif (board(dev)->layout == LAYOUT_4020)\r\nreturn 0;\r\nelse if (use_internal_queue_6xxx(&dev->read_subdev->async->cmd))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (external_ai_queue_in_use(dev)) {\r\nwarn_external_queue(dev);\r\nreturn -EBUSY;\r\n}\r\nwritew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);\r\npriv(dev)->ao_dma_index = 0;\r\npriv(dev)->ao_count = cmd->stop_arg * cmd->chanlist_len;\r\nset_dac_select_reg(dev, cmd);\r\nset_dac_interval_regs(dev, cmd);\r\nload_first_dma_descriptor(dev, 0, priv(dev)->ao_dma_desc_bus_addr |\r\nPLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);\r\nset_dac_control1_reg(dev, cmd);\r\ns->async->inttrig = ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint retval;\r\nif (trig_num != 0)\r\nreturn -EINVAL;\r\nretval = prep_ao_dma(dev, cmd);\r\nif (retval < 0)\r\nreturn -EPIPE;\r\nset_dac_control0_reg(dev, cmd);\r\nif (cmd->start_src == TRIG_INT)\r\nwritew(0, priv(dev)->main_iobase + DAC_START_REG);\r\ns->async->inttrig = NULL;\r\nreturn 0;\r\n}\r\nstatic int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nunsigned int tmp_arg;\r\nint i;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_INT | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < board(dev)->ao_scan_speed) {\r\ncmd->scan_begin_arg = board(dev)->ao_scan_speed;\r\nerr++;\r\n}\r\nif (get_ao_divisor(cmd->scan_begin_arg,\r\ncmd->flags) > max_counter_value) {\r\ncmd->scan_begin_arg =\r\n(max_counter_value + 2) * TIMER_BASE;\r\nerr++;\r\n}\r\n}\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 1;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp_arg = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg =\r\nget_divisor(cmd->scan_begin_arg, cmd->flags) * TIMER_BASE;\r\nif (tmp_arg != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nunsigned int first_channel = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) != first_channel + i) {\r\ncomedi_error(dev,\r\n"chanlist must use consecutive channels");\r\nerr++;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nwritew(0x0, priv(dev)->main_iobase + DAC_CONTROL0_REG);\r\nabort_dma(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int dio_callback(int dir, int port, int data, unsigned long arg)\r\n{\r\nvoid __iomem *iobase = (void __iomem *)arg;\r\nif (dir) {\r\nwriteb(data, iobase + port);\r\nDEBUG_PRINT("wrote 0x%x to port %i\n", data, port);\r\nreturn 0;\r\n} else {\r\nreturn readb(iobase + port);\r\n}\r\n}\r\nstatic int dio_callback_4020(int dir, int port, int data, unsigned long arg)\r\n{\r\nvoid __iomem *iobase = (void __iomem *)arg;\r\nif (dir) {\r\nwritew(data, iobase + 2 * port);\r\nreturn 0;\r\n} else {\r\nreturn readw(iobase + 2 * port);\r\n}\r\n}\r\nstatic int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int bits;\r\nbits = readb(priv(dev)->dio_counter_iobase + DI_REG);\r\nbits &= 0xf;\r\ndata[1] = bits;\r\ndata[0] = 0;\r\nreturn 2;\r\n}\r\nstatic int do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] &= 0xf;\r\ns->state &= ~data[0];\r\ns->state |= data[0] & data[1];\r\nwriteb(s->state, priv(dev)->dio_counter_iobase + DO_REG);\r\ndata[1] = s->state;\r\nreturn 2;\r\n}\r\nstatic int dio_60xx_config_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int mask;\r\nmask = 1 << CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~mask;\r\nbreak;\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= mask;\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn 2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwriteb(s->io_bits,\r\npriv(dev)->dio_counter_iobase + DIO_DIRECTION_60XX_REG);\r\nreturn 1;\r\n}\r\nstatic int dio_60xx_wbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nwriteb(s->state,\r\npriv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);\r\n}\r\ndata[1] = readb(priv(dev)->dio_counter_iobase + DIO_DATA_60XX_REG);\r\nreturn 2;\r\n}\r\nstatic void caldac_write(struct comedi_device *dev, unsigned int channel,\r\nunsigned int value)\r\n{\r\npriv(dev)->caldac_state[channel] = value;\r\nswitch (board(dev)->layout) {\r\ncase LAYOUT_60XX:\r\ncase LAYOUT_64XX:\r\ncaldac_8800_write(dev, channel, value);\r\nbreak;\r\ncase LAYOUT_4020:\r\ncaldac_i2c_write(dev, channel, value);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int calib_write_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel = CR_CHAN(insn->chanspec);\r\nif (priv(dev)->caldac_state[channel] == data[0])\r\nreturn 1;\r\ncaldac_write(dev, channel, data[0]);\r\nreturn 1;\r\n}\r\nstatic int calib_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int channel = CR_CHAN(insn->chanspec);\r\ndata[0] = priv(dev)->caldac_state[channel];\r\nreturn 1;\r\n}\r\nstatic void ad8402_write(struct comedi_device *dev, unsigned int channel,\r\nunsigned int value)\r\n{\r\nstatic const int bitstream_length = 10;\r\nunsigned int bit, register_bits;\r\nunsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);\r\nstatic const int ad8402_udelay = 1;\r\npriv(dev)->ad8402_state[channel] = value;\r\nregister_bits = SELECT_8402_64XX_BIT;\r\nudelay(ad8402_udelay);\r\nwritew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nif (bitstream & bit)\r\nregister_bits |= SERIAL_DATA_IN_BIT;\r\nelse\r\nregister_bits &= ~SERIAL_DATA_IN_BIT;\r\nudelay(ad8402_udelay);\r\nwritew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);\r\nudelay(ad8402_udelay);\r\nwritew(register_bits | SERIAL_CLOCK_BIT,\r\npriv(dev)->main_iobase + CALIBRATION_REG);\r\n}\r\nudelay(ad8402_udelay);\r\nwritew(0, priv(dev)->main_iobase + CALIBRATION_REG);\r\n}\r\nstatic int ad8402_write_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel = CR_CHAN(insn->chanspec);\r\nif (priv(dev)->ad8402_state[channel] == data[0])\r\nreturn 1;\r\npriv(dev)->ad8402_state[channel] = data[0];\r\nad8402_write(dev, channel, data[0]);\r\nreturn 1;\r\n}\r\nstatic int ad8402_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int channel = CR_CHAN(insn->chanspec);\r\ndata[0] = priv(dev)->ad8402_state[channel];\r\nreturn 1;\r\n}\r\nstatic uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)\r\n{\r\nstatic const int bitstream_length = 11;\r\nstatic const int read_command = 0x6;\r\nunsigned int bitstream = (read_command << 8) | address;\r\nunsigned int bit;\r\nvoid __iomem * const plx_control_addr =\r\npriv(dev)->plx9080_iobase + PLX_CONTROL_REG;\r\nuint16_t value;\r\nstatic const int value_length = 16;\r\nstatic const int eeprom_udelay = 1;\r\nudelay(eeprom_udelay);\r\npriv(dev)->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;\r\npriv(dev)->plx_control_bits |= CTL_USERO;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\npriv(dev)->plx_control_bits |= CTL_EE_CS;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nudelay(eeprom_udelay);\r\nif (bitstream & bit)\r\npriv(dev)->plx_control_bits |= CTL_EE_W;\r\nelse\r\npriv(dev)->plx_control_bits &= ~CTL_EE_W;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\npriv(dev)->plx_control_bits |= CTL_EE_CLK;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\npriv(dev)->plx_control_bits &= ~CTL_EE_CLK;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\n}\r\nvalue = 0;\r\nfor (bit = 1 << (value_length - 1); bit; bit >>= 1) {\r\nudelay(eeprom_udelay);\r\npriv(dev)->plx_control_bits |= CTL_EE_CLK;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\npriv(dev)->plx_control_bits &= ~CTL_EE_CLK;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\nif (readl(plx_control_addr) & CTL_EE_R)\r\nvalue |= bit;\r\n}\r\nudelay(eeprom_udelay);\r\npriv(dev)->plx_control_bits &= ~CTL_EE_CS;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nreturn value;\r\n}\r\nstatic int eeprom_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));\r\nreturn 1;\r\n}\r\nstatic void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)\r\n{\r\nunsigned int convert_divisor = 0, scan_divisor;\r\nstatic const int min_convert_divisor = 3;\r\nstatic const int max_convert_divisor =\r\nmax_counter_value + min_convert_divisor;\r\nstatic const int min_scan_divisor_4020 = 2;\r\nunsigned long long max_scan_divisor, min_scan_divisor;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (board(dev)->layout == LAYOUT_4020) {\r\ncmd->convert_arg = 0;\r\n} else {\r\nconvert_divisor =\r\nget_divisor(cmd->convert_arg, cmd->flags);\r\nif (convert_divisor > max_convert_divisor)\r\nconvert_divisor = max_convert_divisor;\r\nif (convert_divisor < min_convert_divisor)\r\nconvert_divisor = min_convert_divisor;\r\ncmd->convert_arg = convert_divisor * TIMER_BASE;\r\n}\r\n} else if (cmd->convert_src == TRIG_NOW)\r\ncmd->convert_arg = 0;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nscan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nmin_scan_divisor = convert_divisor * cmd->chanlist_len;\r\nmax_scan_divisor =\r\n(convert_divisor * cmd->chanlist_len - 1) +\r\nmax_counter_value;\r\n} else {\r\nmin_scan_divisor = min_scan_divisor_4020;\r\nmax_scan_divisor = max_counter_value + min_scan_divisor;\r\n}\r\nif (scan_divisor > max_scan_divisor)\r\nscan_divisor = max_scan_divisor;\r\nif (scan_divisor < min_scan_divisor)\r\nscan_divisor = min_scan_divisor;\r\ncmd->scan_begin_arg = scan_divisor * TIMER_BASE;\r\n}\r\nreturn;\r\n}\r\nstatic unsigned int get_divisor(unsigned int ns, unsigned int flags)\r\n{\r\nunsigned int divisor;\r\nswitch (flags & TRIG_ROUND_MASK) {\r\ncase TRIG_ROUND_UP:\r\ndivisor = (ns + TIMER_BASE - 1) / TIMER_BASE;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndivisor = ns / TIMER_BASE;\r\nbreak;\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\ndivisor = (ns + TIMER_BASE / 2) / TIMER_BASE;\r\nbreak;\r\n}\r\nreturn divisor;\r\n}\r\nstatic unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)\r\n{\r\nreturn get_divisor(ns, flags) - 2;\r\n}\r\nstatic int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)\r\n{\r\nunsigned int num_fifo_entries;\r\nint retval;\r\nconst struct hw_fifo_info *const fifo = board(dev)->ai_fifo;\r\nnum_fifo_entries = num_samples / fifo->sample_packing_ratio;\r\nretval = set_ai_fifo_segment_length(dev,\r\nnum_fifo_entries /\r\nfifo->num_segments);\r\nif (retval < 0)\r\nreturn retval;\r\nnum_samples = retval * fifo->num_segments * fifo->sample_packing_ratio;\r\nDEBUG_PRINT("set hardware fifo size to %i\n", num_samples);\r\nreturn num_samples;\r\n}\r\nstatic unsigned int ai_fifo_size(struct comedi_device *dev)\r\n{\r\nreturn priv(dev)->ai_fifo_segment_length *\r\nboard(dev)->ai_fifo->num_segments *\r\nboard(dev)->ai_fifo->sample_packing_ratio;\r\n}\r\nstatic int set_ai_fifo_segment_length(struct comedi_device *dev,\r\nunsigned int num_entries)\r\n{\r\nstatic const int increment_size = 0x100;\r\nconst struct hw_fifo_info *const fifo = board(dev)->ai_fifo;\r\nunsigned int num_increments;\r\nuint16_t bits;\r\nif (num_entries < increment_size)\r\nnum_entries = increment_size;\r\nif (num_entries > fifo->max_segment_length)\r\nnum_entries = fifo->max_segment_length;\r\nnum_increments = (num_entries + increment_size / 2) / increment_size;\r\nbits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;\r\npriv(dev)->fifo_size_bits &= ~fifo->fifo_size_reg_mask;\r\npriv(dev)->fifo_size_bits |= bits;\r\nwritew(priv(dev)->fifo_size_bits,\r\npriv(dev)->main_iobase + FIFO_SIZE_REG);\r\npriv(dev)->ai_fifo_segment_length = num_increments * increment_size;\r\nDEBUG_PRINT("set hardware fifo segment length to %i\n",\r\npriv(dev)->ai_fifo_segment_length);\r\nreturn priv(dev)->ai_fifo_segment_length;\r\n}\r\nstatic int caldac_8800_write(struct comedi_device *dev, unsigned int address,\r\nuint8_t value)\r\n{\r\nstatic const int num_caldac_channels = 8;\r\nstatic const int bitstream_length = 11;\r\nunsigned int bitstream = ((address & 0x7) << 8) | value;\r\nunsigned int bit, register_bits;\r\nstatic const int caldac_8800_udelay = 1;\r\nif (address >= num_caldac_channels) {\r\ncomedi_error(dev, "illegal caldac channel");\r\nreturn -1;\r\n}\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nregister_bits = 0;\r\nif (bitstream & bit)\r\nregister_bits |= SERIAL_DATA_IN_BIT;\r\nudelay(caldac_8800_udelay);\r\nwritew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);\r\nregister_bits |= SERIAL_CLOCK_BIT;\r\nudelay(caldac_8800_udelay);\r\nwritew(register_bits, priv(dev)->main_iobase + CALIBRATION_REG);\r\n}\r\nudelay(caldac_8800_udelay);\r\nwritew(SELECT_8800_BIT, priv(dev)->main_iobase + CALIBRATION_REG);\r\nudelay(caldac_8800_udelay);\r\nwritew(0, priv(dev)->main_iobase + CALIBRATION_REG);\r\nudelay(caldac_8800_udelay);\r\nreturn 0;\r\n}\r\nstatic int caldac_i2c_write(struct comedi_device *dev,\r\nunsigned int caldac_channel, unsigned int value)\r\n{\r\nuint8_t serial_bytes[3];\r\nuint8_t i2c_addr;\r\nenum pointer_bits {\r\nOFFSET_0_2 = 0x1,\r\nGAIN_0_2 = 0x2,\r\nOFFSET_1_3 = 0x4,\r\nGAIN_1_3 = 0x8,\r\n};\r\nenum data_bits {\r\nNOT_CLEAR_REGISTERS = 0x20,\r\n};\r\nswitch (caldac_channel) {\r\ncase 0:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_0_2;\r\nbreak;\r\ncase 1:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_1_3;\r\nbreak;\r\ncase 2:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_0_2;\r\nbreak;\r\ncase 3:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_1_3;\r\nbreak;\r\ncase 4:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = GAIN_0_2;\r\nbreak;\r\ncase 5:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = GAIN_1_3;\r\nbreak;\r\ncase 6:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = GAIN_0_2;\r\nbreak;\r\ncase 7:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = GAIN_1_3;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "invalid caldac channel\n");\r\nreturn -1;\r\nbreak;\r\n}\r\nserial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);\r\nserial_bytes[2] = value & 0xff;\r\ni2c_write(dev, i2c_addr, serial_bytes, 3);\r\nreturn 0;\r\n}\r\nstatic void i2c_set_sda(struct comedi_device *dev, int state)\r\n{\r\nstatic const int data_bit = CTL_EE_W;\r\nvoid __iomem *plx_control_addr = priv(dev)->plx9080_iobase +\r\nPLX_CONTROL_REG;\r\nif (state) {\r\npriv(dev)->plx_control_bits &= ~data_bit;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(i2c_high_udelay);\r\n} else {\r\npriv(dev)->plx_control_bits |= data_bit;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(i2c_low_udelay);\r\n}\r\n}\r\nstatic void i2c_set_scl(struct comedi_device *dev, int state)\r\n{\r\nstatic const int clock_bit = CTL_USERO;\r\nvoid __iomem *plx_control_addr = priv(dev)->plx9080_iobase +\r\nPLX_CONTROL_REG;\r\nif (state) {\r\npriv(dev)->plx_control_bits &= ~clock_bit;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(i2c_high_udelay);\r\n} else {\r\npriv(dev)->plx_control_bits |= clock_bit;\r\nwritel(priv(dev)->plx_control_bits, plx_control_addr);\r\nudelay(i2c_low_udelay);\r\n}\r\n}\r\nstatic void i2c_write_byte(struct comedi_device *dev, uint8_t byte)\r\n{\r\nuint8_t bit;\r\nunsigned int num_bits = 8;\r\nDEBUG_PRINT("writing to i2c byte 0x%x\n", byte);\r\nfor (bit = 1 << (num_bits - 1); bit; bit >>= 1) {\r\ni2c_set_scl(dev, 0);\r\nif ((byte & bit))\r\ni2c_set_sda(dev, 1);\r\nelse\r\ni2c_set_sda(dev, 0);\r\ni2c_set_scl(dev, 1);\r\n}\r\n}\r\nstatic int i2c_read_ack(struct comedi_device *dev)\r\n{\r\ni2c_set_scl(dev, 0);\r\ni2c_set_sda(dev, 1);\r\ni2c_set_scl(dev, 1);\r\nreturn 0;\r\n}\r\nstatic void i2c_start(struct comedi_device *dev)\r\n{\r\ni2c_set_scl(dev, 1);\r\ni2c_set_sda(dev, 1);\r\ni2c_set_sda(dev, 0);\r\n}\r\nstatic void i2c_stop(struct comedi_device *dev)\r\n{\r\ni2c_set_scl(dev, 0);\r\ni2c_set_sda(dev, 0);\r\ni2c_set_scl(dev, 1);\r\ni2c_set_sda(dev, 1);\r\n}\r\nstatic void i2c_write(struct comedi_device *dev, unsigned int address,\r\nconst uint8_t * data, unsigned int length)\r\n{\r\nunsigned int i;\r\nuint8_t bitstream;\r\nstatic const int read_bit = 0x1;\r\npriv(dev)->plx_control_bits &= ~CTL_EE_CS;\r\ni2c_stop(dev);\r\ni2c_start(dev);\r\nbitstream = (address << 1) & ~read_bit;\r\ni2c_write_byte(dev, bitstream);\r\nif (i2c_read_ack(dev) != 0) {\r\ncomedi_error(dev, "i2c write failed: no acknowledge");\r\ni2c_stop(dev);\r\nreturn;\r\n}\r\nfor (i = 0; i < length; i++) {\r\ni2c_write_byte(dev, data[i]);\r\nif (i2c_read_ack(dev) != 0) {\r\ncomedi_error(dev, "i2c write failed: no acknowledge");\r\ni2c_stop(dev);\r\nreturn;\r\n}\r\n}\r\ni2c_stop(dev);\r\n}
