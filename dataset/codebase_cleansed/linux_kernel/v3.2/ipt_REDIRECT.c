static int redirect_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct nf_nat_multi_range_compat *mr = par->targinfo;\r\nif (mr->range[0].flags & IP_NAT_RANGE_MAP_IPS) {\r\npr_debug("bad MAP_IPS.\n");\r\nreturn -EINVAL;\r\n}\r\nif (mr->rangesize != 1) {\r\npr_debug("bad rangesize %u.\n", mr->rangesize);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nredirect_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\n__be32 newdst;\r\nconst struct nf_nat_multi_range_compat *mr = par->targinfo;\r\nstruct nf_nat_range newrange;\r\nNF_CT_ASSERT(par->hooknum == NF_INET_PRE_ROUTING ||\r\npar->hooknum == NF_INET_LOCAL_OUT);\r\nct = nf_ct_get(skb, &ctinfo);\r\nNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\r\nif (par->hooknum == NF_INET_LOCAL_OUT)\r\nnewdst = htonl(0x7F000001);\r\nelse {\r\nstruct in_device *indev;\r\nstruct in_ifaddr *ifa;\r\nnewdst = 0;\r\nrcu_read_lock();\r\nindev = __in_dev_get_rcu(skb->dev);\r\nif (indev && (ifa = indev->ifa_list))\r\nnewdst = ifa->ifa_local;\r\nrcu_read_unlock();\r\nif (!newdst)\r\nreturn NF_DROP;\r\n}\r\nnewrange = ((struct nf_nat_range)\r\n{ mr->range[0].flags | IP_NAT_RANGE_MAP_IPS,\r\nnewdst, newdst,\r\nmr->range[0].min, mr->range[0].max });\r\nreturn nf_nat_setup_info(ct, &newrange, IP_NAT_MANIP_DST);\r\n}\r\nstatic int __init redirect_tg_init(void)\r\n{\r\nreturn xt_register_target(&redirect_tg_reg);\r\n}\r\nstatic void __exit redirect_tg_exit(void)\r\n{\r\nxt_unregister_target(&redirect_tg_reg);\r\n}
