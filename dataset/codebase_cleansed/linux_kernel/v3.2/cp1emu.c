static int isBranchInstr(mips_instruction * i)\r\n{\r\nswitch (MIPSInst_OPCODE(*i)) {\r\ncase spec_op:\r\nswitch (MIPSInst_FUNC(*i)) {\r\ncase jalr_op:\r\ncase jr_op:\r\nreturn 1;\r\n}\r\nbreak;\r\ncase bcond_op:\r\nswitch (MIPSInst_RT(*i)) {\r\ncase bltz_op:\r\ncase bgez_op:\r\ncase bltzl_op:\r\ncase bgezl_op:\r\ncase bltzal_op:\r\ncase bgezal_op:\r\ncase bltzall_op:\r\ncase bgezall_op:\r\nreturn 1;\r\n}\r\nbreak;\r\ncase j_op:\r\ncase jal_op:\r\ncase jalx_op:\r\ncase beq_op:\r\ncase bne_op:\r\ncase blez_op:\r\ncase bgtz_op:\r\ncase beql_op:\r\ncase bnel_op:\r\ncase blezl_op:\r\ncase bgtzl_op:\r\nreturn 1;\r\ncase cop0_op:\r\ncase cop1_op:\r\ncase cop2_op:\r\ncase cop1x_op:\r\nif (MIPSInst_RS(*i) == bc_op)\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int cop1_64bit(struct pt_regs *xcp)\r\n{\r\nif (cpu_has_fpu)\r\nreturn xcp->cp0_status & ST0_FR;\r\n#ifdef CONFIG_64BIT\r\nreturn !test_thread_flag(TIF_32BIT_REGS);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\r\nvoid *__user *fault_addr)\r\n{\r\nmips_instruction ir;\r\nunsigned long emulpc, contpc;\r\nunsigned int cond;\r\nif (!access_ok(VERIFY_READ, xcp->cp0_epc, sizeof(mips_instruction))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(ir, (mips_instruction __user *) xcp->cp0_epc)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\r\nreturn SIGSEGV;\r\n}\r\nif ((xcp->cp0_cause & CAUSEF_BD) && !isBranchInstr(&ir))\r\nxcp->cp0_cause &= ~CAUSEF_BD;\r\nif (xcp->cp0_cause & CAUSEF_BD) {\r\nemulpc = xcp->cp0_epc + 4;\r\nif (__compute_return_epc(xcp)) {\r\n#ifdef CP1DBG\r\nprintk("failed to emulate branch at %p\n",\r\n(void *) (xcp->cp0_epc));\r\n#endif\r\nreturn SIGILL;\r\n}\r\nif (!access_ok(VERIFY_READ, emulpc, sizeof(mips_instruction))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)emulpc;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(ir, (mips_instruction __user *) emulpc)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)emulpc;\r\nreturn SIGSEGV;\r\n}\r\ncontpc = xcp->cp0_epc;\r\nxcp->cp0_epc = emulpc - 4;\r\n} else {\r\nemulpc = xcp->cp0_epc;\r\ncontpc = xcp->cp0_epc + 4;\r\n}\r\nemul:\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, xcp, 0);\r\nMIPS_FPU_EMU_INC_STATS(emulated);\r\nswitch (MIPSInst_OPCODE(ir)) {\r\ncase ldc1_op:{\r\nu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\r\nMIPSInst_SIMM(ir));\r\nu64 val;\r\nMIPS_FPU_EMU_INC_STATS(loads);\r\nif (!access_ok(VERIFY_READ, va, sizeof(u64))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nDITOREG(val, MIPSInst_RT(ir));\r\nbreak;\r\n}\r\ncase sdc1_op:{\r\nu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\r\nMIPSInst_SIMM(ir));\r\nu64 val;\r\nMIPS_FPU_EMU_INC_STATS(stores);\r\nDIFROMREG(val, MIPSInst_RT(ir));\r\nif (!access_ok(VERIFY_WRITE, va, sizeof(u64))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (__put_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nbreak;\r\n}\r\ncase lwc1_op:{\r\nu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\r\nMIPSInst_SIMM(ir));\r\nu32 val;\r\nMIPS_FPU_EMU_INC_STATS(loads);\r\nif (!access_ok(VERIFY_READ, va, sizeof(u32))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nSITOREG(val, MIPSInst_RT(ir));\r\nbreak;\r\n}\r\ncase swc1_op:{\r\nu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\r\nMIPSInst_SIMM(ir));\r\nu32 val;\r\nMIPS_FPU_EMU_INC_STATS(stores);\r\nSIFROMREG(val, MIPSInst_RT(ir));\r\nif (!access_ok(VERIFY_WRITE, va, sizeof(u32))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (__put_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nbreak;\r\n}\r\ncase cop1_op:\r\nswitch (MIPSInst_RS(ir)) {\r\n#if defined(__mips64)\r\ncase dmfc_op:\r\nif (MIPSInst_RT(ir) != 0) {\r\nDIFROMREG(xcp->regs[MIPSInst_RT(ir)],\r\nMIPSInst_RD(ir));\r\n}\r\nbreak;\r\ncase dmtc_op:\r\nDITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\r\nbreak;\r\n#endif\r\ncase mfc_op:\r\nif (MIPSInst_RT(ir) != 0) {\r\nSIFROMREG(xcp->regs[MIPSInst_RT(ir)],\r\nMIPSInst_RD(ir));\r\n}\r\nbreak;\r\ncase mtc_op:\r\nSITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\r\nbreak;\r\ncase cfc_op:{\r\nu32 value;\r\nif (MIPSInst_RD(ir) == FPCREG_CSR) {\r\nvalue = ctx->fcr31;\r\nvalue = (value & ~FPU_CSR_RM) |\r\nmips_rm[modeindex(value)];\r\n#ifdef CSRTRACE\r\nprintk("%p gpr[%d]<-csr=%08x\n",\r\n(void *) (xcp->cp0_epc),\r\nMIPSInst_RT(ir), value);\r\n#endif\r\n}\r\nelse if (MIPSInst_RD(ir) == FPCREG_RID)\r\nvalue = 0;\r\nelse\r\nvalue = 0;\r\nif (MIPSInst_RT(ir))\r\nxcp->regs[MIPSInst_RT(ir)] = value;\r\nbreak;\r\n}\r\ncase ctc_op:{\r\nu32 value;\r\nif (MIPSInst_RT(ir) == 0)\r\nvalue = 0;\r\nelse\r\nvalue = xcp->regs[MIPSInst_RT(ir)];\r\nif (MIPSInst_RD(ir) == FPCREG_CSR) {\r\n#ifdef CSRTRACE\r\nprintk("%p gpr[%d]->csr=%08x\n",\r\n(void *) (xcp->cp0_epc),\r\nMIPSInst_RT(ir), value);\r\n#endif\r\nctx->fcr31 = (value &\r\n~(FPU_CSR_RSVD | FPU_CSR_RM)) |\r\nieee_rm[modeindex(value)];\r\n}\r\nif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\r\nreturn SIGFPE;\r\n}\r\nbreak;\r\n}\r\ncase bc_op:{\r\nint likely = 0;\r\nif (xcp->cp0_cause & CAUSEF_BD)\r\nreturn SIGILL;\r\n#if __mips >= 4\r\ncond = ctx->fcr31 & fpucondbit[MIPSInst_RT(ir) >> 2];\r\n#else\r\ncond = ctx->fcr31 & FPU_CSR_COND;\r\n#endif\r\nswitch (MIPSInst_RT(ir) & 3) {\r\ncase bcfl_op:\r\nlikely = 1;\r\ncase bcf_op:\r\ncond = !cond;\r\nbreak;\r\ncase bctl_op:\r\nlikely = 1;\r\ncase bct_op:\r\nbreak;\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nxcp->cp0_cause |= CAUSEF_BD;\r\nif (cond) {\r\nxcp->cp0_epc += 4;\r\ncontpc = (xcp->cp0_epc +\r\n(MIPSInst_SIMM(ir) << 2));\r\nif (!access_ok(VERIFY_READ, xcp->cp0_epc,\r\nsizeof(mips_instruction))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(ir,\r\n(mips_instruction __user *) xcp->cp0_epc)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\r\nreturn SIGSEGV;\r\n}\r\nswitch (MIPSInst_OPCODE(ir)) {\r\ncase lwc1_op:\r\ncase swc1_op:\r\n#if (__mips >= 2 || defined(__mips64))\r\ncase ldc1_op:\r\ncase sdc1_op:\r\n#endif\r\ncase cop1_op:\r\n#if __mips >= 4 && __mips != 32\r\ncase cop1x_op:\r\n#endif\r\ngoto emul;\r\n#if __mips >= 4\r\ncase spec_op:\r\nif (MIPSInst_FUNC(ir) == movc_op)\r\ngoto emul;\r\nbreak;\r\n#endif\r\n}\r\nreturn mips_dsemul(xcp, ir, contpc);\r\n}\r\nelse {\r\nif (likely) {\r\nxcp->cp0_epc += 4;\r\ncontpc += 4;\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nif (!(MIPSInst_RS(ir) & 0x10))\r\nreturn SIGILL;\r\n{\r\nint sig;\r\nif ((sig = fpu_emu(xcp, ctx, ir)))\r\nreturn sig;\r\n}\r\n}\r\nbreak;\r\n#if __mips >= 4 && __mips != 32\r\ncase cop1x_op:{\r\nint sig = fpux_emu(xcp, ctx, ir, fault_addr);\r\nif (sig)\r\nreturn sig;\r\nbreak;\r\n}\r\n#endif\r\n#if __mips >= 4\r\ncase spec_op:\r\nif (MIPSInst_FUNC(ir) != movc_op)\r\nreturn SIGILL;\r\ncond = fpucondbit[MIPSInst_RT(ir) >> 2];\r\nif (((ctx->fcr31 & cond) != 0) == ((MIPSInst_RT(ir) & 1) != 0))\r\nxcp->regs[MIPSInst_RD(ir)] =\r\nxcp->regs[MIPSInst_RS(ir)];\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nxcp->cp0_epc = contpc;\r\nxcp->cp0_cause &= ~CAUSEF_BD;\r\nreturn 0;\r\n}\r\nstatic ieee754dp fpemu_dp_recip(ieee754dp d)\r\n{\r\nreturn ieee754dp_div(ieee754dp_one(0), d);\r\n}\r\nstatic ieee754dp fpemu_dp_rsqrt(ieee754dp d)\r\n{\r\nreturn ieee754dp_div(ieee754dp_one(0), ieee754dp_sqrt(d));\r\n}\r\nstatic ieee754sp fpemu_sp_recip(ieee754sp s)\r\n{\r\nreturn ieee754sp_div(ieee754sp_one(0), s);\r\n}\r\nstatic ieee754sp fpemu_sp_rsqrt(ieee754sp s)\r\n{\r\nreturn ieee754sp_div(ieee754sp_one(0), ieee754sp_sqrt(s));\r\n}\r\nstatic int fpux_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\r\nmips_instruction ir, void *__user *fault_addr)\r\n{\r\nunsigned rcsr = 0;\r\nMIPS_FPU_EMU_INC_STATS(cp1xops);\r\nswitch (MIPSInst_FMA_FFMT(ir)) {\r\ncase s_fmt:{\r\nieee754sp(*handler) (ieee754sp, ieee754sp, ieee754sp);\r\nieee754sp fd, fr, fs, ft;\r\nu32 __user *va;\r\nu32 val;\r\nswitch (MIPSInst_FUNC(ir)) {\r\ncase lwxc1_op:\r\nva = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +\r\nxcp->regs[MIPSInst_FT(ir)]);\r\nMIPS_FPU_EMU_INC_STATS(loads);\r\nif (!access_ok(VERIFY_READ, va, sizeof(u32))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nSITOREG(val, MIPSInst_FD(ir));\r\nbreak;\r\ncase swxc1_op:\r\nva = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +\r\nxcp->regs[MIPSInst_FT(ir)]);\r\nMIPS_FPU_EMU_INC_STATS(stores);\r\nSIFROMREG(val, MIPSInst_FS(ir));\r\nif (!access_ok(VERIFY_WRITE, va, sizeof(u32))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (put_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nbreak;\r\ncase madd_s_op:\r\nhandler = fpemu_sp_madd;\r\ngoto scoptop;\r\ncase msub_s_op:\r\nhandler = fpemu_sp_msub;\r\ngoto scoptop;\r\ncase nmadd_s_op:\r\nhandler = fpemu_sp_nmadd;\r\ngoto scoptop;\r\ncase nmsub_s_op:\r\nhandler = fpemu_sp_nmsub;\r\ngoto scoptop;\r\nscoptop:\r\nSPFROMREG(fr, MIPSInst_FR(ir));\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nSPFROMREG(ft, MIPSInst_FT(ir));\r\nfd = (*handler) (fr, fs, ft);\r\nSPTOREG(fd, MIPSInst_FD(ir));\r\ncopcsr:\r\nif (ieee754_cxtest(IEEE754_INEXACT))\r\nrcsr |= FPU_CSR_INE_X | FPU_CSR_INE_S;\r\nif (ieee754_cxtest(IEEE754_UNDERFLOW))\r\nrcsr |= FPU_CSR_UDF_X | FPU_CSR_UDF_S;\r\nif (ieee754_cxtest(IEEE754_OVERFLOW))\r\nrcsr |= FPU_CSR_OVF_X | FPU_CSR_OVF_S;\r\nif (ieee754_cxtest(IEEE754_INVALID_OPERATION))\r\nrcsr |= FPU_CSR_INV_X | FPU_CSR_INV_S;\r\nctx->fcr31 = (ctx->fcr31 & ~FPU_CSR_ALL_X) | rcsr;\r\nif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\r\nreturn SIGFPE;\r\n}\r\nbreak;\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nbreak;\r\n}\r\ncase d_fmt:{\r\nieee754dp(*handler) (ieee754dp, ieee754dp, ieee754dp);\r\nieee754dp fd, fr, fs, ft;\r\nu64 __user *va;\r\nu64 val;\r\nswitch (MIPSInst_FUNC(ir)) {\r\ncase ldxc1_op:\r\nva = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +\r\nxcp->regs[MIPSInst_FT(ir)]);\r\nMIPS_FPU_EMU_INC_STATS(loads);\r\nif (!access_ok(VERIFY_READ, va, sizeof(u64))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nDITOREG(val, MIPSInst_FD(ir));\r\nbreak;\r\ncase sdxc1_op:\r\nva = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +\r\nxcp->regs[MIPSInst_FT(ir)]);\r\nMIPS_FPU_EMU_INC_STATS(stores);\r\nDIFROMREG(val, MIPSInst_FS(ir));\r\nif (!access_ok(VERIFY_WRITE, va, sizeof(u64))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGBUS;\r\n}\r\nif (__put_user(val, va)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = va;\r\nreturn SIGSEGV;\r\n}\r\nbreak;\r\ncase madd_d_op:\r\nhandler = fpemu_dp_madd;\r\ngoto dcoptop;\r\ncase msub_d_op:\r\nhandler = fpemu_dp_msub;\r\ngoto dcoptop;\r\ncase nmadd_d_op:\r\nhandler = fpemu_dp_nmadd;\r\ngoto dcoptop;\r\ncase nmsub_d_op:\r\nhandler = fpemu_dp_nmsub;\r\ngoto dcoptop;\r\ndcoptop:\r\nDPFROMREG(fr, MIPSInst_FR(ir));\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nDPFROMREG(ft, MIPSInst_FT(ir));\r\nfd = (*handler) (fr, fs, ft);\r\nDPTOREG(fd, MIPSInst_FD(ir));\r\ngoto copcsr;\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nbreak;\r\n}\r\ncase 0x7:\r\nif (MIPSInst_FUNC(ir) != pfetch_op) {\r\nreturn SIGILL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\r\nmips_instruction ir)\r\n{\r\nint rfmt;\r\nunsigned rcsr = 0;\r\nunsigned cond;\r\nunion {\r\nieee754dp d;\r\nieee754sp s;\r\nint w;\r\n#ifdef __mips64\r\ns64 l;\r\n#endif\r\n} rv;\r\nMIPS_FPU_EMU_INC_STATS(cp1ops);\r\nswitch (rfmt = (MIPSInst_FFMT(ir) & 0xf)) {\r\ncase s_fmt:{\r\nunion {\r\nieee754sp(*b) (ieee754sp, ieee754sp);\r\nieee754sp(*u) (ieee754sp);\r\n} handler;\r\nswitch (MIPSInst_FUNC(ir)) {\r\ncase fadd_op:\r\nhandler.b = ieee754sp_add;\r\ngoto scopbop;\r\ncase fsub_op:\r\nhandler.b = ieee754sp_sub;\r\ngoto scopbop;\r\ncase fmul_op:\r\nhandler.b = ieee754sp_mul;\r\ngoto scopbop;\r\ncase fdiv_op:\r\nhandler.b = ieee754sp_div;\r\ngoto scopbop;\r\n#if __mips >= 2 || defined(__mips64)\r\ncase fsqrt_op:\r\nhandler.u = ieee754sp_sqrt;\r\ngoto scopuop;\r\n#endif\r\n#if __mips >= 4 && __mips != 32\r\ncase frsqrt_op:\r\nhandler.u = fpemu_sp_rsqrt;\r\ngoto scopuop;\r\ncase frecip_op:\r\nhandler.u = fpemu_sp_recip;\r\ngoto scopuop;\r\n#endif\r\n#if __mips >= 4\r\ncase fmovc_op:\r\ncond = fpucondbit[MIPSInst_FT(ir) >> 2];\r\nif (((ctx->fcr31 & cond) != 0) !=\r\n((MIPSInst_FT(ir) & 1) != 0))\r\nreturn 0;\r\nSPFROMREG(rv.s, MIPSInst_FS(ir));\r\nbreak;\r\ncase fmovz_op:\r\nif (xcp->regs[MIPSInst_FT(ir)] != 0)\r\nreturn 0;\r\nSPFROMREG(rv.s, MIPSInst_FS(ir));\r\nbreak;\r\ncase fmovn_op:\r\nif (xcp->regs[MIPSInst_FT(ir)] == 0)\r\nreturn 0;\r\nSPFROMREG(rv.s, MIPSInst_FS(ir));\r\nbreak;\r\n#endif\r\ncase fabs_op:\r\nhandler.u = ieee754sp_abs;\r\ngoto scopuop;\r\ncase fneg_op:\r\nhandler.u = ieee754sp_neg;\r\ngoto scopuop;\r\ncase fmov_op:\r\nSPFROMREG(rv.s, MIPSInst_FS(ir));\r\ngoto copcsr;\r\nscopbop:\r\n{\r\nieee754sp fs, ft;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nSPFROMREG(ft, MIPSInst_FT(ir));\r\nrv.s = (*handler.b) (fs, ft);\r\ngoto copcsr;\r\n}\r\nscopuop:\r\n{\r\nieee754sp fs;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.s = (*handler.u) (fs);\r\ngoto copcsr;\r\n}\r\ncopcsr:\r\nif (ieee754_cxtest(IEEE754_INEXACT))\r\nrcsr |= FPU_CSR_INE_X | FPU_CSR_INE_S;\r\nif (ieee754_cxtest(IEEE754_UNDERFLOW))\r\nrcsr |= FPU_CSR_UDF_X | FPU_CSR_UDF_S;\r\nif (ieee754_cxtest(IEEE754_OVERFLOW))\r\nrcsr |= FPU_CSR_OVF_X | FPU_CSR_OVF_S;\r\nif (ieee754_cxtest(IEEE754_ZERO_DIVIDE))\r\nrcsr |= FPU_CSR_DIV_X | FPU_CSR_DIV_S;\r\nif (ieee754_cxtest(IEEE754_INVALID_OPERATION))\r\nrcsr |= FPU_CSR_INV_X | FPU_CSR_INV_S;\r\nbreak;\r\ncase fcvts_op:\r\nreturn SIGILL;\r\ncase fcvtd_op:{\r\nieee754sp fs;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.d = ieee754dp_fsp(fs);\r\nrfmt = d_fmt;\r\ngoto copcsr;\r\n}\r\ncase fcvtw_op:{\r\nieee754sp fs;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.w = ieee754sp_tint(fs);\r\nrfmt = w_fmt;\r\ngoto copcsr;\r\n}\r\n#if __mips >= 2 || defined(__mips64)\r\ncase fround_op:\r\ncase ftrunc_op:\r\ncase fceil_op:\r\ncase ffloor_op:{\r\nunsigned int oldrm = ieee754_csr.rm;\r\nieee754sp fs;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\r\nrv.w = ieee754sp_tint(fs);\r\nieee754_csr.rm = oldrm;\r\nrfmt = w_fmt;\r\ngoto copcsr;\r\n}\r\n#endif\r\n#if defined(__mips64)\r\ncase fcvtl_op:{\r\nieee754sp fs;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.l = ieee754sp_tlong(fs);\r\nrfmt = l_fmt;\r\ngoto copcsr;\r\n}\r\ncase froundl_op:\r\ncase ftruncl_op:\r\ncase fceill_op:\r\ncase ffloorl_op:{\r\nunsigned int oldrm = ieee754_csr.rm;\r\nieee754sp fs;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\r\nrv.l = ieee754sp_tlong(fs);\r\nieee754_csr.rm = oldrm;\r\nrfmt = l_fmt;\r\ngoto copcsr;\r\n}\r\n#endif\r\ndefault:\r\nif (MIPSInst_FUNC(ir) >= fcmp_op) {\r\nunsigned cmpop = MIPSInst_FUNC(ir) - fcmp_op;\r\nieee754sp fs, ft;\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nSPFROMREG(ft, MIPSInst_FT(ir));\r\nrv.w = ieee754sp_cmp(fs, ft,\r\ncmptab[cmpop & 0x7], cmpop & 0x8);\r\nrfmt = -1;\r\nif ((cmpop & 0x8) && ieee754_cxtest\r\n(IEEE754_INVALID_OPERATION))\r\nrcsr = FPU_CSR_INV_X | FPU_CSR_INV_S;\r\nelse\r\ngoto copcsr;\r\n}\r\nelse {\r\nreturn SIGILL;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase d_fmt:{\r\nunion {\r\nieee754dp(*b) (ieee754dp, ieee754dp);\r\nieee754dp(*u) (ieee754dp);\r\n} handler;\r\nswitch (MIPSInst_FUNC(ir)) {\r\ncase fadd_op:\r\nhandler.b = ieee754dp_add;\r\ngoto dcopbop;\r\ncase fsub_op:\r\nhandler.b = ieee754dp_sub;\r\ngoto dcopbop;\r\ncase fmul_op:\r\nhandler.b = ieee754dp_mul;\r\ngoto dcopbop;\r\ncase fdiv_op:\r\nhandler.b = ieee754dp_div;\r\ngoto dcopbop;\r\n#if __mips >= 2 || defined(__mips64)\r\ncase fsqrt_op:\r\nhandler.u = ieee754dp_sqrt;\r\ngoto dcopuop;\r\n#endif\r\n#if __mips >= 4 && __mips != 32\r\ncase frsqrt_op:\r\nhandler.u = fpemu_dp_rsqrt;\r\ngoto dcopuop;\r\ncase frecip_op:\r\nhandler.u = fpemu_dp_recip;\r\ngoto dcopuop;\r\n#endif\r\n#if __mips >= 4\r\ncase fmovc_op:\r\ncond = fpucondbit[MIPSInst_FT(ir) >> 2];\r\nif (((ctx->fcr31 & cond) != 0) !=\r\n((MIPSInst_FT(ir) & 1) != 0))\r\nreturn 0;\r\nDPFROMREG(rv.d, MIPSInst_FS(ir));\r\nbreak;\r\ncase fmovz_op:\r\nif (xcp->regs[MIPSInst_FT(ir)] != 0)\r\nreturn 0;\r\nDPFROMREG(rv.d, MIPSInst_FS(ir));\r\nbreak;\r\ncase fmovn_op:\r\nif (xcp->regs[MIPSInst_FT(ir)] == 0)\r\nreturn 0;\r\nDPFROMREG(rv.d, MIPSInst_FS(ir));\r\nbreak;\r\n#endif\r\ncase fabs_op:\r\nhandler.u = ieee754dp_abs;\r\ngoto dcopuop;\r\ncase fneg_op:\r\nhandler.u = ieee754dp_neg;\r\ngoto dcopuop;\r\ncase fmov_op:\r\nDPFROMREG(rv.d, MIPSInst_FS(ir));\r\ngoto copcsr;\r\ndcopbop:{\r\nieee754dp fs, ft;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nDPFROMREG(ft, MIPSInst_FT(ir));\r\nrv.d = (*handler.b) (fs, ft);\r\ngoto copcsr;\r\n}\r\ndcopuop:{\r\nieee754dp fs;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.d = (*handler.u) (fs);\r\ngoto copcsr;\r\n}\r\ncase fcvts_op:{\r\nieee754dp fs;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.s = ieee754sp_fdp(fs);\r\nrfmt = s_fmt;\r\ngoto copcsr;\r\n}\r\ncase fcvtd_op:\r\nreturn SIGILL;\r\ncase fcvtw_op:{\r\nieee754dp fs;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.w = ieee754dp_tint(fs);\r\nrfmt = w_fmt;\r\ngoto copcsr;\r\n}\r\n#if __mips >= 2 || defined(__mips64)\r\ncase fround_op:\r\ncase ftrunc_op:\r\ncase fceil_op:\r\ncase ffloor_op:{\r\nunsigned int oldrm = ieee754_csr.rm;\r\nieee754dp fs;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\r\nrv.w = ieee754dp_tint(fs);\r\nieee754_csr.rm = oldrm;\r\nrfmt = w_fmt;\r\ngoto copcsr;\r\n}\r\n#endif\r\n#if defined(__mips64)\r\ncase fcvtl_op:{\r\nieee754dp fs;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.l = ieee754dp_tlong(fs);\r\nrfmt = l_fmt;\r\ngoto copcsr;\r\n}\r\ncase froundl_op:\r\ncase ftruncl_op:\r\ncase fceill_op:\r\ncase ffloorl_op:{\r\nunsigned int oldrm = ieee754_csr.rm;\r\nieee754dp fs;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\r\nrv.l = ieee754dp_tlong(fs);\r\nieee754_csr.rm = oldrm;\r\nrfmt = l_fmt;\r\ngoto copcsr;\r\n}\r\n#endif\r\ndefault:\r\nif (MIPSInst_FUNC(ir) >= fcmp_op) {\r\nunsigned cmpop = MIPSInst_FUNC(ir) - fcmp_op;\r\nieee754dp fs, ft;\r\nDPFROMREG(fs, MIPSInst_FS(ir));\r\nDPFROMREG(ft, MIPSInst_FT(ir));\r\nrv.w = ieee754dp_cmp(fs, ft,\r\ncmptab[cmpop & 0x7], cmpop & 0x8);\r\nrfmt = -1;\r\nif ((cmpop & 0x8)\r\n&&\r\nieee754_cxtest\r\n(IEEE754_INVALID_OPERATION))\r\nrcsr = FPU_CSR_INV_X | FPU_CSR_INV_S;\r\nelse\r\ngoto copcsr;\r\n}\r\nelse {\r\nreturn SIGILL;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase w_fmt:{\r\nieee754sp fs;\r\nswitch (MIPSInst_FUNC(ir)) {\r\ncase fcvts_op:\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.s = ieee754sp_fint(fs.bits);\r\nrfmt = s_fmt;\r\ngoto copcsr;\r\ncase fcvtd_op:\r\nSPFROMREG(fs, MIPSInst_FS(ir));\r\nrv.d = ieee754dp_fint(fs.bits);\r\nrfmt = d_fmt;\r\ngoto copcsr;\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nbreak;\r\n}\r\n#if defined(__mips64)\r\ncase l_fmt:{\r\nswitch (MIPSInst_FUNC(ir)) {\r\ncase fcvts_op:\r\nrv.s = ieee754sp_flong(ctx->fpr[MIPSInst_FS(ir)]);\r\nrfmt = s_fmt;\r\ngoto copcsr;\r\ncase fcvtd_op:\r\nrv.d = ieee754dp_flong(ctx->fpr[MIPSInst_FS(ir)]);\r\nrfmt = d_fmt;\r\ngoto copcsr;\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nctx->fcr31 = (ctx->fcr31 & ~FPU_CSR_ALL_X) | rcsr;\r\nif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\r\nreturn SIGFPE;\r\n}\r\nswitch (rfmt) {\r\ncase -1:{\r\n#if __mips >= 4\r\ncond = fpucondbit[MIPSInst_FD(ir) >> 2];\r\n#else\r\ncond = FPU_CSR_COND;\r\n#endif\r\nif (rv.w)\r\nctx->fcr31 |= cond;\r\nelse\r\nctx->fcr31 &= ~cond;\r\nbreak;\r\n}\r\ncase d_fmt:\r\nDPTOREG(rv.d, MIPSInst_FD(ir));\r\nbreak;\r\ncase s_fmt:\r\nSPTOREG(rv.s, MIPSInst_FD(ir));\r\nbreak;\r\ncase w_fmt:\r\nSITOREG(rv.w, MIPSInst_FD(ir));\r\nbreak;\r\n#if defined(__mips64)\r\ncase l_fmt:\r\nDITOREG(rv.l, MIPSInst_FD(ir));\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn SIGILL;\r\n}\r\nreturn 0;\r\n}\r\nint fpu_emulator_cop1Handler(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\r\nint has_fpu, void *__user *fault_addr)\r\n{\r\nunsigned long oldepc, prevepc;\r\nmips_instruction insn;\r\nint sig = 0;\r\noldepc = xcp->cp0_epc;\r\ndo {\r\nprevepc = xcp->cp0_epc;\r\nif (!access_ok(VERIFY_READ, xcp->cp0_epc, sizeof(mips_instruction))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\r\nreturn SIGBUS;\r\n}\r\nif (__get_user(insn, (mips_instruction __user *) xcp->cp0_epc)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\n*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\r\nreturn SIGSEGV;\r\n}\r\nif (insn == 0)\r\nxcp->cp0_epc += 4;\r\nelse {\r\nieee754_csr.rm = ieee_rm[ieee754_csr.rm];\r\nsig = cop1Emulate(xcp, ctx, fault_addr);\r\nieee754_csr.rm = mips_rm[ieee754_csr.rm];\r\n}\r\nif (has_fpu)\r\nbreak;\r\nif (sig)\r\nbreak;\r\ncond_resched();\r\n} while (xcp->cp0_epc > prevepc);\r\nif (sig == SIGILL && xcp->cp0_epc != oldepc)\r\nsig = 0;\r\nreturn sig;\r\n}\r\nstatic int fpuemu_stat_get(void *data, u64 *val)\r\n{\r\nint cpu;\r\nunsigned long sum = 0;\r\nfor_each_online_cpu(cpu) {\r\nstruct mips_fpu_emulator_stats *ps;\r\nlocal_t *pv;\r\nps = &per_cpu(fpuemustats, cpu);\r\npv = (void *)ps + (unsigned long)data;\r\nsum += local_read(pv);\r\n}\r\n*val = sum;\r\nreturn 0;\r\n}\r\nstatic int __init debugfs_fpuemu(void)\r\n{\r\nstruct dentry *d, *dir;\r\nif (!mips_debugfs_dir)\r\nreturn -ENODEV;\r\ndir = debugfs_create_dir("fpuemustats", mips_debugfs_dir);\r\nif (!dir)\r\nreturn -ENOMEM;\r\n#define FPU_STAT_CREATE(M) \\r\ndo { \\r\nd = debugfs_create_file(#M , S_IRUGO, dir, \\r\n(void *)offsetof(struct mips_fpu_emulator_stats, M), \\r\n&fops_fpuemu_stat); \\r\nif (!d) \\r\nreturn -ENOMEM; \\r\n} while (0)\r\nFPU_STAT_CREATE(emulated);\r\nFPU_STAT_CREATE(loads);\r\nFPU_STAT_CREATE(stores);\r\nFPU_STAT_CREATE(cp1ops);\r\nFPU_STAT_CREATE(cp1xops);\r\nFPU_STAT_CREATE(errors);\r\nreturn 0;\r\n}
