static int perf_event__repipe_synth(union perf_event *event,\r\nstruct perf_session *session __used)\r\n{\r\nuint32_t size;\r\nvoid *buf = event;\r\nsize = event->header.size;\r\nwhile (size) {\r\nint ret = write(STDOUT_FILENO, buf, size);\r\nif (ret < 0)\r\nreturn -errno;\r\nsize -= ret;\r\nbuf += ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_event__repipe(union perf_event *event,\r\nstruct perf_sample *sample __used,\r\nstruct perf_session *session)\r\n{\r\nreturn perf_event__repipe_synth(event, session);\r\n}\r\nstatic int perf_event__repipe_sample(union perf_event *event,\r\nstruct perf_sample *sample __used,\r\nstruct perf_evsel *evsel __used,\r\nstruct perf_session *session)\r\n{\r\nreturn perf_event__repipe_synth(event, session);\r\n}\r\nstatic int perf_event__repipe_mmap(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_session *session)\r\n{\r\nint err;\r\nerr = perf_event__process_mmap(event, sample, session);\r\nperf_event__repipe(event, sample, session);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_task(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_session *session)\r\n{\r\nint err;\r\nerr = perf_event__process_task(event, sample, session);\r\nperf_event__repipe(event, sample, session);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_tracing_data(union perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nint err;\r\nperf_event__repipe_synth(event, session);\r\nerr = perf_event__process_tracing_data(event, session);\r\nreturn err;\r\n}\r\nstatic int dso__read_build_id(struct dso *self)\r\n{\r\nif (self->has_build_id)\r\nreturn 0;\r\nif (filename__read_build_id(self->long_name, self->build_id,\r\nsizeof(self->build_id)) > 0) {\r\nself->has_build_id = true;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int dso__inject_build_id(struct dso *self, struct perf_session *session)\r\n{\r\nu16 misc = PERF_RECORD_MISC_USER;\r\nstruct machine *machine;\r\nint err;\r\nif (dso__read_build_id(self) < 0) {\r\npr_debug("no build_id found for %s\n", self->long_name);\r\nreturn -1;\r\n}\r\nmachine = perf_session__find_host_machine(session);\r\nif (machine == NULL) {\r\npr_err("Can't find machine for session\n");\r\nreturn -1;\r\n}\r\nif (self->kernel)\r\nmisc = PERF_RECORD_MISC_KERNEL;\r\nerr = perf_event__synthesize_build_id(self, misc, perf_event__repipe,\r\nmachine, session);\r\nif (err) {\r\npr_err("Can't synthesize build_id event for %s\n", self->long_name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_event__inject_buildid(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __used,\r\nstruct perf_session *session)\r\n{\r\nstruct addr_location al;\r\nstruct thread *thread;\r\nu8 cpumode;\r\ncpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nthread = perf_session__findnew(session, event->ip.pid);\r\nif (thread == NULL) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\ngoto repipe;\r\n}\r\nthread__find_addr_map(thread, session, cpumode, MAP__FUNCTION,\r\nevent->ip.pid, event->ip.ip, &al);\r\nif (al.map != NULL) {\r\nif (!al.map->dso->hit) {\r\nal.map->dso->hit = 1;\r\nif (map__load(al.map, NULL) >= 0) {\r\ndso__inject_build_id(al.map->dso, session);\r\n} else\r\npr_warning("no symbols found in %s, maybe "\r\n"install a debug package?\n",\r\nal.map->dso->long_name);\r\n}\r\n}\r\nrepipe:\r\nperf_event__repipe(event, sample, session);\r\nreturn 0;\r\n}\r\nstatic int __cmd_inject(void)\r\n{\r\nstruct perf_session *session;\r\nint ret = -EINVAL;\r\nsignal(SIGINT, sig_handler);\r\nif (inject_build_ids) {\r\ninject_ops.sample = perf_event__inject_buildid;\r\ninject_ops.mmap = perf_event__repipe_mmap;\r\ninject_ops.fork = perf_event__repipe_task;\r\ninject_ops.tracing_data = perf_event__repipe_tracing_data;\r\n}\r\nsession = perf_session__new(input_name, O_RDONLY, false, true, &inject_ops);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nret = perf_session__process_events(session, &inject_ops);\r\nperf_session__delete(session);\r\nreturn ret;\r\n}\r\nint cmd_inject(int argc, const char **argv, const char *prefix __used)\r\n{\r\nargc = parse_options(argc, argv, options, report_usage, 0);\r\nif (argc)\r\nusage_with_options(report_usage, options);\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nreturn __cmd_inject();\r\n}
