struct aoedev *\r\naoedev_by_aoeaddr(int maj, int min)\r\n{\r\nstruct aoedev *d;\r\nulong flags;\r\nspin_lock_irqsave(&devlist_lock, flags);\r\nfor (d=devlist; d; d=d->next)\r\nif (d->aoemajor == maj && d->aoeminor == min)\r\nbreak;\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\nreturn d;\r\n}\r\nstatic void\r\ndummy_timer(ulong vp)\r\n{\r\nstruct aoedev *d;\r\nd = (struct aoedev *)vp;\r\nif (d->flags & DEVFL_TKILL)\r\nreturn;\r\nd->timer.expires = jiffies + HZ;\r\nadd_timer(&d->timer);\r\n}\r\nvoid\r\naoedev_downdev(struct aoedev *d)\r\n{\r\nstruct aoetgt **t, **te;\r\nstruct frame *f, *e;\r\nstruct buf *buf;\r\nstruct bio *bio;\r\nt = d->targets;\r\nte = t + NTARGETS;\r\nfor (; t < te && *t; t++) {\r\nf = (*t)->frames;\r\ne = f + (*t)->nframes;\r\nfor (; f < e; f->tag = FREETAG, f->buf = NULL, f++) {\r\nif (f->tag == FREETAG || f->buf == NULL)\r\ncontinue;\r\nbuf = f->buf;\r\nbio = buf->bio;\r\nif (--buf->nframesout == 0\r\n&& buf != d->inprocess) {\r\nmempool_free(buf, d->bufpool);\r\nbio_endio(bio, -EIO);\r\n}\r\n}\r\n(*t)->maxout = (*t)->nframes;\r\n(*t)->nout = 0;\r\n}\r\nbuf = d->inprocess;\r\nif (buf) {\r\nbio = buf->bio;\r\nmempool_free(buf, d->bufpool);\r\nbio_endio(bio, -EIO);\r\n}\r\nd->inprocess = NULL;\r\nd->htgt = NULL;\r\nwhile (!list_empty(&d->bufq)) {\r\nbuf = container_of(d->bufq.next, struct buf, bufs);\r\nlist_del(d->bufq.next);\r\nbio = buf->bio;\r\nmempool_free(buf, d->bufpool);\r\nbio_endio(bio, -EIO);\r\n}\r\nif (d->gd)\r\nset_capacity(d->gd, 0);\r\nd->flags &= ~DEVFL_UP;\r\n}\r\nstatic void\r\naoedev_freedev(struct aoedev *d)\r\n{\r\nstruct aoetgt **t, **e;\r\ncancel_work_sync(&d->work);\r\nif (d->gd) {\r\naoedisk_rm_sysfs(d);\r\ndel_gendisk(d->gd);\r\nput_disk(d->gd);\r\n}\r\nt = d->targets;\r\ne = t + NTARGETS;\r\nfor (; t < e && *t; t++)\r\nfreetgt(d, *t);\r\nif (d->bufpool)\r\nmempool_destroy(d->bufpool);\r\nskbpoolfree(d);\r\nblk_cleanup_queue(d->blkq);\r\nkfree(d);\r\n}\r\nint\r\naoedev_flush(const char __user *str, size_t cnt)\r\n{\r\nulong flags;\r\nstruct aoedev *d, **dd;\r\nstruct aoedev *rmd = NULL;\r\nchar buf[16];\r\nint all = 0;\r\nif (cnt >= 3) {\r\nif (cnt > sizeof buf)\r\ncnt = sizeof buf;\r\nif (copy_from_user(buf, str, cnt))\r\nreturn -EFAULT;\r\nall = !strncmp(buf, "all", 3);\r\n}\r\nspin_lock_irqsave(&devlist_lock, flags);\r\ndd = &devlist;\r\nwhile ((d = *dd)) {\r\nspin_lock(&d->lock);\r\nif ((!all && (d->flags & DEVFL_UP))\r\n|| (d->flags & (DEVFL_GDALLOC|DEVFL_NEWSIZE))\r\n|| d->nopen) {\r\nspin_unlock(&d->lock);\r\ndd = &d->next;\r\ncontinue;\r\n}\r\n*dd = d->next;\r\naoedev_downdev(d);\r\nd->flags |= DEVFL_TKILL;\r\nspin_unlock(&d->lock);\r\nd->next = rmd;\r\nrmd = d;\r\n}\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\nwhile ((d = rmd)) {\r\nrmd = d->next;\r\ndel_timer_sync(&d->timer);\r\naoedev_freedev(d);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nskbfree(struct sk_buff *skb)\r\n{\r\nenum { Sms = 100, Tms = 3*1000};\r\nint i = Tms / Sms;\r\nif (skb == NULL)\r\nreturn;\r\nwhile (atomic_read(&skb_shinfo(skb)->dataref) != 1 && i-- > 0)\r\nmsleep(Sms);\r\nif (i < 0) {\r\nprintk(KERN_ERR\r\n"aoe: %s holds ref: %s\n",\r\nskb->dev ? skb->dev->name : "netif",\r\n"cannot free skb -- memory leaked.");\r\nreturn;\r\n}\r\nskb_shinfo(skb)->nr_frags = skb->data_len = 0;\r\nskb_trim(skb, 0);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nskbpoolfree(struct aoedev *d)\r\n{\r\nstruct sk_buff *skb, *tmp;\r\nskb_queue_walk_safe(&d->skbpool, skb, tmp)\r\nskbfree(skb);\r\n__skb_queue_head_init(&d->skbpool);\r\n}\r\nstruct aoedev *\r\naoedev_by_sysminor_m(ulong sysminor)\r\n{\r\nstruct aoedev *d;\r\nulong flags;\r\nspin_lock_irqsave(&devlist_lock, flags);\r\nfor (d=devlist; d; d=d->next)\r\nif (d->sysminor == sysminor)\r\nbreak;\r\nif (d)\r\ngoto out;\r\nd = kcalloc(1, sizeof *d, GFP_ATOMIC);\r\nif (!d)\r\ngoto out;\r\nINIT_WORK(&d->work, aoecmd_sleepwork);\r\nspin_lock_init(&d->lock);\r\nskb_queue_head_init(&d->sendq);\r\nskb_queue_head_init(&d->skbpool);\r\ninit_timer(&d->timer);\r\nd->timer.data = (ulong) d;\r\nd->timer.function = dummy_timer;\r\nd->timer.expires = jiffies + HZ;\r\nadd_timer(&d->timer);\r\nd->bufpool = NULL;\r\nd->tgt = d->targets;\r\nINIT_LIST_HEAD(&d->bufq);\r\nd->sysminor = sysminor;\r\nd->aoemajor = AOEMAJOR(sysminor);\r\nd->aoeminor = AOEMINOR(sysminor);\r\nd->mintimer = MINTIMER;\r\nd->next = devlist;\r\ndevlist = d;\r\nout:\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\nreturn d;\r\n}\r\nstatic void\r\nfreetgt(struct aoedev *d, struct aoetgt *t)\r\n{\r\nstruct frame *f, *e;\r\nf = t->frames;\r\ne = f + t->nframes;\r\nfor (; f < e; f++)\r\nskbfree(f->skb);\r\nkfree(t->frames);\r\nkfree(t);\r\n}\r\nvoid\r\naoedev_exit(void)\r\n{\r\nstruct aoedev *d;\r\nulong flags;\r\nwhile ((d = devlist)) {\r\ndevlist = d->next;\r\nspin_lock_irqsave(&d->lock, flags);\r\naoedev_downdev(d);\r\nd->flags |= DEVFL_TKILL;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\ndel_timer_sync(&d->timer);\r\naoedev_freedev(d);\r\n}\r\n}\r\nint __init\r\naoedev_init(void)\r\n{\r\nreturn 0;\r\n}
