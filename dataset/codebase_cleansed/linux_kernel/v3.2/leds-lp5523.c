static inline struct lp5523_led *cdev_to_led(struct led_classdev *cdev)\r\n{\r\nreturn container_of(cdev, struct lp5523_led, cdev);\r\n}\r\nstatic inline struct lp5523_chip *engine_to_lp5523(struct lp5523_engine *engine)\r\n{\r\nreturn container_of(engine, struct lp5523_chip,\r\nengines[engine->id - 1]);\r\n}\r\nstatic inline struct lp5523_chip *led_to_lp5523(struct lp5523_led *led)\r\n{\r\nreturn container_of(led, struct lp5523_chip,\r\nleds[led->id]);\r\n}\r\nstatic int lp5523_write(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int lp5523_read(struct i2c_client *client, u8 reg, u8 *buf)\r\n{\r\ns32 ret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\nreturn -EIO;\r\n*buf = ret;\r\nreturn 0;\r\n}\r\nstatic int lp5523_detect(struct i2c_client *client)\r\n{\r\nint ret;\r\nu8 buf;\r\nret = lp5523_write(client, LP5523_REG_ENABLE, 0x40);\r\nif (ret)\r\nreturn ret;\r\nret = lp5523_read(client, LP5523_REG_ENABLE, &buf);\r\nif (ret)\r\nreturn ret;\r\nif (buf == 0x40)\r\nreturn 0;\r\nelse\r\nreturn -ENODEV;\r\n}\r\nstatic int lp5523_configure(struct i2c_client *client)\r\n{\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nint ret = 0;\r\nu8 status;\r\nu8 pattern[][LP5523_PROGRAM_LENGTH] = {\r\n{ 0x9c, 0x30, 0x9c, 0xb0, 0x9d, 0x80, 0xd8, 0x00, 0},\r\n{ 0x9c, 0x40, 0x9c, 0xc0, 0x9d, 0x80, 0xd8, 0x00, 0},\r\n{ 0x9c, 0x50, 0x9c, 0xd0, 0x9d, 0x80, 0xd8, 0x00, 0},\r\n};\r\nret |= lp5523_write(client, LP5523_REG_ENABLE, LP5523_ENABLE);\r\nusleep_range(1000, 2000);\r\nret |= lp5523_write(client, LP5523_REG_CONFIG,\r\nLP5523_AUTO_INC | LP5523_PWR_SAVE |\r\nLP5523_CP_AUTO | LP5523_AUTO_CLK |\r\nLP5523_PWM_PWR_SAVE);\r\nret |= lp5523_write(client, LP5523_REG_ENABLE_LEDS_MSB, 0x01);\r\nret |= lp5523_write(client, LP5523_REG_ENABLE_LEDS_LSB, 0xff);\r\nret |= lp5523_write(client, LP5523_REG_CH1_PROG_START, 0x00);\r\nret |= lp5523_write(client, LP5523_REG_CH2_PROG_START, 0x10);\r\nret |= lp5523_write(client, LP5523_REG_CH3_PROG_START, 0x20);\r\nret |= lp5523_load_program(&chip->engines[0], pattern[0]);\r\nret |= lp5523_load_program(&chip->engines[1], pattern[1]);\r\nret |= lp5523_load_program(&chip->engines[2], pattern[2]);\r\nif (ret) {\r\ndev_err(&client->dev, "could not load mux programs\n");\r\nreturn -1;\r\n}\r\nret |= lp5523_write(client, LP5523_REG_ENABLE,\r\n(LP5523_CMD_RUN | LP5523_ENABLE));\r\nret |= lp5523_write(client, LP5523_REG_OP_MODE, LP5523_CMD_RUN);\r\nif (ret) {\r\ndev_err(&client->dev, "could not start mux programs\n");\r\nreturn -1;\r\n}\r\nusleep_range(3000, 6000);\r\nlp5523_read(client, LP5523_REG_STATUS, &status);\r\nstatus &= LP5523_ENG_STATUS_MASK;\r\nif (status == LP5523_ENG_STATUS_MASK) {\r\ndev_dbg(&client->dev, "all engines configured\n");\r\n} else {\r\ndev_info(&client->dev, "status == %x\n", status);\r\ndev_err(&client->dev, "cound not configure LED engine\n");\r\nreturn -1;\r\n}\r\ndev_info(&client->dev, "disabling engines\n");\r\nret |= lp5523_write(client, LP5523_REG_OP_MODE, LP5523_CMD_DISABLED);\r\nreturn ret;\r\n}\r\nstatic int lp5523_set_engine_mode(struct lp5523_engine *engine, u8 mode)\r\n{\r\nstruct lp5523_chip *chip = engine_to_lp5523(engine);\r\nstruct i2c_client *client = chip->client;\r\nint ret;\r\nu8 engine_state;\r\nret = lp5523_read(client, LP5523_REG_OP_MODE, &engine_state);\r\nif (ret)\r\ngoto fail;\r\nengine_state &= ~(engine->engine_mask);\r\nmode &= engine->engine_mask;\r\nengine_state |= mode;\r\nret |= lp5523_write(client, LP5523_REG_OP_MODE, engine_state);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lp5523_load_mux(struct lp5523_engine *engine, u16 mux)\r\n{\r\nstruct lp5523_chip *chip = engine_to_lp5523(engine);\r\nstruct i2c_client *client = chip->client;\r\nint ret = 0;\r\nret |= lp5523_set_engine_mode(engine, LP5523_CMD_LOAD);\r\nret |= lp5523_write(client, LP5523_REG_PROG_PAGE_SEL, engine->mux_page);\r\nret |= lp5523_write(client, LP5523_REG_PROG_MEM,\r\n(u8)(mux >> 8));\r\nret |= lp5523_write(client, LP5523_REG_PROG_MEM + 1, (u8)(mux));\r\nengine->led_mux = mux;\r\nreturn ret;\r\n}\r\nstatic int lp5523_load_program(struct lp5523_engine *engine, u8 *pattern)\r\n{\r\nstruct lp5523_chip *chip = engine_to_lp5523(engine);\r\nstruct i2c_client *client = chip->client;\r\nint ret = 0;\r\nret |= lp5523_set_engine_mode(engine, LP5523_CMD_LOAD);\r\nret |= lp5523_write(client, LP5523_REG_PROG_PAGE_SEL,\r\nengine->prog_page);\r\nret |= i2c_smbus_write_i2c_block_data(client, LP5523_REG_PROG_MEM,\r\nLP5523_PROGRAM_LENGTH, pattern);\r\nreturn ret;\r\n}\r\nstatic int lp5523_run_program(struct lp5523_engine *engine)\r\n{\r\nstruct lp5523_chip *chip = engine_to_lp5523(engine);\r\nstruct i2c_client *client = chip->client;\r\nint ret;\r\nret = lp5523_write(client, LP5523_REG_ENABLE,\r\nLP5523_CMD_RUN | LP5523_ENABLE);\r\nif (ret)\r\ngoto fail;\r\nret = lp5523_set_engine_mode(engine, LP5523_CMD_RUN);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lp5523_mux_parse(const char *buf, u16 *mux, size_t len)\r\n{\r\nint i;\r\nu16 tmp_mux = 0;\r\nlen = len < LP5523_LEDS ? len : LP5523_LEDS;\r\nfor (i = 0; i < len; i++) {\r\nswitch (buf[i]) {\r\ncase '1':\r\ntmp_mux |= (1 << i);\r\nbreak;\r\ncase '0':\r\nbreak;\r\ncase '\n':\r\ni = len;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\n*mux = tmp_mux;\r\nreturn 0;\r\n}\r\nstatic void lp5523_mux_to_array(u16 led_mux, char *array)\r\n{\r\nint i, pos = 0;\r\nfor (i = 0; i < LP5523_LEDS; i++)\r\npos += sprintf(array + pos, "%x", LED_ACTIVE(led_mux, i));\r\narray[pos] = '\0';\r\n}\r\nstatic ssize_t show_engine_leds(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nchar mux[LP5523_LEDS + 1];\r\nlp5523_mux_to_array(chip->engines[nr - 1].led_mux, mux);\r\nreturn sprintf(buf, "%s\n", mux);\r\n}\r\nstatic ssize_t store_engine_leds(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nu16 mux = 0;\r\nssize_t ret;\r\nif (lp5523_mux_parse(buf, &mux, len))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->lock);\r\nret = -EINVAL;\r\nif (chip->engines[nr - 1].mode != LP5523_CMD_LOAD)\r\ngoto leave;\r\nif (lp5523_load_mux(&chip->engines[nr - 1], mux))\r\ngoto leave;\r\nret = len;\r\nleave:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t lp5523_selftest(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nint i, ret, pos = 0;\r\nint led = 0;\r\nu8 status, adc, vdd;\r\nmutex_lock(&chip->lock);\r\nret = lp5523_read(chip->client, LP5523_REG_STATUS, &status);\r\nif (ret < 0)\r\ngoto fail;\r\nif ((chip->pdata) && (chip->pdata->clock_mode == LP5523_CLOCK_EXT))\r\nif ((status & LP5523_EXT_CLK_USED) == 0)\r\ngoto fail;\r\nlp5523_write(chip->client, LP5523_REG_LED_TEST_CTRL,\r\nLP5523_EN_LEDTEST | 16);\r\nusleep_range(3000, 6000);\r\nret = lp5523_read(chip->client, LP5523_REG_STATUS, &status);\r\nif (!(status & LP5523_LEDTEST_DONE))\r\nusleep_range(3000, 6000);\r\nret |= lp5523_read(chip->client, LP5523_REG_LED_TEST_ADC, &vdd);\r\nvdd--;\r\nfor (i = 0; i < LP5523_LEDS; i++) {\r\nif (chip->pdata->led_config[i].led_current == 0)\r\ncontinue;\r\nlp5523_write(chip->client,\r\nLP5523_REG_LED_CURRENT_BASE + i,\r\nchip->pdata->led_config[i].led_current);\r\nlp5523_write(chip->client, LP5523_REG_LED_PWM_BASE + i, 0xff);\r\nusleep_range(2000, 4000);\r\nlp5523_write(chip->client,\r\nLP5523_REG_LED_TEST_CTRL,\r\nLP5523_EN_LEDTEST | i);\r\nusleep_range(3000, 6000);\r\nret = lp5523_read(chip->client, LP5523_REG_STATUS, &status);\r\nif (!(status & LP5523_LEDTEST_DONE))\r\nusleep_range(3000, 6000);\r\nret |= lp5523_read(chip->client, LP5523_REG_LED_TEST_ADC, &adc);\r\nif (adc >= vdd || adc < LP5523_ADC_SHORTCIRC_LIM)\r\npos += sprintf(buf + pos, "LED %d FAIL\n", i);\r\nlp5523_write(chip->client, LP5523_REG_LED_PWM_BASE + i, 0x00);\r\nlp5523_write(chip->client,\r\nLP5523_REG_LED_CURRENT_BASE + i,\r\nchip->leds[led].led_current);\r\nled++;\r\n}\r\nif (pos == 0)\r\npos = sprintf(buf, "OK\n");\r\ngoto release_lock;\r\nfail:\r\npos = sprintf(buf, "FAIL\n");\r\nrelease_lock:\r\nmutex_unlock(&chip->lock);\r\nreturn pos;\r\n}\r\nstatic void lp5523_set_brightness(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lp5523_led *led = cdev_to_led(cdev);\r\nled->brightness = (u8)brightness;\r\nschedule_work(&led->brightness_work);\r\n}\r\nstatic void lp5523_led_brightness_work(struct work_struct *work)\r\n{\r\nstruct lp5523_led *led = container_of(work,\r\nstruct lp5523_led,\r\nbrightness_work);\r\nstruct lp5523_chip *chip = led_to_lp5523(led);\r\nstruct i2c_client *client = chip->client;\r\nmutex_lock(&chip->lock);\r\nlp5523_write(client, LP5523_REG_LED_PWM_BASE + led->chan_nr,\r\nled->brightness);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int lp5523_do_store_load(struct lp5523_engine *engine,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp5523_chip *chip = engine_to_lp5523(engine);\r\nstruct i2c_client *client = chip->client;\r\nint ret, nrchars, offset = 0, i = 0;\r\nchar c[3];\r\nunsigned cmd;\r\nu8 pattern[LP5523_PROGRAM_LENGTH] = {0};\r\nwhile ((offset < len - 1) && (i < LP5523_PROGRAM_LENGTH)) {\r\nret = sscanf(buf + offset, "%2s%n ", c, &nrchars);\r\nret = sscanf(c, "%2x", &cmd);\r\nif (ret != 1)\r\ngoto fail;\r\npattern[i] = (u8)cmd;\r\noffset += nrchars;\r\ni++;\r\n}\r\nif (i % 2)\r\ngoto fail;\r\nmutex_lock(&chip->lock);\r\nif (engine->mode == LP5523_CMD_LOAD)\r\nret = lp5523_load_program(engine, pattern);\r\nelse\r\nret = -EINVAL;\r\nmutex_unlock(&chip->lock);\r\nif (ret) {\r\ndev_err(&client->dev, "failed loading pattern\n");\r\nreturn ret;\r\n}\r\nreturn len;\r\nfail:\r\ndev_err(&client->dev, "wrong pattern format\n");\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t store_engine_load(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nreturn lp5523_do_store_load(&chip->engines[nr - 1], buf, len);\r\n}\r\nstatic ssize_t show_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nswitch (chip->engines[nr - 1].mode) {\r\ncase LP5523_CMD_RUN:\r\nreturn sprintf(buf, "run\n");\r\ncase LP5523_CMD_LOAD:\r\nreturn sprintf(buf, "load\n");\r\ncase LP5523_CMD_DISABLED:\r\nreturn sprintf(buf, "disabled\n");\r\ndefault:\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\n}\r\nstatic ssize_t store_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nstruct lp5523_engine *engine = &chip->engines[nr - 1];\r\nmutex_lock(&chip->lock);\r\nif (!strncmp(buf, "run", 3))\r\nlp5523_set_mode(engine, LP5523_CMD_RUN);\r\nelse if (!strncmp(buf, "load", 4))\r\nlp5523_set_mode(engine, LP5523_CMD_LOAD);\r\nelse if (!strncmp(buf, "disabled", 8))\r\nlp5523_set_mode(engine, LP5523_CMD_DISABLED);\r\nmutex_unlock(&chip->lock);\r\nreturn len;\r\n}\r\nstatic ssize_t show_max_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lp5523_led *led = cdev_to_led(led_cdev);\r\nreturn sprintf(buf, "%d\n", led->max_current);\r\n}\r\nstatic ssize_t show_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lp5523_led *led = cdev_to_led(led_cdev);\r\nreturn sprintf(buf, "%d\n", led->led_current);\r\n}\r\nstatic ssize_t store_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lp5523_led *led = cdev_to_led(led_cdev);\r\nstruct lp5523_chip *chip = led_to_lp5523(led);\r\nssize_t ret;\r\nunsigned long curr;\r\nif (strict_strtoul(buf, 0, &curr))\r\nreturn -EINVAL;\r\nif (curr > led->max_current)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->lock);\r\nret = lp5523_write(chip->client,\r\nLP5523_REG_LED_CURRENT_BASE + led->chan_nr,\r\n(u8)curr);\r\nmutex_unlock(&chip->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nled->led_current = (u8)curr;\r\nreturn len;\r\n}\r\nstatic int lp5523_register_sysfs(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nint ret;\r\nret = sysfs_create_group(&dev->kobj, &lp5523_group);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void lp5523_unregister_sysfs(struct i2c_client *client)\r\n{\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nstruct device *dev = &client->dev;\r\nint i;\r\nsysfs_remove_group(&dev->kobj, &lp5523_group);\r\nfor (i = 0; i < chip->num_leds; i++)\r\nsysfs_remove_group(&chip->leds[i].cdev.dev->kobj,\r\n&lp5523_led_attribute_group);\r\n}\r\nstatic int lp5523_set_mode(struct lp5523_engine *engine, u8 mode)\r\n{\r\nint ret = 0;\r\nif (mode == engine->mode && mode != LP5523_CMD_RUN)\r\nreturn 0;\r\nif (mode == LP5523_CMD_RUN) {\r\nret = lp5523_run_program(engine);\r\n} else if (mode == LP5523_CMD_LOAD) {\r\nlp5523_set_engine_mode(engine, LP5523_CMD_DISABLED);\r\nlp5523_set_engine_mode(engine, LP5523_CMD_LOAD);\r\n} else if (mode == LP5523_CMD_DISABLED) {\r\nlp5523_set_engine_mode(engine, LP5523_CMD_DISABLED);\r\n}\r\nengine->mode = mode;\r\nreturn ret;\r\n}\r\nstatic int __init lp5523_init_engine(struct lp5523_engine *engine, int id)\r\n{\r\nif (id < 1 || id > LP5523_ENGINES)\r\nreturn -1;\r\nengine->id = id;\r\nengine->engine_mask = LP5523_ENG_MASK_BASE >> SHIFT_MASK(id);\r\nengine->prog_page = id - 1;\r\nengine->mux_page = id + 2;\r\nreturn 0;\r\n}\r\nstatic int __devinit lp5523_init_led(struct lp5523_led *led, struct device *dev,\r\nint chan, struct lp5523_platform_data *pdata)\r\n{\r\nchar name[32];\r\nint res;\r\nif (chan >= LP5523_LEDS)\r\nreturn -EINVAL;\r\nif (pdata->led_config[chan].led_current) {\r\nled->led_current = pdata->led_config[chan].led_current;\r\nled->max_current = pdata->led_config[chan].max_current;\r\nled->chan_nr = pdata->led_config[chan].chan_nr;\r\nif (led->chan_nr >= LP5523_LEDS) {\r\ndev_err(dev, "Use channel numbers between 0 and %d\n",\r\nLP5523_LEDS - 1);\r\nreturn -EINVAL;\r\n}\r\nsnprintf(name, sizeof(name), "%s:channel%d",\r\npdata->label ?: "lp5523", chan);\r\nled->cdev.name = name;\r\nled->cdev.brightness_set = lp5523_set_brightness;\r\nres = led_classdev_register(dev, &led->cdev);\r\nif (res < 0) {\r\ndev_err(dev, "couldn't register led on channel %d\n",\r\nchan);\r\nreturn res;\r\n}\r\nres = sysfs_create_group(&led->cdev.dev->kobj,\r\n&lp5523_led_attribute_group);\r\nif (res < 0) {\r\ndev_err(dev, "couldn't register current attribute\n");\r\nled_classdev_unregister(&led->cdev);\r\nreturn res;\r\n}\r\n} else {\r\nled->led_current = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit lp5523_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lp5523_chip *chip;\r\nstruct lp5523_platform_data *pdata;\r\nint ret, i, led;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, chip);\r\nchip->client = client;\r\npdata = client->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data\n");\r\nret = -EINVAL;\r\ngoto fail1;\r\n}\r\nmutex_init(&chip->lock);\r\nchip->pdata = pdata;\r\nif (pdata->setup_resources) {\r\nret = pdata->setup_resources();\r\nif (ret < 0)\r\ngoto fail1;\r\n}\r\nif (pdata->enable) {\r\npdata->enable(0);\r\nusleep_range(1000, 2000);\r\npdata->enable(1);\r\nusleep_range(1000, 2000);\r\n}\r\nlp5523_write(client, LP5523_REG_RESET, 0xff);\r\nusleep_range(10000, 20000);\r\nret = lp5523_detect(client);\r\nif (ret)\r\ngoto fail2;\r\ndev_info(&client->dev, "LP5523 Programmable led chip found\n");\r\nfor (i = 0; i < ARRAY_SIZE(chip->engines); i++) {\r\nret = lp5523_init_engine(&chip->engines[i], i + 1);\r\nif (ret) {\r\ndev_err(&client->dev, "error initializing engine\n");\r\ngoto fail2;\r\n}\r\n}\r\nret = lp5523_configure(client);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "error configuring chip\n");\r\ngoto fail2;\r\n}\r\nchip->num_channels = pdata->num_channels;\r\nchip->num_leds = 0;\r\nled = 0;\r\nfor (i = 0; i < pdata->num_channels; i++) {\r\nif (pdata->led_config[i].led_current == 0)\r\ncontinue;\r\nret = lp5523_init_led(&chip->leds[led], &client->dev, i, pdata);\r\nif (ret) {\r\ndev_err(&client->dev, "error initializing leds\n");\r\ngoto fail3;\r\n}\r\nchip->num_leds++;\r\nchip->leds[led].id = led;\r\nlp5523_write(client,\r\nLP5523_REG_LED_CURRENT_BASE + chip->leds[led].chan_nr,\r\nchip->leds[led].led_current);\r\nINIT_WORK(&(chip->leds[led].brightness_work),\r\nlp5523_led_brightness_work);\r\nled++;\r\n}\r\nret = lp5523_register_sysfs(client);\r\nif (ret) {\r\ndev_err(&client->dev, "registering sysfs failed\n");\r\ngoto fail3;\r\n}\r\nreturn ret;\r\nfail3:\r\nfor (i = 0; i < chip->num_leds; i++) {\r\nled_classdev_unregister(&chip->leds[i].cdev);\r\ncancel_work_sync(&chip->leds[i].brightness_work);\r\n}\r\nfail2:\r\nif (pdata->enable)\r\npdata->enable(0);\r\nif (pdata->release_resources)\r\npdata->release_resources();\r\nfail1:\r\nkfree(chip);\r\nreturn ret;\r\n}\r\nstatic int lp5523_remove(struct i2c_client *client)\r\n{\r\nstruct lp5523_chip *chip = i2c_get_clientdata(client);\r\nint i;\r\nlp5523_unregister_sysfs(client);\r\nfor (i = 0; i < chip->num_leds; i++) {\r\nled_classdev_unregister(&chip->leds[i].cdev);\r\ncancel_work_sync(&chip->leds[i].brightness_work);\r\n}\r\nif (chip->pdata->enable)\r\nchip->pdata->enable(0);\r\nif (chip->pdata->release_resources)\r\nchip->pdata->release_resources();\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int __init lp5523_init(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&lp5523_driver);\r\nif (ret < 0)\r\nprintk(KERN_ALERT "Adding lp5523 driver failed\n");\r\nreturn ret;\r\n}\r\nstatic void __exit lp5523_exit(void)\r\n{\r\ni2c_del_driver(&lp5523_driver);\r\n}
