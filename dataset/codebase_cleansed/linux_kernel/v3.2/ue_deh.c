static void mmu_fault_dpc(unsigned long data)\r\n{\r\nstruct deh_mgr *deh = (void *)data;\r\nif (!deh)\r\nreturn;\r\nbridge_deh_notify(deh, DSP_MMUFAULT, 0);\r\n}\r\nstatic irqreturn_t mmu_fault_isr(int irq, void *data)\r\n{\r\nstruct deh_mgr *deh = data;\r\nstruct cfg_hostres *resources;\r\nu32 event;\r\nif (!deh)\r\nreturn IRQ_HANDLED;\r\nresources = deh->bridge_context->resources;\r\nif (!resources) {\r\ndev_dbg(bridge, "%s: Failed to get Host Resources\n",\r\n__func__);\r\nreturn IRQ_HANDLED;\r\n}\r\nhw_mmu_event_status(resources->dmmu_base, &event);\r\nif (event == HW_MMU_TRANSLATION_FAULT) {\r\nhw_mmu_fault_addr_read(resources->dmmu_base, &fault_addr);\r\ndev_dbg(bridge, "%s: event=0x%x, fault_addr=0x%x\n", __func__,\r\nevent, fault_addr);\r\ntasklet_schedule(&deh->dpc_tasklet);\r\nhw_mmu_event_disable(resources->dmmu_base,\r\nHW_MMU_TRANSLATION_FAULT);\r\n} else {\r\nhw_mmu_event_disable(resources->dmmu_base,\r\nHW_MMU_ALL_INTERRUPTS);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint bridge_deh_create(struct deh_mgr **ret_deh,\r\nstruct dev_object *hdev_obj)\r\n{\r\nint status;\r\nstruct deh_mgr *deh;\r\nstruct bridge_dev_context *hbridge_context = NULL;\r\ndev_get_bridge_context(hdev_obj, &hbridge_context);\r\ndeh = kzalloc(sizeof(*deh), GFP_KERNEL);\r\nif (!deh) {\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\ndeh->ntfy_obj = kmalloc(sizeof(struct ntfy_object), GFP_KERNEL);\r\nif (!deh->ntfy_obj) {\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nntfy_init(deh->ntfy_obj);\r\ntasklet_init(&deh->dpc_tasklet, mmu_fault_dpc, (u32) deh);\r\ndeh->bridge_context = hbridge_context;\r\nstatus = request_irq(INT_DSP_MMU_IRQ, mmu_fault_isr, 0,\r\n"DspBridge\tiommu fault", deh);\r\nif (status < 0)\r\ngoto err;\r\n*ret_deh = deh;\r\nreturn 0;\r\nerr:\r\nbridge_deh_destroy(deh);\r\n*ret_deh = NULL;\r\nreturn status;\r\n}\r\nint bridge_deh_destroy(struct deh_mgr *deh)\r\n{\r\nif (!deh)\r\nreturn -EFAULT;\r\nif (deh->ntfy_obj) {\r\nntfy_delete(deh->ntfy_obj);\r\nkfree(deh->ntfy_obj);\r\n}\r\nfree_irq(INT_DSP_MMU_IRQ, deh);\r\ntasklet_kill(&deh->dpc_tasklet);\r\nkfree(deh);\r\nreturn 0;\r\n}\r\nint bridge_deh_register_notify(struct deh_mgr *deh, u32 event_mask,\r\nu32 notify_type,\r\nstruct dsp_notification *hnotification)\r\n{\r\nif (!deh)\r\nreturn -EFAULT;\r\nif (event_mask)\r\nreturn ntfy_register(deh->ntfy_obj, hnotification,\r\nevent_mask, notify_type);\r\nelse\r\nreturn ntfy_unregister(deh->ntfy_obj, hnotification);\r\n}\r\nstatic void mmu_fault_print_stack(struct bridge_dev_context *dev_context)\r\n{\r\nstruct cfg_hostres *resources;\r\nstruct hw_mmu_map_attrs_t map_attrs = {\r\n.endianism = HW_LITTLE_ENDIAN,\r\n.element_size = HW_ELEM_SIZE16BIT,\r\n.mixed_size = HW_MMU_CPUES,\r\n};\r\nvoid *dummy_va_addr;\r\nresources = dev_context->resources;\r\ndummy_va_addr = (void*)__get_free_page(GFP_ATOMIC);\r\nhw_mmu_twl_disable(resources->dmmu_base);\r\nhw_mmu_tlb_flush_all(resources->dmmu_base);\r\nhw_mmu_tlb_add(resources->dmmu_base,\r\nvirt_to_phys(dummy_va_addr), fault_addr,\r\nHW_PAGE_SIZE4KB, 1,\r\n&map_attrs, HW_SET, HW_SET);\r\ndsp_clk_enable(DSP_CLK_GPT8);\r\ndsp_gpt_wait_overflow(DSP_CLK_GPT8, 0xfffffffe);\r\nhw_mmu_event_ack(resources->dmmu_base,\r\nHW_MMU_TRANSLATION_FAULT);\r\ndump_dsp_stack(dev_context);\r\ndsp_clk_disable(DSP_CLK_GPT8);\r\nhw_mmu_disable(resources->dmmu_base);\r\nfree_page((unsigned long)dummy_va_addr);\r\n}\r\nstatic inline const char *event_to_string(int event)\r\n{\r\nswitch (event) {\r\ncase DSP_SYSERROR: return "DSP_SYSERROR"; break;\r\ncase DSP_MMUFAULT: return "DSP_MMUFAULT"; break;\r\ncase DSP_PWRERROR: return "DSP_PWRERROR"; break;\r\ncase DSP_WDTOVERFLOW: return "DSP_WDTOVERFLOW"; break;\r\ndefault: return "unkown event"; break;\r\n}\r\n}\r\nvoid bridge_deh_notify(struct deh_mgr *deh, int event, int info)\r\n{\r\nstruct bridge_dev_context *dev_context;\r\nconst char *str = event_to_string(event);\r\nif (!deh)\r\nreturn;\r\ndev_dbg(bridge, "%s: device exception", __func__);\r\ndev_context = deh->bridge_context;\r\nswitch (event) {\r\ncase DSP_SYSERROR:\r\ndev_err(bridge, "%s: %s, info=0x%x", __func__,\r\nstr, info);\r\n#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE\r\ndump_dl_modules(dev_context);\r\ndump_dsp_stack(dev_context);\r\n#endif\r\nbreak;\r\ncase DSP_MMUFAULT:\r\ndev_err(bridge, "%s: %s, addr=0x%x", __func__,\r\nstr, fault_addr);\r\n#ifdef CONFIG_TIDSPBRIDGE_BACKTRACE\r\nprint_dsp_trace_buffer(dev_context);\r\ndump_dl_modules(dev_context);\r\nmmu_fault_print_stack(dev_context);\r\n#endif\r\nbreak;\r\ndefault:\r\ndev_err(bridge, "%s: %s", __func__, str);\r\nbreak;\r\n}\r\nif (dev_context->brd_state != BRD_ERROR) {\r\nntfy_notify(deh->ntfy_obj, event);\r\n#ifdef CONFIG_TIDSPBRIDGE_RECOVERY\r\nbridge_recover_schedule();\r\n#endif\r\n}\r\ndev_context->brd_state = BRD_ERROR;\r\ndsp_clock_disable_all(dev_context->dsp_per_clks);\r\ndsp_wdt_enable(false);\r\n}
