static int nfeth_open(struct net_device *dev)\r\n{\r\nstruct nfeth_private *priv = netdev_priv(dev);\r\nint res;\r\nres = nf_call(nfEtherID + XIF_START, priv->ethX);\r\nnetdev_dbg(dev, "%s: %d\n", __func__, res);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int nfeth_stop(struct net_device *dev)\r\n{\r\nstruct nfeth_private *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnf_call(nfEtherID + XIF_STOP, priv->ethX);\r\nreturn 0;\r\n}\r\nstatic inline void recv_packet(struct net_device *dev)\r\n{\r\nstruct nfeth_private *priv = netdev_priv(dev);\r\nunsigned short pktlen;\r\nstruct sk_buff *skb;\r\npktlen = nf_call(nfEtherID + XIF_READLENGTH, priv->ethX);\r\nnetdev_dbg(dev, "%s: %u\n", __func__, pktlen);\r\nif (!pktlen) {\r\nnetdev_dbg(dev, "%s: pktlen == 0\n", __func__);\r\ndev->stats.rx_errors++;\r\nreturn;\r\n}\r\nskb = dev_alloc_skb(pktlen + 2);\r\nif (!skb) {\r\nnetdev_dbg(dev, "%s: out of mem (buf_alloc failed)\n",\r\n__func__);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb->dev = dev;\r\nskb_reserve(skb, 2);\r\nskb_put(skb, pktlen);\r\nnf_call(nfEtherID + XIF_READBLOCK, priv->ethX, virt_to_phys(skb->data),\r\npktlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->last_rx = jiffies;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pktlen;\r\nreturn;\r\n}\r\nstatic irqreturn_t nfeth_interrupt(int irq, void *dev_id)\r\n{\r\nint i, m, mask;\r\nmask = nf_call(nfEtherID + XIF_IRQ, 0);\r\nfor (i = 0, m = 1; i < MAX_UNIT; m <<= 1, i++) {\r\nif (mask & m && nfeth_dev[i]) {\r\nrecv_packet(nfeth_dev[i]);\r\nnf_call(nfEtherID + XIF_IRQ, m);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nfeth_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned int len;\r\nchar *data, shortpkt[ETH_ZLEN];\r\nstruct nfeth_private *priv = netdev_priv(dev);\r\ndata = skb->data;\r\nlen = skb->len;\r\nif (len < ETH_ZLEN) {\r\nmemset(shortpkt, 0, ETH_ZLEN);\r\nmemcpy(shortpkt, data, len);\r\ndata = shortpkt;\r\nlen = ETH_ZLEN;\r\n}\r\nnetdev_dbg(dev, "%s: send %u bytes\n", __func__, len);\r\nnf_call(nfEtherID + XIF_WRITEBLOCK, priv->ethX, virt_to_phys(data),\r\nlen);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += len;\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void nfeth_tx_timeout(struct net_device *dev)\r\n{\r\ndev->stats.tx_errors++;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic struct net_device * __init nfeth_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nstruct nfeth_private *priv;\r\nchar mac[ETH_ALEN], host_ip[32], local_ip[32];\r\nint err;\r\nif (!nf_call(nfEtherID + XIF_GET_MAC, unit, mac, ETH_ALEN))\r\nreturn NULL;\r\ndev = alloc_etherdev(sizeof(struct nfeth_private));\r\nif (!dev)\r\nreturn NULL;\r\ndev->irq = nfEtherIRQ;\r\ndev->netdev_ops = &nfeth_netdev_ops;\r\nmemcpy(dev->dev_addr, mac, ETH_ALEN);\r\npriv = netdev_priv(dev);\r\npriv->ethX = unit;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nnf_call(nfEtherID + XIF_GET_IPHOST, unit,\r\nhost_ip, sizeof(host_ip));\r\nnf_call(nfEtherID + XIF_GET_IPATARI, unit,\r\nlocal_ip, sizeof(local_ip));\r\nnetdev_info(dev, KBUILD_MODNAME " addr:%s (%s) HWaddr:%pM\n", host_ip,\r\nlocal_ip, mac);\r\nreturn dev;\r\n}\r\nstatic int __init nfeth_init(void)\r\n{\r\nlong ver;\r\nint error, i;\r\nnfEtherID = nf_get_id("ETHERNET");\r\nif (!nfEtherID)\r\nreturn -ENODEV;\r\nver = nf_call(nfEtherID + GET_VERSION);\r\npr_info("API %lu\n", ver);\r\nnfEtherIRQ = nf_call(nfEtherID + XIF_INTLEVEL);\r\nerror = request_irq(nfEtherIRQ, nfeth_interrupt, IRQF_SHARED,\r\n"eth emu", nfeth_interrupt);\r\nif (error) {\r\npr_err("request for irq %d failed %d", nfEtherIRQ, error);\r\nreturn error;\r\n}\r\nfor (i = 0; i < MAX_UNIT; i++)\r\nnfeth_dev[i] = nfeth_probe(i);\r\nreturn 0;\r\n}\r\nstatic void __exit nfeth_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_UNIT; i++) {\r\nif (nfeth_dev[i]) {\r\nunregister_netdev(nfeth_dev[0]);\r\nfree_netdev(nfeth_dev[0]);\r\n}\r\n}\r\nfree_irq(nfEtherIRQ, nfeth_interrupt);\r\n}
