static void\r\nbfa_ioc_sm_uninit_entry(struct bfa_ioc_s *ioc)\r\n{\r\n}\r\nstatic void\r\nbfa_ioc_sm_uninit(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_RESET:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_reset);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_reset_entry(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_fsm_set_state(&ioc->iocpf, bfa_iocpf_sm_reset);\r\n}\r\nstatic void\r\nbfa_ioc_sm_reset(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_ENABLE:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_enabling);\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nbfa_ioc_disable_comp(ioc);\r\nbreak;\r\ncase IOC_E_DETACH:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_enabling_entry(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_ENABLE);\r\n}\r\nstatic void\r\nbfa_ioc_sm_enabling(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_ENABLED:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_getattr);\r\nbreak;\r\ncase IOC_E_PFFAILED:\r\ncase IOC_E_HWERROR:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\r\nif (event != IOC_E_PFFAILED)\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_INITFAIL);\r\nbreak;\r\ncase IOC_E_HWFAILED:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_hwfail);\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\r\nbreak;\r\ncase IOC_E_DETACH:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_STOP);\r\nbreak;\r\ncase IOC_E_ENABLE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_getattr_entry(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_ioc_timer_start(ioc);\r\nbfa_ioc_send_getattr(ioc);\r\n}\r\nstatic void\r\nbfa_ioc_sm_getattr(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_FWRSP_GETATTR:\r\nbfa_ioc_timer_stop(ioc);\r\nbfa_ioc_check_attr_wwns(ioc);\r\nbfa_ioc_hb_monitor(ioc);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_op);\r\nbreak;\r\ncase IOC_E_FWRSP_ACQ_ADDR:\r\nbfa_ioc_timer_stop(ioc);\r\nbfa_ioc_hb_monitor(ioc);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_acq_addr);\r\nbreak;\r\ncase IOC_E_PFFAILED:\r\ncase IOC_E_HWERROR:\r\nbfa_ioc_timer_stop(ioc);\r\ncase IOC_E_TIMEOUT:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\r\nif (event != IOC_E_PFFAILED)\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_GETATTRFAIL);\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nbfa_ioc_timer_stop(ioc);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\r\nbreak;\r\ncase IOC_E_ENABLE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_acq_addr_entry(struct bfa_ioc_s *ioc)\r\n{\r\n}\r\nstatic void\r\nbfa_ioc_sm_acq_addr(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_FWRSP_GETATTR:\r\nbfa_ioc_check_attr_wwns(ioc);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_op);\r\nbreak;\r\ncase IOC_E_PFFAILED:\r\ncase IOC_E_HWERROR:\r\nbfa_hb_timer_stop(ioc);\r\ncase IOC_E_HBFAIL:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\r\nif (event != IOC_E_PFFAILED)\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_GETATTRFAIL);\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nbfa_hb_timer_stop(ioc);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\r\nbreak;\r\ncase IOC_E_ENABLE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_op_entry(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)ioc->bfa->bfad;\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_OK);\r\nbfa_ioc_event_notify(ioc, BFA_IOC_E_ENABLED);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level, "IOC enabled\n");\r\nbfa_ioc_aen_post(ioc, BFA_IOC_AEN_ENABLE);\r\n}\r\nstatic void\r\nbfa_ioc_sm_op(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_ENABLE:\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nbfa_hb_timer_stop(ioc);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\r\nbreak;\r\ncase IOC_E_PFFAILED:\r\ncase IOC_E_HWERROR:\r\nbfa_hb_timer_stop(ioc);\r\ncase IOC_E_HBFAIL:\r\nif (ioc->iocpf.auto_recover)\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_fail_retry);\r\nelse\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\r\nbfa_ioc_fail_notify(ioc);\r\nif (event != IOC_E_PFFAILED)\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_FAIL);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_disabling_entry(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)ioc->bfa->bfad;\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_DISABLE);\r\nBFA_LOG(KERN_INFO, bfad, bfa_log_level, "IOC disabled\n");\r\nbfa_ioc_aen_post(ioc, BFA_IOC_AEN_DISABLE);\r\n}\r\nstatic void\r\nbfa_ioc_sm_disabling(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_DISABLED:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_disabled);\r\nbreak;\r\ncase IOC_E_HWERROR:\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_FAIL);\r\nbreak;\r\ncase IOC_E_HWFAILED:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_hwfail);\r\nbfa_ioc_disable_comp(ioc);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_disabled_entry(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_ioc_disable_comp(ioc);\r\n}\r\nstatic void\r\nbfa_ioc_sm_disabled(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_ENABLE:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_enabling);\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nioc->cbfn->disable_cbfn(ioc->bfa);\r\nbreak;\r\ncase IOC_E_DETACH:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_STOP);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_fail_retry_entry(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_trc(ioc, 0);\r\n}\r\nstatic void\r\nbfa_ioc_sm_fail_retry(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_ENABLED:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_getattr);\r\nbreak;\r\ncase IOC_E_PFFAILED:\r\ncase IOC_E_HWERROR:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\r\nif (event != IOC_E_PFFAILED)\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_INITFAIL);\r\nbreak;\r\ncase IOC_E_HWFAILED:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_hwfail);\r\nbreak;\r\ncase IOC_E_ENABLE:\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\r\nbreak;\r\ncase IOC_E_DETACH:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_STOP);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_fail_entry(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_trc(ioc, 0);\r\n}\r\nstatic void\r\nbfa_ioc_sm_fail(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_ENABLE:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\r\nbreak;\r\ncase IOC_E_DETACH:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_STOP);\r\nbreak;\r\ncase IOC_E_HWERROR:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_sm_hwfail_entry(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_trc(ioc, 0);\r\n}\r\nstatic void\r\nbfa_ioc_sm_hwfail(struct bfa_ioc_s *ioc, enum ioc_event event)\r\n{\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOC_E_ENABLE:\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nbreak;\r\ncase IOC_E_DISABLE:\r\nioc->cbfn->disable_cbfn(ioc->bfa);\r\nbreak;\r\ncase IOC_E_DETACH:\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_reset_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\niocpf->fw_mismatch_notified = BFA_FALSE;\r\niocpf->auto_recover = bfa_auto_recover;\r\n}\r\nstatic void\r\nbfa_iocpf_sm_reset(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_ENABLE:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fwcheck);\r\nbreak;\r\ncase IOCPF_E_STOP:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_fwcheck_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nstruct bfi_ioc_image_hdr_s fwhdr;\r\nu32 fwstate = readl(iocpf->ioc->ioc_regs.ioc_fwstate);\r\nif (fwstate == BFI_IOC_UNINIT)\r\ngoto sem_get;\r\nbfa_ioc_fwver_get(iocpf->ioc, &fwhdr);\r\nif (swab32(fwhdr.exec) == BFI_FWBOOT_TYPE_NORMAL)\r\ngoto sem_get;\r\nbfa_trc(iocpf->ioc, fwstate);\r\nbfa_trc(iocpf->ioc, fwhdr.exec);\r\nwritel(BFI_IOC_UNINIT, iocpf->ioc->ioc_regs.ioc_fwstate);\r\nreadl(iocpf->ioc->ioc_regs.ioc_sem_reg);\r\nwritel(1, iocpf->ioc->ioc_regs.ioc_sem_reg);\r\nsem_get:\r\nbfa_ioc_hw_sem_get(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_fwcheck(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_SEMLOCKED:\r\nif (bfa_ioc_firmware_lock(ioc)) {\r\nif (bfa_ioc_sync_start(ioc)) {\r\nbfa_ioc_sync_join(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_hwinit);\r\n} else {\r\nbfa_ioc_firmware_unlock(ioc);\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_sem_timer_start(ioc);\r\n}\r\n} else {\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_mismatch);\r\n}\r\nbreak;\r\ncase IOCPF_E_SEM_ERROR:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\r\nbfa_fsm_send_event(ioc, IOC_E_HWFAILED);\r\nbreak;\r\ncase IOCPF_E_DISABLE:\r\nbfa_sem_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\r\nbfa_fsm_send_event(ioc, IOC_E_DISABLED);\r\nbreak;\r\ncase IOCPF_E_STOP:\r\nbfa_sem_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_mismatch_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nif (iocpf->fw_mismatch_notified == BFA_FALSE)\r\nbfa_ioc_pf_fwmismatch(iocpf->ioc);\r\niocpf->fw_mismatch_notified = BFA_TRUE;\r\nbfa_iocpf_timer_start(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_mismatch(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_TIMEOUT:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fwcheck);\r\nbreak;\r\ncase IOCPF_E_DISABLE:\r\nbfa_iocpf_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\r\nbfa_fsm_send_event(ioc, IOC_E_DISABLED);\r\nbreak;\r\ncase IOCPF_E_STOP:\r\nbfa_iocpf_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_semwait_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_ioc_hw_sem_get(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_semwait(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_SEMLOCKED:\r\nif (bfa_ioc_sync_complete(ioc)) {\r\nbfa_ioc_sync_join(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_hwinit);\r\n} else {\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_sem_timer_start(ioc);\r\n}\r\nbreak;\r\ncase IOCPF_E_SEM_ERROR:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\r\nbfa_fsm_send_event(ioc, IOC_E_HWFAILED);\r\nbreak;\r\ncase IOCPF_E_DISABLE:\r\nbfa_sem_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_hwinit_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\niocpf->poll_time = 0;\r\nbfa_ioc_hwinit(iocpf->ioc, BFA_FALSE);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_hwinit(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_FWREADY:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_enabling);\r\nbreak;\r\ncase IOCPF_E_TIMEOUT:\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_send_event(ioc, IOC_E_PFFAILED);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail_sync);\r\nbreak;\r\ncase IOCPF_E_DISABLE:\r\nbfa_iocpf_timer_stop(ioc);\r\nbfa_ioc_sync_leave(ioc);\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_enabling_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_iocpf_timer_start(iocpf->ioc);\r\niocpf->ioc->cbfn->reset_cbfn(iocpf->ioc->bfa);\r\nbfa_ioc_send_enable(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_enabling(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_FWRSP_ENABLE:\r\nbfa_iocpf_timer_stop(ioc);\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_ready);\r\nbreak;\r\ncase IOCPF_E_INITFAIL:\r\nbfa_iocpf_timer_stop(ioc);\r\ncase IOCPF_E_TIMEOUT:\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nif (event == IOCPF_E_TIMEOUT)\r\nbfa_fsm_send_event(ioc, IOC_E_PFFAILED);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail_sync);\r\nbreak;\r\ncase IOCPF_E_DISABLE:\r\nbfa_iocpf_timer_stop(ioc);\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_ready_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_fsm_send_event(iocpf->ioc, IOC_E_ENABLED);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_ready(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_DISABLE:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling);\r\nbreak;\r\ncase IOCPF_E_GETATTRFAIL:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail_sync);\r\nbreak;\r\ncase IOCPF_E_FAIL:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail_sync);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_disabling_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_iocpf_timer_start(iocpf->ioc);\r\nbfa_ioc_send_disable(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_disabling(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_FWRSP_DISABLE:\r\nbfa_iocpf_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\r\nbreak;\r\ncase IOCPF_E_FAIL:\r\nbfa_iocpf_timer_stop(ioc);\r\ncase IOCPF_E_TIMEOUT:\r\nwritel(BFI_IOC_FAIL, ioc->ioc_regs.ioc_fwstate);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\r\nbreak;\r\ncase IOCPF_E_FWRSP_ENABLE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_disabling_sync_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_ioc_hw_sem_get(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_disabling_sync(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_SEMLOCKED:\r\nbfa_ioc_sync_leave(ioc);\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\r\nbreak;\r\ncase IOCPF_E_SEM_ERROR:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\r\nbfa_fsm_send_event(ioc, IOC_E_HWFAILED);\r\nbreak;\r\ncase IOCPF_E_FAIL:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_disabled_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_ioc_mbox_flush(iocpf->ioc);\r\nbfa_fsm_send_event(iocpf->ioc, IOC_E_DISABLED);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_disabled(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_ENABLE:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_semwait);\r\nbreak;\r\ncase IOCPF_E_STOP:\r\nbfa_ioc_firmware_unlock(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_initfail_sync_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_ioc_debug_save_ftrc(iocpf->ioc);\r\nbfa_ioc_hw_sem_get(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_initfail_sync(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_SEMLOCKED:\r\nbfa_ioc_notify_fail(ioc);\r\nbfa_ioc_sync_leave(ioc);\r\nwritel(BFI_IOC_FAIL, ioc->ioc_regs.ioc_fwstate);\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail);\r\nbreak;\r\ncase IOCPF_E_SEM_ERROR:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\r\nbfa_fsm_send_event(ioc, IOC_E_HWFAILED);\r\nbreak;\r\ncase IOCPF_E_DISABLE:\r\nbfa_sem_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\r\nbreak;\r\ncase IOCPF_E_STOP:\r\nbfa_sem_timer_stop(ioc);\r\nbfa_ioc_firmware_unlock(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\r\nbreak;\r\ncase IOCPF_E_FAIL:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_initfail_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_trc(iocpf->ioc, 0);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_initfail(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_DISABLE:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\r\nbreak;\r\ncase IOCPF_E_STOP:\r\nbfa_ioc_firmware_unlock(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_fail_sync_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_ioc_lpu_stop(iocpf->ioc);\r\nbfa_ioc_mbox_flush(iocpf->ioc);\r\nbfa_ioc_hw_sem_get(iocpf->ioc);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_fail_sync(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_SEMLOCKED:\r\nbfa_ioc_sync_ack(ioc);\r\nbfa_ioc_notify_fail(ioc);\r\nif (!iocpf->auto_recover) {\r\nbfa_ioc_sync_leave(ioc);\r\nwritel(BFI_IOC_FAIL, ioc->ioc_regs.ioc_fwstate);\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\r\n} else {\r\nif (bfa_ioc_sync_complete(ioc))\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_hwinit);\r\nelse {\r\nwritel(1, ioc->ioc_regs.ioc_sem_reg);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_semwait);\r\n}\r\n}\r\nbreak;\r\ncase IOCPF_E_SEM_ERROR:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\r\nbfa_fsm_send_event(ioc, IOC_E_HWFAILED);\r\nbreak;\r\ncase IOCPF_E_DISABLE:\r\nbfa_sem_timer_stop(ioc);\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\r\nbreak;\r\ncase IOCPF_E_FAIL:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_sm_fail_entry(struct bfa_iocpf_s *iocpf)\r\n{\r\nbfa_trc(iocpf->ioc, 0);\r\n}\r\nstatic void\r\nbfa_iocpf_sm_fail(struct bfa_iocpf_s *iocpf, enum iocpf_event event)\r\n{\r\nstruct bfa_ioc_s *ioc = iocpf->ioc;\r\nbfa_trc(ioc, event);\r\nswitch (event) {\r\ncase IOCPF_E_DISABLE:\r\nbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(ioc, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_event_notify(struct bfa_ioc_s *ioc, enum bfa_ioc_event_e event)\r\n{\r\nstruct bfa_ioc_notify_s *notify;\r\nstruct list_head *qe;\r\nlist_for_each(qe, &ioc->notify_q) {\r\nnotify = (struct bfa_ioc_notify_s *)qe;\r\nnotify->cbfn(notify->cbarg, event);\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_disable_comp(struct bfa_ioc_s *ioc)\r\n{\r\nioc->cbfn->disable_cbfn(ioc->bfa);\r\nbfa_ioc_event_notify(ioc, BFA_IOC_E_DISABLED);\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_sem_get(void __iomem *sem_reg)\r\n{\r\nu32 r32;\r\nint cnt = 0;\r\n#define BFA_SEM_SPINCNT 3000\r\nr32 = readl(sem_reg);\r\nwhile ((r32 & 1) && (cnt < BFA_SEM_SPINCNT)) {\r\ncnt++;\r\nudelay(2);\r\nr32 = readl(sem_reg);\r\n}\r\nif (!(r32 & 1))\r\nreturn BFA_TRUE;\r\nreturn BFA_FALSE;\r\n}\r\nstatic void\r\nbfa_ioc_hw_sem_get(struct bfa_ioc_s *ioc)\r\n{\r\nu32 r32;\r\nr32 = readl(ioc->ioc_regs.ioc_sem_reg);\r\nif (r32 == ~0) {\r\nWARN_ON(r32 == ~0);\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_SEM_ERROR);\r\nreturn;\r\n}\r\nif (!(r32 & 1)) {\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_SEMLOCKED);\r\nreturn;\r\n}\r\nbfa_sem_timer_start(ioc);\r\n}\r\nstatic void\r\nbfa_ioc_lmem_init(struct bfa_ioc_s *ioc)\r\n{\r\nu32 pss_ctl;\r\nint i;\r\n#define PSS_LMEM_INIT_TIME 10000\r\npss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\r\npss_ctl &= ~__PSS_LMEM_RESET;\r\npss_ctl |= __PSS_LMEM_INIT_EN;\r\npss_ctl |= __PSS_I2C_CLK_DIV(3UL);\r\nwritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\r\ni = 0;\r\ndo {\r\npss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\r\ni++;\r\n} while (!(pss_ctl & __PSS_LMEM_INIT_DONE) && (i < PSS_LMEM_INIT_TIME));\r\nWARN_ON(!(pss_ctl & __PSS_LMEM_INIT_DONE));\r\nbfa_trc(ioc, pss_ctl);\r\npss_ctl &= ~(__PSS_LMEM_INIT_DONE | __PSS_LMEM_INIT_EN);\r\nwritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\r\n}\r\nstatic void\r\nbfa_ioc_lpu_start(struct bfa_ioc_s *ioc)\r\n{\r\nu32 pss_ctl;\r\npss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\r\npss_ctl &= ~__PSS_LPU0_RESET;\r\nwritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\r\n}\r\nstatic void\r\nbfa_ioc_lpu_stop(struct bfa_ioc_s *ioc)\r\n{\r\nu32 pss_ctl;\r\npss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\r\npss_ctl |= (__PSS_LPU0_RESET | __PSS_LPU1_RESET);\r\nwritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\r\n}\r\nvoid\r\nbfa_ioc_fwver_get(struct bfa_ioc_s *ioc, struct bfi_ioc_image_hdr_s *fwhdr)\r\n{\r\nu32 pgnum, pgoff;\r\nu32 loff = 0;\r\nint i;\r\nu32 *fwsig = (u32 *) fwhdr;\r\npgnum = PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, loff);\r\npgoff = PSS_SMEM_PGOFF(loff);\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\nfor (i = 0; i < (sizeof(struct bfi_ioc_image_hdr_s) / sizeof(u32));\r\ni++) {\r\nfwsig[i] =\r\nbfa_mem_read(ioc->ioc_regs.smem_page_start, loff);\r\nloff += sizeof(u32);\r\n}\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc, struct bfi_ioc_image_hdr_s *fwhdr)\r\n{\r\nstruct bfi_ioc_image_hdr_s *drv_fwhdr;\r\nint i;\r\ndrv_fwhdr = (struct bfi_ioc_image_hdr_s *)\r\nbfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc), 0);\r\nfor (i = 0; i < BFI_IOC_MD5SUM_SZ; i++) {\r\nif (fwhdr->md5sum[i] != drv_fwhdr->md5sum[i]) {\r\nbfa_trc(ioc, i);\r\nbfa_trc(ioc, fwhdr->md5sum[i]);\r\nbfa_trc(ioc, drv_fwhdr->md5sum[i]);\r\nreturn BFA_FALSE;\r\n}\r\n}\r\nbfa_trc(ioc, fwhdr->md5sum[0]);\r\nreturn BFA_TRUE;\r\n}\r\nstatic bfa_boolean_t\r\nbfa_ioc_fwver_valid(struct bfa_ioc_s *ioc, u32 boot_env)\r\n{\r\nstruct bfi_ioc_image_hdr_s fwhdr, *drv_fwhdr;\r\nbfa_ioc_fwver_get(ioc, &fwhdr);\r\ndrv_fwhdr = (struct bfi_ioc_image_hdr_s *)\r\nbfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc), 0);\r\nif (fwhdr.signature != drv_fwhdr->signature) {\r\nbfa_trc(ioc, fwhdr.signature);\r\nbfa_trc(ioc, drv_fwhdr->signature);\r\nreturn BFA_FALSE;\r\n}\r\nif (swab32(fwhdr.bootenv) != boot_env) {\r\nbfa_trc(ioc, fwhdr.bootenv);\r\nbfa_trc(ioc, boot_env);\r\nreturn BFA_FALSE;\r\n}\r\nreturn bfa_ioc_fwver_cmp(ioc, &fwhdr);\r\n}\r\nstatic void\r\nbfa_ioc_msgflush(struct bfa_ioc_s *ioc)\r\n{\r\nu32 r32;\r\nr32 = readl(ioc->ioc_regs.lpu_mbox_cmd);\r\nif (r32)\r\nwritel(1, ioc->ioc_regs.lpu_mbox_cmd);\r\n}\r\nstatic void\r\nbfa_ioc_hwinit(struct bfa_ioc_s *ioc, bfa_boolean_t force)\r\n{\r\nenum bfi_ioc_state ioc_fwstate;\r\nbfa_boolean_t fwvalid;\r\nu32 boot_type;\r\nu32 boot_env;\r\nioc_fwstate = readl(ioc->ioc_regs.ioc_fwstate);\r\nif (force)\r\nioc_fwstate = BFI_IOC_UNINIT;\r\nbfa_trc(ioc, ioc_fwstate);\r\nboot_type = BFI_FWBOOT_TYPE_NORMAL;\r\nboot_env = BFI_FWBOOT_ENV_OS;\r\nfwvalid = (ioc_fwstate == BFI_IOC_UNINIT) ?\r\nBFA_FALSE : bfa_ioc_fwver_valid(ioc, boot_env);\r\nif (!fwvalid) {\r\nbfa_ioc_boot(ioc, boot_type, boot_env);\r\nbfa_ioc_poll_fwinit(ioc);\r\nreturn;\r\n}\r\nif (ioc_fwstate == BFI_IOC_INITING) {\r\nbfa_ioc_poll_fwinit(ioc);\r\nreturn;\r\n}\r\nif (ioc_fwstate == BFI_IOC_DISABLED || ioc_fwstate == BFI_IOC_OP) {\r\nbfa_ioc_msgflush(ioc);\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_FWREADY);\r\nreturn;\r\n}\r\nbfa_ioc_boot(ioc, boot_type, boot_env);\r\nbfa_ioc_poll_fwinit(ioc);\r\n}\r\nstatic void\r\nbfa_ioc_timeout(void *ioc_arg)\r\n{\r\nstruct bfa_ioc_s *ioc = (struct bfa_ioc_s *) ioc_arg;\r\nbfa_trc(ioc, 0);\r\nbfa_fsm_send_event(ioc, IOC_E_TIMEOUT);\r\n}\r\nvoid\r\nbfa_ioc_mbox_send(struct bfa_ioc_s *ioc, void *ioc_msg, int len)\r\n{\r\nu32 *msgp = (u32 *) ioc_msg;\r\nu32 i;\r\nbfa_trc(ioc, msgp[0]);\r\nbfa_trc(ioc, len);\r\nWARN_ON(len > BFI_IOC_MSGLEN_MAX);\r\nfor (i = 0; i < len / sizeof(u32); i++)\r\nwritel(cpu_to_le32(msgp[i]),\r\nioc->ioc_regs.hfn_mbox + i * sizeof(u32));\r\nfor (; i < BFI_IOC_MSGLEN_MAX / sizeof(u32); i++)\r\nwritel(0, ioc->ioc_regs.hfn_mbox + i * sizeof(u32));\r\nwritel(1, ioc->ioc_regs.hfn_mbox_cmd);\r\n(void) readl(ioc->ioc_regs.hfn_mbox_cmd);\r\n}\r\nstatic void\r\nbfa_ioc_send_enable(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfi_ioc_ctrl_req_s enable_req;\r\nstruct timeval tv;\r\nbfi_h2i_set(enable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_ENABLE_REQ,\r\nbfa_ioc_portid(ioc));\r\nenable_req.clscode = cpu_to_be16(ioc->clscode);\r\ndo_gettimeofday(&tv);\r\nenable_req.tv_sec = be32_to_cpu(tv.tv_sec);\r\nbfa_ioc_mbox_send(ioc, &enable_req, sizeof(struct bfi_ioc_ctrl_req_s));\r\n}\r\nstatic void\r\nbfa_ioc_send_disable(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfi_ioc_ctrl_req_s disable_req;\r\nbfi_h2i_set(disable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_DISABLE_REQ,\r\nbfa_ioc_portid(ioc));\r\nbfa_ioc_mbox_send(ioc, &disable_req, sizeof(struct bfi_ioc_ctrl_req_s));\r\n}\r\nstatic void\r\nbfa_ioc_send_getattr(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfi_ioc_getattr_req_s attr_req;\r\nbfi_h2i_set(attr_req.mh, BFI_MC_IOC, BFI_IOC_H2I_GETATTR_REQ,\r\nbfa_ioc_portid(ioc));\r\nbfa_dma_be_addr_set(attr_req.attr_addr, ioc->attr_dma.pa);\r\nbfa_ioc_mbox_send(ioc, &attr_req, sizeof(attr_req));\r\n}\r\nstatic void\r\nbfa_ioc_hb_check(void *cbarg)\r\n{\r\nstruct bfa_ioc_s *ioc = cbarg;\r\nu32 hb_count;\r\nhb_count = readl(ioc->ioc_regs.heartbeat);\r\nif (ioc->hb_count == hb_count) {\r\nbfa_ioc_recover(ioc);\r\nreturn;\r\n} else {\r\nioc->hb_count = hb_count;\r\n}\r\nbfa_ioc_mbox_poll(ioc);\r\nbfa_hb_timer_start(ioc);\r\n}\r\nstatic void\r\nbfa_ioc_hb_monitor(struct bfa_ioc_s *ioc)\r\n{\r\nioc->hb_count = readl(ioc->ioc_regs.heartbeat);\r\nbfa_hb_timer_start(ioc);\r\n}\r\nstatic void\r\nbfa_ioc_download_fw(struct bfa_ioc_s *ioc, u32 boot_type,\r\nu32 boot_env)\r\n{\r\nu32 *fwimg;\r\nu32 pgnum, pgoff;\r\nu32 loff = 0;\r\nu32 chunkno = 0;\r\nu32 i;\r\nu32 asicmode;\r\nbfa_ioc_lmem_init(ioc);\r\nbfa_trc(ioc, bfa_cb_image_get_size(bfa_ioc_asic_gen(ioc)));\r\nfwimg = bfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc), chunkno);\r\npgnum = PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, loff);\r\npgoff = PSS_SMEM_PGOFF(loff);\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\nfor (i = 0; i < bfa_cb_image_get_size(bfa_ioc_asic_gen(ioc)); i++) {\r\nif (BFA_IOC_FLASH_CHUNK_NO(i) != chunkno) {\r\nchunkno = BFA_IOC_FLASH_CHUNK_NO(i);\r\nfwimg = bfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc),\r\nBFA_IOC_FLASH_CHUNK_ADDR(chunkno));\r\n}\r\nbfa_mem_write(ioc->ioc_regs.smem_page_start, loff,\r\nfwimg[BFA_IOC_FLASH_OFFSET_IN_CHUNK(i)]);\r\nloff += sizeof(u32);\r\nloff = PSS_SMEM_PGOFF(loff);\r\nif (loff == 0) {\r\npgnum++;\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\n}\r\n}\r\nwritel(PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, 0),\r\nioc->ioc_regs.host_page_num_fn);\r\nasicmode = BFI_FWBOOT_DEVMODE(ioc->asic_gen, ioc->asic_mode,\r\nioc->port0_mode, ioc->port1_mode);\r\nbfa_mem_write(ioc->ioc_regs.smem_page_start, BFI_FWBOOT_DEVMODE_OFF,\r\nswab32(asicmode));\r\nbfa_mem_write(ioc->ioc_regs.smem_page_start, BFI_FWBOOT_TYPE_OFF,\r\nswab32(boot_type));\r\nbfa_mem_write(ioc->ioc_regs.smem_page_start, BFI_FWBOOT_ENV_OFF,\r\nswab32(boot_env));\r\n}\r\nstatic void\r\nbfa_ioc_getattr_reply(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfi_ioc_attr_s *attr = ioc->attr;\r\nattr->adapter_prop = be32_to_cpu(attr->adapter_prop);\r\nattr->card_type = be32_to_cpu(attr->card_type);\r\nattr->maxfrsize = be16_to_cpu(attr->maxfrsize);\r\nioc->fcmode = (attr->port_mode == BFI_PORT_MODE_FC);\r\nbfa_fsm_send_event(ioc, IOC_E_FWRSP_GETATTR);\r\n}\r\nstatic void\r\nbfa_ioc_mbox_attach(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;\r\nint mc;\r\nINIT_LIST_HEAD(&mod->cmd_q);\r\nfor (mc = 0; mc < BFI_MC_MAX; mc++) {\r\nmod->mbhdlr[mc].cbfn = NULL;\r\nmod->mbhdlr[mc].cbarg = ioc->bfa;\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_mbox_poll(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;\r\nstruct bfa_mbox_cmd_s *cmd;\r\nu32 stat;\r\nif (list_empty(&mod->cmd_q))\r\nreturn;\r\nstat = readl(ioc->ioc_regs.hfn_mbox_cmd);\r\nif (stat)\r\nreturn;\r\nbfa_q_deq(&mod->cmd_q, &cmd);\r\nbfa_ioc_mbox_send(ioc, cmd->msg, sizeof(cmd->msg));\r\n}\r\nstatic void\r\nbfa_ioc_mbox_flush(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;\r\nstruct bfa_mbox_cmd_s *cmd;\r\nwhile (!list_empty(&mod->cmd_q))\r\nbfa_q_deq(&mod->cmd_q, &cmd);\r\n}\r\nstatic bfa_status_t\r\nbfa_ioc_smem_read(struct bfa_ioc_s *ioc, void *tbuf, u32 soff, u32 sz)\r\n{\r\nu32 pgnum, loff;\r\n__be32 r32;\r\nint i, len;\r\nu32 *buf = tbuf;\r\npgnum = PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, soff);\r\nloff = PSS_SMEM_PGOFF(soff);\r\nbfa_trc(ioc, pgnum);\r\nbfa_trc(ioc, loff);\r\nbfa_trc(ioc, sz);\r\nif (BFA_FALSE == bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg)) {\r\nbfa_trc(ioc, 0);\r\nreturn BFA_STATUS_FAILED;\r\n}\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\nlen = sz/sizeof(u32);\r\nbfa_trc(ioc, len);\r\nfor (i = 0; i < len; i++) {\r\nr32 = bfa_mem_read(ioc->ioc_regs.smem_page_start, loff);\r\nbuf[i] = be32_to_cpu(r32);\r\nloff += sizeof(u32);\r\nloff = PSS_SMEM_PGOFF(loff);\r\nif (loff == 0) {\r\npgnum++;\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\n}\r\n}\r\nwritel(PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, 0),\r\nioc->ioc_regs.host_page_num_fn);\r\nreadl(ioc->ioc_regs.ioc_init_sem_reg);\r\nwritel(1, ioc->ioc_regs.ioc_init_sem_reg);\r\nbfa_trc(ioc, pgnum);\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic bfa_status_t\r\nbfa_ioc_smem_clr(struct bfa_ioc_s *ioc, u32 soff, u32 sz)\r\n{\r\nint i, len;\r\nu32 pgnum, loff;\r\npgnum = PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, soff);\r\nloff = PSS_SMEM_PGOFF(soff);\r\nbfa_trc(ioc, pgnum);\r\nbfa_trc(ioc, loff);\r\nbfa_trc(ioc, sz);\r\nif (BFA_FALSE == bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg)) {\r\nbfa_trc(ioc, 0);\r\nreturn BFA_STATUS_FAILED;\r\n}\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\nlen = sz/sizeof(u32);\r\nbfa_trc(ioc, len);\r\nfor (i = 0; i < len; i++) {\r\nbfa_mem_write(ioc->ioc_regs.smem_page_start, loff, 0);\r\nloff += sizeof(u32);\r\nloff = PSS_SMEM_PGOFF(loff);\r\nif (loff == 0) {\r\npgnum++;\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\n}\r\n}\r\nwritel(PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, 0),\r\nioc->ioc_regs.host_page_num_fn);\r\nreadl(ioc->ioc_regs.ioc_init_sem_reg);\r\nwritel(1, ioc->ioc_regs.ioc_init_sem_reg);\r\nbfa_trc(ioc, pgnum);\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic void\r\nbfa_ioc_fail_notify(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)ioc->bfa->bfad;\r\nioc->cbfn->hbfail_cbfn(ioc->bfa);\r\nbfa_ioc_event_notify(ioc, BFA_IOC_E_FAILED);\r\nbfa_ioc_debug_save_ftrc(ioc);\r\nBFA_LOG(KERN_CRIT, bfad, bfa_log_level,\r\n"Heart Beat of IOC has failed\n");\r\nbfa_ioc_aen_post(ioc, BFA_IOC_AEN_HBFAIL);\r\n}\r\nstatic void\r\nbfa_ioc_pf_fwmismatch(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)ioc->bfa->bfad;\r\nioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\r\nBFA_LOG(KERN_WARNING, bfad, bfa_log_level,\r\n"Running firmware version is incompatible "\r\n"with the driver version\n");\r\nbfa_ioc_aen_post(ioc, BFA_IOC_AEN_FWMISMATCH);\r\n}\r\nbfa_status_t\r\nbfa_ioc_pll_init(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);\r\nbfa_ioc_pll_init_asic(ioc);\r\nioc->pllinit = BFA_TRUE;\r\nreadl(ioc->ioc_regs.ioc_init_sem_reg);\r\nwritel(1, ioc->ioc_regs.ioc_init_sem_reg);\r\nreturn BFA_STATUS_OK;\r\n}\r\nvoid\r\nbfa_ioc_boot(struct bfa_ioc_s *ioc, u32 boot_type, u32 boot_env)\r\n{\r\nbfa_ioc_stats(ioc, ioc_boots);\r\nif (bfa_ioc_pll_init(ioc) != BFA_STATUS_OK)\r\nreturn;\r\nif (boot_type == BFI_FWBOOT_TYPE_MEMTEST) {\r\nwritel(BFI_IOC_MEMTEST, ioc->ioc_regs.ioc_fwstate);\r\nwritel(BFI_IOC_MEMTEST, ioc->ioc_regs.alt_ioc_fwstate);\r\n} else {\r\nwritel(BFI_IOC_INITING, ioc->ioc_regs.ioc_fwstate);\r\nwritel(BFI_IOC_INITING, ioc->ioc_regs.alt_ioc_fwstate);\r\n}\r\nbfa_ioc_msgflush(ioc);\r\nbfa_ioc_download_fw(ioc, boot_type, boot_env);\r\nbfa_ioc_lpu_start(ioc);\r\n}\r\nvoid\r\nbfa_ioc_auto_recover(bfa_boolean_t auto_recover)\r\n{\r\nbfa_auto_recover = auto_recover;\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_is_operational(struct bfa_ioc_s *ioc)\r\n{\r\nreturn bfa_fsm_cmp_state(ioc, bfa_ioc_sm_op);\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_is_initialized(struct bfa_ioc_s *ioc)\r\n{\r\nu32 r32 = readl(ioc->ioc_regs.ioc_fwstate);\r\nreturn ((r32 != BFI_IOC_UNINIT) &&\r\n(r32 != BFI_IOC_INITING) &&\r\n(r32 != BFI_IOC_MEMTEST));\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_msgget(struct bfa_ioc_s *ioc, void *mbmsg)\r\n{\r\n__be32 *msgp = mbmsg;\r\nu32 r32;\r\nint i;\r\nr32 = readl(ioc->ioc_regs.lpu_mbox_cmd);\r\nif ((r32 & 1) == 0)\r\nreturn BFA_FALSE;\r\nfor (i = 0; i < (sizeof(union bfi_ioc_i2h_msg_u) / sizeof(u32));\r\ni++) {\r\nr32 = readl(ioc->ioc_regs.lpu_mbox +\r\ni * sizeof(u32));\r\nmsgp[i] = cpu_to_be32(r32);\r\n}\r\nwritel(1, ioc->ioc_regs.lpu_mbox_cmd);\r\nreadl(ioc->ioc_regs.lpu_mbox_cmd);\r\nreturn BFA_TRUE;\r\n}\r\nvoid\r\nbfa_ioc_isr(struct bfa_ioc_s *ioc, struct bfi_mbmsg_s *m)\r\n{\r\nunion bfi_ioc_i2h_msg_u *msg;\r\nstruct bfa_iocpf_s *iocpf = &ioc->iocpf;\r\nmsg = (union bfi_ioc_i2h_msg_u *) m;\r\nbfa_ioc_stats(ioc, ioc_isrs);\r\nswitch (msg->mh.msg_id) {\r\ncase BFI_IOC_I2H_HBEAT:\r\nbreak;\r\ncase BFI_IOC_I2H_ENABLE_REPLY:\r\nioc->port_mode = ioc->port_mode_cfg =\r\n(enum bfa_mode_s)msg->fw_event.port_mode;\r\nioc->ad_cap_bm = msg->fw_event.cap_bm;\r\nbfa_fsm_send_event(iocpf, IOCPF_E_FWRSP_ENABLE);\r\nbreak;\r\ncase BFI_IOC_I2H_DISABLE_REPLY:\r\nbfa_fsm_send_event(iocpf, IOCPF_E_FWRSP_DISABLE);\r\nbreak;\r\ncase BFI_IOC_I2H_GETATTR_REPLY:\r\nbfa_ioc_getattr_reply(ioc);\r\nbreak;\r\ncase BFI_IOC_I2H_ACQ_ADDR_REPLY:\r\nbfa_fsm_send_event(ioc, IOC_E_FWRSP_ACQ_ADDR);\r\nbreak;\r\ndefault:\r\nbfa_trc(ioc, msg->mh.msg_id);\r\nWARN_ON(1);\r\n}\r\n}\r\nvoid\r\nbfa_ioc_attach(struct bfa_ioc_s *ioc, void *bfa, struct bfa_ioc_cbfn_s *cbfn,\r\nstruct bfa_timer_mod_s *timer_mod)\r\n{\r\nioc->bfa = bfa;\r\nioc->cbfn = cbfn;\r\nioc->timer_mod = timer_mod;\r\nioc->fcmode = BFA_FALSE;\r\nioc->pllinit = BFA_FALSE;\r\nioc->dbg_fwsave_once = BFA_TRUE;\r\nioc->iocpf.ioc = ioc;\r\nbfa_ioc_mbox_attach(ioc);\r\nINIT_LIST_HEAD(&ioc->notify_q);\r\nbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\r\nbfa_fsm_send_event(ioc, IOC_E_RESET);\r\n}\r\nvoid\r\nbfa_ioc_detach(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_fsm_send_event(ioc, IOC_E_DETACH);\r\nINIT_LIST_HEAD(&ioc->notify_q);\r\n}\r\nvoid\r\nbfa_ioc_pci_init(struct bfa_ioc_s *ioc, struct bfa_pcidev_s *pcidev,\r\nenum bfi_pcifn_class clscode)\r\n{\r\nioc->clscode = clscode;\r\nioc->pcidev = *pcidev;\r\nioc->port0_mode = ioc->port1_mode = BFI_PORT_MODE_FC;\r\nioc->asic_mode = BFI_ASIC_MODE_FC;\r\nswitch (pcidev->device_id) {\r\ncase BFA_PCI_DEVICE_ID_FC_8G1P:\r\ncase BFA_PCI_DEVICE_ID_FC_8G2P:\r\nioc->asic_gen = BFI_ASIC_GEN_CB;\r\nioc->fcmode = BFA_TRUE;\r\nioc->port_mode = ioc->port_mode_cfg = BFA_MODE_HBA;\r\nioc->ad_cap_bm = BFA_CM_HBA;\r\nbreak;\r\ncase BFA_PCI_DEVICE_ID_CT:\r\nioc->asic_gen = BFI_ASIC_GEN_CT;\r\nioc->port0_mode = ioc->port1_mode = BFI_PORT_MODE_ETH;\r\nioc->asic_mode = BFI_ASIC_MODE_ETH;\r\nioc->port_mode = ioc->port_mode_cfg = BFA_MODE_CNA;\r\nioc->ad_cap_bm = BFA_CM_CNA;\r\nbreak;\r\ncase BFA_PCI_DEVICE_ID_CT_FC:\r\nioc->asic_gen = BFI_ASIC_GEN_CT;\r\nioc->fcmode = BFA_TRUE;\r\nioc->port_mode = ioc->port_mode_cfg = BFA_MODE_HBA;\r\nioc->ad_cap_bm = BFA_CM_HBA;\r\nbreak;\r\ncase BFA_PCI_DEVICE_ID_CT2:\r\nioc->asic_gen = BFI_ASIC_GEN_CT2;\r\nif (clscode == BFI_PCIFN_CLASS_FC &&\r\npcidev->ssid == BFA_PCI_CT2_SSID_FC) {\r\nioc->asic_mode = BFI_ASIC_MODE_FC16;\r\nioc->fcmode = BFA_TRUE;\r\nioc->port_mode = ioc->port_mode_cfg = BFA_MODE_HBA;\r\nioc->ad_cap_bm = BFA_CM_HBA;\r\n} else {\r\nioc->port0_mode = ioc->port1_mode = BFI_PORT_MODE_ETH;\r\nioc->asic_mode = BFI_ASIC_MODE_ETH;\r\nif (pcidev->ssid == BFA_PCI_CT2_SSID_FCoE) {\r\nioc->port_mode =\r\nioc->port_mode_cfg = BFA_MODE_CNA;\r\nioc->ad_cap_bm = BFA_CM_CNA;\r\n} else {\r\nioc->port_mode =\r\nioc->port_mode_cfg = BFA_MODE_NIC;\r\nioc->ad_cap_bm = BFA_CM_NIC;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nif (ioc->asic_gen == BFI_ASIC_GEN_CB)\r\nbfa_ioc_set_cb_hwif(ioc);\r\nelse if (ioc->asic_gen == BFI_ASIC_GEN_CT)\r\nbfa_ioc_set_ct_hwif(ioc);\r\nelse {\r\nWARN_ON(ioc->asic_gen != BFI_ASIC_GEN_CT2);\r\nbfa_ioc_set_ct2_hwif(ioc);\r\nbfa_ioc_ct2_poweron(ioc);\r\n}\r\nbfa_ioc_map_port(ioc);\r\nbfa_ioc_reg_init(ioc);\r\n}\r\nvoid\r\nbfa_ioc_mem_claim(struct bfa_ioc_s *ioc, u8 *dm_kva, u64 dm_pa)\r\n{\r\nioc->attr_dma.kva = dm_kva;\r\nioc->attr_dma.pa = dm_pa;\r\nioc->attr = (struct bfi_ioc_attr_s *) dm_kva;\r\n}\r\nvoid\r\nbfa_ioc_enable(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_ioc_stats(ioc, ioc_enables);\r\nioc->dbg_fwsave_once = BFA_TRUE;\r\nbfa_fsm_send_event(ioc, IOC_E_ENABLE);\r\n}\r\nvoid\r\nbfa_ioc_disable(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_ioc_stats(ioc, ioc_disables);\r\nbfa_fsm_send_event(ioc, IOC_E_DISABLE);\r\n}\r\nvoid\r\nbfa_ioc_debug_memclaim(struct bfa_ioc_s *ioc, void *dbg_fwsave)\r\n{\r\nioc->dbg_fwsave = dbg_fwsave;\r\nioc->dbg_fwsave_len = (ioc->iocpf.auto_recover) ? BFA_DBG_FWTRC_LEN : 0;\r\n}\r\nvoid\r\nbfa_ioc_mbox_register(struct bfa_ioc_s *ioc, bfa_ioc_mbox_mcfunc_t *mcfuncs)\r\n{\r\nstruct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;\r\nint mc;\r\nfor (mc = 0; mc < BFI_MC_MAX; mc++)\r\nmod->mbhdlr[mc].cbfn = mcfuncs[mc];\r\n}\r\nvoid\r\nbfa_ioc_mbox_regisr(struct bfa_ioc_s *ioc, enum bfi_mclass mc,\r\nbfa_ioc_mbox_mcfunc_t cbfn, void *cbarg)\r\n{\r\nstruct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;\r\nmod->mbhdlr[mc].cbfn = cbfn;\r\nmod->mbhdlr[mc].cbarg = cbarg;\r\n}\r\nvoid\r\nbfa_ioc_mbox_queue(struct bfa_ioc_s *ioc, struct bfa_mbox_cmd_s *cmd)\r\n{\r\nstruct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;\r\nu32 stat;\r\nif (!list_empty(&mod->cmd_q)) {\r\nlist_add_tail(&cmd->qe, &mod->cmd_q);\r\nreturn;\r\n}\r\nstat = readl(ioc->ioc_regs.hfn_mbox_cmd);\r\nif (stat) {\r\nlist_add_tail(&cmd->qe, &mod->cmd_q);\r\nreturn;\r\n}\r\nbfa_ioc_mbox_send(ioc, cmd->msg, sizeof(cmd->msg));\r\n}\r\nvoid\r\nbfa_ioc_mbox_isr(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfa_ioc_mbox_mod_s *mod = &ioc->mbox_mod;\r\nstruct bfi_mbmsg_s m;\r\nint mc;\r\nif (bfa_ioc_msgget(ioc, &m)) {\r\nmc = m.mh.msg_class;\r\nif (mc == BFI_MC_IOC) {\r\nbfa_ioc_isr(ioc, &m);\r\nreturn;\r\n}\r\nif ((mc > BFI_MC_MAX) || (mod->mbhdlr[mc].cbfn == NULL))\r\nreturn;\r\nmod->mbhdlr[mc].cbfn(mod->mbhdlr[mc].cbarg, &m);\r\n}\r\nbfa_ioc_lpu_read_stat(ioc);\r\nbfa_ioc_mbox_poll(ioc);\r\n}\r\nvoid\r\nbfa_ioc_error_isr(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_ioc_stats(ioc, ioc_hbfails);\r\nioc->stats.hb_count = ioc->hb_count;\r\nbfa_fsm_send_event(ioc, IOC_E_HWERROR);\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_is_disabled(struct bfa_ioc_s *ioc)\r\n{\r\nreturn bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabling) ||\r\nbfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled);\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_is_acq_addr(struct bfa_ioc_s *ioc)\r\n{\r\nreturn bfa_fsm_cmp_state(ioc, bfa_ioc_sm_acq_addr);\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_fw_mismatch(struct bfa_ioc_s *ioc)\r\n{\r\nreturn bfa_fsm_cmp_state(ioc, bfa_ioc_sm_reset) ||\r\nbfa_fsm_cmp_state(&ioc->iocpf, bfa_iocpf_sm_fwcheck) ||\r\nbfa_fsm_cmp_state(&ioc->iocpf, bfa_iocpf_sm_mismatch);\r\n}\r\nbfa_boolean_t\r\nbfa_ioc_adapter_is_disabled(struct bfa_ioc_s *ioc)\r\n{\r\nu32 ioc_state;\r\nif (!bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled))\r\nreturn BFA_FALSE;\r\nioc_state = readl(ioc->ioc_regs.ioc_fwstate);\r\nif (!bfa_ioc_state_disabled(ioc_state))\r\nreturn BFA_FALSE;\r\nif (ioc->pcidev.device_id != BFA_PCI_DEVICE_ID_FC_8G1P) {\r\nioc_state = readl(ioc->ioc_regs.alt_ioc_fwstate);\r\nif (!bfa_ioc_state_disabled(ioc_state))\r\nreturn BFA_FALSE;\r\n}\r\nreturn BFA_TRUE;\r\n}\r\nvoid\r\nbfa_ioc_reset_fwstate(struct bfa_ioc_s *ioc)\r\n{\r\nwritel(BFI_IOC_UNINIT, ioc->ioc_regs.ioc_fwstate);\r\nwritel(BFI_IOC_UNINIT, ioc->ioc_regs.alt_ioc_fwstate);\r\n}\r\nvoid\r\nbfa_ioc_get_adapter_attr(struct bfa_ioc_s *ioc,\r\nstruct bfa_adapter_attr_s *ad_attr)\r\n{\r\nstruct bfi_ioc_attr_s *ioc_attr;\r\nioc_attr = ioc->attr;\r\nbfa_ioc_get_adapter_serial_num(ioc, ad_attr->serial_num);\r\nbfa_ioc_get_adapter_fw_ver(ioc, ad_attr->fw_ver);\r\nbfa_ioc_get_adapter_optrom_ver(ioc, ad_attr->optrom_ver);\r\nbfa_ioc_get_adapter_manufacturer(ioc, ad_attr->manufacturer);\r\nmemcpy(&ad_attr->vpd, &ioc_attr->vpd,\r\nsizeof(struct bfa_mfg_vpd_s));\r\nad_attr->nports = bfa_ioc_get_nports(ioc);\r\nad_attr->max_speed = bfa_ioc_speed_sup(ioc);\r\nbfa_ioc_get_adapter_model(ioc, ad_attr->model);\r\nbfa_ioc_get_adapter_model(ioc, ad_attr->model_descr);\r\nad_attr->card_type = ioc_attr->card_type;\r\nad_attr->is_mezz = bfa_mfg_is_mezz(ioc_attr->card_type);\r\nif (BFI_ADAPTER_IS_SPECIAL(ioc_attr->adapter_prop))\r\nad_attr->prototype = 1;\r\nelse\r\nad_attr->prototype = 0;\r\nad_attr->pwwn = ioc->attr->pwwn;\r\nad_attr->mac = bfa_ioc_get_mac(ioc);\r\nad_attr->pcie_gen = ioc_attr->pcie_gen;\r\nad_attr->pcie_lanes = ioc_attr->pcie_lanes;\r\nad_attr->pcie_lanes_orig = ioc_attr->pcie_lanes_orig;\r\nad_attr->asic_rev = ioc_attr->asic_rev;\r\nbfa_ioc_get_pci_chip_rev(ioc, ad_attr->hw_ver);\r\nad_attr->cna_capable = bfa_ioc_is_cna(ioc);\r\nad_attr->trunk_capable = (ad_attr->nports > 1) &&\r\n!bfa_ioc_is_cna(ioc) && !ad_attr->is_mezz;\r\n}\r\nenum bfa_ioc_type_e\r\nbfa_ioc_get_type(struct bfa_ioc_s *ioc)\r\n{\r\nif (ioc->clscode == BFI_PCIFN_CLASS_ETH)\r\nreturn BFA_IOC_TYPE_LL;\r\nWARN_ON(ioc->clscode != BFI_PCIFN_CLASS_FC);\r\nreturn (ioc->attr->port_mode == BFI_PORT_MODE_FC)\r\n? BFA_IOC_TYPE_FC : BFA_IOC_TYPE_FCoE;\r\n}\r\nvoid\r\nbfa_ioc_get_adapter_serial_num(struct bfa_ioc_s *ioc, char *serial_num)\r\n{\r\nmemset((void *)serial_num, 0, BFA_ADAPTER_SERIAL_NUM_LEN);\r\nmemcpy((void *)serial_num,\r\n(void *)ioc->attr->brcd_serialnum,\r\nBFA_ADAPTER_SERIAL_NUM_LEN);\r\n}\r\nvoid\r\nbfa_ioc_get_adapter_fw_ver(struct bfa_ioc_s *ioc, char *fw_ver)\r\n{\r\nmemset((void *)fw_ver, 0, BFA_VERSION_LEN);\r\nmemcpy(fw_ver, ioc->attr->fw_version, BFA_VERSION_LEN);\r\n}\r\nvoid\r\nbfa_ioc_get_pci_chip_rev(struct bfa_ioc_s *ioc, char *chip_rev)\r\n{\r\nWARN_ON(!chip_rev);\r\nmemset((void *)chip_rev, 0, BFA_IOC_CHIP_REV_LEN);\r\nchip_rev[0] = 'R';\r\nchip_rev[1] = 'e';\r\nchip_rev[2] = 'v';\r\nchip_rev[3] = '-';\r\nchip_rev[4] = ioc->attr->asic_rev;\r\nchip_rev[5] = '\0';\r\n}\r\nvoid\r\nbfa_ioc_get_adapter_optrom_ver(struct bfa_ioc_s *ioc, char *optrom_ver)\r\n{\r\nmemset((void *)optrom_ver, 0, BFA_VERSION_LEN);\r\nmemcpy(optrom_ver, ioc->attr->optrom_version,\r\nBFA_VERSION_LEN);\r\n}\r\nvoid\r\nbfa_ioc_get_adapter_manufacturer(struct bfa_ioc_s *ioc, char *manufacturer)\r\n{\r\nmemset((void *)manufacturer, 0, BFA_ADAPTER_MFG_NAME_LEN);\r\nmemcpy(manufacturer, BFA_MFG_NAME, BFA_ADAPTER_MFG_NAME_LEN);\r\n}\r\nvoid\r\nbfa_ioc_get_adapter_model(struct bfa_ioc_s *ioc, char *model)\r\n{\r\nstruct bfi_ioc_attr_s *ioc_attr;\r\nWARN_ON(!model);\r\nmemset((void *)model, 0, BFA_ADAPTER_MODEL_NAME_LEN);\r\nioc_attr = ioc->attr;\r\nsnprintf(model, BFA_ADAPTER_MODEL_NAME_LEN, "%s-%u",\r\nBFA_MFG_NAME, ioc_attr->card_type);\r\n}\r\nenum bfa_ioc_state\r\nbfa_ioc_get_state(struct bfa_ioc_s *ioc)\r\n{\r\nenum bfa_iocpf_state iocpf_st;\r\nenum bfa_ioc_state ioc_st = bfa_sm_to_state(ioc_sm_table, ioc->fsm);\r\nif (ioc_st == BFA_IOC_ENABLING ||\r\nioc_st == BFA_IOC_FAIL || ioc_st == BFA_IOC_INITFAIL) {\r\niocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);\r\nswitch (iocpf_st) {\r\ncase BFA_IOCPF_SEMWAIT:\r\nioc_st = BFA_IOC_SEMWAIT;\r\nbreak;\r\ncase BFA_IOCPF_HWINIT:\r\nioc_st = BFA_IOC_HWINIT;\r\nbreak;\r\ncase BFA_IOCPF_FWMISMATCH:\r\nioc_st = BFA_IOC_FWMISMATCH;\r\nbreak;\r\ncase BFA_IOCPF_FAIL:\r\nioc_st = BFA_IOC_FAIL;\r\nbreak;\r\ncase BFA_IOCPF_INITFAIL:\r\nioc_st = BFA_IOC_INITFAIL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn ioc_st;\r\n}\r\nvoid\r\nbfa_ioc_get_attr(struct bfa_ioc_s *ioc, struct bfa_ioc_attr_s *ioc_attr)\r\n{\r\nmemset((void *)ioc_attr, 0, sizeof(struct bfa_ioc_attr_s));\r\nioc_attr->state = bfa_ioc_get_state(ioc);\r\nioc_attr->port_id = ioc->port_id;\r\nioc_attr->port_mode = ioc->port_mode;\r\nioc_attr->port_mode_cfg = ioc->port_mode_cfg;\r\nioc_attr->cap_bm = ioc->ad_cap_bm;\r\nioc_attr->ioc_type = bfa_ioc_get_type(ioc);\r\nbfa_ioc_get_adapter_attr(ioc, &ioc_attr->adapter_attr);\r\nioc_attr->pci_attr.device_id = ioc->pcidev.device_id;\r\nioc_attr->pci_attr.pcifn = ioc->pcidev.pci_func;\r\nbfa_ioc_get_pci_chip_rev(ioc, ioc_attr->pci_attr.chip_rev);\r\n}\r\nmac_t\r\nbfa_ioc_get_mac(struct bfa_ioc_s *ioc)\r\n{\r\nif (bfa_ioc_get_type(ioc) == BFA_IOC_TYPE_FCoE)\r\nreturn ioc->attr->fcoe_mac;\r\nelse\r\nreturn ioc->attr->mac;\r\n}\r\nmac_t\r\nbfa_ioc_get_mfg_mac(struct bfa_ioc_s *ioc)\r\n{\r\nmac_t m;\r\nm = ioc->attr->mfg_mac;\r\nif (bfa_mfg_is_old_wwn_mac_model(ioc->attr->card_type))\r\nm.mac[MAC_ADDRLEN - 1] += bfa_ioc_pcifn(ioc);\r\nelse\r\nbfa_mfg_increment_wwn_mac(&(m.mac[MAC_ADDRLEN-3]),\r\nbfa_ioc_pcifn(ioc));\r\nreturn m;\r\n}\r\nvoid\r\nbfa_ioc_aen_post(struct bfa_ioc_s *ioc, enum bfa_ioc_aen_event event)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)ioc->bfa->bfad;\r\nstruct bfa_aen_entry_s *aen_entry;\r\nenum bfa_ioc_type_e ioc_type;\r\nbfad_get_aen_entry(bfad, aen_entry);\r\nif (!aen_entry)\r\nreturn;\r\nioc_type = bfa_ioc_get_type(ioc);\r\nswitch (ioc_type) {\r\ncase BFA_IOC_TYPE_FC:\r\naen_entry->aen_data.ioc.pwwn = ioc->attr->pwwn;\r\nbreak;\r\ncase BFA_IOC_TYPE_FCoE:\r\naen_entry->aen_data.ioc.pwwn = ioc->attr->pwwn;\r\naen_entry->aen_data.ioc.mac = bfa_ioc_get_mac(ioc);\r\nbreak;\r\ncase BFA_IOC_TYPE_LL:\r\naen_entry->aen_data.ioc.mac = bfa_ioc_get_mac(ioc);\r\nbreak;\r\ndefault:\r\nWARN_ON(ioc_type != BFA_IOC_TYPE_FC);\r\nbreak;\r\n}\r\naen_entry->aen_data.ioc.ioc_type = ioc_type;\r\nbfad_im_post_vendor_event(aen_entry, bfad, ++ioc->ioc_aen_seq,\r\nBFA_AEN_CAT_IOC, event);\r\n}\r\nbfa_status_t\r\nbfa_ioc_debug_fwsave(struct bfa_ioc_s *ioc, void *trcdata, int *trclen)\r\n{\r\nint tlen;\r\nif (ioc->dbg_fwsave_len == 0)\r\nreturn BFA_STATUS_ENOFSAVE;\r\ntlen = *trclen;\r\nif (tlen > ioc->dbg_fwsave_len)\r\ntlen = ioc->dbg_fwsave_len;\r\nmemcpy(trcdata, ioc->dbg_fwsave, tlen);\r\n*trclen = tlen;\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ioc_debug_fwtrc(struct bfa_ioc_s *ioc, void *trcdata, int *trclen)\r\n{\r\nu32 loff = BFA_DBG_FWTRC_OFF(bfa_ioc_portid(ioc));\r\nint tlen;\r\nbfa_status_t status;\r\nbfa_trc(ioc, *trclen);\r\ntlen = *trclen;\r\nif (tlen > BFA_DBG_FWTRC_LEN)\r\ntlen = BFA_DBG_FWTRC_LEN;\r\nstatus = bfa_ioc_smem_read(ioc, trcdata, loff, tlen);\r\n*trclen = tlen;\r\nreturn status;\r\n}\r\nstatic void\r\nbfa_ioc_send_fwsync(struct bfa_ioc_s *ioc)\r\n{\r\nstruct bfa_mbox_cmd_s cmd;\r\nstruct bfi_ioc_ctrl_req_s *req = (struct bfi_ioc_ctrl_req_s *) cmd.msg;\r\nbfi_h2i_set(req->mh, BFI_MC_IOC, BFI_IOC_H2I_DBG_SYNC,\r\nbfa_ioc_portid(ioc));\r\nreq->clscode = cpu_to_be16(ioc->clscode);\r\nbfa_ioc_mbox_queue(ioc, &cmd);\r\n}\r\nstatic void\r\nbfa_ioc_fwsync(struct bfa_ioc_s *ioc)\r\n{\r\nu32 fwsync_iter = 1000;\r\nbfa_ioc_send_fwsync(ioc);\r\nwhile (bfa_ioc_mbox_cmd_pending(ioc) && fwsync_iter > 0)\r\nfwsync_iter--;\r\n}\r\nbfa_status_t\r\nbfa_ioc_debug_fwcore(struct bfa_ioc_s *ioc, void *buf,\r\nu32 *offset, int *buflen)\r\n{\r\nu32 loff;\r\nint dlen;\r\nbfa_status_t status;\r\nu32 smem_len = BFA_IOC_FW_SMEM_SIZE(ioc);\r\nif (*offset >= smem_len) {\r\n*offset = *buflen = 0;\r\nreturn BFA_STATUS_EINVAL;\r\n}\r\nloff = *offset;\r\ndlen = *buflen;\r\nif (loff == 0)\r\nbfa_ioc_fwsync(ioc);\r\nif ((loff + dlen) >= smem_len)\r\ndlen = smem_len - loff;\r\nstatus = bfa_ioc_smem_read(ioc, buf, loff, dlen);\r\nif (status != BFA_STATUS_OK) {\r\n*offset = *buflen = 0;\r\nreturn status;\r\n}\r\n*offset += dlen;\r\nif (*offset >= smem_len)\r\n*offset = 0;\r\n*buflen = dlen;\r\nreturn status;\r\n}\r\nbfa_status_t\r\nbfa_ioc_fw_stats_get(struct bfa_ioc_s *ioc, void *stats)\r\n{\r\nu32 loff = BFI_IOC_FWSTATS_OFF + \\r\nBFI_IOC_FWSTATS_SZ * (bfa_ioc_portid(ioc));\r\nint tlen;\r\nbfa_status_t status;\r\nif (ioc->stats_busy) {\r\nbfa_trc(ioc, ioc->stats_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nioc->stats_busy = BFA_TRUE;\r\ntlen = sizeof(struct bfa_fw_stats_s);\r\nstatus = bfa_ioc_smem_read(ioc, stats, loff, tlen);\r\nioc->stats_busy = BFA_FALSE;\r\nreturn status;\r\n}\r\nbfa_status_t\r\nbfa_ioc_fw_stats_clear(struct bfa_ioc_s *ioc)\r\n{\r\nu32 loff = BFI_IOC_FWSTATS_OFF + \\r\nBFI_IOC_FWSTATS_SZ * (bfa_ioc_portid(ioc));\r\nint tlen;\r\nbfa_status_t status;\r\nif (ioc->stats_busy) {\r\nbfa_trc(ioc, ioc->stats_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nioc->stats_busy = BFA_TRUE;\r\ntlen = sizeof(struct bfa_fw_stats_s);\r\nstatus = bfa_ioc_smem_clr(ioc, loff, tlen);\r\nioc->stats_busy = BFA_FALSE;\r\nreturn status;\r\n}\r\nstatic void\r\nbfa_ioc_debug_save_ftrc(struct bfa_ioc_s *ioc)\r\n{\r\nint tlen;\r\nif (ioc->dbg_fwsave_once) {\r\nioc->dbg_fwsave_once = BFA_FALSE;\r\nif (ioc->dbg_fwsave_len) {\r\ntlen = ioc->dbg_fwsave_len;\r\nbfa_ioc_debug_fwtrc(ioc, ioc->dbg_fwsave, &tlen);\r\n}\r\n}\r\n}\r\nstatic void\r\nbfa_ioc_recover(struct bfa_ioc_s *ioc)\r\n{\r\nbfa_ioc_stats(ioc, ioc_hbfails);\r\nioc->stats.hb_count = ioc->hb_count;\r\nbfa_fsm_send_event(ioc, IOC_E_HBFAIL);\r\n}\r\nstatic void\r\nbfa_ioc_check_attr_wwns(struct bfa_ioc_s *ioc)\r\n{\r\nif (bfa_ioc_get_type(ioc) == BFA_IOC_TYPE_LL)\r\nreturn;\r\nif (ioc->attr->nwwn == 0)\r\nbfa_ioc_aen_post(ioc, BFA_IOC_AEN_INVALID_NWWN);\r\nif (ioc->attr->pwwn == 0)\r\nbfa_ioc_aen_post(ioc, BFA_IOC_AEN_INVALID_PWWN);\r\n}\r\nstatic void\r\nbfa_iocpf_timeout(void *ioc_arg)\r\n{\r\nstruct bfa_ioc_s *ioc = (struct bfa_ioc_s *) ioc_arg;\r\nbfa_trc(ioc, 0);\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_TIMEOUT);\r\n}\r\nstatic void\r\nbfa_iocpf_sem_timeout(void *ioc_arg)\r\n{\r\nstruct bfa_ioc_s *ioc = (struct bfa_ioc_s *) ioc_arg;\r\nbfa_ioc_hw_sem_get(ioc);\r\n}\r\nstatic void\r\nbfa_ioc_poll_fwinit(struct bfa_ioc_s *ioc)\r\n{\r\nu32 fwstate = readl(ioc->ioc_regs.ioc_fwstate);\r\nbfa_trc(ioc, fwstate);\r\nif (fwstate == BFI_IOC_DISABLED) {\r\nbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_FWREADY);\r\nreturn;\r\n}\r\nif (ioc->iocpf.poll_time >= BFA_IOC_TOV)\r\nbfa_iocpf_timeout(ioc);\r\nelse {\r\nioc->iocpf.poll_time += BFA_IOC_POLL_TOV;\r\nbfa_iocpf_poll_timer_start(ioc);\r\n}\r\n}\r\nstatic void\r\nbfa_iocpf_poll_timeout(void *ioc_arg)\r\n{\r\nstruct bfa_ioc_s *ioc = (struct bfa_ioc_s *) ioc_arg;\r\nbfa_ioc_poll_fwinit(ioc);\r\n}\r\nvoid\r\nbfa_timer_beat(struct bfa_timer_mod_s *mod)\r\n{\r\nstruct list_head *qh = &mod->timer_q;\r\nstruct list_head *qe, *qe_next;\r\nstruct bfa_timer_s *elem;\r\nstruct list_head timedout_q;\r\nINIT_LIST_HEAD(&timedout_q);\r\nqe = bfa_q_next(qh);\r\nwhile (qe != qh) {\r\nqe_next = bfa_q_next(qe);\r\nelem = (struct bfa_timer_s *) qe;\r\nif (elem->timeout <= BFA_TIMER_FREQ) {\r\nelem->timeout = 0;\r\nlist_del(&elem->qe);\r\nlist_add_tail(&elem->qe, &timedout_q);\r\n} else {\r\nelem->timeout -= BFA_TIMER_FREQ;\r\n}\r\nqe = qe_next;\r\n}\r\nwhile (!list_empty(&timedout_q)) {\r\nbfa_q_deq(&timedout_q, &elem);\r\nelem->timercb(elem->arg);\r\n}\r\n}\r\nvoid\r\nbfa_timer_begin(struct bfa_timer_mod_s *mod, struct bfa_timer_s *timer,\r\nvoid (*timercb) (void *), void *arg, unsigned int timeout)\r\n{\r\nWARN_ON(timercb == NULL);\r\nWARN_ON(bfa_q_is_on_q(&mod->timer_q, timer));\r\ntimer->timeout = timeout;\r\ntimer->timercb = timercb;\r\ntimer->arg = arg;\r\nlist_add_tail(&timer->qe, &mod->timer_q);\r\n}\r\nvoid\r\nbfa_timer_stop(struct bfa_timer_s *timer)\r\n{\r\nWARN_ON(list_empty(&timer->qe));\r\nlist_del(&timer->qe);\r\n}\r\nstatic void\r\nbfa_ablk_config_swap(struct bfa_ablk_cfg_s *cfg)\r\n{\r\nstruct bfa_ablk_cfg_inst_s *cfg_inst;\r\nint i, j;\r\nu16 be16;\r\nu32 be32;\r\nfor (i = 0; i < BFA_ABLK_MAX; i++) {\r\ncfg_inst = &cfg->inst[i];\r\nfor (j = 0; j < BFA_ABLK_MAX_PFS; j++) {\r\nbe16 = cfg_inst->pf_cfg[j].pers;\r\ncfg_inst->pf_cfg[j].pers = be16_to_cpu(be16);\r\nbe16 = cfg_inst->pf_cfg[j].num_qpairs;\r\ncfg_inst->pf_cfg[j].num_qpairs = be16_to_cpu(be16);\r\nbe16 = cfg_inst->pf_cfg[j].num_vectors;\r\ncfg_inst->pf_cfg[j].num_vectors = be16_to_cpu(be16);\r\nbe32 = cfg_inst->pf_cfg[j].bw;\r\ncfg_inst->pf_cfg[j].bw = be16_to_cpu(be32);\r\n}\r\n}\r\n}\r\nstatic void\r\nbfa_ablk_isr(void *cbarg, struct bfi_mbmsg_s *msg)\r\n{\r\nstruct bfa_ablk_s *ablk = (struct bfa_ablk_s *)cbarg;\r\nstruct bfi_ablk_i2h_rsp_s *rsp = (struct bfi_ablk_i2h_rsp_s *)msg;\r\nbfa_ablk_cbfn_t cbfn;\r\nWARN_ON(msg->mh.msg_class != BFI_MC_ABLK);\r\nbfa_trc(ablk->ioc, msg->mh.msg_id);\r\nswitch (msg->mh.msg_id) {\r\ncase BFI_ABLK_I2H_QUERY:\r\nif (rsp->status == BFA_STATUS_OK) {\r\nmemcpy(ablk->cfg, ablk->dma_addr.kva,\r\nsizeof(struct bfa_ablk_cfg_s));\r\nbfa_ablk_config_swap(ablk->cfg);\r\nablk->cfg = NULL;\r\n}\r\nbreak;\r\ncase BFI_ABLK_I2H_ADPT_CONFIG:\r\ncase BFI_ABLK_I2H_PORT_CONFIG:\r\nablk->ioc->port_mode_cfg = rsp->port_mode;\r\ncase BFI_ABLK_I2H_PF_DELETE:\r\ncase BFI_ABLK_I2H_PF_UPDATE:\r\ncase BFI_ABLK_I2H_OPTROM_ENABLE:\r\ncase BFI_ABLK_I2H_OPTROM_DISABLE:\r\nbreak;\r\ncase BFI_ABLK_I2H_PF_CREATE:\r\n*(ablk->pcifn) = rsp->pcifn;\r\nablk->pcifn = NULL;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nablk->busy = BFA_FALSE;\r\nif (ablk->cbfn) {\r\ncbfn = ablk->cbfn;\r\nablk->cbfn = NULL;\r\ncbfn(ablk->cbarg, rsp->status);\r\n}\r\n}\r\nstatic void\r\nbfa_ablk_notify(void *cbarg, enum bfa_ioc_event_e event)\r\n{\r\nstruct bfa_ablk_s *ablk = (struct bfa_ablk_s *)cbarg;\r\nbfa_trc(ablk->ioc, event);\r\nswitch (event) {\r\ncase BFA_IOC_E_ENABLED:\r\nWARN_ON(ablk->busy != BFA_FALSE);\r\nbreak;\r\ncase BFA_IOC_E_DISABLED:\r\ncase BFA_IOC_E_FAILED:\r\nablk->pcifn = NULL;\r\nif (ablk->busy) {\r\nif (ablk->cbfn)\r\nablk->cbfn(ablk->cbarg, BFA_STATUS_FAILED);\r\nablk->cbfn = NULL;\r\nablk->busy = BFA_FALSE;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nu32\r\nbfa_ablk_meminfo(void)\r\n{\r\nreturn BFA_ROUNDUP(sizeof(struct bfa_ablk_cfg_s), BFA_DMA_ALIGN_SZ);\r\n}\r\nvoid\r\nbfa_ablk_memclaim(struct bfa_ablk_s *ablk, u8 *dma_kva, u64 dma_pa)\r\n{\r\nablk->dma_addr.kva = dma_kva;\r\nablk->dma_addr.pa = dma_pa;\r\n}\r\nvoid\r\nbfa_ablk_attach(struct bfa_ablk_s *ablk, struct bfa_ioc_s *ioc)\r\n{\r\nablk->ioc = ioc;\r\nbfa_ioc_mbox_regisr(ablk->ioc, BFI_MC_ABLK, bfa_ablk_isr, ablk);\r\nbfa_q_qe_init(&ablk->ioc_notify);\r\nbfa_ioc_notify_init(&ablk->ioc_notify, bfa_ablk_notify, ablk);\r\nlist_add_tail(&ablk->ioc_notify.qe, &ablk->ioc->notify_q);\r\n}\r\nbfa_status_t\r\nbfa_ablk_query(struct bfa_ablk_s *ablk, struct bfa_ablk_cfg_s *ablk_cfg,\r\nbfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_query_s *m;\r\nWARN_ON(!ablk_cfg);\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->cfg = ablk_cfg;\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_query_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_QUERY,\r\nbfa_ioc_portid(ablk->ioc));\r\nbfa_dma_be_addr_set(m->addr, ablk->dma_addr.pa);\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ablk_pf_create(struct bfa_ablk_s *ablk, u16 *pcifn,\r\nu8 port, enum bfi_pcifn_class personality, int bw,\r\nbfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_pf_req_s *m;\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->pcifn = pcifn;\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_pf_req_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_PF_CREATE,\r\nbfa_ioc_portid(ablk->ioc));\r\nm->pers = cpu_to_be16((u16)personality);\r\nm->bw = cpu_to_be32(bw);\r\nm->port = port;\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ablk_pf_delete(struct bfa_ablk_s *ablk, int pcifn,\r\nbfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_pf_req_s *m;\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_pf_req_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_PF_DELETE,\r\nbfa_ioc_portid(ablk->ioc));\r\nm->pcifn = (u8)pcifn;\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ablk_adapter_config(struct bfa_ablk_s *ablk, enum bfa_mode_s mode,\r\nint max_pf, int max_vf, bfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_cfg_req_s *m;\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_cfg_req_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_ADPT_CONFIG,\r\nbfa_ioc_portid(ablk->ioc));\r\nm->mode = (u8)mode;\r\nm->max_pf = (u8)max_pf;\r\nm->max_vf = (u8)max_vf;\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ablk_port_config(struct bfa_ablk_s *ablk, int port, enum bfa_mode_s mode,\r\nint max_pf, int max_vf, bfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_cfg_req_s *m;\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_cfg_req_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_PORT_CONFIG,\r\nbfa_ioc_portid(ablk->ioc));\r\nm->port = (u8)port;\r\nm->mode = (u8)mode;\r\nm->max_pf = (u8)max_pf;\r\nm->max_vf = (u8)max_vf;\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ablk_pf_update(struct bfa_ablk_s *ablk, int pcifn, int bw,\r\nbfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_pf_req_s *m;\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_pf_req_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_PF_UPDATE,\r\nbfa_ioc_portid(ablk->ioc));\r\nm->pcifn = (u8)pcifn;\r\nm->bw = cpu_to_be32(bw);\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ablk_optrom_en(struct bfa_ablk_s *ablk, bfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_optrom_s *m;\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_optrom_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_OPTROM_ENABLE,\r\nbfa_ioc_portid(ablk->ioc));\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_ablk_optrom_dis(struct bfa_ablk_s *ablk, bfa_ablk_cbfn_t cbfn, void *cbarg)\r\n{\r\nstruct bfi_ablk_h2i_optrom_s *m;\r\nif (!bfa_ioc_is_operational(ablk->ioc)) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_IOC_FAILURE);\r\nreturn BFA_STATUS_IOC_FAILURE;\r\n}\r\nif (ablk->busy) {\r\nbfa_trc(ablk->ioc, BFA_STATUS_DEVBUSY);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nablk->cbfn = cbfn;\r\nablk->cbarg = cbarg;\r\nablk->busy = BFA_TRUE;\r\nm = (struct bfi_ablk_h2i_optrom_s *)ablk->mb.msg;\r\nbfi_h2i_set(m->mh, BFI_MC_ABLK, BFI_ABLK_H2I_OPTROM_DISABLE,\r\nbfa_ioc_portid(ablk->ioc));\r\nbfa_ioc_mbox_queue(ablk->ioc, &ablk->mb);\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic void\r\nbfa_cb_sfp_show(struct bfa_sfp_s *sfp)\r\n{\r\nbfa_trc(sfp, sfp->lock);\r\nif (sfp->cbfn)\r\nsfp->cbfn(sfp->cbarg, sfp->status);\r\nsfp->lock = 0;\r\nsfp->cbfn = NULL;\r\n}\r\nstatic void\r\nbfa_cb_sfp_state_query(struct bfa_sfp_s *sfp)\r\n{\r\nbfa_trc(sfp, sfp->portspeed);\r\nif (sfp->media) {\r\nbfa_sfp_media_get(sfp);\r\nif (sfp->state_query_cbfn)\r\nsfp->state_query_cbfn(sfp->state_query_cbarg,\r\nsfp->status);\r\nsfp->media = NULL;\r\n}\r\nif (sfp->portspeed) {\r\nsfp->status = bfa_sfp_speed_valid(sfp, sfp->portspeed);\r\nif (sfp->state_query_cbfn)\r\nsfp->state_query_cbfn(sfp->state_query_cbarg,\r\nsfp->status);\r\nsfp->portspeed = BFA_PORT_SPEED_UNKNOWN;\r\n}\r\nsfp->state_query_lock = 0;\r\nsfp->state_query_cbfn = NULL;\r\n}\r\nstatic void\r\nbfa_sfp_notify(void *sfp_arg, enum bfa_ioc_event_e event)\r\n{\r\nstruct bfa_sfp_s *sfp = sfp_arg;\r\nbfa_trc(sfp, event);\r\nbfa_trc(sfp, sfp->lock);\r\nbfa_trc(sfp, sfp->state_query_lock);\r\nswitch (event) {\r\ncase BFA_IOC_E_DISABLED:\r\ncase BFA_IOC_E_FAILED:\r\nif (sfp->lock) {\r\nsfp->status = BFA_STATUS_IOC_FAILURE;\r\nbfa_cb_sfp_show(sfp);\r\n}\r\nif (sfp->state_query_lock) {\r\nsfp->status = BFA_STATUS_IOC_FAILURE;\r\nbfa_cb_sfp_state_query(sfp);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfa_sfp_scn_aen_post(struct bfa_sfp_s *sfp, struct bfi_sfp_scn_s *rsp)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)sfp->ioc->bfa->bfad;\r\nstruct bfa_aen_entry_s *aen_entry;\r\nenum bfa_port_aen_event aen_evt = 0;\r\nbfa_trc(sfp, (((u64)rsp->pomlvl) << 16) | (((u64)rsp->sfpid) << 8) |\r\n((u64)rsp->event));\r\nbfad_get_aen_entry(bfad, aen_entry);\r\nif (!aen_entry)\r\nreturn;\r\naen_entry->aen_data.port.ioc_type = bfa_ioc_get_type(sfp->ioc);\r\naen_entry->aen_data.port.pwwn = sfp->ioc->attr->pwwn;\r\naen_entry->aen_data.port.mac = bfa_ioc_get_mac(sfp->ioc);\r\nswitch (rsp->event) {\r\ncase BFA_SFP_SCN_INSERTED:\r\naen_evt = BFA_PORT_AEN_SFP_INSERT;\r\nbreak;\r\ncase BFA_SFP_SCN_REMOVED:\r\naen_evt = BFA_PORT_AEN_SFP_REMOVE;\r\nbreak;\r\ncase BFA_SFP_SCN_FAILED:\r\naen_evt = BFA_PORT_AEN_SFP_ACCESS_ERROR;\r\nbreak;\r\ncase BFA_SFP_SCN_UNSUPPORT:\r\naen_evt = BFA_PORT_AEN_SFP_UNSUPPORT;\r\nbreak;\r\ncase BFA_SFP_SCN_POM:\r\naen_evt = BFA_PORT_AEN_SFP_POM;\r\naen_entry->aen_data.port.level = rsp->pomlvl;\r\nbreak;\r\ndefault:\r\nbfa_trc(sfp, rsp->event);\r\nWARN_ON(1);\r\n}\r\nbfad_im_post_vendor_event(aen_entry, bfad, ++sfp->ioc->ioc_aen_seq,\r\nBFA_AEN_CAT_PORT, aen_evt);\r\n}\r\nstatic void\r\nbfa_sfp_getdata_send(struct bfa_sfp_s *sfp)\r\n{\r\nstruct bfi_sfp_req_s *req = (struct bfi_sfp_req_s *)sfp->mbcmd.msg;\r\nbfa_trc(sfp, req->memtype);\r\nbfi_h2i_set(req->mh, BFI_MC_SFP, BFI_SFP_H2I_SHOW,\r\nbfa_ioc_portid(sfp->ioc));\r\nbfa_ioc_mbox_queue(sfp->ioc, &sfp->mbcmd);\r\n}\r\nstatic void\r\nbfa_sfp_getdata(struct bfa_sfp_s *sfp, enum bfi_sfp_mem_e memtype)\r\n{\r\nstruct bfi_sfp_req_s *req = (struct bfi_sfp_req_s *)sfp->mbcmd.msg;\r\nWARN_ON(sfp->lock != 0);\r\nbfa_trc(sfp, sfp->state);\r\nsfp->lock = 1;\r\nsfp->memtype = memtype;\r\nreq->memtype = memtype;\r\nbfa_alen_set(&req->alen, sizeof(struct sfp_mem_s), sfp->dbuf_pa);\r\nbfa_sfp_getdata_send(sfp);\r\n}\r\nstatic void\r\nbfa_sfp_scn(struct bfa_sfp_s *sfp, struct bfi_mbmsg_s *msg)\r\n{\r\nstruct bfi_sfp_scn_s *rsp = (struct bfi_sfp_scn_s *) msg;\r\nswitch (rsp->event) {\r\ncase BFA_SFP_SCN_INSERTED:\r\nsfp->state = BFA_SFP_STATE_INSERTED;\r\nsfp->data_valid = 0;\r\nbfa_sfp_scn_aen_post(sfp, rsp);\r\nbreak;\r\ncase BFA_SFP_SCN_REMOVED:\r\nsfp->state = BFA_SFP_STATE_REMOVED;\r\nsfp->data_valid = 0;\r\nbfa_sfp_scn_aen_post(sfp, rsp);\r\nbreak;\r\ncase BFA_SFP_SCN_FAILED:\r\nsfp->state = BFA_SFP_STATE_FAILED;\r\nsfp->data_valid = 0;\r\nbfa_sfp_scn_aen_post(sfp, rsp);\r\nbreak;\r\ncase BFA_SFP_SCN_UNSUPPORT:\r\nsfp->state = BFA_SFP_STATE_UNSUPPORT;\r\nbfa_sfp_scn_aen_post(sfp, rsp);\r\nif (!sfp->lock)\r\nbfa_sfp_getdata(sfp, BFI_SFP_MEM_ALL);\r\nbreak;\r\ncase BFA_SFP_SCN_POM:\r\nbfa_sfp_scn_aen_post(sfp, rsp);\r\nbreak;\r\ncase BFA_SFP_SCN_VALID:\r\nsfp->state = BFA_SFP_STATE_VALID;\r\nif (!sfp->lock)\r\nbfa_sfp_getdata(sfp, BFI_SFP_MEM_ALL);\r\nbreak;\r\ndefault:\r\nbfa_trc(sfp, rsp->event);\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic void\r\nbfa_sfp_show_comp(struct bfa_sfp_s *sfp, struct bfi_mbmsg_s *msg)\r\n{\r\nstruct bfi_sfp_rsp_s *rsp = (struct bfi_sfp_rsp_s *) msg;\r\nif (!sfp->lock) {\r\nbfa_trc(sfp, sfp->lock);\r\nreturn;\r\n}\r\nbfa_trc(sfp, rsp->status);\r\nif (rsp->status == BFA_STATUS_OK) {\r\nsfp->data_valid = 1;\r\nif (sfp->state == BFA_SFP_STATE_VALID)\r\nsfp->status = BFA_STATUS_OK;\r\nelse if (sfp->state == BFA_SFP_STATE_UNSUPPORT)\r\nsfp->status = BFA_STATUS_SFP_UNSUPP;\r\nelse\r\nbfa_trc(sfp, sfp->state);\r\n} else {\r\nsfp->data_valid = 0;\r\nsfp->status = rsp->status;\r\n}\r\nbfa_trc(sfp, sfp->memtype);\r\nif (sfp->memtype == BFI_SFP_MEM_DIAGEXT) {\r\nbfa_trc(sfp, sfp->data_valid);\r\nif (sfp->data_valid) {\r\nu32 size = sizeof(struct sfp_mem_s);\r\nu8 *des = (u8 *) &(sfp->sfpmem->srlid_base);\r\nmemcpy(des, sfp->dbuf_kva, size);\r\n}\r\nbfa_cb_sfp_show(sfp);\r\n} else\r\nsfp->lock = 0;\r\nbfa_trc(sfp, sfp->state_query_lock);\r\nif (sfp->state_query_lock) {\r\nsfp->state = rsp->state;\r\nbfa_cb_sfp_state_query(sfp);\r\n}\r\n}\r\nstatic void\r\nbfa_sfp_state_query(struct bfa_sfp_s *sfp)\r\n{\r\nstruct bfi_sfp_req_s *req = (struct bfi_sfp_req_s *)sfp->mbcmd.msg;\r\nWARN_ON(sfp->state != BFA_SFP_STATE_INIT);\r\nWARN_ON(sfp->state_query_lock != 0);\r\nbfa_trc(sfp, sfp->state);\r\nsfp->state_query_lock = 1;\r\nreq->memtype = 0;\r\nif (!sfp->lock)\r\nbfa_sfp_getdata(sfp, BFI_SFP_MEM_ALL);\r\n}\r\nstatic void\r\nbfa_sfp_media_get(struct bfa_sfp_s *sfp)\r\n{\r\nenum bfa_defs_sfp_media_e *media = sfp->media;\r\n*media = BFA_SFP_MEDIA_UNKNOWN;\r\nif (sfp->state == BFA_SFP_STATE_UNSUPPORT)\r\n*media = BFA_SFP_MEDIA_UNSUPPORT;\r\nelse if (sfp->state == BFA_SFP_STATE_VALID) {\r\nunion sfp_xcvr_e10g_code_u e10g;\r\nstruct sfp_mem_s *sfpmem = (struct sfp_mem_s *)sfp->dbuf_kva;\r\nu16 xmtr_tech = (sfpmem->srlid_base.xcvr[4] & 0x3) << 7 |\r\n(sfpmem->srlid_base.xcvr[5] >> 1);\r\ne10g.b = sfpmem->srlid_base.xcvr[0];\r\nbfa_trc(sfp, e10g.b);\r\nbfa_trc(sfp, xmtr_tech);\r\nif ((xmtr_tech & SFP_XMTR_TECH_CU) ||\r\n(xmtr_tech & SFP_XMTR_TECH_CP) ||\r\n(xmtr_tech & SFP_XMTR_TECH_CA))\r\n*media = BFA_SFP_MEDIA_CU;\r\nelse if ((xmtr_tech & SFP_XMTR_TECH_EL_INTRA) ||\r\n(xmtr_tech & SFP_XMTR_TECH_EL_INTER))\r\n*media = BFA_SFP_MEDIA_EL;\r\nelse if ((xmtr_tech & SFP_XMTR_TECH_LL) ||\r\n(xmtr_tech & SFP_XMTR_TECH_LC))\r\n*media = BFA_SFP_MEDIA_LW;\r\nelse if ((xmtr_tech & SFP_XMTR_TECH_SL) ||\r\n(xmtr_tech & SFP_XMTR_TECH_SN) ||\r\n(xmtr_tech & SFP_XMTR_TECH_SA))\r\n*media = BFA_SFP_MEDIA_SW;\r\nelse if (e10g.b & 0x10)\r\n*media = BFA_SFP_MEDIA_SW;\r\nelse if (e10g.b & 0x60)\r\n*media = BFA_SFP_MEDIA_LW;\r\nelse if (e10g.r.e10g_unall & 0x80)\r\n*media = BFA_SFP_MEDIA_UNKNOWN;\r\nelse\r\nbfa_trc(sfp, 0);\r\n} else\r\nbfa_trc(sfp, sfp->state);\r\n}\r\nstatic bfa_status_t\r\nbfa_sfp_speed_valid(struct bfa_sfp_s *sfp, enum bfa_port_speed portspeed)\r\n{\r\nstruct sfp_mem_s *sfpmem = (struct sfp_mem_s *)sfp->dbuf_kva;\r\nstruct sfp_xcvr_s *xcvr = (struct sfp_xcvr_s *) sfpmem->srlid_base.xcvr;\r\nunion sfp_xcvr_fc3_code_u fc3 = xcvr->fc3;\r\nunion sfp_xcvr_e10g_code_u e10g = xcvr->e10g;\r\nif (portspeed == BFA_PORT_SPEED_10GBPS) {\r\nif (e10g.r.e10g_sr || e10g.r.e10g_lr)\r\nreturn BFA_STATUS_OK;\r\nelse {\r\nbfa_trc(sfp, e10g.b);\r\nreturn BFA_STATUS_UNSUPP_SPEED;\r\n}\r\n}\r\nif (((portspeed & BFA_PORT_SPEED_16GBPS) && fc3.r.mb1600) ||\r\n((portspeed & BFA_PORT_SPEED_8GBPS) && fc3.r.mb800) ||\r\n((portspeed & BFA_PORT_SPEED_4GBPS) && fc3.r.mb400) ||\r\n((portspeed & BFA_PORT_SPEED_2GBPS) && fc3.r.mb200) ||\r\n((portspeed & BFA_PORT_SPEED_1GBPS) && fc3.r.mb100))\r\nreturn BFA_STATUS_OK;\r\nelse {\r\nbfa_trc(sfp, portspeed);\r\nbfa_trc(sfp, fc3.b);\r\nbfa_trc(sfp, e10g.b);\r\nreturn BFA_STATUS_UNSUPP_SPEED;\r\n}\r\n}\r\nvoid\r\nbfa_sfp_intr(void *sfparg, struct bfi_mbmsg_s *msg)\r\n{\r\nstruct bfa_sfp_s *sfp = sfparg;\r\nswitch (msg->mh.msg_id) {\r\ncase BFI_SFP_I2H_SHOW:\r\nbfa_sfp_show_comp(sfp, msg);\r\nbreak;\r\ncase BFI_SFP_I2H_SCN:\r\nbfa_sfp_scn(sfp, msg);\r\nbreak;\r\ndefault:\r\nbfa_trc(sfp, msg->mh.msg_id);\r\nWARN_ON(1);\r\n}\r\n}\r\nu32\r\nbfa_sfp_meminfo(void)\r\n{\r\nreturn BFA_ROUNDUP(sizeof(struct sfp_mem_s), BFA_DMA_ALIGN_SZ);\r\n}\r\nvoid\r\nbfa_sfp_attach(struct bfa_sfp_s *sfp, struct bfa_ioc_s *ioc, void *dev,\r\nstruct bfa_trc_mod_s *trcmod)\r\n{\r\nsfp->dev = dev;\r\nsfp->ioc = ioc;\r\nsfp->trcmod = trcmod;\r\nsfp->cbfn = NULL;\r\nsfp->cbarg = NULL;\r\nsfp->sfpmem = NULL;\r\nsfp->lock = 0;\r\nsfp->data_valid = 0;\r\nsfp->state = BFA_SFP_STATE_INIT;\r\nsfp->state_query_lock = 0;\r\nsfp->state_query_cbfn = NULL;\r\nsfp->state_query_cbarg = NULL;\r\nsfp->media = NULL;\r\nsfp->portspeed = BFA_PORT_SPEED_UNKNOWN;\r\nsfp->is_elb = BFA_FALSE;\r\nbfa_ioc_mbox_regisr(sfp->ioc, BFI_MC_SFP, bfa_sfp_intr, sfp);\r\nbfa_q_qe_init(&sfp->ioc_notify);\r\nbfa_ioc_notify_init(&sfp->ioc_notify, bfa_sfp_notify, sfp);\r\nlist_add_tail(&sfp->ioc_notify.qe, &sfp->ioc->notify_q);\r\n}\r\nvoid\r\nbfa_sfp_memclaim(struct bfa_sfp_s *sfp, u8 *dm_kva, u64 dm_pa)\r\n{\r\nsfp->dbuf_kva = dm_kva;\r\nsfp->dbuf_pa = dm_pa;\r\nmemset(sfp->dbuf_kva, 0, sizeof(struct sfp_mem_s));\r\ndm_kva += BFA_ROUNDUP(sizeof(struct sfp_mem_s), BFA_DMA_ALIGN_SZ);\r\ndm_pa += BFA_ROUNDUP(sizeof(struct sfp_mem_s), BFA_DMA_ALIGN_SZ);\r\n}\r\nbfa_status_t\r\nbfa_sfp_show(struct bfa_sfp_s *sfp, struct sfp_mem_s *sfpmem,\r\nbfa_cb_sfp_t cbfn, void *cbarg)\r\n{\r\nif (!bfa_ioc_is_operational(sfp->ioc)) {\r\nbfa_trc(sfp, 0);\r\nreturn BFA_STATUS_IOC_NON_OP;\r\n}\r\nif (sfp->lock) {\r\nbfa_trc(sfp, 0);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nsfp->cbfn = cbfn;\r\nsfp->cbarg = cbarg;\r\nsfp->sfpmem = sfpmem;\r\nbfa_sfp_getdata(sfp, BFI_SFP_MEM_DIAGEXT);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_sfp_media(struct bfa_sfp_s *sfp, enum bfa_defs_sfp_media_e *media,\r\nbfa_cb_sfp_t cbfn, void *cbarg)\r\n{\r\nif (!bfa_ioc_is_operational(sfp->ioc)) {\r\nbfa_trc(sfp, 0);\r\nreturn BFA_STATUS_IOC_NON_OP;\r\n}\r\nsfp->media = media;\r\nif (sfp->state == BFA_SFP_STATE_INIT) {\r\nif (sfp->state_query_lock) {\r\nbfa_trc(sfp, 0);\r\nreturn BFA_STATUS_DEVBUSY;\r\n} else {\r\nsfp->state_query_cbfn = cbfn;\r\nsfp->state_query_cbarg = cbarg;\r\nbfa_sfp_state_query(sfp);\r\nreturn BFA_STATUS_SFP_NOT_READY;\r\n}\r\n}\r\nbfa_sfp_media_get(sfp);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_sfp_speed(struct bfa_sfp_s *sfp, enum bfa_port_speed portspeed,\r\nbfa_cb_sfp_t cbfn, void *cbarg)\r\n{\r\nWARN_ON(portspeed == BFA_PORT_SPEED_UNKNOWN);\r\nif (!bfa_ioc_is_operational(sfp->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (bfa_mfg_is_mezz(sfp->ioc->attr->card_type))\r\nreturn BFA_STATUS_OK;\r\nsfp->portspeed = portspeed;\r\nif (sfp->state == BFA_SFP_STATE_INIT) {\r\nif (sfp->state_query_lock) {\r\nbfa_trc(sfp, 0);\r\nreturn BFA_STATUS_DEVBUSY;\r\n} else {\r\nsfp->state_query_cbfn = cbfn;\r\nsfp->state_query_cbarg = cbarg;\r\nbfa_sfp_state_query(sfp);\r\nreturn BFA_STATUS_SFP_NOT_READY;\r\n}\r\n}\r\nif (sfp->state == BFA_SFP_STATE_REMOVED ||\r\nsfp->state == BFA_SFP_STATE_FAILED) {\r\nbfa_trc(sfp, sfp->state);\r\nreturn BFA_STATUS_NO_SFP_DEV;\r\n}\r\nif (sfp->state == BFA_SFP_STATE_INSERTED) {\r\nbfa_trc(sfp, sfp->state);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nif (sfp->is_elb)\r\nreturn BFA_STATUS_OK;\r\nreturn bfa_sfp_speed_valid(sfp, portspeed);\r\n}\r\nstatic void\r\nbfa_flash_aen_audit_post(struct bfa_ioc_s *ioc, enum bfa_audit_aen_event event,\r\nint inst, int type)\r\n{\r\nstruct bfad_s *bfad = (struct bfad_s *)ioc->bfa->bfad;\r\nstruct bfa_aen_entry_s *aen_entry;\r\nbfad_get_aen_entry(bfad, aen_entry);\r\nif (!aen_entry)\r\nreturn;\r\naen_entry->aen_data.audit.pwwn = ioc->attr->pwwn;\r\naen_entry->aen_data.audit.partition_inst = inst;\r\naen_entry->aen_data.audit.partition_type = type;\r\nbfad_im_post_vendor_event(aen_entry, bfad, ++ioc->ioc_aen_seq,\r\nBFA_AEN_CAT_AUDIT, event);\r\n}\r\nstatic void\r\nbfa_flash_cb(struct bfa_flash_s *flash)\r\n{\r\nflash->op_busy = 0;\r\nif (flash->cbfn)\r\nflash->cbfn(flash->cbarg, flash->status);\r\n}\r\nstatic void\r\nbfa_flash_notify(void *cbarg, enum bfa_ioc_event_e event)\r\n{\r\nstruct bfa_flash_s *flash = cbarg;\r\nbfa_trc(flash, event);\r\nswitch (event) {\r\ncase BFA_IOC_E_DISABLED:\r\ncase BFA_IOC_E_FAILED:\r\nif (flash->op_busy) {\r\nflash->status = BFA_STATUS_IOC_FAILURE;\r\nflash->cbfn(flash->cbarg, flash->status);\r\nflash->op_busy = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfa_flash_query_send(void *cbarg)\r\n{\r\nstruct bfa_flash_s *flash = cbarg;\r\nstruct bfi_flash_query_req_s *msg =\r\n(struct bfi_flash_query_req_s *) flash->mb.msg;\r\nbfi_h2i_set(msg->mh, BFI_MC_FLASH, BFI_FLASH_H2I_QUERY_REQ,\r\nbfa_ioc_portid(flash->ioc));\r\nbfa_alen_set(&msg->alen, sizeof(struct bfa_flash_attr_s),\r\nflash->dbuf_pa);\r\nbfa_ioc_mbox_queue(flash->ioc, &flash->mb);\r\n}\r\nstatic void\r\nbfa_flash_write_send(struct bfa_flash_s *flash)\r\n{\r\nstruct bfi_flash_write_req_s *msg =\r\n(struct bfi_flash_write_req_s *) flash->mb.msg;\r\nu32 len;\r\nmsg->type = be32_to_cpu(flash->type);\r\nmsg->instance = flash->instance;\r\nmsg->offset = be32_to_cpu(flash->addr_off + flash->offset);\r\nlen = (flash->residue < BFA_FLASH_DMA_BUF_SZ) ?\r\nflash->residue : BFA_FLASH_DMA_BUF_SZ;\r\nmsg->length = be32_to_cpu(len);\r\nmsg->last = (len == flash->residue) ? 1 : 0;\r\nbfi_h2i_set(msg->mh, BFI_MC_FLASH, BFI_FLASH_H2I_WRITE_REQ,\r\nbfa_ioc_portid(flash->ioc));\r\nbfa_alen_set(&msg->alen, len, flash->dbuf_pa);\r\nmemcpy(flash->dbuf_kva, flash->ubuf + flash->offset, len);\r\nbfa_ioc_mbox_queue(flash->ioc, &flash->mb);\r\nflash->residue -= len;\r\nflash->offset += len;\r\n}\r\nstatic void\r\nbfa_flash_read_send(void *cbarg)\r\n{\r\nstruct bfa_flash_s *flash = cbarg;\r\nstruct bfi_flash_read_req_s *msg =\r\n(struct bfi_flash_read_req_s *) flash->mb.msg;\r\nu32 len;\r\nmsg->type = be32_to_cpu(flash->type);\r\nmsg->instance = flash->instance;\r\nmsg->offset = be32_to_cpu(flash->addr_off + flash->offset);\r\nlen = (flash->residue < BFA_FLASH_DMA_BUF_SZ) ?\r\nflash->residue : BFA_FLASH_DMA_BUF_SZ;\r\nmsg->length = be32_to_cpu(len);\r\nbfi_h2i_set(msg->mh, BFI_MC_FLASH, BFI_FLASH_H2I_READ_REQ,\r\nbfa_ioc_portid(flash->ioc));\r\nbfa_alen_set(&msg->alen, len, flash->dbuf_pa);\r\nbfa_ioc_mbox_queue(flash->ioc, &flash->mb);\r\n}\r\nstatic void\r\nbfa_flash_erase_send(void *cbarg)\r\n{\r\nstruct bfa_flash_s *flash = cbarg;\r\nstruct bfi_flash_erase_req_s *msg =\r\n(struct bfi_flash_erase_req_s *) flash->mb.msg;\r\nmsg->type = be32_to_cpu(flash->type);\r\nmsg->instance = flash->instance;\r\nbfi_h2i_set(msg->mh, BFI_MC_FLASH, BFI_FLASH_H2I_ERASE_REQ,\r\nbfa_ioc_portid(flash->ioc));\r\nbfa_ioc_mbox_queue(flash->ioc, &flash->mb);\r\n}\r\nstatic void\r\nbfa_flash_intr(void *flasharg, struct bfi_mbmsg_s *msg)\r\n{\r\nstruct bfa_flash_s *flash = flasharg;\r\nu32 status;\r\nunion {\r\nstruct bfi_flash_query_rsp_s *query;\r\nstruct bfi_flash_erase_rsp_s *erase;\r\nstruct bfi_flash_write_rsp_s *write;\r\nstruct bfi_flash_read_rsp_s *read;\r\nstruct bfi_flash_event_s *event;\r\nstruct bfi_mbmsg_s *msg;\r\n} m;\r\nm.msg = msg;\r\nbfa_trc(flash, msg->mh.msg_id);\r\nif (!flash->op_busy && msg->mh.msg_id != BFI_FLASH_I2H_EVENT) {\r\nbfa_trc(flash, 0x9999);\r\nreturn;\r\n}\r\nswitch (msg->mh.msg_id) {\r\ncase BFI_FLASH_I2H_QUERY_RSP:\r\nstatus = be32_to_cpu(m.query->status);\r\nbfa_trc(flash, status);\r\nif (status == BFA_STATUS_OK) {\r\nu32 i;\r\nstruct bfa_flash_attr_s *attr, *f;\r\nattr = (struct bfa_flash_attr_s *) flash->ubuf;\r\nf = (struct bfa_flash_attr_s *) flash->dbuf_kva;\r\nattr->status = be32_to_cpu(f->status);\r\nattr->npart = be32_to_cpu(f->npart);\r\nbfa_trc(flash, attr->status);\r\nbfa_trc(flash, attr->npart);\r\nfor (i = 0; i < attr->npart; i++) {\r\nattr->part[i].part_type =\r\nbe32_to_cpu(f->part[i].part_type);\r\nattr->part[i].part_instance =\r\nbe32_to_cpu(f->part[i].part_instance);\r\nattr->part[i].part_off =\r\nbe32_to_cpu(f->part[i].part_off);\r\nattr->part[i].part_size =\r\nbe32_to_cpu(f->part[i].part_size);\r\nattr->part[i].part_len =\r\nbe32_to_cpu(f->part[i].part_len);\r\nattr->part[i].part_status =\r\nbe32_to_cpu(f->part[i].part_status);\r\n}\r\n}\r\nflash->status = status;\r\nbfa_flash_cb(flash);\r\nbreak;\r\ncase BFI_FLASH_I2H_ERASE_RSP:\r\nstatus = be32_to_cpu(m.erase->status);\r\nbfa_trc(flash, status);\r\nflash->status = status;\r\nbfa_flash_cb(flash);\r\nbreak;\r\ncase BFI_FLASH_I2H_WRITE_RSP:\r\nstatus = be32_to_cpu(m.write->status);\r\nbfa_trc(flash, status);\r\nif (status != BFA_STATUS_OK || flash->residue == 0) {\r\nflash->status = status;\r\nbfa_flash_cb(flash);\r\n} else {\r\nbfa_trc(flash, flash->offset);\r\nbfa_flash_write_send(flash);\r\n}\r\nbreak;\r\ncase BFI_FLASH_I2H_READ_RSP:\r\nstatus = be32_to_cpu(m.read->status);\r\nbfa_trc(flash, status);\r\nif (status != BFA_STATUS_OK) {\r\nflash->status = status;\r\nbfa_flash_cb(flash);\r\n} else {\r\nu32 len = be32_to_cpu(m.read->length);\r\nbfa_trc(flash, flash->offset);\r\nbfa_trc(flash, len);\r\nmemcpy(flash->ubuf + flash->offset,\r\nflash->dbuf_kva, len);\r\nflash->residue -= len;\r\nflash->offset += len;\r\nif (flash->residue == 0) {\r\nflash->status = status;\r\nbfa_flash_cb(flash);\r\n} else\r\nbfa_flash_read_send(flash);\r\n}\r\nbreak;\r\ncase BFI_FLASH_I2H_BOOT_VER_RSP:\r\nbreak;\r\ncase BFI_FLASH_I2H_EVENT:\r\nstatus = be32_to_cpu(m.event->status);\r\nbfa_trc(flash, status);\r\nif (status == BFA_STATUS_BAD_FWCFG)\r\nbfa_ioc_aen_post(flash->ioc, BFA_IOC_AEN_FWCFG_ERROR);\r\nelse if (status == BFA_STATUS_INVALID_VENDOR) {\r\nu32 param;\r\nparam = be32_to_cpu(m.event->param);\r\nbfa_trc(flash, param);\r\nbfa_ioc_aen_post(flash->ioc,\r\nBFA_IOC_AEN_INVALID_VENDOR);\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nu32\r\nbfa_flash_meminfo(bfa_boolean_t mincfg)\r\n{\r\nif (mincfg)\r\nreturn 0;\r\nreturn BFA_ROUNDUP(BFA_FLASH_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\r\n}\r\nvoid\r\nbfa_flash_attach(struct bfa_flash_s *flash, struct bfa_ioc_s *ioc, void *dev,\r\nstruct bfa_trc_mod_s *trcmod, bfa_boolean_t mincfg)\r\n{\r\nflash->ioc = ioc;\r\nflash->trcmod = trcmod;\r\nflash->cbfn = NULL;\r\nflash->cbarg = NULL;\r\nflash->op_busy = 0;\r\nbfa_ioc_mbox_regisr(flash->ioc, BFI_MC_FLASH, bfa_flash_intr, flash);\r\nbfa_q_qe_init(&flash->ioc_notify);\r\nbfa_ioc_notify_init(&flash->ioc_notify, bfa_flash_notify, flash);\r\nlist_add_tail(&flash->ioc_notify.qe, &flash->ioc->notify_q);\r\nif (mincfg) {\r\nflash->dbuf_kva = NULL;\r\nflash->dbuf_pa = 0;\r\n}\r\n}\r\nvoid\r\nbfa_flash_memclaim(struct bfa_flash_s *flash, u8 *dm_kva, u64 dm_pa,\r\nbfa_boolean_t mincfg)\r\n{\r\nif (mincfg)\r\nreturn;\r\nflash->dbuf_kva = dm_kva;\r\nflash->dbuf_pa = dm_pa;\r\nmemset(flash->dbuf_kva, 0, BFA_FLASH_DMA_BUF_SZ);\r\ndm_kva += BFA_ROUNDUP(BFA_FLASH_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\r\ndm_pa += BFA_ROUNDUP(BFA_FLASH_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\r\n}\r\nbfa_status_t\r\nbfa_flash_get_attr(struct bfa_flash_s *flash, struct bfa_flash_attr_s *attr,\r\nbfa_cb_flash_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(flash, BFI_FLASH_H2I_QUERY_REQ);\r\nif (!bfa_ioc_is_operational(flash->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (flash->op_busy) {\r\nbfa_trc(flash, flash->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nflash->op_busy = 1;\r\nflash->cbfn = cbfn;\r\nflash->cbarg = cbarg;\r\nflash->ubuf = (u8 *) attr;\r\nbfa_flash_query_send(flash);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_flash_erase_part(struct bfa_flash_s *flash, enum bfa_flash_part_type type,\r\nu8 instance, bfa_cb_flash_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(flash, BFI_FLASH_H2I_ERASE_REQ);\r\nbfa_trc(flash, type);\r\nbfa_trc(flash, instance);\r\nif (!bfa_ioc_is_operational(flash->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (flash->op_busy) {\r\nbfa_trc(flash, flash->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nflash->op_busy = 1;\r\nflash->cbfn = cbfn;\r\nflash->cbarg = cbarg;\r\nflash->type = type;\r\nflash->instance = instance;\r\nbfa_flash_erase_send(flash);\r\nbfa_flash_aen_audit_post(flash->ioc, BFA_AUDIT_AEN_FLASH_ERASE,\r\ninstance, type);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_flash_update_part(struct bfa_flash_s *flash, enum bfa_flash_part_type type,\r\nu8 instance, void *buf, u32 len, u32 offset,\r\nbfa_cb_flash_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(flash, BFI_FLASH_H2I_WRITE_REQ);\r\nbfa_trc(flash, type);\r\nbfa_trc(flash, instance);\r\nbfa_trc(flash, len);\r\nbfa_trc(flash, offset);\r\nif (!bfa_ioc_is_operational(flash->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (!len || (len & 0x03) || (offset & 0x00003FFF))\r\nreturn BFA_STATUS_FLASH_BAD_LEN;\r\nif (type == BFA_FLASH_PART_MFG)\r\nreturn BFA_STATUS_EINVAL;\r\nif (flash->op_busy) {\r\nbfa_trc(flash, flash->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nflash->op_busy = 1;\r\nflash->cbfn = cbfn;\r\nflash->cbarg = cbarg;\r\nflash->type = type;\r\nflash->instance = instance;\r\nflash->residue = len;\r\nflash->offset = 0;\r\nflash->addr_off = offset;\r\nflash->ubuf = buf;\r\nbfa_flash_write_send(flash);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_flash_read_part(struct bfa_flash_s *flash, enum bfa_flash_part_type type,\r\nu8 instance, void *buf, u32 len, u32 offset,\r\nbfa_cb_flash_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(flash, BFI_FLASH_H2I_READ_REQ);\r\nbfa_trc(flash, type);\r\nbfa_trc(flash, instance);\r\nbfa_trc(flash, len);\r\nbfa_trc(flash, offset);\r\nif (!bfa_ioc_is_operational(flash->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (!len || (len & 0x03) || (offset & 0x00003FFF))\r\nreturn BFA_STATUS_FLASH_BAD_LEN;\r\nif (flash->op_busy) {\r\nbfa_trc(flash, flash->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nflash->op_busy = 1;\r\nflash->cbfn = cbfn;\r\nflash->cbarg = cbarg;\r\nflash->type = type;\r\nflash->instance = instance;\r\nflash->residue = len;\r\nflash->offset = 0;\r\nflash->addr_off = offset;\r\nflash->ubuf = buf;\r\nbfa_flash_read_send(flash);\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic void\r\nbfa_diag_notify(void *diag_arg, enum bfa_ioc_event_e event)\r\n{\r\nstruct bfa_diag_s *diag = diag_arg;\r\nbfa_trc(diag, event);\r\nbfa_trc(diag, diag->block);\r\nbfa_trc(diag, diag->fwping.lock);\r\nbfa_trc(diag, diag->tsensor.lock);\r\nswitch (event) {\r\ncase BFA_IOC_E_DISABLED:\r\ncase BFA_IOC_E_FAILED:\r\nif (diag->fwping.lock) {\r\ndiag->fwping.status = BFA_STATUS_IOC_FAILURE;\r\ndiag->fwping.cbfn(diag->fwping.cbarg,\r\ndiag->fwping.status);\r\ndiag->fwping.lock = 0;\r\n}\r\nif (diag->tsensor.lock) {\r\ndiag->tsensor.status = BFA_STATUS_IOC_FAILURE;\r\ndiag->tsensor.cbfn(diag->tsensor.cbarg,\r\ndiag->tsensor.status);\r\ndiag->tsensor.lock = 0;\r\n}\r\nif (diag->block) {\r\nif (diag->timer_active) {\r\nbfa_timer_stop(&diag->timer);\r\ndiag->timer_active = 0;\r\n}\r\ndiag->status = BFA_STATUS_IOC_FAILURE;\r\ndiag->cbfn(diag->cbarg, diag->status);\r\ndiag->block = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfa_diag_memtest_done(void *cbarg)\r\n{\r\nstruct bfa_diag_s *diag = cbarg;\r\nstruct bfa_ioc_s *ioc = diag->ioc;\r\nstruct bfa_diag_memtest_result *res = diag->result;\r\nu32 loff = BFI_BOOT_MEMTEST_RES_ADDR;\r\nu32 pgnum, pgoff, i;\r\npgnum = PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, loff);\r\npgoff = PSS_SMEM_PGOFF(loff);\r\nwritel(pgnum, ioc->ioc_regs.host_page_num_fn);\r\nfor (i = 0; i < (sizeof(struct bfa_diag_memtest_result) /\r\nsizeof(u32)); i++) {\r\n*((u32 *) res + i) =\r\nbfa_mem_read(ioc->ioc_regs.smem_page_start, loff);\r\nloff += sizeof(u32);\r\n}\r\nbfa_ioc_reset_fwstate(ioc);\r\nres->status = swab32(res->status);\r\nbfa_trc(diag, res->status);\r\nif (res->status == BFI_BOOT_MEMTEST_RES_SIG)\r\ndiag->status = BFA_STATUS_OK;\r\nelse {\r\ndiag->status = BFA_STATUS_MEMTEST_FAILED;\r\nres->addr = swab32(res->addr);\r\nres->exp = swab32(res->exp);\r\nres->act = swab32(res->act);\r\nres->err_status = swab32(res->err_status);\r\nres->err_status1 = swab32(res->err_status1);\r\nres->err_addr = swab32(res->err_addr);\r\nbfa_trc(diag, res->addr);\r\nbfa_trc(diag, res->exp);\r\nbfa_trc(diag, res->act);\r\nbfa_trc(diag, res->err_status);\r\nbfa_trc(diag, res->err_status1);\r\nbfa_trc(diag, res->err_addr);\r\n}\r\ndiag->timer_active = 0;\r\ndiag->cbfn(diag->cbarg, diag->status);\r\ndiag->block = 0;\r\n}\r\nstatic void\r\ndiag_fwping_send(struct bfa_diag_s *diag)\r\n{\r\nstruct bfi_diag_fwping_req_s *fwping_req;\r\nu32 i;\r\nbfa_trc(diag, diag->fwping.dbuf_pa);\r\nfor (i = 0; i < (BFI_DIAG_DMA_BUF_SZ >> 2); i++)\r\n*((u32 *)diag->fwping.dbuf_kva + i) = diag->fwping.data;\r\nfwping_req = (struct bfi_diag_fwping_req_s *)diag->fwping.mbcmd.msg;\r\nbfa_alen_set(&fwping_req->alen, BFI_DIAG_DMA_BUF_SZ,\r\ndiag->fwping.dbuf_pa);\r\nfwping_req->count = cpu_to_be32(diag->fwping.count);\r\nfwping_req->data = diag->fwping.data;\r\nbfi_h2i_set(fwping_req->mh, BFI_MC_DIAG, BFI_DIAG_H2I_FWPING,\r\nbfa_ioc_portid(diag->ioc));\r\nbfa_ioc_mbox_queue(diag->ioc, &diag->fwping.mbcmd);\r\n}\r\nstatic void\r\ndiag_fwping_comp(struct bfa_diag_s *diag,\r\nstruct bfi_diag_fwping_rsp_s *diag_rsp)\r\n{\r\nu32 rsp_data = diag_rsp->data;\r\nu8 rsp_dma_status = diag_rsp->dma_status;\r\nbfa_trc(diag, rsp_data);\r\nbfa_trc(diag, rsp_dma_status);\r\nif (rsp_dma_status == BFA_STATUS_OK) {\r\nu32 i, pat;\r\npat = (diag->fwping.count & 0x1) ? ~(diag->fwping.data) :\r\ndiag->fwping.data;\r\nif (diag->fwping.data != rsp_data) {\r\nbfa_trc(diag, rsp_data);\r\ndiag->fwping.result->dmastatus =\r\nBFA_STATUS_DATACORRUPTED;\r\ndiag->fwping.status = BFA_STATUS_DATACORRUPTED;\r\ndiag->fwping.cbfn(diag->fwping.cbarg,\r\ndiag->fwping.status);\r\ndiag->fwping.lock = 0;\r\nreturn;\r\n}\r\nfor (i = 0; i < (BFI_DIAG_DMA_BUF_SZ >> 2); i++) {\r\nif (*((u32 *)diag->fwping.dbuf_kva + i) != pat) {\r\nbfa_trc(diag, i);\r\nbfa_trc(diag, pat);\r\nbfa_trc(diag,\r\n*((u32 *)diag->fwping.dbuf_kva + i));\r\ndiag->fwping.result->dmastatus =\r\nBFA_STATUS_DATACORRUPTED;\r\ndiag->fwping.status = BFA_STATUS_DATACORRUPTED;\r\ndiag->fwping.cbfn(diag->fwping.cbarg,\r\ndiag->fwping.status);\r\ndiag->fwping.lock = 0;\r\nreturn;\r\n}\r\n}\r\ndiag->fwping.result->dmastatus = BFA_STATUS_OK;\r\ndiag->fwping.status = BFA_STATUS_OK;\r\ndiag->fwping.cbfn(diag->fwping.cbarg, diag->fwping.status);\r\ndiag->fwping.lock = 0;\r\n} else {\r\ndiag->fwping.status = BFA_STATUS_HDMA_FAILED;\r\ndiag->fwping.cbfn(diag->fwping.cbarg, diag->fwping.status);\r\ndiag->fwping.lock = 0;\r\n}\r\n}\r\nstatic void\r\ndiag_tempsensor_send(struct bfa_diag_s *diag)\r\n{\r\nstruct bfi_diag_ts_req_s *msg;\r\nmsg = (struct bfi_diag_ts_req_s *)diag->tsensor.mbcmd.msg;\r\nbfa_trc(diag, msg->temp);\r\nbfi_h2i_set(msg->mh, BFI_MC_DIAG, BFI_DIAG_H2I_TEMPSENSOR,\r\nbfa_ioc_portid(diag->ioc));\r\nbfa_ioc_mbox_queue(diag->ioc, &diag->tsensor.mbcmd);\r\n}\r\nstatic void\r\ndiag_tempsensor_comp(struct bfa_diag_s *diag, bfi_diag_ts_rsp_t *rsp)\r\n{\r\nif (!diag->tsensor.lock) {\r\nbfa_trc(diag, diag->tsensor.lock);\r\nreturn;\r\n}\r\ndiag->tsensor.temp->temp = be16_to_cpu(rsp->temp);\r\ndiag->tsensor.temp->ts_junc = rsp->ts_junc;\r\ndiag->tsensor.temp->ts_brd = rsp->ts_brd;\r\ndiag->tsensor.temp->status = BFA_STATUS_OK;\r\nif (rsp->ts_brd) {\r\nif (rsp->status == BFA_STATUS_OK) {\r\ndiag->tsensor.temp->brd_temp =\r\nbe16_to_cpu(rsp->brd_temp);\r\n} else {\r\nbfa_trc(diag, rsp->status);\r\ndiag->tsensor.temp->brd_temp = 0;\r\ndiag->tsensor.temp->status = BFA_STATUS_DEVBUSY;\r\n}\r\n}\r\nbfa_trc(diag, rsp->ts_junc);\r\nbfa_trc(diag, rsp->temp);\r\nbfa_trc(diag, rsp->ts_brd);\r\nbfa_trc(diag, rsp->brd_temp);\r\ndiag->tsensor.cbfn(diag->tsensor.cbarg, diag->tsensor.status);\r\ndiag->tsensor.lock = 0;\r\n}\r\nstatic void\r\ndiag_ledtest_send(struct bfa_diag_s *diag, struct bfa_diag_ledtest_s *ledtest)\r\n{\r\nstruct bfi_diag_ledtest_req_s *msg;\r\nmsg = (struct bfi_diag_ledtest_req_s *)diag->ledtest.mbcmd.msg;\r\nbfi_h2i_set(msg->mh, BFI_MC_DIAG, BFI_DIAG_H2I_LEDTEST,\r\nbfa_ioc_portid(diag->ioc));\r\nif (ledtest->freq)\r\nledtest->freq = 500 / ledtest->freq;\r\nif (ledtest->freq == 0)\r\nledtest->freq = 1;\r\nbfa_trc(diag, ledtest->freq);\r\nmsg->cmd = (u8) ledtest->cmd;\r\nmsg->color = (u8) ledtest->color;\r\nmsg->portid = bfa_ioc_portid(diag->ioc);\r\nmsg->led = ledtest->led;\r\nmsg->freq = cpu_to_be16(ledtest->freq);\r\nbfa_ioc_mbox_queue(diag->ioc, &diag->ledtest.mbcmd);\r\n}\r\nstatic void\r\ndiag_ledtest_comp(struct bfa_diag_s *diag, struct bfi_diag_ledtest_rsp_s * msg)\r\n{\r\nbfa_trc(diag, diag->ledtest.lock);\r\ndiag->ledtest.lock = BFA_FALSE;\r\n}\r\nstatic void\r\ndiag_portbeacon_send(struct bfa_diag_s *diag, bfa_boolean_t beacon, u32 sec)\r\n{\r\nstruct bfi_diag_portbeacon_req_s *msg;\r\nmsg = (struct bfi_diag_portbeacon_req_s *)diag->beacon.mbcmd.msg;\r\nbfi_h2i_set(msg->mh, BFI_MC_DIAG, BFI_DIAG_H2I_PORTBEACON,\r\nbfa_ioc_portid(diag->ioc));\r\nmsg->beacon = beacon;\r\nmsg->period = cpu_to_be32(sec);\r\nbfa_ioc_mbox_queue(diag->ioc, &diag->beacon.mbcmd);\r\n}\r\nstatic void\r\ndiag_portbeacon_comp(struct bfa_diag_s *diag)\r\n{\r\nbfa_trc(diag, diag->beacon.state);\r\ndiag->beacon.state = BFA_FALSE;\r\nif (diag->cbfn_beacon)\r\ndiag->cbfn_beacon(diag->dev, BFA_FALSE, diag->beacon.link_e2e);\r\n}\r\nvoid\r\nbfa_diag_intr(void *diagarg, struct bfi_mbmsg_s *msg)\r\n{\r\nstruct bfa_diag_s *diag = diagarg;\r\nswitch (msg->mh.msg_id) {\r\ncase BFI_DIAG_I2H_PORTBEACON:\r\ndiag_portbeacon_comp(diag);\r\nbreak;\r\ncase BFI_DIAG_I2H_FWPING:\r\ndiag_fwping_comp(diag, (struct bfi_diag_fwping_rsp_s *) msg);\r\nbreak;\r\ncase BFI_DIAG_I2H_TEMPSENSOR:\r\ndiag_tempsensor_comp(diag, (bfi_diag_ts_rsp_t *) msg);\r\nbreak;\r\ncase BFI_DIAG_I2H_LEDTEST:\r\ndiag_ledtest_comp(diag, (struct bfi_diag_ledtest_rsp_s *) msg);\r\nbreak;\r\ndefault:\r\nbfa_trc(diag, msg->mh.msg_id);\r\nWARN_ON(1);\r\n}\r\n}\r\nbfa_status_t\r\nbfa_diag_memtest(struct bfa_diag_s *diag, struct bfa_diag_memtest_s *memtest,\r\nu32 pattern, struct bfa_diag_memtest_result *result,\r\nbfa_cb_diag_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(diag, pattern);\r\nif (!bfa_ioc_adapter_is_disabled(diag->ioc))\r\nreturn BFA_STATUS_ADAPTER_ENABLED;\r\nif (diag->block) {\r\nbfa_trc(diag, diag->block);\r\nreturn BFA_STATUS_DEVBUSY;\r\n} else\r\ndiag->block = 1;\r\ndiag->result = result;\r\ndiag->cbfn = cbfn;\r\ndiag->cbarg = cbarg;\r\nbfa_ioc_boot(diag->ioc, BFI_FWBOOT_TYPE_MEMTEST, BFI_FWBOOT_ENV_OS);\r\nbfa_timer_begin(diag->ioc->timer_mod, &diag->timer,\r\nbfa_diag_memtest_done, diag, BFA_DIAG_MEMTEST_TOV);\r\ndiag->timer_active = 1;\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_diag_fwping(struct bfa_diag_s *diag, u32 cnt, u32 data,\r\nstruct bfa_diag_results_fwping *result, bfa_cb_diag_t cbfn,\r\nvoid *cbarg)\r\n{\r\nbfa_trc(diag, cnt);\r\nbfa_trc(diag, data);\r\nif (!bfa_ioc_is_operational(diag->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (bfa_asic_id_ct2(bfa_ioc_devid((diag->ioc))) &&\r\n((diag->ioc)->clscode == BFI_PCIFN_CLASS_ETH))\r\nreturn BFA_STATUS_CMD_NOTSUPP;\r\nif (diag->block || diag->fwping.lock) {\r\nbfa_trc(diag, diag->block);\r\nbfa_trc(diag, diag->fwping.lock);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\ndiag->fwping.lock = 1;\r\ndiag->fwping.cbfn = cbfn;\r\ndiag->fwping.cbarg = cbarg;\r\ndiag->fwping.result = result;\r\ndiag->fwping.data = data;\r\ndiag->fwping.count = cnt;\r\ndiag->fwping.result->data = 0;\r\ndiag->fwping.result->status = BFA_STATUS_OK;\r\ndiag_fwping_send(diag);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_diag_tsensor_query(struct bfa_diag_s *diag,\r\nstruct bfa_diag_results_tempsensor_s *result,\r\nbfa_cb_diag_t cbfn, void *cbarg)\r\n{\r\nif (diag->block || diag->tsensor.lock) {\r\nbfa_trc(diag, diag->block);\r\nbfa_trc(diag, diag->tsensor.lock);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nif (!bfa_ioc_is_operational(diag->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\ndiag->tsensor.lock = 1;\r\ndiag->tsensor.temp = result;\r\ndiag->tsensor.cbfn = cbfn;\r\ndiag->tsensor.cbarg = cbarg;\r\ndiag_tempsensor_send(diag);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_diag_ledtest(struct bfa_diag_s *diag, struct bfa_diag_ledtest_s *ledtest)\r\n{\r\nbfa_trc(diag, ledtest->cmd);\r\nif (!bfa_ioc_is_operational(diag->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (diag->beacon.state)\r\nreturn BFA_STATUS_BEACON_ON;\r\nif (diag->ledtest.lock)\r\nreturn BFA_STATUS_LEDTEST_OP;\r\ndiag->ledtest.lock = BFA_TRUE;\r\ndiag_ledtest_send(diag, ledtest);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_diag_beacon_port(struct bfa_diag_s *diag, bfa_boolean_t beacon,\r\nbfa_boolean_t link_e2e_beacon, uint32_t sec)\r\n{\r\nbfa_trc(diag, beacon);\r\nbfa_trc(diag, link_e2e_beacon);\r\nbfa_trc(diag, sec);\r\nif (!bfa_ioc_is_operational(diag->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (diag->ledtest.lock)\r\nreturn BFA_STATUS_LEDTEST_OP;\r\nif (diag->beacon.state && beacon)\r\nreturn BFA_STATUS_BEACON_ON;\r\ndiag->beacon.state = beacon;\r\ndiag->beacon.link_e2e = link_e2e_beacon;\r\nif (diag->cbfn_beacon)\r\ndiag->cbfn_beacon(diag->dev, beacon, link_e2e_beacon);\r\ndiag_portbeacon_send(diag, beacon, sec);\r\nreturn BFA_STATUS_OK;\r\n}\r\nu32\r\nbfa_diag_meminfo(void)\r\n{\r\nreturn BFA_ROUNDUP(BFI_DIAG_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\r\n}\r\nvoid\r\nbfa_diag_attach(struct bfa_diag_s *diag, struct bfa_ioc_s *ioc, void *dev,\r\nbfa_cb_diag_beacon_t cbfn_beacon, struct bfa_trc_mod_s *trcmod)\r\n{\r\ndiag->dev = dev;\r\ndiag->ioc = ioc;\r\ndiag->trcmod = trcmod;\r\ndiag->block = 0;\r\ndiag->cbfn = NULL;\r\ndiag->cbarg = NULL;\r\ndiag->result = NULL;\r\ndiag->cbfn_beacon = cbfn_beacon;\r\nbfa_ioc_mbox_regisr(diag->ioc, BFI_MC_DIAG, bfa_diag_intr, diag);\r\nbfa_q_qe_init(&diag->ioc_notify);\r\nbfa_ioc_notify_init(&diag->ioc_notify, bfa_diag_notify, diag);\r\nlist_add_tail(&diag->ioc_notify.qe, &diag->ioc->notify_q);\r\n}\r\nvoid\r\nbfa_diag_memclaim(struct bfa_diag_s *diag, u8 *dm_kva, u64 dm_pa)\r\n{\r\ndiag->fwping.dbuf_kva = dm_kva;\r\ndiag->fwping.dbuf_pa = dm_pa;\r\nmemset(diag->fwping.dbuf_kva, 0, BFI_DIAG_DMA_BUF_SZ);\r\n}\r\nstatic void\r\nbfa_phy_ntoh32(u32 *obuf, u32 *ibuf, int sz)\r\n{\r\nint i, m = sz >> 2;\r\nfor (i = 0; i < m; i++)\r\nobuf[i] = be32_to_cpu(ibuf[i]);\r\n}\r\nstatic bfa_boolean_t\r\nbfa_phy_present(struct bfa_phy_s *phy)\r\n{\r\nreturn (phy->ioc->attr->card_type == BFA_MFG_TYPE_LIGHTNING);\r\n}\r\nstatic void\r\nbfa_phy_notify(void *cbarg, enum bfa_ioc_event_e event)\r\n{\r\nstruct bfa_phy_s *phy = cbarg;\r\nbfa_trc(phy, event);\r\nswitch (event) {\r\ncase BFA_IOC_E_DISABLED:\r\ncase BFA_IOC_E_FAILED:\r\nif (phy->op_busy) {\r\nphy->status = BFA_STATUS_IOC_FAILURE;\r\nphy->cbfn(phy->cbarg, phy->status);\r\nphy->op_busy = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfa_phy_query_send(void *cbarg)\r\n{\r\nstruct bfa_phy_s *phy = cbarg;\r\nstruct bfi_phy_query_req_s *msg =\r\n(struct bfi_phy_query_req_s *) phy->mb.msg;\r\nmsg->instance = phy->instance;\r\nbfi_h2i_set(msg->mh, BFI_MC_PHY, BFI_PHY_H2I_QUERY_REQ,\r\nbfa_ioc_portid(phy->ioc));\r\nbfa_alen_set(&msg->alen, sizeof(struct bfa_phy_attr_s), phy->dbuf_pa);\r\nbfa_ioc_mbox_queue(phy->ioc, &phy->mb);\r\n}\r\nstatic void\r\nbfa_phy_write_send(void *cbarg)\r\n{\r\nstruct bfa_phy_s *phy = cbarg;\r\nstruct bfi_phy_write_req_s *msg =\r\n(struct bfi_phy_write_req_s *) phy->mb.msg;\r\nu32 len;\r\nu16 *buf, *dbuf;\r\nint i, sz;\r\nmsg->instance = phy->instance;\r\nmsg->offset = cpu_to_be32(phy->addr_off + phy->offset);\r\nlen = (phy->residue < BFA_PHY_DMA_BUF_SZ) ?\r\nphy->residue : BFA_PHY_DMA_BUF_SZ;\r\nmsg->length = cpu_to_be32(len);\r\nmsg->last = (len == phy->residue) ? 1 : 0;\r\nbfi_h2i_set(msg->mh, BFI_MC_PHY, BFI_PHY_H2I_WRITE_REQ,\r\nbfa_ioc_portid(phy->ioc));\r\nbfa_alen_set(&msg->alen, len, phy->dbuf_pa);\r\nbuf = (u16 *) (phy->ubuf + phy->offset);\r\ndbuf = (u16 *)phy->dbuf_kva;\r\nsz = len >> 1;\r\nfor (i = 0; i < sz; i++)\r\nbuf[i] = cpu_to_be16(dbuf[i]);\r\nbfa_ioc_mbox_queue(phy->ioc, &phy->mb);\r\nphy->residue -= len;\r\nphy->offset += len;\r\n}\r\nstatic void\r\nbfa_phy_read_send(void *cbarg)\r\n{\r\nstruct bfa_phy_s *phy = cbarg;\r\nstruct bfi_phy_read_req_s *msg =\r\n(struct bfi_phy_read_req_s *) phy->mb.msg;\r\nu32 len;\r\nmsg->instance = phy->instance;\r\nmsg->offset = cpu_to_be32(phy->addr_off + phy->offset);\r\nlen = (phy->residue < BFA_PHY_DMA_BUF_SZ) ?\r\nphy->residue : BFA_PHY_DMA_BUF_SZ;\r\nmsg->length = cpu_to_be32(len);\r\nbfi_h2i_set(msg->mh, BFI_MC_PHY, BFI_PHY_H2I_READ_REQ,\r\nbfa_ioc_portid(phy->ioc));\r\nbfa_alen_set(&msg->alen, len, phy->dbuf_pa);\r\nbfa_ioc_mbox_queue(phy->ioc, &phy->mb);\r\n}\r\nstatic void\r\nbfa_phy_stats_send(void *cbarg)\r\n{\r\nstruct bfa_phy_s *phy = cbarg;\r\nstruct bfi_phy_stats_req_s *msg =\r\n(struct bfi_phy_stats_req_s *) phy->mb.msg;\r\nmsg->instance = phy->instance;\r\nbfi_h2i_set(msg->mh, BFI_MC_PHY, BFI_PHY_H2I_STATS_REQ,\r\nbfa_ioc_portid(phy->ioc));\r\nbfa_alen_set(&msg->alen, sizeof(struct bfa_phy_stats_s), phy->dbuf_pa);\r\nbfa_ioc_mbox_queue(phy->ioc, &phy->mb);\r\n}\r\nu32\r\nbfa_phy_meminfo(bfa_boolean_t mincfg)\r\n{\r\nif (mincfg)\r\nreturn 0;\r\nreturn BFA_ROUNDUP(BFA_PHY_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\r\n}\r\nvoid\r\nbfa_phy_attach(struct bfa_phy_s *phy, struct bfa_ioc_s *ioc, void *dev,\r\nstruct bfa_trc_mod_s *trcmod, bfa_boolean_t mincfg)\r\n{\r\nphy->ioc = ioc;\r\nphy->trcmod = trcmod;\r\nphy->cbfn = NULL;\r\nphy->cbarg = NULL;\r\nphy->op_busy = 0;\r\nbfa_ioc_mbox_regisr(phy->ioc, BFI_MC_PHY, bfa_phy_intr, phy);\r\nbfa_q_qe_init(&phy->ioc_notify);\r\nbfa_ioc_notify_init(&phy->ioc_notify, bfa_phy_notify, phy);\r\nlist_add_tail(&phy->ioc_notify.qe, &phy->ioc->notify_q);\r\nif (mincfg) {\r\nphy->dbuf_kva = NULL;\r\nphy->dbuf_pa = 0;\r\n}\r\n}\r\nvoid\r\nbfa_phy_memclaim(struct bfa_phy_s *phy, u8 *dm_kva, u64 dm_pa,\r\nbfa_boolean_t mincfg)\r\n{\r\nif (mincfg)\r\nreturn;\r\nphy->dbuf_kva = dm_kva;\r\nphy->dbuf_pa = dm_pa;\r\nmemset(phy->dbuf_kva, 0, BFA_PHY_DMA_BUF_SZ);\r\ndm_kva += BFA_ROUNDUP(BFA_PHY_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\r\ndm_pa += BFA_ROUNDUP(BFA_PHY_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\r\n}\r\nbfa_boolean_t\r\nbfa_phy_busy(struct bfa_ioc_s *ioc)\r\n{\r\nvoid __iomem *rb;\r\nrb = bfa_ioc_bar0(ioc);\r\nreturn readl(rb + BFA_PHY_LOCK_STATUS);\r\n}\r\nbfa_status_t\r\nbfa_phy_get_attr(struct bfa_phy_s *phy, u8 instance,\r\nstruct bfa_phy_attr_s *attr, bfa_cb_phy_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(phy, BFI_PHY_H2I_QUERY_REQ);\r\nbfa_trc(phy, instance);\r\nif (!bfa_phy_present(phy))\r\nreturn BFA_STATUS_PHY_NOT_PRESENT;\r\nif (!bfa_ioc_is_operational(phy->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (phy->op_busy || bfa_phy_busy(phy->ioc)) {\r\nbfa_trc(phy, phy->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nphy->op_busy = 1;\r\nphy->cbfn = cbfn;\r\nphy->cbarg = cbarg;\r\nphy->instance = instance;\r\nphy->ubuf = (uint8_t *) attr;\r\nbfa_phy_query_send(phy);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_phy_get_stats(struct bfa_phy_s *phy, u8 instance,\r\nstruct bfa_phy_stats_s *stats,\r\nbfa_cb_phy_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(phy, BFI_PHY_H2I_STATS_REQ);\r\nbfa_trc(phy, instance);\r\nif (!bfa_phy_present(phy))\r\nreturn BFA_STATUS_PHY_NOT_PRESENT;\r\nif (!bfa_ioc_is_operational(phy->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (phy->op_busy || bfa_phy_busy(phy->ioc)) {\r\nbfa_trc(phy, phy->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nphy->op_busy = 1;\r\nphy->cbfn = cbfn;\r\nphy->cbarg = cbarg;\r\nphy->instance = instance;\r\nphy->ubuf = (u8 *) stats;\r\nbfa_phy_stats_send(phy);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_phy_update(struct bfa_phy_s *phy, u8 instance,\r\nvoid *buf, u32 len, u32 offset,\r\nbfa_cb_phy_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(phy, BFI_PHY_H2I_WRITE_REQ);\r\nbfa_trc(phy, instance);\r\nbfa_trc(phy, len);\r\nbfa_trc(phy, offset);\r\nif (!bfa_phy_present(phy))\r\nreturn BFA_STATUS_PHY_NOT_PRESENT;\r\nif (!bfa_ioc_is_operational(phy->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (!len || (len & 0x03))\r\nreturn BFA_STATUS_FAILED;\r\nif (phy->op_busy || bfa_phy_busy(phy->ioc)) {\r\nbfa_trc(phy, phy->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nphy->op_busy = 1;\r\nphy->cbfn = cbfn;\r\nphy->cbarg = cbarg;\r\nphy->instance = instance;\r\nphy->residue = len;\r\nphy->offset = 0;\r\nphy->addr_off = offset;\r\nphy->ubuf = buf;\r\nbfa_phy_write_send(phy);\r\nreturn BFA_STATUS_OK;\r\n}\r\nbfa_status_t\r\nbfa_phy_read(struct bfa_phy_s *phy, u8 instance,\r\nvoid *buf, u32 len, u32 offset,\r\nbfa_cb_phy_t cbfn, void *cbarg)\r\n{\r\nbfa_trc(phy, BFI_PHY_H2I_READ_REQ);\r\nbfa_trc(phy, instance);\r\nbfa_trc(phy, len);\r\nbfa_trc(phy, offset);\r\nif (!bfa_phy_present(phy))\r\nreturn BFA_STATUS_PHY_NOT_PRESENT;\r\nif (!bfa_ioc_is_operational(phy->ioc))\r\nreturn BFA_STATUS_IOC_NON_OP;\r\nif (!len || (len & 0x03))\r\nreturn BFA_STATUS_FAILED;\r\nif (phy->op_busy || bfa_phy_busy(phy->ioc)) {\r\nbfa_trc(phy, phy->op_busy);\r\nreturn BFA_STATUS_DEVBUSY;\r\n}\r\nphy->op_busy = 1;\r\nphy->cbfn = cbfn;\r\nphy->cbarg = cbarg;\r\nphy->instance = instance;\r\nphy->residue = len;\r\nphy->offset = 0;\r\nphy->addr_off = offset;\r\nphy->ubuf = buf;\r\nbfa_phy_read_send(phy);\r\nreturn BFA_STATUS_OK;\r\n}\r\nvoid\r\nbfa_phy_intr(void *phyarg, struct bfi_mbmsg_s *msg)\r\n{\r\nstruct bfa_phy_s *phy = phyarg;\r\nu32 status;\r\nunion {\r\nstruct bfi_phy_query_rsp_s *query;\r\nstruct bfi_phy_stats_rsp_s *stats;\r\nstruct bfi_phy_write_rsp_s *write;\r\nstruct bfi_phy_read_rsp_s *read;\r\nstruct bfi_mbmsg_s *msg;\r\n} m;\r\nm.msg = msg;\r\nbfa_trc(phy, msg->mh.msg_id);\r\nif (!phy->op_busy) {\r\nbfa_trc(phy, 0x9999);\r\nreturn;\r\n}\r\nswitch (msg->mh.msg_id) {\r\ncase BFI_PHY_I2H_QUERY_RSP:\r\nstatus = be32_to_cpu(m.query->status);\r\nbfa_trc(phy, status);\r\nif (status == BFA_STATUS_OK) {\r\nstruct bfa_phy_attr_s *attr =\r\n(struct bfa_phy_attr_s *) phy->ubuf;\r\nbfa_phy_ntoh32((u32 *)attr, (u32 *)phy->dbuf_kva,\r\nsizeof(struct bfa_phy_attr_s));\r\nbfa_trc(phy, attr->status);\r\nbfa_trc(phy, attr->length);\r\n}\r\nphy->status = status;\r\nphy->op_busy = 0;\r\nif (phy->cbfn)\r\nphy->cbfn(phy->cbarg, phy->status);\r\nbreak;\r\ncase BFI_PHY_I2H_STATS_RSP:\r\nstatus = be32_to_cpu(m.stats->status);\r\nbfa_trc(phy, status);\r\nif (status == BFA_STATUS_OK) {\r\nstruct bfa_phy_stats_s *stats =\r\n(struct bfa_phy_stats_s *) phy->ubuf;\r\nbfa_phy_ntoh32((u32 *)stats, (u32 *)phy->dbuf_kva,\r\nsizeof(struct bfa_phy_stats_s));\r\nbfa_trc(phy, stats->status);\r\n}\r\nphy->status = status;\r\nphy->op_busy = 0;\r\nif (phy->cbfn)\r\nphy->cbfn(phy->cbarg, phy->status);\r\nbreak;\r\ncase BFI_PHY_I2H_WRITE_RSP:\r\nstatus = be32_to_cpu(m.write->status);\r\nbfa_trc(phy, status);\r\nif (status != BFA_STATUS_OK || phy->residue == 0) {\r\nphy->status = status;\r\nphy->op_busy = 0;\r\nif (phy->cbfn)\r\nphy->cbfn(phy->cbarg, phy->status);\r\n} else {\r\nbfa_trc(phy, phy->offset);\r\nbfa_phy_write_send(phy);\r\n}\r\nbreak;\r\ncase BFI_PHY_I2H_READ_RSP:\r\nstatus = be32_to_cpu(m.read->status);\r\nbfa_trc(phy, status);\r\nif (status != BFA_STATUS_OK) {\r\nphy->status = status;\r\nphy->op_busy = 0;\r\nif (phy->cbfn)\r\nphy->cbfn(phy->cbarg, phy->status);\r\n} else {\r\nu32 len = be32_to_cpu(m.read->length);\r\nu16 *buf = (u16 *)(phy->ubuf + phy->offset);\r\nu16 *dbuf = (u16 *)phy->dbuf_kva;\r\nint i, sz = len >> 1;\r\nbfa_trc(phy, phy->offset);\r\nbfa_trc(phy, len);\r\nfor (i = 0; i < sz; i++)\r\nbuf[i] = be16_to_cpu(dbuf[i]);\r\nphy->residue -= len;\r\nphy->offset += len;\r\nif (phy->residue == 0) {\r\nphy->status = status;\r\nphy->op_busy = 0;\r\nif (phy->cbfn)\r\nphy->cbfn(phy->cbarg, phy->status);\r\n} else\r\nbfa_phy_read_send(phy);\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_sm_uninit(struct bfa_dconf_mod_s *dconf, enum bfa_dconf_event event)\r\n{\r\nbfa_status_t bfa_status;\r\nbfa_trc(dconf->bfa, event);\r\nswitch (event) {\r\ncase BFA_DCONF_SM_INIT:\r\nif (dconf->min_cfg) {\r\nbfa_trc(dconf->bfa, dconf->min_cfg);\r\nreturn;\r\n}\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_flash_read);\r\ndconf->flashdone = BFA_FALSE;\r\nbfa_trc(dconf->bfa, dconf->flashdone);\r\nbfa_status = bfa_flash_read_part(BFA_FLASH(dconf->bfa),\r\nBFA_FLASH_PART_DRV, dconf->instance,\r\ndconf->dconf,\r\nsizeof(struct bfa_dconf_s), 0,\r\nbfa_dconf_init_cb, dconf->bfa);\r\nif (bfa_status != BFA_STATUS_OK) {\r\nbfa_dconf_init_cb(dconf->bfa, BFA_STATUS_FAILED);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_uninit);\r\nreturn;\r\n}\r\nbreak;\r\ncase BFA_DCONF_SM_EXIT:\r\ndconf->flashdone = BFA_TRUE;\r\ncase BFA_DCONF_SM_IOCDISABLE:\r\ncase BFA_DCONF_SM_WR:\r\ncase BFA_DCONF_SM_FLASH_COMP:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(dconf->bfa, event);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_sm_flash_read(struct bfa_dconf_mod_s *dconf,\r\nenum bfa_dconf_event event)\r\n{\r\nbfa_trc(dconf->bfa, event);\r\nswitch (event) {\r\ncase BFA_DCONF_SM_FLASH_COMP:\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_ready);\r\nbreak;\r\ncase BFA_DCONF_SM_TIMEOUT:\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_ready);\r\nbreak;\r\ncase BFA_DCONF_SM_EXIT:\r\ndconf->flashdone = BFA_TRUE;\r\nbfa_trc(dconf->bfa, dconf->flashdone);\r\ncase BFA_DCONF_SM_IOCDISABLE:\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_uninit);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(dconf->bfa, event);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_sm_ready(struct bfa_dconf_mod_s *dconf, enum bfa_dconf_event event)\r\n{\r\nbfa_trc(dconf->bfa, event);\r\nswitch (event) {\r\ncase BFA_DCONF_SM_WR:\r\nbfa_timer_start(dconf->bfa, &dconf->timer,\r\nbfa_dconf_timer, dconf, BFA_DCONF_UPDATE_TOV);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_dirty);\r\nbreak;\r\ncase BFA_DCONF_SM_EXIT:\r\ndconf->flashdone = BFA_TRUE;\r\nbfa_trc(dconf->bfa, dconf->flashdone);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_uninit);\r\nbreak;\r\ncase BFA_DCONF_SM_INIT:\r\ncase BFA_DCONF_SM_IOCDISABLE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(dconf->bfa, event);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_sm_dirty(struct bfa_dconf_mod_s *dconf, enum bfa_dconf_event event)\r\n{\r\nbfa_trc(dconf->bfa, event);\r\nswitch (event) {\r\ncase BFA_DCONF_SM_TIMEOUT:\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_sync);\r\nbfa_dconf_flash_write(dconf);\r\nbreak;\r\ncase BFA_DCONF_SM_WR:\r\nbfa_timer_stop(&dconf->timer);\r\nbfa_timer_start(dconf->bfa, &dconf->timer,\r\nbfa_dconf_timer, dconf, BFA_DCONF_UPDATE_TOV);\r\nbreak;\r\ncase BFA_DCONF_SM_EXIT:\r\nbfa_timer_stop(&dconf->timer);\r\nbfa_timer_start(dconf->bfa, &dconf->timer,\r\nbfa_dconf_timer, dconf, BFA_DCONF_UPDATE_TOV);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_final_sync);\r\nbfa_dconf_flash_write(dconf);\r\nbreak;\r\ncase BFA_DCONF_SM_FLASH_COMP:\r\nbreak;\r\ncase BFA_DCONF_SM_IOCDISABLE:\r\nbfa_timer_stop(&dconf->timer);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_iocdown_dirty);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(dconf->bfa, event);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_sm_final_sync(struct bfa_dconf_mod_s *dconf,\r\nenum bfa_dconf_event event)\r\n{\r\nbfa_trc(dconf->bfa, event);\r\nswitch (event) {\r\ncase BFA_DCONF_SM_IOCDISABLE:\r\ncase BFA_DCONF_SM_FLASH_COMP:\r\nbfa_timer_stop(&dconf->timer);\r\ncase BFA_DCONF_SM_TIMEOUT:\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_uninit);\r\ndconf->flashdone = BFA_TRUE;\r\nbfa_trc(dconf->bfa, dconf->flashdone);\r\nbfa_ioc_disable(&dconf->bfa->ioc);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(dconf->bfa, event);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_sm_sync(struct bfa_dconf_mod_s *dconf, enum bfa_dconf_event event)\r\n{\r\nbfa_trc(dconf->bfa, event);\r\nswitch (event) {\r\ncase BFA_DCONF_SM_FLASH_COMP:\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_ready);\r\nbreak;\r\ncase BFA_DCONF_SM_WR:\r\nbfa_timer_start(dconf->bfa, &dconf->timer,\r\nbfa_dconf_timer, dconf, BFA_DCONF_UPDATE_TOV);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_dirty);\r\nbreak;\r\ncase BFA_DCONF_SM_EXIT:\r\nbfa_timer_start(dconf->bfa, &dconf->timer,\r\nbfa_dconf_timer, dconf, BFA_DCONF_UPDATE_TOV);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_final_sync);\r\nbreak;\r\ncase BFA_DCONF_SM_IOCDISABLE:\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_iocdown_dirty);\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(dconf->bfa, event);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_sm_iocdown_dirty(struct bfa_dconf_mod_s *dconf,\r\nenum bfa_dconf_event event)\r\n{\r\nbfa_trc(dconf->bfa, event);\r\nswitch (event) {\r\ncase BFA_DCONF_SM_INIT:\r\nbfa_timer_start(dconf->bfa, &dconf->timer,\r\nbfa_dconf_timer, dconf, BFA_DCONF_UPDATE_TOV);\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_dirty);\r\nbreak;\r\ncase BFA_DCONF_SM_EXIT:\r\ndconf->flashdone = BFA_TRUE;\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_uninit);\r\nbreak;\r\ncase BFA_DCONF_SM_IOCDISABLE:\r\nbreak;\r\ndefault:\r\nbfa_sm_fault(dconf->bfa, event);\r\n}\r\n}\r\nstatic void\r\nbfa_dconf_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *meminfo,\r\nstruct bfa_s *bfa)\r\n{\r\nstruct bfa_mem_kva_s *dconf_kva = BFA_MEM_DCONF_KVA(bfa);\r\nif (cfg->drvcfg.min_cfg)\r\nbfa_mem_kva_setup(meminfo, dconf_kva,\r\nsizeof(struct bfa_dconf_hdr_s));\r\nelse\r\nbfa_mem_kva_setup(meminfo, dconf_kva,\r\nsizeof(struct bfa_dconf_s));\r\n}\r\nstatic void\r\nbfa_dconf_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\r\nstruct bfa_pcidev_s *pcidev)\r\n{\r\nstruct bfa_dconf_mod_s *dconf = BFA_DCONF_MOD(bfa);\r\ndconf->bfad = bfad;\r\ndconf->bfa = bfa;\r\ndconf->instance = bfa->ioc.port_id;\r\nbfa_trc(bfa, dconf->instance);\r\ndconf->dconf = (struct bfa_dconf_s *) bfa_mem_kva_curp(dconf);\r\nif (cfg->drvcfg.min_cfg) {\r\nbfa_mem_kva_curp(dconf) += sizeof(struct bfa_dconf_hdr_s);\r\ndconf->min_cfg = BFA_TRUE;\r\ndconf->flashdone = BFA_TRUE;\r\n} else {\r\ndconf->min_cfg = BFA_FALSE;\r\nbfa_mem_kva_curp(dconf) += sizeof(struct bfa_dconf_s);\r\n}\r\nbfa_dconf_read_data_valid(bfa) = BFA_FALSE;\r\nbfa_sm_set_state(dconf, bfa_dconf_sm_uninit);\r\n}\r\nstatic void\r\nbfa_dconf_init_cb(void *arg, bfa_status_t status)\r\n{\r\nstruct bfa_s *bfa = arg;\r\nstruct bfa_dconf_mod_s *dconf = BFA_DCONF_MOD(bfa);\r\ndconf->flashdone = BFA_TRUE;\r\nbfa_trc(bfa, dconf->flashdone);\r\nbfa_iocfc_cb_dconf_modinit(bfa, status);\r\nif (status == BFA_STATUS_OK) {\r\nbfa_dconf_read_data_valid(bfa) = BFA_TRUE;\r\nif (dconf->dconf->hdr.signature != BFI_DCONF_SIGNATURE)\r\ndconf->dconf->hdr.signature = BFI_DCONF_SIGNATURE;\r\nif (dconf->dconf->hdr.version != BFI_DCONF_VERSION)\r\ndconf->dconf->hdr.version = BFI_DCONF_VERSION;\r\n}\r\nbfa_sm_send_event(dconf, BFA_DCONF_SM_FLASH_COMP);\r\n}\r\nvoid\r\nbfa_dconf_modinit(struct bfa_s *bfa)\r\n{\r\nstruct bfa_dconf_mod_s *dconf = BFA_DCONF_MOD(bfa);\r\nbfa_sm_send_event(dconf, BFA_DCONF_SM_INIT);\r\n}\r\nstatic void\r\nbfa_dconf_start(struct bfa_s *bfa)\r\n{\r\n}\r\nstatic void\r\nbfa_dconf_stop(struct bfa_s *bfa)\r\n{\r\n}\r\nstatic void bfa_dconf_timer(void *cbarg)\r\n{\r\nstruct bfa_dconf_mod_s *dconf = cbarg;\r\nbfa_sm_send_event(dconf, BFA_DCONF_SM_TIMEOUT);\r\n}\r\nstatic void\r\nbfa_dconf_iocdisable(struct bfa_s *bfa)\r\n{\r\nstruct bfa_dconf_mod_s *dconf = BFA_DCONF_MOD(bfa);\r\nbfa_sm_send_event(dconf, BFA_DCONF_SM_IOCDISABLE);\r\n}\r\nstatic void\r\nbfa_dconf_detach(struct bfa_s *bfa)\r\n{\r\n}\r\nstatic bfa_status_t\r\nbfa_dconf_flash_write(struct bfa_dconf_mod_s *dconf)\r\n{\r\nbfa_status_t bfa_status;\r\nbfa_trc(dconf->bfa, 0);\r\nbfa_status = bfa_flash_update_part(BFA_FLASH(dconf->bfa),\r\nBFA_FLASH_PART_DRV, dconf->instance,\r\ndconf->dconf, sizeof(struct bfa_dconf_s), 0,\r\nbfa_dconf_cbfn, dconf);\r\nif (bfa_status != BFA_STATUS_OK)\r\nWARN_ON(bfa_status);\r\nbfa_trc(dconf->bfa, bfa_status);\r\nreturn bfa_status;\r\n}\r\nbfa_status_t\r\nbfa_dconf_update(struct bfa_s *bfa)\r\n{\r\nstruct bfa_dconf_mod_s *dconf = BFA_DCONF_MOD(bfa);\r\nbfa_trc(dconf->bfa, 0);\r\nif (bfa_sm_cmp_state(dconf, bfa_dconf_sm_iocdown_dirty))\r\nreturn BFA_STATUS_FAILED;\r\nif (dconf->min_cfg) {\r\nbfa_trc(dconf->bfa, dconf->min_cfg);\r\nreturn BFA_STATUS_FAILED;\r\n}\r\nbfa_sm_send_event(dconf, BFA_DCONF_SM_WR);\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic void\r\nbfa_dconf_cbfn(void *arg, bfa_status_t status)\r\n{\r\nstruct bfa_dconf_mod_s *dconf = arg;\r\nWARN_ON(status);\r\nbfa_sm_send_event(dconf, BFA_DCONF_SM_FLASH_COMP);\r\n}\r\nvoid\r\nbfa_dconf_modexit(struct bfa_s *bfa)\r\n{\r\nstruct bfa_dconf_mod_s *dconf = BFA_DCONF_MOD(bfa);\r\nBFA_DCONF_MOD(bfa)->flashdone = BFA_FALSE;\r\nbfa_trc(bfa, BFA_DCONF_MOD(bfa)->flashdone);\r\nbfa_sm_send_event(dconf, BFA_DCONF_SM_EXIT);\r\n}
