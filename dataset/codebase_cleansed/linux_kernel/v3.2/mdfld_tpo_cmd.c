static struct drm_display_mode *tpo_cmd_get_config_mode(struct drm_device *dev)\r\n{\r\nstruct drm_display_mode *mode;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mrst_timing_info *ti = &dev_priv->gct_data.DTD;\r\nbool use_gct = false;\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode)\r\nreturn NULL;\r\nif (use_gct) {\r\ndev_dbg(dev->dev, "gct find MIPI panel.\n");\r\nmode->hdisplay = (ti->hactive_hi << 8) | ti->hactive_lo;\r\nmode->vdisplay = (ti->vactive_hi << 8) | ti->vactive_lo;\r\nmode->hsync_start = mode->hdisplay + \\r\n((ti->hsync_offset_hi << 8) | \\r\nti->hsync_offset_lo);\r\nmode->hsync_end = mode->hsync_start + \\r\n((ti->hsync_pulse_width_hi << 8) | \\r\nti->hsync_pulse_width_lo);\r\nmode->htotal = mode->hdisplay + ((ti->hblank_hi << 8) | \\r\nti->hblank_lo);\r\nmode->vsync_start = \\r\nmode->vdisplay + ((ti->vsync_offset_hi << 8) | \\r\nti->vsync_offset_lo);\r\nmode->vsync_end = \\r\nmode->vsync_start + ((ti->vsync_pulse_width_hi << 8) | \\r\nti->vsync_pulse_width_lo);\r\nmode->vtotal = mode->vdisplay + \\r\n((ti->vblank_hi << 8) | ti->vblank_lo);\r\nmode->clock = ti->pixel_clock * 10;\r\ndev_dbg(dev->dev, "hdisplay is %d\n", mode->hdisplay);\r\ndev_dbg(dev->dev, "vdisplay is %d\n", mode->vdisplay);\r\ndev_dbg(dev->dev, "HSS is %d\n", mode->hsync_start);\r\ndev_dbg(dev->dev, "HSE is %d\n", mode->hsync_end);\r\ndev_dbg(dev->dev, "htotal is %d\n", mode->htotal);\r\ndev_dbg(dev->dev, "VSS is %d\n", mode->vsync_start);\r\ndev_dbg(dev->dev, "VSE is %d\n", mode->vsync_end);\r\ndev_dbg(dev->dev, "vtotal is %d\n", mode->vtotal);\r\ndev_dbg(dev->dev, "clock is %d\n", mode->clock);\r\n} else {\r\nmode->hdisplay = 864;\r\nmode->vdisplay = 480;\r\nmode->hsync_start = 872;\r\nmode->hsync_end = 876;\r\nmode->htotal = 884;\r\nmode->vsync_start = 482;\r\nmode->vsync_end = 494;\r\nmode->vtotal = 486;\r\nmode->clock = 25777;\r\n}\r\ndrm_mode_set_name(mode);\r\ndrm_mode_set_crtcinfo(mode, 0);\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\nreturn mode;\r\n}\r\nstatic bool mdfld_dsi_dbi_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_display_mode *fixed_mode = tpo_cmd_get_config_mode(dev);\r\nif (fixed_mode) {\r\nadjusted_mode->hdisplay = fixed_mode->hdisplay;\r\nadjusted_mode->hsync_start = fixed_mode->hsync_start;\r\nadjusted_mode->hsync_end = fixed_mode->hsync_end;\r\nadjusted_mode->htotal = fixed_mode->htotal;\r\nadjusted_mode->vdisplay = fixed_mode->vdisplay;\r\nadjusted_mode->vsync_start = fixed_mode->vsync_start;\r\nadjusted_mode->vsync_end = fixed_mode->vsync_end;\r\nadjusted_mode->vtotal = fixed_mode->vtotal;\r\nadjusted_mode->clock = fixed_mode->clock;\r\ndrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\r\nkfree(fixed_mode);\r\n}\r\nreturn true;\r\n}\r\nstatic void mdfld_dsi_dbi_set_power(struct drm_encoder *encoder, bool on)\r\n{\r\nint ret = 0;\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct mdfld_dsi_pkg_sender *sender =\r\nmdfld_dsi_encoder_get_pkg_sender(dsi_encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 reg_offset = 0;\r\nint pipe = (dbi_output->channel_num == 0) ? 0 : 2;\r\nu32 data = 0;\r\ndev_dbg(dev->dev, "pipe %d : %s, panel on: %s\n",\r\npipe, on ? "On" : "Off",\r\ndbi_output->dbi_panel_on ? "True" : "False");\r\nif (pipe == 2) {\r\nif (on)\r\ndev_priv->dual_mipi = true;\r\nelse\r\ndev_priv->dual_mipi = false;\r\nreg_offset = MIPIC_REG_OFFSET;\r\n} else {\r\nif (!on)\r\ndev_priv->dual_mipi = false;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nif (on) {\r\nif (dbi_output->dbi_panel_on)\r\ngoto out_err;\r\nret = mdfld_dsi_dbi_update_power(dbi_output, DRM_MODE_DPMS_ON);\r\nif (ret) {\r\ndev_err(dev->dev, "power on error\n");\r\ngoto out_err;\r\n}\r\ndbi_output->dbi_panel_on = true;\r\nif (pipe == 2)\r\ndev_priv->dbi_panel_on2 = true;\r\nelse\r\ndev_priv->dbi_panel_on = true;\r\nmdfld_enable_te(dev, pipe);\r\n} else {\r\nif (!dbi_output->dbi_panel_on && !dbi_output->first_boot)\r\ngoto out_err;\r\ndbi_output->dbi_panel_on = false;\r\ndbi_output->first_boot = false;\r\nif (pipe == 2)\r\ndev_priv->dbi_panel_on2 = false;\r\nelse\r\ndev_priv->dbi_panel_on = false;\r\nmdfld_disable_te(dev, pipe);\r\nret = mdfld_dsi_dbi_update_power(dbi_output, DRM_MODE_DPMS_OFF);\r\nif (ret) {\r\ndev_err(dev->dev, "power on error\n");\r\ngoto out_err;\r\n}\r\n}\r\nmdfld_dsi_get_power_mode(dsi_config,\r\n&data,\r\nMDFLD_DSI_HS_TRANSMISSION);\r\nif (on && data && !(data & (1 << 7))) {\r\nmdfld_dsi_send_dcs(sender,\r\nDCS_SOFT_RESET,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_PIPE,\r\nMDFLD_DSI_SEND_PACKAGE);\r\nif (dbi_output->p_funcs->drv_ic_init)\r\ndbi_output->p_funcs->drv_ic_init(dsi_config,\r\npipe);\r\n}\r\nout_err:\r\ngma_power_end(dev);\r\nif (ret)\r\ndev_err(dev->dev, "failed\n");\r\n}\r\nstatic void mdfld_dsi_dbi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nint ret = 0;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dsi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct mdfld_dsi_connector *dsi_connector = dsi_config->connector;\r\nint pipe = dsi_connector->pipe;\r\nu8 param = 0;\r\nu32 mipi_reg = MIPI;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 reg_offset = 0;\r\nu32 dspcntr_val = dev_priv->dspcntr;\r\nu32 pipeconf_val = dev_priv->pipeconf;\r\nu32 h_active_area = mode->hdisplay;\r\nu32 v_active_area = mode->vdisplay;\r\nu32 mipi_val;\r\nmipi_val = (PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX |\r\nTE_TRIGGER_GPIO_PIN);\r\ndev_dbg(dev->dev, "mipi_val =0x%x\n", mipi_val);\r\ndev_dbg(dev->dev, "type %s\n", (pipe == 2) ? "MIPI2" : "MIPI");\r\ndev_dbg(dev->dev, "h %d v %d\n", mode->hdisplay, mode->vdisplay);\r\nif (pipe == 2) {\r\nmipi_reg = MIPI_C;\r\ndspcntr_reg = DSPCCNTR;\r\npipeconf_reg = PIPECCONF;\r\nreg_offset = MIPIC_REG_OFFSET;\r\ndspcntr_val = dev_priv->dspcntr2;\r\npipeconf_val = dev_priv->pipeconf2;\r\n} else {\r\nmipi_val |= 0x2;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nREG_WRITE(dspcntr_reg, dspcntr_val);\r\nREG_READ(dspcntr_reg);\r\nmsleep(20);\r\nret = mdfld_dsi_dbi_send_dcs(dsi_output, DCS_EXIT_SLEEP_MODE,\r\nNULL, 0, CMD_DATA_SRC_SYSTEM_MEM);\r\nif (ret) {\r\ndev_err(dev->dev, "sent exit_sleep_mode faild\n");\r\ngoto out_err;\r\n}\r\nret = mdfld_dsi_dbi_send_dcs(dsi_output, DCS_SET_TEAR_ON,\r\n&param, 1, CMD_DATA_SRC_SYSTEM_MEM);\r\nif (ret) {\r\ndev_err(dev->dev, "%s - sent set_tear_on faild\n", __func__);\r\ngoto out_err;\r\n}\r\nREG_WRITE(pipeconf_reg, pipeconf_val | PIPEACONF_DSR);\r\nREG_READ(pipeconf_reg);\r\nif (pipe == 2)\r\ndev_priv->pipeconf2 |= PIPEACONF_DSR;\r\nelse\r\ndev_priv->pipeconf |= PIPEACONF_DSR;\r\ndev_dbg(dev->dev, "pipeconf %x\n", REG_READ(pipeconf_reg));\r\nret = mdfld_dsi_dbi_update_area(dsi_output, 0, 0,\r\nh_active_area - 1, v_active_area - 1);\r\nif (ret) {\r\ndev_err(dev->dev, "update area failed\n");\r\ngoto out_err;\r\n}\r\nout_err:\r\ngma_power_end(dev);\r\nif (ret)\r\ndev_err(dev->dev, "mode set failed\n");\r\n}\r\nstatic void mdfld_dsi_dbi_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output\r\n= MDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\ndbi_output->mode_flags |= MODE_SETTING_IN_ENCODER;\r\ndbi_output->mode_flags &= ~MODE_SETTING_ENCODER_DONE;\r\nmdfld_dsi_dbi_set_power(encoder, false);\r\n}\r\nstatic void mdfld_dsi_dbi_commit(struct drm_encoder *encoder)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output =\r\nMDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_drm_dpu_rect rect;\r\nmdfld_dsi_dbi_set_power(encoder, true);\r\ndbi_output->mode_flags &= ~MODE_SETTING_IN_ENCODER;\r\nrect.x = rect.y = 0;\r\nrect.width = 864;\r\nrect.height = 480;\r\nif (dbi_output->channel_num == 1) {\r\ndev_priv->dsr_fb_update |= MDFLD_DSR_2D_3D_2;\r\nmdfld_dbi_dpu_report_damage(dev, MDFLD_PLANEC, &rect);\r\n} else {\r\ndev_priv->dsr_fb_update |= MDFLD_DSR_2D_3D_0;\r\nmdfld_dbi_dpu_report_damage(dev, MDFLD_PLANEA, &rect);\r\n}\r\ndbi_output->mode_flags |= MODE_SETTING_ENCODER_DONE;\r\n}\r\nstatic void mdfld_dsi_dbi_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dbi_output *dbi_output\r\n= MDFLD_DSI_DBI_OUTPUT(dsi_encoder);\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstatic bool bdispoff;\r\ndev_dbg(dev->dev, "%s\n", (mode == DRM_MODE_DPMS_ON ? "on" : "off"));\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nif (bdispoff ) {\r\nmdfld_dsi_dbi_exit_dsr(dev, MDFLD_DSR_2D_3D);\r\nbdispoff = false;\r\ndev_priv->dispstatus = true;\r\n}\r\nmdfld_dsi_dbi_set_power(encoder, true);\r\n} else {\r\nbdispoff = true;\r\ndev_priv->dispstatus = false;\r\nmdfld_dsi_dbi_set_power(encoder, false);\r\n}\r\n}\r\nstatic void mdfld_dsi_dbi_update_fb(struct mdfld_dsi_dbi_output *dbi_output,\r\nint pipe)\r\n{\r\nstruct mdfld_dsi_pkg_sender *sender =\r\nmdfld_dsi_encoder_get_pkg_sender(&dbi_output->base);\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_crtc *crtc = dbi_output->base.base.crtc;\r\nstruct psb_intel_crtc *psb_crtc = (crtc) ?\r\nto_psb_intel_crtc(crtc) : NULL;\r\nu32 dpll_reg = MRST_DPLL_A;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dsplinoff_reg = DSPALINOFF;\r\nu32 dspsurf_reg = DSPASURF;\r\nu32 reg_offset = 0;\r\nif ((dbi_output->mode_flags & MODE_SETTING_ON_GOING) ||\r\n(psb_crtc && psb_crtc->mode_flags & MODE_SETTING_ON_GOING) ||\r\n!(dbi_output->mode_flags & MODE_SETTING_ENCODER_DONE))\r\nreturn;\r\nif (pipe == 2) {\r\ndspcntr_reg = DSPCCNTR;\r\npipeconf_reg = PIPECCONF;\r\ndsplinoff_reg = DSPCLINOFF;\r\ndspsurf_reg = DSPCSURF;\r\nreg_offset = MIPIC_REG_OFFSET;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nif (!(REG_READ(dpll_reg) & DPLL_VCO_ENABLE) ||\r\n!(REG_READ(dspcntr_reg) & DISPLAY_PLANE_ENABLE) ||\r\n!(REG_READ(pipeconf_reg) & DISPLAY_PLANE_ENABLE))\r\ngoto update_fb_out0;\r\nREG_WRITE(dsplinoff_reg, REG_READ(dsplinoff_reg));\r\nREG_WRITE(dspsurf_reg, REG_READ(dspsurf_reg));\r\nREG_READ(dspsurf_reg);\r\nmdfld_dsi_send_dcs(sender,\r\nDCS_WRITE_MEM_START,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_PIPE,\r\nMDFLD_DSI_SEND_PACKAGE);\r\ndbi_output->dsr_fb_update_done = true;\r\nupdate_fb_out0:\r\ngma_power_end(dev);\r\n}\r\nstatic int tpo_cmd_get_panel_info(struct drm_device *dev,\r\nint pipe,\r\nstruct panel_info *pi)\r\n{\r\nif (!dev || !pi)\r\nreturn -EINVAL;\r\npi->width_mm = TPO_PANEL_WIDTH;\r\npi->height_mm = TPO_PANEL_HEIGHT;\r\nreturn 0;\r\n}\r\nvoid tpo_cmd_init(struct drm_device *dev, struct panel_funcs *p_funcs)\r\n{\r\np_funcs->encoder_funcs = &mdfld_dsi_dbi_encoder_funcs;\r\np_funcs->encoder_helper_funcs = &mdfld_dsi_dbi_helper_funcs;\r\np_funcs->get_config_mode = &tpo_cmd_get_config_mode;\r\np_funcs->update_fb = mdfld_dsi_dbi_update_fb;\r\np_funcs->get_panel_info = tpo_cmd_get_panel_info;\r\np_funcs->reset = mdfld_dsi_panel_reset;\r\np_funcs->drv_ic_init = mdfld_dsi_brightness_init;\r\n}
