static u16 dib3000mc_read_word(struct dib3000mc_state *state, u16 reg)\r\n{\r\nu8 wb[2] = { (reg >> 8) | 0x80, reg & 0xff };\r\nu8 rb[2];\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = state->i2c_addr >> 1, .flags = 0, .buf = wb, .len = 2 },\r\n{ .addr = state->i2c_addr >> 1, .flags = I2C_M_RD, .buf = rb, .len = 2 },\r\n};\r\nif (i2c_transfer(state->i2c_adap, msg, 2) != 2)\r\ndprintk("i2c read error on %d\n",reg);\r\nreturn (rb[0] << 8) | rb[1];\r\n}\r\nstatic int dib3000mc_write_word(struct dib3000mc_state *state, u16 reg, u16 val)\r\n{\r\nu8 b[4] = {\r\n(reg >> 8) & 0xff, reg & 0xff,\r\n(val >> 8) & 0xff, val & 0xff,\r\n};\r\nstruct i2c_msg msg = {\r\n.addr = state->i2c_addr >> 1, .flags = 0, .buf = b, .len = 4\r\n};\r\nreturn i2c_transfer(state->i2c_adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\r\n}\r\nstatic int dib3000mc_identify(struct dib3000mc_state *state)\r\n{\r\nu16 value;\r\nif ((value = dib3000mc_read_word(state, 1025)) != 0x01b3) {\r\ndprintk("-E- DiB3000MC/P: wrong Vendor ID (read=0x%x)\n",value);\r\nreturn -EREMOTEIO;\r\n}\r\nvalue = dib3000mc_read_word(state, 1026);\r\nif (value != 0x3001 && value != 0x3002) {\r\ndprintk("-E- DiB3000MC/P: wrong Device ID (%x)\n",value);\r\nreturn -EREMOTEIO;\r\n}\r\nstate->dev_id = value;\r\ndprintk("-I- found DiB3000MC/P: %x\n",state->dev_id);\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_set_timing(struct dib3000mc_state *state, s16 nfft, u32 bw, u8 update_offset)\r\n{\r\nu32 timf;\r\nif (state->timf == 0) {\r\ntimf = 1384402;\r\nif (update_offset)\r\nmsleep(200);\r\n} else\r\ntimf = state->timf;\r\ntimf *= (bw / 1000);\r\nif (update_offset) {\r\ns16 tim_offs = dib3000mc_read_word(state, 416);\r\nif (tim_offs & 0x2000)\r\ntim_offs -= 0x4000;\r\nif (nfft == TRANSMISSION_MODE_2K)\r\ntim_offs *= 4;\r\ntimf += tim_offs;\r\nstate->timf = timf / (bw / 1000);\r\n}\r\ndprintk("timf: %d\n", timf);\r\ndib3000mc_write_word(state, 23, (u16) (timf >> 16));\r\ndib3000mc_write_word(state, 24, (u16) (timf ) & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_setup_pwm_state(struct dib3000mc_state *state)\r\n{\r\nu16 reg_51, reg_52 = state->cfg->agc->setup & 0xfefb;\r\nif (state->cfg->pwm3_inversion) {\r\nreg_51 = (2 << 14) | (0 << 10) | (7 << 6) | (2 << 2) | (2 << 0);\r\nreg_52 |= (1 << 2);\r\n} else {\r\nreg_51 = (2 << 14) | (4 << 10) | (7 << 6) | (2 << 2) | (2 << 0);\r\nreg_52 |= (1 << 8);\r\n}\r\ndib3000mc_write_word(state, 51, reg_51);\r\ndib3000mc_write_word(state, 52, reg_52);\r\nif (state->cfg->use_pwm3)\r\ndib3000mc_write_word(state, 245, (1 << 3) | (1 << 0));\r\nelse\r\ndib3000mc_write_word(state, 245, 0);\r\ndib3000mc_write_word(state, 1040, 0x3);\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_set_output_mode(struct dib3000mc_state *state, int mode)\r\n{\r\nint ret = 0;\r\nu16 fifo_threshold = 1792;\r\nu16 outreg = 0;\r\nu16 outmode = 0;\r\nu16 elecout = 1;\r\nu16 smo_reg = dib3000mc_read_word(state, 206) & 0x0010;\r\ndprintk("-I- Setting output mode for demod %p to %d\n",\r\n&state->demod, mode);\r\nswitch (mode) {\r\ncase OUTMODE_HIGH_Z:\r\nelecout = 0;\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\noutmode = 0;\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\noutmode = 1;\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\noutmode = 2;\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\nelecout = 3;\r\nsmo_reg |= 3 << 1;\r\nfifo_threshold = 512;\r\noutmode = 5;\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\noutmode = 4;\r\nelecout = 1;\r\nbreak;\r\ndefault:\r\ndprintk("Unhandled output_mode passed to be set for demod %p\n",&state->demod);\r\noutmode = 0;\r\nbreak;\r\n}\r\nif ((state->cfg->output_mpeg2_in_188_bytes))\r\nsmo_reg |= (1 << 5);\r\noutreg = dib3000mc_read_word(state, 244) & 0x07FF;\r\noutreg |= (outmode << 11);\r\nret |= dib3000mc_write_word(state, 244, outreg);\r\nret |= dib3000mc_write_word(state, 206, smo_reg);\r\nret |= dib3000mc_write_word(state, 207, fifo_threshold);\r\nret |= dib3000mc_write_word(state, 1040, elecout);\r\nreturn ret;\r\n}\r\nstatic int dib3000mc_set_bandwidth(struct dib3000mc_state *state, u32 bw)\r\n{\r\nu16 bw_cfg[6] = { 0 };\r\nu16 imp_bw_cfg[3] = { 0 };\r\nu16 reg;\r\nswitch (bw) {\r\ncase 8000:\r\nbw_cfg[0] = 0x0019; bw_cfg[1] = 0x5c30; bw_cfg[2] = 0x0054; bw_cfg[3] = 0x88a0; bw_cfg[4] = 0x01a6; bw_cfg[5] = 0xab20;\r\nimp_bw_cfg[0] = 0x04db; imp_bw_cfg[1] = 0x00db; imp_bw_cfg[2] = 0x00b7;\r\nbreak;\r\ncase 7000:\r\nbw_cfg[0] = 0x001c; bw_cfg[1] = 0xfba5; bw_cfg[2] = 0x0060; bw_cfg[3] = 0x9c25; bw_cfg[4] = 0x01e3; bw_cfg[5] = 0x0cb7;\r\nimp_bw_cfg[0] = 0x04c0; imp_bw_cfg[1] = 0x00c0; imp_bw_cfg[2] = 0x00a0;\r\nbreak;\r\ncase 6000:\r\nbw_cfg[0] = 0x0021; bw_cfg[1] = 0xd040; bw_cfg[2] = 0x0070; bw_cfg[3] = 0xb62b; bw_cfg[4] = 0x0233; bw_cfg[5] = 0x8ed5;\r\nimp_bw_cfg[0] = 0x04a5; imp_bw_cfg[1] = 0x00a5; imp_bw_cfg[2] = 0x0089;\r\nbreak;\r\ncase 5000:\r\nbw_cfg[0] = 0x0028; bw_cfg[1] = 0x9380; bw_cfg[2] = 0x0087; bw_cfg[3] = 0x4100; bw_cfg[4] = 0x02a4; bw_cfg[5] = 0x4500;\r\nimp_bw_cfg[0] = 0x0489; imp_bw_cfg[1] = 0x0089; imp_bw_cfg[2] = 0x0072;\r\nbreak;\r\ndefault: return -EINVAL;\r\n}\r\nfor (reg = 6; reg < 12; reg++)\r\ndib3000mc_write_word(state, reg, bw_cfg[reg - 6]);\r\ndib3000mc_write_word(state, 12, 0x0000);\r\ndib3000mc_write_word(state, 13, 0x03e8);\r\ndib3000mc_write_word(state, 14, 0x0000);\r\ndib3000mc_write_word(state, 15, 0x03f2);\r\ndib3000mc_write_word(state, 16, 0x0001);\r\ndib3000mc_write_word(state, 17, 0xb0d0);\r\ndib3000mc_write_word(state, 18, 0x0393);\r\ndib3000mc_write_word(state, 19, 0x8700);\r\nfor (reg = 55; reg < 58; reg++)\r\ndib3000mc_write_word(state, reg, imp_bw_cfg[reg - 55]);\r\ndib3000mc_set_timing(state, TRANSMISSION_MODE_2K, bw, 0);\r\nreturn 0;\r\n}\r\nstatic void dib3000mc_set_impulse_noise(struct dib3000mc_state *state, u8 mode, s16 nfft)\r\n{\r\nu16 i;\r\nfor (i = 58; i < 87; i++)\r\ndib3000mc_write_word(state, i, impulse_noise_val[i-58]);\r\nif (nfft == TRANSMISSION_MODE_8K) {\r\ndib3000mc_write_word(state, 58, 0x3b);\r\ndib3000mc_write_word(state, 84, 0x00);\r\ndib3000mc_write_word(state, 85, 0x8200);\r\n}\r\ndib3000mc_write_word(state, 34, 0x1294);\r\ndib3000mc_write_word(state, 35, 0x1ff8);\r\nif (mode == 1)\r\ndib3000mc_write_word(state, 55, dib3000mc_read_word(state, 55) | (1 << 10));\r\n}\r\nstatic int dib3000mc_init(struct dvb_frontend *demod)\r\n{\r\nstruct dib3000mc_state *state = demod->demodulator_priv;\r\nstruct dibx000_agc_config *agc = state->cfg->agc;\r\ndib3000mc_write_word(state, 1027, 0x8000);\r\ndib3000mc_write_word(state, 1027, 0x0000);\r\ndib3000mc_write_word(state, 140, 0x0000);\r\ndib3000mc_write_word(state, 1031, 0);\r\nif (state->cfg->mobile_mode) {\r\ndib3000mc_write_word(state, 139, 0x0000);\r\ndib3000mc_write_word(state, 141, 0x0000);\r\ndib3000mc_write_word(state, 175, 0x0002);\r\ndib3000mc_write_word(state, 1032, 0x0000);\r\n} else {\r\ndib3000mc_write_word(state, 139, 0x0001);\r\ndib3000mc_write_word(state, 141, 0x0000);\r\ndib3000mc_write_word(state, 175, 0x0000);\r\ndib3000mc_write_word(state, 1032, 0x012C);\r\n}\r\ndib3000mc_write_word(state, 1033, 0x0000);\r\ndib3000mc_write_word(state, 1037, 0x3130);\r\ndib3000mc_write_word(state, 33, (5 << 0));\r\ndib3000mc_write_word(state, 88, (1 << 10) | (0x10 << 0));\r\ndib3000mc_write_word(state, 99, (1 << 9) | (0x20 << 0));\r\nif (state->cfg->phase_noise_mode == 0)\r\ndib3000mc_write_word(state, 111, 0x00);\r\nelse\r\ndib3000mc_write_word(state, 111, 0x02);\r\ndib3000mc_write_word(state, 50, 0x8000);\r\ndib3000mc_setup_pwm_state(state);\r\ndib3000mc_write_word(state, 53, 0x87);\r\ndib3000mc_write_word(state, 54, 0x87);\r\ndib3000mc_write_word(state, 36, state->cfg->max_time);\r\ndib3000mc_write_word(state, 37, (state->cfg->agc_command1 << 13) | (state->cfg->agc_command2 << 12) | (0x1d << 0));\r\ndib3000mc_write_word(state, 38, state->cfg->pwm3_value);\r\ndib3000mc_write_word(state, 39, state->cfg->ln_adc_level);\r\ndib3000mc_write_word(state, 40, 0x0179);\r\ndib3000mc_write_word(state, 41, 0x03f0);\r\ndib3000mc_write_word(state, 42, agc->agc1_max);\r\ndib3000mc_write_word(state, 43, agc->agc1_min);\r\ndib3000mc_write_word(state, 44, agc->agc2_max);\r\ndib3000mc_write_word(state, 45, agc->agc2_min);\r\ndib3000mc_write_word(state, 46, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\r\ndib3000mc_write_word(state, 47, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\r\ndib3000mc_write_word(state, 48, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\r\ndib3000mc_write_word(state, 49, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\r\ndib3000mc_write_word(state, 110, 3277);\r\ndib3000mc_write_word(state, 26, 0x6680);\r\ndib3000mc_write_word(state, 1, 4);\r\ndib3000mc_write_word(state, 2, 4);\r\ndib3000mc_write_word(state, 3, 0x1000);\r\ndib3000mc_write_word(state, 5, 1);\r\ndib3000mc_set_bandwidth(state, 8000);\r\ndib3000mc_write_word(state, 4, 0x814);\r\ndib3000mc_write_word(state, 21, (1 << 9) | 0x164);\r\ndib3000mc_write_word(state, 22, 0x463d);\r\ndib3000mc_write_word(state, 120, 0x200f);\r\ndib3000mc_write_word(state, 134, 0);\r\ndib3000mc_write_word(state, 195, 0x10);\r\ndib3000mc_write_word(state, 180, 0x2FF0);\r\ndib3000mc_set_impulse_noise(state, 0, TRANSMISSION_MODE_8K);\r\ndib3000mc_set_output_mode(state, OUTMODE_HIGH_Z);\r\ndib3000mc_write_word(state, 769, (1 << 7) );\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_sleep(struct dvb_frontend *demod)\r\n{\r\nstruct dib3000mc_state *state = demod->demodulator_priv;\r\ndib3000mc_write_word(state, 1031, 0xFFFF);\r\ndib3000mc_write_word(state, 1032, 0xFFFF);\r\ndib3000mc_write_word(state, 1033, 0xFFF0);\r\nreturn 0;\r\n}\r\nstatic void dib3000mc_set_adp_cfg(struct dib3000mc_state *state, s16 qam)\r\n{\r\nu16 cfg[4] = { 0 },reg;\r\nswitch (qam) {\r\ncase QPSK:\r\ncfg[0] = 0x099a; cfg[1] = 0x7fae; cfg[2] = 0x0333; cfg[3] = 0x7ff0;\r\nbreak;\r\ncase QAM_16:\r\ncfg[0] = 0x023d; cfg[1] = 0x7fdf; cfg[2] = 0x00a4; cfg[3] = 0x7ff0;\r\nbreak;\r\ncase QAM_64:\r\ncfg[0] = 0x0148; cfg[1] = 0x7ff0; cfg[2] = 0x00a4; cfg[3] = 0x7ff8;\r\nbreak;\r\n}\r\nfor (reg = 129; reg < 133; reg++)\r\ndib3000mc_write_word(state, reg, cfg[reg - 129]);\r\n}\r\nstatic void dib3000mc_set_channel_cfg(struct dib3000mc_state *state, struct dvb_frontend_parameters *ch, u16 seq)\r\n{\r\nu16 value;\r\ndib3000mc_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->u.ofdm.bandwidth));\r\ndib3000mc_set_timing(state, ch->u.ofdm.transmission_mode, BANDWIDTH_TO_KHZ(ch->u.ofdm.bandwidth), 0);\r\ndib3000mc_write_word(state, 100, (16 << 6) + 9);\r\ndib3000mc_write_word(state, 1027, 0x0800);\r\ndib3000mc_write_word(state, 1027, 0x0000);\r\ndib3000mc_write_word(state, 26, 0x6680);\r\ndib3000mc_write_word(state, 29, 0x1273);\r\ndib3000mc_write_word(state, 33, 5);\r\ndib3000mc_set_adp_cfg(state, QAM_16);\r\ndib3000mc_write_word(state, 133, 15564);\r\ndib3000mc_write_word(state, 12 , 0x0);\r\ndib3000mc_write_word(state, 13 , 0x3e8);\r\ndib3000mc_write_word(state, 14 , 0x0);\r\ndib3000mc_write_word(state, 15 , 0x3f2);\r\ndib3000mc_write_word(state, 93,0);\r\ndib3000mc_write_word(state, 94,0);\r\ndib3000mc_write_word(state, 95,0);\r\ndib3000mc_write_word(state, 96,0);\r\ndib3000mc_write_word(state, 97,0);\r\ndib3000mc_write_word(state, 98,0);\r\ndib3000mc_set_impulse_noise(state, 0, ch->u.ofdm.transmission_mode);\r\nvalue = 0;\r\nswitch (ch->u.ofdm.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K: value |= (0 << 7); break;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K: value |= (1 << 7); break;\r\n}\r\nswitch (ch->u.ofdm.guard_interval) {\r\ncase GUARD_INTERVAL_1_32: value |= (0 << 5); break;\r\ncase GUARD_INTERVAL_1_16: value |= (1 << 5); break;\r\ncase GUARD_INTERVAL_1_4: value |= (3 << 5); break;\r\ndefault:\r\ncase GUARD_INTERVAL_1_8: value |= (2 << 5); break;\r\n}\r\nswitch (ch->u.ofdm.constellation) {\r\ncase QPSK: value |= (0 << 3); break;\r\ncase QAM_16: value |= (1 << 3); break;\r\ndefault:\r\ncase QAM_64: value |= (2 << 3); break;\r\n}\r\nswitch (HIERARCHY_1) {\r\ncase HIERARCHY_2: value |= 2; break;\r\ncase HIERARCHY_4: value |= 4; break;\r\ndefault:\r\ncase HIERARCHY_1: value |= 1; break;\r\n}\r\ndib3000mc_write_word(state, 0, value);\r\ndib3000mc_write_word(state, 5, (1 << 8) | ((seq & 0xf) << 4));\r\nvalue = 0;\r\nif (ch->u.ofdm.hierarchy_information == 1)\r\nvalue |= (1 << 4);\r\nif (1 == 1)\r\nvalue |= 1;\r\nswitch ((ch->u.ofdm.hierarchy_information == 0 || 1 == 1) ? ch->u.ofdm.code_rate_HP : ch->u.ofdm.code_rate_LP) {\r\ncase FEC_2_3: value |= (2 << 1); break;\r\ncase FEC_3_4: value |= (3 << 1); break;\r\ncase FEC_5_6: value |= (5 << 1); break;\r\ncase FEC_7_8: value |= (7 << 1); break;\r\ndefault:\r\ncase FEC_1_2: value |= (1 << 1); break;\r\n}\r\ndib3000mc_write_word(state, 181, value);\r\nswitch (ch->u.ofdm.transmission_mode) {\r\ncase TRANSMISSION_MODE_8K: value = 256; break;\r\ncase TRANSMISSION_MODE_2K:\r\ndefault: value = 64; break;\r\n}\r\nswitch (ch->u.ofdm.guard_interval) {\r\ncase GUARD_INTERVAL_1_16: value *= 2; break;\r\ncase GUARD_INTERVAL_1_8: value *= 4; break;\r\ncase GUARD_INTERVAL_1_4: value *= 8; break;\r\ndefault:\r\ncase GUARD_INTERVAL_1_32: value *= 1; break;\r\n}\r\nvalue <<= 4;\r\nvalue |= dib3000mc_read_word(state, 180) & 0x000f;\r\ndib3000mc_write_word(state, 180, value);\r\nvalue = dib3000mc_read_word(state, 0);\r\ndib3000mc_write_word(state, 0, value | (1 << 9));\r\ndib3000mc_write_word(state, 0, value);\r\nmsleep(30);\r\ndib3000mc_set_impulse_noise(state, state->cfg->impulse_noise_mode, ch->u.ofdm.transmission_mode);\r\n}\r\nstatic int dib3000mc_autosearch_start(struct dvb_frontend *demod, struct dvb_frontend_parameters *chan)\r\n{\r\nstruct dib3000mc_state *state = demod->demodulator_priv;\r\nu16 reg;\r\nstruct dvb_frontend_parameters schan;\r\nschan = *chan;\r\nschan.u.ofdm.transmission_mode = TRANSMISSION_MODE_8K;\r\nschan.u.ofdm.guard_interval = GUARD_INTERVAL_1_32;\r\nschan.u.ofdm.constellation = QAM_64;\r\nschan.u.ofdm.code_rate_HP = FEC_2_3;\r\nschan.u.ofdm.code_rate_LP = FEC_2_3;\r\nschan.u.ofdm.hierarchy_information = 0;\r\ndib3000mc_set_channel_cfg(state, &schan, 11);\r\nreg = dib3000mc_read_word(state, 0);\r\ndib3000mc_write_word(state, 0, reg | (1 << 8));\r\ndib3000mc_read_word(state, 511);\r\ndib3000mc_write_word(state, 0, reg);\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_autosearch_is_irq(struct dvb_frontend *demod)\r\n{\r\nstruct dib3000mc_state *state = demod->demodulator_priv;\r\nu16 irq_pending = dib3000mc_read_word(state, 511);\r\nif (irq_pending & 0x1)\r\nreturn 1;\r\nif (irq_pending & 0x2)\r\nreturn 2;\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_tune(struct dvb_frontend *demod, struct dvb_frontend_parameters *ch)\r\n{\r\nstruct dib3000mc_state *state = demod->demodulator_priv;\r\ndib3000mc_set_channel_cfg(state, ch, 0);\r\nif (state->sfn_workaround_active) {\r\ndprintk("SFN workaround is active\n");\r\ndib3000mc_write_word(state, 29, 0x1273);\r\ndib3000mc_write_word(state, 108, 0x4000);\r\n} else {\r\ndib3000mc_write_word(state, 29, 0x1073);\r\ndib3000mc_write_word(state, 108, 0x0000);\r\n}\r\ndib3000mc_set_adp_cfg(state, (u8)ch->u.ofdm.constellation);\r\nif (ch->u.ofdm.transmission_mode == TRANSMISSION_MODE_8K) {\r\ndib3000mc_write_word(state, 26, 38528);\r\ndib3000mc_write_word(state, 33, 8);\r\n} else {\r\ndib3000mc_write_word(state, 26, 30336);\r\ndib3000mc_write_word(state, 33, 6);\r\n}\r\nif (dib3000mc_read_word(state, 509) & 0x80)\r\ndib3000mc_set_timing(state, ch->u.ofdm.transmission_mode, BANDWIDTH_TO_KHZ(ch->u.ofdm.bandwidth), 1);\r\nreturn 0;\r\n}\r\nstruct i2c_adapter * dib3000mc_get_tuner_i2c_master(struct dvb_frontend *demod, int gating)\r\n{\r\nstruct dib3000mc_state *st = demod->demodulator_priv;\r\nreturn dibx000_get_i2c_adapter(&st->i2c_master, DIBX000_I2C_INTERFACE_TUNER, gating);\r\n}\r\nstatic int dib3000mc_get_frontend(struct dvb_frontend* fe,\r\nstruct dvb_frontend_parameters *fep)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\nu16 tps = dib3000mc_read_word(state,458);\r\nfep->inversion = INVERSION_AUTO;\r\nfep->u.ofdm.bandwidth = state->current_bandwidth;\r\nswitch ((tps >> 8) & 0x1) {\r\ncase 0: fep->u.ofdm.transmission_mode = TRANSMISSION_MODE_2K; break;\r\ncase 1: fep->u.ofdm.transmission_mode = TRANSMISSION_MODE_8K; break;\r\n}\r\nswitch (tps & 0x3) {\r\ncase 0: fep->u.ofdm.guard_interval = GUARD_INTERVAL_1_32; break;\r\ncase 1: fep->u.ofdm.guard_interval = GUARD_INTERVAL_1_16; break;\r\ncase 2: fep->u.ofdm.guard_interval = GUARD_INTERVAL_1_8; break;\r\ncase 3: fep->u.ofdm.guard_interval = GUARD_INTERVAL_1_4; break;\r\n}\r\nswitch ((tps >> 13) & 0x3) {\r\ncase 0: fep->u.ofdm.constellation = QPSK; break;\r\ncase 1: fep->u.ofdm.constellation = QAM_16; break;\r\ncase 2:\r\ndefault: fep->u.ofdm.constellation = QAM_64; break;\r\n}\r\nfep->u.ofdm.hierarchy_information = HIERARCHY_NONE;\r\nswitch ((tps >> 5) & 0x7) {\r\ncase 1: fep->u.ofdm.code_rate_HP = FEC_1_2; break;\r\ncase 2: fep->u.ofdm.code_rate_HP = FEC_2_3; break;\r\ncase 3: fep->u.ofdm.code_rate_HP = FEC_3_4; break;\r\ncase 5: fep->u.ofdm.code_rate_HP = FEC_5_6; break;\r\ncase 7:\r\ndefault: fep->u.ofdm.code_rate_HP = FEC_7_8; break;\r\n}\r\nswitch ((tps >> 2) & 0x7) {\r\ncase 1: fep->u.ofdm.code_rate_LP = FEC_1_2; break;\r\ncase 2: fep->u.ofdm.code_rate_LP = FEC_2_3; break;\r\ncase 3: fep->u.ofdm.code_rate_LP = FEC_3_4; break;\r\ncase 5: fep->u.ofdm.code_rate_LP = FEC_5_6; break;\r\ncase 7:\r\ndefault: fep->u.ofdm.code_rate_LP = FEC_7_8; break;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_set_frontend(struct dvb_frontend* fe,\r\nstruct dvb_frontend_parameters *fep)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\nint ret;\r\ndib3000mc_set_output_mode(state, OUTMODE_HIGH_Z);\r\nstate->current_bandwidth = fep->u.ofdm.bandwidth;\r\ndib3000mc_set_bandwidth(state, BANDWIDTH_TO_KHZ(fep->u.ofdm.bandwidth));\r\nstate->sfn_workaround_active = buggy_sfn_workaround;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe, fep);\r\nmsleep(100);\r\n}\r\nif (fep->u.ofdm.transmission_mode == TRANSMISSION_MODE_AUTO ||\r\nfep->u.ofdm.guard_interval == GUARD_INTERVAL_AUTO ||\r\nfep->u.ofdm.constellation == QAM_AUTO ||\r\nfep->u.ofdm.code_rate_HP == FEC_AUTO) {\r\nint i = 1000, found;\r\ndib3000mc_autosearch_start(fe, fep);\r\ndo {\r\nmsleep(1);\r\nfound = dib3000mc_autosearch_is_irq(fe);\r\n} while (found == 0 && i--);\r\ndprintk("autosearch returns: %d\n",found);\r\nif (found == 0 || found == 1)\r\nreturn 0;\r\ndib3000mc_get_frontend(fe, fep);\r\n}\r\nret = dib3000mc_tune(fe, fep);\r\ndib3000mc_set_output_mode(state, OUTMODE_MPEG2_FIFO);\r\nreturn ret;\r\n}\r\nstatic int dib3000mc_read_status(struct dvb_frontend *fe, fe_status_t *stat)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\nu16 lock = dib3000mc_read_word(state, 509);\r\n*stat = 0;\r\nif (lock & 0x8000)\r\n*stat |= FE_HAS_SIGNAL;\r\nif (lock & 0x3000)\r\n*stat |= FE_HAS_CARRIER;\r\nif (lock & 0x0100)\r\n*stat |= FE_HAS_VITERBI;\r\nif (lock & 0x0010)\r\n*stat |= FE_HAS_SYNC;\r\nif (lock & 0x0008)\r\n*stat |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\n*ber = (dib3000mc_read_word(state, 500) << 16) | dib3000mc_read_word(state, 501);\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_read_unc_blocks(struct dvb_frontend *fe, u32 *unc)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\n*unc = dib3000mc_read_word(state, 508);\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\nu16 val = dib3000mc_read_word(state, 392);\r\n*strength = 65535 - val;\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_read_snr(struct dvb_frontend* fe, u16 *snr)\r\n{\r\n*snr = 0x0000;\r\nreturn 0;\r\n}\r\nstatic int dib3000mc_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void dib3000mc_release(struct dvb_frontend *fe)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\ndibx000_exit_i2c_master(&state->i2c_master);\r\nkfree(state);\r\n}\r\nint dib3000mc_pid_control(struct dvb_frontend *fe, int index, int pid,int onoff)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\ndib3000mc_write_word(state, 212 + index, onoff ? (1 << 13) | pid : 0);\r\nreturn 0;\r\n}\r\nint dib3000mc_pid_parse(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\nu16 tmp = dib3000mc_read_word(state, 206) & ~(1 << 4);\r\ntmp |= (onoff << 4);\r\nreturn dib3000mc_write_word(state, 206, tmp);\r\n}\r\nvoid dib3000mc_set_config(struct dvb_frontend *fe, struct dib3000mc_config *cfg)\r\n{\r\nstruct dib3000mc_state *state = fe->demodulator_priv;\r\nstate->cfg = cfg;\r\n}\r\nint dib3000mc_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods, u8 default_addr, struct dib3000mc_config cfg[])\r\n{\r\nstruct dib3000mc_state *dmcst;\r\nint k;\r\nu8 new_addr;\r\nstatic u8 DIB3000MC_I2C_ADDRESS[] = {20,22,24,26};\r\ndmcst = kzalloc(sizeof(struct dib3000mc_state), GFP_KERNEL);\r\nif (dmcst == NULL)\r\nreturn -ENOMEM;\r\ndmcst->i2c_adap = i2c;\r\nfor (k = no_of_demods-1; k >= 0; k--) {\r\ndmcst->cfg = &cfg[k];\r\nnew_addr = DIB3000MC_I2C_ADDRESS[k];\r\ndmcst->i2c_addr = new_addr;\r\nif (dib3000mc_identify(dmcst) != 0) {\r\ndmcst->i2c_addr = default_addr;\r\nif (dib3000mc_identify(dmcst) != 0) {\r\ndprintk("-E- DiB3000P/MC #%d: not identified\n", k);\r\nkfree(dmcst);\r\nreturn -ENODEV;\r\n}\r\n}\r\ndib3000mc_set_output_mode(dmcst, OUTMODE_MPEG2_PAR_CONT_CLK);\r\ndib3000mc_write_word(dmcst, 1024, (new_addr << 3) | 0x1);\r\ndmcst->i2c_addr = new_addr;\r\n}\r\nfor (k = 0; k < no_of_demods; k++) {\r\ndmcst->cfg = &cfg[k];\r\ndmcst->i2c_addr = DIB3000MC_I2C_ADDRESS[k];\r\ndib3000mc_write_word(dmcst, 1024, dmcst->i2c_addr << 3);\r\ndib3000mc_set_output_mode(dmcst, OUTMODE_HIGH_Z);\r\n}\r\nkfree(dmcst);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend * dib3000mc_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib3000mc_config *cfg)\r\n{\r\nstruct dvb_frontend *demod;\r\nstruct dib3000mc_state *st;\r\nst = kzalloc(sizeof(struct dib3000mc_state), GFP_KERNEL);\r\nif (st == NULL)\r\nreturn NULL;\r\nst->cfg = cfg;\r\nst->i2c_adap = i2c_adap;\r\nst->i2c_addr = i2c_addr;\r\ndemod = &st->demod;\r\ndemod->demodulator_priv = st;\r\nmemcpy(&st->demod.ops, &dib3000mc_ops, sizeof(struct dvb_frontend_ops));\r\nif (dib3000mc_identify(st) != 0)\r\ngoto error;\r\ndibx000_init_i2c_master(&st->i2c_master, DIB3000MC, st->i2c_adap, st->i2c_addr);\r\ndib3000mc_write_word(st, 1037, 0x3130);\r\nreturn demod;\r\nerror:\r\nkfree(st);\r\nreturn NULL;\r\n}
