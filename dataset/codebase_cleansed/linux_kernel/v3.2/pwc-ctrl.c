static int _send_control_msg(struct pwc_device *pdev,\r\nu8 request, u16 value, int index, void *buf, int buflen)\r\n{\r\nint rc;\r\nvoid *kbuf = NULL;\r\nif (buflen) {\r\nkbuf = kmalloc(buflen, GFP_KERNEL);\r\nif (kbuf == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(kbuf, buf, buflen);\r\n}\r\nrc = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),\r\nrequest,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue,\r\nindex,\r\nkbuf, buflen, USB_CTRL_SET_TIMEOUT);\r\nkfree(kbuf);\r\nreturn rc;\r\n}\r\nstatic int recv_control_msg(struct pwc_device *pdev,\r\nu8 request, u16 value, void *buf, int buflen)\r\n{\r\nint rc;\r\nvoid *kbuf = kmalloc(buflen, GFP_KERNEL);\r\nif (kbuf == NULL)\r\nreturn -ENOMEM;\r\nrc = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),\r\nrequest,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue,\r\npdev->vcinterface,\r\nkbuf, buflen, USB_CTRL_GET_TIMEOUT);\r\nmemcpy(buf, kbuf, buflen);\r\nkfree(kbuf);\r\nif (rc < 0)\r\nPWC_ERROR("recv_control_msg error %d req %02x val %04x\n",\r\nrc, request, value);\r\nreturn rc;\r\n}\r\nstatic inline int send_video_command(struct pwc_device *pdev,\r\nint index, void *buf, int buflen)\r\n{\r\nreturn _send_control_msg(pdev,\r\nSET_EP_STREAM_CTL,\r\nVIDEO_OUTPUT_CONTROL_FORMATTER,\r\nindex,\r\nbuf, buflen);\r\n}\r\nint send_control_msg(struct pwc_device *pdev,\r\nu8 request, u16 value, void *buf, int buflen)\r\n{\r\nreturn _send_control_msg(pdev,\r\nrequest, value, pdev->vcinterface, buf, buflen);\r\n}\r\nstatic int set_video_mode_Nala(struct pwc_device *pdev, int size, int frames)\r\n{\r\nunsigned char buf[3];\r\nint ret, fps;\r\nstruct Nala_table_entry *pEntry;\r\nint frames2frames[31] =\r\n{\r\n0, 0, 0, 0, 4,\r\n5, 5, 7, 7, 10,\r\n10, 10, 12, 12, 15,\r\n15, 15, 15, 20, 20,\r\n20, 20, 20, 24, 24,\r\n24, 24, 24, 24, 24,\r\n24\r\n};\r\nint frames2table[31] =\r\n{ 0, 0, 0, 0, 0,\r\n1, 1, 1, 2, 2,\r\n3, 3, 4, 4, 4,\r\n5, 5, 5, 5, 5,\r\n6, 6, 6, 6, 7,\r\n7, 7, 7, 7, 7,\r\n7\r\n};\r\nif (size < 0 || size > PSZ_CIF || frames < 4 || frames > 25)\r\nreturn -EINVAL;\r\nframes = frames2frames[frames];\r\nfps = frames2table[frames];\r\npEntry = &Nala_table[size][fps];\r\nif (pEntry->alternate == 0)\r\nreturn -EINVAL;\r\nmemcpy(buf, pEntry->mode, 3);\r\nret = send_video_command(pdev, pdev->vendpoint, buf, 3);\r\nif (ret < 0) {\r\nPWC_DEBUG_MODULE("Failed to send video command... %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pEntry->compressed && pdev->pixfmt == V4L2_PIX_FMT_YUV420) {\r\nret = pwc_dec1_init(pdev, pdev->type, pdev->release, buf);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npdev->cmd_len = 3;\r\nmemcpy(pdev->cmd_buf, buf, 3);\r\npdev->vframes = frames;\r\npdev->vsize = size;\r\npdev->valternate = pEntry->alternate;\r\npdev->image = pwc_image_sizes[size];\r\npdev->frame_size = (pdev->image.x * pdev->image.y * 3) / 2;\r\nif (pEntry->compressed) {\r\nif (pdev->release < 5) {\r\npdev->vbandlength = 528;\r\npdev->frame_size /= 4;\r\n}\r\nelse {\r\npdev->vbandlength = 704;\r\npdev->frame_size /= 3;\r\n}\r\n}\r\nelse\r\npdev->vbandlength = 0;\r\nreturn 0;\r\n}\r\nstatic int set_video_mode_Timon(struct pwc_device *pdev, int size, int frames, int compression, int snapshot)\r\n{\r\nunsigned char buf[13];\r\nconst struct Timon_table_entry *pChoose;\r\nint ret, fps;\r\nif (size >= PSZ_MAX || frames < 5 || frames > 30 || compression < 0 || compression > 3)\r\nreturn -EINVAL;\r\nif (size == PSZ_VGA && frames > 15)\r\nreturn -EINVAL;\r\nfps = (frames / 5) - 1;\r\npChoose = NULL;\r\nwhile (compression <= 3) {\r\npChoose = &Timon_table[size][fps][compression];\r\nif (pChoose->alternate != 0)\r\nbreak;\r\ncompression++;\r\n}\r\nif (pChoose == NULL || pChoose->alternate == 0)\r\nreturn -ENOENT;\r\nmemcpy(buf, pChoose->mode, 13);\r\nif (snapshot)\r\nbuf[0] |= 0x80;\r\nret = send_video_command(pdev, pdev->vendpoint, buf, 13);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pChoose->bandlength > 0 && pdev->pixfmt == V4L2_PIX_FMT_YUV420) {\r\nret = pwc_dec23_init(pdev, pdev->type, buf);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npdev->cmd_len = 13;\r\nmemcpy(pdev->cmd_buf, buf, 13);\r\npdev->vframes = frames;\r\npdev->vsize = size;\r\npdev->vsnapshot = snapshot;\r\npdev->valternate = pChoose->alternate;\r\npdev->image = pwc_image_sizes[size];\r\npdev->vbandlength = pChoose->bandlength;\r\nif (pChoose->bandlength > 0)\r\npdev->frame_size = (pChoose->bandlength * pdev->image.y) / 4;\r\nelse\r\npdev->frame_size = (pdev->image.x * pdev->image.y * 12) / 8;\r\nreturn 0;\r\n}\r\nstatic int set_video_mode_Kiara(struct pwc_device *pdev, int size, int frames, int compression, int snapshot)\r\n{\r\nconst struct Kiara_table_entry *pChoose = NULL;\r\nint fps, ret;\r\nunsigned char buf[12];\r\nstruct Kiara_table_entry RawEntry = {6, 773, 1272, {0xAD, 0xF4, 0x10, 0x27, 0xB6, 0x24, 0x96, 0x02, 0x30, 0x05, 0x03, 0x80}};\r\nif (size >= PSZ_MAX || frames < 5 || frames > 30 || compression < 0 || compression > 3)\r\nreturn -EINVAL;\r\nif (size == PSZ_VGA && frames > 15)\r\nreturn -EINVAL;\r\nfps = (frames / 5) - 1;\r\nif (size == PSZ_VGA && frames == 5 && snapshot && pdev->pixfmt != V4L2_PIX_FMT_YUV420)\r\n{\r\nPWC_DEBUG_SIZE("Choosing VGA/5 BAYER mode.\n");\r\npChoose = &RawEntry;\r\n}\r\nelse\r\n{\r\nsnapshot = 0;\r\nwhile (compression <= 3) {\r\npChoose = &Kiara_table[size][fps][compression];\r\nif (pChoose->alternate != 0)\r\nbreak;\r\ncompression++;\r\n}\r\n}\r\nif (pChoose == NULL || pChoose->alternate == 0)\r\nreturn -ENOENT;\r\nPWC_TRACE("Using alternate setting %d.\n", pChoose->alternate);\r\nmemcpy(buf, pChoose->mode, 12);\r\nif (snapshot)\r\nbuf[0] |= 0x80;\r\nret = send_video_command(pdev, 4 , buf, 12);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pChoose->bandlength > 0 && pdev->pixfmt == V4L2_PIX_FMT_YUV420) {\r\nret = pwc_dec23_init(pdev, pdev->type, buf);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npdev->cmd_len = 12;\r\nmemcpy(pdev->cmd_buf, buf, 12);\r\npdev->vframes = frames;\r\npdev->vsize = size;\r\npdev->vsnapshot = snapshot;\r\npdev->valternate = pChoose->alternate;\r\npdev->image = pwc_image_sizes[size];\r\npdev->vbandlength = pChoose->bandlength;\r\nif (pdev->vbandlength > 0)\r\npdev->frame_size = (pdev->vbandlength * pdev->image.y) / 4;\r\nelse\r\npdev->frame_size = (pdev->image.x * pdev->image.y * 12) / 8;\r\nPWC_TRACE("frame_size=%d, vframes=%d, vsize=%d, vsnapshot=%d, vbandlength=%d\n",\r\npdev->frame_size,pdev->vframes,pdev->vsize,pdev->vsnapshot,pdev->vbandlength);\r\nreturn 0;\r\n}\r\nint pwc_set_video_mode(struct pwc_device *pdev, int width, int height, int frames, int compression, int snapshot)\r\n{\r\nint ret, size;\r\nPWC_DEBUG_FLOW("set_video_mode(%dx%d @ %d, pixfmt %08x).\n", width, height, frames, pdev->pixfmt);\r\nsize = pwc_decode_size(pdev, width, height);\r\nif (size < 0) {\r\nPWC_DEBUG_MODULE("Could not find suitable size.\n");\r\nreturn -ERANGE;\r\n}\r\nPWC_TRACE("decode_size = %d.\n", size);\r\nif (DEVICE_USE_CODEC1(pdev->type)) {\r\nret = set_video_mode_Nala(pdev, size, frames);\r\n} else if (DEVICE_USE_CODEC3(pdev->type)) {\r\nret = set_video_mode_Kiara(pdev, size, frames, compression, snapshot);\r\n} else {\r\nret = set_video_mode_Timon(pdev, size, frames, compression, snapshot);\r\n}\r\nif (ret < 0) {\r\nPWC_ERROR("Failed to set video mode %s@%d fps; return code = %d\n", size2name[size], frames, ret);\r\nreturn ret;\r\n}\r\npdev->view.x = width;\r\npdev->view.y = height;\r\npdev->vcompression = compression;\r\npdev->frame_total_size = pdev->frame_size + pdev->frame_header_size + pdev->frame_trailer_size;\r\npwc_set_image_buffer_size(pdev);\r\nPWC_DEBUG_SIZE("Set viewport to %dx%d, image size is %dx%d.\n", width, height, pwc_image_sizes[size].x, pwc_image_sizes[size].y);\r\nreturn 0;\r\n}\r\nstatic unsigned int pwc_get_fps_Nala(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < PWC_FPS_MAX_NALA; i++) {\r\nif (Nala_table[size][i].alternate) {\r\nif (index--==0) return Nala_fps_vector[i];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pwc_get_fps_Kiara(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < PWC_FPS_MAX_KIARA; i++) {\r\nif (Kiara_table[size][i][3].alternate) {\r\nif (index--==0) return Kiara_fps_vector[i];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pwc_get_fps_Timon(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i=0; i < PWC_FPS_MAX_TIMON; i++) {\r\nif (Timon_table[size][i][3].alternate) {\r\nif (index--==0) return Timon_fps_vector[i];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nunsigned int pwc_get_fps(struct pwc_device *pdev, unsigned int index, unsigned int size)\r\n{\r\nunsigned int ret;\r\nif (DEVICE_USE_CODEC1(pdev->type)) {\r\nret = pwc_get_fps_Nala(pdev, index, size);\r\n} else if (DEVICE_USE_CODEC3(pdev->type)) {\r\nret = pwc_get_fps_Kiara(pdev, index, size);\r\n} else {\r\nret = pwc_get_fps_Timon(pdev, index, size);\r\n}\r\nreturn ret;\r\n}\r\nstatic void pwc_set_image_buffer_size(struct pwc_device *pdev)\r\n{\r\nint factor = 0;\r\nswitch (pdev->pixfmt) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nfactor = 6;\r\nbreak;\r\ncase V4L2_PIX_FMT_PWC1:\r\ncase V4L2_PIX_FMT_PWC2:\r\nfactor = 6;\r\nbreak;\r\n}\r\npdev->image.size = pdev->image.x * pdev->image.y * factor / 4;\r\npdev->view.size = pdev->view.x * pdev->view.y * factor / 4;\r\npdev->offset.x = ((pdev->view.x - pdev->image.x) / 2) & 0xFFFC;\r\npdev->offset.y = ((pdev->view.y - pdev->image.y) / 2) & 0xFFFE;\r\n}\r\nint pwc_get_u8_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\r\n{\r\nint ret;\r\nu8 buf;\r\nret = recv_control_msg(pdev, request, value, &buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*data = buf;\r\nreturn 0;\r\n}\r\nint pwc_set_u8_ctrl(struct pwc_device *pdev, u8 request, u16 value, u8 data)\r\n{\r\nint ret;\r\nret = send_control_msg(pdev, request, value, &data, sizeof(data));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint pwc_get_s8_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\r\n{\r\nint ret;\r\ns8 buf;\r\nret = recv_control_msg(pdev, request, value, &buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*data = buf;\r\nreturn 0;\r\n}\r\nint pwc_get_u16_ctrl(struct pwc_device *pdev, u8 request, u16 value, int *data)\r\n{\r\nint ret;\r\nu8 buf[2];\r\nret = recv_control_msg(pdev, request, value, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*data = (buf[1] << 8) | buf[0];\r\nreturn 0;\r\n}\r\nint pwc_set_u16_ctrl(struct pwc_device *pdev, u8 request, u16 value, u16 data)\r\n{\r\nint ret;\r\nu8 buf[2];\r\nbuf[0] = data & 0xff;\r\nbuf[1] = data >> 8;\r\nret = send_control_msg(pdev, request, value, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint pwc_button_ctrl(struct pwc_device *pdev, u16 value)\r\n{\r\nint ret;\r\nret = send_control_msg(pdev, SET_STATUS_CTL, value, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid pwc_camera_power(struct pwc_device *pdev, int power)\r\n{\r\nchar buf;\r\nint r;\r\nif (!pdev->power_save)\r\nreturn;\r\nif (pdev->type < 675 || (pdev->type < 730 && pdev->release < 6))\r\nreturn;\r\nif (power)\r\nbuf = 0x00;\r\nelse\r\nbuf = 0xFF;\r\nr = send_control_msg(pdev,\r\nSET_STATUS_CTL, SET_POWER_SAVE_MODE_FORMATTER,\r\n&buf, sizeof(buf));\r\nif (r < 0)\r\nPWC_ERROR("Failed to power %s camera (%d)\n",\r\npower ? "on" : "off", r);\r\n}\r\nstatic int pwc_set_wb_speed(struct pwc_device *pdev, int speed)\r\n{\r\nunsigned char buf;\r\nbuf = speed / 0x7f0;\r\nreturn send_control_msg(pdev,\r\nSET_CHROM_CTL, AWB_CONTROL_SPEED_FORMATTER, &buf, sizeof(buf));\r\n}\r\nstatic int pwc_get_wb_speed(struct pwc_device *pdev, int *value)\r\n{\r\nunsigned char buf;\r\nint ret;\r\nret = recv_control_msg(pdev,\r\nGET_CHROM_CTL, AWB_CONTROL_SPEED_FORMATTER, &buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*value = buf * 0x7f0;\r\nreturn 0;\r\n}\r\nstatic int pwc_set_wb_delay(struct pwc_device *pdev, int delay)\r\n{\r\nunsigned char buf;\r\nbuf = (delay >> 10);\r\nreturn send_control_msg(pdev,\r\nSET_CHROM_CTL, AWB_CONTROL_DELAY_FORMATTER, &buf, sizeof(buf));\r\n}\r\nstatic int pwc_get_wb_delay(struct pwc_device *pdev, int *value)\r\n{\r\nunsigned char buf;\r\nint ret;\r\nret = recv_control_msg(pdev,\r\nGET_CHROM_CTL, AWB_CONTROL_DELAY_FORMATTER, &buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*value = buf << 10;\r\nreturn 0;\r\n}\r\nint pwc_set_leds(struct pwc_device *pdev, int on_value, int off_value)\r\n{\r\nunsigned char buf[2];\r\nint r;\r\nif (pdev->type < 730)\r\nreturn 0;\r\non_value /= 100;\r\noff_value /= 100;\r\nif (on_value < 0)\r\non_value = 0;\r\nif (on_value > 0xff)\r\non_value = 0xff;\r\nif (off_value < 0)\r\noff_value = 0;\r\nif (off_value > 0xff)\r\noff_value = 0xff;\r\nbuf[0] = on_value;\r\nbuf[1] = off_value;\r\nr = send_control_msg(pdev,\r\nSET_STATUS_CTL, LED_FORMATTER, &buf, sizeof(buf));\r\nif (r < 0)\r\nPWC_ERROR("Failed to set LED on/off time (%d)\n", r);\r\nreturn r;\r\n}\r\nstatic int pwc_get_leds(struct pwc_device *pdev, int *on_value, int *off_value)\r\n{\r\nunsigned char buf[2];\r\nint ret;\r\nif (pdev->type < 730) {\r\n*on_value = -1;\r\n*off_value = -1;\r\nreturn 0;\r\n}\r\nret = recv_control_msg(pdev,\r\nGET_STATUS_CTL, LED_FORMATTER, &buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\n*on_value = buf[0] * 100;\r\n*off_value = buf[1] * 100;\r\nreturn 0;\r\n}\r\nstatic int _pwc_mpt_reset(struct pwc_device *pdev, int flags)\r\n{\r\nunsigned char buf;\r\nbuf = flags & 0x03;\r\nreturn send_control_msg(pdev,\r\nSET_MPT_CTL, PT_RESET_CONTROL_FORMATTER, &buf, sizeof(buf));\r\n}\r\nint pwc_mpt_reset(struct pwc_device *pdev, int flags)\r\n{\r\nint ret;\r\nret = _pwc_mpt_reset(pdev, flags);\r\nif (ret >= 0) {\r\npdev->pan_angle = 0;\r\npdev->tilt_angle = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int _pwc_mpt_set_angle(struct pwc_device *pdev, int pan, int tilt)\r\n{\r\nunsigned char buf[4];\r\npan = 64 * pan / 100;\r\ntilt = -64 * tilt / 100;\r\nbuf[0] = pan & 0xFF;\r\nbuf[1] = (pan >> 8) & 0xFF;\r\nbuf[2] = tilt & 0xFF;\r\nbuf[3] = (tilt >> 8) & 0xFF;\r\nreturn send_control_msg(pdev,\r\nSET_MPT_CTL, PT_RELATIVE_CONTROL_FORMATTER, &buf, sizeof(buf));\r\n}\r\nint pwc_mpt_set_angle(struct pwc_device *pdev, int pan, int tilt)\r\n{\r\nint ret;\r\nif (pan < pdev->angle_range.pan_min ||\r\npan > pdev->angle_range.pan_max ||\r\ntilt < pdev->angle_range.tilt_min ||\r\ntilt > pdev->angle_range.tilt_max)\r\nreturn -ERANGE;\r\npan -= pdev->pan_angle;\r\ntilt -= pdev->tilt_angle;\r\nif (pan < -36000 || pan > 36000 || tilt < -36000 || tilt > 36000)\r\nreturn -ERANGE;\r\nret = _pwc_mpt_set_angle(pdev, pan, tilt);\r\nif (ret >= 0) {\r\npdev->pan_angle += pan;\r\npdev->tilt_angle += tilt;\r\n}\r\nif (ret == -EPIPE)\r\nret = -ERANGE;\r\nreturn ret;\r\n}\r\nstatic int pwc_mpt_get_status(struct pwc_device *pdev, struct pwc_mpt_status *status)\r\n{\r\nint ret;\r\nunsigned char buf[5];\r\nret = recv_control_msg(pdev,\r\nGET_MPT_CTL, PT_STATUS_FORMATTER, &buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nstatus->status = buf[0] & 0x7;\r\nstatus->time_pan = (buf[1] << 8) + buf[2];\r\nstatus->time_tilt = (buf[3] << 8) + buf[4];\r\nreturn 0;\r\n}\r\nint pwc_get_cmos_sensor(struct pwc_device *pdev, int *sensor)\r\n{\r\nunsigned char buf;\r\nint ret = -1, request;\r\nif (pdev->type < 675)\r\nrequest = SENSOR_TYPE_FORMATTER1;\r\nelse if (pdev->type < 730)\r\nreturn -1;\r\nelse\r\nrequest = SENSOR_TYPE_FORMATTER2;\r\nret = recv_control_msg(pdev,\r\nGET_STATUS_CTL, request, &buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nif (pdev->type < 675)\r\n*sensor = buf | 0x100;\r\nelse\r\n*sensor = buf;\r\nreturn 0;\r\n}\r\nstatic int pwc_ioctl_g_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn v4l2_ctrl_g_ctrl(ctrl) * 65535 / ctrl->maximum;\r\n}\r\nstatic int pwc_ioctl_s_ctrl(struct v4l2_ctrl *ctrl, int val)\r\n{\r\nreturn v4l2_ctrl_s_ctrl(ctrl, val * ctrl->maximum / 65535);\r\n}\r\nlong pwc_ioctl(struct pwc_device *pdev, unsigned int cmd, void *arg)\r\n{\r\nlong ret = 0;\r\nswitch(cmd) {\r\ncase VIDIOCPWCRUSER:\r\nret = pwc_button_ctrl(pdev, RESTORE_USER_DEFAULTS_FORMATTER);\r\nbreak;\r\ncase VIDIOCPWCSUSER:\r\nret = pwc_button_ctrl(pdev, SAVE_USER_DEFAULTS_FORMATTER);\r\nbreak;\r\ncase VIDIOCPWCFACTORY:\r\nret = pwc_button_ctrl(pdev, RESTORE_FACTORY_DEFAULTS_FORMATTER);\r\nbreak;\r\ncase VIDIOCPWCSCQUAL:\r\n{\r\nARG_DEF(int, qual)\r\nif (vb2_is_streaming(&pdev->vb_queue)) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nARG_IN(qual)\r\nif (ARGR(qual) < 0 || ARGR(qual) > 3)\r\nret = -EINVAL;\r\nelse\r\nret = pwc_set_video_mode(pdev, pdev->view.x, pdev->view.y, pdev->vframes, ARGR(qual), pdev->vsnapshot);\r\nbreak;\r\n}\r\ncase VIDIOCPWCGCQUAL:\r\n{\r\nARG_DEF(int, qual)\r\nARGR(qual) = pdev->vcompression;\r\nARG_OUT(qual)\r\nbreak;\r\n}\r\ncase VIDIOCPWCPROBE:\r\n{\r\nARG_DEF(struct pwc_probe, probe)\r\nstrcpy(ARGR(probe).name, pdev->vdev.name);\r\nARGR(probe).type = pdev->type;\r\nARG_OUT(probe)\r\nbreak;\r\n}\r\ncase VIDIOCPWCGSERIAL:\r\n{\r\nARG_DEF(struct pwc_serial, serial)\r\nstrcpy(ARGR(serial).serial, pdev->serial);\r\nARG_OUT(serial)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSAGC:\r\n{\r\nARG_DEF(int, agc)\r\nARG_IN(agc)\r\nret = v4l2_ctrl_s_ctrl(pdev->autogain, ARGR(agc) < 0);\r\nif (ret == 0 && ARGR(agc) >= 0)\r\nret = pwc_ioctl_s_ctrl(pdev->gain, ARGR(agc));\r\nbreak;\r\n}\r\ncase VIDIOCPWCGAGC:\r\n{\r\nARG_DEF(int, agc)\r\nif (v4l2_ctrl_g_ctrl(pdev->autogain))\r\nARGR(agc) = -1;\r\nelse\r\nARGR(agc) = pwc_ioctl_g_ctrl(pdev->gain);\r\nARG_OUT(agc)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSSHUTTER:\r\n{\r\nARG_DEF(int, shutter)\r\nARG_IN(shutter)\r\nret = v4l2_ctrl_s_ctrl(pdev->exposure_auto,\r\nARGR(shutter) >= 0);\r\nif (ret == 0 && ARGR(shutter) >= 0)\r\nret = pwc_ioctl_s_ctrl(pdev->exposure, ARGR(shutter));\r\nbreak;\r\n}\r\ncase VIDIOCPWCSAWB:\r\n{\r\nARG_DEF(struct pwc_whitebalance, wb)\r\nARG_IN(wb)\r\nret = v4l2_ctrl_s_ctrl(pdev->auto_white_balance,\r\nARGR(wb).mode);\r\nif (ret == 0 && ARGR(wb).mode == PWC_WB_MANUAL)\r\nret = pwc_ioctl_s_ctrl(pdev->red_balance,\r\nARGR(wb).manual_red);\r\nif (ret == 0 && ARGR(wb).mode == PWC_WB_MANUAL)\r\nret = pwc_ioctl_s_ctrl(pdev->blue_balance,\r\nARGR(wb).manual_blue);\r\nbreak;\r\n}\r\ncase VIDIOCPWCGAWB:\r\n{\r\nARG_DEF(struct pwc_whitebalance, wb)\r\nARGR(wb).mode = v4l2_ctrl_g_ctrl(pdev->auto_white_balance);\r\nARGR(wb).manual_red = ARGR(wb).read_red =\r\npwc_ioctl_g_ctrl(pdev->red_balance);\r\nARGR(wb).manual_blue = ARGR(wb).read_blue =\r\npwc_ioctl_g_ctrl(pdev->blue_balance);\r\nARG_OUT(wb)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSAWBSPEED:\r\n{\r\nARG_DEF(struct pwc_wb_speed, wbs)\r\nif (ARGR(wbs).control_speed > 0) {\r\nret = pwc_set_wb_speed(pdev, ARGR(wbs).control_speed);\r\n}\r\nif (ARGR(wbs).control_delay > 0) {\r\nret = pwc_set_wb_delay(pdev, ARGR(wbs).control_delay);\r\n}\r\nbreak;\r\n}\r\ncase VIDIOCPWCGAWBSPEED:\r\n{\r\nARG_DEF(struct pwc_wb_speed, wbs)\r\nret = pwc_get_wb_speed(pdev, &ARGR(wbs).control_speed);\r\nif (ret < 0)\r\nbreak;\r\nret = pwc_get_wb_delay(pdev, &ARGR(wbs).control_delay);\r\nif (ret < 0)\r\nbreak;\r\nARG_OUT(wbs)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSLED:\r\n{\r\nARG_DEF(struct pwc_leds, leds)\r\nARG_IN(leds)\r\nret = pwc_set_leds(pdev, ARGR(leds).led_on, ARGR(leds).led_off);\r\nbreak;\r\n}\r\ncase VIDIOCPWCGLED:\r\n{\r\nARG_DEF(struct pwc_leds, leds)\r\nret = pwc_get_leds(pdev, &ARGR(leds).led_on, &ARGR(leds).led_off);\r\nARG_OUT(leds)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSCONTOUR:\r\n{\r\nARG_DEF(int, contour)\r\nARG_IN(contour)\r\nret = v4l2_ctrl_s_ctrl(pdev->autocontour, ARGR(contour) < 0);\r\nif (ret == 0 && ARGR(contour) >= 0)\r\nret = pwc_ioctl_s_ctrl(pdev->contour, ARGR(contour));\r\nbreak;\r\n}\r\ncase VIDIOCPWCGCONTOUR:\r\n{\r\nARG_DEF(int, contour)\r\nif (v4l2_ctrl_g_ctrl(pdev->autocontour))\r\nARGR(contour) = -1;\r\nelse\r\nARGR(contour) = pwc_ioctl_g_ctrl(pdev->contour);\r\nARG_OUT(contour)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSBACKLIGHT:\r\n{\r\nARG_DEF(int, backlight)\r\nARG_IN(backlight)\r\nret = v4l2_ctrl_s_ctrl(pdev->backlight, ARGR(backlight));\r\nbreak;\r\n}\r\ncase VIDIOCPWCGBACKLIGHT:\r\n{\r\nARG_DEF(int, backlight)\r\nARGR(backlight) = v4l2_ctrl_g_ctrl(pdev->backlight);\r\nARG_OUT(backlight)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSFLICKER:\r\n{\r\nARG_DEF(int, flicker)\r\nARG_IN(flicker)\r\nret = v4l2_ctrl_s_ctrl(pdev->flicker, ARGR(flicker));\r\nbreak;\r\n}\r\ncase VIDIOCPWCGFLICKER:\r\n{\r\nARG_DEF(int, flicker)\r\nARGR(flicker) = v4l2_ctrl_g_ctrl(pdev->flicker);\r\nARG_OUT(flicker)\r\nbreak;\r\n}\r\ncase VIDIOCPWCSDYNNOISE:\r\n{\r\nARG_DEF(int, dynnoise)\r\nARG_IN(dynnoise)\r\nret = v4l2_ctrl_s_ctrl(pdev->noise_reduction, ARGR(dynnoise));\r\nbreak;\r\n}\r\ncase VIDIOCPWCGDYNNOISE:\r\n{\r\nARG_DEF(int, dynnoise)\r\nARGR(dynnoise) = v4l2_ctrl_g_ctrl(pdev->noise_reduction);\r\nARG_OUT(dynnoise);\r\nbreak;\r\n}\r\ncase VIDIOCPWCGREALSIZE:\r\n{\r\nARG_DEF(struct pwc_imagesize, size)\r\nARGR(size).width = pdev->image.x;\r\nARGR(size).height = pdev->image.y;\r\nARG_OUT(size)\r\nbreak;\r\n}\r\ncase VIDIOCPWCMPTRESET:\r\n{\r\nif (pdev->features & FEATURE_MOTOR_PANTILT)\r\n{\r\nARG_DEF(int, flags)\r\nARG_IN(flags)\r\nret = pwc_mpt_reset(pdev, ARGR(flags));\r\n}\r\nelse\r\n{\r\nret = -ENXIO;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOCPWCMPTGRANGE:\r\n{\r\nif (pdev->features & FEATURE_MOTOR_PANTILT)\r\n{\r\nARG_DEF(struct pwc_mpt_range, range)\r\nARGR(range) = pdev->angle_range;\r\nARG_OUT(range)\r\n}\r\nelse\r\n{\r\nret = -ENXIO;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOCPWCMPTSANGLE:\r\n{\r\nint new_pan, new_tilt;\r\nif (pdev->features & FEATURE_MOTOR_PANTILT)\r\n{\r\nARG_DEF(struct pwc_mpt_angles, angles)\r\nARG_IN(angles)\r\nif (ARGR(angles).absolute)\r\n{\r\nnew_pan = ARGR(angles).pan;\r\nnew_tilt = ARGR(angles).tilt;\r\n}\r\nelse\r\n{\r\nnew_pan = pdev->pan_angle + ARGR(angles).pan;\r\nnew_tilt = pdev->tilt_angle + ARGR(angles).tilt;\r\n}\r\nret = pwc_mpt_set_angle(pdev, new_pan, new_tilt);\r\n}\r\nelse\r\n{\r\nret = -ENXIO;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOCPWCMPTGANGLE:\r\n{\r\nif (pdev->features & FEATURE_MOTOR_PANTILT)\r\n{\r\nARG_DEF(struct pwc_mpt_angles, angles)\r\nARGR(angles).absolute = 1;\r\nARGR(angles).pan = pdev->pan_angle;\r\nARGR(angles).tilt = pdev->tilt_angle;\r\nARG_OUT(angles)\r\n}\r\nelse\r\n{\r\nret = -ENXIO;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOCPWCMPTSTATUS:\r\n{\r\nif (pdev->features & FEATURE_MOTOR_PANTILT)\r\n{\r\nARG_DEF(struct pwc_mpt_status, status)\r\nret = pwc_mpt_get_status(pdev, ARGA(status));\r\nARG_OUT(status)\r\n}\r\nelse\r\n{\r\nret = -ENXIO;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOCPWCGVIDCMD:\r\n{\r\nARG_DEF(struct pwc_video_command, vcmd);\r\nARGR(vcmd).type = pdev->type;\r\nARGR(vcmd).release = pdev->release;\r\nARGR(vcmd).command_len = pdev->cmd_len;\r\nmemcpy(&ARGR(vcmd).command_buf, pdev->cmd_buf, pdev->cmd_len);\r\nARGR(vcmd).bandlength = pdev->vbandlength;\r\nARGR(vcmd).frame_size = pdev->frame_size;\r\nARG_OUT(vcmd)\r\nbreak;\r\n}\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nif (ret > 0)\r\nreturn 0;\r\nreturn ret;\r\n}
