static struct asyncppp *ap_get(struct tty_struct *tty)\r\n{\r\nstruct asyncppp *ap;\r\nread_lock(&disc_data_lock);\r\nap = tty->disc_data;\r\nif (ap != NULL)\r\natomic_inc(&ap->refcnt);\r\nread_unlock(&disc_data_lock);\r\nreturn ap;\r\n}\r\nstatic void ap_put(struct asyncppp *ap)\r\n{\r\nif (atomic_dec_and_test(&ap->refcnt))\r\nup(&ap->dead_sem);\r\n}\r\nstatic int\r\nppp_asynctty_open(struct tty_struct *tty)\r\n{\r\nstruct asyncppp *ap;\r\nint err;\r\nint speed;\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\nerr = -ENOMEM;\r\nap = kzalloc(sizeof(*ap), GFP_KERNEL);\r\nif (!ap)\r\ngoto out;\r\nap->tty = tty;\r\nap->mru = PPP_MRU;\r\nspin_lock_init(&ap->xmit_lock);\r\nspin_lock_init(&ap->recv_lock);\r\nap->xaccm[0] = ~0U;\r\nap->xaccm[3] = 0x60000000U;\r\nap->raccm = ~0U;\r\nap->optr = ap->obuf;\r\nap->olim = ap->obuf;\r\nap->lcp_fcs = -1;\r\nskb_queue_head_init(&ap->rqueue);\r\ntasklet_init(&ap->tsk, ppp_async_process, (unsigned long) ap);\r\natomic_set(&ap->refcnt, 1);\r\nsema_init(&ap->dead_sem, 0);\r\nap->chan.private = ap;\r\nap->chan.ops = &async_ops;\r\nap->chan.mtu = PPP_MRU;\r\nspeed = tty_get_baud_rate(tty);\r\nap->chan.speed = speed;\r\nerr = ppp_register_channel(&ap->chan);\r\nif (err)\r\ngoto out_free;\r\ntty->disc_data = ap;\r\ntty->receive_room = 65536;\r\nreturn 0;\r\nout_free:\r\nkfree(ap);\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\nppp_asynctty_close(struct tty_struct *tty)\r\n{\r\nstruct asyncppp *ap;\r\nwrite_lock_irq(&disc_data_lock);\r\nap = tty->disc_data;\r\ntty->disc_data = NULL;\r\nwrite_unlock_irq(&disc_data_lock);\r\nif (!ap)\r\nreturn;\r\nif (!atomic_dec_and_test(&ap->refcnt))\r\ndown(&ap->dead_sem);\r\ntasklet_kill(&ap->tsk);\r\nppp_unregister_channel(&ap->chan);\r\nkfree_skb(ap->rpkt);\r\nskb_queue_purge(&ap->rqueue);\r\nkfree_skb(ap->tpkt);\r\nkfree(ap);\r\n}\r\nstatic int ppp_asynctty_hangup(struct tty_struct *tty)\r\n{\r\nppp_asynctty_close(tty);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nppp_asynctty_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user *buf, size_t count)\r\n{\r\nreturn -EAGAIN;\r\n}\r\nstatic ssize_t\r\nppp_asynctty_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *buf, size_t count)\r\n{\r\nreturn -EAGAIN;\r\n}\r\nstatic int\r\nppp_asynctty_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct asyncppp *ap = ap_get(tty);\r\nint err, val;\r\nint __user *p = (int __user *)arg;\r\nif (!ap)\r\nreturn -ENXIO;\r\nerr = -EFAULT;\r\nswitch (cmd) {\r\ncase PPPIOCGCHAN:\r\nerr = -EFAULT;\r\nif (put_user(ppp_channel_index(&ap->chan), p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGUNIT:\r\nerr = -EFAULT;\r\nif (put_user(ppp_unit_number(&ap->chan), p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase TCFLSH:\r\nif (arg == TCIOFLUSH || arg == TCOFLUSH)\r\nppp_async_flush_output(ap);\r\nerr = tty_perform_flush(tty, arg);\r\nbreak;\r\ncase FIONREAD:\r\nval = 0;\r\nif (put_user(val, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = tty_mode_ioctl(tty, file, cmd, arg);\r\n}\r\nap_put(ap);\r\nreturn err;\r\n}\r\nstatic unsigned int\r\nppp_asynctty_poll(struct tty_struct *tty, struct file *file, poll_table *wait)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nppp_asynctty_receive(struct tty_struct *tty, const unsigned char *buf,\r\nchar *cflags, int count)\r\n{\r\nstruct asyncppp *ap = ap_get(tty);\r\nunsigned long flags;\r\nif (!ap)\r\nreturn;\r\nspin_lock_irqsave(&ap->recv_lock, flags);\r\nppp_async_input(ap, buf, cflags, count);\r\nspin_unlock_irqrestore(&ap->recv_lock, flags);\r\nif (!skb_queue_empty(&ap->rqueue))\r\ntasklet_schedule(&ap->tsk);\r\nap_put(ap);\r\ntty_unthrottle(tty);\r\n}\r\nstatic void\r\nppp_asynctty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct asyncppp *ap = ap_get(tty);\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nif (!ap)\r\nreturn;\r\nset_bit(XMIT_WAKEUP, &ap->xmit_flags);\r\ntasklet_schedule(&ap->tsk);\r\nap_put(ap);\r\n}\r\nstatic int __init\r\nppp_async_init(void)\r\n{\r\nint err;\r\nerr = tty_register_ldisc(N_PPP, &ppp_ldisc);\r\nif (err != 0)\r\nprintk(KERN_ERR "PPP_async: error %d registering line disc.\n",\r\nerr);\r\nreturn err;\r\n}\r\nstatic int\r\nppp_async_ioctl(struct ppp_channel *chan, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct asyncppp *ap = chan->private;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint err, val;\r\nu32 accm[8];\r\nerr = -EFAULT;\r\nswitch (cmd) {\r\ncase PPPIOCGFLAGS:\r\nval = ap->flags | ap->rbits;\r\nif (put_user(val, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSFLAGS:\r\nif (get_user(val, p))\r\nbreak;\r\nap->flags = val & ~SC_RCV_BITS;\r\nspin_lock_irq(&ap->recv_lock);\r\nap->rbits = val & SC_RCV_BITS;\r\nspin_unlock_irq(&ap->recv_lock);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGASYNCMAP:\r\nif (put_user(ap->xaccm[0], (u32 __user *)argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSASYNCMAP:\r\nif (get_user(ap->xaccm[0], (u32 __user *)argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGRASYNCMAP:\r\nif (put_user(ap->raccm, (u32 __user *)argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSRASYNCMAP:\r\nif (get_user(ap->raccm, (u32 __user *)argp))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGXASYNCMAP:\r\nif (copy_to_user(argp, ap->xaccm, sizeof(ap->xaccm)))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSXASYNCMAP:\r\nif (copy_from_user(accm, argp, sizeof(accm)))\r\nbreak;\r\naccm[2] &= ~0x40000000U;\r\naccm[3] |= 0x60000000U;\r\nmemcpy(ap->xaccm, accm, sizeof(ap->xaccm));\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGMRU:\r\nif (put_user(ap->mru, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSMRU:\r\nif (get_user(val, p))\r\nbreak;\r\nif (val < PPP_MRU)\r\nval = PPP_MRU;\r\nap->mru = val;\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\n}\r\nreturn err;\r\n}\r\nstatic void ppp_async_process(unsigned long arg)\r\n{\r\nstruct asyncppp *ap = (struct asyncppp *) arg;\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&ap->rqueue)) != NULL) {\r\nif (skb->cb[0])\r\nppp_input_error(&ap->chan, 0);\r\nppp_input(&ap->chan, skb);\r\n}\r\nif (test_bit(XMIT_WAKEUP, &ap->xmit_flags) && ppp_async_push(ap))\r\nppp_output_wakeup(&ap->chan);\r\n}\r\nstatic int\r\nppp_async_encode(struct asyncppp *ap)\r\n{\r\nint fcs, i, count, c, proto;\r\nunsigned char *buf, *buflim;\r\nunsigned char *data;\r\nint islcp;\r\nbuf = ap->obuf;\r\nap->olim = buf;\r\nap->optr = buf;\r\ni = ap->tpkt_pos;\r\ndata = ap->tpkt->data;\r\ncount = ap->tpkt->len;\r\nfcs = ap->tfcs;\r\nproto = get_unaligned_be16(data);\r\nislcp = proto == PPP_LCP && 1 <= data[2] && data[2] <= 7;\r\nif (i == 0) {\r\nif (islcp)\r\nasync_lcp_peek(ap, data, count, 0);\r\nif (islcp || flag_time == 0 ||\r\ntime_after_eq(jiffies, ap->last_xmit + flag_time))\r\n*buf++ = PPP_FLAG;\r\nap->last_xmit = jiffies;\r\nfcs = PPP_INITFCS;\r\nif ((ap->flags & SC_COMP_AC) == 0 || islcp) {\r\nPUT_BYTE(ap, buf, 0xff, islcp);\r\nfcs = PPP_FCS(fcs, 0xff);\r\nPUT_BYTE(ap, buf, 0x03, islcp);\r\nfcs = PPP_FCS(fcs, 0x03);\r\n}\r\n}\r\nbuflim = ap->obuf + OBUFSIZE - 6;\r\nwhile (i < count && buf < buflim) {\r\nc = data[i++];\r\nif (i == 1 && c == 0 && (ap->flags & SC_COMP_PROT))\r\ncontinue;\r\nfcs = PPP_FCS(fcs, c);\r\nPUT_BYTE(ap, buf, c, islcp);\r\n}\r\nif (i < count) {\r\nap->olim = buf;\r\nap->tpkt_pos = i;\r\nap->tfcs = fcs;\r\nreturn 0;\r\n}\r\nfcs = ~fcs;\r\nc = fcs & 0xff;\r\nPUT_BYTE(ap, buf, c, islcp);\r\nc = (fcs >> 8) & 0xff;\r\nPUT_BYTE(ap, buf, c, islcp);\r\n*buf++ = PPP_FLAG;\r\nap->olim = buf;\r\nkfree_skb(ap->tpkt);\r\nap->tpkt = NULL;\r\nreturn 1;\r\n}\r\nstatic int\r\nppp_async_send(struct ppp_channel *chan, struct sk_buff *skb)\r\n{\r\nstruct asyncppp *ap = chan->private;\r\nppp_async_push(ap);\r\nif (test_and_set_bit(XMIT_FULL, &ap->xmit_flags))\r\nreturn 0;\r\nap->tpkt = skb;\r\nap->tpkt_pos = 0;\r\nppp_async_push(ap);\r\nreturn 1;\r\n}\r\nstatic int\r\nppp_async_push(struct asyncppp *ap)\r\n{\r\nint avail, sent, done = 0;\r\nstruct tty_struct *tty = ap->tty;\r\nint tty_stuffed = 0;\r\nif (test_and_set_bit(XMIT_BUSY, &ap->xmit_flags))\r\nreturn 0;\r\nspin_lock_bh(&ap->xmit_lock);\r\nfor (;;) {\r\nif (test_and_clear_bit(XMIT_WAKEUP, &ap->xmit_flags))\r\ntty_stuffed = 0;\r\nif (!tty_stuffed && ap->optr < ap->olim) {\r\navail = ap->olim - ap->optr;\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nsent = tty->ops->write(tty, ap->optr, avail);\r\nif (sent < 0)\r\ngoto flush;\r\nap->optr += sent;\r\nif (sent < avail)\r\ntty_stuffed = 1;\r\ncontinue;\r\n}\r\nif (ap->optr >= ap->olim && ap->tpkt) {\r\nif (ppp_async_encode(ap)) {\r\nclear_bit(XMIT_FULL, &ap->xmit_flags);\r\ndone = 1;\r\n}\r\ncontinue;\r\n}\r\nclear_bit(XMIT_BUSY, &ap->xmit_flags);\r\nif (!(test_bit(XMIT_WAKEUP, &ap->xmit_flags) ||\r\n(!tty_stuffed && ap->tpkt)))\r\nbreak;\r\nif (test_and_set_bit(XMIT_BUSY, &ap->xmit_flags))\r\nbreak;\r\n}\r\nspin_unlock_bh(&ap->xmit_lock);\r\nreturn done;\r\nflush:\r\nclear_bit(XMIT_BUSY, &ap->xmit_flags);\r\nif (ap->tpkt) {\r\nkfree_skb(ap->tpkt);\r\nap->tpkt = NULL;\r\nclear_bit(XMIT_FULL, &ap->xmit_flags);\r\ndone = 1;\r\n}\r\nap->optr = ap->olim;\r\nspin_unlock_bh(&ap->xmit_lock);\r\nreturn done;\r\n}\r\nstatic void\r\nppp_async_flush_output(struct asyncppp *ap)\r\n{\r\nint done = 0;\r\nspin_lock_bh(&ap->xmit_lock);\r\nap->optr = ap->olim;\r\nif (ap->tpkt != NULL) {\r\nkfree_skb(ap->tpkt);\r\nap->tpkt = NULL;\r\nclear_bit(XMIT_FULL, &ap->xmit_flags);\r\ndone = 1;\r\n}\r\nspin_unlock_bh(&ap->xmit_lock);\r\nif (done)\r\nppp_output_wakeup(&ap->chan);\r\n}\r\nstatic inline int\r\nscan_ordinary(struct asyncppp *ap, const unsigned char *buf, int count)\r\n{\r\nint i, c;\r\nfor (i = 0; i < count; ++i) {\r\nc = buf[i];\r\nif (c == PPP_ESCAPE || c == PPP_FLAG ||\r\n(c < 0x20 && (ap->raccm & (1 << c)) != 0))\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic void\r\nprocess_input_packet(struct asyncppp *ap)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *p;\r\nunsigned int len, fcs, proto;\r\nskb = ap->rpkt;\r\nif (ap->state & (SC_TOSS | SC_ESCAPE))\r\ngoto err;\r\nif (skb == NULL)\r\nreturn;\r\np = skb->data;\r\nlen = skb->len;\r\nif (len < 3)\r\ngoto err;\r\nfcs = PPP_INITFCS;\r\nfor (; len > 0; --len)\r\nfcs = PPP_FCS(fcs, *p++);\r\nif (fcs != PPP_GOODFCS)\r\ngoto err;\r\nskb_trim(skb, skb->len - 2);\r\np = skb->data;\r\nif (p[0] == PPP_ALLSTATIONS) {\r\nif (p[1] != PPP_UI || skb->len < 3)\r\ngoto err;\r\np = skb_pull(skb, 2);\r\n}\r\nproto = p[0];\r\nif (proto & 1) {\r\nskb_push(skb, 1)[0] = 0;\r\n} else {\r\nif (skb->len < 2)\r\ngoto err;\r\nproto = (proto << 8) + p[1];\r\nif (proto == PPP_LCP)\r\nasync_lcp_peek(ap, p, skb->len, 1);\r\n}\r\nskb->cb[0] = ap->state;\r\nskb_queue_tail(&ap->rqueue, skb);\r\nap->rpkt = NULL;\r\nap->state = 0;\r\nreturn;\r\nerr:\r\nap->state = SC_PREV_ERROR;\r\nif (skb) {\r\nskb_trim(skb, 0);\r\nskb_reserve(skb, - skb_headroom(skb));\r\n}\r\n}\r\nstatic void\r\nppp_async_input(struct asyncppp *ap, const unsigned char *buf,\r\nchar *flags, int count)\r\n{\r\nstruct sk_buff *skb;\r\nint c, i, j, n, s, f;\r\nunsigned char *sp;\r\nif (~ap->rbits & SC_RCV_BITS) {\r\ns = 0;\r\nfor (i = 0; i < count; ++i) {\r\nc = buf[i];\r\nif (flags && flags[i] != 0)\r\ncontinue;\r\ns |= (c & 0x80)? SC_RCV_B7_1: SC_RCV_B7_0;\r\nc = ((c >> 4) ^ c) & 0xf;\r\ns |= (0x6996 & (1 << c))? SC_RCV_ODDP: SC_RCV_EVNP;\r\n}\r\nap->rbits |= s;\r\n}\r\nwhile (count > 0) {\r\nif ((ap->state & SC_ESCAPE) && buf[0] == PPP_ESCAPE)\r\nn = 1;\r\nelse\r\nn = scan_ordinary(ap, buf, count);\r\nf = 0;\r\nif (flags && (ap->state & SC_TOSS) == 0) {\r\nfor (j = 0; j < n; ++j)\r\nif ((f = flags[j]) != 0)\r\nbreak;\r\n}\r\nif (f != 0) {\r\nap->state |= SC_TOSS;\r\n} else if (n > 0 && (ap->state & SC_TOSS) == 0) {\r\nskb = ap->rpkt;\r\nif (!skb) {\r\nskb = dev_alloc_skb(ap->mru + PPP_HDRLEN + 2);\r\nif (!skb)\r\ngoto nomem;\r\nap->rpkt = skb;\r\n}\r\nif (skb->len == 0) {\r\nif (buf[0] != PPP_ALLSTATIONS)\r\nskb_reserve(skb, 2 + (buf[0] & 1));\r\n}\r\nif (n > skb_tailroom(skb)) {\r\nap->state |= SC_TOSS;\r\n} else {\r\nsp = skb_put(skb, n);\r\nmemcpy(sp, buf, n);\r\nif (ap->state & SC_ESCAPE) {\r\nsp[0] ^= PPP_TRANS;\r\nap->state &= ~SC_ESCAPE;\r\n}\r\n}\r\n}\r\nif (n >= count)\r\nbreak;\r\nc = buf[n];\r\nif (flags != NULL && flags[n] != 0) {\r\nap->state |= SC_TOSS;\r\n} else if (c == PPP_FLAG) {\r\nprocess_input_packet(ap);\r\n} else if (c == PPP_ESCAPE) {\r\nap->state |= SC_ESCAPE;\r\n} else if (I_IXON(ap->tty)) {\r\nif (c == START_CHAR(ap->tty))\r\nstart_tty(ap->tty);\r\nelse if (c == STOP_CHAR(ap->tty))\r\nstop_tty(ap->tty);\r\n}\r\n++n;\r\nbuf += n;\r\nif (flags)\r\nflags += n;\r\ncount -= n;\r\n}\r\nreturn;\r\nnomem:\r\nprintk(KERN_ERR "PPPasync: no memory (input pkt)\n");\r\nap->state |= SC_TOSS;\r\n}\r\nstatic void async_lcp_peek(struct asyncppp *ap, unsigned char *data,\r\nint len, int inbound)\r\n{\r\nint dlen, fcs, i, code;\r\nu32 val;\r\ndata += 2;\r\nlen -= 2;\r\nif (len < 4)\r\nreturn;\r\ncode = data[0];\r\nif (code != CONFACK && code != CONFREQ)\r\nreturn;\r\ndlen = get_unaligned_be16(data + 2);\r\nif (len < dlen)\r\nreturn;\r\nif (code == (inbound? CONFACK: CONFREQ)) {\r\nfcs = PPP_INITFCS;\r\nfor (i = 1; i < dlen; ++i)\r\nfcs = PPP_FCS(fcs, data[i]);\r\nif (!inbound) {\r\nap->lcp_fcs = fcs;\r\nreturn;\r\n}\r\nfcs ^= ap->lcp_fcs;\r\nap->lcp_fcs = -1;\r\nif (fcs != 0)\r\nreturn;\r\n} else if (inbound)\r\nreturn;\r\ndata += 4;\r\ndlen -= 4;\r\nwhile (dlen >= 2 && dlen >= data[1] && data[1] >= 2) {\r\nswitch (data[0]) {\r\ncase LCP_MRU:\r\nval = get_unaligned_be16(data + 2);\r\nif (inbound)\r\nap->mru = val;\r\nelse\r\nap->chan.mtu = val;\r\nbreak;\r\ncase LCP_ASYNCMAP:\r\nval = get_unaligned_be32(data + 2);\r\nif (inbound)\r\nap->raccm = val;\r\nelse\r\nap->xaccm[0] = val;\r\nbreak;\r\n}\r\ndlen -= data[1];\r\ndata += data[1];\r\n}\r\n}\r\nstatic void __exit ppp_async_cleanup(void)\r\n{\r\nif (tty_unregister_ldisc(N_PPP) != 0)\r\nprintk(KERN_ERR "failed to unregister PPP line discipline\n");\r\n}
