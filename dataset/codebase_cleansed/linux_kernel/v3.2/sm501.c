static unsigned long decode_div(unsigned long pll2, unsigned long val,\r\nunsigned int lshft, unsigned int selbit,\r\nunsigned long mask)\r\n{\r\nif (val & selbit)\r\npll2 = 288 * MHZ;\r\nreturn pll2 / div_tab[(val >> lshft) & mask];\r\n}\r\nstatic void sm501_dump_clk(struct sm501_devdata *sm)\r\n{\r\nunsigned long misct = smc501_readl(sm->regs + SM501_MISC_TIMING);\r\nunsigned long pm0 = smc501_readl(sm->regs + SM501_POWER_MODE_0_CLOCK);\r\nunsigned long pm1 = smc501_readl(sm->regs + SM501_POWER_MODE_1_CLOCK);\r\nunsigned long pmc = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\r\nunsigned long sdclk0, sdclk1;\r\nunsigned long pll2 = 0;\r\nswitch (misct & 0x30) {\r\ncase 0x00:\r\npll2 = 336 * MHZ;\r\nbreak;\r\ncase 0x10:\r\npll2 = 288 * MHZ;\r\nbreak;\r\ncase 0x20:\r\npll2 = 240 * MHZ;\r\nbreak;\r\ncase 0x30:\r\npll2 = 192 * MHZ;\r\nbreak;\r\n}\r\nsdclk0 = (misct & (1<<12)) ? pll2 : 288 * MHZ;\r\nsdclk0 /= div_tab[((misct >> 8) & 0xf)];\r\nsdclk1 = (misct & (1<<20)) ? pll2 : 288 * MHZ;\r\nsdclk1 /= div_tab[((misct >> 16) & 0xf)];\r\ndev_dbg(sm->dev, "MISCT=%08lx, PM0=%08lx, PM1=%08lx\n",\r\nmisct, pm0, pm1);\r\ndev_dbg(sm->dev, "PLL2 = %ld.%ld MHz (%ld), SDCLK0=%08lx, SDCLK1=%08lx\n",\r\nfmt_freq(pll2), sdclk0, sdclk1);\r\ndev_dbg(sm->dev, "SDRAM: PM0=%ld, PM1=%ld\n", sdclk0, sdclk1);\r\ndev_dbg(sm->dev, "PM0[%c]: "\r\n"P2 %ld.%ld MHz (%ld), V2 %ld.%ld (%ld), "\r\n"M %ld.%ld (%ld), MX1 %ld.%ld (%ld)\n",\r\n(pmc & 3 ) == 0 ? '*' : '-',\r\nfmt_freq(decode_div(pll2, pm0, 24, 1<<29, 31)),\r\nfmt_freq(decode_div(pll2, pm0, 16, 1<<20, 15)),\r\nfmt_freq(decode_div(pll2, pm0, 8, 1<<12, 15)),\r\nfmt_freq(decode_div(pll2, pm0, 0, 1<<4, 15)));\r\ndev_dbg(sm->dev, "PM1[%c]: "\r\n"P2 %ld.%ld MHz (%ld), V2 %ld.%ld (%ld), "\r\n"M %ld.%ld (%ld), MX1 %ld.%ld (%ld)\n",\r\n(pmc & 3 ) == 1 ? '*' : '-',\r\nfmt_freq(decode_div(pll2, pm1, 24, 1<<29, 31)),\r\nfmt_freq(decode_div(pll2, pm1, 16, 1<<20, 15)),\r\nfmt_freq(decode_div(pll2, pm1, 8, 1<<12, 15)),\r\nfmt_freq(decode_div(pll2, pm1, 0, 1<<4, 15)));\r\n}\r\nstatic void sm501_dump_regs(struct sm501_devdata *sm)\r\n{\r\nvoid __iomem *regs = sm->regs;\r\ndev_info(sm->dev, "System Control %08x\n",\r\nsmc501_readl(regs + SM501_SYSTEM_CONTROL));\r\ndev_info(sm->dev, "Misc Control %08x\n",\r\nsmc501_readl(regs + SM501_MISC_CONTROL));\r\ndev_info(sm->dev, "GPIO Control Low %08x\n",\r\nsmc501_readl(regs + SM501_GPIO31_0_CONTROL));\r\ndev_info(sm->dev, "GPIO Control Hi %08x\n",\r\nsmc501_readl(regs + SM501_GPIO63_32_CONTROL));\r\ndev_info(sm->dev, "DRAM Control %08x\n",\r\nsmc501_readl(regs + SM501_DRAM_CONTROL));\r\ndev_info(sm->dev, "Arbitration Ctrl %08x\n",\r\nsmc501_readl(regs + SM501_ARBTRTN_CONTROL));\r\ndev_info(sm->dev, "Misc Timing %08x\n",\r\nsmc501_readl(regs + SM501_MISC_TIMING));\r\n}\r\nstatic void sm501_dump_gate(struct sm501_devdata *sm)\r\n{\r\ndev_info(sm->dev, "CurrentGate %08x\n",\r\nsmc501_readl(sm->regs + SM501_CURRENT_GATE));\r\ndev_info(sm->dev, "CurrentClock %08x\n",\r\nsmc501_readl(sm->regs + SM501_CURRENT_CLOCK));\r\ndev_info(sm->dev, "PowerModeControl %08x\n",\r\nsmc501_readl(sm->regs + SM501_POWER_MODE_CONTROL));\r\n}\r\nstatic inline void sm501_dump_gate(struct sm501_devdata *sm) { }\r\nstatic inline void sm501_dump_regs(struct sm501_devdata *sm) { }\r\nstatic inline void sm501_dump_clk(struct sm501_devdata *sm) { }\r\nstatic void sm501_sync_regs(struct sm501_devdata *sm)\r\n{\r\nsmc501_readl(sm->regs);\r\n}\r\nstatic inline void sm501_mdelay(struct sm501_devdata *sm, unsigned int delay)\r\n{\r\nif (sm->in_suspend)\r\nmdelay(delay);\r\nelse\r\nmsleep(delay);\r\n}\r\nint sm501_misc_control(struct device *dev,\r\nunsigned long set, unsigned long clear)\r\n{\r\nstruct sm501_devdata *sm = dev_get_drvdata(dev);\r\nunsigned long misc;\r\nunsigned long save;\r\nunsigned long to;\r\nspin_lock_irqsave(&sm->reg_lock, save);\r\nmisc = smc501_readl(sm->regs + SM501_MISC_CONTROL);\r\nto = (misc & ~clear) | set;\r\nif (to != misc) {\r\nsmc501_writel(to, sm->regs + SM501_MISC_CONTROL);\r\nsm501_sync_regs(sm);\r\ndev_dbg(sm->dev, "MISC_CONTROL %08lx\n", misc);\r\n}\r\nspin_unlock_irqrestore(&sm->reg_lock, save);\r\nreturn to;\r\n}\r\nunsigned long sm501_modify_reg(struct device *dev,\r\nunsigned long reg,\r\nunsigned long set,\r\nunsigned long clear)\r\n{\r\nstruct sm501_devdata *sm = dev_get_drvdata(dev);\r\nunsigned long data;\r\nunsigned long save;\r\nspin_lock_irqsave(&sm->reg_lock, save);\r\ndata = smc501_readl(sm->regs + reg);\r\ndata |= set;\r\ndata &= ~clear;\r\nsmc501_writel(data, sm->regs + reg);\r\nsm501_sync_regs(sm);\r\nspin_unlock_irqrestore(&sm->reg_lock, save);\r\nreturn data;\r\n}\r\nint sm501_unit_power(struct device *dev, unsigned int unit, unsigned int to)\r\n{\r\nstruct sm501_devdata *sm = dev_get_drvdata(dev);\r\nunsigned long mode;\r\nunsigned long gate;\r\nunsigned long clock;\r\nmutex_lock(&sm->clock_lock);\r\nmode = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\r\ngate = smc501_readl(sm->regs + SM501_CURRENT_GATE);\r\nclock = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\r\nmode &= 3;\r\nif (unit >= ARRAY_SIZE(sm->unit_power)) {\r\ndev_err(dev, "%s: bad unit %d\n", __func__, unit);\r\ngoto already;\r\n}\r\ndev_dbg(sm->dev, "%s: unit %d, cur %d, to %d\n", __func__, unit,\r\nsm->unit_power[unit], to);\r\nif (to == 0 && sm->unit_power[unit] == 0) {\r\ndev_err(sm->dev, "unit %d is already shutdown\n", unit);\r\ngoto already;\r\n}\r\nsm->unit_power[unit] += to ? 1 : -1;\r\nto = sm->unit_power[unit] ? 1 : 0;\r\nif (to) {\r\nif (gate & (1 << unit))\r\ngoto already;\r\ngate |= (1 << unit);\r\n} else {\r\nif (!(gate & (1 << unit)))\r\ngoto already;\r\ngate &= ~(1 << unit);\r\n}\r\nswitch (mode) {\r\ncase 1:\r\nsmc501_writel(gate, sm->regs + SM501_POWER_MODE_0_GATE);\r\nsmc501_writel(clock, sm->regs + SM501_POWER_MODE_0_CLOCK);\r\nmode = 0;\r\nbreak;\r\ncase 2:\r\ncase 0:\r\nsmc501_writel(gate, sm->regs + SM501_POWER_MODE_1_GATE);\r\nsmc501_writel(clock, sm->regs + SM501_POWER_MODE_1_CLOCK);\r\nmode = 1;\r\nbreak;\r\ndefault:\r\ngate = -1;\r\ngoto already;\r\n}\r\nsmc501_writel(mode, sm->regs + SM501_POWER_MODE_CONTROL);\r\nsm501_sync_regs(sm);\r\ndev_dbg(sm->dev, "gate %08lx, clock %08lx, mode %08lx\n",\r\ngate, clock, mode);\r\nsm501_mdelay(sm, 16);\r\nalready:\r\nmutex_unlock(&sm->clock_lock);\r\nreturn gate;\r\n}\r\nstatic long sm501fb_round_div(long num, long denom)\r\n{\r\nreturn (2 * num + denom) / (2 * denom);\r\n}\r\nstatic int sm501_calc_clock(unsigned long freq,\r\nstruct sm501_clock *clock,\r\nint max_div,\r\nunsigned long mclk,\r\nlong *best_diff)\r\n{\r\nint ret = 0;\r\nint divider;\r\nint shift;\r\nlong diff;\r\nfor (divider = 1; divider <= max_div; divider += 2) {\r\nfor (shift = 0; shift < 8; shift++) {\r\ndiff = sm501fb_round_div(mclk, divider << shift) - freq;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff < *best_diff) {\r\n*best_diff = diff;\r\nclock->mclk = mclk;\r\nclock->divider = divider;\r\nclock->shift = shift;\r\nret = 1;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned long sm501_calc_pll(unsigned long freq,\r\nstruct sm501_clock *clock,\r\nint max_div)\r\n{\r\nunsigned long mclk;\r\nunsigned int m, n, k;\r\nlong best_diff = 999999999;\r\nfor (m = 2; m <= 255; m++) {\r\nfor (n = 2; n <= 127; n++) {\r\nfor (k = 0; k <= 1; k++) {\r\nmclk = (24000000UL * m / n) >> k;\r\nif (sm501_calc_clock(freq, clock, max_div,\r\nmclk, &best_diff)) {\r\nclock->m = m;\r\nclock->n = n;\r\nclock->k = k;\r\n}\r\n}\r\n}\r\n}\r\nreturn clock->mclk / (clock->divider << clock->shift);\r\n}\r\nstatic unsigned long sm501_select_clock(unsigned long freq,\r\nstruct sm501_clock *clock,\r\nint max_div)\r\n{\r\nunsigned long mclk;\r\nlong best_diff = 999999999;\r\nfor (mclk = 288000000; mclk <= 336000000; mclk += 48000000) {\r\nsm501_calc_clock(freq, clock, max_div, mclk, &best_diff);\r\n}\r\nreturn clock->mclk / (clock->divider << clock->shift);\r\n}\r\nunsigned long sm501_set_clock(struct device *dev,\r\nint clksrc,\r\nunsigned long req_freq)\r\n{\r\nstruct sm501_devdata *sm = dev_get_drvdata(dev);\r\nunsigned long mode = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\r\nunsigned long gate = smc501_readl(sm->regs + SM501_CURRENT_GATE);\r\nunsigned long clock = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\r\nunsigned char reg;\r\nunsigned int pll_reg = 0;\r\nunsigned long sm501_freq;\r\nstruct sm501_clock to;\r\nswitch (clksrc) {\r\ncase SM501_CLOCK_P2XCLK:\r\nif (sm->rev >= 0xC0) {\r\nsm501_freq = (sm501_calc_pll(2 * req_freq,\r\n&to, 5) / 2);\r\nreg = to.shift & 0x07;\r\nif (to.divider == 3)\r\nreg |= 0x08;\r\nelse if (to.divider == 5)\r\nreg |= 0x10;\r\nreg |= 0x40;\r\npll_reg = 0x20000 | (to.k << 15) | (to.n << 8) | to.m;\r\n} else {\r\nsm501_freq = (sm501_select_clock(2 * req_freq,\r\n&to, 5) / 2);\r\nreg = to.shift & 0x07;\r\nif (to.divider == 3)\r\nreg |= 0x08;\r\nelse if (to.divider == 5)\r\nreg |= 0x10;\r\nif (to.mclk != 288000000)\r\nreg |= 0x20;\r\n}\r\nbreak;\r\ncase SM501_CLOCK_V2XCLK:\r\nsm501_freq = (sm501_select_clock(2 * req_freq, &to, 3) / 2);\r\nreg=to.shift & 0x07;\r\nif (to.divider == 3)\r\nreg |= 0x08;\r\nif (to.mclk != 288000000)\r\nreg |= 0x10;\r\nbreak;\r\ncase SM501_CLOCK_MCLK:\r\ncase SM501_CLOCK_M1XCLK:\r\nsm501_freq = sm501_select_clock( req_freq, &to, 3);\r\nreg=to.shift & 0x07;\r\nif (to.divider == 3)\r\nreg |= 0x08;\r\nif (to.mclk != 288000000)\r\nreg |= 0x10;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmutex_lock(&sm->clock_lock);\r\nmode = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\r\ngate = smc501_readl(sm->regs + SM501_CURRENT_GATE);\r\nclock = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\r\nclock = clock & ~(0xFF << clksrc);\r\nclock |= reg<<clksrc;\r\nmode &= 3;\r\nswitch (mode) {\r\ncase 1:\r\nsmc501_writel(gate, sm->regs + SM501_POWER_MODE_0_GATE);\r\nsmc501_writel(clock, sm->regs + SM501_POWER_MODE_0_CLOCK);\r\nmode = 0;\r\nbreak;\r\ncase 2:\r\ncase 0:\r\nsmc501_writel(gate, sm->regs + SM501_POWER_MODE_1_GATE);\r\nsmc501_writel(clock, sm->regs + SM501_POWER_MODE_1_CLOCK);\r\nmode = 1;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&sm->clock_lock);\r\nreturn -1;\r\n}\r\nsmc501_writel(mode, sm->regs + SM501_POWER_MODE_CONTROL);\r\nif (pll_reg)\r\nsmc501_writel(pll_reg,\r\nsm->regs + SM501_PROGRAMMABLE_PLL_CONTROL);\r\nsm501_sync_regs(sm);\r\ndev_dbg(sm->dev, "gate %08lx, clock %08lx, mode %08lx\n",\r\ngate, clock, mode);\r\nsm501_mdelay(sm, 16);\r\nmutex_unlock(&sm->clock_lock);\r\nsm501_dump_clk(sm);\r\nreturn sm501_freq;\r\n}\r\nunsigned long sm501_find_clock(struct device *dev,\r\nint clksrc,\r\nunsigned long req_freq)\r\n{\r\nstruct sm501_devdata *sm = dev_get_drvdata(dev);\r\nunsigned long sm501_freq;\r\nstruct sm501_clock to;\r\nswitch (clksrc) {\r\ncase SM501_CLOCK_P2XCLK:\r\nif (sm->rev >= 0xC0) {\r\nsm501_freq = (sm501_calc_pll(2 * req_freq,\r\n&to, 5) / 2);\r\n} else {\r\nsm501_freq = (sm501_select_clock(2 * req_freq,\r\n&to, 5) / 2);\r\n}\r\nbreak;\r\ncase SM501_CLOCK_V2XCLK:\r\nsm501_freq = (sm501_select_clock(2 * req_freq, &to, 3) / 2);\r\nbreak;\r\ncase SM501_CLOCK_MCLK:\r\ncase SM501_CLOCK_M1XCLK:\r\nsm501_freq = sm501_select_clock(req_freq, &to, 3);\r\nbreak;\r\ndefault:\r\nsm501_freq = 0;\r\n}\r\nreturn sm501_freq;\r\n}\r\nstatic struct sm501_device *to_sm_device(struct platform_device *pdev)\r\n{\r\nreturn container_of(pdev, struct sm501_device, pdev);\r\n}\r\nstatic void sm501_device_release(struct device *dev)\r\n{\r\nkfree(to_sm_device(to_platform_device(dev)));\r\n}\r\nstatic struct platform_device *\r\nsm501_create_subdev(struct sm501_devdata *sm, char *name,\r\nunsigned int res_count, unsigned int platform_data_size)\r\n{\r\nstruct sm501_device *smdev;\r\nsmdev = kzalloc(sizeof(struct sm501_device) +\r\n(sizeof(struct resource) * res_count) +\r\nplatform_data_size, GFP_KERNEL);\r\nif (!smdev)\r\nreturn NULL;\r\nsmdev->pdev.dev.release = sm501_device_release;\r\nsmdev->pdev.name = name;\r\nsmdev->pdev.id = sm->pdev_id;\r\nsmdev->pdev.dev.parent = sm->dev;\r\nif (res_count) {\r\nsmdev->pdev.resource = (struct resource *)(smdev+1);\r\nsmdev->pdev.num_resources = res_count;\r\n}\r\nif (platform_data_size)\r\nsmdev->pdev.dev.platform_data = (void *)(smdev+1);\r\nreturn &smdev->pdev;\r\n}\r\nstatic int sm501_register_device(struct sm501_devdata *sm,\r\nstruct platform_device *pdev)\r\n{\r\nstruct sm501_device *smdev = to_sm_device(pdev);\r\nint ptr;\r\nint ret;\r\nfor (ptr = 0; ptr < pdev->num_resources; ptr++) {\r\nprintk(KERN_DEBUG "%s[%d] %pR\n",\r\npdev->name, ptr, &pdev->resource[ptr]);\r\n}\r\nret = platform_device_register(pdev);\r\nif (ret >= 0) {\r\ndev_dbg(sm->dev, "registered %s\n", pdev->name);\r\nlist_add_tail(&smdev->list, &sm->devices);\r\n} else\r\ndev_err(sm->dev, "error registering %s (%d)\n",\r\npdev->name, ret);\r\nreturn ret;\r\n}\r\nstatic void sm501_create_subio(struct sm501_devdata *sm,\r\nstruct resource *res,\r\nresource_size_t offs,\r\nresource_size_t size)\r\n{\r\nres->flags = IORESOURCE_MEM;\r\nres->parent = sm->io_res;\r\nres->start = sm->io_res->start + offs;\r\nres->end = res->start + size - 1;\r\n}\r\nstatic void sm501_create_mem(struct sm501_devdata *sm,\r\nstruct resource *res,\r\nresource_size_t *offs,\r\nresource_size_t size)\r\n{\r\n*offs -= size;\r\nres->flags = IORESOURCE_MEM;\r\nres->parent = sm->mem_res;\r\nres->start = sm->mem_res->start + *offs;\r\nres->end = res->start + size - 1;\r\n}\r\nstatic void sm501_create_irq(struct sm501_devdata *sm,\r\nstruct resource *res)\r\n{\r\nres->flags = IORESOURCE_IRQ;\r\nres->parent = NULL;\r\nres->start = res->end = sm->irq;\r\n}\r\nstatic int sm501_register_usbhost(struct sm501_devdata *sm,\r\nresource_size_t *mem_avail)\r\n{\r\nstruct platform_device *pdev;\r\npdev = sm501_create_subdev(sm, "sm501-usb", 3, 0);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nsm501_create_subio(sm, &pdev->resource[0], 0x40000, 0x20000);\r\nsm501_create_mem(sm, &pdev->resource[1], mem_avail, 256*1024);\r\nsm501_create_irq(sm, &pdev->resource[2]);\r\nreturn sm501_register_device(sm, pdev);\r\n}\r\nstatic void sm501_setup_uart_data(struct sm501_devdata *sm,\r\nstruct plat_serial8250_port *uart_data,\r\nunsigned int offset)\r\n{\r\nuart_data->membase = sm->regs + offset;\r\nuart_data->mapbase = sm->io_res->start + offset;\r\nuart_data->iotype = UPIO_MEM;\r\nuart_data->irq = sm->irq;\r\nuart_data->flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_SHARE_IRQ;\r\nuart_data->regshift = 2;\r\nuart_data->uartclk = (9600 * 16);\r\n}\r\nstatic int sm501_register_uart(struct sm501_devdata *sm, int devices)\r\n{\r\nstruct platform_device *pdev;\r\nstruct plat_serial8250_port *uart_data;\r\npdev = sm501_create_subdev(sm, "serial8250", 0,\r\nsizeof(struct plat_serial8250_port) * 3);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nuart_data = pdev->dev.platform_data;\r\nif (devices & SM501_USE_UART0) {\r\nsm501_setup_uart_data(sm, uart_data++, 0x30000);\r\nsm501_unit_power(sm->dev, SM501_GATE_UART0, 1);\r\nsm501_modify_reg(sm->dev, SM501_IRQ_MASK, 1 << 12, 0);\r\nsm501_modify_reg(sm->dev, SM501_GPIO63_32_CONTROL, 0x01e0, 0);\r\n}\r\nif (devices & SM501_USE_UART1) {\r\nsm501_setup_uart_data(sm, uart_data++, 0x30020);\r\nsm501_unit_power(sm->dev, SM501_GATE_UART1, 1);\r\nsm501_modify_reg(sm->dev, SM501_IRQ_MASK, 1 << 13, 0);\r\nsm501_modify_reg(sm->dev, SM501_GPIO63_32_CONTROL, 0x1e00, 0);\r\n}\r\npdev->id = PLAT8250_DEV_SM501;\r\nreturn sm501_register_device(sm, pdev);\r\n}\r\nstatic int sm501_register_display(struct sm501_devdata *sm,\r\nresource_size_t *mem_avail)\r\n{\r\nstruct platform_device *pdev;\r\npdev = sm501_create_subdev(sm, "sm501-fb", 4, 0);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nsm501_create_subio(sm, &pdev->resource[0], 0x80000, 0x10000);\r\nsm501_create_subio(sm, &pdev->resource[1], 0x100000, 0x50000);\r\nsm501_create_mem(sm, &pdev->resource[2], mem_avail, *mem_avail);\r\nsm501_create_irq(sm, &pdev->resource[3]);\r\nreturn sm501_register_device(sm, pdev);\r\n}\r\nstatic inline struct sm501_gpio_chip *to_sm501_gpio(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct sm501_gpio_chip, gpio);\r\n}\r\nstatic inline struct sm501_devdata *sm501_gpio_to_dev(struct sm501_gpio *gpio)\r\n{\r\nreturn container_of(gpio, struct sm501_devdata, gpio);\r\n}\r\nstatic int sm501_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sm501_gpio_chip *smgpio = to_sm501_gpio(chip);\r\nunsigned long result;\r\nresult = smc501_readl(smgpio->regbase + SM501_GPIO_DATA_LOW);\r\nresult >>= offset;\r\nreturn result & 1UL;\r\n}\r\nstatic void sm501_gpio_ensure_gpio(struct sm501_gpio_chip *smchip,\r\nunsigned long bit)\r\n{\r\nunsigned long ctrl;\r\nif (smc501_readl(smchip->control) & bit) {\r\ndev_info(sm501_gpio_to_dev(smchip->ourgpio)->dev,\r\n"changing mode of gpio, bit %08lx\n", bit);\r\nctrl = smc501_readl(smchip->control);\r\nctrl &= ~bit;\r\nsmc501_writel(ctrl, smchip->control);\r\nsm501_sync_regs(sm501_gpio_to_dev(smchip->ourgpio));\r\n}\r\n}\r\nstatic void sm501_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct sm501_gpio_chip *smchip = to_sm501_gpio(chip);\r\nstruct sm501_gpio *smgpio = smchip->ourgpio;\r\nunsigned long bit = 1 << offset;\r\nvoid __iomem *regs = smchip->regbase;\r\nunsigned long save;\r\nunsigned long val;\r\ndev_dbg(sm501_gpio_to_dev(smgpio)->dev, "%s(%p,%d)\n",\r\n__func__, chip, offset);\r\nspin_lock_irqsave(&smgpio->lock, save);\r\nval = smc501_readl(regs + SM501_GPIO_DATA_LOW) & ~bit;\r\nif (value)\r\nval |= bit;\r\nsmc501_writel(val, regs);\r\nsm501_sync_regs(sm501_gpio_to_dev(smgpio));\r\nsm501_gpio_ensure_gpio(smchip, bit);\r\nspin_unlock_irqrestore(&smgpio->lock, save);\r\n}\r\nstatic int sm501_gpio_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sm501_gpio_chip *smchip = to_sm501_gpio(chip);\r\nstruct sm501_gpio *smgpio = smchip->ourgpio;\r\nvoid __iomem *regs = smchip->regbase;\r\nunsigned long bit = 1 << offset;\r\nunsigned long save;\r\nunsigned long ddr;\r\ndev_dbg(sm501_gpio_to_dev(smgpio)->dev, "%s(%p,%d)\n",\r\n__func__, chip, offset);\r\nspin_lock_irqsave(&smgpio->lock, save);\r\nddr = smc501_readl(regs + SM501_GPIO_DDR_LOW);\r\nsmc501_writel(ddr & ~bit, regs + SM501_GPIO_DDR_LOW);\r\nsm501_sync_regs(sm501_gpio_to_dev(smgpio));\r\nsm501_gpio_ensure_gpio(smchip, bit);\r\nspin_unlock_irqrestore(&smgpio->lock, save);\r\nreturn 0;\r\n}\r\nstatic int sm501_gpio_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct sm501_gpio_chip *smchip = to_sm501_gpio(chip);\r\nstruct sm501_gpio *smgpio = smchip->ourgpio;\r\nunsigned long bit = 1 << offset;\r\nvoid __iomem *regs = smchip->regbase;\r\nunsigned long save;\r\nunsigned long val;\r\nunsigned long ddr;\r\ndev_dbg(sm501_gpio_to_dev(smgpio)->dev, "%s(%p,%d,%d)\n",\r\n__func__, chip, offset, value);\r\nspin_lock_irqsave(&smgpio->lock, save);\r\nval = smc501_readl(regs + SM501_GPIO_DATA_LOW);\r\nif (value)\r\nval |= bit;\r\nelse\r\nval &= ~bit;\r\nsmc501_writel(val, regs);\r\nddr = smc501_readl(regs + SM501_GPIO_DDR_LOW);\r\nsmc501_writel(ddr | bit, regs + SM501_GPIO_DDR_LOW);\r\nsm501_sync_regs(sm501_gpio_to_dev(smgpio));\r\nsmc501_writel(val, regs + SM501_GPIO_DATA_LOW);\r\nsm501_sync_regs(sm501_gpio_to_dev(smgpio));\r\nspin_unlock_irqrestore(&smgpio->lock, save);\r\nreturn 0;\r\n}\r\nstatic int __devinit sm501_gpio_register_chip(struct sm501_devdata *sm,\r\nstruct sm501_gpio *gpio,\r\nstruct sm501_gpio_chip *chip)\r\n{\r\nstruct sm501_platdata *pdata = sm->platdata;\r\nstruct gpio_chip *gchip = &chip->gpio;\r\nint base = pdata->gpio_base;\r\nchip->gpio = gpio_chip_template;\r\nif (chip == &gpio->high) {\r\nif (base > 0)\r\nbase += 32;\r\nchip->regbase = gpio->regs + SM501_GPIO_DATA_HIGH;\r\nchip->control = sm->regs + SM501_GPIO63_32_CONTROL;\r\ngchip->label = "SM501-HIGH";\r\n} else {\r\nchip->regbase = gpio->regs + SM501_GPIO_DATA_LOW;\r\nchip->control = sm->regs + SM501_GPIO31_0_CONTROL;\r\ngchip->label = "SM501-LOW";\r\n}\r\ngchip->base = base;\r\nchip->ourgpio = gpio;\r\nreturn gpiochip_add(gchip);\r\n}\r\nstatic int __devinit sm501_register_gpio(struct sm501_devdata *sm)\r\n{\r\nstruct sm501_gpio *gpio = &sm->gpio;\r\nresource_size_t iobase = sm->io_res->start + SM501_GPIO;\r\nint ret;\r\nint tmp;\r\ndev_dbg(sm->dev, "registering gpio block %08llx\n",\r\n(unsigned long long)iobase);\r\nspin_lock_init(&gpio->lock);\r\ngpio->regs_res = request_mem_region(iobase, 0x20, "sm501-gpio");\r\nif (gpio->regs_res == NULL) {\r\ndev_err(sm->dev, "gpio: failed to request region\n");\r\nreturn -ENXIO;\r\n}\r\ngpio->regs = ioremap(iobase, 0x20);\r\nif (gpio->regs == NULL) {\r\ndev_err(sm->dev, "gpio: failed to remap registers\n");\r\nret = -ENXIO;\r\ngoto err_claimed;\r\n}\r\nret = sm501_gpio_register_chip(sm, gpio, &gpio->low);\r\nif (ret) {\r\ndev_err(sm->dev, "failed to add low chip\n");\r\ngoto err_mapped;\r\n}\r\nret = sm501_gpio_register_chip(sm, gpio, &gpio->high);\r\nif (ret) {\r\ndev_err(sm->dev, "failed to add high chip\n");\r\ngoto err_low_chip;\r\n}\r\ngpio->registered = 1;\r\nreturn 0;\r\nerr_low_chip:\r\ntmp = gpiochip_remove(&gpio->low.gpio);\r\nif (tmp) {\r\ndev_err(sm->dev, "cannot remove low chip, cannot tidy up\n");\r\nreturn ret;\r\n}\r\nerr_mapped:\r\niounmap(gpio->regs);\r\nerr_claimed:\r\nrelease_resource(gpio->regs_res);\r\nkfree(gpio->regs_res);\r\nreturn ret;\r\n}\r\nstatic void sm501_gpio_remove(struct sm501_devdata *sm)\r\n{\r\nstruct sm501_gpio *gpio = &sm->gpio;\r\nint ret;\r\nif (!sm->gpio.registered)\r\nreturn;\r\nret = gpiochip_remove(&gpio->low.gpio);\r\nif (ret)\r\ndev_err(sm->dev, "cannot remove low chip, cannot tidy up\n");\r\nret = gpiochip_remove(&gpio->high.gpio);\r\nif (ret)\r\ndev_err(sm->dev, "cannot remove high chip, cannot tidy up\n");\r\niounmap(gpio->regs);\r\nrelease_resource(gpio->regs_res);\r\nkfree(gpio->regs_res);\r\n}\r\nstatic inline int sm501_gpio_pin2nr(struct sm501_devdata *sm, unsigned int pin)\r\n{\r\nstruct sm501_gpio *gpio = &sm->gpio;\r\nint base = (pin < 32) ? gpio->low.gpio.base : gpio->high.gpio.base;\r\nreturn (pin % 32) + base;\r\n}\r\nstatic inline int sm501_gpio_isregistered(struct sm501_devdata *sm)\r\n{\r\nreturn sm->gpio.registered;\r\n}\r\nstatic inline int sm501_register_gpio(struct sm501_devdata *sm)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void sm501_gpio_remove(struct sm501_devdata *sm)\r\n{\r\n}\r\nstatic inline int sm501_gpio_pin2nr(struct sm501_devdata *sm, unsigned int pin)\r\n{\r\nreturn -1;\r\n}\r\nstatic inline int sm501_gpio_isregistered(struct sm501_devdata *sm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sm501_register_gpio_i2c_instance(struct sm501_devdata *sm,\r\nstruct sm501_platdata_gpio_i2c *iic)\r\n{\r\nstruct i2c_gpio_platform_data *icd;\r\nstruct platform_device *pdev;\r\npdev = sm501_create_subdev(sm, "i2c-gpio", 0,\r\nsizeof(struct i2c_gpio_platform_data));\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nicd = pdev->dev.platform_data;\r\nicd->sda_pin = sm501_gpio_pin2nr(sm, iic->pin_sda);\r\nicd->scl_pin = sm501_gpio_pin2nr(sm, iic->pin_scl);\r\nicd->timeout = iic->timeout;\r\nicd->udelay = iic->udelay;\r\npdev->id = iic->bus_num;\r\ndev_info(sm->dev, "registering i2c-%d: sda=%d (%d), scl=%d (%d)\n",\r\niic->bus_num,\r\nicd->sda_pin, iic->pin_sda, icd->scl_pin, iic->pin_scl);\r\nreturn sm501_register_device(sm, pdev);\r\n}\r\nstatic int sm501_register_gpio_i2c(struct sm501_devdata *sm,\r\nstruct sm501_platdata *pdata)\r\n{\r\nstruct sm501_platdata_gpio_i2c *iic = pdata->gpio_i2c;\r\nint index;\r\nint ret;\r\nfor (index = 0; index < pdata->gpio_i2c_nr; index++, iic++) {\r\nret = sm501_register_gpio_i2c_instance(sm, iic);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t sm501_dbg_regs(struct device *dev,\r\nstruct device_attribute *attr, char *buff)\r\n{\r\nstruct sm501_devdata *sm = dev_get_drvdata(dev) ;\r\nunsigned int reg;\r\nchar *ptr = buff;\r\nint ret;\r\nfor (reg = 0x00; reg < 0x70; reg += 4) {\r\nret = sprintf(ptr, "%08x = %08x\n",\r\nreg, smc501_readl(sm->regs + reg));\r\nptr += ret;\r\n}\r\nreturn ptr - buff;\r\n}\r\nstatic inline void sm501_init_reg(struct sm501_devdata *sm,\r\nunsigned long reg,\r\nstruct sm501_reg_init *r)\r\n{\r\nunsigned long tmp;\r\ntmp = smc501_readl(sm->regs + reg);\r\ntmp &= ~r->mask;\r\ntmp |= r->set;\r\nsmc501_writel(tmp, sm->regs + reg);\r\n}\r\nstatic void sm501_init_regs(struct sm501_devdata *sm,\r\nstruct sm501_initdata *init)\r\n{\r\nsm501_misc_control(sm->dev,\r\ninit->misc_control.set,\r\ninit->misc_control.mask);\r\nsm501_init_reg(sm, SM501_MISC_TIMING, &init->misc_timing);\r\nsm501_init_reg(sm, SM501_GPIO31_0_CONTROL, &init->gpio_low);\r\nsm501_init_reg(sm, SM501_GPIO63_32_CONTROL, &init->gpio_high);\r\nif (init->m1xclk) {\r\ndev_info(sm->dev, "setting M1XCLK to %ld\n", init->m1xclk);\r\nsm501_set_clock(sm->dev, SM501_CLOCK_M1XCLK, init->m1xclk);\r\n}\r\nif (init->mclk) {\r\ndev_info(sm->dev, "setting MCLK to %ld\n", init->mclk);\r\nsm501_set_clock(sm->dev, SM501_CLOCK_MCLK, init->mclk);\r\n}\r\n}\r\nstatic int sm501_check_clocks(struct sm501_devdata *sm)\r\n{\r\nunsigned long pwrmode = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\r\nunsigned long msrc = (pwrmode & SM501_POWERMODE_M_SRC);\r\nunsigned long m1src = (pwrmode & SM501_POWERMODE_M1_SRC);\r\nreturn ((msrc == 0 && m1src != 0) || (msrc != 0 && m1src == 0));\r\n}\r\nstatic int __devinit sm501_init_dev(struct sm501_devdata *sm)\r\n{\r\nstruct sm501_initdata *idata;\r\nstruct sm501_platdata *pdata;\r\nresource_size_t mem_avail;\r\nunsigned long dramctrl;\r\nunsigned long devid;\r\nint ret;\r\nmutex_init(&sm->clock_lock);\r\nspin_lock_init(&sm->reg_lock);\r\nINIT_LIST_HEAD(&sm->devices);\r\ndevid = smc501_readl(sm->regs + SM501_DEVICEID);\r\nif ((devid & SM501_DEVICEID_IDMASK) != SM501_DEVICEID_SM501) {\r\ndev_err(sm->dev, "incorrect device id %08lx\n", devid);\r\nreturn -EINVAL;\r\n}\r\nsmc501_writel(0, sm->regs + SM501_IRQ_MASK);\r\ndramctrl = smc501_readl(sm->regs + SM501_DRAM_CONTROL);\r\nmem_avail = sm501_mem_local[(dramctrl >> 13) & 0x7];\r\ndev_info(sm->dev, "SM501 At %p: Version %08lx, %ld Mb, IRQ %d\n",\r\nsm->regs, devid, (unsigned long)mem_avail >> 20, sm->irq);\r\nsm->rev = devid & SM501_DEVICEID_REVMASK;\r\nsm501_dump_gate(sm);\r\nret = device_create_file(sm->dev, &dev_attr_dbg_regs);\r\nif (ret)\r\ndev_err(sm->dev, "failed to create debug regs file\n");\r\nsm501_dump_clk(sm);\r\npdata = sm->platdata;\r\nidata = pdata ? pdata->init : NULL;\r\nif (idata) {\r\nsm501_init_regs(sm, idata);\r\nif (idata->devices & SM501_USE_USB_HOST)\r\nsm501_register_usbhost(sm, &mem_avail);\r\nif (idata->devices & (SM501_USE_UART0 | SM501_USE_UART1))\r\nsm501_register_uart(sm, idata->devices);\r\nif (idata->devices & SM501_USE_GPIO)\r\nsm501_register_gpio(sm);\r\n}\r\nif (pdata && pdata->gpio_i2c != NULL && pdata->gpio_i2c_nr > 0) {\r\nif (!sm501_gpio_isregistered(sm))\r\ndev_err(sm->dev, "no gpio available for i2c gpio.\n");\r\nelse\r\nsm501_register_gpio_i2c(sm, pdata);\r\n}\r\nret = sm501_check_clocks(sm);\r\nif (ret) {\r\ndev_err(sm->dev, "M1X and M clocks sourced from different "\r\n"PLLs\n");\r\nreturn -EINVAL;\r\n}\r\nsm501_register_display(sm, &mem_avail);\r\nreturn 0;\r\n}\r\nstatic int __devinit sm501_plat_probe(struct platform_device *dev)\r\n{\r\nstruct sm501_devdata *sm;\r\nint ret;\r\nsm = kzalloc(sizeof(struct sm501_devdata), GFP_KERNEL);\r\nif (sm == NULL) {\r\ndev_err(&dev->dev, "no memory for device data\n");\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nsm->dev = &dev->dev;\r\nsm->pdev_id = dev->id;\r\nsm->platdata = dev->dev.platform_data;\r\nret = platform_get_irq(dev, 0);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "failed to get irq resource\n");\r\ngoto err_res;\r\n}\r\nsm->irq = ret;\r\nsm->io_res = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nsm->mem_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (sm->io_res == NULL || sm->mem_res == NULL) {\r\ndev_err(&dev->dev, "failed to get IO resource\n");\r\nret = -ENOENT;\r\ngoto err_res;\r\n}\r\nsm->regs_claim = request_mem_region(sm->io_res->start,\r\n0x100, "sm501");\r\nif (sm->regs_claim == NULL) {\r\ndev_err(&dev->dev, "cannot claim registers\n");\r\nret = -EBUSY;\r\ngoto err_res;\r\n}\r\nplatform_set_drvdata(dev, sm);\r\nsm->regs = ioremap(sm->io_res->start, resource_size(sm->io_res));\r\nif (sm->regs == NULL) {\r\ndev_err(&dev->dev, "cannot remap registers\n");\r\nret = -EIO;\r\ngoto err_claim;\r\n}\r\nreturn sm501_init_dev(sm);\r\nerr_claim:\r\nrelease_resource(sm->regs_claim);\r\nkfree(sm->regs_claim);\r\nerr_res:\r\nkfree(sm);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic void sm501_set_power(struct sm501_devdata *sm, int on)\r\n{\r\nstruct sm501_platdata *pd = sm->platdata;\r\nif (pd == NULL)\r\nreturn;\r\nif (pd->get_power) {\r\nif (pd->get_power(sm->dev) == on) {\r\ndev_dbg(sm->dev, "is already %d\n", on);\r\nreturn;\r\n}\r\n}\r\nif (pd->set_power) {\r\ndev_dbg(sm->dev, "setting power to %d\n", on);\r\npd->set_power(sm->dev, on);\r\nsm501_mdelay(sm, 10);\r\n}\r\n}\r\nstatic int sm501_plat_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct sm501_devdata *sm = platform_get_drvdata(pdev);\r\nsm->in_suspend = 1;\r\nsm->pm_misc = smc501_readl(sm->regs + SM501_MISC_CONTROL);\r\nsm501_dump_regs(sm);\r\nif (sm->platdata) {\r\nif (sm->platdata->flags & SM501_FLAG_SUSPEND_OFF)\r\nsm501_set_power(sm, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sm501_plat_resume(struct platform_device *pdev)\r\n{\r\nstruct sm501_devdata *sm = platform_get_drvdata(pdev);\r\nsm501_set_power(sm, 1);\r\nsm501_dump_regs(sm);\r\nsm501_dump_gate(sm);\r\nsm501_dump_clk(sm);\r\nif (smc501_readl(sm->regs + SM501_MISC_CONTROL) != sm->pm_misc) {\r\ndev_info(sm->dev, "SM501_MISC_CONTROL changed over sleep\n");\r\nsmc501_writel(sm->pm_misc, sm->regs + SM501_MISC_CONTROL);\r\nif (sm->platdata && sm->platdata->init) {\r\nsm501_init_regs(sm, sm->platdata->init);\r\n}\r\n}\r\nsm501_dump_regs(sm);\r\nsm501_dump_clk(sm);\r\nsm->in_suspend = 0;\r\nreturn 0;\r\n}\r\nstatic int __devinit sm501_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct sm501_devdata *sm;\r\nint err;\r\nsm = kzalloc(sizeof(struct sm501_devdata), GFP_KERNEL);\r\nif (sm == NULL) {\r\ndev_err(&dev->dev, "no memory for device data\n");\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\ndev->dev.platform_data = sm->platdata = &sm501_pci_platdata;\r\nsm->pdev_id = 32 + dev->devfn;\r\npci_set_drvdata(dev, sm);\r\nerr = pci_enable_device(dev);\r\nif (err) {\r\ndev_err(&dev->dev, "cannot enable device\n");\r\ngoto err2;\r\n}\r\nsm->dev = &dev->dev;\r\nsm->irq = dev->irq;\r\n#ifdef __BIG_ENDIAN\r\nsm501_fb_pdata.flags |= SM501_FBPD_SWAP_FB_ENDIAN;\r\n#endif\r\nif (!(pci_resource_flags(dev, 0) & IORESOURCE_MEM)) {\r\ndev_err(&dev->dev, "region #0 is not memory?\n");\r\nerr = -EINVAL;\r\ngoto err3;\r\n}\r\nif (!(pci_resource_flags(dev, 1) & IORESOURCE_MEM)) {\r\ndev_err(&dev->dev, "region #1 is not memory?\n");\r\nerr = -EINVAL;\r\ngoto err3;\r\n}\r\nsm->io_res = &dev->resource[1];\r\nsm->mem_res = &dev->resource[0];\r\nsm->regs_claim = request_mem_region(sm->io_res->start,\r\n0x100, "sm501");\r\nif (sm->regs_claim == NULL) {\r\ndev_err(&dev->dev, "cannot claim registers\n");\r\nerr= -EBUSY;\r\ngoto err3;\r\n}\r\nsm->regs = pci_ioremap_bar(dev, 1);\r\nif (sm->regs == NULL) {\r\ndev_err(&dev->dev, "cannot remap registers\n");\r\nerr = -EIO;\r\ngoto err4;\r\n}\r\nsm501_init_dev(sm);\r\nreturn 0;\r\nerr4:\r\nrelease_resource(sm->regs_claim);\r\nkfree(sm->regs_claim);\r\nerr3:\r\npci_disable_device(dev);\r\nerr2:\r\npci_set_drvdata(dev, NULL);\r\nkfree(sm);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void sm501_remove_sub(struct sm501_devdata *sm,\r\nstruct sm501_device *smdev)\r\n{\r\nlist_del(&smdev->list);\r\nplatform_device_unregister(&smdev->pdev);\r\n}\r\nstatic void sm501_dev_remove(struct sm501_devdata *sm)\r\n{\r\nstruct sm501_device *smdev, *tmp;\r\nlist_for_each_entry_safe(smdev, tmp, &sm->devices, list)\r\nsm501_remove_sub(sm, smdev);\r\ndevice_remove_file(sm->dev, &dev_attr_dbg_regs);\r\nsm501_gpio_remove(sm);\r\n}\r\nstatic void __devexit sm501_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct sm501_devdata *sm = pci_get_drvdata(dev);\r\nsm501_dev_remove(sm);\r\niounmap(sm->regs);\r\nrelease_resource(sm->regs_claim);\r\nkfree(sm->regs_claim);\r\npci_set_drvdata(dev, NULL);\r\npci_disable_device(dev);\r\n}\r\nstatic int sm501_plat_remove(struct platform_device *dev)\r\n{\r\nstruct sm501_devdata *sm = platform_get_drvdata(dev);\r\nsm501_dev_remove(sm);\r\niounmap(sm->regs);\r\nrelease_resource(sm->regs_claim);\r\nkfree(sm->regs_claim);\r\nreturn 0;\r\n}\r\nstatic int __init sm501_base_init(void)\r\n{\r\nplatform_driver_register(&sm501_plat_driver);\r\nreturn pci_register_driver(&sm501_pci_driver);\r\n}\r\nstatic void __exit sm501_base_exit(void)\r\n{\r\nplatform_driver_unregister(&sm501_plat_driver);\r\npci_unregister_driver(&sm501_pci_driver);\r\n}
