static int iwl_legacy_eeprom_verify_signature(struct iwl_priv *priv)\r\n{\r\nu32 gp = iwl_read32(priv, CSR_EEPROM_GP) & CSR_EEPROM_GP_VALID_MSK;\r\nint ret = 0;\r\nIWL_DEBUG_EEPROM(priv, "EEPROM signature=0x%08x\n", gp);\r\nswitch (gp) {\r\ncase CSR_EEPROM_GP_GOOD_SIG_EEP_LESS_THAN_4K:\r\ncase CSR_EEPROM_GP_GOOD_SIG_EEP_MORE_THAN_4K:\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "bad EEPROM signature,"\r\n"EEPROM_GP=0x%08x\n", gp);\r\nret = -ENOENT;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nconst u8\r\n*iwl_legacy_eeprom_query_addr(const struct iwl_priv *priv, size_t offset)\r\n{\r\nBUG_ON(offset >= priv->cfg->base_params->eeprom_size);\r\nreturn &priv->eeprom[offset];\r\n}\r\nu16 iwl_legacy_eeprom_query16(const struct iwl_priv *priv, size_t offset)\r\n{\r\nif (!priv->eeprom)\r\nreturn 0;\r\nreturn (u16)priv->eeprom[offset] | ((u16)priv->eeprom[offset + 1] << 8);\r\n}\r\nint iwl_legacy_eeprom_init(struct iwl_priv *priv)\r\n{\r\n__le16 *e;\r\nu32 gp = iwl_read32(priv, CSR_EEPROM_GP);\r\nint sz;\r\nint ret;\r\nu16 addr;\r\nsz = priv->cfg->base_params->eeprom_size;\r\nIWL_DEBUG_EEPROM(priv, "NVM size = %d\n", sz);\r\npriv->eeprom = kzalloc(sz, GFP_KERNEL);\r\nif (!priv->eeprom) {\r\nret = -ENOMEM;\r\ngoto alloc_err;\r\n}\r\ne = (__le16 *)priv->eeprom;\r\npriv->cfg->ops->lib->apm_ops.init(priv);\r\nret = iwl_legacy_eeprom_verify_signature(priv);\r\nif (ret < 0) {\r\nIWL_ERR(priv, "EEPROM not found, EEPROM_GP=0x%08x\n", gp);\r\nret = -ENOENT;\r\ngoto err;\r\n}\r\nret = priv->cfg->ops->lib->eeprom_ops.acquire_semaphore(priv);\r\nif (ret < 0) {\r\nIWL_ERR(priv, "Failed to acquire EEPROM semaphore.\n");\r\nret = -ENOENT;\r\ngoto err;\r\n}\r\nfor (addr = 0; addr < sz; addr += sizeof(u16)) {\r\nu32 r;\r\n_iwl_legacy_write32(priv, CSR_EEPROM_REG,\r\nCSR_EEPROM_REG_MSK_ADDR & (addr << 1));\r\nret = iwl_poll_bit(priv, CSR_EEPROM_REG,\r\nCSR_EEPROM_REG_READ_VALID_MSK,\r\nCSR_EEPROM_REG_READ_VALID_MSK,\r\nIWL_EEPROM_ACCESS_TIMEOUT);\r\nif (ret < 0) {\r\nIWL_ERR(priv, "Time out reading EEPROM[%d]\n",\r\naddr);\r\ngoto done;\r\n}\r\nr = _iwl_legacy_read_direct32(priv, CSR_EEPROM_REG);\r\ne[addr / 2] = cpu_to_le16(r >> 16);\r\n}\r\nIWL_DEBUG_EEPROM(priv, "NVM Type: %s, version: 0x%x\n",\r\n"EEPROM",\r\niwl_legacy_eeprom_query16(priv, EEPROM_VERSION));\r\nret = 0;\r\ndone:\r\npriv->cfg->ops->lib->eeprom_ops.release_semaphore(priv);\r\nerr:\r\nif (ret)\r\niwl_legacy_eeprom_free(priv);\r\niwl_legacy_apm_stop(priv);\r\nalloc_err:\r\nreturn ret;\r\n}\r\nvoid iwl_legacy_eeprom_free(struct iwl_priv *priv)\r\n{\r\nkfree(priv->eeprom);\r\npriv->eeprom = NULL;\r\n}\r\nstatic void iwl_legacy_init_band_reference(const struct iwl_priv *priv,\r\nint eep_band, int *eeprom_ch_count,\r\nconst struct iwl_eeprom_channel **eeprom_ch_info,\r\nconst u8 **eeprom_ch_index)\r\n{\r\nu32 offset = priv->cfg->ops->lib->\r\neeprom_ops.regulatory_bands[eep_band - 1];\r\nswitch (eep_band) {\r\ncase 1:\r\n*eeprom_ch_count = ARRAY_SIZE(iwlegacy_eeprom_band_1);\r\n*eeprom_ch_info = (struct iwl_eeprom_channel *)\r\niwl_legacy_eeprom_query_addr(priv, offset);\r\n*eeprom_ch_index = iwlegacy_eeprom_band_1;\r\nbreak;\r\ncase 2:\r\n*eeprom_ch_count = ARRAY_SIZE(iwlegacy_eeprom_band_2);\r\n*eeprom_ch_info = (struct iwl_eeprom_channel *)\r\niwl_legacy_eeprom_query_addr(priv, offset);\r\n*eeprom_ch_index = iwlegacy_eeprom_band_2;\r\nbreak;\r\ncase 3:\r\n*eeprom_ch_count = ARRAY_SIZE(iwlegacy_eeprom_band_3);\r\n*eeprom_ch_info = (struct iwl_eeprom_channel *)\r\niwl_legacy_eeprom_query_addr(priv, offset);\r\n*eeprom_ch_index = iwlegacy_eeprom_band_3;\r\nbreak;\r\ncase 4:\r\n*eeprom_ch_count = ARRAY_SIZE(iwlegacy_eeprom_band_4);\r\n*eeprom_ch_info = (struct iwl_eeprom_channel *)\r\niwl_legacy_eeprom_query_addr(priv, offset);\r\n*eeprom_ch_index = iwlegacy_eeprom_band_4;\r\nbreak;\r\ncase 5:\r\n*eeprom_ch_count = ARRAY_SIZE(iwlegacy_eeprom_band_5);\r\n*eeprom_ch_info = (struct iwl_eeprom_channel *)\r\niwl_legacy_eeprom_query_addr(priv, offset);\r\n*eeprom_ch_index = iwlegacy_eeprom_band_5;\r\nbreak;\r\ncase 6:\r\n*eeprom_ch_count = ARRAY_SIZE(iwlegacy_eeprom_band_6);\r\n*eeprom_ch_info = (struct iwl_eeprom_channel *)\r\niwl_legacy_eeprom_query_addr(priv, offset);\r\n*eeprom_ch_index = iwlegacy_eeprom_band_6;\r\nbreak;\r\ncase 7:\r\n*eeprom_ch_count = ARRAY_SIZE(iwlegacy_eeprom_band_7);\r\n*eeprom_ch_info = (struct iwl_eeprom_channel *)\r\niwl_legacy_eeprom_query_addr(priv, offset);\r\n*eeprom_ch_index = iwlegacy_eeprom_band_7;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int iwl_legacy_mod_ht40_chan_info(struct iwl_priv *priv,\r\nenum ieee80211_band band, u16 channel,\r\nconst struct iwl_eeprom_channel *eeprom_ch,\r\nu8 clear_ht40_extension_channel)\r\n{\r\nstruct iwl_channel_info *ch_info;\r\nch_info = (struct iwl_channel_info *)\r\niwl_legacy_get_channel_info(priv, band, channel);\r\nif (!iwl_legacy_is_channel_valid(ch_info))\r\nreturn -1;\r\nIWL_DEBUG_EEPROM(priv, "HT40 Ch. %d [%sGHz] %s%s%s%s%s(0x%02x %ddBm):"\r\n" Ad-Hoc %ssupported\n",\r\nch_info->channel,\r\niwl_legacy_is_channel_a_band(ch_info) ?\r\n"5.2" : "2.4",\r\nCHECK_AND_PRINT(IBSS),\r\nCHECK_AND_PRINT(ACTIVE),\r\nCHECK_AND_PRINT(RADAR),\r\nCHECK_AND_PRINT(WIDE),\r\nCHECK_AND_PRINT(DFS),\r\neeprom_ch->flags,\r\neeprom_ch->max_power_avg,\r\n((eeprom_ch->flags & EEPROM_CHANNEL_IBSS)\r\n&& !(eeprom_ch->flags & EEPROM_CHANNEL_RADAR)) ?\r\n"" : "not ");\r\nch_info->ht40_eeprom = *eeprom_ch;\r\nch_info->ht40_max_power_avg = eeprom_ch->max_power_avg;\r\nch_info->ht40_flags = eeprom_ch->flags;\r\nif (eeprom_ch->flags & EEPROM_CHANNEL_VALID)\r\nch_info->ht40_extension_channel &=\r\n~clear_ht40_extension_channel;\r\nreturn 0;\r\n}\r\nint iwl_legacy_init_channel_map(struct iwl_priv *priv)\r\n{\r\nint eeprom_ch_count = 0;\r\nconst u8 *eeprom_ch_index = NULL;\r\nconst struct iwl_eeprom_channel *eeprom_ch_info = NULL;\r\nint band, ch;\r\nstruct iwl_channel_info *ch_info;\r\nif (priv->channel_count) {\r\nIWL_DEBUG_EEPROM(priv, "Channel map already initialized.\n");\r\nreturn 0;\r\n}\r\nIWL_DEBUG_EEPROM(priv, "Initializing regulatory info from EEPROM\n");\r\npriv->channel_count =\r\nARRAY_SIZE(iwlegacy_eeprom_band_1) +\r\nARRAY_SIZE(iwlegacy_eeprom_band_2) +\r\nARRAY_SIZE(iwlegacy_eeprom_band_3) +\r\nARRAY_SIZE(iwlegacy_eeprom_band_4) +\r\nARRAY_SIZE(iwlegacy_eeprom_band_5);\r\nIWL_DEBUG_EEPROM(priv, "Parsing data for %d channels.\n",\r\npriv->channel_count);\r\npriv->channel_info = kzalloc(sizeof(struct iwl_channel_info) *\r\npriv->channel_count, GFP_KERNEL);\r\nif (!priv->channel_info) {\r\nIWL_ERR(priv, "Could not allocate channel_info\n");\r\npriv->channel_count = 0;\r\nreturn -ENOMEM;\r\n}\r\nch_info = priv->channel_info;\r\nfor (band = 1; band <= 5; band++) {\r\niwl_legacy_init_band_reference(priv, band, &eeprom_ch_count,\r\n&eeprom_ch_info, &eeprom_ch_index);\r\nfor (ch = 0; ch < eeprom_ch_count; ch++) {\r\nch_info->channel = eeprom_ch_index[ch];\r\nch_info->band = (band == 1) ? IEEE80211_BAND_2GHZ :\r\nIEEE80211_BAND_5GHZ;\r\nch_info->eeprom = eeprom_ch_info[ch];\r\nch_info->flags = eeprom_ch_info[ch].flags;\r\nch_info->ht40_extension_channel =\r\nIEEE80211_CHAN_NO_HT40;\r\nif (!(iwl_legacy_is_channel_valid(ch_info))) {\r\nIWL_DEBUG_EEPROM(priv,\r\n"Ch. %d Flags %x [%sGHz] - "\r\n"No traffic\n",\r\nch_info->channel,\r\nch_info->flags,\r\niwl_legacy_is_channel_a_band(ch_info) ?\r\n"5.2" : "2.4");\r\nch_info++;\r\ncontinue;\r\n}\r\nch_info->max_power_avg = ch_info->curr_txpow =\r\neeprom_ch_info[ch].max_power_avg;\r\nch_info->scan_power = eeprom_ch_info[ch].max_power_avg;\r\nch_info->min_power = 0;\r\nIWL_DEBUG_EEPROM(priv, "Ch. %d [%sGHz] "\r\n"%s%s%s%s%s%s(0x%02x %ddBm):"\r\n" Ad-Hoc %ssupported\n",\r\nch_info->channel,\r\niwl_legacy_is_channel_a_band(ch_info) ?\r\n"5.2" : "2.4",\r\nCHECK_AND_PRINT_I(VALID),\r\nCHECK_AND_PRINT_I(IBSS),\r\nCHECK_AND_PRINT_I(ACTIVE),\r\nCHECK_AND_PRINT_I(RADAR),\r\nCHECK_AND_PRINT_I(WIDE),\r\nCHECK_AND_PRINT_I(DFS),\r\neeprom_ch_info[ch].flags,\r\neeprom_ch_info[ch].max_power_avg,\r\n((eeprom_ch_info[ch].\r\nflags & EEPROM_CHANNEL_IBSS)\r\n&& !(eeprom_ch_info[ch].\r\nflags & EEPROM_CHANNEL_RADAR))\r\n? "" : "not ");\r\nch_info++;\r\n}\r\n}\r\nif (priv->cfg->ops->lib->eeprom_ops.regulatory_bands[5] ==\r\nEEPROM_REGULATORY_BAND_NO_HT40 &&\r\npriv->cfg->ops->lib->eeprom_ops.regulatory_bands[6] ==\r\nEEPROM_REGULATORY_BAND_NO_HT40)\r\nreturn 0;\r\nfor (band = 6; band <= 7; band++) {\r\nenum ieee80211_band ieeeband;\r\niwl_legacy_init_band_reference(priv, band, &eeprom_ch_count,\r\n&eeprom_ch_info, &eeprom_ch_index);\r\nieeeband =\r\n(band == 6) ? IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;\r\nfor (ch = 0; ch < eeprom_ch_count; ch++) {\r\niwl_legacy_mod_ht40_chan_info(priv, ieeeband,\r\neeprom_ch_index[ch],\r\n&eeprom_ch_info[ch],\r\nIEEE80211_CHAN_NO_HT40PLUS);\r\niwl_legacy_mod_ht40_chan_info(priv, ieeeband,\r\neeprom_ch_index[ch] + 4,\r\n&eeprom_ch_info[ch],\r\nIEEE80211_CHAN_NO_HT40MINUS);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid iwl_legacy_free_channel_map(struct iwl_priv *priv)\r\n{\r\nkfree(priv->channel_info);\r\npriv->channel_count = 0;\r\n}\r\nconst struct\r\niwl_channel_info *iwl_legacy_get_channel_info(const struct iwl_priv *priv,\r\nenum ieee80211_band band, u16 channel)\r\n{\r\nint i;\r\nswitch (band) {\r\ncase IEEE80211_BAND_5GHZ:\r\nfor (i = 14; i < priv->channel_count; i++) {\r\nif (priv->channel_info[i].channel == channel)\r\nreturn &priv->channel_info[i];\r\n}\r\nbreak;\r\ncase IEEE80211_BAND_2GHZ:\r\nif (channel >= 1 && channel <= 14)\r\nreturn &priv->channel_info[channel - 1];\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}
