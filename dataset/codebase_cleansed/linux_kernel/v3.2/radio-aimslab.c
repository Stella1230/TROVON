static void rt_decvol(struct rtrack *rt)\r\n{\r\noutb(0x58, rt->io);\r\nmsleep(100);\r\noutb(0xd8, rt->io);\r\n}\r\nstatic void rt_incvol(struct rtrack *rt)\r\n{\r\noutb(0x98, rt->io);\r\nmsleep(100);\r\noutb(0xd8, rt->io);\r\n}\r\nstatic void rt_mute(struct rtrack *rt)\r\n{\r\nrt->muted = 1;\r\nmutex_lock(&rt->lock);\r\noutb(0xd0, rt->io);\r\nmutex_unlock(&rt->lock);\r\n}\r\nstatic int rt_setvol(struct rtrack *rt, int vol)\r\n{\r\nint i;\r\nmutex_lock(&rt->lock);\r\nif (vol == rt->curvol) {\r\nif (rt->muted) {\r\nrt->muted = 0;\r\noutb(0xd8, rt->io);\r\n}\r\nmutex_unlock(&rt->lock);\r\nreturn 0;\r\n}\r\nif (vol == 0) {\r\noutb(0x48, rt->io);\r\nmsleep(2000);\r\noutb(0xd0, rt->io);\r\nrt->curvol = 0;\r\nmutex_unlock(&rt->lock);\r\nreturn 0;\r\n}\r\nrt->muted = 0;\r\nif (vol > rt->curvol)\r\nfor (i = rt->curvol; i < vol; i++)\r\nrt_incvol(rt);\r\nelse\r\nfor (i = rt->curvol; i > vol; i--)\r\nrt_decvol(rt);\r\nrt->curvol = vol;\r\nmutex_unlock(&rt->lock);\r\nreturn 0;\r\n}\r\nstatic void send_0_byte(struct rtrack *rt)\r\n{\r\nif (rt->curvol == 0 || rt->muted) {\r\noutb_p(128+64+16+ 1, rt->io);\r\noutb_p(128+64+16+2+1, rt->io);\r\n}\r\nelse {\r\noutb_p(128+64+16+8+ 1, rt->io);\r\noutb_p(128+64+16+8+2+1, rt->io);\r\n}\r\nmsleep(1);\r\n}\r\nstatic void send_1_byte(struct rtrack *rt)\r\n{\r\nif (rt->curvol == 0 || rt->muted) {\r\noutb_p(128+64+16+4 +1, rt->io);\r\noutb_p(128+64+16+4+2+1, rt->io);\r\n}\r\nelse {\r\noutb_p(128+64+16+8+4 +1, rt->io);\r\noutb_p(128+64+16+8+4+2+1, rt->io);\r\n}\r\nmsleep(1);\r\n}\r\nstatic int rt_setfreq(struct rtrack *rt, unsigned long freq)\r\n{\r\nint i;\r\nmutex_lock(&rt->lock);\r\nrt->curfreq = freq;\r\nfreq += 171200;\r\nfreq /= 800;\r\nsend_0_byte(rt);\r\nfor (i = 0; i < 13; i++)\r\nif (freq & (1 << i))\r\nsend_1_byte(rt);\r\nelse\r\nsend_0_byte(rt);\r\nsend_0_byte(rt);\r\nsend_0_byte(rt);\r\nsend_0_byte(rt);\r\nsend_0_byte(rt);\r\nsend_0_byte(rt);\r\nsend_0_byte(rt);\r\nsend_0_byte(rt);\r\nsend_1_byte(rt);\r\nsend_0_byte(rt);\r\nsend_1_byte(rt);\r\nif (rt->curvol == 0 || rt->muted)\r\noutb(0xd0, rt->io);\r\nelse\r\noutb(0xd8, rt->io);\r\nmutex_unlock(&rt->lock);\r\nreturn 0;\r\n}\r\nstatic int rt_getsigstr(struct rtrack *rt)\r\n{\r\nint sig = 1;\r\nmutex_lock(&rt->lock);\r\nif (inb(rt->io) & 2)\r\nsig = 0;\r\nmutex_unlock(&rt->lock);\r\nreturn sig;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "radio-aimslab", sizeof(v->driver));\r\nstrlcpy(v->card, "RadioTrack", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct rtrack *rt = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = 87 * 16000;\r\nv->rangehigh = 108 * 16000;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nv->signal = 0xffff * rt_getsigstr(rt);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct rtrack *rt = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nrt_setfreq(rt, f->frequency);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct rtrack *rt = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = rt->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 0xff, 1, 0xff);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct rtrack *rt = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = rt->muted;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nctrl->value = rt->curvol;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct rtrack *rt = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value)\r\nrt_mute(rt);\r\nelse\r\nrt_setvol(rt, rt->curvol);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nrt_setvol(rt, ctrl->value);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn a->index ? -EINVAL : 0;\r\n}\r\nstatic int __init rtrack_init(void)\r\n{\r\nstruct rtrack *rt = &rtrack_card;\r\nstruct v4l2_device *v4l2_dev = &rt->v4l2_dev;\r\nint res;\r\nstrlcpy(v4l2_dev->name, "rtrack", sizeof(v4l2_dev->name));\r\nrt->io = io;\r\nif (rt->io == -1) {\r\nv4l2_err(v4l2_dev, "you must set an I/O address with io=0x20f or 0x30f\n");\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(rt->io, 2, "rtrack")) {\r\nv4l2_err(v4l2_dev, "port 0x%x already in use\n", rt->io);\r\nreturn -EBUSY;\r\n}\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(rt->io, 2);\r\nv4l2_err(v4l2_dev, "could not register v4l2_device\n");\r\nreturn res;\r\n}\r\nstrlcpy(rt->vdev.name, v4l2_dev->name, sizeof(rt->vdev.name));\r\nrt->vdev.v4l2_dev = v4l2_dev;\r\nrt->vdev.fops = &rtrack_fops;\r\nrt->vdev.ioctl_ops = &rtrack_ioctl_ops;\r\nrt->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&rt->vdev, rt);\r\nmutex_init(&rt->lock);\r\noutb(0x48, rt->io);\r\nmsleep(2000);\r\noutb(0xc0, rt->io);\r\nif (video_register_device(&rt->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_device_unregister(&rt->v4l2_dev);\r\nrelease_region(rt->io, 2);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(v4l2_dev, "AIMSlab RadioTrack/RadioReveal card driver.\n");\r\nreturn 0;\r\n}\r\nstatic void __exit rtrack_exit(void)\r\n{\r\nstruct rtrack *rt = &rtrack_card;\r\nvideo_unregister_device(&rt->vdev);\r\nv4l2_device_unregister(&rt->v4l2_dev);\r\nrelease_region(rt->io, 2);\r\n}
