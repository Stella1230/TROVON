static inline struct sockaddr *nsm_addr(const struct nsm_handle *nsm)\r\n{\r\nreturn (struct sockaddr *)&nsm->sm_addr;\r\n}\r\nstatic struct rpc_clnt *nsm_create(void)\r\n{\r\nstruct sockaddr_in sin = {\r\n.sin_family = AF_INET,\r\n.sin_addr.s_addr = htonl(INADDR_LOOPBACK),\r\n};\r\nstruct rpc_create_args args = {\r\n.net = &init_net,\r\n.protocol = XPRT_TRANSPORT_UDP,\r\n.address = (struct sockaddr *)&sin,\r\n.addrsize = sizeof(sin),\r\n.servername = "rpc.statd",\r\n.program = &nsm_program,\r\n.version = NSM_VERSION,\r\n.authflavor = RPC_AUTH_NULL,\r\n.flags = RPC_CLNT_CREATE_NOPING,\r\n};\r\nreturn rpc_create(&args);\r\n}\r\nstatic int nsm_mon_unmon(struct nsm_handle *nsm, u32 proc, struct nsm_res *res)\r\n{\r\nstruct rpc_clnt *clnt;\r\nint status;\r\nstruct nsm_args args = {\r\n.priv = &nsm->sm_priv,\r\n.prog = NLM_PROGRAM,\r\n.vers = 3,\r\n.proc = NLMPROC_NSM_NOTIFY,\r\n.mon_name = nsm->sm_mon_name,\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_argp = &args,\r\n.rpc_resp = res,\r\n};\r\nclnt = nsm_create();\r\nif (IS_ERR(clnt)) {\r\nstatus = PTR_ERR(clnt);\r\ndprintk("lockd: failed to create NSM upcall transport, "\r\n"status=%d\n", status);\r\ngoto out;\r\n}\r\nmemset(res, 0, sizeof(*res));\r\nmsg.rpc_proc = &clnt->cl_procinfo[proc];\r\nstatus = rpc_call_sync(clnt, &msg, 0);\r\nif (status < 0)\r\ndprintk("lockd: NSM upcall RPC failed, status=%d\n",\r\nstatus);\r\nelse\r\nstatus = 0;\r\nrpc_shutdown_client(clnt);\r\nout:\r\nreturn status;\r\n}\r\nint nsm_monitor(const struct nlm_host *host)\r\n{\r\nstruct nsm_handle *nsm = host->h_nsmhandle;\r\nstruct nsm_res res;\r\nint status;\r\ndprintk("lockd: nsm_monitor(%s)\n", nsm->sm_name);\r\nif (nsm->sm_monitored)\r\nreturn 0;\r\nnsm->sm_mon_name = nsm_use_hostnames ? nsm->sm_name : nsm->sm_addrbuf;\r\nstatus = nsm_mon_unmon(nsm, NSMPROC_MON, &res);\r\nif (unlikely(res.status != 0))\r\nstatus = -EIO;\r\nif (unlikely(status < 0)) {\r\nprintk(KERN_NOTICE "lockd: cannot monitor %s\n", nsm->sm_name);\r\nreturn status;\r\n}\r\nnsm->sm_monitored = 1;\r\nif (unlikely(nsm_local_state != res.state)) {\r\nnsm_local_state = res.state;\r\ndprintk("lockd: NSM state changed to %d\n", nsm_local_state);\r\n}\r\nreturn 0;\r\n}\r\nvoid nsm_unmonitor(const struct nlm_host *host)\r\n{\r\nstruct nsm_handle *nsm = host->h_nsmhandle;\r\nstruct nsm_res res;\r\nint status;\r\nif (atomic_read(&nsm->sm_count) == 1\r\n&& nsm->sm_monitored && !nsm->sm_sticky) {\r\ndprintk("lockd: nsm_unmonitor(%s)\n", nsm->sm_name);\r\nstatus = nsm_mon_unmon(nsm, NSMPROC_UNMON, &res);\r\nif (res.status != 0)\r\nstatus = -EIO;\r\nif (status < 0)\r\nprintk(KERN_NOTICE "lockd: cannot unmonitor %s\n",\r\nnsm->sm_name);\r\nelse\r\nnsm->sm_monitored = 0;\r\n}\r\n}\r\nstatic struct nsm_handle *nsm_lookup_hostname(const char *hostname,\r\nconst size_t len)\r\n{\r\nstruct nsm_handle *nsm;\r\nlist_for_each_entry(nsm, &nsm_handles, sm_link)\r\nif (strlen(nsm->sm_name) == len &&\r\nmemcmp(nsm->sm_name, hostname, len) == 0)\r\nreturn nsm;\r\nreturn NULL;\r\n}\r\nstatic struct nsm_handle *nsm_lookup_addr(const struct sockaddr *sap)\r\n{\r\nstruct nsm_handle *nsm;\r\nlist_for_each_entry(nsm, &nsm_handles, sm_link)\r\nif (rpc_cmp_addr(nsm_addr(nsm), sap))\r\nreturn nsm;\r\nreturn NULL;\r\n}\r\nstatic struct nsm_handle *nsm_lookup_priv(const struct nsm_private *priv)\r\n{\r\nstruct nsm_handle *nsm;\r\nlist_for_each_entry(nsm, &nsm_handles, sm_link)\r\nif (memcmp(nsm->sm_priv.data, priv->data,\r\nsizeof(priv->data)) == 0)\r\nreturn nsm;\r\nreturn NULL;\r\n}\r\nstatic void nsm_init_private(struct nsm_handle *nsm)\r\n{\r\nu64 *p = (u64 *)&nsm->sm_priv.data;\r\nstruct timespec ts;\r\ns64 ns;\r\nktime_get_ts(&ts);\r\nns = timespec_to_ns(&ts);\r\nput_unaligned(ns, p);\r\nput_unaligned((unsigned long)nsm, p + 1);\r\n}\r\nstatic struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,\r\nconst size_t salen,\r\nconst char *hostname,\r\nconst size_t hostname_len)\r\n{\r\nstruct nsm_handle *new;\r\nnew = kzalloc(sizeof(*new) + hostname_len + 1, GFP_KERNEL);\r\nif (unlikely(new == NULL))\r\nreturn NULL;\r\natomic_set(&new->sm_count, 1);\r\nnew->sm_name = (char *)(new + 1);\r\nmemcpy(nsm_addr(new), sap, salen);\r\nnew->sm_addrlen = salen;\r\nnsm_init_private(new);\r\nif (rpc_ntop(nsm_addr(new), new->sm_addrbuf,\r\nsizeof(new->sm_addrbuf)) == 0)\r\n(void)snprintf(new->sm_addrbuf, sizeof(new->sm_addrbuf),\r\n"unsupported address family");\r\nmemcpy(new->sm_name, hostname, hostname_len);\r\nnew->sm_name[hostname_len] = '\0';\r\nreturn new;\r\n}\r\nstruct nsm_handle *nsm_get_handle(const struct sockaddr *sap,\r\nconst size_t salen, const char *hostname,\r\nconst size_t hostname_len)\r\n{\r\nstruct nsm_handle *cached, *new = NULL;\r\nif (hostname && memchr(hostname, '/', hostname_len) != NULL) {\r\nif (printk_ratelimit()) {\r\nprintk(KERN_WARNING "Invalid hostname \"%.*s\" "\r\n"in NFS lock request\n",\r\n(int)hostname_len, hostname);\r\n}\r\nreturn NULL;\r\n}\r\nretry:\r\nspin_lock(&nsm_lock);\r\nif (nsm_use_hostnames && hostname != NULL)\r\ncached = nsm_lookup_hostname(hostname, hostname_len);\r\nelse\r\ncached = nsm_lookup_addr(sap);\r\nif (cached != NULL) {\r\natomic_inc(&cached->sm_count);\r\nspin_unlock(&nsm_lock);\r\nkfree(new);\r\ndprintk("lockd: found nsm_handle for %s (%s), "\r\n"cnt %d\n", cached->sm_name,\r\ncached->sm_addrbuf,\r\natomic_read(&cached->sm_count));\r\nreturn cached;\r\n}\r\nif (new != NULL) {\r\nlist_add(&new->sm_link, &nsm_handles);\r\nspin_unlock(&nsm_lock);\r\ndprintk("lockd: created nsm_handle for %s (%s)\n",\r\nnew->sm_name, new->sm_addrbuf);\r\nreturn new;\r\n}\r\nspin_unlock(&nsm_lock);\r\nnew = nsm_create_handle(sap, salen, hostname, hostname_len);\r\nif (unlikely(new == NULL))\r\nreturn NULL;\r\ngoto retry;\r\n}\r\nstruct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)\r\n{\r\nstruct nsm_handle *cached;\r\nspin_lock(&nsm_lock);\r\ncached = nsm_lookup_priv(&info->priv);\r\nif (unlikely(cached == NULL)) {\r\nspin_unlock(&nsm_lock);\r\ndprintk("lockd: never saw rebooted peer '%.*s' before\n",\r\ninfo->len, info->mon);\r\nreturn cached;\r\n}\r\natomic_inc(&cached->sm_count);\r\nspin_unlock(&nsm_lock);\r\ndprintk("lockd: host %s (%s) rebooted, cnt %d\n",\r\ncached->sm_name, cached->sm_addrbuf,\r\natomic_read(&cached->sm_count));\r\nreturn cached;\r\n}\r\nvoid nsm_release(struct nsm_handle *nsm)\r\n{\r\nif (atomic_dec_and_lock(&nsm->sm_count, &nsm_lock)) {\r\nlist_del(&nsm->sm_link);\r\nspin_unlock(&nsm_lock);\r\ndprintk("lockd: destroyed nsm_handle for %s (%s)\n",\r\nnsm->sm_name, nsm->sm_addrbuf);\r\nkfree(nsm);\r\n}\r\n}\r\nstatic void encode_nsm_string(struct xdr_stream *xdr, const char *string)\r\n{\r\nconst u32 len = strlen(string);\r\n__be32 *p;\r\nBUG_ON(len > SM_MAXSTRLEN);\r\np = xdr_reserve_space(xdr, 4 + len);\r\nxdr_encode_opaque(p, string, len);\r\n}\r\nstatic void encode_mon_name(struct xdr_stream *xdr, const struct nsm_args *argp)\r\n{\r\nencode_nsm_string(xdr, argp->mon_name);\r\n}\r\nstatic void encode_my_id(struct xdr_stream *xdr, const struct nsm_args *argp)\r\n{\r\n__be32 *p;\r\nencode_nsm_string(xdr, utsname()->nodename);\r\np = xdr_reserve_space(xdr, 4 + 4 + 4);\r\n*p++ = cpu_to_be32(argp->prog);\r\n*p++ = cpu_to_be32(argp->vers);\r\n*p = cpu_to_be32(argp->proc);\r\n}\r\nstatic void encode_mon_id(struct xdr_stream *xdr, const struct nsm_args *argp)\r\n{\r\nencode_mon_name(xdr, argp);\r\nencode_my_id(xdr, argp);\r\n}\r\nstatic void encode_priv(struct xdr_stream *xdr, const struct nsm_args *argp)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, SM_PRIV_SIZE);\r\nxdr_encode_opaque_fixed(p, argp->priv->data, SM_PRIV_SIZE);\r\n}\r\nstatic void nsm_xdr_enc_mon(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nconst struct nsm_args *argp)\r\n{\r\nencode_mon_id(xdr, argp);\r\nencode_priv(xdr, argp);\r\n}\r\nstatic void nsm_xdr_enc_unmon(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nconst struct nsm_args *argp)\r\n{\r\nencode_mon_id(xdr, argp);\r\n}\r\nstatic int nsm_xdr_dec_stat_res(struct rpc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct nsm_res *resp)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nresp->status = be32_to_cpup(p++);\r\nresp->state = be32_to_cpup(p);\r\ndprintk("lockd: %s status %d state %d\n",\r\n__func__, resp->status, resp->state);\r\nreturn 0;\r\n}\r\nstatic int nsm_xdr_dec_stat(struct rpc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct nsm_res *resp)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nresp->state = be32_to_cpup(p);\r\ndprintk("lockd: %s state %d\n", __func__, resp->state);\r\nreturn 0;\r\n}
