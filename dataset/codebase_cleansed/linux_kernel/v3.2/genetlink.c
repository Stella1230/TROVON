void genl_lock(void)\r\n{\r\nmutex_lock(&genl_mutex);\r\n}\r\nvoid genl_unlock(void)\r\n{\r\nmutex_unlock(&genl_mutex);\r\n}\r\nstatic inline unsigned int genl_family_hash(unsigned int id)\r\n{\r\nreturn id & GENL_FAM_TAB_MASK;\r\n}\r\nstatic inline struct list_head *genl_family_chain(unsigned int id)\r\n{\r\nreturn &family_ht[genl_family_hash(id)];\r\n}\r\nstatic struct genl_family *genl_family_find_byid(unsigned int id)\r\n{\r\nstruct genl_family *f;\r\nlist_for_each_entry(f, genl_family_chain(id), family_list)\r\nif (f->id == id)\r\nreturn f;\r\nreturn NULL;\r\n}\r\nstatic struct genl_family *genl_family_find_byname(char *name)\r\n{\r\nstruct genl_family *f;\r\nint i;\r\nfor (i = 0; i < GENL_FAM_TAB_SIZE; i++)\r\nlist_for_each_entry(f, genl_family_chain(i), family_list)\r\nif (strcmp(f->name, name) == 0)\r\nreturn f;\r\nreturn NULL;\r\n}\r\nstatic struct genl_ops *genl_get_cmd(u8 cmd, struct genl_family *family)\r\n{\r\nstruct genl_ops *ops;\r\nlist_for_each_entry(ops, &family->ops_list, ops_list)\r\nif (ops->cmd == cmd)\r\nreturn ops;\r\nreturn NULL;\r\n}\r\nstatic inline u16 genl_generate_id(void)\r\n{\r\nstatic u16 id_gen_idx = GENL_MIN_ID;\r\nint i;\r\nfor (i = 0; i <= GENL_MAX_ID - GENL_MIN_ID; i++) {\r\nif (!genl_family_find_byid(id_gen_idx))\r\nreturn id_gen_idx;\r\nif (++id_gen_idx > GENL_MAX_ID)\r\nid_gen_idx = GENL_MIN_ID;\r\n}\r\nreturn 0;\r\n}\r\nint genl_register_mc_group(struct genl_family *family,\r\nstruct genl_multicast_group *grp)\r\n{\r\nint id;\r\nunsigned long *new_groups;\r\nint err = 0;\r\nBUG_ON(grp->name[0] == '\0');\r\ngenl_lock();\r\nif (grp == &notify_grp)\r\nid = GENL_ID_CTRL;\r\nelse\r\nid = find_first_zero_bit(mc_groups,\r\nmc_groups_longs * BITS_PER_LONG);\r\nif (id >= mc_groups_longs * BITS_PER_LONG) {\r\nsize_t nlen = (mc_groups_longs + 1) * sizeof(unsigned long);\r\nif (mc_groups == &mc_group_start) {\r\nnew_groups = kzalloc(nlen, GFP_KERNEL);\r\nif (!new_groups) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmc_groups = new_groups;\r\n*mc_groups = mc_group_start;\r\n} else {\r\nnew_groups = krealloc(mc_groups, nlen, GFP_KERNEL);\r\nif (!new_groups) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmc_groups = new_groups;\r\nmc_groups[mc_groups_longs] = 0;\r\n}\r\nmc_groups_longs++;\r\n}\r\nif (family->netnsok) {\r\nstruct net *net;\r\nnetlink_table_grab();\r\nrcu_read_lock();\r\nfor_each_net_rcu(net) {\r\nerr = __netlink_change_ngroups(net->genl_sock,\r\nmc_groups_longs * BITS_PER_LONG);\r\nif (err) {\r\nrcu_read_unlock();\r\nnetlink_table_ungrab();\r\ngoto out;\r\n}\r\n}\r\nrcu_read_unlock();\r\nnetlink_table_ungrab();\r\n} else {\r\nerr = netlink_change_ngroups(init_net.genl_sock,\r\nmc_groups_longs * BITS_PER_LONG);\r\nif (err)\r\ngoto out;\r\n}\r\ngrp->id = id;\r\nset_bit(id, mc_groups);\r\nlist_add_tail(&grp->list, &family->mcast_groups);\r\ngrp->family = family;\r\ngenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, grp);\r\nout:\r\ngenl_unlock();\r\nreturn err;\r\n}\r\nstatic void __genl_unregister_mc_group(struct genl_family *family,\r\nstruct genl_multicast_group *grp)\r\n{\r\nstruct net *net;\r\nBUG_ON(grp->family != family);\r\nnetlink_table_grab();\r\nrcu_read_lock();\r\nfor_each_net_rcu(net)\r\n__netlink_clear_multicast_users(net->genl_sock, grp->id);\r\nrcu_read_unlock();\r\nnetlink_table_ungrab();\r\nclear_bit(grp->id, mc_groups);\r\nlist_del(&grp->list);\r\ngenl_ctrl_event(CTRL_CMD_DELMCAST_GRP, grp);\r\ngrp->id = 0;\r\ngrp->family = NULL;\r\n}\r\nvoid genl_unregister_mc_group(struct genl_family *family,\r\nstruct genl_multicast_group *grp)\r\n{\r\ngenl_lock();\r\n__genl_unregister_mc_group(family, grp);\r\ngenl_unlock();\r\n}\r\nstatic void genl_unregister_mc_groups(struct genl_family *family)\r\n{\r\nstruct genl_multicast_group *grp, *tmp;\r\nlist_for_each_entry_safe(grp, tmp, &family->mcast_groups, list)\r\n__genl_unregister_mc_group(family, grp);\r\n}\r\nint genl_register_ops(struct genl_family *family, struct genl_ops *ops)\r\n{\r\nint err = -EINVAL;\r\nif (ops->dumpit == NULL && ops->doit == NULL)\r\ngoto errout;\r\nif (genl_get_cmd(ops->cmd, family)) {\r\nerr = -EEXIST;\r\ngoto errout;\r\n}\r\nif (ops->dumpit)\r\nops->flags |= GENL_CMD_CAP_DUMP;\r\nif (ops->doit)\r\nops->flags |= GENL_CMD_CAP_DO;\r\nif (ops->policy)\r\nops->flags |= GENL_CMD_CAP_HASPOL;\r\ngenl_lock();\r\nlist_add_tail(&ops->ops_list, &family->ops_list);\r\ngenl_unlock();\r\ngenl_ctrl_event(CTRL_CMD_NEWOPS, ops);\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nint genl_unregister_ops(struct genl_family *family, struct genl_ops *ops)\r\n{\r\nstruct genl_ops *rc;\r\ngenl_lock();\r\nlist_for_each_entry(rc, &family->ops_list, ops_list) {\r\nif (rc == ops) {\r\nlist_del(&ops->ops_list);\r\ngenl_unlock();\r\ngenl_ctrl_event(CTRL_CMD_DELOPS, ops);\r\nreturn 0;\r\n}\r\n}\r\ngenl_unlock();\r\nreturn -ENOENT;\r\n}\r\nint genl_register_family(struct genl_family *family)\r\n{\r\nint err = -EINVAL;\r\nif (family->id && family->id < GENL_MIN_ID)\r\ngoto errout;\r\nif (family->id > GENL_MAX_ID)\r\ngoto errout;\r\nINIT_LIST_HEAD(&family->ops_list);\r\nINIT_LIST_HEAD(&family->mcast_groups);\r\ngenl_lock();\r\nif (genl_family_find_byname(family->name)) {\r\nerr = -EEXIST;\r\ngoto errout_locked;\r\n}\r\nif (family->id == GENL_ID_GENERATE) {\r\nu16 newid = genl_generate_id();\r\nif (!newid) {\r\nerr = -ENOMEM;\r\ngoto errout_locked;\r\n}\r\nfamily->id = newid;\r\n} else if (genl_family_find_byid(family->id)) {\r\nerr = -EEXIST;\r\ngoto errout_locked;\r\n}\r\nif (family->maxattr) {\r\nfamily->attrbuf = kmalloc((family->maxattr+1) *\r\nsizeof(struct nlattr *), GFP_KERNEL);\r\nif (family->attrbuf == NULL) {\r\nerr = -ENOMEM;\r\ngoto errout_locked;\r\n}\r\n} else\r\nfamily->attrbuf = NULL;\r\nlist_add_tail(&family->family_list, genl_family_chain(family->id));\r\ngenl_unlock();\r\ngenl_ctrl_event(CTRL_CMD_NEWFAMILY, family);\r\nreturn 0;\r\nerrout_locked:\r\ngenl_unlock();\r\nerrout:\r\nreturn err;\r\n}\r\nint genl_register_family_with_ops(struct genl_family *family,\r\nstruct genl_ops *ops, size_t n_ops)\r\n{\r\nint err, i;\r\nerr = genl_register_family(family);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < n_ops; ++i, ++ops) {\r\nerr = genl_register_ops(family, ops);\r\nif (err)\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\ngenl_unregister_family(family);\r\nreturn err;\r\n}\r\nint genl_unregister_family(struct genl_family *family)\r\n{\r\nstruct genl_family *rc;\r\ngenl_lock();\r\ngenl_unregister_mc_groups(family);\r\nlist_for_each_entry(rc, genl_family_chain(family->id), family_list) {\r\nif (family->id != rc->id || strcmp(rc->name, family->name))\r\ncontinue;\r\nlist_del(&rc->family_list);\r\nINIT_LIST_HEAD(&family->ops_list);\r\ngenl_unlock();\r\nkfree(family->attrbuf);\r\ngenl_ctrl_event(CTRL_CMD_DELFAMILY, family);\r\nreturn 0;\r\n}\r\ngenl_unlock();\r\nreturn -ENOENT;\r\n}\r\nstatic int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct genl_ops *ops;\r\nstruct genl_family *family;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct genl_info info;\r\nstruct genlmsghdr *hdr = nlmsg_data(nlh);\r\nint hdrlen, err;\r\nfamily = genl_family_find_byid(nlh->nlmsg_type);\r\nif (family == NULL)\r\nreturn -ENOENT;\r\nif (!family->netnsok && !net_eq(net, &init_net))\r\nreturn -ENOENT;\r\nhdrlen = GENL_HDRLEN + family->hdrsize;\r\nif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\r\nreturn -EINVAL;\r\nops = genl_get_cmd(hdr->cmd, family);\r\nif (ops == NULL)\r\nreturn -EOPNOTSUPP;\r\nif ((ops->flags & GENL_ADMIN_PERM) &&\r\nsecurity_netlink_recv(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nif (ops->dumpit == NULL)\r\nreturn -EOPNOTSUPP;\r\ngenl_unlock();\r\nerr = netlink_dump_start(net->genl_sock, skb, nlh,\r\nops->dumpit, ops->done, 0);\r\ngenl_lock();\r\nreturn err;\r\n}\r\nif (ops->doit == NULL)\r\nreturn -EOPNOTSUPP;\r\nif (family->attrbuf) {\r\nerr = nlmsg_parse(nlh, hdrlen, family->attrbuf, family->maxattr,\r\nops->policy);\r\nif (err < 0)\r\nreturn err;\r\n}\r\ninfo.snd_seq = nlh->nlmsg_seq;\r\ninfo.snd_pid = NETLINK_CB(skb).pid;\r\ninfo.nlhdr = nlh;\r\ninfo.genlhdr = nlmsg_data(nlh);\r\ninfo.userhdr = nlmsg_data(nlh) + GENL_HDRLEN;\r\ninfo.attrs = family->attrbuf;\r\ngenl_info_net_set(&info, net);\r\nmemset(&info.user_ptr, 0, sizeof(info.user_ptr));\r\nif (family->pre_doit) {\r\nerr = family->pre_doit(ops, skb, &info);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ops->doit(skb, &info);\r\nif (family->post_doit)\r\nfamily->post_doit(ops, skb, &info);\r\nreturn err;\r\n}\r\nstatic void genl_rcv(struct sk_buff *skb)\r\n{\r\ngenl_lock();\r\nnetlink_rcv_skb(skb, &genl_rcv_msg);\r\ngenl_unlock();\r\n}\r\nstatic int ctrl_fill_info(struct genl_family *family, u32 pid, u32 seq,\r\nu32 flags, struct sk_buff *skb, u8 cmd)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, pid, seq, &genl_ctrl, flags, cmd);\r\nif (hdr == NULL)\r\nreturn -1;\r\nNLA_PUT_STRING(skb, CTRL_ATTR_FAMILY_NAME, family->name);\r\nNLA_PUT_U16(skb, CTRL_ATTR_FAMILY_ID, family->id);\r\nNLA_PUT_U32(skb, CTRL_ATTR_VERSION, family->version);\r\nNLA_PUT_U32(skb, CTRL_ATTR_HDRSIZE, family->hdrsize);\r\nNLA_PUT_U32(skb, CTRL_ATTR_MAXATTR, family->maxattr);\r\nif (!list_empty(&family->ops_list)) {\r\nstruct nlattr *nla_ops;\r\nstruct genl_ops *ops;\r\nint idx = 1;\r\nnla_ops = nla_nest_start(skb, CTRL_ATTR_OPS);\r\nif (nla_ops == NULL)\r\ngoto nla_put_failure;\r\nlist_for_each_entry(ops, &family->ops_list, ops_list) {\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, idx++);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nNLA_PUT_U32(skb, CTRL_ATTR_OP_ID, ops->cmd);\r\nNLA_PUT_U32(skb, CTRL_ATTR_OP_FLAGS, ops->flags);\r\nnla_nest_end(skb, nest);\r\n}\r\nnla_nest_end(skb, nla_ops);\r\n}\r\nif (!list_empty(&family->mcast_groups)) {\r\nstruct genl_multicast_group *grp;\r\nstruct nlattr *nla_grps;\r\nint idx = 1;\r\nnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\r\nif (nla_grps == NULL)\r\ngoto nla_put_failure;\r\nlist_for_each_entry(grp, &family->mcast_groups, list) {\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, idx++);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nNLA_PUT_U32(skb, CTRL_ATTR_MCAST_GRP_ID, grp->id);\r\nNLA_PUT_STRING(skb, CTRL_ATTR_MCAST_GRP_NAME,\r\ngrp->name);\r\nnla_nest_end(skb, nest);\r\n}\r\nnla_nest_end(skb, nla_grps);\r\n}\r\nreturn genlmsg_end(skb, hdr);\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ctrl_fill_mcgrp_info(struct genl_multicast_group *grp, u32 pid,\r\nu32 seq, u32 flags, struct sk_buff *skb,\r\nu8 cmd)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *nla_grps;\r\nstruct nlattr *nest;\r\nhdr = genlmsg_put(skb, pid, seq, &genl_ctrl, flags, cmd);\r\nif (hdr == NULL)\r\nreturn -1;\r\nNLA_PUT_STRING(skb, CTRL_ATTR_FAMILY_NAME, grp->family->name);\r\nNLA_PUT_U16(skb, CTRL_ATTR_FAMILY_ID, grp->family->id);\r\nnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\r\nif (nla_grps == NULL)\r\ngoto nla_put_failure;\r\nnest = nla_nest_start(skb, 1);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nNLA_PUT_U32(skb, CTRL_ATTR_MCAST_GRP_ID, grp->id);\r\nNLA_PUT_STRING(skb, CTRL_ATTR_MCAST_GRP_NAME,\r\ngrp->name);\r\nnla_nest_end(skb, nest);\r\nnla_nest_end(skb, nla_grps);\r\nreturn genlmsg_end(skb, hdr);\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ctrl_dumpfamily(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint i, n = 0;\r\nstruct genl_family *rt;\r\nstruct net *net = sock_net(skb->sk);\r\nint chains_to_skip = cb->args[0];\r\nint fams_to_skip = cb->args[1];\r\nfor (i = chains_to_skip; i < GENL_FAM_TAB_SIZE; i++) {\r\nn = 0;\r\nlist_for_each_entry(rt, genl_family_chain(i), family_list) {\r\nif (!rt->netnsok && !net_eq(net, &init_net))\r\ncontinue;\r\nif (++n < fams_to_skip)\r\ncontinue;\r\nif (ctrl_fill_info(rt, NETLINK_CB(cb->skb).pid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nskb, CTRL_CMD_NEWFAMILY) < 0)\r\ngoto errout;\r\n}\r\nfams_to_skip = 0;\r\n}\r\nerrout:\r\ncb->args[0] = i;\r\ncb->args[1] = n;\r\nreturn skb->len;\r\n}\r\nstatic struct sk_buff *ctrl_build_family_msg(struct genl_family *family,\r\nu32 pid, int seq, u8 cmd)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn ERR_PTR(-ENOBUFS);\r\nerr = ctrl_fill_info(family, pid, seq, 0, skb, cmd);\r\nif (err < 0) {\r\nnlmsg_free(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *ctrl_build_mcgrp_msg(struct genl_multicast_group *grp,\r\nu32 pid, int seq, u8 cmd)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb == NULL)\r\nreturn ERR_PTR(-ENOBUFS);\r\nerr = ctrl_fill_mcgrp_info(grp, pid, seq, 0, skb, cmd);\r\nif (err < 0) {\r\nnlmsg_free(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic int ctrl_getfamily(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct sk_buff *msg;\r\nstruct genl_family *res = NULL;\r\nint err = -EINVAL;\r\nif (info->attrs[CTRL_ATTR_FAMILY_ID]) {\r\nu16 id = nla_get_u16(info->attrs[CTRL_ATTR_FAMILY_ID]);\r\nres = genl_family_find_byid(id);\r\nerr = -ENOENT;\r\n}\r\nif (info->attrs[CTRL_ATTR_FAMILY_NAME]) {\r\nchar *name;\r\nname = nla_data(info->attrs[CTRL_ATTR_FAMILY_NAME]);\r\nres = genl_family_find_byname(name);\r\nerr = -ENOENT;\r\n}\r\nif (res == NULL)\r\nreturn err;\r\nif (!res->netnsok && !net_eq(genl_info_net(info), &init_net)) {\r\nreturn -ENOENT;\r\n}\r\nmsg = ctrl_build_family_msg(res, info->snd_pid, info->snd_seq,\r\nCTRL_CMD_NEWFAMILY);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int genl_ctrl_event(int event, void *data)\r\n{\r\nstruct sk_buff *msg;\r\nstruct genl_family *family;\r\nstruct genl_multicast_group *grp;\r\nif (!init_net.genl_sock)\r\nreturn 0;\r\nswitch (event) {\r\ncase CTRL_CMD_NEWFAMILY:\r\ncase CTRL_CMD_DELFAMILY:\r\nfamily = data;\r\nmsg = ctrl_build_family_msg(family, 0, 0, event);\r\nbreak;\r\ncase CTRL_CMD_NEWMCAST_GRP:\r\ncase CTRL_CMD_DELMCAST_GRP:\r\ngrp = data;\r\nfamily = grp->family;\r\nmsg = ctrl_build_mcgrp_msg(data, 0, 0, event);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nif (!family->netnsok) {\r\ngenlmsg_multicast_netns(&init_net, msg, 0,\r\nGENL_ID_CTRL, GFP_KERNEL);\r\n} else {\r\nrcu_read_lock();\r\ngenlmsg_multicast_allns(msg, 0, GENL_ID_CTRL, GFP_ATOMIC);\r\nrcu_read_unlock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int __net_init genl_pernet_init(struct net *net)\r\n{\r\nnet->genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, 0,\r\ngenl_rcv, &genl_mutex,\r\nTHIS_MODULE);\r\nif (!net->genl_sock && net_eq(net, &init_net))\r\npanic("GENL: Cannot initialize generic netlink\n");\r\nif (!net->genl_sock)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit genl_pernet_exit(struct net *net)\r\n{\r\nnetlink_kernel_release(net->genl_sock);\r\nnet->genl_sock = NULL;\r\n}\r\nstatic int __init genl_init(void)\r\n{\r\nint i, err;\r\nfor (i = 0; i < GENL_FAM_TAB_SIZE; i++)\r\nINIT_LIST_HEAD(&family_ht[i]);\r\nerr = genl_register_family_with_ops(&genl_ctrl, &genl_ctrl_ops, 1);\r\nif (err < 0)\r\ngoto problem;\r\nnetlink_set_nonroot(NETLINK_GENERIC, NL_NONROOT_RECV);\r\nerr = register_pernet_subsys(&genl_pernet_ops);\r\nif (err)\r\ngoto problem;\r\nerr = genl_register_mc_group(&genl_ctrl, &notify_grp);\r\nif (err < 0)\r\ngoto problem;\r\nreturn 0;\r\nproblem:\r\npanic("GENL: Cannot register controller: %d\n", err);\r\n}\r\nstatic int genlmsg_mcast(struct sk_buff *skb, u32 pid, unsigned long group,\r\ngfp_t flags)\r\n{\r\nstruct sk_buff *tmp;\r\nstruct net *net, *prev = NULL;\r\nint err;\r\nfor_each_net_rcu(net) {\r\nif (prev) {\r\ntmp = skb_clone(skb, flags);\r\nif (!tmp) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nerr = nlmsg_multicast(prev->genl_sock, tmp,\r\npid, group, flags);\r\nif (err)\r\ngoto error;\r\n}\r\nprev = net;\r\n}\r\nreturn nlmsg_multicast(prev->genl_sock, skb, pid, group, flags);\r\nerror:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nint genlmsg_multicast_allns(struct sk_buff *skb, u32 pid, unsigned int group,\r\ngfp_t flags)\r\n{\r\nreturn genlmsg_mcast(skb, pid, group, flags);\r\n}
