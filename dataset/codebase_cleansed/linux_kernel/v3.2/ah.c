int mlx4_ib_resolve_grh(struct mlx4_ib_dev *dev, const struct ib_ah_attr *ah_attr,\r\nu8 *mac, int *is_mcast, u8 port)\r\n{\r\nstruct in6_addr in6;\r\n*is_mcast = 0;\r\nmemcpy(&in6, ah_attr->grh.dgid.raw, sizeof in6);\r\nif (rdma_link_local_addr(&in6))\r\nrdma_get_ll_mac(&in6, mac);\r\nelse if (rdma_is_multicast_addr(&in6)) {\r\nrdma_get_mcast_mac(&in6, mac);\r\n*is_mcast = 1;\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic struct ib_ah *create_ib_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr,\r\nstruct mlx4_ib_ah *ah)\r\n{\r\nstruct mlx4_dev *dev = to_mdev(pd->device)->dev;\r\nah->av.ib.port_pd = cpu_to_be32(to_mpd(pd)->pdn | (ah_attr->port_num << 24));\r\nah->av.ib.g_slid = ah_attr->src_path_bits;\r\nif (ah_attr->ah_flags & IB_AH_GRH) {\r\nah->av.ib.g_slid |= 0x80;\r\nah->av.ib.gid_index = ah_attr->grh.sgid_index;\r\nah->av.ib.hop_limit = ah_attr->grh.hop_limit;\r\nah->av.ib.sl_tclass_flowlabel |=\r\ncpu_to_be32((ah_attr->grh.traffic_class << 20) |\r\nah_attr->grh.flow_label);\r\nmemcpy(ah->av.ib.dgid, ah_attr->grh.dgid.raw, 16);\r\n}\r\nah->av.ib.dlid = cpu_to_be16(ah_attr->dlid);\r\nif (ah_attr->static_rate) {\r\nah->av.ib.stat_rate = ah_attr->static_rate + MLX4_STAT_RATE_OFFSET;\r\nwhile (ah->av.ib.stat_rate > IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &&\r\n!(1 << ah->av.ib.stat_rate & dev->caps.stat_rate_support))\r\n--ah->av.ib.stat_rate;\r\n}\r\nah->av.ib.sl_tclass_flowlabel = cpu_to_be32(ah_attr->sl << 28);\r\nreturn &ah->ibah;\r\n}\r\nstatic struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr,\r\nstruct mlx4_ib_ah *ah)\r\n{\r\nstruct mlx4_ib_dev *ibdev = to_mdev(pd->device);\r\nstruct mlx4_dev *dev = ibdev->dev;\r\nunion ib_gid sgid;\r\nu8 mac[6];\r\nint err;\r\nint is_mcast;\r\nu16 vlan_tag;\r\nerr = mlx4_ib_resolve_grh(ibdev, ah_attr, mac, &is_mcast, ah_attr->port_num);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nmemcpy(ah->av.eth.mac, mac, 6);\r\nerr = ib_get_cached_gid(pd->device, ah_attr->port_num, ah_attr->grh.sgid_index, &sgid);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nvlan_tag = rdma_get_vlan_id(&sgid);\r\nif (vlan_tag < 0x1000)\r\nvlan_tag |= (ah_attr->sl & 7) << 13;\r\nah->av.eth.port_pd = cpu_to_be32(to_mpd(pd)->pdn | (ah_attr->port_num << 24));\r\nah->av.eth.gid_index = ah_attr->grh.sgid_index;\r\nah->av.eth.vlan = cpu_to_be16(vlan_tag);\r\nif (ah_attr->static_rate) {\r\nah->av.eth.stat_rate = ah_attr->static_rate + MLX4_STAT_RATE_OFFSET;\r\nwhile (ah->av.eth.stat_rate > IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &&\r\n!(1 << ah->av.eth.stat_rate & dev->caps.stat_rate_support))\r\n--ah->av.eth.stat_rate;\r\n}\r\nif (is_mcast)\r\nah->av.ib.dlid = cpu_to_be16(0xc000);\r\nmemcpy(ah->av.eth.dgid, ah_attr->grh.dgid.raw, 16);\r\nah->av.eth.sl_tclass_flowlabel = cpu_to_be32(ah_attr->sl << 28);\r\nreturn &ah->ibah;\r\n}\r\nstruct ib_ah *mlx4_ib_create_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr)\r\n{\r\nstruct mlx4_ib_ah *ah;\r\nstruct ib_ah *ret;\r\nah = kzalloc(sizeof *ah, GFP_ATOMIC);\r\nif (!ah)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (rdma_port_get_link_layer(pd->device, ah_attr->port_num) == IB_LINK_LAYER_ETHERNET) {\r\nif (!(ah_attr->ah_flags & IB_AH_GRH)) {\r\nret = ERR_PTR(-EINVAL);\r\n} else {\r\nret = create_iboe_ah(pd, ah_attr, ah);\r\n}\r\nif (IS_ERR(ret))\r\nkfree(ah);\r\nreturn ret;\r\n} else\r\nreturn create_ib_ah(pd, ah_attr, ah);\r\n}\r\nint mlx4_ib_query_ah(struct ib_ah *ibah, struct ib_ah_attr *ah_attr)\r\n{\r\nstruct mlx4_ib_ah *ah = to_mah(ibah);\r\nenum rdma_link_layer ll;\r\nmemset(ah_attr, 0, sizeof *ah_attr);\r\nah_attr->sl = be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;\r\nah_attr->port_num = be32_to_cpu(ah->av.ib.port_pd) >> 24;\r\nll = rdma_port_get_link_layer(ibah->device, ah_attr->port_num);\r\nah_attr->dlid = ll == IB_LINK_LAYER_INFINIBAND ? be16_to_cpu(ah->av.ib.dlid) : 0;\r\nif (ah->av.ib.stat_rate)\r\nah_attr->static_rate = ah->av.ib.stat_rate - MLX4_STAT_RATE_OFFSET;\r\nah_attr->src_path_bits = ah->av.ib.g_slid & 0x7F;\r\nif (mlx4_ib_ah_grh_present(ah)) {\r\nah_attr->ah_flags = IB_AH_GRH;\r\nah_attr->grh.traffic_class =\r\nbe32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 20;\r\nah_attr->grh.flow_label =\r\nbe32_to_cpu(ah->av.ib.sl_tclass_flowlabel) & 0xfffff;\r\nah_attr->grh.hop_limit = ah->av.ib.hop_limit;\r\nah_attr->grh.sgid_index = ah->av.ib.gid_index;\r\nmemcpy(ah_attr->grh.dgid.raw, ah->av.ib.dgid, 16);\r\n}\r\nreturn 0;\r\n}\r\nint mlx4_ib_destroy_ah(struct ib_ah *ah)\r\n{\r\nkfree(to_mah(ah));\r\nreturn 0;\r\n}
