static inline struct spi_lm70llp *spidev_to_pp(struct spi_device *spi)\r\n{\r\nreturn spi->controller_data;\r\n}\r\nstatic inline void deassertCS(struct spi_lm70llp *pp)\r\n{\r\nu8 data = parport_read_data(pp->port);\r\ndata &= ~0x80;\r\nparport_write_data(pp->port, data | nCS);\r\n}\r\nstatic inline void assertCS(struct spi_lm70llp *pp)\r\n{\r\nu8 data = parport_read_data(pp->port);\r\ndata |= 0x80;\r\nparport_write_data(pp->port, data & ~nCS);\r\n}\r\nstatic inline void clkHigh(struct spi_lm70llp *pp)\r\n{\r\nu8 data = parport_read_data(pp->port);\r\nparport_write_data(pp->port, data | SCLK);\r\n}\r\nstatic inline void clkLow(struct spi_lm70llp *pp)\r\n{\r\nu8 data = parport_read_data(pp->port);\r\nparport_write_data(pp->port, data & ~SCLK);\r\n}\r\nstatic inline void spidelay(unsigned d)\r\n{\r\nudelay(d);\r\n}\r\nstatic inline void setsck(struct spi_device *s, int is_on)\r\n{\r\nstruct spi_lm70llp *pp = spidev_to_pp(s);\r\nif (is_on)\r\nclkHigh(pp);\r\nelse\r\nclkLow(pp);\r\n}\r\nstatic inline void setmosi(struct spi_device *s, int is_on)\r\n{\r\n}\r\nstatic inline int getmiso(struct spi_device *s)\r\n{\r\nstruct spi_lm70llp *pp = spidev_to_pp(s);\r\nreturn ((SIO == (parport_read_status(pp->port) & SIO)) ? 0 : 1 );\r\n}\r\nstatic void lm70_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct spi_lm70llp *pp = spidev_to_pp(spi);\r\nif (value)\r\nassertCS(pp);\r\nelse\r\ndeassertCS(pp);\r\n}\r\nstatic u32 lm70_txrx(struct spi_device *spi, unsigned nsecs, u32 word, u8 bits)\r\n{\r\nreturn bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);\r\n}\r\nstatic void spi_lm70llp_attach(struct parport *p)\r\n{\r\nstruct pardevice *pd;\r\nstruct spi_lm70llp *pp;\r\nstruct spi_master *master;\r\nint status;\r\nif (lm70llp) {\r\nprintk(KERN_WARNING\r\n"%s: spi_lm70llp instance already loaded. Aborting.\n",\r\nDRVNAME);\r\nreturn;\r\n}\r\nmaster = spi_alloc_master(p->physport->dev, sizeof *pp);\r\nif (!master) {\r\nstatus = -ENOMEM;\r\ngoto out_fail;\r\n}\r\npp = spi_master_get_devdata(master);\r\nmaster->bus_num = -1;\r\nmaster->num_chipselect = 1;\r\npp->bitbang.master = spi_master_get(master);\r\npp->bitbang.chipselect = lm70_chipselect;\r\npp->bitbang.txrx_word[SPI_MODE_0] = lm70_txrx;\r\npp->bitbang.flags = SPI_3WIRE;\r\npp->port = p;\r\npd = parport_register_device(p, DRVNAME,\r\nNULL, NULL, NULL,\r\nPARPORT_FLAG_EXCL, pp);\r\nif (!pd) {\r\nstatus = -ENOMEM;\r\ngoto out_free_master;\r\n}\r\npp->pd = pd;\r\nstatus = parport_claim(pd);\r\nif (status < 0)\r\ngoto out_parport_unreg;\r\nstatus = spi_bitbang_start(&pp->bitbang);\r\nif (status < 0) {\r\nprintk(KERN_WARNING\r\n"%s: spi_bitbang_start failed with status %d\n",\r\nDRVNAME, status);\r\ngoto out_off_and_release;\r\n}\r\nstrcpy(pp->info.modalias, "lm70");\r\npp->info.max_speed_hz = 6 * 1000 * 1000;\r\npp->info.chip_select = 0;\r\npp->info.mode = SPI_3WIRE | SPI_MODE_0;\r\nparport_write_data(pp->port, lm70_INIT);\r\npp->info.controller_data = pp;\r\npp->spidev_lm70 = spi_new_device(pp->bitbang.master, &pp->info);\r\nif (pp->spidev_lm70)\r\ndev_dbg(&pp->spidev_lm70->dev, "spidev_lm70 at %s\n",\r\ndev_name(&pp->spidev_lm70->dev));\r\nelse {\r\nprintk(KERN_WARNING "%s: spi_new_device failed\n", DRVNAME);\r\nstatus = -ENODEV;\r\ngoto out_bitbang_stop;\r\n}\r\npp->spidev_lm70->bits_per_word = 8;\r\nlm70llp = pp;\r\nreturn;\r\nout_bitbang_stop:\r\nspi_bitbang_stop(&pp->bitbang);\r\nout_off_and_release:\r\nparport_write_data(pp->port, 0);\r\nmdelay(10);\r\nparport_release(pp->pd);\r\nout_parport_unreg:\r\nparport_unregister_device(pd);\r\nout_free_master:\r\n(void) spi_master_put(master);\r\nout_fail:\r\npr_info("%s: spi_lm70llp probe fail, status %d\n", DRVNAME, status);\r\n}\r\nstatic void spi_lm70llp_detach(struct parport *p)\r\n{\r\nstruct spi_lm70llp *pp;\r\nif (!lm70llp || lm70llp->port != p)\r\nreturn;\r\npp = lm70llp;\r\nspi_bitbang_stop(&pp->bitbang);\r\nparport_write_data(pp->port, 0);\r\nparport_release(pp->pd);\r\nparport_unregister_device(pp->pd);\r\n(void) spi_master_put(pp->bitbang.master);\r\nlm70llp = NULL;\r\n}\r\nstatic int __init init_spi_lm70llp(void)\r\n{\r\nreturn parport_register_driver(&spi_lm70llp_drv);\r\n}\r\nstatic void __exit cleanup_spi_lm70llp(void)\r\n{\r\nparport_unregister_driver(&spi_lm70llp_drv);\r\n}
