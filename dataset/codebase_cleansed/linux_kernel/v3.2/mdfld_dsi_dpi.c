static void mdfld_wait_for_HS_DATA_FIFO(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 gen_fifo_stat_reg = MIPIA_GEN_FIFO_STAT_REG;\r\nint timeout = 0;\r\nif (pipe == 2)\r\ngen_fifo_stat_reg += MIPIC_REG_OFFSET;\r\nudelay(500);\r\nwhile ((timeout < 20000) && (REG_READ(gen_fifo_stat_reg) & DSI_FIFO_GEN_HS_DATA_FULL)) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\ndev_warn(dev->dev, "MIPI: HS Data FIFO was never cleared!\n");\r\n}\r\nstatic void mdfld_wait_for_HS_CTRL_FIFO(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 gen_fifo_stat_reg = MIPIA_GEN_FIFO_STAT_REG;\r\nint timeout = 0;\r\nif (pipe == 2)\r\ngen_fifo_stat_reg += MIPIC_REG_OFFSET;\r\nudelay(500);\r\nwhile ((timeout < 20000) && (REG_READ(gen_fifo_stat_reg) & DSI_FIFO_GEN_HS_CTRL_FULL)) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\ndev_warn(dev->dev, "MIPI: HS CMD FIFO was never cleared!\n");\r\n}\r\nstatic void mdfld_wait_for_DPI_CTRL_FIFO(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 gen_fifo_stat_reg = MIPIA_GEN_FIFO_STAT_REG;\r\nint timeout = 0;\r\nif (pipe == 2)\r\ngen_fifo_stat_reg += MIPIC_REG_OFFSET;\r\nudelay(500);\r\nwhile ((timeout < 20000) && ((REG_READ(gen_fifo_stat_reg) & DPI_FIFO_EMPTY)\r\n!= DPI_FIFO_EMPTY)) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\ndev_warn(dev->dev, "MIPI: DPI FIFO was never cleared!\n");\r\n}\r\nstatic void mdfld_wait_for_SPL_PKG_SENT(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 intr_stat_reg = MIPIA_INTR_STAT_REG;\r\nint timeout = 0;\r\nif (pipe == 2)\r\nintr_stat_reg += MIPIC_REG_OFFSET;\r\nudelay(500);\r\nwhile ((timeout < 20000) && (!(REG_READ(intr_stat_reg) & DSI_INTR_STATE_SPL_PKG_SENT))) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\ndev_warn(dev->dev, "MIPI: SPL_PKT_SENT_INTERRUPT was not sent successfully!\n");\r\n}\r\nvoid mdfld_dsi_tpo_ic_init(struct mdfld_dsi_config *dsi_config, u32 pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nu32 dcsChannelNumber = dsi_config->channel_num;\r\nu32 gen_data_reg = MIPIA_HS_GEN_DATA_REG;\r\nu32 gen_ctrl_reg = MIPIA_HS_GEN_CTRL_REG;\r\nu32 gen_ctrl_val = GEN_LONG_WRITE;\r\nif (pipe == 2) {\r\ngen_data_reg = HS_GEN_DATA_REG + MIPIC_REG_OFFSET;\r\ngen_ctrl_reg = HS_GEN_CTRL_REG + MIPIC_REG_OFFSET;\r\n}\r\ngen_ctrl_val |= dcsChannelNumber << DCS_CHANNEL_NUMBER_POS;\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00008036);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x02 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x005a5af0);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x005a5af1);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x005a5afc);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x770000b7);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000044);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x05 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000a0ab6);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x081010f2);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x4a070708);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000000c5);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x09 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x024003f8);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x01030a04);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x0e020220);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000004);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x0d << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x398fc3e2);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x0000916f);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x06 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000000b0);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x02 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x240242f4);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x78ee2002);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2a071050);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x507fee10);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x10300710);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x14 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x19fe07ba);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x101c0a31);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000010);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x09 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x28ff07bb);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x24280a31);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000034);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x09 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x535d05fb);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1b1a2130);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x221e180e);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x131d2120);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x535d0508);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1c1a2131);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x231f160d);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x111b2220);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x535c2008);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1f1d2433);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2c251a10);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2c34372d);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000023);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x31 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x525c0bfa);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1c1c232f);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2623190e);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x18212625);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x545d0d0e);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1e1d2333);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x26231a10);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1a222725);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x545d280f);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x21202635);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x31292013);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x31393d33);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000029);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x31 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000100f7);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\n}\r\nstatic u16 mdfld_dsi_dpi_to_byte_clock_count(int pixel_clock_count,\r\nint num_lane, int bpp)\r\n{\r\nreturn (u16)((pixel_clock_count * bpp) / (num_lane * 8));\r\n}\r\nint mdfld_dsi_dpi_timing_calculation(struct drm_display_mode *mode,\r\nstruct mdfld_dsi_dpi_timing *dpi_timing,\r\nint num_lane, int bpp)\r\n{\r\nint pclk_hsync, pclk_hfp, pclk_hbp, pclk_hactive;\r\nint pclk_vsync, pclk_vfp, pclk_vbp, pclk_vactive;\r\nif(!mode || !dpi_timing) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn -EINVAL;\r\n}\r\npclk_hactive = mode->hdisplay;\r\npclk_hfp = mode->hsync_start - mode->hdisplay;\r\npclk_hsync = mode->hsync_end - mode->hsync_start;\r\npclk_hbp = mode->htotal - mode->hsync_end;\r\npclk_vactive = mode->vdisplay;\r\npclk_vfp = mode->vsync_start - mode->vdisplay;\r\npclk_vsync = mode->vsync_end - mode->vsync_start;\r\npclk_vbp = mode->vtotal - mode->vsync_end;\r\ndpi_timing->hsync_count = mdfld_dsi_dpi_to_byte_clock_count(pclk_hsync, num_lane, bpp);\r\ndpi_timing->hbp_count = mdfld_dsi_dpi_to_byte_clock_count(pclk_hbp, num_lane, bpp);\r\ndpi_timing->hfp_count = mdfld_dsi_dpi_to_byte_clock_count(pclk_hfp, num_lane, bpp);\r\ndpi_timing->hactive_count = mdfld_dsi_dpi_to_byte_clock_count(pclk_hactive, num_lane, bpp);\r\ndpi_timing->vsync_count = mdfld_dsi_dpi_to_byte_clock_count(pclk_vsync, num_lane, bpp);\r\ndpi_timing->vbp_count = mdfld_dsi_dpi_to_byte_clock_count(pclk_vbp, num_lane, bpp);\r\ndpi_timing->vfp_count = mdfld_dsi_dpi_to_byte_clock_count(pclk_vfp, num_lane, bpp);\r\nreturn 0;\r\n}\r\nvoid mdfld_dsi_dpi_controller_init(struct mdfld_dsi_config *dsi_config, int pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nu32 reg_offset = pipe ? MIPIC_REG_OFFSET : 0;\r\nint lane_count = dsi_config->lane_count;\r\nstruct mdfld_dsi_dpi_timing dpi_timing;\r\nstruct drm_display_mode *mode = dsi_config->mode;\r\nu32 val = 0;\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_CONTROL_REG + reg_offset), 0x00000018);\r\nREG_WRITE((MIPIA_INTR_EN_REG + reg_offset), 0xffffffff);\r\nval |= lane_count;\r\nval |= dsi_config->channel_num << DSI_DPI_VIRT_CHANNEL_OFFSET;\r\nswitch(dsi_config->bpp) {\r\ncase 16:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB565;\r\nbreak;\r\ncase 18:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB666;\r\nbreak;\r\ncase 24:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB888;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported color format, bpp = %d\n", dsi_config->bpp);\r\n}\r\nREG_WRITE((MIPIA_DSI_FUNC_PRG_REG + reg_offset), val);\r\nREG_WRITE((MIPIA_HS_TX_TIMEOUT_REG + reg_offset),\r\n(mode->vtotal * mode->htotal * dsi_config->bpp / (8 * lane_count)) & DSI_HS_TX_TIMEOUT_MASK);\r\nREG_WRITE((MIPIA_LP_RX_TIMEOUT_REG + reg_offset), 0xffff & DSI_LP_RX_TIMEOUT_MASK);\r\nREG_WRITE((MIPIA_TURN_AROUND_TIMEOUT_REG + reg_offset), 0x14 & DSI_TURN_AROUND_TIMEOUT_MASK);\r\nREG_WRITE((MIPIA_DEVICE_RESET_TIMER_REG + reg_offset), 0xffff & DSI_RESET_TIMER_MASK);\r\nREG_WRITE((MIPIA_DPI_RESOLUTION_REG + reg_offset), mode->vdisplay << 16 | mode->hdisplay);\r\nmdfld_dsi_dpi_timing_calculation(mode, &dpi_timing, dsi_config->lane_count, dsi_config->bpp);\r\nREG_WRITE((MIPIA_HSYNC_COUNT_REG + reg_offset), dpi_timing.hsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HBP_COUNT_REG + reg_offset), dpi_timing.hbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HFP_COUNT_REG + reg_offset), dpi_timing.hfp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HACTIVE_COUNT_REG + reg_offset), dpi_timing.hactive_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_VSYNC_COUNT_REG + reg_offset), dpi_timing.vsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_VBP_COUNT_REG + reg_offset), dpi_timing.vbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_VFP_COUNT_REG + reg_offset), dpi_timing.vfp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE((MIPIA_HIGH_LOW_SWITCH_COUNT_REG + reg_offset), 0x46);\r\nREG_WRITE((MIPIA_INIT_COUNT_REG + reg_offset), 0x000007d0);\r\nval = 0;\r\nval = dsi_config->video_mode | DSI_DPI_COMPLETE_LAST_LINE;\r\nREG_WRITE((MIPIA_VIDEO_MODE_FORMAT_REG + reg_offset), val);\r\nREG_WRITE((MIPIA_EOT_DISABLE_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_LP_BYTECLK_REG + reg_offset), 0x00000004);\r\nREG_WRITE((MIPIA_DPHY_PARAM_REG + reg_offset), 0x150c3408);\r\nREG_WRITE((MIPIA_CLK_LANE_SWITCH_TIME_CNT_REG + reg_offset), (0xa << 16) | 0x14);\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000001);\r\n}\r\nvoid mdfld_dsi_dpi_turn_on(struct mdfld_dsi_dpi_output *output, int pipe)\r\n{\r\nstruct drm_device *dev = output->dev;\r\nu32 reg_offset = 0;\r\nif(output->panel_on)\r\nreturn;\r\nif(pipe)\r\nreg_offset = MIPIC_REG_OFFSET;\r\nif(REG_READ(MIPIA_INTR_STAT_REG + reg_offset) & DSI_INTR_STATE_SPL_PKG_SENT) {\r\nREG_WRITE((MIPIA_INTR_STAT_REG + reg_offset), DSI_INTR_STATE_SPL_PKG_SENT);\r\n}\r\nREG_WRITE((MIPIA_DPI_CONTROL_REG + reg_offset), DSI_DPI_CTRL_HS_TURN_ON);\r\nmdfld_wait_for_SPL_PKG_SENT(dev, pipe);\r\nif(REG_READ(MIPIA_INTR_STAT_REG + reg_offset) & DSI_INTR_STATE_SPL_PKG_SENT) {\r\nREG_WRITE((MIPIA_INTR_STAT_REG + reg_offset), DSI_INTR_STATE_SPL_PKG_SENT);\r\n}\r\noutput->panel_on = 1;\r\n}\r\nstatic void mdfld_dsi_dpi_shut_down(struct mdfld_dsi_dpi_output *output, int pipe)\r\n{\r\nstruct drm_device *dev = output->dev;\r\nu32 reg_offset = 0;\r\nif((!output->panel_on) || output->first_boot) {\r\noutput->first_boot = 0;\r\nreturn;\r\n}\r\nif(pipe)\r\nreg_offset = MIPIC_REG_OFFSET;\r\nmdfld_wait_for_DPI_CTRL_FIFO(dev, pipe);\r\nif(REG_READ(MIPIA_INTR_STAT_REG + reg_offset) & DSI_INTR_STATE_SPL_PKG_SENT) {\r\nREG_WRITE((MIPIA_INTR_STAT_REG + reg_offset), DSI_INTR_STATE_SPL_PKG_SENT);\r\n}\r\nif(REG_READ(MIPIA_DPI_CONTROL_REG + reg_offset) == DSI_DPI_CTRL_HS_SHUTDOWN) {\r\ndev_warn(dev->dev, "try to send the same package again, abort!");\r\ngoto shutdown_out;\r\n}\r\nREG_WRITE((MIPIA_DPI_CONTROL_REG + reg_offset), DSI_DPI_CTRL_HS_SHUTDOWN);\r\nshutdown_out:\r\noutput->panel_on = 0;\r\noutput->first_boot = 0;\r\n}\r\nvoid mdfld_dsi_dpi_set_power(struct drm_encoder *encoder, bool on)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dpi_output *dpi_output = MDFLD_DSI_DPI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config = mdfld_dsi_encoder_get_config(dsi_encoder);\r\nint pipe = mdfld_dsi_encoder_get_pipe(dsi_encoder);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 mipi_reg = MIPI;\r\nu32 pipeconf_reg = PIPEACONF;\r\nif(pipe) {\r\nmipi_reg = MIPI_C;\r\npipeconf_reg = PIPECCONF;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nif(on) {\r\nif (mdfld_get_panel_type(dev, pipe) == TMD_VID){\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\n} else {\r\nREG_WRITE(mipi_reg, (REG_READ(mipi_reg) | (1 << 31)));\r\nREG_READ(mipi_reg);\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\nmdfld_dsi_tpo_ic_init(dsi_config, pipe);\r\n}\r\nif(pipe == 2) {\r\ndev_priv->dpi_panel_on2 = true;\r\n}\r\nelse {\r\ndev_priv->dpi_panel_on = true;\r\n}\r\n} else {\r\nif (mdfld_get_panel_type(dev, pipe) == TMD_VID) {\r\nmdfld_dsi_dpi_shut_down(dpi_output, pipe);\r\n} else {\r\nmdfld_dsi_dpi_shut_down(dpi_output, pipe);\r\nREG_WRITE(mipi_reg, (REG_READ(mipi_reg) & ~(1<<31)));\r\nREG_READ(mipi_reg);\r\n}\r\nif(pipe == 2)\r\ndev_priv->dpi_panel_on2 = false;\r\nelse\r\ndev_priv->dpi_panel_on = false;\r\n}\r\ngma_power_end(dev);\r\n}\r\nvoid mdfld_dsi_dpi_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\ndev_dbg(encoder->dev->dev, "DPMS %s\n",\r\n(mode == DRM_MODE_DPMS_ON ? "on":"off"));\r\nif (mode == DRM_MODE_DPMS_ON)\r\nmdfld_dsi_dpi_set_power(encoder, true);\r\nelse {\r\nmdfld_dsi_dpi_set_power(encoder, false);\r\n#if 0\r\n#ifdef CONFIG_PM_RUNTIME\r\nif (enable_gfx_rtpm)\r\npm_schedule_suspend(&gpDrmDevice->pdev->dev, gfxrtdelay);\r\n#endif\r\n#endif\r\n}\r\n}\r\nbool mdfld_dsi_dpi_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_config *dsi_config = mdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct drm_display_mode *fixed_mode = dsi_config->fixed_mode;\r\nif(fixed_mode) {\r\nadjusted_mode->hdisplay = fixed_mode->hdisplay;\r\nadjusted_mode->hsync_start = fixed_mode->hsync_start;\r\nadjusted_mode->hsync_end = fixed_mode->hsync_end;\r\nadjusted_mode->htotal = fixed_mode->htotal;\r\nadjusted_mode->vdisplay = fixed_mode->vdisplay;\r\nadjusted_mode->vsync_start = fixed_mode->vsync_start;\r\nadjusted_mode->vsync_end = fixed_mode->vsync_end;\r\nadjusted_mode->vtotal = fixed_mode->vtotal;\r\nadjusted_mode->clock = fixed_mode->clock;\r\ndrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\r\n}\r\nreturn true;\r\n}\r\nvoid mdfld_dsi_dpi_prepare(struct drm_encoder *encoder)\r\n{\r\nmdfld_dsi_dpi_set_power(encoder, false);\r\n}\r\nvoid mdfld_dsi_dpi_commit(struct drm_encoder *encoder)\r\n{\r\nmdfld_dsi_dpi_set_power(encoder, true);\r\n}\r\nvoid mdfld_dsi_dpi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = MDFLD_DSI_ENCODER(encoder);\r\nstruct mdfld_dsi_dpi_output *dpi_output = MDFLD_DSI_DPI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config = mdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint pipe = mdfld_dsi_encoder_get_pipe(dsi_encoder);\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 mipi_reg = MIPI;\r\nu32 reg_offset = 0;\r\nu32 pipeconf = dev_priv->pipeconf;\r\nu32 dspcntr = dev_priv->dspcntr;\r\nu32 mipi = MIPI_PORT_EN | PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX;\r\ndev_dbg(dev->dev, "set mode %dx%d on pipe %d\n",\r\nmode->hdisplay, mode->vdisplay, pipe);\r\nif(pipe) {\r\npipeconf_reg = PIPECCONF;\r\ndspcntr_reg = DSPCCNTR;\r\nmipi_reg = MIPI_C;\r\nreg_offset = MIPIC_REG_OFFSET;\r\n} else {\r\nmipi |= 2;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nREG_WRITE(mipi_reg, mipi);\r\nREG_READ(mipi_reg);\r\nmdfld_dsi_dpi_controller_init(dsi_config, pipe);\r\nif (mdfld_get_panel_type(dev, pipe) != TMD_VID) {\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\n}\r\nREG_WRITE(pipeconf_reg, pipeconf);\r\nREG_READ(pipeconf_reg);\r\nREG_WRITE(dspcntr_reg, dspcntr);\r\nREG_READ(dspcntr_reg);\r\nmsleep(20);\r\ndev_dbg(dev->dev, "State %x, power %d\n",\r\nREG_READ(MIPIA_INTR_STAT_REG + reg_offset),\r\ndpi_output->panel_on);\r\nif (mdfld_get_panel_type(dev, pipe) != TMD_VID) {\r\nmdfld_dsi_tpo_ic_init(dsi_config, pipe);\r\nmdfld_dsi_brightness_init(dsi_config, pipe);\r\n}\r\ngma_power_end(dev);\r\n}\r\nstruct mdfld_dsi_encoder *mdfld_dsi_dpi_init(struct drm_device *dev,\r\nstruct mdfld_dsi_connector *dsi_connector,\r\nstruct panel_funcs *p_funcs)\r\n{\r\nstruct mdfld_dsi_dpi_output *dpi_output = NULL;\r\nstruct mdfld_dsi_config *dsi_config;\r\nstruct drm_connector *connector = NULL;\r\nstruct drm_encoder *encoder = NULL;\r\nstruct drm_display_mode *fixed_mode = NULL;\r\nint pipe;\r\nu32 data;\r\nint ret;\r\nif (!dsi_connector || !p_funcs) {\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\ndsi_config = mdfld_dsi_get_config(dsi_connector);\r\npipe = dsi_connector->pipe;\r\nif (p_funcs->reset) {\r\nret = p_funcs->reset(pipe);\r\nif (ret) {\r\nDRM_ERROR("Panel %d hard-reset failed\n", pipe);\r\nreturn NULL;\r\n}\r\n}\r\nif (p_funcs->drv_ic_init)\r\np_funcs->drv_ic_init(dsi_config, pipe);\r\nret = mdfld_dsi_get_power_mode(dsi_config,\r\n&data,\r\nMDFLD_DSI_LP_TRANSMISSION);\r\nif (ret) {\r\nDRM_ERROR("Panel %d get power mode failed\n", pipe);\r\ndsi_connector->status = connector_status_disconnected;\r\n} else {\r\nDRM_INFO("pipe %d power mode 0x%x\n", pipe, data);\r\ndsi_connector->status = connector_status_connected;\r\n}\r\ndpi_output = kzalloc(sizeof(struct mdfld_dsi_dpi_output), GFP_KERNEL);\r\nif(!dpi_output) {\r\ndev_err(dev->dev, "No memory for dsi_dpi_output\n");\r\nreturn NULL;\r\n}\r\nif(dsi_connector->pipe)\r\ndpi_output->panel_on = 0;\r\nelse\r\ndpi_output->panel_on = 0;\r\ndpi_output->dev = dev;\r\ndpi_output->p_funcs = p_funcs;\r\ndpi_output->first_boot = 1;\r\ndsi_config = mdfld_dsi_get_config(dsi_connector);\r\nfixed_mode = dsi_config->fixed_mode;\r\nconnector = &dsi_connector->base.base;\r\nencoder = &dpi_output->base.base;\r\ndrm_encoder_init(dev,\r\nencoder,\r\np_funcs->encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\ndrm_encoder_helper_add(encoder,\r\np_funcs->encoder_helper_funcs);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nif(dsi_connector->pipe) {\r\nencoder->possible_crtcs = (1 << 2);\r\nencoder->possible_clones = (1 << 1);\r\n} else {\r\nencoder->possible_crtcs = (1 << 0);\r\nencoder->possible_clones = (1 << 0);\r\n}\r\nreturn &dpi_output->base;\r\n}
