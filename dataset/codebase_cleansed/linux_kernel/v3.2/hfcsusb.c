static void\r\nctrl_start_transfer(struct hfcsusb *hw)\r\n{\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s\n", hw->name, __func__);\r\nif (hw->ctrl_cnt) {\r\nhw->ctrl_urb->pipe = hw->ctrl_out_pipe;\r\nhw->ctrl_urb->setup_packet = (u_char *)&hw->ctrl_write;\r\nhw->ctrl_urb->transfer_buffer = NULL;\r\nhw->ctrl_urb->transfer_buffer_length = 0;\r\nhw->ctrl_write.wIndex =\r\ncpu_to_le16(hw->ctrl_buff[hw->ctrl_out_idx].hfcs_reg);\r\nhw->ctrl_write.wValue =\r\ncpu_to_le16(hw->ctrl_buff[hw->ctrl_out_idx].reg_val);\r\nusb_submit_urb(hw->ctrl_urb, GFP_ATOMIC);\r\n}\r\n}\r\nstatic int write_reg(struct hfcsusb *hw, __u8 reg, __u8 val)\r\n{\r\nstruct ctrl_buf *buf;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s reg(0x%02x) val(0x%02x)\n",\r\nhw->name, __func__, reg, val);\r\nspin_lock(&hw->ctrl_lock);\r\nif (hw->ctrl_cnt >= HFC_CTRL_BUFSIZE) {\r\nspin_unlock(&hw->ctrl_lock);\r\nreturn 1;\r\n}\r\nbuf = &hw->ctrl_buff[hw->ctrl_in_idx];\r\nbuf->hfcs_reg = reg;\r\nbuf->reg_val = val;\r\nif (++hw->ctrl_in_idx >= HFC_CTRL_BUFSIZE)\r\nhw->ctrl_in_idx = 0;\r\nif (++hw->ctrl_cnt == 1)\r\nctrl_start_transfer(hw);\r\nspin_unlock(&hw->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nctrl_complete(struct urb *urb)\r\n{\r\nstruct hfcsusb *hw = (struct hfcsusb *) urb->context;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s\n", hw->name, __func__);\r\nurb->dev = hw->dev;\r\nif (hw->ctrl_cnt) {\r\nhw->ctrl_cnt--;\r\nif (++hw->ctrl_out_idx >= HFC_CTRL_BUFSIZE)\r\nhw->ctrl_out_idx = 0;\r\nctrl_start_transfer(hw);\r\n}\r\n}\r\nstatic void\r\nset_led_bit(struct hfcsusb *hw, signed short led_bits, int set_on)\r\n{\r\nif (set_on) {\r\nif (led_bits < 0)\r\nhw->led_state &= ~abs(led_bits);\r\nelse\r\nhw->led_state |= led_bits;\r\n} else {\r\nif (led_bits < 0)\r\nhw->led_state |= abs(led_bits);\r\nelse\r\nhw->led_state &= ~led_bits;\r\n}\r\n}\r\nstatic void\r\nhandle_led(struct hfcsusb *hw, int event)\r\n{\r\nstruct hfcsusb_vdata *driver_info = (struct hfcsusb_vdata *)\r\nhfcsusb_idtab[hw->vend_idx].driver_info;\r\n__u8 tmpled;\r\nif (driver_info->led_scheme == LED_OFF)\r\nreturn;\r\ntmpled = hw->led_state;\r\nswitch (event) {\r\ncase LED_POWER_ON:\r\nset_led_bit(hw, driver_info->led_bits[0], 1);\r\nset_led_bit(hw, driver_info->led_bits[1], 0);\r\nset_led_bit(hw, driver_info->led_bits[2], 0);\r\nset_led_bit(hw, driver_info->led_bits[3], 0);\r\nbreak;\r\ncase LED_POWER_OFF:\r\nset_led_bit(hw, driver_info->led_bits[0], 0);\r\nset_led_bit(hw, driver_info->led_bits[1], 0);\r\nset_led_bit(hw, driver_info->led_bits[2], 0);\r\nset_led_bit(hw, driver_info->led_bits[3], 0);\r\nbreak;\r\ncase LED_S0_ON:\r\nset_led_bit(hw, driver_info->led_bits[1], 1);\r\nbreak;\r\ncase LED_S0_OFF:\r\nset_led_bit(hw, driver_info->led_bits[1], 0);\r\nbreak;\r\ncase LED_B1_ON:\r\nset_led_bit(hw, driver_info->led_bits[2], 1);\r\nbreak;\r\ncase LED_B1_OFF:\r\nset_led_bit(hw, driver_info->led_bits[2], 0);\r\nbreak;\r\ncase LED_B2_ON:\r\nset_led_bit(hw, driver_info->led_bits[3], 1);\r\nbreak;\r\ncase LED_B2_OFF:\r\nset_led_bit(hw, driver_info->led_bits[3], 0);\r\nbreak;\r\n}\r\nif (hw->led_state != tmpled) {\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s reg(0x%02x) val(x%02x)\n",\r\nhw->name, __func__,\r\nHFCUSB_P_DATA, hw->led_state);\r\nwrite_reg(hw, HFCUSB_P_DATA, hw->led_state);\r\n}\r\n}\r\nstatic int\r\nhfcusb_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct hfcsusb *hw = bch->hw;\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nu_long flags;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s\n", hw->name, __func__);\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(&hw->lock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s PH_DATA_REQ ret(%i)\n",\r\nhw->name, __func__, ret);\r\nif (ret > 0) {\r\nqueue_ch_frame(ch, PH_DATA_CNF, hh->id, NULL);\r\nret = 0;\r\n}\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags)) {\r\nhfcsusb_start_endpoint(hw, bch->nr);\r\nret = hfcsusb_setup_bch(bch, ch->protocol);\r\n} else\r\nret = 0;\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\ndeactivate_bchannel(bch);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\nret = 0;\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic void\r\nhfcsusb_ph_info(struct hfcsusb *hw)\r\n{\r\nstruct ph_info *phi;\r\nstruct dchannel *dch = &hw->dch;\r\nint i;\r\nphi = kzalloc(sizeof(struct ph_info) +\r\ndch->dev.nrbchan * sizeof(struct ph_info_ch), GFP_ATOMIC);\r\nphi->dch.ch.protocol = hw->protocol;\r\nphi->dch.ch.Flags = dch->Flags;\r\nphi->dch.state = dch->state;\r\nphi->dch.num_bch = dch->dev.nrbchan;\r\nfor (i = 0; i < dch->dev.nrbchan; i++) {\r\nphi->bch[i].protocol = hw->bch[i].ch.protocol;\r\nphi->bch[i].Flags = hw->bch[i].Flags;\r\n}\r\n_queue_data(&dch->dev.D, MPH_INFORMATION_IND, MISDN_ID_ANY,\r\nsizeof(struct ph_info_dch) + dch->dev.nrbchan *\r\nsizeof(struct ph_info_ch), phi, GFP_ATOMIC);\r\nkfree(phi);\r\n}\r\nstatic int\r\nhfcusb_l2l1D(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nstruct hfcsusb *hw = dch->hw;\r\nint ret = -EINVAL;\r\nu_long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s: PH_DATA_REQ\n",\r\nhw->name, __func__);\r\nspin_lock_irqsave(&hw->lock, flags);\r\nret = dchannel_senddata(dch, skb);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nif (ret > 0) {\r\nret = 0;\r\nqueue_ch_frame(ch, PH_DATA_CNF, hh->id, NULL);\r\n}\r\nbreak;\r\ncase PH_ACTIVATE_REQ:\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s: PH_ACTIVATE_REQ %s\n",\r\nhw->name, __func__,\r\n(hw->protocol == ISDN_P_NT_S0) ? "NT" : "TE");\r\nif (hw->protocol == ISDN_P_NT_S0) {\r\nret = 0;\r\nif (test_bit(FLG_ACTIVE, &dch->Flags)) {\r\n_queue_data(&dch->dev.D,\r\nPH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_ATOMIC);\r\n} else {\r\nhfcsusb_ph_command(hw,\r\nHFC_L1_ACTIVATE_NT);\r\ntest_and_set_bit(FLG_L2_ACTIVATED,\r\n&dch->Flags);\r\n}\r\n} else {\r\nhfcsusb_ph_command(hw, HFC_L1_ACTIVATE_TE);\r\nret = l1_event(dch->l1, hh->prim);\r\n}\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s: PH_DEACTIVATE_REQ\n",\r\nhw->name, __func__);\r\ntest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\nif (hw->protocol == ISDN_P_NT_S0) {\r\nhfcsusb_ph_command(hw, HFC_L1_DEACTIVATE_NT);\r\nspin_lock_irqsave(&hw->lock, flags);\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n#ifdef FIXME\r\nif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\r\ndchannel_sched_event(&hc->dch, D_CLEARBUSY);\r\n#endif\r\nret = 0;\r\n} else\r\nret = l1_event(dch->l1, hh->prim);\r\nbreak;\r\ncase MPH_INFORMATION_REQ:\r\nhfcsusb_ph_info(hw);\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nhfc_l1callback(struct dchannel *dch, u_int cmd)\r\n{\r\nstruct hfcsusb *hw = dch->hw;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s cmd 0x%x\n",\r\nhw->name, __func__, cmd);\r\nswitch (cmd) {\r\ncase INFO3_P8:\r\ncase INFO3_P10:\r\ncase HW_RESET_REQ:\r\ncase HW_POWERUP_REQ:\r\nbreak;\r\ncase HW_DEACT_REQ:\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nbreak;\r\ncase PH_ACTIVATE_IND:\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase PH_DEACTIVATE_IND:\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ndefault:\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: unknown cmd %x\n",\r\nhw->name, __func__, cmd);\r\nreturn -1;\r\n}\r\nhfcsusb_ph_info(hw);\r\nreturn 0;\r\n}\r\nstatic int\r\nopen_dchannel(struct hfcsusb *hw, struct mISDNchannel *ch,\r\nstruct channel_req *rq)\r\n{\r\nint err = 0;\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: %s: dev(%d) open addr(%i) from %p\n",\r\nhw->name, __func__, hw->dch.dev.id, rq->adr.channel,\r\n__builtin_return_address(0));\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\ntest_and_clear_bit(FLG_ACTIVE, &hw->dch.Flags);\r\ntest_and_clear_bit(FLG_ACTIVE, &hw->ech.Flags);\r\nhfcsusb_start_endpoint(hw, HFC_CHAN_D);\r\nif (rq->adr.channel == 1) {\r\nif (hw->fifos[HFCUSB_PCM_RX].pipe) {\r\nhfcsusb_start_endpoint(hw, HFC_CHAN_E);\r\nset_bit(FLG_ACTIVE, &hw->ech.Flags);\r\n_queue_data(&hw->ech.dev.D, PH_ACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nif (!hw->initdone) {\r\nhw->protocol = rq->protocol;\r\nif (rq->protocol == ISDN_P_TE_S0) {\r\nerr = create_l1(&hw->dch, hfc_l1callback);\r\nif (err)\r\nreturn err;\r\n}\r\nsetPortMode(hw);\r\nch->protocol = rq->protocol;\r\nhw->initdone = 1;\r\n} else {\r\nif (rq->protocol != ch->protocol)\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nif (((ch->protocol == ISDN_P_NT_S0) && (hw->dch.state == 3)) ||\r\n((ch->protocol == ISDN_P_TE_S0) && (hw->dch.state == 7)))\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\nrq->ch = ch;\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s: %s: cannot get module\n",\r\nhw->name, __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nopen_bchannel(struct hfcsusb *hw, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nif (rq->adr.channel > 2)\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s B%i\n",\r\nhw->name, __func__, rq->adr.channel);\r\nbch = &hw->bch[rq->adr.channel - 1];\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\ntest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nif (rq->adr.channel == 1)\r\nhfcsusb_start_endpoint(hw, HFC_CHAN_B1);\r\nelse\r\nhfcsusb_start_endpoint(hw, HFC_CHAN_B2);\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s: %s:cannot get module\n",\r\nhw->name, __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nchannel_ctrl(struct hfcsusb *hw, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s op(0x%x) channel(0x%x)\n",\r\nhw->name, __func__, (cq->op), (cq->channel));\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_LOOP | MISDN_CTRL_CONNECT |\r\nMISDN_CTRL_DISCONNECT;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: %s: unknown Op %x\n",\r\nhw->name, __func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nhfc_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct hfcsusb *hw = dch->hw;\r\nstruct channel_req *rq;\r\nint err = 0;\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: cmd:%x %p\n",\r\nhw->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nif ((rq->protocol == ISDN_P_TE_S0) ||\r\n(rq->protocol == ISDN_P_NT_S0))\r\nerr = open_dchannel(hw, ch, rq);\r\nelse\r\nerr = open_bchannel(hw, rq);\r\nif (!err)\r\nhw->open++;\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nhw->open--;\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG\r\n"%s: %s: dev(%d) close from %p (open %d)\n",\r\nhw->name, __func__, hw->dch.dev.id,\r\n__builtin_return_address(0), hw->open);\r\nif (!hw->open) {\r\nhfcsusb_stop_endpoint(hw, HFC_CHAN_D);\r\nif (hw->fifos[HFCUSB_PCM_RX].pipe)\r\nhfcsusb_stop_endpoint(hw, HFC_CHAN_E);\r\nhandle_led(hw, LED_POWER_ON);\r\n}\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_ctrl(hw, arg);\r\nbreak;\r\ndefault:\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: unknown command %x\n",\r\nhw->name, __func__, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nph_state_te(struct dchannel *dch)\r\n{\r\nstruct hfcsusb *hw = dch->hw;\r\nif (debug & DEBUG_HW) {\r\nif (dch->state <= HFC_MAX_TE_LAYER1_STATE)\r\nprintk(KERN_DEBUG "%s: %s: %s\n", hw->name, __func__,\r\nHFC_TE_LAYER1_STATES[dch->state]);\r\nelse\r\nprintk(KERN_DEBUG "%s: %s: TE F%d\n",\r\nhw->name, __func__, dch->state);\r\n}\r\nswitch (dch->state) {\r\ncase 0:\r\nl1_event(dch->l1, HW_RESET_IND);\r\nbreak;\r\ncase 3:\r\nl1_event(dch->l1, HW_DEACT_IND);\r\nbreak;\r\ncase 5:\r\ncase 8:\r\nl1_event(dch->l1, ANYSIGNAL);\r\nbreak;\r\ncase 6:\r\nl1_event(dch->l1, INFO2);\r\nbreak;\r\ncase 7:\r\nl1_event(dch->l1, INFO4_P8);\r\nbreak;\r\n}\r\nif (dch->state == 7)\r\nhandle_led(hw, LED_S0_ON);\r\nelse\r\nhandle_led(hw, LED_S0_OFF);\r\n}\r\nstatic void\r\nph_state_nt(struct dchannel *dch)\r\n{\r\nstruct hfcsusb *hw = dch->hw;\r\nif (debug & DEBUG_HW) {\r\nif (dch->state <= HFC_MAX_NT_LAYER1_STATE)\r\nprintk(KERN_DEBUG "%s: %s: %s\n",\r\nhw->name, __func__,\r\nHFC_NT_LAYER1_STATES[dch->state]);\r\nelse\r\nprintk(KERN_INFO DRIVER_NAME "%s: %s: NT G%d\n",\r\nhw->name, __func__, dch->state);\r\n}\r\nswitch (dch->state) {\r\ncase (1):\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\ntest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\nhw->nt_timer = 0;\r\nhw->timers &= ~NT_ACTIVATION_TIMER;\r\nhandle_led(hw, LED_S0_OFF);\r\nbreak;\r\ncase (2):\r\nif (hw->nt_timer < 0) {\r\nhw->nt_timer = 0;\r\nhw->timers &= ~NT_ACTIVATION_TIMER;\r\nhfcsusb_ph_command(dch->hw, HFC_L1_DEACTIVATE_NT);\r\n} else {\r\nhw->timers |= NT_ACTIVATION_TIMER;\r\nhw->nt_timer = NT_T1_COUNT;\r\nwrite_reg(hw, HFCUSB_STATES, 2 | HFCUSB_NT_G2_G3);\r\n}\r\nbreak;\r\ncase (3):\r\nhw->nt_timer = 0;\r\nhw->timers &= ~NT_ACTIVATION_TIMER;\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\nhandle_led(hw, LED_S0_ON);\r\nbreak;\r\ncase (4):\r\nhw->nt_timer = 0;\r\nhw->timers &= ~NT_ACTIVATION_TIMER;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nhfcsusb_ph_info(hw);\r\n}\r\nstatic void\r\nph_state(struct dchannel *dch)\r\n{\r\nstruct hfcsusb *hw = dch->hw;\r\nif (hw->protocol == ISDN_P_NT_S0)\r\nph_state_nt(dch);\r\nelse if (hw->protocol == ISDN_P_TE_S0)\r\nph_state_te(dch);\r\n}\r\nstatic int\r\nhfcsusb_setup_bch(struct bchannel *bch, int protocol)\r\n{\r\nstruct hfcsusb *hw = bch->hw;\r\n__u8 conhdlc, sctrl, sctrl_r;\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: protocol %x-->%x B%d\n",\r\nhw->name, __func__, bch->state, protocol,\r\nbch->nr);\r\nconhdlc = 0;\r\nif (protocol > ISDN_P_NONE)\r\nconhdlc = 8;\r\nswitch (protocol) {\r\ncase (-1):\r\nbch->state = -1;\r\ncase (ISDN_P_NONE):\r\nif (bch->state == ISDN_P_NONE)\r\nreturn 0;\r\nbch->state = ISDN_P_NONE;\r\nclear_bit(FLG_HDLC, &bch->Flags);\r\nclear_bit(FLG_TRANSPARENT, &bch->Flags);\r\nbreak;\r\ncase (ISDN_P_B_RAW):\r\nconhdlc |= 2;\r\nbch->state = protocol;\r\nset_bit(FLG_TRANSPARENT, &bch->Flags);\r\nbreak;\r\ncase (ISDN_P_B_HDLC):\r\nbch->state = protocol;\r\nset_bit(FLG_HDLC, &bch->Flags);\r\nbreak;\r\ndefault:\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: prot not known %x\n",\r\nhw->name, __func__, protocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (protocol >= ISDN_P_NONE) {\r\nwrite_reg(hw, HFCUSB_FIFO, (bch->nr == 1) ? 0 : 2);\r\nwrite_reg(hw, HFCUSB_CON_HDLC, conhdlc);\r\nwrite_reg(hw, HFCUSB_INC_RES_F, 2);\r\nwrite_reg(hw, HFCUSB_FIFO, (bch->nr == 1) ? 1 : 3);\r\nwrite_reg(hw, HFCUSB_CON_HDLC, conhdlc);\r\nwrite_reg(hw, HFCUSB_INC_RES_F, 2);\r\nsctrl = 0x40 + ((hw->protocol == ISDN_P_TE_S0) ? 0x00 : 0x04);\r\nsctrl_r = 0x0;\r\nif (test_bit(FLG_ACTIVE, &hw->bch[0].Flags)) {\r\nsctrl |= 1;\r\nsctrl_r |= 1;\r\n}\r\nif (test_bit(FLG_ACTIVE, &hw->bch[1].Flags)) {\r\nsctrl |= 2;\r\nsctrl_r |= 2;\r\n}\r\nwrite_reg(hw, HFCUSB_SCTRL, sctrl);\r\nwrite_reg(hw, HFCUSB_SCTRL_R, sctrl_r);\r\nif (protocol > ISDN_P_NONE)\r\nhandle_led(hw, (bch->nr == 1) ? LED_B1_ON : LED_B2_ON);\r\nelse\r\nhandle_led(hw, (bch->nr == 1) ? LED_B1_OFF :\r\nLED_B2_OFF);\r\n}\r\nhfcsusb_ph_info(hw);\r\nreturn 0;\r\n}\r\nstatic void\r\nhfcsusb_ph_command(struct hfcsusb *hw, u_char command)\r\n{\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: %x\n",\r\nhw->name, __func__, command);\r\nswitch (command) {\r\ncase HFC_L1_ACTIVATE_TE:\r\nwrite_reg(hw, HFCUSB_STATES, 0x14);\r\nwrite_reg(hw, HFCUSB_STATES, 0x04);\r\nbreak;\r\ncase HFC_L1_FORCE_DEACTIVATE_TE:\r\nwrite_reg(hw, HFCUSB_STATES, 0x10);\r\nwrite_reg(hw, HFCUSB_STATES, 0x03);\r\nbreak;\r\ncase HFC_L1_ACTIVATE_NT:\r\nif (hw->dch.state == 3)\r\n_queue_data(&hw->dch.dev.D, PH_ACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\nelse\r\nwrite_reg(hw, HFCUSB_STATES, HFCUSB_ACTIVATE |\r\nHFCUSB_DO_ACTION | HFCUSB_NT_G2_G3);\r\nbreak;\r\ncase HFC_L1_DEACTIVATE_NT:\r\nwrite_reg(hw, HFCUSB_STATES,\r\nHFCUSB_DO_ACTION);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_FILL_EMPTY;\r\nbreak;\r\ncase MISDN_CTRL_FILL_EMPTY:\r\ntest_and_set_bit(FLG_FILLEMPTY, &bch->Flags);\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: FILL_EMPTY request (nr=%d "\r\n"off=%d)\n", __func__, bch->nr, !!cq->p1);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown Op %x\n", __func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nhfcsusb_rx_frame(struct usb_fifo *fifo, __u8 *data, unsigned int len,\r\nint finish)\r\n{\r\nstruct hfcsusb *hw = fifo->hw;\r\nstruct sk_buff *rx_skb = NULL;\r\nint maxlen = 0;\r\nint fifon = fifo->fifonum;\r\nint i;\r\nint hdlc = 0;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s: fifo(%i) len(%i) "\r\n"dch(%p) bch(%p) ech(%p)\n",\r\nhw->name, __func__, fifon, len,\r\nfifo->dch, fifo->bch, fifo->ech);\r\nif (!len)\r\nreturn;\r\nif ((!!fifo->dch + !!fifo->bch + !!fifo->ech) != 1) {\r\nprintk(KERN_DEBUG "%s: %s: undefined channel\n",\r\nhw->name, __func__);\r\nreturn;\r\n}\r\nspin_lock(&hw->lock);\r\nif (fifo->dch) {\r\nrx_skb = fifo->dch->rx_skb;\r\nmaxlen = fifo->dch->maxlen;\r\nhdlc = 1;\r\n}\r\nif (fifo->bch) {\r\nrx_skb = fifo->bch->rx_skb;\r\nmaxlen = fifo->bch->maxlen;\r\nhdlc = test_bit(FLG_HDLC, &fifo->bch->Flags);\r\n}\r\nif (fifo->ech) {\r\nrx_skb = fifo->ech->rx_skb;\r\nmaxlen = fifo->ech->maxlen;\r\nhdlc = 1;\r\n}\r\nif (!rx_skb) {\r\nrx_skb = mI_alloc_skb(maxlen, GFP_ATOMIC);\r\nif (rx_skb) {\r\nif (fifo->dch)\r\nfifo->dch->rx_skb = rx_skb;\r\nif (fifo->bch)\r\nfifo->bch->rx_skb = rx_skb;\r\nif (fifo->ech)\r\nfifo->ech->rx_skb = rx_skb;\r\nskb_trim(rx_skb, 0);\r\n} else {\r\nprintk(KERN_DEBUG "%s: %s: No mem for rx_skb\n",\r\nhw->name, __func__);\r\nspin_unlock(&hw->lock);\r\nreturn;\r\n}\r\n}\r\nif (fifo->dch || fifo->ech) {\r\nif ((rx_skb->len + len) >= MAX_DFRAME_LEN_L1) {\r\nprintk(KERN_DEBUG "%s: %s: sbk mem exceeded "\r\n"for fifo(%d) HFCUSB_D_RX\n",\r\nhw->name, __func__, fifon);\r\nskb_trim(rx_skb, 0);\r\nspin_unlock(&hw->lock);\r\nreturn;\r\n}\r\n} else if (fifo->bch) {\r\nif ((rx_skb->len + len) >= (MAX_BCH_SIZE + 3)) {\r\nprintk(KERN_DEBUG "%s: %s: sbk mem exceeded "\r\n"for fifo(%d) HFCUSB_B_RX\n",\r\nhw->name, __func__, fifon);\r\nskb_trim(rx_skb, 0);\r\nspin_unlock(&hw->lock);\r\nreturn;\r\n}\r\n}\r\nmemcpy(skb_put(rx_skb, len), data, len);\r\nif (hdlc) {\r\nif (finish) {\r\nif ((rx_skb->len > 3) &&\r\n(!(rx_skb->data[rx_skb->len - 1]))) {\r\nif (debug & DBG_HFC_FIFO_VERBOSE) {\r\nprintk(KERN_DEBUG "%s: %s: fifon(%i)"\r\n" new RX len(%i): ",\r\nhw->name, __func__, fifon,\r\nrx_skb->len);\r\ni = 0;\r\nwhile (i < rx_skb->len)\r\nprintk("%02x ",\r\nrx_skb->data[i++]);\r\nprintk("\n");\r\n}\r\nskb_trim(rx_skb, rx_skb->len - 3);\r\nif (fifo->dch)\r\nrecv_Dchannel(fifo->dch);\r\nif (fifo->bch)\r\nrecv_Bchannel(fifo->bch, MISDN_ID_ANY);\r\nif (fifo->ech)\r\nrecv_Echannel(fifo->ech,\r\n&hw->dch);\r\n} else {\r\nif (debug & DBG_HFC_FIFO_VERBOSE) {\r\nprintk(KERN_DEBUG\r\n"%s: CRC or minlen ERROR fifon(%i) "\r\n"RX len(%i): ",\r\nhw->name, fifon, rx_skb->len);\r\ni = 0;\r\nwhile (i < rx_skb->len)\r\nprintk("%02x ",\r\nrx_skb->data[i++]);\r\nprintk("\n");\r\n}\r\nskb_trim(rx_skb, 0);\r\n}\r\n}\r\n} else {\r\nif (rx_skb->len >= poll)\r\nrecv_Bchannel(fifo->bch, MISDN_ID_ANY);\r\n}\r\nspin_unlock(&hw->lock);\r\n}\r\nstatic void\r\nfill_isoc_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,\r\nvoid *buf, int num_packets, int packet_size, int interval,\r\nusb_complete_t complete, void *context)\r\n{\r\nint k;\r\nusb_fill_bulk_urb(urb, dev, pipe, buf, packet_size * num_packets,\r\ncomplete, context);\r\nurb->number_of_packets = num_packets;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->actual_length = 0;\r\nurb->interval = interval;\r\nfor (k = 0; k < num_packets; k++) {\r\nurb->iso_frame_desc[k].offset = packet_size * k;\r\nurb->iso_frame_desc[k].length = packet_size;\r\nurb->iso_frame_desc[k].actual_length = 0;\r\n}\r\n}\r\nstatic void\r\nrx_iso_complete(struct urb *urb)\r\n{\r\nstruct iso_urb *context_iso_urb = (struct iso_urb *) urb->context;\r\nstruct usb_fifo *fifo = context_iso_urb->owner_fifo;\r\nstruct hfcsusb *hw = fifo->hw;\r\nint k, len, errcode, offset, num_isoc_packets, fifon, maxlen,\r\nstatus, iso_status, i;\r\n__u8 *buf;\r\nstatic __u8 eof[8];\r\n__u8 s0_state;\r\nfifon = fifo->fifonum;\r\nstatus = urb->status;\r\nspin_lock(&hw->lock);\r\nif (fifo->stop_gracefull) {\r\nfifo->stop_gracefull = 0;\r\nfifo->active = 0;\r\nspin_unlock(&hw->lock);\r\nreturn;\r\n}\r\nspin_unlock(&hw->lock);\r\nif (status == -EXDEV) {\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: with -EXDEV "\r\n"urb->status %d, fifonum %d\n",\r\nhw->name, __func__, status, fifon);\r\nstatus = 0;\r\n}\r\ns0_state = 0;\r\nif (fifo->active && !status) {\r\nnum_isoc_packets = iso_packets[fifon];\r\nmaxlen = fifo->usb_packet_maxlen;\r\nfor (k = 0; k < num_isoc_packets; ++k) {\r\nlen = urb->iso_frame_desc[k].actual_length;\r\noffset = urb->iso_frame_desc[k].offset;\r\nbuf = context_iso_urb->buffer + offset;\r\niso_status = urb->iso_frame_desc[k].status;\r\nif (iso_status && (debug & DBG_HFC_FIFO_VERBOSE)) {\r\nprintk(KERN_DEBUG "%s: %s: "\r\n"ISO packet %i, status: %i\n",\r\nhw->name, __func__, k, iso_status);\r\n}\r\nif ((fifon == HFCUSB_D_RX) &&\r\n(debug & DBG_HFC_USB_VERBOSE)) {\r\nprintk(KERN_DEBUG\r\n"%s: %s: %d (%d/%d) len(%d) ",\r\nhw->name, __func__, urb->start_frame,\r\nk, num_isoc_packets-1,\r\nlen);\r\nfor (i = 0; i < len; i++)\r\nprintk("%x ", buf[i]);\r\nprintk("\n");\r\n}\r\nif (!iso_status) {\r\nif (fifo->last_urblen != maxlen) {\r\nhw->threshold_mask = buf[1];\r\nif (fifon == HFCUSB_D_RX)\r\ns0_state = (buf[0] >> 4);\r\neof[fifon] = buf[0] & 1;\r\nif (len > 2)\r\nhfcsusb_rx_frame(fifo, buf + 2,\r\nlen - 2, (len < maxlen)\r\n? eof[fifon] : 0);\r\n} else\r\nhfcsusb_rx_frame(fifo, buf, len,\r\n(len < maxlen) ?\r\neof[fifon] : 0);\r\nfifo->last_urblen = len;\r\n}\r\n}\r\nif ((s0_state) && (hw->initdone) &&\r\n(s0_state != hw->dch.state)) {\r\nhw->dch.state = s0_state;\r\nschedule_event(&hw->dch, FLG_PHCHANGE);\r\n}\r\nfill_isoc_urb(urb, fifo->hw->dev, fifo->pipe,\r\ncontext_iso_urb->buffer, num_isoc_packets,\r\nfifo->usb_packet_maxlen, fifo->intervall,\r\n(usb_complete_t)rx_iso_complete, urb->context);\r\nerrcode = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (errcode < 0) {\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: error submitting "\r\n"ISO URB: %d\n",\r\nhw->name, __func__, errcode);\r\n}\r\n} else {\r\nif (status && (debug & DBG_HFC_URB_INFO))\r\nprintk(KERN_DEBUG "%s: %s: rx_iso_complete : "\r\n"urb->status %d, fifonum %d\n",\r\nhw->name, __func__, status, fifon);\r\n}\r\n}\r\nstatic void\r\nrx_int_complete(struct urb *urb)\r\n{\r\nint len, status, i;\r\n__u8 *buf, maxlen, fifon;\r\nstruct usb_fifo *fifo = (struct usb_fifo *) urb->context;\r\nstruct hfcsusb *hw = fifo->hw;\r\nstatic __u8 eof[8];\r\nspin_lock(&hw->lock);\r\nif (fifo->stop_gracefull) {\r\nfifo->stop_gracefull = 0;\r\nfifo->active = 0;\r\nspin_unlock(&hw->lock);\r\nreturn;\r\n}\r\nspin_unlock(&hw->lock);\r\nfifon = fifo->fifonum;\r\nif ((!fifo->active) || (urb->status)) {\r\nif (debug & DBG_HFC_URB_ERROR)\r\nprintk(KERN_DEBUG\r\n"%s: %s: RX-Fifo %i is going down (%i)\n",\r\nhw->name, __func__, fifon, urb->status);\r\nfifo->urb->interval = 0;\r\nreturn;\r\n}\r\nlen = urb->actual_length;\r\nbuf = fifo->buffer;\r\nmaxlen = fifo->usb_packet_maxlen;\r\nif ((fifon == HFCUSB_D_RX) && (debug & DBG_HFC_USB_VERBOSE)) {\r\nprintk(KERN_DEBUG "%s: %s: D RX INT len(%d) ",\r\nhw->name, __func__, len);\r\nfor (i = 0; i < len; i++)\r\nprintk("%02x ", buf[i]);\r\nprintk("\n");\r\n}\r\nif (fifo->last_urblen != fifo->usb_packet_maxlen) {\r\nhw->threshold_mask = buf[1];\r\nif (hw->initdone && ((buf[0] >> 4) != hw->dch.state)) {\r\nhw->dch.state = (buf[0] >> 4);\r\nschedule_event(&hw->dch, FLG_PHCHANGE);\r\n}\r\neof[fifon] = buf[0] & 1;\r\nif (len > 2)\r\nhfcsusb_rx_frame(fifo, buf + 2,\r\nurb->actual_length - 2,\r\n(len < maxlen) ? eof[fifon] : 0);\r\n} else {\r\nhfcsusb_rx_frame(fifo, buf, urb->actual_length,\r\n(len < maxlen) ? eof[fifon] : 0);\r\n}\r\nfifo->last_urblen = urb->actual_length;\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: error resubmitting USB\n",\r\nhw->name, __func__);\r\n}\r\n}\r\nstatic void\r\ntx_iso_complete(struct urb *urb)\r\n{\r\nstruct iso_urb *context_iso_urb = (struct iso_urb *) urb->context;\r\nstruct usb_fifo *fifo = context_iso_urb->owner_fifo;\r\nstruct hfcsusb *hw = fifo->hw;\r\nstruct sk_buff *tx_skb;\r\nint k, tx_offset, num_isoc_packets, sink, remain, current_len,\r\nerrcode, hdlc, i;\r\nint *tx_idx;\r\nint frame_complete, fifon, status;\r\n__u8 threshbit;\r\nspin_lock(&hw->lock);\r\nif (fifo->stop_gracefull) {\r\nfifo->stop_gracefull = 0;\r\nfifo->active = 0;\r\nspin_unlock(&hw->lock);\r\nreturn;\r\n}\r\nif (fifo->dch) {\r\ntx_skb = fifo->dch->tx_skb;\r\ntx_idx = &fifo->dch->tx_idx;\r\nhdlc = 1;\r\n} else if (fifo->bch) {\r\ntx_skb = fifo->bch->tx_skb;\r\ntx_idx = &fifo->bch->tx_idx;\r\nhdlc = test_bit(FLG_HDLC, &fifo->bch->Flags);\r\n} else {\r\nprintk(KERN_DEBUG "%s: %s: neither BCH nor DCH\n",\r\nhw->name, __func__);\r\nspin_unlock(&hw->lock);\r\nreturn;\r\n}\r\nfifon = fifo->fifonum;\r\nstatus = urb->status;\r\ntx_offset = 0;\r\nif (status == -EXDEV) {\r\nif (debug & DBG_HFC_URB_ERROR)\r\nprintk(KERN_DEBUG "%s: %s: "\r\n"-EXDEV (%i) fifon (%d)\n",\r\nhw->name, __func__, status, fifon);\r\nstatus = 0;\r\n}\r\nif (fifo->active && !status) {\r\nthreshbit = (hw->threshold_mask & (1 << fifon));\r\nnum_isoc_packets = iso_packets[fifon];\r\nif (fifon >= HFCUSB_D_TX)\r\nsink = (threshbit) ? SINK_DMIN : SINK_DMAX;\r\nelse\r\nsink = (threshbit) ? SINK_MIN : SINK_MAX;\r\nfill_isoc_urb(urb, fifo->hw->dev, fifo->pipe,\r\ncontext_iso_urb->buffer, num_isoc_packets,\r\nfifo->usb_packet_maxlen, fifo->intervall,\r\n(usb_complete_t)tx_iso_complete, urb->context);\r\nmemset(context_iso_urb->buffer, 0,\r\nsizeof(context_iso_urb->buffer));\r\nframe_complete = 0;\r\nfor (k = 0; k < num_isoc_packets; ++k) {\r\nif (debug & DBG_HFC_URB_ERROR) {\r\nerrcode = urb->iso_frame_desc[k].status;\r\nif (errcode) {\r\nprintk(KERN_DEBUG "%s: %s: "\r\n"ISO packet %i, status: %i\n",\r\nhw->name, __func__, k, errcode);\r\n}\r\n}\r\nif (tx_skb)\r\nremain = tx_skb->len - *tx_idx;\r\nelse\r\nremain = 0;\r\nif (remain > 0) {\r\nfifo->bit_line -= sink;\r\ncurrent_len = (0 - fifo->bit_line) / 8;\r\nif (current_len > 14)\r\ncurrent_len = 14;\r\nif (current_len < 0)\r\ncurrent_len = 0;\r\nif (remain < current_len)\r\ncurrent_len = remain;\r\nfifo->bit_line += current_len * 8;\r\ncontext_iso_urb->buffer[tx_offset] = 0;\r\nif (current_len == remain) {\r\nif (hdlc) {\r\ncontext_iso_urb->\r\nbuffer[tx_offset] = 1;\r\nfifo->bit_line += 32;\r\n}\r\nframe_complete = 1;\r\n}\r\nmemcpy(context_iso_urb->buffer + tx_offset + 1,\r\n(tx_skb->data + *tx_idx), current_len);\r\n*tx_idx += current_len;\r\nurb->iso_frame_desc[k].offset = tx_offset;\r\nurb->iso_frame_desc[k].length = current_len + 1;\r\nif ((fifon == HFCUSB_D_RX) &&\r\n(debug & DBG_HFC_USB_VERBOSE)) {\r\nprintk(KERN_DEBUG\r\n"%s: %s (%d/%d) offs(%d) len(%d) ",\r\nhw->name, __func__,\r\nk, num_isoc_packets-1,\r\nurb->iso_frame_desc[k].offset,\r\nurb->iso_frame_desc[k].length);\r\nfor (i = urb->iso_frame_desc[k].offset;\r\ni < (urb->iso_frame_desc[k].offset\r\n+ urb->iso_frame_desc[k].length);\r\ni++)\r\nprintk("%x ",\r\ncontext_iso_urb->buffer[i]);\r\nprintk(" skb->len(%i) tx-idx(%d)\n",\r\ntx_skb->len, *tx_idx);\r\n}\r\ntx_offset += (current_len + 1);\r\n} else {\r\nurb->iso_frame_desc[k].offset = tx_offset++;\r\nurb->iso_frame_desc[k].length = 1;\r\nfifo->bit_line -= sink;\r\nif (fifo->bit_line < BITLINE_INF)\r\nfifo->bit_line = BITLINE_INF;\r\n}\r\nif (frame_complete) {\r\nframe_complete = 0;\r\nif (debug & DBG_HFC_FIFO_VERBOSE) {\r\nprintk(KERN_DEBUG "%s: %s: "\r\n"fifon(%i) new TX len(%i): ",\r\nhw->name, __func__,\r\nfifon, tx_skb->len);\r\ni = 0;\r\nwhile (i < tx_skb->len)\r\nprintk("%02x ",\r\ntx_skb->data[i++]);\r\nprintk("\n");\r\n}\r\ndev_kfree_skb(tx_skb);\r\ntx_skb = NULL;\r\nif (fifo->dch && get_next_dframe(fifo->dch))\r\ntx_skb = fifo->dch->tx_skb;\r\nelse if (fifo->bch &&\r\nget_next_bframe(fifo->bch)) {\r\nif (test_bit(FLG_TRANSPARENT,\r\n&fifo->bch->Flags))\r\nconfirm_Bsend(fifo->bch);\r\ntx_skb = fifo->bch->tx_skb;\r\n}\r\n}\r\n}\r\nerrcode = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (errcode < 0) {\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG\r\n"%s: %s: error submitting ISO URB: %d \n",\r\nhw->name, __func__, errcode);\r\n}\r\nif ((fifon == HFCUSB_D_TX) && (hw->protocol == ISDN_P_NT_S0)\r\n&& (hw->timers & NT_ACTIVATION_TIMER)) {\r\nif ((--hw->nt_timer) < 0)\r\nschedule_event(&hw->dch, FLG_PHCHANGE);\r\n}\r\n} else {\r\nif (status && (debug & DBG_HFC_URB_ERROR))\r\nprintk(KERN_DEBUG "%s: %s: urb->status %s (%i)"\r\n"fifonum=%d\n",\r\nhw->name, __func__,\r\nsymbolic(urb_errlist, status), status, fifon);\r\n}\r\nspin_unlock(&hw->lock);\r\n}\r\nstatic int\r\nstart_isoc_chain(struct usb_fifo *fifo, int num_packets_per_urb,\r\nusb_complete_t complete, int packet_size)\r\n{\r\nstruct hfcsusb *hw = fifo->hw;\r\nint i, k, errcode;\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: %s: fifo %i\n",\r\nhw->name, __func__, fifo->fifonum);\r\nfor (i = 0; i < 2; i++) {\r\nif (!(fifo->iso[i].urb)) {\r\nfifo->iso[i].urb =\r\nusb_alloc_urb(num_packets_per_urb, GFP_KERNEL);\r\nif (!(fifo->iso[i].urb)) {\r\nprintk(KERN_DEBUG\r\n"%s: %s: alloc urb for fifo %i failed",\r\nhw->name, __func__, fifo->fifonum);\r\n}\r\nfifo->iso[i].owner_fifo = (struct usb_fifo *) fifo;\r\nfifo->iso[i].indx = i;\r\nif (ISO_BUFFER_SIZE >=\r\n(fifo->usb_packet_maxlen *\r\nnum_packets_per_urb)) {\r\nfill_isoc_urb(fifo->iso[i].urb,\r\nfifo->hw->dev, fifo->pipe,\r\nfifo->iso[i].buffer,\r\nnum_packets_per_urb,\r\nfifo->usb_packet_maxlen,\r\nfifo->intervall, complete,\r\n&fifo->iso[i]);\r\nmemset(fifo->iso[i].buffer, 0,\r\nsizeof(fifo->iso[i].buffer));\r\nfor (k = 0; k < num_packets_per_urb; k++) {\r\nfifo->iso[i].urb->\r\niso_frame_desc[k].offset =\r\nk * packet_size;\r\nfifo->iso[i].urb->\r\niso_frame_desc[k].length =\r\npacket_size;\r\n}\r\n} else {\r\nprintk(KERN_DEBUG\r\n"%s: %s: ISO Buffer size to small!\n",\r\nhw->name, __func__);\r\n}\r\n}\r\nfifo->bit_line = BITLINE_INF;\r\nerrcode = usb_submit_urb(fifo->iso[i].urb, GFP_KERNEL);\r\nfifo->active = (errcode >= 0) ? 1 : 0;\r\nfifo->stop_gracefull = 0;\r\nif (errcode < 0) {\r\nprintk(KERN_DEBUG "%s: %s: %s URB nr:%d\n",\r\nhw->name, __func__,\r\nsymbolic(urb_errlist, errcode), i);\r\n}\r\n}\r\nreturn fifo->active;\r\n}\r\nstatic void\r\nstop_iso_gracefull(struct usb_fifo *fifo)\r\n{\r\nstruct hfcsusb *hw = fifo->hw;\r\nint i, timeout;\r\nu_long flags;\r\nfor (i = 0; i < 2; i++) {\r\nspin_lock_irqsave(&hw->lock, flags);\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: %s for fifo %i.%i\n",\r\nhw->name, __func__, fifo->fifonum, i);\r\nfifo->stop_gracefull = 1;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\ntimeout = 3;\r\nwhile (fifo->stop_gracefull && timeout--)\r\nschedule_timeout_interruptible((HZ/1000)*16);\r\nif (debug && fifo->stop_gracefull)\r\nprintk(KERN_DEBUG "%s: ERROR %s for fifo %i.%i\n",\r\nhw->name, __func__, fifo->fifonum, i);\r\n}\r\n}\r\nstatic void\r\nstop_int_gracefull(struct usb_fifo *fifo)\r\n{\r\nstruct hfcsusb *hw = fifo->hw;\r\nint timeout;\r\nu_long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: %s for fifo %i\n",\r\nhw->name, __func__, fifo->fifonum);\r\nfifo->stop_gracefull = 1;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\ntimeout = 3;\r\nwhile (fifo->stop_gracefull && timeout--)\r\nschedule_timeout_interruptible((HZ/1000)*3);\r\nif (debug && fifo->stop_gracefull)\r\nprintk(KERN_DEBUG "%s: ERROR %s for fifo %i\n",\r\nhw->name, __func__, fifo->fifonum);\r\n}\r\nstatic void\r\nstart_int_fifo(struct usb_fifo *fifo)\r\n{\r\nstruct hfcsusb *hw = fifo->hw;\r\nint errcode;\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: %s: INT IN fifo:%d\n",\r\nhw->name, __func__, fifo->fifonum);\r\nif (!fifo->urb) {\r\nfifo->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!fifo->urb)\r\nreturn;\r\n}\r\nusb_fill_int_urb(fifo->urb, fifo->hw->dev, fifo->pipe,\r\nfifo->buffer, fifo->usb_packet_maxlen,\r\n(usb_complete_t)rx_int_complete, fifo, fifo->intervall);\r\nfifo->active = 1;\r\nfifo->stop_gracefull = 0;\r\nerrcode = usb_submit_urb(fifo->urb, GFP_KERNEL);\r\nif (errcode) {\r\nprintk(KERN_DEBUG "%s: %s: submit URB: status:%i\n",\r\nhw->name, __func__, errcode);\r\nfifo->active = 0;\r\n}\r\n}\r\nstatic void\r\nsetPortMode(struct hfcsusb *hw)\r\n{\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s %s\n", hw->name, __func__,\r\n(hw->protocol == ISDN_P_TE_S0) ? "TE" : "NT");\r\nif (hw->protocol == ISDN_P_TE_S0) {\r\nwrite_reg(hw, HFCUSB_SCTRL, 0x40);\r\nwrite_reg(hw, HFCUSB_SCTRL_E, 0x00);\r\nwrite_reg(hw, HFCUSB_CLKDEL, CLKDEL_TE);\r\nwrite_reg(hw, HFCUSB_STATES, 3 | 0x10);\r\nwrite_reg(hw, HFCUSB_STATES, 3);\r\n} else {\r\nwrite_reg(hw, HFCUSB_SCTRL, 0x44);\r\nwrite_reg(hw, HFCUSB_SCTRL_E, 0x09);\r\nwrite_reg(hw, HFCUSB_CLKDEL, CLKDEL_NT);\r\nwrite_reg(hw, HFCUSB_STATES, 1 | 0x10);\r\nwrite_reg(hw, HFCUSB_STATES, 1);\r\n}\r\n}\r\nstatic void\r\nreset_hfcsusb(struct hfcsusb *hw)\r\n{\r\nstruct usb_fifo *fifo;\r\nint i;\r\nif (debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s\n", hw->name, __func__);\r\nwrite_reg(hw, HFCUSB_CIRM, 8);\r\nwrite_reg(hw, HFCUSB_CIRM, 0x10);\r\nwrite_reg(hw, HFCUSB_USB_SIZE, (hw->packet_size / 8) |\r\n((hw->packet_size / 8) << 4));\r\nwrite_reg(hw, HFCUSB_USB_SIZE_I, hw->iso_packet_size);\r\nwrite_reg(hw, HFCUSB_MST_MODE1, 0);\r\nwrite_reg(hw, HFCUSB_MST_MODE0, 1);\r\nwrite_reg(hw, HFCUSB_F_THRES,\r\n(HFCUSB_TX_THRESHOLD / 8) | ((HFCUSB_RX_THRESHOLD / 8) << 4));\r\nfifo = hw->fifos;\r\nfor (i = 0; i < HFCUSB_NUM_FIFOS; i++) {\r\nwrite_reg(hw, HFCUSB_FIFO, i);\r\nfifo[i].max_size =\r\n(i <= HFCUSB_B2_RX) ? MAX_BCH_SIZE : MAX_DFRAME_LEN;\r\nfifo[i].last_urblen = 0;\r\nwrite_reg(hw, HFCUSB_HDLC_PAR, ((i <= HFCUSB_B2_RX) ? 0 : 2));\r\nif (i == HFCUSB_D_TX)\r\nwrite_reg(hw, HFCUSB_CON_HDLC,\r\n(hw->protocol == ISDN_P_NT_S0) ? 0x08 : 0x09);\r\nelse\r\nwrite_reg(hw, HFCUSB_CON_HDLC, 0x08);\r\nwrite_reg(hw, HFCUSB_INC_RES_F, 2);\r\n}\r\nwrite_reg(hw, HFCUSB_SCTRL_R, 0);\r\nhandle_led(hw, LED_POWER_ON);\r\n}\r\nstatic void\r\nhfcsusb_start_endpoint(struct hfcsusb *hw, int channel)\r\n{\r\nif ((channel == HFC_CHAN_D) && (hw->fifos[HFCUSB_D_RX].active))\r\nreturn;\r\nif ((channel == HFC_CHAN_B1) && (hw->fifos[HFCUSB_B1_RX].active))\r\nreturn;\r\nif ((channel == HFC_CHAN_B2) && (hw->fifos[HFCUSB_B2_RX].active))\r\nreturn;\r\nif ((channel == HFC_CHAN_E) && (hw->fifos[HFCUSB_PCM_RX].active))\r\nreturn;\r\nif (hw->cfg_used == CNF_3INT3ISO || hw->cfg_used == CNF_4INT3ISO)\r\nstart_int_fifo(hw->fifos + channel*2 + 1);\r\nif (hw->cfg_used == CNF_3ISO3ISO || hw->cfg_used == CNF_4ISO3ISO) {\r\nswitch (channel) {\r\ncase HFC_CHAN_D:\r\nstart_isoc_chain(hw->fifos + HFCUSB_D_RX,\r\nISOC_PACKETS_D,\r\n(usb_complete_t)rx_iso_complete,\r\n16);\r\nbreak;\r\ncase HFC_CHAN_E:\r\nstart_isoc_chain(hw->fifos + HFCUSB_PCM_RX,\r\nISOC_PACKETS_D,\r\n(usb_complete_t)rx_iso_complete,\r\n16);\r\nbreak;\r\ncase HFC_CHAN_B1:\r\nstart_isoc_chain(hw->fifos + HFCUSB_B1_RX,\r\nISOC_PACKETS_B,\r\n(usb_complete_t)rx_iso_complete,\r\n16);\r\nbreak;\r\ncase HFC_CHAN_B2:\r\nstart_isoc_chain(hw->fifos + HFCUSB_B2_RX,\r\nISOC_PACKETS_B,\r\n(usb_complete_t)rx_iso_complete,\r\n16);\r\nbreak;\r\n}\r\n}\r\nswitch (channel) {\r\ncase HFC_CHAN_D:\r\nstart_isoc_chain(hw->fifos + HFCUSB_D_TX,\r\nISOC_PACKETS_B,\r\n(usb_complete_t)tx_iso_complete, 1);\r\nbreak;\r\ncase HFC_CHAN_B1:\r\nstart_isoc_chain(hw->fifos + HFCUSB_B1_TX,\r\nISOC_PACKETS_D,\r\n(usb_complete_t)tx_iso_complete, 1);\r\nbreak;\r\ncase HFC_CHAN_B2:\r\nstart_isoc_chain(hw->fifos + HFCUSB_B2_TX,\r\nISOC_PACKETS_B,\r\n(usb_complete_t)tx_iso_complete, 1);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nhfcsusb_stop_endpoint(struct hfcsusb *hw, int channel)\r\n{\r\nif ((channel == HFC_CHAN_D) && (!hw->fifos[HFCUSB_D_RX].active))\r\nreturn;\r\nif ((channel == HFC_CHAN_B1) && (!hw->fifos[HFCUSB_B1_RX].active))\r\nreturn;\r\nif ((channel == HFC_CHAN_B2) && (!hw->fifos[HFCUSB_B2_RX].active))\r\nreturn;\r\nif ((channel == HFC_CHAN_E) && (!hw->fifos[HFCUSB_PCM_RX].active))\r\nreturn;\r\nif (hw->cfg_used == CNF_3INT3ISO || hw->cfg_used == CNF_4INT3ISO)\r\nstop_int_gracefull(hw->fifos + channel*2 + 1);\r\nif (hw->cfg_used == CNF_3ISO3ISO || hw->cfg_used == CNF_4ISO3ISO)\r\nstop_iso_gracefull(hw->fifos + channel*2 + 1);\r\nif (channel != HFC_CHAN_E)\r\nstop_iso_gracefull(hw->fifos + channel*2);\r\n}\r\nstatic int\r\nsetup_hfcsusb(struct hfcsusb *hw)\r\n{\r\nu_char b;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s\n", hw->name, __func__);\r\nif (read_reg_atomic(hw, HFCUSB_CHIP_ID, &b) != 1) {\r\nprintk(KERN_DEBUG "%s: %s: cannot read chip id\n",\r\nhw->name, __func__);\r\nreturn 1;\r\n}\r\nif (b != HFCUSB_CHIPID) {\r\nprintk(KERN_DEBUG "%s: %s: Invalid chip id 0x%02x\n",\r\nhw->name, __func__, b);\r\nreturn 1;\r\n}\r\n(void) usb_set_interface(hw->dev, hw->if_used, hw->alt_used);\r\nhw->led_state = 0;\r\nhw->ctrl_read.bRequestType = 0xc0;\r\nhw->ctrl_read.bRequest = 1;\r\nhw->ctrl_read.wLength = cpu_to_le16(1);\r\nhw->ctrl_write.bRequestType = 0x40;\r\nhw->ctrl_write.bRequest = 0;\r\nhw->ctrl_write.wLength = 0;\r\nusb_fill_control_urb(hw->ctrl_urb, hw->dev, hw->ctrl_out_pipe,\r\n(u_char *)&hw->ctrl_write, NULL, 0,\r\n(usb_complete_t)ctrl_complete, hw);\r\nreset_hfcsusb(hw);\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_hw(struct hfcsusb *hw)\r\n{\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s\n", hw->name, __func__);\r\nhfcsusb_stop_endpoint(hw, HFC_CHAN_D);\r\nhfcsusb_stop_endpoint(hw, HFC_CHAN_B1);\r\nhfcsusb_stop_endpoint(hw, HFC_CHAN_B2);\r\nif (hw->fifos[HFCUSB_PCM_RX].pipe)\r\nhfcsusb_stop_endpoint(hw, HFC_CHAN_E);\r\nif (hw->protocol == ISDN_P_TE_S0)\r\nl1_event(hw->dch.l1, CLOSE_CHANNEL);\r\nmISDN_unregister_device(&hw->dch.dev);\r\nmISDN_freebchannel(&hw->bch[1]);\r\nmISDN_freebchannel(&hw->bch[0]);\r\nmISDN_freedchannel(&hw->dch);\r\nif (hw->ctrl_urb) {\r\nusb_kill_urb(hw->ctrl_urb);\r\nusb_free_urb(hw->ctrl_urb);\r\nhw->ctrl_urb = NULL;\r\n}\r\nif (hw->intf)\r\nusb_set_intfdata(hw->intf, NULL);\r\nlist_del(&hw->list);\r\nkfree(hw);\r\nhw = NULL;\r\n}\r\nstatic void\r\ndeactivate_bchannel(struct bchannel *bch)\r\n{\r\nstruct hfcsusb *hw = bch->hw;\r\nu_long flags;\r\nif (bch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: %s: bch->nr(%i)\n",\r\nhw->name, __func__, bch->nr);\r\nspin_lock_irqsave(&hw->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nhfcsusb_setup_bch(bch, ISDN_P_NONE);\r\nhfcsusb_stop_endpoint(hw, bch->nr);\r\n}\r\nstatic int\r\nhfc_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nint ret = -EINVAL;\r\nif (bch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: cmd:%x %p\n", __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase HW_TESTRX_RAW:\r\ncase HW_TESTRX_HDLC:\r\ncase HW_TESTRX_OFF:\r\nret = -EINVAL;\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\nif (test_bit(FLG_ACTIVE, &bch->Flags))\r\ndeactivate_bchannel(bch);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(THIS_MODULE);\r\nret = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = channel_bctrl(bch, arg);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown prim(%x)\n",\r\n__func__, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsetup_instance(struct hfcsusb *hw, struct device *parent)\r\n{\r\nu_long flags;\r\nint err, i;\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_DEBUG "%s: %s\n", hw->name, __func__);\r\nspin_lock_init(&hw->ctrl_lock);\r\nspin_lock_init(&hw->lock);\r\nmISDN_initdchannel(&hw->dch, MAX_DFRAME_LEN_L1, ph_state);\r\nhw->dch.debug = debug & 0xFFFF;\r\nhw->dch.hw = hw;\r\nhw->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\r\nhw->dch.dev.D.send = hfcusb_l2l1D;\r\nhw->dch.dev.D.ctrl = hfc_dctrl;\r\nif (hw->fifos[HFCUSB_PCM_RX].pipe)\r\nmISDN_initdchannel(&hw->ech, MAX_DFRAME_LEN_L1, NULL);\r\nhw->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\nhw->dch.dev.nrbchan = 2;\r\nfor (i = 0; i < 2; i++) {\r\nhw->bch[i].nr = i + 1;\r\nset_channelmap(i + 1, hw->dch.dev.channelmap);\r\nhw->bch[i].debug = debug;\r\nmISDN_initbchannel(&hw->bch[i], MAX_DATA_MEM);\r\nhw->bch[i].hw = hw;\r\nhw->bch[i].ch.send = hfcusb_l2l1B;\r\nhw->bch[i].ch.ctrl = hfc_bctrl;\r\nhw->bch[i].ch.nr = i + 1;\r\nlist_add(&hw->bch[i].ch.list, &hw->dch.dev.bchannels);\r\n}\r\nhw->fifos[HFCUSB_B1_TX].bch = &hw->bch[0];\r\nhw->fifos[HFCUSB_B1_RX].bch = &hw->bch[0];\r\nhw->fifos[HFCUSB_B2_TX].bch = &hw->bch[1];\r\nhw->fifos[HFCUSB_B2_RX].bch = &hw->bch[1];\r\nhw->fifos[HFCUSB_D_TX].dch = &hw->dch;\r\nhw->fifos[HFCUSB_D_RX].dch = &hw->dch;\r\nhw->fifos[HFCUSB_PCM_RX].ech = &hw->ech;\r\nhw->fifos[HFCUSB_PCM_TX].ech = &hw->ech;\r\nerr = setup_hfcsusb(hw);\r\nif (err)\r\ngoto out;\r\nsnprintf(hw->name, MISDN_MAX_IDLEN - 1, "%s.%d", DRIVER_NAME,\r\nhfcsusb_cnt + 1);\r\nprintk(KERN_INFO "%s: registered as '%s'\n",\r\nDRIVER_NAME, hw->name);\r\nerr = mISDN_register_device(&hw->dch.dev, parent, hw->name);\r\nif (err)\r\ngoto out;\r\nhfcsusb_cnt++;\r\nwrite_lock_irqsave(&HFClock, flags);\r\nlist_add_tail(&hw->list, &HFClist);\r\nwrite_unlock_irqrestore(&HFClock, flags);\r\nreturn 0;\r\nout:\r\nmISDN_freebchannel(&hw->bch[1]);\r\nmISDN_freebchannel(&hw->bch[0]);\r\nmISDN_freedchannel(&hw->dch);\r\nkfree(hw);\r\nreturn err;\r\n}\r\nstatic int\r\nhfcsusb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct hfcsusb *hw;\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *iface = intf->cur_altsetting;\r\nstruct usb_host_interface *iface_used = NULL;\r\nstruct usb_host_endpoint *ep;\r\nstruct hfcsusb_vdata *driver_info;\r\nint ifnum = iface->desc.bInterfaceNumber, i, idx, alt_idx,\r\nprobe_alt_setting, vend_idx, cfg_used, *vcf, attr, cfg_found,\r\nep_addr, cmptbl[16], small_match, iso_packet_size, packet_size,\r\nalt_used = 0;\r\nvend_idx = 0xffff;\r\nfor (i = 0; hfcsusb_idtab[i].idVendor; i++) {\r\nif ((le16_to_cpu(dev->descriptor.idVendor)\r\n== hfcsusb_idtab[i].idVendor) &&\r\n(le16_to_cpu(dev->descriptor.idProduct)\r\n== hfcsusb_idtab[i].idProduct)) {\r\nvend_idx = i;\r\ncontinue;\r\n}\r\n}\r\nprintk(KERN_DEBUG\r\n"%s: interface(%d) actalt(%d) minor(%d) vend_idx(%d)\n",\r\n__func__, ifnum, iface->desc.bAlternateSetting,\r\nintf->minor, vend_idx);\r\nif (vend_idx == 0xffff) {\r\nprintk(KERN_WARNING\r\n"%s: no valid vendor found in USB descriptor\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nalt_idx = 0;\r\nsmall_match = -1;\r\niso_packet_size = 16;\r\npacket_size = 64;\r\nwhile (alt_idx < intf->num_altsetting) {\r\niface = intf->altsetting + alt_idx;\r\nprobe_alt_setting = iface->desc.bAlternateSetting;\r\ncfg_used = 0;\r\nwhile (validconf[cfg_used][0]) {\r\ncfg_found = 1;\r\nvcf = validconf[cfg_used];\r\nep = iface->endpoint;\r\nmemcpy(cmptbl, vcf, 16 * sizeof(int));\r\nfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\r\nep_addr = ep->desc.bEndpointAddress;\r\nidx = ((ep_addr & 0x7f) - 1) * 2;\r\nif (ep_addr & 0x80)\r\nidx++;\r\nattr = ep->desc.bmAttributes;\r\nif (cmptbl[idx] != EP_NOP) {\r\nif (cmptbl[idx] == EP_NUL)\r\ncfg_found = 0;\r\nif (attr == USB_ENDPOINT_XFER_INT\r\n&& cmptbl[idx] == EP_INT)\r\ncmptbl[idx] = EP_NUL;\r\nif (attr == USB_ENDPOINT_XFER_BULK\r\n&& cmptbl[idx] == EP_BLK)\r\ncmptbl[idx] = EP_NUL;\r\nif (attr == USB_ENDPOINT_XFER_ISOC\r\n&& cmptbl[idx] == EP_ISO)\r\ncmptbl[idx] = EP_NUL;\r\nif (attr == USB_ENDPOINT_XFER_INT &&\r\nep->desc.bInterval < vcf[17]) {\r\ncfg_found = 0;\r\n}\r\n}\r\nep++;\r\n}\r\nfor (i = 0; i < 16; i++)\r\nif (cmptbl[i] != EP_NOP && cmptbl[i] != EP_NUL)\r\ncfg_found = 0;\r\nif (cfg_found) {\r\nif (small_match < cfg_used) {\r\nsmall_match = cfg_used;\r\nalt_used = probe_alt_setting;\r\niface_used = iface;\r\n}\r\n}\r\ncfg_used++;\r\n}\r\nalt_idx++;\r\n}\r\nif (small_match == -1)\r\nreturn -EIO;\r\niface = iface_used;\r\nhw = kzalloc(sizeof(struct hfcsusb), GFP_KERNEL);\r\nif (!hw)\r\nreturn -ENOMEM;\r\nsnprintf(hw->name, MISDN_MAX_IDLEN - 1, "%s", DRIVER_NAME);\r\nep = iface->endpoint;\r\nvcf = validconf[small_match];\r\nfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\r\nstruct usb_fifo *f;\r\nep_addr = ep->desc.bEndpointAddress;\r\nidx = ((ep_addr & 0x7f) - 1) * 2;\r\nif (ep_addr & 0x80)\r\nidx++;\r\nf = &hw->fifos[idx & 7];\r\nif (vcf[idx] == EP_NOP || vcf[idx] == EP_NUL) {\r\nep++;\r\ncontinue;\r\n}\r\nswitch (ep->desc.bmAttributes) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nf->pipe = usb_rcvintpipe(dev,\r\nep->desc.bEndpointAddress);\r\nf->usb_transfer_mode = USB_INT;\r\npacket_size = le16_to_cpu(ep->desc.wMaxPacketSize);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (ep_addr & 0x80)\r\nf->pipe = usb_rcvbulkpipe(dev,\r\nep->desc.bEndpointAddress);\r\nelse\r\nf->pipe = usb_sndbulkpipe(dev,\r\nep->desc.bEndpointAddress);\r\nf->usb_transfer_mode = USB_BULK;\r\npacket_size = le16_to_cpu(ep->desc.wMaxPacketSize);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (ep_addr & 0x80)\r\nf->pipe = usb_rcvisocpipe(dev,\r\nep->desc.bEndpointAddress);\r\nelse\r\nf->pipe = usb_sndisocpipe(dev,\r\nep->desc.bEndpointAddress);\r\nf->usb_transfer_mode = USB_ISOC;\r\niso_packet_size = le16_to_cpu(ep->desc.wMaxPacketSize);\r\nbreak;\r\ndefault:\r\nf->pipe = 0;\r\n}\r\nif (f->pipe) {\r\nf->fifonum = idx & 7;\r\nf->hw = hw;\r\nf->usb_packet_maxlen =\r\nle16_to_cpu(ep->desc.wMaxPacketSize);\r\nf->intervall = ep->desc.bInterval;\r\n}\r\nep++;\r\n}\r\nhw->dev = dev;\r\nhw->if_used = ifnum;\r\nhw->alt_used = alt_used;\r\nhw->ctrl_paksize = dev->descriptor.bMaxPacketSize0;\r\nhw->cfg_used = vcf[16];\r\nhw->vend_idx = vend_idx;\r\nhw->packet_size = packet_size;\r\nhw->iso_packet_size = iso_packet_size;\r\nhw->ctrl_in_pipe = usb_rcvctrlpipe(hw->dev, 0);\r\nhw->ctrl_out_pipe = usb_sndctrlpipe(hw->dev, 0);\r\nhw->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\r\ndriver_info =\r\n(struct hfcsusb_vdata *)hfcsusb_idtab[vend_idx].driver_info;\r\nprintk(KERN_DEBUG "%s: %s: detected \"%s\" (%s, if=%d alt=%d)\n",\r\nhw->name, __func__, driver_info->vend_name,\r\nconf_str[small_match], ifnum, alt_used);\r\nif (setup_instance(hw, dev->dev.parent))\r\nreturn -EIO;\r\nhw->intf = intf;\r\nusb_set_intfdata(hw->intf, hw);\r\nreturn 0;\r\n}\r\nstatic void\r\nhfcsusb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct hfcsusb *hw = usb_get_intfdata(intf);\r\nstruct hfcsusb *next;\r\nint cnt = 0;\r\nprintk(KERN_INFO "%s: device disconnected\n", hw->name);\r\nhandle_led(hw, LED_POWER_OFF);\r\nrelease_hw(hw);\r\nlist_for_each_entry_safe(hw, next, &HFClist, list)\r\ncnt++;\r\nif (!cnt)\r\nhfcsusb_cnt = 0;\r\nusb_set_intfdata(intf, NULL);\r\n}\r\nstatic int __init\r\nhfcsusb_init(void)\r\n{\r\nprintk(KERN_INFO DRIVER_NAME " driver Rev. %s debug(0x%x) poll(%i)\n",\r\nhfcsusb_rev, debug, poll);\r\nif (usb_register(&hfcsusb_drv)) {\r\nprintk(KERN_INFO DRIVER_NAME\r\n": Unable to register hfcsusb module at usb stack\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nhfcsusb_cleanup(void)\r\n{\r\nif (debug & DBG_HFC_CALL_TRACE)\r\nprintk(KERN_INFO DRIVER_NAME ": %s\n", __func__);\r\nusb_deregister(&hfcsusb_drv);\r\n}
