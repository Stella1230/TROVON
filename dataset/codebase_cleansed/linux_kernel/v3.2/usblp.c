static void usblp_dump(struct usblp *usblp)\r\n{\r\nint p;\r\ndbg("usblp=0x%p", usblp);\r\ndbg("dev=0x%p", usblp->dev);\r\ndbg("present=%d", usblp->present);\r\ndbg("readbuf=0x%p", usblp->readbuf);\r\ndbg("readcount=%d", usblp->readcount);\r\ndbg("ifnum=%d", usblp->ifnum);\r\nfor (p = USBLP_FIRST_PROTOCOL; p <= USBLP_LAST_PROTOCOL; p++) {\r\ndbg("protocol[%d].alt_setting=%d", p, usblp->protocol[p].alt_setting);\r\ndbg("protocol[%d].epwrite=%p", p, usblp->protocol[p].epwrite);\r\ndbg("protocol[%d].epread=%p", p, usblp->protocol[p].epread);\r\n}\r\ndbg("current_protocol=%d", usblp->current_protocol);\r\ndbg("minor=%d", usblp->minor);\r\ndbg("wstatus=%d", usblp->wstatus);\r\ndbg("rstatus=%d", usblp->rstatus);\r\ndbg("quirks=%d", usblp->quirks);\r\ndbg("used=%d", usblp->used);\r\ndbg("bidir=%d", usblp->bidir);\r\ndbg("device_id_string=\"%s\"",\r\nusblp->device_id_string ?\r\nusblp->device_id_string + 2 :\r\n(unsigned char *)"(null)");\r\n}\r\nstatic int usblp_ctrl_msg(struct usblp *usblp, int request, int type, int dir, int recip, int value, void *buf, int len)\r\n{\r\nint retval;\r\nint index = usblp->ifnum;\r\nif ((request == USBLP_REQ_GET_ID) && (type == USB_TYPE_CLASS))\r\nindex = (usblp->ifnum<<8)|usblp->protocol[usblp->current_protocol].alt_setting;\r\nretval = usb_control_msg(usblp->dev,\r\ndir ? usb_rcvctrlpipe(usblp->dev, 0) : usb_sndctrlpipe(usblp->dev, 0),\r\nrequest, type | dir | recip, value, index, buf, len, USBLP_CTL_TIMEOUT);\r\ndbg("usblp_control_msg: rq: 0x%02x dir: %d recip: %d value: %d idx: %d len: %#x result: %d",\r\nrequest, !!dir, recip, value, index, len, retval);\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nstatic void usblp_bulk_read(struct urb *urb)\r\n{\r\nstruct usblp *usblp = urb->context;\r\nint status = urb->status;\r\nif (usblp->present && usblp->used) {\r\nif (status)\r\nprintk(KERN_WARNING "usblp%d: "\r\n"nonzero read bulk status received: %d\n",\r\nusblp->minor, status);\r\n}\r\nspin_lock(&usblp->lock);\r\nif (status < 0)\r\nusblp->rstatus = status;\r\nelse\r\nusblp->rstatus = urb->actual_length;\r\nusblp->rcomplete = 1;\r\nwake_up(&usblp->rwait);\r\nspin_unlock(&usblp->lock);\r\nusb_free_urb(urb);\r\n}\r\nstatic void usblp_bulk_write(struct urb *urb)\r\n{\r\nstruct usblp *usblp = urb->context;\r\nint status = urb->status;\r\nif (usblp->present && usblp->used) {\r\nif (status)\r\nprintk(KERN_WARNING "usblp%d: "\r\n"nonzero write bulk status received: %d\n",\r\nusblp->minor, status);\r\n}\r\nspin_lock(&usblp->lock);\r\nif (status < 0)\r\nusblp->wstatus = status;\r\nelse\r\nusblp->wstatus = urb->actual_length;\r\nusblp->no_paper = 0;\r\nusblp->wcomplete = 1;\r\nwake_up(&usblp->wwait);\r\nspin_unlock(&usblp->lock);\r\nusb_free_urb(urb);\r\n}\r\nstatic int usblp_check_status(struct usblp *usblp, int err)\r\n{\r\nunsigned char status, newerr = 0;\r\nint error;\r\nmutex_lock(&usblp->mut);\r\nif ((error = usblp_read_status(usblp, usblp->statusbuf)) < 0) {\r\nmutex_unlock(&usblp->mut);\r\nprintk_ratelimited(KERN_ERR\r\n"usblp%d: error %d reading printer status\n",\r\nusblp->minor, error);\r\nreturn 0;\r\n}\r\nstatus = *usblp->statusbuf;\r\nmutex_unlock(&usblp->mut);\r\nif (~status & LP_PERRORP)\r\nnewerr = 3;\r\nif (status & LP_POUTPA)\r\nnewerr = 1;\r\nif (~status & LP_PSELECD)\r\nnewerr = 2;\r\nif (newerr != err) {\r\nprintk(KERN_INFO "usblp%d: %s\n",\r\nusblp->minor, usblp_messages[newerr]);\r\n}\r\nreturn newerr;\r\n}\r\nstatic int handle_bidir(struct usblp *usblp)\r\n{\r\nif (usblp->bidir && usblp->used) {\r\nif (usblp_submit_read(usblp) < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usblp_open(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nstruct usblp *usblp;\r\nstruct usb_interface *intf;\r\nint retval;\r\nif (minor < 0)\r\nreturn -ENODEV;\r\nmutex_lock(&usblp_mutex);\r\nretval = -ENODEV;\r\nintf = usb_find_interface(&usblp_driver, minor);\r\nif (!intf)\r\ngoto out;\r\nusblp = usb_get_intfdata(intf);\r\nif (!usblp || !usblp->dev || !usblp->present)\r\ngoto out;\r\nretval = -EBUSY;\r\nif (usblp->used)\r\ngoto out;\r\nretval = usb_autopm_get_interface(intf);\r\nif (retval < 0)\r\ngoto out;\r\nusblp->used = 1;\r\nfile->private_data = usblp;\r\nusblp->wcomplete = 1;\r\nusblp->wstatus = 0;\r\nusblp->rcomplete = 0;\r\nif (handle_bidir(usblp) < 0) {\r\nusb_autopm_put_interface(intf);\r\nusblp->used = 0;\r\nfile->private_data = NULL;\r\nretval = -EIO;\r\n}\r\nout:\r\nmutex_unlock(&usblp_mutex);\r\nreturn retval;\r\n}\r\nstatic void usblp_cleanup(struct usblp *usblp)\r\n{\r\nprintk(KERN_INFO "usblp%d: removed\n", usblp->minor);\r\nkfree(usblp->readbuf);\r\nkfree(usblp->device_id_string);\r\nkfree(usblp->statusbuf);\r\nkfree(usblp);\r\n}\r\nstatic void usblp_unlink_urbs(struct usblp *usblp)\r\n{\r\nusb_kill_anchored_urbs(&usblp->urbs);\r\n}\r\nstatic int usblp_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usblp *usblp = file->private_data;\r\nusblp->flags &= ~LP_ABORT;\r\nmutex_lock(&usblp_mutex);\r\nusblp->used = 0;\r\nif (usblp->present) {\r\nusblp_unlink_urbs(usblp);\r\nusb_autopm_put_interface(usblp->intf);\r\n} else\r\nusblp_cleanup(usblp);\r\nmutex_unlock(&usblp_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned int usblp_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct usblp *usblp = file->private_data;\r\npoll_wait(file, &usblp->rwait, wait);\r\npoll_wait(file, &usblp->wwait, wait);\r\nspin_lock_irqsave(&usblp->lock, flags);\r\nret = ((usblp->bidir && usblp->rcomplete) ? POLLIN | POLLRDNORM : 0) |\r\n((usblp->no_paper || usblp->wcomplete) ? POLLOUT | POLLWRNORM : 0);\r\nspin_unlock_irqrestore(&usblp->lock, flags);\r\nreturn ret;\r\n}\r\nstatic long usblp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct usblp *usblp = file->private_data;\r\nint length, err, i;\r\nunsigned char newChannel;\r\nint status;\r\nint twoints[2];\r\nint retval = 0;\r\nmutex_lock(&usblp->mut);\r\nif (!usblp->present) {\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\ndbg("usblp_ioctl: cmd=0x%x (%c nr=%d len=%d dir=%d)", cmd, _IOC_TYPE(cmd),\r\n_IOC_NR(cmd), _IOC_SIZE(cmd), _IOC_DIR(cmd));\r\nif (_IOC_TYPE(cmd) == 'P')\r\nswitch (_IOC_NR(cmd)) {\r\ncase IOCNR_GET_DEVICE_ID:\r\nif (_IOC_DIR(cmd) != _IOC_READ) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nlength = usblp_cache_device_id_string(usblp);\r\nif (length < 0) {\r\nretval = length;\r\ngoto done;\r\n}\r\nif (length > _IOC_SIZE(cmd))\r\nlength = _IOC_SIZE(cmd);\r\nif (copy_to_user((void __user *) arg,\r\nusblp->device_id_string,\r\n(unsigned long) length)) {\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\nbreak;\r\ncase IOCNR_GET_PROTOCOLS:\r\nif (_IOC_DIR(cmd) != _IOC_READ ||\r\n_IOC_SIZE(cmd) < sizeof(twoints)) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\ntwoints[0] = usblp->current_protocol;\r\ntwoints[1] = 0;\r\nfor (i = USBLP_FIRST_PROTOCOL;\r\ni <= USBLP_LAST_PROTOCOL; i++) {\r\nif (usblp->protocol[i].alt_setting >= 0)\r\ntwoints[1] |= (1<<i);\r\n}\r\nif (copy_to_user((void __user *)arg,\r\n(unsigned char *)twoints,\r\nsizeof(twoints))) {\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\nbreak;\r\ncase IOCNR_SET_PROTOCOL:\r\nif (_IOC_DIR(cmd) != _IOC_WRITE) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\n#ifdef DEBUG\r\nif (arg == -10) {\r\nusblp_dump(usblp);\r\nbreak;\r\n}\r\n#endif\r\nusblp_unlink_urbs(usblp);\r\nretval = usblp_set_protocol(usblp, arg);\r\nif (retval < 0) {\r\nusblp_set_protocol(usblp,\r\nusblp->current_protocol);\r\n}\r\nbreak;\r\ncase IOCNR_HP_SET_CHANNEL:\r\nif (_IOC_DIR(cmd) != _IOC_WRITE ||\r\nle16_to_cpu(usblp->dev->descriptor.idVendor) != 0x03F0 ||\r\nusblp->quirks & USBLP_QUIRK_BIDIR) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nerr = usblp_hp_channel_change_request(usblp,\r\narg, &newChannel);\r\nif (err < 0) {\r\ndev_err(&usblp->dev->dev,\r\n"usblp%d: error = %d setting "\r\n"HP channel\n",\r\nusblp->minor, err);\r\nretval = -EIO;\r\ngoto done;\r\n}\r\ndbg("usblp%d requested/got HP channel %ld/%d",\r\nusblp->minor, arg, newChannel);\r\nbreak;\r\ncase IOCNR_GET_BUS_ADDRESS:\r\nif (_IOC_DIR(cmd) != _IOC_READ ||\r\n_IOC_SIZE(cmd) < sizeof(twoints)) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\ntwoints[0] = usblp->dev->bus->busnum;\r\ntwoints[1] = usblp->dev->devnum;\r\nif (copy_to_user((void __user *)arg,\r\n(unsigned char *)twoints,\r\nsizeof(twoints))) {\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\ndbg("usblp%d is bus=%d, device=%d",\r\nusblp->minor, twoints[0], twoints[1]);\r\nbreak;\r\ncase IOCNR_GET_VID_PID:\r\nif (_IOC_DIR(cmd) != _IOC_READ ||\r\n_IOC_SIZE(cmd) < sizeof(twoints)) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\ntwoints[0] = le16_to_cpu(usblp->dev->descriptor.idVendor);\r\ntwoints[1] = le16_to_cpu(usblp->dev->descriptor.idProduct);\r\nif (copy_to_user((void __user *)arg,\r\n(unsigned char *)twoints,\r\nsizeof(twoints))) {\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\ndbg("usblp%d is VID=0x%4.4X, PID=0x%4.4X",\r\nusblp->minor, twoints[0], twoints[1]);\r\nbreak;\r\ncase IOCNR_SOFT_RESET:\r\nif (_IOC_DIR(cmd) != _IOC_NONE) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nretval = usblp_reset(usblp);\r\nbreak;\r\ndefault:\r\nretval = -ENOTTY;\r\n}\r\nelse\r\nswitch (cmd) {\r\ncase LPGETSTATUS:\r\nif ((retval = usblp_read_status(usblp, usblp->statusbuf))) {\r\nprintk_ratelimited(KERN_ERR "usblp%d:"\r\n"failed reading printer status (%d)\n",\r\nusblp->minor, retval);\r\nretval = -EIO;\r\ngoto done;\r\n}\r\nstatus = *usblp->statusbuf;\r\nif (copy_to_user((void __user *)arg, &status, sizeof(int)))\r\nretval = -EFAULT;\r\nbreak;\r\ncase LPABORT:\r\nif (arg)\r\nusblp->flags |= LP_ABORT;\r\nelse\r\nusblp->flags &= ~LP_ABORT;\r\nbreak;\r\ndefault:\r\nretval = -ENOTTY;\r\n}\r\ndone:\r\nmutex_unlock(&usblp->mut);\r\nreturn retval;\r\n}\r\nstatic struct urb *usblp_new_writeurb(struct usblp *usblp, int transfer_length)\r\n{\r\nstruct urb *urb;\r\nchar *writebuf;\r\nif ((writebuf = kmalloc(transfer_length, GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nif ((urb = usb_alloc_urb(0, GFP_KERNEL)) == NULL) {\r\nkfree(writebuf);\r\nreturn NULL;\r\n}\r\nusb_fill_bulk_urb(urb, usblp->dev,\r\nusb_sndbulkpipe(usblp->dev,\r\nusblp->protocol[usblp->current_protocol].epwrite->bEndpointAddress),\r\nwritebuf, transfer_length, usblp_bulk_write, usblp);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nreturn urb;\r\n}\r\nstatic ssize_t usblp_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct usblp *usblp = file->private_data;\r\nstruct urb *writeurb;\r\nint rv;\r\nint transfer_length;\r\nssize_t writecount = 0;\r\nif (mutex_lock_interruptible(&usblp->wmut)) {\r\nrv = -EINTR;\r\ngoto raise_biglock;\r\n}\r\nif ((rv = usblp_wwait(usblp, !!(file->f_flags & O_NONBLOCK))) < 0)\r\ngoto raise_wait;\r\nwhile (writecount < count) {\r\nif ((transfer_length = count - writecount) > USBLP_BUF_SIZE)\r\ntransfer_length = USBLP_BUF_SIZE;\r\nrv = -ENOMEM;\r\nif ((writeurb = usblp_new_writeurb(usblp, transfer_length)) == NULL)\r\ngoto raise_urb;\r\nusb_anchor_urb(writeurb, &usblp->urbs);\r\nif (copy_from_user(writeurb->transfer_buffer,\r\nbuffer + writecount, transfer_length)) {\r\nrv = -EFAULT;\r\ngoto raise_badaddr;\r\n}\r\nspin_lock_irq(&usblp->lock);\r\nusblp->wcomplete = 0;\r\nspin_unlock_irq(&usblp->lock);\r\nif ((rv = usb_submit_urb(writeurb, GFP_KERNEL)) < 0) {\r\nusblp->wstatus = 0;\r\nspin_lock_irq(&usblp->lock);\r\nusblp->no_paper = 0;\r\nusblp->wcomplete = 1;\r\nwake_up(&usblp->wwait);\r\nspin_unlock_irq(&usblp->lock);\r\nif (rv != -ENOMEM)\r\nrv = -EIO;\r\ngoto raise_submit;\r\n}\r\nrv = usblp_wwait(usblp, !!(file->f_flags&O_NONBLOCK));\r\nif (rv < 0) {\r\nif (rv == -EAGAIN) {\r\nwritecount += transfer_length;\r\n}\r\nif (rv == -ENOSPC) {\r\nspin_lock_irq(&usblp->lock);\r\nusblp->no_paper = 1;\r\nspin_unlock_irq(&usblp->lock);\r\nwritecount += transfer_length;\r\n}\r\ngoto collect_error;\r\n}\r\nif (usblp->wstatus < 0) {\r\nrv = -EIO;\r\ngoto collect_error;\r\n}\r\nwritecount += usblp->wstatus;\r\n}\r\nmutex_unlock(&usblp->wmut);\r\nreturn writecount;\r\nraise_submit:\r\nraise_badaddr:\r\nusb_unanchor_urb(writeurb);\r\nusb_free_urb(writeurb);\r\nraise_urb:\r\nraise_wait:\r\ncollect_error:\r\nmutex_unlock(&usblp->wmut);\r\nraise_biglock:\r\nreturn writecount ? writecount : rv;\r\n}\r\nstatic ssize_t usblp_read(struct file *file, char __user *buffer, size_t len, loff_t *ppos)\r\n{\r\nstruct usblp *usblp = file->private_data;\r\nssize_t count;\r\nssize_t avail;\r\nint rv;\r\nif (!usblp->bidir)\r\nreturn -EINVAL;\r\nrv = usblp_rwait_and_lock(usblp, !!(file->f_flags & O_NONBLOCK));\r\nif (rv < 0)\r\nreturn rv;\r\nif ((avail = usblp->rstatus) < 0) {\r\nprintk(KERN_ERR "usblp%d: error %d reading from printer\n",\r\nusblp->minor, (int)avail);\r\nusblp_submit_read(usblp);\r\ncount = -EIO;\r\ngoto done;\r\n}\r\ncount = len < avail - usblp->readcount ? len : avail - usblp->readcount;\r\nif (count != 0 &&\r\ncopy_to_user(buffer, usblp->readbuf + usblp->readcount, count)) {\r\ncount = -EFAULT;\r\ngoto done;\r\n}\r\nif ((usblp->readcount += count) == avail) {\r\nif (usblp_submit_read(usblp) < 0) {\r\nif (count == 0)\r\ncount = -EIO;\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nmutex_unlock(&usblp->mut);\r\nreturn count;\r\n}\r\nstatic int usblp_wwait(struct usblp *usblp, int nonblock)\r\n{\r\nDECLARE_WAITQUEUE(waita, current);\r\nint rc;\r\nint err = 0;\r\nadd_wait_queue(&usblp->wwait, &waita);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (mutex_lock_interruptible(&usblp->mut)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\nrc = usblp_wtest(usblp, nonblock);\r\nmutex_unlock(&usblp->mut);\r\nif (rc <= 0)\r\nbreak;\r\nif (schedule_timeout(msecs_to_jiffies(1500)) == 0) {\r\nif (usblp->flags & LP_ABORT) {\r\nerr = usblp_check_status(usblp, err);\r\nif (err == 1) {\r\nrc = -ENOSPC;\r\nbreak;\r\n}\r\n} else {\r\nmutex_lock(&usblp->mut);\r\nusblp_read_status(usblp, usblp->statusbuf);\r\nmutex_unlock(&usblp->mut);\r\n}\r\n}\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&usblp->wwait, &waita);\r\nreturn rc;\r\n}\r\nstatic int usblp_wtest(struct usblp *usblp, int nonblock)\r\n{\r\nunsigned long flags;\r\nif (!usblp->present)\r\nreturn -ENODEV;\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nspin_lock_irqsave(&usblp->lock, flags);\r\nif (usblp->wcomplete) {\r\nspin_unlock_irqrestore(&usblp->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&usblp->lock, flags);\r\nif (nonblock)\r\nreturn -EAGAIN;\r\nreturn 1;\r\n}\r\nstatic int usblp_rwait_and_lock(struct usblp *usblp, int nonblock)\r\n{\r\nDECLARE_WAITQUEUE(waita, current);\r\nint rc;\r\nadd_wait_queue(&usblp->rwait, &waita);\r\nfor (;;) {\r\nif (mutex_lock_interruptible(&usblp->mut)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif ((rc = usblp_rtest(usblp, nonblock)) < 0) {\r\nmutex_unlock(&usblp->mut);\r\nbreak;\r\n}\r\nif (rc == 0)\r\nbreak;\r\nmutex_unlock(&usblp->mut);\r\nschedule();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&usblp->rwait, &waita);\r\nreturn rc;\r\n}\r\nstatic int usblp_rtest(struct usblp *usblp, int nonblock)\r\n{\r\nunsigned long flags;\r\nif (!usblp->present)\r\nreturn -ENODEV;\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nspin_lock_irqsave(&usblp->lock, flags);\r\nif (usblp->rcomplete) {\r\nspin_unlock_irqrestore(&usblp->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&usblp->lock, flags);\r\nif (nonblock)\r\nreturn -EAGAIN;\r\nreturn 1;\r\n}\r\nstatic int usblp_submit_read(struct usblp *usblp)\r\n{\r\nstruct urb *urb;\r\nunsigned long flags;\r\nint rc;\r\nrc = -ENOMEM;\r\nif ((urb = usb_alloc_urb(0, GFP_KERNEL)) == NULL)\r\ngoto raise_urb;\r\nusb_fill_bulk_urb(urb, usblp->dev,\r\nusb_rcvbulkpipe(usblp->dev,\r\nusblp->protocol[usblp->current_protocol].epread->bEndpointAddress),\r\nusblp->readbuf, USBLP_BUF_SIZE_IN,\r\nusblp_bulk_read, usblp);\r\nusb_anchor_urb(urb, &usblp->urbs);\r\nspin_lock_irqsave(&usblp->lock, flags);\r\nusblp->readcount = 0;\r\nusblp->rcomplete = 0;\r\nspin_unlock_irqrestore(&usblp->lock, flags);\r\nif ((rc = usb_submit_urb(urb, GFP_KERNEL)) < 0) {\r\ndbg("error submitting urb (%d)", rc);\r\nspin_lock_irqsave(&usblp->lock, flags);\r\nusblp->rstatus = rc;\r\nusblp->rcomplete = 1;\r\nspin_unlock_irqrestore(&usblp->lock, flags);\r\ngoto raise_submit;\r\n}\r\nreturn 0;\r\nraise_submit:\r\nusb_unanchor_urb(urb);\r\nusb_free_urb(urb);\r\nraise_urb:\r\nreturn rc;\r\n}\r\nstatic unsigned int usblp_quirks(__u16 vendor, __u16 product)\r\n{\r\nint i;\r\nfor (i = 0; quirk_printers[i].vendorId; i++) {\r\nif (vendor == quirk_printers[i].vendorId &&\r\nproduct == quirk_printers[i].productId)\r\nreturn quirk_printers[i].quirks;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *usblp_devnode(struct device *dev, mode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "usb/%s", dev_name(dev));\r\n}\r\nstatic ssize_t usblp_show_ieee1284_id(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usblp *usblp = usb_get_intfdata(intf);\r\nif (usblp->device_id_string[0] == 0 &&\r\nusblp->device_id_string[1] == 0)\r\nreturn 0;\r\nreturn sprintf(buf, "%s", usblp->device_id_string+2);\r\n}\r\nstatic int usblp_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct usblp *usblp;\r\nint protocol;\r\nint retval;\r\nusblp = kzalloc(sizeof(struct usblp), GFP_KERNEL);\r\nif (!usblp) {\r\nretval = -ENOMEM;\r\ngoto abort_ret;\r\n}\r\nusblp->dev = dev;\r\nmutex_init(&usblp->wmut);\r\nmutex_init(&usblp->mut);\r\nspin_lock_init(&usblp->lock);\r\ninit_waitqueue_head(&usblp->rwait);\r\ninit_waitqueue_head(&usblp->wwait);\r\ninit_usb_anchor(&usblp->urbs);\r\nusblp->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nusblp->intf = intf;\r\nif (!(usblp->device_id_string = kmalloc(USBLP_DEVICE_ID_SIZE, GFP_KERNEL))) {\r\nretval = -ENOMEM;\r\ngoto abort;\r\n}\r\nif (!(usblp->readbuf = kmalloc(USBLP_BUF_SIZE_IN, GFP_KERNEL))) {\r\nretval = -ENOMEM;\r\ngoto abort;\r\n}\r\nusblp->statusbuf = kmalloc(STATUS_BUF_SIZE, GFP_KERNEL);\r\nif (!usblp->statusbuf) {\r\nretval = -ENOMEM;\r\ngoto abort;\r\n}\r\nusblp->quirks = usblp_quirks(\r\nle16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct));\r\nprotocol = usblp_select_alts(usblp);\r\nif (protocol < 0) {\r\ndbg("incompatible printer-class device 0x%4.4X/0x%4.4X",\r\nle16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct));\r\nretval = -ENODEV;\r\ngoto abort;\r\n}\r\nif (usblp_set_protocol(usblp, protocol) < 0) {\r\nretval = -ENODEV;\r\ngoto abort;\r\n}\r\nusblp_cache_device_id_string(usblp);\r\nretval = device_create_file(&intf->dev, &dev_attr_ieee1284_id);\r\nif (retval)\r\ngoto abort_intfdata;\r\n#ifdef DEBUG\r\nusblp_check_status(usblp, 0);\r\n#endif\r\nusb_set_intfdata(intf, usblp);\r\nusblp->present = 1;\r\nretval = usb_register_dev(intf, &usblp_class);\r\nif (retval) {\r\nprintk(KERN_ERR "usblp: Not able to get a minor"\r\n" (base %u, slice default): %d\n",\r\nUSBLP_MINOR_BASE, retval);\r\ngoto abort_intfdata;\r\n}\r\nusblp->minor = intf->minor;\r\nprintk(KERN_INFO "usblp%d: USB %sdirectional printer dev %d "\r\n"if %d alt %d proto %d vid 0x%4.4X pid 0x%4.4X\n",\r\nusblp->minor, usblp->bidir ? "Bi" : "Uni", dev->devnum,\r\nusblp->ifnum,\r\nusblp->protocol[usblp->current_protocol].alt_setting,\r\nusblp->current_protocol,\r\nle16_to_cpu(usblp->dev->descriptor.idVendor),\r\nle16_to_cpu(usblp->dev->descriptor.idProduct));\r\nreturn 0;\r\nabort_intfdata:\r\nusb_set_intfdata(intf, NULL);\r\ndevice_remove_file(&intf->dev, &dev_attr_ieee1284_id);\r\nabort:\r\nkfree(usblp->readbuf);\r\nkfree(usblp->statusbuf);\r\nkfree(usblp->device_id_string);\r\nkfree(usblp);\r\nabort_ret:\r\nreturn retval;\r\n}\r\nstatic int usblp_select_alts(struct usblp *usblp)\r\n{\r\nstruct usb_interface *if_alt;\r\nstruct usb_host_interface *ifd;\r\nstruct usb_endpoint_descriptor *epd, *epwrite, *epread;\r\nint p, i, e;\r\nif_alt = usblp->intf;\r\nfor (p = 0; p < USBLP_MAX_PROTOCOLS; p++)\r\nusblp->protocol[p].alt_setting = -1;\r\nfor (i = 0; i < if_alt->num_altsetting; i++) {\r\nifd = &if_alt->altsetting[i];\r\nif (ifd->desc.bInterfaceClass != 7 || ifd->desc.bInterfaceSubClass != 1)\r\nif (!(usblp->quirks & USBLP_QUIRK_BAD_CLASS))\r\ncontinue;\r\nif (ifd->desc.bInterfaceProtocol < USBLP_FIRST_PROTOCOL ||\r\nifd->desc.bInterfaceProtocol > USBLP_LAST_PROTOCOL)\r\ncontinue;\r\nepwrite = epread = NULL;\r\nfor (e = 0; e < ifd->desc.bNumEndpoints; e++) {\r\nepd = &ifd->endpoint[e].desc;\r\nif (usb_endpoint_is_bulk_out(epd))\r\nif (!epwrite)\r\nepwrite = epd;\r\nif (usb_endpoint_is_bulk_in(epd))\r\nif (!epread)\r\nepread = epd;\r\n}\r\nif (!epwrite || (ifd->desc.bInterfaceProtocol > 1 && !epread))\r\ncontinue;\r\nif (ifd->desc.bInterfaceProtocol == 1) {\r\nepread = NULL;\r\n} else if (usblp->quirks & USBLP_QUIRK_BIDIR) {\r\nprintk(KERN_INFO "usblp%d: Disabling reads from "\r\n"problematic bidirectional printer\n",\r\nusblp->minor);\r\nepread = NULL;\r\n}\r\nusblp->protocol[ifd->desc.bInterfaceProtocol].alt_setting =\r\nifd->desc.bAlternateSetting;\r\nusblp->protocol[ifd->desc.bInterfaceProtocol].epwrite = epwrite;\r\nusblp->protocol[ifd->desc.bInterfaceProtocol].epread = epread;\r\n}\r\nif (proto_bias >= USBLP_FIRST_PROTOCOL &&\r\nproto_bias <= USBLP_LAST_PROTOCOL &&\r\nusblp->protocol[proto_bias].alt_setting != -1)\r\nreturn proto_bias;\r\nif (usblp->protocol[2].alt_setting != -1)\r\nreturn 2;\r\nif (usblp->protocol[1].alt_setting != -1)\r\nreturn 1;\r\nif (usblp->protocol[3].alt_setting != -1)\r\nreturn 3;\r\nreturn -1;\r\n}\r\nstatic int usblp_set_protocol(struct usblp *usblp, int protocol)\r\n{\r\nint r, alts;\r\nif (protocol < USBLP_FIRST_PROTOCOL || protocol > USBLP_LAST_PROTOCOL)\r\nreturn -EINVAL;\r\nalts = usblp->protocol[protocol].alt_setting;\r\nif (alts < 0)\r\nreturn -EINVAL;\r\nr = usb_set_interface(usblp->dev, usblp->ifnum, alts);\r\nif (r < 0) {\r\nprintk(KERN_ERR "usblp: can't set desired altsetting %d on interface %d\n",\r\nalts, usblp->ifnum);\r\nreturn r;\r\n}\r\nusblp->bidir = (usblp->protocol[protocol].epread != NULL);\r\nusblp->current_protocol = protocol;\r\ndbg("usblp%d set protocol %d", usblp->minor, protocol);\r\nreturn 0;\r\n}\r\nstatic int usblp_cache_device_id_string(struct usblp *usblp)\r\n{\r\nint err, length;\r\nerr = usblp_get_id(usblp, 0, usblp->device_id_string, USBLP_DEVICE_ID_SIZE - 1);\r\nif (err < 0) {\r\ndbg("usblp%d: error = %d reading IEEE-1284 Device ID string",\r\nusblp->minor, err);\r\nusblp->device_id_string[0] = usblp->device_id_string[1] = '\0';\r\nreturn -EIO;\r\n}\r\nlength = be16_to_cpu(*((__be16 *)usblp->device_id_string));\r\nif (length < 2)\r\nlength = 2;\r\nelse if (length >= USBLP_DEVICE_ID_SIZE)\r\nlength = USBLP_DEVICE_ID_SIZE - 1;\r\nusblp->device_id_string[length] = '\0';\r\ndbg("usblp%d Device ID string [len=%d]=\"%s\"",\r\nusblp->minor, length, &usblp->device_id_string[2]);\r\nreturn length;\r\n}\r\nstatic void usblp_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usblp *usblp = usb_get_intfdata(intf);\r\nusb_deregister_dev(intf, &usblp_class);\r\nif (!usblp || !usblp->dev) {\r\ndev_err(&intf->dev, "bogus disconnect\n");\r\nBUG();\r\n}\r\ndevice_remove_file(&intf->dev, &dev_attr_ieee1284_id);\r\nmutex_lock(&usblp_mutex);\r\nmutex_lock(&usblp->mut);\r\nusblp->present = 0;\r\nwake_up(&usblp->wwait);\r\nwake_up(&usblp->rwait);\r\nusb_set_intfdata(intf, NULL);\r\nusblp_unlink_urbs(usblp);\r\nmutex_unlock(&usblp->mut);\r\nif (!usblp->used)\r\nusblp_cleanup(usblp);\r\nmutex_unlock(&usblp_mutex);\r\n}\r\nstatic int usblp_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usblp *usblp = usb_get_intfdata(intf);\r\nusblp_unlink_urbs(usblp);\r\n#if 0\r\nwake_up(&usblp->wwait);\r\nwake_up(&usblp->rwait);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int usblp_resume(struct usb_interface *intf)\r\n{\r\nstruct usblp *usblp = usb_get_intfdata(intf);\r\nint r;\r\nr = handle_bidir(usblp);\r\nreturn r;\r\n}\r\nstatic int __init usblp_init(void)\r\n{\r\nreturn usb_register(&usblp_driver);\r\n}\r\nstatic void __exit usblp_exit(void)\r\n{\r\nusb_deregister(&usblp_driver);\r\n}
