static irqreturn_t caam_jr_interrupt(int irq, void *st_dev)\r\n{\r\nstruct device *dev = st_dev;\r\nstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\r\nu32 irqstate;\r\nirqstate = rd_reg32(&jrp->rregs->jrintstatus);\r\nif (!irqstate)\r\nreturn IRQ_NONE;\r\nif (irqstate & JRINT_JR_ERROR) {\r\ndev_err(dev, "job ring error: irqstate: %08x\n", irqstate);\r\nBUG();\r\n}\r\nsetbits32(&jrp->rregs->rconfig_lo, JRCFG_IMSK);\r\nwr_reg32(&jrp->rregs->jrintstatus, irqstate);\r\npreempt_disable();\r\ntasklet_schedule(&jrp->irqtask[smp_processor_id()]);\r\npreempt_enable();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void caam_jr_dequeue(unsigned long devarg)\r\n{\r\nint hw_idx, sw_idx, i, head, tail;\r\nstruct device *dev = (struct device *)devarg;\r\nstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\r\nvoid (*usercall)(struct device *dev, u32 *desc, u32 status, void *arg);\r\nu32 *userdesc, userstatus;\r\nvoid *userarg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&jrp->outlock, flags);\r\nhead = ACCESS_ONCE(jrp->head);\r\nsw_idx = tail = jrp->tail;\r\nwhile (CIRC_CNT(head, tail, JOBR_DEPTH) >= 1 &&\r\nrd_reg32(&jrp->rregs->outring_used)) {\r\nhw_idx = jrp->out_ring_read_index;\r\nfor (i = 0; CIRC_CNT(head, tail + i, JOBR_DEPTH) >= 1; i++) {\r\nsw_idx = (tail + i) & (JOBR_DEPTH - 1);\r\nsmp_read_barrier_depends();\r\nif (jrp->outring[hw_idx].desc ==\r\njrp->entinfo[sw_idx].desc_addr_dma)\r\nbreak;\r\n}\r\nBUG_ON(CIRC_CNT(head, tail + i, JOBR_DEPTH) <= 0);\r\ndma_unmap_single(dev, jrp->outring[hw_idx].desc,\r\njrp->entinfo[sw_idx].desc_size,\r\nDMA_TO_DEVICE);\r\njrp->entinfo[sw_idx].desc_addr_dma = 0;\r\nusercall = jrp->entinfo[sw_idx].callbk;\r\nuserarg = jrp->entinfo[sw_idx].cbkarg;\r\nuserdesc = jrp->entinfo[sw_idx].desc_addr_virt;\r\nuserstatus = jrp->outring[hw_idx].jrstatus;\r\nsmp_mb();\r\njrp->out_ring_read_index = (jrp->out_ring_read_index + 1) &\r\n(JOBR_DEPTH - 1);\r\nif (sw_idx == tail) {\r\ndo {\r\ntail = (tail + 1) & (JOBR_DEPTH - 1);\r\nsmp_read_barrier_depends();\r\n} while (CIRC_CNT(head, tail, JOBR_DEPTH) >= 1 &&\r\njrp->entinfo[tail].desc_addr_dma == 0);\r\njrp->tail = tail;\r\n}\r\nwr_reg32(&jrp->rregs->outring_rmvd, 1);\r\nspin_unlock_irqrestore(&jrp->outlock, flags);\r\nusercall(dev, userdesc, userstatus, userarg);\r\nspin_lock_irqsave(&jrp->outlock, flags);\r\nhead = ACCESS_ONCE(jrp->head);\r\nsw_idx = tail = jrp->tail;\r\n}\r\nspin_unlock_irqrestore(&jrp->outlock, flags);\r\nclrbits32(&jrp->rregs->rconfig_lo, JRCFG_IMSK);\r\n}\r\nint caam_jr_register(struct device *ctrldev, struct device **rdev)\r\n{\r\nstruct caam_drv_private *ctrlpriv = dev_get_drvdata(ctrldev);\r\nstruct caam_drv_private_jr *jrpriv = NULL;\r\nunsigned long flags;\r\nint ring;\r\nspin_lock_irqsave(&ctrlpriv->jr_alloc_lock, flags);\r\nfor (ring = 0; ring < ctrlpriv->total_jobrs; ring++) {\r\njrpriv = dev_get_drvdata(ctrlpriv->jrdev[ring]);\r\nif (jrpriv->assign == JOBR_UNASSIGNED) {\r\njrpriv->assign = JOBR_ASSIGNED;\r\n*rdev = ctrlpriv->jrdev[ring];\r\nspin_unlock_irqrestore(&ctrlpriv->jr_alloc_lock, flags);\r\nreturn ring;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ctrlpriv->jr_alloc_lock, flags);\r\n*rdev = NULL;\r\nreturn -ENODEV;\r\n}\r\nint caam_jr_deregister(struct device *rdev)\r\n{\r\nstruct caam_drv_private_jr *jrpriv = dev_get_drvdata(rdev);\r\nstruct caam_drv_private *ctrlpriv;\r\nunsigned long flags;\r\nctrlpriv = dev_get_drvdata(jrpriv->parentdev);\r\nif (rd_reg32(&jrpriv->rregs->outring_used) ||\r\n(rd_reg32(&jrpriv->rregs->inpring_avail) != JOBR_DEPTH))\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&ctrlpriv->jr_alloc_lock, flags);\r\njrpriv->assign = JOBR_UNASSIGNED;\r\nspin_unlock_irqrestore(&ctrlpriv->jr_alloc_lock, flags);\r\nreturn 0;\r\n}\r\nint caam_jr_enqueue(struct device *dev, u32 *desc,\r\nvoid (*cbk)(struct device *dev, u32 *desc,\r\nu32 status, void *areq),\r\nvoid *areq)\r\n{\r\nstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\r\nstruct caam_jrentry_info *head_entry;\r\nunsigned long flags;\r\nint head, tail, desc_size;\r\ndma_addr_t desc_dma;\r\ndesc_size = (*desc & HDR_JD_LENGTH_MASK) * sizeof(u32);\r\ndesc_dma = dma_map_single(dev, desc, desc_size, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, desc_dma)) {\r\ndev_err(dev, "caam_jr_enqueue(): can't map jobdesc\n");\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&jrp->inplock, flags);\r\nhead = jrp->head;\r\ntail = ACCESS_ONCE(jrp->tail);\r\nif (!rd_reg32(&jrp->rregs->inpring_avail) ||\r\nCIRC_SPACE(head, tail, JOBR_DEPTH) <= 0) {\r\nspin_unlock_irqrestore(&jrp->inplock, flags);\r\ndma_unmap_single(dev, desc_dma, desc_size, DMA_TO_DEVICE);\r\nreturn -EBUSY;\r\n}\r\nhead_entry = &jrp->entinfo[head];\r\nhead_entry->desc_addr_virt = desc;\r\nhead_entry->desc_size = desc_size;\r\nhead_entry->callbk = (void *)cbk;\r\nhead_entry->cbkarg = areq;\r\nhead_entry->desc_addr_dma = desc_dma;\r\njrp->inpring[jrp->inp_ring_write_index] = desc_dma;\r\nsmp_wmb();\r\njrp->inp_ring_write_index = (jrp->inp_ring_write_index + 1) &\r\n(JOBR_DEPTH - 1);\r\njrp->head = (head + 1) & (JOBR_DEPTH - 1);\r\nwmb();\r\nwr_reg32(&jrp->rregs->inpring_jobadd, 1);\r\nspin_unlock_irqrestore(&jrp->inplock, flags);\r\nreturn 0;\r\n}\r\nstatic int caam_reset_hw_jr(struct device *dev)\r\n{\r\nstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\r\nunsigned int timeout = 100000;\r\nsetbits32(&jrp->rregs->rconfig_lo, JRCFG_IMSK);\r\nwr_reg32(&jrp->rregs->jrcommand, JRCR_RESET);\r\nwhile (((rd_reg32(&jrp->rregs->jrintstatus) & JRINT_ERR_HALT_MASK) ==\r\nJRINT_ERR_HALT_INPROGRESS) && --timeout)\r\ncpu_relax();\r\nif ((rd_reg32(&jrp->rregs->jrintstatus) & JRINT_ERR_HALT_MASK) !=\r\nJRINT_ERR_HALT_COMPLETE || timeout == 0) {\r\ndev_err(dev, "failed to flush job ring %d\n", jrp->ridx);\r\nreturn -EIO;\r\n}\r\ntimeout = 100000;\r\nwr_reg32(&jrp->rregs->jrcommand, JRCR_RESET);\r\nwhile ((rd_reg32(&jrp->rregs->jrcommand) & JRCR_RESET) && --timeout)\r\ncpu_relax();\r\nif (timeout == 0) {\r\ndev_err(dev, "failed to reset job ring %d\n", jrp->ridx);\r\nreturn -EIO;\r\n}\r\nclrbits32(&jrp->rregs->rconfig_lo, JRCFG_IMSK);\r\nreturn 0;\r\n}\r\nstatic int caam_jr_init(struct device *dev)\r\n{\r\nstruct caam_drv_private_jr *jrp;\r\ndma_addr_t inpbusaddr, outbusaddr;\r\nint i, error;\r\njrp = dev_get_drvdata(dev);\r\nfor_each_possible_cpu(i)\r\ntasklet_init(&jrp->irqtask[i], caam_jr_dequeue,\r\n(unsigned long)dev);\r\nerror = request_irq(jrp->irq, caam_jr_interrupt, IRQF_SHARED,\r\n"caam-jobr", dev);\r\nif (error) {\r\ndev_err(dev, "can't connect JobR %d interrupt (%d)\n",\r\njrp->ridx, jrp->irq);\r\nirq_dispose_mapping(jrp->irq);\r\njrp->irq = 0;\r\nreturn -EINVAL;\r\n}\r\nerror = caam_reset_hw_jr(dev);\r\nif (error)\r\nreturn error;\r\njrp->inpring = kzalloc(sizeof(dma_addr_t) * JOBR_DEPTH,\r\nGFP_KERNEL | GFP_DMA);\r\njrp->outring = kzalloc(sizeof(struct jr_outentry) *\r\nJOBR_DEPTH, GFP_KERNEL | GFP_DMA);\r\njrp->entinfo = kzalloc(sizeof(struct caam_jrentry_info) * JOBR_DEPTH,\r\nGFP_KERNEL);\r\nif ((jrp->inpring == NULL) || (jrp->outring == NULL) ||\r\n(jrp->entinfo == NULL)) {\r\ndev_err(dev, "can't allocate job rings for %d\n",\r\njrp->ridx);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < JOBR_DEPTH; i++)\r\njrp->entinfo[i].desc_addr_dma = !0;\r\ninpbusaddr = dma_map_single(dev, jrp->inpring,\r\nsizeof(u32 *) * JOBR_DEPTH,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, inpbusaddr)) {\r\ndev_err(dev, "caam_jr_init(): can't map input ring\n");\r\nkfree(jrp->inpring);\r\nkfree(jrp->outring);\r\nkfree(jrp->entinfo);\r\nreturn -EIO;\r\n}\r\noutbusaddr = dma_map_single(dev, jrp->outring,\r\nsizeof(struct jr_outentry) * JOBR_DEPTH,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, outbusaddr)) {\r\ndev_err(dev, "caam_jr_init(): can't map output ring\n");\r\ndma_unmap_single(dev, inpbusaddr,\r\nsizeof(u32 *) * JOBR_DEPTH,\r\nDMA_BIDIRECTIONAL);\r\nkfree(jrp->inpring);\r\nkfree(jrp->outring);\r\nkfree(jrp->entinfo);\r\nreturn -EIO;\r\n}\r\njrp->inp_ring_write_index = 0;\r\njrp->out_ring_read_index = 0;\r\njrp->head = 0;\r\njrp->tail = 0;\r\nwr_reg64(&jrp->rregs->inpring_base, inpbusaddr);\r\nwr_reg64(&jrp->rregs->outring_base, outbusaddr);\r\nwr_reg32(&jrp->rregs->inpring_size, JOBR_DEPTH);\r\nwr_reg32(&jrp->rregs->outring_size, JOBR_DEPTH);\r\njrp->ringsize = JOBR_DEPTH;\r\nspin_lock_init(&jrp->inplock);\r\nspin_lock_init(&jrp->outlock);\r\nsetbits32(&jrp->rregs->rconfig_lo, JOBR_INTC |\r\n(JOBR_INTC_COUNT_THLD << JRCFG_ICDCT_SHIFT) |\r\n(JOBR_INTC_TIME_THLD << JRCFG_ICTT_SHIFT));\r\njrp->assign = JOBR_UNASSIGNED;\r\nreturn 0;\r\n}\r\nint caam_jr_shutdown(struct device *dev)\r\n{\r\nstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\r\ndma_addr_t inpbusaddr, outbusaddr;\r\nint ret, i;\r\nret = caam_reset_hw_jr(dev);\r\nfor_each_possible_cpu(i)\r\ntasklet_kill(&jrp->irqtask[i]);\r\nfree_irq(jrp->irq, dev);\r\ninpbusaddr = rd_reg64(&jrp->rregs->inpring_base);\r\noutbusaddr = rd_reg64(&jrp->rregs->outring_base);\r\ndma_unmap_single(dev, outbusaddr,\r\nsizeof(struct jr_outentry) * JOBR_DEPTH,\r\nDMA_BIDIRECTIONAL);\r\ndma_unmap_single(dev, inpbusaddr, sizeof(u32 *) * JOBR_DEPTH,\r\nDMA_BIDIRECTIONAL);\r\nkfree(jrp->outring);\r\nkfree(jrp->inpring);\r\nkfree(jrp->entinfo);\r\nreturn ret;\r\n}\r\nint caam_jr_probe(struct platform_device *pdev, struct device_node *np,\r\nint ring)\r\n{\r\nstruct device *ctrldev, *jrdev;\r\nstruct platform_device *jr_pdev;\r\nstruct caam_drv_private *ctrlpriv;\r\nstruct caam_drv_private_jr *jrpriv;\r\nu32 *jroffset;\r\nint error;\r\nctrldev = &pdev->dev;\r\nctrlpriv = dev_get_drvdata(ctrldev);\r\njrpriv = kmalloc(sizeof(struct caam_drv_private_jr),\r\nGFP_KERNEL);\r\nif (jrpriv == NULL) {\r\ndev_err(ctrldev, "can't alloc private mem for job ring %d\n",\r\nring);\r\nreturn -ENOMEM;\r\n}\r\njrpriv->parentdev = ctrldev;\r\njrpriv->ridx = ring;\r\njroffset = (u32 *)of_get_property(np, "reg", NULL);\r\njrpriv->rregs = (struct caam_job_ring __iomem *)((void *)ctrlpriv->ctrl\r\n+ *jroffset);\r\njr_pdev = of_platform_device_create(np, NULL, ctrldev);\r\nif (jr_pdev == NULL) {\r\nkfree(jrpriv);\r\nreturn -EINVAL;\r\n}\r\njrdev = &jr_pdev->dev;\r\ndev_set_drvdata(jrdev, jrpriv);\r\nctrlpriv->jrdev[ring] = jrdev;\r\njrpriv->irq = of_irq_to_resource(np, 0, NULL);\r\nerror = caam_jr_init(jrdev);\r\nif (error) {\r\nkfree(jrpriv);\r\nreturn error;\r\n}\r\nreturn error;\r\n}
