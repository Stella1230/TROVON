void bnx2i_identify_device(struct bnx2i_hba *hba)\r\n{\r\nhba->cnic_dev_type = 0;\r\nif ((hba->pci_did == PCI_DEVICE_ID_NX2_5706) ||\r\n(hba->pci_did == PCI_DEVICE_ID_NX2_5706S))\r\nset_bit(BNX2I_NX2_DEV_5706, &hba->cnic_dev_type);\r\nelse if ((hba->pci_did == PCI_DEVICE_ID_NX2_5708) ||\r\n(hba->pci_did == PCI_DEVICE_ID_NX2_5708S))\r\nset_bit(BNX2I_NX2_DEV_5708, &hba->cnic_dev_type);\r\nelse if ((hba->pci_did == PCI_DEVICE_ID_NX2_5709) ||\r\n(hba->pci_did == PCI_DEVICE_ID_NX2_5709S)) {\r\nset_bit(BNX2I_NX2_DEV_5709, &hba->cnic_dev_type);\r\nhba->mail_queue_access = BNX2I_MQ_BIN_MODE;\r\n} else if (hba->pci_did == PCI_DEVICE_ID_NX2_57710 ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57711 ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57711E ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57712 ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57712E ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57800 ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57800_MF ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57800_VF ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57810 ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57810_MF ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57810_VF ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57840 ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57840_MF ||\r\nhba->pci_did == PCI_DEVICE_ID_NX2_57840_VF)\r\nset_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type);\r\nelse\r\nprintk(KERN_ALERT "bnx2i: unknown device, 0x%x\n",\r\nhba->pci_did);\r\n}\r\nstruct bnx2i_hba *get_adapter_list_head(void)\r\n{\r\nstruct bnx2i_hba *hba = NULL;\r\nstruct bnx2i_hba *tmp_hba;\r\nif (!adapter_count)\r\ngoto hba_not_found;\r\nmutex_lock(&bnx2i_dev_lock);\r\nlist_for_each_entry(tmp_hba, &adapter_list, link) {\r\nif (tmp_hba->cnic && tmp_hba->cnic->cm_select_dev) {\r\nhba = tmp_hba;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&bnx2i_dev_lock);\r\nhba_not_found:\r\nreturn hba;\r\n}\r\nstruct bnx2i_hba *bnx2i_find_hba_for_cnic(struct cnic_dev *cnic)\r\n{\r\nstruct bnx2i_hba *hba, *temp;\r\nmutex_lock(&bnx2i_dev_lock);\r\nlist_for_each_entry_safe(hba, temp, &adapter_list, link) {\r\nif (hba->cnic == cnic) {\r\nmutex_unlock(&bnx2i_dev_lock);\r\nreturn hba;\r\n}\r\n}\r\nmutex_unlock(&bnx2i_dev_lock);\r\nreturn NULL;\r\n}\r\nvoid bnx2i_start(void *handle)\r\n{\r\n#define BNX2I_INIT_POLL_TIME (1000 / HZ)\r\nstruct bnx2i_hba *hba = handle;\r\nint i = HZ;\r\nBUG_ON(!hba->cnic->max_iscsi_conn);\r\nbnx2i_send_fw_iscsi_init_msg(hba);\r\nwhile (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state) && i--)\r\nmsleep(BNX2I_INIT_POLL_TIME);\r\n}\r\nstatic void bnx2i_chip_cleanup(struct bnx2i_hba *hba)\r\n{\r\nstruct bnx2i_endpoint *bnx2i_ep;\r\nstruct list_head *pos, *tmp;\r\nif (hba->ofld_conns_active) {\r\nprintk(KERN_ALERT "bnx2i: (%s) chip cleanup for %d active "\r\n"connections\n", hba->netdev->name,\r\nhba->ofld_conns_active);\r\nmutex_lock(&hba->net_dev_lock);\r\nlist_for_each_safe(pos, tmp, &hba->ep_active_list) {\r\nbnx2i_ep = list_entry(pos, struct bnx2i_endpoint, link);\r\nbnx2i_hw_ep_disconnect(bnx2i_ep);\r\nbnx2i_ep->cm_sk = NULL;\r\n}\r\nmutex_unlock(&hba->net_dev_lock);\r\n}\r\n}\r\nvoid bnx2i_stop(void *handle)\r\n{\r\nstruct bnx2i_hba *hba = handle;\r\nint conns_active;\r\nint wait_delay = 1 * HZ;\r\nif (!test_and_set_bit(ADAPTER_STATE_GOING_DOWN,\r\n&hba->adapter_state)) {\r\niscsi_host_for_each_session(hba->shost,\r\nbnx2i_drop_session);\r\nwait_delay = hba->hba_shutdown_tmo;\r\n}\r\nwait_event_interruptible_timeout(hba->eh_wait,\r\n(list_empty(&hba->ep_ofld_list) &&\r\nlist_empty(&hba->ep_destroy_list)),\r\n2 * HZ);\r\nwhile (hba->ofld_conns_active) {\r\nconns_active = hba->ofld_conns_active;\r\nwait_event_interruptible_timeout(hba->eh_wait,\r\n(hba->ofld_conns_active != conns_active),\r\nwait_delay);\r\nif (hba->ofld_conns_active == conns_active)\r\nbreak;\r\n}\r\nbnx2i_chip_cleanup(hba);\r\nclear_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\r\nclear_bit(ADAPTER_STATE_UP, &hba->adapter_state);\r\n}\r\nstatic int bnx2i_init_one(struct bnx2i_hba *hba, struct cnic_dev *cnic)\r\n{\r\nint rc;\r\nmutex_lock(&bnx2i_dev_lock);\r\nif (!cnic->max_iscsi_conn) {\r\nprintk(KERN_ALERT "bnx2i: dev %s does not support "\r\n"iSCSI\n", hba->netdev->name);\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nhba->cnic = cnic;\r\nrc = cnic->register_device(cnic, CNIC_ULP_ISCSI, hba);\r\nif (!rc) {\r\nhba->age++;\r\nset_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\r\nlist_add_tail(&hba->link, &adapter_list);\r\nadapter_count++;\r\n} else if (rc == -EBUSY)\r\nprintk(KERN_ALERT "bnx2i, duplicate registration"\r\n"hba=%p, cnic=%p\n", hba, cnic);\r\nelse if (rc == -EAGAIN)\r\nprintk(KERN_ERR "bnx2i, driver not registered\n");\r\nelse if (rc == -EINVAL)\r\nprintk(KERN_ERR "bnx2i, invalid type %d\n", CNIC_ULP_ISCSI);\r\nelse\r\nprintk(KERN_ERR "bnx2i dev reg, unknown error, %d\n", rc);\r\nout:\r\nmutex_unlock(&bnx2i_dev_lock);\r\nreturn rc;\r\n}\r\nvoid bnx2i_ulp_init(struct cnic_dev *dev)\r\n{\r\nstruct bnx2i_hba *hba;\r\nhba = bnx2i_alloc_hba(dev);\r\nif (!hba) {\r\nprintk(KERN_ERR "bnx2i init: hba initialization failed\n");\r\nreturn;\r\n}\r\nclear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\r\nif (bnx2i_init_one(hba, dev)) {\r\nprintk(KERN_ERR "bnx2i - hba %p init failed\n", hba);\r\nbnx2i_free_hba(hba);\r\n}\r\n}\r\nvoid bnx2i_ulp_exit(struct cnic_dev *dev)\r\n{\r\nstruct bnx2i_hba *hba;\r\nhba = bnx2i_find_hba_for_cnic(dev);\r\nif (!hba) {\r\nprintk(KERN_INFO "bnx2i_ulp_exit: hba not "\r\n"found, dev 0x%p\n", dev);\r\nreturn;\r\n}\r\nmutex_lock(&bnx2i_dev_lock);\r\nlist_del_init(&hba->link);\r\nadapter_count--;\r\nif (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {\r\nhba->cnic->unregister_device(hba->cnic, CNIC_ULP_ISCSI);\r\nclear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\r\n}\r\nmutex_unlock(&bnx2i_dev_lock);\r\nbnx2i_free_hba(hba);\r\n}\r\nstatic void bnx2i_percpu_thread_create(unsigned int cpu)\r\n{\r\nstruct bnx2i_percpu_s *p;\r\nstruct task_struct *thread;\r\np = &per_cpu(bnx2i_percpu, cpu);\r\nthread = kthread_create(bnx2i_percpu_io_thread, (void *)p,\r\n"bnx2i_thread/%d", cpu);\r\nif (likely(!IS_ERR(thread))) {\r\nkthread_bind(thread, cpu);\r\np->iothread = thread;\r\nwake_up_process(thread);\r\n}\r\n}\r\nstatic void bnx2i_percpu_thread_destroy(unsigned int cpu)\r\n{\r\nstruct bnx2i_percpu_s *p;\r\nstruct task_struct *thread;\r\nstruct bnx2i_work *work, *tmp;\r\np = &per_cpu(bnx2i_percpu, cpu);\r\nspin_lock_bh(&p->p_work_lock);\r\nthread = p->iothread;\r\np->iothread = NULL;\r\nlist_for_each_entry_safe(work, tmp, &p->work_list, list) {\r\nlist_del_init(&work->list);\r\nbnx2i_process_scsi_cmd_resp(work->session,\r\nwork->bnx2i_conn, &work->cqe);\r\nkfree(work);\r\n}\r\nspin_unlock_bh(&p->p_work_lock);\r\nif (thread)\r\nkthread_stop(thread);\r\n}\r\nstatic int bnx2i_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned cpu = (unsigned long)hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nprintk(KERN_INFO "bnx2i: CPU %x online: Create Rx thread\n",\r\ncpu);\r\nbnx2i_percpu_thread_create(cpu);\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nprintk(KERN_INFO "CPU %x offline: Remove Rx thread\n", cpu);\r\nbnx2i_percpu_thread_destroy(cpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init bnx2i_mod_init(void)\r\n{\r\nint err;\r\nunsigned cpu = 0;\r\nstruct bnx2i_percpu_s *p;\r\nprintk(KERN_INFO "%s", version);\r\nif (sq_size && !is_power_of_2(sq_size))\r\nsq_size = roundup_pow_of_two(sq_size);\r\nmutex_init(&bnx2i_dev_lock);\r\nbnx2i_scsi_xport_template =\r\niscsi_register_transport(&bnx2i_iscsi_transport);\r\nif (!bnx2i_scsi_xport_template) {\r\nprintk(KERN_ERR "Could not register bnx2i transport.\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = cnic_register_driver(CNIC_ULP_ISCSI, &bnx2i_cnic_cb);\r\nif (err) {\r\nprintk(KERN_ERR "Could not register bnx2i cnic driver.\n");\r\ngoto unreg_xport;\r\n}\r\nfor_each_possible_cpu(cpu) {\r\np = &per_cpu(bnx2i_percpu, cpu);\r\nINIT_LIST_HEAD(&p->work_list);\r\nspin_lock_init(&p->p_work_lock);\r\np->iothread = NULL;\r\n}\r\nfor_each_online_cpu(cpu)\r\nbnx2i_percpu_thread_create(cpu);\r\nregister_hotcpu_notifier(&bnx2i_cpu_notifier);\r\nreturn 0;\r\nunreg_xport:\r\niscsi_unregister_transport(&bnx2i_iscsi_transport);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit bnx2i_mod_exit(void)\r\n{\r\nstruct bnx2i_hba *hba;\r\nunsigned cpu = 0;\r\nmutex_lock(&bnx2i_dev_lock);\r\nwhile (!list_empty(&adapter_list)) {\r\nhba = list_entry(adapter_list.next, struct bnx2i_hba, link);\r\nlist_del(&hba->link);\r\nadapter_count--;\r\nif (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {\r\nbnx2i_chip_cleanup(hba);\r\nhba->cnic->unregister_device(hba->cnic, CNIC_ULP_ISCSI);\r\nclear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\r\n}\r\nbnx2i_free_hba(hba);\r\n}\r\nmutex_unlock(&bnx2i_dev_lock);\r\nunregister_hotcpu_notifier(&bnx2i_cpu_notifier);\r\nfor_each_online_cpu(cpu)\r\nbnx2i_percpu_thread_destroy(cpu);\r\niscsi_unregister_transport(&bnx2i_iscsi_transport);\r\ncnic_unregister_driver(CNIC_ULP_ISCSI);\r\n}
