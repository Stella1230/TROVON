static int ad1836_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad1836_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint word_len = 0;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nword_len = AD1836_WORD_LEN_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nword_len = AD1836_WORD_LEN_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nword_len = AD1836_WORD_LEN_24;\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, AD1836_DAC_CTRL1, AD1836_DAC_WORD_LEN_MASK,\r\nword_len << AD1836_DAC_WORD_LEN_OFFSET);\r\nsnd_soc_update_bits(codec, AD1836_ADC_CTRL2, AD1836_ADC_WORD_LEN_MASK,\r\nword_len << AD1836_ADC_WORD_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int ad1836_suspend(struct snd_soc_codec *codec, pm_message_t state)\r\n{\r\nreturn snd_soc_update_bits(codec, AD1836_ADC_CTRL2,\r\nAD1836_ADC_SERFMT_MASK, 0);\r\n}\r\nstatic int ad1836_resume(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_update_bits(codec, AD1836_ADC_CTRL2,\r\nAD1836_ADC_SERFMT_MASK, AD1836_ADC_AUX);\r\n}\r\nstatic int ad1836_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ad1836_priv *ad1836 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint num_dacs, num_adcs;\r\nint ret = 0;\r\nint i;\r\nnum_dacs = ad183x_dais[ad1836->type].playback.channels_max / 2;\r\nnum_adcs = ad183x_dais[ad1836->type].capture.channels_max / 2;\r\nret = snd_soc_codec_set_cache_io(codec, 4, 12, SND_SOC_SPI);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to set cache I/O: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsnd_soc_write(codec, AD1836_DAC_CTRL1, 0x300);\r\nsnd_soc_write(codec, AD1836_DAC_CTRL2, 0x0);\r\nsnd_soc_write(codec, AD1836_ADC_CTRL1, 0x100);\r\nsnd_soc_write(codec, AD1836_ADC_CTRL2, 0x180);\r\nfor (i = 1; i <= num_dacs; ++i) {\r\nsnd_soc_write(codec, AD1836_DAC_L_VOL(i), 0x3FF);\r\nsnd_soc_write(codec, AD1836_DAC_R_VOL(i), 0x3FF);\r\n}\r\nif (ad1836->type == AD1836) {\r\nsnd_soc_write(codec, AD1836_ADC_CTRL3, 0x3A);\r\nret = snd_soc_add_controls(codec, ad1836_controls,\r\nARRAY_SIZE(ad1836_controls));\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nsnd_soc_write(codec, AD1836_ADC_CTRL3, 0x00);\r\n}\r\nret = snd_soc_add_controls(codec, ad183x_dac_controls, num_dacs * 2);\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_add_controls(codec, ad183x_adc_controls, num_adcs);\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_new_controls(dapm, ad183x_dac_dapm_widgets, num_dacs);\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_new_controls(dapm, ad183x_adc_dapm_widgets, num_adcs);\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_add_routes(dapm, ad183x_dac_routes, num_dacs);\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_add_routes(dapm, ad183x_adc_routes, num_adcs);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int ad1836_remove(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_update_bits(codec, AD1836_ADC_CTRL2,\r\nAD1836_ADC_SERFMT_MASK, 0);\r\n}\r\nstatic int __devinit ad1836_spi_probe(struct spi_device *spi)\r\n{\r\nstruct ad1836_priv *ad1836;\r\nint ret;\r\nad1836 = kzalloc(sizeof(struct ad1836_priv), GFP_KERNEL);\r\nif (ad1836 == NULL)\r\nreturn -ENOMEM;\r\nad1836->type = spi_get_device_id(spi)->driver_data;\r\nspi_set_drvdata(spi, ad1836);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_ad1836, &ad183x_dais[ad1836->type], 1);\r\nif (ret < 0)\r\nkfree(ad1836);\r\nreturn ret;\r\n}\r\nstatic int __devexit ad1836_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nkfree(spi_get_drvdata(spi));\r\nreturn 0;\r\n}\r\nstatic int __init ad1836_init(void)\r\n{\r\nreturn spi_register_driver(&ad1836_spi_driver);\r\n}\r\nstatic void __exit ad1836_exit(void)\r\n{\r\nspi_unregister_driver(&ad1836_spi_driver);\r\n}
