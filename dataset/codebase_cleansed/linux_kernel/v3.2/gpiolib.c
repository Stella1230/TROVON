static inline void desc_set_label(struct gpio_desc *d, const char *label)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nd->label = label;\r\n#endif\r\n}\r\nstatic int gpio_ensure_requested(struct gpio_desc *desc, unsigned offset)\r\n{\r\nconst struct gpio_chip *chip = desc->chip;\r\nconst int gpio = chip->base + offset;\r\nif (WARN(test_and_set_bit(FLAG_REQUESTED, &desc->flags) == 0,\r\n"autorequest GPIO-%d\n", gpio)) {\r\nif (!try_module_get(chip->owner)) {\r\npr_err("GPIO-%d: module can't be gotten \n", gpio);\r\nclear_bit(FLAG_REQUESTED, &desc->flags);\r\nreturn -EIO;\r\n}\r\ndesc_set_label(desc, "[auto]");\r\nif (chip->request)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct gpio_chip *gpio_to_chip(unsigned gpio)\r\n{\r\nreturn gpio_desc[gpio].chip;\r\n}\r\nstatic int gpiochip_find_base(int ngpio)\r\n{\r\nint i;\r\nint spare = 0;\r\nint base = -ENOSPC;\r\nfor (i = ARCH_NR_GPIOS - 1; i >= 0 ; i--) {\r\nstruct gpio_desc *desc = &gpio_desc[i];\r\nstruct gpio_chip *chip = desc->chip;\r\nif (!chip && !test_bit(FLAG_RESERVED, &desc->flags)) {\r\nspare++;\r\nif (spare == ngpio) {\r\nbase = i;\r\nbreak;\r\n}\r\n} else {\r\nspare = 0;\r\nif (chip)\r\ni -= chip->ngpio - 1;\r\n}\r\n}\r\nif (gpio_is_valid(base))\r\npr_debug("%s: found new base at %d\n", __func__, base);\r\nreturn base;\r\n}\r\nint __init gpiochip_reserve(int start, int ngpio)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nint i;\r\nif (!gpio_is_valid(start) || !gpio_is_valid(start + ngpio - 1))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nfor (i = start; i < start + ngpio; i++) {\r\nstruct gpio_desc *desc = &gpio_desc[i];\r\nif (desc->chip || test_bit(FLAG_RESERVED, &desc->flags)) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nset_bit(FLAG_RESERVED, &desc->flags);\r\n}\r\npr_debug("%s: reserved gpios from %d to %d\n",\r\n__func__, start, start + ngpio - 1);\r\nerr:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t gpio_direction_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse\r\nstatus = sprintf(buf, "%s\n",\r\ntest_bit(FLAG_IS_OUT, &desc->flags)\r\n? "out" : "in");\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_direction_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nunsigned gpio = desc - gpio_desc;\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse if (sysfs_streq(buf, "high"))\r\nstatus = gpio_direction_output(gpio, 1);\r\nelse if (sysfs_streq(buf, "out") || sysfs_streq(buf, "low"))\r\nstatus = gpio_direction_output(gpio, 0);\r\nelse if (sysfs_streq(buf, "in"))\r\nstatus = gpio_direction_input(gpio);\r\nelse\r\nstatus = -EINVAL;\r\nmutex_unlock(&sysfs_lock);\r\nreturn status ? : size;\r\n}\r\nstatic ssize_t gpio_value_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nunsigned gpio = desc - gpio_desc;\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstatus = -EIO;\r\n} else {\r\nint value;\r\nvalue = !!gpio_get_value_cansleep(gpio);\r\nif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\r\nvalue = !value;\r\nstatus = sprintf(buf, "%d\n", value);\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_value_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nunsigned gpio = desc - gpio_desc;\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse if (!test_bit(FLAG_IS_OUT, &desc->flags))\r\nstatus = -EPERM;\r\nelse {\r\nlong value;\r\nstatus = strict_strtol(buf, 0, &value);\r\nif (status == 0) {\r\nif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\r\nvalue = !value;\r\ngpio_set_value_cansleep(gpio, value != 0);\r\nstatus = size;\r\n}\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic irqreturn_t gpio_sysfs_irq(int irq, void *priv)\r\n{\r\nstruct sysfs_dirent *value_sd = priv;\r\nsysfs_notify_dirent(value_sd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gpio_setup_irq(struct gpio_desc *desc, struct device *dev,\r\nunsigned long gpio_flags)\r\n{\r\nstruct sysfs_dirent *value_sd;\r\nunsigned long irq_flags;\r\nint ret, irq, id;\r\nif ((desc->flags & GPIO_TRIGGER_MASK) == gpio_flags)\r\nreturn 0;\r\nirq = gpio_to_irq(desc - gpio_desc);\r\nif (irq < 0)\r\nreturn -EIO;\r\nid = desc->flags >> ID_SHIFT;\r\nvalue_sd = idr_find(&dirent_idr, id);\r\nif (value_sd)\r\nfree_irq(irq, value_sd);\r\ndesc->flags &= ~GPIO_TRIGGER_MASK;\r\nif (!gpio_flags) {\r\nret = 0;\r\ngoto free_id;\r\n}\r\nirq_flags = IRQF_SHARED;\r\nif (test_bit(FLAG_TRIG_FALL, &gpio_flags))\r\nirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\r\nIRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;\r\nif (test_bit(FLAG_TRIG_RISE, &gpio_flags))\r\nirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\r\nIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\r\nif (!value_sd) {\r\nvalue_sd = sysfs_get_dirent(dev->kobj.sd, NULL, "value");\r\nif (!value_sd) {\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\ndo {\r\nret = -ENOMEM;\r\nif (idr_pre_get(&dirent_idr, GFP_KERNEL))\r\nret = idr_get_new_above(&dirent_idr, value_sd,\r\n1, &id);\r\n} while (ret == -EAGAIN);\r\nif (ret)\r\ngoto free_sd;\r\ndesc->flags &= GPIO_FLAGS_MASK;\r\ndesc->flags |= (unsigned long)id << ID_SHIFT;\r\nif (desc->flags >> ID_SHIFT != id) {\r\nret = -ERANGE;\r\ngoto free_id;\r\n}\r\n}\r\nret = request_any_context_irq(irq, gpio_sysfs_irq, irq_flags,\r\n"gpiolib", value_sd);\r\nif (ret < 0)\r\ngoto free_id;\r\ndesc->flags |= gpio_flags;\r\nreturn 0;\r\nfree_id:\r\nidr_remove(&dirent_idr, id);\r\ndesc->flags &= GPIO_FLAGS_MASK;\r\nfree_sd:\r\nif (value_sd)\r\nsysfs_put(value_sd);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic ssize_t gpio_edge_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse {\r\nint i;\r\nstatus = 0;\r\nfor (i = 0; i < ARRAY_SIZE(trigger_types); i++)\r\nif ((desc->flags & GPIO_TRIGGER_MASK)\r\n== trigger_types[i].flags) {\r\nstatus = sprintf(buf, "%s\n",\r\ntrigger_types[i].name);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_edge_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(trigger_types); i++)\r\nif (sysfs_streq(trigger_types[i].name, buf))\r\ngoto found;\r\nreturn -EINVAL;\r\nfound:\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse {\r\nstatus = gpio_setup_irq(desc, dev, trigger_types[i].flags);\r\nif (!status)\r\nstatus = size;\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic int sysfs_set_active_low(struct gpio_desc *desc, struct device *dev,\r\nint value)\r\n{\r\nint status = 0;\r\nif (!!test_bit(FLAG_ACTIVE_LOW, &desc->flags) == !!value)\r\nreturn 0;\r\nif (value)\r\nset_bit(FLAG_ACTIVE_LOW, &desc->flags);\r\nelse\r\nclear_bit(FLAG_ACTIVE_LOW, &desc->flags);\r\nif (dev != NULL && (!!test_bit(FLAG_TRIG_RISE, &desc->flags) ^\r\n!!test_bit(FLAG_TRIG_FALL, &desc->flags))) {\r\nunsigned long trigger_flags = desc->flags & GPIO_TRIGGER_MASK;\r\ngpio_setup_irq(desc, dev, 0);\r\nstatus = gpio_setup_irq(desc, dev, trigger_flags);\r\n}\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_active_low_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse\r\nstatus = sprintf(buf, "%d\n",\r\n!!test_bit(FLAG_ACTIVE_LOW, &desc->flags));\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_active_low_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstatus = -EIO;\r\n} else {\r\nlong value;\r\nstatus = strict_strtol(buf, 0, &value);\r\nif (status == 0)\r\nstatus = sysfs_set_active_low(desc, dev, value != 0);\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status ? : size;\r\n}\r\nstatic ssize_t chip_base_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->base);\r\n}\r\nstatic ssize_t chip_label_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", chip->label ? : "");\r\n}\r\nstatic ssize_t chip_ngpio_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", chip->ngpio);\r\n}\r\nstatic ssize_t export_store(struct class *class,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nlong gpio;\r\nint status;\r\nstatus = strict_strtol(buf, 0, &gpio);\r\nif (status < 0)\r\ngoto done;\r\nstatus = gpio_request(gpio, "sysfs");\r\nif (status < 0)\r\ngoto done;\r\nstatus = gpio_export(gpio, true);\r\nif (status < 0)\r\ngpio_free(gpio);\r\nelse\r\nset_bit(FLAG_SYSFS, &gpio_desc[gpio].flags);\r\ndone:\r\nif (status)\r\npr_debug("%s: status %d\n", __func__, status);\r\nreturn status ? : len;\r\n}\r\nstatic ssize_t unexport_store(struct class *class,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nlong gpio;\r\nint status;\r\nstatus = strict_strtol(buf, 0, &gpio);\r\nif (status < 0)\r\ngoto done;\r\nstatus = -EINVAL;\r\nif (!gpio_is_valid(gpio))\r\ngoto done;\r\nif (test_and_clear_bit(FLAG_SYSFS, &gpio_desc[gpio].flags)) {\r\nstatus = 0;\r\ngpio_free(gpio);\r\n}\r\ndone:\r\nif (status)\r\npr_debug("%s: status %d\n", __func__, status);\r\nreturn status ? : len;\r\n}\r\nint gpio_export(unsigned gpio, bool direction_may_change)\r\n{\r\nunsigned long flags;\r\nstruct gpio_desc *desc;\r\nint status = -EINVAL;\r\nconst char *ioname = NULL;\r\nif (!gpio_class.p) {\r\npr_debug("%s: called too early!\n", __func__);\r\nreturn -ENOENT;\r\n}\r\nif (!gpio_is_valid(gpio))\r\ngoto done;\r\nmutex_lock(&sysfs_lock);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\ndesc = &gpio_desc[gpio];\r\nif (test_bit(FLAG_REQUESTED, &desc->flags)\r\n&& !test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstatus = 0;\r\nif (!desc->chip->direction_input\r\n|| !desc->chip->direction_output)\r\ndirection_may_change = false;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (desc->chip->names && desc->chip->names[gpio - desc->chip->base])\r\nioname = desc->chip->names[gpio - desc->chip->base];\r\nif (status == 0) {\r\nstruct device *dev;\r\ndev = device_create(&gpio_class, desc->chip->dev, MKDEV(0, 0),\r\ndesc, ioname ? ioname : "gpio%u", gpio);\r\nif (!IS_ERR(dev)) {\r\nstatus = sysfs_create_group(&dev->kobj,\r\n&gpio_attr_group);\r\nif (!status && direction_may_change)\r\nstatus = device_create_file(dev,\r\n&dev_attr_direction);\r\nif (!status && gpio_to_irq(gpio) >= 0\r\n&& (direction_may_change\r\n|| !test_bit(FLAG_IS_OUT,\r\n&desc->flags)))\r\nstatus = device_create_file(dev,\r\n&dev_attr_edge);\r\nif (status != 0)\r\ndevice_unregister(dev);\r\n} else\r\nstatus = PTR_ERR(dev);\r\nif (status == 0)\r\nset_bit(FLAG_EXPORT, &desc->flags);\r\n}\r\nmutex_unlock(&sysfs_lock);\r\ndone:\r\nif (status)\r\npr_debug("%s: gpio%d status %d\n", __func__, gpio, status);\r\nreturn status;\r\n}\r\nstatic int match_export(struct device *dev, void *data)\r\n{\r\nreturn dev_get_drvdata(dev) == data;\r\n}\r\nint gpio_export_link(struct device *dev, const char *name, unsigned gpio)\r\n{\r\nstruct gpio_desc *desc;\r\nint status = -EINVAL;\r\nif (!gpio_is_valid(gpio))\r\ngoto done;\r\nmutex_lock(&sysfs_lock);\r\ndesc = &gpio_desc[gpio];\r\nif (test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstruct device *tdev;\r\ntdev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (tdev != NULL) {\r\nstatus = sysfs_create_link(&dev->kobj, &tdev->kobj,\r\nname);\r\n} else {\r\nstatus = -ENODEV;\r\n}\r\n}\r\nmutex_unlock(&sysfs_lock);\r\ndone:\r\nif (status)\r\npr_debug("%s: gpio%d status %d\n", __func__, gpio, status);\r\nreturn status;\r\n}\r\nint gpio_sysfs_set_active_low(unsigned gpio, int value)\r\n{\r\nstruct gpio_desc *desc;\r\nstruct device *dev = NULL;\r\nint status = -EINVAL;\r\nif (!gpio_is_valid(gpio))\r\ngoto done;\r\nmutex_lock(&sysfs_lock);\r\ndesc = &gpio_desc[gpio];\r\nif (test_bit(FLAG_EXPORT, &desc->flags)) {\r\ndev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (dev == NULL) {\r\nstatus = -ENODEV;\r\ngoto unlock;\r\n}\r\n}\r\nstatus = sysfs_set_active_low(desc, dev, value);\r\nunlock:\r\nmutex_unlock(&sysfs_lock);\r\ndone:\r\nif (status)\r\npr_debug("%s: gpio%d status %d\n", __func__, gpio, status);\r\nreturn status;\r\n}\r\nvoid gpio_unexport(unsigned gpio)\r\n{\r\nstruct gpio_desc *desc;\r\nint status = 0;\r\nif (!gpio_is_valid(gpio)) {\r\nstatus = -EINVAL;\r\ngoto done;\r\n}\r\nmutex_lock(&sysfs_lock);\r\ndesc = &gpio_desc[gpio];\r\nif (test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstruct device *dev = NULL;\r\ndev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (dev) {\r\ngpio_setup_irq(desc, dev, 0);\r\nclear_bit(FLAG_EXPORT, &desc->flags);\r\nput_device(dev);\r\ndevice_unregister(dev);\r\n} else\r\nstatus = -ENODEV;\r\n}\r\nmutex_unlock(&sysfs_lock);\r\ndone:\r\nif (status)\r\npr_debug("%s: gpio%d status %d\n", __func__, gpio, status);\r\n}\r\nstatic int gpiochip_export(struct gpio_chip *chip)\r\n{\r\nint status;\r\nstruct device *dev;\r\nif (!gpio_class.p)\r\nreturn 0;\r\nmutex_lock(&sysfs_lock);\r\ndev = device_create(&gpio_class, chip->dev, MKDEV(0, 0), chip,\r\n"gpiochip%d", chip->base);\r\nif (!IS_ERR(dev)) {\r\nstatus = sysfs_create_group(&dev->kobj,\r\n&gpiochip_attr_group);\r\n} else\r\nstatus = PTR_ERR(dev);\r\nchip->exported = (status == 0);\r\nmutex_unlock(&sysfs_lock);\r\nif (status) {\r\nunsigned long flags;\r\nunsigned gpio;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\ngpio = chip->base;\r\nwhile (gpio_desc[gpio].chip == chip)\r\ngpio_desc[gpio++].chip = NULL;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\npr_debug("%s: chip %s status %d\n", __func__,\r\nchip->label, status);\r\n}\r\nreturn status;\r\n}\r\nstatic void gpiochip_unexport(struct gpio_chip *chip)\r\n{\r\nint status;\r\nstruct device *dev;\r\nmutex_lock(&sysfs_lock);\r\ndev = class_find_device(&gpio_class, NULL, chip, match_export);\r\nif (dev) {\r\nput_device(dev);\r\ndevice_unregister(dev);\r\nchip->exported = 0;\r\nstatus = 0;\r\n} else\r\nstatus = -ENODEV;\r\nmutex_unlock(&sysfs_lock);\r\nif (status)\r\npr_debug("%s: chip %s status %d\n", __func__,\r\nchip->label, status);\r\n}\r\nstatic int __init gpiolib_sysfs_init(void)\r\n{\r\nint status;\r\nunsigned long flags;\r\nunsigned gpio;\r\nstatus = class_register(&gpio_class);\r\nif (status < 0)\r\nreturn status;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nfor (gpio = 0; gpio < ARCH_NR_GPIOS; gpio++) {\r\nstruct gpio_chip *chip;\r\nchip = gpio_desc[gpio].chip;\r\nif (!chip || chip->exported)\r\ncontinue;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nstatus = gpiochip_export(chip);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn status;\r\n}\r\nstatic inline int gpiochip_export(struct gpio_chip *chip)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void gpiochip_unexport(struct gpio_chip *chip)\r\n{\r\n}\r\nint gpiochip_add(struct gpio_chip *chip)\r\n{\r\nunsigned long flags;\r\nint status = 0;\r\nunsigned id;\r\nint base = chip->base;\r\nif ((!gpio_is_valid(base) || !gpio_is_valid(base + chip->ngpio - 1))\r\n&& base >= 0) {\r\nstatus = -EINVAL;\r\ngoto fail;\r\n}\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (base < 0) {\r\nbase = gpiochip_find_base(chip->ngpio);\r\nif (base < 0) {\r\nstatus = base;\r\ngoto unlock;\r\n}\r\nchip->base = base;\r\n}\r\nfor (id = base; id < base + chip->ngpio; id++) {\r\nif (gpio_desc[id].chip != NULL) {\r\nstatus = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nif (status == 0) {\r\nfor (id = base; id < base + chip->ngpio; id++) {\r\ngpio_desc[id].chip = chip;\r\ngpio_desc[id].flags = !chip->direction_input\r\n? (1 << FLAG_IS_OUT)\r\n: 0;\r\n}\r\n}\r\nof_gpiochip_add(chip);\r\nunlock:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (status)\r\ngoto fail;\r\nstatus = gpiochip_export(chip);\r\nif (status)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\npr_err("gpiochip_add: gpios %d..%d (%s) failed to register\n",\r\nchip->base, chip->base + chip->ngpio - 1,\r\nchip->label ? : "generic");\r\nreturn status;\r\n}\r\nint gpiochip_remove(struct gpio_chip *chip)\r\n{\r\nunsigned long flags;\r\nint status = 0;\r\nunsigned id;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nof_gpiochip_remove(chip);\r\nfor (id = chip->base; id < chip->base + chip->ngpio; id++) {\r\nif (test_bit(FLAG_REQUESTED, &gpio_desc[id].flags)) {\r\nstatus = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nif (status == 0) {\r\nfor (id = chip->base; id < chip->base + chip->ngpio; id++)\r\ngpio_desc[id].chip = NULL;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (status == 0)\r\ngpiochip_unexport(chip);\r\nreturn status;\r\n}\r\nstruct gpio_chip *gpiochip_find(void *data,\r\nint (*match)(struct gpio_chip *chip, void *data))\r\n{\r\nstruct gpio_chip *chip = NULL;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nfor (i = 0; i < ARCH_NR_GPIOS; i++) {\r\nif (!gpio_desc[i].chip)\r\ncontinue;\r\nif (match(gpio_desc[i].chip, data)) {\r\nchip = gpio_desc[i].chip;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn chip;\r\n}\r\nint gpio_request(unsigned gpio, const char *label)\r\n{\r\nstruct gpio_desc *desc;\r\nstruct gpio_chip *chip;\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (!gpio_is_valid(gpio))\r\ngoto done;\r\ndesc = &gpio_desc[gpio];\r\nchip = desc->chip;\r\nif (chip == NULL)\r\ngoto done;\r\nif (!try_module_get(chip->owner))\r\ngoto done;\r\nif (test_and_set_bit(FLAG_REQUESTED, &desc->flags) == 0) {\r\ndesc_set_label(desc, label ? : "?");\r\nstatus = 0;\r\n} else {\r\nstatus = -EBUSY;\r\nmodule_put(chip->owner);\r\ngoto done;\r\n}\r\nif (chip->request) {\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nstatus = chip->request(chip, gpio - chip->base);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (status < 0) {\r\ndesc_set_label(desc, NULL);\r\nmodule_put(chip->owner);\r\nclear_bit(FLAG_REQUESTED, &desc->flags);\r\n}\r\n}\r\ndone:\r\nif (status)\r\npr_debug("gpio_request: gpio-%d (%s) status %d\n",\r\ngpio, label ? : "?", status);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn status;\r\n}\r\nvoid gpio_free(unsigned gpio)\r\n{\r\nunsigned long flags;\r\nstruct gpio_desc *desc;\r\nstruct gpio_chip *chip;\r\nmight_sleep();\r\nif (!gpio_is_valid(gpio)) {\r\nWARN_ON(extra_checks);\r\nreturn;\r\n}\r\ngpio_unexport(gpio);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\ndesc = &gpio_desc[gpio];\r\nchip = desc->chip;\r\nif (chip && test_bit(FLAG_REQUESTED, &desc->flags)) {\r\nif (chip->free) {\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nmight_sleep_if(chip->can_sleep);\r\nchip->free(chip, gpio - chip->base);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\n}\r\ndesc_set_label(desc, NULL);\r\nmodule_put(desc->chip->owner);\r\nclear_bit(FLAG_ACTIVE_LOW, &desc->flags);\r\nclear_bit(FLAG_REQUESTED, &desc->flags);\r\n} else\r\nWARN_ON(extra_checks);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\n}\r\nint gpio_request_one(unsigned gpio, unsigned long flags, const char *label)\r\n{\r\nint err;\r\nerr = gpio_request(gpio, label);\r\nif (err)\r\nreturn err;\r\nif (flags & GPIOF_DIR_IN)\r\nerr = gpio_direction_input(gpio);\r\nelse\r\nerr = gpio_direction_output(gpio,\r\n(flags & GPIOF_INIT_HIGH) ? 1 : 0);\r\nif (err)\r\ngpio_free(gpio);\r\nreturn err;\r\n}\r\nint gpio_request_array(const struct gpio *array, size_t num)\r\n{\r\nint i, err;\r\nfor (i = 0; i < num; i++, array++) {\r\nerr = gpio_request_one(array->gpio, array->flags, array->label);\r\nif (err)\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nwhile (i--)\r\ngpio_free((--array)->gpio);\r\nreturn err;\r\n}\r\nvoid gpio_free_array(const struct gpio *array, size_t num)\r\n{\r\nwhile (num--)\r\ngpio_free((array++)->gpio);\r\n}\r\nconst char *gpiochip_is_requested(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned gpio = chip->base + offset;\r\nif (!gpio_is_valid(gpio) || gpio_desc[gpio].chip != chip)\r\nreturn NULL;\r\nif (test_bit(FLAG_REQUESTED, &gpio_desc[gpio].flags) == 0)\r\nreturn NULL;\r\n#ifdef CONFIG_DEBUG_FS\r\nreturn gpio_desc[gpio].label;\r\n#else\r\nreturn "?";\r\n#endif\r\n}\r\nint gpio_direction_input(unsigned gpio)\r\n{\r\nunsigned long flags;\r\nstruct gpio_chip *chip;\r\nstruct gpio_desc *desc = &gpio_desc[gpio];\r\nint status = -EINVAL;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (!gpio_is_valid(gpio))\r\ngoto fail;\r\nchip = desc->chip;\r\nif (!chip || !chip->get || !chip->direction_input)\r\ngoto fail;\r\ngpio -= chip->base;\r\nif (gpio >= chip->ngpio)\r\ngoto fail;\r\nstatus = gpio_ensure_requested(desc, gpio);\r\nif (status < 0)\r\ngoto fail;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nmight_sleep_if(chip->can_sleep);\r\nif (status) {\r\nstatus = chip->request(chip, gpio);\r\nif (status < 0) {\r\npr_debug("GPIO-%d: chip request fail, %d\n",\r\nchip->base + gpio, status);\r\ngoto lose;\r\n}\r\n}\r\nstatus = chip->direction_input(chip, gpio);\r\nif (status == 0)\r\nclear_bit(FLAG_IS_OUT, &desc->flags);\r\ntrace_gpio_direction(chip->base + gpio, 1, status);\r\nlose:\r\nreturn status;\r\nfail:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (status)\r\npr_debug("%s: gpio-%d status %d\n",\r\n__func__, gpio, status);\r\nreturn status;\r\n}\r\nint gpio_direction_output(unsigned gpio, int value)\r\n{\r\nunsigned long flags;\r\nstruct gpio_chip *chip;\r\nstruct gpio_desc *desc = &gpio_desc[gpio];\r\nint status = -EINVAL;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (!gpio_is_valid(gpio))\r\ngoto fail;\r\nchip = desc->chip;\r\nif (!chip || !chip->set || !chip->direction_output)\r\ngoto fail;\r\ngpio -= chip->base;\r\nif (gpio >= chip->ngpio)\r\ngoto fail;\r\nstatus = gpio_ensure_requested(desc, gpio);\r\nif (status < 0)\r\ngoto fail;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nmight_sleep_if(chip->can_sleep);\r\nif (status) {\r\nstatus = chip->request(chip, gpio);\r\nif (status < 0) {\r\npr_debug("GPIO-%d: chip request fail, %d\n",\r\nchip->base + gpio, status);\r\ngoto lose;\r\n}\r\n}\r\nstatus = chip->direction_output(chip, gpio, value);\r\nif (status == 0)\r\nset_bit(FLAG_IS_OUT, &desc->flags);\r\ntrace_gpio_value(chip->base + gpio, 0, value);\r\ntrace_gpio_direction(chip->base + gpio, 0, status);\r\nlose:\r\nreturn status;\r\nfail:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (status)\r\npr_debug("%s: gpio-%d status %d\n",\r\n__func__, gpio, status);\r\nreturn status;\r\n}\r\nint gpio_set_debounce(unsigned gpio, unsigned debounce)\r\n{\r\nunsigned long flags;\r\nstruct gpio_chip *chip;\r\nstruct gpio_desc *desc = &gpio_desc[gpio];\r\nint status = -EINVAL;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (!gpio_is_valid(gpio))\r\ngoto fail;\r\nchip = desc->chip;\r\nif (!chip || !chip->set || !chip->set_debounce)\r\ngoto fail;\r\ngpio -= chip->base;\r\nif (gpio >= chip->ngpio)\r\ngoto fail;\r\nstatus = gpio_ensure_requested(desc, gpio);\r\nif (status < 0)\r\ngoto fail;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nmight_sleep_if(chip->can_sleep);\r\nreturn chip->set_debounce(chip, gpio, debounce);\r\nfail:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nif (status)\r\npr_debug("%s: gpio-%d status %d\n",\r\n__func__, gpio, status);\r\nreturn status;\r\n}\r\nint __gpio_get_value(unsigned gpio)\r\n{\r\nstruct gpio_chip *chip;\r\nint value;\r\nchip = gpio_to_chip(gpio);\r\nWARN_ON(chip->can_sleep);\r\nvalue = chip->get ? chip->get(chip, gpio - chip->base) : 0;\r\ntrace_gpio_value(gpio, 1, value);\r\nreturn value;\r\n}\r\nvoid __gpio_set_value(unsigned gpio, int value)\r\n{\r\nstruct gpio_chip *chip;\r\nchip = gpio_to_chip(gpio);\r\nWARN_ON(chip->can_sleep);\r\ntrace_gpio_value(gpio, 0, value);\r\nchip->set(chip, gpio - chip->base, value);\r\n}\r\nint __gpio_cansleep(unsigned gpio)\r\n{\r\nstruct gpio_chip *chip;\r\nchip = gpio_to_chip(gpio);\r\nreturn chip->can_sleep;\r\n}\r\nint __gpio_to_irq(unsigned gpio)\r\n{\r\nstruct gpio_chip *chip;\r\nchip = gpio_to_chip(gpio);\r\nreturn chip->to_irq ? chip->to_irq(chip, gpio - chip->base) : -ENXIO;\r\n}\r\nint gpio_get_value_cansleep(unsigned gpio)\r\n{\r\nstruct gpio_chip *chip;\r\nint value;\r\nmight_sleep_if(extra_checks);\r\nchip = gpio_to_chip(gpio);\r\nvalue = chip->get ? chip->get(chip, gpio - chip->base) : 0;\r\ntrace_gpio_value(gpio, 1, value);\r\nreturn value;\r\n}\r\nvoid gpio_set_value_cansleep(unsigned gpio, int value)\r\n{\r\nstruct gpio_chip *chip;\r\nmight_sleep_if(extra_checks);\r\nchip = gpio_to_chip(gpio);\r\ntrace_gpio_value(gpio, 0, value);\r\nchip->set(chip, gpio - chip->base, value);\r\n}\r\nstatic void gpiolib_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nunsigned i;\r\nunsigned gpio = chip->base;\r\nstruct gpio_desc *gdesc = &gpio_desc[gpio];\r\nint is_out;\r\nfor (i = 0; i < chip->ngpio; i++, gpio++, gdesc++) {\r\nif (!test_bit(FLAG_REQUESTED, &gdesc->flags))\r\ncontinue;\r\nis_out = test_bit(FLAG_IS_OUT, &gdesc->flags);\r\nseq_printf(s, " gpio-%-3d (%-20.20s) %s %s",\r\ngpio, gdesc->label,\r\nis_out ? "out" : "in ",\r\nchip->get\r\n? (chip->get(chip, i) ? "hi" : "lo")\r\n: "? ");\r\nseq_printf(s, "\n");\r\n}\r\n}\r\nstatic int gpiolib_show(struct seq_file *s, void *unused)\r\n{\r\nstruct gpio_chip *chip = NULL;\r\nunsigned gpio;\r\nint started = 0;\r\nfor (gpio = 0; gpio_is_valid(gpio); gpio++) {\r\nstruct device *dev;\r\nif (chip == gpio_desc[gpio].chip)\r\ncontinue;\r\nchip = gpio_desc[gpio].chip;\r\nif (!chip)\r\ncontinue;\r\nseq_printf(s, "%sGPIOs %d-%d",\r\nstarted ? "\n" : "",\r\nchip->base, chip->base + chip->ngpio - 1);\r\ndev = chip->dev;\r\nif (dev)\r\nseq_printf(s, ", %s/%s",\r\ndev->bus ? dev->bus->name : "no-bus",\r\ndev_name(dev));\r\nif (chip->label)\r\nseq_printf(s, ", %s", chip->label);\r\nif (chip->can_sleep)\r\nseq_printf(s, ", can sleep");\r\nseq_printf(s, ":\n");\r\nstarted = 1;\r\nif (chip->dbg_show)\r\nchip->dbg_show(s, chip);\r\nelse\r\ngpiolib_dbg_show(s, chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpiolib_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, gpiolib_show, NULL);\r\n}\r\nstatic int __init gpiolib_debugfs_init(void)\r\n{\r\n(void) debugfs_create_file("gpio", S_IFREG | S_IRUGO,\r\nNULL, NULL, &gpiolib_operations);\r\nreturn 0;\r\n}
