void flush_user_windows(void)\r\n{\r\nregister int ctr asm("g5");\r\nctr = 0;\r\n__asm__ __volatile__(\r\n"\n1:\n\t"\r\n"ld [%%g6 + %2], %%g4\n\t"\r\n"orcc %%g0, %%g4, %%g0\n\t"\r\n"add %0, 1, %0\n\t"\r\n"bne 1b\n\t"\r\n" save %%sp, -64, %%sp\n"\r\n"2:\n\t"\r\n"subcc %0, 1, %0\n\t"\r\n"bne 2b\n\t"\r\n" restore %%g0, %%g0, %%g0\n"\r\n: "=&r" (ctr)\r\n: "0" (ctr),\r\n"i" ((const unsigned long)TI_UWINMASK)\r\n: "g4", "cc");\r\n}\r\nstatic inline void shift_window_buffer(int first_win, int last_win, struct thread_info *tp)\r\n{\r\nint i;\r\nfor(i = first_win; i < last_win; i++) {\r\ntp->rwbuf_stkptrs[i] = tp->rwbuf_stkptrs[i+1];\r\nmemcpy(&tp->reg_window[i], &tp->reg_window[i+1], sizeof(struct reg_window32));\r\n}\r\n}\r\nvoid synchronize_user_stack(void)\r\n{\r\nstruct thread_info *tp = current_thread_info();\r\nint window;\r\nflush_user_windows();\r\nif(!tp->w_saved)\r\nreturn;\r\nfor(window = tp->w_saved - 1; window >= 0; window--) {\r\nunsigned long sp = tp->rwbuf_stkptrs[window];\r\nif (copy_to_user((char __user *) sp, &tp->reg_window[window],\r\nsizeof(struct reg_window32)))\r\ncontinue;\r\nshift_window_buffer(window, tp->w_saved - 1, tp);\r\ntp->w_saved--;\r\n}\r\n}\r\nvoid try_to_clear_window_buffer(struct pt_regs *regs, int who)\r\n{\r\nstruct thread_info *tp = current_thread_info();\r\nint window;\r\nflush_user_windows();\r\nfor(window = 0; window < tp->w_saved; window++) {\r\nunsigned long sp = tp->rwbuf_stkptrs[window];\r\nif ((sp & 7) ||\r\ncopy_to_user((char __user *) sp, &tp->reg_window[window],\r\nsizeof(struct reg_window32)))\r\ndo_exit(SIGILL);\r\n}\r\ntp->w_saved = 0;\r\n}
