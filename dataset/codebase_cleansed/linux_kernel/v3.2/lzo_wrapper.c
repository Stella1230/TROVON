static void *lzo_init(struct squashfs_sb_info *msblk, void *buff, int len)\r\n{\r\nint block_size = max_t(int, msblk->block_size, SQUASHFS_METADATA_SIZE);\r\nstruct squashfs_lzo *stream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (stream == NULL)\r\ngoto failed;\r\nstream->input = vmalloc(block_size);\r\nif (stream->input == NULL)\r\ngoto failed;\r\nstream->output = vmalloc(block_size);\r\nif (stream->output == NULL)\r\ngoto failed2;\r\nreturn stream;\r\nfailed2:\r\nvfree(stream->input);\r\nfailed:\r\nERROR("Failed to allocate lzo workspace\n");\r\nkfree(stream);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void lzo_free(void *strm)\r\n{\r\nstruct squashfs_lzo *stream = strm;\r\nif (stream) {\r\nvfree(stream->input);\r\nvfree(stream->output);\r\n}\r\nkfree(stream);\r\n}\r\nstatic int lzo_uncompress(struct squashfs_sb_info *msblk, void **buffer,\r\nstruct buffer_head **bh, int b, int offset, int length, int srclength,\r\nint pages)\r\n{\r\nstruct squashfs_lzo *stream = msblk->stream;\r\nvoid *buff = stream->input;\r\nint avail, i, bytes = length, res;\r\nsize_t out_len = srclength;\r\nmutex_lock(&msblk->read_data_mutex);\r\nfor (i = 0; i < b; i++) {\r\nwait_on_buffer(bh[i]);\r\nif (!buffer_uptodate(bh[i]))\r\ngoto block_release;\r\navail = min(bytes, msblk->devblksize - offset);\r\nmemcpy(buff, bh[i]->b_data + offset, avail);\r\nbuff += avail;\r\nbytes -= avail;\r\noffset = 0;\r\nput_bh(bh[i]);\r\n}\r\nres = lzo1x_decompress_safe(stream->input, (size_t)length,\r\nstream->output, &out_len);\r\nif (res != LZO_E_OK)\r\ngoto failed;\r\nres = bytes = (int)out_len;\r\nfor (i = 0, buff = stream->output; bytes && i < pages; i++) {\r\navail = min_t(int, bytes, PAGE_CACHE_SIZE);\r\nmemcpy(buffer[i], buff, avail);\r\nbuff += avail;\r\nbytes -= avail;\r\n}\r\nmutex_unlock(&msblk->read_data_mutex);\r\nreturn res;\r\nblock_release:\r\nfor (; i < b; i++)\r\nput_bh(bh[i]);\r\nfailed:\r\nmutex_unlock(&msblk->read_data_mutex);\r\nERROR("lzo decompression failed, data probably corrupt\n");\r\nreturn -EIO;\r\n}
