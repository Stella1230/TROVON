static void __init m68k_parse_bootinfo(const struct bi_record *record)\r\n{\r\nwhile (record->tag != BI_LAST) {\r\nint unknown = 0;\r\nconst unsigned long *data = record->data;\r\nswitch (record->tag) {\r\ncase BI_MACHTYPE:\r\ncase BI_CPUTYPE:\r\ncase BI_FPUTYPE:\r\ncase BI_MMUTYPE:\r\nbreak;\r\ncase BI_MEMCHUNK:\r\nif (m68k_num_memory < NUM_MEMINFO) {\r\nm68k_memory[m68k_num_memory].addr = data[0];\r\nm68k_memory[m68k_num_memory].size = data[1];\r\nm68k_num_memory++;\r\n} else\r\nprintk("m68k_parse_bootinfo: too many memory chunks\n");\r\nbreak;\r\ncase BI_RAMDISK:\r\nm68k_ramdisk.addr = data[0];\r\nm68k_ramdisk.size = data[1];\r\nbreak;\r\ncase BI_COMMAND_LINE:\r\nstrlcpy(m68k_command_line, (const char *)data,\r\nsizeof(m68k_command_line));\r\nbreak;\r\ndefault:\r\nif (MACH_IS_AMIGA)\r\nunknown = amiga_parse_bootinfo(record);\r\nelse if (MACH_IS_ATARI)\r\nunknown = atari_parse_bootinfo(record);\r\nelse if (MACH_IS_MAC)\r\nunknown = mac_parse_bootinfo(record);\r\nelse if (MACH_IS_Q40)\r\nunknown = q40_parse_bootinfo(record);\r\nelse if (MACH_IS_BVME6000)\r\nunknown = bvme6000_parse_bootinfo(record);\r\nelse if (MACH_IS_MVME16x)\r\nunknown = mvme16x_parse_bootinfo(record);\r\nelse if (MACH_IS_MVME147)\r\nunknown = mvme147_parse_bootinfo(record);\r\nelse if (MACH_IS_HP300)\r\nunknown = hp300_parse_bootinfo(record);\r\nelse if (MACH_IS_APOLLO)\r\nunknown = apollo_parse_bootinfo(record);\r\nelse\r\nunknown = 1;\r\n}\r\nif (unknown)\r\nprintk("m68k_parse_bootinfo: unknown tag 0x%04x ignored\n",\r\nrecord->tag);\r\nrecord = (struct bi_record *)((unsigned long)record +\r\nrecord->size);\r\n}\r\nm68k_realnum_memory = m68k_num_memory;\r\n#ifdef CONFIG_SINGLE_MEMORY_CHUNK\r\nif (m68k_num_memory > 1) {\r\nprintk("Ignoring last %i chunks of physical memory\n",\r\n(m68k_num_memory - 1));\r\nm68k_num_memory = 1;\r\n}\r\n#endif\r\n}\r\nvoid __init setup_arch(char **cmdline_p)\r\n{\r\n#ifndef CONFIG_SUN3\r\nint i;\r\n#endif\r\nm68k_parse_bootinfo((const struct bi_record *)_end);\r\nif (CPU_IS_040)\r\nm68k_is040or060 = 4;\r\nelse if (CPU_IS_060)\r\nm68k_is040or060 = 6;\r\n#ifndef CONFIG_M68KFPU_EMU_ONLY\r\nif (m68k_fputype & (FPU_68881|FPU_68882|FPU_68040|FPU_68060)) {\r\nvolatile int zero = 0;\r\nasm volatile ("frestore %0" : : "m" (zero));\r\n}\r\n#endif\r\nif (CPU_IS_060) {\r\nu32 pcr;\r\nasm (".chip 68060; movec %%pcr,%0; .chip 68k"\r\n: "=d" (pcr));\r\nif (((pcr >> 8) & 0xff) <= 5) {\r\nprintk("Enabling workaround for errata I14\n");\r\nasm (".chip 68060; movec %0,%%pcr; .chip 68k"\r\n: : "d" (pcr | 0x20));\r\n}\r\n}\r\ninit_mm.start_code = PAGE_OFFSET;\r\ninit_mm.end_code = (unsigned long)_etext;\r\ninit_mm.end_data = (unsigned long)_edata;\r\ninit_mm.brk = (unsigned long)_end;\r\n*cmdline_p = m68k_command_line;\r\nmemcpy(boot_command_line, *cmdline_p, CL_SIZE);\r\nparse_early_param();\r\n#ifdef CONFIG_DUMMY_CONSOLE\r\nconswitchp = &dummy_con;\r\n#endif\r\nswitch (m68k_machtype) {\r\n#ifdef CONFIG_AMIGA\r\ncase MACH_AMIGA:\r\nconfig_amiga();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ATARI\r\ncase MACH_ATARI:\r\nconfig_atari();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MAC\r\ncase MACH_MAC:\r\nconfig_mac();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_SUN3\r\ncase MACH_SUN3:\r\nconfig_sun3();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_APOLLO\r\ncase MACH_APOLLO:\r\nconfig_apollo();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MVME147\r\ncase MACH_MVME147:\r\nconfig_mvme147();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MVME16x\r\ncase MACH_MVME16x:\r\nconfig_mvme16x();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_BVME6000\r\ncase MACH_BVME6000:\r\nconfig_bvme6000();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_HP300\r\ncase MACH_HP300:\r\nconfig_hp300();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_Q40\r\ncase MACH_Q40:\r\nconfig_q40();\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_SUN3X\r\ncase MACH_SUN3X:\r\nconfig_sun3x();\r\nbreak;\r\n#endif\r\ndefault:\r\npanic("No configuration setup");\r\n}\r\n#ifdef CONFIG_NATFEAT\r\nnf_init();\r\n#endif\r\npaging_init();\r\n#ifndef CONFIG_SUN3\r\nfor (i = 1; i < m68k_num_memory; i++)\r\nfree_bootmem_node(NODE_DATA(i), m68k_memory[i].addr,\r\nm68k_memory[i].size);\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (m68k_ramdisk.size) {\r\nreserve_bootmem_node(__virt_to_node(phys_to_virt(m68k_ramdisk.addr)),\r\nm68k_ramdisk.addr, m68k_ramdisk.size,\r\nBOOTMEM_DEFAULT);\r\ninitrd_start = (unsigned long)phys_to_virt(m68k_ramdisk.addr);\r\ninitrd_end = initrd_start + m68k_ramdisk.size;\r\nprintk("initrd: %08lx - %08lx\n", initrd_start, initrd_end);\r\n}\r\n#endif\r\n#ifdef CONFIG_ATARI\r\nif (MACH_IS_ATARI)\r\natari_stram_reserve_pages((void *)availmem);\r\n#endif\r\n#ifdef CONFIG_SUN3X\r\nif (MACH_IS_SUN3X) {\r\ndvma_init();\r\n}\r\n#endif\r\n#endif\r\n#if defined(CONFIG_ISA) && defined(MULTI_ISA)\r\nif (MACH_IS_Q40) {\r\nisa_type = ISA_TYPE_Q40;\r\nisa_sex = 0;\r\n}\r\n#ifdef CONFIG_AMIGA_PCMCIA\r\nif (MACH_IS_AMIGA && AMIGAHW_PRESENT(PCMCIA)) {\r\nisa_type = ISA_TYPE_AG;\r\nisa_sex = 1;\r\n}\r\n#endif\r\n#endif\r\n}\r\nstatic int show_cpuinfo(struct seq_file *m, void *v)\r\n{\r\nconst char *cpu, *mmu, *fpu;\r\nunsigned long clockfreq, clockfactor;\r\n#define LOOP_CYCLES_68020 (8)\r\n#define LOOP_CYCLES_68030 (8)\r\n#define LOOP_CYCLES_68040 (3)\r\n#define LOOP_CYCLES_68060 (1)\r\nif (CPU_IS_020) {\r\ncpu = "68020";\r\nclockfactor = LOOP_CYCLES_68020;\r\n} else if (CPU_IS_030) {\r\ncpu = "68030";\r\nclockfactor = LOOP_CYCLES_68030;\r\n} else if (CPU_IS_040) {\r\ncpu = "68040";\r\nclockfactor = LOOP_CYCLES_68040;\r\n} else if (CPU_IS_060) {\r\ncpu = "68060";\r\nclockfactor = LOOP_CYCLES_68060;\r\n} else {\r\ncpu = "680x0";\r\nclockfactor = 0;\r\n}\r\n#ifdef CONFIG_M68KFPU_EMU_ONLY\r\nfpu = "none(soft float)";\r\n#else\r\nif (m68k_fputype & FPU_68881)\r\nfpu = "68881";\r\nelse if (m68k_fputype & FPU_68882)\r\nfpu = "68882";\r\nelse if (m68k_fputype & FPU_68040)\r\nfpu = "68040";\r\nelse if (m68k_fputype & FPU_68060)\r\nfpu = "68060";\r\nelse if (m68k_fputype & FPU_SUNFPA)\r\nfpu = "Sun FPA";\r\nelse\r\nfpu = "none";\r\n#endif\r\nif (m68k_mmutype & MMU_68851)\r\nmmu = "68851";\r\nelse if (m68k_mmutype & MMU_68030)\r\nmmu = "68030";\r\nelse if (m68k_mmutype & MMU_68040)\r\nmmu = "68040";\r\nelse if (m68k_mmutype & MMU_68060)\r\nmmu = "68060";\r\nelse if (m68k_mmutype & MMU_SUN3)\r\nmmu = "Sun-3";\r\nelse if (m68k_mmutype & MMU_APOLLO)\r\nmmu = "Apollo";\r\nelse\r\nmmu = "unknown";\r\nclockfreq = loops_per_jiffy * HZ * clockfactor;\r\nseq_printf(m, "CPU:\t\t%s\n"\r\n"MMU:\t\t%s\n"\r\n"FPU:\t\t%s\n"\r\n"Clocking:\t%lu.%1luMHz\n"\r\n"BogoMips:\t%lu.%02lu\n"\r\n"Calibration:\t%lu loops\n",\r\ncpu, mmu, fpu,\r\nclockfreq/1000000,(clockfreq/100000)%10,\r\nloops_per_jiffy/(500000/HZ),(loops_per_jiffy/(5000/HZ))%100,\r\nloops_per_jiffy);\r\nreturn 0;\r\n}\r\nstatic void *c_start(struct seq_file *m, loff_t *pos)\r\n{\r\nreturn *pos < 1 ? (void *)1 : NULL;\r\n}\r\nstatic void *c_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn NULL;\r\n}\r\nstatic void c_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int hardware_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar model[80];\r\nunsigned long mem;\r\nint i;\r\nif (mach_get_model)\r\nmach_get_model(model);\r\nelse\r\nstrcpy(model, "Unknown m68k");\r\nseq_printf(m, "Model:\t\t%s\n", model);\r\nfor (mem = 0, i = 0; i < m68k_num_memory; i++)\r\nmem += m68k_memory[i].size;\r\nseq_printf(m, "System Memory:\t%ldK\n", mem >> 10);\r\nif (mach_get_hardware_list)\r\nmach_get_hardware_list(m);\r\nreturn 0;\r\n}\r\nstatic int hardware_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, hardware_proc_show, NULL);\r\n}\r\nstatic int __init proc_hardware_init(void)\r\n{\r\nproc_create("hardware", 0, NULL, &hardware_proc_fops);\r\nreturn 0;\r\n}\r\nvoid check_bugs(void)\r\n{\r\n#ifndef CONFIG_M68KFPU_EMU\r\nif (m68k_fputype == 0) {\r\nprintk(KERN_EMERG "*** YOU DO NOT HAVE A FLOATING POINT UNIT, "\r\n"WHICH IS REQUIRED BY LINUX/M68K ***\n");\r\nprintk(KERN_EMERG "Upgrade your hardware or join the FPU "\r\n"emulation project\n");\r\npanic("no FPU");\r\n}\r\n#endif\r\n}\r\nstatic int __init adb_probe_sync_enable (char *str) {\r\nextern int __adb_probe_sync;\r\n__adb_probe_sync = 1;\r\nreturn 1;\r\n}
