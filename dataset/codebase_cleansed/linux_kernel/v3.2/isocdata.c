void gigaset_isowbuf_init(struct isowbuf_t *iwb, unsigned char idle)\r\n{\r\niwb->read = 0;\r\niwb->nextread = 0;\r\niwb->write = 0;\r\natomic_set(&iwb->writesem, 1);\r\niwb->wbits = 0;\r\niwb->idle = idle;\r\nmemset(iwb->data + BAS_OUTBUFSIZE, idle, BAS_OUTBUFPAD);\r\n}\r\nstatic inline int isowbuf_freebytes(struct isowbuf_t *iwb)\r\n{\r\nint read, write, freebytes;\r\nread = iwb->read;\r\nwrite = iwb->write;\r\nfreebytes = read - write;\r\nif (freebytes > 0) {\r\nreturn freebytes - BAS_OUTBUFPAD;\r\n} else if (read < BAS_OUTBUFPAD) {\r\nreturn BAS_OUTBUFSIZE - write;\r\n} else {\r\nreturn freebytes + BAS_OUTBUFSIZE - BAS_OUTBUFPAD;\r\n}\r\n}\r\nstatic inline int isowbuf_startwrite(struct isowbuf_t *iwb)\r\n{\r\nif (!atomic_dec_and_test(&iwb->writesem)) {\r\natomic_inc(&iwb->writesem);\r\ngig_dbg(DEBUG_ISO, "%s: couldn't acquire iso write semaphore",\r\n__func__);\r\nreturn 0;\r\n}\r\ngig_dbg(DEBUG_ISO,\r\n"%s: acquired iso write semaphore, data[write]=%02x, nbits=%d",\r\n__func__, iwb->data[iwb->write], iwb->wbits);\r\nreturn 1;\r\n}\r\nstatic inline int isowbuf_donewrite(struct isowbuf_t *iwb)\r\n{\r\nint write = iwb->write;\r\natomic_inc(&iwb->writesem);\r\nreturn write;\r\n}\r\nstatic inline void isowbuf_putbits(struct isowbuf_t *iwb, u32 data, int nbits)\r\n{\r\nint write = iwb->write;\r\ndata <<= iwb->wbits;\r\ndata |= iwb->data[write];\r\nnbits += iwb->wbits;\r\nwhile (nbits >= 8) {\r\niwb->data[write++] = data & 0xff;\r\nwrite %= BAS_OUTBUFSIZE;\r\ndata >>= 8;\r\nnbits -= 8;\r\n}\r\niwb->wbits = nbits;\r\niwb->data[write] = data & 0xff;\r\niwb->write = write;\r\n}\r\nstatic inline void isowbuf_putflag(struct isowbuf_t *iwb)\r\n{\r\nint write;\r\nisowbuf_putbits(iwb, 0x7e7e, 8);\r\nwrite = iwb->write;\r\niwb->idle = iwb->data[write];\r\ngig_dbg(DEBUG_ISO, "idle fill byte %02x", iwb->idle);\r\niwb->data[write] &= (1 << iwb->wbits) - 1;\r\n}\r\nint gigaset_isowbuf_getbytes(struct isowbuf_t *iwb, int size)\r\n{\r\nint read, write, limit, src, dst;\r\nunsigned char pbyte;\r\nread = iwb->nextread;\r\nwrite = iwb->write;\r\nif (likely(read == write)) {\r\nreturn read < BAS_OUTBUFPAD ?\r\nBAS_OUTBUFSIZE : read - BAS_OUTBUFPAD;\r\n}\r\nlimit = read + size;\r\ngig_dbg(DEBUG_STREAM, "%s: read=%d write=%d limit=%d",\r\n__func__, read, write, limit);\r\n#ifdef CONFIG_GIGASET_DEBUG\r\nif (unlikely(size < 0 || size > BAS_OUTBUFPAD)) {\r\npr_err("invalid size %d\n", size);\r\nreturn -EINVAL;\r\n}\r\n#endif\r\nif (read < write) {\r\nif (limit >= write) {\r\nif (!isowbuf_startwrite(iwb))\r\nreturn -EBUSY;\r\nwrite = iwb->write;\r\nif (limit >= write) {\r\npbyte = iwb->data[write];\r\nlimit = write + BAS_OUTBUFPAD;\r\ngig_dbg(DEBUG_STREAM,\r\n"%s: filling %d->%d with %02x",\r\n__func__, write, limit, iwb->idle);\r\nif (write + BAS_OUTBUFPAD < BAS_OUTBUFSIZE)\r\nmemset(iwb->data + write, iwb->idle,\r\nBAS_OUTBUFPAD);\r\nelse {\r\nmemset(iwb->data + write, iwb->idle,\r\nBAS_OUTBUFSIZE + BAS_OUTBUFPAD\r\n- write);\r\nlimit = 0;\r\n}\r\ngig_dbg(DEBUG_STREAM,\r\n"%s: restoring %02x at %d",\r\n__func__, pbyte, limit);\r\niwb->data[limit] = pbyte;\r\niwb->write = limit;\r\n}\r\nisowbuf_donewrite(iwb);\r\n}\r\n} else {\r\nif (limit >= BAS_OUTBUFSIZE) {\r\nsrc = 0;\r\ndst = BAS_OUTBUFSIZE;\r\nwhile (dst < limit && src < write)\r\niwb->data[dst++] = iwb->data[src++];\r\nif (dst <= limit) {\r\nmemset(iwb->data + dst, iwb->idle,\r\nBAS_OUTBUFSIZE + BAS_OUTBUFPAD - dst);\r\n}\r\nlimit = src;\r\n}\r\n}\r\niwb->nextread = limit;\r\nreturn read;\r\n}\r\nstatic inline void dump_bytes(enum debuglevel level, const char *tag,\r\nunsigned char *bytes, int count)\r\n{\r\n#ifdef CONFIG_GIGASET_DEBUG\r\nunsigned char c;\r\nstatic char dbgline[3 * 32 + 1];\r\nint i = 0;\r\nif (!(gigaset_debuglevel & level))\r\nreturn;\r\nwhile (count-- > 0) {\r\nif (i > sizeof(dbgline) - 4) {\r\ndbgline[i] = '\0';\r\ngig_dbg(level, "%s:%s", tag, dbgline);\r\ni = 0;\r\n}\r\nc = *bytes++;\r\ndbgline[i] = (i && !(i % 12)) ? '-' : ' ';\r\ni++;\r\ndbgline[i++] = hex_asc_hi(c);\r\ndbgline[i++] = hex_asc_lo(c);\r\n}\r\ndbgline[i] = '\0';\r\ngig_dbg(level, "%s:%s", tag, dbgline);\r\n#endif\r\n}\r\nstatic inline int hdlc_bitstuff_byte(struct isowbuf_t *iwb, unsigned char cin,\r\nint ones)\r\n{\r\nu16 stuff;\r\nint shiftinc, newones;\r\nstuff = stufftab[256 * ones + cin];\r\nshiftinc = (stuff >> 13) & 3;\r\nnewones = (stuff >> 10) & 7;\r\nstuff &= 0x3ff;\r\nisowbuf_putbits(iwb, stuff, 8 + shiftinc);\r\nreturn newones;\r\n}\r\nstatic inline int hdlc_buildframe(struct isowbuf_t *iwb,\r\nunsigned char *in, int count)\r\n{\r\nint ones;\r\nu16 fcs;\r\nint end;\r\nunsigned char c;\r\nif (isowbuf_freebytes(iwb) < count + count / 5 + 6 ||\r\n!isowbuf_startwrite(iwb)) {\r\ngig_dbg(DEBUG_ISO, "%s: %d bytes free -> -EAGAIN",\r\n__func__, isowbuf_freebytes(iwb));\r\nreturn -EAGAIN;\r\n}\r\ndump_bytes(DEBUG_STREAM_DUMP, "snd data", in, count);\r\nfcs = PPP_INITFCS;\r\nones = 0;\r\nwhile (count-- > 0) {\r\nc = *in++;\r\nones = hdlc_bitstuff_byte(iwb, c, ones);\r\nfcs = crc_ccitt_byte(fcs, c);\r\n}\r\nfcs ^= 0xffff;\r\nones = hdlc_bitstuff_byte(iwb, fcs & 0x00ff, ones);\r\nones = hdlc_bitstuff_byte(iwb, (fcs >> 8) & 0x00ff, ones);\r\nisowbuf_putflag(iwb);\r\nend = isowbuf_donewrite(iwb);\r\nreturn end;\r\n}\r\nstatic inline int trans_buildframe(struct isowbuf_t *iwb,\r\nunsigned char *in, int count)\r\n{\r\nint write;\r\nunsigned char c;\r\nif (unlikely(count <= 0))\r\nreturn iwb->write;\r\nif (isowbuf_freebytes(iwb) < count ||\r\n!isowbuf_startwrite(iwb)) {\r\ngig_dbg(DEBUG_ISO, "can't put %d bytes", count);\r\nreturn -EAGAIN;\r\n}\r\ngig_dbg(DEBUG_STREAM, "put %d bytes", count);\r\ndump_bytes(DEBUG_STREAM_DUMP, "snd data", in, count);\r\nwrite = iwb->write;\r\ndo {\r\nc = bitrev8(*in++);\r\niwb->data[write++] = c;\r\nwrite %= BAS_OUTBUFSIZE;\r\n} while (--count > 0);\r\niwb->write = write;\r\niwb->idle = c;\r\nreturn isowbuf_donewrite(iwb);\r\n}\r\nint gigaset_isoc_buildframe(struct bc_state *bcs, unsigned char *in, int len)\r\n{\r\nint result;\r\nswitch (bcs->proto2) {\r\ncase L2_HDLC:\r\nresult = hdlc_buildframe(bcs->hw.bas->isooutbuf, in, len);\r\ngig_dbg(DEBUG_ISO, "%s: %d bytes HDLC -> %d",\r\n__func__, len, result);\r\nbreak;\r\ndefault:\r\nresult = trans_buildframe(bcs->hw.bas->isooutbuf, in, len);\r\ngig_dbg(DEBUG_ISO, "%s: %d bytes trans -> %d",\r\n__func__, len, result);\r\n}\r\nreturn result;\r\n}\r\nstatic inline void hdlc_putbyte(unsigned char c, struct bc_state *bcs)\r\n{\r\nbcs->rx_fcs = crc_ccitt_byte(bcs->rx_fcs, c);\r\nif (bcs->rx_skb == NULL)\r\nreturn;\r\nif (bcs->rx_skb->len >= bcs->rx_bufsize) {\r\ndev_warn(bcs->cs->dev, "received oversized packet discarded\n");\r\nbcs->hw.bas->giants++;\r\ndev_kfree_skb_any(bcs->rx_skb);\r\nbcs->rx_skb = NULL;\r\nreturn;\r\n}\r\n*__skb_put(bcs->rx_skb, 1) = c;\r\n}\r\nstatic inline void hdlc_flush(struct bc_state *bcs)\r\n{\r\nif (bcs->rx_skb != NULL)\r\nskb_trim(bcs->rx_skb, 0);\r\nelse\r\ngigaset_new_rx_skb(bcs);\r\nbcs->rx_fcs = PPP_INITFCS;\r\n}\r\nstatic inline void hdlc_done(struct bc_state *bcs)\r\n{\r\nstruct cardstate *cs = bcs->cs;\r\nstruct sk_buff *procskb;\r\nunsigned int len;\r\nif (unlikely(bcs->ignore)) {\r\nbcs->ignore--;\r\nhdlc_flush(bcs);\r\nreturn;\r\n}\r\nprocskb = bcs->rx_skb;\r\nif (procskb == NULL) {\r\ngig_dbg(DEBUG_ISO, "%s: skb=NULL", __func__);\r\ngigaset_isdn_rcv_err(bcs);\r\n} else if (procskb->len < 2) {\r\ndev_notice(cs->dev, "received short frame (%d octets)\n",\r\nprocskb->len);\r\nbcs->hw.bas->runts++;\r\ndev_kfree_skb_any(procskb);\r\ngigaset_isdn_rcv_err(bcs);\r\n} else if (bcs->rx_fcs != PPP_GOODFCS) {\r\ndev_notice(cs->dev, "frame check error\n");\r\nbcs->hw.bas->fcserrs++;\r\ndev_kfree_skb_any(procskb);\r\ngigaset_isdn_rcv_err(bcs);\r\n} else {\r\nlen = procskb->len;\r\n__skb_trim(procskb, len -= 2);\r\ngig_dbg(DEBUG_ISO, "%s: good frame (%d octets)", __func__, len);\r\ndump_bytes(DEBUG_STREAM_DUMP,\r\n"rcv data", procskb->data, len);\r\nbcs->hw.bas->goodbytes += len;\r\ngigaset_skb_rcvd(bcs, procskb);\r\n}\r\ngigaset_new_rx_skb(bcs);\r\nbcs->rx_fcs = PPP_INITFCS;\r\n}\r\nstatic inline void hdlc_frag(struct bc_state *bcs, unsigned inbits)\r\n{\r\nif (unlikely(bcs->ignore)) {\r\nbcs->ignore--;\r\nhdlc_flush(bcs);\r\nreturn;\r\n}\r\ndev_notice(bcs->cs->dev, "received partial byte (%d bits)\n", inbits);\r\nbcs->hw.bas->alignerrs++;\r\ngigaset_isdn_rcv_err(bcs);\r\n__skb_trim(bcs->rx_skb, 0);\r\nbcs->rx_fcs = PPP_INITFCS;\r\n}\r\nstatic inline void hdlc_unpack(unsigned char *src, unsigned count,\r\nstruct bc_state *bcs)\r\n{\r\nstruct bas_bc_state *ubc = bcs->hw.bas;\r\nint inputstate;\r\nunsigned seqlen, inbyte, inbits;\r\ninputstate = bcs->inputstate;\r\nseqlen = ubc->seqlen;\r\ninbyte = ubc->inbyte;\r\ninbits = ubc->inbits;\r\nwhile (count--) {\r\nunsigned char c = *src++;\r\nunsigned char tabentry = bitcounts[c];\r\nunsigned lead1 = tabentry & 0x0f;\r\nunsigned trail1 = (tabentry >> 4) & 0x0f;\r\nseqlen += lead1;\r\nif (unlikely(inputstate & INS_flag_hunt)) {\r\nif (c == PPP_FLAG) {\r\ninputstate &= ~(INS_flag_hunt | INS_have_data);\r\ninbyte = 0;\r\ninbits = 0;\r\n} else if (seqlen == 6 && trail1 != 7) {\r\ninputstate &= ~(INS_flag_hunt | INS_have_data);\r\ninbyte = c >> (lead1 + 1);\r\ninbits = 7 - lead1;\r\nif (trail1 >= 8) {\r\ninbits--;\r\nswitch (c) {\r\ncase 0xbe:\r\ninbyte = 0x3f;\r\nbreak;\r\n}\r\n}\r\n}\r\n} else if (likely(seqlen < 5 && trail1 < 7)) {\r\ninbyte |= c << inbits;\r\nhdlc_putbyte(inbyte & 0xff, bcs);\r\ninputstate |= INS_have_data;\r\ninbyte >>= 8;\r\n} else if (likely(seqlen == 6 && inbits == 7 - lead1 &&\r\ntrail1 + 1 == inbits &&\r\n!(inputstate & INS_have_data))) {\r\n} else if (unlikely(seqlen > 6)) {\r\nubc->aborts++;\r\nhdlc_flush(bcs);\r\ninputstate |= INS_flag_hunt;\r\n} else if (seqlen == 6) {\r\nif (inbits > 7 - lead1) {\r\nhdlc_frag(bcs, inbits + lead1 - 7);\r\ninputstate &= ~INS_have_data;\r\n} else {\r\nif (inbits < 7 - lead1)\r\nubc->stolen0s++;\r\nif (inputstate & INS_have_data) {\r\nhdlc_done(bcs);\r\ninputstate &= ~INS_have_data;\r\n}\r\n}\r\nif (c == PPP_FLAG) {\r\nubc->shared0s++;\r\ninbits = 0;\r\ninbyte = 0;\r\n} else if (trail1 != 7) {\r\ninbyte = c >> (lead1 + 1);\r\ninbits = 7 - lead1;\r\nif (trail1 >= 8) {\r\ninbits--;\r\nswitch (c) {\r\ncase 0xbe:\r\ninbyte = 0x3f;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nubc->aborts++;\r\ninputstate |= INS_flag_hunt;\r\n}\r\n} else {\r\nif (c == PPP_FLAG) {\r\nif (seqlen == 5)\r\nubc->stolen0s++;\r\nif (inbits) {\r\nhdlc_frag(bcs, inbits);\r\ninbits = 0;\r\ninbyte = 0;\r\n} else if (inputstate & INS_have_data)\r\nhdlc_done(bcs);\r\ninputstate &= ~INS_have_data;\r\n} else if (trail1 == 7) {\r\nubc->aborts++;\r\nhdlc_flush(bcs);\r\ninputstate |= INS_flag_hunt;\r\n} else {\r\nif (trail1 < 7) {\r\nunsigned char mask = (1 << lead1) - 1;\r\nc = (c & mask) | ((c & ~mask) >> 1);\r\ninbyte |= c << inbits;\r\ninbits += 7;\r\n} else if (seqlen < 5) {\r\nswitch (c) {\r\ncase 0xbe:\r\nc = 0x7e;\r\nbreak;\r\n}\r\ninbyte |= c << inbits;\r\ninbits += 7;\r\n} else {\r\nswitch (c) {\r\ncase 0x7d:\r\nc = 0x3f;\r\nbreak;\r\ncase 0xbe:\r\nc = 0x3f;\r\nbreak;\r\ncase 0x3e:\r\nc = 0x1f;\r\nbreak;\r\ncase 0x7c:\r\nc = 0x3e;\r\nbreak;\r\n}\r\ninbyte |= c << inbits;\r\ninbits += 6;\r\n}\r\nif (inbits >= 8) {\r\ninbits -= 8;\r\nhdlc_putbyte(inbyte & 0xff, bcs);\r\ninputstate |= INS_have_data;\r\ninbyte >>= 8;\r\n}\r\n}\r\n}\r\nseqlen = trail1 & 7;\r\n}\r\nbcs->inputstate = inputstate;\r\nubc->seqlen = seqlen;\r\nubc->inbyte = inbyte;\r\nubc->inbits = inbits;\r\n}\r\nstatic inline void trans_receive(unsigned char *src, unsigned count,\r\nstruct bc_state *bcs)\r\n{\r\nstruct sk_buff *skb;\r\nint dobytes;\r\nunsigned char *dst;\r\nif (unlikely(bcs->ignore)) {\r\nbcs->ignore--;\r\nreturn;\r\n}\r\nskb = bcs->rx_skb;\r\nif (skb == NULL) {\r\nskb = gigaset_new_rx_skb(bcs);\r\nif (skb == NULL)\r\nreturn;\r\n}\r\ndobytes = bcs->rx_bufsize - skb->len;\r\nwhile (count > 0) {\r\ndst = skb_put(skb, count < dobytes ? count : dobytes);\r\nwhile (count > 0 && dobytes > 0) {\r\n*dst++ = bitrev8(*src++);\r\ncount--;\r\ndobytes--;\r\n}\r\nif (dobytes == 0) {\r\ndump_bytes(DEBUG_STREAM_DUMP,\r\n"rcv data", skb->data, skb->len);\r\nbcs->hw.bas->goodbytes += skb->len;\r\ngigaset_skb_rcvd(bcs, skb);\r\nskb = gigaset_new_rx_skb(bcs);\r\nif (skb == NULL)\r\nreturn;\r\ndobytes = bcs->rx_bufsize;\r\n}\r\n}\r\n}\r\nvoid gigaset_isoc_receive(unsigned char *src, unsigned count,\r\nstruct bc_state *bcs)\r\n{\r\nswitch (bcs->proto2) {\r\ncase L2_HDLC:\r\nhdlc_unpack(src, count, bcs);\r\nbreak;\r\ndefault:\r\ntrans_receive(src, count, bcs);\r\n}\r\n}\r\nstatic void cmd_loop(unsigned char *src, int numbytes, struct inbuf_t *inbuf)\r\n{\r\nstruct cardstate *cs = inbuf->cs;\r\nunsigned cbytes = cs->cbytes;\r\nunsigned char c;\r\nwhile (numbytes--) {\r\nc = *src++;\r\nswitch (c) {\r\ncase '\n':\r\nif (cbytes == 0 && cs->respdata[0] == '\r') {\r\ncs->respdata[0] = 0;\r\nbreak;\r\n}\r\ncase '\r':\r\nif (cbytes >= MAX_RESP_SIZE) {\r\ndev_warn(cs->dev, "response too large (%d)\n",\r\ncbytes);\r\ncbytes = MAX_RESP_SIZE;\r\n}\r\ncs->cbytes = cbytes;\r\ngigaset_dbg_buffer(DEBUG_TRANSCMD, "received response",\r\ncbytes, cs->respdata);\r\ngigaset_handle_modem_response(cs);\r\ncbytes = 0;\r\ncs->respdata[0] = c;\r\nbreak;\r\ndefault:\r\nif (cbytes < MAX_RESP_SIZE)\r\ncs->respdata[cbytes] = c;\r\ncbytes++;\r\n}\r\n}\r\ncs->cbytes = cbytes;\r\n}\r\nvoid gigaset_isoc_input(struct inbuf_t *inbuf)\r\n{\r\nstruct cardstate *cs = inbuf->cs;\r\nunsigned tail, head, numbytes;\r\nunsigned char *src;\r\nhead = inbuf->head;\r\nwhile (head != (tail = inbuf->tail)) {\r\ngig_dbg(DEBUG_INTR, "buffer state: %u -> %u", head, tail);\r\nif (head > tail)\r\ntail = RBUFSIZE;\r\nsrc = inbuf->data + head;\r\nnumbytes = tail - head;\r\ngig_dbg(DEBUG_INTR, "processing %u bytes", numbytes);\r\nif (cs->mstate == MS_LOCKED) {\r\ngigaset_dbg_buffer(DEBUG_LOCKCMD, "received response",\r\nnumbytes, src);\r\ngigaset_if_receive(inbuf->cs, src, numbytes);\r\n} else {\r\ncmd_loop(src, numbytes, inbuf);\r\n}\r\nhead += numbytes;\r\nif (head == RBUFSIZE)\r\nhead = 0;\r\ngig_dbg(DEBUG_INTR, "setting head to %u", head);\r\ninbuf->head = head;\r\n}\r\n}\r\nint gigaset_isoc_send_skb(struct bc_state *bcs, struct sk_buff *skb)\r\n{\r\nint len = skb->len;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (!bcs->cs->connected) {\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nreturn -ENODEV;\r\n}\r\nskb_queue_tail(&bcs->squeue, skb);\r\ngig_dbg(DEBUG_ISO, "%s: skb queued, qlen=%d",\r\n__func__, skb_queue_len(&bcs->squeue));\r\ntasklet_schedule(&bcs->hw.bas->sent_tasklet);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nreturn len;\r\n}
