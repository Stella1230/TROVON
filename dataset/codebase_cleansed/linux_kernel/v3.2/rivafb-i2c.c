static void riva_gpio_setscl(void* data, int state)\r\n{\r\nstruct riva_i2c_chan *chan = data;\r\nstruct riva_par *par = chan->par;\r\nu32 val;\r\nVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\r\nval = VGA_RD08(par->riva.PCIO, 0x3d5) & 0xf0;\r\nif (state)\r\nval |= 0x20;\r\nelse\r\nval &= ~0x20;\r\nVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\r\nVGA_WR08(par->riva.PCIO, 0x3d5, val | 0x1);\r\n}\r\nstatic void riva_gpio_setsda(void* data, int state)\r\n{\r\nstruct riva_i2c_chan *chan = data;\r\nstruct riva_par *par = chan->par;\r\nu32 val;\r\nVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\r\nval = VGA_RD08(par->riva.PCIO, 0x3d5) & 0xf0;\r\nif (state)\r\nval |= 0x10;\r\nelse\r\nval &= ~0x10;\r\nVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base + 1);\r\nVGA_WR08(par->riva.PCIO, 0x3d5, val | 0x1);\r\n}\r\nstatic int riva_gpio_getscl(void* data)\r\n{\r\nstruct riva_i2c_chan *chan = data;\r\nstruct riva_par *par = chan->par;\r\nu32 val = 0;\r\nVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base);\r\nif (VGA_RD08(par->riva.PCIO, 0x3d5) & 0x04)\r\nval = 1;\r\nreturn val;\r\n}\r\nstatic int riva_gpio_getsda(void* data)\r\n{\r\nstruct riva_i2c_chan *chan = data;\r\nstruct riva_par *par = chan->par;\r\nu32 val = 0;\r\nVGA_WR08(par->riva.PCIO, 0x3d4, chan->ddc_base);\r\nif (VGA_RD08(par->riva.PCIO, 0x3d5) & 0x08)\r\nval = 1;\r\nreturn val;\r\n}\r\nstatic int __devinit riva_setup_i2c_bus(struct riva_i2c_chan *chan,\r\nconst char *name,\r\nunsigned int i2c_class)\r\n{\r\nint rc;\r\nstrcpy(chan->adapter.name, name);\r\nchan->adapter.owner = THIS_MODULE;\r\nchan->adapter.class = i2c_class;\r\nchan->adapter.algo_data = &chan->algo;\r\nchan->adapter.dev.parent = &chan->par->pdev->dev;\r\nchan->algo.setsda = riva_gpio_setsda;\r\nchan->algo.setscl = riva_gpio_setscl;\r\nchan->algo.getsda = riva_gpio_getsda;\r\nchan->algo.getscl = riva_gpio_getscl;\r\nchan->algo.udelay = 40;\r\nchan->algo.timeout = msecs_to_jiffies(2);\r\nchan->algo.data = chan;\r\ni2c_set_adapdata(&chan->adapter, chan);\r\nriva_gpio_setsda(chan, 1);\r\nriva_gpio_setscl(chan, 1);\r\nudelay(20);\r\nrc = i2c_bit_add_bus(&chan->adapter);\r\nif (rc == 0)\r\ndev_dbg(&chan->par->pdev->dev, "I2C bus %s registered.\n", name);\r\nelse {\r\ndev_warn(&chan->par->pdev->dev,\r\n"Failed to register I2C bus %s.\n", name);\r\nchan->par = NULL;\r\n}\r\nreturn rc;\r\n}\r\nvoid __devinit riva_create_i2c_busses(struct riva_par *par)\r\n{\r\npar->chan[0].par = par;\r\npar->chan[1].par = par;\r\npar->chan[2].par = par;\r\npar->chan[0].ddc_base = 0x36;\r\npar->chan[1].ddc_base = 0x3e;\r\npar->chan[2].ddc_base = 0x50;\r\nriva_setup_i2c_bus(&par->chan[0], "BUS1", I2C_CLASS_HWMON);\r\nriva_setup_i2c_bus(&par->chan[1], "BUS2", 0);\r\nriva_setup_i2c_bus(&par->chan[2], "BUS3", 0);\r\n}\r\nvoid riva_delete_i2c_busses(struct riva_par *par)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (!par->chan[i].par)\r\ncontinue;\r\ni2c_del_adapter(&par->chan[i].adapter);\r\npar->chan[i].par = NULL;\r\n}\r\n}\r\nint __devinit riva_probe_i2c_connector(struct riva_par *par, int conn, u8 **out_edid)\r\n{\r\nu8 *edid = NULL;\r\nif (par->chan[conn].par)\r\nedid = fb_ddc_read(&par->chan[conn].adapter);\r\nif (out_edid)\r\n*out_edid = edid;\r\nif (!edid)\r\nreturn 1;\r\nreturn 0;\r\n}
