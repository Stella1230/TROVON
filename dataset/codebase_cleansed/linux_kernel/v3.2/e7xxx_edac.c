static inline int e7xxx_find_channel(u16 syndrome)\r\n{\r\ndebugf3("%s()\n", __func__);\r\nif ((syndrome & 0xff00) == 0)\r\nreturn 0;\r\nif ((syndrome & 0x00ff) == 0)\r\nreturn 1;\r\nif ((syndrome & 0xf000) == 0 || (syndrome & 0x0f00) == 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic unsigned long ctl_page_to_phys(struct mem_ctl_info *mci,\r\nunsigned long page)\r\n{\r\nu32 remap;\r\nstruct e7xxx_pvt *pvt = (struct e7xxx_pvt *)mci->pvt_info;\r\ndebugf3("%s()\n", __func__);\r\nif ((page < pvt->tolm) ||\r\n((page >= 0x100000) && (page < pvt->remapbase)))\r\nreturn page;\r\nremap = (page - pvt->tolm) + pvt->remapbase;\r\nif (remap < pvt->remaplimit)\r\nreturn remap;\r\ne7xxx_printk(KERN_ERR, "Invalid page %lx - out of range\n", page);\r\nreturn pvt->tolm - 1;\r\n}\r\nstatic void process_ce(struct mem_ctl_info *mci, struct e7xxx_error_info *info)\r\n{\r\nu32 error_1b, page;\r\nu16 syndrome;\r\nint row;\r\nint channel;\r\ndebugf3("%s()\n", __func__);\r\nerror_1b = info->dram_celog_add;\r\npage = error_1b >> 6;\r\nsyndrome = info->dram_celog_syndrome;\r\nrow = edac_mc_find_csrow_by_page(mci, page);\r\nchannel = e7xxx_find_channel(syndrome);\r\nedac_mc_handle_ce(mci, page, 0, syndrome, row, channel, "e7xxx CE");\r\n}\r\nstatic void process_ce_no_info(struct mem_ctl_info *mci)\r\n{\r\ndebugf3("%s()\n", __func__);\r\nedac_mc_handle_ce_no_info(mci, "e7xxx CE log register overflow");\r\n}\r\nstatic void process_ue(struct mem_ctl_info *mci, struct e7xxx_error_info *info)\r\n{\r\nu32 error_2b, block_page;\r\nint row;\r\ndebugf3("%s()\n", __func__);\r\nerror_2b = info->dram_uelog_add;\r\nblock_page = error_2b >> 6;\r\nrow = edac_mc_find_csrow_by_page(mci, block_page);\r\nedac_mc_handle_ue(mci, block_page, 0, row, "e7xxx UE");\r\n}\r\nstatic void process_ue_no_info(struct mem_ctl_info *mci)\r\n{\r\ndebugf3("%s()\n", __func__);\r\nedac_mc_handle_ue_no_info(mci, "e7xxx UE log register overflow");\r\n}\r\nstatic void e7xxx_get_error_info(struct mem_ctl_info *mci,\r\nstruct e7xxx_error_info *info)\r\n{\r\nstruct e7xxx_pvt *pvt;\r\npvt = (struct e7xxx_pvt *)mci->pvt_info;\r\npci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_FERR, &info->dram_ferr);\r\npci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_NERR, &info->dram_nerr);\r\nif ((info->dram_ferr & 1) || (info->dram_nerr & 1)) {\r\npci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_CELOG_ADD,\r\n&info->dram_celog_add);\r\npci_read_config_word(pvt->bridge_ck,\r\nE7XXX_DRAM_CELOG_SYNDROME,\r\n&info->dram_celog_syndrome);\r\n}\r\nif ((info->dram_ferr & 2) || (info->dram_nerr & 2))\r\npci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_UELOG_ADD,\r\n&info->dram_uelog_add);\r\nif (info->dram_ferr & 3)\r\npci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_FERR, 0x03, 0x03);\r\nif (info->dram_nerr & 3)\r\npci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_NERR, 0x03, 0x03);\r\n}\r\nstatic int e7xxx_process_error_info(struct mem_ctl_info *mci,\r\nstruct e7xxx_error_info *info,\r\nint handle_errors)\r\n{\r\nint error_found;\r\nerror_found = 0;\r\nif (info->dram_ferr & 1) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nprocess_ce(mci, info);\r\n}\r\nif (info->dram_ferr & 2) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nprocess_ue(mci, info);\r\n}\r\nif (info->dram_nerr & 1) {\r\nerror_found = 1;\r\nif (handle_errors) {\r\nif (info->dram_ferr & 1)\r\nprocess_ce_no_info(mci);\r\nelse\r\nprocess_ce(mci, info);\r\n}\r\n}\r\nif (info->dram_nerr & 2) {\r\nerror_found = 1;\r\nif (handle_errors) {\r\nif (info->dram_ferr & 2)\r\nprocess_ue_no_info(mci);\r\nelse\r\nprocess_ue(mci, info);\r\n}\r\n}\r\nreturn error_found;\r\n}\r\nstatic void e7xxx_check(struct mem_ctl_info *mci)\r\n{\r\nstruct e7xxx_error_info info;\r\ndebugf3("%s()\n", __func__);\r\ne7xxx_get_error_info(mci, &info);\r\ne7xxx_process_error_info(mci, &info, 1);\r\n}\r\nstatic inline int dual_channel_active(u32 drc, int dev_idx)\r\n{\r\nreturn (dev_idx == E7501) ? ((drc >> 22) & 0x1) : 1;\r\n}\r\nstatic inline int drb_granularity(u32 drc, int dev_idx)\r\n{\r\nreturn (dev_idx == E7501) ? ((drc >> 18) & 0x3) : 1;\r\n}\r\nstatic void e7xxx_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\r\nint dev_idx, u32 drc)\r\n{\r\nunsigned long last_cumul_size;\r\nint index;\r\nu8 value;\r\nu32 dra, cumul_size;\r\nint drc_chan, drc_drbg, drc_ddim, mem_dev;\r\nstruct csrow_info *csrow;\r\npci_read_config_dword(pdev, E7XXX_DRA, &dra);\r\ndrc_chan = dual_channel_active(drc, dev_idx);\r\ndrc_drbg = drb_granularity(drc, dev_idx);\r\ndrc_ddim = (drc >> 20) & 0x3;\r\nlast_cumul_size = 0;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\nmem_dev = (dra >> (index * 4 + 3)) & 0x1;\r\ncsrow = &mci->csrows[index];\r\npci_read_config_byte(pdev, E7XXX_DRB + index, &value);\r\ncumul_size = value << (25 + drc_drbg - PAGE_SHIFT);\r\ndebugf3("%s(): (%d) cumul_size 0x%x\n", __func__, index,\r\ncumul_size);\r\nif (cumul_size == last_cumul_size)\r\ncontinue;\r\ncsrow->first_page = last_cumul_size;\r\ncsrow->last_page = cumul_size - 1;\r\ncsrow->nr_pages = cumul_size - last_cumul_size;\r\nlast_cumul_size = cumul_size;\r\ncsrow->grain = 1 << 12;\r\ncsrow->mtype = MEM_RDDR;\r\ncsrow->dtype = mem_dev ? DEV_X4 : DEV_X8;\r\nif (drc_ddim) {\r\nif (drc_chan && mem_dev) {\r\ncsrow->edac_mode = EDAC_S4ECD4ED;\r\nmci->edac_cap |= EDAC_FLAG_S4ECD4ED;\r\n} else {\r\ncsrow->edac_mode = EDAC_SECDED;\r\nmci->edac_cap |= EDAC_FLAG_SECDED;\r\n}\r\n} else\r\ncsrow->edac_mode = EDAC_NONE;\r\n}\r\n}\r\nstatic int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nu16 pci_data;\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct e7xxx_pvt *pvt = NULL;\r\nu32 drc;\r\nint drc_chan;\r\nstruct e7xxx_error_info discard;\r\ndebugf0("%s(): mci\n", __func__);\r\npci_read_config_dword(pdev, E7XXX_DRC, &drc);\r\ndrc_chan = dual_channel_active(drc, dev_idx);\r\nmci = edac_mc_alloc(sizeof(*pvt), E7XXX_NR_CSROWS, drc_chan + 1, 0);\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\ndebugf3("%s(): init mci\n", __func__);\r\nmci->mtype_cap = MEM_FLAG_RDDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED |\r\nEDAC_FLAG_S4ECD4ED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = E7XXX_REVISION;\r\nmci->dev = &pdev->dev;\r\ndebugf3("%s(): init pvt\n", __func__);\r\npvt = (struct e7xxx_pvt *)mci->pvt_info;\r\npvt->dev_info = &e7xxx_devs[dev_idx];\r\npvt->bridge_ck = pci_get_device(PCI_VENDOR_ID_INTEL,\r\npvt->dev_info->err_dev, pvt->bridge_ck);\r\nif (!pvt->bridge_ck) {\r\ne7xxx_printk(KERN_ERR, "error reporting device not found:"\r\n"vendor %x device 0x%x (broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL, e7xxx_devs[dev_idx].err_dev);\r\ngoto fail0;\r\n}\r\ndebugf3("%s(): more mci init\n", __func__);\r\nmci->ctl_name = pvt->dev_info->ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = e7xxx_check;\r\nmci->ctl_page_to_phys = ctl_page_to_phys;\r\ne7xxx_init_csrows(mci, pdev, dev_idx, drc);\r\nmci->edac_cap |= EDAC_FLAG_NONE;\r\ndebugf3("%s(): tolm, remapbase, remaplimit\n", __func__);\r\npci_read_config_word(pdev, E7XXX_TOLM, &pci_data);\r\npvt->tolm = ((u32) pci_data) << 4;\r\npci_read_config_word(pdev, E7XXX_REMAPBASE, &pci_data);\r\npvt->remapbase = ((u32) pci_data) << 14;\r\npci_read_config_word(pdev, E7XXX_REMAPLIMIT, &pci_data);\r\npvt->remaplimit = ((u32) pci_data) << 14;\r\ne7xxx_printk(KERN_INFO,\r\n"tolm = %x, remapbase = %x, remaplimit = %x\n", pvt->tolm,\r\npvt->remapbase, pvt->remaplimit);\r\ne7xxx_get_error_info(mci, &discard);\r\nif (edac_mc_add_mc(mci)) {\r\ndebugf3("%s(): failed edac_mc_add_mc()\n", __func__);\r\ngoto fail1;\r\n}\r\ne7xxx_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!e7xxx_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\ndebugf3("%s(): success\n", __func__);\r\nreturn 0;\r\nfail1:\r\npci_dev_put(pvt->bridge_ck);\r\nfail0:\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit e7xxx_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\ndebugf0("%s()\n", __func__);\r\nreturn pci_enable_device(pdev) ?\r\n-EIO : e7xxx_probe1(pdev, ent->driver_data);\r\n}\r\nstatic void __devexit e7xxx_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct e7xxx_pvt *pvt;\r\ndebugf0("%s()\n", __func__);\r\nif (e7xxx_pci)\r\nedac_pci_release_generic_ctl(e7xxx_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\npvt = (struct e7xxx_pvt *)mci->pvt_info;\r\npci_dev_put(pvt->bridge_ck);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init e7xxx_init(void)\r\n{\r\nopstate_init();\r\nreturn pci_register_driver(&e7xxx_driver);\r\n}\r\nstatic void __exit e7xxx_exit(void)\r\n{\r\npci_unregister_driver(&e7xxx_driver);\r\n}
