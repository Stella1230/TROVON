asmlinkage int\r\nsys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)\r\n{\r\nreturn do_sigaltstack(uss, uoss, rdusp());\r\n}\r\nstatic long\r\nrestore_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\r\nstruct switch_stack *sw)\r\n{\r\nunsigned long usp;\r\nlong i, err = __get_user(regs->pc, &sc->sc_pc);\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nsw->r26 = (unsigned long) ret_from_sys_call;\r\nerr |= __get_user(regs->r0, sc->sc_regs+0);\r\nerr |= __get_user(regs->r1, sc->sc_regs+1);\r\nerr |= __get_user(regs->r2, sc->sc_regs+2);\r\nerr |= __get_user(regs->r3, sc->sc_regs+3);\r\nerr |= __get_user(regs->r4, sc->sc_regs+4);\r\nerr |= __get_user(regs->r5, sc->sc_regs+5);\r\nerr |= __get_user(regs->r6, sc->sc_regs+6);\r\nerr |= __get_user(regs->r7, sc->sc_regs+7);\r\nerr |= __get_user(regs->r8, sc->sc_regs+8);\r\nerr |= __get_user(sw->r9, sc->sc_regs+9);\r\nerr |= __get_user(sw->r10, sc->sc_regs+10);\r\nerr |= __get_user(sw->r11, sc->sc_regs+11);\r\nerr |= __get_user(sw->r12, sc->sc_regs+12);\r\nerr |= __get_user(sw->r13, sc->sc_regs+13);\r\nerr |= __get_user(sw->r14, sc->sc_regs+14);\r\nerr |= __get_user(sw->r15, sc->sc_regs+15);\r\nerr |= __get_user(regs->r16, sc->sc_regs+16);\r\nerr |= __get_user(regs->r17, sc->sc_regs+17);\r\nerr |= __get_user(regs->r18, sc->sc_regs+18);\r\nerr |= __get_user(regs->r19, sc->sc_regs+19);\r\nerr |= __get_user(regs->r20, sc->sc_regs+20);\r\nerr |= __get_user(regs->r21, sc->sc_regs+21);\r\nerr |= __get_user(regs->r22, sc->sc_regs+22);\r\nerr |= __get_user(regs->r23, sc->sc_regs+23);\r\nerr |= __get_user(regs->r24, sc->sc_regs+24);\r\nerr |= __get_user(regs->r25, sc->sc_regs+25);\r\nerr |= __get_user(regs->r26, sc->sc_regs+26);\r\nerr |= __get_user(regs->r27, sc->sc_regs+27);\r\nerr |= __get_user(regs->r28, sc->sc_regs+28);\r\nerr |= __get_user(regs->gp, sc->sc_regs+29);\r\nerr |= __get_user(usp, sc->sc_regs+30);\r\nwrusp(usp);\r\nfor (i = 0; i < 31; i++)\r\nerr |= __get_user(sw->fp[i], sc->sc_fpregs+i);\r\nerr |= __get_user(sw->fp[31], &sc->sc_fpcr);\r\nreturn err;\r\n}\r\nasmlinkage void\r\ndo_sigreturn(struct sigcontext __user *sc, struct pt_regs *regs,\r\nstruct switch_stack *sw)\r\n{\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, sc, sizeof(*sc)))\r\ngoto give_sigsegv;\r\nif (__get_user(set.sig[0], &sc->sc_mask))\r\ngoto give_sigsegv;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->blocked = set;\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (restore_sigcontext(sc, regs, sw))\r\ngoto give_sigsegv;\r\nif (ptrace_cancel_bpt (current)) {\r\nsiginfo_t info;\r\ninfo.si_signo = SIGTRAP;\r\ninfo.si_errno = 0;\r\ninfo.si_code = TRAP_BRKPT;\r\ninfo.si_addr = (void __user *) regs->pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGTRAP, &info, current);\r\n}\r\nreturn;\r\ngive_sigsegv:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nasmlinkage void\r\ndo_rt_sigreturn(struct rt_sigframe __user *frame, struct pt_regs *regs,\r\nstruct switch_stack *sw)\r\n{\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, &frame->uc, sizeof(frame->uc)))\r\ngoto give_sigsegv;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto give_sigsegv;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->blocked = set;\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (restore_sigcontext(&frame->uc.uc_mcontext, regs, sw))\r\ngoto give_sigsegv;\r\nif (ptrace_cancel_bpt (current)) {\r\nsiginfo_t info;\r\ninfo.si_signo = SIGTRAP;\r\ninfo.si_errno = 0;\r\ninfo.si_code = TRAP_BRKPT;\r\ninfo.si_addr = (void __user *) regs->pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGTRAP, &info, current);\r\n}\r\nreturn;\r\ngive_sigsegv:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct k_sigaction *ka, unsigned long sp, size_t frame_size)\r\n{\r\nif ((ka->sa.sa_flags & SA_ONSTACK) != 0 && ! sas_ss_flags(sp))\r\nsp = current->sas_ss_sp + current->sas_ss_size;\r\nreturn (void __user *)((sp - frame_size) & -32ul);\r\n}\r\nstatic long\r\nsetup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\r\nstruct switch_stack *sw, unsigned long mask, unsigned long sp)\r\n{\r\nlong i, err = 0;\r\nerr |= __put_user(on_sig_stack((unsigned long)sc), &sc->sc_onstack);\r\nerr |= __put_user(mask, &sc->sc_mask);\r\nerr |= __put_user(regs->pc, &sc->sc_pc);\r\nerr |= __put_user(8, &sc->sc_ps);\r\nerr |= __put_user(regs->r0 , sc->sc_regs+0);\r\nerr |= __put_user(regs->r1 , sc->sc_regs+1);\r\nerr |= __put_user(regs->r2 , sc->sc_regs+2);\r\nerr |= __put_user(regs->r3 , sc->sc_regs+3);\r\nerr |= __put_user(regs->r4 , sc->sc_regs+4);\r\nerr |= __put_user(regs->r5 , sc->sc_regs+5);\r\nerr |= __put_user(regs->r6 , sc->sc_regs+6);\r\nerr |= __put_user(regs->r7 , sc->sc_regs+7);\r\nerr |= __put_user(regs->r8 , sc->sc_regs+8);\r\nerr |= __put_user(sw->r9 , sc->sc_regs+9);\r\nerr |= __put_user(sw->r10 , sc->sc_regs+10);\r\nerr |= __put_user(sw->r11 , sc->sc_regs+11);\r\nerr |= __put_user(sw->r12 , sc->sc_regs+12);\r\nerr |= __put_user(sw->r13 , sc->sc_regs+13);\r\nerr |= __put_user(sw->r14 , sc->sc_regs+14);\r\nerr |= __put_user(sw->r15 , sc->sc_regs+15);\r\nerr |= __put_user(regs->r16, sc->sc_regs+16);\r\nerr |= __put_user(regs->r17, sc->sc_regs+17);\r\nerr |= __put_user(regs->r18, sc->sc_regs+18);\r\nerr |= __put_user(regs->r19, sc->sc_regs+19);\r\nerr |= __put_user(regs->r20, sc->sc_regs+20);\r\nerr |= __put_user(regs->r21, sc->sc_regs+21);\r\nerr |= __put_user(regs->r22, sc->sc_regs+22);\r\nerr |= __put_user(regs->r23, sc->sc_regs+23);\r\nerr |= __put_user(regs->r24, sc->sc_regs+24);\r\nerr |= __put_user(regs->r25, sc->sc_regs+25);\r\nerr |= __put_user(regs->r26, sc->sc_regs+26);\r\nerr |= __put_user(regs->r27, sc->sc_regs+27);\r\nerr |= __put_user(regs->r28, sc->sc_regs+28);\r\nerr |= __put_user(regs->gp , sc->sc_regs+29);\r\nerr |= __put_user(sp, sc->sc_regs+30);\r\nerr |= __put_user(0, sc->sc_regs+31);\r\nfor (i = 0; i < 31; i++)\r\nerr |= __put_user(sw->fp[i], sc->sc_fpregs+i);\r\nerr |= __put_user(0, sc->sc_fpregs+31);\r\nerr |= __put_user(sw->fp[31], &sc->sc_fpcr);\r\nerr |= __put_user(regs->trap_a0, &sc->sc_traparg_a0);\r\nerr |= __put_user(regs->trap_a1, &sc->sc_traparg_a1);\r\nerr |= __put_user(regs->trap_a2, &sc->sc_traparg_a2);\r\nreturn err;\r\n}\r\nstatic int\r\nsetup_frame(int sig, struct k_sigaction *ka, sigset_t *set,\r\nstruct pt_regs *regs, struct switch_stack * sw)\r\n{\r\nunsigned long oldsp, r26, err = 0;\r\nstruct sigframe __user *frame;\r\noldsp = rdusp();\r\nframe = get_sigframe(ka, oldsp, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\ngoto give_sigsegv;\r\nerr |= setup_sigcontext(&frame->sc, regs, sw, set->sig[0], oldsp);\r\nif (err)\r\ngoto give_sigsegv;\r\nif (ka->ka_restorer) {\r\nr26 = (unsigned long) ka->ka_restorer;\r\n} else {\r\nerr |= __put_user(INSN_MOV_R30_R16, frame->retcode+0);\r\nerr |= __put_user(INSN_LDI_R0+__NR_sigreturn, frame->retcode+1);\r\nerr |= __put_user(INSN_CALLSYS, frame->retcode+2);\r\nimb();\r\nr26 = (unsigned long) frame->retcode;\r\n}\r\nif (err)\r\ngoto give_sigsegv;\r\nregs->r26 = r26;\r\nregs->r27 = regs->pc = (unsigned long) ka->sa.sa_handler;\r\nregs->r16 = sig;\r\nregs->r17 = 0;\r\nregs->r18 = (unsigned long) &frame->sc;\r\nwrusp((unsigned long) frame);\r\n#if DEBUG_SIG\r\nprintk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",\r\ncurrent->comm, current->pid, frame, regs->pc, regs->r26);\r\n#endif\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\nsetup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *set, struct pt_regs *regs, struct switch_stack * sw)\r\n{\r\nunsigned long oldsp, r26, err = 0;\r\nstruct rt_sigframe __user *frame;\r\noldsp = rdusp();\r\nframe = get_sigframe(ka, oldsp, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\ngoto give_sigsegv;\r\nerr |= copy_siginfo_to_user(&frame->info, info);\r\nerr |= __put_user(0, &frame->uc.uc_flags);\r\nerr |= __put_user(0, &frame->uc.uc_link);\r\nerr |= __put_user(set->sig[0], &frame->uc.uc_osf_sigmask);\r\nerr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\r\nerr |= __put_user(sas_ss_flags(oldsp), &frame->uc.uc_stack.ss_flags);\r\nerr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\r\nerr |= setup_sigcontext(&frame->uc.uc_mcontext, regs, sw,\r\nset->sig[0], oldsp);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (err)\r\ngoto give_sigsegv;\r\nif (ka->ka_restorer) {\r\nr26 = (unsigned long) ka->ka_restorer;\r\n} else {\r\nerr |= __put_user(INSN_MOV_R30_R16, frame->retcode+0);\r\nerr |= __put_user(INSN_LDI_R0+__NR_rt_sigreturn,\r\nframe->retcode+1);\r\nerr |= __put_user(INSN_CALLSYS, frame->retcode+2);\r\nimb();\r\nr26 = (unsigned long) frame->retcode;\r\n}\r\nif (err)\r\ngoto give_sigsegv;\r\nregs->r26 = r26;\r\nregs->r27 = regs->pc = (unsigned long) ka->sa.sa_handler;\r\nregs->r16 = sig;\r\nregs->r17 = (unsigned long) &frame->info;\r\nregs->r18 = (unsigned long) &frame->uc;\r\nwrusp((unsigned long) frame);\r\n#if DEBUG_SIG\r\nprintk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",\r\ncurrent->comm, current->pid, frame, regs->pc, regs->r26);\r\n#endif\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn -EFAULT;\r\n}\r\nstatic inline int\r\nhandle_signal(int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *oldset, struct pt_regs * regs, struct switch_stack *sw)\r\n{\r\nint ret;\r\nif (ka->sa.sa_flags & SA_SIGINFO)\r\nret = setup_rt_frame(sig, ka, info, oldset, regs, sw);\r\nelse\r\nret = setup_frame(sig, ka, oldset, regs, sw);\r\nif (ret == 0) {\r\nspin_lock_irq(&current->sighand->siglock);\r\nsigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);\r\nif (!(ka->sa.sa_flags & SA_NODEFER))\r\nsigaddset(&current->blocked,sig);\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void\r\nsyscall_restart(unsigned long r0, unsigned long r19,\r\nstruct pt_regs *regs, struct k_sigaction *ka)\r\n{\r\nswitch (regs->r0) {\r\ncase ERESTARTSYS:\r\nif (!(ka->sa.sa_flags & SA_RESTART)) {\r\ncase ERESTARTNOHAND:\r\nregs->r0 = EINTR;\r\nbreak;\r\n}\r\ncase ERESTARTNOINTR:\r\nregs->r0 = r0;\r\nregs->r19 = r19;\r\nregs->pc -= 4;\r\nbreak;\r\ncase ERESTART_RESTARTBLOCK:\r\nregs->r0 = EINTR;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndo_signal(struct pt_regs * regs, struct switch_stack * sw,\r\nunsigned long r0, unsigned long r19)\r\n{\r\nsiginfo_t info;\r\nint signr;\r\nunsigned long single_stepping = ptrace_cancel_bpt(current);\r\nstruct k_sigaction ka;\r\nsigset_t *oldset;\r\nif (test_thread_flag(TIF_RESTORE_SIGMASK))\r\noldset = &current->saved_sigmask;\r\nelse\r\noldset = &current->blocked;\r\nsignr = get_signal_to_deliver(&info, &ka, regs, NULL);\r\nsingle_stepping |= ptrace_cancel_bpt(current);\r\nif (signr > 0) {\r\nif (r0)\r\nsyscall_restart(r0, r19, regs, &ka);\r\nif (handle_signal(signr, &ka, &info, oldset, regs, sw) == 0) {\r\nif (test_thread_flag(TIF_RESTORE_SIGMASK))\r\nclear_thread_flag(TIF_RESTORE_SIGMASK);\r\n}\r\nif (single_stepping)\r\nptrace_set_bpt(current);\r\nreturn;\r\n}\r\nif (r0) {\r\nswitch (regs->r0) {\r\ncase ERESTARTNOHAND:\r\ncase ERESTARTSYS:\r\ncase ERESTARTNOINTR:\r\nregs->r0 = r0;\r\nregs->r19 = r19;\r\nregs->pc -= 4;\r\nbreak;\r\ncase ERESTART_RESTARTBLOCK:\r\nregs->r0 = __NR_restart_syscall;\r\nregs->pc -= 4;\r\nbreak;\r\n}\r\n}\r\nif (test_thread_flag(TIF_RESTORE_SIGMASK)) {\r\nclear_thread_flag(TIF_RESTORE_SIGMASK);\r\nsigprocmask(SIG_SETMASK, &current->saved_sigmask, NULL);\r\n}\r\nif (single_stepping)\r\nptrace_set_bpt(current);\r\n}\r\nvoid\r\ndo_notify_resume(struct pt_regs *regs, struct switch_stack *sw,\r\nunsigned long thread_info_flags,\r\nunsigned long r0, unsigned long r19)\r\n{\r\nif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\r\ndo_signal(regs, sw, r0, r19);\r\nif (thread_info_flags & _TIF_NOTIFY_RESUME) {\r\nclear_thread_flag(TIF_NOTIFY_RESUME);\r\ntracehook_notify_resume(regs);\r\nif (current->replacement_session_keyring)\r\nkey_replace_session_keyring();\r\n}\r\n}
