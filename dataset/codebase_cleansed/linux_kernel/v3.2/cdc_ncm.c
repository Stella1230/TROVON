static void\r\ncdc_ncm_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstrncpy(info->driver, dev->driver_name, sizeof(info->driver));\r\nstrncpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\nstrncpy(info->fw_version, dev->driver_info->description,\r\nsizeof(info->fw_version));\r\nusb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));\r\n}\r\nstatic u8 cdc_ncm_setup(struct cdc_ncm_ctx *ctx)\r\n{\r\nu32 val;\r\nu8 flags;\r\nu8 iface_no;\r\nint err;\r\nu16 ntb_fmt_supported;\r\niface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\r\nerr = usb_control_msg(ctx->udev,\r\nusb_rcvctrlpipe(ctx->udev, 0),\r\nUSB_CDC_GET_NTB_PARAMETERS,\r\nUSB_TYPE_CLASS | USB_DIR_IN\r\n| USB_RECIP_INTERFACE,\r\n0, iface_no, &ctx->ncm_parm,\r\nsizeof(ctx->ncm_parm), 10000);\r\nif (err < 0) {\r\npr_debug("failed GET_NTB_PARAMETERS\n");\r\nreturn 1;\r\n}\r\nctx->rx_max = le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize);\r\nctx->tx_max = le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize);\r\nctx->tx_remainder = le16_to_cpu(ctx->ncm_parm.wNdpOutPayloadRemainder);\r\nctx->tx_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutDivisor);\r\nctx->tx_ndp_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutAlignment);\r\nctx->tx_max_datagrams = le16_to_cpu(ctx->ncm_parm.wNtbOutMaxDatagrams);\r\nntb_fmt_supported = le16_to_cpu(ctx->ncm_parm.bmNtbFormatsSupported);\r\nif (ctx->func_desc != NULL)\r\nflags = ctx->func_desc->bmNetworkCapabilities;\r\nelse\r\nflags = 0;\r\npr_debug("dwNtbInMaxSize=%u dwNtbOutMaxSize=%u "\r\n"wNdpOutPayloadRemainder=%u wNdpOutDivisor=%u "\r\n"wNdpOutAlignment=%u wNtbOutMaxDatagrams=%u flags=0x%x\n",\r\nctx->rx_max, ctx->tx_max, ctx->tx_remainder, ctx->tx_modulus,\r\nctx->tx_ndp_modulus, ctx->tx_max_datagrams, flags);\r\nif ((ctx->tx_max_datagrams == 0) ||\r\n(ctx->tx_max_datagrams > CDC_NCM_DPT_DATAGRAMS_MAX))\r\nctx->tx_max_datagrams = CDC_NCM_DPT_DATAGRAMS_MAX;\r\nif (ctx->rx_max < USB_CDC_NCM_NTB_MIN_IN_SIZE) {\r\npr_debug("Using min receive length=%d\n",\r\nUSB_CDC_NCM_NTB_MIN_IN_SIZE);\r\nctx->rx_max = USB_CDC_NCM_NTB_MIN_IN_SIZE;\r\n}\r\nif (ctx->rx_max > CDC_NCM_NTB_MAX_SIZE_RX) {\r\npr_debug("Using default maximum receive length=%d\n",\r\nCDC_NCM_NTB_MAX_SIZE_RX);\r\nctx->rx_max = CDC_NCM_NTB_MAX_SIZE_RX;\r\n}\r\nif (ctx->rx_max != le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize)) {\r\nif (flags & USB_CDC_NCM_NCAP_NTB_INPUT_SIZE) {\r\nstruct usb_cdc_ncm_ndp_input_size *ndp_in_sz;\r\nndp_in_sz = kzalloc(sizeof(*ndp_in_sz), GFP_KERNEL);\r\nif (!ndp_in_sz) {\r\nerr = -ENOMEM;\r\ngoto size_err;\r\n}\r\nerr = usb_control_msg(ctx->udev,\r\nusb_sndctrlpipe(ctx->udev, 0),\r\nUSB_CDC_SET_NTB_INPUT_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\n0, iface_no, ndp_in_sz, 8, 1000);\r\nkfree(ndp_in_sz);\r\n} else {\r\n__le32 *dwNtbInMaxSize;\r\ndwNtbInMaxSize = kzalloc(sizeof(*dwNtbInMaxSize),\r\nGFP_KERNEL);\r\nif (!dwNtbInMaxSize) {\r\nerr = -ENOMEM;\r\ngoto size_err;\r\n}\r\n*dwNtbInMaxSize = cpu_to_le32(ctx->rx_max);\r\nerr = usb_control_msg(ctx->udev,\r\nusb_sndctrlpipe(ctx->udev, 0),\r\nUSB_CDC_SET_NTB_INPUT_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\n0, iface_no, dwNtbInMaxSize, 4, 1000);\r\nkfree(dwNtbInMaxSize);\r\n}\r\nsize_err:\r\nif (err < 0)\r\npr_debug("Setting NTB Input Size failed\n");\r\n}\r\nif ((ctx->tx_max <\r\n(CDC_NCM_MIN_HDR_SIZE + CDC_NCM_MIN_DATAGRAM_SIZE)) ||\r\n(ctx->tx_max > CDC_NCM_NTB_MAX_SIZE_TX)) {\r\npr_debug("Using default maximum transmit length=%d\n",\r\nCDC_NCM_NTB_MAX_SIZE_TX);\r\nctx->tx_max = CDC_NCM_NTB_MAX_SIZE_TX;\r\n}\r\nval = ctx->tx_ndp_modulus;\r\nif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\r\n(val != ((-val) & val)) || (val >= ctx->tx_max)) {\r\npr_debug("Using default alignment: 4 bytes\n");\r\nctx->tx_ndp_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\r\n}\r\nval = ctx->tx_modulus;\r\nif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\r\n(val != ((-val) & val)) || (val >= ctx->tx_max)) {\r\npr_debug("Using default transmit modulus: 4 bytes\n");\r\nctx->tx_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\r\n}\r\nif (ctx->tx_remainder >= ctx->tx_modulus) {\r\npr_debug("Using default transmit remainder: 0 bytes\n");\r\nctx->tx_remainder = 0;\r\n}\r\nctx->tx_remainder = ((ctx->tx_remainder - ETH_HLEN) &\r\n(ctx->tx_modulus - 1));\r\nif (flags & USB_CDC_NCM_NCAP_CRC_MODE) {\r\nerr = usb_control_msg(ctx->udev, usb_sndctrlpipe(ctx->udev, 0),\r\nUSB_CDC_SET_CRC_MODE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\nUSB_CDC_NCM_CRC_NOT_APPENDED,\r\niface_no, NULL, 0, 1000);\r\nif (err < 0)\r\npr_debug("Setting CRC mode off failed\n");\r\n}\r\nif (ntb_fmt_supported & USB_CDC_NCM_NTH32_SIGN) {\r\nerr = usb_control_msg(ctx->udev, usb_sndctrlpipe(ctx->udev, 0),\r\nUSB_CDC_SET_NTB_FORMAT, USB_TYPE_CLASS\r\n| USB_DIR_OUT | USB_RECIP_INTERFACE,\r\nUSB_CDC_NCM_NTB16_FORMAT,\r\niface_no, NULL, 0, 1000);\r\nif (err < 0)\r\npr_debug("Setting NTB format to 16-bit failed\n");\r\n}\r\nctx->max_datagram_size = CDC_NCM_MIN_DATAGRAM_SIZE;\r\nif (flags & USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE) {\r\n__le16 *max_datagram_size;\r\nu16 eth_max_sz = le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);\r\nmax_datagram_size = kzalloc(sizeof(*max_datagram_size),\r\nGFP_KERNEL);\r\nif (!max_datagram_size) {\r\nerr = -ENOMEM;\r\ngoto max_dgram_err;\r\n}\r\nerr = usb_control_msg(ctx->udev, usb_rcvctrlpipe(ctx->udev, 0),\r\nUSB_CDC_GET_MAX_DATAGRAM_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_IN\r\n| USB_RECIP_INTERFACE,\r\n0, iface_no, max_datagram_size,\r\n2, 1000);\r\nif (err < 0) {\r\npr_debug("GET_MAX_DATAGRAM_SIZE failed, use size=%u\n",\r\nCDC_NCM_MIN_DATAGRAM_SIZE);\r\nkfree(max_datagram_size);\r\n} else {\r\nctx->max_datagram_size =\r\nle16_to_cpu(*max_datagram_size);\r\nif (eth_max_sz < CDC_NCM_MAX_DATAGRAM_SIZE) {\r\nif (ctx->max_datagram_size > eth_max_sz)\r\nctx->max_datagram_size = eth_max_sz;\r\n} else {\r\nif (ctx->max_datagram_size >\r\nCDC_NCM_MAX_DATAGRAM_SIZE)\r\nctx->max_datagram_size =\r\nCDC_NCM_MAX_DATAGRAM_SIZE;\r\n}\r\nif (ctx->max_datagram_size < CDC_NCM_MIN_DATAGRAM_SIZE)\r\nctx->max_datagram_size =\r\nCDC_NCM_MIN_DATAGRAM_SIZE;\r\nerr = usb_control_msg(ctx->udev,\r\nusb_sndctrlpipe(ctx->udev, 0),\r\nUSB_CDC_SET_MAX_DATAGRAM_SIZE,\r\nUSB_TYPE_CLASS | USB_DIR_OUT\r\n| USB_RECIP_INTERFACE,\r\n0,\r\niface_no, max_datagram_size,\r\n2, 1000);\r\nkfree(max_datagram_size);\r\nmax_dgram_err:\r\nif (err < 0)\r\npr_debug("SET_MAX_DATAGRAM_SIZE failed\n");\r\n}\r\n}\r\nif (ctx->netdev->mtu != (ctx->max_datagram_size - ETH_HLEN))\r\nctx->netdev->mtu = ctx->max_datagram_size - ETH_HLEN;\r\nreturn 0;\r\n}\r\nstatic void\r\ncdc_ncm_find_endpoints(struct cdc_ncm_ctx *ctx, struct usb_interface *intf)\r\n{\r\nstruct usb_host_endpoint *e;\r\nu8 ep;\r\nfor (ep = 0; ep < intf->cur_altsetting->desc.bNumEndpoints; ep++) {\r\ne = intf->cur_altsetting->endpoint + ep;\r\nswitch (e->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (ctx->status_ep == NULL)\r\nctx->status_ep = e;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (usb_endpoint_dir_in(&e->desc)) {\r\nif (ctx->in_ep == NULL)\r\nctx->in_ep = e;\r\n} else {\r\nif (ctx->out_ep == NULL)\r\nctx->out_ep = e;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void cdc_ncm_free(struct cdc_ncm_ctx *ctx)\r\n{\r\nif (ctx == NULL)\r\nreturn;\r\ndel_timer_sync(&ctx->tx_timer);\r\nif (ctx->tx_rem_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_rem_skb);\r\nctx->tx_rem_skb = NULL;\r\n}\r\nif (ctx->tx_curr_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_curr_skb);\r\nctx->tx_curr_skb = NULL;\r\n}\r\nkfree(ctx);\r\n}\r\nstatic int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_driver *driver;\r\nu8 *buf;\r\nint len;\r\nint temp;\r\nu8 iface_no;\r\nctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (ctx == NULL)\r\nreturn -ENODEV;\r\nmemset(ctx, 0, sizeof(*ctx));\r\ninit_timer(&ctx->tx_timer);\r\nspin_lock_init(&ctx->mtx);\r\nctx->netdev = dev->net;\r\ndev->data[0] = (unsigned long)ctx;\r\ndriver = driver_of(intf);\r\nbuf = intf->cur_altsetting->extra;\r\nlen = intf->cur_altsetting->extralen;\r\nctx->udev = dev->udev;\r\nctx->intf = intf;\r\nwhile ((len > 0) && (buf[0] > 2) && (buf[0] <= len)) {\r\nif (buf[1] != USB_DT_CS_INTERFACE)\r\ngoto advance;\r\nswitch (buf[2]) {\r\ncase USB_CDC_UNION_TYPE:\r\nif (buf[0] < sizeof(*(ctx->union_desc)))\r\nbreak;\r\nctx->union_desc =\r\n(const struct usb_cdc_union_desc *)buf;\r\nctx->control = usb_ifnum_to_if(dev->udev,\r\nctx->union_desc->bMasterInterface0);\r\nctx->data = usb_ifnum_to_if(dev->udev,\r\nctx->union_desc->bSlaveInterface0);\r\nbreak;\r\ncase USB_CDC_ETHERNET_TYPE:\r\nif (buf[0] < sizeof(*(ctx->ether_desc)))\r\nbreak;\r\nctx->ether_desc =\r\n(const struct usb_cdc_ether_desc *)buf;\r\ndev->hard_mtu =\r\nle16_to_cpu(ctx->ether_desc->wMaxSegmentSize);\r\nif (dev->hard_mtu < CDC_NCM_MIN_DATAGRAM_SIZE)\r\ndev->hard_mtu = CDC_NCM_MIN_DATAGRAM_SIZE;\r\nelse if (dev->hard_mtu > CDC_NCM_MAX_DATAGRAM_SIZE)\r\ndev->hard_mtu = CDC_NCM_MAX_DATAGRAM_SIZE;\r\nbreak;\r\ncase USB_CDC_NCM_TYPE:\r\nif (buf[0] < sizeof(*(ctx->func_desc)))\r\nbreak;\r\nctx->func_desc = (const struct usb_cdc_ncm_desc *)buf;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nadvance:\r\ntemp = buf[0];\r\nbuf += temp;\r\nlen -= temp;\r\n}\r\nif ((ctx->control == NULL) || (ctx->data == NULL) ||\r\n(ctx->ether_desc == NULL) || (ctx->control != intf))\r\ngoto error;\r\ntemp = usb_driver_claim_interface(driver, ctx->data, dev);\r\nif (temp)\r\ngoto error;\r\niface_no = ctx->data->cur_altsetting->desc.bInterfaceNumber;\r\ntemp = usb_set_interface(dev->udev, iface_no, 0);\r\nif (temp)\r\ngoto error2;\r\nif (cdc_ncm_setup(ctx))\r\ngoto error2;\r\ntemp = usb_set_interface(dev->udev, iface_no, 1);\r\nif (temp)\r\ngoto error2;\r\ncdc_ncm_find_endpoints(ctx, ctx->data);\r\ncdc_ncm_find_endpoints(ctx, ctx->control);\r\nif ((ctx->in_ep == NULL) || (ctx->out_ep == NULL) ||\r\n(ctx->status_ep == NULL))\r\ngoto error2;\r\ndev->net->ethtool_ops = &cdc_ncm_ethtool_ops;\r\nusb_set_intfdata(ctx->data, dev);\r\nusb_set_intfdata(ctx->control, dev);\r\nusb_set_intfdata(ctx->intf, dev);\r\ntemp = usbnet_get_ethernet_addr(dev, ctx->ether_desc->iMACAddress);\r\nif (temp)\r\ngoto error2;\r\ndev_info(&dev->udev->dev, "MAC-Address: "\r\n"0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",\r\ndev->net->dev_addr[0], dev->net->dev_addr[1],\r\ndev->net->dev_addr[2], dev->net->dev_addr[3],\r\ndev->net->dev_addr[4], dev->net->dev_addr[5]);\r\ndev->in = usb_rcvbulkpipe(dev->udev,\r\nctx->in_ep->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->out = usb_sndbulkpipe(dev->udev,\r\nctx->out_ep->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\ndev->status = ctx->status_ep;\r\ndev->rx_urb_size = ctx->rx_max;\r\nnetif_carrier_off(dev->net);\r\nctx->tx_speed = ctx->rx_speed = 0;\r\nreturn 0;\r\nerror2:\r\nusb_set_intfdata(ctx->control, NULL);\r\nusb_set_intfdata(ctx->data, NULL);\r\nusb_driver_release_interface(driver, ctx->data);\r\nerror:\r\ncdc_ncm_free((struct cdc_ncm_ctx *)dev->data[0]);\r\ndev->data[0] = 0;\r\ndev_info(&dev->udev->dev, "bind() failure\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void cdc_ncm_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nstruct usb_driver *driver = driver_of(intf);\r\nif (ctx == NULL)\r\nreturn;\r\nif (intf == ctx->control && ctx->data) {\r\nusb_set_intfdata(ctx->data, NULL);\r\nusb_driver_release_interface(driver, ctx->data);\r\nctx->data = NULL;\r\n} else if (intf == ctx->data && ctx->control) {\r\nusb_set_intfdata(ctx->control, NULL);\r\nusb_driver_release_interface(driver, ctx->control);\r\nctx->control = NULL;\r\n}\r\nusb_set_intfdata(ctx->intf, NULL);\r\ncdc_ncm_free(ctx);\r\n}\r\nstatic void cdc_ncm_zero_fill(u8 *ptr, u32 first, u32 end, u32 max)\r\n{\r\nif (first >= max)\r\nreturn;\r\nif (first >= end)\r\nreturn;\r\nif (end > max)\r\nend = max;\r\nmemset(ptr + first, 0, end - first);\r\n}\r\nstatic struct sk_buff *\r\ncdc_ncm_fill_tx_frame(struct cdc_ncm_ctx *ctx, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb_out;\r\nu32 rem;\r\nu32 offset;\r\nu32 last_offset;\r\nu16 n = 0, index;\r\nu8 ready2send = 0;\r\nif (skb != NULL)\r\nswap(skb, ctx->tx_rem_skb);\r\nelse\r\nready2send = 1;\r\nif (ctx->tx_curr_skb != NULL) {\r\nskb_out = ctx->tx_curr_skb;\r\noffset = ctx->tx_curr_offset;\r\nlast_offset = ctx->tx_curr_last_offset;\r\nn = ctx->tx_curr_frame_num;\r\n} else {\r\nskb_out = alloc_skb((ctx->tx_max + 1), GFP_ATOMIC);\r\nif (skb_out == NULL) {\r\nif (skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\nctx->netdev->stats.tx_dropped++;\r\n}\r\ngoto exit_no_skb;\r\n}\r\noffset = ALIGN(sizeof(struct usb_cdc_ncm_nth16),\r\nctx->tx_ndp_modulus) +\r\nsizeof(struct usb_cdc_ncm_ndp16) +\r\n(ctx->tx_max_datagrams + 1) *\r\nsizeof(struct usb_cdc_ncm_dpe16);\r\nlast_offset = offset;\r\noffset = ALIGN(offset, ctx->tx_modulus) + ctx->tx_remainder;\r\ncdc_ncm_zero_fill(skb_out->data, 0, offset, offset);\r\nn = 0;\r\nctx->tx_curr_frame_num = 0;\r\n}\r\nfor (; n < ctx->tx_max_datagrams; n++) {\r\nif (offset >= ctx->tx_max) {\r\nready2send = 1;\r\nbreak;\r\n}\r\nrem = ctx->tx_max - offset;\r\nif (skb == NULL) {\r\nskb = ctx->tx_rem_skb;\r\nctx->tx_rem_skb = NULL;\r\nif (skb == NULL)\r\nbreak;\r\n}\r\nif (skb->len > rem) {\r\nif (n == 0) {\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nctx->netdev->stats.tx_dropped++;\r\n} else {\r\nif (ctx->tx_rem_skb != NULL) {\r\ndev_kfree_skb_any(ctx->tx_rem_skb);\r\nctx->netdev->stats.tx_dropped++;\r\n}\r\nctx->tx_rem_skb = skb;\r\nskb = NULL;\r\nready2send = 1;\r\n}\r\nbreak;\r\n}\r\nmemcpy(((u8 *)skb_out->data) + offset, skb->data, skb->len);\r\nctx->tx_ncm.dpe16[n].wDatagramLength = cpu_to_le16(skb->len);\r\nctx->tx_ncm.dpe16[n].wDatagramIndex = cpu_to_le16(offset);\r\noffset += skb->len;\r\nlast_offset = offset;\r\noffset = ALIGN(offset, ctx->tx_modulus) + ctx->tx_remainder;\r\ncdc_ncm_zero_fill(skb_out->data, last_offset, offset,\r\nctx->tx_max);\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\n}\r\nif (skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nctx->netdev->stats.tx_dropped++;\r\n}\r\nctx->tx_curr_frame_num = n;\r\nif (n == 0) {\r\nctx->tx_curr_skb = skb_out;\r\nctx->tx_curr_offset = offset;\r\nctx->tx_curr_last_offset = last_offset;\r\ngoto exit_no_skb;\r\n} else if ((n < ctx->tx_max_datagrams) && (ready2send == 0)) {\r\nctx->tx_curr_skb = skb_out;\r\nctx->tx_curr_offset = offset;\r\nctx->tx_curr_last_offset = last_offset;\r\nif (n < CDC_NCM_RESTART_TIMER_DATAGRAM_CNT)\r\nctx->tx_timer_pending = 2;\r\ngoto exit_no_skb;\r\n} else {\r\n}\r\nif (last_offset > ctx->tx_max)\r\nlast_offset = ctx->tx_max;\r\noffset = last_offset;\r\nif (offset > CDC_NCM_MIN_TX_PKT)\r\noffset = ctx->tx_max;\r\ncdc_ncm_zero_fill(skb_out->data, last_offset, offset, ctx->tx_max);\r\nlast_offset = offset;\r\nif (((last_offset < ctx->tx_max) && ((last_offset %\r\nle16_to_cpu(ctx->out_ep->desc.wMaxPacketSize)) == 0)) ||\r\n(((last_offset == ctx->tx_max) && ((ctx->tx_max %\r\nle16_to_cpu(ctx->out_ep->desc.wMaxPacketSize)) == 0)) &&\r\n(ctx->tx_max < le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize)))) {\r\n*(((u8 *)skb_out->data) + last_offset) = 0;\r\nlast_offset++;\r\n}\r\nfor (; n <= CDC_NCM_DPT_DATAGRAMS_MAX; n++) {\r\nctx->tx_ncm.dpe16[n].wDatagramLength = 0;\r\nctx->tx_ncm.dpe16[n].wDatagramIndex = 0;\r\n}\r\nctx->tx_ncm.nth16.dwSignature = cpu_to_le32(USB_CDC_NCM_NTH16_SIGN);\r\nctx->tx_ncm.nth16.wHeaderLength =\r\ncpu_to_le16(sizeof(ctx->tx_ncm.nth16));\r\nctx->tx_ncm.nth16.wSequence = cpu_to_le16(ctx->tx_seq);\r\nctx->tx_ncm.nth16.wBlockLength = cpu_to_le16(last_offset);\r\nindex = ALIGN(sizeof(struct usb_cdc_ncm_nth16), ctx->tx_ndp_modulus);\r\nctx->tx_ncm.nth16.wNdpIndex = cpu_to_le16(index);\r\nmemcpy(skb_out->data, &(ctx->tx_ncm.nth16), sizeof(ctx->tx_ncm.nth16));\r\nctx->tx_seq++;\r\nctx->tx_ncm.ndp16.dwSignature =\r\ncpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN);\r\nrem = sizeof(ctx->tx_ncm.ndp16) + ((ctx->tx_curr_frame_num + 1) *\r\nsizeof(struct usb_cdc_ncm_dpe16));\r\nctx->tx_ncm.ndp16.wLength = cpu_to_le16(rem);\r\nctx->tx_ncm.ndp16.wNextNdpIndex = 0;\r\nmemcpy(((u8 *)skb_out->data) + index,\r\n&(ctx->tx_ncm.ndp16),\r\nsizeof(ctx->tx_ncm.ndp16));\r\nmemcpy(((u8 *)skb_out->data) + index + sizeof(ctx->tx_ncm.ndp16),\r\n&(ctx->tx_ncm.dpe16),\r\n(ctx->tx_curr_frame_num + 1) *\r\nsizeof(struct usb_cdc_ncm_dpe16));\r\nskb_put(skb_out, last_offset);\r\nctx->tx_curr_skb = NULL;\r\nreturn skb_out;\r\nexit_no_skb:\r\nreturn NULL;\r\n}\r\nstatic void cdc_ncm_tx_timeout_start(struct cdc_ncm_ctx *ctx)\r\n{\r\nif (timer_pending(&ctx->tx_timer) == 0) {\r\nctx->tx_timer.function = &cdc_ncm_tx_timeout;\r\nctx->tx_timer.data = (unsigned long)ctx;\r\nctx->tx_timer.expires = jiffies + ((HZ + 999) / 1000);\r\nadd_timer(&ctx->tx_timer);\r\n}\r\n}\r\nstatic void cdc_ncm_tx_timeout(unsigned long arg)\r\n{\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)arg;\r\nu8 restart;\r\nspin_lock(&ctx->mtx);\r\nif (ctx->tx_timer_pending != 0) {\r\nctx->tx_timer_pending--;\r\nrestart = 1;\r\n} else {\r\nrestart = 0;\r\n}\r\nspin_unlock(&ctx->mtx);\r\nif (restart) {\r\nspin_lock(&ctx->mtx);\r\ncdc_ncm_tx_timeout_start(ctx);\r\nspin_unlock(&ctx->mtx);\r\n} else if (ctx->netdev != NULL) {\r\nusbnet_start_xmit(NULL, ctx->netdev);\r\n}\r\n}\r\nstatic struct sk_buff *\r\ncdc_ncm_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb_out;\r\nstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nu8 need_timer = 0;\r\nif (ctx == NULL)\r\ngoto error;\r\nspin_lock(&ctx->mtx);\r\nskb_out = cdc_ncm_fill_tx_frame(ctx, skb);\r\nif (ctx->tx_curr_skb != NULL)\r\nneed_timer = 1;\r\nif (need_timer)\r\ncdc_ncm_tx_timeout_start(ctx);\r\nif (skb_out)\r\ndev->net->stats.tx_packets += ctx->tx_curr_frame_num;\r\nspin_unlock(&ctx->mtx);\r\nreturn skb_out;\r\nerror:\r\nif (skb != NULL)\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nstatic int cdc_ncm_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cdc_ncm_ctx *ctx;\r\nint sumlen;\r\nint actlen;\r\nint temp;\r\nint nframes;\r\nint x;\r\nint offset;\r\nctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (ctx == NULL)\r\ngoto error;\r\nactlen = skb_in->len;\r\nsumlen = CDC_NCM_NTB_MAX_SIZE_RX;\r\nif (actlen < (sizeof(ctx->rx_ncm.nth16) + sizeof(ctx->rx_ncm.ndp16))) {\r\npr_debug("frame too short\n");\r\ngoto error;\r\n}\r\nmemcpy(&(ctx->rx_ncm.nth16), ((u8 *)skb_in->data),\r\nsizeof(ctx->rx_ncm.nth16));\r\nif (le32_to_cpu(ctx->rx_ncm.nth16.dwSignature) !=\r\nUSB_CDC_NCM_NTH16_SIGN) {\r\npr_debug("invalid NTH16 signature <%u>\n",\r\nle32_to_cpu(ctx->rx_ncm.nth16.dwSignature));\r\ngoto error;\r\n}\r\ntemp = le16_to_cpu(ctx->rx_ncm.nth16.wBlockLength);\r\nif (temp > sumlen) {\r\npr_debug("unsupported NTB block length %u/%u\n", temp, sumlen);\r\ngoto error;\r\n}\r\ntemp = le16_to_cpu(ctx->rx_ncm.nth16.wNdpIndex);\r\nif ((temp + sizeof(ctx->rx_ncm.ndp16)) > actlen) {\r\npr_debug("invalid DPT16 index\n");\r\ngoto error;\r\n}\r\nmemcpy(&(ctx->rx_ncm.ndp16), ((u8 *)skb_in->data) + temp,\r\nsizeof(ctx->rx_ncm.ndp16));\r\nif (le32_to_cpu(ctx->rx_ncm.ndp16.dwSignature) !=\r\nUSB_CDC_NCM_NDP16_NOCRC_SIGN) {\r\npr_debug("invalid DPT16 signature <%u>\n",\r\nle32_to_cpu(ctx->rx_ncm.ndp16.dwSignature));\r\ngoto error;\r\n}\r\nif (le16_to_cpu(ctx->rx_ncm.ndp16.wLength) <\r\nUSB_CDC_NCM_NDP16_LENGTH_MIN) {\r\npr_debug("invalid DPT16 length <%u>\n",\r\nle32_to_cpu(ctx->rx_ncm.ndp16.dwSignature));\r\ngoto error;\r\n}\r\nnframes = ((le16_to_cpu(ctx->rx_ncm.ndp16.wLength) -\r\nsizeof(struct usb_cdc_ncm_ndp16)) /\r\nsizeof(struct usb_cdc_ncm_dpe16));\r\nnframes--;\r\npr_debug("nframes = %u\n", nframes);\r\ntemp += sizeof(ctx->rx_ncm.ndp16);\r\nif ((temp + nframes * (sizeof(struct usb_cdc_ncm_dpe16))) > actlen) {\r\npr_debug("Invalid nframes = %d\n", nframes);\r\ngoto error;\r\n}\r\nif (nframes > CDC_NCM_DPT_DATAGRAMS_MAX) {\r\npr_debug("Truncating number of frames from %u to %u\n",\r\nnframes, CDC_NCM_DPT_DATAGRAMS_MAX);\r\nnframes = CDC_NCM_DPT_DATAGRAMS_MAX;\r\n}\r\nmemcpy(&(ctx->rx_ncm.dpe16), ((u8 *)skb_in->data) + temp,\r\nnframes * (sizeof(struct usb_cdc_ncm_dpe16)));\r\nfor (x = 0; x < nframes; x++) {\r\noffset = le16_to_cpu(ctx->rx_ncm.dpe16[x].wDatagramIndex);\r\ntemp = le16_to_cpu(ctx->rx_ncm.dpe16[x].wDatagramLength);\r\nif ((offset == 0) || (temp == 0)) {\r\nif (!x)\r\ngoto error;\r\nbreak;\r\n}\r\nif (((offset + temp) > actlen) ||\r\n(temp > CDC_NCM_MAX_DATAGRAM_SIZE) || (temp < ETH_HLEN)) {\r\npr_debug("invalid frame detected (ignored)"\r\n"offset[%u]=%u, length=%u, skb=%p\n",\r\nx, offset, temp, skb_in);\r\nif (!x)\r\ngoto error;\r\nbreak;\r\n} else {\r\nskb = skb_clone(skb_in, GFP_ATOMIC);\r\nif (!skb)\r\ngoto error;\r\nskb->len = temp;\r\nskb->data = ((u8 *)skb_in->data) + offset;\r\nskb_set_tail_pointer(skb, temp);\r\nusbnet_skb_return(dev, skb);\r\n}\r\n}\r\nreturn 1;\r\nerror:\r\nreturn 0;\r\n}\r\nstatic void\r\ncdc_ncm_speed_change(struct cdc_ncm_ctx *ctx,\r\nstruct usb_cdc_speed_change *data)\r\n{\r\nuint32_t rx_speed = le32_to_cpu(data->DLBitRRate);\r\nuint32_t tx_speed = le32_to_cpu(data->ULBitRate);\r\nif ((tx_speed != ctx->tx_speed) || (rx_speed != ctx->rx_speed)) {\r\nctx->tx_speed = tx_speed;\r\nctx->rx_speed = rx_speed;\r\nif ((tx_speed > 1000000) && (rx_speed > 1000000)) {\r\nprintk(KERN_INFO KBUILD_MODNAME\r\n": %s: %u mbit/s downlink "\r\n"%u mbit/s uplink\n",\r\nctx->netdev->name,\r\n(unsigned int)(rx_speed / 1000000U),\r\n(unsigned int)(tx_speed / 1000000U));\r\n} else {\r\nprintk(KERN_INFO KBUILD_MODNAME\r\n": %s: %u kbit/s downlink "\r\n"%u kbit/s uplink\n",\r\nctx->netdev->name,\r\n(unsigned int)(rx_speed / 1000U),\r\n(unsigned int)(tx_speed / 1000U));\r\n}\r\n}\r\n}\r\nstatic void cdc_ncm_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nstruct usb_cdc_notification *event;\r\nctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (urb->actual_length < sizeof(*event))\r\nreturn;\r\nif (test_and_clear_bit(EVENT_STS_SPLIT, &dev->flags)) {\r\ncdc_ncm_speed_change(ctx,\r\n(struct usb_cdc_speed_change *)urb->transfer_buffer);\r\nreturn;\r\n}\r\nevent = urb->transfer_buffer;\r\nswitch (event->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\nctx->connected = event->wValue;\r\nprintk(KERN_INFO KBUILD_MODNAME ": %s: network connection:"\r\n" %sconnected\n",\r\nctx->netdev->name, ctx->connected ? "" : "dis");\r\nif (ctx->connected)\r\nnetif_carrier_on(dev->net);\r\nelse {\r\nnetif_carrier_off(dev->net);\r\nctx->tx_speed = ctx->rx_speed = 0;\r\n}\r\nbreak;\r\ncase USB_CDC_NOTIFY_SPEED_CHANGE:\r\nif (urb->actual_length < (sizeof(*event) +\r\nsizeof(struct usb_cdc_speed_change)))\r\nset_bit(EVENT_STS_SPLIT, &dev->flags);\r\nelse\r\ncdc_ncm_speed_change(ctx,\r\n(struct usb_cdc_speed_change *) &event[1]);\r\nbreak;\r\ndefault:\r\ndev_err(&dev->udev->dev, "NCM: unexpected "\r\n"notification 0x%02x!\n", event->bNotificationType);\r\nbreak;\r\n}\r\n}\r\nstatic int cdc_ncm_check_connect(struct usbnet *dev)\r\n{\r\nstruct cdc_ncm_ctx *ctx;\r\nctx = (struct cdc_ncm_ctx *)dev->data[0];\r\nif (ctx == NULL)\r\nreturn 1;\r\nreturn !ctx->connected;\r\n}\r\nstatic int\r\ncdc_ncm_probe(struct usb_interface *udev, const struct usb_device_id *prod)\r\n{\r\nreturn usbnet_probe(udev, prod);\r\n}\r\nstatic void cdc_ncm_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (dev == NULL)\r\nreturn;\r\nusbnet_disconnect(intf);\r\n}\r\nstatic int cdc_ncm_manage_power(struct usbnet *dev, int status)\r\n{\r\ndev->intf->needs_remote_wakeup = status;\r\nreturn 0;\r\n}\r\nstatic int __init cdc_ncm_init(void)\r\n{\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION "\n");\r\nreturn usb_register(&cdc_ncm_driver);\r\n}\r\nstatic void __exit cdc_ncm_exit(void)\r\n{\r\nusb_deregister(&cdc_ncm_driver);\r\n}
