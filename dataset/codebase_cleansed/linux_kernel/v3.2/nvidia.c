static void nvidiafb_load_cursor_image(struct nvidia_par *par, u8 * data8,\r\nu16 bg, u16 fg, u32 w, u32 h)\r\n{\r\nu32 *data = (u32 *) data8;\r\nint i, j, k = 0;\r\nu32 b, tmp;\r\nw = (w + 1) & ~1;\r\nfor (i = 0; i < h; i++) {\r\nb = *data++;\r\nreverse_order(&b);\r\nfor (j = 0; j < w / 2; j++) {\r\ntmp = 0;\r\n#if defined (__BIG_ENDIAN)\r\ntmp = (b & (1 << 31)) ? fg << 16 : bg << 16;\r\nb <<= 1;\r\ntmp |= (b & (1 << 31)) ? fg : bg;\r\nb <<= 1;\r\n#else\r\ntmp = (b & 1) ? fg : bg;\r\nb >>= 1;\r\ntmp |= (b & 1) ? fg << 16 : bg << 16;\r\nb >>= 1;\r\n#endif\r\nNV_WR32(&par->CURSOR[k++], 0, tmp);\r\n}\r\nk += (MAX_CURS - w) / 2;\r\n}\r\n}\r\nstatic void nvidia_write_clut(struct nvidia_par *par,\r\nu8 regnum, u8 red, u8 green, u8 blue)\r\n{\r\nNVWriteDacMask(par, 0xff);\r\nNVWriteDacWriteAddr(par, regnum);\r\nNVWriteDacData(par, red);\r\nNVWriteDacData(par, green);\r\nNVWriteDacData(par, blue);\r\n}\r\nstatic void nvidia_read_clut(struct nvidia_par *par,\r\nu8 regnum, u8 * red, u8 * green, u8 * blue)\r\n{\r\nNVWriteDacMask(par, 0xff);\r\nNVWriteDacReadAddr(par, regnum);\r\n*red = NVReadDacData(par);\r\n*green = NVReadDacData(par);\r\n*blue = NVReadDacData(par);\r\n}\r\nstatic int nvidia_panel_tweak(struct nvidia_par *par,\r\nstruct _riva_hw_state *state)\r\n{\r\nint tweak = 0;\r\nif (par->paneltweak) {\r\ntweak = par->paneltweak;\r\n} else {\r\nif(((par->Chipset & 0xffff) == 0x0328) && (state->bpp == 32)) {\r\ntweak = -1;\r\n}\r\nif((par->Chipset & 0xfff0) == 0x0310) {\r\ntweak = 1;\r\n}\r\n}\r\nreturn tweak;\r\n}\r\nstatic void nvidia_screen_off(struct nvidia_par *par, int on)\r\n{\r\nunsigned char tmp;\r\nif (on) {\r\ntmp = NVReadSeq(par, 0x01);\r\nNVWriteSeq(par, 0x00, 0x01);\r\nNVWriteSeq(par, 0x01, tmp | 0x20);\r\n} else {\r\ntmp = NVReadSeq(par, 0x01);\r\nNVWriteSeq(par, 0x01, tmp & ~0x20);\r\nNVWriteSeq(par, 0x00, 0x03);\r\n}\r\n}\r\nstatic void nvidia_save_vga(struct nvidia_par *par,\r\nstruct _riva_hw_state *state)\r\n{\r\nint i;\r\nNVTRACE_ENTER();\r\nNVLockUnlock(par, 0);\r\nNVUnloadStateExt(par, state);\r\nstate->misc_output = NVReadMiscOut(par);\r\nfor (i = 0; i < NUM_CRT_REGS; i++)\r\nstate->crtc[i] = NVReadCrtc(par, i);\r\nfor (i = 0; i < NUM_ATC_REGS; i++)\r\nstate->attr[i] = NVReadAttr(par, i);\r\nfor (i = 0; i < NUM_GRC_REGS; i++)\r\nstate->gra[i] = NVReadGr(par, i);\r\nfor (i = 0; i < NUM_SEQ_REGS; i++)\r\nstate->seq[i] = NVReadSeq(par, i);\r\nNVTRACE_LEAVE();\r\n}\r\nstatic void nvidia_write_regs(struct nvidia_par *par,\r\nstruct _riva_hw_state *state)\r\n{\r\nint i;\r\nNVTRACE_ENTER();\r\nNVLoadStateExt(par, state);\r\nNVWriteMiscOut(par, state->misc_output);\r\nfor (i = 1; i < NUM_SEQ_REGS; i++) {\r\n#ifdef DUMP_REG\r\nprintk(" SEQ[%02x] = %08x\n", i, state->seq[i]);\r\n#endif\r\nNVWriteSeq(par, i, state->seq[i]);\r\n}\r\nNVWriteCrtc(par, 0x11, state->crtc[0x11] & ~0x80);\r\nfor (i = 0; i < NUM_CRT_REGS; i++) {\r\nswitch (i) {\r\ncase 0x19:\r\ncase 0x20 ... 0x40:\r\nbreak;\r\ndefault:\r\n#ifdef DUMP_REG\r\nprintk("CRTC[%02x] = %08x\n", i, state->crtc[i]);\r\n#endif\r\nNVWriteCrtc(par, i, state->crtc[i]);\r\n}\r\n}\r\nfor (i = 0; i < NUM_GRC_REGS; i++) {\r\n#ifdef DUMP_REG\r\nprintk(" GRA[%02x] = %08x\n", i, state->gra[i]);\r\n#endif\r\nNVWriteGr(par, i, state->gra[i]);\r\n}\r\nfor (i = 0; i < NUM_ATC_REGS; i++) {\r\n#ifdef DUMP_REG\r\nprintk("ATTR[%02x] = %08x\n", i, state->attr[i]);\r\n#endif\r\nNVWriteAttr(par, i, state->attr[i]);\r\n}\r\nNVTRACE_LEAVE();\r\n}\r\nstatic int nvidia_calc_regs(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nstruct _riva_hw_state *state = &par->ModeReg;\r\nint i, depth = fb_get_color_depth(&info->var, &info->fix);\r\nint h_display = info->var.xres / 8 - 1;\r\nint h_start = (info->var.xres + info->var.right_margin) / 8 - 1;\r\nint h_end = (info->var.xres + info->var.right_margin +\r\ninfo->var.hsync_len) / 8 - 1;\r\nint h_total = (info->var.xres + info->var.right_margin +\r\ninfo->var.hsync_len + info->var.left_margin) / 8 - 5;\r\nint h_blank_s = h_display;\r\nint h_blank_e = h_total + 4;\r\nint v_display = info->var.yres - 1;\r\nint v_start = info->var.yres + info->var.lower_margin - 1;\r\nint v_end = (info->var.yres + info->var.lower_margin +\r\ninfo->var.vsync_len) - 1;\r\nint v_total = (info->var.yres + info->var.lower_margin +\r\ninfo->var.vsync_len + info->var.upper_margin) - 2;\r\nint v_blank_s = v_display;\r\nint v_blank_e = v_total + 1;\r\nif (info->var.vmode & FB_VMODE_INTERLACED)\r\nv_total |= 1;\r\nif (par->FlatPanel == 1) {\r\nv_start = v_total - 3;\r\nv_end = v_total - 2;\r\nv_blank_s = v_start;\r\nh_start = h_total - 5;\r\nh_end = h_total - 2;\r\nh_blank_e = h_total + 4;\r\n}\r\nstate->crtc[0x0] = Set8Bits(h_total);\r\nstate->crtc[0x1] = Set8Bits(h_display);\r\nstate->crtc[0x2] = Set8Bits(h_blank_s);\r\nstate->crtc[0x3] = SetBitField(h_blank_e, 4: 0, 4:0)\r\n| SetBit(7);\r\nstate->crtc[0x4] = Set8Bits(h_start);\r\nstate->crtc[0x5] = SetBitField(h_blank_e, 5: 5, 7:7)\r\n| SetBitField(h_end, 4: 0, 4:0);\r\nstate->crtc[0x6] = SetBitField(v_total, 7: 0, 7:0);\r\nstate->crtc[0x7] = SetBitField(v_total, 8: 8, 0:0)\r\n| SetBitField(v_display, 8: 8, 1:1)\r\n| SetBitField(v_start, 8: 8, 2:2)\r\n| SetBitField(v_blank_s, 8: 8, 3:3)\r\n| SetBit(4)\r\n| SetBitField(v_total, 9: 9, 5:5)\r\n| SetBitField(v_display, 9: 9, 6:6)\r\n| SetBitField(v_start, 9: 9, 7:7);\r\nstate->crtc[0x9] = SetBitField(v_blank_s, 9: 9, 5:5)\r\n| SetBit(6)\r\n| ((info->var.vmode & FB_VMODE_DOUBLE) ? 0x80 : 0x00);\r\nstate->crtc[0x10] = Set8Bits(v_start);\r\nstate->crtc[0x11] = SetBitField(v_end, 3: 0, 3:0) | SetBit(5);\r\nstate->crtc[0x12] = Set8Bits(v_display);\r\nstate->crtc[0x13] = ((info->var.xres_virtual / 8) *\r\n(info->var.bits_per_pixel / 8));\r\nstate->crtc[0x15] = Set8Bits(v_blank_s);\r\nstate->crtc[0x16] = Set8Bits(v_blank_e);\r\nstate->attr[0x10] = 0x01;\r\nif (par->Television)\r\nstate->attr[0x11] = 0x00;\r\nstate->screen = SetBitField(h_blank_e, 6: 6, 4:4)\r\n| SetBitField(v_blank_s, 10: 10, 3:3)\r\n| SetBitField(v_start, 10: 10, 2:2)\r\n| SetBitField(v_display, 10: 10, 1:1)\r\n| SetBitField(v_total, 10: 10, 0:0);\r\nstate->horiz = SetBitField(h_total, 8: 8, 0:0)\r\n| SetBitField(h_display, 8: 8, 1:1)\r\n| SetBitField(h_blank_s, 8: 8, 2:2)\r\n| SetBitField(h_start, 8: 8, 3:3);\r\nstate->extra = SetBitField(v_total, 11: 11, 0:0)\r\n| SetBitField(v_display, 11: 11, 2:2)\r\n| SetBitField(v_start, 11: 11, 4:4)\r\n| SetBitField(v_blank_s, 11: 11, 6:6);\r\nif (info->var.vmode & FB_VMODE_INTERLACED) {\r\nh_total = (h_total >> 1) & ~1;\r\nstate->interlace = Set8Bits(h_total);\r\nstate->horiz |= SetBitField(h_total, 8: 8, 4:4);\r\n} else {\r\nstate->interlace = 0xff;\r\n}\r\nif (depth < 24)\r\ni = depth;\r\nelse\r\ni = 32;\r\nif (par->Architecture >= NV_ARCH_10)\r\npar->CURSOR = (volatile u32 __iomem *)(info->screen_base +\r\npar->CursorStart);\r\nif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\nstate->misc_output &= ~0x40;\r\nelse\r\nstate->misc_output |= 0x40;\r\nif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\nstate->misc_output &= ~0x80;\r\nelse\r\nstate->misc_output |= 0x80;\r\nNVCalcStateExt(par, state, i, info->var.xres_virtual,\r\ninfo->var.xres, info->var.yres_virtual,\r\n1000000000 / info->var.pixclock, info->var.vmode);\r\nstate->scale = NV_RD32(par->PRAMDAC, 0x00000848) & 0xfff000ff;\r\nif (par->FlatPanel == 1) {\r\nstate->pixel |= (1 << 7);\r\nif (!par->fpScaler || (par->fpWidth <= info->var.xres)\r\n|| (par->fpHeight <= info->var.yres)) {\r\nstate->scale |= (1 << 8);\r\n}\r\nif (!par->crtcSync_read) {\r\nstate->crtcSync = NV_RD32(par->PRAMDAC, 0x0828);\r\npar->crtcSync_read = 1;\r\n}\r\npar->PanelTweak = nvidia_panel_tweak(par, state);\r\n}\r\nstate->vpll = state->pll;\r\nstate->vpll2 = state->pll;\r\nstate->vpllB = state->pllB;\r\nstate->vpll2B = state->pllB;\r\nVGA_WR08(par->PCIO, 0x03D4, 0x1C);\r\nstate->fifo = VGA_RD08(par->PCIO, 0x03D5) & ~(1<<5);\r\nif (par->CRTCnumber) {\r\nstate->head = NV_RD32(par->PCRTC0, 0x00000860) & ~0x00001000;\r\nstate->head2 = NV_RD32(par->PCRTC0, 0x00002860) | 0x00001000;\r\nstate->crtcOwner = 3;\r\nstate->pllsel |= 0x20000800;\r\nstate->vpll = NV_RD32(par->PRAMDAC0, 0x00000508);\r\nif (par->twoStagePLL)\r\nstate->vpllB = NV_RD32(par->PRAMDAC0, 0x00000578);\r\n} else if (par->twoHeads) {\r\nstate->head = NV_RD32(par->PCRTC0, 0x00000860) | 0x00001000;\r\nstate->head2 = NV_RD32(par->PCRTC0, 0x00002860) & ~0x00001000;\r\nstate->crtcOwner = 0;\r\nstate->vpll2 = NV_RD32(par->PRAMDAC0, 0x0520);\r\nif (par->twoStagePLL)\r\nstate->vpll2B = NV_RD32(par->PRAMDAC0, 0x057C);\r\n}\r\nstate->cursorConfig = 0x00000100;\r\nif (info->var.vmode & FB_VMODE_DOUBLE)\r\nstate->cursorConfig |= (1 << 4);\r\nif (par->alphaCursor) {\r\nif ((par->Chipset & 0x0ff0) != 0x0110)\r\nstate->cursorConfig |= 0x04011000;\r\nelse\r\nstate->cursorConfig |= 0x14011000;\r\nstate->general |= (1 << 29);\r\n} else\r\nstate->cursorConfig |= 0x02000000;\r\nif (par->twoHeads) {\r\nif ((par->Chipset & 0x0ff0) == 0x0110) {\r\nstate->dither = NV_RD32(par->PRAMDAC, 0x0528) &\r\n~0x00010000;\r\nif (par->FPDither)\r\nstate->dither |= 0x00010000;\r\n} else {\r\nstate->dither = NV_RD32(par->PRAMDAC, 0x083C) & ~1;\r\nif (par->FPDither)\r\nstate->dither |= 1;\r\n}\r\n}\r\nstate->timingH = 0;\r\nstate->timingV = 0;\r\nstate->displayV = info->var.xres;\r\nreturn 0;\r\n}\r\nstatic void nvidia_init_vga(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nstruct _riva_hw_state *state = &par->ModeReg;\r\nint i;\r\nfor (i = 0; i < 0x10; i++)\r\nstate->attr[i] = i;\r\nstate->attr[0x10] = 0x41;\r\nstate->attr[0x11] = 0xff;\r\nstate->attr[0x12] = 0x0f;\r\nstate->attr[0x13] = 0x00;\r\nstate->attr[0x14] = 0x00;\r\nmemset(state->crtc, 0x00, NUM_CRT_REGS);\r\nstate->crtc[0x0a] = 0x20;\r\nstate->crtc[0x17] = 0xe3;\r\nstate->crtc[0x18] = 0xff;\r\nstate->crtc[0x28] = 0x40;\r\nmemset(state->gra, 0x00, NUM_GRC_REGS);\r\nstate->gra[0x05] = 0x40;\r\nstate->gra[0x06] = 0x05;\r\nstate->gra[0x07] = 0x0f;\r\nstate->gra[0x08] = 0xff;\r\nstate->seq[0x00] = 0x03;\r\nstate->seq[0x01] = 0x01;\r\nstate->seq[0x02] = 0x0f;\r\nstate->seq[0x03] = 0x00;\r\nstate->seq[0x04] = 0x0e;\r\nstate->misc_output = 0xeb;\r\n}\r\nstatic int nvidiafb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nu8 data[MAX_CURS * MAX_CURS / 8];\r\nint i, set = cursor->set;\r\nu16 fg, bg;\r\nif (cursor->image.width > MAX_CURS || cursor->image.height > MAX_CURS)\r\nreturn -ENXIO;\r\nNVShowHideCursor(par, 0);\r\nif (par->cursor_reset) {\r\nset = FB_CUR_SETALL;\r\npar->cursor_reset = 0;\r\n}\r\nif (set & FB_CUR_SETSIZE)\r\nmemset_io(par->CURSOR, 0, MAX_CURS * MAX_CURS * 2);\r\nif (set & FB_CUR_SETPOS) {\r\nu32 xx, yy, temp;\r\nyy = cursor->image.dy - info->var.yoffset;\r\nxx = cursor->image.dx - info->var.xoffset;\r\ntemp = xx & 0xFFFF;\r\ntemp |= yy << 16;\r\nNV_WR32(par->PRAMDAC, 0x0000300, temp);\r\n}\r\nif (set & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP | FB_CUR_SETIMAGE)) {\r\nu32 bg_idx = cursor->image.bg_color;\r\nu32 fg_idx = cursor->image.fg_color;\r\nu32 s_pitch = (cursor->image.width + 7) >> 3;\r\nu32 d_pitch = MAX_CURS / 8;\r\nu8 *dat = (u8 *) cursor->image.data;\r\nu8 *msk = (u8 *) cursor->mask;\r\nu8 *src;\r\nsrc = kmalloc(s_pitch * cursor->image.height, GFP_ATOMIC);\r\nif (src) {\r\nswitch (cursor->rop) {\r\ncase ROP_XOR:\r\nfor (i = 0; i < s_pitch * cursor->image.height; i++)\r\nsrc[i] = dat[i] ^ msk[i];\r\nbreak;\r\ncase ROP_COPY:\r\ndefault:\r\nfor (i = 0; i < s_pitch * cursor->image.height; i++)\r\nsrc[i] = dat[i] & msk[i];\r\nbreak;\r\n}\r\nfb_pad_aligned_buffer(data, d_pitch, src, s_pitch,\r\ncursor->image.height);\r\nbg = ((info->cmap.red[bg_idx] & 0xf8) << 7) |\r\n((info->cmap.green[bg_idx] & 0xf8) << 2) |\r\n((info->cmap.blue[bg_idx] & 0xf8) >> 3) | 1 << 15;\r\nfg = ((info->cmap.red[fg_idx] & 0xf8) << 7) |\r\n((info->cmap.green[fg_idx] & 0xf8) << 2) |\r\n((info->cmap.blue[fg_idx] & 0xf8) >> 3) | 1 << 15;\r\nNVLockUnlock(par, 0);\r\nnvidiafb_load_cursor_image(par, data, bg, fg,\r\ncursor->image.width,\r\ncursor->image.height);\r\nkfree(src);\r\n}\r\n}\r\nif (cursor->enable)\r\nNVShowHideCursor(par, 1);\r\nreturn 0;\r\n}\r\nstatic int nvidiafb_set_par(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nNVTRACE_ENTER();\r\nNVLockUnlock(par, 1);\r\nif (!par->FlatPanel || !par->twoHeads)\r\npar->FPDither = 0;\r\nif (par->FPDither < 0) {\r\nif ((par->Chipset & 0x0ff0) == 0x0110)\r\npar->FPDither = !!(NV_RD32(par->PRAMDAC, 0x0528)\r\n& 0x00010000);\r\nelse\r\npar->FPDither = !!(NV_RD32(par->PRAMDAC, 0x083C) & 1);\r\nprintk(KERN_INFO PFX "Flat panel dithering %s\n",\r\npar->FPDither ? "enabled" : "disabled");\r\n}\r\ninfo->fix.visual = (info->var.bits_per_pixel == 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\nnvidia_init_vga(info);\r\nnvidia_calc_regs(info);\r\nNVLockUnlock(par, 0);\r\nif (par->twoHeads) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x44);\r\nVGA_WR08(par->PCIO, 0x03D5, par->ModeReg.crtcOwner);\r\nNVLockUnlock(par, 0);\r\n}\r\nnvidia_screen_off(par, 1);\r\nnvidia_write_regs(par, &par->ModeReg);\r\nNVSetStartAddress(par, 0);\r\n#if defined (__BIG_ENDIAN)\r\n{\r\nunsigned char tmp;\r\nVGA_WR08(par->PCIO, 0x3d4, 0x46);\r\ntmp = VGA_RD08(par->PCIO, 0x3d5);\r\ntmp |= (1 << 7);\r\nVGA_WR08(par->PCIO, 0x3d5, tmp);\r\n}\r\n#endif\r\ninfo->fix.line_length = (info->var.xres_virtual *\r\ninfo->var.bits_per_pixel) >> 3;\r\nif (info->var.accel_flags) {\r\ninfo->fbops->fb_imageblit = nvidiafb_imageblit;\r\ninfo->fbops->fb_fillrect = nvidiafb_fillrect;\r\ninfo->fbops->fb_copyarea = nvidiafb_copyarea;\r\ninfo->fbops->fb_sync = nvidiafb_sync;\r\ninfo->pixmap.scan_align = 4;\r\ninfo->flags &= ~FBINFO_HWACCEL_DISABLED;\r\ninfo->flags |= FBINFO_READS_FAST;\r\nNVResetGraphics(info);\r\n} else {\r\ninfo->fbops->fb_imageblit = cfb_imageblit;\r\ninfo->fbops->fb_fillrect = cfb_fillrect;\r\ninfo->fbops->fb_copyarea = cfb_copyarea;\r\ninfo->fbops->fb_sync = NULL;\r\ninfo->pixmap.scan_align = 1;\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\ninfo->flags &= ~FBINFO_READS_FAST;\r\n}\r\npar->cursor_reset = 1;\r\nnvidia_screen_off(par, 0);\r\n#ifdef CONFIG_BOOTX_TEXT\r\nbtext_update_display(info->fix.smem_start,\r\ninfo->var.xres, info->var.yres,\r\ninfo->var.bits_per_pixel, info->fix.line_length);\r\n#endif\r\nNVLockUnlock(par, 0);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int nvidiafb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nint i;\r\nNVTRACE_ENTER();\r\nif (regno >= (1 << info->var.green.length))\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\n((u32 *) info->pseudo_palette)[regno] =\r\n(regno << info->var.red.offset) |\r\n(regno << info->var.green.offset) |\r\n(regno << info->var.blue.offset);\r\n}\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nnvidia_write_clut(par, regno, red >> 8, green >> 8, blue >> 8);\r\nbreak;\r\ncase 16:\r\nif (info->var.green.length == 5) {\r\nfor (i = 0; i < 8; i++) {\r\nnvidia_write_clut(par, regno * 8 + i, red >> 8,\r\ngreen >> 8, blue >> 8);\r\n}\r\n} else {\r\nu8 r, g, b;\r\nif (regno < 32) {\r\nfor (i = 0; i < 8; i++) {\r\nnvidia_write_clut(par, regno * 8 + i,\r\nred >> 8, green >> 8,\r\nblue >> 8);\r\n}\r\n}\r\nnvidia_read_clut(par, regno * 4, &r, &g, &b);\r\nfor (i = 0; i < 4; i++)\r\nnvidia_write_clut(par, regno * 4 + i, r,\r\ngreen >> 8, b);\r\n}\r\nbreak;\r\ncase 32:\r\nnvidia_write_clut(par, regno, red >> 8, green >> 8, blue >> 8);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int nvidiafb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nint memlen, vramlen, mode_valid = 0;\r\nint pitch, err = 0;\r\nNVTRACE_ENTER();\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->xres &= ~7;\r\nif (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse\r\nvar->bits_per_pixel = 32;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->green.length = (var->green.length < 6) ? 5 : 6;\r\nvar->red.length = 5;\r\nvar->blue.length = 5;\r\nvar->transp.length = 6 - var->green.length;\r\nvar->blue.offset = 0;\r\nvar->green.offset = 5;\r\nvar->red.offset = 5 + var->green.length;\r\nvar->transp.offset = (5 + var->red.offset) & 15;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.length = 8;\r\nvar->transp.offset = 24;\r\nbreak;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nif (!info->monspecs.hfmax || !info->monspecs.vfmax ||\r\n!info->monspecs.dclkmax || !fb_validate_mode(var, info))\r\nmode_valid = 1;\r\nif (!mode_valid && info->monspecs.gtf) {\r\nif (!fb_get_mode(FB_MAXTIMINGS, 0, var, info))\r\nmode_valid = 1;\r\n}\r\nif (!mode_valid) {\r\nconst struct fb_videomode *mode;\r\nmode = fb_find_best_mode(var, &info->modelist);\r\nif (mode) {\r\nfb_videomode_to_var(var, mode);\r\nmode_valid = 1;\r\n}\r\n}\r\nif (!mode_valid && info->monspecs.modedb_len)\r\nreturn -EINVAL;\r\nif (par->fpWidth && par->fpHeight && (par->fpWidth < var->xres ||\r\npar->fpHeight < var->yres)) {\r\nconst struct fb_videomode *mode;\r\nvar->xres = par->fpWidth;\r\nvar->yres = par->fpHeight;\r\nmode = fb_find_best_mode(var, &info->modelist);\r\nif (!mode) {\r\nprintk(KERN_ERR PFX "mode out of range of flat "\r\n"panel dimensions\n");\r\nreturn -EINVAL;\r\n}\r\nfb_videomode_to_var(var, mode);\r\n}\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nvar->xres_virtual = (var->xres_virtual + 63) & ~63;\r\nvramlen = info->screen_size;\r\npitch = ((var->xres_virtual * var->bits_per_pixel) + 7) / 8;\r\nmemlen = pitch * var->yres_virtual;\r\nif (memlen > vramlen) {\r\nvar->yres_virtual = vramlen / pitch;\r\nif (var->yres_virtual < var->yres) {\r\nvar->yres_virtual = var->yres;\r\nvar->xres_virtual = vramlen / var->yres_virtual;\r\nvar->xres_virtual /= var->bits_per_pixel / 8;\r\nvar->xres_virtual &= ~63;\r\npitch = (var->xres_virtual *\r\nvar->bits_per_pixel + 7) / 8;\r\nmemlen = pitch * var->yres;\r\nif (var->xres_virtual < var->xres) {\r\nprintk("nvidiafb: required video memory, "\r\n"%d bytes, for %dx%d-%d (virtual) "\r\n"is out of range\n",\r\nmemlen, var->xres_virtual,\r\nvar->yres_virtual, var->bits_per_pixel);\r\nerr = -ENOMEM;\r\n}\r\n}\r\n}\r\nif (var->accel_flags) {\r\nif (var->yres_virtual > 0x7fff)\r\nvar->yres_virtual = 0x7fff;\r\nif (var->xres_virtual > 0x7fff)\r\nvar->xres_virtual = 0x7fff;\r\n}\r\nvar->xres_virtual &= ~63;\r\nNVTRACE_LEAVE();\r\nreturn err;\r\n}\r\nstatic int nvidiafb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nu32 total;\r\ntotal = var->yoffset * info->fix.line_length + var->xoffset;\r\nNVSetStartAddress(par, total);\r\nreturn 0;\r\n}\r\nstatic int nvidiafb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nunsigned char tmp, vesa;\r\ntmp = NVReadSeq(par, 0x01) & ~0x20;\r\nvesa = NVReadCrtc(par, 0x1a) & ~0xc0;\r\nNVTRACE_ENTER();\r\nif (blank)\r\ntmp |= 0x20;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nvesa |= 0x80;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nvesa |= 0x40;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nvesa |= 0xc0;\r\nbreak;\r\n}\r\nNVWriteSeq(par, 0x01, tmp);\r\nNVWriteCrtc(par, 0x1a, vesa);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic void save_vga_x86(struct nvidia_par *par)\r\n{\r\nstruct resource *res= &par->pci_dev->resource[PCI_ROM_RESOURCE];\r\nif (res && res->flags & IORESOURCE_ROM_SHADOW) {\r\nmemset(&par->vgastate, 0, sizeof(par->vgastate));\r\npar->vgastate.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS |\r\nVGA_SAVE_CMAP;\r\nsave_vga(&par->vgastate);\r\n}\r\n}\r\nstatic void restore_vga_x86(struct nvidia_par *par)\r\n{\r\nstruct resource *res= &par->pci_dev->resource[PCI_ROM_RESOURCE];\r\nif (res && res->flags & IORESOURCE_ROM_SHADOW)\r\nrestore_vga(&par->vgastate);\r\n}\r\nstatic int nvidiafb_open(struct fb_info *info, int user)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nif (!par->open_count) {\r\nsave_vga_x86(par);\r\nnvidia_save_vga(par, &par->initial_state);\r\n}\r\npar->open_count++;\r\nreturn 0;\r\n}\r\nstatic int nvidiafb_release(struct fb_info *info, int user)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nint err = 0;\r\nif (!par->open_count) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (par->open_count == 1) {\r\nnvidia_write_regs(par, &par->initial_state);\r\nrestore_vga_x86(par);\r\n}\r\npar->open_count--;\r\ndone:\r\nreturn err;\r\n}\r\nstatic int nvidiafb_suspend(struct pci_dev *dev, pm_message_t mesg)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct nvidia_par *par = info->par;\r\nif (mesg.event == PM_EVENT_PRETHAW)\r\nmesg.event = PM_EVENT_FREEZE;\r\nconsole_lock();\r\npar->pm_state = mesg.event;\r\nif (mesg.event & PM_EVENT_SLEEP) {\r\nfb_set_suspend(info, 1);\r\nnvidiafb_blank(FB_BLANK_POWERDOWN, info);\r\nnvidia_write_regs(par, &par->SavedReg);\r\npci_save_state(dev);\r\npci_disable_device(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, mesg));\r\n}\r\ndev->dev.power.power_state = mesg;\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int nvidiafb_resume(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct nvidia_par *par = info->par;\r\nconsole_lock();\r\npci_set_power_state(dev, PCI_D0);\r\nif (par->pm_state != PM_EVENT_FREEZE) {\r\npci_restore_state(dev);\r\nif (pci_enable_device(dev))\r\ngoto fail;\r\npci_set_master(dev);\r\n}\r\npar->pm_state = PM_EVENT_ON;\r\nnvidiafb_set_par(info);\r\nfb_set_suspend (info, 0);\r\nnvidiafb_blank(FB_BLANK_UNBLANK, info);\r\nfail:\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int __devinit nvidia_set_fbinfo(struct fb_info *info)\r\n{\r\nstruct fb_monspecs *specs = &info->monspecs;\r\nstruct fb_videomode modedb;\r\nstruct nvidia_par *par = info->par;\r\nint lpitch;\r\nNVTRACE_ENTER();\r\ninfo->flags = FBINFO_DEFAULT\r\n| FBINFO_HWACCEL_IMAGEBLIT\r\n| FBINFO_HWACCEL_FILLRECT\r\n| FBINFO_HWACCEL_COPYAREA\r\n| FBINFO_HWACCEL_YPAN;\r\nfb_videomode_to_modelist(info->monspecs.modedb,\r\ninfo->monspecs.modedb_len, &info->modelist);\r\nfb_var_to_videomode(&modedb, &nvidiafb_default_var);\r\nswitch (bpp) {\r\ncase 0 ... 8:\r\nbpp = 8;\r\nbreak;\r\ncase 9 ... 16:\r\nbpp = 16;\r\nbreak;\r\ndefault:\r\nbpp = 32;\r\nbreak;\r\n}\r\nif (specs->modedb != NULL) {\r\nconst struct fb_videomode *mode;\r\nmode = fb_find_best_display(specs, &info->modelist);\r\nfb_videomode_to_var(&nvidiafb_default_var, mode);\r\nnvidiafb_default_var.bits_per_pixel = bpp;\r\n} else if (par->fpWidth && par->fpHeight) {\r\nchar buf[16];\r\nmemset(buf, 0, 16);\r\nsnprintf(buf, 15, "%dx%dMR", par->fpWidth, par->fpHeight);\r\nfb_find_mode(&nvidiafb_default_var, info, buf, specs->modedb,\r\nspecs->modedb_len, &modedb, bpp);\r\n}\r\nif (mode_option)\r\nfb_find_mode(&nvidiafb_default_var, info, mode_option,\r\nspecs->modedb, specs->modedb_len, &modedb, bpp);\r\ninfo->var = nvidiafb_default_var;\r\ninfo->fix.visual = (info->var.bits_per_pixel == 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\nfb_destroy_modedb(info->monspecs.modedb);\r\ninfo->monspecs.modedb = NULL;\r\nlpitch = info->var.xres_virtual *\r\n((info->var.bits_per_pixel + 7) >> 3);\r\ninfo->var.yres_virtual = info->screen_size / lpitch;\r\ninfo->pixmap.scan_align = 4;\r\ninfo->pixmap.buf_align = 4;\r\ninfo->pixmap.access_align = 32;\r\ninfo->pixmap.size = 8 * 1024;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nif (!hwcur)\r\ninfo->fbops->fb_cursor = NULL;\r\ninfo->var.accel_flags = (!noaccel);\r\nswitch (par->Architecture) {\r\ncase NV_ARCH_04:\r\ninfo->fix.accel = FB_ACCEL_NV4;\r\nbreak;\r\ncase NV_ARCH_10:\r\ninfo->fix.accel = FB_ACCEL_NV_10;\r\nbreak;\r\ncase NV_ARCH_20:\r\ninfo->fix.accel = FB_ACCEL_NV_20;\r\nbreak;\r\ncase NV_ARCH_30:\r\ninfo->fix.accel = FB_ACCEL_NV_30;\r\nbreak;\r\ncase NV_ARCH_40:\r\ninfo->fix.accel = FB_ACCEL_NV_40;\r\nbreak;\r\n}\r\nNVTRACE_LEAVE();\r\nreturn nvidiafb_check_var(&info->var, info);\r\n}\r\nstatic u32 __devinit nvidia_get_chipset(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nu32 id = (par->pci_dev->vendor << 16) | par->pci_dev->device;\r\nprintk(KERN_INFO PFX "Device ID: %x \n", id);\r\nif ((id & 0xfff0) == 0x00f0 ||\r\n(id & 0xfff0) == 0x02e0) {\r\nid = NV_RD32(par->REGS, 0x1800);\r\nif ((id & 0x0000ffff) == 0x000010DE)\r\nid = 0x10DE0000 | (id >> 16);\r\nelse if ((id & 0xffff0000) == 0xDE100000)\r\nid = 0x10DE0000 | ((id << 8) & 0x0000ff00) |\r\n((id >> 8) & 0x000000ff);\r\nprintk(KERN_INFO PFX "Subsystem ID: %x \n", id);\r\n}\r\nreturn id;\r\n}\r\nstatic u32 __devinit nvidia_get_arch(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nu32 arch = 0;\r\nswitch (par->Chipset & 0x0ff0) {\r\ncase 0x0100:\r\ncase 0x0110:\r\ncase 0x0150:\r\ncase 0x0170:\r\ncase 0x0180:\r\ncase 0x01A0:\r\ncase 0x01F0:\r\narch = NV_ARCH_10;\r\nbreak;\r\ncase 0x0200:\r\ncase 0x0250:\r\ncase 0x0280:\r\narch = NV_ARCH_20;\r\nbreak;\r\ncase 0x0300:\r\ncase 0x0310:\r\ncase 0x0320:\r\ncase 0x0330:\r\ncase 0x0340:\r\narch = NV_ARCH_30;\r\nbreak;\r\ncase 0x0040:\r\ncase 0x00C0:\r\ncase 0x0120:\r\ncase 0x0140:\r\ncase 0x0160:\r\ncase 0x01D0:\r\ncase 0x0090:\r\ncase 0x0210:\r\ncase 0x0220:\r\ncase 0x0240:\r\ncase 0x0290:\r\ncase 0x0390:\r\ncase 0x03D0:\r\narch = NV_ARCH_40;\r\nbreak;\r\ncase 0x0020:\r\narch = NV_ARCH_04;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn arch;\r\n}\r\nstatic int __devinit nvidiafb_probe(struct pci_dev *pd,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct nvidia_par *par;\r\nstruct fb_info *info;\r\nunsigned short cmd;\r\nNVTRACE_ENTER();\r\nassert(pd != NULL);\r\ninfo = framebuffer_alloc(sizeof(struct nvidia_par), &pd->dev);\r\nif (!info)\r\ngoto err_out;\r\npar = info->par;\r\npar->pci_dev = pd;\r\ninfo->pixmap.addr = kzalloc(8 * 1024, GFP_KERNEL);\r\nif (info->pixmap.addr == NULL)\r\ngoto err_out_kfree;\r\nif (pci_enable_device(pd)) {\r\nprintk(KERN_ERR PFX "cannot enable PCI device\n");\r\ngoto err_out_enable;\r\n}\r\nif (pci_request_regions(pd, "nvidiafb")) {\r\nprintk(KERN_ERR PFX "cannot request PCI regions\n");\r\ngoto err_out_enable;\r\n}\r\npar->FlatPanel = flatpanel;\r\nif (flatpanel == 1)\r\nprintk(KERN_INFO PFX "flatpanel support enabled\n");\r\npar->FPDither = fpdither;\r\npar->CRTCnumber = forceCRTC;\r\npar->FpScale = (!noscale);\r\npar->paneltweak = paneltweak;\r\npar->reverse_i2c = reverse_i2c;\r\npci_read_config_word(pd, PCI_COMMAND, &cmd);\r\ncmd |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\r\npci_write_config_word(pd, PCI_COMMAND, cmd);\r\nnvidiafb_fix.mmio_start = pci_resource_start(pd, 0);\r\nnvidiafb_fix.smem_start = pci_resource_start(pd, 1);\r\nnvidiafb_fix.mmio_len = pci_resource_len(pd, 0);\r\npar->REGS = ioremap(nvidiafb_fix.mmio_start, nvidiafb_fix.mmio_len);\r\nif (!par->REGS) {\r\nprintk(KERN_ERR PFX "cannot ioremap MMIO base\n");\r\ngoto err_out_free_base0;\r\n}\r\npar->Chipset = nvidia_get_chipset(info);\r\npar->Architecture = nvidia_get_arch(info);\r\nif (par->Architecture == 0) {\r\nprintk(KERN_ERR PFX "unknown NV_ARCH\n");\r\ngoto err_out_arch;\r\n}\r\nsprintf(nvidiafb_fix.id, "NV%x", (pd->device & 0x0ff0) >> 4);\r\nif (NVCommonSetup(info))\r\ngoto err_out_arch;\r\npar->FbAddress = nvidiafb_fix.smem_start;\r\npar->FbMapSize = par->RamAmountKBytes * 1024;\r\nif (vram && vram * 1024 * 1024 < par->FbMapSize)\r\npar->FbMapSize = vram * 1024 * 1024;\r\nif (par->FbMapSize > 64 * 1024 * 1024)\r\npar->FbMapSize = 64 * 1024 * 1024;\r\nif(par->Architecture >= NV_ARCH_40)\r\npar->FbUsableSize = par->FbMapSize - (560 * 1024);\r\nelse\r\npar->FbUsableSize = par->FbMapSize - (128 * 1024);\r\npar->ScratchBufferSize = (par->Architecture < NV_ARCH_10) ? 8 * 1024 :\r\n16 * 1024;\r\npar->ScratchBufferStart = par->FbUsableSize - par->ScratchBufferSize;\r\npar->CursorStart = par->FbUsableSize + (32 * 1024);\r\ninfo->screen_base = ioremap(nvidiafb_fix.smem_start, par->FbMapSize);\r\ninfo->screen_size = par->FbUsableSize;\r\nnvidiafb_fix.smem_len = par->RamAmountKBytes * 1024;\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR PFX "cannot ioremap FB base\n");\r\ngoto err_out_free_base1;\r\n}\r\npar->FbStart = info->screen_base;\r\n#ifdef CONFIG_MTRR\r\nif (!nomtrr) {\r\npar->mtrr.vram = mtrr_add(nvidiafb_fix.smem_start,\r\npar->RamAmountKBytes * 1024,\r\nMTRR_TYPE_WRCOMB, 1);\r\nif (par->mtrr.vram < 0) {\r\nprintk(KERN_ERR PFX "unable to setup MTRR\n");\r\n} else {\r\npar->mtrr.vram_valid = 1;\r\nprintk(KERN_INFO PFX "MTRR set to ON\n");\r\n}\r\n}\r\n#endif\r\ninfo->fbops = &nvidia_fb_ops;\r\ninfo->fix = nvidiafb_fix;\r\nif (nvidia_set_fbinfo(info) < 0) {\r\nprintk(KERN_ERR PFX "error setting initial video mode\n");\r\ngoto err_out_iounmap_fb;\r\n}\r\nnvidia_save_vga(par, &par->SavedReg);\r\npci_set_drvdata(pd, info);\r\nif (backlight)\r\nnvidia_bl_init(par);\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR PFX "error registering nVidia framebuffer\n");\r\ngoto err_out_iounmap_fb;\r\n}\r\nprintk(KERN_INFO PFX\r\n"PCI nVidia %s framebuffer (%dMB @ 0x%lX)\n",\r\ninfo->fix.id,\r\npar->FbMapSize / (1024 * 1024), info->fix.smem_start);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\nerr_out_iounmap_fb:\r\niounmap(info->screen_base);\r\nerr_out_free_base1:\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nnvidia_delete_i2c_busses(par);\r\nerr_out_arch:\r\niounmap(par->REGS);\r\nerr_out_free_base0:\r\npci_release_regions(pd);\r\nerr_out_enable:\r\nkfree(info->pixmap.addr);\r\nerr_out_kfree:\r\nframebuffer_release(info);\r\nerr_out:\r\nreturn -ENODEV;\r\n}\r\nstatic void __devexit nvidiafb_remove(struct pci_dev *pd)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pd);\r\nstruct nvidia_par *par = info->par;\r\nNVTRACE_ENTER();\r\nunregister_framebuffer(info);\r\nnvidia_bl_exit(par);\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr.vram_valid)\r\nmtrr_del(par->mtrr.vram, info->fix.smem_start,\r\ninfo->fix.smem_len);\r\n#endif\r\niounmap(info->screen_base);\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nnvidia_delete_i2c_busses(par);\r\niounmap(par->REGS);\r\npci_release_regions(pd);\r\nkfree(info->pixmap.addr);\r\nframebuffer_release(info);\r\npci_set_drvdata(pd, NULL);\r\nNVTRACE_LEAVE();\r\n}\r\nstatic int __devinit nvidiafb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nNVTRACE_ENTER();\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "forceCRTC", 9)) {\r\nchar *p;\r\np = this_opt + 9;\r\nif (!*p || !*(++p))\r\ncontinue;\r\nforceCRTC = *p - '0';\r\nif (forceCRTC < 0 || forceCRTC > 1)\r\nforceCRTC = -1;\r\n} else if (!strncmp(this_opt, "flatpanel", 9)) {\r\nflatpanel = 1;\r\n} else if (!strncmp(this_opt, "hwcur", 5)) {\r\nhwcur = 1;\r\n} else if (!strncmp(this_opt, "noaccel", 6)) {\r\nnoaccel = 1;\r\n} else if (!strncmp(this_opt, "noscale", 7)) {\r\nnoscale = 1;\r\n} else if (!strncmp(this_opt, "reverse_i2c", 11)) {\r\nreverse_i2c = 1;\r\n} else if (!strncmp(this_opt, "paneltweak:", 11)) {\r\npaneltweak = simple_strtoul(this_opt+11, NULL, 0);\r\n} else if (!strncmp(this_opt, "vram:", 5)) {\r\nvram = simple_strtoul(this_opt+5, NULL, 0);\r\n} else if (!strncmp(this_opt, "backlight:", 10)) {\r\nbacklight = simple_strtoul(this_opt+10, NULL, 0);\r\n#ifdef CONFIG_MTRR\r\n} else if (!strncmp(this_opt, "nomtrr", 6)) {\r\nnomtrr = 1;\r\n#endif\r\n} else if (!strncmp(this_opt, "fpdither:", 9)) {\r\nfpdither = simple_strtol(this_opt+9, NULL, 0);\r\n} else if (!strncmp(this_opt, "bpp:", 4)) {\r\nbpp = simple_strtoul(this_opt+4, NULL, 0);\r\n} else\r\nmode_option = this_opt;\r\n}\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int __devinit nvidiafb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("nvidiafb", &option))\r\nreturn -ENODEV;\r\nnvidiafb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&nvidiafb_driver);\r\n}\r\nstatic void __exit nvidiafb_exit(void)\r\n{\r\npci_unregister_driver(&nvidiafb_driver);\r\n}
