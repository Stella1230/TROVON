static void econet_remove_socket(struct hlist_head *list, struct sock *sk)\r\n{\r\nspin_lock_bh(&econet_lock);\r\nsk_del_node_init(sk);\r\nspin_unlock_bh(&econet_lock);\r\n}\r\nstatic void econet_insert_socket(struct hlist_head *list, struct sock *sk)\r\n{\r\nspin_lock_bh(&econet_lock);\r\nsk_add_node(sk, list);\r\nspin_unlock_bh(&econet_lock);\r\n}\r\nstatic int econet_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nsize_t copied;\r\nint err;\r\nmsg->msg_namelen = sizeof(struct sockaddr_ec);\r\nmutex_lock(&econet_mutex);\r\nskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\r\nif (skb == NULL)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\ncopied = len;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nerr = memcpy_toiovec(msg->msg_iov, skb->data, copied);\r\nif (err)\r\ngoto out_free;\r\nsk->sk_stamp = skb->tstamp;\r\nif (msg->msg_name)\r\nmemcpy(msg->msg_name, skb->cb, msg->msg_namelen);\r\nerr = copied;\r\nout_free:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nmutex_unlock(&econet_mutex);\r\nreturn err;\r\n}\r\nstatic int econet_bind(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len)\r\n{\r\nstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\r\nstruct sock *sk;\r\nstruct econet_sock *eo;\r\nif (addr_len < sizeof(struct sockaddr_ec) ||\r\nsec->sec_family != AF_ECONET)\r\nreturn -EINVAL;\r\nmutex_lock(&econet_mutex);\r\nsk = sock->sk;\r\neo = ec_sk(sk);\r\neo->cb = sec->cb;\r\neo->port = sec->port;\r\neo->station = sec->addr.station;\r\neo->net = sec->addr.net;\r\nmutex_unlock(&econet_mutex);\r\nreturn 0;\r\n}\r\nstatic void tx_result(struct sock *sk, unsigned long cookie, int result)\r\n{\r\nstruct sk_buff *skb = alloc_skb(0, GFP_ATOMIC);\r\nstruct ec_cb *eb;\r\nstruct sockaddr_ec *sec;\r\nif (skb == NULL) {\r\npr_debug("econet: memory squeeze, transmit result dropped\n");\r\nreturn;\r\n}\r\neb = (struct ec_cb *)&skb->cb;\r\nsec = (struct sockaddr_ec *)&eb->sec;\r\nmemset(sec, 0, sizeof(struct sockaddr_ec));\r\nsec->cookie = cookie;\r\nsec->type = ECTYPE_TRANSMIT_STATUS | result;\r\nsec->sec_family = AF_ECONET;\r\nif (sock_queue_rcv_skb(sk, skb) < 0)\r\nkfree_skb(skb);\r\n}\r\nstatic void ec_tx_done(struct sk_buff *skb, int result)\r\n{\r\nstruct ec_cb *eb = (struct ec_cb *)&skb->cb;\r\ntx_result(skb->sk, eb->cookie, result);\r\n}\r\nstatic int econet_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sockaddr_ec *saddr = (struct sockaddr_ec *)msg->msg_name;\r\nstruct net_device *dev;\r\nstruct ec_addr addr;\r\nint err;\r\nunsigned char port, cb;\r\n#if defined(CONFIG_ECONET_AUNUDP) || defined(CONFIG_ECONET_NATIVE)\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nstruct ec_cb *eb;\r\n#endif\r\n#ifdef CONFIG_ECONET_AUNUDP\r\nstruct msghdr udpmsg;\r\nstruct iovec iov[2];\r\nstruct aunhdr ah;\r\nstruct sockaddr_in udpdest;\r\n__kernel_size_t size;\r\nmm_segment_t oldfs;\r\nchar *userbuf;\r\n#endif\r\nif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\r\nreturn -EINVAL;\r\nmutex_lock(&econet_mutex);\r\nif (saddr == NULL || msg->msg_namelen < sizeof(struct sockaddr_ec)) {\r\nmutex_unlock(&econet_mutex);\r\nreturn -EINVAL;\r\n}\r\naddr.station = saddr->addr.station;\r\naddr.net = saddr->addr.net;\r\nport = saddr->port;\r\ncb = saddr->cb;\r\ndev = net2dev_map[addr.net];\r\nif (dev == NULL) {\r\ndev = net2dev_map[0];\r\nif (dev == NULL) {\r\nmutex_unlock(&econet_mutex);\r\nreturn -ENETDOWN;\r\n}\r\n}\r\nif (dev->type == ARPHRD_ECONET) {\r\n#ifdef CONFIG_ECONET_NATIVE\r\nunsigned short proto = 0;\r\nint res;\r\nif (len + 15 > dev->mtu) {\r\nmutex_unlock(&econet_mutex);\r\nreturn -EMSGSIZE;\r\n}\r\ndev_hold(dev);\r\nskb = sock_alloc_send_skb(sk, len + LL_ALLOCATED_SPACE(dev),\r\nmsg->msg_flags & MSG_DONTWAIT, &err);\r\nif (skb == NULL)\r\ngoto out_unlock;\r\nskb_reserve(skb, LL_RESERVED_SPACE(dev));\r\nskb_reset_network_header(skb);\r\neb = (struct ec_cb *)&skb->cb;\r\neb->cookie = saddr->cookie;\r\neb->sec = *saddr;\r\neb->sent = ec_tx_done;\r\nerr = -EINVAL;\r\nres = dev_hard_header(skb, dev, ntohs(proto), &addr, NULL, len);\r\nif (res < 0)\r\ngoto out_free;\r\nif (res > 0) {\r\nstruct ec_framehdr *fh;\r\nfh = (struct ec_framehdr *)skb->data;\r\nfh->cb = cb;\r\nfh->port = port;\r\nif (sock->type != SOCK_DGRAM) {\r\nskb_reset_tail_pointer(skb);\r\nskb->len = 0;\r\n}\r\n}\r\nerr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\r\nskb->protocol = proto;\r\nskb->dev = dev;\r\nskb->priority = sk->sk_priority;\r\nif (err)\r\ngoto out_free;\r\nerr = -ENETDOWN;\r\nif (!(dev->flags & IFF_UP))\r\ngoto out_free;\r\ndev_queue_xmit(skb);\r\ndev_put(dev);\r\nmutex_unlock(&econet_mutex);\r\nreturn len;\r\nout_free:\r\nkfree_skb(skb);\r\nout_unlock:\r\nif (dev)\r\ndev_put(dev);\r\n#else\r\nerr = -EPROTOTYPE;\r\n#endif\r\nmutex_unlock(&econet_mutex);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_ECONET_AUNUDP\r\nif (udpsock == NULL) {\r\nmutex_unlock(&econet_mutex);\r\nreturn -ENETDOWN;\r\n}\r\nif (len > 32768) {\r\nerr = -E2BIG;\r\ngoto error;\r\n}\r\nmemset(&udpdest, 0, sizeof(udpdest));\r\nudpdest.sin_family = AF_INET;\r\nudpdest.sin_port = htons(AUN_PORT);\r\n{\r\nstruct in_device *idev;\r\nunsigned long network = 0;\r\nrcu_read_lock();\r\nidev = __in_dev_get_rcu(dev);\r\nif (idev) {\r\nif (idev->ifa_list)\r\nnetwork = ntohl(idev->ifa_list->ifa_address) &\r\n0xffffff00;\r\n}\r\nrcu_read_unlock();\r\nudpdest.sin_addr.s_addr = htonl(network | addr.station);\r\n}\r\nmemset(&ah, 0, sizeof(ah));\r\nah.port = port;\r\nah.cb = cb & 0x7f;\r\nah.code = 2;\r\nsize = sizeof(struct aunhdr);\r\niov[0].iov_base = (void *)&ah;\r\niov[0].iov_len = size;\r\nuserbuf = vmalloc(len);\r\nif (userbuf == NULL) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\niov[1].iov_base = userbuf;\r\niov[1].iov_len = len;\r\nerr = memcpy_fromiovec(userbuf, msg->msg_iov, len);\r\nif (err)\r\ngoto error_free_buf;\r\nskb = sock_alloc_send_skb(sk, 0, msg->msg_flags & MSG_DONTWAIT, &err);\r\nif (skb == NULL)\r\ngoto error_free_buf;\r\neb = (struct ec_cb *)&skb->cb;\r\neb->cookie = saddr->cookie;\r\neb->timeout = 5 * HZ;\r\neb->start = jiffies;\r\nah.handle = aun_seq;\r\neb->seq = (aun_seq++);\r\neb->sec = *saddr;\r\nskb_queue_tail(&aun_queue, skb);\r\nudpmsg.msg_name = (void *)&udpdest;\r\nudpmsg.msg_namelen = sizeof(udpdest);\r\nudpmsg.msg_iov = &iov[0];\r\nudpmsg.msg_iovlen = 2;\r\nudpmsg.msg_control = NULL;\r\nudpmsg.msg_controllen = 0;\r\nudpmsg.msg_flags = 0;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = sock_sendmsg(udpsock, &udpmsg, size);\r\nset_fs(oldfs);\r\nerror_free_buf:\r\nvfree(userbuf);\r\nerror:\r\n#else\r\nerr = -EPROTOTYPE;\r\n#endif\r\nmutex_unlock(&econet_mutex);\r\nreturn err;\r\n}\r\nstatic int econet_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sock *sk;\r\nstruct econet_sock *eo;\r\nstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\r\nif (peer)\r\nreturn -EOPNOTSUPP;\r\nmemset(sec, 0, sizeof(*sec));\r\nmutex_lock(&econet_mutex);\r\nsk = sock->sk;\r\neo = ec_sk(sk);\r\nsec->sec_family = AF_ECONET;\r\nsec->port = eo->port;\r\nsec->addr.station = eo->station;\r\nsec->addr.net = eo->net;\r\nmutex_unlock(&econet_mutex);\r\n*uaddr_len = sizeof(*sec);\r\nreturn 0;\r\n}\r\nstatic void econet_destroy_timer(unsigned long data)\r\n{\r\nstruct sock *sk = (struct sock *)data;\r\nif (!sk_has_allocations(sk)) {\r\nsk_free(sk);\r\nreturn;\r\n}\r\nsk->sk_timer.expires = jiffies + 10 * HZ;\r\nadd_timer(&sk->sk_timer);\r\npr_debug("econet: socket destroy delayed\n");\r\n}\r\nstatic int econet_release(struct socket *sock)\r\n{\r\nstruct sock *sk;\r\nmutex_lock(&econet_mutex);\r\nsk = sock->sk;\r\nif (!sk)\r\ngoto out_unlock;\r\neconet_remove_socket(&econet_sklist, sk);\r\nsk->sk_state_change(sk);\r\nsock_orphan(sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nif (sk_has_allocations(sk)) {\r\nsk->sk_timer.data = (unsigned long)sk;\r\nsk->sk_timer.expires = jiffies + HZ;\r\nsk->sk_timer.function = econet_destroy_timer;\r\nadd_timer(&sk->sk_timer);\r\ngoto out_unlock;\r\n}\r\nsk_free(sk);\r\nout_unlock:\r\nmutex_unlock(&econet_mutex);\r\nreturn 0;\r\n}\r\nstatic int econet_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nstruct econet_sock *eo;\r\nint err;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (sock->type != SOCK_DGRAM)\r\nreturn -ESOCKTNOSUPPORT;\r\nsock->state = SS_UNCONNECTED;\r\nerr = -ENOBUFS;\r\nsk = sk_alloc(net, PF_ECONET, GFP_KERNEL, &econet_proto);\r\nif (sk == NULL)\r\ngoto out;\r\nsk->sk_reuse = 1;\r\nsock->ops = &econet_ops;\r\nsock_init_data(sock, sk);\r\neo = ec_sk(sk);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nsk->sk_family = PF_ECONET;\r\neo->num = protocol;\r\neconet_insert_socket(&econet_sklist, sk);\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int ec_dev_ioctl(struct socket *sock, unsigned int cmd, void __user *arg)\r\n{\r\nstruct ifreq ifr;\r\nstruct ec_device *edev;\r\nstruct net_device *dev;\r\nstruct sockaddr_ec *sec;\r\nint err;\r\nif (copy_from_user(&ifr, arg, sizeof(struct ifreq)))\r\nreturn -EFAULT;\r\ndev = dev_get_by_name(&init_net, ifr.ifr_name);\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nsec = (struct sockaddr_ec *)&ifr.ifr_addr;\r\nmutex_lock(&econet_mutex);\r\nerr = 0;\r\nswitch (cmd) {\r\ncase SIOCSIFADDR:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerr = -EPERM;\r\nbreak;\r\n}\r\nedev = dev->ec_ptr;\r\nif (edev == NULL) {\r\nedev = kzalloc(sizeof(struct ec_device), GFP_KERNEL);\r\nif (edev == NULL) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\ndev->ec_ptr = edev;\r\n} else\r\nnet2dev_map[edev->net] = NULL;\r\nedev->station = sec->addr.station;\r\nedev->net = sec->addr.net;\r\nnet2dev_map[sec->addr.net] = dev;\r\nif (!net2dev_map[0])\r\nnet2dev_map[0] = dev;\r\nbreak;\r\ncase SIOCGIFADDR:\r\nedev = dev->ec_ptr;\r\nif (edev == NULL) {\r\nerr = -ENODEV;\r\nbreak;\r\n}\r\nmemset(sec, 0, sizeof(struct sockaddr_ec));\r\nsec->addr.station = edev->station;\r\nsec->addr.net = edev->net;\r\nsec->sec_family = AF_ECONET;\r\ndev_put(dev);\r\nif (copy_to_user(arg, &ifr, sizeof(struct ifreq)))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&econet_mutex);\r\ndev_put(dev);\r\nreturn err;\r\n}\r\nstatic int econet_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase SIOCGSTAMP:\r\nreturn sock_get_timestamp(sk, argp);\r\ncase SIOCGSTAMPNS:\r\nreturn sock_get_timestampns(sk, argp);\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFADDR:\r\nreturn ec_dev_ioctl(sock, cmd, argp);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic struct sock *ec_listening_socket(unsigned char port, unsigned char\r\nstation, unsigned char net)\r\n{\r\nstruct sock *sk;\r\nstruct hlist_node *node;\r\nspin_lock(&econet_lock);\r\nsk_for_each(sk, node, &econet_sklist) {\r\nstruct econet_sock *opt = ec_sk(sk);\r\nif ((opt->port == port || opt->port == 0) &&\r\n(opt->station == station || opt->station == 0) &&\r\n(opt->net == net || opt->net == 0)) {\r\nsock_hold(sk);\r\ngoto found;\r\n}\r\n}\r\nsk = NULL;\r\nfound:\r\nspin_unlock(&econet_lock);\r\nreturn sk;\r\n}\r\nstatic int ec_queue_packet(struct sock *sk, struct sk_buff *skb,\r\nunsigned char stn, unsigned char net,\r\nunsigned char cb, unsigned char port)\r\n{\r\nstruct ec_cb *eb = (struct ec_cb *)&skb->cb;\r\nstruct sockaddr_ec *sec = (struct sockaddr_ec *)&eb->sec;\r\nmemset(sec, 0, sizeof(struct sockaddr_ec));\r\nsec->sec_family = AF_ECONET;\r\nsec->type = ECTYPE_PACKET_RECEIVED;\r\nsec->port = port;\r\nsec->cb = cb;\r\nsec->addr.net = net;\r\nsec->addr.station = stn;\r\nreturn sock_queue_rcv_skb(sk, skb);\r\n}\r\nstatic void aun_send_response(__u32 addr, unsigned long seq, int code, int cb)\r\n{\r\nstruct sockaddr_in sin = {\r\n.sin_family = AF_INET,\r\n.sin_port = htons(AUN_PORT),\r\n.sin_addr = {.s_addr = addr}\r\n};\r\nstruct aunhdr ah = {.code = code, .cb = cb, .handle = seq};\r\nstruct kvec iov = {.iov_base = (void *)&ah, .iov_len = sizeof(ah)};\r\nstruct msghdr udpmsg;\r\nudpmsg.msg_name = (void *)&sin;\r\nudpmsg.msg_namelen = sizeof(sin);\r\nudpmsg.msg_control = NULL;\r\nudpmsg.msg_controllen = 0;\r\nudpmsg.msg_flags = 0;\r\nkernel_sendmsg(udpsock, &udpmsg, &iov, 1, sizeof(ah));\r\n}\r\nstatic void aun_incoming(struct sk_buff *skb, struct aunhdr *ah, size_t len)\r\n{\r\nstruct iphdr *ip = ip_hdr(skb);\r\nunsigned char stn = ntohl(ip->saddr) & 0xff;\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct ec_device *edev = NULL;\r\nstruct sock *sk = NULL;\r\nstruct sk_buff *newskb;\r\nif (dst)\r\nedev = dst->dev->ec_ptr;\r\nif (!edev)\r\ngoto bad;\r\nsk = ec_listening_socket(ah->port, stn, edev->net);\r\nif (sk == NULL)\r\ngoto bad;\r\nnewskb = alloc_skb((len - sizeof(struct aunhdr) + 15) & ~15,\r\nGFP_ATOMIC);\r\nif (newskb == NULL) {\r\npr_debug("AUN: memory squeeze, dropping packet\n");\r\ngoto bad;\r\n}\r\nmemcpy(skb_put(newskb, len - sizeof(struct aunhdr)), (void *)(ah + 1),\r\nlen - sizeof(struct aunhdr));\r\nif (ec_queue_packet(sk, newskb, stn, edev->net, ah->cb, ah->port)) {\r\nkfree_skb(newskb);\r\ngoto bad;\r\n}\r\naun_send_response(ip->saddr, ah->handle, 3, 0);\r\nsock_put(sk);\r\nreturn;\r\nbad:\r\naun_send_response(ip->saddr, ah->handle, 4, 0);\r\nif (sk)\r\nsock_put(sk);\r\n}\r\nstatic void aun_tx_ack(unsigned long seq, int result)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nstruct ec_cb *eb;\r\nspin_lock_irqsave(&aun_queue_lock, flags);\r\nskb_queue_walk(&aun_queue, skb) {\r\neb = (struct ec_cb *)&skb->cb;\r\nif (eb->seq == seq)\r\ngoto foundit;\r\n}\r\nspin_unlock_irqrestore(&aun_queue_lock, flags);\r\npr_debug("AUN: unknown sequence %ld\n", seq);\r\nreturn;\r\nfoundit:\r\ntx_result(skb->sk, eb->cookie, result);\r\nskb_unlink(skb, &aun_queue);\r\nspin_unlock_irqrestore(&aun_queue_lock, flags);\r\nkfree_skb(skb);\r\n}\r\nstatic void aun_data_available(struct sock *sk, int slen)\r\n{\r\nint err;\r\nstruct sk_buff *skb;\r\nunsigned char *data;\r\nstruct aunhdr *ah;\r\nsize_t len;\r\nwhile ((skb = skb_recv_datagram(sk, 0, 1, &err)) == NULL) {\r\nif (err == -EAGAIN) {\r\npr_err("AUN: no data available?!\n");\r\nreturn;\r\n}\r\npr_debug("AUN: recvfrom() error %d\n", -err);\r\n}\r\ndata = skb_transport_header(skb) + sizeof(struct udphdr);\r\nah = (struct aunhdr *)data;\r\nlen = skb->len - sizeof(struct udphdr);\r\nswitch (ah->code) {\r\ncase 2:\r\naun_incoming(skb, ah, len);\r\nbreak;\r\ncase 3:\r\naun_tx_ack(ah->handle, ECTYPE_TRANSMIT_OK);\r\nbreak;\r\ncase 4:\r\naun_tx_ack(ah->handle, ECTYPE_TRANSMIT_NOT_LISTENING);\r\nbreak;\r\ndefault:\r\npr_debug("AUN: unknown packet type: %d\n", data[0]);\r\n}\r\nskb_free_datagram(sk, skb);\r\n}\r\nstatic void ab_cleanup(unsigned long h)\r\n{\r\nstruct sk_buff *skb, *n;\r\nunsigned long flags;\r\nspin_lock_irqsave(&aun_queue_lock, flags);\r\nskb_queue_walk_safe(&aun_queue, skb, n) {\r\nstruct ec_cb *eb = (struct ec_cb *)&skb->cb;\r\nif ((jiffies - eb->start) > eb->timeout) {\r\ntx_result(skb->sk, eb->cookie,\r\nECTYPE_TRANSMIT_NOT_PRESENT);\r\nskb_unlink(skb, &aun_queue);\r\nkfree_skb(skb);\r\n}\r\n}\r\nspin_unlock_irqrestore(&aun_queue_lock, flags);\r\nmod_timer(&ab_cleanup_timer, jiffies + (HZ * 2));\r\n}\r\nstatic int __init aun_udp_initialise(void)\r\n{\r\nint error;\r\nstruct sockaddr_in sin;\r\nskb_queue_head_init(&aun_queue);\r\nsetup_timer(&ab_cleanup_timer, ab_cleanup, 0);\r\nab_cleanup_timer.expires = jiffies + (HZ * 2);\r\nadd_timer(&ab_cleanup_timer);\r\nmemset(&sin, 0, sizeof(sin));\r\nsin.sin_port = htons(AUN_PORT);\r\nerror = sock_create_kern(PF_INET, SOCK_DGRAM, 0, &udpsock);\r\nif (error < 0) {\r\npr_err("AUN: socket error %d\n", -error);\r\nreturn error;\r\n}\r\nudpsock->sk->sk_reuse = 1;\r\nudpsock->sk->sk_allocation = GFP_ATOMIC;\r\nerror = udpsock->ops->bind(udpsock, (struct sockaddr *)&sin,\r\nsizeof(sin));\r\nif (error < 0) {\r\npr_err("AUN: bind error %d\n", -error);\r\ngoto release;\r\n}\r\nudpsock->sk->sk_data_ready = aun_data_available;\r\nreturn 0;\r\nrelease:\r\nsock_release(udpsock);\r\nudpsock = NULL;\r\nreturn error;\r\n}\r\nstatic int econet_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct ec_framehdr *hdr;\r\nstruct sock *sk = NULL;\r\nstruct ec_device *edev = dev->ec_ptr;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nif (skb->pkt_type == PACKET_OTHERHOST)\r\ngoto drop;\r\nif (!edev)\r\ngoto drop;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn NET_RX_DROP;\r\nif (!pskb_may_pull(skb, sizeof(struct ec_framehdr)))\r\ngoto drop;\r\nhdr = (struct ec_framehdr *)skb->data;\r\nif (hdr->port == EC_PORT_IP) {\r\nskb->protocol = htons(ETH_P_IP);\r\nskb_pull(skb, sizeof(struct ec_framehdr));\r\nnetif_rx(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nsk = ec_listening_socket(hdr->port, hdr->src_stn, hdr->src_net);\r\nif (!sk)\r\ngoto drop;\r\nif (ec_queue_packet(sk, skb, edev->net, hdr->src_stn, hdr->cb,\r\nhdr->port))\r\ngoto drop;\r\nsock_put(sk);\r\nreturn NET_RX_SUCCESS;\r\ndrop:\r\nif (sk)\r\nsock_put(sk);\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic void econet_hw_initialise(void)\r\n{\r\ndev_add_pack(&econet_packet_type);\r\n}\r\nstatic int econet_notifier(struct notifier_block *this, unsigned long msg,\r\nvoid *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct ec_device *edev;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nswitch (msg) {\r\ncase NETDEV_UNREGISTER:\r\nedev = dev->ec_ptr;\r\nif (edev) {\r\nif (net2dev_map[0] == dev)\r\nnet2dev_map[0] = NULL;\r\nnet2dev_map[edev->net] = NULL;\r\nkfree(edev);\r\ndev->ec_ptr = NULL;\r\n}\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __exit econet_proto_exit(void)\r\n{\r\n#ifdef CONFIG_ECONET_AUNUDP\r\ndel_timer(&ab_cleanup_timer);\r\nif (udpsock)\r\nsock_release(udpsock);\r\n#endif\r\nunregister_netdevice_notifier(&econet_netdev_notifier);\r\n#ifdef CONFIG_ECONET_NATIVE\r\ndev_remove_pack(&econet_packet_type);\r\n#endif\r\nsock_unregister(econet_family_ops.family);\r\nproto_unregister(&econet_proto);\r\n}\r\nstatic int __init econet_proto_init(void)\r\n{\r\nint err = proto_register(&econet_proto, 0);\r\nif (err != 0)\r\ngoto out;\r\nsock_register(&econet_family_ops);\r\n#ifdef CONFIG_ECONET_AUNUDP\r\naun_udp_initialise();\r\n#endif\r\n#ifdef CONFIG_ECONET_NATIVE\r\neconet_hw_initialise();\r\n#endif\r\nregister_netdevice_notifier(&econet_netdev_notifier);\r\nout:\r\nreturn err;\r\n}
