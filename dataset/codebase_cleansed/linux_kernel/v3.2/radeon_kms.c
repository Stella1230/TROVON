int radeon_driver_unload_kms(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (rdev == NULL)\r\nreturn 0;\r\nradeon_modeset_fini(rdev);\r\nradeon_device_fini(rdev);\r\nkfree(rdev);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nint radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct radeon_device *rdev;\r\nint r, acpi_status;\r\nrdev = kzalloc(sizeof(struct radeon_device), GFP_KERNEL);\r\nif (rdev == NULL) {\r\nreturn -ENOMEM;\r\n}\r\ndev->dev_private = (void *)rdev;\r\nif (drm_pci_device_is_agp(dev)) {\r\nflags |= RADEON_IS_AGP;\r\n} else if (pci_is_pcie(dev->pdev)) {\r\nflags |= RADEON_IS_PCIE;\r\n} else {\r\nflags |= RADEON_IS_PCI;\r\n}\r\nr = radeon_device_init(rdev, dev, dev->pdev, flags);\r\nif (r) {\r\ndev_err(&dev->pdev->dev, "Fatal error during GPU init\n");\r\ngoto out;\r\n}\r\nacpi_status = radeon_acpi_init(rdev);\r\nif (acpi_status)\r\ndev_dbg(&dev->pdev->dev, "Error during ACPI methods call\n");\r\nr = radeon_modeset_init(rdev);\r\nif (r)\r\ndev_err(&dev->pdev->dev, "Fatal error during modeset init\n");\r\nout:\r\nif (r)\r\nradeon_driver_unload_kms(dev);\r\nreturn r;\r\n}\r\nstatic void radeon_set_filp_rights(struct drm_device *dev,\r\nstruct drm_file **owner,\r\nstruct drm_file *applier,\r\nuint32_t *value)\r\n{\r\nmutex_lock(&dev->struct_mutex);\r\nif (*value == 1) {\r\nif (!*owner)\r\n*owner = applier;\r\n} else if (*value == 0) {\r\nif (*owner == applier)\r\n*owner = NULL;\r\n}\r\n*value = *owner == applier ? 1 : 0;\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nint radeon_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_radeon_info *info;\r\nstruct radeon_mode_info *minfo = &rdev->mode_info;\r\nuint32_t *value_ptr;\r\nuint32_t value;\r\nstruct drm_crtc *crtc;\r\nint i, found;\r\ninfo = data;\r\nvalue_ptr = (uint32_t *)((unsigned long)info->value);\r\nif (DRM_COPY_FROM_USER(&value, value_ptr, sizeof(value)))\r\nreturn -EFAULT;\r\nswitch (info->request) {\r\ncase RADEON_INFO_DEVICE_ID:\r\nvalue = dev->pci_device;\r\nbreak;\r\ncase RADEON_INFO_NUM_GB_PIPES:\r\nvalue = rdev->num_gb_pipes;\r\nbreak;\r\ncase RADEON_INFO_NUM_Z_PIPES:\r\nvalue = rdev->num_z_pipes;\r\nbreak;\r\ncase RADEON_INFO_ACCEL_WORKING:\r\nif ((rdev->family >= CHIP_CEDAR) && (rdev->family <= CHIP_HEMLOCK))\r\nvalue = false;\r\nelse\r\nvalue = rdev->accel_working;\r\nbreak;\r\ncase RADEON_INFO_CRTC_FROM_ID:\r\nfor (i = 0, found = 0; i < rdev->num_crtc; i++) {\r\ncrtc = (struct drm_crtc *)minfo->crtcs[i];\r\nif (crtc && crtc->base.id == value) {\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nvalue = radeon_crtc->crtc_id;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nDRM_DEBUG_KMS("unknown crtc id %d\n", value);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_ACCEL_WORKING2:\r\nvalue = rdev->accel_working;\r\nbreak;\r\ncase RADEON_INFO_TILING_CONFIG:\r\nif (rdev->family >= CHIP_CAYMAN)\r\nvalue = rdev->config.cayman.tile_config;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\nvalue = rdev->config.evergreen.tile_config;\r\nelse if (rdev->family >= CHIP_RV770)\r\nvalue = rdev->config.rv770.tile_config;\r\nelse if (rdev->family >= CHIP_R600)\r\nvalue = rdev->config.r600.tile_config;\r\nelse {\r\nDRM_DEBUG_KMS("tiling config is r6xx+ only!\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_WANT_HYPERZ:\r\nif (value >= 2) {\r\nDRM_DEBUG_KMS("WANT_HYPERZ: invalid value %d\n", value);\r\nreturn -EINVAL;\r\n}\r\nradeon_set_filp_rights(dev, &rdev->hyperz_filp, filp, &value);\r\nbreak;\r\ncase RADEON_INFO_WANT_CMASK:\r\nif (value >= 2) {\r\nDRM_DEBUG_KMS("WANT_CMASK: invalid value %d\n", value);\r\nreturn -EINVAL;\r\n}\r\nradeon_set_filp_rights(dev, &rdev->cmask_filp, filp, &value);\r\nbreak;\r\ncase RADEON_INFO_CLOCK_CRYSTAL_FREQ:\r\nvalue = rdev->clock.spll.reference_freq * 10;\r\nbreak;\r\ncase RADEON_INFO_NUM_BACKENDS:\r\nif (rdev->family >= CHIP_CAYMAN)\r\nvalue = rdev->config.cayman.max_backends_per_se *\r\nrdev->config.cayman.max_shader_engines;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\nvalue = rdev->config.evergreen.max_backends;\r\nelse if (rdev->family >= CHIP_RV770)\r\nvalue = rdev->config.rv770.max_backends;\r\nelse if (rdev->family >= CHIP_R600)\r\nvalue = rdev->config.r600.max_backends;\r\nelse {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_NUM_TILE_PIPES:\r\nif (rdev->family >= CHIP_CAYMAN)\r\nvalue = rdev->config.cayman.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\nvalue = rdev->config.evergreen.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_RV770)\r\nvalue = rdev->config.rv770.max_tile_pipes;\r\nelse if (rdev->family >= CHIP_R600)\r\nvalue = rdev->config.r600.max_tile_pipes;\r\nelse {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_INFO_FUSION_GART_WORKING:\r\nvalue = 1;\r\nbreak;\r\ncase RADEON_INFO_BACKEND_MAP:\r\nif (rdev->family >= CHIP_CAYMAN)\r\nvalue = rdev->config.cayman.backend_map;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\nvalue = rdev->config.evergreen.backend_map;\r\nelse if (rdev->family >= CHIP_RV770)\r\nvalue = rdev->config.rv770.backend_map;\r\nelse if (rdev->family >= CHIP_R600)\r\nvalue = rdev->config.r600.backend_map;\r\nelse {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("Invalid request %d\n", info->request);\r\nreturn -EINVAL;\r\n}\r\nif (DRM_COPY_TO_USER(value_ptr, &value, sizeof(uint32_t))) {\r\nDRM_ERROR("copy_to_user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_driver_firstopen_kms(struct drm_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nvoid radeon_driver_lastclose_kms(struct drm_device *dev)\r\n{\r\nvga_switcheroo_process_delayed_switch();\r\n}\r\nint radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nreturn 0;\r\n}\r\nvoid radeon_driver_postclose_kms(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\n}\r\nvoid radeon_driver_preclose_kms(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (rdev->hyperz_filp == file_priv)\r\nrdev->hyperz_filp = NULL;\r\nif (rdev->cmask_filp == file_priv)\r\nrdev->cmask_filp = NULL;\r\n}\r\nu32 radeon_get_vblank_counter_kms(struct drm_device *dev, int crtc)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (crtc < 0 || crtc >= rdev->num_crtc) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn -EINVAL;\r\n}\r\nreturn radeon_get_vblank_counter(rdev, crtc);\r\n}\r\nint radeon_enable_vblank_kms(struct drm_device *dev, int crtc)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (crtc < 0 || crtc >= rdev->num_crtc) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn -EINVAL;\r\n}\r\nrdev->irq.crtc_vblank_int[crtc] = true;\r\nreturn radeon_irq_set(rdev);\r\n}\r\nvoid radeon_disable_vblank_kms(struct drm_device *dev, int crtc)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (crtc < 0 || crtc >= rdev->num_crtc) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn;\r\n}\r\nrdev->irq.crtc_vblank_int[crtc] = false;\r\nradeon_irq_set(rdev);\r\n}\r\nint radeon_get_vblank_timestamp_kms(struct drm_device *dev, int crtc,\r\nint *max_error,\r\nstruct timeval *vblank_time,\r\nunsigned flags)\r\n{\r\nstruct drm_crtc *drmcrtc;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (crtc < 0 || crtc >= dev->num_crtcs) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn -EINVAL;\r\n}\r\ndrmcrtc = &rdev->mode_info.crtcs[crtc]->base;\r\nreturn drm_calc_vbltimestamp_from_scanoutpos(dev, crtc, max_error,\r\nvblank_time, flags,\r\ndrmcrtc);\r\n}\r\nint radeon_dma_ioctl_kms(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn -EINVAL;\r\n}
