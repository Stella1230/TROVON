static void bgpio_write8(void __iomem *reg, unsigned long data)\r\n{\r\nwriteb(data, reg);\r\n}\r\nstatic unsigned long bgpio_read8(void __iomem *reg)\r\n{\r\nreturn readb(reg);\r\n}\r\nstatic void bgpio_write16(void __iomem *reg, unsigned long data)\r\n{\r\nwritew(data, reg);\r\n}\r\nstatic unsigned long bgpio_read16(void __iomem *reg)\r\n{\r\nreturn readw(reg);\r\n}\r\nstatic void bgpio_write32(void __iomem *reg, unsigned long data)\r\n{\r\nwritel(data, reg);\r\n}\r\nstatic unsigned long bgpio_read32(void __iomem *reg)\r\n{\r\nreturn readl(reg);\r\n}\r\nstatic void bgpio_write64(void __iomem *reg, unsigned long data)\r\n{\r\nwriteq(data, reg);\r\n}\r\nstatic unsigned long bgpio_read64(void __iomem *reg)\r\n{\r\nreturn readq(reg);\r\n}\r\nstatic unsigned long bgpio_pin2mask(struct bgpio_chip *bgc, unsigned int pin)\r\n{\r\nreturn 1 << pin;\r\n}\r\nstatic unsigned long bgpio_pin2mask_be(struct bgpio_chip *bgc,\r\nunsigned int pin)\r\n{\r\nreturn 1 << (bgc->bits - 1 - pin);\r\n}\r\nstatic int bgpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nreturn bgc->read_reg(bgc->reg_dat) & bgc->pin2mask(bgc, gpio);\r\n}\r\nstatic void bgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nunsigned long mask = bgc->pin2mask(bgc, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nif (val)\r\nbgc->data |= mask;\r\nelse\r\nbgc->data &= ~mask;\r\nbgc->write_reg(bgc->reg_dat, bgc->data);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\n}\r\nstatic void bgpio_set_with_clear(struct gpio_chip *gc, unsigned int gpio,\r\nint val)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nunsigned long mask = bgc->pin2mask(bgc, gpio);\r\nif (val)\r\nbgc->write_reg(bgc->reg_set, mask);\r\nelse\r\nbgc->write_reg(bgc->reg_clr, mask);\r\n}\r\nstatic void bgpio_set_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nunsigned long mask = bgc->pin2mask(bgc, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nif (val)\r\nbgc->data |= mask;\r\nelse\r\nbgc->data &= ~mask;\r\nbgc->write_reg(bgc->reg_set, bgc->data);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\n}\r\nstatic int bgpio_simple_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bgpio_simple_dir_out(struct gpio_chip *gc, unsigned int gpio,\r\nint val)\r\n{\r\ngc->set(gc, gpio, val);\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nbgc->dir &= ~bgc->pin2mask(bgc, gpio);\r\nbgc->write_reg(bgc->reg_dir, bgc->dir);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nunsigned long flags;\r\ngc->set(gc, gpio, val);\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nbgc->dir |= bgc->pin2mask(bgc, gpio);\r\nbgc->write_reg(bgc->reg_dir, bgc->dir);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_in_inv(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nbgc->dir |= bgc->pin2mask(bgc, gpio);\r\nbgc->write_reg(bgc->reg_dir, bgc->dir);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_out_inv(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nunsigned long flags;\r\ngc->set(gc, gpio, val);\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nbgc->dir &= ~bgc->pin2mask(bgc, gpio);\r\nbgc->write_reg(bgc->reg_dir, bgc->dir);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_setup_accessors(struct device *dev,\r\nstruct bgpio_chip *bgc,\r\nbool be)\r\n{\r\nswitch (bgc->bits) {\r\ncase 8:\r\nbgc->read_reg = bgpio_read8;\r\nbgc->write_reg = bgpio_write8;\r\nbreak;\r\ncase 16:\r\nbgc->read_reg = bgpio_read16;\r\nbgc->write_reg = bgpio_write16;\r\nbreak;\r\ncase 32:\r\nbgc->read_reg = bgpio_read32;\r\nbgc->write_reg = bgpio_write32;\r\nbreak;\r\n#if BITS_PER_LONG >= 64\r\ncase 64:\r\nbgc->read_reg = bgpio_read64;\r\nbgc->write_reg = bgpio_write64;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(dev, "unsupported data width %u bits\n", bgc->bits);\r\nreturn -EINVAL;\r\n}\r\nbgc->pin2mask = be ? bgpio_pin2mask_be : bgpio_pin2mask;\r\nreturn 0;\r\n}\r\nstatic int bgpio_setup_io(struct bgpio_chip *bgc,\r\nvoid __iomem *dat,\r\nvoid __iomem *set,\r\nvoid __iomem *clr)\r\n{\r\nbgc->reg_dat = dat;\r\nif (!bgc->reg_dat)\r\nreturn -EINVAL;\r\nif (set && clr) {\r\nbgc->reg_set = set;\r\nbgc->reg_clr = clr;\r\nbgc->gc.set = bgpio_set_with_clear;\r\n} else if (set && !clr) {\r\nbgc->reg_set = set;\r\nbgc->gc.set = bgpio_set_set;\r\n} else {\r\nbgc->gc.set = bgpio_set;\r\n}\r\nbgc->gc.get = bgpio_get;\r\nreturn 0;\r\n}\r\nstatic int bgpio_setup_direction(struct bgpio_chip *bgc,\r\nvoid __iomem *dirout,\r\nvoid __iomem *dirin)\r\n{\r\nif (dirout && dirin) {\r\nreturn -EINVAL;\r\n} else if (dirout) {\r\nbgc->reg_dir = dirout;\r\nbgc->gc.direction_output = bgpio_dir_out;\r\nbgc->gc.direction_input = bgpio_dir_in;\r\n} else if (dirin) {\r\nbgc->reg_dir = dirin;\r\nbgc->gc.direction_output = bgpio_dir_out_inv;\r\nbgc->gc.direction_input = bgpio_dir_in_inv;\r\n} else {\r\nbgc->gc.direction_output = bgpio_simple_dir_out;\r\nbgc->gc.direction_input = bgpio_simple_dir_in;\r\n}\r\nreturn 0;\r\n}\r\nint bgpio_remove(struct bgpio_chip *bgc)\r\n{\r\nint err = gpiochip_remove(&bgc->gc);\r\nkfree(bgc);\r\nreturn err;\r\n}\r\nint bgpio_init(struct bgpio_chip *bgc, struct device *dev,\r\nunsigned long sz, void __iomem *dat, void __iomem *set,\r\nvoid __iomem *clr, void __iomem *dirout, void __iomem *dirin,\r\nbool big_endian)\r\n{\r\nint ret;\r\nif (!is_power_of_2(sz))\r\nreturn -EINVAL;\r\nbgc->bits = sz * 8;\r\nif (bgc->bits > BITS_PER_LONG)\r\nreturn -EINVAL;\r\nspin_lock_init(&bgc->lock);\r\nbgc->gc.dev = dev;\r\nbgc->gc.label = dev_name(dev);\r\nbgc->gc.base = -1;\r\nbgc->gc.ngpio = bgc->bits;\r\nret = bgpio_setup_io(bgc, dat, set, clr);\r\nif (ret)\r\nreturn ret;\r\nret = bgpio_setup_accessors(dev, bgc, big_endian);\r\nif (ret)\r\nreturn ret;\r\nret = bgpio_setup_direction(bgc, dirout, dirin);\r\nif (ret)\r\nreturn ret;\r\nbgc->data = bgc->read_reg(bgc->reg_dat);\r\nreturn ret;\r\n}\r\nstatic void __iomem *bgpio_map(struct platform_device *pdev,\r\nconst char *name,\r\nresource_size_t sane_sz,\r\nint *err)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *r;\r\nresource_size_t start;\r\nresource_size_t sz;\r\nvoid __iomem *ret;\r\n*err = 0;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\r\nif (!r)\r\nreturn NULL;\r\nsz = resource_size(r);\r\nif (sz != sane_sz) {\r\n*err = -EINVAL;\r\nreturn NULL;\r\n}\r\nstart = r->start;\r\nif (!devm_request_mem_region(dev, start, sz, r->name)) {\r\n*err = -EBUSY;\r\nreturn NULL;\r\n}\r\nret = devm_ioremap(dev, start, sz);\r\nif (!ret) {\r\n*err = -ENOMEM;\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit bgpio_pdev_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *r;\r\nvoid __iomem *dat;\r\nvoid __iomem *set;\r\nvoid __iomem *clr;\r\nvoid __iomem *dirout;\r\nvoid __iomem *dirin;\r\nunsigned long sz;\r\nbool be;\r\nint err;\r\nstruct bgpio_chip *bgc;\r\nstruct bgpio_pdata *pdata = dev_get_platdata(dev);\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");\r\nif (!r)\r\nreturn -EINVAL;\r\nsz = resource_size(r);\r\ndat = bgpio_map(pdev, "dat", sz, &err);\r\nif (!dat)\r\nreturn err ? err : -EINVAL;\r\nset = bgpio_map(pdev, "set", sz, &err);\r\nif (err)\r\nreturn err;\r\nclr = bgpio_map(pdev, "clr", sz, &err);\r\nif (err)\r\nreturn err;\r\ndirout = bgpio_map(pdev, "dirout", sz, &err);\r\nif (err)\r\nreturn err;\r\ndirin = bgpio_map(pdev, "dirin", sz, &err);\r\nif (err)\r\nreturn err;\r\nbe = !strcmp(platform_get_device_id(pdev)->name, "basic-mmio-gpio-be");\r\nbgc = devm_kzalloc(&pdev->dev, sizeof(*bgc), GFP_KERNEL);\r\nif (!bgc)\r\nreturn -ENOMEM;\r\nerr = bgpio_init(bgc, dev, sz, dat, set, clr, dirout, dirin, be);\r\nif (err)\r\nreturn err;\r\nif (pdata) {\r\nbgc->gc.base = pdata->base;\r\nif (pdata->ngpio > 0)\r\nbgc->gc.ngpio = pdata->ngpio;\r\n}\r\nplatform_set_drvdata(pdev, bgc);\r\nreturn gpiochip_add(&bgc->gc);\r\n}\r\nstatic int __devexit bgpio_pdev_remove(struct platform_device *pdev)\r\n{\r\nstruct bgpio_chip *bgc = platform_get_drvdata(pdev);\r\nreturn bgpio_remove(bgc);\r\n}\r\nstatic int __init bgpio_platform_init(void)\r\n{\r\nreturn platform_driver_register(&bgpio_driver);\r\n}\r\nstatic void __exit bgpio_platform_exit(void)\r\n{\r\nplatform_driver_unregister(&bgpio_driver);\r\n}
