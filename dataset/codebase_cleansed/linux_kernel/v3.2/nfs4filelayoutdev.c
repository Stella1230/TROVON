void\r\nprint_ds(struct nfs4_pnfs_ds *ds)\r\n{\r\nif (ds == NULL) {\r\nprintk("%s NULL device\n", __func__);\r\nreturn;\r\n}\r\nprintk(" ds %s\n"\r\n" ref count %d\n"\r\n" client %p\n"\r\n" cl_exchange_flags %x\n",\r\nds->ds_remotestr,\r\natomic_read(&ds->ds_count), ds->ds_clp,\r\nds->ds_clp ? ds->ds_clp->cl_exchange_flags : 0);\r\n}\r\nstatic bool\r\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\r\n{\r\nstruct sockaddr_in *a, *b;\r\nstruct sockaddr_in6 *a6, *b6;\r\nif (addr1->sa_family != addr2->sa_family)\r\nreturn false;\r\nswitch (addr1->sa_family) {\r\ncase AF_INET:\r\na = (struct sockaddr_in *)addr1;\r\nb = (struct sockaddr_in *)addr2;\r\nif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\r\na->sin_port == b->sin_port)\r\nreturn true;\r\nbreak;\r\ncase AF_INET6:\r\na6 = (struct sockaddr_in6 *)addr1;\r\nb6 = (struct sockaddr_in6 *)addr2;\r\nif (ipv6_addr_scope(&a6->sin6_addr) ==\r\nIPV6_ADDR_SCOPE_LINKLOCAL &&\r\na6->sin6_scope_id != b6->sin6_scope_id)\r\nreturn false;\r\nif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\r\na6->sin6_port == b6->sin6_port)\r\nreturn true;\r\nbreak;\r\ndefault:\r\ndprintk("%s: unhandled address family: %u\n",\r\n__func__, addr1->sa_family);\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic struct nfs4_pnfs_ds *\r\n_data_server_lookup_locked(struct list_head *dsaddrs)\r\n{\r\nstruct nfs4_pnfs_ds *ds;\r\nstruct nfs4_pnfs_ds_addr *da1, *da2;\r\nlist_for_each_entry(da1, dsaddrs, da_node) {\r\nlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node) {\r\nlist_for_each_entry(da2, &ds->ds_addrs, da_node) {\r\nif (same_sockaddr(\r\n(struct sockaddr *)&da1->da_addr,\r\n(struct sockaddr *)&da2->da_addr))\r\nreturn ds;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool\r\n_data_server_match_all_addrs_locked(struct list_head *dsaddrs1,\r\nstruct list_head *dsaddrs2)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da1, *da2;\r\nsize_t count1 = 0,\r\ncount2 = 0;\r\nlist_for_each_entry(da1, dsaddrs1, da_node)\r\ncount1++;\r\nlist_for_each_entry(da2, dsaddrs2, da_node) {\r\nbool found = false;\r\ncount2++;\r\nlist_for_each_entry(da1, dsaddrs1, da_node) {\r\nif (same_sockaddr((struct sockaddr *)&da1->da_addr,\r\n(struct sockaddr *)&da2->da_addr)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn false;\r\n}\r\nreturn (count1 == count2);\r\n}\r\nstatic int\r\nnfs4_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds)\r\n{\r\nstruct nfs_client *clp = ERR_PTR(-EIO);\r\nstruct nfs4_pnfs_ds_addr *da;\r\nint status = 0;\r\ndprintk("--> %s DS %s au_flavor %d\n", __func__, ds->ds_remotestr,\r\nmds_srv->nfs_client->cl_rpcclient->cl_auth->au_flavor);\r\nBUG_ON(list_empty(&ds->ds_addrs));\r\nlist_for_each_entry(da, &ds->ds_addrs, da_node) {\r\ndprintk("%s: DS %s: trying address %s\n",\r\n__func__, ds->ds_remotestr, da->da_remotestr);\r\nclp = nfs4_set_ds_client(mds_srv->nfs_client,\r\n(struct sockaddr *)&da->da_addr,\r\nda->da_addrlen, IPPROTO_TCP);\r\nif (!IS_ERR(clp))\r\nbreak;\r\n}\r\nif (IS_ERR(clp)) {\r\nstatus = PTR_ERR(clp);\r\ngoto out;\r\n}\r\nif ((clp->cl_exchange_flags & EXCHGID4_FLAG_MASK_PNFS) != 0) {\r\nif (!is_ds_client(clp)) {\r\nstatus = -ENODEV;\r\ngoto out_put;\r\n}\r\nds->ds_clp = clp;\r\ndprintk("%s [existing] server=%s\n", __func__,\r\nds->ds_remotestr);\r\ngoto out;\r\n}\r\nspin_lock(&mds_srv->nfs_client->cl_lock);\r\nclp->cl_lease_time = mds_srv->nfs_client->cl_lease_time;\r\nspin_unlock(&mds_srv->nfs_client->cl_lock);\r\nclp->cl_last_renewal = jiffies;\r\nstatus = nfs4_init_ds_session(clp);\r\nif (status)\r\ngoto out_put;\r\nds->ds_clp = clp;\r\ndprintk("%s [new] addr: %s\n", __func__, ds->ds_remotestr);\r\nout:\r\nreturn status;\r\nout_put:\r\nnfs_put_client(clp);\r\ngoto out;\r\n}\r\nstatic void\r\ndestroy_ds(struct nfs4_pnfs_ds *ds)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da;\r\ndprintk("--> %s\n", __func__);\r\nifdebug(FACILITY)\r\nprint_ds(ds);\r\nif (ds->ds_clp)\r\nnfs_put_client(ds->ds_clp);\r\nwhile (!list_empty(&ds->ds_addrs)) {\r\nda = list_first_entry(&ds->ds_addrs,\r\nstruct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\nkfree(ds->ds_remotestr);\r\nkfree(ds);\r\n}\r\nvoid\r\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\r\n{\r\nstruct nfs4_pnfs_ds *ds;\r\nint i;\r\nnfs4_print_deviceid(&dsaddr->id_node.deviceid);\r\nfor (i = 0; i < dsaddr->ds_num; i++) {\r\nds = dsaddr->ds_list[i];\r\nif (ds != NULL) {\r\nif (atomic_dec_and_lock(&ds->ds_count,\r\n&nfs4_ds_cache_lock)) {\r\nlist_del_init(&ds->ds_node);\r\nspin_unlock(&nfs4_ds_cache_lock);\r\ndestroy_ds(ds);\r\n}\r\n}\r\n}\r\nkfree(dsaddr->stripe_indices);\r\nkfree(dsaddr);\r\n}\r\nstatic char *\r\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da;\r\nchar *remotestr;\r\nsize_t len;\r\nchar *p;\r\nlen = 3;\r\nlist_for_each_entry(da, dsaddrs, da_node) {\r\nlen += strlen(da->da_remotestr) + 1;\r\n}\r\nremotestr = kzalloc(len, gfp_flags);\r\nif (!remotestr)\r\nreturn NULL;\r\np = remotestr;\r\n*(p++) = '{';\r\nlen--;\r\nlist_for_each_entry(da, dsaddrs, da_node) {\r\nsize_t ll = strlen(da->da_remotestr);\r\nif (ll > len)\r\ngoto out_err;\r\nmemcpy(p, da->da_remotestr, ll);\r\np += ll;\r\nlen -= ll;\r\nif (len < 1)\r\ngoto out_err;\r\n(*p++) = ',';\r\nlen--;\r\n}\r\nif (len < 2)\r\ngoto out_err;\r\n*(p++) = '}';\r\n*p = '\0';\r\nreturn remotestr;\r\nout_err:\r\nkfree(remotestr);\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_pnfs_ds *\r\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\r\nchar *remotestr;\r\nif (list_empty(dsaddrs)) {\r\ndprintk("%s: no addresses defined\n", __func__);\r\ngoto out;\r\n}\r\nds = kzalloc(sizeof(*ds), gfp_flags);\r\nif (!ds)\r\ngoto out;\r\nremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\r\nspin_lock(&nfs4_ds_cache_lock);\r\ntmp_ds = _data_server_lookup_locked(dsaddrs);\r\nif (tmp_ds == NULL) {\r\nINIT_LIST_HEAD(&ds->ds_addrs);\r\nlist_splice_init(dsaddrs, &ds->ds_addrs);\r\nds->ds_remotestr = remotestr;\r\natomic_set(&ds->ds_count, 1);\r\nINIT_LIST_HEAD(&ds->ds_node);\r\nds->ds_clp = NULL;\r\nlist_add(&ds->ds_node, &nfs4_data_server_cache);\r\ndprintk("%s add new data server %s\n", __func__,\r\nds->ds_remotestr);\r\n} else {\r\nif (!_data_server_match_all_addrs_locked(&tmp_ds->ds_addrs,\r\ndsaddrs)) {\r\ndprintk("%s: multipath address mismatch: %s != %s",\r\n__func__, tmp_ds->ds_remotestr, remotestr);\r\n}\r\nkfree(remotestr);\r\nkfree(ds);\r\natomic_inc(&tmp_ds->ds_count);\r\ndprintk("%s data server %s found, inc'ed ds_count to %d\n",\r\n__func__, tmp_ds->ds_remotestr,\r\natomic_read(&tmp_ds->ds_count));\r\nds = tmp_ds;\r\n}\r\nspin_unlock(&nfs4_ds_cache_lock);\r\nout:\r\nreturn ds;\r\n}\r\nstatic struct nfs4_pnfs_ds_addr *\r\ndecode_ds_addr(struct xdr_stream *streamp, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da = NULL;\r\nchar *buf, *portstr;\r\nu32 port;\r\nint nlen, rlen;\r\nint tmp[2];\r\n__be32 *p;\r\nchar *netid, *match_netid;\r\nsize_t len, match_netid_len;\r\nchar *startsep = "";\r\nchar *endsep = "";\r\np = xdr_inline_decode(streamp, 4);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nnlen = be32_to_cpup(p++);\r\np = xdr_inline_decode(streamp, nlen);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nnetid = kmalloc(nlen+1, gfp_flags);\r\nif (unlikely(!netid))\r\ngoto out_err;\r\nnetid[nlen] = '\0';\r\nmemcpy(netid, p, nlen);\r\np = xdr_inline_decode(streamp, 4);\r\nif (unlikely(!p))\r\ngoto out_free_netid;\r\nrlen = be32_to_cpup(p);\r\np = xdr_inline_decode(streamp, rlen);\r\nif (unlikely(!p))\r\ngoto out_free_netid;\r\nif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\r\ndprintk("%s: Invalid address, length %d\n", __func__,\r\nrlen);\r\ngoto out_free_netid;\r\n}\r\nbuf = kmalloc(rlen + 1, gfp_flags);\r\nif (!buf) {\r\ndprintk("%s: Not enough memory\n", __func__);\r\ngoto out_free_netid;\r\n}\r\nbuf[rlen] = '\0';\r\nmemcpy(buf, p, rlen);\r\nportstr = strrchr(buf, '.');\r\nif (!portstr) {\r\ndprintk("%s: Failed finding expected dot in port\n",\r\n__func__);\r\ngoto out_free_buf;\r\n}\r\n*portstr = '-';\r\nportstr = strrchr(buf, '.');\r\nif (!portstr) {\r\ndprintk("%s: Failed finding expected dot between address and "\r\n"port\n", __func__);\r\ngoto out_free_buf;\r\n}\r\n*portstr = '\0';\r\nda = kzalloc(sizeof(*da), gfp_flags);\r\nif (unlikely(!da))\r\ngoto out_free_buf;\r\nINIT_LIST_HEAD(&da->da_node);\r\nif (!rpc_pton(buf, portstr-buf, (struct sockaddr *)&da->da_addr,\r\nsizeof(da->da_addr))) {\r\ndprintk("%s: error parsing address %s\n", __func__, buf);\r\ngoto out_free_da;\r\n}\r\nportstr++;\r\nsscanf(portstr, "%d-%d", &tmp[0], &tmp[1]);\r\nport = htons((tmp[0] << 8) | (tmp[1]));\r\nswitch (da->da_addr.ss_family) {\r\ncase AF_INET:\r\n((struct sockaddr_in *)&da->da_addr)->sin_port = port;\r\nda->da_addrlen = sizeof(struct sockaddr_in);\r\nmatch_netid = "tcp";\r\nmatch_netid_len = 3;\r\nbreak;\r\ncase AF_INET6:\r\n((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\r\nda->da_addrlen = sizeof(struct sockaddr_in6);\r\nmatch_netid = "tcp6";\r\nmatch_netid_len = 4;\r\nstartsep = "[";\r\nendsep = "]";\r\nbreak;\r\ndefault:\r\ndprintk("%s: unsupported address family: %u\n",\r\n__func__, da->da_addr.ss_family);\r\ngoto out_free_da;\r\n}\r\nif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\r\ndprintk("%s: ERROR: r_netid \"%s\" != \"%s\"\n",\r\n__func__, netid, match_netid);\r\ngoto out_free_da;\r\n}\r\nlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\r\nda->da_remotestr = kzalloc(len, gfp_flags);\r\nif (da->da_remotestr)\r\nsnprintf(da->da_remotestr, len, "%s%s%s:%u", startsep,\r\nbuf, endsep, ntohs(port));\r\ndprintk("%s: Parsed DS addr %s\n", __func__, da->da_remotestr);\r\nkfree(buf);\r\nkfree(netid);\r\nreturn da;\r\nout_free_da:\r\nkfree(da);\r\nout_free_buf:\r\ndprintk("%s: Error parsing DS addr: %s\n", __func__, buf);\r\nkfree(buf);\r\nout_free_netid:\r\nkfree(netid);\r\nout_err:\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_file_layout_dsaddr*\r\ndecode_device(struct inode *ino, struct pnfs_device *pdev, gfp_t gfp_flags)\r\n{\r\nint i;\r\nu32 cnt, num;\r\nu8 *indexp;\r\n__be32 *p;\r\nu8 *stripe_indices;\r\nu8 max_stripe_index;\r\nstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\r\nstruct xdr_stream stream;\r\nstruct xdr_buf buf;\r\nstruct page *scratch;\r\nstruct list_head dsaddrs;\r\nstruct nfs4_pnfs_ds_addr *da;\r\nscratch = alloc_page(gfp_flags);\r\nif (!scratch)\r\ngoto out_err;\r\nxdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\r\nxdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_scratch;\r\ncnt = be32_to_cpup(p);\r\ndprintk("%s stripe count %d\n", __func__, cnt);\r\nif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\r\nprintk(KERN_WARNING "%s: stripe count %d greater than "\r\n"supported maximum %d\n", __func__,\r\ncnt, NFS4_PNFS_MAX_STRIPE_CNT);\r\ngoto out_err_free_scratch;\r\n}\r\nstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\r\nif (!stripe_indices)\r\ngoto out_err_free_scratch;\r\np = xdr_inline_decode(&stream, cnt << 2);\r\nif (unlikely(!p))\r\ngoto out_err_free_stripe_indices;\r\nindexp = &stripe_indices[0];\r\nmax_stripe_index = 0;\r\nfor (i = 0; i < cnt; i++) {\r\n*indexp = be32_to_cpup(p++);\r\nmax_stripe_index = max(max_stripe_index, *indexp);\r\nindexp++;\r\n}\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_stripe_indices;\r\nnum = be32_to_cpup(p);\r\ndprintk("%s ds_num %u\n", __func__, num);\r\nif (num > NFS4_PNFS_MAX_MULTI_CNT) {\r\nprintk(KERN_WARNING "%s: multipath count %d greater than "\r\n"supported maximum %d\n", __func__,\r\nnum, NFS4_PNFS_MAX_MULTI_CNT);\r\ngoto out_err_free_stripe_indices;\r\n}\r\nif (max_stripe_index >= num) {\r\nprintk(KERN_WARNING "%s: stripe index %u >= num ds %u\n",\r\n__func__, max_stripe_index, num);\r\ngoto out_err_free_stripe_indices;\r\n}\r\ndsaddr = kzalloc(sizeof(*dsaddr) +\r\n(sizeof(struct nfs4_pnfs_ds *) * (num - 1)),\r\ngfp_flags);\r\nif (!dsaddr)\r\ngoto out_err_free_stripe_indices;\r\ndsaddr->stripe_count = cnt;\r\ndsaddr->stripe_indices = stripe_indices;\r\nstripe_indices = NULL;\r\ndsaddr->ds_num = num;\r\nnfs4_init_deviceid_node(&dsaddr->id_node,\r\nNFS_SERVER(ino)->pnfs_curr_ld,\r\nNFS_SERVER(ino)->nfs_client,\r\n&pdev->dev_id);\r\nINIT_LIST_HEAD(&dsaddrs);\r\nfor (i = 0; i < dsaddr->ds_num; i++) {\r\nint j;\r\nu32 mp_count;\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_deviceid;\r\nmp_count = be32_to_cpup(p);\r\nfor (j = 0; j < mp_count; j++) {\r\nda = decode_ds_addr(&stream, gfp_flags);\r\nif (da)\r\nlist_add_tail(&da->da_node, &dsaddrs);\r\n}\r\nif (list_empty(&dsaddrs)) {\r\ndprintk("%s: no suitable DS addresses found\n",\r\n__func__);\r\ngoto out_err_free_deviceid;\r\n}\r\ndsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\r\nif (!dsaddr->ds_list[i])\r\ngoto out_err_drain_dsaddrs;\r\nwhile (!list_empty(&dsaddrs)) {\r\nda = list_first_entry(&dsaddrs,\r\nstruct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\n}\r\n__free_page(scratch);\r\nreturn dsaddr;\r\nout_err_drain_dsaddrs:\r\nwhile (!list_empty(&dsaddrs)) {\r\nda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\nout_err_free_deviceid:\r\nnfs4_fl_free_deviceid(dsaddr);\r\ngoto out_err_free_scratch;\r\nout_err_free_stripe_indices:\r\nkfree(stripe_indices);\r\nout_err_free_scratch:\r\n__free_page(scratch);\r\nout_err:\r\ndprintk("%s ERROR: returning NULL\n", __func__);\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_file_layout_dsaddr *\r\ndecode_and_add_device(struct inode *inode, struct pnfs_device *dev, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_deviceid_node *d;\r\nstruct nfs4_file_layout_dsaddr *n, *new;\r\nnew = decode_device(inode, dev, gfp_flags);\r\nif (!new) {\r\nprintk(KERN_WARNING "%s: Could not decode or add device\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nd = nfs4_insert_deviceid_node(&new->id_node);\r\nn = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\r\nif (n != new) {\r\nnfs4_fl_free_deviceid(new);\r\nreturn n;\r\n}\r\nreturn new;\r\n}\r\nstruct nfs4_file_layout_dsaddr *\r\nget_device_info(struct inode *inode, struct nfs4_deviceid *dev_id, gfp_t gfp_flags)\r\n{\r\nstruct pnfs_device *pdev = NULL;\r\nu32 max_resp_sz;\r\nint max_pages;\r\nstruct page **pages = NULL;\r\nstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\r\nint rc, i;\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\r\nmax_pages = max_resp_sz >> PAGE_SHIFT;\r\ndprintk("%s inode %p max_resp_sz %u max_pages %d\n",\r\n__func__, inode, max_resp_sz, max_pages);\r\npdev = kzalloc(sizeof(struct pnfs_device), gfp_flags);\r\nif (pdev == NULL)\r\nreturn NULL;\r\npages = kzalloc(max_pages * sizeof(struct page *), gfp_flags);\r\nif (pages == NULL) {\r\nkfree(pdev);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < max_pages; i++) {\r\npages[i] = alloc_page(gfp_flags);\r\nif (!pages[i])\r\ngoto out_free;\r\n}\r\nmemcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));\r\npdev->layout_type = LAYOUT_NFSV4_1_FILES;\r\npdev->pages = pages;\r\npdev->pgbase = 0;\r\npdev->pglen = PAGE_SIZE * max_pages;\r\npdev->mincount = 0;\r\nrc = nfs4_proc_getdeviceinfo(server, pdev);\r\ndprintk("%s getdevice info returns %d\n", __func__, rc);\r\nif (rc)\r\ngoto out_free;\r\ndsaddr = decode_and_add_device(inode, pdev, gfp_flags);\r\nout_free:\r\nfor (i = 0; i < max_pages; i++)\r\n__free_page(pages[i]);\r\nkfree(pages);\r\nkfree(pdev);\r\ndprintk("<-- %s dsaddr %p\n", __func__, dsaddr);\r\nreturn dsaddr;\r\n}\r\nvoid\r\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\r\n{\r\nnfs4_put_deviceid_node(&dsaddr->id_node);\r\n}\r\nu32\r\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nu64 tmp;\r\ntmp = offset - flseg->pattern_offset;\r\ndo_div(tmp, flseg->stripe_unit);\r\ntmp += flseg->first_stripe_index;\r\nreturn do_div(tmp, flseg->dsaddr->stripe_count);\r\n}\r\nu32\r\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\r\n{\r\nreturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\r\n}\r\nstruct nfs_fh *\r\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nu32 i;\r\nif (flseg->stripe_type == STRIPE_SPARSE) {\r\nif (flseg->num_fh == 1)\r\ni = 0;\r\nelse if (flseg->num_fh == 0)\r\nreturn NULL;\r\nelse\r\ni = nfs4_fl_calc_ds_index(lseg, j);\r\n} else\r\ni = j;\r\nreturn flseg->fh_array[i];\r\n}\r\nstatic void\r\nfilelayout_mark_devid_negative(struct nfs4_file_layout_dsaddr *dsaddr,\r\nint err, const char *ds_remotestr)\r\n{\r\nu32 *p = (u32 *)&dsaddr->id_node.deviceid;\r\nprintk(KERN_ERR "NFS: data server %s connection error %d."\r\n" Deviceid [%x%x%x%x] marked out of use.\n",\r\nds_remotestr, err, p[0], p[1], p[2], p[3]);\r\nspin_lock(&nfs4_ds_cache_lock);\r\ndsaddr->flags |= NFS4_DEVICE_ID_NEG_ENTRY;\r\nspin_unlock(&nfs4_ds_cache_lock);\r\n}\r\nstruct nfs4_pnfs_ds *\r\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\r\n{\r\nstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\r\nstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\r\nif (ds == NULL) {\r\nprintk(KERN_ERR "%s: No data server for offset index %d\n",\r\n__func__, ds_idx);\r\nreturn NULL;\r\n}\r\nif (!ds->ds_clp) {\r\nstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\r\nint err;\r\nif (dsaddr->flags & NFS4_DEVICE_ID_NEG_ENTRY) {\r\ndprintk("%s Deviceid marked out of use\n", __func__);\r\nreturn NULL;\r\n}\r\nerr = nfs4_ds_connect(s, ds);\r\nif (err) {\r\nfilelayout_mark_devid_negative(dsaddr, err,\r\nds->ds_remotestr);\r\nreturn NULL;\r\n}\r\n}\r\nreturn ds;\r\n}
