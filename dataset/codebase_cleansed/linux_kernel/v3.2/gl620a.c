static int genelink_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct gl_header *header;\r\nstruct gl_packet *packet;\r\nstruct sk_buff *gl_skb;\r\nu32 size;\r\nu32 count;\r\nheader = (struct gl_header *) skb->data;\r\ncount = le32_to_cpu(header->packet_count);\r\nif (count > GL_MAX_TRANSMIT_PACKETS) {\r\ndbg("genelink: invalid received packet count %u", count);\r\nreturn 0;\r\n}\r\npacket = &header->packets;\r\nskb_pull(skb, 4);\r\nwhile (count > 1) {\r\nsize = le32_to_cpu(packet->packet_length);\r\nif (size > GL_MAX_PACKET_LEN) {\r\ndbg("genelink: invalid rx length %d", size);\r\nreturn 0;\r\n}\r\ngl_skb = alloc_skb(size, GFP_ATOMIC);\r\nif (gl_skb) {\r\nmemcpy(skb_put(gl_skb, size),\r\npacket->packet_data, size);\r\nusbnet_skb_return(dev, gl_skb);\r\n}\r\npacket = (struct gl_packet *)&packet->packet_data[size];\r\ncount--;\r\nskb_pull(skb, size + 4);\r\n}\r\nskb_pull(skb, 4);\r\nif (skb->len > GL_MAX_PACKET_LEN) {\r\ndbg("genelink: invalid rx length %d", skb->len);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *\r\ngenelink_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nint padlen;\r\nint length = skb->len;\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\n__le32 *packet_count;\r\n__le32 *packet_len;\r\npadlen = ((skb->len + (4 + 4*1)) % 64) ? 0 : 1;\r\nif ((!skb_cloned(skb))\r\n&& ((headroom + tailroom) >= (padlen + (4 + 4*1)))) {\r\nif ((headroom < (4 + 4*1)) || (tailroom < padlen)) {\r\nskb->data = memmove(skb->head + (4 + 4*1),\r\nskb->data, skb->len);\r\nskb_set_tail_pointer(skb, skb->len);\r\n}\r\n} else {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_copy_expand(skb, (4 + 4*1) , padlen, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\npacket_count = (__le32 *) skb_push(skb, (4 + 4*1));\r\npacket_len = packet_count + 1;\r\n*packet_count = cpu_to_le32(1);\r\n*packet_len = cpu_to_le32(length);\r\nif ((skb->len % dev->maxpacket) == 0)\r\nskb_put(skb, 1);\r\nreturn skb;\r\n}\r\nstatic int genelink_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\ndev->hard_mtu = GL_RCV_BUF_SIZE;\r\ndev->net->hard_header_len += 4;\r\ndev->in = usb_rcvbulkpipe(dev->udev, dev->driver_info->in);\r\ndev->out = usb_sndbulkpipe(dev->udev, dev->driver_info->out);\r\nreturn 0;\r\n}\r\nstatic int __init usbnet_init(void)\r\n{\r\nreturn usb_register(&gl620a_driver);\r\n}\r\nstatic void __exit usbnet_exit(void)\r\n{\r\nusb_deregister(&gl620a_driver);\r\n}
