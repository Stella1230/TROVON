static int _log_set_log_filter(u8 *logdefs, int size, u8 src, u8 logmask)\r\n{\r\nint i;\r\nif (src < size)\r\nlogdefs[src] = logmask;\r\nelse if (src == LOG_SRC_ALL)\r\nfor (i = 0; i < size; i++)\r\nlogdefs[i] = logmask;\r\nelse\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint iwmct_log_set_filter(u8 src, u8 logmask)\r\n{\r\nreturn _log_set_log_filter(iwmct_logdefs, LOG_SRC_MAX, src, logmask);\r\n}\r\nint iwmct_log_set_fw_filter(u8 src, u8 logmask)\r\n{\r\nreturn _log_set_log_filter(iwmct_fw_logdefs,\r\nFW_LOG_SRC_MAX, src, logmask);\r\n}\r\nstatic int log_msg_format_hex(char *str, int slen, u8 *ibuf,\r\nint ilen, char *pref)\r\n{\r\nint pos = 0;\r\nint i;\r\nint len;\r\nfor (pos = 0, i = 0; pos < slen - 2 && pref[i] != '\0'; i++, pos++)\r\nstr[pos] = pref[i];\r\nfor (i = 0; pos < slen - 2 && i < ilen; pos += len, i++)\r\nlen = snprintf(&str[pos], slen - pos - 1, " %2.2X", ibuf[i]);\r\nif (i < ilen)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid iwmct_log_top_message(struct iwmct_priv *priv, u8 *buf, int len)\r\n{\r\nstruct top_msg *msg;\r\nstatic char logbuf[LOG_MSG_SIZE_MAX];\r\nmsg = (struct top_msg *)buf;\r\nif (len < sizeof(msg->hdr) + sizeof(msg->u.log.log_hdr)) {\r\nLOG_ERROR(priv, FW_MSG, "Log message from TOP "\r\n"is too short %d (expected %zd)\n",\r\nlen, sizeof(msg->hdr) + sizeof(msg->u.log.log_hdr));\r\nreturn;\r\n}\r\nif (!(iwmct_fw_logdefs[msg->u.log.log_hdr.logsource] &\r\nBIT(msg->u.log.log_hdr.severity)) ||\r\n!(iwmct_logdefs[LOG_SRC_FW_MSG] & BIT(msg->u.log.log_hdr.severity)))\r\nreturn;\r\nswitch (msg->hdr.category) {\r\ncase COMM_CATEGORY_TESTABILITY:\r\nif (!(iwmct_logdefs[LOG_SRC_TST] &\r\nBIT(msg->u.log.log_hdr.severity)))\r\nreturn;\r\nif (log_msg_format_hex(logbuf, LOG_MSG_SIZE_MAX, buf,\r\nle16_to_cpu(msg->hdr.length) +\r\nsizeof(msg->hdr), "<TST>"))\r\nLOG_WARNING(priv, TST,\r\n"TOP TST message is too long, truncating...");\r\nLOG_WARNING(priv, TST, "%s\n", logbuf);\r\nbreak;\r\ncase COMM_CATEGORY_DEBUG:\r\nif (msg->hdr.opcode == OP_DBG_ZSTR_MSG)\r\nLOG_INFO(priv, FW_MSG, "%s %s", "<DBG>",\r\n((u8 *)msg) + sizeof(msg->hdr)\r\n+ sizeof(msg->u.log.log_hdr));\r\nelse {\r\nif (log_msg_format_hex(logbuf, LOG_MSG_SIZE_MAX, buf,\r\nle16_to_cpu(msg->hdr.length)\r\n+ sizeof(msg->hdr),\r\n"<DBG>"))\r\nLOG_WARNING(priv, FW_MSG,\r\n"TOP DBG message is too long,"\r\n"truncating...");\r\nLOG_WARNING(priv, FW_MSG, "%s\n", logbuf);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int _log_get_filter_str(u8 *logdefs, int logdefsz, char *buf, int size)\r\n{\r\nint i, pos, len;\r\nfor (i = 0, pos = 0; (pos < size-1) && (i < logdefsz); i++) {\r\nlen = snprintf(&buf[pos], size - pos - 1, "0x%02X%02X,",\r\ni, logdefs[i]);\r\npos += len;\r\n}\r\nbuf[pos-1] = '\n';\r\nbuf[pos] = '\0';\r\nif (i < logdefsz)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint log_get_filter_str(char *buf, int size)\r\n{\r\nreturn _log_get_filter_str(iwmct_logdefs, LOG_SRC_MAX, buf, size);\r\n}\r\nint log_get_fw_filter_str(char *buf, int size)\r\n{\r\nreturn _log_get_filter_str(iwmct_fw_logdefs, FW_LOG_SRC_MAX, buf, size);\r\n}\r\nssize_t show_iwmct_log_level(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iwmct_priv *priv = dev_get_drvdata(d);\r\nchar *str_buf;\r\nint buf_size;\r\nssize_t ret;\r\nbuf_size = (LOG_SRC_FORMAT * LOG_SRC_MAX) + 1;\r\nstr_buf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!str_buf) {\r\nLOG_ERROR(priv, DEBUGFS,\r\n"failed to allocate %d bytes\n", buf_size);\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nif (log_get_filter_str(str_buf, buf_size) < 0) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nret = sprintf(buf, "%s", str_buf);\r\nexit:\r\nkfree(str_buf);\r\nreturn ret;\r\n}\r\nssize_t store_iwmct_log_level(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct iwmct_priv *priv = dev_get_drvdata(d);\r\nchar *token, *str_buf = NULL;\r\nlong val;\r\nssize_t ret = count;\r\nu8 src, mask;\r\nif (!count)\r\ngoto exit;\r\nstr_buf = kzalloc(count, GFP_KERNEL);\r\nif (!str_buf) {\r\nLOG_ERROR(priv, DEBUGFS,\r\n"failed to allocate %zd bytes\n", count);\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nmemcpy(str_buf, buf, count);\r\nwhile ((token = strsep(&str_buf, ",")) != NULL) {\r\nwhile (isspace(*token))\r\n++token;\r\nif (strict_strtol(token, HEXADECIMAL_RADIX, &val)) {\r\nLOG_ERROR(priv, DEBUGFS,\r\n"failed to convert string to long %s\n",\r\ntoken);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nmask = val & 0xFF;\r\nsrc = (val & 0XFF00) >> 8;\r\niwmct_log_set_filter(src, mask);\r\n}\r\nexit:\r\nkfree(str_buf);\r\nreturn ret;\r\n}\r\nssize_t show_iwmct_log_level_fw(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iwmct_priv *priv = dev_get_drvdata(d);\r\nchar *str_buf;\r\nint buf_size;\r\nssize_t ret;\r\nbuf_size = (LOG_SRC_FORMAT * FW_LOG_SRC_MAX) + 2;\r\nstr_buf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!str_buf) {\r\nLOG_ERROR(priv, DEBUGFS,\r\n"failed to allocate %d bytes\n", buf_size);\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nif (log_get_fw_filter_str(str_buf, buf_size) < 0) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nret = sprintf(buf, "%s", str_buf);\r\nexit:\r\nkfree(str_buf);\r\nreturn ret;\r\n}\r\nssize_t store_iwmct_log_level_fw(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct iwmct_priv *priv = dev_get_drvdata(d);\r\nstruct top_msg cmd;\r\nchar *token, *str_buf = NULL;\r\nssize_t ret = count;\r\nu16 cmdlen = 0;\r\nint i;\r\nlong val;\r\nu8 src, mask;\r\nif (!count)\r\ngoto exit;\r\nstr_buf = kzalloc(count, GFP_KERNEL);\r\nif (!str_buf) {\r\nLOG_ERROR(priv, DEBUGFS,\r\n"failed to allocate %zd bytes\n", count);\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nmemcpy(str_buf, buf, count);\r\ncmd.hdr.type = COMM_TYPE_H2D;\r\ncmd.hdr.category = COMM_CATEGORY_DEBUG;\r\ncmd.hdr.opcode = CMD_DBG_LOG_LEVEL;\r\nfor (i = 0; ((token = strsep(&str_buf, ",")) != NULL) &&\r\n(i < FW_LOG_SRC_MAX); i++) {\r\nwhile (isspace(*token))\r\n++token;\r\nif (strict_strtol(token, HEXADECIMAL_RADIX, &val)) {\r\nLOG_ERROR(priv, DEBUGFS,\r\n"failed to convert string to long %s\n",\r\ntoken);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nmask = val & 0xFF;\r\nsrc = (val & 0XFF00) >> 8;\r\niwmct_log_set_fw_filter(src, mask);\r\ncmd.u.logdefs[i].logsource = src;\r\ncmd.u.logdefs[i].sevmask = mask;\r\n}\r\ncmd.hdr.length = cpu_to_le16(i * sizeof(cmd.u.logdefs[0]));\r\ncmdlen = (i * sizeof(cmd.u.logdefs[0]) + sizeof(cmd.hdr));\r\nret = iwmct_send_hcmd(priv, (u8 *)&cmd, cmdlen);\r\nif (ret) {\r\nLOG_ERROR(priv, DEBUGFS,\r\n"Failed to send %d bytes of fwcmd, ret=%zd\n",\r\ncmdlen, ret);\r\ngoto exit;\r\n} else\r\nLOG_INFO(priv, DEBUGFS, "fwcmd sent (%d bytes)\n", cmdlen);\r\nret = count;\r\nexit:\r\nkfree(str_buf);\r\nreturn ret;\r\n}
