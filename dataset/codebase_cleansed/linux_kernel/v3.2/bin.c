static int\r\nfill_read(struct file *file, char *buffer, loff_t off, size_t count)\r\n{\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nstruct bin_attribute *attr = attr_sd->s_bin_attr.bin_attr;\r\nstruct kobject *kobj = attr_sd->s_parent->s_dir.kobj;\r\nint rc;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn -ENODEV;\r\nrc = -EIO;\r\nif (attr->read)\r\nrc = attr->read(file, kobj, attr, buffer, off, count);\r\nsysfs_put_active(attr_sd);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nread(struct file *file, char __user *userbuf, size_t bytes, loff_t *off)\r\n{\r\nstruct bin_buffer *bb = file->private_data;\r\nint size = file->f_path.dentry->d_inode->i_size;\r\nloff_t offs = *off;\r\nint count = min_t(size_t, bytes, PAGE_SIZE);\r\nchar *temp;\r\nif (!bytes)\r\nreturn 0;\r\nif (size) {\r\nif (offs > size)\r\nreturn 0;\r\nif (offs + count > size)\r\ncount = size - offs;\r\n}\r\ntemp = kmalloc(count, GFP_KERNEL);\r\nif (!temp)\r\nreturn -ENOMEM;\r\nmutex_lock(&bb->mutex);\r\ncount = fill_read(file, bb->buffer, offs, count);\r\nif (count < 0) {\r\nmutex_unlock(&bb->mutex);\r\ngoto out_free;\r\n}\r\nmemcpy(temp, bb->buffer, count);\r\nmutex_unlock(&bb->mutex);\r\nif (copy_to_user(userbuf, temp, count)) {\r\ncount = -EFAULT;\r\ngoto out_free;\r\n}\r\npr_debug("offs = %lld, *off = %lld, count = %d\n", offs, *off, count);\r\n*off = offs + count;\r\nout_free:\r\nkfree(temp);\r\nreturn count;\r\n}\r\nstatic int\r\nflush_write(struct file *file, char *buffer, loff_t offset, size_t count)\r\n{\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nstruct bin_attribute *attr = attr_sd->s_bin_attr.bin_attr;\r\nstruct kobject *kobj = attr_sd->s_parent->s_dir.kobj;\r\nint rc;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn -ENODEV;\r\nrc = -EIO;\r\nif (attr->write)\r\nrc = attr->write(file, kobj, attr, buffer, offset, count);\r\nsysfs_put_active(attr_sd);\r\nreturn rc;\r\n}\r\nstatic ssize_t write(struct file *file, const char __user *userbuf,\r\nsize_t bytes, loff_t *off)\r\n{\r\nstruct bin_buffer *bb = file->private_data;\r\nint size = file->f_path.dentry->d_inode->i_size;\r\nloff_t offs = *off;\r\nint count = min_t(size_t, bytes, PAGE_SIZE);\r\nchar *temp;\r\nif (!bytes)\r\nreturn 0;\r\nif (size) {\r\nif (offs > size)\r\nreturn 0;\r\nif (offs + count > size)\r\ncount = size - offs;\r\n}\r\ntemp = memdup_user(userbuf, count);\r\nif (IS_ERR(temp))\r\nreturn PTR_ERR(temp);\r\nmutex_lock(&bb->mutex);\r\nmemcpy(bb->buffer, temp, count);\r\ncount = flush_write(file, bb->buffer, offs, count);\r\nmutex_unlock(&bb->mutex);\r\nif (count > 0)\r\n*off = offs + count;\r\nkfree(temp);\r\nreturn count;\r\n}\r\nstatic void bin_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nif (!bb->vm_ops)\r\nreturn;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn;\r\nif (bb->vm_ops->open)\r\nbb->vm_ops->open(vma);\r\nsysfs_put_active(attr_sd);\r\n}\r\nstatic int bin_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nint ret;\r\nif (!bb->vm_ops)\r\nreturn VM_FAULT_SIGBUS;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn VM_FAULT_SIGBUS;\r\nret = VM_FAULT_SIGBUS;\r\nif (bb->vm_ops->fault)\r\nret = bb->vm_ops->fault(vma, vmf);\r\nsysfs_put_active(attr_sd);\r\nreturn ret;\r\n}\r\nstatic int bin_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nint ret;\r\nif (!bb->vm_ops)\r\nreturn VM_FAULT_SIGBUS;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn VM_FAULT_SIGBUS;\r\nret = 0;\r\nif (bb->vm_ops->page_mkwrite)\r\nret = bb->vm_ops->page_mkwrite(vma, vmf);\r\nsysfs_put_active(attr_sd);\r\nreturn ret;\r\n}\r\nstatic int bin_access(struct vm_area_struct *vma, unsigned long addr,\r\nvoid *buf, int len, int write)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nint ret;\r\nif (!bb->vm_ops)\r\nreturn -EINVAL;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn -EINVAL;\r\nret = -EINVAL;\r\nif (bb->vm_ops->access)\r\nret = bb->vm_ops->access(vma, addr, buf, len, write);\r\nsysfs_put_active(attr_sd);\r\nreturn ret;\r\n}\r\nstatic int bin_set_policy(struct vm_area_struct *vma, struct mempolicy *new)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nint ret;\r\nif (!bb->vm_ops)\r\nreturn 0;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn -EINVAL;\r\nret = 0;\r\nif (bb->vm_ops->set_policy)\r\nret = bb->vm_ops->set_policy(vma, new);\r\nsysfs_put_active(attr_sd);\r\nreturn ret;\r\n}\r\nstatic struct mempolicy *bin_get_policy(struct vm_area_struct *vma,\r\nunsigned long addr)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nstruct mempolicy *pol;\r\nif (!bb->vm_ops)\r\nreturn vma->vm_policy;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn vma->vm_policy;\r\npol = vma->vm_policy;\r\nif (bb->vm_ops->get_policy)\r\npol = bb->vm_ops->get_policy(vma, addr);\r\nsysfs_put_active(attr_sd);\r\nreturn pol;\r\n}\r\nstatic int bin_migrate(struct vm_area_struct *vma, const nodemask_t *from,\r\nconst nodemask_t *to, unsigned long flags)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nint ret;\r\nif (!bb->vm_ops)\r\nreturn 0;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn 0;\r\nret = 0;\r\nif (bb->vm_ops->migrate)\r\nret = bb->vm_ops->migrate(vma, from, to, flags);\r\nsysfs_put_active(attr_sd);\r\nreturn ret;\r\n}\r\nstatic int mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct bin_buffer *bb = file->private_data;\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nstruct bin_attribute *attr = attr_sd->s_bin_attr.bin_attr;\r\nstruct kobject *kobj = attr_sd->s_parent->s_dir.kobj;\r\nint rc;\r\nmutex_lock(&bb->mutex);\r\nrc = -ENODEV;\r\nif (!sysfs_get_active(attr_sd))\r\ngoto out_unlock;\r\nrc = -EINVAL;\r\nif (!attr->mmap)\r\ngoto out_put;\r\nrc = attr->mmap(file, kobj, attr, vma);\r\nif (rc)\r\ngoto out_put;\r\nif (vma->vm_file != file)\r\ngoto out_put;\r\nrc = -EINVAL;\r\nif (bb->mmapped && bb->vm_ops != vma->vm_ops)\r\ngoto out_put;\r\nrc = -EINVAL;\r\nif (vma->vm_ops && vma->vm_ops->close)\r\ngoto out_put;\r\nrc = 0;\r\nbb->mmapped = 1;\r\nbb->vm_ops = vma->vm_ops;\r\nvma->vm_ops = &bin_vm_ops;\r\nout_put:\r\nsysfs_put_active(attr_sd);\r\nout_unlock:\r\nmutex_unlock(&bb->mutex);\r\nreturn rc;\r\n}\r\nstatic int open(struct inode * inode, struct file * file)\r\n{\r\nstruct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;\r\nstruct bin_attribute *attr = attr_sd->s_bin_attr.bin_attr;\r\nstruct bin_buffer *bb = NULL;\r\nint error;\r\nif (!sysfs_get_active(attr_sd))\r\nreturn -ENODEV;\r\nerror = -EACCES;\r\nif ((file->f_mode & FMODE_WRITE) && !(attr->write || attr->mmap))\r\ngoto err_out;\r\nif ((file->f_mode & FMODE_READ) && !(attr->read || attr->mmap))\r\ngoto err_out;\r\nerror = -ENOMEM;\r\nbb = kzalloc(sizeof(*bb), GFP_KERNEL);\r\nif (!bb)\r\ngoto err_out;\r\nbb->buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!bb->buffer)\r\ngoto err_out;\r\nmutex_init(&bb->mutex);\r\nbb->file = file;\r\nfile->private_data = bb;\r\nmutex_lock(&sysfs_bin_lock);\r\nhlist_add_head(&bb->list, &attr_sd->s_bin_attr.buffers);\r\nmutex_unlock(&sysfs_bin_lock);\r\nsysfs_put_active(attr_sd);\r\nreturn 0;\r\nerr_out:\r\nsysfs_put_active(attr_sd);\r\nkfree(bb);\r\nreturn error;\r\n}\r\nstatic int release(struct inode * inode, struct file * file)\r\n{\r\nstruct bin_buffer *bb = file->private_data;\r\nmutex_lock(&sysfs_bin_lock);\r\nhlist_del(&bb->list);\r\nmutex_unlock(&sysfs_bin_lock);\r\nkfree(bb->buffer);\r\nkfree(bb);\r\nreturn 0;\r\n}\r\nvoid unmap_bin_file(struct sysfs_dirent *attr_sd)\r\n{\r\nstruct bin_buffer *bb;\r\nstruct hlist_node *tmp;\r\nif (sysfs_type(attr_sd) != SYSFS_KOBJ_BIN_ATTR)\r\nreturn;\r\nmutex_lock(&sysfs_bin_lock);\r\nhlist_for_each_entry(bb, tmp, &attr_sd->s_bin_attr.buffers, list) {\r\nstruct inode *inode = bb->file->f_path.dentry->d_inode;\r\nunmap_mapping_range(inode->i_mapping, 0, 0, 1);\r\n}\r\nmutex_unlock(&sysfs_bin_lock);\r\n}\r\nint sysfs_create_bin_file(struct kobject *kobj,\r\nconst struct bin_attribute *attr)\r\n{\r\nBUG_ON(!kobj || !kobj->sd || !attr);\r\nreturn sysfs_add_file(kobj->sd, &attr->attr, SYSFS_KOBJ_BIN_ATTR);\r\n}\r\nvoid sysfs_remove_bin_file(struct kobject *kobj,\r\nconst struct bin_attribute *attr)\r\n{\r\nsysfs_hash_and_remove(kobj->sd, NULL, attr->attr.name);\r\n}
