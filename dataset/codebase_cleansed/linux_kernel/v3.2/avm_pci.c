static u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nregister u_char idx = (offset > 0x2f) ? AVM_ISAC_REG_HIGH : AVM_ISAC_REG_LOW;\r\nregister u_char val;\r\noutb(idx, cs->hw.avm.cfg_reg + 4);\r\nval = inb(cs->hw.avm.isac + (offset & 0xf));\r\nreturn (val);\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nregister u_char idx = (offset > 0x2f) ? AVM_ISAC_REG_HIGH : AVM_ISAC_REG_LOW;\r\noutb(idx, cs->hw.avm.cfg_reg + 4);\r\noutb(value, cs->hw.avm.isac + (offset & 0xf));\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\noutb(AVM_ISAC_FIFO, cs->hw.avm.cfg_reg + 4);\r\ninsb(cs->hw.avm.isac, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\noutb(AVM_ISAC_FIFO, cs->hw.avm.cfg_reg + 4);\r\noutsb(cs->hw.avm.isac, data, size);\r\n}\r\nstatic inline u_int\r\nReadHDLCPCI(struct IsdnCardState *cs, int chan, u_char offset)\r\n{\r\nregister u_int idx = chan ? AVM_HDLC_2 : AVM_HDLC_1;\r\nregister u_int val;\r\noutl(idx, cs->hw.avm.cfg_reg + 4);\r\nval = inl(cs->hw.avm.isac + offset);\r\nreturn (val);\r\n}\r\nstatic inline void\r\nWriteHDLCPCI(struct IsdnCardState *cs, int chan, u_char offset, u_int value)\r\n{\r\nregister u_int idx = chan ? AVM_HDLC_2 : AVM_HDLC_1;\r\noutl(idx, cs->hw.avm.cfg_reg + 4);\r\noutl(value, cs->hw.avm.isac + offset);\r\n}\r\nstatic inline u_char\r\nReadHDLCPnP(struct IsdnCardState *cs, int chan, u_char offset)\r\n{\r\nregister u_char idx = chan ? AVM_HDLC_2 : AVM_HDLC_1;\r\nregister u_char val;\r\noutb(idx, cs->hw.avm.cfg_reg + 4);\r\nval = inb(cs->hw.avm.isac + offset);\r\nreturn (val);\r\n}\r\nstatic inline void\r\nWriteHDLCPnP(struct IsdnCardState *cs, int chan, u_char offset, u_char value)\r\n{\r\nregister u_char idx = chan ? AVM_HDLC_2 : AVM_HDLC_1;\r\noutb(idx, cs->hw.avm.cfg_reg + 4);\r\noutb(value, cs->hw.avm.isac + offset);\r\n}\r\nstatic u_char\r\nReadHDLC_s(struct IsdnCardState *cs, int chan, u_char offset)\r\n{\r\nreturn(0xff & ReadHDLCPCI(cs, chan, offset));\r\n}\r\nstatic void\r\nWriteHDLC_s(struct IsdnCardState *cs, int chan, u_char offset, u_char value)\r\n{\r\nWriteHDLCPCI(cs, chan, offset, value);\r\n}\r\nstatic inline\r\nstruct BCState *Sel_BCS(struct IsdnCardState *cs, int channel)\r\n{\r\nif (cs->bcs[0].mode && (cs->bcs[0].channel == channel))\r\nreturn(&cs->bcs[0]);\r\nelse if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))\r\nreturn(&cs->bcs[1]);\r\nelse\r\nreturn(NULL);\r\n}\r\nstatic void\r\nwrite_ctrl(struct BCState *bcs, int which) {\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "hdlc %c wr%x ctrl %x",\r\n'A' + bcs->channel, which, bcs->hw.hdlc.ctrl.ctrl);\r\nif (bcs->cs->subtyp == AVM_FRITZ_PCI) {\r\nWriteHDLCPCI(bcs->cs, bcs->channel, HDLC_STATUS, bcs->hw.hdlc.ctrl.ctrl);\r\n} else {\r\nif (which & 4)\r\nWriteHDLCPnP(bcs->cs, bcs->channel, HDLC_STATUS + 2,\r\nbcs->hw.hdlc.ctrl.sr.mode);\r\nif (which & 2)\r\nWriteHDLCPnP(bcs->cs, bcs->channel, HDLC_STATUS + 1,\r\nbcs->hw.hdlc.ctrl.sr.xml);\r\nif (which & 1)\r\nWriteHDLCPnP(bcs->cs, bcs->channel, HDLC_STATUS,\r\nbcs->hw.hdlc.ctrl.sr.cmd);\r\n}\r\n}\r\nstatic void\r\nmodehdlc(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint hdlc = bcs->channel;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hdlc %c mode %d --> %d ichan %d --> %d",\r\n'A' + hdlc, bcs->mode, mode, hdlc, bc);\r\nbcs->hw.hdlc.ctrl.ctrl = 0;\r\nswitch (mode) {\r\ncase (-1):\r\nbcs->mode = 1;\r\nbcs->channel = bc;\r\nbc = 0;\r\ncase (L1_MODE_NULL):\r\nif (bcs->mode == L1_MODE_NULL)\r\nreturn;\r\nbcs->hw.hdlc.ctrl.sr.cmd = HDLC_CMD_XRS | HDLC_CMD_RRS;\r\nbcs->hw.hdlc.ctrl.sr.mode = HDLC_MODE_TRANS;\r\nwrite_ctrl(bcs, 5);\r\nbcs->mode = L1_MODE_NULL;\r\nbcs->channel = bc;\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nbcs->hw.hdlc.ctrl.sr.cmd = HDLC_CMD_XRS | HDLC_CMD_RRS;\r\nbcs->hw.hdlc.ctrl.sr.mode = HDLC_MODE_TRANS;\r\nwrite_ctrl(bcs, 5);\r\nbcs->hw.hdlc.ctrl.sr.cmd = HDLC_CMD_XRS;\r\nwrite_ctrl(bcs, 1);\r\nbcs->hw.hdlc.ctrl.sr.cmd = 0;\r\nschedule_event(bcs, B_XMTBUFREADY);\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nbcs->hw.hdlc.ctrl.sr.cmd = HDLC_CMD_XRS | HDLC_CMD_RRS;\r\nbcs->hw.hdlc.ctrl.sr.mode = HDLC_MODE_ITF_FLG;\r\nwrite_ctrl(bcs, 5);\r\nbcs->hw.hdlc.ctrl.sr.cmd = HDLC_CMD_XRS;\r\nwrite_ctrl(bcs, 1);\r\nbcs->hw.hdlc.ctrl.sr.cmd = 0;\r\nschedule_event(bcs, B_XMTBUFREADY);\r\nbreak;\r\n}\r\n}\r\nstatic inline void\r\nhdlc_empty_fifo(struct BCState *bcs, int count)\r\n{\r\nregister u_int *ptr;\r\nu_char *p;\r\nu_char idx = bcs->channel ? AVM_HDLC_2 : AVM_HDLC_1;\r\nint cnt=0;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hdlc_empty_fifo %d", count);\r\nif (bcs->hw.hdlc.rcvidx + count > HSCX_BUFMAX) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hdlc_empty_fifo: incoming packet too large");\r\nreturn;\r\n}\r\np = bcs->hw.hdlc.rcvbuf + bcs->hw.hdlc.rcvidx;\r\nptr = (u_int *)p;\r\nbcs->hw.hdlc.rcvidx += count;\r\nif (cs->subtyp == AVM_FRITZ_PCI) {\r\noutl(idx, cs->hw.avm.cfg_reg + 4);\r\nwhile (cnt < count) {\r\n#ifdef __powerpc__\r\n*ptr++ = in_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE));\r\n#else\r\n*ptr++ = inl(cs->hw.avm.isac);\r\n#endif\r\ncnt += 4;\r\n}\r\n} else {\r\noutb(idx, cs->hw.avm.cfg_reg + 4);\r\nwhile (cnt < count) {\r\n*p++ = inb(cs->hw.avm.isac);\r\ncnt++;\r\n}\r\n}\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nif (cs->subtyp == AVM_FRITZ_PNP)\r\np = (u_char *) ptr;\r\nt += sprintf(t, "hdlc_empty_fifo %c cnt %d",\r\nbcs->channel ? 'B' : 'A', count);\r\nQuickHex(t, p, count);\r\ndebugl1(cs, bcs->blog);\r\n}\r\n}\r\nstatic inline void\r\nhdlc_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint count, cnt =0;\r\nint fifo_size = 32;\r\nu_char *p;\r\nu_int *ptr;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hdlc_fill_fifo");\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nbcs->hw.hdlc.ctrl.sr.cmd &= ~HDLC_CMD_XME;\r\nif (bcs->tx_skb->len > fifo_size) {\r\ncount = fifo_size;\r\n} else {\r\ncount = bcs->tx_skb->len;\r\nif (bcs->mode != L1_MODE_TRANS)\r\nbcs->hw.hdlc.ctrl.sr.cmd |= HDLC_CMD_XME;\r\n}\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hdlc_fill_fifo %d/%u", count, bcs->tx_skb->len);\r\np = bcs->tx_skb->data;\r\nptr = (u_int *)p;\r\nskb_pull(bcs->tx_skb, count);\r\nbcs->tx_cnt -= count;\r\nbcs->hw.hdlc.count += count;\r\nbcs->hw.hdlc.ctrl.sr.xml = ((count == fifo_size) ? 0 : count);\r\nwrite_ctrl(bcs, 3);\r\nif (cs->subtyp == AVM_FRITZ_PCI) {\r\nwhile (cnt<count) {\r\n#ifdef __powerpc__\r\nout_be32((unsigned *)(cs->hw.avm.isac +_IO_BASE), *ptr++);\r\n#else\r\noutl(*ptr++, cs->hw.avm.isac);\r\n#endif\r\ncnt += 4;\r\n}\r\n} else {\r\nwhile (cnt<count) {\r\noutb(*p++, cs->hw.avm.isac);\r\ncnt++;\r\n}\r\n}\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nif (cs->subtyp == AVM_FRITZ_PNP)\r\np = (u_char *) ptr;\r\nt += sprintf(t, "hdlc_fill_fifo %c cnt %d",\r\nbcs->channel ? 'B' : 'A', count);\r\nQuickHex(t, p, count);\r\ndebugl1(cs, bcs->blog);\r\n}\r\n}\r\nstatic void\r\nHDLC_irq(struct BCState *bcs, u_int stat) {\r\nint len;\r\nstruct sk_buff *skb;\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "ch%d stat %#x", bcs->channel, stat);\r\nif (stat & HDLC_INT_RPR) {\r\nif (stat & HDLC_STAT_RDO) {\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "RDO");\r\nelse\r\ndebugl1(bcs->cs, "ch%d stat %#x", bcs->channel, stat);\r\nbcs->hw.hdlc.ctrl.sr.xml = 0;\r\nbcs->hw.hdlc.ctrl.sr.cmd |= HDLC_CMD_RRS;\r\nwrite_ctrl(bcs, 1);\r\nbcs->hw.hdlc.ctrl.sr.cmd &= ~HDLC_CMD_RRS;\r\nwrite_ctrl(bcs, 1);\r\nbcs->hw.hdlc.rcvidx = 0;\r\n} else {\r\nif (!(len = (stat & HDLC_STAT_RML_MASK)>>8))\r\nlen = 32;\r\nhdlc_empty_fifo(bcs, len);\r\nif ((stat & HDLC_STAT_RME) || (bcs->mode == L1_MODE_TRANS)) {\r\nif (((stat & HDLC_STAT_CRCVFRRAB)==HDLC_STAT_CRCVFR) ||\r\n(bcs->mode == L1_MODE_TRANS)) {\r\nif (!(skb = dev_alloc_skb(bcs->hw.hdlc.rcvidx)))\r\nprintk(KERN_WARNING "HDLC: receive out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, bcs->hw.hdlc.rcvidx),\r\nbcs->hw.hdlc.rcvbuf, bcs->hw.hdlc.rcvidx);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\nbcs->hw.hdlc.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n} else {\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "invalid frame");\r\nelse\r\ndebugl1(bcs->cs, "ch%d invalid frame %#x", bcs->channel, stat);\r\nbcs->hw.hdlc.rcvidx = 0;\r\n}\r\n}\r\n}\r\n}\r\nif (stat & HDLC_INT_XDU) {\r\nif (bcs->tx_skb) {\r\nskb_push(bcs->tx_skb, bcs->hw.hdlc.count);\r\nbcs->tx_cnt += bcs->hw.hdlc.count;\r\nbcs->hw.hdlc.count = 0;\r\nif (bcs->cs->debug & L1_DEB_WARN)\r\ndebugl1(bcs->cs, "ch%d XDU", bcs->channel);\r\n} else if (bcs->cs->debug & L1_DEB_WARN)\r\ndebugl1(bcs->cs, "ch%d XDU without skb", bcs->channel);\r\nbcs->hw.hdlc.ctrl.sr.xml = 0;\r\nbcs->hw.hdlc.ctrl.sr.cmd |= HDLC_CMD_XRS;\r\nwrite_ctrl(bcs, 1);\r\nbcs->hw.hdlc.ctrl.sr.cmd &= ~HDLC_CMD_XRS;\r\nwrite_ctrl(bcs, 1);\r\nhdlc_fill_fifo(bcs);\r\n} else if (stat & HDLC_INT_XPR) {\r\nif (bcs->tx_skb) {\r\nif (bcs->tx_skb->len) {\r\nhdlc_fill_fifo(bcs);\r\nreturn;\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP,&bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->hw.hdlc.count;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_irq(bcs->tx_skb);\r\nbcs->hw.hdlc.count = 0;\r\nbcs->tx_skb = NULL;\r\n}\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nbcs->hw.hdlc.count = 0;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nhdlc_fill_fifo(bcs);\r\n} else {\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\nstatic inline void\r\nHDLC_irq_main(struct IsdnCardState *cs)\r\n{\r\nu_int stat;\r\nstruct BCState *bcs;\r\nif (cs->subtyp == AVM_FRITZ_PCI) {\r\nstat = ReadHDLCPCI(cs, 0, HDLC_STATUS);\r\n} else {\r\nstat = ReadHDLCPnP(cs, 0, HDLC_STATUS);\r\nif (stat & HDLC_INT_RPR)\r\nstat |= (ReadHDLCPnP(cs, 0, HDLC_STATUS+1))<<8;\r\n}\r\nif (stat & HDLC_INT_MASK) {\r\nif (!(bcs = Sel_BCS(cs, 0))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hdlc spurious channel 0 IRQ");\r\n} else\r\nHDLC_irq(bcs, stat);\r\n}\r\nif (cs->subtyp == AVM_FRITZ_PCI) {\r\nstat = ReadHDLCPCI(cs, 1, HDLC_STATUS);\r\n} else {\r\nstat = ReadHDLCPnP(cs, 1, HDLC_STATUS);\r\nif (stat & HDLC_INT_RPR)\r\nstat |= (ReadHDLCPnP(cs, 1, HDLC_STATUS+1))<<8;\r\n}\r\nif (stat & HDLC_INT_MASK) {\r\nif (!(bcs = Sel_BCS(cs, 1))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hdlc spurious channel 1 IRQ");\r\n} else\r\nHDLC_irq(bcs, stat);\r\n}\r\n}\r\nstatic void\r\nhdlc_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->hw.hdlc.count = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "hdlc_l2l1: this shouldn't happen\n");\r\n} else {\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->tx_skb = skb;\r\nbcs->hw.hdlc.count = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmodehdlc(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmodehdlc(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_hdlcstate(struct BCState *bcs)\r\n{\r\nmodehdlc(bcs, 0, 0);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nkfree(bcs->hw.hdlc.rcvbuf);\r\nbcs->hw.hdlc.rcvbuf = NULL;\r\nkfree(bcs->blog);\r\nbcs->blog = NULL;\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic int\r\nopen_hdlcstate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nif (!(bcs->hw.hdlc.rcvbuf = kmalloc(HSCX_BUFMAX, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for hdlc.rcvbuf\n");\r\nreturn (1);\r\n}\r\nif (!(bcs->blog = kmalloc(MAX_BLOG_SPACE, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for bcs->blog\n");\r\ntest_and_clear_bit(BC_FLG_INIT, &bcs->Flag);\r\nkfree(bcs->hw.hdlc.rcvbuf);\r\nbcs->hw.hdlc.rcvbuf = NULL;\r\nreturn (2);\r\n}\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->hw.hdlc.rcvidx = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_hdlc(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_hdlcstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = hdlc_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nstatic void\r\ninithdlc(struct IsdnCardState *cs)\r\n{\r\ncs->bcs[0].BC_SetStack = setstack_hdlc;\r\ncs->bcs[1].BC_SetStack = setstack_hdlc;\r\ncs->bcs[0].BC_Close = close_hdlcstate;\r\ncs->bcs[1].BC_Close = close_hdlcstate;\r\nmodehdlc(cs->bcs, -1, 0);\r\nmodehdlc(cs->bcs + 1, -1, 1);\r\n}\r\nstatic irqreturn_t\r\navm_pcipnp_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_long flags;\r\nu_char val;\r\nu_char sval;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nsval = inb(cs->hw.avm.cfg_reg + 2);\r\nif ((sval & AVM_STATUS0_IRQ_MASK) == AVM_STATUS0_IRQ_MASK) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (!(sval & AVM_STATUS0_IRQ_ISAC)) {\r\nval = ReadISAC(cs, ISAC_ISTA);\r\nisac_interrupt(cs, val);\r\n}\r\nif (!(sval & AVM_STATUS0_IRQ_HDLC)) {\r\nHDLC_irq_main(cs);\r\n}\r\nWriteISAC(cs, ISAC_MASK, 0xFF);\r\nWriteISAC(cs, ISAC_MASK, 0x0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nreset_avmpcipnp(struct IsdnCardState *cs)\r\n{\r\nprintk(KERN_INFO "AVM PCI/PnP: reset\n");\r\noutb(AVM_STATUS0_RESET | AVM_STATUS0_DIS_TIMER, cs->hw.avm.cfg_reg + 2);\r\nmdelay(10);\r\noutb(AVM_STATUS0_DIS_TIMER | AVM_STATUS0_RES_TIMER | AVM_STATUS0_ENA_IRQ, cs->hw.avm.cfg_reg + 2);\r\noutb(AVM_STATUS1_ENA_IOM | cs->irq, cs->hw.avm.cfg_reg + 3);\r\nmdelay(10);\r\nprintk(KERN_INFO "AVM PCI/PnP: S1 %x\n", inb(cs->hw.avm.cfg_reg + 3));\r\n}\r\nstatic int\r\nAVM_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_avmpcipnp(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn(0);\r\ncase CARD_RELEASE:\r\noutb(0, cs->hw.avm.cfg_reg + 2);\r\nrelease_region(cs->hw.avm.cfg_reg, 32);\r\nreturn(0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_avmpcipnp(cs);\r\nclear_pending_isac_ints(cs);\r\ninitisac(cs);\r\ninithdlc(cs);\r\noutb(AVM_STATUS0_DIS_TIMER | AVM_STATUS0_RES_TIMER,\r\ncs->hw.avm.cfg_reg + 2);\r\nWriteISAC(cs, ISAC_MASK, 0);\r\noutb(AVM_STATUS0_DIS_TIMER | AVM_STATUS0_RES_TIMER |\r\nAVM_STATUS0_ENA_IRQ, cs->hw.avm.cfg_reg + 2);\r\nWriteISAC(cs, ISAC_CMDR, 0x41);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn(0);\r\ncase CARD_TEST:\r\nreturn(0);\r\n}\r\nreturn(0);\r\n}\r\nstatic int __devinit avm_setup_rest(struct IsdnCardState *cs)\r\n{\r\nu_int val, ver;\r\ncs->hw.avm.isac = cs->hw.avm.cfg_reg + 0x10;\r\nif (!request_region(cs->hw.avm.cfg_reg, 32,\r\n(cs->subtyp == AVM_FRITZ_PCI) ? "avm PCI" : "avm PnP")) {\r\nprintk(KERN_WARNING\r\n"HiSax: Fritz!PCI/PNP config port %x-%x already in use\n",\r\ncs->hw.avm.cfg_reg,\r\ncs->hw.avm.cfg_reg + 31);\r\nreturn (0);\r\n}\r\nswitch (cs->subtyp) {\r\ncase AVM_FRITZ_PCI:\r\nval = inl(cs->hw.avm.cfg_reg);\r\nprintk(KERN_INFO "AVM PCI: stat %#x\n", val);\r\nprintk(KERN_INFO "AVM PCI: Class %X Rev %d\n",\r\nval & 0xff, (val>>8) & 0xff);\r\ncs->BC_Read_Reg = &ReadHDLC_s;\r\ncs->BC_Write_Reg = &WriteHDLC_s;\r\nbreak;\r\ncase AVM_FRITZ_PNP:\r\nval = inb(cs->hw.avm.cfg_reg);\r\nver = inb(cs->hw.avm.cfg_reg + 1);\r\nprintk(KERN_INFO "AVM PnP: Class %X Rev %d\n", val, ver);\r\ncs->BC_Read_Reg = &ReadHDLCPnP;\r\ncs->BC_Write_Reg = &WriteHDLCPnP;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "AVM unknown subtype %d\n", cs->subtyp);\r\nreturn(0);\r\n}\r\nprintk(KERN_INFO "HiSax: %s config irq:%d base:0x%X\n",\r\n(cs->subtyp == AVM_FRITZ_PCI) ? "AVM Fritz!PCI" : "AVM Fritz!PnP",\r\ncs->irq, cs->hw.avm.cfg_reg);\r\nsetup_isac(cs);\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->BC_Send_Data = &hdlc_fill_fifo;\r\ncs->cardmsg = &AVM_card_msg;\r\ncs->irq_func = &avm_pcipnp_interrupt;\r\ncs->writeisac(cs, ISAC_MASK, 0xFF);\r\nISACVersion(cs, (cs->subtyp == AVM_FRITZ_PCI) ? "AVM PCI:" : "AVM PnP:");\r\nreturn (1);\r\n}\r\nstatic int __devinit avm_pnp_setup(struct IsdnCardState *cs)\r\n{\r\nreturn(1);\r\n}\r\nstatic int __devinit avm_pnp_setup(struct IsdnCardState *cs)\r\n{\r\nstruct pnp_dev *pnp_avm_d = NULL;\r\nif (!isapnp_present())\r\nreturn(1);\r\nif ((pnp_avm_c = pnp_find_card(\r\nISAPNP_VENDOR('A', 'V', 'M'),\r\nISAPNP_FUNCTION(0x0900), pnp_avm_c))) {\r\nif ((pnp_avm_d = pnp_find_dev(pnp_avm_c,\r\nISAPNP_VENDOR('A', 'V', 'M'),\r\nISAPNP_FUNCTION(0x0900), pnp_avm_d))) {\r\nint err;\r\npnp_disable_dev(pnp_avm_d);\r\nerr = pnp_activate_dev(pnp_avm_d);\r\nif (err<0) {\r\nprintk(KERN_WARNING "%s: pnp_activate_dev ret(%d)\n",\r\n__func__, err);\r\nreturn(0);\r\n}\r\ncs->hw.avm.cfg_reg =\r\npnp_port_start(pnp_avm_d, 0);\r\ncs->irq = pnp_irq(pnp_avm_d, 0);\r\nif (!cs->irq) {\r\nprintk(KERN_ERR "FritzPnP:No IRQ\n");\r\nreturn(0);\r\n}\r\nif (!cs->hw.avm.cfg_reg) {\r\nprintk(KERN_ERR "FritzPnP:No IO address\n");\r\nreturn(0);\r\n}\r\ncs->subtyp = AVM_FRITZ_PNP;\r\nreturn (2);\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic int __devinit avm_pci_setup(struct IsdnCardState *cs)\r\n{\r\nreturn(1);\r\n}\r\nstatic int __devinit avm_pci_setup(struct IsdnCardState *cs)\r\n{\r\nif ((dev_avm = hisax_find_pci_device(PCI_VENDOR_ID_AVM,\r\nPCI_DEVICE_ID_AVM_A1, dev_avm))) {\r\nif (pci_enable_device(dev_avm))\r\nreturn(0);\r\ncs->irq = dev_avm->irq;\r\nif (!cs->irq) {\r\nprintk(KERN_ERR "FritzPCI: No IRQ for PCI card found\n");\r\nreturn(0);\r\n}\r\ncs->hw.avm.cfg_reg = pci_resource_start(dev_avm, 1);\r\nif (!cs->hw.avm.cfg_reg) {\r\nprintk(KERN_ERR "FritzPCI: No IO-Adr for PCI card found\n");\r\nreturn(0);\r\n}\r\ncs->subtyp = AVM_FRITZ_PCI;\r\n} else {\r\nprintk(KERN_WARNING "FritzPCI: No PCI card found\n");\r\nreturn(0);\r\n}\r\ncs->irq_flags |= IRQF_SHARED;\r\nreturn (1);\r\n}\r\nint __devinit\r\nsetup_avm_pcipnp(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nint rc;\r\nstrcpy(tmp, avm_pci_rev);\r\nprintk(KERN_INFO "HiSax: AVM PCI driver Rev. %s\n", HiSax_getrev(tmp));\r\nif (cs->typ != ISDN_CTYPE_FRITZPCI)\r\nreturn (0);\r\nif (card->para[1]) {\r\ncs->hw.avm.cfg_reg = card->para[1];\r\ncs->irq = card->para[0];\r\ncs->subtyp = AVM_FRITZ_PNP;\r\ngoto ready;\r\n}\r\nrc = avm_pnp_setup(cs);\r\nif (rc < 1)\r\nreturn (0);\r\nif (rc == 2)\r\ngoto ready;\r\nrc = avm_pci_setup(cs);\r\nif (rc < 1)\r\nreturn (0);\r\nready:\r\nreturn avm_setup_rest(cs);\r\n}
