static int tp_event_has_id(struct dirent *sys_dir, struct dirent *evt_dir)\r\n{\r\nchar evt_path[MAXPATHLEN];\r\nint fd;\r\nsnprintf(evt_path, MAXPATHLEN, "%s/%s/%s/id", debugfs_path,\r\nsys_dir->d_name, evt_dir->d_name);\r\nfd = open(evt_path, O_RDONLY);\r\nif (fd < 0)\r\nreturn -EINVAL;\r\nclose(fd);\r\nreturn 0;\r\n}\r\nstruct tracepoint_path *tracepoint_id_to_path(u64 config)\r\n{\r\nstruct tracepoint_path *path = NULL;\r\nDIR *sys_dir, *evt_dir;\r\nstruct dirent *sys_next, *evt_next, sys_dirent, evt_dirent;\r\nchar id_buf[4];\r\nint fd;\r\nu64 id;\r\nchar evt_path[MAXPATHLEN];\r\nchar dir_path[MAXPATHLEN];\r\nif (debugfs_valid_mountpoint(debugfs_path))\r\nreturn NULL;\r\nsys_dir = opendir(debugfs_path);\r\nif (!sys_dir)\r\nreturn NULL;\r\nfor_each_subsystem(sys_dir, sys_dirent, sys_next) {\r\nsnprintf(dir_path, MAXPATHLEN, "%s/%s", debugfs_path,\r\nsys_dirent.d_name);\r\nevt_dir = opendir(dir_path);\r\nif (!evt_dir)\r\ncontinue;\r\nfor_each_event(sys_dirent, evt_dir, evt_dirent, evt_next) {\r\nsnprintf(evt_path, MAXPATHLEN, "%s/%s/id", dir_path,\r\nevt_dirent.d_name);\r\nfd = open(evt_path, O_RDONLY);\r\nif (fd < 0)\r\ncontinue;\r\nif (read(fd, id_buf, sizeof(id_buf)) < 0) {\r\nclose(fd);\r\ncontinue;\r\n}\r\nclose(fd);\r\nid = atoll(id_buf);\r\nif (id == config) {\r\nclosedir(evt_dir);\r\nclosedir(sys_dir);\r\npath = zalloc(sizeof(*path));\r\npath->system = malloc(MAX_EVENT_LENGTH);\r\nif (!path->system) {\r\nfree(path);\r\nreturn NULL;\r\n}\r\npath->name = malloc(MAX_EVENT_LENGTH);\r\nif (!path->name) {\r\nfree(path->system);\r\nfree(path);\r\nreturn NULL;\r\n}\r\nstrncpy(path->system, sys_dirent.d_name,\r\nMAX_EVENT_LENGTH);\r\nstrncpy(path->name, evt_dirent.d_name,\r\nMAX_EVENT_LENGTH);\r\nreturn path;\r\n}\r\n}\r\nclosedir(evt_dir);\r\n}\r\nclosedir(sys_dir);\r\nreturn NULL;\r\n}\r\nstatic const char *tracepoint_id_to_name(u64 config)\r\n{\r\nstatic char buf[TP_PATH_LEN];\r\nstruct tracepoint_path *path;\r\npath = tracepoint_id_to_path(config);\r\nif (path) {\r\nsnprintf(buf, TP_PATH_LEN, "%s:%s", path->system, path->name);\r\nfree(path->name);\r\nfree(path->system);\r\nfree(path);\r\n} else\r\nsnprintf(buf, TP_PATH_LEN, "%s:%s", "unknown", "unknown");\r\nreturn buf;\r\n}\r\nstatic int is_cache_op_valid(u8 cache_type, u8 cache_op)\r\n{\r\nif (hw_cache_stat[cache_type] & COP(cache_op))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic char *event_cache_name(u8 cache_type, u8 cache_op, u8 cache_result)\r\n{\r\nstatic char name[50];\r\nif (cache_result) {\r\nsprintf(name, "%s-%s-%s", hw_cache[cache_type][0],\r\nhw_cache_op[cache_op][0],\r\nhw_cache_result[cache_result][0]);\r\n} else {\r\nsprintf(name, "%s-%s", hw_cache[cache_type][0],\r\nhw_cache_op[cache_op][1]);\r\n}\r\nreturn name;\r\n}\r\nconst char *event_type(int type)\r\n{\r\nswitch (type) {\r\ncase PERF_TYPE_HARDWARE:\r\nreturn "hardware";\r\ncase PERF_TYPE_SOFTWARE:\r\nreturn "software";\r\ncase PERF_TYPE_TRACEPOINT:\r\nreturn "tracepoint";\r\ncase PERF_TYPE_HW_CACHE:\r\nreturn "hardware-cache";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "unknown";\r\n}\r\nconst char *event_name(struct perf_evsel *evsel)\r\n{\r\nu64 config = evsel->attr.config;\r\nint type = evsel->attr.type;\r\nif (evsel->name)\r\nreturn evsel->name;\r\nreturn __event_name(type, config);\r\n}\r\nconst char *__event_name(int type, u64 config)\r\n{\r\nstatic char buf[32];\r\nif (type == PERF_TYPE_RAW) {\r\nsprintf(buf, "raw 0x%" PRIx64, config);\r\nreturn buf;\r\n}\r\nswitch (type) {\r\ncase PERF_TYPE_HARDWARE:\r\nif (config < PERF_COUNT_HW_MAX && hw_event_names[config])\r\nreturn hw_event_names[config];\r\nreturn "unknown-hardware";\r\ncase PERF_TYPE_HW_CACHE: {\r\nu8 cache_type, cache_op, cache_result;\r\ncache_type = (config >> 0) & 0xff;\r\nif (cache_type > PERF_COUNT_HW_CACHE_MAX)\r\nreturn "unknown-ext-hardware-cache-type";\r\ncache_op = (config >> 8) & 0xff;\r\nif (cache_op > PERF_COUNT_HW_CACHE_OP_MAX)\r\nreturn "unknown-ext-hardware-cache-op";\r\ncache_result = (config >> 16) & 0xff;\r\nif (cache_result > PERF_COUNT_HW_CACHE_RESULT_MAX)\r\nreturn "unknown-ext-hardware-cache-result";\r\nif (!is_cache_op_valid(cache_type, cache_op))\r\nreturn "invalid-cache";\r\nreturn event_cache_name(cache_type, cache_op, cache_result);\r\n}\r\ncase PERF_TYPE_SOFTWARE:\r\nif (config < PERF_COUNT_SW_MAX && sw_event_names[config])\r\nreturn sw_event_names[config];\r\nreturn "unknown-software";\r\ncase PERF_TYPE_TRACEPOINT:\r\nreturn tracepoint_id_to_name(config);\r\ndefault:\r\nbreak;\r\n}\r\nreturn "unknown";\r\n}\r\nstatic int parse_aliases(const char **str, const char *names[][MAX_ALIASES], int size)\r\n{\r\nint i, j;\r\nint n, longest = -1;\r\nfor (i = 0; i < size; i++) {\r\nfor (j = 0; j < MAX_ALIASES && names[i][j]; j++) {\r\nn = strlen(names[i][j]);\r\nif (n > longest && !strncasecmp(*str, names[i][j], n))\r\nlongest = n;\r\n}\r\nif (longest > 0) {\r\n*str += longest;\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic enum event_result\r\nparse_generic_hw_event(const char **str, struct perf_event_attr *attr)\r\n{\r\nconst char *s = *str;\r\nint cache_type = -1, cache_op = -1, cache_result = -1;\r\ncache_type = parse_aliases(&s, hw_cache, PERF_COUNT_HW_CACHE_MAX);\r\nif (cache_type == -1)\r\nreturn EVT_FAILED;\r\nwhile ((cache_op == -1 || cache_result == -1) && *s == '-') {\r\n++s;\r\nif (cache_op == -1) {\r\ncache_op = parse_aliases(&s, hw_cache_op,\r\nPERF_COUNT_HW_CACHE_OP_MAX);\r\nif (cache_op >= 0) {\r\nif (!is_cache_op_valid(cache_type, cache_op))\r\nreturn EVT_FAILED;\r\ncontinue;\r\n}\r\n}\r\nif (cache_result == -1) {\r\ncache_result = parse_aliases(&s, hw_cache_result,\r\nPERF_COUNT_HW_CACHE_RESULT_MAX);\r\nif (cache_result >= 0)\r\ncontinue;\r\n}\r\n--s;\r\nbreak;\r\n}\r\nif (cache_op == -1)\r\ncache_op = PERF_COUNT_HW_CACHE_OP_READ;\r\nif (cache_result == -1)\r\ncache_result = PERF_COUNT_HW_CACHE_RESULT_ACCESS;\r\nattr->config = cache_type | (cache_op << 8) | (cache_result << 16);\r\nattr->type = PERF_TYPE_HW_CACHE;\r\n*str = s;\r\nreturn EVT_HANDLED;\r\n}\r\nstatic enum event_result\r\nparse_single_tracepoint_event(char *sys_name,\r\nconst char *evt_name,\r\nunsigned int evt_length,\r\nstruct perf_event_attr *attr,\r\nconst char **strp)\r\n{\r\nchar evt_path[MAXPATHLEN];\r\nchar id_buf[4];\r\nu64 id;\r\nint fd;\r\nsnprintf(evt_path, MAXPATHLEN, "%s/%s/%s/id", debugfs_path,\r\nsys_name, evt_name);\r\nfd = open(evt_path, O_RDONLY);\r\nif (fd < 0)\r\nreturn EVT_FAILED;\r\nif (read(fd, id_buf, sizeof(id_buf)) < 0) {\r\nclose(fd);\r\nreturn EVT_FAILED;\r\n}\r\nclose(fd);\r\nid = atoll(id_buf);\r\nattr->config = id;\r\nattr->type = PERF_TYPE_TRACEPOINT;\r\n*strp += strlen(sys_name) + evt_length + 1;\r\nattr->sample_type |= PERF_SAMPLE_RAW;\r\nattr->sample_type |= PERF_SAMPLE_TIME;\r\nattr->sample_type |= PERF_SAMPLE_CPU;\r\nattr->sample_period = 1;\r\nreturn EVT_HANDLED;\r\n}\r\nstatic enum event_result\r\nparse_multiple_tracepoint_event(struct perf_evlist *evlist, char *sys_name,\r\nconst char *evt_exp, char *flags)\r\n{\r\nchar evt_path[MAXPATHLEN];\r\nstruct dirent *evt_ent;\r\nDIR *evt_dir;\r\nsnprintf(evt_path, MAXPATHLEN, "%s/%s", debugfs_path, sys_name);\r\nevt_dir = opendir(evt_path);\r\nif (!evt_dir) {\r\nperror("Can't open event dir");\r\nreturn EVT_FAILED;\r\n}\r\nwhile ((evt_ent = readdir(evt_dir))) {\r\nchar event_opt[MAX_EVOPT_LEN + 1];\r\nint len;\r\nif (!strcmp(evt_ent->d_name, ".")\r\n|| !strcmp(evt_ent->d_name, "..")\r\n|| !strcmp(evt_ent->d_name, "enable")\r\n|| !strcmp(evt_ent->d_name, "filter"))\r\ncontinue;\r\nif (!strglobmatch(evt_ent->d_name, evt_exp))\r\ncontinue;\r\nlen = snprintf(event_opt, MAX_EVOPT_LEN, "%s:%s%s%s", sys_name,\r\nevt_ent->d_name, flags ? ":" : "",\r\nflags ?: "");\r\nif (len < 0)\r\nreturn EVT_FAILED;\r\nif (parse_events(evlist, event_opt, 0))\r\nreturn EVT_FAILED;\r\n}\r\nreturn EVT_HANDLED_ALL;\r\n}\r\nstatic enum event_result\r\nparse_tracepoint_event(struct perf_evlist *evlist, const char **strp,\r\nstruct perf_event_attr *attr)\r\n{\r\nconst char *evt_name;\r\nchar *flags = NULL, *comma_loc;\r\nchar sys_name[MAX_EVENT_LENGTH];\r\nunsigned int sys_length, evt_length;\r\nif (debugfs_valid_mountpoint(debugfs_path))\r\nreturn 0;\r\nevt_name = strchr(*strp, ':');\r\nif (!evt_name)\r\nreturn EVT_FAILED;\r\nsys_length = evt_name - *strp;\r\nif (sys_length >= MAX_EVENT_LENGTH)\r\nreturn 0;\r\nstrncpy(sys_name, *strp, sys_length);\r\nsys_name[sys_length] = '\0';\r\nevt_name = evt_name + 1;\r\ncomma_loc = strchr(evt_name, ',');\r\nif (comma_loc) {\r\nevt_name = strndup(evt_name, comma_loc - evt_name);\r\n}\r\nflags = strchr(evt_name, ':');\r\nif (flags) {\r\nevt_name = strndup(evt_name, flags - evt_name);\r\nflags++;\r\n}\r\nevt_length = strlen(evt_name);\r\nif (evt_length >= MAX_EVENT_LENGTH)\r\nreturn EVT_FAILED;\r\nif (strpbrk(evt_name, "*?")) {\r\n*strp += strlen(sys_name) + evt_length + 1;\r\nreturn parse_multiple_tracepoint_event(evlist, sys_name,\r\nevt_name, flags);\r\n} else {\r\nreturn parse_single_tracepoint_event(sys_name, evt_name,\r\nevt_length, attr, strp);\r\n}\r\n}\r\nstatic enum event_result\r\nparse_breakpoint_type(const char *type, const char **strp,\r\nstruct perf_event_attr *attr)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (!type[i])\r\nbreak;\r\nswitch (type[i]) {\r\ncase 'r':\r\nattr->bp_type |= HW_BREAKPOINT_R;\r\nbreak;\r\ncase 'w':\r\nattr->bp_type |= HW_BREAKPOINT_W;\r\nbreak;\r\ncase 'x':\r\nattr->bp_type |= HW_BREAKPOINT_X;\r\nbreak;\r\ndefault:\r\nreturn EVT_FAILED;\r\n}\r\n}\r\nif (!attr->bp_type)\r\nattr->bp_type = HW_BREAKPOINT_R | HW_BREAKPOINT_W;\r\n*strp = type + i;\r\nreturn EVT_HANDLED;\r\n}\r\nstatic enum event_result\r\nparse_breakpoint_event(const char **strp, struct perf_event_attr *attr)\r\n{\r\nconst char *target;\r\nconst char *type;\r\nchar *endaddr;\r\nu64 addr;\r\nenum event_result err;\r\ntarget = strchr(*strp, ':');\r\nif (!target)\r\nreturn EVT_FAILED;\r\nif (strncmp(*strp, "mem", target - *strp) != 0)\r\nreturn EVT_FAILED;\r\ntarget++;\r\naddr = strtoull(target, &endaddr, 0);\r\nif (target == endaddr)\r\nreturn EVT_FAILED;\r\nattr->bp_addr = addr;\r\n*strp = endaddr;\r\ntype = strchr(target, ':');\r\nif (!type) {\r\nattr->bp_type = HW_BREAKPOINT_R | HW_BREAKPOINT_W;\r\n} else {\r\nerr = parse_breakpoint_type(++type, strp, attr);\r\nif (err == EVT_FAILED)\r\nreturn EVT_FAILED;\r\n}\r\nif (attr->bp_type == HW_BREAKPOINT_X)\r\nattr->bp_len = sizeof(long);\r\nelse\r\nattr->bp_len = HW_BREAKPOINT_LEN_4;\r\nattr->type = PERF_TYPE_BREAKPOINT;\r\nreturn EVT_HANDLED;\r\n}\r\nstatic int check_events(const char *str, unsigned int i)\r\n{\r\nint n;\r\nn = strlen(event_symbols[i].symbol);\r\nif (!strncasecmp(str, event_symbols[i].symbol, n))\r\nreturn n;\r\nn = strlen(event_symbols[i].alias);\r\nif (n) {\r\nif (!strncasecmp(str, event_symbols[i].alias, n))\r\nreturn n;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum event_result\r\nparse_symbolic_event(const char **strp, struct perf_event_attr *attr)\r\n{\r\nconst char *str = *strp;\r\nunsigned int i;\r\nint n;\r\nfor (i = 0; i < ARRAY_SIZE(event_symbols); i++) {\r\nn = check_events(str, i);\r\nif (n > 0) {\r\nattr->type = event_symbols[i].type;\r\nattr->config = event_symbols[i].config;\r\n*strp = str + n;\r\nreturn EVT_HANDLED;\r\n}\r\n}\r\nreturn EVT_FAILED;\r\n}\r\nstatic enum event_result\r\nparse_raw_event(const char **strp, struct perf_event_attr *attr)\r\n{\r\nconst char *str = *strp;\r\nu64 config;\r\nint n;\r\nif (*str != 'r')\r\nreturn EVT_FAILED;\r\nn = hex2u64(str + 1, &config);\r\nif (n > 0) {\r\nconst char *end = str + n + 1;\r\nif (*end != '\0' && *end != ',' && *end != ':')\r\nreturn EVT_FAILED;\r\n*strp = end;\r\nattr->type = PERF_TYPE_RAW;\r\nattr->config = config;\r\nreturn EVT_HANDLED;\r\n}\r\nreturn EVT_FAILED;\r\n}\r\nstatic enum event_result\r\nparse_numeric_event(const char **strp, struct perf_event_attr *attr)\r\n{\r\nconst char *str = *strp;\r\nchar *endp;\r\nunsigned long type;\r\nu64 config;\r\ntype = strtoul(str, &endp, 0);\r\nif (endp > str && type < PERF_TYPE_MAX && *endp == ':') {\r\nstr = endp + 1;\r\nconfig = strtoul(str, &endp, 0);\r\nif (endp > str) {\r\nattr->type = type;\r\nattr->config = config;\r\n*strp = endp;\r\nreturn EVT_HANDLED;\r\n}\r\n}\r\nreturn EVT_FAILED;\r\n}\r\nstatic int\r\nparse_event_modifier(const char **strp, struct perf_event_attr *attr)\r\n{\r\nconst char *str = *strp;\r\nint exclude = 0;\r\nint eu = 0, ek = 0, eh = 0, precise = 0;\r\nif (!*str)\r\nreturn 0;\r\nif (*str == ',')\r\nreturn 0;\r\nif (*str++ != ':')\r\nreturn -1;\r\nwhile (*str) {\r\nif (*str == 'u') {\r\nif (!exclude)\r\nexclude = eu = ek = eh = 1;\r\neu = 0;\r\n} else if (*str == 'k') {\r\nif (!exclude)\r\nexclude = eu = ek = eh = 1;\r\nek = 0;\r\n} else if (*str == 'h') {\r\nif (!exclude)\r\nexclude = eu = ek = eh = 1;\r\neh = 0;\r\n} else if (*str == 'p') {\r\nprecise++;\r\n} else\r\nbreak;\r\n++str;\r\n}\r\nif (str < *strp + 2)\r\nreturn -1;\r\n*strp = str;\r\nattr->exclude_user = eu;\r\nattr->exclude_kernel = ek;\r\nattr->exclude_hv = eh;\r\nattr->precise_ip = precise;\r\nreturn 0;\r\n}\r\nstatic enum event_result\r\nparse_event_symbols(struct perf_evlist *evlist, const char **str,\r\nstruct perf_event_attr *attr)\r\n{\r\nenum event_result ret;\r\nret = parse_tracepoint_event(evlist, str, attr);\r\nif (ret != EVT_FAILED)\r\ngoto modifier;\r\nret = parse_raw_event(str, attr);\r\nif (ret != EVT_FAILED)\r\ngoto modifier;\r\nret = parse_numeric_event(str, attr);\r\nif (ret != EVT_FAILED)\r\ngoto modifier;\r\nret = parse_symbolic_event(str, attr);\r\nif (ret != EVT_FAILED)\r\ngoto modifier;\r\nret = parse_generic_hw_event(str, attr);\r\nif (ret != EVT_FAILED)\r\ngoto modifier;\r\nret = parse_breakpoint_event(str, attr);\r\nif (ret != EVT_FAILED)\r\ngoto modifier;\r\nfprintf(stderr, "invalid or unsupported event: '%s'\n", *str);\r\nfprintf(stderr, "Run 'perf list' for a list of valid events\n");\r\nreturn EVT_FAILED;\r\nmodifier:\r\nif (parse_event_modifier(str, attr) < 0) {\r\nfprintf(stderr, "invalid event modifier: '%s'\n", *str);\r\nfprintf(stderr, "Run 'perf list' for a list of valid events and modifiers\n");\r\nreturn EVT_FAILED;\r\n}\r\nreturn ret;\r\n}\r\nint parse_events(struct perf_evlist *evlist , const char *str, int unset __used)\r\n{\r\nstruct perf_event_attr attr;\r\nenum event_result ret;\r\nconst char *ostr;\r\nfor (;;) {\r\nostr = str;\r\nmemset(&attr, 0, sizeof(attr));\r\nret = parse_event_symbols(evlist, &str, &attr);\r\nif (ret == EVT_FAILED)\r\nreturn -1;\r\nif (!(*str == 0 || *str == ',' || isspace(*str)))\r\nreturn -1;\r\nif (ret != EVT_HANDLED_ALL) {\r\nstruct perf_evsel *evsel;\r\nevsel = perf_evsel__new(&attr, evlist->nr_entries);\r\nif (evsel == NULL)\r\nreturn -1;\r\nperf_evlist__add(evlist, evsel);\r\nevsel->name = calloc(str - ostr + 1, 1);\r\nif (!evsel->name)\r\nreturn -1;\r\nstrncpy(evsel->name, ostr, str - ostr);\r\n}\r\nif (*str == 0)\r\nbreak;\r\nif (*str == ',')\r\n++str;\r\nwhile (isspace(*str))\r\n++str;\r\n}\r\nreturn 0;\r\n}\r\nint parse_events_option(const struct option *opt, const char *str,\r\nint unset __used)\r\n{\r\nstruct perf_evlist *evlist = *(struct perf_evlist **)opt->value;\r\nreturn parse_events(evlist, str, unset);\r\n}\r\nint parse_filter(const struct option *opt, const char *str,\r\nint unset __used)\r\n{\r\nstruct perf_evlist *evlist = *(struct perf_evlist **)opt->value;\r\nstruct perf_evsel *last = NULL;\r\nif (evlist->nr_entries > 0)\r\nlast = list_entry(evlist->entries.prev, struct perf_evsel, node);\r\nif (last == NULL || last->attr.type != PERF_TYPE_TRACEPOINT) {\r\nfprintf(stderr,\r\n"-F option should follow a -e tracepoint option\n");\r\nreturn -1;\r\n}\r\nlast->filter = strdup(str);\r\nif (last->filter == NULL) {\r\nfprintf(stderr, "not enough memory to hold filter string\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid print_tracepoint_events(const char *subsys_glob, const char *event_glob)\r\n{\r\nDIR *sys_dir, *evt_dir;\r\nstruct dirent *sys_next, *evt_next, sys_dirent, evt_dirent;\r\nchar evt_path[MAXPATHLEN];\r\nchar dir_path[MAXPATHLEN];\r\nif (debugfs_valid_mountpoint(debugfs_path))\r\nreturn;\r\nsys_dir = opendir(debugfs_path);\r\nif (!sys_dir)\r\nreturn;\r\nfor_each_subsystem(sys_dir, sys_dirent, sys_next) {\r\nif (subsys_glob != NULL &&\r\n!strglobmatch(sys_dirent.d_name, subsys_glob))\r\ncontinue;\r\nsnprintf(dir_path, MAXPATHLEN, "%s/%s", debugfs_path,\r\nsys_dirent.d_name);\r\nevt_dir = opendir(dir_path);\r\nif (!evt_dir)\r\ncontinue;\r\nfor_each_event(sys_dirent, evt_dir, evt_dirent, evt_next) {\r\nif (event_glob != NULL &&\r\n!strglobmatch(evt_dirent.d_name, event_glob))\r\ncontinue;\r\nsnprintf(evt_path, MAXPATHLEN, "%s:%s",\r\nsys_dirent.d_name, evt_dirent.d_name);\r\nprintf(" %-50s [%s]\n", evt_path,\r\nevent_type_descriptors[PERF_TYPE_TRACEPOINT]);\r\n}\r\nclosedir(evt_dir);\r\n}\r\nclosedir(sys_dir);\r\n}\r\nint is_valid_tracepoint(const char *event_string)\r\n{\r\nDIR *sys_dir, *evt_dir;\r\nstruct dirent *sys_next, *evt_next, sys_dirent, evt_dirent;\r\nchar evt_path[MAXPATHLEN];\r\nchar dir_path[MAXPATHLEN];\r\nif (debugfs_valid_mountpoint(debugfs_path))\r\nreturn 0;\r\nsys_dir = opendir(debugfs_path);\r\nif (!sys_dir)\r\nreturn 0;\r\nfor_each_subsystem(sys_dir, sys_dirent, sys_next) {\r\nsnprintf(dir_path, MAXPATHLEN, "%s/%s", debugfs_path,\r\nsys_dirent.d_name);\r\nevt_dir = opendir(dir_path);\r\nif (!evt_dir)\r\ncontinue;\r\nfor_each_event(sys_dirent, evt_dir, evt_dirent, evt_next) {\r\nsnprintf(evt_path, MAXPATHLEN, "%s:%s",\r\nsys_dirent.d_name, evt_dirent.d_name);\r\nif (!strcmp(evt_path, event_string)) {\r\nclosedir(evt_dir);\r\nclosedir(sys_dir);\r\nreturn 1;\r\n}\r\n}\r\nclosedir(evt_dir);\r\n}\r\nclosedir(sys_dir);\r\nreturn 0;\r\n}\r\nvoid print_events_type(u8 type)\r\n{\r\nstruct event_symbol *syms = event_symbols;\r\nunsigned int i;\r\nchar name[64];\r\nfor (i = 0; i < ARRAY_SIZE(event_symbols); i++, syms++) {\r\nif (type != syms->type)\r\ncontinue;\r\nif (strlen(syms->alias))\r\nsnprintf(name, sizeof(name), "%s OR %s",\r\nsyms->symbol, syms->alias);\r\nelse\r\nsnprintf(name, sizeof(name), "%s", syms->symbol);\r\nprintf(" %-50s [%s]\n", name,\r\nevent_type_descriptors[type]);\r\n}\r\n}\r\nint print_hwcache_events(const char *event_glob)\r\n{\r\nunsigned int type, op, i, printed = 0;\r\nfor (type = 0; type < PERF_COUNT_HW_CACHE_MAX; type++) {\r\nfor (op = 0; op < PERF_COUNT_HW_CACHE_OP_MAX; op++) {\r\nif (!is_cache_op_valid(type, op))\r\ncontinue;\r\nfor (i = 0; i < PERF_COUNT_HW_CACHE_RESULT_MAX; i++) {\r\nchar *name = event_cache_name(type, op, i);\r\nif (event_glob != NULL && !strglobmatch(name, event_glob))\r\ncontinue;\r\nprintf(" %-50s [%s]\n", name,\r\nevent_type_descriptors[PERF_TYPE_HW_CACHE]);\r\n++printed;\r\n}\r\n}\r\n}\r\nreturn printed;\r\n}\r\nvoid print_events(const char *event_glob)\r\n{\r\nunsigned int i, type, prev_type = -1, printed = 0, ntypes_printed = 0;\r\nstruct event_symbol *syms = event_symbols;\r\nchar name[MAX_NAME_LEN];\r\nprintf("\n");\r\nprintf("List of pre-defined events (to be used in -e):\n");\r\nfor (i = 0; i < ARRAY_SIZE(event_symbols); i++, syms++) {\r\ntype = syms->type;\r\nif (type != prev_type && printed) {\r\nprintf("\n");\r\nprinted = 0;\r\nntypes_printed++;\r\n}\r\nif (event_glob != NULL &&\r\n!(strglobmatch(syms->symbol, event_glob) ||\r\n(syms->alias && strglobmatch(syms->alias, event_glob))))\r\ncontinue;\r\nif (strlen(syms->alias))\r\nsnprintf(name, MAX_NAME_LEN, "%s OR %s", syms->symbol, syms->alias);\r\nelse\r\nstrncpy(name, syms->symbol, MAX_NAME_LEN);\r\nprintf(" %-50s [%s]\n", name,\r\nevent_type_descriptors[type]);\r\nprev_type = type;\r\n++printed;\r\n}\r\nif (ntypes_printed) {\r\nprinted = 0;\r\nprintf("\n");\r\n}\r\nprint_hwcache_events(event_glob);\r\nif (event_glob != NULL)\r\nreturn;\r\nprintf("\n");\r\nprintf(" %-50s [%s]\n",\r\n"rNNN (see 'perf list --help' on how to encode it)",\r\nevent_type_descriptors[PERF_TYPE_RAW]);\r\nprintf("\n");\r\nprintf(" %-50s [%s]\n",\r\n"mem:<addr>[:access]",\r\nevent_type_descriptors[PERF_TYPE_BREAKPOINT]);\r\nprintf("\n");\r\nprint_tracepoint_events(NULL, NULL);\r\n}
