static struct rar_device *alloc_rar_device(void)\r\n{\r\nif (my_rar_device.allocated)\r\nreturn NULL;\r\nmy_rar_device.allocated = 1;\r\nreturn &my_rar_device;\r\n}\r\nstatic void free_rar_device(struct rar_device *rar)\r\n{\r\npci_dev_put(rar->rar_dev);\r\nrar->allocated = 0;\r\n}\r\nstatic struct rar_device *_rar_to_device(int rar, int *off)\r\n{\r\nif (rar >= 0 && rar < MRST_NUM_RAR) {\r\n*off = rar;\r\nreturn &my_rar_device;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct rar_device *rar_to_device(int rar, int *off)\r\n{\r\nstruct rar_device *rar_dev = _rar_to_device(rar, off);\r\nif (rar_dev == NULL || !rar_dev->registered)\r\nreturn NULL;\r\nreturn rar_dev;\r\n}\r\nstatic struct client *rar_to_client(int rar)\r\n{\r\nint idx;\r\nstruct rar_device *r = _rar_to_device(rar, &idx);\r\nif (r != NULL)\r\nreturn &r->client[idx];\r\nreturn NULL;\r\n}\r\nstatic int rar_read_addr(struct pci_dev *pdev, int offset, dma_addr_t *addr)\r\n{\r\nint result;\r\nu32 addr32;\r\nu32 const message =\r\n(LNC_MESSAGE_READ_OPCODE << 24)\r\n| (LNC_BUNIT_PORT << 16)\r\n| (offset << 8)\r\n| (LNC_MESSAGE_BYTE_WRITE_ENABLES << 4);\r\ndev_dbg(&pdev->dev, "Offset for 'get' LNC MSG is %x\n", offset);\r\nmutex_lock(&lnc_reg_mutex);\r\nresult = pci_write_config_dword(pdev, LNC_MCR_OFFSET, message);\r\nif (!result) {\r\nresult = pci_read_config_dword(pdev, LNC_MDR_OFFSET, &addr32);\r\n*addr = (dma_addr_t)addr32;\r\n}\r\nmutex_unlock(&lnc_reg_mutex);\r\nreturn result;\r\n}\r\nstatic int rar_set_addr(struct pci_dev *pdev,\r\nint offset,\r\ndma_addr_t addr)\r\n{\r\nint result;\r\nu32 const message = (LNC_MESSAGE_WRITE_OPCODE << 24)\r\n| (LNC_BUNIT_PORT << 16)\r\n| (offset << 8)\r\n| (LNC_MESSAGE_BYTE_WRITE_ENABLES << 4);\r\nmutex_lock(&lnc_reg_mutex);\r\nresult = pci_write_config_dword(pdev, LNC_MDR_OFFSET, addr);\r\nif (!result)\r\nresult = pci_write_config_dword(pdev, LNC_MCR_OFFSET, message);\r\nmutex_unlock(&lnc_reg_mutex);\r\nreturn result;\r\n}\r\nstatic int init_rar_params(struct rar_device *rar)\r\n{\r\nstruct pci_dev *pdev = rar->rar_dev;\r\nunsigned int i;\r\nint result = 0;\r\nint offset = 0x10;\r\nfor (i = 0; i < MRST_NUM_RAR; ++i) {\r\nstruct rar_addr *addr = &rar->rar_addr[i];\r\nresult = rar_read_addr(pdev, offset++, &addr->low);\r\nif (result != 0)\r\nreturn result;\r\nresult = rar_read_addr(pdev, offset++, &addr->high);\r\nif (result != 0)\r\nreturn result;\r\naddr->low &= (dma_addr_t)0xfffffc00u;\r\nif ((addr->high & 0xfffffc00u) == 0)\r\naddr->high = 0;\r\nelse\r\naddr->high |= 0x3ffu;\r\n}\r\nif (result == 0) {\r\nfor (i = 0; i != MRST_NUM_RAR; ++i) {\r\ndev_info(&pdev->dev, "BRAR[%u] bus address range = "\r\n"[%lx, %lx]\n", i,\r\n(unsigned long)rar->rar_addr[i].low,\r\n(unsigned long)rar->rar_addr[i].high);\r\n}\r\n}\r\nreturn result;\r\n}\r\nint rar_get_address(int rar_index, dma_addr_t *start, dma_addr_t *end)\r\n{\r\nint idx;\r\nstruct rar_device *rar = rar_to_device(rar_index, &idx);\r\nif (rar == NULL) {\r\nWARN_ON(1);\r\nreturn -ENODEV;\r\n}\r\n*start = rar->rar_addr[idx].low;\r\n*end = rar->rar_addr[idx].high;\r\nreturn 0;\r\n}\r\nint rar_lock(int rar_index)\r\n{\r\nstruct rar_device *rar;\r\nint result;\r\nint idx;\r\ndma_addr_t low, high;\r\nrar = rar_to_device(rar_index, &idx);\r\nif (rar == NULL) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nlow = rar->rar_addr[idx].low & 0xfffffc00u;\r\nhigh = rar->rar_addr[idx].high & 0xfffffc00u;\r\nif (rar_index == RAR_TYPE_VIDEO) {\r\nlow |= 0x00000009;\r\nhigh |= 0x00000015;\r\n} else if (rar_index == RAR_TYPE_AUDIO) {\r\nlow |= 0x00000008;\r\nhigh |= 0x00000018;\r\n} else\r\nhigh |= 0x00000018;\r\nresult = rar_set_addr(rar->rar_dev,\r\n2 * idx, low);\r\nif (result == 0)\r\nresult = rar_set_addr(rar->rar_dev,\r\n2 * idx + 1, high);\r\nreturn result;\r\n}\r\nint register_rar(int num, int (*callback)(unsigned long data),\r\nunsigned long data)\r\n{\r\nstruct rar_device *rar;\r\nstruct client *c;\r\nint idx;\r\nint retval = 0;\r\nmutex_lock(&rar_mutex);\r\nc = rar_to_client(num);\r\nif (c == NULL) {\r\nretval = -ERANGE;\r\ngoto done;\r\n}\r\nif (c->busy) {\r\nretval = -EBUSY;\r\ngoto done;\r\n}\r\nc->busy = 1;\r\nrar = rar_to_device(num, &idx);\r\nif (rar) {\r\n(*callback)(data);\r\ngoto done;\r\n}\r\nc->callback = callback;\r\nc->driver_priv = data;\r\ndone:\r\nmutex_unlock(&rar_mutex);\r\nreturn retval;\r\n}\r\nvoid unregister_rar(int num)\r\n{\r\nstruct client *c;\r\nmutex_lock(&rar_mutex);\r\nc = rar_to_client(num);\r\nif (c == NULL || !c->busy)\r\nWARN_ON(1);\r\nelse\r\nc->busy = 0;\r\nmutex_unlock(&rar_mutex);\r\n}\r\nstatic void rar_callback(struct rar_device *rar)\r\n{\r\nstruct client *c = &rar->client[0];\r\nint i;\r\nmutex_lock(&rar_mutex);\r\nrar->registered = 1;\r\nfor (i = 0; i < MRST_NUM_RAR; i++) {\r\nif (c->callback && c->busy) {\r\nc->callback(c->driver_priv);\r\nc->callback = NULL;\r\n}\r\nc++;\r\n}\r\nmutex_unlock(&rar_mutex);\r\n}\r\nstatic int rar_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint error;\r\nstruct rar_device *rar;\r\ndev_dbg(&dev->dev, "PCI probe starting\n");\r\nrar = alloc_rar_device();\r\nif (rar == NULL)\r\nreturn -EBUSY;\r\nerror = pci_enable_device(dev);\r\nif (error) {\r\ndev_err(&dev->dev,\r\n"Error enabling RAR register PCI device\n");\r\ngoto end_function;\r\n}\r\nrar->rar_dev = pci_dev_get(dev);\r\npci_set_drvdata(dev, rar);\r\nerror = init_rar_params(rar);\r\nif (error) {\r\npci_disable_device(dev);\r\ndev_err(&dev->dev, "Error retrieving RAR addresses\n");\r\ngoto end_function;\r\n}\r\nrar_callback(rar);\r\nreturn 0;\r\nend_function:\r\nfree_rar_device(rar);\r\nreturn error;\r\n}\r\nstatic int __init rar_init_handler(void)\r\n{\r\nreturn pci_register_driver(&rar_pci_driver);\r\n}\r\nstatic void __exit rar_exit_handler(void)\r\n{\r\npci_unregister_driver(&rar_pci_driver);\r\n}
