static u8 tda10023_readreg (struct tda10023_state* state, u8 reg)\r\n{\r\nu8 b0 [] = { reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\nint ret;\r\nret = i2c_transfer (state->i2c, msg, 2);\r\nif (ret != 2) {\r\nint num = state->frontend.dvb ? state->frontend.dvb->num : -1;\r\nprintk(KERN_ERR "DVB: TDA10023(%d): %s: readreg error "\r\n"(reg == 0x%02x, ret == %i)\n",\r\nnum, __func__, reg, ret);\r\n}\r\nreturn b1[0];\r\n}\r\nstatic int tda10023_writereg (struct tda10023_state* state, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\nint ret;\r\nret = i2c_transfer (state->i2c, &msg, 1);\r\nif (ret != 1) {\r\nint num = state->frontend.dvb ? state->frontend.dvb->num : -1;\r\nprintk(KERN_ERR "DVB: TDA10023(%d): %s, writereg error "\r\n"(reg == 0x%02x, val == 0x%02x, ret == %i)\n",\r\nnum, __func__, reg, data, ret);\r\n}\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic int tda10023_writebit (struct tda10023_state* state, u8 reg, u8 mask,u8 data)\r\n{\r\nif (mask==0xff)\r\nreturn tda10023_writereg(state, reg, data);\r\nelse {\r\nu8 val;\r\nval=tda10023_readreg(state,reg);\r\nval&=~mask;\r\nval|=(data&mask);\r\nreturn tda10023_writereg(state, reg, val);\r\n}\r\n}\r\nstatic void tda10023_writetab(struct tda10023_state* state, u8* tab)\r\n{\r\nu8 r,m,v;\r\nwhile (1) {\r\nr=*tab++;\r\nm=*tab++;\r\nv=*tab++;\r\nif (r==0xff) {\r\nif (m==0xff)\r\nbreak;\r\nelse\r\nmsleep(m);\r\n}\r\nelse\r\ntda10023_writebit(state,r,m,v);\r\n}\r\n}\r\nstatic int lock_tuner(struct tda10023_state* state)\r\n{\r\nu8 buf[2] = { 0x0f, 0xc0 };\r\nstruct i2c_msg msg = {.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\r\nif(i2c_transfer(state->i2c, &msg, 1) != 1)\r\n{\r\nprintk("tda10023: lock tuner fails\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int unlock_tuner(struct tda10023_state* state)\r\n{\r\nu8 buf[2] = { 0x0f, 0x40 };\r\nstruct i2c_msg msg_post={.addr=state->config->demod_address, .flags=0, .buf=buf, .len=2};\r\nif(i2c_transfer(state->i2c, &msg_post, 1) != 1)\r\n{\r\nprintk("tda10023: unlock tuner fails\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10023_setup_reg0 (struct tda10023_state* state, u8 reg0)\r\n{\r\nreg0 |= state->reg0 & 0x63;\r\ntda10023_writereg (state, 0x00, reg0 & 0xfe);\r\ntda10023_writereg (state, 0x00, reg0 | 0x01);\r\nstate->reg0 = reg0;\r\nreturn 0;\r\n}\r\nstatic int tda10023_set_symbolrate (struct tda10023_state* state, u32 sr)\r\n{\r\ns32 BDR;\r\ns32 BDRI;\r\ns16 SFIL=0;\r\nu16 NDEC = 0;\r\nu32 sysclk_x_10 = state->sysclk * 10;\r\nif (sr < (u32)(sysclk_x_10/984)) {\r\nNDEC=3;\r\nSFIL=1;\r\n} else if (sr < (u32)(sysclk_x_10/640)) {\r\nNDEC=3;\r\nSFIL=0;\r\n} else if (sr < (u32)(sysclk_x_10/492)) {\r\nNDEC=2;\r\nSFIL=1;\r\n} else if (sr < (u32)(sysclk_x_10/320)) {\r\nNDEC=2;\r\nSFIL=0;\r\n} else if (sr < (u32)(sysclk_x_10/246)) {\r\nNDEC=1;\r\nSFIL=1;\r\n} else if (sr < (u32)(sysclk_x_10/160)) {\r\nNDEC=1;\r\nSFIL=0;\r\n} else if (sr < (u32)(sysclk_x_10/123)) {\r\nNDEC=0;\r\nSFIL=1;\r\n}\r\nBDRI = (state->sysclk)*16;\r\nBDRI>>=NDEC;\r\nBDRI +=sr/2;\r\nBDRI /=sr;\r\nif (BDRI>255)\r\nBDRI=255;\r\n{\r\nu64 BDRX;\r\nBDRX=1<<(24+NDEC);\r\nBDRX*=sr;\r\ndo_div(BDRX, state->sysclk);\r\nBDR=(s32)BDRX;\r\n}\r\ndprintk("Symbolrate %i, BDR %i BDRI %i, NDEC %i\n",\r\nsr, BDR, BDRI, NDEC);\r\ntda10023_writebit (state, 0x03, 0xc0, NDEC<<6);\r\ntda10023_writereg (state, 0x0a, BDR&255);\r\ntda10023_writereg (state, 0x0b, (BDR>>8)&255);\r\ntda10023_writereg (state, 0x0c, (BDR>>16)&31);\r\ntda10023_writereg (state, 0x0d, BDRI);\r\ntda10023_writereg (state, 0x3d, (SFIL<<7));\r\nreturn 0;\r\n}\r\nstatic int tda10023_init (struct dvb_frontend *fe)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nu8 tda10023_inittab[] = {\r\n0x2a, 0xff, 0x02,\r\n0xff, 0x64, 0x00,\r\n0x2a, 0xff, 0x03,\r\n0xff, 0x64, 0x00,\r\n0x28, 0xff, (state->pll_m-1),\r\n0x29, 0xff, ((state->pll_p-1)<<6)|(state->pll_n-1),\r\n0x00, 0xff, REG0_INIT_VAL,\r\n0x2a, 0xff, 0x08,\r\n0xff, 0x64, 0x00,\r\n0x1f, 0xff, 0x00,\r\n0xff, 0x64, 0x00,\r\n0xe6, 0x0c, 0x04,\r\n0x10, 0xc0, 0x80,\r\n0x0e, 0xff, 0x82,\r\n0x03, 0x08, 0x08,\r\n0x2e, 0xbf, 0x30,\r\n0x01, 0xff, 0x30,\r\n0x1e, 0x84, 0x84,\r\n0x1b, 0xff, 0xc8,\r\n0x3b, 0xff, 0xff,\r\n0x3c, 0xff, 0x00,\r\n0x34, 0xff, 0x00,\r\n0x35, 0xff, 0xff,\r\n0x36, 0xff, 0x00,\r\n0x06, 0xff, 0x7f,\r\n0x1c, 0x30, 0x30,\r\n0x37, 0xff, 0xf6,\r\n0x38, 0xff, 0xff,\r\n0x02, 0xff, 0x93,\r\n0x2d, 0xff, 0xf6,\r\n0x04, 0x10, 0x00,\r\n0x12, 0xff, TDA10023_OUTPUT_MODE_PARALLEL_B,\r\n0x2b, 0x01, 0xa1,\r\n0x20, 0xff, 0x04,\r\n0x2c, 0xff, 0x0d,\r\n0xc4, 0xff, 0x00,\r\n0xc3, 0x30, 0x00,\r\n0xb5, 0xff, 0x19,\r\n0x00, 0x03, 0x01,\r\n0x00, 0x03, 0x03,\r\n0xff, 0x64, 0x00,\r\n0xff, 0xff, 0xff\r\n};\r\ndprintk("DVB: TDA10023(%d): init chip\n", fe->dvb->num);\r\nif (state->config->deltaf) {\r\ntda10023_inittab[80] = (state->config->deltaf & 0xff);\r\ntda10023_inittab[83] = (state->config->deltaf >> 8);\r\n}\r\nif (state->config->output_mode)\r\ntda10023_inittab[95] = state->config->output_mode;\r\ntda10023_writetab(state, tda10023_inittab);\r\nreturn 0;\r\n}\r\nstatic int tda10023_set_parameters (struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nstatic int qamvals[6][6] = {\r\n{ (5<<2), 0x78, 0x8c, 0x96, 0x78, 0x4c },\r\n{ (0<<2), 0x87, 0xa2, 0x91, 0x8c, 0x57 },\r\n{ (1<<2), 0x64, 0x74, 0x96, 0x8c, 0x57 },\r\n{ (2<<2), 0x46, 0x43, 0x6a, 0x6a, 0x44 },\r\n{ (3<<2), 0x36, 0x34, 0x7e, 0x78, 0x4c },\r\n{ (4<<2), 0x26, 0x23, 0x6c, 0x5c, 0x3c },\r\n};\r\nint qam = p->u.qam.modulation;\r\nif (qam < 0 || qam > 5)\r\nreturn -EINVAL;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe, p);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\ntda10023_set_symbolrate (state, p->u.qam.symbol_rate);\r\ntda10023_writereg (state, 0x05, qamvals[qam][1]);\r\ntda10023_writereg (state, 0x08, qamvals[qam][2]);\r\ntda10023_writereg (state, 0x09, qamvals[qam][3]);\r\ntda10023_writereg (state, 0xb4, qamvals[qam][4]);\r\ntda10023_writereg (state, 0xb6, qamvals[qam][5]);\r\ntda10023_writebit (state, 0x04, 0x40, 0x40);\r\ntda10023_setup_reg0 (state, qamvals[qam][0]);\r\nreturn 0;\r\n}\r\nstatic int tda10023_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nint sync;\r\n*status = 0;\r\nsync = tda10023_readreg (state, 0x11);\r\nif (sync & 2)\r\n*status |= FE_HAS_SIGNAL|FE_HAS_CARRIER;\r\nif (sync & 4)\r\n*status |= FE_HAS_SYNC|FE_HAS_VITERBI;\r\nif (sync & 8)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int tda10023_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nu8 a,b,c;\r\na=tda10023_readreg(state, 0x14);\r\nb=tda10023_readreg(state, 0x15);\r\nc=tda10023_readreg(state, 0x16)&0xf;\r\ntda10023_writebit (state, 0x10, 0xc0, 0x00);\r\n*ber = a | (b<<8)| (c<<16);\r\nreturn 0;\r\n}\r\nstatic int tda10023_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nu8 ifgain=tda10023_readreg(state, 0x2f);\r\nu16 gain = ((255-tda10023_readreg(state, 0x17))) + (255-ifgain)/16;\r\nif (gain>0x90)\r\ngain=gain+2*(gain-0x90);\r\nif (gain>255)\r\ngain=255;\r\n*strength = (gain<<8)|gain;\r\nreturn 0;\r\n}\r\nstatic int tda10023_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nu8 quality = ~tda10023_readreg(state, 0x18);\r\n*snr = (quality << 8) | quality;\r\nreturn 0;\r\n}\r\nstatic int tda10023_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nu8 a,b,c,d;\r\na= tda10023_readreg (state, 0x74);\r\nb= tda10023_readreg (state, 0x75);\r\nc= tda10023_readreg (state, 0x76);\r\nd= tda10023_readreg (state, 0x77);\r\n*ucblocks = a | (b<<8)|(c<<16)|(d<<24);\r\ntda10023_writebit (state, 0x10, 0x20,0x00);\r\ntda10023_writebit (state, 0x10, 0x20,0x20);\r\ntda10023_writebit (state, 0x13, 0x01, 0x00);\r\nreturn 0;\r\n}\r\nstatic int tda10023_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nint sync,inv;\r\ns8 afc = 0;\r\nsync = tda10023_readreg(state, 0x11);\r\nafc = tda10023_readreg(state, 0x19);\r\ninv = tda10023_readreg(state, 0x04);\r\nif (verbose) {\r\nprintk(sync & 2 ? "DVB: TDA10023(%d): AFC (%d) %dHz\n" :\r\n"DVB: TDA10023(%d): [AFC (%d) %dHz]\n",\r\nstate->frontend.dvb->num, afc,\r\n-((s32)p->u.qam.symbol_rate * afc) >> 10);\r\n}\r\np->inversion = (inv&0x20?0:1);\r\np->u.qam.modulation = ((state->reg0 >> 2) & 7) + QAM_16;\r\np->u.qam.fec_inner = FEC_NONE;\r\np->frequency = ((p->frequency + 31250) / 62500) * 62500;\r\nif (sync & 2)\r\np->frequency -= ((s32)p->u.qam.symbol_rate * afc) >> 10;\r\nreturn 0;\r\n}\r\nstatic int tda10023_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\ntda10023_writereg (state, 0x1b, 0x02);\r\ntda10023_writereg (state, 0x00, 0x80);\r\nreturn 0;\r\n}\r\nstatic int tda10023_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nlock_tuner(state);\r\n} else {\r\nunlock_tuner(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tda10023_release(struct dvb_frontend* fe)\r\n{\r\nstruct tda10023_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *tda10023_attach(const struct tda10023_config *config,\r\nstruct i2c_adapter *i2c,\r\nu8 pwm)\r\n{\r\nstruct tda10023_state* state = NULL;\r\nstate = kzalloc(sizeof(struct tda10023_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\ntda10023_writereg (state, 0x00, 0x33);\r\nif ((tda10023_readreg(state, 0x1a) & 0xf0) != 0x70) goto error;\r\nmemcpy(&state->frontend.ops, &tda10023_ops, sizeof(struct dvb_frontend_ops));\r\nstate->pwm = pwm;\r\nstate->reg0 = REG0_INIT_VAL;\r\nif (state->config->xtal) {\r\nstate->xtal = state->config->xtal;\r\nstate->pll_m = state->config->pll_m;\r\nstate->pll_p = state->config->pll_p;\r\nstate->pll_n = state->config->pll_n;\r\n} else {\r\nstate->xtal = 28920000;\r\nstate->pll_m = 8;\r\nstate->pll_p = 4;\r\nstate->pll_n = 1;\r\n}\r\nstate->sysclk = (state->xtal * state->pll_m / \\r\n(state->pll_n * state->pll_p));\r\nstate->frontend.ops.info.symbol_rate_min = (state->sysclk/2)/64;\r\nstate->frontend.ops.info.symbol_rate_max = (state->sysclk/2)/4;\r\ndprintk("DVB: TDA10023 %s: xtal:%d pll_m:%d pll_p:%d pll_n:%d\n",\r\n__func__, state->xtal, state->pll_m, state->pll_p,\r\nstate->pll_n);\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
