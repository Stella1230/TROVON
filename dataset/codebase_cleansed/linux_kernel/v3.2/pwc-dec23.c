static void build_subblock_pattern(struct pwc_dec23_private *pdec)\r\n{\r\nstatic const unsigned int initial_values[12] = {\r\n-0x526500, -0x221200, 0x221200, 0x526500,\r\n-0x3de200, 0x3de200,\r\n-0x6db480, -0x2d5d00, 0x2d5d00, 0x6db480,\r\n-0x12c200, 0x12c200\r\n};\r\nstatic const unsigned int values_derivated[12] = {\r\n0xa4ca, 0x4424, -0x4424, -0xa4ca,\r\n0x7bc4, -0x7bc4,\r\n0xdb69, 0x5aba, -0x5aba, -0xdb69,\r\n0x2584, -0x2584\r\n};\r\nunsigned int temp_values[12];\r\nint i, j;\r\nmemcpy(temp_values, initial_values, sizeof(initial_values));\r\nfor (i = 0; i < 256; i++) {\r\nfor (j = 0; j < 12; j++) {\r\npdec->table_subblock[i][j] = temp_values[j];\r\ntemp_values[j] += values_derivated[j];\r\n}\r\n}\r\n}\r\nstatic void build_bit_powermask_table(struct pwc_dec23_private *pdec)\r\n{\r\nunsigned char *p;\r\nunsigned int bit, byte, mask, val;\r\nunsigned int bitpower = 1;\r\nfor (bit = 0; bit < 8; bit++) {\r\nmask = bitpower - 1;\r\np = pdec->table_bitpowermask[bit];\r\nfor (byte = 0; byte < 256; byte++) {\r\nval = (byte & mask);\r\nif (byte & bitpower)\r\nval = -val;\r\n*p++ = val;\r\n}\r\nbitpower<<=1;\r\n}\r\n}\r\nstatic void build_table_color(const unsigned int romtable[16][8],\r\nunsigned char p0004[16][1024],\r\nunsigned char p8004[16][256])\r\n{\r\nint compression_mode, j, k, bit, pw;\r\nunsigned char *p0, *p8;\r\nconst unsigned int *r;\r\nfor (compression_mode = 0; compression_mode < 16; compression_mode++) {\r\np0 = p0004[compression_mode];\r\np8 = p8004[compression_mode];\r\nr = romtable[compression_mode];\r\nfor (j = 0; j < 8; j++, r++, p0 += 128) {\r\nfor (k = 0; k < 16; k++) {\r\nif (k == 0)\r\nbit = 1;\r\nelse if (k >= 1 && k < 3)\r\nbit = (r[0] >> 15) & 7;\r\nelse if (k >= 3 && k < 6)\r\nbit = (r[0] >> 12) & 7;\r\nelse if (k >= 6 && k < 10)\r\nbit = (r[0] >> 9) & 7;\r\nelse if (k >= 10 && k < 13)\r\nbit = (r[0] >> 6) & 7;\r\nelse if (k >= 13 && k < 15)\r\nbit = (r[0] >> 3) & 7;\r\nelse\r\nbit = (r[0]) & 7;\r\nif (k == 0)\r\n*p8++ = 8;\r\nelse\r\n*p8++ = j - bit;\r\n*p8++ = bit;\r\npw = 1 << bit;\r\np0[k + 0x00] = (1 * pw) + 0x80;\r\np0[k + 0x10] = (2 * pw) + 0x80;\r\np0[k + 0x20] = (3 * pw) + 0x80;\r\np0[k + 0x30] = (4 * pw) + 0x80;\r\np0[k + 0x40] = (-1 * pw) + 0x80;\r\np0[k + 0x50] = (-2 * pw) + 0x80;\r\np0[k + 0x60] = (-3 * pw) + 0x80;\r\np0[k + 0x70] = (-4 * pw) + 0x80;\r\n}\r\n}\r\n}\r\n}\r\nstatic void fill_table_dc00_d800(struct pwc_dec23_private *pdec)\r\n{\r\n#define SCALEBITS 15\r\n#define ONE_HALF (1UL << (SCALEBITS - 1))\r\nint i;\r\nunsigned int offset1 = ONE_HALF;\r\nunsigned int offset2 = 0x0000;\r\nfor (i=0; i<256; i++) {\r\npdec->table_dc00[i] = offset1 & ~(ONE_HALF);\r\npdec->table_d800[i] = offset2;\r\noffset1 += 0x7bc4;\r\noffset2 += 0x7bc4;\r\n}\r\n}\r\nint pwc_dec23_init(struct pwc_device *pwc, int type, unsigned char *cmd)\r\n{\r\nint flags, version, shift, i;\r\nstruct pwc_dec23_private *pdec;\r\nif (pwc->decompress_data == NULL) {\r\npdec = kmalloc(sizeof(struct pwc_dec23_private), GFP_KERNEL);\r\nif (pdec == NULL)\r\nreturn -ENOMEM;\r\npwc->decompress_data = pdec;\r\n}\r\npdec = pwc->decompress_data;\r\nif (DEVICE_USE_CODEC3(type)) {\r\nflags = cmd[2] & 0x18;\r\nif (flags == 8)\r\npdec->nbits = 7;\r\nelse if (flags == 0x10)\r\npdec->nbits = 8;\r\nelse\r\npdec->nbits = 6;\r\nversion = cmd[2] >> 5;\r\nbuild_table_color(KiaraRomTable[version][0], pdec->table_0004_pass1, pdec->table_8004_pass1);\r\nbuild_table_color(KiaraRomTable[version][1], pdec->table_0004_pass2, pdec->table_8004_pass2);\r\n} else {\r\nflags = cmd[2] & 6;\r\nif (flags == 2)\r\npdec->nbits = 7;\r\nelse if (flags == 4)\r\npdec->nbits = 8;\r\nelse\r\npdec->nbits = 6;\r\nversion = cmd[2] >> 3;\r\nbuild_table_color(TimonRomTable[version][0], pdec->table_0004_pass1, pdec->table_8004_pass1);\r\nbuild_table_color(TimonRomTable[version][1], pdec->table_0004_pass2, pdec->table_8004_pass2);\r\n}\r\nshift = 8 - pdec->nbits;\r\npdec->scalebits = SCALEBITS - shift;\r\npdec->nbitsmask = 0xFF >> shift;\r\nfill_table_dc00_d800(pdec);\r\nbuild_subblock_pattern(pdec);\r\nbuild_bit_powermask_table(pdec);\r\n#if USE_LOOKUP_TABLE_TO_CLAMP\r\nfor (i=0;i<MAX_OUTER_CROP_VALUE;i++)\r\npwc_crop_table[i] = 0;\r\nfor (i=0; i<256; i++)\r\npwc_crop_table[MAX_OUTER_CROP_VALUE+i] = i;\r\nfor (i=0; i<MAX_OUTER_CROP_VALUE; i++)\r\npwc_crop_table[MAX_OUTER_CROP_VALUE+256+i] = 255;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void copy_image_block_Y(const int *src, unsigned char *dst, unsigned int bytes_per_line, unsigned int scalebits)\r\n{\r\n#if UNROLL_LOOP_FOR_COPY\r\nconst unsigned char *cm = pwc_crop_table+MAX_OUTER_CROP_VALUE;\r\nconst int *c = src;\r\nunsigned char *d = dst;\r\n*d++ = cm[c[0] >> scalebits];\r\n*d++ = cm[c[1] >> scalebits];\r\n*d++ = cm[c[2] >> scalebits];\r\n*d++ = cm[c[3] >> scalebits];\r\nd = dst + bytes_per_line;\r\n*d++ = cm[c[4] >> scalebits];\r\n*d++ = cm[c[5] >> scalebits];\r\n*d++ = cm[c[6] >> scalebits];\r\n*d++ = cm[c[7] >> scalebits];\r\nd = dst + bytes_per_line*2;\r\n*d++ = cm[c[8] >> scalebits];\r\n*d++ = cm[c[9] >> scalebits];\r\n*d++ = cm[c[10] >> scalebits];\r\n*d++ = cm[c[11] >> scalebits];\r\nd = dst + bytes_per_line*3;\r\n*d++ = cm[c[12] >> scalebits];\r\n*d++ = cm[c[13] >> scalebits];\r\n*d++ = cm[c[14] >> scalebits];\r\n*d++ = cm[c[15] >> scalebits];\r\n#else\r\nint i;\r\nconst int *c = src;\r\nunsigned char *d = dst;\r\nfor (i = 0; i < 4; i++, c++)\r\n*d++ = CLAMP((*c) >> scalebits);\r\nd = dst + bytes_per_line;\r\nfor (i = 0; i < 4; i++, c++)\r\n*d++ = CLAMP((*c) >> scalebits);\r\nd = dst + bytes_per_line*2;\r\nfor (i = 0; i < 4; i++, c++)\r\n*d++ = CLAMP((*c) >> scalebits);\r\nd = dst + bytes_per_line*3;\r\nfor (i = 0; i < 4; i++, c++)\r\n*d++ = CLAMP((*c) >> scalebits);\r\n#endif\r\n}\r\nstatic void copy_image_block_CrCb(const int *src, unsigned char *dst, unsigned int bytes_per_line, unsigned int scalebits)\r\n{\r\n#if UNROLL_LOOP_FOR_COPY\r\nconst unsigned char *cm = pwc_crop_table+MAX_OUTER_CROP_VALUE;\r\nconst int *c = src;\r\nunsigned char *d = dst;\r\n*d++ = cm[c[0] >> scalebits];\r\n*d++ = cm[c[4] >> scalebits];\r\n*d++ = cm[c[1] >> scalebits];\r\n*d++ = cm[c[5] >> scalebits];\r\n*d++ = cm[c[2] >> scalebits];\r\n*d++ = cm[c[6] >> scalebits];\r\n*d++ = cm[c[3] >> scalebits];\r\n*d++ = cm[c[7] >> scalebits];\r\nd = dst + bytes_per_line;\r\n*d++ = cm[c[12] >> scalebits];\r\n*d++ = cm[c[8] >> scalebits];\r\n*d++ = cm[c[13] >> scalebits];\r\n*d++ = cm[c[9] >> scalebits];\r\n*d++ = cm[c[14] >> scalebits];\r\n*d++ = cm[c[10] >> scalebits];\r\n*d++ = cm[c[15] >> scalebits];\r\n*d++ = cm[c[11] >> scalebits];\r\n#else\r\nint i;\r\nconst int *c1 = src;\r\nconst int *c2 = src + 4;\r\nunsigned char *d = dst;\r\nfor (i = 0; i < 4; i++, c1++, c2++) {\r\n*d++ = CLAMP((*c1) >> scalebits);\r\n*d++ = CLAMP((*c2) >> scalebits);\r\n}\r\nc1 = src + 12;\r\nd = dst + bytes_per_line;\r\nfor (i = 0; i < 4; i++, c1++, c2++) {\r\n*d++ = CLAMP((*c1) >> scalebits);\r\n*d++ = CLAMP((*c2) >> scalebits);\r\n}\r\n#endif\r\n}\r\nstatic void copy_image_block_Green(const int *src, unsigned char *dst, unsigned int bytes_per_line, unsigned int scalebits)\r\n{\r\n#if UNROLL_LOOP_FOR_COPY\r\nconst unsigned char *cm = pwc_crop_table+MAX_OUTER_CROP_VALUE;\r\nunsigned char *d = dst;\r\nconst int *c = src;\r\nd[0] = cm[c[0] >> scalebits];\r\nd[2] = cm[c[1] >> scalebits];\r\nd[4] = cm[c[2] >> scalebits];\r\nd[6] = cm[c[3] >> scalebits];\r\nd[8] = cm[c[4] >> scalebits];\r\nd[10] = cm[c[5] >> scalebits];\r\nd[12] = cm[c[6] >> scalebits];\r\nd[14] = cm[c[7] >> scalebits];\r\nd = dst + bytes_per_line;\r\nd[0] = cm[c[8] >> scalebits];\r\nd[2] = cm[c[9] >> scalebits];\r\nd[4] = cm[c[10] >> scalebits];\r\nd[6] = cm[c[11] >> scalebits];\r\nd[8] = cm[c[12] >> scalebits];\r\nd[10] = cm[c[13] >> scalebits];\r\nd[12] = cm[c[14] >> scalebits];\r\nd[14] = cm[c[15] >> scalebits];\r\n#else\r\nint i;\r\nunsigned char *d;\r\nconst int *c = src;\r\nd = dst;\r\nfor (i = 0; i < 8; i++, c++)\r\nd[i*2] = CLAMP((*c) >> scalebits);\r\nd = dst + bytes_per_line;\r\nfor (i = 0; i < 8; i++, c++)\r\nd[i*2] = CLAMP((*c) >> scalebits);\r\n#endif\r\n}\r\nstatic void copy_image_block_RedBlue(const int *src, unsigned char *dst, unsigned int bytes_per_line, unsigned int scalebits)\r\n{\r\n#if UNROLL_LOOP_FOR_COPY\r\nconst unsigned char *cm = pwc_crop_table+MAX_OUTER_CROP_VALUE;\r\nunsigned char *d = dst;\r\nconst int *c = src;\r\nd[0] = cm[c[0] >> scalebits];\r\nd[2] = cm[c[1] >> scalebits];\r\nd[4] = cm[c[2] >> scalebits];\r\nd[6] = cm[c[3] >> scalebits];\r\nd = dst + bytes_per_line;\r\nd[1] = cm[c[4] >> scalebits];\r\nd[3] = cm[c[5] >> scalebits];\r\nd[5] = cm[c[6] >> scalebits];\r\nd[7] = cm[c[7] >> scalebits];\r\nd = dst + bytes_per_line*2;\r\nd[0] = cm[c[8] >> scalebits];\r\nd[2] = cm[c[9] >> scalebits];\r\nd[4] = cm[c[10] >> scalebits];\r\nd[6] = cm[c[11] >> scalebits];\r\nd = dst + bytes_per_line*3;\r\nd[1] = cm[c[12] >> scalebits];\r\nd[3] = cm[c[13] >> scalebits];\r\nd[5] = cm[c[14] >> scalebits];\r\nd[7] = cm[c[15] >> scalebits];\r\n#else\r\nint i;\r\nunsigned char *d;\r\nconst int *c = src;\r\nd = dst;\r\nfor (i = 0; i < 4; i++, c++)\r\nd[i*2] = CLAMP((*c) >> scalebits);\r\nd = dst + bytes_per_line;\r\nfor (i = 0; i < 4; i++, c++)\r\nd[i*2+1] = CLAMP((*c) >> scalebits);\r\nd = dst + bytes_per_line*2;\r\nfor (i = 0; i < 4; i++, c++)\r\nd[i*2] = CLAMP((*c) >> scalebits);\r\nd = dst + bytes_per_line*3;\r\nfor (i = 0; i < 4; i++, c++)\r\nd[i*2+1] = CLAMP((*c) >> scalebits);\r\n#endif\r\n}\r\nstatic void decode_block(struct pwc_dec23_private *pdec,\r\nconst unsigned char *ptable0004,\r\nconst unsigned char *ptable8004)\r\n{\r\nunsigned int primary_color;\r\nunsigned int channel_v, offset1, op;\r\nint i;\r\nfill_nbits(pdec, 16);\r\n__get_nbits(pdec, pdec->nbits, primary_color);\r\nif (look_nbits(pdec,2) == 0) {\r\nskip_nbits(pdec, 2);\r\nfor (i = 0; i < 16; i++)\r\npdec->temp_colors[i] = pdec->table_dc00[primary_color];\r\nreturn;\r\n}\r\nfor (i = 0; i < 16; i++)\r\npdec->temp_colors[i] = pdec->table_d800[primary_color];\r\n__get_nbits(pdec, 3, channel_v);\r\nchannel_v = ((channel_v & 1) << 2) | (channel_v & 2) | ((channel_v & 4) >> 2);\r\nptable0004 += (channel_v * 128);\r\nptable8004 += (channel_v * 32);\r\noffset1 = 0;\r\ndo\r\n{\r\nunsigned int htable_idx, rows = 0;\r\nconst unsigned int *block;\r\nfill_nbits(pdec, 16);\r\nhtable_idx = look_nbits(pdec, 6);\r\nop = hash_table_ops[htable_idx * 4];\r\nif (op == 2) {\r\nskip_nbits(pdec, 2);\r\n} else if (op == 1) {\r\nunsigned int mask, shift;\r\nunsigned int nbits, col1;\r\nunsigned int yyyy;\r\nskip_nbits(pdec, 3);\r\n__get_nbits(pdec, 4, yyyy);\r\noffset1 += 1 + yyyy;\r\noffset1 &= 0x0F;\r\nnbits = ptable8004[offset1 * 2];\r\n__get_nbits(pdec, nbits+1, col1);\r\nmask = pdec->table_bitpowermask[nbits][col1];\r\nshift = ptable8004[offset1 * 2 + 1];\r\nrows = ((mask << shift) + 0x80) & 0xFF;\r\nblock = pdec->table_subblock[rows];\r\nfor (i = 0; i < 16; i++)\r\npdec->temp_colors[i] += block[MulIdx[offset1][i]];\r\n} else {\r\nunsigned int shift;\r\noffset1 += hash_table_ops [htable_idx * 4 + 2];\r\noffset1 &= 0x0F;\r\nrows = ptable0004[offset1 + hash_table_ops [htable_idx * 4 + 3]];\r\nblock = pdec->table_subblock[rows];\r\nfor (i = 0; i < 16; i++)\r\npdec->temp_colors[i] += block[MulIdx[offset1][i]];\r\nshift = hash_table_ops[htable_idx * 4 + 1];\r\nskip_nbits(pdec, shift);\r\n}\r\n} while (op != 2);\r\n}\r\nstatic void DecompressBand23(struct pwc_dec23_private *pdec,\r\nconst unsigned char *rawyuv,\r\nunsigned char *planar_y,\r\nunsigned char *planar_u,\r\nunsigned char *planar_v,\r\nunsigned int compressed_image_width,\r\nunsigned int real_image_width)\r\n{\r\nint compression_index, nblocks;\r\nconst unsigned char *ptable0004;\r\nconst unsigned char *ptable8004;\r\npdec->reservoir = 0;\r\npdec->nbits_in_reservoir = 0;\r\npdec->stream = rawyuv + 1;\r\nget_nbits(pdec, 4, compression_index);\r\nnblocks = compressed_image_width / 4;\r\nptable0004 = pdec->table_0004_pass1[compression_index];\r\nptable8004 = pdec->table_8004_pass1[compression_index];\r\nwhile (nblocks) {\r\ndecode_block(pdec, ptable0004, ptable8004);\r\ncopy_image_block_Y(pdec->temp_colors, planar_y, real_image_width, pdec->scalebits);\r\nplanar_y += 4;\r\nnblocks--;\r\n}\r\nnblocks = compressed_image_width / 8;\r\nptable0004 = pdec->table_0004_pass2[compression_index];\r\nptable8004 = pdec->table_8004_pass2[compression_index];\r\nwhile (nblocks) {\r\ndecode_block(pdec, ptable0004, ptable8004);\r\ncopy_image_block_CrCb(pdec->temp_colors, planar_u, real_image_width/2, pdec->scalebits);\r\ndecode_block(pdec, ptable0004, ptable8004);\r\ncopy_image_block_CrCb(pdec->temp_colors, planar_v, real_image_width/2, pdec->scalebits);\r\nplanar_v += 8;\r\nplanar_u += 8;\r\nnblocks -= 2;\r\n}\r\n}\r\nstatic void DecompressBandBayer(struct pwc_dec23_private *pdec,\r\nconst unsigned char *rawyuv,\r\nunsigned char *rgbbayer,\r\nunsigned int compressed_image_width,\r\nunsigned int real_image_width)\r\n{\r\nint compression_index, nblocks;\r\nconst unsigned char *ptable0004;\r\nconst unsigned char *ptable8004;\r\nunsigned char *dest;\r\npdec->reservoir = 0;\r\npdec->nbits_in_reservoir = 0;\r\npdec->stream = rawyuv + 1;\r\nget_nbits(pdec, 4, compression_index);\r\nnblocks = compressed_image_width / 4;\r\nptable0004 = pdec->table_0004_pass1[compression_index];\r\nptable8004 = pdec->table_8004_pass1[compression_index];\r\ndest = rgbbayer;\r\nwhile (nblocks) {\r\ndecode_block(pdec, ptable0004, ptable8004);\r\ncopy_image_block_RedBlue(pdec->temp_colors, rgbbayer, real_image_width, pdec->scalebits);\r\ndest += 8;\r\nnblocks--;\r\n}\r\nnblocks = compressed_image_width / 8;\r\nptable0004 = pdec->table_0004_pass2[compression_index];\r\nptable8004 = pdec->table_8004_pass2[compression_index];\r\nwhile (nblocks) {\r\ndecode_block(pdec, ptable0004, ptable8004);\r\ncopy_image_block_Green(pdec->temp_colors, rgbbayer+1, real_image_width, pdec->scalebits);\r\ndecode_block(pdec, ptable0004, ptable8004);\r\ncopy_image_block_Green(pdec->temp_colors, rgbbayer+real_image_width, real_image_width, pdec->scalebits);\r\nrgbbayer += 16;\r\nnblocks -= 2;\r\n}\r\n}\r\nvoid pwc_dec23_decompress(const struct pwc_device *pwc,\r\nconst void *src,\r\nvoid *dst,\r\nint flags)\r\n{\r\nint bandlines_left, stride, bytes_per_block;\r\nbandlines_left = pwc->image.y / 4;\r\nbytes_per_block = pwc->view.x * 4;\r\nif (flags & PWCX_FLAG_BAYER) {\r\n#if ENABLE_BAYER_DECODER\r\nunsigned char *rgbout;\r\nstride = pwc->view.x * pwc->offset.y;\r\nrgbout = dst + stride + pwc->offset.x;\r\nwhile (bandlines_left--) {\r\nDecompressBandBayer(pwc->decompress_data,\r\nsrc,\r\nrgbout,\r\npwc->image.x, pwc->view.x);\r\nsrc += pwc->vbandlength;\r\nrgbout += bytes_per_block;\r\n}\r\n#else\r\nmemset(dst, 0, pwc->view.x * pwc->view.y);\r\n#endif\r\n} else {\r\nunsigned char *pout_planar_y;\r\nunsigned char *pout_planar_u;\r\nunsigned char *pout_planar_v;\r\nunsigned int plane_size;\r\nplane_size = pwc->view.x * pwc->view.y;\r\nstride = pwc->view.x * pwc->offset.y;\r\npout_planar_y = dst + stride + pwc->offset.x;\r\nstride = (pwc->view.x * pwc->offset.y) / 4 + pwc->offset.x / 2;\r\npout_planar_u = dst + plane_size + stride;\r\npout_planar_v = dst + plane_size + plane_size / 4 + stride;\r\nwhile (bandlines_left--) {\r\nDecompressBand23(pwc->decompress_data,\r\nsrc,\r\npout_planar_y, pout_planar_u, pout_planar_v,\r\npwc->image.x, pwc->view.x);\r\nsrc += pwc->vbandlength;\r\npout_planar_y += bytes_per_block;\r\npout_planar_u += pwc->view.x;\r\npout_planar_v += pwc->view.x;\r\n}\r\n}\r\n}
