static void __init quirk_fsl_pcie_header(struct pci_dev *dev)\r\n{\r\nu8 progif;\r\nif (!pci_find_capability(dev, PCI_CAP_ID_EXP))\r\nreturn;\r\npci_read_config_byte(dev, PCI_CLASS_PROG, &progif);\r\nif (progif & 0x1)\r\nreturn;\r\ndev->class = PCI_CLASS_BRIDGE_PCI << 8;\r\nfsl_pcie_bus_fixup = 1;\r\nreturn;\r\n}\r\nstatic int __init fsl_pcie_check_link(struct pci_controller *hose)\r\n{\r\nu32 val;\r\nearly_read_config_dword(hose, 0, 0, PCIE_LTSSM, &val);\r\nif (val < PCIE_LTSSM_L0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init setup_one_atmu(struct ccsr_pci __iomem *pci,\r\nunsigned int index, const struct resource *res,\r\nresource_size_t offset)\r\n{\r\nresource_size_t pci_addr = res->start - offset;\r\nresource_size_t phys_addr = res->start;\r\nresource_size_t size = resource_size(res);\r\nu32 flags = 0x80044000;\r\nunsigned int i;\r\npr_debug("PCI MEM resource start 0x%016llx, size 0x%016llx.\n",\r\n(u64)res->start, (u64)size);\r\nif (res->flags & IORESOURCE_PREFETCH)\r\nflags |= 0x10000000;\r\nfor (i = 0; size > 0; i++) {\r\nunsigned int bits = min(__ilog2(size),\r\n__ffs(pci_addr | phys_addr));\r\nif (index + i >= 5)\r\nreturn -1;\r\nout_be32(&pci->pow[index + i].potar, pci_addr >> 12);\r\nout_be32(&pci->pow[index + i].potear, (u64)pci_addr >> 44);\r\nout_be32(&pci->pow[index + i].powbar, phys_addr >> 12);\r\nout_be32(&pci->pow[index + i].powar, flags | (bits - 1));\r\npci_addr += (resource_size_t)1U << bits;\r\nphys_addr += (resource_size_t)1U << bits;\r\nsize -= (resource_size_t)1U << bits;\r\n}\r\nreturn i;\r\n}\r\nstatic void __init setup_pci_atmu(struct pci_controller *hose,\r\nstruct resource *rsrc)\r\n{\r\nstruct ccsr_pci __iomem *pci;\r\nint i, j, n, mem_log, win_idx = 3, start_idx = 1, end_idx = 4;\r\nu64 mem, sz, paddr_hi = 0;\r\nu64 paddr_lo = ULLONG_MAX;\r\nu32 pcicsrbar = 0, pcicsrbar_sz;\r\nu32 piwar = PIWAR_EN | PIWAR_PF | PIWAR_TGI_LOCAL |\r\nPIWAR_READ_SNOOP | PIWAR_WRITE_SNOOP;\r\nchar *name = hose->dn->full_name;\r\npr_debug("PCI memory map start 0x%016llx, size 0x%016llx\n",\r\n(u64)rsrc->start, (u64)resource_size(rsrc));\r\nif (of_device_is_compatible(hose->dn, "fsl,qoriq-pcie-v2.2")) {\r\nwin_idx = 2;\r\nstart_idx = 0;\r\nend_idx = 3;\r\n}\r\npci = ioremap(rsrc->start, resource_size(rsrc));\r\nif (!pci) {\r\ndev_err(hose->parent, "Unable to map ATMU registers\n");\r\nreturn;\r\n}\r\nfor(i = 1; i < 5; i++)\r\nout_be32(&pci->pow[i].powar, 0);\r\nfor (i = start_idx; i < end_idx; i++)\r\nout_be32(&pci->piw[i].piwar, 0);\r\nfor(i = 0, j = 1; i < 3; i++) {\r\nif (!(hose->mem_resources[i].flags & IORESOURCE_MEM))\r\ncontinue;\r\npaddr_lo = min(paddr_lo, (u64)hose->mem_resources[i].start);\r\npaddr_hi = max(paddr_hi, (u64)hose->mem_resources[i].end);\r\nn = setup_one_atmu(pci, j, &hose->mem_resources[i],\r\nhose->pci_mem_offset);\r\nif (n < 0 || j >= 5) {\r\npr_err("Ran out of outbound PCI ATMUs for resource %d!\n", i);\r\nhose->mem_resources[i].flags |= IORESOURCE_DISABLED;\r\n} else\r\nj += n;\r\n}\r\nif (hose->io_resource.flags & IORESOURCE_IO) {\r\nif (j >= 5) {\r\npr_err("Ran out of outbound PCI ATMUs for IO resource\n");\r\n} else {\r\npr_debug("PCI IO resource start 0x%016llx, size 0x%016llx, "\r\n"phy base 0x%016llx.\n",\r\n(u64)hose->io_resource.start,\r\n(u64)resource_size(&hose->io_resource),\r\n(u64)hose->io_base_phys);\r\nout_be32(&pci->pow[j].potar, (hose->io_resource.start >> 12));\r\nout_be32(&pci->pow[j].potear, 0);\r\nout_be32(&pci->pow[j].powbar, (hose->io_base_phys >> 12));\r\nout_be32(&pci->pow[j].powar, 0x80088000\r\n| (__ilog2(hose->io_resource.end\r\n- hose->io_resource.start + 1) - 1));\r\n}\r\n}\r\npaddr_hi -= hose->pci_mem_offset;\r\npaddr_lo -= hose->pci_mem_offset;\r\nif (paddr_hi == paddr_lo) {\r\npr_err("%s: No outbound window space\n", name);\r\nreturn ;\r\n}\r\nif (paddr_lo == 0) {\r\npr_err("%s: No space for inbound window\n", name);\r\nreturn ;\r\n}\r\nearly_write_config_dword(hose, 0, 0, PCI_BASE_ADDRESS_0, 0xffffffff);\r\nearly_read_config_dword(hose, 0, 0, PCI_BASE_ADDRESS_0, &pcicsrbar_sz);\r\npcicsrbar_sz = ~pcicsrbar_sz + 1;\r\nif (paddr_hi < (0x100000000ull - pcicsrbar_sz) ||\r\n(paddr_lo > 0x100000000ull))\r\npcicsrbar = 0x100000000ull - pcicsrbar_sz;\r\nelse\r\npcicsrbar = (paddr_lo - pcicsrbar_sz) & -pcicsrbar_sz;\r\nearly_write_config_dword(hose, 0, 0, PCI_BASE_ADDRESS_0, pcicsrbar);\r\npaddr_lo = min(paddr_lo, (u64)pcicsrbar);\r\npr_info("%s: PCICSRBAR @ 0x%x\n", name, pcicsrbar);\r\nmem = memblock_end_of_DRAM();\r\nsz = min(mem, paddr_lo);\r\nmem_log = __ilog2_u64(sz);\r\nif (early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP)) {\r\nif ((1ull << mem_log) != mem) {\r\nif ((1ull << mem_log) > mem)\r\npr_info("%s: Setting PCI inbound window "\r\n"greater than memory size\n", name);\r\nmem_log++;\r\n}\r\npiwar |= ((mem_log - 1) & PIWAR_SZ_MASK);\r\nout_be32(&pci->piw[win_idx].pitar, 0x00000000);\r\nout_be32(&pci->piw[win_idx].piwbar, 0x00000000);\r\nout_be32(&pci->piw[win_idx].piwar, piwar);\r\nwin_idx--;\r\nhose->dma_window_base_cur = 0x00000000;\r\nhose->dma_window_size = (resource_size_t)sz;\r\n} else {\r\nu64 paddr = 0;\r\nout_be32(&pci->piw[win_idx].pitar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwbar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwar, (piwar | (mem_log - 1)));\r\nwin_idx--;\r\npaddr += 1ull << mem_log;\r\nsz -= 1ull << mem_log;\r\nif (sz) {\r\nmem_log = __ilog2_u64(sz);\r\npiwar |= (mem_log - 1);\r\nout_be32(&pci->piw[win_idx].pitar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwbar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwar, piwar);\r\nwin_idx--;\r\npaddr += 1ull << mem_log;\r\n}\r\nhose->dma_window_base_cur = 0x00000000;\r\nhose->dma_window_size = (resource_size_t)paddr;\r\n}\r\nif (hose->dma_window_size < mem) {\r\n#ifndef CONFIG_SWIOTLB\r\npr_err("%s: ERROR: Memory size exceeds PCI ATMU ability to "\r\n"map - enable CONFIG_SWIOTLB to avoid dma errors.\n",\r\nname);\r\n#endif\r\nif (paddr_hi < 0xffffffffull)\r\npr_warning("%s: WARNING: Outbound window cfg leaves "\r\n"gaps in memory map. Adjusting the memory map "\r\n"could reduce unnecessary bounce buffering.\n",\r\nname);\r\npr_info("%s: DMA window size is 0x%llx\n", name,\r\n(u64)hose->dma_window_size);\r\n}\r\niounmap(pci);\r\n}\r\nstatic void __init setup_pci_cmd(struct pci_controller *hose)\r\n{\r\nu16 cmd;\r\nint cap_x;\r\nearly_read_config_word(hose, 0, 0, PCI_COMMAND, &cmd);\r\ncmd |= PCI_COMMAND_SERR | PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY\r\n| PCI_COMMAND_IO;\r\nearly_write_config_word(hose, 0, 0, PCI_COMMAND, cmd);\r\ncap_x = early_find_capability(hose, 0, 0, PCI_CAP_ID_PCIX);\r\nif (cap_x) {\r\nint pci_x_cmd = cap_x + PCI_X_CMD;\r\ncmd = PCI_X_CMD_MAX_SPLIT | PCI_X_CMD_MAX_READ\r\n| PCI_X_CMD_ERO | PCI_X_CMD_DPERR_E;\r\nearly_write_config_word(hose, 0, 0, pci_x_cmd, cmd);\r\n} else {\r\nearly_write_config_byte(hose, 0, 0, PCI_LATENCY_TIMER, 0x80);\r\n}\r\n}\r\nvoid fsl_pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nint i;\r\nif ((bus->parent == hose->bus) &&\r\n((fsl_pcie_bus_fixup &&\r\nearly_find_capability(hose, 0, 0, PCI_CAP_ID_EXP)) ||\r\n(hose->indirect_type & PPC_INDIRECT_TYPE_NO_PCIE_LINK)))\r\n{\r\nfor (i = 0; i < 4; ++i) {\r\nstruct resource *res = bus->resource[i];\r\nstruct resource *par = bus->parent->resource[i];\r\nif (res) {\r\nres->start = 0;\r\nres->end = 0;\r\nres->flags = 0;\r\n}\r\nif (res && par) {\r\nres->start = par->start;\r\nres->end = par->end;\r\nres->flags = par->flags;\r\n}\r\n}\r\n}\r\n}\r\nint __init fsl_add_bridge(struct device_node *dev, int is_primary)\r\n{\r\nint len;\r\nstruct pci_controller *hose;\r\nstruct resource rsrc;\r\nconst int *bus_range;\r\nu8 progif;\r\nif (!of_device_is_available(dev)) {\r\npr_warning("%s: disabled\n", dev->full_name);\r\nreturn -ENODEV;\r\n}\r\npr_debug("Adding PCI host bridge %s\n", dev->full_name);\r\nif (of_address_to_resource(dev, 0, &rsrc)) {\r\nprintk(KERN_WARNING "Can't get pci register base!");\r\nreturn -ENOMEM;\r\n}\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int))\r\nprintk(KERN_WARNING "Can't get bus-range for %s, assume"\r\n" bus 0\n", dev->full_name);\r\npci_add_flags(PCI_REASSIGN_ALL_BUS);\r\nhose = pcibios_alloc_controller(dev);\r\nif (!hose)\r\nreturn -ENOMEM;\r\nhose->first_busno = bus_range ? bus_range[0] : 0x0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nsetup_indirect_pci(hose, rsrc.start, rsrc.start + 0x4,\r\nPPC_INDIRECT_TYPE_BIG_ENDIAN);\r\nearly_read_config_byte(hose, 0, 0, PCI_CLASS_PROG, &progif);\r\nif ((progif & 1) == 1) {\r\nif (((unsigned long)hose->cfg_data & PAGE_MASK) !=\r\n((unsigned long)hose->cfg_addr & PAGE_MASK))\r\niounmap(hose->cfg_data);\r\niounmap(hose->cfg_addr);\r\npcibios_free_controller(hose);\r\nreturn 0;\r\n}\r\nsetup_pci_cmd(hose);\r\nif (early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP)) {\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_EXT_REG |\r\nPPC_INDIRECT_TYPE_SURPRESS_PRIMARY_BUS;\r\nif (fsl_pcie_check_link(hose))\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_NO_PCIE_LINK;\r\n}\r\nprintk(KERN_INFO "Found FSL PCI host bridge at 0x%016llx. "\r\n"Firmware bus number: %d->%d\n",\r\n(unsigned long long)rsrc.start, hose->first_busno,\r\nhose->last_busno);\r\npr_debug(" ->Hose at 0x%p, cfg_addr=0x%p,cfg_data=0x%p\n",\r\nhose, hose->cfg_addr, hose->cfg_data);\r\npci_process_bridge_OF_ranges(hose, dev, is_primary);\r\nsetup_pci_atmu(hose, &rsrc);\r\nreturn 0;\r\n}\r\nstatic int mpc83xx_pcie_exclude_device(struct pci_bus *bus, unsigned int devfn)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nif (hose->indirect_type & PPC_INDIRECT_TYPE_NO_PCIE_LINK)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == hose->first_busno ||\r\nbus->primary == hose->first_busno) {\r\nif (devfn & 0xf8)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (ppc_md.pci_exclude_device) {\r\nif (ppc_md.pci_exclude_device(hose, bus->number, devfn))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void __iomem *mpc83xx_pcie_remap_cfg(struct pci_bus *bus,\r\nunsigned int devfn, int offset)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct mpc83xx_pcie_priv *pcie = hose->dn->data;\r\nu32 dev_base = bus->number << 24 | devfn << 16;\r\nint ret;\r\nret = mpc83xx_pcie_exclude_device(bus, devfn);\r\nif (ret)\r\nreturn NULL;\r\noffset &= 0xfff;\r\nif (bus->number == hose->first_busno)\r\nreturn pcie->cfg_type0 + offset;\r\nif (pcie->dev_base == dev_base)\r\ngoto mapped;\r\nout_le32(pcie->cfg_type0 + PEX_OUTWIN0_TAL, dev_base);\r\npcie->dev_base = dev_base;\r\nmapped:\r\nreturn pcie->cfg_type1 + offset;\r\n}\r\nstatic int mpc83xx_pcie_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 *val)\r\n{\r\nvoid __iomem *cfg_addr;\r\ncfg_addr = mpc83xx_pcie_remap_cfg(bus, devfn, offset);\r\nif (!cfg_addr)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (len) {\r\ncase 1:\r\n*val = in_8(cfg_addr);\r\nbreak;\r\ncase 2:\r\n*val = in_le16(cfg_addr);\r\nbreak;\r\ndefault:\r\n*val = in_le32(cfg_addr);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int mpc83xx_pcie_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nvoid __iomem *cfg_addr;\r\ncfg_addr = mpc83xx_pcie_remap_cfg(bus, devfn, offset);\r\nif (!cfg_addr)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (offset == PCI_PRIMARY_BUS && bus->number == hose->first_busno)\r\nval &= 0xffffff00;\r\nswitch (len) {\r\ncase 1:\r\nout_8(cfg_addr, val);\r\nbreak;\r\ncase 2:\r\nout_le16(cfg_addr, val);\r\nbreak;\r\ndefault:\r\nout_le32(cfg_addr, val);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int __init mpc83xx_pcie_setup(struct pci_controller *hose,\r\nstruct resource *reg)\r\n{\r\nstruct mpc83xx_pcie_priv *pcie;\r\nu32 cfg_bar;\r\nint ret = -ENOMEM;\r\npcie = zalloc_maybe_bootmem(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn ret;\r\npcie->cfg_type0 = ioremap(reg->start, resource_size(reg));\r\nif (!pcie->cfg_type0)\r\ngoto err0;\r\ncfg_bar = in_le32(pcie->cfg_type0 + PEX_OUTWIN0_BAR);\r\nif (!cfg_bar) {\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\npcie->cfg_type1 = ioremap(cfg_bar, 0x1000);\r\nif (!pcie->cfg_type1)\r\ngoto err1;\r\nWARN_ON(hose->dn->data);\r\nhose->dn->data = pcie;\r\nhose->ops = &mpc83xx_pcie_ops;\r\nout_le32(pcie->cfg_type0 + PEX_OUTWIN0_TAH, 0);\r\nout_le32(pcie->cfg_type0 + PEX_OUTWIN0_TAL, 0);\r\nif (fsl_pcie_check_link(hose))\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_NO_PCIE_LINK;\r\nreturn 0;\r\nerr1:\r\niounmap(pcie->cfg_type0);\r\nerr0:\r\nkfree(pcie);\r\nreturn ret;\r\n}\r\nint __init mpc83xx_add_bridge(struct device_node *dev)\r\n{\r\nint ret;\r\nint len;\r\nstruct pci_controller *hose;\r\nstruct resource rsrc_reg;\r\nstruct resource rsrc_cfg;\r\nconst int *bus_range;\r\nint primary;\r\nis_mpc83xx_pci = 1;\r\nif (!of_device_is_available(dev)) {\r\npr_warning("%s: disabled by the firmware.\n",\r\ndev->full_name);\r\nreturn -ENODEV;\r\n}\r\npr_debug("Adding PCI host bridge %s\n", dev->full_name);\r\nif (of_address_to_resource(dev, 0, &rsrc_reg)) {\r\nprintk(KERN_WARNING "Can't get pci register base!\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(&rsrc_cfg, 0, sizeof(rsrc_cfg));\r\nif (of_address_to_resource(dev, 1, &rsrc_cfg)) {\r\nprintk(KERN_WARNING\r\n"No pci config register base in dev tree, "\r\n"using default\n");\r\nif ((rsrc_reg.start & 0xfffff) == 0x8500)\r\nrsrc_cfg.start = (rsrc_reg.start & 0xfff00000) + 0x8300;\r\nelse if ((rsrc_reg.start & 0xfffff) == 0x8600)\r\nrsrc_cfg.start = (rsrc_reg.start & 0xfff00000) + 0x8380;\r\n}\r\nif ((rsrc_reg.start & 0xfffff) == 0x8500)\r\nprimary = 1;\r\nelse\r\nprimary = 0;\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int)) {\r\nprintk(KERN_WARNING "Can't get bus-range for %s, assume"\r\n" bus 0\n", dev->full_name);\r\n}\r\npci_add_flags(PCI_REASSIGN_ALL_BUS);\r\nhose = pcibios_alloc_controller(dev);\r\nif (!hose)\r\nreturn -ENOMEM;\r\nhose->first_busno = bus_range ? bus_range[0] : 0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nif (of_device_is_compatible(dev, "fsl,mpc8314-pcie")) {\r\nret = mpc83xx_pcie_setup(hose, &rsrc_reg);\r\nif (ret)\r\ngoto err0;\r\n} else {\r\nsetup_indirect_pci(hose, rsrc_cfg.start,\r\nrsrc_cfg.start + 4, 0);\r\n}\r\nprintk(KERN_INFO "Found FSL PCI host bridge at 0x%016llx. "\r\n"Firmware bus number: %d->%d\n",\r\n(unsigned long long)rsrc_reg.start, hose->first_busno,\r\nhose->last_busno);\r\npr_debug(" ->Hose at 0x%p, cfg_addr=0x%p,cfg_data=0x%p\n",\r\nhose, hose->cfg_addr, hose->cfg_data);\r\npci_process_bridge_OF_ranges(hose, dev, primary);\r\nreturn 0;\r\nerr0:\r\npcibios_free_controller(hose);\r\nreturn ret;\r\n}\r\nu64 fsl_pci_immrbar_base(struct pci_controller *hose)\r\n{\r\n#ifdef CONFIG_PPC_83xx\r\nif (is_mpc83xx_pci) {\r\nstruct mpc83xx_pcie_priv *pcie = hose->dn->data;\r\nstruct pex_inbound_window *in;\r\nint i;\r\nin = pcie->cfg_type0 + PEX_RC_INWIN_BASE;\r\nfor (i = 0; i < 4; i++) {\r\nif (!in_le32(&in[i].ar) & PEX_RCIWARn_EN)\r\ncontinue;\r\nif (get_immrbase() == in_le32(&in[i].tar))\r\nreturn (u64)in_le32(&in[i].barh) << 32 |\r\nin_le32(&in[i].barl);\r\n}\r\nprintk(KERN_WARNING "could not find PCI BAR matching IMMR\n");\r\n}\r\n#endif\r\n#if defined(CONFIG_FSL_SOC_BOOKE) || defined(CONFIG_PPC_86xx)\r\nif (!is_mpc83xx_pci) {\r\nu32 base;\r\npci_bus_read_config_dword(hose->bus,\r\nPCI_DEVFN(0, 0), PCI_BASE_ADDRESS_0, &base);\r\nreturn base;\r\n}\r\n#endif\r\nreturn 0;\r\n}
