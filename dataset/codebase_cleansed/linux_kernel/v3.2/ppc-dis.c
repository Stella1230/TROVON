int\r\nprint_insn_powerpc (unsigned long insn, unsigned long memaddr)\r\n{\r\nconst struct powerpc_opcode *opcode;\r\nconst struct powerpc_opcode *opcode_end;\r\nunsigned long op;\r\nint dialect;\r\ndialect = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON\r\n| PPC_OPCODE_64 | PPC_OPCODE_POWER4 | PPC_OPCODE_ALTIVEC;\r\nif (cpu_has_feature(CPU_FTRS_POWER5))\r\ndialect |= PPC_OPCODE_POWER5;\r\nif (cpu_has_feature(CPU_FTRS_CELL))\r\ndialect |= PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC;\r\nif (cpu_has_feature(CPU_FTRS_POWER6))\r\ndialect |= PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC;\r\nop = PPC_OP (insn);\r\nopcode_end = powerpc_opcodes + powerpc_num_opcodes;\r\nagain:\r\nfor (opcode = powerpc_opcodes; opcode < opcode_end; opcode++)\r\n{\r\nunsigned long table_op;\r\nconst unsigned char *opindex;\r\nconst struct powerpc_operand *operand;\r\nint invalid;\r\nint need_comma;\r\nint need_paren;\r\ntable_op = PPC_OP (opcode->opcode);\r\nif (op < table_op)\r\nbreak;\r\nif (op > table_op)\r\ncontinue;\r\nif ((insn & opcode->mask) != opcode->opcode\r\n|| (opcode->flags & dialect) == 0)\r\ncontinue;\r\ninvalid = 0;\r\nfor (opindex = opcode->operands; *opindex != 0; opindex++)\r\n{\r\noperand = powerpc_operands + *opindex;\r\nif (operand->extract)\r\n(*operand->extract) (insn, dialect, &invalid);\r\n}\r\nif (invalid)\r\ncontinue;\r\nprintf("%s", opcode->name);\r\nif (opcode->operands[0] != 0)\r\nprintf("\t");\r\nneed_comma = 0;\r\nneed_paren = 0;\r\nfor (opindex = opcode->operands; *opindex != 0; opindex++)\r\n{\r\nlong value;\r\noperand = powerpc_operands + *opindex;\r\nif ((operand->flags & PPC_OPERAND_FAKE) != 0)\r\ncontinue;\r\nif (operand->extract)\r\nvalue = (*operand->extract) (insn, dialect, &invalid);\r\nelse\r\n{\r\nvalue = (insn >> operand->shift) & ((1 << operand->bits) - 1);\r\nif ((operand->flags & PPC_OPERAND_SIGNED) != 0\r\n&& (value & (1 << (operand->bits - 1))) != 0)\r\nvalue -= 1 << operand->bits;\r\n}\r\nif ((operand->flags & PPC_OPERAND_OPTIONAL) != 0\r\n&& (operand->flags & PPC_OPERAND_NEXT) == 0\r\n&& value == 0)\r\ncontinue;\r\nif (need_comma)\r\n{\r\nprintf(",");\r\nneed_comma = 0;\r\n}\r\nif ((operand->flags & PPC_OPERAND_GPR) != 0\r\n|| ((operand->flags & PPC_OPERAND_GPR_0) != 0 && value != 0))\r\nprintf("r%ld", value);\r\nelse if ((operand->flags & PPC_OPERAND_FPR) != 0)\r\nprintf("f%ld", value);\r\nelse if ((operand->flags & PPC_OPERAND_VR) != 0)\r\nprintf("v%ld", value);\r\nelse if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)\r\nprint_address (memaddr + value);\r\nelse if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)\r\nprint_address (value & 0xffffffff);\r\nelse if ((operand->flags & PPC_OPERAND_CR) == 0\r\n|| (dialect & PPC_OPCODE_PPC) == 0)\r\nprintf("%ld", value);\r\nelse\r\n{\r\nif (operand->bits == 3)\r\nprintf("cr%ld", value);\r\nelse\r\n{\r\nstatic const char *cbnames[4] = { "lt", "gt", "eq", "so" };\r\nint cr;\r\nint cc;\r\ncr = value >> 2;\r\nif (cr != 0)\r\nprintf("4*cr%d+", cr);\r\ncc = value & 3;\r\nprintf("%s", cbnames[cc]);\r\n}\r\n}\r\nif (need_paren)\r\n{\r\nprintf(")");\r\nneed_paren = 0;\r\n}\r\nif ((operand->flags & PPC_OPERAND_PARENS) == 0)\r\nneed_comma = 1;\r\nelse\r\n{\r\nprintf("(");\r\nneed_paren = 1;\r\n}\r\n}\r\nreturn 4;\r\n}\r\nif ((dialect & PPC_OPCODE_ANY) != 0)\r\n{\r\ndialect = ~PPC_OPCODE_ANY;\r\ngoto again;\r\n}\r\nprintf(".long 0x%lx", insn);\r\nreturn 4;\r\n}
