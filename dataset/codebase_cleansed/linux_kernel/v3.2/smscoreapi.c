void smscore_set_board_id(struct smscore_device_t *core, int id)\r\n{\r\ncore->board_id = id;\r\n}\r\nint smscore_led_state(struct smscore_device_t *core, int led)\r\n{\r\nif (led >= 0)\r\ncore->led_state = led;\r\nreturn core->led_state;\r\n}\r\nint smscore_get_board_id(struct smscore_device_t *core)\r\n{\r\nreturn core->board_id;\r\n}\r\nstatic struct smscore_registry_entry_t *smscore_find_registry(char *devpath)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nstruct list_head *next;\r\nkmutex_lock(&g_smscore_registrylock);\r\nfor (next = g_smscore_registry.next;\r\nnext != &g_smscore_registry;\r\nnext = next->next) {\r\nentry = (struct smscore_registry_entry_t *) next;\r\nif (!strcmp(entry->devpath, devpath)) {\r\nkmutex_unlock(&g_smscore_registrylock);\r\nreturn entry;\r\n}\r\n}\r\nentry = kmalloc(sizeof(struct smscore_registry_entry_t), GFP_KERNEL);\r\nif (entry) {\r\nentry->mode = default_mode;\r\nstrcpy(entry->devpath, devpath);\r\nlist_add(&entry->entry, &g_smscore_registry);\r\n} else\r\nsms_err("failed to create smscore_registry.");\r\nkmutex_unlock(&g_smscore_registrylock);\r\nreturn entry;\r\n}\r\nint smscore_registry_getmode(char *devpath)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nreturn entry->mode;\r\nelse\r\nsms_err("No registry found.");\r\nreturn default_mode;\r\n}\r\nstatic enum sms_device_type_st smscore_registry_gettype(char *devpath)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nreturn entry->type;\r\nelse\r\nsms_err("No registry found.");\r\nreturn -1;\r\n}\r\nvoid smscore_registry_setmode(char *devpath, int mode)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nentry->mode = mode;\r\nelse\r\nsms_err("No registry found.");\r\n}\r\nstatic void smscore_registry_settype(char *devpath,\r\nenum sms_device_type_st type)\r\n{\r\nstruct smscore_registry_entry_t *entry;\r\nentry = smscore_find_registry(devpath);\r\nif (entry)\r\nentry->type = type;\r\nelse\r\nsms_err("No registry found.");\r\n}\r\nstatic void list_add_locked(struct list_head *new, struct list_head *head,\r\nspinlock_t *lock)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nlist_add(new, head);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nint smscore_register_hotplug(hotplug_t hotplug)\r\n{\r\nstruct smscore_device_notifyee_t *notifyee;\r\nstruct list_head *next, *first;\r\nint rc = 0;\r\nkmutex_lock(&g_smscore_deviceslock);\r\nnotifyee = kmalloc(sizeof(struct smscore_device_notifyee_t),\r\nGFP_KERNEL);\r\nif (notifyee) {\r\nfirst = &g_smscore_devices;\r\nfor (next = first->next;\r\nnext != first && !rc;\r\nnext = next->next) {\r\nstruct smscore_device_t *coredev =\r\n(struct smscore_device_t *) next;\r\nrc = hotplug(coredev, coredev->device, 1);\r\n}\r\nif (rc >= 0) {\r\nnotifyee->hotplug = hotplug;\r\nlist_add(&notifyee->entry, &g_smscore_notifyees);\r\n} else\r\nkfree(notifyee);\r\n} else\r\nrc = -ENOMEM;\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nreturn rc;\r\n}\r\nvoid smscore_unregister_hotplug(hotplug_t hotplug)\r\n{\r\nstruct list_head *next, *first;\r\nkmutex_lock(&g_smscore_deviceslock);\r\nfirst = &g_smscore_notifyees;\r\nfor (next = first->next; next != first;) {\r\nstruct smscore_device_notifyee_t *notifyee =\r\n(struct smscore_device_notifyee_t *) next;\r\nnext = next->next;\r\nif (notifyee->hotplug == hotplug) {\r\nlist_del(&notifyee->entry);\r\nkfree(notifyee);\r\n}\r\n}\r\nkmutex_unlock(&g_smscore_deviceslock);\r\n}\r\nstatic void smscore_notify_clients(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_client_t *client;\r\nwhile (!list_empty(&coredev->clients)) {\r\nclient = (struct smscore_client_t *) coredev->clients.next;\r\nclient->onremove_handler(client->context);\r\n}\r\n}\r\nstatic int smscore_notify_callbacks(struct smscore_device_t *coredev,\r\nstruct device *device, int arrival)\r\n{\r\nstruct list_head *next, *first;\r\nint rc = 0;\r\nfirst = &g_smscore_notifyees;\r\nfor (next = first->next; next != first; next = next->next) {\r\nrc = ((struct smscore_device_notifyee_t *) next)->\r\nhotplug(coredev, device, arrival);\r\nif (rc < 0)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic struct\r\nsmscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,\r\ndma_addr_t common_buffer_phys)\r\n{\r\nstruct smscore_buffer_t *cb =\r\nkmalloc(sizeof(struct smscore_buffer_t), GFP_KERNEL);\r\nif (!cb) {\r\nsms_info("kmalloc(...) failed");\r\nreturn NULL;\r\n}\r\ncb->p = buffer;\r\ncb->offset_in_common = buffer - (u8 *) common_buffer;\r\ncb->phys = common_buffer_phys + cb->offset_in_common;\r\nreturn cb;\r\n}\r\nint smscore_register_device(struct smsdevice_params_t *params,\r\nstruct smscore_device_t **coredev)\r\n{\r\nstruct smscore_device_t *dev;\r\nu8 *buffer;\r\ndev = kzalloc(sizeof(struct smscore_device_t), GFP_KERNEL);\r\nif (!dev) {\r\nsms_info("kzalloc(...) failed");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&dev->entry);\r\nINIT_LIST_HEAD(&dev->clients);\r\nINIT_LIST_HEAD(&dev->buffers);\r\nspin_lock_init(&dev->clientslock);\r\nspin_lock_init(&dev->bufferslock);\r\ninit_completion(&dev->version_ex_done);\r\ninit_completion(&dev->data_download_done);\r\ninit_completion(&dev->trigger_done);\r\ninit_completion(&dev->init_device_done);\r\ninit_completion(&dev->reload_start_done);\r\ninit_completion(&dev->resume_done);\r\ninit_completion(&dev->gpio_configuration_done);\r\ninit_completion(&dev->gpio_set_level_done);\r\ninit_completion(&dev->gpio_get_level_done);\r\ninit_completion(&dev->ir_init_done);\r\ninit_waitqueue_head(&dev->buffer_mng_waitq);\r\ndev->common_buffer_size = params->buffer_size * params->num_buffers;\r\ndev->common_buffer = dma_alloc_coherent(NULL, dev->common_buffer_size,\r\n&dev->common_buffer_phys,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!dev->common_buffer) {\r\nsmscore_unregister_device(dev);\r\nreturn -ENOMEM;\r\n}\r\nfor (buffer = dev->common_buffer;\r\ndev->num_buffers < params->num_buffers;\r\ndev->num_buffers++, buffer += params->buffer_size) {\r\nstruct smscore_buffer_t *cb =\r\nsmscore_createbuffer(buffer, dev->common_buffer,\r\ndev->common_buffer_phys);\r\nif (!cb) {\r\nsmscore_unregister_device(dev);\r\nreturn -ENOMEM;\r\n}\r\nsmscore_putbuffer(dev, cb);\r\n}\r\nsms_info("allocated %d buffers", dev->num_buffers);\r\ndev->mode = DEVICE_MODE_NONE;\r\ndev->context = params->context;\r\ndev->device = params->device;\r\ndev->setmode_handler = params->setmode_handler;\r\ndev->detectmode_handler = params->detectmode_handler;\r\ndev->sendrequest_handler = params->sendrequest_handler;\r\ndev->preload_handler = params->preload_handler;\r\ndev->postload_handler = params->postload_handler;\r\ndev->device_flags = params->flags;\r\nstrcpy(dev->devpath, params->devpath);\r\nsmscore_registry_settype(dev->devpath, params->device_type);\r\nkmutex_lock(&g_smscore_deviceslock);\r\nlist_add(&dev->entry, &g_smscore_devices);\r\nkmutex_unlock(&g_smscore_deviceslock);\r\n*coredev = dev;\r\nsms_info("device %p created", dev);\r\nreturn 0;\r\n}\r\nstatic int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,\r\nvoid *buffer, size_t size, struct completion *completion) {\r\nint rc = coredev->sendrequest_handler(coredev->context, buffer, size);\r\nif (rc < 0) {\r\nsms_info("sendrequest returned error %d", rc);\r\nreturn rc;\r\n}\r\nreturn wait_for_completion_timeout(completion,\r\nmsecs_to_jiffies(SMS_PROTOCOL_MAX_RAOUNDTRIP_MS)) ?\r\n0 : -ETIME;\r\n}\r\nstatic int smscore_init_ir(struct smscore_device_t *coredev)\r\n{\r\nint ir_io;\r\nint rc;\r\nvoid *buffer;\r\ncoredev->ir.dev = NULL;\r\nir_io = sms_get_board(smscore_get_board_id(coredev))->board_cfg.ir;\r\nif (ir_io) {\r\nsms_info("IR loading");\r\nrc = sms_ir_init(coredev);\r\nif (rc != 0)\r\nsms_err("Error initialization DTV IR sub-module");\r\nelse {\r\nbuffer = kmalloc(sizeof(struct SmsMsgData_ST2) +\r\nSMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (buffer) {\r\nstruct SmsMsgData_ST2 *msg =\r\n(struct SmsMsgData_ST2 *)\r\nSMS_ALIGN_ADDRESS(buffer);\r\nSMS_INIT_MSG(&msg->xMsgHeader,\r\nMSG_SMS_START_IR_REQ,\r\nsizeof(struct SmsMsgData_ST2));\r\nmsg->msgData[0] = coredev->ir.controller;\r\nmsg->msgData[1] = coredev->ir.timeout;\r\nsmsendian_handle_tx_message(\r\n(struct SmsMsgHdr_ST2 *)msg);\r\nrc = smscore_sendrequest_and_wait(coredev, msg,\r\nmsg->xMsgHeader. msgLength,\r\n&coredev->ir_init_done);\r\nkfree(buffer);\r\n} else\r\nsms_err\r\n("Sending IR initialization message failed");\r\n}\r\n} else\r\nsms_info("IR port has not been detected");\r\nreturn 0;\r\n}\r\nint smscore_start_device(struct smscore_device_t *coredev)\r\n{\r\nint rc = smscore_set_device_mode(\r\ncoredev, smscore_registry_getmode(coredev->devpath));\r\nif (rc < 0) {\r\nsms_info("set device mode faile , rc %d", rc);\r\nreturn rc;\r\n}\r\nkmutex_lock(&g_smscore_deviceslock);\r\nrc = smscore_notify_callbacks(coredev, coredev->device, 1);\r\nsmscore_init_ir(coredev);\r\nsms_info("device %p started, rc %d", coredev, rc);\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nreturn rc;\r\n}\r\nstatic int smscore_load_firmware_family2(struct smscore_device_t *coredev,\r\nvoid *buffer, size_t size)\r\n{\r\nstruct SmsFirmware_ST *firmware = (struct SmsFirmware_ST *) buffer;\r\nstruct SmsMsgHdr_ST *msg;\r\nu32 mem_address;\r\nu8 *payload = firmware->Payload;\r\nint rc = 0;\r\nfirmware->StartAddress = le32_to_cpu(firmware->StartAddress);\r\nfirmware->Length = le32_to_cpu(firmware->Length);\r\nmem_address = firmware->StartAddress;\r\nsms_info("loading FW to addr 0x%x size %d",\r\nmem_address, firmware->Length);\r\nif (coredev->preload_handler) {\r\nrc = coredev->preload_handler(coredev->context);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nmsg = kmalloc(PAGE_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nif (coredev->mode != DEVICE_MODE_NONE) {\r\nsms_debug("sending reload command.");\r\nSMS_INIT_MSG(msg, MSG_SW_RELOAD_START_REQ,\r\nsizeof(struct SmsMsgHdr_ST));\r\nrc = smscore_sendrequest_and_wait(coredev, msg,\r\nmsg->msgLength,\r\n&coredev->reload_start_done);\r\nmem_address = *(u32 *) &payload[20];\r\n}\r\nwhile (size && rc >= 0) {\r\nstruct SmsDataDownload_ST *DataMsg =\r\n(struct SmsDataDownload_ST *) msg;\r\nint payload_size = min((int) size, SMS_MAX_PAYLOAD_SIZE);\r\nSMS_INIT_MSG(msg, MSG_SMS_DATA_DOWNLOAD_REQ,\r\n(u16)(sizeof(struct SmsMsgHdr_ST) +\r\nsizeof(u32) + payload_size));\r\nDataMsg->MemAddr = mem_address;\r\nmemcpy(DataMsg->Payload, payload, payload_size);\r\nif ((coredev->device_flags & SMS_ROM_NO_RESPONSE) &&\r\n(coredev->mode == DEVICE_MODE_NONE))\r\nrc = coredev->sendrequest_handler(\r\ncoredev->context, DataMsg,\r\nDataMsg->xMsgHeader.msgLength);\r\nelse\r\nrc = smscore_sendrequest_and_wait(\r\ncoredev, DataMsg,\r\nDataMsg->xMsgHeader.msgLength,\r\n&coredev->data_download_done);\r\npayload += payload_size;\r\nsize -= payload_size;\r\nmem_address += payload_size;\r\n}\r\nif (rc >= 0) {\r\nif (coredev->mode == DEVICE_MODE_NONE) {\r\nstruct SmsMsgData_ST *TriggerMsg =\r\n(struct SmsMsgData_ST *) msg;\r\nSMS_INIT_MSG(msg, MSG_SMS_SWDOWNLOAD_TRIGGER_REQ,\r\nsizeof(struct SmsMsgHdr_ST) +\r\nsizeof(u32) * 5);\r\nTriggerMsg->msgData[0] = firmware->StartAddress;\r\nTriggerMsg->msgData[1] = 5;\r\nTriggerMsg->msgData[2] = 0x200;\r\nTriggerMsg->msgData[3] = 0;\r\nTriggerMsg->msgData[4] = 4;\r\nif (coredev->device_flags & SMS_ROM_NO_RESPONSE) {\r\nrc = coredev->sendrequest_handler(\r\ncoredev->context, TriggerMsg,\r\nTriggerMsg->xMsgHeader.msgLength);\r\nmsleep(100);\r\n} else\r\nrc = smscore_sendrequest_and_wait(\r\ncoredev, TriggerMsg,\r\nTriggerMsg->xMsgHeader.msgLength,\r\n&coredev->trigger_done);\r\n} else {\r\nSMS_INIT_MSG(msg, MSG_SW_RELOAD_EXEC_REQ,\r\nsizeof(struct SmsMsgHdr_ST));\r\nrc = coredev->sendrequest_handler(coredev->context,\r\nmsg, msg->msgLength);\r\n}\r\nmsleep(500);\r\n}\r\nsms_debug("rc=%d, postload=%p ", rc,\r\ncoredev->postload_handler);\r\nkfree(msg);\r\nreturn ((rc >= 0) && coredev->postload_handler) ?\r\ncoredev->postload_handler(coredev->context) :\r\nrc;\r\n}\r\nstatic int smscore_load_firmware_from_file(struct smscore_device_t *coredev,\r\nchar *filename,\r\nloadfirmware_t loadfirmware_handler)\r\n{\r\nint rc = -ENOENT;\r\nconst struct firmware *fw;\r\nu8 *fw_buffer;\r\nif (loadfirmware_handler == NULL && !(coredev->device_flags &\r\nSMS_DEVICE_FAMILY2))\r\nreturn -EINVAL;\r\nrc = request_firmware(&fw, filename, coredev->device);\r\nif (rc < 0) {\r\nsms_info("failed to open \"%s\"", filename);\r\nreturn rc;\r\n}\r\nsms_info("read FW %s, size=%zd", filename, fw->size);\r\nfw_buffer = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),\r\nGFP_KERNEL | GFP_DMA);\r\nif (fw_buffer) {\r\nmemcpy(fw_buffer, fw->data, fw->size);\r\nrc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?\r\nsmscore_load_firmware_family2(coredev,\r\nfw_buffer,\r\nfw->size) :\r\nloadfirmware_handler(coredev->context,\r\nfw_buffer, fw->size);\r\nkfree(fw_buffer);\r\n} else {\r\nsms_info("failed to allocate firmware buffer");\r\nrc = -ENOMEM;\r\n}\r\nrelease_firmware(fw);\r\nreturn rc;\r\n}\r\nvoid smscore_unregister_device(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_buffer_t *cb;\r\nint num_buffers = 0;\r\nint retry = 0;\r\nkmutex_lock(&g_smscore_deviceslock);\r\nsms_ir_exit(coredev);\r\nsmscore_notify_clients(coredev);\r\nsmscore_notify_callbacks(coredev, NULL, 0);\r\nwhile (1) {\r\nwhile (!list_empty(&coredev->buffers)) {\r\ncb = (struct smscore_buffer_t *) coredev->buffers.next;\r\nlist_del(&cb->entry);\r\nkfree(cb);\r\nnum_buffers++;\r\n}\r\nif (num_buffers == coredev->num_buffers)\r\nbreak;\r\nif (++retry > 10) {\r\nsms_info("exiting although "\r\n"not all buffers released.");\r\nbreak;\r\n}\r\nsms_info("waiting for %d buffer(s)",\r\ncoredev->num_buffers - num_buffers);\r\nmsleep(100);\r\n}\r\nsms_info("freed %d buffers", num_buffers);\r\nif (coredev->common_buffer)\r\ndma_free_coherent(NULL, coredev->common_buffer_size,\r\ncoredev->common_buffer, coredev->common_buffer_phys);\r\nif (coredev->fw_buf != NULL)\r\nkfree(coredev->fw_buf);\r\nlist_del(&coredev->entry);\r\nkfree(coredev);\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nsms_info("device %p destroyed", coredev);\r\n}\r\nstatic int smscore_detect_mode(struct smscore_device_t *coredev)\r\n{\r\nvoid *buffer = kmalloc(sizeof(struct SmsMsgHdr_ST) + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nstruct SmsMsgHdr_ST *msg =\r\n(struct SmsMsgHdr_ST *) SMS_ALIGN_ADDRESS(buffer);\r\nint rc;\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nSMS_INIT_MSG(msg, MSG_SMS_GET_VERSION_EX_REQ,\r\nsizeof(struct SmsMsgHdr_ST));\r\nrc = smscore_sendrequest_and_wait(coredev, msg, msg->msgLength,\r\n&coredev->version_ex_done);\r\nif (rc == -ETIME) {\r\nsms_err("MSG_SMS_GET_VERSION_EX_REQ failed first try");\r\nif (wait_for_completion_timeout(&coredev->resume_done,\r\nmsecs_to_jiffies(5000))) {\r\nrc = smscore_sendrequest_and_wait(\r\ncoredev, msg, msg->msgLength,\r\n&coredev->version_ex_done);\r\nif (rc < 0)\r\nsms_err("MSG_SMS_GET_VERSION_EX_REQ failed "\r\n"second try, rc %d", rc);\r\n} else\r\nrc = -ETIME;\r\n}\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nstatic inline char *sms_get_fw_name(struct smscore_device_t *coredev,\r\nint mode, enum sms_device_type_st type)\r\n{\r\nchar **fw = sms_get_board(smscore_get_board_id(coredev))->fw;\r\nreturn (fw && fw[mode]) ? fw[mode] : smscore_fw_lkup[mode][type];\r\n}\r\nint smscore_set_device_mode(struct smscore_device_t *coredev, int mode)\r\n{\r\nvoid *buffer;\r\nint rc = 0;\r\nenum sms_device_type_st type;\r\nsms_debug("set device mode to %d", mode);\r\nif (coredev->device_flags & SMS_DEVICE_FAMILY2) {\r\nif (mode < DEVICE_MODE_DVBT || mode >= DEVICE_MODE_RAW_TUNER) {\r\nsms_err("invalid mode specified %d", mode);\r\nreturn -EINVAL;\r\n}\r\nsmscore_registry_setmode(coredev->devpath, mode);\r\nif (!(coredev->device_flags & SMS_DEVICE_NOT_READY)) {\r\nrc = smscore_detect_mode(coredev);\r\nif (rc < 0) {\r\nsms_err("mode detect failed %d", rc);\r\nreturn rc;\r\n}\r\n}\r\nif (coredev->mode == mode) {\r\nsms_info("device mode %d already set", mode);\r\nreturn 0;\r\n}\r\nif (!(coredev->modes_supported & (1 << mode))) {\r\nchar *fw_filename;\r\ntype = smscore_registry_gettype(coredev->devpath);\r\nfw_filename = sms_get_fw_name(coredev, mode, type);\r\nrc = smscore_load_firmware_from_file(coredev,\r\nfw_filename, NULL);\r\nif (rc < 0) {\r\nsms_warn("error %d loading firmware: %s, "\r\n"trying again with default firmware",\r\nrc, fw_filename);\r\nfw_filename = smscore_fw_lkup[mode][type];\r\nrc = smscore_load_firmware_from_file(coredev,\r\nfw_filename, NULL);\r\nif (rc < 0) {\r\nsms_warn("error %d loading "\r\n"firmware: %s", rc,\r\nfw_filename);\r\nreturn rc;\r\n}\r\n}\r\nsms_log("firmware download success: %s", fw_filename);\r\n} else\r\nsms_info("mode %d supported by running "\r\n"firmware", mode);\r\nbuffer = kmalloc(sizeof(struct SmsMsgData_ST) +\r\nSMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);\r\nif (buffer) {\r\nstruct SmsMsgData_ST *msg =\r\n(struct SmsMsgData_ST *)\r\nSMS_ALIGN_ADDRESS(buffer);\r\nSMS_INIT_MSG(&msg->xMsgHeader, MSG_SMS_INIT_DEVICE_REQ,\r\nsizeof(struct SmsMsgData_ST));\r\nmsg->msgData[0] = mode;\r\nrc = smscore_sendrequest_and_wait(\r\ncoredev, msg, msg->xMsgHeader.msgLength,\r\n&coredev->init_device_done);\r\nkfree(buffer);\r\n} else {\r\nsms_err("Could not allocate buffer for "\r\n"init device message.");\r\nrc = -ENOMEM;\r\n}\r\n} else {\r\nif (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_DVBT_BDA) {\r\nsms_err("invalid mode specified %d", mode);\r\nreturn -EINVAL;\r\n}\r\nsmscore_registry_setmode(coredev->devpath, mode);\r\nif (coredev->detectmode_handler)\r\ncoredev->detectmode_handler(coredev->context,\r\n&coredev->mode);\r\nif (coredev->mode != mode && coredev->setmode_handler)\r\nrc = coredev->setmode_handler(coredev->context, mode);\r\n}\r\nif (rc >= 0) {\r\ncoredev->mode = mode;\r\ncoredev->device_flags &= ~SMS_DEVICE_NOT_READY;\r\n}\r\nif (rc < 0)\r\nsms_err("return error code %d.", rc);\r\nreturn rc;\r\n}\r\nint smscore_get_device_mode(struct smscore_device_t *coredev)\r\n{\r\nreturn coredev->mode;\r\n}\r\nstatic struct\r\nsmscore_client_t *smscore_find_client(struct smscore_device_t *coredev,\r\nint data_type, int id)\r\n{\r\nstruct smscore_client_t *client = NULL;\r\nstruct list_head *next, *first;\r\nunsigned long flags;\r\nstruct list_head *firstid, *nextid;\r\nspin_lock_irqsave(&coredev->clientslock, flags);\r\nfirst = &coredev->clients;\r\nfor (next = first->next;\r\n(next != first) && !client;\r\nnext = next->next) {\r\nfirstid = &((struct smscore_client_t *)next)->idlist;\r\nfor (nextid = firstid->next;\r\nnextid != firstid;\r\nnextid = nextid->next) {\r\nif ((((struct smscore_idlist_t *)nextid)->id == id) &&\r\n(((struct smscore_idlist_t *)nextid)->data_type == data_type ||\r\n(((struct smscore_idlist_t *)nextid)->data_type == 0))) {\r\nclient = (struct smscore_client_t *) next;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&coredev->clientslock, flags);\r\nreturn client;\r\n}\r\nvoid smscore_onresponse(struct smscore_device_t *coredev,\r\nstruct smscore_buffer_t *cb) {\r\nstruct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) ((u8 *) cb->p\r\n+ cb->offset);\r\nstruct smscore_client_t *client;\r\nint rc = -EBUSY;\r\nstatic unsigned long last_sample_time;\r\nstatic int data_total;\r\nunsigned long time_now = jiffies_to_msecs(jiffies);\r\nif (!last_sample_time)\r\nlast_sample_time = time_now;\r\nif (time_now - last_sample_time > 10000) {\r\nsms_debug("\ndata rate %d bytes/secs",\r\n(int)((data_total * 1000) /\r\n(time_now - last_sample_time)));\r\nlast_sample_time = time_now;\r\ndata_total = 0;\r\n}\r\ndata_total += cb->size;\r\nif ((phdr->msgType == MSG_SMS_HO_PER_SLICES_IND) ||\r\n(phdr->msgType == MSG_SMS_TRANSMISSION_IND)) {\r\nif (coredev->mode == DEVICE_MODE_DVBT_BDA)\r\nphdr->msgDstId = DVBT_BDA_CONTROL_MSG_ID;\r\n}\r\nclient = smscore_find_client(coredev, phdr->msgType, phdr->msgDstId);\r\nif (client)\r\nrc = client->onresponse_handler(client->context, cb);\r\nif (rc < 0) {\r\nswitch (phdr->msgType) {\r\ncase MSG_SMS_GET_VERSION_EX_RES:\r\n{\r\nstruct SmsVersionRes_ST *ver =\r\n(struct SmsVersionRes_ST *) phdr;\r\nsms_debug("MSG_SMS_GET_VERSION_EX_RES "\r\n"id %d prots 0x%x ver %d.%d",\r\nver->FirmwareId, ver->SupportedProtocols,\r\nver->RomVersionMajor, ver->RomVersionMinor);\r\ncoredev->mode = ver->FirmwareId == 255 ?\r\nDEVICE_MODE_NONE : ver->FirmwareId;\r\ncoredev->modes_supported = ver->SupportedProtocols;\r\ncomplete(&coredev->version_ex_done);\r\nbreak;\r\n}\r\ncase MSG_SMS_INIT_DEVICE_RES:\r\nsms_debug("MSG_SMS_INIT_DEVICE_RES");\r\ncomplete(&coredev->init_device_done);\r\nbreak;\r\ncase MSG_SW_RELOAD_START_RES:\r\nsms_debug("MSG_SW_RELOAD_START_RES");\r\ncomplete(&coredev->reload_start_done);\r\nbreak;\r\ncase MSG_SMS_DATA_DOWNLOAD_RES:\r\ncomplete(&coredev->data_download_done);\r\nbreak;\r\ncase MSG_SW_RELOAD_EXEC_RES:\r\nsms_debug("MSG_SW_RELOAD_EXEC_RES");\r\nbreak;\r\ncase MSG_SMS_SWDOWNLOAD_TRIGGER_RES:\r\nsms_debug("MSG_SMS_SWDOWNLOAD_TRIGGER_RES");\r\ncomplete(&coredev->trigger_done);\r\nbreak;\r\ncase MSG_SMS_SLEEP_RESUME_COMP_IND:\r\ncomplete(&coredev->resume_done);\r\nbreak;\r\ncase MSG_SMS_GPIO_CONFIG_EX_RES:\r\nsms_debug("MSG_SMS_GPIO_CONFIG_EX_RES");\r\ncomplete(&coredev->gpio_configuration_done);\r\nbreak;\r\ncase MSG_SMS_GPIO_SET_LEVEL_RES:\r\nsms_debug("MSG_SMS_GPIO_SET_LEVEL_RES");\r\ncomplete(&coredev->gpio_set_level_done);\r\nbreak;\r\ncase MSG_SMS_GPIO_GET_LEVEL_RES:\r\n{\r\nu32 *msgdata = (u32 *) phdr;\r\ncoredev->gpio_get_res = msgdata[1];\r\nsms_debug("MSG_SMS_GPIO_GET_LEVEL_RES gpio level %d",\r\ncoredev->gpio_get_res);\r\ncomplete(&coredev->gpio_get_level_done);\r\nbreak;\r\n}\r\ncase MSG_SMS_START_IR_RES:\r\ncomplete(&coredev->ir_init_done);\r\nbreak;\r\ncase MSG_SMS_IR_SAMPLES_IND:\r\nsms_ir_event(coredev,\r\n(const char *)\r\n((char *)phdr\r\n+ sizeof(struct SmsMsgHdr_ST)),\r\n(int)phdr->msgLength\r\n- sizeof(struct SmsMsgHdr_ST));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsmscore_putbuffer(coredev, cb);\r\n}\r\n}\r\nstruct smscore_buffer_t *get_entry(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_buffer_t *cb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&coredev->bufferslock, flags);\r\nif (!list_empty(&coredev->buffers)) {\r\ncb = (struct smscore_buffer_t *) coredev->buffers.next;\r\nlist_del(&cb->entry);\r\n}\r\nspin_unlock_irqrestore(&coredev->bufferslock, flags);\r\nreturn cb;\r\n}\r\nstruct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)\r\n{\r\nstruct smscore_buffer_t *cb = NULL;\r\nwait_event(coredev->buffer_mng_waitq, (cb = get_entry(coredev)));\r\nreturn cb;\r\n}\r\nvoid smscore_putbuffer(struct smscore_device_t *coredev,\r\nstruct smscore_buffer_t *cb) {\r\nwake_up_interruptible(&coredev->buffer_mng_waitq);\r\nlist_add_locked(&cb->entry, &coredev->buffers, &coredev->bufferslock);\r\n}\r\nstatic int smscore_validate_client(struct smscore_device_t *coredev,\r\nstruct smscore_client_t *client,\r\nint data_type, int id)\r\n{\r\nstruct smscore_idlist_t *listentry;\r\nstruct smscore_client_t *registered_client;\r\nif (!client) {\r\nsms_err("bad parameter.");\r\nreturn -EINVAL;\r\n}\r\nregistered_client = smscore_find_client(coredev, data_type, id);\r\nif (registered_client == client)\r\nreturn 0;\r\nif (registered_client) {\r\nsms_err("The msg ID already registered to another client.");\r\nreturn -EEXIST;\r\n}\r\nlistentry = kzalloc(sizeof(struct smscore_idlist_t), GFP_KERNEL);\r\nif (!listentry) {\r\nsms_err("Can't allocate memory for client id.");\r\nreturn -ENOMEM;\r\n}\r\nlistentry->id = id;\r\nlistentry->data_type = data_type;\r\nlist_add_locked(&listentry->entry, &client->idlist,\r\n&coredev->clientslock);\r\nreturn 0;\r\n}\r\nint smscore_register_client(struct smscore_device_t *coredev,\r\nstruct smsclient_params_t *params,\r\nstruct smscore_client_t **client)\r\n{\r\nstruct smscore_client_t *newclient;\r\nif (smscore_find_client(coredev, params->data_type,\r\nparams->initial_id)) {\r\nsms_err("Client already exist.");\r\nreturn -EEXIST;\r\n}\r\nnewclient = kzalloc(sizeof(struct smscore_client_t), GFP_KERNEL);\r\nif (!newclient) {\r\nsms_err("Failed to allocate memory for client.");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&newclient->idlist);\r\nnewclient->coredev = coredev;\r\nnewclient->onresponse_handler = params->onresponse_handler;\r\nnewclient->onremove_handler = params->onremove_handler;\r\nnewclient->context = params->context;\r\nlist_add_locked(&newclient->entry, &coredev->clients,\r\n&coredev->clientslock);\r\nsmscore_validate_client(coredev, newclient, params->data_type,\r\nparams->initial_id);\r\n*client = newclient;\r\nsms_debug("%p %d %d", params->context, params->data_type,\r\nparams->initial_id);\r\nreturn 0;\r\n}\r\nvoid smscore_unregister_client(struct smscore_client_t *client)\r\n{\r\nstruct smscore_device_t *coredev = client->coredev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&coredev->clientslock, flags);\r\nwhile (!list_empty(&client->idlist)) {\r\nstruct smscore_idlist_t *identry =\r\n(struct smscore_idlist_t *) client->idlist.next;\r\nlist_del(&identry->entry);\r\nkfree(identry);\r\n}\r\nsms_info("%p", client->context);\r\nlist_del(&client->entry);\r\nkfree(client);\r\nspin_unlock_irqrestore(&coredev->clientslock, flags);\r\n}\r\nint smsclient_sendrequest(struct smscore_client_t *client,\r\nvoid *buffer, size_t size)\r\n{\r\nstruct smscore_device_t *coredev;\r\nstruct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) buffer;\r\nint rc;\r\nif (client == NULL) {\r\nsms_err("Got NULL client");\r\nreturn -EINVAL;\r\n}\r\ncoredev = client->coredev;\r\nif (coredev == NULL) {\r\nsms_err("Got NULL coredev");\r\nreturn -EINVAL;\r\n}\r\nrc = smscore_validate_client(client->coredev, client, 0,\r\nphdr->msgSrcId);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn coredev->sendrequest_handler(coredev->context, buffer, size);\r\n}\r\nint smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,\r\nstruct smscore_config_gpio *pinconfig)\r\n{\r\nstruct {\r\nstruct SmsMsgHdr_ST hdr;\r\nu32 data[6];\r\n} msg;\r\nif (coredev->device_flags & SMS_DEVICE_FAMILY2) {\r\nmsg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;\r\nmsg.hdr.msgDstId = HIF_TASK;\r\nmsg.hdr.msgFlags = 0;\r\nmsg.hdr.msgType = MSG_SMS_GPIO_CONFIG_EX_REQ;\r\nmsg.hdr.msgLength = sizeof(msg);\r\nmsg.data[0] = pin;\r\nmsg.data[1] = pinconfig->pullupdown;\r\nmsg.data[2] = pinconfig->outputslewrate == 0 ? 3 : 0;\r\nswitch (pinconfig->outputdriving) {\r\ncase SMS_GPIO_OUTPUTDRIVING_16mA:\r\nmsg.data[3] = 7;\r\nbreak;\r\ncase SMS_GPIO_OUTPUTDRIVING_12mA:\r\nmsg.data[3] = 5;\r\nbreak;\r\ncase SMS_GPIO_OUTPUTDRIVING_8mA:\r\nmsg.data[3] = 3;\r\nbreak;\r\ncase SMS_GPIO_OUTPUTDRIVING_4mA:\r\ndefault:\r\nmsg.data[3] = 2;\r\nbreak;\r\n}\r\nmsg.data[4] = pinconfig->direction;\r\nmsg.data[5] = 0;\r\n} else\r\nreturn -EINVAL;\r\nreturn coredev->sendrequest_handler(coredev->context,\r\n&msg, sizeof(msg));\r\n}\r\nint smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level)\r\n{\r\nstruct {\r\nstruct SmsMsgHdr_ST hdr;\r\nu32 data[3];\r\n} msg;\r\nif (pin > MAX_GPIO_PIN_NUMBER)\r\nreturn -EINVAL;\r\nmsg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;\r\nmsg.hdr.msgDstId = HIF_TASK;\r\nmsg.hdr.msgFlags = 0;\r\nmsg.hdr.msgType = MSG_SMS_GPIO_SET_LEVEL_REQ;\r\nmsg.hdr.msgLength = sizeof(msg);\r\nmsg.data[0] = pin;\r\nmsg.data[1] = level ? 1 : 0;\r\nmsg.data[2] = 0;\r\nreturn coredev->sendrequest_handler(coredev->context,\r\n&msg, sizeof(msg));\r\n}\r\nstatic int GetGpioPinParams(u32 PinNum, u32 *pTranslatedPinNum,\r\nu32 *pGroupNum, u32 *pGroupCfg) {\r\n*pGroupCfg = 1;\r\nif (PinNum <= 1) {\r\n*pTranslatedPinNum = 0;\r\n*pGroupNum = 9;\r\n*pGroupCfg = 2;\r\n} else if (PinNum >= 2 && PinNum <= 6) {\r\n*pTranslatedPinNum = 2;\r\n*pGroupNum = 0;\r\n*pGroupCfg = 2;\r\n} else if (PinNum >= 7 && PinNum <= 11) {\r\n*pTranslatedPinNum = 7;\r\n*pGroupNum = 1;\r\n} else if (PinNum >= 12 && PinNum <= 15) {\r\n*pTranslatedPinNum = 12;\r\n*pGroupNum = 2;\r\n*pGroupCfg = 3;\r\n} else if (PinNum == 16) {\r\n*pTranslatedPinNum = 16;\r\n*pGroupNum = 23;\r\n} else if (PinNum >= 17 && PinNum <= 24) {\r\n*pTranslatedPinNum = 17;\r\n*pGroupNum = 3;\r\n} else if (PinNum == 25) {\r\n*pTranslatedPinNum = 25;\r\n*pGroupNum = 6;\r\n} else if (PinNum >= 26 && PinNum <= 28) {\r\n*pTranslatedPinNum = 26;\r\n*pGroupNum = 4;\r\n} else if (PinNum == 29) {\r\n*pTranslatedPinNum = 29;\r\n*pGroupNum = 5;\r\n*pGroupCfg = 2;\r\n} else if (PinNum == 30) {\r\n*pTranslatedPinNum = 30;\r\n*pGroupNum = 8;\r\n} else if (PinNum == 31) {\r\n*pTranslatedPinNum = 31;\r\n*pGroupNum = 17;\r\n} else\r\nreturn -1;\r\n*pGroupCfg <<= 24;\r\nreturn 0;\r\n}\r\nint smscore_gpio_configure(struct smscore_device_t *coredev, u8 PinNum,\r\nstruct smscore_gpio_config *pGpioConfig) {\r\nu32 totalLen;\r\nu32 TranslatedPinNum = 0;\r\nu32 GroupNum = 0;\r\nu32 ElectricChar;\r\nu32 groupCfg;\r\nvoid *buffer;\r\nint rc;\r\nstruct SetGpioMsg {\r\nstruct SmsMsgHdr_ST xMsgHeader;\r\nu32 msgData[6];\r\n} *pMsg;\r\nif (PinNum > MAX_GPIO_PIN_NUMBER)\r\nreturn -EINVAL;\r\nif (pGpioConfig == NULL)\r\nreturn -EINVAL;\r\ntotalLen = sizeof(struct SmsMsgHdr_ST) + (sizeof(u32) * 6);\r\nbuffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\npMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);\r\npMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;\r\npMsg->xMsgHeader.msgDstId = HIF_TASK;\r\npMsg->xMsgHeader.msgFlags = 0;\r\npMsg->xMsgHeader.msgLength = (u16) totalLen;\r\npMsg->msgData[0] = PinNum;\r\nif (!(coredev->device_flags & SMS_DEVICE_FAMILY2)) {\r\npMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_REQ;\r\nif (GetGpioPinParams(PinNum, &TranslatedPinNum, &GroupNum,\r\n&groupCfg) != 0) {\r\nrc = -EINVAL;\r\ngoto free;\r\n}\r\npMsg->msgData[1] = TranslatedPinNum;\r\npMsg->msgData[2] = GroupNum;\r\nElectricChar = (pGpioConfig->PullUpDown)\r\n| (pGpioConfig->InputCharacteristics << 2)\r\n| (pGpioConfig->OutputSlewRate << 3)\r\n| (pGpioConfig->OutputDriving << 4);\r\npMsg->msgData[3] = ElectricChar;\r\npMsg->msgData[4] = pGpioConfig->Direction;\r\npMsg->msgData[5] = groupCfg;\r\n} else {\r\npMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_EX_REQ;\r\npMsg->msgData[1] = pGpioConfig->PullUpDown;\r\npMsg->msgData[2] = pGpioConfig->OutputSlewRate;\r\npMsg->msgData[3] = pGpioConfig->OutputDriving;\r\npMsg->msgData[4] = pGpioConfig->Direction;\r\npMsg->msgData[5] = 0;\r\n}\r\nsmsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);\r\nrc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,\r\n&coredev->gpio_configuration_done);\r\nif (rc != 0) {\r\nif (rc == -ETIME)\r\nsms_err("smscore_gpio_configure timeout");\r\nelse\r\nsms_err("smscore_gpio_configure error");\r\n}\r\nfree:\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nint smscore_gpio_set_level(struct smscore_device_t *coredev, u8 PinNum,\r\nu8 NewLevel) {\r\nu32 totalLen;\r\nint rc;\r\nvoid *buffer;\r\nstruct SetGpioMsg {\r\nstruct SmsMsgHdr_ST xMsgHeader;\r\nu32 msgData[3];\r\n} *pMsg;\r\nif ((NewLevel > 1) || (PinNum > MAX_GPIO_PIN_NUMBER))\r\nreturn -EINVAL;\r\ntotalLen = sizeof(struct SmsMsgHdr_ST) +\r\n(3 * sizeof(u32));\r\nbuffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\npMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);\r\npMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;\r\npMsg->xMsgHeader.msgDstId = HIF_TASK;\r\npMsg->xMsgHeader.msgFlags = 0;\r\npMsg->xMsgHeader.msgType = MSG_SMS_GPIO_SET_LEVEL_REQ;\r\npMsg->xMsgHeader.msgLength = (u16) totalLen;\r\npMsg->msgData[0] = PinNum;\r\npMsg->msgData[1] = NewLevel;\r\nsmsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);\r\nrc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,\r\n&coredev->gpio_set_level_done);\r\nif (rc != 0) {\r\nif (rc == -ETIME)\r\nsms_err("smscore_gpio_set_level timeout");\r\nelse\r\nsms_err("smscore_gpio_set_level error");\r\n}\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nint smscore_gpio_get_level(struct smscore_device_t *coredev, u8 PinNum,\r\nu8 *level) {\r\nu32 totalLen;\r\nint rc;\r\nvoid *buffer;\r\nstruct SetGpioMsg {\r\nstruct SmsMsgHdr_ST xMsgHeader;\r\nu32 msgData[2];\r\n} *pMsg;\r\nif (PinNum > MAX_GPIO_PIN_NUMBER)\r\nreturn -EINVAL;\r\ntotalLen = sizeof(struct SmsMsgHdr_ST) + (2 * sizeof(u32));\r\nbuffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\npMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);\r\npMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;\r\npMsg->xMsgHeader.msgDstId = HIF_TASK;\r\npMsg->xMsgHeader.msgFlags = 0;\r\npMsg->xMsgHeader.msgType = MSG_SMS_GPIO_GET_LEVEL_REQ;\r\npMsg->xMsgHeader.msgLength = (u16) totalLen;\r\npMsg->msgData[0] = PinNum;\r\npMsg->msgData[1] = 0;\r\nsmsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);\r\nrc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,\r\n&coredev->gpio_get_level_done);\r\nif (rc != 0) {\r\nif (rc == -ETIME)\r\nsms_err("smscore_gpio_get_level timeout");\r\nelse\r\nsms_err("smscore_gpio_get_level error");\r\n}\r\nkfree(buffer);\r\n*level = coredev->gpio_get_res;\r\nreturn rc;\r\n}\r\nstatic int __init smscore_module_init(void)\r\n{\r\nint rc = 0;\r\nINIT_LIST_HEAD(&g_smscore_notifyees);\r\nINIT_LIST_HEAD(&g_smscore_devices);\r\nkmutex_init(&g_smscore_deviceslock);\r\nINIT_LIST_HEAD(&g_smscore_registry);\r\nkmutex_init(&g_smscore_registrylock);\r\nreturn rc;\r\n}\r\nstatic void __exit smscore_module_exit(void)\r\n{\r\nkmutex_lock(&g_smscore_deviceslock);\r\nwhile (!list_empty(&g_smscore_notifyees)) {\r\nstruct smscore_device_notifyee_t *notifyee =\r\n(struct smscore_device_notifyee_t *)\r\ng_smscore_notifyees.next;\r\nlist_del(&notifyee->entry);\r\nkfree(notifyee);\r\n}\r\nkmutex_unlock(&g_smscore_deviceslock);\r\nkmutex_lock(&g_smscore_registrylock);\r\nwhile (!list_empty(&g_smscore_registry)) {\r\nstruct smscore_registry_entry_t *entry =\r\n(struct smscore_registry_entry_t *)\r\ng_smscore_registry.next;\r\nlist_del(&entry->entry);\r\nkfree(entry);\r\n}\r\nkmutex_unlock(&g_smscore_registrylock);\r\nsms_debug("");\r\n}
