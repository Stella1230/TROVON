static int wm831x_dcdc_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint mask = 1 << rdev_get_id(rdev);\r\nint reg;\r\nreg = wm831x_reg_read(wm831x, WM831X_DCDC_ENABLE);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg & mask)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int wm831x_dcdc_enable(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint mask = 1 << rdev_get_id(rdev);\r\nreturn wm831x_set_bits(wm831x, WM831X_DCDC_ENABLE, mask, mask);\r\n}\r\nstatic int wm831x_dcdc_disable(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint mask = 1 << rdev_get_id(rdev);\r\nreturn wm831x_set_bits(wm831x, WM831X_DCDC_ENABLE, mask, 0);\r\n}\r\nstatic unsigned int wm831x_dcdc_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nint val;\r\nval = wm831x_reg_read(wm831x, reg);\r\nif (val < 0)\r\nreturn val;\r\nval = (val & WM831X_DC1_ON_MODE_MASK) >> WM831X_DC1_ON_MODE_SHIFT;\r\nswitch (val) {\r\ncase WM831X_DCDC_MODE_FAST:\r\nreturn REGULATOR_MODE_FAST;\r\ncase WM831X_DCDC_MODE_NORMAL:\r\nreturn REGULATOR_MODE_NORMAL;\r\ncase WM831X_DCDC_MODE_STANDBY:\r\nreturn REGULATOR_MODE_STANDBY;\r\ncase WM831X_DCDC_MODE_IDLE:\r\nreturn REGULATOR_MODE_IDLE;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int wm831x_dcdc_set_mode_int(struct wm831x *wm831x, int reg,\r\nunsigned int mode)\r\n{\r\nint val;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = WM831X_DCDC_MODE_FAST;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = WM831X_DCDC_MODE_NORMAL;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = WM831X_DCDC_MODE_STANDBY;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nval = WM831X_DCDC_MODE_IDLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_DC1_ON_MODE_MASK,\r\nval << WM831X_DC1_ON_MODE_SHIFT);\r\n}\r\nstatic int wm831x_dcdc_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nreturn wm831x_dcdc_set_mode_int(wm831x, reg, mode);\r\n}\r\nstatic int wm831x_dcdc_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\r\nreturn wm831x_dcdc_set_mode_int(wm831x, reg, mode);\r\n}\r\nstatic int wm831x_dcdc_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint ret;\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_UV_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & (1 << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d under voltage\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\nif (rdev_get_id(rdev) < 2) {\r\nif (ret & (WM831X_DC1_OV_STS << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d over voltage\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\nif (ret & (WM831X_DC1_HC_STS << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d over current\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\n}\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & (1 << rdev_get_id(rdev))))\r\nreturn REGULATOR_STATUS_OFF;\r\nreturn REGULATOR_STATUS_ON;\r\n}\r\nstatic irqreturn_t wm831x_dcdc_uv_irq(int irq, void *data)\r\n{\r\nstruct wm831x_dcdc *dcdc = data;\r\nregulator_notifier_call_chain(dcdc->regulator,\r\nREGULATOR_EVENT_UNDER_VOLTAGE,\r\nNULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm831x_dcdc_oc_irq(int irq, void *data)\r\n{\r\nstruct wm831x_dcdc *dcdc = data;\r\nregulator_notifier_call_chain(dcdc->regulator,\r\nREGULATOR_EVENT_OVER_CURRENT,\r\nNULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm831x_buckv_list_voltage(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nif (selector <= 0x8)\r\nreturn 600000;\r\nif (selector <= WM831X_BUCKV_MAX_SELECTOR)\r\nreturn 600000 + ((selector - 0x8) * 12500);\r\nreturn -EINVAL;\r\n}\r\nstatic int wm831x_buckv_select_min_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nu16 vsel;\r\nif (min_uV < 600000)\r\nvsel = 0;\r\nelse if (min_uV <= 1800000)\r\nvsel = ((min_uV - 600000) / 12500) + 8;\r\nelse\r\nreturn -EINVAL;\r\nif (wm831x_buckv_list_voltage(rdev, vsel) > max_uV)\r\nreturn -EINVAL;\r\nreturn vsel;\r\n}\r\nstatic int wm831x_buckv_set_dvs(struct regulator_dev *rdev, int state)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nif (state == dcdc->dvs_gpio_state)\r\nreturn 0;\r\ndcdc->dvs_gpio_state = state;\r\ngpio_set_value(dcdc->dvs_gpio, state);\r\nreturn 0;\r\n}\r\nstatic int wm831x_buckv_set_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV, unsigned *selector)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint on_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nint dvs_reg = dcdc->base + WM831X_DCDC_DVS_CONTROL;\r\nint vsel, ret;\r\nvsel = wm831x_buckv_select_min_voltage(rdev, min_uV, max_uV);\r\nif (vsel < 0)\r\nreturn vsel;\r\n*selector = vsel;\r\nif (dcdc->dvs_gpio && dcdc->on_vsel == vsel)\r\nreturn wm831x_buckv_set_dvs(rdev, 0);\r\nif (dcdc->dvs_gpio && dcdc->dvs_vsel == vsel)\r\nreturn wm831x_buckv_set_dvs(rdev, 1);\r\nret = wm831x_set_bits(wm831x, on_reg, WM831X_DC1_ON_VSEL_MASK, vsel);\r\nif (ret < 0)\r\nreturn ret;\r\ndcdc->on_vsel = vsel;\r\nif (!dcdc->dvs_gpio)\r\nreturn ret;\r\nret = wm831x_buckv_set_dvs(rdev, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vsel > dcdc->dvs_vsel) {\r\nret = wm831x_set_bits(wm831x, dvs_reg,\r\nWM831X_DC1_DVS_VSEL_MASK,\r\ndcdc->dvs_vsel);\r\nif (ret == 0)\r\ndcdc->dvs_vsel = vsel;\r\nelse\r\ndev_warn(wm831x->dev,\r\n"Failed to set DCDC DVS VSEL: %d\n", ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm831x_buckv_set_suspend_voltage(struct regulator_dev *rdev,\r\nint uV)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\r\nint vsel;\r\nvsel = wm831x_buckv_select_min_voltage(rdev, uV, uV);\r\nif (vsel < 0)\r\nreturn vsel;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_DC1_SLP_VSEL_MASK, vsel);\r\n}\r\nstatic int wm831x_buckv_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nif (dcdc->dvs_gpio && dcdc->dvs_gpio_state)\r\nreturn dcdc->dvs_vsel;\r\nelse\r\nreturn dcdc->on_vsel;\r\n}\r\nstatic int wm831x_buckv_set_current_limit(struct regulator_dev *rdev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_CONTROL_2;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wm831x_dcdc_ilim); i++) {\r\nif (max_uA <= wm831x_dcdc_ilim[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(wm831x_dcdc_ilim))\r\nreturn -EINVAL;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_DC1_HC_THR_MASK, i);\r\n}\r\nstatic int wm831x_buckv_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_CONTROL_2;\r\nint val;\r\nval = wm831x_reg_read(wm831x, reg);\r\nif (val < 0)\r\nreturn val;\r\nreturn wm831x_dcdc_ilim[val & WM831X_DC1_HC_THR_MASK];\r\n}\r\nstatic __devinit void wm831x_buckv_dvs_init(struct wm831x_dcdc *dcdc,\r\nstruct wm831x_buckv_pdata *pdata)\r\n{\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint ret;\r\nu16 ctrl;\r\nif (!pdata || !pdata->dvs_gpio)\r\nreturn;\r\nret = gpio_request(pdata->dvs_gpio, "DCDC DVS");\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to get %s DVS GPIO: %d\n",\r\ndcdc->name, ret);\r\nreturn;\r\n}\r\ndcdc->dvs_gpio_state = pdata->dvs_init_state;\r\nret = gpio_direction_output(pdata->dvs_gpio, dcdc->dvs_gpio_state);\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to enable %s DVS GPIO: %d\n",\r\ndcdc->name, ret);\r\ngpio_free(pdata->dvs_gpio);\r\nreturn;\r\n}\r\ndcdc->dvs_gpio = pdata->dvs_gpio;\r\nswitch (pdata->dvs_control_src) {\r\ncase 1:\r\nctrl = 2 << WM831X_DC1_DVS_SRC_SHIFT;\r\nbreak;\r\ncase 2:\r\nctrl = 3 << WM831X_DC1_DVS_SRC_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_err(wm831x->dev, "Invalid DVS control source %d for %s\n",\r\npdata->dvs_control_src, dcdc->name);\r\nreturn;\r\n}\r\nif (!dcdc->dvs_vsel) {\r\nret = wm831x_set_bits(wm831x,\r\ndcdc->base + WM831X_DCDC_DVS_CONTROL,\r\nWM831X_DC1_DVS_VSEL_MASK, dcdc->on_vsel);\r\nif (ret == 0)\r\ndcdc->dvs_vsel = dcdc->on_vsel;\r\nelse\r\ndev_warn(wm831x->dev, "Failed to set DVS_VSEL: %d\n",\r\nret);\r\n}\r\nret = wm831x_set_bits(wm831x, dcdc->base + WM831X_DCDC_DVS_CONTROL,\r\nWM831X_DC1_DVS_SRC_MASK, ctrl);\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to set %s DVS source: %d\n",\r\ndcdc->name, ret);\r\n}\r\n}\r\nstatic __devinit int wm831x_buckv_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = wm831x->dev->platform_data;\r\nint id;\r\nstruct wm831x_dcdc *dcdc;\r\nstruct resource *res;\r\nint ret, irq;\r\nif (pdata && pdata->wm831x_num)\r\nid = (pdata->wm831x_num * 10) + 1;\r\nelse\r\nid = 0;\r\nid = pdev->id - id;\r\ndev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);\r\nif (pdata == NULL || pdata->dcdc[id] == NULL)\r\nreturn -ENODEV;\r\ndcdc = kzalloc(sizeof(struct wm831x_dcdc), GFP_KERNEL);\r\nif (dcdc == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\ndcdc->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No I/O resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndcdc->base = res->start;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "DCDC%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\ndcdc->desc.id = id;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.n_voltages = WM831X_BUCKV_MAX_SELECTOR + 1;\r\ndcdc->desc.ops = &wm831x_buckv_ops;\r\ndcdc->desc.owner = THIS_MODULE;\r\nret = wm831x_reg_read(wm831x, dcdc->base + WM831X_DCDC_ON_CONFIG);\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to read ON VSEL: %d\n", ret);\r\ngoto err;\r\n}\r\ndcdc->on_vsel = ret & WM831X_DC1_ON_VSEL_MASK;\r\nret = wm831x_reg_read(wm831x, dcdc->base + WM831X_DCDC_DVS_CONTROL);\r\nif (ret < 0) {\r\ndev_err(wm831x->dev, "Failed to read DVS VSEL: %d\n", ret);\r\ngoto err;\r\n}\r\ndcdc->dvs_vsel = ret & WM831X_DC1_DVS_VSEL_MASK;\r\nif (pdata->dcdc[id])\r\nwm831x_buckv_dvs_init(dcdc, pdata->dcdc[id]->driver_data);\r\ndcdc->regulator = regulator_register(&dcdc->desc, &pdev->dev,\r\npdata->dcdc[id], dcdc);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register DCDC%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nirq = platform_get_irq_byname(pdev, "UV");\r\nret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name, dcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err_regulator;\r\n}\r\nirq = platform_get_irq_byname(pdev, "HC");\r\nret = request_threaded_irq(irq, NULL, wm831x_dcdc_oc_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name, dcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request HC IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err_uv;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\nerr_uv:\r\nfree_irq(platform_get_irq_byname(pdev, "UV"), dcdc);\r\nerr_regulator:\r\nregulator_unregister(dcdc->regulator);\r\nerr:\r\nif (dcdc->dvs_gpio)\r\ngpio_free(dcdc->dvs_gpio);\r\nkfree(dcdc);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm831x_buckv_remove(struct platform_device *pdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(platform_get_irq_byname(pdev, "HC"), dcdc);\r\nfree_irq(platform_get_irq_byname(pdev, "UV"), dcdc);\r\nregulator_unregister(dcdc->regulator);\r\nif (dcdc->dvs_gpio)\r\ngpio_free(dcdc->dvs_gpio);\r\nkfree(dcdc);\r\nreturn 0;\r\n}\r\nstatic int wm831x_buckp_list_voltage(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nif (selector <= WM831X_BUCKP_MAX_SELECTOR)\r\nreturn 850000 + (selector * 25000);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int wm831x_buckp_set_voltage_int(struct regulator_dev *rdev, int reg,\r\nint min_uV, int max_uV, int *selector)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 vsel;\r\nif (min_uV <= 34000000)\r\nvsel = (min_uV - 850000) / 25000;\r\nelse\r\nreturn -EINVAL;\r\nif (wm831x_buckp_list_voltage(rdev, vsel) > max_uV)\r\nreturn -EINVAL;\r\n*selector = vsel;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_DC3_ON_VSEL_MASK, vsel);\r\n}\r\nstatic int wm831x_buckp_set_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV,\r\nunsigned *selector)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nreturn wm831x_buckp_set_voltage_int(rdev, reg, min_uV, max_uV,\r\nselector);\r\n}\r\nstatic int wm831x_buckp_set_suspend_voltage(struct regulator_dev *rdev,\r\nint uV)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\r\nunsigned selector;\r\nreturn wm831x_buckp_set_voltage_int(rdev, reg, uV, uV, &selector);\r\n}\r\nstatic int wm831x_buckp_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\r\nint val;\r\nval = wm831x_reg_read(wm831x, reg);\r\nif (val < 0)\r\nreturn val;\r\nreturn val & WM831X_DC3_ON_VSEL_MASK;\r\n}\r\nstatic __devinit int wm831x_buckp_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = wm831x->dev->platform_data;\r\nint id;\r\nstruct wm831x_dcdc *dcdc;\r\nstruct resource *res;\r\nint ret, irq;\r\nif (pdata && pdata->wm831x_num)\r\nid = (pdata->wm831x_num * 10) + 1;\r\nelse\r\nid = 0;\r\nid = pdev->id - id;\r\ndev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);\r\nif (pdata == NULL || pdata->dcdc[id] == NULL)\r\nreturn -ENODEV;\r\ndcdc = kzalloc(sizeof(struct wm831x_dcdc), GFP_KERNEL);\r\nif (dcdc == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\ndcdc->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No I/O resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndcdc->base = res->start;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "DCDC%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\ndcdc->desc.id = id;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.n_voltages = WM831X_BUCKP_MAX_SELECTOR + 1;\r\ndcdc->desc.ops = &wm831x_buckp_ops;\r\ndcdc->desc.owner = THIS_MODULE;\r\ndcdc->regulator = regulator_register(&dcdc->desc, &pdev->dev,\r\npdata->dcdc[id], dcdc);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register DCDC%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nirq = platform_get_irq_byname(pdev, "UV");\r\nret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name, dcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err_regulator;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\nerr_regulator:\r\nregulator_unregister(dcdc->regulator);\r\nerr:\r\nkfree(dcdc);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm831x_buckp_remove(struct platform_device *pdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(platform_get_irq_byname(pdev, "UV"), dcdc);\r\nregulator_unregister(dcdc->regulator);\r\nkfree(dcdc);\r\nreturn 0;\r\n}\r\nstatic int wm831x_boostp_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = dcdc->wm831x;\r\nint ret;\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_UV_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & (1 << rdev_get_id(rdev))) {\r\ndev_dbg(wm831x->dev, "DCDC%d under voltage\n",\r\nrdev_get_id(rdev) + 1);\r\nreturn REGULATOR_STATUS_ERROR;\r\n}\r\nret = wm831x_reg_read(wm831x, WM831X_DCDC_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & (1 << rdev_get_id(rdev)))\r\nreturn REGULATOR_STATUS_ON;\r\nelse\r\nreturn REGULATOR_STATUS_OFF;\r\n}\r\nstatic __devinit int wm831x_boostp_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = wm831x->dev->platform_data;\r\nint id = pdev->id % ARRAY_SIZE(pdata->dcdc);\r\nstruct wm831x_dcdc *dcdc;\r\nstruct resource *res;\r\nint ret, irq;\r\ndev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);\r\nif (pdata == NULL || pdata->dcdc[id] == NULL)\r\nreturn -ENODEV;\r\ndcdc = kzalloc(sizeof(struct wm831x_dcdc), GFP_KERNEL);\r\nif (dcdc == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\ndcdc->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No I/O resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndcdc->base = res->start;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "DCDC%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\ndcdc->desc.id = id;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.ops = &wm831x_boostp_ops;\r\ndcdc->desc.owner = THIS_MODULE;\r\ndcdc->regulator = regulator_register(&dcdc->desc, &pdev->dev,\r\npdata->dcdc[id], dcdc);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register DCDC%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nirq = platform_get_irq_byname(pdev, "UV");\r\nret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,\r\nIRQF_TRIGGER_RISING, dcdc->name,\r\ndcdc);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err_regulator;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\nerr_regulator:\r\nregulator_unregister(dcdc->regulator);\r\nerr:\r\nkfree(dcdc);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm831x_boostp_remove(struct platform_device *pdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(platform_get_irq_byname(pdev, "UV"), dcdc);\r\nregulator_unregister(dcdc->regulator);\r\nkfree(dcdc);\r\nreturn 0;\r\n}\r\nstatic __devinit int wm831x_epe_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = wm831x->dev->platform_data;\r\nint id = pdev->id % ARRAY_SIZE(pdata->epe);\r\nstruct wm831x_dcdc *dcdc;\r\nint ret;\r\ndev_dbg(&pdev->dev, "Probing EPE%d\n", id + 1);\r\nif (pdata == NULL || pdata->epe[id] == NULL)\r\nreturn -ENODEV;\r\ndcdc = kzalloc(sizeof(struct wm831x_dcdc), GFP_KERNEL);\r\nif (dcdc == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\ndcdc->wm831x = wm831x;\r\nsnprintf(dcdc->name, sizeof(dcdc->name), "EPE%d", id + 1);\r\ndcdc->desc.name = dcdc->name;\r\ndcdc->desc.id = id + WM831X_EPE_BASE;\r\ndcdc->desc.ops = &wm831x_epe_ops;\r\ndcdc->desc.type = REGULATOR_VOLTAGE;\r\ndcdc->desc.owner = THIS_MODULE;\r\ndcdc->regulator = regulator_register(&dcdc->desc, &pdev->dev,\r\npdata->epe[id], dcdc);\r\nif (IS_ERR(dcdc->regulator)) {\r\nret = PTR_ERR(dcdc->regulator);\r\ndev_err(wm831x->dev, "Failed to register EPE%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, dcdc);\r\nreturn 0;\r\nerr:\r\nkfree(dcdc);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm831x_epe_remove(struct platform_device *pdev)\r\n{\r\nstruct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nregulator_unregister(dcdc->regulator);\r\nkfree(dcdc);\r\nreturn 0;\r\n}\r\nstatic int __init wm831x_dcdc_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&wm831x_buckv_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x BUCKV driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_buckp_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x BUCKP driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_boostp_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x BOOST driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_epe_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x EPE driver: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic void __exit wm831x_dcdc_exit(void)\r\n{\r\nplatform_driver_unregister(&wm831x_epe_driver);\r\nplatform_driver_unregister(&wm831x_boostp_driver);\r\nplatform_driver_unregister(&wm831x_buckp_driver);\r\nplatform_driver_unregister(&wm831x_buckv_driver);\r\n}
