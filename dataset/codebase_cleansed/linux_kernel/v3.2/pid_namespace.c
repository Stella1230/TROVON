static struct kmem_cache *create_pid_cachep(int nr_ids)\r\n{\r\nstruct pid_cache *pcache;\r\nstruct kmem_cache *cachep;\r\nmutex_lock(&pid_caches_mutex);\r\nlist_for_each_entry(pcache, &pid_caches_lh, list)\r\nif (pcache->nr_ids == nr_ids)\r\ngoto out;\r\npcache = kmalloc(sizeof(struct pid_cache), GFP_KERNEL);\r\nif (pcache == NULL)\r\ngoto err_alloc;\r\nsnprintf(pcache->name, sizeof(pcache->name), "pid_%d", nr_ids);\r\ncachep = kmem_cache_create(pcache->name,\r\nsizeof(struct pid) + (nr_ids - 1) * sizeof(struct upid),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (cachep == NULL)\r\ngoto err_cachep;\r\npcache->nr_ids = nr_ids;\r\npcache->cachep = cachep;\r\nlist_add(&pcache->list, &pid_caches_lh);\r\nout:\r\nmutex_unlock(&pid_caches_mutex);\r\nreturn pcache->cachep;\r\nerr_cachep:\r\nkfree(pcache);\r\nerr_alloc:\r\nmutex_unlock(&pid_caches_mutex);\r\nreturn NULL;\r\n}\r\nstatic struct pid_namespace *create_pid_namespace(struct pid_namespace *parent_pid_ns)\r\n{\r\nstruct pid_namespace *ns;\r\nunsigned int level = parent_pid_ns->level + 1;\r\nint i, err = -ENOMEM;\r\nns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);\r\nif (ns == NULL)\r\ngoto out;\r\nns->pidmap[0].page = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!ns->pidmap[0].page)\r\ngoto out_free;\r\nns->pid_cachep = create_pid_cachep(level + 1);\r\nif (ns->pid_cachep == NULL)\r\ngoto out_free_map;\r\nkref_init(&ns->kref);\r\nns->level = level;\r\nns->parent = get_pid_ns(parent_pid_ns);\r\nset_bit(0, ns->pidmap[0].page);\r\natomic_set(&ns->pidmap[0].nr_free, BITS_PER_PAGE - 1);\r\nfor (i = 1; i < PIDMAP_ENTRIES; i++)\r\natomic_set(&ns->pidmap[i].nr_free, BITS_PER_PAGE);\r\nerr = pid_ns_prepare_proc(ns);\r\nif (err)\r\ngoto out_put_parent_pid_ns;\r\nreturn ns;\r\nout_put_parent_pid_ns:\r\nput_pid_ns(parent_pid_ns);\r\nout_free_map:\r\nkfree(ns->pidmap[0].page);\r\nout_free:\r\nkmem_cache_free(pid_ns_cachep, ns);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void destroy_pid_namespace(struct pid_namespace *ns)\r\n{\r\nint i;\r\nfor (i = 0; i < PIDMAP_ENTRIES; i++)\r\nkfree(ns->pidmap[i].page);\r\nkmem_cache_free(pid_ns_cachep, ns);\r\n}\r\nstruct pid_namespace *copy_pid_ns(unsigned long flags, struct pid_namespace *old_ns)\r\n{\r\nif (!(flags & CLONE_NEWPID))\r\nreturn get_pid_ns(old_ns);\r\nif (flags & (CLONE_THREAD|CLONE_PARENT))\r\nreturn ERR_PTR(-EINVAL);\r\nreturn create_pid_namespace(old_ns);\r\n}\r\nvoid free_pid_ns(struct kref *kref)\r\n{\r\nstruct pid_namespace *ns, *parent;\r\nns = container_of(kref, struct pid_namespace, kref);\r\nparent = ns->parent;\r\ndestroy_pid_namespace(ns);\r\nif (parent != NULL)\r\nput_pid_ns(parent);\r\n}\r\nvoid zap_pid_ns_processes(struct pid_namespace *pid_ns)\r\n{\r\nint nr;\r\nint rc;\r\nstruct task_struct *task;\r\nread_lock(&tasklist_lock);\r\nnr = next_pidmap(pid_ns, 1);\r\nwhile (nr > 0) {\r\nrcu_read_lock();\r\ntask = pid_task(find_vpid(nr), PIDTYPE_PID);\r\nif (task)\r\nsend_sig_info(SIGKILL, SEND_SIG_NOINFO, task);\r\nrcu_read_unlock();\r\nnr = next_pidmap(pid_ns, nr);\r\n}\r\nread_unlock(&tasklist_lock);\r\ndo {\r\nclear_thread_flag(TIF_SIGPENDING);\r\nrc = sys_wait4(-1, NULL, __WALL, NULL);\r\n} while (rc != -ECHILD);\r\nacct_exit_ns(pid_ns);\r\nreturn;\r\n}\r\nstatic __init int pid_namespaces_init(void)\r\n{\r\npid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC);\r\nreturn 0;\r\n}
