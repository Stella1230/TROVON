static enum ata_completion_errors sas_to_ata_err(struct task_status_struct *ts)\r\n{\r\nif (ts->resp == SAS_TASK_UNDELIVERED)\r\nreturn AC_ERR_ATA_BUS;\r\nswitch (ts->stat) {\r\ncase SAS_DEV_NO_RESPONSE:\r\nreturn AC_ERR_TIMEOUT;\r\ncase SAS_INTERRUPTED:\r\ncase SAS_PHY_DOWN:\r\ncase SAS_NAK_R_ERR:\r\nreturn AC_ERR_ATA_BUS;\r\ncase SAS_DATA_UNDERRUN:\r\nreturn 0;\r\ncase SAS_DATA_OVERRUN:\r\ncase SAS_QUEUE_FULL:\r\ncase SAS_DEVICE_UNKNOWN:\r\ncase SAS_SG_ERR:\r\nreturn AC_ERR_INVALID;\r\ncase SAS_OPEN_TO:\r\ncase SAS_OPEN_REJECT:\r\nSAS_DPRINTK("%s: Saw error %d. What to do?\n",\r\n__func__, ts->stat);\r\nreturn AC_ERR_OTHER;\r\ncase SAM_STAT_CHECK_CONDITION:\r\ncase SAS_ABORTED_TASK:\r\nreturn AC_ERR_DEV;\r\ncase SAS_PROTO_RESPONSE:\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void sas_ata_task_done(struct sas_task *task)\r\n{\r\nstruct ata_queued_cmd *qc = task->uldd_task;\r\nstruct domain_device *dev;\r\nstruct task_status_struct *stat = &task->task_status;\r\nstruct ata_task_resp *resp = (struct ata_task_resp *)stat->buf;\r\nstruct sas_ha_struct *sas_ha;\r\nenum ata_completion_errors ac;\r\nunsigned long flags;\r\nstruct ata_link *link;\r\nif (!qc)\r\ngoto qc_already_gone;\r\ndev = qc->ap->private_data;\r\nsas_ha = dev->port->ha;\r\nlink = &dev->sata_dev.ap->link;\r\nspin_lock_irqsave(dev->sata_dev.ap->lock, flags);\r\nif (stat->stat == SAS_PROTO_RESPONSE || stat->stat == SAM_STAT_GOOD ||\r\n((stat->stat == SAM_STAT_CHECK_CONDITION &&\r\ndev->sata_dev.command_set == ATAPI_COMMAND_SET))) {\r\nata_tf_from_fis(resp->ending_fis, &dev->sata_dev.tf);\r\nif (!link->sactive) {\r\nqc->err_mask |= ac_err_mask(dev->sata_dev.tf.command);\r\n} else {\r\nlink->eh_info.err_mask |= ac_err_mask(dev->sata_dev.tf.command);\r\nif (unlikely(link->eh_info.err_mask))\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\n}\r\ndev->sata_dev.sstatus = resp->sstatus;\r\ndev->sata_dev.serror = resp->serror;\r\ndev->sata_dev.scontrol = resp->scontrol;\r\n} else {\r\nac = sas_to_ata_err(stat);\r\nif (ac) {\r\nSAS_DPRINTK("%s: SAS error %x\n", __func__,\r\nstat->stat);\r\nif (!link->sactive) {\r\nqc->err_mask = ac;\r\n} else {\r\nlink->eh_info.err_mask |= AC_ERR_DEV;\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\n}\r\ndev->sata_dev.tf.feature = 0x04;\r\ndev->sata_dev.tf.command = ATA_ERR;\r\n}\r\n}\r\nqc->lldd_task = NULL;\r\nif (qc->scsicmd)\r\nASSIGN_SAS_TASK(qc->scsicmd, NULL);\r\nata_qc_complete(qc);\r\nspin_unlock_irqrestore(dev->sata_dev.ap->lock, flags);\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (qc->scsicmd && task->task_state_flags & SAS_TASK_STATE_ABORTED)\r\nscsi_eh_finish_cmd(qc->scsicmd, &sas_ha->eh_done_q);\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nqc_already_gone:\r\nlist_del_init(&task->list);\r\nsas_free_task(task);\r\n}\r\nstatic unsigned int sas_ata_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nint res;\r\nstruct sas_task *task;\r\nstruct domain_device *dev = qc->ap->private_data;\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nstruct Scsi_Host *host = sas_ha->core.shost;\r\nstruct sas_internal *i = to_sas_internal(host->transportt);\r\nstruct scatterlist *sg;\r\nunsigned int xfer = 0;\r\nunsigned int si;\r\nif (dev->gone)\r\nreturn AC_ERR_SYSTEM;\r\ntask = sas_alloc_task(GFP_ATOMIC);\r\nif (!task)\r\nreturn AC_ERR_SYSTEM;\r\ntask->dev = dev;\r\ntask->task_proto = SAS_PROTOCOL_STP;\r\ntask->task_done = sas_ata_task_done;\r\nif (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\r\nqc->tf.command == ATA_CMD_FPDMA_READ) {\r\nqc->tf.nsect = 0;\r\n}\r\nata_tf_to_fis(&qc->tf, 1, 0, (u8*)&task->ata_task.fis);\r\ntask->uldd_task = qc;\r\nif (ata_is_atapi(qc->tf.protocol)) {\r\nmemcpy(task->ata_task.atapi_packet, qc->cdb, qc->dev->cdb_len);\r\ntask->total_xfer_len = qc->nbytes;\r\ntask->num_scatter = qc->n_elem;\r\n} else {\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si)\r\nxfer += sg->length;\r\ntask->total_xfer_len = xfer;\r\ntask->num_scatter = si;\r\n}\r\ntask->data_dir = qc->dma_dir;\r\ntask->scatter = qc->sg;\r\ntask->ata_task.retry_count = 1;\r\ntask->task_state_flags = SAS_TASK_STATE_PENDING;\r\nqc->lldd_task = task;\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_NCQ:\r\ntask->ata_task.use_ncq = 1;\r\ncase ATAPI_PROT_DMA:\r\ncase ATA_PROT_DMA:\r\ntask->ata_task.dma_xfer = 1;\r\nbreak;\r\n}\r\nif (qc->scsicmd)\r\nASSIGN_SAS_TASK(qc->scsicmd, task);\r\nif (sas_ha->lldd_max_execute_num < 2)\r\nres = i->dft->lldd_execute_task(task, 1, GFP_ATOMIC);\r\nelse\r\nres = sas_queue_up(task);\r\nif (res) {\r\nSAS_DPRINTK("lldd_execute_task returned: %d\n", res);\r\nif (qc->scsicmd)\r\nASSIGN_SAS_TASK(qc->scsicmd, NULL);\r\nsas_free_task(task);\r\nreturn AC_ERR_SYSTEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool sas_ata_qc_fill_rtf(struct ata_queued_cmd *qc)\r\n{\r\nstruct domain_device *dev = qc->ap->private_data;\r\nmemcpy(&qc->result_tf, &dev->sata_dev.tf, sizeof(qc->result_tf));\r\nreturn true;\r\n}\r\nstatic int sas_ata_hard_reset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_internal *i =\r\nto_sas_internal(dev->port->ha->core.shost->transportt);\r\nint res = TMF_RESP_FUNC_FAILED;\r\nint ret = 0;\r\nif (i->dft->lldd_I_T_nexus_reset)\r\nres = i->dft->lldd_I_T_nexus_reset(dev);\r\nif (res != TMF_RESP_FUNC_COMPLETE) {\r\nSAS_DPRINTK("%s: Unable to reset I T nexus?\n", __func__);\r\nret = -EAGAIN;\r\n}\r\nswitch (dev->sata_dev.command_set) {\r\ncase ATA_COMMAND_SET:\r\nSAS_DPRINTK("%s: Found ATA device.\n", __func__);\r\n*class = ATA_DEV_ATA;\r\nbreak;\r\ncase ATAPI_COMMAND_SET:\r\nSAS_DPRINTK("%s: Found ATAPI device.\n", __func__);\r\n*class = ATA_DEV_ATAPI;\r\nbreak;\r\ndefault:\r\nSAS_DPRINTK("%s: Unknown SATA command set: %d.\n",\r\n__func__,\r\ndev->sata_dev.command_set);\r\n*class = ATA_DEV_UNKNOWN;\r\nbreak;\r\n}\r\nap->cbl = ATA_CBL_SATA;\r\nreturn ret;\r\n}\r\nstatic int sas_ata_soft_reset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_internal *i =\r\nto_sas_internal(dev->port->ha->core.shost->transportt);\r\nint res = TMF_RESP_FUNC_FAILED;\r\nint ret = 0;\r\nif (i->dft->lldd_ata_soft_reset)\r\nres = i->dft->lldd_ata_soft_reset(dev);\r\nif (res != TMF_RESP_FUNC_COMPLETE) {\r\nSAS_DPRINTK("%s: Unable to soft reset\n", __func__);\r\nret = -EAGAIN;\r\n}\r\nswitch (dev->sata_dev.command_set) {\r\ncase ATA_COMMAND_SET:\r\nSAS_DPRINTK("%s: Found ATA device.\n", __func__);\r\n*class = ATA_DEV_ATA;\r\nbreak;\r\ncase ATAPI_COMMAND_SET:\r\nSAS_DPRINTK("%s: Found ATAPI device.\n", __func__);\r\n*class = ATA_DEV_ATAPI;\r\nbreak;\r\ndefault:\r\nSAS_DPRINTK("%s: Unknown SATA command set: %d.\n",\r\n__func__, dev->sata_dev.command_set);\r\n*class = ATA_DEV_UNKNOWN;\r\nbreak;\r\n}\r\nap->cbl = ATA_CBL_SATA;\r\nreturn ret;\r\n}\r\nstatic void sas_ata_post_internal(struct ata_queued_cmd *qc)\r\n{\r\nif (qc->flags & ATA_QCFLAG_FAILED)\r\nqc->err_mask |= AC_ERR_OTHER;\r\nif (qc->err_mask) {\r\nstruct sas_task *task = qc->lldd_task;\r\nunsigned long flags;\r\nqc->lldd_task = NULL;\r\nif (task) {\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\ntask->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\ntask->uldd_task = NULL;\r\n__sas_task_abort(task);\r\n}\r\n}\r\n}\r\nint sas_ata_init_host_and_port(struct domain_device *found_dev,\r\nstruct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nstruct ata_port *ap;\r\nata_host_init(&found_dev->sata_dev.ata_host,\r\nha->dev,\r\nsata_port_info.flags,\r\n&sas_sata_ops);\r\nap = ata_sas_port_alloc(&found_dev->sata_dev.ata_host,\r\n&sata_port_info,\r\nshost);\r\nif (!ap) {\r\nSAS_DPRINTK("ata_sas_port_alloc failed.\n");\r\nreturn -ENODEV;\r\n}\r\nap->private_data = found_dev;\r\nap->cbl = ATA_CBL_SATA;\r\nap->scsi_host = shost;\r\nfound_dev->sata_dev.ap = ap;\r\nreturn 0;\r\n}\r\nvoid sas_ata_task_abort(struct sas_task *task)\r\n{\r\nstruct ata_queued_cmd *qc = task->uldd_task;\r\nstruct completion *waiting;\r\nif (qc->scsicmd) {\r\nstruct request_queue *q = qc->scsicmd->device->request_queue;\r\nunsigned long flags;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nblk_abort_request(qc->scsicmd->request);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nscsi_schedule_eh(qc->scsicmd->device->host);\r\nreturn;\r\n}\r\nqc->flags &= ~ATA_QCFLAG_ACTIVE;\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\nqc->err_mask |= AC_ERR_TIMEOUT;\r\nwaiting = qc->private_data;\r\ncomplete(waiting);\r\n}\r\nstatic void sas_task_timedout(unsigned long _task)\r\n{\r\nstruct sas_task *task = (void *) _task;\r\nunsigned long flags;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\r\ntask->task_state_flags |= SAS_TASK_STATE_ABORTED;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\ncomplete(&task->completion);\r\n}\r\nstatic void sas_disc_task_done(struct sas_task *task)\r\n{\r\nif (!del_timer(&task->timer))\r\nreturn;\r\ncomplete(&task->completion);\r\n}\r\nstatic int sas_execute_task(struct sas_task *task, void *buffer, int size,\r\nenum dma_data_direction dma_dir)\r\n{\r\nint res = 0;\r\nstruct scatterlist *scatter = NULL;\r\nstruct task_status_struct *ts = &task->task_status;\r\nint num_scatter = 0;\r\nint retries = 0;\r\nstruct sas_internal *i =\r\nto_sas_internal(task->dev->port->ha->core.shost->transportt);\r\nif (dma_dir != DMA_NONE) {\r\nscatter = kzalloc(sizeof(*scatter), GFP_KERNEL);\r\nif (!scatter)\r\ngoto out;\r\nsg_init_one(scatter, buffer, size);\r\nnum_scatter = 1;\r\n}\r\ntask->task_proto = task->dev->tproto;\r\ntask->scatter = scatter;\r\ntask->num_scatter = num_scatter;\r\ntask->total_xfer_len = size;\r\ntask->data_dir = dma_dir;\r\ntask->task_done = sas_disc_task_done;\r\nif (dma_dir != DMA_NONE &&\r\nsas_protocol_ata(task->task_proto)) {\r\ntask->num_scatter = dma_map_sg(task->dev->port->ha->dev,\r\ntask->scatter,\r\ntask->num_scatter,\r\ntask->data_dir);\r\n}\r\nfor (retries = 0; retries < 5; retries++) {\r\ntask->task_state_flags = SAS_TASK_STATE_PENDING;\r\ninit_completion(&task->completion);\r\ntask->timer.data = (unsigned long) task;\r\ntask->timer.function = sas_task_timedout;\r\ntask->timer.expires = jiffies + SAS_DEV_TIMEOUT*HZ;\r\nadd_timer(&task->timer);\r\nres = i->dft->lldd_execute_task(task, 1, GFP_KERNEL);\r\nif (res) {\r\ndel_timer(&task->timer);\r\nSAS_DPRINTK("executing SAS discovery task failed:%d\n",\r\nres);\r\ngoto ex_err;\r\n}\r\nwait_for_completion(&task->completion);\r\nres = -ECOMM;\r\nif (task->task_state_flags & SAS_TASK_STATE_ABORTED) {\r\nint res2;\r\nSAS_DPRINTK("task aborted, flags:0x%x\n",\r\ntask->task_state_flags);\r\nres2 = i->dft->lldd_abort_task(task);\r\nSAS_DPRINTK("came back from abort task\n");\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\r\nif (res2 == TMF_RESP_FUNC_COMPLETE)\r\ncontinue;\r\nelse\r\ngoto ex_err;\r\n}\r\n}\r\nif (task->task_status.stat == SAM_STAT_BUSY ||\r\ntask->task_status.stat == SAM_STAT_TASK_SET_FULL ||\r\ntask->task_status.stat == SAS_QUEUE_FULL) {\r\nSAS_DPRINTK("task: q busy, sleeping...\n");\r\nschedule_timeout_interruptible(HZ);\r\n} else if (task->task_status.stat == SAM_STAT_CHECK_CONDITION) {\r\nstruct scsi_sense_hdr shdr;\r\nif (!scsi_normalize_sense(ts->buf, ts->buf_valid_size,\r\n&shdr)) {\r\nSAS_DPRINTK("couldn't normalize sense\n");\r\ncontinue;\r\n}\r\nif ((shdr.sense_key == 6 && shdr.asc == 0x29) ||\r\n(shdr.sense_key == 2 && shdr.asc == 4 &&\r\nshdr.ascq == 1)) {\r\nSAS_DPRINTK("device %016llx LUN: %016llx "\r\n"powering up or not ready yet, "\r\n"sleeping...\n",\r\nSAS_ADDR(task->dev->sas_addr),\r\nSAS_ADDR(task->ssp_task.LUN));\r\nschedule_timeout_interruptible(5*HZ);\r\n} else if (shdr.sense_key == 1) {\r\nres = 0;\r\nbreak;\r\n} else if (shdr.sense_key == 5) {\r\nbreak;\r\n} else {\r\nSAS_DPRINTK("dev %016llx LUN: %016llx "\r\n"sense key:0x%x ASC:0x%x ASCQ:0x%x"\r\n"\n",\r\nSAS_ADDR(task->dev->sas_addr),\r\nSAS_ADDR(task->ssp_task.LUN),\r\nshdr.sense_key,\r\nshdr.asc, shdr.ascq);\r\n}\r\n} else if (task->task_status.resp != SAS_TASK_COMPLETE ||\r\ntask->task_status.stat != SAM_STAT_GOOD) {\r\nSAS_DPRINTK("task finished with resp:0x%x, "\r\n"stat:0x%x\n",\r\ntask->task_status.resp,\r\ntask->task_status.stat);\r\ngoto ex_err;\r\n} else {\r\nres = 0;\r\nbreak;\r\n}\r\n}\r\nex_err:\r\nif (dma_dir != DMA_NONE) {\r\nif (sas_protocol_ata(task->task_proto))\r\ndma_unmap_sg(task->dev->port->ha->dev,\r\ntask->scatter, task->num_scatter,\r\ntask->data_dir);\r\nkfree(scatter);\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic void sas_get_ata_command_set(struct domain_device *dev)\r\n{\r\nstruct dev_to_host_fis *fis =\r\n(struct dev_to_host_fis *) dev->frame_rcvd;\r\nif ((fis->sector_count == 1 &&\r\nfis->lbal == 1 &&\r\nfis->lbam == 0 &&\r\nfis->lbah == 0 &&\r\nfis->device == 0)\r\n||\r\n(fis->sector_count == 0 &&\r\nfis->lbal == 0 &&\r\nfis->lbam == 0xCE &&\r\nfis->lbah == 0xAA &&\r\n(fis->device & ~0x10) == 0))\r\ndev->sata_dev.command_set = ATA_COMMAND_SET;\r\nelse if ((fis->interrupt_reason == 1 &&\r\nfis->lbal == 1 &&\r\nfis->byte_count_low == 0x14 &&\r\nfis->byte_count_high == 0xEB &&\r\n(fis->device & ~0x10) == 0))\r\ndev->sata_dev.command_set = ATAPI_COMMAND_SET;\r\nelse if ((fis->sector_count == 1 &&\r\nfis->lbal == 1 &&\r\nfis->lbam == 0x3C &&\r\nfis->lbah == 0xC3 &&\r\nfis->device == 0)\r\n||\r\n(fis->interrupt_reason == 1 &&\r\nfis->lbal == 1 &&\r\nfis->byte_count_low == 0x69 &&\r\nfis->byte_count_high == 0x96 &&\r\n(fis->device & ~0x10) == 0))\r\ndev->sata_dev.command_set = ATAPI_COMMAND_SET;\r\n}\r\nstatic int sas_issue_ata_cmd(struct domain_device *dev, u8 command,\r\nu8 features, void *buffer, int size,\r\nenum dma_data_direction dma_dir)\r\n{\r\nint res = 0;\r\nstruct sas_task *task;\r\nstruct dev_to_host_fis *d2h_fis = (struct dev_to_host_fis *)\r\n&dev->frame_rcvd[0];\r\nres = -ENOMEM;\r\ntask = sas_alloc_task(GFP_KERNEL);\r\nif (!task)\r\ngoto out;\r\ntask->dev = dev;\r\ntask->ata_task.fis.fis_type = 0x27;\r\ntask->ata_task.fis.command = command;\r\ntask->ata_task.fis.features = features;\r\ntask->ata_task.fis.device = d2h_fis->device;\r\ntask->ata_task.retry_count = 1;\r\nres = sas_execute_task(task, buffer, size, dma_dir);\r\nsas_free_task(task);\r\nout:\r\nreturn res;\r\n}\r\nstatic int sas_discover_sata_dev(struct domain_device *dev)\r\n{\r\nint res;\r\n__le16 *identify_x;\r\nu8 command;\r\nidentify_x = kzalloc(512, GFP_KERNEL);\r\nif (!identify_x)\r\nreturn -ENOMEM;\r\nif (dev->sata_dev.command_set == ATA_COMMAND_SET) {\r\ndev->sata_dev.identify_device = identify_x;\r\ncommand = ATA_IDENTIFY_DEV;\r\n} else {\r\ndev->sata_dev.identify_packet_device = identify_x;\r\ncommand = ATA_IDENTIFY_PACKET_DEV;\r\n}\r\nres = sas_issue_ata_cmd(dev, command, 0, identify_x, 512,\r\nDMA_FROM_DEVICE);\r\nif (res)\r\ngoto out_err;\r\nif (le16_to_cpu(identify_x[0]) & 4) {\r\nSAS_DPRINTK("sending SET FEATURE/PUP_STBY_SPIN_UP to "\r\n"dev %llx\n", SAS_ADDR(dev->sas_addr));\r\nif (!(identify_x[83] & cpu_to_le16(1<<6)))\r\ngoto cont1;\r\nres = sas_issue_ata_cmd(dev, ATA_SET_FEATURES,\r\nATA_FEATURE_PUP_STBY_SPIN_UP,\r\nNULL, 0, DMA_NONE);\r\nif (res)\r\ngoto cont1;\r\nschedule_timeout_interruptible(5*HZ);\r\nres = sas_issue_ata_cmd(dev, command, 0, identify_x, 512,\r\nDMA_FROM_DEVICE);\r\nif (res)\r\ngoto out_err;\r\n}\r\ncont1:\r\nsas_fill_in_rphy(dev, dev->rphy);\r\nreturn 0;\r\nout_err:\r\ndev->sata_dev.identify_packet_device = NULL;\r\ndev->sata_dev.identify_device = NULL;\r\nkfree(identify_x);\r\nreturn res;\r\n}\r\nstatic int sas_discover_sata_pm(struct domain_device *dev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nint sas_discover_sata(struct domain_device *dev)\r\n{\r\nint res;\r\nsas_get_ata_command_set(dev);\r\nres = sas_notify_lldd_dev_found(dev);\r\nif (res)\r\nreturn res;\r\nswitch (dev->dev_type) {\r\ncase SATA_DEV:\r\nres = sas_discover_sata_dev(dev);\r\nbreak;\r\ncase SATA_PM:\r\nres = sas_discover_sata_pm(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsas_notify_lldd_dev_gone(dev);\r\nif (!res) {\r\nsas_notify_lldd_dev_found(dev);\r\nres = sas_rphy_add(dev->rphy);\r\n}\r\nreturn res;\r\n}\r\nvoid sas_ata_strategy_handler(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, shost) {\r\nstruct domain_device *ddev = sdev_to_domain_dev(sdev);\r\nstruct ata_port *ap = ddev->sata_dev.ap;\r\nif (!dev_is_sata(ddev))\r\ncontinue;\r\nata_port_printk(ap, KERN_DEBUG, "sas eh calling libata port error handler");\r\nata_scsi_port_error_handler(shost, ap);\r\n}\r\n}\r\nint sas_ata_timed_out(struct scsi_cmnd *cmd, struct sas_task *task,\r\nenum blk_eh_timer_return *rtn)\r\n{\r\nstruct domain_device *ddev = cmd_to_domain_dev(cmd);\r\nif (!dev_is_sata(ddev) || task)\r\nreturn 0;\r\n*rtn = BLK_EH_NOT_HANDLED;\r\nreturn 1;\r\n}\r\nint sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nint rtn = 0;\r\nstruct scsi_cmnd *cmd, *n;\r\nstruct ata_port *ap;\r\ndo {\r\nLIST_HEAD(sata_q);\r\nap = NULL;\r\nlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\r\nstruct domain_device *ddev = cmd_to_domain_dev(cmd);\r\nif (!dev_is_sata(ddev) || TO_SAS_TASK(cmd))\r\ncontinue;\r\nif (ap && ap != ddev->sata_dev.ap)\r\ncontinue;\r\nap = ddev->sata_dev.ap;\r\nrtn = 1;\r\nlist_move(&cmd->eh_entry, &sata_q);\r\n}\r\nif (!list_empty(&sata_q)) {\r\nata_port_printk(ap, KERN_DEBUG, "sas eh calling libata cmd error handler\n");\r\nata_scsi_cmd_error_handler(shost, ap, &sata_q);\r\nwhile (!list_empty(&sata_q))\r\nlist_del_init(sata_q.next);\r\n}\r\n} while (ap);\r\nreturn rtn;\r\n}
