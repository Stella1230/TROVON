int PIPEnsControlOutAsyn(\r\nPSDevice pDevice,\r\nBYTE byRequest,\r\nWORD wValue,\r\nWORD wIndex,\r\nWORD wLength,\r\nPBYTE pbyBuffer\r\n)\r\n{\r\nint ntStatus;\r\nif (pDevice->Flags & fMP_DISCONNECTED)\r\nreturn STATUS_FAILURE;\r\nif (pDevice->Flags & fMP_CONTROL_WRITES)\r\nreturn STATUS_FAILURE;\r\nif (in_interrupt()) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"in_interrupt return ..byRequest %x\n", byRequest);\r\nreturn STATUS_FAILURE;\r\n}\r\nntStatus = usb_control_msg(\r\npDevice->usb,\r\nusb_sndctrlpipe(pDevice->usb , 0),\r\nbyRequest,\r\n0x40,\r\nwValue,\r\nwIndex,\r\n(void *) pbyBuffer,\r\nwLength,\r\nHZ\r\n);\r\nif (ntStatus >= 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"usb_sndctrlpipe ntStatus= %d\n", ntStatus);\r\nntStatus = 0;\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"usb_sndctrlpipe fail, ntStatus= %d\n", ntStatus);\r\n}\r\nreturn ntStatus;\r\n}\r\nint PIPEnsControlOut(\r\nPSDevice pDevice,\r\nBYTE byRequest,\r\nWORD wValue,\r\nWORD wIndex,\r\nWORD wLength,\r\nPBYTE pbyBuffer\r\n)\r\n{\r\nint ntStatus = 0;\r\nint ii;\r\nif (pDevice->Flags & fMP_DISCONNECTED)\r\nreturn STATUS_FAILURE;\r\nif (pDevice->Flags & fMP_CONTROL_WRITES)\r\nreturn STATUS_FAILURE;\r\npDevice->sUsbCtlRequest.bRequestType = 0x40;\r\npDevice->sUsbCtlRequest.bRequest = byRequest;\r\npDevice->sUsbCtlRequest.wValue = cpu_to_le16p(&wValue);\r\npDevice->sUsbCtlRequest.wIndex = cpu_to_le16p(&wIndex);\r\npDevice->sUsbCtlRequest.wLength = cpu_to_le16p(&wLength);\r\npDevice->pControlURB->transfer_flags |= URB_ASYNC_UNLINK;\r\npDevice->pControlURB->actual_length = 0;\r\nusb_fill_control_urb(pDevice->pControlURB, pDevice->usb,\r\nusb_sndctrlpipe(pDevice->usb , 0), (char *) &pDevice->sUsbCtlRequest,\r\npbyBuffer, wLength, s_nsControlInUsbIoCompleteWrite, pDevice);\r\nntStatus = usb_submit_urb(pDevice->pControlURB, GFP_ATOMIC);\r\nif (ntStatus != 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"control send request submission failed: %d\n", ntStatus);\r\nreturn STATUS_FAILURE;\r\n}\r\nelse {\r\nMP_SET_FLAG(pDevice, fMP_CONTROL_WRITES);\r\n}\r\nspin_unlock_irq(&pDevice->lock);\r\nfor (ii = 0; ii <= USB_CTL_WAIT; ii ++) {\r\nif (pDevice->Flags & fMP_CONTROL_WRITES)\r\nmdelay(1);\r\nelse\r\nbreak;\r\nif (ii >= USB_CTL_WAIT) {\r\nDBG_PRT(MSG_LEVEL_DEBUG,\r\nKERN_INFO "control send request submission timeout\n");\r\nspin_lock_irq(&pDevice->lock);\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\nspin_lock_irq(&pDevice->lock);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint PIPEnsControlIn(\r\nPSDevice pDevice,\r\nBYTE byRequest,\r\nWORD wValue,\r\nWORD wIndex,\r\nWORD wLength,\r\nPBYTE pbyBuffer\r\n)\r\n{\r\nint ntStatus = 0;\r\nint ii;\r\nif (pDevice->Flags & fMP_DISCONNECTED)\r\nreturn STATUS_FAILURE;\r\nif (pDevice->Flags & fMP_CONTROL_READS)\r\nreturn STATUS_FAILURE;\r\npDevice->sUsbCtlRequest.bRequestType = 0xC0;\r\npDevice->sUsbCtlRequest.bRequest = byRequest;\r\npDevice->sUsbCtlRequest.wValue = cpu_to_le16p(&wValue);\r\npDevice->sUsbCtlRequest.wIndex = cpu_to_le16p(&wIndex);\r\npDevice->sUsbCtlRequest.wLength = cpu_to_le16p(&wLength);\r\npDevice->pControlURB->transfer_flags |= URB_ASYNC_UNLINK;\r\npDevice->pControlURB->actual_length = 0;\r\nusb_fill_control_urb(pDevice->pControlURB, pDevice->usb,\r\nusb_rcvctrlpipe(pDevice->usb , 0), (char *) &pDevice->sUsbCtlRequest,\r\npbyBuffer, wLength, s_nsControlInUsbIoCompleteRead, pDevice);\r\nntStatus = usb_submit_urb(pDevice->pControlURB, GFP_ATOMIC);\r\nif (ntStatus != 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"control request submission failed: %d\n", ntStatus);\r\n}else {\r\nMP_SET_FLAG(pDevice, fMP_CONTROL_READS);\r\n}\r\nspin_unlock_irq(&pDevice->lock);\r\nfor (ii = 0; ii <= USB_CTL_WAIT; ii ++) {\r\nif (pDevice->Flags & fMP_CONTROL_READS)\r\nmdelay(1);\r\nelse\r\nbreak;\r\nif (ii >= USB_CTL_WAIT) {\r\nDBG_PRT(MSG_LEVEL_DEBUG,\r\nKERN_INFO "control rcv request submission timeout\n");\r\nspin_lock_irq(&pDevice->lock);\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\nspin_lock_irq(&pDevice->lock);\r\nreturn ntStatus;\r\n}\r\nstatic\r\nvoid\r\ns_nsControlInUsbIoCompleteWrite(\r\nstruct urb *urb\r\n)\r\n{\r\nPSDevice pDevice;\r\npDevice = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -EINPROGRESS:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ctrl write urb status EINPROGRESS%d\n", urb->status);\r\nbreak;\r\ncase -ENOENT:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ctrl write urb status ENOENT %d\n", urb->status);\r\nbreak;\r\ndefault:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ctrl write urb status %d\n", urb->status);\r\n}\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);\r\n}\r\nstatic\r\nvoid\r\ns_nsControlInUsbIoCompleteRead(\r\nstruct urb *urb\r\n)\r\n{\r\nPSDevice pDevice;\r\npDevice = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -EINPROGRESS:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ctrl read urb status EINPROGRESS%d\n", urb->status);\r\nbreak;\r\ncase -ENOENT:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ctrl read urb status = ENOENT %d\n", urb->status);\r\nbreak;\r\ndefault:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ctrl read urb status %d\n", urb->status);\r\n}\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);\r\n}\r\nint PIPEnsInterruptRead(PSDevice pDevice)\r\n{\r\nint ntStatus = STATUS_FAILURE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->s_nsStartInterruptUsbRead()\n");\r\nif(pDevice->intBuf.bInUse == TRUE){\r\nreturn (STATUS_FAILURE);\r\n}\r\npDevice->intBuf.bInUse = TRUE;\r\npDevice->ulIntInPosted++;\r\npDevice->pInterruptURB->interval = pDevice->int_interval;\r\nusb_fill_bulk_urb(pDevice->pInterruptURB,\r\npDevice->usb,\r\nusb_rcvbulkpipe(pDevice->usb, 1),\r\n(void *) pDevice->intBuf.pDataBuf,\r\nMAX_INTERRUPT_SIZE,\r\ns_nsInterruptUsbIoCompleteRead,\r\npDevice);\r\nntStatus = usb_submit_urb(pDevice->pInterruptURB, GFP_ATOMIC);\r\nif (ntStatus != 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Submit int URB failed %d\n", ntStatus);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"<----s_nsStartInterruptUsbRead Return(%x)\n",ntStatus);\r\nreturn ntStatus;\r\n}\r\nstatic\r\nvoid\r\ns_nsInterruptUsbIoCompleteRead(\r\nstruct urb *urb\r\n)\r\n{\r\nPSDevice pDevice;\r\nint ntStatus;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->s_nsInterruptUsbIoCompleteRead\n");\r\npDevice = (PSDevice)urb->context;\r\nntStatus = urb->status;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"s_nsInterruptUsbIoCompleteRead Status %d\n", ntStatus);\r\nif (( ntStatus != STATUS_SUCCESS )) {\r\npDevice->ulBulkInError++;\r\npDevice->intBuf.bInUse = FALSE;\r\npDevice->fKillEventPollingThread = TRUE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"IntUSBIoCompleteControl STATUS = %d\n", ntStatus );\r\n} else {\r\npDevice->ulIntInBytesRead += (unsigned long) urb->actual_length;\r\npDevice->ulIntInContCRCError = 0;\r\npDevice->bEventAvailable = TRUE;\r\nINTnsProcessData(pDevice);\r\n}\r\nSTAvUpdateUSBCounter(&pDevice->scStatistic.USB_InterruptStat, ntStatus);\r\nif (pDevice->fKillEventPollingThread != TRUE) {\r\nusb_fill_bulk_urb(pDevice->pInterruptURB,\r\npDevice->usb,\r\nusb_rcvbulkpipe(pDevice->usb, 1),\r\n(void *) pDevice->intBuf.pDataBuf,\r\nMAX_INTERRUPT_SIZE,\r\ns_nsInterruptUsbIoCompleteRead,\r\npDevice);\r\nntStatus = usb_submit_urb(pDevice->pInterruptURB, GFP_ATOMIC);\r\nif (ntStatus != 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Submit int URB failed %d\n", ntStatus);\r\n}\r\n}\r\nreturn ;\r\n}\r\nint PIPEnsBulkInUsbRead(PSDevice pDevice, PRCB pRCB)\r\n{\r\nint ntStatus = 0;\r\nstruct urb *pUrb;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->s_nsStartBulkInUsbRead\n");\r\nif (pDevice->Flags & fMP_DISCONNECTED)\r\nreturn STATUS_FAILURE;\r\npDevice->ulBulkInPosted++;\r\npUrb = pRCB->pUrb;\r\nif (pRCB->skb == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pRCB->skb is null \n");\r\nreturn ntStatus;\r\n}\r\nusb_fill_bulk_urb(pUrb,\r\npDevice->usb,\r\nusb_rcvbulkpipe(pDevice->usb, 2),\r\n(void *) (pRCB->skb->data),\r\nMAX_TOTAL_SIZE_WITH_ALL_HEADERS,\r\ns_nsBulkInUsbIoCompleteRead,\r\npRCB);\r\nntStatus = usb_submit_urb(pUrb, GFP_ATOMIC);\r\nif (ntStatus != 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Submit Rx URB failed %d\n", ntStatus);\r\nreturn STATUS_FAILURE ;\r\n}\r\npRCB->Ref = 1;\r\npRCB->bBoolInUse= TRUE;\r\nreturn ntStatus;\r\n}\r\nstatic\r\nvoid\r\ns_nsBulkInUsbIoCompleteRead(\r\nstruct urb *urb\r\n)\r\n{\r\nPRCB pRCB = (PRCB)urb->context;\r\nPSDevice pDevice = (PSDevice)pRCB->pDevice;\r\nunsigned long bytesRead;\r\nBOOL bIndicateReceive = FALSE;\r\nBOOL bReAllocSkb = FALSE;\r\nint status;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->s_nsBulkInUsbIoCompleteRead\n");\r\nstatus = urb->status;\r\nbytesRead = urb->actual_length;\r\nif (status) {\r\npDevice->ulBulkInError++;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"BULK In failed %d\n", status);\r\npDevice->scStatistic.RxFcsErrCnt ++;\r\n} else {\r\nbIndicateReceive = TRUE;\r\npDevice->ulBulkInContCRCError = 0;\r\npDevice->ulBulkInBytesRead += bytesRead;\r\npDevice->scStatistic.RxOkCnt ++;\r\n}\r\nSTAvUpdateUSBCounter(&pDevice->scStatistic.USB_BulkInStat, status);\r\nif (bIndicateReceive) {\r\nspin_lock(&pDevice->lock);\r\nif (RXbBulkInProcessData(pDevice, pRCB, bytesRead) == TRUE)\r\nbReAllocSkb = TRUE;\r\nspin_unlock(&pDevice->lock);\r\n}\r\npRCB->Ref--;\r\nif (pRCB->Ref == 0)\r\n{\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RxvFreeNormal %d \n",pDevice->NumRecvFreeList);\r\nspin_lock(&pDevice->lock);\r\nRXvFreeRCB(pRCB, bReAllocSkb);\r\nspin_unlock(&pDevice->lock);\r\n}\r\nreturn;\r\n}\r\nint\r\nPIPEnsSendBulkOut(\r\nPSDevice pDevice,\r\nPUSB_SEND_CONTEXT pContext\r\n)\r\n{\r\nint status;\r\nstruct urb *pUrb;\r\npDevice->bPWBitOn = FALSE;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"s_nsSendBulkOut\n");\r\nif (MP_IS_READY(pDevice) && (pDevice->Flags & fMP_POST_WRITES)) {\r\npUrb = pContext->pUrb;\r\npDevice->ulBulkOutPosted++;\r\nusb_fill_bulk_urb(\r\npUrb,\r\npDevice->usb,\r\nusb_sndbulkpipe(pDevice->usb, 3),\r\n(void *) &(pContext->Data[0]),\r\npContext->uBufLen,\r\ns_nsBulkOutIoCompleteWrite,\r\npContext);\r\nstatus = usb_submit_urb(pUrb, GFP_ATOMIC);\r\nif (status != 0)\r\n{\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Submit Tx URB failed %d\n", status);\r\nreturn STATUS_FAILURE;\r\n}\r\nreturn STATUS_PENDING;\r\n}\r\nelse {\r\npContext->bBoolInUse = FALSE;\r\nreturn STATUS_RESOURCES;\r\n}\r\n}\r\nstatic\r\nvoid\r\ns_nsBulkOutIoCompleteWrite(\r\nstruct urb *urb\r\n)\r\n{\r\nPSDevice pDevice;\r\nint status;\r\nCONTEXT_TYPE ContextType;\r\nunsigned long ulBufLen;\r\nPUSB_SEND_CONTEXT pContext;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->s_nsBulkOutIoCompleteWrite\n");\r\npContext = (PUSB_SEND_CONTEXT) urb->context;\r\nASSERT( NULL != pContext );\r\npDevice = pContext->pDevice;\r\nContextType = pContext->Type;\r\nulBufLen = pContext->uBufLen;\r\nif (!netif_device_present(pDevice->dev))\r\nreturn;\r\nstatus = urb->status;\r\nSTAvUpdateUSBCounter(&pDevice->scStatistic.USB_BulkOutStat, status);\r\nif(status == STATUS_SUCCESS) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Write %d bytes\n",(int)ulBufLen);\r\npDevice->ulBulkOutBytesWrite += ulBufLen;\r\npDevice->ulBulkOutContCRCError = 0;\r\npDevice->nTxDataTimeCout = 0;\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"BULK Out failed %d\n", status);\r\npDevice->ulBulkOutError++;\r\n}\r\nif ( CONTEXT_DATA_PACKET == ContextType ) {\r\nif (pContext->pPacket != NULL) {\r\ndev_kfree_skb_irq(pContext->pPacket);\r\npContext->pPacket = NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"tx %d bytes\n",(int)ulBufLen);\r\n}\r\npDevice->dev->trans_start = jiffies;\r\nif (status == STATUS_SUCCESS) {\r\npDevice->packetsSent++;\r\n}\r\nelse {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Send USB error! [%08xh]\n", status);\r\npDevice->packetsSentDropped++;\r\n}\r\n}\r\nif (pDevice->bLinkPass == TRUE) {\r\nif (netif_queue_stopped(pDevice->dev))\r\nnetif_wake_queue(pDevice->dev);\r\n}\r\npContext->bBoolInUse = FALSE;\r\nreturn;\r\n}
