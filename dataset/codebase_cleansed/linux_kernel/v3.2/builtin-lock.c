static struct thread_stat *thread_stat_find(u32 tid)\r\n{\r\nstruct rb_node *node;\r\nstruct thread_stat *st;\r\nnode = thread_stats.rb_node;\r\nwhile (node) {\r\nst = container_of(node, struct thread_stat, rb);\r\nif (st->tid == tid)\r\nreturn st;\r\nelse if (tid < st->tid)\r\nnode = node->rb_left;\r\nelse\r\nnode = node->rb_right;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void thread_stat_insert(struct thread_stat *new)\r\n{\r\nstruct rb_node **rb = &thread_stats.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct thread_stat *p;\r\nwhile (*rb) {\r\np = container_of(*rb, struct thread_stat, rb);\r\nparent = *rb;\r\nif (new->tid < p->tid)\r\nrb = &(*rb)->rb_left;\r\nelse if (new->tid > p->tid)\r\nrb = &(*rb)->rb_right;\r\nelse\r\nBUG_ON("inserting invalid thread_stat\n");\r\n}\r\nrb_link_node(&new->rb, parent, rb);\r\nrb_insert_color(&new->rb, &thread_stats);\r\n}\r\nstatic struct thread_stat *thread_stat_findnew_after_first(u32 tid)\r\n{\r\nstruct thread_stat *st;\r\nst = thread_stat_find(tid);\r\nif (st)\r\nreturn st;\r\nst = zalloc(sizeof(struct thread_stat));\r\nif (!st)\r\ndie("memory allocation failed\n");\r\nst->tid = tid;\r\nINIT_LIST_HEAD(&st->seq_list);\r\nthread_stat_insert(st);\r\nreturn st;\r\n}\r\nstatic struct thread_stat *thread_stat_findnew_first(u32 tid)\r\n{\r\nstruct thread_stat *st;\r\nst = zalloc(sizeof(struct thread_stat));\r\nif (!st)\r\ndie("memory allocation failed\n");\r\nst->tid = tid;\r\nINIT_LIST_HEAD(&st->seq_list);\r\nrb_link_node(&st->rb, NULL, &thread_stats.rb_node);\r\nrb_insert_color(&st->rb, &thread_stats);\r\nthread_stat_findnew = thread_stat_findnew_after_first;\r\nreturn st;\r\n}\r\nstatic int lock_stat_key_wait_time_min(struct lock_stat *one,\r\nstruct lock_stat *two)\r\n{\r\nu64 s1 = one->wait_time_min;\r\nu64 s2 = two->wait_time_min;\r\nif (s1 == ULLONG_MAX)\r\ns1 = 0;\r\nif (s2 == ULLONG_MAX)\r\ns2 = 0;\r\nreturn s1 > s2;\r\n}\r\nstatic void select_key(void)\r\n{\r\nint i;\r\nfor (i = 0; keys[i].name; i++) {\r\nif (!strcmp(keys[i].name, sort_key)) {\r\ncompare = keys[i].key;\r\nreturn;\r\n}\r\n}\r\ndie("Unknown compare key:%s\n", sort_key);\r\n}\r\nstatic void insert_to_result(struct lock_stat *st,\r\nint (*bigger)(struct lock_stat *, struct lock_stat *))\r\n{\r\nstruct rb_node **rb = &result.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct lock_stat *p;\r\nwhile (*rb) {\r\np = container_of(*rb, struct lock_stat, rb);\r\nparent = *rb;\r\nif (bigger(st, p))\r\nrb = &(*rb)->rb_left;\r\nelse\r\nrb = &(*rb)->rb_right;\r\n}\r\nrb_link_node(&st->rb, parent, rb);\r\nrb_insert_color(&st->rb, &result);\r\n}\r\nstatic struct lock_stat *pop_from_result(void)\r\n{\r\nstruct rb_node *node = result.rb_node;\r\nif (!node)\r\nreturn NULL;\r\nwhile (node->rb_left)\r\nnode = node->rb_left;\r\nrb_erase(node, &result);\r\nreturn container_of(node, struct lock_stat, rb);\r\n}\r\nstatic struct lock_stat *lock_stat_findnew(void *addr, const char *name)\r\n{\r\nstruct list_head *entry = lockhashentry(addr);\r\nstruct lock_stat *ret, *new;\r\nlist_for_each_entry(ret, entry, hash_entry) {\r\nif (ret->addr == addr)\r\nreturn ret;\r\n}\r\nnew = zalloc(sizeof(struct lock_stat));\r\nif (!new)\r\ngoto alloc_failed;\r\nnew->addr = addr;\r\nnew->name = zalloc(sizeof(char) * strlen(name) + 1);\r\nif (!new->name)\r\ngoto alloc_failed;\r\nstrcpy(new->name, name);\r\nnew->wait_time_min = ULLONG_MAX;\r\nlist_add(&new->hash_entry, entry);\r\nreturn new;\r\nalloc_failed:\r\ndie("memory allocation failed\n");\r\n}\r\nstatic struct lock_seq_stat *get_seq(struct thread_stat *ts, void *addr)\r\n{\r\nstruct lock_seq_stat *seq;\r\nlist_for_each_entry(seq, &ts->seq_list, list) {\r\nif (seq->addr == addr)\r\nreturn seq;\r\n}\r\nseq = zalloc(sizeof(struct lock_seq_stat));\r\nif (!seq)\r\ndie("Not enough memory\n");\r\nseq->state = SEQ_STATE_UNINITIALIZED;\r\nseq->addr = addr;\r\nlist_add(&seq->list, &ts->seq_list);\r\nreturn seq;\r\n}\r\nstatic void\r\nreport_lock_acquire_event(struct trace_acquire_event *acquire_event,\r\nstruct event *__event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nls = lock_stat_findnew(acquire_event->addr, acquire_event->name);\r\nif (ls->discard)\r\nreturn;\r\nts = thread_stat_findnew(thread->pid);\r\nseq = get_seq(ts, acquire_event->addr);\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\ncase SEQ_STATE_RELEASED:\r\nif (!acquire_event->flag) {\r\nseq->state = SEQ_STATE_ACQUIRING;\r\n} else {\r\nif (acquire_event->flag & TRY_LOCK)\r\nls->nr_trylock++;\r\nif (acquire_event->flag & READ_LOCK)\r\nls->nr_readlock++;\r\nseq->state = SEQ_STATE_READ_ACQUIRED;\r\nseq->read_count = 1;\r\nls->nr_acquired++;\r\n}\r\nbreak;\r\ncase SEQ_STATE_READ_ACQUIRED:\r\nif (acquire_event->flag & READ_LOCK) {\r\nseq->read_count++;\r\nls->nr_acquired++;\r\ngoto end;\r\n} else {\r\ngoto broken;\r\n}\r\nbreak;\r\ncase SEQ_STATE_ACQUIRED:\r\ncase SEQ_STATE_ACQUIRING:\r\ncase SEQ_STATE_CONTENDED:\r\nbroken:\r\nls->discard = 1;\r\nbad_hist[BROKEN_ACQUIRE]++;\r\nlist_del(&seq->list);\r\nfree(seq);\r\ngoto end;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nls->nr_acquire++;\r\nseq->prev_event_time = timestamp;\r\nend:\r\nreturn;\r\n}\r\nstatic void\r\nreport_lock_acquired_event(struct trace_acquired_event *acquired_event,\r\nstruct event *__event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nu64 contended_term;\r\nls = lock_stat_findnew(acquired_event->addr, acquired_event->name);\r\nif (ls->discard)\r\nreturn;\r\nts = thread_stat_findnew(thread->pid);\r\nseq = get_seq(ts, acquired_event->addr);\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\nreturn;\r\ncase SEQ_STATE_ACQUIRING:\r\nbreak;\r\ncase SEQ_STATE_CONTENDED:\r\ncontended_term = timestamp - seq->prev_event_time;\r\nls->wait_time_total += contended_term;\r\nif (contended_term < ls->wait_time_min)\r\nls->wait_time_min = contended_term;\r\nif (ls->wait_time_max < contended_term)\r\nls->wait_time_max = contended_term;\r\nbreak;\r\ncase SEQ_STATE_RELEASED:\r\ncase SEQ_STATE_ACQUIRED:\r\ncase SEQ_STATE_READ_ACQUIRED:\r\nls->discard = 1;\r\nbad_hist[BROKEN_ACQUIRED]++;\r\nlist_del(&seq->list);\r\nfree(seq);\r\ngoto end;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nseq->state = SEQ_STATE_ACQUIRED;\r\nls->nr_acquired++;\r\nseq->prev_event_time = timestamp;\r\nend:\r\nreturn;\r\n}\r\nstatic void\r\nreport_lock_contended_event(struct trace_contended_event *contended_event,\r\nstruct event *__event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nls = lock_stat_findnew(contended_event->addr, contended_event->name);\r\nif (ls->discard)\r\nreturn;\r\nts = thread_stat_findnew(thread->pid);\r\nseq = get_seq(ts, contended_event->addr);\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\nreturn;\r\ncase SEQ_STATE_ACQUIRING:\r\nbreak;\r\ncase SEQ_STATE_RELEASED:\r\ncase SEQ_STATE_ACQUIRED:\r\ncase SEQ_STATE_READ_ACQUIRED:\r\ncase SEQ_STATE_CONTENDED:\r\nls->discard = 1;\r\nbad_hist[BROKEN_CONTENDED]++;\r\nlist_del(&seq->list);\r\nfree(seq);\r\ngoto end;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nseq->state = SEQ_STATE_CONTENDED;\r\nls->nr_contended++;\r\nseq->prev_event_time = timestamp;\r\nend:\r\nreturn;\r\n}\r\nstatic void\r\nreport_lock_release_event(struct trace_release_event *release_event,\r\nstruct event *__event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nls = lock_stat_findnew(release_event->addr, release_event->name);\r\nif (ls->discard)\r\nreturn;\r\nts = thread_stat_findnew(thread->pid);\r\nseq = get_seq(ts, release_event->addr);\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\ngoto end;\r\nbreak;\r\ncase SEQ_STATE_ACQUIRED:\r\nbreak;\r\ncase SEQ_STATE_READ_ACQUIRED:\r\nseq->read_count--;\r\nBUG_ON(seq->read_count < 0);\r\nif (!seq->read_count) {\r\nls->nr_release++;\r\ngoto end;\r\n}\r\nbreak;\r\ncase SEQ_STATE_ACQUIRING:\r\ncase SEQ_STATE_CONTENDED:\r\ncase SEQ_STATE_RELEASED:\r\nls->discard = 1;\r\nbad_hist[BROKEN_RELEASE]++;\r\ngoto free_seq;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nls->nr_release++;\r\nfree_seq:\r\nlist_del(&seq->list);\r\nfree(seq);\r\nend:\r\nreturn;\r\n}\r\nstatic void\r\nprocess_lock_acquire_event(void *data,\r\nstruct event *event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct trace_acquire_event acquire_event;\r\nu64 tmp;\r\ntmp = raw_field_value(event, "lockdep_addr", data);\r\nmemcpy(&acquire_event.addr, &tmp, sizeof(void *));\r\nacquire_event.name = (char *)raw_field_ptr(event, "name", data);\r\nacquire_event.flag = (int)raw_field_value(event, "flag", data);\r\nif (trace_handler->acquire_event)\r\ntrace_handler->acquire_event(&acquire_event, event, cpu, timestamp, thread);\r\n}\r\nstatic void\r\nprocess_lock_acquired_event(void *data,\r\nstruct event *event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct trace_acquired_event acquired_event;\r\nu64 tmp;\r\ntmp = raw_field_value(event, "lockdep_addr", data);\r\nmemcpy(&acquired_event.addr, &tmp, sizeof(void *));\r\nacquired_event.name = (char *)raw_field_ptr(event, "name", data);\r\nif (trace_handler->acquire_event)\r\ntrace_handler->acquired_event(&acquired_event, event, cpu, timestamp, thread);\r\n}\r\nstatic void\r\nprocess_lock_contended_event(void *data,\r\nstruct event *event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct trace_contended_event contended_event;\r\nu64 tmp;\r\ntmp = raw_field_value(event, "lockdep_addr", data);\r\nmemcpy(&contended_event.addr, &tmp, sizeof(void *));\r\ncontended_event.name = (char *)raw_field_ptr(event, "name", data);\r\nif (trace_handler->acquire_event)\r\ntrace_handler->contended_event(&contended_event, event, cpu, timestamp, thread);\r\n}\r\nstatic void\r\nprocess_lock_release_event(void *data,\r\nstruct event *event __used,\r\nint cpu __used,\r\nu64 timestamp __used,\r\nstruct thread *thread __used)\r\n{\r\nstruct trace_release_event release_event;\r\nu64 tmp;\r\ntmp = raw_field_value(event, "lockdep_addr", data);\r\nmemcpy(&release_event.addr, &tmp, sizeof(void *));\r\nrelease_event.name = (char *)raw_field_ptr(event, "name", data);\r\nif (trace_handler->acquire_event)\r\ntrace_handler->release_event(&release_event, event, cpu, timestamp, thread);\r\n}\r\nstatic void\r\nprocess_raw_event(void *data, int cpu, u64 timestamp, struct thread *thread)\r\n{\r\nstruct event *event;\r\nint type;\r\ntype = trace_parse_common_type(data);\r\nevent = trace_find_event(type);\r\nif (!strcmp(event->name, "lock_acquire"))\r\nprocess_lock_acquire_event(data, event, cpu, timestamp, thread);\r\nif (!strcmp(event->name, "lock_acquired"))\r\nprocess_lock_acquired_event(data, event, cpu, timestamp, thread);\r\nif (!strcmp(event->name, "lock_contended"))\r\nprocess_lock_contended_event(data, event, cpu, timestamp, thread);\r\nif (!strcmp(event->name, "lock_release"))\r\nprocess_lock_release_event(data, event, cpu, timestamp, thread);\r\n}\r\nstatic void print_bad_events(int bad, int total)\r\n{\r\nint i;\r\nconst char *name[4] =\r\n{ "acquire", "acquired", "contended", "release" };\r\npr_info("\n=== output for debug===\n\n");\r\npr_info("bad: %d, total: %d\n", bad, total);\r\npr_info("bad rate: %f %%\n", (double)bad / (double)total * 100);\r\npr_info("histogram of events caused bad sequence\n");\r\nfor (i = 0; i < BROKEN_MAX; i++)\r\npr_info(" %10s: %d\n", name[i], bad_hist[i]);\r\n}\r\nstatic void print_result(void)\r\n{\r\nstruct lock_stat *st;\r\nchar cut_name[20];\r\nint bad, total;\r\npr_info("%20s ", "Name");\r\npr_info("%10s ", "acquired");\r\npr_info("%10s ", "contended");\r\npr_info("%15s ", "total wait (ns)");\r\npr_info("%15s ", "max wait (ns)");\r\npr_info("%15s ", "min wait (ns)");\r\npr_info("\n\n");\r\nbad = total = 0;\r\nwhile ((st = pop_from_result())) {\r\ntotal++;\r\nif (st->discard) {\r\nbad++;\r\ncontinue;\r\n}\r\nbzero(cut_name, 20);\r\nif (strlen(st->name) < 16) {\r\npr_info("%20s ", st->name);\r\n} else {\r\nstrncpy(cut_name, st->name, 16);\r\ncut_name[16] = '.';\r\ncut_name[17] = '.';\r\ncut_name[18] = '.';\r\ncut_name[19] = '\0';\r\npr_info("%20s ", cut_name);\r\n}\r\npr_info("%10u ", st->nr_acquired);\r\npr_info("%10u ", st->nr_contended);\r\npr_info("%15" PRIu64 " ", st->wait_time_total);\r\npr_info("%15" PRIu64 " ", st->wait_time_max);\r\npr_info("%15" PRIu64 " ", st->wait_time_min == ULLONG_MAX ?\r\n0 : st->wait_time_min);\r\npr_info("\n");\r\n}\r\nprint_bad_events(bad, total);\r\n}\r\nstatic void dump_threads(void)\r\n{\r\nstruct thread_stat *st;\r\nstruct rb_node *node;\r\nstruct thread *t;\r\npr_info("%10s: comm\n", "Thread ID");\r\nnode = rb_first(&thread_stats);\r\nwhile (node) {\r\nst = container_of(node, struct thread_stat, rb);\r\nt = perf_session__findnew(session, st->tid);\r\npr_info("%10d: %s\n", st->tid, t->comm);\r\nnode = rb_next(node);\r\n};\r\n}\r\nstatic void dump_map(void)\r\n{\r\nunsigned int i;\r\nstruct lock_stat *st;\r\npr_info("Address of instance: name of class\n");\r\nfor (i = 0; i < LOCKHASH_SIZE; i++) {\r\nlist_for_each_entry(st, &lockhash_table[i], hash_entry) {\r\npr_info(" %p: %s\n", st->addr, st->name);\r\n}\r\n}\r\n}\r\nstatic void dump_info(void)\r\n{\r\nif (info_threads)\r\ndump_threads();\r\nelse if (info_map)\r\ndump_map();\r\nelse\r\ndie("Unknown type of information\n");\r\n}\r\nstatic int process_sample_event(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __used,\r\nstruct perf_session *s)\r\n{\r\nstruct thread *thread = perf_session__findnew(s, sample->tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nprocess_raw_event(sample->raw_data, sample->cpu, sample->time, thread);\r\nreturn 0;\r\n}\r\nstatic int read_events(void)\r\n{\r\nsession = perf_session__new(input_name, O_RDONLY, 0, false, &eops);\r\nif (!session)\r\ndie("Initializing perf session failed\n");\r\nreturn perf_session__process_events(session, &eops);\r\n}\r\nstatic void sort_result(void)\r\n{\r\nunsigned int i;\r\nstruct lock_stat *st;\r\nfor (i = 0; i < LOCKHASH_SIZE; i++) {\r\nlist_for_each_entry(st, &lockhash_table[i], hash_entry) {\r\ninsert_to_result(st, compare);\r\n}\r\n}\r\n}\r\nstatic void __cmd_report(void)\r\n{\r\nsetup_pager();\r\nselect_key();\r\nread_events();\r\nsort_result();\r\nprint_result();\r\n}\r\nstatic int __cmd_record(int argc, const char **argv)\r\n{\r\nunsigned int rec_argc, i, j;\r\nconst char **rec_argv;\r\nrec_argc = ARRAY_SIZE(record_args) + argc - 1;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (rec_argv == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(record_args); i++)\r\nrec_argv[i] = strdup(record_args[i]);\r\nfor (j = 1; j < (unsigned int)argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nBUG_ON(i != rec_argc);\r\nreturn cmd_record(i, rec_argv, NULL);\r\n}\r\nint cmd_lock(int argc, const char **argv, const char *prefix __used)\r\n{\r\nunsigned int i;\r\nsymbol__init();\r\nfor (i = 0; i < LOCKHASH_SIZE; i++)\r\nINIT_LIST_HEAD(lockhash_table + i);\r\nargc = parse_options(argc, argv, lock_options, lock_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (!argc)\r\nusage_with_options(lock_usage, lock_options);\r\nif (!strncmp(argv[0], "rec", 3)) {\r\nreturn __cmd_record(argc, argv);\r\n} else if (!strncmp(argv[0], "report", 6)) {\r\ntrace_handler = &report_lock_ops;\r\nif (argc) {\r\nargc = parse_options(argc, argv,\r\nreport_options, report_usage, 0);\r\nif (argc)\r\nusage_with_options(report_usage, report_options);\r\n}\r\n__cmd_report();\r\n} else if (!strcmp(argv[0], "script")) {\r\nreturn cmd_script(argc, argv, prefix);\r\n} else if (!strcmp(argv[0], "info")) {\r\nif (argc) {\r\nargc = parse_options(argc, argv,\r\ninfo_options, info_usage, 0);\r\nif (argc)\r\nusage_with_options(info_usage, info_options);\r\n}\r\ntrace_handler = &report_lock_ops;\r\nsetup_pager();\r\nread_events();\r\ndump_info();\r\n} else {\r\nusage_with_options(lock_usage, lock_options);\r\n}\r\nreturn 0;\r\n}
