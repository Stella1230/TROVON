static int tuner_attach_stv6110(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct stv090x_config *feconf = (struct stv090x_config *)\r\nchan->dev->card_info->fe_config[chan->number];\r\nstruct stv6110x_config *tunerconf = (struct stv6110x_config *)\r\nchan->dev->card_info->tuner_config[chan->number];\r\nstruct stv6110x_devctl *ctl;\r\nif (chan->number < 2)\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nelse\r\ni2c = &chan->dev->channel[1].i2c_adapter;\r\nctl = dvb_attach(stv6110x_attach, chan->fe, tunerconf, i2c);\r\nif (ctl == NULL) {\r\nprintk(KERN_ERR DEVICE_NAME ": No STV6110X found!\n");\r\nreturn -ENODEV;\r\n}\r\nfeconf->tuner_init = ctl->tuner_init;\r\nfeconf->tuner_sleep = ctl->tuner_sleep;\r\nfeconf->tuner_set_mode = ctl->tuner_set_mode;\r\nfeconf->tuner_set_frequency = ctl->tuner_set_frequency;\r\nfeconf->tuner_get_frequency = ctl->tuner_get_frequency;\r\nfeconf->tuner_set_bandwidth = ctl->tuner_set_bandwidth;\r\nfeconf->tuner_get_bandwidth = ctl->tuner_get_bandwidth;\r\nfeconf->tuner_set_bbgain = ctl->tuner_set_bbgain;\r\nfeconf->tuner_get_bbgain = ctl->tuner_get_bbgain;\r\nfeconf->tuner_set_refclk = ctl->tuner_set_refclk;\r\nfeconf->tuner_get_status = ctl->tuner_get_status;\r\nreturn 0;\r\n}\r\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct ngene_channel *chan = fe->sec_priv;\r\nint status;\r\nif (enable) {\r\ndown(&chan->dev->pll_mutex);\r\nstatus = chan->gate_ctrl(fe, 1);\r\n} else {\r\nstatus = chan->gate_ctrl(fe, 0);\r\nup(&chan->dev->pll_mutex);\r\n}\r\nreturn status;\r\n}\r\nstatic int tuner_attach_tda18271(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct dvb_frontend *fe;\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nif (chan->fe->ops.i2c_gate_ctrl)\r\nchan->fe->ops.i2c_gate_ctrl(chan->fe, 1);\r\nfe = dvb_attach(tda18271c2dd_attach, chan->fe, i2c, 0x60);\r\nif (chan->fe->ops.i2c_gate_ctrl)\r\nchan->fe->ops.i2c_gate_ctrl(chan->fe, 0);\r\nif (!fe) {\r\nprintk(KERN_ERR "No TDA18271 found!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tuner_attach_probe(struct ngene_channel *chan)\r\n{\r\nif (chan->demod_type == 0)\r\nreturn tuner_attach_stv6110(chan);\r\nif (chan->demod_type == 1)\r\nreturn tuner_attach_tda18271(chan);\r\nreturn -EINVAL;\r\n}\r\nstatic int demod_attach_stv0900(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct stv090x_config *feconf = (struct stv090x_config *)\r\nchan->dev->card_info->fe_config[chan->number];\r\nif (chan->number < 2)\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nelse\r\ni2c = &chan->dev->channel[1].i2c_adapter;\r\nchan->fe = dvb_attach(stv090x_attach, feconf, i2c,\r\n(chan->number & 1) == 0 ? STV090x_DEMODULATOR_0\r\n: STV090x_DEMODULATOR_1);\r\nif (chan->fe == NULL) {\r\nprintk(KERN_ERR DEVICE_NAME ": No STV0900 found!\n");\r\nreturn -ENODEV;\r\n}\r\nif (feconf->tuner_i2c_lock)\r\nchan->fe->analog_demod_priv = chan;\r\nif (!dvb_attach(lnbh24_attach, chan->fe, i2c, 0,\r\n0, chan->dev->card_info->lnb[chan->number])) {\r\nprintk(KERN_ERR DEVICE_NAME ": No LNBH24 found!\n");\r\ndvb_frontend_detach(chan->fe);\r\nchan->fe = NULL;\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cineS2_tuner_i2c_lock(struct dvb_frontend *fe, int lock)\r\n{\r\nstruct ngene_channel *chan = fe->analog_demod_priv;\r\nif (lock)\r\ndown(&chan->dev->pll_mutex);\r\nelse\r\nup(&chan->dev->pll_mutex);\r\n}\r\nstatic int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)\r\n{\r\nstruct i2c_msg msgs[1] = {{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1 } };\r\nreturn (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;\r\n}\r\nstatic int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,\r\nu16 reg, u8 *val)\r\n{\r\nu8 msg[2] = {reg>>8, reg&0xff};\r\nstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\r\n.buf = msg, .len = 2},\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1} };\r\nreturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\r\n}\r\nstatic int port_has_stv0900(struct i2c_adapter *i2c, int port)\r\n{\r\nu8 val;\r\nif (i2c_read_reg16(i2c, 0x68+port/2, 0xf100, &val) < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int port_has_drxk(struct i2c_adapter *i2c, int port)\r\n{\r\nu8 val;\r\nif (i2c_read(i2c, 0x29+port, &val) < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int demod_attach_drxk(struct ngene_channel *chan,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct drxk_config config;\r\nmemset(&config, 0, sizeof(config));\r\nconfig.adr = 0x29 + (chan->number ^ 2);\r\nchan->fe = dvb_attach(drxk_attach, &config, i2c, &chan->fe2);\r\nif (!chan->fe) {\r\nprintk(KERN_ERR "No DRXK found!\n");\r\nreturn -ENODEV;\r\n}\r\nchan->fe->sec_priv = chan;\r\nchan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;\r\nchan->fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;\r\nreturn 0;\r\n}\r\nstatic int cineS2_probe(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct stv090x_config *fe_conf;\r\nu8 buf[3];\r\nstruct i2c_msg i2c_msg = { .flags = 0, .buf = buf };\r\nint rc;\r\nif (chan->number < 2)\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nelse\r\ni2c = &chan->dev->channel[1].i2c_adapter;\r\nif (port_has_stv0900(i2c, chan->number)) {\r\nchan->demod_type = 0;\r\nfe_conf = chan->dev->card_info->fe_config[chan->number];\r\nrc = demod_attach_stv0900(chan);\r\nif (rc < 0 || chan->number < 2)\r\nreturn rc;\r\ni2c_msg.addr = fe_conf->address;\r\ni2c_msg.len = 3;\r\nbuf[0] = 0xf1;\r\nswitch (chan->number) {\r\ncase 2:\r\nbuf[1] = 0x5c;\r\nbuf[2] = 0xc2;\r\nbreak;\r\ncase 3:\r\nbuf[1] = 0x61;\r\nbuf[2] = 0xcc;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nrc = i2c_transfer(i2c, &i2c_msg, 1);\r\nif (rc != 1) {\r\nprintk(KERN_ERR DEVICE_NAME ": could not setup DPNx\n");\r\nreturn -EIO;\r\n}\r\n} else if (port_has_drxk(i2c, chan->number^2)) {\r\nchan->demod_type = 1;\r\ndemod_attach_drxk(chan, i2c);\r\n} else {\r\nprintk(KERN_ERR "No demod found on chan %d\n", chan->number);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int demod_attach_lg330x(struct ngene_channel *chan)\r\n{\r\nchan->fe = dvb_attach(lgdt330x_attach, &aver_m780, &chan->i2c_adapter);\r\nif (chan->fe == NULL) {\r\nprintk(KERN_ERR DEVICE_NAME ": No LGDT330x found!\n");\r\nreturn -ENODEV;\r\n}\r\ndvb_attach(mt2131_attach, chan->fe, &chan->i2c_adapter,\r\n&m780_tunerconfig, 0);\r\nreturn (chan->fe) ? 0 : -ENODEV;\r\n}\r\nstatic pci_ers_result_t ngene_error_detected(struct pci_dev *dev,\r\nenum pci_channel_state state)\r\n{\r\nprintk(KERN_ERR DEVICE_NAME ": PCI error\n");\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (state == pci_channel_io_frozen)\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\n}\r\nstatic pci_ers_result_t ngene_link_reset(struct pci_dev *dev)\r\n{\r\nprintk(KERN_INFO DEVICE_NAME ": link reset\n");\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t ngene_slot_reset(struct pci_dev *dev)\r\n{\r\nprintk(KERN_INFO DEVICE_NAME ": slot reset\n");\r\nreturn 0;\r\n}\r\nstatic void ngene_resume(struct pci_dev *dev)\r\n{\r\nprintk(KERN_INFO DEVICE_NAME ": resume\n");\r\n}\r\nstatic __init int module_init_ngene(void)\r\n{\r\nprintk(KERN_INFO\r\n"nGene PCIE bridge driver, Copyright (C) 2005-2007 Micronas\n");\r\nreturn pci_register_driver(&ngene_pci_driver);\r\n}\r\nstatic __exit void module_exit_ngene(void)\r\n{\r\npci_unregister_driver(&ngene_pci_driver);\r\n}
