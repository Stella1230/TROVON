static irqreturn_t omap4_keypad_interrupt(int irq, void *dev_id)\r\n{\r\nstruct omap4_keypad *keypad_data = dev_id;\r\nstruct input_dev *input_dev = keypad_data->input;\r\nunsigned char key_state[ARRAY_SIZE(keypad_data->key_state)];\r\nunsigned int col, row, code, changed;\r\nu32 *new_state = (u32 *) key_state;\r\n__raw_writel(OMAP4_VAL_IRQDISABLE,\r\nkeypad_data->base + OMAP4_KBD_IRQENABLE);\r\n*new_state = __raw_readl(keypad_data->base + OMAP4_KBD_FULLCODE31_0);\r\n*(new_state + 1) = __raw_readl(keypad_data->base\r\n+ OMAP4_KBD_FULLCODE63_32);\r\nfor (row = 0; row < keypad_data->rows; row++) {\r\nchanged = key_state[row] ^ keypad_data->key_state[row];\r\nif (!changed)\r\ncontinue;\r\nfor (col = 0; col < keypad_data->cols; col++) {\r\nif (changed & (1 << col)) {\r\ncode = MATRIX_SCAN_CODE(row, col,\r\nkeypad_data->row_shift);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev,\r\nkeypad_data->keymap[code],\r\nkey_state[row] & (1 << col));\r\n}\r\n}\r\n}\r\ninput_sync(input_dev);\r\nmemcpy(keypad_data->key_state, key_state,\r\nsizeof(keypad_data->key_state));\r\n__raw_writel(__raw_readl(keypad_data->base + OMAP4_KBD_IRQSTATUS),\r\nkeypad_data->base + OMAP4_KBD_IRQSTATUS);\r\n__raw_writel(OMAP4_DEF_IRQENABLE_EVENTEN | OMAP4_DEF_IRQENABLE_LONGKEY,\r\nkeypad_data->base + OMAP4_KBD_IRQENABLE);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap4_keypad_open(struct input_dev *input)\r\n{\r\nstruct omap4_keypad *keypad_data = input_get_drvdata(input);\r\npm_runtime_get_sync(input->dev.parent);\r\ndisable_irq(keypad_data->irq);\r\n__raw_writel(OMAP4_VAL_FUNCTIONALCFG,\r\nkeypad_data->base + OMAP4_KBD_CTRL);\r\n__raw_writel(OMAP4_VAL_DEBOUNCINGTIME,\r\nkeypad_data->base + OMAP4_KBD_DEBOUNCINGTIME);\r\n__raw_writel(OMAP4_VAL_IRQDISABLE,\r\nkeypad_data->base + OMAP4_KBD_IRQSTATUS);\r\n__raw_writel(OMAP4_DEF_IRQENABLE_EVENTEN | OMAP4_DEF_IRQENABLE_LONGKEY,\r\nkeypad_data->base + OMAP4_KBD_IRQENABLE);\r\n__raw_writel(OMAP4_DEF_WUP_EVENT_ENA | OMAP4_DEF_WUP_LONG_KEY_ENA,\r\nkeypad_data->base + OMAP4_KBD_WAKEUPENABLE);\r\nenable_irq(keypad_data->irq);\r\nreturn 0;\r\n}\r\nstatic void omap4_keypad_close(struct input_dev *input)\r\n{\r\nstruct omap4_keypad *keypad_data = input_get_drvdata(input);\r\ndisable_irq(keypad_data->irq);\r\n__raw_writel(OMAP4_VAL_IRQDISABLE,\r\nkeypad_data->base + OMAP4_KBD_IRQENABLE);\r\n__raw_writel(__raw_readl(keypad_data->base + OMAP4_KBD_IRQSTATUS),\r\nkeypad_data->base + OMAP4_KBD_IRQSTATUS);\r\nenable_irq(keypad_data->irq);\r\npm_runtime_put_sync(input->dev.parent);\r\n}\r\nstatic int __devinit omap4_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct omap4_keypad_platform_data *pdata;\r\nstruct omap4_keypad *keypad_data;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nresource_size_t size;\r\nunsigned int row_shift, max_keys;\r\nint irq;\r\nint error;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no base address specified\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no keyboard irq assigned\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->keymap_data) {\r\ndev_err(&pdev->dev, "no keymap data defined\n");\r\nreturn -EINVAL;\r\n}\r\nrow_shift = get_count_order(pdata->cols);\r\nmax_keys = pdata->rows << row_shift;\r\nkeypad_data = kzalloc(sizeof(struct omap4_keypad) +\r\nmax_keys * sizeof(keypad_data->keymap[0]),\r\nGFP_KERNEL);\r\nif (!keypad_data) {\r\ndev_err(&pdev->dev, "keypad_data memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsize = resource_size(res);\r\nres = request_mem_region(res->start, size, pdev->name);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't request mem region\n");\r\nerror = -EBUSY;\r\ngoto err_free_keypad;\r\n}\r\nkeypad_data->base = ioremap(res->start, resource_size(res));\r\nif (!keypad_data->base) {\r\ndev_err(&pdev->dev, "can't ioremap mem resource\n");\r\nerror = -ENOMEM;\r\ngoto err_release_mem;\r\n}\r\nkeypad_data->irq = irq;\r\nkeypad_data->row_shift = row_shift;\r\nkeypad_data->rows = pdata->rows;\r\nkeypad_data->cols = pdata->cols;\r\nkeypad_data->input = input_dev = input_allocate_device();\r\nif (!input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0001;\r\ninput_dev->open = omap4_keypad_open;\r\ninput_dev->close = omap4_keypad_close;\r\ninput_dev->keycode = keypad_data->keymap;\r\ninput_dev->keycodesize = sizeof(keypad_data->keymap[0]);\r\ninput_dev->keycodemax = max_keys;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input_dev, keypad_data);\r\nmatrix_keypad_build_keymap(pdata->keymap_data, row_shift,\r\ninput_dev->keycode, input_dev->keybit);\r\nerror = request_irq(keypad_data->irq, omap4_keypad_interrupt,\r\nIRQF_TRIGGER_RISING,\r\n"omap4-keypad", keypad_data);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register interrupt\n");\r\ngoto err_free_input;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nerror = input_register_device(keypad_data->input);\r\nif (error < 0) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto err_pm_disable;\r\n}\r\nplatform_set_drvdata(pdev, keypad_data);\r\nreturn 0;\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nfree_irq(keypad_data->irq, keypad_data);\r\nerr_free_input:\r\ninput_free_device(input_dev);\r\nerr_unmap:\r\niounmap(keypad_data->base);\r\nerr_release_mem:\r\nrelease_mem_region(res->start, size);\r\nerr_free_keypad:\r\nkfree(keypad_data);\r\nreturn error;\r\n}\r\nstatic int __devexit omap4_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct omap4_keypad *keypad_data = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nfree_irq(keypad_data->irq, keypad_data);\r\npm_runtime_disable(&pdev->dev);\r\ninput_unregister_device(keypad_data->input);\r\niounmap(keypad_data->base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(keypad_data);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init omap4_keypad_init(void)\r\n{\r\nreturn platform_driver_register(&omap4_keypad_driver);\r\n}\r\nstatic void __exit omap4_keypad_exit(void)\r\n{\r\nplatform_driver_unregister(&omap4_keypad_driver);\r\n}
