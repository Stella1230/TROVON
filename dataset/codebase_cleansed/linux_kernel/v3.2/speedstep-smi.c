static int speedstep_smi_ownership(void)\r\n{\r\nu32 command, result, magic, dummy;\r\nu32 function = GET_SPEEDSTEP_OWNER;\r\nunsigned char magic_data[] = "Copyright (c) 1999 Intel Corporation";\r\ncommand = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);\r\nmagic = virt_to_phys(magic_data);\r\npr_debug("trying to obtain ownership with command %x at port %x\n",\r\ncommand, smi_port);\r\n__asm__ __volatile__(\r\n"push %%ebp\n"\r\n"out %%al, (%%dx)\n"\r\n"pop %%ebp\n"\r\n: "=D" (result),\r\n"=a" (dummy), "=b" (dummy), "=c" (dummy), "=d" (dummy),\r\n"=S" (dummy)\r\n: "a" (command), "b" (function), "c" (0), "d" (smi_port),\r\n"D" (0), "S" (magic)\r\n: "memory"\r\n);\r\npr_debug("result is %x\n", result);\r\nreturn result;\r\n}\r\nstatic int speedstep_smi_get_freqs(unsigned int *low, unsigned int *high)\r\n{\r\nu32 command, result = 0, edi, high_mhz, low_mhz, dummy;\r\nu32 state = 0;\r\nu32 function = GET_SPEEDSTEP_FREQS;\r\nif (!(ist_info.event & 0xFFFF)) {\r\npr_debug("bug #1422 -- can't read freqs from BIOS\n");\r\nreturn -ENODEV;\r\n}\r\ncommand = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);\r\npr_debug("trying to determine frequencies with command %x at port %x\n",\r\ncommand, smi_port);\r\n__asm__ __volatile__(\r\n"push %%ebp\n"\r\n"out %%al, (%%dx)\n"\r\n"pop %%ebp"\r\n: "=a" (result),\r\n"=b" (high_mhz),\r\n"=c" (low_mhz),\r\n"=d" (state), "=D" (edi), "=S" (dummy)\r\n: "a" (command),\r\n"b" (function),\r\n"c" (state),\r\n"d" (smi_port), "S" (0), "D" (0)\r\n);\r\npr_debug("result %x, low_freq %u, high_freq %u\n",\r\nresult, low_mhz, high_mhz);\r\nif ((high_mhz + low_mhz) < 600)\r\nreturn -EINVAL;\r\n*high = high_mhz * 1000;\r\n*low = low_mhz * 1000;\r\nreturn result;\r\n}\r\nstatic int speedstep_get_state(void)\r\n{\r\nu32 function = GET_SPEEDSTEP_STATE;\r\nu32 result, state, edi, command, dummy;\r\ncommand = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);\r\npr_debug("trying to determine current setting with command %x "\r\n"at port %x\n", command, smi_port);\r\n__asm__ __volatile__(\r\n"push %%ebp\n"\r\n"out %%al, (%%dx)\n"\r\n"pop %%ebp\n"\r\n: "=a" (result),\r\n"=b" (state), "=D" (edi),\r\n"=c" (dummy), "=d" (dummy), "=S" (dummy)\r\n: "a" (command), "b" (function), "c" (0),\r\n"d" (smi_port), "S" (0), "D" (0)\r\n);\r\npr_debug("state is %x, result is %x\n", state, result);\r\nreturn state & 1;\r\n}\r\nstatic void speedstep_set_state(unsigned int state)\r\n{\r\nunsigned int result = 0, command, new_state, dummy;\r\nunsigned long flags;\r\nunsigned int function = SET_SPEEDSTEP_STATE;\r\nunsigned int retry = 0;\r\nif (state > 0x1)\r\nreturn;\r\nlocal_irq_save(flags);\r\ncommand = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);\r\npr_debug("trying to set frequency to state %u "\r\n"with command %x at port %x\n",\r\nstate, command, smi_port);\r\ndo {\r\nif (retry) {\r\npr_debug("retry %u, previous result %u, waiting...\n",\r\nretry, result);\r\nmdelay(retry * 50);\r\n}\r\nretry++;\r\n__asm__ __volatile__(\r\n"push %%ebp\n"\r\n"out %%al, (%%dx)\n"\r\n"pop %%ebp"\r\n: "=b" (new_state), "=D" (result),\r\n"=c" (dummy), "=a" (dummy),\r\n"=d" (dummy), "=S" (dummy)\r\n: "a" (command), "b" (function), "c" (state),\r\n"d" (smi_port), "S" (0), "D" (0)\r\n);\r\n} while ((new_state != state) && (retry <= SMI_TRIES));\r\nlocal_irq_restore(flags);\r\nif (new_state == state)\r\npr_debug("change to %u MHz succeeded after %u tries "\r\n"with result %u\n",\r\n(speedstep_freqs[new_state].frequency / 1000),\r\nretry, result);\r\nelse\r\nprintk(KERN_ERR "cpufreq: change to state %u "\r\n"failed with new_state %u and result %u\n",\r\nstate, new_state, result);\r\nreturn;\r\n}\r\nstatic int speedstep_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq, unsigned int relation)\r\n{\r\nunsigned int newstate = 0;\r\nstruct cpufreq_freqs freqs;\r\nif (cpufreq_frequency_table_target(policy, &speedstep_freqs[0],\r\ntarget_freq, relation, &newstate))\r\nreturn -EINVAL;\r\nfreqs.old = speedstep_freqs[speedstep_get_state()].frequency;\r\nfreqs.new = speedstep_freqs[newstate].frequency;\r\nfreqs.cpu = 0;\r\nif (freqs.old == freqs.new)\r\nreturn 0;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\nspeedstep_set_state(newstate);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nreturn 0;\r\n}\r\nstatic int speedstep_verify(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy, &speedstep_freqs[0]);\r\n}\r\nstatic int speedstep_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint result;\r\nunsigned int speed, state;\r\nunsigned int *low, *high;\r\nif (policy->cpu != 0)\r\nreturn -ENODEV;\r\nresult = speedstep_smi_ownership();\r\nif (result) {\r\npr_debug("fails in acquiring ownership of a SMI interface.\n");\r\nreturn -EINVAL;\r\n}\r\nlow = &speedstep_freqs[SPEEDSTEP_LOW].frequency;\r\nhigh = &speedstep_freqs[SPEEDSTEP_HIGH].frequency;\r\nresult = speedstep_smi_get_freqs(low, high);\r\nif (result) {\r\npr_debug("could not detect low and high frequencies "\r\n"by SMI call.\n");\r\nresult = speedstep_get_freqs(speedstep_processor,\r\nlow, high,\r\nNULL,\r\n&speedstep_set_state);\r\nif (result) {\r\npr_debug("could not detect two different speeds"\r\n" -- aborting.\n");\r\nreturn result;\r\n} else\r\npr_debug("workaround worked.\n");\r\n}\r\nstate = speedstep_get_state();\r\nspeed = speedstep_freqs[state].frequency;\r\npr_debug("currently at %s speed setting - %i MHz\n",\r\n(speed == speedstep_freqs[SPEEDSTEP_LOW].frequency)\r\n? "low" : "high",\r\n(speed / 1000));\r\npolicy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;\r\npolicy->cur = speed;\r\nresult = cpufreq_frequency_table_cpuinfo(policy, speedstep_freqs);\r\nif (result)\r\nreturn result;\r\ncpufreq_frequency_table_get_attr(speedstep_freqs, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int speedstep_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nreturn 0;\r\n}\r\nstatic unsigned int speedstep_get(unsigned int cpu)\r\n{\r\nif (cpu)\r\nreturn -ENODEV;\r\nreturn speedstep_get_frequency(speedstep_processor);\r\n}\r\nstatic int speedstep_resume(struct cpufreq_policy *policy)\r\n{\r\nint result = speedstep_smi_ownership();\r\nif (result)\r\npr_debug("fails in re-acquiring ownership of a SMI interface.\n");\r\nreturn result;\r\n}\r\nstatic int __init speedstep_init(void)\r\n{\r\nspeedstep_processor = speedstep_detect_processor();\r\nswitch (speedstep_processor) {\r\ncase SPEEDSTEP_CPU_PIII_T:\r\ncase SPEEDSTEP_CPU_PIII_C:\r\ncase SPEEDSTEP_CPU_PIII_C_EARLY:\r\nbreak;\r\ndefault:\r\nspeedstep_processor = 0;\r\n}\r\nif (!speedstep_processor) {\r\npr_debug("No supported Intel CPU detected.\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("signature:0x%.8ulx, command:0x%.8ulx, "\r\n"event:0x%.8ulx, perf_level:0x%.8ulx.\n",\r\nist_info.signature, ist_info.command,\r\nist_info.event, ist_info.perf_level);\r\nif ((ist_info.signature != 0x47534943) && (\r\n(smi_port == 0) || (smi_cmd == 0)))\r\nreturn -ENODEV;\r\nif (smi_sig == 1)\r\nsmi_sig = 0x47534943;\r\nelse\r\nsmi_sig = ist_info.signature;\r\nif ((smi_port > 0xff) || (smi_port < 0))\r\nreturn -EINVAL;\r\nelse if (smi_port == 0)\r\nsmi_port = ist_info.command & 0xff;\r\nif ((smi_cmd > 0xff) || (smi_cmd < 0))\r\nreturn -EINVAL;\r\nelse if (smi_cmd == 0)\r\nsmi_cmd = (ist_info.command >> 16) & 0xff;\r\nreturn cpufreq_register_driver(&speedstep_driver);\r\n}\r\nstatic void __exit speedstep_exit(void)\r\n{\r\ncpufreq_unregister_driver(&speedstep_driver);\r\n}
