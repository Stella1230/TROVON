u16 NAND_Get_Bad_Block(u32 block)\r\n{\r\nu32 status = PASS;\r\nu32 flag_bytes = 0;\r\nu32 skip_bytes = DeviceInfo.wSpareSkipBytes;\r\nu32 page, i;\r\nu8 *pReadSpareBuf = buf_get_bad_block;\r\nif (enable_ecc)\r\nflag_bytes = DeviceInfo.wNumPageSpareFlag;\r\nfor (page = 0; page < 2; page++) {\r\nstatus = NAND_Read_Page_Spare(pReadSpareBuf, block, page, 1);\r\nif (status != PASS)\r\nreturn READ_ERROR;\r\nfor (i = flag_bytes; i < (flag_bytes + skip_bytes); i++)\r\nif (pReadSpareBuf[i] != 0xff)\r\nreturn DEFECTIVE_BLOCK;\r\n}\r\nfor (page = 1; page < 3; page++) {\r\nstatus = NAND_Read_Page_Spare(pReadSpareBuf, block,\r\nDeviceInfo.wPagesPerBlock - page , 1);\r\nif (status != PASS)\r\nreturn READ_ERROR;\r\nfor (i = flag_bytes; i < (flag_bytes + skip_bytes); i++)\r\nif (pReadSpareBuf[i] != 0xff)\r\nreturn DEFECTIVE_BLOCK;\r\n}\r\nreturn GOOD_BLOCK;\r\n}\r\nu16 NAND_Flash_Reset(void)\r\n{\r\nu32 i;\r\nu32 intr_status_rst_comp[4] = {INTR_STATUS0__RST_COMP,\r\nINTR_STATUS1__RST_COMP,\r\nINTR_STATUS2__RST_COMP,\r\nINTR_STATUS3__RST_COMP};\r\nu32 intr_status_time_out[4] = {INTR_STATUS0__TIME_OUT,\r\nINTR_STATUS1__TIME_OUT,\r\nINTR_STATUS2__TIME_OUT,\r\nINTR_STATUS3__TIME_OUT};\r\nu32 intr_status[4] = {INTR_STATUS0, INTR_STATUS1,\r\nINTR_STATUS2, INTR_STATUS3};\r\nu32 device_reset_banks[4] = {DEVICE_RESET__BANK0,\r\nDEVICE_RESET__BANK1,\r\nDEVICE_RESET__BANK2,\r\nDEVICE_RESET__BANK3};\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nfor (i = 0 ; i < LLD_MAX_FLASH_BANKS; i++)\r\niowrite32(intr_status_rst_comp[i] | intr_status_time_out[i],\r\nFlashReg + intr_status[i]);\r\nfor (i = 0 ; i < LLD_MAX_FLASH_BANKS; i++) {\r\niowrite32(device_reset_banks[i], FlashReg + DEVICE_RESET);\r\nwhile (!(ioread32(FlashReg + intr_status[i]) &\r\n(intr_status_rst_comp[i] | intr_status_time_out[i])))\r\n;\r\nif (ioread32(FlashReg + intr_status[i]) &\r\nintr_status_time_out[i])\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"NAND Reset operation timed out on bank %d\n", i);\r\n}\r\nfor (i = 0; i < LLD_MAX_FLASH_BANKS; i++)\r\niowrite32(intr_status_rst_comp[i] | intr_status_time_out[i],\r\nFlashReg + intr_status[i]);\r\nreturn PASS;\r\n}\r\nstatic void NAND_ONFi_Timing_Mode(u16 mode)\r\n{\r\nu16 Trea[6] = {40, 30, 25, 20, 20, 16};\r\nu16 Trp[6] = {50, 25, 17, 15, 12, 10};\r\nu16 Treh[6] = {30, 15, 15, 10, 10, 7};\r\nu16 Trc[6] = {100, 50, 35, 30, 25, 20};\r\nu16 Trhoh[6] = {0, 15, 15, 15, 15, 15};\r\nu16 Trloh[6] = {0, 0, 0, 0, 5, 5};\r\nu16 Tcea[6] = {100, 45, 30, 25, 25, 25};\r\nu16 Tadl[6] = {200, 100, 100, 100, 70, 70};\r\nu16 Trhw[6] = {200, 100, 100, 100, 100, 100};\r\nu16 Trhz[6] = {200, 100, 100, 100, 100, 100};\r\nu16 Twhr[6] = {120, 80, 80, 60, 60, 60};\r\nu16 Tcs[6] = {70, 35, 25, 25, 20, 15};\r\nu16 TclsRising = 1;\r\nu16 data_invalid_rhoh, data_invalid_rloh, data_invalid;\r\nu16 dv_window = 0;\r\nu16 en_lo, en_hi;\r\nu16 acc_clks;\r\nu16 addr_2_data, re_2_we, re_2_re, we_2_re, cs_cnt;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nen_lo = CEIL_DIV(Trp[mode], CLK_X);\r\nen_hi = CEIL_DIV(Treh[mode], CLK_X);\r\n#if ONFI_BLOOM_TIME\r\nif ((en_hi * CLK_X) < (Treh[mode] + 2))\r\nen_hi++;\r\n#endif\r\nif ((en_lo + en_hi) * CLK_X < Trc[mode])\r\nen_lo += CEIL_DIV((Trc[mode] - (en_lo + en_hi) * CLK_X), CLK_X);\r\nif ((en_lo + en_hi) < CLK_MULTI)\r\nen_lo += CLK_MULTI - en_lo - en_hi;\r\nwhile (dv_window < 8) {\r\ndata_invalid_rhoh = en_lo * CLK_X + Trhoh[mode];\r\ndata_invalid_rloh = (en_lo + en_hi) * CLK_X + Trloh[mode];\r\ndata_invalid =\r\ndata_invalid_rhoh <\r\ndata_invalid_rloh ? data_invalid_rhoh : data_invalid_rloh;\r\ndv_window = data_invalid - Trea[mode];\r\nif (dv_window < 8)\r\nen_lo++;\r\n}\r\nacc_clks = CEIL_DIV(Trea[mode], CLK_X);\r\nwhile (((acc_clks * CLK_X) - Trea[mode]) < 3)\r\nacc_clks++;\r\nif ((data_invalid - acc_clks * CLK_X) < 2)\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d: Warning!\n",\r\n__FILE__, __LINE__);\r\naddr_2_data = CEIL_DIV(Tadl[mode], CLK_X);\r\nre_2_we = CEIL_DIV(Trhw[mode], CLK_X);\r\nre_2_re = CEIL_DIV(Trhz[mode], CLK_X);\r\nwe_2_re = CEIL_DIV(Twhr[mode], CLK_X);\r\ncs_cnt = CEIL_DIV((Tcs[mode] - Trp[mode]), CLK_X);\r\nif (!TclsRising)\r\ncs_cnt = CEIL_DIV(Tcs[mode], CLK_X);\r\nif (cs_cnt == 0)\r\ncs_cnt = 1;\r\nif (Tcea[mode]) {\r\nwhile (((cs_cnt * CLK_X) + Trea[mode]) < Tcea[mode])\r\ncs_cnt++;\r\n}\r\n#if MODE5_WORKAROUND\r\nif (mode == 5)\r\nacc_clks = 5;\r\n#endif\r\nif ((ioread32(FlashReg + MANUFACTURER_ID) == 0) &&\r\n(ioread32(FlashReg + DEVICE_ID) == 0x88))\r\nacc_clks = 6;\r\niowrite32(acc_clks, FlashReg + ACC_CLKS);\r\niowrite32(re_2_we, FlashReg + RE_2_WE);\r\niowrite32(re_2_re, FlashReg + RE_2_RE);\r\niowrite32(we_2_re, FlashReg + WE_2_RE);\r\niowrite32(addr_2_data, FlashReg + ADDR_2_DATA);\r\niowrite32(en_lo, FlashReg + RDWR_EN_LO_CNT);\r\niowrite32(en_hi, FlashReg + RDWR_EN_HI_CNT);\r\niowrite32(cs_cnt, FlashReg + CS_SETUP_CNT);\r\n}\r\nstatic void index_addr(u32 address, u32 data)\r\n{\r\niowrite32(address, FlashMem);\r\niowrite32(data, FlashMem + 0x10);\r\n}\r\nstatic void index_addr_read_data(u32 address, u32 *pdata)\r\n{\r\niowrite32(address, FlashMem);\r\n*pdata = ioread32(FlashMem + 0x10);\r\n}\r\nstatic void set_ecc_config(void)\r\n{\r\n#if SUPPORT_8BITECC\r\nif ((ioread32(FlashReg + DEVICE_MAIN_AREA_SIZE) < 4096) ||\r\n(ioread32(FlashReg + DEVICE_SPARE_AREA_SIZE) <= 128))\r\niowrite32(8, FlashReg + ECC_CORRECTION);\r\n#endif\r\nif ((ioread32(FlashReg + ECC_CORRECTION) & ECC_CORRECTION__VALUE)\r\n== 1) {\r\nDeviceInfo.wECCBytesPerSector = 4;\r\nDeviceInfo.wECCBytesPerSector *= DeviceInfo.wDevicesConnected;\r\nDeviceInfo.wNumPageSpareFlag =\r\nDeviceInfo.wPageSpareSize -\r\nDeviceInfo.wPageDataSize /\r\n(ECC_SECTOR_SIZE * DeviceInfo.wDevicesConnected) *\r\nDeviceInfo.wECCBytesPerSector\r\n- DeviceInfo.wSpareSkipBytes;\r\n} else {\r\nDeviceInfo.wECCBytesPerSector =\r\n(ioread32(FlashReg + ECC_CORRECTION) &\r\nECC_CORRECTION__VALUE) * 13 / 8;\r\nif ((DeviceInfo.wECCBytesPerSector) % 2 == 0)\r\nDeviceInfo.wECCBytesPerSector += 2;\r\nelse\r\nDeviceInfo.wECCBytesPerSector += 1;\r\nDeviceInfo.wECCBytesPerSector *= DeviceInfo.wDevicesConnected;\r\nDeviceInfo.wNumPageSpareFlag = DeviceInfo.wPageSpareSize -\r\nDeviceInfo.wPageDataSize /\r\n(ECC_SECTOR_SIZE * DeviceInfo.wDevicesConnected) *\r\nDeviceInfo.wECCBytesPerSector\r\n- DeviceInfo.wSpareSkipBytes;\r\n}\r\n}\r\nstatic u16 get_onfi_nand_para(void)\r\n{\r\nint i;\r\nu16 blks_lun_l, blks_lun_h, n_of_luns;\r\nu32 blockperlun, id;\r\niowrite32(DEVICE_RESET__BANK0, FlashReg + DEVICE_RESET);\r\nwhile (!((ioread32(FlashReg + INTR_STATUS0) &\r\nINTR_STATUS0__RST_COMP) |\r\n(ioread32(FlashReg + INTR_STATUS0) &\r\nINTR_STATUS0__TIME_OUT)))\r\n;\r\nif (ioread32(FlashReg + INTR_STATUS0) & INTR_STATUS0__RST_COMP) {\r\niowrite32(DEVICE_RESET__BANK1, FlashReg + DEVICE_RESET);\r\nwhile (!((ioread32(FlashReg + INTR_STATUS1) &\r\nINTR_STATUS1__RST_COMP) |\r\n(ioread32(FlashReg + INTR_STATUS1) &\r\nINTR_STATUS1__TIME_OUT)))\r\n;\r\nif (ioread32(FlashReg + INTR_STATUS1) &\r\nINTR_STATUS1__RST_COMP) {\r\niowrite32(DEVICE_RESET__BANK2,\r\nFlashReg + DEVICE_RESET);\r\nwhile (!((ioread32(FlashReg + INTR_STATUS2) &\r\nINTR_STATUS2__RST_COMP) |\r\n(ioread32(FlashReg + INTR_STATUS2) &\r\nINTR_STATUS2__TIME_OUT)))\r\n;\r\nif (ioread32(FlashReg + INTR_STATUS2) &\r\nINTR_STATUS2__RST_COMP) {\r\niowrite32(DEVICE_RESET__BANK3,\r\nFlashReg + DEVICE_RESET);\r\nwhile (!((ioread32(FlashReg + INTR_STATUS3) &\r\nINTR_STATUS3__RST_COMP) |\r\n(ioread32(FlashReg + INTR_STATUS3) &\r\nINTR_STATUS3__TIME_OUT)))\r\n;\r\n} else {\r\nprintk(KERN_ERR "Getting a time out for bank 2!\n");\r\n}\r\n} else {\r\nprintk(KERN_ERR "Getting a time out for bank 1!\n");\r\n}\r\n}\r\niowrite32(INTR_STATUS0__TIME_OUT, FlashReg + INTR_STATUS0);\r\niowrite32(INTR_STATUS1__TIME_OUT, FlashReg + INTR_STATUS1);\r\niowrite32(INTR_STATUS2__TIME_OUT, FlashReg + INTR_STATUS2);\r\niowrite32(INTR_STATUS3__TIME_OUT, FlashReg + INTR_STATUS3);\r\nDeviceInfo.wONFIDevFeatures =\r\nioread32(FlashReg + ONFI_DEVICE_FEATURES);\r\nDeviceInfo.wONFIOptCommands =\r\nioread32(FlashReg + ONFI_OPTIONAL_COMMANDS);\r\nDeviceInfo.wONFITimingMode =\r\nioread32(FlashReg + ONFI_TIMING_MODE);\r\nDeviceInfo.wONFIPgmCacheTimingMode =\r\nioread32(FlashReg + ONFI_PGM_CACHE_TIMING_MODE);\r\nn_of_luns = ioread32(FlashReg + ONFI_DEVICE_NO_OF_LUNS) &\r\nONFI_DEVICE_NO_OF_LUNS__NO_OF_LUNS;\r\nblks_lun_l = ioread32(FlashReg + ONFI_DEVICE_NO_OF_BLOCKS_PER_LUN_L);\r\nblks_lun_h = ioread32(FlashReg + ONFI_DEVICE_NO_OF_BLOCKS_PER_LUN_U);\r\nblockperlun = (blks_lun_h << 16) | blks_lun_l;\r\nDeviceInfo.wTotalBlocks = n_of_luns * blockperlun;\r\nif (!(ioread32(FlashReg + ONFI_TIMING_MODE) &\r\nONFI_TIMING_MODE__VALUE))\r\nreturn FAIL;\r\nfor (i = 5; i > 0; i--) {\r\nif (ioread32(FlashReg + ONFI_TIMING_MODE) & (0x01 << i))\r\nbreak;\r\n}\r\nNAND_ONFi_Timing_Mode(i);\r\nindex_addr(MODE_11 | 0, 0x90);\r\nindex_addr(MODE_11 | 1, 0);\r\nfor (i = 0; i < 3; i++)\r\nindex_addr_read_data(MODE_11 | 2, &id);\r\nnand_dbg_print(NAND_DBG_DEBUG, "3rd ID: 0x%x\n", id);\r\nDeviceInfo.MLCDevice = id & 0x0C;\r\nreturn PASS;\r\n}\r\nstatic void get_samsung_nand_para(void)\r\n{\r\nu8 no_of_planes;\r\nu32 blk_size;\r\nu64 plane_size, capacity;\r\nu32 id_bytes[5];\r\nint i;\r\nindex_addr((u32)(MODE_11 | 0), 0x90);\r\nindex_addr((u32)(MODE_11 | 1), 0);\r\nfor (i = 0; i < 5; i++)\r\nindex_addr_read_data((u32)(MODE_11 | 2), &id_bytes[i]);\r\nnand_dbg_print(NAND_DBG_DEBUG,\r\n"ID bytes: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n",\r\nid_bytes[0], id_bytes[1], id_bytes[2],\r\nid_bytes[3], id_bytes[4]);\r\nif ((id_bytes[1] & 0xff) == 0xd3) {\r\niowrite32(5, FlashReg + ACC_CLKS);\r\niowrite32(20, FlashReg + RE_2_WE);\r\niowrite32(12, FlashReg + WE_2_RE);\r\niowrite32(14, FlashReg + ADDR_2_DATA);\r\niowrite32(3, FlashReg + RDWR_EN_LO_CNT);\r\niowrite32(2, FlashReg + RDWR_EN_HI_CNT);\r\niowrite32(2, FlashReg + CS_SETUP_CNT);\r\n}\r\nno_of_planes = 1 << ((id_bytes[4] & 0x0c) >> 2);\r\nplane_size = (u64)64 << ((id_bytes[4] & 0x70) >> 4);\r\nblk_size = 64 << ((ioread32(FlashReg + DEVICE_PARAM_1) & 0x30) >> 4);\r\ncapacity = (u64)128 * plane_size * no_of_planes;\r\nDeviceInfo.wTotalBlocks = (u32)GLOB_u64_Div(capacity, blk_size);\r\n}\r\nstatic void get_toshiba_nand_para(void)\r\n{\r\nvoid __iomem *scratch_reg;\r\nu32 tmp;\r\nif ((ioread32(FlashReg + DEVICE_MAIN_AREA_SIZE) == 4096) &&\r\n(ioread32(FlashReg + DEVICE_SPARE_AREA_SIZE) == 64)) {\r\niowrite32(216, FlashReg + DEVICE_SPARE_AREA_SIZE);\r\ntmp = ioread32(FlashReg + DEVICES_CONNECTED) *\r\nioread32(FlashReg + DEVICE_SPARE_AREA_SIZE);\r\niowrite32(tmp, FlashReg + LOGICAL_PAGE_SPARE_SIZE);\r\n#if SUPPORT_15BITECC\r\niowrite32(15, FlashReg + ECC_CORRECTION);\r\n#elif SUPPORT_8BITECC\r\niowrite32(8, FlashReg + ECC_CORRECTION);\r\n#endif\r\n}\r\nscratch_reg = ioremap_nocache(SCRATCH_REG_ADDR, SCRATCH_REG_SIZE);\r\nif (!scratch_reg) {\r\nprintk(KERN_ERR "Spectra: ioremap failed in %s, Line %d",\r\n__FILE__, __LINE__);\r\nDeviceInfo.wTotalBlocks = GLOB_HWCTL_DEFAULT_BLKS;\r\n} else {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Spectra: ioremap reg address: 0x%p\n", scratch_reg);\r\nDeviceInfo.wTotalBlocks = 1 << ioread8(scratch_reg);\r\nif (DeviceInfo.wTotalBlocks < 512)\r\nDeviceInfo.wTotalBlocks = GLOB_HWCTL_DEFAULT_BLKS;\r\niounmap(scratch_reg);\r\n}\r\n}\r\nstatic void get_hynix_nand_para(void)\r\n{\r\nvoid __iomem *scratch_reg;\r\nu32 main_size, spare_size;\r\nswitch (DeviceInfo.wDeviceID) {\r\ncase 0xD5:\r\ncase 0xD7:\r\niowrite32(128, FlashReg + PAGES_PER_BLOCK);\r\niowrite32(4096, FlashReg + DEVICE_MAIN_AREA_SIZE);\r\niowrite32(224, FlashReg + DEVICE_SPARE_AREA_SIZE);\r\nmain_size = 4096 * ioread32(FlashReg + DEVICES_CONNECTED);\r\nspare_size = 224 * ioread32(FlashReg + DEVICES_CONNECTED);\r\niowrite32(main_size, FlashReg + LOGICAL_PAGE_DATA_SIZE);\r\niowrite32(spare_size, FlashReg + LOGICAL_PAGE_SPARE_SIZE);\r\niowrite32(0, FlashReg + DEVICE_WIDTH);\r\n#if SUPPORT_15BITECC\r\niowrite32(15, FlashReg + ECC_CORRECTION);\r\n#elif SUPPORT_8BITECC\r\niowrite32(8, FlashReg + ECC_CORRECTION);\r\n#endif\r\nDeviceInfo.MLCDevice = 1;\r\nbreak;\r\ndefault:\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Spectra: Unknown Hynix NAND (Device ID: 0x%x)."\r\n"Will use default parameter values instead.\n",\r\nDeviceInfo.wDeviceID);\r\n}\r\nscratch_reg = ioremap_nocache(SCRATCH_REG_ADDR, SCRATCH_REG_SIZE);\r\nif (!scratch_reg) {\r\nprintk(KERN_ERR "Spectra: ioremap failed in %s, Line %d",\r\n__FILE__, __LINE__);\r\nDeviceInfo.wTotalBlocks = GLOB_HWCTL_DEFAULT_BLKS;\r\n} else {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Spectra: ioremap reg address: 0x%p\n", scratch_reg);\r\nDeviceInfo.wTotalBlocks = 1 << ioread8(scratch_reg);\r\nif (DeviceInfo.wTotalBlocks < 512)\r\nDeviceInfo.wTotalBlocks = GLOB_HWCTL_DEFAULT_BLKS;\r\niounmap(scratch_reg);\r\n}\r\n}\r\nstatic void find_valid_banks(void)\r\n{\r\nu32 id[LLD_MAX_FLASH_BANKS];\r\nint i;\r\ntotalUsedBanks = 0;\r\nfor (i = 0; i < LLD_MAX_FLASH_BANKS; i++) {\r\nindex_addr((u32)(MODE_11 | (i << 24) | 0), 0x90);\r\nindex_addr((u32)(MODE_11 | (i << 24) | 1), 0);\r\nindex_addr_read_data((u32)(MODE_11 | (i << 24) | 2), &id[i]);\r\nnand_dbg_print(NAND_DBG_DEBUG,\r\n"Return 1st ID for bank[%d]: %x\n", i, id[i]);\r\nif (i == 0) {\r\nif (id[i] & 0x0ff)\r\nGLOB_valid_banks[i] = 1;\r\n} else {\r\nif ((id[i] & 0x0ff) == (id[0] & 0x0ff))\r\nGLOB_valid_banks[i] = 1;\r\n}\r\ntotalUsedBanks += GLOB_valid_banks[i];\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG,\r\n"totalUsedBanks: %d\n", totalUsedBanks);\r\n}\r\nstatic void detect_partition_feature(void)\r\n{\r\nif (ioread32(FlashReg + FEATURES) & FEATURES__PARTITION) {\r\nif ((ioread32(FlashReg + PERM_SRC_ID_1) &\r\nPERM_SRC_ID_1__SRCID) == SPECTRA_PARTITION_ID) {\r\nDeviceInfo.wSpectraStartBlock =\r\n((ioread32(FlashReg + MIN_MAX_BANK_1) &\r\nMIN_MAX_BANK_1__MIN_VALUE) *\r\nDeviceInfo.wTotalBlocks)\r\n+\r\n(ioread32(FlashReg + MIN_BLK_ADDR_1) &\r\nMIN_BLK_ADDR_1__VALUE);\r\nDeviceInfo.wSpectraEndBlock =\r\n(((ioread32(FlashReg + MIN_MAX_BANK_1) &\r\nMIN_MAX_BANK_1__MAX_VALUE) >> 2) *\r\nDeviceInfo.wTotalBlocks)\r\n+\r\n(ioread32(FlashReg + MAX_BLK_ADDR_1) &\r\nMAX_BLK_ADDR_1__VALUE);\r\nDeviceInfo.wTotalBlocks *= totalUsedBanks;\r\nif (DeviceInfo.wSpectraEndBlock >=\r\nDeviceInfo.wTotalBlocks) {\r\nDeviceInfo.wSpectraEndBlock =\r\nDeviceInfo.wTotalBlocks - 1;\r\n}\r\nDeviceInfo.wDataBlockNum =\r\nDeviceInfo.wSpectraEndBlock -\r\nDeviceInfo.wSpectraStartBlock + 1;\r\n} else {\r\nDeviceInfo.wTotalBlocks *= totalUsedBanks;\r\nDeviceInfo.wSpectraStartBlock = SPECTRA_START_BLOCK;\r\nDeviceInfo.wSpectraEndBlock =\r\nDeviceInfo.wTotalBlocks - 1;\r\nDeviceInfo.wDataBlockNum =\r\nDeviceInfo.wSpectraEndBlock -\r\nDeviceInfo.wSpectraStartBlock + 1;\r\n}\r\n} else {\r\nDeviceInfo.wTotalBlocks *= totalUsedBanks;\r\nDeviceInfo.wSpectraStartBlock = SPECTRA_START_BLOCK;\r\nDeviceInfo.wSpectraEndBlock = DeviceInfo.wTotalBlocks - 1;\r\nDeviceInfo.wDataBlockNum =\r\nDeviceInfo.wSpectraEndBlock -\r\nDeviceInfo.wSpectraStartBlock + 1;\r\n}\r\n}\r\nstatic void dump_device_info(void)\r\n{\r\nnand_dbg_print(NAND_DBG_DEBUG, "DeviceInfo:\n");\r\nnand_dbg_print(NAND_DBG_DEBUG, "DeviceMaker: 0x%x\n",\r\nDeviceInfo.wDeviceMaker);\r\nnand_dbg_print(NAND_DBG_DEBUG, "DeviceID: 0x%x\n",\r\nDeviceInfo.wDeviceID);\r\nnand_dbg_print(NAND_DBG_DEBUG, "DeviceType: 0x%x\n",\r\nDeviceInfo.wDeviceType);\r\nnand_dbg_print(NAND_DBG_DEBUG, "SpectraStartBlock: %d\n",\r\nDeviceInfo.wSpectraStartBlock);\r\nnand_dbg_print(NAND_DBG_DEBUG, "SpectraEndBlock: %d\n",\r\nDeviceInfo.wSpectraEndBlock);\r\nnand_dbg_print(NAND_DBG_DEBUG, "TotalBlocks: %d\n",\r\nDeviceInfo.wTotalBlocks);\r\nnand_dbg_print(NAND_DBG_DEBUG, "PagesPerBlock: %d\n",\r\nDeviceInfo.wPagesPerBlock);\r\nnand_dbg_print(NAND_DBG_DEBUG, "PageSize: %d\n",\r\nDeviceInfo.wPageSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "PageDataSize: %d\n",\r\nDeviceInfo.wPageDataSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "PageSpareSize: %d\n",\r\nDeviceInfo.wPageSpareSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "NumPageSpareFlag: %d\n",\r\nDeviceInfo.wNumPageSpareFlag);\r\nnand_dbg_print(NAND_DBG_DEBUG, "ECCBytesPerSector: %d\n",\r\nDeviceInfo.wECCBytesPerSector);\r\nnand_dbg_print(NAND_DBG_DEBUG, "BlockSize: %d\n",\r\nDeviceInfo.wBlockSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "BlockDataSize: %d\n",\r\nDeviceInfo.wBlockDataSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "DataBlockNum: %d\n",\r\nDeviceInfo.wDataBlockNum);\r\nnand_dbg_print(NAND_DBG_DEBUG, "PlaneNum: %d\n",\r\nDeviceInfo.bPlaneNum);\r\nnand_dbg_print(NAND_DBG_DEBUG, "DeviceMainAreaSize: %d\n",\r\nDeviceInfo.wDeviceMainAreaSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "DeviceSpareAreaSize: %d\n",\r\nDeviceInfo.wDeviceSpareAreaSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "DevicesConnected: %d\n",\r\nDeviceInfo.wDevicesConnected);\r\nnand_dbg_print(NAND_DBG_DEBUG, "DeviceWidth: %d\n",\r\nDeviceInfo.wDeviceWidth);\r\nnand_dbg_print(NAND_DBG_DEBUG, "HWRevision: 0x%x\n",\r\nDeviceInfo.wHWRevision);\r\nnand_dbg_print(NAND_DBG_DEBUG, "HWFeatures: 0x%x\n",\r\nDeviceInfo.wHWFeatures);\r\nnand_dbg_print(NAND_DBG_DEBUG, "ONFIDevFeatures: 0x%x\n",\r\nDeviceInfo.wONFIDevFeatures);\r\nnand_dbg_print(NAND_DBG_DEBUG, "ONFIOptCommands: 0x%x\n",\r\nDeviceInfo.wONFIOptCommands);\r\nnand_dbg_print(NAND_DBG_DEBUG, "ONFITimingMode: 0x%x\n",\r\nDeviceInfo.wONFITimingMode);\r\nnand_dbg_print(NAND_DBG_DEBUG, "ONFIPgmCacheTimingMode: 0x%x\n",\r\nDeviceInfo.wONFIPgmCacheTimingMode);\r\nnand_dbg_print(NAND_DBG_DEBUG, "MLCDevice: %s\n",\r\nDeviceInfo.MLCDevice ? "Yes" : "No");\r\nnand_dbg_print(NAND_DBG_DEBUG, "SpareSkipBytes: %d\n",\r\nDeviceInfo.wSpareSkipBytes);\r\nnand_dbg_print(NAND_DBG_DEBUG, "BitsInPageNumber: %d\n",\r\nDeviceInfo.nBitsInPageNumber);\r\nnand_dbg_print(NAND_DBG_DEBUG, "BitsInPageDataSize: %d\n",\r\nDeviceInfo.nBitsInPageDataSize);\r\nnand_dbg_print(NAND_DBG_DEBUG, "BitsInBlockDataSize: %d\n",\r\nDeviceInfo.nBitsInBlockDataSize);\r\n}\r\nu16 NAND_Read_Device_ID(void)\r\n{\r\nu16 status = PASS;\r\nu8 no_of_planes;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\niowrite32(0x02, FlashReg + SPARE_AREA_SKIP_BYTES);\r\niowrite32(0xffff, FlashReg + SPARE_AREA_MARKER);\r\nDeviceInfo.wDeviceMaker = ioread32(FlashReg + MANUFACTURER_ID);\r\nDeviceInfo.wDeviceID = ioread32(FlashReg + DEVICE_ID);\r\nDeviceInfo.MLCDevice = ioread32(FlashReg + DEVICE_PARAM_0) & 0x0c;\r\nif (ioread32(FlashReg + ONFI_DEVICE_NO_OF_LUNS) &\r\nONFI_DEVICE_NO_OF_LUNS__ONFI_DEVICE) {\r\nif (FAIL == get_onfi_nand_para())\r\nreturn FAIL;\r\n} else if (DeviceInfo.wDeviceMaker == 0xEC) {\r\nget_samsung_nand_para();\r\n} else if (DeviceInfo.wDeviceMaker == 0x98) {\r\nget_toshiba_nand_para();\r\n} else if (DeviceInfo.wDeviceMaker == 0xAD) {\r\nget_hynix_nand_para();\r\n} else {\r\nDeviceInfo.wTotalBlocks = GLOB_HWCTL_DEFAULT_BLKS;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Dump timing register values:"\r\n"acc_clks: %d, re_2_we: %d, we_2_re: %d,"\r\n"addr_2_data: %d, rdwr_en_lo_cnt: %d, "\r\n"rdwr_en_hi_cnt: %d, cs_setup_cnt: %d\n",\r\nioread32(FlashReg + ACC_CLKS),\r\nioread32(FlashReg + RE_2_WE),\r\nioread32(FlashReg + WE_2_RE),\r\nioread32(FlashReg + ADDR_2_DATA),\r\nioread32(FlashReg + RDWR_EN_LO_CNT),\r\nioread32(FlashReg + RDWR_EN_HI_CNT),\r\nioread32(FlashReg + CS_SETUP_CNT));\r\nDeviceInfo.wHWRevision = ioread32(FlashReg + REVISION);\r\nDeviceInfo.wHWFeatures = ioread32(FlashReg + FEATURES);\r\nDeviceInfo.wDeviceMainAreaSize =\r\nioread32(FlashReg + DEVICE_MAIN_AREA_SIZE);\r\nDeviceInfo.wDeviceSpareAreaSize =\r\nioread32(FlashReg + DEVICE_SPARE_AREA_SIZE);\r\nDeviceInfo.wPageDataSize =\r\nioread32(FlashReg + LOGICAL_PAGE_DATA_SIZE);\r\nDeviceInfo.wPageSpareSize =\r\nioread32(FlashReg + LOGICAL_PAGE_SPARE_SIZE);\r\nDeviceInfo.wPagesPerBlock = ioread32(FlashReg + PAGES_PER_BLOCK);\r\nDeviceInfo.wPageSize =\r\nDeviceInfo.wPageDataSize + DeviceInfo.wPageSpareSize;\r\nDeviceInfo.wBlockSize =\r\nDeviceInfo.wPageSize * DeviceInfo.wPagesPerBlock;\r\nDeviceInfo.wBlockDataSize =\r\nDeviceInfo.wPagesPerBlock * DeviceInfo.wPageDataSize;\r\nDeviceInfo.wDeviceWidth = ioread32(FlashReg + DEVICE_WIDTH);\r\nDeviceInfo.wDeviceType =\r\n((ioread32(FlashReg + DEVICE_WIDTH) > 0) ? 16 : 8);\r\nDeviceInfo.wDevicesConnected = ioread32(FlashReg + DEVICES_CONNECTED);\r\nDeviceInfo.wSpareSkipBytes =\r\nioread32(FlashReg + SPARE_AREA_SKIP_BYTES) *\r\nDeviceInfo.wDevicesConnected;\r\nDeviceInfo.nBitsInPageNumber =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wPagesPerBlock);\r\nDeviceInfo.nBitsInPageDataSize =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wPageDataSize);\r\nDeviceInfo.nBitsInBlockDataSize =\r\n(u8)GLOB_Calc_Used_Bits(DeviceInfo.wBlockDataSize);\r\nset_ecc_config();\r\nno_of_planes = ioread32(FlashReg + NUMBER_OF_PLANES) &\r\nNUMBER_OF_PLANES__VALUE;\r\nswitch (no_of_planes) {\r\ncase 0:\r\ncase 1:\r\ncase 3:\r\ncase 7:\r\nDeviceInfo.bPlaneNum = no_of_planes + 1;\r\nbreak;\r\ndefault:\r\nstatus = FAIL;\r\nbreak;\r\n}\r\nfind_valid_banks();\r\ndetect_partition_feature();\r\ndump_device_info();\r\nreturn status;\r\n}\r\nu16 NAND_UnlockArrayAll(void)\r\n{\r\nu64 start_addr, end_addr;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstart_addr = 0;\r\nend_addr = ((u64)DeviceInfo.wBlockSize *\r\n(DeviceInfo.wTotalBlocks - 1)) >>\r\nDeviceInfo.nBitsInPageDataSize;\r\nindex_addr((u32)(MODE_10 | (u32)start_addr), 0x10);\r\nindex_addr((u32)(MODE_10 | (u32)end_addr), 0x11);\r\nreturn PASS;\r\n}\r\nvoid NAND_LLD_Enable_Disable_Interrupts(u16 INT_ENABLE)\r\n{\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (INT_ENABLE)\r\niowrite32(1, FlashReg + GLOBAL_INT_ENABLE);\r\nelse\r\niowrite32(0, FlashReg + GLOBAL_INT_ENABLE);\r\n}\r\nu16 NAND_Erase_Block(u32 block)\r\n{\r\nu16 status = PASS;\r\nu64 flash_add;\r\nu16 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nif (block >= DeviceInfo.wTotalBlocks)\r\nstatus = FAIL;\r\nif (status == PASS) {\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(INTR_STATUS0__ERASE_COMP | INTR_STATUS0__ERASE_FAIL,\r\nFlashReg + intr_status);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 1);\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\n(INTR_STATUS0__ERASE_COMP | INTR_STATUS0__ERASE_FAIL)))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ERASE_FAIL)\r\nstatus = FAIL;\r\niowrite32(INTR_STATUS0__ERASE_COMP | INTR_STATUS0__ERASE_FAIL,\r\nFlashReg + intr_status);\r\n}\r\nreturn status;\r\n}\r\nstatic u32 Boundary_Check_Block_Page(u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nu32 status = PASS;\r\nif (block >= DeviceInfo.wTotalBlocks)\r\nstatus = FAIL;\r\nif (page + page_count > DeviceInfo.wPagesPerBlock)\r\nstatus = FAIL;\r\nreturn status;\r\n}\r\nu16 NAND_Read_Page_Spare(u8 *read_data, u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nu32 status = PASS;\r\nu32 i;\r\nu64 flash_add;\r\nu32 PageSpareSize = DeviceInfo.wPageSpareSize;\r\nu32 spareFlagBytes = DeviceInfo.wNumPageSpareFlag;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu8 *page_spare = buf_read_page_spare;\r\nif (block >= DeviceInfo.wTotalBlocks) {\r\nprintk(KERN_ERR "block too big: %d\n", (int)block);\r\nstatus = FAIL;\r\n}\r\nif (page >= DeviceInfo.wPagesPerBlock) {\r\nprintk(KERN_ERR "page too big: %d\n", page);\r\nstatus = FAIL;\r\n}\r\nif (page_count > 1) {\r\nprintk(KERN_ERR "page count too big: %d\n", page_count);\r\nstatus = FAIL;\r\n}\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nif (status == PASS) {\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)),\r\n0x41);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)),\r\n0x2000 | page_count);\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__LOAD_COMP))\r\n;\r\niowrite32((u32)(MODE_01 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)),\r\nFlashMem);\r\nfor (i = 0; i < (PageSpareSize / 4); i++)\r\n*((u32 *)page_spare + i) =\r\nioread32(FlashMem + 0x10);\r\nif (enable_ecc) {\r\nfor (i = 0; i < spareFlagBytes; i++)\r\nread_data[i] =\r\npage_spare[PageSpareSize -\r\nspareFlagBytes + i];\r\nfor (i = 0; i < (PageSpareSize - spareFlagBytes); i++)\r\nread_data[spareFlagBytes + i] =\r\npage_spare[i];\r\n} else {\r\nfor (i = 0; i < PageSpareSize; i++)\r\nread_data[i] = page_spare[i];\r\n}\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 0x42);\r\n}\r\nreturn status;\r\n}\r\nu16 NAND_Write_Page_Spare(u8 *write_data, u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nprintk(KERN_ERR\r\n"Error! This function (NAND_Write_Page_Spare) should never"\r\n" be called!\n");\r\nreturn ERR;\r\n}\r\nstatic void ddma_trans(u8 *data, u64 flash_add,\r\nu32 flash_bank, int op, u32 numPages)\r\n{\r\nu32 data_addr;\r\ndata_addr = virt_to_bus(data);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)),\r\n(u16)(2 << 12) | (op << 8) | numPages);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n((u16)(0x0FFFF & (data_addr >> 16)) << 8)),\r\n(u16)(2 << 12) | (2 << 8) | 0);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n((u16)(0x0FFFF & data_addr) << 8)),\r\n(u16)(2 << 12) | (3 << 8) | 0);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(1 << 16) | (0x40 << 8)),\r\n(u16)(2 << 12) | (4 << 8) | 0);\r\n}\r\nstatic int check_all_1(u8 *buf)\r\n{\r\nint i, j, cnt;\r\nfor (i = 0; i < DeviceInfo.wPageDataSize; i++) {\r\nif (buf[i] != 0xff) {\r\ncnt = 0;\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"the first non-0xff data byte is: %d\n", i);\r\nfor (j = i; j < DeviceInfo.wPageDataSize; j++) {\r\nnand_dbg_print(NAND_DBG_WARN, "0x%x ", buf[j]);\r\ncnt++;\r\nif (cnt > 8)\r\nbreak;\r\n}\r\nnand_dbg_print(NAND_DBG_WARN, "\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int do_ecc_new(unsigned long bank, u8 *buf,\r\nu32 block, u16 page)\r\n{\r\nint status = PASS;\r\nu16 err_page = 0;\r\nu16 err_byte;\r\nu8 err_sect;\r\nu8 err_dev;\r\nu16 err_fix_info;\r\nu16 err_addr;\r\nu32 ecc_sect_size;\r\nu8 *err_pos;\r\nu32 err_page_addr[4] = {ERR_PAGE_ADDR0,\r\nERR_PAGE_ADDR1, ERR_PAGE_ADDR2, ERR_PAGE_ADDR3};\r\necc_sect_size = ECC_SECTOR_SIZE * (DeviceInfo.wDevicesConnected);\r\ndo {\r\nerr_page = ioread32(FlashReg + err_page_addr[bank]);\r\nerr_addr = ioread32(FlashReg + ECC_ERROR_ADDRESS);\r\nerr_byte = err_addr & ECC_ERROR_ADDRESS__OFFSET;\r\nerr_sect = ((err_addr & ECC_ERROR_ADDRESS__SECTOR_NR) >> 12);\r\nerr_fix_info = ioread32(FlashReg + ERR_CORRECTION_INFO);\r\nerr_dev = ((err_fix_info & ERR_CORRECTION_INFO__DEVICE_NR)\r\n>> 8);\r\nif (err_fix_info & ERR_CORRECTION_INFO__ERROR_TYPE) {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"%s, Line %d Uncorrectable ECC error "\r\n"when read block %d page %d."\r\n"PTN_INTR register: 0x%x "\r\n"err_page: %d, err_sect: %d, err_byte: %d, "\r\n"err_dev: %d, ecc_sect_size: %d, "\r\n"err_fix_info: 0x%x\n",\r\n__FILE__, __LINE__, block, page,\r\nioread32(FlashReg + PTN_INTR),\r\nerr_page, err_sect, err_byte, err_dev,\r\necc_sect_size, (u32)err_fix_info);\r\nif (check_all_1(buf))\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d"\r\n"All 0xff!\n",\r\n__FILE__, __LINE__);\r\nelse\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d"\r\n"Not all 0xff!\n",\r\n__FILE__, __LINE__);\r\nstatus = FAIL;\r\n} else {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"%s, Line %d Found ECC error "\r\n"when read block %d page %d."\r\n"err_page: %d, err_sect: %d, err_byte: %d, "\r\n"err_dev: %d, ecc_sect_size: %d, "\r\n"err_fix_info: 0x%x\n",\r\n__FILE__, __LINE__, block, page,\r\nerr_page, err_sect, err_byte, err_dev,\r\necc_sect_size, (u32)err_fix_info);\r\nif (err_byte < ECC_SECTOR_SIZE) {\r\nerr_pos = buf +\r\n(err_page - page) *\r\nDeviceInfo.wPageDataSize +\r\nerr_sect * ecc_sect_size +\r\nerr_byte *\r\nDeviceInfo.wDevicesConnected +\r\nerr_dev;\r\n*err_pos ^= err_fix_info &\r\nERR_CORRECTION_INFO__BYTEMASK;\r\n}\r\n}\r\n} while (!(err_fix_info & ERR_CORRECTION_INFO__LAST_ERR_INFO));\r\nreturn status;\r\n}\r\nu16 NAND_Read_Page_Main_Polling(u8 *read_data,\r\nu32 block, u16 page, u16 page_count)\r\n{\r\nu32 status = PASS;\r\nu64 flash_add;\r\nu32 intr_status = 0;\r\nu32 flash_bank;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu8 *read_data_l;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nif (status != PASS)\r\nreturn status;\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\nif (page_count > 1) {\r\nread_data_l = read_data;\r\nwhile (page_count > MAX_PAGES_PER_RW) {\r\nif (ioread32(FlashReg + MULTIPLANE_OPERATION))\r\nstatus = NAND_Multiplane_Read(read_data_l,\r\nblock, page, MAX_PAGES_PER_RW);\r\nelse\r\nstatus = NAND_Pipeline_Read_Ahead_Polling(\r\nread_data_l, block, page,\r\nMAX_PAGES_PER_RW);\r\nif (status == FAIL)\r\nreturn status;\r\nread_data_l += DeviceInfo.wPageDataSize *\r\nMAX_PAGES_PER_RW;\r\npage_count -= MAX_PAGES_PER_RW;\r\npage += MAX_PAGES_PER_RW;\r\n}\r\nif (ioread32(FlashReg + MULTIPLANE_OPERATION))\r\nstatus = NAND_Multiplane_Read(read_data_l,\r\nblock, page, page_count);\r\nelse\r\nstatus = NAND_Pipeline_Read_Ahead_Polling(\r\nread_data_l, block, page, page_count);\r\nreturn status;\r\n}\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\nddma_trans(read_data, flash_add, flash_bank, 0, 1);\r\nif (enable_ecc) {\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\n(INTR_STATUS0__ECC_TRANSACTION_DONE |\r\nINTR_STATUS0__ECC_ERR)))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_ERR) {\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\nstatus = do_ecc_new(flash_bank, read_data,\r\nblock, page);\r\n}\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_TRANSACTION_DONE &\r\nINTR_STATUS0__ECC_ERR)\r\niowrite32(INTR_STATUS0__ECC_TRANSACTION_DONE |\r\nINTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\nelse if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_TRANSACTION_DONE)\r\niowrite32(INTR_STATUS0__ECC_TRANSACTION_DONE,\r\nFlashReg + intr_status);\r\nelse if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_ERR)\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\n} else {\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP))\r\n;\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP, FlashReg + intr_status);\r\n}\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\nreturn status;\r\n}\r\nu16 NAND_Pipeline_Read_Ahead_Polling(u8 *read_data,\r\nu32 block, u16 page, u16 page_count)\r\n{\r\nu32 status = PASS;\r\nu32 NumPages = page_count;\r\nu64 flash_add;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu32 ecc_done_OR_dma_comp;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nif (page_count < 2)\r\nstatus = FAIL;\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n*DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nif (status == PASS) {\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 0x42);\r\nddma_trans(read_data, flash_add, flash_bank, 0, NumPages);\r\necc_done_OR_dma_comp = 0;\r\nwhile (1) {\r\nif (enable_ecc) {\r\nwhile (!ioread32(FlashReg + intr_status))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_ERR) {\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\nstatus = do_ecc_new(flash_bank,\r\nread_data, block, page);\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP) {\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nif (1 == ecc_done_OR_dma_comp)\r\nbreak;\r\necc_done_OR_dma_comp = 1;\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_TRANSACTION_DONE) {\r\niowrite32(\r\nINTR_STATUS0__ECC_TRANSACTION_DONE,\r\nFlashReg + intr_status);\r\nif (1 == ecc_done_OR_dma_comp)\r\nbreak;\r\necc_done_OR_dma_comp = 1;\r\n}\r\n} else {\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP))\r\n;\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nbreak;\r\n}\r\niowrite32((~INTR_STATUS0__ECC_ERR) &\r\n(~INTR_STATUS0__ECC_TRANSACTION_DONE) &\r\n(~INTR_STATUS0__DMA_CMD_COMP),\r\nFlashReg + intr_status);\r\n}\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\n}\r\nreturn status;\r\n}\r\nu16 NAND_Read_Page_Main(u8 *read_data, u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nu32 status = PASS;\r\nu64 flash_add;\r\nu32 intr_status = 0;\r\nu32 flash_bank;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nint ret;\r\nu8 *read_data_l;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nif (status != PASS)\r\nreturn status;\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\nif (page_count > 1) {\r\nread_data_l = read_data;\r\nwhile (page_count > MAX_PAGES_PER_RW) {\r\nif (ioread32(FlashReg + MULTIPLANE_OPERATION))\r\nstatus = NAND_Multiplane_Read(read_data_l,\r\nblock, page, MAX_PAGES_PER_RW);\r\nelse\r\nstatus = NAND_Pipeline_Read_Ahead(\r\nread_data_l, block, page,\r\nMAX_PAGES_PER_RW);\r\nif (status == FAIL)\r\nreturn status;\r\nread_data_l += DeviceInfo.wPageDataSize *\r\nMAX_PAGES_PER_RW;\r\npage_count -= MAX_PAGES_PER_RW;\r\npage += MAX_PAGES_PER_RW;\r\n}\r\nif (ioread32(FlashReg + MULTIPLANE_OPERATION))\r\nstatus = NAND_Multiplane_Read(read_data_l,\r\nblock, page, page_count);\r\nelse\r\nstatus = NAND_Pipeline_Read_Ahead(\r\nread_data_l, block, page, page_count);\r\nreturn status;\r\n}\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\ninfo.state = INT_READ_PAGE_MAIN;\r\ninfo.read_data = read_data;\r\ninfo.flash_bank = flash_bank;\r\ninfo.block = block;\r\ninfo.page = page;\r\ninfo.ret = PASS;\r\nddma_trans(read_data, flash_add, flash_bank, 0, 1);\r\niowrite32(1, FlashReg + GLOBAL_INT_ENABLE);\r\nret = wait_for_completion_timeout(&info.complete, 10 * HZ);\r\nif (!ret) {\r\nprintk(KERN_ERR "Wait for completion timeout "\r\n"in %s, Line %d\n", __FILE__, __LINE__);\r\nstatus = ERR;\r\n} else {\r\nstatus = info.ret;\r\n}\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\nreturn status;\r\n}\r\nvoid Conv_Spare_Data_Log2Phy_Format(u8 *data)\r\n{\r\nint i;\r\nconst u32 spareFlagBytes = DeviceInfo.wNumPageSpareFlag;\r\nconst u32 PageSpareSize = DeviceInfo.wPageSpareSize;\r\nif (enable_ecc) {\r\nfor (i = spareFlagBytes - 1; i >= 0; i--)\r\ndata[PageSpareSize - spareFlagBytes + i] = data[i];\r\n}\r\n}\r\nvoid Conv_Spare_Data_Phy2Log_Format(u8 *data)\r\n{\r\nint i;\r\nconst u32 spareFlagBytes = DeviceInfo.wNumPageSpareFlag;\r\nconst u32 PageSpareSize = DeviceInfo.wPageSpareSize;\r\nif (enable_ecc) {\r\nfor (i = 0; i < spareFlagBytes; i++)\r\ndata[i] = data[PageSpareSize - spareFlagBytes + i];\r\n}\r\n}\r\nvoid Conv_Main_Spare_Data_Log2Phy_Format(u8 *data, u16 page_count)\r\n{\r\nconst u32 PageSize = DeviceInfo.wPageSize;\r\nconst u32 PageDataSize = DeviceInfo.wPageDataSize;\r\nconst u32 eccBytes = DeviceInfo.wECCBytesPerSector;\r\nconst u32 spareSkipBytes = DeviceInfo.wSpareSkipBytes;\r\nconst u32 spareFlagBytes = DeviceInfo.wNumPageSpareFlag;\r\nu32 eccSectorSize;\r\nu32 page_offset;\r\nint i, j;\r\neccSectorSize = ECC_SECTOR_SIZE * (DeviceInfo.wDevicesConnected);\r\nif (enable_ecc) {\r\nwhile (page_count > 0) {\r\npage_offset = (page_count - 1) * PageSize;\r\nj = (DeviceInfo.wPageDataSize / eccSectorSize);\r\nfor (i = spareFlagBytes - 1; i >= 0; i--)\r\ndata[page_offset +\r\n(eccSectorSize + eccBytes) * j + i] =\r\ndata[page_offset + PageDataSize + i];\r\nfor (j--; j >= 1; j--) {\r\nfor (i = eccSectorSize - 1; i >= 0; i--)\r\ndata[page_offset +\r\n(eccSectorSize + eccBytes) * j + i] =\r\ndata[page_offset +\r\neccSectorSize * j + i];\r\n}\r\nfor (i = (PageSize - spareSkipBytes) - 1;\r\ni >= PageDataSize; i--)\r\ndata[page_offset + i + spareSkipBytes] =\r\ndata[page_offset + i];\r\npage_count--;\r\n}\r\n}\r\n}\r\nvoid Conv_Main_Spare_Data_Phy2Log_Format(u8 *data, u16 page_count)\r\n{\r\nconst u32 PageSize = DeviceInfo.wPageSize;\r\nconst u32 PageDataSize = DeviceInfo.wPageDataSize;\r\nconst u32 eccBytes = DeviceInfo.wECCBytesPerSector;\r\nconst u32 spareSkipBytes = DeviceInfo.wSpareSkipBytes;\r\nconst u32 spareFlagBytes = DeviceInfo.wNumPageSpareFlag;\r\nu32 eccSectorSize;\r\nu32 page_offset;\r\nint i, j;\r\neccSectorSize = ECC_SECTOR_SIZE * (DeviceInfo.wDevicesConnected);\r\nif (enable_ecc) {\r\nwhile (page_count > 0) {\r\npage_offset = (page_count - 1) * PageSize;\r\nfor (i = PageDataSize;\r\ni < PageSize - spareSkipBytes;\r\ni++)\r\ndata[page_offset + i] =\r\ndata[page_offset + i +\r\nspareSkipBytes];\r\nfor (j = 1;\r\nj < DeviceInfo.wPageDataSize / eccSectorSize;\r\nj++) {\r\nfor (i = 0; i < eccSectorSize; i++)\r\ndata[page_offset +\r\neccSectorSize * j + i] =\r\ndata[page_offset +\r\n(eccSectorSize + eccBytes) * j\r\n+ i];\r\n}\r\nfor (i = 0; i < spareFlagBytes; i++)\r\ndata[page_offset + PageDataSize + i] =\r\ndata[page_offset +\r\n(eccSectorSize + eccBytes) * j + i];\r\npage_count--;\r\n}\r\n}\r\n}\r\nu16 NAND_Multiplane_Read(u8 *read_data, u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nu32 status = PASS;\r\nu32 NumPages = page_count;\r\nu64 flash_add;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu32 ecc_done_OR_dma_comp;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nif (status == PASS) {\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\niowrite32(0x01, FlashReg + MULTIPLANE_OPERATION);\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 0x42);\r\nddma_trans(read_data, flash_add, flash_bank, 0, NumPages);\r\necc_done_OR_dma_comp = 0;\r\nwhile (1) {\r\nif (enable_ecc) {\r\nwhile (!ioread32(FlashReg + intr_status))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_ERR) {\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\nstatus = do_ecc_new(flash_bank,\r\nread_data, block, page);\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP) {\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nif (1 == ecc_done_OR_dma_comp)\r\nbreak;\r\necc_done_OR_dma_comp = 1;\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_TRANSACTION_DONE) {\r\niowrite32(\r\nINTR_STATUS0__ECC_TRANSACTION_DONE,\r\nFlashReg + intr_status);\r\nif (1 == ecc_done_OR_dma_comp)\r\nbreak;\r\necc_done_OR_dma_comp = 1;\r\n}\r\n} else {\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP))\r\n;\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nbreak;\r\n}\r\niowrite32((~INTR_STATUS0__ECC_ERR) &\r\n(~INTR_STATUS0__ECC_TRANSACTION_DONE) &\r\n(~INTR_STATUS0__DMA_CMD_COMP),\r\nFlashReg + intr_status);\r\n}\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + MULTIPLANE_OPERATION);\r\n}\r\nreturn status;\r\n}\r\nu16 NAND_Pipeline_Read_Ahead(u8 *read_data, u32 block,\r\nu16 page, u16 page_count)\r\n{\r\nu32 status = PASS;\r\nu32 NumPages = page_count;\r\nu64 flash_add;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nint ret;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nif (page_count < 2)\r\nstatus = FAIL;\r\nif (status != PASS)\r\nreturn status;\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n*DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\ninfo.state = INT_PIPELINE_READ_AHEAD;\r\ninfo.read_data = read_data;\r\ninfo.flash_bank = flash_bank;\r\ninfo.block = block;\r\ninfo.page = page;\r\ninfo.ret = PASS;\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 0x42);\r\nddma_trans(read_data, flash_add, flash_bank, 0, NumPages);\r\niowrite32(1, FlashReg + GLOBAL_INT_ENABLE);\r\nret = wait_for_completion_timeout(&info.complete, 10 * HZ);\r\nif (!ret) {\r\nprintk(KERN_ERR "Wait for completion timeout "\r\n"in %s, Line %d\n", __FILE__, __LINE__);\r\nstatus = ERR;\r\n} else {\r\nstatus = info.ret;\r\n}\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\nreturn status;\r\n}\r\nu16 NAND_Write_Page_Main(u8 *write_data, u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nu32 status = PASS;\r\nu64 flash_add;\r\nu32 intr_status = 0;\r\nu32 flash_bank;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nint ret;\r\nu8 *write_data_l;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nif (status != PASS)\r\nreturn status;\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\niowrite32(INTR_STATUS0__PROGRAM_COMP |\r\nINTR_STATUS0__PROGRAM_FAIL, FlashReg + intr_status);\r\nif (page_count > 1) {\r\nwrite_data_l = write_data;\r\nwhile (page_count > MAX_PAGES_PER_RW) {\r\nif (ioread32(FlashReg + MULTIPLANE_OPERATION))\r\nstatus = NAND_Multiplane_Write(write_data_l,\r\nblock, page, MAX_PAGES_PER_RW);\r\nelse\r\nstatus = NAND_Pipeline_Write_Ahead(\r\nwrite_data_l, block, page,\r\nMAX_PAGES_PER_RW);\r\nif (status == FAIL)\r\nreturn status;\r\nwrite_data_l += DeviceInfo.wPageDataSize *\r\nMAX_PAGES_PER_RW;\r\npage_count -= MAX_PAGES_PER_RW;\r\npage += MAX_PAGES_PER_RW;\r\n}\r\nif (ioread32(FlashReg + MULTIPLANE_OPERATION))\r\nstatus = NAND_Multiplane_Write(write_data_l,\r\nblock, page, page_count);\r\nelse\r\nstatus = NAND_Pipeline_Write_Ahead(write_data_l,\r\nblock, page, page_count);\r\nreturn status;\r\n}\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\ninfo.state = INT_WRITE_PAGE_MAIN;\r\ninfo.write_data = write_data;\r\ninfo.flash_bank = flash_bank;\r\ninfo.block = block;\r\ninfo.page = page;\r\ninfo.ret = PASS;\r\nddma_trans(write_data, flash_add, flash_bank, 1, 1);\r\niowrite32(1, FlashReg + GLOBAL_INT_ENABLE);\r\nret = wait_for_completion_timeout(&info.complete, 10 * HZ);\r\nif (!ret) {\r\nprintk(KERN_ERR "Wait for completion timeout "\r\n"in %s, Line %d\n", __FILE__, __LINE__);\r\nstatus = ERR;\r\n} else {\r\nstatus = info.ret;\r\n}\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile (ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG)\r\n;\r\nreturn status;\r\n}\r\nvoid NAND_ECC_Ctrl(int enable)\r\n{\r\nif (enable) {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Will enable ECC in %s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\niowrite32(1, FlashReg + ECC_ENABLE);\r\nenable_ecc = 1;\r\n} else {\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Will disable ECC in %s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\niowrite32(0, FlashReg + ECC_ENABLE);\r\nenable_ecc = 0;\r\n}\r\n}\r\nu16 NAND_Write_Page_Main_Spare(u8 *write_data, u32 block,\r\nu16 page, u16 page_count)\r\n{\r\nu32 status = PASS;\r\nu32 i, j, page_num = 0;\r\nu32 PageSize = DeviceInfo.wPageSize;\r\nu32 PageDataSize = DeviceInfo.wPageDataSize;\r\nu32 eccBytes = DeviceInfo.wECCBytesPerSector;\r\nu32 spareFlagBytes = DeviceInfo.wNumPageSpareFlag;\r\nu32 spareSkipBytes = DeviceInfo.wSpareSkipBytes;\r\nu64 flash_add;\r\nu32 eccSectorSize;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu8 *page_main_spare = buf_write_page_main_spare;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\neccSectorSize = ECC_SECTOR_SIZE * (DeviceInfo.wDevicesConnected);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nif (status == PASS) {\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(1, FlashReg + TRANSFER_SPARE_REG);\r\nwhile ((status != FAIL) && (page_count > 0)) {\r\nflash_add = (u64)(block %\r\n(DeviceInfo.wTotalBlocks / totalUsedBanks)) *\r\nDeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\niowrite32((u32)(MODE_01 | (flash_bank << 24) |\r\n(flash_add >>\r\nDeviceInfo.nBitsInPageDataSize)),\r\nFlashMem);\r\nif (enable_ecc) {\r\nfor (j = 0;\r\nj <\r\nDeviceInfo.wPageDataSize / eccSectorSize;\r\nj++) {\r\nfor (i = 0; i < eccSectorSize; i++)\r\npage_main_spare[(eccSectorSize +\r\neccBytes) * j +\r\ni] =\r\nwrite_data[eccSectorSize *\r\nj + i];\r\nfor (i = 0; i < eccBytes; i++)\r\npage_main_spare[(eccSectorSize +\r\neccBytes) * j +\r\neccSectorSize +\r\ni] =\r\nwrite_data[PageDataSize +\r\nspareFlagBytes +\r\neccBytes * j +\r\ni];\r\n}\r\nfor (i = 0; i < spareFlagBytes; i++)\r\npage_main_spare[(eccSectorSize +\r\neccBytes) * j + i] =\r\nwrite_data[PageDataSize + i];\r\nfor (i = PageSize - 1; i >= PageDataSize +\r\nspareSkipBytes; i--)\r\npage_main_spare[i] = page_main_spare[i -\r\nspareSkipBytes];\r\nfor (i = PageDataSize; i < PageDataSize +\r\nspareSkipBytes; i++)\r\npage_main_spare[i] = 0xff;\r\nfor (i = 0; i < PageSize / 4; i++)\r\niowrite32(\r\n*((u32 *)page_main_spare + i),\r\nFlashMem + 0x10);\r\n} else {\r\nfor (i = 0; i < PageSize / 4; i++)\r\niowrite32(*((u32 *)write_data + i),\r\nFlashMem + 0x10);\r\n}\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\n(INTR_STATUS0__PROGRAM_COMP |\r\nINTR_STATUS0__PROGRAM_FAIL)))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__PROGRAM_FAIL)\r\nstatus = FAIL;\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\npage_num++;\r\npage_count--;\r\nwrite_data += PageSize;\r\n}\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\n}\r\nreturn status;\r\n}\r\nu16 NAND_Read_Page_Main_Spare(u8 *read_data, u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nu32 status = PASS;\r\nu32 i, j;\r\nu64 flash_add = 0;\r\nu32 PageSize = DeviceInfo.wPageSize;\r\nu32 PageDataSize = DeviceInfo.wPageDataSize;\r\nu32 PageSpareSize = DeviceInfo.wPageSpareSize;\r\nu32 eccBytes = DeviceInfo.wECCBytesPerSector;\r\nu32 spareFlagBytes = DeviceInfo.wNumPageSpareFlag;\r\nu32 spareSkipBytes = DeviceInfo.wSpareSkipBytes;\r\nu32 eccSectorSize;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu8 *read_data_l = read_data;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu8 *page_main_spare = buf_read_page_main_spare;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\neccSectorSize = ECC_SECTOR_SIZE * (DeviceInfo.wDevicesConnected);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nif (status == PASS) {\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(1, FlashReg + TRANSFER_SPARE_REG);\r\niowrite32(ioread32(FlashReg + intr_status),\r\nFlashReg + intr_status);\r\nwhile ((status != FAIL) && (page_count > 0)) {\r\nflash_add = (u64)(block %\r\n(DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)),\r\n0x43);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)),\r\n0x2000 | page_count);\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__LOAD_COMP))\r\n;\r\niowrite32((u32)(MODE_01 | (flash_bank << 24) |\r\n(flash_add >>\r\nDeviceInfo.nBitsInPageDataSize)),\r\nFlashMem);\r\nfor (i = 0; i < PageSize / 4; i++)\r\n*(((u32 *)page_main_spare) + i) =\r\nioread32(FlashMem + 0x10);\r\nif (enable_ecc) {\r\nfor (i = PageDataSize; i < PageSize -\r\nspareSkipBytes; i++)\r\npage_main_spare[i] = page_main_spare[i +\r\nspareSkipBytes];\r\nfor (j = 0;\r\nj < DeviceInfo.wPageDataSize / eccSectorSize;\r\nj++) {\r\nfor (i = 0; i < eccSectorSize; i++)\r\nread_data_l[eccSectorSize * j +\r\ni] =\r\npage_main_spare[\r\n(eccSectorSize +\r\neccBytes) * j + i];\r\nfor (i = 0; i < eccBytes; i++)\r\nread_data_l[PageDataSize +\r\nspareFlagBytes +\r\neccBytes * j + i] =\r\npage_main_spare[\r\n(eccSectorSize +\r\neccBytes) * j +\r\neccSectorSize + i];\r\n}\r\nfor (i = 0; i < spareFlagBytes; i++)\r\nread_data_l[PageDataSize + i] =\r\npage_main_spare[(eccSectorSize +\r\neccBytes) * j + i];\r\n} else {\r\nfor (i = 0; i < (PageDataSize + PageSpareSize);\r\ni++)\r\nread_data_l[i] = page_main_spare[i];\r\n}\r\nif (enable_ecc) {\r\nwhile (!(ioread32(FlashReg + intr_status) &\r\n(INTR_STATUS0__ECC_TRANSACTION_DONE |\r\nINTR_STATUS0__ECC_ERR)))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_ERR) {\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\nstatus = do_ecc_new(flash_bank,\r\nread_data, block, page);\r\n}\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_TRANSACTION_DONE &\r\nINTR_STATUS0__ECC_ERR) {\r\niowrite32(INTR_STATUS0__ECC_ERR |\r\nINTR_STATUS0__ECC_TRANSACTION_DONE,\r\nFlashReg + intr_status);\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_TRANSACTION_DONE) {\r\niowrite32(\r\nINTR_STATUS0__ECC_TRANSACTION_DONE,\r\nFlashReg + intr_status);\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_ERR) {\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\n}\r\n}\r\npage++;\r\npage_count--;\r\nread_data_l += PageSize;\r\n}\r\n}\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 0x42);\r\nreturn status;\r\n}\r\nu16 NAND_Pipeline_Write_Ahead(u8 *write_data, u32 block,\r\nu16 page, u16 page_count)\r\n{\r\nu16 status = PASS;\r\nu32 NumPages = page_count;\r\nu64 flash_add;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nint ret;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nif (page_count < 2)\r\nstatus = FAIL;\r\nif (status != PASS)\r\nreturn status;\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\ninfo.state = INT_PIPELINE_WRITE_AHEAD;\r\ninfo.write_data = write_data;\r\ninfo.flash_bank = flash_bank;\r\ninfo.block = block;\r\ninfo.page = page;\r\ninfo.ret = PASS;\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 0x42);\r\nddma_trans(write_data, flash_add, flash_bank, 1, NumPages);\r\niowrite32(1, FlashReg + GLOBAL_INT_ENABLE);\r\nret = wait_for_completion_timeout(&info.complete, 10 * HZ);\r\nif (!ret) {\r\nprintk(KERN_ERR "Wait for completion timeout "\r\n"in %s, Line %d\n", __FILE__, __LINE__);\r\nstatus = ERR;\r\n} else {\r\nstatus = info.ret;\r\n}\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\nreturn status;\r\n}\r\nu16 NAND_Multiplane_Write(u8 *write_data, u32 block, u16 page,\r\nu16 page_count)\r\n{\r\nu16 status = PASS;\r\nu32 NumPages = page_count;\r\nu64 flash_add;\r\nu32 flash_bank;\r\nu32 intr_status = 0;\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu16 status2 = PASS;\r\nu32 t;\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nstatus = Boundary_Check_Block_Page(block, page, page_count);\r\nif (status != PASS)\r\nreturn status;\r\nflash_add = (u64)(block % (DeviceInfo.wTotalBlocks / totalUsedBanks))\r\n* DeviceInfo.wBlockDataSize +\r\n(u64)page * DeviceInfo.wPageDataSize;\r\nflash_bank = block / (DeviceInfo.wTotalBlocks / totalUsedBanks);\r\nintr_status = intr_status_addresses[flash_bank];\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\niowrite32(0x01, FlashReg + MULTIPLANE_OPERATION);\r\niowrite32(1, FlashReg + DMA_ENABLE);\r\nwhile (!(ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + TRANSFER_SPARE_REG);\r\nindex_addr((u32)(MODE_10 | (flash_bank << 24) |\r\n(flash_add >> DeviceInfo.nBitsInPageDataSize)), 0x42);\r\nddma_trans(write_data, flash_add, flash_bank, 1, NumPages);\r\nwhile (1) {\r\nwhile (!ioread32(FlashReg + intr_status))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP) {\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nstatus = PASS;\r\nif (status2 == FAIL)\r\nstatus = FAIL;\r\nbreak;\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__PROGRAM_FAIL) {\r\nstatus2 = FAIL;\r\nstatus = FAIL;\r\nt = ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__PROGRAM_FAIL;\r\niowrite32(t, FlashReg + intr_status);\r\n} else {\r\niowrite32((~INTR_STATUS0__PROGRAM_FAIL) &\r\n(~INTR_STATUS0__DMA_CMD_COMP),\r\nFlashReg + intr_status);\r\n}\r\n}\r\niowrite32(ioread32(FlashReg + intr_status), FlashReg + intr_status);\r\niowrite32(0, FlashReg + DMA_ENABLE);\r\nwhile ((ioread32(FlashReg + DMA_ENABLE) & DMA_ENABLE__FLAG))\r\n;\r\niowrite32(0, FlashReg + MULTIPLANE_OPERATION);\r\nreturn status;\r\n}\r\nstatic irqreturn_t cdma_isr(int irq, void *dev_id)\r\n{\r\nstruct mrst_nand_info *dev = dev_id;\r\nint first_failed_cmd;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nif (!is_cdma_interrupt())\r\nreturn IRQ_NONE;\r\niowrite32(0, FlashReg + GLOBAL_INT_ENABLE);\r\nGLOB_FTL_Event_Status(&first_failed_cmd);\r\ncomplete(&dev->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void handle_nand_int_read(struct mrst_nand_info *dev)\r\n{\r\nu32 intr_status_addresses[4] = {INTR_STATUS0,\r\nINTR_STATUS1, INTR_STATUS2, INTR_STATUS3};\r\nu32 intr_status;\r\nu32 ecc_done_OR_dma_comp = 0;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\ndev->ret = PASS;\r\nintr_status = intr_status_addresses[dev->flash_bank];\r\nwhile (1) {\r\nif (enable_ecc) {\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_ERR) {\r\niowrite32(INTR_STATUS0__ECC_ERR,\r\nFlashReg + intr_status);\r\ndev->ret = do_ecc_new(dev->flash_bank,\r\ndev->read_data,\r\ndev->block, dev->page);\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP) {\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nif (1 == ecc_done_OR_dma_comp)\r\nbreak;\r\necc_done_OR_dma_comp = 1;\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__ECC_TRANSACTION_DONE) {\r\niowrite32(INTR_STATUS0__ECC_TRANSACTION_DONE,\r\nFlashReg + intr_status);\r\nif (1 == ecc_done_OR_dma_comp)\r\nbreak;\r\necc_done_OR_dma_comp = 1;\r\n}\r\n} else {\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP) {\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nbreak;\r\n} else {\r\nprintk(KERN_ERR "Illegal INTS "\r\n"(offset addr 0x%x) value: 0x%x\n",\r\nintr_status,\r\nioread32(FlashReg + intr_status));\r\n}\r\n}\r\niowrite32((~INTR_STATUS0__ECC_ERR) &\r\n(~INTR_STATUS0__ECC_TRANSACTION_DONE) &\r\n(~INTR_STATUS0__DMA_CMD_COMP),\r\nFlashReg + intr_status);\r\n}\r\n}\r\nstatic void handle_nand_int_write(struct mrst_nand_info *dev)\r\n{\r\nu32 intr_status;\r\nu32 intr[4] = {INTR_STATUS0, INTR_STATUS1,\r\nINTR_STATUS2, INTR_STATUS3};\r\nint status = PASS;\r\nnand_dbg_print(NAND_DBG_DEBUG, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\ndev->ret = PASS;\r\nintr_status = intr[dev->flash_bank];\r\nwhile (1) {\r\nwhile (!ioread32(FlashReg + intr_status))\r\n;\r\nif (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__DMA_CMD_COMP) {\r\niowrite32(INTR_STATUS0__DMA_CMD_COMP,\r\nFlashReg + intr_status);\r\nif (FAIL == status)\r\ndev->ret = FAIL;\r\nbreak;\r\n} else if (ioread32(FlashReg + intr_status) &\r\nINTR_STATUS0__PROGRAM_FAIL) {\r\nstatus = FAIL;\r\niowrite32(INTR_STATUS0__PROGRAM_FAIL,\r\nFlashReg + intr_status);\r\n} else {\r\niowrite32((~INTR_STATUS0__PROGRAM_FAIL) &\r\n(~INTR_STATUS0__DMA_CMD_COMP),\r\nFlashReg + intr_status);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t ddma_isr(int irq, void *dev_id)\r\n{\r\nstruct mrst_nand_info *dev = dev_id;\r\nu32 int_mask, ints0, ints1, ints2, ints3, ints_offset;\r\nu32 intr[4] = {INTR_STATUS0, INTR_STATUS1,\r\nINTR_STATUS2, INTR_STATUS3};\r\nint_mask = INTR_STATUS0__DMA_CMD_COMP |\r\nINTR_STATUS0__ECC_TRANSACTION_DONE |\r\nINTR_STATUS0__ECC_ERR |\r\nINTR_STATUS0__PROGRAM_FAIL |\r\nINTR_STATUS0__ERASE_FAIL;\r\nints0 = ioread32(FlashReg + INTR_STATUS0);\r\nints1 = ioread32(FlashReg + INTR_STATUS1);\r\nints2 = ioread32(FlashReg + INTR_STATUS2);\r\nints3 = ioread32(FlashReg + INTR_STATUS3);\r\nints_offset = intr[dev->flash_bank];\r\nnand_dbg_print(NAND_DBG_DEBUG,\r\n"INTR0: 0x%x, INTR1: 0x%x, INTR2: 0x%x, INTR3: 0x%x, "\r\n"DMA_INTR: 0x%x, "\r\n"dev->state: 0x%x, dev->flash_bank: %d\n",\r\nints0, ints1, ints2, ints3,\r\nioread32(FlashReg + DMA_INTR),\r\ndev->state, dev->flash_bank);\r\nif (!(ioread32(FlashReg + ints_offset) & int_mask)) {\r\niowrite32(ints0, FlashReg + INTR_STATUS0);\r\niowrite32(ints1, FlashReg + INTR_STATUS1);\r\niowrite32(ints2, FlashReg + INTR_STATUS2);\r\niowrite32(ints3, FlashReg + INTR_STATUS3);\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"ddma_isr: Invalid interrupt for NAND controller. "\r\n"Ignore it\n");\r\nreturn IRQ_NONE;\r\n}\r\nswitch (dev->state) {\r\ncase INT_READ_PAGE_MAIN:\r\ncase INT_PIPELINE_READ_AHEAD:\r\niowrite32(0, FlashReg + GLOBAL_INT_ENABLE);\r\nhandle_nand_int_read(dev);\r\nbreak;\r\ncase INT_WRITE_PAGE_MAIN:\r\ncase INT_PIPELINE_WRITE_AHEAD:\r\niowrite32(0, FlashReg + GLOBAL_INT_ENABLE);\r\nhandle_nand_int_write(dev);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "ddma_isr - Illegal state: 0x%x\n",\r\ndev->state);\r\nreturn IRQ_NONE;\r\n}\r\ndev->state = INT_IDLE_STATE;\r\ncomplete(&dev->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nand_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint ret = -ENODEV;\r\nunsigned long csr_base;\r\nunsigned long csr_len;\r\nstruct mrst_nand_info *pndev = &info;\r\nu32 int_mask;\r\nret = pci_enable_device(dev);\r\nif (ret) {\r\nprintk(KERN_ERR "Spectra: pci_enable_device failed.\n");\r\nreturn ret;\r\n}\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nFlashReg = ioremap_nocache(GLOB_HWCTL_REG_BASE,\r\nGLOB_HWCTL_REG_SIZE);\r\nif (!FlashReg) {\r\nprintk(KERN_ERR "Spectra: ioremap_nocache failed!");\r\ngoto failed_disable;\r\n}\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Spectra: Remapped reg base address: "\r\n"0x%p, len: %d\n",\r\nFlashReg, GLOB_HWCTL_REG_SIZE);\r\nFlashMem = ioremap_nocache(GLOB_HWCTL_MEM_BASE,\r\nGLOB_HWCTL_MEM_SIZE);\r\nif (!FlashMem) {\r\nprintk(KERN_ERR "Spectra: ioremap_nocache failed!");\r\niounmap(FlashReg);\r\ngoto failed_disable;\r\n}\r\nnand_dbg_print(NAND_DBG_WARN,\r\n"Spectra: Remapped flash base address: "\r\n"0x%p, len: %d\n",\r\n(void *)FlashMem, GLOB_HWCTL_MEM_SIZE);\r\nnand_dbg_print(NAND_DBG_DEBUG, "Dump timing register values:"\r\n"acc_clks: %d, re_2_we: %d, we_2_re: %d,"\r\n"addr_2_data: %d, rdwr_en_lo_cnt: %d, "\r\n"rdwr_en_hi_cnt: %d, cs_setup_cnt: %d\n",\r\nioread32(FlashReg + ACC_CLKS),\r\nioread32(FlashReg + RE_2_WE),\r\nioread32(FlashReg + WE_2_RE),\r\nioread32(FlashReg + ADDR_2_DATA),\r\nioread32(FlashReg + RDWR_EN_LO_CNT),\r\nioread32(FlashReg + RDWR_EN_HI_CNT),\r\nioread32(FlashReg + CS_SETUP_CNT));\r\nNAND_Flash_Reset();\r\niowrite32(0, FlashReg + GLOBAL_INT_ENABLE);\r\n#if CMD_DMA\r\ninfo.pcmds_num = 0;\r\ninfo.flash_bank = 0;\r\ninfo.cdma_num = 0;\r\nint_mask = (DMA_INTR__DESC_COMP_CHANNEL0 |\r\nDMA_INTR__DESC_COMP_CHANNEL1 |\r\nDMA_INTR__DESC_COMP_CHANNEL2 |\r\nDMA_INTR__DESC_COMP_CHANNEL3 |\r\nDMA_INTR__MEMCOPY_DESC_COMP);\r\niowrite32(int_mask, FlashReg + DMA_INTR_EN);\r\niowrite32(0xFFFF, FlashReg + DMA_INTR);\r\nint_mask = (INTR_STATUS0__ECC_ERR |\r\nINTR_STATUS0__PROGRAM_FAIL |\r\nINTR_STATUS0__ERASE_FAIL);\r\n#else\r\nint_mask = INTR_STATUS0__DMA_CMD_COMP |\r\nINTR_STATUS0__ECC_TRANSACTION_DONE |\r\nINTR_STATUS0__ECC_ERR |\r\nINTR_STATUS0__PROGRAM_FAIL |\r\nINTR_STATUS0__ERASE_FAIL;\r\n#endif\r\niowrite32(int_mask, FlashReg + INTR_EN0);\r\niowrite32(int_mask, FlashReg + INTR_EN1);\r\niowrite32(int_mask, FlashReg + INTR_EN2);\r\niowrite32(int_mask, FlashReg + INTR_EN3);\r\niowrite32(0xFFFF, FlashReg + INTR_STATUS0);\r\niowrite32(0xFFFF, FlashReg + INTR_STATUS1);\r\niowrite32(0xFFFF, FlashReg + INTR_STATUS2);\r\niowrite32(0xFFFF, FlashReg + INTR_STATUS3);\r\niowrite32(0x0F, FlashReg + RB_PIN_ENABLED);\r\niowrite32(CHIP_EN_DONT_CARE__FLAG, FlashReg + CHIP_ENABLE_DONT_CARE);\r\niowrite32(0, FlashReg + TWO_ROW_ADDR_CYCLES);\r\niowrite32(1, FlashReg + ECC_ENABLE);\r\nenable_ecc = 1;\r\npci_set_master(dev);\r\npndev->dev = dev;\r\ncsr_base = pci_resource_start(dev, 0);\r\nif (!csr_base) {\r\nprintk(KERN_ERR "Spectra: pci_resource_start failed!\n");\r\nret = -ENODEV;\r\ngoto failed_req_csr;\r\n}\r\ncsr_len = pci_resource_len(dev, 0);\r\nif (!csr_len) {\r\nprintk(KERN_ERR "Spectra: pci_resource_len failed!\n");\r\nret = -ENODEV;\r\ngoto failed_req_csr;\r\n}\r\nret = pci_request_regions(dev, SPECTRA_NAND_NAME);\r\nif (ret) {\r\nprintk(KERN_ERR "Spectra: Unable to request "\r\n"memory region\n");\r\ngoto failed_req_csr;\r\n}\r\npndev->ioaddr = ioremap_nocache(csr_base, csr_len);\r\nif (!pndev->ioaddr) {\r\nprintk(KERN_ERR "Spectra: Unable to remap memory region\n");\r\nret = -ENOMEM;\r\ngoto failed_remap_csr;\r\n}\r\nnand_dbg_print(NAND_DBG_DEBUG, "Spectra: CSR 0x%08lx -> 0x%p (0x%lx)\n",\r\ncsr_base, pndev->ioaddr, csr_len);\r\ninit_completion(&pndev->complete);\r\nnand_dbg_print(NAND_DBG_DEBUG, "Spectra: IRQ %d\n", dev->irq);\r\n#if CMD_DMA\r\nif (request_irq(dev->irq, cdma_isr, IRQF_SHARED,\r\nSPECTRA_NAND_NAME, &info)) {\r\nprintk(KERN_ERR "Spectra: Unable to allocate IRQ\n");\r\nret = -ENODEV;\r\niounmap(pndev->ioaddr);\r\ngoto failed_remap_csr;\r\n}\r\n#else\r\nif (request_irq(dev->irq, ddma_isr, IRQF_SHARED,\r\nSPECTRA_NAND_NAME, &info)) {\r\nprintk(KERN_ERR "Spectra: Unable to allocate IRQ\n");\r\nret = -ENODEV;\r\niounmap(pndev->ioaddr);\r\ngoto failed_remap_csr;\r\n}\r\n#endif\r\npci_set_drvdata(dev, pndev);\r\nret = GLOB_LLD_Read_Device_ID();\r\nif (ret) {\r\niounmap(pndev->ioaddr);\r\ngoto failed_remap_csr;\r\n}\r\nret = register_spectra_ftl();\r\nif (ret) {\r\niounmap(pndev->ioaddr);\r\ngoto failed_remap_csr;\r\n}\r\nreturn 0;\r\nfailed_remap_csr:\r\npci_release_regions(dev);\r\nfailed_req_csr:\r\niounmap(FlashMem);\r\niounmap(FlashReg);\r\nfailed_disable:\r\npci_disable_device(dev);\r\nreturn ret;\r\n}\r\nstatic void nand_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct mrst_nand_info *pndev = pci_get_drvdata(dev);\r\nnand_dbg_print(NAND_DBG_WARN, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\n#if CMD_DMA\r\nfree_irq(dev->irq, pndev);\r\n#endif\r\niounmap(pndev->ioaddr);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\n}\r\nint NAND_Flash_Init(void)\r\n{\r\nint retval;\r\nnand_dbg_print(NAND_DBG_TRACE, "%s, Line %d, Function: %s\n",\r\n__FILE__, __LINE__, __func__);\r\nretval = pci_register_driver(&nand_pci_driver);\r\nif (retval)\r\nreturn -ENOMEM;\r\nreturn PASS;\r\n}\r\nint nand_release_spectra(void)\r\n{\r\npci_unregister_driver(&nand_pci_driver);\r\niounmap(FlashMem);\r\niounmap(FlashReg);\r\nreturn 0;\r\n}
