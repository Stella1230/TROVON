static void sym2_setup_params(void)\r\n{\r\nchar *p = excl_string;\r\nint xi = 0;\r\nwhile (p && (xi < 8)) {\r\nchar *next_p;\r\nint val = (int) simple_strtoul(p, &next_p, 0);\r\nsym_driver_setup.excludes[xi++] = val;\r\np = next_p;\r\n}\r\nif (safe_string) {\r\nif (*safe_string == 'y') {\r\nsym_driver_setup.max_tag = 0;\r\nsym_driver_setup.burst_order = 0;\r\nsym_driver_setup.scsi_led = 0;\r\nsym_driver_setup.scsi_diff = 1;\r\nsym_driver_setup.irq_mode = 0;\r\nsym_driver_setup.scsi_bus_check = 2;\r\nsym_driver_setup.host_id = 7;\r\nsym_driver_setup.verbose = 2;\r\nsym_driver_setup.settle_delay = 10;\r\nsym_driver_setup.use_nvram = 1;\r\n} else if (*safe_string != 'n') {\r\nprintk(KERN_WARNING NAME53C8XX "Ignoring parameter %s"\r\n" passed to safe option", safe_string);\r\n}\r\n}\r\n}\r\nvoid sym_xpt_done(struct sym_hcb *np, struct scsi_cmnd *cmd)\r\n{\r\nstruct sym_ucmd *ucmd = SYM_UCMD_PTR(cmd);\r\nBUILD_BUG_ON(sizeof(struct scsi_pointer) < sizeof(struct sym_ucmd));\r\nif (ucmd->eh_done)\r\ncomplete(ucmd->eh_done);\r\nscsi_dma_unmap(cmd);\r\ncmd->scsi_done(cmd);\r\n}\r\nvoid sym_xpt_async_bus_reset(struct sym_hcb *np)\r\n{\r\nprintf_notice("%s: SCSI BUS has been reset.\n", sym_name(np));\r\nnp->s.settle_time = jiffies + sym_driver_setup.settle_delay * HZ;\r\nnp->s.settle_time_valid = 1;\r\nif (sym_verbose >= 2)\r\nprintf_info("%s: command processing suspended for %d seconds\n",\r\nsym_name(np), sym_driver_setup.settle_delay);\r\n}\r\nstatic int sym_xerr_cam_status(int cam_status, int x_status)\r\n{\r\nif (x_status) {\r\nif (x_status & XE_PARITY_ERR)\r\ncam_status = DID_PARITY;\r\nelse if (x_status &(XE_EXTRA_DATA|XE_SODL_UNRUN|XE_SWIDE_OVRUN))\r\ncam_status = DID_ERROR;\r\nelse if (x_status & XE_BAD_PHASE)\r\ncam_status = DID_ERROR;\r\nelse\r\ncam_status = DID_ERROR;\r\n}\r\nreturn cam_status;\r\n}\r\nvoid sym_set_cam_result_error(struct sym_hcb *np, struct sym_ccb *cp, int resid)\r\n{\r\nstruct scsi_cmnd *cmd = cp->cmd;\r\nu_int cam_status, scsi_status, drv_status;\r\ndrv_status = 0;\r\ncam_status = DID_OK;\r\nscsi_status = cp->ssss_status;\r\nif (cp->host_flags & HF_SENSE) {\r\nscsi_status = cp->sv_scsi_status;\r\nresid = cp->sv_resid;\r\nif (sym_verbose && cp->sv_xerr_status)\r\nsym_print_xerr(cmd, cp->sv_xerr_status);\r\nif (cp->host_status == HS_COMPLETE &&\r\ncp->ssss_status == S_GOOD &&\r\ncp->xerr_status == 0) {\r\ncam_status = sym_xerr_cam_status(DID_OK,\r\ncp->sv_xerr_status);\r\ndrv_status = DRIVER_SENSE;\r\nmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nmemcpy(cmd->sense_buffer, cp->sns_bbuf,\r\nmin(SCSI_SENSE_BUFFERSIZE, SYM_SNS_BBUF_LEN));\r\n#if 0\r\nif (1) {\r\nu_char *p;\r\np = (u_char *) cmd->sense_data;\r\nif (p[0]==0x70 && p[2]==0x6 && p[12]==0x29)\r\nsym_clear_tasks(np, DID_ABORT,\r\ncp->target,cp->lun, -1);\r\n}\r\n#endif\r\n} else {\r\nsym_reset_scsi_target(np, cmd->device->id);\r\ncam_status = DID_ERROR;\r\n}\r\n} else if (cp->host_status == HS_COMPLETE)\r\ncam_status = DID_OK;\r\nelse if (cp->host_status == HS_SEL_TIMEOUT)\r\ncam_status = DID_NO_CONNECT;\r\nelse if (cp->host_status == HS_UNEXPECTED)\r\ncam_status = DID_ERROR;\r\nelse {\r\nif (sym_verbose) {\r\nsym_print_addr(cmd, "COMMAND FAILED (%x %x %x).\n",\r\ncp->host_status, cp->ssss_status,\r\ncp->xerr_status);\r\n}\r\ncam_status = sym_xerr_cam_status(DID_ERROR, cp->xerr_status);\r\n}\r\nscsi_set_resid(cmd, resid);\r\ncmd->result = (drv_status << 24) + (cam_status << 16) + scsi_status;\r\n}\r\nstatic int sym_scatter(struct sym_hcb *np, struct sym_ccb *cp, struct scsi_cmnd *cmd)\r\n{\r\nint segment;\r\nint use_sg;\r\ncp->data_len = 0;\r\nuse_sg = scsi_dma_map(cmd);\r\nif (use_sg > 0) {\r\nstruct scatterlist *sg;\r\nstruct sym_tcb *tp = &np->target[cp->target];\r\nstruct sym_tblmove *data;\r\nif (use_sg > SYM_CONF_MAX_SG) {\r\nscsi_dma_unmap(cmd);\r\nreturn -1;\r\n}\r\ndata = &cp->phys.data[SYM_CONF_MAX_SG - use_sg];\r\nscsi_for_each_sg(cmd, sg, use_sg, segment) {\r\ndma_addr_t baddr = sg_dma_address(sg);\r\nunsigned int len = sg_dma_len(sg);\r\nif ((len & 1) && (tp->head.wval & EWS)) {\r\nlen++;\r\ncp->odd_byte_adjustment++;\r\n}\r\nsym_build_sge(np, &data[segment], baddr, len);\r\ncp->data_len += len;\r\n}\r\n} else {\r\nsegment = -2;\r\n}\r\nreturn segment;\r\n}\r\nstatic int sym_queue_command(struct sym_hcb *np, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct sym_tcb *tp;\r\nstruct sym_lcb *lp;\r\nstruct sym_ccb *cp;\r\nint order;\r\ntp = &np->target[sdev->id];\r\nlp = sym_lp(tp, sdev->lun);\r\norder = (lp && lp->s.reqtags) ? M_SIMPLE_TAG : 0;\r\ncp = sym_get_ccb(np, cmd, order);\r\nif (!cp)\r\nreturn 1;\r\nsym_queue_scsiio(np, cmd, cp);\r\nreturn 0;\r\n}\r\nstatic inline int sym_setup_cdb(struct sym_hcb *np, struct scsi_cmnd *cmd, struct sym_ccb *cp)\r\n{\r\nmemcpy(cp->cdb_buf, cmd->cmnd, cmd->cmd_len);\r\ncp->phys.cmd.addr = CCB_BA(cp, cdb_buf[0]);\r\ncp->phys.cmd.size = cpu_to_scr(cmd->cmd_len);\r\nreturn 0;\r\n}\r\nint sym_setup_data_and_start(struct sym_hcb *np, struct scsi_cmnd *cmd, struct sym_ccb *cp)\r\n{\r\nu32 lastp, goalp;\r\nint dir;\r\nif (sym_setup_cdb(np, cmd, cp))\r\ngoto out_abort;\r\ndir = cmd->sc_data_direction;\r\nif (dir != DMA_NONE) {\r\ncp->segments = sym_scatter(np, cp, cmd);\r\nif (cp->segments < 0) {\r\nsym_set_cam_status(cmd, DID_ERROR);\r\ngoto out_abort;\r\n}\r\nif (!cp->segments)\r\ndir = DMA_NONE;\r\n} else {\r\ncp->data_len = 0;\r\ncp->segments = 0;\r\n}\r\nswitch (dir) {\r\ncase DMA_BIDIRECTIONAL:\r\nscmd_printk(KERN_INFO, cmd, "got DMA_BIDIRECTIONAL command");\r\nsym_set_cam_status(cmd, DID_ERROR);\r\ngoto out_abort;\r\ncase DMA_TO_DEVICE:\r\ngoalp = SCRIPTA_BA(np, data_out2) + 8;\r\nlastp = goalp - 8 - (cp->segments * (2*4));\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\ncp->host_flags |= HF_DATA_IN;\r\ngoalp = SCRIPTA_BA(np, data_in2) + 8;\r\nlastp = goalp - 8 - (cp->segments * (2*4));\r\nbreak;\r\ncase DMA_NONE:\r\ndefault:\r\nlastp = goalp = SCRIPTB_BA(np, no_data);\r\nbreak;\r\n}\r\ncp->phys.head.lastp = cpu_to_scr(lastp);\r\ncp->phys.head.savep = cpu_to_scr(lastp);\r\ncp->startp = cp->phys.head.savep;\r\ncp->goalp = cpu_to_scr(goalp);\r\n#if 0\r\nswitch (cp->cdb_buf[0]) {\r\ncase 0x0A: case 0x2A: case 0xAA:\r\npanic("XXXXXXXXXXXXX WRITE NOT YET ALLOWED XXXXXXXXXXXXXX\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#endif\r\nsym_put_start_queue(np, cp);\r\nreturn 0;\r\nout_abort:\r\nsym_free_ccb(np, cp);\r\nsym_xpt_done(np, cmd);\r\nreturn 0;\r\n}\r\nstatic void sym_timer(struct sym_hcb *np)\r\n{\r\nunsigned long thistime = jiffies;\r\nnp->s.timer.expires = thistime + SYM_CONF_TIMER_INTERVAL;\r\nadd_timer(&np->s.timer);\r\nif (np->s.settle_time_valid) {\r\nif (time_before_eq(np->s.settle_time, thistime)) {\r\nif (sym_verbose >= 2 )\r\nprintk("%s: command processing resumed\n",\r\nsym_name(np));\r\nnp->s.settle_time_valid = 0;\r\n}\r\nreturn;\r\n}\r\nif (np->s.lasttime + 4*HZ < thistime) {\r\nnp->s.lasttime = thistime;\r\n}\r\n#ifdef SYM_CONF_PCIQ_MAY_MISS_COMPLETIONS\r\nsym_wakeup_done(np);\r\n#endif\r\n}\r\nvoid sym_log_bus_error(struct Scsi_Host *shost)\r\n{\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nstruct pci_dev *pdev = sym_data->pdev;\r\nunsigned short pci_sts;\r\npci_read_config_word(pdev, PCI_STATUS, &pci_sts);\r\nif (pci_sts & 0xf900) {\r\npci_write_config_word(pdev, PCI_STATUS, pci_sts);\r\nshost_printk(KERN_WARNING, shost,\r\n"PCI bus error: status = 0x%04x\n", pci_sts & 0xf900);\r\n}\r\n}\r\nstatic int sym53c8xx_queue_command_lck(struct scsi_cmnd *cmd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct sym_hcb *np = SYM_SOFTC_PTR(cmd);\r\nstruct sym_ucmd *ucp = SYM_UCMD_PTR(cmd);\r\nint sts = 0;\r\ncmd->scsi_done = done;\r\nmemset(ucp, 0, sizeof(*ucp));\r\nif (np->s.settle_time_valid && cmd->request->timeout) {\r\nunsigned long tlimit = jiffies + cmd->request->timeout;\r\ntlimit -= SYM_CONF_TIMER_INTERVAL*2;\r\nif (time_after(np->s.settle_time, tlimit)) {\r\nnp->s.settle_time = tlimit;\r\n}\r\n}\r\nif (np->s.settle_time_valid)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nsts = sym_queue_command(np, cmd);\r\nif (sts)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nreturn 0;\r\n}\r\nvoid sym53c8xx_timer(unsigned long npref)\r\n{\r\nstruct sym_hcb *np = (struct sym_hcb *)npref;\r\nunsigned long flags;\r\nspin_lock_irqsave(np->s.host->host_lock, flags);\r\nsym_timer(np);\r\nspin_unlock_irqrestore(np->s.host->host_lock, flags);\r\n}\r\nstatic int sym_eh_handler(int op, char *opname, struct scsi_cmnd *cmd)\r\n{\r\nstruct sym_ucmd *ucmd = SYM_UCMD_PTR(cmd);\r\nstruct Scsi_Host *shost = cmd->device->host;\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nstruct pci_dev *pdev = sym_data->pdev;\r\nstruct sym_hcb *np = sym_data->ncb;\r\nSYM_QUEHEAD *qp;\r\nint cmd_queued = 0;\r\nint sts = -1;\r\nstruct completion eh_done;\r\nscmd_printk(KERN_WARNING, cmd, "%s operation started\n", opname);\r\n#define WAIT_FOR_PCI_RECOVERY 35\r\nif (pci_channel_offline(pdev)) {\r\nint finished_reset = 0;\r\ninit_completion(&eh_done);\r\nspin_lock_irq(shost->host_lock);\r\nif (pci_channel_offline(pdev)) {\r\nBUG_ON(sym_data->io_reset);\r\nsym_data->io_reset = &eh_done;\r\n} else {\r\nfinished_reset = 1;\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\nif (!finished_reset)\r\nfinished_reset = wait_for_completion_timeout\r\n(sym_data->io_reset,\r\nWAIT_FOR_PCI_RECOVERY*HZ);\r\nspin_lock_irq(shost->host_lock);\r\nsym_data->io_reset = NULL;\r\nspin_unlock_irq(shost->host_lock);\r\nif (!finished_reset)\r\nreturn SCSI_FAILED;\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\r\nstruct sym_ccb *cp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\nif (cp->cmd == cmd) {\r\ncmd_queued = 1;\r\nbreak;\r\n}\r\n}\r\nsts = -1;\r\nswitch(op) {\r\ncase SYM_EH_ABORT:\r\nsts = sym_abort_scsiio(np, cmd, 1);\r\nbreak;\r\ncase SYM_EH_DEVICE_RESET:\r\nsts = sym_reset_scsi_target(np, cmd->device->id);\r\nbreak;\r\ncase SYM_EH_BUS_RESET:\r\nsym_reset_scsi_bus(np, 1);\r\nsts = 0;\r\nbreak;\r\ncase SYM_EH_HOST_RESET:\r\nsym_reset_scsi_bus(np, 0);\r\nsym_start_up(shost, 1);\r\nsts = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (sts)\r\ncmd_queued = 0;\r\nif (cmd_queued) {\r\ninit_completion(&eh_done);\r\nucmd->eh_done = &eh_done;\r\nspin_unlock_irq(shost->host_lock);\r\nif (!wait_for_completion_timeout(&eh_done, 5*HZ)) {\r\nucmd->eh_done = NULL;\r\nsts = -2;\r\n}\r\n} else {\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\ndev_warn(&cmd->device->sdev_gendev, "%s operation %s.\n", opname,\r\nsts==0 ? "complete" :sts==-2 ? "timed-out" : "failed");\r\nreturn sts ? SCSI_FAILED : SCSI_SUCCESS;\r\n}\r\nstatic int sym53c8xx_eh_abort_handler(struct scsi_cmnd *cmd)\r\n{\r\nreturn sym_eh_handler(SYM_EH_ABORT, "ABORT", cmd);\r\n}\r\nstatic int sym53c8xx_eh_device_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nreturn sym_eh_handler(SYM_EH_DEVICE_RESET, "DEVICE RESET", cmd);\r\n}\r\nstatic int sym53c8xx_eh_bus_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nreturn sym_eh_handler(SYM_EH_BUS_RESET, "BUS RESET", cmd);\r\n}\r\nstatic int sym53c8xx_eh_host_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nreturn sym_eh_handler(SYM_EH_HOST_RESET, "HOST RESET", cmd);\r\n}\r\nstatic void sym_tune_dev_queuing(struct sym_tcb *tp, int lun, u_short reqtags)\r\n{\r\nstruct sym_lcb *lp = sym_lp(tp, lun);\r\nu_short oldtags;\r\nif (!lp)\r\nreturn;\r\noldtags = lp->s.reqtags;\r\nif (reqtags > lp->s.scdev_depth)\r\nreqtags = lp->s.scdev_depth;\r\nlp->s.reqtags = reqtags;\r\nif (reqtags != oldtags) {\r\ndev_info(&tp->starget->dev,\r\n"tagged command queuing %s, command queue depth %d.\n",\r\nlp->s.reqtags ? "enabled" : "disabled", reqtags);\r\n}\r\n}\r\nstatic int sym53c8xx_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(sdev->host);\r\nstruct sym_tcb *tp = &np->target[sdev->id];\r\nstruct sym_lcb *lp;\r\nunsigned long flags;\r\nint error;\r\nif (sdev->id >= SYM_CONF_MAX_TARGET || sdev->lun >= SYM_CONF_MAX_LUN)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(np->s.host->host_lock, flags);\r\nif (tp->usrflags & SYM_SCAN_BOOT_DISABLED) {\r\ntp->usrflags &= ~SYM_SCAN_BOOT_DISABLED;\r\nstarget_printk(KERN_INFO, sdev->sdev_target,\r\n"Scan at boot disabled in NVRAM\n");\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nif (tp->usrflags & SYM_SCAN_LUNS_DISABLED) {\r\nif (sdev->lun != 0) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nstarget_printk(KERN_INFO, sdev->sdev_target,\r\n"Multiple LUNs disabled in NVRAM\n");\r\n}\r\nlp = sym_alloc_lcb(np, sdev->id, sdev->lun);\r\nif (!lp) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nif (tp->nlcb == 1)\r\ntp->starget = sdev->sdev_target;\r\nspi_min_period(tp->starget) = tp->usr_period;\r\nspi_max_width(tp->starget) = tp->usr_width;\r\nerror = 0;\r\nout:\r\nspin_unlock_irqrestore(np->s.host->host_lock, flags);\r\nreturn error;\r\n}\r\nstatic int sym53c8xx_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(sdev->host);\r\nstruct sym_tcb *tp = &np->target[sdev->id];\r\nstruct sym_lcb *lp = sym_lp(tp, sdev->lun);\r\nint reqtags, depth_to_use;\r\nlp->curr_flags = lp->user_flags;\r\nreqtags = sym_driver_setup.max_tag;\r\nif (reqtags > tp->usrtags)\r\nreqtags = tp->usrtags;\r\nif (!sdev->tagged_supported)\r\nreqtags = 0;\r\nif (reqtags > SYM_CONF_MAX_TAG)\r\nreqtags = SYM_CONF_MAX_TAG;\r\ndepth_to_use = reqtags ? reqtags : 1;\r\nscsi_adjust_queue_depth(sdev,\r\nsdev->tagged_supported ? MSG_SIMPLE_TAG : 0,\r\ndepth_to_use);\r\nlp->s.scdev_depth = depth_to_use;\r\nsym_tune_dev_queuing(tp, sdev->lun, reqtags);\r\nif (!spi_initial_dv(sdev->sdev_target))\r\nspi_dv_device(sdev);\r\nreturn 0;\r\n}\r\nstatic void sym53c8xx_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(sdev->host);\r\nstruct sym_tcb *tp = &np->target[sdev->id];\r\nstruct sym_lcb *lp = sym_lp(tp, sdev->lun);\r\nunsigned long flags;\r\nspin_lock_irqsave(np->s.host->host_lock, flags);\r\nif (lp->busy_itlq || lp->busy_itl) {\r\nstarget_printk(KERN_WARNING, tp->starget,\r\n"Removing busy LCB (%d)\n", sdev->lun);\r\nsym_reset_scsi_bus(np, 1);\r\n}\r\nif (sym_free_lcb(np, sdev->id, sdev->lun) == 0) {\r\ntp->head.sval = 0;\r\ntp->head.wval = np->rv_scntl3;\r\ntp->head.uval = 0;\r\ntp->tgoal.check_nego = 1;\r\ntp->starget = NULL;\r\n}\r\nspin_unlock_irqrestore(np->s.host->host_lock, flags);\r\n}\r\nstatic const char *sym53c8xx_info (struct Scsi_Host *host)\r\n{\r\nreturn SYM_DRIVER_NAME;\r\n}\r\nstatic void sym_exec_user_command (struct sym_hcb *np, struct sym_usrcmd *uc)\r\n{\r\nstruct sym_tcb *tp;\r\nint t, l;\r\nswitch (uc->cmd) {\r\ncase 0: return;\r\n#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT\r\ncase UC_SETDEBUG:\r\nsym_debug_flags = uc->data;\r\nbreak;\r\n#endif\r\ncase UC_SETVERBOSE:\r\nnp->verbose = uc->data;\r\nbreak;\r\ndefault:\r\nfor (t = 0; t < SYM_CONF_MAX_TARGET; t++) {\r\nif (!((uc->target >> t) & 1))\r\ncontinue;\r\ntp = &np->target[t];\r\nif (!tp->nlcb)\r\ncontinue;\r\nswitch (uc->cmd) {\r\ncase UC_SETSYNC:\r\nif (!uc->data || uc->data >= 255) {\r\ntp->tgoal.iu = tp->tgoal.dt =\r\ntp->tgoal.qas = 0;\r\ntp->tgoal.offset = 0;\r\n} else if (uc->data <= 9 && np->minsync_dt) {\r\nif (uc->data < np->minsync_dt)\r\nuc->data = np->minsync_dt;\r\ntp->tgoal.iu = tp->tgoal.dt =\r\ntp->tgoal.qas = 1;\r\ntp->tgoal.width = 1;\r\ntp->tgoal.period = uc->data;\r\ntp->tgoal.offset = np->maxoffs_dt;\r\n} else {\r\nif (uc->data < np->minsync)\r\nuc->data = np->minsync;\r\ntp->tgoal.iu = tp->tgoal.dt =\r\ntp->tgoal.qas = 0;\r\ntp->tgoal.period = uc->data;\r\ntp->tgoal.offset = np->maxoffs;\r\n}\r\ntp->tgoal.check_nego = 1;\r\nbreak;\r\ncase UC_SETWIDE:\r\ntp->tgoal.width = uc->data ? 1 : 0;\r\ntp->tgoal.check_nego = 1;\r\nbreak;\r\ncase UC_SETTAGS:\r\nfor (l = 0; l < SYM_CONF_MAX_LUN; l++)\r\nsym_tune_dev_queuing(tp, l, uc->data);\r\nbreak;\r\ncase UC_RESETDEV:\r\ntp->to_reset = 1;\r\nnp->istat_sem = SEM;\r\nOUTB(np, nc_istat, SIGP|SEM);\r\nbreak;\r\ncase UC_CLEARDEV:\r\nfor (l = 0; l < SYM_CONF_MAX_LUN; l++) {\r\nstruct sym_lcb *lp = sym_lp(tp, l);\r\nif (lp) lp->to_clear = 1;\r\n}\r\nnp->istat_sem = SEM;\r\nOUTB(np, nc_istat, SIGP|SEM);\r\nbreak;\r\ncase UC_SETFLAG:\r\ntp->usrflags = uc->data;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int sym_skip_spaces(char *ptr, int len)\r\n{\r\nint cnt, c;\r\nfor (cnt = len; cnt > 0 && (c = *ptr++) && isspace(c); cnt--);\r\nreturn (len - cnt);\r\n}\r\nstatic int get_int_arg(char *ptr, int len, u_long *pv)\r\n{\r\nchar *end;\r\n*pv = simple_strtoul(ptr, &end, 10);\r\nreturn (end - ptr);\r\n}\r\nstatic int is_keyword(char *ptr, int len, char *verb)\r\n{\r\nint verb_len = strlen(verb);\r\nif (len >= verb_len && !memcmp(verb, ptr, verb_len))\r\nreturn verb_len;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int sym_user_command(struct Scsi_Host *shost, char *buffer, int length)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nchar *ptr = buffer;\r\nint len = length;\r\nstruct sym_usrcmd cmd, *uc = &cmd;\r\nint arg_len;\r\nu_long target;\r\nmemset(uc, 0, sizeof(*uc));\r\nif (len > 0 && ptr[len-1] == '\n')\r\n--len;\r\nif ((arg_len = is_keyword(ptr, len, "setsync")) != 0)\r\nuc->cmd = UC_SETSYNC;\r\nelse if ((arg_len = is_keyword(ptr, len, "settags")) != 0)\r\nuc->cmd = UC_SETTAGS;\r\nelse if ((arg_len = is_keyword(ptr, len, "setverbose")) != 0)\r\nuc->cmd = UC_SETVERBOSE;\r\nelse if ((arg_len = is_keyword(ptr, len, "setwide")) != 0)\r\nuc->cmd = UC_SETWIDE;\r\n#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT\r\nelse if ((arg_len = is_keyword(ptr, len, "setdebug")) != 0)\r\nuc->cmd = UC_SETDEBUG;\r\n#endif\r\nelse if ((arg_len = is_keyword(ptr, len, "setflag")) != 0)\r\nuc->cmd = UC_SETFLAG;\r\nelse if ((arg_len = is_keyword(ptr, len, "resetdev")) != 0)\r\nuc->cmd = UC_RESETDEV;\r\nelse if ((arg_len = is_keyword(ptr, len, "cleardev")) != 0)\r\nuc->cmd = UC_CLEARDEV;\r\nelse\r\narg_len = 0;\r\n#ifdef DEBUG_PROC_INFO\r\nprintk("sym_user_command: arg_len=%d, cmd=%ld\n", arg_len, uc->cmd);\r\n#endif\r\nif (!arg_len)\r\nreturn -EINVAL;\r\nptr += arg_len; len -= arg_len;\r\nswitch(uc->cmd) {\r\ncase UC_SETSYNC:\r\ncase UC_SETTAGS:\r\ncase UC_SETWIDE:\r\ncase UC_SETFLAG:\r\ncase UC_RESETDEV:\r\ncase UC_CLEARDEV:\r\nSKIP_SPACES(ptr, len);\r\nif ((arg_len = is_keyword(ptr, len, "all")) != 0) {\r\nptr += arg_len; len -= arg_len;\r\nuc->target = ~0;\r\n} else {\r\nGET_INT_ARG(ptr, len, target);\r\nuc->target = (1<<target);\r\n#ifdef DEBUG_PROC_INFO\r\nprintk("sym_user_command: target=%ld\n", target);\r\n#endif\r\n}\r\nbreak;\r\n}\r\nswitch(uc->cmd) {\r\ncase UC_SETVERBOSE:\r\ncase UC_SETSYNC:\r\ncase UC_SETTAGS:\r\ncase UC_SETWIDE:\r\nSKIP_SPACES(ptr, len);\r\nGET_INT_ARG(ptr, len, uc->data);\r\n#ifdef DEBUG_PROC_INFO\r\nprintk("sym_user_command: data=%ld\n", uc->data);\r\n#endif\r\nbreak;\r\n#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT\r\ncase UC_SETDEBUG:\r\nwhile (len > 0) {\r\nSKIP_SPACES(ptr, len);\r\nif ((arg_len = is_keyword(ptr, len, "alloc")))\r\nuc->data |= DEBUG_ALLOC;\r\nelse if ((arg_len = is_keyword(ptr, len, "phase")))\r\nuc->data |= DEBUG_PHASE;\r\nelse if ((arg_len = is_keyword(ptr, len, "queue")))\r\nuc->data |= DEBUG_QUEUE;\r\nelse if ((arg_len = is_keyword(ptr, len, "result")))\r\nuc->data |= DEBUG_RESULT;\r\nelse if ((arg_len = is_keyword(ptr, len, "scatter")))\r\nuc->data |= DEBUG_SCATTER;\r\nelse if ((arg_len = is_keyword(ptr, len, "script")))\r\nuc->data |= DEBUG_SCRIPT;\r\nelse if ((arg_len = is_keyword(ptr, len, "tiny")))\r\nuc->data |= DEBUG_TINY;\r\nelse if ((arg_len = is_keyword(ptr, len, "timing")))\r\nuc->data |= DEBUG_TIMING;\r\nelse if ((arg_len = is_keyword(ptr, len, "nego")))\r\nuc->data |= DEBUG_NEGO;\r\nelse if ((arg_len = is_keyword(ptr, len, "tags")))\r\nuc->data |= DEBUG_TAGS;\r\nelse if ((arg_len = is_keyword(ptr, len, "pointer")))\r\nuc->data |= DEBUG_POINTER;\r\nelse\r\nreturn -EINVAL;\r\nptr += arg_len; len -= arg_len;\r\n}\r\n#ifdef DEBUG_PROC_INFO\r\nprintk("sym_user_command: data=%ld\n", uc->data);\r\n#endif\r\nbreak;\r\n#endif\r\ncase UC_SETFLAG:\r\nwhile (len > 0) {\r\nSKIP_SPACES(ptr, len);\r\nif ((arg_len = is_keyword(ptr, len, "no_disc")))\r\nuc->data &= ~SYM_DISC_ENABLED;\r\nelse\r\nreturn -EINVAL;\r\nptr += arg_len; len -= arg_len;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (len)\r\nreturn -EINVAL;\r\nelse {\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nsym_exec_user_command(np, uc);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nreturn length;\r\n}\r\nstatic void copy_mem_info(struct info_str *info, char *data, int len)\r\n{\r\nif (info->pos + len > info->length)\r\nlen = info->length - info->pos;\r\nif (info->pos + len < info->offset) {\r\ninfo->pos += len;\r\nreturn;\r\n}\r\nif (info->pos < info->offset) {\r\ndata += (info->offset - info->pos);\r\nlen -= (info->offset - info->pos);\r\n}\r\nif (len > 0) {\r\nmemcpy(info->buffer + info->pos, data, len);\r\ninfo->pos += len;\r\n}\r\n}\r\nstatic int copy_info(struct info_str *info, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[81];\r\nint len;\r\nva_start(args, fmt);\r\nlen = vsprintf(buf, fmt, args);\r\nva_end(args);\r\ncopy_mem_info(info, buf, len);\r\nreturn len;\r\n}\r\nstatic int sym_host_info(struct Scsi_Host *shost, char *ptr, off_t offset, int len)\r\n{\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nstruct pci_dev *pdev = sym_data->pdev;\r\nstruct sym_hcb *np = sym_data->ncb;\r\nstruct info_str info;\r\ninfo.buffer = ptr;\r\ninfo.length = len;\r\ninfo.offset = offset;\r\ninfo.pos = 0;\r\ncopy_info(&info, "Chip " NAME53C "%s, device id 0x%x, "\r\n"revision id 0x%x\n", np->s.chip_name,\r\npdev->device, pdev->revision);\r\ncopy_info(&info, "At PCI address %s, IRQ %u\n",\r\npci_name(pdev), pdev->irq);\r\ncopy_info(&info, "Min. period factor %d, %s SCSI BUS%s\n",\r\n(int) (np->minsync_dt ? np->minsync_dt : np->minsync),\r\nnp->maxwide ? "Wide" : "Narrow",\r\nnp->minsync_dt ? ", DT capable" : "");\r\ncopy_info(&info, "Max. started commands %d, "\r\n"max. commands per LUN %d\n",\r\nSYM_CONF_MAX_START, SYM_CONF_MAX_TAG);\r\nreturn info.pos > info.offset? info.pos - info.offset : 0;\r\n}\r\nstatic int sym53c8xx_proc_info(struct Scsi_Host *shost, char *buffer,\r\nchar **start, off_t offset, int length, int func)\r\n{\r\nint retv;\r\nif (func) {\r\n#ifdef SYM_LINUX_USER_COMMAND_SUPPORT\r\nretv = sym_user_command(shost, buffer, length);\r\n#else\r\nretv = -EINVAL;\r\n#endif\r\n} else {\r\nif (start)\r\n*start = buffer;\r\n#ifdef SYM_LINUX_USER_INFO_SUPPORT\r\nretv = sym_host_info(shost, buffer, offset, length);\r\n#else\r\nretv = -EINVAL;\r\n#endif\r\n}\r\nreturn retv;\r\n}\r\nstatic void __devinit\r\nsym_iounmap_device(struct sym_device *device)\r\n{\r\nif (device->s.ioaddr)\r\npci_iounmap(device->pdev, device->s.ioaddr);\r\nif (device->s.ramaddr)\r\npci_iounmap(device->pdev, device->s.ramaddr);\r\n}\r\nstatic void sym_free_resources(struct sym_hcb *np, struct pci_dev *pdev,\r\nint do_free_irq)\r\n{\r\nif (do_free_irq)\r\nfree_irq(pdev->irq, np->s.host);\r\nif (np->s.ioaddr)\r\npci_iounmap(pdev, np->s.ioaddr);\r\nif (np->s.ramaddr)\r\npci_iounmap(pdev, np->s.ramaddr);\r\nsym_hcb_free(np);\r\nsym_mfree_dma(np, sizeof(*np), "HCB");\r\n}\r\nstatic struct Scsi_Host * __devinit sym_attach(struct scsi_host_template *tpnt,\r\nint unit, struct sym_device *dev)\r\n{\r\nstruct sym_data *sym_data;\r\nstruct sym_hcb *np = NULL;\r\nstruct Scsi_Host *shost = NULL;\r\nstruct pci_dev *pdev = dev->pdev;\r\nunsigned long flags;\r\nstruct sym_fw *fw;\r\nint do_free_irq = 0;\r\nprintk(KERN_INFO "sym%d: <%s> rev 0x%x at pci %s irq %u\n",\r\nunit, dev->chip.name, pdev->revision, pci_name(pdev),\r\npdev->irq);\r\nfw = sym_find_firmware(&dev->chip);\r\nif (!fw)\r\ngoto attach_failed;\r\nshost = scsi_host_alloc(tpnt, sizeof(*sym_data));\r\nif (!shost)\r\ngoto attach_failed;\r\nsym_data = shost_priv(shost);\r\nnp = __sym_calloc_dma(&pdev->dev, sizeof(*np), "HCB");\r\nif (!np)\r\ngoto attach_failed;\r\nnp->bus_dmat = &pdev->dev;\r\nsym_data->ncb = np;\r\nsym_data->pdev = pdev;\r\nnp->s.host = shost;\r\npci_set_drvdata(pdev, shost);\r\nnp->hcb_ba = vtobus(np);\r\nnp->verbose = sym_driver_setup.verbose;\r\nnp->s.unit = unit;\r\nnp->features = dev->chip.features;\r\nnp->clock_divn = dev->chip.nr_divisor;\r\nnp->maxoffs = dev->chip.offset_max;\r\nnp->maxburst = dev->chip.burst_max;\r\nnp->myaddr = dev->host_id;\r\nnp->mmio_ba = (u32)dev->mmio_base;\r\nnp->ram_ba = (u32)dev->ram_base;\r\nnp->s.ioaddr = dev->s.ioaddr;\r\nnp->s.ramaddr = dev->s.ramaddr;\r\nstrlcpy(np->s.chip_name, dev->chip.name, sizeof(np->s.chip_name));\r\nsprintf(np->s.inst_name, "sym%d", np->s.unit);\r\nif ((SYM_CONF_DMA_ADDRESSING_MODE > 0) && (np->features & FE_DAC) &&\r\n!pci_set_dma_mask(pdev, DMA_DAC_MASK)) {\r\nset_dac(np);\r\n} else if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintf_warning("%s: No suitable DMA available\n", sym_name(np));\r\ngoto attach_failed;\r\n}\r\nif (sym_hcb_attach(shost, fw, dev->nvram))\r\ngoto attach_failed;\r\nif (request_irq(pdev->irq, sym53c8xx_intr, IRQF_SHARED, NAME53C8XX,\r\nshost)) {\r\nprintf_err("%s: request irq %u failure\n",\r\nsym_name(np), pdev->irq);\r\ngoto attach_failed;\r\n}\r\ndo_free_irq = 1;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (sym_reset_scsi_bus(np, 0))\r\ngoto reset_failed;\r\nsym_start_up(shost, 1);\r\ninit_timer(&np->s.timer);\r\nnp->s.timer.data = (unsigned long) np;\r\nnp->s.timer.function = sym53c8xx_timer;\r\nnp->s.lasttime=0;\r\nsym_timer (np);\r\nshost->max_channel = 0;\r\nshost->this_id = np->myaddr;\r\nshost->max_id = np->maxwide ? 16 : 8;\r\nshost->max_lun = SYM_CONF_MAX_LUN;\r\nshost->unique_id = pci_resource_start(pdev, 0);\r\nshost->cmd_per_lun = SYM_CONF_MAX_TAG;\r\nshost->can_queue = (SYM_CONF_MAX_START-2);\r\nshost->sg_tablesize = SYM_CONF_MAX_SG;\r\nshost->max_cmd_len = 16;\r\nBUG_ON(sym2_transport_template == NULL);\r\nshost->transportt = sym2_transport_template;\r\nif (pdev->device == PCI_DEVICE_ID_NCR_53C896 && pdev->revision < 2)\r\nshost->dma_boundary = 0xFFFFFF;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn shost;\r\nreset_failed:\r\nprintf_err("%s: FATAL ERROR: CHECK SCSI BUS - CABLES, "\r\n"TERMINATION, DEVICE POWER etc.!\n", sym_name(np));\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nattach_failed:\r\nprintf_info("sym%d: giving up ...\n", unit);\r\nif (np)\r\nsym_free_resources(np, pdev, do_free_irq);\r\nelse\r\nsym_iounmap_device(dev);\r\nif (shost)\r\nscsi_host_put(shost);\r\nreturn NULL;\r\n}\r\nstatic void __devinit sym_get_nvram(struct sym_device *devp, struct sym_nvram *nvp)\r\n{\r\ndevp->nvram = nvp;\r\nnvp->type = 0;\r\nsym_read_nvram(devp, nvp);\r\n}\r\nstatic inline void sym_get_nvram(struct sym_device *devp, struct sym_nvram *nvp)\r\n{\r\n}\r\nstatic int __devinit sym_check_supported(struct sym_device *device)\r\n{\r\nstruct sym_chip *chip;\r\nstruct pci_dev *pdev = device->pdev;\r\nunsigned long io_port = pci_resource_start(pdev, 0);\r\nint i;\r\nif (io_port) {\r\nfor (i = 0 ; i < 8 ; i++) {\r\nif (sym_driver_setup.excludes[i] == io_port)\r\nreturn -ENODEV;\r\n}\r\n}\r\nchip = sym_lookup_chip_table(pdev->device, pdev->revision);\r\nif (!chip) {\r\ndev_info(&pdev->dev, "device not supported\n");\r\nreturn -ENODEV;\r\n}\r\nmemcpy(&device->chip, chip, sizeof(device->chip));\r\nreturn 0;\r\n}\r\nstatic int __devinit sym_check_raid(struct sym_device *device)\r\n{\r\nunsigned int ram_size, ram_val;\r\nif (!device->s.ramaddr)\r\nreturn 0;\r\nif (device->chip.features & FE_RAM8K)\r\nram_size = 8192;\r\nelse\r\nram_size = 4096;\r\nram_val = readl(device->s.ramaddr + ram_size - 16);\r\nif (ram_val != 0x52414944)\r\nreturn 0;\r\ndev_info(&device->pdev->dev,\r\n"not initializing, driven by RAID controller.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit sym_set_workarounds(struct sym_device *device)\r\n{\r\nstruct sym_chip *chip = &device->chip;\r\nstruct pci_dev *pdev = device->pdev;\r\nu_short status_reg;\r\nif (pdev->device == PCI_DEVICE_ID_NCR_53C896 && pdev->revision < 0x4) {\r\nchip->features |= (FE_WRIE | FE_CLSE);\r\n}\r\nif (chip->features & FE_WRIE) {\r\nif (pci_set_mwi(pdev))\r\nreturn -ENODEV;\r\n}\r\npci_read_config_word(pdev, PCI_STATUS, &status_reg);\r\nif (chip->features & FE_66MHZ) {\r\nif (!(status_reg & PCI_STATUS_66MHZ))\r\nchip->features &= ~FE_66MHZ;\r\n} else {\r\nif (status_reg & PCI_STATUS_66MHZ) {\r\nstatus_reg = PCI_STATUS_66MHZ;\r\npci_write_config_word(pdev, PCI_STATUS, status_reg);\r\npci_read_config_word(pdev, PCI_STATUS, &status_reg);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nsym_iomap_device(struct sym_device *device)\r\n{\r\nstruct pci_dev *pdev = device->pdev;\r\nstruct pci_bus_region bus_addr;\r\nint i = 2;\r\npcibios_resource_to_bus(pdev, &bus_addr, &pdev->resource[1]);\r\ndevice->mmio_base = bus_addr.start;\r\nif (device->chip.features & FE_RAM) {\r\nif (!pdev->resource[i].flags)\r\ni++;\r\npcibios_resource_to_bus(pdev, &bus_addr, &pdev->resource[i]);\r\ndevice->ram_base = bus_addr.start;\r\n}\r\n#ifdef CONFIG_SCSI_SYM53C8XX_MMIO\r\nif (device->mmio_base)\r\ndevice->s.ioaddr = pci_iomap(pdev, 1,\r\npci_resource_len(pdev, 1));\r\n#endif\r\nif (!device->s.ioaddr)\r\ndevice->s.ioaddr = pci_iomap(pdev, 0,\r\npci_resource_len(pdev, 0));\r\nif (!device->s.ioaddr) {\r\ndev_err(&pdev->dev, "could not map registers; giving up.\n");\r\nreturn -EIO;\r\n}\r\nif (device->ram_base) {\r\ndevice->s.ramaddr = pci_iomap(pdev, i,\r\npci_resource_len(pdev, i));\r\nif (!device->s.ramaddr) {\r\ndev_warn(&pdev->dev,\r\n"could not map SRAM; continuing anyway.\n");\r\ndevice->ram_base = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sym_config_pqs(struct pci_dev *pdev, struct sym_device *sym_dev)\r\n{\r\nint slot;\r\nu8 tmp;\r\nfor (slot = 0; slot < 256; slot++) {\r\nstruct pci_dev *memc = pci_get_slot(pdev->bus, slot);\r\nif (!memc || memc->vendor != 0x101a || memc->device == 0x0009) {\r\npci_dev_put(memc);\r\ncontinue;\r\n}\r\npci_read_config_byte(memc, 0x44, &tmp);\r\nif ((tmp & 0x2) == 0) {\r\ntmp |= 0x2;\r\npci_write_config_byte(memc, 0x44, tmp);\r\n}\r\npci_read_config_byte(memc, 0x45, &tmp);\r\nif ((tmp & 0x4) == 0) {\r\ntmp |= 0x4;\r\npci_write_config_byte(memc, 0x45, tmp);\r\n}\r\npci_dev_put(memc);\r\nbreak;\r\n}\r\npci_read_config_byte(pdev, 0x84, &tmp);\r\nsym_dev->host_id = tmp;\r\n}\r\nstatic int sym_detach(struct Scsi_Host *shost, struct pci_dev *pdev)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nprintk("%s: detaching ...\n", sym_name(np));\r\ndel_timer_sync(&np->s.timer);\r\nprintk("%s: resetting chip\n", sym_name(np));\r\nOUTB(np, nc_istat, SRST);\r\nINB(np, nc_mbox1);\r\nudelay(10);\r\nOUTB(np, nc_istat, 0);\r\nsym_free_resources(np, pdev, 1);\r\nscsi_host_put(shost);\r\nreturn 1;\r\n}\r\nstatic int __devinit sym2_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct sym_device sym_dev;\r\nstruct sym_nvram nvram;\r\nstruct Scsi_Host *shost;\r\nint do_iounmap = 0;\r\nint do_disable_device = 1;\r\nmemset(&sym_dev, 0, sizeof(sym_dev));\r\nmemset(&nvram, 0, sizeof(nvram));\r\nsym_dev.pdev = pdev;\r\nsym_dev.host_id = SYM_SETUP_HOST_ID;\r\nif (pci_enable_device(pdev))\r\ngoto leave;\r\npci_set_master(pdev);\r\nif (pci_request_regions(pdev, NAME53C8XX))\r\ngoto disable;\r\nif (sym_check_supported(&sym_dev))\r\ngoto free;\r\nif (sym_iomap_device(&sym_dev))\r\ngoto free;\r\ndo_iounmap = 1;\r\nif (sym_check_raid(&sym_dev)) {\r\ndo_disable_device = 0;\r\ngoto free;\r\n}\r\nif (sym_set_workarounds(&sym_dev))\r\ngoto free;\r\nsym_config_pqs(pdev, &sym_dev);\r\nsym_get_nvram(&sym_dev, &nvram);\r\ndo_iounmap = 0;\r\nshost = sym_attach(&sym2_template, attach_count, &sym_dev);\r\nif (!shost)\r\ngoto free;\r\nif (scsi_add_host(shost, &pdev->dev))\r\ngoto detach;\r\nscsi_scan_host(shost);\r\nattach_count++;\r\nreturn 0;\r\ndetach:\r\nsym_detach(pci_get_drvdata(pdev), pdev);\r\nfree:\r\nif (do_iounmap)\r\nsym_iounmap_device(&sym_dev);\r\npci_release_regions(pdev);\r\ndisable:\r\nif (do_disable_device)\r\npci_disable_device(pdev);\r\nleave:\r\nreturn -ENODEV;\r\n}\r\nstatic void sym2_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nscsi_remove_host(shost);\r\nsym_detach(shost, pdev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nattach_count--;\r\n}\r\nstatic pci_ers_result_t sym2_io_error_detected(struct pci_dev *pdev,\r\nenum pci_channel_state state)\r\n{\r\nif (state == pci_channel_io_perm_failure) {\r\nsym2_remove(pdev);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\ndisable_irq(pdev->irq);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\n}\r\nstatic pci_ers_result_t sym2_io_slot_dump(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nsym_dump_registers(shost);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic void sym2_reset_workarounds(struct pci_dev *pdev)\r\n{\r\nu_short status_reg;\r\nstruct sym_chip *chip;\r\nchip = sym_lookup_chip_table(pdev->device, pdev->revision);\r\npci_read_config_word(pdev, PCI_STATUS, &status_reg);\r\nif (!(chip->features & FE_66MHZ) && (status_reg & PCI_STATUS_66MHZ)) {\r\nstatus_reg = PCI_STATUS_66MHZ;\r\npci_write_config_word(pdev, PCI_STATUS, status_reg);\r\npci_read_config_word(pdev, PCI_STATUS, &status_reg);\r\n}\r\n}\r\nstatic pci_ers_result_t sym2_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nprintk(KERN_INFO "%s: recovering from a PCI slot reset\n",\r\nsym_name(np));\r\nif (pci_enable_device(pdev)) {\r\nprintk(KERN_ERR "%s: Unable to enable after PCI reset\n",\r\nsym_name(np));\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\npci_set_master(pdev);\r\nenable_irq(pdev->irq);\r\nif (np->features & FE_WRIE) {\r\nif (pci_set_mwi(pdev))\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nsym2_reset_workarounds(pdev);\r\nif (PCI_FUNC(pdev->devfn) == 0) {\r\nif (sym_reset_scsi_bus(np, 0)) {\r\nprintk(KERN_ERR "%s: Unable to reset scsi host\n",\r\nsym_name(np));\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nsym_start_up(shost, 1);\r\n}\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void sym2_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nspin_lock_irq(shost->host_lock);\r\nif (sym_data->io_reset)\r\ncomplete_all(sym_data->io_reset);\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nstatic void sym2_get_signalling(struct Scsi_Host *shost)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nenum spi_signal_type type;\r\nswitch (np->scsi_mode) {\r\ncase SMODE_SE:\r\ntype = SPI_SIGNAL_SE;\r\nbreak;\r\ncase SMODE_LVD:\r\ntype = SPI_SIGNAL_LVD;\r\nbreak;\r\ncase SMODE_HVD:\r\ntype = SPI_SIGNAL_HVD;\r\nbreak;\r\ndefault:\r\ntype = SPI_SIGNAL_UNKNOWN;\r\nbreak;\r\n}\r\nspi_signalling(shost) = type;\r\n}\r\nstatic void sym2_set_offset(struct scsi_target *starget, int offset)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nstruct sym_tcb *tp = &np->target[starget->id];\r\ntp->tgoal.offset = offset;\r\ntp->tgoal.check_nego = 1;\r\n}\r\nstatic void sym2_set_period(struct scsi_target *starget, int period)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nstruct sym_tcb *tp = &np->target[starget->id];\r\nif (period <= np->minsync && spi_width(starget))\r\ntp->tgoal.dt = 1;\r\ntp->tgoal.period = period;\r\ntp->tgoal.check_nego = 1;\r\n}\r\nstatic void sym2_set_width(struct scsi_target *starget, int width)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nstruct sym_tcb *tp = &np->target[starget->id];\r\nif (width == 0)\r\ntp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\r\ntp->tgoal.width = width;\r\ntp->tgoal.check_nego = 1;\r\n}\r\nstatic void sym2_set_dt(struct scsi_target *starget, int dt)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nstruct sym_tcb *tp = &np->target[starget->id];\r\nif (dt)\r\ntp->tgoal.dt = 1;\r\nelse\r\ntp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\r\ntp->tgoal.check_nego = 1;\r\n}\r\nstatic int __init sym2_init(void)\r\n{\r\nint error;\r\nsym2_setup_params();\r\nsym2_transport_template = spi_attach_transport(&sym2_transport_functions);\r\nif (!sym2_transport_template)\r\nreturn -ENODEV;\r\nerror = pci_register_driver(&sym2_driver);\r\nif (error)\r\nspi_release_transport(sym2_transport_template);\r\nreturn error;\r\n}\r\nstatic void __exit sym2_exit(void)\r\n{\r\npci_unregister_driver(&sym2_driver);\r\nspi_release_transport(sym2_transport_template);\r\n}
