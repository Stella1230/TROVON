static void dump_packet(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb,\r\nunsigned int iphoff)\r\n{\r\nstruct iphdr _iph;\r\nconst struct iphdr *ih;\r\nunsigned int logflags;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nelse\r\nlogflags = NF_LOG_MASK;\r\nih = skb_header_pointer(skb, iphoff, sizeof(_iph), &_iph);\r\nif (ih == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nsb_add(m, "SRC=%pI4 DST=%pI4 ",\r\n&ih->saddr, &ih->daddr);\r\nsb_add(m, "LEN=%u TOS=0x%02X PREC=0x%02X TTL=%u ID=%u ",\r\nntohs(ih->tot_len), ih->tos & IPTOS_TOS_MASK,\r\nih->tos & IPTOS_PREC_MASK, ih->ttl, ntohs(ih->id));\r\nif (ntohs(ih->frag_off) & IP_CE)\r\nsb_add(m, "CE ");\r\nif (ntohs(ih->frag_off) & IP_DF)\r\nsb_add(m, "DF ");\r\nif (ntohs(ih->frag_off) & IP_MF)\r\nsb_add(m, "MF ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nsb_add(m, "FRAG:%u ", ntohs(ih->frag_off) & IP_OFFSET);\r\nif ((logflags & IPT_LOG_IPOPT) &&\r\nih->ihl * 4 > sizeof(struct iphdr)) {\r\nconst unsigned char *op;\r\nunsigned char _opt[4 * 15 - sizeof(struct iphdr)];\r\nunsigned int i, optsize;\r\noptsize = ih->ihl * 4 - sizeof(struct iphdr);\r\nop = skb_header_pointer(skb, iphoff+sizeof(_iph),\r\noptsize, _opt);\r\nif (op == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nsb_add(m, "OPT (");\r\nfor (i = 0; i < optsize; i++)\r\nsb_add(m, "%02X", op[i]);\r\nsb_add(m, ") ");\r\n}\r\nswitch (ih->protocol) {\r\ncase IPPROTO_TCP: {\r\nstruct tcphdr _tcph;\r\nconst struct tcphdr *th;\r\nsb_add(m, "PROTO=TCP ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nth = skb_header_pointer(skb, iphoff + ih->ihl * 4,\r\nsizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "SPT=%u DPT=%u ",\r\nntohs(th->source), ntohs(th->dest));\r\nif (logflags & IPT_LOG_TCPSEQ)\r\nsb_add(m, "SEQ=%u ACK=%u ",\r\nntohl(th->seq), ntohl(th->ack_seq));\r\nsb_add(m, "WINDOW=%u ", ntohs(th->window));\r\nsb_add(m, "RES=0x%02x ", (u8)(ntohl(tcp_flag_word(th) & TCP_RESERVED_BITS) >> 22));\r\nif (th->cwr)\r\nsb_add(m, "CWR ");\r\nif (th->ece)\r\nsb_add(m, "ECE ");\r\nif (th->urg)\r\nsb_add(m, "URG ");\r\nif (th->ack)\r\nsb_add(m, "ACK ");\r\nif (th->psh)\r\nsb_add(m, "PSH ");\r\nif (th->rst)\r\nsb_add(m, "RST ");\r\nif (th->syn)\r\nsb_add(m, "SYN ");\r\nif (th->fin)\r\nsb_add(m, "FIN ");\r\nsb_add(m, "URGP=%u ", ntohs(th->urg_ptr));\r\nif ((logflags & IPT_LOG_TCPOPT) &&\r\nth->doff * 4 > sizeof(struct tcphdr)) {\r\nunsigned char _opt[4 * 15 - sizeof(struct tcphdr)];\r\nconst unsigned char *op;\r\nunsigned int i, optsize;\r\noptsize = th->doff * 4 - sizeof(struct tcphdr);\r\nop = skb_header_pointer(skb,\r\niphoff+ih->ihl*4+sizeof(_tcph),\r\noptsize, _opt);\r\nif (op == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nsb_add(m, "OPT (");\r\nfor (i = 0; i < optsize; i++)\r\nsb_add(m, "%02X", op[i]);\r\nsb_add(m, ") ");\r\n}\r\nbreak;\r\n}\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE: {\r\nstruct udphdr _udph;\r\nconst struct udphdr *uh;\r\nif (ih->protocol == IPPROTO_UDP)\r\nsb_add(m, "PROTO=UDP " );\r\nelse\r\nsb_add(m, "PROTO=UDPLITE ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nuh = skb_header_pointer(skb, iphoff+ih->ihl*4,\r\nsizeof(_udph), &_udph);\r\nif (uh == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "SPT=%u DPT=%u LEN=%u ",\r\nntohs(uh->source), ntohs(uh->dest),\r\nntohs(uh->len));\r\nbreak;\r\n}\r\ncase IPPROTO_ICMP: {\r\nstruct icmphdr _icmph;\r\nconst struct icmphdr *ich;\r\nstatic const size_t required_len[NR_ICMP_TYPES+1]\r\n= { [ICMP_ECHOREPLY] = 4,\r\n[ICMP_DEST_UNREACH]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_SOURCE_QUENCH]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_REDIRECT]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_ECHO] = 4,\r\n[ICMP_TIME_EXCEEDED]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_PARAMETERPROB]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_TIMESTAMP] = 20,\r\n[ICMP_TIMESTAMPREPLY] = 20,\r\n[ICMP_ADDRESS] = 12,\r\n[ICMP_ADDRESSREPLY] = 12 };\r\nsb_add(m, "PROTO=ICMP ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nich = skb_header_pointer(skb, iphoff + ih->ihl * 4,\r\nsizeof(_icmph), &_icmph);\r\nif (ich == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "TYPE=%u CODE=%u ", ich->type, ich->code);\r\nif (ich->type <= NR_ICMP_TYPES &&\r\nrequired_len[ich->type] &&\r\nskb->len-iphoff-ih->ihl*4 < required_len[ich->type]) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nswitch (ich->type) {\r\ncase ICMP_ECHOREPLY:\r\ncase ICMP_ECHO:\r\nsb_add(m, "ID=%u SEQ=%u ",\r\nntohs(ich->un.echo.id),\r\nntohs(ich->un.echo.sequence));\r\nbreak;\r\ncase ICMP_PARAMETERPROB:\r\nsb_add(m, "PARAMETER=%u ",\r\nntohl(ich->un.gateway) >> 24);\r\nbreak;\r\ncase ICMP_REDIRECT:\r\nsb_add(m, "GATEWAY=%pI4 ", &ich->un.gateway);\r\ncase ICMP_DEST_UNREACH:\r\ncase ICMP_SOURCE_QUENCH:\r\ncase ICMP_TIME_EXCEEDED:\r\nif (!iphoff) {\r\nsb_add(m, "[");\r\ndump_packet(m, info, skb,\r\niphoff + ih->ihl*4+sizeof(_icmph));\r\nsb_add(m, "] ");\r\n}\r\nif (ich->type == ICMP_DEST_UNREACH &&\r\nich->code == ICMP_FRAG_NEEDED)\r\nsb_add(m, "MTU=%u ", ntohs(ich->un.frag.mtu));\r\n}\r\nbreak;\r\n}\r\ncase IPPROTO_AH: {\r\nstruct ip_auth_hdr _ahdr;\r\nconst struct ip_auth_hdr *ah;\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nsb_add(m, "PROTO=AH ");\r\nah = skb_header_pointer(skb, iphoff+ih->ihl*4,\r\nsizeof(_ahdr), &_ahdr);\r\nif (ah == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "SPI=0x%x ", ntohl(ah->spi));\r\nbreak;\r\n}\r\ncase IPPROTO_ESP: {\r\nstruct ip_esp_hdr _esph;\r\nconst struct ip_esp_hdr *eh;\r\nsb_add(m, "PROTO=ESP ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\neh = skb_header_pointer(skb, iphoff+ih->ihl*4,\r\nsizeof(_esph), &_esph);\r\nif (eh == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "SPI=0x%x ", ntohl(eh->spi));\r\nbreak;\r\n}\r\ndefault:\r\nsb_add(m, "PROTO=%u ", ih->protocol);\r\n}\r\nif ((logflags & IPT_LOG_UID) && !iphoff && skb->sk) {\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket && skb->sk->sk_socket->file)\r\nsb_add(m, "UID=%u GID=%u ",\r\nskb->sk->sk_socket->file->f_cred->fsuid,\r\nskb->sk->sk_socket->file->f_cred->fsgid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\n}\r\nif (!iphoff && skb->mark)\r\nsb_add(m, "MARK=0x%x ", skb->mark);\r\n}\r\nstatic void dump_mac_header(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nunsigned int logflags = 0;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nif (!(logflags & IPT_LOG_MACDECODE))\r\ngoto fallback;\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\nsb_add(m, "MACSRC=%pM MACDST=%pM MACPROTO=%04x ",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nfallback:\r\nsb_add(m, "MAC=");\r\nif (dev->hard_header_len &&\r\nskb->mac_header != skb->network_header) {\r\nconst unsigned char *p = skb_mac_header(skb);\r\nunsigned int i;\r\nsb_add(m, "%02x", *p++);\r\nfor (i = 1; i < dev->hard_header_len; i++, p++)\r\nsb_add(m, ":%02x", *p);\r\n}\r\nsb_add(m, " ");\r\n}\r\nstatic void\r\nipt_log_packet(u_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nstruct sbuff *m = sb_open();\r\nif (!loginfo)\r\nloginfo = &default_loginfo;\r\nsb_add(m, "<%d>%sIN=%s OUT=%s ", loginfo->u.log.level,\r\nprefix,\r\nin ? in->name : "",\r\nout ? out->name : "");\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (skb->nf_bridge) {\r\nconst struct net_device *physindev;\r\nconst struct net_device *physoutdev;\r\nphysindev = skb->nf_bridge->physindev;\r\nif (physindev && in != physindev)\r\nsb_add(m, "PHYSIN=%s ", physindev->name);\r\nphysoutdev = skb->nf_bridge->physoutdev;\r\nif (physoutdev && out != physoutdev)\r\nsb_add(m, "PHYSOUT=%s ", physoutdev->name);\r\n}\r\n#endif\r\nif (in != NULL)\r\ndump_mac_header(m, loginfo, skb);\r\ndump_packet(m, loginfo, skb, 0);\r\nsb_close(m);\r\n}\r\nstatic unsigned int\r\nlog_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ipt_log_info *loginfo = par->targinfo;\r\nstruct nf_loginfo li;\r\nli.type = NF_LOG_TYPE_LOG;\r\nli.u.log.level = loginfo->level;\r\nli.u.log.logflags = loginfo->logflags;\r\nipt_log_packet(NFPROTO_IPV4, par->hooknum, skb, par->in, par->out, &li,\r\nloginfo->prefix);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int log_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ipt_log_info *loginfo = par->targinfo;\r\nif (loginfo->level >= 8) {\r\npr_debug("level %u >= 8\n", loginfo->level);\r\nreturn -EINVAL;\r\n}\r\nif (loginfo->prefix[sizeof(loginfo->prefix)-1] != '\0') {\r\npr_debug("prefix is not null-terminated\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init log_tg_init(void)\r\n{\r\nint ret;\r\nret = xt_register_target(&log_tg_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nnf_log_register(NFPROTO_IPV4, &ipt_log_logger);\r\nreturn 0;\r\n}\r\nstatic void __exit log_tg_exit(void)\r\n{\r\nnf_log_unregister(&ipt_log_logger);\r\nxt_unregister_target(&log_tg_reg);\r\n}
