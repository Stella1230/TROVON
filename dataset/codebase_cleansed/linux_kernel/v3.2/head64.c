static void __init zap_identity_mappings(void)\r\n{\r\npgd_t *pgd = pgd_offset_k(0UL);\r\npgd_clear(pgd);\r\n__flush_tlb_all();\r\n}\r\nstatic void __init clear_bss(void)\r\n{\r\nmemset(__bss_start, 0,\r\n(unsigned long) __bss_stop - (unsigned long) __bss_start);\r\n}\r\nstatic void __init copy_bootdata(char *real_mode_data)\r\n{\r\nchar * command_line;\r\nmemcpy(&boot_params, real_mode_data, sizeof boot_params);\r\nif (boot_params.hdr.cmd_line_ptr) {\r\ncommand_line = __va(boot_params.hdr.cmd_line_ptr);\r\nmemcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);\r\n}\r\n}\r\nvoid __init x86_64_start_kernel(char * real_mode_data)\r\n{\r\nint i;\r\nBUILD_BUG_ON(MODULES_VADDR < KERNEL_IMAGE_START);\r\nBUILD_BUG_ON(MODULES_VADDR-KERNEL_IMAGE_START < KERNEL_IMAGE_SIZE);\r\nBUILD_BUG_ON(MODULES_LEN + KERNEL_IMAGE_SIZE > 2*PUD_SIZE);\r\nBUILD_BUG_ON((KERNEL_IMAGE_START & ~PMD_MASK) != 0);\r\nBUILD_BUG_ON((MODULES_VADDR & ~PMD_MASK) != 0);\r\nBUILD_BUG_ON(!(MODULES_VADDR > __START_KERNEL));\r\nBUILD_BUG_ON(!(((MODULES_END - 1) & PGDIR_MASK) ==\r\n(__START_KERNEL & PGDIR_MASK)));\r\nBUILD_BUG_ON(__fix_to_virt(__end_of_fixed_addresses) <= MODULES_END);\r\nclear_bss();\r\nzap_identity_mappings();\r\nmax_pfn_mapped = KERNEL_IMAGE_SIZE >> PAGE_SHIFT;\r\nfor (i = 0; i < NUM_EXCEPTION_VECTORS; i++) {\r\n#ifdef CONFIG_EARLY_PRINTK\r\nset_intr_gate(i, &early_idt_handlers[i]);\r\n#else\r\nset_intr_gate(i, early_idt_handler);\r\n#endif\r\n}\r\nload_idt((const struct desc_ptr *)&idt_descr);\r\nif (console_loglevel == 10)\r\nearly_printk("Kernel alive\n");\r\nx86_64_start_reservations(real_mode_data);\r\n}\r\nvoid __init x86_64_start_reservations(char *real_mode_data)\r\n{\r\ncopy_bootdata(__va(real_mode_data));\r\nmemblock_init();\r\nmemblock_x86_reserve_range(__pa_symbol(&_text), __pa_symbol(&__bss_stop), "TEXT DATA BSS");\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (boot_params.hdr.type_of_loader && boot_params.hdr.ramdisk_image) {\r\nunsigned long ramdisk_image = boot_params.hdr.ramdisk_image;\r\nunsigned long ramdisk_size = boot_params.hdr.ramdisk_size;\r\nunsigned long ramdisk_end = PAGE_ALIGN(ramdisk_image + ramdisk_size);\r\nmemblock_x86_reserve_range(ramdisk_image, ramdisk_end, "RAMDISK");\r\n}\r\n#endif\r\nreserve_ebda_region();\r\nstart_kernel();\r\n}
