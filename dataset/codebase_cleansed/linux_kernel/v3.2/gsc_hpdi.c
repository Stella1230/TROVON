int command_channel_valid(unsigned int channel)\r\n{\r\nif (channel == 0 || channel > 6) {\r\nprintk(KERN_WARNING\r\n"gsc_hpdi: bug! invalid cable command channel\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint firmware_revision(uint32_t fwr_bits)\r\n{\r\nreturn fwr_bits & 0xff;\r\n}\r\nint pcb_revision(uint32_t fwr_bits)\r\n{\r\nreturn (fwr_bits >> 8) & 0xff;\r\n}\r\nint hpdi_subid(uint32_t fwr_bits)\r\n{\r\nreturn (fwr_bits >> 16) & 0xff;\r\n}\r\nuint32_t command_discrete_output_bits(unsigned int channel, int output,\r\nint output_value)\r\n{\r\nuint32_t bits = 0;\r\nif (command_channel_valid(channel) == 0)\r\nreturn 0;\r\nif (output) {\r\nbits |= 0x1 << (16 + channel);\r\nif (output_value)\r\nbits |= 0x1 << (24 + channel);\r\n} else\r\nbits |= 0x1 << (24 + channel);\r\nreturn bits;\r\n}\r\nuint32_t almost_full_bits(unsigned int num_words)\r\n{\r\nreturn (num_words << 16) & 0xff0000;\r\n}\r\nuint32_t almost_empty_bits(unsigned int num_words)\r\n{\r\nreturn num_words & 0xffff;\r\n}\r\nunsigned int almost_full_num_words(uint32_t bits)\r\n{\r\nreturn (bits >> 16) & 0xffff;\r\n}\r\nunsigned int almost_empty_num_words(uint32_t bits)\r\n{\r\nreturn bits & 0xffff;\r\n}\r\nint command_intr_source(unsigned int channel)\r\n{\r\nif (command_channel_valid(channel) == 0)\r\nchannel = 1;\r\nreturn channel + 1;\r\n}\r\nuint32_t intr_bit(int interrupt_source)\r\n{\r\nreturn 0x1 << interrupt_source;\r\n}\r\nuint32_t tx_clock_divisor_bits(unsigned int divisor)\r\n{\r\nreturn divisor & 0xff;\r\n}\r\nunsigned int fifo_size(uint32_t fifo_size_bits)\r\n{\r\nreturn fifo_size_bits & 0xfffff;\r\n}\r\nunsigned int fifo_words(uint32_t fifo_words_bits)\r\n{\r\nreturn fifo_words_bits & 0xfffff;\r\n}\r\nuint32_t intr_edge_bit(int interrupt_source)\r\n{\r\nreturn 0x1 << interrupt_source;\r\n}\r\nuint32_t intr_active_high_bit(int interrupt_source)\r\n{\r\nreturn 0x1 << interrupt_source;\r\n}\r\nstatic inline struct hpdi_board *board(const struct comedi_device *dev)\r\n{\r\nreturn (struct hpdi_board *)dev->board_ptr;\r\n}\r\nstatic inline struct hpdi_private *priv(struct comedi_device *dev)\r\n{\r\nreturn dev->private;\r\n}\r\nstatic int __devinit driver_hpdi_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_hpdi.driver_name);\r\n}\r\nstatic void __devexit driver_hpdi_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_hpdi_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_hpdi);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_hpdi_pci_driver.name = (char *)driver_hpdi.driver_name;\r\nreturn pci_register_driver(&driver_hpdi_pci_driver);\r\n}\r\nstatic void __exit driver_hpdi_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_hpdi_pci_driver);\r\ncomedi_driver_unregister(&driver_hpdi);\r\n}\r\nstatic int dio_config_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\npriv(dev)->dio_config_output = 1;\r\nreturn insn->n;\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\npriv(dev)->dio_config_output = 0;\r\nreturn insn->n;\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\npriv(dev)->dio_config_output ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ncase INSN_CONFIG_BLOCK_SIZE:\r\nreturn dio_config_block_size(dev, data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void disable_plx_interrupts(struct comedi_device *dev)\r\n{\r\nwritel(0, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);\r\n}\r\nstatic void init_plx9080(struct comedi_device *dev)\r\n{\r\nuint32_t bits;\r\nvoid *plx_iobase = priv(dev)->plx9080_iobase;\r\nDEBUG_PRINT(" plx interrupt status 0x%x\n",\r\nreadl(plx_iobase + PLX_INTRCS_REG));\r\nDEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));\r\nDEBUG_PRINT(" plx control reg 0x%x\n",\r\nreadl(priv(dev)->plx9080_iobase + PLX_CONTROL_REG));\r\nDEBUG_PRINT(" plx revision 0x%x\n",\r\nreadl(plx_iobase + PLX_REVISION_REG));\r\nDEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_MODE_REG));\r\nDEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA1_MODE_REG));\r\nDEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));\r\nDEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));\r\nDEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",\r\nreadb(plx_iobase + PLX_DMA0_CS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_THRESHOLD_REG));\r\nDEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));\r\n#ifdef __BIG_ENDIAN\r\nbits = BIGEND_DMA0 | BIGEND_DMA1;\r\n#else\r\nbits = 0;\r\n#endif\r\nwritel(bits, priv(dev)->plx9080_iobase + PLX_BIGEND_REG);\r\ndisable_plx_interrupts(dev);\r\nabort_dma(dev, 0);\r\nabort_dma(dev, 1);\r\nbits = 0;\r\nbits |= PLX_DMA_EN_READYIN_BIT;\r\nbits |= PLX_EN_CHAIN_BIT;\r\nbits |= PLX_EN_DMA_DONE_INTR_BIT;\r\nbits |= PLX_LOCAL_ADDR_CONST_BIT;\r\nbits |= PLX_DMA_INTR_PCI_BIT;\r\nbits |= PLX_DEMAND_MODE_BIT;\r\nbits |= PLX_DMA_LOCAL_BURST_EN_BIT;\r\nbits |= PLX_LOCAL_BUS_32_WIDE_BITS;\r\nwritel(bits, plx_iobase + PLX_DMA0_MODE_REG);\r\n}\r\nstatic int setup_subdevices(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nif (alloc_subdevices(dev, 1) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;\r\ns->n_chan = 32;\r\ns->len_chanlist = 32;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_config = dio_config_insn;\r\ns->do_cmd = hpdi_cmd;\r\ns->do_cmdtest = hpdi_cmd_test;\r\ns->cancel = hpdi_cancel;\r\nreturn 0;\r\n}\r\nstatic int init_hpdi(struct comedi_device *dev)\r\n{\r\nuint32_t plx_intcsr_bits;\r\nwritel(BOARD_RESET_BIT, priv(dev)->hpdi_iobase + BOARD_CONTROL_REG);\r\nudelay(10);\r\nwritel(almost_empty_bits(32) | almost_full_bits(32),\r\npriv(dev)->hpdi_iobase + RX_PROG_ALMOST_REG);\r\nwritel(almost_empty_bits(32) | almost_full_bits(32),\r\npriv(dev)->hpdi_iobase + TX_PROG_ALMOST_REG);\r\npriv(dev)->tx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +\r\nTX_FIFO_SIZE_REG));\r\npriv(dev)->rx_fifo_size = fifo_size(readl(priv(dev)->hpdi_iobase +\r\nRX_FIFO_SIZE_REG));\r\nwritel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);\r\nplx_intcsr_bits =\r\nICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |\r\nICS_DMA0_E;\r\nwritel(plx_intcsr_bits, priv(dev)->plx9080_iobase + PLX_INTRCS_REG);\r\nreturn 0;\r\n}\r\nstatic int setup_dma_descriptors(struct comedi_device *dev,\r\nunsigned int transfer_size)\r\n{\r\nunsigned int buffer_index, buffer_offset;\r\nuint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |\r\nPLX_XFER_LOCAL_TO_PCI;\r\nunsigned int i;\r\nif (transfer_size > DMA_BUFFER_SIZE)\r\ntransfer_size = DMA_BUFFER_SIZE;\r\ntransfer_size -= transfer_size % sizeof(uint32_t);\r\nif (transfer_size == 0)\r\nreturn -1;\r\nDEBUG_PRINT(" transfer_size %i\n", transfer_size);\r\nDEBUG_PRINT(" descriptors at 0x%lx\n",\r\n(unsigned long)priv(dev)->dma_desc_phys_addr);\r\nbuffer_offset = 0;\r\nbuffer_index = 0;\r\nfor (i = 0; i < NUM_DMA_DESCRIPTORS &&\r\nbuffer_index < NUM_DMA_BUFFERS; i++) {\r\npriv(dev)->dma_desc[i].pci_start_addr =\r\ncpu_to_le32(priv(dev)->dio_buffer_phys_addr[buffer_index] +\r\nbuffer_offset);\r\npriv(dev)->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);\r\npriv(dev)->dma_desc[i].transfer_size =\r\ncpu_to_le32(transfer_size);\r\npriv(dev)->dma_desc[i].next =\r\ncpu_to_le32((priv(dev)->dma_desc_phys_addr + (i +\r\n1) *\r\nsizeof(priv(dev)->dma_desc[0])) | next_bits);\r\npriv(dev)->desc_dio_buffer[i] =\r\npriv(dev)->dio_buffer[buffer_index] +\r\n(buffer_offset / sizeof(uint32_t));\r\nbuffer_offset += transfer_size;\r\nif (transfer_size + buffer_offset > DMA_BUFFER_SIZE) {\r\nbuffer_offset = 0;\r\nbuffer_index++;\r\n}\r\nDEBUG_PRINT(" desc %i\n", i);\r\nDEBUG_PRINT(" start addr virt 0x%p, phys 0x%lx\n",\r\npriv(dev)->desc_dio_buffer[i],\r\n(unsigned long)priv(dev)->dma_desc[i].\r\npci_start_addr);\r\nDEBUG_PRINT(" next 0x%lx\n",\r\n(unsigned long)priv(dev)->dma_desc[i].next);\r\n}\r\npriv(dev)->num_dma_descriptors = i;\r\npriv(dev)->dma_desc[i - 1].next =\r\ncpu_to_le32(priv(dev)->dma_desc_phys_addr | next_bits);\r\nDEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,\r\n(unsigned long)priv(dev)->dma_desc[i - 1].next);\r\npriv(dev)->block_size = transfer_size;\r\nreturn transfer_size;\r\n}\r\nstatic int hpdi_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct pci_dev *pcidev;\r\nint i;\r\nint retval;\r\nprintk(KERN_WARNING "comedi%d: gsc_hpdi\n", dev->minor);\r\nif (alloc_private(dev, sizeof(struct hpdi_private)) < 0)\r\nreturn -ENOMEM;\r\npcidev = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(hpdi_boards) &&\r\ndev->board_ptr == NULL; i++) {\r\ndo {\r\npcidev = pci_get_subsys(PCI_VENDOR_ID_PLX,\r\nhpdi_boards[i].device_id,\r\nPCI_VENDOR_ID_PLX,\r\nhpdi_boards[i].subdevice_id,\r\npcidev);\r\nif (it->options[0] || it->options[1]) {\r\nif (pcidev->bus->number != it->options[0] ||\r\nPCI_SLOT(pcidev->devfn) != it->options[1])\r\ncontinue;\r\n}\r\nif (pcidev) {\r\npriv(dev)->hw_dev = pcidev;\r\ndev->board_ptr = hpdi_boards + i;\r\nbreak;\r\n}\r\n} while (pcidev != NULL);\r\n}\r\nif (dev->board_ptr == NULL) {\r\nprintk(KERN_WARNING "gsc_hpdi: no hpdi card found\n");\r\nreturn -EIO;\r\n}\r\nprintk(KERN_WARNING\r\n"gsc_hpdi: found %s on bus %i, slot %i\n", board(dev)->name,\r\npcidev->bus->number, PCI_SLOT(pcidev->devfn));\r\nif (comedi_pci_enable(pcidev, driver_hpdi.driver_name)) {\r\nprintk(KERN_WARNING\r\n" failed enable PCI device and request regions\n");\r\nreturn -EIO;\r\n}\r\npci_set_master(pcidev);\r\ndev->board_name = board(dev)->name;\r\npriv(dev)->plx9080_phys_iobase =\r\npci_resource_start(pcidev, PLX9080_BADDRINDEX);\r\npriv(dev)->hpdi_phys_iobase =\r\npci_resource_start(pcidev, HPDI_BADDRINDEX);\r\npriv(dev)->plx9080_iobase = ioremap(priv(dev)->plx9080_phys_iobase,\r\npci_resource_len(pcidev,\r\nPLX9080_BADDRINDEX));\r\npriv(dev)->hpdi_iobase =\r\nioremap(priv(dev)->hpdi_phys_iobase,\r\npci_resource_len(pcidev, HPDI_BADDRINDEX));\r\nif (!priv(dev)->plx9080_iobase || !priv(dev)->hpdi_iobase) {\r\nprintk(KERN_WARNING " failed to remap io memory\n");\r\nreturn -ENOMEM;\r\n}\r\nDEBUG_PRINT(" plx9080 remapped to 0x%p\n", priv(dev)->plx9080_iobase);\r\nDEBUG_PRINT(" hpdi remapped to 0x%p\n", priv(dev)->hpdi_iobase);\r\ninit_plx9080(dev);\r\nif (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,\r\ndriver_hpdi.driver_name, dev)) {\r\nprintk(KERN_WARNING\r\n" unable to allocate irq %u\n", pcidev->irq);\r\nreturn -EINVAL;\r\n}\r\ndev->irq = pcidev->irq;\r\nprintk(KERN_WARNING " irq %u\n", dev->irq);\r\nfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\r\npriv(dev)->dio_buffer[i] =\r\npci_alloc_consistent(priv(dev)->hw_dev, DMA_BUFFER_SIZE,\r\n&priv(dev)->dio_buffer_phys_addr[i]);\r\nDEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",\r\npriv(dev)->dio_buffer[i],\r\n(unsigned long)priv(dev)->dio_buffer_phys_addr[i]);\r\n}\r\npriv(dev)->dma_desc = pci_alloc_consistent(priv(dev)->hw_dev,\r\nsizeof(struct plx_dma_desc) *\r\nNUM_DMA_DESCRIPTORS,\r\n&priv(dev)->\r\ndma_desc_phys_addr);\r\nif (priv(dev)->dma_desc_phys_addr & 0xf) {\r\nprintk(KERN_WARNING\r\n" dma descriptors not quad-word aligned (bug)\n");\r\nreturn -EIO;\r\n}\r\nretval = setup_dma_descriptors(dev, 0x1000);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = setup_subdevices(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn init_hpdi(dev);\r\n}\r\nstatic int hpdi_detach(struct comedi_device *dev)\r\n{\r\nunsigned int i;\r\nprintk(KERN_WARNING "comedi%d: gsc_hpdi: remove\n", dev->minor);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif ((priv(dev)) && (priv(dev)->hw_dev)) {\r\nif (priv(dev)->plx9080_iobase) {\r\ndisable_plx_interrupts(dev);\r\niounmap((void *)priv(dev)->plx9080_iobase);\r\n}\r\nif (priv(dev)->hpdi_iobase)\r\niounmap((void *)priv(dev)->hpdi_iobase);\r\nfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\r\nif (priv(dev)->dio_buffer[i])\r\npci_free_consistent(priv(dev)->hw_dev,\r\nDMA_BUFFER_SIZE,\r\npriv(dev)->\r\ndio_buffer[i],\r\npriv\r\n(dev)->dio_buffer_phys_addr\r\n[i]);\r\n}\r\nif (priv(dev)->dma_desc)\r\npci_free_consistent(priv(dev)->hw_dev,\r\nsizeof(struct plx_dma_desc)\r\n* NUM_DMA_DESCRIPTORS,\r\npriv(dev)->dma_desc,\r\npriv(dev)->\r\ndma_desc_phys_addr);\r\nif (priv(dev)->hpdi_phys_iobase)\r\ncomedi_pci_disable(priv(dev)->hw_dev);\r\npci_dev_put(priv(dev)->hw_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dio_config_block_size(struct comedi_device *dev, unsigned int *data)\r\n{\r\nunsigned int requested_block_size;\r\nint retval;\r\nrequested_block_size = data[1];\r\nretval = setup_dma_descriptors(dev, requested_block_size);\r\nif (retval < 0)\r\nreturn retval;\r\ndata[1] = retval;\r\nreturn 2;\r\n}\r\nstatic int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nint i;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 32;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (err)\r\nreturn 4;\r\nif (!cmd->chanlist)\r\nreturn 0;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) != i) {\r\ncomedi_error(dev,\r\n"chanlist must be ch 0 to 31 in order");\r\nerr++;\r\nbreak;\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nif (priv(dev)->dio_config_output)\r\nreturn -EINVAL;\r\nelse\r\nreturn di_cmd_test(dev, s, cmd);\r\n}\r\nstatic inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,\r\nunsigned int offset)\r\n{\r\nwritel(bits | priv(dev)->bits[offset / sizeof(uint32_t)],\r\npriv(dev)->hpdi_iobase + offset);\r\n}\r\nstatic int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nuint32_t bits;\r\nunsigned long flags;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nhpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);\r\nDEBUG_PRINT("hpdi: in di_cmd\n");\r\nabort_dma(dev, 0);\r\npriv(dev)->dma_desc_index = 0;\r\nwritel(0, priv(dev)->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);\r\nwritel(0, priv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);\r\nwritel(0, priv(dev)->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);\r\nbits =\r\npriv(dev)->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |\r\nPLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;\r\nwritel(bits, priv(dev)->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nwriteb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (cmd->stop_src == TRIG_COUNT)\r\npriv(dev)->dio_count = cmd->stop_arg;\r\nelse\r\npriv(dev)->dio_count = 1;\r\nwritel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,\r\npriv(dev)->hpdi_iobase + BOARD_STATUS_REG);\r\nwritel(intr_bit(RX_FULL_INTR),\r\npriv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);\r\nDEBUG_PRINT("hpdi: starting rx\n");\r\nhpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);\r\nreturn 0;\r\n}\r\nstatic int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nif (priv(dev)->dio_config_output)\r\nreturn -EINVAL;\r\nelse\r\nreturn di_cmd(dev, s);\r\n}\r\nstatic void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)\r\n{\r\nstruct comedi_async *async = dev->read_subdev->async;\r\nuint32_t next_transfer_addr;\r\nint j;\r\nint num_samples = 0;\r\nvoid *pci_addr_reg;\r\nif (channel)\r\npci_addr_reg =\r\npriv(dev)->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;\r\nelse\r\npci_addr_reg =\r\npriv(dev)->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;\r\nj = 0;\r\nfor (next_transfer_addr = readl(pci_addr_reg);\r\n(next_transfer_addr <\r\nle32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].\r\npci_start_addr)\r\n|| next_transfer_addr >=\r\nle32_to_cpu(priv(dev)->dma_desc[priv(dev)->dma_desc_index].\r\npci_start_addr) + priv(dev)->block_size)\r\n&& j < priv(dev)->num_dma_descriptors; j++) {\r\nnum_samples = priv(dev)->block_size / sizeof(uint32_t);\r\nif (async->cmd.stop_src == TRIG_COUNT) {\r\nif (num_samples > priv(dev)->dio_count)\r\nnum_samples = priv(dev)->dio_count;\r\npriv(dev)->dio_count -= num_samples;\r\n}\r\ncfc_write_array_to_buffer(dev->read_subdev,\r\npriv(dev)->desc_dio_buffer[priv(dev)->\r\ndma_desc_index],\r\nnum_samples * sizeof(uint32_t));\r\npriv(dev)->dma_desc_index++;\r\npriv(dev)->dma_desc_index %= priv(dev)->num_dma_descriptors;\r\nDEBUG_PRINT("next desc addr 0x%lx\n", (unsigned long)\r\npriv(dev)->dma_desc[priv(dev)->dma_desc_index].\r\nnext);\r\nDEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);\r\n}\r\n}\r\nstatic irqreturn_t handle_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nuint32_t hpdi_intr_status, hpdi_board_status;\r\nuint32_t plx_status;\r\nuint32_t plx_bits;\r\nuint8_t dma0_status, dma1_status;\r\nunsigned long flags;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nplx_status = readl(priv(dev)->plx9080_iobase + PLX_INTRCS_REG);\r\nif ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)\r\nreturn IRQ_NONE;\r\nhpdi_intr_status = readl(priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);\r\nhpdi_board_status = readl(priv(dev)->hpdi_iobase + BOARD_STATUS_REG);\r\nasync->events = 0;\r\nif (hpdi_intr_status) {\r\nDEBUG_PRINT("hpdi: intr status 0x%x, ", hpdi_intr_status);\r\nwritel(hpdi_intr_status,\r\npriv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nif (plx_status & ICS_DMA0_A) {\r\nwriteb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);\r\nDEBUG_PRINT("dma0 status 0x%x\n", dma0_status);\r\nif (dma0_status & PLX_DMA_EN_BIT)\r\ndrain_dma_buffers(dev, 0);\r\nDEBUG_PRINT(" cleared dma ch0 interrupt\n");\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);\r\nif (plx_status & ICS_DMA1_A) {\r\nwriteb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\npriv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);\r\nDEBUG_PRINT("dma1 status 0x%x\n", dma1_status);\r\nDEBUG_PRINT(" cleared dma ch1 interrupt\n");\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (plx_status & ICS_LDIA) {\r\nplx_bits = readl(priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);\r\nwritel(plx_bits, priv(dev)->plx9080_iobase + PLX_DBR_OUT_REG);\r\nDEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);\r\n}\r\nif (hpdi_board_status & RX_OVERRUN_BIT) {\r\ncomedi_error(dev, "rx fifo overrun");\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\nDEBUG_PRINT("dma0_status 0x%x\n",\r\n(int)readb(priv(dev)->plx9080_iobase +\r\nPLX_DMA0_CS_REG));\r\n}\r\nif (hpdi_board_status & RX_UNDERRUN_BIT) {\r\ncomedi_error(dev, "rx fifo underrun");\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\n}\r\nif (priv(dev)->dio_count == 0)\r\nasync->events |= COMEDI_CB_EOA;\r\nDEBUG_PRINT("board status 0x%x, ", hpdi_board_status);\r\nDEBUG_PRINT("plx status 0x%x\n", plx_status);\r\nif (async->events)\r\nDEBUG_PRINT(" events 0x%x\n", async->events);\r\ncfc_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void abort_dma(struct comedi_device *dev, unsigned int channel)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nplx9080_abort_dma(priv(dev)->plx9080_iobase, channel);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nhpdi_writel(dev, 0, BOARD_CONTROL_REG);\r\nwritel(0, priv(dev)->hpdi_iobase + INTERRUPT_CONTROL_REG);\r\nabort_dma(dev, 0);\r\nreturn 0;\r\n}
