static int qt1070_read(struct i2c_client *client, u8 reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ndev_err(&client->dev,\r\n"can not read register, returned %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int qt1070_write(struct i2c_client *client, u8 reg, u8 data)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, reg, data);\r\nif (ret < 0)\r\ndev_err(&client->dev,\r\n"can not write register, returned %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic bool __devinit qt1070_identify(struct i2c_client *client)\r\n{\r\nint id, ver;\r\nid = qt1070_read(client, CHIP_ID);\r\nif (id != QT1070_CHIP_ID) {\r\ndev_err(&client->dev, "ID %d not supported\n", id);\r\nreturn false;\r\n}\r\nver = qt1070_read(client, FW_VERSION);\r\nif (ver < 0) {\r\ndev_err(&client->dev, "could not read the firmware version\n");\r\nreturn false;\r\n}\r\ndev_info(&client->dev, "AT42QT1070 firmware version %x\n", ver);\r\nreturn true;\r\n}\r\nstatic irqreturn_t qt1070_interrupt(int irq, void *dev_id)\r\n{\r\nstruct qt1070_data *data = dev_id;\r\nstruct i2c_client *client = data->client;\r\nstruct input_dev *input = data->input;\r\nint i;\r\nu8 new_keys, keyval, mask = 0x01;\r\nqt1070_read(client, DET_STATUS);\r\nnew_keys = qt1070_read(client, KEY_STATUS);\r\nfor (i = 0; i < ARRAY_SIZE(qt1070_key2code); i++) {\r\nkeyval = new_keys & mask;\r\nif ((data->last_keys & mask) != keyval)\r\ninput_report_key(input, data->keycodes[i], keyval);\r\nmask <<= 1;\r\n}\r\ninput_sync(input);\r\ndata->last_keys = new_keys;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit qt1070_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct qt1070_data *data;\r\nstruct input_dev *input;\r\nint i;\r\nint err;\r\nerr = i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE);\r\nif (!err) {\r\ndev_err(&client->dev, "%s adapter not supported\n",\r\ndev_driver_string(&client->adapter->dev));\r\nreturn -ENODEV;\r\n}\r\nif (!client->irq) {\r\ndev_err(&client->dev, "please assign the irq to this device\n");\r\nreturn -EINVAL;\r\n}\r\nif (!qt1070_identify(client))\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(struct qt1070_data), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!data || !input) {\r\ndev_err(&client->dev, "insufficient memory\n");\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ndata->client = client;\r\ndata->input = input;\r\ndata->irq = client->irq;\r\ninput->name = "AT42QT1070 QTouch Sensor";\r\ninput->dev.parent = &client->dev;\r\ninput->id.bustype = BUS_I2C;\r\ninput->keycode = data->keycodes;\r\ninput->keycodesize = sizeof(data->keycodes[0]);\r\ninput->keycodemax = ARRAY_SIZE(qt1070_key2code);\r\n__set_bit(EV_KEY, input->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(qt1070_key2code); i++) {\r\ndata->keycodes[i] = qt1070_key2code[i];\r\n__set_bit(qt1070_key2code[i], input->keybit);\r\n}\r\nqt1070_write(client, CALIBRATE_CMD, 1);\r\nmsleep(QT1070_CAL_TIME);\r\nqt1070_write(client, RESET, 1);\r\nmsleep(QT1070_RESET_TIME);\r\nerr = request_threaded_irq(client->irq, NULL, qt1070_interrupt,\r\nIRQF_TRIGGER_NONE, client->dev.driver->name, data);\r\nif (err) {\r\ndev_err(&client->dev, "fail to request irq\n");\r\ngoto err_free_mem;\r\n}\r\nerr = input_register_device(data->input);\r\nif (err) {\r\ndev_err(&client->dev, "Failed to register input device\n");\r\ngoto err_free_irq;\r\n}\r\ni2c_set_clientdata(client, data);\r\nqt1070_read(client, DET_STATUS);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, data);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int __devexit qt1070_remove(struct i2c_client *client)\r\n{\r\nstruct qt1070_data *data = i2c_get_clientdata(client);\r\nfree_irq(client->irq, data);\r\ninput_unregister_device(data->input);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init qt1070_init(void)\r\n{\r\nreturn i2c_add_driver(&qt1070_driver);\r\n}\r\nstatic void __exit qt1070_exit(void)\r\n{\r\ni2c_del_driver(&qt1070_driver);\r\n}
