STATIC xfs_dahash_t\r\nxfs_ascii_ci_hashname(\r\nstruct xfs_name *name)\r\n{\r\nxfs_dahash_t hash;\r\nint i;\r\nfor (i = 0, hash = 0; i < name->len; i++)\r\nhash = tolower(name->name[i]) ^ rol32(hash, 7);\r\nreturn hash;\r\n}\r\nSTATIC enum xfs_dacmp\r\nxfs_ascii_ci_compname(\r\nstruct xfs_da_args *args,\r\nconst unsigned char *name,\r\nint len)\r\n{\r\nenum xfs_dacmp result;\r\nint i;\r\nif (args->namelen != len)\r\nreturn XFS_CMP_DIFFERENT;\r\nresult = XFS_CMP_EXACT;\r\nfor (i = 0; i < len; i++) {\r\nif (args->name[i] == name[i])\r\ncontinue;\r\nif (tolower(args->name[i]) != tolower(name[i]))\r\nreturn XFS_CMP_DIFFERENT;\r\nresult = XFS_CMP_CASE;\r\n}\r\nreturn result;\r\n}\r\nvoid\r\nxfs_dir_mount(\r\nxfs_mount_t *mp)\r\n{\r\nASSERT(xfs_sb_version_hasdirv2(&mp->m_sb));\r\nASSERT((1 << (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog)) <=\r\nXFS_MAX_BLOCKSIZE);\r\nmp->m_dirblksize = 1 << (mp->m_sb.sb_blocklog + mp->m_sb.sb_dirblklog);\r\nmp->m_dirblkfsbs = 1 << mp->m_sb.sb_dirblklog;\r\nmp->m_dirdatablk = xfs_dir2_db_to_da(mp, XFS_DIR2_DATA_FIRSTDB(mp));\r\nmp->m_dirleafblk = xfs_dir2_db_to_da(mp, XFS_DIR2_LEAF_FIRSTDB(mp));\r\nmp->m_dirfreeblk = xfs_dir2_db_to_da(mp, XFS_DIR2_FREE_FIRSTDB(mp));\r\nmp->m_attr_node_ents =\r\n(mp->m_sb.sb_blocksize - (uint)sizeof(xfs_da_node_hdr_t)) /\r\n(uint)sizeof(xfs_da_node_entry_t);\r\nmp->m_dir_node_ents =\r\n(mp->m_dirblksize - (uint)sizeof(xfs_da_node_hdr_t)) /\r\n(uint)sizeof(xfs_da_node_entry_t);\r\nmp->m_dir_magicpct = (mp->m_dirblksize * 37) / 100;\r\nif (xfs_sb_version_hasasciici(&mp->m_sb))\r\nmp->m_dirnameops = &xfs_ascii_ci_nameops;\r\nelse\r\nmp->m_dirnameops = &xfs_default_nameops;\r\n}\r\nint\r\nxfs_dir_isempty(\r\nxfs_inode_t *dp)\r\n{\r\nxfs_dir2_sf_hdr_t *sfp;\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nif (dp->i_d.di_size == 0)\r\nreturn 1;\r\nif (dp->i_d.di_size > XFS_IFORK_DSIZE(dp))\r\nreturn 0;\r\nsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\r\nreturn !sfp->count;\r\n}\r\nint\r\nxfs_dir_ino_validate(\r\nxfs_mount_t *mp,\r\nxfs_ino_t ino)\r\n{\r\nxfs_agblock_t agblkno;\r\nxfs_agino_t agino;\r\nxfs_agnumber_t agno;\r\nint ino_ok;\r\nint ioff;\r\nagno = XFS_INO_TO_AGNO(mp, ino);\r\nagblkno = XFS_INO_TO_AGBNO(mp, ino);\r\nioff = XFS_INO_TO_OFFSET(mp, ino);\r\nagino = XFS_OFFBNO_TO_AGINO(mp, agblkno, ioff);\r\nino_ok =\r\nagno < mp->m_sb.sb_agcount &&\r\nagblkno < mp->m_sb.sb_agblocks &&\r\nagblkno != 0 &&\r\nioff < (1 << mp->m_sb.sb_inopblog) &&\r\nXFS_AGINO_TO_INO(mp, agno, agino) == ino;\r\nif (unlikely(XFS_TEST_ERROR(!ino_ok, mp, XFS_ERRTAG_DIR_INO_VALIDATE,\r\nXFS_RANDOM_DIR_INO_VALIDATE))) {\r\nxfs_warn(mp, "Invalid inode number 0x%Lx",\r\n(unsigned long long) ino);\r\nXFS_ERROR_REPORT("xfs_dir_ino_validate", XFS_ERRLEVEL_LOW, mp);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir_init(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nxfs_inode_t *pdp)\r\n{\r\nxfs_da_args_t args;\r\nint error;\r\nmemset((char *)&args, 0, sizeof(args));\r\nargs.dp = dp;\r\nargs.trans = tp;\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nif ((error = xfs_dir_ino_validate(tp->t_mountp, pdp->i_ino)))\r\nreturn error;\r\nreturn xfs_dir2_sf_create(&args, pdp->i_ino);\r\n}\r\nint\r\nxfs_dir_createname(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\nxfs_ino_t inum,\r\nxfs_fsblock_t *first,\r\nxfs_bmap_free_t *flist,\r\nxfs_extlen_t total)\r\n{\r\nxfs_da_args_t args;\r\nint rval;\r\nint v;\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nif ((rval = xfs_dir_ino_validate(tp->t_mountp, inum)))\r\nreturn rval;\r\nXFS_STATS_INC(xs_dir_create);\r\nmemset(&args, 0, sizeof(xfs_da_args_t));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.hashval = dp->i_mount->m_dirnameops->hashname(name);\r\nargs.inumber = inum;\r\nargs.dp = dp;\r\nargs.firstblock = first;\r\nargs.flist = flist;\r\nargs.total = total;\r\nargs.whichfork = XFS_DATA_FORK;\r\nargs.trans = tp;\r\nargs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\r\nif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\r\nrval = xfs_dir2_sf_addname(&args);\r\nelse if ((rval = xfs_dir2_isblock(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_block_addname(&args);\r\nelse if ((rval = xfs_dir2_isleaf(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_leaf_addname(&args);\r\nelse\r\nrval = xfs_dir2_node_addname(&args);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir_cilookup_result(\r\nstruct xfs_da_args *args,\r\nconst unsigned char *name,\r\nint len)\r\n{\r\nif (args->cmpresult == XFS_CMP_DIFFERENT)\r\nreturn ENOENT;\r\nif (args->cmpresult != XFS_CMP_CASE ||\r\n!(args->op_flags & XFS_DA_OP_CILOOKUP))\r\nreturn EEXIST;\r\nargs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\r\nif (!args->value)\r\nreturn ENOMEM;\r\nmemcpy(args->value, name, len);\r\nargs->valuelen = len;\r\nreturn EEXIST;\r\n}\r\nint\r\nxfs_dir_lookup(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\nxfs_ino_t *inum,\r\nstruct xfs_name *ci_name)\r\n{\r\nxfs_da_args_t args;\r\nint rval;\r\nint v;\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nXFS_STATS_INC(xs_dir_lookup);\r\nmemset(&args, 0, sizeof(xfs_da_args_t));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.hashval = dp->i_mount->m_dirnameops->hashname(name);\r\nargs.dp = dp;\r\nargs.whichfork = XFS_DATA_FORK;\r\nargs.trans = tp;\r\nargs.op_flags = XFS_DA_OP_OKNOENT;\r\nif (ci_name)\r\nargs.op_flags |= XFS_DA_OP_CILOOKUP;\r\nif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\r\nrval = xfs_dir2_sf_lookup(&args);\r\nelse if ((rval = xfs_dir2_isblock(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_block_lookup(&args);\r\nelse if ((rval = xfs_dir2_isleaf(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_leaf_lookup(&args);\r\nelse\r\nrval = xfs_dir2_node_lookup(&args);\r\nif (rval == EEXIST)\r\nrval = 0;\r\nif (!rval) {\r\n*inum = args.inumber;\r\nif (ci_name) {\r\nci_name->name = args.value;\r\nci_name->len = args.valuelen;\r\n}\r\n}\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir_removename(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\nxfs_ino_t ino,\r\nxfs_fsblock_t *first,\r\nxfs_bmap_free_t *flist,\r\nxfs_extlen_t total)\r\n{\r\nxfs_da_args_t args;\r\nint rval;\r\nint v;\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nXFS_STATS_INC(xs_dir_remove);\r\nmemset(&args, 0, sizeof(xfs_da_args_t));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.hashval = dp->i_mount->m_dirnameops->hashname(name);\r\nargs.inumber = ino;\r\nargs.dp = dp;\r\nargs.firstblock = first;\r\nargs.flist = flist;\r\nargs.total = total;\r\nargs.whichfork = XFS_DATA_FORK;\r\nargs.trans = tp;\r\nif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\r\nrval = xfs_dir2_sf_removename(&args);\r\nelse if ((rval = xfs_dir2_isblock(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_block_removename(&args);\r\nelse if ((rval = xfs_dir2_isleaf(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_leaf_removename(&args);\r\nelse\r\nrval = xfs_dir2_node_removename(&args);\r\nreturn rval;\r\n}\r\nint\r\nxfs_readdir(\r\nxfs_inode_t *dp,\r\nvoid *dirent,\r\nsize_t bufsize,\r\nxfs_off_t *offset,\r\nfilldir_t filldir)\r\n{\r\nint rval;\r\nint v;\r\ntrace_xfs_readdir(dp);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn XFS_ERROR(EIO);\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nXFS_STATS_INC(xs_dir_getdents);\r\nif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\r\nrval = xfs_dir2_sf_getdents(dp, dirent, offset, filldir);\r\nelse if ((rval = xfs_dir2_isblock(NULL, dp, &v)))\r\n;\r\nelse if (v)\r\nrval = xfs_dir2_block_getdents(dp, dirent, offset, filldir);\r\nelse\r\nrval = xfs_dir2_leaf_getdents(dp, dirent, bufsize, offset,\r\nfilldir);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir_replace(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\nxfs_ino_t inum,\r\nxfs_fsblock_t *first,\r\nxfs_bmap_free_t *flist,\r\nxfs_extlen_t total)\r\n{\r\nxfs_da_args_t args;\r\nint rval;\r\nint v;\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nif ((rval = xfs_dir_ino_validate(tp->t_mountp, inum)))\r\nreturn rval;\r\nmemset(&args, 0, sizeof(xfs_da_args_t));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.hashval = dp->i_mount->m_dirnameops->hashname(name);\r\nargs.inumber = inum;\r\nargs.dp = dp;\r\nargs.firstblock = first;\r\nargs.flist = flist;\r\nargs.total = total;\r\nargs.whichfork = XFS_DATA_FORK;\r\nargs.trans = tp;\r\nif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\r\nrval = xfs_dir2_sf_replace(&args);\r\nelse if ((rval = xfs_dir2_isblock(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_block_replace(&args);\r\nelse if ((rval = xfs_dir2_isleaf(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_leaf_replace(&args);\r\nelse\r\nrval = xfs_dir2_node_replace(&args);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir_canenter(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\nuint resblks)\r\n{\r\nxfs_da_args_t args;\r\nint rval;\r\nint v;\r\nif (resblks)\r\nreturn 0;\r\nASSERT(S_ISDIR(dp->i_d.di_mode));\r\nmemset(&args, 0, sizeof(xfs_da_args_t));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.hashval = dp->i_mount->m_dirnameops->hashname(name);\r\nargs.dp = dp;\r\nargs.whichfork = XFS_DATA_FORK;\r\nargs.trans = tp;\r\nargs.op_flags = XFS_DA_OP_JUSTCHECK | XFS_DA_OP_ADDNAME |\r\nXFS_DA_OP_OKNOENT;\r\nif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\r\nrval = xfs_dir2_sf_addname(&args);\r\nelse if ((rval = xfs_dir2_isblock(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_block_addname(&args);\r\nelse if ((rval = xfs_dir2_isleaf(tp, dp, &v)))\r\nreturn rval;\r\nelse if (v)\r\nrval = xfs_dir2_leaf_addname(&args);\r\nelse\r\nrval = xfs_dir2_node_addname(&args);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir2_grow_inode(\r\nstruct xfs_da_args *args,\r\nint space,\r\nxfs_dir2_db_t *dbp)\r\n{\r\nstruct xfs_inode *dp = args->dp;\r\nstruct xfs_mount *mp = dp->i_mount;\r\nxfs_fileoff_t bno;\r\nint count;\r\nint error;\r\ntrace_xfs_dir2_grow_inode(args, space);\r\nbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\r\ncount = mp->m_dirblkfsbs;\r\nerror = xfs_da_grow_inode_int(args, &bno, count);\r\nif (error)\r\nreturn error;\r\n*dbp = xfs_dir2_da_to_db(mp, (xfs_dablk_t)bno);\r\nif (space == XFS_DIR2_DATA_SPACE) {\r\nxfs_fsize_t size;\r\nsize = XFS_FSB_TO_B(mp, bno + count);\r\nif (size > dp->i_d.di_size) {\r\ndp->i_d.di_size = size;\r\nxfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir2_isblock(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nint *vp)\r\n{\r\nxfs_fileoff_t last;\r\nxfs_mount_t *mp;\r\nint rval;\r\nmp = dp->i_mount;\r\nif ((rval = xfs_bmap_last_offset(tp, dp, &last, XFS_DATA_FORK)))\r\nreturn rval;\r\nrval = XFS_FSB_TO_B(mp, last) == mp->m_dirblksize;\r\nASSERT(rval == 0 || dp->i_d.di_size == mp->m_dirblksize);\r\n*vp = rval;\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir2_isleaf(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *dp,\r\nint *vp)\r\n{\r\nxfs_fileoff_t last;\r\nxfs_mount_t *mp;\r\nint rval;\r\nmp = dp->i_mount;\r\nif ((rval = xfs_bmap_last_offset(tp, dp, &last, XFS_DATA_FORK)))\r\nreturn rval;\r\n*vp = last == mp->m_dirleafblk + (1 << mp->m_sb.sb_dirblklog);\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir2_shrink_inode(\r\nxfs_da_args_t *args,\r\nxfs_dir2_db_t db,\r\nxfs_dabuf_t *bp)\r\n{\r\nxfs_fileoff_t bno;\r\nxfs_dablk_t da;\r\nint done;\r\nxfs_inode_t *dp;\r\nint error;\r\nxfs_mount_t *mp;\r\nxfs_trans_t *tp;\r\ntrace_xfs_dir2_shrink_inode(args, db);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nda = xfs_dir2_db_to_da(mp, db);\r\nif ((error = xfs_bunmapi(tp, dp, da, mp->m_dirblkfsbs,\r\nXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\r\n&done))) {\r\nreturn error;\r\n}\r\nASSERT(done);\r\nxfs_da_binval(tp, bp);\r\nif (db >= XFS_DIR2_LEAF_FIRSTDB(mp))\r\nreturn 0;\r\nif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(mp, db + 1, 0))\r\nreturn 0;\r\nbno = da;\r\nif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\r\nreturn error;\r\n}\r\nif (db == mp->m_dirdatablk)\r\nASSERT(bno == 0);\r\nelse\r\nASSERT(bno > 0);\r\ndp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\r\nxfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\r\nreturn 0;\r\n}
