static int spcp8x5_startup(struct usb_serial *serial)\r\n{\r\nstruct spcp8x5_private *priv;\r\nint i;\r\nenum spcp8x5_type type = SPCP825_007_TYPE;\r\nu16 product = le16_to_cpu(serial->dev->descriptor.idProduct);\r\nif (product == 0x0201)\r\ntype = SPCP825_007_TYPE;\r\nelse if (product == 0x0231)\r\ntype = SPCP835_TYPE;\r\nelse if (product == 0x0235)\r\ntype = SPCP825_008_TYPE;\r\nelse if (product == 0x0204)\r\ntype = SPCP825_INTERMATIC_TYPE;\r\nelse if (product == 0x0471 &&\r\nserial->dev->descriptor.idVendor == cpu_to_le16(0x081e))\r\ntype = SPCP825_PHILIP_TYPE;\r\ndev_dbg(&serial->dev->dev, "device type = %d\n", (int)type);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\npriv = kzalloc(sizeof(struct spcp8x5_private), GFP_KERNEL);\r\nif (!priv)\r\ngoto cleanup;\r\nspin_lock_init(&priv->lock);\r\ninit_waitqueue_head(&priv->delta_msr_wait);\r\npriv->type = type;\r\nusb_set_serial_port_data(serial->port[i] , priv);\r\n}\r\nreturn 0;\r\ncleanup:\r\nfor (--i; i >= 0; --i) {\r\npriv = usb_get_serial_port_data(serial->port[i]);\r\nkfree(priv);\r\nusb_set_serial_port_data(serial->port[i] , NULL);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void spcp8x5_release(struct usb_serial *serial)\r\n{\r\nint i;\r\nfor (i = 0; i < serial->num_ports; i++)\r\nkfree(usb_get_serial_port_data(serial->port[i]));\r\n}\r\nstatic int spcp8x5_set_ctrlLine(struct usb_device *dev, u8 value,\r\nenum spcp8x5_type type)\r\n{\r\nint retval;\r\nu8 mcr = 0 ;\r\nif (type == SPCP825_007_TYPE)\r\nreturn -EPERM;\r\nmcr = (unsigned short)value;\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nSET_UART_STATUS_TYPE, SET_UART_STATUS,\r\nmcr, 0x04, NULL, 0, 100);\r\nif (retval != 0)\r\ndev_dbg(&dev->dev, "usb_control_msg return %#x\n", retval);\r\nreturn retval;\r\n}\r\nstatic int spcp8x5_get_msr(struct usb_device *dev, u8 *status,\r\nenum spcp8x5_type type)\r\n{\r\nu8 *status_buffer;\r\nint ret;\r\nif (type == SPCP825_007_TYPE)\r\nreturn -EPERM;\r\nif (status == NULL)\r\nreturn -EINVAL;\r\nstatus_buffer = kmalloc(1, GFP_KERNEL);\r\nif (!status_buffer)\r\nreturn -ENOMEM;\r\nstatus_buffer[0] = status[0];\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nGET_UART_STATUS, GET_UART_STATUS_TYPE,\r\n0, GET_UART_STATUS_MSR, status_buffer, 1, 100);\r\nif (ret < 0)\r\ndev_dbg(&dev->dev, "Get MSR = 0x%p failed (error = %d)",\r\nstatus_buffer, ret);\r\ndev_dbg(&dev->dev, "0xc0:0x22:0:6 %d - 0x%p ", ret, status_buffer);\r\nstatus[0] = status_buffer[0];\r\nkfree(status_buffer);\r\nreturn ret;\r\n}\r\nstatic void spcp8x5_set_workMode(struct usb_device *dev, u16 value,\r\nu16 index, enum spcp8x5_type type)\r\n{\r\nint ret;\r\nif (type == SPCP825_007_TYPE)\r\nreturn;\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nSET_WORKING_MODE_TYPE, SET_WORKING_MODE,\r\nvalue, index, NULL, 0, 100);\r\ndev_dbg(&dev->dev, "value = %#x , index = %#x\n", value, index);\r\nif (ret < 0)\r\ndev_dbg(&dev->dev,\r\n"RTSCTS usb_control_msg(enable flowctrl) = %d\n", ret);\r\n}\r\nstatic int spcp8x5_carrier_raised(struct usb_serial_port *port)\r\n{\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nif (priv->line_status & MSR_STATUS_LINE_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void spcp8x5_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (on)\r\npriv->line_control = MCR_CONTROL_LINE_DTR\r\n| MCR_CONTROL_LINE_RTS;\r\nelse\r\npriv->line_control &= ~ (MCR_CONTROL_LINE_DTR\r\n| MCR_CONTROL_LINE_RTS);\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nspcp8x5_set_ctrlLine(port->serial->dev, control , priv->type);\r\n}\r\nstatic void spcp8x5_init_termios(struct tty_struct *tty)\r\n{\r\n*(tty->termios) = tty_std_termios;\r\ntty->termios->c_cflag = B115200 | CS8 | CREAD | HUPCL | CLOCAL;\r\ntty->termios->c_ispeed = 115200;\r\ntty->termios->c_ospeed = 115200;\r\n}\r\nstatic void spcp8x5_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int cflag = tty->termios->c_cflag;\r\nunsigned int old_cflag = old_termios->c_cflag;\r\nunsigned short uartdata;\r\nunsigned char buf[2] = {0, 0};\r\nint baud;\r\nint i;\r\nu8 control;\r\nif (!tty_termios_hw_change(tty->termios, old_termios))\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol = priv->line_control;\r\nif ((old_cflag & CBAUD) == B0) {\r\npriv->line_control |= MCR_DTR;\r\nif (!(old_cflag & CRTSCTS))\r\npriv->line_control |= MCR_RTS;\r\n}\r\nif (control != priv->line_control) {\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nspcp8x5_set_ctrlLine(serial->dev, control , priv->type);\r\n} else {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nswitch (baud) {\r\ncase 300: buf[0] = 0x00; break;\r\ncase 600: buf[0] = 0x01; break;\r\ncase 1200: buf[0] = 0x02; break;\r\ncase 2400: buf[0] = 0x03; break;\r\ncase 4800: buf[0] = 0x04; break;\r\ncase 9600: buf[0] = 0x05; break;\r\ncase 19200: buf[0] = 0x07; break;\r\ncase 38400: buf[0] = 0x09; break;\r\ncase 57600: buf[0] = 0x0a; break;\r\ncase 115200: buf[0] = 0x0b; break;\r\ncase 230400: buf[0] = 0x0c; break;\r\ncase 460800: buf[0] = 0x0d; break;\r\ncase 921600: buf[0] = 0x0e; break;\r\ncase 3000000: buf[0] = 0x11; break;\r\ncase 0:\r\ncase 1000000:\r\nbuf[0] = 0x0b; break;\r\ndefault:\r\ndev_err(&port->dev, "spcp825 driver does not support the "\r\n"baudrate requested, using default of 9600.\n");\r\n}\r\nif (cflag & CSIZE) {\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nbuf[1] |= SET_UART_FORMAT_SIZE_5;\r\nbreak;\r\ncase CS6:\r\nbuf[1] |= SET_UART_FORMAT_SIZE_6;\r\nbreak;\r\ncase CS7:\r\nbuf[1] |= SET_UART_FORMAT_SIZE_7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nbuf[1] |= SET_UART_FORMAT_SIZE_8;\r\nbreak;\r\n}\r\n}\r\nbuf[1] |= (cflag & CSTOPB) ? SET_UART_FORMAT_STOP_2 :\r\nSET_UART_FORMAT_STOP_1;\r\nif (cflag & PARENB) {\r\nbuf[1] |= (cflag & PARODD) ?\r\nSET_UART_FORMAT_PAR_ODD : SET_UART_FORMAT_PAR_EVEN ;\r\n} else\r\nbuf[1] |= SET_UART_FORMAT_PAR_NONE;\r\nuartdata = buf[0] | buf[1]<<8;\r\ni = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nSET_UART_FORMAT_TYPE, SET_UART_FORMAT,\r\nuartdata, 0, NULL, 0, 100);\r\nif (i < 0)\r\ndev_err(&port->dev, "Set UART format %#x failed (error = %d)\n",\r\nuartdata, i);\r\ndbg("0x21:0x40:0:0 %d", i);\r\nif (cflag & CRTSCTS) {\r\nspcp8x5_set_workMode(serial->dev, 0x000a,\r\nSET_WORKING_MODE_U2C, priv->type);\r\n}\r\n}\r\nstatic int spcp8x5_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct ktermios tmp_termios;\r\nstruct usb_serial *serial = port->serial;\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nint ret;\r\nunsigned long flags;\r\nu8 status = 0x30;\r\ndbg("%s - port %d", __func__, port->number);\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nret = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n0x09, 0x00,\r\n0x01, 0x00, NULL, 0x00, 100);\r\nif (ret)\r\nreturn ret;\r\nspcp8x5_set_ctrlLine(serial->dev, priv->line_control , priv->type);\r\nif (tty)\r\nspcp8x5_set_termios(tty, port, &tmp_termios);\r\nspcp8x5_get_msr(serial->dev, &status, priv->type);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->line_status = status & 0xf0 ;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nport->port.drain_delay = 256;\r\nreturn usb_serial_generic_open(tty, port);\r\n}\r\nstatic void spcp8x5_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned long flags;\r\nu8 status;\r\nchar tty_flag;\r\ntty_flag = TTY_NORMAL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = priv->line_status;\r\npriv->line_status &= ~UART_STATE_TRANSIENT_MASK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\nif (!urb->actual_length)\r\nreturn;\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\nif (status & UART_STATE_TRANSIENT_MASK) {\r\nif (status & UART_BREAK_ERROR)\r\ntty_flag = TTY_BREAK;\r\nelse if (status & UART_PARITY_ERROR)\r\ntty_flag = TTY_PARITY;\r\nelse if (status & UART_FRAME_ERROR)\r\ntty_flag = TTY_FRAME;\r\ndev_dbg(&port->dev, "tty_flag = %d\n", tty_flag);\r\nif (status & UART_OVERRUN_ERROR)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nif (status & UART_DCD)\r\nusb_serial_handle_dcd_change(port, tty,\r\npriv->line_status & MSR_STATUS_LINE_DCD);\r\n}\r\ntty_insert_flip_string_fixed_flag(tty, data, tty_flag,\r\nurb->actual_length);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int spcp8x5_wait_modem_info(struct usb_serial_port *port,\r\nunsigned int arg)\r\n{\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int prevstatus;\r\nunsigned int status;\r\nunsigned int changed;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nprevstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwhile (1) {\r\ninterruptible_sleep_on(&priv->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nchanged = prevstatus^status;\r\nif (((arg & TIOCM_RNG) && (changed & MSR_STATUS_LINE_RI)) ||\r\n((arg & TIOCM_DSR) && (changed & MSR_STATUS_LINE_DSR)) ||\r\n((arg & TIOCM_CD) && (changed & MSR_STATUS_LINE_DCD)) ||\r\n((arg & TIOCM_CTS) && (changed & MSR_STATUS_LINE_CTS)))\r\nreturn 0;\r\nprevstatus = status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spcp8x5_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndbg("%s (%d) cmd = 0x%04x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCMIWAIT:\r\ndbg("%s (%d) TIOCMIWAIT", __func__, port->number);\r\nreturn spcp8x5_wait_modem_info(port, arg);\r\ndefault:\r\ndbg("%s not supported = 0x%04x", __func__, cmd);\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int spcp8x5_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (set & TIOCM_RTS)\r\npriv->line_control |= MCR_RTS;\r\nif (set & TIOCM_DTR)\r\npriv->line_control |= MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\npriv->line_control &= ~MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\npriv->line_control &= ~MCR_DTR;\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn spcp8x5_set_ctrlLine(port->serial->dev, control , priv->type);\r\n}\r\nstatic int spcp8x5_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int mcr;\r\nunsigned int status;\r\nunsigned int result;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmcr = priv->line_control;\r\nstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nresult = ((mcr & MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((status & MSR_STATUS_LINE_CTS) ? TIOCM_CTS : 0)\r\n| ((status & MSR_STATUS_LINE_DSR) ? TIOCM_DSR : 0)\r\n| ((status & MSR_STATUS_LINE_RI) ? TIOCM_RI : 0)\r\n| ((status & MSR_STATUS_LINE_DCD) ? TIOCM_CD : 0);\r\nreturn result;\r\n}\r\nstatic int __init spcp8x5_init(void)\r\n{\r\nint retval;\r\nretval = usb_serial_register(&spcp8x5_device);\r\nif (retval)\r\ngoto failed_usb_serial_register;\r\nretval = usb_register(&spcp8x5_driver);\r\nif (retval)\r\ngoto failed_usb_register;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nreturn 0;\r\nfailed_usb_register:\r\nusb_serial_deregister(&spcp8x5_device);\r\nfailed_usb_serial_register:\r\nreturn retval;\r\n}\r\nstatic void __exit spcp8x5_exit(void)\r\n{\r\nusb_deregister(&spcp8x5_driver);\r\nusb_serial_deregister(&spcp8x5_device);\r\n}
