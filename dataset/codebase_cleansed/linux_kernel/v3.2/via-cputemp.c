static ssize_t show_name(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nint ret;\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct via_cputemp_data *data = dev_get_drvdata(dev);\r\nif (attr->index == SHOW_NAME)\r\nret = sprintf(buf, "%s\n", data->name);\r\nelse\r\nret = sprintf(buf, "Core %d\n", data->id);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct via_cputemp_data *data = dev_get_drvdata(dev);\r\nu32 eax, edx;\r\nint err;\r\nerr = rdmsr_safe_on_cpu(data->id, data->msr_temp, &eax, &edx);\r\nif (err)\r\nreturn -EAGAIN;\r\nreturn sprintf(buf, "%lu\n", ((unsigned long)eax & 0xffffff) * 1000);\r\n}\r\nstatic ssize_t show_cpu_vid(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct via_cputemp_data *data = dev_get_drvdata(dev);\r\nu32 eax, edx;\r\nint err;\r\nerr = rdmsr_safe_on_cpu(data->id, data->msr_vid, &eax, &edx);\r\nif (err)\r\nreturn -EAGAIN;\r\nreturn sprintf(buf, "%d\n", vid_from_reg(~edx & 0x7f, data->vrm));\r\n}\r\nstatic int __devinit via_cputemp_probe(struct platform_device *pdev)\r\n{\r\nstruct via_cputemp_data *data;\r\nstruct cpuinfo_x86 *c = &cpu_data(pdev->id);\r\nint err;\r\nu32 eax, edx;\r\ndata = kzalloc(sizeof(struct via_cputemp_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ndev_err(&pdev->dev, "Out of memory\n");\r\ngoto exit;\r\n}\r\ndata->id = pdev->id;\r\ndata->name = "via_cputemp";\r\nswitch (c->x86_model) {\r\ncase 0xA:\r\ncase 0xD:\r\ndata->msr_temp = 0x1169;\r\ndata->msr_vid = 0x198;\r\nbreak;\r\ncase 0xF:\r\ndata->msr_temp = 0x1423;\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto exit_free;\r\n}\r\nerr = rdmsr_safe_on_cpu(data->id, data->msr_temp, &eax, &edx);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Unable to access TEMPERATURE MSR, giving up\n");\r\ngoto exit_free;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nerr = sysfs_create_group(&pdev->dev.kobj, &via_cputemp_group);\r\nif (err)\r\ngoto exit_free;\r\nif (data->msr_vid)\r\ndata->vrm = vid_which_vrm();\r\nif (data->vrm) {\r\nerr = device_create_file(&pdev->dev, &dev_attr_cpu0_vid);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndev_err(&pdev->dev, "Class registration failed (%d)\n",\r\nerr);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nif (data->vrm)\r\ndevice_remove_file(&pdev->dev, &dev_attr_cpu0_vid);\r\nsysfs_remove_group(&pdev->dev.kobj, &via_cputemp_group);\r\nexit_free:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit via_cputemp_remove(struct platform_device *pdev)\r\n{\r\nstruct via_cputemp_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nif (data->vrm)\r\ndevice_remove_file(&pdev->dev, &dev_attr_cpu0_vid);\r\nsysfs_remove_group(&pdev->dev.kobj, &via_cputemp_group);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __cpuinit via_cputemp_device_add(unsigned int cpu)\r\n{\r\nint err;\r\nstruct platform_device *pdev;\r\nstruct pdev_entry *pdev_entry;\r\npdev = platform_device_alloc(DRVNAME, cpu);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\npdev_entry = kzalloc(sizeof(struct pdev_entry), GFP_KERNEL);\r\nif (!pdev_entry) {\r\nerr = -ENOMEM;\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_free;\r\n}\r\npdev_entry->pdev = pdev;\r\npdev_entry->cpu = cpu;\r\nmutex_lock(&pdev_list_mutex);\r\nlist_add_tail(&pdev_entry->list, &pdev_list);\r\nmutex_unlock(&pdev_list_mutex);\r\nreturn 0;\r\nexit_device_free:\r\nkfree(pdev_entry);\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __cpuinit via_cputemp_device_remove(unsigned int cpu)\r\n{\r\nstruct pdev_entry *p;\r\nmutex_lock(&pdev_list_mutex);\r\nlist_for_each_entry(p, &pdev_list, list) {\r\nif (p->cpu == cpu) {\r\nplatform_device_unregister(p->pdev);\r\nlist_del(&p->list);\r\nmutex_unlock(&pdev_list_mutex);\r\nkfree(p);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&pdev_list_mutex);\r\n}\r\nstatic int __cpuinit via_cputemp_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long) hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_DOWN_FAILED:\r\nvia_cputemp_device_add(cpu);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nvia_cputemp_device_remove(cpu);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init via_cputemp_init(void)\r\n{\r\nint i, err;\r\nif (cpu_data(0).x86_vendor != X86_VENDOR_CENTAUR) {\r\nprintk(KERN_DEBUG DRVNAME ": Not a VIA CPU\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nerr = platform_driver_register(&via_cputemp_driver);\r\nif (err)\r\ngoto exit;\r\nfor_each_online_cpu(i) {\r\nstruct cpuinfo_x86 *c = &cpu_data(i);\r\nif (c->x86 != 6)\r\ncontinue;\r\nif (c->x86_model < 0x0a)\r\ncontinue;\r\nif (c->x86_model > 0x0f) {\r\npr_warn("Unknown CPU model 0x%x\n", c->x86_model);\r\ncontinue;\r\n}\r\nvia_cputemp_device_add(i);\r\n}\r\n#ifndef CONFIG_HOTPLUG_CPU\r\nif (list_empty(&pdev_list)) {\r\nerr = -ENODEV;\r\ngoto exit_driver_unreg;\r\n}\r\n#endif\r\nregister_hotcpu_notifier(&via_cputemp_cpu_notifier);\r\nreturn 0;\r\n#ifndef CONFIG_HOTPLUG_CPU\r\nexit_driver_unreg:\r\nplatform_driver_unregister(&via_cputemp_driver);\r\n#endif\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit via_cputemp_exit(void)\r\n{\r\nstruct pdev_entry *p, *n;\r\nunregister_hotcpu_notifier(&via_cputemp_cpu_notifier);\r\nmutex_lock(&pdev_list_mutex);\r\nlist_for_each_entry_safe(p, n, &pdev_list, list) {\r\nplatform_device_unregister(p->pdev);\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nmutex_unlock(&pdev_list_mutex);\r\nplatform_driver_unregister(&via_cputemp_driver);\r\n}
