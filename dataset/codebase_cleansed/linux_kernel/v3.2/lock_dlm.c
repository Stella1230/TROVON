static void gdlm_ast(void *arg)\r\n{\r\nstruct gfs2_glock *gl = arg;\r\nunsigned ret = gl->gl_state;\r\nBUG_ON(gl->gl_lksb.sb_flags & DLM_SBF_DEMOTED);\r\nif (gl->gl_lksb.sb_flags & DLM_SBF_VALNOTVALID)\r\nmemset(gl->gl_lvb, 0, GDLM_LVB_SIZE);\r\nswitch (gl->gl_lksb.sb_status) {\r\ncase -DLM_EUNLOCK:\r\ngfs2_glock_free(gl);\r\nreturn;\r\ncase -DLM_ECANCEL:\r\nret |= LM_OUT_CANCELED;\r\ngoto out;\r\ncase -EAGAIN:\r\ncase -EDEADLK:\r\ngoto out;\r\ncase -ETIMEDOUT:\r\nret |= LM_OUT_ERROR;\r\ngoto out;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nret = gl->gl_req;\r\nif (gl->gl_lksb.sb_flags & DLM_SBF_ALTMODE) {\r\nif (gl->gl_req == LM_ST_SHARED)\r\nret = LM_ST_DEFERRED;\r\nelse if (gl->gl_req == LM_ST_DEFERRED)\r\nret = LM_ST_SHARED;\r\nelse\r\nBUG();\r\n}\r\nset_bit(GLF_INITIAL, &gl->gl_flags);\r\ngfs2_glock_complete(gl, ret);\r\nreturn;\r\nout:\r\nif (!test_bit(GLF_INITIAL, &gl->gl_flags))\r\ngl->gl_lksb.sb_lkid = 0;\r\ngfs2_glock_complete(gl, ret);\r\n}\r\nstatic void gdlm_bast(void *arg, int mode)\r\n{\r\nstruct gfs2_glock *gl = arg;\r\nswitch (mode) {\r\ncase DLM_LOCK_EX:\r\ngfs2_glock_cb(gl, LM_ST_UNLOCKED);\r\nbreak;\r\ncase DLM_LOCK_CW:\r\ngfs2_glock_cb(gl, LM_ST_DEFERRED);\r\nbreak;\r\ncase DLM_LOCK_PR:\r\ngfs2_glock_cb(gl, LM_ST_SHARED);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "unknown bast mode %d", mode);\r\nBUG();\r\n}\r\n}\r\nstatic int make_mode(const unsigned int lmstate)\r\n{\r\nswitch (lmstate) {\r\ncase LM_ST_UNLOCKED:\r\nreturn DLM_LOCK_NL;\r\ncase LM_ST_EXCLUSIVE:\r\nreturn DLM_LOCK_EX;\r\ncase LM_ST_DEFERRED:\r\nreturn DLM_LOCK_CW;\r\ncase LM_ST_SHARED:\r\nreturn DLM_LOCK_PR;\r\n}\r\nprintk(KERN_ERR "unknown LM state %d", lmstate);\r\nBUG();\r\nreturn -1;\r\n}\r\nstatic u32 make_flags(const u32 lkid, const unsigned int gfs_flags,\r\nconst int req)\r\n{\r\nu32 lkf = 0;\r\nif (gfs_flags & LM_FLAG_TRY)\r\nlkf |= DLM_LKF_NOQUEUE;\r\nif (gfs_flags & LM_FLAG_TRY_1CB) {\r\nlkf |= DLM_LKF_NOQUEUE;\r\nlkf |= DLM_LKF_NOQUEUEBAST;\r\n}\r\nif (gfs_flags & LM_FLAG_PRIORITY) {\r\nlkf |= DLM_LKF_NOORDER;\r\nlkf |= DLM_LKF_HEADQUE;\r\n}\r\nif (gfs_flags & LM_FLAG_ANY) {\r\nif (req == DLM_LOCK_PR)\r\nlkf |= DLM_LKF_ALTCW;\r\nelse if (req == DLM_LOCK_CW)\r\nlkf |= DLM_LKF_ALTPR;\r\nelse\r\nBUG();\r\n}\r\nif (lkid != 0)\r\nlkf |= DLM_LKF_CONVERT;\r\nlkf |= DLM_LKF_VALBLK;\r\nreturn lkf;\r\n}\r\nstatic int gdlm_lock(struct gfs2_glock *gl, unsigned int req_state,\r\nunsigned int flags)\r\n{\r\nstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\r\nint req;\r\nu32 lkf;\r\nreq = make_mode(req_state);\r\nlkf = make_flags(gl->gl_lksb.sb_lkid, flags, req);\r\nreturn dlm_lock(ls->ls_dlm, req, &gl->gl_lksb, lkf, gl->gl_strname,\r\nGDLM_STRNAME_BYTES - 1, 0, gdlm_ast, gl, gdlm_bast);\r\n}\r\nstatic void gdlm_put_lock(struct gfs2_glock *gl)\r\n{\r\nstruct gfs2_sbd *sdp = gl->gl_sbd;\r\nstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\r\nint error;\r\nif (gl->gl_lksb.sb_lkid == 0) {\r\ngfs2_glock_free(gl);\r\nreturn;\r\n}\r\nerror = dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_VALBLK,\r\nNULL, gl);\r\nif (error) {\r\nprintk(KERN_ERR "gdlm_unlock %x,%llx err=%d\n",\r\ngl->gl_name.ln_type,\r\n(unsigned long long)gl->gl_name.ln_number, error);\r\nreturn;\r\n}\r\n}\r\nstatic void gdlm_cancel(struct gfs2_glock *gl)\r\n{\r\nstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\r\ndlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_CANCEL, NULL, gl);\r\n}\r\nstatic int gdlm_mount(struct gfs2_sbd *sdp, const char *fsname)\r\n{\r\nstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\r\nint error;\r\nif (fsname == NULL) {\r\nfs_info(sdp, "no fsname found\n");\r\nreturn -EINVAL;\r\n}\r\nerror = dlm_new_lockspace(fsname, strlen(fsname), &ls->ls_dlm,\r\nDLM_LSFL_FS | DLM_LSFL_NEWEXCL |\r\n(ls->ls_nodir ? DLM_LSFL_NODIR : 0),\r\nGDLM_LVB_SIZE);\r\nif (error)\r\nprintk(KERN_ERR "dlm_new_lockspace error %d", error);\r\nreturn error;\r\n}\r\nstatic void gdlm_unmount(struct gfs2_sbd *sdp)\r\n{\r\nstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\r\nif (ls->ls_dlm) {\r\ndlm_release_lockspace(ls->ls_dlm, 2);\r\nls->ls_dlm = NULL;\r\n}\r\n}
