static bool ttl_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ipt_ttl_info *info = par->matchinfo;\r\nconst u8 ttl = ip_hdr(skb)->ttl;\r\nswitch (info->mode) {\r\ncase IPT_TTL_EQ:\r\nreturn ttl == info->ttl;\r\ncase IPT_TTL_NE:\r\nreturn ttl != info->ttl;\r\ncase IPT_TTL_LT:\r\nreturn ttl < info->ttl;\r\ncase IPT_TTL_GT:\r\nreturn ttl > info->ttl;\r\n}\r\nreturn false;\r\n}\r\nstatic bool hl_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ip6t_hl_info *info = par->matchinfo;\r\nconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nswitch (info->mode) {\r\ncase IP6T_HL_EQ:\r\nreturn ip6h->hop_limit == info->hop_limit;\r\ncase IP6T_HL_NE:\r\nreturn ip6h->hop_limit != info->hop_limit;\r\ncase IP6T_HL_LT:\r\nreturn ip6h->hop_limit < info->hop_limit;\r\ncase IP6T_HL_GT:\r\nreturn ip6h->hop_limit > info->hop_limit;\r\n}\r\nreturn false;\r\n}\r\nstatic int __init hl_mt_init(void)\r\n{\r\nreturn xt_register_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));\r\n}\r\nstatic void __exit hl_mt_exit(void)\r\n{\r\nxt_unregister_matches(hl_mt_reg, ARRAY_SIZE(hl_mt_reg));\r\n}
