int mdfld_dsi_dbi_update_area(struct mdfld_dsi_dbi_output *dbi_output,\r\nu16 x1, u16 y1, u16 x2, u16 y2)\r\n{\r\nstruct mdfld_dsi_pkg_sender *sender =\r\nmdfld_dsi_encoder_get_pkg_sender(&dbi_output->base);\r\nu8 param[4];\r\nu8 cmd;\r\nint err;\r\nif (!sender) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\ncmd = DCS_SET_COLUMN_ADDRESS;\r\nparam[0] = x1 >> 8;\r\nparam[1] = x1;\r\nparam[2] = x2 >> 8;\r\nparam[3] = x2;\r\nerr = mdfld_dsi_send_dcs(sender,\r\ncmd,\r\nparam,\r\n4,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(sender->dev->dev, "DCS 0x%x sent failed\n", cmd);\r\ngoto err_out;\r\n}\r\ncmd = DCS_SET_PAGE_ADDRESS;\r\nparam[0] = y1 >> 8;\r\nparam[1] = y1;\r\nparam[2] = y2 >> 8;\r\nparam[3] = y2;\r\nerr = mdfld_dsi_send_dcs(sender,\r\ncmd,\r\nparam,\r\n4,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(sender->dev->dev, "DCS 0x%x sent failed\n", cmd);\r\ngoto err_out;\r\n}\r\nerr = mdfld_dsi_send_dcs(sender,\r\nwrite_mem_start,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_PIPE,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(sender->dev->dev, "DCS 0x%x sent failed\n", cmd);\r\ngoto err_out;\r\n}\r\nmdfld_dsi_cmds_kick_out(sender);\r\nerr_out:\r\nreturn err;\r\n}\r\nint mdfld_dsi_dbi_update_power(struct mdfld_dsi_dbi_output *dbi_output,\r\nint mode)\r\n{\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct mdfld_dsi_pkg_sender *sender =\r\nmdfld_dsi_encoder_get_pkg_sender(&dbi_output->base);\r\nu8 param = 0;\r\nu32 err = 0;\r\nif (!sender) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nerr = mdfld_dsi_send_dcs(sender,\r\nDCS_EXIT_SLEEP_MODE,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(dev->dev, "DCS 0x%x sent failed\n",\r\nDCS_EXIT_SLEEP_MODE);\r\ngoto power_err;\r\n}\r\nerr = mdfld_dsi_send_dcs(sender,\r\nDCS_SET_DISPLAY_ON,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(dev->dev, "DCS 0x%x sent failed\n",\r\nDCS_SET_DISPLAY_ON);\r\ngoto power_err;\r\n}\r\nerr = mdfld_dsi_send_dcs(sender,\r\nDCS_SET_TEAR_ON,\r\n&param,\r\n1,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(dev->dev, "DCS 0x%x sent failed\n",\r\nset_tear_on);\r\ngoto power_err;\r\n}\r\nerr = mdfld_dsi_send_dcs(sender,\r\nDCS_WRITE_MEM_START,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_PIPE,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(dev->dev, "DCS 0x%x sent failed\n",\r\nDCS_WRITE_MEM_START);\r\ngoto power_err;\r\n}\r\n} else {\r\nerr = mdfld_dsi_send_dcs(sender,\r\nDCS_SET_TEAR_OFF,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(dev->dev, "DCS 0x%x sent failed\n",\r\nDCS_SET_TEAR_OFF);\r\ngoto power_err;\r\n}\r\nerr = mdfld_dsi_send_dcs(sender,\r\nDCS_SET_DISPLAY_OFF,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(dev->dev, "DCS 0x%x sent failed\n",\r\nDCS_SET_DISPLAY_OFF);\r\ngoto power_err;\r\n}\r\nerr = mdfld_dsi_send_dcs(sender,\r\nDCS_ENTER_SLEEP_MODE,\r\nNULL,\r\n0,\r\nCMD_DATA_SRC_SYSTEM_MEM,\r\nMDFLD_DSI_QUEUE_PACKAGE);\r\nif (err) {\r\ndev_err(dev->dev, "DCS 0x%x sent failed\n",\r\nDCS_ENTER_SLEEP_MODE);\r\ngoto power_err;\r\n}\r\n}\r\nmdfld_dsi_cmds_kick_out(sender);\r\npower_err:\r\nreturn err;\r\n}\r\nint mdfld_dsi_dbi_send_dcs(struct mdfld_dsi_dbi_output *dbi_output,\r\nu8 dcs, u8 *param, u32 num, u8 data_src)\r\n{\r\nstruct mdfld_dsi_pkg_sender *sender =\r\nmdfld_dsi_encoder_get_pkg_sender(&dbi_output->base);\r\nint ret;\r\nif (!sender) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nret = mdfld_dsi_send_dcs(sender,\r\ndcs,\r\nparam,\r\nnum,\r\ndata_src,\r\nMDFLD_DSI_SEND_PACKAGE);\r\nreturn ret;\r\n}\r\nvoid mdfld_dsi_dbi_enter_dsr(struct mdfld_dsi_dbi_output *dbi_output, int pipe)\r\n{\r\nu32 reg_val;\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_crtc *crtc = dbi_output->base.base.crtc;\r\nstruct psb_intel_crtc *psb_crtc = (crtc) ?\r\nto_psb_intel_crtc(crtc) : NULL;\r\nu32 dpll_reg = MRST_DPLL_A;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dspcntr_reg = DSPACNTR;\r\nif (!dbi_output)\r\nreturn;\r\ndev_priv->is_in_idle = true;\r\ngdbi_output = dbi_output;\r\nif ((dbi_output->mode_flags & MODE_SETTING_ON_GOING) ||\r\n(psb_crtc && psb_crtc->mode_flags & MODE_SETTING_ON_GOING))\r\nreturn;\r\nif (pipe == 2) {\r\ndpll_reg = MRST_DPLL_A;\r\npipeconf_reg = PIPECCONF;\r\ndspcntr_reg = DSPCCNTR;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nmdfld_disable_te(dev, pipe);\r\nreg_val = REG_READ(dspcntr_reg);\r\nif (!(reg_val & DISPLAY_PLANE_ENABLE)) {\r\nREG_WRITE(dspcntr_reg, reg_val & ~DISPLAY_PLANE_ENABLE);\r\nREG_READ(dspcntr_reg);\r\n}\r\nreg_val = REG_READ(pipeconf_reg);\r\nif (!(reg_val & DISPLAY_PLANE_ENABLE)) {\r\nreg_val &= ~DISPLAY_PLANE_ENABLE;\r\nreg_val |= (PIPECONF_PLANE_OFF | PIPECONF_CURSOR_OFF);\r\nREG_WRITE(pipeconf_reg, reg_val);\r\nREG_READ(pipeconf_reg);\r\nmdfldWaitForPipeDisable(dev, pipe);\r\n}\r\nreg_val = REG_READ(dpll_reg);\r\nif (!(reg_val & DPLL_VCO_ENABLE)) {\r\nreg_val &= ~DPLL_VCO_ENABLE;\r\nREG_WRITE(dpll_reg, reg_val);\r\nREG_READ(dpll_reg);\r\nudelay(500);\r\n}\r\ngma_power_end(dev);\r\ndbi_output->mode_flags |= MODE_SETTING_IN_DSR;\r\nif (pipe == 2) {\r\nenter_dsr = 1;\r\n}\r\n}\r\nstatic void mdfld_dbi_output_exit_dsr(struct mdfld_dsi_dbi_output *dbi_output,\r\nint pipe)\r\n{\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_crtc *crtc = dbi_output->base.base.crtc;\r\nstruct psb_intel_crtc *psb_crtc = (crtc) ?\r\nto_psb_intel_crtc(crtc) : NULL;\r\nu32 reg_val;\r\nu32 dpll_reg = MRST_DPLL_A;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 reg_offset = 0;\r\nif ((dbi_output->mode_flags & MODE_SETTING_ON_GOING) ||\r\n(psb_crtc && psb_crtc->mode_flags & MODE_SETTING_ON_GOING))\r\nreturn;\r\nif (pipe == 2) {\r\ndpll_reg = MRST_DPLL_A;\r\npipeconf_reg = PIPECCONF;\r\ndspcntr_reg = DSPCCNTR;\r\nreg_offset = MIPIC_REG_OFFSET;\r\n}\r\nif (!gma_power_begin(dev, true)) {\r\ndev_err(dev->dev, "hw begin failed\n");\r\nreturn;\r\n}\r\nreg_val = REG_READ(dpll_reg);\r\nif (!(reg_val & DPLL_VCO_ENABLE)) {\r\nif (reg_val & MDFLD_PWR_GATE_EN) {\r\nreg_val &= ~MDFLD_PWR_GATE_EN;\r\nREG_WRITE(dpll_reg, reg_val);\r\nREG_READ(dpll_reg);\r\nudelay(500);\r\n}\r\nreg_val |= DPLL_VCO_ENABLE;\r\nREG_WRITE(dpll_reg, reg_val);\r\nREG_READ(dpll_reg);\r\nudelay(500);\r\nwhile (!(REG_READ(pipeconf_reg) & PIPECONF_DSIPLL_LOCK))\r\ncpu_relax();\r\n}\r\nreg_val = REG_READ(pipeconf_reg);\r\nif (!(reg_val & PIPEACONF_ENABLE)) {\r\nreg_val |= PIPEACONF_ENABLE;\r\nREG_WRITE(pipeconf_reg, reg_val);\r\nREG_READ(pipeconf_reg);\r\nudelay(500);\r\nmdfldWaitForPipeEnable(dev, pipe);\r\n}\r\nreg_val = REG_READ(dspcntr_reg);\r\nif (!(reg_val & DISPLAY_PLANE_ENABLE)) {\r\nreg_val |= DISPLAY_PLANE_ENABLE;\r\nREG_WRITE(dspcntr_reg, reg_val);\r\nREG_READ(dspcntr_reg);\r\nudelay(500);\r\n}\r\nmdfld_enable_te(dev, pipe);\r\ngma_power_end(dev);\r\ndbi_output->mode_flags &= ~MODE_SETTING_IN_DSR;\r\n}\r\nvoid mdfld_dsi_dbi_exit_dsr(struct drm_device *dev, u32 update_src)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dsr_info *dsr_info = dev_priv->dbi_dsr_info;\r\nstruct mdfld_dsi_dbi_output **dbi_output;\r\nint i;\r\nint pipe;\r\ndev_priv->is_in_idle = false;\r\ndbi_output = dsr_info->dbi_outputs;\r\n#ifdef CONFIG_PM_RUNTIME\r\nif (!enable_gfx_rtpm) {\r\n}\r\n#endif\r\nfor (i = 0; i < dsr_info->dbi_output_num; i++) {\r\nif (!dbi_output[i] || !dbi_output[i]->dbi_panel_on)\r\ncontinue;\r\npipe = dbi_output[i]->channel_num ? 2 : 0;\r\nenter_dsr = 0;\r\nmdfld_dbi_output_exit_dsr(dbi_output[i], pipe);\r\n}\r\ndev_priv->dsr_fb_update |= update_src;\r\n}\r\nstatic bool mdfld_dbi_is_in_dsr(struct drm_device *dev)\r\n{\r\nif (REG_READ(MRST_DPLL_A) & DPLL_VCO_ENABLE)\r\nreturn false;\r\nif ((REG_READ(PIPEACONF) & PIPEACONF_ENABLE) ||\r\n(REG_READ(PIPECCONF) & PIPEACONF_ENABLE))\r\nreturn false;\r\nif ((REG_READ(DSPACNTR) & DISPLAY_PLANE_ENABLE) ||\r\n(REG_READ(DSPCCNTR) & DISPLAY_PLANE_ENABLE))\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid mdfld_dbi_update_panel(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dsr_info *dsr_info = dev_priv->dbi_dsr_info;\r\nstruct mdfld_dsi_dbi_output **dbi_outputs;\r\nstruct mdfld_dsi_dbi_output *dbi_output;\r\nint i;\r\nint can_enter_dsr = 0;\r\nu32 damage_mask;\r\ndbi_outputs = dsr_info->dbi_outputs;\r\ndbi_output = pipe ? dbi_outputs[1] : dbi_outputs[0];\r\nif (!dbi_output)\r\nreturn;\r\nif (pipe == 0)\r\ndamage_mask = dev_priv->dsr_fb_update & MDFLD_DSR_DAMAGE_MASK_0;\r\nelse if (pipe == 2)\r\ndamage_mask = dev_priv->dsr_fb_update & MDFLD_DSR_DAMAGE_MASK_2;\r\nelse\r\nreturn;\r\nif (damage_mask && dbi_output->dbi_panel_on) {\r\ndbi_output->dsr_fb_update_done = false;\r\nif (dbi_output->p_funcs->update_fb)\r\ndbi_output->p_funcs->update_fb(dbi_output, pipe);\r\nif (dev_priv->dsr_enable && dbi_output->dsr_fb_update_done)\r\ndev_priv->dsr_fb_update &= ~damage_mask;\r\ndbi_output->mode_flags &= ~MODE_SETTING_IN_DSR;\r\ndbi_output->dsr_idle_count = 0;\r\n} else {\r\ndbi_output->dsr_idle_count++;\r\n}\r\nswitch (dsr_info->dbi_output_num) {\r\ncase 1:\r\nif (dbi_output->dsr_idle_count > MDFLD_DSR_MAX_IDLE_COUNT)\r\ncan_enter_dsr = 1;\r\nbreak;\r\ncase 2:\r\nif (dbi_outputs[0]->dsr_idle_count > MDFLD_DSR_MAX_IDLE_COUNT\r\n&& dbi_outputs[1]->dsr_idle_count > MDFLD_DSR_MAX_IDLE_COUNT)\r\ncan_enter_dsr = 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Wrong DBI output number\n");\r\n}\r\nif (can_enter_dsr) {\r\nfor (i = 0; i < dsr_info->dbi_output_num; i++) {\r\nif (!mdfld_dbi_is_in_dsr(dev) && dbi_outputs[i] &&\r\n!(dbi_outputs[i]->mode_flags & MODE_SETTING_ON_GOING)) {\r\nmdfld_dsi_dbi_enter_dsr(dbi_outputs[i],\r\ndbi_outputs[i]->channel_num ? 2 : 0);\r\n#if 0\r\nenter_dsr = 1;\r\npr_err("%s: enter_dsr = 1\n", __func__);\r\n#endif\r\n}\r\n}\r\n#ifdef CONFIG_GFX_RTPM\r\nif (!dev_priv->rpm_enabled\r\n|| !enter_dsr\r\n|| pm_schedule_suspend(&dev->pdev->dev, gfxrtdelay))\r\ndev_warn(dev->dev,\r\n"Runtime PM schedule suspend failed, rpm %d\n",\r\ndev_priv->rpm_enabled);\r\n#endif\r\n}\r\n}\r\nint mdfld_dbi_dsr_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dsr_info *dsr_info = dev_priv->dbi_dsr_info;\r\nif (!dsr_info || IS_ERR(dsr_info)) {\r\ndsr_info = kzalloc(sizeof(struct mdfld_dbi_dsr_info),\r\nGFP_KERNEL);\r\nif (!dsr_info) {\r\ndev_err(dev->dev, "No memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_priv->dbi_dsr_info = dsr_info;\r\n}\r\nreturn 0;\r\n}\r\nvoid mdfld_dbi_dsr_exit(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dsr_info *dsr_info = dev_priv->dbi_dsr_info;\r\nif (dsr_info) {\r\nkfree(dsr_info);\r\ndev_priv->dbi_dsr_info = NULL;\r\n}\r\n}\r\nvoid mdfld_dsi_controller_dbi_init(struct mdfld_dsi_config *dsi_config,\r\nint pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nu32 reg_offset = pipe ? MIPIC_REG_OFFSET : 0;\r\nint lane_count = dsi_config->lane_count;\r\nu32 val = 0;\r\ndev_dbg(dev->dev, "Init DBI interface on pipe %d...\n", pipe);\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_CONTROL_REG + reg_offset), 0x00000018);\r\nREG_WRITE((MIPIA_DPHY_PARAM_REG + reg_offset), 0x150c3408);\r\nREG_WRITE((MIPIA_CLK_LANE_SWITCH_TIME_CNT_REG + reg_offset),\r\n0x000a0014);\r\nREG_WRITE((MIPIA_DBI_BW_CTRL_REG + reg_offset), 0x00000400);\r\nREG_WRITE((MIPIA_DBI_FIFO_THROTTLE_REG + reg_offset), 0x00000001);\r\nREG_WRITE((MIPIA_HS_LS_DBI_ENABLE_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_INTR_EN_REG + reg_offset), 0xffffffff);\r\nREG_WRITE((MIPIA_TURN_AROUND_TIMEOUT_REG + reg_offset), 0x0000001f);\r\nREG_WRITE((MIPIA_DEVICE_RESET_TIMER_REG + reg_offset), 0x0000ffff);\r\nREG_WRITE((MIPIA_INIT_COUNT_REG + reg_offset), 0x00000fa0);\r\nval |= lane_count;\r\nval |= (dsi_config->channel_num << DSI_DBI_VIRT_CHANNEL_OFFSET);\r\nval |= DSI_DBI_COLOR_FORMAT_OPTION2;\r\nREG_WRITE((MIPIA_DSI_FUNC_PRG_REG + reg_offset), val);\r\nREG_WRITE((MIPIA_HS_TX_TIMEOUT_REG + reg_offset), 0x3fffff);\r\nREG_WRITE((MIPIA_LP_RX_TIMEOUT_REG + reg_offset), 0xffff);\r\nREG_WRITE((MIPIA_HIGH_LOW_SWITCH_COUNT_REG + reg_offset), 0x46);\r\nREG_WRITE((MIPIA_EOT_DISABLE_REG + reg_offset), 0x00000000);\r\nREG_WRITE((MIPIA_LP_BYTECLK_REG + reg_offset), 0x00000004);\r\nREG_WRITE((MIPIA_DEVICE_READY_REG + reg_offset), 0x00000001);\r\n}\r\nstruct mdfld_dsi_encoder *mdfld_dsi_dbi_init(struct drm_device *dev,\r\nstruct mdfld_dsi_connector *dsi_connector,\r\nstruct panel_funcs *p_funcs)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dsi_dbi_output *dbi_output = NULL;\r\nstruct mdfld_dsi_config *dsi_config;\r\nstruct drm_connector *connector = NULL;\r\nstruct drm_encoder *encoder = NULL;\r\nstruct drm_display_mode *fixed_mode = NULL;\r\nstruct psb_gtt *pg = dev_priv ? (&dev_priv->gtt) : NULL;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv ? (dev_priv->dbi_dpu_info) : NULL;\r\nstruct mdfld_dbi_dsr_info *dsr_info = dev_priv ? (dev_priv->dbi_dsr_info) : NULL;\r\nu32 data = 0;\r\nint pipe;\r\nint ret;\r\nif (!pg || !dsi_connector || !p_funcs) {\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\ndsi_config = mdfld_dsi_get_config(dsi_connector);\r\npipe = dsi_connector->pipe;\r\nif (p_funcs->reset) {\r\nret = p_funcs->reset(pipe);\r\nif (ret) {\r\nDRM_ERROR("Panel %d hard-reset failed\n", pipe);\r\nreturn NULL;\r\n}\r\n}\r\nif (p_funcs->drv_ic_init)\r\np_funcs->drv_ic_init(dsi_config, pipe);\r\nret = mdfld_dsi_get_power_mode(dsi_config,\r\n&data,\r\nMDFLD_DSI_HS_TRANSMISSION);\r\nif (ret) {\r\nDRM_ERROR("Panel %d get power mode failed\n", pipe);\r\ndsi_connector->status = connector_status_disconnected;\r\n} else {\r\nDRM_INFO("pipe %d power mode 0x%x\n", pipe, data);\r\ndsi_connector->status = connector_status_connected;\r\n}\r\ndbi_output = kzalloc(sizeof(struct mdfld_dsi_dbi_output), GFP_KERNEL);\r\nif (!dbi_output) {\r\ndev_err(dev->dev, "No memory\n");\r\nreturn NULL;\r\n}\r\nif (dsi_connector->pipe == 0) {\r\ndbi_output->channel_num = 0;\r\ndev_priv->dbi_output = dbi_output;\r\n} else if (dsi_connector->pipe == 2) {\r\ndbi_output->channel_num = 1;\r\ndev_priv->dbi_output2 = dbi_output;\r\n} else {\r\ndev_err(dev->dev, "only support 2 DSI outputs\n");\r\ngoto out_err1;\r\n}\r\ndbi_output->dev = dev;\r\ndbi_output->p_funcs = p_funcs;\r\nfixed_mode = dsi_config->fixed_mode;\r\ndbi_output->panel_fixed_mode = fixed_mode;\r\nconnector = &dsi_connector->base.base;\r\nencoder = &dbi_output->base.base;\r\ndrm_encoder_init(dev,\r\nencoder,\r\np_funcs->encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\ndrm_encoder_helper_add(encoder, p_funcs->encoder_helper_funcs);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nif (dsi_connector->pipe) {\r\nencoder->possible_crtcs = (1 << 2);\r\nencoder->possible_clones = (1 << 1);\r\n} else {\r\nencoder->possible_crtcs = (1 << 0);\r\nencoder->possible_clones = (1 << 0);\r\n}\r\ndev_priv->dsr_fb_update = 0;\r\ndev_priv->dsr_enable = false;\r\ndev_priv->exit_idle = mdfld_dsi_dbi_exit_dsr;\r\ndbi_output->first_boot = true;\r\ndbi_output->mode_flags = MODE_SETTING_IN_ENCODER;\r\nif (dpu_info && dsi_connector->status == connector_status_connected) {\r\nif (dsi_connector->pipe == 0)\r\ndpu_info->dbi_outputs[0] = dbi_output;\r\nelse\r\ndpu_info->dbi_outputs[1] = dbi_output;\r\ndpu_info->dbi_output_num++;\r\n} else if (dsi_connector->status == connector_status_connected) {\r\nif (dsi_connector->pipe == 0)\r\ndsr_info->dbi_outputs[0] = dbi_output;\r\nelse\r\ndsr_info->dbi_outputs[1] = dbi_output;\r\ndsr_info->dbi_output_num++;\r\n}\r\nreturn &dbi_output->base;\r\nout_err1:\r\nkfree(dbi_output);\r\nreturn NULL;\r\n}
