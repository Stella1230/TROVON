static unsigned short madgemc_sifreadb(struct net_device *dev, unsigned short reg)\r\n{\r\nunsigned short ret;\r\nif (reg<0x8)\r\nret = SIFREADB(reg);\r\nelse {\r\nmadgemc_setregpage(dev, 1);\r\nret = SIFREADB(reg);\r\nmadgemc_setregpage(dev, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void madgemc_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\nif (reg<0x8)\r\nSIFWRITEB(val, reg);\r\nelse {\r\nmadgemc_setregpage(dev, 1);\r\nSIFWRITEB(val, reg);\r\nmadgemc_setregpage(dev, 0);\r\n}\r\n}\r\nstatic unsigned short madgemc_sifreadw(struct net_device *dev, unsigned short reg)\r\n{\r\nunsigned short ret;\r\nif (reg<0x8)\r\nret = SIFREADW(reg);\r\nelse {\r\nmadgemc_setregpage(dev, 1);\r\nret = SIFREADW(reg);\r\nmadgemc_setregpage(dev, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void madgemc_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\nif (reg<0x8)\r\nSIFWRITEW(val, reg);\r\nelse {\r\nmadgemc_setregpage(dev, 1);\r\nSIFWRITEW(val, reg);\r\nmadgemc_setregpage(dev, 0);\r\n}\r\n}\r\nstatic int __devinit madgemc_probe(struct device *device)\r\n{\r\nstatic int versionprinted;\r\nstruct net_device *dev;\r\nstruct net_local *tp;\r\nstruct card_info *card;\r\nstruct mca_device *mdev = to_mca_device(device);\r\nint ret = 0;\r\nif (versionprinted++ == 0)\r\nprintk("%s", version);\r\nif(mca_device_claimed(mdev))\r\nreturn -EBUSY;\r\nmca_device_set_claim(mdev, 1);\r\ndev = alloc_trdev(sizeof(struct net_local));\r\nif (!dev) {\r\nprintk("madgemc: unable to allocate dev space\n");\r\nmca_device_set_claim(mdev, 0);\r\nret = -ENOMEM;\r\ngoto getout;\r\n}\r\ndev->netdev_ops = &madgemc_netdev_ops;\r\ncard = kmalloc(sizeof(struct card_info), GFP_KERNEL);\r\nif (card==NULL) {\r\nprintk("madgemc: unable to allocate card struct\n");\r\nret = -ENOMEM;\r\ngoto getout1;\r\n}\r\ndev->base_addr = 0x0a20 +\r\n((mdev->pos[2] & MC16_POS2_ADDR2)?0x0400:0) +\r\n((mdev->pos[0] & MC16_POS0_ADDR1)?0x1000:0) +\r\n((mdev->pos[3] & MC16_POS3_ADDR3)?0x2000:0);\r\nswitch(mdev->pos[0] >> 6) {\r\ncase 0x1: dev->irq = 3; break;\r\ncase 0x2: dev->irq = 9; break;\r\ncase 0x3: dev->irq = 10; break;\r\ndefault: dev->irq = 0; break;\r\n}\r\nif (dev->irq == 0) {\r\nprintk("%s: invalid IRQ\n", dev->name);\r\nret = -EBUSY;\r\ngoto getout2;\r\n}\r\nif (!request_region(dev->base_addr, MADGEMC_IO_EXTENT,\r\n"madgemc")) {\r\nprintk(KERN_INFO "madgemc: unable to setup Smart MC in slot %d because of I/O base conflict at 0x%04lx\n", mdev->slot, dev->base_addr);\r\ndev->base_addr += MADGEMC_SIF_OFFSET;\r\nret = -EBUSY;\r\ngoto getout2;\r\n}\r\ndev->base_addr += MADGEMC_SIF_OFFSET;\r\ncard->arblevel = ((mdev->pos[0] >> 1) & 0x7) + 8;\r\ncard->burstmode = ((mdev->pos[2] >> 6) & 0x3);\r\ncard->fairness = ((mdev->pos[2] >> 4) & 0x1);\r\nif ((mdev->pos[1] >> 2)&0x1)\r\ncard->ringspeed = 2;\r\nelse if ((mdev->pos[2] >> 5) & 0x1)\r\ncard->ringspeed = 1;\r\nelse\r\ncard->ringspeed = 0;\r\nif ((mdev->pos[1] >> 6)&0x1)\r\ncard->cabletype = 1;\r\nelse\r\ncard->cabletype = 0;\r\nmadgemc_read_rom(dev, card);\r\nif (card->manid != 0x4d) {\r\nprintk(KERN_INFO "%s: Madge MC ROM read failed (unknown manufacturer ID %02x)\n", dev->name, card->manid);\r\ngoto getout3;\r\n}\r\nif ((card->cardtype != 0x08) && (card->cardtype != 0x0d)) {\r\nprintk(KERN_INFO "%s: Madge MC ROM read failed (unknown card ID %02x)\n", dev->name, card->cardtype);\r\nret = -EIO;\r\ngoto getout3;\r\n}\r\nif ((card->cardtype == 0x08) && (card->cardrev <= 0x01))\r\ncard->ramsize = 128;\r\nelse\r\ncard->ramsize = 256;\r\nprintk("%s: %s Rev %d at 0x%04lx IRQ %d\n",\r\ndev->name,\r\n(card->cardtype == 0x08)?MADGEMC16_CARDNAME:\r\nMADGEMC32_CARDNAME, card->cardrev,\r\ndev->base_addr, dev->irq);\r\nif (card->cardtype == 0x0d)\r\nprintk("%s: Warning: MC32 support is experimental and highly untested\n", dev->name);\r\nif (card->ringspeed==2) {\r\nprintk("%s: Warning: Ring speed not set in POS -- Please run the reference disk and set it!\n", dev->name);\r\ncard->ringspeed = 1;\r\n}\r\nprintk("%s: RAM Size: %dKB\n", dev->name, card->ramsize);\r\nprintk("%s: Ring Speed: %dMb/sec on %s\n", dev->name,\r\n(card->ringspeed)?16:4,\r\ncard->cabletype?"STP/DB9":"UTP/RJ-45");\r\nprintk("%s: Arbitration Level: %d\n", dev->name,\r\ncard->arblevel);\r\nprintk("%s: Burst Mode: ", dev->name);\r\nswitch(card->burstmode) {\r\ncase 0: printk("Cycle steal"); break;\r\ncase 1: printk("Limited burst"); break;\r\ncase 2: printk("Delayed release"); break;\r\ncase 3: printk("Immediate release"); break;\r\n}\r\nprintk(" (%s)\n", (card->fairness)?"Unfair":"Fair");\r\noutb(0, dev->base_addr + MC_CONTROL_REG0);\r\nmadgemc_setsifsel(dev, 1);\r\nif (request_irq(dev->irq, madgemc_interrupt, IRQF_SHARED,\r\n"madgemc", dev)) {\r\nret = -EBUSY;\r\ngoto getout3;\r\n}\r\nmadgemc_chipset_init(dev);\r\nmadgemc_setcabletype(dev, card->cabletype);\r\nmca_device_set_name(mdev, (card->cardtype == 0x08)?MADGEMC16_CARDNAME:MADGEMC32_CARDNAME);\r\nmca_set_adapter_procfn(mdev->slot, madgemc_mcaproc, dev);\r\nprintk("%s: Ring Station Address: %pM\n",\r\ndev->name, dev->dev_addr);\r\nif (tmsdev_init(dev, device)) {\r\nprintk("%s: unable to get memory for dev->priv.\n",\r\ndev->name);\r\nret = -ENOMEM;\r\ngoto getout4;\r\n}\r\ntp = netdev_priv(dev);\r\ntp->setnselout = madgemc_setnselout_pins;\r\ntp->sifwriteb = madgemc_sifwriteb;\r\ntp->sifreadb = madgemc_sifreadb;\r\ntp->sifwritew = madgemc_sifwritew;\r\ntp->sifreadw = madgemc_sifreadw;\r\ntp->DataRate = (card->ringspeed)?SPEED_16:SPEED_4;\r\nmemcpy(tp->ProductID, "Madge MCA 16/4 ", PROD_ID_SIZE + 1);\r\ntp->tmspriv = card;\r\ndev_set_drvdata(device, dev);\r\nif (register_netdev(dev) == 0)\r\nreturn 0;\r\ndev_set_drvdata(device, NULL);\r\nret = -ENOMEM;\r\ngetout4:\r\nfree_irq(dev->irq, dev);\r\ngetout3:\r\nrelease_region(dev->base_addr-MADGEMC_SIF_OFFSET,\r\nMADGEMC_IO_EXTENT);\r\ngetout2:\r\nkfree(card);\r\ngetout1:\r\nfree_netdev(dev);\r\ngetout:\r\nmca_device_set_claim(mdev, 0);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t madgemc_interrupt(int irq, void *dev_id)\r\n{\r\nint pending,reg1;\r\nstruct net_device *dev;\r\nif (!dev_id) {\r\nprintk("madgemc_interrupt: was not passed a dev_id!\n");\r\nreturn IRQ_NONE;\r\n}\r\ndev = dev_id;\r\npending = inb(dev->base_addr + MC_CONTROL_REG0);\r\nif (!(pending & MC_CONTROL_REG0_SINTR))\r\nreturn IRQ_NONE;\r\npending = STS_SYSTEM_IRQ;\r\ndo {\r\nif (pending & STS_SYSTEM_IRQ) {\r\nreg1 = inb(dev->base_addr + MC_CONTROL_REG1);\r\noutb(reg1 ^ MC_CONTROL_REG1_SINTEN,\r\ndev->base_addr + MC_CONTROL_REG1);\r\noutb(reg1, dev->base_addr + MC_CONTROL_REG1);\r\ntms380tr_interrupt(irq, dev_id);\r\npending = SIFREADW(SIFSTS);\r\n} else\r\nreturn IRQ_HANDLED;\r\n} while (1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned short madgemc_setnselout_pins(struct net_device *dev)\r\n{\r\nunsigned char reg1;\r\nstruct net_local *tp = netdev_priv(dev);\r\nreg1 = inb(dev->base_addr + MC_CONTROL_REG1);\r\nif(tp->DataRate == SPEED_16)\r\nreg1 |= MC_CONTROL_REG1_SPEED_SEL;\r\nelse if (reg1 & MC_CONTROL_REG1_SPEED_SEL)\r\nreg1 ^= MC_CONTROL_REG1_SPEED_SEL;\r\noutb(reg1, dev->base_addr + MC_CONTROL_REG1);\r\nreturn 0;\r\n}\r\nstatic void madgemc_setregpage(struct net_device *dev, int page)\r\n{\r\nstatic int reg1;\r\nreg1 = inb(dev->base_addr + MC_CONTROL_REG1);\r\nif ((page == 0) && (reg1 & MC_CONTROL_REG1_SRSX)) {\r\noutb(reg1 ^ MC_CONTROL_REG1_SRSX,\r\ndev->base_addr + MC_CONTROL_REG1);\r\n}\r\nelse if (page == 1) {\r\noutb(reg1 | MC_CONTROL_REG1_SRSX,\r\ndev->base_addr + MC_CONTROL_REG1);\r\n}\r\nreg1 = inb(dev->base_addr + MC_CONTROL_REG1);\r\n}\r\nstatic void madgemc_setsifsel(struct net_device *dev, int val)\r\n{\r\nunsigned int reg0;\r\nreg0 = inb(dev->base_addr + MC_CONTROL_REG0);\r\nif ((val == 0) && (reg0 & MC_CONTROL_REG0_SIFSEL)) {\r\noutb(reg0 ^ MC_CONTROL_REG0_SIFSEL,\r\ndev->base_addr + MC_CONTROL_REG0);\r\n} else if (val == 1) {\r\noutb(reg0 | MC_CONTROL_REG0_SIFSEL,\r\ndev->base_addr + MC_CONTROL_REG0);\r\n}\r\nreg0 = inb(dev->base_addr + MC_CONTROL_REG0);\r\n}\r\nstatic void madgemc_setint(struct net_device *dev, int val)\r\n{\r\nunsigned int reg1;\r\nreg1 = inb(dev->base_addr + MC_CONTROL_REG1);\r\nif ((val == 0) && (reg1 & MC_CONTROL_REG1_SINTEN)) {\r\noutb(reg1 ^ MC_CONTROL_REG1_SINTEN,\r\ndev->base_addr + MC_CONTROL_REG1);\r\n} else if (val == 1) {\r\noutb(reg1 | MC_CONTROL_REG1_SINTEN,\r\ndev->base_addr + MC_CONTROL_REG1);\r\n}\r\n}\r\nstatic void madgemc_setcabletype(struct net_device *dev, int type)\r\n{\r\noutb((type==0)?MC_CONTROL_REG7_CABLEUTP:MC_CONTROL_REG7_CABLESTP,\r\ndev->base_addr + MC_CONTROL_REG7);\r\n}\r\nstatic int madgemc_chipset_init(struct net_device *dev)\r\n{\r\noutb(0, dev->base_addr + MC_CONTROL_REG1);\r\ntms380tr_wait(100);\r\noutb(MC_CONTROL_REG1_NSRESET, dev->base_addr + MC_CONTROL_REG1);\r\nmadgemc_setsifsel(dev, 1);\r\nmadgemc_setint(dev, 1);\r\nreturn 0;\r\n}\r\nstatic void madgemc_chipset_close(struct net_device *dev)\r\n{\r\nmadgemc_setint(dev, 0);\r\nmadgemc_setsifsel(dev, 0);\r\n}\r\nstatic void madgemc_read_rom(struct net_device *dev, struct card_info *card)\r\n{\r\nunsigned long ioaddr;\r\nunsigned char reg0, reg1, tmpreg0, i;\r\nioaddr = dev->base_addr;\r\nreg0 = inb(ioaddr + MC_CONTROL_REG0);\r\nreg1 = inb(ioaddr + MC_CONTROL_REG1);\r\ntmpreg0 = reg0 & ~(MC_CONTROL_REG0_PAGE + MC_CONTROL_REG0_SIFSEL);\r\noutb(tmpreg0, ioaddr + MC_CONTROL_REG0);\r\ncard->manid = inb(ioaddr + MC_ROM_MANUFACTURERID);\r\ncard->cardtype = inb(ioaddr + MC_ROM_ADAPTERID);\r\ncard->cardrev = inb(ioaddr + MC_ROM_REVISION);\r\noutb(tmpreg0 | MC_CONTROL_REG0_PAGE, ioaddr + MC_CONTROL_REG0);\r\ndev->addr_len = 6;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + MC_ROM_BIA_START + i);\r\noutb(reg0, ioaddr + MC_CONTROL_REG0);\r\noutb(reg1, ioaddr + MC_CONTROL_REG1);\r\n}\r\nstatic int madgemc_open(struct net_device *dev)\r\n{\r\nmadgemc_chipset_init(dev);\r\ntms380tr_open(dev);\r\nreturn 0;\r\n}\r\nstatic int madgemc_close(struct net_device *dev)\r\n{\r\ntms380tr_close(dev);\r\nmadgemc_chipset_close(dev);\r\nreturn 0;\r\n}\r\nstatic int madgemc_mcaproc(char *buf, int slot, void *d)\r\n{\r\nstruct net_device *dev = (struct net_device *)d;\r\nstruct net_local *tp = netdev_priv(dev);\r\nstruct card_info *curcard = tp->tmspriv;\r\nint len = 0;\r\nlen += sprintf(buf+len, "-------\n");\r\nif (curcard) {\r\nlen += sprintf(buf+len, "Card Revision: %d\n", curcard->cardrev);\r\nlen += sprintf(buf+len, "RAM Size: %dkb\n", curcard->ramsize);\r\nlen += sprintf(buf+len, "Cable type: %s\n", (curcard->cabletype)?"STP/DB9":"UTP/RJ-45");\r\nlen += sprintf(buf+len, "Configured ring speed: %dMb/sec\n", (curcard->ringspeed)?16:4);\r\nlen += sprintf(buf+len, "Running ring speed: %dMb/sec\n", (tp->DataRate==SPEED_16)?16:4);\r\nlen += sprintf(buf+len, "Device: %s\n", dev->name);\r\nlen += sprintf(buf+len, "IO Port: 0x%04lx\n", dev->base_addr);\r\nlen += sprintf(buf+len, "IRQ: %d\n", dev->irq);\r\nlen += sprintf(buf+len, "Arbitration Level: %d\n", curcard->arblevel);\r\nlen += sprintf(buf+len, "Burst Mode: ");\r\nswitch(curcard->burstmode) {\r\ncase 0: len += sprintf(buf+len, "Cycle steal"); break;\r\ncase 1: len += sprintf(buf+len, "Limited burst"); break;\r\ncase 2: len += sprintf(buf+len, "Delayed release"); break;\r\ncase 3: len += sprintf(buf+len, "Immediate release"); break;\r\n}\r\nlen += sprintf(buf+len, " (%s)\n", (curcard->fairness)?"Unfair":"Fair");\r\nlen += sprintf(buf+len, "Ring Station Address: %pM\n",\r\ndev->dev_addr);\r\n} else\r\nlen += sprintf(buf+len, "Card not configured\n");\r\nreturn len;\r\n}\r\nstatic int __devexit madgemc_remove(struct device *device)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(device);\r\nstruct net_local *tp;\r\nstruct card_info *card;\r\nBUG_ON(!dev);\r\ntp = netdev_priv(dev);\r\ncard = tp->tmspriv;\r\nkfree(card);\r\ntp->tmspriv = NULL;\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr-MADGEMC_SIF_OFFSET, MADGEMC_IO_EXTENT);\r\nfree_irq(dev->irq, dev);\r\ntmsdev_term(dev);\r\nfree_netdev(dev);\r\ndev_set_drvdata(device, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init madgemc_init (void)\r\n{\r\nmadgemc_netdev_ops = tms380tr_netdev_ops;\r\nmadgemc_netdev_ops.ndo_open = madgemc_open;\r\nmadgemc_netdev_ops.ndo_stop = madgemc_close;\r\nreturn mca_register_driver (&madgemc_driver);\r\n}\r\nstatic void __exit madgemc_exit (void)\r\n{\r\nmca_unregister_driver (&madgemc_driver);\r\n}
