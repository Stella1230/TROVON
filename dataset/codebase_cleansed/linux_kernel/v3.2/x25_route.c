static int x25_add_route(struct x25_address *address, unsigned int sigdigits,\r\nstruct net_device *dev)\r\n{\r\nstruct x25_route *rt;\r\nstruct list_head *entry;\r\nint rc = -EINVAL;\r\nwrite_lock_bh(&x25_route_list_lock);\r\nlist_for_each(entry, &x25_route_list) {\r\nrt = list_entry(entry, struct x25_route, node);\r\nif (!memcmp(&rt->address, address, sigdigits) &&\r\nrt->sigdigits == sigdigits)\r\ngoto out;\r\n}\r\nrt = kmalloc(sizeof(*rt), GFP_ATOMIC);\r\nrc = -ENOMEM;\r\nif (!rt)\r\ngoto out;\r\nstrcpy(rt->address.x25_addr, "000000000000000");\r\nmemcpy(rt->address.x25_addr, address->x25_addr, sigdigits);\r\nrt->sigdigits = sigdigits;\r\nrt->dev = dev;\r\natomic_set(&rt->refcnt, 1);\r\nlist_add(&rt->node, &x25_route_list);\r\nrc = 0;\r\nout:\r\nwrite_unlock_bh(&x25_route_list_lock);\r\nreturn rc;\r\n}\r\nstatic void __x25_remove_route(struct x25_route *rt)\r\n{\r\nif (rt->node.next) {\r\nlist_del(&rt->node);\r\nx25_route_put(rt);\r\n}\r\n}\r\nstatic int x25_del_route(struct x25_address *address, unsigned int sigdigits,\r\nstruct net_device *dev)\r\n{\r\nstruct x25_route *rt;\r\nstruct list_head *entry;\r\nint rc = -EINVAL;\r\nwrite_lock_bh(&x25_route_list_lock);\r\nlist_for_each(entry, &x25_route_list) {\r\nrt = list_entry(entry, struct x25_route, node);\r\nif (!memcmp(&rt->address, address, sigdigits) &&\r\nrt->sigdigits == sigdigits && rt->dev == dev) {\r\n__x25_remove_route(rt);\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nwrite_unlock_bh(&x25_route_list_lock);\r\nreturn rc;\r\n}\r\nvoid x25_route_device_down(struct net_device *dev)\r\n{\r\nstruct x25_route *rt;\r\nstruct list_head *entry, *tmp;\r\nwrite_lock_bh(&x25_route_list_lock);\r\nlist_for_each_safe(entry, tmp, &x25_route_list) {\r\nrt = list_entry(entry, struct x25_route, node);\r\nif (rt->dev == dev)\r\n__x25_remove_route(rt);\r\n}\r\nwrite_unlock_bh(&x25_route_list_lock);\r\nx25_clear_forward_by_dev(dev);\r\n}\r\nstruct net_device *x25_dev_get(char *devname)\r\n{\r\nstruct net_device *dev = dev_get_by_name(&init_net, devname);\r\nif (dev &&\r\n(!(dev->flags & IFF_UP) || (dev->type != ARPHRD_X25\r\n#if defined(CONFIG_LLC) || defined(CONFIG_LLC_MODULE)\r\n&& dev->type != ARPHRD_ETHER\r\n#endif\r\n))){\r\ndev_put(dev);\r\ndev = NULL;\r\n}\r\nreturn dev;\r\n}\r\nstruct x25_route *x25_get_route(struct x25_address *addr)\r\n{\r\nstruct x25_route *rt, *use = NULL;\r\nstruct list_head *entry;\r\nread_lock_bh(&x25_route_list_lock);\r\nlist_for_each(entry, &x25_route_list) {\r\nrt = list_entry(entry, struct x25_route, node);\r\nif (!memcmp(&rt->address, addr, rt->sigdigits)) {\r\nif (!use)\r\nuse = rt;\r\nelse if (rt->sigdigits > use->sigdigits)\r\nuse = rt;\r\n}\r\n}\r\nif (use)\r\nx25_route_hold(use);\r\nread_unlock_bh(&x25_route_list_lock);\r\nreturn use;\r\n}\r\nint x25_route_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct x25_route_struct rt;\r\nstruct net_device *dev;\r\nint rc = -EINVAL;\r\nif (cmd != SIOCADDRT && cmd != SIOCDELRT)\r\ngoto out;\r\nrc = -EFAULT;\r\nif (copy_from_user(&rt, arg, sizeof(rt)))\r\ngoto out;\r\nrc = -EINVAL;\r\nif (rt.sigdigits > 15)\r\ngoto out;\r\ndev = x25_dev_get(rt.device);\r\nif (!dev)\r\ngoto out;\r\nif (cmd == SIOCADDRT)\r\nrc = x25_add_route(&rt.address, rt.sigdigits, dev);\r\nelse\r\nrc = x25_del_route(&rt.address, rt.sigdigits, dev);\r\ndev_put(dev);\r\nout:\r\nreturn rc;\r\n}\r\nvoid __exit x25_route_free(void)\r\n{\r\nstruct x25_route *rt;\r\nstruct list_head *entry, *tmp;\r\nwrite_lock_bh(&x25_route_list_lock);\r\nlist_for_each_safe(entry, tmp, &x25_route_list) {\r\nrt = list_entry(entry, struct x25_route, node);\r\n__x25_remove_route(rt);\r\n}\r\nwrite_unlock_bh(&x25_route_list_lock);\r\n}
