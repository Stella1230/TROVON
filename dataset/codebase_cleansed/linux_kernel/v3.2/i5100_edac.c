static inline u32 i5100_mc_scrben(u32 mc)\r\n{\r\nreturn mc >> 7 & 1;\r\n}\r\nstatic inline u32 i5100_mc_errdeten(u32 mc)\r\n{\r\nreturn mc >> 5 & 1;\r\n}\r\nstatic inline u32 i5100_mc_scrbdone(u32 mc)\r\n{\r\nreturn mc >> 4 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_rdo(u16 a)\r\n{\r\nreturn a >> 15 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_sbe(u16 a)\r\n{\r\nreturn a >> 13 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_busy(u16 a)\r\n{\r\nreturn a >> 12 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_data(u16 a)\r\n{\r\nreturn a & ((1 << 8) - 1);\r\n}\r\nstatic inline u32 i5100_spdcmd_create(u32 dti, u32 ckovrd, u32 sa, u32 ba,\r\nu32 data, u32 cmd)\r\n{\r\nreturn ((dti & ((1 << 4) - 1)) << 28) |\r\n((ckovrd & 1) << 27) |\r\n((sa & ((1 << 3) - 1)) << 24) |\r\n((ba & ((1 << 8) - 1)) << 16) |\r\n((data & ((1 << 8) - 1)) << 8) |\r\n(cmd & 1);\r\n}\r\nstatic inline u16 i5100_tolm_tolm(u16 a)\r\n{\r\nreturn a >> 12 & ((1 << 4) - 1);\r\n}\r\nstatic inline u16 i5100_mir_limit(u16 a)\r\n{\r\nreturn a >> 4 & ((1 << 12) - 1);\r\n}\r\nstatic inline u16 i5100_mir_way1(u16 a)\r\n{\r\nreturn a >> 1 & 1;\r\n}\r\nstatic inline u16 i5100_mir_way0(u16 a)\r\n{\r\nreturn a & 1;\r\n}\r\nstatic inline u32 i5100_ferr_nf_mem_chan_indx(u32 a)\r\n{\r\nreturn a >> 28 & 1;\r\n}\r\nstatic inline u32 i5100_ferr_nf_mem_any(u32 a)\r\n{\r\nreturn a & I5100_FERR_NF_MEM_ANY_MASK;\r\n}\r\nstatic inline u32 i5100_nerr_nf_mem_any(u32 a)\r\n{\r\nreturn i5100_ferr_nf_mem_any(a);\r\n}\r\nstatic inline u32 i5100_dmir_limit(u32 a)\r\n{\r\nreturn a >> 16 & ((1 << 11) - 1);\r\n}\r\nstatic inline u32 i5100_dmir_rank(u32 a, u32 i)\r\n{\r\nreturn a >> (4 * i) & ((1 << 2) - 1);\r\n}\r\nstatic inline u16 i5100_mtr_present(u16 a)\r\n{\r\nreturn a >> 10 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_ethrottle(u16 a)\r\n{\r\nreturn a >> 9 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_width(u16 a)\r\n{\r\nreturn a >> 8 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_numbank(u16 a)\r\n{\r\nreturn a >> 6 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_numrow(u16 a)\r\n{\r\nreturn a >> 2 & ((1 << 2) - 1);\r\n}\r\nstatic inline u16 i5100_mtr_numcol(u16 a)\r\n{\r\nreturn a & ((1 << 2) - 1);\r\n}\r\nstatic inline u32 i5100_validlog_redmemvalid(u32 a)\r\n{\r\nreturn a >> 2 & 1;\r\n}\r\nstatic inline u32 i5100_validlog_recmemvalid(u32 a)\r\n{\r\nreturn a >> 1 & 1;\r\n}\r\nstatic inline u32 i5100_validlog_nrecmemvalid(u32 a)\r\n{\r\nreturn a & 1;\r\n}\r\nstatic inline u32 i5100_nrecmema_merr(u32 a)\r\n{\r\nreturn a >> 15 & ((1 << 5) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmema_bank(u32 a)\r\n{\r\nreturn a >> 12 & ((1 << 3) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmema_rank(u32 a)\r\n{\r\nreturn a >> 8 & ((1 << 3) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmema_dm_buf_id(u32 a)\r\n{\r\nreturn a & ((1 << 8) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmemb_cas(u32 a)\r\n{\r\nreturn a >> 16 & ((1 << 13) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmemb_ras(u32 a)\r\n{\r\nreturn a & ((1 << 16) - 1);\r\n}\r\nstatic inline u32 i5100_redmemb_ecc_locator(u32 a)\r\n{\r\nreturn a & ((1 << 18) - 1);\r\n}\r\nstatic inline u32 i5100_recmema_merr(u32 a)\r\n{\r\nreturn i5100_nrecmema_merr(a);\r\n}\r\nstatic inline u32 i5100_recmema_bank(u32 a)\r\n{\r\nreturn i5100_nrecmema_bank(a);\r\n}\r\nstatic inline u32 i5100_recmema_rank(u32 a)\r\n{\r\nreturn i5100_nrecmema_rank(a);\r\n}\r\nstatic inline u32 i5100_recmema_dm_buf_id(u32 a)\r\n{\r\nreturn i5100_nrecmema_dm_buf_id(a);\r\n}\r\nstatic inline u32 i5100_recmemb_cas(u32 a)\r\n{\r\nreturn i5100_nrecmemb_cas(a);\r\n}\r\nstatic inline u32 i5100_recmemb_ras(u32 a)\r\n{\r\nreturn i5100_nrecmemb_ras(a);\r\n}\r\nstatic int i5100_rank_to_slot(const struct mem_ctl_info *mci,\r\nint chan, int rank)\r\n{\r\nconst struct i5100_priv *priv = mci->pvt_info;\r\nint i;\r\nfor (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {\r\nint j;\r\nconst int numrank = priv->dimm_numrank[chan][i];\r\nfor (j = 0; j < numrank; j++)\r\nif (priv->dimm_csmap[i][j] == rank)\r\nreturn i * 2 + chan;\r\n}\r\nreturn -1;\r\n}\r\nstatic const char *i5100_err_msg(unsigned err)\r\n{\r\nstatic const char *merrs[] = {\r\n"unknown",\r\n"uncorrectable data ECC on replay",\r\n"unknown",\r\n"unknown",\r\n"aliased uncorrectable demand data ECC",\r\n"aliased uncorrectable spare-copy data ECC",\r\n"aliased uncorrectable patrol data ECC",\r\n"unknown",\r\n"unknown",\r\n"unknown",\r\n"non-aliased uncorrectable demand data ECC",\r\n"non-aliased uncorrectable spare-copy data ECC",\r\n"non-aliased uncorrectable patrol data ECC",\r\n"unknown",\r\n"correctable demand data ECC",\r\n"correctable spare-copy data ECC",\r\n"correctable patrol data ECC",\r\n"unknown",\r\n"SPD protocol error",\r\n"unknown",\r\n"spare copy initiated",\r\n"spare copy completed",\r\n};\r\nunsigned i;\r\nfor (i = 0; i < ARRAY_SIZE(merrs); i++)\r\nif (1 << i & err)\r\nreturn merrs[i];\r\nreturn "none";\r\n}\r\nstatic int i5100_csrow_to_rank(const struct mem_ctl_info *mci, int csrow)\r\n{\r\nconst struct i5100_priv *priv = mci->pvt_info;\r\nreturn csrow % priv->ranksperchan;\r\n}\r\nstatic int i5100_csrow_to_chan(const struct mem_ctl_info *mci, int csrow)\r\n{\r\nconst struct i5100_priv *priv = mci->pvt_info;\r\nreturn csrow / priv->ranksperchan;\r\n}\r\nstatic unsigned i5100_rank_to_csrow(const struct mem_ctl_info *mci,\r\nint chan, int rank)\r\n{\r\nconst struct i5100_priv *priv = mci->pvt_info;\r\nreturn chan * priv->ranksperchan + rank;\r\n}\r\nstatic void i5100_handle_ce(struct mem_ctl_info *mci,\r\nint chan,\r\nunsigned bank,\r\nunsigned rank,\r\nunsigned long syndrome,\r\nunsigned cas,\r\nunsigned ras,\r\nconst char *msg)\r\n{\r\nconst int csrow = i5100_rank_to_csrow(mci, chan, rank);\r\nprintk(KERN_ERR\r\n"CE chan %d, bank %u, rank %u, syndrome 0x%lx, "\r\n"cas %u, ras %u, csrow %u, label \"%s\": %s\n",\r\nchan, bank, rank, syndrome, cas, ras,\r\ncsrow, mci->csrows[csrow].channels[0].label, msg);\r\nmci->ce_count++;\r\nmci->csrows[csrow].ce_count++;\r\nmci->csrows[csrow].channels[0].ce_count++;\r\n}\r\nstatic void i5100_handle_ue(struct mem_ctl_info *mci,\r\nint chan,\r\nunsigned bank,\r\nunsigned rank,\r\nunsigned long syndrome,\r\nunsigned cas,\r\nunsigned ras,\r\nconst char *msg)\r\n{\r\nconst int csrow = i5100_rank_to_csrow(mci, chan, rank);\r\nprintk(KERN_ERR\r\n"UE chan %d, bank %u, rank %u, syndrome 0x%lx, "\r\n"cas %u, ras %u, csrow %u, label \"%s\": %s\n",\r\nchan, bank, rank, syndrome, cas, ras,\r\ncsrow, mci->csrows[csrow].channels[0].label, msg);\r\nmci->ue_count++;\r\nmci->csrows[csrow].ue_count++;\r\n}\r\nstatic void i5100_read_log(struct mem_ctl_info *mci, int chan,\r\nu32 ferr, u32 nerr)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nstruct pci_dev *pdev = (chan) ? priv->ch1mm : priv->ch0mm;\r\nu32 dw;\r\nu32 dw2;\r\nunsigned syndrome = 0;\r\nunsigned ecc_loc = 0;\r\nunsigned merr;\r\nunsigned bank;\r\nunsigned rank;\r\nunsigned cas;\r\nunsigned ras;\r\npci_read_config_dword(pdev, I5100_VALIDLOG, &dw);\r\nif (i5100_validlog_redmemvalid(dw)) {\r\npci_read_config_dword(pdev, I5100_REDMEMA, &dw2);\r\nsyndrome = dw2;\r\npci_read_config_dword(pdev, I5100_REDMEMB, &dw2);\r\necc_loc = i5100_redmemb_ecc_locator(dw2);\r\n}\r\nif (i5100_validlog_recmemvalid(dw)) {\r\nconst char *msg;\r\npci_read_config_dword(pdev, I5100_RECMEMA, &dw2);\r\nmerr = i5100_recmema_merr(dw2);\r\nbank = i5100_recmema_bank(dw2);\r\nrank = i5100_recmema_rank(dw2);\r\npci_read_config_dword(pdev, I5100_RECMEMB, &dw2);\r\ncas = i5100_recmemb_cas(dw2);\r\nras = i5100_recmemb_ras(dw2);\r\nif (!merr)\r\nmsg = i5100_err_msg(ferr);\r\nelse\r\nmsg = i5100_err_msg(nerr);\r\ni5100_handle_ce(mci, chan, bank, rank, syndrome, cas, ras, msg);\r\n}\r\nif (i5100_validlog_nrecmemvalid(dw)) {\r\nconst char *msg;\r\npci_read_config_dword(pdev, I5100_NRECMEMA, &dw2);\r\nmerr = i5100_nrecmema_merr(dw2);\r\nbank = i5100_nrecmema_bank(dw2);\r\nrank = i5100_nrecmema_rank(dw2);\r\npci_read_config_dword(pdev, I5100_NRECMEMB, &dw2);\r\ncas = i5100_nrecmemb_cas(dw2);\r\nras = i5100_nrecmemb_ras(dw2);\r\nif (!merr)\r\nmsg = i5100_err_msg(ferr);\r\nelse\r\nmsg = i5100_err_msg(nerr);\r\ni5100_handle_ue(mci, chan, bank, rank, syndrome, cas, ras, msg);\r\n}\r\npci_write_config_dword(pdev, I5100_VALIDLOG, dw);\r\n}\r\nstatic void i5100_check_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu32 dw;\r\npci_read_config_dword(priv->mc, I5100_FERR_NF_MEM, &dw);\r\nif (i5100_ferr_nf_mem_any(dw)) {\r\nu32 dw2;\r\npci_read_config_dword(priv->mc, I5100_NERR_NF_MEM, &dw2);\r\nif (dw2)\r\npci_write_config_dword(priv->mc, I5100_NERR_NF_MEM,\r\ndw2);\r\npci_write_config_dword(priv->mc, I5100_FERR_NF_MEM, dw);\r\ni5100_read_log(mci, i5100_ferr_nf_mem_chan_indx(dw),\r\ni5100_ferr_nf_mem_any(dw),\r\ni5100_nerr_nf_mem_any(dw2));\r\n}\r\n}\r\nstatic void i5100_refresh_scrubbing(struct work_struct *work)\r\n{\r\nstruct delayed_work *i5100_scrubbing = container_of(work,\r\nstruct delayed_work,\r\nwork);\r\nstruct i5100_priv *priv = container_of(i5100_scrubbing,\r\nstruct i5100_priv,\r\ni5100_scrubbing);\r\nu32 dw;\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nif (priv->scrub_enable) {\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nif (i5100_mc_scrbdone(dw)) {\r\ndw |= I5100_MC_SCRBEN_MASK;\r\npci_write_config_dword(priv->mc, I5100_MC, dw);\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\n}\r\nschedule_delayed_work(&(priv->i5100_scrubbing),\r\nI5100_SCRUB_REFRESH_RATE);\r\n}\r\n}\r\nstatic int i5100_set_scrub_rate(struct mem_ctl_info *mci, u32 bandwidth)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu32 dw;\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nif (bandwidth) {\r\npriv->scrub_enable = 1;\r\ndw |= I5100_MC_SCRBEN_MASK;\r\nschedule_delayed_work(&(priv->i5100_scrubbing),\r\nI5100_SCRUB_REFRESH_RATE);\r\n} else {\r\npriv->scrub_enable = 0;\r\ndw &= ~I5100_MC_SCRBEN_MASK;\r\ncancel_delayed_work(&(priv->i5100_scrubbing));\r\n}\r\npci_write_config_dword(priv->mc, I5100_MC, dw);\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nbandwidth = 5900000 * i5100_mc_scrben(dw);\r\nreturn bandwidth;\r\n}\r\nstatic int i5100_get_scrub_rate(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu32 dw;\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nreturn 5900000 * i5100_mc_scrben(dw);\r\n}\r\nstatic struct pci_dev *pci_get_device_func(unsigned vendor,\r\nunsigned device,\r\nunsigned func)\r\n{\r\nstruct pci_dev *ret = NULL;\r\nwhile (1) {\r\nret = pci_get_device(vendor, device, ret);\r\nif (!ret)\r\nbreak;\r\nif (PCI_FUNC(ret->devfn) == func)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned long __devinit i5100_npages(struct mem_ctl_info *mci,\r\nint csrow)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nconst unsigned chan_rank = i5100_csrow_to_rank(mci, csrow);\r\nconst unsigned chan = i5100_csrow_to_chan(mci, csrow);\r\nunsigned addr_lines;\r\nif (!priv->mtr[chan][chan_rank].present)\r\nreturn 0ULL;\r\naddr_lines =\r\nI5100_DIMM_ADDR_LINES +\r\npriv->mtr[chan][chan_rank].numcol +\r\npriv->mtr[chan][chan_rank].numrow +\r\npriv->mtr[chan][chan_rank].numbank;\r\nreturn (unsigned long)\r\n((unsigned long long) (1ULL << addr_lines) / PAGE_SIZE);\r\n}\r\nstatic void __devinit i5100_init_mtr(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nstruct pci_dev *mms[2] = { priv->ch0mm, priv->ch1mm };\r\nint i;\r\nfor (i = 0; i < I5100_CHANNELS; i++) {\r\nint j;\r\nstruct pci_dev *pdev = mms[i];\r\nfor (j = 0; j < I5100_MAX_RANKS_PER_CHAN; j++) {\r\nconst unsigned addr =\r\n(j < 4) ? I5100_MTR_0 + j * 2 :\r\nI5100_MTR_4 + (j - 4) * 2;\r\nu16 w;\r\npci_read_config_word(pdev, addr, &w);\r\npriv->mtr[i][j].present = i5100_mtr_present(w);\r\npriv->mtr[i][j].ethrottle = i5100_mtr_ethrottle(w);\r\npriv->mtr[i][j].width = 4 + 4 * i5100_mtr_width(w);\r\npriv->mtr[i][j].numbank = 2 + i5100_mtr_numbank(w);\r\npriv->mtr[i][j].numrow = 13 + i5100_mtr_numrow(w);\r\npriv->mtr[i][j].numcol = 10 + i5100_mtr_numcol(w);\r\n}\r\n}\r\n}\r\nstatic int i5100_read_spd_byte(const struct mem_ctl_info *mci,\r\nu8 ch, u8 slot, u8 addr, u8 *byte)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu16 w;\r\nunsigned long et;\r\npci_read_config_word(priv->mc, I5100_SPDDATA, &w);\r\nif (i5100_spddata_busy(w))\r\nreturn -1;\r\npci_write_config_dword(priv->mc, I5100_SPDCMD,\r\ni5100_spdcmd_create(0xa, 1, ch * 4 + slot, addr,\r\n0, 0));\r\net = jiffies + HZ / 10;\r\nudelay(100);\r\nwhile (1) {\r\npci_read_config_word(priv->mc, I5100_SPDDATA, &w);\r\nif (!i5100_spddata_busy(w))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (!i5100_spddata_rdo(w) || i5100_spddata_sbe(w))\r\nreturn -1;\r\n*byte = i5100_spddata_data(w);\r\nreturn 0;\r\n}\r\nstatic void __devinit i5100_init_dimm_csmap(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nint i;\r\nfor (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {\r\nint j;\r\nfor (j = 0; j < I5100_MAX_RANKS_PER_DIMM; j++)\r\npriv->dimm_csmap[i][j] = -1;\r\n}\r\nif (priv->ranksperchan == 4) {\r\npriv->dimm_csmap[0][0] = 0;\r\npriv->dimm_csmap[0][1] = 3;\r\npriv->dimm_csmap[1][0] = 1;\r\npriv->dimm_csmap[1][1] = 2;\r\npriv->dimm_csmap[2][0] = 2;\r\npriv->dimm_csmap[3][0] = 3;\r\n} else {\r\npriv->dimm_csmap[0][0] = 0;\r\npriv->dimm_csmap[0][1] = 1;\r\npriv->dimm_csmap[1][0] = 2;\r\npriv->dimm_csmap[1][1] = 3;\r\npriv->dimm_csmap[2][0] = 4;\r\npriv->dimm_csmap[2][1] = 5;\r\n}\r\n}\r\nstatic void __devinit i5100_init_dimm_layout(struct pci_dev *pdev,\r\nstruct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nint i;\r\nfor (i = 0; i < I5100_CHANNELS; i++) {\r\nint j;\r\nfor (j = 0; j < I5100_MAX_DIMM_SLOTS_PER_CHAN; j++) {\r\nu8 rank;\r\nif (i5100_read_spd_byte(mci, i, j, 5, &rank) < 0)\r\npriv->dimm_numrank[i][j] = 0;\r\nelse\r\npriv->dimm_numrank[i][j] = (rank & 3) + 1;\r\n}\r\n}\r\ni5100_init_dimm_csmap(mci);\r\n}\r\nstatic void __devinit i5100_init_interleaving(struct pci_dev *pdev,\r\nstruct mem_ctl_info *mci)\r\n{\r\nu16 w;\r\nu32 dw;\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nstruct pci_dev *mms[2] = { priv->ch0mm, priv->ch1mm };\r\nint i;\r\npci_read_config_word(pdev, I5100_TOLM, &w);\r\npriv->tolm = (u64) i5100_tolm_tolm(w) * 256 * 1024 * 1024;\r\npci_read_config_word(pdev, I5100_MIR0, &w);\r\npriv->mir[0].limit = (u64) i5100_mir_limit(w) << 28;\r\npriv->mir[0].way[1] = i5100_mir_way1(w);\r\npriv->mir[0].way[0] = i5100_mir_way0(w);\r\npci_read_config_word(pdev, I5100_MIR1, &w);\r\npriv->mir[1].limit = (u64) i5100_mir_limit(w) << 28;\r\npriv->mir[1].way[1] = i5100_mir_way1(w);\r\npriv->mir[1].way[0] = i5100_mir_way0(w);\r\npci_read_config_word(pdev, I5100_AMIR_0, &w);\r\npriv->amir[0] = w;\r\npci_read_config_word(pdev, I5100_AMIR_1, &w);\r\npriv->amir[1] = w;\r\nfor (i = 0; i < I5100_CHANNELS; i++) {\r\nint j;\r\nfor (j = 0; j < 5; j++) {\r\nint k;\r\npci_read_config_dword(mms[i], I5100_DMIR + j * 4, &dw);\r\npriv->dmir[i][j].limit =\r\n(u64) i5100_dmir_limit(dw) << 28;\r\nfor (k = 0; k < I5100_MAX_RANKS_PER_DIMM; k++)\r\npriv->dmir[i][j].rank[k] =\r\ni5100_dmir_rank(dw, k);\r\n}\r\n}\r\ni5100_init_mtr(mci);\r\n}\r\nstatic void __devinit i5100_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\nunsigned long total_pages = 0UL;\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nconst unsigned long npages = i5100_npages(mci, i);\r\nconst unsigned chan = i5100_csrow_to_chan(mci, i);\r\nconst unsigned rank = i5100_csrow_to_rank(mci, i);\r\nif (!npages)\r\ncontinue;\r\nmci->csrows[i].first_page = total_pages;\r\nmci->csrows[i].last_page = total_pages + npages - 1;\r\nmci->csrows[i].page_mask = 0UL;\r\nmci->csrows[i].nr_pages = npages;\r\nmci->csrows[i].grain = 32;\r\nmci->csrows[i].csrow_idx = i;\r\nmci->csrows[i].dtype =\r\n(priv->mtr[chan][rank].width == 4) ? DEV_X4 : DEV_X8;\r\nmci->csrows[i].ue_count = 0;\r\nmci->csrows[i].ce_count = 0;\r\nmci->csrows[i].mtype = MEM_RDDR2;\r\nmci->csrows[i].edac_mode = EDAC_SECDED;\r\nmci->csrows[i].mci = mci;\r\nmci->csrows[i].nr_channels = 1;\r\nmci->csrows[i].channels[0].chan_idx = 0;\r\nmci->csrows[i].channels[0].ce_count = 0;\r\nmci->csrows[i].channels[0].csrow = mci->csrows + i;\r\nsnprintf(mci->csrows[i].channels[0].label,\r\nsizeof(mci->csrows[i].channels[0].label),\r\n"DIMM%u", i5100_rank_to_slot(mci, chan, rank));\r\ntotal_pages += npages;\r\n}\r\n}\r\nstatic int __devinit i5100_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint rc;\r\nstruct mem_ctl_info *mci;\r\nstruct i5100_priv *priv;\r\nstruct pci_dev *ch0mm, *ch1mm;\r\nint ret = 0;\r\nu32 dw;\r\nint ranksperch;\r\nif (PCI_FUNC(pdev->devfn) != 1)\r\nreturn -ENODEV;\r\nrc = pci_enable_device(pdev);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto bail;\r\n}\r\npci_read_config_dword(pdev, I5100_MC, &dw);\r\nif (!i5100_mc_errdeten(dw)) {\r\nprintk(KERN_INFO "i5100_edac: ECC not enabled.\n");\r\nret = -ENODEV;\r\ngoto bail_pdev;\r\n}\r\npci_read_config_dword(pdev, I5100_MS, &dw);\r\nranksperch = !!(dw & (1 << 8)) * 2 + 4;\r\npci_read_config_dword(pdev, I5100_EMASK_MEM, &dw);\r\ndw &= ~I5100_FERR_NF_MEM_ANY_MASK;\r\npci_write_config_dword(pdev, I5100_EMASK_MEM, dw);\r\nch0mm = pci_get_device_func(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_5100_21, 0);\r\nif (!ch0mm) {\r\nret = -ENODEV;\r\ngoto bail_pdev;\r\n}\r\nrc = pci_enable_device(ch0mm);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto bail_ch0;\r\n}\r\nch1mm = pci_get_device_func(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_5100_22, 0);\r\nif (!ch1mm) {\r\nret = -ENODEV;\r\ngoto bail_disable_ch0;\r\n}\r\nrc = pci_enable_device(ch1mm);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto bail_ch1;\r\n}\r\nmci = edac_mc_alloc(sizeof(*priv), ranksperch * 2, 1, 0);\r\nif (!mci) {\r\nret = -ENOMEM;\r\ngoto bail_disable_ch1;\r\n}\r\nmci->dev = &pdev->dev;\r\npriv = mci->pvt_info;\r\npriv->ranksperchan = ranksperch;\r\npriv->mc = pdev;\r\npriv->ch0mm = ch0mm;\r\npriv->ch1mm = ch1mm;\r\nINIT_DELAYED_WORK(&(priv->i5100_scrubbing), i5100_refresh_scrubbing);\r\npci_read_config_dword(pdev, I5100_MC, &dw);\r\nif (i5100_mc_scrben(dw)) {\r\npriv->scrub_enable = 1;\r\nschedule_delayed_work(&(priv->i5100_scrubbing),\r\nI5100_SCRUB_REFRESH_RATE);\r\n}\r\ni5100_init_dimm_layout(pdev, mci);\r\ni5100_init_interleaving(pdev, mci);\r\nmci->mtype_cap = MEM_FLAG_FB_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = "i5100_edac.c";\r\nmci->mod_ver = "not versioned";\r\nmci->ctl_name = "i5100";\r\nmci->dev_name = pci_name(pdev);\r\nmci->ctl_page_to_phys = NULL;\r\nmci->edac_check = i5100_check_error;\r\nmci->set_sdram_scrub_rate = i5100_set_scrub_rate;\r\nmci->get_sdram_scrub_rate = i5100_get_scrub_rate;\r\ni5100_init_csrows(mci);\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_NMI:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_POLL;\r\nbreak;\r\n}\r\nif (edac_mc_add_mc(mci)) {\r\nret = -ENODEV;\r\ngoto bail_scrub;\r\n}\r\nreturn ret;\r\nbail_scrub:\r\npriv->scrub_enable = 0;\r\ncancel_delayed_work_sync(&(priv->i5100_scrubbing));\r\nedac_mc_free(mci);\r\nbail_disable_ch1:\r\npci_disable_device(ch1mm);\r\nbail_ch1:\r\npci_dev_put(ch1mm);\r\nbail_disable_ch0:\r\npci_disable_device(ch0mm);\r\nbail_ch0:\r\npci_dev_put(ch0mm);\r\nbail_pdev:\r\npci_disable_device(pdev);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void __devexit i5100_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i5100_priv *priv;\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\npriv = mci->pvt_info;\r\npriv->scrub_enable = 0;\r\ncancel_delayed_work_sync(&(priv->i5100_scrubbing));\r\npci_disable_device(pdev);\r\npci_disable_device(priv->ch0mm);\r\npci_disable_device(priv->ch1mm);\r\npci_dev_put(priv->ch0mm);\r\npci_dev_put(priv->ch1mm);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i5100_init(void)\r\n{\r\nint pci_rc;\r\npci_rc = pci_register_driver(&i5100_driver);\r\nreturn (pci_rc < 0) ? pci_rc : 0;\r\n}\r\nstatic void __exit i5100_exit(void)\r\n{\r\npci_unregister_driver(&i5100_driver);\r\n}
