void subdev_700_interrupt(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nshort d;\r\nd = CALLBACK_FUNC(0, _700_DATA, 0, CALLBACK_ARG);\r\ncomedi_buf_put(s->async, d);\r\ns->async->events |= COMEDI_CB_EOS;\r\ncomedi_event(dev, s);\r\n}\r\nstatic int subdev_700_cb(int dir, int port, int data, unsigned long arg)\r\n{\r\nunsigned long iobase = arg;\r\nif (dir) {\r\noutb(data, iobase + DIO_W);\r\nreturn 0;\r\n} else {\r\nreturn inb(iobase + DIO_R);\r\n}\r\n}\r\nstatic int subdev_700_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nif (data[0] & 0xff)\r\nCALLBACK_FUNC(1, _700_DATA, s->state & 0xff,\r\nCALLBACK_ARG);\r\n}\r\ndata[1] = s->state & 0xff;\r\ndata[1] |= CALLBACK_FUNC(0, _700_DATA, 0, CALLBACK_ARG) << 8;\r\nreturn 2;\r\n}\r\nstatic int subdev_700_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_INPUT:\r\nbreak;\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->\r\nio_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :\r\nCOMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 1;\r\n}\r\nstatic void do_config(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nreturn;\r\n}\r\nstatic int subdev_700_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_FOLLOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != 1) {\r\ncmd->scan_end_arg = 1;\r\nerr++;\r\n}\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int subdev_700_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nreturn 0;\r\n}\r\nstatic int subdev_700_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nreturn 0;\r\n}\r\nint subdev_700_init(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint (*cb) (int, int, int, unsigned long), unsigned long arg)\r\n{\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 16;\r\ns->range_table = &range_digital;\r\ns->maxdata = 1;\r\ns->private = kmalloc(sizeof(struct subdev_700_struct), GFP_KERNEL);\r\nif (!s->private)\r\nreturn -ENOMEM;\r\nCALLBACK_ARG = arg;\r\nif (cb == NULL)\r\nCALLBACK_FUNC = subdev_700_cb;\r\nelse\r\nCALLBACK_FUNC = cb;\r\ns->insn_bits = subdev_700_insn;\r\ns->insn_config = subdev_700_insn_config;\r\ns->state = 0;\r\ns->io_bits = 0x00ff;\r\ndo_config(dev, s);\r\nreturn 0;\r\n}\r\nint subdev_700_init_irq(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint (*cb) (int, int, int, unsigned long),\r\nunsigned long arg)\r\n{\r\nint ret;\r\nret = subdev_700_init(dev, s, cb, arg);\r\nif (ret < 0)\r\nreturn ret;\r\ns->do_cmdtest = subdev_700_cmdtest;\r\ns->do_cmd = subdev_700_cmd;\r\ns->cancel = subdev_700_cancel;\r\nsubdevpriv->have_irq = 1;\r\nreturn 0;\r\n}\r\nvoid subdev_700_cleanup(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nif (s->private)\r\nif (subdevpriv->have_irq)\r\nkfree(s->private);\r\n}\r\nstatic int dio700_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nunsigned long iobase = 0;\r\n#ifdef incomplete\r\nunsigned int irq = 0;\r\n#endif\r\nstruct pcmcia_device *link;\r\nif (alloc_private(dev, sizeof(struct dio700_private)) < 0)\r\nreturn -ENOMEM;\r\nswitch (thisboard->bustype) {\r\ncase pcmcia_bustype:\r\nlink = pcmcia_cur_dev;\r\nif (!link)\r\nreturn -EIO;\r\niobase = link->resource[0]->start;\r\n#ifdef incomplete\r\nirq = link->irq;\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "bug! couldn't determine board type\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nprintk(KERN_ERR "comedi%d: ni_daq_700: %s, io 0x%lx", dev->minor,\r\nthisboard->name, iobase);\r\n#ifdef incomplete\r\nif (irq)\r\nprintk(", irq %u", irq);\r\n#endif\r\nprintk("\n");\r\nif (iobase == 0) {\r\nprintk(KERN_ERR "io base address is zero!\n");\r\nreturn -EINVAL;\r\n}\r\ndev->iobase = iobase;\r\n#ifdef incomplete\r\ndev->irq = irq;\r\n#endif\r\ndev->board_name = thisboard->name;\r\nif (alloc_subdevices(dev, 1) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\nsubdev_700_init(dev, s, NULL, dev->iobase);\r\nreturn 0;\r\n}\r\nstatic int dio700_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_ERR "comedi%d: ni_daq_700: cs-remove\n", dev->minor);\r\nif (dev->subdevices)\r\nsubdev_700_cleanup(dev, dev->subdevices + 0);\r\nif (thisboard->bustype != pcmcia_bustype && dev->iobase)\r\nrelease_region(dev->iobase, DIO700_SIZE);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic int dio700_cs_attach(struct pcmcia_device *link)\r\n{\r\nstruct local_info_t *local;\r\nprintk(KERN_INFO "ni_daq_700: cs-attach\n");\r\ndev_dbg(&link->dev, "dio700_cs_attach()\n");\r\nlocal = kzalloc(sizeof(struct local_info_t), GFP_KERNEL);\r\nif (!local)\r\nreturn -ENOMEM;\r\nlocal->link = link;\r\nlink->priv = local;\r\npcmcia_cur_dev = link;\r\ndio700_config(link);\r\nreturn 0;\r\n}\r\nstatic void dio700_cs_detach(struct pcmcia_device *link)\r\n{\r\nprintk(KERN_INFO "ni_daq_700: cs-detach!\n");\r\ndev_dbg(&link->dev, "dio700_cs_detach\n");\r\n((struct local_info_t *)link->priv)->stop = 1;\r\ndio700_release(link);\r\nkfree(link->priv);\r\n}\r\nstatic int dio700_pcmcia_config_loop(struct pcmcia_device *p_dev,\r\nvoid *priv_data)\r\n{\r\nif (p_dev->config_index == 0)\r\nreturn -EINVAL;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic void dio700_config(struct pcmcia_device *link)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "ni_daq_700: cs-config\n");\r\ndev_dbg(&link->dev, "dio700_config\n");\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_AUDIO |\r\nCONF_AUTO_SET_IO;\r\nret = pcmcia_loop_config(link, dio700_pcmcia_config_loop, NULL);\r\nif (ret) {\r\ndev_warn(&link->dev, "no configuration found\n");\r\ngoto failed;\r\n}\r\nif (!link->irq)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret != 0)\r\ngoto failed;\r\nreturn;\r\nfailed:\r\nprintk(KERN_INFO "ni_daq_700 cs failed");\r\ndio700_release(link);\r\n}\r\nstatic void dio700_release(struct pcmcia_device *link)\r\n{\r\ndev_dbg(&link->dev, "dio700_release\n");\r\npcmcia_disable_device(link);\r\n}\r\nstatic int dio700_cs_suspend(struct pcmcia_device *link)\r\n{\r\nstruct local_info_t *local = link->priv;\r\nlocal->stop = 1;\r\nreturn 0;\r\n}\r\nstatic int dio700_cs_resume(struct pcmcia_device *link)\r\n{\r\nstruct local_info_t *local = link->priv;\r\nlocal->stop = 0;\r\nreturn 0;\r\n}\r\nstatic int __init init_dio700_cs(void)\r\n{\r\npcmcia_register_driver(&dio700_cs_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit exit_dio700_cs(void)\r\n{\r\npr_debug("ni_daq_700: unloading\n");\r\npcmcia_unregister_driver(&dio700_cs_driver);\r\n}\r\nint __init init_module(void)\r\n{\r\nint ret;\r\nret = init_dio700_cs();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn comedi_driver_register(&driver_dio700);\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nexit_dio700_cs();\r\ncomedi_driver_unregister(&driver_dio700);\r\n}
