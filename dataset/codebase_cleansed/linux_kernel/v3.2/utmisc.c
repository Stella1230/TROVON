const char *acpi_ut_validate_exception(acpi_status status)\r\n{\r\nu32 sub_status;\r\nconst char *exception = NULL;\r\nACPI_FUNCTION_ENTRY();\r\nsub_status = (status & ~AE_CODE_MASK);\r\nswitch (status & AE_CODE_MASK) {\r\ncase AE_CODE_ENVIRONMENTAL:\r\nif (sub_status <= AE_CODE_ENV_MAX) {\r\nexception = acpi_gbl_exception_names_env[sub_status];\r\n}\r\nbreak;\r\ncase AE_CODE_PROGRAMMER:\r\nif (sub_status <= AE_CODE_PGM_MAX) {\r\nexception = acpi_gbl_exception_names_pgm[sub_status];\r\n}\r\nbreak;\r\ncase AE_CODE_ACPI_TABLES:\r\nif (sub_status <= AE_CODE_TBL_MAX) {\r\nexception = acpi_gbl_exception_names_tbl[sub_status];\r\n}\r\nbreak;\r\ncase AE_CODE_AML:\r\nif (sub_status <= AE_CODE_AML_MAX) {\r\nexception = acpi_gbl_exception_names_aml[sub_status];\r\n}\r\nbreak;\r\ncase AE_CODE_CONTROL:\r\nif (sub_status <= AE_CODE_CTRL_MAX) {\r\nexception = acpi_gbl_exception_names_ctrl[sub_status];\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (ACPI_CAST_PTR(const char, exception));\r\n}\r\nu8 acpi_ut_is_pci_root_bridge(char *id)\r\n{\r\nif (!(ACPI_STRCMP(id,\r\nPCI_ROOT_HID_STRING)) ||\r\n!(ACPI_STRCMP(id, PCI_EXPRESS_ROOT_HID_STRING))) {\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nu8 acpi_ut_is_aml_table(struct acpi_table_header *table)\r\n{\r\nif (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT) ||\r\nACPI_COMPARE_NAME(table->signature, ACPI_SIG_PSDT) ||\r\nACPI_COMPARE_NAME(table->signature, ACPI_SIG_SSDT)) {\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nacpi_status acpi_ut_allocate_owner_id(acpi_owner_id * owner_id)\r\n{\r\nu32 i;\r\nu32 j;\r\nu32 k;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ut_allocate_owner_id);\r\nif (*owner_id) {\r\nACPI_ERROR((AE_INFO, "Owner ID [0x%2.2X] already exists",\r\n*owner_id));\r\nreturn_ACPI_STATUS(AE_ALREADY_EXISTS);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nfor (i = 0, j = acpi_gbl_last_owner_id_index;\r\ni < (ACPI_NUM_OWNERID_MASKS + 1); i++, j++) {\r\nif (j >= ACPI_NUM_OWNERID_MASKS) {\r\nj = 0;\r\n}\r\nfor (k = acpi_gbl_next_owner_id_offset; k < 32; k++) {\r\nif (acpi_gbl_owner_id_mask[j] == ACPI_UINT32_MAX) {\r\nbreak;\r\n}\r\nif (!(acpi_gbl_owner_id_mask[j] & (1 << k))) {\r\nacpi_gbl_owner_id_mask[j] |= (1 << k);\r\nacpi_gbl_last_owner_id_index = (u8) j;\r\nacpi_gbl_next_owner_id_offset = (u8) (k + 1);\r\n*owner_id =\r\n(acpi_owner_id) ((k + 1) + ACPI_MUL_32(j));\r\nACPI_DEBUG_PRINT((ACPI_DB_VALUES,\r\n"Allocated OwnerId: %2.2X\n",\r\n(unsigned int)*owner_id));\r\ngoto exit;\r\n}\r\n}\r\nacpi_gbl_next_owner_id_offset = 0;\r\n}\r\nstatus = AE_OWNER_ID_LIMIT;\r\nACPI_ERROR((AE_INFO,\r\n"Could not allocate new OwnerId (255 max), AE_OWNER_ID_LIMIT"));\r\nexit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid acpi_ut_release_owner_id(acpi_owner_id * owner_id_ptr)\r\n{\r\nacpi_owner_id owner_id = *owner_id_ptr;\r\nacpi_status status;\r\nu32 index;\r\nu32 bit;\r\nACPI_FUNCTION_TRACE_U32(ut_release_owner_id, owner_id);\r\n*owner_id_ptr = 0;\r\nif (owner_id == 0) {\r\nACPI_ERROR((AE_INFO, "Invalid OwnerId: 0x%2.2X", owner_id));\r\nreturn_VOID;\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_CACHES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\nowner_id--;\r\nindex = ACPI_DIV_32(owner_id);\r\nbit = 1 << ACPI_MOD_32(owner_id);\r\nif (acpi_gbl_owner_id_mask[index] & bit) {\r\nacpi_gbl_owner_id_mask[index] ^= bit;\r\n} else {\r\nACPI_ERROR((AE_INFO,\r\n"Release of non-allocated OwnerId: 0x%2.2X",\r\nowner_id + 1));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_CACHES);\r\nreturn_VOID;\r\n}\r\nvoid acpi_ut_strupr(char *src_string)\r\n{\r\nchar *string;\r\nACPI_FUNCTION_ENTRY();\r\nif (!src_string) {\r\nreturn;\r\n}\r\nfor (string = src_string; *string; string++) {\r\n*string = (char)ACPI_TOUPPER(*string);\r\n}\r\nreturn;\r\n}\r\nvoid acpi_ut_print_string(char *string, u8 max_length)\r\n{\r\nu32 i;\r\nif (!string) {\r\nacpi_os_printf("<\"NULL STRING PTR\">");\r\nreturn;\r\n}\r\nacpi_os_printf("\"");\r\nfor (i = 0; string[i] && (i < max_length); i++) {\r\nswitch (string[i]) {\r\ncase 0x07:\r\nacpi_os_printf("\\a");\r\nbreak;\r\ncase 0x08:\r\nacpi_os_printf("\\b");\r\nbreak;\r\ncase 0x0C:\r\nacpi_os_printf("\\f");\r\nbreak;\r\ncase 0x0A:\r\nacpi_os_printf("\\n");\r\nbreak;\r\ncase 0x0D:\r\nacpi_os_printf("\\r");\r\nbreak;\r\ncase 0x09:\r\nacpi_os_printf("\\t");\r\nbreak;\r\ncase 0x0B:\r\nacpi_os_printf("\\v");\r\nbreak;\r\ncase '\'':\r\ncase '\"':\r\ncase '\\':\r\nacpi_os_printf("\\%c", (int)string[i]);\r\nbreak;\r\ndefault:\r\nif (ACPI_IS_PRINT(string[i])) {\r\nacpi_os_printf("%c", (int)string[i]);\r\n} else {\r\nacpi_os_printf("\\x%2.2X", (s32) string[i]);\r\n}\r\nbreak;\r\n}\r\n}\r\nacpi_os_printf("\"");\r\nif (i == max_length && string[i]) {\r\nacpi_os_printf("...");\r\n}\r\n}\r\nu32 acpi_ut_dword_byte_swap(u32 value)\r\n{\r\nunion {\r\nu32 value;\r\nu8 bytes[4];\r\n} out;\r\nunion {\r\nu32 value;\r\nu8 bytes[4];\r\n} in;\r\nACPI_FUNCTION_ENTRY();\r\nin.value = value;\r\nout.bytes[0] = in.bytes[3];\r\nout.bytes[1] = in.bytes[2];\r\nout.bytes[2] = in.bytes[1];\r\nout.bytes[3] = in.bytes[0];\r\nreturn (out.value);\r\n}\r\nvoid acpi_ut_set_integer_width(u8 revision)\r\n{\r\nif (revision < 2) {\r\nacpi_gbl_integer_bit_width = 32;\r\nacpi_gbl_integer_nybble_width = 8;\r\nacpi_gbl_integer_byte_width = 4;\r\n} else {\r\nacpi_gbl_integer_bit_width = 64;\r\nacpi_gbl_integer_nybble_width = 16;\r\nacpi_gbl_integer_byte_width = 8;\r\n}\r\n}\r\nvoid\r\nacpi_ut_display_init_pathname(u8 type,\r\nstruct acpi_namespace_node *obj_handle,\r\nchar *path)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer;\r\nACPI_FUNCTION_ENTRY();\r\nif (!(acpi_dbg_level & ACPI_LV_INIT_NAMES)) {\r\nreturn;\r\n}\r\nbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nstatus = acpi_ns_handle_to_pathname(obj_handle, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nreturn;\r\n}\r\nswitch (type) {\r\ncase ACPI_TYPE_METHOD:\r\nacpi_os_printf("Executing ");\r\nbreak;\r\ndefault:\r\nacpi_os_printf("Initializing ");\r\nbreak;\r\n}\r\nacpi_os_printf("%-12s %s",\r\nacpi_ut_get_type_name(type), (char *)buffer.pointer);\r\nif (path) {\r\nacpi_os_printf(".%s", path);\r\n}\r\nacpi_os_printf("\n");\r\nACPI_FREE(buffer.pointer);\r\n}\r\nu8 acpi_ut_valid_acpi_char(char character, u32 position)\r\n{\r\nif (!((character >= 'A' && character <= 'Z') ||\r\n(character >= '0' && character <= '9') || (character == '_'))) {\r\nif (character == '!' && position == 3) {\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nreturn (TRUE);\r\n}\r\nu8 acpi_ut_valid_acpi_name(u32 name)\r\n{\r\nu32 i;\r\nACPI_FUNCTION_ENTRY();\r\nfor (i = 0; i < ACPI_NAME_SIZE; i++) {\r\nif (!acpi_ut_valid_acpi_char\r\n((ACPI_CAST_PTR(char, &name))[i], i)) {\r\nreturn (FALSE);\r\n}\r\n}\r\nreturn (TRUE);\r\n}\r\nacpi_name acpi_ut_repair_name(char *name)\r\n{\r\nu32 i;\r\nchar new_name[ACPI_NAME_SIZE];\r\nfor (i = 0; i < ACPI_NAME_SIZE; i++) {\r\nnew_name[i] = name[i];\r\nif (!acpi_ut_valid_acpi_char(name[i], i)) {\r\nnew_name[i] = '*';\r\n}\r\n}\r\nreturn (*(u32 *) new_name);\r\n}\r\nacpi_status acpi_ut_strtoul64(char *string, u32 base, u64 * ret_integer)\r\n{\r\nu32 this_digit = 0;\r\nu64 return_value = 0;\r\nu64 quotient;\r\nu64 dividend;\r\nu32 to_integer_op = (base == ACPI_ANY_BASE);\r\nu32 mode32 = (acpi_gbl_integer_byte_width == 4);\r\nu8 valid_digits = 0;\r\nu8 sign_of0x = 0;\r\nu8 term = 0;\r\nACPI_FUNCTION_TRACE_STR(ut_stroul64, string);\r\nswitch (base) {\r\ncase ACPI_ANY_BASE:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!string) {\r\ngoto error_exit;\r\n}\r\nwhile ((*string) && (ACPI_IS_SPACE(*string) || *string == '\t')) {\r\nstring++;\r\n}\r\nif (to_integer_op) {\r\nif ((*string == '0') && (ACPI_TOLOWER(*(string + 1)) == 'x')) {\r\nsign_of0x = 1;\r\nbase = 16;\r\nstring += 2;\r\n} else {\r\nbase = 10;\r\n}\r\n}\r\nif (!(*string) || ACPI_IS_SPACE(*string) || *string == '\t') {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\ngoto all_done;\r\n}\r\n}\r\ndividend = (mode32) ? ACPI_UINT32_MAX : ACPI_UINT64_MAX;\r\nwhile (*string) {\r\nif (ACPI_IS_DIGIT(*string)) {\r\nthis_digit = ((u8) * string) - '0';\r\n} else if (base == 10) {\r\nterm = 1;\r\n} else {\r\nthis_digit = (u8) ACPI_TOUPPER(*string);\r\nif (ACPI_IS_XDIGIT((char)this_digit)) {\r\nthis_digit = this_digit - 'A' + 10;\r\n} else {\r\nterm = 1;\r\n}\r\n}\r\nif (term) {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n} else if ((valid_digits == 0) && (this_digit == 0)\r\n&& !sign_of0x) {\r\nstring++;\r\ncontinue;\r\n}\r\nvalid_digits++;\r\nif (sign_of0x && ((valid_digits > 16)\r\n|| ((valid_digits > 8) && mode32))) {\r\ngoto error_exit;\r\n}\r\n(void)acpi_ut_short_divide((dividend - (u64) this_digit),\r\nbase, &quotient, NULL);\r\nif (return_value > quotient) {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn_value *= base;\r\nreturn_value += this_digit;\r\nstring++;\r\n}\r\nall_done:\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(return_value)));\r\n*ret_integer = return_value;\r\nreturn_ACPI_STATUS(AE_OK);\r\nerror_exit:\r\nif (base == 10) {\r\nreturn_ACPI_STATUS(AE_BAD_DECIMAL_CONSTANT);\r\n} else {\r\nreturn_ACPI_STATUS(AE_BAD_HEX_CONSTANT);\r\n}\r\n}\r\nacpi_status\r\nacpi_ut_create_update_state_and_push(union acpi_operand_object *object,\r\nu16 action,\r\nunion acpi_generic_state **state_list)\r\n{\r\nunion acpi_generic_state *state;\r\nACPI_FUNCTION_ENTRY();\r\nif (!object) {\r\nreturn (AE_OK);\r\n}\r\nstate = acpi_ut_create_update_state(object, action);\r\nif (!state) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nacpi_ut_push_generic_state(state_list, state);\r\nreturn (AE_OK);\r\n}\r\nacpi_status\r\nacpi_ut_walk_package_tree(union acpi_operand_object * source_object,\r\nvoid *target_object,\r\nacpi_pkg_callback walk_callback, void *context)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_generic_state *state_list = NULL;\r\nunion acpi_generic_state *state;\r\nu32 this_index;\r\nunion acpi_operand_object *this_source_obj;\r\nACPI_FUNCTION_TRACE(ut_walk_package_tree);\r\nstate = acpi_ut_create_pkg_state(source_object, target_object, 0);\r\nif (!state) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nwhile (state) {\r\nthis_index = state->pkg.index;\r\nthis_source_obj = (union acpi_operand_object *)\r\nstate->pkg.source_object->package.elements[this_index];\r\nif ((!this_source_obj) ||\r\n(ACPI_GET_DESCRIPTOR_TYPE(this_source_obj) !=\r\nACPI_DESC_TYPE_OPERAND)\r\n|| (this_source_obj->common.type != ACPI_TYPE_PACKAGE)) {\r\nstatus =\r\nwalk_callback(ACPI_COPY_TYPE_SIMPLE,\r\nthis_source_obj, state, context);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstate->pkg.index++;\r\nwhile (state->pkg.index >=\r\nstate->pkg.source_object->package.count) {\r\nacpi_ut_delete_generic_state(state);\r\nstate = acpi_ut_pop_generic_state(&state_list);\r\nif (!state) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstate->pkg.index++;\r\n}\r\n} else {\r\nstatus =\r\nwalk_callback(ACPI_COPY_TYPE_PACKAGE,\r\nthis_source_obj, state, context);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ut_push_generic_state(&state_list, state);\r\nstate = acpi_ut_create_pkg_state(this_source_obj,\r\nstate->pkg.\r\nthis_target_obj, 0);\r\nif (!state) {\r\nwhile (state_list) {\r\nstate =\r\nacpi_ut_pop_generic_state\r\n(&state_list);\r\nacpi_ut_delete_generic_state(state);\r\n}\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_AML_INTERNAL);\r\n}
