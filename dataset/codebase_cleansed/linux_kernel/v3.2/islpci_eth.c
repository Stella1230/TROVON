void\r\nislpci_eth_cleanup_transmit(islpci_private *priv,\r\nisl38xx_control_block *control_block)\r\n{\r\nstruct sk_buff *skb;\r\nu32 index;\r\nwhile (priv->free_data_tx !=\r\nle32_to_cpu(control_block->\r\ndevice_curr_frag[ISL38XX_CB_TX_DATA_LQ])) {\r\nindex = priv->free_data_tx % ISL38XX_CB_TX_QSIZE;\r\nif (priv->pci_map_tx_address[index]) {\r\nskb = priv->data_low_tx[index];\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING,\r\n"cleanup skb %p skb->data %p skb->len %u truesize %u\n ",\r\nskb, skb->data, skb->len, skb->truesize);\r\n#endif\r\npci_unmap_single(priv->pdev,\r\npriv->pci_map_tx_address[index],\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\nskb = NULL;\r\n}\r\npriv->free_data_tx++;\r\n}\r\n}\r\nnetdev_tx_t\r\nislpci_eth_transmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nisl38xx_control_block *cb = priv->control_block;\r\nu32 index;\r\ndma_addr_t pci_map_address;\r\nint frame_size;\r\nisl38xx_fragment *fragment;\r\nint offset;\r\nstruct sk_buff *newskb;\r\nint newskb_offset;\r\nunsigned long flags;\r\nunsigned char wds_mac[6];\r\nu32 curr_frag;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS, "islpci_eth_transmit\n");\r\n#endif\r\nspin_lock_irqsave(&priv->slock, flags);\r\ncurr_frag = le32_to_cpu(cb->driver_curr_frag[ISL38XX_CB_TX_DATA_LQ]);\r\nif (unlikely(curr_frag - priv->free_data_tx >= ISL38XX_CB_TX_QSIZE)) {\r\nprintk(KERN_ERR "%s: transmit device queue full when awake\n",\r\nndev->name);\r\nnetif_stop_queue(ndev);\r\nisl38xx_w32_flush(priv->device_base, ISL38XX_DEV_INT_UPDATE,\r\nISL38XX_DEV_INT_REG);\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\ngoto drop_free;\r\n}\r\nif (likely(((long) skb->data & 0x03) | init_wds)) {\r\noffset = (4 - (long) skb->data) & 0x03;\r\noffset += init_wds ? 6 : 0;\r\nif (!skb_cloned(skb) && (skb_tailroom(skb) >= offset)) {\r\nunsigned char *src = skb->data;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "skb offset %i wds %i\n", offset,\r\ninit_wds);\r\n#endif\r\nskb_reserve(skb, (4 - (long) skb->data) & 0x03);\r\nif (init_wds) {\r\nskb_put(skb, 6);\r\n#ifdef ISLPCI_ETH_DEBUG\r\nprintk("islpci_eth_transmit:wds_mac\n");\r\n#endif\r\nmemmove(skb->data + 6, src, skb->len);\r\nskb_copy_to_linear_data(skb, wds_mac, 6);\r\n} else {\r\nmemmove(skb->data, src, skb->len);\r\n}\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "memmove %p %p %i\n", skb->data,\r\nsrc, skb->len);\r\n#endif\r\n} else {\r\nnewskb =\r\ndev_alloc_skb(init_wds ? skb->len + 6 : skb->len);\r\nif (unlikely(newskb == NULL)) {\r\nprintk(KERN_ERR "%s: Cannot allocate skb\n",\r\nndev->name);\r\ngoto drop_free;\r\n}\r\nnewskb_offset = (4 - (long) newskb->data) & 0x03;\r\nif (newskb_offset)\r\nskb_reserve(newskb, newskb_offset);\r\nskb_put(newskb, init_wds ? skb->len + 6 : skb->len);\r\nif (init_wds) {\r\nskb_copy_from_linear_data(skb,\r\nnewskb->data + 6,\r\nskb->len);\r\nskb_copy_to_linear_data(newskb, wds_mac, 6);\r\n#ifdef ISLPCI_ETH_DEBUG\r\nprintk("islpci_eth_transmit:wds_mac\n");\r\n#endif\r\n} else\r\nskb_copy_from_linear_data(skb, newskb->data,\r\nskb->len);\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "memcpy %p %p %i wds %i\n",\r\nnewskb->data, skb->data, skb->len, init_wds);\r\n#endif\r\nnewskb->dev = skb->dev;\r\ndev_kfree_skb_irq(skb);\r\nskb = newskb;\r\n}\r\n}\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_BUFFER_CONTENTS, "\ntx %p ", skb->data);\r\ndisplay_buffer((char *) skb->data, skb->len);\r\n#endif\r\npci_map_address = pci_map_single(priv->pdev,\r\n(void *) skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (unlikely(pci_map_address == 0)) {\r\nprintk(KERN_WARNING "%s: cannot map buffer to PCI\n",\r\nndev->name);\r\ngoto drop_free;\r\n}\r\nindex = curr_frag % ISL38XX_CB_TX_QSIZE;\r\nfragment = &cb->tx_data_low[index];\r\npriv->pci_map_tx_address[index] = pci_map_address;\r\npriv->data_low_tx[index] = skb;\r\nframe_size = skb->len;\r\nfragment->size = cpu_to_le16(frame_size);\r\nfragment->flags = cpu_to_le16(0);\r\nfragment->address = cpu_to_le32(pci_map_address);\r\ncurr_frag++;\r\nwmb();\r\ncb->driver_curr_frag[ISL38XX_CB_TX_DATA_LQ] = cpu_to_le32(curr_frag);\r\nif (curr_frag - priv->free_data_tx + ISL38XX_MIN_QTHRESHOLD\r\n> ISL38XX_CB_TX_QSIZE) {\r\nnetif_stop_queue(ndev);\r\npriv->data_low_tx_full = 1;\r\n}\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += skb->len;\r\nislpci_trigger(priv);\r\nspin_unlock_irqrestore(&priv->slock, flags);\r\nreturn NETDEV_TX_OK;\r\ndrop_free:\r\nndev->stats.tx_dropped++;\r\nspin_unlock_irqrestore(&priv->slock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline int\r\nislpci_monitor_rx(islpci_private *priv, struct sk_buff **skb)\r\n{\r\nstruct rfmon_header *hdr = (struct rfmon_header *) (*skb)->data;\r\nif (hdr->flags & 0x01)\r\nreturn -1;\r\nif (priv->ndev->type == ARPHRD_IEEE80211_PRISM) {\r\nstruct avs_80211_1_header *avs;\r\nu32 clock = le32_to_cpu(hdr->clock);\r\nu8 rate = hdr->rate;\r\nu16 freq = le16_to_cpu(hdr->freq);\r\nu8 rssi = hdr->rssi;\r\nskb_pull(*skb, sizeof (struct rfmon_header));\r\nif (skb_headroom(*skb) < sizeof (struct avs_80211_1_header)) {\r\nstruct sk_buff *newskb = skb_copy_expand(*skb,\r\nsizeof (struct\r\navs_80211_1_header),\r\n0, GFP_ATOMIC);\r\nif (newskb) {\r\ndev_kfree_skb_irq(*skb);\r\n*skb = newskb;\r\n} else\r\nreturn -1;\r\n}\r\navs =\r\n(struct avs_80211_1_header *) skb_push(*skb,\r\nsizeof (struct\r\navs_80211_1_header));\r\navs->version = cpu_to_be32(P80211CAPTURE_VERSION);\r\navs->length = cpu_to_be32(sizeof (struct avs_80211_1_header));\r\navs->mactime = cpu_to_be64(clock);\r\navs->hosttime = cpu_to_be64(jiffies);\r\navs->phytype = cpu_to_be32(6);\r\navs->channel = cpu_to_be32(channel_of_freq(freq));\r\navs->datarate = cpu_to_be32(rate * 5);\r\navs->antenna = cpu_to_be32(0);\r\navs->priority = cpu_to_be32(0);\r\navs->ssi_type = cpu_to_be32(3);\r\navs->ssi_signal = cpu_to_be32(rssi & 0x7f);\r\navs->ssi_noise = cpu_to_be32(priv->local_iwstatistics.qual.noise);\r\navs->preamble = cpu_to_be32(0);\r\navs->encoding = cpu_to_be32(0);\r\n} else\r\nskb_pull(*skb, sizeof (struct rfmon_header));\r\n(*skb)->protocol = htons(ETH_P_802_2);\r\nskb_reset_mac_header(*skb);\r\n(*skb)->pkt_type = PACKET_OTHERHOST;\r\nreturn 0;\r\n}\r\nint\r\nislpci_eth_receive(islpci_private *priv)\r\n{\r\nstruct net_device *ndev = priv->ndev;\r\nisl38xx_control_block *control_block = priv->control_block;\r\nstruct sk_buff *skb;\r\nu16 size;\r\nu32 index, offset;\r\nunsigned char *src;\r\nint discard = 0;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS, "islpci_eth_receive\n");\r\n#endif\r\nindex = priv->free_data_rx % ISL38XX_CB_RX_QSIZE;\r\nsize = le16_to_cpu(control_block->rx_data_low[index].size);\r\nskb = priv->data_low_rx[index];\r\noffset = ((unsigned long)\r\nle32_to_cpu(control_block->rx_data_low[index].address) -\r\n(unsigned long) skb->data) & 3;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING,\r\n"frq->addr %x skb->data %p skb->len %u offset %u truesize %u\n ",\r\ncontrol_block->rx_data_low[priv->free_data_rx].address, skb->data,\r\nskb->len, offset, skb->truesize);\r\n#endif\r\npci_unmap_single(priv->pdev,\r\npriv->pci_map_rx_address[index],\r\nMAX_FRAGMENT_SIZE_RX + 2, PCI_DMA_FROMDEVICE);\r\nskb_put(skb, size);\r\nif (offset) {\r\nskb_pull(skb, 2);\r\nskb_put(skb, 2);\r\n}\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_BUFFER_CONTENTS, "\nrx %p ", skb->data);\r\ndisplay_buffer((char *) skb->data, skb->len);\r\n#endif\r\nif (init_wds) {\r\nsrc = skb->data + 6;\r\nmemmove(skb->data, src, skb->len - 6);\r\nskb_trim(skb, skb->len - 6);\r\n}\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "Fragment size %i in skb at %p\n", size, skb);\r\nDEBUG(SHOW_TRACING, "Skb data at %p, length %i\n", skb->data, skb->len);\r\nDEBUG(SHOW_BUFFER_CONTENTS, "\nrx %p ", skb->data);\r\ndisplay_buffer((char *) skb->data, skb->len);\r\n#endif\r\nif (unlikely(priv->iw_mode == IW_MODE_MONITOR)) {\r\nskb->dev = ndev;\r\ndiscard = islpci_monitor_rx(priv, &skb);\r\n} else {\r\nif (unlikely(skb->data[2 * ETH_ALEN] == 0)) {\r\nstruct iw_quality wstats;\r\nstruct rx_annex_header *annex =\r\n(struct rx_annex_header *) skb->data;\r\nwstats.level = annex->rfmon.rssi;\r\nwstats.noise = priv->local_iwstatistics.qual.noise;\r\nwstats.qual = wstats.level - wstats.noise;\r\nwstats.updated = 0x07;\r\nwireless_spy_update(ndev, annex->addr2, &wstats);\r\nskb_copy_from_linear_data(skb,\r\n(skb->data +\r\nsizeof(struct rfmon_header)),\r\n2 * ETH_ALEN);\r\nskb_pull(skb, sizeof (struct rfmon_header));\r\n}\r\nskb->protocol = eth_type_trans(skb, ndev);\r\n}\r\nskb->ip_summed = CHECKSUM_NONE;\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += size;\r\n#ifdef ISLPCI_ETH_DEBUG\r\nprintk\r\n("islpci_eth_receive:netif_rx %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\nskb->data[0], skb->data[1], skb->data[2], skb->data[3],\r\nskb->data[4], skb->data[5]);\r\n#endif\r\nif (unlikely(discard)) {\r\ndev_kfree_skb_irq(skb);\r\nskb = NULL;\r\n} else\r\nnetif_rx(skb);\r\npriv->free_data_rx++;\r\nwhile (index =\r\nle32_to_cpu(control_block->\r\ndriver_curr_frag[ISL38XX_CB_RX_DATA_LQ]),\r\nindex - priv->free_data_rx < ISL38XX_CB_RX_QSIZE) {\r\nskb = dev_alloc_skb(MAX_FRAGMENT_SIZE_RX + 2);\r\nif (unlikely(skb == NULL)) {\r\nDEBUG(SHOW_ERROR_MESSAGES, "Error allocating skb\n");\r\nbreak;\r\n}\r\nskb_reserve(skb, (4 - (long) skb->data) & 0x03);\r\nindex = index % ISL38XX_CB_RX_QSIZE;\r\npriv->data_low_rx[index] = skb;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING,\r\n"new alloc skb %p skb->data %p skb->len %u index %u truesize %u\n ",\r\nskb, skb->data, skb->len, index, skb->truesize);\r\n#endif\r\npriv->pci_map_rx_address[index] =\r\npci_map_single(priv->pdev, (void *) skb->data,\r\nMAX_FRAGMENT_SIZE_RX + 2,\r\nPCI_DMA_FROMDEVICE);\r\nif (unlikely(!priv->pci_map_rx_address[index])) {\r\nDEBUG(SHOW_ERROR_MESSAGES,\r\n"Error mapping DMA address\n");\r\ndev_kfree_skb_irq((struct sk_buff *) skb);\r\nskb = NULL;\r\nbreak;\r\n}\r\ncontrol_block->rx_data_low[index].address =\r\ncpu_to_le32((u32)priv->pci_map_rx_address[index]);\r\nwmb();\r\nle32_add_cpu(&control_block->\r\ndriver_curr_frag[ISL38XX_CB_RX_DATA_LQ], 1);\r\n}\r\nislpci_trigger(priv);\r\nreturn 0;\r\n}\r\nvoid\r\nislpci_do_reset_and_wake(struct work_struct *work)\r\n{\r\nislpci_private *priv = container_of(work, islpci_private, reset_task);\r\nislpci_reset(priv, 1);\r\npriv->reset_task_pending = 0;\r\nsmp_wmb();\r\nnetif_wake_queue(priv->ndev);\r\n}\r\nvoid\r\nislpci_eth_tx_timeout(struct net_device *ndev)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nndev->stats.tx_errors++;\r\nif (!priv->reset_task_pending) {\r\nprintk(KERN_WARNING\r\n"%s: tx_timeout, scheduling reset", ndev->name);\r\nnetif_stop_queue(ndev);\r\npriv->reset_task_pending = 1;\r\nschedule_work(&priv->reset_task);\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s: tx_timeout, waiting for reset", ndev->name);\r\n}\r\n}
