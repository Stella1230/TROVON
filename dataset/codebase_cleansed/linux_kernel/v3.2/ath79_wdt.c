static inline void ath79_wdt_keepalive(void)\r\n{\r\nath79_reset_wr(AR71XX_RESET_REG_WDOG, wdt_freq * timeout);\r\n}\r\nstatic inline void ath79_wdt_enable(void)\r\n{\r\nath79_wdt_keepalive();\r\nath79_reset_wr(AR71XX_RESET_REG_WDOG_CTRL, WDOG_CTRL_ACTION_FCR);\r\n}\r\nstatic inline void ath79_wdt_disable(void)\r\n{\r\nath79_reset_wr(AR71XX_RESET_REG_WDOG_CTRL, WDOG_CTRL_ACTION_NONE);\r\n}\r\nstatic int ath79_wdt_set_timeout(int val)\r\n{\r\nif (val < 1 || val > max_timeout)\r\nreturn -EINVAL;\r\ntimeout = val;\r\nath79_wdt_keepalive();\r\nreturn 0;\r\n}\r\nstatic int ath79_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(WDT_FLAGS_BUSY, &wdt_flags))\r\nreturn -EBUSY;\r\nclear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);\r\nath79_wdt_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int ath79_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (test_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags))\r\nath79_wdt_disable();\r\nelse {\r\npr_crit(DRIVER_NAME ": device closed unexpectedly, "\r\n"watchdog timer will not stop!\n");\r\nath79_wdt_keepalive();\r\n}\r\nclear_bit(WDT_FLAGS_BUSY, &wdt_flags);\r\nclear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t ath79_wdt_write(struct file *file, const char *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nclear_bit(WDT_FLAGS_EXPECT_CLOSE, &wdt_flags);\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(WDT_FLAGS_EXPECT_CLOSE,\r\n&wdt_flags);\r\n}\r\n}\r\nath79_wdt_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic long ath79_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint err;\r\nint t;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nerr = copy_to_user(argp, &ath79_wdt_info,\r\nsizeof(ath79_wdt_info)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nerr = put_user(0, p);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nerr = put_user(boot_status, p);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nath79_wdt_keepalive();\r\nerr = 0;\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nerr = get_user(t, p);\r\nif (err)\r\nbreak;\r\nerr = ath79_wdt_set_timeout(t);\r\nif (err)\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\nerr = put_user(timeout, p);\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int __devinit ath79_wdt_probe(struct platform_device *pdev)\r\n{\r\nu32 ctrl;\r\nint err;\r\nwdt_clk = clk_get(&pdev->dev, "wdt");\r\nif (IS_ERR(wdt_clk))\r\nreturn PTR_ERR(wdt_clk);\r\nerr = clk_enable(wdt_clk);\r\nif (err)\r\ngoto err_clk_put;\r\nwdt_freq = clk_get_rate(wdt_clk);\r\nif (!wdt_freq) {\r\nerr = -EINVAL;\r\ngoto err_clk_disable;\r\n}\r\nmax_timeout = (0xfffffffful / wdt_freq);\r\nif (timeout < 1 || timeout > max_timeout) {\r\ntimeout = max_timeout;\r\ndev_info(&pdev->dev,\r\n"timeout value must be 0 < timeout < %d, using %d\n",\r\nmax_timeout, timeout);\r\n}\r\nctrl = ath79_reset_rr(AR71XX_RESET_REG_WDOG_CTRL);\r\nboot_status = (ctrl & WDOG_CTRL_LAST_RESET) ? WDIOF_CARDRESET : 0;\r\nerr = misc_register(&ath79_wdt_miscdev);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"unable to register misc device, err=%d\n", err);\r\ngoto err_clk_disable;\r\n}\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable(wdt_clk);\r\nerr_clk_put:\r\nclk_put(wdt_clk);\r\nreturn err;\r\n}\r\nstatic int __devexit ath79_wdt_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&ath79_wdt_miscdev);\r\nclk_disable(wdt_clk);\r\nclk_put(wdt_clk);\r\nreturn 0;\r\n}\r\nstatic void ath97_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nath79_wdt_disable();\r\n}\r\nstatic int __init ath79_wdt_init(void)\r\n{\r\nreturn platform_driver_probe(&ath79_wdt_driver, ath79_wdt_probe);\r\n}\r\nstatic void __exit ath79_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&ath79_wdt_driver);\r\n}
