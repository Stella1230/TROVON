static int rps_sock_flow_sysctl(ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nunsigned int orig_size, size;\r\nint ret, i;\r\nctl_table tmp = {\r\n.data = &size,\r\n.maxlen = sizeof(size),\r\n.mode = table->mode\r\n};\r\nstruct rps_sock_flow_table *orig_sock_table, *sock_table;\r\nstatic DEFINE_MUTEX(sock_flow_mutex);\r\nmutex_lock(&sock_flow_mutex);\r\norig_sock_table = rcu_dereference_protected(rps_sock_flow_table,\r\nlockdep_is_held(&sock_flow_mutex));\r\nsize = orig_size = orig_sock_table ? orig_sock_table->mask + 1 : 0;\r\nret = proc_dointvec(&tmp, write, buffer, lenp, ppos);\r\nif (write) {\r\nif (size) {\r\nif (size > 1<<30) {\r\nmutex_unlock(&sock_flow_mutex);\r\nreturn -EINVAL;\r\n}\r\nsize = roundup_pow_of_two(size);\r\nif (size != orig_size) {\r\nsock_table =\r\nvmalloc(RPS_SOCK_FLOW_TABLE_SIZE(size));\r\nif (!sock_table) {\r\nmutex_unlock(&sock_flow_mutex);\r\nreturn -ENOMEM;\r\n}\r\nsock_table->mask = size - 1;\r\n} else\r\nsock_table = orig_sock_table;\r\nfor (i = 0; i < size; i++)\r\nsock_table->ents[i] = RPS_NO_CPU;\r\n} else\r\nsock_table = NULL;\r\nif (sock_table != orig_sock_table) {\r\nrcu_assign_pointer(rps_sock_flow_table, sock_table);\r\nsynchronize_rcu();\r\nvfree(orig_sock_table);\r\n}\r\n}\r\nmutex_unlock(&sock_flow_mutex);\r\nreturn ret;\r\n}\r\nstatic __net_init int sysctl_core_net_init(struct net *net)\r\n{\r\nstruct ctl_table *tbl;\r\nnet->core.sysctl_somaxconn = SOMAXCONN;\r\ntbl = netns_core_table;\r\nif (!net_eq(net, &init_net)) {\r\ntbl = kmemdup(tbl, sizeof(netns_core_table), GFP_KERNEL);\r\nif (tbl == NULL)\r\ngoto err_dup;\r\ntbl[0].data = &net->core.sysctl_somaxconn;\r\n}\r\nnet->core.sysctl_hdr = register_net_sysctl_table(net,\r\nnet_core_path, tbl);\r\nif (net->core.sysctl_hdr == NULL)\r\ngoto err_reg;\r\nreturn 0;\r\nerr_reg:\r\nif (tbl != netns_core_table)\r\nkfree(tbl);\r\nerr_dup:\r\nreturn -ENOMEM;\r\n}\r\nstatic __net_exit void sysctl_core_net_exit(struct net *net)\r\n{\r\nstruct ctl_table *tbl;\r\ntbl = net->core.sysctl_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->core.sysctl_hdr);\r\nBUG_ON(tbl == netns_core_table);\r\nkfree(tbl);\r\n}\r\nstatic __init int sysctl_core_init(void)\r\n{\r\nstatic struct ctl_table empty[1];\r\nregister_sysctl_paths(net_core_path, empty);\r\nregister_net_sysctl_rotable(net_core_path, net_core_table);\r\nreturn register_pernet_subsys(&sysctl_core_ops);\r\n}
