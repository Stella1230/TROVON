static inline struct stmpe_gpio *to_stmpe_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct stmpe_gpio, chip);\r\n}\r\nstatic int stmpe_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = to_stmpe_gpio(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPMR_LSB] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nint ret;\r\nret = stmpe_reg_read(stmpe, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret & mask;\r\n}\r\nstatic void stmpe_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = to_stmpe_gpio(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nint which = val ? STMPE_IDX_GPSR_LSB : STMPE_IDX_GPCR_LSB;\r\nu8 reg = stmpe->regs[which] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nstmpe_reg_write(stmpe, reg, mask);\r\n}\r\nstatic int stmpe_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int val)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = to_stmpe_gpio(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nstmpe_gpio_set(chip, offset, val);\r\nreturn stmpe_set_bits(stmpe, reg, mask, mask);\r\n}\r\nstatic int stmpe_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = to_stmpe_gpio(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 reg = stmpe->regs[STMPE_IDX_GPDR_LSB] - (offset / 8);\r\nu8 mask = 1 << (offset % 8);\r\nreturn stmpe_set_bits(stmpe, reg, mask, 0);\r\n}\r\nstatic int stmpe_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = to_stmpe_gpio(chip);\r\nreturn stmpe_gpio->irq_base + offset;\r\n}\r\nstatic int stmpe_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = to_stmpe_gpio(chip);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nif (stmpe_gpio->norequest_mask & (1 << offset))\r\nreturn -EINVAL;\r\nreturn stmpe_set_altfunc(stmpe, 1 << offset, STMPE_BLOCK_GPIO);\r\n}\r\nstatic int stmpe_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = irq_data_get_irq_chip_data(d);\r\nint offset = d->irq - stmpe_gpio->irq_base;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nif (type == IRQ_TYPE_LEVEL_LOW || type == IRQ_TYPE_LEVEL_HIGH)\r\nreturn -EINVAL;\r\nif (type == IRQ_TYPE_EDGE_RISING)\r\nstmpe_gpio->regs[REG_RE][regoffset] |= mask;\r\nelse\r\nstmpe_gpio->regs[REG_RE][regoffset] &= ~mask;\r\nif (type == IRQ_TYPE_EDGE_FALLING)\r\nstmpe_gpio->regs[REG_FE][regoffset] |= mask;\r\nelse\r\nstmpe_gpio->regs[REG_FE][regoffset] &= ~mask;\r\nreturn 0;\r\n}\r\nstatic void stmpe_gpio_irq_lock(struct irq_data *d)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = irq_data_get_irq_chip_data(d);\r\nmutex_lock(&stmpe_gpio->irq_lock);\r\n}\r\nstatic void stmpe_gpio_irq_sync_unlock(struct irq_data *d)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = irq_data_get_irq_chip_data(d);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\r\nstatic const u8 regmap[] = {\r\n[REG_RE] = STMPE_IDX_GPRER_LSB,\r\n[REG_FE] = STMPE_IDX_GPFER_LSB,\r\n[REG_IE] = STMPE_IDX_IEGPIOR_LSB,\r\n};\r\nint i, j;\r\nfor (i = 0; i < CACHE_NR_REGS; i++) {\r\nfor (j = 0; j < num_banks; j++) {\r\nu8 old = stmpe_gpio->oldregs[i][j];\r\nu8 new = stmpe_gpio->regs[i][j];\r\nif (new == old)\r\ncontinue;\r\nstmpe_gpio->oldregs[i][j] = new;\r\nstmpe_reg_write(stmpe, stmpe->regs[regmap[i]] - j, new);\r\n}\r\n}\r\nmutex_unlock(&stmpe_gpio->irq_lock);\r\n}\r\nstatic void stmpe_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = irq_data_get_irq_chip_data(d);\r\nint offset = d->irq - stmpe_gpio->irq_base;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe_gpio->regs[REG_IE][regoffset] &= ~mask;\r\n}\r\nstatic void stmpe_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = irq_data_get_irq_chip_data(d);\r\nint offset = d->irq - stmpe_gpio->irq_base;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe_gpio->regs[REG_IE][regoffset] |= mask;\r\n}\r\nstatic irqreturn_t stmpe_gpio_irq(int irq, void *dev)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = dev;\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nu8 statmsbreg = stmpe->regs[STMPE_IDX_ISGPIOR_MSB];\r\nint num_banks = DIV_ROUND_UP(stmpe->num_gpios, 8);\r\nu8 status[num_banks];\r\nint ret;\r\nint i;\r\nret = stmpe_block_read(stmpe, statmsbreg, num_banks, status);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < num_banks; i++) {\r\nint bank = num_banks - i - 1;\r\nunsigned int enabled = stmpe_gpio->regs[REG_IE][bank];\r\nunsigned int stat = status[i];\r\nstat &= enabled;\r\nif (!stat)\r\ncontinue;\r\nwhile (stat) {\r\nint bit = __ffs(stat);\r\nint line = bank * 8 + bit;\r\nhandle_nested_irq(stmpe_gpio->irq_base + line);\r\nstat &= ~(1 << bit);\r\n}\r\nstmpe_reg_write(stmpe, statmsbreg + i, status[i]);\r\nstmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_GPEDR_MSB] + i,\r\nstatus[i]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit stmpe_gpio_irq_init(struct stmpe_gpio *stmpe_gpio)\r\n{\r\nint base = stmpe_gpio->irq_base;\r\nint irq;\r\nfor (irq = base; irq < base + stmpe_gpio->chip.ngpio; irq++) {\r\nirq_set_chip_data(irq, stmpe_gpio);\r\nirq_set_chip_and_handler(irq, &stmpe_gpio_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_nested_thread(irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void stmpe_gpio_irq_remove(struct stmpe_gpio *stmpe_gpio)\r\n{\r\nint base = stmpe_gpio->irq_base;\r\nint irq;\r\nfor (irq = base; irq < base + stmpe_gpio->chip.ngpio; irq++) {\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, 0);\r\n#endif\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nirq_set_chip_data(irq, NULL);\r\n}\r\n}\r\nstatic int __devinit stmpe_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct stmpe_gpio_platform_data *pdata;\r\nstruct stmpe_gpio *stmpe_gpio;\r\nint ret;\r\nint irq;\r\npdata = stmpe->pdata->gpio;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nstmpe_gpio = kzalloc(sizeof(struct stmpe_gpio), GFP_KERNEL);\r\nif (!stmpe_gpio)\r\nreturn -ENOMEM;\r\nmutex_init(&stmpe_gpio->irq_lock);\r\nstmpe_gpio->dev = &pdev->dev;\r\nstmpe_gpio->stmpe = stmpe;\r\nstmpe_gpio->norequest_mask = pdata ? pdata->norequest_mask : 0;\r\nstmpe_gpio->chip = template_chip;\r\nstmpe_gpio->chip.ngpio = stmpe->num_gpios;\r\nstmpe_gpio->chip.dev = &pdev->dev;\r\nstmpe_gpio->chip.base = pdata ? pdata->gpio_base : -1;\r\nstmpe_gpio->irq_base = stmpe->irq_base + STMPE_INT_GPIO(0);\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\r\nif (ret)\r\ngoto out_free;\r\nret = stmpe_gpio_irq_init(stmpe_gpio);\r\nif (ret)\r\ngoto out_disable;\r\nret = request_threaded_irq(irq, NULL, stmpe_gpio_irq, IRQF_ONESHOT,\r\n"stmpe-gpio", stmpe_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to get irq: %d\n", ret);\r\ngoto out_removeirq;\r\n}\r\nret = gpiochip_add(&stmpe_gpio->chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to add gpiochip: %d\n", ret);\r\ngoto out_freeirq;\r\n}\r\nif (pdata && pdata->setup)\r\npdata->setup(stmpe, stmpe_gpio->chip.base);\r\nplatform_set_drvdata(pdev, stmpe_gpio);\r\nreturn 0;\r\nout_freeirq:\r\nfree_irq(irq, stmpe_gpio);\r\nout_removeirq:\r\nstmpe_gpio_irq_remove(stmpe_gpio);\r\nout_disable:\r\nstmpe_disable(stmpe, STMPE_BLOCK_GPIO);\r\nout_free:\r\nkfree(stmpe_gpio);\r\nreturn ret;\r\n}\r\nstatic int __devexit stmpe_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct stmpe_gpio *stmpe_gpio = platform_get_drvdata(pdev);\r\nstruct stmpe *stmpe = stmpe_gpio->stmpe;\r\nstruct stmpe_gpio_platform_data *pdata = stmpe->pdata->gpio;\r\nint irq = platform_get_irq(pdev, 0);\r\nint ret;\r\nif (pdata && pdata->remove)\r\npdata->remove(stmpe, stmpe_gpio->chip.base);\r\nret = gpiochip_remove(&stmpe_gpio->chip);\r\nif (ret < 0) {\r\ndev_err(stmpe_gpio->dev,\r\n"unable to remove gpiochip: %d\n", ret);\r\nreturn ret;\r\n}\r\nstmpe_disable(stmpe, STMPE_BLOCK_GPIO);\r\nfree_irq(irq, stmpe_gpio);\r\nstmpe_gpio_irq_remove(stmpe_gpio);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(stmpe_gpio);\r\nreturn 0;\r\n}\r\nstatic int __init stmpe_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&stmpe_gpio_driver);\r\n}\r\nstatic void __exit stmpe_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&stmpe_gpio_driver);\r\n}
