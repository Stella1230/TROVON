void bat_socket_init(void)\r\n{\r\nmemset(socket_client_hash, 0, sizeof(socket_client_hash));\r\n}\r\nstatic int bat_socket_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int i;\r\nstruct socket_client *socket_client;\r\nnonseekable_open(inode, file);\r\nsocket_client = kmalloc(sizeof(*socket_client), GFP_KERNEL);\r\nif (!socket_client)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(socket_client_hash); i++) {\r\nif (!socket_client_hash[i]) {\r\nsocket_client_hash[i] = socket_client;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(socket_client_hash)) {\r\npr_err("Error - can't add another packet client: "\r\n"maximum number of clients reached\n");\r\nkfree(socket_client);\r\nreturn -EXFULL;\r\n}\r\nINIT_LIST_HEAD(&socket_client->queue_list);\r\nsocket_client->queue_len = 0;\r\nsocket_client->index = i;\r\nsocket_client->bat_priv = inode->i_private;\r\nspin_lock_init(&socket_client->lock);\r\ninit_waitqueue_head(&socket_client->queue_wait);\r\nfile->private_data = socket_client;\r\ninc_module_count();\r\nreturn 0;\r\n}\r\nstatic int bat_socket_release(struct inode *inode, struct file *file)\r\n{\r\nstruct socket_client *socket_client = file->private_data;\r\nstruct socket_packet *socket_packet;\r\nstruct list_head *list_pos, *list_pos_tmp;\r\nspin_lock_bh(&socket_client->lock);\r\nlist_for_each_safe(list_pos, list_pos_tmp, &socket_client->queue_list) {\r\nsocket_packet = list_entry(list_pos,\r\nstruct socket_packet, list);\r\nlist_del(list_pos);\r\nkfree(socket_packet);\r\n}\r\nsocket_client_hash[socket_client->index] = NULL;\r\nspin_unlock_bh(&socket_client->lock);\r\nkfree(socket_client);\r\ndec_module_count();\r\nreturn 0;\r\n}\r\nstatic ssize_t bat_socket_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct socket_client *socket_client = file->private_data;\r\nstruct socket_packet *socket_packet;\r\nsize_t packet_len;\r\nint error;\r\nif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\r\nreturn -EAGAIN;\r\nif ((!buf) || (count < sizeof(struct icmp_packet)))\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nerror = wait_event_interruptible(socket_client->queue_wait,\r\nsocket_client->queue_len);\r\nif (error)\r\nreturn error;\r\nspin_lock_bh(&socket_client->lock);\r\nsocket_packet = list_first_entry(&socket_client->queue_list,\r\nstruct socket_packet, list);\r\nlist_del(&socket_packet->list);\r\nsocket_client->queue_len--;\r\nspin_unlock_bh(&socket_client->lock);\r\nerror = __copy_to_user(buf, &socket_packet->icmp_packet,\r\nsocket_packet->icmp_len);\r\npacket_len = socket_packet->icmp_len;\r\nkfree(socket_packet);\r\nif (error)\r\nreturn -EFAULT;\r\nreturn packet_len;\r\n}\r\nstatic ssize_t bat_socket_write(struct file *file, const char __user *buff,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct socket_client *socket_client = file->private_data;\r\nstruct bat_priv *bat_priv = socket_client->bat_priv;\r\nstruct hard_iface *primary_if = NULL;\r\nstruct sk_buff *skb;\r\nstruct icmp_packet_rr *icmp_packet;\r\nstruct orig_node *orig_node = NULL;\r\nstruct neigh_node *neigh_node = NULL;\r\nsize_t packet_len = sizeof(struct icmp_packet);\r\nif (len < sizeof(struct icmp_packet)) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Error - can't send packet from char device: "\r\n"invalid packet size\n");\r\nreturn -EINVAL;\r\n}\r\nprimary_if = primary_if_get_selected(bat_priv);\r\nif (!primary_if) {\r\nlen = -EFAULT;\r\ngoto out;\r\n}\r\nif (len >= sizeof(struct icmp_packet_rr))\r\npacket_len = sizeof(struct icmp_packet_rr);\r\nskb = dev_alloc_skb(packet_len + sizeof(struct ethhdr));\r\nif (!skb) {\r\nlen = -ENOMEM;\r\ngoto out;\r\n}\r\nskb_reserve(skb, sizeof(struct ethhdr));\r\nicmp_packet = (struct icmp_packet_rr *)skb_put(skb, packet_len);\r\nif (!access_ok(VERIFY_READ, buff, packet_len)) {\r\nlen = -EFAULT;\r\ngoto free_skb;\r\n}\r\nif (__copy_from_user(icmp_packet, buff, packet_len)) {\r\nlen = -EFAULT;\r\ngoto free_skb;\r\n}\r\nif (icmp_packet->packet_type != BAT_ICMP) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Error - can't send packet from char device: "\r\n"got bogus packet type (expected: BAT_ICMP)\n");\r\nlen = -EINVAL;\r\ngoto free_skb;\r\n}\r\nif (icmp_packet->msg_type != ECHO_REQUEST) {\r\nbat_dbg(DBG_BATMAN, bat_priv,\r\n"Error - can't send packet from char device: "\r\n"got bogus message type (expected: ECHO_REQUEST)\n");\r\nlen = -EINVAL;\r\ngoto free_skb;\r\n}\r\nicmp_packet->uid = socket_client->index;\r\nif (icmp_packet->version != COMPAT_VERSION) {\r\nicmp_packet->msg_type = PARAMETER_PROBLEM;\r\nicmp_packet->ttl = COMPAT_VERSION;\r\nbat_socket_add_packet(socket_client, icmp_packet, packet_len);\r\ngoto free_skb;\r\n}\r\nif (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)\r\ngoto dst_unreach;\r\norig_node = orig_hash_find(bat_priv, icmp_packet->dst);\r\nif (!orig_node)\r\ngoto dst_unreach;\r\nneigh_node = orig_node_get_router(orig_node);\r\nif (!neigh_node)\r\ngoto dst_unreach;\r\nif (!neigh_node->if_incoming)\r\ngoto dst_unreach;\r\nif (neigh_node->if_incoming->if_status != IF_ACTIVE)\r\ngoto dst_unreach;\r\nmemcpy(icmp_packet->orig,\r\nprimary_if->net_dev->dev_addr, ETH_ALEN);\r\nif (packet_len == sizeof(struct icmp_packet_rr))\r\nmemcpy(icmp_packet->rr,\r\nneigh_node->if_incoming->net_dev->dev_addr, ETH_ALEN);\r\nsend_skb_packet(skb, neigh_node->if_incoming, neigh_node->addr);\r\ngoto out;\r\ndst_unreach:\r\nicmp_packet->msg_type = DESTINATION_UNREACHABLE;\r\nbat_socket_add_packet(socket_client, icmp_packet, packet_len);\r\nfree_skb:\r\nkfree_skb(skb);\r\nout:\r\nif (primary_if)\r\nhardif_free_ref(primary_if);\r\nif (neigh_node)\r\nneigh_node_free_ref(neigh_node);\r\nif (orig_node)\r\norig_node_free_ref(orig_node);\r\nreturn len;\r\n}\r\nstatic unsigned int bat_socket_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct socket_client *socket_client = file->private_data;\r\npoll_wait(file, &socket_client->queue_wait, wait);\r\nif (socket_client->queue_len > 0)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nint bat_socket_setup(struct bat_priv *bat_priv)\r\n{\r\nstruct dentry *d;\r\nif (!bat_priv->debug_dir)\r\ngoto err;\r\nd = debugfs_create_file(ICMP_SOCKET, S_IFREG | S_IWUSR | S_IRUSR,\r\nbat_priv->debug_dir, bat_priv, &fops);\r\nif (d)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nreturn 1;\r\n}\r\nstatic void bat_socket_add_packet(struct socket_client *socket_client,\r\nstruct icmp_packet_rr *icmp_packet,\r\nsize_t icmp_len)\r\n{\r\nstruct socket_packet *socket_packet;\r\nsocket_packet = kmalloc(sizeof(*socket_packet), GFP_ATOMIC);\r\nif (!socket_packet)\r\nreturn;\r\nINIT_LIST_HEAD(&socket_packet->list);\r\nmemcpy(&socket_packet->icmp_packet, icmp_packet, icmp_len);\r\nsocket_packet->icmp_len = icmp_len;\r\nspin_lock_bh(&socket_client->lock);\r\nif (!socket_client_hash[icmp_packet->uid]) {\r\nspin_unlock_bh(&socket_client->lock);\r\nkfree(socket_packet);\r\nreturn;\r\n}\r\nlist_add_tail(&socket_packet->list, &socket_client->queue_list);\r\nsocket_client->queue_len++;\r\nif (socket_client->queue_len > 100) {\r\nsocket_packet = list_first_entry(&socket_client->queue_list,\r\nstruct socket_packet, list);\r\nlist_del(&socket_packet->list);\r\nkfree(socket_packet);\r\nsocket_client->queue_len--;\r\n}\r\nspin_unlock_bh(&socket_client->lock);\r\nwake_up(&socket_client->queue_wait);\r\n}\r\nvoid bat_socket_receive_packet(struct icmp_packet_rr *icmp_packet,\r\nsize_t icmp_len)\r\n{\r\nstruct socket_client *hash = socket_client_hash[icmp_packet->uid];\r\nif (hash)\r\nbat_socket_add_packet(hash, icmp_packet, icmp_len);\r\n}
