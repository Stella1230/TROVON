static int pri_is_rev_2_card(int card_ordinal)\r\n{\r\nswitch (card_ordinal) {\r\ncase CARDTYPE_DIVASRV_P_30M_V2_PCI:\r\ncase CARDTYPE_DIVASRV_VOICE_P_30M_V2_PCI:\r\nreturn (1);\r\n}\r\nreturn (0);\r\n}\r\nstatic void diva_pri_set_addresses(diva_os_xdi_adapter_t * a)\r\n{\r\na->resources.pci.mem_type_id[MEM_TYPE_ADDRESS] = 0;\r\na->resources.pci.mem_type_id[MEM_TYPE_CONTROL] = 2;\r\na->resources.pci.mem_type_id[MEM_TYPE_CONFIG] = 4;\r\na->resources.pci.mem_type_id[MEM_TYPE_RAM] = 0;\r\na->resources.pci.mem_type_id[MEM_TYPE_RESET] = 2;\r\na->resources.pci.mem_type_id[MEM_TYPE_CFG] = 4;\r\na->resources.pci.mem_type_id[MEM_TYPE_PROM] = 3;\r\na->xdi_adapter.Address = a->resources.pci.addr[0];\r\na->xdi_adapter.Control = a->resources.pci.addr[2];\r\na->xdi_adapter.Config = a->resources.pci.addr[4];\r\na->xdi_adapter.ram = a->resources.pci.addr[0];\r\na->xdi_adapter.ram += MP_SHARED_RAM_OFFSET;\r\na->xdi_adapter.reset = a->resources.pci.addr[2];\r\na->xdi_adapter.reset += MP_RESET;\r\na->xdi_adapter.cfg = a->resources.pci.addr[4];\r\na->xdi_adapter.cfg += MP_IRQ_RESET;\r\na->xdi_adapter.sdram_bar = a->resources.pci.bar[0];\r\na->xdi_adapter.prom = a->resources.pci.addr[3];\r\n}\r\nint diva_pri_init_card(diva_os_xdi_adapter_t * a)\r\n{\r\nint bar = 0;\r\nint pri_rev_2;\r\nunsigned long bar_length[5] = {\r\nMP_MEMORY_SIZE,\r\n0x1000,\r\n0x2000,\r\n0x8000,\r\n0x1000\r\n};\r\npri_rev_2 = pri_is_rev_2_card(a->CardOrdinal);\r\nif (pri_rev_2) {\r\nbar_length[0] = MP2_MEMORY_SIZE;\r\n}\r\na->xdi_adapter.Properties = CardProperties[a->CardOrdinal];\r\nDBG_LOG(("Load %s", a->xdi_adapter.Properties.Name))\r\nfor (bar = 0; bar < 5; bar++) {\r\na->resources.pci.bar[bar] =\r\ndivasa_get_pci_bar(a->resources.pci.bus,\r\na->resources.pci.func, bar,\r\na->resources.pci.hdev);\r\nif (!a->resources.pci.bar[bar]\r\n|| (a->resources.pci.bar[bar] == 0xFFFFFFF0)) {\r\nDBG_ERR(("A: invalid bar[%d]=%08x", bar,\r\na->resources.pci.bar[bar]))\r\nreturn (-1);\r\n}\r\n}\r\na->resources.pci.irq =\r\n(byte) divasa_get_pci_irq(a->resources.pci.bus,\r\na->resources.pci.func,\r\na->resources.pci.hdev);\r\nif (!a->resources.pci.irq) {\r\nDBG_ERR(("A: invalid irq"));\r\nreturn (-1);\r\n}\r\nfor (bar = 0; bar < 5; bar++) {\r\na->resources.pci.addr[bar] =\r\ndivasa_remap_pci_bar(a, bar, a->resources.pci.bar[bar],\r\nbar_length[bar]);\r\nif (!a->resources.pci.addr[bar]) {\r\nDBG_ERR(("A: A(%d), can't map bar[%d]",\r\na->controller, bar))\r\ndiva_pri_cleanup_adapter(a);\r\nreturn (-1);\r\n}\r\n}\r\ndiva_pri_set_addresses(a);\r\nif (pri_get_serial_number(a)) {\r\ndword serNo;\r\nserNo = a->resources.pci.bar[1] & 0xffff0000;\r\nserNo |= ((dword) a->resources.pci.bus) << 8;\r\nserNo += (a->resources.pci.func + a->controller + 1);\r\na->xdi_adapter.serialNo = serNo & ~0xFF000000;\r\nDBG_ERR(("A: A(%d) can't get Serial Number, generated serNo=%ld",\r\na->controller, a->xdi_adapter.serialNo))\r\n}\r\nif (diva_os_initialize_spin_lock(&a->xdi_adapter.isr_spin_lock, "isr")) {\r\ndiva_pri_cleanup_adapter(a);\r\nreturn (-1);\r\n}\r\nif (diva_os_initialize_spin_lock\r\n(&a->xdi_adapter.data_spin_lock, "data")) {\r\ndiva_pri_cleanup_adapter(a);\r\nreturn (-1);\r\n}\r\nstrcpy(a->xdi_adapter.req_soft_isr.dpc_thread_name, "kdivasprid");\r\nif (diva_os_initialize_soft_isr(&a->xdi_adapter.req_soft_isr,\r\nDIDpcRoutine, &a->xdi_adapter)) {\r\ndiva_pri_cleanup_adapter(a);\r\nreturn (-1);\r\n}\r\na->xdi_adapter.isr_soft_isr.object =\r\na->xdi_adapter.req_soft_isr.object;\r\na->xdi_adapter.Channels = CardProperties[a->CardOrdinal].Channels;\r\na->xdi_adapter.e_max = CardProperties[a->CardOrdinal].E_info;\r\na->xdi_adapter.e_tbl =\r\ndiva_os_malloc(0, a->xdi_adapter.e_max * sizeof(E_INFO));\r\nif (!a->xdi_adapter.e_tbl) {\r\ndiva_pri_cleanup_adapter(a);\r\nreturn (-1);\r\n}\r\nmemset(a->xdi_adapter.e_tbl, 0x00, a->xdi_adapter.e_max * sizeof(E_INFO));\r\na->xdi_adapter.a.io = &a->xdi_adapter;\r\na->xdi_adapter.DIRequest = request;\r\na->interface.cleanup_adapter_proc = diva_pri_cleanup_adapter;\r\na->interface.cmd_proc = diva_pri_cmd_card_proc;\r\nif (pri_rev_2) {\r\nprepare_pri2_functions(&a->xdi_adapter);\r\n} else {\r\nprepare_pri_functions(&a->xdi_adapter);\r\n}\r\na->dsp_mask = diva_pri_detect_dsps(a);\r\nif (pri_rev_2) {\r\ndiva_init_dma_map(a->resources.pci.hdev,\r\n(struct _diva_dma_map_entry **) &a->xdi_adapter.dma_map, 32);\r\n}\r\na->xdi_adapter.irq_info.irq_nr = a->resources.pci.irq;\r\nsprintf(a->xdi_adapter.irq_info.irq_name,\r\n"DIVA PRI %ld", (long) a->xdi_adapter.serialNo);\r\nif (diva_os_register_irq(a, a->xdi_adapter.irq_info.irq_nr,\r\na->xdi_adapter.irq_info.irq_name)) {\r\ndiva_pri_cleanup_adapter(a);\r\nreturn (-1);\r\n}\r\na->xdi_adapter.irq_info.registered = 1;\r\ndiva_log_info("%s IRQ:%d SerNo:%d", a->xdi_adapter.Properties.Name,\r\na->resources.pci.irq, a->xdi_adapter.serialNo);\r\nreturn (0);\r\n}\r\nstatic int diva_pri_cleanup_adapter(diva_os_xdi_adapter_t * a)\r\n{\r\nint bar = 0;\r\nif (a->xdi_adapter.Initialized) {\r\ndiva_pri_stop_adapter(a);\r\n}\r\nif (a->xdi_adapter.irq_info.registered) {\r\ndiva_os_remove_irq(a, a->xdi_adapter.irq_info.irq_nr);\r\n}\r\na->xdi_adapter.irq_info.registered = 0;\r\nfor (bar = 0; bar < 5; bar++) {\r\nif (a->resources.pci.bar[bar]\r\n&& a->resources.pci.addr[bar]) {\r\ndivasa_unmap_pci_bar(a->resources.pci.addr[bar]);\r\na->resources.pci.bar[bar] = 0;\r\na->resources.pci.addr[bar] = NULL;\r\n}\r\n}\r\ndiva_os_cancel_soft_isr(&a->xdi_adapter.isr_soft_isr);\r\ndiva_os_cancel_soft_isr(&a->xdi_adapter.req_soft_isr);\r\ndiva_os_remove_soft_isr(&a->xdi_adapter.req_soft_isr);\r\na->xdi_adapter.isr_soft_isr.object = NULL;\r\ndiva_os_destroy_spin_lock(&a->xdi_adapter.isr_spin_lock, "rm");\r\ndiva_os_destroy_spin_lock(&a->xdi_adapter.data_spin_lock, "rm");\r\nif (a->xdi_adapter.e_tbl) {\r\ndiva_os_free(0, a->xdi_adapter.e_tbl);\r\na->xdi_adapter.e_tbl = NULL;\r\n}\r\na->xdi_adapter.Channels = 0;\r\na->xdi_adapter.e_max = 0;\r\ndiva_free_dma_map(a->resources.pci.hdev,\r\n(struct _diva_dma_map_entry *) a->xdi_adapter.\r\ndma_map);\r\na->xdi_adapter.dma_map = NULL;\r\nreturn (0);\r\n}\r\nstatic int diva_pri_reset_adapter(PISDN_ADAPTER IoAdapter)\r\n{\r\ndword i;\r\nstruct mp_load __iomem *boot;\r\nif (!IoAdapter->Address || !IoAdapter->reset) {\r\nreturn (-1);\r\n}\r\nif (IoAdapter->Initialized) {\r\nDBG_ERR(("A: A(%d) can't reset PRI adapter - please stop first",\r\nIoAdapter->ANum))\r\nreturn (-1);\r\n}\r\nboot = (struct mp_load __iomem *) DIVA_OS_MEM_ATTACH_ADDRESS(IoAdapter);\r\nWRITE_DWORD(&boot->err, 0);\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nIoAdapter->rstFnc(IoAdapter);\r\ndiva_os_wait(10);\r\nboot = (struct mp_load __iomem *) DIVA_OS_MEM_ATTACH_ADDRESS(IoAdapter);\r\ni = READ_DWORD(&boot->live);\r\ndiva_os_wait(10);\r\nif (i == READ_DWORD(&boot->live)) {\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nDBG_ERR(("A: A(%d) CPU on PRI %ld is not alive!",\r\nIoAdapter->ANum, IoAdapter->serialNo))\r\nreturn (-1);\r\n}\r\nif (READ_DWORD(&boot->err)) {\r\nDBG_ERR(("A: A(%d) PRI %ld Board Selftest failed, error=%08lx",\r\nIoAdapter->ANum, IoAdapter->serialNo,\r\nREAD_DWORD(&boot->err)))\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nreturn (-1);\r\n}\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nIoAdapter->e_count = 0;\r\nif (IoAdapter->e_tbl) {\r\nmemset(IoAdapter->e_tbl, 0x00,\r\nIoAdapter->e_max * sizeof(E_INFO));\r\n}\r\nIoAdapter->head = 0;\r\nIoAdapter->tail = 0;\r\nIoAdapter->assign = 0;\r\nIoAdapter->trapped = 0;\r\nmemset(&IoAdapter->a.IdTable[0], 0x00,\r\nsizeof(IoAdapter->a.IdTable));\r\nmemset(&IoAdapter->a.IdTypeTable[0], 0x00,\r\nsizeof(IoAdapter->a.IdTypeTable));\r\nmemset(&IoAdapter->a.FlowControlIdTable[0], 0x00,\r\nsizeof(IoAdapter->a.FlowControlIdTable));\r\nmemset(&IoAdapter->a.FlowControlSkipTable[0], 0x00,\r\nsizeof(IoAdapter->a.FlowControlSkipTable));\r\nmemset(&IoAdapter->a.misc_flags_table[0], 0x00,\r\nsizeof(IoAdapter->a.misc_flags_table));\r\nmemset(&IoAdapter->a.rx_stream[0], 0x00,\r\nsizeof(IoAdapter->a.rx_stream));\r\nmemset(&IoAdapter->a.tx_stream[0], 0x00,\r\nsizeof(IoAdapter->a.tx_stream));\r\nmemset(&IoAdapter->a.tx_pos[0], 0x00, sizeof(IoAdapter->a.tx_pos));\r\nmemset(&IoAdapter->a.rx_pos[0], 0x00, sizeof(IoAdapter->a.rx_pos));\r\nreturn (0);\r\n}\r\nstatic int\r\ndiva_pri_write_sdram_block(PISDN_ADAPTER IoAdapter,\r\ndword address,\r\nconst byte * data, dword length, dword limit)\r\n{\r\nbyte __iomem *p = DIVA_OS_MEM_ATTACH_ADDRESS(IoAdapter);\r\nbyte __iomem *mem = p;\r\nif (((address + length) >= limit) || !mem) {\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, p);\r\nDBG_ERR(("A: A(%d) write PRI address=0x%08lx",\r\nIoAdapter->ANum, address + length))\r\nreturn (-1);\r\n}\r\nmem += address;\r\nwhile (length--) {\r\nWRITE_BYTE(mem++, *data++);\r\n}\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, p);\r\nreturn (0);\r\n}\r\nstatic int\r\ndiva_pri_start_adapter(PISDN_ADAPTER IoAdapter,\r\ndword start_address, dword features)\r\n{\r\ndword i;\r\nint started = 0;\r\nbyte __iomem *p;\r\nstruct mp_load __iomem *boot = (struct mp_load __iomem *) DIVA_OS_MEM_ATTACH_ADDRESS(IoAdapter);\r\nADAPTER *a = &IoAdapter->a;\r\nif (IoAdapter->Initialized) {\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nDBG_ERR(("A: A(%d) pri_start_adapter, adapter already running",\r\nIoAdapter->ANum))\r\nreturn (-1);\r\n}\r\nif (!boot) {\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nDBG_ERR(("A: PRI %ld can't start, adapter not mapped",\r\nIoAdapter->serialNo))\r\nreturn (-1);\r\n}\r\nsprintf(IoAdapter->Name, "A(%d)", (int) IoAdapter->ANum);\r\nDBG_LOG(("A(%d) start PRI at 0x%08lx", IoAdapter->ANum,\r\nstart_address))\r\nWRITE_DWORD(&boot->addr, start_address);\r\nWRITE_DWORD(&boot->cmd, 3);\r\nfor (i = 0; i < 300; ++i) {\r\ndiva_os_wait(10);\r\nif ((READ_DWORD(&boot->signature) >> 16) == 0x4447) {\r\nDBG_LOG(("A(%d) Protocol startup time %d.%02d seconds",\r\nIoAdapter->ANum, (i / 100), (i % 100)))\r\nstarted = 1;\r\nbreak;\r\n}\r\n}\r\nif (!started) {\r\nbyte __iomem *p = (byte __iomem *)boot;\r\ndword TrapId;\r\ndword debug;\r\nTrapId = READ_DWORD(&p[0x80]);\r\ndebug = READ_DWORD(&p[0x1c]);\r\nDBG_ERR(("A(%d) Adapter start failed 0x%08lx, TrapId=%08lx, debug=%08lx",\r\nIoAdapter->ANum, READ_DWORD(&boot->signature),\r\nTrapId, debug))\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nif (IoAdapter->trapFnc) {\r\n(*(IoAdapter->trapFnc)) (IoAdapter);\r\n}\r\nIoAdapter->stop(IoAdapter);\r\nreturn (-1);\r\n}\r\nDIVA_OS_MEM_DETACH_ADDRESS(IoAdapter, boot);\r\nIoAdapter->Initialized = true;\r\nIoAdapter->IrqCount = 0;\r\np = DIVA_OS_MEM_ATTACH_CFG(IoAdapter);\r\nWRITE_DWORD(p, (dword) ~ 0x03E00000);\r\nDIVA_OS_MEM_DETACH_CFG(IoAdapter, p);\r\na->ReadyInt = 1;\r\na->ram_out(a, &PR_RAM->ReadyInt, 1);\r\nfor (i = 100; !IoAdapter->IrqCount && (i-- > 0); diva_os_wait(10));\r\nif (!IoAdapter->IrqCount) {\r\nDBG_ERR(("A: A(%d) interrupt test failed",\r\nIoAdapter->ANum))\r\nIoAdapter->Initialized = false;\r\nIoAdapter->stop(IoAdapter);\r\nreturn (-1);\r\n}\r\nIoAdapter->Properties.Features = (word) features;\r\ndiva_xdi_display_adapter_features(IoAdapter->ANum);\r\nDBG_LOG(("A(%d) PRI adapter successfully started", IoAdapter->ANum))\r\ndiva_xdi_didd_register_adapter(IoAdapter->ANum);\r\nreturn (0);\r\n}\r\nstatic void diva_pri_clear_interrupts(diva_os_xdi_adapter_t * a)\r\n{\r\nPISDN_ADAPTER IoAdapter = &a->xdi_adapter;\r\nIoAdapter->disIrq(IoAdapter);\r\nIoAdapter->tst_irq(&IoAdapter->a);\r\nIoAdapter->clr_irq(&IoAdapter->a);\r\nIoAdapter->tst_irq(&IoAdapter->a);\r\ndiva_os_cancel_soft_isr(&IoAdapter->req_soft_isr);\r\ndiva_os_cancel_soft_isr(&IoAdapter->isr_soft_isr);\r\n}\r\nstatic int diva_pri_stop_adapter(diva_os_xdi_adapter_t * a)\r\n{\r\nPISDN_ADAPTER IoAdapter = &a->xdi_adapter;\r\nint i = 100;\r\nif (!IoAdapter->ram) {\r\nreturn (-1);\r\n}\r\nif (!IoAdapter->Initialized) {\r\nDBG_ERR(("A: A(%d) can't stop PRI adapter - not running",\r\nIoAdapter->ANum))\r\nreturn (-1);\r\n}\r\nIoAdapter->Initialized = 0;\r\ndiva_xdi_didd_remove_adapter(IoAdapter->ANum);\r\na->clear_interrupts_proc = diva_pri_clear_interrupts;\r\nIoAdapter->a.ReadyInt = 1;\r\nIoAdapter->a.ram_inc(&IoAdapter->a, &PR_RAM->ReadyInt);\r\ndo {\r\ndiva_os_sleep(10);\r\n} while (i-- && a->clear_interrupts_proc);\r\nif (a->clear_interrupts_proc) {\r\ndiva_pri_clear_interrupts(a);\r\na->clear_interrupts_proc = NULL;\r\nDBG_ERR(("A: A(%d) no final interrupt from PRI adapter",\r\nIoAdapter->ANum))\r\n}\r\nIoAdapter->a.ReadyInt = 0;\r\nIoAdapter->stop(IoAdapter);\r\nreturn (0);\r\n}\r\nstatic int\r\ndiva_pri_cmd_card_proc(struct _diva_os_xdi_adapter *a,\r\ndiva_xdi_um_cfg_cmd_t * cmd, int length)\r\n{\r\nint ret = -1;\r\nif (cmd->adapter != a->controller) {\r\nDBG_ERR(("A: pri_cmd, invalid controller=%d != %d",\r\ncmd->adapter, a->controller))\r\nreturn (-1);\r\n}\r\nswitch (cmd->command) {\r\ncase DIVA_XDI_UM_CMD_GET_CARD_ORDINAL:\r\na->xdi_mbox.data_length = sizeof(dword);\r\na->xdi_mbox.data =\r\ndiva_os_malloc(0, a->xdi_mbox.data_length);\r\nif (a->xdi_mbox.data) {\r\n*(dword *) a->xdi_mbox.data =\r\n(dword) a->CardOrdinal;\r\na->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\r\nret = 0;\r\n}\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_GET_SERIAL_NR:\r\na->xdi_mbox.data_length = sizeof(dword);\r\na->xdi_mbox.data =\r\ndiva_os_malloc(0, a->xdi_mbox.data_length);\r\nif (a->xdi_mbox.data) {\r\n*(dword *) a->xdi_mbox.data =\r\n(dword) a->xdi_adapter.serialNo;\r\na->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\r\nret = 0;\r\n}\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_GET_PCI_HW_CONFIG:\r\na->xdi_mbox.data_length = sizeof(dword) * 9;\r\na->xdi_mbox.data =\r\ndiva_os_malloc(0, a->xdi_mbox.data_length);\r\nif (a->xdi_mbox.data) {\r\nint i;\r\ndword *data = (dword *) a->xdi_mbox.data;\r\nfor (i = 0; i < 8; i++) {\r\n*data++ = a->resources.pci.bar[i];\r\n}\r\n*data++ = (dword) a->resources.pci.irq;\r\na->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\r\nret = 0;\r\n}\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_RESET_ADAPTER:\r\nret = diva_pri_reset_adapter(&a->xdi_adapter);\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_WRITE_SDRAM_BLOCK:\r\nret = diva_pri_write_sdram_block(&a->xdi_adapter,\r\ncmd->command_data.\r\nwrite_sdram.offset,\r\n(byte *) & cmd[1],\r\ncmd->command_data.\r\nwrite_sdram.length,\r\npri_is_rev_2_card(a->\r\nCardOrdinal)\r\n? MP2_MEMORY_SIZE :\r\nMP_MEMORY_SIZE);\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_STOP_ADAPTER:\r\nret = diva_pri_stop_adapter(a);\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_START_ADAPTER:\r\nret = diva_pri_start_adapter(&a->xdi_adapter,\r\ncmd->command_data.start.\r\noffset,\r\ncmd->command_data.start.\r\nfeatures);\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_SET_PROTOCOL_FEATURES:\r\na->xdi_adapter.features =\r\ncmd->command_data.features.features;\r\na->xdi_adapter.a.protocol_capabilities =\r\na->xdi_adapter.features;\r\nDBG_TRC(("Set raw protocol features (%08x)",\r\na->xdi_adapter.features))\r\nret = 0;\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_GET_CARD_STATE:\r\na->xdi_mbox.data_length = sizeof(dword);\r\na->xdi_mbox.data =\r\ndiva_os_malloc(0, a->xdi_mbox.data_length);\r\nif (a->xdi_mbox.data) {\r\ndword *data = (dword *) a->xdi_mbox.data;\r\nif (!a->xdi_adapter.ram ||\r\n!a->xdi_adapter.reset ||\r\n!a->xdi_adapter.cfg) {\r\n*data = 3;\r\n} else if (a->xdi_adapter.trapped) {\r\n*data = 2;\r\n} else if (a->xdi_adapter.Initialized) {\r\n*data = 1;\r\n} else {\r\n*data = 0;\r\n}\r\na->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\r\nret = 0;\r\n}\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_READ_XLOG_ENTRY:\r\nret = diva_card_read_xlog(a);\r\nbreak;\r\ncase DIVA_XDI_UM_CMD_READ_SDRAM:\r\nif (a->xdi_adapter.Address) {\r\nif (\r\n(a->xdi_mbox.data_length =\r\ncmd->command_data.read_sdram.length)) {\r\nif (\r\n(a->xdi_mbox.data_length +\r\ncmd->command_data.read_sdram.offset) <\r\na->xdi_adapter.MemorySize) {\r\na->xdi_mbox.data =\r\ndiva_os_malloc(0,\r\na->xdi_mbox.\r\ndata_length);\r\nif (a->xdi_mbox.data) {\r\nbyte __iomem *p = DIVA_OS_MEM_ATTACH_ADDRESS(&a->xdi_adapter);\r\nbyte __iomem *src = p;\r\nbyte *dst = a->xdi_mbox.data;\r\ndword len = a->xdi_mbox.data_length;\r\nsrc += cmd->command_data.read_sdram.offset;\r\nwhile (len--) {\r\n*dst++ = READ_BYTE(src++);\r\n}\r\na->xdi_mbox.status = DIVA_XDI_MBOX_BUSY;\r\nDIVA_OS_MEM_DETACH_ADDRESS(&a->xdi_adapter, p);\r\nret = 0;\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nDBG_ERR(("A: A(%d) invalid cmd=%d", a->controller,\r\ncmd->command))\r\n}\r\nreturn (ret);\r\n}\r\nstatic int pri_get_serial_number(diva_os_xdi_adapter_t * a)\r\n{\r\nbyte data[64];\r\nint i;\r\ndword len = sizeof(data);\r\nvolatile byte __iomem *config;\r\nvolatile byte __iomem *flash;\r\nbyte c;\r\nconfig = DIVA_OS_MEM_ATTACH_CONFIG(&a->xdi_adapter);\r\nc = READ_BYTE(&config[0xc3c]);\r\nif (!(c & 0x08)) {\r\nWRITE_BYTE(&config[0xc3c], c);\r\n}\r\nWRITE_BYTE(&config[LOW_BOOTCS_DREG], 0x00);\r\nWRITE_BYTE(&config[HI_BOOTCS_DREG], 0xFF);\r\nDIVA_OS_MEM_DETACH_CONFIG(&a->xdi_adapter, config);\r\nmemset(data, '\0', len);\r\nflash = DIVA_OS_MEM_ATTACH_PROM(&a->xdi_adapter);\r\nfor (i = 0; i < len; i++) {\r\ndata[i] = READ_BYTE(&flash[0x8000 - len + i]);\r\n}\r\nDIVA_OS_MEM_DETACH_PROM(&a->xdi_adapter, flash);\r\nconfig = DIVA_OS_MEM_ATTACH_CONFIG(&a->xdi_adapter);\r\nWRITE_BYTE(&config[LOW_BOOTCS_DREG], 0xFC);\r\nWRITE_BYTE(&config[HI_BOOTCS_DREG], 0xFF);\r\nDIVA_OS_MEM_DETACH_CONFIG(&a->xdi_adapter, config);\r\nif (memcmp(&data[48], "DIVAserverPR", 12)) {\r\n#if !defined(DIVA_PRI_NO_PCI_BIOS_WORKAROUND)\r\nword cmd = 0, cmd_org;\r\nvoid *addr;\r\ndword addr1, addr3, addr4;\r\nbyte Bus, Slot;\r\nvoid *hdev;\r\naddr4 = a->resources.pci.bar[4];\r\naddr3 = a->resources.pci.bar[3];\r\naddr1 = a->resources.pci.bar[1];\r\nDBG_ERR(("A: apply Compaq BIOS workaround"))\r\nDBG_LOG(("%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",\r\ndata[0], data[1], data[2], data[3],\r\ndata[4], data[5], data[6], data[7]))\r\nBus = a->resources.pci.bus;\r\nSlot = a->resources.pci.func;\r\nhdev = a->resources.pci.hdev;\r\nPCIread(Bus, Slot, 0x04, &cmd_org, sizeof(cmd_org), hdev);\r\nPCIwrite(Bus, Slot, 0x04, &cmd, sizeof(cmd), hdev);\r\nPCIwrite(Bus, Slot, 0x14, &addr4, sizeof(addr4), hdev);\r\nPCIwrite(Bus, Slot, 0x20, &addr1, sizeof(addr1), hdev);\r\nPCIwrite(Bus, Slot, 0x04, &cmd_org, sizeof(cmd_org), hdev);\r\naddr = a->resources.pci.addr[1];\r\na->resources.pci.addr[1] = a->resources.pci.addr[4];\r\na->resources.pci.addr[4] = addr;\r\naddr1 = a->resources.pci.bar[1];\r\na->resources.pci.bar[1] = a->resources.pci.bar[4];\r\na->resources.pci.bar[4] = addr1;\r\nlen = sizeof(data);\r\nconfig = DIVA_OS_MEM_ATTACH_CONFIG(&a->xdi_adapter);\r\nif (!(config[0xc3c] & 0x08)) {\r\nconfig[0xc3c] |= 0x08;\r\n}\r\nconfig[LOW_BOOTCS_DREG] = 0x00;\r\nconfig[HI_BOOTCS_DREG] = 0xFF;\r\nDIVA_OS_MEM_DETACH_CONFIG(&a->xdi_adapter, config);\r\nmemset(data, '\0', len);\r\nflash = DIVA_OS_MEM_ATTACH_PROM(&a->xdi_adapter);\r\nfor (i = 0; i < len; i++) {\r\ndata[i] = flash[0x8000 - len + i];\r\n}\r\nDIVA_OS_MEM_ATTACH_PROM(&a->xdi_adapter, flash);\r\nconfig = DIVA_OS_MEM_ATTACH_CONFIG(&a->xdi_adapter);\r\nconfig[LOW_BOOTCS_DREG] = 0xFC;\r\nconfig[HI_BOOTCS_DREG] = 0xFF;\r\nDIVA_OS_MEM_DETACH_CONFIG(&a->xdi_adapter, config);\r\nif (memcmp(&data[48], "DIVAserverPR", 12)) {\r\nDBG_ERR(("A: failed to read serial number"))\r\nDBG_LOG(("%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",\r\ndata[0], data[1], data[2], data[3],\r\ndata[4], data[5], data[6], data[7]))\r\nreturn (-1);\r\n}\r\n#else\r\nDBG_ERR(("A: failed to read DIVA signature word"))\r\nDBG_LOG(("%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",\r\ndata[0], data[1], data[2], data[3],\r\ndata[4], data[5], data[6], data[7]))\r\nDBG_LOG(("%02x:%02x:%02x:%02x", data[47], data[46],\r\ndata[45], data[44]))\r\n#endif\r\n}\r\na->xdi_adapter.serialNo =\r\n(data[47] << 24) | (data[46] << 16) | (data[45] << 8) |\r\ndata[44];\r\nif (!a->xdi_adapter.serialNo\r\n|| (a->xdi_adapter.serialNo == 0xffffffff)) {\r\na->xdi_adapter.serialNo = 0;\r\nDBG_ERR(("A: failed to read serial number"))\r\nreturn (-1);\r\n}\r\nDBG_LOG(("Serial No. : %ld", a->xdi_adapter.serialNo))\r\nDBG_TRC(("Board Revision : %d.%02d", (int) data[41],\r\n(int) data[40]))\r\nDBG_TRC(("PLD revision : %d.%02d", (int) data[33],\r\n(int) data[32]))\r\nDBG_TRC(("Boot loader version : %d.%02d", (int) data[37],\r\n(int) data[36]))\r\nDBG_TRC(("Manufacturing Date : %d/%02d/%02d (yyyy/mm/dd)",\r\n(int) ((data[28] > 90) ? 1900 : 2000) +\r\n(int) data[28], (int) data[29], (int) data[30]))\r\nreturn (0);\r\n}\r\nvoid diva_os_prepare_pri2_functions(PISDN_ADAPTER IoAdapter)\r\n{\r\n}\r\nvoid diva_os_prepare_pri_functions(PISDN_ADAPTER IoAdapter)\r\n{\r\n}\r\nstatic int\r\ndsp_check_presence(volatile byte __iomem * addr, volatile byte __iomem * data, int dsp)\r\n{\r\nword pattern;\r\nWRITE_WORD(addr, 0x4000);\r\nWRITE_WORD(data, DSP_SIGNATURE_PROBE_WORD);\r\nWRITE_WORD(addr, 0x4000);\r\npattern = READ_WORD(data);\r\nif (pattern != DSP_SIGNATURE_PROBE_WORD) {\r\nDBG_TRC(("W: DSP[%d] %04x(is) != %04x(should)",\r\ndsp, pattern, DSP_SIGNATURE_PROBE_WORD))\r\nreturn (-1);\r\n}\r\nWRITE_WORD(addr, 0x4000);\r\nWRITE_WORD(data, ~DSP_SIGNATURE_PROBE_WORD);\r\nWRITE_WORD(addr, 0x4000);\r\npattern = READ_WORD(data);\r\nif (pattern != (word) ~ DSP_SIGNATURE_PROBE_WORD) {\r\nDBG_ERR(("A: DSP[%d] %04x(is) != %04x(should)",\r\ndsp, pattern, (word) ~ DSP_SIGNATURE_PROBE_WORD))\r\nreturn (-2);\r\n}\r\nDBG_TRC(("DSP[%d] present", dsp))\r\nreturn (0);\r\n}\r\nstatic dword diva_pri_detect_dsps(diva_os_xdi_adapter_t * a)\r\n{\r\nbyte __iomem *base;\r\nbyte __iomem *p;\r\ndword ret = 0;\r\ndword row_offset[7] = {\r\n0x00000000,\r\n0x00000800,\r\n0x00000840,\r\n0x00001000,\r\n0x00001040,\r\n0x00000000\r\n};\r\nbyte __iomem *dsp_addr_port;\r\nbyte __iomem *dsp_data_port;\r\nbyte row_state;\r\nint dsp_row = 0, dsp_index, dsp_num;\r\nif (!a->xdi_adapter.Control || !a->xdi_adapter.reset) {\r\nreturn (0);\r\n}\r\np = DIVA_OS_MEM_ATTACH_RESET(&a->xdi_adapter);\r\nWRITE_BYTE(p, _MP_RISC_RESET | _MP_DSP_RESET);\r\nDIVA_OS_MEM_DETACH_RESET(&a->xdi_adapter, p);\r\ndiva_os_wait(5);\r\nbase = DIVA_OS_MEM_ATTACH_CONTROL(&a->xdi_adapter);\r\nfor (dsp_num = 0; dsp_num < 30; dsp_num++) {\r\ndsp_row = dsp_num / 7 + 1;\r\ndsp_index = dsp_num % 7;\r\ndsp_data_port = base;\r\ndsp_addr_port = base;\r\ndsp_data_port += row_offset[dsp_row];\r\ndsp_addr_port += row_offset[dsp_row];\r\ndsp_data_port += (dsp_index * 8);\r\ndsp_addr_port += (dsp_index * 8) + 0x80;\r\nif (!dsp_check_presence\r\n(dsp_addr_port, dsp_data_port, dsp_num + 1)) {\r\nret |= (1 << dsp_num);\r\n}\r\n}\r\nDIVA_OS_MEM_DETACH_CONTROL(&a->xdi_adapter, base);\r\np = DIVA_OS_MEM_ATTACH_RESET(&a->xdi_adapter);\r\nWRITE_BYTE(p, _MP_RISC_RESET | _MP_LED1 | _MP_LED2);\r\nDIVA_OS_MEM_DETACH_RESET(&a->xdi_adapter, p);\r\ndiva_os_wait(5);\r\nfor (dsp_row = 0; dsp_row < 4; dsp_row++) {\r\nrow_state = ((ret >> (dsp_row * 7)) & 0x7F);\r\nif (row_state && (row_state != 0x7F)) {\r\nfor (dsp_index = 0; dsp_index < 7; dsp_index++) {\r\nif (!(row_state & (1 << dsp_index))) {\r\nDBG_ERR(("A: MODULE[%d]-DSP[%d] failed",\r\ndsp_row + 1,\r\ndsp_index + 1))\r\n}\r\n}\r\n}\r\n}\r\nif (!(ret & 0x10000000)) {\r\nDBG_ERR(("A: ON BOARD-DSP[1] failed"))\r\n}\r\nif (!(ret & 0x20000000)) {\r\nDBG_ERR(("A: ON BOARD-DSP[2] failed"))\r\n}\r\nDBG_LOG(("+-----------------------+"))\r\nDBG_LOG(("| DSP MODULE POPULATION |"))\r\nDBG_LOG(("+-----------------------+"))\r\nDBG_LOG(("| 1 | 2 | 3 | 4 |"))\r\nDBG_LOG(("+-----------------------+"))\r\nDBG_LOG(("| %s | %s | %s | %s |",\r\n((ret >> (0 * 7)) & 0x7F) ? "Y" : "N",\r\n((ret >> (1 * 7)) & 0x7F) ? "Y" : "N",\r\n((ret >> (2 * 7)) & 0x7F) ? "Y" : "N",\r\n((ret >> (3 * 7)) & 0x7F) ? "Y" : "N"))\r\nDBG_LOG(("+-----------------------+"))\r\nDBG_LOG(("DSP's(present-absent):%08x-%08x", ret,\r\n~ret & 0x3fffffff))\r\nreturn (ret);\r\n}
