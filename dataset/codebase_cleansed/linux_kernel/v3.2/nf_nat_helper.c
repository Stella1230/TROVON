static inline void\r\nadjust_tcp_sequence(u32 seq,\r\nint sizediff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct nf_conn_nat *nat = nfct_nat(ct);\r\nstruct nf_nat_seq *this_way = &nat->seq[dir];\r\npr_debug("adjust_tcp_sequence: seq = %u, sizediff = %d\n",\r\nseq, sizediff);\r\npr_debug("adjust_tcp_sequence: Seq_offset before: ");\r\nDUMP_OFFSET(this_way);\r\nspin_lock_bh(&nf_nat_seqofs_lock);\r\nif (this_way->offset_before == this_way->offset_after ||\r\nbefore(this_way->correction_pos, seq)) {\r\nthis_way->correction_pos = seq;\r\nthis_way->offset_before = this_way->offset_after;\r\nthis_way->offset_after += sizediff;\r\n}\r\nspin_unlock_bh(&nf_nat_seqofs_lock);\r\npr_debug("adjust_tcp_sequence: Seq_offset after: ");\r\nDUMP_OFFSET(this_way);\r\n}\r\ns16 nf_nat_get_offset(const struct nf_conn *ct,\r\nenum ip_conntrack_dir dir,\r\nu32 seq)\r\n{\r\nstruct nf_conn_nat *nat = nfct_nat(ct);\r\nstruct nf_nat_seq *this_way;\r\ns16 offset;\r\nif (!nat)\r\nreturn 0;\r\nthis_way = &nat->seq[dir];\r\nspin_lock_bh(&nf_nat_seqofs_lock);\r\noffset = after(seq, this_way->correction_pos)\r\n? this_way->offset_after : this_way->offset_before;\r\nspin_unlock_bh(&nf_nat_seqofs_lock);\r\nreturn offset;\r\n}\r\nstatic void mangle_contents(struct sk_buff *skb,\r\nunsigned int dataoff,\r\nunsigned int match_offset,\r\nunsigned int match_len,\r\nconst char *rep_buffer,\r\nunsigned int rep_len)\r\n{\r\nunsigned char *data;\r\nBUG_ON(skb_is_nonlinear(skb));\r\ndata = skb_network_header(skb) + dataoff;\r\nmemmove(data + match_offset + rep_len,\r\ndata + match_offset + match_len,\r\nskb->tail - (skb->network_header + dataoff +\r\nmatch_offset + match_len));\r\nmemcpy(data + match_offset, rep_buffer, rep_len);\r\nif (rep_len > match_len) {\r\npr_debug("nf_nat_mangle_packet: Extending packet by "\r\n"%u from %u bytes\n", rep_len - match_len, skb->len);\r\nskb_put(skb, rep_len - match_len);\r\n} else {\r\npr_debug("nf_nat_mangle_packet: Shrinking packet from "\r\n"%u from %u bytes\n", match_len - rep_len, skb->len);\r\n__skb_trim(skb, skb->len + rep_len - match_len);\r\n}\r\nip_hdr(skb)->tot_len = htons(skb->len);\r\nip_send_check(ip_hdr(skb));\r\n}\r\nstatic int enlarge_skb(struct sk_buff *skb, unsigned int extra)\r\n{\r\nif (skb->len + extra > 65535)\r\nreturn 0;\r\nif (pskb_expand_head(skb, 0, extra - skb_tailroom(skb), GFP_ATOMIC))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid nf_nat_set_seq_adjust(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\r\n__be32 seq, s16 off)\r\n{\r\nif (!off)\r\nreturn;\r\nset_bit(IPS_SEQ_ADJUST_BIT, &ct->status);\r\nadjust_tcp_sequence(ntohl(seq), off, ct, ctinfo);\r\nnf_conntrack_event_cache(IPCT_NATSEQADJ, ct);\r\n}\r\nstatic void nf_nat_csum(struct sk_buff *skb, const struct iphdr *iph, void *data,\r\nint datalen, __sum16 *check, int oldlen)\r\n{\r\nstruct rtable *rt = skb_rtable(skb);\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\nif (!(rt->rt_flags & RTCF_LOCAL) &&\r\n(!skb->dev || skb->dev->features & NETIF_F_V4_CSUM)) {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_start = skb_headroom(skb) +\r\nskb_network_offset(skb) +\r\niph->ihl * 4;\r\nskb->csum_offset = (void *)check - data;\r\n*check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\ndatalen, iph->protocol, 0);\r\n} else {\r\n*check = 0;\r\n*check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\ndatalen, iph->protocol,\r\ncsum_partial(data, datalen,\r\n0));\r\nif (iph->protocol == IPPROTO_UDP && !*check)\r\n*check = CSUM_MANGLED_0;\r\n}\r\n} else\r\ninet_proto_csum_replace2(check, skb,\r\nhtons(oldlen), htons(datalen), 1);\r\n}\r\nint __nf_nat_mangle_tcp_packet(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int match_offset,\r\nunsigned int match_len,\r\nconst char *rep_buffer,\r\nunsigned int rep_len, bool adjust)\r\n{\r\nstruct iphdr *iph;\r\nstruct tcphdr *tcph;\r\nint oldlen, datalen;\r\nif (!skb_make_writable(skb, skb->len))\r\nreturn 0;\r\nif (rep_len > match_len &&\r\nrep_len - match_len > skb_tailroom(skb) &&\r\n!enlarge_skb(skb, rep_len - match_len))\r\nreturn 0;\r\nSKB_LINEAR_ASSERT(skb);\r\niph = ip_hdr(skb);\r\ntcph = (void *)iph + iph->ihl*4;\r\noldlen = skb->len - iph->ihl*4;\r\nmangle_contents(skb, iph->ihl*4 + tcph->doff*4,\r\nmatch_offset, match_len, rep_buffer, rep_len);\r\ndatalen = skb->len - iph->ihl*4;\r\nnf_nat_csum(skb, iph, tcph, datalen, &tcph->check, oldlen);\r\nif (adjust && rep_len != match_len)\r\nnf_nat_set_seq_adjust(ct, ctinfo, tcph->seq,\r\n(int)rep_len - (int)match_len);\r\nreturn 1;\r\n}\r\nint\r\nnf_nat_mangle_udp_packet(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int match_offset,\r\nunsigned int match_len,\r\nconst char *rep_buffer,\r\nunsigned int rep_len)\r\n{\r\nstruct iphdr *iph;\r\nstruct udphdr *udph;\r\nint datalen, oldlen;\r\niph = ip_hdr(skb);\r\nif (skb->len < iph->ihl*4 + sizeof(*udph) +\r\nmatch_offset + match_len)\r\nreturn 0;\r\nif (!skb_make_writable(skb, skb->len))\r\nreturn 0;\r\nif (rep_len > match_len &&\r\nrep_len - match_len > skb_tailroom(skb) &&\r\n!enlarge_skb(skb, rep_len - match_len))\r\nreturn 0;\r\niph = ip_hdr(skb);\r\nudph = (void *)iph + iph->ihl*4;\r\noldlen = skb->len - iph->ihl*4;\r\nmangle_contents(skb, iph->ihl*4 + sizeof(*udph),\r\nmatch_offset, match_len, rep_buffer, rep_len);\r\ndatalen = skb->len - iph->ihl*4;\r\nudph->len = htons(datalen);\r\nif (!udph->check && skb->ip_summed != CHECKSUM_PARTIAL)\r\nreturn 1;\r\nnf_nat_csum(skb, iph, udph, datalen, &udph->check, oldlen);\r\nreturn 1;\r\n}\r\nstatic void\r\nsack_adjust(struct sk_buff *skb,\r\nstruct tcphdr *tcph,\r\nunsigned int sackoff,\r\nunsigned int sackend,\r\nstruct nf_nat_seq *natseq)\r\n{\r\nwhile (sackoff < sackend) {\r\nstruct tcp_sack_block_wire *sack;\r\n__be32 new_start_seq, new_end_seq;\r\nsack = (void *)skb->data + sackoff;\r\nif (after(ntohl(sack->start_seq) - natseq->offset_before,\r\nnatseq->correction_pos))\r\nnew_start_seq = htonl(ntohl(sack->start_seq)\r\n- natseq->offset_after);\r\nelse\r\nnew_start_seq = htonl(ntohl(sack->start_seq)\r\n- natseq->offset_before);\r\nif (after(ntohl(sack->end_seq) - natseq->offset_before,\r\nnatseq->correction_pos))\r\nnew_end_seq = htonl(ntohl(sack->end_seq)\r\n- natseq->offset_after);\r\nelse\r\nnew_end_seq = htonl(ntohl(sack->end_seq)\r\n- natseq->offset_before);\r\npr_debug("sack_adjust: start_seq: %d->%d, end_seq: %d->%d\n",\r\nntohl(sack->start_seq), new_start_seq,\r\nntohl(sack->end_seq), new_end_seq);\r\ninet_proto_csum_replace4(&tcph->check, skb,\r\nsack->start_seq, new_start_seq, 0);\r\ninet_proto_csum_replace4(&tcph->check, skb,\r\nsack->end_seq, new_end_seq, 0);\r\nsack->start_seq = new_start_seq;\r\nsack->end_seq = new_end_seq;\r\nsackoff += sizeof(*sack);\r\n}\r\n}\r\nstatic inline unsigned int\r\nnf_nat_sack_adjust(struct sk_buff *skb,\r\nstruct tcphdr *tcph,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nunsigned int dir, optoff, optend;\r\nstruct nf_conn_nat *nat = nfct_nat(ct);\r\noptoff = ip_hdrlen(skb) + sizeof(struct tcphdr);\r\noptend = ip_hdrlen(skb) + tcph->doff * 4;\r\nif (!skb_make_writable(skb, optend))\r\nreturn 0;\r\ndir = CTINFO2DIR(ctinfo);\r\nwhile (optoff < optend) {\r\nunsigned char *op = skb->data + optoff;\r\nswitch (op[0]) {\r\ncase TCPOPT_EOL:\r\nreturn 1;\r\ncase TCPOPT_NOP:\r\noptoff++;\r\ncontinue;\r\ndefault:\r\nif (optoff + 1 == optend ||\r\noptoff + op[1] > optend ||\r\nop[1] < 2)\r\nreturn 0;\r\nif (op[0] == TCPOPT_SACK &&\r\nop[1] >= 2+TCPOLEN_SACK_PERBLOCK &&\r\n((op[1] - 2) % TCPOLEN_SACK_PERBLOCK) == 0)\r\nsack_adjust(skb, tcph, optoff+2,\r\noptoff+op[1], &nat->seq[!dir]);\r\noptoff += op[1];\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint\r\nnf_nat_seq_adjust(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nstruct tcphdr *tcph;\r\nint dir;\r\n__be32 newseq, newack;\r\ns16 seqoff, ackoff;\r\nstruct nf_conn_nat *nat = nfct_nat(ct);\r\nstruct nf_nat_seq *this_way, *other_way;\r\ndir = CTINFO2DIR(ctinfo);\r\nthis_way = &nat->seq[dir];\r\nother_way = &nat->seq[!dir];\r\nif (!skb_make_writable(skb, ip_hdrlen(skb) + sizeof(*tcph)))\r\nreturn 0;\r\ntcph = (void *)skb->data + ip_hdrlen(skb);\r\nif (after(ntohl(tcph->seq), this_way->correction_pos))\r\nseqoff = this_way->offset_after;\r\nelse\r\nseqoff = this_way->offset_before;\r\nif (after(ntohl(tcph->ack_seq) - other_way->offset_before,\r\nother_way->correction_pos))\r\nackoff = other_way->offset_after;\r\nelse\r\nackoff = other_way->offset_before;\r\nnewseq = htonl(ntohl(tcph->seq) + seqoff);\r\nnewack = htonl(ntohl(tcph->ack_seq) - ackoff);\r\ninet_proto_csum_replace4(&tcph->check, skb, tcph->seq, newseq, 0);\r\ninet_proto_csum_replace4(&tcph->check, skb, tcph->ack_seq, newack, 0);\r\npr_debug("Adjusting sequence number from %u->%u, ack from %u->%u\n",\r\nntohl(tcph->seq), ntohl(newseq), ntohl(tcph->ack_seq),\r\nntohl(newack));\r\ntcph->seq = newseq;\r\ntcph->ack_seq = newack;\r\nreturn nf_nat_sack_adjust(skb, tcph, ct, ctinfo);\r\n}\r\nvoid nf_nat_follow_master(struct nf_conn *ct,\r\nstruct nf_conntrack_expect *exp)\r\n{\r\nstruct nf_nat_range range;\r\nBUG_ON(ct->status & IPS_NAT_DONE_MASK);\r\nrange.flags = IP_NAT_RANGE_MAP_IPS;\r\nrange.min_ip = range.max_ip\r\n= ct->master->tuplehash[!exp->dir].tuple.dst.u3.ip;\r\nnf_nat_setup_info(ct, &range, IP_NAT_MANIP_SRC);\r\nrange.flags = (IP_NAT_RANGE_MAP_IPS | IP_NAT_RANGE_PROTO_SPECIFIED);\r\nrange.min = range.max = exp->saved_proto;\r\nrange.min_ip = range.max_ip\r\n= ct->master->tuplehash[!exp->dir].tuple.src.u3.ip;\r\nnf_nat_setup_info(ct, &range, IP_NAT_MANIP_DST);\r\n}
