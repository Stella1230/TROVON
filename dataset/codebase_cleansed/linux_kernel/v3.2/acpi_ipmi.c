static struct acpi_ipmi_msg *acpi_alloc_ipmi_msg(struct acpi_ipmi_device *ipmi)\r\n{\r\nstruct acpi_ipmi_msg *ipmi_msg;\r\nstruct pnp_dev *pnp_dev = ipmi->pnp_dev;\r\nipmi_msg = kzalloc(sizeof(struct acpi_ipmi_msg), GFP_KERNEL);\r\nif (!ipmi_msg) {\r\ndev_warn(&pnp_dev->dev, "Can't allocate memory for ipmi_msg\n");\r\nreturn NULL;\r\n}\r\ninit_completion(&ipmi_msg->tx_complete);\r\nINIT_LIST_HEAD(&ipmi_msg->head);\r\nipmi_msg->device = ipmi;\r\nreturn ipmi_msg;\r\n}\r\nstatic void acpi_format_ipmi_msg(struct acpi_ipmi_msg *tx_msg,\r\nacpi_physical_address address,\r\nacpi_integer *value)\r\n{\r\nstruct kernel_ipmi_msg *msg;\r\nstruct acpi_ipmi_buffer *buffer;\r\nstruct acpi_ipmi_device *device;\r\nmsg = &tx_msg->tx_message;\r\nmsg->netfn = IPMI_OP_RGN_NETFN(address);\r\nmsg->cmd = IPMI_OP_RGN_CMD(address);\r\nmsg->data = tx_msg->tx_data;\r\nbuffer = (struct acpi_ipmi_buffer *)value;\r\nmsg->data_len = buffer->length;\r\nmemcpy(tx_msg->tx_data, buffer->data, msg->data_len);\r\ntx_msg->addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\ntx_msg->addr.channel = IPMI_BMC_CHANNEL;\r\ntx_msg->addr.data[0] = 0;\r\ndevice = tx_msg->device;\r\nmutex_lock(&device->tx_msg_lock);\r\ndevice->curr_msgid++;\r\ntx_msg->tx_msgid = device->curr_msgid;\r\nmutex_unlock(&device->tx_msg_lock);\r\n}\r\nstatic void acpi_format_ipmi_response(struct acpi_ipmi_msg *msg,\r\nacpi_integer *value, int rem_time)\r\n{\r\nstruct acpi_ipmi_buffer *buffer;\r\nbuffer = (struct acpi_ipmi_buffer *)value;\r\nif (!rem_time && !msg->msg_done) {\r\nbuffer->status = ACPI_IPMI_TIMEOUT;\r\nreturn;\r\n}\r\nif (!msg->msg_done || !msg->rx_len) {\r\nbuffer->status = ACPI_IPMI_UNKNOWN;\r\nreturn;\r\n}\r\nbuffer->status = ACPI_IPMI_OK;\r\nbuffer->length = msg->rx_len;\r\nmemcpy(buffer->data, msg->rx_data, msg->rx_len);\r\n}\r\nstatic void ipmi_flush_tx_msg(struct acpi_ipmi_device *ipmi)\r\n{\r\nstruct acpi_ipmi_msg *tx_msg, *temp;\r\nint count = HZ / 10;\r\nstruct pnp_dev *pnp_dev = ipmi->pnp_dev;\r\nlist_for_each_entry_safe(tx_msg, temp, &ipmi->tx_msg_list, head) {\r\ncomplete(&tx_msg->tx_complete);\r\n}\r\nwhile (count--) {\r\nif (list_empty(&ipmi->tx_msg_list))\r\nbreak;\r\nschedule_timeout(1);\r\n}\r\nif (!list_empty(&ipmi->tx_msg_list))\r\ndev_warn(&pnp_dev->dev, "tx msg list is not NULL\n");\r\n}\r\nstatic void ipmi_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device = user_msg_data;\r\nint msg_found = 0;\r\nstruct acpi_ipmi_msg *tx_msg;\r\nstruct pnp_dev *pnp_dev = ipmi_device->pnp_dev;\r\nif (msg->user != ipmi_device->user_interface) {\r\ndev_warn(&pnp_dev->dev, "Unexpected response is returned. "\r\n"returned user %p, expected user %p\n",\r\nmsg->user, ipmi_device->user_interface);\r\nipmi_free_recv_msg(msg);\r\nreturn;\r\n}\r\nmutex_lock(&ipmi_device->tx_msg_lock);\r\nlist_for_each_entry(tx_msg, &ipmi_device->tx_msg_list, head) {\r\nif (msg->msgid == tx_msg->tx_msgid) {\r\nmsg_found = 1;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ipmi_device->tx_msg_lock);\r\nif (!msg_found) {\r\ndev_warn(&pnp_dev->dev, "Unexpected response (msg id %ld) is "\r\n"returned.\n", msg->msgid);\r\nipmi_free_recv_msg(msg);\r\nreturn;\r\n}\r\nif (msg->msg.data_len) {\r\nmemcpy(tx_msg->rx_data, msg->msg_data, msg->msg.data_len);\r\ntx_msg->rx_len = msg->msg.data_len;\r\ntx_msg->msg_done = 1;\r\n}\r\ncomplete(&tx_msg->tx_complete);\r\nipmi_free_recv_msg(msg);\r\n}\r\nstatic void ipmi_register_bmc(int iface, struct device *dev)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device, *temp;\r\nstruct pnp_dev *pnp_dev;\r\nipmi_user_t user;\r\nint err;\r\nstruct ipmi_smi_info smi_data;\r\nacpi_handle handle;\r\nerr = ipmi_get_smi_info(iface, &smi_data);\r\nif (err)\r\nreturn;\r\nif (smi_data.addr_src != SI_ACPI) {\r\nput_device(smi_data.dev);\r\nreturn;\r\n}\r\nhandle = smi_data.addr_info.acpi_info.acpi_handle;\r\nmutex_lock(&driver_data.ipmi_lock);\r\nlist_for_each_entry(temp, &driver_data.ipmi_devices, head) {\r\nif (temp->handle == handle)\r\ngoto out;\r\n}\r\nipmi_device = kzalloc(sizeof(*ipmi_device), GFP_KERNEL);\r\nif (!ipmi_device)\r\ngoto out;\r\npnp_dev = to_pnp_dev(smi_data.dev);\r\nipmi_device->handle = handle;\r\nipmi_device->pnp_dev = pnp_dev;\r\nerr = ipmi_create_user(iface, &driver_data.ipmi_hndlrs,\r\nipmi_device, &user);\r\nif (err) {\r\ndev_warn(&pnp_dev->dev, "Can't create IPMI user interface\n");\r\nkfree(ipmi_device);\r\ngoto out;\r\n}\r\nacpi_add_ipmi_device(ipmi_device);\r\nipmi_device->user_interface = user;\r\nipmi_device->ipmi_ifnum = iface;\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nmemcpy(&ipmi_device->smi_data, &smi_data, sizeof(struct ipmi_smi_info));\r\nreturn;\r\nout:\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nput_device(smi_data.dev);\r\nreturn;\r\n}\r\nstatic void ipmi_bmc_gone(int iface)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device, *temp;\r\nmutex_lock(&driver_data.ipmi_lock);\r\nlist_for_each_entry_safe(ipmi_device, temp,\r\n&driver_data.ipmi_devices, head) {\r\nif (ipmi_device->ipmi_ifnum != iface)\r\ncontinue;\r\nacpi_remove_ipmi_device(ipmi_device);\r\nput_device(ipmi_device->smi_data.dev);\r\nkfree(ipmi_device);\r\nbreak;\r\n}\r\nmutex_unlock(&driver_data.ipmi_lock);\r\n}\r\nstatic acpi_status\r\nacpi_ipmi_space_handler(u32 function, acpi_physical_address address,\r\nu32 bits, acpi_integer *value,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct acpi_ipmi_msg *tx_msg;\r\nstruct acpi_ipmi_device *ipmi_device = handler_context;\r\nint err, rem_time;\r\nacpi_status status;\r\nif ((function & ACPI_IO_MASK) == ACPI_READ)\r\nreturn AE_TYPE;\r\nif (!ipmi_device->user_interface)\r\nreturn AE_NOT_EXIST;\r\ntx_msg = acpi_alloc_ipmi_msg(ipmi_device);\r\nif (!tx_msg)\r\nreturn AE_NO_MEMORY;\r\nacpi_format_ipmi_msg(tx_msg, address, value);\r\nmutex_lock(&ipmi_device->tx_msg_lock);\r\nlist_add_tail(&tx_msg->head, &ipmi_device->tx_msg_list);\r\nmutex_unlock(&ipmi_device->tx_msg_lock);\r\nerr = ipmi_request_settime(ipmi_device->user_interface,\r\n&tx_msg->addr,\r\ntx_msg->tx_msgid,\r\n&tx_msg->tx_message,\r\nNULL, 0, 0, 0);\r\nif (err) {\r\nstatus = AE_ERROR;\r\ngoto end_label;\r\n}\r\nrem_time = wait_for_completion_timeout(&tx_msg->tx_complete,\r\nIPMI_TIMEOUT);\r\nacpi_format_ipmi_response(tx_msg, value, rem_time);\r\nstatus = AE_OK;\r\nend_label:\r\nmutex_lock(&ipmi_device->tx_msg_lock);\r\nlist_del(&tx_msg->head);\r\nmutex_unlock(&ipmi_device->tx_msg_lock);\r\nkfree(tx_msg);\r\nreturn status;\r\n}\r\nstatic void ipmi_remove_space_handler(struct acpi_ipmi_device *ipmi)\r\n{\r\nif (!test_bit(IPMI_FLAGS_HANDLER_INSTALL, &ipmi->flags))\r\nreturn;\r\nacpi_remove_address_space_handler(ipmi->handle,\r\nACPI_ADR_SPACE_IPMI, &acpi_ipmi_space_handler);\r\nclear_bit(IPMI_FLAGS_HANDLER_INSTALL, &ipmi->flags);\r\n}\r\nstatic int ipmi_install_space_handler(struct acpi_ipmi_device *ipmi)\r\n{\r\nacpi_status status;\r\nif (test_bit(IPMI_FLAGS_HANDLER_INSTALL, &ipmi->flags))\r\nreturn 0;\r\nstatus = acpi_install_address_space_handler(ipmi->handle,\r\nACPI_ADR_SPACE_IPMI,\r\n&acpi_ipmi_space_handler,\r\nNULL, ipmi);\r\nif (ACPI_FAILURE(status)) {\r\nstruct pnp_dev *pnp_dev = ipmi->pnp_dev;\r\ndev_warn(&pnp_dev->dev, "Can't register IPMI opregion space "\r\n"handle\n");\r\nreturn -EINVAL;\r\n}\r\nset_bit(IPMI_FLAGS_HANDLER_INSTALL, &ipmi->flags);\r\nreturn 0;\r\n}\r\nstatic void acpi_add_ipmi_device(struct acpi_ipmi_device *ipmi_device)\r\n{\r\nINIT_LIST_HEAD(&ipmi_device->head);\r\nmutex_init(&ipmi_device->tx_msg_lock);\r\nINIT_LIST_HEAD(&ipmi_device->tx_msg_list);\r\nipmi_install_space_handler(ipmi_device);\r\nlist_add_tail(&ipmi_device->head, &driver_data.ipmi_devices);\r\n}\r\nstatic void acpi_remove_ipmi_device(struct acpi_ipmi_device *ipmi_device)\r\n{\r\nif (ipmi_device->user_interface) {\r\nipmi_destroy_user(ipmi_device->user_interface);\r\nipmi_device->user_interface = NULL;\r\n}\r\nif (!list_empty(&ipmi_device->tx_msg_list))\r\nipmi_flush_tx_msg(ipmi_device);\r\nlist_del(&ipmi_device->head);\r\nipmi_remove_space_handler(ipmi_device);\r\n}\r\nstatic int __init acpi_ipmi_init(void)\r\n{\r\nint result = 0;\r\nif (acpi_disabled)\r\nreturn result;\r\nmutex_init(&driver_data.ipmi_lock);\r\nresult = ipmi_smi_watcher_register(&driver_data.bmc_events);\r\nreturn result;\r\n}\r\nstatic void __exit acpi_ipmi_exit(void)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device, *temp;\r\nif (acpi_disabled)\r\nreturn;\r\nipmi_smi_watcher_unregister(&driver_data.bmc_events);\r\nmutex_lock(&driver_data.ipmi_lock);\r\nlist_for_each_entry_safe(ipmi_device, temp,\r\n&driver_data.ipmi_devices, head) {\r\nacpi_remove_ipmi_device(ipmi_device);\r\nput_device(ipmi_device->smi_data.dev);\r\nkfree(ipmi_device);\r\n}\r\nmutex_unlock(&driver_data.ipmi_lock);\r\n}
