static int wm2000_write(struct i2c_client *i2c, unsigned int reg,\r\nunsigned int value)\r\n{\r\nu8 data[3];\r\nint ret;\r\ndata[0] = (reg >> 8) & 0xff;\r\ndata[1] = reg & 0xff;\r\ndata[2] = value & 0xff;\r\ndev_vdbg(&i2c->dev, "write %x = %x\n", reg, value);\r\nret = i2c_master_send(i2c, data, 3);\r\nif (ret == 3)\r\nreturn 0;\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic unsigned int wm2000_read(struct i2c_client *i2c, unsigned int r)\r\n{\r\nstruct i2c_msg xfer[2];\r\nu8 reg[2];\r\nu8 data;\r\nint ret;\r\nreg[0] = (r >> 8) & 0xff;\r\nreg[1] = r & 0xff;\r\nxfer[0].addr = i2c->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = sizeof(reg);\r\nxfer[0].buf = &reg[0];\r\nxfer[1].addr = i2c->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = 1;\r\nxfer[1].buf = &data;\r\nret = i2c_transfer(i2c->adapter, xfer, 2);\r\nif (ret != 2) {\r\ndev_err(&i2c->dev, "i2c_transfer() returned %d\n", ret);\r\nreturn 0;\r\n}\r\ndev_vdbg(&i2c->dev, "read %x from %x\n", data, r);\r\nreturn data;\r\n}\r\nstatic void wm2000_reset(struct wm2000_priv *wm2000)\r\n{\r\nstruct i2c_client *i2c = wm2000->i2c;\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\r\nwm2000_write(i2c, WM2000_REG_ID1, 0);\r\nwm2000->anc_mode = ANC_OFF;\r\n}\r\nstatic int wm2000_poll_bit(struct i2c_client *i2c,\r\nunsigned int reg, u8 mask, int timeout)\r\n{\r\nint val;\r\nval = wm2000_read(i2c, reg);\r\nwhile (!(val & mask) && --timeout) {\r\nmsleep(1);\r\nval = wm2000_read(i2c, reg);\r\n}\r\nif (timeout == 0)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int wm2000_power_up(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nint ret, timeout;\r\nBUG_ON(wm2000->anc_mode != ANC_OFF);\r\ndev_dbg(&i2c->dev, "Beginning power up\n");\r\nif (!wm2000->mclk_div) {\r\ndev_dbg(&i2c->dev, "Disabling MCLK divider\n");\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2,\r\nWM2000_MCLK_DIV2_ENA_CLR);\r\n} else {\r\ndev_dbg(&i2c->dev, "Enabling MCLK divider\n");\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2,\r\nWM2000_MCLK_DIV2_ENA_SET);\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_SET);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\r\nWM2000_ANC_ENG_IDLE, 1)) {\r\ndev_err(&i2c->dev, "ANC engine failed to reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_BOOT_COMPLETE, 1)) {\r\ndev_err(&i2c->dev, "ANC engine failed to initialise\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\r\ndev_dbg(&i2c->dev, "Downloading %d bytes\n",\r\nwm2000->anc_download_size - 2);\r\nret = i2c_master_send(i2c, wm2000->anc_download,\r\nwm2000->anc_download_size);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "i2c_transfer() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ret != wm2000->anc_download_size) {\r\ndev_err(&i2c->dev, "i2c_transfer() failed, %d != %d\n",\r\nret, wm2000->anc_download_size);\r\nreturn -EIO;\r\n}\r\ndev_dbg(&i2c->dev, "Download complete\n");\r\nif (analogue) {\r\ntimeout = 248;\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, timeout / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n} else {\r\ntimeout = 10;\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n}\r\nret = wm2000_read(i2c, WM2000_REG_SPEECH_CLARITY);\r\nif (wm2000->speech_clarity)\r\nret &= ~WM2000_SPEECH_CLARITY;\r\nelse\r\nret |= WM2000_SPEECH_CLARITY;\r\nwm2000_write(i2c, WM2000_REG_SPEECH_CLARITY, ret);\r\nwm2000_write(i2c, WM2000_REG_SYS_START0, 0x33);\r\nwm2000_write(i2c, WM2000_REG_SYS_START1, 0x02);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_MOUSE_ACTIVE, timeout)) {\r\ndev_err(&i2c->dev, "Timed out waiting for device after %dms\n",\r\ntimeout * 10);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(&i2c->dev, "ANC active\n");\r\nif (analogue)\r\ndev_dbg(&i2c->dev, "Analogue active\n");\r\nwm2000->anc_mode = ANC_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int wm2000_power_down(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nint timeout;\r\nif (analogue) {\r\ntimeout = 248;\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, timeout / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_POWER_DOWN);\r\n} else {\r\ntimeout = 10;\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_POWER_DOWN);\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_POWER_DOWN_COMPLETE, timeout)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC power down\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\r\nWM2000_ANC_ENG_IDLE, 1)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC engine idle\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(&i2c->dev, "powered off\n");\r\nwm2000->anc_mode = ANC_OFF;\r\nreturn 0;\r\n}\r\nstatic int wm2000_enter_bypass(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nBUG_ON(wm2000->anc_mode != ANC_ACTIVE);\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_BYPASS_ENTRY);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_BYPASS_ENTRY);\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_ANC_DISABLED, 10)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC disable\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\r\nWM2000_ANC_ENG_IDLE, 1)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC engine idle\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\r\nwm2000->anc_mode = ANC_BYPASS;\r\ndev_dbg(&i2c->dev, "bypass enabled\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_exit_bypass(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nBUG_ON(wm2000->anc_mode != ANC_BYPASS);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_MOUSE_ACTIVE, 10)) {\r\ndev_err(&i2c->dev, "Timed out waiting for MOUSE\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000->anc_mode = ANC_ACTIVE;\r\ndev_dbg(&i2c->dev, "MOUSE active\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_enter_standby(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nint timeout;\r\nBUG_ON(wm2000->anc_mode != ANC_ACTIVE);\r\nif (analogue) {\r\ntimeout = 248;\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, timeout / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_STANDBY_ENTRY);\r\n} else {\r\ntimeout = 10;\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_STANDBY_ENTRY);\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_ANC_DISABLED, timeout)) {\r\ndev_err(&i2c->dev,\r\n"Timed out waiting for ANC disable after 1ms\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT, WM2000_ANC_ENG_IDLE,\r\n1)) {\r\ndev_err(&i2c->dev,\r\n"Timed out waiting for standby after %dms\n",\r\ntimeout * 10);\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\r\nwm2000->anc_mode = ANC_STANDBY;\r\ndev_dbg(&i2c->dev, "standby\n");\r\nif (analogue)\r\ndev_dbg(&i2c->dev, "Analogue disabled\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_exit_standby(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nint timeout;\r\nBUG_ON(wm2000->anc_mode != ANC_STANDBY);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);\r\nif (analogue) {\r\ntimeout = 248;\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, timeout / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_MOUSE_ENABLE);\r\n} else {\r\ntimeout = 10;\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_MOUSE_ENABLE);\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_MOUSE_ACTIVE, timeout)) {\r\ndev_err(&i2c->dev, "Timed out waiting for MOUSE after %dms\n",\r\ntimeout * 10);\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000->anc_mode = ANC_ACTIVE;\r\ndev_dbg(&i2c->dev, "MOUSE active\n");\r\nif (analogue)\r\ndev_dbg(&i2c->dev, "Analogue enabled\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_anc_transition(struct wm2000_priv *wm2000,\r\nenum wm2000_anc_mode mode)\r\n{\r\nstruct i2c_client *i2c = wm2000->i2c;\r\nint i, j;\r\nint ret;\r\nif (wm2000->anc_mode == mode)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(anc_transitions); i++)\r\nif (anc_transitions[i].source == wm2000->anc_mode &&\r\nanc_transitions[i].dest == mode)\r\nbreak;\r\nif (i == ARRAY_SIZE(anc_transitions)) {\r\ndev_err(&i2c->dev, "No transition for %d->%d\n",\r\nwm2000->anc_mode, mode);\r\nreturn -EINVAL;\r\n}\r\nfor (j = 0; j < ARRAY_SIZE(anc_transitions[j].step); j++) {\r\nif (!anc_transitions[i].step[j])\r\nbreak;\r\nret = anc_transitions[i].step[j](i2c,\r\nanc_transitions[i].analogue);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm2000_anc_set_mode(struct wm2000_priv *wm2000)\r\n{\r\nstruct i2c_client *i2c = wm2000->i2c;\r\nenum wm2000_anc_mode mode;\r\nif (wm2000->anc_eng_ena && wm2000->spk_ena)\r\nif (wm2000->anc_active)\r\nmode = ANC_ACTIVE;\r\nelse\r\nmode = ANC_BYPASS;\r\nelse\r\nmode = ANC_STANDBY;\r\ndev_dbg(&i2c->dev, "Set mode %d (enabled %d, mute %d, active %d)\n",\r\nmode, wm2000->anc_eng_ena, !wm2000->spk_ena,\r\nwm2000->anc_active);\r\nreturn wm2000_anc_transition(wm2000, mode);\r\n}\r\nstatic int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&wm2000_i2c->dev);\r\nucontrol->value.enumerated.item[0] = wm2000->anc_active;\r\nreturn 0;\r\n}\r\nstatic int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&wm2000_i2c->dev);\r\nint anc_active = ucontrol->value.enumerated.item[0];\r\nif (anc_active > 1)\r\nreturn -EINVAL;\r\nwm2000->anc_active = anc_active;\r\nreturn wm2000_anc_set_mode(wm2000);\r\n}\r\nstatic int wm2000_speaker_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&wm2000_i2c->dev);\r\nucontrol->value.enumerated.item[0] = wm2000->spk_ena;\r\nreturn 0;\r\n}\r\nstatic int wm2000_speaker_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&wm2000_i2c->dev);\r\nint val = ucontrol->value.enumerated.item[0];\r\nif (val > 1)\r\nreturn -EINVAL;\r\nwm2000->spk_ena = val;\r\nreturn wm2000_anc_set_mode(wm2000);\r\n}\r\nstatic int wm2000_anc_power_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&wm2000_i2c->dev);\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\nwm2000->anc_eng_ena = 1;\r\nif (SND_SOC_DAPM_EVENT_OFF(event))\r\nwm2000->anc_eng_ena = 0;\r\nreturn wm2000_anc_set_mode(wm2000);\r\n}\r\nint wm2000_add_controls(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint ret;\r\nif (!wm2000_i2c) {\r\npr_err("WM2000 not yet probed\n");\r\nreturn -ENODEV;\r\n}\r\nret = snd_soc_dapm_new_controls(dapm, wm2000_dapm_widgets,\r\nARRAY_SIZE(wm2000_dapm_widgets));\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn snd_soc_add_controls(codec, wm2000_controls,\r\nARRAY_SIZE(wm2000_controls));\r\n}\r\nstatic int __devinit wm2000_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct wm2000_priv *wm2000;\r\nstruct wm2000_platform_data *pdata;\r\nconst char *filename;\r\nconst struct firmware *fw;\r\nint reg, ret;\r\nu16 id;\r\nif (wm2000_i2c) {\r\ndev_err(&i2c->dev, "Another WM2000 is already registered\n");\r\nreturn -EINVAL;\r\n}\r\nwm2000 = kzalloc(sizeof(struct wm2000_priv), GFP_KERNEL);\r\nif (wm2000 == NULL) {\r\ndev_err(&i2c->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nreg = wm2000_read(i2c, WM2000_REG_ID1);\r\nid = reg << 8;\r\nreg = wm2000_read(i2c, WM2000_REG_ID2);\r\nid |= reg & 0xff;\r\nif (id != 0x2000) {\r\ndev_err(&i2c->dev, "Device is not a WM2000 - ID %x\n", id);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreg = wm2000_read(i2c, WM2000_REG_REVISON);\r\ndev_info(&i2c->dev, "revision %c\n", reg + 'A');\r\nfilename = "wm2000_anc.bin";\r\npdata = dev_get_platdata(&i2c->dev);\r\nif (pdata) {\r\nwm2000->mclk_div = pdata->mclkdiv2;\r\nwm2000->speech_clarity = !pdata->speech_enh_disable;\r\nif (pdata->download_file)\r\nfilename = pdata->download_file;\r\n}\r\nret = request_firmware(&fw, filename, &i2c->dev);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to acquire ANC data: %d\n", ret);\r\ngoto err;\r\n}\r\nwm2000->anc_download_size = fw->size + 2;\r\nwm2000->anc_download = kmalloc(wm2000->anc_download_size, GFP_KERNEL);\r\nif (wm2000->anc_download == NULL) {\r\ndev_err(&i2c->dev, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto err_fw;\r\n}\r\nwm2000->anc_download[0] = 0x80;\r\nwm2000->anc_download[1] = 0x00;\r\nmemcpy(wm2000->anc_download + 2, fw->data, fw->size);\r\nrelease_firmware(fw);\r\ndev_set_drvdata(&i2c->dev, wm2000);\r\nwm2000->anc_eng_ena = 1;\r\nwm2000->anc_active = 1;\r\nwm2000->spk_ena = 1;\r\nwm2000->i2c = i2c;\r\nwm2000_reset(wm2000);\r\nwm2000_anc_set_mode(wm2000);\r\nwm2000_i2c = i2c;\r\nreturn 0;\r\nerr_fw:\r\nrelease_firmware(fw);\r\nerr:\r\nkfree(wm2000);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm2000_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nwm2000_anc_transition(wm2000, ANC_OFF);\r\nwm2000_i2c = NULL;\r\nkfree(wm2000->anc_download);\r\nkfree(wm2000);\r\nreturn 0;\r\n}\r\nstatic void wm2000_i2c_shutdown(struct i2c_client *i2c)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nwm2000_anc_transition(wm2000, ANC_OFF);\r\n}\r\nstatic int wm2000_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nreturn wm2000_anc_transition(wm2000, ANC_OFF);\r\n}\r\nstatic int wm2000_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nreturn wm2000_anc_set_mode(wm2000);\r\n}\r\nstatic int __init wm2000_init(void)\r\n{\r\nreturn i2c_add_driver(&wm2000_i2c_driver);\r\n}\r\nstatic void __exit wm2000_exit(void)\r\n{\r\ni2c_del_driver(&wm2000_i2c_driver);\r\n}
