static int pmic8xxx_kp_write_u8(struct pmic8xxx_kp *kp,\r\nu8 data, u16 reg)\r\n{\r\nint rc;\r\nrc = pm8xxx_writeb(kp->dev->parent, reg, data);\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_read(struct pmic8xxx_kp *kp,\r\nu8 *data, u16 reg, unsigned num_bytes)\r\n{\r\nint rc;\r\nrc = pm8xxx_read_buf(kp->dev->parent, reg, data, num_bytes);\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_read_u8(struct pmic8xxx_kp *kp,\r\nu8 *data, u16 reg)\r\n{\r\nint rc;\r\nrc = pmic8xxx_kp_read(kp, data, reg, 1);\r\nreturn rc;\r\n}\r\nstatic u8 pmic8xxx_col_state(struct pmic8xxx_kp *kp, u8 col)\r\n{\r\nif (col == 0x00)\r\nreturn 1 << kp->pdata->num_cols;\r\nelse\r\nreturn col & ((1 << kp->pdata->num_cols) - 1);\r\n}\r\nstatic int pmic8xxx_chk_sync_read(struct pmic8xxx_kp *kp)\r\n{\r\nint rc;\r\nu8 scan_val;\r\nrc = pmic8xxx_kp_read_u8(kp, &scan_val, KEYP_SCAN);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error reading KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nscan_val |= 0x1;\r\nrc = pmic8xxx_kp_write_u8(kp, scan_val, KEYP_SCAN);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error writing KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nudelay((2 * DIV_ROUND_UP(USEC_PER_SEC, KEYP_CLOCK_FREQ)) + 1);\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_read_data(struct pmic8xxx_kp *kp, u16 *state,\r\nu16 data_reg, int read_rows)\r\n{\r\nint rc, row;\r\nu8 new_data[PM8XXX_MAX_ROWS];\r\nrc = pmic8xxx_kp_read(kp, new_data, data_reg, read_rows);\r\nif (rc)\r\nreturn rc;\r\nfor (row = 0; row < kp->pdata->num_rows; row++) {\r\ndev_dbg(kp->dev, "new_data[%d] = %d\n", row,\r\nnew_data[row]);\r\nstate[row] = pmic8xxx_col_state(kp, new_data[row]);\r\n}\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_read_matrix(struct pmic8xxx_kp *kp, u16 *new_state,\r\nu16 *old_state)\r\n{\r\nint rc, read_rows;\r\nu8 scan_val;\r\nif (kp->pdata->num_rows < PM8XXX_MIN_ROWS)\r\nread_rows = PM8XXX_MIN_ROWS;\r\nelse\r\nread_rows = kp->pdata->num_rows;\r\npmic8xxx_chk_sync_read(kp);\r\nif (old_state) {\r\nrc = pmic8xxx_kp_read_data(kp, old_state, KEYP_OLD_DATA,\r\nread_rows);\r\nif (rc < 0) {\r\ndev_err(kp->dev,\r\n"Error reading KEYP_OLD_DATA, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nrc = pmic8xxx_kp_read_data(kp, new_state, KEYP_RECENT_DATA,\r\nread_rows);\r\nif (rc < 0) {\r\ndev_err(kp->dev,\r\n"Error reading KEYP_RECENT_DATA, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nudelay((4 * DIV_ROUND_UP(USEC_PER_SEC, KEYP_CLOCK_FREQ)) + 1);\r\nrc = pmic8xxx_kp_read_u8(kp, &scan_val, KEYP_SCAN);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error reading KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nscan_val &= 0xFE;\r\nrc = pmic8xxx_kp_write_u8(kp, scan_val, KEYP_SCAN);\r\nif (rc < 0)\r\ndev_err(kp->dev, "Error writing KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic void __pmic8xxx_kp_scan_matrix(struct pmic8xxx_kp *kp, u16 *new_state,\r\nu16 *old_state)\r\n{\r\nint row, col, code;\r\nfor (row = 0; row < kp->pdata->num_rows; row++) {\r\nint bits_changed = new_state[row] ^ old_state[row];\r\nif (!bits_changed)\r\ncontinue;\r\nfor (col = 0; col < kp->pdata->num_cols; col++) {\r\nif (!(bits_changed & (1 << col)))\r\ncontinue;\r\ndev_dbg(kp->dev, "key [%d:%d] %s\n", row, col,\r\n!(new_state[row] & (1 << col)) ?\r\n"pressed" : "released");\r\ncode = MATRIX_SCAN_CODE(row, col, PM8XXX_ROW_SHIFT);\r\ninput_event(kp->input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(kp->input,\r\nkp->keycodes[code],\r\n!(new_state[row] & (1 << col)));\r\ninput_sync(kp->input);\r\n}\r\n}\r\n}\r\nstatic bool pmic8xxx_detect_ghost_keys(struct pmic8xxx_kp *kp, u16 *new_state)\r\n{\r\nint row, found_first = -1;\r\nu16 check, row_state;\r\ncheck = 0;\r\nfor (row = 0; row < kp->pdata->num_rows; row++) {\r\nrow_state = (~new_state[row]) &\r\n((1 << kp->pdata->num_cols) - 1);\r\nif (hweight16(row_state) > 1) {\r\nif (found_first == -1)\r\nfound_first = row;\r\nif (check & row_state) {\r\ndev_dbg(kp->dev, "detected ghost key on row[%d]"\r\n" and row[%d]\n", found_first, row);\r\nreturn true;\r\n}\r\n}\r\ncheck |= row_state;\r\n}\r\nreturn false;\r\n}\r\nstatic int pmic8xxx_kp_scan_matrix(struct pmic8xxx_kp *kp, unsigned int events)\r\n{\r\nu16 new_state[PM8XXX_MAX_ROWS];\r\nu16 old_state[PM8XXX_MAX_ROWS];\r\nint rc;\r\nswitch (events) {\r\ncase 0x1:\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\nif (pmic8xxx_detect_ghost_keys(kp, new_state))\r\nreturn 0;\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, kp->keystate);\r\nmemcpy(kp->keystate, new_state, sizeof(new_state));\r\nbreak;\r\ncase 0x3:\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\r\nif (rc < 0)\r\nreturn rc;\r\n__pmic8xxx_kp_scan_matrix(kp, old_state, kp->keystate);\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, old_state);\r\nmemcpy(kp->keystate, new_state, sizeof(new_state));\r\nbreak;\r\ncase 0x2:\r\ndev_dbg(kp->dev, "Some key events were lost\n");\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\r\nif (rc < 0)\r\nreturn rc;\r\n__pmic8xxx_kp_scan_matrix(kp, old_state, kp->keystate);\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, old_state);\r\nmemcpy(kp->keystate, new_state, sizeof(new_state));\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic irqreturn_t pmic8xxx_kp_stuck_irq(int irq, void *data)\r\n{\r\nu16 new_state[PM8XXX_MAX_ROWS];\r\nu16 old_state[PM8XXX_MAX_ROWS];\r\nint rc;\r\nstruct pmic8xxx_kp *kp = data;\r\nrc = pmic8xxx_kp_read_matrix(kp, new_state, old_state);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "failed to read keypad matrix\n");\r\nreturn IRQ_HANDLED;\r\n}\r\n__pmic8xxx_kp_scan_matrix(kp, new_state, kp->stuckstate);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pmic8xxx_kp_irq(int irq, void *data)\r\n{\r\nstruct pmic8xxx_kp *kp = data;\r\nu8 ctrl_val, events;\r\nint rc;\r\nrc = pmic8xxx_kp_read(kp, &ctrl_val, KEYP_CTRL, 1);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "failed to read keyp_ctrl register\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nevents = ctrl_val & KEYP_CTRL_EVNTS_MASK;\r\nrc = pmic8xxx_kp_scan_matrix(kp, events);\r\nif (rc < 0)\r\ndev_err(kp->dev, "failed to scan matrix\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit pmic8xxx_kpd_init(struct pmic8xxx_kp *kp)\r\n{\r\nint bits, rc, cycles;\r\nu8 scan_val = 0, ctrl_val = 0;\r\nstatic const u8 row_bits[] = {\r\n0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7,\r\n};\r\nif (kp->pdata->num_cols < KEYP_CTRL_SCAN_COLS_MIN)\r\nbits = 0;\r\nelse\r\nbits = kp->pdata->num_cols - KEYP_CTRL_SCAN_COLS_MIN;\r\nctrl_val = (bits & KEYP_CTRL_SCAN_COLS_BITS) <<\r\nKEYP_CTRL_SCAN_COLS_SHIFT;\r\nif (kp->pdata->num_rows < KEYP_CTRL_SCAN_ROWS_MIN)\r\nbits = 0;\r\nelse\r\nbits = row_bits[kp->pdata->num_rows - KEYP_CTRL_SCAN_ROWS_MIN];\r\nctrl_val |= (bits << KEYP_CTRL_SCAN_ROWS_SHIFT);\r\nrc = pmic8xxx_kp_write_u8(kp, ctrl_val, KEYP_CTRL);\r\nif (rc < 0) {\r\ndev_err(kp->dev, "Error writing KEYP_CTRL reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nbits = (kp->pdata->debounce_ms / 5) - 1;\r\nscan_val |= (bits << KEYP_SCAN_DBOUNCE_SHIFT);\r\nbits = fls(kp->pdata->scan_delay_ms) - 1;\r\nscan_val |= (bits << KEYP_SCAN_PAUSE_SHIFT);\r\ncycles = (kp->pdata->row_hold_ns * KEYP_CLOCK_FREQ) / NSEC_PER_SEC;\r\nscan_val |= (cycles << KEYP_SCAN_ROW_HOLD_SHIFT);\r\nrc = pmic8xxx_kp_write_u8(kp, scan_val, KEYP_SCAN);\r\nif (rc)\r\ndev_err(kp->dev, "Error writing KEYP_SCAN reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int __devinit pmic8xxx_kp_config_gpio(int gpio_start, int num_gpios,\r\nstruct pmic8xxx_kp *kp, struct pm_gpio *gpio_config)\r\n{\r\nint rc, i;\r\nif (gpio_start < 0 || num_gpios < 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_gpios; i++) {\r\nrc = pm8xxx_gpio_config(gpio_start + i, gpio_config);\r\nif (rc) {\r\ndev_err(kp->dev, "%s: FAIL pm8xxx_gpio_config():"\r\n"for PM GPIO [%d] rc=%d.\n",\r\n__func__, gpio_start + i, rc);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmic8xxx_kp_enable(struct pmic8xxx_kp *kp)\r\n{\r\nint rc;\r\nkp->ctrl_reg |= KEYP_CTRL_KEYP_EN;\r\nrc = pmic8xxx_kp_write_u8(kp, kp->ctrl_reg, KEYP_CTRL);\r\nif (rc < 0)\r\ndev_err(kp->dev, "Error writing KEYP_CTRL reg, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_disable(struct pmic8xxx_kp *kp)\r\n{\r\nint rc;\r\nkp->ctrl_reg &= ~KEYP_CTRL_KEYP_EN;\r\nrc = pmic8xxx_kp_write_u8(kp, kp->ctrl_reg, KEYP_CTRL);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn rc;\r\n}\r\nstatic int pmic8xxx_kp_open(struct input_dev *dev)\r\n{\r\nstruct pmic8xxx_kp *kp = input_get_drvdata(dev);\r\nreturn pmic8xxx_kp_enable(kp);\r\n}\r\nstatic void pmic8xxx_kp_close(struct input_dev *dev)\r\n{\r\nstruct pmic8xxx_kp *kp = input_get_drvdata(dev);\r\npmic8xxx_kp_disable(kp);\r\n}\r\nstatic int __devinit pmic8xxx_kp_probe(struct platform_device *pdev)\r\n{\r\nconst struct pm8xxx_keypad_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nconst struct matrix_keymap_data *keymap_data;\r\nstruct pmic8xxx_kp *kp;\r\nint rc;\r\nu8 ctrl_val;\r\nstruct pm_gpio kypd_drv = {\r\n.direction = PM_GPIO_DIR_OUT,\r\n.output_buffer = PM_GPIO_OUT_BUF_OPEN_DRAIN,\r\n.output_value = 0,\r\n.pull = PM_GPIO_PULL_NO,\r\n.vin_sel = PM_GPIO_VIN_S3,\r\n.out_strength = PM_GPIO_STRENGTH_LOW,\r\n.function = PM_GPIO_FUNC_1,\r\n.inv_int_pol = 1,\r\n};\r\nstruct pm_gpio kypd_sns = {\r\n.direction = PM_GPIO_DIR_IN,\r\n.pull = PM_GPIO_PULL_UP_31P5,\r\n.vin_sel = PM_GPIO_VIN_S3,\r\n.out_strength = PM_GPIO_STRENGTH_NO,\r\n.function = PM_GPIO_FUNC_NORMAL,\r\n.inv_int_pol = 1,\r\n};\r\nif (!pdata || !pdata->num_cols || !pdata->num_rows ||\r\npdata->num_cols > PM8XXX_MAX_COLS ||\r\npdata->num_rows > PM8XXX_MAX_ROWS ||\r\npdata->num_cols < PM8XXX_MIN_COLS) {\r\ndev_err(&pdev->dev, "invalid platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->scan_delay_ms ||\r\npdata->scan_delay_ms > MAX_SCAN_DELAY ||\r\npdata->scan_delay_ms < MIN_SCAN_DELAY ||\r\n!is_power_of_2(pdata->scan_delay_ms)) {\r\ndev_err(&pdev->dev, "invalid keypad scan time supplied\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->row_hold_ns ||\r\npdata->row_hold_ns > MAX_ROW_HOLD_DELAY ||\r\npdata->row_hold_ns < MIN_ROW_HOLD_DELAY ||\r\n((pdata->row_hold_ns % MIN_ROW_HOLD_DELAY) != 0)) {\r\ndev_err(&pdev->dev, "invalid keypad row hold time supplied\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->debounce_ms ||\r\n((pdata->debounce_ms % 5) != 0) ||\r\npdata->debounce_ms > MAX_DEBOUNCE_TIME ||\r\npdata->debounce_ms < MIN_DEBOUNCE_TIME) {\r\ndev_err(&pdev->dev, "invalid debounce time supplied\n");\r\nreturn -EINVAL;\r\n}\r\nkeymap_data = pdata->keymap_data;\r\nif (!keymap_data) {\r\ndev_err(&pdev->dev, "no keymap data supplied\n");\r\nreturn -EINVAL;\r\n}\r\nkp = kzalloc(sizeof(*kp), GFP_KERNEL);\r\nif (!kp)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, kp);\r\nkp->pdata = pdata;\r\nkp->dev = &pdev->dev;\r\nkp->input = input_allocate_device();\r\nif (!kp->input) {\r\ndev_err(&pdev->dev, "unable to allocate input device\n");\r\nrc = -ENOMEM;\r\ngoto err_alloc_device;\r\n}\r\nkp->key_sense_irq = platform_get_irq(pdev, 0);\r\nif (kp->key_sense_irq < 0) {\r\ndev_err(&pdev->dev, "unable to get keypad sense irq\n");\r\nrc = -ENXIO;\r\ngoto err_get_irq;\r\n}\r\nkp->key_stuck_irq = platform_get_irq(pdev, 1);\r\nif (kp->key_stuck_irq < 0) {\r\ndev_err(&pdev->dev, "unable to get keypad stuck irq\n");\r\nrc = -ENXIO;\r\ngoto err_get_irq;\r\n}\r\nkp->input->name = pdata->input_name ? : "PMIC8XXX keypad";\r\nkp->input->phys = pdata->input_phys_device ? : "pmic8xxx_keypad/input0";\r\nkp->input->dev.parent = &pdev->dev;\r\nkp->input->id.bustype = BUS_I2C;\r\nkp->input->id.version = 0x0001;\r\nkp->input->id.product = 0x0001;\r\nkp->input->id.vendor = 0x0001;\r\nkp->input->evbit[0] = BIT_MASK(EV_KEY);\r\nif (pdata->rep)\r\n__set_bit(EV_REP, kp->input->evbit);\r\nkp->input->keycode = kp->keycodes;\r\nkp->input->keycodemax = PM8XXX_MATRIX_MAX_SIZE;\r\nkp->input->keycodesize = sizeof(kp->keycodes);\r\nkp->input->open = pmic8xxx_kp_open;\r\nkp->input->close = pmic8xxx_kp_close;\r\nmatrix_keypad_build_keymap(keymap_data, PM8XXX_ROW_SHIFT,\r\nkp->input->keycode, kp->input->keybit);\r\ninput_set_capability(kp->input, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(kp->input, kp);\r\nmemset(kp->keystate, 0xff, sizeof(kp->keystate));\r\nmemset(kp->stuckstate, 0xff, sizeof(kp->stuckstate));\r\nrc = pmic8xxx_kpd_init(kp);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "unable to initialize keypad controller\n");\r\ngoto err_get_irq;\r\n}\r\nrc = pmic8xxx_kp_config_gpio(pdata->cols_gpio_start,\r\npdata->num_cols, kp, &kypd_sns);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "unable to configure keypad sense lines\n");\r\ngoto err_gpio_config;\r\n}\r\nrc = pmic8xxx_kp_config_gpio(pdata->rows_gpio_start,\r\npdata->num_rows, kp, &kypd_drv);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "unable to configure keypad drive lines\n");\r\ngoto err_gpio_config;\r\n}\r\nrc = request_any_context_irq(kp->key_sense_irq, pmic8xxx_kp_irq,\r\nIRQF_TRIGGER_RISING, "pmic-keypad", kp);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to request keypad sense irq\n");\r\ngoto err_get_irq;\r\n}\r\nrc = request_any_context_irq(kp->key_stuck_irq, pmic8xxx_kp_stuck_irq,\r\nIRQF_TRIGGER_RISING, "pmic-keypad-stuck", kp);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to request keypad stuck irq\n");\r\ngoto err_req_stuck_irq;\r\n}\r\nrc = pmic8xxx_kp_read_u8(kp, &ctrl_val, KEYP_CTRL);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to read KEYP_CTRL register\n");\r\ngoto err_pmic_reg_read;\r\n}\r\nkp->ctrl_reg = ctrl_val;\r\nrc = input_register_device(kp->input);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "unable to register keypad input device\n");\r\ngoto err_pmic_reg_read;\r\n}\r\ndevice_init_wakeup(&pdev->dev, pdata->wakeup);\r\nreturn 0;\r\nerr_pmic_reg_read:\r\nfree_irq(kp->key_stuck_irq, kp);\r\nerr_req_stuck_irq:\r\nfree_irq(kp->key_sense_irq, kp);\r\nerr_gpio_config:\r\nerr_get_irq:\r\ninput_free_device(kp->input);\r\nerr_alloc_device:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(kp);\r\nreturn rc;\r\n}\r\nstatic int __devexit pmic8xxx_kp_remove(struct platform_device *pdev)\r\n{\r\nstruct pmic8xxx_kp *kp = platform_get_drvdata(pdev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nfree_irq(kp->key_stuck_irq, kp);\r\nfree_irq(kp->key_sense_irq, kp);\r\ninput_unregister_device(kp->input);\r\nkfree(kp);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int pmic8xxx_kp_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pmic8xxx_kp *kp = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kp->input;\r\nif (device_may_wakeup(dev)) {\r\nenable_irq_wake(kp->key_sense_irq);\r\n} else {\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\npmic8xxx_kp_disable(kp);\r\nmutex_unlock(&input_dev->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmic8xxx_kp_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pmic8xxx_kp *kp = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kp->input;\r\nif (device_may_wakeup(dev)) {\r\ndisable_irq_wake(kp->key_sense_irq);\r\n} else {\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\npmic8xxx_kp_enable(kp);\r\nmutex_unlock(&input_dev->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pmic8xxx_kp_init(void)\r\n{\r\nreturn platform_driver_register(&pmic8xxx_kp_driver);\r\n}\r\nstatic void __exit pmic8xxx_kp_exit(void)\r\n{\r\nplatform_driver_unregister(&pmic8xxx_kp_driver);\r\n}
