static inline void rt2500usb_register_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nu16 *value)\r\n{\r\n__le16 reg;\r\nrt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_READ,\r\nUSB_VENDOR_REQUEST_IN, offset,\r\n&reg, sizeof(reg), REGISTER_TIMEOUT);\r\n*value = le16_to_cpu(reg);\r\n}\r\nstatic inline void rt2500usb_register_read_lock(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nu16 *value)\r\n{\r\n__le16 reg;\r\nrt2x00usb_vendor_req_buff_lock(rt2x00dev, USB_MULTI_READ,\r\nUSB_VENDOR_REQUEST_IN, offset,\r\n&reg, sizeof(reg), REGISTER_TIMEOUT);\r\n*value = le16_to_cpu(reg);\r\n}\r\nstatic inline void rt2500usb_register_multiread(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nvoid *value, const u16 length)\r\n{\r\nrt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_READ,\r\nUSB_VENDOR_REQUEST_IN, offset,\r\nvalue, length,\r\nREGISTER_TIMEOUT16(length));\r\n}\r\nstatic inline void rt2500usb_register_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nu16 value)\r\n{\r\n__le16 reg = cpu_to_le16(value);\r\nrt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_WRITE,\r\nUSB_VENDOR_REQUEST_OUT, offset,\r\n&reg, sizeof(reg), REGISTER_TIMEOUT);\r\n}\r\nstatic inline void rt2500usb_register_write_lock(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nu16 value)\r\n{\r\n__le16 reg = cpu_to_le16(value);\r\nrt2x00usb_vendor_req_buff_lock(rt2x00dev, USB_MULTI_WRITE,\r\nUSB_VENDOR_REQUEST_OUT, offset,\r\n&reg, sizeof(reg), REGISTER_TIMEOUT);\r\n}\r\nstatic inline void rt2500usb_register_multiwrite(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nvoid *value, const u16 length)\r\n{\r\nrt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_WRITE,\r\nUSB_VENDOR_REQUEST_OUT, offset,\r\nvalue, length,\r\nREGISTER_TIMEOUT16(length));\r\n}\r\nstatic int rt2500usb_regbusy_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nstruct rt2x00_field16 field,\r\nu16 *reg)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2500usb_register_read_lock(rt2x00dev, offset, reg);\r\nif (!rt2x00_get_field16(*reg, field))\r\nreturn 1;\r\nudelay(REGISTER_BUSY_DELAY);\r\n}\r\nERROR(rt2x00dev, "Indirect register access failed: "\r\n"offset=0x%.08x, value=0x%.08x\n", offset, *reg);\r\n*reg = ~0;\r\nreturn 0;\r\n}\r\nstatic void rt2500usb_bbp_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, const u8 value)\r\n{\r\nu16 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field16(&reg, PHY_CSR7_DATA, value);\r\nrt2x00_set_field16(&reg, PHY_CSR7_REG_ID, word);\r\nrt2x00_set_field16(&reg, PHY_CSR7_READ_CONTROL, 0);\r\nrt2500usb_register_write_lock(rt2x00dev, PHY_CSR7, reg);\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt2500usb_bbp_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, u8 *value)\r\n{\r\nu16 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field16(&reg, PHY_CSR7_REG_ID, word);\r\nrt2x00_set_field16(&reg, PHY_CSR7_READ_CONTROL, 1);\r\nrt2500usb_register_write_lock(rt2x00dev, PHY_CSR7, reg);\r\nif (WAIT_FOR_BBP(rt2x00dev, &reg))\r\nrt2500usb_register_read_lock(rt2x00dev, PHY_CSR7, &reg);\r\n}\r\n*value = rt2x00_get_field16(reg, PHY_CSR7_DATA);\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt2500usb_rf_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, const u32 value)\r\n{\r\nu16 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_RF(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field16(&reg, PHY_CSR9_RF_VALUE, value);\r\nrt2500usb_register_write_lock(rt2x00dev, PHY_CSR9, reg);\r\nreg = 0;\r\nrt2x00_set_field16(&reg, PHY_CSR10_RF_VALUE, value >> 16);\r\nrt2x00_set_field16(&reg, PHY_CSR10_RF_NUMBER_OF_BITS, 20);\r\nrt2x00_set_field16(&reg, PHY_CSR10_RF_IF_SELECT, 0);\r\nrt2x00_set_field16(&reg, PHY_CSR10_RF_BUSY, 1);\r\nrt2500usb_register_write_lock(rt2x00dev, PHY_CSR10, reg);\r\nrt2x00_rf_write(rt2x00dev, word, value);\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void _rt2500usb_register_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nu32 *value)\r\n{\r\nrt2500usb_register_read(rt2x00dev, offset, (u16 *)value);\r\n}\r\nstatic void _rt2500usb_register_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nu32 value)\r\n{\r\nrt2500usb_register_write(rt2x00dev, offset, value);\r\n}\r\nstatic int rt2500usb_rfkill_poll(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu16 reg;\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR19, &reg);\r\nreturn rt2x00_get_field32(reg, MAC_CSR19_BIT7);\r\n}\r\nstatic void rt2500usb_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct rt2x00_led *led =\r\ncontainer_of(led_cdev, struct rt2x00_led, led_dev);\r\nunsigned int enabled = brightness != LED_OFF;\r\nu16 reg;\r\nrt2500usb_register_read(led->rt2x00dev, MAC_CSR20, &reg);\r\nif (led->type == LED_TYPE_RADIO || led->type == LED_TYPE_ASSOC)\r\nrt2x00_set_field16(&reg, MAC_CSR20_LINK, enabled);\r\nelse if (led->type == LED_TYPE_ACTIVITY)\r\nrt2x00_set_field16(&reg, MAC_CSR20_ACTIVITY, enabled);\r\nrt2500usb_register_write(led->rt2x00dev, MAC_CSR20, reg);\r\n}\r\nstatic int rt2500usb_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct rt2x00_led *led =\r\ncontainer_of(led_cdev, struct rt2x00_led, led_dev);\r\nu16 reg;\r\nrt2500usb_register_read(led->rt2x00dev, MAC_CSR21, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR21_ON_PERIOD, *delay_on);\r\nrt2x00_set_field16(&reg, MAC_CSR21_OFF_PERIOD, *delay_off);\r\nrt2500usb_register_write(led->rt2x00dev, MAC_CSR21, reg);\r\nreturn 0;\r\n}\r\nstatic void rt2500usb_init_led(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_led *led,\r\nenum led_type type)\r\n{\r\nled->rt2x00dev = rt2x00dev;\r\nled->type = type;\r\nled->led_dev.brightness_set = rt2500usb_brightness_set;\r\nled->led_dev.blink_set = rt2500usb_blink_set;\r\nled->flags = LED_INITIALIZED;\r\n}\r\nstatic int rt2500usb_config_key(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_crypto *crypto,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nu32 mask;\r\nu16 reg;\r\nenum cipher curr_cipher;\r\nif (crypto->cmd == SET_KEY) {\r\nif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkey->cipher == WLAN_CIPHER_SUITE_WEP104) &&\r\nkey->keyidx != 0)\r\nreturn -EOPNOTSUPP;\r\nmask = TXRX_CSR0_KEY_ID.bit_mask;\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\ncurr_cipher = rt2x00_get_field16(reg, TXRX_CSR0_ALGORITHM);\r\nreg &= mask;\r\nif (reg && reg == mask)\r\nreturn -ENOSPC;\r\nreg = rt2x00_get_field16(reg, TXRX_CSR0_KEY_ID);\r\nkey->hw_key_idx += reg ? ffz(reg) : 0;\r\nif (key->hw_key_idx > 0 && crypto->cipher != curr_cipher)\r\nreturn -EOPNOTSUPP;\r\nrt2500usb_register_multiwrite(rt2x00dev, KEY_ENTRY(key->hw_key_idx),\r\ncrypto->key, sizeof(crypto->key));\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\r\n}\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR0_ALGORITHM, crypto->cipher);\r\nrt2x00_set_field16(&reg, TXRX_CSR0_IV_OFFSET, IEEE80211_HEADER);\r\nmask = rt2x00_get_field16(reg, TXRX_CSR0_KEY_ID);\r\nif (crypto->cmd == SET_KEY)\r\nmask |= 1 << key->hw_key_idx;\r\nelse if (crypto->cmd == DISABLE_KEY)\r\nmask &= ~(1 << key->hw_key_idx);\r\nrt2x00_set_field16(&reg, TXRX_CSR0_KEY_ID, mask);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR0, reg);\r\nreturn 0;\r\n}\r\nstatic void rt2500usb_config_filter(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int filter_flags)\r\n{\r\nu16 reg;\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_CRC,\r\n!(filter_flags & FIF_FCSFAIL));\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_PHYSICAL,\r\n!(filter_flags & FIF_PLCPFAIL));\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_CONTROL,\r\n!(filter_flags & FIF_CONTROL));\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_NOT_TO_ME,\r\n!(filter_flags & FIF_PROMISC_IN_BSS));\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_TODS,\r\n!(filter_flags & FIF_PROMISC_IN_BSS) &&\r\n!rt2x00dev->intf_ap_count);\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_VERSION_ERROR, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_MULTICAST,\r\n!(filter_flags & FIF_ALLMULTI));\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DROP_BROADCAST, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\r\n}\r\nstatic void rt2500usb_config_intf(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_intf *intf,\r\nstruct rt2x00intf_conf *conf,\r\nconst unsigned int flags)\r\n{\r\nunsigned int bcn_preload;\r\nu16 reg;\r\nif (flags & CONFIG_UPDATE_TYPE) {\r\nbcn_preload = PREAMBLE + GET_DURATION(IEEE80211_HEADER, 20);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR20, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR20_OFFSET, bcn_preload >> 6);\r\nrt2x00_set_field16(&reg, TXRX_CSR20_BCN_EXPECT_WINDOW,\r\n2 * (conf->type != NL80211_IFTYPE_STATION));\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR20, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR18, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR18_OFFSET, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR18, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR19, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TSF_SYNC, conf->sync);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\n}\r\nif (flags & CONFIG_UPDATE_MAC)\r\nrt2500usb_register_multiwrite(rt2x00dev, MAC_CSR2, conf->mac,\r\n(3 * sizeof(__le16)));\r\nif (flags & CONFIG_UPDATE_BSSID)\r\nrt2500usb_register_multiwrite(rt2x00dev, MAC_CSR5, conf->bssid,\r\n(3 * sizeof(__le16)));\r\n}\r\nstatic void rt2500usb_config_erp(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_erp *erp,\r\nu32 changed)\r\n{\r\nu16 reg;\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR10, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR10_AUTORESPOND_PREAMBLE,\r\n!!erp->short_preamble);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR10, reg);\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES)\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR11,\r\nerp->basic_rates);\r\nif (changed & BSS_CHANGED_BEACON_INT) {\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR18, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR18_INTERVAL,\r\nerp->beacon_int * 4);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR18, reg);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR10, erp->slot_time);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR11, erp->sifs);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR12, erp->eifs);\r\n}\r\n}\r\nstatic void rt2500usb_config_ant(struct rt2x00_dev *rt2x00dev,\r\nstruct antenna_setup *ant)\r\n{\r\nu8 r2;\r\nu8 r14;\r\nu16 csr5;\r\nu16 csr6;\r\nBUG_ON(ant->rx == ANTENNA_SW_DIVERSITY ||\r\nant->tx == ANTENNA_SW_DIVERSITY);\r\nrt2500usb_bbp_read(rt2x00dev, 2, &r2);\r\nrt2500usb_bbp_read(rt2x00dev, 14, &r14);\r\nrt2500usb_register_read(rt2x00dev, PHY_CSR5, &csr5);\r\nrt2500usb_register_read(rt2x00dev, PHY_CSR6, &csr6);\r\nswitch (ant->tx) {\r\ncase ANTENNA_HW_DIVERSITY:\r\nrt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 1);\r\nrt2x00_set_field16(&csr5, PHY_CSR5_CCK, 1);\r\nrt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 1);\r\nbreak;\r\ncase ANTENNA_A:\r\nrt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 0);\r\nrt2x00_set_field16(&csr5, PHY_CSR5_CCK, 0);\r\nrt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 0);\r\nbreak;\r\ncase ANTENNA_B:\r\ndefault:\r\nrt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 2);\r\nrt2x00_set_field16(&csr5, PHY_CSR5_CCK, 2);\r\nrt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 2);\r\nbreak;\r\n}\r\nswitch (ant->rx) {\r\ncase ANTENNA_HW_DIVERSITY:\r\nrt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 1);\r\nbreak;\r\ncase ANTENNA_A:\r\nrt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 0);\r\nbreak;\r\ncase ANTENNA_B:\r\ndefault:\r\nrt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 2);\r\nbreak;\r\n}\r\nif (rt2x00_rf(rt2x00dev, RF2525E) || rt2x00_rf(rt2x00dev, RF5222)) {\r\nrt2x00_set_field8(&r2, BBP_R2_TX_IQ_FLIP, 1);\r\nrt2x00_set_field16(&csr5, PHY_CSR5_CCK_FLIP, 1);\r\nrt2x00_set_field16(&csr6, PHY_CSR6_OFDM_FLIP, 1);\r\nif (rt2x00_rf(rt2x00dev, RF2525E))\r\nrt2x00_set_field8(&r14, BBP_R14_RX_IQ_FLIP, 0);\r\n} else {\r\nrt2x00_set_field16(&csr5, PHY_CSR5_CCK_FLIP, 0);\r\nrt2x00_set_field16(&csr6, PHY_CSR6_OFDM_FLIP, 0);\r\n}\r\nrt2500usb_bbp_write(rt2x00dev, 2, r2);\r\nrt2500usb_bbp_write(rt2x00dev, 14, r14);\r\nrt2500usb_register_write(rt2x00dev, PHY_CSR5, csr5);\r\nrt2500usb_register_write(rt2x00dev, PHY_CSR6, csr6);\r\n}\r\nstatic void rt2500usb_config_channel(struct rt2x00_dev *rt2x00dev,\r\nstruct rf_channel *rf, const int txpower)\r\n{\r\nrt2x00_set_field32(&rf->rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\r\nif (rt2x00_rf(rt2x00dev, RF2525E)) {\r\nstatic const u32 vals[] = {\r\n0x000008aa, 0x000008ae, 0x000008ae, 0x000008b2,\r\n0x000008b2, 0x000008b6, 0x000008b6, 0x000008ba,\r\n0x000008ba, 0x000008be, 0x000008b7, 0x00000902,\r\n0x00000902, 0x00000906\r\n};\r\nrt2500usb_rf_write(rt2x00dev, 2, vals[rf->channel - 1]);\r\nif (rf->rf4)\r\nrt2500usb_rf_write(rt2x00dev, 4, rf->rf4);\r\n}\r\nrt2500usb_rf_write(rt2x00dev, 1, rf->rf1);\r\nrt2500usb_rf_write(rt2x00dev, 2, rf->rf2);\r\nrt2500usb_rf_write(rt2x00dev, 3, rf->rf3);\r\nif (rf->rf4)\r\nrt2500usb_rf_write(rt2x00dev, 4, rf->rf4);\r\n}\r\nstatic void rt2500usb_config_txpower(struct rt2x00_dev *rt2x00dev,\r\nconst int txpower)\r\n{\r\nu32 rf3;\r\nrt2x00_rf_read(rt2x00dev, 3, &rf3);\r\nrt2x00_set_field32(&rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\r\nrt2500usb_rf_write(rt2x00dev, 3, rf3);\r\n}\r\nstatic void rt2500usb_config_ps(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf)\r\n{\r\nenum dev_state state =\r\n(libconf->conf->flags & IEEE80211_CONF_PS) ?\r\nSTATE_SLEEP : STATE_AWAKE;\r\nu16 reg;\r\nif (state == STATE_SLEEP) {\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR18, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR18_DELAY_AFTER_BEACON,\r\nrt2x00dev->beacon_int - 20);\r\nrt2x00_set_field16(&reg, MAC_CSR18_BEACONS_BEFORE_WAKEUP,\r\nlibconf->conf->listen_interval - 1);\r\nrt2x00_set_field16(&reg, MAC_CSR18_AUTO_WAKE, 0);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\r\nrt2x00_set_field16(&reg, MAC_CSR18_AUTO_WAKE, 1);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\r\n} else {\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR18, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR18_AUTO_WAKE, 0);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\r\n}\r\nrt2x00dev->ops->lib->set_device_state(rt2x00dev, state);\r\n}\r\nstatic void rt2500usb_config(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf,\r\nconst unsigned int flags)\r\n{\r\nif (flags & IEEE80211_CONF_CHANGE_CHANNEL)\r\nrt2500usb_config_channel(rt2x00dev, &libconf->rf,\r\nlibconf->conf->power_level);\r\nif ((flags & IEEE80211_CONF_CHANGE_POWER) &&\r\n!(flags & IEEE80211_CONF_CHANGE_CHANNEL))\r\nrt2500usb_config_txpower(rt2x00dev,\r\nlibconf->conf->power_level);\r\nif (flags & IEEE80211_CONF_CHANGE_PS)\r\nrt2500usb_config_ps(rt2x00dev, libconf);\r\n}\r\nstatic void rt2500usb_link_stats(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual)\r\n{\r\nu16 reg;\r\nrt2500usb_register_read(rt2x00dev, STA_CSR0, &reg);\r\nqual->rx_failed = rt2x00_get_field16(reg, STA_CSR0_FCS_ERROR);\r\nrt2500usb_register_read(rt2x00dev, STA_CSR3, &reg);\r\nqual->false_cca = rt2x00_get_field16(reg, STA_CSR3_FALSE_CCA_ERROR);\r\n}\r\nstatic void rt2500usb_reset_tuner(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual)\r\n{\r\nu16 eeprom;\r\nu16 value;\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R24, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R24_LOW);\r\nrt2500usb_bbp_write(rt2x00dev, 24, value);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R25, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R25_LOW);\r\nrt2500usb_bbp_write(rt2x00dev, 25, value);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R61, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R61_LOW);\r\nrt2500usb_bbp_write(rt2x00dev, 61, value);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_VGC, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_VGCUPPER);\r\nrt2500usb_bbp_write(rt2x00dev, 17, value);\r\nqual->vgc_level = value;\r\n}\r\nstatic void rt2500usb_start_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu16 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR19, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void rt2500usb_stop_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu16 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR19, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 0);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 0);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int rt2500usb_init_registers(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu16 reg;\r\nrt2x00usb_vendor_request_sw(rt2x00dev, USB_DEVICE_MODE, 0x0001,\r\nUSB_MODE_TEST, REGISTER_TIMEOUT);\r\nrt2x00usb_vendor_request_sw(rt2x00dev, USB_SINGLE_WRITE, 0x0308,\r\n0x00f0, REGISTER_TIMEOUT);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR13, 0x1111);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR14, 0x1e11);\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR1_SOFT_RESET, 1);\r\nrt2x00_set_field16(&reg, MAC_CSR1_BBP_RESET, 1);\r\nrt2x00_set_field16(&reg, MAC_CSR1_HOST_READY, 0);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR1, reg);\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR1_SOFT_RESET, 0);\r\nrt2x00_set_field16(&reg, MAC_CSR1_BBP_RESET, 0);\r\nrt2x00_set_field16(&reg, MAC_CSR1_HOST_READY, 0);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR1, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR5, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID0, 13);\r\nrt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID0_VALID, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID1, 12);\r\nrt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID1_VALID, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR5, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR6, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID0, 10);\r\nrt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID0_VALID, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID1, 11);\r\nrt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID1_VALID, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR6, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR7, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID0, 7);\r\nrt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID0_VALID, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID1, 6);\r\nrt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID1_VALID, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR7, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR8, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID0, 5);\r\nrt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID0_VALID, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID1, 0);\r\nrt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID1_VALID, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR8, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR19, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 0);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TSF_SYNC, 0);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 0);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR21, 0xe78f);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR9, 0xff1d);\r\nif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\r\nreturn -EBUSY;\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR1_SOFT_RESET, 0);\r\nrt2x00_set_field16(&reg, MAC_CSR1_BBP_RESET, 0);\r\nrt2x00_set_field16(&reg, MAC_CSR1_HOST_READY, 1);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR1, reg);\r\nif (rt2x00_rev(rt2x00dev) >= RT2570_VERSION_C) {\r\nrt2500usb_register_read(rt2x00dev, PHY_CSR2, &reg);\r\nrt2x00_set_field16(&reg, PHY_CSR2_LNA, 0);\r\n} else {\r\nreg = 0;\r\nrt2x00_set_field16(&reg, PHY_CSR2_LNA, 1);\r\nrt2x00_set_field16(&reg, PHY_CSR2_LNA_MODE, 3);\r\n}\r\nrt2500usb_register_write(rt2x00dev, PHY_CSR2, reg);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR11, 0x0002);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR22, 0x0053);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR15, 0x01ee);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR16, 0x0000);\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR8, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR8_MAX_FRAME_UNIT,\r\nrt2x00dev->rx->data_size);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR8, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR0_ALGORITHM, CIPHER_NONE);\r\nrt2x00_set_field16(&reg, TXRX_CSR0_IV_OFFSET, IEEE80211_HEADER);\r\nrt2x00_set_field16(&reg, TXRX_CSR0_KEY_ID, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR0, reg);\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR18, &reg);\r\nrt2x00_set_field16(&reg, MAC_CSR18_DELAY_AFTER_BEACON, 90);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\r\nrt2500usb_register_read(rt2x00dev, PHY_CSR4, &reg);\r\nrt2x00_set_field16(&reg, PHY_CSR4_LOW_RF_LE, 1);\r\nrt2500usb_register_write(rt2x00dev, PHY_CSR4, reg);\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR1, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR1_AUTO_SEQUENCE, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR1, reg);\r\nreturn 0;\r\n}\r\nstatic int rt2500usb_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)\r\n{\r\nunsigned int i;\r\nu8 value;\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2500usb_bbp_read(rt2x00dev, 0, &value);\r\nif ((value != 0xff) && (value != 0x00))\r\nreturn 0;\r\nudelay(REGISTER_BUSY_DELAY);\r\n}\r\nERROR(rt2x00dev, "BBP register access failed, aborting.\n");\r\nreturn -EACCES;\r\n}\r\nstatic int rt2500usb_init_bbp(struct rt2x00_dev *rt2x00dev)\r\n{\r\nunsigned int i;\r\nu16 eeprom;\r\nu8 value;\r\nu8 reg_id;\r\nif (unlikely(rt2500usb_wait_bbp_ready(rt2x00dev)))\r\nreturn -EACCES;\r\nrt2500usb_bbp_write(rt2x00dev, 3, 0x02);\r\nrt2500usb_bbp_write(rt2x00dev, 4, 0x19);\r\nrt2500usb_bbp_write(rt2x00dev, 14, 0x1c);\r\nrt2500usb_bbp_write(rt2x00dev, 15, 0x30);\r\nrt2500usb_bbp_write(rt2x00dev, 16, 0xac);\r\nrt2500usb_bbp_write(rt2x00dev, 18, 0x18);\r\nrt2500usb_bbp_write(rt2x00dev, 19, 0xff);\r\nrt2500usb_bbp_write(rt2x00dev, 20, 0x1e);\r\nrt2500usb_bbp_write(rt2x00dev, 21, 0x08);\r\nrt2500usb_bbp_write(rt2x00dev, 22, 0x08);\r\nrt2500usb_bbp_write(rt2x00dev, 23, 0x08);\r\nrt2500usb_bbp_write(rt2x00dev, 24, 0x80);\r\nrt2500usb_bbp_write(rt2x00dev, 25, 0x50);\r\nrt2500usb_bbp_write(rt2x00dev, 26, 0x08);\r\nrt2500usb_bbp_write(rt2x00dev, 27, 0x23);\r\nrt2500usb_bbp_write(rt2x00dev, 30, 0x10);\r\nrt2500usb_bbp_write(rt2x00dev, 31, 0x2b);\r\nrt2500usb_bbp_write(rt2x00dev, 32, 0xb9);\r\nrt2500usb_bbp_write(rt2x00dev, 34, 0x12);\r\nrt2500usb_bbp_write(rt2x00dev, 35, 0x50);\r\nrt2500usb_bbp_write(rt2x00dev, 39, 0xc4);\r\nrt2500usb_bbp_write(rt2x00dev, 40, 0x02);\r\nrt2500usb_bbp_write(rt2x00dev, 41, 0x60);\r\nrt2500usb_bbp_write(rt2x00dev, 53, 0x10);\r\nrt2500usb_bbp_write(rt2x00dev, 54, 0x18);\r\nrt2500usb_bbp_write(rt2x00dev, 56, 0x08);\r\nrt2500usb_bbp_write(rt2x00dev, 57, 0x10);\r\nrt2500usb_bbp_write(rt2x00dev, 58, 0x08);\r\nrt2500usb_bbp_write(rt2x00dev, 61, 0x60);\r\nrt2500usb_bbp_write(rt2x00dev, 62, 0x10);\r\nrt2500usb_bbp_write(rt2x00dev, 75, 0xff);\r\nfor (i = 0; i < EEPROM_BBP_SIZE; i++) {\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBP_START + i, &eeprom);\r\nif (eeprom != 0xffff && eeprom != 0x0000) {\r\nreg_id = rt2x00_get_field16(eeprom, EEPROM_BBP_REG_ID);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);\r\nrt2500usb_bbp_write(rt2x00dev, reg_id, value);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt2500usb_enable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (unlikely(rt2500usb_init_registers(rt2x00dev) ||\r\nrt2500usb_init_bbp(rt2x00dev)))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void rt2500usb_disable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR13, 0x2121);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR14, 0x2121);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, 0);\r\nrt2x00usb_disable_radio(rt2x00dev);\r\n}\r\nstatic int rt2500usb_set_state(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nu16 reg;\r\nu16 reg2;\r\nunsigned int i;\r\nchar put_to_sleep;\r\nchar bbp_state;\r\nchar rf_state;\r\nput_to_sleep = (state != STATE_AWAKE);\r\nreg = 0;\r\nrt2x00_set_field16(&reg, MAC_CSR17_BBP_DESIRE_STATE, state);\r\nrt2x00_set_field16(&reg, MAC_CSR17_RF_DESIRE_STATE, state);\r\nrt2x00_set_field16(&reg, MAC_CSR17_PUT_TO_SLEEP, put_to_sleep);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);\r\nrt2x00_set_field16(&reg, MAC_CSR17_SET_STATE, 1);\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR17, &reg2);\r\nbbp_state = rt2x00_get_field16(reg2, MAC_CSR17_BBP_CURR_STATE);\r\nrf_state = rt2x00_get_field16(reg2, MAC_CSR17_RF_CURR_STATE);\r\nif (bbp_state == state && rf_state == state)\r\nreturn 0;\r\nrt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);\r\nmsleep(30);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int rt2500usb_set_device_state(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nint retval = 0;\r\nswitch (state) {\r\ncase STATE_RADIO_ON:\r\nretval = rt2500usb_enable_radio(rt2x00dev);\r\nbreak;\r\ncase STATE_RADIO_OFF:\r\nrt2500usb_disable_radio(rt2x00dev);\r\nbreak;\r\ncase STATE_RADIO_IRQ_ON:\r\ncase STATE_RADIO_IRQ_OFF:\r\nbreak;\r\ncase STATE_DEEP_SLEEP:\r\ncase STATE_SLEEP:\r\ncase STATE_STANDBY:\r\ncase STATE_AWAKE:\r\nretval = rt2500usb_set_state(rt2x00dev, state);\r\nbreak;\r\ndefault:\r\nretval = -ENOTSUPP;\r\nbreak;\r\n}\r\nif (unlikely(retval))\r\nERROR(rt2x00dev, "Device failed to enter state %d (%d).\n",\r\nstate, retval);\r\nreturn retval;\r\n}\r\nstatic void rt2500usb_write_tx_desc(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\n__le32 *txd = (__le32 *) entry->skb->data;\r\nu32 word;\r\nrt2x00_desc_read(txd, 0, &word);\r\nrt2x00_set_field32(&word, TXD_W0_RETRY_LIMIT, txdesc->retry_limit);\r\nrt2x00_set_field32(&word, TXD_W0_MORE_FRAG,\r\ntest_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_ACK,\r\ntest_bit(ENTRY_TXD_ACK, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_TIMESTAMP,\r\ntest_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_OFDM,\r\n(txdesc->rate_mode == RATE_MODE_OFDM));\r\nrt2x00_set_field32(&word, TXD_W0_NEW_SEQ,\r\ntest_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_IFS, txdesc->u.plcp.ifs);\r\nrt2x00_set_field32(&word, TXD_W0_DATABYTE_COUNT, txdesc->length);\r\nrt2x00_set_field32(&word, TXD_W0_CIPHER, !!txdesc->cipher);\r\nrt2x00_set_field32(&word, TXD_W0_KEY_ID, txdesc->key_idx);\r\nrt2x00_desc_write(txd, 0, word);\r\nrt2x00_desc_read(txd, 1, &word);\r\nrt2x00_set_field32(&word, TXD_W1_IV_OFFSET, txdesc->iv_offset);\r\nrt2x00_set_field32(&word, TXD_W1_AIFS, entry->queue->aifs);\r\nrt2x00_set_field32(&word, TXD_W1_CWMIN, entry->queue->cw_min);\r\nrt2x00_set_field32(&word, TXD_W1_CWMAX, entry->queue->cw_max);\r\nrt2x00_desc_write(txd, 1, word);\r\nrt2x00_desc_read(txd, 2, &word);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_SIGNAL, txdesc->u.plcp.signal);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_SERVICE, txdesc->u.plcp.service);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_LOW,\r\ntxdesc->u.plcp.length_low);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_HIGH,\r\ntxdesc->u.plcp.length_high);\r\nrt2x00_desc_write(txd, 2, word);\r\nif (test_bit(ENTRY_TXD_ENCRYPT, &txdesc->flags)) {\r\n_rt2x00_desc_write(txd, 3, skbdesc->iv[0]);\r\n_rt2x00_desc_write(txd, 4, skbdesc->iv[1]);\r\n}\r\nskbdesc->flags |= SKBDESC_DESC_IN_SKB;\r\nskbdesc->desc = txd;\r\nskbdesc->desc_len = TXD_DESC_SIZE;\r\n}\r\nstatic void rt2500usb_write_beacon(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\r\nstruct queue_entry_priv_usb_bcn *bcn_priv = entry->priv_data;\r\nint pipe = usb_sndbulkpipe(usb_dev, entry->queue->usb_endpoint);\r\nint length;\r\nu16 reg, reg0;\r\nrt2500usb_register_read(rt2x00dev, TXRX_CSR19, &reg);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\nskb_push(entry->skb, TXD_DESC_SIZE);\r\nmemset(entry->skb->data, 0, TXD_DESC_SIZE);\r\nrt2500usb_write_tx_desc(entry, txdesc);\r\nrt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_BEACON, entry->skb);\r\nlength = rt2x00dev->ops->lib->get_tx_data_len(entry);\r\nusb_fill_bulk_urb(bcn_priv->urb, usb_dev, pipe,\r\nentry->skb->data, length, rt2500usb_beacondone,\r\nentry);\r\nbcn_priv->guardian_data = 0;\r\nusb_fill_bulk_urb(bcn_priv->guardian_urb, usb_dev, pipe,\r\n&bcn_priv->guardian_data, 1, rt2500usb_beacondone,\r\nentry);\r\nusb_submit_urb(bcn_priv->guardian_urb, GFP_ATOMIC);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 1);\r\nrt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 1);\r\nreg0 = reg;\r\nrt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 1);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg0);\r\nrt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\r\n}\r\nstatic int rt2500usb_get_tx_data_len(struct queue_entry *entry)\r\n{\r\nint length;\r\nlength = roundup(entry->skb->len, 2);\r\nlength += (2 * !(length % entry->queue->usb_maxpacket));\r\nreturn length;\r\n}\r\nstatic void rt2500usb_fill_rxdone(struct queue_entry *entry,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\n__le32 *rxd =\r\n(__le32 *)(entry->skb->data +\r\n(entry_priv->urb->actual_length -\r\nentry->queue->desc_size));\r\nu32 word0;\r\nu32 word1;\r\nmemcpy(skbdesc->desc, rxd, skbdesc->desc_len);\r\nrxd = (__le32 *)skbdesc->desc;\r\nrt2x00_desc_read(rxd, 0, &word0);\r\nrt2x00_desc_read(rxd, 1, &word1);\r\nif (rt2x00_get_field32(word0, RXD_W0_CRC_ERROR))\r\nrxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\r\nif (rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))\r\nrxdesc->flags |= RX_FLAG_FAILED_PLCP_CRC;\r\nrxdesc->cipher = rt2x00_get_field32(word0, RXD_W0_CIPHER);\r\nif (rt2x00_get_field32(word0, RXD_W0_CIPHER_ERROR))\r\nrxdesc->cipher_status = RX_CRYPTO_FAIL_KEY;\r\nif (rxdesc->cipher != CIPHER_NONE) {\r\n_rt2x00_desc_read(rxd, 2, &rxdesc->iv[0]);\r\n_rt2x00_desc_read(rxd, 3, &rxdesc->iv[1]);\r\nrxdesc->dev_flags |= RXDONE_CRYPTO_IV;\r\nrxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\r\nif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)\r\nrxdesc->flags |= RX_FLAG_DECRYPTED;\r\nelse if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)\r\nrxdesc->flags |= RX_FLAG_MMIC_ERROR;\r\n}\r\nrxdesc->signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);\r\nrxdesc->rssi =\r\nrt2x00_get_field32(word1, RXD_W1_RSSI) - rt2x00dev->rssi_offset;\r\nrxdesc->size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);\r\nif (rt2x00_get_field32(word0, RXD_W0_OFDM))\r\nrxdesc->dev_flags |= RXDONE_SIGNAL_PLCP;\r\nelse\r\nrxdesc->dev_flags |= RXDONE_SIGNAL_BITRATE;\r\nif (rt2x00_get_field32(word0, RXD_W0_MY_BSS))\r\nrxdesc->dev_flags |= RXDONE_MY_BSS;\r\nskb_trim(entry->skb, rxdesc->size);\r\n}\r\nstatic void rt2500usb_beacondone(struct urb *urb)\r\n{\r\nstruct queue_entry *entry = (struct queue_entry *)urb->context;\r\nstruct queue_entry_priv_usb_bcn *bcn_priv = entry->priv_data;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &entry->queue->rt2x00dev->flags))\r\nreturn;\r\nif (bcn_priv->guardian_urb == urb) {\r\nusb_submit_urb(bcn_priv->urb, GFP_ATOMIC);\r\n} else if (bcn_priv->urb == urb) {\r\ndev_kfree_skb(entry->skb);\r\nentry->skb = NULL;\r\n}\r\n}\r\nstatic int rt2500usb_validate_eeprom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu16 word;\r\nu8 *mac;\r\nu8 bbp;\r\nrt2x00usb_eeprom_read(rt2x00dev, rt2x00dev->eeprom, EEPROM_SIZE);\r\nmac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);\r\nif (!is_valid_ether_addr(mac)) {\r\nrandom_ether_addr(mac);\r\nEEPROM(rt2x00dev, "MAC: %pM\n", mac);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_TX_DEFAULT,\r\nANTENNA_SW_DIVERSITY);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_RX_DEFAULT,\r\nANTENNA_SW_DIVERSITY);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_LED_MODE,\r\nLED_MODE_DEFAULT);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_DYN_TXAGC, 0);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_HARDWARE_RADIO, 0);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_RF_TYPE, RF2522);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_ANTENNA, word);\r\nEEPROM(rt2x00dev, "Antenna: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_NIC, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_NIC_CARDBUS_ACCEL, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_DYN_BBP_TUNE, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_CCK_TX_POWER, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_NIC, word);\r\nEEPROM(rt2x00dev, "NIC: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_CALIBRATE_OFFSET_RSSI,\r\nDEFAULT_RSSI_OFFSET);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_CALIBRATE_OFFSET, word);\r\nEEPROM(rt2x00dev, "Calibrate offset: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_THRESHOLD, 45);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE, word);\r\nEEPROM(rt2x00dev, "BBPtune: 0x%04x\n", word);\r\n}\r\nrt2500usb_bbp_read(rt2x00dev, 17, &bbp);\r\nbbp -= 6;\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_VGC, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_VGCUPPER, 0x40);\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_VGCLOWER, bbp);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_VGC, word);\r\nEEPROM(rt2x00dev, "BBPtune vgc: 0x%04x\n", word);\r\n} else {\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_VGCLOWER, bbp);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_VGC, word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R17, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R17_LOW, 0x48);\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R17_HIGH, 0x41);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R17, word);\r\nEEPROM(rt2x00dev, "BBPtune r17: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R24, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R24_LOW, 0x40);\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R24_HIGH, 0x80);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R24, word);\r\nEEPROM(rt2x00dev, "BBPtune r24: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R25, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R25_LOW, 0x40);\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R25_HIGH, 0x50);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R25, word);\r\nEEPROM(rt2x00dev, "BBPtune r25: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R61, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R61_LOW, 0x60);\r\nrt2x00_set_field16(&word, EEPROM_BBPTUNE_R61_HIGH, 0x6d);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R61, word);\r\nEEPROM(rt2x00dev, "BBPtune r61: 0x%04x\n", word);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt2500usb_init_eeprom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu16 reg;\r\nu16 value;\r\nu16 eeprom;\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);\r\nrt2500usb_register_read(rt2x00dev, MAC_CSR0, &reg);\r\nrt2x00_set_chip(rt2x00dev, RT2570, value, reg);\r\nif (((reg & 0xfff0) != 0) || ((reg & 0x0000000f) == 0)) {\r\nERROR(rt2x00dev, "Invalid RT chipset detected.\n");\r\nreturn -ENODEV;\r\n}\r\nif (!rt2x00_rf(rt2x00dev, RF2522) &&\r\n!rt2x00_rf(rt2x00dev, RF2523) &&\r\n!rt2x00_rf(rt2x00dev, RF2524) &&\r\n!rt2x00_rf(rt2x00dev, RF2525) &&\r\n!rt2x00_rf(rt2x00dev, RF2525E) &&\r\n!rt2x00_rf(rt2x00dev, RF5222)) {\r\nERROR(rt2x00dev, "Invalid RF chipset detected.\n");\r\nreturn -ENODEV;\r\n}\r\nrt2x00dev->default_ant.tx =\r\nrt2x00_get_field16(eeprom, EEPROM_ANTENNA_TX_DEFAULT);\r\nrt2x00dev->default_ant.rx =\r\nrt2x00_get_field16(eeprom, EEPROM_ANTENNA_RX_DEFAULT);\r\nif (rt2x00dev->default_ant.tx == ANTENNA_SW_DIVERSITY)\r\nrt2x00dev->default_ant.tx = ANTENNA_HW_DIVERSITY;\r\nif (rt2x00dev->default_ant.rx == ANTENNA_SW_DIVERSITY)\r\nrt2x00dev->default_ant.rx = ANTENNA_HW_DIVERSITY;\r\n#ifdef CONFIG_RT2X00_LIB_LEDS\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_LED_MODE);\r\nrt2500usb_init_led(rt2x00dev, &rt2x00dev->led_radio, LED_TYPE_RADIO);\r\nif (value == LED_MODE_TXRX_ACTIVITY ||\r\nvalue == LED_MODE_DEFAULT ||\r\nvalue == LED_MODE_ASUS)\r\nrt2500usb_init_led(rt2x00dev, &rt2x00dev->led_qual,\r\nLED_TYPE_ACTIVITY);\r\n#endif\r\nif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO))\r\n__set_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &eeprom);\r\nrt2x00dev->rssi_offset =\r\nrt2x00_get_field16(eeprom, EEPROM_CALIBRATE_OFFSET_RSSI);\r\nreturn 0;\r\n}\r\nstatic int rt2500usb_probe_hw_mode(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct hw_mode_spec *spec = &rt2x00dev->spec;\r\nstruct channel_info *info;\r\nchar *tx_power;\r\nunsigned int i;\r\nrt2x00dev->hw->flags =\r\nIEEE80211_HW_RX_INCLUDES_FCS |\r\nIEEE80211_HW_SIGNAL_DBM |\r\nIEEE80211_HW_SUPPORTS_PS |\r\nIEEE80211_HW_PS_NULLFUNC_STACK;\r\nSET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);\r\nSET_IEEE80211_PERM_ADDR(rt2x00dev->hw,\r\nrt2x00_eeprom_addr(rt2x00dev,\r\nEEPROM_MAC_ADDR_0));\r\nspec->supported_bands = SUPPORT_BAND_2GHZ;\r\nspec->supported_rates = SUPPORT_RATE_CCK | SUPPORT_RATE_OFDM;\r\nif (rt2x00_rf(rt2x00dev, RF2522)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2522);\r\nspec->channels = rf_vals_bg_2522;\r\n} else if (rt2x00_rf(rt2x00dev, RF2523)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2523);\r\nspec->channels = rf_vals_bg_2523;\r\n} else if (rt2x00_rf(rt2x00dev, RF2524)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2524);\r\nspec->channels = rf_vals_bg_2524;\r\n} else if (rt2x00_rf(rt2x00dev, RF2525)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2525);\r\nspec->channels = rf_vals_bg_2525;\r\n} else if (rt2x00_rf(rt2x00dev, RF2525E)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2525e);\r\nspec->channels = rf_vals_bg_2525e;\r\n} else if (rt2x00_rf(rt2x00dev, RF5222)) {\r\nspec->supported_bands |= SUPPORT_BAND_5GHZ;\r\nspec->num_channels = ARRAY_SIZE(rf_vals_5222);\r\nspec->channels = rf_vals_5222;\r\n}\r\ninfo = kcalloc(spec->num_channels, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nspec->channels_info = info;\r\ntx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);\r\nfor (i = 0; i < 14; i++) {\r\ninfo[i].max_power = MAX_TXPOWER;\r\ninfo[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);\r\n}\r\nif (spec->num_channels > 14) {\r\nfor (i = 14; i < spec->num_channels; i++) {\r\ninfo[i].max_power = MAX_TXPOWER;\r\ninfo[i].default_power1 = DEFAULT_TXPOWER;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt2500usb_probe_hw(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval;\r\nretval = rt2500usb_validate_eeprom(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nretval = rt2500usb_init_eeprom(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nretval = rt2500usb_probe_hw_mode(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\n__set_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags);\r\n__set_bit(REQUIRE_BEACON_GUARD, &rt2x00dev->cap_flags);\r\nif (!modparam_nohwcrypt) {\r\n__set_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags);\r\n__set_bit(REQUIRE_COPY_IV, &rt2x00dev->cap_flags);\r\n}\r\n__set_bit(REQUIRE_SW_SEQNO, &rt2x00dev->cap_flags);\r\n__set_bit(REQUIRE_PS_AUTOWAKE, &rt2x00dev->cap_flags);\r\nrt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;\r\nreturn 0;\r\n}\r\nstatic int rt2500usb_probe(struct usb_interface *usb_intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn rt2x00usb_probe(usb_intf, &rt2500usb_ops);\r\n}\r\nstatic int __init rt2500usb_init(void)\r\n{\r\nreturn usb_register(&rt2500usb_driver);\r\n}\r\nstatic void __exit rt2500usb_exit(void)\r\n{\r\nusb_deregister(&rt2500usb_driver);\r\n}
