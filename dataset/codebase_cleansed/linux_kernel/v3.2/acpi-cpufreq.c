static int check_est_cpu(unsigned int cpuid)\r\n{\r\nstruct cpuinfo_x86 *cpu = &cpu_data(cpuid);\r\nreturn cpu_has(cpu, X86_FEATURE_EST);\r\n}\r\nstatic unsigned extract_io(u32 value, struct acpi_cpufreq_data *data)\r\n{\r\nstruct acpi_processor_performance *perf;\r\nint i;\r\nperf = data->acpi_data;\r\nfor (i = 0; i < perf->state_count; i++) {\r\nif (value == perf->states[i].status)\r\nreturn data->freq_table[i].frequency;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned extract_msr(u32 msr, struct acpi_cpufreq_data *data)\r\n{\r\nint i;\r\nstruct acpi_processor_performance *perf;\r\nmsr &= INTEL_MSR_RANGE;\r\nperf = data->acpi_data;\r\nfor (i = 0; data->freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {\r\nif (msr == perf->states[data->freq_table[i].index].status)\r\nreturn data->freq_table[i].frequency;\r\n}\r\nreturn data->freq_table[0].frequency;\r\n}\r\nstatic unsigned extract_freq(u32 val, struct acpi_cpufreq_data *data)\r\n{\r\nswitch (data->cpu_feature) {\r\ncase SYSTEM_INTEL_MSR_CAPABLE:\r\nreturn extract_msr(val, data);\r\ncase SYSTEM_IO_CAPABLE:\r\nreturn extract_io(val, data);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void do_drv_read(void *_cmd)\r\n{\r\nstruct drv_cmd *cmd = _cmd;\r\nu32 h;\r\nswitch (cmd->type) {\r\ncase SYSTEM_INTEL_MSR_CAPABLE:\r\nrdmsr(cmd->addr.msr.reg, cmd->val, h);\r\nbreak;\r\ncase SYSTEM_IO_CAPABLE:\r\nacpi_os_read_port((acpi_io_address)cmd->addr.io.port,\r\n&cmd->val,\r\n(u32)cmd->addr.io.bit_width);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void do_drv_write(void *_cmd)\r\n{\r\nstruct drv_cmd *cmd = _cmd;\r\nu32 lo, hi;\r\nswitch (cmd->type) {\r\ncase SYSTEM_INTEL_MSR_CAPABLE:\r\nrdmsr(cmd->addr.msr.reg, lo, hi);\r\nlo = (lo & ~INTEL_MSR_RANGE) | (cmd->val & INTEL_MSR_RANGE);\r\nwrmsr(cmd->addr.msr.reg, lo, hi);\r\nbreak;\r\ncase SYSTEM_IO_CAPABLE:\r\nacpi_os_write_port((acpi_io_address)cmd->addr.io.port,\r\ncmd->val,\r\n(u32)cmd->addr.io.bit_width);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void drv_read(struct drv_cmd *cmd)\r\n{\r\nint err;\r\ncmd->val = 0;\r\nerr = smp_call_function_any(cmd->mask, do_drv_read, cmd, 1);\r\nWARN_ON_ONCE(err);\r\n}\r\nstatic void drv_write(struct drv_cmd *cmd)\r\n{\r\nint this_cpu;\r\nthis_cpu = get_cpu();\r\nif (cpumask_test_cpu(this_cpu, cmd->mask))\r\ndo_drv_write(cmd);\r\nsmp_call_function_many(cmd->mask, do_drv_write, cmd, 1);\r\nput_cpu();\r\n}\r\nstatic u32 get_cur_val(const struct cpumask *mask)\r\n{\r\nstruct acpi_processor_performance *perf;\r\nstruct drv_cmd cmd;\r\nif (unlikely(cpumask_empty(mask)))\r\nreturn 0;\r\nswitch (per_cpu(acfreq_data, cpumask_first(mask))->cpu_feature) {\r\ncase SYSTEM_INTEL_MSR_CAPABLE:\r\ncmd.type = SYSTEM_INTEL_MSR_CAPABLE;\r\ncmd.addr.msr.reg = MSR_IA32_PERF_STATUS;\r\nbreak;\r\ncase SYSTEM_IO_CAPABLE:\r\ncmd.type = SYSTEM_IO_CAPABLE;\r\nperf = per_cpu(acfreq_data, cpumask_first(mask))->acpi_data;\r\ncmd.addr.io.port = perf->control_register.address;\r\ncmd.addr.io.bit_width = perf->control_register.bit_width;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ncmd.mask = mask;\r\ndrv_read(&cmd);\r\npr_debug("get_cur_val = %u\n", cmd.val);\r\nreturn cmd.val;\r\n}\r\nstatic unsigned int get_cur_freq_on_cpu(unsigned int cpu)\r\n{\r\nstruct acpi_cpufreq_data *data = per_cpu(acfreq_data, cpu);\r\nunsigned int freq;\r\nunsigned int cached_freq;\r\npr_debug("get_cur_freq_on_cpu (%d)\n", cpu);\r\nif (unlikely(data == NULL ||\r\ndata->acpi_data == NULL || data->freq_table == NULL)) {\r\nreturn 0;\r\n}\r\ncached_freq = data->freq_table[data->acpi_data->state].frequency;\r\nfreq = extract_freq(get_cur_val(cpumask_of(cpu)), data);\r\nif (freq != cached_freq) {\r\ndata->resume = 1;\r\n}\r\npr_debug("cur freq = %u\n", freq);\r\nreturn freq;\r\n}\r\nstatic unsigned int check_freqs(const struct cpumask *mask, unsigned int freq,\r\nstruct acpi_cpufreq_data *data)\r\n{\r\nunsigned int cur_freq;\r\nunsigned int i;\r\nfor (i = 0; i < 100; i++) {\r\ncur_freq = extract_freq(get_cur_val(mask), data);\r\nif (cur_freq == freq)\r\nreturn 1;\r\nudelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq, unsigned int relation)\r\n{\r\nstruct acpi_cpufreq_data *data = per_cpu(acfreq_data, policy->cpu);\r\nstruct acpi_processor_performance *perf;\r\nstruct cpufreq_freqs freqs;\r\nstruct drv_cmd cmd;\r\nunsigned int next_state = 0;\r\nunsigned int next_perf_state = 0;\r\nunsigned int i;\r\nint result = 0;\r\npr_debug("acpi_cpufreq_target %d (%d)\n", target_freq, policy->cpu);\r\nif (unlikely(data == NULL ||\r\ndata->acpi_data == NULL || data->freq_table == NULL)) {\r\nreturn -ENODEV;\r\n}\r\nperf = data->acpi_data;\r\nresult = cpufreq_frequency_table_target(policy,\r\ndata->freq_table,\r\ntarget_freq,\r\nrelation, &next_state);\r\nif (unlikely(result)) {\r\nresult = -ENODEV;\r\ngoto out;\r\n}\r\nnext_perf_state = data->freq_table[next_state].index;\r\nif (perf->state == next_perf_state) {\r\nif (unlikely(data->resume)) {\r\npr_debug("Called after resume, resetting to P%d\n",\r\nnext_perf_state);\r\ndata->resume = 0;\r\n} else {\r\npr_debug("Already at target state (P%d)\n",\r\nnext_perf_state);\r\ngoto out;\r\n}\r\n}\r\nswitch (data->cpu_feature) {\r\ncase SYSTEM_INTEL_MSR_CAPABLE:\r\ncmd.type = SYSTEM_INTEL_MSR_CAPABLE;\r\ncmd.addr.msr.reg = MSR_IA32_PERF_CTL;\r\ncmd.val = (u32) perf->states[next_perf_state].control;\r\nbreak;\r\ncase SYSTEM_IO_CAPABLE:\r\ncmd.type = SYSTEM_IO_CAPABLE;\r\ncmd.addr.io.port = perf->control_register.address;\r\ncmd.addr.io.bit_width = perf->control_register.bit_width;\r\ncmd.val = (u32) perf->states[next_perf_state].control;\r\nbreak;\r\ndefault:\r\nresult = -ENODEV;\r\ngoto out;\r\n}\r\nif (policy->shared_type != CPUFREQ_SHARED_TYPE_ANY)\r\ncmd.mask = policy->cpus;\r\nelse\r\ncmd.mask = cpumask_of(policy->cpu);\r\nfreqs.old = perf->states[perf->state].core_frequency * 1000;\r\nfreqs.new = data->freq_table[next_state].frequency;\r\nfor_each_cpu(i, policy->cpus) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\n}\r\ndrv_write(&cmd);\r\nif (acpi_pstate_strict) {\r\nif (!check_freqs(cmd.mask, freqs.new, data)) {\r\npr_debug("acpi_cpufreq_target failed (%d)\n",\r\npolicy->cpu);\r\nresult = -EAGAIN;\r\ngoto out;\r\n}\r\n}\r\nfor_each_cpu(i, policy->cpus) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nperf->state = next_perf_state;\r\nout:\r\nreturn result;\r\n}\r\nstatic int acpi_cpufreq_verify(struct cpufreq_policy *policy)\r\n{\r\nstruct acpi_cpufreq_data *data = per_cpu(acfreq_data, policy->cpu);\r\npr_debug("acpi_cpufreq_verify\n");\r\nreturn cpufreq_frequency_table_verify(policy, data->freq_table);\r\n}\r\nstatic unsigned long\r\nacpi_cpufreq_guess_freq(struct acpi_cpufreq_data *data, unsigned int cpu)\r\n{\r\nstruct acpi_processor_performance *perf = data->acpi_data;\r\nif (cpu_khz) {\r\nunsigned int i;\r\nunsigned long freq;\r\nunsigned long freqn = perf->states[0].core_frequency * 1000;\r\nfor (i = 0; i < (perf->state_count-1); i++) {\r\nfreq = freqn;\r\nfreqn = perf->states[i+1].core_frequency * 1000;\r\nif ((2 * cpu_khz) > (freqn + freq)) {\r\nperf->state = i;\r\nreturn freq;\r\n}\r\n}\r\nperf->state = perf->state_count-1;\r\nreturn freqn;\r\n} else {\r\nperf->state = 0;\r\nreturn perf->states[0].core_frequency * 1000;\r\n}\r\n}\r\nstatic void free_acpi_perf_data(void)\r\n{\r\nunsigned int i;\r\nfor_each_possible_cpu(i)\r\nfree_cpumask_var(per_cpu_ptr(acpi_perf_data, i)\r\n->shared_cpu_map);\r\nfree_percpu(acpi_perf_data);\r\n}\r\nstatic int __init acpi_cpufreq_early_init(void)\r\n{\r\nunsigned int i;\r\npr_debug("acpi_cpufreq_early_init\n");\r\nacpi_perf_data = alloc_percpu(struct acpi_processor_performance);\r\nif (!acpi_perf_data) {\r\npr_debug("Memory allocation error for acpi_perf_data.\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_possible_cpu(i) {\r\nif (!zalloc_cpumask_var_node(\r\n&per_cpu_ptr(acpi_perf_data, i)->shared_cpu_map,\r\nGFP_KERNEL, cpu_to_node(i))) {\r\nfree_acpi_perf_data();\r\nreturn -ENOMEM;\r\n}\r\n}\r\nacpi_processor_preregister_performance(acpi_perf_data);\r\nreturn 0;\r\n}\r\nstatic int sw_any_bug_found(const struct dmi_system_id *d)\r\n{\r\nbios_with_sw_any_bug = 1;\r\nreturn 0;\r\n}\r\nstatic int acpi_cpufreq_blacklist(struct cpuinfo_x86 *c)\r\n{\r\nif (c->x86_vendor == X86_VENDOR_INTEL) {\r\nif ((c->x86 == 15) &&\r\n(c->x86_model == 6) &&\r\n(c->x86_mask == 8)) {\r\nprintk(KERN_INFO "acpi-cpufreq: Intel(R) "\r\n"Xeon(R) 7100 Errata AL30, processors may "\r\n"lock up on frequency changes: disabling "\r\n"acpi-cpufreq.\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int i;\r\nunsigned int valid_states = 0;\r\nunsigned int cpu = policy->cpu;\r\nstruct acpi_cpufreq_data *data;\r\nunsigned int result = 0;\r\nstruct cpuinfo_x86 *c = &cpu_data(policy->cpu);\r\nstruct acpi_processor_performance *perf;\r\n#ifdef CONFIG_SMP\r\nstatic int blacklisted;\r\n#endif\r\npr_debug("acpi_cpufreq_cpu_init\n");\r\n#ifdef CONFIG_SMP\r\nif (blacklisted)\r\nreturn blacklisted;\r\nblacklisted = acpi_cpufreq_blacklist(c);\r\nif (blacklisted)\r\nreturn blacklisted;\r\n#endif\r\ndata = kzalloc(sizeof(struct acpi_cpufreq_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->acpi_data = per_cpu_ptr(acpi_perf_data, cpu);\r\nper_cpu(acfreq_data, cpu) = data;\r\nif (cpu_has(c, X86_FEATURE_CONSTANT_TSC))\r\nacpi_cpufreq_driver.flags |= CPUFREQ_CONST_LOOPS;\r\nresult = acpi_processor_register_performance(data->acpi_data, cpu);\r\nif (result)\r\ngoto err_free;\r\nperf = data->acpi_data;\r\npolicy->shared_type = perf->shared_type;\r\nif (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL ||\r\npolicy->shared_type == CPUFREQ_SHARED_TYPE_ANY) {\r\ncpumask_copy(policy->cpus, perf->shared_cpu_map);\r\n}\r\ncpumask_copy(policy->related_cpus, perf->shared_cpu_map);\r\n#ifdef CONFIG_SMP\r\ndmi_check_system(sw_any_bug_dmi_table);\r\nif (bios_with_sw_any_bug && cpumask_weight(policy->cpus) == 1) {\r\npolicy->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\ncpumask_copy(policy->cpus, cpu_core_mask(cpu));\r\n}\r\n#endif\r\nif (perf->state_count <= 1) {\r\npr_debug("No P-States\n");\r\nresult = -ENODEV;\r\ngoto err_unreg;\r\n}\r\nif (perf->control_register.space_id != perf->status_register.space_id) {\r\nresult = -ENODEV;\r\ngoto err_unreg;\r\n}\r\nswitch (perf->control_register.space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\npr_debug("SYSTEM IO addr space\n");\r\ndata->cpu_feature = SYSTEM_IO_CAPABLE;\r\nbreak;\r\ncase ACPI_ADR_SPACE_FIXED_HARDWARE:\r\npr_debug("HARDWARE addr space\n");\r\nif (!check_est_cpu(cpu)) {\r\nresult = -ENODEV;\r\ngoto err_unreg;\r\n}\r\ndata->cpu_feature = SYSTEM_INTEL_MSR_CAPABLE;\r\nbreak;\r\ndefault:\r\npr_debug("Unknown addr space %d\n",\r\n(u32) (perf->control_register.space_id));\r\nresult = -ENODEV;\r\ngoto err_unreg;\r\n}\r\ndata->freq_table = kmalloc(sizeof(struct cpufreq_frequency_table) *\r\n(perf->state_count+1), GFP_KERNEL);\r\nif (!data->freq_table) {\r\nresult = -ENOMEM;\r\ngoto err_unreg;\r\n}\r\npolicy->cpuinfo.transition_latency = 0;\r\nfor (i = 0; i < perf->state_count; i++) {\r\nif ((perf->states[i].transition_latency * 1000) >\r\npolicy->cpuinfo.transition_latency)\r\npolicy->cpuinfo.transition_latency =\r\nperf->states[i].transition_latency * 1000;\r\n}\r\nif (perf->control_register.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE &&\r\npolicy->cpuinfo.transition_latency > 20 * 1000) {\r\npolicy->cpuinfo.transition_latency = 20 * 1000;\r\nprintk_once(KERN_INFO\r\n"P-state transition latency capped at 20 uS\n");\r\n}\r\nfor (i = 0; i < perf->state_count; i++) {\r\nif (i > 0 && perf->states[i].core_frequency >=\r\ndata->freq_table[valid_states-1].frequency / 1000)\r\ncontinue;\r\ndata->freq_table[valid_states].index = i;\r\ndata->freq_table[valid_states].frequency =\r\nperf->states[i].core_frequency * 1000;\r\nvalid_states++;\r\n}\r\ndata->freq_table[valid_states].frequency = CPUFREQ_TABLE_END;\r\nperf->state = 0;\r\nresult = cpufreq_frequency_table_cpuinfo(policy, data->freq_table);\r\nif (result)\r\ngoto err_freqfree;\r\nif (perf->states[0].core_frequency * 1000 != policy->cpuinfo.max_freq)\r\nprintk(KERN_WARNING FW_WARN "P-state 0 is not max freq\n");\r\nswitch (perf->control_register.space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\npolicy->cur = acpi_cpufreq_guess_freq(data, policy->cpu);\r\nbreak;\r\ncase ACPI_ADR_SPACE_FIXED_HARDWARE:\r\nacpi_cpufreq_driver.get = get_cur_freq_on_cpu;\r\npolicy->cur = get_cur_freq_on_cpu(cpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nacpi_processor_notify_smm(THIS_MODULE);\r\nif (boot_cpu_has(X86_FEATURE_APERFMPERF))\r\nacpi_cpufreq_driver.getavg = cpufreq_get_measured_perf;\r\npr_debug("CPU%u - ACPI performance management activated.\n", cpu);\r\nfor (i = 0; i < perf->state_count; i++)\r\npr_debug(" %cP%d: %d MHz, %d mW, %d uS\n",\r\n(i == perf->state ? '*' : ' '), i,\r\n(u32) perf->states[i].core_frequency,\r\n(u32) perf->states[i].power,\r\n(u32) perf->states[i].transition_latency);\r\ncpufreq_frequency_table_get_attr(data->freq_table, policy->cpu);\r\ndata->resume = 1;\r\nreturn result;\r\nerr_freqfree:\r\nkfree(data->freq_table);\r\nerr_unreg:\r\nacpi_processor_unregister_performance(perf, cpu);\r\nerr_free:\r\nkfree(data);\r\nper_cpu(acfreq_data, cpu) = NULL;\r\nreturn result;\r\n}\r\nstatic int acpi_cpufreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct acpi_cpufreq_data *data = per_cpu(acfreq_data, policy->cpu);\r\npr_debug("acpi_cpufreq_cpu_exit\n");\r\nif (data) {\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nper_cpu(acfreq_data, policy->cpu) = NULL;\r\nacpi_processor_unregister_performance(data->acpi_data,\r\npolicy->cpu);\r\nkfree(data->freq_table);\r\nkfree(data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_cpufreq_resume(struct cpufreq_policy *policy)\r\n{\r\nstruct acpi_cpufreq_data *data = per_cpu(acfreq_data, policy->cpu);\r\npr_debug("acpi_cpufreq_resume\n");\r\ndata->resume = 1;\r\nreturn 0;\r\n}\r\nstatic int __init acpi_cpufreq_init(void)\r\n{\r\nint ret;\r\nif (acpi_disabled)\r\nreturn 0;\r\npr_debug("acpi_cpufreq_init\n");\r\nret = acpi_cpufreq_early_init();\r\nif (ret)\r\nreturn ret;\r\nret = cpufreq_register_driver(&acpi_cpufreq_driver);\r\nif (ret)\r\nfree_acpi_perf_data();\r\nreturn ret;\r\n}\r\nstatic void __exit acpi_cpufreq_exit(void)\r\n{\r\npr_debug("acpi_cpufreq_exit\n");\r\ncpufreq_unregister_driver(&acpi_cpufreq_driver);\r\nfree_acpi_perf_data();\r\n}
