static int ipheth_alloc_urbs(struct ipheth_device *iphone)\r\n{\r\nstruct urb *tx_urb = NULL;\r\nstruct urb *rx_urb = NULL;\r\nu8 *tx_buf = NULL;\r\nu8 *rx_buf = NULL;\r\ntx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (tx_urb == NULL)\r\ngoto error_nomem;\r\nrx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (rx_urb == NULL)\r\ngoto free_tx_urb;\r\ntx_buf = usb_alloc_coherent(iphone->udev, IPHETH_BUF_SIZE,\r\nGFP_KERNEL, &tx_urb->transfer_dma);\r\nif (tx_buf == NULL)\r\ngoto free_rx_urb;\r\nrx_buf = usb_alloc_coherent(iphone->udev, IPHETH_BUF_SIZE,\r\nGFP_KERNEL, &rx_urb->transfer_dma);\r\nif (rx_buf == NULL)\r\ngoto free_tx_buf;\r\niphone->tx_urb = tx_urb;\r\niphone->rx_urb = rx_urb;\r\niphone->tx_buf = tx_buf;\r\niphone->rx_buf = rx_buf;\r\nreturn 0;\r\nfree_tx_buf:\r\nusb_free_coherent(iphone->udev, IPHETH_BUF_SIZE, tx_buf,\r\ntx_urb->transfer_dma);\r\nfree_rx_urb:\r\nusb_free_urb(rx_urb);\r\nfree_tx_urb:\r\nusb_free_urb(tx_urb);\r\nerror_nomem:\r\nreturn -ENOMEM;\r\n}\r\nstatic void ipheth_free_urbs(struct ipheth_device *iphone)\r\n{\r\nusb_free_coherent(iphone->udev, IPHETH_BUF_SIZE, iphone->rx_buf,\r\niphone->rx_urb->transfer_dma);\r\nusb_free_coherent(iphone->udev, IPHETH_BUF_SIZE, iphone->tx_buf,\r\niphone->tx_urb->transfer_dma);\r\nusb_free_urb(iphone->rx_urb);\r\nusb_free_urb(iphone->tx_urb);\r\n}\r\nstatic void ipheth_kill_urbs(struct ipheth_device *dev)\r\n{\r\nusb_kill_urb(dev->tx_urb);\r\nusb_kill_urb(dev->rx_urb);\r\n}\r\nstatic void ipheth_rcvbulk_callback(struct urb *urb)\r\n{\r\nstruct ipheth_device *dev;\r\nstruct sk_buff *skb;\r\nint status;\r\nchar *buf;\r\nint len;\r\ndev = urb->context;\r\nif (dev == NULL)\r\nreturn;\r\nstatus = urb->status;\r\nswitch (status) {\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nerr("%s: urb status: %d", __func__, status);\r\nreturn;\r\n}\r\nif (urb->actual_length <= IPHETH_IP_ALIGN) {\r\ndev->net->stats.rx_length_errors++;\r\nreturn;\r\n}\r\nlen = urb->actual_length - IPHETH_IP_ALIGN;\r\nbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nerr("%s: dev_alloc_skb: -ENOMEM", __func__);\r\ndev->net->stats.rx_dropped++;\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, len), buf, len);\r\nskb->dev = dev->net;\r\nskb->protocol = eth_type_trans(skb, dev->net);\r\ndev->net->stats.rx_packets++;\r\ndev->net->stats.rx_bytes += len;\r\nnetif_rx(skb);\r\nipheth_rx_submit(dev, GFP_ATOMIC);\r\n}\r\nstatic void ipheth_sndbulk_callback(struct urb *urb)\r\n{\r\nstruct ipheth_device *dev;\r\nint status = urb->status;\r\ndev = urb->context;\r\nif (dev == NULL)\r\nreturn;\r\nif (status != 0 &&\r\nstatus != -ENOENT &&\r\nstatus != -ECONNRESET &&\r\nstatus != -ESHUTDOWN)\r\nerr("%s: urb status: %d", __func__, status);\r\ndev_kfree_skb_irq(dev->tx_skb);\r\nnetif_wake_queue(dev->net);\r\n}\r\nstatic int ipheth_carrier_set(struct ipheth_device *dev)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nint retval;\r\nretval = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, IPHETH_CTRL_ENDP),\r\nIPHETH_CMD_CARRIER_CHECK,\r\n0xc0,\r\n0x00,\r\n0x02,\r\ndev->ctrl_buf, IPHETH_CTRL_BUF_SIZE,\r\nIPHETH_CTRL_TIMEOUT);\r\nif (retval < 0) {\r\nerr("%s: usb_control_msg: %d", __func__, retval);\r\nreturn retval;\r\n}\r\nif (dev->ctrl_buf[0] == IPHETH_CARRIER_ON)\r\nnetif_carrier_on(dev->net);\r\nelse\r\nnetif_carrier_off(dev->net);\r\nreturn 0;\r\n}\r\nstatic void ipheth_carrier_check_work(struct work_struct *work)\r\n{\r\nstruct ipheth_device *dev = container_of(work, struct ipheth_device,\r\ncarrier_work.work);\r\nipheth_carrier_set(dev);\r\nschedule_delayed_work(&dev->carrier_work, IPHETH_CARRIER_CHECK_TIMEOUT);\r\n}\r\nstatic int ipheth_get_macaddr(struct ipheth_device *dev)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nstruct net_device *net = dev->net;\r\nint retval;\r\nretval = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, IPHETH_CTRL_ENDP),\r\nIPHETH_CMD_GET_MACADDR,\r\n0xc0,\r\n0x00,\r\n0x02,\r\ndev->ctrl_buf,\r\nIPHETH_CTRL_BUF_SIZE,\r\nIPHETH_CTRL_TIMEOUT);\r\nif (retval < 0) {\r\nerr("%s: usb_control_msg: %d", __func__, retval);\r\n} else if (retval < ETH_ALEN) {\r\nerr("%s: usb_control_msg: short packet: %d bytes",\r\n__func__, retval);\r\nretval = -EINVAL;\r\n} else {\r\nmemcpy(net->dev_addr, dev->ctrl_buf, ETH_ALEN);\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic int ipheth_rx_submit(struct ipheth_device *dev, gfp_t mem_flags)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nint retval;\r\nusb_fill_bulk_urb(dev->rx_urb, udev,\r\nusb_rcvbulkpipe(udev, dev->bulk_in),\r\ndev->rx_buf, IPHETH_BUF_SIZE,\r\nipheth_rcvbulk_callback,\r\ndev);\r\ndev->rx_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nretval = usb_submit_urb(dev->rx_urb, mem_flags);\r\nif (retval)\r\nerr("%s: usb_submit_urb: %d", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic int ipheth_open(struct net_device *net)\r\n{\r\nstruct ipheth_device *dev = netdev_priv(net);\r\nstruct usb_device *udev = dev->udev;\r\nint retval = 0;\r\nusb_set_interface(udev, IPHETH_INTFNUM, IPHETH_ALT_INTFNUM);\r\nretval = ipheth_carrier_set(dev);\r\nif (retval)\r\nreturn retval;\r\nretval = ipheth_rx_submit(dev, GFP_KERNEL);\r\nif (retval)\r\nreturn retval;\r\nschedule_delayed_work(&dev->carrier_work, IPHETH_CARRIER_CHECK_TIMEOUT);\r\nnetif_start_queue(net);\r\nreturn retval;\r\n}\r\nstatic int ipheth_close(struct net_device *net)\r\n{\r\nstruct ipheth_device *dev = netdev_priv(net);\r\ncancel_delayed_work_sync(&dev->carrier_work);\r\nnetif_stop_queue(net);\r\nreturn 0;\r\n}\r\nstatic int ipheth_tx(struct sk_buff *skb, struct net_device *net)\r\n{\r\nstruct ipheth_device *dev = netdev_priv(net);\r\nstruct usb_device *udev = dev->udev;\r\nint retval;\r\nif (skb->len > IPHETH_BUF_SIZE) {\r\nWARN(1, "%s: skb too large: %d bytes\n", __func__, skb->len);\r\ndev->net->stats.tx_dropped++;\r\ndev_kfree_skb_irq(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nmemcpy(dev->tx_buf, skb->data, skb->len);\r\nif (skb->len < IPHETH_BUF_SIZE)\r\nmemset(dev->tx_buf + skb->len, 0, IPHETH_BUF_SIZE - skb->len);\r\nusb_fill_bulk_urb(dev->tx_urb, udev,\r\nusb_sndbulkpipe(udev, dev->bulk_out),\r\ndev->tx_buf, IPHETH_BUF_SIZE,\r\nipheth_sndbulk_callback,\r\ndev);\r\ndev->tx_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nretval = usb_submit_urb(dev->tx_urb, GFP_ATOMIC);\r\nif (retval) {\r\nerr("%s: usb_submit_urb: %d", __func__, retval);\r\ndev->net->stats.tx_errors++;\r\ndev_kfree_skb_irq(skb);\r\n} else {\r\ndev->tx_skb = skb;\r\ndev->net->stats.tx_packets++;\r\ndev->net->stats.tx_bytes += skb->len;\r\nnetif_stop_queue(net);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ipheth_tx_timeout(struct net_device *net)\r\n{\r\nstruct ipheth_device *dev = netdev_priv(net);\r\nerr("%s: TX timeout", __func__);\r\ndev->net->stats.tx_errors++;\r\nusb_unlink_urb(dev->tx_urb);\r\n}\r\nstatic u32 ipheth_ethtool_op_get_link(struct net_device *net)\r\n{\r\nstruct ipheth_device *dev = netdev_priv(net);\r\nreturn netif_carrier_ok(dev->net);\r\n}\r\nstatic int ipheth_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *hintf;\r\nstruct usb_endpoint_descriptor *endp;\r\nstruct ipheth_device *dev;\r\nstruct net_device *netdev;\r\nint i;\r\nint retval;\r\nnetdev = alloc_etherdev(sizeof(struct ipheth_device));\r\nif (!netdev)\r\nreturn -ENOMEM;\r\nnetdev->netdev_ops = &ipheth_netdev_ops;\r\nnetdev->watchdog_timeo = IPHETH_TX_TIMEOUT;\r\nstrcpy(netdev->name, "eth%d");\r\ndev = netdev_priv(netdev);\r\ndev->udev = udev;\r\ndev->net = netdev;\r\ndev->intf = intf;\r\nhintf = usb_altnum_to_altsetting(intf, IPHETH_ALT_INTFNUM);\r\nif (hintf == NULL) {\r\nretval = -ENODEV;\r\nerr("Unable to find alternate settings interface");\r\ngoto err_endpoints;\r\n}\r\nfor (i = 0; i < hintf->desc.bNumEndpoints; i++) {\r\nendp = &hintf->endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(endp))\r\ndev->bulk_in = endp->bEndpointAddress;\r\nelse if (usb_endpoint_is_bulk_out(endp))\r\ndev->bulk_out = endp->bEndpointAddress;\r\n}\r\nif (!(dev->bulk_in && dev->bulk_out)) {\r\nretval = -ENODEV;\r\nerr("Unable to find endpoints");\r\ngoto err_endpoints;\r\n}\r\ndev->ctrl_buf = kmalloc(IPHETH_CTRL_BUF_SIZE, GFP_KERNEL);\r\nif (dev->ctrl_buf == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_alloc_ctrl_buf;\r\n}\r\nretval = ipheth_get_macaddr(dev);\r\nif (retval)\r\ngoto err_get_macaddr;\r\nINIT_DELAYED_WORK(&dev->carrier_work, ipheth_carrier_check_work);\r\nretval = ipheth_alloc_urbs(dev);\r\nif (retval) {\r\nerr("error allocating urbs: %d", retval);\r\ngoto err_alloc_urbs;\r\n}\r\nusb_set_intfdata(intf, dev);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nSET_ETHTOOL_OPS(netdev, &ops);\r\nretval = register_netdev(netdev);\r\nif (retval) {\r\nerr("error registering netdev: %d", retval);\r\nretval = -EIO;\r\ngoto err_register_netdev;\r\n}\r\ndev_info(&intf->dev, "Apple iPhone USB Ethernet device attached\n");\r\nreturn 0;\r\nerr_register_netdev:\r\nipheth_free_urbs(dev);\r\nerr_alloc_urbs:\r\nerr_get_macaddr:\r\nerr_alloc_ctrl_buf:\r\nkfree(dev->ctrl_buf);\r\nerr_endpoints:\r\nfree_netdev(netdev);\r\nreturn retval;\r\n}\r\nstatic void ipheth_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ipheth_device *dev;\r\ndev = usb_get_intfdata(intf);\r\nif (dev != NULL) {\r\nunregister_netdev(dev->net);\r\nipheth_kill_urbs(dev);\r\nipheth_free_urbs(dev);\r\nkfree(dev->ctrl_buf);\r\nfree_netdev(dev->net);\r\n}\r\nusb_set_intfdata(intf, NULL);\r\ndev_info(&intf->dev, "Apple iPhone USB Ethernet now disconnected\n");\r\n}\r\nstatic int __init ipheth_init(void)\r\n{\r\nint retval;\r\nretval = usb_register(&ipheth_driver);\r\nif (retval) {\r\nerr("usb_register failed: %d", retval);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ipheth_exit(void)\r\n{\r\nusb_deregister(&ipheth_driver);\r\n}
