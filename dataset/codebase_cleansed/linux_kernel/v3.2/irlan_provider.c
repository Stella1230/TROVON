static int irlan_provider_data_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irlan_cb *self;\r\n__u8 code;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\ncode = skb->data[0];\r\nswitch(code) {\r\ncase CMD_GET_PROVIDER_INFO:\r\nIRDA_DEBUG(4, "Got GET_PROVIDER_INFO command!\n");\r\nirlan_do_provider_event(self, IRLAN_GET_INFO_CMD, skb);\r\nbreak;\r\ncase CMD_GET_MEDIA_CHAR:\r\nIRDA_DEBUG(4, "Got GET_MEDIA_CHAR command!\n");\r\nirlan_do_provider_event(self, IRLAN_GET_MEDIA_CMD, skb);\r\nbreak;\r\ncase CMD_OPEN_DATA_CHANNEL:\r\nIRDA_DEBUG(4, "Got OPEN_DATA_CHANNEL command!\n");\r\nirlan_do_provider_event(self, IRLAN_OPEN_DATA_CMD, skb);\r\nbreak;\r\ncase CMD_FILTER_OPERATION:\r\nIRDA_DEBUG(4, "Got FILTER_OPERATION command!\n");\r\nirlan_do_provider_event(self, IRLAN_FILTER_CONFIG_CMD, skb);\r\nbreak;\r\ncase CMD_RECONNECT_DATA_CHAN:\r\nIRDA_DEBUG(2, "%s(), Got RECONNECT_DATA_CHAN command\n", __func__ );\r\nIRDA_DEBUG(2, "%s(), NOT IMPLEMENTED\n", __func__ );\r\nbreak;\r\ncase CMD_CLOSE_DATA_CHAN:\r\nIRDA_DEBUG(2, "Got CLOSE_DATA_CHAN command!\n");\r\nIRDA_DEBUG(2, "%s(), NOT IMPLEMENTED\n", __func__ );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown command!\n", __func__ );\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void irlan_provider_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irlan_cb *self;\r\nstruct tsap_cb *tsap;\r\nIRDA_DEBUG(0, "%s()\n", __func__ );\r\nself = instance;\r\ntsap = sap;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nIRDA_ASSERT(tsap == self->provider.tsap_ctrl,return;);\r\nIRDA_ASSERT(self->provider.state == IRLAN_IDLE, return;);\r\nself->provider.max_sdu_size = max_sdu_size;\r\nself->provider.max_header_size = max_header_size;\r\nirlan_do_provider_event(self, IRLAN_CONNECT_INDICATION, NULL);\r\nif ((self->provider.access_type == ACCESS_PEER) &&\r\n(self->client.state == IRLAN_IDLE))\r\n{\r\nirlan_client_wakeup(self, self->saddr, self->daddr);\r\n}\r\n}\r\nvoid irlan_provider_connect_response(struct irlan_cb *self,\r\nstruct tsap_cb *tsap)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nirttp_connect_response(tsap, IRLAN_MTU, NULL);\r\n}\r\nstatic void irlan_provider_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason,\r\nstruct sk_buff *userdata)\r\n{\r\nstruct irlan_cb *self;\r\nstruct tsap_cb *tsap;\r\nIRDA_DEBUG(4, "%s(), reason=%d\n", __func__ , reason);\r\nself = instance;\r\ntsap = sap;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nIRDA_ASSERT(tsap != NULL, return;);\r\nIRDA_ASSERT(tsap->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_ASSERT(tsap == self->provider.tsap_ctrl, return;);\r\nirlan_do_provider_event(self, IRLAN_LMP_DISCONNECT, NULL);\r\n}\r\nint irlan_parse_open_data_cmd(struct irlan_cb *self, struct sk_buff *skb)\r\n{\r\nint ret;\r\nret = irlan_provider_parse_command(self, CMD_OPEN_DATA_CHANNEL, skb);\r\nirlan_open_data_tsap(self);\r\nreturn ret;\r\n}\r\nint irlan_provider_parse_command(struct irlan_cb *self, int cmd,\r\nstruct sk_buff *skb)\r\n{\r\n__u8 *frame;\r\n__u8 *ptr;\r\nint count;\r\n__u16 val_len;\r\nint i;\r\nchar *name;\r\nchar *value;\r\nint ret = RSP_SUCCESS;\r\nIRDA_ASSERT(skb != NULL, return -RSP_PROTOCOL_ERROR;);\r\nIRDA_DEBUG(4, "%s(), skb->len=%d\n", __func__ , (int)skb->len);\r\nIRDA_ASSERT(self != NULL, return -RSP_PROTOCOL_ERROR;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -RSP_PROTOCOL_ERROR;);\r\nif (!skb)\r\nreturn -RSP_PROTOCOL_ERROR;\r\nframe = skb->data;\r\nname = kmalloc(255, GFP_ATOMIC);\r\nif (!name)\r\nreturn -RSP_INSUFFICIENT_RESOURCES;\r\nvalue = kmalloc(1016, GFP_ATOMIC);\r\nif (!value) {\r\nkfree(name);\r\nreturn -RSP_INSUFFICIENT_RESOURCES;\r\n}\r\ncount = frame[1];\r\nIRDA_DEBUG(4, "Got %d parameters\n", count);\r\nptr = frame+2;\r\nfor (i=0; i<count;i++) {\r\nret = irlan_extract_param(ptr, name, value, &val_len);\r\nif (ret < 0) {\r\nIRDA_DEBUG(2, "%s(), IrLAN, Error!\n", __func__ );\r\nbreak;\r\n}\r\nptr+=ret;\r\nret = RSP_SUCCESS;\r\nirlan_check_command_param(self, name, value);\r\n}\r\nkfree(name);\r\nkfree(value);\r\nreturn ret;\r\n}\r\nvoid irlan_provider_send_reply(struct irlan_cb *self, int command,\r\nint ret_code)\r\n{\r\nstruct sk_buff *skb;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_TYPE", "DIRECTED") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_TYPE", "BORADCAST") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_TYPE", "MULTICAST") +\r\nIRLAN_STRING_PARAMETER_LEN("ACCESS_TYPE", "HOSTED"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->provider.max_header_size);\r\nskb_put(skb, 2);\r\nswitch (command) {\r\ncase CMD_GET_PROVIDER_INFO:\r\nskb->data[0] = 0x00;\r\nskb->data[1] = 0x02;\r\nswitch (self->media) {\r\ncase MEDIA_802_3:\r\nirlan_insert_string_param(skb, "MEDIA", "802.3");\r\nbreak;\r\ncase MEDIA_802_5:\r\nirlan_insert_string_param(skb, "MEDIA", "802.5");\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown media type!\n", __func__ );\r\nbreak;\r\n}\r\nirlan_insert_short_param(skb, "IRLAN_VER", 0x0101);\r\nbreak;\r\ncase CMD_GET_MEDIA_CHAR:\r\nskb->data[0] = 0x00;\r\nskb->data[1] = 0x05;\r\nirlan_insert_string_param(skb, "FILTER_TYPE", "DIRECTED");\r\nirlan_insert_string_param(skb, "FILTER_TYPE", "BROADCAST");\r\nirlan_insert_string_param(skb, "FILTER_TYPE", "MULTICAST");\r\nswitch (self->provider.access_type) {\r\ncase ACCESS_DIRECT:\r\nirlan_insert_string_param(skb, "ACCESS_TYPE", "DIRECT");\r\nbreak;\r\ncase ACCESS_PEER:\r\nirlan_insert_string_param(skb, "ACCESS_TYPE", "PEER");\r\nbreak;\r\ncase ACCESS_HOSTED:\r\nirlan_insert_string_param(skb, "ACCESS_TYPE", "HOSTED");\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown access type\n", __func__ );\r\nbreak;\r\n}\r\nirlan_insert_short_param(skb, "MAX_FRAME", 0x05ee);\r\nbreak;\r\ncase CMD_OPEN_DATA_CHANNEL:\r\nskb->data[0] = 0x00;\r\nif (self->provider.send_arb_val) {\r\nskb->data[1] = 0x03;\r\nirlan_insert_short_param(skb, "CON_ARB",\r\nself->provider.send_arb_val);\r\n} else\r\nskb->data[1] = 0x02;\r\nirlan_insert_byte_param(skb, "DATA_CHAN", self->stsap_sel_data);\r\nirlan_insert_string_param(skb, "RECONNECT_KEY", "LINUX RULES!");\r\nbreak;\r\ncase CMD_FILTER_OPERATION:\r\nirlan_filter_request(self, skb);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), Unknown command!\n", __func__ );\r\nbreak;\r\n}\r\nirttp_data_request(self->provider.tsap_ctrl, skb);\r\n}\r\nint irlan_provider_open_ctrl_tsap(struct irlan_cb *self)\r\n{\r\nstruct tsap_cb *tsap;\r\nnotify_t notify;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\r\nif (self->provider.tsap_ctrl)\r\nreturn -1;\r\nirda_notify_init(&notify);\r\nnotify.data_indication = irlan_provider_data_indication;\r\nnotify.connect_indication = irlan_provider_connect_indication;\r\nnotify.disconnect_indication = irlan_provider_disconnect_indication;\r\nnotify.instance = self;\r\nstrlcpy(notify.name, "IrLAN ctrl (p)", sizeof(notify.name));\r\ntsap = irttp_open_tsap(LSAP_ANY, 1, &notify);\r\nif (!tsap) {\r\nIRDA_DEBUG(2, "%s(), Got no tsap!\n", __func__ );\r\nreturn -1;\r\n}\r\nself->provider.tsap_ctrl = tsap;\r\nirlan_ias_register(self, tsap->stsap_sel);\r\nreturn 0;\r\n}
