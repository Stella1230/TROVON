static void migor_ts_poscheck(struct work_struct *work)\r\n{\r\nstruct migor_ts_priv *priv = container_of(work,\r\nstruct migor_ts_priv,\r\nwork.work);\r\nunsigned short xpos, ypos;\r\nunsigned char event;\r\nu_int8_t buf[16];\r\nmemset(buf, 0, sizeof(buf));\r\nbuf[0] = 0;\r\nif (i2c_master_send(priv->client, buf, 1) != 1) {\r\ndev_err(&priv->client->dev, "Unable to write i2c index\n");\r\ngoto out;\r\n}\r\nif (i2c_master_recv(priv->client, buf, sizeof(buf)) != sizeof(buf)) {\r\ndev_err(&priv->client->dev, "Unable to read i2c page\n");\r\ngoto out;\r\n}\r\nypos = ((buf[9] & 0x03) << 8 | buf[8]);\r\nxpos = ((buf[11] & 0x03) << 8 | buf[10]);\r\nevent = buf[12];\r\nif (event == EVENT_PENDOWN || event == EVENT_REPEAT) {\r\ninput_report_key(priv->input, BTN_TOUCH, 1);\r\ninput_report_abs(priv->input, ABS_X, ypos);\r\ninput_report_abs(priv->input, ABS_Y, xpos);\r\ninput_sync(priv->input);\r\n} else if (event == EVENT_PENUP) {\r\ninput_report_key(priv->input, BTN_TOUCH, 0);\r\ninput_sync(priv->input);\r\n}\r\nout:\r\nenable_irq(priv->irq);\r\n}\r\nstatic irqreturn_t migor_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct migor_ts_priv *priv = dev_id;\r\ndisable_irq_nosync(irq);\r\nschedule_delayed_work(&priv->work, HZ / 20);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int migor_ts_open(struct input_dev *dev)\r\n{\r\nstruct migor_ts_priv *priv = input_get_drvdata(dev);\r\nstruct i2c_client *client = priv->client;\r\nint count;\r\ncount = i2c_master_send(client, migor_ts_ena_seq,\r\nsizeof(migor_ts_ena_seq));\r\nif (count != sizeof(migor_ts_ena_seq)) {\r\ndev_err(&client->dev, "Unable to enable touchscreen.\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void migor_ts_close(struct input_dev *dev)\r\n{\r\nstruct migor_ts_priv *priv = input_get_drvdata(dev);\r\nstruct i2c_client *client = priv->client;\r\ndisable_irq(priv->irq);\r\nif (cancel_delayed_work_sync(&priv->work)) {\r\nenable_irq(priv->irq);\r\n}\r\ni2c_master_send(client, migor_ts_dis_seq, sizeof(migor_ts_dis_seq));\r\nenable_irq(priv->irq);\r\n}\r\nstatic int migor_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *idp)\r\n{\r\nstruct migor_ts_priv *priv;\r\nstruct input_dev *input;\r\nint error;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&client->dev, "failed to allocate driver data\n");\r\nerror = -ENOMEM;\r\ngoto err0;\r\n}\r\ndev_set_drvdata(&client->dev, priv);\r\ninput = input_allocate_device();\r\nif (!input) {\r\ndev_err(&client->dev, "Failed to allocate input device.\n");\r\nerror = -ENOMEM;\r\ngoto err1;\r\n}\r\ninput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input, ABS_X, 95, 955, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 85, 935, 0, 0);\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &client->dev;\r\ninput->open = migor_ts_open;\r\ninput->close = migor_ts_close;\r\ninput_set_drvdata(input, priv);\r\npriv->client = client;\r\npriv->input = input;\r\nINIT_DELAYED_WORK(&priv->work, migor_ts_poscheck);\r\npriv->irq = client->irq;\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err1;\r\nerror = request_irq(priv->irq, migor_ts_isr, IRQF_TRIGGER_LOW,\r\nclient->name, priv);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to request touchscreen IRQ.\n");\r\ngoto err2;\r\n}\r\ndevice_init_wakeup(&client->dev, 1);\r\nreturn 0;\r\nerr2:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nerr1:\r\ninput_free_device(input);\r\nkfree(priv);\r\nerr0:\r\ndev_set_drvdata(&client->dev, NULL);\r\nreturn error;\r\n}\r\nstatic int migor_ts_remove(struct i2c_client *client)\r\n{\r\nstruct migor_ts_priv *priv = dev_get_drvdata(&client->dev);\r\nfree_irq(priv->irq, priv);\r\ninput_unregister_device(priv->input);\r\nkfree(priv);\r\ndev_set_drvdata(&client->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int migor_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct migor_ts_priv *priv = dev_get_drvdata(&client->dev);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(priv->irq);\r\nreturn 0;\r\n}\r\nstatic int migor_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct migor_ts_priv *priv = dev_get_drvdata(&client->dev);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(priv->irq);\r\nreturn 0;\r\n}\r\nstatic int __init migor_ts_init(void)\r\n{\r\nreturn i2c_add_driver(&migor_ts_driver);\r\n}\r\nstatic void __exit migor_ts_exit(void)\r\n{\r\ni2c_del_driver(&migor_ts_driver);\r\n}
