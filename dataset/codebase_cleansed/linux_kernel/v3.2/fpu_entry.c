void math_emulate(struct math_emu_info *info)\r\n{\r\nu_char FPU_modrm, byte1;\r\nunsigned short code;\r\nfpu_addr_modes addr_modes;\r\nint unmasked;\r\nFPU_REG loaded_data;\r\nFPU_REG *st0_ptr;\r\nu_char loaded_tag, st0_tag;\r\nvoid __user *data_address;\r\nstruct address data_sel_off;\r\nstruct address entry_sel_off;\r\nunsigned long code_base = 0;\r\nunsigned long code_limit = 0;\r\nstruct desc_struct code_descriptor;\r\nif (!used_math()) {\r\nif (init_fpu(current)) {\r\ndo_group_exit(SIGKILL);\r\nreturn;\r\n}\r\n}\r\n#ifdef RE_ENTRANT_CHECKING\r\nif (emulating) {\r\nprintk("ERROR: wm-FPU-emu is not RE-ENTRANT!\n");\r\n}\r\nRE_ENTRANT_CHECK_ON;\r\n#endif\r\nFPU_info = info;\r\nFPU_ORIG_EIP = FPU_EIP;\r\nif ((FPU_EFLAGS & 0x00020000) != 0) {\r\naddr_modes.default_mode = VM86;\r\nFPU_EIP += code_base = FPU_CS << 4;\r\ncode_limit = code_base + 0xffff;\r\n} else if (FPU_CS == __USER_CS && FPU_DS == __USER_DS) {\r\naddr_modes.default_mode = 0;\r\n} else if (FPU_CS == __KERNEL_CS) {\r\nprintk("math_emulate: %04x:%08lx\n", FPU_CS, FPU_EIP);\r\npanic("Math emulation needed in kernel");\r\n} else {\r\nif ((FPU_CS & 4) != 4) {\r\nprintk("FPU emulator: Unsupported addressing mode\n");\r\nmath_abort(FPU_info, SIGILL);\r\n}\r\ncode_descriptor = LDT_DESCRIPTOR(FPU_CS);\r\nif (SEG_D_SIZE(code_descriptor)) {\r\naddr_modes.default_mode = SEG32;\r\n} else {\r\naddr_modes.default_mode = PM16;\r\n}\r\nFPU_EIP += code_base = SEG_BASE_ADDR(code_descriptor);\r\ncode_limit = code_base\r\n+ (SEG_LIMIT(code_descriptor) +\r\n1) * SEG_GRANULARITY(code_descriptor)\r\n- 1;\r\nif (code_limit < code_base)\r\ncode_limit = 0xffffffff;\r\n}\r\nFPU_lookahead = !(FPU_EFLAGS & X86_EFLAGS_TF);\r\nif (!valid_prefix(&byte1, (u_char __user **) & FPU_EIP,\r\n&addr_modes.override)) {\r\nRE_ENTRANT_CHECK_OFF;\r\nprintk\r\n("FPU emulator: Unknown prefix byte 0x%02x, probably due to\n"\r\n"FPU emulator: self-modifying code! (emulation impossible)\n",\r\nbyte1);\r\nRE_ENTRANT_CHECK_ON;\r\nEXCEPTION(EX_INTERNAL | 0x126);\r\nmath_abort(FPU_info, SIGILL);\r\n}\r\ndo_another_FPU_instruction:\r\nno_ip_update = 0;\r\nFPU_EIP++;\r\nif (addr_modes.default_mode) {\r\nif (FPU_EIP > code_limit)\r\nmath_abort(FPU_info, SIGSEGV);\r\n}\r\nif ((byte1 & 0xf8) != 0xd8) {\r\nif (byte1 == FWAIT_OPCODE) {\r\nif (partial_status & SW_Summary)\r\ngoto do_the_FPU_interrupt;\r\nelse\r\ngoto FPU_fwait_done;\r\n}\r\n#ifdef PARANOID\r\nEXCEPTION(EX_INTERNAL | 0x128);\r\nmath_abort(FPU_info, SIGILL);\r\n#endif\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(1);\r\nFPU_get_user(FPU_modrm, (u_char __user *) FPU_EIP);\r\nRE_ENTRANT_CHECK_ON;\r\nFPU_EIP++;\r\nif (partial_status & SW_Summary) {\r\ncode = (FPU_modrm << 8) | byte1;\r\nif (!((((code & 0xf803) == 0xe003) ||\r\n(((code & 0x3003) == 0x3001) &&\r\n((code & 0xc000) != 0xc000))))) {\r\ndo_the_FPU_interrupt:\r\nFPU_EIP = FPU_ORIG_EIP;\r\nRE_ENTRANT_CHECK_OFF;\r\ncurrent->thread.trap_no = 16;\r\ncurrent->thread.error_code = 0;\r\nsend_sig(SIGFPE, current, 1);\r\nreturn;\r\n}\r\n}\r\nentry_sel_off.offset = FPU_ORIG_EIP;\r\nentry_sel_off.selector = FPU_CS;\r\nentry_sel_off.opcode = (byte1 << 8) | FPU_modrm;\r\nentry_sel_off.empty = 0;\r\nFPU_rm = FPU_modrm & 7;\r\nif (FPU_modrm < 0300) {\r\nif ((addr_modes.default_mode & SIXTEEN)\r\n^ (addr_modes.override.address_size == ADDR_SIZE_PREFIX))\r\ndata_address =\r\nFPU_get_address_16(FPU_modrm, &FPU_EIP,\r\n&data_sel_off, addr_modes);\r\nelse\r\ndata_address =\r\nFPU_get_address(FPU_modrm, &FPU_EIP, &data_sel_off,\r\naddr_modes);\r\nif (addr_modes.default_mode) {\r\nif (FPU_EIP - 1 > code_limit)\r\nmath_abort(FPU_info, SIGSEGV);\r\n}\r\nif (!(byte1 & 1)) {\r\nunsigned short status1 = partial_status;\r\nst0_ptr = &st(0);\r\nst0_tag = FPU_gettag0();\r\nif (NOT_EMPTY_ST0) {\r\nif (addr_modes.default_mode & PROTECTED) {\r\nif (access_limit <\r\ndata_sizes_16[(byte1 >> 1) & 3])\r\nmath_abort(FPU_info, SIGSEGV);\r\n}\r\nunmasked = 0;\r\nswitch ((byte1 >> 1) & 3) {\r\ncase 0:\r\nunmasked =\r\nFPU_load_single((float __user *)\r\ndata_address,\r\n&loaded_data);\r\nloaded_tag = unmasked & 0xff;\r\nunmasked &= ~0xff;\r\nbreak;\r\ncase 1:\r\nloaded_tag =\r\nFPU_load_int32((long __user *)\r\ndata_address,\r\n&loaded_data);\r\nbreak;\r\ncase 2:\r\nunmasked =\r\nFPU_load_double((double __user *)\r\ndata_address,\r\n&loaded_data);\r\nloaded_tag = unmasked & 0xff;\r\nunmasked &= ~0xff;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nloaded_tag =\r\nFPU_load_int16((short __user *)\r\ndata_address,\r\n&loaded_data);\r\nbreak;\r\n}\r\nif (((st0_tag == TAG_Special) && isNaN(st0_ptr))\r\n|| ((loaded_tag == TAG_Special)\r\n&& isNaN(&loaded_data))) {\r\npartial_status = status1;\r\nif ((FPU_modrm & 0x30) == 0x10) {\r\nEXCEPTION(EX_Invalid);\r\nsetcc(SW_C3 | SW_C2 | SW_C0);\r\nif ((FPU_modrm & 0x08)\r\n&& (control_word &\r\nCW_Invalid))\r\nFPU_pop();\r\n} else {\r\nif (loaded_tag == TAG_Special)\r\nloaded_tag =\r\nFPU_Special\r\n(&loaded_data);\r\n#ifdef PECULIAR_486\r\nif ((FPU_modrm & 0x28) == 0x20)\r\nreal_2op_NaN\r\n(&loaded_data,\r\nloaded_tag, 0,\r\n&loaded_data);\r\nelse\r\n#endif\r\nreal_2op_NaN\r\n(&loaded_data,\r\nloaded_tag, 0,\r\nst0_ptr);\r\n}\r\ngoto reg_mem_instr_done;\r\n}\r\nif (unmasked && !((FPU_modrm & 0x30) == 0x10)) {\r\nif ((FPU_modrm & 0x38) == 0x38) {\r\nif ((st0_tag == TAG_Zero) &&\r\n((loaded_tag == TAG_Valid)\r\n|| (loaded_tag ==\r\nTAG_Special\r\n&&\r\nisdenormal\r\n(&loaded_data)))) {\r\nif (FPU_divide_by_zero\r\n(0,\r\ngetsign\r\n(&loaded_data))\r\n< 0) {\r\npartial_status\r\n&=\r\n~SW_Denorm_Op;\r\npartial_status\r\n|=\r\nstatus1 &\r\nSW_Denorm_Op;\r\n} else\r\nsetsign(st0_ptr,\r\ngetsign\r\n(&loaded_data));\r\n}\r\n}\r\ngoto reg_mem_instr_done;\r\n}\r\nswitch ((FPU_modrm >> 3) & 7) {\r\ncase 0:\r\nclear_C1();\r\nFPU_add(&loaded_data, loaded_tag, 0,\r\ncontrol_word);\r\nbreak;\r\ncase 1:\r\nclear_C1();\r\nFPU_mul(&loaded_data, loaded_tag, 0,\r\ncontrol_word);\r\nbreak;\r\ncase 2:\r\nFPU_compare_st_data(&loaded_data,\r\nloaded_tag);\r\nbreak;\r\ncase 3:\r\nif (!FPU_compare_st_data\r\n(&loaded_data, loaded_tag)\r\n&& !unmasked)\r\nFPU_pop();\r\nbreak;\r\ncase 4:\r\nclear_C1();\r\nFPU_sub(LOADED | loaded_tag,\r\n(int)&loaded_data,\r\ncontrol_word);\r\nbreak;\r\ncase 5:\r\nclear_C1();\r\nFPU_sub(REV | LOADED | loaded_tag,\r\n(int)&loaded_data,\r\ncontrol_word);\r\nbreak;\r\ncase 6:\r\nclear_C1();\r\nFPU_div(LOADED | loaded_tag,\r\n(int)&loaded_data,\r\ncontrol_word);\r\nbreak;\r\ncase 7:\r\nclear_C1();\r\nif (st0_tag == TAG_Zero)\r\npartial_status = status1;\r\nFPU_div(REV | LOADED | loaded_tag,\r\n(int)&loaded_data,\r\ncontrol_word);\r\nbreak;\r\n}\r\n} else {\r\nif ((FPU_modrm & 0x30) == 0x10) {\r\nEXCEPTION(EX_StackUnder);\r\nsetcc(SW_C3 | SW_C2 | SW_C0);\r\nif ((FPU_modrm & 0x08)\r\n&& (control_word & CW_Invalid))\r\nFPU_pop();\r\n} else\r\nFPU_stack_underflow();\r\n}\r\nreg_mem_instr_done:\r\noperand_address = data_sel_off;\r\n} else {\r\nif (!(no_ip_update =\r\nFPU_load_store(((FPU_modrm & 0x38) | (byte1 & 6))\r\n>> 1, addr_modes, data_address))) {\r\noperand_address = data_sel_off;\r\n}\r\n}\r\n} else {\r\nu_char instr_index = (FPU_modrm & 0x38) | (byte1 & 7);\r\n#ifdef PECULIAR_486\r\noperand_address.offset = 0;\r\noperand_address.selector = FPU_DS;\r\n#endif\r\nst0_ptr = &st(0);\r\nst0_tag = FPU_gettag0();\r\nswitch (type_table[(int)instr_index]) {\r\ncase _NONE_:\r\nbreak;\r\ncase _REG0_:\r\nif (!NOT_EMPTY_ST0) {\r\nFPU_stack_underflow();\r\ngoto FPU_instruction_done;\r\n}\r\nbreak;\r\ncase _REGIi:\r\nif (!NOT_EMPTY_ST0 || !NOT_EMPTY(FPU_rm)) {\r\nFPU_stack_underflow_i(FPU_rm);\r\ngoto FPU_instruction_done;\r\n}\r\nbreak;\r\ncase _REGIp:\r\nif (!NOT_EMPTY_ST0 || !NOT_EMPTY(FPU_rm)) {\r\nFPU_stack_underflow_pop(FPU_rm);\r\ngoto FPU_instruction_done;\r\n}\r\nbreak;\r\ncase _REGI_:\r\nif (!NOT_EMPTY_ST0 || !NOT_EMPTY(FPU_rm)) {\r\nFPU_stack_underflow();\r\ngoto FPU_instruction_done;\r\n}\r\nbreak;\r\ncase _PUSH_:\r\nbreak;\r\ncase _null_:\r\nFPU_illegal();\r\ngoto FPU_instruction_done;\r\ndefault:\r\nEXCEPTION(EX_INTERNAL | 0x111);\r\ngoto FPU_instruction_done;\r\n}\r\n(*st_instr_table[(int)instr_index]) ();\r\nFPU_instruction_done:\r\n;\r\n}\r\nif (!no_ip_update)\r\ninstruction_address = entry_sel_off;\r\nFPU_fwait_done:\r\n#ifdef DEBUG\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_printall();\r\nRE_ENTRANT_CHECK_ON;\r\n#endif\r\nif (FPU_lookahead && !need_resched()) {\r\nFPU_ORIG_EIP = FPU_EIP - code_base;\r\nif (valid_prefix(&byte1, (u_char __user **) & FPU_EIP,\r\n&addr_modes.override))\r\ngoto do_another_FPU_instruction;\r\n}\r\nif (addr_modes.default_mode)\r\nFPU_EIP -= code_base;\r\nRE_ENTRANT_CHECK_OFF;\r\n}\r\nstatic int valid_prefix(u_char *Byte, u_char __user **fpu_eip,\r\noverrides * override)\r\n{\r\nu_char byte;\r\nu_char __user *ip = *fpu_eip;\r\n*override = (overrides) {\r\n0, 0, PREFIX_DEFAULT};\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(1);\r\nFPU_get_user(byte, ip);\r\nRE_ENTRANT_CHECK_ON;\r\nwhile (1) {\r\nswitch (byte) {\r\ncase ADDR_SIZE_PREFIX:\r\noverride->address_size = ADDR_SIZE_PREFIX;\r\ngoto do_next_byte;\r\ncase OP_SIZE_PREFIX:\r\noverride->operand_size = OP_SIZE_PREFIX;\r\ngoto do_next_byte;\r\ncase PREFIX_CS:\r\noverride->segment = PREFIX_CS_;\r\ngoto do_next_byte;\r\ncase PREFIX_ES:\r\noverride->segment = PREFIX_ES_;\r\ngoto do_next_byte;\r\ncase PREFIX_SS:\r\noverride->segment = PREFIX_SS_;\r\ngoto do_next_byte;\r\ncase PREFIX_FS:\r\noverride->segment = PREFIX_FS_;\r\ngoto do_next_byte;\r\ncase PREFIX_GS:\r\noverride->segment = PREFIX_GS_;\r\ngoto do_next_byte;\r\ncase PREFIX_DS:\r\noverride->segment = PREFIX_DS_;\r\ngoto do_next_byte;\r\ncase PREFIX_REPE:\r\ncase PREFIX_REPNE:\r\ndo_next_byte:\r\nip++;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_code_access_ok(1);\r\nFPU_get_user(byte, ip);\r\nRE_ENTRANT_CHECK_ON;\r\nbreak;\r\ncase FWAIT_OPCODE:\r\n*Byte = byte;\r\nreturn 1;\r\ndefault:\r\nif ((byte & 0xf8) == 0xd8) {\r\n*Byte = byte;\r\n*fpu_eip = ip;\r\nreturn 1;\r\n} else {\r\n*Byte = byte;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nvoid math_abort(struct math_emu_info *info, unsigned int signal)\r\n{\r\nFPU_EIP = FPU_ORIG_EIP;\r\ncurrent->thread.trap_no = 16;\r\ncurrent->thread.error_code = 0;\r\nsend_sig(signal, current, 1);\r\nRE_ENTRANT_CHECK_OFF;\r\n__asm__("movl %0,%%esp ; ret": :"g"(((long)info) - 4));\r\n#ifdef PARANOID\r\nprintk("ERROR: wm-FPU-emu math_abort failed!\n");\r\n#endif\r\n}\r\nint fpregs_soft_set(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct i387_soft_struct *s387 = &target->thread.fpu.state->soft;\r\nvoid *space = s387->st_space;\r\nint ret;\r\nint offset, other, i, tags, regnr, tag, newtop;\r\nRE_ENTRANT_CHECK_OFF;\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, s387, 0,\r\noffsetof(struct i387_soft_struct, st_space));\r\nRE_ENTRANT_CHECK_ON;\r\nif (ret)\r\nreturn ret;\r\nS387->ftop = (S387->swd >> SW_Top_Shift) & 7;\r\noffset = (S387->ftop & 7) * 10;\r\nother = 80 - offset;\r\nRE_ENTRANT_CHECK_OFF;\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\nspace + offset, 0, other);\r\nif (!ret && offset)\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\nspace, 0, offset);\r\nRE_ENTRANT_CHECK_ON;\r\ntags = S387->twd;\r\nnewtop = S387->ftop;\r\nfor (i = 0; i < 8; i++) {\r\nregnr = (i + newtop) & 7;\r\nif (((tags >> ((regnr & 7) * 2)) & 3) != TAG_Empty) {\r\ntag =\r\nFPU_tagof((FPU_REG *) ((u_char *) S387->st_space +\r\n10 * regnr));\r\ntags &= ~(3 << (regnr * 2));\r\ntags |= (tag & 3) << (regnr * 2);\r\n}\r\n}\r\nS387->twd = tags;\r\nreturn ret;\r\n}\r\nint fpregs_soft_get(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct i387_soft_struct *s387 = &target->thread.fpu.state->soft;\r\nconst void *space = s387->st_space;\r\nint ret;\r\nint offset = (S387->ftop & 7) * 10, other = 80 - offset;\r\nRE_ENTRANT_CHECK_OFF;\r\n#ifdef PECULIAR_486\r\nS387->cwd &= ~0xe080;\r\nS387->cwd |= 0xffff0040;\r\nS387->swd = sstatus_word() | 0xffff0000;\r\nS387->twd |= 0xffff0000;\r\nS387->fcs &= ~0xf8000000;\r\nS387->fos |= 0xffff0000;\r\n#endif\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, s387, 0,\r\noffsetof(struct i387_soft_struct, st_space));\r\nif (!ret)\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\nspace + offset, 0, other);\r\nif (!ret)\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\nspace, 0, offset);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn ret;\r\n}
