static int __hwahc_set_cluster_id(struct hwahc *hwahc, u8 cluster_id)\r\n{\r\nint result;\r\nstruct wusbhc *wusbhc = &hwahc->wusbhc;\r\nstruct wahc *wa = &hwahc->wa;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_SET_CLUSTER_ID,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\ncluster_id,\r\nwa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\r\nNULL, 0, 1000 );\r\nif (result < 0)\r\ndev_err(dev, "Cannot set WUSB Cluster ID to 0x%02x: %d\n",\r\ncluster_id, result);\r\nelse\r\nwusbhc->cluster_id = cluster_id;\r\ndev_info(dev, "Wireless USB Cluster ID set to 0x%02x\n", cluster_id);\r\nreturn result;\r\n}\r\nstatic int __hwahc_op_set_num_dnts(struct wusbhc *wusbhc, u8 interval, u8 slots)\r\n{\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nreturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_SET_NUM_DNTS,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\ninterval << 8 | slots,\r\nwa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\r\nNULL, 0, 1000 );\r\n}\r\nstatic int hwahc_op_reset(struct usb_hcd *usb_hcd)\r\n{\r\nint result;\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct device *dev = &hwahc->wa.usb_iface->dev;\r\nmutex_lock(&wusbhc->mutex);\r\nwa_nep_disarm(&hwahc->wa);\r\nresult = __wa_set_feature(&hwahc->wa, WA_RESET);\r\nif (result < 0) {\r\ndev_err(dev, "error commanding HC to reset: %d\n", result);\r\ngoto error_unlock;\r\n}\r\nresult = __wa_wait_status(&hwahc->wa, WA_STATUS_RESETTING, 0);\r\nif (result < 0) {\r\ndev_err(dev, "error waiting for HC to reset: %d\n", result);\r\ngoto error_unlock;\r\n}\r\nerror_unlock:\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn result;\r\n}\r\nstatic int hwahc_op_start(struct usb_hcd *usb_hcd)\r\n{\r\nu8 addr;\r\nint result;\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nresult = -ENOSPC;\r\nmutex_lock(&wusbhc->mutex);\r\naddr = wusb_cluster_id_get();\r\nif (addr == 0)\r\ngoto error_cluster_id_get;\r\nresult = __hwahc_set_cluster_id(hwahc, addr);\r\nif (result < 0)\r\ngoto error_set_cluster_id;\r\nusb_hcd->uses_new_polling = 1;\r\nset_bit(HCD_FLAG_POLL_RH, &usb_hcd->flags);\r\nusb_hcd->state = HC_STATE_RUNNING;\r\nresult = 0;\r\nout:\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn result;\r\nerror_set_cluster_id:\r\nwusb_cluster_id_put(wusbhc->cluster_id);\r\nerror_cluster_id_get:\r\ngoto out;\r\n}\r\nstatic void hwahc_op_stop(struct usb_hcd *usb_hcd)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nmutex_lock(&wusbhc->mutex);\r\nwusb_cluster_id_put(wusbhc->cluster_id);\r\nmutex_unlock(&wusbhc->mutex);\r\n}\r\nstatic int hwahc_op_get_frame_number(struct usb_hcd *usb_hcd)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\ndev_err(wusbhc->dev, "%s (%p [%p]) UNIMPLEMENTED\n", __func__,\r\nusb_hcd, hwahc);\r\nreturn -ENOSYS;\r\n}\r\nstatic int hwahc_op_urb_enqueue(struct usb_hcd *usb_hcd, struct urb *urb,\r\ngfp_t gfp)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nreturn wa_urb_enqueue(&hwahc->wa, urb->ep, urb, gfp);\r\n}\r\nstatic int hwahc_op_urb_dequeue(struct usb_hcd *usb_hcd, struct urb *urb,\r\nint status)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nreturn wa_urb_dequeue(&hwahc->wa, urb);\r\n}\r\nstatic void hwahc_op_endpoint_disable(struct usb_hcd *usb_hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nrpipe_ep_disable(&hwahc->wa, ep);\r\n}\r\nstatic int __hwahc_op_wusbhc_start(struct wusbhc *wusbhc)\r\n{\r\nint result;\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct device *dev = &hwahc->wa.usb_iface->dev;\r\nresult = __wa_set_feature(&hwahc->wa, WA_ENABLE);\r\nif (result < 0) {\r\ndev_err(dev, "error commanding HC to start: %d\n", result);\r\ngoto error_stop;\r\n}\r\nresult = __wa_wait_status(&hwahc->wa, WA_ENABLE, WA_ENABLE);\r\nif (result < 0) {\r\ndev_err(dev, "error waiting for HC to start: %d\n", result);\r\ngoto error_stop;\r\n}\r\nresult = wa_nep_arm(&hwahc->wa, GFP_KERNEL);\r\nif (result < 0) {\r\ndev_err(dev, "cannot listen to notifications: %d\n", result);\r\ngoto error_stop;\r\n}\r\nreturn result;\r\nerror_stop:\r\n__wa_clear_feature(&hwahc->wa, WA_ENABLE);\r\nreturn result;\r\n}\r\nstatic void __hwahc_op_wusbhc_stop(struct wusbhc *wusbhc, int delay)\r\n{\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\r\nint ret;\r\nret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_CHAN_STOP,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\ndelay * 1000,\r\niface_no,\r\nNULL, 0, 1000 );\r\nif (ret == 0)\r\nmsleep(delay);\r\nwa_nep_disarm(&hwahc->wa);\r\n__wa_stop(&hwahc->wa);\r\n}\r\nstatic int __hwahc_op_bwa_set(struct wusbhc *wusbhc, s8 stream_index,\r\nconst struct uwb_mas_bm *mas)\r\n{\r\nint result;\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nu8 mas_le[UWB_NUM_MAS/8];\r\nresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_SET_STREAM_IDX,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nstream_index,\r\nwa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\r\nNULL, 0, 1000 );\r\nif (result < 0) {\r\ndev_err(dev, "Cannot set WUSB stream index: %d\n", result);\r\ngoto out;\r\n}\r\nuwb_mas_bm_copy_le(mas_le, mas);\r\nresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_SET_WUSB_MAS,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, wa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\r\nmas_le, 32, 1000 );\r\nif (result < 0)\r\ndev_err(dev, "Cannot set WUSB MAS allocation: %d\n", result);\r\nout:\r\nreturn result;\r\n}\r\nstatic int __hwahc_op_mmcie_add(struct wusbhc *wusbhc, u8 interval,\r\nu8 repeat_cnt, u8 handle,\r\nstruct wuie_hdr *wuie)\r\n{\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\r\nreturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_ADD_MMC_IE,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\ninterval << 8 | repeat_cnt,\r\nhandle << 8 | iface_no,\r\nwuie, wuie->bLength, 1000 );\r\n}\r\nstatic int __hwahc_op_mmcie_rm(struct wusbhc *wusbhc, u8 handle)\r\n{\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\r\nreturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_REMOVE_MMC_IE,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, handle << 8 | iface_no,\r\nNULL, 0, 1000 );\r\n}\r\nstatic int __hwahc_op_dev_info_set(struct wusbhc *wusbhc,\r\nstruct wusb_dev *wusb_dev)\r\n{\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\r\nstruct hwa_dev_info *dev_info;\r\nint ret;\r\ndev_info = kzalloc(sizeof(struct hwa_dev_info), GFP_KERNEL);\r\nif (!dev_info)\r\nreturn -ENOMEM;\r\nuwb_mas_bm_copy_le(dev_info->bmDeviceAvailability,\r\n&wusb_dev->availability);\r\ndev_info->bDeviceAddress = wusb_dev->addr;\r\nif (wusb_dev->wusb_cap_descr)\r\ndev_info->wPHYRates = wusb_dev->wusb_cap_descr->wPHYRates;\r\nelse\r\ndev_info->wPHYRates = cpu_to_le16(USB_WIRELESS_PHY_53);\r\nret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nWUSB_REQ_SET_DEV_INFO,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, wusb_dev->port_idx << 8 | iface_no,\r\ndev_info, sizeof(struct hwa_dev_info),\r\n1000 );\r\nkfree(dev_info);\r\nreturn ret;\r\n}\r\nstatic int __hwahc_dev_set_key(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\r\nconst void *key, size_t key_size,\r\nu8 key_idx)\r\n{\r\nint result = -ENOMEM;\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\r\nstruct usb_key_descriptor *keyd;\r\nsize_t keyd_len;\r\nkeyd_len = sizeof(*keyd) + key_size;\r\nkeyd = kzalloc(keyd_len, GFP_KERNEL);\r\nif (keyd == NULL)\r\nreturn -ENOMEM;\r\nkeyd->bLength = keyd_len;\r\nkeyd->bDescriptorType = USB_DT_KEY;\r\nkeyd->tTKID[0] = (tkid >> 0) & 0xff;\r\nkeyd->tTKID[1] = (tkid >> 8) & 0xff;\r\nkeyd->tTKID[2] = (tkid >> 16) & 0xff;\r\nmemcpy(keyd->bKeyData, key, key_size);\r\nresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nUSB_REQ_SET_DESCRIPTOR,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nUSB_DT_KEY << 8 | key_idx,\r\nport_idx << 8 | iface_no,\r\nkeyd, keyd_len, 1000 );\r\nkzfree(keyd);\r\nreturn result;\r\n}\r\nstatic int __hwahc_op_set_ptk(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\r\nconst void *key, size_t key_size)\r\n{\r\nint result = -ENOMEM;\r\nstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nstruct wahc *wa = &hwahc->wa;\r\nu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\r\nu8 encryption_value;\r\nif (key) {\r\nu8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_PTK,\r\nWUSB_KEY_INDEX_ORIGINATOR_HOST);\r\nresult = __hwahc_dev_set_key(wusbhc, port_idx, tkid,\r\nkey, key_size, key_idx);\r\nif (result < 0)\r\ngoto error_set_key;\r\nencryption_value = wusbhc->ccm1_etd->bEncryptionValue;\r\n} else {\r\nencryption_value = 0;\r\n}\r\nresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nUSB_REQ_SET_ENCRYPTION,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nencryption_value, port_idx << 8 | iface_no,\r\nNULL, 0, 1000 );\r\nif (result < 0)\r\ndev_err(wusbhc->dev, "Can't set host's WUSB encryption for "\r\n"port index %u to %s (value %d): %d\n", port_idx,\r\nwusb_et_name(wusbhc->ccm1_etd->bEncryptionType),\r\nwusbhc->ccm1_etd->bEncryptionValue, result);\r\nerror_set_key:\r\nreturn result;\r\n}\r\nstatic int __hwahc_op_set_gtk(struct wusbhc *wusbhc, u32 tkid,\r\nconst void *key, size_t key_size)\r\n{\r\nu8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_GTK,\r\nWUSB_KEY_INDEX_ORIGINATOR_HOST);\r\nreturn __hwahc_dev_set_key(wusbhc, 0, tkid, key, key_size, key_idx);\r\n}\r\nstatic int wa_fill_descr(struct wahc *wa)\r\n{\r\nint result;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nchar *itr;\r\nstruct usb_device *usb_dev = wa->usb_dev;\r\nstruct usb_descriptor_header *hdr;\r\nstruct usb_wa_descriptor *wa_descr;\r\nsize_t itr_size, actconfig_idx;\r\nactconfig_idx = (usb_dev->actconfig - usb_dev->config) /\r\nsizeof(usb_dev->config[0]);\r\nitr = usb_dev->rawdescriptors[actconfig_idx];\r\nitr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\r\nwhile (itr_size >= sizeof(*hdr)) {\r\nhdr = (struct usb_descriptor_header *) itr;\r\ndev_dbg(dev, "Extra device descriptor: "\r\n"type %02x/%u bytes @ %zu (%zu left)\n",\r\nhdr->bDescriptorType, hdr->bLength,\r\n(itr - usb_dev->rawdescriptors[actconfig_idx]),\r\nitr_size);\r\nif (hdr->bDescriptorType == USB_DT_WIRE_ADAPTER)\r\ngoto found;\r\nitr += hdr->bLength;\r\nitr_size -= hdr->bLength;\r\n}\r\ndev_err(dev, "cannot find Wire Adapter Class descriptor\n");\r\nreturn -ENODEV;\r\nfound:\r\nresult = -EINVAL;\r\nif (hdr->bLength > itr_size) {\r\ndev_err(dev, "incomplete Wire Adapter Class descriptor "\r\n"(%zu bytes left, %u needed)\n",\r\nitr_size, hdr->bLength);\r\ngoto error;\r\n}\r\nif (hdr->bLength < sizeof(*wa->wa_descr)) {\r\ndev_err(dev, "short Wire Adapter Class descriptor\n");\r\ngoto error;\r\n}\r\nwa->wa_descr = wa_descr = (struct usb_wa_descriptor *) hdr;\r\nwa_descr->bcdWAVersion = le16_to_cpu(wa_descr->bcdWAVersion);\r\nwa_descr->wNumRPipes = le16_to_cpu(wa_descr->wNumRPipes);\r\nwa_descr->wRPipeMaxBlock = le16_to_cpu(wa_descr->wRPipeMaxBlock);\r\nif (wa_descr->bcdWAVersion > 0x0100)\r\ndev_warn(dev, "Wire Adapter v%d.%d newer than groked v1.0\n",\r\nwa_descr->bcdWAVersion & 0xff00 >> 8,\r\nwa_descr->bcdWAVersion & 0x00ff);\r\nresult = 0;\r\nerror:\r\nreturn result;\r\n}\r\nstatic int hwahc_security_create(struct hwahc *hwahc)\r\n{\r\nint result;\r\nstruct wusbhc *wusbhc = &hwahc->wusbhc;\r\nstruct usb_device *usb_dev = hwahc->wa.usb_dev;\r\nstruct device *dev = &usb_dev->dev;\r\nstruct usb_security_descriptor *secd;\r\nstruct usb_encryption_descriptor *etd;\r\nvoid *itr, *top;\r\nsize_t itr_size, needed, bytes;\r\nu8 index;\r\nchar buf[64];\r\nindex = (usb_dev->actconfig - usb_dev->config) /\r\nsizeof(usb_dev->config[0]);\r\nitr = usb_dev->rawdescriptors[index];\r\nitr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\r\ntop = itr + itr_size;\r\nresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\r\nle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\r\nUSB_DT_SECURITY, (void **) &secd);\r\nif (result == -1) {\r\ndev_warn(dev, "BUG? WUSB host has no security descriptors\n");\r\nreturn 0;\r\n}\r\nneeded = sizeof(*secd);\r\nif (top - (void *)secd < needed) {\r\ndev_err(dev, "BUG? Not enough data to process security "\r\n"descriptor header (%zu bytes left vs %zu needed)\n",\r\ntop - (void *) secd, needed);\r\nreturn 0;\r\n}\r\nneeded = le16_to_cpu(secd->wTotalLength);\r\nif (top - (void *)secd < needed) {\r\ndev_err(dev, "BUG? Not enough data to process security "\r\n"descriptors (%zu bytes left vs %zu needed)\n",\r\ntop - (void *) secd, needed);\r\nreturn 0;\r\n}\r\nitr = (void *) secd + sizeof(*secd);\r\ntop = (void *) secd + le16_to_cpu(secd->wTotalLength);\r\nindex = 0;\r\nbytes = 0;\r\nwhile (itr < top) {\r\netd = itr;\r\nif (top - itr < sizeof(*etd)) {\r\ndev_err(dev, "BUG: bad host security descriptor; "\r\n"not enough data (%zu vs %zu left)\n",\r\ntop - itr, sizeof(*etd));\r\nbreak;\r\n}\r\nif (etd->bLength < sizeof(*etd)) {\r\ndev_err(dev, "BUG: bad host encryption descriptor; "\r\n"descriptor is too short "\r\n"(%zu vs %zu needed)\n",\r\n(size_t)etd->bLength, sizeof(*etd));\r\nbreak;\r\n}\r\nitr += etd->bLength;\r\nbytes += snprintf(buf + bytes, sizeof(buf) - bytes,\r\n"%s (0x%02x) ",\r\nwusb_et_name(etd->bEncryptionType),\r\netd->bEncryptionValue);\r\nwusbhc->ccm1_etd = etd;\r\n}\r\ndev_info(dev, "supported encryption types: %s\n", buf);\r\nif (wusbhc->ccm1_etd == NULL) {\r\ndev_err(dev, "E: host doesn't support CCM-1 crypto\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hwahc_security_release(struct hwahc *hwahc)\r\n{\r\n}\r\nstatic int hwahc_create(struct hwahc *hwahc, struct usb_interface *iface)\r\n{\r\nint result;\r\nstruct device *dev = &iface->dev;\r\nstruct wusbhc *wusbhc = &hwahc->wusbhc;\r\nstruct wahc *wa = &hwahc->wa;\r\nstruct usb_device *usb_dev = interface_to_usbdev(iface);\r\nwa->usb_dev = usb_get_dev(usb_dev);\r\nwa->usb_iface = usb_get_intf(iface);\r\nwusbhc->dev = dev;\r\nwusbhc->uwb_rc = uwb_rc_get_by_grandpa(iface->dev.parent);\r\nif (wusbhc->uwb_rc == NULL) {\r\nresult = -ENODEV;\r\ndev_err(dev, "Cannot get associated UWB Host Controller\n");\r\ngoto error_rc_get;\r\n}\r\nresult = wa_fill_descr(wa);\r\nif (result < 0)\r\ngoto error_fill_descriptor;\r\nif (wa->wa_descr->bNumPorts > USB_MAXCHILDREN) {\r\ndev_err(dev, "FIXME: USB_MAXCHILDREN too low for WUSB "\r\n"adapter (%u ports)\n", wa->wa_descr->bNumPorts);\r\nwusbhc->ports_max = USB_MAXCHILDREN;\r\n} else {\r\nwusbhc->ports_max = wa->wa_descr->bNumPorts;\r\n}\r\nwusbhc->mmcies_max = wa->wa_descr->bNumMMCIEs;\r\nwusbhc->start = __hwahc_op_wusbhc_start;\r\nwusbhc->stop = __hwahc_op_wusbhc_stop;\r\nwusbhc->mmcie_add = __hwahc_op_mmcie_add;\r\nwusbhc->mmcie_rm = __hwahc_op_mmcie_rm;\r\nwusbhc->dev_info_set = __hwahc_op_dev_info_set;\r\nwusbhc->bwa_set = __hwahc_op_bwa_set;\r\nwusbhc->set_num_dnts = __hwahc_op_set_num_dnts;\r\nwusbhc->set_ptk = __hwahc_op_set_ptk;\r\nwusbhc->set_gtk = __hwahc_op_set_gtk;\r\nresult = hwahc_security_create(hwahc);\r\nif (result < 0) {\r\ndev_err(dev, "Can't initialize security: %d\n", result);\r\ngoto error_security_create;\r\n}\r\nwa->wusb = wusbhc;\r\nresult = wusbhc_create(&hwahc->wusbhc);\r\nif (result < 0) {\r\ndev_err(dev, "Can't create WUSB HC structures: %d\n", result);\r\ngoto error_wusbhc_create;\r\n}\r\nresult = wa_create(&hwahc->wa, iface);\r\nif (result < 0)\r\ngoto error_wa_create;\r\nreturn 0;\r\nerror_wa_create:\r\nwusbhc_destroy(&hwahc->wusbhc);\r\nerror_wusbhc_create:\r\nerror_security_create:\r\nerror_fill_descriptor:\r\nuwb_rc_put(wusbhc->uwb_rc);\r\nerror_rc_get:\r\nusb_put_intf(iface);\r\nusb_put_dev(usb_dev);\r\nreturn result;\r\n}\r\nstatic void hwahc_destroy(struct hwahc *hwahc)\r\n{\r\nstruct wusbhc *wusbhc = &hwahc->wusbhc;\r\nmutex_lock(&wusbhc->mutex);\r\n__wa_destroy(&hwahc->wa);\r\nwusbhc_destroy(&hwahc->wusbhc);\r\nhwahc_security_release(hwahc);\r\nhwahc->wusbhc.dev = NULL;\r\nuwb_rc_put(wusbhc->uwb_rc);\r\nusb_put_intf(hwahc->wa.usb_iface);\r\nusb_put_dev(hwahc->wa.usb_dev);\r\nmutex_unlock(&wusbhc->mutex);\r\n}\r\nstatic void hwahc_init(struct hwahc *hwahc)\r\n{\r\nwa_init(&hwahc->wa);\r\n}\r\nstatic int hwahc_probe(struct usb_interface *usb_iface,\r\nconst struct usb_device_id *id)\r\n{\r\nint result;\r\nstruct usb_hcd *usb_hcd;\r\nstruct wusbhc *wusbhc;\r\nstruct hwahc *hwahc;\r\nstruct device *dev = &usb_iface->dev;\r\nresult = -ENOMEM;\r\nusb_hcd = usb_create_hcd(&hwahc_hc_driver, &usb_iface->dev, "wusb-hwa");\r\nif (usb_hcd == NULL) {\r\ndev_err(dev, "unable to allocate instance\n");\r\ngoto error_alloc;\r\n}\r\nusb_hcd->wireless = 1;\r\nset_bit(HCD_FLAG_SAW_IRQ, &usb_hcd->flags);\r\nwusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nhwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nhwahc_init(hwahc);\r\nresult = hwahc_create(hwahc, usb_iface);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot initialize internals: %d\n", result);\r\ngoto error_hwahc_create;\r\n}\r\nresult = usb_add_hcd(usb_hcd, 0, 0);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot add HCD: %d\n", result);\r\ngoto error_add_hcd;\r\n}\r\nresult = wusbhc_b_create(&hwahc->wusbhc);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot setup phase B of WUSBHC: %d\n", result);\r\ngoto error_wusbhc_b_create;\r\n}\r\nreturn 0;\r\nerror_wusbhc_b_create:\r\nusb_remove_hcd(usb_hcd);\r\nerror_add_hcd:\r\nhwahc_destroy(hwahc);\r\nerror_hwahc_create:\r\nusb_put_hcd(usb_hcd);\r\nerror_alloc:\r\nreturn result;\r\n}\r\nstatic void hwahc_disconnect(struct usb_interface *usb_iface)\r\n{\r\nstruct usb_hcd *usb_hcd;\r\nstruct wusbhc *wusbhc;\r\nstruct hwahc *hwahc;\r\nusb_hcd = usb_get_intfdata(usb_iface);\r\nwusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nhwahc = container_of(wusbhc, struct hwahc, wusbhc);\r\nwusbhc_b_destroy(&hwahc->wusbhc);\r\nusb_remove_hcd(usb_hcd);\r\nhwahc_destroy(hwahc);\r\nusb_put_hcd(usb_hcd);\r\n}\r\nstatic int __init hwahc_driver_init(void)\r\n{\r\nreturn usb_register(&hwahc_driver);\r\n}\r\nstatic void __exit hwahc_driver_exit(void)\r\n{\r\nusb_deregister(&hwahc_driver);\r\n}
