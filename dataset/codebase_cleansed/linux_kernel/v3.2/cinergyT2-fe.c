static uint16_t compute_tps(struct dvb_frontend_parameters *p)\r\n{\r\nstruct dvb_ofdm_parameters *op = &p->u.ofdm;\r\nuint16_t tps = 0;\r\nswitch (op->code_rate_HP) {\r\ncase FEC_2_3:\r\ntps |= (1 << 7);\r\nbreak;\r\ncase FEC_3_4:\r\ntps |= (2 << 7);\r\nbreak;\r\ncase FEC_5_6:\r\ntps |= (3 << 7);\r\nbreak;\r\ncase FEC_7_8:\r\ntps |= (4 << 7);\r\nbreak;\r\ncase FEC_1_2:\r\ncase FEC_AUTO:\r\ndefault:\r\n;\r\n}\r\nswitch (op->code_rate_LP) {\r\ncase FEC_2_3:\r\ntps |= (1 << 4);\r\nbreak;\r\ncase FEC_3_4:\r\ntps |= (2 << 4);\r\nbreak;\r\ncase FEC_5_6:\r\ntps |= (3 << 4);\r\nbreak;\r\ncase FEC_7_8:\r\ntps |= (4 << 4);\r\nbreak;\r\ncase FEC_1_2:\r\ncase FEC_AUTO:\r\ndefault:\r\n;\r\n}\r\nswitch (op->constellation) {\r\ncase QAM_16:\r\ntps |= (1 << 13);\r\nbreak;\r\ncase QAM_64:\r\ntps |= (2 << 13);\r\nbreak;\r\ncase QPSK:\r\ndefault:\r\n;\r\n}\r\nswitch (op->transmission_mode) {\r\ncase TRANSMISSION_MODE_8K:\r\ntps |= (1 << 0);\r\nbreak;\r\ncase TRANSMISSION_MODE_2K:\r\ndefault:\r\n;\r\n}\r\nswitch (op->guard_interval) {\r\ncase GUARD_INTERVAL_1_16:\r\ntps |= (1 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ntps |= (2 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ntps |= (3 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_32:\r\ndefault:\r\n;\r\n}\r\nswitch (op->hierarchy_information) {\r\ncase HIERARCHY_1:\r\ntps |= (1 << 10);\r\nbreak;\r\ncase HIERARCHY_2:\r\ntps |= (2 << 10);\r\nbreak;\r\ncase HIERARCHY_4:\r\ntps |= (3 << 10);\r\nbreak;\r\ncase HIERARCHY_NONE:\r\ndefault:\r\n;\r\n}\r\nreturn tps;\r\n}\r\nstatic int cinergyt2_fe_read_status(struct dvb_frontend *fe,\r\nfe_status_t *status)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nstruct dvbt_get_status_msg result;\r\nu8 cmd[] = { CINERGYT2_EP1_GET_TUNER_STATUS };\r\nint ret;\r\nret = dvb_usb_generic_rw(state->d, cmd, sizeof(cmd), (u8 *)&result,\r\nsizeof(result), 0);\r\nif (ret < 0)\r\nreturn ret;\r\n*status = 0;\r\nif (0xffff - le16_to_cpu(result.gain) > 30)\r\n*status |= FE_HAS_SIGNAL;\r\nif (result.lock_bits & (1 << 6))\r\n*status |= FE_HAS_LOCK;\r\nif (result.lock_bits & (1 << 5))\r\n*status |= FE_HAS_SYNC;\r\nif (result.lock_bits & (1 << 4))\r\n*status |= FE_HAS_CARRIER;\r\nif (result.lock_bits & (1 << 1))\r\n*status |= FE_HAS_VITERBI;\r\nif ((*status & (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)) !=\r\n(FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC))\r\n*status &= ~FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nstruct dvbt_get_status_msg status;\r\nchar cmd[] = { CINERGYT2_EP1_GET_TUNER_STATUS };\r\nint ret;\r\nret = dvb_usb_generic_rw(state->d, cmd, sizeof(cmd), (char *)&status,\r\nsizeof(status), 0);\r\nif (ret < 0)\r\nreturn ret;\r\n*ber = le32_to_cpu(status.viterbi_error_rate);\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_unc_blocks(struct dvb_frontend *fe, u32 *unc)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nstruct dvbt_get_status_msg status;\r\nu8 cmd[] = { CINERGYT2_EP1_GET_TUNER_STATUS };\r\nint ret;\r\nret = dvb_usb_generic_rw(state->d, cmd, sizeof(cmd), (u8 *)&status,\r\nsizeof(status), 0);\r\nif (ret < 0) {\r\nerr("cinergyt2_fe_read_unc_blocks() Failed! (Error=%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\n*unc = le32_to_cpu(status.uncorrected_block_count);\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nstruct dvbt_get_status_msg status;\r\nchar cmd[] = { CINERGYT2_EP1_GET_TUNER_STATUS };\r\nint ret;\r\nret = dvb_usb_generic_rw(state->d, cmd, sizeof(cmd), (char *)&status,\r\nsizeof(status), 0);\r\nif (ret < 0) {\r\nerr("cinergyt2_fe_read_signal_strength() Failed!"\r\n" (Error=%d)\n", ret);\r\nreturn ret;\r\n}\r\n*strength = (0xffff - le16_to_cpu(status.gain));\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nstruct dvbt_get_status_msg status;\r\nchar cmd[] = { CINERGYT2_EP1_GET_TUNER_STATUS };\r\nint ret;\r\nret = dvb_usb_generic_rw(state->d, cmd, sizeof(cmd), (char *)&status,\r\nsizeof(status), 0);\r\nif (ret < 0) {\r\nerr("cinergyt2_fe_read_snr() Failed! (Error=%d)\n", ret);\r\nreturn ret;\r\n}\r\n*snr = (status.snr << 8) | status.snr;\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_init(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_sleep(struct dvb_frontend *fe)\r\n{\r\ndeb_info("cinergyt2_fe_sleep() Called\n");\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 800;\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_set_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *fep)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nstruct dvbt_set_parameters_msg param;\r\nchar result[2];\r\nint err;\r\nparam.cmd = CINERGYT2_EP1_SET_TUNER_PARAMETERS;\r\nparam.tps = cpu_to_le16(compute_tps(fep));\r\nparam.freq = cpu_to_le32(fep->frequency / 1000);\r\nparam.bandwidth = 8 - fep->u.ofdm.bandwidth - BANDWIDTH_8_MHZ;\r\nparam.flags = 0;\r\nerr = dvb_usb_generic_rw(state->d,\r\n(char *)&param, sizeof(param),\r\nresult, sizeof(result), 0);\r\nif (err < 0)\r\nerr("cinergyt2_fe_set_frontend() Failed! err=%d\n", err);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int cinergyt2_fe_get_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *fep)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cinergyt2_fe_release(struct dvb_frontend *fe)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nif (state != NULL)\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *cinergyt2_fe_attach(struct dvb_usb_device *d)\r\n{\r\nstruct cinergyt2_fe_state *s = kzalloc(sizeof(\r\nstruct cinergyt2_fe_state), GFP_KERNEL);\r\nif (s == NULL)\r\nreturn NULL;\r\ns->d = d;\r\nmemcpy(&s->fe.ops, &cinergyt2_fe_ops, sizeof(struct dvb_frontend_ops));\r\ns->fe.demodulator_priv = s;\r\nreturn &s->fe;\r\n}
