static int txx9aclc_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct txx9aclc_dmadata *dmadata = runtime->private_data;\r\nint ret;\r\nret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(rtd->platform->dev,\r\n"runtime->dma_area = %#lx dma_addr = %#lx dma_bytes = %zd "\r\n"runtime->min_align %ld\n",\r\n(unsigned long)runtime->dma_area,\r\n(unsigned long)runtime->dma_addr, runtime->dma_bytes,\r\nruntime->min_align);\r\ndev_dbg(rtd->platform->dev,\r\n"periods %d period_bytes %d stream %d\n",\r\nparams_periods(params), params_period_bytes(params),\r\nsubstream->stream);\r\ndmadata->substream = substream;\r\ndmadata->pos = 0;\r\nreturn 0;\r\n}\r\nstatic int txx9aclc_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int txx9aclc_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct txx9aclc_dmadata *dmadata = runtime->private_data;\r\ndmadata->dma_addr = runtime->dma_addr;\r\ndmadata->buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\r\ndmadata->period_bytes = snd_pcm_lib_period_bytes(substream);\r\nif (dmadata->buffer_bytes == dmadata->period_bytes) {\r\ndmadata->frag_bytes = dmadata->period_bytes >> 1;\r\ndmadata->frags = 2;\r\n} else {\r\ndmadata->frag_bytes = dmadata->period_bytes;\r\ndmadata->frags = dmadata->buffer_bytes / dmadata->period_bytes;\r\n}\r\ndmadata->frag_count = 0;\r\ndmadata->pos = 0;\r\nreturn 0;\r\n}\r\nstatic void txx9aclc_dma_complete(void *arg)\r\n{\r\nstruct txx9aclc_dmadata *dmadata = arg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dmadata->dma_lock, flags);\r\nif (dmadata->frag_count >= 0) {\r\ndmadata->dmacount--;\r\nBUG_ON(dmadata->dmacount < 0);\r\ntasklet_schedule(&dmadata->tasklet);\r\n}\r\nspin_unlock_irqrestore(&dmadata->dma_lock, flags);\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\ntxx9aclc_dma_submit(struct txx9aclc_dmadata *dmadata, dma_addr_t buf_dma_addr)\r\n{\r\nstruct dma_chan *chan = dmadata->dma_chan;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist sg;\r\nsg_init_table(&sg, 1);\r\nsg_set_page(&sg, pfn_to_page(PFN_DOWN(buf_dma_addr)),\r\ndmadata->frag_bytes, buf_dma_addr & (PAGE_SIZE - 1));\r\nsg_dma_address(&sg) = buf_dma_addr;\r\ndesc = chan->device->device_prep_slave_sg(chan, &sg, 1,\r\ndmadata->substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\nDMA_TO_DEVICE : DMA_FROM_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(&chan->dev->device, "cannot prepare slave dma\n");\r\nreturn NULL;\r\n}\r\ndesc->callback = txx9aclc_dma_complete;\r\ndesc->callback_param = dmadata;\r\ndesc->tx_submit(desc);\r\nreturn desc;\r\n}\r\nstatic void txx9aclc_dma_tasklet(unsigned long data)\r\n{\r\nstruct txx9aclc_dmadata *dmadata = (struct txx9aclc_dmadata *)data;\r\nstruct dma_chan *chan = dmadata->dma_chan;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct snd_pcm_substream *substream = dmadata->substream;\r\nu32 ctlbit = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\nACCTL_AUDODMA : ACCTL_AUDIDMA;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dmadata->dma_lock, flags);\r\nif (dmadata->frag_count < 0) {\r\nstruct txx9aclc_plat_drvdata *drvdata = txx9aclc_drvdata;\r\nvoid __iomem *base = drvdata->base;\r\nspin_unlock_irqrestore(&dmadata->dma_lock, flags);\r\nchan->device->device_control(chan, DMA_TERMINATE_ALL, 0);\r\nfor (i = 0; i < NR_DMA_CHAIN; i++) {\r\ndesc = txx9aclc_dma_submit(dmadata,\r\ndmadata->dma_addr + i * dmadata->frag_bytes);\r\nif (!desc)\r\nreturn;\r\n}\r\ndmadata->dmacount = NR_DMA_CHAIN;\r\nchan->device->device_issue_pending(chan);\r\nspin_lock_irqsave(&dmadata->dma_lock, flags);\r\n__raw_writel(ctlbit, base + ACCTLEN);\r\ndmadata->frag_count = NR_DMA_CHAIN % dmadata->frags;\r\nspin_unlock_irqrestore(&dmadata->dma_lock, flags);\r\nreturn;\r\n}\r\nBUG_ON(dmadata->dmacount >= NR_DMA_CHAIN);\r\nwhile (dmadata->dmacount < NR_DMA_CHAIN) {\r\ndmadata->dmacount++;\r\nspin_unlock_irqrestore(&dmadata->dma_lock, flags);\r\ndesc = txx9aclc_dma_submit(dmadata,\r\ndmadata->dma_addr +\r\ndmadata->frag_count * dmadata->frag_bytes);\r\nif (!desc)\r\nreturn;\r\nchan->device->device_issue_pending(chan);\r\nspin_lock_irqsave(&dmadata->dma_lock, flags);\r\ndmadata->frag_count++;\r\ndmadata->frag_count %= dmadata->frags;\r\ndmadata->pos += dmadata->frag_bytes;\r\ndmadata->pos %= dmadata->buffer_bytes;\r\nif ((dmadata->frag_count * dmadata->frag_bytes) %\r\ndmadata->period_bytes == 0)\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nspin_unlock_irqrestore(&dmadata->dma_lock, flags);\r\n}\r\nstatic int txx9aclc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct txx9aclc_dmadata *dmadata = substream->runtime->private_data;\r\nstruct txx9aclc_plat_drvdata *drvdata =txx9aclc_drvdata;\r\nvoid __iomem *base = drvdata->base;\r\nunsigned long flags;\r\nint ret = 0;\r\nu32 ctlbit = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\nACCTL_AUDODMA : ACCTL_AUDIDMA;\r\nspin_lock_irqsave(&dmadata->dma_lock, flags);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ndmadata->frag_count = -1;\r\ntasklet_schedule(&dmadata->tasklet);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\n__raw_writel(ctlbit, base + ACCTLDIS);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\n__raw_writel(ctlbit, base + ACCTLEN);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&dmadata->dma_lock, flags);\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t\r\ntxx9aclc_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct txx9aclc_dmadata *dmadata = substream->runtime->private_data;\r\nreturn bytes_to_frames(substream->runtime, dmadata->pos);\r\n}\r\nstatic int txx9aclc_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct txx9aclc_soc_device *dev = &txx9aclc_soc_device;\r\nstruct txx9aclc_dmadata *dmadata = &dev->dmadata[substream->stream];\r\nint ret;\r\nret = snd_soc_set_runtime_hwparams(substream, &txx9aclc_pcm_hardware);\r\nif (ret)\r\nreturn ret;\r\nret = snd_pcm_hw_constraint_integer(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\nreturn ret;\r\nsubstream->runtime->private_data = dmadata;\r\nreturn 0;\r\n}\r\nstatic int txx9aclc_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct txx9aclc_dmadata *dmadata = substream->runtime->private_data;\r\nstruct dma_chan *chan = dmadata->dma_chan;\r\ndmadata->frag_count = -1;\r\nchan->device->device_control(chan, DMA_TERMINATE_ALL, 0);\r\nreturn 0;\r\n}\r\nstatic void txx9aclc_pcm_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int txx9aclc_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nstruct platform_device *pdev = to_platform_device(dai->platform->dev);\r\nstruct txx9aclc_soc_device *dev;\r\nstruct resource *r;\r\nint i;\r\nint ret;\r\ndev = snd_soc_dai_get_drvdata(dai);\r\ndev->dmadata[0].stream = SNDRV_PCM_STREAM_PLAYBACK;\r\ndev->dmadata[1].stream = SNDRV_PCM_STREAM_CAPTURE;\r\nfor (i = 0; i < 2; i++) {\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, i);\r\nif (!r) {\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\ndev->dmadata[i].dma_res = r;\r\nret = txx9aclc_dma_init(dev, &dev->dmadata[i]);\r\nif (ret)\r\ngoto exit;\r\n}\r\nreturn snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\ncard->dev, 64 * 1024, 4 * 1024 * 1024);\r\nexit:\r\nfor (i = 0; i < 2; i++) {\r\nif (dev->dmadata[i].dma_chan)\r\ndma_release_channel(dev->dmadata[i].dma_chan);\r\ndev->dmadata[i].dma_chan = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct txx9aclc_dmadata *dmadata = param;\r\nchar *devname;\r\nbool found = false;\r\ndevname = kasprintf(GFP_KERNEL, "%s.%d", dmadata->dma_res->name,\r\n(int)dmadata->dma_res->start);\r\nif (strcmp(dev_name(chan->device->dev), devname) == 0) {\r\nchan->private = &dmadata->dma_slave;\r\nfound = true;\r\n}\r\nkfree(devname);\r\nreturn found;\r\n}\r\nstatic int txx9aclc_dma_init(struct txx9aclc_soc_device *dev,\r\nstruct txx9aclc_dmadata *dmadata)\r\n{\r\nstruct txx9aclc_plat_drvdata *drvdata =txx9aclc_drvdata;\r\nstruct txx9dmac_slave *ds = &dmadata->dma_slave;\r\ndma_cap_mask_t mask;\r\nspin_lock_init(&dmadata->dma_lock);\r\nds->reg_width = sizeof(u32);\r\nif (dmadata->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nds->tx_reg = drvdata->physbase + ACAUDODAT;\r\nds->rx_reg = 0;\r\n} else {\r\nds->tx_reg = 0;\r\nds->rx_reg = drvdata->physbase + ACAUDIDAT;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndmadata->dma_chan = dma_request_channel(mask, filter, dmadata);\r\nif (!dmadata->dma_chan) {\r\nprintk(KERN_ERR\r\n"DMA channel for %s is not available\n",\r\ndmadata->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\n"playback" : "capture");\r\nreturn -EBUSY;\r\n}\r\ntasklet_init(&dmadata->tasklet, txx9aclc_dma_tasklet,\r\n(unsigned long)dmadata);\r\nreturn 0;\r\n}\r\nstatic int txx9aclc_pcm_probe(struct snd_soc_platform *platform)\r\n{\r\nsnd_soc_platform_set_drvdata(platform, &txx9aclc_soc_device);\r\nreturn 0;\r\n}\r\nstatic int txx9aclc_pcm_remove(struct snd_soc_platform *platform)\r\n{\r\nstruct txx9aclc_soc_device *dev = snd_soc_platform_get_drvdata(platform);\r\nstruct txx9aclc_plat_drvdata *drvdata = txx9aclc_drvdata;\r\nvoid __iomem *base = drvdata->base;\r\nint i;\r\n__raw_writel(ACCTL_AUDODMA | ACCTL_AUDIDMA, base + ACCTLDIS);\r\n__raw_writel(__raw_readl(base + ACAUDIDAT), base + ACAUDODAT);\r\nfor (i = 0; i < 2; i++) {\r\nstruct txx9aclc_dmadata *dmadata = &dev->dmadata[i];\r\nstruct dma_chan *chan = dmadata->dma_chan;\r\nif (chan) {\r\ndmadata->frag_count = -1;\r\nchan->device->device_control(chan,\r\nDMA_TERMINATE_ALL, 0);\r\ndma_release_channel(chan);\r\n}\r\ndev->dmadata[i].dma_chan = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit txx9aclc_soc_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_platform(&pdev->dev, &txx9aclc_soc_platform);\r\n}\r\nstatic int __devexit txx9aclc_soc_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init snd_txx9aclc_pcm_init(void)\r\n{\r\nreturn platform_driver_register(&txx9aclc_pcm_driver);\r\n}\r\nstatic void __exit snd_txx9aclc_pcm_exit(void)\r\n{\r\nplatform_driver_unregister(&txx9aclc_pcm_driver);\r\n}
