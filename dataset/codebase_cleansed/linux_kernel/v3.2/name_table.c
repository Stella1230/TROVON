static int hash(int x)\r\n{\r\nreturn x & (tipc_nametbl_size - 1);\r\n}\r\nstatic struct publication *publ_create(u32 type, u32 lower, u32 upper,\r\nu32 scope, u32 node, u32 port_ref,\r\nu32 key)\r\n{\r\nstruct publication *publ = kzalloc(sizeof(*publ), GFP_ATOMIC);\r\nif (publ == NULL) {\r\nwarn("Publication creation failure, no memory\n");\r\nreturn NULL;\r\n}\r\npubl->type = type;\r\npubl->lower = lower;\r\npubl->upper = upper;\r\npubl->scope = scope;\r\npubl->node = node;\r\npubl->ref = port_ref;\r\npubl->key = key;\r\nINIT_LIST_HEAD(&publ->local_list);\r\nINIT_LIST_HEAD(&publ->pport_list);\r\nINIT_LIST_HEAD(&publ->subscr.nodesub_list);\r\nreturn publ;\r\n}\r\nstatic struct sub_seq *tipc_subseq_alloc(u32 cnt)\r\n{\r\nstruct sub_seq *sseq = kcalloc(cnt, sizeof(struct sub_seq), GFP_ATOMIC);\r\nreturn sseq;\r\n}\r\nstatic struct name_seq *tipc_nameseq_create(u32 type, struct hlist_head *seq_head)\r\n{\r\nstruct name_seq *nseq = kzalloc(sizeof(*nseq), GFP_ATOMIC);\r\nstruct sub_seq *sseq = tipc_subseq_alloc(1);\r\nif (!nseq || !sseq) {\r\nwarn("Name sequence creation failed, no memory\n");\r\nkfree(nseq);\r\nkfree(sseq);\r\nreturn NULL;\r\n}\r\nspin_lock_init(&nseq->lock);\r\nnseq->type = type;\r\nnseq->sseqs = sseq;\r\nnseq->alloc = 1;\r\nINIT_HLIST_NODE(&nseq->ns_list);\r\nINIT_LIST_HEAD(&nseq->subscriptions);\r\nhlist_add_head(&nseq->ns_list, seq_head);\r\nreturn nseq;\r\n}\r\nstatic struct sub_seq *nameseq_find_subseq(struct name_seq *nseq,\r\nu32 instance)\r\n{\r\nstruct sub_seq *sseqs = nseq->sseqs;\r\nint low = 0;\r\nint high = nseq->first_free - 1;\r\nint mid;\r\nwhile (low <= high) {\r\nmid = (low + high) / 2;\r\nif (instance < sseqs[mid].lower)\r\nhigh = mid - 1;\r\nelse if (instance > sseqs[mid].upper)\r\nlow = mid + 1;\r\nelse\r\nreturn &sseqs[mid];\r\n}\r\nreturn NULL;\r\n}\r\nstatic u32 nameseq_locate_subseq(struct name_seq *nseq, u32 instance)\r\n{\r\nstruct sub_seq *sseqs = nseq->sseqs;\r\nint low = 0;\r\nint high = nseq->first_free - 1;\r\nint mid;\r\nwhile (low <= high) {\r\nmid = (low + high) / 2;\r\nif (instance < sseqs[mid].lower)\r\nhigh = mid - 1;\r\nelse if (instance > sseqs[mid].upper)\r\nlow = mid + 1;\r\nelse\r\nreturn mid;\r\n}\r\nreturn low;\r\n}\r\nstatic struct publication *tipc_nameseq_insert_publ(struct name_seq *nseq,\r\nu32 type, u32 lower, u32 upper,\r\nu32 scope, u32 node, u32 port, u32 key)\r\n{\r\nstruct subscription *s;\r\nstruct subscription *st;\r\nstruct publication *publ;\r\nstruct sub_seq *sseq;\r\nstruct name_info *info;\r\nint created_subseq = 0;\r\nsseq = nameseq_find_subseq(nseq, lower);\r\nif (sseq) {\r\nif ((sseq->lower != lower) || (sseq->upper != upper)) {\r\nwarn("Cannot publish {%u,%u,%u}, overlap error\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\ninfo = sseq->info;\r\n} else {\r\nu32 inspos;\r\nstruct sub_seq *freesseq;\r\ninspos = nameseq_locate_subseq(nseq, lower);\r\nif ((inspos < nseq->first_free) &&\r\n(upper >= nseq->sseqs[inspos].lower)) {\r\nwarn("Cannot publish {%u,%u,%u}, overlap error\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\nif (nseq->first_free == nseq->alloc) {\r\nstruct sub_seq *sseqs = tipc_subseq_alloc(nseq->alloc * 2);\r\nif (!sseqs) {\r\nwarn("Cannot publish {%u,%u,%u}, no memory\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\nmemcpy(sseqs, nseq->sseqs,\r\nnseq->alloc * sizeof(struct sub_seq));\r\nkfree(nseq->sseqs);\r\nnseq->sseqs = sseqs;\r\nnseq->alloc *= 2;\r\n}\r\ninfo = kzalloc(sizeof(*info), GFP_ATOMIC);\r\nif (!info) {\r\nwarn("Cannot publish {%u,%u,%u}, no memory\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&info->node_list);\r\nINIT_LIST_HEAD(&info->cluster_list);\r\nINIT_LIST_HEAD(&info->zone_list);\r\nsseq = &nseq->sseqs[inspos];\r\nfreesseq = &nseq->sseqs[nseq->first_free];\r\nmemmove(sseq + 1, sseq, (freesseq - sseq) * sizeof(*sseq));\r\nmemset(sseq, 0, sizeof(*sseq));\r\nnseq->first_free++;\r\nsseq->lower = lower;\r\nsseq->upper = upper;\r\nsseq->info = info;\r\ncreated_subseq = 1;\r\n}\r\npubl = publ_create(type, lower, upper, scope, node, port, key);\r\nif (!publ)\r\nreturn NULL;\r\nlist_add(&publ->zone_list, &info->zone_list);\r\ninfo->zone_list_size++;\r\nif (in_own_cluster(node)) {\r\nlist_add(&publ->cluster_list, &info->cluster_list);\r\ninfo->cluster_list_size++;\r\n}\r\nif (node == tipc_own_addr) {\r\nlist_add(&publ->node_list, &info->node_list);\r\ninfo->node_list_size++;\r\n}\r\nlist_for_each_entry_safe(s, st, &nseq->subscriptions, nameseq_list) {\r\ntipc_subscr_report_overlap(s,\r\npubl->lower,\r\npubl->upper,\r\nTIPC_PUBLISHED,\r\npubl->ref,\r\npubl->node,\r\ncreated_subseq);\r\n}\r\nreturn publ;\r\n}\r\nstatic struct publication *tipc_nameseq_remove_publ(struct name_seq *nseq, u32 inst,\r\nu32 node, u32 ref, u32 key)\r\n{\r\nstruct publication *publ;\r\nstruct sub_seq *sseq = nameseq_find_subseq(nseq, inst);\r\nstruct name_info *info;\r\nstruct sub_seq *free;\r\nstruct subscription *s, *st;\r\nint removed_subseq = 0;\r\nif (!sseq)\r\nreturn NULL;\r\ninfo = sseq->info;\r\nlist_for_each_entry(publ, &info->zone_list, zone_list) {\r\nif ((publ->key == key) && (publ->ref == ref) &&\r\n(!publ->node || (publ->node == node)))\r\ngoto found;\r\n}\r\nreturn NULL;\r\nfound:\r\nlist_del(&publ->zone_list);\r\ninfo->zone_list_size--;\r\nif (in_own_cluster(node)) {\r\nlist_del(&publ->cluster_list);\r\ninfo->cluster_list_size--;\r\n}\r\nif (node == tipc_own_addr) {\r\nlist_del(&publ->node_list);\r\ninfo->node_list_size--;\r\n}\r\nif (list_empty(&info->zone_list)) {\r\nkfree(info);\r\nfree = &nseq->sseqs[nseq->first_free--];\r\nmemmove(sseq, sseq + 1, (free - (sseq + 1)) * sizeof(*sseq));\r\nremoved_subseq = 1;\r\n}\r\nlist_for_each_entry_safe(s, st, &nseq->subscriptions, nameseq_list) {\r\ntipc_subscr_report_overlap(s,\r\npubl->lower,\r\npubl->upper,\r\nTIPC_WITHDRAWN,\r\npubl->ref,\r\npubl->node,\r\nremoved_subseq);\r\n}\r\nreturn publ;\r\n}\r\nstatic void tipc_nameseq_subscribe(struct name_seq *nseq, struct subscription *s)\r\n{\r\nstruct sub_seq *sseq = nseq->sseqs;\r\nlist_add(&s->nameseq_list, &nseq->subscriptions);\r\nif (!sseq)\r\nreturn;\r\nwhile (sseq != &nseq->sseqs[nseq->first_free]) {\r\nif (tipc_subscr_overlap(s, sseq->lower, sseq->upper)) {\r\nstruct publication *crs;\r\nstruct name_info *info = sseq->info;\r\nint must_report = 1;\r\nlist_for_each_entry(crs, &info->zone_list, zone_list) {\r\ntipc_subscr_report_overlap(s,\r\nsseq->lower,\r\nsseq->upper,\r\nTIPC_PUBLISHED,\r\ncrs->ref,\r\ncrs->node,\r\nmust_report);\r\nmust_report = 0;\r\n}\r\n}\r\nsseq++;\r\n}\r\n}\r\nstatic struct name_seq *nametbl_find_seq(u32 type)\r\n{\r\nstruct hlist_head *seq_head;\r\nstruct hlist_node *seq_node;\r\nstruct name_seq *ns;\r\nseq_head = &table.types[hash(type)];\r\nhlist_for_each_entry(ns, seq_node, seq_head, ns_list) {\r\nif (ns->type == type)\r\nreturn ns;\r\n}\r\nreturn NULL;\r\n}\r\nstruct publication *tipc_nametbl_insert_publ(u32 type, u32 lower, u32 upper,\r\nu32 scope, u32 node, u32 port, u32 key)\r\n{\r\nstruct name_seq *seq = nametbl_find_seq(type);\r\nif (lower > upper) {\r\nwarn("Failed to publish illegal {%u,%u,%u}\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\nif (!seq)\r\nseq = tipc_nameseq_create(type, &table.types[hash(type)]);\r\nif (!seq)\r\nreturn NULL;\r\nreturn tipc_nameseq_insert_publ(seq, type, lower, upper,\r\nscope, node, port, key);\r\n}\r\nstruct publication *tipc_nametbl_remove_publ(u32 type, u32 lower,\r\nu32 node, u32 ref, u32 key)\r\n{\r\nstruct publication *publ;\r\nstruct name_seq *seq = nametbl_find_seq(type);\r\nif (!seq)\r\nreturn NULL;\r\npubl = tipc_nameseq_remove_publ(seq, lower, node, ref, key);\r\nif (!seq->first_free && list_empty(&seq->subscriptions)) {\r\nhlist_del_init(&seq->ns_list);\r\nkfree(seq->sseqs);\r\nkfree(seq);\r\n}\r\nreturn publ;\r\n}\r\nu32 tipc_nametbl_translate(u32 type, u32 instance, u32 *destnode)\r\n{\r\nstruct sub_seq *sseq;\r\nstruct name_info *info;\r\nstruct publication *publ;\r\nstruct name_seq *seq;\r\nu32 ref = 0;\r\nif (!tipc_in_scope(*destnode, tipc_own_addr))\r\nreturn 0;\r\nread_lock_bh(&tipc_nametbl_lock);\r\nseq = nametbl_find_seq(type);\r\nif (unlikely(!seq))\r\ngoto not_found;\r\nsseq = nameseq_find_subseq(seq, instance);\r\nif (unlikely(!sseq))\r\ngoto not_found;\r\nspin_lock_bh(&seq->lock);\r\ninfo = sseq->info;\r\nif (likely(!*destnode)) {\r\nif (!list_empty(&info->node_list)) {\r\npubl = list_first_entry(&info->node_list,\r\nstruct publication,\r\nnode_list);\r\nlist_move_tail(&publ->node_list,\r\n&info->node_list);\r\n} else if (!list_empty(&info->cluster_list)) {\r\npubl = list_first_entry(&info->cluster_list,\r\nstruct publication,\r\ncluster_list);\r\nlist_move_tail(&publ->cluster_list,\r\n&info->cluster_list);\r\n} else {\r\npubl = list_first_entry(&info->zone_list,\r\nstruct publication,\r\nzone_list);\r\nlist_move_tail(&publ->zone_list,\r\n&info->zone_list);\r\n}\r\n}\r\nelse if (*destnode == tipc_own_addr) {\r\nif (list_empty(&info->node_list))\r\ngoto no_match;\r\npubl = list_first_entry(&info->node_list, struct publication,\r\nnode_list);\r\nlist_move_tail(&publ->node_list, &info->node_list);\r\n} else if (in_own_cluster(*destnode)) {\r\nif (list_empty(&info->cluster_list))\r\ngoto no_match;\r\npubl = list_first_entry(&info->cluster_list, struct publication,\r\ncluster_list);\r\nlist_move_tail(&publ->cluster_list, &info->cluster_list);\r\n} else {\r\npubl = list_first_entry(&info->zone_list, struct publication,\r\nzone_list);\r\nlist_move_tail(&publ->zone_list, &info->zone_list);\r\n}\r\nref = publ->ref;\r\n*destnode = publ->node;\r\nno_match:\r\nspin_unlock_bh(&seq->lock);\r\nnot_found:\r\nread_unlock_bh(&tipc_nametbl_lock);\r\nreturn ref;\r\n}\r\nint tipc_nametbl_mc_translate(u32 type, u32 lower, u32 upper, u32 limit,\r\nstruct port_list *dports)\r\n{\r\nstruct name_seq *seq;\r\nstruct sub_seq *sseq;\r\nstruct sub_seq *sseq_stop;\r\nstruct name_info *info;\r\nint res = 0;\r\nread_lock_bh(&tipc_nametbl_lock);\r\nseq = nametbl_find_seq(type);\r\nif (!seq)\r\ngoto exit;\r\nspin_lock_bh(&seq->lock);\r\nsseq = seq->sseqs + nameseq_locate_subseq(seq, lower);\r\nsseq_stop = seq->sseqs + seq->first_free;\r\nfor (; sseq != sseq_stop; sseq++) {\r\nstruct publication *publ;\r\nif (sseq->lower > upper)\r\nbreak;\r\ninfo = sseq->info;\r\nlist_for_each_entry(publ, &info->node_list, node_list) {\r\nif (publ->scope <= limit)\r\ntipc_port_list_add(dports, publ->ref);\r\n}\r\nif (info->cluster_list_size != info->node_list_size)\r\nres = 1;\r\n}\r\nspin_unlock_bh(&seq->lock);\r\nexit:\r\nread_unlock_bh(&tipc_nametbl_lock);\r\nreturn res;\r\n}\r\nint tipc_nametbl_publish_rsv(u32 ref, unsigned int scope,\r\nstruct tipc_name_seq const *seq)\r\n{\r\nint res;\r\natomic_inc(&rsv_publ_ok);\r\nres = tipc_publish(ref, scope, seq);\r\natomic_dec(&rsv_publ_ok);\r\nreturn res;\r\n}\r\nstruct publication *tipc_nametbl_publish(u32 type, u32 lower, u32 upper,\r\nu32 scope, u32 port_ref, u32 key)\r\n{\r\nstruct publication *publ;\r\nif (table.local_publ_count >= tipc_max_publications) {\r\nwarn("Publication failed, local publication limit reached (%u)\n",\r\ntipc_max_publications);\r\nreturn NULL;\r\n}\r\nif ((type < TIPC_RESERVED_TYPES) && !atomic_read(&rsv_publ_ok)) {\r\nwarn("Publication failed, reserved name {%u,%u,%u}\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\ntable.local_publ_count++;\r\npubl = tipc_nametbl_insert_publ(type, lower, upper, scope,\r\ntipc_own_addr, port_ref, key);\r\nif (publ && (scope != TIPC_NODE_SCOPE))\r\ntipc_named_publish(publ);\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\nreturn publ;\r\n}\r\nint tipc_nametbl_withdraw(u32 type, u32 lower, u32 ref, u32 key)\r\n{\r\nstruct publication *publ;\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\npubl = tipc_nametbl_remove_publ(type, lower, tipc_own_addr, ref, key);\r\nif (likely(publ)) {\r\ntable.local_publ_count--;\r\nif (publ->scope != TIPC_NODE_SCOPE)\r\ntipc_named_withdraw(publ);\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\nlist_del_init(&publ->pport_list);\r\nkfree(publ);\r\nreturn 1;\r\n}\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\nerr("Unable to remove local publication\n"\r\n"(type=%u, lower=%u, ref=%u, key=%u)\n",\r\ntype, lower, ref, key);\r\nreturn 0;\r\n}\r\nvoid tipc_nametbl_subscribe(struct subscription *s)\r\n{\r\nu32 type = s->seq.type;\r\nstruct name_seq *seq;\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\nseq = nametbl_find_seq(type);\r\nif (!seq)\r\nseq = tipc_nameseq_create(type, &table.types[hash(type)]);\r\nif (seq) {\r\nspin_lock_bh(&seq->lock);\r\ntipc_nameseq_subscribe(seq, s);\r\nspin_unlock_bh(&seq->lock);\r\n} else {\r\nwarn("Failed to create subscription for {%u,%u,%u}\n",\r\ns->seq.type, s->seq.lower, s->seq.upper);\r\n}\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\n}\r\nvoid tipc_nametbl_unsubscribe(struct subscription *s)\r\n{\r\nstruct name_seq *seq;\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\nseq = nametbl_find_seq(s->seq.type);\r\nif (seq != NULL) {\r\nspin_lock_bh(&seq->lock);\r\nlist_del_init(&s->nameseq_list);\r\nspin_unlock_bh(&seq->lock);\r\nif ((seq->first_free == 0) && list_empty(&seq->subscriptions)) {\r\nhlist_del_init(&seq->ns_list);\r\nkfree(seq->sseqs);\r\nkfree(seq);\r\n}\r\n}\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\n}\r\nstatic void subseq_list(struct sub_seq *sseq, struct print_buf *buf, u32 depth,\r\nu32 index)\r\n{\r\nchar portIdStr[27];\r\nconst char *scope_str[] = {"", " zone", " cluster", " node"};\r\nstruct publication *publ;\r\nstruct name_info *info;\r\ntipc_printf(buf, "%-10u %-10u ", sseq->lower, sseq->upper);\r\nif (depth == 2) {\r\ntipc_printf(buf, "\n");\r\nreturn;\r\n}\r\ninfo = sseq->info;\r\nlist_for_each_entry(publ, &info->zone_list, zone_list) {\r\nsprintf(portIdStr, "<%u.%u.%u:%u>",\r\ntipc_zone(publ->node), tipc_cluster(publ->node),\r\ntipc_node(publ->node), publ->ref);\r\ntipc_printf(buf, "%-26s ", portIdStr);\r\nif (depth > 3) {\r\ntipc_printf(buf, "%-10u %s", publ->key,\r\nscope_str[publ->scope]);\r\n}\r\nif (!list_is_last(&publ->zone_list, &info->zone_list))\r\ntipc_printf(buf, "\n%33s", " ");\r\n};\r\ntipc_printf(buf, "\n");\r\n}\r\nstatic void nameseq_list(struct name_seq *seq, struct print_buf *buf, u32 depth,\r\nu32 type, u32 lowbound, u32 upbound, u32 index)\r\n{\r\nstruct sub_seq *sseq;\r\nchar typearea[11];\r\nif (seq->first_free == 0)\r\nreturn;\r\nsprintf(typearea, "%-10u", seq->type);\r\nif (depth == 1) {\r\ntipc_printf(buf, "%s\n", typearea);\r\nreturn;\r\n}\r\nfor (sseq = seq->sseqs; sseq != &seq->sseqs[seq->first_free]; sseq++) {\r\nif ((lowbound <= sseq->upper) && (upbound >= sseq->lower)) {\r\ntipc_printf(buf, "%s ", typearea);\r\nspin_lock_bh(&seq->lock);\r\nsubseq_list(sseq, buf, depth, index);\r\nspin_unlock_bh(&seq->lock);\r\nsprintf(typearea, "%10s", " ");\r\n}\r\n}\r\n}\r\nstatic void nametbl_header(struct print_buf *buf, u32 depth)\r\n{\r\nconst char *header[] = {\r\n"Type ",\r\n"Lower Upper ",\r\n"Port Identity ",\r\n"Publication Scope"\r\n};\r\nint i;\r\nif (depth > 4)\r\ndepth = 4;\r\nfor (i = 0; i < depth; i++)\r\ntipc_printf(buf, header[i]);\r\ntipc_printf(buf, "\n");\r\n}\r\nstatic void nametbl_list(struct print_buf *buf, u32 depth_info,\r\nu32 type, u32 lowbound, u32 upbound)\r\n{\r\nstruct hlist_head *seq_head;\r\nstruct hlist_node *seq_node;\r\nstruct name_seq *seq;\r\nint all_types;\r\nu32 depth;\r\nu32 i;\r\nall_types = (depth_info & TIPC_NTQ_ALLTYPES);\r\ndepth = (depth_info & ~TIPC_NTQ_ALLTYPES);\r\nif (depth == 0)\r\nreturn;\r\nif (all_types) {\r\nnametbl_header(buf, depth);\r\nlowbound = 0;\r\nupbound = ~0;\r\nfor (i = 0; i < tipc_nametbl_size; i++) {\r\nseq_head = &table.types[i];\r\nhlist_for_each_entry(seq, seq_node, seq_head, ns_list) {\r\nnameseq_list(seq, buf, depth, seq->type,\r\nlowbound, upbound, i);\r\n}\r\n}\r\n} else {\r\nif (upbound < lowbound) {\r\ntipc_printf(buf, "invalid name sequence specified\n");\r\nreturn;\r\n}\r\nnametbl_header(buf, depth);\r\ni = hash(type);\r\nseq_head = &table.types[i];\r\nhlist_for_each_entry(seq, seq_node, seq_head, ns_list) {\r\nif (seq->type == type) {\r\nnameseq_list(seq, buf, depth, type,\r\nlowbound, upbound, i);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstruct sk_buff *tipc_nametbl_get(const void *req_tlv_area, int req_tlv_space)\r\n{\r\nstruct sk_buff *buf;\r\nstruct tipc_name_table_query *argv;\r\nstruct tlv_desc *rep_tlv;\r\nstruct print_buf b;\r\nint str_len;\r\nif (!TLV_CHECK(req_tlv_area, req_tlv_space, TIPC_TLV_NAME_TBL_QUERY))\r\nreturn tipc_cfg_reply_error_string(TIPC_CFG_TLV_ERROR);\r\nbuf = tipc_cfg_reply_alloc(TLV_SPACE(MAX_NAME_TBL_QUERY));\r\nif (!buf)\r\nreturn NULL;\r\nrep_tlv = (struct tlv_desc *)buf->data;\r\ntipc_printbuf_init(&b, TLV_DATA(rep_tlv), MAX_NAME_TBL_QUERY);\r\nargv = (struct tipc_name_table_query *)TLV_DATA(req_tlv_area);\r\nread_lock_bh(&tipc_nametbl_lock);\r\nnametbl_list(&b, ntohl(argv->depth), ntohl(argv->type),\r\nntohl(argv->lowbound), ntohl(argv->upbound));\r\nread_unlock_bh(&tipc_nametbl_lock);\r\nstr_len = tipc_printbuf_validate(&b);\r\nskb_put(buf, TLV_SPACE(str_len));\r\nTLV_SET(rep_tlv, TIPC_TLV_ULTRA_STRING, NULL, str_len);\r\nreturn buf;\r\n}\r\nint tipc_nametbl_init(void)\r\n{\r\ntable.types = kcalloc(tipc_nametbl_size, sizeof(struct hlist_head),\r\nGFP_ATOMIC);\r\nif (!table.types)\r\nreturn -ENOMEM;\r\ntable.local_publ_count = 0;\r\nreturn 0;\r\n}\r\nvoid tipc_nametbl_stop(void)\r\n{\r\nu32 i;\r\nif (!table.types)\r\nreturn;\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\nfor (i = 0; i < tipc_nametbl_size; i++) {\r\nif (!hlist_empty(&table.types[i]))\r\nerr("tipc_nametbl_stop(): hash chain %u is non-null\n", i);\r\n}\r\nkfree(table.types);\r\ntable.types = NULL;\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\n}
