static ssize_t show_index(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nreturn sprintf(buf, "%i\n", vdev->index);\r\n}\r\nstatic ssize_t show_name(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nreturn sprintf(buf, "%.*s\n", (int)sizeof(vdev->name), vdev->name);\r\n}\r\nstatic inline unsigned long *devnode_bits(int vfl_type)\r\n{\r\nint idx = (vfl_type > VFL_TYPE_RADIO) ? VFL_TYPE_MAX - 1 : vfl_type;\r\nreturn devnode_nums[idx];\r\n}\r\nstatic inline unsigned long *devnode_bits(int vfl_type)\r\n{\r\nreturn devnode_nums[vfl_type];\r\n}\r\nstatic inline void devnode_set(struct video_device *vdev)\r\n{\r\nset_bit(vdev->num, devnode_bits(vdev->vfl_type));\r\n}\r\nstatic inline void devnode_clear(struct video_device *vdev)\r\n{\r\nclear_bit(vdev->num, devnode_bits(vdev->vfl_type));\r\n}\r\nstatic inline int devnode_find(struct video_device *vdev, int from, int to)\r\n{\r\nreturn find_next_zero_bit(devnode_bits(vdev->vfl_type), to, from);\r\n}\r\nstruct video_device *video_device_alloc(void)\r\n{\r\nreturn kzalloc(sizeof(struct video_device), GFP_KERNEL);\r\n}\r\nvoid video_device_release(struct video_device *vdev)\r\n{\r\nkfree(vdev);\r\n}\r\nvoid video_device_release_empty(struct video_device *vdev)\r\n{\r\n}\r\nstatic inline void video_get(struct video_device *vdev)\r\n{\r\nget_device(&vdev->dev);\r\n}\r\nstatic inline void video_put(struct video_device *vdev)\r\n{\r\nput_device(&vdev->dev);\r\n}\r\nstatic void v4l2_device_release(struct device *cd)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct v4l2_device *v4l2_dev = vdev->v4l2_dev;\r\nmutex_lock(&videodev_lock);\r\nif (video_device[vdev->minor] != vdev) {\r\nmutex_unlock(&videodev_lock);\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nvideo_device[vdev->minor] = NULL;\r\ncdev_del(vdev->cdev);\r\nvdev->cdev = NULL;\r\ndevnode_clear(vdev);\r\nmutex_unlock(&videodev_lock);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (vdev->v4l2_dev && vdev->v4l2_dev->mdev &&\r\nvdev->vfl_type != VFL_TYPE_SUBDEV)\r\nmedia_device_unregister_entity(&vdev->entity);\r\n#endif\r\nif (v4l2_dev && v4l2_dev->release == NULL)\r\nv4l2_dev = NULL;\r\nvdev->release(vdev);\r\nif (v4l2_dev)\r\nv4l2_device_put(v4l2_dev);\r\n}\r\nstruct video_device *video_devdata(struct file *file)\r\n{\r\nreturn video_device[iminor(file->f_path.dentry->d_inode)];\r\n}\r\nstatic inline bool prio_is_valid(enum v4l2_priority prio)\r\n{\r\nreturn prio == V4L2_PRIORITY_BACKGROUND ||\r\nprio == V4L2_PRIORITY_INTERACTIVE ||\r\nprio == V4L2_PRIORITY_RECORD;\r\n}\r\nvoid v4l2_prio_init(struct v4l2_prio_state *global)\r\n{\r\nmemset(global, 0, sizeof(*global));\r\n}\r\nint v4l2_prio_change(struct v4l2_prio_state *global, enum v4l2_priority *local,\r\nenum v4l2_priority new)\r\n{\r\nif (!prio_is_valid(new))\r\nreturn -EINVAL;\r\nif (*local == new)\r\nreturn 0;\r\natomic_inc(&global->prios[new]);\r\nif (prio_is_valid(*local))\r\natomic_dec(&global->prios[*local]);\r\n*local = new;\r\nreturn 0;\r\n}\r\nvoid v4l2_prio_open(struct v4l2_prio_state *global, enum v4l2_priority *local)\r\n{\r\nv4l2_prio_change(global, local, V4L2_PRIORITY_DEFAULT);\r\n}\r\nvoid v4l2_prio_close(struct v4l2_prio_state *global, enum v4l2_priority local)\r\n{\r\nif (prio_is_valid(local))\r\natomic_dec(&global->prios[local]);\r\n}\r\nenum v4l2_priority v4l2_prio_max(struct v4l2_prio_state *global)\r\n{\r\nif (atomic_read(&global->prios[V4L2_PRIORITY_RECORD]) > 0)\r\nreturn V4L2_PRIORITY_RECORD;\r\nif (atomic_read(&global->prios[V4L2_PRIORITY_INTERACTIVE]) > 0)\r\nreturn V4L2_PRIORITY_INTERACTIVE;\r\nif (atomic_read(&global->prios[V4L2_PRIORITY_BACKGROUND]) > 0)\r\nreturn V4L2_PRIORITY_BACKGROUND;\r\nreturn V4L2_PRIORITY_UNSET;\r\n}\r\nint v4l2_prio_check(struct v4l2_prio_state *global, enum v4l2_priority local)\r\n{\r\nreturn (local < v4l2_prio_max(global)) ? -EBUSY : 0;\r\n}\r\nstatic ssize_t v4l2_read(struct file *filp, char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (!vdev->fops->read)\r\nreturn -EINVAL;\r\nif (vdev->lock && mutex_lock_interruptible(vdev->lock))\r\nreturn -ERESTARTSYS;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->read(filp, buf, sz, off);\r\nif (vdev->lock)\r\nmutex_unlock(vdev->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t v4l2_write(struct file *filp, const char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (!vdev->fops->write)\r\nreturn -EINVAL;\r\nif (vdev->lock && mutex_lock_interruptible(vdev->lock))\r\nreturn -ERESTARTSYS;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->write(filp, buf, sz, off);\r\nif (vdev->lock)\r\nmutex_unlock(vdev->lock);\r\nreturn ret;\r\n}\r\nstatic unsigned int v4l2_poll(struct file *filp, struct poll_table_struct *poll)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = POLLERR | POLLHUP;\r\nif (!vdev->fops->poll)\r\nreturn DEFAULT_POLLMASK;\r\nif (vdev->lock)\r\nmutex_lock(vdev->lock);\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->poll(filp, poll);\r\nif (vdev->lock)\r\nmutex_unlock(vdev->lock);\r\nreturn ret;\r\n}\r\nstatic long v4l2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (vdev->fops->unlocked_ioctl) {\r\nif (vdev->lock && mutex_lock_interruptible(vdev->lock))\r\nreturn -ERESTARTSYS;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->unlocked_ioctl(filp, cmd, arg);\r\nif (vdev->lock)\r\nmutex_unlock(vdev->lock);\r\n} else if (vdev->fops->ioctl) {\r\nstatic DEFINE_MUTEX(v4l2_ioctl_mutex);\r\nstruct mutex *m = vdev->v4l2_dev ?\r\n&vdev->v4l2_dev->ioctl_lock : &v4l2_ioctl_mutex;\r\nif (cmd != VIDIOC_DQBUF && mutex_lock_interruptible(m))\r\nreturn -ERESTARTSYS;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->ioctl(filp, cmd, arg);\r\nif (cmd != VIDIOC_DQBUF)\r\nmutex_unlock(m);\r\n} else\r\nret = -ENOTTY;\r\nreturn ret;\r\n}\r\nstatic unsigned long v4l2_get_unmapped_area(struct file *filp,\r\nunsigned long addr, unsigned long len, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nif (!vdev->fops->get_unmapped_area)\r\nreturn -ENOSYS;\r\nif (!video_is_registered(vdev))\r\nreturn -ENODEV;\r\nreturn vdev->fops->get_unmapped_area(filp, addr, len, pgoff, flags);\r\n}\r\nstatic int v4l2_mmap(struct file *filp, struct vm_area_struct *vm)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (!vdev->fops->mmap)\r\nreturn ret;\r\nif (vdev->lock && mutex_lock_interruptible(vdev->lock))\r\nreturn -ERESTARTSYS;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->mmap(filp, vm);\r\nif (vdev->lock)\r\nmutex_unlock(vdev->lock);\r\nreturn ret;\r\n}\r\nstatic int v4l2_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct video_device *vdev;\r\nint ret = 0;\r\nmutex_lock(&videodev_lock);\r\nvdev = video_devdata(filp);\r\nif (vdev == NULL || !video_is_registered(vdev)) {\r\nmutex_unlock(&videodev_lock);\r\nreturn -ENODEV;\r\n}\r\nvideo_get(vdev);\r\nmutex_unlock(&videodev_lock);\r\nif (vdev->fops->open) {\r\nif (vdev->lock && mutex_lock_interruptible(vdev->lock)) {\r\nret = -ERESTARTSYS;\r\ngoto err;\r\n}\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->open(filp);\r\nelse\r\nret = -ENODEV;\r\nif (vdev->lock)\r\nmutex_unlock(vdev->lock);\r\n}\r\nerr:\r\nif (ret)\r\nvideo_put(vdev);\r\nreturn ret;\r\n}\r\nstatic int v4l2_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = 0;\r\nif (vdev->fops->release) {\r\nif (vdev->lock)\r\nmutex_lock(vdev->lock);\r\nvdev->fops->release(filp);\r\nif (vdev->lock)\r\nmutex_unlock(vdev->lock);\r\n}\r\nvideo_put(vdev);\r\nreturn ret;\r\n}\r\nstatic int get_index(struct video_device *vdev)\r\n{\r\nstatic DECLARE_BITMAP(used, VIDEO_NUM_DEVICES);\r\nint i;\r\nif (vdev->parent == NULL)\r\nreturn 0;\r\nbitmap_zero(used, VIDEO_NUM_DEVICES);\r\nfor (i = 0; i < VIDEO_NUM_DEVICES; i++) {\r\nif (video_device[i] != NULL &&\r\nvideo_device[i]->parent == vdev->parent) {\r\nset_bit(video_device[i]->index, used);\r\n}\r\n}\r\nreturn find_first_zero_bit(used, VIDEO_NUM_DEVICES);\r\n}\r\nint __video_register_device(struct video_device *vdev, int type, int nr,\r\nint warn_if_nr_in_use, struct module *owner)\r\n{\r\nint i = 0;\r\nint ret;\r\nint minor_offset = 0;\r\nint minor_cnt = VIDEO_NUM_DEVICES;\r\nconst char *name_base;\r\nvdev->minor = -1;\r\nWARN_ON(!vdev->release);\r\nif (!vdev->release)\r\nreturn -EINVAL;\r\nspin_lock_init(&vdev->fh_lock);\r\nINIT_LIST_HEAD(&vdev->fh_list);\r\nswitch (type) {\r\ncase VFL_TYPE_GRABBER:\r\nname_base = "video";\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nname_base = "vbi";\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nname_base = "radio";\r\nbreak;\r\ncase VFL_TYPE_SUBDEV:\r\nname_base = "v4l-subdev";\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s called with unknown type: %d\n",\r\n__func__, type);\r\nreturn -EINVAL;\r\n}\r\nvdev->vfl_type = type;\r\nvdev->cdev = NULL;\r\nif (vdev->v4l2_dev) {\r\nif (vdev->v4l2_dev->dev)\r\nvdev->parent = vdev->v4l2_dev->dev;\r\nif (vdev->ctrl_handler == NULL)\r\nvdev->ctrl_handler = vdev->v4l2_dev->ctrl_handler;\r\nif (vdev->prio == NULL)\r\nvdev->prio = &vdev->v4l2_dev->prio;\r\n}\r\n#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES\r\nswitch (type) {\r\ncase VFL_TYPE_GRABBER:\r\nminor_offset = 0;\r\nminor_cnt = 64;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nminor_offset = 64;\r\nminor_cnt = 64;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nminor_offset = 224;\r\nminor_cnt = 32;\r\nbreak;\r\ndefault:\r\nminor_offset = 128;\r\nminor_cnt = 64;\r\nbreak;\r\n}\r\n#endif\r\nmutex_lock(&videodev_lock);\r\nnr = devnode_find(vdev, nr == -1 ? 0 : nr, minor_cnt);\r\nif (nr == minor_cnt)\r\nnr = devnode_find(vdev, 0, minor_cnt);\r\nif (nr == minor_cnt) {\r\nprintk(KERN_ERR "could not get a free device node number\n");\r\nmutex_unlock(&videodev_lock);\r\nreturn -ENFILE;\r\n}\r\n#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES\r\ni = nr;\r\n#else\r\nfor (i = 0; i < VIDEO_NUM_DEVICES; i++)\r\nif (video_device[i] == NULL)\r\nbreak;\r\nif (i == VIDEO_NUM_DEVICES) {\r\nmutex_unlock(&videodev_lock);\r\nprintk(KERN_ERR "could not get a free minor\n");\r\nreturn -ENFILE;\r\n}\r\n#endif\r\nvdev->minor = i + minor_offset;\r\nvdev->num = nr;\r\ndevnode_set(vdev);\r\nWARN_ON(video_device[vdev->minor] != NULL);\r\nvdev->index = get_index(vdev);\r\nmutex_unlock(&videodev_lock);\r\nvdev->cdev = cdev_alloc();\r\nif (vdev->cdev == NULL) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nvdev->cdev->ops = &v4l2_fops;\r\nvdev->cdev->owner = owner;\r\nret = cdev_add(vdev->cdev, MKDEV(VIDEO_MAJOR, vdev->minor), 1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: cdev_add failed\n", __func__);\r\nkfree(vdev->cdev);\r\nvdev->cdev = NULL;\r\ngoto cleanup;\r\n}\r\nvdev->dev.class = &video_class;\r\nvdev->dev.devt = MKDEV(VIDEO_MAJOR, vdev->minor);\r\nif (vdev->parent)\r\nvdev->dev.parent = vdev->parent;\r\ndev_set_name(&vdev->dev, "%s%d", name_base, vdev->num);\r\nret = device_register(&vdev->dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: device_register failed\n", __func__);\r\ngoto cleanup;\r\n}\r\nvdev->dev.release = v4l2_device_release;\r\nif (nr != -1 && nr != vdev->num && warn_if_nr_in_use)\r\nprintk(KERN_WARNING "%s: requested %s%d, got %s\n", __func__,\r\nname_base, nr, video_device_node_name(vdev));\r\nif (vdev->v4l2_dev)\r\nv4l2_device_get(vdev->v4l2_dev);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (vdev->v4l2_dev && vdev->v4l2_dev->mdev &&\r\nvdev->vfl_type != VFL_TYPE_SUBDEV) {\r\nvdev->entity.type = MEDIA_ENT_T_DEVNODE_V4L;\r\nvdev->entity.name = vdev->name;\r\nvdev->entity.v4l.major = VIDEO_MAJOR;\r\nvdev->entity.v4l.minor = vdev->minor;\r\nret = media_device_register_entity(vdev->v4l2_dev->mdev,\r\n&vdev->entity);\r\nif (ret < 0)\r\nprintk(KERN_WARNING\r\n"%s: media_device_register_entity failed\n",\r\n__func__);\r\n}\r\n#endif\r\nset_bit(V4L2_FL_REGISTERED, &vdev->flags);\r\nmutex_lock(&videodev_lock);\r\nvideo_device[vdev->minor] = vdev;\r\nmutex_unlock(&videodev_lock);\r\nreturn 0;\r\ncleanup:\r\nmutex_lock(&videodev_lock);\r\nif (vdev->cdev)\r\ncdev_del(vdev->cdev);\r\ndevnode_clear(vdev);\r\nmutex_unlock(&videodev_lock);\r\nvdev->minor = -1;\r\nreturn ret;\r\n}\r\nvoid video_unregister_device(struct video_device *vdev)\r\n{\r\nif (!vdev || !video_is_registered(vdev))\r\nreturn;\r\nmutex_lock(&videodev_lock);\r\nclear_bit(V4L2_FL_REGISTERED, &vdev->flags);\r\nmutex_unlock(&videodev_lock);\r\ndevice_unregister(&vdev->dev);\r\n}\r\nstatic int __init videodev_init(void)\r\n{\r\ndev_t dev = MKDEV(VIDEO_MAJOR, 0);\r\nint ret;\r\nprintk(KERN_INFO "Linux video capture interface: v2.00\n");\r\nret = register_chrdev_region(dev, VIDEO_NUM_DEVICES, VIDEO_NAME);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "videodev: unable to get major %d\n",\r\nVIDEO_MAJOR);\r\nreturn ret;\r\n}\r\nret = class_register(&video_class);\r\nif (ret < 0) {\r\nunregister_chrdev_region(dev, VIDEO_NUM_DEVICES);\r\nprintk(KERN_WARNING "video_dev: class_register failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit videodev_exit(void)\r\n{\r\ndev_t dev = MKDEV(VIDEO_MAJOR, 0);\r\nclass_unregister(&video_class);\r\nunregister_chrdev_region(dev, VIDEO_NUM_DEVICES);\r\n}
