void apei_exec_ctx_init(struct apei_exec_context *ctx,\r\nstruct apei_exec_ins_type *ins_table,\r\nu32 instructions,\r\nstruct acpi_whea_header *action_table,\r\nu32 entries)\r\n{\r\nctx->ins_table = ins_table;\r\nctx->instructions = instructions;\r\nctx->action_table = action_table;\r\nctx->entries = entries;\r\n}\r\nint __apei_exec_read_register(struct acpi_whea_header *entry, u64 *val)\r\n{\r\nint rc;\r\nrc = acpi_atomic_read(val, &entry->register_region);\r\nif (rc)\r\nreturn rc;\r\n*val >>= entry->register_region.bit_offset;\r\n*val &= entry->mask;\r\nreturn 0;\r\n}\r\nint apei_exec_read_register(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nu64 val = 0;\r\nrc = __apei_exec_read_register(entry, &val);\r\nif (rc)\r\nreturn rc;\r\nctx->value = val;\r\nreturn 0;\r\n}\r\nint apei_exec_read_register_value(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nrc = apei_exec_read_register(ctx, entry);\r\nif (rc)\r\nreturn rc;\r\nctx->value = (ctx->value == entry->value);\r\nreturn 0;\r\n}\r\nint __apei_exec_write_register(struct acpi_whea_header *entry, u64 val)\r\n{\r\nint rc;\r\nval &= entry->mask;\r\nval <<= entry->register_region.bit_offset;\r\nif (entry->flags & APEI_EXEC_PRESERVE_REGISTER) {\r\nu64 valr = 0;\r\nrc = acpi_atomic_read(&valr, &entry->register_region);\r\nif (rc)\r\nreturn rc;\r\nvalr &= ~(entry->mask << entry->register_region.bit_offset);\r\nval |= valr;\r\n}\r\nrc = acpi_atomic_write(val, &entry->register_region);\r\nreturn rc;\r\n}\r\nint apei_exec_write_register(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nreturn __apei_exec_write_register(entry, ctx->value);\r\n}\r\nint apei_exec_write_register_value(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nctx->value = entry->value;\r\nrc = apei_exec_write_register(ctx, entry);\r\nreturn rc;\r\n}\r\nint apei_exec_noop(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nreturn 0;\r\n}\r\nint __apei_exec_run(struct apei_exec_context *ctx, u8 action,\r\nbool optional)\r\n{\r\nint rc = -ENOENT;\r\nu32 i, ip;\r\nstruct acpi_whea_header *entry;\r\napei_exec_ins_func_t run;\r\nctx->ip = 0;\r\nrewind:\r\nip = 0;\r\nfor (i = 0; i < ctx->entries; i++) {\r\nentry = &ctx->action_table[i];\r\nif (entry->action != action)\r\ncontinue;\r\nif (ip == ctx->ip) {\r\nif (entry->instruction >= ctx->instructions ||\r\n!ctx->ins_table[entry->instruction].run) {\r\npr_warning(FW_WARN APEI_PFX\r\n"Invalid action table, unknown instruction type: %d\n",\r\nentry->instruction);\r\nreturn -EINVAL;\r\n}\r\nrun = ctx->ins_table[entry->instruction].run;\r\nrc = run(ctx, entry);\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (rc != APEI_EXEC_SET_IP)\r\nctx->ip++;\r\n}\r\nip++;\r\nif (ctx->ip < ip)\r\ngoto rewind;\r\n}\r\nreturn !optional && rc < 0 ? rc : 0;\r\n}\r\nstatic int apei_exec_for_each_entry(struct apei_exec_context *ctx,\r\napei_exec_entry_func_t func,\r\nvoid *data,\r\nint *end)\r\n{\r\nu8 ins;\r\nint i, rc;\r\nstruct acpi_whea_header *entry;\r\nstruct apei_exec_ins_type *ins_table = ctx->ins_table;\r\nfor (i = 0; i < ctx->entries; i++) {\r\nentry = ctx->action_table + i;\r\nins = entry->instruction;\r\nif (end)\r\n*end = i;\r\nif (ins >= ctx->instructions || !ins_table[ins].run) {\r\npr_warning(FW_WARN APEI_PFX\r\n"Invalid action table, unknown instruction type: %d\n",\r\nins);\r\nreturn -EINVAL;\r\n}\r\nrc = func(ctx, entry, data);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pre_map_gar_callback(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry,\r\nvoid *data)\r\n{\r\nu8 ins = entry->instruction;\r\nif (ctx->ins_table[ins].flags & APEI_EXEC_INS_ACCESS_REGISTER)\r\nreturn acpi_pre_map_gar(&entry->register_region);\r\nreturn 0;\r\n}\r\nint apei_exec_pre_map_gars(struct apei_exec_context *ctx)\r\n{\r\nint rc, end;\r\nrc = apei_exec_for_each_entry(ctx, pre_map_gar_callback,\r\nNULL, &end);\r\nif (rc) {\r\nstruct apei_exec_context ctx_unmap;\r\nmemcpy(&ctx_unmap, ctx, sizeof(*ctx));\r\nctx_unmap.entries = end;\r\napei_exec_post_unmap_gars(&ctx_unmap);\r\n}\r\nreturn rc;\r\n}\r\nstatic int post_unmap_gar_callback(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry,\r\nvoid *data)\r\n{\r\nu8 ins = entry->instruction;\r\nif (ctx->ins_table[ins].flags & APEI_EXEC_INS_ACCESS_REGISTER)\r\nacpi_post_unmap_gar(&entry->register_region);\r\nreturn 0;\r\n}\r\nint apei_exec_post_unmap_gars(struct apei_exec_context *ctx)\r\n{\r\nreturn apei_exec_for_each_entry(ctx, post_unmap_gar_callback,\r\nNULL, NULL);\r\n}\r\nstatic int apei_res_add(struct list_head *res_list,\r\nunsigned long start, unsigned long size)\r\n{\r\nstruct apei_res *res, *resn, *res_ins = NULL;\r\nunsigned long end = start + size;\r\nif (end <= start)\r\nreturn 0;\r\nrepeat:\r\nlist_for_each_entry_safe(res, resn, res_list, list) {\r\nif (res->start > end || res->end < start)\r\ncontinue;\r\nelse if (end <= res->end && start >= res->start) {\r\nkfree(res_ins);\r\nreturn 0;\r\n}\r\nlist_del(&res->list);\r\nres->start = start = min(res->start, start);\r\nres->end = end = max(res->end, end);\r\nkfree(res_ins);\r\nres_ins = res;\r\ngoto repeat;\r\n}\r\nif (res_ins)\r\nlist_add(&res_ins->list, res_list);\r\nelse {\r\nres_ins = kmalloc(sizeof(*res), GFP_KERNEL);\r\nif (!res_ins)\r\nreturn -ENOMEM;\r\nres_ins->start = start;\r\nres_ins->end = end;\r\nlist_add(&res_ins->list, res_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int apei_res_sub(struct list_head *res_list1,\r\nstruct list_head *res_list2)\r\n{\r\nstruct apei_res *res1, *resn1, *res2, *res;\r\nres1 = list_entry(res_list1->next, struct apei_res, list);\r\nresn1 = list_entry(res1->list.next, struct apei_res, list);\r\nwhile (&res1->list != res_list1) {\r\nlist_for_each_entry(res2, res_list2, list) {\r\nif (res1->start >= res2->end ||\r\nres1->end <= res2->start)\r\ncontinue;\r\nelse if (res1->end <= res2->end &&\r\nres1->start >= res2->start) {\r\nlist_del(&res1->list);\r\nkfree(res1);\r\nbreak;\r\n} else if (res1->end > res2->end &&\r\nres1->start < res2->start) {\r\nres = kmalloc(sizeof(*res), GFP_KERNEL);\r\nif (!res)\r\nreturn -ENOMEM;\r\nres->start = res2->end;\r\nres->end = res1->end;\r\nres1->end = res2->start;\r\nlist_add(&res->list, &res1->list);\r\nresn1 = res;\r\n} else {\r\nif (res1->start < res2->start)\r\nres1->end = res2->start;\r\nelse\r\nres1->start = res2->end;\r\n}\r\n}\r\nres1 = resn1;\r\nresn1 = list_entry(resn1->list.next, struct apei_res, list);\r\n}\r\nreturn 0;\r\n}\r\nstatic void apei_res_clean(struct list_head *res_list)\r\n{\r\nstruct apei_res *res, *resn;\r\nlist_for_each_entry_safe(res, resn, res_list, list) {\r\nlist_del(&res->list);\r\nkfree(res);\r\n}\r\n}\r\nvoid apei_resources_fini(struct apei_resources *resources)\r\n{\r\napei_res_clean(&resources->iomem);\r\napei_res_clean(&resources->ioport);\r\n}\r\nstatic int apei_resources_merge(struct apei_resources *resources1,\r\nstruct apei_resources *resources2)\r\n{\r\nint rc;\r\nstruct apei_res *res;\r\nlist_for_each_entry(res, &resources2->iomem, list) {\r\nrc = apei_res_add(&resources1->iomem, res->start,\r\nres->end - res->start);\r\nif (rc)\r\nreturn rc;\r\n}\r\nlist_for_each_entry(res, &resources2->ioport, list) {\r\nrc = apei_res_add(&resources1->ioport, res->start,\r\nres->end - res->start);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint apei_resources_sub(struct apei_resources *resources1,\r\nstruct apei_resources *resources2)\r\n{\r\nint rc;\r\nrc = apei_res_sub(&resources1->iomem, &resources2->iomem);\r\nif (rc)\r\nreturn rc;\r\nreturn apei_res_sub(&resources1->ioport, &resources2->ioport);\r\n}\r\nint apei_resources_request(struct apei_resources *resources,\r\nconst char *desc)\r\n{\r\nstruct apei_res *res, *res_bak = NULL;\r\nstruct resource *r;\r\nint rc;\r\nrc = apei_resources_sub(resources, &apei_resources_all);\r\nif (rc)\r\nreturn rc;\r\nrc = -EINVAL;\r\nlist_for_each_entry(res, &resources->iomem, list) {\r\nr = request_mem_region(res->start, res->end - res->start,\r\ndesc);\r\nif (!r) {\r\npr_err(APEI_PFX\r\n"Can not request iomem region <%016llx-%016llx> for GARs.\n",\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end);\r\nres_bak = res;\r\ngoto err_unmap_iomem;\r\n}\r\n}\r\nlist_for_each_entry(res, &resources->ioport, list) {\r\nr = request_region(res->start, res->end - res->start, desc);\r\nif (!r) {\r\npr_err(APEI_PFX\r\n"Can not request ioport region <%016llx-%016llx> for GARs.\n",\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end);\r\nres_bak = res;\r\ngoto err_unmap_ioport;\r\n}\r\n}\r\nrc = apei_resources_merge(&apei_resources_all, resources);\r\nif (rc) {\r\npr_err(APEI_PFX "Fail to merge resources!\n");\r\ngoto err_unmap_ioport;\r\n}\r\nreturn 0;\r\nerr_unmap_ioport:\r\nlist_for_each_entry(res, &resources->ioport, list) {\r\nif (res == res_bak)\r\nbreak;\r\nrelease_region(res->start, res->end - res->start);\r\n}\r\nres_bak = NULL;\r\nerr_unmap_iomem:\r\nlist_for_each_entry(res, &resources->iomem, list) {\r\nif (res == res_bak)\r\nbreak;\r\nrelease_mem_region(res->start, res->end - res->start);\r\n}\r\nreturn rc;\r\n}\r\nvoid apei_resources_release(struct apei_resources *resources)\r\n{\r\nint rc;\r\nstruct apei_res *res;\r\nlist_for_each_entry(res, &resources->iomem, list)\r\nrelease_mem_region(res->start, res->end - res->start);\r\nlist_for_each_entry(res, &resources->ioport, list)\r\nrelease_region(res->start, res->end - res->start);\r\nrc = apei_resources_sub(&apei_resources_all, resources);\r\nif (rc)\r\npr_err(APEI_PFX "Fail to sub resources!\n");\r\n}\r\nstatic int apei_check_gar(struct acpi_generic_address *reg, u64 *paddr)\r\n{\r\nu32 width, space_id;\r\nwidth = reg->bit_width;\r\nspace_id = reg->space_id;\r\nmemcpy(paddr, &reg->address, sizeof(*paddr));\r\nif (!*paddr) {\r\npr_warning(FW_BUG APEI_PFX\r\n"Invalid physical address in GAR [0x%llx/%u/%u]\n",\r\n*paddr, width, space_id);\r\nreturn -EINVAL;\r\n}\r\nif ((width != 8) && (width != 16) && (width != 32) && (width != 64)) {\r\npr_warning(FW_BUG APEI_PFX\r\n"Invalid bit width in GAR [0x%llx/%u/%u]\n",\r\n*paddr, width, space_id);\r\nreturn -EINVAL;\r\n}\r\nif (space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY &&\r\nspace_id != ACPI_ADR_SPACE_SYSTEM_IO) {\r\npr_warning(FW_BUG APEI_PFX\r\n"Invalid address space type in GAR [0x%llx/%u/%u]\n",\r\n*paddr, width, space_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int collect_res_callback(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry,\r\nvoid *data)\r\n{\r\nstruct apei_resources *resources = data;\r\nstruct acpi_generic_address *reg = &entry->register_region;\r\nu8 ins = entry->instruction;\r\nu64 paddr;\r\nint rc;\r\nif (!(ctx->ins_table[ins].flags & APEI_EXEC_INS_ACCESS_REGISTER))\r\nreturn 0;\r\nrc = apei_check_gar(reg, &paddr);\r\nif (rc)\r\nreturn rc;\r\nswitch (reg->space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_MEMORY:\r\nreturn apei_res_add(&resources->iomem, paddr,\r\nreg->bit_width / 8);\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\nreturn apei_res_add(&resources->ioport, paddr,\r\nreg->bit_width / 8);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint apei_exec_collect_resources(struct apei_exec_context *ctx,\r\nstruct apei_resources *resources)\r\n{\r\nreturn apei_exec_for_each_entry(ctx, collect_res_callback,\r\nresources, NULL);\r\n}\r\nstruct dentry *apei_get_debugfs_dir(void)\r\n{\r\nstatic struct dentry *dapei;\r\nif (!dapei)\r\ndapei = debugfs_create_dir("apei", NULL);\r\nreturn dapei;\r\n}\r\nint apei_osc_setup(void)\r\n{\r\nstatic u8 whea_uuid_str[] = "ed855e0c-6c90-47bf-a62a-26de0fc5ad5c";\r\nacpi_handle handle;\r\nu32 capbuf[3];\r\nstruct acpi_osc_context context = {\r\n.uuid_str = whea_uuid_str,\r\n.rev = 1,\r\n.cap.length = sizeof(capbuf),\r\n.cap.pointer = capbuf,\r\n};\r\ncapbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;\r\ncapbuf[OSC_SUPPORT_TYPE] = 1;\r\ncapbuf[OSC_CONTROL_TYPE] = 0;\r\nif (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle))\r\n|| ACPI_FAILURE(acpi_run_osc(handle, &context)))\r\nreturn -EIO;\r\nelse {\r\nkfree(context.ret.pointer);\r\nreturn 0;\r\n}\r\n}
