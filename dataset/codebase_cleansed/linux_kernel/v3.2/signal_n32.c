asmlinkage int sysn32_rt_sigsuspend(nabi_no_regargs struct pt_regs regs)\r\n{\r\ncompat_sigset_t __user *unewset;\r\ncompat_sigset_t uset;\r\nsize_t sigsetsize;\r\nsigset_t newset;\r\nsigsetsize = regs.regs[5];\r\nif (sigsetsize != sizeof(sigset_t))\r\nreturn -EINVAL;\r\nunewset = (compat_sigset_t __user *) regs.regs[4];\r\nif (copy_from_user(&uset, unewset, sizeof(uset)))\r\nreturn -EFAULT;\r\nsigset_from_compat(&newset, &uset);\r\nsigdelsetmask(&newset, ~_BLOCKABLE);\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->saved_sigmask = current->blocked;\r\ncurrent->blocked = newset;\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule();\r\nset_thread_flag(TIF_RESTORE_SIGMASK);\r\nreturn -ERESTARTNOHAND;\r\n}\r\nasmlinkage void sysn32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)\r\n{\r\nstruct rt_sigframe_n32 __user *frame;\r\nmm_segment_t old_fs;\r\nsigset_t set;\r\nstack_t st;\r\ns32 sp;\r\nint sig;\r\nframe = (struct rt_sigframe_n32 __user *) regs.regs[29];\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_conv_sigset_from_user(&set, &frame->rs_uc.uc_sigmask))\r\ngoto badframe;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->blocked = set;\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\nsig = restore_sigcontext(&regs, &frame->rs_uc.uc_mcontext);\r\nif (sig < 0)\r\ngoto badframe;\r\nelse if (sig)\r\nforce_sig(sig, current);\r\nif (__get_user(sp, &frame->rs_uc.uc_stack.ss_sp))\r\ngoto badframe;\r\nst.ss_sp = (void __user *)(long) sp;\r\nif (__get_user(st.ss_size, &frame->rs_uc.uc_stack.ss_size))\r\ngoto badframe;\r\nif (__get_user(st.ss_flags, &frame->rs_uc.uc_stack.ss_flags))\r\ngoto badframe;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\ndo_sigaltstack((stack_t __user *)&st, NULL, regs.regs[29]);\r\nset_fs(old_fs);\r\n__asm__ __volatile__(\r\n"move\t$29, %0\n\t"\r\n"j\tsyscall_exit"\r\n:\r\n:"r" (&regs));\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nstatic int setup_rt_frame_n32(void *sig_return, struct k_sigaction *ka,\r\nstruct pt_regs *regs, int signr, sigset_t *set, siginfo_t *info)\r\n{\r\nstruct rt_sigframe_n32 __user *frame;\r\nint err = 0;\r\ns32 sp;\r\nframe = get_sigframe(ka, regs, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\r\ngoto give_sigsegv;\r\nerr |= copy_siginfo_to_user32(&frame->rs_info, info);\r\nerr |= __put_user(0, &frame->rs_uc.uc_flags);\r\nerr |= __put_user(0, &frame->rs_uc.uc_link);\r\nsp = (int) (long) current->sas_ss_sp;\r\nerr |= __put_user(sp,\r\n&frame->rs_uc.uc_stack.ss_sp);\r\nerr |= __put_user(sas_ss_flags(regs->regs[29]),\r\n&frame->rs_uc.uc_stack.ss_flags);\r\nerr |= __put_user(current->sas_ss_size,\r\n&frame->rs_uc.uc_stack.ss_size);\r\nerr |= setup_sigcontext(regs, &frame->rs_uc.uc_mcontext);\r\nerr |= __copy_conv_sigset_to_user(&frame->rs_uc.uc_sigmask, set);\r\nif (err)\r\ngoto give_sigsegv;\r\nregs->regs[ 4] = signr;\r\nregs->regs[ 5] = (unsigned long) &frame->rs_info;\r\nregs->regs[ 6] = (unsigned long) &frame->rs_uc;\r\nregs->regs[29] = (unsigned long) frame;\r\nregs->regs[31] = (unsigned long) sig_return;\r\nregs->cp0_epc = regs->regs[25] = (unsigned long) ka->sa.sa_handler;\r\nDEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",\r\ncurrent->comm, current->pid,\r\nframe, regs->cp0_epc, regs->regs[31]);\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(signr, current);\r\nreturn -EFAULT;\r\n}
