static unsigned char\r\nReadByteAmd7930(struct IsdnCardState *cs, unsigned char offset)\r\n{\r\nif(offset < 8)\r\nreturn (inb(cs->hw.njet.isac + 4*offset));\r\nelse {\r\noutb(offset, cs->hw.njet.isac + 4*AMD_CR);\r\nreturn(inb(cs->hw.njet.isac + 4*AMD_DR));\r\n}\r\n}\r\nstatic void\r\nWriteByteAmd7930(struct IsdnCardState *cs, unsigned char offset, unsigned char value)\r\n{\r\nif(offset < 8)\r\noutb(value, cs->hw.njet.isac + 4*offset);\r\nelse {\r\noutb(offset, cs->hw.njet.isac + 4*AMD_CR);\r\noutb(value, cs->hw.njet.isac + 4*AMD_DR);\r\n}\r\n}\r\nstatic void\r\nenpci_setIrqMask(struct IsdnCardState *cs, unsigned char val) {\r\nif (!val)\r\noutb(0x00, cs->hw.njet.base+NETJET_IRQMASK1);\r\nelse\r\noutb(TJ_AMD_IRQ, cs->hw.njet.base+NETJET_IRQMASK1);\r\n}\r\nstatic unsigned char dummyrr(struct IsdnCardState *cs, int chan, unsigned char off)\r\n{\r\nreturn(5);\r\n}\r\nstatic void dummywr(struct IsdnCardState *cs, int chan, unsigned char off, unsigned char value)\r\n{\r\n}\r\nstatic void\r\nreset_enpci(struct IsdnCardState *cs)\r\n{\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "enter:now PCI: reset");\r\ncs->hw.njet.ctrl_reg = 0x07;\r\noutb(cs->hw.njet.ctrl_reg, cs->hw.njet.base + NETJET_CTRL);\r\nmdelay(20);\r\ncs->hw.njet.ctrl_reg = 0x30;\r\noutb(cs->hw.njet.ctrl_reg, cs->hw.njet.base + NETJET_CTRL);\r\nmdelay(20);\r\ncs->hw.njet.auxd = 0;\r\ncs->hw.njet.dmactrl = 0;\r\noutb(~TJ_AMD_IRQ, cs->hw.njet.base + NETJET_AUXCTRL);\r\noutb(TJ_AMD_IRQ, cs->hw.njet.base + NETJET_IRQMASK1);\r\noutb(cs->hw.njet.auxd, cs->hw.njet.auxa);\r\n}\r\nstatic int\r\nenpci_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nunsigned char *chan;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "enter:now PCI: card_msg: 0x%04X", mt);\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_enpci(cs);\r\nAmd7930_init(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase CARD_RELEASE:\r\nrelease_io_netjet(cs);\r\nbreak;\r\ncase CARD_INIT:\r\nreset_enpci(cs);\r\ninittiger(cs);\r\nAmd7930_init(cs);\r\nbreak;\r\ncase CARD_TEST:\r\nbreak;\r\ncase MDL_ASSIGN:\r\ncs->hw.njet.auxd = TJ_AMD_IRQ << 1;\r\noutb(cs->hw.njet.auxd, cs->hw.njet.base + NETJET_AUXDATA);\r\nbreak;\r\ncase MDL_REMOVE:\r\ncs->hw.njet.auxd = 0;\r\noutb(0x00, cs->hw.njet.base + NETJET_AUXDATA);\r\nbreak;\r\ncase MDL_BC_ASSIGN:\r\nchan = (unsigned char *)arg;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "enter:now PCI: assign phys. BC %d in AMD LMR1", *chan);\r\ncs->dc.amd7930.ph_command(cs, (cs->dc.amd7930.lmr1 | (*chan + 1)), "MDL_BC_ASSIGN");\r\ncs->hw.njet.auxd |= TJ_AMD_IRQ << 2;\r\noutb(cs->hw.njet.auxd, cs->hw.njet.base + NETJET_AUXDATA);\r\nbreak;\r\ncase MDL_BC_RELEASE:\r\nchan = (unsigned char *)arg;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "enter:now PCI: release phys. BC %d in Amd LMR1", *chan);\r\ncs->dc.amd7930.ph_command(cs, (cs->dc.amd7930.lmr1 & ~(*chan + 1)), "MDL_BC_RELEASE");\r\nif (!(cs->dc.amd7930.lmr1 & 3)) {\r\ncs->hw.njet.auxd &= ~(TJ_AMD_IRQ << 2);\r\noutb(cs->hw.njet.auxd, cs->hw.njet.base + NETJET_AUXDATA);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn(0);\r\n}\r\nstatic irqreturn_t\r\nenpci_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nunsigned char s0val, s1val, ir;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\ns1val = inb(cs->hw.njet.base + NETJET_IRQSTAT1);\r\nif (!(s1val & TJ_AMD_IRQ)) {\r\nir = ReadByteAmd7930(cs, 0x00);\r\nAmd7930_interrupt(cs, ir);\r\ns1val = 1;\r\n} else\r\ns1val = 0;\r\ns0val = inb(cs->hw.njet.base + NETJET_IRQSTAT0);\r\nif ((s0val | s1val)==0) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (s0val)\r\noutb(s0val, cs->hw.njet.base + NETJET_IRQSTAT0);\r\nif (inl(cs->hw.njet.base + NETJET_DMA_WRITE_ADR) <\r\ninl(cs->hw.njet.base + NETJET_DMA_WRITE_IRQ))\r\ns0val = 0x08;\r\nelse\r\ns0val = 0x04;\r\nif (inl(cs->hw.njet.base + NETJET_DMA_READ_ADR) <\r\ninl(cs->hw.njet.base + NETJET_DMA_READ_IRQ))\r\ns0val = s0val | 0x02;\r\nelse\r\ns0val = s0val | 0x01;\r\nif (s0val != cs->hw.njet.last_is0)\r\n{\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\ncs->hw.njet.irqstat0 = s0val;\r\nif ((cs->hw.njet.irqstat0 & NETJET_IRQM0_READ) !=\r\n(cs->hw.njet.last_is0 & NETJET_IRQM0_READ))\r\nread_tiger(cs);\r\nif ((cs->hw.njet.irqstat0 & NETJET_IRQM0_WRITE) !=\r\n(cs->hw.njet.last_is0 & NETJET_IRQM0_WRITE))\r\nwrite_tiger(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit en_pci_probe(struct pci_dev *dev_netjet,\r\nstruct IsdnCardState *cs)\r\n{\r\nif (pci_enable_device(dev_netjet))\r\nreturn(0);\r\ncs->irq = dev_netjet->irq;\r\nif (!cs->irq) {\r\nprintk(KERN_WARNING "enter:now PCI: No IRQ for PCI card found\n");\r\nreturn(0);\r\n}\r\ncs->hw.njet.base = pci_resource_start(dev_netjet, 0);\r\nif (!cs->hw.njet.base) {\r\nprintk(KERN_WARNING "enter:now PCI: No IO-Adr for PCI card found\n");\r\nreturn(0);\r\n}\r\nif ((dev_netjet->subsystem_vendor != 0x55) ||\r\n(dev_netjet->subsystem_device != 0x02)) {\r\nprintk(KERN_WARNING "enter:now: You tried to load this driver with an incompatible TigerJet-card\n");\r\nprintk(KERN_WARNING "Use type=20 for Traverse NetJet PCI Card.\n");\r\nreturn(0);\r\n}\r\nreturn(1);\r\n}\r\nstatic void __devinit en_cs_init(struct IsdnCard *card,\r\nstruct IsdnCardState *cs)\r\n{\r\ncs->hw.njet.auxa = cs->hw.njet.base + NETJET_AUXDATA;\r\ncs->hw.njet.isac = cs->hw.njet.base + 0xC0;\r\ncs->hw.njet.ctrl_reg = 0x07;\r\noutb(cs->hw.njet.ctrl_reg, cs->hw.njet.base + NETJET_CTRL);\r\nmdelay(20);\r\ncs->hw.njet.ctrl_reg = 0x30;\r\noutb(cs->hw.njet.ctrl_reg, cs->hw.njet.base + NETJET_CTRL);\r\nmdelay(10);\r\ncs->hw.njet.auxd = 0x00;\r\ncs->hw.njet.dmactrl = 0;\r\noutb(~TJ_AMD_IRQ, cs->hw.njet.base + NETJET_AUXCTRL);\r\noutb(TJ_AMD_IRQ, cs->hw.njet.base + NETJET_IRQMASK1);\r\noutb(cs->hw.njet.auxd, cs->hw.njet.auxa);\r\n}\r\nstatic int __devinit en_cs_init_rest(struct IsdnCard *card,\r\nstruct IsdnCardState *cs)\r\n{\r\nconst int bytecnt = 256;\r\nprintk(KERN_INFO\r\n"enter:now PCI: PCI card configured at 0x%lx IRQ %d\n",\r\ncs->hw.njet.base, cs->irq);\r\nif (!request_region(cs->hw.njet.base, bytecnt, "Fn_ISDN")) {\r\nprintk(KERN_WARNING\r\n"HiSax: enter:now config port %lx-%lx already in use\n",\r\ncs->hw.njet.base,\r\ncs->hw.njet.base + bytecnt);\r\nreturn (0);\r\n}\r\nsetup_Amd7930(cs);\r\ncs->hw.njet.last_is0 = 0;\r\ncs->readisac = &ReadByteAmd7930;\r\ncs->writeisac = &WriteByteAmd7930;\r\ncs->dc.amd7930.setIrqMask = &enpci_setIrqMask;\r\ncs->BC_Read_Reg = &dummyrr;\r\ncs->BC_Write_Reg = &dummywr;\r\ncs->BC_Send_Data = &netjet_fill_dma;\r\ncs->cardmsg = &enpci_card_msg;\r\ncs->irq_func = &enpci_interrupt;\r\ncs->irq_flags |= IRQF_SHARED;\r\nreturn (1);\r\n}\r\nint __devinit\r\nsetup_enternow_pci(struct IsdnCard *card)\r\n{\r\nint ret;\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\n#ifdef __BIG_ENDIAN\r\n#error "not running on big endian machines now"\r\n#endif\r\nstrcpy(tmp, enternow_pci_rev);\r\nprintk(KERN_INFO "HiSax: Formula-n Europe AG enter:now ISDN PCI driver Rev. %s\n", HiSax_getrev(tmp));\r\nif (cs->typ != ISDN_CTYPE_ENTERNOW)\r\nreturn(0);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nfor ( ;; )\r\n{\r\nif ((dev_netjet = hisax_find_pci_device(PCI_VENDOR_ID_TIGERJET,\r\nPCI_DEVICE_ID_TIGERJET_300, dev_netjet))) {\r\nret = en_pci_probe(dev_netjet, cs);\r\nif (!ret)\r\nreturn(0);\r\n} else {\r\nprintk(KERN_WARNING "enter:now PCI: No PCI card found\n");\r\nreturn(0);\r\n}\r\nen_cs_init(card, cs);\r\nbreak;\r\n}\r\nreturn en_cs_init_rest(card, cs);\r\n}
