unsigned long thread_saved_pc(struct task_struct *tsk)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *)tsk->thread.ksp;\r\nif (in_sched_functions(sw->retpc))\r\nreturn ((unsigned long *)sw->a6)[1];\r\nelse\r\nreturn sw->retpc;\r\n}\r\nstatic void default_idle(void)\r\n{\r\nif (!need_resched())\r\n#if defined(MACH_ATARI_ONLY)\r\n__asm__("stop #0x2200" : : : "cc");\r\n#else\r\n__asm__("stop #0x2000" : : : "cc");\r\n#endif\r\n}\r\nvoid cpu_idle(void)\r\n{\r\nwhile (1) {\r\nwhile (!need_resched())\r\nidle();\r\npreempt_enable_no_resched();\r\nschedule();\r\npreempt_disable();\r\n}\r\n}\r\nvoid machine_restart(char * __unused)\r\n{\r\nif (mach_reset)\r\nmach_reset();\r\nfor (;;);\r\n}\r\nvoid machine_halt(void)\r\n{\r\nif (mach_halt)\r\nmach_halt();\r\nfor (;;);\r\n}\r\nvoid machine_power_off(void)\r\n{\r\nif (mach_power_off)\r\nmach_power_off();\r\nfor (;;);\r\n}\r\nvoid show_regs(struct pt_regs * regs)\r\n{\r\nprintk("\n");\r\nprintk("Format %02x Vector: %04x PC: %08lx Status: %04x %s\n",\r\nregs->format, regs->vector, regs->pc, regs->sr, print_tainted());\r\nprintk("ORIG_D0: %08lx D0: %08lx A2: %08lx A1: %08lx\n",\r\nregs->orig_d0, regs->d0, regs->a2, regs->a1);\r\nprintk("A0: %08lx D5: %08lx D4: %08lx\n",\r\nregs->a0, regs->d5, regs->d4);\r\nprintk("D3: %08lx D2: %08lx D1: %08lx\n",\r\nregs->d3, regs->d2, regs->d1);\r\nif (!(regs->sr & PS_S))\r\nprintk("USP: %08lx\n", rdusp());\r\n}\r\nint kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)\r\n{\r\nint pid;\r\nmm_segment_t fs;\r\nfs = get_fs();\r\nset_fs (KERNEL_DS);\r\n{\r\nregister long retval __asm__ ("d0");\r\nregister long clone_arg __asm__ ("d1") = flags | CLONE_VM | CLONE_UNTRACED;\r\nretval = __NR_clone;\r\n__asm__ __volatile__\r\n("clrl %%d2\n\t"\r\n"trap #0\n\t"\r\n"tstl %0\n\t"\r\n"jne 1f\n\t"\r\n"lea %%sp@(%c7),%6\n\t"\r\n"movel %6@,%6\n\t"\r\n"movel %3,%%sp@-\n\t"\r\n"jsr %4@\n\t"\r\n"movel %0,%%d1\n\t"\r\n"movel %2,%%d0\n\t"\r\n"trap #0\n"\r\n"1:"\r\n: "+d" (retval)\r\n: "i" (__NR_clone), "i" (__NR_exit),\r\n"r" (arg), "a" (fn), "d" (clone_arg), "r" (current),\r\n"i" (-THREAD_SIZE)\r\n: "d2");\r\npid = retval;\r\n}\r\nset_fs (fs);\r\nreturn pid;\r\n}\r\nvoid flush_thread(void)\r\n{\r\nunsigned long zero = 0;\r\ncurrent->thread.fs = __USER_DS;\r\nif (!FPU_IS_EMU)\r\nasm volatile (".chip 68k/68881\n\t"\r\n"frestore %0@\n\t"\r\n".chip 68k" : : "a" (&zero));\r\n}\r\nasmlinkage int m68k_fork(struct pt_regs *regs)\r\n{\r\nreturn do_fork(SIGCHLD, rdusp(), regs, 0, NULL, NULL);\r\n}\r\nasmlinkage int m68k_vfork(struct pt_regs *regs)\r\n{\r\nreturn do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0,\r\nNULL, NULL);\r\n}\r\nasmlinkage int m68k_clone(struct pt_regs *regs)\r\n{\r\nunsigned long clone_flags;\r\nunsigned long newsp;\r\nint __user *parent_tidptr, *child_tidptr;\r\nclone_flags = regs->d1;\r\nnewsp = regs->d2;\r\nparent_tidptr = (int __user *)regs->d3;\r\nchild_tidptr = (int __user *)regs->d4;\r\nif (!newsp)\r\nnewsp = rdusp();\r\nreturn do_fork(clone_flags, newsp, regs, 0,\r\nparent_tidptr, child_tidptr);\r\n}\r\nint copy_thread(unsigned long clone_flags, unsigned long usp,\r\nunsigned long unused,\r\nstruct task_struct * p, struct pt_regs * regs)\r\n{\r\nstruct pt_regs * childregs;\r\nstruct switch_stack * childstack, *stack;\r\nunsigned long *retp;\r\nchildregs = (struct pt_regs *) (task_stack_page(p) + THREAD_SIZE) - 1;\r\n*childregs = *regs;\r\nchildregs->d0 = 0;\r\nretp = ((unsigned long *) regs);\r\nstack = ((struct switch_stack *) retp) - 1;\r\nchildstack = ((struct switch_stack *) childregs) - 1;\r\n*childstack = *stack;\r\nchildstack->retpc = (unsigned long)ret_from_fork;\r\np->thread.usp = usp;\r\np->thread.ksp = (unsigned long)childstack;\r\nif (clone_flags & CLONE_SETTLS)\r\ntask_thread_info(p)->tp_value = regs->d5;\r\np->thread.fs = get_fs().seg;\r\nif (!FPU_IS_EMU) {\r\nasm volatile ("fsave %0" : : "m" (p->thread.fpstate[0]) : "memory");\r\nif (!CPU_IS_060 ? p->thread.fpstate[0] : p->thread.fpstate[2])\r\nasm volatile ("fmovemx %/fp0-%/fp7,%0\n\t"\r\n"fmoveml %/fpiar/%/fpcr/%/fpsr,%1"\r\n: : "m" (p->thread.fp[0]), "m" (p->thread.fpcntl[0])\r\n: "memory");\r\nasm volatile ("frestore %0" : : "m" (p->thread.fpstate[0]));\r\n}\r\nreturn 0;\r\n}\r\nint dump_fpu (struct pt_regs *regs, struct user_m68kfp_struct *fpu)\r\n{\r\nchar fpustate[216];\r\nif (FPU_IS_EMU) {\r\nint i;\r\nmemcpy(fpu->fpcntl, current->thread.fpcntl, 12);\r\nmemcpy(fpu->fpregs, current->thread.fp, 96);\r\nfor (i = 0; i < 24; i += 3)\r\nfpu->fpregs[i] = ((fpu->fpregs[i] & 0xffff0000) << 15) |\r\n((fpu->fpregs[i] & 0x0000ffff) << 16);\r\nreturn 1;\r\n}\r\nasm volatile ("fsave %0" :: "m" (fpustate[0]) : "memory");\r\nif (!CPU_IS_060 ? !fpustate[0] : !fpustate[2])\r\nreturn 0;\r\nasm volatile ("fmovem %/fpiar/%/fpcr/%/fpsr,%0"\r\n:: "m" (fpu->fpcntl[0])\r\n: "memory");\r\nasm volatile ("fmovemx %/fp0-%/fp7,%0"\r\n:: "m" (fpu->fpregs[0])\r\n: "memory");\r\nreturn 1;\r\n}\r\nasmlinkage int sys_execve(const char __user *name,\r\nconst char __user *const __user *argv,\r\nconst char __user *const __user *envp)\r\n{\r\nint error;\r\nchar * filename;\r\nstruct pt_regs *regs = (struct pt_regs *) &name;\r\nfilename = getname(name);\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\nreturn error;\r\nerror = do_execve(filename, argv, envp, regs);\r\nputname(filename);\r\nreturn error;\r\n}\r\nunsigned long get_wchan(struct task_struct *p)\r\n{\r\nunsigned long fp, pc;\r\nunsigned long stack_page;\r\nint count = 0;\r\nif (!p || p == current || p->state == TASK_RUNNING)\r\nreturn 0;\r\nstack_page = (unsigned long)task_stack_page(p);\r\nfp = ((struct switch_stack *)p->thread.ksp)->a6;\r\ndo {\r\nif (fp < stack_page+sizeof(struct thread_info) ||\r\nfp >= 8184+stack_page)\r\nreturn 0;\r\npc = ((unsigned long *)fp)[1];\r\nif (!in_sched_functions(pc))\r\nreturn pc;\r\nfp = *(unsigned long *) fp;\r\n} while (count++ < 16);\r\nreturn 0;\r\n}
