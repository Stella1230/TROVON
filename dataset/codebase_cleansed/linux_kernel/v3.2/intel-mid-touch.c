static int mrstouch_nec_adc_read_prepare(struct mrstouch_dev *tsdev)\r\n{\r\nreturn intel_scu_ipc_update_register(PMIC_REG_MADCINT, 0, 0x20);\r\n}\r\nstatic int mrstouch_nec_adc_read_finish(struct mrstouch_dev *tsdev)\r\n{\r\nint err;\r\nerr = intel_scu_ipc_update_register(PMIC_REG_MADCINT, 0x20, 0x20);\r\nif (!err)\r\nerr = intel_scu_ipc_update_register(PMIC_REG_ADCCNTL1, 0, 0x05);\r\nreturn err;\r\n}\r\nstatic int mrstouch_ts_chan_read(u16 offset, u16 chan, u16 *vp, u16 *vm)\r\n{\r\nint err;\r\nu16 result;\r\nu32 res;\r\nresult = PMIC_REG_ADCSNS0H + offset;\r\nif (chan == MRST_TS_CHAN12)\r\nresult += 4;\r\nerr = intel_scu_ipc_ioread32(result, &res);\r\nif (err)\r\nreturn err;\r\n*vp = (res & 0xFF) << 3;\r\n*vp |= (res >> 8) & 0x07;\r\n*vp &= 0x3FF;\r\nres >>= 16;\r\n*vm = (res & 0xFF) << 3;\r\n*vm |= (res >> 8) & 0x07;\r\n*vm &= 0x3FF;\r\nreturn 0;\r\n}\r\nstatic int mrstouch_ts_bias_set(uint offset, uint bias)\r\n{\r\nint count;\r\nu16 chan, start;\r\nu16 reg[4];\r\nu8 data[4];\r\nchan = PMICADDR0 + offset;\r\nstart = MRST_TS_CHAN10;\r\nfor (count = 0; count <= 3; count++) {\r\nreg[count] = chan++;\r\ndata[count] = bias | (start + count);\r\n}\r\nreturn intel_scu_ipc_writev(reg, data, 4);\r\n}\r\nstatic int mrstouch_nec_adc_read(struct mrstouch_dev *tsdev,\r\nu16 *x, u16 *y, u16 *z)\r\n{\r\nint err;\r\nu16 xm, ym, zm;\r\nerr = mrstouch_ts_bias_set(tsdev->asr, MRST_YBIAS);\r\nif (err)\r\ngoto ipc_error;\r\nmsleep(WAIT_ADC_COMPLETION);\r\nerr = mrstouch_ts_chan_read(tsdev->asr, MRST_TS_CHAN10, x, &xm);\r\nif (err)\r\ngoto ipc_error;\r\nerr = mrstouch_ts_bias_set(tsdev->asr, MRST_XBIAS);\r\nif (err)\r\ngoto ipc_error;\r\nmsleep(WAIT_ADC_COMPLETION);\r\nerr = mrstouch_ts_chan_read(tsdev->asr, MRST_TS_CHAN12, y, &ym);\r\nif (err)\r\ngoto ipc_error;\r\nerr = mrstouch_ts_bias_set(tsdev->asr, MRST_ZBIAS);\r\nif (err)\r\ngoto ipc_error;\r\nmsleep(WAIT_ADC_COMPLETION);\r\nerr = mrstouch_ts_chan_read(tsdev->asr, MRST_TS_CHAN10, z, &zm);\r\nif (err)\r\ngoto ipc_error;\r\nreturn 0;\r\nipc_error:\r\ndev_err(tsdev->dev, "ipc error during adc read\n");\r\nreturn err;\r\n}\r\nstatic int mrstouch_fs_adc_read_prepare(struct mrstouch_dev *tsdev)\r\n{\r\nint err, count;\r\nu16 chan;\r\nu16 reg[5];\r\nu8 data[5];\r\nerr = intel_scu_ipc_update_register(PMIC_REG_MADCINT, 0x00, 0x02);\r\nif (err)\r\ngoto ipc_error;\r\nchan = PMICADDR0 + tsdev->asr;\r\nfor (count = 0; count <= 3; count++) {\r\nreg[count] = chan++;\r\ndata[count] = 0x2A;\r\n}\r\nreg[count] = chan++;\r\ndata[count] = 0;\r\nerr = intel_scu_ipc_writev(reg, data, 5);\r\nif (err)\r\ngoto ipc_error;\r\nmsleep(WAIT_ADC_COMPLETION);\r\nfor (count = 0; count <= 3; count++) {\r\nreg[count] = chan++;\r\ndata[count] = 0x4A;\r\n}\r\nreg[count] = chan++;\r\ndata[count] = 0;\r\nerr = intel_scu_ipc_writev(reg, data, 5);\r\nif (err)\r\ngoto ipc_error;\r\nmsleep(WAIT_ADC_COMPLETION);\r\nerr = intel_scu_ipc_iowrite32(chan + 2, 0x8A8A8A8A);\r\nif (err)\r\ngoto ipc_error;\r\nmsleep(WAIT_ADC_COMPLETION);\r\nreturn 0;\r\nipc_error:\r\ndev_err(tsdev->dev, "ipc error during %s\n", __func__);\r\nreturn err;\r\n}\r\nstatic int mrstouch_fs_adc_read(struct mrstouch_dev *tsdev,\r\nu16 *x, u16 *y, u16 *z)\r\n{\r\nint err;\r\nu16 result;\r\nu16 reg[4];\r\nu8 data[4];\r\nresult = PMIC_REG_ADCSNS0H + tsdev->asr;\r\nreg[0] = result + 4;\r\nreg[1] = result + 5;\r\nreg[2] = result + 16;\r\nreg[3] = result + 17;\r\nerr = intel_scu_ipc_readv(reg, data, 4);\r\nif (err)\r\ngoto ipc_error;\r\n*x = data[0] << 3;\r\n*x |= data[1] & 0x7;\r\n*x &= 0x3FF;\r\n*y = data[2] << 3;\r\n*y |= data[3] & 0x7;\r\n*y &= 0x3FF;\r\nreg[0] = result + 28;\r\nreg[1] = result + 29;\r\nerr = intel_scu_ipc_readv(reg, data, 4);\r\nif (err)\r\ngoto ipc_error;\r\n*z = data[0] << 3;\r\n*z |= data[1] & 0x7;\r\n*z &= 0x3FF;\r\nreturn 0;\r\nipc_error:\r\ndev_err(tsdev->dev, "ipc error during %s\n", __func__);\r\nreturn err;\r\n}\r\nstatic int mrstouch_fs_adc_read_finish(struct mrstouch_dev *tsdev)\r\n{\r\nint err, count;\r\nu16 chan;\r\nu16 reg[5];\r\nu8 data[5];\r\nchan = PMICADDR0 + tsdev->asr;\r\nfor (count = 0; count <= 4; count++) {\r\nreg[count] = chan++;\r\ndata[count] = 0;\r\n}\r\nerr = intel_scu_ipc_writev(reg, data, 5);\r\nif (err)\r\ngoto ipc_error;\r\nfor (count = 0; count <= 4; count++) {\r\nreg[count] = chan++;\r\ndata[count] = 0;\r\n}\r\nerr = intel_scu_ipc_writev(reg, data, 5);\r\nif (err)\r\ngoto ipc_error;\r\nerr = intel_scu_ipc_iowrite32(chan + 2, 0x00000000);\r\nif (err)\r\ngoto ipc_error;\r\nerr = intel_scu_ipc_update_register(PMIC_REG_MADCINT, 0x02, 0x02);\r\nif (err)\r\ngoto ipc_error;\r\nreturn 0;\r\nipc_error:\r\ndev_err(tsdev->dev, "ipc error during %s\n", __func__);\r\nreturn err;\r\n}\r\nstatic void mrstouch_report_event(struct input_dev *input,\r\nunsigned int x, unsigned int y, unsigned int z)\r\n{\r\nif (z > MRST_PRESSURE_NOMINAL) {\r\ninput_report_key(input, BTN_TOUCH, 1);\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\n} else {\r\ninput_report_key(input, BTN_TOUCH, 0);\r\n}\r\ninput_report_abs(input, ABS_PRESSURE, z);\r\ninput_sync(input);\r\n}\r\nstatic irqreturn_t mrstouch_pendet_irq(int irq, void *dev_id)\r\n{\r\nstruct mrstouch_dev *tsdev = dev_id;\r\nu16 x, y, z;\r\nif (tsdev->read_prepare(tsdev))\r\ngoto out;\r\ndo {\r\nif (tsdev->read(tsdev, &x, &y, &z))\r\nbreak;\r\nmrstouch_report_event(tsdev->input, x, y, z);\r\n} while (z > MRST_PRESSURE_NOMINAL);\r\ntsdev->read_finish(tsdev);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit mrstouch_read_pmic_id(uint *vendor, uint *rev)\r\n{\r\nint err;\r\nu8 r;\r\nerr = intel_scu_ipc_ioread8(PMIC_REG_ID1, &r);\r\nif (err)\r\nreturn err;\r\n*vendor = r & 0x7;\r\n*rev = (r >> 3) & 0x7;\r\nreturn 0;\r\n}\r\nstatic int __devinit mrstouch_chan_parse(struct mrstouch_dev *tsdev)\r\n{\r\nint found = 0;\r\nint err, i;\r\nu8 r8;\r\nfor (i = 0; i < MRSTOUCH_MAX_CHANNELS; i++) {\r\nerr = intel_scu_ipc_ioread8(PMICADDR0 + i, &r8);\r\nif (err)\r\nreturn err;\r\nif (r8 == END_OF_CHANNEL) {\r\nfound = i;\r\nbreak;\r\n}\r\n}\r\nif (tsdev->vendor == PMIC_VENDOR_FS) {\r\nif (found > MRSTOUCH_MAX_CHANNELS - 18)\r\nreturn -ENOSPC;\r\n} else {\r\nif (found > MRSTOUCH_MAX_CHANNELS - 4)\r\nreturn -ENOSPC;\r\n}\r\nreturn found;\r\n}\r\nstatic int __devinit mrstouch_ts_chan_set(uint offset)\r\n{\r\nu16 chan;\r\nint ret, count;\r\nchan = PMICADDR0 + offset;\r\nfor (count = 0; count <= 3; count++) {\r\nret = intel_scu_ipc_iowrite8(chan++, MRST_TS_CHAN10 + count);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn intel_scu_ipc_iowrite8(chan++, END_OF_CHANNEL);\r\n}\r\nstatic int __devinit mrstouch_adc_init(struct mrstouch_dev *tsdev)\r\n{\r\nint err, start;\r\nu8 ra, rm;\r\nerr = mrstouch_read_pmic_id(&tsdev->vendor, &tsdev->rev);\r\nif (err) {\r\ndev_err(tsdev->dev, "Unable to read PMIC id\n");\r\nreturn err;\r\n}\r\nswitch (tsdev->vendor) {\r\ncase PMIC_VENDOR_NEC:\r\ncase PMIC_VENDOR_MAXIM:\r\ntsdev->read_prepare = mrstouch_nec_adc_read_prepare;\r\ntsdev->read = mrstouch_nec_adc_read;\r\ntsdev->read_finish = mrstouch_nec_adc_read_finish;\r\nbreak;\r\ncase PMIC_VENDOR_FS:\r\ntsdev->read_prepare = mrstouch_fs_adc_read_prepare;\r\ntsdev->read = mrstouch_fs_adc_read;\r\ntsdev->read_finish = mrstouch_fs_adc_read_finish;\r\nbreak;\r\ndefault:\r\ndev_err(tsdev->dev,\r\n"Unsupported touchscreen: %d\n", tsdev->vendor);\r\nreturn -ENXIO;\r\n}\r\nstart = mrstouch_chan_parse(tsdev);\r\nif (start < 0) {\r\ndev_err(tsdev->dev, "Unable to parse channels\n");\r\nreturn start;\r\n}\r\ntsdev->asr = start;\r\nif (tsdev->vendor == PMIC_VENDOR_FS) {\r\nra = 0xE0 | ADC_LOOP_DELAY0;\r\nrm = 0x5;\r\n} else {\r\nra = 0xE0 | ADC_LOOP_DELAY1;\r\nrm = 0x0;\r\nerr = mrstouch_ts_chan_set(tsdev->asr);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = intel_scu_ipc_update_register(PMIC_REG_ADCCNTL1, ra, 0xE7);\r\nif (err)\r\nreturn err;\r\nerr = intel_scu_ipc_update_register(PMIC_REG_MADCINT, rm, 0x03);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int __devinit mrstouch_probe(struct platform_device *pdev)\r\n{\r\nstruct mrstouch_dev *tsdev;\r\nstruct input_dev *input;\r\nint err;\r\nint irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no interrupt assigned\n");\r\nreturn -EINVAL;\r\n}\r\ntsdev = kzalloc(sizeof(struct mrstouch_dev), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!tsdev || !input) {\r\ndev_err(&pdev->dev, "unable to allocate memory\n");\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ntsdev->dev = &pdev->dev;\r\ntsdev->input = input;\r\ntsdev->irq = irq;\r\nsnprintf(tsdev->phys, sizeof(tsdev->phys),\r\n"%s/input0", dev_name(tsdev->dev));\r\nerr = mrstouch_adc_init(tsdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "ADC initialization failed\n");\r\ngoto err_free_mem;\r\n}\r\ninput->name = "mrst_touchscreen";\r\ninput->phys = tsdev->phys;\r\ninput->dev.parent = tsdev->dev;\r\ninput->id.vendor = tsdev->vendor;\r\ninput->id.version = tsdev->rev;\r\ninput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(tsdev->input, ABS_X,\r\nMRST_X_MIN, MRST_X_MAX, MRST_X_FUZZ, 0);\r\ninput_set_abs_params(tsdev->input, ABS_Y,\r\nMRST_Y_MIN, MRST_Y_MAX, MRST_Y_FUZZ, 0);\r\ninput_set_abs_params(tsdev->input, ABS_PRESSURE,\r\nMRST_PRESSURE_MIN, MRST_PRESSURE_MAX, 0, 0);\r\nerr = request_threaded_irq(tsdev->irq, NULL, mrstouch_pendet_irq,\r\n0, "mrstouch", tsdev);\r\nif (err) {\r\ndev_err(tsdev->dev, "unable to allocate irq\n");\r\ngoto err_free_mem;\r\n}\r\nerr = input_register_device(tsdev->input);\r\nif (err) {\r\ndev_err(tsdev->dev, "unable to register input device\n");\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, tsdev);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(tsdev->irq, tsdev);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(tsdev);\r\nreturn err;\r\n}\r\nstatic int __devexit mrstouch_remove(struct platform_device *pdev)\r\n{\r\nstruct mrstouch_dev *tsdev = platform_get_drvdata(pdev);\r\nfree_irq(tsdev->irq, tsdev);\r\ninput_unregister_device(tsdev->input);\r\nkfree(tsdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init mrstouch_init(void)\r\n{\r\nreturn platform_driver_register(&mrstouch_driver);\r\n}\r\nstatic void __exit mrstouch_exit(void)\r\n{\r\nplatform_driver_unregister(&mrstouch_driver);\r\n}
