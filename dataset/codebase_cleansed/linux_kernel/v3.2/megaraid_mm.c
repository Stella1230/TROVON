static int\r\nmraid_mm_open(struct inode *inode, struct file *filep)\r\n{\r\nif (!capable(CAP_SYS_ADMIN)) return (-EACCES);\r\nreturn 0;\r\n}\r\nstatic int\r\nmraid_mm_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nuioc_t *kioc;\r\nchar signature[EXT_IOCTL_SIGN_SZ] = {0};\r\nint rval;\r\nmraid_mmadp_t *adp;\r\nuint8_t old_ioctl;\r\nint drvrcmd_rval;\r\nvoid __user *argp = (void __user *)arg;\r\nif ((_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD)) {\r\nreturn (-EINVAL);\r\n}\r\nif (copy_from_user(signature, argp, EXT_IOCTL_SIGN_SZ)) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid cmm: copy from usr addr failed\n"));\r\nreturn (-EFAULT);\r\n}\r\nif (memcmp(signature, EXT_IOCTL_SIGN, EXT_IOCTL_SIGN_SZ) == 0)\r\nold_ioctl = 0;\r\nelse\r\nold_ioctl = 1;\r\nif (!old_ioctl )\r\nreturn (-EINVAL);\r\nrval = handle_drvrcmd(argp, old_ioctl, &drvrcmd_rval);\r\nif (rval < 0)\r\nreturn rval;\r\nelse if (rval == 0)\r\nreturn drvrcmd_rval;\r\nrval = 0;\r\nif ((adp = mraid_mm_get_adapter(argp, &rval)) == NULL) {\r\nreturn rval;\r\n}\r\nif (!adp->quiescent) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid cmm: controller cannot accept cmds due to "\r\n"earlier errors\n" ));\r\nreturn -EFAULT;\r\n}\r\nkioc = mraid_mm_alloc_kioc(adp);\r\nif ((rval = mimd_to_kioc(argp, adp, kioc))) {\r\nmraid_mm_dealloc_kioc(adp, kioc);\r\nreturn rval;\r\n}\r\nkioc->done = ioctl_done;\r\nif ((rval = lld_ioctl(adp, kioc))) {\r\nif (!kioc->timedout)\r\nmraid_mm_dealloc_kioc(adp, kioc);\r\nreturn rval;\r\n}\r\nrval = kioc_to_mimd(kioc, argp);\r\nmraid_mm_dealloc_kioc(adp, kioc);\r\nreturn rval;\r\n}\r\nstatic long\r\nmraid_mm_unlocked_ioctl(struct file *filep, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err;\r\nmutex_lock(&mraid_mm_mutex);\r\nerr = mraid_mm_ioctl(filep, cmd, arg);\r\nmutex_unlock(&mraid_mm_mutex);\r\nreturn err;\r\n}\r\nstatic mraid_mmadp_t *\r\nmraid_mm_get_adapter(mimd_t __user *umimd, int *rval)\r\n{\r\nmraid_mmadp_t *adapter;\r\nmimd_t mimd;\r\nuint32_t adapno;\r\nint iterator;\r\nif (copy_from_user(&mimd, umimd, sizeof(mimd_t))) {\r\n*rval = -EFAULT;\r\nreturn NULL;\r\n}\r\nadapno = GETADAP(mimd.ui.fcs.adapno);\r\nif (adapno >= adapters_count_g) {\r\n*rval = -ENODEV;\r\nreturn NULL;\r\n}\r\nadapter = NULL;\r\niterator = 0;\r\nlist_for_each_entry(adapter, &adapters_list_g, list) {\r\nif (iterator++ == adapno) break;\r\n}\r\nif (!adapter) {\r\n*rval = -ENODEV;\r\nreturn NULL;\r\n}\r\nreturn adapter;\r\n}\r\nstatic int\r\nhandle_drvrcmd(void __user *arg, uint8_t old_ioctl, int *rval)\r\n{\r\nmimd_t __user *umimd;\r\nmimd_t kmimd;\r\nuint8_t opcode;\r\nuint8_t subopcode;\r\nif (old_ioctl)\r\ngoto old_packet;\r\nelse\r\ngoto new_packet;\r\nnew_packet:\r\nreturn (-ENOTSUPP);\r\nold_packet:\r\n*rval = 0;\r\numimd = arg;\r\nif (copy_from_user(&kmimd, umimd, sizeof(mimd_t)))\r\nreturn (-EFAULT);\r\nopcode = kmimd.ui.fcs.opcode;\r\nsubopcode = kmimd.ui.fcs.subopcode;\r\nif (opcode != 0x82)\r\nreturn 1;\r\nswitch (subopcode) {\r\ncase MEGAIOC_QDRVRVER:\r\nif (copy_to_user(kmimd.data, &drvr_ver, sizeof(uint32_t)))\r\nreturn (-EFAULT);\r\nreturn 0;\r\ncase MEGAIOC_QNADAP:\r\n*rval = adapters_count_g;\r\nif (copy_to_user(kmimd.data, &adapters_count_g,\r\nsizeof(uint32_t)))\r\nreturn (-EFAULT);\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmimd_to_kioc(mimd_t __user *umimd, mraid_mmadp_t *adp, uioc_t *kioc)\r\n{\r\nmbox64_t *mbox64;\r\nmbox_t *mbox;\r\nmraid_passthru_t *pthru32;\r\nuint32_t adapno;\r\nuint8_t opcode;\r\nuint8_t subopcode;\r\nmimd_t mimd;\r\nif (copy_from_user(&mimd, umimd, sizeof(mimd_t)))\r\nreturn (-EFAULT);\r\nif ((mimd.mbox[0] == MBOXCMD_PASSTHRU64) ||\r\n(mimd.mbox[0] == MBOXCMD_EXTPTHRU))\r\nreturn (-EINVAL);\r\nopcode = mimd.ui.fcs.opcode;\r\nsubopcode = mimd.ui.fcs.subopcode;\r\nadapno = GETADAP(mimd.ui.fcs.adapno);\r\nif (adapno >= adapters_count_g)\r\nreturn (-ENODEV);\r\nkioc->adapno = adapno;\r\nkioc->mb_type = MBOX_LEGACY;\r\nkioc->app_type = APPTYPE_MIMD;\r\nswitch (opcode) {\r\ncase 0x82:\r\nif (subopcode == MEGAIOC_QADAPINFO) {\r\nkioc->opcode = GET_ADAP_INFO;\r\nkioc->data_dir = UIOC_RD;\r\nkioc->xferlen = sizeof(mraid_hba_info_t);\r\nif (mraid_mm_attach_buf(adp, kioc, kioc->xferlen))\r\nreturn (-ENOMEM);\r\n}\r\nelse {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid cmm: Invalid subop\n"));\r\nreturn (-EINVAL);\r\n}\r\nbreak;\r\ncase 0x81:\r\nkioc->opcode = MBOX_CMD;\r\nkioc->xferlen = mimd.ui.fcs.length;\r\nkioc->user_data_len = kioc->xferlen;\r\nkioc->user_data = mimd.ui.fcs.buffer;\r\nif (mraid_mm_attach_buf(adp, kioc, kioc->xferlen))\r\nreturn (-ENOMEM);\r\nif (mimd.outlen) kioc->data_dir = UIOC_RD;\r\nif (mimd.inlen) kioc->data_dir |= UIOC_WR;\r\nbreak;\r\ncase 0x80:\r\nkioc->opcode = MBOX_CMD;\r\nkioc->xferlen = (mimd.outlen > mimd.inlen) ?\r\nmimd.outlen : mimd.inlen;\r\nkioc->user_data_len = kioc->xferlen;\r\nkioc->user_data = mimd.data;\r\nif (mraid_mm_attach_buf(adp, kioc, kioc->xferlen))\r\nreturn (-ENOMEM);\r\nif (mimd.outlen) kioc->data_dir = UIOC_RD;\r\nif (mimd.inlen) kioc->data_dir |= UIOC_WR;\r\nbreak;\r\ndefault:\r\nreturn (-EINVAL);\r\n}\r\nif (opcode == 0x82)\r\nreturn 0;\r\nmbox64 = (mbox64_t *)((unsigned long)kioc->cmdbuf);\r\nmbox = &mbox64->mbox32;\r\nmemcpy(mbox, mimd.mbox, 14);\r\nif (mbox->cmd != MBOXCMD_PASSTHRU) {\r\nmbox->xferaddr = (uint32_t)kioc->buf_paddr;\r\nif (kioc->data_dir & UIOC_WR) {\r\nif (copy_from_user(kioc->buf_vaddr, kioc->user_data,\r\nkioc->xferlen)) {\r\nreturn (-EFAULT);\r\n}\r\n}\r\nreturn 0;\r\n}\r\npthru32 = kioc->pthru32;\r\nkioc->user_pthru = &umimd->pthru;\r\nmbox->xferaddr = (uint32_t)kioc->pthru32_h;\r\nif (copy_from_user(pthru32, kioc->user_pthru,\r\nsizeof(mraid_passthru_t))) {\r\nreturn (-EFAULT);\r\n}\r\npthru32->dataxferaddr = kioc->buf_paddr;\r\nif (kioc->data_dir & UIOC_WR) {\r\nif (copy_from_user(kioc->buf_vaddr, kioc->user_data,\r\npthru32->dataxferlen)) {\r\nreturn (-EFAULT);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmraid_mm_attach_buf(mraid_mmadp_t *adp, uioc_t *kioc, int xferlen)\r\n{\r\nmm_dmapool_t *pool;\r\nint right_pool = -1;\r\nunsigned long flags;\r\nint i;\r\nkioc->pool_index = -1;\r\nkioc->buf_vaddr = NULL;\r\nkioc->buf_paddr = 0;\r\nkioc->free_buf = 0;\r\nfor (i = 0; i < MAX_DMA_POOLS; i++) {\r\npool = &adp->dma_pool_list[i];\r\nif (xferlen > pool->buf_size)\r\ncontinue;\r\nif (right_pool == -1)\r\nright_pool = i;\r\nspin_lock_irqsave(&pool->lock, flags);\r\nif (!pool->in_use) {\r\npool->in_use = 1;\r\nkioc->pool_index = i;\r\nkioc->buf_vaddr = pool->vaddr;\r\nkioc->buf_paddr = pool->paddr;\r\nspin_unlock_irqrestore(&pool->lock, flags);\r\nreturn 0;\r\n}\r\nelse {\r\nspin_unlock_irqrestore(&pool->lock, flags);\r\ncontinue;\r\n}\r\n}\r\nif (right_pool == -1)\r\nreturn -EINVAL;\r\npool = &adp->dma_pool_list[right_pool];\r\nspin_lock_irqsave(&pool->lock, flags);\r\nkioc->pool_index = right_pool;\r\nkioc->free_buf = 1;\r\nkioc->buf_vaddr = pci_pool_alloc(pool->handle, GFP_KERNEL,\r\n&kioc->buf_paddr);\r\nspin_unlock_irqrestore(&pool->lock, flags);\r\nif (!kioc->buf_vaddr)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic uioc_t *\r\nmraid_mm_alloc_kioc(mraid_mmadp_t *adp)\r\n{\r\nuioc_t *kioc;\r\nstruct list_head* head;\r\nunsigned long flags;\r\ndown(&adp->kioc_semaphore);\r\nspin_lock_irqsave(&adp->kioc_pool_lock, flags);\r\nhead = &adp->kioc_pool;\r\nif (list_empty(head)) {\r\nup(&adp->kioc_semaphore);\r\nspin_unlock_irqrestore(&adp->kioc_pool_lock, flags);\r\ncon_log(CL_ANN, ("megaraid cmm: kioc list empty!\n"));\r\nreturn NULL;\r\n}\r\nkioc = list_entry(head->next, uioc_t, list);\r\nlist_del_init(&kioc->list);\r\nspin_unlock_irqrestore(&adp->kioc_pool_lock, flags);\r\nmemset((caddr_t)(unsigned long)kioc->cmdbuf, 0, sizeof(mbox64_t));\r\nmemset((caddr_t) kioc->pthru32, 0, sizeof(mraid_passthru_t));\r\nkioc->buf_vaddr = NULL;\r\nkioc->buf_paddr = 0;\r\nkioc->pool_index =-1;\r\nkioc->free_buf = 0;\r\nkioc->user_data = NULL;\r\nkioc->user_data_len = 0;\r\nkioc->user_pthru = NULL;\r\nkioc->timedout = 0;\r\nreturn kioc;\r\n}\r\nstatic void\r\nmraid_mm_dealloc_kioc(mraid_mmadp_t *adp, uioc_t *kioc)\r\n{\r\nmm_dmapool_t *pool;\r\nunsigned long flags;\r\nif (kioc->pool_index != -1) {\r\npool = &adp->dma_pool_list[kioc->pool_index];\r\nspin_lock_irqsave(&pool->lock, flags);\r\nif (kioc->free_buf == 1)\r\npci_pool_free(pool->handle, kioc->buf_vaddr,\r\nkioc->buf_paddr);\r\nelse\r\npool->in_use = 0;\r\nspin_unlock_irqrestore(&pool->lock, flags);\r\n}\r\nspin_lock_irqsave(&adp->kioc_pool_lock, flags);\r\nlist_add(&kioc->list, &adp->kioc_pool);\r\nspin_unlock_irqrestore(&adp->kioc_pool_lock, flags);\r\nup(&adp->kioc_semaphore);\r\nreturn;\r\n}\r\nstatic int\r\nlld_ioctl(mraid_mmadp_t *adp, uioc_t *kioc)\r\n{\r\nint rval;\r\nstruct timer_list timer;\r\nstruct timer_list *tp = NULL;\r\nkioc->status = -ENODATA;\r\nrval = adp->issue_uioc(adp->drvr_data, kioc, IOCTL_ISSUE);\r\nif (rval) return rval;\r\nif (adp->timeout > 0) {\r\ntp = &timer;\r\ninit_timer(tp);\r\ntp->function = lld_timedout;\r\ntp->data = (unsigned long)kioc;\r\ntp->expires = jiffies + adp->timeout * HZ;\r\nadd_timer(tp);\r\n}\r\nwait_event(wait_q, (kioc->status != -ENODATA));\r\nif (tp) {\r\ndel_timer_sync(tp);\r\n}\r\nif (kioc->timedout) {\r\nadp->quiescent = 0;\r\n}\r\nreturn kioc->status;\r\n}\r\nstatic void\r\nioctl_done(uioc_t *kioc)\r\n{\r\nuint32_t adapno;\r\nint iterator;\r\nmraid_mmadp_t* adapter;\r\nif (kioc->status == -ENODATA) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid cmm: lld didn't change status!\n"));\r\nkioc->status = -EINVAL;\r\n}\r\nif (kioc->timedout) {\r\niterator = 0;\r\nadapter = NULL;\r\nadapno = kioc->adapno;\r\ncon_log(CL_ANN, ( KERN_WARNING "megaraid cmm: completed "\r\n"ioctl that was timedout before\n"));\r\nlist_for_each_entry(adapter, &adapters_list_g, list) {\r\nif (iterator++ == adapno) break;\r\n}\r\nkioc->timedout = 0;\r\nif (adapter) {\r\nmraid_mm_dealloc_kioc( adapter, kioc );\r\n}\r\n}\r\nelse {\r\nwake_up(&wait_q);\r\n}\r\n}\r\nstatic void\r\nlld_timedout(unsigned long ptr)\r\n{\r\nuioc_t *kioc = (uioc_t *)ptr;\r\nkioc->status = -ETIME;\r\nkioc->timedout = 1;\r\ncon_log(CL_ANN, (KERN_WARNING "megaraid cmm: ioctl timed out\n"));\r\nwake_up(&wait_q);\r\n}\r\nstatic int\r\nkioc_to_mimd(uioc_t *kioc, mimd_t __user *mimd)\r\n{\r\nmimd_t kmimd;\r\nuint8_t opcode;\r\nuint8_t subopcode;\r\nmbox64_t *mbox64;\r\nmraid_passthru_t __user *upthru32;\r\nmraid_passthru_t *kpthru32;\r\nmcontroller_t cinfo;\r\nmraid_hba_info_t *hinfo;\r\nif (copy_from_user(&kmimd, mimd, sizeof(mimd_t)))\r\nreturn (-EFAULT);\r\nopcode = kmimd.ui.fcs.opcode;\r\nsubopcode = kmimd.ui.fcs.subopcode;\r\nif (opcode == 0x82) {\r\nswitch (subopcode) {\r\ncase MEGAIOC_QADAPINFO:\r\nhinfo = (mraid_hba_info_t *)(unsigned long)\r\nkioc->buf_vaddr;\r\nhinfo_to_cinfo(hinfo, &cinfo);\r\nif (copy_to_user(kmimd.data, &cinfo, sizeof(cinfo)))\r\nreturn (-EFAULT);\r\nreturn 0;\r\ndefault:\r\nreturn (-EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nmbox64 = (mbox64_t *)(unsigned long)kioc->cmdbuf;\r\nif (kioc->user_pthru) {\r\nupthru32 = kioc->user_pthru;\r\nkpthru32 = kioc->pthru32;\r\nif (copy_to_user(&upthru32->scsistatus,\r\n&kpthru32->scsistatus,\r\nsizeof(uint8_t))) {\r\nreturn (-EFAULT);\r\n}\r\n}\r\nif (kioc->user_data) {\r\nif (copy_to_user(kioc->user_data, kioc->buf_vaddr,\r\nkioc->user_data_len)) {\r\nreturn (-EFAULT);\r\n}\r\n}\r\nif (copy_to_user(&mimd->mbox[17],\r\n&mbox64->mbox32.status, sizeof(uint8_t))) {\r\nreturn (-EFAULT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nhinfo_to_cinfo(mraid_hba_info_t *hinfo, mcontroller_t *cinfo)\r\n{\r\nif (!hinfo || !cinfo)\r\nreturn;\r\ncinfo->base = hinfo->baseport;\r\ncinfo->irq = hinfo->irq;\r\ncinfo->numldrv = hinfo->num_ldrv;\r\ncinfo->pcibus = hinfo->pci_bus;\r\ncinfo->pcidev = hinfo->pci_slot;\r\ncinfo->pcifun = PCI_FUNC(hinfo->pci_dev_fn);\r\ncinfo->pciid = hinfo->pci_device_id;\r\ncinfo->pcivendor = hinfo->pci_vendor_id;\r\ncinfo->pcislot = hinfo->pci_slot;\r\ncinfo->uid = hinfo->unique_id;\r\n}\r\nint\r\nmraid_mm_register_adp(mraid_mmadp_t *lld_adp)\r\n{\r\nmraid_mmadp_t *adapter;\r\nmbox64_t *mbox_list;\r\nuioc_t *kioc;\r\nuint32_t rval;\r\nint i;\r\nif (lld_adp->drvr_type != DRVRTYPE_MBOX)\r\nreturn (-EINVAL);\r\nadapter = kzalloc(sizeof(mraid_mmadp_t), GFP_KERNEL);\r\nif (!adapter)\r\nreturn -ENOMEM;\r\nadapter->unique_id = lld_adp->unique_id;\r\nadapter->drvr_type = lld_adp->drvr_type;\r\nadapter->drvr_data = lld_adp->drvr_data;\r\nadapter->pdev = lld_adp->pdev;\r\nadapter->issue_uioc = lld_adp->issue_uioc;\r\nadapter->timeout = lld_adp->timeout;\r\nadapter->max_kioc = lld_adp->max_kioc;\r\nadapter->quiescent = 1;\r\nadapter->kioc_list = kmalloc(sizeof(uioc_t) * lld_adp->max_kioc,\r\nGFP_KERNEL);\r\nadapter->mbox_list = kmalloc(sizeof(mbox64_t) * lld_adp->max_kioc,\r\nGFP_KERNEL);\r\nadapter->pthru_dma_pool = pci_pool_create("megaraid mm pthru pool",\r\nadapter->pdev,\r\nsizeof(mraid_passthru_t),\r\n16, 0);\r\nif (!adapter->kioc_list || !adapter->mbox_list ||\r\n!adapter->pthru_dma_pool) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid cmm: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\nrval = (-ENOMEM);\r\ngoto memalloc_error;\r\n}\r\nINIT_LIST_HEAD(&adapter->kioc_pool);\r\nspin_lock_init(&adapter->kioc_pool_lock);\r\nsema_init(&adapter->kioc_semaphore, lld_adp->max_kioc);\r\nmbox_list = (mbox64_t *)adapter->mbox_list;\r\nfor (i = 0; i < lld_adp->max_kioc; i++) {\r\nkioc = adapter->kioc_list + i;\r\nkioc->cmdbuf = (uint64_t)(unsigned long)(mbox_list + i);\r\nkioc->pthru32 = pci_pool_alloc(adapter->pthru_dma_pool,\r\nGFP_KERNEL, &kioc->pthru32_h);\r\nif (!kioc->pthru32) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid cmm: out of memory, %s %d\n",\r\n__func__, __LINE__));\r\nrval = (-ENOMEM);\r\ngoto pthru_dma_pool_error;\r\n}\r\nlist_add_tail(&kioc->list, &adapter->kioc_pool);\r\n}\r\nif ((rval = mraid_mm_setup_dma_pools(adapter)) != 0) {\r\ngoto dma_pool_error;\r\n}\r\nlist_add_tail(&adapter->list, &adapters_list_g);\r\nadapters_count_g++;\r\nreturn 0;\r\ndma_pool_error:\r\npthru_dma_pool_error:\r\nfor (i = 0; i < lld_adp->max_kioc; i++) {\r\nkioc = adapter->kioc_list + i;\r\nif (kioc->pthru32) {\r\npci_pool_free(adapter->pthru_dma_pool, kioc->pthru32,\r\nkioc->pthru32_h);\r\n}\r\n}\r\nmemalloc_error:\r\nkfree(adapter->kioc_list);\r\nkfree(adapter->mbox_list);\r\nif (adapter->pthru_dma_pool)\r\npci_pool_destroy(adapter->pthru_dma_pool);\r\nkfree(adapter);\r\nreturn rval;\r\n}\r\nuint32_t\r\nmraid_mm_adapter_app_handle(uint32_t unique_id)\r\n{\r\nmraid_mmadp_t *adapter;\r\nmraid_mmadp_t *tmp;\r\nint index = 0;\r\nlist_for_each_entry_safe(adapter, tmp, &adapters_list_g, list) {\r\nif (adapter->unique_id == unique_id) {\r\nreturn MKADAP(index);\r\n}\r\nindex++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmraid_mm_setup_dma_pools(mraid_mmadp_t *adp)\r\n{\r\nmm_dmapool_t *pool;\r\nint bufsize;\r\nint i;\r\nbufsize = MRAID_MM_INIT_BUFF_SIZE;\r\nfor (i = 0; i < MAX_DMA_POOLS; i++){\r\npool = &adp->dma_pool_list[i];\r\npool->buf_size = bufsize;\r\nspin_lock_init(&pool->lock);\r\npool->handle = pci_pool_create("megaraid mm data buffer",\r\nadp->pdev, bufsize, 16, 0);\r\nif (!pool->handle) {\r\ngoto dma_pool_setup_error;\r\n}\r\npool->vaddr = pci_pool_alloc(pool->handle, GFP_KERNEL,\r\n&pool->paddr);\r\nif (!pool->vaddr)\r\ngoto dma_pool_setup_error;\r\nbufsize = bufsize * 2;\r\n}\r\nreturn 0;\r\ndma_pool_setup_error:\r\nmraid_mm_teardown_dma_pools(adp);\r\nreturn (-ENOMEM);\r\n}\r\nint\r\nmraid_mm_unregister_adp(uint32_t unique_id)\r\n{\r\nmraid_mmadp_t *adapter;\r\nmraid_mmadp_t *tmp;\r\nlist_for_each_entry_safe(adapter, tmp, &adapters_list_g, list) {\r\nif (adapter->unique_id == unique_id) {\r\nadapters_count_g--;\r\nlist_del_init(&adapter->list);\r\nmraid_mm_free_adp_resources(adapter);\r\nkfree(adapter);\r\ncon_log(CL_ANN, (\r\n"megaraid cmm: Unregistered one adapter:%#x\n",\r\nunique_id));\r\nreturn 0;\r\n}\r\n}\r\nreturn (-ENODEV);\r\n}\r\nstatic void\r\nmraid_mm_free_adp_resources(mraid_mmadp_t *adp)\r\n{\r\nuioc_t *kioc;\r\nint i;\r\nmraid_mm_teardown_dma_pools(adp);\r\nfor (i = 0; i < adp->max_kioc; i++) {\r\nkioc = adp->kioc_list + i;\r\npci_pool_free(adp->pthru_dma_pool, kioc->pthru32,\r\nkioc->pthru32_h);\r\n}\r\nkfree(adp->kioc_list);\r\nkfree(adp->mbox_list);\r\npci_pool_destroy(adp->pthru_dma_pool);\r\nreturn;\r\n}\r\nstatic void\r\nmraid_mm_teardown_dma_pools(mraid_mmadp_t *adp)\r\n{\r\nint i;\r\nmm_dmapool_t *pool;\r\nfor (i = 0; i < MAX_DMA_POOLS; i++) {\r\npool = &adp->dma_pool_list[i];\r\nif (pool->handle) {\r\nif (pool->vaddr)\r\npci_pool_free(pool->handle, pool->vaddr,\r\npool->paddr);\r\npci_pool_destroy(pool->handle);\r\npool->handle = NULL;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int __init\r\nmraid_mm_init(void)\r\n{\r\nint err;\r\ncon_log(CL_ANN, (KERN_INFO "megaraid cmm: %s %s\n",\r\nLSI_COMMON_MOD_VERSION, LSI_COMMON_MOD_EXT_VERSION));\r\nerr = misc_register(&megaraid_mm_dev);\r\nif (err < 0) {\r\ncon_log(CL_ANN, ("megaraid cmm: cannot register misc device\n"));\r\nreturn err;\r\n}\r\ninit_waitqueue_head(&wait_q);\r\nINIT_LIST_HEAD(&adapters_list_g);\r\nreturn 0;\r\n}\r\nstatic long\r\nmraid_mm_compat_ioctl(struct file *filep, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err;\r\nerr = mraid_mm_ioctl(filep, cmd, arg);\r\nreturn err;\r\n}\r\nstatic void __exit\r\nmraid_mm_exit(void)\r\n{\r\ncon_log(CL_DLEVEL1 , ("exiting common mod\n"));\r\nmisc_deregister(&megaraid_mm_dev);\r\n}
