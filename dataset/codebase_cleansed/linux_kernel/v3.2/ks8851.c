static void ks8851_wrreg16(struct ks8851_net *ks, unsigned reg, unsigned val)\r\n{\r\nstruct spi_transfer *xfer = &ks->spi_xfer1;\r\nstruct spi_message *msg = &ks->spi_msg1;\r\n__le16 txb[2];\r\nint ret;\r\ntxb[0] = cpu_to_le16(MK_OP(reg & 2 ? 0xC : 0x03, reg) | KS_SPIOP_WR);\r\ntxb[1] = cpu_to_le16(val);\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 4;\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "spi_sync() failed\n");\r\n}\r\nstatic void ks8851_wrreg8(struct ks8851_net *ks, unsigned reg, unsigned val)\r\n{\r\nstruct spi_transfer *xfer = &ks->spi_xfer1;\r\nstruct spi_message *msg = &ks->spi_msg1;\r\n__le16 txb[2];\r\nint ret;\r\nint bit;\r\nbit = 1 << (reg & 3);\r\ntxb[0] = cpu_to_le16(MK_OP(bit, reg) | KS_SPIOP_WR);\r\ntxb[1] = val;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 3;\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "spi_sync() failed\n");\r\n}\r\nstatic inline bool ks8851_rx_1msg(struct ks8851_net *ks)\r\n{\r\nreturn true;\r\n}\r\nstatic void ks8851_rdreg(struct ks8851_net *ks, unsigned op,\r\nu8 *rxb, unsigned rxl)\r\n{\r\nstruct spi_transfer *xfer;\r\nstruct spi_message *msg;\r\n__le16 *txb = (__le16 *)ks->txd;\r\nu8 *trx = ks->rxd;\r\nint ret;\r\ntxb[0] = cpu_to_le16(op | KS_SPIOP_RD);\r\nif (ks8851_rx_1msg(ks)) {\r\nmsg = &ks->spi_msg1;\r\nxfer = &ks->spi_xfer1;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = trx;\r\nxfer->len = rxl + 2;\r\n} else {\r\nmsg = &ks->spi_msg2;\r\nxfer = ks->spi_xfer2;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 2;\r\nxfer++;\r\nxfer->tx_buf = NULL;\r\nxfer->rx_buf = trx;\r\nxfer->len = rxl;\r\n}\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "read: spi_sync() failed\n");\r\nelse if (ks8851_rx_1msg(ks))\r\nmemcpy(rxb, trx + 2, rxl);\r\nelse\r\nmemcpy(rxb, trx, rxl);\r\n}\r\nstatic unsigned ks8851_rdreg8(struct ks8851_net *ks, unsigned reg)\r\n{\r\nu8 rxb[1];\r\nks8851_rdreg(ks, MK_OP(1 << (reg & 3), reg), rxb, 1);\r\nreturn rxb[0];\r\n}\r\nstatic unsigned ks8851_rdreg16(struct ks8851_net *ks, unsigned reg)\r\n{\r\n__le16 rx = 0;\r\nks8851_rdreg(ks, MK_OP(reg & 2 ? 0xC : 0x3, reg), (u8 *)&rx, 2);\r\nreturn le16_to_cpu(rx);\r\n}\r\nstatic unsigned ks8851_rdreg32(struct ks8851_net *ks, unsigned reg)\r\n{\r\n__le32 rx = 0;\r\nWARN_ON(reg & 3);\r\nks8851_rdreg(ks, MK_OP(0xf, reg), (u8 *)&rx, 4);\r\nreturn le32_to_cpu(rx);\r\n}\r\nstatic void ks8851_soft_reset(struct ks8851_net *ks, unsigned op)\r\n{\r\nks8851_wrreg16(ks, KS_GRR, op);\r\nmdelay(1);\r\nks8851_wrreg16(ks, KS_GRR, 0);\r\nmdelay(1);\r\n}\r\nstatic int ks8851_write_mac_addr(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint i;\r\nmutex_lock(&ks->lock);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nks8851_wrreg8(ks, KS_MAR(i), dev->dev_addr[i]);\r\nmutex_unlock(&ks->lock);\r\nreturn 0;\r\n}\r\nstatic void ks8851_init_mac(struct ks8851_net *ks)\r\n{\r\nstruct net_device *dev = ks->netdev;\r\nrandom_ether_addr(dev->dev_addr);\r\nks8851_write_mac_addr(dev);\r\n}\r\nstatic irqreturn_t ks8851_irq(int irq, void *pw)\r\n{\r\nstruct ks8851_net *ks = pw;\r\ndisable_irq_nosync(irq);\r\nschedule_work(&ks->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ks8851_rdfifo(struct ks8851_net *ks, u8 *buff, unsigned len)\r\n{\r\nstruct spi_transfer *xfer = ks->spi_xfer2;\r\nstruct spi_message *msg = &ks->spi_msg2;\r\nu8 txb[1];\r\nint ret;\r\nnetif_dbg(ks, rx_status, ks->netdev,\r\n"%s: %d@%p\n", __func__, len, buff);\r\ntxb[0] = KS_SPIOP_RXFIFO;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 1;\r\nxfer++;\r\nxfer->rx_buf = buff;\r\nxfer->tx_buf = NULL;\r\nxfer->len = len;\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "%s: spi_sync() failed\n", __func__);\r\n}\r\nstatic void ks8851_dbg_dumpkkt(struct ks8851_net *ks, u8 *rxpkt)\r\n{\r\nnetdev_dbg(ks->netdev,\r\n"pkt %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x\n",\r\nrxpkt[4], rxpkt[5], rxpkt[6], rxpkt[7],\r\nrxpkt[8], rxpkt[9], rxpkt[10], rxpkt[11],\r\nrxpkt[12], rxpkt[13], rxpkt[14], rxpkt[15]);\r\n}\r\nstatic void ks8851_rx_pkts(struct ks8851_net *ks)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned rxfc;\r\nunsigned rxlen;\r\nunsigned rxstat;\r\nu32 rxh;\r\nu8 *rxpkt;\r\nrxfc = ks8851_rdreg8(ks, KS_RXFC);\r\nnetif_dbg(ks, rx_status, ks->netdev,\r\n"%s: %d packets\n", __func__, rxfc);\r\nfor (; rxfc != 0; rxfc--) {\r\nrxh = ks8851_rdreg32(ks, KS_RXFHSR);\r\nrxstat = rxh & 0xffff;\r\nrxlen = rxh >> 16;\r\nnetif_dbg(ks, rx_status, ks->netdev,\r\n"rx: stat 0x%04x, len 0x%04x\n", rxstat, rxlen);\r\nks8851_wrreg16(ks, KS_RXFDPR, RXFDPR_RXFPAI | 0x00);\r\nks8851_wrreg16(ks, KS_RXQCR,\r\nks->rc_rxqcr | RXQCR_SDA | RXQCR_ADRFE);\r\nif (rxlen > 4) {\r\nunsigned int rxalign;\r\nrxlen -= 4;\r\nrxalign = ALIGN(rxlen, 4);\r\nskb = netdev_alloc_skb_ip_align(ks->netdev, rxalign);\r\nif (skb) {\r\nrxpkt = skb_put(skb, rxlen) - 8;\r\nks8851_rdfifo(ks, rxpkt, rxalign + 8);\r\nif (netif_msg_pktdata(ks))\r\nks8851_dbg_dumpkkt(ks, rxpkt);\r\nskb->protocol = eth_type_trans(skb, ks->netdev);\r\nnetif_rx(skb);\r\nks->netdev->stats.rx_packets++;\r\nks->netdev->stats.rx_bytes += rxlen;\r\n}\r\n}\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\r\n}\r\n}\r\nstatic void ks8851_irq_work(struct work_struct *work)\r\n{\r\nstruct ks8851_net *ks = container_of(work, struct ks8851_net, irq_work);\r\nunsigned status;\r\nunsigned handled = 0;\r\nmutex_lock(&ks->lock);\r\nstatus = ks8851_rdreg16(ks, KS_ISR);\r\nnetif_dbg(ks, intr, ks->netdev,\r\n"%s: status 0x%04x\n", __func__, status);\r\nif (status & IRQ_LCI) {\r\nhandled |= IRQ_LCI;\r\n}\r\nif (status & IRQ_LDI) {\r\nu16 pmecr = ks8851_rdreg16(ks, KS_PMECR);\r\npmecr &= ~PMECR_WKEVT_MASK;\r\nks8851_wrreg16(ks, KS_PMECR, pmecr | PMECR_WKEVT_LINK);\r\nhandled |= IRQ_LDI;\r\n}\r\nif (status & IRQ_RXPSI)\r\nhandled |= IRQ_RXPSI;\r\nif (status & IRQ_TXI) {\r\nhandled |= IRQ_TXI;\r\nks->tx_space = ks8851_rdreg16(ks, KS_TXMIR);\r\nnetif_dbg(ks, intr, ks->netdev,\r\n"%s: txspace %d\n", __func__, ks->tx_space);\r\n}\r\nif (status & IRQ_RXI)\r\nhandled |= IRQ_RXI;\r\nif (status & IRQ_SPIBEI) {\r\ndev_err(&ks->spidev->dev, "%s: spi bus error\n", __func__);\r\nhandled |= IRQ_SPIBEI;\r\n}\r\nks8851_wrreg16(ks, KS_ISR, handled);\r\nif (status & IRQ_RXI) {\r\nks8851_rx_pkts(ks);\r\n}\r\nif (status & IRQ_RXPSI) {\r\nstruct ks8851_rxctrl *rxc = &ks->rxctrl;\r\nks8851_wrreg16(ks, KS_MAHTR0, rxc->mchash[0]);\r\nks8851_wrreg16(ks, KS_MAHTR1, rxc->mchash[1]);\r\nks8851_wrreg16(ks, KS_MAHTR2, rxc->mchash[2]);\r\nks8851_wrreg16(ks, KS_MAHTR3, rxc->mchash[3]);\r\nks8851_wrreg16(ks, KS_RXCR2, rxc->rxcr2);\r\nks8851_wrreg16(ks, KS_RXCR1, rxc->rxcr1);\r\n}\r\nmutex_unlock(&ks->lock);\r\nif (status & IRQ_TXI)\r\nnetif_wake_queue(ks->netdev);\r\nenable_irq(ks->netdev->irq);\r\n}\r\nstatic inline unsigned calc_txlen(unsigned len)\r\n{\r\nreturn ALIGN(len + 4, 4);\r\n}\r\nstatic void ks8851_wrpkt(struct ks8851_net *ks, struct sk_buff *txp, bool irq)\r\n{\r\nstruct spi_transfer *xfer = ks->spi_xfer2;\r\nstruct spi_message *msg = &ks->spi_msg2;\r\nunsigned fid = 0;\r\nint ret;\r\nnetif_dbg(ks, tx_queued, ks->netdev, "%s: skb %p, %d@%p, irq %d\n",\r\n__func__, txp, txp->len, txp->data, irq);\r\nfid = ks->fid++;\r\nfid &= TXFR_TXFID_MASK;\r\nif (irq)\r\nfid |= TXFR_TXIC;\r\nks->txh.txb[1] = KS_SPIOP_TXFIFO;\r\nks->txh.txw[1] = cpu_to_le16(fid);\r\nks->txh.txw[2] = cpu_to_le16(txp->len);\r\nxfer->tx_buf = &ks->txh.txb[1];\r\nxfer->rx_buf = NULL;\r\nxfer->len = 5;\r\nxfer++;\r\nxfer->tx_buf = txp->data;\r\nxfer->rx_buf = NULL;\r\nxfer->len = ALIGN(txp->len, 4);\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "%s: spi_sync() failed\n", __func__);\r\n}\r\nstatic void ks8851_done_tx(struct ks8851_net *ks, struct sk_buff *txb)\r\n{\r\nstruct net_device *dev = ks->netdev;\r\ndev->stats.tx_bytes += txb->len;\r\ndev->stats.tx_packets++;\r\ndev_kfree_skb(txb);\r\n}\r\nstatic void ks8851_tx_work(struct work_struct *work)\r\n{\r\nstruct ks8851_net *ks = container_of(work, struct ks8851_net, tx_work);\r\nstruct sk_buff *txb;\r\nbool last = skb_queue_empty(&ks->txq);\r\nmutex_lock(&ks->lock);\r\nwhile (!last) {\r\ntxb = skb_dequeue(&ks->txq);\r\nlast = skb_queue_empty(&ks->txq);\r\nif (txb != NULL) {\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr | RXQCR_SDA);\r\nks8851_wrpkt(ks, txb, last);\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\r\nks8851_wrreg16(ks, KS_TXQCR, TXQCR_METFE);\r\nks8851_done_tx(ks, txb);\r\n}\r\n}\r\nmutex_unlock(&ks->lock);\r\n}\r\nstatic void ks8851_set_powermode(struct ks8851_net *ks, unsigned pwrmode)\r\n{\r\nunsigned pmecr;\r\nnetif_dbg(ks, hw, ks->netdev, "setting power mode %d\n", pwrmode);\r\npmecr = ks8851_rdreg16(ks, KS_PMECR);\r\npmecr &= ~PMECR_PM_MASK;\r\npmecr |= pwrmode;\r\nks8851_wrreg16(ks, KS_PMECR, pmecr);\r\n}\r\nstatic int ks8851_net_open(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nmutex_lock(&ks->lock);\r\nnetif_dbg(ks, ifup, ks->netdev, "opening\n");\r\nks8851_set_powermode(ks, PMECR_PM_NORMAL);\r\nks8851_soft_reset(ks, GRR_QMU);\r\nks8851_wrreg16(ks, KS_TXCR, (TXCR_TXE |\r\nTXCR_TXPE |\r\nTXCR_TXCRC |\r\nTXCR_TXFCE));\r\nks8851_wrreg16(ks, KS_TXFDPR, TXFDPR_TXFPAI);\r\nks8851_wrreg16(ks, KS_RXCR1, (RXCR1_RXPAFMA |\r\nRXCR1_RXFCE |\r\nRXCR1_RXBE |\r\nRXCR1_RXUE |\r\nRXCR1_RXE));\r\nks8851_wrreg16(ks, KS_RXCR2, RXCR2_SRDBL_FRAME);\r\nks8851_wrreg16(ks, KS_RXDTTR, 1000);\r\nks8851_wrreg16(ks, KS_RXDBCTR, 4096);\r\nks8851_wrreg16(ks, KS_RXFCTR, 10);\r\nks->rc_rxqcr = (RXQCR_RXFCTE |\r\nRXQCR_RXDBCTE |\r\nRXQCR_RXDTTE);\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\r\n#define STD_IRQ (IRQ_LCI | \\r\nIRQ_TXI | \\r\nIRQ_RXI | \\r\nIRQ_SPIBEI | \\r\nIRQ_TXPSI | \\r\nIRQ_RXPSI)\r\nks->rc_ier = STD_IRQ;\r\nks8851_wrreg16(ks, KS_ISR, STD_IRQ);\r\nks8851_wrreg16(ks, KS_IER, STD_IRQ);\r\nnetif_start_queue(ks->netdev);\r\nnetif_dbg(ks, ifup, ks->netdev, "network device up\n");\r\nmutex_unlock(&ks->lock);\r\nreturn 0;\r\n}\r\nstatic int ks8851_net_stop(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nnetif_info(ks, ifdown, dev, "shutting down\n");\r\nnetif_stop_queue(dev);\r\nmutex_lock(&ks->lock);\r\nflush_work(&ks->irq_work);\r\nflush_work(&ks->tx_work);\r\nflush_work(&ks->rxctrl_work);\r\nks8851_wrreg16(ks, KS_IER, 0x0000);\r\nks8851_wrreg16(ks, KS_ISR, 0xffff);\r\nks8851_wrreg16(ks, KS_RXCR1, 0x0000);\r\nks8851_wrreg16(ks, KS_TXCR, 0x0000);\r\nks8851_set_powermode(ks, PMECR_PM_SOFTDOWN);\r\nwhile (!skb_queue_empty(&ks->txq)) {\r\nstruct sk_buff *txb = skb_dequeue(&ks->txq);\r\nnetif_dbg(ks, ifdown, ks->netdev,\r\n"%s: freeing txb %p\n", __func__, txb);\r\ndev_kfree_skb(txb);\r\n}\r\nmutex_unlock(&ks->lock);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ks8851_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nunsigned needed = calc_txlen(skb->len);\r\nnetdev_tx_t ret = NETDEV_TX_OK;\r\nnetif_dbg(ks, tx_queued, ks->netdev,\r\n"%s: skb %p, %d@%p\n", __func__, skb, skb->len, skb->data);\r\nspin_lock(&ks->statelock);\r\nif (needed > ks->tx_space) {\r\nnetif_stop_queue(dev);\r\nret = NETDEV_TX_BUSY;\r\n} else {\r\nks->tx_space -= needed;\r\nskb_queue_tail(&ks->txq, skb);\r\n}\r\nspin_unlock(&ks->statelock);\r\nschedule_work(&ks->tx_work);\r\nreturn ret;\r\n}\r\nstatic void ks8851_rxctrl_work(struct work_struct *work)\r\n{\r\nstruct ks8851_net *ks = container_of(work, struct ks8851_net, rxctrl_work);\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_RXCR1, 0x00);\r\nmutex_unlock(&ks->lock);\r\n}\r\nstatic void ks8851_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nstruct ks8851_rxctrl rxctrl;\r\nmemset(&rxctrl, 0, sizeof(rxctrl));\r\nif (dev->flags & IFF_PROMISC) {\r\nrxctrl.rxcr1 = RXCR1_RXAE | RXCR1_RXINVF;\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\nrxctrl.rxcr1 = (RXCR1_RXME | RXCR1_RXAE |\r\nRXCR1_RXPAFMA | RXCR1_RXMAFMA);\r\n} else if (dev->flags & IFF_MULTICAST && !netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc(ETH_ALEN, ha->addr);\r\ncrc >>= (32 - 6);\r\nrxctrl.mchash[crc >> 4] |= (1 << (crc & 0xf));\r\n}\r\nrxctrl.rxcr1 = RXCR1_RXME | RXCR1_RXPAFMA;\r\n} else {\r\nrxctrl.rxcr1 = RXCR1_RXPAFMA;\r\n}\r\nrxctrl.rxcr1 |= (RXCR1_RXUE |\r\nRXCR1_RXBE |\r\nRXCR1_RXE |\r\nRXCR1_RXFCE);\r\nrxctrl.rxcr2 |= RXCR2_SRDBL_FRAME;\r\nspin_lock(&ks->statelock);\r\nif (memcmp(&rxctrl, &ks->rxctrl, sizeof(rxctrl)) != 0) {\r\nmemcpy(&ks->rxctrl, &rxctrl, sizeof(ks->rxctrl));\r\nschedule_work(&ks->rxctrl_work);\r\n}\r\nspin_unlock(&ks->statelock);\r\n}\r\nstatic int ks8851_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = addr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(sa->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, sa->sa_data, ETH_ALEN);\r\nreturn ks8851_write_mac_addr(dev);\r\n}\r\nstatic int ks8851_net_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn generic_mii_ioctl(&ks->mii, if_mii(req), cmd, NULL);\r\n}\r\nunsigned int ks8851_eeprom_read(struct net_device *dev, unsigned int addr)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint eepcr;\r\nint ctrl = EEPROM_OP_READ;\r\nint state = EEPROM_CONTROL;\r\nint bit_count = EEPROM_OP_LEN - 1;\r\nunsigned int data = 0;\r\nint dummy;\r\nunsigned int addr_len;\r\naddr_len = (ks->eeprom_size == 128) ? 6 : 8;\r\nmutex_lock(&ks->lock);\r\neepcr = EEPCR_EESA | EEPCR_EESRWA;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\neepcr |= EEPCR_EECS;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\nwhile (state != EEPROM_COMPLETE) {\r\neepcr &= ~EEPCR_EEDO;\r\nswitch (state) {\r\ncase EEPROM_CONTROL:\r\neepcr |= ((ctrl >> bit_count) & 1) << 2;\r\nif (bit_count-- <= 0) {\r\nbit_count = addr_len - 1;\r\nstate = EEPROM_ADDRESS;\r\n}\r\nbreak;\r\ncase EEPROM_ADDRESS:\r\neepcr |= ((addr >> bit_count) & 1) << 2;\r\nbit_count--;\r\nbreak;\r\ncase EEPROM_DATA:\r\neepcr &= ~EEPCR_EESRWA;\r\nbreak;\r\n}\r\neepcr &= ~EEPCR_EESCK;\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\nudelay(EEPROM_SK_PERIOD / 2);\r\nmutex_lock(&ks->lock);\r\neepcr |= EEPCR_EESCK;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\nswitch (state) {\r\ncase EEPROM_ADDRESS:\r\nif (bit_count < 0) {\r\nbit_count = EEPROM_DATA_LEN - 1;\r\nstate = EEPROM_DATA;\r\n}\r\nbreak;\r\ncase EEPROM_DATA:\r\nmutex_lock(&ks->lock);\r\ndummy = ks8851_rdreg16(ks, KS_EEPCR);\r\nmutex_unlock(&ks->lock);\r\ndata |= ((dummy >> EEPCR_EESB_OFFSET) & 1) << bit_count;\r\nif (bit_count-- <= 0)\r\nstate = EEPROM_COMPLETE;\r\nbreak;\r\n}\r\nudelay(EEPROM_SK_PERIOD / 2);\r\n}\r\nmutex_lock(&ks->lock);\r\neepcr &= ~EEPCR_EECS;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\neepcr = 0;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\nreturn data;\r\n}\r\nvoid ks8851_eeprom_write(struct net_device *dev, unsigned int op,\r\nunsigned int addr, unsigned int data)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint eepcr;\r\nint state = EEPROM_CONTROL;\r\nint bit_count = EEPROM_OP_LEN - 1;\r\nunsigned int addr_len;\r\naddr_len = (ks->eeprom_size == 128) ? 6 : 8;\r\nswitch (op) {\r\ncase EEPROM_OP_EWEN:\r\naddr = 0x30;\r\nbreak;\r\ncase EEPROM_OP_EWDS:\r\naddr = 0;\r\nbreak;\r\n}\r\nmutex_lock(&ks->lock);\r\neepcr = EEPCR_EESA | EEPCR_EESRWA;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\neepcr |= EEPCR_EECS;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\nwhile (state != EEPROM_COMPLETE) {\r\neepcr &= ~EEPCR_EEDO;\r\nswitch (state) {\r\ncase EEPROM_CONTROL:\r\neepcr |= ((op >> bit_count) & 1) << 2;\r\nif (bit_count-- <= 0) {\r\nbit_count = addr_len - 1;\r\nstate = EEPROM_ADDRESS;\r\n}\r\nbreak;\r\ncase EEPROM_ADDRESS:\r\neepcr |= ((addr >> bit_count) & 1) << 2;\r\nif (bit_count-- <= 0) {\r\nif (op == EEPROM_OP_WRITE) {\r\nbit_count = EEPROM_DATA_LEN - 1;\r\nstate = EEPROM_DATA;\r\n} else {\r\nstate = EEPROM_COMPLETE;\r\n}\r\n}\r\nbreak;\r\ncase EEPROM_DATA:\r\neepcr |= ((data >> bit_count) & 1) << 2;\r\nif (bit_count-- <= 0)\r\nstate = EEPROM_COMPLETE;\r\nbreak;\r\n}\r\neepcr &= ~EEPCR_EESCK;\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\nudelay(EEPROM_SK_PERIOD / 2);\r\neepcr |= EEPCR_EESCK;\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\nudelay(EEPROM_SK_PERIOD / 2);\r\n}\r\nmutex_lock(&ks->lock);\r\neepcr &= ~EEPCR_EECS;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\neepcr = 0;\r\nks8851_wrreg16(ks, KS_EEPCR, eepcr);\r\nmutex_unlock(&ks->lock);\r\n}\r\nstatic void ks8851_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *di)\r\n{\r\nstrlcpy(di->driver, "KS8851", sizeof(di->driver));\r\nstrlcpy(di->version, "1.00", sizeof(di->version));\r\nstrlcpy(di->bus_info, dev_name(dev->dev.parent), sizeof(di->bus_info));\r\n}\r\nstatic u32 ks8851_get_msglevel(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn ks->msg_enable;\r\n}\r\nstatic void ks8851_set_msglevel(struct net_device *dev, u32 to)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nks->msg_enable = to;\r\n}\r\nstatic int ks8851_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_ethtool_gset(&ks->mii, cmd);\r\n}\r\nstatic int ks8851_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_ethtool_sset(&ks->mii, cmd);\r\n}\r\nstatic u32 ks8851_get_link(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_link_ok(&ks->mii);\r\n}\r\nstatic int ks8851_nway_reset(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_nway_restart(&ks->mii);\r\n}\r\nstatic int ks8851_get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn ks->eeprom_size;\r\n}\r\nstatic int ks8851_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nu16 *eeprom_buff;\r\nint first_word;\r\nint last_word;\r\nint ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\nif (eeprom->len > ks->eeprom_size)\r\nreturn -EINVAL;\r\neeprom->magic = ks8851_rdreg16(ks, KS_CIDER);\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(sizeof(u16) *\r\n(last_word - first_word + 1), GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\neeprom_buff[i] = ks8851_eeprom_read(dev, first_word + 1);\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\nle16_to_cpus(&eeprom_buff[i]);\r\nmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic int ks8851_set_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nu16 *eeprom_buff;\r\nvoid *ptr;\r\nint max_len;\r\nint first_word;\r\nint last_word;\r\nint ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EOPNOTSUPP;\r\nif (eeprom->len > ks->eeprom_size)\r\nreturn -EINVAL;\r\nif (eeprom->magic != ks8851_rdreg16(ks, KS_CIDER))\r\nreturn -EFAULT;\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\nmax_len = (last_word - first_word + 1) * 2;\r\neeprom_buff = kmalloc(max_len, GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nptr = (void *)eeprom_buff;\r\nif (eeprom->offset & 1) {\r\neeprom_buff[0] = ks8851_eeprom_read(dev, first_word);\r\nptr++;\r\n}\r\nif ((eeprom->offset + eeprom->len) & 1)\r\neeprom_buff[last_word - first_word] =\r\nks8851_eeprom_read(dev, last_word);\r\nle16_to_cpus(&eeprom_buff[0]);\r\nle16_to_cpus(&eeprom_buff[last_word - first_word]);\r\nmemcpy(ptr, bytes, eeprom->len);\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\neeprom_buff[i] = cpu_to_le16(eeprom_buff[i]);\r\nks8851_eeprom_write(dev, EEPROM_OP_EWEN, 0, 0);\r\nfor (i = 0; i < last_word - first_word + 1; i++) {\r\nks8851_eeprom_write(dev, EEPROM_OP_WRITE, first_word + i,\r\neeprom_buff[i]);\r\nmdelay(EEPROM_WRITE_TIME);\r\n}\r\nks8851_eeprom_write(dev, EEPROM_OP_EWDS, 0, 0);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic int ks8851_phy_reg(int reg)\r\n{\r\nswitch (reg) {\r\ncase MII_BMCR:\r\nreturn KS_P1MBCR;\r\ncase MII_BMSR:\r\nreturn KS_P1MBSR;\r\ncase MII_PHYSID1:\r\nreturn KS_PHY1ILR;\r\ncase MII_PHYSID2:\r\nreturn KS_PHY1IHR;\r\ncase MII_ADVERTISE:\r\nreturn KS_P1ANAR;\r\ncase MII_LPA:\r\nreturn KS_P1ANLPR;\r\n}\r\nreturn 0x0;\r\n}\r\nstatic int ks8851_phy_read(struct net_device *dev, int phy_addr, int reg)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint ksreg;\r\nint result;\r\nksreg = ks8851_phy_reg(reg);\r\nif (!ksreg)\r\nreturn 0x0;\r\nmutex_lock(&ks->lock);\r\nresult = ks8851_rdreg16(ks, ksreg);\r\nmutex_unlock(&ks->lock);\r\nreturn result;\r\n}\r\nstatic void ks8851_phy_write(struct net_device *dev,\r\nint phy, int reg, int value)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint ksreg;\r\nksreg = ks8851_phy_reg(reg);\r\nif (ksreg) {\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, ksreg, value);\r\nmutex_unlock(&ks->lock);\r\n}\r\n}\r\nstatic int ks8851_read_selftest(struct ks8851_net *ks)\r\n{\r\nunsigned both_done = MBIR_TXMBF | MBIR_RXMBF;\r\nint ret = 0;\r\nunsigned rd;\r\nrd = ks8851_rdreg16(ks, KS_MBIR);\r\nif ((rd & both_done) != both_done) {\r\nnetdev_warn(ks->netdev, "Memory selftest not finished\n");\r\nreturn 0;\r\n}\r\nif (rd & MBIR_TXMBFA) {\r\nnetdev_err(ks->netdev, "TX memory selftest fail\n");\r\nret |= 1;\r\n}\r\nif (rd & MBIR_RXMBFA) {\r\nnetdev_err(ks->netdev, "RX memory selftest fail\n");\r\nret |= 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks8851_suspend(struct spi_device *spi, pm_message_t state)\r\n{\r\nstruct ks8851_net *ks = dev_get_drvdata(&spi->dev);\r\nstruct net_device *dev = ks->netdev;\r\nif (netif_running(dev)) {\r\nnetif_device_detach(dev);\r\nks8851_net_stop(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks8851_resume(struct spi_device *spi)\r\n{\r\nstruct ks8851_net *ks = dev_get_drvdata(&spi->dev);\r\nstruct net_device *dev = ks->netdev;\r\nif (netif_running(dev)) {\r\nks8851_net_open(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit ks8851_probe(struct spi_device *spi)\r\n{\r\nstruct net_device *ndev;\r\nstruct ks8851_net *ks;\r\nint ret;\r\nndev = alloc_etherdev(sizeof(struct ks8851_net));\r\nif (!ndev) {\r\ndev_err(&spi->dev, "failed to alloc ethernet device\n");\r\nreturn -ENOMEM;\r\n}\r\nspi->bits_per_word = 8;\r\nks = netdev_priv(ndev);\r\nks->netdev = ndev;\r\nks->spidev = spi;\r\nks->tx_space = 6144;\r\nmutex_init(&ks->lock);\r\nspin_lock_init(&ks->statelock);\r\nINIT_WORK(&ks->tx_work, ks8851_tx_work);\r\nINIT_WORK(&ks->irq_work, ks8851_irq_work);\r\nINIT_WORK(&ks->rxctrl_work, ks8851_rxctrl_work);\r\nspi_message_init(&ks->spi_msg1);\r\nspi_message_add_tail(&ks->spi_xfer1, &ks->spi_msg1);\r\nspi_message_init(&ks->spi_msg2);\r\nspi_message_add_tail(&ks->spi_xfer2[0], &ks->spi_msg2);\r\nspi_message_add_tail(&ks->spi_xfer2[1], &ks->spi_msg2);\r\nks->mii.dev = ndev;\r\nks->mii.phy_id = 1,\r\nks->mii.phy_id_mask = 1;\r\nks->mii.reg_num_mask = 0xf;\r\nks->mii.mdio_read = ks8851_phy_read;\r\nks->mii.mdio_write = ks8851_phy_write;\r\ndev_info(&spi->dev, "message enable is %d\n", msg_enable);\r\nks->msg_enable = netif_msg_init(msg_enable, (NETIF_MSG_DRV |\r\nNETIF_MSG_PROBE |\r\nNETIF_MSG_LINK));\r\nskb_queue_head_init(&ks->txq);\r\nSET_ETHTOOL_OPS(ndev, &ks8851_ethtool_ops);\r\nSET_NETDEV_DEV(ndev, &spi->dev);\r\ndev_set_drvdata(&spi->dev, ks);\r\nndev->if_port = IF_PORT_100BASET;\r\nndev->netdev_ops = &ks8851_netdev_ops;\r\nndev->irq = spi->irq;\r\nks8851_soft_reset(ks, GRR_GSR);\r\nif ((ks8851_rdreg16(ks, KS_CIDER) & ~CIDER_REV_MASK) != CIDER_ID) {\r\ndev_err(&spi->dev, "failed to read device ID\n");\r\nret = -ENODEV;\r\ngoto err_id;\r\n}\r\nks->rc_ccr = ks8851_rdreg16(ks, KS_CCR);\r\nif (ks->rc_ccr & CCR_EEPROM)\r\nks->eeprom_size = 128;\r\nelse\r\nks->eeprom_size = 0;\r\nks8851_read_selftest(ks);\r\nks8851_init_mac(ks);\r\nret = request_irq(spi->irq, ks8851_irq, IRQF_TRIGGER_LOW,\r\nndev->name, ks);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "failed to get irq\n");\r\ngoto err_irq;\r\n}\r\nret = register_netdev(ndev);\r\nif (ret) {\r\ndev_err(&spi->dev, "failed to register network device\n");\r\ngoto err_netdev;\r\n}\r\nnetdev_info(ndev, "revision %d, MAC %pM, IRQ %d\n",\r\nCIDER_REV_GET(ks8851_rdreg16(ks, KS_CIDER)),\r\nndev->dev_addr, ndev->irq);\r\nreturn 0;\r\nerr_netdev:\r\nfree_irq(ndev->irq, ndev);\r\nerr_id:\r\nerr_irq:\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int __devexit ks8851_remove(struct spi_device *spi)\r\n{\r\nstruct ks8851_net *priv = dev_get_drvdata(&spi->dev);\r\nif (netif_msg_drv(priv))\r\ndev_info(&spi->dev, "remove\n");\r\nunregister_netdev(priv->netdev);\r\nfree_irq(spi->irq, priv);\r\nfree_netdev(priv->netdev);\r\nreturn 0;\r\n}\r\nstatic int __init ks8851_init(void)\r\n{\r\nreturn spi_register_driver(&ks8851_driver);\r\n}\r\nstatic void __exit ks8851_exit(void)\r\n{\r\nspi_unregister_driver(&ks8851_driver);\r\n}
