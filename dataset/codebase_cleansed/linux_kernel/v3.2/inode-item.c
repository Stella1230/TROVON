static int find_name_in_backref(struct btrfs_path *path, const char *name,\r\nint name_len, struct btrfs_inode_ref **ref_ret)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_inode_ref *ref;\r\nunsigned long ptr;\r\nunsigned long name_ptr;\r\nu32 item_size;\r\nu32 cur_offset = 0;\r\nint len;\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nwhile (cur_offset < item_size) {\r\nref = (struct btrfs_inode_ref *)(ptr + cur_offset);\r\nlen = btrfs_inode_ref_name_len(leaf, ref);\r\nname_ptr = (unsigned long)(ref + 1);\r\ncur_offset += len + sizeof(*ref);\r\nif (len != name_len)\r\ncontinue;\r\nif (memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0) {\r\n*ref_ret = ref;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct btrfs_inode_ref *\r\nbtrfs_lookup_inode_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, int mod)\r\n{\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_ref *ref;\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nint ret;\r\nkey.objectid = inode_objectid;\r\nkey.type = BTRFS_INODE_REF_KEY;\r\nkey.offset = ref_objectid;\r\nret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0)\r\nreturn NULL;\r\nif (!find_name_in_backref(path, name, name_len, &ref))\r\nreturn NULL;\r\nreturn ref;\r\n}\r\nint btrfs_del_inode_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, u64 *index)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_ref *ref;\r\nstruct extent_buffer *leaf;\r\nunsigned long ptr;\r\nunsigned long item_start;\r\nu32 item_size;\r\nu32 sub_item_len;\r\nint ret;\r\nint del_len = name_len + sizeof(*ref);\r\nkey.objectid = inode_objectid;\r\nkey.offset = ref_objectid;\r\nbtrfs_set_key_type(&key, BTRFS_INODE_REF_KEY);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nret = btrfs_search_slot(trans, root, &key, path, -1, 1);\r\nif (ret > 0) {\r\nret = -ENOENT;\r\ngoto out;\r\n} else if (ret < 0) {\r\ngoto out;\r\n}\r\nif (!find_name_in_backref(path, name, name_len, &ref)) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nif (index)\r\n*index = btrfs_inode_ref_index(leaf, ref);\r\nif (del_len == item_size) {\r\nret = btrfs_del_item(trans, root, path);\r\ngoto out;\r\n}\r\nptr = (unsigned long)ref;\r\nsub_item_len = name_len + sizeof(*ref);\r\nitem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\r\nitem_size - (ptr + sub_item_len - item_start));\r\nret = btrfs_truncate_item(trans, root, path,\r\nitem_size - sub_item_len, 1);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_insert_inode_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, u64 index)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_ref *ref;\r\nunsigned long ptr;\r\nint ret;\r\nint ins_len = name_len + sizeof(*ref);\r\nkey.objectid = inode_objectid;\r\nkey.offset = ref_objectid;\r\nbtrfs_set_key_type(&key, BTRFS_INODE_REF_KEY);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nret = btrfs_insert_empty_item(trans, root, path, &key,\r\nins_len);\r\nif (ret == -EEXIST) {\r\nu32 old_size;\r\nif (find_name_in_backref(path, name, name_len, &ref))\r\ngoto out;\r\nold_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\r\nret = btrfs_extend_item(trans, root, path, ins_len);\r\nref = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_inode_ref);\r\nref = (struct btrfs_inode_ref *)((unsigned long)ref + old_size);\r\nbtrfs_set_inode_ref_name_len(path->nodes[0], ref, name_len);\r\nbtrfs_set_inode_ref_index(path->nodes[0], ref, index);\r\nptr = (unsigned long)(ref + 1);\r\nret = 0;\r\n} else if (ret < 0) {\r\nif (ret == -EOVERFLOW)\r\nret = -EMLINK;\r\ngoto out;\r\n} else {\r\nref = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_inode_ref);\r\nbtrfs_set_inode_ref_name_len(path->nodes[0], ref, name_len);\r\nbtrfs_set_inode_ref_index(path->nodes[0], ref, index);\r\nptr = (unsigned long)(ref + 1);\r\n}\r\nwrite_extent_buffer(path->nodes[0], name, ptr, name_len);\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_insert_empty_inode(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 objectid)\r\n{\r\nstruct btrfs_key key;\r\nint ret;\r\nkey.objectid = objectid;\r\nbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\r\nkey.offset = 0;\r\nret = btrfs_insert_empty_item(trans, root, path, &key,\r\nsizeof(struct btrfs_inode_item));\r\nreturn ret;\r\n}\r\nint btrfs_lookup_inode(struct btrfs_trans_handle *trans, struct btrfs_root\r\n*root, struct btrfs_path *path,\r\nstruct btrfs_key *location, int mod)\r\n{\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nint ret;\r\nint slot;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key found_key;\r\nret = btrfs_search_slot(trans, root, location, path, ins_len, cow);\r\nif (ret > 0 && btrfs_key_type(location) == BTRFS_ROOT_ITEM_KEY &&\r\nlocation->offset == (u64)-1 && path->slots[0] != 0) {\r\nslot = path->slots[0] - 1;\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &found_key, slot);\r\nif (found_key.objectid == location->objectid &&\r\nbtrfs_key_type(&found_key) == btrfs_key_type(location)) {\r\npath->slots[0]--;\r\nreturn 0;\r\n}\r\n}\r\nreturn ret;\r\n}
