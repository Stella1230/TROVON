int go7007_read_interrupt(struct go7007 *go, u16 *value, u16 *data)\r\n{\r\ngo->interrupt_available = 0;\r\ngo->hpi_ops->read_interrupt(go);\r\nif (wait_event_timeout(go->interrupt_waitq,\r\ngo->interrupt_available, 5*HZ) < 0) {\r\nv4l2_err(&go->v4l2_dev, "timeout waiting for read interrupt\n");\r\nreturn -1;\r\n}\r\nif (!go->interrupt_available)\r\nreturn -1;\r\ngo->interrupt_available = 0;\r\n*value = go->interrupt_value & 0xfffe;\r\n*data = go->interrupt_data;\r\nreturn 0;\r\n}\r\nint go7007_read_addr(struct go7007 *go, u16 addr, u16 *data)\r\n{\r\nint count = 100;\r\nu16 value;\r\nif (go7007_write_interrupt(go, 0x0010, addr) < 0)\r\nreturn -EIO;\r\nwhile (count-- > 0) {\r\nif (go7007_read_interrupt(go, &value, data) == 0 &&\r\nvalue == 0xa000)\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int go7007_load_encoder(struct go7007 *go)\r\n{\r\nconst struct firmware *fw_entry;\r\nchar fw_name[] = "go7007fw.bin";\r\nvoid *bounce;\r\nint fw_len, rv = 0;\r\nu16 intr_val, intr_data;\r\nif (request_firmware(&fw_entry, fw_name, go->dev)) {\r\nv4l2_err(go, "unable to load firmware from file "\r\n"\"%s\"\n", fw_name);\r\nreturn -1;\r\n}\r\nif (fw_entry->size < 16 || memcmp(fw_entry->data, "WISGO7007FW", 11)) {\r\nv4l2_err(go, "file \"%s\" does not appear to be "\r\n"go7007 firmware\n", fw_name);\r\nrelease_firmware(fw_entry);\r\nreturn -1;\r\n}\r\nfw_len = fw_entry->size - 16;\r\nbounce = kmalloc(fw_len, GFP_KERNEL);\r\nif (bounce == NULL) {\r\nv4l2_err(go, "unable to allocate %d bytes for "\r\n"firmware transfer\n", fw_len);\r\nrelease_firmware(fw_entry);\r\nreturn -1;\r\n}\r\nmemcpy(bounce, fw_entry->data + 16, fw_len);\r\nrelease_firmware(fw_entry);\r\nif (go7007_interface_reset(go) < 0 ||\r\ngo7007_send_firmware(go, bounce, fw_len) < 0 ||\r\ngo7007_read_interrupt(go, &intr_val, &intr_data) < 0 ||\r\n(intr_val & ~0x1) != 0x5a5a) {\r\nv4l2_err(go, "error transferring firmware\n");\r\nrv = -1;\r\n}\r\nkfree(bounce);\r\nreturn rv;\r\n}\r\nint go7007_boot_encoder(struct go7007 *go, int init_i2c)\r\n{\r\nint ret;\r\nmutex_lock(&go->hw_lock);\r\nret = go7007_load_encoder(go);\r\nmutex_unlock(&go->hw_lock);\r\nif (ret < 0)\r\nreturn -1;\r\nif (!init_i2c)\r\nreturn 0;\r\nif (go7007_i2c_init(go) < 0)\r\nreturn -1;\r\ngo->i2c_adapter_online = 1;\r\nreturn 0;\r\n}\r\nstatic int go7007_init_encoder(struct go7007 *go)\r\n{\r\nif (go->board_info->audio_flags & GO7007_AUDIO_I2S_MASTER) {\r\ngo7007_write_addr(go, 0x1000, 0x0811);\r\ngo7007_write_addr(go, 0x1000, 0x0c11);\r\n}\r\nif (go->board_id == GO7007_BOARDID_MATRIX_REV) {\r\ngo7007_write_addr(go, 0x3c82, 0x0001);\r\ngo7007_write_addr(go, 0x3c80, 0x00fe);\r\n}\r\nreturn 0;\r\n}\r\nint go7007_reset_encoder(struct go7007 *go)\r\n{\r\nif (go7007_load_encoder(go) < 0)\r\nreturn -1;\r\nreturn go7007_init_encoder(go);\r\n}\r\nstatic int init_i2c_module(struct i2c_adapter *adapter, const char *type,\r\nint addr)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(adapter);\r\nstruct v4l2_device *v4l2_dev = &go->v4l2_dev;\r\nif (v4l2_i2c_new_subdev(v4l2_dev, adapter, type, addr, NULL))\r\nreturn 0;\r\nprintk(KERN_INFO "go7007: probing for module i2c:%s failed\n", type);\r\nreturn -1;\r\n}\r\nint go7007_register_encoder(struct go7007 *go)\r\n{\r\nint i, ret;\r\nprintk(KERN_INFO "go7007: registering new %s\n", go->name);\r\nmutex_lock(&go->hw_lock);\r\nret = go7007_init_encoder(go);\r\nmutex_unlock(&go->hw_lock);\r\nif (ret < 0)\r\nreturn -1;\r\nret = go7007_v4l2_init(go);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!go->i2c_adapter_online &&\r\ngo->board_info->flags & GO7007_BOARD_USE_ONBOARD_I2C) {\r\nif (go7007_i2c_init(go) < 0)\r\nreturn -1;\r\ngo->i2c_adapter_online = 1;\r\n}\r\nif (go->i2c_adapter_online) {\r\nfor (i = 0; i < go->board_info->num_i2c_devs; ++i)\r\ninit_i2c_module(&go->i2c_adapter,\r\ngo->board_info->i2c_devs[i].type,\r\ngo->board_info->i2c_devs[i].addr);\r\nif (go->board_id == GO7007_BOARDID_ADLINK_MPG24)\r\ni2c_clients_command(&go->i2c_adapter,\r\nDECODER_SET_CHANNEL, &go->channel_number);\r\n}\r\nif (go->board_info->flags & GO7007_BOARD_HAS_AUDIO) {\r\ngo->audio_enabled = 1;\r\ngo7007_snd_init(go);\r\n}\r\nreturn 0;\r\n}\r\nint go7007_start_encoder(struct go7007 *go)\r\n{\r\nu8 *fw;\r\nint fw_len, rv = 0, i;\r\nu16 intr_val, intr_data;\r\ngo->modet_enable = 0;\r\nif (!go->dvd_mode)\r\nfor (i = 0; i < 4; ++i) {\r\nif (go->modet[i].enable) {\r\ngo->modet_enable = 1;\r\ncontinue;\r\n}\r\ngo->modet[i].pixel_threshold = 32767;\r\ngo->modet[i].motion_threshold = 32767;\r\ngo->modet[i].mb_threshold = 32767;\r\n}\r\nif (go7007_construct_fw_image(go, &fw, &fw_len) < 0)\r\nreturn -1;\r\nif (go7007_send_firmware(go, fw, fw_len) < 0 ||\r\ngo7007_read_interrupt(go, &intr_val, &intr_data) < 0) {\r\nv4l2_err(&go->v4l2_dev, "error transferring firmware\n");\r\nrv = -1;\r\ngoto start_error;\r\n}\r\ngo->state = STATE_DATA;\r\ngo->parse_length = 0;\r\ngo->seen_frame = 0;\r\nif (go7007_stream_start(go) < 0) {\r\nv4l2_err(&go->v4l2_dev, "error starting stream transfer\n");\r\nrv = -1;\r\ngoto start_error;\r\n}\r\nstart_error:\r\nkfree(fw);\r\nreturn rv;\r\n}\r\nstatic inline void store_byte(struct go7007_buffer *gobuf, u8 byte)\r\n{\r\nif (gobuf != NULL && gobuf->bytesused < GO7007_BUF_SIZE) {\r\nunsigned int pgidx = gobuf->offset >> PAGE_SHIFT;\r\nunsigned int pgoff = gobuf->offset & ~PAGE_MASK;\r\n*((u8 *)page_address(gobuf->pages[pgidx]) + pgoff) = byte;\r\n++gobuf->offset;\r\n++gobuf->bytesused;\r\n}\r\n}\r\nstatic void frame_boundary(struct go7007 *go)\r\n{\r\nstruct go7007_buffer *gobuf;\r\nint i;\r\nif (go->active_buf) {\r\nif (go->active_buf->modet_active) {\r\nif (go->active_buf->bytesused + 216 < GO7007_BUF_SIZE) {\r\nfor (i = 0; i < 216; ++i)\r\nstore_byte(go->active_buf,\r\ngo->active_map[i]);\r\ngo->active_buf->bytesused -= 216;\r\n} else\r\ngo->active_buf->modet_active = 0;\r\n}\r\ngo->active_buf->state = BUF_STATE_DONE;\r\nwake_up_interruptible(&go->frame_waitq);\r\ngo->active_buf = NULL;\r\n}\r\nlist_for_each_entry(gobuf, &go->stream, stream)\r\nif (gobuf->state == BUF_STATE_QUEUED) {\r\ngobuf->seq = go->next_seq;\r\ndo_gettimeofday(&gobuf->timestamp);\r\ngo->active_buf = gobuf;\r\nbreak;\r\n}\r\n++go->next_seq;\r\n}\r\nstatic void write_bitmap_word(struct go7007 *go)\r\n{\r\nint x, y, i, stride = ((go->width >> 4) + 7) >> 3;\r\nfor (i = 0; i < 16; ++i) {\r\ny = (((go->parse_length - 1) << 3) + i) / (go->width >> 4);\r\nx = (((go->parse_length - 1) << 3) + i) % (go->width >> 4);\r\nif (stride * y + (x >> 3) < sizeof(go->active_map))\r\ngo->active_map[stride * y + (x >> 3)] |=\r\n(go->modet_word & 1) << (x & 0x7);\r\ngo->modet_word >>= 1;\r\n}\r\n}\r\nvoid go7007_parse_video_stream(struct go7007 *go, u8 *buf, int length)\r\n{\r\nint i, seq_start_code = -1, frame_start_code = -1;\r\nspin_lock(&go->spinlock);\r\nswitch (go->format) {\r\ncase GO7007_FORMAT_MPEG4:\r\nseq_start_code = 0xB0;\r\nframe_start_code = 0xB6;\r\nbreak;\r\ncase GO7007_FORMAT_MPEG1:\r\ncase GO7007_FORMAT_MPEG2:\r\nseq_start_code = 0xB3;\r\nframe_start_code = 0x00;\r\nbreak;\r\n}\r\nfor (i = 0; i < length; ++i) {\r\nif (go->active_buf != NULL &&\r\ngo->active_buf->bytesused >= GO7007_BUF_SIZE - 3) {\r\nv4l2_info(&go->v4l2_dev, "dropping oversized frame\n");\r\ngo->active_buf->offset -= go->active_buf->bytesused;\r\ngo->active_buf->bytesused = 0;\r\ngo->active_buf->modet_active = 0;\r\ngo->active_buf = NULL;\r\n}\r\nswitch (go->state) {\r\ncase STATE_DATA:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\ngo->state = STATE_00;\r\nbreak;\r\ncase 0xFF:\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(go->active_buf, buf[i]);\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_00:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\ngo->state = STATE_00_00;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(go->active_buf, 0x00);\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_00_00:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\nstore_byte(go->active_buf, 0x00);\r\nbreak;\r\ncase 0x01:\r\ngo->state = STATE_00_00_01;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x00);\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_00_00_01:\r\nif (buf[i] == 0xF8 && go->modet_enable == 0) {\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x01);\r\nstore_byte(go->active_buf, 0xF8);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nif ((go->format == GO7007_FORMAT_MPEG1 ||\r\ngo->format == GO7007_FORMAT_MPEG2 ||\r\ngo->format == GO7007_FORMAT_MPEG4) &&\r\n(buf[i] == seq_start_code ||\r\nbuf[i] == 0xB8 ||\r\nbuf[i] == frame_start_code)) {\r\nif (go->active_buf == NULL || go->seen_frame)\r\nframe_boundary(go);\r\nif (buf[i] == frame_start_code) {\r\nif (go->active_buf != NULL)\r\ngo->active_buf->frame_offset =\r\ngo->active_buf->offset;\r\ngo->seen_frame = 1;\r\n} else {\r\ngo->seen_frame = 0;\r\n}\r\n}\r\nswitch (buf[i]) {\r\ncase 0xF5:\r\ngo->parse_length = 12;\r\ngo->state = STATE_UNPARSED;\r\nbreak;\r\ncase 0xF6:\r\ngo->state = STATE_VBI_LEN_A;\r\nbreak;\r\ncase 0xF8:\r\ngo->parse_length = 0;\r\nmemset(go->active_map, 0,\r\nsizeof(go->active_map));\r\ngo->state = STATE_MODET_MAP;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x01);\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x00);\r\nstore_byte(go->active_buf, 0x01);\r\nstore_byte(go->active_buf, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_FF:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\nstore_byte(go->active_buf, 0xFF);\r\ngo->state = STATE_00;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(go->active_buf, 0xFF);\r\nbreak;\r\ncase 0xD8:\r\nif (go->format == GO7007_FORMAT_MJPEG)\r\nframe_boundary(go);\r\ndefault:\r\nstore_byte(go->active_buf, 0xFF);\r\nstore_byte(go->active_buf, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_VBI_LEN_A:\r\ngo->parse_length = buf[i] << 8;\r\ngo->state = STATE_VBI_LEN_B;\r\nbreak;\r\ncase STATE_VBI_LEN_B:\r\ngo->parse_length |= buf[i];\r\nif (go->parse_length > 0)\r\ngo->state = STATE_UNPARSED;\r\nelse\r\ngo->state = STATE_DATA;\r\nbreak;\r\ncase STATE_MODET_MAP:\r\nif (go->parse_length < 204) {\r\nif (go->parse_length & 1) {\r\ngo->modet_word |= buf[i];\r\nwrite_bitmap_word(go);\r\n} else\r\ngo->modet_word = buf[i] << 8;\r\n} else if (go->parse_length == 207 && go->active_buf) {\r\ngo->active_buf->modet_active = buf[i];\r\n}\r\nif (++go->parse_length == 208)\r\ngo->state = STATE_DATA;\r\nbreak;\r\ncase STATE_UNPARSED:\r\nif (--go->parse_length == 0)\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&go->spinlock);\r\n}\r\nstruct go7007 *go7007_alloc(struct go7007_board_info *board, struct device *dev)\r\n{\r\nstruct go7007 *go;\r\nint i;\r\ngo = kmalloc(sizeof(struct go7007), GFP_KERNEL);\r\nif (go == NULL)\r\nreturn NULL;\r\ngo->dev = dev;\r\ngo->board_info = board;\r\ngo->board_id = 0;\r\ngo->tuner_type = -1;\r\ngo->channel_number = 0;\r\ngo->name[0] = 0;\r\nmutex_init(&go->hw_lock);\r\ninit_waitqueue_head(&go->frame_waitq);\r\nspin_lock_init(&go->spinlock);\r\ngo->video_dev = NULL;\r\ngo->ref_count = 0;\r\ngo->status = STATUS_INIT;\r\nmemset(&go->i2c_adapter, 0, sizeof(go->i2c_adapter));\r\ngo->i2c_adapter_online = 0;\r\ngo->interrupt_available = 0;\r\ninit_waitqueue_head(&go->interrupt_waitq);\r\ngo->in_use = 0;\r\ngo->input = 0;\r\nif (board->sensor_flags & GO7007_SENSOR_TV) {\r\ngo->standard = GO7007_STD_NTSC;\r\ngo->width = 720;\r\ngo->height = 480;\r\ngo->sensor_framerate = 30000;\r\n} else {\r\ngo->standard = GO7007_STD_OTHER;\r\ngo->width = board->sensor_width;\r\ngo->height = board->sensor_height;\r\ngo->sensor_framerate = board->sensor_framerate;\r\n}\r\ngo->encoder_v_offset = board->sensor_v_offset;\r\ngo->encoder_h_offset = board->sensor_h_offset;\r\ngo->encoder_h_halve = 0;\r\ngo->encoder_v_halve = 0;\r\ngo->encoder_subsample = 0;\r\ngo->streaming = 0;\r\ngo->format = GO7007_FORMAT_MJPEG;\r\ngo->bitrate = 1500000;\r\ngo->fps_scale = 1;\r\ngo->pali = 0;\r\ngo->aspect_ratio = GO7007_RATIO_1_1;\r\ngo->gop_size = 0;\r\ngo->ipb = 0;\r\ngo->closed_gop = 0;\r\ngo->repeat_seqhead = 0;\r\ngo->seq_header_enable = 0;\r\ngo->gop_header_enable = 0;\r\ngo->dvd_mode = 0;\r\ngo->interlace_coding = 0;\r\nfor (i = 0; i < 4; ++i)\r\ngo->modet[i].enable = 0;\r\nfor (i = 0; i < 1624; ++i)\r\ngo->modet_map[i] = 0;\r\ngo->audio_deliver = NULL;\r\ngo->audio_enabled = 0;\r\nINIT_LIST_HEAD(&go->stream);\r\nreturn go;\r\n}\r\nvoid go7007_remove(struct go7007 *go)\r\n{\r\nif (go->i2c_adapter_online) {\r\nif (i2c_del_adapter(&go->i2c_adapter) == 0)\r\ngo->i2c_adapter_online = 0;\r\nelse\r\nv4l2_err(&go->v4l2_dev,\r\n"error removing I2C adapter!\n");\r\n}\r\nif (go->audio_enabled)\r\ngo7007_snd_remove(go);\r\ngo7007_v4l2_remove(go);\r\n}
