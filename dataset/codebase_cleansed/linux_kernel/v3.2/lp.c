static void lp_claim_parport_or_block(struct lp_struct *this_lp)\r\n{\r\nif (!test_and_set_bit(LP_PARPORT_CLAIMED, &this_lp->bits)) {\r\nparport_claim_or_block (this_lp->dev);\r\n}\r\n}\r\nstatic void lp_release_parport(struct lp_struct *this_lp)\r\n{\r\nif (test_and_clear_bit(LP_PARPORT_CLAIMED, &this_lp->bits)) {\r\nparport_release (this_lp->dev);\r\n}\r\n}\r\nstatic int lp_preempt(void *handle)\r\n{\r\nstruct lp_struct *this_lp = (struct lp_struct *)handle;\r\nset_bit(LP_PREEMPT_REQUEST, &this_lp->bits);\r\nreturn (1);\r\n}\r\nstatic int lp_negotiate(struct parport * port, int mode)\r\n{\r\nif (parport_negotiate (port, mode) != 0) {\r\nmode = IEEE1284_MODE_COMPAT;\r\nparport_negotiate (port, mode);\r\n}\r\nreturn (mode);\r\n}\r\nstatic int lp_reset(int minor)\r\n{\r\nint retval;\r\nlp_claim_parport_or_block (&lp_table[minor]);\r\nw_ctr(minor, LP_PSELECP);\r\nudelay (LP_DELAY);\r\nw_ctr(minor, LP_PSELECP | LP_PINITP);\r\nretval = r_str(minor);\r\nlp_release_parport (&lp_table[minor]);\r\nreturn retval;\r\n}\r\nstatic void lp_error (int minor)\r\n{\r\nDEFINE_WAIT(wait);\r\nint polling;\r\nif (LP_F(minor) & LP_ABORT)\r\nreturn;\r\npolling = lp_table[minor].dev->port->irq == PARPORT_IRQ_NONE;\r\nif (polling) lp_release_parport (&lp_table[minor]);\r\nprepare_to_wait(&lp_table[minor].waitq, &wait, TASK_INTERRUPTIBLE);\r\nschedule_timeout(LP_TIMEOUT_POLLED);\r\nfinish_wait(&lp_table[minor].waitq, &wait);\r\nif (polling) lp_claim_parport_or_block (&lp_table[minor]);\r\nelse parport_yield_blocking (lp_table[minor].dev);\r\n}\r\nstatic int lp_check_status(int minor)\r\n{\r\nint error = 0;\r\nunsigned int last = lp_table[minor].last_error;\r\nunsigned char status = r_str(minor);\r\nif ((status & LP_PERRORP) && !(LP_F(minor) & LP_CAREFUL))\r\nlast = 0;\r\nelse if ((status & LP_POUTPA)) {\r\nif (last != LP_POUTPA) {\r\nlast = LP_POUTPA;\r\nprintk(KERN_INFO "lp%d out of paper\n", minor);\r\n}\r\nerror = -ENOSPC;\r\n} else if (!(status & LP_PSELECD)) {\r\nif (last != LP_PSELECD) {\r\nlast = LP_PSELECD;\r\nprintk(KERN_INFO "lp%d off-line\n", minor);\r\n}\r\nerror = -EIO;\r\n} else if (!(status & LP_PERRORP)) {\r\nif (last != LP_PERRORP) {\r\nlast = LP_PERRORP;\r\nprintk(KERN_INFO "lp%d on fire\n", minor);\r\n}\r\nerror = -EIO;\r\n} else {\r\nlast = 0;\r\n}\r\nlp_table[minor].last_error = last;\r\nif (last != 0)\r\nlp_error(minor);\r\nreturn error;\r\n}\r\nstatic int lp_wait_ready(int minor, int nonblock)\r\n{\r\nint error = 0;\r\nif (lp_table[minor].current_mode != IEEE1284_MODE_COMPAT) {\r\nreturn (0);\r\n}\r\ndo {\r\nerror = lp_check_status (minor);\r\nif (error && (nonblock || (LP_F(minor) & LP_ABORT)))\r\nbreak;\r\nif (signal_pending (current)) {\r\nerror = -EINTR;\r\nbreak;\r\n}\r\n} while (error);\r\nreturn error;\r\n}\r\nstatic ssize_t lp_write(struct file * file, const char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned int minor = iminor(file->f_path.dentry->d_inode);\r\nstruct parport *port = lp_table[minor].dev->port;\r\nchar *kbuf = lp_table[minor].lp_buffer;\r\nssize_t retv = 0;\r\nssize_t written;\r\nsize_t copy_size = count;\r\nint nonblock = ((file->f_flags & O_NONBLOCK) ||\r\n(LP_F(minor) & LP_ABORT));\r\n#ifdef LP_STATS\r\nif (time_after(jiffies, lp_table[minor].lastcall + LP_TIME(minor)))\r\nlp_table[minor].runchars = 0;\r\nlp_table[minor].lastcall = jiffies;\r\n#endif\r\nif (copy_size > LP_BUFFER_SIZE)\r\ncopy_size = LP_BUFFER_SIZE;\r\nif (mutex_lock_interruptible(&lp_table[minor].port_mutex))\r\nreturn -EINTR;\r\nif (copy_from_user (kbuf, buf, copy_size)) {\r\nretv = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nlp_claim_parport_or_block (&lp_table[minor]);\r\nlp_table[minor].current_mode = lp_negotiate (port,\r\nlp_table[minor].best_mode);\r\nparport_set_timeout (lp_table[minor].dev,\r\n(nonblock ? PARPORT_INACTIVITY_O_NONBLOCK\r\n: lp_table[minor].timeout));\r\nif ((retv = lp_wait_ready (minor, nonblock)) == 0)\r\ndo {\r\nwritten = parport_write (port, kbuf, copy_size);\r\nif (written > 0) {\r\ncopy_size -= written;\r\ncount -= written;\r\nbuf += written;\r\nretv += written;\r\n}\r\nif (signal_pending (current)) {\r\nif (retv == 0)\r\nretv = -EINTR;\r\nbreak;\r\n}\r\nif (copy_size > 0) {\r\nint error;\r\nparport_negotiate (lp_table[minor].dev->port,\r\nIEEE1284_MODE_COMPAT);\r\nlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\r\nerror = lp_wait_ready (minor, nonblock);\r\nif (error) {\r\nif (retv == 0)\r\nretv = error;\r\nbreak;\r\n} else if (nonblock) {\r\nif (retv == 0)\r\nretv = -EAGAIN;\r\nbreak;\r\n}\r\nparport_yield_blocking (lp_table[minor].dev);\r\nlp_table[minor].current_mode\r\n= lp_negotiate (port,\r\nlp_table[minor].best_mode);\r\n} else if (need_resched())\r\nschedule ();\r\nif (count) {\r\ncopy_size = count;\r\nif (copy_size > LP_BUFFER_SIZE)\r\ncopy_size = LP_BUFFER_SIZE;\r\nif (copy_from_user(kbuf, buf, copy_size)) {\r\nif (retv == 0)\r\nretv = -EFAULT;\r\nbreak;\r\n}\r\n}\r\n} while (count > 0);\r\nif (test_and_clear_bit(LP_PREEMPT_REQUEST,\r\n&lp_table[minor].bits)) {\r\nprintk(KERN_INFO "lp%d releasing parport\n", minor);\r\nparport_negotiate (lp_table[minor].dev->port,\r\nIEEE1284_MODE_COMPAT);\r\nlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\r\nlp_release_parport (&lp_table[minor]);\r\n}\r\nout_unlock:\r\nmutex_unlock(&lp_table[minor].port_mutex);\r\nreturn retv;\r\n}\r\nstatic ssize_t lp_read(struct file * file, char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nDEFINE_WAIT(wait);\r\nunsigned int minor=iminor(file->f_path.dentry->d_inode);\r\nstruct parport *port = lp_table[minor].dev->port;\r\nssize_t retval = 0;\r\nchar *kbuf = lp_table[minor].lp_buffer;\r\nint nonblock = ((file->f_flags & O_NONBLOCK) ||\r\n(LP_F(minor) & LP_ABORT));\r\nif (count > LP_BUFFER_SIZE)\r\ncount = LP_BUFFER_SIZE;\r\nif (mutex_lock_interruptible(&lp_table[minor].port_mutex))\r\nreturn -EINTR;\r\nlp_claim_parport_or_block (&lp_table[minor]);\r\nparport_set_timeout (lp_table[minor].dev,\r\n(nonblock ? PARPORT_INACTIVITY_O_NONBLOCK\r\n: lp_table[minor].timeout));\r\nparport_negotiate (lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\r\nif (parport_negotiate (lp_table[minor].dev->port,\r\nIEEE1284_MODE_NIBBLE)) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nwhile (retval == 0) {\r\nretval = parport_read (port, kbuf, count);\r\nif (retval > 0)\r\nbreak;\r\nif (nonblock) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (lp_table[minor].dev->port->irq == PARPORT_IRQ_NONE) {\r\nparport_negotiate (lp_table[minor].dev->port,\r\nIEEE1284_MODE_COMPAT);\r\nlp_error (minor);\r\nif (parport_negotiate (lp_table[minor].dev->port,\r\nIEEE1284_MODE_NIBBLE)) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\n} else {\r\nprepare_to_wait(&lp_table[minor].waitq, &wait, TASK_INTERRUPTIBLE);\r\nschedule_timeout(LP_TIMEOUT_POLLED);\r\nfinish_wait(&lp_table[minor].waitq, &wait);\r\n}\r\nif (signal_pending (current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\ncond_resched ();\r\n}\r\nparport_negotiate (lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\r\nout:\r\nlp_release_parport (&lp_table[minor]);\r\nif (retval > 0 && copy_to_user (buf, kbuf, retval))\r\nretval = -EFAULT;\r\nmutex_unlock(&lp_table[minor].port_mutex);\r\nreturn retval;\r\n}\r\nstatic int lp_open(struct inode * inode, struct file * file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nint ret = 0;\r\nmutex_lock(&lp_mutex);\r\nif (minor >= LP_NO) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif ((LP_F(minor) & LP_EXIST) == 0) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (test_and_set_bit(LP_BUSY_BIT_POS, &LP_F(minor))) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif ((LP_F(minor) & LP_ABORTOPEN) && !(file->f_flags & O_NONBLOCK)) {\r\nint status;\r\nlp_claim_parport_or_block (&lp_table[minor]);\r\nstatus = r_str(minor);\r\nlp_release_parport (&lp_table[minor]);\r\nif (status & LP_POUTPA) {\r\nprintk(KERN_INFO "lp%d out of paper\n", minor);\r\nLP_F(minor) &= ~LP_BUSY;\r\nret = -ENOSPC;\r\ngoto out;\r\n} else if (!(status & LP_PSELECD)) {\r\nprintk(KERN_INFO "lp%d off-line\n", minor);\r\nLP_F(minor) &= ~LP_BUSY;\r\nret = -EIO;\r\ngoto out;\r\n} else if (!(status & LP_PERRORP)) {\r\nprintk(KERN_ERR "lp%d printer error\n", minor);\r\nLP_F(minor) &= ~LP_BUSY;\r\nret = -EIO;\r\ngoto out;\r\n}\r\n}\r\nlp_table[minor].lp_buffer = kmalloc(LP_BUFFER_SIZE, GFP_KERNEL);\r\nif (!lp_table[minor].lp_buffer) {\r\nLP_F(minor) &= ~LP_BUSY;\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nlp_claim_parport_or_block (&lp_table[minor]);\r\nif ( (lp_table[minor].dev->port->modes & PARPORT_MODE_ECP) &&\r\n!parport_negotiate (lp_table[minor].dev->port,\r\nIEEE1284_MODE_ECP)) {\r\nprintk (KERN_INFO "lp%d: ECP mode\n", minor);\r\nlp_table[minor].best_mode = IEEE1284_MODE_ECP;\r\n} else {\r\nlp_table[minor].best_mode = IEEE1284_MODE_COMPAT;\r\n}\r\nparport_negotiate (lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\r\nlp_release_parport (&lp_table[minor]);\r\nlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\r\nout:\r\nmutex_unlock(&lp_mutex);\r\nreturn ret;\r\n}\r\nstatic int lp_release(struct inode * inode, struct file * file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nlp_claim_parport_or_block (&lp_table[minor]);\r\nparport_negotiate (lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\r\nlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\r\nlp_release_parport (&lp_table[minor]);\r\nkfree(lp_table[minor].lp_buffer);\r\nlp_table[minor].lp_buffer = NULL;\r\nLP_F(minor) &= ~LP_BUSY;\r\nreturn 0;\r\n}\r\nstatic int lp_do_ioctl(unsigned int minor, unsigned int cmd,\r\nunsigned long arg, void __user *argp)\r\n{\r\nint status;\r\nint retval = 0;\r\n#ifdef LP_DEBUG\r\nprintk(KERN_DEBUG "lp%d ioctl, cmd: 0x%x, arg: 0x%lx\n", minor, cmd, arg);\r\n#endif\r\nif (minor >= LP_NO)\r\nreturn -ENODEV;\r\nif ((LP_F(minor) & LP_EXIST) == 0)\r\nreturn -ENODEV;\r\nswitch ( cmd ) {\r\ncase LPTIME:\r\nLP_TIME(minor) = arg * HZ/100;\r\nbreak;\r\ncase LPCHAR:\r\nLP_CHAR(minor) = arg;\r\nbreak;\r\ncase LPABORT:\r\nif (arg)\r\nLP_F(minor) |= LP_ABORT;\r\nelse\r\nLP_F(minor) &= ~LP_ABORT;\r\nbreak;\r\ncase LPABORTOPEN:\r\nif (arg)\r\nLP_F(minor) |= LP_ABORTOPEN;\r\nelse\r\nLP_F(minor) &= ~LP_ABORTOPEN;\r\nbreak;\r\ncase LPCAREFUL:\r\nif (arg)\r\nLP_F(minor) |= LP_CAREFUL;\r\nelse\r\nLP_F(minor) &= ~LP_CAREFUL;\r\nbreak;\r\ncase LPWAIT:\r\nLP_WAIT(minor) = arg;\r\nbreak;\r\ncase LPSETIRQ:\r\nreturn -EINVAL;\r\nbreak;\r\ncase LPGETIRQ:\r\nif (copy_to_user(argp, &LP_IRQ(minor),\r\nsizeof(int)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase LPGETSTATUS:\r\nlp_claim_parport_or_block (&lp_table[minor]);\r\nstatus = r_str(minor);\r\nlp_release_parport (&lp_table[minor]);\r\nif (copy_to_user(argp, &status, sizeof(int)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase LPRESET:\r\nlp_reset(minor);\r\nbreak;\r\n#ifdef LP_STATS\r\ncase LPGETSTATS:\r\nif (copy_to_user(argp, &LP_STAT(minor),\r\nsizeof(struct lp_stats)))\r\nreturn -EFAULT;\r\nif (capable(CAP_SYS_ADMIN))\r\nmemset(&LP_STAT(minor), 0,\r\nsizeof(struct lp_stats));\r\nbreak;\r\n#endif\r\ncase LPGETFLAGS:\r\nstatus = LP_F(minor);\r\nif (copy_to_user(argp, &status, sizeof(int)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic int lp_set_timeout(unsigned int minor, struct timeval *par_timeout)\r\n{\r\nlong to_jiffies;\r\nif ((par_timeout->tv_sec < 0) ||\r\n(par_timeout->tv_usec < 0)) {\r\nreturn -EINVAL;\r\n}\r\nto_jiffies = DIV_ROUND_UP(par_timeout->tv_usec, 1000000/HZ);\r\nto_jiffies += par_timeout->tv_sec * (long) HZ;\r\nif (to_jiffies <= 0) {\r\nreturn -EINVAL;\r\n}\r\nlp_table[minor].timeout = to_jiffies;\r\nreturn 0;\r\n}\r\nstatic long lp_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nunsigned int minor;\r\nstruct timeval par_timeout;\r\nint ret;\r\nminor = iminor(file->f_path.dentry->d_inode);\r\nmutex_lock(&lp_mutex);\r\nswitch (cmd) {\r\ncase LPSETTIMEOUT:\r\nif (copy_from_user(&par_timeout, (void __user *)arg,\r\nsizeof (struct timeval))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = lp_set_timeout(minor, &par_timeout);\r\nbreak;\r\ndefault:\r\nret = lp_do_ioctl(minor, cmd, arg, (void __user *)arg);\r\nbreak;\r\n}\r\nmutex_unlock(&lp_mutex);\r\nreturn ret;\r\n}\r\nstatic long lp_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nunsigned int minor;\r\nstruct timeval par_timeout;\r\nstruct compat_timeval __user *tc;\r\nint ret;\r\nminor = iminor(file->f_path.dentry->d_inode);\r\nmutex_lock(&lp_mutex);\r\nswitch (cmd) {\r\ncase LPSETTIMEOUT:\r\ntc = compat_ptr(arg);\r\nif (get_user(par_timeout.tv_sec, &tc->tv_sec) ||\r\nget_user(par_timeout.tv_usec, &tc->tv_usec)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = lp_set_timeout(minor, &par_timeout);\r\nbreak;\r\n#ifdef LP_STATS\r\ncase LPGETSTATS:\r\nret = -EINVAL;\r\nbreak;\r\n#endif\r\ndefault:\r\nret = lp_do_ioctl(minor, cmd, arg, compat_ptr(arg));\r\nbreak;\r\n}\r\nmutex_unlock(&lp_mutex);\r\nreturn ret;\r\n}\r\nstatic void lp_console_write (struct console *co, const char *s,\r\nunsigned count)\r\n{\r\nstruct pardevice *dev = lp_table[CONSOLE_LP].dev;\r\nstruct parport *port = dev->port;\r\nssize_t written;\r\nif (parport_claim (dev))\r\nreturn;\r\nparport_set_timeout (dev, 0);\r\nparport_negotiate (port, IEEE1284_MODE_COMPAT);\r\ndo {\r\nssize_t canwrite = count;\r\nchar *lf = memchr (s, '\n', count);\r\nif (lf)\r\ncanwrite = lf - s;\r\nif (canwrite > 0) {\r\nwritten = parport_write (port, s, canwrite);\r\nif (written <= 0)\r\ncontinue;\r\ns += written;\r\ncount -= written;\r\ncanwrite -= written;\r\n}\r\nif (lf && canwrite <= 0) {\r\nconst char *crlf = "\r\n";\r\nint i = 2;\r\ns++;\r\ncount--;\r\ndo {\r\nwritten = parport_write (port, crlf, i);\r\nif (written > 0)\r\ni -= written, crlf += written;\r\n} while (i > 0 && (CONSOLE_LP_STRICT || written > 0));\r\n}\r\n} while (count > 0 && (CONSOLE_LP_STRICT || written > 0));\r\nparport_release (dev);\r\n}\r\nstatic int __init lp_setup (char *str)\r\n{\r\nstatic int parport_ptr;\r\nint x;\r\nif (get_option(&str, &x)) {\r\nif (x == 0) {\r\nparport_nr[0] = LP_PARPORT_OFF;\r\n} else {\r\nprintk(KERN_WARNING "warning: 'lp=0x%x' is deprecated, ignored\n", x);\r\nreturn 0;\r\n}\r\n} else if (!strncmp(str, "parport", 7)) {\r\nint n = simple_strtoul(str+7, NULL, 10);\r\nif (parport_ptr < LP_NO)\r\nparport_nr[parport_ptr++] = n;\r\nelse\r\nprintk(KERN_INFO "lp: too many ports, %s ignored.\n",\r\nstr);\r\n} else if (!strcmp(str, "auto")) {\r\nparport_nr[0] = LP_PARPORT_AUTO;\r\n} else if (!strcmp(str, "none")) {\r\nparport_nr[parport_ptr++] = LP_PARPORT_NONE;\r\n} else if (!strcmp(str, "reset")) {\r\nreset = 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int lp_register(int nr, struct parport *port)\r\n{\r\nlp_table[nr].dev = parport_register_device(port, "lp",\r\nlp_preempt, NULL, NULL, 0,\r\n(void *) &lp_table[nr]);\r\nif (lp_table[nr].dev == NULL)\r\nreturn 1;\r\nlp_table[nr].flags |= LP_EXIST;\r\nif (reset)\r\nlp_reset(nr);\r\ndevice_create(lp_class, port->dev, MKDEV(LP_MAJOR, nr), NULL,\r\n"lp%d", nr);\r\nprintk(KERN_INFO "lp%d: using %s (%s).\n", nr, port->name,\r\n(port->irq == PARPORT_IRQ_NONE)?"polling":"interrupt-driven");\r\n#ifdef CONFIG_LP_CONSOLE\r\nif (!nr) {\r\nif (port->modes & PARPORT_MODE_SAFEININT) {\r\nregister_console(&lpcons);\r\nconsole_registered = port;\r\nprintk (KERN_INFO "lp%d: console ready\n", CONSOLE_LP);\r\n} else\r\nprintk (KERN_ERR "lp%d: cannot run console on %s\n",\r\nCONSOLE_LP, port->name);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void lp_attach (struct parport *port)\r\n{\r\nunsigned int i;\r\nswitch (parport_nr[0]) {\r\ncase LP_PARPORT_UNSPEC:\r\ncase LP_PARPORT_AUTO:\r\nif (parport_nr[0] == LP_PARPORT_AUTO &&\r\nport->probe_info[0].class != PARPORT_CLASS_PRINTER)\r\nreturn;\r\nif (lp_count == LP_NO) {\r\nprintk(KERN_INFO "lp: ignoring parallel port (max. %d)\n",LP_NO);\r\nreturn;\r\n}\r\nif (!lp_register(lp_count, port))\r\nlp_count++;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i < LP_NO; i++) {\r\nif (port->number == parport_nr[i]) {\r\nif (!lp_register(i, port))\r\nlp_count++;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void lp_detach (struct parport *port)\r\n{\r\n#ifdef CONFIG_LP_CONSOLE\r\nif (console_registered == port) {\r\nunregister_console(&lpcons);\r\nconsole_registered = NULL;\r\n}\r\n#endif\r\n}\r\nstatic int __init lp_init (void)\r\n{\r\nint i, err = 0;\r\nif (parport_nr[0] == LP_PARPORT_OFF)\r\nreturn 0;\r\nfor (i = 0; i < LP_NO; i++) {\r\nlp_table[i].dev = NULL;\r\nlp_table[i].flags = 0;\r\nlp_table[i].chars = LP_INIT_CHAR;\r\nlp_table[i].time = LP_INIT_TIME;\r\nlp_table[i].wait = LP_INIT_WAIT;\r\nlp_table[i].lp_buffer = NULL;\r\n#ifdef LP_STATS\r\nlp_table[i].lastcall = 0;\r\nlp_table[i].runchars = 0;\r\nmemset (&lp_table[i].stats, 0, sizeof (struct lp_stats));\r\n#endif\r\nlp_table[i].last_error = 0;\r\ninit_waitqueue_head (&lp_table[i].waitq);\r\ninit_waitqueue_head (&lp_table[i].dataq);\r\nmutex_init(&lp_table[i].port_mutex);\r\nlp_table[i].timeout = 10 * HZ;\r\n}\r\nif (register_chrdev (LP_MAJOR, "lp", &lp_fops)) {\r\nprintk (KERN_ERR "lp: unable to get major %d\n", LP_MAJOR);\r\nreturn -EIO;\r\n}\r\nlp_class = class_create(THIS_MODULE, "printer");\r\nif (IS_ERR(lp_class)) {\r\nerr = PTR_ERR(lp_class);\r\ngoto out_reg;\r\n}\r\nif (parport_register_driver (&lp_driver)) {\r\nprintk (KERN_ERR "lp: unable to register with parport\n");\r\nerr = -EIO;\r\ngoto out_class;\r\n}\r\nif (!lp_count) {\r\nprintk (KERN_INFO "lp: driver loaded but no devices found\n");\r\n#ifndef CONFIG_PARPORT_1284\r\nif (parport_nr[0] == LP_PARPORT_AUTO)\r\nprintk (KERN_INFO "lp: (is IEEE 1284 support enabled?)\n");\r\n#endif\r\n}\r\nreturn 0;\r\nout_class:\r\nclass_destroy(lp_class);\r\nout_reg:\r\nunregister_chrdev(LP_MAJOR, "lp");\r\nreturn err;\r\n}\r\nstatic int __init lp_init_module (void)\r\n{\r\nif (parport[0]) {\r\nif (!strncmp(parport[0], "auto", 4))\r\nparport_nr[0] = LP_PARPORT_AUTO;\r\nelse {\r\nint n;\r\nfor (n = 0; n < LP_NO && parport[n]; n++) {\r\nif (!strncmp(parport[n], "none", 4))\r\nparport_nr[n] = LP_PARPORT_NONE;\r\nelse {\r\nchar *ep;\r\nunsigned long r = simple_strtoul(parport[n], &ep, 0);\r\nif (ep != parport[n])\r\nparport_nr[n] = r;\r\nelse {\r\nprintk(KERN_ERR "lp: bad port specifier `%s'\n", parport[n]);\r\nreturn -ENODEV;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn lp_init();\r\n}\r\nstatic void lp_cleanup_module (void)\r\n{\r\nunsigned int offset;\r\nparport_unregister_driver (&lp_driver);\r\n#ifdef CONFIG_LP_CONSOLE\r\nunregister_console (&lpcons);\r\n#endif\r\nunregister_chrdev(LP_MAJOR, "lp");\r\nfor (offset = 0; offset < LP_NO; offset++) {\r\nif (lp_table[offset].dev == NULL)\r\ncontinue;\r\nparport_unregister_device(lp_table[offset].dev);\r\ndevice_destroy(lp_class, MKDEV(LP_MAJOR, offset));\r\n}\r\nclass_destroy(lp_class);\r\n}
