static int setChar(struct yealink_dev *yld, int el, int chr)\r\n{\r\nint i, a, m, val;\r\nif (el >= ARRAY_SIZE(lcdMap))\r\nreturn -EINVAL;\r\nif (chr == '\t' || chr == '\n')\r\nreturn 0;\r\nyld->lcdMap[el] = chr;\r\nif (lcdMap[el].type == '.') {\r\na = lcdMap[el].u.p.a;\r\nm = lcdMap[el].u.p.m;\r\nif (chr != ' ')\r\nyld->master.b[a] |= m;\r\nelse\r\nyld->master.b[a] &= ~m;\r\nreturn 0;\r\n}\r\nval = map_to_seg7(&map_seg7, chr);\r\nfor (i = 0; i < ARRAY_SIZE(lcdMap[0].u.s); i++) {\r\nm = lcdMap[el].u.s[i].m;\r\nif (m == 0)\r\ncontinue;\r\na = lcdMap[el].u.s[i].a;\r\nif (val & 1)\r\nyld->master.b[a] |= m;\r\nelse\r\nyld->master.b[a] &= ~m;\r\nval = val >> 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int map_p1k_to_key(int scancode)\r\n{\r\nswitch(scancode) {\r\ncase 0x23: return KEY_LEFT;\r\ncase 0x33: return KEY_UP;\r\ncase 0x04: return KEY_RIGHT;\r\ncase 0x24: return KEY_DOWN;\r\ncase 0x03: return KEY_ENTER;\r\ncase 0x14: return KEY_BACKSPACE;\r\ncase 0x13: return KEY_ESC;\r\ncase 0x00: return KEY_1;\r\ncase 0x01: return KEY_2;\r\ncase 0x02: return KEY_3;\r\ncase 0x10: return KEY_4;\r\ncase 0x11: return KEY_5;\r\ncase 0x12: return KEY_6;\r\ncase 0x20: return KEY_7;\r\ncase 0x21: return KEY_8;\r\ncase 0x22: return KEY_9;\r\ncase 0x30: return KEY_KPASTERISK;\r\ncase 0x31: return KEY_0;\r\ncase 0x32: return KEY_LEFTSHIFT |\r\nKEY_3 << 8;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void report_key(struct yealink_dev *yld, int key)\r\n{\r\nstruct input_dev *idev = yld->idev;\r\nif (yld->key_code >= 0) {\r\ninput_report_key(idev, yld->key_code & 0xff, 0);\r\nif (yld->key_code >> 8)\r\ninput_report_key(idev, yld->key_code >> 8, 0);\r\n}\r\nyld->key_code = key;\r\nif (key >= 0) {\r\ninput_report_key(idev, key & 0xff, 1);\r\nif (key >> 8)\r\ninput_report_key(idev, key >> 8, 1);\r\n}\r\ninput_sync(idev);\r\n}\r\nstatic int yealink_cmd(struct yealink_dev *yld, struct yld_ctl_packet *p)\r\n{\r\nu8 *buf = (u8 *)p;\r\nint i;\r\nu8 sum = 0;\r\nfor(i=0; i<USB_PKT_LEN-1; i++)\r\nsum -= buf[i];\r\np->sum = sum;\r\nreturn usb_control_msg(yld->udev,\r\nusb_sndctrlpipe(yld->udev, 0),\r\nUSB_REQ_SET_CONFIGURATION,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\r\n0x200, 3,\r\np, sizeof(*p),\r\nUSB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic int yealink_set_ringtone(struct yealink_dev *yld, u8 *buf, size_t size)\r\n{\r\nstruct yld_ctl_packet *p = yld->ctl_data;\r\nint ix, len;\r\nif (size <= 0)\r\nreturn -EINVAL;\r\nmemset(yld->ctl_data, 0, sizeof(*(yld->ctl_data)));\r\nyld->ctl_data->cmd = CMD_RING_VOLUME;\r\nyld->ctl_data->size = 1;\r\nyld->ctl_data->data[0] = buf[0];\r\nyealink_cmd(yld, p);\r\nbuf++;\r\nsize--;\r\np->cmd = CMD_RING_NOTE;\r\nix = 0;\r\nwhile (size != ix) {\r\nlen = size - ix;\r\nif (len > sizeof(p->data))\r\nlen = sizeof(p->data);\r\np->size = len;\r\np->offset = cpu_to_be16(ix);\r\nmemcpy(p->data, &buf[ix], len);\r\nyealink_cmd(yld, p);\r\nix += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int yealink_do_idle_tasks(struct yealink_dev *yld)\r\n{\r\nu8 val;\r\nint i, ix, len;\r\nix = yld->stat_ix;\r\nmemset(yld->ctl_data, 0, sizeof(*(yld->ctl_data)));\r\nyld->ctl_data->cmd = CMD_KEYPRESS;\r\nyld->ctl_data->size = 1;\r\nyld->ctl_data->sum = 0xff - CMD_KEYPRESS;\r\nif (ix >= sizeof(yld->master)) {\r\nyld->stat_ix = 0;\r\nreturn 0;\r\n}\r\ndo {\r\nval = yld->master.b[ix];\r\nif (val != yld->copy.b[ix])\r\ngoto send_update;\r\n} while (++ix < sizeof(yld->master));\r\nyld->stat_ix = 0;\r\nreturn 0;\r\nsend_update:\r\nyld->copy.b[ix] = val;\r\nyld->ctl_data->data[0] = val;\r\nswitch(ix) {\r\ncase offsetof(struct yld_status, led):\r\nyld->ctl_data->cmd = CMD_LED;\r\nyld->ctl_data->sum = -1 - CMD_LED - val;\r\nbreak;\r\ncase offsetof(struct yld_status, dialtone):\r\nyld->ctl_data->cmd = CMD_DIALTONE;\r\nyld->ctl_data->sum = -1 - CMD_DIALTONE - val;\r\nbreak;\r\ncase offsetof(struct yld_status, ringtone):\r\nyld->ctl_data->cmd = CMD_RINGTONE;\r\nyld->ctl_data->sum = -1 - CMD_RINGTONE - val;\r\nbreak;\r\ncase offsetof(struct yld_status, keynum):\r\nval--;\r\nval &= 0x1f;\r\nyld->ctl_data->cmd = CMD_SCANCODE;\r\nyld->ctl_data->offset = cpu_to_be16(val);\r\nyld->ctl_data->data[0] = 0;\r\nyld->ctl_data->sum = -1 - CMD_SCANCODE - val;\r\nbreak;\r\ndefault:\r\nlen = sizeof(yld->master.s.lcd) - ix;\r\nif (len > sizeof(yld->ctl_data->data))\r\nlen = sizeof(yld->ctl_data->data);\r\nyld->ctl_data->cmd = CMD_LCD;\r\nyld->ctl_data->offset = cpu_to_be16(ix);\r\nyld->ctl_data->size = len;\r\nyld->ctl_data->sum = -CMD_LCD - ix - val - len;\r\nfor(i=1; i<len; i++) {\r\nix++;\r\nval = yld->master.b[ix];\r\nyld->copy.b[ix] = val;\r\nyld->ctl_data->data[i] = val;\r\nyld->ctl_data->sum -= val;\r\n}\r\n}\r\nyld->stat_ix = ix + 1;\r\nreturn 1;\r\n}\r\nstatic void urb_irq_callback(struct urb *urb)\r\n{\r\nstruct yealink_dev *yld = urb->context;\r\nint ret, status = urb->status;\r\nif (status)\r\nerr("%s - urb status %d", __func__, status);\r\nswitch (yld->irq_data->cmd) {\r\ncase CMD_KEYPRESS:\r\nyld->master.s.keynum = yld->irq_data->data[0];\r\nbreak;\r\ncase CMD_SCANCODE:\r\ndbg("get scancode %x", yld->irq_data->data[0]);\r\nreport_key(yld, map_p1k_to_key(yld->irq_data->data[0]));\r\nbreak;\r\ndefault:\r\nerr("unexpected response %x", yld->irq_data->cmd);\r\n}\r\nyealink_do_idle_tasks(yld);\r\nif (!yld->shutdown) {\r\nret = usb_submit_urb(yld->urb_ctl, GFP_ATOMIC);\r\nif (ret && ret != -EPERM)\r\nerr("%s - usb_submit_urb failed %d", __func__, ret);\r\n}\r\n}\r\nstatic void urb_ctl_callback(struct urb *urb)\r\n{\r\nstruct yealink_dev *yld = urb->context;\r\nint ret = 0, status = urb->status;\r\nif (status)\r\nerr("%s - urb status %d", __func__, status);\r\nswitch (yld->ctl_data->cmd) {\r\ncase CMD_KEYPRESS:\r\ncase CMD_SCANCODE:\r\nif (!yld->shutdown)\r\nret = usb_submit_urb(yld->urb_irq, GFP_ATOMIC);\r\nbreak;\r\ndefault:\r\nyealink_do_idle_tasks(yld);\r\nif (!yld->shutdown)\r\nret = usb_submit_urb(yld->urb_ctl, GFP_ATOMIC);\r\nbreak;\r\n}\r\nif (ret && ret != -EPERM)\r\nerr("%s - usb_submit_urb failed %d", __func__, ret);\r\n}\r\nstatic int input_open(struct input_dev *dev)\r\n{\r\nstruct yealink_dev *yld = input_get_drvdata(dev);\r\nint i, ret;\r\ndbg("%s", __func__);\r\nfor (i = 0; i<sizeof(yld->master); i++)\r\nyld->copy.b[i] = ~yld->master.b[i];\r\nyld->key_code = -1;\r\nyealink_set_ringtone(yld, default_ringtone, sizeof(default_ringtone));\r\nmemset(yld->ctl_data, 0, sizeof(*(yld->ctl_data)));\r\nyld->ctl_data->cmd = CMD_INIT;\r\nyld->ctl_data->size = 10;\r\nyld->ctl_data->sum = 0x100-CMD_INIT-10;\r\nif ((ret = usb_submit_urb(yld->urb_ctl, GFP_KERNEL)) != 0) {\r\ndbg("%s - usb_submit_urb failed with result %d",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void input_close(struct input_dev *dev)\r\n{\r\nstruct yealink_dev *yld = input_get_drvdata(dev);\r\nyld->shutdown = 1;\r\nsmp_wmb();\r\nusb_kill_urb(yld->urb_ctl);\r\nusb_kill_urb(yld->urb_irq);\r\nyld->shutdown = 0;\r\nsmp_wmb();\r\n}\r\nstatic ssize_t show_map(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nmemcpy(buf, &map_seg7, sizeof(map_seg7));\r\nreturn sizeof(map_seg7);\r\n}\r\nstatic ssize_t store_map(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t cnt)\r\n{\r\nif (cnt != sizeof(map_seg7))\r\nreturn -EINVAL;\r\nmemcpy(&map_seg7, buf, sizeof(map_seg7));\r\nreturn sizeof(map_seg7);\r\n}\r\nstatic ssize_t show_line(struct device *dev, char *buf, int a, int b)\r\n{\r\nstruct yealink_dev *yld;\r\nint i;\r\ndown_read(&sysfs_rwsema);\r\nyld = dev_get_drvdata(dev);\r\nif (yld == NULL) {\r\nup_read(&sysfs_rwsema);\r\nreturn -ENODEV;\r\n}\r\nfor (i = a; i < b; i++)\r\n*buf++ = lcdMap[i].type;\r\n*buf++ = '\n';\r\nfor (i = a; i < b; i++)\r\n*buf++ = yld->lcdMap[i];\r\n*buf++ = '\n';\r\n*buf = 0;\r\nup_read(&sysfs_rwsema);\r\nreturn 3 + ((b - a) << 1);\r\n}\r\nstatic ssize_t show_line1(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_line(dev, buf, LCD_LINE1_OFFSET, LCD_LINE2_OFFSET);\r\n}\r\nstatic ssize_t show_line2(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_line(dev, buf, LCD_LINE2_OFFSET, LCD_LINE3_OFFSET);\r\n}\r\nstatic ssize_t show_line3(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_line(dev, buf, LCD_LINE3_OFFSET, LCD_LINE4_OFFSET);\r\n}\r\nstatic ssize_t store_line(struct device *dev, const char *buf, size_t count,\r\nint el, size_t len)\r\n{\r\nstruct yealink_dev *yld;\r\nint i;\r\ndown_write(&sysfs_rwsema);\r\nyld = dev_get_drvdata(dev);\r\nif (yld == NULL) {\r\nup_write(&sysfs_rwsema);\r\nreturn -ENODEV;\r\n}\r\nif (len > count)\r\nlen = count;\r\nfor (i = 0; i < len; i++)\r\nsetChar(yld, el++, buf[i]);\r\nup_write(&sysfs_rwsema);\r\nreturn count;\r\n}\r\nstatic ssize_t store_line1(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn store_line(dev, buf, count, LCD_LINE1_OFFSET, LCD_LINE1_SIZE);\r\n}\r\nstatic ssize_t store_line2(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn store_line(dev, buf, count, LCD_LINE2_OFFSET, LCD_LINE2_SIZE);\r\n}\r\nstatic ssize_t store_line3(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn store_line(dev, buf, count, LCD_LINE3_OFFSET, LCD_LINE3_SIZE);\r\n}\r\nstatic ssize_t get_icons(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct yealink_dev *yld;\r\nint i, ret = 1;\r\ndown_read(&sysfs_rwsema);\r\nyld = dev_get_drvdata(dev);\r\nif (yld == NULL) {\r\nup_read(&sysfs_rwsema);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(lcdMap); i++) {\r\nif (lcdMap[i].type != '.')\r\ncontinue;\r\nret += sprintf(&buf[ret], "%s %s\n",\r\nyld->lcdMap[i] == ' ' ? " " : "on",\r\nlcdMap[i].u.p.name);\r\n}\r\nup_read(&sysfs_rwsema);\r\nreturn ret;\r\n}\r\nstatic ssize_t set_icon(struct device *dev, const char *buf, size_t count,\r\nint chr)\r\n{\r\nstruct yealink_dev *yld;\r\nint i;\r\ndown_write(&sysfs_rwsema);\r\nyld = dev_get_drvdata(dev);\r\nif (yld == NULL) {\r\nup_write(&sysfs_rwsema);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(lcdMap); i++) {\r\nif (lcdMap[i].type != '.')\r\ncontinue;\r\nif (strncmp(buf, lcdMap[i].u.p.name, count) == 0) {\r\nsetChar(yld, i, chr);\r\nbreak;\r\n}\r\n}\r\nup_write(&sysfs_rwsema);\r\nreturn count;\r\n}\r\nstatic ssize_t show_icon(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn set_icon(dev, buf, count, buf[0]);\r\n}\r\nstatic ssize_t hide_icon(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn set_icon(dev, buf, count, ' ');\r\n}\r\nstatic ssize_t store_ringtone(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct yealink_dev *yld;\r\ndown_write(&sysfs_rwsema);\r\nyld = dev_get_drvdata(dev);\r\nif (yld == NULL) {\r\nup_write(&sysfs_rwsema);\r\nreturn -ENODEV;\r\n}\r\nyealink_set_ringtone(yld, (char *)buf, count);\r\nup_write(&sysfs_rwsema);\r\nreturn count;\r\n}\r\nstatic int usb_cleanup(struct yealink_dev *yld, int err)\r\n{\r\nif (yld == NULL)\r\nreturn err;\r\nif (yld->idev) {\r\nif (err)\r\ninput_free_device(yld->idev);\r\nelse\r\ninput_unregister_device(yld->idev);\r\n}\r\nusb_free_urb(yld->urb_irq);\r\nusb_free_urb(yld->urb_ctl);\r\nkfree(yld->ctl_req);\r\nusb_free_coherent(yld->udev, USB_PKT_LEN, yld->ctl_data, yld->ctl_dma);\r\nusb_free_coherent(yld->udev, USB_PKT_LEN, yld->irq_data, yld->irq_dma);\r\nkfree(yld);\r\nreturn err;\r\n}\r\nstatic void usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct yealink_dev *yld;\r\ndown_write(&sysfs_rwsema);\r\nyld = usb_get_intfdata(intf);\r\nsysfs_remove_group(&intf->dev.kobj, &yld_attr_group);\r\nusb_set_intfdata(intf, NULL);\r\nup_write(&sysfs_rwsema);\r\nusb_cleanup(yld, 0);\r\n}\r\nstatic int usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev (intf);\r\nstruct driver_info *nfo = (struct driver_info *)id->driver_info;\r\nstruct usb_host_interface *interface;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct yealink_dev *yld;\r\nstruct input_dev *input_dev;\r\nint ret, pipe, i;\r\ninterface = intf->cur_altsetting;\r\nendpoint = &interface->endpoint[0].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\nreturn -ENODEV;\r\nyld = kzalloc(sizeof(struct yealink_dev), GFP_KERNEL);\r\nif (!yld)\r\nreturn -ENOMEM;\r\nyld->udev = udev;\r\nyld->idev = input_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn usb_cleanup(yld, -ENOMEM);\r\nyld->irq_data = usb_alloc_coherent(udev, USB_PKT_LEN,\r\nGFP_ATOMIC, &yld->irq_dma);\r\nif (yld->irq_data == NULL)\r\nreturn usb_cleanup(yld, -ENOMEM);\r\nyld->ctl_data = usb_alloc_coherent(udev, USB_PKT_LEN,\r\nGFP_ATOMIC, &yld->ctl_dma);\r\nif (!yld->ctl_data)\r\nreturn usb_cleanup(yld, -ENOMEM);\r\nyld->ctl_req = kmalloc(sizeof(*(yld->ctl_req)), GFP_KERNEL);\r\nif (yld->ctl_req == NULL)\r\nreturn usb_cleanup(yld, -ENOMEM);\r\nyld->urb_irq = usb_alloc_urb(0, GFP_KERNEL);\r\nif (yld->urb_irq == NULL)\r\nreturn usb_cleanup(yld, -ENOMEM);\r\nyld->urb_ctl = usb_alloc_urb(0, GFP_KERNEL);\r\nif (yld->urb_ctl == NULL)\r\nreturn usb_cleanup(yld, -ENOMEM);\r\npipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\r\nret = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nif (ret != USB_PKT_LEN)\r\nerr("invalid payload size %d, expected %zd", ret, USB_PKT_LEN);\r\nusb_fill_int_urb(yld->urb_irq, udev, pipe, yld->irq_data,\r\nUSB_PKT_LEN,\r\nurb_irq_callback,\r\nyld, endpoint->bInterval);\r\nyld->urb_irq->transfer_dma = yld->irq_dma;\r\nyld->urb_irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nyld->urb_irq->dev = udev;\r\nyld->ctl_req->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE |\r\nUSB_DIR_OUT;\r\nyld->ctl_req->bRequest = USB_REQ_SET_CONFIGURATION;\r\nyld->ctl_req->wValue = cpu_to_le16(0x200);\r\nyld->ctl_req->wIndex = cpu_to_le16(interface->desc.bInterfaceNumber);\r\nyld->ctl_req->wLength = cpu_to_le16(USB_PKT_LEN);\r\nusb_fill_control_urb(yld->urb_ctl, udev, usb_sndctrlpipe(udev, 0),\r\n(void *)yld->ctl_req, yld->ctl_data, USB_PKT_LEN,\r\nurb_ctl_callback, yld);\r\nyld->urb_ctl->transfer_dma = yld->ctl_dma;\r\nyld->urb_ctl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nyld->urb_ctl->dev = udev;\r\nusb_make_path(udev, yld->phys, sizeof(yld->phys));\r\nstrlcat(yld->phys, "/input0", sizeof(yld->phys));\r\ninput_dev->name = nfo->name;\r\ninput_dev->phys = yld->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &intf->dev;\r\ninput_set_drvdata(input_dev, yld);\r\ninput_dev->open = input_open;\r\ninput_dev->close = input_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY);\r\nfor (i = 0; i < 256; i++) {\r\nint k = map_p1k_to_key(i);\r\nif (k >= 0) {\r\nset_bit(k & 0xff, input_dev->keybit);\r\nif (k >> 8)\r\nset_bit(k >> 8, input_dev->keybit);\r\n}\r\n}\r\nret = input_register_device(yld->idev);\r\nif (ret)\r\nreturn usb_cleanup(yld, ret);\r\nusb_set_intfdata(intf, yld);\r\nfor (i = 0; i < ARRAY_SIZE(lcdMap); i++)\r\nsetChar(yld, i, ' ');\r\nstore_line3(&intf->dev, NULL,\r\nDRIVER_VERSION, sizeof(DRIVER_VERSION));\r\nret = sysfs_create_group(&intf->dev.kobj, &yld_attr_group);\r\nreturn 0;\r\n}\r\nstatic int __init yealink_dev_init(void)\r\n{\r\nint ret = usb_register(&yealink_driver);\r\nif (ret == 0)\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nreturn ret;\r\n}\r\nstatic void __exit yealink_dev_exit(void)\r\n{\r\nusb_deregister(&yealink_driver);\r\n}
