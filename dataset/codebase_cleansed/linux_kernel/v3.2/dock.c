static int\r\nadd_dock_dependent_device(struct dock_station *ds, acpi_handle handle)\r\n{\r\nstruct dock_dependent_device *dd;\r\ndd = kzalloc(sizeof(*dd), GFP_KERNEL);\r\nif (!dd)\r\nreturn -ENOMEM;\r\ndd->handle = handle;\r\nINIT_LIST_HEAD(&dd->list);\r\nINIT_LIST_HEAD(&dd->hotplug_list);\r\nspin_lock(&ds->dd_lock);\r\nlist_add_tail(&dd->list, &ds->dependent_devices);\r\nspin_unlock(&ds->dd_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\ndock_add_hotplug_device(struct dock_station *ds,\r\nstruct dock_dependent_device *dd)\r\n{\r\nmutex_lock(&ds->hp_lock);\r\nlist_add_tail(&dd->hotplug_list, &ds->hotplug_devices);\r\nmutex_unlock(&ds->hp_lock);\r\n}\r\nstatic void\r\ndock_del_hotplug_device(struct dock_station *ds,\r\nstruct dock_dependent_device *dd)\r\n{\r\nmutex_lock(&ds->hp_lock);\r\nlist_del(&dd->hotplug_list);\r\nmutex_unlock(&ds->hp_lock);\r\n}\r\nstatic struct dock_dependent_device *\r\nfind_dock_dependent_device(struct dock_station *ds, acpi_handle handle)\r\n{\r\nstruct dock_dependent_device *dd;\r\nspin_lock(&ds->dd_lock);\r\nlist_for_each_entry(dd, &ds->dependent_devices, list) {\r\nif (handle == dd->handle) {\r\nspin_unlock(&ds->dd_lock);\r\nreturn dd;\r\n}\r\n}\r\nspin_unlock(&ds->dd_lock);\r\nreturn NULL;\r\n}\r\nstatic int is_dock(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nacpi_handle tmp;\r\nstatus = acpi_get_handle(handle, "_DCK", &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int is_ejectable(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nacpi_handle tmp;\r\nstatus = acpi_get_handle(handle, "_EJ0", &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int is_ata(acpi_handle handle)\r\n{\r\nacpi_handle tmp;\r\nif ((ACPI_SUCCESS(acpi_get_handle(handle, "_GTF", &tmp))) ||\r\n(ACPI_SUCCESS(acpi_get_handle(handle, "_GTM", &tmp))) ||\r\n(ACPI_SUCCESS(acpi_get_handle(handle, "_STM", &tmp))) ||\r\n(ACPI_SUCCESS(acpi_get_handle(handle, "_SDD", &tmp))))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int is_battery(acpi_handle handle)\r\n{\r\nstruct acpi_device_info *info;\r\nint ret = 1;\r\nif (!ACPI_SUCCESS(acpi_get_object_info(handle, &info)))\r\nreturn 0;\r\nif (!(info->valid & ACPI_VALID_HID))\r\nret = 0;\r\nelse\r\nret = !strcmp("PNP0C0A", info->hardware_id.string);\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int is_ejectable_bay(acpi_handle handle)\r\n{\r\nacpi_handle phandle;\r\nif (!is_ejectable(handle))\r\nreturn 0;\r\nif (is_battery(handle) || is_ata(handle))\r\nreturn 1;\r\nif (!acpi_get_parent(handle, &phandle) && is_ata(phandle))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint is_dock_device(acpi_handle handle)\r\n{\r\nstruct dock_station *dock_station;\r\nif (!dock_station_count)\r\nreturn 0;\r\nif (is_dock(handle))\r\nreturn 1;\r\nlist_for_each_entry(dock_station, &dock_stations, sibling)\r\nif (find_dock_dependent_device(dock_station, handle))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int dock_present(struct dock_station *ds)\r\n{\r\nunsigned long long sta;\r\nacpi_status status;\r\nif (ds) {\r\nstatus = acpi_evaluate_integer(ds->handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && sta)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct acpi_device * dock_create_acpi_device(acpi_handle handle)\r\n{\r\nstruct acpi_device *device;\r\nstruct acpi_device *parent_device;\r\nacpi_handle parent;\r\nint ret;\r\nif (acpi_bus_get_device(handle, &device)) {\r\nacpi_get_parent(handle, &parent);\r\nif (acpi_bus_get_device(parent, &parent_device))\r\nparent_device = NULL;\r\nret = acpi_bus_add(&device, parent_device, handle,\r\nACPI_BUS_TYPE_DEVICE);\r\nif (ret) {\r\npr_debug("error adding bus, %x\n", -ret);\r\nreturn NULL;\r\n}\r\n}\r\nreturn device;\r\n}\r\nstatic void dock_remove_acpi_device(acpi_handle handle)\r\n{\r\nstruct acpi_device *device;\r\nint ret;\r\nif (!acpi_bus_get_device(handle, &device)) {\r\nret = acpi_bus_trim(device, 1);\r\nif (ret)\r\npr_debug("error removing bus, %x\n", -ret);\r\n}\r\n}\r\nstatic void hotplug_dock_devices(struct dock_station *ds, u32 event)\r\n{\r\nstruct dock_dependent_device *dd;\r\nmutex_lock(&ds->hp_lock);\r\nlist_for_each_entry(dd, &ds->hotplug_devices, hotplug_list)\r\nif (dd->ops && dd->ops->handler)\r\ndd->ops->handler(dd->handle, event, dd->context);\r\nlist_for_each_entry(dd, &ds->dependent_devices, list) {\r\nif (event == ACPI_NOTIFY_EJECT_REQUEST)\r\ndock_remove_acpi_device(dd->handle);\r\nelse\r\ndock_create_acpi_device(dd->handle);\r\n}\r\nmutex_unlock(&ds->hp_lock);\r\n}\r\nstatic void dock_event(struct dock_station *ds, u32 event, int num)\r\n{\r\nstruct device *dev = &ds->dock_device->dev;\r\nchar event_string[13];\r\nchar *envp[] = { event_string, NULL };\r\nstruct dock_dependent_device *dd;\r\nif (num == UNDOCK_EVENT)\r\nsprintf(event_string, "EVENT=undock");\r\nelse\r\nsprintf(event_string, "EVENT=dock");\r\nif (num == DOCK_EVENT)\r\nkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\r\nlist_for_each_entry(dd, &ds->hotplug_devices, hotplug_list)\r\nif (dd->ops && dd->ops->uevent)\r\ndd->ops->uevent(dd->handle, event, dd->context);\r\nif (num != DOCK_EVENT)\r\nkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\r\n}\r\nstatic void eject_dock(struct dock_station *ds)\r\n{\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\nacpi_handle tmp;\r\nstatus = acpi_get_handle(ds->handle, "_EJ0", &tmp);\r\nif (ACPI_FAILURE(status)) {\r\npr_debug("No _EJ0 support for dock device\n");\r\nreturn;\r\n}\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = 1;\r\nstatus = acpi_evaluate_object(ds->handle, "_EJ0", &arg_list, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_debug("Failed to evaluate _EJ0!\n");\r\n}\r\nstatic void handle_dock(struct dock_station *ds, int dock)\r\n{\r\nacpi_status status;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer name_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(ds->handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_INFO PREFIX "%s - %s\n",\r\n(char *)name_buffer.pointer, dock ? "docking" : "undocking");\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = dock;\r\nstatus = acpi_evaluate_object(ds->handle, "_DCK", &arg_list, &buffer);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND)\r\nACPI_EXCEPTION((AE_INFO, status, "%s - failed to execute"\r\n" _DCK\n", (char *)name_buffer.pointer));\r\nkfree(buffer.pointer);\r\nkfree(name_buffer.pointer);\r\n}\r\nstatic inline void dock(struct dock_station *ds)\r\n{\r\nhandle_dock(ds, 1);\r\n}\r\nstatic inline void undock(struct dock_station *ds)\r\n{\r\nhandle_dock(ds, 0);\r\n}\r\nstatic inline void begin_dock(struct dock_station *ds)\r\n{\r\nds->flags |= DOCK_DOCKING;\r\n}\r\nstatic inline void complete_dock(struct dock_station *ds)\r\n{\r\nds->flags &= ~(DOCK_DOCKING);\r\nds->last_dock_time = jiffies;\r\n}\r\nstatic inline void begin_undock(struct dock_station *ds)\r\n{\r\nds->flags |= DOCK_UNDOCKING;\r\n}\r\nstatic inline void complete_undock(struct dock_station *ds)\r\n{\r\nds->flags &= ~(DOCK_UNDOCKING);\r\n}\r\nstatic void dock_lock(struct dock_station *ds, int lock)\r\n{\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = !!lock;\r\nstatus = acpi_evaluate_object(ds->handle, "_LCK", &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nif (lock)\r\nprintk(KERN_WARNING PREFIX "Locking device failed\n");\r\nelse\r\nprintk(KERN_WARNING PREFIX "Unlocking device failed\n");\r\n}\r\n}\r\nstatic int dock_in_progress(struct dock_station *ds)\r\n{\r\nif ((ds->flags & DOCK_DOCKING) ||\r\ntime_before(jiffies, (ds->last_dock_time + HZ)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint register_dock_notifier(struct notifier_block *nb)\r\n{\r\nif (!dock_station_count)\r\nreturn -ENODEV;\r\nreturn atomic_notifier_chain_register(&dock_notifier_list, nb);\r\n}\r\nvoid unregister_dock_notifier(struct notifier_block *nb)\r\n{\r\nif (!dock_station_count)\r\nreturn;\r\natomic_notifier_chain_unregister(&dock_notifier_list, nb);\r\n}\r\nint\r\nregister_hotplug_dock_device(acpi_handle handle, const struct acpi_dock_ops *ops,\r\nvoid *context)\r\n{\r\nstruct dock_dependent_device *dd;\r\nstruct dock_station *dock_station;\r\nint ret = -EINVAL;\r\nif (!dock_station_count)\r\nreturn -ENODEV;\r\nlist_for_each_entry(dock_station, &dock_stations, sibling) {\r\ndd = find_dock_dependent_device(dock_station, handle);\r\nif (dd) {\r\ndd->ops = ops;\r\ndd->context = context;\r\ndock_add_hotplug_device(dock_station, dd);\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid unregister_hotplug_dock_device(acpi_handle handle)\r\n{\r\nstruct dock_dependent_device *dd;\r\nstruct dock_station *dock_station;\r\nif (!dock_station_count)\r\nreturn;\r\nlist_for_each_entry(dock_station, &dock_stations, sibling) {\r\ndd = find_dock_dependent_device(dock_station, handle);\r\nif (dd)\r\ndock_del_hotplug_device(dock_station, dd);\r\n}\r\n}\r\nstatic int handle_eject_request(struct dock_station *ds, u32 event)\r\n{\r\nif (dock_in_progress(ds))\r\nreturn -EBUSY;\r\ndock_event(ds, event, UNDOCK_EVENT);\r\nhotplug_dock_devices(ds, ACPI_NOTIFY_EJECT_REQUEST);\r\nundock(ds);\r\ndock_lock(ds, 0);\r\neject_dock(ds);\r\nif (dock_present(ds)) {\r\nprintk(KERN_ERR PREFIX "Unable to undock!\n");\r\nreturn -EBUSY;\r\n}\r\ncomplete_undock(ds);\r\nreturn 0;\r\n}\r\nstatic void dock_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct dock_station *ds = data;\r\nstruct acpi_device *tmp;\r\nint surprise_removal = 0;\r\nif ((ds->flags & DOCK_IS_DOCK) && event == ACPI_NOTIFY_DEVICE_CHECK)\r\nevent = ACPI_NOTIFY_EJECT_REQUEST;\r\nswitch (event) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nif (!dock_in_progress(ds) && acpi_bus_get_device(ds->handle,\r\n&tmp)) {\r\nbegin_dock(ds);\r\ndock(ds);\r\nif (!dock_present(ds)) {\r\nprintk(KERN_ERR PREFIX "Unable to dock!\n");\r\ncomplete_dock(ds);\r\nbreak;\r\n}\r\natomic_notifier_call_chain(&dock_notifier_list,\r\nevent, NULL);\r\nhotplug_dock_devices(ds, event);\r\ncomplete_dock(ds);\r\ndock_event(ds, event, DOCK_EVENT);\r\ndock_lock(ds, 1);\r\nacpi_update_all_gpes();\r\nbreak;\r\n}\r\nif (dock_present(ds) || dock_in_progress(ds))\r\nbreak;\r\nsurprise_removal = 1;\r\nevent = ACPI_NOTIFY_EJECT_REQUEST;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nbegin_undock(ds);\r\nif ((immediate_undock && !(ds->flags & DOCK_IS_ATA))\r\n|| surprise_removal)\r\nhandle_eject_request(ds, event);\r\nelse\r\ndock_event(ds, event, UNDOCK_EVENT);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PREFIX "Unknown dock event %d\n", event);\r\n}\r\n}\r\nstatic void acpi_dock_deferred_cb(void *context)\r\n{\r\nstruct dock_data *data = context;\r\ndock_notify(data->handle, data->event, data->ds);\r\nkfree(data);\r\n}\r\nstatic int acpi_dock_notifier_call(struct notifier_block *this,\r\nunsigned long event, void *data)\r\n{\r\nstruct dock_station *dock_station;\r\nacpi_handle handle = data;\r\nif (event != ACPI_NOTIFY_BUS_CHECK && event != ACPI_NOTIFY_DEVICE_CHECK\r\n&& event != ACPI_NOTIFY_EJECT_REQUEST)\r\nreturn 0;\r\nlist_for_each_entry(dock_station, &dock_stations, sibling) {\r\nif (dock_station->handle == handle) {\r\nstruct dock_data *dd;\r\ndd = kmalloc(sizeof(*dd), GFP_KERNEL);\r\nif (!dd)\r\nreturn 0;\r\ndd->handle = handle;\r\ndd->event = event;\r\ndd->ds = dock_station;\r\nacpi_os_hotplug_execute(acpi_dock_deferred_cb, dd);\r\nreturn 0 ;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic acpi_status\r\nfind_dock_devices(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nacpi_status status;\r\nacpi_handle tmp, parent;\r\nstruct dock_station *ds = context;\r\nstatus = acpi_bus_get_ejd(handle, &tmp);\r\nif (ACPI_FAILURE(status)) {\r\nstatus = acpi_get_parent(handle, &parent);\r\nif (ACPI_FAILURE(status))\r\ngoto fdd_out;\r\nstatus = acpi_bus_get_ejd(parent, &tmp);\r\nif (ACPI_FAILURE(status))\r\ngoto fdd_out;\r\n}\r\nif (tmp == ds->handle)\r\nadd_dock_dependent_device(ds, handle);\r\nfdd_out:\r\nreturn AE_OK;\r\n}\r\nstatic ssize_t show_docked(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct acpi_device *tmp;\r\nstruct dock_station *dock_station = dev->platform_data;\r\nif (ACPI_SUCCESS(acpi_bus_get_device(dock_station->handle, &tmp)))\r\nreturn snprintf(buf, PAGE_SIZE, "1\n");\r\nreturn snprintf(buf, PAGE_SIZE, "0\n");\r\n}\r\nstatic ssize_t show_flags(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dock_station *dock_station = dev->platform_data;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", dock_station->flags);\r\n}\r\nstatic ssize_t write_undock(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nstruct dock_station *dock_station = dev->platform_data;\r\nif (!count)\r\nreturn -EINVAL;\r\nbegin_undock(dock_station);\r\nret = handle_eject_request(dock_station, ACPI_NOTIFY_EJECT_REQUEST);\r\nreturn ret ? ret: count;\r\n}\r\nstatic ssize_t show_dock_uid(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long long lbuf;\r\nstruct dock_station *dock_station = dev->platform_data;\r\nacpi_status status = acpi_evaluate_integer(dock_station->handle,\r\n"_UID", NULL, &lbuf);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%llx\n", lbuf);\r\n}\r\nstatic ssize_t show_dock_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dock_station *dock_station = dev->platform_data;\r\nchar *type;\r\nif (dock_station->flags & DOCK_IS_DOCK)\r\ntype = "dock_station";\r\nelse if (dock_station->flags & DOCK_IS_ATA)\r\ntype = "ata_bay";\r\nelse if (dock_station->flags & DOCK_IS_BAT)\r\ntype = "battery_bay";\r\nelse\r\ntype = "unknown";\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", type);\r\n}\r\nstatic int __init dock_add(acpi_handle handle)\r\n{\r\nint ret, id;\r\nstruct dock_station ds, *dock_station;\r\nstruct platform_device *dd;\r\nid = dock_station_count;\r\nmemset(&ds, 0, sizeof(ds));\r\ndd = platform_device_register_data(NULL, "dock", id, &ds, sizeof(ds));\r\nif (IS_ERR(dd))\r\nreturn PTR_ERR(dd);\r\ndock_station = dd->dev.platform_data;\r\ndock_station->handle = handle;\r\ndock_station->dock_device = dd;\r\ndock_station->last_dock_time = jiffies - HZ;\r\nmutex_init(&dock_station->hp_lock);\r\nspin_lock_init(&dock_station->dd_lock);\r\nINIT_LIST_HEAD(&dock_station->sibling);\r\nINIT_LIST_HEAD(&dock_station->hotplug_devices);\r\nATOMIC_INIT_NOTIFIER_HEAD(&dock_notifier_list);\r\nINIT_LIST_HEAD(&dock_station->dependent_devices);\r\ndev_set_uevent_suppress(&dd->dev, 0);\r\nif (is_dock(handle))\r\ndock_station->flags |= DOCK_IS_DOCK;\r\nif (is_ata(handle))\r\ndock_station->flags |= DOCK_IS_ATA;\r\nif (is_battery(handle))\r\ndock_station->flags |= DOCK_IS_BAT;\r\nret = sysfs_create_group(&dd->dev.kobj, &dock_attribute_group);\r\nif (ret)\r\ngoto err_unregister;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, find_dock_devices, NULL,\r\ndock_station, NULL);\r\nret = add_dock_dependent_device(dock_station, handle);\r\nif (ret)\r\ngoto err_rmgroup;\r\ndock_station_count++;\r\nlist_add(&dock_station->sibling, &dock_stations);\r\nreturn 0;\r\nerr_rmgroup:\r\nsysfs_remove_group(&dd->dev.kobj, &dock_attribute_group);\r\nerr_unregister:\r\nplatform_device_unregister(dd);\r\nprintk(KERN_ERR "%s encountered error %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dock_remove(struct dock_station *ds)\r\n{\r\nstruct dock_dependent_device *dd, *tmp;\r\nstruct platform_device *dock_device = ds->dock_device;\r\nif (!dock_station_count)\r\nreturn 0;\r\nlist_for_each_entry_safe(dd, tmp, &ds->dependent_devices, list)\r\nkfree(dd);\r\nlist_del(&ds->sibling);\r\nsysfs_remove_group(&dock_device->dev.kobj, &dock_attribute_group);\r\nplatform_device_unregister(dock_device);\r\nreturn 0;\r\n}\r\nstatic __init acpi_status\r\nfind_dock(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nif (is_dock(handle))\r\ndock_add(handle);\r\nreturn AE_OK;\r\n}\r\nstatic __init acpi_status\r\nfind_bay(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nif (is_ejectable_bay(handle) && !is_dock(handle))\r\ndock_add(handle);\r\nreturn AE_OK;\r\n}\r\nstatic int __init dock_init(void)\r\n{\r\nif (acpi_disabled)\r\nreturn 0;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, find_dock, NULL, NULL, NULL);\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, find_bay, NULL, NULL, NULL);\r\nif (!dock_station_count) {\r\nprintk(KERN_INFO PREFIX "No dock devices found.\n");\r\nreturn 0;\r\n}\r\nregister_acpi_bus_notifier(&dock_acpi_notifier);\r\nprintk(KERN_INFO PREFIX "%s: %d docks/bays found\n",\r\nACPI_DOCK_DRIVER_DESCRIPTION, dock_station_count);\r\nreturn 0;\r\n}\r\nstatic void __exit dock_exit(void)\r\n{\r\nstruct dock_station *tmp, *dock_station;\r\nunregister_acpi_bus_notifier(&dock_acpi_notifier);\r\nlist_for_each_entry_safe(dock_station, tmp, &dock_stations, sibling)\r\ndock_remove(dock_station);\r\n}
