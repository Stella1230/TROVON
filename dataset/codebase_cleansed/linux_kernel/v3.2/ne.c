static int __init do_ne_probe(struct net_device *dev)\r\n{\r\nunsigned long base_addr = dev->base_addr;\r\n#ifdef NEEDS_PORTLIST\r\nint orig_irq = dev->irq;\r\n#endif\r\nif (base_addr > 0x1ff) {\r\nint ret = ne_probe1(dev, base_addr);\r\nif (ret)\r\nprintk(KERN_WARNING "ne.c: No NE*000 card found at "\r\n"i/o = %#lx\n", base_addr);\r\nreturn ret;\r\n}\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nif (isapnp_present() && (ne_probe_isapnp(dev) == 0))\r\nreturn 0;\r\n#ifdef NEEDS_PORTLIST\r\nfor (base_addr = 0; netcard_portlist[base_addr] != 0; base_addr++) {\r\nint ioaddr = netcard_portlist[base_addr];\r\ndev->irq = orig_irq;\r\nif (ne_probe1(dev, ioaddr) == 0)\r\nreturn 0;\r\n}\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nstatic int __init ne_probe_isapnp(struct net_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; isapnp_clone_list[i].vendor != 0; i++) {\r\nstruct pnp_dev *idev = NULL;\r\nwhile ((idev = pnp_find_dev(NULL,\r\nisapnp_clone_list[i].vendor,\r\nisapnp_clone_list[i].function,\r\nidev))) {\r\nif (pnp_device_attach(idev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(idev) < 0) {\r\npnp_device_detach(idev);\r\ncontinue;\r\n}\r\nif (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0)) {\r\npnp_device_detach(idev);\r\ncontinue;\r\n}\r\ndev->base_addr = pnp_port_start(idev, 0);\r\ndev->irq = pnp_irq(idev, 0);\r\nprintk(KERN_INFO "ne.c: ISAPnP reports %s at i/o %#lx, irq %d.\n",\r\n(char *) isapnp_clone_list[i].driver_data,\r\ndev->base_addr, dev->irq);\r\nif (ne_probe1(dev, dev->base_addr) != 0) {\r\nprintk(KERN_ERR "ne.c: Probe of ISAPnP card at %#lx failed.\n", dev->base_addr);\r\npnp_device_detach(idev);\r\nreturn -ENXIO;\r\n}\r\nei_status.priv = (unsigned long)idev;\r\nbreak;\r\n}\r\nif (!idev)\r\ncontinue;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init ne_probe1(struct net_device *dev, unsigned long ioaddr)\r\n{\r\nint i;\r\nunsigned char SA_prom[32];\r\nint wordlength = 2;\r\nconst char *name = NULL;\r\nint start_page, stop_page;\r\nint neX000, ctron, copam, bad_card;\r\nint reg0, ret;\r\nstatic unsigned version_printed;\r\nif (!request_region(ioaddr, NE_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\nreg0 = inb_p(ioaddr);\r\nif (reg0 == 0xFF) {\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\n{\r\nint regd;\r\noutb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);\r\nregd = inb_p(ioaddr + 0x0d);\r\noutb_p(0xff, ioaddr + 0x0d);\r\noutb_p(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);\r\ninb_p(ioaddr + EN0_COUNTER0);\r\nif (inb_p(ioaddr + EN0_COUNTER0) != 0) {\r\noutb_p(reg0, ioaddr);\r\noutb_p(regd, ioaddr + 0x0d);\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\n}\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(KERN_INFO "%s%s", version1, version2);\r\nprintk(KERN_INFO "NE*000 ethercard probe at %#3lx:", ioaddr);\r\nbad_card = ((dev->base_addr != 0) && (dev->mem_end == BAD));\r\n{\r\nunsigned long reset_start_time = jiffies;\r\noutb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);\r\nwhile ((inb_p(ioaddr + EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\r\nif (bad_card) {\r\nprintk(" (warning: no reset ack)");\r\nbreak;\r\n} else {\r\nprintk(" not found (no reset ack).\n");\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\n}\r\noutb_p(0xff, ioaddr + EN0_ISR);\r\n}\r\n{\r\nstruct {unsigned char value, offset; } program_seq[] =\r\n{\r\n{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},\r\n{0x48, EN0_DCFG},\r\n{0x00, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_IMR},\r\n{0xFF, EN0_ISR},\r\n{E8390_RXOFF, EN0_RXCR},\r\n{E8390_TXOFF, EN0_TXCR},\r\n{32, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_RSARLO},\r\n{0x00, EN0_RSARHI},\r\n{E8390_RREAD+E8390_START, E8390_CMD},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\r\noutb_p(program_seq[i].value, ioaddr + program_seq[i].offset);\r\n}\r\nfor(i = 0; i < 32 ; i+=2) {\r\nSA_prom[i] = inb(ioaddr + NE_DATAPORT);\r\nSA_prom[i+1] = inb(ioaddr + NE_DATAPORT);\r\nif (SA_prom[i] != SA_prom[i+1])\r\nwordlength = 1;\r\n}\r\nif (wordlength == 2)\r\n{\r\nfor (i = 0; i < 16; i++)\r\nSA_prom[i] = SA_prom[i+i];\r\noutb_p(DCR_VAL, ioaddr + EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nif ((DCR_VAL & 0x01) == 0 &&\r\ninb(ioaddr + EN0_RCNTLO) == 0x50 &&\r\ninb(ioaddr + EN0_RCNTHI) == 0x70)\r\nstop_page = 0x60;\r\nelse\r\nstop_page = NESM_STOP_PG;\r\n} else {\r\nstart_page = NE1SM_START_PG;\r\nstop_page = NE1SM_STOP_PG;\r\n}\r\n#if defined(CONFIG_PLAT_MAPPI) || defined(CONFIG_PLAT_OAKS32R)\r\nneX000 = ((SA_prom[14] == 0x57 && SA_prom[15] == 0x57)\r\n|| (SA_prom[14] == 0x42 && SA_prom[15] == 0x42));\r\n#else\r\nneX000 = (SA_prom[14] == 0x57 && SA_prom[15] == 0x57);\r\n#endif\r\nctron = (SA_prom[0] == 0x00 && SA_prom[1] == 0x00 && SA_prom[2] == 0x1d);\r\ncopam = (SA_prom[14] == 0x49 && SA_prom[15] == 0x00);\r\nif (neX000 || bad_card || copam) {\r\nname = (wordlength == 2) ? "NE2000" : "NE1000";\r\n}\r\nelse if (ctron)\r\n{\r\nname = (wordlength == 2) ? "Ctron-8" : "Ctron-16";\r\nstart_page = 0x01;\r\nstop_page = (wordlength == 2) ? 0x40 : 0x20;\r\n}\r\nelse\r\n{\r\n#ifdef SUPPORT_NE_BAD_CLONES\r\nfor (i = 0; bad_clone_list[i].name8; i++)\r\n{\r\nif (SA_prom[0] == bad_clone_list[i].SAprefix[0] &&\r\nSA_prom[1] == bad_clone_list[i].SAprefix[1] &&\r\nSA_prom[2] == bad_clone_list[i].SAprefix[2])\r\n{\r\nif (wordlength == 2)\r\n{\r\nname = bad_clone_list[i].name16;\r\n} else {\r\nname = bad_clone_list[i].name8;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (bad_clone_list[i].name8 == NULL)\r\n{\r\nprintk(" not found (invalid signature %2.2x %2.2x).\n",\r\nSA_prom[14], SA_prom[15]);\r\nret = -ENXIO;\r\ngoto err_out;\r\n}\r\n#else\r\nprintk(" not found.\n");\r\nret = -ENXIO;\r\ngoto err_out;\r\n#endif\r\n}\r\nif (dev->irq < 2)\r\n{\r\nunsigned long cookie = probe_irq_on();\r\noutb_p(0x50, ioaddr + EN0_IMR);\r\noutb_p(0x00, ioaddr + EN0_RCNTLO);\r\noutb_p(0x00, ioaddr + EN0_RCNTHI);\r\noutb_p(E8390_RREAD+E8390_START, ioaddr);\r\nmdelay(10);\r\noutb_p(0x00, ioaddr + EN0_IMR);\r\ndev->irq = probe_irq_off(cookie);\r\nif (ei_debug > 2)\r\nprintk(" autoirq is %d\n", dev->irq);\r\n} else if (dev->irq == 2)\r\ndev->irq = 9;\r\nif (! dev->irq) {\r\nprintk(" failed to detect IRQ line.\n");\r\nret = -EAGAIN;\r\ngoto err_out;\r\n}\r\nret = request_irq(dev->irq, eip_interrupt, 0, name, dev);\r\nif (ret) {\r\nprintk (" unable to get IRQ %d (errno=%d).\n", dev->irq, ret);\r\ngoto err_out;\r\n}\r\ndev->base_addr = ioaddr;\r\n#ifdef CONFIG_PLAT_MAPPI\r\noutb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP,\r\nioaddr + E8390_CMD);\r\nfor (i = 0 ; i < ETHER_ADDR_LEN ; i++) {\r\ndev->dev_addr[i] = SA_prom[i]\r\n= inb_p(ioaddr + EN1_PHYS_SHIFT(i));\r\n}\r\n#else\r\nfor(i = 0; i < ETHER_ADDR_LEN; i++) {\r\ndev->dev_addr[i] = SA_prom[i];\r\n}\r\n#endif\r\nprintk("%pM\n", dev->dev_addr);\r\nei_status.name = name;\r\nei_status.tx_start_page = start_page;\r\nei_status.stop_page = stop_page;\r\nei_status.word16 = (wordlength == 2 && (DCR_VAL & 0x01));\r\nei_status.rx_start_page = start_page + TX_PAGES;\r\n#ifdef PACKETBUF_MEMSIZE\r\nei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;\r\n#endif\r\nei_status.reset_8390 = &ne_reset_8390;\r\nei_status.block_input = &ne_block_input;\r\nei_status.block_output = &ne_block_output;\r\nei_status.get_8390_hdr = &ne_get_8390_hdr;\r\nei_status.priv = 0;\r\ndev->netdev_ops = &eip_netdev_ops;\r\nNS8390p_init(dev, 0);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto out_irq;\r\nprintk(KERN_INFO "%s: %s found at %#lx, using IRQ %d.\n",\r\ndev->name, name, ioaddr, dev->irq);\r\nreturn 0;\r\nout_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_out:\r\nrelease_region(ioaddr, NE_IO_EXTENT);\r\nreturn ret;\r\n}\r\nstatic void ne_reset_8390(struct net_device *dev)\r\n{\r\nunsigned long reset_start_time = jiffies;\r\nif (ei_debug > 1)\r\nprintk(KERN_DEBUG "resetting the 8390 t=%ld...", jiffies);\r\noutb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\r\nei_status.txing = 0;\r\nei_status.dmaing = 0;\r\nwhile ((inb_p(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\r\nprintk(KERN_WARNING "%s: ne_reset_8390() did not complete.\n", dev->name);\r\nbreak;\r\n}\r\noutb_p(ENISR_RESET, NE_BASE + EN0_ISR);\r\n}\r\nstatic void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint nic_base = dev->base_addr;\r\nif (ei_status.dmaing)\r\n{\r\nprintk(KERN_EMERG "%s: DMAing conflict in ne_get_8390_hdr "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\r\noutb_p(0, nic_base + EN0_RCNTHI);\r\noutb_p(0, nic_base + EN0_RSARLO);\r\noutb_p(ring_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16)\r\ninsw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);\r\nelse\r\ninsb(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\nle16_to_cpus(&hdr->count);\r\n}\r\nstatic void ne_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\n#ifdef NE_SANITY_CHECK\r\nint xfer_count = count;\r\n#endif\r\nint nic_base = dev->base_addr;\r\nchar *buf = skb->data;\r\nif (ei_status.dmaing)\r\n{\r\nprintk(KERN_EMERG "%s: DMAing conflict in ne_block_input "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\r\noutb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16)\r\n{\r\ninsw(NE_BASE + NE_DATAPORT,buf,count>>1);\r\nif (count & 0x01)\r\n{\r\nbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\r\n#ifdef NE_SANITY_CHECK\r\nxfer_count++;\r\n#endif\r\n}\r\n} else {\r\ninsb(NE_BASE + NE_DATAPORT, buf, count);\r\n}\r\n#ifdef NE_SANITY_CHECK\r\nif (ei_debug > 1)\r\n{\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif (((ring_offset + xfer_count) & 0xff) == low)\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0)\r\nprintk(KERN_WARNING "%s: RX transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\ndev->name, ring_offset + xfer_count, addr);\r\n}\r\n#endif\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void ne_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, const int start_page)\r\n{\r\nint nic_base = NE_BASE;\r\nunsigned long dma_start;\r\n#ifdef NE_SANITY_CHECK\r\nint retries = 0;\r\n#endif\r\nif (ei_status.word16 && (count & 0x01))\r\ncount++;\r\nif (ei_status.dmaing)\r\n{\r\nprintk(KERN_EMERG "%s: DMAing conflict in ne_block_output."\r\n"[DMAstat:%d][irqlock:%d]\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\r\n#ifdef NE_SANITY_CHECK\r\nretry:\r\n#endif\r\n#ifdef NE8390_RW_BUGFIX\r\noutb_p(0x42, nic_base + EN0_RCNTLO);\r\noutb_p(0x00, nic_base + EN0_RCNTHI);\r\noutb_p(0x42, nic_base + EN0_RSARLO);\r\noutb_p(0x00, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nudelay(6);\r\n#endif\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\noutb_p(count & 0xff, nic_base + EN0_RCNTLO);\r\noutb_p(count >> 8, nic_base + EN0_RCNTHI);\r\noutb_p(0x00, nic_base + EN0_RSARLO);\r\noutb_p(start_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16) {\r\noutsw(NE_BASE + NE_DATAPORT, buf, count>>1);\r\n} else {\r\noutsb(NE_BASE + NE_DATAPORT, buf, count);\r\n}\r\ndma_start = jiffies;\r\n#ifdef NE_SANITY_CHECK\r\nif (ei_debug > 1)\r\n{\r\nint addr, tries = 20;\r\ndo {\r\nint high = inb_p(nic_base + EN0_RSARHI);\r\nint low = inb_p(nic_base + EN0_RSARLO);\r\naddr = (high << 8) + low;\r\nif ((start_page << 8) + count == addr)\r\nbreak;\r\n} while (--tries > 0);\r\nif (tries <= 0)\r\n{\r\nprintk(KERN_WARNING "%s: Tx packet transfer address mismatch,"\r\n"%#4.4x (expected) vs. %#4.4x (actual).\n",\r\ndev->name, (start_page << 8) + count, addr);\r\nif (retries++ == 0)\r\ngoto retry;\r\n}\r\n}\r\n#endif\r\nwhile ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)\r\nif (time_after(jiffies, dma_start + 2*HZ/100)) {\r\nprintk(KERN_WARNING "%s: timeout waiting for Tx RDC.\n", dev->name);\r\nne_reset_8390(dev);\r\nNS8390p_init(dev, 1);\r\nbreak;\r\n}\r\noutb_p(ENISR_RDC, nic_base + EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic int __init ne_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nint err, this_dev = pdev->id;\r\nstruct resource *res;\r\ndev = alloc_eip_netdev();\r\nif (!dev)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res) {\r\ndev->base_addr = res->start;\r\ndev->irq = platform_get_irq(pdev, 0);\r\n} else {\r\nif (this_dev < 0 || this_dev >= MAX_NE_CARDS) {\r\nfree_netdev(dev);\r\nreturn -EINVAL;\r\n}\r\ndev->base_addr = io[this_dev];\r\ndev->irq = irq[this_dev];\r\ndev->mem_end = bad[this_dev];\r\n}\r\nerr = do_ne_probe(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nif (!res) {\r\nio[this_dev] = dev->base_addr;\r\nirq[this_dev] = dev->irq;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ne_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nif (dev) {\r\nstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\r\nnetif_device_detach(dev);\r\nunregister_netdev(dev);\r\nif (idev)\r\npnp_device_detach(idev);\r\nei_status.priv = 0;\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, NE_IO_EXTENT);\r\nfree_netdev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ne_loop_rm_unreg(int all)\r\n{\r\nint this_dev;\r\nstruct platform_device *pdev;\r\nfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\r\npdev = pdev_ne[this_dev];\r\nif (pdev && (!platform_get_drvdata(pdev) || all)) {\r\nne_drv_remove(pdev);\r\nplatform_device_unregister(pdev);\r\npdev_ne[this_dev] = NULL;\r\n}\r\n}\r\n}\r\nstatic int ne_drv_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nif (netif_running(dev)) {\r\nstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\r\nnetif_device_detach(dev);\r\nif (idev)\r\npnp_stop_dev(idev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ne_drv_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nif (netif_running(dev)) {\r\nstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\r\nif (idev)\r\npnp_start_dev(idev);\r\nne_reset_8390(dev);\r\nNS8390p_init(dev, 1);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ne_add_devices(void)\r\n{\r\nint this_dev;\r\nstruct platform_device *pdev;\r\nfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\r\nif (pdev_ne[this_dev])\r\ncontinue;\r\npdev = platform_device_register_simple(\r\nDRV_NAME, this_dev, NULL, 0);\r\nif (IS_ERR(pdev))\r\ncontinue;\r\npdev_ne[this_dev] = pdev;\r\n}\r\n}\r\nint __init init_module(void)\r\n{\r\nint retval;\r\nne_add_devices();\r\nretval = platform_driver_probe(&ne_driver, ne_drv_probe);\r\nif (retval) {\r\nif (io[0] == 0)\r\nprintk(KERN_NOTICE "ne.c: You must supply \"io=0xNNN\""\r\n" value(s) for ISA cards.\n");\r\nne_loop_rm_unreg(1);\r\nreturn retval;\r\n}\r\nne_loop_rm_unreg(0);\r\nreturn retval;\r\n}\r\nstatic int __init ne_init(void)\r\n{\r\nint retval = platform_driver_probe(&ne_driver, ne_drv_probe);\r\nne_loop_rm_unreg(0);\r\nreturn retval;\r\n}\r\nstruct net_device * __init ne_probe(int unit)\r\n{\r\nint this_dev;\r\nstruct net_device *dev;\r\nthis_dev = 0;\r\nwhile ((pdev_ne[this_dev] && platform_get_drvdata(pdev_ne[this_dev])) ||\r\nio[this_dev]) {\r\nif (++this_dev == MAX_NE_CARDS)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndev = alloc_eip_netdev();\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio[this_dev] = dev->base_addr;\r\nirq[this_dev] = dev->irq;\r\nbad[this_dev] = dev->mem_end;\r\nfree_netdev(dev);\r\nne_add_devices();\r\nfor (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {\r\nif (pdev_ne[this_dev]) {\r\ndev = platform_get_drvdata(pdev_ne[this_dev]);\r\nif (dev)\r\nreturn dev;\r\n}\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic void __exit ne_exit(void)\r\n{\r\nplatform_driver_unregister(&ne_driver);\r\nne_loop_rm_unreg(1);\r\n}
