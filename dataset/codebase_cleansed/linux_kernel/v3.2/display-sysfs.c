static ssize_t display_show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct display_device *dsp = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", dsp->name);\r\n}\r\nstatic ssize_t display_show_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct display_device *dsp = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", dsp->type);\r\n}\r\nstatic ssize_t display_show_contrast(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct display_device *dsp = dev_get_drvdata(dev);\r\nssize_t rc = -ENXIO;\r\nmutex_lock(&dsp->lock);\r\nif (likely(dsp->driver) && dsp->driver->get_contrast)\r\nrc = sprintf(buf, "%d\n", dsp->driver->get_contrast(dsp));\r\nmutex_unlock(&dsp->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t display_store_contrast(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct display_device *dsp = dev_get_drvdata(dev);\r\nssize_t ret = -EINVAL, size;\r\nint contrast;\r\nchar *endp;\r\ncontrast = simple_strtoul(buf, &endp, 0);\r\nsize = endp - buf;\r\nif (isspace(*endp))\r\nsize++;\r\nif (size != count)\r\nreturn ret;\r\nmutex_lock(&dsp->lock);\r\nif (likely(dsp->driver && dsp->driver->set_contrast)) {\r\npr_debug("display: set contrast to %d\n", contrast);\r\ndsp->driver->set_contrast(dsp, contrast);\r\nret = count;\r\n}\r\nmutex_unlock(&dsp->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t display_show_max_contrast(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct display_device *dsp = dev_get_drvdata(dev);\r\nssize_t rc = -ENXIO;\r\nmutex_lock(&dsp->lock);\r\nif (likely(dsp->driver))\r\nrc = sprintf(buf, "%d\n", dsp->driver->max_contrast);\r\nmutex_unlock(&dsp->lock);\r\nreturn rc;\r\n}\r\nstatic int display_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct display_device *dsp = dev_get_drvdata(dev);\r\nmutex_lock(&dsp->lock);\r\nif (likely(dsp->driver->suspend))\r\ndsp->driver->suspend(dsp, state);\r\nmutex_unlock(&dsp->lock);\r\nreturn 0;\r\n}\r\nstatic int display_resume(struct device *dev)\r\n{\r\nstruct display_device *dsp = dev_get_drvdata(dev);\r\nmutex_lock(&dsp->lock);\r\nif (likely(dsp->driver->resume))\r\ndsp->driver->resume(dsp);\r\nmutex_unlock(&dsp->lock);\r\nreturn 0;\r\n}\r\nstruct display_device *display_device_register(struct display_driver *driver,\r\nstruct device *parent, void *devdata)\r\n{\r\nstruct display_device *new_dev = NULL;\r\nint ret = -EINVAL;\r\nif (unlikely(!driver))\r\nreturn ERR_PTR(ret);\r\nmutex_lock(&allocated_dsp_lock);\r\nret = idr_pre_get(&allocated_dsp, GFP_KERNEL);\r\nmutex_unlock(&allocated_dsp_lock);\r\nif (!ret)\r\nreturn ERR_PTR(ret);\r\nnew_dev = kzalloc(sizeof(struct display_device), GFP_KERNEL);\r\nif (likely(new_dev) && unlikely(driver->probe(new_dev, devdata))) {\r\nmutex_lock(&allocated_dsp_lock);\r\nret = idr_get_new(&allocated_dsp, new_dev, &new_dev->idx);\r\nmutex_unlock(&allocated_dsp_lock);\r\nif (!ret) {\r\nnew_dev->dev = device_create(display_class, parent,\r\nMKDEV(0, 0), new_dev,\r\n"display%d", new_dev->idx);\r\nif (!IS_ERR(new_dev->dev)) {\r\nnew_dev->parent = parent;\r\nnew_dev->driver = driver;\r\nmutex_init(&new_dev->lock);\r\nreturn new_dev;\r\n}\r\nmutex_lock(&allocated_dsp_lock);\r\nidr_remove(&allocated_dsp, new_dev->idx);\r\nmutex_unlock(&allocated_dsp_lock);\r\nret = -EINVAL;\r\n}\r\n}\r\nkfree(new_dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid display_device_unregister(struct display_device *ddev)\r\n{\r\nif (!ddev)\r\nreturn;\r\nmutex_lock(&ddev->lock);\r\ndevice_unregister(ddev->dev);\r\nmutex_unlock(&ddev->lock);\r\nmutex_lock(&allocated_dsp_lock);\r\nidr_remove(&allocated_dsp, ddev->idx);\r\nmutex_unlock(&allocated_dsp_lock);\r\nkfree(ddev);\r\n}\r\nstatic int __init display_class_init(void)\r\n{\r\ndisplay_class = class_create(THIS_MODULE, "display");\r\nif (IS_ERR(display_class)) {\r\nprintk(KERN_ERR "Failed to create display class\n");\r\ndisplay_class = NULL;\r\nreturn -EINVAL;\r\n}\r\ndisplay_class->dev_attrs = display_attrs;\r\ndisplay_class->suspend = display_suspend;\r\ndisplay_class->resume = display_resume;\r\nmutex_init(&allocated_dsp_lock);\r\nreturn 0;\r\n}\r\nstatic void __exit display_class_exit(void)\r\n{\r\nclass_destroy(display_class);\r\n}
