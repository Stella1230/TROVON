static int32_t read_attr_usbip_status(struct usbip_usb_device *udev)\r\n{\r\nchar attrpath[SYSFS_PATH_MAX];\r\nstruct sysfs_attribute *attr;\r\nint value = 0;\r\nint rc;\r\nstruct stat s;\r\nint retries = SYSFS_OPEN_RETRIES;\r\nsnprintf(attrpath, SYSFS_PATH_MAX, "%s/%s:%d.%d/usbip_status",\r\nudev->path, udev->busid, udev->bConfigurationValue, 0);\r\nwhile (retries > 0) {\r\nif (stat(attrpath, &s) == 0)\r\nbreak;\r\nif (errno != ENOENT) {\r\ndbg("stat failed: %s", attrpath);\r\nreturn -1;\r\n}\r\nusleep(10000);\r\nretries--;\r\n}\r\nif (retries == 0)\r\ndbg("usbip_status not ready after %d retries",\r\nSYSFS_OPEN_RETRIES);\r\nelse if (retries < SYSFS_OPEN_RETRIES)\r\ndbg("warning: usbip_status ready after %d retries",\r\nSYSFS_OPEN_RETRIES - retries);\r\nattr = sysfs_open_attribute(attrpath);\r\nif (!attr) {\r\ndbg("sysfs_open_attribute failed: %s", attrpath);\r\nreturn -1;\r\n}\r\nrc = sysfs_read_attribute(attr);\r\nif (rc) {\r\ndbg("sysfs_read_attribute failed: %s", attrpath);\r\nsysfs_close_attribute(attr);\r\nreturn -1;\r\n}\r\nvalue = atoi(attr->value);\r\nsysfs_close_attribute(attr);\r\nreturn value;\r\n}\r\nstatic struct usbip_exported_device *usbip_exported_device_new(char *sdevpath)\r\n{\r\nstruct usbip_exported_device *edev = NULL;\r\nsize_t size;\r\nint i;\r\nedev = calloc(1, sizeof(*edev));\r\nif (!edev) {\r\ndbg("calloc failed");\r\nreturn NULL;\r\n}\r\nedev->sudev = sysfs_open_device_path(sdevpath);\r\nif (!edev->sudev) {\r\ndbg("sysfs_open_device_path failed: %s", sdevpath);\r\ngoto err;\r\n}\r\nread_usb_device(edev->sudev, &edev->udev);\r\nedev->status = read_attr_usbip_status(&edev->udev);\r\nif (edev->status < 0)\r\ngoto err;\r\nsize = sizeof(*edev) + edev->udev.bNumInterfaces *\r\nsizeof(struct usbip_usb_interface);\r\nedev = realloc(edev, size);\r\nif (!edev) {\r\ndbg("realloc failed");\r\ngoto err;\r\n}\r\nfor (i = 0; i < edev->udev.bNumInterfaces; i++)\r\nread_usb_interface(&edev->udev, i, &edev->uinf[i]);\r\nreturn edev;\r\nerr:\r\nif (edev && edev->sudev)\r\nsysfs_close_device(edev->sudev);\r\nif (edev)\r\nfree(edev);\r\nreturn NULL;\r\n}\r\nstatic int check_new(struct dlist *dlist, struct sysfs_device *target)\r\n{\r\nstruct sysfs_device *dev;\r\ndlist_for_each_data(dlist, dev, struct sysfs_device) {\r\nif (!strncmp(dev->bus_id, target->bus_id, SYSFS_BUS_ID_SIZE))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void delete_nothing(void *unused_data)\r\n{\r\n(void) unused_data;\r\n}\r\nstatic int refresh_exported_devices(void)\r\n{\r\nstruct sysfs_device *suintf;\r\nstruct dlist *suintf_list;\r\nstruct sysfs_device *sudev;\r\nstruct dlist *sudev_list;\r\nstruct usbip_exported_device *edev;\r\nsudev_list = dlist_new_with_delete(sizeof(struct sysfs_device),\r\ndelete_nothing);\r\nsuintf_list = sysfs_get_driver_devices(host_driver->sysfs_driver);\r\nif (!suintf_list) {\r\ndbg("bind " USBIP_HOST_DRV_NAME ".ko to a usb device to be "\r\n"exportable!");\r\nreturn 0;\r\n}\r\ndlist_for_each_data(suintf_list, suintf, struct sysfs_device) {\r\nsudev = sysfs_get_device_parent(suintf);\r\nif (!sudev) {\r\ndbg("sysfs_get_device_parent failed: %s", suintf->name);\r\ncontinue;\r\n}\r\nif (check_new(sudev_list, sudev)) {\r\ndlist_unshift(sudev_list, sudev);\r\n}\r\n}\r\ndlist_for_each_data(sudev_list, sudev, struct sysfs_device) {\r\nedev = usbip_exported_device_new(sudev->path);\r\nif (!edev) {\r\ndbg("usbip_exported_device_new failed");\r\ncontinue;\r\n}\r\ndlist_unshift(host_driver->edev_list, edev);\r\nhost_driver->ndevs++;\r\n}\r\ndlist_destroy(sudev_list);\r\nreturn 0;\r\n}\r\nstatic struct sysfs_driver *open_sysfs_host_driver(void)\r\n{\r\nchar bus_type[] = "usb";\r\nchar sysfs_mntpath[SYSFS_PATH_MAX];\r\nchar host_drv_path[SYSFS_PATH_MAX];\r\nstruct sysfs_driver *host_drv;\r\nint rc;\r\nrc = sysfs_get_mnt_path(sysfs_mntpath, SYSFS_PATH_MAX);\r\nif (rc < 0) {\r\ndbg("sysfs_get_mnt_path failed");\r\nreturn NULL;\r\n}\r\nsnprintf(host_drv_path, SYSFS_PATH_MAX, "%s/%s/%s/%s/%s",\r\nsysfs_mntpath, SYSFS_BUS_NAME, bus_type, SYSFS_DRIVERS_NAME,\r\nUSBIP_HOST_DRV_NAME);\r\nhost_drv = sysfs_open_driver_path(host_drv_path);\r\nif (!host_drv) {\r\ndbg("sysfs_open_driver_path failed");\r\nreturn NULL;\r\n}\r\nreturn host_drv;\r\n}\r\nstatic void usbip_exported_device_delete(void *dev)\r\n{\r\nstruct usbip_exported_device *edev = dev;\r\nsysfs_close_device(edev->sudev);\r\nfree(dev);\r\n}\r\nint usbip_host_driver_open(void)\r\n{\r\nint rc;\r\nhost_driver = calloc(1, sizeof(*host_driver));\r\nif (!host_driver) {\r\ndbg("calloc failed");\r\nreturn -1;\r\n}\r\nhost_driver->ndevs = 0;\r\nhost_driver->edev_list =\r\ndlist_new_with_delete(sizeof(struct usbip_exported_device),\r\nusbip_exported_device_delete);\r\nif (!host_driver->edev_list) {\r\ndbg("dlist_new_with_delete failed");\r\ngoto err_free_host_driver;\r\n}\r\nhost_driver->sysfs_driver = open_sysfs_host_driver();\r\nif (!host_driver->sysfs_driver)\r\ngoto err_destroy_edev_list;\r\nrc = refresh_exported_devices();\r\nif (rc < 0)\r\ngoto err_close_sysfs_driver;\r\nreturn 0;\r\nerr_close_sysfs_driver:\r\nsysfs_close_driver(host_driver->sysfs_driver);\r\nerr_destroy_edev_list:\r\ndlist_destroy(host_driver->edev_list);\r\nerr_free_host_driver:\r\nfree(host_driver);\r\nhost_driver = NULL;\r\nreturn -1;\r\n}\r\nvoid usbip_host_driver_close(void)\r\n{\r\nif (!host_driver)\r\nreturn;\r\nif (host_driver->edev_list)\r\ndlist_destroy(host_driver->edev_list);\r\nif (host_driver->sysfs_driver)\r\nsysfs_close_driver(host_driver->sysfs_driver);\r\nfree(host_driver);\r\nhost_driver = NULL;\r\n}\r\nint usbip_host_refresh_device_list(void)\r\n{\r\nint rc;\r\nif (host_driver->edev_list)\r\ndlist_destroy(host_driver->edev_list);\r\nhost_driver->ndevs = 0;\r\nhost_driver->edev_list =\r\ndlist_new_with_delete(sizeof(struct usbip_exported_device),\r\nusbip_exported_device_delete);\r\nif (!host_driver->edev_list) {\r\ndbg("dlist_new_with_delete failed");\r\nreturn -1;\r\n}\r\nrc = refresh_exported_devices();\r\nif (rc < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint usbip_host_export_device(struct usbip_exported_device *edev, int sockfd)\r\n{\r\nchar attr_name[] = "usbip_sockfd";\r\nchar attr_path[SYSFS_PATH_MAX];\r\nstruct sysfs_attribute *attr;\r\nchar sockfd_buff[30];\r\nint ret;\r\nif (edev->status != SDEV_ST_AVAILABLE) {\r\ndbg("device not available: %s", edev->udev.busid);\r\nswitch (edev->status) {\r\ncase SDEV_ST_ERROR:\r\ndbg("status SDEV_ST_ERROR");\r\nbreak;\r\ncase SDEV_ST_USED:\r\ndbg("status SDEV_ST_USED");\r\nbreak;\r\ndefault:\r\ndbg("status unknown: 0x%x", edev->status);\r\n}\r\nreturn -1;\r\n}\r\nsnprintf(attr_path, sizeof(attr_path), "%s/%s:%d.%d/%s",\r\nedev->udev.path, edev->udev.busid,\r\nedev->udev.bConfigurationValue, 0, attr_name);\r\nattr = sysfs_open_attribute(attr_path);\r\nif (!attr) {\r\ndbg("sysfs_open_attribute failed: %s", attr_path);\r\nreturn -1;\r\n}\r\nsnprintf(sockfd_buff, sizeof(sockfd_buff), "%d\n", sockfd);\r\ndbg("write: %s", sockfd_buff);\r\nret = sysfs_write_attribute(attr, sockfd_buff, strlen(sockfd_buff));\r\nif (ret < 0) {\r\ndbg("sysfs_write_attribute failed: sockfd %s to %s",\r\nsockfd_buff, attr_path);\r\ngoto err_write_sockfd;\r\n}\r\ndbg("connect: %s", edev->udev.busid);\r\nerr_write_sockfd:\r\nsysfs_close_attribute(attr);\r\nreturn ret;\r\n}\r\nstruct usbip_exported_device *usbip_host_get_device(int num)\r\n{\r\nstruct usbip_exported_device *edev;\r\nstruct dlist *dlist = host_driver->edev_list;\r\nint cnt = 0;\r\ndlist_for_each_data(dlist, edev, struct usbip_exported_device) {\r\nif (num == cnt)\r\nreturn edev;\r\nelse\r\ncnt++;\r\n}\r\nreturn NULL;\r\n}
