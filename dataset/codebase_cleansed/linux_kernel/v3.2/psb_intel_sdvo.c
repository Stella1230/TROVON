void psb_intel_sdvo_write_sdvox(struct psb_intel_output *psb_intel_output,\r\nu32 val)\r\n{\r\nstruct drm_device *dev = psb_intel_output->base.dev;\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nu32 bval = val, cval = val;\r\nint i;\r\nif (sdvo_priv->output_device == SDVOB)\r\ncval = REG_READ(SDVOC);\r\nelse\r\nbval = REG_READ(SDVOB);\r\nfor (i = 0; i < 2; i++) {\r\nREG_WRITE(SDVOB, bval);\r\nREG_READ(SDVOB);\r\nREG_WRITE(SDVOC, cval);\r\nREG_READ(SDVOC);\r\n}\r\n}\r\nstatic bool psb_intel_sdvo_read_byte(\r\nstruct psb_intel_output *psb_intel_output,\r\nu8 addr, u8 *ch)\r\n{\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nu8 out_buf[2];\r\nu8 buf[2];\r\nint ret;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = sdvo_priv->i2c_bus->slave_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = out_buf,\r\n},\r\n{\r\n.addr = sdvo_priv->i2c_bus->slave_addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = buf,\r\n}\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = 0;\r\nret = i2c_transfer(&sdvo_priv->i2c_bus->adapter, msgs, 2);\r\nif (ret == 2) {\r\n*ch = buf[0];\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool psb_intel_sdvo_write_byte(\r\nstruct psb_intel_output *psb_intel_output,\r\nint addr, u8 ch)\r\n{\r\nu8 out_buf[2];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = psb_intel_output->i2c_bus->slave_addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = out_buf,\r\n}\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = ch;\r\nif (i2c_transfer(&psb_intel_output->i2c_bus->adapter, msgs, 1) == 1)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void psb_intel_sdvo_write_cmd(struct psb_intel_output *psb_intel_output,\r\nu8 cmd,\r\nvoid *args,\r\nint args_len)\r\n{\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nint i;\r\nif (0) {\r\nprintk(KERN_DEBUG "%s: W: %02X ", SDVO_NAME(sdvo_priv), cmd);\r\nfor (i = 0; i < args_len; i++)\r\nprintk(KERN_CONT "%02X ", ((u8 *) args)[i]);\r\nfor (; i < 8; i++)\r\nprintk(KERN_CONT " ");\r\nfor (i = 0;\r\ni <\r\nsizeof(sdvo_cmd_names) / sizeof(sdvo_cmd_names[0]);\r\ni++) {\r\nif (cmd == sdvo_cmd_names[i].cmd) {\r\nprintk(KERN_CONT\r\n"(%s)", sdvo_cmd_names[i].name);\r\nbreak;\r\n}\r\n}\r\nif (i ==\r\nsizeof(sdvo_cmd_names) / sizeof(sdvo_cmd_names[0]))\r\nprintk(KERN_CONT "(%02X)", cmd);\r\nprintk(KERN_CONT "\n");\r\n}\r\nfor (i = 0; i < args_len; i++) {\r\npsb_intel_sdvo_write_byte(psb_intel_output,\r\nSDVO_I2C_ARG_0 - i,\r\n((u8 *) args)[i]);\r\n}\r\npsb_intel_sdvo_write_byte(psb_intel_output, SDVO_I2C_OPCODE, cmd);\r\n}\r\nstatic u8 psb_intel_sdvo_read_response(\r\nstruct psb_intel_output *psb_intel_output,\r\nvoid *response, int response_len)\r\n{\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nint i;\r\nu8 status;\r\nu8 retry = 50;\r\nwhile (retry--) {\r\nfor (i = 0; i < response_len; i++) {\r\npsb_intel_sdvo_read_byte(psb_intel_output,\r\nSDVO_I2C_RETURN_0 + i,\r\n&((u8 *) response)[i]);\r\n}\r\npsb_intel_sdvo_read_byte(psb_intel_output,\r\nSDVO_I2C_CMD_STATUS,\r\n&status);\r\nif (0) {\r\npr_debug("%s: R: ", SDVO_NAME(sdvo_priv));\r\nfor (i = 0; i < response_len; i++)\r\nprintk(KERN_CONT "%02X ", ((u8 *) response)[i]);\r\nfor (; i < 8; i++)\r\nprintk(" ");\r\nif (status <= SDVO_CMD_STATUS_SCALING_NOT_SUPP)\r\nprintk(KERN_CONT "(%s)",\r\ncmd_status_names[status]);\r\nelse\r\nprintk(KERN_CONT "(??? %d)", status);\r\nprintk(KERN_CONT "\n");\r\n}\r\nif (status != SDVO_CMD_STATUS_PENDING)\r\nreturn status;\r\nmdelay(50);\r\n}\r\nreturn status;\r\n}\r\nint psb_intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode)\r\n{\r\nif (mode->clock >= 100000)\r\nreturn 1;\r\nelse if (mode->clock >= 50000)\r\nreturn 2;\r\nelse\r\nreturn 4;\r\n}\r\nvoid psb_intel_sdvo_set_control_bus_switch(\r\nstruct psb_intel_output *psb_intel_output,\r\nu8 target)\r\n{\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_SET_CONTROL_BUS_SWITCH,\r\n&target,\r\n1);\r\n}\r\nstatic bool psb_intel_sdvo_set_target_input(\r\nstruct psb_intel_output *psb_intel_output,\r\nbool target_0, bool target_1)\r\n{\r\nstruct psb_intel_sdvo_set_target_input_args targets = { 0 };\r\nu8 status;\r\nif (target_0 && target_1)\r\nreturn SDVO_CMD_STATUS_NOTSUPP;\r\nif (target_1)\r\ntargets.target_1 = 1;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, SDVO_CMD_SET_TARGET_INPUT,\r\n&targets, sizeof(targets));\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\nreturn status == SDVO_CMD_STATUS_SUCCESS;\r\n}\r\nstatic bool psb_intel_sdvo_get_trained_inputs(struct psb_intel_output\r\n*psb_intel_output, bool *input_1,\r\nbool *input_2)\r\n{\r\nstruct psb_intel_sdvo_get_trained_inputs_response response;\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, SDVO_CMD_GET_TRAINED_INPUTS,\r\nNULL, 0);\r\nstatus =\r\npsb_intel_sdvo_read_response(psb_intel_output, &response,\r\nsizeof(response));\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\n*input_1 = response.input0_trained;\r\n*input_2 = response.input1_trained;\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_get_active_outputs(struct psb_intel_output\r\n*psb_intel_output, u16 *outputs)\r\n{\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, SDVO_CMD_GET_ACTIVE_OUTPUTS,\r\nNULL, 0);\r\nstatus =\r\npsb_intel_sdvo_read_response(psb_intel_output, outputs,\r\nsizeof(*outputs));\r\nreturn status == SDVO_CMD_STATUS_SUCCESS;\r\n}\r\nstatic bool psb_intel_sdvo_set_active_outputs(struct psb_intel_output\r\n*psb_intel_output, u16 outputs)\r\n{\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, SDVO_CMD_SET_ACTIVE_OUTPUTS,\r\n&outputs, sizeof(outputs));\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\nreturn status == SDVO_CMD_STATUS_SUCCESS;\r\n}\r\nstatic bool psb_intel_sdvo_set_encoder_power_state(struct psb_intel_output\r\n*psb_intel_output, int mode)\r\n{\r\nu8 status, state = SDVO_ENCODER_STATE_ON;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nstate = SDVO_ENCODER_STATE_ON;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\nstate = SDVO_ENCODER_STATE_STANDBY;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nstate = SDVO_ENCODER_STATE_SUSPEND;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nstate = SDVO_ENCODER_STATE_OFF;\r\nbreak;\r\n}\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_SET_ENCODER_POWER_STATE, &state,\r\nsizeof(state));\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\nreturn status == SDVO_CMD_STATUS_SUCCESS;\r\n}\r\nstatic bool psb_intel_sdvo_get_input_pixel_clock_range(struct psb_intel_output\r\n*psb_intel_output,\r\nint *clock_min,\r\nint *clock_max)\r\n{\r\nstruct psb_intel_sdvo_pixel_clock_range clocks;\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE, NULL,\r\n0);\r\nstatus =\r\npsb_intel_sdvo_read_response(psb_intel_output, &clocks,\r\nsizeof(clocks));\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\n*clock_min = clocks.min * 10;\r\n*clock_max = clocks.max * 10;\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_set_target_output(\r\nstruct psb_intel_output *psb_intel_output,\r\nu16 outputs)\r\n{\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, SDVO_CMD_SET_TARGET_OUTPUT,\r\n&outputs, sizeof(outputs));\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\nreturn status == SDVO_CMD_STATUS_SUCCESS;\r\n}\r\nstatic bool psb_intel_sdvo_get_timing(struct psb_intel_output *psb_intel_output,\r\nu8 cmd, struct psb_intel_sdvo_dtd *dtd)\r\n{\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, cmd, NULL, 0);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, &dtd->part1,\r\nsizeof(dtd->part1));\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, cmd + 1, NULL, 0);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, &dtd->part2,\r\nsizeof(dtd->part2));\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_get_input_timing(\r\nstruct psb_intel_output *psb_intel_output,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nreturn psb_intel_sdvo_get_timing(psb_intel_output,\r\nSDVO_CMD_GET_INPUT_TIMINGS_PART1,\r\ndtd);\r\n}\r\nstatic bool psb_intel_sdvo_set_timing(\r\nstruct psb_intel_output *psb_intel_output,\r\nu8 cmd,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, cmd, &dtd->part1,\r\nsizeof(dtd->part1));\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\npsb_intel_sdvo_write_cmd(psb_intel_output, cmd + 1, &dtd->part2,\r\nsizeof(dtd->part2));\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_set_input_timing(\r\nstruct psb_intel_output *psb_intel_output,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nreturn psb_intel_sdvo_set_timing(psb_intel_output,\r\nSDVO_CMD_SET_INPUT_TIMINGS_PART1,\r\ndtd);\r\n}\r\nstatic bool psb_intel_sdvo_set_output_timing(\r\nstruct psb_intel_output *psb_intel_output,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nreturn psb_intel_sdvo_set_timing(psb_intel_output,\r\nSDVO_CMD_SET_OUTPUT_TIMINGS_PART1,\r\ndtd);\r\n}\r\nstatic int psb_intel_sdvo_get_clock_rate_mult(struct psb_intel_output\r\n*psb_intel_output)\r\n{\r\nu8 response, status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_CLOCK_RATE_MULT,\r\nNULL,\r\n0);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, &response, 1);\r\nif (status != SDVO_CMD_STATUS_SUCCESS) {\r\nDRM_DEBUG("Couldn't get SDVO clock rate multiplier\n");\r\nreturn SDVO_CLOCK_RATE_MULT_1X;\r\n} else {\r\nDRM_DEBUG("Current clock rate multiplier: %d\n", response);\r\n}\r\nreturn response;\r\n}\r\nstatic bool psb_intel_sdvo_set_clock_rate_mult(struct psb_intel_output\r\n*psb_intel_output, u8 val)\r\n{\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_SET_CLOCK_RATE_MULT,\r\n&val,\r\n1);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool psb_sdvo_set_current_inoutmap(struct psb_intel_output *output,\r\nu32 in0outputmask,\r\nu32 in1outputmask)\r\n{\r\nu8 byArgs[4];\r\nu8 status;\r\nint i;\r\nstruct psb_intel_sdvo_priv *sdvo_priv = output->dev_priv;\r\nmemset(byArgs, 0, sizeof(byArgs));\r\nbyArgs[0] = (u8) (in0outputmask & 0xFF);\r\nbyArgs[1] = (u8) ((in0outputmask >> 8) & 0xFF);\r\nbyArgs[2] = (u8) (in1outputmask & 0xFF);\r\nbyArgs[3] = (u8) ((in1outputmask >> 8) & 0xFF);\r\nfor (i = 0; i < 4; i++)\r\nsdvo_priv->in_out_map[i] = byArgs[0];\r\npsb_intel_sdvo_write_cmd(output, SDVO_CMD_SET_IN_OUT_MAP, byArgs, 4);\r\nstatus = psb_intel_sdvo_read_response(output, NULL, 0);\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void psb_intel_sdvo_set_iomap(struct psb_intel_output *output)\r\n{\r\nu32 dwCurrentSDVOIn0 = 0;\r\nu32 dwCurrentSDVOIn1 = 0;\r\nu32 dwDevMask = 0;\r\nstruct psb_intel_sdvo_priv *sdvo_priv = output->dev_priv;\r\nif (sdvo_priv->by_input_wiring & (SDVOB_IN0 | SDVOC_IN0)) {\r\nswitch (sdvo_priv->active_device) {\r\ncase SDVO_DEVICE_LVDS:\r\ndwDevMask = SDVO_OUTPUT_LVDS0 | SDVO_OUTPUT_LVDS1;\r\nbreak;\r\ncase SDVO_DEVICE_TMDS:\r\ndwDevMask = SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_TMDS1;\r\nbreak;\r\ncase SDVO_DEVICE_TV:\r\ndwDevMask =\r\nSDVO_OUTPUT_YPRPB0 | SDVO_OUTPUT_SVID0 |\r\nSDVO_OUTPUT_CVBS0 | SDVO_OUTPUT_YPRPB1 |\r\nSDVO_OUTPUT_SVID1 | SDVO_OUTPUT_CVBS1 |\r\nSDVO_OUTPUT_SCART0 | SDVO_OUTPUT_SCART1;\r\nbreak;\r\ncase SDVO_DEVICE_CRT:\r\ndwDevMask = SDVO_OUTPUT_RGB0 | SDVO_OUTPUT_RGB1;\r\nbreak;\r\n}\r\ndwCurrentSDVOIn0 = (sdvo_priv->active_outputs & dwDevMask);\r\n} else if (sdvo_priv->by_input_wiring & (SDVOB_IN1 | SDVOC_IN1)) {\r\nswitch (sdvo_priv->active_device) {\r\ncase SDVO_DEVICE_LVDS:\r\ndwDevMask = SDVO_OUTPUT_LVDS0 | SDVO_OUTPUT_LVDS1;\r\nbreak;\r\ncase SDVO_DEVICE_TMDS:\r\ndwDevMask = SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_TMDS1;\r\nbreak;\r\ncase SDVO_DEVICE_TV:\r\ndwDevMask =\r\nSDVO_OUTPUT_YPRPB0 | SDVO_OUTPUT_SVID0 |\r\nSDVO_OUTPUT_CVBS0 | SDVO_OUTPUT_YPRPB1 |\r\nSDVO_OUTPUT_SVID1 | SDVO_OUTPUT_CVBS1 |\r\nSDVO_OUTPUT_SCART0 | SDVO_OUTPUT_SCART1;\r\nbreak;\r\ncase SDVO_DEVICE_CRT:\r\ndwDevMask = SDVO_OUTPUT_RGB0 | SDVO_OUTPUT_RGB1;\r\nbreak;\r\n}\r\ndwCurrentSDVOIn1 = (sdvo_priv->active_outputs & dwDevMask);\r\n}\r\npsb_sdvo_set_current_inoutmap(output, dwCurrentSDVOIn0,\r\ndwCurrentSDVOIn1);\r\n}\r\nstatic bool psb_intel_sdvo_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nadjusted_mode->clock *= psb_intel_sdvo_get_pixel_multiplier(mode);\r\nreturn true;\r\n}\r\nstatic void psb_intel_sdvo_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_intel_output *psb_intel_output =\r\nenc_to_psb_intel_output(encoder);\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nu16 width, height;\r\nu16 h_blank_len, h_sync_len, v_blank_len, v_sync_len;\r\nu16 h_sync_offset, v_sync_offset;\r\nu32 sdvox;\r\nstruct psb_intel_sdvo_dtd output_dtd;\r\nint sdvo_pixel_multiply;\r\nif (!mode)\r\nreturn;\r\npsb_intel_sdvo_set_target_output(psb_intel_output, 0);\r\nwidth = mode->crtc_hdisplay;\r\nheight = mode->crtc_vdisplay;\r\nh_blank_len = mode->crtc_hblank_end - mode->crtc_hblank_start;\r\nh_sync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\r\nv_blank_len = mode->crtc_vblank_end - mode->crtc_vblank_start;\r\nv_sync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\r\nh_sync_offset = mode->crtc_hsync_start - mode->crtc_hblank_start;\r\nv_sync_offset = mode->crtc_vsync_start - mode->crtc_vblank_start;\r\noutput_dtd.part1.clock = mode->clock / 10;\r\noutput_dtd.part1.h_active = width & 0xff;\r\noutput_dtd.part1.h_blank = h_blank_len & 0xff;\r\noutput_dtd.part1.h_high = (((width >> 8) & 0xf) << 4) |\r\n((h_blank_len >> 8) & 0xf);\r\noutput_dtd.part1.v_active = height & 0xff;\r\noutput_dtd.part1.v_blank = v_blank_len & 0xff;\r\noutput_dtd.part1.v_high = (((height >> 8) & 0xf) << 4) |\r\n((v_blank_len >> 8) & 0xf);\r\noutput_dtd.part2.h_sync_off = h_sync_offset;\r\noutput_dtd.part2.h_sync_width = h_sync_len & 0xff;\r\noutput_dtd.part2.v_sync_off_width = (v_sync_offset & 0xf) << 4 |\r\n(v_sync_len & 0xf);\r\noutput_dtd.part2.sync_off_width_high =\r\n((h_sync_offset & 0x300) >> 2) | ((h_sync_len & 0x300) >> 4) |\r\n((v_sync_offset & 0x30) >> 2) | ((v_sync_len & 0x30) >> 4);\r\noutput_dtd.part2.dtd_flags = 0x18;\r\nif (mode->flags & DRM_MODE_FLAG_PHSYNC)\r\noutput_dtd.part2.dtd_flags |= 0x2;\r\nif (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\noutput_dtd.part2.dtd_flags |= 0x4;\r\noutput_dtd.part2.sdvo_flags = 0;\r\noutput_dtd.part2.v_sync_off_high = v_sync_offset & 0xc0;\r\noutput_dtd.part2.reserved = 0;\r\npsb_intel_sdvo_set_target_output(psb_intel_output,\r\nsdvo_priv->active_outputs);\r\npsb_intel_sdvo_set_target_input(psb_intel_output, true, false);\r\npsb_intel_sdvo_set_output_timing(psb_intel_output, &output_dtd);\r\npsb_intel_sdvo_set_input_timing(psb_intel_output, &output_dtd);\r\nswitch (psb_intel_sdvo_get_pixel_multiplier(mode)) {\r\ncase 1:\r\npsb_intel_sdvo_set_clock_rate_mult(psb_intel_output,\r\nSDVO_CLOCK_RATE_MULT_1X);\r\nbreak;\r\ncase 2:\r\npsb_intel_sdvo_set_clock_rate_mult(psb_intel_output,\r\nSDVO_CLOCK_RATE_MULT_2X);\r\nbreak;\r\ncase 4:\r\npsb_intel_sdvo_set_clock_rate_mult(psb_intel_output,\r\nSDVO_CLOCK_RATE_MULT_4X);\r\nbreak;\r\n}\r\nsdvox = REG_READ(sdvo_priv->output_device);\r\nswitch (sdvo_priv->output_device) {\r\ncase SDVOB:\r\nsdvox &= SDVOB_PRESERVE_MASK;\r\nbreak;\r\ncase SDVOC:\r\nsdvox &= SDVOC_PRESERVE_MASK;\r\nbreak;\r\n}\r\nsdvox |= (9 << 19) | SDVO_BORDER_ENABLE;\r\nif (psb_intel_crtc->pipe == 1)\r\nsdvox |= SDVO_PIPE_B_SELECT;\r\nsdvo_pixel_multiply = psb_intel_sdvo_get_pixel_multiplier(mode);\r\npsb_intel_sdvo_write_sdvox(psb_intel_output, sdvox);\r\npsb_intel_sdvo_set_iomap(psb_intel_output);\r\n}\r\nstatic void psb_intel_sdvo_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct psb_intel_output *psb_intel_output =\r\nenc_to_psb_intel_output(encoder);\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nu32 temp;\r\nif (mode != DRM_MODE_DPMS_ON) {\r\npsb_intel_sdvo_set_active_outputs(psb_intel_output, 0);\r\nif (0)\r\npsb_intel_sdvo_set_encoder_power_state(\r\npsb_intel_output,\r\nmode);\r\nif (mode == DRM_MODE_DPMS_OFF) {\r\ntemp = REG_READ(sdvo_priv->output_device);\r\nif ((temp & SDVO_ENABLE) != 0) {\r\npsb_intel_sdvo_write_sdvox(psb_intel_output,\r\ntemp &\r\n~SDVO_ENABLE);\r\n}\r\n}\r\n} else {\r\nbool input1, input2;\r\nint i;\r\nu8 status;\r\ntemp = REG_READ(sdvo_priv->output_device);\r\nif ((temp & SDVO_ENABLE) == 0)\r\npsb_intel_sdvo_write_sdvox(psb_intel_output,\r\ntemp | SDVO_ENABLE);\r\nfor (i = 0; i < 2; i++)\r\npsb_intel_wait_for_vblank(dev);\r\nstatus =\r\npsb_intel_sdvo_get_trained_inputs(psb_intel_output,\r\n&input1,\r\n&input2);\r\nif (status == SDVO_CMD_STATUS_SUCCESS && !input1) {\r\nDRM_DEBUG\r\n("First %s output reported failure to sync\n",\r\nSDVO_NAME(sdvo_priv));\r\n}\r\nif (0)\r\npsb_intel_sdvo_set_encoder_power_state(\r\npsb_intel_output,\r\nmode);\r\npsb_intel_sdvo_set_active_outputs(psb_intel_output,\r\nsdvo_priv->active_outputs);\r\n}\r\nreturn;\r\n}\r\nstatic void psb_intel_sdvo_save(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nsdvo_priv->save_sdvo_mult =\r\npsb_intel_sdvo_get_clock_rate_mult(psb_intel_output);\r\npsb_intel_sdvo_get_active_outputs(psb_intel_output,\r\n&sdvo_priv->save_active_outputs);\r\nif (sdvo_priv->caps.sdvo_inputs_mask & 0x1) {\r\npsb_intel_sdvo_set_target_input(psb_intel_output,\r\ntrue,\r\nfalse);\r\npsb_intel_sdvo_get_input_timing(psb_intel_output,\r\n&sdvo_priv->save_input_dtd_1);\r\n}\r\nif (sdvo_priv->caps.sdvo_inputs_mask & 0x2) {\r\npsb_intel_sdvo_set_target_input(psb_intel_output,\r\nfalse,\r\ntrue);\r\npsb_intel_sdvo_get_input_timing(psb_intel_output,\r\n&sdvo_priv->save_input_dtd_2);\r\n}\r\nsdvo_priv->save_SDVOX = REG_READ(sdvo_priv->output_device);\r\n}\r\nstatic void psb_intel_sdvo_restore(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nint i;\r\nbool input1, input2;\r\nu8 status;\r\npsb_intel_sdvo_set_active_outputs(psb_intel_output, 0);\r\nif (sdvo_priv->caps.sdvo_inputs_mask & 0x1) {\r\npsb_intel_sdvo_set_target_input(psb_intel_output, true, false);\r\npsb_intel_sdvo_set_input_timing(psb_intel_output,\r\n&sdvo_priv->save_input_dtd_1);\r\n}\r\nif (sdvo_priv->caps.sdvo_inputs_mask & 0x2) {\r\npsb_intel_sdvo_set_target_input(psb_intel_output, false, true);\r\npsb_intel_sdvo_set_input_timing(psb_intel_output,\r\n&sdvo_priv->save_input_dtd_2);\r\n}\r\npsb_intel_sdvo_set_clock_rate_mult(psb_intel_output,\r\nsdvo_priv->save_sdvo_mult);\r\nREG_WRITE(sdvo_priv->output_device, sdvo_priv->save_SDVOX);\r\nif (sdvo_priv->save_SDVOX & SDVO_ENABLE) {\r\nfor (i = 0; i < 2; i++)\r\npsb_intel_wait_for_vblank(dev);\r\nstatus =\r\npsb_intel_sdvo_get_trained_inputs(psb_intel_output,\r\n&input1,\r\n&input2);\r\nif (status == SDVO_CMD_STATUS_SUCCESS && !input1)\r\nDRM_DEBUG\r\n("First %s output reported failure to sync\n",\r\nSDVO_NAME(sdvo_priv));\r\n}\r\npsb_intel_sdvo_set_active_outputs(psb_intel_output,\r\nsdvo_priv->save_active_outputs);\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_SET_IN_OUT_MAP,\r\nsdvo_priv->in_out_map,\r\n4);\r\npsb_intel_sdvo_read_response(psb_intel_output, NULL, 0);\r\n}\r\nstatic int psb_intel_sdvo_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\nstruct psb_intel_sdvo_priv *sdvo_priv = psb_intel_output->dev_priv;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (sdvo_priv->pixel_clock_min > mode->clock)\r\nreturn MODE_CLOCK_LOW;\r\nif (sdvo_priv->pixel_clock_max < mode->clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic bool psb_intel_sdvo_get_capabilities(\r\nstruct psb_intel_output *psb_intel_output,\r\nstruct psb_intel_sdvo_caps *caps)\r\n{\r\nu8 status;\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_DEVICE_CAPS,\r\nNULL,\r\n0);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output,\r\ncaps,\r\nsizeof(*caps));\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstruct drm_connector *psb_intel_sdvo_find(struct drm_device *dev, int sdvoB)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct psb_intel_output *iout = NULL;\r\nstruct psb_intel_sdvo_priv *sdvo;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list,\r\nhead) {\r\niout = to_psb_intel_output(connector);\r\nif (iout->type != INTEL_OUTPUT_SDVO)\r\ncontinue;\r\nsdvo = iout->dev_priv;\r\nif (sdvo->output_device == SDVOB && sdvoB)\r\nreturn connector;\r\nif (sdvo->output_device == SDVOC && !sdvoB)\r\nreturn connector;\r\n}\r\nreturn NULL;\r\n}\r\nint psb_intel_sdvo_supports_hotplug(struct drm_connector *connector)\r\n{\r\nu8 response[2];\r\nu8 status;\r\nstruct psb_intel_output *psb_intel_output;\r\nif (!connector)\r\nreturn 0;\r\npsb_intel_output = to_psb_intel_output(connector);\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_HOT_PLUG_SUPPORT,\r\nNULL,\r\n0);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output,\r\n&response,\r\n2);\r\nif (response[0] != 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid psb_intel_sdvo_set_hotplug(struct drm_connector *connector, int on)\r\n{\r\nu8 response[2];\r\nu8 status;\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_ACTIVE_HOT_PLUG,\r\nNULL,\r\n0);\r\npsb_intel_sdvo_read_response(psb_intel_output, &response, 2);\r\nif (on) {\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_HOT_PLUG_SUPPORT, NULL,\r\n0);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output,\r\n&response,\r\n2);\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_SET_ACTIVE_HOT_PLUG,\r\n&response, 2);\r\n} else {\r\nresponse[0] = 0;\r\nresponse[1] = 0;\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_SET_ACTIVE_HOT_PLUG,\r\n&response, 2);\r\n}\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_ACTIVE_HOT_PLUG,\r\nNULL,\r\n0);\r\npsb_intel_sdvo_read_response(psb_intel_output, &response, 2);\r\n}\r\nstatic enum drm_connector_status psb_intel_sdvo_detect(struct drm_connector\r\n*connector, bool force)\r\n{\r\nu8 response[2];\r\nu8 status;\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\npsb_intel_sdvo_write_cmd(psb_intel_output,\r\nSDVO_CMD_GET_ATTACHED_DISPLAYS,\r\nNULL,\r\n0);\r\nstatus = psb_intel_sdvo_read_response(psb_intel_output, &response, 2);\r\nDRM_DEBUG("SDVO response %d %d\n", response[0], response[1]);\r\nif ((response[0] != 0) || (response[1] != 0))\r\nreturn connector_status_connected;\r\nelse\r\nreturn connector_status_disconnected;\r\n}\r\nstatic int psb_intel_sdvo_get_modes(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\npsb_intel_sdvo_set_control_bus_switch(psb_intel_output,\r\nSDVO_CONTROL_BUS_DDC2);\r\npsb_intel_ddc_get_modes(psb_intel_output);\r\nif (list_empty(&connector->probed_modes))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void psb_intel_sdvo_destroy(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_output *psb_intel_output =\r\nto_psb_intel_output(connector);\r\nif (psb_intel_output->i2c_bus)\r\npsb_intel_i2c_destroy(psb_intel_output->i2c_bus);\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(psb_intel_output);\r\n}\r\nvoid psb_intel_sdvo_enc_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nvoid psb_intel_sdvo_init(struct drm_device *dev, int output_device)\r\n{\r\nstruct drm_connector *connector;\r\nstruct psb_intel_output *psb_intel_output;\r\nstruct psb_intel_sdvo_priv *sdvo_priv;\r\nstruct psb_intel_i2c_chan *i2cbus = NULL;\r\nint connector_type;\r\nu8 ch[0x40];\r\nint i;\r\nint encoder_type, output_id;\r\npsb_intel_output =\r\nkcalloc(sizeof(struct psb_intel_output) +\r\nsizeof(struct psb_intel_sdvo_priv), 1, GFP_KERNEL);\r\nif (!psb_intel_output)\r\nreturn;\r\nconnector = &psb_intel_output->base;\r\ndrm_connector_init(dev, connector, &psb_intel_sdvo_connector_funcs,\r\nDRM_MODE_CONNECTOR_Unknown);\r\ndrm_connector_helper_add(connector,\r\n&psb_intel_sdvo_connector_helper_funcs);\r\nsdvo_priv = (struct psb_intel_sdvo_priv *) (psb_intel_output + 1);\r\npsb_intel_output->type = INTEL_OUTPUT_SDVO;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\nif (output_device == SDVOB)\r\ni2cbus =\r\npsb_intel_i2c_create(dev, GPIOE, "SDVOCTRL_E for SDVOB");\r\nelse\r\ni2cbus =\r\npsb_intel_i2c_create(dev, GPIOE, "SDVOCTRL_E for SDVOC");\r\nif (!i2cbus)\r\ngoto err_connector;\r\nsdvo_priv->i2c_bus = i2cbus;\r\nif (output_device == SDVOB) {\r\noutput_id = 1;\r\nsdvo_priv->by_input_wiring = SDVOB_IN0;\r\nsdvo_priv->i2c_bus->slave_addr = 0x38;\r\n} else {\r\noutput_id = 2;\r\nsdvo_priv->i2c_bus->slave_addr = 0x39;\r\n}\r\nsdvo_priv->output_device = output_device;\r\npsb_intel_output->i2c_bus = i2cbus;\r\npsb_intel_output->dev_priv = sdvo_priv;\r\nfor (i = 0; i < 0x40; i++) {\r\nif (!psb_intel_sdvo_read_byte(psb_intel_output, i, &ch[i])) {\r\ndev_dbg(dev->dev, "No SDVO device found on SDVO%c\n",\r\noutput_device == SDVOB ? 'B' : 'C');\r\ngoto err_i2c;\r\n}\r\n}\r\npsb_intel_sdvo_get_capabilities(psb_intel_output, &sdvo_priv->caps);\r\nmemset(&sdvo_priv->active_outputs, 0,\r\nsizeof(sdvo_priv->active_outputs));\r\nif (sdvo_priv->caps.output_flags & SDVO_OUTPUT_RGB0) {\r\nsdvo_priv->active_outputs = SDVO_OUTPUT_RGB0;\r\nsdvo_priv->active_device = SDVO_DEVICE_CRT;\r\nconnector->display_info.subpixel_order =\r\nSubPixelHorizontalRGB;\r\nencoder_type = DRM_MODE_ENCODER_DAC;\r\nconnector_type = DRM_MODE_CONNECTOR_VGA;\r\n} else if (sdvo_priv->caps.output_flags & SDVO_OUTPUT_RGB1) {\r\nsdvo_priv->active_outputs = SDVO_OUTPUT_RGB1;\r\nsdvo_priv->active_outputs = SDVO_DEVICE_CRT;\r\nconnector->display_info.subpixel_order =\r\nSubPixelHorizontalRGB;\r\nencoder_type = DRM_MODE_ENCODER_DAC;\r\nconnector_type = DRM_MODE_CONNECTOR_VGA;\r\n} else if (sdvo_priv->caps.output_flags & SDVO_OUTPUT_TMDS0) {\r\nsdvo_priv->active_outputs = SDVO_OUTPUT_TMDS0;\r\nsdvo_priv->active_device = SDVO_DEVICE_TMDS;\r\nconnector->display_info.subpixel_order =\r\nSubPixelHorizontalRGB;\r\nencoder_type = DRM_MODE_ENCODER_TMDS;\r\nconnector_type = DRM_MODE_CONNECTOR_DVID;\r\n} else if (sdvo_priv->caps.output_flags & SDVO_OUTPUT_TMDS1) {\r\nsdvo_priv->active_outputs = SDVO_OUTPUT_TMDS1;\r\nsdvo_priv->active_device = SDVO_DEVICE_TMDS;\r\nconnector->display_info.subpixel_order =\r\nSubPixelHorizontalRGB;\r\nencoder_type = DRM_MODE_ENCODER_TMDS;\r\nconnector_type = DRM_MODE_CONNECTOR_DVID;\r\n} else {\r\nunsigned char bytes[2];\r\nmemcpy(bytes, &sdvo_priv->caps.output_flags, 2);\r\ndev_dbg(dev->dev, "%s: No active RGB or TMDS outputs (0x%02x%02x)\n",\r\nSDVO_NAME(sdvo_priv), bytes[0], bytes[1]);\r\ngoto err_i2c;\r\n}\r\ndrm_encoder_init(dev, &psb_intel_output->enc, &psb_intel_sdvo_enc_funcs,\r\nencoder_type);\r\ndrm_encoder_helper_add(&psb_intel_output->enc,\r\n&psb_intel_sdvo_helper_funcs);\r\nconnector->connector_type = connector_type;\r\ndrm_mode_connector_attach_encoder(&psb_intel_output->base,\r\n&psb_intel_output->enc);\r\ndrm_sysfs_connector_add(connector);\r\npsb_intel_sdvo_set_target_input(psb_intel_output, true, false);\r\npsb_intel_sdvo_get_input_pixel_clock_range(psb_intel_output,\r\n&sdvo_priv->pixel_clock_min,\r\n&sdvo_priv->\r\npixel_clock_max);\r\ndev_dbg(dev->dev, "%s device VID/DID: %02X:%02X.%02X, "\r\n"clock range %dMHz - %dMHz, "\r\n"input 1: %c, input 2: %c, "\r\n"output 1: %c, output 2: %c\n",\r\nSDVO_NAME(sdvo_priv),\r\nsdvo_priv->caps.vendor_id, sdvo_priv->caps.device_id,\r\nsdvo_priv->caps.device_rev_id,\r\nsdvo_priv->pixel_clock_min / 1000,\r\nsdvo_priv->pixel_clock_max / 1000,\r\n(sdvo_priv->caps.sdvo_inputs_mask & 0x1) ? 'Y' : 'N',\r\n(sdvo_priv->caps.sdvo_inputs_mask & 0x2) ? 'Y' : 'N',\r\nsdvo_priv->caps.output_flags &\r\n(SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_RGB0) ? 'Y' : 'N',\r\nsdvo_priv->caps.output_flags &\r\n(SDVO_OUTPUT_TMDS1 | SDVO_OUTPUT_RGB1) ? 'Y' : 'N');\r\npsb_intel_output->ddc_bus = i2cbus;\r\nreturn;\r\nerr_i2c:\r\npsb_intel_i2c_destroy(psb_intel_output->i2c_bus);\r\nerr_connector:\r\ndrm_connector_cleanup(connector);\r\nkfree(psb_intel_output);\r\nreturn;\r\n}
