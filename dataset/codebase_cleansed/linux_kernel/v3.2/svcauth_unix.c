static void svcauth_unix_domain_release(struct auth_domain *dom)\r\n{\r\nstruct unix_domain *ud = container_of(dom, struct unix_domain, h);\r\nkfree(dom->name);\r\nkfree(ud);\r\n}\r\nstruct auth_domain *unix_domain_find(char *name)\r\n{\r\nstruct auth_domain *rv;\r\nstruct unix_domain *new = NULL;\r\nrv = auth_domain_lookup(name, NULL);\r\nwhile(1) {\r\nif (rv) {\r\nif (new && rv != &new->h)\r\nsvcauth_unix_domain_release(&new->h);\r\nif (rv->flavour != &svcauth_unix) {\r\nauth_domain_put(rv);\r\nreturn NULL;\r\n}\r\nreturn rv;\r\n}\r\nnew = kmalloc(sizeof(*new), GFP_KERNEL);\r\nif (new == NULL)\r\nreturn NULL;\r\nkref_init(&new->h.ref);\r\nnew->h.name = kstrdup(name, GFP_KERNEL);\r\nif (new->h.name == NULL) {\r\nkfree(new);\r\nreturn NULL;\r\n}\r\nnew->h.flavour = &svcauth_unix;\r\nrv = auth_domain_lookup(name, &new->h);\r\n}\r\n}\r\nstatic void ip_map_put(struct kref *kref)\r\n{\r\nstruct cache_head *item = container_of(kref, struct cache_head, ref);\r\nstruct ip_map *im = container_of(item, struct ip_map,h);\r\nif (test_bit(CACHE_VALID, &item->flags) &&\r\n!test_bit(CACHE_NEGATIVE, &item->flags))\r\nauth_domain_put(&im->m_client->h);\r\nkfree(im);\r\n}\r\nstatic inline int hash_ip(__be32 ip)\r\n{\r\nint hash = (__force u32)ip ^ ((__force u32)ip>>16);\r\nreturn (hash ^ (hash>>8)) & 0xff;\r\n}\r\nstatic inline int hash_ip6(struct in6_addr ip)\r\n{\r\nreturn (hash_ip(ip.s6_addr32[0]) ^\r\nhash_ip(ip.s6_addr32[1]) ^\r\nhash_ip(ip.s6_addr32[2]) ^\r\nhash_ip(ip.s6_addr32[3]));\r\n}\r\nstatic int ip_map_match(struct cache_head *corig, struct cache_head *cnew)\r\n{\r\nstruct ip_map *orig = container_of(corig, struct ip_map, h);\r\nstruct ip_map *new = container_of(cnew, struct ip_map, h);\r\nreturn strcmp(orig->m_class, new->m_class) == 0 &&\r\nipv6_addr_equal(&orig->m_addr, &new->m_addr);\r\n}\r\nstatic void ip_map_init(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct ip_map *new = container_of(cnew, struct ip_map, h);\r\nstruct ip_map *item = container_of(citem, struct ip_map, h);\r\nstrcpy(new->m_class, item->m_class);\r\nipv6_addr_copy(&new->m_addr, &item->m_addr);\r\n}\r\nstatic void update(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct ip_map *new = container_of(cnew, struct ip_map, h);\r\nstruct ip_map *item = container_of(citem, struct ip_map, h);\r\nkref_get(&item->m_client->h.ref);\r\nnew->m_client = item->m_client;\r\n}\r\nstatic struct cache_head *ip_map_alloc(void)\r\n{\r\nstruct ip_map *i = kmalloc(sizeof(*i), GFP_KERNEL);\r\nif (i)\r\nreturn &i->h;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void ip_map_request(struct cache_detail *cd,\r\nstruct cache_head *h,\r\nchar **bpp, int *blen)\r\n{\r\nchar text_addr[40];\r\nstruct ip_map *im = container_of(h, struct ip_map, h);\r\nif (ipv6_addr_v4mapped(&(im->m_addr))) {\r\nsnprintf(text_addr, 20, "%pI4", &im->m_addr.s6_addr32[3]);\r\n} else {\r\nsnprintf(text_addr, 40, "%pI6", &im->m_addr);\r\n}\r\nqword_add(bpp, blen, im->m_class);\r\nqword_add(bpp, blen, text_addr);\r\n(*bpp)[-1] = '\n';\r\n}\r\nstatic int ip_map_upcall(struct cache_detail *cd, struct cache_head *h)\r\n{\r\nreturn sunrpc_cache_pipe_upcall(cd, h, ip_map_request);\r\n}\r\nstatic int ip_map_parse(struct cache_detail *cd,\r\nchar *mesg, int mlen)\r\n{\r\nchar *buf = mesg;\r\nint len;\r\nchar class[8];\r\nunion {\r\nstruct sockaddr sa;\r\nstruct sockaddr_in s4;\r\nstruct sockaddr_in6 s6;\r\n} address;\r\nstruct sockaddr_in6 sin6;\r\nint err;\r\nstruct ip_map *ipmp;\r\nstruct auth_domain *dom;\r\ntime_t expiry;\r\nif (mesg[mlen-1] != '\n')\r\nreturn -EINVAL;\r\nmesg[mlen-1] = 0;\r\nlen = qword_get(&mesg, class, sizeof(class));\r\nif (len <= 0) return -EINVAL;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len <= 0) return -EINVAL;\r\nif (rpc_pton(buf, len, &address.sa, sizeof(address)) == 0)\r\nreturn -EINVAL;\r\nswitch (address.sa.sa_family) {\r\ncase AF_INET:\r\nsin6.sin6_family = AF_INET6;\r\nipv6_addr_set_v4mapped(address.s4.sin_addr.s_addr,\r\n&sin6.sin6_addr);\r\nbreak;\r\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\r\ncase AF_INET6:\r\nmemcpy(&sin6, &address.s6, sizeof(sin6));\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nexpiry = get_expiry(&mesg);\r\nif (expiry ==0)\r\nreturn -EINVAL;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0) return -EINVAL;\r\nif (len) {\r\ndom = unix_domain_find(buf);\r\nif (dom == NULL)\r\nreturn -ENOENT;\r\n} else\r\ndom = NULL;\r\nipmp = __ip_map_lookup(cd, class, &sin6.sin6_addr);\r\nif (ipmp) {\r\nerr = __ip_map_update(cd, ipmp,\r\ncontainer_of(dom, struct unix_domain, h),\r\nexpiry);\r\n} else\r\nerr = -ENOMEM;\r\nif (dom)\r\nauth_domain_put(dom);\r\ncache_flush();\r\nreturn err;\r\n}\r\nstatic int ip_map_show(struct seq_file *m,\r\nstruct cache_detail *cd,\r\nstruct cache_head *h)\r\n{\r\nstruct ip_map *im;\r\nstruct in6_addr addr;\r\nchar *dom = "-no-domain-";\r\nif (h == NULL) {\r\nseq_puts(m, "#class IP domain\n");\r\nreturn 0;\r\n}\r\nim = container_of(h, struct ip_map, h);\r\nipv6_addr_copy(&addr, &im->m_addr);\r\nif (test_bit(CACHE_VALID, &h->flags) &&\r\n!test_bit(CACHE_NEGATIVE, &h->flags))\r\ndom = im->m_client->h.name;\r\nif (ipv6_addr_v4mapped(&addr)) {\r\nseq_printf(m, "%s %pI4 %s\n",\r\nim->m_class, &addr.s6_addr32[3], dom);\r\n} else {\r\nseq_printf(m, "%s %pI6 %s\n", im->m_class, &addr, dom);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ip_map *__ip_map_lookup(struct cache_detail *cd, char *class,\r\nstruct in6_addr *addr)\r\n{\r\nstruct ip_map ip;\r\nstruct cache_head *ch;\r\nstrcpy(ip.m_class, class);\r\nipv6_addr_copy(&ip.m_addr, addr);\r\nch = sunrpc_cache_lookup(cd, &ip.h,\r\nhash_str(class, IP_HASHBITS) ^\r\nhash_ip6(*addr));\r\nif (ch)\r\nreturn container_of(ch, struct ip_map, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic inline struct ip_map *ip_map_lookup(struct net *net, char *class,\r\nstruct in6_addr *addr)\r\n{\r\nstruct sunrpc_net *sn;\r\nsn = net_generic(net, sunrpc_net_id);\r\nreturn __ip_map_lookup(sn->ip_map_cache, class, addr);\r\n}\r\nstatic int __ip_map_update(struct cache_detail *cd, struct ip_map *ipm,\r\nstruct unix_domain *udom, time_t expiry)\r\n{\r\nstruct ip_map ip;\r\nstruct cache_head *ch;\r\nip.m_client = udom;\r\nip.h.flags = 0;\r\nif (!udom)\r\nset_bit(CACHE_NEGATIVE, &ip.h.flags);\r\nip.h.expiry_time = expiry;\r\nch = sunrpc_cache_update(cd, &ip.h, &ipm->h,\r\nhash_str(ipm->m_class, IP_HASHBITS) ^\r\nhash_ip6(ipm->m_addr));\r\nif (!ch)\r\nreturn -ENOMEM;\r\ncache_put(ch, cd);\r\nreturn 0;\r\n}\r\nstatic inline int ip_map_update(struct net *net, struct ip_map *ipm,\r\nstruct unix_domain *udom, time_t expiry)\r\n{\r\nstruct sunrpc_net *sn;\r\nsn = net_generic(net, sunrpc_net_id);\r\nreturn __ip_map_update(sn->ip_map_cache, ipm, udom, expiry);\r\n}\r\nvoid svcauth_unix_purge(void)\r\n{\r\nstruct net *net;\r\nfor_each_net(net) {\r\nstruct sunrpc_net *sn;\r\nsn = net_generic(net, sunrpc_net_id);\r\ncache_purge(sn->ip_map_cache);\r\n}\r\n}\r\nstatic inline struct ip_map *\r\nip_map_cached_get(struct svc_xprt *xprt)\r\n{\r\nstruct ip_map *ipm = NULL;\r\nstruct sunrpc_net *sn;\r\nif (test_bit(XPT_CACHE_AUTH, &xprt->xpt_flags)) {\r\nspin_lock(&xprt->xpt_lock);\r\nipm = xprt->xpt_auth_cache;\r\nif (ipm != NULL) {\r\nif (!cache_valid(&ipm->h)) {\r\nsn = net_generic(xprt->xpt_net, sunrpc_net_id);\r\nxprt->xpt_auth_cache = NULL;\r\nspin_unlock(&xprt->xpt_lock);\r\ncache_put(&ipm->h, sn->ip_map_cache);\r\nreturn NULL;\r\n}\r\ncache_get(&ipm->h);\r\n}\r\nspin_unlock(&xprt->xpt_lock);\r\n}\r\nreturn ipm;\r\n}\r\nstatic inline void\r\nip_map_cached_put(struct svc_xprt *xprt, struct ip_map *ipm)\r\n{\r\nif (test_bit(XPT_CACHE_AUTH, &xprt->xpt_flags)) {\r\nspin_lock(&xprt->xpt_lock);\r\nif (xprt->xpt_auth_cache == NULL) {\r\nxprt->xpt_auth_cache = ipm;\r\nipm = NULL;\r\n}\r\nspin_unlock(&xprt->xpt_lock);\r\n}\r\nif (ipm) {\r\nstruct sunrpc_net *sn;\r\nsn = net_generic(xprt->xpt_net, sunrpc_net_id);\r\ncache_put(&ipm->h, sn->ip_map_cache);\r\n}\r\n}\r\nvoid\r\nsvcauth_unix_info_release(struct svc_xprt *xpt)\r\n{\r\nstruct ip_map *ipm;\r\nipm = xpt->xpt_auth_cache;\r\nif (ipm != NULL) {\r\nstruct sunrpc_net *sn;\r\nsn = net_generic(xpt->xpt_net, sunrpc_net_id);\r\ncache_put(&ipm->h, sn->ip_map_cache);\r\n}\r\n}\r\nstatic void unix_gid_put(struct kref *kref)\r\n{\r\nstruct cache_head *item = container_of(kref, struct cache_head, ref);\r\nstruct unix_gid *ug = container_of(item, struct unix_gid, h);\r\nif (test_bit(CACHE_VALID, &item->flags) &&\r\n!test_bit(CACHE_NEGATIVE, &item->flags))\r\nput_group_info(ug->gi);\r\nkfree(ug);\r\n}\r\nstatic int unix_gid_match(struct cache_head *corig, struct cache_head *cnew)\r\n{\r\nstruct unix_gid *orig = container_of(corig, struct unix_gid, h);\r\nstruct unix_gid *new = container_of(cnew, struct unix_gid, h);\r\nreturn orig->uid == new->uid;\r\n}\r\nstatic void unix_gid_init(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct unix_gid *new = container_of(cnew, struct unix_gid, h);\r\nstruct unix_gid *item = container_of(citem, struct unix_gid, h);\r\nnew->uid = item->uid;\r\n}\r\nstatic void unix_gid_update(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct unix_gid *new = container_of(cnew, struct unix_gid, h);\r\nstruct unix_gid *item = container_of(citem, struct unix_gid, h);\r\nget_group_info(item->gi);\r\nnew->gi = item->gi;\r\n}\r\nstatic struct cache_head *unix_gid_alloc(void)\r\n{\r\nstruct unix_gid *g = kmalloc(sizeof(*g), GFP_KERNEL);\r\nif (g)\r\nreturn &g->h;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void unix_gid_request(struct cache_detail *cd,\r\nstruct cache_head *h,\r\nchar **bpp, int *blen)\r\n{\r\nchar tuid[20];\r\nstruct unix_gid *ug = container_of(h, struct unix_gid, h);\r\nsnprintf(tuid, 20, "%u", ug->uid);\r\nqword_add(bpp, blen, tuid);\r\n(*bpp)[-1] = '\n';\r\n}\r\nstatic int unix_gid_upcall(struct cache_detail *cd, struct cache_head *h)\r\n{\r\nreturn sunrpc_cache_pipe_upcall(cd, h, unix_gid_request);\r\n}\r\nstatic int unix_gid_parse(struct cache_detail *cd,\r\nchar *mesg, int mlen)\r\n{\r\nint uid;\r\nint gids;\r\nint rv;\r\nint i;\r\nint err;\r\ntime_t expiry;\r\nstruct unix_gid ug, *ugp;\r\nif (mlen <= 0 || mesg[mlen-1] != '\n')\r\nreturn -EINVAL;\r\nmesg[mlen-1] = 0;\r\nrv = get_int(&mesg, &uid);\r\nif (rv)\r\nreturn -EINVAL;\r\nug.uid = uid;\r\nexpiry = get_expiry(&mesg);\r\nif (expiry == 0)\r\nreturn -EINVAL;\r\nrv = get_int(&mesg, &gids);\r\nif (rv || gids < 0 || gids > 8192)\r\nreturn -EINVAL;\r\nug.gi = groups_alloc(gids);\r\nif (!ug.gi)\r\nreturn -ENOMEM;\r\nfor (i = 0 ; i < gids ; i++) {\r\nint gid;\r\nrv = get_int(&mesg, &gid);\r\nerr = -EINVAL;\r\nif (rv)\r\ngoto out;\r\nGROUP_AT(ug.gi, i) = gid;\r\n}\r\nugp = unix_gid_lookup(uid);\r\nif (ugp) {\r\nstruct cache_head *ch;\r\nug.h.flags = 0;\r\nug.h.expiry_time = expiry;\r\nch = sunrpc_cache_update(&unix_gid_cache,\r\n&ug.h, &ugp->h,\r\nhash_long(uid, GID_HASHBITS));\r\nif (!ch)\r\nerr = -ENOMEM;\r\nelse {\r\nerr = 0;\r\ncache_put(ch, &unix_gid_cache);\r\n}\r\n} else\r\nerr = -ENOMEM;\r\nout:\r\nif (ug.gi)\r\nput_group_info(ug.gi);\r\nreturn err;\r\n}\r\nstatic int unix_gid_show(struct seq_file *m,\r\nstruct cache_detail *cd,\r\nstruct cache_head *h)\r\n{\r\nstruct unix_gid *ug;\r\nint i;\r\nint glen;\r\nif (h == NULL) {\r\nseq_puts(m, "#uid cnt: gids...\n");\r\nreturn 0;\r\n}\r\nug = container_of(h, struct unix_gid, h);\r\nif (test_bit(CACHE_VALID, &h->flags) &&\r\n!test_bit(CACHE_NEGATIVE, &h->flags))\r\nglen = ug->gi->ngroups;\r\nelse\r\nglen = 0;\r\nseq_printf(m, "%u %d:", ug->uid, glen);\r\nfor (i = 0; i < glen; i++)\r\nseq_printf(m, " %d", GROUP_AT(ug->gi, i));\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic struct unix_gid *unix_gid_lookup(uid_t uid)\r\n{\r\nstruct unix_gid ug;\r\nstruct cache_head *ch;\r\nug.uid = uid;\r\nch = sunrpc_cache_lookup(&unix_gid_cache, &ug.h,\r\nhash_long(uid, GID_HASHBITS));\r\nif (ch)\r\nreturn container_of(ch, struct unix_gid, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct group_info *unix_gid_find(uid_t uid, struct svc_rqst *rqstp)\r\n{\r\nstruct unix_gid *ug;\r\nstruct group_info *gi;\r\nint ret;\r\nug = unix_gid_lookup(uid);\r\nif (!ug)\r\nreturn ERR_PTR(-EAGAIN);\r\nret = cache_check(&unix_gid_cache, &ug->h, &rqstp->rq_chandle);\r\nswitch (ret) {\r\ncase -ENOENT:\r\nreturn ERR_PTR(-ENOENT);\r\ncase -ETIMEDOUT:\r\nreturn ERR_PTR(-ESHUTDOWN);\r\ncase 0:\r\ngi = get_group_info(ug->gi);\r\ncache_put(&ug->h, &unix_gid_cache);\r\nreturn gi;\r\ndefault:\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\n}\r\nint\r\nsvcauth_unix_set_client(struct svc_rqst *rqstp)\r\n{\r\nstruct sockaddr_in *sin;\r\nstruct sockaddr_in6 *sin6, sin6_storage;\r\nstruct ip_map *ipm;\r\nstruct group_info *gi;\r\nstruct svc_cred *cred = &rqstp->rq_cred;\r\nstruct svc_xprt *xprt = rqstp->rq_xprt;\r\nstruct net *net = xprt->xpt_net;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nswitch (rqstp->rq_addr.ss_family) {\r\ncase AF_INET:\r\nsin = svc_addr_in(rqstp);\r\nsin6 = &sin6_storage;\r\nipv6_addr_set_v4mapped(sin->sin_addr.s_addr, &sin6->sin6_addr);\r\nbreak;\r\ncase AF_INET6:\r\nsin6 = svc_addr_in6(rqstp);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nrqstp->rq_client = NULL;\r\nif (rqstp->rq_proc == 0)\r\nreturn SVC_OK;\r\nipm = ip_map_cached_get(xprt);\r\nif (ipm == NULL)\r\nipm = __ip_map_lookup(sn->ip_map_cache, rqstp->rq_server->sv_program->pg_class,\r\n&sin6->sin6_addr);\r\nif (ipm == NULL)\r\nreturn SVC_DENIED;\r\nswitch (cache_check(sn->ip_map_cache, &ipm->h, &rqstp->rq_chandle)) {\r\ndefault:\r\nBUG();\r\ncase -ETIMEDOUT:\r\nreturn SVC_CLOSE;\r\ncase -EAGAIN:\r\nreturn SVC_DROP;\r\ncase -ENOENT:\r\nreturn SVC_DENIED;\r\ncase 0:\r\nrqstp->rq_client = &ipm->m_client->h;\r\nkref_get(&rqstp->rq_client->ref);\r\nip_map_cached_put(xprt, ipm);\r\nbreak;\r\n}\r\ngi = unix_gid_find(cred->cr_uid, rqstp);\r\nswitch (PTR_ERR(gi)) {\r\ncase -EAGAIN:\r\nreturn SVC_DROP;\r\ncase -ESHUTDOWN:\r\nreturn SVC_CLOSE;\r\ncase -ENOENT:\r\nbreak;\r\ndefault:\r\nput_group_info(cred->cr_group_info);\r\ncred->cr_group_info = gi;\r\n}\r\nreturn SVC_OK;\r\n}\r\nstatic int\r\nsvcauth_null_accept(struct svc_rqst *rqstp, __be32 *authp)\r\n{\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nstruct svc_cred *cred = &rqstp->rq_cred;\r\ncred->cr_group_info = NULL;\r\nrqstp->rq_client = NULL;\r\nif (argv->iov_len < 3*4)\r\nreturn SVC_GARBAGE;\r\nif (svc_getu32(argv) != 0) {\r\ndprintk("svc: bad null cred\n");\r\n*authp = rpc_autherr_badcred;\r\nreturn SVC_DENIED;\r\n}\r\nif (svc_getu32(argv) != htonl(RPC_AUTH_NULL) || svc_getu32(argv) != 0) {\r\ndprintk("svc: bad null verf\n");\r\n*authp = rpc_autherr_badverf;\r\nreturn SVC_DENIED;\r\n}\r\ncred->cr_uid = (uid_t) -1;\r\ncred->cr_gid = (gid_t) -1;\r\ncred->cr_group_info = groups_alloc(0);\r\nif (cred->cr_group_info == NULL)\r\nreturn SVC_CLOSE;\r\nsvc_putnl(resv, RPC_AUTH_NULL);\r\nsvc_putnl(resv, 0);\r\nrqstp->rq_flavor = RPC_AUTH_NULL;\r\nreturn SVC_OK;\r\n}\r\nstatic int\r\nsvcauth_null_release(struct svc_rqst *rqstp)\r\n{\r\nif (rqstp->rq_client)\r\nauth_domain_put(rqstp->rq_client);\r\nrqstp->rq_client = NULL;\r\nif (rqstp->rq_cred.cr_group_info)\r\nput_group_info(rqstp->rq_cred.cr_group_info);\r\nrqstp->rq_cred.cr_group_info = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsvcauth_unix_accept(struct svc_rqst *rqstp, __be32 *authp)\r\n{\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nstruct svc_cred *cred = &rqstp->rq_cred;\r\nu32 slen, i;\r\nint len = argv->iov_len;\r\ncred->cr_group_info = NULL;\r\nrqstp->rq_client = NULL;\r\nif ((len -= 3*4) < 0)\r\nreturn SVC_GARBAGE;\r\nsvc_getu32(argv);\r\nsvc_getu32(argv);\r\nslen = XDR_QUADLEN(svc_getnl(argv));\r\nif (slen > 64 || (len -= (slen + 3)*4) < 0)\r\ngoto badcred;\r\nargv->iov_base = (void*)((__be32*)argv->iov_base + slen);\r\nargv->iov_len -= slen*4;\r\ncred->cr_uid = svc_getnl(argv);\r\ncred->cr_gid = svc_getnl(argv);\r\nslen = svc_getnl(argv);\r\nif (slen > 16 || (len -= (slen + 2)*4) < 0)\r\ngoto badcred;\r\ncred->cr_group_info = groups_alloc(slen);\r\nif (cred->cr_group_info == NULL)\r\nreturn SVC_CLOSE;\r\nfor (i = 0; i < slen; i++)\r\nGROUP_AT(cred->cr_group_info, i) = svc_getnl(argv);\r\nif (svc_getu32(argv) != htonl(RPC_AUTH_NULL) || svc_getu32(argv) != 0) {\r\n*authp = rpc_autherr_badverf;\r\nreturn SVC_DENIED;\r\n}\r\nsvc_putnl(resv, RPC_AUTH_NULL);\r\nsvc_putnl(resv, 0);\r\nrqstp->rq_flavor = RPC_AUTH_UNIX;\r\nreturn SVC_OK;\r\nbadcred:\r\n*authp = rpc_autherr_badcred;\r\nreturn SVC_DENIED;\r\n}\r\nstatic int\r\nsvcauth_unix_release(struct svc_rqst *rqstp)\r\n{\r\nif (rqstp->rq_client)\r\nauth_domain_put(rqstp->rq_client);\r\nrqstp->rq_client = NULL;\r\nif (rqstp->rq_cred.cr_group_info)\r\nput_group_info(rqstp->rq_cred.cr_group_info);\r\nrqstp->rq_cred.cr_group_info = NULL;\r\nreturn 0;\r\n}\r\nint ip_map_cache_create(struct net *net)\r\n{\r\nint err = -ENOMEM;\r\nstruct cache_detail *cd;\r\nstruct cache_head **tbl;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\ncd = kzalloc(sizeof(struct cache_detail), GFP_KERNEL);\r\nif (cd == NULL)\r\ngoto err_cd;\r\ntbl = kzalloc(IP_HASHMAX * sizeof(struct cache_head *), GFP_KERNEL);\r\nif (tbl == NULL)\r\ngoto err_tbl;\r\ncd->owner = THIS_MODULE,\r\ncd->hash_size = IP_HASHMAX,\r\ncd->hash_table = tbl,\r\ncd->name = "auth.unix.ip",\r\ncd->cache_put = ip_map_put,\r\ncd->cache_upcall = ip_map_upcall,\r\ncd->cache_parse = ip_map_parse,\r\ncd->cache_show = ip_map_show,\r\ncd->match = ip_map_match,\r\ncd->init = ip_map_init,\r\ncd->update = update,\r\ncd->alloc = ip_map_alloc,\r\nerr = cache_register_net(cd, net);\r\nif (err)\r\ngoto err_reg;\r\nsn->ip_map_cache = cd;\r\nreturn 0;\r\nerr_reg:\r\nkfree(tbl);\r\nerr_tbl:\r\nkfree(cd);\r\nerr_cd:\r\nreturn err;\r\n}\r\nvoid ip_map_cache_destroy(struct net *net)\r\n{\r\nstruct sunrpc_net *sn;\r\nsn = net_generic(net, sunrpc_net_id);\r\ncache_purge(sn->ip_map_cache);\r\ncache_unregister_net(sn->ip_map_cache, net);\r\nkfree(sn->ip_map_cache->hash_table);\r\nkfree(sn->ip_map_cache);\r\n}
