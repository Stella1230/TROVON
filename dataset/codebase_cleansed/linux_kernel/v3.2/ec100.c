static int ec100_write_reg(struct ec100_state *state, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = {reg, val};\r\nstruct i2c_msg msg = {\r\n.addr = state->config.demod_address,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = buf};\r\nif (i2c_transfer(state->i2c, &msg, 1) != 1) {\r\nwarn("I2C write failed reg:%02x", reg);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ec100_read_reg(struct ec100_state *state, u8 reg, u8 *val)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = state->config.demod_address,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg\r\n}, {\r\n.addr = state->config.demod_address,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = val\r\n}\r\n};\r\nif (i2c_transfer(state->i2c, msg, 2) != 2) {\r\nwarn("I2C read failed reg:%02x", reg);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ec100_set_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *params)\r\n{\r\nstruct ec100_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp, tmp2;\r\ndeb_info("%s: freq:%d bw:%d\n", __func__, params->frequency,\r\nparams->u.ofdm.bandwidth);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe, params);\r\nret = ec100_write_reg(state, 0x04, 0x06);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x67, 0x58);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x05, 0x18);\r\nif (ret)\r\ngoto error;\r\nswitch (params->u.ofdm.bandwidth) {\r\ncase BANDWIDTH_6_MHZ:\r\ntmp = 0xb7;\r\ntmp2 = 0x55;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\ntmp = 0x00;\r\ntmp2 = 0x64;\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\ndefault:\r\ntmp = 0x49;\r\ntmp2 = 0x72;\r\n}\r\nret = ec100_write_reg(state, 0x1b, tmp);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x1c, tmp2);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x0c, 0xbb);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x0d, 0x31);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x08, 0x24);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x00, 0x00);\r\nif (ret)\r\ngoto error;\r\nret = ec100_write_reg(state, 0x00, 0x20);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec100_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 300;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int ec100_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct ec100_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp;\r\n*status = 0;\r\nret = ec100_read_reg(state, 0x42, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp & 0x80) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\n} else {\r\nret = ec100_read_reg(state, 0x01, &tmp);\r\nif (ret)\r\ngoto error;\r\nif (tmp & 0x10) {\r\n*status |= FE_HAS_SIGNAL;\r\nif (!(tmp & 0x01)) {\r\n*status |= FE_HAS_CARRIER | FE_HAS_VITERBI;\r\n}\r\n}\r\n}\r\nreturn ret;\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec100_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct ec100_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp, tmp2;\r\nu16 ber2;\r\n*ber = 0;\r\nret = ec100_read_reg(state, 0x65, &tmp);\r\nif (ret)\r\ngoto error;\r\nret = ec100_read_reg(state, 0x66, &tmp2);\r\nif (ret)\r\ngoto error;\r\nber2 = (tmp2 << 8) | tmp;\r\nif (ber2 < state->ber)\r\n*ber = ber2;\r\nelse\r\n*ber = ber2 - state->ber;\r\nstate->ber = ber2;\r\nreturn ret;\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec100_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct ec100_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp;\r\nret = ec100_read_reg(state, 0x24, &tmp);\r\nif (ret) {\r\n*strength = 0;\r\ngoto error;\r\n}\r\n*strength = ((tmp << 8) | tmp);\r\nreturn ret;\r\nerror:\r\ndeb_info("%s: failed:%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec100_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int ec100_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic void ec100_release(struct dvb_frontend *fe)\r\n{\r\nstruct ec100_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *ec100_attach(const struct ec100_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nint ret;\r\nstruct ec100_state *state = NULL;\r\nu8 tmp;\r\nstate = kzalloc(sizeof(struct ec100_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->i2c = i2c;\r\nmemcpy(&state->config, config, sizeof(struct ec100_config));\r\nret = ec100_read_reg(state, 0x33, &tmp);\r\nif (ret || tmp != 0x0b)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &ec100_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
