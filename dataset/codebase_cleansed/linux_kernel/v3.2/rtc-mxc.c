static u32 get_alarm_or_time(struct device *dev, int time_alarm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 day = 0, hr = 0, min = 0, sec = 0, hr_min = 0;\r\nswitch (time_alarm) {\r\ncase MXC_RTC_TIME:\r\nday = readw(ioaddr + RTC_DAYR);\r\nhr_min = readw(ioaddr + RTC_HOURMIN);\r\nsec = readw(ioaddr + RTC_SECOND);\r\nbreak;\r\ncase MXC_RTC_ALARM:\r\nday = readw(ioaddr + RTC_DAYALARM);\r\nhr_min = readw(ioaddr + RTC_ALRM_HM) & 0xffff;\r\nsec = readw(ioaddr + RTC_ALRM_SEC);\r\nbreak;\r\n}\r\nhr = hr_min >> 8;\r\nmin = hr_min & 0xff;\r\nreturn (((day * 24 + hr) * 60) + min) * 60 + sec;\r\n}\r\nstatic void set_alarm_or_time(struct device *dev, int time_alarm, u32 time)\r\n{\r\nu32 day, hr, min, sec, temp;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nday = time / 86400;\r\ntime -= day * 86400;\r\nhr = time / 3600;\r\ntime -= hr * 3600;\r\nmin = time / 60;\r\nsec = time - min * 60;\r\ntemp = (hr << 8) + min;\r\nswitch (time_alarm) {\r\ncase MXC_RTC_TIME:\r\nwritew(day, ioaddr + RTC_DAYR);\r\nwritew(sec, ioaddr + RTC_SECOND);\r\nwritew(temp, ioaddr + RTC_HOURMIN);\r\nbreak;\r\ncase MXC_RTC_ALARM:\r\nwritew(day, ioaddr + RTC_DAYALARM);\r\nwritew(sec, ioaddr + RTC_ALRM_SEC);\r\nwritew(temp, ioaddr + RTC_ALRM_HM);\r\nbreak;\r\n}\r\n}\r\nstatic int rtc_update_alarm(struct device *dev, struct rtc_time *alrm)\r\n{\r\nstruct rtc_time alarm_tm, now_tm;\r\nunsigned long now, time;\r\nint ret;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nnow = get_alarm_or_time(dev, MXC_RTC_TIME);\r\nrtc_time_to_tm(now, &now_tm);\r\nalarm_tm.tm_year = now_tm.tm_year;\r\nalarm_tm.tm_mon = now_tm.tm_mon;\r\nalarm_tm.tm_mday = now_tm.tm_mday;\r\nalarm_tm.tm_hour = alrm->tm_hour;\r\nalarm_tm.tm_min = alrm->tm_min;\r\nalarm_tm.tm_sec = alrm->tm_sec;\r\nrtc_tm_to_time(&now_tm, &now);\r\nrtc_tm_to_time(&alarm_tm, &time);\r\nif (time < now) {\r\ntime += 60 * 60 * 24;\r\nrtc_time_to_tm(time, &alarm_tm);\r\n}\r\nret = rtc_tm_to_time(&alarm_tm, &time);\r\nwritew(readw(ioaddr + RTC_RTCISR), ioaddr + RTC_RTCISR);\r\nset_alarm_or_time(dev, MXC_RTC_ALARM, time);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t mxc_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = dev_id;\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 status;\r\nu32 events = 0;\r\nspin_lock_irq(&pdata->rtc->irq_lock);\r\nstatus = readw(ioaddr + RTC_RTCISR) & readw(ioaddr + RTC_RTCIENR);\r\nwritew(status, ioaddr + RTC_RTCISR);\r\nif (status & RTC_ALM_BIT)\r\nstatus &= ~RTC_ALM_BIT;\r\nif (status & RTC_ALM_BIT)\r\nevents |= (RTC_AF | RTC_IRQF);\r\nif (status & RTC_1HZ_BIT)\r\nevents |= (RTC_UF | RTC_IRQF);\r\nif (status & PIT_ALL_ON)\r\nevents |= (RTC_PF | RTC_IRQF);\r\nif ((status & RTC_ALM_BIT) && rtc_valid_tm(&pdata->g_rtc_alarm))\r\nrtc_update_alarm(&pdev->dev, &pdata->g_rtc_alarm);\r\nrtc_update_irq(pdata->rtc, 1, events);\r\nspin_unlock_irq(&pdata->rtc->irq_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mxc_rtc_release(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nspin_lock_irq(&pdata->rtc->irq_lock);\r\nwritew(0, ioaddr + RTC_RTCIENR);\r\nwritew(0xffffffff, ioaddr + RTC_RTCISR);\r\nspin_unlock_irq(&pdata->rtc->irq_lock);\r\n}\r\nstatic void mxc_rtc_irq_enable(struct device *dev, unsigned int bit,\r\nunsigned int enabled)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 reg;\r\nspin_lock_irq(&pdata->rtc->irq_lock);\r\nreg = readw(ioaddr + RTC_RTCIENR);\r\nif (enabled)\r\nreg |= bit;\r\nelse\r\nreg &= ~bit;\r\nwritew(reg, ioaddr + RTC_RTCIENR);\r\nspin_unlock_irq(&pdata->rtc->irq_lock);\r\n}\r\nstatic int mxc_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nmxc_rtc_irq_enable(dev, RTC_ALM_BIT, enabled);\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nu32 val;\r\ndo {\r\nval = get_alarm_or_time(dev, MXC_RTC_TIME);\r\n} while (val != get_alarm_or_time(dev, MXC_RTC_TIME));\r\nrtc_time_to_tm(val, tm);\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_set_mmss(struct device *dev, unsigned long time)\r\n{\r\ndo {\r\nset_alarm_or_time(dev, MXC_RTC_TIME, time);\r\n} while (time != get_alarm_or_time(dev, MXC_RTC_TIME));\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nrtc_time_to_tm(get_alarm_or_time(dev, MXC_RTC_ALARM), &alrm->time);\r\nalrm->pending = ((readw(ioaddr + RTC_RTCISR) & RTC_ALM_BIT)) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int mxc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nint ret;\r\nif (rtc_valid_tm(&alrm->time)) {\r\nif (alrm->time.tm_sec > 59 ||\r\nalrm->time.tm_hour > 23 ||\r\nalrm->time.tm_min > 59)\r\nreturn -EINVAL;\r\nret = rtc_update_alarm(dev, &alrm->time);\r\n} else {\r\nret = rtc_valid_tm(&alrm->time);\r\nif (ret)\r\nreturn ret;\r\nret = rtc_update_alarm(dev, &alrm->time);\r\n}\r\nif (ret)\r\nreturn ret;\r\nmemcpy(&pdata->g_rtc_alarm, &alrm->time, sizeof(struct rtc_time));\r\nmxc_rtc_irq_enable(dev, RTC_ALM_BIT, alrm->enabled);\r\nreturn 0;\r\n}\r\nstatic int __init mxc_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct rtc_device *rtc;\r\nstruct rtc_plat_data *pdata = NULL;\r\nu32 reg;\r\nunsigned long rate;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name))\r\nreturn -EBUSY;\r\npdata->ioaddr = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\npdata->clk = clk_get(&pdev->dev, "rtc");\r\nif (IS_ERR(pdata->clk)) {\r\ndev_err(&pdev->dev, "unable to get clock!\n");\r\nret = PTR_ERR(pdata->clk);\r\ngoto exit_free_pdata;\r\n}\r\nclk_enable(pdata->clk);\r\nrate = clk_get_rate(pdata->clk);\r\nif (rate == 32768)\r\nreg = RTC_INPUT_CLK_32768HZ;\r\nelse if (rate == 32000)\r\nreg = RTC_INPUT_CLK_32000HZ;\r\nelse if (rate == 38400)\r\nreg = RTC_INPUT_CLK_38400HZ;\r\nelse {\r\ndev_err(&pdev->dev, "rtc clock is not valid (%lu)\n", rate);\r\nret = -EINVAL;\r\ngoto exit_put_clk;\r\n}\r\nreg |= RTC_ENABLE_BIT;\r\nwritew(reg, (pdata->ioaddr + RTC_RTCCTL));\r\nif (((readw(pdata->ioaddr + RTC_RTCCTL)) & RTC_ENABLE_BIT) == 0) {\r\ndev_err(&pdev->dev, "hardware module can't be enabled!\n");\r\nret = -EIO;\r\ngoto exit_put_clk;\r\n}\r\nplatform_set_drvdata(pdev, pdata);\r\npdata->irq = platform_get_irq(pdev, 0);\r\nif (pdata->irq >= 0 &&\r\ndevm_request_irq(&pdev->dev, pdata->irq, mxc_rtc_interrupt,\r\nIRQF_SHARED, pdev->name, pdev) < 0) {\r\ndev_warn(&pdev->dev, "interrupt not available.\n");\r\npdata->irq = -1;\r\n}\r\nrtc = rtc_device_register(pdev->name, &pdev->dev, &mxc_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\nret = PTR_ERR(rtc);\r\ngoto exit_clr_drvdata;\r\n}\r\npdata->rtc = rtc;\r\nreturn 0;\r\nexit_clr_drvdata:\r\nplatform_set_drvdata(pdev, NULL);\r\nexit_put_clk:\r\nclk_disable(pdata->clk);\r\nclk_put(pdata->clk);\r\nexit_free_pdata:\r\nreturn ret;\r\n}\r\nstatic int __exit mxc_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nrtc_device_unregister(pdata->rtc);\r\nclk_disable(pdata->clk);\r\nclk_put(pdata->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init mxc_rtc_init(void)\r\n{\r\nreturn platform_driver_probe(&mxc_rtc_driver, mxc_rtc_probe);\r\n}\r\nstatic void __exit mxc_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&mxc_rtc_driver);\r\n}
