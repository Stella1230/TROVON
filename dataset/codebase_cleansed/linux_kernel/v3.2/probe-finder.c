static int line_list__add_line(struct list_head *head, int line)\r\n{\r\nstruct line_node *ln;\r\nstruct list_head *p;\r\nlist_for_each_entry_reverse(ln, head, list) {\r\nif (ln->line < line) {\r\np = &ln->list;\r\ngoto found;\r\n} else if (ln->line == line)\r\nreturn 1;\r\n}\r\np = head;\r\nfound:\r\npr_debug("line list: add a line %u\n", line);\r\nln = zalloc(sizeof(struct line_node));\r\nif (ln == NULL)\r\nreturn -ENOMEM;\r\nln->line = line;\r\nINIT_LIST_HEAD(&ln->list);\r\nlist_add(&ln->list, p);\r\nreturn 0;\r\n}\r\nstatic int line_list__has_line(struct list_head *head, int line)\r\n{\r\nstruct line_node *ln;\r\nlist_for_each_entry(ln, head, list)\r\nif (ln->line == line)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void line_list__init(struct list_head *head)\r\n{\r\nINIT_LIST_HEAD(head);\r\n}\r\nstatic void line_list__free(struct list_head *head)\r\n{\r\nstruct line_node *ln;\r\nwhile (!list_empty(head)) {\r\nln = list_first_entry(head, struct line_node, list);\r\nlist_del(&ln->list);\r\nfree(ln);\r\n}\r\n}\r\nstatic int debuginfo__init_offline_dwarf(struct debuginfo *self,\r\nconst char *path)\r\n{\r\nDwfl_Module *mod;\r\nint fd;\r\nfd = open(path, O_RDONLY);\r\nif (fd < 0)\r\nreturn fd;\r\nself->dwfl = dwfl_begin(&offline_callbacks);\r\nif (!self->dwfl)\r\ngoto error;\r\nmod = dwfl_report_offline(self->dwfl, "", "", fd);\r\nif (!mod)\r\ngoto error;\r\nself->dbg = dwfl_module_getdwarf(mod, &self->bias);\r\nif (!self->dbg)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nif (self->dwfl)\r\ndwfl_end(self->dwfl);\r\nelse\r\nclose(fd);\r\nmemset(self, 0, sizeof(*self));\r\nreturn -ENOENT;\r\n}\r\nstatic int __linux_kernel_find_elf(Dwfl_Module *mod,\r\nvoid **userdata,\r\nconst char *module_name,\r\nDwarf_Addr base,\r\nchar **file_name, Elf **elfp)\r\n{\r\nint fd;\r\nconst char *path = kernel_get_module_path(module_name);\r\npr_debug2("Use file %s for %s\n", path, module_name);\r\nif (path) {\r\nfd = open(path, O_RDONLY);\r\nif (fd >= 0) {\r\n*file_name = strdup(path);\r\nreturn fd;\r\n}\r\n}\r\nreturn dwfl_linux_kernel_find_elf(mod, userdata, module_name, base,\r\nfile_name, elfp);\r\n}\r\nstatic int debuginfo__init_online_kernel_dwarf(struct debuginfo *self,\r\nDwarf_Addr addr)\r\n{\r\nself->dwfl = dwfl_begin(&kernel_callbacks);\r\nif (!self->dwfl)\r\nreturn -EINVAL;\r\ndwfl_linux_kernel_report_kernel(self->dwfl);\r\ndwfl_linux_kernel_report_modules(self->dwfl);\r\nself->dbg = dwfl_addrdwarf(self->dwfl, addr, &self->bias);\r\nif (!self->dbg) {\r\npr_debug("Failed to find kernel dwarf at %lx\n",\r\n(unsigned long)addr);\r\ndwfl_end(self->dwfl);\r\nmemset(self, 0, sizeof(*self));\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int debuginfo__init_online_kernel_dwarf(struct debuginfo *self,\r\nDwarf_Addr addr __used)\r\n{\r\nconst char *path = kernel_get_module_path("kernel");\r\nif (!path) {\r\npr_err("Failed to find vmlinux path\n");\r\nreturn -ENOENT;\r\n}\r\npr_debug2("Use file %s for debuginfo\n", path);\r\nreturn debuginfo__init_offline_dwarf(self, path);\r\n}\r\nstruct debuginfo *debuginfo__new(const char *path)\r\n{\r\nstruct debuginfo *self = zalloc(sizeof(struct debuginfo));\r\nif (!self)\r\nreturn NULL;\r\nif (debuginfo__init_offline_dwarf(self, path) < 0) {\r\nfree(self);\r\nself = NULL;\r\n}\r\nreturn self;\r\n}\r\nstruct debuginfo *debuginfo__new_online_kernel(unsigned long addr)\r\n{\r\nstruct debuginfo *self = zalloc(sizeof(struct debuginfo));\r\nif (!self)\r\nreturn NULL;\r\nif (debuginfo__init_online_kernel_dwarf(self, (Dwarf_Addr)addr) < 0) {\r\nfree(self);\r\nself = NULL;\r\n}\r\nreturn self;\r\n}\r\nvoid debuginfo__delete(struct debuginfo *self)\r\n{\r\nif (self) {\r\nif (self->dwfl)\r\ndwfl_end(self->dwfl);\r\nfree(self);\r\n}\r\n}\r\nstatic struct probe_trace_arg_ref *alloc_trace_arg_ref(long offs)\r\n{\r\nstruct probe_trace_arg_ref *ref;\r\nref = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (ref != NULL)\r\nref->offset = offs;\r\nreturn ref;\r\n}\r\nstatic int convert_variable_location(Dwarf_Die *vr_die, Dwarf_Addr addr,\r\nDwarf_Op *fb_ops,\r\nstruct probe_trace_arg *tvar)\r\n{\r\nDwarf_Attribute attr;\r\nDwarf_Op *op;\r\nsize_t nops;\r\nunsigned int regn;\r\nDwarf_Word offs = 0;\r\nbool ref = false;\r\nconst char *regs;\r\nint ret;\r\nif (dwarf_attr(vr_die, DW_AT_external, &attr) != NULL)\r\ngoto static_var;\r\nif (dwarf_attr(vr_die, DW_AT_location, &attr) == NULL ||\r\ndwarf_getlocation_addr(&attr, addr, &op, &nops, 1) <= 0 ||\r\nnops == 0) {\r\nreturn -ENOENT;\r\n}\r\nif (op->atom == DW_OP_addr) {\r\nstatic_var:\r\nif (!tvar)\r\nreturn 0;\r\nret = strlen(dwarf_diename(vr_die));\r\ntvar->value = zalloc(ret + 2);\r\nif (tvar->value == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(tvar->value, ret + 2, "@%s", dwarf_diename(vr_die));\r\ntvar->ref = alloc_trace_arg_ref((long)offs);\r\nif (tvar->ref == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nif (op->atom == DW_OP_fbreg) {\r\nif (fb_ops == NULL)\r\nreturn -ENOTSUP;\r\nref = true;\r\noffs = op->number;\r\nop = &fb_ops[0];\r\n}\r\nif (op->atom >= DW_OP_breg0 && op->atom <= DW_OP_breg31) {\r\nregn = op->atom - DW_OP_breg0;\r\noffs += op->number;\r\nref = true;\r\n} else if (op->atom >= DW_OP_reg0 && op->atom <= DW_OP_reg31) {\r\nregn = op->atom - DW_OP_reg0;\r\n} else if (op->atom == DW_OP_bregx) {\r\nregn = op->number;\r\noffs += op->number2;\r\nref = true;\r\n} else if (op->atom == DW_OP_regx) {\r\nregn = op->number;\r\n} else {\r\npr_debug("DW_OP %x is not supported.\n", op->atom);\r\nreturn -ENOTSUP;\r\n}\r\nif (!tvar)\r\nreturn 0;\r\nregs = get_arch_regstr(regn);\r\nif (!regs) {\r\npr_warning("Mapping for the register number %u "\r\n"missing on this architecture.\n", regn);\r\nreturn -ERANGE;\r\n}\r\ntvar->value = strdup(regs);\r\nif (tvar->value == NULL)\r\nreturn -ENOMEM;\r\nif (ref) {\r\ntvar->ref = alloc_trace_arg_ref((long)offs);\r\nif (tvar->ref == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int convert_variable_type(Dwarf_Die *vr_die,\r\nstruct probe_trace_arg *tvar,\r\nconst char *cast)\r\n{\r\nstruct probe_trace_arg_ref **ref_ptr = &tvar->ref;\r\nDwarf_Die type;\r\nchar buf[16];\r\nint bsize, boffs, total;\r\nint ret;\r\nif (cast && strcmp(cast, "string") != 0) {\r\ntvar->type = strdup(cast);\r\nreturn (tvar->type == NULL) ? -ENOMEM : 0;\r\n}\r\nbsize = dwarf_bitsize(vr_die);\r\nif (bsize > 0) {\r\nboffs = dwarf_bitoffset(vr_die);\r\ntotal = dwarf_bytesize(vr_die);\r\nif (boffs < 0 || total < 0)\r\nreturn -ENOENT;\r\nret = snprintf(buf, 16, "b%d@%d/%zd", bsize, boffs,\r\nBYTES_TO_BITS(total));\r\ngoto formatted;\r\n}\r\nif (die_get_real_type(vr_die, &type) == NULL) {\r\npr_warning("Failed to get a type information of %s.\n",\r\ndwarf_diename(vr_die));\r\nreturn -ENOENT;\r\n}\r\npr_debug("%s type is %s.\n",\r\ndwarf_diename(vr_die), dwarf_diename(&type));\r\nif (cast && strcmp(cast, "string") == 0) {\r\nret = dwarf_tag(&type);\r\nif (ret != DW_TAG_pointer_type &&\r\nret != DW_TAG_array_type) {\r\npr_warning("Failed to cast into string: "\r\n"%s(%s) is not a pointer nor array.\n",\r\ndwarf_diename(vr_die), dwarf_diename(&type));\r\nreturn -EINVAL;\r\n}\r\nif (ret == DW_TAG_pointer_type) {\r\nif (die_get_real_type(&type, &type) == NULL) {\r\npr_warning("Failed to get a type"\r\n" information.\n");\r\nreturn -ENOENT;\r\n}\r\nwhile (*ref_ptr)\r\nref_ptr = &(*ref_ptr)->next;\r\n*ref_ptr = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (*ref_ptr == NULL) {\r\npr_warning("Out of memory error\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!die_compare_name(&type, "char") &&\r\n!die_compare_name(&type, "unsigned char")) {\r\npr_warning("Failed to cast into string: "\r\n"%s is not (unsigned) char *.\n",\r\ndwarf_diename(vr_die));\r\nreturn -EINVAL;\r\n}\r\ntvar->type = strdup(cast);\r\nreturn (tvar->type == NULL) ? -ENOMEM : 0;\r\n}\r\nret = dwarf_bytesize(&type);\r\nif (ret <= 0)\r\nreturn 0;\r\nret = BYTES_TO_BITS(ret);\r\nif (ret > MAX_BASIC_TYPE_BITS) {\r\npr_info("%s exceeds max-bitwidth. Cut down to %d bits.\n",\r\ndwarf_diename(&type), MAX_BASIC_TYPE_BITS);\r\nret = MAX_BASIC_TYPE_BITS;\r\n}\r\nret = snprintf(buf, 16, "%c%d",\r\ndie_is_signed_type(&type) ? 's' : 'u', ret);\r\nformatted:\r\nif (ret < 0 || ret >= 16) {\r\nif (ret >= 16)\r\nret = -E2BIG;\r\npr_warning("Failed to convert variable type: %s\n",\r\nstrerror(-ret));\r\nreturn ret;\r\n}\r\ntvar->type = strdup(buf);\r\nif (tvar->type == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,\r\nstruct perf_probe_arg_field *field,\r\nstruct probe_trace_arg_ref **ref_ptr,\r\nDwarf_Die *die_mem)\r\n{\r\nstruct probe_trace_arg_ref *ref = *ref_ptr;\r\nDwarf_Die type;\r\nDwarf_Word offs;\r\nint ret, tag;\r\npr_debug("converting %s in %s\n", field->name, varname);\r\nif (die_get_real_type(vr_die, &type) == NULL) {\r\npr_warning("Failed to get the type of %s.\n", varname);\r\nreturn -ENOENT;\r\n}\r\npr_debug2("Var real type: (%x)\n", (unsigned)dwarf_dieoffset(&type));\r\ntag = dwarf_tag(&type);\r\nif (field->name[0] == '[' &&\r\n(tag == DW_TAG_array_type || tag == DW_TAG_pointer_type)) {\r\nif (field->next)\r\nmemcpy(die_mem, &type, sizeof(*die_mem));\r\nif (die_get_real_type(&type, &type) == NULL) {\r\npr_warning("Failed to get the type of %s.\n", varname);\r\nreturn -ENOENT;\r\n}\r\npr_debug2("Array real type: (%x)\n",\r\n(unsigned)dwarf_dieoffset(&type));\r\nif (tag == DW_TAG_pointer_type) {\r\nref = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (ref == NULL)\r\nreturn -ENOMEM;\r\nif (*ref_ptr)\r\n(*ref_ptr)->next = ref;\r\nelse\r\n*ref_ptr = ref;\r\n}\r\nref->offset += dwarf_bytesize(&type) * field->index;\r\nif (!field->next)\r\nmemcpy(die_mem, vr_die, sizeof(*die_mem));\r\ngoto next;\r\n} else if (tag == DW_TAG_pointer_type) {\r\nif (!field->ref) {\r\npr_err("Semantic error: %s must be referred by '->'\n",\r\nfield->name);\r\nreturn -EINVAL;\r\n}\r\nif (die_get_real_type(&type, &type) == NULL) {\r\npr_warning("Failed to get the type of %s.\n", varname);\r\nreturn -ENOENT;\r\n}\r\nif (dwarf_tag(&type) != DW_TAG_structure_type) {\r\npr_warning("%s is not a data structure.\n", varname);\r\nreturn -EINVAL;\r\n}\r\nref = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (ref == NULL)\r\nreturn -ENOMEM;\r\nif (*ref_ptr)\r\n(*ref_ptr)->next = ref;\r\nelse\r\n*ref_ptr = ref;\r\n} else {\r\nif (tag != DW_TAG_structure_type) {\r\npr_warning("%s is not a data structure.\n", varname);\r\nreturn -EINVAL;\r\n}\r\nif (field->name[0] == '[') {\r\npr_err("Semantic error: %s is not a pointor"\r\n" nor array.\n", varname);\r\nreturn -EINVAL;\r\n}\r\nif (field->ref) {\r\npr_err("Semantic error: %s must be referred by '.'\n",\r\nfield->name);\r\nreturn -EINVAL;\r\n}\r\nif (!ref) {\r\npr_warning("Structure on a register is not "\r\n"supported yet.\n");\r\nreturn -ENOTSUP;\r\n}\r\n}\r\nif (die_find_member(&type, field->name, die_mem) == NULL) {\r\npr_warning("%s(tyep:%s) has no member %s.\n", varname,\r\ndwarf_diename(&type), field->name);\r\nreturn -EINVAL;\r\n}\r\nret = die_get_data_member_location(die_mem, &offs);\r\nif (ret < 0) {\r\npr_warning("Failed to get the offset of %s.\n", field->name);\r\nreturn ret;\r\n}\r\nref->offset += (long)offs;\r\nnext:\r\nif (field->next)\r\nreturn convert_variable_fields(die_mem, field->name,\r\nfield->next, &ref, die_mem);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int convert_variable(Dwarf_Die *vr_die, struct probe_finder *pf)\r\n{\r\nDwarf_Die die_mem;\r\nint ret;\r\npr_debug("Converting variable %s into trace event.\n",\r\ndwarf_diename(vr_die));\r\nret = convert_variable_location(vr_die, pf->addr, pf->fb_ops,\r\npf->tvar);\r\nif (ret == -ENOENT)\r\npr_err("Failed to find the location of %s at this address.\n"\r\n" Perhaps, it has been optimized out.\n", pf->pvar->var);\r\nelse if (ret == -ENOTSUP)\r\npr_err("Sorry, we don't support this variable location yet.\n");\r\nelse if (pf->pvar->field) {\r\nret = convert_variable_fields(vr_die, pf->pvar->var,\r\npf->pvar->field, &pf->tvar->ref,\r\n&die_mem);\r\nvr_die = &die_mem;\r\n}\r\nif (ret == 0)\r\nret = convert_variable_type(vr_die, pf->tvar, pf->pvar->type);\r\nreturn ret;\r\n}\r\nstatic int find_variable(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nDwarf_Die vr_die;\r\nchar buf[32], *ptr;\r\nint ret = 0;\r\nif (!is_c_varname(pf->pvar->var)) {\r\npf->tvar->value = strdup(pf->pvar->var);\r\nif (pf->tvar->value == NULL)\r\nreturn -ENOMEM;\r\nif (pf->pvar->type) {\r\npf->tvar->type = strdup(pf->pvar->type);\r\nif (pf->tvar->type == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (pf->pvar->name) {\r\npf->tvar->name = strdup(pf->pvar->name);\r\nif (pf->tvar->name == NULL)\r\nreturn -ENOMEM;\r\n} else\r\npf->tvar->name = NULL;\r\nreturn 0;\r\n}\r\nif (pf->pvar->name)\r\npf->tvar->name = strdup(pf->pvar->name);\r\nelse {\r\nret = synthesize_perf_probe_arg(pf->pvar, buf, 32);\r\nif (ret < 0)\r\nreturn ret;\r\nptr = strchr(buf, ':');\r\nif (ptr)\r\n*ptr = '_';\r\npf->tvar->name = strdup(buf);\r\n}\r\nif (pf->tvar->name == NULL)\r\nreturn -ENOMEM;\r\npr_debug("Searching '%s' variable in context.\n", pf->pvar->var);\r\nif (!die_find_variable_at(sc_die, pf->pvar->var, pf->addr, &vr_die)) {\r\nif (!die_find_variable_at(&pf->cu_die, pf->pvar->var, 0, &vr_die))\r\nret = -ENOENT;\r\n}\r\nif (ret >= 0)\r\nret = convert_variable(&vr_die, pf);\r\nif (ret < 0)\r\npr_warning("Failed to find '%s' in this function.\n",\r\npf->pvar->var);\r\nreturn ret;\r\n}\r\nstatic int convert_to_trace_point(Dwarf_Die *sp_die, Dwarf_Addr paddr,\r\nbool retprobe, struct probe_trace_point *tp)\r\n{\r\nDwarf_Addr eaddr;\r\nconst char *name;\r\nname = dwarf_diename(sp_die);\r\nif (name) {\r\nif (dwarf_entrypc(sp_die, &eaddr) != 0) {\r\npr_warning("Failed to get entry address of %s\n",\r\ndwarf_diename(sp_die));\r\nreturn -ENOENT;\r\n}\r\ntp->symbol = strdup(name);\r\nif (tp->symbol == NULL)\r\nreturn -ENOMEM;\r\ntp->offset = (unsigned long)(paddr - eaddr);\r\n} else\r\ntp->offset = (unsigned long)paddr;\r\nif (retprobe) {\r\nif (eaddr != paddr) {\r\npr_warning("Return probe must be on the head of"\r\n" a real function.\n");\r\nreturn -EINVAL;\r\n}\r\ntp->retprobe = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int call_probe_finder(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nDwarf_Attribute fb_attr;\r\nsize_t nops;\r\nint ret;\r\nif (!sc_die) {\r\npr_err("Caller must pass a scope DIE. Program error.\n");\r\nreturn -EINVAL;\r\n}\r\nif (dwarf_tag(sc_die) != DW_TAG_subprogram) {\r\nif (!die_find_realfunc(&pf->cu_die, pf->addr, &pf->sp_die)) {\r\npr_warning("Failed to find probe point in any "\r\n"functions.\n");\r\nreturn -ENOENT;\r\n}\r\n} else\r\nmemcpy(&pf->sp_die, sc_die, sizeof(Dwarf_Die));\r\ndwarf_attr(&pf->sp_die, DW_AT_frame_base, &fb_attr);\r\nret = dwarf_getlocation_addr(&fb_attr, pf->addr, &pf->fb_ops, &nops, 1);\r\nif (ret <= 0 || nops == 0) {\r\npf->fb_ops = NULL;\r\n#if _ELFUTILS_PREREQ(0, 142)\r\n} else if (nops == 1 && pf->fb_ops[0].atom == DW_OP_call_frame_cfa &&\r\npf->cfi != NULL) {\r\nDwarf_Frame *frame;\r\nif (dwarf_cfi_addrframe(pf->cfi, pf->addr, &frame) != 0 ||\r\ndwarf_frame_cfa(frame, &pf->fb_ops, &nops) != 0) {\r\npr_warning("Failed to get call frame on 0x%jx\n",\r\n(uintmax_t)pf->addr);\r\nreturn -ENOENT;\r\n}\r\n#endif\r\n}\r\nret = pf->callback(sc_die, pf);\r\npf->fb_ops = NULL;\r\nreturn ret;\r\n}\r\nstatic int find_best_scope_cb(Dwarf_Die *fn_die, void *data)\r\n{\r\nstruct find_scope_param *fsp = data;\r\nconst char *file;\r\nint lno;\r\nif (fsp->file) {\r\nfile = dwarf_decl_file(fn_die);\r\nif (!file || strcmp(fsp->file, file) != 0)\r\nreturn 0;\r\n}\r\nif (fsp->function) {\r\nif (die_compare_name(fn_die, fsp->function)) {\r\nmemcpy(fsp->die_mem, fn_die, sizeof(Dwarf_Die));\r\nfsp->found = true;\r\nreturn 1;\r\n}\r\n} else {\r\ndwarf_decl_line(fn_die, &lno);\r\nif (lno < fsp->line && fsp->diff > fsp->line - lno) {\r\nfsp->diff = fsp->line - lno;\r\nmemcpy(fsp->die_mem, fn_die, sizeof(Dwarf_Die));\r\nfsp->found = true;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic Dwarf_Die *find_best_scope(struct probe_finder *pf, Dwarf_Die *die_mem)\r\n{\r\nstruct find_scope_param fsp = {\r\n.function = pf->pev->point.function,\r\n.file = pf->fname,\r\n.line = pf->lno,\r\n.diff = INT_MAX,\r\n.die_mem = die_mem,\r\n.found = false,\r\n};\r\ncu_walk_functions_at(&pf->cu_die, pf->addr, find_best_scope_cb, &fsp);\r\nreturn fsp.found ? die_mem : NULL;\r\n}\r\nstatic int probe_point_line_walker(const char *fname, int lineno,\r\nDwarf_Addr addr, void *data)\r\n{\r\nstruct probe_finder *pf = data;\r\nDwarf_Die *sc_die, die_mem;\r\nint ret;\r\nif (lineno != pf->lno || strtailcmp(fname, pf->fname) != 0)\r\nreturn 0;\r\npf->addr = addr;\r\nsc_die = find_best_scope(pf, &die_mem);\r\nif (!sc_die) {\r\npr_warning("Failed to find scope of probe point.\n");\r\nreturn -ENOENT;\r\n}\r\nret = call_probe_finder(sc_die, pf);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int find_probe_point_by_line(struct probe_finder *pf)\r\n{\r\nreturn die_walk_lines(&pf->cu_die, probe_point_line_walker, pf);\r\n}\r\nstatic int find_lazy_match_lines(struct list_head *head,\r\nconst char *fname, const char *pat)\r\n{\r\nFILE *fp;\r\nchar *line = NULL;\r\nsize_t line_len;\r\nssize_t len;\r\nint count = 0, linenum = 1;\r\nfp = fopen(fname, "r");\r\nif (!fp) {\r\npr_warning("Failed to open %s: %s\n", fname, strerror(errno));\r\nreturn -errno;\r\n}\r\nwhile ((len = getline(&line, &line_len, fp)) > 0) {\r\nif (line[len - 1] == '\n')\r\nline[len - 1] = '\0';\r\nif (strlazymatch(line, pat)) {\r\nline_list__add_line(head, linenum);\r\ncount++;\r\n}\r\nlinenum++;\r\n}\r\nif (ferror(fp))\r\ncount = -errno;\r\nfree(line);\r\nfclose(fp);\r\nif (count == 0)\r\npr_debug("No matched lines found in %s.\n", fname);\r\nreturn count;\r\n}\r\nstatic int probe_point_lazy_walker(const char *fname, int lineno,\r\nDwarf_Addr addr, void *data)\r\n{\r\nstruct probe_finder *pf = data;\r\nDwarf_Die *sc_die, die_mem;\r\nint ret;\r\nif (!line_list__has_line(&pf->lcache, lineno) ||\r\nstrtailcmp(fname, pf->fname) != 0)\r\nreturn 0;\r\npr_debug("Probe line found: line:%d addr:0x%llx\n",\r\nlineno, (unsigned long long)addr);\r\npf->addr = addr;\r\npf->lno = lineno;\r\nsc_die = find_best_scope(pf, &die_mem);\r\nif (!sc_die) {\r\npr_warning("Failed to find scope of probe point.\n");\r\nreturn -ENOENT;\r\n}\r\nret = call_probe_finder(sc_die, pf);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int find_probe_point_lazy(Dwarf_Die *sp_die, struct probe_finder *pf)\r\n{\r\nint ret = 0;\r\nif (list_empty(&pf->lcache)) {\r\nret = find_lazy_match_lines(&pf->lcache, pf->fname,\r\npf->pev->point.lazy_line);\r\nif (ret <= 0)\r\nreturn ret;\r\n}\r\nreturn die_walk_lines(sp_die, probe_point_lazy_walker, pf);\r\n}\r\nstatic int probe_point_inline_cb(Dwarf_Die *in_die, void *data)\r\n{\r\nstruct probe_finder *pf = data;\r\nstruct perf_probe_point *pp = &pf->pev->point;\r\nDwarf_Addr addr;\r\nint ret;\r\nif (pp->lazy_line)\r\nret = find_probe_point_lazy(in_die, pf);\r\nelse {\r\nif (dwarf_entrypc(in_die, &addr) != 0) {\r\npr_warning("Failed to get entry address of %s.\n",\r\ndwarf_diename(in_die));\r\nreturn -ENOENT;\r\n}\r\npf->addr = addr;\r\npf->addr += pp->offset;\r\npr_debug("found inline addr: 0x%jx\n",\r\n(uintmax_t)pf->addr);\r\nret = call_probe_finder(in_die, pf);\r\n}\r\nreturn ret;\r\n}\r\nstatic int probe_point_search_cb(Dwarf_Die *sp_die, void *data)\r\n{\r\nstruct dwarf_callback_param *param = data;\r\nstruct probe_finder *pf = param->data;\r\nstruct perf_probe_point *pp = &pf->pev->point;\r\nif (dwarf_tag(sp_die) != DW_TAG_subprogram ||\r\n!die_compare_name(sp_die, pp->function))\r\nreturn DWARF_CB_OK;\r\nif (pp->file && strtailcmp(pp->file, dwarf_decl_file(sp_die)))\r\nreturn DWARF_CB_OK;\r\npf->fname = dwarf_decl_file(sp_die);\r\nif (pp->line) {\r\ndwarf_decl_line(sp_die, &pf->lno);\r\npf->lno += pp->line;\r\nparam->retval = find_probe_point_by_line(pf);\r\n} else if (!dwarf_func_inline(sp_die)) {\r\nif (pp->lazy_line)\r\nparam->retval = find_probe_point_lazy(sp_die, pf);\r\nelse {\r\nif (dwarf_entrypc(sp_die, &pf->addr) != 0) {\r\npr_warning("Failed to get entry address of "\r\n"%s.\n", dwarf_diename(sp_die));\r\nparam->retval = -ENOENT;\r\nreturn DWARF_CB_ABORT;\r\n}\r\npf->addr += pp->offset;\r\nparam->retval = call_probe_finder(sp_die, pf);\r\n}\r\n} else\r\nparam->retval = die_walk_instances(sp_die,\r\nprobe_point_inline_cb, (void *)pf);\r\nreturn DWARF_CB_ABORT;\r\n}\r\nstatic int find_probe_point_by_func(struct probe_finder *pf)\r\n{\r\nstruct dwarf_callback_param _param = {.data = (void *)pf,\r\n.retval = 0};\r\ndwarf_getfuncs(&pf->cu_die, probe_point_search_cb, &_param, 0);\r\nreturn _param.retval;\r\n}\r\nstatic int pubname_search_cb(Dwarf *dbg, Dwarf_Global *gl, void *data)\r\n{\r\nstruct pubname_callback_param *param = data;\r\nif (dwarf_offdie(dbg, gl->die_offset, param->sp_die)) {\r\nif (dwarf_tag(param->sp_die) != DW_TAG_subprogram)\r\nreturn DWARF_CB_OK;\r\nif (die_compare_name(param->sp_die, param->function)) {\r\nif (!dwarf_offdie(dbg, gl->cu_offset, param->cu_die))\r\nreturn DWARF_CB_OK;\r\nif (param->file &&\r\nstrtailcmp(param->file, dwarf_decl_file(param->sp_die)))\r\nreturn DWARF_CB_OK;\r\nparam->found = 1;\r\nreturn DWARF_CB_ABORT;\r\n}\r\n}\r\nreturn DWARF_CB_OK;\r\n}\r\nstatic int debuginfo__find_probes(struct debuginfo *self,\r\nstruct probe_finder *pf)\r\n{\r\nstruct perf_probe_point *pp = &pf->pev->point;\r\nDwarf_Off off, noff;\r\nsize_t cuhl;\r\nDwarf_Die *diep;\r\nint ret = 0;\r\n#if _ELFUTILS_PREREQ(0, 142)\r\npf->cfi = dwarf_getcfi(self->dbg);\r\n#endif\r\noff = 0;\r\nline_list__init(&pf->lcache);\r\nif (pp->function) {\r\nstruct pubname_callback_param pubname_param = {\r\n.function = pp->function,\r\n.file = pp->file,\r\n.cu_die = &pf->cu_die,\r\n.sp_die = &pf->sp_die,\r\n.found = 0,\r\n};\r\nstruct dwarf_callback_param probe_param = {\r\n.data = pf,\r\n};\r\ndwarf_getpubnames(self->dbg, pubname_search_cb,\r\n&pubname_param, 0);\r\nif (pubname_param.found) {\r\nret = probe_point_search_cb(&pf->sp_die, &probe_param);\r\nif (ret)\r\ngoto found;\r\n}\r\n}\r\nwhile (!dwarf_nextcu(self->dbg, off, &noff, &cuhl, NULL, NULL, NULL)) {\r\ndiep = dwarf_offdie(self->dbg, off + cuhl, &pf->cu_die);\r\nif (!diep)\r\ncontinue;\r\nif (pp->file)\r\npf->fname = cu_find_realpath(&pf->cu_die, pp->file);\r\nelse\r\npf->fname = NULL;\r\nif (!pp->file || pf->fname) {\r\nif (pp->function)\r\nret = find_probe_point_by_func(pf);\r\nelse if (pp->lazy_line)\r\nret = find_probe_point_lazy(NULL, pf);\r\nelse {\r\npf->lno = pp->line;\r\nret = find_probe_point_by_line(pf);\r\n}\r\nif (ret < 0)\r\nbreak;\r\n}\r\noff = noff;\r\n}\r\nfound:\r\nline_list__free(&pf->lcache);\r\nreturn ret;\r\n}\r\nstatic int add_probe_trace_event(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nstruct trace_event_finder *tf =\r\ncontainer_of(pf, struct trace_event_finder, pf);\r\nstruct probe_trace_event *tev;\r\nint ret, i;\r\nif (tf->ntevs == tf->max_tevs) {\r\npr_warning("Too many( > %d) probe point found.\n",\r\ntf->max_tevs);\r\nreturn -ERANGE;\r\n}\r\ntev = &tf->tevs[tf->ntevs++];\r\nret = convert_to_trace_point(&pf->sp_die, pf->addr,\r\npf->pev->point.retprobe, &tev->point);\r\nif (ret < 0)\r\nreturn ret;\r\npr_debug("Probe point found: %s+%lu\n", tev->point.symbol,\r\ntev->point.offset);\r\ntev->nargs = pf->pev->nargs;\r\ntev->args = zalloc(sizeof(struct probe_trace_arg) * tev->nargs);\r\nif (tev->args == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pf->pev->nargs; i++) {\r\npf->pvar = &pf->pev->args[i];\r\npf->tvar = &tev->args[i];\r\nret = find_variable(sc_die, pf);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint debuginfo__find_trace_events(struct debuginfo *self,\r\nstruct perf_probe_event *pev,\r\nstruct probe_trace_event **tevs, int max_tevs)\r\n{\r\nstruct trace_event_finder tf = {\r\n.pf = {.pev = pev, .callback = add_probe_trace_event},\r\n.max_tevs = max_tevs};\r\nint ret;\r\n*tevs = zalloc(sizeof(struct probe_trace_event) * max_tevs);\r\nif (*tevs == NULL)\r\nreturn -ENOMEM;\r\ntf.tevs = *tevs;\r\ntf.ntevs = 0;\r\nret = debuginfo__find_probes(self, &tf.pf);\r\nif (ret < 0) {\r\nfree(*tevs);\r\n*tevs = NULL;\r\nreturn ret;\r\n}\r\nreturn (ret < 0) ? ret : tf.ntevs;\r\n}\r\nstatic int collect_variables_cb(Dwarf_Die *die_mem, void *data)\r\n{\r\nstruct available_var_finder *af = data;\r\nstruct variable_list *vl;\r\nchar buf[MAX_VAR_LEN];\r\nint tag, ret;\r\nvl = &af->vls[af->nvls - 1];\r\ntag = dwarf_tag(die_mem);\r\nif (tag == DW_TAG_formal_parameter ||\r\ntag == DW_TAG_variable) {\r\nret = convert_variable_location(die_mem, af->pf.addr,\r\naf->pf.fb_ops, NULL);\r\nif (ret == 0) {\r\nret = die_get_varname(die_mem, buf, MAX_VAR_LEN);\r\npr_debug2("Add new var: %s\n", buf);\r\nif (ret > 0)\r\nstrlist__add(vl->vars, buf);\r\n}\r\n}\r\nif (af->child && dwarf_haspc(die_mem, af->pf.addr))\r\nreturn DIE_FIND_CB_CONTINUE;\r\nelse\r\nreturn DIE_FIND_CB_SIBLING;\r\n}\r\nstatic int add_available_vars(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nstruct available_var_finder *af =\r\ncontainer_of(pf, struct available_var_finder, pf);\r\nstruct variable_list *vl;\r\nDwarf_Die die_mem;\r\nint ret;\r\nif (af->nvls == af->max_vls) {\r\npr_warning("Too many( > %d) probe point found.\n", af->max_vls);\r\nreturn -ERANGE;\r\n}\r\nvl = &af->vls[af->nvls++];\r\nret = convert_to_trace_point(&pf->sp_die, pf->addr,\r\npf->pev->point.retprobe, &vl->point);\r\nif (ret < 0)\r\nreturn ret;\r\npr_debug("Probe point found: %s+%lu\n", vl->point.symbol,\r\nvl->point.offset);\r\nvl->vars = strlist__new(true, NULL);\r\nif (vl->vars == NULL)\r\nreturn -ENOMEM;\r\naf->child = true;\r\ndie_find_child(sc_die, collect_variables_cb, (void *)af, &die_mem);\r\nif (!af->externs)\r\ngoto out;\r\naf->child = false;\r\ndie_find_child(&pf->cu_die, collect_variables_cb, (void *)af, &die_mem);\r\nout:\r\nif (strlist__empty(vl->vars)) {\r\nstrlist__delete(vl->vars);\r\nvl->vars = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint debuginfo__find_available_vars_at(struct debuginfo *self,\r\nstruct perf_probe_event *pev,\r\nstruct variable_list **vls,\r\nint max_vls, bool externs)\r\n{\r\nstruct available_var_finder af = {\r\n.pf = {.pev = pev, .callback = add_available_vars},\r\n.max_vls = max_vls, .externs = externs};\r\nint ret;\r\n*vls = zalloc(sizeof(struct variable_list) * max_vls);\r\nif (*vls == NULL)\r\nreturn -ENOMEM;\r\naf.vls = *vls;\r\naf.nvls = 0;\r\nret = debuginfo__find_probes(self, &af.pf);\r\nif (ret < 0) {\r\nwhile (af.nvls--) {\r\nif (af.vls[af.nvls].point.symbol)\r\nfree(af.vls[af.nvls].point.symbol);\r\nif (af.vls[af.nvls].vars)\r\nstrlist__delete(af.vls[af.nvls].vars);\r\n}\r\nfree(af.vls);\r\n*vls = NULL;\r\nreturn ret;\r\n}\r\nreturn (ret < 0) ? ret : af.nvls;\r\n}\r\nint debuginfo__find_probe_point(struct debuginfo *self, unsigned long addr,\r\nstruct perf_probe_point *ppt)\r\n{\r\nDwarf_Die cudie, spdie, indie;\r\nDwarf_Addr _addr, baseaddr;\r\nconst char *fname = NULL, *func = NULL, *tmp;\r\nint baseline = 0, lineno = 0, ret = 0;\r\naddr += self->bias;\r\nif (!dwarf_addrdie(self->dbg, (Dwarf_Addr)addr - self->bias, &cudie)) {\r\npr_warning("Failed to find debug information for address %lx\n",\r\naddr);\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\ncu_find_lineinfo(&cudie, addr, &fname, &lineno);\r\nif (die_find_realfunc(&cudie, (Dwarf_Addr)addr, &spdie)) {\r\ntmp = dwarf_diename(&spdie);\r\nif (!tmp ||\r\ndwarf_entrypc(&spdie, &baseaddr) != 0 ||\r\ndwarf_decl_line(&spdie, &baseline) != 0)\r\ngoto post;\r\nfunc = tmp;\r\nif (addr == (unsigned long)baseaddr)\r\nlineno = baseline;\r\nelse if (die_find_inlinefunc(&spdie, (Dwarf_Addr)addr,\r\n&indie)) {\r\nif (dwarf_entrypc(&indie, &_addr) == 0 &&\r\n_addr == addr)\r\nlineno = die_get_call_lineno(&indie);\r\nelse {\r\ntmp = dwarf_diename(&indie);\r\nif (tmp &&\r\ndwarf_decl_line(&spdie, &baseline) == 0)\r\nfunc = tmp;\r\n}\r\n}\r\n}\r\npost:\r\nif (lineno)\r\nppt->line = lineno - baseline;\r\nelse if (func)\r\nppt->offset = addr - (unsigned long)baseaddr;\r\nif (func) {\r\nppt->function = strdup(func);\r\nif (ppt->function == NULL) {\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\n}\r\nif (fname) {\r\nppt->file = strdup(fname);\r\nif (ppt->file == NULL) {\r\nif (ppt->function) {\r\nfree(ppt->function);\r\nppt->function = NULL;\r\n}\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\n}\r\nend:\r\nif (ret == 0 && (fname || func))\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic int line_range_add_line(const char *src, unsigned int lineno,\r\nstruct line_range *lr)\r\n{\r\nif (!lr->path) {\r\nlr->path = strdup(src);\r\nif (lr->path == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn line_list__add_line(&lr->line_list, lineno);\r\n}\r\nstatic int line_range_walk_cb(const char *fname, int lineno,\r\nDwarf_Addr addr __used,\r\nvoid *data)\r\n{\r\nstruct line_finder *lf = data;\r\nif ((strtailcmp(fname, lf->fname) != 0) ||\r\n(lf->lno_s > lineno || lf->lno_e < lineno))\r\nreturn 0;\r\nif (line_range_add_line(fname, lineno, lf->lr) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int find_line_range_by_line(Dwarf_Die *sp_die, struct line_finder *lf)\r\n{\r\nint ret;\r\nret = die_walk_lines(sp_die ?: &lf->cu_die, line_range_walk_cb, lf);\r\nif (ret >= 0)\r\nif (!list_empty(&lf->lr->line_list))\r\nret = lf->found = 1;\r\nelse\r\nret = 0;\r\nelse {\r\nfree(lf->lr->path);\r\nlf->lr->path = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int line_range_inline_cb(Dwarf_Die *in_die, void *data)\r\n{\r\nfind_line_range_by_line(in_die, data);\r\nreturn 0;\r\n}\r\nstatic int line_range_search_cb(Dwarf_Die *sp_die, void *data)\r\n{\r\nstruct dwarf_callback_param *param = data;\r\nstruct line_finder *lf = param->data;\r\nstruct line_range *lr = lf->lr;\r\nif (lr->file && strtailcmp(lr->file, dwarf_decl_file(sp_die)))\r\nreturn DWARF_CB_OK;\r\nif (dwarf_tag(sp_die) == DW_TAG_subprogram &&\r\ndie_compare_name(sp_die, lr->function)) {\r\nlf->fname = dwarf_decl_file(sp_die);\r\ndwarf_decl_line(sp_die, &lr->offset);\r\npr_debug("fname: %s, lineno:%d\n", lf->fname, lr->offset);\r\nlf->lno_s = lr->offset + lr->start;\r\nif (lf->lno_s < 0)\r\nlf->lno_s = INT_MAX;\r\nlf->lno_e = lr->offset + lr->end;\r\nif (lf->lno_e < 0)\r\nlf->lno_e = INT_MAX;\r\npr_debug("New line range: %d to %d\n", lf->lno_s, lf->lno_e);\r\nlr->start = lf->lno_s;\r\nlr->end = lf->lno_e;\r\nif (dwarf_func_inline(sp_die))\r\nparam->retval = die_walk_instances(sp_die,\r\nline_range_inline_cb, lf);\r\nelse\r\nparam->retval = find_line_range_by_line(sp_die, lf);\r\nreturn DWARF_CB_ABORT;\r\n}\r\nreturn DWARF_CB_OK;\r\n}\r\nstatic int find_line_range_by_func(struct line_finder *lf)\r\n{\r\nstruct dwarf_callback_param param = {.data = (void *)lf, .retval = 0};\r\ndwarf_getfuncs(&lf->cu_die, line_range_search_cb, &param, 0);\r\nreturn param.retval;\r\n}\r\nint debuginfo__find_line_range(struct debuginfo *self, struct line_range *lr)\r\n{\r\nstruct line_finder lf = {.lr = lr, .found = 0};\r\nint ret = 0;\r\nDwarf_Off off = 0, noff;\r\nsize_t cuhl;\r\nDwarf_Die *diep;\r\nconst char *comp_dir;\r\nif (lr->function) {\r\nstruct pubname_callback_param pubname_param = {\r\n.function = lr->function, .file = lr->file,\r\n.cu_die = &lf.cu_die, .sp_die = &lf.sp_die, .found = 0};\r\nstruct dwarf_callback_param line_range_param = {\r\n.data = (void *)&lf, .retval = 0};\r\ndwarf_getpubnames(self->dbg, pubname_search_cb,\r\n&pubname_param, 0);\r\nif (pubname_param.found) {\r\nline_range_search_cb(&lf.sp_die, &line_range_param);\r\nif (lf.found)\r\ngoto found;\r\n}\r\n}\r\nwhile (!lf.found && ret >= 0) {\r\nif (dwarf_nextcu(self->dbg, off, &noff, &cuhl,\r\nNULL, NULL, NULL) != 0)\r\nbreak;\r\ndiep = dwarf_offdie(self->dbg, off + cuhl, &lf.cu_die);\r\nif (!diep)\r\ncontinue;\r\nif (lr->file)\r\nlf.fname = cu_find_realpath(&lf.cu_die, lr->file);\r\nelse\r\nlf.fname = 0;\r\nif (!lr->file || lf.fname) {\r\nif (lr->function)\r\nret = find_line_range_by_func(&lf);\r\nelse {\r\nlf.lno_s = lr->start;\r\nlf.lno_e = lr->end;\r\nret = find_line_range_by_line(NULL, &lf);\r\n}\r\n}\r\noff = noff;\r\n}\r\nfound:\r\nif (lf.found) {\r\ncomp_dir = cu_get_comp_dir(&lf.cu_die);\r\nif (comp_dir) {\r\nlr->comp_dir = strdup(comp_dir);\r\nif (!lr->comp_dir)\r\nret = -ENOMEM;\r\n}\r\n}\r\npr_debug("path: %s\n", lr->path);\r\nreturn (ret < 0) ? ret : lf.found;\r\n}
