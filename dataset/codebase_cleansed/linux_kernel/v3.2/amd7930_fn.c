static void\r\nWriteWordAmd7930(struct IsdnCardState *cs, BYTE reg, WORD val)\r\n{\r\nwByteAMD(cs, 0x00, reg);\r\nwByteAMD(cs, 0x01, LOBYTE(val));\r\nwByteAMD(cs, 0x01, HIBYTE(val));\r\n}\r\nstatic WORD\r\nReadWordAmd7930(struct IsdnCardState *cs, BYTE reg)\r\n{\r\nWORD res;\r\nif(reg < 8) {\r\nres = rByteAMD(cs, reg);\r\nres += 256*rByteAMD(cs, reg);\r\n}\r\nelse {\r\nwByteAMD(cs, 0x00, reg);\r\nres = rByteAMD(cs, 0x01);\r\nres += 256*rByteAMD(cs, 0x01);\r\n}\r\nreturn (res);\r\n}\r\nstatic void\r\nAmd7930_ph_command(struct IsdnCardState *cs, u_char command, char *s)\r\n{\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "AMD7930: %s: ph_command 0x%02X", s, command);\r\ncs->dc.amd7930.lmr1 = command;\r\nwByteAMD(cs, 0xA3, command);\r\n}\r\nstatic void\r\nAmd7930_get_state(struct IsdnCardState *cs) {\r\nBYTE lsr = rByteAMD(cs, 0xA1);\r\ncs->dc.amd7930.ph_state = (lsr & 0x7) + 2;\r\nAmd7930_new_ph(cs);\r\n}\r\nstatic void\r\nAmd7930_new_ph(struct IsdnCardState *cs)\r\n{\r\nu_char index = stateHelper[cs->dc.amd7930.old_state]*8 + stateHelper[cs->dc.amd7930.ph_state]-1;\r\nu_char message = i430States[index];\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "AMD7930: new_ph %d, old_ph %d, message %d, index %d",\r\ncs->dc.amd7930.ph_state, cs->dc.amd7930.old_state, message & 0x0f, index);\r\ncs->dc.amd7930.old_state = cs->dc.amd7930.ph_state;\r\nif ((message & 0xf0) && (cs->tx_skb)) {\r\nwByteAMD(cs, 0x21, 0xC2);\r\nwByteAMD(cs, 0x21, 0x02);\r\n}\r\nswitch (message & 0x0f) {\r\ncase (1):\r\nl1_msg(cs, HW_RESET | INDICATION, NULL);\r\nAmd7930_get_state(cs);\r\nbreak;\r\ncase (2):\r\nl1_msg(cs, HW_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\ncase (3):\r\nl1_msg(cs, HW_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase (4):\r\nl1_msg(cs, HW_POWERUP | CONFIRM, NULL);\r\nAmd7930_ph_command(cs, 0x50, "HW_ENABLE REQUEST");\r\nbreak;\r\ncase (5):\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nbreak;\r\ncase (6):\r\nl1_msg(cs, HW_INFO4_P8 | INDICATION, NULL);\r\nbreak;\r\ncase (7):\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nl1_msg(cs, HW_INFO4_P8 | INDICATION, NULL);\r\nbreak;\r\ncase (8):\r\nl1_msg(cs, HW_POWERUP | CONFIRM, NULL);\r\ncase (9):\r\nAmd7930_ph_command(cs, 0x40, "HW_ENABLE REQ cleared if set");\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nl1_msg(cs, HW_INFO2 | INDICATION, NULL);\r\nl1_msg(cs, HW_INFO4_P8 | INDICATION, NULL);\r\nbreak;\r\ncase (10):\r\nAmd7930_ph_command(cs, 0x40, "T3 expired, HW_ENABLE REQ cleared");\r\ncs->dc.amd7930.old_state = 3;\r\nbreak;\r\ncase (11):\r\nl1_msg(cs, HW_INFO2 | INDICATION, NULL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nAmd7930_bh(struct work_struct *work)\r\n{\r\nstruct IsdnCardState *cs =\r\ncontainer_of(work, struct IsdnCardState, tqueue);\r\nstruct PStack *stptr;\r\nif (test_and_clear_bit(D_CLEARBUSY, &cs->event)) {\r\nif (cs->debug)\r\ndebugl1(cs, "Amd7930: bh, D-Channel Busy cleared");\r\nstptr = cs->stlist;\r\nwhile (stptr != NULL) {\r\nstptr->l1.l1l2(stptr, PH_PAUSE | CONFIRM, NULL);\r\nstptr = stptr->next;\r\n}\r\n}\r\nif (test_and_clear_bit(D_L1STATECHANGE, &cs->event)) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "AMD7930: bh, D_L1STATECHANGE");\r\nAmd7930_new_ph(cs);\r\n}\r\nif (test_and_clear_bit(D_RCVBUFREADY, &cs->event)) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "AMD7930: bh, D_RCVBUFREADY");\r\nDChannel_proc_rcv(cs);\r\n}\r\nif (test_and_clear_bit(D_XMTBUFREADY, &cs->event)) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "AMD7930: bh, D_XMTBUFREADY");\r\nDChannel_proc_xmt(cs);\r\n}\r\n}\r\nstatic void\r\nAmd7930_empty_Dfifo(struct IsdnCardState *cs, int flag)\r\n{\r\nBYTE stat, der;\r\nBYTE *ptr;\r\nstruct sk_buff *skb;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "Amd7930: empty_Dfifo");\r\nptr = cs->rcvbuf + cs->rcvidx;\r\nAmdIrqOff(cs);\r\nstat = rByteAMD(cs, 0x07);\r\nwhile ( (stat & 2) && ((ptr-cs->rcvbuf) < MAX_DFRAME_LEN_L1) ) {\r\n*ptr = rByteAMD(cs, 0x04);\r\nptr++;\r\nstat = rByteAMD(cs, 0x07);\r\ncs->rcvidx = ptr - cs->rcvbuf;\r\nif (stat & 1) {\r\nder = rWordAMD(cs, 0x03);\r\nif(!der && !flag) {\r\nrWordAMD(cs, 0x89);\r\nif ((cs->rcvidx) > 0) {\r\nif (!(skb = alloc_skb(cs->rcvidx, GFP_ATOMIC)))\r\nprintk(KERN_WARNING "HiSax: Amd7930: empty_Dfifo, D receive out of memory!\n");\r\nelse {\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "Amd7930: empty_Dfifo cnt: %d |", cs->rcvidx);\r\nQuickHex(t, cs->rcvbuf, cs->rcvidx);\r\ndebugl1(cs, cs->dlog);\r\n}\r\nmemcpy(skb_put(skb, cs->rcvidx), cs->rcvbuf, cs->rcvidx);\r\nskb_queue_tail(&cs->rq, skb);\r\n}\r\n}\r\n}\r\nptr = cs->rcvbuf;\r\ncs->rcvidx = 0;\r\nschedule_event(cs, D_RCVBUFREADY);\r\n}\r\n}\r\nif(cs->rcvidx >= MAX_DFRAME_LEN_L1) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "AMD7930: empty_Dfifo L2-Framelength overrun");\r\ncs->rcvidx = 0;\r\nreturn;\r\n}\r\nAmdIrqOn(cs);\r\n}\r\nstatic void\r\nAmd7930_fill_Dfifo(struct IsdnCardState *cs)\r\n{\r\nWORD dtcrr, dtcrw, len, count;\r\nBYTE txstat, dmr3;\r\nBYTE *ptr, *deb_ptr;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "Amd7930: fill_Dfifo");\r\nif ((!cs->tx_skb) || (cs->tx_skb->len <= 0))\r\nreturn;\r\ndtcrw = 0;\r\nif(!cs->dc.amd7930.tx_xmtlen)\r\nlen = dtcrw = cs->tx_skb->len;\r\nelse len = cs->dc.amd7930.tx_xmtlen;\r\nAmdIrqOff(cs);\r\ndeb_ptr = ptr = cs->tx_skb->data;\r\ntxstat = 0x10;\r\nwhile((txstat & 0x10) && (cs->tx_cnt < len)) {\r\nwByteAMD(cs, 0x04, *ptr);\r\nptr++;\r\ncs->tx_cnt++;\r\ntxstat= rByteAMD(cs, 0x07);\r\n}\r\ncount = ptr - cs->tx_skb->data;\r\nskb_pull(cs->tx_skb, count);\r\ndtcrr = rWordAMD(cs, 0x85);\r\ndmr3 = rByteAMD(cs, 0x8E);\r\nif (cs->debug & L1_DEB_ISAC) {\r\ndebugl1(cs, "Amd7930: fill_Dfifo, DMR3: 0x%02X, DTCR read: 0x%04X write: 0x%02X 0x%02X", dmr3, dtcrr, LOBYTE(dtcrw), HIBYTE(dtcrw));\r\n}\r\nif(!cs->dc.amd7930.tx_xmtlen) {\r\nwWordAMD(cs, 0x85, dtcrw);\r\ncs->dc.amd7930.tx_xmtlen = dtcrw;\r\n}\r\nif (test_and_set_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\ndebugl1(cs, "Amd7930: fill_Dfifo dbusytimer running");\r\ndel_timer(&cs->dbusytimer);\r\n}\r\ninit_timer(&cs->dbusytimer);\r\ncs->dbusytimer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ) / 1000);\r\nadd_timer(&cs->dbusytimer);\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "Amd7930: fill_Dfifo cnt: %d |", count);\r\nQuickHex(t, deb_ptr, count);\r\ndebugl1(cs, cs->dlog);\r\n}\r\nAmdIrqOn(cs);\r\n}\r\nvoid Amd7930_interrupt(struct IsdnCardState *cs, BYTE irflags)\r\n{\r\nBYTE dsr1, dsr2, lsr;\r\nWORD der;\r\nwhile (irflags)\r\n{\r\ndsr1 = rByteAMD(cs, 0x02);\r\nder = rWordAMD(cs, 0x03);\r\ndsr2 = rByteAMD(cs, 0x07);\r\nlsr = rByteAMD(cs, 0xA1);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: interrupt: flags: 0x%02X, DSR1: 0x%02X, DSR2: 0x%02X, LSR: 0x%02X, DER=0x%04X", irflags, dsr1, dsr2, lsr, der);\r\nif (der || (dsr2 & 4)) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "Amd7930: interrupt: D error DER=0x%04X", der);\r\nif (der & 2) {\r\nwByteAMD(cs, 0x21, 0xC2);\r\nwByteAMD(cs, 0x21, 0x02);\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nskb_push(cs->tx_skb, cs->tx_cnt);\r\ncs->tx_cnt = 0;\r\ncs->dc.amd7930.tx_xmtlen = 0;\r\nAmd7930_fill_Dfifo(cs);\r\n} else {\r\nprintk(KERN_WARNING "HiSax: Amd7930 D-Collision, no skb\n");\r\ndebugl1(cs, "Amd7930: interrupt: D-Collision, no skb");\r\n}\r\n}\r\nAmd7930_empty_Dfifo(cs, 1);\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nskb_push(cs->tx_skb, cs->tx_cnt);\r\ncs->tx_cnt = 0;\r\ncs->dc.amd7930.tx_xmtlen = 0;\r\nAmd7930_fill_Dfifo(cs);\r\n}\r\n}\r\nif (irflags & 1) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: interrupt: clear Timer and fill D-TX-FIFO if data");\r\nAmdIrqOff(cs);\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->tx_skb->len)\r\nAmd7930_fill_Dfifo(cs);\r\n}\r\nAmdIrqOn(cs);\r\n}\r\nif ((irflags & 2) || (dsr1 & 2)) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: interrupt: empty D-FIFO");\r\nAmd7930_empty_Dfifo(cs, 0);\r\n}\r\nif (dsr1 & 64) {\r\nif (cs->debug & L1_DEB_ISAC) {\r\ndebugl1(cs, "Amd7930: interrupt: transmit packet ready");\r\n}\r\nAmdIrqOff(cs);\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: interrupt: TX-Packet ready, freeing skb");\r\ndev_kfree_skb_irq(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->dc.amd7930.tx_xmtlen=0;\r\ncs->tx_skb = NULL;\r\n}\r\nif ((cs->tx_skb = skb_dequeue(&cs->sq))) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: interrupt: TX-Packet ready, next packet dequeued");\r\ncs->tx_cnt = 0;\r\ncs->dc.amd7930.tx_xmtlen=0;\r\nAmd7930_fill_Dfifo(cs);\r\n}\r\nelse\r\nschedule_event(cs, D_XMTBUFREADY);\r\nAmdIrqOn(cs);\r\n}\r\nif (lsr & 0x38) {\r\nAmdIrqOff(cs);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd: interrupt: LSR=0x%02X, LIU is in state %d", lsr, ((lsr & 0x7) +2));\r\ncs->dc.amd7930.ph_state = (lsr & 0x7) + 2;\r\nschedule_event(cs, D_L1STATECHANGE);\r\nAmdIrqOn(cs);\r\n}\r\nirflags = rByteAMD(cs, 0x00);\r\n}\r\n}\r\nstatic void\r\nAmd7930_l1hw(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: l1hw called, pr: 0x%04X", pr);\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nskb_queue_tail(&cs->sq, skb);\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "Amd7930: l1hw: PH_DATA Queued", 0);\r\n#endif\r\n} else {\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\ncs->dc.amd7930.tx_xmtlen=0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "Amd7930: l1hw: PH_DATA", 0);\r\n#endif\r\nAmd7930_fill_Dfifo(cs);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "Amd7930: l1hw: l2l1 tx_skb exist this shouldn't happen");\r\nskb_queue_tail(&cs->sq, skb);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\n}\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\ncs->dc.amd7930.tx_xmtlen=0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "Amd7930: l1hw: PH_DATA_PULLED", 0);\r\n#endif\r\nAmd7930_fill_Dfifo(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\ndebugl1(cs, "Amd7930: l1hw: -> PH_REQUEST_PULL, skb: %s", (cs->tx_skb)? "yes":"no");\r\n#endif\r\nif (!cs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (HW_RESET | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif ((cs->dc.amd7930.ph_state == 8)) {\r\nAmd7930_ph_command(cs, 0x20, "HW_RESET REQEST");\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n} else {\r\nAmd7930_ph_command(cs, 0x40, "HW_RESET REQUEST");\r\ncs->dc.amd7930.ph_state = 2;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nAmd7930_new_ph(cs);\r\n}\r\nbreak;\r\ncase (HW_ENABLE | REQUEST):\r\ncs->dc.amd7930.ph_state = 9;\r\nAmd7930_new_ph(cs);\r\nbreak;\r\ncase (HW_INFO3 | REQUEST):\r\nbreak;\r\ncase (HW_TESTLOOP | REQUEST):\r\nbreak;\r\ncase (HW_DEACTIVATE | RESPONSE):\r\nskb_queue_purge(&cs->rq);\r\nskb_queue_purge(&cs->sq);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\n}\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "Amd7930: l1hw: unknown %04x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsetstack_Amd7930(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: setstack called");\r\nst->l1.l1hw = Amd7930_l1hw;\r\n}\r\nstatic void\r\nDC_Close_Amd7930(struct IsdnCardState *cs) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: DC_Close called");\r\n}\r\nstatic void\r\ndbusy_timer_handler(struct IsdnCardState *cs)\r\n{\r\nu_long flags;\r\nstruct PStack *stptr;\r\nWORD dtcr, der;\r\nBYTE dsr1, dsr2;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: dbusy_timer expired!");\r\nif (test_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\nspin_lock_irqsave(&cs->lock, flags);\r\ndtcr = rWordAMD(cs, 0x85);\r\ndsr1 = rByteAMD(cs, 0x02);\r\ndsr2 = rByteAMD(cs, 0x07);\r\nder = rWordAMD(cs, 0x03);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: dbusy_timer_handler: DSR1=0x%02X, DSR2=0x%02X, DER=0x%04X, cs->tx_skb->len=%u, tx_stat=%u, dtcr=%u, cs->tx_cnt=%u", dsr1, dsr2, der, cs->tx_skb->len, cs->dc.amd7930.tx_xmtlen, dtcr, cs->tx_cnt);\r\nif ((cs->dc.amd7930.tx_xmtlen - dtcr) < cs->tx_cnt) {\r\ntest_and_set_bit(FLG_L1_DBUSY, &cs->HW_Flags);\r\nstptr = cs->stlist;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nwhile (stptr != NULL) {\r\nstptr->l1.l1l2(stptr, PH_PAUSE | INDICATION, NULL);\r\nstptr = stptr->next;\r\n}\r\n} else {\r\ntest_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\ncs->dc.amd7930.tx_xmtlen = 0;\r\n} else {\r\nprintk(KERN_WARNING "HiSax: Amd7930: D-Channel Busy no skb\n");\r\ndebugl1(cs, "Amd7930: D-Channel Busy no skb");\r\n}\r\nwByteAMD(cs, 0x21, 0x82);\r\nwByteAMD(cs, 0x21, 0x02);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ncs->irq_func(cs->irq, cs);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: dbusy_timer_handler: Transmitter reset");\r\n}\r\n}\r\n}\r\nvoid Amd7930_init(struct IsdnCardState *cs)\r\n{\r\nWORD *ptr;\r\nBYTE cmd, cnt;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "Amd7930: initamd called");\r\ncs->dc.amd7930.tx_xmtlen = 0;\r\ncs->dc.amd7930.old_state = 0;\r\ncs->dc.amd7930.lmr1 = 0x40;\r\ncs->dc.amd7930.ph_command = Amd7930_ph_command;\r\ncs->setstack_d = setstack_Amd7930;\r\ncs->DC_Close = DC_Close_Amd7930;\r\nfor (ptr = initAMD; *ptr != 0xFFFF; ) {\r\ncmd = LOBYTE(*ptr);\r\nif (*ptr++ >= 0x100) {\r\nif (cmd < 8)\r\nrByteAMD(cs, cmd);\r\nelse {\r\nwByteAMD(cs, 0x00, cmd);\r\nfor (cnt = *ptr++; cnt > 0; cnt--)\r\nrByteAMD(cs, 0x01);\r\n}\r\n}\r\nelse if (cmd < 8)\r\nwByteAMD(cs, cmd, LOBYTE(*ptr++));\r\nelse {\r\nwByteAMD(cs, 0x00, cmd);\r\nfor (cnt = *ptr++; cnt > 0; cnt--)\r\nwByteAMD(cs, 0x01, LOBYTE(*ptr++));\r\n}\r\n}\r\n}\r\nvoid __devinit\r\nsetup_Amd7930(struct IsdnCardState *cs)\r\n{\r\nINIT_WORK(&cs->tqueue, Amd7930_bh);\r\ncs->dbusytimer.function = (void *) dbusy_timer_handler;\r\ncs->dbusytimer.data = (long) cs;\r\ninit_timer(&cs->dbusytimer);\r\n}
