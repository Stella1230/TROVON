static int nanoengine_get_pci_address(struct pci_bus *bus,\r\nunsigned int devfn, int where, unsigned long *address)\r\n{\r\nint ret = PCIBIOS_DEVICE_NOT_FOUND;\r\nunsigned int busnr = bus->number;\r\n*address = NANO_PCI_CONFIG_SPACE_VIRT +\r\n((bus->number << 16) | (devfn << 8) | (where & ~3));\r\nret = (busnr > 255 || devfn > 255 || where > 255) ?\r\nPCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\nreturn ret;\r\n}\r\nstatic int nanoengine_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *val)\r\n{\r\nint ret;\r\nunsigned long address;\r\nunsigned long flags;\r\nu32 v;\r\nif (bus->number != 0 || (devfn >> 3) != 0) {\r\nv = -1;\r\nnanoengine_get_pci_address(bus, devfn, where, &address);\r\ngoto exit_function;\r\n}\r\nspin_lock_irqsave(&nano_lock, flags);\r\nret = nanoengine_get_pci_address(bus, devfn, where, &address);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\nv = __raw_readl(address);\r\nspin_unlock_irqrestore(&nano_lock, flags);\r\nv >>= ((where & 3) * 8);\r\nv &= (unsigned long)(-1) >> ((4 - size) * 8);\r\nexit_function:\r\n*val = v;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int nanoengine_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 val)\r\n{\r\nint ret;\r\nunsigned long address;\r\nunsigned long flags;\r\nunsigned shift;\r\nu32 v;\r\nshift = (where & 3) * 8;\r\nspin_lock_irqsave(&nano_lock, flags);\r\nret = nanoengine_get_pci_address(bus, devfn, where, &address);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\nv = __raw_readl(address);\r\nswitch (size) {\r\ncase 1:\r\nv &= ~(0xFF << shift);\r\nv |= val << shift;\r\nbreak;\r\ncase 2:\r\nv &= ~(0xFFFF << shift);\r\nv |= val << shift;\r\nbreak;\r\ncase 4:\r\nv = val;\r\nbreak;\r\n}\r\n__raw_writel(v, address);\r\nspin_unlock_irqrestore(&nano_lock, flags);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int __init pci_nanoengine_map_irq(const struct pci_dev *dev, u8 slot,\r\nu8 pin)\r\n{\r\nreturn NANOENGINE_IRQ_GPIO_PCI;\r\n}\r\nstruct pci_bus * __init pci_nanoengine_scan_bus(int nr, struct pci_sys_data *sys)\r\n{\r\nreturn pci_scan_bus(sys->busnr, &pci_nano_ops, sys);\r\n}\r\nstatic int __init pci_nanoengine_setup_resources(struct resource **resource)\r\n{\r\nif (request_resource(&ioport_resource, &pci_io_ports)) {\r\nprintk(KERN_ERR "PCI: unable to allocate io port region\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_resource(&iomem_resource, &pci_non_prefetchable_memory)) {\r\nrelease_resource(&pci_io_ports);\r\nprintk(KERN_ERR "PCI: unable to allocate non prefetchable\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_resource(&iomem_resource, &pci_prefetchable_memory)) {\r\nrelease_resource(&pci_io_ports);\r\nrelease_resource(&pci_non_prefetchable_memory);\r\nprintk(KERN_ERR "PCI: unable to allocate prefetchable\n");\r\nreturn -EBUSY;\r\n}\r\nresource[0] = &pci_io_ports;\r\nresource[1] = &pci_non_prefetchable_memory;\r\nresource[2] = &pci_prefetchable_memory;\r\nreturn 1;\r\n}\r\nint __init pci_nanoengine_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nint ret = 0;\r\npcibios_min_io = 0;\r\npcibios_min_mem = 0;\r\nif (nr == 0) {\r\nsys->mem_offset = NANO_PCI_MEM_RW_PHYS;\r\nsys->io_offset = 0x400;\r\nret = pci_nanoengine_setup_resources(sys->resource);\r\nGPDR = (GPDR & ~GPIO_MBREQ) | GPIO_MBGNT;\r\nGAFR |= GPIO_MBGNT | GPIO_MBREQ;\r\nTUCR |= TUCR_MBGPIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init nanoengine_pci_init(void)\r\n{\r\nif (machine_is_nanoengine())\r\npci_common_init(&nanoengine_pci);\r\nreturn 0;\r\n}
