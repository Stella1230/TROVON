int arp_mc_map(__be32 addr, u8 *haddr, struct net_device *dev, int dir)\r\n{\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\ncase ARPHRD_FDDI:\r\ncase ARPHRD_IEEE802:\r\nip_eth_mc_map(addr, haddr);\r\nreturn 0;\r\ncase ARPHRD_IEEE802_TR:\r\nip_tr_mc_map(addr, haddr);\r\nreturn 0;\r\ncase ARPHRD_INFINIBAND:\r\nip_ib_mc_map(addr, dev->broadcast, haddr);\r\nreturn 0;\r\ncase ARPHRD_IPGRE:\r\nip_ipgre_mc_map(addr, dev->broadcast, haddr);\r\nreturn 0;\r\ndefault:\r\nif (dir) {\r\nmemcpy(haddr, dev->broadcast, dev->addr_len);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 arp_hash(const void *pkey,\r\nconst struct net_device *dev,\r\n__u32 hash_rnd)\r\n{\r\nreturn arp_hashfn(*(u32 *)pkey, dev, hash_rnd);\r\n}\r\nstatic int arp_constructor(struct neighbour *neigh)\r\n{\r\n__be32 addr = *(__be32 *)neigh->primary_key;\r\nstruct net_device *dev = neigh->dev;\r\nstruct in_device *in_dev;\r\nstruct neigh_parms *parms;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (in_dev == NULL) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nneigh->type = inet_addr_type(dev_net(dev), addr);\r\nparms = in_dev->arp_parms;\r\n__neigh_parms_put(neigh->parms);\r\nneigh->parms = neigh_parms_clone(parms);\r\nrcu_read_unlock();\r\nif (!dev->header_ops) {\r\nneigh->nud_state = NUD_NOARP;\r\nneigh->ops = &arp_direct_ops;\r\nneigh->output = neigh_direct_output;\r\n} else {\r\n#if 1\r\nswitch (dev->type) {\r\ndefault:\r\nbreak;\r\ncase ARPHRD_ROSE:\r\n#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)\r\ncase ARPHRD_AX25:\r\n#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)\r\ncase ARPHRD_NETROM:\r\n#endif\r\nneigh->ops = &arp_broken_ops;\r\nneigh->output = neigh->ops->output;\r\nreturn 0;\r\n#else\r\nbreak;\r\n#endif\r\n}\r\n#endif\r\nif (neigh->type == RTN_MULTICAST) {\r\nneigh->nud_state = NUD_NOARP;\r\narp_mc_map(addr, neigh->ha, dev, 1);\r\n} else if (dev->flags & (IFF_NOARP | IFF_LOOPBACK)) {\r\nneigh->nud_state = NUD_NOARP;\r\nmemcpy(neigh->ha, dev->dev_addr, dev->addr_len);\r\n} else if (neigh->type == RTN_BROADCAST ||\r\n(dev->flags & IFF_POINTOPOINT)) {\r\nneigh->nud_state = NUD_NOARP;\r\nmemcpy(neigh->ha, dev->broadcast, dev->addr_len);\r\n}\r\nif (dev->header_ops->cache)\r\nneigh->ops = &arp_hh_ops;\r\nelse\r\nneigh->ops = &arp_generic_ops;\r\nif (neigh->nud_state & NUD_VALID)\r\nneigh->output = neigh->ops->connected_output;\r\nelse\r\nneigh->output = neigh->ops->output;\r\n}\r\nreturn 0;\r\n}\r\nstatic void arp_error_report(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\ndst_link_failure(skb);\r\nkfree_skb(skb);\r\n}\r\nstatic void arp_solicit(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\n__be32 saddr = 0;\r\nu8 *dst_ha = NULL;\r\nstruct net_device *dev = neigh->dev;\r\n__be32 target = *(__be32 *)neigh->primary_key;\r\nint probes = atomic_read(&neigh->probes);\r\nstruct in_device *in_dev;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (!in_dev) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nswitch (IN_DEV_ARP_ANNOUNCE(in_dev)) {\r\ndefault:\r\ncase 0:\r\nif (skb && inet_addr_type(dev_net(dev),\r\nip_hdr(skb)->saddr) == RTN_LOCAL)\r\nsaddr = ip_hdr(skb)->saddr;\r\nbreak;\r\ncase 1:\r\nif (!skb)\r\nbreak;\r\nsaddr = ip_hdr(skb)->saddr;\r\nif (inet_addr_type(dev_net(dev), saddr) == RTN_LOCAL) {\r\nif (inet_addr_onlink(in_dev, target, saddr))\r\nbreak;\r\n}\r\nsaddr = 0;\r\nbreak;\r\ncase 2:\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!saddr)\r\nsaddr = inet_select_addr(dev, target, RT_SCOPE_LINK);\r\nprobes -= neigh->parms->ucast_probes;\r\nif (probes < 0) {\r\nif (!(neigh->nud_state & NUD_VALID))\r\nprintk(KERN_DEBUG\r\n"trying to ucast probe in NUD_INVALID\n");\r\ndst_ha = neigh->ha;\r\nread_lock_bh(&neigh->lock);\r\n} else {\r\nprobes -= neigh->parms->app_probes;\r\nif (probes < 0) {\r\n#ifdef CONFIG_ARPD\r\nneigh_app_ns(neigh);\r\n#endif\r\nreturn;\r\n}\r\n}\r\narp_send(ARPOP_REQUEST, ETH_P_ARP, target, dev, saddr,\r\ndst_ha, dev->dev_addr, NULL);\r\nif (dst_ha)\r\nread_unlock_bh(&neigh->lock);\r\n}\r\nstatic int arp_ignore(struct in_device *in_dev, __be32 sip, __be32 tip)\r\n{\r\nint scope;\r\nswitch (IN_DEV_ARP_IGNORE(in_dev)) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nsip = 0;\r\nscope = RT_SCOPE_HOST;\r\nbreak;\r\ncase 2:\r\nscope = RT_SCOPE_HOST;\r\nbreak;\r\ncase 3:\r\nsip = 0;\r\nscope = RT_SCOPE_LINK;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nreturn 0;\r\ncase 8:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn !inet_confirm_addr(in_dev, sip, tip, scope);\r\n}\r\nstatic int arp_filter(__be32 sip, __be32 tip, struct net_device *dev)\r\n{\r\nstruct rtable *rt;\r\nint flag = 0;\r\nstruct net *net = dev_net(dev);\r\nrt = ip_route_output(net, sip, tip, 0, 0);\r\nif (IS_ERR(rt))\r\nreturn 1;\r\nif (rt->dst.dev != dev) {\r\nNET_INC_STATS_BH(net, LINUX_MIB_ARPFILTER);\r\nflag = 1;\r\n}\r\nip_rt_put(rt);\r\nreturn flag;\r\n}\r\nstatic int arp_set_predefined(int addr_hint, unsigned char *haddr,\r\n__be32 paddr, struct net_device *dev)\r\n{\r\nswitch (addr_hint) {\r\ncase RTN_LOCAL:\r\nprintk(KERN_DEBUG "ARP: arp called for own IP address\n");\r\nmemcpy(haddr, dev->dev_addr, dev->addr_len);\r\nreturn 1;\r\ncase RTN_MULTICAST:\r\narp_mc_map(paddr, haddr, dev, 1);\r\nreturn 1;\r\ncase RTN_BROADCAST:\r\nmemcpy(haddr, dev->broadcast, dev->addr_len);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint arp_find(unsigned char *haddr, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\n__be32 paddr;\r\nstruct neighbour *n;\r\nif (!skb_dst(skb)) {\r\nprintk(KERN_DEBUG "arp_find is called with dst==NULL\n");\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\npaddr = skb_rtable(skb)->rt_gateway;\r\nif (arp_set_predefined(inet_addr_type(dev_net(dev), paddr), haddr,\r\npaddr, dev))\r\nreturn 0;\r\nn = __neigh_lookup(&arp_tbl, &paddr, dev, 1);\r\nif (n) {\r\nn->used = jiffies;\r\nif (n->nud_state & NUD_VALID || neigh_event_send(n, skb) == 0) {\r\nneigh_ha_snapshot(haddr, n, dev);\r\nneigh_release(n);\r\nreturn 0;\r\n}\r\nneigh_release(n);\r\n} else\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\nstatic inline int arp_fwd_proxy(struct in_device *in_dev,\r\nstruct net_device *dev, struct rtable *rt)\r\n{\r\nstruct in_device *out_dev;\r\nint imi, omi = -1;\r\nif (rt->dst.dev == dev)\r\nreturn 0;\r\nif (!IN_DEV_PROXY_ARP(in_dev))\r\nreturn 0;\r\nimi = IN_DEV_MEDIUM_ID(in_dev);\r\nif (imi == 0)\r\nreturn 1;\r\nif (imi == -1)\r\nreturn 0;\r\nout_dev = __in_dev_get_rcu(rt->dst.dev);\r\nif (out_dev)\r\nomi = IN_DEV_MEDIUM_ID(out_dev);\r\nreturn omi != imi && omi != -1;\r\n}\r\nstatic inline int arp_fwd_pvlan(struct in_device *in_dev,\r\nstruct net_device *dev, struct rtable *rt,\r\n__be32 sip, __be32 tip)\r\n{\r\nif (rt->dst.dev != dev)\r\nreturn 0;\r\nif (sip == tip)\r\nreturn 0;\r\nif (IN_DEV_PROXY_ARP_PVLAN(in_dev))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstruct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,\r\nstruct net_device *dev, __be32 src_ip,\r\nconst unsigned char *dest_hw,\r\nconst unsigned char *src_hw,\r\nconst unsigned char *target_hw)\r\n{\r\nstruct sk_buff *skb;\r\nstruct arphdr *arp;\r\nunsigned char *arp_ptr;\r\nskb = alloc_skb(arp_hdr_len(dev) + LL_ALLOCATED_SPACE(dev), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn NULL;\r\nskb_reserve(skb, LL_RESERVED_SPACE(dev));\r\nskb_reset_network_header(skb);\r\narp = (struct arphdr *) skb_put(skb, arp_hdr_len(dev));\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_ARP);\r\nif (src_hw == NULL)\r\nsrc_hw = dev->dev_addr;\r\nif (dest_hw == NULL)\r\ndest_hw = dev->broadcast;\r\nif (dev_hard_header(skb, dev, ptype, dest_hw, src_hw, skb->len) < 0)\r\ngoto out;\r\nswitch (dev->type) {\r\ndefault:\r\narp->ar_hrd = htons(dev->type);\r\narp->ar_pro = htons(ETH_P_IP);\r\nbreak;\r\n#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)\r\ncase ARPHRD_AX25:\r\narp->ar_hrd = htons(ARPHRD_AX25);\r\narp->ar_pro = htons(AX25_P_IP);\r\nbreak;\r\n#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)\r\ncase ARPHRD_NETROM:\r\narp->ar_hrd = htons(ARPHRD_NETROM);\r\narp->ar_pro = htons(AX25_P_IP);\r\nbreak;\r\n#endif\r\n#endif\r\n#if defined(CONFIG_FDDI) || defined(CONFIG_FDDI_MODULE)\r\ncase ARPHRD_FDDI:\r\narp->ar_hrd = htons(ARPHRD_ETHER);\r\narp->ar_pro = htons(ETH_P_IP);\r\nbreak;\r\n#endif\r\n#if defined(CONFIG_TR) || defined(CONFIG_TR_MODULE)\r\ncase ARPHRD_IEEE802_TR:\r\narp->ar_hrd = htons(ARPHRD_IEEE802);\r\narp->ar_pro = htons(ETH_P_IP);\r\nbreak;\r\n#endif\r\n}\r\narp->ar_hln = dev->addr_len;\r\narp->ar_pln = 4;\r\narp->ar_op = htons(type);\r\narp_ptr = (unsigned char *)(arp + 1);\r\nmemcpy(arp_ptr, src_hw, dev->addr_len);\r\narp_ptr += dev->addr_len;\r\nmemcpy(arp_ptr, &src_ip, 4);\r\narp_ptr += 4;\r\nif (target_hw != NULL)\r\nmemcpy(arp_ptr, target_hw, dev->addr_len);\r\nelse\r\nmemset(arp_ptr, 0, dev->addr_len);\r\narp_ptr += dev->addr_len;\r\nmemcpy(arp_ptr, &dest_ip, 4);\r\nreturn skb;\r\nout:\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nvoid arp_xmit(struct sk_buff *skb)\r\n{\r\nNF_HOOK(NFPROTO_ARP, NF_ARP_OUT, skb, NULL, skb->dev, dev_queue_xmit);\r\n}\r\nvoid arp_send(int type, int ptype, __be32 dest_ip,\r\nstruct net_device *dev, __be32 src_ip,\r\nconst unsigned char *dest_hw, const unsigned char *src_hw,\r\nconst unsigned char *target_hw)\r\n{\r\nstruct sk_buff *skb;\r\nif (dev->flags&IFF_NOARP)\r\nreturn;\r\nskb = arp_create(type, ptype, dest_ip, dev, src_ip,\r\ndest_hw, src_hw, target_hw);\r\nif (skb == NULL)\r\nreturn;\r\narp_xmit(skb);\r\n}\r\nstatic int arp_process(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct in_device *in_dev = __in_dev_get_rcu(dev);\r\nstruct arphdr *arp;\r\nunsigned char *arp_ptr;\r\nstruct rtable *rt;\r\nunsigned char *sha;\r\n__be32 sip, tip;\r\nu16 dev_type = dev->type;\r\nint addr_type;\r\nstruct neighbour *n;\r\nstruct net *net = dev_net(dev);\r\nif (in_dev == NULL)\r\ngoto out;\r\narp = arp_hdr(skb);\r\nswitch (dev_type) {\r\ndefault:\r\nif (arp->ar_pro != htons(ETH_P_IP) ||\r\nhtons(dev_type) != arp->ar_hrd)\r\ngoto out;\r\nbreak;\r\ncase ARPHRD_ETHER:\r\ncase ARPHRD_IEEE802_TR:\r\ncase ARPHRD_FDDI:\r\ncase ARPHRD_IEEE802:\r\nif ((arp->ar_hrd != htons(ARPHRD_ETHER) &&\r\narp->ar_hrd != htons(ARPHRD_IEEE802)) ||\r\narp->ar_pro != htons(ETH_P_IP))\r\ngoto out;\r\nbreak;\r\ncase ARPHRD_AX25:\r\nif (arp->ar_pro != htons(AX25_P_IP) ||\r\narp->ar_hrd != htons(ARPHRD_AX25))\r\ngoto out;\r\nbreak;\r\ncase ARPHRD_NETROM:\r\nif (arp->ar_pro != htons(AX25_P_IP) ||\r\narp->ar_hrd != htons(ARPHRD_NETROM))\r\ngoto out;\r\nbreak;\r\n}\r\nif (arp->ar_op != htons(ARPOP_REPLY) &&\r\narp->ar_op != htons(ARPOP_REQUEST))\r\ngoto out;\r\narp_ptr = (unsigned char *)(arp + 1);\r\nsha = arp_ptr;\r\narp_ptr += dev->addr_len;\r\nmemcpy(&sip, arp_ptr, 4);\r\narp_ptr += 4;\r\narp_ptr += dev->addr_len;\r\nmemcpy(&tip, arp_ptr, 4);\r\nif (ipv4_is_loopback(tip) || ipv4_is_multicast(tip))\r\ngoto out;\r\nif (dev_type == ARPHRD_DLCI)\r\nsha = dev->broadcast;\r\nif (sip == 0) {\r\nif (arp->ar_op == htons(ARPOP_REQUEST) &&\r\ninet_addr_type(net, tip) == RTN_LOCAL &&\r\n!arp_ignore(in_dev, sip, tip))\r\narp_send(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip, sha,\r\ndev->dev_addr, sha);\r\ngoto out;\r\n}\r\nif (arp->ar_op == htons(ARPOP_REQUEST) &&\r\nip_route_input_noref(skb, tip, sip, 0, dev) == 0) {\r\nrt = skb_rtable(skb);\r\naddr_type = rt->rt_type;\r\nif (addr_type == RTN_LOCAL) {\r\nint dont_send;\r\ndont_send = arp_ignore(in_dev, sip, tip);\r\nif (!dont_send && IN_DEV_ARPFILTER(in_dev))\r\ndont_send = arp_filter(sip, tip, dev);\r\nif (!dont_send) {\r\nn = neigh_event_ns(&arp_tbl, sha, &sip, dev);\r\nif (n) {\r\narp_send(ARPOP_REPLY, ETH_P_ARP, sip,\r\ndev, tip, sha, dev->dev_addr,\r\nsha);\r\nneigh_release(n);\r\n}\r\n}\r\ngoto out;\r\n} else if (IN_DEV_FORWARD(in_dev)) {\r\nif (addr_type == RTN_UNICAST &&\r\n(arp_fwd_proxy(in_dev, dev, rt) ||\r\narp_fwd_pvlan(in_dev, dev, rt, sip, tip) ||\r\npneigh_lookup(&arp_tbl, net, &tip, dev, 0))) {\r\nn = neigh_event_ns(&arp_tbl, sha, &sip, dev);\r\nif (n)\r\nneigh_release(n);\r\nif (NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED ||\r\nskb->pkt_type == PACKET_HOST ||\r\nin_dev->arp_parms->proxy_delay == 0) {\r\narp_send(ARPOP_REPLY, ETH_P_ARP, sip,\r\ndev, tip, sha, dev->dev_addr,\r\nsha);\r\n} else {\r\npneigh_enqueue(&arp_tbl,\r\nin_dev->arp_parms, skb);\r\nreturn 0;\r\n}\r\ngoto out;\r\n}\r\n}\r\n}\r\nn = __neigh_lookup(&arp_tbl, &sip, dev, 0);\r\nif (IPV4_DEVCONF_ALL(dev_net(dev), ARP_ACCEPT)) {\r\nif (n == NULL &&\r\n(arp->ar_op == htons(ARPOP_REPLY) ||\r\n(arp->ar_op == htons(ARPOP_REQUEST) && tip == sip)) &&\r\ninet_addr_type(net, sip) == RTN_UNICAST)\r\nn = __neigh_lookup(&arp_tbl, &sip, dev, 1);\r\n}\r\nif (n) {\r\nint state = NUD_REACHABLE;\r\nint override;\r\noverride = time_after(jiffies, n->updated + n->parms->locktime);\r\nif (arp->ar_op != htons(ARPOP_REPLY) ||\r\nskb->pkt_type != PACKET_HOST)\r\nstate = NUD_STALE;\r\nneigh_update(n, sha, state,\r\noverride ? NEIGH_UPDATE_F_OVERRIDE : 0);\r\nneigh_release(n);\r\n}\r\nout:\r\nconsume_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void parp_redo(struct sk_buff *skb)\r\n{\r\narp_process(skb);\r\n}\r\nstatic int arp_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct arphdr *arp;\r\nif (!pskb_may_pull(skb, arp_hdr_len(dev)))\r\ngoto freeskb;\r\narp = arp_hdr(skb);\r\nif (arp->ar_hln != dev->addr_len ||\r\ndev->flags & IFF_NOARP ||\r\nskb->pkt_type == PACKET_OTHERHOST ||\r\nskb->pkt_type == PACKET_LOOPBACK ||\r\narp->ar_pln != 4)\r\ngoto freeskb;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto out_of_mem;\r\nmemset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));\r\nreturn NF_HOOK(NFPROTO_ARP, NF_ARP_IN, skb, dev, NULL, arp_process);\r\nfreeskb:\r\nkfree_skb(skb);\r\nout_of_mem:\r\nreturn 0;\r\n}\r\nstatic int arp_req_set_proxy(struct net *net, struct net_device *dev, int on)\r\n{\r\nif (dev == NULL) {\r\nIPV4_DEVCONF_ALL(net, PROXY_ARP) = on;\r\nreturn 0;\r\n}\r\nif (__in_dev_get_rtnl(dev)) {\r\nIN_DEV_CONF_SET(__in_dev_get_rtnl(dev), PROXY_ARP, on);\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int arp_req_set_public(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\r\n__be32 mask = ((struct sockaddr_in *)&r->arp_netmask)->sin_addr.s_addr;\r\nif (mask && mask != htonl(0xFFFFFFFF))\r\nreturn -EINVAL;\r\nif (!dev && (r->arp_flags & ATF_COM)) {\r\ndev = dev_getbyhwaddr_rcu(net, r->arp_ha.sa_family,\r\nr->arp_ha.sa_data);\r\nif (!dev)\r\nreturn -ENODEV;\r\n}\r\nif (mask) {\r\nif (pneigh_lookup(&arp_tbl, net, &ip, dev, 1) == NULL)\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nreturn arp_req_set_proxy(net, dev, 1);\r\n}\r\nstatic int arp_req_set(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip;\r\nstruct neighbour *neigh;\r\nint err;\r\nif (r->arp_flags & ATF_PUBL)\r\nreturn arp_req_set_public(net, r, dev);\r\nip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\r\nif (r->arp_flags & ATF_PERM)\r\nr->arp_flags |= ATF_COM;\r\nif (dev == NULL) {\r\nstruct rtable *rt = ip_route_output(net, ip, 0, RTO_ONLINK, 0);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\ndev = rt->dst.dev;\r\nip_rt_put(rt);\r\nif (!dev)\r\nreturn -EINVAL;\r\n}\r\nswitch (dev->type) {\r\n#if defined(CONFIG_FDDI) || defined(CONFIG_FDDI_MODULE)\r\ncase ARPHRD_FDDI:\r\nif (r->arp_ha.sa_family != ARPHRD_FDDI &&\r\nr->arp_ha.sa_family != ARPHRD_ETHER &&\r\nr->arp_ha.sa_family != ARPHRD_IEEE802)\r\nreturn -EINVAL;\r\nbreak;\r\n#endif\r\ndefault:\r\nif (r->arp_ha.sa_family != dev->type)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nneigh = __neigh_lookup_errno(&arp_tbl, &ip, dev);\r\nerr = PTR_ERR(neigh);\r\nif (!IS_ERR(neigh)) {\r\nunsigned state = NUD_STALE;\r\nif (r->arp_flags & ATF_PERM)\r\nstate = NUD_PERMANENT;\r\nerr = neigh_update(neigh, (r->arp_flags & ATF_COM) ?\r\nr->arp_ha.sa_data : NULL, state,\r\nNEIGH_UPDATE_F_OVERRIDE |\r\nNEIGH_UPDATE_F_ADMIN);\r\nneigh_release(neigh);\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned arp_state_to_flags(struct neighbour *neigh)\r\n{\r\nif (neigh->nud_state&NUD_PERMANENT)\r\nreturn ATF_PERM | ATF_COM;\r\nelse if (neigh->nud_state&NUD_VALID)\r\nreturn ATF_COM;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int arp_req_get(struct arpreq *r, struct net_device *dev)\r\n{\r\n__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;\r\nstruct neighbour *neigh;\r\nint err = -ENXIO;\r\nneigh = neigh_lookup(&arp_tbl, &ip, dev);\r\nif (neigh) {\r\nread_lock_bh(&neigh->lock);\r\nmemcpy(r->arp_ha.sa_data, neigh->ha, dev->addr_len);\r\nr->arp_flags = arp_state_to_flags(neigh);\r\nread_unlock_bh(&neigh->lock);\r\nr->arp_ha.sa_family = dev->type;\r\nstrlcpy(r->arp_dev, dev->name, sizeof(r->arp_dev));\r\nneigh_release(neigh);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nint arp_invalidate(struct net_device *dev, __be32 ip)\r\n{\r\nstruct neighbour *neigh = neigh_lookup(&arp_tbl, &ip, dev);\r\nint err = -ENXIO;\r\nif (neigh) {\r\nif (neigh->nud_state & ~NUD_NOARP)\r\nerr = neigh_update(neigh, NULL, NUD_FAILED,\r\nNEIGH_UPDATE_F_OVERRIDE|\r\nNEIGH_UPDATE_F_ADMIN);\r\nneigh_release(neigh);\r\n}\r\nreturn err;\r\n}\r\nstatic int arp_req_delete_public(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;\r\n__be32 mask = ((struct sockaddr_in *)&r->arp_netmask)->sin_addr.s_addr;\r\nif (mask == htonl(0xFFFFFFFF))\r\nreturn pneigh_delete(&arp_tbl, net, &ip, dev);\r\nif (mask)\r\nreturn -EINVAL;\r\nreturn arp_req_set_proxy(net, dev, 0);\r\n}\r\nstatic int arp_req_delete(struct net *net, struct arpreq *r,\r\nstruct net_device *dev)\r\n{\r\n__be32 ip;\r\nif (r->arp_flags & ATF_PUBL)\r\nreturn arp_req_delete_public(net, r, dev);\r\nip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\r\nif (dev == NULL) {\r\nstruct rtable *rt = ip_route_output(net, ip, 0, RTO_ONLINK, 0);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\ndev = rt->dst.dev;\r\nip_rt_put(rt);\r\nif (!dev)\r\nreturn -EINVAL;\r\n}\r\nreturn arp_invalidate(dev, ip);\r\n}\r\nint arp_ioctl(struct net *net, unsigned int cmd, void __user *arg)\r\n{\r\nint err;\r\nstruct arpreq r;\r\nstruct net_device *dev = NULL;\r\nswitch (cmd) {\r\ncase SIOCDARP:\r\ncase SIOCSARP:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ncase SIOCGARP:\r\nerr = copy_from_user(&r, arg, sizeof(struct arpreq));\r\nif (err)\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (r.arp_pa.sa_family != AF_INET)\r\nreturn -EPFNOSUPPORT;\r\nif (!(r.arp_flags & ATF_PUBL) &&\r\n(r.arp_flags & (ATF_NETMASK | ATF_DONTPUB)))\r\nreturn -EINVAL;\r\nif (!(r.arp_flags & ATF_NETMASK))\r\n((struct sockaddr_in *)&r.arp_netmask)->sin_addr.s_addr =\r\nhtonl(0xFFFFFFFFUL);\r\nrtnl_lock();\r\nif (r.arp_dev[0]) {\r\nerr = -ENODEV;\r\ndev = __dev_get_by_name(net, r.arp_dev);\r\nif (dev == NULL)\r\ngoto out;\r\nif (!r.arp_ha.sa_family)\r\nr.arp_ha.sa_family = dev->type;\r\nerr = -EINVAL;\r\nif ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)\r\ngoto out;\r\n} else if (cmd == SIOCGARP) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase SIOCDARP:\r\nerr = arp_req_delete(net, &r, dev);\r\nbreak;\r\ncase SIOCSARP:\r\nerr = arp_req_set(net, &r, dev);\r\nbreak;\r\ncase SIOCGARP:\r\nerr = arp_req_get(&r, dev);\r\nbreak;\r\n}\r\nout:\r\nrtnl_unlock();\r\nif (cmd == SIOCGARP && !err && copy_to_user(arg, &r, sizeof(r)))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int arp_netdev_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nswitch (event) {\r\ncase NETDEV_CHANGEADDR:\r\nneigh_changeaddr(&arp_tbl, dev);\r\nrt_cache_flush(dev_net(dev), 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid arp_ifdown(struct net_device *dev)\r\n{\r\nneigh_ifdown(&arp_tbl, dev);\r\n}\r\nvoid __init arp_init(void)\r\n{\r\nneigh_table_init(&arp_tbl);\r\ndev_add_pack(&arp_packet_type);\r\narp_proc_init();\r\n#ifdef CONFIG_SYSCTL\r\nneigh_sysctl_register(NULL, &arp_tbl.parms, "ipv4", NULL);\r\n#endif\r\nregister_netdevice_notifier(&arp_netdev_notifier);\r\n}\r\nstatic char *ax2asc2(ax25_address *a, char *buf)\r\n{\r\nchar c, *s;\r\nint n;\r\nfor (n = 0, s = buf; n < 6; n++) {\r\nc = (a->ax25_call[n] >> 1) & 0x7F;\r\nif (c != ' ')\r\n*s++ = c;\r\n}\r\n*s++ = '-';\r\nn = (a->ax25_call[6] >> 1) & 0x0F;\r\nif (n > 9) {\r\n*s++ = '1';\r\nn -= 10;\r\n}\r\n*s++ = n + '0';\r\n*s++ = '\0';\r\nif (*buf == '\0' || *buf == '-')\r\nreturn "*";\r\nreturn buf;\r\n}\r\nstatic void arp_format_neigh_entry(struct seq_file *seq,\r\nstruct neighbour *n)\r\n{\r\nchar hbuffer[HBUFFERLEN];\r\nint k, j;\r\nchar tbuf[16];\r\nstruct net_device *dev = n->dev;\r\nint hatype = dev->type;\r\nread_lock(&n->lock);\r\n#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)\r\nif (hatype == ARPHRD_AX25 || hatype == ARPHRD_NETROM)\r\nax2asc2((ax25_address *)n->ha, hbuffer);\r\nelse {\r\n#endif\r\nfor (k = 0, j = 0; k < HBUFFERLEN - 3 && j < dev->addr_len; j++) {\r\nhbuffer[k++] = hex_asc_hi(n->ha[j]);\r\nhbuffer[k++] = hex_asc_lo(n->ha[j]);\r\nhbuffer[k++] = ':';\r\n}\r\nif (k != 0)\r\n--k;\r\nhbuffer[k] = 0;\r\n#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)\r\n}\r\n#endif\r\nsprintf(tbuf, "%pI4", n->primary_key);\r\nseq_printf(seq, "%-16s 0x%-10x0x%-10x%s * %s\n",\r\ntbuf, hatype, arp_state_to_flags(n), hbuffer, dev->name);\r\nread_unlock(&n->lock);\r\n}\r\nstatic void arp_format_pneigh_entry(struct seq_file *seq,\r\nstruct pneigh_entry *n)\r\n{\r\nstruct net_device *dev = n->dev;\r\nint hatype = dev ? dev->type : 0;\r\nchar tbuf[16];\r\nsprintf(tbuf, "%pI4", n->key);\r\nseq_printf(seq, "%-16s 0x%-10x0x%-10x%s * %s\n",\r\ntbuf, hatype, ATF_PUBL | ATF_PERM, "00:00:00:00:00:00",\r\ndev ? dev->name : "*");\r\n}\r\nstatic int arp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "IP address HW type Flags "\r\n"HW address Mask Device\n");\r\n} else {\r\nstruct neigh_seq_state *state = seq->private;\r\nif (state->flags & NEIGH_SEQ_IS_PNEIGH)\r\narp_format_pneigh_entry(seq, v);\r\nelse\r\narp_format_neigh_entry(seq, v);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *arp_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn neigh_seq_start(seq, pos, &arp_tbl, NEIGH_SEQ_SKIP_NOARP);\r\n}\r\nstatic int arp_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &arp_seq_ops,\r\nsizeof(struct neigh_seq_state));\r\n}\r\nstatic int __net_init arp_net_init(struct net *net)\r\n{\r\nif (!proc_net_fops_create(net, "arp", S_IRUGO, &arp_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit arp_net_exit(struct net *net)\r\n{\r\nproc_net_remove(net, "arp");\r\n}\r\nstatic int __init arp_proc_init(void)\r\n{\r\nreturn register_pernet_subsys(&arp_net_ops);\r\n}\r\nstatic int __init arp_proc_init(void)\r\n{\r\nreturn 0;\r\n}
