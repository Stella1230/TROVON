static int tda10086_write_byte(struct tda10086_state *state, int reg, int data)\r\n{\r\nint ret;\r\nu8 b0[] = { reg, data };\r\nstruct i2c_msg msg = { .flags = 0, .buf = b0, .len = 2 };\r\nmsg.addr = state->config->demod_address;\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: error reg=0x%x, data=0x%x, ret=%i\n",\r\n__func__, reg, data, ret);\r\nreturn (ret != 1) ? ret : 0;\r\n}\r\nstatic int tda10086_read_byte(struct tda10086_state *state, int reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {{ .flags = 0, .buf = b0, .len = 1 },\r\n{ .flags = I2C_M_RD, .buf = b1, .len = 1 }};\r\nmsg[0].addr = state->config->demod_address;\r\nmsg[1].addr = state->config->demod_address;\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\ndprintk("%s: error reg=0x%x, ret=%i\n", __func__, reg,\r\nret);\r\nreturn ret;\r\n}\r\nreturn b1[0];\r\n}\r\nstatic int tda10086_write_mask(struct tda10086_state *state, int reg, int mask, int data)\r\n{\r\nint val;\r\nval = tda10086_read_byte(state, reg);\r\nif (val < 0)\r\nreturn val;\r\nval = val & ~mask;\r\nval |= data & 0xff;\r\nreturn tda10086_write_byte(state, reg, val);\r\n}\r\nstatic int tda10086_init(struct dvb_frontend* fe)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nu8 t22k_off = 0x80;\r\ndprintk ("%s\n", __func__);\r\nif (state->config->diseqc_tone)\r\nt22k_off = 0;\r\ntda10086_write_byte(state, 0x00, 0x00);\r\nmsleep(10);\r\ntda10086_write_byte(state, 0x01, 0x94);\r\ntda10086_write_byte(state, 0x02, 0x35);\r\ntda10086_write_byte(state, 0x03, 0xe4);\r\ntda10086_write_byte(state, 0x04, 0x43);\r\ntda10086_write_byte(state, 0x0c, 0x0c);\r\ntda10086_write_byte(state, 0x1b, 0xb0);\r\ntda10086_write_byte(state, 0x20, 0x89);\r\ntda10086_write_byte(state, 0x30, 0x04);\r\ntda10086_write_byte(state, 0x32, 0x00);\r\ntda10086_write_byte(state, 0x31, 0x56);\r\ntda10086_write_byte(state, 0x55, 0x2c);\r\nif (state->config->xtal_freq == TDA10086_XTAL_16M) {\r\ntda10086_write_byte(state, 0x3a, 0x0b);\r\ntda10086_write_byte(state, 0x3b, 0x01);\r\n} else {\r\ntda10086_write_byte(state, 0x3a, 0x17);\r\ntda10086_write_byte(state, 0x3b, 0x00);\r\n}\r\ntda10086_write_mask(state, 0x55, 0x20, 0x00);\r\ntda10086_write_byte(state, 0x11, 0x81);\r\ntda10086_write_byte(state, 0x12, 0x81);\r\ntda10086_write_byte(state, 0x19, 0x40);\r\ntda10086_write_byte(state, 0x56, 0x80);\r\ntda10086_write_byte(state, 0x57, 0x08);\r\ntda10086_write_byte(state, 0x10, 0x2a);\r\ntda10086_write_byte(state, 0x58, 0x61);\r\ntda10086_write_mask(state, 0x58, 0x01, 0x00);\r\ntda10086_write_byte(state, 0x05, 0x0B);\r\ntda10086_write_byte(state, 0x37, 0x63);\r\ntda10086_write_byte(state, 0x3f, 0x0a);\r\ntda10086_write_byte(state, 0x40, 0x64);\r\ntda10086_write_byte(state, 0x41, 0x4f);\r\ntda10086_write_byte(state, 0x42, 0x43);\r\ntda10086_write_byte(state, 0x1a, 0x11);\r\ntda10086_write_byte(state, 0x3d, 0x80);\r\ntda10086_write_byte(state, 0x36, t22k_off);\r\ntda10086_write_byte(state, 0x34, (((1<<19) * (22000/1000)) / (SACLK/1000)));\r\ntda10086_write_byte(state, 0x35, (((1<<19) * (22000/1000)) / (SACLK/1000)) >> 8);\r\nreturn 0;\r\n}\r\nstatic void tda10086_diseqc_wait(struct tda10086_state *state)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(200);\r\nwhile (!(tda10086_read_byte(state, 0x50) & 0x01)) {\r\nif(time_after(jiffies, timeout)) {\r\nprintk("%s: diseqc queue not ready, command may be lost.\n", __func__);\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\nstatic int tda10086_set_tone (struct dvb_frontend* fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nu8 t22k_off = 0x80;\r\ndprintk ("%s\n", __func__);\r\nif (state->config->diseqc_tone)\r\nt22k_off = 0;\r\nswitch (tone) {\r\ncase SEC_TONE_OFF:\r\ntda10086_write_byte(state, 0x36, t22k_off);\r\nbreak;\r\ncase SEC_TONE_ON:\r\ntda10086_write_byte(state, 0x36, 0x01 + t22k_off);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10086_send_master_cmd (struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd* cmd)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nint i;\r\nu8 oldval;\r\nu8 t22k_off = 0x80;\r\ndprintk ("%s\n", __func__);\r\nif (state->config->diseqc_tone)\r\nt22k_off = 0;\r\nif (cmd->msg_len > 6)\r\nreturn -EINVAL;\r\noldval = tda10086_read_byte(state, 0x36);\r\nfor(i=0; i< cmd->msg_len; i++) {\r\ntda10086_write_byte(state, 0x48+i, cmd->msg[i]);\r\n}\r\ntda10086_write_byte(state, 0x36, (0x08 + t22k_off)\r\n| ((cmd->msg_len - 1) << 4));\r\ntda10086_diseqc_wait(state);\r\ntda10086_write_byte(state, 0x36, oldval);\r\nreturn 0;\r\n}\r\nstatic int tda10086_send_burst (struct dvb_frontend* fe, fe_sec_mini_cmd_t minicmd)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nu8 oldval = tda10086_read_byte(state, 0x36);\r\nu8 t22k_off = 0x80;\r\ndprintk ("%s\n", __func__);\r\nif (state->config->diseqc_tone)\r\nt22k_off = 0;\r\nswitch(minicmd) {\r\ncase SEC_MINI_A:\r\ntda10086_write_byte(state, 0x36, 0x04 + t22k_off);\r\nbreak;\r\ncase SEC_MINI_B:\r\ntda10086_write_byte(state, 0x36, 0x06 + t22k_off);\r\nbreak;\r\n}\r\ntda10086_diseqc_wait(state);\r\ntda10086_write_byte(state, 0x36, oldval);\r\nreturn 0;\r\n}\r\nstatic int tda10086_set_inversion(struct tda10086_state *state,\r\nstruct dvb_frontend_parameters *fe_params)\r\n{\r\nu8 invval = 0x80;\r\ndprintk ("%s %i %i\n", __func__, fe_params->inversion, state->config->invert);\r\nswitch(fe_params->inversion) {\r\ncase INVERSION_OFF:\r\nif (state->config->invert)\r\ninvval = 0x40;\r\nbreak;\r\ncase INVERSION_ON:\r\nif (!state->config->invert)\r\ninvval = 0x40;\r\nbreak;\r\ncase INVERSION_AUTO:\r\ninvval = 0x00;\r\nbreak;\r\n}\r\ntda10086_write_mask(state, 0x0c, 0xc0, invval);\r\nreturn 0;\r\n}\r\nstatic int tda10086_set_symbol_rate(struct tda10086_state *state,\r\nstruct dvb_frontend_parameters *fe_params)\r\n{\r\nu8 dfn = 0;\r\nu8 afs = 0;\r\nu8 byp = 0;\r\nu8 reg37 = 0x43;\r\nu8 reg42 = 0x43;\r\nu64 big;\r\nu32 tmp;\r\nu32 bdr;\r\nu32 bdri;\r\nu32 symbol_rate = fe_params->u.qpsk.symbol_rate;\r\ndprintk ("%s %i\n", __func__, symbol_rate);\r\nif (symbol_rate < (u32) (SACLK * 0.0137)) {\r\ndfn=4;\r\nafs=1;\r\n} else if (symbol_rate < (u32) (SACLK * 0.0208)) {\r\ndfn=4;\r\nafs=0;\r\n} else if (symbol_rate < (u32) (SACLK * 0.0270)) {\r\ndfn=3;\r\nafs=1;\r\n} else if (symbol_rate < (u32) (SACLK * 0.0416)) {\r\ndfn=3;\r\nafs=0;\r\n} else if (symbol_rate < (u32) (SACLK * 0.0550)) {\r\ndfn=2;\r\nafs=1;\r\n} else if (symbol_rate < (u32) (SACLK * 0.0833)) {\r\ndfn=2;\r\nafs=0;\r\n} else if (symbol_rate < (u32) (SACLK * 0.1100)) {\r\ndfn=1;\r\nafs=1;\r\n} else if (symbol_rate < (u32) (SACLK * 0.1666)) {\r\ndfn=1;\r\nafs=0;\r\n} else if (symbol_rate < (u32) (SACLK * 0.2200)) {\r\ndfn=0;\r\nafs=1;\r\n} else if (symbol_rate < (u32) (SACLK * 0.3333)) {\r\ndfn=0;\r\nafs=0;\r\n} else {\r\nreg37 = 0x63;\r\nreg42 = 0x4f;\r\nbyp=1;\r\n}\r\nbig = (1ULL<<21) * ((u64) symbol_rate/1000ULL) * (1ULL<<dfn);\r\nbig += ((SACLK/1000ULL)-1ULL);\r\ndo_div(big, (SACLK/1000ULL));\r\nbdr = big & 0xfffff;\r\ntmp = (1<<dfn)*(symbol_rate/1000);\r\nbdri = ((32 * (SACLK/1000)) + (tmp-1)) / tmp;\r\ntda10086_write_byte(state, 0x21, (afs << 7) | dfn);\r\ntda10086_write_mask(state, 0x20, 0x08, byp << 3);\r\ntda10086_write_byte(state, 0x06, bdr);\r\ntda10086_write_byte(state, 0x07, bdr >> 8);\r\ntda10086_write_byte(state, 0x08, bdr >> 16);\r\ntda10086_write_byte(state, 0x09, bdri);\r\ntda10086_write_byte(state, 0x37, reg37);\r\ntda10086_write_byte(state, 0x42, reg42);\r\nreturn 0;\r\n}\r\nstatic int tda10086_set_fec(struct tda10086_state *state,\r\nstruct dvb_frontend_parameters *fe_params)\r\n{\r\nu8 fecval;\r\ndprintk ("%s %i\n", __func__, fe_params->u.qpsk.fec_inner);\r\nswitch(fe_params->u.qpsk.fec_inner) {\r\ncase FEC_1_2:\r\nfecval = 0x00;\r\nbreak;\r\ncase FEC_2_3:\r\nfecval = 0x01;\r\nbreak;\r\ncase FEC_3_4:\r\nfecval = 0x02;\r\nbreak;\r\ncase FEC_4_5:\r\nfecval = 0x03;\r\nbreak;\r\ncase FEC_5_6:\r\nfecval = 0x04;\r\nbreak;\r\ncase FEC_6_7:\r\nfecval = 0x05;\r\nbreak;\r\ncase FEC_7_8:\r\nfecval = 0x06;\r\nbreak;\r\ncase FEC_8_9:\r\nfecval = 0x07;\r\nbreak;\r\ncase FEC_AUTO:\r\nfecval = 0x08;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\ntda10086_write_byte(state, 0x0d, fecval);\r\nreturn 0;\r\n}\r\nstatic int tda10086_set_frontend(struct dvb_frontend* fe,\r\nstruct dvb_frontend_parameters *fe_params)\r\n{\r\nstruct tda10086_state *state = fe->demodulator_priv;\r\nint ret;\r\nu32 freq = 0;\r\nint freqoff;\r\ndprintk ("%s\n", __func__);\r\ntda10086_write_byte(state, 0x02, 0x35);\r\nstate->has_lock = false;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe, fe_params);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (fe->ops.tuner_ops.get_frequency)\r\nfe->ops.tuner_ops.get_frequency(fe, &freq);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nfreqoff = fe_params->frequency - freq;\r\nfreqoff = ((1<<16) * freqoff) / (SACLK/1000);\r\ntda10086_write_byte(state, 0x3d, 0x80 | ((freqoff >> 8) & 0x7f));\r\ntda10086_write_byte(state, 0x3e, freqoff);\r\nif ((ret = tda10086_set_inversion(state, fe_params)) < 0)\r\nreturn ret;\r\nif ((ret = tda10086_set_symbol_rate(state, fe_params)) < 0)\r\nreturn ret;\r\nif ((ret = tda10086_set_fec(state, fe_params)) < 0)\r\nreturn ret;\r\ntda10086_write_mask(state, 0x10, 0x40, 0x40);\r\ntda10086_write_mask(state, 0x00, 0x01, 0x00);\r\nstate->symbol_rate = fe_params->u.qpsk.symbol_rate;\r\nstate->frequency = fe_params->frequency;\r\nreturn 0;\r\n}\r\nstatic int tda10086_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *fe_params)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nu8 val;\r\nint tmp;\r\nu64 tmp64;\r\ndprintk ("%s\n", __func__);\r\nif (fe_params->u.qpsk.symbol_rate < 500000)\r\nreturn -EINVAL;\r\ntmp64 = tda10086_read_byte(state, 0x52);\r\ntmp64 |= (tda10086_read_byte(state, 0x51) << 8);\r\nif (tmp64 & 0x8000)\r\ntmp64 |= 0xffffffffffff0000ULL;\r\ntmp64 = (tmp64 * (SACLK/1000ULL));\r\ndo_div(tmp64, (1ULL<<15) * (1ULL<<1));\r\nfe_params->frequency = (int) state->frequency + (int) tmp64;\r\nval = tda10086_read_byte(state, 0x0c);\r\nif (val & 0x80) {\r\nswitch(val & 0x40) {\r\ncase 0x00:\r\nfe_params->inversion = INVERSION_OFF;\r\nif (state->config->invert)\r\nfe_params->inversion = INVERSION_ON;\r\nbreak;\r\ndefault:\r\nfe_params->inversion = INVERSION_ON;\r\nif (state->config->invert)\r\nfe_params->inversion = INVERSION_OFF;\r\nbreak;\r\n}\r\n} else {\r\ntda10086_read_byte(state, 0x0f);\r\nswitch(val & 0x02) {\r\ncase 0x00:\r\nfe_params->inversion = INVERSION_OFF;\r\nif (state->config->invert)\r\nfe_params->inversion = INVERSION_ON;\r\nbreak;\r\ndefault:\r\nfe_params->inversion = INVERSION_ON;\r\nif (state->config->invert)\r\nfe_params->inversion = INVERSION_OFF;\r\nbreak;\r\n}\r\n}\r\ntmp = tda10086_read_byte(state, 0x1d);\r\nif (tmp & 0x80)\r\ntmp |= 0xffffff00;\r\ntmp = (tmp * 480 * (1<<1)) / 128;\r\ntmp = ((state->symbol_rate/1000) * tmp) / (1000000/1000);\r\nfe_params->u.qpsk.symbol_rate = state->symbol_rate + tmp;\r\nval = (tda10086_read_byte(state, 0x0d) & 0x70) >> 4;\r\nswitch(val) {\r\ncase 0x00:\r\nfe_params->u.qpsk.fec_inner = FEC_1_2;\r\nbreak;\r\ncase 0x01:\r\nfe_params->u.qpsk.fec_inner = FEC_2_3;\r\nbreak;\r\ncase 0x02:\r\nfe_params->u.qpsk.fec_inner = FEC_3_4;\r\nbreak;\r\ncase 0x03:\r\nfe_params->u.qpsk.fec_inner = FEC_4_5;\r\nbreak;\r\ncase 0x04:\r\nfe_params->u.qpsk.fec_inner = FEC_5_6;\r\nbreak;\r\ncase 0x05:\r\nfe_params->u.qpsk.fec_inner = FEC_6_7;\r\nbreak;\r\ncase 0x06:\r\nfe_params->u.qpsk.fec_inner = FEC_7_8;\r\nbreak;\r\ncase 0x07:\r\nfe_params->u.qpsk.fec_inner = FEC_8_9;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10086_read_status(struct dvb_frontend* fe, fe_status_t *fe_status)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nu8 val;\r\ndprintk ("%s\n", __func__);\r\nval = tda10086_read_byte(state, 0x0e);\r\n*fe_status = 0;\r\nif (val & 0x01)\r\n*fe_status |= FE_HAS_SIGNAL;\r\nif (val & 0x02)\r\n*fe_status |= FE_HAS_CARRIER;\r\nif (val & 0x04)\r\n*fe_status |= FE_HAS_VITERBI;\r\nif (val & 0x08)\r\n*fe_status |= FE_HAS_SYNC;\r\nif (val & 0x10) {\r\n*fe_status |= FE_HAS_LOCK;\r\nif (!state->has_lock) {\r\nstate->has_lock = true;\r\ntda10086_write_byte(state, 0x02, 0x00);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10086_read_signal_strength(struct dvb_frontend* fe, u16 * signal)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nu8 _str;\r\ndprintk ("%s\n", __func__);\r\n_str = 0xff - tda10086_read_byte(state, 0x43);\r\n*signal = (_str << 8) | _str;\r\nreturn 0;\r\n}\r\nstatic int tda10086_read_snr(struct dvb_frontend* fe, u16 * snr)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\nu8 _snr;\r\ndprintk ("%s\n", __func__);\r\n_snr = 0xff - tda10086_read_byte(state, 0x1c);\r\n*snr = (_snr << 8) | _snr;\r\nreturn 0;\r\n}\r\nstatic int tda10086_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\ndprintk ("%s\n", __func__);\r\n*ucblocks = tda10086_read_byte(state, 0x18) & 0x7f;\r\ntda10086_write_byte(state, 0x18, 0x00);\r\ntda10086_write_byte(state, 0x18, 0x80);\r\nreturn 0;\r\n}\r\nstatic int tda10086_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\ndprintk ("%s\n", __func__);\r\n*ber = 0;\r\n*ber |= tda10086_read_byte(state, 0x15);\r\n*ber |= tda10086_read_byte(state, 0x16) << 8;\r\n*ber |= (tda10086_read_byte(state, 0x17) & 0xf) << 16;\r\nreturn 0;\r\n}\r\nstatic int tda10086_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\ndprintk ("%s\n", __func__);\r\ntda10086_write_mask(state, 0x00, 0x08, 0x08);\r\nreturn 0;\r\n}\r\nstatic int tda10086_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct tda10086_state* state = fe->demodulator_priv;\r\ndprintk ("%s\n", __func__);\r\nif (enable) {\r\ntda10086_write_mask(state, 0x00, 0x10, 0x10);\r\n} else {\r\ntda10086_write_mask(state, 0x00, 0x10, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda10086_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\r\n{\r\nif (fesettings->parameters.u.qpsk.symbol_rate > 20000000) {\r\nfesettings->min_delay_ms = 50;\r\nfesettings->step_size = 2000;\r\nfesettings->max_drift = 8000;\r\n} else if (fesettings->parameters.u.qpsk.symbol_rate > 12000000) {\r\nfesettings->min_delay_ms = 100;\r\nfesettings->step_size = 1500;\r\nfesettings->max_drift = 9000;\r\n} else if (fesettings->parameters.u.qpsk.symbol_rate > 8000000) {\r\nfesettings->min_delay_ms = 100;\r\nfesettings->step_size = 1000;\r\nfesettings->max_drift = 8000;\r\n} else if (fesettings->parameters.u.qpsk.symbol_rate > 4000000) {\r\nfesettings->min_delay_ms = 100;\r\nfesettings->step_size = 500;\r\nfesettings->max_drift = 7000;\r\n} else if (fesettings->parameters.u.qpsk.symbol_rate > 2000000) {\r\nfesettings->min_delay_ms = 200;\r\nfesettings->step_size = (fesettings->parameters.u.qpsk.symbol_rate / 8000);\r\nfesettings->max_drift = 14 * fesettings->step_size;\r\n} else {\r\nfesettings->min_delay_ms = 200;\r\nfesettings->step_size = (fesettings->parameters.u.qpsk.symbol_rate / 8000);\r\nfesettings->max_drift = 18 * fesettings->step_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tda10086_release(struct dvb_frontend* fe)\r\n{\r\nstruct tda10086_state *state = fe->demodulator_priv;\r\ntda10086_sleep(fe);\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* tda10086_attach(const struct tda10086_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct tda10086_state *state;\r\ndprintk ("%s\n", __func__);\r\nstate = kzalloc(sizeof(struct tda10086_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif (tda10086_read_byte(state, 0x1e) != 0xe1) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nmemcpy(&state->frontend.ops, &tda10086_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\n}
