static int bonding_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nLOG_MSG("comedi%d\n", dev->minor);\r\nif (alloc_private(dev, sizeof(struct Private)) < 0)\r\nreturn -ENOMEM;\r\nif (!doDevConfig(dev, it))\r\nreturn -EINVAL;\r\ndev->board_name = devpriv->name;\r\nif (alloc_subdevices(dev, 1) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = devpriv->nchans;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = bonding_dio_insn_bits;\r\ns->insn_config = bonding_dio_insn_config;\r\nLOG_MSG("attached with %u DIO channels coming from %u different "\r\n"subdevices all bonded together. "\r\n"John Lennon would be proud!\n",\r\ndevpriv->nchans, devpriv->ndevs);\r\nreturn 1;\r\n}\r\nstatic int bonding_detach(struct comedi_device *dev)\r\n{\r\nLOG_MSG("comedi%d: remove\n", dev->minor);\r\ndoDevUnconfig(dev);\r\nreturn 0;\r\n}\r\nstatic int bonding_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\n#define LSAMPL_BITS (sizeof(unsigned int)*8)\r\nunsigned nchans = LSAMPL_BITS, num_done = 0, i;\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nif (devpriv->nchans < nchans)\r\nnchans = devpriv->nchans;\r\nfor (i = 0; num_done < nchans && i < devpriv->ndevs; ++i) {\r\nstruct BondedDevice *bdev = devpriv->devs[i];\r\nunsigned int subdevMask = ((1 << bdev->nchans) - 1);\r\nunsigned int writeMask, dataBits;\r\nif (bdev->nchans >= LSAMPL_BITS)\r\nsubdevMask = (unsigned int)(-1);\r\nwriteMask = (data[0] >> num_done) & subdevMask;\r\ndataBits = (data[1] >> num_done) & subdevMask;\r\nif (comedi_dio_bitfield(bdev->dev, bdev->subdev, writeMask,\r\n&dataBits) != 2)\r\nreturn -EINVAL;\r\ndata[1] &= ~(subdevMask << num_done);\r\ndata[1] |= (dataBits & subdevMask) << num_done;\r\ns->state = data[1];\r\nnum_done += bdev->nchans;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int bonding_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec), ret, io_bits = s->io_bits;\r\nunsigned int io;\r\nstruct BondedDevice *bdev;\r\nif (chan < 0 || chan >= devpriv->nchans)\r\nreturn -EINVAL;\r\nbdev = devpriv->chanIdDevMap[chan];\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\nio = COMEDI_OUTPUT;\r\nio_bits |= 1 << chan;\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\nio = COMEDI_INPUT;\r\nio_bits &= ~(1 << chan);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nchan -= bdev->chanid_offset;\r\nret = comedi_dio_config(bdev->dev, bdev->subdev, chan, io);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\ns->io_bits = io_bits;\r\nreturn insn->n;\r\n}\r\nstatic void *Realloc(const void *oldmem, size_t newlen, size_t oldlen)\r\n{\r\nvoid *newmem = kmalloc(newlen, GFP_KERNEL);\r\nif (newmem && oldmem)\r\nmemcpy(newmem, oldmem, min(oldlen, newlen));\r\nkfree(oldmem);\r\nreturn newmem;\r\n}\r\nstatic int doDevConfig(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nint i;\r\nstruct comedi_device *devs_opened[COMEDI_NUM_BOARD_MINORS];\r\nmemset(devs_opened, 0, sizeof(devs_opened));\r\ndevpriv->name[0] = 0;\r\nfor (i = 0; i < COMEDI_NDEVCONFOPTS && (!i || it->options[i]); ++i) {\r\nchar file[] = "/dev/comediXXXXXX";\r\nint minor = it->options[i];\r\nstruct comedi_device *d;\r\nint sdev = -1, nchans, tmp;\r\nstruct BondedDevice *bdev = NULL;\r\nif (minor < 0 || minor >= COMEDI_NUM_BOARD_MINORS) {\r\nERROR("Minor %d is invalid!\n", minor);\r\nreturn 0;\r\n}\r\nif (minor == dev->minor) {\r\nERROR("Cannot bond this driver to itself!\n");\r\nreturn 0;\r\n}\r\nif (devs_opened[minor]) {\r\nERROR("Minor %d specified more than once!\n", minor);\r\nreturn 0;\r\n}\r\nsnprintf(file, sizeof(file), "/dev/comedi%u", minor);\r\nfile[sizeof(file) - 1] = 0;\r\nd = devs_opened[minor] = comedi_open(file);\r\nif (!d) {\r\nERROR("Minor %u could not be opened\n", minor);\r\nreturn 0;\r\n}\r\nwhile ((sdev = comedi_find_subdevice_by_type(d, COMEDI_SUBD_DIO,\r\nsdev + 1)) > -1) {\r\nnchans = comedi_get_n_channels(d, sdev);\r\nif (nchans <= 0) {\r\nERROR("comedi_get_n_channels() returned %d "\r\n"on minor %u subdev %d!\n",\r\nnchans, minor, sdev);\r\nreturn 0;\r\n}\r\nbdev = kmalloc(sizeof(*bdev), GFP_KERNEL);\r\nif (!bdev) {\r\nERROR("Out of memory.\n");\r\nreturn 0;\r\n}\r\nbdev->dev = d;\r\nbdev->minor = minor;\r\nbdev->subdev = sdev;\r\nbdev->subdev_type = COMEDI_SUBD_DIO;\r\nbdev->nchans = nchans;\r\nbdev->chanid_offset = devpriv->nchans;\r\nwhile (nchans--)\r\ndevpriv->chanIdDevMap[devpriv->nchans++] = bdev;\r\ntmp = devpriv->ndevs * sizeof(bdev);\r\ndevpriv->devs =\r\nRealloc(devpriv->devs,\r\n++devpriv->ndevs * sizeof(bdev), tmp);\r\nif (!devpriv->devs) {\r\nERROR("Could not allocate memory. "\r\n"Out of memory?");\r\nreturn 0;\r\n}\r\ndevpriv->devs[devpriv->ndevs - 1] = bdev;\r\n{\r\nchar buf[20];\r\nint left =\r\nMAX_BOARD_NAME - strlen(devpriv->name) - 1;\r\nsnprintf(buf, sizeof(buf), "%d:%d ", dev->minor,\r\nbdev->subdev);\r\nbuf[sizeof(buf) - 1] = 0;\r\nstrncat(devpriv->name, buf, left);\r\n}\r\n}\r\n}\r\nif (!devpriv->nchans) {\r\nERROR("No channels found!\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void doDevUnconfig(struct comedi_device *dev)\r\n{\r\nunsigned long devs_closed = 0;\r\nif (devpriv) {\r\nwhile (devpriv->ndevs-- && devpriv->devs) {\r\nstruct BondedDevice *bdev;\r\nbdev = devpriv->devs[devpriv->ndevs];\r\nif (!bdev)\r\ncontinue;\r\nif (!(devs_closed & (0x1 << bdev->minor))) {\r\ncomedi_close(bdev->dev);\r\ndevs_closed |= (0x1 << bdev->minor);\r\n}\r\nkfree(bdev);\r\n}\r\nkfree(devpriv->devs);\r\ndevpriv->devs = NULL;\r\nkfree(devpriv);\r\ndev->private = NULL;\r\n}\r\n}\r\nstatic int __init init(void)\r\n{\r\nreturn comedi_driver_register(&driver_bonding);\r\n}\r\nstatic void __exit cleanup(void)\r\n{\r\ncomedi_driver_unregister(&driver_bonding);\r\n}
