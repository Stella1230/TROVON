static inline void writeq(__u64 val, volatile void __iomem *addr)\r\n{\r\nwritel(val, addr);\r\nwritel(val >> 32, addr+4);\r\n}\r\nstatic void einj_exec_ctx_init(struct apei_exec_context *ctx)\r\n{\r\napei_exec_ctx_init(ctx, einj_ins_type, ARRAY_SIZE(einj_ins_type),\r\nEINJ_TAB_ENTRY(einj_tab), einj_tab->entries);\r\n}\r\nstatic int __einj_get_available_error_type(u32 *type)\r\n{\r\nstruct apei_exec_context ctx;\r\nint rc;\r\neinj_exec_ctx_init(&ctx);\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_GET_ERROR_TYPE);\r\nif (rc)\r\nreturn rc;\r\n*type = apei_exec_ctx_get_output(&ctx);\r\nreturn 0;\r\n}\r\nstatic int einj_get_available_error_type(u32 *type)\r\n{\r\nint rc;\r\nmutex_lock(&einj_mutex);\r\nrc = __einj_get_available_error_type(type);\r\nmutex_unlock(&einj_mutex);\r\nreturn rc;\r\n}\r\nstatic int einj_timedout(u64 *t)\r\n{\r\nif ((s64)*t < SPIN_UNIT) {\r\npr_warning(FW_WARN EINJ_PFX\r\n"Firmware does not respond in time\n");\r\nreturn 1;\r\n}\r\n*t -= SPIN_UNIT;\r\nndelay(SPIN_UNIT);\r\ntouch_nmi_watchdog();\r\nreturn 0;\r\n}\r\nstatic u64 einj_get_parameter_address(void)\r\n{\r\nint i;\r\nu64 paddr = 0;\r\nstruct acpi_whea_header *entry;\r\nentry = EINJ_TAB_ENTRY(einj_tab);\r\nfor (i = 0; i < einj_tab->entries; i++) {\r\nif (entry->action == ACPI_EINJ_SET_ERROR_TYPE &&\r\nentry->instruction == ACPI_EINJ_WRITE_REGISTER &&\r\nentry->register_region.space_id ==\r\nACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nmemcpy(&paddr, &entry->register_region.address,\r\nsizeof(paddr));\r\nentry++;\r\n}\r\nreturn paddr;\r\n}\r\nstatic int einj_check_trigger_header(struct acpi_einj_trigger *trigger_tab)\r\n{\r\nif (trigger_tab->header_size != sizeof(struct acpi_einj_trigger))\r\nreturn -EINVAL;\r\nif (trigger_tab->table_size > PAGE_SIZE ||\r\ntrigger_tab->table_size <= trigger_tab->header_size)\r\nreturn -EINVAL;\r\nif (trigger_tab->entry_count !=\r\n(trigger_tab->table_size - trigger_tab->header_size) /\r\nsizeof(struct acpi_einj_entry))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __einj_error_trigger(u64 trigger_paddr)\r\n{\r\nstruct acpi_einj_trigger *trigger_tab = NULL;\r\nstruct apei_exec_context trigger_ctx;\r\nstruct apei_resources trigger_resources;\r\nstruct acpi_whea_header *trigger_entry;\r\nstruct resource *r;\r\nu32 table_size;\r\nint rc = -EIO;\r\nr = request_mem_region(trigger_paddr, sizeof(*trigger_tab),\r\n"APEI EINJ Trigger Table");\r\nif (!r) {\r\npr_err(EINJ_PFX\r\n"Can not request iomem region <%016llx-%016llx> for Trigger table.\n",\r\n(unsigned long long)trigger_paddr,\r\n(unsigned long long)trigger_paddr+sizeof(*trigger_tab));\r\ngoto out;\r\n}\r\ntrigger_tab = ioremap_cache(trigger_paddr, sizeof(*trigger_tab));\r\nif (!trigger_tab) {\r\npr_err(EINJ_PFX "Failed to map trigger table!\n");\r\ngoto out_rel_header;\r\n}\r\nrc = einj_check_trigger_header(trigger_tab);\r\nif (rc) {\r\npr_warning(FW_BUG EINJ_PFX\r\n"The trigger error action table is invalid\n");\r\ngoto out_rel_header;\r\n}\r\nrc = -EIO;\r\ntable_size = trigger_tab->table_size;\r\nr = request_mem_region(trigger_paddr + sizeof(*trigger_tab),\r\ntable_size - sizeof(*trigger_tab),\r\n"APEI EINJ Trigger Table");\r\nif (!r) {\r\npr_err(EINJ_PFX\r\n"Can not request iomem region <%016llx-%016llx> for Trigger Table Entry.\n",\r\n(unsigned long long)trigger_paddr+sizeof(*trigger_tab),\r\n(unsigned long long)trigger_paddr + table_size);\r\ngoto out_rel_header;\r\n}\r\niounmap(trigger_tab);\r\ntrigger_tab = ioremap_cache(trigger_paddr, table_size);\r\nif (!trigger_tab) {\r\npr_err(EINJ_PFX "Failed to map trigger table!\n");\r\ngoto out_rel_entry;\r\n}\r\ntrigger_entry = (struct acpi_whea_header *)\r\n((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\r\napei_resources_init(&trigger_resources);\r\napei_exec_ctx_init(&trigger_ctx, einj_ins_type,\r\nARRAY_SIZE(einj_ins_type),\r\ntrigger_entry, trigger_tab->entry_count);\r\nrc = apei_exec_collect_resources(&trigger_ctx, &trigger_resources);\r\nif (rc)\r\ngoto out_fini;\r\nrc = apei_resources_sub(&trigger_resources, &einj_resources);\r\nif (rc)\r\ngoto out_fini;\r\nrc = apei_resources_request(&trigger_resources, "APEI EINJ Trigger");\r\nif (rc)\r\ngoto out_fini;\r\nrc = apei_exec_pre_map_gars(&trigger_ctx);\r\nif (rc)\r\ngoto out_release;\r\nrc = apei_exec_run(&trigger_ctx, ACPI_EINJ_TRIGGER_ERROR);\r\napei_exec_post_unmap_gars(&trigger_ctx);\r\nout_release:\r\napei_resources_release(&trigger_resources);\r\nout_fini:\r\napei_resources_fini(&trigger_resources);\r\nout_rel_entry:\r\nrelease_mem_region(trigger_paddr + sizeof(*trigger_tab),\r\ntable_size - sizeof(*trigger_tab));\r\nout_rel_header:\r\nrelease_mem_region(trigger_paddr, sizeof(*trigger_tab));\r\nout:\r\nif (trigger_tab)\r\niounmap(trigger_tab);\r\nreturn rc;\r\n}\r\nstatic int __einj_error_inject(u32 type, u64 param1, u64 param2)\r\n{\r\nstruct apei_exec_context ctx;\r\nu64 val, trigger_paddr, timeout = FIRMWARE_TIMEOUT;\r\nint rc;\r\neinj_exec_ctx_init(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_EINJ_BEGIN_OPERATION);\r\nif (rc)\r\nreturn rc;\r\napei_exec_ctx_set_input(&ctx, type);\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_SET_ERROR_TYPE);\r\nif (rc)\r\nreturn rc;\r\nif (einj_param) {\r\nwriteq(param1, &einj_param->param1);\r\nwriteq(param2, &einj_param->param2);\r\n}\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_EXECUTE_OPERATION);\r\nif (rc)\r\nreturn rc;\r\nfor (;;) {\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_CHECK_BUSY_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nif (!(val & EINJ_OP_BUSY))\r\nbreak;\r\nif (einj_timedout(&timeout))\r\nreturn -EIO;\r\n}\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_GET_COMMAND_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nif (val != EINJ_STATUS_SUCCESS)\r\nreturn -EBUSY;\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_GET_TRIGGER_TABLE);\r\nif (rc)\r\nreturn rc;\r\ntrigger_paddr = apei_exec_ctx_get_output(&ctx);\r\nrc = __einj_error_trigger(trigger_paddr);\r\nif (rc)\r\nreturn rc;\r\nrc = apei_exec_run_optional(&ctx, ACPI_EINJ_END_OPERATION);\r\nreturn rc;\r\n}\r\nstatic int einj_error_inject(u32 type, u64 param1, u64 param2)\r\n{\r\nint rc;\r\nmutex_lock(&einj_mutex);\r\nrc = __einj_error_inject(type, param1, param2);\r\nmutex_unlock(&einj_mutex);\r\nreturn rc;\r\n}\r\nstatic int available_error_type_show(struct seq_file *m, void *v)\r\n{\r\nint rc;\r\nu32 available_error_type = 0;\r\nrc = einj_get_available_error_type(&available_error_type);\r\nif (rc)\r\nreturn rc;\r\nif (available_error_type & 0x0001)\r\nseq_printf(m, "0x00000001\tProcessor Correctable\n");\r\nif (available_error_type & 0x0002)\r\nseq_printf(m, "0x00000002\tProcessor Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0004)\r\nseq_printf(m, "0x00000004\tProcessor Uncorrectable fatal\n");\r\nif (available_error_type & 0x0008)\r\nseq_printf(m, "0x00000008\tMemory Correctable\n");\r\nif (available_error_type & 0x0010)\r\nseq_printf(m, "0x00000010\tMemory Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0020)\r\nseq_printf(m, "0x00000020\tMemory Uncorrectable fatal\n");\r\nif (available_error_type & 0x0040)\r\nseq_printf(m, "0x00000040\tPCI Express Correctable\n");\r\nif (available_error_type & 0x0080)\r\nseq_printf(m, "0x00000080\tPCI Express Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0100)\r\nseq_printf(m, "0x00000100\tPCI Express Uncorrectable fatal\n");\r\nif (available_error_type & 0x0200)\r\nseq_printf(m, "0x00000200\tPlatform Correctable\n");\r\nif (available_error_type & 0x0400)\r\nseq_printf(m, "0x00000400\tPlatform Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0800)\r\nseq_printf(m, "0x00000800\tPlatform Uncorrectable fatal\n");\r\nreturn 0;\r\n}\r\nstatic int available_error_type_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, available_error_type_show, NULL);\r\n}\r\nstatic int error_type_get(void *data, u64 *val)\r\n{\r\n*val = error_type;\r\nreturn 0;\r\n}\r\nstatic int error_type_set(void *data, u64 val)\r\n{\r\nint rc;\r\nu32 available_error_type = 0;\r\nif (val & (val - 1))\r\nreturn -EINVAL;\r\nrc = einj_get_available_error_type(&available_error_type);\r\nif (rc)\r\nreturn rc;\r\nif (!(val & available_error_type))\r\nreturn -EINVAL;\r\nerror_type = val;\r\nreturn 0;\r\n}\r\nstatic int error_inject_set(void *data, u64 val)\r\n{\r\nif (!error_type)\r\nreturn -EINVAL;\r\nreturn einj_error_inject(error_type, error_param1, error_param2);\r\n}\r\nstatic int einj_check_table(struct acpi_table_einj *einj_tab)\r\n{\r\nif ((einj_tab->header_length !=\r\n(sizeof(struct acpi_table_einj) - sizeof(einj_tab->header)))\r\n&& (einj_tab->header_length != sizeof(struct acpi_table_einj)))\r\nreturn -EINVAL;\r\nif (einj_tab->header.length < sizeof(struct acpi_table_einj))\r\nreturn -EINVAL;\r\nif (einj_tab->entries !=\r\n(einj_tab->header.length - sizeof(struct acpi_table_einj)) /\r\nsizeof(struct acpi_einj_entry))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init einj_init(void)\r\n{\r\nint rc;\r\nu64 param_paddr;\r\nacpi_status status;\r\nstruct dentry *fentry;\r\nstruct apei_exec_context ctx;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nstatus = acpi_get_table(ACPI_SIG_EINJ, 0,\r\n(struct acpi_table_header **)&einj_tab);\r\nif (status == AE_NOT_FOUND) {\r\npr_info(EINJ_PFX "Table is not found!\n");\r\nreturn -ENODEV;\r\n} else if (ACPI_FAILURE(status)) {\r\nconst char *msg = acpi_format_exception(status);\r\npr_err(EINJ_PFX "Failed to get table, %s\n", msg);\r\nreturn -EINVAL;\r\n}\r\nrc = einj_check_table(einj_tab);\r\nif (rc) {\r\npr_warning(FW_BUG EINJ_PFX "EINJ table is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nrc = -ENOMEM;\r\neinj_debug_dir = debugfs_create_dir("einj", apei_get_debugfs_dir());\r\nif (!einj_debug_dir)\r\ngoto err_cleanup;\r\nfentry = debugfs_create_file("available_error_type", S_IRUSR,\r\neinj_debug_dir, NULL,\r\n&available_error_type_fops);\r\nif (!fentry)\r\ngoto err_cleanup;\r\nfentry = debugfs_create_file("error_type", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, NULL, &error_type_fops);\r\nif (!fentry)\r\ngoto err_cleanup;\r\nfentry = debugfs_create_file("error_inject", S_IWUSR,\r\neinj_debug_dir, NULL, &error_inject_fops);\r\nif (!fentry)\r\ngoto err_cleanup;\r\napei_resources_init(&einj_resources);\r\neinj_exec_ctx_init(&ctx);\r\nrc = apei_exec_collect_resources(&ctx, &einj_resources);\r\nif (rc)\r\ngoto err_fini;\r\nrc = apei_resources_request(&einj_resources, "APEI EINJ");\r\nif (rc)\r\ngoto err_fini;\r\nrc = apei_exec_pre_map_gars(&ctx);\r\nif (rc)\r\ngoto err_release;\r\nif (param_extension) {\r\nparam_paddr = einj_get_parameter_address();\r\nif (param_paddr) {\r\neinj_param = ioremap(param_paddr, sizeof(*einj_param));\r\nrc = -ENOMEM;\r\nif (!einj_param)\r\ngoto err_unmap;\r\nfentry = debugfs_create_x64("param1", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, &error_param1);\r\nif (!fentry)\r\ngoto err_unmap;\r\nfentry = debugfs_create_x64("param2", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, &error_param2);\r\nif (!fentry)\r\ngoto err_unmap;\r\n} else\r\npr_warn(EINJ_PFX "Parameter extension is not supported.\n");\r\n}\r\npr_info(EINJ_PFX "Error INJection is initialized.\n");\r\nreturn 0;\r\nerr_unmap:\r\nif (einj_param)\r\niounmap(einj_param);\r\napei_exec_post_unmap_gars(&ctx);\r\nerr_release:\r\napei_resources_release(&einj_resources);\r\nerr_fini:\r\napei_resources_fini(&einj_resources);\r\nerr_cleanup:\r\ndebugfs_remove_recursive(einj_debug_dir);\r\nreturn rc;\r\n}\r\nstatic void __exit einj_exit(void)\r\n{\r\nstruct apei_exec_context ctx;\r\nif (einj_param)\r\niounmap(einj_param);\r\neinj_exec_ctx_init(&ctx);\r\napei_exec_post_unmap_gars(&ctx);\r\napei_resources_release(&einj_resources);\r\napei_resources_fini(&einj_resources);\r\ndebugfs_remove_recursive(einj_debug_dir);\r\n}
