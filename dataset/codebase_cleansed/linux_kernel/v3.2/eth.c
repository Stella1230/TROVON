int eth_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned len)\r\n{\r\nstruct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);\r\nif (type != ETH_P_802_3 && type != ETH_P_802_2)\r\neth->h_proto = htons(type);\r\nelse\r\neth->h_proto = htons(len);\r\nif (!saddr)\r\nsaddr = dev->dev_addr;\r\nmemcpy(eth->h_source, saddr, ETH_ALEN);\r\nif (daddr) {\r\nmemcpy(eth->h_dest, daddr, ETH_ALEN);\r\nreturn ETH_HLEN;\r\n}\r\nif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\r\nmemset(eth->h_dest, 0, ETH_ALEN);\r\nreturn ETH_HLEN;\r\n}\r\nreturn -ETH_HLEN;\r\n}\r\nint eth_rebuild_header(struct sk_buff *skb)\r\n{\r\nstruct ethhdr *eth = (struct ethhdr *)skb->data;\r\nstruct net_device *dev = skb->dev;\r\nswitch (eth->h_proto) {\r\n#ifdef CONFIG_INET\r\ncase htons(ETH_P_IP):\r\nreturn arp_find(eth->h_dest, skb);\r\n#endif\r\ndefault:\r\nprintk(KERN_DEBUG\r\n"%s: unable to resolve type %X addresses.\n",\r\ndev->name, ntohs(eth->h_proto));\r\nmemcpy(eth->h_source, dev->dev_addr, ETH_ALEN);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\n__be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ethhdr *eth;\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull_inline(skb, ETH_HLEN);\r\neth = eth_hdr(skb);\r\nif (unlikely(is_multicast_ether_addr(eth->h_dest))) {\r\nif (!compare_ether_addr_64bits(eth->h_dest, dev->broadcast))\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\n}\r\nelse if (1 ) {\r\nif (unlikely(compare_ether_addr_64bits(eth->h_dest, dev->dev_addr)))\r\nskb->pkt_type = PACKET_OTHERHOST;\r\n}\r\nif (netdev_uses_dsa_tags(dev))\r\nreturn htons(ETH_P_DSA);\r\nif (netdev_uses_trailer_tags(dev))\r\nreturn htons(ETH_P_TRAILER);\r\nif (ntohs(eth->h_proto) >= 1536)\r\nreturn eth->h_proto;\r\nif (skb->len >= 2 && *(unsigned short *)(skb->data) == 0xFFFF)\r\nreturn htons(ETH_P_802_3);\r\nreturn htons(ETH_P_802_2);\r\n}\r\nint eth_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nconst struct ethhdr *eth = eth_hdr(skb);\r\nmemcpy(haddr, eth->h_source, ETH_ALEN);\r\nreturn ETH_ALEN;\r\n}\r\nint eth_header_cache(const struct neighbour *neigh, struct hh_cache *hh, __be16 type)\r\n{\r\nstruct ethhdr *eth;\r\nconst struct net_device *dev = neigh->dev;\r\neth = (struct ethhdr *)\r\n(((u8 *) hh->hh_data) + (HH_DATA_OFF(sizeof(*eth))));\r\nif (type == htons(ETH_P_802_3))\r\nreturn -1;\r\neth->h_proto = type;\r\nmemcpy(eth->h_source, dev->dev_addr, ETH_ALEN);\r\nmemcpy(eth->h_dest, neigh->ha, ETH_ALEN);\r\nhh->hh_len = ETH_HLEN;\r\nreturn 0;\r\n}\r\nvoid eth_header_cache_update(struct hh_cache *hh,\r\nconst struct net_device *dev,\r\nconst unsigned char *haddr)\r\n{\r\nmemcpy(((u8 *) hh->hh_data) + HH_DATA_OFF(sizeof(struct ethhdr)),\r\nhaddr, ETH_ALEN);\r\n}\r\nint eth_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nreturn 0;\r\n}\r\nint eth_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < 68 || new_mtu > ETH_DATA_LEN)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nint eth_validate_addr(struct net_device *dev)\r\n{\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nreturn -EADDRNOTAVAIL;\r\nreturn 0;\r\n}\r\nvoid ether_setup(struct net_device *dev)\r\n{\r\ndev->header_ops = &eth_header_ops;\r\ndev->type = ARPHRD_ETHER;\r\ndev->hard_header_len = ETH_HLEN;\r\ndev->mtu = ETH_DATA_LEN;\r\ndev->addr_len = ETH_ALEN;\r\ndev->tx_queue_len = 1000;\r\ndev->flags = IFF_BROADCAST|IFF_MULTICAST;\r\ndev->priv_flags |= IFF_TX_SKB_SHARING;\r\nmemset(dev->broadcast, 0xFF, ETH_ALEN);\r\n}\r\nstruct net_device *alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs,\r\nunsigned int rxqs)\r\n{\r\nreturn alloc_netdev_mqs(sizeof_priv, "eth%d", ether_setup, txqs, rxqs);\r\n}\r\nstatic size_t _format_mac_addr(char *buf, int buflen,\r\nconst unsigned char *addr, int len)\r\n{\r\nint i;\r\nchar *cp = buf;\r\nfor (i = 0; i < len; i++) {\r\ncp += scnprintf(cp, buflen - (cp - buf), "%02x", addr[i]);\r\nif (i == len - 1)\r\nbreak;\r\ncp += scnprintf(cp, buflen - (cp - buf), ":");\r\n}\r\nreturn cp - buf;\r\n}\r\nssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len)\r\n{\r\nsize_t l;\r\nl = _format_mac_addr(buf, PAGE_SIZE, addr, len);\r\nl += scnprintf(buf + l, PAGE_SIZE - l, "\n");\r\nreturn (ssize_t)l;\r\n}
