static int set_use_inc(void *data)\r\n{\r\nint i, retval;\r\nstruct ttusbir_device *ttusbir = data;\r\nDPRINTK("Sending first URBs\n");\r\nttusbir->opened = 1;\r\nfor (i = 0; i < num_urbs; i++) {\r\nretval = usb_submit_urb(ttusbir->urb[i], GFP_KERNEL);\r\nif (retval) {\r\nerr("%s: usb_submit_urb failed on urb %d",\r\n__func__, i);\r\nreturn retval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_use_dec(void *data)\r\n{\r\nstruct ttusbir_device *ttusbir = data;\r\nDPRINTK("Device closed\n");\r\nttusbir->opened = 0;\r\n}\r\nstatic void urb_complete(struct urb *urb)\r\n{\r\nstruct ttusbir_device *ttusbir;\r\nunsigned char *buf;\r\nint i;\r\nint l;\r\nttusbir = urb->context;\r\nif (!ttusbir->opened)\r\nreturn;\r\nbuf = (unsigned char *)urb->transfer_buffer;\r\nfor (i = 0; i < 128; i++) {\r\nbuf[i] = ~map_table[buf[i]];\r\nif (ttusbir->last_pulse == buf[i]) {\r\nif (ttusbir->last_num < PULSE_MASK/63)\r\nttusbir->last_num++;\r\n} else {\r\nl = ttusbir->last_num * 62;\r\nif (ttusbir->last_pulse)\r\nl |= PULSE_BIT;\r\nif (!lirc_buffer_full(&ttusbir->rbuf)) {\r\nlirc_buffer_write(&ttusbir->rbuf, (void *)&l);\r\nwake_up_interruptible(&ttusbir->rbuf.wait_poll);\r\n}\r\nttusbir->last_num = 0;\r\nttusbir->last_pulse = buf[i];\r\n}\r\n}\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nint alt_set, endp;\r\nint found = 0;\r\nint i, j;\r\nint struct_size;\r\nstruct usb_host_interface *host_interf;\r\nstruct usb_interface_descriptor *interf_desc;\r\nstruct usb_host_endpoint *host_endpoint;\r\nstruct ttusbir_device *ttusbir;\r\nDPRINTK("Module ttusbir probe\n");\r\nstruct_size = sizeof(struct ttusbir_device) +\r\n(sizeof(struct urb *) * num_urbs) +\r\n(sizeof(char *) * num_urbs) +\r\n(num_urbs * 128);\r\nttusbir = kzalloc(struct_size, GFP_KERNEL);\r\nif (!ttusbir)\r\nreturn -ENOMEM;\r\nttusbir->urb = (struct urb **)((char *)ttusbir +\r\nsizeof(struct ttusbir_device));\r\nttusbir->buffer = (char **)((char *)ttusbir->urb +\r\n(sizeof(struct urb *) * num_urbs));\r\nfor (i = 0; i < num_urbs; i++)\r\nttusbir->buffer[i] = (char *)ttusbir->buffer +\r\n(sizeof(char *)*num_urbs) + (i * 128);\r\nttusbir->usb_driver = &usb_driver;\r\nttusbir->alt_setting = -1;\r\nttusbir->udev = usb_get_dev(interface_to_usbdev(intf));\r\nttusbir->interf = intf;\r\nttusbir->last_pulse = 0x00;\r\nttusbir->last_num = 0;\r\nfor (alt_set = 0; alt_set < intf->num_altsetting && !found; alt_set++) {\r\nhost_interf = &intf->altsetting[alt_set];\r\ninterf_desc = &host_interf->desc;\r\nfor (endp = 0; endp < interf_desc->bNumEndpoints; endp++) {\r\nhost_endpoint = &host_interf->endpoint[endp];\r\nif ((host_endpoint->desc.bEndpointAddress == 0x82) &&\r\n(host_endpoint->desc.wMaxPacketSize == 0x10)) {\r\nttusbir->alt_setting = alt_set;\r\nttusbir->endpoint = endp;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ttusbir->alt_setting != -1)\r\nDPRINTK("alt setting: %d\n", ttusbir->alt_setting);\r\nelse {\r\nerr("Could not find alternate setting\n");\r\nkfree(ttusbir);\r\nreturn -EINVAL;\r\n}\r\nusb_set_interface(ttusbir->udev, 0, ttusbir->alt_setting);\r\nusb_set_intfdata(intf, ttusbir);\r\nif (lirc_buffer_init(&ttusbir->rbuf, sizeof(int), 256) < 0) {\r\nerr("Could not get memory for LIRC data buffer\n");\r\nusb_set_intfdata(intf, NULL);\r\nkfree(ttusbir);\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(ttusbir->driver.name, "TTUSBIR");\r\nttusbir->driver.minor = -1;\r\nttusbir->driver.code_length = 1;\r\nttusbir->driver.sample_rate = 0;\r\nttusbir->driver.data = ttusbir;\r\nttusbir->driver.add_to_buf = NULL;\r\nttusbir->driver.rbuf = &ttusbir->rbuf;\r\nttusbir->driver.set_use_inc = set_use_inc;\r\nttusbir->driver.set_use_dec = set_use_dec;\r\nttusbir->driver.dev = &intf->dev;\r\nttusbir->driver.owner = THIS_MODULE;\r\nttusbir->driver.features = LIRC_CAN_REC_MODE2;\r\nttusbir->minor = lirc_register_driver(&ttusbir->driver);\r\nif (ttusbir->minor < 0) {\r\nerr("Error registering as LIRC driver\n");\r\nusb_set_intfdata(intf, NULL);\r\nlirc_buffer_free(&ttusbir->rbuf);\r\nkfree(ttusbir);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < num_urbs; i++) {\r\nttusbir->urb[i] = usb_alloc_urb(8, GFP_KERNEL);\r\nif (!ttusbir->urb[i]) {\r\nerr("Could not allocate memory for the URB\n");\r\nfor (j = i - 1; j >= 0; j--)\r\nkfree(ttusbir->urb[j]);\r\nlirc_buffer_free(&ttusbir->rbuf);\r\nlirc_unregister_driver(ttusbir->minor);\r\nkfree(ttusbir);\r\nusb_set_intfdata(intf, NULL);\r\nreturn -ENOMEM;\r\n}\r\nttusbir->urb[i]->dev = ttusbir->udev;\r\nttusbir->urb[i]->context = ttusbir;\r\nttusbir->urb[i]->pipe = usb_rcvisocpipe(ttusbir->udev,\r\nttusbir->endpoint);\r\nttusbir->urb[i]->interval = 1;\r\nttusbir->urb[i]->transfer_flags = URB_ISO_ASAP;\r\nttusbir->urb[i]->transfer_buffer = &ttusbir->buffer[i][0];\r\nttusbir->urb[i]->complete = urb_complete;\r\nttusbir->urb[i]->number_of_packets = 8;\r\nttusbir->urb[i]->transfer_buffer_length = 128;\r\nfor (j = 0; j < 8; j++) {\r\nttusbir->urb[i]->iso_frame_desc[j].offset = j*16;\r\nttusbir->urb[i]->iso_frame_desc[j].length = 16;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void disconnect(struct usb_interface *intf)\r\n{\r\nint i;\r\nstruct ttusbir_device *ttusbir;\r\nDPRINTK("Module ttusbir disconnect\n");\r\nttusbir = (struct ttusbir_device *) usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nlirc_unregister_driver(ttusbir->minor);\r\nDPRINTK("unregistered\n");\r\nfor (i = 0; i < num_urbs; i++) {\r\nusb_kill_urb(ttusbir->urb[i]);\r\nusb_free_urb(ttusbir->urb[i]);\r\n}\r\nDPRINTK("URBs killed\n");\r\nlirc_buffer_free(&ttusbir->rbuf);\r\nkfree(ttusbir);\r\n}\r\nstatic int ttusbir_init_module(void)\r\n{\r\nint result;\r\nDPRINTK(KERN_DEBUG "Module ttusbir init\n");\r\nresult = usb_register(&usb_driver);\r\nif (result)\r\nerr("usb_register failed. Error number %d", result);\r\nreturn result;\r\n}\r\nstatic void ttusbir_exit_module(void)\r\n{\r\nprintk(KERN_DEBUG "Module ttusbir exit\n");\r\nusb_deregister(&usb_driver);\r\n}
