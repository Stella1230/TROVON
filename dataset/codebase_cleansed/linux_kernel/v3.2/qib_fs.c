static int qibfs_mknod(struct inode *dir, struct dentry *dentry,\r\nint mode, const struct file_operations *fops,\r\nvoid *data)\r\n{\r\nint error;\r\nstruct inode *inode = new_inode(dir->i_sb);\r\nif (!inode) {\r\nerror = -EPERM;\r\ngoto bail;\r\n}\r\ninode->i_ino = get_next_ino();\r\ninode->i_mode = mode;\r\ninode->i_uid = 0;\r\ninode->i_gid = 0;\r\ninode->i_blocks = 0;\r\ninode->i_atime = CURRENT_TIME;\r\ninode->i_mtime = inode->i_atime;\r\ninode->i_ctime = inode->i_atime;\r\ninode->i_private = data;\r\nif ((mode & S_IFMT) == S_IFDIR) {\r\ninode->i_op = &simple_dir_inode_operations;\r\ninc_nlink(inode);\r\ninc_nlink(dir);\r\n}\r\ninode->i_fop = fops;\r\nd_instantiate(dentry, inode);\r\nerror = 0;\r\nbail:\r\nreturn error;\r\n}\r\nstatic int create_file(const char *name, mode_t mode,\r\nstruct dentry *parent, struct dentry **dentry,\r\nconst struct file_operations *fops, void *data)\r\n{\r\nint error;\r\n*dentry = NULL;\r\nmutex_lock(&parent->d_inode->i_mutex);\r\n*dentry = lookup_one_len(name, parent, strlen(name));\r\nif (!IS_ERR(*dentry))\r\nerror = qibfs_mknod(parent->d_inode, *dentry,\r\nmode, fops, data);\r\nelse\r\nerror = PTR_ERR(*dentry);\r\nmutex_unlock(&parent->d_inode->i_mutex);\r\nreturn error;\r\n}\r\nstatic ssize_t driver_stats_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(buf, count, ppos, &qib_stats,\r\nsizeof qib_stats);\r\n}\r\nstatic ssize_t driver_names_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(buf, count, ppos, qib_statnames,\r\nsizeof qib_statnames - 1);\r\n}\r\nstatic ssize_t dev_counters_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu64 *counters;\r\nsize_t avail;\r\nstruct qib_devdata *dd = private2dd(file);\r\navail = dd->f_read_cntrs(dd, *ppos, NULL, &counters);\r\nreturn simple_read_from_buffer(buf, count, ppos, counters, avail);\r\n}\r\nstatic ssize_t dev_names_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *names;\r\nsize_t avail;\r\nstruct qib_devdata *dd = private2dd(file);\r\navail = dd->f_read_cntrs(dd, *ppos, &names, NULL);\r\nreturn simple_read_from_buffer(buf, count, ppos, names, avail);\r\n}\r\nstatic ssize_t portnames_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *names;\r\nsize_t avail;\r\nstruct qib_devdata *dd = private2dd(file);\r\navail = dd->f_read_portcntrs(dd, *ppos, 0, &names, NULL);\r\nreturn simple_read_from_buffer(buf, count, ppos, names, avail);\r\n}\r\nstatic ssize_t portcntrs_1_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu64 *counters;\r\nsize_t avail;\r\nstruct qib_devdata *dd = private2dd(file);\r\navail = dd->f_read_portcntrs(dd, *ppos, 0, NULL, &counters);\r\nreturn simple_read_from_buffer(buf, count, ppos, counters, avail);\r\n}\r\nstatic ssize_t portcntrs_2_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu64 *counters;\r\nsize_t avail;\r\nstruct qib_devdata *dd = private2dd(file);\r\navail = dd->f_read_portcntrs(dd, *ppos, 1, NULL, &counters);\r\nreturn simple_read_from_buffer(buf, count, ppos, counters, avail);\r\n}\r\nstatic ssize_t qsfp_1_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct qib_devdata *dd = private2dd(file);\r\nchar *tmp;\r\nint ret;\r\ntmp = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nret = qib_qsfp_dump(dd->pport, tmp, PAGE_SIZE);\r\nif (ret > 0)\r\nret = simple_read_from_buffer(buf, count, ppos, tmp, ret);\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic ssize_t qsfp_2_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct qib_devdata *dd = private2dd(file);\r\nchar *tmp;\r\nint ret;\r\nif (dd->num_pports < 2)\r\nreturn -ENODEV;\r\ntmp = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nret = qib_qsfp_dump(dd->pport + 1, tmp, PAGE_SIZE);\r\nif (ret > 0)\r\nret = simple_read_from_buffer(buf, count, ppos, tmp, ret);\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic ssize_t flash_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct qib_devdata *dd;\r\nssize_t ret;\r\nloff_t pos;\r\nchar *tmp;\r\npos = *ppos;\r\nif (pos < 0) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (pos >= sizeof(struct qib_flash)) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nif (count > sizeof(struct qib_flash) - pos)\r\ncount = sizeof(struct qib_flash) - pos;\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\ndd = private2dd(file);\r\nif (qib_eeprom_read(dd, pos, tmp, count)) {\r\nqib_dev_err(dd, "failed to read from flash\n");\r\nret = -ENXIO;\r\ngoto bail_tmp;\r\n}\r\nif (copy_to_user(buf, tmp, count)) {\r\nret = -EFAULT;\r\ngoto bail_tmp;\r\n}\r\n*ppos = pos + count;\r\nret = count;\r\nbail_tmp:\r\nkfree(tmp);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t flash_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct qib_devdata *dd;\r\nssize_t ret;\r\nloff_t pos;\r\nchar *tmp;\r\npos = *ppos;\r\nif (pos != 0) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (count != sizeof(struct qib_flash)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nif (copy_from_user(tmp, buf, count)) {\r\nret = -EFAULT;\r\ngoto bail_tmp;\r\n}\r\ndd = private2dd(file);\r\nif (qib_eeprom_write(dd, pos, tmp, count)) {\r\nret = -ENXIO;\r\nqib_dev_err(dd, "failed to write to flash\n");\r\ngoto bail_tmp;\r\n}\r\n*ppos = pos + count;\r\nret = count;\r\nbail_tmp:\r\nkfree(tmp);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int add_cntr_files(struct super_block *sb, struct qib_devdata *dd)\r\n{\r\nstruct dentry *dir, *tmp;\r\nchar unit[10];\r\nint ret, i;\r\nsnprintf(unit, sizeof unit, "%u", dd->unit);\r\nret = create_file(unit, S_IFDIR|S_IRUGO|S_IXUGO, sb->s_root, &dir,\r\n&simple_dir_operations, dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s) failed: %d\n", unit, ret);\r\ngoto bail;\r\n}\r\nret = create_file("counters", S_IFREG|S_IRUGO, dir, &tmp,\r\n&cntr_ops[0], dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s/counters) failed: %d\n",\r\nunit, ret);\r\ngoto bail;\r\n}\r\nret = create_file("counter_names", S_IFREG|S_IRUGO, dir, &tmp,\r\n&cntr_ops[1], dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s/counter_names) failed: %d\n",\r\nunit, ret);\r\ngoto bail;\r\n}\r\nret = create_file("portcounter_names", S_IFREG|S_IRUGO, dir, &tmp,\r\n&portcntr_ops[0], dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s/%s) failed: %d\n",\r\nunit, "portcounter_names", ret);\r\ngoto bail;\r\n}\r\nfor (i = 1; i <= dd->num_pports; i++) {\r\nchar fname[24];\r\nsprintf(fname, "port%dcounters", i);\r\nret = create_file(fname, S_IFREG|S_IRUGO, dir, &tmp,\r\n&portcntr_ops[i], dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s/%s) failed: %d\n",\r\nunit, fname, ret);\r\ngoto bail;\r\n}\r\nif (!(dd->flags & QIB_HAS_QSFP))\r\ncontinue;\r\nsprintf(fname, "qsfp%d", i);\r\nret = create_file(fname, S_IFREG|S_IRUGO, dir, &tmp,\r\n&qsfp_ops[i - 1], dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s/%s) failed: %d\n",\r\nunit, fname, ret);\r\ngoto bail;\r\n}\r\n}\r\nret = create_file("flash", S_IFREG|S_IWUSR|S_IRUGO, dir, &tmp,\r\n&flash_ops, dd);\r\nif (ret)\r\nprintk(KERN_ERR "create_file(%s/flash) failed: %d\n",\r\nunit, ret);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int remove_file(struct dentry *parent, char *name)\r\n{\r\nstruct dentry *tmp;\r\nint ret;\r\ntmp = lookup_one_len(name, parent, strlen(name));\r\nif (IS_ERR(tmp)) {\r\nret = PTR_ERR(tmp);\r\ngoto bail;\r\n}\r\nspin_lock(&tmp->d_lock);\r\nif (!(d_unhashed(tmp) && tmp->d_inode)) {\r\ndget_dlock(tmp);\r\n__d_drop(tmp);\r\nspin_unlock(&tmp->d_lock);\r\nsimple_unlink(parent->d_inode, tmp);\r\n} else {\r\nspin_unlock(&tmp->d_lock);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int remove_device_files(struct super_block *sb,\r\nstruct qib_devdata *dd)\r\n{\r\nstruct dentry *dir, *root;\r\nchar unit[10];\r\nint ret, i;\r\nroot = dget(sb->s_root);\r\nmutex_lock(&root->d_inode->i_mutex);\r\nsnprintf(unit, sizeof unit, "%u", dd->unit);\r\ndir = lookup_one_len(unit, root, strlen(unit));\r\nif (IS_ERR(dir)) {\r\nret = PTR_ERR(dir);\r\nprintk(KERN_ERR "Lookup of %s failed\n", unit);\r\ngoto bail;\r\n}\r\nremove_file(dir, "counters");\r\nremove_file(dir, "counter_names");\r\nremove_file(dir, "portcounter_names");\r\nfor (i = 0; i < dd->num_pports; i++) {\r\nchar fname[24];\r\nsprintf(fname, "port%dcounters", i + 1);\r\nremove_file(dir, fname);\r\nif (dd->flags & QIB_HAS_QSFP) {\r\nsprintf(fname, "qsfp%d", i + 1);\r\nremove_file(dir, fname);\r\n}\r\n}\r\nremove_file(dir, "flash");\r\nd_delete(dir);\r\nret = simple_rmdir(root->d_inode, dir);\r\nbail:\r\nmutex_unlock(&root->d_inode->i_mutex);\r\ndput(root);\r\nreturn ret;\r\n}\r\nstatic int qibfs_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct qib_devdata *dd, *tmp;\r\nunsigned long flags;\r\nint ret;\r\nstatic struct tree_descr files[] = {\r\n[2] = {"driver_stats", &driver_ops[0], S_IRUGO},\r\n[3] = {"driver_stats_names", &driver_ops[1], S_IRUGO},\r\n{""},\r\n};\r\nret = simple_fill_super(sb, QIBFS_MAGIC, files);\r\nif (ret) {\r\nprintk(KERN_ERR "simple_fill_super failed: %d\n", ret);\r\ngoto bail;\r\n}\r\nspin_lock_irqsave(&qib_devs_lock, flags);\r\nlist_for_each_entry_safe(dd, tmp, &qib_dev_list, list) {\r\nspin_unlock_irqrestore(&qib_devs_lock, flags);\r\nret = add_cntr_files(sb, dd);\r\nif (ret)\r\ngoto bail;\r\nspin_lock_irqsave(&qib_devs_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&qib_devs_lock, flags);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic struct dentry *qibfs_mount(struct file_system_type *fs_type, int flags,\r\nconst char *dev_name, void *data)\r\n{\r\nstruct dentry *ret;\r\nret = mount_single(fs_type, flags, data, qibfs_fill_super);\r\nif (!IS_ERR(ret))\r\nqib_super = ret->d_sb;\r\nreturn ret;\r\n}\r\nstatic void qibfs_kill_super(struct super_block *s)\r\n{\r\nkill_litter_super(s);\r\nqib_super = NULL;\r\n}\r\nint qibfs_add(struct qib_devdata *dd)\r\n{\r\nint ret;\r\nif (qib_super == NULL)\r\nret = 0;\r\nelse\r\nret = add_cntr_files(qib_super, dd);\r\nreturn ret;\r\n}\r\nint qibfs_remove(struct qib_devdata *dd)\r\n{\r\nint ret = 0;\r\nif (qib_super)\r\nret = remove_device_files(qib_super, dd);\r\nreturn ret;\r\n}\r\nint __init qib_init_qibfs(void)\r\n{\r\nreturn register_filesystem(&qibfs_fs_type);\r\n}\r\nint __exit qib_exit_qibfs(void)\r\n{\r\nreturn unregister_filesystem(&qibfs_fs_type);\r\n}
