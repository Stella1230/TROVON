static int gfs2_aspace_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nstruct buffer_head *bh, *head;\r\nint nr_underway = 0;\r\nint write_op = REQ_META | REQ_PRIO |\r\n(wbc->sync_mode == WB_SYNC_ALL ? WRITE_SYNC : WRITE);\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(!page_has_buffers(page));\r\nhead = page_buffers(page);\r\nbh = head;\r\ndo {\r\nif (!buffer_mapped(bh))\r\ncontinue;\r\nif (wbc->sync_mode != WB_SYNC_NONE) {\r\nlock_buffer(bh);\r\n} else if (!trylock_buffer(bh)) {\r\nredirty_page_for_writepage(wbc, page);\r\ncontinue;\r\n}\r\nif (test_clear_buffer_dirty(bh)) {\r\nmark_buffer_async_write(bh);\r\n} else {\r\nunlock_buffer(bh);\r\n}\r\n} while ((bh = bh->b_this_page) != head);\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\ndo {\r\nstruct buffer_head *next = bh->b_this_page;\r\nif (buffer_async_write(bh)) {\r\nsubmit_bh(write_op, bh);\r\nnr_underway++;\r\n}\r\nbh = next;\r\n} while (bh != head);\r\nunlock_page(page);\r\nif (nr_underway == 0)\r\nend_page_writeback(page);\r\nreturn 0;\r\n}\r\nvoid gfs2_meta_sync(struct gfs2_glock *gl)\r\n{\r\nstruct address_space *mapping = gfs2_glock2aspace(gl);\r\nint error;\r\nfilemap_fdatawrite(mapping);\r\nerror = filemap_fdatawait(mapping);\r\nif (error)\r\ngfs2_io_error(gl->gl_sbd);\r\n}\r\nstruct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)\r\n{\r\nstruct address_space *mapping = gfs2_glock2aspace(gl);\r\nstruct gfs2_sbd *sdp = gl->gl_sbd;\r\nstruct page *page;\r\nstruct buffer_head *bh;\r\nunsigned int shift;\r\nunsigned long index;\r\nunsigned int bufnum;\r\nshift = PAGE_CACHE_SHIFT - sdp->sd_sb.sb_bsize_shift;\r\nindex = blkno >> shift;\r\nbufnum = blkno - (index << shift);\r\nif (create) {\r\nfor (;;) {\r\npage = grab_cache_page(mapping, index);\r\nif (page)\r\nbreak;\r\nyield();\r\n}\r\n} else {\r\npage = find_lock_page(mapping, index);\r\nif (!page)\r\nreturn NULL;\r\n}\r\nif (!page_has_buffers(page))\r\ncreate_empty_buffers(page, sdp->sd_sb.sb_bsize, 0);\r\nfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\r\n;\r\nget_bh(bh);\r\nif (!buffer_mapped(bh))\r\nmap_bh(bh, sdp->sd_vfs, blkno);\r\nunlock_page(page);\r\nmark_page_accessed(page);\r\npage_cache_release(page);\r\nreturn bh;\r\n}\r\nstatic void meta_prep_new(struct buffer_head *bh)\r\n{\r\nstruct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;\r\nlock_buffer(bh);\r\nclear_buffer_dirty(bh);\r\nset_buffer_uptodate(bh);\r\nunlock_buffer(bh);\r\nmh->mh_magic = cpu_to_be32(GFS2_MAGIC);\r\n}\r\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\r\n{\r\nstruct buffer_head *bh;\r\nbh = gfs2_getbuf(gl, blkno, CREATE);\r\nmeta_prep_new(bh);\r\nreturn bh;\r\n}\r\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\r\nstruct buffer_head **bhp)\r\n{\r\nstruct gfs2_sbd *sdp = gl->gl_sbd;\r\nstruct buffer_head *bh;\r\nif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\r\nreturn -EIO;\r\n*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\r\nlock_buffer(bh);\r\nif (buffer_uptodate(bh)) {\r\nunlock_buffer(bh);\r\nreturn 0;\r\n}\r\nbh->b_end_io = end_buffer_read_sync;\r\nget_bh(bh);\r\nsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\r\nif (!(flags & DIO_WAIT))\r\nreturn 0;\r\nwait_on_buffer(bh);\r\nif (unlikely(!buffer_uptodate(bh))) {\r\nstruct gfs2_trans *tr = current->journal_info;\r\nif (tr && tr->tr_touched)\r\ngfs2_io_error_bh(sdp, bh);\r\nbrelse(bh);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)\r\n{\r\nif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\r\nreturn -EIO;\r\nwait_on_buffer(bh);\r\nif (!buffer_uptodate(bh)) {\r\nstruct gfs2_trans *tr = current->journal_info;\r\nif (tr && tr->tr_touched)\r\ngfs2_io_error_bh(sdp, bh);\r\nreturn -EIO;\r\n}\r\nif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nvoid gfs2_attach_bufdata(struct gfs2_glock *gl, struct buffer_head *bh,\r\nint meta)\r\n{\r\nstruct gfs2_bufdata *bd;\r\nif (meta)\r\nlock_page(bh->b_page);\r\nif (bh->b_private) {\r\nif (meta)\r\nunlock_page(bh->b_page);\r\nreturn;\r\n}\r\nbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\r\nbd->bd_bh = bh;\r\nbd->bd_gl = gl;\r\nINIT_LIST_HEAD(&bd->bd_list_tr);\r\nif (meta)\r\nlops_init_le(&bd->bd_le, &gfs2_buf_lops);\r\nelse\r\nlops_init_le(&bd->bd_le, &gfs2_databuf_lops);\r\nbh->b_private = bd;\r\nif (meta)\r\nunlock_page(bh->b_page);\r\n}\r\nvoid gfs2_remove_from_journal(struct buffer_head *bh, struct gfs2_trans *tr, int meta)\r\n{\r\nstruct address_space *mapping = bh->b_page->mapping;\r\nstruct gfs2_sbd *sdp = gfs2_mapping2sbd(mapping);\r\nstruct gfs2_bufdata *bd = bh->b_private;\r\nif (test_clear_buffer_pinned(bh)) {\r\ntrace_gfs2_pin(bd, 0);\r\natomic_dec(&sdp->sd_log_pinned);\r\nlist_del_init(&bd->bd_le.le_list);\r\nif (meta) {\r\ngfs2_assert_warn(sdp, sdp->sd_log_num_buf);\r\nsdp->sd_log_num_buf--;\r\ntr->tr_num_buf_rm++;\r\n} else {\r\ngfs2_assert_warn(sdp, sdp->sd_log_num_databuf);\r\nsdp->sd_log_num_databuf--;\r\ntr->tr_num_databuf_rm++;\r\n}\r\ntr->tr_touched = 1;\r\nbrelse(bh);\r\n}\r\nif (bd) {\r\nspin_lock(&sdp->sd_ail_lock);\r\nif (bd->bd_ail) {\r\ngfs2_remove_from_ail(bd);\r\nbh->b_private = NULL;\r\nbd->bd_bh = NULL;\r\nbd->bd_blkno = bh->b_blocknr;\r\ngfs2_trans_add_revoke(sdp, bd);\r\n}\r\nspin_unlock(&sdp->sd_ail_lock);\r\n}\r\nclear_buffer_dirty(bh);\r\nclear_buffer_uptodate(bh);\r\n}\r\nvoid gfs2_meta_wipe(struct gfs2_inode *ip, u64 bstart, u32 blen)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\r\nstruct buffer_head *bh;\r\nwhile (blen) {\r\nbh = gfs2_getbuf(ip->i_gl, bstart, NO_CREATE);\r\nif (bh) {\r\nlock_buffer(bh);\r\ngfs2_log_lock(sdp);\r\ngfs2_remove_from_journal(bh, current->journal_info, 1);\r\ngfs2_log_unlock(sdp);\r\nunlock_buffer(bh);\r\nbrelse(bh);\r\n}\r\nbstart++;\r\nblen--;\r\n}\r\n}\r\nint gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,\r\nint new, struct buffer_head **bhp)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\r\nstruct gfs2_glock *gl = ip->i_gl;\r\nstruct buffer_head *bh;\r\nint ret = 0;\r\nif (new) {\r\nBUG_ON(height == 0);\r\nbh = gfs2_meta_new(gl, num);\r\ngfs2_trans_add_bh(ip->i_gl, bh, 1);\r\ngfs2_metatype_set(bh, GFS2_METATYPE_IN, GFS2_FORMAT_IN);\r\ngfs2_buffer_clear_tail(bh, sizeof(struct gfs2_meta_header));\r\n} else {\r\nu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;\r\nret = gfs2_meta_read(gl, num, DIO_WAIT, &bh);\r\nif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {\r\nbrelse(bh);\r\nret = -EIO;\r\n}\r\n}\r\n*bhp = bh;\r\nreturn ret;\r\n}\r\nstruct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\r\n{\r\nstruct gfs2_sbd *sdp = gl->gl_sbd;\r\nstruct buffer_head *first_bh, *bh;\r\nu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\r\nsdp->sd_sb.sb_bsize_shift;\r\nBUG_ON(!extlen);\r\nif (max_ra < 1)\r\nmax_ra = 1;\r\nif (extlen > max_ra)\r\nextlen = max_ra;\r\nfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\r\nif (buffer_uptodate(first_bh))\r\ngoto out;\r\nif (!buffer_locked(first_bh))\r\nll_rw_block(READ_SYNC | REQ_META | REQ_PRIO, 1, &first_bh);\r\ndblock++;\r\nextlen--;\r\nwhile (extlen) {\r\nbh = gfs2_getbuf(gl, dblock, CREATE);\r\nif (!buffer_uptodate(bh) && !buffer_locked(bh))\r\nll_rw_block(READA, 1, &bh);\r\nbrelse(bh);\r\ndblock++;\r\nextlen--;\r\nif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\r\ngoto out;\r\n}\r\nwait_on_buffer(first_bh);\r\nout:\r\nreturn first_bh;\r\n}
