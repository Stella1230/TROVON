static unsigned int in(int offset)\r\n{\r\nswitch (offset) {\r\ncase LIRC_LP_BASE:\r\nreturn parport_read_data(pport);\r\ncase LIRC_LP_STATUS:\r\nreturn parport_read_status(pport);\r\ncase LIRC_LP_CONTROL:\r\nreturn parport_read_control(pport);\r\n}\r\nreturn 0;\r\n}\r\nstatic void out(int offset, int value)\r\n{\r\nswitch (offset) {\r\ncase LIRC_LP_BASE:\r\nparport_write_data(pport, value);\r\nbreak;\r\ncase LIRC_LP_CONTROL:\r\nparport_write_control(pport, value);\r\nbreak;\r\ncase LIRC_LP_STATUS:\r\nprintk(KERN_INFO "%s: attempt to write to status register\n",\r\nLIRC_DRIVER_NAME);\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int lirc_get_timer(void)\r\n{\r\nreturn in(LIRC_PORT_TIMER) & LIRC_PORT_TIMER_BIT;\r\n}\r\nstatic unsigned int lirc_get_signal(void)\r\n{\r\nreturn in(LIRC_PORT_SIGNAL) & LIRC_PORT_SIGNAL_BIT;\r\n}\r\nstatic void lirc_on(void)\r\n{\r\nout(LIRC_PORT_DATA, tx_mask);\r\n}\r\nstatic void lirc_off(void)\r\n{\r\nout(LIRC_PORT_DATA, 0);\r\n}\r\nstatic unsigned int init_lirc_timer(void)\r\n{\r\nstruct timeval tv, now;\r\nunsigned int level, newlevel, timeelapsed, newtimer;\r\nint count = 0;\r\ndo_gettimeofday(&tv);\r\ntv.tv_sec++;\r\nlevel = lirc_get_timer();\r\ndo {\r\nnewlevel = lirc_get_timer();\r\nif (level == 0 && newlevel != 0)\r\ncount++;\r\nlevel = newlevel;\r\ndo_gettimeofday(&now);\r\n} while (count < 1000 && (now.tv_sec < tv.tv_sec\r\n|| (now.tv_sec == tv.tv_sec\r\n&& now.tv_usec < tv.tv_usec)));\r\ntimeelapsed = ((now.tv_sec + 1 - tv.tv_sec)*1000000\r\n+ (now.tv_usec - tv.tv_usec));\r\nif (count >= 1000 && timeelapsed > 0) {\r\nif (default_timer == 0) {\r\nnewtimer = (1000000*count)/timeelapsed;\r\nprintk(KERN_INFO "%s: %u Hz timer detected\n",\r\nLIRC_DRIVER_NAME, newtimer);\r\nreturn newtimer;\r\n} else {\r\nnewtimer = (1000000*count)/timeelapsed;\r\nif (abs(newtimer - default_timer) > default_timer/10) {\r\nprintk(KERN_NOTICE "%s: bad timer: %u Hz\n",\r\nLIRC_DRIVER_NAME, newtimer);\r\nprintk(KERN_NOTICE "%s: using default timer: "\r\n"%u Hz\n",\r\nLIRC_DRIVER_NAME, default_timer);\r\nreturn default_timer;\r\n} else {\r\nprintk(KERN_INFO "%s: %u Hz timer detected\n",\r\nLIRC_DRIVER_NAME, newtimer);\r\nreturn newtimer;\r\n}\r\n}\r\n} else {\r\nprintk(KERN_NOTICE "%s: no timer detected\n", LIRC_DRIVER_NAME);\r\nreturn 0;\r\n}\r\n}\r\nstatic int lirc_claim(void)\r\n{\r\nif (parport_claim(ppdevice) != 0) {\r\nprintk(KERN_WARNING "%s: could not claim port\n",\r\nLIRC_DRIVER_NAME);\r\nprintk(KERN_WARNING "%s: waiting for port becoming available"\r\n"\n", LIRC_DRIVER_NAME);\r\nif (parport_claim_or_block(ppdevice) < 0) {\r\nprintk(KERN_NOTICE "%s: could not claim port, giving"\r\n" up\n", LIRC_DRIVER_NAME);\r\nreturn 0;\r\n}\r\n}\r\nout(LIRC_LP_CONTROL, LP_PSELECP|LP_PINITP);\r\nis_claimed = 1;\r\nreturn 1;\r\n}\r\nstatic void rbuf_write(int signal)\r\n{\r\nunsigned int nwptr;\r\nnwptr = (wptr + 1) & (RBUF_SIZE - 1);\r\nif (nwptr == rptr) {\r\nlost_irqs++;\r\nprintk(KERN_NOTICE "%s: buffer overrun\n", LIRC_DRIVER_NAME);\r\nreturn;\r\n}\r\nrbuf[wptr] = signal;\r\nwptr = nwptr;\r\n}\r\nstatic void irq_handler(void *blah)\r\n{\r\nstruct timeval tv;\r\nstatic struct timeval lasttv;\r\nstatic int init;\r\nlong signal;\r\nint data;\r\nunsigned int level, newlevel;\r\nunsigned int timeout;\r\nif (!is_open)\r\nreturn;\r\nif (!is_claimed)\r\nreturn;\r\n#if 0\r\ndisable_irq(irq);\r\nout(LIRC_PORT_IRQ, in(LIRC_PORT_IRQ) & (~LP_PINTEN));\r\n#endif\r\nif (check_pselecd && (in(1) & LP_PSELECD))\r\nreturn;\r\n#ifdef LIRC_TIMER\r\nif (init) {\r\ndo_gettimeofday(&tv);\r\nsignal = tv.tv_sec - lasttv.tv_sec;\r\nif (signal > 15)\r\ndata = PULSE_MASK;\r\nelse\r\ndata = (int) (signal*1000000 +\r\ntv.tv_usec - lasttv.tv_usec +\r\nLIRC_SFH506_DELAY);\r\nrbuf_write(data);\r\n} else {\r\nif (timer == 0) {\r\ntimer = init_lirc_timer();\r\nreturn;\r\n}\r\ninit = 1;\r\n}\r\ntimeout = timer/10;\r\nsignal = 1;\r\nlevel = lirc_get_timer();\r\ndo {\r\nnewlevel = lirc_get_timer();\r\nif (level == 0 && newlevel != 0)\r\nsignal++;\r\nlevel = newlevel;\r\nif (signal > timeout\r\n|| (check_pselecd && (in(1) & LP_PSELECD))) {\r\nsignal = 0;\r\nprintk(KERN_NOTICE "%s: timeout\n", LIRC_DRIVER_NAME);\r\nbreak;\r\n}\r\n} while (lirc_get_signal());\r\nif (signal != 0) {\r\n__u64 helper;\r\nhelper = ((__u64) signal)*1000000;\r\ndo_div(helper, timer);\r\nsignal = (long) helper;\r\nif (signal > LIRC_SFH506_DELAY)\r\ndata = signal - LIRC_SFH506_DELAY;\r\nelse\r\ndata = 1;\r\nrbuf_write(PULSE_BIT|data);\r\n}\r\ndo_gettimeofday(&lasttv);\r\n#else\r\n#endif\r\nwake_up_interruptible(&lirc_wait);\r\n}\r\nstatic loff_t lirc_lseek(struct file *filep, loff_t offset, int orig)\r\n{\r\nreturn -ESPIPE;\r\n}\r\nstatic ssize_t lirc_read(struct file *filep, char *buf, size_t n, loff_t *ppos)\r\n{\r\nint result = 0;\r\nint count = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (n % sizeof(int))\r\nreturn -EINVAL;\r\nadd_wait_queue(&lirc_wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (count < n) {\r\nif (rptr != wptr) {\r\nif (copy_to_user(buf+count, (char *) &rbuf[rptr],\r\nsizeof(int))) {\r\nresult = -EFAULT;\r\nbreak;\r\n}\r\nrptr = (rptr + 1) & (RBUF_SIZE - 1);\r\ncount += sizeof(int);\r\n} else {\r\nif (filep->f_flags & O_NONBLOCK) {\r\nresult = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nresult = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\n}\r\nremove_wait_queue(&lirc_wait, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn count ? count : result;\r\n}\r\nstatic ssize_t lirc_write(struct file *filep, const char *buf, size_t n,\r\nloff_t *ppos)\r\n{\r\nint count;\r\nunsigned int i;\r\nunsigned int level, newlevel;\r\nunsigned long flags;\r\nint counttimer;\r\nint *wbuf;\r\nssize_t ret;\r\nif (!is_claimed)\r\nreturn -EBUSY;\r\ncount = n / sizeof(int);\r\nif (n % sizeof(int) || count % 2 == 0)\r\nreturn -EINVAL;\r\nwbuf = memdup_user(buf, n);\r\nif (IS_ERR(wbuf))\r\nreturn PTR_ERR(wbuf);\r\n#ifdef LIRC_TIMER\r\nif (timer == 0) {\r\ntimer = init_lirc_timer();\r\nif (timer == 0) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < count; i++) {\r\n__u64 helper;\r\nhelper = ((__u64) wbuf[i])*timer;\r\ndo_div(helper, 1000000);\r\nwbuf[i] = (int) helper;\r\n}\r\nlocal_irq_save(flags);\r\ni = 0;\r\nwhile (i < count) {\r\nlevel = lirc_get_timer();\r\ncounttimer = 0;\r\nlirc_on();\r\ndo {\r\nnewlevel = lirc_get_timer();\r\nif (level == 0 && newlevel != 0)\r\ncounttimer++;\r\nlevel = newlevel;\r\nif (check_pselecd && (in(1) & LP_PSELECD)) {\r\nlirc_off();\r\nlocal_irq_restore(flags);\r\nret = -EIO;\r\ngoto out;\r\n}\r\n} while (counttimer < wbuf[i]);\r\ni++;\r\nlirc_off();\r\nif (i == count)\r\nbreak;\r\ncounttimer = 0;\r\ndo {\r\nnewlevel = lirc_get_timer();\r\nif (level == 0 && newlevel != 0)\r\ncounttimer++;\r\nlevel = newlevel;\r\nif (check_pselecd && (in(1) & LP_PSELECD)) {\r\nlocal_irq_restore(flags);\r\nret = -EIO;\r\ngoto out;\r\n}\r\n} while (counttimer < wbuf[i]);\r\ni++;\r\n}\r\nlocal_irq_restore(flags);\r\n#else\r\n#endif\r\nret = n;\r\nout:\r\nkfree(wbuf);\r\nreturn ret;\r\n}\r\nstatic unsigned int lirc_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &lirc_wait, wait);\r\nif (rptr != wptr)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic long lirc_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nint result;\r\n__u32 features = LIRC_CAN_SET_TRANSMITTER_MASK |\r\nLIRC_CAN_SEND_PULSE | LIRC_CAN_REC_MODE2;\r\n__u32 mode;\r\n__u32 value;\r\nswitch (cmd) {\r\ncase LIRC_GET_FEATURES:\r\nresult = put_user(features, (__u32 *) arg);\r\nif (result)\r\nreturn result;\r\nbreak;\r\ncase LIRC_GET_SEND_MODE:\r\nresult = put_user(LIRC_MODE_PULSE, (__u32 *) arg);\r\nif (result)\r\nreturn result;\r\nbreak;\r\ncase LIRC_GET_REC_MODE:\r\nresult = put_user(LIRC_MODE_MODE2, (__u32 *) arg);\r\nif (result)\r\nreturn result;\r\nbreak;\r\ncase LIRC_SET_SEND_MODE:\r\nresult = get_user(mode, (__u32 *) arg);\r\nif (result)\r\nreturn result;\r\nif (mode != LIRC_MODE_PULSE)\r\nreturn -EINVAL;\r\nbreak;\r\ncase LIRC_SET_REC_MODE:\r\nresult = get_user(mode, (__u32 *) arg);\r\nif (result)\r\nreturn result;\r\nif (mode != LIRC_MODE_MODE2)\r\nreturn -ENOSYS;\r\nbreak;\r\ncase LIRC_SET_TRANSMITTER_MASK:\r\nresult = get_user(value, (__u32 *) arg);\r\nif (result)\r\nreturn result;\r\nif ((value & LIRC_PARALLEL_TRANSMITTER_MASK) != value)\r\nreturn LIRC_PARALLEL_MAX_TRANSMITTERS;\r\ntx_mask = value;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lirc_open(struct inode *node, struct file *filep)\r\n{\r\nif (is_open || !lirc_claim())\r\nreturn -EBUSY;\r\nparport_enable_irq(pport);\r\nrptr = 0;\r\nwptr = 0;\r\nlost_irqs = 0;\r\nis_open = 1;\r\nreturn 0;\r\n}\r\nstatic int lirc_close(struct inode *node, struct file *filep)\r\n{\r\nif (is_claimed) {\r\nis_claimed = 0;\r\nparport_release(ppdevice);\r\n}\r\nis_open = 0;\r\nreturn 0;\r\n}\r\nstatic int set_use_inc(void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void set_use_dec(void *data)\r\n{\r\n}\r\nstatic int __devinit lirc_parallel_probe(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __devexit lirc_parallel_remove(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int lirc_parallel_suspend(struct platform_device *dev,\r\npm_message_t state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int lirc_parallel_resume(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pf(void *handle)\r\n{\r\nparport_disable_irq(pport);\r\nis_claimed = 0;\r\nreturn 0;\r\n}\r\nstatic void kf(void *handle)\r\n{\r\nif (!is_open)\r\nreturn;\r\nif (!lirc_claim())\r\nreturn;\r\nparport_enable_irq(pport);\r\nlirc_off();\r\n}\r\nstatic int __init lirc_parallel_init(void)\r\n{\r\nint result;\r\nresult = platform_driver_register(&lirc_parallel_driver);\r\nif (result) {\r\nprintk(KERN_NOTICE "platform_driver_register"\r\n" returned %d\n", result);\r\nreturn result;\r\n}\r\nlirc_parallel_dev = platform_device_alloc(LIRC_DRIVER_NAME, 0);\r\nif (!lirc_parallel_dev) {\r\nresult = -ENOMEM;\r\ngoto exit_driver_unregister;\r\n}\r\nresult = platform_device_add(lirc_parallel_dev);\r\nif (result)\r\ngoto exit_device_put;\r\npport = parport_find_base(io);\r\nif (pport == NULL) {\r\nprintk(KERN_NOTICE "%s: no port at %x found\n",\r\nLIRC_DRIVER_NAME, io);\r\nresult = -ENXIO;\r\ngoto exit_device_put;\r\n}\r\nppdevice = parport_register_device(pport, LIRC_DRIVER_NAME,\r\npf, kf, irq_handler, 0, NULL);\r\nparport_put_port(pport);\r\nif (ppdevice == NULL) {\r\nprintk(KERN_NOTICE "%s: parport_register_device() failed\n",\r\nLIRC_DRIVER_NAME);\r\nresult = -ENXIO;\r\ngoto exit_device_put;\r\n}\r\nif (parport_claim(ppdevice) != 0)\r\ngoto skip_init;\r\nis_claimed = 1;\r\nout(LIRC_LP_CONTROL, LP_PSELECP|LP_PINITP);\r\n#ifdef LIRC_TIMER\r\nif (debug)\r\nout(LIRC_PORT_DATA, tx_mask);\r\ntimer = init_lirc_timer();\r\n#if 0\r\nif (timer == 0) {\r\nis_claimed = 0;\r\nparport_release(pport);\r\nparport_unregister_device(ppdevice);\r\nresult = -EIO;\r\ngoto exit_device_put;\r\n}\r\n#endif\r\nif (debug)\r\nout(LIRC_PORT_DATA, 0);\r\n#endif\r\nis_claimed = 0;\r\nparport_release(ppdevice);\r\nskip_init:\r\ndriver.dev = &lirc_parallel_dev->dev;\r\ndriver.minor = lirc_register_driver(&driver);\r\nif (driver.minor < 0) {\r\nprintk(KERN_NOTICE "%s: register_chrdev() failed\n",\r\nLIRC_DRIVER_NAME);\r\nparport_unregister_device(ppdevice);\r\nresult = -EIO;\r\ngoto exit_device_put;\r\n}\r\nprintk(KERN_INFO "%s: installed using port 0x%04x irq %d\n",\r\nLIRC_DRIVER_NAME, io, irq);\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(lirc_parallel_dev);\r\nexit_driver_unregister:\r\nplatform_driver_unregister(&lirc_parallel_driver);\r\nreturn result;\r\n}\r\nstatic void __exit lirc_parallel_exit(void)\r\n{\r\nparport_unregister_device(ppdevice);\r\nlirc_unregister_driver(driver.minor);\r\nplatform_device_unregister(lirc_parallel_dev);\r\nplatform_driver_unregister(&lirc_parallel_driver);\r\n}
