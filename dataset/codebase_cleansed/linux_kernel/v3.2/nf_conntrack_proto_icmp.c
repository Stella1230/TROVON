static bool icmp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct icmphdr *hp;\r\nstruct icmphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->dst.u.icmp.type = hp->type;\r\ntuple->src.u.icmp.id = hp->un.echo.id;\r\ntuple->dst.u.icmp.code = hp->code;\r\nreturn true;\r\n}\r\nstatic bool icmp_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\nif (orig->dst.u.icmp.type >= sizeof(invmap) ||\r\n!invmap[orig->dst.u.icmp.type])\r\nreturn false;\r\ntuple->src.u.icmp.id = orig->src.u.icmp.id;\r\ntuple->dst.u.icmp.type = invmap[orig->dst.u.icmp.type] - 1;\r\ntuple->dst.u.icmp.code = orig->dst.u.icmp.code;\r\nreturn true;\r\n}\r\nstatic int icmp_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "type=%u code=%u id=%u ",\r\ntuple->dst.u.icmp.type,\r\ntuple->dst.u.icmp.code,\r\nntohs(tuple->src.u.icmp.id));\r\n}\r\nstatic int icmp_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nnf_ct_refresh_acct(ct, ctinfo, skb, nf_ct_icmp_timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool icmp_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff)\r\n{\r\nstatic const u_int8_t valid_new[] = {\r\n[ICMP_ECHO] = 1,\r\n[ICMP_TIMESTAMP] = 1,\r\n[ICMP_INFO_REQUEST] = 1,\r\n[ICMP_ADDRESS] = 1\r\n};\r\nif (ct->tuplehash[0].tuple.dst.u.icmp.type >= sizeof(valid_new) ||\r\n!valid_new[ct->tuplehash[0].tuple.dst.u.icmp.type]) {\r\npr_debug("icmp: can't create new conn with type %u\n",\r\nct->tuplehash[0].tuple.dst.u.icmp.type);\r\nnf_ct_dump_tuple_ip(&ct->tuplehash[0].tuple);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\nicmp_error_message(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb,\r\nenum ip_conntrack_info *ctinfo,\r\nunsigned int hooknum)\r\n{\r\nstruct nf_conntrack_tuple innertuple, origtuple;\r\nconst struct nf_conntrack_l4proto *innerproto;\r\nconst struct nf_conntrack_tuple_hash *h;\r\nu16 zone = tmpl ? nf_ct_zone(tmpl) : NF_CT_DEFAULT_ZONE;\r\nNF_CT_ASSERT(skb->nfct == NULL);\r\nif (!nf_ct_get_tuplepr(skb,\r\nskb_network_offset(skb) + ip_hdrlen(skb)\r\n+ sizeof(struct icmphdr),\r\nPF_INET, &origtuple)) {\r\npr_debug("icmp_error_message: failed to get tuple\n");\r\nreturn -NF_ACCEPT;\r\n}\r\ninnerproto = __nf_ct_l4proto_find(PF_INET, origtuple.dst.protonum);\r\nif (!nf_ct_invert_tuple(&innertuple, &origtuple,\r\n&nf_conntrack_l3proto_ipv4, innerproto)) {\r\npr_debug("icmp_error_message: no match\n");\r\nreturn -NF_ACCEPT;\r\n}\r\n*ctinfo = IP_CT_RELATED;\r\nh = nf_conntrack_find_get(net, zone, &innertuple);\r\nif (!h) {\r\npr_debug("icmp_error_message: no match\n");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (NF_CT_DIRECTION(h) == IP_CT_DIR_REPLY)\r\n*ctinfo += IP_CT_IS_REPLY;\r\nskb->nfct = &nf_ct_tuplehash_to_ctrack(h)->ct_general;\r\nskb->nfctinfo = *ctinfo;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int\r\nicmp_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb, unsigned int dataoff,\r\nenum ip_conntrack_info *ctinfo, u_int8_t pf, unsigned int hooknum)\r\n{\r\nconst struct icmphdr *icmph;\r\nstruct icmphdr _ih;\r\nicmph = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_ih), &_ih);\r\nif (icmph == NULL) {\r\nif (LOG_INVALID(net, IPPROTO_ICMP))\r\nnf_log_packet(PF_INET, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmp: short packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_ip_checksum(skb, hooknum, dataoff, 0)) {\r\nif (LOG_INVALID(net, IPPROTO_ICMP))\r\nnf_log_packet(PF_INET, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmp: bad HW ICMP checksum ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (icmph->type > NR_ICMP_TYPES) {\r\nif (LOG_INVALID(net, IPPROTO_ICMP))\r\nnf_log_packet(PF_INET, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmp: invalid ICMP type ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (icmph->type != ICMP_DEST_UNREACH &&\r\nicmph->type != ICMP_SOURCE_QUENCH &&\r\nicmph->type != ICMP_TIME_EXCEEDED &&\r\nicmph->type != ICMP_PARAMETERPROB &&\r\nicmph->type != ICMP_REDIRECT)\r\nreturn NF_ACCEPT;\r\nreturn icmp_error_message(net, tmpl, skb, ctinfo, hooknum);\r\n}\r\nstatic int icmp_tuple_to_nlattr(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *t)\r\n{\r\nNLA_PUT_BE16(skb, CTA_PROTO_ICMP_ID, t->src.u.icmp.id);\r\nNLA_PUT_U8(skb, CTA_PROTO_ICMP_TYPE, t->dst.u.icmp.type);\r\nNLA_PUT_U8(skb, CTA_PROTO_ICMP_CODE, t->dst.u.icmp.code);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int icmp_nlattr_to_tuple(struct nlattr *tb[],\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nif (!tb[CTA_PROTO_ICMP_TYPE] ||\r\n!tb[CTA_PROTO_ICMP_CODE] ||\r\n!tb[CTA_PROTO_ICMP_ID])\r\nreturn -EINVAL;\r\ntuple->dst.u.icmp.type = nla_get_u8(tb[CTA_PROTO_ICMP_TYPE]);\r\ntuple->dst.u.icmp.code = nla_get_u8(tb[CTA_PROTO_ICMP_CODE]);\r\ntuple->src.u.icmp.id = nla_get_be16(tb[CTA_PROTO_ICMP_ID]);\r\nif (tuple->dst.u.icmp.type >= sizeof(invmap) ||\r\n!invmap[tuple->dst.u.icmp.type])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int icmp_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(icmp_nla_policy, CTA_PROTO_MAX + 1);\r\n}
