static void it821x_program(ide_drive_t *drive, u16 timing)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct it821x_dev *itdev = ide_get_hwifdata(hwif);\r\nint channel = hwif->channel;\r\nu8 conf;\r\nif(itdev->clock_mode == ATA_66)\r\nconf = timing >> 8;\r\nelse\r\nconf = timing & 0xFF;\r\npci_write_config_byte(dev, 0x54 + 4 * channel, conf);\r\n}\r\nstatic void it821x_program_udma(ide_drive_t *drive, u16 timing)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct it821x_dev *itdev = ide_get_hwifdata(hwif);\r\nint channel = hwif->channel;\r\nu8 unit = drive->dn & 1, conf;\r\nif(itdev->clock_mode == ATA_66)\r\nconf = timing >> 8;\r\nelse\r\nconf = timing & 0xFF;\r\nif (itdev->timing10 == 0)\r\npci_write_config_byte(dev, 0x56 + 4 * channel + unit, conf);\r\nelse {\r\npci_write_config_byte(dev, 0x56 + 4 * channel, conf);\r\npci_write_config_byte(dev, 0x56 + 4 * channel + 1, conf);\r\n}\r\n}\r\nstatic void it821x_clock_strategy(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct it821x_dev *itdev = ide_get_hwifdata(hwif);\r\nide_drive_t *pair = ide_get_pair_dev(drive);\r\nint clock, altclock, sel = 0;\r\nu8 unit = drive->dn & 1, v;\r\nif(itdev->want[0][0] > itdev->want[1][0]) {\r\nclock = itdev->want[0][1];\r\naltclock = itdev->want[1][1];\r\n} else {\r\nclock = itdev->want[1][1];\r\naltclock = itdev->want[0][1];\r\n}\r\nif (clock == ATA_ANY)\r\nclock = altclock;\r\nif(clock == ATA_ANY)\r\nreturn;\r\nif(clock == itdev->clock_mode)\r\nreturn;\r\nif(clock == ATA_66)\r\nitdev->clock_mode = ATA_66;\r\nelse {\r\nitdev->clock_mode = ATA_50;\r\nsel = 1;\r\n}\r\npci_read_config_byte(dev, 0x50, &v);\r\nv &= ~(1 << (1 + hwif->channel));\r\nv |= sel << (1 + hwif->channel);\r\npci_write_config_byte(dev, 0x50, v);\r\nif(pair && itdev->udma[1-unit] != UDMA_OFF) {\r\nit821x_program_udma(pair, itdev->udma[1-unit]);\r\nit821x_program(pair, itdev->pio[1-unit]);\r\n}\r\nif(itdev->udma[unit] != UDMA_OFF) {\r\nit821x_program_udma(drive, itdev->udma[unit]);\r\nit821x_program(drive, itdev->pio[unit]);\r\n}\r\n}\r\nstatic void it821x_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct it821x_dev *itdev = ide_get_hwifdata(hwif);\r\nide_drive_t *pair = ide_get_pair_dev(drive);\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\nu8 unit = drive->dn & 1, set_pio = pio;\r\nstatic u16 pio_timings[]= { 0xAA88, 0xA382, 0xA181, 0x3332, 0x3121 };\r\nstatic u8 pio_want[] = { ATA_66, ATA_66, ATA_66, ATA_66, ATA_ANY };\r\nif (pair) {\r\nu8 pair_pio = pair->pio_mode - XFER_PIO_0;\r\nif (pair_pio < set_pio)\r\nset_pio = pair_pio;\r\n}\r\nitdev->want[unit][1] = pio_want[set_pio];\r\nitdev->want[unit][0] = 1;\r\nitdev->pio[unit] = pio_timings[set_pio];\r\nit821x_clock_strategy(drive);\r\nit821x_program(drive, itdev->pio[unit]);\r\n}\r\nstatic void it821x_tune_mwdma(ide_drive_t *drive, u8 mode_wanted)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct it821x_dev *itdev = (void *)ide_get_hwifdata(hwif);\r\nu8 unit = drive->dn & 1, channel = hwif->channel, conf;\r\nstatic u16 dma[] = { 0x8866, 0x3222, 0x3121 };\r\nstatic u8 mwdma_want[] = { ATA_ANY, ATA_66, ATA_ANY };\r\nitdev->want[unit][1] = mwdma_want[mode_wanted];\r\nitdev->want[unit][0] = 2;\r\nitdev->mwdma[unit] = dma[mode_wanted];\r\nitdev->udma[unit] = UDMA_OFF;\r\npci_read_config_byte(dev, 0x50, &conf);\r\nif (itdev->timing10)\r\nconf |= channel ? 0x60: 0x18;\r\nelse\r\nconf |= 1 << (3 + 2 * channel + unit);\r\npci_write_config_byte(dev, 0x50, conf);\r\nit821x_clock_strategy(drive);\r\n}\r\nstatic void it821x_tune_udma(ide_drive_t *drive, u8 mode_wanted)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct it821x_dev *itdev = ide_get_hwifdata(hwif);\r\nu8 unit = drive->dn & 1, channel = hwif->channel, conf;\r\nstatic u16 udma[] = { 0x4433, 0x4231, 0x3121, 0x2121, 0x1111, 0x2211, 0x1111 };\r\nstatic u8 udma_want[] = { ATA_ANY, ATA_50, ATA_ANY, ATA_66, ATA_66, ATA_50, ATA_66 };\r\nitdev->want[unit][1] = udma_want[mode_wanted];\r\nitdev->want[unit][0] = 3;\r\nitdev->mwdma[unit] = MWDMA_OFF;\r\nitdev->udma[unit] = udma[mode_wanted];\r\nif(mode_wanted >= 5)\r\nitdev->udma[unit] |= 0x8080;\r\npci_read_config_byte(dev, 0x50, &conf);\r\nif (itdev->timing10)\r\nconf &= channel ? 0x9F: 0xE7;\r\nelse\r\nconf &= ~ (1 << (3 + 2 * channel + unit));\r\npci_write_config_byte(dev, 0x50, conf);\r\nit821x_clock_strategy(drive);\r\nit821x_program_udma(drive, itdev->udma[unit]);\r\n}\r\nstatic void it821x_dma_start(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct it821x_dev *itdev = ide_get_hwifdata(hwif);\r\nu8 unit = drive->dn & 1;\r\nif(itdev->mwdma[unit] != MWDMA_OFF)\r\nit821x_program(drive, itdev->mwdma[unit]);\r\nelse if(itdev->udma[unit] != UDMA_OFF && itdev->timing10)\r\nit821x_program_udma(drive, itdev->udma[unit]);\r\nide_dma_start(drive);\r\n}\r\nstatic int it821x_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct it821x_dev *itdev = ide_get_hwifdata(hwif);\r\nint ret = ide_dma_end(drive);\r\nu8 unit = drive->dn & 1;\r\nif(itdev->mwdma[unit] != MWDMA_OFF)\r\nit821x_program(drive, itdev->pio[unit]);\r\nreturn ret;\r\n}\r\nstatic void it821x_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nconst u8 speed = drive->dma_mode;\r\nif (speed >= XFER_UDMA_0 && speed <= XFER_UDMA_6)\r\nit821x_tune_udma(drive, speed - XFER_UDMA_0);\r\nelse if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2)\r\nit821x_tune_mwdma(drive, speed - XFER_MW_DMA_0);\r\n}\r\nstatic u8 it821x_cable_detect(ide_hwif_t *hwif)\r\n{\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void it821x_quirkproc(ide_drive_t *drive)\r\n{\r\nstruct it821x_dev *itdev = ide_get_hwifdata(drive->hwif);\r\nu16 *id = drive->id;\r\nif (!itdev->smart) {\r\ndrive->dev_flags |= IDE_DFLAG_UNMASK;\r\n} else {\r\nif (strstr((char *)&id[ATA_ID_PROD],\r\n"Integrated Technology Express")) {\r\nid[ATA_ID_CAPABILITY] |= (3 << 8);\r\nid[ATA_ID_COMMAND_SET_2] |= 0x0400;\r\nid[ATA_ID_CFS_ENABLE_2] |= 0x0400;\r\nprintk(KERN_INFO "%s: IT8212 %sRAID %d volume",\r\ndrive->name, id[147] ? "Bootable " : "",\r\nid[ATA_ID_CSFO]);\r\nif (id[ATA_ID_CSFO] != 1)\r\nprintk(KERN_CONT "(%dK stripe)", id[146]);\r\nprintk(KERN_CONT ".\n");\r\n} else {\r\nid[ATA_ID_FIELD_VALID] &= 3;\r\nid[ATA_ID_QUEUE_DEPTH] = 0;\r\nid[ATA_ID_COMMAND_SET_1] = 0;\r\nid[ATA_ID_COMMAND_SET_2] &= 0xC400;\r\nid[ATA_ID_CFSSE] &= 0xC000;\r\nid[ATA_ID_CFS_ENABLE_1] = 0;\r\nid[ATA_ID_CFS_ENABLE_2] &= 0xC400;\r\nid[ATA_ID_CSF_DEFAULT] &= 0xC000;\r\nid[127] = 0;\r\nid[ATA_ID_DLF] = 0;\r\nid[ATA_ID_CSFO] = 0;\r\nid[ATA_ID_CFA_POWER] = 0;\r\nprintk(KERN_INFO "%s: Performing identify fixups.\n",\r\ndrive->name);\r\n}\r\nif (ata_id_has_dma(id)) {\r\nid[ATA_ID_MWDMA_MODES] |= 0x0101;\r\ndrive->current_speed = XFER_MW_DMA_0;\r\n}\r\n}\r\n}\r\nstatic void __devinit init_hwif_it821x(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nstruct it821x_dev *itdevs = host->host_priv;\r\nstruct it821x_dev *idev = itdevs + hwif->channel;\r\nu8 conf;\r\nide_set_hwifdata(hwif, idev);\r\npci_read_config_byte(dev, 0x50, &conf);\r\nif (conf & 1) {\r\nidev->smart = 1;\r\nhwif->host_flags |= IDE_HFLAG_NO_ATAPI_DMA;\r\nhwif->rqsize = 256;\r\n}\r\nif (conf & (1 << (1 + hwif->channel)))\r\nidev->clock_mode = ATA_50;\r\nelse\r\nidev->clock_mode = ATA_66;\r\nidev->want[0][1] = ATA_ANY;\r\nidev->want[1][1] = ATA_ANY;\r\nif (dev->revision == 0x10) {\r\nidev->timing10 = 1;\r\nhwif->host_flags |= IDE_HFLAG_NO_ATAPI_DMA;\r\nif (idev->smart == 0)\r\nprintk(KERN_WARNING DRV_NAME " %s: revision 0x10, "\r\n"workarounds activated\n", pci_name(dev));\r\n}\r\nif (idev->smart == 0) {\r\nhwif->dma_ops = &it821x_pass_through_dma_ops;\r\n} else\r\nhwif->host_flags |= IDE_HFLAG_NO_SET_MODE;\r\nif (hwif->dma_base == 0)\r\nreturn;\r\nhwif->ultra_mask = ATA_UDMA6;\r\nhwif->mwdma_mask = ATA_MWDMA2;\r\nif (idev->quirks & QUIRK_VORTEX86) {\r\nif (dev->revision == 0x11)\r\nhwif->ultra_mask = 0;\r\n}\r\n}\r\nstatic void it8212_disable_raid(struct pci_dev *dev)\r\n{\r\npci_write_config_byte(dev, 0x5E, 0x01);\r\npci_write_config_byte(dev, 0x50, 0x00);\r\npci_write_config_word(dev, PCI_COMMAND,\r\nPCI_COMMAND_PARITY | PCI_COMMAND_IO |\r\nPCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\r\npci_write_config_word(dev, 0x40, 0xA0F3);\r\npci_write_config_dword(dev,0x4C, 0x02040204);\r\npci_write_config_byte(dev, 0x42, 0x36);\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x20);\r\n}\r\nstatic int init_chipset_it821x(struct pci_dev *dev)\r\n{\r\nu8 conf;\r\nstatic char *mode[2] = { "pass through", "smart" };\r\nif (it8212_noraid) {\r\nprintk(KERN_INFO DRV_NAME " %s: forcing bypass mode\n",\r\npci_name(dev));\r\nit8212_disable_raid(dev);\r\n}\r\npci_read_config_byte(dev, 0x50, &conf);\r\nprintk(KERN_INFO DRV_NAME " %s: controller in %s mode\n",\r\npci_name(dev), mode[conf & 1]);\r\nreturn 0;\r\n}\r\nstatic int __devinit it821x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct it821x_dev *itdevs;\r\nint rc;\r\nitdevs = kzalloc(2 * sizeof(*itdevs), GFP_KERNEL);\r\nif (itdevs == NULL) {\r\nprintk(KERN_ERR DRV_NAME " %s: out of memory\n", pci_name(dev));\r\nreturn -ENOMEM;\r\n}\r\nitdevs->quirks = id->driver_data;\r\nrc = ide_pci_init_one(dev, &it821x_chipset, itdevs);\r\nif (rc)\r\nkfree(itdevs);\r\nreturn rc;\r\n}\r\nstatic void __devexit it821x_remove(struct pci_dev *dev)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nstruct it821x_dev *itdevs = host->host_priv;\r\nide_pci_remove(dev);\r\nkfree(itdevs);\r\n}\r\nstatic int __init it821x_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&it821x_pci_driver);\r\n}\r\nstatic void __exit it821x_ide_exit(void)\r\n{\r\npci_unregister_driver(&it821x_pci_driver);\r\n}
