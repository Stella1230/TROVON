static inline char pin_name(int pin)\r\n{\r\nreturn 'A' + pin - 1;\r\n}\r\nstatic struct acpi_prt_entry *acpi_pci_irq_find_prt_entry(struct pci_dev *dev,\r\nint pin)\r\n{\r\nstruct acpi_prt_entry *entry;\r\nint segment = pci_domain_nr(dev->bus);\r\nint bus = dev->bus->number;\r\nint device = PCI_SLOT(dev->devfn);\r\nspin_lock(&acpi_prt_lock);\r\nlist_for_each_entry(entry, &acpi_prt_list, list) {\r\nif ((segment == entry->id.segment)\r\n&& (bus == entry->id.bus)\r\n&& (device == entry->id.device)\r\n&& (pin == entry->pin)) {\r\nspin_unlock(&acpi_prt_lock);\r\nreturn entry;\r\n}\r\n}\r\nspin_unlock(&acpi_prt_lock);\r\nreturn NULL;\r\n}\r\nstatic void do_prt_fixups(struct acpi_prt_entry *entry,\r\nstruct acpi_pci_routing_table *prt)\r\n{\r\nint i;\r\nconst struct prt_quirk *quirk;\r\nfor (i = 0; i < ARRAY_SIZE(prt_quirks); i++) {\r\nquirk = &prt_quirks[i];\r\nif (!prt->source)\r\ncontinue;\r\nif (dmi_check_system(quirk->system) &&\r\nentry->id.segment == quirk->segment &&\r\nentry->id.bus == quirk->bus &&\r\nentry->id.device == quirk->device &&\r\nentry->pin == quirk->pin &&\r\n!strcmp(prt->source, quirk->source) &&\r\nstrlen(prt->source) >= strlen(quirk->actual_source)) {\r\nprintk(KERN_WARNING PREFIX "firmware reports "\r\n"%04x:%02x:%02x PCI INT %c connected to %s; "\r\n"changing to %s\n",\r\nentry->id.segment, entry->id.bus,\r\nentry->id.device, pin_name(entry->pin),\r\nprt->source, quirk->actual_source);\r\nstrcpy(prt->source, quirk->actual_source);\r\n}\r\n}\r\n}\r\nstatic int acpi_pci_irq_add_entry(acpi_handle handle, struct pci_bus *bus,\r\nstruct acpi_pci_routing_table *prt)\r\n{\r\nstruct acpi_prt_entry *entry;\r\nentry = kzalloc(sizeof(struct acpi_prt_entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->id.segment = pci_domain_nr(bus);\r\nentry->id.bus = bus->number;\r\nentry->id.device = (prt->address >> 16) & 0xFFFF;\r\nentry->pin = prt->pin + 1;\r\ndo_prt_fixups(entry, prt);\r\nentry->index = prt->source_index;\r\nif (prt->source[0])\r\nacpi_get_handle(handle, prt->source, &entry->link);\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,\r\n" %04x:%02x:%02x[%c] -> %s[%d]\n",\r\nentry->id.segment, entry->id.bus,\r\nentry->id.device, pin_name(entry->pin),\r\nprt->source, entry->index));\r\nspin_lock(&acpi_prt_lock);\r\nlist_add_tail(&entry->list, &acpi_prt_list);\r\nspin_unlock(&acpi_prt_lock);\r\nreturn 0;\r\n}\r\nint acpi_pci_irq_add_prt(acpi_handle handle, struct pci_bus *bus)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_pci_routing_table *entry;\r\nstatus = acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nprintk(KERN_DEBUG "ACPI: PCI Interrupt Routing Table [%s._PRT]\n",\r\n(char *) buffer.pointer);\r\nkfree(buffer.pointer);\r\nbuffer.length = ACPI_ALLOCATE_BUFFER;\r\nbuffer.pointer = NULL;\r\nstatus = acpi_get_irq_routing_table(handle, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRT [%s]",\r\nacpi_format_exception(status)));\r\nkfree(buffer.pointer);\r\nreturn -ENODEV;\r\n}\r\nentry = buffer.pointer;\r\nwhile (entry && (entry->length > 0)) {\r\nacpi_pci_irq_add_entry(handle, bus, entry);\r\nentry = (struct acpi_pci_routing_table *)\r\n((unsigned long)entry + entry->length);\r\n}\r\nkfree(buffer.pointer);\r\nreturn 0;\r\n}\r\nvoid acpi_pci_irq_del_prt(struct pci_bus *bus)\r\n{\r\nstruct acpi_prt_entry *entry, *tmp;\r\nprintk(KERN_DEBUG\r\n"ACPI: Delete PCI Interrupt Routing Table for %04x:%02x\n",\r\npci_domain_nr(bus), bus->number);\r\nspin_lock(&acpi_prt_lock);\r\nlist_for_each_entry_safe(entry, tmp, &acpi_prt_list, list) {\r\nif (pci_domain_nr(bus) == entry->id.segment\r\n&& bus->number == entry->id.bus) {\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\n}\r\nspin_unlock(&acpi_prt_lock);\r\n}\r\nstatic int bridge_has_boot_interrupt_variant(struct pci_bus *bus)\r\n{\r\nstruct pci_bus *bus_it;\r\nfor (bus_it = bus ; bus_it ; bus_it = bus_it->parent) {\r\nif (!bus_it->self)\r\nreturn 0;\r\nif (bus_it->self->irq_reroute_variant)\r\nreturn bus_it->self->irq_reroute_variant;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_reroute_boot_interrupt(struct pci_dev *dev,\r\nstruct acpi_prt_entry *entry)\r\n{\r\nif (noioapicquirk || noioapicreroute) {\r\nreturn 0;\r\n} else {\r\nswitch (bridge_has_boot_interrupt_variant(dev->bus)) {\r\ncase 0:\r\nreturn 0;\r\ncase INTEL_IRQ_REROUTE_VARIANT:\r\ndev_info(&dev->dev, "PCI IRQ %d -> rerouted to legacy "\r\n"IRQ %d\n", entry->index,\r\n(entry->index % 4) + 16);\r\nentry->index = (entry->index % 4) + 16;\r\nreturn 1;\r\ndefault:\r\ndev_warn(&dev->dev, "Cannot reroute IRQ %d to legacy "\r\n"IRQ: unknown mapping\n", entry->index);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nstatic struct acpi_prt_entry *acpi_pci_irq_lookup(struct pci_dev *dev, int pin)\r\n{\r\nstruct acpi_prt_entry *entry;\r\nstruct pci_dev *bridge;\r\nu8 bridge_pin, orig_pin = pin;\r\nentry = acpi_pci_irq_find_prt_entry(dev, pin);\r\nif (entry) {\r\n#ifdef CONFIG_X86_IO_APIC\r\nacpi_reroute_boot_interrupt(dev, entry);\r\n#endif\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %s[%c] _PRT entry\n",\r\npci_name(dev), pin_name(pin)));\r\nreturn entry;\r\n}\r\nbridge = dev->bus->self;\r\nwhile (bridge) {\r\npin = pci_swizzle_interrupt_pin(dev, pin);\r\nif ((bridge->class >> 8) == PCI_CLASS_BRIDGE_CARDBUS) {\r\nbridge_pin = bridge->pin;\r\nif (!bridge_pin) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"No interrupt pin configured for device %s\n",\r\npci_name(bridge)));\r\nreturn NULL;\r\n}\r\npin = bridge_pin;\r\n}\r\nentry = acpi_pci_irq_find_prt_entry(bridge, pin);\r\nif (entry) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Derived GSI for %s INT %c from %s\n",\r\npci_name(dev), pin_name(orig_pin),\r\npci_name(bridge)));\r\nreturn entry;\r\n}\r\ndev = bridge;\r\nbridge = dev->bus->self;\r\n}\r\ndev_warn(&dev->dev, "can't derive routing for PCI INT %c\n",\r\npin_name(orig_pin));\r\nreturn NULL;\r\n}\r\nint acpi_pci_irq_enable(struct pci_dev *dev)\r\n{\r\nstruct acpi_prt_entry *entry;\r\nint gsi;\r\nu8 pin;\r\nint triggering = ACPI_LEVEL_SENSITIVE;\r\nint polarity = ACPI_ACTIVE_LOW;\r\nchar *link = NULL;\r\nchar link_desc[16];\r\nint rc;\r\npin = dev->pin;\r\nif (!pin) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"No interrupt pin configured for device %s\n",\r\npci_name(dev)));\r\nreturn 0;\r\n}\r\nentry = acpi_pci_irq_lookup(dev, pin);\r\nif (!entry) {\r\nif (dev->class >> 8 == PCI_CLASS_STORAGE_IDE &&\r\n(dev->class & 0x05) == 0)\r\nreturn 0;\r\n}\r\nif (entry) {\r\nif (entry->link)\r\ngsi = acpi_pci_link_allocate_irq(entry->link,\r\nentry->index,\r\n&triggering, &polarity,\r\n&link);\r\nelse\r\ngsi = entry->index;\r\n} else\r\ngsi = -1;\r\nif (gsi < 0) {\r\nu32 dev_gsi;\r\ndev_warn(&dev->dev, "PCI INT %c: no GSI", pin_name(pin));\r\nif (dev->irq > 0 && (dev->irq <= 0xF) &&\r\n(acpi_isa_irq_to_gsi(dev->irq, &dev_gsi) == 0)) {\r\nprintk(" - using ISA IRQ %d\n", dev->irq);\r\nacpi_register_gsi(&dev->dev, dev_gsi,\r\nACPI_LEVEL_SENSITIVE,\r\nACPI_ACTIVE_LOW);\r\nreturn 0;\r\n} else {\r\nprintk("\n");\r\nreturn 0;\r\n}\r\n}\r\nrc = acpi_register_gsi(&dev->dev, gsi, triggering, polarity);\r\nif (rc < 0) {\r\ndev_warn(&dev->dev, "PCI INT %c: failed to register GSI\n",\r\npin_name(pin));\r\nreturn rc;\r\n}\r\ndev->irq = rc;\r\nif (link)\r\nsnprintf(link_desc, sizeof(link_desc), " -> Link[%s]", link);\r\nelse\r\nlink_desc[0] = '\0';\r\ndev_info(&dev->dev, "PCI INT %c%s -> GSI %u (%s, %s) -> IRQ %d\n",\r\npin_name(pin), link_desc, gsi,\r\n(triggering == ACPI_LEVEL_SENSITIVE) ? "level" : "edge",\r\n(polarity == ACPI_ACTIVE_LOW) ? "low" : "high", dev->irq);\r\nreturn 0;\r\n}\r\nvoid acpi_pci_irq_disable(struct pci_dev *dev)\r\n{\r\nstruct acpi_prt_entry *entry;\r\nint gsi;\r\nu8 pin;\r\npin = dev->pin;\r\nif (!pin)\r\nreturn;\r\nentry = acpi_pci_irq_lookup(dev, pin);\r\nif (!entry)\r\nreturn;\r\nif (entry->link)\r\ngsi = acpi_pci_link_free_irq(entry->link);\r\nelse\r\ngsi = entry->index;\r\ndev_info(&dev->dev, "PCI INT %c disabled\n", pin_name(pin));\r\nacpi_unregister_gsi(gsi);\r\n}
