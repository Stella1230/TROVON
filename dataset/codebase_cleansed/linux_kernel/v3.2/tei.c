static void\r\nda_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nstruct manager *mgr = fi->userdata;\r\nstruct va_format vaf;\r\nva_list va;\r\nif (!(*debug & DEBUG_L2_TEIFSM))\r\nreturn;\r\nva_start(va, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &va;\r\nprintk(KERN_DEBUG "mgr(%d): %pV\n", mgr->ch.st->dev->id, &vaf);\r\nva_end(va);\r\n}\r\nstatic void\r\nda_activate(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct manager *mgr = fi->userdata;\r\nif (fi->state == ST_L1_DEACT_PENDING)\r\nmISDN_FsmDelTimer(&mgr->datimer, 1);\r\nmISDN_FsmChangeState(fi, ST_L1_ACTIV);\r\n}\r\nstatic void\r\nda_deactivate_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nmISDN_FsmChangeState(fi, ST_L1_DEACT);\r\n}\r\nstatic void\r\nda_deactivate(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct manager *mgr = fi->userdata;\r\nstruct layer2 *l2;\r\nu_long flags;\r\nread_lock_irqsave(&mgr->lock, flags);\r\nlist_for_each_entry(l2, &mgr->layer2, list) {\r\nif (l2->l2m.state > ST_L2_4) {\r\nread_unlock_irqrestore(&mgr->lock, flags);\r\nreturn;\r\n}\r\n}\r\nread_unlock_irqrestore(&mgr->lock, flags);\r\nif (!test_bit(OPTION_L1_HOLD, &mgr->options)) {\r\nmISDN_FsmAddTimer(&mgr->datimer, DATIMER_VAL, EV_DATIMER,\r\nNULL, 1);\r\nmISDN_FsmChangeState(fi, ST_L1_DEACT_PENDING);\r\n}\r\n}\r\nstatic void\r\nda_ui(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct manager *mgr = fi->userdata;\r\nif (!test_bit(OPTION_L1_HOLD, &mgr->options)) {\r\nmISDN_FsmDelTimer(&mgr->datimer, 2);\r\nmISDN_FsmAddTimer(&mgr->datimer, DATIMER_VAL, EV_DATIMER,\r\nNULL, 2);\r\n}\r\n}\r\nstatic void\r\nda_timer(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct manager *mgr = fi->userdata;\r\nstruct layer2 *l2;\r\nu_long flags;\r\nread_lock_irqsave(&mgr->lock, flags);\r\nlist_for_each_entry(l2, &mgr->layer2, list) {\r\nif (l2->l2m.state > ST_L2_4) {\r\nread_unlock_irqrestore(&mgr->lock, flags);\r\nmISDN_FsmChangeState(fi, ST_L1_ACTIV);\r\nreturn;\r\n}\r\n}\r\nread_unlock_irqrestore(&mgr->lock, flags);\r\nmISDN_FsmChangeState(fi, ST_L1_DEACT);\r\n_queue_data(&mgr->ch, PH_DEACTIVATE_REQ, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\n}\r\nstatic void\r\ntei_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nstruct va_format vaf;\r\nva_list va;\r\nif (!(*debug & DEBUG_L2_TEIFSM))\r\nreturn;\r\nva_start(va, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &va;\r\nprintk(KERN_DEBUG "sapi(%d) tei(%d): %pV\n",\r\ntm->l2->sapi, tm->l2->tei, &vaf);\r\nva_end(va);\r\n}\r\nstatic int\r\nget_free_id(struct manager *mgr)\r\n{\r\nu64 ids = 0;\r\nint i;\r\nstruct layer2 *l2;\r\nlist_for_each_entry(l2, &mgr->layer2, list) {\r\nif (l2->ch.nr > 63) {\r\nprintk(KERN_WARNING\r\n"%s: more as 63 layer2 for one device\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\ntest_and_set_bit(l2->ch.nr, (u_long *)&ids);\r\n}\r\nfor (i = 1; i < 64; i++)\r\nif (!test_bit(i, (u_long *)&ids))\r\nreturn i;\r\nprintk(KERN_WARNING "%s: more as 63 layer2 for one device\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\nget_free_tei(struct manager *mgr)\r\n{\r\nu64 ids = 0;\r\nint i;\r\nstruct layer2 *l2;\r\nlist_for_each_entry(l2, &mgr->layer2, list) {\r\nif (l2->ch.nr == 0)\r\ncontinue;\r\nif ((l2->ch.addr & 0xff) != 0)\r\ncontinue;\r\ni = l2->ch.addr >> 8;\r\nif (i < 64)\r\ncontinue;\r\ni -= 64;\r\ntest_and_set_bit(i, (u_long *)&ids);\r\n}\r\nfor (i = 0; i < 64; i++)\r\nif (!test_bit(i, (u_long *)&ids))\r\nreturn i + 64;\r\nprintk(KERN_WARNING "%s: more as 63 dynamic tei for one device\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nstatic void\r\nteiup_create(struct manager *mgr, u_int prim, int len, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mISDNhead *hh;\r\nint err;\r\nskb = mI_alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nhh = mISDN_HEAD_P(skb);\r\nhh->prim = prim;\r\nhh->id = (mgr->ch.nr << 16) | mgr->ch.addr;\r\nif (len)\r\nmemcpy(skb_put(skb, len), arg, len);\r\nerr = mgr->up->send(mgr->up, skb);\r\nif (err) {\r\nprintk(KERN_WARNING "%s: err=%d\n", __func__, err);\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic u_int\r\nnew_id(struct manager *mgr)\r\n{\r\nu_int id;\r\nid = mgr->nextid++;\r\nif (id == 0x7fff)\r\nmgr->nextid = 1;\r\nid <<= 16;\r\nid |= GROUP_TEI << 8;\r\nid |= TEI_SAPI;\r\nreturn id;\r\n}\r\nstatic void\r\ndo_send(struct manager *mgr)\r\n{\r\nif (!test_bit(MGR_PH_ACTIVE, &mgr->options))\r\nreturn;\r\nif (!test_and_set_bit(MGR_PH_NOTREADY, &mgr->options)) {\r\nstruct sk_buff *skb = skb_dequeue(&mgr->sendq);\r\nif (!skb) {\r\ntest_and_clear_bit(MGR_PH_NOTREADY, &mgr->options);\r\nreturn;\r\n}\r\nmgr->lastid = mISDN_HEAD_ID(skb);\r\nmISDN_FsmEvent(&mgr->deact, EV_UI, NULL);\r\nif (mgr->ch.recv(mgr->ch.peer, skb)) {\r\ndev_kfree_skb(skb);\r\ntest_and_clear_bit(MGR_PH_NOTREADY, &mgr->options);\r\nmgr->lastid = MISDN_ID_NONE;\r\n}\r\n}\r\n}\r\nstatic void\r\ndo_ack(struct manager *mgr, u_int id)\r\n{\r\nif (test_bit(MGR_PH_NOTREADY, &mgr->options)) {\r\nif (id == mgr->lastid) {\r\nif (test_bit(MGR_PH_ACTIVE, &mgr->options)) {\r\nstruct sk_buff *skb;\r\nskb = skb_dequeue(&mgr->sendq);\r\nif (skb) {\r\nmgr->lastid = mISDN_HEAD_ID(skb);\r\nif (!mgr->ch.recv(mgr->ch.peer, skb))\r\nreturn;\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nmgr->lastid = MISDN_ID_NONE;\r\ntest_and_clear_bit(MGR_PH_NOTREADY, &mgr->options);\r\n}\r\n}\r\n}\r\nstatic void\r\nmgr_send_down(struct manager *mgr, struct sk_buff *skb)\r\n{\r\nskb_queue_tail(&mgr->sendq, skb);\r\nif (!test_bit(MGR_PH_ACTIVE, &mgr->options)) {\r\n_queue_data(&mgr->ch, PH_ACTIVATE_REQ, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\n} else {\r\ndo_send(mgr);\r\n}\r\n}\r\nstatic int\r\ndl_unit_data(struct manager *mgr, struct sk_buff *skb)\r\n{\r\nif (!test_bit(MGR_OPT_NETWORK, &mgr->options))\r\nreturn -EINVAL;\r\nif (!test_bit(MGR_PH_ACTIVE, &mgr->options))\r\n_queue_data(&mgr->ch, PH_ACTIVATE_REQ, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nskb_push(skb, 3);\r\nskb->data[0] = 0x02;\r\nskb->data[1] = 0xff;\r\nskb->data[2] = UI;\r\nmISDN_HEAD_PRIM(skb) = PH_DATA_REQ;\r\nmISDN_HEAD_ID(skb) = new_id(mgr);\r\nskb_queue_tail(&mgr->sendq, skb);\r\ndo_send(mgr);\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nrandom_ri(void)\r\n{\r\nu16 x;\r\nget_random_bytes(&x, sizeof(x));\r\nreturn x;\r\n}\r\nstatic struct layer2 *\r\nfindtei(struct manager *mgr, int tei)\r\n{\r\nstruct layer2 *l2;\r\nu_long flags;\r\nread_lock_irqsave(&mgr->lock, flags);\r\nlist_for_each_entry(l2, &mgr->layer2, list) {\r\nif ((l2->sapi == 0) && (l2->tei > 0) &&\r\n(l2->tei != GROUP_TEI) && (l2->tei == tei))\r\ngoto done;\r\n}\r\nl2 = NULL;\r\ndone:\r\nread_unlock_irqrestore(&mgr->lock, flags);\r\nreturn l2;\r\n}\r\nstatic void\r\nput_tei_msg(struct manager *mgr, u_char m_id, unsigned int ri, int tei)\r\n{\r\nstruct sk_buff *skb;\r\nu_char bp[8];\r\nbp[0] = (TEI_SAPI << 2);\r\nif (test_bit(MGR_OPT_NETWORK, &mgr->options))\r\nbp[0] |= 2;\r\nbp[1] = (GROUP_TEI << 1) | 0x1;\r\nbp[2] = UI;\r\nbp[3] = TEI_ENTITY_ID;\r\nbp[4] = ri >> 8;\r\nbp[5] = ri & 0xff;\r\nbp[6] = m_id;\r\nbp[7] = ((tei << 1) & 0xff) | 1;\r\nskb = _alloc_mISDN_skb(PH_DATA_REQ, new_id(mgr), 8, bp, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING "%s: no skb for tei msg\n", __func__);\r\nreturn;\r\n}\r\nmgr_send_down(mgr, skb);\r\n}\r\nstatic void\r\ntei_id_request(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nif (tm->l2->tei != GROUP_TEI) {\r\ntm->tei_m.printdebug(&tm->tei_m,\r\n"assign request for already assigned tei %d",\r\ntm->l2->tei);\r\nreturn;\r\n}\r\ntm->ri = random_ri();\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(&tm->tei_m,\r\n"assign request ri %d", tm->ri);\r\nput_tei_msg(tm->mgr, ID_REQUEST, tm->ri, GROUP_TEI);\r\nmISDN_FsmChangeState(fi, ST_TEI_IDREQ);\r\nmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 1);\r\ntm->nval = 3;\r\n}\r\nstatic void\r\ntei_id_assign(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nstruct layer2 *l2;\r\nu_char *dp = arg;\r\nint ri, tei;\r\nri = ((unsigned int) *dp++ << 8);\r\nri += *dp++;\r\ndp++;\r\ntei = *dp >> 1;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "identity assign ri %d tei %d",\r\nri, tei);\r\nl2 = findtei(tm->mgr, tei);\r\nif (l2) {\r\nif (ri != l2->tm->ri) {\r\ntm->tei_m.printdebug(fi,\r\n"possible duplicate assignment tei %d", tei);\r\ntei_l2(l2, MDL_ERROR_RSP, 0);\r\n}\r\n} else if (ri == tm->ri) {\r\nmISDN_FsmDelTimer(&tm->timer, 1);\r\nmISDN_FsmChangeState(fi, ST_TEI_NOP);\r\ntei_l2(tm->l2, MDL_ASSIGN_REQ, tei);\r\n}\r\n}\r\nstatic void\r\ntei_id_test_dup(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nstruct layer2 *l2;\r\nu_char *dp = arg;\r\nint tei, ri;\r\nri = ((unsigned int) *dp++ << 8);\r\nri += *dp++;\r\ndp++;\r\ntei = *dp >> 1;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "foreign identity assign ri %d tei %d",\r\nri, tei);\r\nl2 = findtei(tm->mgr, tei);\r\nif (l2) {\r\nif (ri != l2->tm->ri) {\r\ntm->tei_m.printdebug(fi,\r\n"possible duplicate assignment tei %d", tei);\r\nmISDN_FsmEvent(&l2->tm->tei_m, EV_VERIFY, NULL);\r\n}\r\n}\r\n}\r\nstatic void\r\ntei_id_denied(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nu_char *dp = arg;\r\nint ri, tei;\r\nri = ((unsigned int) *dp++ << 8);\r\nri += *dp++;\r\ndp++;\r\ntei = *dp >> 1;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "identity denied ri %d tei %d",\r\nri, tei);\r\n}\r\nstatic void\r\ntei_id_chk_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nu_char *dp = arg;\r\nint tei;\r\ntei = *(dp+3) >> 1;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "identity check req tei %d", tei);\r\nif ((tm->l2->tei != GROUP_TEI) && ((tei == GROUP_TEI) ||\r\n(tei == tm->l2->tei))) {\r\nmISDN_FsmDelTimer(&tm->timer, 4);\r\nmISDN_FsmChangeState(&tm->tei_m, ST_TEI_NOP);\r\nput_tei_msg(tm->mgr, ID_CHK_RES, random_ri(), tm->l2->tei);\r\n}\r\n}\r\nstatic void\r\ntei_id_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nu_char *dp = arg;\r\nint tei;\r\ntei = *(dp+3) >> 1;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "identity remove tei %d", tei);\r\nif ((tm->l2->tei != GROUP_TEI) &&\r\n((tei == GROUP_TEI) || (tei == tm->l2->tei))) {\r\nmISDN_FsmDelTimer(&tm->timer, 5);\r\nmISDN_FsmChangeState(&tm->tei_m, ST_TEI_NOP);\r\ntei_l2(tm->l2, MDL_REMOVE_REQ, 0);\r\n}\r\n}\r\nstatic void\r\ntei_id_verify(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "id verify request for tei %d",\r\ntm->l2->tei);\r\nput_tei_msg(tm->mgr, ID_VERIFY, 0, tm->l2->tei);\r\nmISDN_FsmChangeState(&tm->tei_m, ST_TEI_IDVERIFY);\r\nmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 2);\r\ntm->nval = 2;\r\n}\r\nstatic void\r\ntei_id_req_tout(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nif (--tm->nval) {\r\ntm->ri = random_ri();\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "assign req(%d) ri %d",\r\n4 - tm->nval, tm->ri);\r\nput_tei_msg(tm->mgr, ID_REQUEST, tm->ri, GROUP_TEI);\r\nmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 3);\r\n} else {\r\ntm->tei_m.printdebug(fi, "assign req failed");\r\ntei_l2(tm->l2, MDL_ERROR_RSP, 0);\r\nmISDN_FsmChangeState(fi, ST_TEI_NOP);\r\n}\r\n}\r\nstatic void\r\ntei_id_ver_tout(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nif (--tm->nval) {\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi,\r\n"id verify req(%d) for tei %d",\r\n3 - tm->nval, tm->l2->tei);\r\nput_tei_msg(tm->mgr, ID_VERIFY, 0, tm->l2->tei);\r\nmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 4);\r\n} else {\r\ntm->tei_m.printdebug(fi, "verify req for tei %d failed",\r\ntm->l2->tei);\r\ntei_l2(tm->l2, MDL_REMOVE_REQ, 0);\r\nmISDN_FsmChangeState(fi, ST_TEI_NOP);\r\n}\r\n}\r\nstatic void\r\ntei_l2remove(struct layer2 *l2)\r\n{\r\nput_tei_msg(l2->tm->mgr, ID_REMOVE, 0, l2->tei);\r\ntei_l2(l2, MDL_REMOVE_REQ, 0);\r\nlist_del(&l2->ch.list);\r\nl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\r\n}\r\nstatic void\r\ntei_assign_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nu_char *dp = arg;\r\nif (tm->l2->tei == GROUP_TEI) {\r\ntm->tei_m.printdebug(&tm->tei_m,\r\n"net tei assign request without tei");\r\nreturn;\r\n}\r\ntm->ri = ((unsigned int) *dp++ << 8);\r\ntm->ri += *dp++;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(&tm->tei_m,\r\n"net assign request ri %d teim %d", tm->ri, *dp);\r\nput_tei_msg(tm->mgr, ID_ASSIGNED, tm->ri, tm->l2->tei);\r\nmISDN_FsmChangeState(fi, ST_TEI_NOP);\r\n}\r\nstatic void\r\ntei_id_chk_req_net(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "id check request for tei %d",\r\ntm->l2->tei);\r\ntm->rcnt = 0;\r\nput_tei_msg(tm->mgr, ID_CHK_REQ, 0, tm->l2->tei);\r\nmISDN_FsmChangeState(&tm->tei_m, ST_TEI_IDVERIFY);\r\nmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 2);\r\ntm->nval = 2;\r\n}\r\nstatic void\r\ntei_id_chk_resp(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nu_char *dp = arg;\r\nint tei;\r\ntei = dp[3] >> 1;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "identity check resp tei %d", tei);\r\nif (tei == tm->l2->tei)\r\ntm->rcnt++;\r\n}\r\nstatic void\r\ntei_id_verify_net(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nu_char *dp = arg;\r\nint tei;\r\ntei = dp[3] >> 1;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi, "identity verify req tei %d/%d",\r\ntei, tm->l2->tei);\r\nif (tei == tm->l2->tei)\r\ntei_id_chk_req_net(fi, event, arg);\r\n}\r\nstatic void\r\ntei_id_ver_tout_net(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct teimgr *tm = fi->userdata;\r\nif (tm->rcnt == 1) {\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi,\r\n"check req for tei %d successful\n", tm->l2->tei);\r\nmISDN_FsmChangeState(fi, ST_TEI_NOP);\r\n} else if (tm->rcnt > 1) {\r\ntei_l2remove(tm->l2);\r\n} else if (--tm->nval) {\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(fi,\r\n"id check req(%d) for tei %d",\r\n3 - tm->nval, tm->l2->tei);\r\nput_tei_msg(tm->mgr, ID_CHK_REQ, 0, tm->l2->tei);\r\nmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 4);\r\n} else {\r\ntm->tei_m.printdebug(fi, "check req for tei %d failed",\r\ntm->l2->tei);\r\nmISDN_FsmChangeState(fi, ST_TEI_NOP);\r\ntei_l2remove(tm->l2);\r\n}\r\n}\r\nstatic void\r\ntei_ph_data_ind(struct teimgr *tm, u_int mt, u_char *dp, int len)\r\n{\r\nif (test_bit(FLG_FIXED_TEI, &tm->l2->flag))\r\nreturn;\r\nif (*debug & DEBUG_L2_TEI)\r\ntm->tei_m.printdebug(&tm->tei_m, "tei handler mt %x", mt);\r\nif (mt == ID_ASSIGNED)\r\nmISDN_FsmEvent(&tm->tei_m, EV_ASSIGN, dp);\r\nelse if (mt == ID_DENIED)\r\nmISDN_FsmEvent(&tm->tei_m, EV_DENIED, dp);\r\nelse if (mt == ID_CHK_REQ)\r\nmISDN_FsmEvent(&tm->tei_m, EV_CHKREQ, dp);\r\nelse if (mt == ID_REMOVE)\r\nmISDN_FsmEvent(&tm->tei_m, EV_REMOVE, dp);\r\nelse if (mt == ID_VERIFY)\r\nmISDN_FsmEvent(&tm->tei_m, EV_VERIFY, dp);\r\nelse if (mt == ID_CHK_RES)\r\nmISDN_FsmEvent(&tm->tei_m, EV_CHKRESP, dp);\r\n}\r\nstatic struct layer2 *\r\ncreate_new_tei(struct manager *mgr, int tei, int sapi)\r\n{\r\nu_long opt = 0;\r\nu_long flags;\r\nint id;\r\nstruct layer2 *l2;\r\nif (!mgr->up)\r\nreturn NULL;\r\nif ((tei >= 0) && (tei < 64))\r\ntest_and_set_bit(OPTION_L2_FIXEDTEI, &opt);\r\nif (mgr->ch.st->dev->Dprotocols\r\n& ((1 << ISDN_P_TE_E1) | (1 << ISDN_P_NT_E1)))\r\ntest_and_set_bit(OPTION_L2_PMX, &opt);\r\nl2 = create_l2(mgr->up, ISDN_P_LAPD_NT, opt, tei, sapi);\r\nif (!l2) {\r\nprintk(KERN_WARNING "%s:no memory for layer2\n", __func__);\r\nreturn NULL;\r\n}\r\nl2->tm = kzalloc(sizeof(struct teimgr), GFP_KERNEL);\r\nif (!l2->tm) {\r\nkfree(l2);\r\nprintk(KERN_WARNING "%s:no memory for teimgr\n", __func__);\r\nreturn NULL;\r\n}\r\nl2->tm->mgr = mgr;\r\nl2->tm->l2 = l2;\r\nl2->tm->tei_m.debug = *debug & DEBUG_L2_TEIFSM;\r\nl2->tm->tei_m.userdata = l2->tm;\r\nl2->tm->tei_m.printdebug = tei_debug;\r\nl2->tm->tei_m.fsm = &teifsmn;\r\nl2->tm->tei_m.state = ST_TEI_NOP;\r\nl2->tm->tval = 2000;\r\nmISDN_FsmInitTimer(&l2->tm->tei_m, &l2->tm->timer);\r\nwrite_lock_irqsave(&mgr->lock, flags);\r\nid = get_free_id(mgr);\r\nlist_add_tail(&l2->list, &mgr->layer2);\r\nwrite_unlock_irqrestore(&mgr->lock, flags);\r\nif (id < 0) {\r\nl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\r\nprintk(KERN_WARNING "%s:no free id\n", __func__);\r\nreturn NULL;\r\n} else {\r\nl2->ch.nr = id;\r\n__add_layer2(&l2->ch, mgr->ch.st);\r\nl2->ch.recv = mgr->ch.recv;\r\nl2->ch.peer = mgr->ch.peer;\r\nl2->ch.ctrl(&l2->ch, OPEN_CHANNEL, NULL);\r\n}\r\nreturn l2;\r\n}\r\nstatic void\r\nnew_tei_req(struct manager *mgr, u_char *dp)\r\n{\r\nint tei, ri;\r\nstruct layer2 *l2;\r\nri = dp[0] << 8;\r\nri += dp[1];\r\nif (!mgr->up)\r\ngoto denied;\r\nif (!(dp[3] & 1))\r\ngoto denied;\r\nif (dp[3] != 0xff)\r\ntei = dp[3] >> 1;\r\nelse\r\ntei = get_free_tei(mgr);\r\nif (tei < 0) {\r\nprintk(KERN_WARNING "%s:No free tei\n", __func__);\r\ngoto denied;\r\n}\r\nl2 = create_new_tei(mgr, tei, CTRL_SAPI);\r\nif (!l2)\r\ngoto denied;\r\nelse\r\nmISDN_FsmEvent(&l2->tm->tei_m, EV_ASSIGN_REQ, dp);\r\nreturn;\r\ndenied:\r\nput_tei_msg(mgr, ID_DENIED, ri, GROUP_TEI);\r\n}\r\nstatic int\r\nph_data_ind(struct manager *mgr, struct sk_buff *skb)\r\n{\r\nint ret = -EINVAL;\r\nstruct layer2 *l2, *nl2;\r\nu_char mt;\r\nif (skb->len < 8) {\r\nif (*debug & DEBUG_L2_TEI)\r\nprintk(KERN_DEBUG "%s: short mgr frame %d/8\n",\r\n__func__, skb->len);\r\ngoto done;\r\n}\r\nif ((skb->data[0] >> 2) != TEI_SAPI)\r\ngoto done;\r\nif (skb->data[0] & 1)\r\ngoto done;\r\nif (!(skb->data[1] & 1))\r\ngoto done;\r\nif ((skb->data[1] >> 1) != GROUP_TEI)\r\ngoto done;\r\nif ((skb->data[2] & 0xef) != UI)\r\ngoto done;\r\nif (skb->data[3] != TEI_ENTITY_ID)\r\ngoto done;\r\nmt = skb->data[6];\r\nswitch (mt) {\r\ncase ID_REQUEST:\r\ncase ID_CHK_RES:\r\ncase ID_VERIFY:\r\nif (!test_bit(MGR_OPT_NETWORK, &mgr->options))\r\ngoto done;\r\nbreak;\r\ncase ID_ASSIGNED:\r\ncase ID_DENIED:\r\ncase ID_CHK_REQ:\r\ncase ID_REMOVE:\r\nif (test_bit(MGR_OPT_NETWORK, &mgr->options))\r\ngoto done;\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\nret = 0;\r\nif (mt == ID_REQUEST) {\r\nnew_tei_req(mgr, &skb->data[4]);\r\ngoto done;\r\n}\r\nlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\r\ntei_ph_data_ind(l2->tm, mt, &skb->data[4], skb->len - 4);\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nint\r\nl2_tei(struct layer2 *l2, u_int cmd, u_long arg)\r\n{\r\nstruct teimgr *tm = l2->tm;\r\nif (test_bit(FLG_FIXED_TEI, &l2->flag))\r\nreturn 0;\r\nif (*debug & DEBUG_L2_TEI)\r\nprintk(KERN_DEBUG "%s: cmd(%x)\n", __func__, cmd);\r\nswitch (cmd) {\r\ncase MDL_ASSIGN_IND:\r\nmISDN_FsmEvent(&tm->tei_m, EV_IDREQ, NULL);\r\nbreak;\r\ncase MDL_ERROR_IND:\r\nif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\r\nmISDN_FsmEvent(&tm->tei_m, EV_CHKREQ, &l2->tei);\r\nif (test_bit(MGR_OPT_USER, &tm->mgr->options))\r\nmISDN_FsmEvent(&tm->tei_m, EV_VERIFY, NULL);\r\nbreak;\r\ncase MDL_STATUS_UP_IND:\r\nif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\r\nmISDN_FsmEvent(&tm->mgr->deact, EV_ACTIVATE, NULL);\r\nbreak;\r\ncase MDL_STATUS_DOWN_IND:\r\nif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\r\nmISDN_FsmEvent(&tm->mgr->deact, EV_DEACTIVATE, NULL);\r\nbreak;\r\ncase MDL_STATUS_UI_IND:\r\nif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\r\nmISDN_FsmEvent(&tm->mgr->deact, EV_UI, NULL);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nTEIrelease(struct layer2 *l2)\r\n{\r\nstruct teimgr *tm = l2->tm;\r\nu_long flags;\r\nmISDN_FsmDelTimer(&tm->timer, 1);\r\nwrite_lock_irqsave(&tm->mgr->lock, flags);\r\nlist_del(&l2->list);\r\nwrite_unlock_irqrestore(&tm->mgr->lock, flags);\r\nl2->tm = NULL;\r\nkfree(tm);\r\n}\r\nstatic int\r\ncreate_teimgr(struct manager *mgr, struct channel_req *crq)\r\n{\r\nstruct layer2 *l2;\r\nu_long opt = 0;\r\nu_long flags;\r\nint id;\r\nif (*debug & DEBUG_L2_TEI)\r\nprintk(KERN_DEBUG "%s: %s proto(%x) adr(%d %d %d %d)\n",\r\n__func__, dev_name(&mgr->ch.st->dev->dev),\r\ncrq->protocol, crq->adr.dev, crq->adr.channel,\r\ncrq->adr.sapi, crq->adr.tei);\r\nif (crq->adr.tei > GROUP_TEI)\r\nreturn -EINVAL;\r\nif (crq->adr.tei < 64)\r\ntest_and_set_bit(OPTION_L2_FIXEDTEI, &opt);\r\nif (crq->adr.tei == 0)\r\ntest_and_set_bit(OPTION_L2_PTP, &opt);\r\nif (test_bit(MGR_OPT_NETWORK, &mgr->options)) {\r\nif (crq->protocol == ISDN_P_LAPD_TE)\r\nreturn -EPROTONOSUPPORT;\r\nif ((crq->adr.tei != 0) && (crq->adr.tei != 127))\r\nreturn -EINVAL;\r\nif (mgr->up) {\r\nprintk(KERN_WARNING\r\n"%s: only one network manager is allowed\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\n} else if (test_bit(MGR_OPT_USER, &mgr->options)) {\r\nif (crq->protocol == ISDN_P_LAPD_NT)\r\nreturn -EPROTONOSUPPORT;\r\nif ((crq->adr.tei >= 64) && (crq->adr.tei < GROUP_TEI))\r\nreturn -EINVAL;\r\n} else {\r\nif (crq->protocol == ISDN_P_LAPD_NT)\r\ntest_and_set_bit(MGR_OPT_NETWORK, &mgr->options);\r\nif (crq->protocol == ISDN_P_LAPD_TE)\r\ntest_and_set_bit(MGR_OPT_USER, &mgr->options);\r\n}\r\nif (mgr->ch.st->dev->Dprotocols\r\n& ((1 << ISDN_P_TE_E1) | (1 << ISDN_P_NT_E1)))\r\ntest_and_set_bit(OPTION_L2_PMX, &opt);\r\nif ((crq->protocol == ISDN_P_LAPD_NT) && (crq->adr.tei == 127)) {\r\nmgr->up = crq->ch;\r\nid = DL_INFO_L2_CONNECT;\r\nteiup_create(mgr, DL_INFORMATION_IND, sizeof(id), &id);\r\ncrq->ch = NULL;\r\nif (!list_empty(&mgr->layer2)) {\r\nread_lock_irqsave(&mgr->lock, flags);\r\nlist_for_each_entry(l2, &mgr->layer2, list) {\r\nl2->up = mgr->up;\r\nl2->ch.ctrl(&l2->ch, OPEN_CHANNEL, NULL);\r\n}\r\nread_unlock_irqrestore(&mgr->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nl2 = create_l2(crq->ch, crq->protocol, opt,\r\ncrq->adr.tei, crq->adr.sapi);\r\nif (!l2)\r\nreturn -ENOMEM;\r\nl2->tm = kzalloc(sizeof(struct teimgr), GFP_KERNEL);\r\nif (!l2->tm) {\r\nkfree(l2);\r\nprintk(KERN_ERR "kmalloc teimgr failed\n");\r\nreturn -ENOMEM;\r\n}\r\nl2->tm->mgr = mgr;\r\nl2->tm->l2 = l2;\r\nl2->tm->tei_m.debug = *debug & DEBUG_L2_TEIFSM;\r\nl2->tm->tei_m.userdata = l2->tm;\r\nl2->tm->tei_m.printdebug = tei_debug;\r\nif (crq->protocol == ISDN_P_LAPD_TE) {\r\nl2->tm->tei_m.fsm = &teifsmu;\r\nl2->tm->tei_m.state = ST_TEI_NOP;\r\nl2->tm->tval = 1000;\r\n} else {\r\nl2->tm->tei_m.fsm = &teifsmn;\r\nl2->tm->tei_m.state = ST_TEI_NOP;\r\nl2->tm->tval = 2000;\r\n}\r\nmISDN_FsmInitTimer(&l2->tm->tei_m, &l2->tm->timer);\r\nwrite_lock_irqsave(&mgr->lock, flags);\r\nid = get_free_id(mgr);\r\nlist_add_tail(&l2->list, &mgr->layer2);\r\nwrite_unlock_irqrestore(&mgr->lock, flags);\r\nif (id < 0) {\r\nl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\r\n} else {\r\nl2->ch.nr = id;\r\nl2->up->nr = id;\r\ncrq->ch = &l2->ch;\r\nid = 0;\r\n}\r\nreturn id;\r\n}\r\nstatic int\r\nmgr_send(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct manager *mgr;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nint ret = -EINVAL;\r\nmgr = container_of(ch, struct manager, ch);\r\nif (*debug & DEBUG_L2_RECV)\r\nprintk(KERN_DEBUG "%s: prim(%x) id(%x)\n",\r\n__func__, hh->prim, hh->id);\r\nswitch (hh->prim) {\r\ncase PH_DATA_IND:\r\nmISDN_FsmEvent(&mgr->deact, EV_UI, NULL);\r\nret = ph_data_ind(mgr, skb);\r\nbreak;\r\ncase PH_DATA_CNF:\r\ndo_ack(mgr, hh->id);\r\nret = 0;\r\nbreak;\r\ncase PH_ACTIVATE_IND:\r\ntest_and_set_bit(MGR_PH_ACTIVE, &mgr->options);\r\nmISDN_FsmEvent(&mgr->deact, EV_ACTIVATE_IND, NULL);\r\ndo_send(mgr);\r\nret = 0;\r\nbreak;\r\ncase PH_DEACTIVATE_IND:\r\ntest_and_clear_bit(MGR_PH_ACTIVE, &mgr->options);\r\nmISDN_FsmEvent(&mgr->deact, EV_DEACTIVATE_IND, NULL);\r\nret = 0;\r\nbreak;\r\ncase DL_UNITDATA_REQ:\r\nreturn dl_unit_data(mgr, skb);\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nfree_teimanager(struct manager *mgr)\r\n{\r\nstruct layer2 *l2, *nl2;\r\ntest_and_clear_bit(OPTION_L1_HOLD, &mgr->options);\r\nif (test_bit(MGR_OPT_NETWORK, &mgr->options)) {\r\nmgr->up = NULL;\r\nif (test_bit(OPTION_L2_CLEANUP, &mgr->options)) {\r\nlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\r\nput_tei_msg(mgr, ID_REMOVE, 0, l2->tei);\r\nmutex_lock(&mgr->ch.st->lmutex);\r\nlist_del(&l2->ch.list);\r\nmutex_unlock(&mgr->ch.st->lmutex);\r\nl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\r\n}\r\ntest_and_clear_bit(MGR_OPT_NETWORK, &mgr->options);\r\n} else {\r\nlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\r\nl2->up = NULL;\r\n}\r\n}\r\n}\r\nif (test_bit(MGR_OPT_USER, &mgr->options)) {\r\nif (list_empty(&mgr->layer2))\r\ntest_and_clear_bit(MGR_OPT_USER, &mgr->options);\r\n}\r\nmgr->ch.st->dev->D.ctrl(&mgr->ch.st->dev->D, CLOSE_CHANNEL, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nctrl_teimanager(struct manager *mgr, void *arg)\r\n{\r\nint *val = (int *)arg;\r\nint ret = 0;\r\nswitch (val[0]) {\r\ncase IMCLEAR_L2:\r\nif (val[1])\r\ntest_and_set_bit(OPTION_L2_CLEANUP, &mgr->options);\r\nelse\r\ntest_and_clear_bit(OPTION_L2_CLEANUP, &mgr->options);\r\nbreak;\r\ncase IMHOLD_L1:\r\nif (val[1])\r\ntest_and_set_bit(OPTION_L1_HOLD, &mgr->options);\r\nelse\r\ntest_and_clear_bit(OPTION_L1_HOLD, &mgr->options);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ncheck_data(struct manager *mgr, struct sk_buff *skb)\r\n{\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nint ret, tei, sapi;\r\nstruct layer2 *l2;\r\nif (*debug & DEBUG_L2_CTRL)\r\nprintk(KERN_DEBUG "%s: prim(%x) id(%x)\n",\r\n__func__, hh->prim, hh->id);\r\nif (test_bit(MGR_OPT_USER, &mgr->options))\r\nreturn -ENOTCONN;\r\nif (hh->prim != PH_DATA_IND)\r\nreturn -ENOTCONN;\r\nif (skb->len != 3)\r\nreturn -ENOTCONN;\r\nif (skb->data[0] & 3)\r\nreturn -EINVAL;\r\nsapi = skb->data[0] >> 2;\r\nif (!(skb->data[1] & 1))\r\nreturn -EINVAL;\r\ntei = skb->data[1] >> 1;\r\nif (tei > 63)\r\nreturn -ENOTCONN;\r\nif ((skb->data[2] & ~0x10) != SABME)\r\nreturn -ENOTCONN;\r\nif (*debug & DEBUG_L2_CTRL)\r\nprintk(KERN_DEBUG "%s: SABME sapi(%d) tei(%d)\n",\r\n__func__, sapi, tei);\r\nl2 = create_new_tei(mgr, tei, sapi);\r\nif (!l2) {\r\nif (*debug & DEBUG_L2_CTRL)\r\nprintk(KERN_DEBUG "%s: failed to create new tei\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nret = l2->ch.send(&l2->ch, skb);\r\nreturn ret;\r\n}\r\nvoid\r\ndelete_teimanager(struct mISDNchannel *ch)\r\n{\r\nstruct manager *mgr;\r\nstruct layer2 *l2, *nl2;\r\nmgr = container_of(ch, struct manager, ch);\r\nlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\r\nmutex_lock(&mgr->ch.st->lmutex);\r\nlist_del(&l2->ch.list);\r\nmutex_unlock(&mgr->ch.st->lmutex);\r\nl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\r\n}\r\nlist_del(&mgr->ch.list);\r\nlist_del(&mgr->bcast.list);\r\nskb_queue_purge(&mgr->sendq);\r\nkfree(mgr);\r\n}\r\nstatic int\r\nmgr_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct manager *mgr;\r\nint ret = -EINVAL;\r\nmgr = container_of(ch, struct manager, ch);\r\nif (*debug & DEBUG_L2_CTRL)\r\nprintk(KERN_DEBUG "%s(%x, %p)\n", __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nret = create_teimgr(mgr, arg);\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nret = free_teimanager(mgr);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = ctrl_teimanager(mgr, arg);\r\nbreak;\r\ncase CHECK_DATA:\r\nret = check_data(mgr, arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nmgr_bcast(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct manager *mgr = container_of(ch, struct manager, bcast);\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nstruct sk_buff *cskb = NULL;\r\nstruct layer2 *l2;\r\nu_long flags;\r\nint ret;\r\nread_lock_irqsave(&mgr->lock, flags);\r\nlist_for_each_entry(l2, &mgr->layer2, list) {\r\nif ((hh->id & MISDN_ID_SAPI_MASK) ==\r\n(l2->ch.addr & MISDN_ID_SAPI_MASK)) {\r\nif (list_is_last(&l2->list, &mgr->layer2)) {\r\ncskb = skb;\r\nskb = NULL;\r\n} else {\r\nif (!cskb)\r\ncskb = skb_copy(skb, GFP_KERNEL);\r\n}\r\nif (cskb) {\r\nret = l2->ch.send(&l2->ch, cskb);\r\nif (ret) {\r\nif (*debug & DEBUG_SEND_ERR)\r\nprintk(KERN_DEBUG\r\n"%s ch%d prim(%x) addr(%x)"\r\n" err %d\n",\r\n__func__, l2->ch.nr,\r\nhh->prim, l2->ch.addr, ret);\r\n} else\r\ncskb = NULL;\r\n} else {\r\nprintk(KERN_WARNING "%s ch%d addr %x no mem\n",\r\n__func__, ch->nr, ch->addr);\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nread_unlock_irqrestore(&mgr->lock, flags);\r\nif (cskb)\r\ndev_kfree_skb(cskb);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int\r\nmgr_bcast_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint\r\ncreate_teimanager(struct mISDNdevice *dev)\r\n{\r\nstruct manager *mgr;\r\nmgr = kzalloc(sizeof(struct manager), GFP_KERNEL);\r\nif (!mgr)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&mgr->layer2);\r\nrwlock_init(&mgr->lock);\r\nskb_queue_head_init(&mgr->sendq);\r\nmgr->nextid = 1;\r\nmgr->lastid = MISDN_ID_NONE;\r\nmgr->ch.send = mgr_send;\r\nmgr->ch.ctrl = mgr_ctrl;\r\nmgr->ch.st = dev->D.st;\r\nset_channel_address(&mgr->ch, TEI_SAPI, GROUP_TEI);\r\nadd_layer2(&mgr->ch, dev->D.st);\r\nmgr->bcast.send = mgr_bcast;\r\nmgr->bcast.ctrl = mgr_bcast_ctrl;\r\nmgr->bcast.st = dev->D.st;\r\nset_channel_address(&mgr->bcast, 0, GROUP_TEI);\r\nadd_layer2(&mgr->bcast, dev->D.st);\r\nmgr->deact.debug = *debug & DEBUG_MANAGER;\r\nmgr->deact.userdata = mgr;\r\nmgr->deact.printdebug = da_debug;\r\nmgr->deact.fsm = &deactfsm;\r\nmgr->deact.state = ST_L1_DEACT;\r\nmISDN_FsmInitTimer(&mgr->deact, &mgr->datimer);\r\ndev->teimgr = &mgr->ch;\r\nreturn 0;\r\n}\r\nint TEIInit(u_int *deb)\r\n{\r\ndebug = deb;\r\nteifsmu.state_count = TEI_STATE_COUNT;\r\nteifsmu.event_count = TEI_EVENT_COUNT;\r\nteifsmu.strEvent = strTeiEvent;\r\nteifsmu.strState = strTeiState;\r\nmISDN_FsmNew(&teifsmu, TeiFnListUser, ARRAY_SIZE(TeiFnListUser));\r\nteifsmn.state_count = TEI_STATE_COUNT;\r\nteifsmn.event_count = TEI_EVENT_COUNT;\r\nteifsmn.strEvent = strTeiEvent;\r\nteifsmn.strState = strTeiState;\r\nmISDN_FsmNew(&teifsmn, TeiFnListNet, ARRAY_SIZE(TeiFnListNet));\r\ndeactfsm.state_count = DEACT_STATE_COUNT;\r\ndeactfsm.event_count = DEACT_EVENT_COUNT;\r\ndeactfsm.strEvent = strDeactEvent;\r\ndeactfsm.strState = strDeactState;\r\nmISDN_FsmNew(&deactfsm, DeactFnList, ARRAY_SIZE(DeactFnList));\r\nreturn 0;\r\n}\r\nvoid TEIFree(void)\r\n{\r\nmISDN_FsmFree(&teifsmu);\r\nmISDN_FsmFree(&teifsmn);\r\nmISDN_FsmFree(&deactfsm);\r\n}
