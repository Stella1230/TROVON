static struct node *read_fstree(const char *dirname)\r\n{\r\nDIR *d;\r\nstruct dirent *de;\r\nstruct stat st;\r\nstruct node *tree;\r\nd = opendir(dirname);\r\nif (!d)\r\ndie("Couldn't opendir() \"%s\": %s\n", dirname, strerror(errno));\r\ntree = build_node(NULL, NULL);\r\nwhile ((de = readdir(d)) != NULL) {\r\nchar *tmpnam;\r\nif (streq(de->d_name, ".")\r\n|| streq(de->d_name, ".."))\r\ncontinue;\r\ntmpnam = join_path(dirname, de->d_name);\r\nif (lstat(tmpnam, &st) < 0)\r\ndie("stat(%s): %s\n", tmpnam, strerror(errno));\r\nif (S_ISREG(st.st_mode)) {\r\nstruct property *prop;\r\nFILE *pfile;\r\npfile = fopen(tmpnam, "r");\r\nif (! pfile) {\r\nfprintf(stderr,\r\n"WARNING: Cannot open %s: %s\n",\r\ntmpnam, strerror(errno));\r\n} else {\r\nprop = build_property(xstrdup(de->d_name),\r\ndata_copy_file(pfile,\r\nst.st_size));\r\nadd_property(tree, prop);\r\nfclose(pfile);\r\n}\r\n} else if (S_ISDIR(st.st_mode)) {\r\nstruct node *newchild;\r\nnewchild = read_fstree(tmpnam);\r\nnewchild = name_node(newchild, xstrdup(de->d_name));\r\nadd_child(tree, newchild);\r\n}\r\nfree(tmpnam);\r\n}\r\nclosedir(d);\r\nreturn tree;\r\n}\r\nstruct boot_info *dt_from_fs(const char *dirname)\r\n{\r\nstruct node *tree;\r\ntree = read_fstree(dirname);\r\ntree = name_node(tree, "");\r\nreturn build_boot_info(NULL, tree, guess_boot_cpuid(tree));\r\n}
