struct seq_oss_timer *\r\nsnd_seq_oss_timer_new(struct seq_oss_devinfo *dp)\r\n{\r\nstruct seq_oss_timer *rec;\r\nrec = kzalloc(sizeof(*rec), GFP_KERNEL);\r\nif (rec == NULL)\r\nreturn NULL;\r\nrec->dp = dp;\r\nrec->cur_tick = 0;\r\nrec->realtime = 0;\r\nrec->running = 0;\r\nrec->oss_tempo = 60;\r\nrec->oss_timebase = 100;\r\ncalc_alsa_tempo(rec);\r\nreturn rec;\r\n}\r\nvoid\r\nsnd_seq_oss_timer_delete(struct seq_oss_timer *rec)\r\n{\r\nif (rec) {\r\nsnd_seq_oss_timer_stop(rec);\r\nkfree(rec);\r\n}\r\n}\r\nint\r\nsnd_seq_oss_process_timer_event(struct seq_oss_timer *rec, union evrec *ev)\r\n{\r\nabstime_t parm = ev->t.time;\r\nif (ev->t.code == EV_TIMING) {\r\nswitch (ev->t.cmd) {\r\ncase TMR_WAIT_REL:\r\nparm += rec->cur_tick;\r\nrec->realtime = 0;\r\ncase TMR_WAIT_ABS:\r\nif (parm == 0) {\r\nrec->realtime = 1;\r\n} else if (parm >= rec->cur_tick) {\r\nrec->realtime = 0;\r\nrec->cur_tick = parm;\r\n}\r\nreturn 1;\r\ncase TMR_START:\r\nsnd_seq_oss_timer_start(rec);\r\nreturn 1;\r\n}\r\n} else if (ev->s.code == SEQ_WAIT) {\r\nparm = (ev->echo >> 8) & 0xffffff;\r\nif (parm > rec->cur_tick) {\r\nrec->cur_tick = parm;\r\nrec->realtime = 0;\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncalc_alsa_tempo(struct seq_oss_timer *timer)\r\n{\r\ntimer->tempo = (60 * 1000000) / timer->oss_tempo;\r\ntimer->ppq = timer->oss_timebase;\r\n}\r\nstatic int\r\nsend_timer_event(struct seq_oss_devinfo *dp, int type, int value)\r\n{\r\nstruct snd_seq_event ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.type = type;\r\nev.source.client = dp->cseq;\r\nev.source.port = 0;\r\nev.dest.client = SNDRV_SEQ_CLIENT_SYSTEM;\r\nev.dest.port = SNDRV_SEQ_PORT_SYSTEM_TIMER;\r\nev.queue = dp->queue;\r\nev.data.queue.queue = dp->queue;\r\nev.data.queue.param.value = value;\r\nreturn snd_seq_kernel_client_dispatch(dp->cseq, &ev, 1, 0);\r\n}\r\nint\r\nsnd_seq_oss_timer_start(struct seq_oss_timer *timer)\r\n{\r\nstruct seq_oss_devinfo *dp = timer->dp;\r\nstruct snd_seq_queue_tempo tmprec;\r\nif (timer->running)\r\nsnd_seq_oss_timer_stop(timer);\r\nmemset(&tmprec, 0, sizeof(tmprec));\r\ntmprec.queue = dp->queue;\r\ntmprec.ppq = timer->ppq;\r\ntmprec.tempo = timer->tempo;\r\nsnd_seq_set_queue_tempo(dp->cseq, &tmprec);\r\nsend_timer_event(dp, SNDRV_SEQ_EVENT_START, 0);\r\ntimer->running = 1;\r\ntimer->cur_tick = 0;\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_timer_stop(struct seq_oss_timer *timer)\r\n{\r\nif (! timer->running)\r\nreturn 0;\r\nsend_timer_event(timer->dp, SNDRV_SEQ_EVENT_STOP, 0);\r\ntimer->running = 0;\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_timer_continue(struct seq_oss_timer *timer)\r\n{\r\nif (timer->running)\r\nreturn 0;\r\nsend_timer_event(timer->dp, SNDRV_SEQ_EVENT_CONTINUE, 0);\r\ntimer->running = 1;\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_timer_tempo(struct seq_oss_timer *timer, int value)\r\n{\r\nif (value < MIN_OSS_TEMPO)\r\nvalue = MIN_OSS_TEMPO;\r\nelse if (value > MAX_OSS_TEMPO)\r\nvalue = MAX_OSS_TEMPO;\r\ntimer->oss_tempo = value;\r\ncalc_alsa_tempo(timer);\r\nif (timer->running)\r\nsend_timer_event(timer->dp, SNDRV_SEQ_EVENT_TEMPO, timer->tempo);\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_timer_ioctl(struct seq_oss_timer *timer, unsigned int cmd, int __user *arg)\r\n{\r\nint value;\r\nif (cmd == SNDCTL_SEQ_CTRLRATE) {\r\ndebug_printk(("ctrl rate\n"));\r\nif (get_user(value, arg))\r\nreturn -EFAULT;\r\nif (value)\r\nreturn -EINVAL;\r\nvalue = ((timer->oss_tempo * timer->oss_timebase) + 30) / 60;\r\nreturn put_user(value, arg) ? -EFAULT : 0;\r\n}\r\nif (timer->dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH)\r\nreturn 0;\r\nswitch (cmd) {\r\ncase SNDCTL_TMR_START:\r\ndebug_printk(("timer start\n"));\r\nreturn snd_seq_oss_timer_start(timer);\r\ncase SNDCTL_TMR_STOP:\r\ndebug_printk(("timer stop\n"));\r\nreturn snd_seq_oss_timer_stop(timer);\r\ncase SNDCTL_TMR_CONTINUE:\r\ndebug_printk(("timer continue\n"));\r\nreturn snd_seq_oss_timer_continue(timer);\r\ncase SNDCTL_TMR_TEMPO:\r\ndebug_printk(("timer tempo\n"));\r\nif (get_user(value, arg))\r\nreturn -EFAULT;\r\nreturn snd_seq_oss_timer_tempo(timer, value);\r\ncase SNDCTL_TMR_TIMEBASE:\r\ndebug_printk(("timer timebase\n"));\r\nif (get_user(value, arg))\r\nreturn -EFAULT;\r\nif (value < MIN_OSS_TIMEBASE)\r\nvalue = MIN_OSS_TIMEBASE;\r\nelse if (value > MAX_OSS_TIMEBASE)\r\nvalue = MAX_OSS_TIMEBASE;\r\ntimer->oss_timebase = value;\r\ncalc_alsa_tempo(timer);\r\nreturn 0;\r\ncase SNDCTL_TMR_METRONOME:\r\ncase SNDCTL_TMR_SELECT:\r\ncase SNDCTL_TMR_SOURCE:\r\ndebug_printk(("timer XXX\n"));\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}
