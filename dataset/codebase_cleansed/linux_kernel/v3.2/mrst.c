static int fixed_bar_cap(struct pci_bus *bus, unsigned int devfn)\r\n{\r\nint pos;\r\nu32 pcie_cap = 0, cap_data;\r\npos = PCIE_CAP_OFFSET;\r\nif (!raw_pci_ext_ops)\r\nreturn 0;\r\nwhile (pos) {\r\nif (raw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,\r\ndevfn, pos, 4, &pcie_cap))\r\nreturn 0;\r\nif (PCI_EXT_CAP_ID(pcie_cap) == 0x0000 ||\r\nPCI_EXT_CAP_ID(pcie_cap) == 0xffff)\r\nbreak;\r\nif (PCI_EXT_CAP_ID(pcie_cap) == PCI_EXT_CAP_ID_VNDR) {\r\nraw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,\r\ndevfn, pos + 4, 4, &cap_data);\r\nif ((cap_data & 0xffff) == PCIE_VNDR_CAP_ID_FIXED_BAR)\r\nreturn pos;\r\n}\r\npos = PCI_EXT_CAP_NEXT(pcie_cap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_device_update_fixed(struct pci_bus *bus, unsigned int devfn,\r\nint reg, int len, u32 val, int offset)\r\n{\r\nu32 size;\r\nunsigned int domain, busnum;\r\nint bar = (reg - PCI_BASE_ADDRESS_0) >> 2;\r\ndomain = pci_domain_nr(bus);\r\nbusnum = bus->number;\r\nif (val == ~0 && len == 4) {\r\nunsigned long decode;\r\nraw_pci_ext_ops->read(domain, busnum, devfn,\r\noffset + 8 + (bar * 4), 4, &size);\r\nif (size) {\r\ndecode = size - 1;\r\ndecode |= decode >> 1;\r\ndecode |= decode >> 2;\r\ndecode |= decode >> 4;\r\ndecode |= decode >> 8;\r\ndecode |= decode >> 16;\r\ndecode++;\r\ndecode = ~(decode - 1);\r\n} else {\r\ndecode = 0;\r\n}\r\nreturn raw_pci_ext_ops->write(domain, busnum, devfn, reg, 4,\r\ndecode);\r\n}\r\nreturn raw_pci_ext_ops->write(domain, busnum, devfn, reg, len, val);\r\n}\r\nstatic bool type1_access_ok(unsigned int bus, unsigned int devfn, int reg)\r\n{\r\nif (reg >= 0x100 || reg == PCI_STATUS || reg == PCI_HEADER_TYPE)\r\nreturn 0;\r\nif (bus == 0 && (devfn == PCI_DEVFN(2, 0) || devfn == PCI_DEVFN(0, 0)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int pci_read(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nif (type1_access_ok(bus->number, devfn, where))\r\nreturn pci_direct_conf1.read(pci_domain_nr(bus), bus->number,\r\ndevfn, where, size, value);\r\nreturn raw_pci_ext_ops->read(pci_domain_nr(bus), bus->number,\r\ndevfn, where, size, value);\r\n}\r\nstatic int pci_write(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nint offset;\r\nif (where == PCI_ROM_ADDRESS)\r\nreturn 0;\r\noffset = fixed_bar_cap(bus, devfn);\r\nif (offset &&\r\n(where >= PCI_BASE_ADDRESS_0 && where <= PCI_BASE_ADDRESS_5)) {\r\nreturn pci_device_update_fixed(bus, devfn, where, size, value,\r\noffset);\r\n}\r\nif (type1_access_ok(bus->number, devfn, where))\r\nreturn pci_direct_conf1.write(pci_domain_nr(bus), bus->number,\r\ndevfn, where, size, value);\r\nreturn raw_pci_ext_ops->write(pci_domain_nr(bus), bus->number, devfn,\r\nwhere, size, value);\r\n}\r\nstatic int mrst_pci_irq_enable(struct pci_dev *dev)\r\n{\r\nu8 pin;\r\nstruct io_apic_irq_attr irq_attr;\r\npci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\r\nirq_attr.ioapic = mp_find_ioapic(dev->irq);\r\nirq_attr.ioapic_pin = dev->irq;\r\nirq_attr.trigger = 1;\r\nirq_attr.polarity = 1;\r\nio_apic_set_pci_routing(&dev->dev, dev->irq, &irq_attr);\r\nreturn 0;\r\n}\r\nint __init pci_mrst_init(void)\r\n{\r\nprintk(KERN_INFO "Moorestown platform detected, using MRST PCI ops\n");\r\npci_mmcfg_late_init();\r\npcibios_enable_irq = mrst_pci_irq_enable;\r\npci_root_ops = pci_mrst_ops;\r\nreturn 1;\r\n}\r\nstatic void __devinit pci_fixed_bar_fixup(struct pci_dev *dev)\r\n{\r\nunsigned long offset;\r\nu32 size;\r\nint i;\r\nif (dev->cfg_size < PCIE_CAP_OFFSET + 4)\r\nreturn;\r\noffset = fixed_bar_cap(dev->bus, dev->devfn);\r\nif (!offset || PCI_DEVFN(2, 0) == dev->devfn ||\r\nPCI_DEVFN(2, 2) == dev->devfn)\r\nreturn;\r\nfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\r\npci_read_config_dword(dev, offset + 8 + (i * 4), &size);\r\ndev->resource[i].end = dev->resource[i].start + size - 1;\r\ndev->resource[i].flags |= IORESOURCE_PCI_FIXED;\r\n}\r\n}
