static unsigned int hashnum(unsigned int num)\r\n{\r\nunsigned int mask1 = HASH1 << 27, mask2 = HASH2 << 27;\r\nfor (; mask1 >= HASH1; mask1 >>= 1, mask2 >>= 1)\r\nif (num & mask1)\r\nnum ^= mask2;\r\nreturn num & (HASHSZ-1);\r\n}\r\nstatic const char *names_genericstrtable(struct genericstrtable *t[HASHSZ], unsigned int index)\r\n{\r\nstruct genericstrtable *h;\r\nfor (h = t[hashnum(index)]; h; h = h->next)\r\nif (h->num == index)\r\nreturn h->name;\r\nreturn NULL;\r\n}\r\nconst char *names_hid(u_int8_t hidd)\r\n{\r\nreturn names_genericstrtable(hiddescriptors, hidd);\r\n}\r\nconst char *names_reporttag(u_int8_t rt)\r\n{\r\nreturn names_genericstrtable(reports, rt);\r\n}\r\nconst char *names_huts(unsigned int data)\r\n{\r\nreturn names_genericstrtable(huts, data);\r\n}\r\nconst char *names_hutus(unsigned int data)\r\n{\r\nreturn names_genericstrtable(hutus, data);\r\n}\r\nconst char *names_langid(u_int16_t langid)\r\n{\r\nreturn names_genericstrtable(langids, langid);\r\n}\r\nconst char *names_physdes(u_int8_t ph)\r\n{\r\nreturn names_genericstrtable(physdess, ph);\r\n}\r\nconst char *names_bias(u_int8_t b)\r\n{\r\nreturn names_genericstrtable(biass, b);\r\n}\r\nconst char *names_countrycode(unsigned int countrycode)\r\n{\r\nreturn names_genericstrtable(countrycodes, countrycode);\r\n}\r\nconst char *names_vendor(u_int16_t vendorid)\r\n{\r\nstruct vendor *v;\r\nv = vendors[hashnum(vendorid)];\r\nfor (; v; v = v->next)\r\nif (v->vendorid == vendorid)\r\nreturn v->name;\r\nreturn NULL;\r\n}\r\nconst char *names_product(u_int16_t vendorid, u_int16_t productid)\r\n{\r\nstruct product *p;\r\np = products[hashnum((vendorid << 16) | productid)];\r\nfor (; p; p = p->next)\r\nif (p->vendorid == vendorid && p->productid == productid)\r\nreturn p->name;\r\nreturn NULL;\r\n}\r\nconst char *names_class(u_int8_t classid)\r\n{\r\nstruct class *c;\r\nc = classes[hashnum(classid)];\r\nfor (; c; c = c->next)\r\nif (c->classid == classid)\r\nreturn c->name;\r\nreturn NULL;\r\n}\r\nconst char *names_subclass(u_int8_t classid, u_int8_t subclassid)\r\n{\r\nstruct subclass *s;\r\ns = subclasses[hashnum((classid << 8) | subclassid)];\r\nfor (; s; s = s->next)\r\nif (s->classid == classid && s->subclassid == subclassid)\r\nreturn s->name;\r\nreturn NULL;\r\n}\r\nconst char *names_protocol(u_int8_t classid, u_int8_t subclassid, u_int8_t protocolid)\r\n{\r\nstruct protocol *p;\r\np = protocols[hashnum((classid << 16) | (subclassid << 8) | protocolid)];\r\nfor (; p; p = p->next)\r\nif (p->classid == classid && p->subclassid == subclassid && p->protocolid == protocolid)\r\nreturn p->name;\r\nreturn NULL;\r\n}\r\nconst char *names_audioterminal(u_int16_t termt)\r\n{\r\nstruct audioterminal *at;\r\nat = audioterminals[hashnum(termt)];\r\nfor (; at; at = at->next)\r\nif (at->termt == termt)\r\nreturn at->name;\r\nreturn NULL;\r\n}\r\nstatic void *my_malloc(size_t size)\r\n{\r\nstruct pool *p;\r\np = calloc(1, sizeof(struct pool));\r\nif (!p) {\r\nfree(p);\r\nreturn NULL;\r\n}\r\np->mem = calloc(1, size);\r\nif (!p->mem)\r\nreturn NULL;\r\np->next = pool_head;\r\npool_head = p;\r\nreturn p->mem;\r\n}\r\nvoid names_free(void)\r\n{\r\nstruct pool *pool;\r\nif (!pool_head)\r\nreturn;\r\nfor (pool = pool_head; pool != NULL; ) {\r\nstruct pool *tmp;\r\nif (pool->mem)\r\nfree(pool->mem);\r\ntmp = pool;\r\npool = pool->next;\r\nfree(tmp);\r\n}\r\n}\r\nstatic int new_vendor(const char *name, u_int16_t vendorid)\r\n{\r\nstruct vendor *v;\r\nunsigned int h = hashnum(vendorid);\r\nv = vendors[h];\r\nfor (; v; v = v->next)\r\nif (v->vendorid == vendorid)\r\nreturn -1;\r\nv = my_malloc(sizeof(struct vendor) + strlen(name));\r\nif (!v)\r\nreturn -1;\r\nstrcpy(v->name, name);\r\nv->vendorid = vendorid;\r\nv->next = vendors[h];\r\nvendors[h] = v;\r\nreturn 0;\r\n}\r\nstatic int new_product(const char *name, u_int16_t vendorid, u_int16_t productid)\r\n{\r\nstruct product *p;\r\nunsigned int h = hashnum((vendorid << 16) | productid);\r\np = products[h];\r\nfor (; p; p = p->next)\r\nif (p->vendorid == vendorid && p->productid == productid)\r\nreturn -1;\r\np = my_malloc(sizeof(struct product) + strlen(name));\r\nif (!p)\r\nreturn -1;\r\nstrcpy(p->name, name);\r\np->vendorid = vendorid;\r\np->productid = productid;\r\np->next = products[h];\r\nproducts[h] = p;\r\nreturn 0;\r\n}\r\nstatic int new_class(const char *name, u_int8_t classid)\r\n{\r\nstruct class *c;\r\nunsigned int h = hashnum(classid);\r\nc = classes[h];\r\nfor (; c; c = c->next)\r\nif (c->classid == classid)\r\nreturn -1;\r\nc = my_malloc(sizeof(struct class) + strlen(name));\r\nif (!c)\r\nreturn -1;\r\nstrcpy(c->name, name);\r\nc->classid = classid;\r\nc->next = classes[h];\r\nclasses[h] = c;\r\nreturn 0;\r\n}\r\nstatic int new_subclass(const char *name, u_int8_t classid, u_int8_t subclassid)\r\n{\r\nstruct subclass *s;\r\nunsigned int h = hashnum((classid << 8) | subclassid);\r\ns = subclasses[h];\r\nfor (; s; s = s->next)\r\nif (s->classid == classid && s->subclassid == subclassid)\r\nreturn -1;\r\ns = my_malloc(sizeof(struct subclass) + strlen(name));\r\nif (!s)\r\nreturn -1;\r\nstrcpy(s->name, name);\r\ns->classid = classid;\r\ns->subclassid = subclassid;\r\ns->next = subclasses[h];\r\nsubclasses[h] = s;\r\nreturn 0;\r\n}\r\nstatic int new_protocol(const char *name, u_int8_t classid, u_int8_t subclassid, u_int8_t protocolid)\r\n{\r\nstruct protocol *p;\r\nunsigned int h = hashnum((classid << 16) | (subclassid << 8) | protocolid);\r\np = protocols[h];\r\nfor (; p; p = p->next)\r\nif (p->classid == classid && p->subclassid == subclassid && p->protocolid == protocolid)\r\nreturn -1;\r\np = my_malloc(sizeof(struct protocol) + strlen(name));\r\nif (!p)\r\nreturn -1;\r\nstrcpy(p->name, name);\r\np->classid = classid;\r\np->subclassid = subclassid;\r\np->protocolid = protocolid;\r\np->next = protocols[h];\r\nprotocols[h] = p;\r\nreturn 0;\r\n}\r\nstatic int new_audioterminal(const char *name, u_int16_t termt)\r\n{\r\nstruct audioterminal *at;\r\nunsigned int h = hashnum(termt);\r\nat = audioterminals[h];\r\nfor (; at; at = at->next)\r\nif (at->termt == termt)\r\nreturn -1;\r\nat = my_malloc(sizeof(struct audioterminal) + strlen(name));\r\nif (!at)\r\nreturn -1;\r\nstrcpy(at->name, name);\r\nat->termt = termt;\r\nat->next = audioterminals[h];\r\naudioterminals[h] = at;\r\nreturn 0;\r\n}\r\nstatic int new_genericstrtable(struct genericstrtable *t[HASHSZ], const char *name, unsigned int index)\r\n{\r\nstruct genericstrtable *g;\r\nunsigned int h = hashnum(index);\r\nfor (g = t[h]; g; g = g->next)\r\nif (g->num == index)\r\nreturn -1;\r\ng = my_malloc(sizeof(struct genericstrtable) + strlen(name));\r\nif (!g)\r\nreturn -1;\r\nstrcpy(g->name, name);\r\ng->num = index;\r\ng->next = t[h];\r\nt[h] = g;\r\nreturn 0;\r\n}\r\nstatic int new_hid(const char *name, u_int8_t hidd)\r\n{\r\nreturn new_genericstrtable(hiddescriptors, name, hidd);\r\n}\r\nstatic int new_reporttag(const char *name, u_int8_t rt)\r\n{\r\nreturn new_genericstrtable(reports, name, rt);\r\n}\r\nstatic int new_huts(const char *name, unsigned int data)\r\n{\r\nreturn new_genericstrtable(huts, name, data);\r\n}\r\nstatic int new_hutus(const char *name, unsigned int data)\r\n{\r\nreturn new_genericstrtable(hutus, name, data);\r\n}\r\nstatic int new_langid(const char *name, u_int16_t langid)\r\n{\r\nreturn new_genericstrtable(langids, name, langid);\r\n}\r\nstatic int new_physdes(const char *name, u_int8_t ph)\r\n{\r\nreturn new_genericstrtable(physdess, name, ph);\r\n}\r\nstatic int new_bias(const char *name, u_int8_t b)\r\n{\r\nreturn new_genericstrtable(biass, name, b);\r\n}\r\nstatic int new_countrycode(const char *name, unsigned int countrycode)\r\n{\r\nreturn new_genericstrtable(countrycodes, name, countrycode);\r\n}\r\nstatic void parse(FILE *f)\r\n{\r\nchar buf[512], *cp;\r\nunsigned int linectr = 0;\r\nint lastvendor = -1, lastclass = -1, lastsubclass = -1, lasthut=-1, lastlang=-1;\r\nunsigned int u;\r\nwhile (fgets(buf, sizeof(buf), f)) {\r\nlinectr++;\r\nif ((cp = strchr(buf, 13)))\r\n*cp = 0;\r\nif ((cp = strchr(buf, 10)))\r\n*cp = 0;\r\nif (buf[0] == '#' || !buf[0])\r\ncontinue;\r\ncp = buf;\r\nif (buf[0] == 'P' && buf[1] == 'H' && buf[2] == 'Y' && buf[3] == 'S' && buf[4] == 'D' &&\r\nbuf[5] == 'E' && buf[6] == 'S' && buf[7] == ' ') {\r\ncp = buf + 8;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid Physdes type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid Physdes type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_physdes(cp, u))\r\nfprintf(stderr, "Duplicate Physdes type spec at line %u terminal type %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u physdes type %02x %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (buf[0] == 'P' && buf[1] == 'H' && buf[2] == 'Y' && buf[3] == ' ') {\r\ncp = buf + 4;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid PHY type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid PHY type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_physdes(cp, u))\r\nfprintf(stderr, "Duplicate PHY type spec at line %u terminal type %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u PHY type %02x %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (buf[0] == 'B' && buf[1] == 'I' && buf[2] == 'A' && buf[3] == 'S' && buf[4] == ' ') {\r\ncp = buf + 5;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid BIAS type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid BIAS type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_bias(cp, u))\r\nfprintf(stderr, "Duplicate BIAS type spec at line %u terminal type %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u BIAS type %02x %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (buf[0] == 'L' && buf[1] == ' ') {\r\ncp = buf+2;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid LANGID spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid LANGID spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_langid(cp, u))\r\nfprintf(stderr, "Duplicate LANGID spec at line %u language-id %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u LANGID %02x %s\n", linectr, u, cp));\r\nlasthut = lastclass = lastvendor = lastsubclass = -1;\r\nlastlang = u;\r\ncontinue;\r\n}\r\nif (buf[0] == 'C' && buf[1] == ' ') {\r\ncp = buf+2;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid class spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid class spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_class(cp, u))\r\nfprintf(stderr, "Duplicate class spec at line %u class %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u class %02x %s\n", linectr, u, cp));\r\nlasthut = lastlang = lastvendor = lastsubclass = -1;\r\nlastclass = u;\r\ncontinue;\r\n}\r\nif (buf[0] == 'A' && buf[1] == 'T' && isspace(buf[2])) {\r\ncp = buf+3;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid audio terminal type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid audio terminal type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_audioterminal(cp, u))\r\nfprintf(stderr, "Duplicate audio terminal type spec at line %u terminal type %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u audio terminal type %02x %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (buf[0] == 'H' && buf[1] == 'C' && buf[2] == 'C' && isspace(buf[3])) {\r\ncp = buf+3;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid HID country code at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 10);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid HID country code at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_countrycode(cp, u))\r\nfprintf(stderr, "Duplicate HID country code at line %u country %02u %s\n", linectr, u, cp);\r\nDBG(printf("line %5u keyboard country code %02u %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (isxdigit(*cp)) {\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid vendor spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_vendor(cp, u))\r\nfprintf(stderr, "Duplicate vendor spec at line %u vendor %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u vendor %04x %s\n", linectr, u, cp));\r\nlastvendor = u;\r\nlasthut = lastlang = lastclass = lastsubclass = -1;\r\ncontinue;\r\n}\r\nif (buf[0] == '\t' && isxdigit(buf[1])) {\r\nu = strtoul(buf+1, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid product/subclass spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (lastvendor != -1) {\r\nif (new_product(cp, lastvendor, u))\r\nfprintf(stderr, "Duplicate product spec at line %u product %04x:%04x %s\n", linectr, lastvendor, u, cp);\r\nDBG(printf("line %5u product %04x:%04x %s\n", linectr, lastvendor, u, cp));\r\ncontinue;\r\n}\r\nif (lastclass != -1) {\r\nif (new_subclass(cp, lastclass, u))\r\nfprintf(stderr, "Duplicate subclass spec at line %u class %02x:%02x %s\n", linectr, lastclass, u, cp);\r\nDBG(printf("line %5u subclass %02x:%02x %s\n", linectr, lastclass, u, cp));\r\nlastsubclass = u;\r\ncontinue;\r\n}\r\nif (lasthut != -1) {\r\nif (new_hutus(cp, (lasthut << 16)+u))\r\nfprintf(stderr, "Duplicate HUT Usage Spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (lastlang != -1) {\r\nif (new_langid(cp, lastlang+(u<<10)))\r\nfprintf(stderr, "Duplicate LANGID Usage Spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nfprintf(stderr, "Product/Subclass spec without prior Vendor/Class spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (buf[0] == '\t' && buf[1] == '\t' && isxdigit(buf[2])) {\r\nu = strtoul(buf+2, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid protocol spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (lastclass != -1 && lastsubclass != -1) {\r\nif (new_protocol(cp, lastclass, lastsubclass, u))\r\nfprintf(stderr, "Duplicate protocol spec at line %u class %02x:%02x:%02x %s\n", linectr, lastclass, lastsubclass, u, cp);\r\nDBG(printf("line %5u protocol %02x:%02x:%02x %s\n", linectr, lastclass, lastsubclass, u, cp));\r\ncontinue;\r\n}\r\nfprintf(stderr, "Protocol spec without prior Class and Subclass spec at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (buf[0] == 'H' && buf[1] == 'I' && buf[2] == 'D' && buf[3] == ' ') {\r\ncp = buf + 4;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid HID type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid HID type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_hid(cp, u))\r\nfprintf(stderr, "Duplicate HID type spec at line %u terminal type %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u HID type %02x %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (buf[0] == 'H' && buf[1] == 'U' && buf[2] == 'T' && buf[3] == ' ') {\r\ncp = buf + 4;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid HUT type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid HUT type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_huts(cp, u))\r\nfprintf(stderr, "Duplicate HUT type spec at line %u terminal type %04x %s\n", linectr, u, cp);\r\nlastlang = lastclass = lastvendor = lastsubclass = -1;\r\nlasthut = u;\r\nDBG(printf("line %5u HUT type %02x %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (buf[0] == 'R' && buf[1] == ' ') {\r\ncp = buf + 2;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nfprintf(stderr, "Invalid Report type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nfprintf(stderr, "Invalid Report type at line %u\n", linectr);\r\ncontinue;\r\n}\r\nif (new_reporttag(cp, u))\r\nfprintf(stderr, "Duplicate Report type spec at line %u terminal type %04x %s\n", linectr, u, cp);\r\nDBG(printf("line %5u Report type %02x %s\n", linectr, u, cp));\r\ncontinue;\r\n}\r\nif (buf[0] == 'V' && buf[1] == 'T') {\r\ncontinue;\r\n}\r\nfprintf(stderr, "Unknown line at line %u\n", linectr);\r\n}\r\n}\r\nint names_init(char *n)\r\n{\r\nFILE *f;\r\nif (!(f = fopen(n, "r"))) {\r\nreturn errno;\r\n}\r\nparse(f);\r\nfclose(f);\r\nreturn 0;\r\n}
