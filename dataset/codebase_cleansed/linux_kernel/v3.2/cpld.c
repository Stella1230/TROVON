static inline void cpld_set_bit(struct channel *channel, unsigned reg, u32 bit)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&channel->card->bootrom_lock, flags);\r\nbootrom_set_bit(channel, CPLD_MAP_REG(reg, channel), bit);\r\nspin_unlock_irqrestore(&channel->card->bootrom_lock, flags);\r\n}\r\nstatic inline void cpld_clear_bit(struct channel *channel, unsigned reg, u32 bit)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&channel->card->bootrom_lock, flags);\r\nbootrom_clear_bit(channel, CPLD_MAP_REG(reg, channel), bit);\r\nspin_unlock_irqrestore(&channel->card->bootrom_lock, flags);\r\n}\r\nvoid cpld_init(struct channel *sc)\r\n{\r\nu32 val;\r\n#if 0\r\nval = cpld_val_map[SBE_2T3E3_CPLD_VAL_LIU_FRAMER_RESET][sc->h.slot];\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_STATIC_RESET, val);\r\nudelay(10000);\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_STATIC_RESET, val);\r\n#endif\r\nval = SBE_2T3E3_CPLD_VAL_CRC32 |\r\ncpld_val_map[SBE_2T3E3_CPLD_VAL_LOOP_TIMING_SOURCE][sc->h.slot];\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PCRA, val);\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PCRB, val);\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PCRC, val);\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PBWF, val);\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PBWL, val);\r\nval = SBE_2T3E3_CPLD_VAL_LCV_COUNTER;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PLTR, val);\r\nudelay(1000);\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PLCR, val);\r\nudelay(1000);\r\nval = 0x55;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PPFR, val);\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_SERIAL_CHIP_SELECT, val);\r\nval = SBE_2T3E3_CPLD_VAL_DMO_SIGNAL_DETECTED |\r\nSBE_2T3E3_CPLD_VAL_RECEIVE_LOSS_OF_LOCK_DETECTED |\r\nSBE_2T3E3_CPLD_VAL_RECEIVE_LOSS_OF_SIGNAL_DETECTED;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PICSR, val);\r\ncpld_start_intr(sc);\r\nudelay(1000);\r\n}\r\nvoid cpld_start_intr(struct channel *sc)\r\n{\r\nu32 val;\r\nval = SBE_2T3E3_CPLD_VAL_INTERRUPT_FROM_ETHERNET_ENABLE |\r\nSBE_2T3E3_CPLD_VAL_INTERRUPT_FROM_FRAMER_ENABLE;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PIER, val);\r\n#if 0\r\n#endif\r\n}\r\nvoid cpld_stop_intr(struct channel *sc)\r\n{\r\nu32 val;\r\nval = 0;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PIER, val);\r\n}\r\nvoid cpld_set_frame_mode(struct channel *sc, u32 mode)\r\n{\r\nif (sc->p.frame_mode == mode)\r\nreturn;\r\nswitch (mode) {\r\ncase SBE_2T3E3_FRAME_MODE_HDLC:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_TRANSPARENT_MODE |\r\nSBE_2T3E3_CPLD_VAL_RAW_MODE);\r\nexar7250_unipolar_onoff(sc, SBE_2T3E3_OFF);\r\nexar7300_unipolar_onoff(sc, SBE_2T3E3_OFF);\r\nbreak;\r\ncase SBE_2T3E3_FRAME_MODE_TRANSPARENT:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_RAW_MODE);\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_TRANSPARENT_MODE);\r\nexar7250_unipolar_onoff(sc, SBE_2T3E3_OFF);\r\nexar7300_unipolar_onoff(sc, SBE_2T3E3_OFF);\r\nbreak;\r\ncase SBE_2T3E3_FRAME_MODE_RAW:\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_RAW_MODE);\r\nexar7250_unipolar_onoff(sc, SBE_2T3E3_ON);\r\nexar7300_unipolar_onoff(sc, SBE_2T3E3_ON);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsc->p.frame_mode = mode;\r\n}\r\nvoid cpld_set_frame_type(struct channel *sc, u32 type)\r\n{\r\nswitch (type) {\r\ncase SBE_2T3E3_FRAME_TYPE_E3_G751:\r\ncase SBE_2T3E3_FRAME_TYPE_E3_G832:\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_LOCAL_CLOCK_E3);\r\nbreak;\r\ncase SBE_2T3E3_FRAME_TYPE_T3_CBIT:\r\ncase SBE_2T3E3_FRAME_TYPE_T3_M13:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_LOCAL_CLOCK_E3);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nvoid cpld_set_scrambler(struct channel *sc, u32 mode)\r\n{\r\nif (sc->p.scrambler == mode)\r\nreturn;\r\nswitch (mode) {\r\ncase SBE_2T3E3_SCRAMBLER_OFF:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRB,\r\nSBE_2T3E3_CPLD_VAL_SCRAMBLER_ENABLE);\r\nbreak;\r\ncase SBE_2T3E3_SCRAMBLER_LARSCOM:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRB,\r\nSBE_2T3E3_CPLD_VAL_SCRAMBLER_TYPE);\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRB,\r\nSBE_2T3E3_CPLD_VAL_SCRAMBLER_ENABLE);\r\nbreak;\r\ncase SBE_2T3E3_SCRAMBLER_ADC_KENTROX_DIGITAL:\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRB,\r\nSBE_2T3E3_CPLD_VAL_SCRAMBLER_TYPE);\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRB,\r\nSBE_2T3E3_CPLD_VAL_SCRAMBLER_ENABLE);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsc->p.scrambler = mode;\r\n}\r\nvoid cpld_set_crc(struct channel *sc, u32 crc)\r\n{\r\nif (sc->p.crc == crc)\r\nreturn;\r\nswitch (crc) {\r\ncase SBE_2T3E3_CRC_16:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_CRC32);\r\nbreak;\r\ncase SBE_2T3E3_CRC_32:\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_CRC32);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsc->p.crc = crc;\r\n}\r\nvoid cpld_select_panel(struct channel *sc, u32 panel)\r\n{\r\nif (sc->p.panel == panel)\r\nreturn;\r\nswitch (panel) {\r\ncase SBE_2T3E3_PANEL_FRONT:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_REAR_PANEL);\r\nbreak;\r\ncase SBE_2T3E3_PANEL_REAR:\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_REAR_PANEL);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nudelay(100);\r\nsc->p.panel = panel;\r\n}\r\nextern void cpld_set_clock(struct channel *sc, u32 mode)\r\n{\r\nif (sc->p.clock_source == mode)\r\nreturn;\r\nswitch (mode) {\r\ncase SBE_2T3E3_TIMING_LOCAL:\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_ALT);\r\nbreak;\r\ncase SBE_2T3E3_TIMING_LOOP:\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRA,\r\nSBE_2T3E3_CPLD_VAL_ALT);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsc->p.clock_source = mode;\r\n}\r\nvoid cpld_set_pad_count(struct channel *sc, u32 count)\r\n{\r\nu32 val;\r\nif (sc->p.pad_count == count)\r\nreturn;\r\nswitch (count) {\r\ncase SBE_2T3E3_PAD_COUNT_1:\r\nval = SBE_2T3E3_CPLD_VAL_PAD_COUNT_1;\r\nbreak;\r\ncase SBE_2T3E3_PAD_COUNT_2:\r\nval = SBE_2T3E3_CPLD_VAL_PAD_COUNT_2;\r\nbreak;\r\ncase SBE_2T3E3_PAD_COUNT_3:\r\nval = SBE_2T3E3_CPLD_VAL_PAD_COUNT_3;\r\nbreak;\r\ncase SBE_2T3E3_PAD_COUNT_4:\r\nval = SBE_2T3E3_CPLD_VAL_PAD_COUNT_4;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ncpld_clear_bit(sc, SBE_2T3E3_CPLD_REG_PCRB,\r\nSBE_2T3E3_CPLD_VAL_PAD_COUNT);\r\ncpld_set_bit(sc, SBE_2T3E3_CPLD_REG_PCRB, val);\r\nsc->p.pad_count = count;\r\n}\r\nvoid cpld_LOS_update(struct channel *sc)\r\n{\r\nu_int8_t los;\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PICSR,\r\nSBE_2T3E3_CPLD_VAL_DMO_SIGNAL_DETECTED |\r\nSBE_2T3E3_CPLD_VAL_RECEIVE_LOSS_OF_LOCK_DETECTED |\r\nSBE_2T3E3_CPLD_VAL_RECEIVE_LOSS_OF_SIGNAL_DETECTED);\r\nlos = cpld_read(sc, SBE_2T3E3_CPLD_REG_PICSR) &\r\nSBE_2T3E3_CPLD_VAL_RECEIVE_LOSS_OF_SIGNAL_DETECTED;\r\nif (los != sc->s.LOS)\r\ndev_info(&sc->pdev->dev, "SBE 2T3E3: LOS status: %s\n",\r\nlos ? "Loss of signal" : "Signal OK");\r\nsc->s.LOS = los;\r\n}\r\nvoid cpld_set_fractional_mode(struct channel *sc, u32 mode,\r\nu32 start, u32 stop)\r\n{\r\nif (mode == SBE_2T3E3_FRACTIONAL_MODE_NONE) {\r\nstart = 0;\r\nstop = 0;\r\n}\r\nif (sc->p.fractional_mode == mode && sc->p.bandwidth_start == start &&\r\nsc->p.bandwidth_stop == stop)\r\nreturn;\r\nswitch (mode) {\r\ncase SBE_2T3E3_FRACTIONAL_MODE_NONE:\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PCRC,\r\nSBE_2T3E3_CPLD_VAL_FRACTIONAL_MODE_NONE);\r\nbreak;\r\ncase SBE_2T3E3_FRACTIONAL_MODE_0:\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PCRC,\r\nSBE_2T3E3_CPLD_VAL_FRACTIONAL_MODE_0);\r\nbreak;\r\ncase SBE_2T3E3_FRACTIONAL_MODE_1:\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PCRC,\r\nSBE_2T3E3_CPLD_VAL_FRACTIONAL_MODE_1);\r\nbreak;\r\ncase SBE_2T3E3_FRACTIONAL_MODE_2:\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PCRC,\r\nSBE_2T3E3_CPLD_VAL_FRACTIONAL_MODE_2);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "wrong mode in set_fractional_mode\n");\r\nreturn;\r\n}\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PBWF, start);\r\ncpld_write(sc, SBE_2T3E3_CPLD_REG_PBWL, stop);\r\nsc->p.fractional_mode = mode;\r\nsc->p.bandwidth_start = start;\r\nsc->p.bandwidth_stop = stop;\r\n}
