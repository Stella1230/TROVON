static u32 vpif_uservirt_to_phys(u32 virtp)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long physp = 0;\r\nstruct vm_area_struct *vma;\r\nvma = find_vma(mm, virtp);\r\nif (virtp >= PAGE_OFFSET) {\r\nphysp = virt_to_phys((void *)virtp);\r\n} else if (vma && (vma->vm_flags & VM_IO) && (vma->vm_pgoff)) {\r\nphysp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);\r\n} else {\r\nint res, nr_pages = 1;\r\nstruct page *pages;\r\ndown_read(&current->mm->mmap_sem);\r\nres = get_user_pages(current, current->mm,\r\nvirtp, nr_pages, 1, 0, &pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (res == nr_pages) {\r\nphysp = __pa(page_address(&pages[0]) +\r\n(virtp & ~PAGE_MASK));\r\n} else {\r\nvpif_err("get_user_pages failed\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn physp;\r\n}\r\nstatic int vpif_buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct common_obj *common;\r\nunsigned long addr;\r\ncommon = &fh->channel->common[VPIF_VIDEO_INDEX];\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nvb->width = common->width;\r\nvb->height = common->height;\r\nvb->size = vb->width * vb->height;\r\nvb->field = field;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nif (V4L2_MEMORY_USERPTR == common->memory) {\r\nif (!vb->baddr) {\r\nvpif_err("buffer_address is 0\n");\r\nreturn -EINVAL;\r\n}\r\nvb->boff = vpif_uservirt_to_phys(vb->baddr);\r\nif (!ISALIGNED(vb->boff))\r\ngoto buf_align_exit;\r\n}\r\naddr = vb->boff;\r\nif (q->streaming && (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != q->type)) {\r\nif (!ISALIGNED(addr + common->ytop_off) ||\r\n!ISALIGNED(addr + common->ybtm_off) ||\r\n!ISALIGNED(addr + common->ctop_off) ||\r\n!ISALIGNED(addr + common->cbtm_off))\r\ngoto buf_align_exit;\r\n}\r\nreturn 0;\r\nbuf_align_exit:\r\nvpif_err("buffer offset not aligned to 8 bytes\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_buffer_setup(struct videobuf_queue *q, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (V4L2_MEMORY_MMAP != common->memory)\r\nreturn 0;\r\n*size = config_params.channel_bufsize[ch->channel_id];\r\nif (*count < config_params.min_numbuffers)\r\n*count = config_params.min_numbuffers;\r\nreturn 0;\r\n}\r\nstatic void vpif_buffer_queue(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct common_obj *common;\r\ncommon = &fh->channel->common[VPIF_VIDEO_INDEX];\r\nlist_add_tail(&vb->queue, &common->dma_queue);\r\nvb->state = VIDEOBUF_QUEUED;\r\n}\r\nstatic void vpif_buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nunsigned int buf_size = 0;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvideobuf_dma_contig_free(q, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\nif (V4L2_MEMORY_MMAP != common->memory)\r\nreturn;\r\nbuf_size = config_params.channel_bufsize[ch->channel_id];\r\n}\r\nstatic void process_progressive_mode(struct common_obj *common)\r\n{\r\nunsigned long addr = 0;\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nlist_del(&common->next_frm->queue);\r\ncommon->next_frm->state = VIDEOBUF_ACTIVE;\r\naddr = videobuf_to_dma_contig(common->next_frm);\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\n}\r\nstatic void process_interlaced_mode(int fid, struct common_obj *common)\r\n{\r\nif (0 == fid) {\r\nif (common->cur_frm == common->next_frm)\r\nreturn;\r\ndo_gettimeofday(&common->cur_frm->ts);\r\ncommon->cur_frm->state = VIDEOBUF_DONE;\r\nwake_up_interruptible(&common->cur_frm->done);\r\ncommon->cur_frm = common->next_frm;\r\n} else if (1 == fid) {\r\nif (list_empty(&common->dma_queue)\r\n|| (common->cur_frm != common->next_frm)) {\r\nreturn;\r\n}\r\nprocess_progressive_mode(common);\r\n}\r\n}\r\nstatic irqreturn_t vpif_channel_isr(int irq, void *dev_id)\r\n{\r\nstruct vpif_device *dev = &vpif_obj;\r\nstruct channel_obj *ch;\r\nstruct common_obj *common;\r\nenum v4l2_field field;\r\nint fid = -1, i;\r\nint channel_id = 0;\r\nchannel_id = *(int *)(dev_id);\r\nch = dev->dev[channel_id];\r\nfield = ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;\r\nfor (i = 0; i < VPIF_NUMOBJECTS; i++) {\r\ncommon = &ch->common[i];\r\nif (0 == common->started)\r\ncontinue;\r\nif (1 == ch->vpifparams.std_info.frm_fmt) {\r\nif (list_empty(&common->dma_queue))\r\ncontinue;\r\nif (!channel_first_int[i][channel_id]) {\r\ndo_gettimeofday(&common->cur_frm->ts);\r\ncommon->cur_frm->state = VIDEOBUF_DONE;\r\nwake_up_interruptible(&common->cur_frm->done);\r\ncommon->cur_frm = common->next_frm;\r\n}\r\nchannel_first_int[i][channel_id] = 0;\r\nprocess_progressive_mode(common);\r\n} else {\r\nif (channel_first_int[i][channel_id]) {\r\nchannel_first_int[i][channel_id] = 0;\r\ncontinue;\r\n}\r\nif (0 == i) {\r\nch->field_id ^= 1;\r\nfid = vpif_channel_getfid(ch->channel_id + 2);\r\nif (fid != ch->field_id) {\r\nif (0 == fid)\r\nch->field_id = fid;\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nprocess_interlaced_mode(fid, common);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vpif_update_std_info(struct channel_obj *ch)\r\n{\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nconst struct vpif_channel_config_params *config;\r\nint i;\r\nfor (i = 0; i < vpif_ch_params_count; i++) {\r\nconfig = &ch_params[i];\r\nif (config->hd_sd == 0) {\r\nvpif_dbg(2, debug, "SD format\n");\r\nif (config->stdid & vid_ch->stdid) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n} else {\r\nvpif_dbg(2, debug, "HD format\n");\r\nif (config->dv_preset == vid_ch->dv_preset) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i == vpif_ch_params_count) {\r\nvpif_dbg(1, debug, "Format not found\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_update_resolution(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nif (!vid_ch->stdid && !vid_ch->dv_preset && !vid_ch->bt_timings.height)\r\nreturn -EINVAL;\r\nif (vid_ch->stdid || vid_ch->dv_preset) {\r\nif (vpif_update_std_info(ch))\r\nreturn -EINVAL;\r\n}\r\ncommon->fmt.fmt.pix.width = std_info->width;\r\ncommon->fmt.fmt.pix.height = std_info->height;\r\nvpif_dbg(1, debug, "Pixel details: Width = %d,Height = %d\n",\r\ncommon->fmt.fmt.pix.width, common->fmt.fmt.pix.height);\r\ncommon->height = std_info->height;\r\ncommon->width = std_info->width;\r\nreturn 0;\r\n}\r\nstatic void vpif_calculate_offsets(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nenum v4l2_field field = common->fmt.fmt.pix.field;\r\nstruct video_obj *vid_ch = &ch->video;\r\nunsigned int hpitch, vpitch, sizeimage;\r\nif (V4L2_FIELD_ANY == common->fmt.fmt.pix.field) {\r\nif (ch->vpifparams.std_info.frm_fmt)\r\nvid_ch->buf_field = V4L2_FIELD_NONE;\r\nelse\r\nvid_ch->buf_field = V4L2_FIELD_INTERLACED;\r\n} else {\r\nvid_ch->buf_field = common->fmt.fmt.pix.field;\r\n}\r\nif (V4L2_MEMORY_USERPTR == common->memory)\r\nsizeimage = common->fmt.fmt.pix.sizeimage;\r\nelse\r\nsizeimage = config_params.channel_bufsize[ch->channel_id];\r\nhpitch = common->fmt.fmt.pix.bytesperline;\r\nvpitch = sizeimage / (hpitch * 2);\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = hpitch;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = sizeimage / 2 + hpitch;\r\n} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = sizeimage / 4;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = common->ctop_off + sizeimage / 4;\r\n} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {\r\ncommon->ybtm_off = 0;\r\ncommon->ytop_off = sizeimage / 4;\r\ncommon->cbtm_off = sizeimage / 2;\r\ncommon->ctop_off = common->cbtm_off + sizeimage / 4;\r\n}\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\nvpifparams->video_params.storage_mode = 1;\r\n} else {\r\nvpifparams->video_params.storage_mode = 0;\r\n}\r\nif (ch->vpifparams.std_info.frm_fmt == 1) {\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n} else {\r\nif ((field == V4L2_FIELD_ANY) ||\r\n(field == V4L2_FIELD_INTERLACED))\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline * 2;\r\nelse\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n}\r\nch->vpifparams.video_params.stdid = ch->vpifparams.std_info.stdid;\r\n}\r\nstatic void vpif_config_format(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\ncommon->fmt.fmt.pix.field = V4L2_FIELD_ANY;\r\nif (config_params.numbuffers[ch->channel_id] == 0)\r\ncommon->memory = V4L2_MEMORY_USERPTR;\r\nelse\r\ncommon->memory = V4L2_MEMORY_MMAP;\r\ncommon->fmt.fmt.pix.sizeimage =\r\nconfig_params.channel_bufsize[ch->channel_id];\r\ncommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;\r\ncommon->fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\n}\r\nstatic int vpif_check_format(struct channel_obj *ch,\r\nstruct v4l2_pix_format *pixfmt)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nenum v4l2_field field = pixfmt->field;\r\nu32 sizeimage, hpitch, vpitch;\r\nif (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P)\r\ngoto invalid_fmt_exit;\r\nif (!(VPIF_VALID_FIELD(field)))\r\ngoto invalid_fmt_exit;\r\nif (pixfmt->bytesperline <= 0)\r\ngoto invalid_pitch_exit;\r\nif (V4L2_MEMORY_USERPTR == common->memory)\r\nsizeimage = pixfmt->sizeimage;\r\nelse\r\nsizeimage = config_params.channel_bufsize[ch->channel_id];\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\nhpitch = pixfmt->bytesperline;\r\nvpitch = sizeimage / (hpitch * 2);\r\nif ((hpitch < ch->vpifparams.std_info.width) ||\r\n(vpitch < ch->vpifparams.std_info.height))\r\ngoto invalid_pitch_exit;\r\nif (!ISALIGNED(hpitch)) {\r\nvpif_err("invalid pitch alignment\n");\r\nreturn -EINVAL;\r\n}\r\npixfmt->width = common->fmt.fmt.pix.width;\r\npixfmt->height = common->fmt.fmt.pix.height;\r\nreturn 0;\r\ninvalid_fmt_exit:\r\nvpif_err("invalid field format\n");\r\nreturn -EINVAL;\r\ninvalid_pitch_exit:\r\nvpif_err("invalid pitch\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (VPIF_CHANNEL3_VIDEO == ch->channel_id) {\r\ncommon->set_addr = ch3_set_videobuf_addr;\r\n} else {\r\nif (2 == muxmode)\r\ncommon->set_addr = ch2_set_videobuf_addr_yc_nmux;\r\nelse\r\ncommon->set_addr = ch2_set_videobuf_addr;\r\n}\r\n}\r\nstatic int vpif_mmap(struct file *filep, struct vm_area_struct *vma)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);\r\nvpif_dbg(2, debug, "vpif_mmap\n");\r\nreturn videobuf_mmap_mapper(&common->buffer_queue, vma);\r\n}\r\nstatic unsigned int vpif_poll(struct file *filep, poll_table *wait)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->started)\r\nreturn videobuf_poll_stream(filep, &common->buffer_queue, wait);\r\nreturn 0;\r\n}\r\nstatic int vpif_open(struct file *filep)\r\n{\r\nstruct video_device *vdev = video_devdata(filep);\r\nstruct channel_obj *ch = NULL;\r\nstruct vpif_fh *fh = NULL;\r\nch = video_get_drvdata(vdev);\r\nfh = kzalloc(sizeof(struct vpif_fh), GFP_KERNEL);\r\nif (fh == NULL) {\r\nvpif_err("unable to allocate memory for file handle object\n");\r\nreturn -ENOMEM;\r\n}\r\nfilep->private_data = fh;\r\nfh->channel = ch;\r\nfh->initialized = 0;\r\nif (!ch->initialized) {\r\nfh->initialized = 1;\r\nch->initialized = 1;\r\nmemset(&ch->vpifparams, 0, sizeof(ch->vpifparams));\r\n}\r\natomic_inc(&ch->usrs);\r\nfh->io_allowed[VPIF_VIDEO_INDEX] = 0;\r\nfh->prio = V4L2_PRIORITY_UNSET;\r\nv4l2_prio_open(&ch->prio, &fh->prio);\r\nreturn 0;\r\n}\r\nstatic int vpif_release(struct file *filep)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\ncommon->io_usrs = 0;\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nenable_channel2(0);\r\nchannel2_intr_enable(0);\r\n}\r\nif ((VPIF_CHANNEL3_VIDEO == ch->channel_id) ||\r\n(2 == common->started)) {\r\nenable_channel3(0);\r\nchannel3_intr_enable(0);\r\n}\r\ncommon->started = 0;\r\nvideobuf_queue_cancel(&common->buffer_queue);\r\nvideobuf_mmap_free(&common->buffer_queue);\r\ncommon->numbuffers =\r\nconfig_params.numbuffers[ch->channel_id];\r\n}\r\natomic_dec(&ch->usrs);\r\nif (fh->initialized)\r\nch->initialized = 0;\r\nv4l2_prio_close(&ch->prio, fh->prio);\r\nfilep->private_data = NULL;\r\nfh->initialized = 0;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int vpif_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\ncap->capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\nstrlcpy(cap->driver, "vpif display", sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, "Platform", sizeof(cap->bus_info));\r\nstrlcpy(cap->card, config->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nif (fmt->index != 0) {\r\nvpif_err("Invalid format index\n");\r\nreturn -EINVAL;\r\n}\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nstrcpy(fmt->description, "YCbCr4:2:2 YC Planar");\r\nfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->fmt.type != fmt->type)\r\nreturn -EINVAL;\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\n*fmt = common->fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct v4l2_pix_format *pixfmt;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret = 0;\r\nif ((VPIF_CHANNEL2_VIDEO == ch->channel_id)\r\n|| (VPIF_CHANNEL3_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_dbg(1, debug, "Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\nret = v4l2_prio_check(&ch->prio, fh->prio);\r\nif (0 != ret)\r\nreturn ret;\r\nfh->initialized = 1;\r\n}\r\nif (common->started) {\r\nvpif_dbg(1, debug, "Streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\npixfmt = &fmt->fmt.pix;\r\nret = vpif_check_format(ch, pixfmt);\r\nif (ret)\r\nreturn ret;\r\ncommon->fmt.fmt.pix = *pixfmt;\r\ncommon->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nint ret = 0;\r\nret = vpif_check_format(ch, pixfmt);\r\nif (ret) {\r\n*pixfmt = common->fmt.fmt.pix;\r\npixfmt->sizeimage = pixfmt->width * pixfmt->height * 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vpif_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbuf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nenum v4l2_field field;\r\nu8 index = 0;\r\nif ((VPIF_CHANNEL2_VIDEO == ch->channel_id)\r\n|| (VPIF_CHANNEL3_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_err("Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != reqbuf->type)\r\nreturn -EINVAL;\r\nindex = VPIF_VIDEO_INDEX;\r\ncommon = &ch->common[index];\r\nif (common->fmt.type != reqbuf->type)\r\nreturn -EINVAL;\r\nif (0 != common->io_usrs)\r\nreturn -EBUSY;\r\nif (reqbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (common->fmt.fmt.pix.field == V4L2_FIELD_ANY)\r\nfield = V4L2_FIELD_INTERLACED;\r\nelse\r\nfield = common->fmt.fmt.pix.field;\r\n} else {\r\nfield = V4L2_VBI_INTERLACED;\r\n}\r\nvideobuf_queue_dma_contig_init(&common->buffer_queue,\r\n&video_qops, NULL,\r\n&common->irqlock,\r\nreqbuf->type, field,\r\nsizeof(struct videobuf_buffer), fh,\r\n&common->lock);\r\nfh->io_allowed[index] = 1;\r\ncommon->io_usrs = 1;\r\ncommon->memory = reqbuf->memory;\r\nINIT_LIST_HEAD(&common->dma_queue);\r\nreturn videobuf_reqbufs(&common->buffer_queue, reqbuf);\r\n}\r\nstatic int vpif_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *tbuf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->fmt.type != tbuf->type)\r\nreturn -EINVAL;\r\nreturn videobuf_querybuf(&common->buffer_queue, tbuf);\r\n}\r\nstatic int vpif_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct v4l2_buffer tbuf = *buf;\r\nstruct videobuf_buffer *buf1;\r\nunsigned long addr = 0;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (common->fmt.type != tbuf.type)\r\nreturn -EINVAL;\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_err("fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (!(list_empty(&common->dma_queue)) ||\r\n(common->cur_frm != common->next_frm) ||\r\n!(common->started) ||\r\n(common->started && (0 == ch->field_id)))\r\nreturn videobuf_qbuf(&common->buffer_queue, buf);\r\nmutex_lock(&common->buffer_queue.vb_lock);\r\nbuf1 = common->buffer_queue.bufs[tbuf.index];\r\nif (buf1->memory != tbuf.memory) {\r\nvpif_err("invalid buffer type\n");\r\ngoto qbuf_exit;\r\n}\r\nif ((buf1->state == VIDEOBUF_QUEUED) ||\r\n(buf1->state == VIDEOBUF_ACTIVE)) {\r\nvpif_err("invalid state\n");\r\ngoto qbuf_exit;\r\n}\r\nswitch (buf1->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nif (buf1->baddr == 0)\r\ngoto qbuf_exit;\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\nif (tbuf.length < buf1->bsize)\r\ngoto qbuf_exit;\r\nif ((VIDEOBUF_NEEDS_INIT != buf1->state)\r\n&& (buf1->baddr != tbuf.m.userptr)) {\r\nvpif_buffer_release(&common->buffer_queue, buf1);\r\nbuf1->baddr = tbuf.m.userptr;\r\n}\r\nbreak;\r\ndefault:\r\ngoto qbuf_exit;\r\n}\r\nlocal_irq_save(flags);\r\nret = vpif_buffer_prepare(&common->buffer_queue, buf1,\r\ncommon->buffer_queue.field);\r\nif (ret < 0) {\r\nlocal_irq_restore(flags);\r\ngoto qbuf_exit;\r\n}\r\nbuf1->state = VIDEOBUF_ACTIVE;\r\naddr = buf1->boff;\r\ncommon->next_frm = buf1;\r\nif (tbuf.type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {\r\ncommon->set_addr((addr + common->ytop_off),\r\n(addr + common->ybtm_off),\r\n(addr + common->ctop_off),\r\n(addr + common->cbtm_off));\r\n}\r\nlocal_irq_restore(flags);\r\nlist_add_tail(&buf1->stream, &common->buffer_queue.stream);\r\nmutex_unlock(&common->buffer_queue.vb_lock);\r\nreturn 0;\r\nqbuf_exit:\r\nmutex_unlock(&common->buffer_queue.vb_lock);\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_s_std(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret = 0;\r\nif (!(*std_id & DM646X_V4L2_STD))\r\nreturn -EINVAL;\r\nif (common->started) {\r\nvpif_err("streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nch->video.stdid = *std_id;\r\nch->video.dv_preset = V4L2_DV_INVALID;\r\nmemset(&ch->video.bt_timings, 0, sizeof(ch->video.bt_timings));\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\nif ((ch->vpifparams.std_info.width *\r\nch->vpifparams.std_info.height * 2) >\r\nconfig_params.channel_bufsize[ch->channel_id]) {\r\nvpif_err("invalid std for this size\n");\r\nreturn -EINVAL;\r\n}\r\ncommon->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;\r\nvpif_config_format(ch);\r\nret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,\r\ns_std_output, *std_id);\r\nif (ret < 0) {\r\nvpif_err("Failed to set output standard\n");\r\nreturn ret;\r\n}\r\nret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, core,\r\ns_std, *std_id);\r\nif (ret < 0)\r\nvpif_err("Failed to set standard for sub devices\n");\r\nreturn ret;\r\n}\r\nstatic int vpif_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\n*std = ch->video.stdid;\r\nreturn 0;\r\n}\r\nstatic int vpif_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nreturn videobuf_dqbuf(&common->buffer_queue, p,\r\n(file->f_flags & O_NONBLOCK));\r\n}\r\nstatic int vpif_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct channel_obj *oth_ch = vpif_obj.dev[!ch->channel_id];\r\nstruct vpif_params *vpif = &ch->vpifparams;\r\nstruct vpif_display_config *vpif_config_data =\r\nvpif_dev->platform_data;\r\nunsigned long addr = 0;\r\nint ret = 0;\r\nif (buftype != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nvpif_err("buffer type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_err("fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (common->started) {\r\nvpif_err("channel->started\n");\r\nreturn -EBUSY;\r\n}\r\nif ((ch->channel_id == VPIF_CHANNEL2_VIDEO\r\n&& oth_ch->common[VPIF_VIDEO_INDEX].started &&\r\nch->vpifparams.std_info.ycmux_mode == 0)\r\n|| ((ch->channel_id == VPIF_CHANNEL3_VIDEO)\r\n&& (2 == oth_ch->common[VPIF_VIDEO_INDEX].started))) {\r\nvpif_err("other channel is using\n");\r\nreturn -EBUSY;\r\n}\r\nret = vpif_check_format(ch, &common->fmt.fmt.pix);\r\nif (ret < 0)\r\nreturn ret;\r\nret = videobuf_streamon(&common->buffer_queue);\r\nif (ret < 0) {\r\nvpif_err("videobuf_streamon\n");\r\nreturn ret;\r\n}\r\nif (list_empty(&common->dma_queue)) {\r\nvpif_err("buffer queue is empty\n");\r\nreturn -EIO;\r\n}\r\ncommon->next_frm = common->cur_frm =\r\nlist_entry(common->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nlist_del(&common->cur_frm->queue);\r\ncommon->cur_frm->state = VIDEOBUF_ACTIVE;\r\nch->field_id = 0;\r\ncommon->started = 1;\r\nif (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\naddr = common->cur_frm->boff;\r\nvpif_calculate_offsets(ch);\r\nif ((ch->vpifparams.std_info.frm_fmt &&\r\n((common->fmt.fmt.pix.field != V4L2_FIELD_NONE)\r\n&& (common->fmt.fmt.pix.field != V4L2_FIELD_ANY)))\r\n|| (!ch->vpifparams.std_info.frm_fmt\r\n&& (common->fmt.fmt.pix.field == V4L2_FIELD_NONE))) {\r\nvpif_err("conflict in field format and std format\n");\r\nreturn -EINVAL;\r\n}\r\nret =\r\nvpif_config_data->set_clock(ch->vpifparams.std_info.ycmux_mode,\r\nch->vpifparams.std_info.hd_sd);\r\nif (ret < 0) {\r\nvpif_err("can't set clock\n");\r\nreturn ret;\r\n}\r\nret = vpif_set_video_params(vpif, ch->channel_id + 2);\r\nif (ret < 0)\r\nreturn ret;\r\ncommon->started = ret;\r\nvpif_config_addr(ch, ret);\r\ncommon->set_addr((addr + common->ytop_off),\r\n(addr + common->ybtm_off),\r\n(addr + common->ctop_off),\r\n(addr + common->cbtm_off));\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nchannel2_intr_assert();\r\nchannel2_intr_enable(1);\r\nenable_channel2(1);\r\n}\r\nif ((VPIF_CHANNEL3_VIDEO == ch->channel_id)\r\n|| (common->started == 2)) {\r\nchannel3_intr_assert();\r\nchannel3_intr_enable(1);\r\nenable_channel3(1);\r\n}\r\nchannel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vpif_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (buftype != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nvpif_err("buffer type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_err("fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (!common->started) {\r\nvpif_err("channel->started\n");\r\nreturn -EINVAL;\r\n}\r\nif (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nenable_channel2(0);\r\nchannel2_intr_enable(0);\r\n}\r\nif ((VPIF_CHANNEL3_VIDEO == ch->channel_id) ||\r\n(2 == common->started)) {\r\nenable_channel3(0);\r\nchannel3_intr_enable(0);\r\n}\r\n}\r\ncommon->started = 0;\r\nreturn videobuf_streamoff(&common->buffer_queue);\r\n}\r\nstatic int vpif_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *crop)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != crop->type)\r\nreturn -EINVAL;\r\ncrop->bounds.left = crop->bounds.top = 0;\r\ncrop->defrect.left = crop->defrect.top = 0;\r\ncrop->defrect.height = crop->bounds.height = common->height;\r\ncrop->defrect.width = crop->bounds.width = common->width;\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_output(struct file *file, void *fh,\r\nstruct v4l2_output *output)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nif (output->index >= config->output_count) {\r\nvpif_dbg(1, debug, "Invalid output index\n");\r\nreturn -EINVAL;\r\n}\r\nstrcpy(output->name, config->output[output->index]);\r\noutput->type = V4L2_OUTPUT_TYPE_ANALOG;\r\noutput->std = DM646X_V4L2_STD;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_output(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret = 0;\r\nif (common->started) {\r\nvpif_err("Streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,\r\ns_routing, 0, i, 0);\r\nif (ret < 0)\r\nvpif_err("Failed to set output standard\n");\r\nvid_ch->output_id = i;\r\nreturn ret;\r\n}\r\nstatic int vpif_g_output(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\n*i = vid_ch->output_id;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_priority(struct file *file, void *priv, enum v4l2_priority *p)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\n*p = v4l2_prio_max(&ch->prio);\r\nreturn 0;\r\n}\r\nstatic int vpif_s_priority(struct file *file, void *priv, enum v4l2_priority p)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nreturn v4l2_prio_change(&ch->prio, &fh->prio, p);\r\n}\r\nstatic int vpif_enum_dv_presets(struct file *file, void *priv,\r\nstruct v4l2_dv_enum_preset *preset)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\nreturn v4l2_subdev_call(vpif_obj.sd[vid_ch->output_id],\r\nvideo, enum_dv_presets, preset);\r\n}\r\nstatic int vpif_s_dv_preset(struct file *file, void *priv,\r\nstruct v4l2_dv_preset *preset)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct video_obj *vid_ch = &ch->video;\r\nint ret = 0;\r\nif (common->started) {\r\nvpif_dbg(1, debug, "streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nret = v4l2_prio_check(&ch->prio, fh->prio);\r\nif (ret != 0)\r\nreturn ret;\r\nfh->initialized = 1;\r\nif (mutex_lock_interruptible(&common->lock))\r\nreturn -ERESTARTSYS;\r\nch->video.dv_preset = preset->preset;\r\nch->video.stdid = V4L2_STD_UNKNOWN;\r\nmemset(&ch->video.bt_timings, 0, sizeof(ch->video.bt_timings));\r\nif (vpif_update_resolution(ch)) {\r\nret = -EINVAL;\r\n} else {\r\nvpif_config_format(ch);\r\nret = v4l2_subdev_call(vpif_obj.sd[vid_ch->output_id],\r\nvideo, s_dv_preset, preset);\r\n}\r\nmutex_unlock(&common->lock);\r\nreturn ret;\r\n}\r\nstatic int vpif_g_dv_preset(struct file *file, void *priv,\r\nstruct v4l2_dv_preset *preset)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\npreset->preset = ch->video.dv_preset;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_bt_timings *bt = &vid_ch->bt_timings;\r\nint ret;\r\nif (timings->type != V4L2_DV_BT_656_1120) {\r\nvpif_dbg(2, debug, "Timing type not defined\n");\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_subdev_call(vpif_obj.sd[vid_ch->output_id],\r\nvideo, s_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD) {\r\nvpif_dbg(2, debug, "Custom DV timings not supported by "\r\n"subdevice\n");\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0) {\r\nvpif_dbg(2, debug, "Error setting custom DV timings\n");\r\nreturn ret;\r\n}\r\nif (!(timings->bt.width && timings->bt.height &&\r\n(timings->bt.hbackporch ||\r\ntimings->bt.hfrontporch ||\r\ntimings->bt.hsync) &&\r\ntimings->bt.vfrontporch &&\r\n(timings->bt.vbackporch ||\r\ntimings->bt.vsync))) {\r\nvpif_dbg(2, debug, "Timings for width, height, "\r\n"horizontal back porch, horizontal sync, "\r\n"horizontal front porch, vertical back porch, "\r\n"vertical sync and vertical back porch "\r\n"must be defined\n");\r\nreturn -EINVAL;\r\n}\r\n*bt = timings->bt;\r\nstd_info->eav2sav = bt->hbackporch + bt->hfrontporch +\r\nbt->hsync - 8;\r\nstd_info->sav2eav = bt->width;\r\nstd_info->l1 = 1;\r\nstd_info->l3 = bt->vsync + bt->vbackporch + 1;\r\nif (bt->interlaced) {\r\nif (bt->il_vbackporch || bt->il_vfrontporch || bt->il_vsync) {\r\nstd_info->vsize = bt->height * 2 +\r\nbt->vfrontporch + bt->vsync + bt->vbackporch +\r\nbt->il_vfrontporch + bt->il_vsync +\r\nbt->il_vbackporch;\r\nstd_info->l5 = std_info->vsize/2 -\r\n(bt->vfrontporch - 1);\r\nstd_info->l7 = std_info->vsize/2 + 1;\r\nstd_info->l9 = std_info->l7 + bt->il_vsync +\r\nbt->il_vbackporch + 1;\r\nstd_info->l11 = std_info->vsize -\r\n(bt->il_vfrontporch - 1);\r\n} else {\r\nvpif_dbg(2, debug, "Required timing values for "\r\n"interlaced BT format missing\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nstd_info->vsize = bt->height + bt->vfrontporch +\r\nbt->vsync + bt->vbackporch;\r\nstd_info->l5 = std_info->vsize - (bt->vfrontporch - 1);\r\n}\r\nstrncpy(std_info->name, "Custom timings BT656/1120",\r\nVPIF_MAX_NAME);\r\nstd_info->width = bt->width;\r\nstd_info->height = bt->height;\r\nstd_info->frm_fmt = bt->interlaced ? 0 : 1;\r\nstd_info->ycmux_mode = 0;\r\nstd_info->capture_format = 0;\r\nstd_info->vbi_supported = 0;\r\nstd_info->hd_sd = 1;\r\nstd_info->stdid = 0;\r\nstd_info->dv_preset = V4L2_DV_INVALID;\r\nvid_ch->stdid = 0;\r\nvid_ch->dv_preset = V4L2_DV_INVALID;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_bt_timings *bt = &vid_ch->bt_timings;\r\ntimings->bt = *bt;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_chip_ident(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nchip->ident = V4L2_IDENT_NONE;\r\nchip->revision = 0;\r\nif (chip->match.type != V4L2_CHIP_MATCH_I2C_DRIVER &&\r\nchip->match.type != V4L2_CHIP_MATCH_I2C_ADDR) {\r\nvpif_dbg(2, debug, "match_type is invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 0, core,\r\ng_chip_ident, chip);\r\n}\r\nstatic int vpif_dbg_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg){\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\nreturn v4l2_subdev_call(vpif_obj.sd[vid_ch->output_id], core,\r\ng_register, reg);\r\n}\r\nstatic int vpif_dbg_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg){\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\nreturn v4l2_subdev_call(vpif_obj.sd[vid_ch->output_id], core,\r\ns_register, reg);\r\n}\r\nstatic int vpif_log_status(struct file *filep, void *priv)\r\n{\r\nv4l2_device_call_all(&vpif_obj.v4l2_dev, 0, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int initialize_vpif(void)\r\n{\r\nint free_channel_objects_index;\r\nint free_buffer_channel_index;\r\nint free_buffer_index;\r\nint err = 0, i, j;\r\nif ((ch2_numbuffers > 0) &&\r\n(ch2_numbuffers < config_params.min_numbuffers))\r\nch2_numbuffers = config_params.min_numbuffers;\r\nif ((ch3_numbuffers > 0) &&\r\n(ch3_numbuffers < config_params.min_numbuffers))\r\nch3_numbuffers = config_params.min_numbuffers;\r\nif (ch2_bufsize < config_params.min_bufsize[VPIF_CHANNEL2_VIDEO])\r\nch2_bufsize =\r\nconfig_params.min_bufsize[VPIF_CHANNEL2_VIDEO];\r\nif (ch3_bufsize < config_params.min_bufsize[VPIF_CHANNEL3_VIDEO])\r\nch3_bufsize =\r\nconfig_params.min_bufsize[VPIF_CHANNEL3_VIDEO];\r\nconfig_params.numbuffers[VPIF_CHANNEL2_VIDEO] = ch2_numbuffers;\r\nif (ch2_numbuffers) {\r\nconfig_params.channel_bufsize[VPIF_CHANNEL2_VIDEO] =\r\nch2_bufsize;\r\n}\r\nconfig_params.numbuffers[VPIF_CHANNEL3_VIDEO] = ch3_numbuffers;\r\nif (ch3_numbuffers) {\r\nconfig_params.channel_bufsize[VPIF_CHANNEL3_VIDEO] =\r\nch3_bufsize;\r\n}\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nvpif_obj.dev[i] =\r\nkzalloc(sizeof(struct channel_obj), GFP_KERNEL);\r\nif (!vpif_obj.dev[i]) {\r\nfree_channel_objects_index = i;\r\nerr = -ENOMEM;\r\ngoto vpif_init_free_channel_objects;\r\n}\r\n}\r\nfree_channel_objects_index = VPIF_DISPLAY_MAX_DEVICES;\r\nfree_buffer_channel_index = VPIF_DISPLAY_NUM_CHANNELS;\r\nfree_buffer_index = config_params.numbuffers[i - 1];\r\nreturn 0;\r\nvpif_init_free_channel_objects:\r\nfor (j = 0; j < free_channel_objects_index; j++)\r\nkfree(vpif_obj.dev[j]);\r\nreturn err;\r\n}\r\nstatic __init int vpif_probe(struct platform_device *pdev)\r\n{\r\nstruct vpif_subdev_info *subdevdata;\r\nstruct vpif_display_config *config;\r\nint i, j = 0, k, q, m, err = 0;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nint subdev_count;\r\nvpif_dev = &pdev->dev;\r\nerr = initialize_vpif();\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error initializing vpif\n");\r\nreturn err;\r\n}\r\nerr = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error registering v4l2 device\n");\r\nreturn err;\r\n}\r\nk = 0;\r\nwhile ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {\r\nfor (i = res->start; i <= res->end; i++) {\r\nif (request_irq(i, vpif_channel_isr, IRQF_DISABLED,\r\n"DM646x_Display",\r\n(void *)(&vpif_obj.dev[k]->channel_id))) {\r\nerr = -EBUSY;\r\ngoto vpif_int_err;\r\n}\r\n}\r\nk++;\r\n}\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvfd = video_device_alloc();\r\nif (vfd == NULL) {\r\nfor (j = 0; j < i; j++) {\r\nch = vpif_obj.dev[j];\r\nvideo_device_release(ch->video_dev);\r\n}\r\nerr = -ENOMEM;\r\ngoto vpif_int_err;\r\n}\r\n*vfd = vpif_video_template;\r\nvfd->v4l2_dev = &vpif_obj.v4l2_dev;\r\nvfd->release = video_device_release;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"DM646x_VPIFDisplay_DRIVER_V%s",\r\nVPIF_DISPLAY_VERSION);\r\nch->video_dev = vfd;\r\n}\r\nfor (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {\r\nch = vpif_obj.dev[j];\r\natomic_set(&ch->usrs, 0);\r\nfor (k = 0; k < VPIF_NUMOBJECTS; k++) {\r\nch->common[k].numbuffers = 0;\r\ncommon = &ch->common[k];\r\ncommon->io_usrs = 0;\r\ncommon->started = 0;\r\nspin_lock_init(&common->irqlock);\r\nmutex_init(&common->lock);\r\ncommon->numbuffers = 0;\r\ncommon->set_addr = NULL;\r\ncommon->ytop_off = common->ybtm_off = 0;\r\ncommon->ctop_off = common->cbtm_off = 0;\r\ncommon->cur_frm = common->next_frm = NULL;\r\nmemset(&common->fmt, 0, sizeof(common->fmt));\r\ncommon->numbuffers = config_params.numbuffers[k];\r\n}\r\nch->initialized = 0;\r\nch->channel_id = j;\r\nif (j < 2)\r\nch->common[VPIF_VIDEO_INDEX].numbuffers =\r\nconfig_params.numbuffers[ch->channel_id];\r\nelse\r\nch->common[VPIF_VIDEO_INDEX].numbuffers = 0;\r\nmemset(&ch->vpifparams, 0, sizeof(ch->vpifparams));\r\nv4l2_prio_init(&ch->prio);\r\nch->common[VPIF_VIDEO_INDEX].fmt.type =\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nch->video_dev->lock = &common->lock;\r\nvpif_dbg(1, debug, "channel=%x,channel->video_dev=%x\n",\r\n(int)ch, (int)&ch->video_dev);\r\nerr = video_register_device(ch->video_dev,\r\nVFL_TYPE_GRABBER, (j ? 3 : 2));\r\nif (err < 0)\r\ngoto probe_out;\r\nvideo_set_drvdata(ch->video_dev, ch);\r\n}\r\ni2c_adap = i2c_get_adapter(1);\r\nconfig = pdev->dev.platform_data;\r\nsubdev_count = config->subdev_count;\r\nsubdevdata = config->subdevinfo;\r\nvpif_obj.sd = kzalloc(sizeof(struct v4l2_subdev *) * subdev_count,\r\nGFP_KERNEL);\r\nif (vpif_obj.sd == NULL) {\r\nvpif_err("unable to allocate memory for subdevice pointers\n");\r\nerr = -ENOMEM;\r\ngoto probe_out;\r\n}\r\nfor (i = 0; i < subdev_count; i++) {\r\nvpif_obj.sd[i] = v4l2_i2c_new_subdev_board(&vpif_obj.v4l2_dev,\r\ni2c_adap,\r\n&subdevdata[i].board_info,\r\nNULL);\r\nif (!vpif_obj.sd[i]) {\r\nvpif_err("Error registering v4l2 subdevice\n");\r\ngoto probe_subdev_out;\r\n}\r\nif (vpif_obj.sd[i])\r\nvpif_obj.sd[i]->grp_id = 1 << i;\r\n}\r\nv4l2_info(&vpif_obj.v4l2_dev,\r\n"DM646x VPIF display driver initialized\n");\r\nreturn 0;\r\nprobe_subdev_out:\r\nkfree(vpif_obj.sd);\r\nprobe_out:\r\nfor (k = 0; k < j; k++) {\r\nch = vpif_obj.dev[k];\r\nvideo_unregister_device(ch->video_dev);\r\nvideo_device_release(ch->video_dev);\r\nch->video_dev = NULL;\r\n}\r\nvpif_int_err:\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nvpif_err("VPIF IRQ request failed\n");\r\nfor (q = k; k >= 0; k--) {\r\nfor (m = i; m >= res->start; m--)\r\nfree_irq(m, (void *)(&vpif_obj.dev[k]->channel_id));\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, k-1);\r\nm = res->end;\r\n}\r\nreturn err;\r\n}\r\nstatic int vpif_remove(struct platform_device *device)\r\n{\r\nstruct channel_obj *ch;\r\nint i;\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvideo_unregister_device(ch->video_dev);\r\nch->video_dev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int vpif_init(void)\r\n{\r\nreturn platform_driver_register(&vpif_driver);\r\n}\r\nstatic void vpif_cleanup(void)\r\n{\r\nstruct platform_device *pdev;\r\nstruct resource *res;\r\nint irq_num;\r\nint i = 0;\r\npdev = container_of(vpif_dev, struct platform_device, dev);\r\nwhile ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {\r\nfor (irq_num = res->start; irq_num <= res->end; irq_num++)\r\nfree_irq(irq_num,\r\n(void *)(&vpif_obj.dev[i]->channel_id));\r\ni++;\r\n}\r\nplatform_driver_unregister(&vpif_driver);\r\nkfree(vpif_obj.sd);\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++)\r\nkfree(vpif_obj.dev[i]);\r\n}
