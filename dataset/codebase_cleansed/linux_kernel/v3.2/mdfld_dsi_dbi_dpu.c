static int mdfld_cursor_damage(struct mdfld_dbi_dpu_info *dpu_info,\r\nmdfld_plane_t plane,\r\nstruct psb_drm_dpu_rect *damaged_rect)\r\n{\r\nint x, y;\r\nint new_x, new_y;\r\nstruct psb_drm_dpu_rect *rect;\r\nstruct psb_drm_dpu_rect *pipe_rect;\r\nint cursor_size;\r\nstruct mdfld_cursor_info *cursor;\r\nmdfld_plane_t fb_plane;\r\nif (plane == MDFLD_CURSORA) {\r\ncursor = &dpu_info->cursors[0];\r\nx = dpu_info->cursors[0].x;\r\ny = dpu_info->cursors[0].y;\r\ncursor_size = dpu_info->cursors[0].size;\r\npipe_rect = &dpu_info->damage_pipea;\r\nfb_plane = MDFLD_PLANEA;\r\n} else {\r\ncursor = &dpu_info->cursors[1];\r\nx = dpu_info->cursors[1].x;\r\ny = dpu_info->cursors[1].y;\r\ncursor_size = dpu_info->cursors[1].size;\r\npipe_rect = &dpu_info->damage_pipec;\r\nfb_plane = MDFLD_PLANEC;\r\n}\r\nnew_x = damaged_rect->x;\r\nnew_y = damaged_rect->y;\r\nif (x == new_x && y == new_y)\r\nreturn 0;\r\nrect = &dpu_info->damaged_rects[plane];\r\nif (new_x >= x) {\r\nif (new_y > y) {\r\nrect->x = x;\r\nrect->y = y;\r\nrect->width = (new_x + cursor_size) - x;\r\nrect->height = (new_y + cursor_size) - y;\r\ngoto cursor_out;\r\n} else {\r\nrect->x = x;\r\nrect->y = new_y;\r\nrect->width = (new_x + cursor_size) - x;\r\nrect->height = (y - new_y);\r\ngoto cursor_out;\r\n}\r\n} else {\r\nif (new_y > y) {\r\nrect->x = new_x;\r\nrect->y = y;\r\nrect->width = (x + cursor_size) - new_x;\r\nrect->height = new_y - y;\r\ngoto cursor_out;\r\n} else {\r\nrect->x = new_x;\r\nrect->y = new_y;\r\nrect->width = (x + cursor_size) - new_x;\r\nrect->height = (y + cursor_size) - new_y;\r\n}\r\n}\r\ncursor_out:\r\nif (new_x < 0)\r\ncursor->x = 0;\r\nelse if (new_x > 864)\r\ncursor->x = 864;\r\nelse\r\ncursor->x = new_x;\r\nif (new_y < 0)\r\ncursor->y = 0;\r\nelse if (new_y > 480)\r\ncursor->y = 480;\r\nelse\r\ncursor->y = new_y;\r\nrect->x = 0;\r\nrect->y = 0;\r\nrect->width = 864;\r\nrect->height = 480;\r\nmdfld_check_boundary(dpu_info, rect);\r\nmdfld_dpu_region_extent(pipe_rect, rect);\r\ndpu_info->pending |= (1 << plane);\r\ndpu_info->pending |= (1 << fb_plane);\r\nreturn 0;\r\n}\r\nstatic int mdfld_fb_damage(struct mdfld_dbi_dpu_info *dpu_info,\r\nmdfld_plane_t plane,\r\nstruct psb_drm_dpu_rect *damaged_rect)\r\n{\r\nstruct psb_drm_dpu_rect *rect;\r\nif (plane == MDFLD_PLANEA)\r\nrect = &dpu_info->damage_pipea;\r\nelse\r\nrect = &dpu_info->damage_pipec;\r\nmdfld_check_boundary(dpu_info, damaged_rect);\r\nmdfld_dpu_region_extent(rect, damaged_rect);\r\ndpu_info->pending |= (1 << plane);\r\nreturn 0;\r\n}\r\nstatic int mdfld_overlay_damage(struct mdfld_dbi_dpu_info *dpu_info,\r\nmdfld_plane_t plane,\r\nstruct psb_drm_dpu_rect *damaged_rect)\r\n{\r\nreturn 0;\r\n}\r\nint mdfld_dbi_dpu_report_damage(struct drm_device *dev,\r\nmdfld_plane_t plane,\r\nstruct psb_drm_dpu_rect *rect)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nint ret = 0;\r\nif (dpu_info == NULL)\r\nreturn 0;\r\nspin_lock(&dpu_info->dpu_update_lock);\r\nswitch (plane) {\r\ncase MDFLD_PLANEA:\r\ncase MDFLD_PLANEC:\r\nmdfld_fb_damage(dpu_info, plane, rect);\r\nbreak;\r\ncase MDFLD_CURSORA:\r\ncase MDFLD_CURSORC:\r\nmdfld_cursor_damage(dpu_info, plane, rect);\r\nbreak;\r\ncase MDFLD_OVERLAYA:\r\ncase MDFLD_OVERLAYC:\r\nmdfld_overlay_damage(dpu_info, plane, rect);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid plane type %d\n", plane);\r\nret = -EINVAL;\r\n}\r\nspin_unlock(&dpu_info->dpu_update_lock);\r\nreturn ret;\r\n}\r\nint mdfld_dbi_dpu_report_fullscreen_damage(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv;\r\nstruct mdfld_dbi_dpu_info *dpu_info;\r\nstruct mdfld_dsi_config *dsi_config;\r\nstruct psb_drm_dpu_rect rect;\r\nint i;\r\nif (!dev) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv = dev->dev_private;\r\ndpu_info = dev_priv->dbi_dpu_info;\r\nif (!dpu_info)\r\nreturn -EINVAL;\r\nfor (i = 0; i < dpu_info->dbi_output_num; i++) {\r\ndsi_config = dev_priv->dsi_configs[i];\r\nif (dsi_config) {\r\nrect.x = rect.y = 0;\r\nrect.width = dsi_config->fixed_mode->hdisplay;\r\nrect.height = dsi_config->fixed_mode->vdisplay;\r\nmdfld_dbi_dpu_report_damage(dev,\r\ni ? (MDFLD_PLANEC) : (MDFLD_PLANEA),\r\n&rect);\r\n}\r\n}\r\nmdfld_dpu_exit_dsr(dev);\r\nreturn 0;\r\n}\r\nint mdfld_dsi_dbi_dsr_off(struct drm_device *dev,\r\nstruct psb_drm_dpu_rect *rect)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nmdfld_dbi_dpu_report_damage(dev, MDFLD_PLANEA, rect);\r\nif (dpu_info->dbi_output_num == 2)\r\nmdfld_dbi_dpu_report_damage(dev, MDFLD_PLANEC, rect);\r\nmdfld_dpu_exit_dsr(dev);\r\nreturn 0;\r\n}\r\nstatic void mdfld_dpu_cursor_plane_flush(struct mdfld_dbi_dpu_info *dpu_info,\r\nmdfld_plane_t plane)\r\n{\r\nstruct drm_device *dev = dpu_info->dev;\r\nu32 curpos_reg = CURAPOS;\r\nu32 curbase_reg = CURABASE;\r\nu32 curcntr_reg = CURACNTR;\r\nstruct mdfld_cursor_info *cursor = &dpu_info->cursors[0];\r\nif (plane == MDFLD_CURSORC) {\r\ncurpos_reg = CURCPOS;\r\ncurbase_reg = CURCBASE;\r\ncurcntr_reg = CURCCNTR;\r\ncursor = &dpu_info->cursors[1];\r\n}\r\nREG_WRITE(curcntr_reg, REG_READ(curcntr_reg));\r\nREG_WRITE(curpos_reg,\r\n(((cursor->x & CURSOR_POS_MASK) << CURSOR_X_SHIFT) |\r\n((cursor->y & CURSOR_POS_MASK) << CURSOR_Y_SHIFT)));\r\nREG_WRITE(curbase_reg, REG_READ(curbase_reg));\r\n}\r\nstatic void mdfld_dpu_fb_plane_flush(struct mdfld_dbi_dpu_info *dpu_info,\r\nmdfld_plane_t plane)\r\n{\r\nu32 pipesrc_reg = PIPEASRC;\r\nu32 dspsize_reg = DSPASIZE;\r\nu32 dspoff_reg = DSPALINOFF;\r\nu32 dspsurf_reg = DSPASURF;\r\nu32 dspstride_reg = DSPASTRIDE;\r\nu32 stride;\r\nstruct psb_drm_dpu_rect *rect = &dpu_info->damage_pipea;\r\nstruct drm_device *dev = dpu_info->dev;\r\nif (plane == MDFLD_PLANEC) {\r\npipesrc_reg = PIPECSRC;\r\ndspsize_reg = DSPCSIZE;\r\ndspoff_reg = DSPCLINOFF;\r\ndspsurf_reg = DSPCSURF;\r\ndspstride_reg = DSPCSTRIDE;\r\nrect = &dpu_info->damage_pipec;\r\n}\r\nstride = REG_READ(dspstride_reg);\r\nREG_WRITE(pipesrc_reg, ((rect->width - 1) << 16) | (rect->height - 1));\r\nREG_WRITE(dspsize_reg, ((rect->height - 1) << 16) | (rect->width - 1));\r\nREG_WRITE(dspoff_reg, ((rect->x * 4) + (rect->y * stride)));\r\nREG_WRITE(dspsurf_reg, REG_READ(dspsurf_reg));\r\n}\r\nstatic void mdfld_dpu_overlay_plane_flush(struct mdfld_dbi_dpu_info *dpu_info,\r\nmdfld_plane_t plane)\r\n{\r\n}\r\nstatic int mdfld_dbi_prepare_cb(struct mdfld_dsi_dbi_output *dbi_output,\r\nstruct mdfld_dbi_dpu_info *dpu_info, int pipe)\r\n{\r\nu8 *cb_addr = (u8 *)dbi_output->dbi_cb_addr;\r\nu32 *index;\r\nstruct psb_drm_dpu_rect *rect = pipe ?\r\n(&dpu_info->damage_pipec) : (&dpu_info->damage_pipea);\r\nif (!spin_trylock(&dbi_output->cb_lock)) {\r\nDRM_ERROR("lock command buffer failed, try again\n");\r\nreturn -EAGAIN;\r\n}\r\nindex = &dbi_output->cb_write;\r\nif (*index) {\r\nDRM_ERROR("DBI command buffer unclean\n");\r\nreturn -EAGAIN;\r\n}\r\n*(cb_addr + ((*index)++)) = set_column_address;\r\n*(cb_addr + ((*index)++)) = rect->x >> 8;\r\n*(cb_addr + ((*index)++)) = rect->x;\r\n*(cb_addr + ((*index)++)) = (rect->x + rect->width - 1) >> 8;\r\n*(cb_addr + ((*index)++)) = (rect->x + rect->width - 1);\r\n*index = 8;\r\n*(cb_addr + ((*index)++)) = set_page_addr;\r\n*(cb_addr + ((*index)++)) = rect->y >> 8;\r\n*(cb_addr + ((*index)++)) = rect->y;\r\n*(cb_addr + ((*index)++)) = (rect->y + rect->height - 1) >> 8;\r\n*(cb_addr + ((*index)++)) = (rect->y + rect->height - 1);\r\n*index = 16;\r\n*(cb_addr + ((*index)++)) = write_mem_start;\r\nreturn 0;\r\n}\r\nstatic int mdfld_dbi_flush_cb(struct mdfld_dsi_dbi_output *dbi_output, int pipe)\r\n{\r\nu32 cmd_phy = dbi_output->dbi_cb_phy;\r\nu32 *index = &dbi_output->cb_write;\r\nint reg_offset = pipe ? MIPIC_REG_OFFSET : 0;\r\nstruct drm_device *dev = dbi_output->dev;\r\nif (*index == 0 || !dbi_output)\r\nreturn 0;\r\nREG_WRITE((MIPIA_CMD_LEN_REG + reg_offset), 0x010505);\r\nREG_WRITE((MIPIA_CMD_ADD_REG + reg_offset), cmd_phy | 3);\r\n*index = 0;\r\nspin_unlock(&dbi_output->cb_lock);\r\nreturn 0;\r\n}\r\nstatic int mdfld_dpu_update_pipe(struct mdfld_dsi_dbi_output *dbi_output,\r\nstruct mdfld_dbi_dpu_info *dpu_info, int pipe)\r\n{\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nmdfld_plane_t cursor_plane = MDFLD_CURSORA;\r\nmdfld_plane_t fb_plane = MDFLD_PLANEA;\r\nmdfld_plane_t overlay_plane = MDFLD_OVERLAYA;\r\nint ret = 0;\r\nu32 plane_mask = MDFLD_PIPEA_PLANE_MASK;\r\nif (pipe) {\r\ncursor_plane = MDFLD_CURSORC;\r\nfb_plane = MDFLD_PLANEC;\r\noverlay_plane = MDFLD_OVERLAYC;\r\nplane_mask = MDFLD_PIPEC_PLANE_MASK;\r\n}\r\nif (dpu_info->pending & (1 << cursor_plane))\r\nmdfld_dpu_cursor_plane_flush(dpu_info, cursor_plane);\r\nif (dpu_info->pending & (1 << fb_plane))\r\nmdfld_dpu_fb_plane_flush(dpu_info, fb_plane);\r\nif (dpu_info->pending & (1 << overlay_plane))\r\nmdfld_dpu_overlay_plane_flush(dpu_info, overlay_plane);\r\nif (dpu_info->pending & plane_mask) {\r\nret = mdfld_dbi_prepare_cb(dbi_output, dpu_info, pipe);\r\nif (!ret && dev_priv->dsr_enable) {\r\ndpu_info->pending &= ~plane_mask;\r\nmdfld_dpu_init_damage(dpu_info, pipe);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int mdfld_dpu_update_fb(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct psb_intel_crtc *psb_crtc;\r\nstruct mdfld_dsi_dbi_output **dbi_output;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nbool pipe_updated[2];\r\nunsigned long irq_flags;\r\nu32 dpll_reg = MRST_DPLL_A;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dsplinoff_reg = DSPALINOFF;\r\nu32 dspsurf_reg = DSPASURF;\r\nu32 mipi_state_reg = MIPIA_INTR_STAT_REG;\r\nu32 reg_offset = 0;\r\nint pipe;\r\nint i;\r\nint ret;\r\ndbi_output = dpu_info->dbi_outputs;\r\npipe_updated[0] = pipe_updated[1] = false;\r\nif (!gma_power_begin(dev, true))\r\nreturn -EAGAIN;\r\nif (!spin_trylock_irqsave(&dpu_info->dpu_update_lock, irq_flags))\r\nreturn -EAGAIN;\r\nfor (i = 0; i < dpu_info->dbi_output_num; i++) {\r\ncrtc = dbi_output[i]->base.base.crtc;\r\npsb_crtc = (crtc) ? to_psb_intel_crtc(crtc) : NULL;\r\npipe = dbi_output[i]->channel_num ? 2 : 0;\r\nif (pipe == 2) {\r\ndspcntr_reg = DSPCCNTR;\r\npipeconf_reg = PIPECCONF;\r\ndsplinoff_reg = DSPCLINOFF;\r\ndspsurf_reg = DSPCSURF;\r\nreg_offset = MIPIC_REG_OFFSET;\r\n}\r\nif (!(REG_READ((MIPIA_GEN_FIFO_STAT_REG + reg_offset))\r\n& (1 << 27)) ||\r\n!(REG_READ(dpll_reg) & DPLL_VCO_ENABLE) ||\r\n!(REG_READ(dspcntr_reg) & DISPLAY_PLANE_ENABLE) ||\r\n!(REG_READ(pipeconf_reg) & DISPLAY_PLANE_ENABLE)) {\r\ndev_err(dev->dev,\r\n"DBI FIFO is busy, DSI %d state %x\n",\r\npipe,\r\nREG_READ(mipi_state_reg + reg_offset));\r\ncontinue;\r\n}\r\nif (dbi_output[i]->dbi_panel_on &&\r\n!(dbi_output[i]->mode_flags & MODE_SETTING_ON_GOING) &&\r\n!(psb_crtc &&\r\npsb_crtc->mode_flags & MODE_SETTING_ON_GOING) &&\r\n!(dbi_output[i]->mode_flags & MODE_SETTING_IN_DSR)) {\r\nret = mdfld_dpu_update_pipe(dbi_output[i],\r\ndpu_info, dbi_output[i]->channel_num ? 2 : 0);\r\nif (!ret)\r\npipe_updated[i] = true;\r\n}\r\n}\r\nfor (i = 0; i < dpu_info->dbi_output_num; i++)\r\nif (pipe_updated[i])\r\nmdfld_dbi_flush_cb(dbi_output[i],\r\ndbi_output[i]->channel_num ? 2 : 0);\r\nspin_unlock_irqrestore(&dpu_info->dpu_update_lock, irq_flags);\r\ngma_power_end(dev);\r\nreturn 0;\r\n}\r\nstatic int __mdfld_dbi_exit_dsr(struct mdfld_dsi_dbi_output *dbi_output,\r\nint pipe)\r\n{\r\nstruct drm_device *dev = dbi_output->dev;\r\nstruct drm_crtc *crtc = dbi_output->base.base.crtc;\r\nstruct psb_intel_crtc *psb_crtc = (crtc) ? to_psb_intel_crtc(crtc)\r\n: NULL;\r\nu32 reg_val;\r\nu32 dpll_reg = MRST_DPLL_A;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 dspbase_reg = DSPABASE;\r\nu32 dspsurf_reg = DSPASURF;\r\nu32 reg_offset = 0;\r\nif (!dbi_output)\r\nreturn 0;\r\nif ((dbi_output->mode_flags & MODE_SETTING_ON_GOING) ||\r\n(psb_crtc && psb_crtc->mode_flags & MODE_SETTING_ON_GOING))\r\nreturn -EAGAIN;\r\nif (pipe == 2) {\r\ndpll_reg = MRST_DPLL_A;\r\npipeconf_reg = PIPECCONF;\r\ndspcntr_reg = DSPCCNTR;\r\ndspbase_reg = MDFLD_DSPCBASE;\r\ndspsurf_reg = DSPCSURF;\r\nreg_offset = MIPIC_REG_OFFSET;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn -EAGAIN;\r\nreg_val = REG_READ(dpll_reg);\r\nif (!(reg_val & DPLL_VCO_ENABLE)) {\r\nif (reg_val & MDFLD_PWR_GATE_EN) {\r\nreg_val &= ~MDFLD_PWR_GATE_EN;\r\nREG_WRITE(dpll_reg, reg_val);\r\nREG_READ(dpll_reg);\r\nudelay(500);\r\n}\r\nreg_val |= DPLL_VCO_ENABLE;\r\nREG_WRITE(dpll_reg, reg_val);\r\nREG_READ(dpll_reg);\r\nudelay(500);\r\nwhile (!(REG_READ(pipeconf_reg) & PIPECONF_DSIPLL_LOCK))\r\ncpu_relax();\r\n}\r\nreg_val = REG_READ(pipeconf_reg);\r\nif (!(reg_val & PIPEACONF_ENABLE)) {\r\nreg_val |= PIPEACONF_ENABLE;\r\nREG_WRITE(pipeconf_reg, reg_val);\r\nREG_READ(pipeconf_reg);\r\nudelay(500);\r\nmdfldWaitForPipeEnable(dev, pipe);\r\n}\r\nreg_val = REG_READ(dspcntr_reg);\r\nif (!(reg_val & DISPLAY_PLANE_ENABLE)) {\r\nreg_val |= DISPLAY_PLANE_ENABLE;\r\nREG_WRITE(dspcntr_reg, reg_val);\r\nREG_READ(dspcntr_reg);\r\nudelay(500);\r\n}\r\ngma_power_end(dev);\r\ndbi_output->mode_flags &= ~MODE_SETTING_IN_DSR;\r\nreturn 0;\r\n}\r\nint mdfld_dpu_exit_dsr(struct drm_device *dev)\r\n{\r\nstruct mdfld_dsi_dbi_output **dbi_output;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nint i;\r\nint pipe;\r\ndbi_output = dpu_info->dbi_outputs;\r\nfor (i = 0; i < dpu_info->dbi_output_num; i++) {\r\nif (dbi_output[i]->mode_flags & MODE_SETTING_IN_DSR)\r\n__mdfld_dbi_exit_dsr(dbi_output[i],\r\ndbi_output[i]->channel_num ? 2 : 0);\r\n}\r\nfor (i = 0; i < dpu_info->dbi_output_num; i++) {\r\npipe = dbi_output[i]->channel_num ? 2 : 0;\r\nif (dbi_output[i]->dbi_panel_on && pipe) {\r\nmdfld_disable_te(dev, 0);\r\nmdfld_enable_te(dev, 2);\r\n} else if (dbi_output[i]->dbi_panel_on && !pipe) {\r\nmdfld_disable_te(dev, 2);\r\nmdfld_enable_te(dev, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mdfld_dpu_enter_dsr(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nstruct mdfld_dsi_dbi_output **dbi_output;\r\nint i;\r\ndbi_output = dpu_info->dbi_outputs;\r\nfor (i = 0; i < dpu_info->dbi_output_num; i++) {\r\nif (dbi_output[i]->dbi_panel_on &&\r\n!(dbi_output[i]->mode_flags & MODE_SETTING_IN_DSR)) {\r\nmdfld_dsi_dbi_enter_dsr(dbi_output[i],\r\ndbi_output[i]->channel_num ? 2 : 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mdfld_dbi_dpu_timer_func(unsigned long data)\r\n{\r\nstruct drm_device *dev = (struct drm_device *)data;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nstruct timer_list *dpu_timer = &dpu_info->dpu_timer;\r\nunsigned long flags;\r\nif (dpu_info->pending) {\r\ndpu_info->idle_count = 0;\r\nmdfld_dpu_update_fb(dev);\r\n} else {\r\ndpu_info->idle_count++;\r\n}\r\nif (dpu_info->idle_count >= MDFLD_MAX_IDLE_COUNT) {\r\nmdfld_dpu_enter_dsr(dev);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dpu_info->dpu_timer_lock, flags);\r\nif (!timer_pending(dpu_timer)) {\r\ndpu_timer->expires = jiffies + MDFLD_DSR_DELAY;\r\nadd_timer(dpu_timer);\r\n}\r\nspin_unlock_irqrestore(&dpu_info->dpu_timer_lock, flags);\r\n}\r\nvoid mdfld_dpu_update_panel(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nif (dpu_info->pending) {\r\ndpu_info->idle_count = 0;\r\nmdfld_dpu_update_fb(dev);\r\n} else {\r\ndpu_info->idle_count++;\r\n}\r\nif (dpu_info->idle_count >= MDFLD_MAX_IDLE_COUNT) {\r\nmdfld_dpu_enter_dsr(dev);\r\n}\r\n}\r\nstatic int mdfld_dbi_dpu_timer_init(struct drm_device *dev,\r\nstruct mdfld_dbi_dpu_info *dpu_info)\r\n{\r\nstruct timer_list *dpu_timer = &dpu_info->dpu_timer;\r\nunsigned long flags;\r\nspin_lock_init(&dpu_info->dpu_timer_lock);\r\nspin_lock_irqsave(&dpu_info->dpu_timer_lock, flags);\r\ninit_timer(dpu_timer);\r\ndpu_timer->data = (unsigned long)dev;\r\ndpu_timer->function = mdfld_dbi_dpu_timer_func;\r\ndpu_timer->expires = jiffies + MDFLD_DSR_DELAY;\r\nspin_unlock_irqrestore(&dpu_info->dpu_timer_lock, flags);\r\nreturn 0;\r\n}\r\nvoid mdfld_dbi_dpu_timer_start(struct mdfld_dbi_dpu_info *dpu_info)\r\n{\r\nstruct timer_list *dpu_timer = &dpu_info->dpu_timer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dpu_info->dpu_timer_lock, flags);\r\nif (!timer_pending(dpu_timer)) {\r\ndpu_timer->expires = jiffies + MDFLD_DSR_DELAY;\r\nadd_timer(dpu_timer);\r\n}\r\nspin_unlock_irqrestore(&dpu_info->dpu_timer_lock, flags);\r\n}\r\nint mdfld_dbi_dpu_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nif (!dpu_info || IS_ERR(dpu_info)) {\r\ndpu_info = kzalloc(sizeof(struct mdfld_dbi_dpu_info),\r\nGFP_KERNEL);\r\nif (!dpu_info) {\r\nDRM_ERROR("No memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_priv->dbi_dpu_info = dpu_info;\r\n}\r\ndpu_info->dev = dev;\r\ndpu_info->cursors[0].size = MDFLD_CURSOR_SIZE;\r\ndpu_info->cursors[1].size = MDFLD_CURSOR_SIZE;\r\nspin_lock_init(&dpu_info->dpu_update_lock);\r\nmdfld_dbi_dpu_timer_init(dev, dpu_info);\r\nmdfld_dpu_init_damage(dpu_info, 0);\r\nmdfld_dpu_init_damage(dpu_info, 2);\r\nreturn 0;\r\n}\r\nvoid mdfld_dbi_dpu_exit(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dbi_dpu_info *dpu_info = dev_priv->dbi_dpu_info;\r\nif (!dpu_info)\r\nreturn;\r\ndel_timer_sync(&dpu_info->dpu_timer);\r\nkfree(dpu_info);\r\ndev_priv->dbi_dpu_info = NULL;\r\n}
