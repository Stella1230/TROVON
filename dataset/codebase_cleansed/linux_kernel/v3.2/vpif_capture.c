static inline u32 vpif_uservirt_to_phys(u32 virtp)\r\n{\r\nunsigned long physp = 0;\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nvma = find_vma(mm, virtp);\r\nif (virtp >= PAGE_OFFSET)\r\nphysp = virt_to_phys((void *)virtp);\r\nelse if (vma && (vma->vm_flags & VM_IO) && (vma->vm_pgoff))\r\nphysp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);\r\nelse {\r\nint res, nr_pages = 1;\r\nstruct page *pages;\r\ndown_read(&current->mm->mmap_sem);\r\nres = get_user_pages(current, current->mm,\r\nvirtp, nr_pages, 1, 0, &pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (res == nr_pages)\r\nphysp = __pa(page_address(&pages[0]) +\r\n(virtp & ~PAGE_MASK));\r\nelse {\r\nvpif_err("get_user_pages failed\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn physp;\r\n}\r\nstatic int vpif_buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nunsigned long addr;\r\nvpif_dbg(2, debug, "vpif_buffer_prepare\n");\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nvb->width = common->width;\r\nvb->height = common->height;\r\nvb->size = vb->width * vb->height;\r\nvb->field = field;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nif (V4L2_MEMORY_USERPTR == common->memory) {\r\nif (0 == vb->baddr) {\r\nvpif_dbg(1, debug, "buffer address is 0\n");\r\nreturn -EINVAL;\r\n}\r\nvb->boff = vpif_uservirt_to_phys(vb->baddr);\r\nif (!IS_ALIGNED(vb->boff, 8))\r\ngoto exit;\r\n}\r\naddr = vb->boff;\r\nif (q->streaming) {\r\nif (!IS_ALIGNED((addr + common->ytop_off), 8) ||\r\n!IS_ALIGNED((addr + common->ybtm_off), 8) ||\r\n!IS_ALIGNED((addr + common->ctop_off), 8) ||\r\n!IS_ALIGNED((addr + common->cbtm_off), 8))\r\ngoto exit;\r\n}\r\nreturn 0;\r\nexit:\r\nvpif_dbg(1, debug, "buffer_prepare:offset is not aligned to 8 bytes\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_buffer_setup(struct videobuf_queue *q, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvpif_dbg(2, debug, "vpif_buffer_setup\n");\r\nif (V4L2_MEMORY_MMAP != common->memory)\r\nreturn 0;\r\n*size = config_params.channel_bufsize[ch->channel_id];\r\nif (*count < config_params.min_numbuffers)\r\n*count = config_params.min_numbuffers;\r\nreturn 0;\r\n}\r\nstatic void vpif_buffer_queue(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvpif_dbg(2, debug, "vpif_buffer_queue\n");\r\nlist_add_tail(&vb->queue, &common->dma_queue);\r\nvb->state = VIDEOBUF_QUEUED;\r\n}\r\nstatic void vpif_buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpif_fh *fh = q->priv_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvideobuf_dma_contig_free(q, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic void vpif_process_buffer_complete(struct common_obj *common)\r\n{\r\ndo_gettimeofday(&common->cur_frm->ts);\r\ncommon->cur_frm->state = VIDEOBUF_DONE;\r\nwake_up_interruptible(&common->cur_frm->done);\r\ncommon->cur_frm = common->next_frm;\r\n}\r\nstatic void vpif_schedule_next_buffer(struct common_obj *common)\r\n{\r\nunsigned long addr = 0;\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nlist_del(&common->next_frm->queue);\r\ncommon->next_frm->state = VIDEOBUF_ACTIVE;\r\nif (V4L2_MEMORY_USERPTR == common->memory)\r\naddr = common->next_frm->boff;\r\nelse\r\naddr = videobuf_to_dma_contig(common->next_frm);\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\n}\r\nstatic irqreturn_t vpif_channel_isr(int irq, void *dev_id)\r\n{\r\nstruct vpif_device *dev = &vpif_obj;\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nenum v4l2_field field;\r\nint channel_id = 0;\r\nint fid = -1, i;\r\nchannel_id = *(int *)(dev_id);\r\nch = dev->dev[channel_id];\r\nfield = ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;\r\nfor (i = 0; i < VPIF_NUMBER_OF_OBJECTS; i++) {\r\ncommon = &ch->common[i];\r\nif (0 == common->started)\r\ncontinue;\r\nif (1 == ch->vpifparams.std_info.frm_fmt) {\r\nif (list_empty(&common->dma_queue))\r\ncontinue;\r\nif (!channel_first_int[i][channel_id])\r\nvpif_process_buffer_complete(common);\r\nchannel_first_int[i][channel_id] = 0;\r\nvpif_schedule_next_buffer(common);\r\nchannel_first_int[i][channel_id] = 0;\r\n} else {\r\nif (channel_first_int[i][channel_id]) {\r\nchannel_first_int[i][channel_id] = 0;\r\ncontinue;\r\n}\r\nif (0 == i) {\r\nch->field_id ^= 1;\r\nfid = vpif_channel_getfid(ch->channel_id);\r\nif (fid != ch->field_id) {\r\nif (0 == fid)\r\nch->field_id = fid;\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (0 == fid) {\r\nif (common->cur_frm == common->next_frm)\r\ncontinue;\r\nvpif_process_buffer_complete(common);\r\n} else if (1 == fid) {\r\nif (list_empty(&common->dma_queue) ||\r\n(common->cur_frm != common->next_frm))\r\ncontinue;\r\nvpif_schedule_next_buffer(common);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vpif_update_std_info(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nconst struct vpif_channel_config_params *config;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nstruct video_obj *vid_ch = &ch->video;\r\nint index;\r\nvpif_dbg(2, debug, "vpif_update_std_info\n");\r\nfor (index = 0; index < vpif_ch_params_count; index++) {\r\nconfig = &ch_params[index];\r\nif (config->hd_sd == 0) {\r\nvpif_dbg(2, debug, "SD format\n");\r\nif (config->stdid & vid_ch->stdid) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n} else {\r\nvpif_dbg(2, debug, "HD format\n");\r\nif (config->dv_preset == vid_ch->dv_preset) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n}\r\n}\r\nif (index == vpif_ch_params_count)\r\nreturn -EINVAL;\r\ncommon->fmt.fmt.pix.width = std_info->width;\r\ncommon->width = std_info->width;\r\ncommon->fmt.fmt.pix.height = std_info->height;\r\ncommon->height = std_info->height;\r\ncommon->fmt.fmt.pix.bytesperline = std_info->width;\r\nvpifparams->video_params.hpitch = std_info->width;\r\nvpifparams->video_params.storage_mode = std_info->frm_fmt;\r\nreturn 0;\r\n}\r\nstatic void vpif_calculate_offsets(struct channel_obj *ch)\r\n{\r\nunsigned int hpitch, vpitch, sizeimage;\r\nstruct video_obj *vid_ch = &(ch->video);\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nenum v4l2_field field = common->fmt.fmt.pix.field;\r\nvpif_dbg(2, debug, "vpif_calculate_offsets\n");\r\nif (V4L2_FIELD_ANY == field) {\r\nif (vpifparams->std_info.frm_fmt)\r\nvid_ch->buf_field = V4L2_FIELD_NONE;\r\nelse\r\nvid_ch->buf_field = V4L2_FIELD_INTERLACED;\r\n} else\r\nvid_ch->buf_field = common->fmt.fmt.pix.field;\r\nif (V4L2_MEMORY_USERPTR == common->memory)\r\nsizeimage = common->fmt.fmt.pix.sizeimage;\r\nelse\r\nsizeimage = config_params.channel_bufsize[ch->channel_id];\r\nhpitch = common->fmt.fmt.pix.bytesperline;\r\nvpitch = sizeimage / (hpitch * 2);\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = hpitch;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = sizeimage / 2 + hpitch;\r\n} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = sizeimage / 4;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = common->ctop_off + sizeimage / 4;\r\n} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {\r\ncommon->ybtm_off = 0;\r\ncommon->ytop_off = sizeimage / 4;\r\ncommon->cbtm_off = sizeimage / 2;\r\ncommon->ctop_off = common->cbtm_off + sizeimage / 4;\r\n}\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field))\r\nvpifparams->video_params.storage_mode = 1;\r\nelse\r\nvpifparams->video_params.storage_mode = 0;\r\nif (1 == vpifparams->std_info.frm_fmt)\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\nelse {\r\nif ((field == V4L2_FIELD_ANY)\r\n|| (field == V4L2_FIELD_INTERLACED))\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline * 2;\r\nelse\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n}\r\nch->vpifparams.video_params.stdid = vpifparams->std_info.stdid;\r\n}\r\nstatic void vpif_config_format(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nvpif_dbg(2, debug, "vpif_config_format\n");\r\ncommon->fmt.fmt.pix.field = V4L2_FIELD_ANY;\r\nif (config_params.numbuffers[ch->channel_id] == 0)\r\ncommon->memory = V4L2_MEMORY_USERPTR;\r\nelse\r\ncommon->memory = V4L2_MEMORY_MMAP;\r\ncommon->fmt.fmt.pix.sizeimage\r\n= config_params.channel_bufsize[ch->channel_id];\r\nif (ch->vpifparams.iface.if_type == VPIF_IF_RAW_BAYER)\r\ncommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;\r\nelse\r\ncommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;\r\ncommon->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\n}\r\nstatic inline enum v4l2_field vpif_get_default_field(\r\nstruct vpif_interface *iface)\r\n{\r\nreturn (iface->if_type == VPIF_IF_RAW_BAYER) ? V4L2_FIELD_NONE :\r\nV4L2_FIELD_INTERLACED;\r\n}\r\nstatic int vpif_check_format(struct channel_obj *ch,\r\nstruct v4l2_pix_format *pixfmt,\r\nint update)\r\n{\r\nstruct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);\r\nstruct vpif_params *vpif_params = &ch->vpifparams;\r\nenum v4l2_field field = pixfmt->field;\r\nu32 sizeimage, hpitch, vpitch;\r\nint ret = -EINVAL;\r\nvpif_dbg(2, debug, "vpif_check_format\n");\r\nif (vpif_params->iface.if_type == VPIF_IF_RAW_BAYER) {\r\nif (pixfmt->pixelformat != V4L2_PIX_FMT_SBGGR8) {\r\nif (!update) {\r\nvpif_dbg(2, debug, "invalid pix format\n");\r\ngoto exit;\r\n}\r\npixfmt->pixelformat = V4L2_PIX_FMT_SBGGR8;\r\n}\r\n} else {\r\nif (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P) {\r\nif (!update) {\r\nvpif_dbg(2, debug, "invalid pixel format\n");\r\ngoto exit;\r\n}\r\npixfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\r\n}\r\n}\r\nif (!(VPIF_VALID_FIELD(field))) {\r\nif (!update) {\r\nvpif_dbg(2, debug, "invalid field format\n");\r\ngoto exit;\r\n}\r\nfield = vpif_get_default_field(&vpif_params->iface);\r\n} else if (field == V4L2_FIELD_ANY)\r\nfield = vpif_get_default_field(&vpif_params->iface);\r\nhpitch = pixfmt->bytesperline;\r\nif (hpitch < vpif_params->std_info.width) {\r\nif (!update) {\r\nvpif_dbg(2, debug, "invalid hpitch\n");\r\ngoto exit;\r\n}\r\nhpitch = vpif_params->std_info.width;\r\n}\r\nif (V4L2_MEMORY_USERPTR == common->memory)\r\nsizeimage = pixfmt->sizeimage;\r\nelse\r\nsizeimage = config_params.channel_bufsize[ch->channel_id];\r\nvpitch = sizeimage / (hpitch * 2);\r\nif (vpitch < vpif_params->std_info.height) {\r\nif (!update) {\r\nvpif_dbg(2, debug, "Invalid vpitch\n");\r\ngoto exit;\r\n}\r\nvpitch = vpif_params->std_info.height;\r\n}\r\nif (!ALIGN(hpitch, 8)) {\r\nif (!update) {\r\nvpif_dbg(2, debug, "invalid pitch alignment\n");\r\ngoto exit;\r\n}\r\nhpitch = (((hpitch + 7) / 8) * 8);\r\n}\r\nif (update) {\r\npixfmt->bytesperline = hpitch;\r\npixfmt->sizeimage = hpitch * vpitch * 2;\r\n}\r\npixfmt->width = common->fmt.fmt.pix.width;\r\npixfmt->height = common->fmt.fmt.pix.height;\r\nreturn 0;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode)\r\n{\r\nstruct common_obj *common;\r\nvpif_dbg(2, debug, "vpif_config_addr\n");\r\ncommon = &(ch->common[VPIF_VIDEO_INDEX]);\r\nif (VPIF_CHANNEL1_VIDEO == ch->channel_id)\r\ncommon->set_addr = ch1_set_videobuf_addr;\r\nelse if (2 == muxmode)\r\ncommon->set_addr = ch0_set_videobuf_addr_yc_nmux;\r\nelse\r\ncommon->set_addr = ch0_set_videobuf_addr;\r\n}\r\nstatic int vpif_mmap(struct file *filep, struct vm_area_struct *vma)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);\r\nvpif_dbg(2, debug, "vpif_mmap\n");\r\nreturn videobuf_mmap_mapper(&common->buffer_queue, vma);\r\n}\r\nstatic unsigned int vpif_poll(struct file *filep, poll_table * wait)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *channel = fh->channel;\r\nstruct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);\r\nvpif_dbg(2, debug, "vpif_poll\n");\r\nif (common->started)\r\nreturn videobuf_poll_stream(filep, &common->buffer_queue, wait);\r\nreturn 0;\r\n}\r\nstatic int vpif_open(struct file *filep)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(filep);\r\nstruct common_obj *common;\r\nstruct video_obj *vid_ch;\r\nstruct channel_obj *ch;\r\nstruct vpif_fh *fh;\r\nint i;\r\nvpif_dbg(2, debug, "vpif_open\n");\r\nch = video_get_drvdata(vdev);\r\nvid_ch = &ch->video;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (NULL == ch->curr_subdev_info) {\r\nfor (i = 0; i < config->subdev_count; i++) {\r\nif (vpif_obj.sd[i]) {\r\nch->curr_subdev_info = &config->subdev_info[i];\r\nvid_ch->input_idx = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == config->subdev_count) {\r\nvpif_err("No sub device registered\n");\r\nreturn -ENOENT;\r\n}\r\n}\r\nfh = kzalloc(sizeof(struct vpif_fh), GFP_KERNEL);\r\nif (NULL == fh) {\r\nvpif_err("unable to allocate memory for file handle object\n");\r\nreturn -ENOMEM;\r\n}\r\nfilep->private_data = fh;\r\nfh->channel = ch;\r\nfh->initialized = 0;\r\nif (!ch->initialized) {\r\nfh->initialized = 1;\r\nch->initialized = 1;\r\nmemset(&(ch->vpifparams), 0, sizeof(struct vpif_params));\r\n}\r\nch->usrs++;\r\nfh->io_allowed[VPIF_VIDEO_INDEX] = 0;\r\nfh->prio = V4L2_PRIORITY_UNSET;\r\nv4l2_prio_open(&ch->prio, &fh->prio);\r\nreturn 0;\r\n}\r\nstatic int vpif_release(struct file *filep)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nvpif_dbg(2, debug, "vpif_release\n");\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\ncommon->io_usrs = 0;\r\nif (VPIF_CHANNEL0_VIDEO == ch->channel_id) {\r\nenable_channel0(0);\r\nchannel0_intr_enable(0);\r\n}\r\nif ((VPIF_CHANNEL1_VIDEO == ch->channel_id) ||\r\n(2 == common->started)) {\r\nenable_channel1(0);\r\nchannel1_intr_enable(0);\r\n}\r\ncommon->started = 0;\r\nvideobuf_queue_cancel(&common->buffer_queue);\r\nvideobuf_mmap_free(&common->buffer_queue);\r\n}\r\nch->usrs--;\r\nv4l2_prio_close(&ch->prio, fh->prio);\r\nif (fh->initialized)\r\nch->initialized = 0;\r\nfilep->private_data = NULL;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int vpif_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbuf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nu8 index = 0;\r\nvpif_dbg(2, debug, "vpif_reqbufs\n");\r\nif ((VPIF_CHANNEL0_VIDEO == ch->channel_id)\r\n|| (VPIF_CHANNEL1_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_dbg(1, debug, "Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != reqbuf->type)\r\nreturn -EINVAL;\r\nindex = VPIF_VIDEO_INDEX;\r\ncommon = &ch->common[index];\r\nif (0 != common->io_usrs)\r\nreturn -EBUSY;\r\nvideobuf_queue_dma_contig_init(&common->buffer_queue,\r\n&video_qops, NULL,\r\n&common->irqlock,\r\nreqbuf->type,\r\ncommon->fmt.fmt.pix.field,\r\nsizeof(struct videobuf_buffer), fh,\r\n&common->lock);\r\nfh->io_allowed[index] = 1;\r\ncommon->io_usrs = 1;\r\ncommon->memory = reqbuf->memory;\r\nINIT_LIST_HEAD(&common->dma_queue);\r\nreturn videobuf_reqbufs(&common->buffer_queue, reqbuf);\r\n}\r\nstatic int vpif_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nvpif_dbg(2, debug, "vpif_querybuf\n");\r\nif (common->fmt.type != buf->type)\r\nreturn -EINVAL;\r\nif (common->memory != V4L2_MEMORY_MMAP) {\r\nvpif_dbg(1, debug, "Invalid memory\n");\r\nreturn -EINVAL;\r\n}\r\nreturn videobuf_querybuf(&common->buffer_queue, buf);\r\n}\r\nstatic int vpif_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct v4l2_buffer tbuf = *buf;\r\nstruct videobuf_buffer *buf1;\r\nunsigned long addr = 0;\r\nunsigned long flags;\r\nint ret = 0;\r\nvpif_dbg(2, debug, "vpif_qbuf\n");\r\nif (common->fmt.type != tbuf.type) {\r\nvpif_err("invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_err("fh io not allowed \n");\r\nreturn -EACCES;\r\n}\r\nif (!(list_empty(&common->dma_queue)) ||\r\n(common->cur_frm != common->next_frm) ||\r\n!common->started ||\r\n(common->started && (0 == ch->field_id)))\r\nreturn videobuf_qbuf(&common->buffer_queue, buf);\r\nmutex_lock(&common->buffer_queue.vb_lock);\r\nbuf1 = common->buffer_queue.bufs[tbuf.index];\r\nif ((buf1->state == VIDEOBUF_QUEUED) ||\r\n(buf1->state == VIDEOBUF_ACTIVE)) {\r\nvpif_err("invalid state\n");\r\ngoto qbuf_exit;\r\n}\r\nswitch (buf1->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nif (buf1->baddr == 0)\r\ngoto qbuf_exit;\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\nif (tbuf.length < buf1->bsize)\r\ngoto qbuf_exit;\r\nif ((VIDEOBUF_NEEDS_INIT != buf1->state)\r\n&& (buf1->baddr != tbuf.m.userptr)) {\r\nvpif_buffer_release(&common->buffer_queue, buf1);\r\nbuf1->baddr = tbuf.m.userptr;\r\n}\r\nbreak;\r\ndefault:\r\ngoto qbuf_exit;\r\n}\r\nlocal_irq_save(flags);\r\nret = vpif_buffer_prepare(&common->buffer_queue, buf1,\r\ncommon->buffer_queue.field);\r\nif (ret < 0) {\r\nlocal_irq_restore(flags);\r\ngoto qbuf_exit;\r\n}\r\nbuf1->state = VIDEOBUF_ACTIVE;\r\nif (V4L2_MEMORY_USERPTR == common->memory)\r\naddr = buf1->boff;\r\nelse\r\naddr = videobuf_to_dma_contig(buf1);\r\ncommon->next_frm = buf1;\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\nlocal_irq_restore(flags);\r\nlist_add_tail(&buf1->stream, &common->buffer_queue.stream);\r\nmutex_unlock(&common->buffer_queue.vb_lock);\r\nreturn 0;\r\nqbuf_exit:\r\nmutex_unlock(&common->buffer_queue.vb_lock);\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nvpif_dbg(2, debug, "vpif_dqbuf\n");\r\nreturn videobuf_dqbuf(&common->buffer_queue, buf,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vpif_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct channel_obj *oth_ch = vpif_obj.dev[!ch->channel_id];\r\nstruct vpif_params *vpif;\r\nunsigned long addr = 0;\r\nint ret = 0;\r\nvpif_dbg(2, debug, "vpif_streamon\n");\r\nvpif = &ch->vpifparams;\r\nif (buftype != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nvpif_dbg(1, debug, "buffer type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_dbg(1, debug, "io not allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (common->started) {\r\nvpif_dbg(1, debug, "channel->started\n");\r\nreturn -EBUSY;\r\n}\r\nif ((ch->channel_id == VPIF_CHANNEL0_VIDEO &&\r\noth_ch->common[VPIF_VIDEO_INDEX].started &&\r\nvpif->std_info.ycmux_mode == 0) ||\r\n((ch->channel_id == VPIF_CHANNEL1_VIDEO) &&\r\n(2 == oth_ch->common[VPIF_VIDEO_INDEX].started))) {\r\nvpif_dbg(1, debug, "other channel is being used\n");\r\nreturn -EBUSY;\r\n}\r\nret = vpif_check_format(ch, &common->fmt.fmt.pix, 0);\r\nif (ret)\r\nreturn ret;\r\nret = v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index], video,\r\ns_stream, 1);\r\nif (ret && (ret != -ENOIOCTLCMD)) {\r\nvpif_dbg(1, debug, "stream on failed in subdev\n");\r\nreturn ret;\r\n}\r\nret = videobuf_streamon(&common->buffer_queue);\r\nif (ret) {\r\nvpif_dbg(1, debug, "videobuf_streamon\n");\r\nreturn ret;\r\n}\r\nif (list_empty(&common->dma_queue)) {\r\nvpif_dbg(1, debug, "buffer queue is empty\n");\r\nret = -EIO;\r\ngoto exit;\r\n}\r\ncommon->cur_frm = list_entry(common->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\ncommon->next_frm = common->cur_frm;\r\nlist_del(&common->cur_frm->queue);\r\ncommon->cur_frm->state = VIDEOBUF_ACTIVE;\r\nch->field_id = 0;\r\ncommon->started = 1;\r\nif (V4L2_MEMORY_USERPTR == common->memory)\r\naddr = common->cur_frm->boff;\r\nelse\r\naddr = videobuf_to_dma_contig(common->cur_frm);\r\nvpif_calculate_offsets(ch);\r\nif ((vpif->std_info.frm_fmt &&\r\n((common->fmt.fmt.pix.field != V4L2_FIELD_NONE) &&\r\n(common->fmt.fmt.pix.field != V4L2_FIELD_ANY))) ||\r\n(!vpif->std_info.frm_fmt &&\r\n(common->fmt.fmt.pix.field == V4L2_FIELD_NONE))) {\r\nvpif_dbg(1, debug, "conflict in field format and std format\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nret = config->setup_input_channel_mode(vpif->std_info.ycmux_mode);\r\nif (ret < 0) {\r\nvpif_dbg(1, debug, "can't set vpif channel mode\n");\r\ngoto exit;\r\n}\r\nret = vpif_set_video_params(vpif, ch->channel_id);\r\nif (ret < 0) {\r\nvpif_dbg(1, debug, "can't set video params\n");\r\ngoto exit;\r\n}\r\ncommon->started = ret;\r\nvpif_config_addr(ch, ret);\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\nif ((VPIF_CHANNEL0_VIDEO == ch->channel_id)) {\r\nchannel0_intr_assert();\r\nchannel0_intr_enable(1);\r\nenable_channel0(1);\r\n}\r\nif ((VPIF_CHANNEL1_VIDEO == ch->channel_id) ||\r\n(common->started == 2)) {\r\nchannel1_intr_assert();\r\nchannel1_intr_enable(1);\r\nenable_channel1(1);\r\n}\r\nchannel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;\r\nreturn ret;\r\nexit:\r\nvideobuf_streamoff(&common->buffer_queue);\r\nreturn ret;\r\n}\r\nstatic int vpif_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret;\r\nvpif_dbg(2, debug, "vpif_streamoff\n");\r\nif (buftype != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nvpif_dbg(1, debug, "buffer type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_dbg(1, debug, "io not allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (!common->started) {\r\nvpif_dbg(1, debug, "channel->started\n");\r\nreturn -EINVAL;\r\n}\r\nif (VPIF_CHANNEL0_VIDEO == ch->channel_id) {\r\nenable_channel0(0);\r\nchannel0_intr_enable(0);\r\n} else {\r\nenable_channel1(0);\r\nchannel1_intr_enable(0);\r\n}\r\ncommon->started = 0;\r\nret = v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index], video,\r\ns_stream, 0);\r\nif (ret && (ret != -ENOIOCTLCMD))\r\nvpif_dbg(1, debug, "stream off failed in subdev\n");\r\nreturn videobuf_streamoff(&common->buffer_queue);\r\n}\r\nstatic struct vpif_subdev_info *vpif_map_sub_device_to_input(\r\nstruct channel_obj *ch,\r\nstruct vpif_capture_config *vpif_cfg,\r\nint input_index,\r\nint *sub_device_index)\r\n{\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct vpif_subdev_info *subdev_info = NULL;\r\nconst char *subdev_name = NULL;\r\nint i;\r\nvpif_dbg(2, debug, "vpif_map_sub_device_to_input\n");\r\nchan_cfg = &vpif_cfg->chan_config[ch->channel_id];\r\nfor (i = 0; i < chan_cfg->input_count; i++) {\r\nif (i == input_index) {\r\nsubdev_name = chan_cfg->inputs[i].subdev_name;\r\nbreak;\r\n}\r\n}\r\nif (i == chan_cfg->input_count || (NULL == subdev_name))\r\nreturn subdev_info;\r\nfor (i = 0; i < vpif_cfg->subdev_count; i++) {\r\nsubdev_info = &vpif_cfg->subdev_info[i];\r\nif (!strcmp(subdev_info->name, subdev_name))\r\nbreak;\r\n}\r\nif (i == vpif_cfg->subdev_count)\r\nreturn subdev_info;\r\nif (NULL == vpif_obj.sd[i])\r\nreturn NULL;\r\n*sub_device_index = i;\r\nreturn subdev_info;\r\n}\r\nstatic int vpif_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nint ret = 0;\r\nvpif_dbg(2, debug, "vpif_querystd\n");\r\nret = v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index], video,\r\nquerystd, std_id);\r\nif (ret < 0)\r\nvpif_dbg(1, debug, "Failed to set standard for sub devices\n");\r\nreturn ret;\r\n}\r\nstatic int vpif_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nvpif_dbg(2, debug, "vpif_g_std\n");\r\n*std = ch->video.stdid;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_std(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret = 0;\r\nvpif_dbg(2, debug, "vpif_s_std\n");\r\nif (common->started) {\r\nvpif_err("streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif ((VPIF_CHANNEL0_VIDEO == ch->channel_id) ||\r\n(VPIF_CHANNEL1_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_dbg(1, debug, "Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nret = v4l2_prio_check(&ch->prio, fh->prio);\r\nif (0 != ret)\r\nreturn ret;\r\nfh->initialized = 1;\r\nch->video.stdid = *std_id;\r\nch->video.dv_preset = V4L2_DV_INVALID;\r\nmemset(&ch->video.bt_timings, 0, sizeof(ch->video.bt_timings));\r\nif (vpif_update_std_info(ch)) {\r\nvpif_err("Error getting the standard info\n");\r\nreturn -EINVAL;\r\n}\r\nvpif_config_format(ch);\r\nret = v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index], core,\r\ns_std, *std_id);\r\nif (ret < 0)\r\nvpif_dbg(1, debug, "Failed to set standard for sub devices\n");\r\nreturn ret;\r\n}\r\nstatic int vpif_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (input->index >= chan_cfg->input_count) {\r\nvpif_dbg(1, debug, "Invalid input index\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(input, &chan_cfg->inputs[input->index].input,\r\nsizeof(*input));\r\nreturn 0;\r\n}\r\nstatic int vpif_g_input(struct file *file, void *priv, unsigned int *index)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\n*index = vid_ch->input_idx;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\nstruct vpif_capture_chan_config *chan_cfg;\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_subdev_info *subdev_info;\r\nint ret = 0, sd_index = 0;\r\nu32 input = 0, output = 0;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (common->started) {\r\nvpif_err("Streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif ((VPIF_CHANNEL0_VIDEO == ch->channel_id) ||\r\n(VPIF_CHANNEL1_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_dbg(1, debug, "Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nret = v4l2_prio_check(&ch->prio, fh->prio);\r\nif (0 != ret)\r\nreturn ret;\r\nfh->initialized = 1;\r\nsubdev_info = vpif_map_sub_device_to_input(ch, config, index,\r\n&sd_index);\r\nif (NULL == subdev_info) {\r\nvpif_dbg(1, debug,\r\n"couldn't lookup sub device for the input index\n");\r\nreturn -EINVAL;\r\n}\r\nif (config->setup_input_path) {\r\nret = config->setup_input_path(ch->channel_id,\r\nsubdev_info->name);\r\nif (ret < 0) {\r\nvpif_dbg(1, debug, "couldn't setup input path for the"\r\n" sub device %s, for input index %d\n",\r\nsubdev_info->name, index);\r\nreturn ret;\r\n}\r\n}\r\nif (subdev_info->can_route) {\r\ninput = subdev_info->input;\r\noutput = subdev_info->output;\r\nret = v4l2_subdev_call(vpif_obj.sd[sd_index], video, s_routing,\r\ninput, output, 0);\r\nif (ret < 0) {\r\nvpif_dbg(1, debug, "Failed to set input\n");\r\nreturn ret;\r\n}\r\n}\r\nvid_ch->input_idx = index;\r\nch->curr_subdev_info = subdev_info;\r\nch->curr_sd_index = sd_index;\r\nch->vpifparams.iface = subdev_info->vpif_if;\r\nch->video_dev->tvnorms = chan_cfg->inputs[index].input.std;\r\nreturn ret;\r\n}\r\nstatic int vpif_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nif (fmt->index != 0) {\r\nvpif_dbg(1, debug, "Invalid format index\n");\r\nreturn -EINVAL;\r\n}\r\nif (ch->vpifparams.iface.if_type == VPIF_IF_RAW_BAYER) {\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrcpy(fmt->description, "Raw Mode -Bayer Pattern GrRBGb");\r\nfmt->pixelformat = V4L2_PIX_FMT_SBGGR8;\r\n} else {\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrcpy(fmt->description, "YCbCr4:2:2 YC Planar");\r\nfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nreturn vpif_check_format(ch, pixfmt, 1);\r\n}\r\nstatic int vpif_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->fmt.type != fmt->type)\r\nreturn -EINVAL;\r\n*fmt = common->fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct v4l2_pix_format *pixfmt;\r\nint ret = 0;\r\nvpif_dbg(2, debug, "%s\n", __func__);\r\nif (common->started) {\r\nvpif_dbg(1, debug, "Streaming is started\n");\r\nreturn -EBUSY;\r\n}\r\nif ((VPIF_CHANNEL0_VIDEO == ch->channel_id) ||\r\n(VPIF_CHANNEL1_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_dbg(1, debug, "Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nret = v4l2_prio_check(&ch->prio, fh->prio);\r\nif (0 != ret)\r\nreturn ret;\r\nfh->initialized = 1;\r\npixfmt = &fmt->fmt.pix;\r\nret = vpif_check_format(ch, pixfmt, 0);\r\nif (ret)\r\nreturn ret;\r\ncommon->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpif_capture_config *config = vpif_dev->platform_data;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nstrlcpy(cap->driver, "vpif capture", sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, "DM646x Platform", sizeof(cap->bus_info));\r\nstrlcpy(cap->card, config->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpif_g_priority(struct file *file, void *priv,\r\nenum v4l2_priority *prio)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\n*prio = v4l2_prio_max(&ch->prio);\r\nreturn 0;\r\n}\r\nstatic int vpif_s_priority(struct file *file, void *priv, enum v4l2_priority p)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nreturn v4l2_prio_change(&ch->prio, &fh->prio, p);\r\n}\r\nstatic int vpif_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *crop)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != crop->type)\r\nreturn -EINVAL;\r\ncrop->bounds.left = 0;\r\ncrop->bounds.top = 0;\r\ncrop->bounds.height = common->height;\r\ncrop->bounds.width = common->width;\r\ncrop->defrect = crop->bounds;\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_dv_presets(struct file *file, void *priv,\r\nstruct v4l2_dv_enum_preset *preset)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nreturn v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index],\r\nvideo, enum_dv_presets, preset);\r\n}\r\nstatic int vpif_query_dv_preset(struct file *file, void *priv,\r\nstruct v4l2_dv_preset *preset)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nreturn v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index],\r\nvideo, query_dv_preset, preset);\r\n}\r\nstatic int vpif_s_dv_preset(struct file *file, void *priv,\r\nstruct v4l2_dv_preset *preset)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret = 0;\r\nif (common->started) {\r\nvpif_dbg(1, debug, "streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif ((VPIF_CHANNEL0_VIDEO == ch->channel_id) ||\r\n(VPIF_CHANNEL1_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_dbg(1, debug, "Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nret = v4l2_prio_check(&ch->prio, fh->prio);\r\nif (ret)\r\nreturn ret;\r\nfh->initialized = 1;\r\nif (mutex_lock_interruptible(&common->lock))\r\nreturn -ERESTARTSYS;\r\nch->video.dv_preset = preset->preset;\r\nch->video.stdid = V4L2_STD_UNKNOWN;\r\nmemset(&ch->video.bt_timings, 0, sizeof(ch->video.bt_timings));\r\nif (vpif_update_std_info(ch)) {\r\nvpif_dbg(1, debug, "Error getting the standard info\n");\r\nret = -EINVAL;\r\n} else {\r\nvpif_config_format(ch);\r\nret = v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index],\r\nvideo, s_dv_preset, preset);\r\n}\r\nmutex_unlock(&common->lock);\r\nreturn ret;\r\n}\r\nstatic int vpif_g_dv_preset(struct file *file, void *priv,\r\nstruct v4l2_dv_preset *preset)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\npreset->preset = ch->video.dv_preset;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_bt_timings *bt = &vid_ch->bt_timings;\r\nint ret;\r\nif (timings->type != V4L2_DV_BT_656_1120) {\r\nvpif_dbg(2, debug, "Timing type not defined\n");\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index],\r\nvideo, s_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD) {\r\nvpif_dbg(2, debug, "Custom DV timings not supported by "\r\n"subdevice\n");\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0) {\r\nvpif_dbg(2, debug, "Error setting custom DV timings\n");\r\nreturn ret;\r\n}\r\nif (!(timings->bt.width && timings->bt.height &&\r\n(timings->bt.hbackporch ||\r\ntimings->bt.hfrontporch ||\r\ntimings->bt.hsync) &&\r\ntimings->bt.vfrontporch &&\r\n(timings->bt.vbackporch ||\r\ntimings->bt.vsync))) {\r\nvpif_dbg(2, debug, "Timings for width, height, "\r\n"horizontal back porch, horizontal sync, "\r\n"horizontal front porch, vertical back porch, "\r\n"vertical sync and vertical back porch "\r\n"must be defined\n");\r\nreturn -EINVAL;\r\n}\r\n*bt = timings->bt;\r\nstd_info->eav2sav = bt->hbackporch + bt->hfrontporch +\r\nbt->hsync - 8;\r\nstd_info->sav2eav = bt->width;\r\nstd_info->l1 = 1;\r\nstd_info->l3 = bt->vsync + bt->vbackporch + 1;\r\nif (bt->interlaced) {\r\nif (bt->il_vbackporch || bt->il_vfrontporch || bt->il_vsync) {\r\nstd_info->vsize = bt->height * 2 +\r\nbt->vfrontporch + bt->vsync + bt->vbackporch +\r\nbt->il_vfrontporch + bt->il_vsync +\r\nbt->il_vbackporch;\r\nstd_info->l5 = std_info->vsize/2 -\r\n(bt->vfrontporch - 1);\r\nstd_info->l7 = std_info->vsize/2 + 1;\r\nstd_info->l9 = std_info->l7 + bt->il_vsync +\r\nbt->il_vbackporch + 1;\r\nstd_info->l11 = std_info->vsize -\r\n(bt->il_vfrontporch - 1);\r\n} else {\r\nvpif_dbg(2, debug, "Required timing values for "\r\n"interlaced BT format missing\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nstd_info->vsize = bt->height + bt->vfrontporch +\r\nbt->vsync + bt->vbackporch;\r\nstd_info->l5 = std_info->vsize - (bt->vfrontporch - 1);\r\n}\r\nstrncpy(std_info->name, "Custom timings BT656/1120", VPIF_MAX_NAME);\r\nstd_info->width = bt->width;\r\nstd_info->height = bt->height;\r\nstd_info->frm_fmt = bt->interlaced ? 0 : 1;\r\nstd_info->ycmux_mode = 0;\r\nstd_info->capture_format = 0;\r\nstd_info->vbi_supported = 0;\r\nstd_info->hd_sd = 1;\r\nstd_info->stdid = 0;\r\nstd_info->dv_preset = V4L2_DV_INVALID;\r\nvid_ch->stdid = 0;\r\nvid_ch->dv_preset = V4L2_DV_INVALID;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_bt_timings *bt = &vid_ch->bt_timings;\r\ntimings->bt = *bt;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_chip_ident(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nchip->ident = V4L2_IDENT_NONE;\r\nchip->revision = 0;\r\nif (chip->match.type != V4L2_CHIP_MATCH_I2C_DRIVER &&\r\nchip->match.type != V4L2_CHIP_MATCH_I2C_ADDR) {\r\nvpif_dbg(2, debug, "match_type is invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 0, core,\r\ng_chip_ident, chip);\r\n}\r\nstatic int vpif_dbg_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg){\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nreturn v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index], core,\r\ng_register, reg);\r\n}\r\nstatic int vpif_dbg_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg){\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nreturn v4l2_subdev_call(vpif_obj.sd[ch->curr_sd_index], core,\r\ns_register, reg);\r\n}\r\nstatic int vpif_log_status(struct file *filep, void *priv)\r\n{\r\nv4l2_device_call_all(&vpif_obj.v4l2_dev, 0, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int initialize_vpif(void)\r\n{\r\nint err = 0, i, j;\r\nint free_channel_objects_index;\r\nif ((ch0_numbuffers > 0) &&\r\n(ch0_numbuffers < config_params.min_numbuffers))\r\nch0_numbuffers = config_params.min_numbuffers;\r\nif ((ch1_numbuffers > 0) &&\r\n(ch1_numbuffers < config_params.min_numbuffers))\r\nch1_numbuffers = config_params.min_numbuffers;\r\nif (ch0_bufsize < config_params.min_bufsize[VPIF_CHANNEL0_VIDEO])\r\nch0_bufsize =\r\nconfig_params.min_bufsize[VPIF_CHANNEL0_VIDEO];\r\nif (ch1_bufsize < config_params.min_bufsize[VPIF_CHANNEL1_VIDEO])\r\nch1_bufsize =\r\nconfig_params.min_bufsize[VPIF_CHANNEL1_VIDEO];\r\nconfig_params.numbuffers[VPIF_CHANNEL0_VIDEO] = ch0_numbuffers;\r\nconfig_params.numbuffers[VPIF_CHANNEL1_VIDEO] = ch1_numbuffers;\r\nif (ch0_numbuffers) {\r\nconfig_params.channel_bufsize[VPIF_CHANNEL0_VIDEO]\r\n= ch0_bufsize;\r\n}\r\nif (ch1_numbuffers) {\r\nconfig_params.channel_bufsize[VPIF_CHANNEL1_VIDEO]\r\n= ch1_bufsize;\r\n}\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\r\nvpif_obj.dev[i] =\r\nkzalloc(sizeof(*vpif_obj.dev[i]), GFP_KERNEL);\r\nif (!vpif_obj.dev[i]) {\r\nfree_channel_objects_index = i;\r\nerr = -ENOMEM;\r\ngoto vpif_init_free_channel_objects;\r\n}\r\n}\r\nreturn 0;\r\nvpif_init_free_channel_objects:\r\nfor (j = 0; j < free_channel_objects_index; j++)\r\nkfree(vpif_obj.dev[j]);\r\nreturn err;\r\n}\r\nstatic __init int vpif_probe(struct platform_device *pdev)\r\n{\r\nstruct vpif_subdev_info *subdevdata;\r\nstruct vpif_capture_config *config;\r\nint i, j, k, m, q, err;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct channel_obj *ch;\r\nstruct common_obj *common;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nint subdev_count;\r\nvpif_dev = &pdev->dev;\r\nerr = initialize_vpif();\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error initializing vpif\n");\r\nreturn err;\r\n}\r\nk = 0;\r\nwhile ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {\r\nfor (i = res->start; i <= res->end; i++) {\r\nif (request_irq(i, vpif_channel_isr, IRQF_DISABLED,\r\n"DM646x_Capture",\r\n(void *)(&vpif_obj.dev[k]->channel_id))) {\r\nerr = -EBUSY;\r\ni--;\r\ngoto vpif_int_err;\r\n}\r\n}\r\nk++;\r\n}\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvfd = video_device_alloc();\r\nif (NULL == vfd) {\r\nfor (j = 0; j < i; j++) {\r\nch = vpif_obj.dev[j];\r\nvideo_device_release(ch->video_dev);\r\n}\r\nerr = -ENOMEM;\r\ngoto vpif_dev_alloc_err;\r\n}\r\n*vfd = vpif_video_template;\r\nvfd->v4l2_dev = &vpif_obj.v4l2_dev;\r\nvfd->release = video_device_release;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"DM646x_VPIFCapture_DRIVER_V%s",\r\nVPIF_CAPTURE_VERSION);\r\nch->video_dev = vfd;\r\n}\r\nfor (j = 0; j < VPIF_CAPTURE_MAX_DEVICES; j++) {\r\nch = vpif_obj.dev[j];\r\nch->channel_id = j;\r\ncommon = &(ch->common[VPIF_VIDEO_INDEX]);\r\nspin_lock_init(&common->irqlock);\r\nmutex_init(&common->lock);\r\nch->video_dev->lock = &common->lock;\r\nv4l2_prio_init(&ch->prio);\r\nerr = video_register_device(ch->video_dev,\r\nVFL_TYPE_GRABBER, (j ? 1 : 0));\r\nif (err)\r\ngoto probe_out;\r\nvideo_set_drvdata(ch->video_dev, ch);\r\n}\r\ni2c_adap = i2c_get_adapter(1);\r\nconfig = pdev->dev.platform_data;\r\nsubdev_count = config->subdev_count;\r\nvpif_obj.sd = kzalloc(sizeof(struct v4l2_subdev *) * subdev_count,\r\nGFP_KERNEL);\r\nif (vpif_obj.sd == NULL) {\r\nvpif_err("unable to allocate memory for subdevice pointers\n");\r\nerr = -ENOMEM;\r\ngoto probe_out;\r\n}\r\nerr = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error registering v4l2 device\n");\r\ngoto probe_subdev_out;\r\n}\r\nfor (i = 0; i < subdev_count; i++) {\r\nsubdevdata = &config->subdev_info[i];\r\nvpif_obj.sd[i] =\r\nv4l2_i2c_new_subdev_board(&vpif_obj.v4l2_dev,\r\ni2c_adap,\r\n&subdevdata->board_info,\r\nNULL);\r\nif (!vpif_obj.sd[i]) {\r\nvpif_err("Error registering v4l2 subdevice\n");\r\ngoto probe_subdev_out;\r\n}\r\nv4l2_info(&vpif_obj.v4l2_dev, "registered sub device %s\n",\r\nsubdevdata->name);\r\nif (vpif_obj.sd[i])\r\nvpif_obj.sd[i]->grp_id = 1 << i;\r\n}\r\nv4l2_info(&vpif_obj.v4l2_dev,\r\n"DM646x VPIF capture driver initialized\n");\r\nreturn 0;\r\nprobe_subdev_out:\r\nkfree(vpif_obj.sd);\r\nj = VPIF_CAPTURE_MAX_DEVICES;\r\nprobe_out:\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nfor (k = 0; k < j; k++) {\r\nch = vpif_obj.dev[k];\r\nvideo_unregister_device(ch->video_dev);\r\n}\r\nvpif_dev_alloc_err:\r\nk = VPIF_CAPTURE_MAX_DEVICES-1;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, k);\r\ni = res->end;\r\nvpif_int_err:\r\nfor (q = k; q >= 0; q--) {\r\nfor (m = i; m >= (int)res->start; m--)\r\nfree_irq(m, (void *)(&vpif_obj.dev[q]->channel_id));\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, q-1);\r\nif (res)\r\ni = res->end;\r\n}\r\nreturn err;\r\n}\r\nstatic int vpif_remove(struct platform_device *device)\r\n{\r\nint i;\r\nstruct channel_obj *ch;\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvideo_unregister_device(ch->video_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvpif_suspend(struct device *dev)\r\n{\r\nreturn -1;\r\n}\r\nstatic int\r\nvpif_resume(struct device *dev)\r\n{\r\nreturn -1;\r\n}\r\nstatic __init int vpif_init(void)\r\n{\r\nreturn platform_driver_register(&vpif_driver);\r\n}\r\nstatic void vpif_cleanup(void)\r\n{\r\nstruct platform_device *pdev;\r\nstruct resource *res;\r\nint irq_num;\r\nint i = 0;\r\npdev = container_of(vpif_dev, struct platform_device, dev);\r\nwhile ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {\r\nfor (irq_num = res->start; irq_num <= res->end; irq_num++)\r\nfree_irq(irq_num,\r\n(void *)(&vpif_obj.dev[i]->channel_id));\r\ni++;\r\n}\r\nplatform_driver_unregister(&vpif_driver);\r\nkfree(vpif_obj.sd);\r\nfor (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++)\r\nkfree(vpif_obj.dev[i]);\r\n}
