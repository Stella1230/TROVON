static void *hw_qpageit_get_inc(struct hw_queue *queue)\r\n{\r\nvoid *retvalue = hw_qeit_get(queue);\r\nqueue->current_q_offset += queue->pagesize;\r\nif (queue->current_q_offset > queue->queue_length) {\r\nqueue->current_q_offset -= queue->pagesize;\r\nretvalue = NULL;\r\n} else if (((u64) retvalue) & (EHEA_PAGESIZE-1)) {\r\npr_err("not on pageboundary\n");\r\nretvalue = NULL;\r\n}\r\nreturn retvalue;\r\n}\r\nstatic int hw_queue_ctor(struct hw_queue *queue, const u32 nr_of_pages,\r\nconst u32 pagesize, const u32 qe_size)\r\n{\r\nint pages_per_kpage = PAGE_SIZE / pagesize;\r\nint i, k;\r\nif ((pagesize > PAGE_SIZE) || (!pages_per_kpage)) {\r\npr_err("pagesize conflict! kernel pagesize=%d, ehea pagesize=%d\n",\r\n(int)PAGE_SIZE, (int)pagesize);\r\nreturn -EINVAL;\r\n}\r\nqueue->queue_length = nr_of_pages * pagesize;\r\nqueue->queue_pages = kmalloc(nr_of_pages * sizeof(void *), GFP_KERNEL);\r\nif (!queue->queue_pages) {\r\npr_err("no mem for queue_pages\n");\r\nreturn -ENOMEM;\r\n}\r\ni = 0;\r\nwhile (i < nr_of_pages) {\r\nu8 *kpage = (u8 *)get_zeroed_page(GFP_KERNEL);\r\nif (!kpage)\r\ngoto out_nomem;\r\nfor (k = 0; k < pages_per_kpage && i < nr_of_pages; k++) {\r\n(queue->queue_pages)[i] = (struct ehea_page *)kpage;\r\nkpage += pagesize;\r\ni++;\r\n}\r\n}\r\nqueue->current_q_offset = 0;\r\nqueue->qe_size = qe_size;\r\nqueue->pagesize = pagesize;\r\nqueue->toggle_state = 1;\r\nreturn 0;\r\nout_nomem:\r\nfor (i = 0; i < nr_of_pages; i += pages_per_kpage) {\r\nif (!(queue->queue_pages)[i])\r\nbreak;\r\nfree_page((unsigned long)(queue->queue_pages)[i]);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void hw_queue_dtor(struct hw_queue *queue)\r\n{\r\nint pages_per_kpage = PAGE_SIZE / queue->pagesize;\r\nint i, nr_pages;\r\nif (!queue || !queue->queue_pages)\r\nreturn;\r\nnr_pages = queue->queue_length / queue->pagesize;\r\nfor (i = 0; i < nr_pages; i += pages_per_kpage)\r\nfree_page((unsigned long)(queue->queue_pages)[i]);\r\nkfree(queue->queue_pages);\r\n}\r\nstruct ehea_cq *ehea_create_cq(struct ehea_adapter *adapter,\r\nint nr_of_cqe, u64 eq_handle, u32 cq_token)\r\n{\r\nstruct ehea_cq *cq;\r\nstruct h_epa epa;\r\nu64 *cq_handle_ref, hret, rpage;\r\nu32 act_nr_of_entries, act_pages, counter;\r\nint ret;\r\nvoid *vpage;\r\ncq = kzalloc(sizeof(*cq), GFP_KERNEL);\r\nif (!cq) {\r\npr_err("no mem for cq\n");\r\ngoto out_nomem;\r\n}\r\ncq->attr.max_nr_of_cqes = nr_of_cqe;\r\ncq->attr.cq_token = cq_token;\r\ncq->attr.eq_handle = eq_handle;\r\ncq->adapter = adapter;\r\ncq_handle_ref = &cq->fw_handle;\r\nact_nr_of_entries = 0;\r\nact_pages = 0;\r\nhret = ehea_h_alloc_resource_cq(adapter->handle, &cq->attr,\r\n&cq->fw_handle, &cq->epas);\r\nif (hret != H_SUCCESS) {\r\npr_err("alloc_resource_cq failed\n");\r\ngoto out_freemem;\r\n}\r\nret = hw_queue_ctor(&cq->hw_queue, cq->attr.nr_pages,\r\nEHEA_PAGESIZE, sizeof(struct ehea_cqe));\r\nif (ret)\r\ngoto out_freeres;\r\nfor (counter = 0; counter < cq->attr.nr_pages; counter++) {\r\nvpage = hw_qpageit_get_inc(&cq->hw_queue);\r\nif (!vpage) {\r\npr_err("hw_qpageit_get_inc failed\n");\r\ngoto out_kill_hwq;\r\n}\r\nrpage = virt_to_abs(vpage);\r\nhret = ehea_h_register_rpage(adapter->handle,\r\n0, EHEA_CQ_REGISTER_ORIG,\r\ncq->fw_handle, rpage, 1);\r\nif (hret < H_SUCCESS) {\r\npr_err("register_rpage_cq failed ehea_cq=%p hret=%llx counter=%i act_pages=%i\n",\r\ncq, hret, counter, cq->attr.nr_pages);\r\ngoto out_kill_hwq;\r\n}\r\nif (counter == (cq->attr.nr_pages - 1)) {\r\nvpage = hw_qpageit_get_inc(&cq->hw_queue);\r\nif ((hret != H_SUCCESS) || (vpage)) {\r\npr_err("registration of pages not complete hret=%llx\n",\r\nhret);\r\ngoto out_kill_hwq;\r\n}\r\n} else {\r\nif (hret != H_PAGE_REGISTERED) {\r\npr_err("CQ: registration of page failed hret=%llx\n",\r\nhret);\r\ngoto out_kill_hwq;\r\n}\r\n}\r\n}\r\nhw_qeit_reset(&cq->hw_queue);\r\nepa = cq->epas.kernel;\r\nehea_reset_cq_ep(cq);\r\nehea_reset_cq_n1(cq);\r\nreturn cq;\r\nout_kill_hwq:\r\nhw_queue_dtor(&cq->hw_queue);\r\nout_freeres:\r\nehea_h_free_resource(adapter->handle, cq->fw_handle, FORCE_FREE);\r\nout_freemem:\r\nkfree(cq);\r\nout_nomem:\r\nreturn NULL;\r\n}\r\nu64 ehea_destroy_cq_res(struct ehea_cq *cq, u64 force)\r\n{\r\nu64 hret;\r\nu64 adapter_handle = cq->adapter->handle;\r\nhret = ehea_h_free_resource(adapter_handle, cq->fw_handle, force);\r\nif (hret != H_SUCCESS)\r\nreturn hret;\r\nhw_queue_dtor(&cq->hw_queue);\r\nkfree(cq);\r\nreturn hret;\r\n}\r\nint ehea_destroy_cq(struct ehea_cq *cq)\r\n{\r\nu64 hret, aer, aerr;\r\nif (!cq)\r\nreturn 0;\r\nhcp_epas_dtor(&cq->epas);\r\nhret = ehea_destroy_cq_res(cq, NORMAL_FREE);\r\nif (hret == H_R_STATE) {\r\nehea_error_data(cq->adapter, cq->fw_handle, &aer, &aerr);\r\nhret = ehea_destroy_cq_res(cq, FORCE_FREE);\r\n}\r\nif (hret != H_SUCCESS) {\r\npr_err("destroy CQ failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstruct ehea_eq *ehea_create_eq(struct ehea_adapter *adapter,\r\nconst enum ehea_eq_type type,\r\nconst u32 max_nr_of_eqes, const u8 eqe_gen)\r\n{\r\nint ret, i;\r\nu64 hret, rpage;\r\nvoid *vpage;\r\nstruct ehea_eq *eq;\r\neq = kzalloc(sizeof(*eq), GFP_KERNEL);\r\nif (!eq) {\r\npr_err("no mem for eq\n");\r\nreturn NULL;\r\n}\r\neq->adapter = adapter;\r\neq->attr.type = type;\r\neq->attr.max_nr_of_eqes = max_nr_of_eqes;\r\neq->attr.eqe_gen = eqe_gen;\r\nspin_lock_init(&eq->spinlock);\r\nhret = ehea_h_alloc_resource_eq(adapter->handle,\r\n&eq->attr, &eq->fw_handle);\r\nif (hret != H_SUCCESS) {\r\npr_err("alloc_resource_eq failed\n");\r\ngoto out_freemem;\r\n}\r\nret = hw_queue_ctor(&eq->hw_queue, eq->attr.nr_pages,\r\nEHEA_PAGESIZE, sizeof(struct ehea_eqe));\r\nif (ret) {\r\npr_err("can't allocate eq pages\n");\r\ngoto out_freeres;\r\n}\r\nfor (i = 0; i < eq->attr.nr_pages; i++) {\r\nvpage = hw_qpageit_get_inc(&eq->hw_queue);\r\nif (!vpage) {\r\npr_err("hw_qpageit_get_inc failed\n");\r\nhret = H_RESOURCE;\r\ngoto out_kill_hwq;\r\n}\r\nrpage = virt_to_abs(vpage);\r\nhret = ehea_h_register_rpage(adapter->handle, 0,\r\nEHEA_EQ_REGISTER_ORIG,\r\neq->fw_handle, rpage, 1);\r\nif (i == (eq->attr.nr_pages - 1)) {\r\nvpage = hw_qpageit_get_inc(&eq->hw_queue);\r\nif ((hret != H_SUCCESS) || (vpage))\r\ngoto out_kill_hwq;\r\n} else {\r\nif (hret != H_PAGE_REGISTERED)\r\ngoto out_kill_hwq;\r\n}\r\n}\r\nhw_qeit_reset(&eq->hw_queue);\r\nreturn eq;\r\nout_kill_hwq:\r\nhw_queue_dtor(&eq->hw_queue);\r\nout_freeres:\r\nehea_h_free_resource(adapter->handle, eq->fw_handle, FORCE_FREE);\r\nout_freemem:\r\nkfree(eq);\r\nreturn NULL;\r\n}\r\nstruct ehea_eqe *ehea_poll_eq(struct ehea_eq *eq)\r\n{\r\nstruct ehea_eqe *eqe;\r\nunsigned long flags;\r\nspin_lock_irqsave(&eq->spinlock, flags);\r\neqe = hw_eqit_eq_get_inc_valid(&eq->hw_queue);\r\nspin_unlock_irqrestore(&eq->spinlock, flags);\r\nreturn eqe;\r\n}\r\nu64 ehea_destroy_eq_res(struct ehea_eq *eq, u64 force)\r\n{\r\nu64 hret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&eq->spinlock, flags);\r\nhret = ehea_h_free_resource(eq->adapter->handle, eq->fw_handle, force);\r\nspin_unlock_irqrestore(&eq->spinlock, flags);\r\nif (hret != H_SUCCESS)\r\nreturn hret;\r\nhw_queue_dtor(&eq->hw_queue);\r\nkfree(eq);\r\nreturn hret;\r\n}\r\nint ehea_destroy_eq(struct ehea_eq *eq)\r\n{\r\nu64 hret, aer, aerr;\r\nif (!eq)\r\nreturn 0;\r\nhcp_epas_dtor(&eq->epas);\r\nhret = ehea_destroy_eq_res(eq, NORMAL_FREE);\r\nif (hret == H_R_STATE) {\r\nehea_error_data(eq->adapter, eq->fw_handle, &aer, &aerr);\r\nhret = ehea_destroy_eq_res(eq, FORCE_FREE);\r\n}\r\nif (hret != H_SUCCESS) {\r\npr_err("destroy EQ failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint ehea_qp_alloc_register(struct ehea_qp *qp, struct hw_queue *hw_queue,\r\nint nr_pages, int wqe_size, int act_nr_sges,\r\nstruct ehea_adapter *adapter, int h_call_q_selector)\r\n{\r\nu64 hret, rpage;\r\nint ret, cnt;\r\nvoid *vpage;\r\nret = hw_queue_ctor(hw_queue, nr_pages, EHEA_PAGESIZE, wqe_size);\r\nif (ret)\r\nreturn ret;\r\nfor (cnt = 0; cnt < nr_pages; cnt++) {\r\nvpage = hw_qpageit_get_inc(hw_queue);\r\nif (!vpage) {\r\npr_err("hw_qpageit_get_inc failed\n");\r\ngoto out_kill_hwq;\r\n}\r\nrpage = virt_to_abs(vpage);\r\nhret = ehea_h_register_rpage(adapter->handle,\r\n0, h_call_q_selector,\r\nqp->fw_handle, rpage, 1);\r\nif (hret < H_SUCCESS) {\r\npr_err("register_rpage_qp failed\n");\r\ngoto out_kill_hwq;\r\n}\r\n}\r\nhw_qeit_reset(hw_queue);\r\nreturn 0;\r\nout_kill_hwq:\r\nhw_queue_dtor(hw_queue);\r\nreturn -EIO;\r\n}\r\nstatic inline u32 map_wqe_size(u8 wqe_enc_size)\r\n{\r\nreturn 128 << wqe_enc_size;\r\n}\r\nstruct ehea_qp *ehea_create_qp(struct ehea_adapter *adapter,\r\nu32 pd, struct ehea_qp_init_attr *init_attr)\r\n{\r\nint ret;\r\nu64 hret;\r\nstruct ehea_qp *qp;\r\nu32 wqe_size_in_bytes_sq, wqe_size_in_bytes_rq1;\r\nu32 wqe_size_in_bytes_rq2, wqe_size_in_bytes_rq3;\r\nqp = kzalloc(sizeof(*qp), GFP_KERNEL);\r\nif (!qp) {\r\npr_err("no mem for qp\n");\r\nreturn NULL;\r\n}\r\nqp->adapter = adapter;\r\nhret = ehea_h_alloc_resource_qp(adapter->handle, init_attr, pd,\r\n&qp->fw_handle, &qp->epas);\r\nif (hret != H_SUCCESS) {\r\npr_err("ehea_h_alloc_resource_qp failed\n");\r\ngoto out_freemem;\r\n}\r\nwqe_size_in_bytes_sq = map_wqe_size(init_attr->act_wqe_size_enc_sq);\r\nwqe_size_in_bytes_rq1 = map_wqe_size(init_attr->act_wqe_size_enc_rq1);\r\nwqe_size_in_bytes_rq2 = map_wqe_size(init_attr->act_wqe_size_enc_rq2);\r\nwqe_size_in_bytes_rq3 = map_wqe_size(init_attr->act_wqe_size_enc_rq3);\r\nret = ehea_qp_alloc_register(qp, &qp->hw_squeue, init_attr->nr_sq_pages,\r\nwqe_size_in_bytes_sq,\r\ninit_attr->act_wqe_size_enc_sq, adapter,\r\n0);\r\nif (ret) {\r\npr_err("can't register for sq ret=%x\n", ret);\r\ngoto out_freeres;\r\n}\r\nret = ehea_qp_alloc_register(qp, &qp->hw_rqueue1,\r\ninit_attr->nr_rq1_pages,\r\nwqe_size_in_bytes_rq1,\r\ninit_attr->act_wqe_size_enc_rq1,\r\nadapter, 1);\r\nif (ret) {\r\npr_err("can't register for rq1 ret=%x\n", ret);\r\ngoto out_kill_hwsq;\r\n}\r\nif (init_attr->rq_count > 1) {\r\nret = ehea_qp_alloc_register(qp, &qp->hw_rqueue2,\r\ninit_attr->nr_rq2_pages,\r\nwqe_size_in_bytes_rq2,\r\ninit_attr->act_wqe_size_enc_rq2,\r\nadapter, 2);\r\nif (ret) {\r\npr_err("can't register for rq2 ret=%x\n", ret);\r\ngoto out_kill_hwr1q;\r\n}\r\n}\r\nif (init_attr->rq_count > 2) {\r\nret = ehea_qp_alloc_register(qp, &qp->hw_rqueue3,\r\ninit_attr->nr_rq3_pages,\r\nwqe_size_in_bytes_rq3,\r\ninit_attr->act_wqe_size_enc_rq3,\r\nadapter, 3);\r\nif (ret) {\r\npr_err("can't register for rq3 ret=%x\n", ret);\r\ngoto out_kill_hwr2q;\r\n}\r\n}\r\nqp->init_attr = *init_attr;\r\nreturn qp;\r\nout_kill_hwr2q:\r\nhw_queue_dtor(&qp->hw_rqueue2);\r\nout_kill_hwr1q:\r\nhw_queue_dtor(&qp->hw_rqueue1);\r\nout_kill_hwsq:\r\nhw_queue_dtor(&qp->hw_squeue);\r\nout_freeres:\r\nehea_h_disable_and_get_hea(adapter->handle, qp->fw_handle);\r\nehea_h_free_resource(adapter->handle, qp->fw_handle, FORCE_FREE);\r\nout_freemem:\r\nkfree(qp);\r\nreturn NULL;\r\n}\r\nu64 ehea_destroy_qp_res(struct ehea_qp *qp, u64 force)\r\n{\r\nu64 hret;\r\nstruct ehea_qp_init_attr *qp_attr = &qp->init_attr;\r\nehea_h_disable_and_get_hea(qp->adapter->handle, qp->fw_handle);\r\nhret = ehea_h_free_resource(qp->adapter->handle, qp->fw_handle, force);\r\nif (hret != H_SUCCESS)\r\nreturn hret;\r\nhw_queue_dtor(&qp->hw_squeue);\r\nhw_queue_dtor(&qp->hw_rqueue1);\r\nif (qp_attr->rq_count > 1)\r\nhw_queue_dtor(&qp->hw_rqueue2);\r\nif (qp_attr->rq_count > 2)\r\nhw_queue_dtor(&qp->hw_rqueue3);\r\nkfree(qp);\r\nreturn hret;\r\n}\r\nint ehea_destroy_qp(struct ehea_qp *qp)\r\n{\r\nu64 hret, aer, aerr;\r\nif (!qp)\r\nreturn 0;\r\nhcp_epas_dtor(&qp->epas);\r\nhret = ehea_destroy_qp_res(qp, NORMAL_FREE);\r\nif (hret == H_R_STATE) {\r\nehea_error_data(qp->adapter, qp->fw_handle, &aer, &aerr);\r\nhret = ehea_destroy_qp_res(qp, FORCE_FREE);\r\n}\r\nif (hret != H_SUCCESS) {\r\npr_err("destroy QP failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int ehea_calc_index(unsigned long i, unsigned long s)\r\n{\r\nreturn (i >> s) & EHEA_INDEX_MASK;\r\n}\r\nstatic inline int ehea_init_top_bmap(struct ehea_top_bmap *ehea_top_bmap,\r\nint dir)\r\n{\r\nif (!ehea_top_bmap->dir[dir]) {\r\nehea_top_bmap->dir[dir] =\r\nkzalloc(sizeof(struct ehea_dir_bmap), GFP_KERNEL);\r\nif (!ehea_top_bmap->dir[dir])\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int ehea_init_bmap(struct ehea_bmap *ehea_bmap, int top, int dir)\r\n{\r\nif (!ehea_bmap->top[top]) {\r\nehea_bmap->top[top] =\r\nkzalloc(sizeof(struct ehea_top_bmap), GFP_KERNEL);\r\nif (!ehea_bmap->top[top])\r\nreturn -ENOMEM;\r\n}\r\nreturn ehea_init_top_bmap(ehea_bmap->top[top], dir);\r\n}\r\nstatic void ehea_rebuild_busmap(void)\r\n{\r\nu64 vaddr = EHEA_BUSMAP_START;\r\nint top, dir, idx;\r\nfor (top = 0; top < EHEA_MAP_ENTRIES; top++) {\r\nstruct ehea_top_bmap *ehea_top;\r\nint valid_dir_entries = 0;\r\nif (!ehea_bmap->top[top])\r\ncontinue;\r\nehea_top = ehea_bmap->top[top];\r\nfor (dir = 0; dir < EHEA_MAP_ENTRIES; dir++) {\r\nstruct ehea_dir_bmap *ehea_dir;\r\nint valid_entries = 0;\r\nif (!ehea_top->dir[dir])\r\ncontinue;\r\nvalid_dir_entries++;\r\nehea_dir = ehea_top->dir[dir];\r\nfor (idx = 0; idx < EHEA_MAP_ENTRIES; idx++) {\r\nif (!ehea_dir->ent[idx])\r\ncontinue;\r\nvalid_entries++;\r\nehea_dir->ent[idx] = vaddr;\r\nvaddr += EHEA_SECTSIZE;\r\n}\r\nif (!valid_entries) {\r\nehea_top->dir[dir] = NULL;\r\nkfree(ehea_dir);\r\n}\r\n}\r\nif (!valid_dir_entries) {\r\nehea_bmap->top[top] = NULL;\r\nkfree(ehea_top);\r\n}\r\n}\r\n}\r\nstatic int ehea_update_busmap(unsigned long pfn, unsigned long nr_pages, int add)\r\n{\r\nunsigned long i, start_section, end_section;\r\nif (!nr_pages)\r\nreturn 0;\r\nif (!ehea_bmap) {\r\nehea_bmap = kzalloc(sizeof(struct ehea_bmap), GFP_KERNEL);\r\nif (!ehea_bmap)\r\nreturn -ENOMEM;\r\n}\r\nstart_section = (pfn * PAGE_SIZE) / EHEA_SECTSIZE;\r\nend_section = start_section + ((nr_pages * PAGE_SIZE) / EHEA_SECTSIZE);\r\nfor (i = start_section; i < end_section; i++) {\r\nu64 flag;\r\nint top = ehea_calc_index(i, EHEA_TOP_INDEX_SHIFT);\r\nint dir = ehea_calc_index(i, EHEA_DIR_INDEX_SHIFT);\r\nint idx = i & EHEA_INDEX_MASK;\r\nif (add) {\r\nint ret = ehea_init_bmap(ehea_bmap, top, dir);\r\nif (ret)\r\nreturn ret;\r\nflag = 1;\r\nehea_mr_len += EHEA_SECTSIZE;\r\n} else {\r\nif (!ehea_bmap->top[top])\r\ncontinue;\r\nif (!ehea_bmap->top[top]->dir[dir])\r\ncontinue;\r\nflag = 0;\r\nehea_mr_len -= EHEA_SECTSIZE;\r\n}\r\nehea_bmap->top[top]->dir[dir]->ent[idx] = flag;\r\n}\r\nehea_rebuild_busmap();\r\nreturn 0;\r\n}\r\nint ehea_add_sect_bmap(unsigned long pfn, unsigned long nr_pages)\r\n{\r\nint ret;\r\nmutex_lock(&ehea_busmap_mutex);\r\nret = ehea_update_busmap(pfn, nr_pages, EHEA_BUSMAP_ADD_SECT);\r\nmutex_unlock(&ehea_busmap_mutex);\r\nreturn ret;\r\n}\r\nint ehea_rem_sect_bmap(unsigned long pfn, unsigned long nr_pages)\r\n{\r\nint ret;\r\nmutex_lock(&ehea_busmap_mutex);\r\nret = ehea_update_busmap(pfn, nr_pages, EHEA_BUSMAP_REM_SECT);\r\nmutex_unlock(&ehea_busmap_mutex);\r\nreturn ret;\r\n}\r\nstatic int ehea_is_hugepage(unsigned long pfn)\r\n{\r\nint page_order;\r\nif (pfn & EHEA_HUGEPAGE_PFN_MASK)\r\nreturn 0;\r\npage_order = compound_order(pfn_to_page(pfn));\r\nif (page_order + PAGE_SHIFT != EHEA_HUGEPAGESHIFT)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ehea_create_busmap_callback(unsigned long initial_pfn,\r\nunsigned long total_nr_pages, void *arg)\r\n{\r\nint ret;\r\nunsigned long pfn, start_pfn, end_pfn, nr_pages;\r\nif ((total_nr_pages * PAGE_SIZE) < EHEA_HUGEPAGE_SIZE)\r\nreturn ehea_update_busmap(initial_pfn, total_nr_pages,\r\nEHEA_BUSMAP_ADD_SECT);\r\nstart_pfn = initial_pfn;\r\nend_pfn = initial_pfn + total_nr_pages;\r\npfn = start_pfn;\r\nwhile (pfn < end_pfn) {\r\nif (ehea_is_hugepage(pfn)) {\r\nnr_pages = pfn - start_pfn;\r\nret = ehea_update_busmap(start_pfn, nr_pages,\r\nEHEA_BUSMAP_ADD_SECT);\r\nif (ret)\r\nreturn ret;\r\npfn += (EHEA_HUGEPAGE_SIZE / PAGE_SIZE);\r\nstart_pfn = pfn;\r\n} else\r\npfn += (EHEA_SECTSIZE / PAGE_SIZE);\r\n}\r\nnr_pages = pfn - start_pfn;\r\nreturn ehea_update_busmap(start_pfn, nr_pages, EHEA_BUSMAP_ADD_SECT);\r\n}\r\nint ehea_create_busmap(void)\r\n{\r\nint ret;\r\nmutex_lock(&ehea_busmap_mutex);\r\nehea_mr_len = 0;\r\nret = walk_system_ram_range(0, 1ULL << MAX_PHYSMEM_BITS, NULL,\r\nehea_create_busmap_callback);\r\nmutex_unlock(&ehea_busmap_mutex);\r\nreturn ret;\r\n}\r\nvoid ehea_destroy_busmap(void)\r\n{\r\nint top, dir;\r\nmutex_lock(&ehea_busmap_mutex);\r\nif (!ehea_bmap)\r\ngoto out_destroy;\r\nfor (top = 0; top < EHEA_MAP_ENTRIES; top++) {\r\nif (!ehea_bmap->top[top])\r\ncontinue;\r\nfor (dir = 0; dir < EHEA_MAP_ENTRIES; dir++) {\r\nif (!ehea_bmap->top[top]->dir[dir])\r\ncontinue;\r\nkfree(ehea_bmap->top[top]->dir[dir]);\r\n}\r\nkfree(ehea_bmap->top[top]);\r\n}\r\nkfree(ehea_bmap);\r\nehea_bmap = NULL;\r\nout_destroy:\r\nmutex_unlock(&ehea_busmap_mutex);\r\n}\r\nu64 ehea_map_vaddr(void *caddr)\r\n{\r\nint top, dir, idx;\r\nunsigned long index, offset;\r\nif (!ehea_bmap)\r\nreturn EHEA_INVAL_ADDR;\r\nindex = virt_to_abs(caddr) >> SECTION_SIZE_BITS;\r\ntop = (index >> EHEA_TOP_INDEX_SHIFT) & EHEA_INDEX_MASK;\r\nif (!ehea_bmap->top[top])\r\nreturn EHEA_INVAL_ADDR;\r\ndir = (index >> EHEA_DIR_INDEX_SHIFT) & EHEA_INDEX_MASK;\r\nif (!ehea_bmap->top[top]->dir[dir])\r\nreturn EHEA_INVAL_ADDR;\r\nidx = index & EHEA_INDEX_MASK;\r\nif (!ehea_bmap->top[top]->dir[dir]->ent[idx])\r\nreturn EHEA_INVAL_ADDR;\r\noffset = (unsigned long)caddr & (EHEA_SECTSIZE - 1);\r\nreturn ehea_bmap->top[top]->dir[dir]->ent[idx] | offset;\r\n}\r\nstatic inline void *ehea_calc_sectbase(int top, int dir, int idx)\r\n{\r\nunsigned long ret = idx;\r\nret |= dir << EHEA_DIR_INDEX_SHIFT;\r\nret |= top << EHEA_TOP_INDEX_SHIFT;\r\nreturn abs_to_virt(ret << SECTION_SIZE_BITS);\r\n}\r\nstatic u64 ehea_reg_mr_section(int top, int dir, int idx, u64 *pt,\r\nstruct ehea_adapter *adapter,\r\nstruct ehea_mr *mr)\r\n{\r\nvoid *pg;\r\nu64 j, m, hret;\r\nunsigned long k = 0;\r\nu64 pt_abs = virt_to_abs(pt);\r\nvoid *sectbase = ehea_calc_sectbase(top, dir, idx);\r\nfor (j = 0; j < (EHEA_PAGES_PER_SECTION / EHEA_MAX_RPAGE); j++) {\r\nfor (m = 0; m < EHEA_MAX_RPAGE; m++) {\r\npg = sectbase + ((k++) * EHEA_PAGESIZE);\r\npt[m] = virt_to_abs(pg);\r\n}\r\nhret = ehea_h_register_rpage_mr(adapter->handle, mr->handle, 0,\r\n0, pt_abs, EHEA_MAX_RPAGE);\r\nif ((hret != H_SUCCESS) &&\r\n(hret != H_PAGE_REGISTERED)) {\r\nehea_h_free_resource(adapter->handle, mr->handle,\r\nFORCE_FREE);\r\npr_err("register_rpage_mr failed\n");\r\nreturn hret;\r\n}\r\n}\r\nreturn hret;\r\n}\r\nstatic u64 ehea_reg_mr_sections(int top, int dir, u64 *pt,\r\nstruct ehea_adapter *adapter,\r\nstruct ehea_mr *mr)\r\n{\r\nu64 hret = H_SUCCESS;\r\nint idx;\r\nfor (idx = 0; idx < EHEA_MAP_ENTRIES; idx++) {\r\nif (!ehea_bmap->top[top]->dir[dir]->ent[idx])\r\ncontinue;\r\nhret = ehea_reg_mr_section(top, dir, idx, pt, adapter, mr);\r\nif ((hret != H_SUCCESS) && (hret != H_PAGE_REGISTERED))\r\nreturn hret;\r\n}\r\nreturn hret;\r\n}\r\nstatic u64 ehea_reg_mr_dir_sections(int top, u64 *pt,\r\nstruct ehea_adapter *adapter,\r\nstruct ehea_mr *mr)\r\n{\r\nu64 hret = H_SUCCESS;\r\nint dir;\r\nfor (dir = 0; dir < EHEA_MAP_ENTRIES; dir++) {\r\nif (!ehea_bmap->top[top]->dir[dir])\r\ncontinue;\r\nhret = ehea_reg_mr_sections(top, dir, pt, adapter, mr);\r\nif ((hret != H_SUCCESS) && (hret != H_PAGE_REGISTERED))\r\nreturn hret;\r\n}\r\nreturn hret;\r\n}\r\nint ehea_reg_kernel_mr(struct ehea_adapter *adapter, struct ehea_mr *mr)\r\n{\r\nint ret;\r\nu64 *pt;\r\nu64 hret;\r\nu32 acc_ctrl = EHEA_MR_ACC_CTRL;\r\nunsigned long top;\r\npt = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!pt) {\r\npr_err("no mem\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nhret = ehea_h_alloc_resource_mr(adapter->handle, EHEA_BUSMAP_START,\r\nehea_mr_len, acc_ctrl, adapter->pd,\r\n&mr->handle, &mr->lkey);\r\nif (hret != H_SUCCESS) {\r\npr_err("alloc_resource_mr failed\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!ehea_bmap) {\r\nehea_h_free_resource(adapter->handle, mr->handle, FORCE_FREE);\r\npr_err("no busmap available\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nfor (top = 0; top < EHEA_MAP_ENTRIES; top++) {\r\nif (!ehea_bmap->top[top])\r\ncontinue;\r\nhret = ehea_reg_mr_dir_sections(top, pt, adapter, mr);\r\nif((hret != H_PAGE_REGISTERED) && (hret != H_SUCCESS))\r\nbreak;\r\n}\r\nif (hret != H_SUCCESS) {\r\nehea_h_free_resource(adapter->handle, mr->handle, FORCE_FREE);\r\npr_err("registering mr failed\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmr->vaddr = EHEA_BUSMAP_START;\r\nmr->adapter = adapter;\r\nret = 0;\r\nout:\r\nfree_page((unsigned long)pt);\r\nreturn ret;\r\n}\r\nint ehea_rem_mr(struct ehea_mr *mr)\r\n{\r\nu64 hret;\r\nif (!mr || !mr->adapter)\r\nreturn -EINVAL;\r\nhret = ehea_h_free_resource(mr->adapter->handle, mr->handle,\r\nFORCE_FREE);\r\nif (hret != H_SUCCESS) {\r\npr_err("destroy MR failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint ehea_gen_smr(struct ehea_adapter *adapter, struct ehea_mr *old_mr,\r\nstruct ehea_mr *shared_mr)\r\n{\r\nu64 hret;\r\nhret = ehea_h_register_smr(adapter->handle, old_mr->handle,\r\nold_mr->vaddr, EHEA_MR_ACC_CTRL,\r\nadapter->pd, shared_mr);\r\nif (hret != H_SUCCESS)\r\nreturn -EIO;\r\nshared_mr->adapter = adapter;\r\nreturn 0;\r\n}\r\nvoid print_error_data(u64 *data)\r\n{\r\nint length;\r\nu64 type = EHEA_BMASK_GET(ERROR_DATA_TYPE, data[2]);\r\nu64 resource = data[1];\r\nlength = EHEA_BMASK_GET(ERROR_DATA_LENGTH, data[0]);\r\nif (length > EHEA_PAGESIZE)\r\nlength = EHEA_PAGESIZE;\r\nif (type == EHEA_AER_RESTYPE_QP)\r\npr_err("QP (resource=%llX) state: AER=0x%llX, AERR=0x%llX, port=%llX\n",\r\nresource, data[6], data[12], data[22]);\r\nelse if (type == EHEA_AER_RESTYPE_CQ)\r\npr_err("CQ (resource=%llX) state: AER=0x%llX\n",\r\nresource, data[6]);\r\nelse if (type == EHEA_AER_RESTYPE_EQ)\r\npr_err("EQ (resource=%llX) state: AER=0x%llX\n",\r\nresource, data[6]);\r\nehea_dump(data, length, "error data");\r\n}\r\nu64 ehea_error_data(struct ehea_adapter *adapter, u64 res_handle,\r\nu64 *aer, u64 *aerr)\r\n{\r\nunsigned long ret;\r\nu64 *rblock;\r\nu64 type = 0;\r\nrblock = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!rblock) {\r\npr_err("Cannot allocate rblock memory\n");\r\ngoto out;\r\n}\r\nret = ehea_h_error_data(adapter->handle, res_handle, rblock);\r\nif (ret == H_SUCCESS) {\r\ntype = EHEA_BMASK_GET(ERROR_DATA_TYPE, rblock[2]);\r\n*aer = rblock[6];\r\n*aerr = rblock[12];\r\nprint_error_data(rblock);\r\n} else if (ret == H_R_STATE) {\r\npr_err("No error data available: %llX\n", res_handle);\r\n} else\r\npr_err("Error data could not be fetched: %llX\n", res_handle);\r\nfree_page((unsigned long)rblock);\r\nout:\r\nreturn type;\r\n}
