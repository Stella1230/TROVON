static void write_mda_b(unsigned int val, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mda_lock, flags);\r\noutb_p(reg, mda_index_port);\r\noutb_p(val, mda_value_port);\r\nspin_unlock_irqrestore(&mda_lock, flags);\r\n}\r\nstatic void write_mda_w(unsigned int val, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mda_lock, flags);\r\noutb_p(reg, mda_index_port); outb_p(val >> 8, mda_value_port);\r\noutb_p(reg+1, mda_index_port); outb_p(val & 0xff, mda_value_port);\r\nspin_unlock_irqrestore(&mda_lock, flags);\r\n}\r\nstatic int test_mda_b(unsigned char val, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mda_lock, flags);\r\noutb_p(reg, mda_index_port);\r\noutb (val, mda_value_port);\r\nudelay(20); val = (inb_p(mda_value_port) == val);\r\nspin_unlock_irqrestore(&mda_lock, flags);\r\nreturn val;\r\n}\r\nstatic inline void mda_set_cursor(unsigned int location)\r\n{\r\nif (mda_cursor_loc == location)\r\nreturn;\r\nwrite_mda_w(location >> 1, 0x0e);\r\nmda_cursor_loc = location;\r\n}\r\nstatic inline void mda_set_cursor_size(int from, int to)\r\n{\r\nif (mda_cursor_size_from==from && mda_cursor_size_to==to)\r\nreturn;\r\nif (from > to) {\r\nwrite_mda_b(MDA_CURSOR_OFF, 0x0a);\r\n} else {\r\nwrite_mda_b(from, 0x0a);\r\nwrite_mda_b(to, 0x0b);\r\n}\r\nmda_cursor_size_from = from;\r\nmda_cursor_size_to = to;\r\n}\r\nstatic int __init mdacon_setup(char *str)\r\n{\r\nint ints[3];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] < 2)\r\nreturn 0;\r\nif (ints[1] < 1 || ints[1] > MAX_NR_CONSOLES ||\r\nints[2] < 1 || ints[2] > MAX_NR_CONSOLES)\r\nreturn 0;\r\nmda_first_vc = ints[1];\r\nmda_last_vc = ints[2];\r\nreturn 1;\r\n}\r\nstatic int mda_detect(void)\r\n{\r\nint count=0;\r\nu16 *p, p_save;\r\nu16 *q, q_save;\r\np = (u16 *) mda_vram_base;\r\nq = (u16 *) (mda_vram_base + 0x01000);\r\np_save = scr_readw(p); q_save = scr_readw(q);\r\nscr_writew(0xAA55, p); if (scr_readw(p) == 0xAA55) count++;\r\nscr_writew(0x55AA, p); if (scr_readw(p) == 0x55AA) count++;\r\nscr_writew(p_save, p);\r\nif (count != 2) {\r\nreturn 0;\r\n}\r\nscr_writew(0xA55A, q); scr_writew(0x0000, p);\r\nif (scr_readw(q) == 0xA55A) count++;\r\nscr_writew(0x5AA5, q); scr_writew(0x0000, p);\r\nif (scr_readw(q) == 0x5AA5) count++;\r\nscr_writew(p_save, p); scr_writew(q_save, q);\r\nif (count == 4) {\r\nmda_vram_len = 0x02000;\r\n}\r\n#ifdef TEST_MDA_B\r\nif (! test_mda_b(0x66, 0x0f)) {\r\nreturn 0;\r\n}\r\nif (! test_mda_b(0x99, 0x0f)) {\r\nreturn 0;\r\n}\r\n#endif\r\np_save = q_save = inb_p(mda_status_port) & MDA_STATUS_VSYNC;\r\nfor (count=0; count < 50000 && p_save == q_save; count++) {\r\nq_save = inb(mda_status_port) & MDA_STATUS_VSYNC;\r\nudelay(2);\r\n}\r\nif (p_save != q_save) {\r\nswitch (inb_p(mda_status_port) & 0x70) {\r\ncase 0x10:\r\nmda_type = TYPE_HERCPLUS;\r\nmda_type_name = "HerculesPlus";\r\nbreak;\r\ncase 0x50:\r\nmda_type = TYPE_HERCCOLOR;\r\nmda_type_name = "HerculesColor";\r\nbreak;\r\ndefault:\r\nmda_type = TYPE_HERC;\r\nmda_type_name = "Hercules";\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void mda_initialize(void)\r\n{\r\nwrite_mda_b(97, 0x00);\r\nwrite_mda_b(80, 0x01);\r\nwrite_mda_b(82, 0x02);\r\nwrite_mda_b(15, 0x03);\r\nwrite_mda_b(25, 0x04);\r\nwrite_mda_b(6, 0x05);\r\nwrite_mda_b(25, 0x06);\r\nwrite_mda_b(25, 0x07);\r\nwrite_mda_b(2, 0x08);\r\nwrite_mda_b(13, 0x09);\r\nwrite_mda_b(12, 0x0a);\r\nwrite_mda_b(13, 0x0b);\r\nwrite_mda_w(0x0000, 0x0c);\r\nwrite_mda_w(0x0000, 0x0e);\r\noutb_p(MDA_MODE_VIDEO_EN | MDA_MODE_BLINK_EN, mda_mode_port);\r\noutb_p(0x00, mda_status_port);\r\noutb_p(0x00, mda_gfx_port);\r\n}\r\nstatic const char *mdacon_startup(void)\r\n{\r\nmda_num_columns = 80;\r\nmda_num_lines = 25;\r\nmda_vram_len = 0x01000;\r\nmda_vram_base = VGA_MAP_MEM(0xb0000, mda_vram_len);\r\nmda_index_port = 0x3b4;\r\nmda_value_port = 0x3b5;\r\nmda_mode_port = 0x3b8;\r\nmda_status_port = 0x3ba;\r\nmda_gfx_port = 0x3bf;\r\nmda_type = TYPE_MDA;\r\nmda_type_name = "MDA";\r\nif (! mda_detect()) {\r\nprintk("mdacon: MDA card not detected.\n");\r\nreturn NULL;\r\n}\r\nif (mda_type != TYPE_MDA) {\r\nmda_initialize();\r\n}\r\nmda_set_cursor(mda_vram_len - 1);\r\nprintk("mdacon: %s with %ldK of memory detected.\n",\r\nmda_type_name, mda_vram_len/1024);\r\nreturn "MDA-2";\r\n}\r\nstatic void mdacon_init(struct vc_data *c, int init)\r\n{\r\nc->vc_complement_mask = 0x0800;\r\nc->vc_display_fg = &mda_display_fg;\r\nif (init) {\r\nc->vc_cols = mda_num_columns;\r\nc->vc_rows = mda_num_lines;\r\n} else\r\nvc_resize(c, mda_num_columns, mda_num_lines);\r\nif (mda_display_fg == NULL)\r\nmda_display_fg = c;\r\n}\r\nstatic void mdacon_deinit(struct vc_data *c)\r\n{\r\nif (mda_display_fg == c)\r\nmda_display_fg = NULL;\r\n}\r\nstatic inline u16 mda_convert_attr(u16 ch)\r\n{\r\nu16 attr = 0x0700;\r\nif (ch & 0x0800) attr = 0x7000;\r\nelse if (ch & 0x0400) attr = 0x0100;\r\nreturn ((ch & 0x0200) << 2) |\r\n(ch & 0x8000) |\r\n(ch & 0x00ff) | attr;\r\n}\r\nstatic u8 mdacon_build_attr(struct vc_data *c, u8 color, u8 intensity,\r\nu8 blink, u8 underline, u8 reverse, u8 italic)\r\n{\r\nreturn (intensity & 3) |\r\n((underline & 1) << 2) |\r\n((reverse & 1) << 3) |\r\n(!!italic << 4) |\r\n((blink & 1) << 7);\r\n}\r\nstatic void mdacon_invert_region(struct vc_data *c, u16 *p, int count)\r\n{\r\nfor (; count > 0; count--) {\r\nscr_writew(scr_readw(p) ^ 0x0800, p);\r\np++;\r\n}\r\n}\r\nstatic void mdacon_putc(struct vc_data *c, int ch, int y, int x)\r\n{\r\nscr_writew(mda_convert_attr(ch), MDA_ADDR(x, y));\r\n}\r\nstatic void mdacon_putcs(struct vc_data *c, const unsigned short *s,\r\nint count, int y, int x)\r\n{\r\nu16 *dest = MDA_ADDR(x, y);\r\nfor (; count > 0; count--) {\r\nscr_writew(mda_convert_attr(scr_readw(s++)), dest++);\r\n}\r\n}\r\nstatic void mdacon_clear(struct vc_data *c, int y, int x,\r\nint height, int width)\r\n{\r\nu16 *dest = MDA_ADDR(x, y);\r\nu16 eattr = mda_convert_attr(c->vc_video_erase_char);\r\nif (width <= 0 || height <= 0)\r\nreturn;\r\nif (x==0 && width==mda_num_columns) {\r\nscr_memsetw(dest, eattr, height*width*2);\r\n} else {\r\nfor (; height > 0; height--, dest+=mda_num_columns)\r\nscr_memsetw(dest, eattr, width*2);\r\n}\r\n}\r\nstatic void mdacon_bmove(struct vc_data *c, int sy, int sx,\r\nint dy, int dx, int height, int width)\r\n{\r\nu16 *src, *dest;\r\nif (width <= 0 || height <= 0)\r\nreturn;\r\nif (sx==0 && dx==0 && width==mda_num_columns) {\r\nscr_memmovew(MDA_ADDR(0,dy), MDA_ADDR(0,sy), height*width*2);\r\n} else if (dy < sy || (dy == sy && dx < sx)) {\r\nsrc = MDA_ADDR(sx, sy);\r\ndest = MDA_ADDR(dx, dy);\r\nfor (; height > 0; height--) {\r\nscr_memmovew(dest, src, width*2);\r\nsrc += mda_num_columns;\r\ndest += mda_num_columns;\r\n}\r\n} else {\r\nsrc = MDA_ADDR(sx, sy+height-1);\r\ndest = MDA_ADDR(dx, dy+height-1);\r\nfor (; height > 0; height--) {\r\nscr_memmovew(dest, src, width*2);\r\nsrc -= mda_num_columns;\r\ndest -= mda_num_columns;\r\n}\r\n}\r\n}\r\nstatic int mdacon_switch(struct vc_data *c)\r\n{\r\nreturn 1;\r\n}\r\nstatic int mdacon_set_palette(struct vc_data *c, unsigned char *table)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int mdacon_blank(struct vc_data *c, int blank, int mode_switch)\r\n{\r\nif (mda_type == TYPE_MDA) {\r\nif (blank)\r\nscr_memsetw((void *)mda_vram_base,\r\nmda_convert_attr(c->vc_video_erase_char),\r\nc->vc_screenbuf_size);\r\nreturn 1;\r\n} else {\r\nif (blank)\r\noutb_p(0x00, mda_mode_port);\r\nelse\r\noutb_p(MDA_MODE_VIDEO_EN | MDA_MODE_BLINK_EN,\r\nmda_mode_port);\r\nreturn 0;\r\n}\r\n}\r\nstatic int mdacon_scrolldelta(struct vc_data *c, int lines)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mdacon_cursor(struct vc_data *c, int mode)\r\n{\r\nif (mode == CM_ERASE) {\r\nmda_set_cursor(mda_vram_len - 1);\r\nreturn;\r\n}\r\nmda_set_cursor(c->vc_y*mda_num_columns*2 + c->vc_x*2);\r\nswitch (c->vc_cursor_type & 0x0f) {\r\ncase CUR_LOWER_THIRD: mda_set_cursor_size(10, 13); break;\r\ncase CUR_LOWER_HALF: mda_set_cursor_size(7, 13); break;\r\ncase CUR_TWO_THIRDS: mda_set_cursor_size(4, 13); break;\r\ncase CUR_BLOCK: mda_set_cursor_size(1, 13); break;\r\ncase CUR_NONE: mda_set_cursor_size(14, 13); break;\r\ndefault: mda_set_cursor_size(12, 13); break;\r\n}\r\n}\r\nstatic int mdacon_scroll(struct vc_data *c, int t, int b, int dir, int lines)\r\n{\r\nu16 eattr = mda_convert_attr(c->vc_video_erase_char);\r\nif (!lines)\r\nreturn 0;\r\nif (lines > c->vc_rows)\r\nlines = c->vc_rows;\r\nswitch (dir) {\r\ncase SM_UP:\r\nscr_memmovew(MDA_ADDR(0,t), MDA_ADDR(0,t+lines),\r\n(b-t-lines)*mda_num_columns*2);\r\nscr_memsetw(MDA_ADDR(0,b-lines), eattr,\r\nlines*mda_num_columns*2);\r\nbreak;\r\ncase SM_DOWN:\r\nscr_memmovew(MDA_ADDR(0,t+lines), MDA_ADDR(0,t),\r\n(b-t-lines)*mda_num_columns*2);\r\nscr_memsetw(MDA_ADDR(0,t), eattr, lines*mda_num_columns*2);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint __init mda_console_init(void)\r\n{\r\nif (mda_first_vc > mda_last_vc)\r\nreturn 1;\r\nreturn take_over_console(&mda_con, mda_first_vc-1, mda_last_vc-1, 0);\r\n}\r\nstatic void __exit mda_console_exit(void)\r\n{\r\ngive_up_console(&mda_con);\r\n}
