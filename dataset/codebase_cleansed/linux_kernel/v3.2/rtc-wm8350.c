static int wm8350_rtc_readtime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct wm8350 *wm8350 = dev_get_drvdata(dev);\r\nu16 time1[4], time2[4];\r\nint retries = WM8350_GET_TIME_RETRIES, ret;\r\ndo {\r\nret = wm8350_block_read(wm8350, WM8350_RTC_SECONDS_MINUTES,\r\n4, time1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wm8350_block_read(wm8350, WM8350_RTC_SECONDS_MINUTES,\r\n4, time2);\r\nif (ret < 0)\r\nreturn ret;\r\nif (memcmp(time1, time2, sizeof(time1)) == 0) {\r\ntm->tm_sec = time1[0] & WM8350_RTC_SECS_MASK;\r\ntm->tm_min = (time1[0] & WM8350_RTC_MINS_MASK)\r\n>> WM8350_RTC_MINS_SHIFT;\r\ntm->tm_hour = time1[1] & WM8350_RTC_HRS_MASK;\r\ntm->tm_wday = ((time1[1] >> WM8350_RTC_DAY_SHIFT)\r\n& 0x7) - 1;\r\ntm->tm_mon = ((time1[2] & WM8350_RTC_MTH_MASK)\r\n>> WM8350_RTC_MTH_SHIFT) - 1;\r\ntm->tm_mday = (time1[2] & WM8350_RTC_DATE_MASK);\r\ntm->tm_year = ((time1[3] & WM8350_RTC_YHUNDREDS_MASK)\r\n>> WM8350_RTC_YHUNDREDS_SHIFT) * 100;\r\ntm->tm_year += time1[3] & WM8350_RTC_YUNITS_MASK;\r\ntm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon,\r\ntm->tm_year);\r\ntm->tm_year -= 1900;\r\ndev_dbg(dev, "Read (%d left): %04x %04x %04x %04x\n",\r\nretries,\r\ntime1[0], time1[1], time1[2], time1[3]);\r\nreturn 0;\r\n}\r\n} while (retries--);\r\ndev_err(dev, "timed out reading RTC time\n");\r\nreturn -EIO;\r\n}\r\nstatic int wm8350_rtc_settime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct wm8350 *wm8350 = dev_get_drvdata(dev);\r\nu16 time[4];\r\nu16 rtc_ctrl;\r\nint ret, retries = WM8350_SET_TIME_RETRIES;\r\ntime[0] = tm->tm_sec;\r\ntime[0] |= tm->tm_min << WM8350_RTC_MINS_SHIFT;\r\ntime[1] = tm->tm_hour;\r\ntime[1] |= (tm->tm_wday + 1) << WM8350_RTC_DAY_SHIFT;\r\ntime[2] = tm->tm_mday;\r\ntime[2] |= (tm->tm_mon + 1) << WM8350_RTC_MTH_SHIFT;\r\ntime[3] = ((tm->tm_year + 1900) / 100) << WM8350_RTC_YHUNDREDS_SHIFT;\r\ntime[3] |= (tm->tm_year + 1900) % 100;\r\ndev_dbg(dev, "Setting: %04x %04x %04x %04x\n",\r\ntime[0], time[1], time[2], time[3]);\r\nret = wm8350_set_bits(wm8350, WM8350_RTC_TIME_CONTROL, WM8350_RTC_SET);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\nrtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(1));\r\n} while (--retries && !(rtc_ctrl & WM8350_RTC_STS));\r\nif (!retries) {\r\ndev_err(dev, "timed out on set confirmation\n");\r\nreturn -EIO;\r\n}\r\nret = wm8350_block_write(wm8350, WM8350_RTC_SECONDS_MINUTES, 4, time);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wm8350_clear_bits(wm8350, WM8350_RTC_TIME_CONTROL,\r\nWM8350_RTC_SET);\r\nreturn ret;\r\n}\r\nstatic int wm8350_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct wm8350 *wm8350 = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nu16 time[4];\r\nint ret;\r\nret = wm8350_block_read(wm8350, WM8350_ALARM_SECONDS_MINUTES, 4, time);\r\nif (ret < 0)\r\nreturn ret;\r\ntm->tm_sec = time[0] & WM8350_RTC_ALMSECS_MASK;\r\nif (tm->tm_sec == WM8350_RTC_ALMSECS_MASK)\r\ntm->tm_sec = -1;\r\ntm->tm_min = time[0] & WM8350_RTC_ALMMINS_MASK;\r\nif (tm->tm_min == WM8350_RTC_ALMMINS_MASK)\r\ntm->tm_min = -1;\r\nelse\r\ntm->tm_min >>= WM8350_RTC_ALMMINS_SHIFT;\r\ntm->tm_hour = time[1] & WM8350_RTC_ALMHRS_MASK;\r\nif (tm->tm_hour == WM8350_RTC_ALMHRS_MASK)\r\ntm->tm_hour = -1;\r\ntm->tm_wday = ((time[1] >> WM8350_RTC_ALMDAY_SHIFT) & 0x7) - 1;\r\nif (tm->tm_wday > 7)\r\ntm->tm_wday = -1;\r\ntm->tm_mon = time[2] & WM8350_RTC_ALMMTH_MASK;\r\nif (tm->tm_mon == WM8350_RTC_ALMMTH_MASK)\r\ntm->tm_mon = -1;\r\nelse\r\ntm->tm_mon = (tm->tm_mon >> WM8350_RTC_ALMMTH_SHIFT) - 1;\r\ntm->tm_mday = (time[2] & WM8350_RTC_ALMDATE_MASK);\r\nif (tm->tm_mday == WM8350_RTC_ALMDATE_MASK)\r\ntm->tm_mday = -1;\r\ntm->tm_year = -1;\r\nalrm->enabled = !(time[3] & WM8350_RTC_ALMSTS);\r\nreturn 0;\r\n}\r\nstatic int wm8350_rtc_stop_alarm(struct wm8350 *wm8350)\r\n{\r\nint retries = WM8350_SET_ALM_RETRIES;\r\nu16 rtc_ctrl;\r\nint ret;\r\nret = wm8350_set_bits(wm8350, WM8350_RTC_TIME_CONTROL,\r\nWM8350_RTC_ALMSET);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\nrtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(1));\r\n} while (retries-- && !(rtc_ctrl & WM8350_RTC_ALMSTS));\r\nif (!(rtc_ctrl & WM8350_RTC_ALMSTS))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int wm8350_rtc_start_alarm(struct wm8350 *wm8350)\r\n{\r\nint ret;\r\nint retries = WM8350_SET_ALM_RETRIES;\r\nu16 rtc_ctrl;\r\nret = wm8350_clear_bits(wm8350, WM8350_RTC_TIME_CONTROL,\r\nWM8350_RTC_ALMSET);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\nrtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(1));\r\n} while (retries-- && rtc_ctrl & WM8350_RTC_ALMSTS);\r\nif (rtc_ctrl & WM8350_RTC_ALMSTS)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int wm8350_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct wm8350 *wm8350 = dev_get_drvdata(dev);\r\nif (enabled)\r\nreturn wm8350_rtc_start_alarm(wm8350);\r\nelse\r\nreturn wm8350_rtc_stop_alarm(wm8350);\r\n}\r\nstatic int wm8350_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct wm8350 *wm8350 = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nu16 time[3];\r\nint ret;\r\nmemset(time, 0, sizeof(time));\r\nif (tm->tm_sec != -1)\r\ntime[0] |= tm->tm_sec;\r\nelse\r\ntime[0] |= WM8350_RTC_ALMSECS_MASK;\r\nif (tm->tm_min != -1)\r\ntime[0] |= tm->tm_min << WM8350_RTC_ALMMINS_SHIFT;\r\nelse\r\ntime[0] |= WM8350_RTC_ALMMINS_MASK;\r\nif (tm->tm_hour != -1)\r\ntime[1] |= tm->tm_hour;\r\nelse\r\ntime[1] |= WM8350_RTC_ALMHRS_MASK;\r\nif (tm->tm_wday != -1)\r\ntime[1] |= (tm->tm_wday + 1) << WM8350_RTC_ALMDAY_SHIFT;\r\nelse\r\ntime[1] |= WM8350_RTC_ALMDAY_MASK;\r\nif (tm->tm_mday != -1)\r\ntime[2] |= tm->tm_mday;\r\nelse\r\ntime[2] |= WM8350_RTC_ALMDATE_MASK;\r\nif (tm->tm_mon != -1)\r\ntime[2] |= (tm->tm_mon + 1) << WM8350_RTC_ALMMTH_SHIFT;\r\nelse\r\ntime[2] |= WM8350_RTC_ALMMTH_MASK;\r\nret = wm8350_rtc_stop_alarm(wm8350);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wm8350_block_write(wm8350, WM8350_ALARM_SECONDS_MINUTES,\r\n3, time);\r\nif (ret < 0)\r\nreturn ret;\r\nif (alrm->enabled)\r\nret = wm8350_rtc_start_alarm(wm8350);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t wm8350_rtc_alarm_handler(int irq, void *data)\r\n{\r\nstruct wm8350 *wm8350 = data;\r\nstruct rtc_device *rtc = wm8350->rtc.rtc;\r\nint ret;\r\nrtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\r\nret = wm8350_set_bits(wm8350, WM8350_RTC_TIME_CONTROL,\r\nWM8350_RTC_ALMSET);\r\nif (ret != 0) {\r\ndev_err(&(wm8350->rtc.pdev->dev),\r\n"Failed to disable alarm: %d\n", ret);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm8350_rtc_update_handler(int irq, void *data)\r\n{\r\nstruct wm8350 *wm8350 = data;\r\nstruct rtc_device *rtc = wm8350->rtc.rtc;\r\nrtc_update_irq(rtc, 1, RTC_IRQF | RTC_UF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm8350_rtc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct wm8350 *wm8350 = dev_get_drvdata(&pdev->dev);\r\nint ret = 0;\r\nu16 reg;\r\nreg = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\r\nif (device_may_wakeup(&wm8350->rtc.pdev->dev) &&\r\nreg & WM8350_RTC_ALMSTS) {\r\nret = wm8350_rtc_stop_alarm(wm8350);\r\nif (ret != 0)\r\ndev_err(&pdev->dev, "Failed to stop RTC alarm: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int wm8350_rtc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct wm8350 *wm8350 = dev_get_drvdata(&pdev->dev);\r\nint ret;\r\nif (wm8350->rtc.alarm_enabled) {\r\nret = wm8350_rtc_start_alarm(wm8350);\r\nif (ret != 0)\r\ndev_err(&pdev->dev,\r\n"Failed to restart RTC alarm: %d\n", ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct wm8350 *wm8350 = platform_get_drvdata(pdev);\r\nstruct wm8350_rtc *wm_rtc = &wm8350->rtc;\r\nint ret = 0;\r\nu16 timectl, power5;\r\ntimectl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);\r\nif (timectl & WM8350_RTC_BCD) {\r\ndev_err(&pdev->dev, "RTC BCD mode not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (timectl & WM8350_RTC_12HR) {\r\ndev_err(&pdev->dev, "RTC 12 hour mode not supported\n");\r\nreturn -EINVAL;\r\n}\r\npower5 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\r\nif (!(power5 & WM8350_RTC_TICK_ENA)) {\r\ndev_info(wm8350->dev, "Starting RTC\n");\r\nwm8350_reg_unlock(wm8350);\r\nret = wm8350_set_bits(wm8350, WM8350_POWER_MGMT_5,\r\nWM8350_RTC_TICK_ENA);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable RTC: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8350_reg_lock(wm8350);\r\n}\r\nif (timectl & WM8350_RTC_STS) {\r\nint retries;\r\nret = wm8350_clear_bits(wm8350, WM8350_RTC_TIME_CONTROL,\r\nWM8350_RTC_SET);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to start: %d\n", ret);\r\nreturn ret;\r\n}\r\nretries = WM8350_SET_TIME_RETRIES;\r\ndo {\r\ntimectl = wm8350_reg_read(wm8350,\r\nWM8350_RTC_TIME_CONTROL);\r\n} while (timectl & WM8350_RTC_STS && --retries);\r\nif (retries == 0) {\r\ndev_err(&pdev->dev, "failed to start: timeout\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nwm_rtc->rtc = rtc_device_register("wm8350", &pdev->dev,\r\n&wm8350_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(wm_rtc->rtc)) {\r\nret = PTR_ERR(wm_rtc->rtc);\r\ndev_err(&pdev->dev, "failed to register RTC: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8350_register_irq(wm8350, WM8350_IRQ_RTC_SEC,\r\nwm8350_rtc_update_handler, 0,\r\n"RTC Seconds", wm8350);\r\nwm8350_mask_irq(wm8350, WM8350_IRQ_RTC_SEC);\r\nwm8350_register_irq(wm8350, WM8350_IRQ_RTC_ALM,\r\nwm8350_rtc_alarm_handler, 0,\r\n"RTC Alarm", wm8350);\r\nreturn 0;\r\n}\r\nstatic int __devexit wm8350_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct wm8350 *wm8350 = platform_get_drvdata(pdev);\r\nstruct wm8350_rtc *wm_rtc = &wm8350->rtc;\r\nwm8350_free_irq(wm8350, WM8350_IRQ_RTC_SEC, wm8350);\r\nwm8350_free_irq(wm8350, WM8350_IRQ_RTC_ALM, wm8350);\r\nrtc_device_unregister(wm_rtc->rtc);\r\nreturn 0;\r\n}\r\nstatic int __init wm8350_rtc_init(void)\r\n{\r\nreturn platform_driver_register(&wm8350_rtc_driver);\r\n}\r\nstatic void __exit wm8350_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&wm8350_rtc_driver);\r\n}
