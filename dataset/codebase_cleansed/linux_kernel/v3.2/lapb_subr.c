void lapb_clear_queues(struct lapb_cb *lapb)\r\n{\r\nskb_queue_purge(&lapb->write_queue);\r\nskb_queue_purge(&lapb->ack_queue);\r\n}\r\nvoid lapb_frames_acked(struct lapb_cb *lapb, unsigned short nr)\r\n{\r\nstruct sk_buff *skb;\r\nint modulus;\r\nmodulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS : LAPB_SMODULUS;\r\nif (lapb->va != nr)\r\nwhile (skb_peek(&lapb->ack_queue) && lapb->va != nr) {\r\nskb = skb_dequeue(&lapb->ack_queue);\r\nkfree_skb(skb);\r\nlapb->va = (lapb->va + 1) % modulus;\r\n}\r\n}\r\nvoid lapb_requeue_frames(struct lapb_cb *lapb)\r\n{\r\nstruct sk_buff *skb, *skb_prev = NULL;\r\nwhile ((skb = skb_dequeue(&lapb->ack_queue)) != NULL) {\r\nif (!skb_prev)\r\nskb_queue_head(&lapb->write_queue, skb);\r\nelse\r\nskb_append(skb_prev, skb, &lapb->write_queue);\r\nskb_prev = skb;\r\n}\r\n}\r\nint lapb_validate_nr(struct lapb_cb *lapb, unsigned short nr)\r\n{\r\nunsigned short vc = lapb->va;\r\nint modulus;\r\nmodulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS : LAPB_SMODULUS;\r\nwhile (vc != lapb->vs) {\r\nif (nr == vc)\r\nreturn 1;\r\nvc = (vc + 1) % modulus;\r\n}\r\nreturn nr == lapb->vs;\r\n}\r\nint lapb_decode(struct lapb_cb *lapb, struct sk_buff *skb,\r\nstruct lapb_frame *frame)\r\n{\r\nframe->type = LAPB_ILLEGAL;\r\n#if LAPB_DEBUG > 2\r\nprintk(KERN_DEBUG "lapb: (%p) S%d RX %02X %02X %02X\n",\r\nlapb->dev, lapb->state,\r\nskb->data[0], skb->data[1], skb->data[2]);\r\n#endif\r\nif (!pskb_may_pull(skb, 2))\r\nreturn -1;\r\nif (lapb->mode & LAPB_MLP) {\r\nif (lapb->mode & LAPB_DCE) {\r\nif (skb->data[0] == LAPB_ADDR_D)\r\nframe->cr = LAPB_COMMAND;\r\nif (skb->data[0] == LAPB_ADDR_C)\r\nframe->cr = LAPB_RESPONSE;\r\n} else {\r\nif (skb->data[0] == LAPB_ADDR_C)\r\nframe->cr = LAPB_COMMAND;\r\nif (skb->data[0] == LAPB_ADDR_D)\r\nframe->cr = LAPB_RESPONSE;\r\n}\r\n} else {\r\nif (lapb->mode & LAPB_DCE) {\r\nif (skb->data[0] == LAPB_ADDR_B)\r\nframe->cr = LAPB_COMMAND;\r\nif (skb->data[0] == LAPB_ADDR_A)\r\nframe->cr = LAPB_RESPONSE;\r\n} else {\r\nif (skb->data[0] == LAPB_ADDR_A)\r\nframe->cr = LAPB_COMMAND;\r\nif (skb->data[0] == LAPB_ADDR_B)\r\nframe->cr = LAPB_RESPONSE;\r\n}\r\n}\r\nskb_pull(skb, 1);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nif (!(skb->data[0] & LAPB_S)) {\r\nif (!pskb_may_pull(skb, 2))\r\nreturn -1;\r\nframe->type = LAPB_I;\r\nframe->ns = (skb->data[0] >> 1) & 0x7F;\r\nframe->nr = (skb->data[1] >> 1) & 0x7F;\r\nframe->pf = skb->data[1] & LAPB_EPF;\r\nframe->control[0] = skb->data[0];\r\nframe->control[1] = skb->data[1];\r\nskb_pull(skb, 2);\r\n} else if ((skb->data[0] & LAPB_U) == 1) {\r\nif (!pskb_may_pull(skb, 2))\r\nreturn -1;\r\nframe->type = skb->data[0] & 0x0F;\r\nframe->nr = (skb->data[1] >> 1) & 0x7F;\r\nframe->pf = skb->data[1] & LAPB_EPF;\r\nframe->control[0] = skb->data[0];\r\nframe->control[1] = skb->data[1];\r\nskb_pull(skb, 2);\r\n} else if ((skb->data[0] & LAPB_U) == 3) {\r\nframe->type = skb->data[0] & ~LAPB_SPF;\r\nframe->pf = skb->data[0] & LAPB_SPF;\r\nframe->control[0] = skb->data[0];\r\nframe->control[1] = 0x00;\r\nskb_pull(skb, 1);\r\n}\r\n} else {\r\nif (!(skb->data[0] & LAPB_S)) {\r\nframe->type = LAPB_I;\r\nframe->ns = (skb->data[0] >> 1) & 0x07;\r\nframe->nr = (skb->data[0] >> 5) & 0x07;\r\nframe->pf = skb->data[0] & LAPB_SPF;\r\n} else if ((skb->data[0] & LAPB_U) == 1) {\r\nframe->type = skb->data[0] & 0x0F;\r\nframe->nr = (skb->data[0] >> 5) & 0x07;\r\nframe->pf = skb->data[0] & LAPB_SPF;\r\n} else if ((skb->data[0] & LAPB_U) == 3) {\r\nframe->type = skb->data[0] & ~LAPB_SPF;\r\nframe->pf = skb->data[0] & LAPB_SPF;\r\n}\r\nframe->control[0] = skb->data[0];\r\nskb_pull(skb, 1);\r\n}\r\nreturn 0;\r\n}\r\nvoid lapb_send_control(struct lapb_cb *lapb, int frametype,\r\nint poll_bit, int type)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nif ((skb = alloc_skb(LAPB_HEADER_LEN + 3, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, LAPB_HEADER_LEN + 1);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\nif ((frametype & LAPB_U) == LAPB_U) {\r\ndptr = skb_put(skb, 1);\r\n*dptr = frametype;\r\n*dptr |= poll_bit ? LAPB_SPF : 0;\r\n} else {\r\ndptr = skb_put(skb, 2);\r\ndptr[0] = frametype;\r\ndptr[1] = (lapb->vr << 1);\r\ndptr[1] |= poll_bit ? LAPB_EPF : 0;\r\n}\r\n} else {\r\ndptr = skb_put(skb, 1);\r\n*dptr = frametype;\r\n*dptr |= poll_bit ? LAPB_SPF : 0;\r\nif ((frametype & LAPB_U) == LAPB_S)\r\n*dptr |= (lapb->vr << 5);\r\n}\r\nlapb_transmit_buffer(lapb, skb, type);\r\n}\r\nvoid lapb_transmit_frmr(struct lapb_cb *lapb)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nif ((skb = alloc_skb(LAPB_HEADER_LEN + 7, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, LAPB_HEADER_LEN + 1);\r\nif (lapb->mode & LAPB_EXTENDED) {\r\ndptr = skb_put(skb, 6);\r\n*dptr++ = LAPB_FRMR;\r\n*dptr++ = lapb->frmr_data.control[0];\r\n*dptr++ = lapb->frmr_data.control[1];\r\n*dptr++ = (lapb->vs << 1) & 0xFE;\r\n*dptr = (lapb->vr << 1) & 0xFE;\r\nif (lapb->frmr_data.cr == LAPB_RESPONSE)\r\n*dptr |= 0x01;\r\ndptr++;\r\n*dptr++ = lapb->frmr_type;\r\n#if LAPB_DEBUG > 1\r\nprintk(KERN_DEBUG "lapb: (%p) S%d TX FRMR %02X %02X %02X %02X %02X\n",\r\nlapb->dev, lapb->state,\r\nskb->data[1], skb->data[2], skb->data[3],\r\nskb->data[4], skb->data[5]);\r\n#endif\r\n} else {\r\ndptr = skb_put(skb, 4);\r\n*dptr++ = LAPB_FRMR;\r\n*dptr++ = lapb->frmr_data.control[0];\r\n*dptr = (lapb->vs << 1) & 0x0E;\r\n*dptr |= (lapb->vr << 5) & 0xE0;\r\nif (lapb->frmr_data.cr == LAPB_RESPONSE)\r\n*dptr |= 0x10;\r\ndptr++;\r\n*dptr++ = lapb->frmr_type;\r\n#if LAPB_DEBUG > 1\r\nprintk(KERN_DEBUG "lapb: (%p) S%d TX FRMR %02X %02X %02X\n",\r\nlapb->dev, lapb->state, skb->data[1],\r\nskb->data[2], skb->data[3]);\r\n#endif\r\n}\r\nlapb_transmit_buffer(lapb, skb, LAPB_RESPONSE);\r\n}
