static void mca_configure_adapter_status(struct mca_device *mca_dev)\r\n{\r\nmca_dev->status = MCA_ADAPTER_NONE;\r\nmca_dev->pos_id = mca_dev->pos[0]\r\n+ (mca_dev->pos[1] << 8);\r\nif (!mca_dev->pos_id && mca_dev->slot < MCA_MAX_SLOT_NR) {\r\nmca_dev->status = MCA_ADAPTER_ERROR;\r\nreturn;\r\n} else if (mca_dev->pos_id != 0xffff) {\r\nmca_dev->status = MCA_ADAPTER_NORMAL;\r\n}\r\nif ((mca_dev->pos_id == 0xffff ||\r\nmca_dev->pos_id == 0x0000) && mca_dev->slot >= MCA_MAX_SLOT_NR) {\r\nint j;\r\nfor (j = 2; j < 8; j++) {\r\nif (mca_dev->pos[j] != 0xff) {\r\nmca_dev->status = MCA_ADAPTER_NORMAL;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!(mca_dev->pos[2] & MCA_ENABLED)) {\r\nmca_dev->status = MCA_ADAPTER_DISABLED;\r\n}\r\n}\r\nstatic int mca_read_and_store_pos(unsigned char *pos)\r\n{\r\nint j;\r\nint found = 0;\r\nfor (j = 0; j < 8; j++) {\r\npos[j] = inb_p(MCA_POS_REG(j));\r\nif (pos[j] != 0xff) {\r\nfound = 1;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic unsigned char mca_pc_read_pos(struct mca_device *mca_dev, int reg)\r\n{\r\nunsigned char byte;\r\nunsigned long flags;\r\nif (reg < 0 || reg >= 8)\r\nreturn 0;\r\nspin_lock_irqsave(&mca_lock, flags);\r\nif (mca_dev->pos_register) {\r\noutb_p(0, MCA_ADAPTER_SETUP_REG);\r\noutb_p(mca_dev->pos_register, MCA_MOTHERBOARD_SETUP_REG);\r\nbyte = inb_p(MCA_POS_REG(reg));\r\noutb_p(0xff, MCA_MOTHERBOARD_SETUP_REG);\r\n} else {\r\noutb_p(0xff, MCA_MOTHERBOARD_SETUP_REG);\r\noutb_p(0x8|(mca_dev->slot & 0xf), MCA_ADAPTER_SETUP_REG);\r\nbyte = inb_p(MCA_POS_REG(reg));\r\noutb_p(0, MCA_ADAPTER_SETUP_REG);\r\n}\r\nspin_unlock_irqrestore(&mca_lock, flags);\r\nmca_dev->pos[reg] = byte;\r\nreturn byte;\r\n}\r\nstatic void mca_pc_write_pos(struct mca_device *mca_dev, int reg,\r\nunsigned char byte)\r\n{\r\nunsigned long flags;\r\nif (reg < 0 || reg >= 8)\r\nreturn;\r\nspin_lock_irqsave(&mca_lock, flags);\r\noutb_p(0xff, MCA_MOTHERBOARD_SETUP_REG);\r\noutb_p(0x8|(mca_dev->slot&0xf), MCA_ADAPTER_SETUP_REG);\r\noutb_p(byte, MCA_POS_REG(reg));\r\noutb_p(0, MCA_ADAPTER_SETUP_REG);\r\nspin_unlock_irqrestore(&mca_lock, flags);\r\nmca_dev->pos[reg] = byte;\r\n}\r\nstatic int mca_dummy_transform_irq(struct mca_device *mca_dev, int irq)\r\n{\r\nreturn irq;\r\n}\r\nstatic int mca_dummy_transform_ioport(struct mca_device *mca_dev, int port)\r\n{\r\nreturn port;\r\n}\r\nstatic void *mca_dummy_transform_memory(struct mca_device *mca_dev, void *mem)\r\n{\r\nreturn mem;\r\n}\r\nstatic int __init mca_init(void)\r\n{\r\nunsigned int i, j;\r\nstruct mca_device *mca_dev;\r\nunsigned char pos[8];\r\nshort mca_builtin_scsi_ports[] = {0xf7, 0xfd, 0x00};\r\nstruct mca_bus *bus;\r\nif (mca_system_init()) {\r\nprintk(KERN_ERR "MCA bus system initialisation failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (!MCA_bus)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "Micro Channel bus detected.\n");\r\nbus = mca_attach_bus(MCA_PRIMARY_BUS);\r\nif (!bus)\r\ngoto out_nomem;\r\nbus->default_dma_mask = 0xffffffffLL;\r\nbus->f.mca_write_pos = mca_pc_write_pos;\r\nbus->f.mca_read_pos = mca_pc_read_pos;\r\nbus->f.mca_transform_irq = mca_dummy_transform_irq;\r\nbus->f.mca_transform_ioport = mca_dummy_transform_ioport;\r\nbus->f.mca_transform_memory = mca_dummy_transform_memory;\r\nmca_dev = kzalloc(sizeof(struct mca_device), GFP_KERNEL);\r\nif (unlikely(!mca_dev))\r\ngoto out_nomem;\r\nspin_lock_irq(&mca_lock);\r\noutb_p(0, MCA_ADAPTER_SETUP_REG);\r\nmca_dev->pos_register = 0x7f;\r\noutb_p(mca_dev->pos_register, MCA_MOTHERBOARD_SETUP_REG);\r\nmca_dev->name[0] = 0;\r\nmca_read_and_store_pos(mca_dev->pos);\r\nmca_configure_adapter_status(mca_dev);\r\nmca_dev->pos_id = MCA_MOTHERBOARD_POS;\r\nmca_dev->slot = MCA_MOTHERBOARD;\r\nmca_register_device(MCA_PRIMARY_BUS, mca_dev);\r\nmca_dev = kzalloc(sizeof(struct mca_device), GFP_ATOMIC);\r\nif (unlikely(!mca_dev))\r\ngoto out_unlock_nomem;\r\nmca_dev->pos_register = 0xdf;\r\noutb_p(mca_dev->pos_register, MCA_MOTHERBOARD_SETUP_REG);\r\nmca_dev->name[0] = 0;\r\nmca_read_and_store_pos(mca_dev->pos);\r\nmca_configure_adapter_status(mca_dev);\r\nmca_dev->pos_id = MCA_INTEGVIDEO_POS;\r\nmca_dev->slot = MCA_INTEGVIDEO;\r\nmca_register_device(MCA_PRIMARY_BUS, mca_dev);\r\nfor (i = 0; (which_scsi = mca_builtin_scsi_ports[i]) != 0; i++) {\r\noutb_p(which_scsi, MCA_MOTHERBOARD_SETUP_REG);\r\nif (mca_read_and_store_pos(pos))\r\nbreak;\r\n}\r\nif (which_scsi) {\r\nmca_dev = kzalloc(sizeof(struct mca_device), GFP_ATOMIC);\r\nif (unlikely(!mca_dev))\r\ngoto out_unlock_nomem;\r\nfor (j = 0; j < 8; j++)\r\nmca_dev->pos[j] = pos[j];\r\nmca_configure_adapter_status(mca_dev);\r\nmca_dev->pos_id = MCA_INTEGSCSI_POS;\r\nmca_dev->slot = MCA_INTEGSCSI;\r\nmca_dev->pos_register = which_scsi;\r\nmca_register_device(MCA_PRIMARY_BUS, mca_dev);\r\n}\r\noutb_p(0xff, MCA_MOTHERBOARD_SETUP_REG);\r\nfor (i = 0; i < MCA_MAX_SLOT_NR; i++) {\r\noutb_p(0x8|(i&0xf), MCA_ADAPTER_SETUP_REG);\r\nif (!mca_read_and_store_pos(pos))\r\ncontinue;\r\nmca_dev = kzalloc(sizeof(struct mca_device), GFP_ATOMIC);\r\nif (unlikely(!mca_dev))\r\ngoto out_unlock_nomem;\r\nfor (j = 0; j < 8; j++)\r\nmca_dev->pos[j] = pos[j];\r\nmca_dev->driver_loaded = 0;\r\nmca_dev->slot = i;\r\nmca_dev->pos_register = 0;\r\nmca_configure_adapter_status(mca_dev);\r\nmca_register_device(MCA_PRIMARY_BUS, mca_dev);\r\n}\r\noutb_p(0, MCA_ADAPTER_SETUP_REG);\r\nspin_unlock_irq(&mca_lock);\r\nfor (i = 0; i < MCA_STANDARD_RESOURCES; i++)\r\nrequest_resource(&ioport_resource, mca_standard_resources + i);\r\nmca_do_proc_init();\r\nreturn 0;\r\nout_unlock_nomem:\r\nspin_unlock_irq(&mca_lock);\r\nout_nomem:\r\nprintk(KERN_EMERG "Failed memory allocation in MCA setup!\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic __kprobes void\r\nmca_handle_nmi_device(struct mca_device *mca_dev, int check_flag)\r\n{\r\nint slot = mca_dev->slot;\r\nif (slot == MCA_INTEGSCSI) {\r\nprintk(KERN_CRIT "NMI: caused by MCA integrated SCSI adapter (%s)\n",\r\nmca_dev->name);\r\n} else if (slot == MCA_INTEGVIDEO) {\r\nprintk(KERN_CRIT "NMI: caused by MCA integrated video adapter (%s)\n",\r\nmca_dev->name);\r\n} else if (slot == MCA_MOTHERBOARD) {\r\nprintk(KERN_CRIT "NMI: caused by motherboard (%s)\n",\r\nmca_dev->name);\r\n}\r\nif (check_flag) {\r\nunsigned char pos6, pos7;\r\npos6 = mca_device_read_pos(mca_dev, 6);\r\npos7 = mca_device_read_pos(mca_dev, 7);\r\nprintk(KERN_CRIT "NMI: POS 6 = 0x%x, POS 7 = 0x%x\n", pos6, pos7);\r\n}\r\n}\r\nstatic int __kprobes mca_handle_nmi_callback(struct device *dev, void *data)\r\n{\r\nstruct mca_device *mca_dev = to_mca_device(dev);\r\nunsigned char pos5;\r\npos5 = mca_device_read_pos(mca_dev, 5);\r\nif (!(pos5 & 0x80)) {\r\nmca_handle_nmi_device(mca_dev, !(pos5 & 0x40));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid __kprobes mca_handle_nmi(void)\r\n{\r\nbus_for_each_dev(&mca_bus_type, NULL, NULL, mca_handle_nmi_callback);\r\n}
