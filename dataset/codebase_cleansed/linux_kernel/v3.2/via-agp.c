static int via_fetch_size(void)\r\n{\r\nint i;\r\nu8 temp;\r\nstruct aper_size_info_8 *values;\r\nvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\r\npci_read_config_byte(agp_bridge->dev, VIA_APSIZE, &temp);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nprintk(KERN_ERR PFX "Unknown aperture size from AGP bridge (0x%x)\n", temp);\r\nreturn 0;\r\n}\r\nstatic int via_configure(void)\r\n{\r\nu32 temp;\r\nstruct aper_size_info_8 *current_size;\r\ncurrent_size = A_SIZE_8(agp_bridge->current_size);\r\npci_write_config_byte(agp_bridge->dev, VIA_APSIZE,\r\ncurrent_size->size_value);\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);\r\nagp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\npci_write_config_dword(agp_bridge->dev, VIA_GARTCTRL, 0x0000000f);\r\npci_write_config_dword(agp_bridge->dev, VIA_ATTBASE,\r\n(agp_bridge->gatt_bus_addr & 0xfffff000) | 3);\r\nreturn 0;\r\n}\r\nstatic void via_cleanup(void)\r\n{\r\nstruct aper_size_info_8 *previous_size;\r\nprevious_size = A_SIZE_8(agp_bridge->previous_size);\r\npci_write_config_byte(agp_bridge->dev, VIA_APSIZE,\r\nprevious_size->size_value);\r\n}\r\nstatic void via_tlbflush(struct agp_memory *mem)\r\n{\r\nu32 temp;\r\npci_read_config_dword(agp_bridge->dev, VIA_GARTCTRL, &temp);\r\ntemp |= (1<<7);\r\npci_write_config_dword(agp_bridge->dev, VIA_GARTCTRL, temp);\r\ntemp &= ~(1<<7);\r\npci_write_config_dword(agp_bridge->dev, VIA_GARTCTRL, temp);\r\n}\r\nstatic int via_fetch_size_agp3(void)\r\n{\r\nint i;\r\nu16 temp;\r\nstruct aper_size_info_16 *values;\r\nvalues = A_SIZE_16(agp_bridge->driver->aperture_sizes);\r\npci_read_config_word(agp_bridge->dev, VIA_AGP3_APSIZE, &temp);\r\ntemp &= 0xfff;\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int via_configure_agp3(void)\r\n{\r\nu32 temp;\r\nstruct aper_size_info_16 *current_size;\r\ncurrent_size = A_SIZE_16(agp_bridge->current_size);\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);\r\nagp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\npci_write_config_dword(agp_bridge->dev, VIA_AGP3_ATTBASE,\r\nagp_bridge->gatt_bus_addr & 0xfffff000);\r\npci_read_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, &temp);\r\npci_write_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, temp | (3<<7));\r\nreturn 0;\r\n}\r\nstatic void via_cleanup_agp3(void)\r\n{\r\nstruct aper_size_info_16 *previous_size;\r\nprevious_size = A_SIZE_16(agp_bridge->previous_size);\r\npci_write_config_byte(agp_bridge->dev, VIA_APSIZE, previous_size->size_value);\r\n}\r\nstatic void via_tlbflush_agp3(struct agp_memory *mem)\r\n{\r\nu32 temp;\r\npci_read_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, &temp);\r\npci_write_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, temp & ~(1<<7));\r\npci_write_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, temp);\r\n}\r\nstatic void check_via_agp3 (struct agp_bridge_data *bridge)\r\n{\r\nu8 reg;\r\npci_read_config_byte(bridge->dev, VIA_AGPSEL, &reg);\r\nif ((reg & (1<<1))==0)\r\nbridge->driver = &via_agp3_driver;\r\n}\r\nstatic int __devinit agp_via_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_device_ids *devs = via_agp_device_ids;\r\nstruct agp_bridge_data *bridge;\r\nint j = 0;\r\nu8 cap_ptr;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nj = ent - agp_via_pci_table;\r\nprintk (KERN_INFO PFX "Detected VIA %s chipset\n", devs[j].chipset_name);\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nbridge->driver = &via_driver;\r\nif (pdev->device == PCI_DEVICE_ID_VIA_8367_0) {\r\nif (pdev->subsystem_device == PCI_DEVICE_ID_VIA_8377_0) {\r\nprintk(KERN_INFO PFX "Found KT400 in disguise as a KT266.\n");\r\ncheck_via_agp3(bridge);\r\n}\r\n}\r\nget_agp_version(bridge);\r\nif (bridge->major_version >= 3)\r\ncheck_via_agp3(bridge);\r\npci_read_config_dword(pdev,\r\nbridge->capndx+PCI_AGP_STATUS, &bridge->mode);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void __devexit agp_via_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int agp_via_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state (pdev);\r\npci_set_power_state (pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int agp_via_resume(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\npci_set_power_state (pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (bridge->driver == &via_agp3_driver)\r\nreturn via_configure_agp3();\r\nelse if (bridge->driver == &via_driver)\r\nreturn via_configure();\r\nreturn 0;\r\n}\r\nstatic int __init agp_via_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_via_pci_driver);\r\n}\r\nstatic void __exit agp_via_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_via_pci_driver);\r\n}
