void cx23885_mc417_init(struct cx23885_dev *dev)\r\n{\r\nu32 regval;\r\ndprintk(2, "%s()\n", __func__);\r\nregval = MC417_SPD_CTL(MC417_SPD_CTL_FAST) |\r\nMC417_GPIO_SEL(MC417_GPIO_SEL_GPIO3) |\r\nMC417_UART_GPIO_EN;\r\ncx_write(MC417_CTL, regval);\r\nregval = MC417_MIRDY;\r\ncx_write(MC417_OEN, regval);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS;\r\ncx_write(MC417_RWD, regval);\r\n}\r\nstatic int mc417_wait_ready(struct cx23885_dev *dev)\r\n{\r\nu32 mi_ready;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1);\r\nfor (;;) {\r\nmi_ready = cx_read(MC417_RWD) & MC417_MIRDY;\r\nif (mi_ready != 0)\r\nreturn 0;\r\nif (time_after(jiffies, timeout))\r\nreturn -1;\r\nudelay(1);\r\n}\r\n}\r\nint mc417_register_write(struct cx23885_dev *dev, u16 address, u32 value)\r\n{\r\nu32 regval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0 |\r\n(value & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1 |\r\n((value >> 8) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2 |\r\n((value >> 16) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3 |\r\n((value >> 24) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE0 |\r\n(address & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_MODE |\r\nMCI_MODE_REGISTER_WRITE;\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nreturn mc417_wait_ready(dev);\r\n}\r\nint mc417_register_read(struct cx23885_dev *dev, u16 address, u32 *value)\r\n{\r\nint retval;\r\nu32 regval;\r\nu32 tempval;\r\nu32 dataval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE0 |\r\n((address & 0x00FF));\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_MODE |\r\nMCI_MODE_REGISTER_READ;\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nretval = mc417_wait_ready(dev);\r\ncx_write(MC417_OEN, MC417_MIRDY | MC417_MIDATA);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval = tempval & 0x000000FF;\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 8);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 16);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 24);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\n*value = dataval;\r\nreturn retval;\r\n}\r\nint mc417_memory_write(struct cx23885_dev *dev, u32 address, u32 value)\r\n{\r\nu32 regval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0 |\r\n(value & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1 |\r\n((value >> 8) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2 |\r\n((value >> 16) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3 |\r\n((value >> 24) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE2 |\r\nMCI_MODE_MEMORY_WRITE | ((address >> 16) & 0x3F);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE0 |\r\n(address & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nreturn mc417_wait_ready(dev);\r\n}\r\nint mc417_memory_read(struct cx23885_dev *dev, u32 address, u32 *value)\r\n{\r\nint retval;\r\nu32 regval;\r\nu32 tempval;\r\nu32 dataval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE2 |\r\nMCI_MODE_MEMORY_READ | ((address >> 16) & 0x3F);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE0 |\r\n(address & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nretval = mc417_wait_ready(dev);\r\ncx_write(MC417_OEN, MC417_MIRDY | MC417_MIDATA);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval = ((tempval & 0x000000FF) << 24);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 16);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 8);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= (tempval & 0x000000FF);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\n*value = dataval;\r\nreturn retval;\r\n}\r\nvoid mc417_gpio_set(struct cx23885_dev *dev, u32 mask)\r\n{\r\nu32 val;\r\nmc417_register_read(dev, 0x900C, &val);\r\nval |= (mask & 0x000ffff);\r\nmc417_register_write(dev, 0x900C, val);\r\n}\r\nvoid mc417_gpio_clear(struct cx23885_dev *dev, u32 mask)\r\n{\r\nu32 val;\r\nmc417_register_read(dev, 0x900C, &val);\r\nval &= ~(mask & 0x0000ffff);\r\nmc417_register_write(dev, 0x900C, val);\r\n}\r\nvoid mc417_gpio_enable(struct cx23885_dev *dev, u32 mask, int asoutput)\r\n{\r\nu32 val;\r\nmc417_register_read(dev, 0x9020, &val);\r\nif (asoutput)\r\nval |= (mask & 0x0000ffff);\r\nelse\r\nval &= ~(mask & 0x0000ffff);\r\nmc417_register_write(dev, 0x9020, val);\r\n}\r\nstatic char *cmd_to_str(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase CX2341X_ENC_PING_FW:\r\nreturn "PING_FW";\r\ncase CX2341X_ENC_START_CAPTURE:\r\nreturn "START_CAPTURE";\r\ncase CX2341X_ENC_STOP_CAPTURE:\r\nreturn "STOP_CAPTURE";\r\ncase CX2341X_ENC_SET_AUDIO_ID:\r\nreturn "SET_AUDIO_ID";\r\ncase CX2341X_ENC_SET_VIDEO_ID:\r\nreturn "SET_VIDEO_ID";\r\ncase CX2341X_ENC_SET_PCR_ID:\r\nreturn "SET_PCR_ID";\r\ncase CX2341X_ENC_SET_FRAME_RATE:\r\nreturn "SET_FRAME_RATE";\r\ncase CX2341X_ENC_SET_FRAME_SIZE:\r\nreturn "SET_FRAME_SIZE";\r\ncase CX2341X_ENC_SET_BIT_RATE:\r\nreturn "SET_BIT_RATE";\r\ncase CX2341X_ENC_SET_GOP_PROPERTIES:\r\nreturn "SET_GOP_PROPERTIES";\r\ncase CX2341X_ENC_SET_ASPECT_RATIO:\r\nreturn "SET_ASPECT_RATIO";\r\ncase CX2341X_ENC_SET_DNR_FILTER_MODE:\r\nreturn "SET_DNR_FILTER_MODE";\r\ncase CX2341X_ENC_SET_DNR_FILTER_PROPS:\r\nreturn "SET_DNR_FILTER_PROPS";\r\ncase CX2341X_ENC_SET_CORING_LEVELS:\r\nreturn "SET_CORING_LEVELS";\r\ncase CX2341X_ENC_SET_SPATIAL_FILTER_TYPE:\r\nreturn "SET_SPATIAL_FILTER_TYPE";\r\ncase CX2341X_ENC_SET_VBI_LINE:\r\nreturn "SET_VBI_LINE";\r\ncase CX2341X_ENC_SET_STREAM_TYPE:\r\nreturn "SET_STREAM_TYPE";\r\ncase CX2341X_ENC_SET_OUTPUT_PORT:\r\nreturn "SET_OUTPUT_PORT";\r\ncase CX2341X_ENC_SET_AUDIO_PROPERTIES:\r\nreturn "SET_AUDIO_PROPERTIES";\r\ncase CX2341X_ENC_HALT_FW:\r\nreturn "HALT_FW";\r\ncase CX2341X_ENC_GET_VERSION:\r\nreturn "GET_VERSION";\r\ncase CX2341X_ENC_SET_GOP_CLOSURE:\r\nreturn "SET_GOP_CLOSURE";\r\ncase CX2341X_ENC_GET_SEQ_END:\r\nreturn "GET_SEQ_END";\r\ncase CX2341X_ENC_SET_PGM_INDEX_INFO:\r\nreturn "SET_PGM_INDEX_INFO";\r\ncase CX2341X_ENC_SET_VBI_CONFIG:\r\nreturn "SET_VBI_CONFIG";\r\ncase CX2341X_ENC_SET_DMA_BLOCK_SIZE:\r\nreturn "SET_DMA_BLOCK_SIZE";\r\ncase CX2341X_ENC_GET_PREV_DMA_INFO_MB_10:\r\nreturn "GET_PREV_DMA_INFO_MB_10";\r\ncase CX2341X_ENC_GET_PREV_DMA_INFO_MB_9:\r\nreturn "GET_PREV_DMA_INFO_MB_9";\r\ncase CX2341X_ENC_SCHED_DMA_TO_HOST:\r\nreturn "SCHED_DMA_TO_HOST";\r\ncase CX2341X_ENC_INITIALIZE_INPUT:\r\nreturn "INITIALIZE_INPUT";\r\ncase CX2341X_ENC_SET_FRAME_DROP_RATE:\r\nreturn "SET_FRAME_DROP_RATE";\r\ncase CX2341X_ENC_PAUSE_ENCODER:\r\nreturn "PAUSE_ENCODER";\r\ncase CX2341X_ENC_REFRESH_INPUT:\r\nreturn "REFRESH_INPUT";\r\ncase CX2341X_ENC_SET_COPYRIGHT:\r\nreturn "SET_COPYRIGHT";\r\ncase CX2341X_ENC_SET_EVENT_NOTIFICATION:\r\nreturn "SET_EVENT_NOTIFICATION";\r\ncase CX2341X_ENC_SET_NUM_VSYNC_LINES:\r\nreturn "SET_NUM_VSYNC_LINES";\r\ncase CX2341X_ENC_SET_PLACEHOLDER:\r\nreturn "SET_PLACEHOLDER";\r\ncase CX2341X_ENC_MUTE_VIDEO:\r\nreturn "MUTE_VIDEO";\r\ncase CX2341X_ENC_MUTE_AUDIO:\r\nreturn "MUTE_AUDIO";\r\ncase CX2341X_ENC_MISC:\r\nreturn "MISC";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic int cx23885_mbox_func(void *priv,\r\nu32 command,\r\nint in,\r\nint out,\r\nu32 data[CX2341X_MBOX_MAX_DATA])\r\n{\r\nstruct cx23885_dev *dev = priv;\r\nunsigned long timeout;\r\nu32 value, flag, retval = 0;\r\nint i;\r\ndprintk(3, "%s: command(0x%X) = %s\n", __func__, command,\r\ncmd_to_str(command));\r\nmc417_memory_read(dev, dev->cx23417_mailbox - 4, &value);\r\nif (value != 0x12345678) {\r\nprintk(KERN_ERR\r\n"Firmware and/or mailbox pointer not initialized "\r\n"or corrupted, signature = 0x%x, cmd = %s\n", value,\r\ncmd_to_str(command));\r\nreturn -1;\r\n}\r\nmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\r\nif (flag) {\r\nprintk(KERN_ERR "ERROR: Mailbox appears to be in use "\r\n"(%x), cmd = %s\n", flag, cmd_to_str(command));\r\nreturn -1;\r\n}\r\nflag |= 1;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 1, command);\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 3,\r\nIVTV_API_STD_TIMEOUT);\r\nfor (i = 0; i < in; i++) {\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, data[i]);\r\ndprintk(3, "API Input %d = %d\n", i, data[i]);\r\n}\r\nfor (; i < CX2341X_MBOX_MAX_DATA; i++)\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, 0);\r\nflag |= 3;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\ntimeout = jiffies + msecs_to_jiffies(10);\r\nfor (;;) {\r\nmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\r\nif (0 != (flag & 4))\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\nprintk(KERN_ERR "ERROR: API Mailbox timeout\n");\r\nreturn -1;\r\n}\r\nudelay(10);\r\n}\r\nfor (i = 0; i < out; i++) {\r\nmc417_memory_read(dev, dev->cx23417_mailbox + 4 + i, data + i);\r\ndprintk(3, "API Output %d = %d\n", i, data[i]);\r\n}\r\nmc417_memory_read(dev, dev->cx23417_mailbox + 2, &retval);\r\ndprintk(3, "API result = %d\n", retval);\r\nflag = 0;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\nreturn retval;\r\n}\r\nstatic int cx23885_api_cmd(struct cx23885_dev *dev,\r\nu32 command,\r\nu32 inputcnt,\r\nu32 outputcnt,\r\n...)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nva_list vargs;\r\nint i, err;\r\ndprintk(3, "%s() cmds = 0x%08x\n", __func__, command);\r\nva_start(vargs, outputcnt);\r\nfor (i = 0; i < inputcnt; i++)\r\ndata[i] = va_arg(vargs, int);\r\nerr = cx23885_mbox_func(dev, command, inputcnt, outputcnt, data);\r\nfor (i = 0; i < outputcnt; i++) {\r\nint *vptr = va_arg(vargs, int *);\r\n*vptr = data[i];\r\n}\r\nva_end(vargs);\r\nreturn err;\r\n}\r\nstatic int cx23885_find_mailbox(struct cx23885_dev *dev)\r\n{\r\nu32 signature[4] = {\r\n0x12345678, 0x34567812, 0x56781234, 0x78123456\r\n};\r\nint signaturecnt = 0;\r\nu32 value;\r\nint i;\r\ndprintk(2, "%s()\n", __func__);\r\nfor (i = 0; i < CX23885_FIRM_IMAGE_SIZE; i++) {\r\nmc417_memory_read(dev, i, &value);\r\nif (value == signature[signaturecnt])\r\nsignaturecnt++;\r\nelse\r\nsignaturecnt = 0;\r\nif (4 == signaturecnt) {\r\ndprintk(1, "Mailbox signature found at 0x%x\n", i+1);\r\nreturn i+1;\r\n}\r\n}\r\nprintk(KERN_ERR "Mailbox signature values not found!\n");\r\nreturn -1;\r\n}\r\nstatic int cx23885_load_firmware(struct cx23885_dev *dev)\r\n{\r\nstatic const unsigned char magic[8] = {\r\n0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\r\n};\r\nconst struct firmware *firmware;\r\nint i, retval = 0;\r\nu32 value = 0;\r\nu32 gpio_output = 0;\r\nu32 checksum = 0;\r\nu32 *dataptr;\r\ndprintk(2, "%s()\n", __func__);\r\nretval |= mc417_memory_read(dev, 0x9020, &gpio_output);\r\nretval |= mc417_memory_read(dev, 0x900C, &value);\r\nretval = mc417_register_write(dev,\r\nIVTV_REG_VPU, 0xFFFFFFED);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_ENC_SDRAM_REFRESH, 0x80000800);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_ENC_SDRAM_PRECHARGE, 0x1A);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_APU, 0);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "%s: Error with mc417_register_write\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nretval = request_firmware(&firmware, CX23885_FIRM_IMAGE_NAME,\r\n&dev->pci->dev);\r\nif (retval != 0) {\r\nprintk(KERN_ERR\r\n"ERROR: Hotplug firmware request failed (%s).\n",\r\nCX23885_FIRM_IMAGE_NAME);\r\nprintk(KERN_ERR "Please fix your hotplug setup, the board will "\r\n"not work without firmware loaded!\n");\r\nreturn -1;\r\n}\r\nif (firmware->size != CX23885_FIRM_IMAGE_SIZE) {\r\nprintk(KERN_ERR "ERROR: Firmware size mismatch "\r\n"(have %zd, expected %d)\n",\r\nfirmware->size, CX23885_FIRM_IMAGE_SIZE);\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nif (0 != memcmp(firmware->data, magic, 8)) {\r\nprintk(KERN_ERR\r\n"ERROR: Firmware magic mismatch, wrong file?\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\ndprintk(2, "Loading firmware ...\n");\r\ndataptr = (u32 *)firmware->data;\r\nfor (i = 0; i < (firmware->size >> 2); i++) {\r\nvalue = *dataptr;\r\nchecksum += ~value;\r\nif (mc417_memory_write(dev, i, value) != 0) {\r\nprintk(KERN_ERR "ERROR: Loading firmware failed!\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\ndataptr++;\r\n}\r\ndprintk(1, "Verifying firmware ...\n");\r\nfor (i--; i >= 0; i--) {\r\nif (mc417_memory_read(dev, i, &value) != 0) {\r\nprintk(KERN_ERR "ERROR: Reading firmware failed!\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nchecksum -= ~value;\r\n}\r\nif (checksum) {\r\nprintk(KERN_ERR\r\n"ERROR: Firmware load failed (checksum mismatch).\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nrelease_firmware(firmware);\r\ndprintk(1, "Firmware upload successful.\n");\r\nretval |= mc417_register_write(dev, IVTV_REG_HW_BLOCKS,\r\nIVTV_CMD_HW_BLOCKS_RST);\r\nretval |= mc417_register_write(dev, 0x9020, gpio_output);\r\nretval |= mc417_register_write(dev, 0x900C, value);\r\nretval |= mc417_register_read(dev, IVTV_REG_VPU, &value);\r\nretval |= mc417_register_write(dev, IVTV_REG_VPU, value & 0xFFFFFFE8);\r\nif (retval < 0)\r\nprintk(KERN_ERR "%s: Error with mc417_register_write\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nvoid cx23885_417_check_encoder(struct cx23885_dev *dev)\r\n{\r\nu32 status, seq;\r\nstatus = seq = 0;\r\ncx23885_api_cmd(dev, CX2341X_ENC_GET_SEQ_END, 0, 2, &status, &seq);\r\ndprintk(1, "%s() status = %d, seq = %d\n", __func__, status, seq);\r\n}\r\nstatic void cx23885_codec_settings(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\r\ndev->ts1.height, dev->ts1.width);\r\ndev->mpeg_params.width = dev->ts1.width;\r\ndev->mpeg_params.height = dev->ts1.height;\r\ndev->mpeg_params.is_50hz =\r\n(dev->encodernorm.id & V4L2_STD_625_50) != 0;\r\ncx2341x_update(dev, cx23885_mbox_func, NULL, &dev->mpeg_params);\r\ncx23885_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 3, 1);\r\ncx23885_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 4, 1);\r\n}\r\nstatic int cx23885_initialize_codec(struct cx23885_dev *dev)\r\n{\r\nint version;\r\nint retval;\r\nu32 i, data[7];\r\ndprintk(1, "%s()\n", __func__);\r\nretval = cx23885_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\ndprintk(2, "%s() PING OK\n", __func__);\r\nretval = cx23885_load_firmware(dev);\r\nif (retval < 0) {\r\nprintk(KERN_ERR "%s() f/w load failed\n", __func__);\r\nreturn retval;\r\n}\r\nretval = cx23885_find_mailbox(dev);\r\nif (retval < 0) {\r\nprintk(KERN_ERR "%s() mailbox < 0, error\n",\r\n__func__);\r\nreturn -1;\r\n}\r\ndev->cx23417_mailbox = retval;\r\nretval = cx23885_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\nprintk(KERN_ERR\r\n"ERROR: cx23417 firmware ping failed!\n");\r\nreturn -1;\r\n}\r\nretval = cx23885_api_cmd(dev, CX2341X_ENC_GET_VERSION, 0, 1,\r\n&version);\r\nif (retval < 0) {\r\nprintk(KERN_ERR "ERROR: cx23417 firmware get encoder :"\r\n"version failed!\n");\r\nreturn -1;\r\n}\r\ndprintk(1, "cx23417 firmware version is 0x%08x\n", version);\r\nmsleep(200);\r\n}\r\ncx23885_codec_settings(dev);\r\nmsleep(60);\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, 0,\r\nCX23885_FIELD1_SAA7115, CX23885_FIELD2_SAA7115);\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_PLACEHOLDER, 12, 0,\r\nCX23885_CUSTOM_EXTENSION_USR_DATA, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0);\r\ndata[0] = 0x0001BD00;\r\ndata[1] = 1;\r\ndata[2] = 4;\r\ndata[3] = 0x91559155;\r\ndata[4] = 0x206080C0;\r\ndata[5] = 6;\r\ndata[6] = 64;\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_CONFIG, 7, 0, data[0], data[1],\r\ndata[2], data[3], data[4], data[5], data[6]);\r\nfor (i = 2; i <= 24; i++) {\r\nint valid;\r\nvalid = ((i >= 19) && (i <= 21));\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0, i,\r\nvalid, 0 , 0, 0);\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0,\r\ni | 0x80000000, valid, 0, 0, 0);\r\n}\r\ncx23885_api_cmd(dev, CX2341X_ENC_MUTE_AUDIO, 1, 0, CX23885_UNMUTE);\r\nmsleep(60);\r\ncx23885_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\r\nmsleep(60);\r\nmc417_memory_write(dev, 2120, 0x00000080);\r\ncx23885_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\r\nCX23885_MPEG_CAPTURE, CX23885_RAW_BITS_NONE);\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nstatic int bb_buf_setup(struct videobuf_queue *q,\r\nunsigned int *count, unsigned int *size)\r\n{\r\nstruct cx23885_fh *fh = q->priv_data;\r\nfh->dev->ts1.ts_packet_size = mpeglinesize;\r\nfh->dev->ts1.ts_packet_count = mpeglines;\r\n*size = fh->dev->ts1.ts_packet_size * fh->dev->ts1.ts_packet_count;\r\n*count = mpegbufs;\r\nreturn 0;\r\n}\r\nstatic int bb_buf_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct cx23885_fh *fh = q->priv_data;\r\nreturn cx23885_buf_prepare(q, &fh->dev->ts1,\r\n(struct cx23885_buffer *)vb,\r\nfield);\r\n}\r\nstatic void bb_buf_queue(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx23885_fh *fh = q->priv_data;\r\ncx23885_buf_queue(&fh->dev->ts1, (struct cx23885_buffer *)vb);\r\n}\r\nstatic void bb_buf_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\ncx23885_free_buffer(q, (struct cx23885_buffer *)vb);\r\n}\r\nstatic int cx23885_queryctrl(struct cx23885_dev *dev,\r\nstruct v4l2_queryctrl *qctrl)\r\n{\r\nqctrl->id = v4l2_ctrl_next(ctrl_classes, qctrl->id);\r\nif (qctrl->id == 0)\r\nreturn -EINVAL;\r\nif (cx2341x_ctrl_query(&dev->mpeg_params, qctrl))\r\nqctrl->flags |= V4L2_CTRL_FLAG_DISABLED;\r\nreturn 0;\r\n}\r\nstatic int cx23885_querymenu(struct cx23885_dev *dev,\r\nstruct v4l2_querymenu *qmenu)\r\n{\r\nstruct v4l2_queryctrl qctrl;\r\nqctrl.id = qmenu->id;\r\ncx23885_queryctrl(dev, &qctrl);\r\nreturn v4l2_ctrl_query_menu(qmenu, &qctrl,\r\ncx2341x_ctrl_get_menu(&dev->mpeg_params, qmenu->id));\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(cx23885_tvnorms); i++)\r\nif (*id & cx23885_tvnorms[i].id)\r\nbreak;\r\nif (i == ARRAY_SIZE(cx23885_tvnorms))\r\nreturn -EINVAL;\r\ndev->encodernorm = cx23885_tvnorms[i];\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nstruct cx23885_input *input;\r\nint n;\r\nif (i->index >= 4)\r\nreturn -EINVAL;\r\ninput = &cx23885_boards[dev->board].input[i->index];\r\nif (input->type == 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name, "unset");\r\nif (input->type == CX23885_VMUX_TELEVISION ||\r\ninput->type == CX23885_VMUX_CABLE)\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nelse\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nfor (n = 0; n < ARRAY_SIZE(cx23885_tvnorms); n++)\r\ni->std |= cx23885_tvnorms[n].id;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\n*i = dev->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i >= 4)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nif (UNSET == dev->tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\ncall_all(dev, tuner, g_tuner, t);\r\ndprintk(1, "VIDIOC_G_TUNER: tuner type %d\n", t->type);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nif (UNSET == dev->tuner_type)\r\nreturn -EINVAL;\r\ncall_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nif (UNSET == dev->tuner_type)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_ANALOG_TV;\r\nf->frequency = dev->freq;\r\ncall_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\ncx23885_api_cmd(fh->dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\r\nCX23885_END_NOW, CX23885_MPEG_CAPTURE,\r\nCX23885_RAW_BITS_NONE);\r\ndprintk(1, "VIDIOC_S_FREQUENCY: dev type %d, f\n",\r\ndev->tuner_type);\r\ndprintk(1, "VIDIOC_S_FREQUENCY: f tuner %d, f type %d\n",\r\nf->tuner, f->type);\r\nif (UNSET == dev->tuner_type)\r\nreturn -EINVAL;\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nif (f->type != V4L2_TUNER_ANALOG_TV)\r\nreturn -EINVAL;\r\ndev->freq = f->frequency;\r\ncall_all(dev, tuner, s_frequency, f);\r\ncx23885_initialize_codec(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\ncall_all(dev, core, s_ctrl, ctl);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nstruct cx23885_tsport *tsport = &dev->ts1;\r\nstrlcpy(cap->driver, dev->name, sizeof(cap->driver));\r\nstrlcpy(cap->card, cx23885_boards[tsport->dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncap->capabilities =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\n0;\r\nif (UNSET != dev->tuner_type)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\ndev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.width = dev->ts1.width;\r\nf->fmt.pix.height = dev->ts1.height;\r\nf->fmt.pix.field = fh->mpegq.field;\r\ndprintk(1, "VIDIOC_G_FMT: w: %d, h: %d, f: %d\n",\r\ndev->ts1.width, dev->ts1.height, fh->mpegq.field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\ndev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\ndprintk(1, "VIDIOC_TRY_FMT: w: %d, h: %d, f: %d\n",\r\ndev->ts1.width, dev->ts1.height, fh->mpegq.field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\ndev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\ndprintk(1, "VIDIOC_S_FMT: w: %d, h: %d, f: %d\n",\r\nf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nreturn videobuf_reqbufs(&fh->mpegq, p);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nreturn videobuf_querybuf(&fh->mpegq, p);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nreturn videobuf_qbuf(&fh->mpegq, p);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nreturn videobuf_dqbuf(&fh->mpegq, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nreturn videobuf_streamon(&fh->mpegq);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nreturn videobuf_streamoff(&fh->mpegq);\r\n}\r\nstatic int vidioc_g_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *f)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nif (f->ctrl_class != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\nreturn cx2341x_ext_ctrls(&dev->mpeg_params, 0, f, VIDIOC_G_EXT_CTRLS);\r\n}\r\nstatic int vidioc_s_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *f)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nstruct cx2341x_mpeg_params p;\r\nint err;\r\nif (f->ctrl_class != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\np = dev->mpeg_params;\r\nerr = cx2341x_ext_ctrls(&p, 0, f, VIDIOC_S_EXT_CTRLS);\r\nif (err == 0) {\r\nerr = cx2341x_update(dev, cx23885_mbox_func,\r\n&dev->mpeg_params, &p);\r\ndev->mpeg_params = p;\r\n}\r\nreturn err;\r\n}\r\nstatic int vidioc_try_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *f)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nstruct cx2341x_mpeg_params p;\r\nint err;\r\nif (f->ctrl_class != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\np = dev->mpeg_params;\r\nerr = cx2341x_ext_ctrls(&p, 0, f, VIDIOC_TRY_EXT_CTRLS);\r\nreturn err;\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nchar name[32 + 2];\r\nsnprintf(name, sizeof(name), "%s/2", dev->name);\r\nprintk(KERN_INFO\r\n"%s/2: ============ START LOG STATUS ============\n",\r\ndev->name);\r\ncall_all(dev, core, log_status);\r\ncx2341x_log_status(&dev->mpeg_params, name);\r\nprintk(KERN_INFO\r\n"%s/2: ============= END LOG STATUS =============\n",\r\ndev->name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querymenu(struct file *file, void *priv,\r\nstruct v4l2_querymenu *a)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nreturn cx23885_querymenu(dev, a);\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nreturn cx23885_queryctrl(dev, c);\r\n}\r\nstatic int mpeg_open(struct file *file)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nstruct cx23885_fh *fh;\r\ndprintk(2, "%s()\n", __func__);\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (!fh)\r\nreturn -ENOMEM;\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nvideobuf_queue_sg_init(&fh->mpegq, &cx23885_qops,\r\n&dev->pci->dev, &dev->ts1.slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct cx23885_buffer),\r\nfh, NULL);\r\nreturn 0;\r\n}\r\nstatic int mpeg_release(struct file *file)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\ndprintk(2, "%s()\n", __func__);\r\nif (atomic_cmpxchg(&fh->v4l_reading, 1, 0) == 1) {\r\nif (atomic_dec_return(&dev->v4l_reader_count) == 0) {\r\ncx23885_api_cmd(fh->dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\r\nCX23885_END_NOW, CX23885_MPEG_CAPTURE,\r\nCX23885_RAW_BITS_NONE);\r\nmsleep(500);\r\ncx23885_417_check_encoder(dev);\r\ncx23885_cancel_buffers(&fh->dev->ts1);\r\n}\r\n}\r\nif (fh->mpegq.streaming)\r\nvideobuf_streamoff(&fh->mpegq);\r\nif (fh->mpegq.reading)\r\nvideobuf_read_stop(&fh->mpegq);\r\nvideobuf_mmap_free(&fh->mpegq);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic ssize_t mpeg_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\ndprintk(2, "%s()\n", __func__);\r\nif (atomic_cmpxchg(&fh->v4l_reading, 0, 1) == 0) {\r\nif (atomic_inc_return(&dev->v4l_reader_count) == 1) {\r\nif (cx23885_initialize_codec(dev) < 0)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn videobuf_read_stream(&fh->mpegq, data, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic unsigned int mpeg_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\ndprintk(2, "%s\n", __func__);\r\nreturn videobuf_poll_stream(file, &fh->mpegq, wait);\r\n}\r\nstatic int mpeg_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\ndprintk(2, "%s()\n", __func__);\r\nreturn videobuf_mmap_mapper(&fh->mpegq, vma);\r\n}\r\nvoid cx23885_417_unregister(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nif (dev->v4l_device) {\r\nif (video_is_registered(dev->v4l_device))\r\nvideo_unregister_device(dev->v4l_device);\r\nelse\r\nvideo_device_release(dev->v4l_device);\r\ndev->v4l_device = NULL;\r\n}\r\n}\r\nstatic struct video_device *cx23885_video_dev_alloc(\r\nstruct cx23885_tsport *tsport,\r\nstruct pci_dev *pci,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\nstruct cx23885_dev *dev = tsport->dev;\r\ndprintk(1, "%s()\n", __func__);\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s (%s)", dev->name,\r\ntype, cx23885_boards[tsport->dev->board].name);\r\nvfd->parent = &pci->dev;\r\nvfd->release = video_device_release;\r\nreturn vfd;\r\n}\r\nint cx23885_417_register(struct cx23885_dev *dev)\r\n{\r\nint err = -ENODEV;\r\nstruct cx23885_tsport *tsport = &dev->ts1;\r\ndprintk(1, "%s()\n", __func__);\r\nif (cx23885_boards[dev->board].portb != CX23885_MPEG_ENCODER)\r\nreturn err;\r\ndev->encodernorm = cx23885_tvnorms[0];\r\nif (dev->encodernorm.id & V4L2_STD_525_60)\r\ntsport->height = 480;\r\nelse\r\ntsport->height = 576;\r\ntsport->width = 720;\r\ncx2341x_fill_defaults(&dev->mpeg_params);\r\ndev->mpeg_params.port = CX2341X_PORT_SERIAL;\r\ndev->v4l_device = cx23885_video_dev_alloc(tsport,\r\ndev->pci, &cx23885_mpeg_template, "mpeg");\r\nvideo_set_drvdata(dev->v4l_device, dev);\r\nerr = video_register_device(dev->v4l_device,\r\nVFL_TYPE_GRABBER, -1);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register mpeg device\n", dev->name);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s [mpeg]\n",\r\ndev->name, video_device_node_name(dev->v4l_device));\r\nreturn 0;\r\n}
