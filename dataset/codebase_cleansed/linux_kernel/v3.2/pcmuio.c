static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint sdev_no, chans_left, n_subdevs, port, asic, thisasic_chanct = 0;\r\nunsigned long iobase;\r\nunsigned int irq[MAX_ASICS];\r\niobase = it->options[0];\r\nirq[0] = it->options[1];\r\nirq[1] = it->options[2];\r\nprintk("comedi%d: %s: io: %lx ", dev->minor, driver.driver_name,\r\niobase);\r\ndev->iobase = iobase;\r\nif (!iobase || !request_region(iobase,\r\nthisboard->num_asics * ASIC_IOSIZE,\r\ndriver.driver_name)) {\r\nprintk("I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->board_name = thisboard->name;\r\nif (alloc_private(dev, sizeof(struct pcmuio_private)) < 0) {\r\nprintk("cannot allocate private data structure\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (asic = 0; asic < MAX_ASICS; ++asic) {\r\ndevpriv->asics[asic].num = asic;\r\ndevpriv->asics[asic].iobase = dev->iobase + asic * ASIC_IOSIZE;\r\ndevpriv->asics[asic].irq = 0;\r\nspin_lock_init(&devpriv->asics[asic].spinlock);\r\n}\r\nchans_left = CHANS_PER_ASIC * thisboard->num_asics;\r\nn_subdevs = CALC_N_SUBDEVS(chans_left);\r\ndevpriv->sprivs =\r\nkcalloc(n_subdevs, sizeof(struct pcmuio_subdev_private),\r\nGFP_KERNEL);\r\nif (!devpriv->sprivs) {\r\nprintk("cannot allocate subdevice private data structures\n");\r\nreturn -ENOMEM;\r\n}\r\nif (alloc_subdevices(dev, n_subdevs) < 0) {\r\nprintk("cannot allocate subdevice data structures\n");\r\nreturn -ENOMEM;\r\n}\r\nport = 0;\r\nasic = 0;\r\nfor (sdev_no = 0; sdev_no < (int)dev->n_subdevices; ++sdev_no) {\r\nint byte_no;\r\ns = dev->subdevices + sdev_no;\r\ns->private = devpriv->sprivs + sdev_no;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->insn_bits = pcmuio_dio_insn_bits;\r\ns->insn_config = pcmuio_dio_insn_config;\r\ns->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);\r\nsubpriv->intr.asic = -1;\r\nsubpriv->intr.first_chan = -1;\r\nsubpriv->intr.asic_chan = -1;\r\nsubpriv->intr.num_asic_chans = -1;\r\nsubpriv->intr.active = 0;\r\ns->len_chanlist = 1;\r\nfor (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {\r\nif (port >= PORTS_PER_ASIC) {\r\nport = 0;\r\n++asic;\r\nthisasic_chanct = 0;\r\n}\r\nsubpriv->iobases[byte_no] =\r\ndevpriv->asics[asic].iobase + port;\r\nif (thisasic_chanct <\r\nCHANS_PER_PORT * INTR_PORTS_PER_ASIC\r\n&& subpriv->intr.asic < 0) {\r\nsubpriv->intr.asic = asic;\r\nsubpriv->intr.active = 0;\r\nsubpriv->intr.stop_count = 0;\r\nsubpriv->intr.first_chan = byte_no * 8;\r\nsubpriv->intr.asic_chan = thisasic_chanct;\r\nsubpriv->intr.num_asic_chans =\r\ns->n_chan - subpriv->intr.first_chan;\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->cancel = pcmuio_cancel;\r\ns->do_cmd = pcmuio_cmd;\r\ns->do_cmdtest = pcmuio_cmdtest;\r\ns->len_chanlist = subpriv->intr.num_asic_chans;\r\n}\r\nthisasic_chanct += CHANS_PER_PORT;\r\n}\r\nspin_lock_init(&subpriv->intr.spinlock);\r\nchans_left -= s->n_chan;\r\nif (!chans_left) {\r\nasic = 0;\r\nport = 0;\r\n}\r\n}\r\ninit_asics(dev);\r\nfor (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {\r\nif (irq[asic]\r\n&& request_irq(irq[asic], interrupt_pcmuio,\r\nIRQF_SHARED, thisboard->name, dev)) {\r\nint i;\r\nfor (i = asic - 1; i >= 0; --i) {\r\nfree_irq(irq[i], dev);\r\ndevpriv->asics[i].irq = irq[i] = 0;\r\n}\r\nirq[asic] = 0;\r\n}\r\ndevpriv->asics[asic].irq = irq[asic];\r\n}\r\ndev->irq = irq[0];\r\nif (irq[0]) {\r\nprintk("irq: %u ", irq[0]);\r\nif (irq[1] && thisboard->num_asics == 2)\r\nprintk("second ASIC irq: %u ", irq[1]);\r\n} else {\r\nprintk("(IRQ mode disabled) ");\r\n}\r\nprintk("attached\n");\r\nreturn 1;\r\n}\r\nstatic int pcmuio_detach(struct comedi_device *dev)\r\n{\r\nint i;\r\nprintk("comedi%d: %s: remove\n", dev->minor, driver.driver_name);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);\r\nfor (i = 0; i < MAX_ASICS; ++i) {\r\nif (devpriv->asics[i].irq)\r\nfree_irq(devpriv->asics[i].irq, dev);\r\n}\r\nif (devpriv && devpriv->sprivs)\r\nkfree(devpriv->sprivs);\r\nreturn 0;\r\n}\r\nstatic int pcmuio_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint byte_no;\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk("write mask: %08x data: %08x\n", data[0], data[1]);\r\n#endif\r\ns->state = 0;\r\nfor (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {\r\nunsigned long ioaddr = subpriv->iobases[byte_no],\r\noffset = byte_no * 8;\r\nunsigned char byte = 0,\r\nwrite_mask_byte = (data[0] >> offset) & 0xff,\r\ndata_byte = (data[1] >> offset) & 0xff;\r\nbyte = inb(ioaddr);\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk\r\n("byte %d wmb %02x db %02x offset %02d io %04x, data_in %02x ",\r\nbyte_no, (unsigned)write_mask_byte, (unsigned)data_byte,\r\noffset, ioaddr, (unsigned)byte);\r\n#endif\r\nif (write_mask_byte) {\r\nbyte &= ~write_mask_byte;\r\nbyte |= ~data_byte & write_mask_byte;\r\noutb(byte, ioaddr);\r\n}\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk("data_out_byte %02x\n", (unsigned)byte);\r\n#endif\r\ns->state |= ((unsigned int)byte) << offset;\r\n}\r\ndata[1] = ~s->state;\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk("s->state %08x data_out %08x\n", s->state, data[1]);\r\n#endif\r\nreturn 2;\r\n}\r\nstatic int pcmuio_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =\r\nchan % 8;\r\nunsigned long ioaddr;\r\nunsigned char byte;\r\nioaddr = subpriv->iobases[byte_no];\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= 1 << chan;\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\nbyte = inb(ioaddr);\r\nbyte &= ~(1 << bit_no);\r\noutb(byte, ioaddr);\r\ns->io_bits &= ~(1 << chan);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void init_asics(struct comedi_device *dev)\r\n{\r\nint asic;\r\nfor (asic = 0; asic < thisboard->num_asics; ++asic) {\r\nint port, page;\r\nunsigned long baseaddr = dev->iobase + asic * ASIC_IOSIZE;\r\nswitch_page(dev, asic, 0);\r\nfor (port = 0; port < PORTS_PER_ASIC; ++port)\r\noutb(0, baseaddr + REG_PORT0 + port);\r\nfor (page = 1; page < NUM_PAGES; ++page) {\r\nint reg;\r\nswitch_page(dev, asic, page);\r\nfor (reg = FIRST_PAGED_REG;\r\nreg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)\r\noutb(0, baseaddr + reg);\r\n}\r\nswitch_page(dev, asic, 0);\r\n}\r\n}\r\nstatic void switch_page(struct comedi_device *dev, int asic, int page)\r\n{\r\nif (asic < 0 || asic >= thisboard->num_asics)\r\nreturn;\r\nif (page < 0 || page >= NUM_PAGES)\r\nreturn;\r\ndevpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;\r\ndevpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;\r\noutb(devpriv->asics[asic].pagelock,\r\ndev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);\r\n}\r\nstatic void lock_port(struct comedi_device *dev, int asic, int port)\r\n{\r\nif (asic < 0 || asic >= thisboard->num_asics)\r\nreturn;\r\nif (port < 0 || port >= PORTS_PER_ASIC)\r\nreturn;\r\ndevpriv->asics[asic].pagelock |= 0x1 << port;\r\noutb(devpriv->asics[asic].pagelock,\r\ndev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);\r\n}\r\nstatic void unlock_port(struct comedi_device *dev, int asic, int port)\r\n{\r\nif (asic < 0 || asic >= thisboard->num_asics)\r\nreturn;\r\nif (port < 0 || port >= PORTS_PER_ASIC)\r\nreturn;\r\ndevpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;\r\noutb(devpriv->asics[asic].pagelock,\r\ndev->iobase + ASIC_IOSIZE * asic + REG_PAGELOCK);\r\n}\r\nstatic irqreturn_t interrupt_pcmuio(int irq, void *d)\r\n{\r\nint asic, got1 = 0;\r\nstruct comedi_device *dev = (struct comedi_device *)d;\r\nfor (asic = 0; asic < MAX_ASICS; ++asic) {\r\nif (irq == devpriv->asics[asic].irq) {\r\nunsigned long flags;\r\nunsigned triggered = 0;\r\nunsigned long iobase = devpriv->asics[asic].iobase;\r\nunsigned char int_pend;\r\nspin_lock_irqsave(&devpriv->asics[asic].spinlock,\r\nflags);\r\nint_pend = inb(iobase + REG_INT_PENDING) & 0x07;\r\nif (int_pend) {\r\nint port;\r\nfor (port = 0; port < INTR_PORTS_PER_ASIC;\r\n++port) {\r\nif (int_pend & (0x1 << port)) {\r\nunsigned char\r\nio_lines_with_edges = 0;\r\nswitch_page(dev, asic,\r\nPAGE_INT_ID);\r\nio_lines_with_edges =\r\ninb(iobase +\r\nREG_INT_ID0 + port);\r\nif (io_lines_with_edges)\r\noutb(0, iobase +\r\nREG_INT_ID0 +\r\nport);\r\ntriggered |=\r\nio_lines_with_edges <<\r\nport * 8;\r\n}\r\n}\r\n++got1;\r\n}\r\nspin_unlock_irqrestore(&devpriv->asics[asic].spinlock,\r\nflags);\r\nif (triggered) {\r\nstruct comedi_subdevice *s;\r\nprintk\r\n("PCMUIO DEBUG: got edge detect interrupt %d asic %d which_chans: %06x\n",\r\nirq, asic, triggered);\r\nfor (s = dev->subdevices;\r\ns < dev->subdevices + dev->n_subdevices;\r\n++s) {\r\nif (subpriv->intr.asic == asic) {\r\nunsigned long flags;\r\nunsigned oldevents;\r\nspin_lock_irqsave(&subpriv->\r\nintr.spinlock,\r\nflags);\r\noldevents = s->async->events;\r\nif (subpriv->intr.active) {\r\nunsigned mytrig =\r\n((triggered >>\r\nsubpriv->intr.asic_chan)\r\n&\r\n((0x1 << subpriv->\r\nintr.\r\nnum_asic_chans) -\r\n1)) << subpriv->\r\nintr.first_chan;\r\nif (mytrig &\r\nsubpriv->intr.enabled_mask)\r\n{\r\nunsigned int val\r\n= 0;\r\nunsigned int n,\r\nch, len;\r\nlen =\r\ns->\r\nasync->cmd.chanlist_len;\r\nfor (n = 0;\r\nn < len;\r\nn++) {\r\nch = CR_CHAN(s->async->cmd.chanlist[n]);\r\nif (mytrig & (1U << ch)) {\r\nval |= (1U << n);\r\n}\r\n}\r\nif (comedi_buf_put(s->async, ((short *)&val)[0])\r\n&&\r\ncomedi_buf_put\r\n(s->async,\r\n((short *)\r\n&val)[1]))\r\n{\r\ns->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);\r\n} else {\r\npcmuio_stop_intr\r\n(dev,\r\ns);\r\n}\r\nif (!subpriv->intr.continuous) {\r\nif (subpriv->intr.stop_count > 0) {\r\nsubpriv->intr.stop_count--;\r\nif (subpriv->intr.stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\npcmuio_stop_intr\r\n(dev,\r\ns);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore\r\n(&subpriv->intr.spinlock,\r\nflags);\r\nif (oldevents !=\r\ns->async->events) {\r\ncomedi_event(dev, s);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (!got1)\r\nreturn IRQ_NONE;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pcmuio_stop_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint nports, firstport, asic, port;\r\nasic = subpriv->intr.asic;\r\nif (asic < 0)\r\nreturn;\r\nsubpriv->intr.enabled_mask = 0;\r\nsubpriv->intr.active = 0;\r\ns->async->inttrig = 0;\r\nnports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;\r\nfirstport = subpriv->intr.asic_chan / CHANS_PER_PORT;\r\nswitch_page(dev, asic, PAGE_ENAB);\r\nfor (port = firstport; port < firstport + nports; ++port) {\r\noutb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);\r\n}\r\n}\r\nstatic int pcmuio_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nif (!subpriv->intr.continuous && subpriv->intr.stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nsubpriv->intr.active = 0;\r\nreturn 1;\r\n} else {\r\nunsigned bits = 0, pol_bits = 0, n;\r\nint nports, firstport, asic, port;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nasic = subpriv->intr.asic;\r\nif (asic < 0)\r\nreturn 1;\r\nsubpriv->intr.enabled_mask = 0;\r\nsubpriv->intr.active = 1;\r\nnports = subpriv->intr.num_asic_chans / CHANS_PER_PORT;\r\nfirstport = subpriv->intr.asic_chan / CHANS_PER_PORT;\r\nif (cmd->chanlist) {\r\nfor (n = 0; n < cmd->chanlist_len; n++) {\r\nbits |= (1U << CR_CHAN(cmd->chanlist[n]));\r\npol_bits |= (CR_AREF(cmd->chanlist[n])\r\n|| CR_RANGE(cmd->\r\nchanlist[n]) ? 1U : 0U)\r\n<< CR_CHAN(cmd->chanlist[n]);\r\n}\r\n}\r\nbits &= ((0x1 << subpriv->intr.num_asic_chans) -\r\n1) << subpriv->intr.first_chan;\r\nsubpriv->intr.enabled_mask = bits;\r\nswitch_page(dev, asic, PAGE_ENAB);\r\nfor (port = firstport; port < firstport + nports; ++port) {\r\nunsigned enab =\r\nbits >> (subpriv->intr.first_chan + (port -\r\nfirstport) *\r\n8) & 0xff, pol =\r\npol_bits >> (subpriv->intr.first_chan +\r\n(port - firstport) * 8) & 0xff;\r\noutb(enab,\r\ndevpriv->asics[asic].iobase + REG_ENAB0 + port);\r\nswitch_page(dev, asic, PAGE_POL);\r\noutb(pol,\r\ndevpriv->asics[asic].iobase + REG_ENAB0 + port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&subpriv->intr.spinlock, flags);\r\nif (subpriv->intr.active)\r\npcmuio_stop_intr(dev, s);\r\nspin_unlock_irqrestore(&subpriv->intr.spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\npcmuio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nunsigned long flags;\r\nint event = 0;\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&subpriv->intr.spinlock, flags);\r\ns->async->inttrig = 0;\r\nif (subpriv->intr.active) {\r\nevent = pcmuio_start_intr(dev, s);\r\n}\r\nspin_unlock_irqrestore(&subpriv->intr.spinlock, flags);\r\nif (event) {\r\ncomedi_event(dev, s);\r\n}\r\nreturn 1;\r\n}\r\nstatic int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nint event = 0;\r\nspin_lock_irqsave(&subpriv->intr.spinlock, flags);\r\nsubpriv->intr.active = 1;\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nsubpriv->intr.continuous = 0;\r\nsubpriv->intr.stop_count = cmd->stop_arg;\r\nbreak;\r\ndefault:\r\nsubpriv->intr.continuous = 1;\r\nsubpriv->intr.stop_count = 0;\r\nbreak;\r\n}\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\ns->async->inttrig = pcmuio_inttrig_start_intr;\r\nbreak;\r\ndefault:\r\nevent = pcmuio_start_intr(dev, s);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&subpriv->intr.spinlock, flags);\r\nif (event) {\r\ncomedi_event(dev, s);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nreturn comedi_pcm_cmdtest(dev, s, cmd);\r\n}\r\nstatic int __init driver_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver);\r\n}\r\nstatic void __exit driver_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver);\r\n}
