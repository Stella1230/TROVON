static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)\r\n{\r\nconst struct aiptek_map *p;\r\nif (str[count - 1] == '\n')\r\ncount--;\r\nfor (p = map; p->string; p++)\r\nif (!strncmp(str, p->string, count))\r\nreturn p->value;\r\nreturn AIPTEK_INVALID_VALUE;\r\n}\r\nstatic const char *map_val_to_str(const struct aiptek_map *map, int val)\r\n{\r\nconst struct aiptek_map *p;\r\nfor (p = map; p->value != AIPTEK_INVALID_VALUE; p++)\r\nif (val == p->value)\r\nreturn p->string;\r\nreturn "unknown";\r\n}\r\nstatic void aiptek_irq(struct urb *urb)\r\n{\r\nstruct aiptek *aiptek = urb->context;\r\nunsigned char *data = aiptek->data;\r\nstruct input_dev *inputdev = aiptek->inputdev;\r\nint jitterable = 0;\r\nint retval, macro, x, y, z, left, right, middle, p, dv, tip, bs, pck;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d",\r\n__func__, urb->status);\r\ngoto exit;\r\n}\r\nif (aiptek->inDelay == 1 && time_after(aiptek->endDelay, jiffies)) {\r\ngoto exit;\r\n}\r\naiptek->inDelay = 0;\r\naiptek->eventCount++;\r\nif (data[0] == 1) {\r\nif (aiptek->curSetting.coordinateMode ==\r\nAIPTEK_COORDINATE_ABSOLUTE_MODE) {\r\naiptek->diagnostic =\r\nAIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE;\r\n} else {\r\nx = (signed char) data[2];\r\ny = (signed char) data[3];\r\njitterable = data[1] & 0x07;\r\nleft = (data[1] & aiptek->curSetting.mouseButtonLeft >> 2) != 0 ? 1 : 0;\r\nright = (data[1] & aiptek->curSetting.mouseButtonRight >> 2) != 0 ? 1 : 0;\r\nmiddle = (data[1] & aiptek->curSetting.mouseButtonMiddle >> 2) != 0 ? 1 : 0;\r\ninput_report_key(inputdev, BTN_LEFT, left);\r\ninput_report_key(inputdev, BTN_MIDDLE, middle);\r\ninput_report_key(inputdev, BTN_RIGHT, right);\r\ninput_report_abs(inputdev, ABS_MISC,\r\n1 | AIPTEK_REPORT_TOOL_UNKNOWN);\r\ninput_report_rel(inputdev, REL_X, x);\r\ninput_report_rel(inputdev, REL_Y, y);\r\nif (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {\r\ninput_report_rel(inputdev, REL_WHEEL,\r\naiptek->curSetting.wheel);\r\naiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\r\n}\r\nif (aiptek->lastMacro != -1) {\r\ninput_report_key(inputdev,\r\nmacroKeyEvents[aiptek->lastMacro], 0);\r\naiptek->lastMacro = -1;\r\n}\r\ninput_sync(inputdev);\r\n}\r\n}\r\nelse if (data[0] == 2) {\r\nif (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {\r\naiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;\r\n} else if (!AIPTEK_POINTER_ALLOW_STYLUS_MODE\r\n(aiptek->curSetting.pointerMode)) {\r\naiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;\r\n} else {\r\nx = get_unaligned_le16(data + 1);\r\ny = get_unaligned_le16(data + 3);\r\nz = get_unaligned_le16(data + 6);\r\ndv = (data[5] & 0x01) != 0 ? 1 : 0;\r\np = (data[5] & 0x02) != 0 ? 1 : 0;\r\ntip = (data[5] & 0x04) != 0 ? 1 : 0;\r\njitterable = data[5] & 0x18;\r\nbs = (data[5] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;\r\npck = (data[5] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;\r\nif (dv != 0) {\r\nif (aiptek->previousToolMode !=\r\naiptek->curSetting.toolMode) {\r\ninput_report_key(inputdev,\r\naiptek->previousToolMode, 0);\r\ninput_report_key(inputdev,\r\naiptek->curSetting.toolMode,\r\n1);\r\naiptek->previousToolMode =\r\naiptek->curSetting.toolMode;\r\n}\r\nif (p != 0) {\r\ninput_report_abs(inputdev, ABS_X, x);\r\ninput_report_abs(inputdev, ABS_Y, y);\r\ninput_report_abs(inputdev, ABS_PRESSURE, z);\r\ninput_report_key(inputdev, BTN_TOUCH, tip);\r\ninput_report_key(inputdev, BTN_STYLUS, bs);\r\ninput_report_key(inputdev, BTN_STYLUS2, pck);\r\nif (aiptek->curSetting.xTilt !=\r\nAIPTEK_TILT_DISABLE) {\r\ninput_report_abs(inputdev,\r\nABS_TILT_X,\r\naiptek->curSetting.xTilt);\r\n}\r\nif (aiptek->curSetting.yTilt != AIPTEK_TILT_DISABLE) {\r\ninput_report_abs(inputdev,\r\nABS_TILT_Y,\r\naiptek->curSetting.yTilt);\r\n}\r\nif (aiptek->curSetting.wheel !=\r\nAIPTEK_WHEEL_DISABLE) {\r\ninput_report_abs(inputdev,\r\nABS_WHEEL,\r\naiptek->curSetting.wheel);\r\naiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\r\n}\r\n}\r\ninput_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_STYLUS);\r\nif (aiptek->lastMacro != -1) {\r\ninput_report_key(inputdev,\r\nmacroKeyEvents[aiptek->lastMacro], 0);\r\naiptek->lastMacro = -1;\r\n}\r\ninput_sync(inputdev);\r\n}\r\n}\r\n}\r\nelse if (data[0] == 3) {\r\nif (aiptek->curSetting.coordinateMode == AIPTEK_COORDINATE_RELATIVE_MODE) {\r\naiptek->diagnostic = AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE;\r\n} else if (!AIPTEK_POINTER_ALLOW_MOUSE_MODE\r\n(aiptek->curSetting.pointerMode)) {\r\naiptek->diagnostic = AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED;\r\n} else {\r\nx = get_unaligned_le16(data + 1);\r\ny = get_unaligned_le16(data + 3);\r\njitterable = data[5] & 0x1c;\r\ndv = (data[5] & 0x01) != 0 ? 1 : 0;\r\np = (data[5] & 0x02) != 0 ? 1 : 0;\r\nleft = (data[5] & aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;\r\nright = (data[5] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;\r\nmiddle = (data[5] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;\r\nif (dv != 0) {\r\nif (aiptek->previousToolMode !=\r\naiptek->curSetting.toolMode) {\r\ninput_report_key(inputdev,\r\naiptek->previousToolMode, 0);\r\ninput_report_key(inputdev,\r\naiptek->curSetting.toolMode,\r\n1);\r\naiptek->previousToolMode =\r\naiptek->curSetting.toolMode;\r\n}\r\nif (p != 0) {\r\ninput_report_abs(inputdev, ABS_X, x);\r\ninput_report_abs(inputdev, ABS_Y, y);\r\ninput_report_key(inputdev, BTN_LEFT, left);\r\ninput_report_key(inputdev, BTN_MIDDLE, middle);\r\ninput_report_key(inputdev, BTN_RIGHT, right);\r\nif (aiptek->curSetting.wheel != AIPTEK_WHEEL_DISABLE) {\r\ninput_report_abs(inputdev,\r\nABS_WHEEL,\r\naiptek->curSetting.wheel);\r\naiptek->curSetting.wheel = AIPTEK_WHEEL_DISABLE;\r\n}\r\n}\r\ninput_report_abs(inputdev, ABS_MISC, p | AIPTEK_REPORT_TOOL_MOUSE);\r\nif (aiptek->lastMacro != -1) {\r\ninput_report_key(inputdev,\r\nmacroKeyEvents[aiptek->lastMacro], 0);\r\naiptek->lastMacro = -1;\r\n}\r\ninput_sync(inputdev);\r\n}\r\n}\r\n}\r\nelse if (data[0] == 4) {\r\njitterable = data[1] & 0x18;\r\ndv = (data[1] & 0x01) != 0 ? 1 : 0;\r\np = (data[1] & 0x02) != 0 ? 1 : 0;\r\ntip = (data[1] & 0x04) != 0 ? 1 : 0;\r\nbs = (data[1] & aiptek->curSetting.stylusButtonLower) != 0 ? 1 : 0;\r\npck = (data[1] & aiptek->curSetting.stylusButtonUpper) != 0 ? 1 : 0;\r\nmacro = dv && p && tip && !(data[3] & 1) ? (data[3] >> 1) : -1;\r\nz = get_unaligned_le16(data + 4);\r\nif (dv) {\r\nif (aiptek->previousToolMode !=\r\naiptek->curSetting.toolMode) {\r\ninput_report_key(inputdev,\r\naiptek->previousToolMode, 0);\r\ninput_report_key(inputdev,\r\naiptek->curSetting.toolMode,\r\n1);\r\naiptek->previousToolMode =\r\naiptek->curSetting.toolMode;\r\n}\r\n}\r\nif (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {\r\ninput_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);\r\naiptek->lastMacro = -1;\r\n}\r\nif (macro != -1 && macro != aiptek->lastMacro) {\r\ninput_report_key(inputdev, macroKeyEvents[macro], 1);\r\naiptek->lastMacro = macro;\r\n}\r\ninput_report_abs(inputdev, ABS_MISC,\r\np | AIPTEK_REPORT_TOOL_STYLUS);\r\ninput_sync(inputdev);\r\n}\r\nelse if (data[0] == 5) {\r\njitterable = data[1] & 0x1c;\r\ndv = (data[1] & 0x01) != 0 ? 1 : 0;\r\np = (data[1] & 0x02) != 0 ? 1 : 0;\r\nleft = (data[1]& aiptek->curSetting.mouseButtonLeft) != 0 ? 1 : 0;\r\nright = (data[1] & aiptek->curSetting.mouseButtonRight) != 0 ? 1 : 0;\r\nmiddle = (data[1] & aiptek->curSetting.mouseButtonMiddle) != 0 ? 1 : 0;\r\nmacro = dv && p && left && !(data[3] & 1) ? (data[3] >> 1) : 0;\r\nif (dv) {\r\nif (aiptek->previousToolMode !=\r\naiptek->curSetting.toolMode) {\r\ninput_report_key(inputdev,\r\naiptek->previousToolMode, 0);\r\ninput_report_key(inputdev,\r\naiptek->curSetting.toolMode, 1);\r\naiptek->previousToolMode = aiptek->curSetting.toolMode;\r\n}\r\n}\r\nif (aiptek->lastMacro != -1 && aiptek->lastMacro != macro) {\r\ninput_report_key(inputdev, macroKeyEvents[aiptek->lastMacro], 0);\r\naiptek->lastMacro = -1;\r\n}\r\nif (macro != -1 && macro != aiptek->lastMacro) {\r\ninput_report_key(inputdev, macroKeyEvents[macro], 1);\r\naiptek->lastMacro = macro;\r\n}\r\ninput_report_abs(inputdev, ABS_MISC,\r\np | AIPTEK_REPORT_TOOL_MOUSE);\r\ninput_sync(inputdev);\r\n}\r\nelse if (data[0] == 6) {\r\nmacro = get_unaligned_le16(data + 1);\r\nif (macro > 0) {\r\ninput_report_key(inputdev, macroKeyEvents[macro - 1],\r\n0);\r\n}\r\nif (macro < 25) {\r\ninput_report_key(inputdev, macroKeyEvents[macro + 1],\r\n0);\r\n}\r\nif (aiptek->previousToolMode !=\r\naiptek->curSetting.toolMode) {\r\ninput_report_key(inputdev,\r\naiptek->previousToolMode, 0);\r\ninput_report_key(inputdev,\r\naiptek->curSetting.toolMode,\r\n1);\r\naiptek->previousToolMode =\r\naiptek->curSetting.toolMode;\r\n}\r\ninput_report_key(inputdev, macroKeyEvents[macro], 1);\r\ninput_report_abs(inputdev, ABS_MISC,\r\n1 | AIPTEK_REPORT_TOOL_UNKNOWN);\r\ninput_sync(inputdev);\r\n} else {\r\ndbg("Unknown report %d", data[0]);\r\n}\r\nif (aiptek->previousJitterable != jitterable &&\r\naiptek->curSetting.jitterDelay != 0 && aiptek->inDelay != 1) {\r\naiptek->endDelay = jiffies +\r\n((aiptek->curSetting.jitterDelay * HZ) / 1000);\r\naiptek->inDelay = 1;\r\n}\r\naiptek->previousJitterable = jitterable;\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval != 0) {\r\nerr("%s - usb_submit_urb failed with result %d",\r\n__func__, retval);\r\n}\r\n}\r\nstatic int aiptek_open(struct input_dev *inputdev)\r\n{\r\nstruct aiptek *aiptek = input_get_drvdata(inputdev);\r\naiptek->urb->dev = aiptek->usbdev;\r\nif (usb_submit_urb(aiptek->urb, GFP_KERNEL) != 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void aiptek_close(struct input_dev *inputdev)\r\n{\r\nstruct aiptek *aiptek = input_get_drvdata(inputdev);\r\nusb_kill_urb(aiptek->urb);\r\n}\r\nstatic int\r\naiptek_set_report(struct aiptek *aiptek,\r\nunsigned char report_type,\r\nunsigned char report_id, void *buffer, int size)\r\n{\r\nreturn usb_control_msg(aiptek->usbdev,\r\nusb_sndctrlpipe(aiptek->usbdev, 0),\r\nUSB_REQ_SET_REPORT,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE |\r\nUSB_DIR_OUT, (report_type << 8) + report_id,\r\naiptek->ifnum, buffer, size, 5000);\r\n}\r\nstatic int\r\naiptek_get_report(struct aiptek *aiptek,\r\nunsigned char report_type,\r\nunsigned char report_id, void *buffer, int size)\r\n{\r\nreturn usb_control_msg(aiptek->usbdev,\r\nusb_rcvctrlpipe(aiptek->usbdev, 0),\r\nUSB_REQ_GET_REPORT,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE |\r\nUSB_DIR_IN, (report_type << 8) + report_id,\r\naiptek->ifnum, buffer, size, 5000);\r\n}\r\nstatic int\r\naiptek_command(struct aiptek *aiptek, unsigned char command, unsigned char data)\r\n{\r\nconst int sizeof_buf = 3 * sizeof(u8);\r\nint ret;\r\nu8 *buf;\r\nbuf = kmalloc(sizeof_buf, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = 2;\r\nbuf[1] = command;\r\nbuf[2] = data;\r\nif ((ret =\r\naiptek_set_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {\r\ndbg("aiptek_program: failed, tried to send: 0x%02x 0x%02x",\r\ncommand, data);\r\n}\r\nkfree(buf);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int\r\naiptek_query(struct aiptek *aiptek, unsigned char command, unsigned char data)\r\n{\r\nconst int sizeof_buf = 3 * sizeof(u8);\r\nint ret;\r\nu8 *buf;\r\nbuf = kmalloc(sizeof_buf, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = 2;\r\nbuf[1] = command;\r\nbuf[2] = data;\r\nif (aiptek_command(aiptek, command, data) != 0) {\r\nkfree(buf);\r\nreturn -EIO;\r\n}\r\nmsleep(aiptek->curSetting.programmableDelay);\r\nif ((ret =\r\naiptek_get_report(aiptek, 3, 2, buf, sizeof_buf)) != sizeof_buf) {\r\ndbg("aiptek_query failed: returned 0x%02x 0x%02x 0x%02x",\r\nbuf[0], buf[1], buf[2]);\r\nret = -EIO;\r\n} else {\r\nret = get_unaligned_le16(buf + 1);\r\n}\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int aiptek_program_tablet(struct aiptek *aiptek)\r\n{\r\nint ret;\r\nif ((ret = aiptek_command(aiptek, 0x18, 0x04)) < 0)\r\nreturn ret;\r\nif ((ret = aiptek_query(aiptek, 0x02, 0x00)) < 0)\r\nreturn ret;\r\naiptek->features.modelCode = ret & 0xff;\r\nif ((ret = aiptek_query(aiptek, 0x03, 0x00)) < 0)\r\nreturn ret;\r\naiptek->features.odmCode = ret;\r\nif ((ret = aiptek_query(aiptek, 0x04, 0x00)) < 0)\r\nreturn ret;\r\naiptek->features.firmwareCode = ret;\r\nif ((ret = aiptek_query(aiptek, 0x01, 0x00)) < 0)\r\nreturn ret;\r\ninput_set_abs_params(aiptek->inputdev, ABS_X, 0, ret - 1, 0, 0);\r\nif ((ret = aiptek_query(aiptek, 0x01, 0x01)) < 0)\r\nreturn ret;\r\ninput_set_abs_params(aiptek->inputdev, ABS_Y, 0, ret - 1, 0, 0);\r\nif ((ret = aiptek_query(aiptek, 0x08, 0x00)) < 0)\r\nreturn ret;\r\ninput_set_abs_params(aiptek->inputdev, ABS_PRESSURE, 0, ret - 1, 0, 0);\r\nif (aiptek->curSetting.coordinateMode ==\r\nAIPTEK_COORDINATE_ABSOLUTE_MODE) {\r\nif ((ret = aiptek_command(aiptek, 0x10, 0x01)) < 0) {\r\nreturn ret;\r\n}\r\n} else {\r\nif ((ret = aiptek_command(aiptek, 0x10, 0x00)) < 0) {\r\nreturn ret;\r\n}\r\n}\r\nif ((ret = aiptek_command(aiptek, 0x11, 0x02)) < 0)\r\nreturn ret;\r\n#if 0\r\nif ((ret = aiptek_command(aiptek, 0x17, 0x00)) < 0)\r\nreturn ret;\r\n#endif\r\nif ((ret = aiptek_command(aiptek, 0x12, 0xff)) < 0)\r\nreturn ret;\r\naiptek->diagnostic = AIPTEK_DIAGNOSTIC_NA;\r\naiptek->eventCount = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_tabletSize(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%dx%d\n",\r\ninput_abs_get_max(aiptek->inputdev, ABS_X) + 1,\r\ninput_abs_get_max(aiptek->inputdev, ABS_Y) + 1);\r\n}\r\nstatic ssize_t show_tabletPointerMode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(pointer_mode_map,\r\naiptek->curSetting.pointerMode));\r\n}\r\nstatic ssize_t\r\nstore_tabletPointerMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_mode = map_str_to_val(pointer_mode_map, buf, count);\r\nif (new_mode == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.pointerMode = new_mode;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(coordinate_mode_map,\r\naiptek->curSetting.coordinateMode));\r\n}\r\nstatic ssize_t\r\nstore_tabletCoordinateMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_mode = map_str_to_val(coordinate_mode_map, buf, count);\r\nif (new_mode == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.coordinateMode = new_mode;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletToolMode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(tool_mode_map,\r\naiptek->curSetting.toolMode));\r\n}\r\nstatic ssize_t\r\nstore_tabletToolMode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_mode = map_str_to_val(tool_mode_map, buf, count);\r\nif (new_mode == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.toolMode = new_mode;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletXtilt(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nif (aiptek->curSetting.xTilt == AIPTEK_TILT_DISABLE) {\r\nreturn snprintf(buf, PAGE_SIZE, "disable\n");\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\naiptek->curSetting.xTilt);\r\n}\r\n}\r\nstatic ssize_t\r\nstore_tabletXtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nlong x;\r\nif (strict_strtol(buf, 10, &x)) {\r\nsize_t len = buf[count - 1] == '\n' ? count - 1 : count;\r\nif (strncmp(buf, "disable", len))\r\nreturn -EINVAL;\r\naiptek->newSetting.xTilt = AIPTEK_TILT_DISABLE;\r\n} else {\r\nif (x < AIPTEK_TILT_MIN || x > AIPTEK_TILT_MAX)\r\nreturn -EINVAL;\r\naiptek->newSetting.xTilt = x;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletYtilt(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nif (aiptek->curSetting.yTilt == AIPTEK_TILT_DISABLE) {\r\nreturn snprintf(buf, PAGE_SIZE, "disable\n");\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\naiptek->curSetting.yTilt);\r\n}\r\n}\r\nstatic ssize_t\r\nstore_tabletYtilt(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nlong y;\r\nif (strict_strtol(buf, 10, &y)) {\r\nsize_t len = buf[count - 1] == '\n' ? count - 1 : count;\r\nif (strncmp(buf, "disable", len))\r\nreturn -EINVAL;\r\naiptek->newSetting.yTilt = AIPTEK_TILT_DISABLE;\r\n} else {\r\nif (y < AIPTEK_TILT_MIN || y > AIPTEK_TILT_MAX)\r\nreturn -EINVAL;\r\naiptek->newSetting.yTilt = y;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletJitterDelay(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", aiptek->curSetting.jitterDelay);\r\n}\r\nstatic ssize_t\r\nstore_tabletJitterDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nlong j;\r\nif (strict_strtol(buf, 10, &j))\r\nreturn -EINVAL;\r\naiptek->newSetting.jitterDelay = (int)j;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\naiptek->curSetting.programmableDelay);\r\n}\r\nstatic ssize_t\r\nstore_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nlong d;\r\nif (strict_strtol(buf, 10, &d))\r\nreturn -EINVAL;\r\naiptek->newSetting.programmableDelay = (int)d;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletEventsReceived(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", aiptek->eventCount);\r\n}\r\nstatic ssize_t show_tabletDiagnosticMessage(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nchar *retMsg;\r\nswitch (aiptek->diagnostic) {\r\ncase AIPTEK_DIAGNOSTIC_NA:\r\nretMsg = "no errors\n";\r\nbreak;\r\ncase AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE:\r\nretMsg = "Error: receiving relative reports\n";\r\nbreak;\r\ncase AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE:\r\nretMsg = "Error: receiving absolute reports\n";\r\nbreak;\r\ncase AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED:\r\nif (aiptek->curSetting.pointerMode ==\r\nAIPTEK_POINTER_ONLY_MOUSE_MODE) {\r\nretMsg = "Error: receiving stylus reports\n";\r\n} else {\r\nretMsg = "Error: receiving mouse reports\n";\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, retMsg);\r\n}\r\nstatic ssize_t show_tabletStylusUpper(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(stylus_button_map,\r\naiptek->curSetting.stylusButtonUpper));\r\n}\r\nstatic ssize_t\r\nstore_tabletStylusUpper(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_button = map_str_to_val(stylus_button_map, buf, count);\r\nif (new_button == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.stylusButtonUpper = new_button;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletStylusLower(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(stylus_button_map,\r\naiptek->curSetting.stylusButtonLower));\r\n}\r\nstatic ssize_t\r\nstore_tabletStylusLower(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_button = map_str_to_val(stylus_button_map, buf, count);\r\nif (new_button == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.stylusButtonLower = new_button;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletMouseLeft(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(mouse_button_map,\r\naiptek->curSetting.mouseButtonLeft));\r\n}\r\nstatic ssize_t\r\nstore_tabletMouseLeft(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_button = map_str_to_val(mouse_button_map, buf, count);\r\nif (new_button == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.mouseButtonLeft = new_button;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(mouse_button_map,\r\naiptek->curSetting.mouseButtonMiddle));\r\n}\r\nstatic ssize_t\r\nstore_tabletMouseMiddle(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_button = map_str_to_val(mouse_button_map, buf, count);\r\nif (new_button == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.mouseButtonMiddle = new_button;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletMouseRight(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nmap_val_to_str(mouse_button_map,\r\naiptek->curSetting.mouseButtonRight));\r\n}\r\nstatic ssize_t\r\nstore_tabletMouseRight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nint new_button = map_str_to_val(mouse_button_map, buf, count);\r\nif (new_button == AIPTEK_INVALID_VALUE)\r\nreturn -EINVAL;\r\naiptek->newSetting.mouseButtonRight = new_button;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletWheel(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nif (aiptek->curSetting.wheel == AIPTEK_WHEEL_DISABLE) {\r\nreturn snprintf(buf, PAGE_SIZE, "disable\n");\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\naiptek->curSetting.wheel);\r\n}\r\n}\r\nstatic ssize_t\r\nstore_tabletWheel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nlong w;\r\nif (strict_strtol(buf, 10, &w)) return -EINVAL;\r\naiptek->newSetting.wheel = (int)w;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletExecute(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"Write anything to this file to program your tablet.\n");\r\n}\r\nstatic ssize_t\r\nstore_tabletExecute(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nmemcpy(&aiptek->curSetting, &aiptek->newSetting,\r\nsizeof(struct aiptek_settings));\r\nif (aiptek_program_tablet(aiptek) < 0)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t show_tabletODMCode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.odmCode);\r\n}\r\nstatic ssize_t show_tabletModelCode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04x\n", aiptek->features.modelCode);\r\n}\r\nstatic ssize_t show_firmwareCode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct aiptek *aiptek = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%04x\n",\r\naiptek->features.firmwareCode);\r\n}\r\nstatic int\r\naiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct aiptek *aiptek;\r\nstruct input_dev *inputdev;\r\nint i;\r\nint speeds[] = { 0,\r\nAIPTEK_PROGRAMMABLE_DELAY_50,\r\nAIPTEK_PROGRAMMABLE_DELAY_400,\r\nAIPTEK_PROGRAMMABLE_DELAY_25,\r\nAIPTEK_PROGRAMMABLE_DELAY_100,\r\nAIPTEK_PROGRAMMABLE_DELAY_200,\r\nAIPTEK_PROGRAMMABLE_DELAY_300\r\n};\r\nint err = -ENOMEM;\r\nspeeds[0] = programmableDelay;\r\naiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);\r\ninputdev = input_allocate_device();\r\nif (!aiptek || !inputdev) {\r\ndev_warn(&intf->dev,\r\n"cannot allocate memory or input device\n");\r\ngoto fail1;\r\n}\r\naiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,\r\nGFP_ATOMIC, &aiptek->data_dma);\r\nif (!aiptek->data) {\r\ndev_warn(&intf->dev, "cannot allocate usb buffer\n");\r\ngoto fail1;\r\n}\r\naiptek->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!aiptek->urb) {\r\ndev_warn(&intf->dev, "cannot allocate urb\n");\r\ngoto fail2;\r\n}\r\naiptek->inputdev = inputdev;\r\naiptek->usbdev = usbdev;\r\naiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;\r\naiptek->inDelay = 0;\r\naiptek->endDelay = 0;\r\naiptek->previousJitterable = 0;\r\naiptek->lastMacro = -1;\r\naiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;\r\naiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;\r\naiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;\r\naiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;\r\naiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;\r\naiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;\r\naiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;\r\naiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;\r\naiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;\r\naiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;\r\naiptek->curSetting.jitterDelay = jitterDelay;\r\naiptek->curSetting.programmableDelay = programmableDelay;\r\naiptek->newSetting = aiptek->curSetting;\r\nusb_make_path(usbdev, aiptek->features.usbPath,\r\nsizeof(aiptek->features.usbPath));\r\nstrlcat(aiptek->features.usbPath, "/input0",\r\nsizeof(aiptek->features.usbPath));\r\ninputdev->name = "Aiptek";\r\ninputdev->phys = aiptek->features.usbPath;\r\nusb_to_input_id(usbdev, &inputdev->id);\r\ninputdev->dev.parent = &intf->dev;\r\ninput_set_drvdata(inputdev, aiptek);\r\ninputdev->open = aiptek_open;\r\ninputdev->close = aiptek_close;\r\nfor (i = 0; i < ARRAY_SIZE(eventTypes); ++i)\r\n__set_bit(eventTypes[i], inputdev->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(absEvents); ++i)\r\n__set_bit(absEvents[i], inputdev->absbit);\r\nfor (i = 0; i < ARRAY_SIZE(relEvents); ++i)\r\n__set_bit(relEvents[i], inputdev->relbit);\r\n__set_bit(MSC_SERIAL, inputdev->mscbit);\r\nfor (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)\r\n__set_bit(buttonEvents[i], inputdev->keybit);\r\nfor (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)\r\n__set_bit(macroKeyEvents[i], inputdev->keybit);\r\ninput_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\r\ninput_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);\r\nendpoint = &intf->altsetting[0].endpoint[0].desc;\r\nusb_fill_int_urb(aiptek->urb,\r\naiptek->usbdev,\r\nusb_rcvintpipe(aiptek->usbdev,\r\nendpoint->bEndpointAddress),\r\naiptek->data, 8, aiptek_irq, aiptek,\r\nendpoint->bInterval);\r\naiptek->urb->transfer_dma = aiptek->data_dma;\r\naiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nfor (i = 0; i < ARRAY_SIZE(speeds); ++i) {\r\naiptek->curSetting.programmableDelay = speeds[i];\r\n(void)aiptek_program_tablet(aiptek);\r\nif (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) {\r\ndev_info(&intf->dev,\r\n"Aiptek using %d ms programming speed\n",\r\naiptek->curSetting.programmableDelay);\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(speeds)) {\r\ndev_info(&intf->dev,\r\n"Aiptek tried all speeds, no sane response\n");\r\ngoto fail2;\r\n}\r\nusb_set_intfdata(intf, aiptek);\r\nerr = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);\r\nif (err) {\r\ndev_warn(&intf->dev, "cannot create sysfs group err: %d\n",\r\nerr);\r\ngoto fail3;\r\n}\r\nerr = input_register_device(aiptek->inputdev);\r\nif (err) {\r\ndev_warn(&intf->dev,\r\n"input_register_device returned err: %d\n", err);\r\ngoto fail4;\r\n}\r\nreturn 0;\r\nfail4: sysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);\r\nfail3: usb_free_urb(aiptek->urb);\r\nfail2: usb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,\r\naiptek->data_dma);\r\nfail1: usb_set_intfdata(intf, NULL);\r\ninput_free_device(inputdev);\r\nkfree(aiptek);\r\nreturn err;\r\n}\r\nstatic void aiptek_disconnect(struct usb_interface *intf)\r\n{\r\nstruct aiptek *aiptek = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (aiptek != NULL) {\r\nusb_kill_urb(aiptek->urb);\r\ninput_unregister_device(aiptek->inputdev);\r\nsysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);\r\nusb_free_urb(aiptek->urb);\r\nusb_free_coherent(interface_to_usbdev(intf),\r\nAIPTEK_PACKET_LENGTH,\r\naiptek->data, aiptek->data_dma);\r\nkfree(aiptek);\r\n}\r\n}\r\nstatic int __init aiptek_init(void)\r\n{\r\nint result = usb_register(&aiptek_driver);\r\nif (result == 0) {\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_AUTHOR "\n");\r\n}\r\nreturn result;\r\n}\r\nstatic void __exit aiptek_exit(void)\r\n{\r\nusb_deregister(&aiptek_driver);\r\n}
