static void rxrpc_abort_calls(struct rxrpc_connection *conn, int state,\r\nu32 abort_code)\r\n{\r\nstruct rxrpc_call *call;\r\nstruct rb_node *p;\r\n_enter("{%d},%x", conn->debug_id, abort_code);\r\nread_lock_bh(&conn->lock);\r\nfor (p = rb_first(&conn->calls); p; p = rb_next(p)) {\r\ncall = rb_entry(p, struct rxrpc_call, conn_node);\r\nwrite_lock(&call->state_lock);\r\nif (call->state <= RXRPC_CALL_COMPLETE) {\r\ncall->state = state;\r\ncall->abort_code = abort_code;\r\nif (state == RXRPC_CALL_LOCALLY_ABORTED)\r\nset_bit(RXRPC_CALL_CONN_ABORT, &call->events);\r\nelse\r\nset_bit(RXRPC_CALL_RCVD_ABORT, &call->events);\r\nrxrpc_queue_call(call);\r\n}\r\nwrite_unlock(&call->state_lock);\r\n}\r\nread_unlock_bh(&conn->lock);\r\n_leave("");\r\n}\r\nstatic int rxrpc_abort_connection(struct rxrpc_connection *conn,\r\nu32 error, u32 abort_code)\r\n{\r\nstruct rxrpc_header hdr;\r\nstruct msghdr msg;\r\nstruct kvec iov[2];\r\n__be32 word;\r\nsize_t len;\r\nint ret;\r\n_enter("%d,,%u,%u", conn->debug_id, error, abort_code);\r\nspin_lock_bh(&conn->state_lock);\r\nif (conn->state < RXRPC_CONN_REMOTELY_ABORTED) {\r\nconn->state = RXRPC_CONN_LOCALLY_ABORTED;\r\nconn->error = error;\r\nspin_unlock_bh(&conn->state_lock);\r\n} else {\r\nspin_unlock_bh(&conn->state_lock);\r\n_leave(" = 0 [already dead]");\r\nreturn 0;\r\n}\r\nrxrpc_abort_calls(conn, RXRPC_CALL_LOCALLY_ABORTED, abort_code);\r\nmsg.msg_name = &conn->trans->peer->srx.transport.sin;\r\nmsg.msg_namelen = sizeof(conn->trans->peer->srx.transport.sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nhdr.epoch = conn->epoch;\r\nhdr.cid = conn->cid;\r\nhdr.callNumber = 0;\r\nhdr.seq = 0;\r\nhdr.type = RXRPC_PACKET_TYPE_ABORT;\r\nhdr.flags = conn->out_clientflag;\r\nhdr.userStatus = 0;\r\nhdr.securityIndex = conn->security_ix;\r\nhdr._rsvd = 0;\r\nhdr.serviceId = conn->service_id;\r\nword = htonl(abort_code);\r\niov[0].iov_base = &hdr;\r\niov[0].iov_len = sizeof(hdr);\r\niov[1].iov_base = &word;\r\niov[1].iov_len = sizeof(word);\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\nhdr.serial = htonl(atomic_inc_return(&conn->serial));\r\n_proto("Tx CONN ABORT %%%u { %d }", ntohl(hdr.serial), abort_code);\r\nret = kernel_sendmsg(conn->trans->local->socket, &msg, iov, 2, len);\r\nif (ret < 0) {\r\n_debug("sendmsg failed: %d", ret);\r\nreturn -EAGAIN;\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void rxrpc_call_is_secure(struct rxrpc_call *call)\r\n{\r\n_enter("%p", call);\r\nif (call) {\r\nread_lock(&call->state_lock);\r\nif (call->state < RXRPC_CALL_COMPLETE &&\r\n!test_and_set_bit(RXRPC_CALL_SECURED, &call->events))\r\nrxrpc_queue_call(call);\r\nread_unlock(&call->state_lock);\r\n}\r\n}\r\nstatic int rxrpc_process_event(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\n__be32 tmp;\r\nu32 serial;\r\nint loop, ret;\r\nif (conn->state >= RXRPC_CONN_REMOTELY_ABORTED) {\r\nkleave(" = -ECONNABORTED [%u]", conn->state);\r\nreturn -ECONNABORTED;\r\n}\r\nserial = ntohl(sp->hdr.serial);\r\n_enter("{%d},{%u,%%%u},", conn->debug_id, sp->hdr.type, serial);\r\nswitch (sp->hdr.type) {\r\ncase RXRPC_PACKET_TYPE_ABORT:\r\nif (skb_copy_bits(skb, 0, &tmp, sizeof(tmp)) < 0)\r\nreturn -EPROTO;\r\n_proto("Rx ABORT %%%u { ac=%d }", serial, ntohl(tmp));\r\nconn->state = RXRPC_CONN_REMOTELY_ABORTED;\r\nrxrpc_abort_calls(conn, RXRPC_CALL_REMOTELY_ABORTED,\r\nntohl(tmp));\r\nreturn -ECONNABORTED;\r\ncase RXRPC_PACKET_TYPE_CHALLENGE:\r\nif (conn->security)\r\nreturn conn->security->respond_to_challenge(\r\nconn, skb, _abort_code);\r\nreturn -EPROTO;\r\ncase RXRPC_PACKET_TYPE_RESPONSE:\r\nif (!conn->security)\r\nreturn -EPROTO;\r\nret = conn->security->verify_response(conn, skb, _abort_code);\r\nif (ret < 0)\r\nreturn ret;\r\nret = conn->security->init_connection_security(conn);\r\nif (ret < 0)\r\nreturn ret;\r\nconn->security->prime_packet_security(conn);\r\nread_lock_bh(&conn->lock);\r\nspin_lock(&conn->state_lock);\r\nif (conn->state == RXRPC_CONN_SERVER_CHALLENGING) {\r\nconn->state = RXRPC_CONN_SERVER;\r\nfor (loop = 0; loop < RXRPC_MAXCALLS; loop++)\r\nrxrpc_call_is_secure(conn->channels[loop]);\r\n}\r\nspin_unlock(&conn->state_lock);\r\nread_unlock_bh(&conn->lock);\r\nreturn 0;\r\ndefault:\r\n_leave(" = -EPROTO [%u]", sp->hdr.type);\r\nreturn -EPROTO;\r\n}\r\n}\r\nstatic void rxrpc_secure_connection(struct rxrpc_connection *conn)\r\n{\r\nu32 abort_code;\r\nint ret;\r\n_enter("{%d}", conn->debug_id);\r\nASSERT(conn->security_ix != 0);\r\nif (!conn->key) {\r\n_debug("set up security");\r\nret = rxrpc_init_server_conn_security(conn);\r\nswitch (ret) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\nabort_code = RX_CALL_DEAD;\r\ngoto abort;\r\ndefault:\r\nabort_code = RXKADNOAUTH;\r\ngoto abort;\r\n}\r\n}\r\nASSERT(conn->security != NULL);\r\nif (conn->security->issue_challenge(conn) < 0) {\r\nabort_code = RX_CALL_DEAD;\r\nret = -ENOMEM;\r\ngoto abort;\r\n}\r\n_leave("");\r\nreturn;\r\nabort:\r\n_debug("abort %d, %d", ret, abort_code);\r\nrxrpc_abort_connection(conn, -ret, abort_code);\r\n_leave(" [aborted]");\r\n}\r\nvoid rxrpc_process_connection(struct work_struct *work)\r\n{\r\nstruct rxrpc_connection *conn =\r\ncontainer_of(work, struct rxrpc_connection, processor);\r\nstruct sk_buff *skb;\r\nu32 abort_code = RX_PROTOCOL_ERROR;\r\nint ret;\r\n_enter("{%d}", conn->debug_id);\r\natomic_inc(&conn->usage);\r\nif (test_and_clear_bit(RXRPC_CONN_CHALLENGE, &conn->events)) {\r\nrxrpc_secure_connection(conn);\r\nrxrpc_put_connection(conn);\r\n}\r\nwhile ((skb = skb_dequeue(&conn->rx_queue))) {\r\nret = rxrpc_process_event(conn, skb, &abort_code);\r\nswitch (ret) {\r\ncase -EPROTO:\r\ncase -EKEYEXPIRED:\r\ncase -EKEYREJECTED:\r\ngoto protocol_error;\r\ncase -EAGAIN:\r\ngoto requeue_and_leave;\r\ncase -ECONNABORTED:\r\ndefault:\r\nrxrpc_put_connection(conn);\r\nrxrpc_free_skb(skb);\r\nbreak;\r\n}\r\n}\r\nout:\r\nrxrpc_put_connection(conn);\r\n_leave("");\r\nreturn;\r\nrequeue_and_leave:\r\nskb_queue_head(&conn->rx_queue, skb);\r\ngoto out;\r\nprotocol_error:\r\nif (rxrpc_abort_connection(conn, -ret, abort_code) < 0)\r\ngoto requeue_and_leave;\r\nrxrpc_put_connection(conn);\r\nrxrpc_free_skb(skb);\r\n_leave(" [EPROTO]");\r\ngoto out;\r\n}\r\nvoid rxrpc_reject_packet(struct rxrpc_local *local, struct sk_buff *skb)\r\n{\r\nCHECK_SLAB_OKAY(&local->usage);\r\nif (!atomic_inc_not_zero(&local->usage)) {\r\nprintk("resurrected on reject\n");\r\nBUG();\r\n}\r\nskb_queue_tail(&local->reject_queue, skb);\r\nrxrpc_queue_work(&local->rejecter);\r\n}\r\nvoid rxrpc_reject_packets(struct work_struct *work)\r\n{\r\nunion {\r\nstruct sockaddr sa;\r\nstruct sockaddr_in sin;\r\n} sa;\r\nstruct rxrpc_skb_priv *sp;\r\nstruct rxrpc_header hdr;\r\nstruct rxrpc_local *local;\r\nstruct sk_buff *skb;\r\nstruct msghdr msg;\r\nstruct kvec iov[2];\r\nsize_t size;\r\n__be32 code;\r\nlocal = container_of(work, struct rxrpc_local, rejecter);\r\nrxrpc_get_local(local);\r\n_enter("%d", local->debug_id);\r\niov[0].iov_base = &hdr;\r\niov[0].iov_len = sizeof(hdr);\r\niov[1].iov_base = &code;\r\niov[1].iov_len = sizeof(code);\r\nsize = sizeof(hdr) + sizeof(code);\r\nmsg.msg_name = &sa;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nmemset(&sa, 0, sizeof(sa));\r\nsa.sa.sa_family = local->srx.transport.family;\r\nswitch (sa.sa.sa_family) {\r\ncase AF_INET:\r\nmsg.msg_namelen = sizeof(sa.sin);\r\nbreak;\r\ndefault:\r\nmsg.msg_namelen = 0;\r\nbreak;\r\n}\r\nmemset(&hdr, 0, sizeof(hdr));\r\nhdr.type = RXRPC_PACKET_TYPE_ABORT;\r\nwhile ((skb = skb_dequeue(&local->reject_queue))) {\r\nsp = rxrpc_skb(skb);\r\nswitch (sa.sa.sa_family) {\r\ncase AF_INET:\r\nsa.sin.sin_port = udp_hdr(skb)->source;\r\nsa.sin.sin_addr.s_addr = ip_hdr(skb)->saddr;\r\ncode = htonl(skb->priority);\r\nhdr.epoch = sp->hdr.epoch;\r\nhdr.cid = sp->hdr.cid;\r\nhdr.callNumber = sp->hdr.callNumber;\r\nhdr.serviceId = sp->hdr.serviceId;\r\nhdr.flags = sp->hdr.flags;\r\nhdr.flags ^= RXRPC_CLIENT_INITIATED;\r\nhdr.flags &= RXRPC_CLIENT_INITIATED;\r\nkernel_sendmsg(local->socket, &msg, iov, 2, size);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrxrpc_free_skb(skb);\r\nrxrpc_put_local(local);\r\n}\r\nrxrpc_put_local(local);\r\n_leave("");\r\n}
