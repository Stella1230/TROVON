static void intc_enable_or_unmask(struct irq_data *d)\r\n{\r\nunsigned long mask = 1 << d->irq;\r\npr_debug("enable_or_unmask: %d\n", d->irq);\r\nout_be32(INTC_BASE + SIE, mask);\r\nif (irqd_is_level_type(d))\r\nout_be32(INTC_BASE + IAR, mask);\r\n}\r\nstatic void intc_disable_or_mask(struct irq_data *d)\r\n{\r\npr_debug("disable: %d\n", d->irq);\r\nout_be32(INTC_BASE + CIE, 1 << d->irq);\r\n}\r\nstatic void intc_ack(struct irq_data *d)\r\n{\r\npr_debug("ack: %d\n", d->irq);\r\nout_be32(INTC_BASE + IAR, 1 << d->irq);\r\n}\r\nstatic void intc_mask_ack(struct irq_data *d)\r\n{\r\nunsigned long mask = 1 << d->irq;\r\npr_debug("disable_and_ack: %d\n", d->irq);\r\nout_be32(INTC_BASE + CIE, mask);\r\nout_be32(INTC_BASE + IAR, mask);\r\n}\r\nunsigned int get_irq(struct pt_regs *regs)\r\n{\r\nint irq;\r\nirq = in_be32(INTC_BASE + IVR);\r\npr_debug("get_irq: %d\n", irq);\r\nreturn irq;\r\n}\r\nvoid __init init_IRQ(void)\r\n{\r\nu32 i, j, intr_type;\r\nstruct device_node *intc = NULL;\r\n#ifdef CONFIG_SELFMOD_INTC\r\nunsigned int intc_baseaddr = 0;\r\nstatic int arr_func[] = {\r\n(int)&get_irq,\r\n(int)&intc_enable_or_unmask,\r\n(int)&intc_disable_or_mask,\r\n(int)&intc_mask_ack,\r\n(int)&intc_ack,\r\n(int)&intc_end,\r\n0\r\n};\r\n#endif\r\nconst char * const intc_list[] = {\r\n"xlnx,xps-intc-1.00.a",\r\nNULL\r\n};\r\nfor (j = 0; intc_list[j] != NULL; j++) {\r\nintc = of_find_compatible_node(NULL, NULL, intc_list[j]);\r\nif (intc)\r\nbreak;\r\n}\r\nBUG_ON(!intc);\r\nintc_baseaddr = be32_to_cpup(of_get_property(intc,\r\n"reg", NULL));\r\nintc_baseaddr = (unsigned long) ioremap(intc_baseaddr, PAGE_SIZE);\r\nnr_irq = be32_to_cpup(of_get_property(intc,\r\n"xlnx,num-intr-inputs", NULL));\r\nintr_type =\r\nbe32_to_cpup(of_get_property(intc,\r\n"xlnx,kind-of-intr", NULL));\r\nif (intr_type > (u32)((1ULL << nr_irq) - 1))\r\nprintk(KERN_INFO " ERROR: Mismatch in kind-of-intr param\n");\r\n#ifdef CONFIG_SELFMOD_INTC\r\nselfmod_function((int *) arr_func, intc_baseaddr);\r\n#endif\r\nprintk(KERN_INFO "%s #0 at 0x%08x, num_irq=%d, edge=0x%x\n",\r\nintc_list[j], intc_baseaddr, nr_irq, intr_type);\r\nout_be32(intc_baseaddr + IER, 0);\r\nout_be32(intc_baseaddr + IAR, 0xffffffff);\r\nout_be32(intc_baseaddr + MER, MER_HIE | MER_ME);\r\nfor (i = 0; i < nr_irq; ++i) {\r\nif (intr_type & (0x00000001 << i)) {\r\nirq_set_chip_and_handler_name(i, &intc_dev,\r\nhandle_edge_irq, "edge");\r\nirq_clear_status_flags(i, IRQ_LEVEL);\r\n} else {\r\nirq_set_chip_and_handler_name(i, &intc_dev,\r\nhandle_level_irq, "level");\r\nirq_set_status_flags(i, IRQ_LEVEL);\r\n}\r\n}\r\n}
