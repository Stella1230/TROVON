static __inline__ u8 sca_get_page(card_t *card)\r\n{\r\nreturn inb(card->io + N2_PSR) & PSR_PAGEBITS;\r\n}\r\nstatic __inline__ void openwin(card_t *card, u8 page)\r\n{\r\nu8 psr = inb(card->io + N2_PSR);\r\noutb((psr & ~PSR_PAGEBITS) | page, card->io + N2_PSR);\r\n}\r\nstatic void n2_set_iface(port_t *port)\r\n{\r\ncard_t *card = port->card;\r\nint io = card->io;\r\nu8 mcr = inb(io + N2_MCR);\r\nu8 msci = get_msci(port);\r\nu8 rxs = port->rxs & CLK_BRG_MASK;\r\nu8 txs = port->txs & CLK_BRG_MASK;\r\nswitch(port->settings.clock_type) {\r\ncase CLOCK_INT:\r\nmcr |= port->phy_node ? CLOCK_OUT_PORT1 : CLOCK_OUT_PORT0;\r\nrxs |= CLK_BRG_RX;\r\ntxs |= CLK_RXCLK_TX;\r\nbreak;\r\ncase CLOCK_TXINT:\r\nmcr |= port->phy_node ? CLOCK_OUT_PORT1 : CLOCK_OUT_PORT0;\r\nrxs |= CLK_LINE_RX;\r\ntxs |= CLK_BRG_TX;\r\nbreak;\r\ncase CLOCK_TXFROMRX:\r\nmcr |= port->phy_node ? CLOCK_OUT_PORT1 : CLOCK_OUT_PORT0;\r\nrxs |= CLK_LINE_RX;\r\ntxs |= CLK_RXCLK_TX;\r\nbreak;\r\ndefault:\r\nmcr &= port->phy_node ? ~CLOCK_OUT_PORT1 : ~CLOCK_OUT_PORT0;\r\nrxs |= CLK_LINE_RX;\r\ntxs |= CLK_LINE_TX;\r\n}\r\noutb(mcr, io + N2_MCR);\r\nport->rxs = rxs;\r\nport->txs = txs;\r\nsca_out(rxs, msci + RXS, card);\r\nsca_out(txs, msci + TXS, card);\r\nsca_set_port(port);\r\n}\r\nstatic int n2_open(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nint io = port->card->io;\r\nu8 mcr = inb(io + N2_MCR) | (port->phy_node ? TX422_PORT1:TX422_PORT0);\r\nint result;\r\nresult = hdlc_open(dev);\r\nif (result)\r\nreturn result;\r\nmcr &= port->phy_node ? ~DTR_PORT1 : ~DTR_PORT0;\r\noutb(mcr, io + N2_MCR);\r\noutb(inb(io + N2_PCR) | PCR_ENWIN, io + N2_PCR);\r\noutb(inb(io + N2_PSR) | PSR_DMAEN, io + N2_PSR);\r\nsca_open(dev);\r\nn2_set_iface(port);\r\nreturn 0;\r\n}\r\nstatic int n2_close(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nint io = port->card->io;\r\nu8 mcr = inb(io+N2_MCR) | (port->phy_node ? TX422_PORT1 : TX422_PORT0);\r\nsca_close(dev);\r\nmcr |= port->phy_node ? DTR_PORT1 : DTR_PORT0;\r\noutb(mcr, io + N2_MCR);\r\nhdlc_close(dev);\r\nreturn 0;\r\n}\r\nstatic int n2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nport_t *port = dev_to_port(dev);\r\n#ifdef DEBUG_RINGS\r\nif (cmd == SIOCDEVPRIVATE) {\r\nsca_dump_rings(dev);\r\nreturn 0;\r\n}\r\n#endif\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nswitch(ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(line, &port->settings, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nif (new_line.clock_type != CLOCK_EXT &&\r\nnew_line.clock_type != CLOCK_TXFROMRX &&\r\nnew_line.clock_type != CLOCK_INT &&\r\nnew_line.clock_type != CLOCK_TXINT)\r\nreturn -EINVAL;\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\nmemcpy(&port->settings, &new_line, size);\r\nn2_set_iface(port);\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void n2_destroy_card(card_t *card)\r\n{\r\nint cnt;\r\nfor (cnt = 0; cnt < 2; cnt++)\r\nif (card->ports[cnt].card) {\r\nstruct net_device *dev = port_to_dev(&card->ports[cnt]);\r\nunregister_hdlc_device(dev);\r\n}\r\nif (card->irq)\r\nfree_irq(card->irq, card);\r\nif (card->winbase) {\r\niounmap(card->winbase);\r\nrelease_mem_region(card->phy_winbase, USE_WINDOWSIZE);\r\n}\r\nif (card->io)\r\nrelease_region(card->io, N2_IOPORTS);\r\nif (card->ports[0].dev)\r\nfree_netdev(card->ports[0].dev);\r\nif (card->ports[1].dev)\r\nfree_netdev(card->ports[1].dev);\r\nkfree(card);\r\n}\r\nstatic int __init n2_run(unsigned long io, unsigned long irq,\r\nunsigned long winbase, long valid0, long valid1)\r\n{\r\ncard_t *card;\r\nu8 cnt, pcr;\r\nint i;\r\nif (io < 0x200 || io > 0x3FF || (io % N2_IOPORTS) != 0) {\r\npr_err("invalid I/O port value\n");\r\nreturn -ENODEV;\r\n}\r\nif (irq < 3 || irq > 15 || irq == 6) {\r\npr_err("invalid IRQ value\n");\r\nreturn -ENODEV;\r\n}\r\nif (winbase < 0xA0000 || winbase > 0xFFFFF || (winbase & 0xFFF) != 0) {\r\npr_err("invalid RAM value\n");\r\nreturn -ENODEV;\r\n}\r\ncard = kzalloc(sizeof(card_t), GFP_KERNEL);\r\nif (card == NULL) {\r\npr_err("unable to allocate memory\n");\r\nreturn -ENOBUFS;\r\n}\r\ncard->ports[0].dev = alloc_hdlcdev(&card->ports[0]);\r\ncard->ports[1].dev = alloc_hdlcdev(&card->ports[1]);\r\nif (!card->ports[0].dev || !card->ports[1].dev) {\r\npr_err("unable to allocate memory\n");\r\nn2_destroy_card(card);\r\nreturn -ENOMEM;\r\n}\r\nif (!request_region(io, N2_IOPORTS, devname)) {\r\npr_err("I/O port region in use\n");\r\nn2_destroy_card(card);\r\nreturn -EBUSY;\r\n}\r\ncard->io = io;\r\nif (request_irq(irq, sca_intr, 0, devname, card)) {\r\npr_err("could not allocate IRQ\n");\r\nn2_destroy_card(card);\r\nreturn -EBUSY;\r\n}\r\ncard->irq = irq;\r\nif (!request_mem_region(winbase, USE_WINDOWSIZE, devname)) {\r\npr_err("could not request RAM window\n");\r\nn2_destroy_card(card);\r\nreturn -EBUSY;\r\n}\r\ncard->phy_winbase = winbase;\r\ncard->winbase = ioremap(winbase, USE_WINDOWSIZE);\r\nif (!card->winbase) {\r\npr_err("ioremap() failed\n");\r\nn2_destroy_card(card);\r\nreturn -EFAULT;\r\n}\r\noutb(0, io + N2_PCR);\r\noutb(winbase >> 12, io + N2_BAR);\r\nswitch (USE_WINDOWSIZE) {\r\ncase 16384:\r\noutb(WIN16K, io + N2_PSR);\r\nbreak;\r\ncase 32768:\r\noutb(WIN32K, io + N2_PSR);\r\nbreak;\r\ncase 65536:\r\noutb(WIN64K, io + N2_PSR);\r\nbreak;\r\ndefault:\r\npr_err("invalid window size\n");\r\nn2_destroy_card(card);\r\nreturn -ENODEV;\r\n}\r\npcr = PCR_ENWIN | PCR_VPM | (USE_BUS16BITS ? PCR_BUS16 : 0);\r\noutb(pcr, io + N2_PCR);\r\ncard->ram_size = sca_detect_ram(card, card->winbase, MAX_RAM_SIZE);\r\ni = card->ram_size / ((valid0 + valid1) * (sizeof(pkt_desc) +\r\nHDLC_MAX_MRU));\r\ncard->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);\r\ncard->rx_ring_buffers = i - card->tx_ring_buffers;\r\ncard->buff_offset = (valid0 + valid1) * sizeof(pkt_desc) *\r\n(card->tx_ring_buffers + card->rx_ring_buffers);\r\npr_info("RISCom/N2 %u KB RAM, IRQ%u, using %u TX + %u RX packets rings\n",\r\ncard->ram_size / 1024, card->irq,\r\ncard->tx_ring_buffers, card->rx_ring_buffers);\r\nif (card->tx_ring_buffers < 1) {\r\npr_err("RAM test failed\n");\r\nn2_destroy_card(card);\r\nreturn -EIO;\r\n}\r\npcr |= PCR_RUNSCA;\r\noutb(pcr, io + N2_PCR);\r\noutb(0, io + N2_MCR);\r\nsca_init(card, 0);\r\nfor (cnt = 0; cnt < 2; cnt++) {\r\nport_t *port = &card->ports[cnt];\r\nstruct net_device *dev = port_to_dev(port);\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nif ((cnt == 0 && !valid0) || (cnt == 1 && !valid1))\r\ncontinue;\r\nport->phy_node = cnt;\r\nport->valid = 1;\r\nif ((cnt == 1) && valid0)\r\nport->log_node = 1;\r\nspin_lock_init(&port->lock);\r\ndev->irq = irq;\r\ndev->mem_start = winbase;\r\ndev->mem_end = winbase + USE_WINDOWSIZE - 1;\r\ndev->tx_queue_len = 50;\r\ndev->netdev_ops = &n2_ops;\r\nhdlc->attach = sca_attach;\r\nhdlc->xmit = sca_xmit;\r\nport->settings.clock_type = CLOCK_EXT;\r\nport->card = card;\r\nif (register_hdlc_device(dev)) {\r\npr_warn("unable to register hdlc device\n");\r\nport->card = NULL;\r\nn2_destroy_card(card);\r\nreturn -ENOBUFS;\r\n}\r\nsca_init_port(port);\r\nnetdev_info(dev, "RISCom/N2 node %d\n", port->phy_node);\r\n}\r\n*new_card = card;\r\nnew_card = &card->next_card;\r\nreturn 0;\r\n}\r\nstatic int __init n2_init(void)\r\n{\r\nif (hw==NULL) {\r\n#ifdef MODULE\r\npr_info("no card initialized\n");\r\n#endif\r\nreturn -EINVAL;\r\n}\r\npr_info("%s\n", version);\r\ndo {\r\nunsigned long io, irq, ram;\r\nlong valid[2] = { 0, 0 };\r\nio = simple_strtoul(hw, &hw, 0);\r\nif (*hw++ != ',')\r\nbreak;\r\nirq = simple_strtoul(hw, &hw, 0);\r\nif (*hw++ != ',')\r\nbreak;\r\nram = simple_strtoul(hw, &hw, 0);\r\nif (*hw++ != ',')\r\nbreak;\r\nwhile(1) {\r\nif (*hw == '0' && !valid[0])\r\nvalid[0] = 1;\r\nelse if (*hw == '1' && !valid[1])\r\nvalid[1] = 1;\r\nelse\r\nbreak;\r\nhw++;\r\n}\r\nif (!valid[0] && !valid[1])\r\nbreak;\r\nif (*hw == ':' || *hw == '\x0')\r\nn2_run(io, irq, ram, valid[0], valid[1]);\r\nif (*hw == '\x0')\r\nreturn first_card ? 0 : -EINVAL;\r\n}while(*hw++ == ':');\r\npr_err("invalid hardware parameters\n");\r\nreturn first_card ? 0 : -EINVAL;\r\n}\r\nstatic void __exit n2_cleanup(void)\r\n{\r\ncard_t *card = first_card;\r\nwhile (card) {\r\ncard_t *ptr = card;\r\ncard = card->next_card;\r\nn2_destroy_card(ptr);\r\n}\r\n}
