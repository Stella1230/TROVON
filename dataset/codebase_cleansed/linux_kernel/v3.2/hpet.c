static cycle_t read_hpet(struct clocksource *cs)\r\n{\r\nreturn (cycle_t)read_counter((void __iomem *)hpet_mctr);\r\n}\r\nstatic inline unsigned long long readq(void __iomem *addr)\r\n{\r\nreturn readl(addr) | (((unsigned long long)readl(addr + 4)) << 32LL);\r\n}\r\nstatic inline void writeq(unsigned long long v, void __iomem *addr)\r\n{\r\nwritel(v & 0xffffffff, addr);\r\nwritel(v >> 32, addr + 4);\r\n}\r\nstatic irqreturn_t hpet_interrupt(int irq, void *data)\r\n{\r\nstruct hpet_dev *devp;\r\nunsigned long isr;\r\ndevp = data;\r\nisr = 1 << (devp - devp->hd_hpets->hp_dev);\r\nif ((devp->hd_flags & HPET_SHARED_IRQ) &&\r\n!(isr & readl(&devp->hd_hpet->hpet_isr)))\r\nreturn IRQ_NONE;\r\nspin_lock(&hpet_lock);\r\ndevp->hd_irqdata++;\r\nif ((devp->hd_flags & (HPET_IE | HPET_PERIODIC)) == HPET_IE) {\r\nunsigned long m, t, mc, base, k;\r\nstruct hpet __iomem *hpet = devp->hd_hpet;\r\nstruct hpets *hpetp = devp->hd_hpets;\r\nt = devp->hd_ireqfreq;\r\nm = read_counter(&devp->hd_timer->hpet_compare);\r\nmc = read_counter(&hpet->hpet_mc);\r\nbase = mc % t;\r\nk = (mc - base + hpetp->hp_delta) / t;\r\nwrite_counter(t * (k + 1) + base,\r\n&devp->hd_timer->hpet_compare);\r\n}\r\nif (devp->hd_flags & HPET_SHARED_IRQ)\r\nwritel(isr, &devp->hd_hpet->hpet_isr);\r\nspin_unlock(&hpet_lock);\r\nwake_up_interruptible(&devp->hd_waitqueue);\r\nkill_fasync(&devp->hd_async_queue, SIGIO, POLL_IN);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hpet_timer_set_irq(struct hpet_dev *devp)\r\n{\r\nunsigned long v;\r\nint irq, gsi;\r\nstruct hpet_timer __iomem *timer;\r\nspin_lock_irq(&hpet_lock);\r\nif (devp->hd_hdwirq) {\r\nspin_unlock_irq(&hpet_lock);\r\nreturn;\r\n}\r\ntimer = devp->hd_timer;\r\nv = readl(&timer->hpet_config);\r\nif (!(v & Tn_INT_TYPE_CNF_MASK)) {\r\nv |= Tn_INT_TYPE_CNF_MASK;\r\nwritel(v, &timer->hpet_config);\r\n}\r\nspin_unlock_irq(&hpet_lock);\r\nv = (readq(&timer->hpet_config) & Tn_INT_ROUTE_CAP_MASK) >>\r\nTn_INT_ROUTE_CAP_SHIFT;\r\nif (acpi_irq_model == ACPI_IRQ_MODEL_PIC)\r\nv &= ~0xf3df;\r\nelse\r\nv &= ~0xffff;\r\nfor_each_set_bit(irq, &v, HPET_MAX_IRQ) {\r\nif (irq >= nr_irqs) {\r\nirq = HPET_MAX_IRQ;\r\nbreak;\r\n}\r\ngsi = acpi_register_gsi(NULL, irq, ACPI_LEVEL_SENSITIVE,\r\nACPI_ACTIVE_LOW);\r\nif (gsi > 0)\r\nbreak;\r\n}\r\nif (irq < HPET_MAX_IRQ) {\r\nspin_lock_irq(&hpet_lock);\r\nv = readl(&timer->hpet_config);\r\nv |= irq << Tn_INT_ROUTE_CNF_SHIFT;\r\nwritel(v, &timer->hpet_config);\r\ndevp->hd_hdwirq = gsi;\r\nspin_unlock_irq(&hpet_lock);\r\n}\r\nreturn;\r\n}\r\nstatic int hpet_open(struct inode *inode, struct file *file)\r\n{\r\nstruct hpet_dev *devp;\r\nstruct hpets *hpetp;\r\nint i;\r\nif (file->f_mode & FMODE_WRITE)\r\nreturn -EINVAL;\r\nmutex_lock(&hpet_mutex);\r\nspin_lock_irq(&hpet_lock);\r\nfor (devp = NULL, hpetp = hpets; hpetp && !devp; hpetp = hpetp->hp_next)\r\nfor (i = 0; i < hpetp->hp_ntimer; i++)\r\nif (hpetp->hp_dev[i].hd_flags & HPET_OPEN)\r\ncontinue;\r\nelse {\r\ndevp = &hpetp->hp_dev[i];\r\nbreak;\r\n}\r\nif (!devp) {\r\nspin_unlock_irq(&hpet_lock);\r\nmutex_unlock(&hpet_mutex);\r\nreturn -EBUSY;\r\n}\r\nfile->private_data = devp;\r\ndevp->hd_irqdata = 0;\r\ndevp->hd_flags |= HPET_OPEN;\r\nspin_unlock_irq(&hpet_lock);\r\nmutex_unlock(&hpet_mutex);\r\nhpet_timer_set_irq(devp);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nhpet_read(struct file *file, char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long data;\r\nssize_t retval;\r\nstruct hpet_dev *devp;\r\ndevp = file->private_data;\r\nif (!devp->hd_ireqfreq)\r\nreturn -EIO;\r\nif (count < sizeof(unsigned long))\r\nreturn -EINVAL;\r\nadd_wait_queue(&devp->hd_waitqueue, &wait);\r\nfor ( ; ; ) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock_irq(&hpet_lock);\r\ndata = devp->hd_irqdata;\r\ndevp->hd_irqdata = 0;\r\nspin_unlock_irq(&hpet_lock);\r\nif (data)\r\nbreak;\r\nelse if (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto out;\r\n} else if (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\ngoto out;\r\n}\r\nschedule();\r\n}\r\nretval = put_user(data, (unsigned long __user *)buf);\r\nif (!retval)\r\nretval = sizeof(unsigned long);\r\nout:\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&devp->hd_waitqueue, &wait);\r\nreturn retval;\r\n}\r\nstatic unsigned int hpet_poll(struct file *file, poll_table * wait)\r\n{\r\nunsigned long v;\r\nstruct hpet_dev *devp;\r\ndevp = file->private_data;\r\nif (!devp->hd_ireqfreq)\r\nreturn 0;\r\npoll_wait(file, &devp->hd_waitqueue, wait);\r\nspin_lock_irq(&hpet_lock);\r\nv = devp->hd_irqdata;\r\nspin_unlock_irq(&hpet_lock);\r\nif (v != 0)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int hpet_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\n#ifdef CONFIG_HPET_MMAP\r\nstruct hpet_dev *devp;\r\nunsigned long addr;\r\nif (((vma->vm_end - vma->vm_start) != PAGE_SIZE) || vma->vm_pgoff)\r\nreturn -EINVAL;\r\ndevp = file->private_data;\r\naddr = devp->hd_hpets->hp_hpet_phys;\r\nif (addr & (PAGE_SIZE - 1))\r\nreturn -ENOSYS;\r\nvma->vm_flags |= VM_IO;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nif (io_remap_pfn_range(vma, vma->vm_start, addr >> PAGE_SHIFT,\r\nPAGE_SIZE, vma->vm_page_prot)) {\r\nprintk(KERN_ERR "%s: io_remap_pfn_range failed\n",\r\n__func__);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n#else\r\nreturn -ENOSYS;\r\n#endif\r\n}\r\nstatic int hpet_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct hpet_dev *devp;\r\ndevp = file->private_data;\r\nif (fasync_helper(fd, file, on, &devp->hd_async_queue) >= 0)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int hpet_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hpet_dev *devp;\r\nstruct hpet_timer __iomem *timer;\r\nint irq = 0;\r\ndevp = file->private_data;\r\ntimer = devp->hd_timer;\r\nspin_lock_irq(&hpet_lock);\r\nwriteq((readq(&timer->hpet_config) & ~Tn_INT_ENB_CNF_MASK),\r\n&timer->hpet_config);\r\nirq = devp->hd_irq;\r\ndevp->hd_irq = 0;\r\ndevp->hd_ireqfreq = 0;\r\nif (devp->hd_flags & HPET_PERIODIC\r\n&& readq(&timer->hpet_config) & Tn_TYPE_CNF_MASK) {\r\nunsigned long v;\r\nv = readq(&timer->hpet_config);\r\nv ^= Tn_TYPE_CNF_MASK;\r\nwriteq(v, &timer->hpet_config);\r\n}\r\ndevp->hd_flags &= ~(HPET_OPEN | HPET_IE | HPET_PERIODIC);\r\nspin_unlock_irq(&hpet_lock);\r\nif (irq)\r\nfree_irq(irq, devp);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int hpet_ioctl_ieon(struct hpet_dev *devp)\r\n{\r\nstruct hpet_timer __iomem *timer;\r\nstruct hpet __iomem *hpet;\r\nstruct hpets *hpetp;\r\nint irq;\r\nunsigned long g, v, t, m;\r\nunsigned long flags, isr;\r\ntimer = devp->hd_timer;\r\nhpet = devp->hd_hpet;\r\nhpetp = devp->hd_hpets;\r\nif (!devp->hd_ireqfreq)\r\nreturn -EIO;\r\nspin_lock_irq(&hpet_lock);\r\nif (devp->hd_flags & HPET_IE) {\r\nspin_unlock_irq(&hpet_lock);\r\nreturn -EBUSY;\r\n}\r\ndevp->hd_flags |= HPET_IE;\r\nif (readl(&timer->hpet_config) & Tn_INT_TYPE_CNF_MASK)\r\ndevp->hd_flags |= HPET_SHARED_IRQ;\r\nspin_unlock_irq(&hpet_lock);\r\nirq = devp->hd_hdwirq;\r\nif (irq) {\r\nunsigned long irq_flags;\r\nif (devp->hd_flags & HPET_SHARED_IRQ) {\r\nwritel(readl(&timer->hpet_config) & ~Tn_TYPE_CNF_MASK,\r\n&timer->hpet_config);\r\nwrite_counter(read_counter(&hpet->hpet_mc),\r\n&timer->hpet_compare);\r\nisr = 1 << (devp - devp->hd_hpets->hp_dev);\r\nwritel(isr, &hpet->hpet_isr);\r\n}\r\nsprintf(devp->hd_name, "hpet%d", (int)(devp - hpetp->hp_dev));\r\nirq_flags = devp->hd_flags & HPET_SHARED_IRQ\r\n? IRQF_SHARED : IRQF_DISABLED;\r\nif (request_irq(irq, hpet_interrupt, irq_flags,\r\ndevp->hd_name, (void *)devp)) {\r\nprintk(KERN_ERR "hpet: IRQ %d is not free\n", irq);\r\nirq = 0;\r\n}\r\n}\r\nif (irq == 0) {\r\nspin_lock_irq(&hpet_lock);\r\ndevp->hd_flags ^= HPET_IE;\r\nspin_unlock_irq(&hpet_lock);\r\nreturn -EIO;\r\n}\r\ndevp->hd_irq = irq;\r\nt = devp->hd_ireqfreq;\r\nv = readq(&timer->hpet_config);\r\ng = v | Tn_32MODE_CNF_MASK | Tn_INT_ENB_CNF_MASK;\r\nif (devp->hd_flags & HPET_PERIODIC) {\r\ng |= Tn_TYPE_CNF_MASK;\r\nv |= Tn_TYPE_CNF_MASK | Tn_VAL_SET_CNF_MASK;\r\nwriteq(v, &timer->hpet_config);\r\nlocal_irq_save(flags);\r\nm = read_counter(&hpet->hpet_mc);\r\nwrite_counter(t + m + hpetp->hp_delta, &timer->hpet_compare);\r\nwrite_counter(t, &timer->hpet_compare);\r\n} else {\r\nlocal_irq_save(flags);\r\nm = read_counter(&hpet->hpet_mc);\r\nwrite_counter(t + m + hpetp->hp_delta, &timer->hpet_compare);\r\n}\r\nif (devp->hd_flags & HPET_SHARED_IRQ) {\r\nisr = 1 << (devp - devp->hd_hpets->hp_dev);\r\nwritel(isr, &hpet->hpet_isr);\r\n}\r\nwriteq(g, &timer->hpet_config);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic inline unsigned long hpet_time_div(struct hpets *hpets,\r\nunsigned long dis)\r\n{\r\nunsigned long long m;\r\nm = hpets->hp_tick_freq + (dis >> 1);\r\ndo_div(m, dis);\r\nreturn (unsigned long)m;\r\n}\r\nstatic int\r\nhpet_ioctl_common(struct hpet_dev *devp, int cmd, unsigned long arg,\r\nstruct hpet_info *info)\r\n{\r\nstruct hpet_timer __iomem *timer;\r\nstruct hpet __iomem *hpet;\r\nstruct hpets *hpetp;\r\nint err;\r\nunsigned long v;\r\nswitch (cmd) {\r\ncase HPET_IE_OFF:\r\ncase HPET_INFO:\r\ncase HPET_EPI:\r\ncase HPET_DPI:\r\ncase HPET_IRQFREQ:\r\ntimer = devp->hd_timer;\r\nhpet = devp->hd_hpet;\r\nhpetp = devp->hd_hpets;\r\nbreak;\r\ncase HPET_IE_ON:\r\nreturn hpet_ioctl_ieon(devp);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = 0;\r\nswitch (cmd) {\r\ncase HPET_IE_OFF:\r\nif ((devp->hd_flags & HPET_IE) == 0)\r\nbreak;\r\nv = readq(&timer->hpet_config);\r\nv &= ~Tn_INT_ENB_CNF_MASK;\r\nwriteq(v, &timer->hpet_config);\r\nif (devp->hd_irq) {\r\nfree_irq(devp->hd_irq, devp);\r\ndevp->hd_irq = 0;\r\n}\r\ndevp->hd_flags ^= HPET_IE;\r\nbreak;\r\ncase HPET_INFO:\r\n{\r\nmemset(info, 0, sizeof(*info));\r\nif (devp->hd_ireqfreq)\r\ninfo->hi_ireqfreq =\r\nhpet_time_div(hpetp, devp->hd_ireqfreq);\r\ninfo->hi_flags =\r\nreadq(&timer->hpet_config) & Tn_PER_INT_CAP_MASK;\r\ninfo->hi_hpet = hpetp->hp_which;\r\ninfo->hi_timer = devp - hpetp->hp_dev;\r\nbreak;\r\n}\r\ncase HPET_EPI:\r\nv = readq(&timer->hpet_config);\r\nif ((v & Tn_PER_INT_CAP_MASK) == 0) {\r\nerr = -ENXIO;\r\nbreak;\r\n}\r\ndevp->hd_flags |= HPET_PERIODIC;\r\nbreak;\r\ncase HPET_DPI:\r\nv = readq(&timer->hpet_config);\r\nif ((v & Tn_PER_INT_CAP_MASK) == 0) {\r\nerr = -ENXIO;\r\nbreak;\r\n}\r\nif (devp->hd_flags & HPET_PERIODIC &&\r\nreadq(&timer->hpet_config) & Tn_TYPE_CNF_MASK) {\r\nv = readq(&timer->hpet_config);\r\nv ^= Tn_TYPE_CNF_MASK;\r\nwriteq(v, &timer->hpet_config);\r\n}\r\ndevp->hd_flags &= ~HPET_PERIODIC;\r\nbreak;\r\ncase HPET_IRQFREQ:\r\nif ((arg > hpet_max_freq) &&\r\n!capable(CAP_SYS_RESOURCE)) {\r\nerr = -EACCES;\r\nbreak;\r\n}\r\nif (!arg) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndevp->hd_ireqfreq = hpet_time_div(hpetp, arg);\r\n}\r\nreturn err;\r\n}\r\nstatic long\r\nhpet_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct hpet_info info;\r\nint err;\r\nmutex_lock(&hpet_mutex);\r\nerr = hpet_ioctl_common(file->private_data, cmd, arg, &info);\r\nmutex_unlock(&hpet_mutex);\r\nif ((cmd == HPET_INFO) && !err &&\r\n(copy_to_user((void __user *)arg, &info, sizeof(info))))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic long\r\nhpet_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct hpet_info info;\r\nint err;\r\nmutex_lock(&hpet_mutex);\r\nerr = hpet_ioctl_common(file->private_data, cmd, arg, &info);\r\nmutex_unlock(&hpet_mutex);\r\nif ((cmd == HPET_INFO) && !err) {\r\nstruct compat_hpet_info __user *u = compat_ptr(arg);\r\nif (put_user(info.hi_ireqfreq, &u->hi_ireqfreq) ||\r\nput_user(info.hi_flags, &u->hi_flags) ||\r\nput_user(info.hi_hpet, &u->hi_hpet) ||\r\nput_user(info.hi_timer, &u->hi_timer))\r\nerr = -EFAULT;\r\n}\r\nreturn err;\r\n}\r\nstatic int hpet_is_known(struct hpet_data *hdp)\r\n{\r\nstruct hpets *hpetp;\r\nfor (hpetp = hpets; hpetp; hpetp = hpetp->hp_next)\r\nif (hpetp->hp_hpet_phys == hdp->hd_phys_address)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned long __hpet_calibrate(struct hpets *hpetp)\r\n{\r\nstruct hpet_timer __iomem *timer = NULL;\r\nunsigned long t, m, count, i, flags, start;\r\nstruct hpet_dev *devp;\r\nint j;\r\nstruct hpet __iomem *hpet;\r\nfor (j = 0, devp = hpetp->hp_dev; j < hpetp->hp_ntimer; j++, devp++)\r\nif ((devp->hd_flags & HPET_OPEN) == 0) {\r\ntimer = devp->hd_timer;\r\nbreak;\r\n}\r\nif (!timer)\r\nreturn 0;\r\nhpet = hpetp->hp_hpet;\r\nt = read_counter(&timer->hpet_compare);\r\ni = 0;\r\ncount = hpet_time_div(hpetp, TICK_CALIBRATE);\r\nlocal_irq_save(flags);\r\nstart = read_counter(&hpet->hpet_mc);\r\ndo {\r\nm = read_counter(&hpet->hpet_mc);\r\nwrite_counter(t + m + hpetp->hp_delta, &timer->hpet_compare);\r\n} while (i++, (m - start) < count);\r\nlocal_irq_restore(flags);\r\nreturn (m - start) / i;\r\n}\r\nstatic unsigned long hpet_calibrate(struct hpets *hpetp)\r\n{\r\nunsigned long ret = -1;\r\nunsigned long tmp;\r\nfor ( ; ; ) {\r\ntmp = __hpet_calibrate(hpetp);\r\nif (ret <= tmp)\r\nbreak;\r\nret = tmp;\r\n}\r\nreturn ret;\r\n}\r\nint hpet_alloc(struct hpet_data *hdp)\r\n{\r\nu64 cap, mcfg;\r\nstruct hpet_dev *devp;\r\nu32 i, ntimer;\r\nstruct hpets *hpetp;\r\nsize_t siz;\r\nstruct hpet __iomem *hpet;\r\nstatic struct hpets *last;\r\nunsigned long period;\r\nunsigned long long temp;\r\nu32 remainder;\r\nif (hpet_is_known(hdp)) {\r\nprintk(KERN_DEBUG "%s: duplicate HPET ignored\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nsiz = sizeof(struct hpets) + ((hdp->hd_nirqs - 1) *\r\nsizeof(struct hpet_dev));\r\nhpetp = kzalloc(siz, GFP_KERNEL);\r\nif (!hpetp)\r\nreturn -ENOMEM;\r\nhpetp->hp_which = hpet_nhpet++;\r\nhpetp->hp_hpet = hdp->hd_address;\r\nhpetp->hp_hpet_phys = hdp->hd_phys_address;\r\nhpetp->hp_ntimer = hdp->hd_nirqs;\r\nfor (i = 0; i < hdp->hd_nirqs; i++)\r\nhpetp->hp_dev[i].hd_hdwirq = hdp->hd_irq[i];\r\nhpet = hpetp->hp_hpet;\r\ncap = readq(&hpet->hpet_cap);\r\nntimer = ((cap & HPET_NUM_TIM_CAP_MASK) >> HPET_NUM_TIM_CAP_SHIFT) + 1;\r\nif (hpetp->hp_ntimer != ntimer) {\r\nprintk(KERN_WARNING "hpet: number irqs doesn't agree"\r\n" with number of timers\n");\r\nkfree(hpetp);\r\nreturn -ENODEV;\r\n}\r\nif (last)\r\nlast->hp_next = hpetp;\r\nelse\r\nhpets = hpetp;\r\nlast = hpetp;\r\nperiod = (cap & HPET_COUNTER_CLK_PERIOD_MASK) >>\r\nHPET_COUNTER_CLK_PERIOD_SHIFT;\r\ntemp = 1000000000000000uLL;\r\ntemp += period >> 1;\r\ndo_div(temp, period);\r\nhpetp->hp_tick_freq = temp;\r\nprintk(KERN_INFO "hpet%d: at MMIO 0x%lx, IRQ%s",\r\nhpetp->hp_which, hdp->hd_phys_address,\r\nhpetp->hp_ntimer > 1 ? "s" : "");\r\nfor (i = 0; i < hpetp->hp_ntimer; i++)\r\nprintk("%s %d", i > 0 ? "," : "", hdp->hd_irq[i]);\r\nprintk("\n");\r\ntemp = hpetp->hp_tick_freq;\r\nremainder = do_div(temp, 1000000);\r\nprintk(KERN_INFO\r\n"hpet%u: %u comparators, %d-bit %u.%06u MHz counter\n",\r\nhpetp->hp_which, hpetp->hp_ntimer,\r\ncap & HPET_COUNTER_SIZE_MASK ? 64 : 32,\r\n(unsigned) temp, remainder);\r\nmcfg = readq(&hpet->hpet_config);\r\nif ((mcfg & HPET_ENABLE_CNF_MASK) == 0) {\r\nwrite_counter(0L, &hpet->hpet_mc);\r\nmcfg |= HPET_ENABLE_CNF_MASK;\r\nwriteq(mcfg, &hpet->hpet_config);\r\n}\r\nfor (i = 0, devp = hpetp->hp_dev; i < hpetp->hp_ntimer; i++, devp++) {\r\nstruct hpet_timer __iomem *timer;\r\ntimer = &hpet->hpet_timers[devp - hpetp->hp_dev];\r\ndevp->hd_hpets = hpetp;\r\ndevp->hd_hpet = hpet;\r\ndevp->hd_timer = timer;\r\nif (hdp->hd_state & (1 << i)) {\r\ndevp->hd_flags = HPET_OPEN;\r\ncontinue;\r\n}\r\ninit_waitqueue_head(&devp->hd_waitqueue);\r\n}\r\nhpetp->hp_delta = hpet_calibrate(hpetp);\r\n#ifdef CONFIG_IA64\r\nif (!hpet_clocksource) {\r\nhpet_mctr = (void __iomem *)&hpetp->hp_hpet->hpet_mc;\r\nclocksource_hpet.archdata.fsys_mmio = hpet_mctr;\r\nclocksource_register_hz(&clocksource_hpet, hpetp->hp_tick_freq);\r\nhpetp->hp_clocksource = &clocksource_hpet;\r\nhpet_clocksource = &clocksource_hpet;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic acpi_status hpet_resources(struct acpi_resource *res, void *data)\r\n{\r\nstruct hpet_data *hdp;\r\nacpi_status status;\r\nstruct acpi_resource_address64 addr;\r\nhdp = data;\r\nstatus = acpi_resource_to_address64(res, &addr);\r\nif (ACPI_SUCCESS(status)) {\r\nhdp->hd_phys_address = addr.minimum;\r\nhdp->hd_address = ioremap(addr.minimum, addr.address_length);\r\nif (hpet_is_known(hdp)) {\r\niounmap(hdp->hd_address);\r\nreturn AE_ALREADY_EXISTS;\r\n}\r\n} else if (res->type == ACPI_RESOURCE_TYPE_FIXED_MEMORY32) {\r\nstruct acpi_resource_fixed_memory32 *fixmem32;\r\nfixmem32 = &res->data.fixed_memory32;\r\nif (!fixmem32)\r\nreturn AE_NO_MEMORY;\r\nhdp->hd_phys_address = fixmem32->address;\r\nhdp->hd_address = ioremap(fixmem32->address,\r\nHPET_RANGE_SIZE);\r\nif (hpet_is_known(hdp)) {\r\niounmap(hdp->hd_address);\r\nreturn AE_ALREADY_EXISTS;\r\n}\r\n} else if (res->type == ACPI_RESOURCE_TYPE_EXTENDED_IRQ) {\r\nstruct acpi_resource_extended_irq *irqp;\r\nint i, irq;\r\nirqp = &res->data.extended_irq;\r\nfor (i = 0; i < irqp->interrupt_count; i++) {\r\nirq = acpi_register_gsi(NULL, irqp->interrupts[i],\r\nirqp->triggering, irqp->polarity);\r\nif (irq < 0)\r\nreturn AE_ERROR;\r\nhdp->hd_irq[hdp->hd_nirqs] = irq;\r\nhdp->hd_nirqs++;\r\n}\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic int hpet_acpi_add(struct acpi_device *device)\r\n{\r\nacpi_status result;\r\nstruct hpet_data data;\r\nmemset(&data, 0, sizeof(data));\r\nresult =\r\nacpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\nhpet_resources, &data);\r\nif (ACPI_FAILURE(result))\r\nreturn -ENODEV;\r\nif (!data.hd_address || !data.hd_nirqs) {\r\nif (data.hd_address)\r\niounmap(data.hd_address);\r\nprintk("%s: no address or irqs in _CRS\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nreturn hpet_alloc(&data);\r\n}\r\nstatic int hpet_acpi_remove(struct acpi_device *device, int type)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int __init hpet_init(void)\r\n{\r\nint result;\r\nresult = misc_register(&hpet_misc);\r\nif (result < 0)\r\nreturn -ENODEV;\r\nsysctl_header = register_sysctl_table(dev_root);\r\nresult = acpi_bus_register_driver(&hpet_acpi_driver);\r\nif (result < 0) {\r\nif (sysctl_header)\r\nunregister_sysctl_table(sysctl_header);\r\nmisc_deregister(&hpet_misc);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hpet_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&hpet_acpi_driver);\r\nif (sysctl_header)\r\nunregister_sysctl_table(sysctl_header);\r\nmisc_deregister(&hpet_misc);\r\nreturn;\r\n}
