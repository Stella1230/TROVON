static inline void new_memcpy_toio(char __iomem *dest, char *src, int length)\r\n{\r\nint len;\r\ndo {\r\nlen = length > 256 ? 256 : length;\r\nmemcpy_toio(dest, src, len);\r\ndest += len;\r\nsrc += len;\r\nlength -= len;\r\nreadb(dest);\r\n} while (len);\r\n}\r\nstatic void pci200_set_iface(port_t *port)\r\n{\r\ncard_t *card = port->card;\r\nu16 msci = get_msci(port);\r\nu8 rxs = port->rxs & CLK_BRG_MASK;\r\nu8 txs = port->txs & CLK_BRG_MASK;\r\nsca_out(EXS_TES1, (port->chan ? MSCI1_OFFSET : MSCI0_OFFSET) + EXS,\r\nport->card);\r\nswitch(port->settings.clock_type) {\r\ncase CLOCK_INT:\r\nrxs |= CLK_BRG;\r\ntxs |= CLK_PIN_OUT | CLK_TX_RXCLK;\r\nbreak;\r\ncase CLOCK_TXINT:\r\nrxs |= CLK_LINE;\r\ntxs |= CLK_PIN_OUT | CLK_BRG;\r\nbreak;\r\ncase CLOCK_TXFROMRX:\r\nrxs |= CLK_LINE;\r\ntxs |= CLK_PIN_OUT | CLK_TX_RXCLK;\r\nbreak;\r\ndefault:\r\nrxs |= CLK_LINE;\r\ntxs |= CLK_PIN_OUT | CLK_LINE;\r\nbreak;\r\n}\r\nport->rxs = rxs;\r\nport->txs = txs;\r\nsca_out(rxs, msci + RXS, card);\r\nsca_out(txs, msci + TXS, card);\r\nsca_set_port(port);\r\n}\r\nstatic int pci200_open(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nint result = hdlc_open(dev);\r\nif (result)\r\nreturn result;\r\nsca_open(dev);\r\npci200_set_iface(port);\r\nsca_flush(port->card);\r\nreturn 0;\r\n}\r\nstatic int pci200_close(struct net_device *dev)\r\n{\r\nsca_close(dev);\r\nsca_flush(dev_to_port(dev)->card);\r\nhdlc_close(dev);\r\nreturn 0;\r\n}\r\nstatic int pci200_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nport_t *port = dev_to_port(dev);\r\n#ifdef DEBUG_RINGS\r\nif (cmd == SIOCDEVPRIVATE) {\r\nsca_dump_rings(dev);\r\nreturn 0;\r\n}\r\n#endif\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nswitch(ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nifr->ifr_settings.type = IF_IFACE_V35;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(line, &port->settings, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_IFACE_V35:\r\ncase IF_IFACE_SYNC_SERIAL:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nif (new_line.clock_type != CLOCK_EXT &&\r\nnew_line.clock_type != CLOCK_TXFROMRX &&\r\nnew_line.clock_type != CLOCK_INT &&\r\nnew_line.clock_type != CLOCK_TXINT)\r\nreturn -EINVAL;\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\nmemcpy(&port->settings, &new_line, size);\r\npci200_set_iface(port);\r\nsca_flush(port->card);\r\nreturn 0;\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void pci200_pci_remove_one(struct pci_dev *pdev)\r\n{\r\nint i;\r\ncard_t *card = pci_get_drvdata(pdev);\r\nfor (i = 0; i < 2; i++)\r\nif (card->ports[i].card)\r\nunregister_hdlc_device(card->ports[i].netdev);\r\nif (card->irq)\r\nfree_irq(card->irq, card);\r\nif (card->rambase)\r\niounmap(card->rambase);\r\nif (card->scabase)\r\niounmap(card->scabase);\r\nif (card->plxbase)\r\niounmap(card->plxbase);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nif (card->ports[0].netdev)\r\nfree_netdev(card->ports[0].netdev);\r\nif (card->ports[1].netdev)\r\nfree_netdev(card->ports[1].netdev);\r\nkfree(card);\r\n}\r\nstatic int __devinit pci200_pci_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\ncard_t *card;\r\nu32 __iomem *p;\r\nint i;\r\nu32 ramsize;\r\nu32 ramphys;\r\nu32 scaphys;\r\nu32 plxphys;\r\ni = pci_enable_device(pdev);\r\nif (i)\r\nreturn i;\r\ni = pci_request_regions(pdev, "PCI200SYN");\r\nif (i) {\r\npci_disable_device(pdev);\r\nreturn i;\r\n}\r\ncard = kzalloc(sizeof(card_t), GFP_KERNEL);\r\nif (card == NULL) {\r\npr_err("unable to allocate memory\n");\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nreturn -ENOBUFS;\r\n}\r\npci_set_drvdata(pdev, card);\r\ncard->ports[0].netdev = alloc_hdlcdev(&card->ports[0]);\r\ncard->ports[1].netdev = alloc_hdlcdev(&card->ports[1]);\r\nif (!card->ports[0].netdev || !card->ports[1].netdev) {\r\npr_err("unable to allocate memory\n");\r\npci200_pci_remove_one(pdev);\r\nreturn -ENOMEM;\r\n}\r\nif (pci_resource_len(pdev, 0) != PCI200SYN_PLX_SIZE ||\r\npci_resource_len(pdev, 2) != PCI200SYN_SCA_SIZE ||\r\npci_resource_len(pdev, 3) < 16384) {\r\npr_err("invalid card EEPROM parameters\n");\r\npci200_pci_remove_one(pdev);\r\nreturn -EFAULT;\r\n}\r\nplxphys = pci_resource_start(pdev,0) & PCI_BASE_ADDRESS_MEM_MASK;\r\ncard->plxbase = ioremap(plxphys, PCI200SYN_PLX_SIZE);\r\nscaphys = pci_resource_start(pdev,2) & PCI_BASE_ADDRESS_MEM_MASK;\r\ncard->scabase = ioremap(scaphys, PCI200SYN_SCA_SIZE);\r\nramphys = pci_resource_start(pdev,3) & PCI_BASE_ADDRESS_MEM_MASK;\r\ncard->rambase = pci_ioremap_bar(pdev, 3);\r\nif (card->plxbase == NULL ||\r\ncard->scabase == NULL ||\r\ncard->rambase == NULL) {\r\npr_err("ioremap() failed\n");\r\npci200_pci_remove_one(pdev);\r\nreturn -EFAULT;\r\n}\r\np = &card->plxbase->init_ctrl;\r\nwritel(readl(p) | 0x40000000, p);\r\nreadl(p);\r\nudelay(1);\r\nwritel(readl(p) & ~0x40000000, p);\r\nreadl(p);\r\nudelay(1);\r\nramsize = sca_detect_ram(card, card->rambase,\r\npci_resource_len(pdev, 3));\r\ni = ramsize / (2 * (sizeof(pkt_desc) + HDLC_MAX_MRU));\r\ncard->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);\r\ncard->rx_ring_buffers = i - card->tx_ring_buffers;\r\ncard->buff_offset = 2 * sizeof(pkt_desc) * (card->tx_ring_buffers +\r\ncard->rx_ring_buffers);\r\npr_info("%u KB RAM at 0x%x, IRQ%u, using %u TX + %u RX packets rings\n",\r\nramsize / 1024, ramphys,\r\npdev->irq, card->tx_ring_buffers, card->rx_ring_buffers);\r\nif (card->tx_ring_buffers < 1) {\r\npr_err("RAM test failed\n");\r\npci200_pci_remove_one(pdev);\r\nreturn -EFAULT;\r\n}\r\np = &card->plxbase->intr_ctrl_stat;\r\nwritew(readw(p) | 0x0040, p);\r\nif (request_irq(pdev->irq, sca_intr, IRQF_SHARED, "pci200syn", card)) {\r\npr_warn("could not allocate IRQ%d\n", pdev->irq);\r\npci200_pci_remove_one(pdev);\r\nreturn -EBUSY;\r\n}\r\ncard->irq = pdev->irq;\r\nsca_init(card, 0);\r\nfor (i = 0; i < 2; i++) {\r\nport_t *port = &card->ports[i];\r\nstruct net_device *dev = port->netdev;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nport->chan = i;\r\nspin_lock_init(&port->lock);\r\ndev->irq = card->irq;\r\ndev->mem_start = ramphys;\r\ndev->mem_end = ramphys + ramsize - 1;\r\ndev->tx_queue_len = 50;\r\ndev->netdev_ops = &pci200_ops;\r\nhdlc->attach = sca_attach;\r\nhdlc->xmit = sca_xmit;\r\nport->settings.clock_type = CLOCK_EXT;\r\nport->card = card;\r\nsca_init_port(port);\r\nif (register_hdlc_device(dev)) {\r\npr_err("unable to register hdlc device\n");\r\nport->card = NULL;\r\npci200_pci_remove_one(pdev);\r\nreturn -ENOBUFS;\r\n}\r\nnetdev_info(dev, "PCI200SYN channel %d\n", port->chan);\r\n}\r\nsca_flush(card);\r\nreturn 0;\r\n}\r\nstatic int __init pci200_init_module(void)\r\n{\r\nif (pci_clock_freq < 1000000 || pci_clock_freq > 80000000) {\r\npr_err("Invalid PCI clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nreturn pci_register_driver(&pci200_pci_driver);\r\n}\r\nstatic void __exit pci200_cleanup_module(void)\r\n{\r\npci_unregister_driver(&pci200_pci_driver);\r\n}
