int llc_conn_state_process(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint rc;\r\nstruct llc_sock *llc = llc_sk(skb->sk);\r\nstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\r\nskb_get(skb);\r\nev->ind_prim = ev->cfm_prim = 0;\r\nrc = llc_conn_service(skb->sk, skb);\r\nif (unlikely(rc != 0)) {\r\nprintk(KERN_ERR "%s: llc_conn_service failed\n", __func__);\r\ngoto out_kfree_skb;\r\n}\r\nif (unlikely(!ev->ind_prim && !ev->cfm_prim)) {\r\nif (!skb->next)\r\ngoto out_kfree_skb;\r\ngoto out_skb_put;\r\n}\r\nif (unlikely(ev->ind_prim && ev->cfm_prim))\r\nskb_get(skb);\r\nswitch (ev->ind_prim) {\r\ncase LLC_DATA_PRIM:\r\nllc_save_primitive(sk, skb, LLC_DATA_PRIM);\r\nif (unlikely(sock_queue_rcv_skb(sk, skb))) {\r\nprintk(KERN_ERR "%s: sock_queue_rcv_skb failed!\n",\r\n__func__);\r\nkfree_skb(skb);\r\n}\r\nbreak;\r\ncase LLC_CONN_PRIM:\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_state_change(sk);\r\nbreak;\r\ncase LLC_DISC_PRIM:\r\nsock_hold(sk);\r\nif (sk->sk_type == SOCK_STREAM &&\r\nsk->sk_state == TCP_ESTABLISHED) {\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nsk->sk_socket->state = SS_UNCONNECTED;\r\nsk->sk_state = TCP_CLOSE;\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsk->sk_state_change(sk);\r\n}\r\n}\r\nkfree_skb(skb);\r\nsock_put(sk);\r\nbreak;\r\ncase LLC_RESET_PRIM:\r\nprintk(KERN_INFO "%s: received a reset ind!\n", __func__);\r\nkfree_skb(skb);\r\nbreak;\r\ndefault:\r\nif (ev->ind_prim) {\r\nprintk(KERN_INFO "%s: received unknown %d prim!\n",\r\n__func__, ev->ind_prim);\r\nkfree_skb(skb);\r\n}\r\nbreak;\r\n}\r\nswitch (ev->cfm_prim) {\r\ncase LLC_DATA_PRIM:\r\nif (!llc_data_accept_state(llc->state))\r\nsk->sk_write_space(sk);\r\nelse\r\nrc = llc->failed_data_req = 1;\r\nbreak;\r\ncase LLC_CONN_PRIM:\r\nif (sk->sk_type == SOCK_STREAM &&\r\nsk->sk_state == TCP_SYN_SENT) {\r\nif (ev->status) {\r\nsk->sk_socket->state = SS_UNCONNECTED;\r\nsk->sk_state = TCP_CLOSE;\r\n} else {\r\nsk->sk_socket->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\n}\r\nsk->sk_state_change(sk);\r\n}\r\nbreak;\r\ncase LLC_DISC_PRIM:\r\nsock_hold(sk);\r\nif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSING) {\r\nsk->sk_socket->state = SS_UNCONNECTED;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_state_change(sk);\r\n}\r\nsock_put(sk);\r\nbreak;\r\ncase LLC_RESET_PRIM:\r\nprintk(KERN_INFO "%s: received a reset conf!\n", __func__);\r\nbreak;\r\ndefault:\r\nif (ev->cfm_prim) {\r\nprintk(KERN_INFO "%s: received unknown %d prim!\n",\r\n__func__, ev->cfm_prim);\r\nbreak;\r\n}\r\ngoto out_skb_put;\r\n}\r\nout_kfree_skb:\r\nkfree_skb(skb);\r\nout_skb_put:\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nvoid llc_conn_send_pdu(struct sock *sk, struct sk_buff *skb)\r\n{\r\nskb_queue_tail(&sk->sk_write_queue, skb);\r\nllc_conn_send_pdus(sk);\r\n}\r\nvoid llc_conn_rtn_pdu(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\r\nev->ind_prim = LLC_DATA_PRIM;\r\n}\r\nvoid llc_conn_resend_i_pdu_as_cmd(struct sock *sk, u8 nr, u8 first_p_bit)\r\n{\r\nstruct sk_buff *skb;\r\nstruct llc_pdu_sn *pdu;\r\nu16 nbr_unack_pdus;\r\nstruct llc_sock *llc;\r\nu8 howmany_resend = 0;\r\nllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\r\nif (!nbr_unack_pdus)\r\ngoto out;\r\nllc = llc_sk(sk);\r\nwhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\r\npdu = llc_pdu_sn_hdr(skb);\r\nllc_pdu_set_cmd_rsp(skb, LLC_PDU_CMD);\r\nllc_pdu_set_pf_bit(skb, first_p_bit);\r\nskb_queue_tail(&sk->sk_write_queue, skb);\r\nfirst_p_bit = 0;\r\nllc->vS = LLC_I_GET_NS(pdu);\r\nhowmany_resend++;\r\n}\r\nif (howmany_resend > 0)\r\nllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\r\nllc_conn_send_pdus(sk);\r\nout:;\r\n}\r\nvoid llc_conn_resend_i_pdu_as_rsp(struct sock *sk, u8 nr, u8 first_f_bit)\r\n{\r\nstruct sk_buff *skb;\r\nu16 nbr_unack_pdus;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nu8 howmany_resend = 0;\r\nllc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);\r\nif (!nbr_unack_pdus)\r\ngoto out;\r\nwhile ((skb = skb_dequeue(&llc->pdu_unack_q)) != NULL) {\r\nstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\r\nllc_pdu_set_cmd_rsp(skb, LLC_PDU_RSP);\r\nllc_pdu_set_pf_bit(skb, first_f_bit);\r\nskb_queue_tail(&sk->sk_write_queue, skb);\r\nfirst_f_bit = 0;\r\nllc->vS = LLC_I_GET_NS(pdu);\r\nhowmany_resend++;\r\n}\r\nif (howmany_resend > 0)\r\nllc->vS = (llc->vS + 1) % LLC_2_SEQ_NBR_MODULO;\r\nllc_conn_send_pdus(sk);\r\nout:;\r\n}\r\nint llc_conn_remove_acked_pdus(struct sock *sk, u8 nr, u16 *how_many_unacked)\r\n{\r\nint pdu_pos, i;\r\nstruct sk_buff *skb;\r\nstruct llc_pdu_sn *pdu;\r\nint nbr_acked = 0;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nint q_len = skb_queue_len(&llc->pdu_unack_q);\r\nif (!q_len)\r\ngoto out;\r\nskb = skb_peek(&llc->pdu_unack_q);\r\npdu = llc_pdu_sn_hdr(skb);\r\npdu_pos = ((int)LLC_2_SEQ_NBR_MODULO + (int)nr -\r\n(int)LLC_I_GET_NS(pdu)) % LLC_2_SEQ_NBR_MODULO;\r\nfor (i = 0; i < pdu_pos && i < q_len; i++) {\r\nskb = skb_dequeue(&llc->pdu_unack_q);\r\nkfree_skb(skb);\r\nnbr_acked++;\r\n}\r\nout:\r\n*how_many_unacked = skb_queue_len(&llc->pdu_unack_q);\r\nreturn nbr_acked;\r\n}\r\nstatic void llc_conn_send_pdus(struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&sk->sk_write_queue)) != NULL) {\r\nstruct llc_pdu_sn *pdu = llc_pdu_sn_hdr(skb);\r\nif (LLC_PDU_TYPE_IS_I(pdu) &&\r\n!(skb->dev->flags & IFF_LOOPBACK)) {\r\nstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\r\nskb_queue_tail(&llc_sk(sk)->pdu_unack_q, skb);\r\nif (!skb2)\r\nbreak;\r\nskb = skb2;\r\n}\r\ndev_queue_xmit(skb);\r\n}\r\n}\r\nstatic int llc_conn_service(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint rc = 1;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct llc_conn_state_trans *trans;\r\nif (llc->state > NBR_CONN_STATES)\r\ngoto out;\r\nrc = 0;\r\ntrans = llc_qualify_conn_ev(sk, skb);\r\nif (trans) {\r\nrc = llc_exec_conn_trans_actions(sk, trans, skb);\r\nif (!rc && trans->next_state != NO_STATE_CHANGE) {\r\nllc->state = trans->next_state;\r\nif (!llc_data_accept_state(llc->state))\r\nsk->sk_state_change(sk);\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic struct llc_conn_state_trans *llc_qualify_conn_ev(struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nstruct llc_conn_state_trans **next_trans;\r\nllc_conn_ev_qfyr_t *next_qualifier;\r\nstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct llc_conn_state *curr_state =\r\n&llc_conn_state_table[llc->state - 1];\r\nfor (next_trans = curr_state->transitions +\r\nllc_find_offset(llc->state - 1, ev->type);\r\n(*next_trans)->ev; next_trans++) {\r\nif (!((*next_trans)->ev)(sk, skb)) {\r\nfor (next_qualifier = (*next_trans)->ev_qualifiers;\r\nnext_qualifier && *next_qualifier &&\r\n!(*next_qualifier)(sk, skb); next_qualifier++)\r\n;\r\nif (!next_qualifier || !*next_qualifier)\r\nreturn *next_trans;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int llc_exec_conn_trans_actions(struct sock *sk,\r\nstruct llc_conn_state_trans *trans,\r\nstruct sk_buff *skb)\r\n{\r\nint rc = 0;\r\nllc_conn_action_t *next_action;\r\nfor (next_action = trans->ev_actions;\r\nnext_action && *next_action; next_action++) {\r\nint rc2 = (*next_action)(sk, skb);\r\nif (rc2 == 2) {\r\nrc = rc2;\r\nbreak;\r\n} else if (rc2)\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline bool llc_estab_match(const struct llc_sap *sap,\r\nconst struct llc_addr *daddr,\r\nconst struct llc_addr *laddr,\r\nconst struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nreturn llc->laddr.lsap == laddr->lsap &&\r\nllc->daddr.lsap == daddr->lsap &&\r\nllc_mac_match(llc->laddr.mac, laddr->mac) &&\r\nllc_mac_match(llc->daddr.mac, daddr->mac);\r\n}\r\nstatic struct sock *__llc_lookup_established(struct llc_sap *sap,\r\nstruct llc_addr *daddr,\r\nstruct llc_addr *laddr)\r\n{\r\nstruct sock *rc;\r\nstruct hlist_nulls_node *node;\r\nint slot = llc_sk_laddr_hashfn(sap, laddr);\r\nstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\r\nrcu_read_lock();\r\nagain:\r\nsk_nulls_for_each_rcu(rc, node, laddr_hb) {\r\nif (llc_estab_match(sap, daddr, laddr, rc)) {\r\nif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\r\ngoto again;\r\nif (unlikely(llc_sk(rc)->sap != sap ||\r\n!llc_estab_match(sap, daddr, laddr, rc))) {\r\nsock_put(rc);\r\ncontinue;\r\n}\r\ngoto found;\r\n}\r\n}\r\nrc = NULL;\r\nif (unlikely(get_nulls_value(node) != slot))\r\ngoto again;\r\nfound:\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nstruct sock *llc_lookup_established(struct llc_sap *sap,\r\nstruct llc_addr *daddr,\r\nstruct llc_addr *laddr)\r\n{\r\nstruct sock *sk;\r\nlocal_bh_disable();\r\nsk = __llc_lookup_established(sap, daddr, laddr);\r\nlocal_bh_enable();\r\nreturn sk;\r\n}\r\nstatic inline bool llc_listener_match(const struct llc_sap *sap,\r\nconst struct llc_addr *laddr,\r\nconst struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nreturn sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN &&\r\nllc->laddr.lsap == laddr->lsap &&\r\nllc_mac_match(llc->laddr.mac, laddr->mac);\r\n}\r\nstatic struct sock *__llc_lookup_listener(struct llc_sap *sap,\r\nstruct llc_addr *laddr)\r\n{\r\nstruct sock *rc;\r\nstruct hlist_nulls_node *node;\r\nint slot = llc_sk_laddr_hashfn(sap, laddr);\r\nstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\r\nrcu_read_lock();\r\nagain:\r\nsk_nulls_for_each_rcu(rc, node, laddr_hb) {\r\nif (llc_listener_match(sap, laddr, rc)) {\r\nif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\r\ngoto again;\r\nif (unlikely(llc_sk(rc)->sap != sap ||\r\n!llc_listener_match(sap, laddr, rc))) {\r\nsock_put(rc);\r\ncontinue;\r\n}\r\ngoto found;\r\n}\r\n}\r\nrc = NULL;\r\nif (unlikely(get_nulls_value(node) != slot))\r\ngoto again;\r\nfound:\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nstatic struct sock *llc_lookup_listener(struct llc_sap *sap,\r\nstruct llc_addr *laddr)\r\n{\r\nstatic struct llc_addr null_addr;\r\nstruct sock *rc = __llc_lookup_listener(sap, laddr);\r\nif (!rc)\r\nrc = __llc_lookup_listener(sap, &null_addr);\r\nreturn rc;\r\n}\r\nstatic struct sock *__llc_lookup(struct llc_sap *sap,\r\nstruct llc_addr *daddr,\r\nstruct llc_addr *laddr)\r\n{\r\nstruct sock *sk = __llc_lookup_established(sap, daddr, laddr);\r\nreturn sk ? : llc_lookup_listener(sap, laddr);\r\n}\r\nu8 llc_data_accept_state(u8 state)\r\n{\r\nreturn state != LLC_CONN_STATE_NORMAL && state != LLC_CONN_STATE_BUSY &&\r\nstate != LLC_CONN_STATE_REJ;\r\n}\r\nstatic u16 __init llc_find_next_offset(struct llc_conn_state *state, u16 offset)\r\n{\r\nu16 cnt = 0;\r\nstruct llc_conn_state_trans **next_trans;\r\nfor (next_trans = state->transitions + offset;\r\n(*next_trans)->ev; next_trans++)\r\n++cnt;\r\nreturn cnt;\r\n}\r\nvoid __init llc_build_offset_table(void)\r\n{\r\nstruct llc_conn_state *curr_state;\r\nint state, ev_type, next_offset;\r\nfor (state = 0; state < NBR_CONN_STATES; state++) {\r\ncurr_state = &llc_conn_state_table[state];\r\nnext_offset = 0;\r\nfor (ev_type = 0; ev_type < NBR_CONN_EV; ev_type++) {\r\nllc_offset_table[state][ev_type] = next_offset;\r\nnext_offset += llc_find_next_offset(curr_state,\r\nnext_offset) + 1;\r\n}\r\n}\r\n}\r\nstatic int llc_find_offset(int state, int ev_type)\r\n{\r\nint rc = 0;\r\nswitch (ev_type) {\r\ncase LLC_CONN_EV_TYPE_PRIM:\r\nrc = llc_offset_table[state][0]; break;\r\ncase LLC_CONN_EV_TYPE_PDU:\r\nrc = llc_offset_table[state][4]; break;\r\ncase LLC_CONN_EV_TYPE_SIMPLE:\r\nrc = llc_offset_table[state][1]; break;\r\ncase LLC_CONN_EV_TYPE_P_TMR:\r\ncase LLC_CONN_EV_TYPE_ACK_TMR:\r\ncase LLC_CONN_EV_TYPE_REJ_TMR:\r\ncase LLC_CONN_EV_TYPE_BUSY_TMR:\r\nrc = llc_offset_table[state][3]; break;\r\n}\r\nreturn rc;\r\n}\r\nvoid llc_sap_add_socket(struct llc_sap *sap, struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, llc->dev->ifindex);\r\nstruct hlist_nulls_head *laddr_hb = llc_sk_laddr_hash(sap, &llc->laddr);\r\nllc_sap_hold(sap);\r\nllc_sk(sk)->sap = sap;\r\nspin_lock_bh(&sap->sk_lock);\r\nsap->sk_count++;\r\nsk_nulls_add_node_rcu(sk, laddr_hb);\r\nhlist_add_head(&llc->dev_hash_node, dev_hb);\r\nspin_unlock_bh(&sap->sk_lock);\r\n}\r\nvoid llc_sap_remove_socket(struct llc_sap *sap, struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nspin_lock_bh(&sap->sk_lock);\r\nsk_nulls_del_node_init_rcu(sk);\r\nhlist_del(&llc->dev_hash_node);\r\nsap->sk_count--;\r\nspin_unlock_bh(&sap->sk_lock);\r\nllc_sap_put(sap);\r\n}\r\nstatic int llc_conn_rcv(struct sock* sk, struct sk_buff *skb)\r\n{\r\nstruct llc_conn_state_ev *ev = llc_conn_ev(skb);\r\nev->type = LLC_CONN_EV_TYPE_PDU;\r\nev->reason = 0;\r\nreturn llc_conn_state_process(sk, skb);\r\n}\r\nstatic struct sock *llc_create_incoming_sock(struct sock *sk,\r\nstruct net_device *dev,\r\nstruct llc_addr *saddr,\r\nstruct llc_addr *daddr)\r\n{\r\nstruct sock *newsk = llc_sk_alloc(sock_net(sk), sk->sk_family, GFP_ATOMIC,\r\nsk->sk_prot);\r\nstruct llc_sock *newllc, *llc = llc_sk(sk);\r\nif (!newsk)\r\ngoto out;\r\nnewllc = llc_sk(newsk);\r\nmemcpy(&newllc->laddr, daddr, sizeof(newllc->laddr));\r\nmemcpy(&newllc->daddr, saddr, sizeof(newllc->daddr));\r\nnewllc->dev = dev;\r\ndev_hold(dev);\r\nllc_sap_add_socket(llc->sap, newsk);\r\nllc_sap_hold(llc->sap);\r\nout:\r\nreturn newsk;\r\n}\r\nvoid llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\r\n{\r\nstruct llc_addr saddr, daddr;\r\nstruct sock *sk;\r\nllc_pdu_decode_sa(skb, saddr.mac);\r\nllc_pdu_decode_ssap(skb, &saddr.lsap);\r\nllc_pdu_decode_da(skb, daddr.mac);\r\nllc_pdu_decode_dsap(skb, &daddr.lsap);\r\nsk = __llc_lookup(sap, &saddr, &daddr);\r\nif (!sk)\r\ngoto drop;\r\nbh_lock_sock(sk);\r\nif (unlikely(sk->sk_state == TCP_LISTEN)) {\r\nstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\r\n&saddr, &daddr);\r\nif (!newsk)\r\ngoto drop_unlock;\r\nskb_set_owner_r(skb, newsk);\r\n} else {\r\nskb->sk = sk;\r\n}\r\nif (!sock_owned_by_user(sk))\r\nllc_conn_rcv(sk, skb);\r\nelse {\r\ndprintk("%s: adding to backlog...\n", __func__);\r\nllc_set_backlog_type(skb, LLC_PACKET);\r\nif (sk_add_backlog(sk, skb))\r\ngoto drop_unlock;\r\n}\r\nout:\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\nreturn;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn;\r\ndrop_unlock:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int llc_backlog_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint rc = 0;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nif (likely(llc_backlog_type(skb) == LLC_PACKET)) {\r\nif (likely(llc->state > 1))\r\nrc = llc_conn_rcv(sk, skb);\r\nelse\r\ngoto out_kfree_skb;\r\n} else if (llc_backlog_type(skb) == LLC_EVENT) {\r\nif (likely(llc->state > 1))\r\nrc = llc_conn_state_process(sk, skb);\r\nelse\r\ngoto out_kfree_skb;\r\n} else {\r\nprintk(KERN_ERR "%s: invalid skb in backlog\n", __func__);\r\ngoto out_kfree_skb;\r\n}\r\nout:\r\nreturn rc;\r\nout_kfree_skb:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic void llc_sk_init(struct sock* sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nllc->state = LLC_CONN_STATE_ADM;\r\nllc->inc_cntr = llc->dec_cntr = 2;\r\nllc->dec_step = llc->connect_step = 1;\r\nsetup_timer(&llc->ack_timer.timer, llc_conn_ack_tmr_cb,\r\n(unsigned long)sk);\r\nllc->ack_timer.expire = sysctl_llc2_ack_timeout;\r\nsetup_timer(&llc->pf_cycle_timer.timer, llc_conn_pf_cycle_tmr_cb,\r\n(unsigned long)sk);\r\nllc->pf_cycle_timer.expire = sysctl_llc2_p_timeout;\r\nsetup_timer(&llc->rej_sent_timer.timer, llc_conn_rej_tmr_cb,\r\n(unsigned long)sk);\r\nllc->rej_sent_timer.expire = sysctl_llc2_rej_timeout;\r\nsetup_timer(&llc->busy_state_timer.timer, llc_conn_busy_tmr_cb,\r\n(unsigned long)sk);\r\nllc->busy_state_timer.expire = sysctl_llc2_busy_timeout;\r\nllc->n2 = 2;\r\nllc->k = 2;\r\nllc->rw = 128;\r\nskb_queue_head_init(&llc->pdu_unack_q);\r\nsk->sk_backlog_rcv = llc_backlog_rcv;\r\n}\r\nstruct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot)\r\n{\r\nstruct sock *sk = sk_alloc(net, family, priority, prot);\r\nif (!sk)\r\ngoto out;\r\nllc_sk_init(sk);\r\nsock_init_data(NULL, sk);\r\n#ifdef LLC_REFCNT_DEBUG\r\natomic_inc(&llc_sock_nr);\r\nprintk(KERN_DEBUG "LLC socket %p created in %s, now we have %d alive\n", sk,\r\n__func__, atomic_read(&llc_sock_nr));\r\n#endif\r\nout:\r\nreturn sk;\r\n}\r\nvoid llc_sk_free(struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nllc->state = LLC_CONN_OUT_OF_SVC;\r\nllc_conn_ac_stop_all_timers(sk, NULL);\r\n#ifdef DEBUG_LLC_CONN_ALLOC\r\nprintk(KERN_INFO "%s: unackq=%d, txq=%d\n", __func__,\r\nskb_queue_len(&llc->pdu_unack_q),\r\nskb_queue_len(&sk->sk_write_queue));\r\n#endif\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nskb_queue_purge(&sk->sk_write_queue);\r\nskb_queue_purge(&llc->pdu_unack_q);\r\n#ifdef LLC_REFCNT_DEBUG\r\nif (atomic_read(&sk->sk_refcnt) != 1) {\r\nprintk(KERN_DEBUG "Destruction of LLC sock %p delayed in %s, cnt=%d\n",\r\nsk, __func__, atomic_read(&sk->sk_refcnt));\r\nprintk(KERN_DEBUG "%d LLC sockets are still alive\n",\r\natomic_read(&llc_sock_nr));\r\n} else {\r\natomic_dec(&llc_sock_nr);\r\nprintk(KERN_DEBUG "LLC socket %p released in %s, %d are still alive\n", sk,\r\n__func__, atomic_read(&llc_sock_nr));\r\n}\r\n#endif\r\nsock_put(sk);\r\n}\r\nvoid llc_sk_reset(struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nllc_conn_ac_stop_all_timers(sk, NULL);\r\nskb_queue_purge(&sk->sk_write_queue);\r\nskb_queue_purge(&llc->pdu_unack_q);\r\nllc->remote_busy_flag = 0;\r\nllc->cause_flag = 0;\r\nllc->retry_count = 0;\r\nllc_conn_set_p_flag(sk, 0);\r\nllc->f_flag = 0;\r\nllc->s_flag = 0;\r\nllc->ack_pf = 0;\r\nllc->first_pdu_Ns = 0;\r\nllc->ack_must_be_send = 0;\r\nllc->dec_step = 1;\r\nllc->inc_cntr = 2;\r\nllc->dec_cntr = 2;\r\nllc->X = 0;\r\nllc->failed_data_req = 0 ;\r\nllc->last_nr = 0;\r\n}
