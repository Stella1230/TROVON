static int\r\nfreecom_readdata (struct scsi_cmnd *srb, struct us_data *us,\r\nunsigned int ipipe, unsigned int opipe, int count)\r\n{\r\nstruct freecom_xfer_wrap *fxfr =\r\n(struct freecom_xfer_wrap *) us->iobuf;\r\nint result;\r\nfxfr->Type = FCM_PACKET_INPUT | 0x00;\r\nfxfr->Timeout = 0;\r\nfxfr->Count = cpu_to_le32 (count);\r\nmemset (fxfr->Pad, 0, sizeof (fxfr->Pad));\r\nUS_DEBUGP("Read data Freecom! (c=%d)\n", count);\r\nresult = usb_stor_bulk_transfer_buf (us, opipe, fxfr,\r\nFCM_PACKET_LENGTH, NULL);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nUS_DEBUGP ("Freecom readdata transport error\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nUS_DEBUGP("Start of read\n");\r\nresult = usb_stor_bulk_srb(us, ipipe, srb);\r\nUS_DEBUGP("freecom_readdata done!\n");\r\nif (result > USB_STOR_XFER_SHORT)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int\r\nfreecom_writedata (struct scsi_cmnd *srb, struct us_data *us,\r\nint unsigned ipipe, unsigned int opipe, int count)\r\n{\r\nstruct freecom_xfer_wrap *fxfr =\r\n(struct freecom_xfer_wrap *) us->iobuf;\r\nint result;\r\nfxfr->Type = FCM_PACKET_OUTPUT | 0x00;\r\nfxfr->Timeout = 0;\r\nfxfr->Count = cpu_to_le32 (count);\r\nmemset (fxfr->Pad, 0, sizeof (fxfr->Pad));\r\nUS_DEBUGP("Write data Freecom! (c=%d)\n", count);\r\nresult = usb_stor_bulk_transfer_buf (us, opipe, fxfr,\r\nFCM_PACKET_LENGTH, NULL);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nUS_DEBUGP ("Freecom writedata transport error\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nUS_DEBUGP("Start of write\n");\r\nresult = usb_stor_bulk_srb(us, opipe, srb);\r\nUS_DEBUGP("freecom_writedata done!\n");\r\nif (result > USB_STOR_XFER_SHORT)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int freecom_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nstruct freecom_cb_wrap *fcb;\r\nstruct freecom_status *fst;\r\nunsigned int ipipe, opipe;\r\nint result;\r\nunsigned int partial;\r\nint length;\r\nfcb = (struct freecom_cb_wrap *) us->iobuf;\r\nfst = (struct freecom_status *) us->iobuf;\r\nUS_DEBUGP("Freecom TRANSPORT STARTED\n");\r\nopipe = us->send_bulk_pipe;\r\nipipe = us->recv_bulk_pipe;\r\nfcb->Type = FCM_PACKET_ATAPI | 0x00;\r\nfcb->Timeout = 0;\r\nmemcpy (fcb->Atapi, srb->cmnd, 12);\r\nmemset (fcb->Filler, 0, sizeof (fcb->Filler));\r\nUS_DEBUG(pdump (srb->cmnd, 12));\r\nresult = usb_stor_bulk_transfer_buf (us, opipe, fcb,\r\nFCM_PACKET_LENGTH, NULL);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nUS_DEBUGP ("freecom transport error\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\r\nFCM_STATUS_PACKET_LENGTH, &partial);\r\nUS_DEBUGP("foo Status result %d %u\n", result, partial);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nUS_DEBUG(pdump ((void *) fst, partial));\r\nwhile (fst->Status & FCM_STATUS_BUSY) {\r\nUS_DEBUGP("20 second USB/ATAPI bridge TIMEOUT occurred!\n");\r\nUS_DEBUGP("fst->Status is %x\n", fst->Status);\r\nfcb->Type = FCM_PACKET_STATUS;\r\nfcb->Timeout = 0;\r\nmemset (fcb->Atapi, 0, sizeof(fcb->Atapi));\r\nmemset (fcb->Filler, 0, sizeof (fcb->Filler));\r\nresult = usb_stor_bulk_transfer_buf (us, opipe, fcb,\r\nFCM_PACKET_LENGTH, NULL);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nUS_DEBUGP ("freecom transport error\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\r\nFCM_STATUS_PACKET_LENGTH, &partial);\r\nUS_DEBUGP("bar Status result %d %u\n", result, partial);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nUS_DEBUG(pdump ((void *) fst, partial));\r\n}\r\nif (partial != 4)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif ((fst->Status & 1) != 0) {\r\nUS_DEBUGP("operation failed\n");\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nUS_DEBUGP("Device indicates that it has %d bytes available\n",\r\nle16_to_cpu (fst->Count));\r\nUS_DEBUGP("SCSI requested %d\n", scsi_bufflen(srb));\r\nswitch (srb->cmnd[0]) {\r\ncase INQUIRY:\r\ncase REQUEST_SENSE:\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\nlength = le16_to_cpu(fst->Count);\r\nbreak;\r\ndefault:\r\nlength = scsi_bufflen(srb);\r\n}\r\nif (length > scsi_bufflen(srb)) {\r\nlength = scsi_bufflen(srb);\r\nUS_DEBUGP("Truncating request to match buffer length: %d\n", length);\r\n}\r\nswitch (us->srb->sc_data_direction) {\r\ncase DMA_FROM_DEVICE:\r\nif (!length)\r\nbreak;\r\nif ((fst->Status & DRQ_STAT) == 0 || (fst->Reason & 3) != 2) {\r\nUS_DEBUGP("SCSI wants data, drive doesn't have any\n");\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nresult = freecom_readdata (srb, us, ipipe, opipe, length);\r\nif (result != USB_STOR_TRANSPORT_GOOD)\r\nreturn result;\r\nUS_DEBUGP("FCM: Waiting for status\n");\r\nresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\r\nFCM_PACKET_LENGTH, &partial);\r\nUS_DEBUG(pdump ((void *) fst, partial));\r\nif (partial != 4 || result > USB_STOR_XFER_SHORT)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif ((fst->Status & ERR_STAT) != 0) {\r\nUS_DEBUGP("operation failed\n");\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif ((fst->Reason & 3) != 3) {\r\nUS_DEBUGP("Drive seems still hungry\n");\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nUS_DEBUGP("Transfer happy\n");\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nif (!length)\r\nbreak;\r\nresult = freecom_writedata (srb, us, ipipe, opipe, length);\r\nif (result != USB_STOR_TRANSPORT_GOOD)\r\nreturn result;\r\nUS_DEBUGP("FCM: Waiting for status\n");\r\nresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\r\nFCM_PACKET_LENGTH, &partial);\r\nif (partial != 4 || result > USB_STOR_XFER_SHORT)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif ((fst->Status & ERR_STAT) != 0) {\r\nUS_DEBUGP("operation failed\n");\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif ((fst->Reason & 3) != 3) {\r\nUS_DEBUGP("Drive seems still hungry\n");\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nUS_DEBUGP("Transfer happy\n");\r\nbreak;\r\ncase DMA_NONE:\r\nbreak;\r\ndefault:\r\nUS_DEBUGP ("freecom unimplemented direction: %d\n",\r\nus->srb->sc_data_direction);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\nbreak;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int init_freecom(struct us_data *us)\r\n{\r\nint result;\r\nchar *buffer = us->iobuf;\r\nresult = usb_stor_control_msg(us, us->recv_ctrl_pipe,\r\n0x4c, 0xc0, 0x4346, 0x0, buffer, 0x20, 3*HZ);\r\nbuffer[32] = '\0';\r\nUS_DEBUGP("String returned from FC init is: %s\n", buffer);\r\nresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\r\n0x4d, 0x40, 0x24d8, 0x0, NULL, 0x0, 3*HZ);\r\nUS_DEBUGP("result from activate reset is %d\n", result);\r\nmdelay(250);\r\nresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\r\n0x4d, 0x40, 0x24f8, 0x0, NULL, 0x0, 3*HZ);\r\nUS_DEBUGP("result from clear reset is %d\n", result);\r\nmdelay(3 * 1000);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int usb_stor_freecom_reset(struct us_data *us)\r\n{\r\nprintk (KERN_CRIT "freecom reset called\n");\r\nreturn FAILED;\r\n}\r\nstatic void pdump (void *ibuffer, int length)\r\n{\r\nstatic char line[80];\r\nint offset = 0;\r\nunsigned char *buffer = (unsigned char *) ibuffer;\r\nint i, j;\r\nint from, base;\r\noffset = 0;\r\nfor (i = 0; i < length; i++) {\r\nif ((i & 15) == 0) {\r\nif (i > 0) {\r\noffset += sprintf (line+offset, " - ");\r\nfor (j = i - 16; j < i; j++) {\r\nif (buffer[j] >= 32 && buffer[j] <= 126)\r\nline[offset++] = buffer[j];\r\nelse\r\nline[offset++] = '.';\r\n}\r\nline[offset] = 0;\r\nUS_DEBUGP("%s\n", line);\r\noffset = 0;\r\n}\r\noffset += sprintf (line+offset, "%08x:", i);\r\n} else if ((i & 7) == 0) {\r\noffset += sprintf (line+offset, " -");\r\n}\r\noffset += sprintf (line+offset, " %02x", buffer[i] & 0xff);\r\n}\r\nfrom = (length - 1) % 16;\r\nbase = ((length - 1) / 16) * 16;\r\nfor (i = from + 1; i < 16; i++)\r\noffset += sprintf (line+offset, " ");\r\nif (from < 8)\r\noffset += sprintf (line+offset, " ");\r\noffset += sprintf (line+offset, " - ");\r\nfor (i = 0; i <= from; i++) {\r\nif (buffer[base+i] >= 32 && buffer[base+i] <= 126)\r\nline[offset++] = buffer[base+i];\r\nelse\r\nline[offset++] = '.';\r\n}\r\nline[offset] = 0;\r\nUS_DEBUGP("%s\n", line);\r\noffset = 0;\r\n}\r\nstatic int freecom_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - freecom_usb_ids) + freecom_unusual_dev_list);\r\nif (result)\r\nreturn result;\r\nus->transport_name = "Freecom";\r\nus->transport = freecom_transport;\r\nus->transport_reset = usb_stor_freecom_reset;\r\nus->max_lun = 0;\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}\r\nstatic int __init freecom_init(void)\r\n{\r\nreturn usb_register(&freecom_driver);\r\n}\r\nstatic void __exit freecom_exit(void)\r\n{\r\nusb_deregister(&freecom_driver);\r\n}
