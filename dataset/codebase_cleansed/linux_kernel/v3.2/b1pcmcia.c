static void b1pcmcia_remove_ctr(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nb1_reset(port);\r\nb1_reset(port);\r\ndetach_capi_ctr(ctrl);\r\nfree_irq(card->irq, card);\r\nb1_free_card(card);\r\n}\r\nstatic int b1pcmcia_add_card(unsigned int port, unsigned irq,\r\nenum avmcardtype cardtype)\r\n{\r\navmctrl_info *cinfo;\r\navmcard *card;\r\nchar *cardname;\r\nint retval;\r\ncard = b1_alloc_card(1);\r\nif (!card) {\r\nprintk(KERN_WARNING "b1pcmcia: no memory.\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\ncinfo = card->ctrlinfo;\r\nswitch (cardtype) {\r\ncase avm_m1: sprintf(card->name, "m1-%x", port); break;\r\ncase avm_m2: sprintf(card->name, "m2-%x", port); break;\r\ndefault: sprintf(card->name, "b1pcmcia-%x", port); break;\r\n}\r\ncard->port = port;\r\ncard->irq = irq;\r\ncard->cardtype = cardtype;\r\nretval = request_irq(card->irq, b1_interrupt, IRQF_SHARED, card->name, card);\r\nif (retval) {\r\nprintk(KERN_ERR "b1pcmcia: unable to get IRQ %d.\n",\r\ncard->irq);\r\nretval = -EBUSY;\r\ngoto err_free;\r\n}\r\nb1_reset(card->port);\r\nif ((retval = b1_detect(card->port, card->cardtype)) != 0) {\r\nprintk(KERN_NOTICE "b1pcmcia: NO card at 0x%x (%d)\n",\r\ncard->port, retval);\r\nretval = -ENODEV;\r\ngoto err_free_irq;\r\n}\r\nb1_reset(card->port);\r\nb1_getrevision(card);\r\ncinfo->capi_ctrl.owner = THIS_MODULE;\r\ncinfo->capi_ctrl.driver_name = "b1pcmcia";\r\ncinfo->capi_ctrl.driverdata = cinfo;\r\ncinfo->capi_ctrl.register_appl = b1_register_appl;\r\ncinfo->capi_ctrl.release_appl = b1_release_appl;\r\ncinfo->capi_ctrl.send_message = b1_send_message;\r\ncinfo->capi_ctrl.load_firmware = b1_load_firmware;\r\ncinfo->capi_ctrl.reset_ctr = b1_reset_ctr;\r\ncinfo->capi_ctrl.procinfo = b1pcmcia_procinfo;\r\ncinfo->capi_ctrl.proc_fops = &b1ctl_proc_fops;\r\nstrcpy(cinfo->capi_ctrl.name, card->name);\r\nretval = attach_capi_ctr(&cinfo->capi_ctrl);\r\nif (retval) {\r\nprintk(KERN_ERR "b1pcmcia: attach controller failed.\n");\r\ngoto err_free_irq;\r\n}\r\nswitch (cardtype) {\r\ncase avm_m1: cardname = "M1"; break;\r\ncase avm_m2: cardname = "M2"; break;\r\ndefault : cardname = "B1 PCMCIA"; break;\r\n}\r\nprintk(KERN_INFO "b1pcmcia: AVM %s at i/o %#x, irq %d, revision %d\n",\r\ncardname, card->port, card->irq, card->revision);\r\nlist_add(&card->list, &cards);\r\nreturn cinfo->capi_ctrl.cnr;\r\nerr_free_irq:\r\nfree_irq(card->irq, card);\r\nerr_free:\r\nb1_free_card(card);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic char *b1pcmcia_procinfo(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\nif (!cinfo)\r\nreturn "";\r\nsprintf(cinfo->infobuf, "%s %s 0x%x %d r%d",\r\ncinfo->cardname[0] ? cinfo->cardname : "-",\r\ncinfo->version[VER_DRIVER] ? cinfo->version[VER_DRIVER] : "-",\r\ncinfo->card ? cinfo->card->port : 0x0,\r\ncinfo->card ? cinfo->card->irq : 0,\r\ncinfo->card ? cinfo->card->revision : 0\r\n);\r\nreturn cinfo->infobuf;\r\n}\r\nint b1pcmcia_addcard_b1(unsigned int port, unsigned irq)\r\n{\r\nreturn b1pcmcia_add_card(port, irq, avm_b1pcmcia);\r\n}\r\nint b1pcmcia_addcard_m1(unsigned int port, unsigned irq)\r\n{\r\nreturn b1pcmcia_add_card(port, irq, avm_m1);\r\n}\r\nint b1pcmcia_addcard_m2(unsigned int port, unsigned irq)\r\n{\r\nreturn b1pcmcia_add_card(port, irq, avm_m2);\r\n}\r\nint b1pcmcia_delcard(unsigned int port, unsigned irq)\r\n{\r\nstruct list_head *l;\r\navmcard *card;\r\nlist_for_each(l, &cards) {\r\ncard = list_entry(l, avmcard, list);\r\nif (card->port == port && card->irq == irq) {\r\nb1pcmcia_remove_ctr(&card->ctrlinfo[0].capi_ctrl);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ESRCH;\r\n}\r\nstatic int __init b1pcmcia_init(void)\r\n{\r\nchar *p;\r\nchar rev[32];\r\nif ((p = strchr(revision, ':')) != NULL && p[1]) {\r\nstrlcpy(rev, p + 2, 32);\r\nif ((p = strchr(rev, '$')) != NULL && p > rev)\r\n*(p-1) = 0;\r\n} else\r\nstrcpy(rev, "1.0");\r\nstrlcpy(capi_driver_b1pcmcia.revision, rev, 32);\r\nregister_capi_driver(&capi_driver_b1pcmcia);\r\nprintk(KERN_INFO "b1pci: revision %s\n", rev);\r\nreturn 0;\r\n}\r\nstatic void __exit b1pcmcia_exit(void)\r\n{\r\nunregister_capi_driver(&capi_driver_b1pcmcia);\r\n}
