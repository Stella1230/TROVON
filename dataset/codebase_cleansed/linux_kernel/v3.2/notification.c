u32 fsnotify_get_cookie(void)\r\n{\r\nreturn atomic_inc_return(&fsnotify_sync_cookie);\r\n}\r\nbool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\r\n{\r\nBUG_ON(!mutex_is_locked(&group->notification_mutex));\r\nreturn list_empty(&group->notification_list) ? true : false;\r\n}\r\nvoid fsnotify_get_event(struct fsnotify_event *event)\r\n{\r\natomic_inc(&event->refcnt);\r\n}\r\nvoid fsnotify_put_event(struct fsnotify_event *event)\r\n{\r\nif (!event)\r\nreturn;\r\nif (atomic_dec_and_test(&event->refcnt)) {\r\npr_debug("%s: event=%p\n", __func__, event);\r\nif (event->data_type == FSNOTIFY_EVENT_PATH)\r\npath_put(&event->path);\r\nBUG_ON(!list_empty(&event->private_data_list));\r\nkfree(event->file_name);\r\nput_pid(event->tgid);\r\nkmem_cache_free(fsnotify_event_cachep, event);\r\n}\r\n}\r\nstruct fsnotify_event_holder *fsnotify_alloc_event_holder(void)\r\n{\r\nreturn kmem_cache_alloc(fsnotify_event_holder_cachep, GFP_KERNEL);\r\n}\r\nvoid fsnotify_destroy_event_holder(struct fsnotify_event_holder *holder)\r\n{\r\nif (holder)\r\nkmem_cache_free(fsnotify_event_holder_cachep, holder);\r\n}\r\nstruct fsnotify_event_private_data *fsnotify_remove_priv_from_event(struct fsnotify_group *group, struct fsnotify_event *event)\r\n{\r\nstruct fsnotify_event_private_data *lpriv;\r\nstruct fsnotify_event_private_data *priv = NULL;\r\nassert_spin_locked(&event->lock);\r\nlist_for_each_entry(lpriv, &event->private_data_list, event_list) {\r\nif (lpriv->group == group) {\r\npriv = lpriv;\r\nlist_del(&priv->event_list);\r\nbreak;\r\n}\r\n}\r\nreturn priv;\r\n}\r\nstruct fsnotify_event *fsnotify_remove_notify_event(struct fsnotify_group *group)\r\n{\r\nstruct fsnotify_event *event;\r\nstruct fsnotify_event_holder *holder;\r\nBUG_ON(!mutex_is_locked(&group->notification_mutex));\r\npr_debug("%s: group=%p\n", __func__, group);\r\nholder = list_first_entry(&group->notification_list, struct fsnotify_event_holder, event_list);\r\nevent = holder->event;\r\nspin_lock(&event->lock);\r\nholder->event = NULL;\r\nlist_del_init(&holder->event_list);\r\nspin_unlock(&event->lock);\r\nif (holder != &event->holder)\r\nfsnotify_destroy_event_holder(holder);\r\ngroup->q_len--;\r\nreturn event;\r\n}\r\nstruct fsnotify_event *fsnotify_peek_notify_event(struct fsnotify_group *group)\r\n{\r\nstruct fsnotify_event *event;\r\nstruct fsnotify_event_holder *holder;\r\nBUG_ON(!mutex_is_locked(&group->notification_mutex));\r\nholder = list_first_entry(&group->notification_list, struct fsnotify_event_holder, event_list);\r\nevent = holder->event;\r\nreturn event;\r\n}\r\nvoid fsnotify_flush_notify(struct fsnotify_group *group)\r\n{\r\nstruct fsnotify_event *event;\r\nstruct fsnotify_event_private_data *priv;\r\nmutex_lock(&group->notification_mutex);\r\nwhile (!fsnotify_notify_queue_is_empty(group)) {\r\nevent = fsnotify_remove_notify_event(group);\r\nif (group->ops->free_event_priv) {\r\nspin_lock(&event->lock);\r\npriv = fsnotify_remove_priv_from_event(group, event);\r\nspin_unlock(&event->lock);\r\nif (priv)\r\ngroup->ops->free_event_priv(priv);\r\n}\r\nfsnotify_put_event(event);\r\n}\r\nmutex_unlock(&group->notification_mutex);\r\n}\r\nstatic void initialize_event(struct fsnotify_event *event)\r\n{\r\nINIT_LIST_HEAD(&event->holder.event_list);\r\natomic_set(&event->refcnt, 1);\r\nspin_lock_init(&event->lock);\r\nINIT_LIST_HEAD(&event->private_data_list);\r\n}\r\nint fsnotify_replace_event(struct fsnotify_event_holder *old_holder,\r\nstruct fsnotify_event *new_event)\r\n{\r\nstruct fsnotify_event *old_event = old_holder->event;\r\nstruct fsnotify_event_holder *new_holder = &new_event->holder;\r\nenum event_spinlock_class {\r\nSPINLOCK_OLD,\r\nSPINLOCK_NEW,\r\n};\r\npr_debug("%s: old_event=%p new_event=%p\n", __func__, old_event, new_event);\r\nBUG_ON(!list_empty(&new_holder->event_list));\r\nspin_lock_nested(&old_event->lock, SPINLOCK_OLD);\r\nspin_lock_nested(&new_event->lock, SPINLOCK_NEW);\r\nnew_holder->event = new_event;\r\nlist_replace_init(&old_holder->event_list, &new_holder->event_list);\r\nspin_unlock(&new_event->lock);\r\nspin_unlock(&old_event->lock);\r\nif (old_holder != &old_event->holder)\r\nfsnotify_destroy_event_holder(old_holder);\r\nfsnotify_get_event(new_event);\r\nfsnotify_put_event(old_event);\r\nreturn 0;\r\n}\r\nstruct fsnotify_event *fsnotify_clone_event(struct fsnotify_event *old_event)\r\n{\r\nstruct fsnotify_event *event;\r\nevent = kmem_cache_alloc(fsnotify_event_cachep, GFP_KERNEL);\r\nif (!event)\r\nreturn NULL;\r\npr_debug("%s: old_event=%p new_event=%p\n", __func__, old_event, event);\r\nmemcpy(event, old_event, sizeof(*event));\r\ninitialize_event(event);\r\nif (event->name_len) {\r\nevent->file_name = kstrdup(old_event->file_name, GFP_KERNEL);\r\nif (!event->file_name) {\r\nkmem_cache_free(fsnotify_event_cachep, event);\r\nreturn NULL;\r\n}\r\n}\r\nevent->tgid = get_pid(old_event->tgid);\r\nif (event->data_type == FSNOTIFY_EVENT_PATH)\r\npath_get(&event->path);\r\nreturn event;\r\n}\r\nstruct fsnotify_event *fsnotify_create_event(struct inode *to_tell, __u32 mask, void *data,\r\nint data_type, const unsigned char *name,\r\nu32 cookie, gfp_t gfp)\r\n{\r\nstruct fsnotify_event *event;\r\nevent = kmem_cache_zalloc(fsnotify_event_cachep, gfp);\r\nif (!event)\r\nreturn NULL;\r\npr_debug("%s: event=%p to_tell=%p mask=%x data=%p data_type=%d\n",\r\n__func__, event, to_tell, mask, data, data_type);\r\ninitialize_event(event);\r\nif (name) {\r\nevent->file_name = kstrdup(name, gfp);\r\nif (!event->file_name) {\r\nkmem_cache_free(fsnotify_event_cachep, event);\r\nreturn NULL;\r\n}\r\nevent->name_len = strlen(event->file_name);\r\n}\r\nevent->tgid = get_pid(task_tgid(current));\r\nevent->sync_cookie = cookie;\r\nevent->to_tell = to_tell;\r\nevent->data_type = data_type;\r\nswitch (data_type) {\r\ncase FSNOTIFY_EVENT_PATH: {\r\nstruct path *path = data;\r\nevent->path.dentry = path->dentry;\r\nevent->path.mnt = path->mnt;\r\npath_get(&event->path);\r\nbreak;\r\n}\r\ncase FSNOTIFY_EVENT_INODE:\r\nevent->inode = data;\r\nbreak;\r\ncase FSNOTIFY_EVENT_NONE:\r\nevent->inode = NULL;\r\nevent->path.dentry = NULL;\r\nevent->path.mnt = NULL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nevent->mask = mask;\r\nreturn event;\r\n}\r\n__init int fsnotify_notification_init(void)\r\n{\r\nfsnotify_event_cachep = KMEM_CACHE(fsnotify_event, SLAB_PANIC);\r\nfsnotify_event_holder_cachep = KMEM_CACHE(fsnotify_event_holder, SLAB_PANIC);\r\nq_overflow_event = fsnotify_create_event(NULL, FS_Q_OVERFLOW, NULL,\r\nFSNOTIFY_EVENT_NONE, NULL, 0,\r\nGFP_KERNEL);\r\nif (!q_overflow_event)\r\npanic("unable to allocate fsnotify q_overflow_event\n");\r\nreturn 0;\r\n}
