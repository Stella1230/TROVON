static void appldata_timer_function(unsigned long data)\r\n{\r\nif (atomic_dec_and_test(&appldata_expire_count)) {\r\natomic_set(&appldata_expire_count, num_online_cpus());\r\nqueue_work(appldata_wq, (struct work_struct *) data);\r\n}\r\n}\r\nstatic void appldata_work_fn(struct work_struct *work)\r\n{\r\nstruct list_head *lh;\r\nstruct appldata_ops *ops;\r\nget_online_cpus();\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\nops = list_entry(lh, struct appldata_ops, list);\r\nif (ops->active == 1) {\r\nops->callback(ops->data);\r\n}\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nput_online_cpus();\r\n}\r\nint appldata_diag(char record_nr, u16 function, unsigned long buffer,\r\nu16 length, char *mod_lvl)\r\n{\r\nstruct appldata_product_id id = {\r\n.prod_nr = {0xD3, 0xC9, 0xD5, 0xE4,\r\n0xE7, 0xD2, 0xD9},\r\n.prod_fn = 0xD5D3,\r\n.version_nr = 0xF2F6,\r\n.release_nr = 0xF0F1,\r\n};\r\nid.record_nr = record_nr;\r\nid.mod_lvl = (mod_lvl[0]) << 8 | mod_lvl[1];\r\nreturn appldata_asm(&id, function, (void *) buffer, length);\r\n}\r\nstatic void __appldata_mod_vtimer_wrap(void *p) {\r\nstruct {\r\nstruct vtimer_list *timer;\r\nu64 expires;\r\n} *args = p;\r\nmod_virt_timer_periodic(args->timer, args->expires);\r\n}\r\nstatic void\r\n__appldata_vtimer_setup(int cmd)\r\n{\r\nu64 per_cpu_interval;\r\nint i;\r\nswitch (cmd) {\r\ncase APPLDATA_ADD_TIMER:\r\nif (appldata_timer_active)\r\nbreak;\r\nper_cpu_interval = (u64) (appldata_interval*1000 /\r\nnum_online_cpus()) * TOD_MICRO;\r\nfor_each_online_cpu(i) {\r\nper_cpu(appldata_timer, i).expires = per_cpu_interval;\r\nsmp_call_function_single(i, add_virt_timer_periodic,\r\n&per_cpu(appldata_timer, i),\r\n1);\r\n}\r\nappldata_timer_active = 1;\r\nbreak;\r\ncase APPLDATA_DEL_TIMER:\r\nfor_each_online_cpu(i)\r\ndel_virt_timer(&per_cpu(appldata_timer, i));\r\nif (!appldata_timer_active)\r\nbreak;\r\nappldata_timer_active = 0;\r\natomic_set(&appldata_expire_count, num_online_cpus());\r\nbreak;\r\ncase APPLDATA_MOD_TIMER:\r\nper_cpu_interval = (u64) (appldata_interval*1000 /\r\nnum_online_cpus()) * TOD_MICRO;\r\nif (!appldata_timer_active)\r\nbreak;\r\nfor_each_online_cpu(i) {\r\nstruct {\r\nstruct vtimer_list *timer;\r\nu64 expires;\r\n} args;\r\nargs.timer = &per_cpu(appldata_timer, i);\r\nargs.expires = per_cpu_interval;\r\nsmp_call_function_single(i, __appldata_mod_vtimer_wrap,\r\n&args, 1);\r\n}\r\n}\r\n}\r\nstatic int\r\nappldata_timer_handler(ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint len;\r\nchar buf[2];\r\nif (!*lenp || *ppos) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (!write) {\r\nlen = sprintf(buf, appldata_timer_active ? "1\n" : "0\n");\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\ngoto out;\r\n}\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer, len > sizeof(buf) ? sizeof(buf) : len))\r\nreturn -EFAULT;\r\nget_online_cpus();\r\nspin_lock(&appldata_timer_lock);\r\nif (buf[0] == '1')\r\n__appldata_vtimer_setup(APPLDATA_ADD_TIMER);\r\nelse if (buf[0] == '0')\r\n__appldata_vtimer_setup(APPLDATA_DEL_TIMER);\r\nspin_unlock(&appldata_timer_lock);\r\nput_online_cpus();\r\nout:\r\n*lenp = len;\r\n*ppos += len;\r\nreturn 0;\r\n}\r\nstatic int\r\nappldata_interval_handler(ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint len, interval;\r\nchar buf[16];\r\nif (!*lenp || *ppos) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (!write) {\r\nlen = sprintf(buf, "%i\n", appldata_interval);\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\ngoto out;\r\n}\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer, len > sizeof(buf) ? sizeof(buf) : len)) {\r\nreturn -EFAULT;\r\n}\r\ninterval = 0;\r\nsscanf(buf, "%i", &interval);\r\nif (interval <= 0)\r\nreturn -EINVAL;\r\nget_online_cpus();\r\nspin_lock(&appldata_timer_lock);\r\nappldata_interval = interval;\r\n__appldata_vtimer_setup(APPLDATA_MOD_TIMER);\r\nspin_unlock(&appldata_timer_lock);\r\nput_online_cpus();\r\nout:\r\n*lenp = len;\r\n*ppos += len;\r\nreturn 0;\r\n}\r\nstatic int\r\nappldata_generic_handler(ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct appldata_ops *ops = NULL, *tmp_ops;\r\nint rc, len, found;\r\nchar buf[2];\r\nstruct list_head *lh;\r\nfound = 0;\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\ntmp_ops = list_entry(lh, struct appldata_ops, list);\r\nif (&tmp_ops->ctl_table[2] == ctl) {\r\nfound = 1;\r\n}\r\n}\r\nif (!found) {\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn -ENODEV;\r\n}\r\nops = ctl->data;\r\nif (!try_module_get(ops->owner)) {\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn -ENODEV;\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nif (!*lenp || *ppos) {\r\n*lenp = 0;\r\nmodule_put(ops->owner);\r\nreturn 0;\r\n}\r\nif (!write) {\r\nlen = sprintf(buf, ops->active ? "1\n" : "0\n");\r\nif (len > *lenp)\r\nlen = *lenp;\r\nif (copy_to_user(buffer, buf, len)) {\r\nmodule_put(ops->owner);\r\nreturn -EFAULT;\r\n}\r\ngoto out;\r\n}\r\nlen = *lenp;\r\nif (copy_from_user(buf, buffer,\r\nlen > sizeof(buf) ? sizeof(buf) : len)) {\r\nmodule_put(ops->owner);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&appldata_ops_mutex);\r\nif ((buf[0] == '1') && (ops->active == 0)) {\r\nif (!try_module_get(ops->owner)) {\r\nmutex_unlock(&appldata_ops_mutex);\r\nmodule_put(ops->owner);\r\nreturn -ENODEV;\r\n}\r\nops->callback(ops->data);\r\nrc = appldata_diag(ops->record_nr,\r\nAPPLDATA_START_INTERVAL_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0) {\r\npr_err("Starting the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\nmodule_put(ops->owner);\r\n} else\r\nops->active = 1;\r\n} else if ((buf[0] == '0') && (ops->active == 1)) {\r\nops->active = 0;\r\nrc = appldata_diag(ops->record_nr, APPLDATA_STOP_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0)\r\npr_err("Stopping the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\nmodule_put(ops->owner);\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nout:\r\n*lenp = len;\r\n*ppos += len;\r\nmodule_put(ops->owner);\r\nreturn 0;\r\n}\r\nint appldata_register_ops(struct appldata_ops *ops)\r\n{\r\nif (ops->size > APPLDATA_MAX_REC_SIZE)\r\nreturn -EINVAL;\r\nops->ctl_table = kzalloc(4 * sizeof(struct ctl_table), GFP_KERNEL);\r\nif (!ops->ctl_table)\r\nreturn -ENOMEM;\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_add(&ops->list, &appldata_ops_list);\r\nmutex_unlock(&appldata_ops_mutex);\r\nops->ctl_table[0].procname = appldata_proc_name;\r\nops->ctl_table[0].maxlen = 0;\r\nops->ctl_table[0].mode = S_IRUGO | S_IXUGO;\r\nops->ctl_table[0].child = &ops->ctl_table[2];\r\nops->ctl_table[2].procname = ops->name;\r\nops->ctl_table[2].mode = S_IRUGO | S_IWUSR;\r\nops->ctl_table[2].proc_handler = appldata_generic_handler;\r\nops->ctl_table[2].data = ops;\r\nops->sysctl_header = register_sysctl_table(ops->ctl_table);\r\nif (!ops->sysctl_header)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_del(&ops->list);\r\nmutex_unlock(&appldata_ops_mutex);\r\nkfree(ops->ctl_table);\r\nreturn -ENOMEM;\r\n}\r\nvoid appldata_unregister_ops(struct appldata_ops *ops)\r\n{\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_del(&ops->list);\r\nmutex_unlock(&appldata_ops_mutex);\r\nunregister_sysctl_table(ops->sysctl_header);\r\nkfree(ops->ctl_table);\r\n}\r\nstatic int appldata_freeze(struct device *dev)\r\n{\r\nstruct appldata_ops *ops;\r\nint rc;\r\nstruct list_head *lh;\r\nget_online_cpus();\r\nspin_lock(&appldata_timer_lock);\r\nif (appldata_timer_active) {\r\n__appldata_vtimer_setup(APPLDATA_DEL_TIMER);\r\nappldata_timer_suspended = 1;\r\n}\r\nspin_unlock(&appldata_timer_lock);\r\nput_online_cpus();\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\nops = list_entry(lh, struct appldata_ops, list);\r\nif (ops->active == 1) {\r\nrc = appldata_diag(ops->record_nr, APPLDATA_STOP_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0)\r\npr_err("Stopping the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\n}\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int appldata_restore(struct device *dev)\r\n{\r\nstruct appldata_ops *ops;\r\nint rc;\r\nstruct list_head *lh;\r\nget_online_cpus();\r\nspin_lock(&appldata_timer_lock);\r\nif (appldata_timer_suspended) {\r\n__appldata_vtimer_setup(APPLDATA_ADD_TIMER);\r\nappldata_timer_suspended = 0;\r\n}\r\nspin_unlock(&appldata_timer_lock);\r\nput_online_cpus();\r\nmutex_lock(&appldata_ops_mutex);\r\nlist_for_each(lh, &appldata_ops_list) {\r\nops = list_entry(lh, struct appldata_ops, list);\r\nif (ops->active == 1) {\r\nops->callback(ops->data);\r\nrc = appldata_diag(ops->record_nr,\r\nAPPLDATA_START_INTERVAL_REC,\r\n(unsigned long) ops->data, ops->size,\r\nops->mod_lvl);\r\nif (rc != 0) {\r\npr_err("Starting the data collection for %s "\r\n"failed with rc=%d\n", ops->name, rc);\r\n}\r\n}\r\n}\r\nmutex_unlock(&appldata_ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int appldata_thaw(struct device *dev)\r\n{\r\nreturn appldata_restore(dev);\r\n}\r\nstatic void __cpuinit appldata_online_cpu(int cpu)\r\n{\r\ninit_virt_timer(&per_cpu(appldata_timer, cpu));\r\nper_cpu(appldata_timer, cpu).function = appldata_timer_function;\r\nper_cpu(appldata_timer, cpu).data = (unsigned long)\r\n&appldata_work;\r\natomic_inc(&appldata_expire_count);\r\nspin_lock(&appldata_timer_lock);\r\n__appldata_vtimer_setup(APPLDATA_MOD_TIMER);\r\nspin_unlock(&appldata_timer_lock);\r\n}\r\nstatic void __cpuinit appldata_offline_cpu(int cpu)\r\n{\r\ndel_virt_timer(&per_cpu(appldata_timer, cpu));\r\nif (atomic_dec_and_test(&appldata_expire_count)) {\r\natomic_set(&appldata_expire_count, num_online_cpus());\r\nqueue_work(appldata_wq, &appldata_work);\r\n}\r\nspin_lock(&appldata_timer_lock);\r\n__appldata_vtimer_setup(APPLDATA_MOD_TIMER);\r\nspin_unlock(&appldata_timer_lock);\r\n}\r\nstatic int __cpuinit appldata_cpu_notify(struct notifier_block *self,\r\nunsigned long action,\r\nvoid *hcpu)\r\n{\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nappldata_online_cpu((long) hcpu);\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nappldata_offline_cpu((long) hcpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init appldata_init(void)\r\n{\r\nint i, rc;\r\nrc = platform_driver_register(&appldata_pdrv);\r\nif (rc)\r\nreturn rc;\r\nappldata_pdev = platform_device_register_simple("appldata", -1, NULL,\r\n0);\r\nif (IS_ERR(appldata_pdev)) {\r\nrc = PTR_ERR(appldata_pdev);\r\ngoto out_driver;\r\n}\r\nappldata_wq = create_singlethread_workqueue("appldata");\r\nif (!appldata_wq) {\r\nrc = -ENOMEM;\r\ngoto out_device;\r\n}\r\nget_online_cpus();\r\nfor_each_online_cpu(i)\r\nappldata_online_cpu(i);\r\nput_online_cpus();\r\nregister_hotcpu_notifier(&appldata_nb);\r\nappldata_sysctl_header = register_sysctl_table(appldata_dir_table);\r\nreturn 0;\r\nout_device:\r\nplatform_device_unregister(appldata_pdev);\r\nout_driver:\r\nplatform_driver_unregister(&appldata_pdrv);\r\nreturn rc;\r\n}
