static void bsg_free_command(struct bsg_command *bc)\r\n{\r\nstruct bsg_device *bd = bc->bd;\r\nunsigned long flags;\r\nkmem_cache_free(bsg_cmd_cachep, bc);\r\nspin_lock_irqsave(&bd->lock, flags);\r\nbd->queued_cmds--;\r\nspin_unlock_irqrestore(&bd->lock, flags);\r\nwake_up(&bd->wq_free);\r\n}\r\nstatic struct bsg_command *bsg_alloc_command(struct bsg_device *bd)\r\n{\r\nstruct bsg_command *bc = ERR_PTR(-EINVAL);\r\nspin_lock_irq(&bd->lock);\r\nif (bd->queued_cmds >= bd->max_queue)\r\ngoto out;\r\nbd->queued_cmds++;\r\nspin_unlock_irq(&bd->lock);\r\nbc = kmem_cache_zalloc(bsg_cmd_cachep, GFP_KERNEL);\r\nif (unlikely(!bc)) {\r\nspin_lock_irq(&bd->lock);\r\nbd->queued_cmds--;\r\nbc = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nbc->bd = bd;\r\nINIT_LIST_HEAD(&bc->list);\r\ndprintk("%s: returning free cmd %p\n", bd->name, bc);\r\nreturn bc;\r\nout:\r\nspin_unlock_irq(&bd->lock);\r\nreturn bc;\r\n}\r\nstatic inline struct hlist_head *bsg_dev_idx_hash(int index)\r\n{\r\nreturn &bsg_device_list[index & (BSG_LIST_ARRAY_SIZE - 1)];\r\n}\r\nstatic int bsg_io_schedule(struct bsg_device *bd)\r\n{\r\nDEFINE_WAIT(wait);\r\nint ret = 0;\r\nspin_lock_irq(&bd->lock);\r\nBUG_ON(bd->done_cmds > bd->queued_cmds);\r\nif (bd->done_cmds == bd->queued_cmds) {\r\nret = -ENODATA;\r\ngoto unlock;\r\n}\r\nif (!test_bit(BSG_F_BLOCK, &bd->flags)) {\r\nret = -EAGAIN;\r\ngoto unlock;\r\n}\r\nprepare_to_wait(&bd->wq_done, &wait, TASK_UNINTERRUPTIBLE);\r\nspin_unlock_irq(&bd->lock);\r\nio_schedule();\r\nfinish_wait(&bd->wq_done, &wait);\r\nreturn ret;\r\nunlock:\r\nspin_unlock_irq(&bd->lock);\r\nreturn ret;\r\n}\r\nstatic int blk_fill_sgv4_hdr_rq(struct request_queue *q, struct request *rq,\r\nstruct sg_io_v4 *hdr, struct bsg_device *bd,\r\nfmode_t has_write_perm)\r\n{\r\nif (hdr->request_len > BLK_MAX_CDB) {\r\nrq->cmd = kzalloc(hdr->request_len, GFP_KERNEL);\r\nif (!rq->cmd)\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(rq->cmd, (void __user *)(unsigned long)hdr->request,\r\nhdr->request_len))\r\nreturn -EFAULT;\r\nif (hdr->subprotocol == BSG_SUB_PROTOCOL_SCSI_CMD) {\r\nif (blk_verify_command(rq->cmd, has_write_perm))\r\nreturn -EPERM;\r\n} else if (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nrq->cmd_len = hdr->request_len;\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nrq->timeout = msecs_to_jiffies(hdr->timeout);\r\nif (!rq->timeout)\r\nrq->timeout = q->sg_timeout;\r\nif (!rq->timeout)\r\nrq->timeout = BLK_DEFAULT_SG_TIMEOUT;\r\nif (rq->timeout < BLK_MIN_SG_TIMEOUT)\r\nrq->timeout = BLK_MIN_SG_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int\r\nbsg_validate_sgv4_hdr(struct request_queue *q, struct sg_io_v4 *hdr, int *rw)\r\n{\r\nint ret = 0;\r\nif (hdr->guard != 'Q')\r\nreturn -EINVAL;\r\nswitch (hdr->protocol) {\r\ncase BSG_PROTOCOL_SCSI:\r\nswitch (hdr->subprotocol) {\r\ncase BSG_SUB_PROTOCOL_SCSI_CMD:\r\ncase BSG_SUB_PROTOCOL_SCSI_TRANSPORT:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\n*rw = hdr->dout_xfer_len ? WRITE : READ;\r\nreturn ret;\r\n}\r\nstatic struct request *\r\nbsg_map_hdr(struct bsg_device *bd, struct sg_io_v4 *hdr, fmode_t has_write_perm,\r\nu8 *sense)\r\n{\r\nstruct request_queue *q = bd->queue;\r\nstruct request *rq, *next_rq = NULL;\r\nint ret, rw;\r\nunsigned int dxfer_len;\r\nvoid __user *dxferp = NULL;\r\nstruct bsg_class_device *bcd = &q->bsg_dev;\r\nif (!bcd->class_dev)\r\nreturn ERR_PTR(-ENXIO);\r\ndprintk("map hdr %llx/%u %llx/%u\n", (unsigned long long) hdr->dout_xferp,\r\nhdr->dout_xfer_len, (unsigned long long) hdr->din_xferp,\r\nhdr->din_xfer_len);\r\nret = bsg_validate_sgv4_hdr(q, hdr, &rw);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nrq = blk_get_request(q, rw, GFP_KERNEL);\r\nif (!rq)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = blk_fill_sgv4_hdr_rq(q, rq, hdr, bd, has_write_perm);\r\nif (ret)\r\ngoto out;\r\nif (rw == WRITE && hdr->din_xfer_len) {\r\nif (!test_bit(QUEUE_FLAG_BIDI, &q->queue_flags)) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nnext_rq = blk_get_request(q, READ, GFP_KERNEL);\r\nif (!next_rq) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nrq->next_rq = next_rq;\r\nnext_rq->cmd_type = rq->cmd_type;\r\ndxferp = (void __user *)(unsigned long)hdr->din_xferp;\r\nret = blk_rq_map_user(q, next_rq, NULL, dxferp,\r\nhdr->din_xfer_len, GFP_KERNEL);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (hdr->dout_xfer_len) {\r\ndxfer_len = hdr->dout_xfer_len;\r\ndxferp = (void __user *)(unsigned long)hdr->dout_xferp;\r\n} else if (hdr->din_xfer_len) {\r\ndxfer_len = hdr->din_xfer_len;\r\ndxferp = (void __user *)(unsigned long)hdr->din_xferp;\r\n} else\r\ndxfer_len = 0;\r\nif (dxfer_len) {\r\nret = blk_rq_map_user(q, rq, NULL, dxferp, dxfer_len,\r\nGFP_KERNEL);\r\nif (ret)\r\ngoto out;\r\n}\r\nrq->sense = sense;\r\nrq->sense_len = 0;\r\nreturn rq;\r\nout:\r\nif (rq->cmd != rq->__cmd)\r\nkfree(rq->cmd);\r\nblk_put_request(rq);\r\nif (next_rq) {\r\nblk_rq_unmap_user(next_rq->bio);\r\nblk_put_request(next_rq);\r\n}\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void bsg_rq_end_io(struct request *rq, int uptodate)\r\n{\r\nstruct bsg_command *bc = rq->end_io_data;\r\nstruct bsg_device *bd = bc->bd;\r\nunsigned long flags;\r\ndprintk("%s: finished rq %p bc %p, bio %p stat %d\n",\r\nbd->name, rq, bc, bc->bio, uptodate);\r\nbc->hdr.duration = jiffies_to_msecs(jiffies - bc->hdr.duration);\r\nspin_lock_irqsave(&bd->lock, flags);\r\nlist_move_tail(&bc->list, &bd->done_list);\r\nbd->done_cmds++;\r\nspin_unlock_irqrestore(&bd->lock, flags);\r\nwake_up(&bd->wq_done);\r\n}\r\nstatic void bsg_add_command(struct bsg_device *bd, struct request_queue *q,\r\nstruct bsg_command *bc, struct request *rq)\r\n{\r\nint at_head = (0 == (bc->hdr.flags & BSG_FLAG_Q_AT_TAIL));\r\nbc->rq = rq;\r\nbc->bio = rq->bio;\r\nif (rq->next_rq)\r\nbc->bidi_bio = rq->next_rq->bio;\r\nbc->hdr.duration = jiffies;\r\nspin_lock_irq(&bd->lock);\r\nlist_add_tail(&bc->list, &bd->busy_list);\r\nspin_unlock_irq(&bd->lock);\r\ndprintk("%s: queueing rq %p, bc %p\n", bd->name, rq, bc);\r\nrq->end_io_data = bc;\r\nblk_execute_rq_nowait(q, NULL, rq, at_head, bsg_rq_end_io);\r\n}\r\nstatic struct bsg_command *bsg_next_done_cmd(struct bsg_device *bd)\r\n{\r\nstruct bsg_command *bc = NULL;\r\nspin_lock_irq(&bd->lock);\r\nif (bd->done_cmds) {\r\nbc = list_first_entry(&bd->done_list, struct bsg_command, list);\r\nlist_del(&bc->list);\r\nbd->done_cmds--;\r\n}\r\nspin_unlock_irq(&bd->lock);\r\nreturn bc;\r\n}\r\nstatic struct bsg_command *bsg_get_done_cmd(struct bsg_device *bd)\r\n{\r\nstruct bsg_command *bc;\r\nint ret;\r\ndo {\r\nbc = bsg_next_done_cmd(bd);\r\nif (bc)\r\nbreak;\r\nif (!test_bit(BSG_F_BLOCK, &bd->flags)) {\r\nbc = ERR_PTR(-EAGAIN);\r\nbreak;\r\n}\r\nret = wait_event_interruptible(bd->wq_done, bd->done_cmds);\r\nif (ret) {\r\nbc = ERR_PTR(-ERESTARTSYS);\r\nbreak;\r\n}\r\n} while (1);\r\ndprintk("%s: returning done %p\n", bd->name, bc);\r\nreturn bc;\r\n}\r\nstatic int blk_complete_sgv4_hdr_rq(struct request *rq, struct sg_io_v4 *hdr,\r\nstruct bio *bio, struct bio *bidi_bio)\r\n{\r\nint ret = 0;\r\ndprintk("rq %p bio %p 0x%x\n", rq, bio, rq->errors);\r\nhdr->device_status = rq->errors & 0xff;\r\nhdr->transport_status = host_byte(rq->errors);\r\nhdr->driver_status = driver_byte(rq->errors);\r\nhdr->info = 0;\r\nif (hdr->device_status || hdr->transport_status || hdr->driver_status)\r\nhdr->info |= SG_INFO_CHECK;\r\nhdr->response_len = 0;\r\nif (rq->sense_len && hdr->response) {\r\nint len = min_t(unsigned int, hdr->max_response_len,\r\nrq->sense_len);\r\nret = copy_to_user((void __user *)(unsigned long)hdr->response,\r\nrq->sense, len);\r\nif (!ret)\r\nhdr->response_len = len;\r\nelse\r\nret = -EFAULT;\r\n}\r\nif (rq->next_rq) {\r\nhdr->dout_resid = rq->resid_len;\r\nhdr->din_resid = rq->next_rq->resid_len;\r\nblk_rq_unmap_user(bidi_bio);\r\nblk_put_request(rq->next_rq);\r\n} else if (rq_data_dir(rq) == READ)\r\nhdr->din_resid = rq->resid_len;\r\nelse\r\nhdr->dout_resid = rq->resid_len;\r\nif (!ret && rq->errors < 0)\r\nret = rq->errors;\r\nblk_rq_unmap_user(bio);\r\nif (rq->cmd != rq->__cmd)\r\nkfree(rq->cmd);\r\nblk_put_request(rq);\r\nreturn ret;\r\n}\r\nstatic int bsg_complete_all_commands(struct bsg_device *bd)\r\n{\r\nstruct bsg_command *bc;\r\nint ret, tret;\r\ndprintk("%s: entered\n", bd->name);\r\nret = 0;\r\ndo {\r\nret = bsg_io_schedule(bd);\r\n} while (ret != -ENODATA);\r\nret = 0;\r\ndo {\r\nspin_lock_irq(&bd->lock);\r\nif (!bd->queued_cmds) {\r\nspin_unlock_irq(&bd->lock);\r\nbreak;\r\n}\r\nspin_unlock_irq(&bd->lock);\r\nbc = bsg_get_done_cmd(bd);\r\nif (IS_ERR(bc))\r\nbreak;\r\ntret = blk_complete_sgv4_hdr_rq(bc->rq, &bc->hdr, bc->bio,\r\nbc->bidi_bio);\r\nif (!ret)\r\nret = tret;\r\nbsg_free_command(bc);\r\n} while (1);\r\nreturn ret;\r\n}\r\nstatic int\r\n__bsg_read(char __user *buf, size_t count, struct bsg_device *bd,\r\nconst struct iovec *iov, ssize_t *bytes_read)\r\n{\r\nstruct bsg_command *bc;\r\nint nr_commands, ret;\r\nif (count % sizeof(struct sg_io_v4))\r\nreturn -EINVAL;\r\nret = 0;\r\nnr_commands = count / sizeof(struct sg_io_v4);\r\nwhile (nr_commands) {\r\nbc = bsg_get_done_cmd(bd);\r\nif (IS_ERR(bc)) {\r\nret = PTR_ERR(bc);\r\nbreak;\r\n}\r\nret = blk_complete_sgv4_hdr_rq(bc->rq, &bc->hdr, bc->bio,\r\nbc->bidi_bio);\r\nif (copy_to_user(buf, &bc->hdr, sizeof(bc->hdr)))\r\nret = -EFAULT;\r\nbsg_free_command(bc);\r\nif (ret)\r\nbreak;\r\nbuf += sizeof(struct sg_io_v4);\r\n*bytes_read += sizeof(struct sg_io_v4);\r\nnr_commands--;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void bsg_set_block(struct bsg_device *bd, struct file *file)\r\n{\r\nif (file->f_flags & O_NONBLOCK)\r\nclear_bit(BSG_F_BLOCK, &bd->flags);\r\nelse\r\nset_bit(BSG_F_BLOCK, &bd->flags);\r\n}\r\nstatic inline int err_block_err(int ret)\r\n{\r\nif (ret && ret != -ENOSPC && ret != -ENODATA && ret != -EAGAIN)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nbsg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct bsg_device *bd = file->private_data;\r\nint ret;\r\nssize_t bytes_read;\r\ndprintk("%s: read %Zd bytes\n", bd->name, count);\r\nbsg_set_block(bd, file);\r\nbytes_read = 0;\r\nret = __bsg_read(buf, count, bd, NULL, &bytes_read);\r\n*ppos = bytes_read;\r\nif (!bytes_read || err_block_err(ret))\r\nbytes_read = ret;\r\nreturn bytes_read;\r\n}\r\nstatic int __bsg_write(struct bsg_device *bd, const char __user *buf,\r\nsize_t count, ssize_t *bytes_written,\r\nfmode_t has_write_perm)\r\n{\r\nstruct bsg_command *bc;\r\nstruct request *rq;\r\nint ret, nr_commands;\r\nif (count % sizeof(struct sg_io_v4))\r\nreturn -EINVAL;\r\nnr_commands = count / sizeof(struct sg_io_v4);\r\nrq = NULL;\r\nbc = NULL;\r\nret = 0;\r\nwhile (nr_commands) {\r\nstruct request_queue *q = bd->queue;\r\nbc = bsg_alloc_command(bd);\r\nif (IS_ERR(bc)) {\r\nret = PTR_ERR(bc);\r\nbc = NULL;\r\nbreak;\r\n}\r\nif (copy_from_user(&bc->hdr, buf, sizeof(bc->hdr))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nrq = bsg_map_hdr(bd, &bc->hdr, has_write_perm, bc->sense);\r\nif (IS_ERR(rq)) {\r\nret = PTR_ERR(rq);\r\nrq = NULL;\r\nbreak;\r\n}\r\nbsg_add_command(bd, q, bc, rq);\r\nbc = NULL;\r\nrq = NULL;\r\nnr_commands--;\r\nbuf += sizeof(struct sg_io_v4);\r\n*bytes_written += sizeof(struct sg_io_v4);\r\n}\r\nif (bc)\r\nbsg_free_command(bc);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nbsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct bsg_device *bd = file->private_data;\r\nssize_t bytes_written;\r\nint ret;\r\ndprintk("%s: write %Zd bytes\n", bd->name, count);\r\nbsg_set_block(bd, file);\r\nbytes_written = 0;\r\nret = __bsg_write(bd, buf, count, &bytes_written,\r\nfile->f_mode & FMODE_WRITE);\r\n*ppos = bytes_written;\r\nif (!bytes_written || err_block_err(ret))\r\nbytes_written = ret;\r\ndprintk("%s: returning %Zd\n", bd->name, bytes_written);\r\nreturn bytes_written;\r\n}\r\nstatic struct bsg_device *bsg_alloc_device(void)\r\n{\r\nstruct bsg_device *bd;\r\nbd = kzalloc(sizeof(struct bsg_device), GFP_KERNEL);\r\nif (unlikely(!bd))\r\nreturn NULL;\r\nspin_lock_init(&bd->lock);\r\nbd->max_queue = BSG_DEFAULT_CMDS;\r\nINIT_LIST_HEAD(&bd->busy_list);\r\nINIT_LIST_HEAD(&bd->done_list);\r\nINIT_HLIST_NODE(&bd->dev_list);\r\ninit_waitqueue_head(&bd->wq_free);\r\ninit_waitqueue_head(&bd->wq_done);\r\nreturn bd;\r\n}\r\nstatic void bsg_kref_release_function(struct kref *kref)\r\n{\r\nstruct bsg_class_device *bcd =\r\ncontainer_of(kref, struct bsg_class_device, ref);\r\nstruct device *parent = bcd->parent;\r\nif (bcd->release)\r\nbcd->release(bcd->parent);\r\nput_device(parent);\r\n}\r\nstatic int bsg_put_device(struct bsg_device *bd)\r\n{\r\nint ret = 0, do_free;\r\nstruct request_queue *q = bd->queue;\r\nmutex_lock(&bsg_mutex);\r\ndo_free = atomic_dec_and_test(&bd->ref_count);\r\nif (!do_free) {\r\nmutex_unlock(&bsg_mutex);\r\ngoto out;\r\n}\r\nhlist_del(&bd->dev_list);\r\nmutex_unlock(&bsg_mutex);\r\ndprintk("%s: tearing down\n", bd->name);\r\nset_bit(BSG_F_BLOCK, &bd->flags);\r\nret = bsg_complete_all_commands(bd);\r\nkfree(bd);\r\nout:\r\nkref_put(&q->bsg_dev.ref, bsg_kref_release_function);\r\nif (do_free)\r\nblk_put_queue(q);\r\nreturn ret;\r\n}\r\nstatic struct bsg_device *bsg_add_device(struct inode *inode,\r\nstruct request_queue *rq,\r\nstruct file *file)\r\n{\r\nstruct bsg_device *bd;\r\nint ret;\r\n#ifdef BSG_DEBUG\r\nunsigned char buf[32];\r\n#endif\r\nret = blk_get_queue(rq);\r\nif (ret)\r\nreturn ERR_PTR(-ENXIO);\r\nbd = bsg_alloc_device();\r\nif (!bd) {\r\nblk_put_queue(rq);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nbd->queue = rq;\r\nbsg_set_block(bd, file);\r\natomic_set(&bd->ref_count, 1);\r\nmutex_lock(&bsg_mutex);\r\nhlist_add_head(&bd->dev_list, bsg_dev_idx_hash(iminor(inode)));\r\nstrncpy(bd->name, dev_name(rq->bsg_dev.class_dev), sizeof(bd->name) - 1);\r\ndprintk("bound to <%s>, max queue %d\n",\r\nformat_dev_t(buf, inode->i_rdev), bd->max_queue);\r\nmutex_unlock(&bsg_mutex);\r\nreturn bd;\r\n}\r\nstatic struct bsg_device *__bsg_get_device(int minor, struct request_queue *q)\r\n{\r\nstruct bsg_device *bd;\r\nstruct hlist_node *entry;\r\nmutex_lock(&bsg_mutex);\r\nhlist_for_each_entry(bd, entry, bsg_dev_idx_hash(minor), dev_list) {\r\nif (bd->queue == q) {\r\natomic_inc(&bd->ref_count);\r\ngoto found;\r\n}\r\n}\r\nbd = NULL;\r\nfound:\r\nmutex_unlock(&bsg_mutex);\r\nreturn bd;\r\n}\r\nstatic struct bsg_device *bsg_get_device(struct inode *inode, struct file *file)\r\n{\r\nstruct bsg_device *bd;\r\nstruct bsg_class_device *bcd;\r\nmutex_lock(&bsg_mutex);\r\nbcd = idr_find(&bsg_minor_idr, iminor(inode));\r\nif (bcd)\r\nkref_get(&bcd->ref);\r\nmutex_unlock(&bsg_mutex);\r\nif (!bcd)\r\nreturn ERR_PTR(-ENODEV);\r\nbd = __bsg_get_device(iminor(inode), bcd->queue);\r\nif (bd)\r\nreturn bd;\r\nbd = bsg_add_device(inode, bcd->queue, file);\r\nif (IS_ERR(bd))\r\nkref_put(&bcd->ref, bsg_kref_release_function);\r\nreturn bd;\r\n}\r\nstatic int bsg_open(struct inode *inode, struct file *file)\r\n{\r\nstruct bsg_device *bd;\r\nbd = bsg_get_device(inode, file);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\nfile->private_data = bd;\r\nreturn 0;\r\n}\r\nstatic int bsg_release(struct inode *inode, struct file *file)\r\n{\r\nstruct bsg_device *bd = file->private_data;\r\nfile->private_data = NULL;\r\nreturn bsg_put_device(bd);\r\n}\r\nstatic unsigned int bsg_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct bsg_device *bd = file->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(file, &bd->wq_done, wait);\r\npoll_wait(file, &bd->wq_free, wait);\r\nspin_lock_irq(&bd->lock);\r\nif (!list_empty(&bd->done_list))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (bd->queued_cmds < bd->max_queue)\r\nmask |= POLLOUT;\r\nspin_unlock_irq(&bd->lock);\r\nreturn mask;\r\n}\r\nstatic long bsg_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct bsg_device *bd = file->private_data;\r\nint __user *uarg = (int __user *) arg;\r\nint ret;\r\nswitch (cmd) {\r\ncase SG_GET_COMMAND_Q:\r\nreturn put_user(bd->max_queue, uarg);\r\ncase SG_SET_COMMAND_Q: {\r\nint queue;\r\nif (get_user(queue, uarg))\r\nreturn -EFAULT;\r\nif (queue < 1)\r\nreturn -EINVAL;\r\nspin_lock_irq(&bd->lock);\r\nbd->max_queue = queue;\r\nspin_unlock_irq(&bd->lock);\r\nreturn 0;\r\n}\r\ncase SG_GET_VERSION_NUM:\r\ncase SCSI_IOCTL_GET_IDLUN:\r\ncase SCSI_IOCTL_GET_BUS_NUMBER:\r\ncase SG_SET_TIMEOUT:\r\ncase SG_GET_TIMEOUT:\r\ncase SG_GET_RESERVED_SIZE:\r\ncase SG_SET_RESERVED_SIZE:\r\ncase SG_EMULATED_HOST:\r\ncase SCSI_IOCTL_SEND_COMMAND: {\r\nvoid __user *uarg = (void __user *) arg;\r\nreturn scsi_cmd_ioctl(bd->queue, NULL, file->f_mode, cmd, uarg);\r\n}\r\ncase SG_IO: {\r\nstruct request *rq;\r\nstruct bio *bio, *bidi_bio = NULL;\r\nstruct sg_io_v4 hdr;\r\nint at_head;\r\nu8 sense[SCSI_SENSE_BUFFERSIZE];\r\nif (copy_from_user(&hdr, uarg, sizeof(hdr)))\r\nreturn -EFAULT;\r\nrq = bsg_map_hdr(bd, &hdr, file->f_mode & FMODE_WRITE, sense);\r\nif (IS_ERR(rq))\r\nreturn PTR_ERR(rq);\r\nbio = rq->bio;\r\nif (rq->next_rq)\r\nbidi_bio = rq->next_rq->bio;\r\nat_head = (0 == (hdr.flags & BSG_FLAG_Q_AT_TAIL));\r\nblk_execute_rq(bd->queue, NULL, rq, at_head);\r\nret = blk_complete_sgv4_hdr_rq(rq, &hdr, bio, bidi_bio);\r\nif (copy_to_user(uarg, &hdr, sizeof(hdr)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\ndefault:\r\n#if 0\r\nreturn ioctl_by_bdev(bd->bdev, cmd, arg);\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\n}\r\nvoid bsg_unregister_queue(struct request_queue *q)\r\n{\r\nstruct bsg_class_device *bcd = &q->bsg_dev;\r\nif (!bcd->class_dev)\r\nreturn;\r\nmutex_lock(&bsg_mutex);\r\nidr_remove(&bsg_minor_idr, bcd->minor);\r\nsysfs_remove_link(&q->kobj, "bsg");\r\ndevice_unregister(bcd->class_dev);\r\nbcd->class_dev = NULL;\r\nkref_put(&bcd->ref, bsg_kref_release_function);\r\nmutex_unlock(&bsg_mutex);\r\n}\r\nint bsg_register_queue(struct request_queue *q, struct device *parent,\r\nconst char *name, void (*release)(struct device *))\r\n{\r\nstruct bsg_class_device *bcd;\r\ndev_t dev;\r\nint ret, minor;\r\nstruct device *class_dev = NULL;\r\nconst char *devname;\r\nif (name)\r\ndevname = name;\r\nelse\r\ndevname = dev_name(parent);\r\nif (!q->request_fn)\r\nreturn 0;\r\nbcd = &q->bsg_dev;\r\nmemset(bcd, 0, sizeof(*bcd));\r\nmutex_lock(&bsg_mutex);\r\nret = idr_pre_get(&bsg_minor_idr, GFP_KERNEL);\r\nif (!ret) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nret = idr_get_new(&bsg_minor_idr, bcd, &minor);\r\nif (ret < 0)\r\ngoto unlock;\r\nif (minor >= BSG_MAX_DEVS) {\r\nprintk(KERN_ERR "bsg: too many bsg devices\n");\r\nret = -EINVAL;\r\ngoto remove_idr;\r\n}\r\nbcd->minor = minor;\r\nbcd->queue = q;\r\nbcd->parent = get_device(parent);\r\nbcd->release = release;\r\nkref_init(&bcd->ref);\r\ndev = MKDEV(bsg_major, bcd->minor);\r\nclass_dev = device_create(bsg_class, parent, dev, NULL, "%s", devname);\r\nif (IS_ERR(class_dev)) {\r\nret = PTR_ERR(class_dev);\r\ngoto put_dev;\r\n}\r\nbcd->class_dev = class_dev;\r\nif (q->kobj.sd) {\r\nret = sysfs_create_link(&q->kobj, &bcd->class_dev->kobj, "bsg");\r\nif (ret)\r\ngoto unregister_class_dev;\r\n}\r\nmutex_unlock(&bsg_mutex);\r\nreturn 0;\r\nunregister_class_dev:\r\ndevice_unregister(class_dev);\r\nput_dev:\r\nput_device(parent);\r\nremove_idr:\r\nidr_remove(&bsg_minor_idr, minor);\r\nunlock:\r\nmutex_unlock(&bsg_mutex);\r\nreturn ret;\r\n}\r\nstatic char *bsg_devnode(struct device *dev, mode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "bsg/%s", dev_name(dev));\r\n}\r\nstatic int __init bsg_init(void)\r\n{\r\nint ret, i;\r\ndev_t devid;\r\nbsg_cmd_cachep = kmem_cache_create("bsg_cmd",\r\nsizeof(struct bsg_command), 0, 0, NULL);\r\nif (!bsg_cmd_cachep) {\r\nprintk(KERN_ERR "bsg: failed creating slab cache\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < BSG_LIST_ARRAY_SIZE; i++)\r\nINIT_HLIST_HEAD(&bsg_device_list[i]);\r\nbsg_class = class_create(THIS_MODULE, "bsg");\r\nif (IS_ERR(bsg_class)) {\r\nret = PTR_ERR(bsg_class);\r\ngoto destroy_kmemcache;\r\n}\r\nbsg_class->devnode = bsg_devnode;\r\nret = alloc_chrdev_region(&devid, 0, BSG_MAX_DEVS, "bsg");\r\nif (ret)\r\ngoto destroy_bsg_class;\r\nbsg_major = MAJOR(devid);\r\ncdev_init(&bsg_cdev, &bsg_fops);\r\nret = cdev_add(&bsg_cdev, MKDEV(bsg_major, 0), BSG_MAX_DEVS);\r\nif (ret)\r\ngoto unregister_chrdev;\r\nprintk(KERN_INFO BSG_DESCRIPTION " version " BSG_VERSION\r\n" loaded (major %d)\n", bsg_major);\r\nreturn 0;\r\nunregister_chrdev:\r\nunregister_chrdev_region(MKDEV(bsg_major, 0), BSG_MAX_DEVS);\r\ndestroy_bsg_class:\r\nclass_destroy(bsg_class);\r\ndestroy_kmemcache:\r\nkmem_cache_destroy(bsg_cmd_cachep);\r\nreturn ret;\r\n}
