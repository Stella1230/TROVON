static void __iomem *\r\nirq_to_pic_mask(unsigned int irq)\r\n{\r\nreturn irq <= 7 ? &cpld_regs->pci_mask : &cpld_regs->misc_mask;\r\n}\r\nstatic unsigned int\r\nirq_to_pic_bit(unsigned int irq)\r\n{\r\nreturn 1 << (irq & 0x7);\r\n}\r\nstatic void\r\ncpld_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int cpld_irq = (unsigned int)irqd_to_hwirq(d);\r\nvoid __iomem *pic_mask = irq_to_pic_mask(cpld_irq);\r\nout_8(pic_mask,\r\nin_8(pic_mask) | irq_to_pic_bit(cpld_irq));\r\n}\r\nstatic void\r\ncpld_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int cpld_irq = (unsigned int)irqd_to_hwirq(d);\r\nvoid __iomem *pic_mask = irq_to_pic_mask(cpld_irq);\r\nout_8(pic_mask,\r\nin_8(pic_mask) & ~irq_to_pic_bit(cpld_irq));\r\n}\r\nstatic int\r\ncpld_pic_get_irq(int offset, u8 ignore, u8 __iomem *statusp,\r\nu8 __iomem *maskp)\r\n{\r\nint cpld_irq;\r\nu8 status = in_8(statusp);\r\nu8 mask = in_8(maskp);\r\nstatus |= (ignore | mask);\r\nif (status == 0xff)\r\nreturn NO_IRQ;\r\ncpld_irq = ffz(status) + offset;\r\nreturn irq_linear_revmap(cpld_pic_host, cpld_irq);\r\n}\r\nstatic void\r\ncpld_pic_cascade(unsigned int irq, struct irq_desc *desc)\r\n{\r\nirq = cpld_pic_get_irq(0, PCI_IGNORE, &cpld_regs->pci_status,\r\n&cpld_regs->pci_mask);\r\nif (irq != NO_IRQ) {\r\ngeneric_handle_irq(irq);\r\nreturn;\r\n}\r\nirq = cpld_pic_get_irq(8, MISC_IGNORE, &cpld_regs->misc_status,\r\n&cpld_regs->misc_mask);\r\nif (irq != NO_IRQ) {\r\ngeneric_handle_irq(irq);\r\nreturn;\r\n}\r\n}\r\nstatic int\r\ncpld_pic_host_match(struct irq_host *h, struct device_node *node)\r\n{\r\nreturn cpld_pic_node == node;\r\n}\r\nstatic int\r\ncpld_pic_host_map(struct irq_host *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &cpld_pic, handle_level_irq);\r\nreturn 0;\r\n}\r\nvoid __init\r\nmpc5121_ads_cpld_map(void)\r\n{\r\nstruct device_node *np = NULL;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc5121ads-cpld-pic");\r\nif (!np) {\r\nprintk(KERN_ERR "CPLD PIC init: can not find cpld-pic node\n");\r\nreturn;\r\n}\r\ncpld_regs = of_iomap(np, 0);\r\nof_node_put(np);\r\n}\r\nvoid __init\r\nmpc5121_ads_cpld_pic_init(void)\r\n{\r\nunsigned int cascade_irq;\r\nstruct device_node *np = NULL;\r\npr_debug("cpld_ic_init\n");\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc5121ads-cpld-pic");\r\nif (!np) {\r\nprintk(KERN_ERR "CPLD PIC init: can not find cpld-pic node\n");\r\nreturn;\r\n}\r\nif (!cpld_regs)\r\ngoto end;\r\ncascade_irq = irq_of_parse_and_map(np, 0);\r\nif (cascade_irq == NO_IRQ)\r\ngoto end;\r\nout_8(&cpld_regs->route, 0xfd);\r\nout_8(&cpld_regs->pci_mask, 0xff);\r\nout_8(&cpld_regs->misc_mask, ~(MISC_IGNORE));\r\ncpld_pic_node = of_node_get(np);\r\ncpld_pic_host =\r\nirq_alloc_host(np, IRQ_HOST_MAP_LINEAR, 16, &cpld_pic_host_ops, 16);\r\nif (!cpld_pic_host) {\r\nprintk(KERN_ERR "CPLD PIC: failed to allocate irq host!\n");\r\ngoto end;\r\n}\r\nirq_set_chained_handler(cascade_irq, cpld_pic_cascade);\r\nend:\r\nof_node_put(np);\r\n}
