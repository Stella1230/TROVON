static int m48t35_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct m48t35_priv *priv = dev_get_drvdata(dev);\r\nu8 control;\r\nspin_lock_irq(&priv->lock);\r\ncontrol = readb(&priv->reg->control);\r\nwriteb(control | M48T35_RTC_READ, &priv->reg->control);\r\ntm->tm_sec = readb(&priv->reg->sec);\r\ntm->tm_min = readb(&priv->reg->min);\r\ntm->tm_hour = readb(&priv->reg->hour);\r\ntm->tm_mday = readb(&priv->reg->date);\r\ntm->tm_mon = readb(&priv->reg->month);\r\ntm->tm_year = readb(&priv->reg->year);\r\nwriteb(control, &priv->reg->control);\r\nspin_unlock_irq(&priv->lock);\r\ntm->tm_sec = bcd2bin(tm->tm_sec);\r\ntm->tm_min = bcd2bin(tm->tm_min);\r\ntm->tm_hour = bcd2bin(tm->tm_hour);\r\ntm->tm_mday = bcd2bin(tm->tm_mday);\r\ntm->tm_mon = bcd2bin(tm->tm_mon);\r\ntm->tm_year = bcd2bin(tm->tm_year);\r\ntm->tm_year += 70;\r\nif (tm->tm_year <= 69)\r\ntm->tm_year += 100;\r\ntm->tm_mon--;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int m48t35_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct m48t35_priv *priv = dev_get_drvdata(dev);\r\nunsigned char mon, day, hrs, min, sec;\r\nunsigned int yrs;\r\nu8 control;\r\nyrs = tm->tm_year + 1900;\r\nmon = tm->tm_mon + 1;\r\nday = tm->tm_mday;\r\nhrs = tm->tm_hour;\r\nmin = tm->tm_min;\r\nsec = tm->tm_sec;\r\nif (yrs < 1970)\r\nreturn -EINVAL;\r\nyrs -= 1970;\r\nif (yrs > 255)\r\nreturn -EINVAL;\r\nif (yrs > 169)\r\nreturn -EINVAL;\r\nif (yrs >= 100)\r\nyrs -= 100;\r\nsec = bin2bcd(sec);\r\nmin = bin2bcd(min);\r\nhrs = bin2bcd(hrs);\r\nday = bin2bcd(day);\r\nmon = bin2bcd(mon);\r\nyrs = bin2bcd(yrs);\r\nspin_lock_irq(&priv->lock);\r\ncontrol = readb(&priv->reg->control);\r\nwriteb(control | M48T35_RTC_SET, &priv->reg->control);\r\nwriteb(yrs, &priv->reg->year);\r\nwriteb(mon, &priv->reg->month);\r\nwriteb(day, &priv->reg->date);\r\nwriteb(hrs, &priv->reg->hour);\r\nwriteb(min, &priv->reg->min);\r\nwriteb(sec, &priv->reg->sec);\r\nwriteb(control, &priv->reg->control);\r\nspin_unlock_irq(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int __devinit m48t35_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct m48t35_priv *priv;\r\nint ret = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\npriv = kzalloc(sizeof(struct m48t35_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->size = resource_size(res);\r\n#ifndef CONFIG_SGI_IP27\r\nif (!request_mem_region(res->start, priv->size, pdev->name)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n#endif\r\npriv->baseaddr = res->start;\r\npriv->reg = ioremap(priv->baseaddr, priv->size);\r\nif (!priv->reg) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nspin_lock_init(&priv->lock);\r\nplatform_set_drvdata(pdev, priv);\r\npriv->rtc = rtc_device_register("m48t35", &pdev->dev,\r\n&m48t35_ops, THIS_MODULE);\r\nif (IS_ERR(priv->rtc)) {\r\nret = PTR_ERR(priv->rtc);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nif (priv->reg)\r\niounmap(priv->reg);\r\nif (priv->baseaddr)\r\nrelease_mem_region(priv->baseaddr, priv->size);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int __devexit m48t35_remove(struct platform_device *pdev)\r\n{\r\nstruct m48t35_priv *priv = platform_get_drvdata(pdev);\r\nrtc_device_unregister(priv->rtc);\r\niounmap(priv->reg);\r\n#ifndef CONFIG_SGI_IP27\r\nrelease_mem_region(priv->baseaddr, priv->size);\r\n#endif\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init m48t35_init(void)\r\n{\r\nreturn platform_driver_register(&m48t35_platform_driver);\r\n}\r\nstatic void __exit m48t35_exit(void)\r\n{\r\nplatform_driver_unregister(&m48t35_platform_driver);\r\n}
