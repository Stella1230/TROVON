static inline void pp_enable_irq (struct pp_struct *pp)\r\n{\r\nstruct parport *port = pp->pdev->port;\r\nport->ops->enable_irq (port);\r\n}\r\nstatic ssize_t pp_read (struct file * file, char __user * buf, size_t count,\r\nloff_t * ppos)\r\n{\r\nunsigned int minor = iminor(file->f_path.dentry->d_inode);\r\nstruct pp_struct *pp = file->private_data;\r\nchar * kbuffer;\r\nssize_t bytes_read = 0;\r\nstruct parport *pport;\r\nint mode;\r\nif (!(pp->flags & PP_CLAIMED)) {\r\npr_debug(CHRDEV "%x: claim the port first\n", minor);\r\nreturn -EINVAL;\r\n}\r\nif (count == 0)\r\nreturn 0;\r\nkbuffer = kmalloc(min_t(size_t, count, PP_BUFFER_SIZE), GFP_KERNEL);\r\nif (!kbuffer) {\r\nreturn -ENOMEM;\r\n}\r\npport = pp->pdev->port;\r\nmode = pport->ieee1284.mode & ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\r\nparport_set_timeout (pp->pdev,\r\n(file->f_flags & O_NONBLOCK) ?\r\nPARPORT_INACTIVITY_O_NONBLOCK :\r\npp->default_inactivity);\r\nwhile (bytes_read == 0) {\r\nssize_t need = min_t(unsigned long, count, PP_BUFFER_SIZE);\r\nif (mode == IEEE1284_MODE_EPP) {\r\nint flags = 0;\r\nsize_t (*fn)(struct parport *, void *, size_t, int);\r\nif (pp->flags & PP_W91284PIC) {\r\nflags |= PARPORT_W91284PIC;\r\n}\r\nif (pp->flags & PP_FASTREAD) {\r\nflags |= PARPORT_EPP_FAST;\r\n}\r\nif (pport->ieee1284.mode & IEEE1284_ADDR) {\r\nfn = pport->ops->epp_read_addr;\r\n} else {\r\nfn = pport->ops->epp_read_data;\r\n}\r\nbytes_read = (*fn)(pport, kbuffer, need, flags);\r\n} else {\r\nbytes_read = parport_read (pport, kbuffer, need);\r\n}\r\nif (bytes_read != 0)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nbytes_read = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending (current)) {\r\nbytes_read = -ERESTARTSYS;\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\nparport_set_timeout (pp->pdev, pp->default_inactivity);\r\nif (bytes_read > 0 && copy_to_user (buf, kbuffer, bytes_read))\r\nbytes_read = -EFAULT;\r\nkfree (kbuffer);\r\npp_enable_irq (pp);\r\nreturn bytes_read;\r\n}\r\nstatic ssize_t pp_write (struct file * file, const char __user * buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nunsigned int minor = iminor(file->f_path.dentry->d_inode);\r\nstruct pp_struct *pp = file->private_data;\r\nchar * kbuffer;\r\nssize_t bytes_written = 0;\r\nssize_t wrote;\r\nint mode;\r\nstruct parport *pport;\r\nif (!(pp->flags & PP_CLAIMED)) {\r\npr_debug(CHRDEV "%x: claim the port first\n", minor);\r\nreturn -EINVAL;\r\n}\r\nkbuffer = kmalloc(min_t(size_t, count, PP_BUFFER_SIZE), GFP_KERNEL);\r\nif (!kbuffer) {\r\nreturn -ENOMEM;\r\n}\r\npport = pp->pdev->port;\r\nmode = pport->ieee1284.mode & ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\r\nparport_set_timeout (pp->pdev,\r\n(file->f_flags & O_NONBLOCK) ?\r\nPARPORT_INACTIVITY_O_NONBLOCK :\r\npp->default_inactivity);\r\nwhile (bytes_written < count) {\r\nssize_t n = min_t(unsigned long, count - bytes_written, PP_BUFFER_SIZE);\r\nif (copy_from_user (kbuffer, buf + bytes_written, n)) {\r\nbytes_written = -EFAULT;\r\nbreak;\r\n}\r\nif ((pp->flags & PP_FASTWRITE) && (mode == IEEE1284_MODE_EPP)) {\r\nif (pport->ieee1284.mode & IEEE1284_ADDR) {\r\nwrote = pport->ops->epp_write_addr (pport,\r\nkbuffer, n, PARPORT_EPP_FAST);\r\n} else {\r\nwrote = pport->ops->epp_write_data (pport,\r\nkbuffer, n, PARPORT_EPP_FAST);\r\n}\r\n} else {\r\nwrote = parport_write (pp->pdev->port, kbuffer, n);\r\n}\r\nif (wrote <= 0) {\r\nif (!bytes_written) {\r\nbytes_written = wrote;\r\n}\r\nbreak;\r\n}\r\nbytes_written += wrote;\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!bytes_written)\r\nbytes_written = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending (current)) {\r\nif (!bytes_written) {\r\nbytes_written = -EINTR;\r\n}\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\nparport_set_timeout (pp->pdev, pp->default_inactivity);\r\nkfree (kbuffer);\r\npp_enable_irq (pp);\r\nreturn bytes_written;\r\n}\r\nstatic void pp_irq (void *private)\r\n{\r\nstruct pp_struct *pp = private;\r\nif (pp->irqresponse) {\r\nparport_write_control (pp->pdev->port, pp->irqctl);\r\npp->irqresponse = 0;\r\n}\r\natomic_inc (&pp->irqc);\r\nwake_up_interruptible (&pp->irq_wait);\r\n}\r\nstatic int register_device (int minor, struct pp_struct *pp)\r\n{\r\nstruct parport *port;\r\nstruct pardevice * pdev = NULL;\r\nchar *name;\r\nint fl;\r\nname = kasprintf(GFP_KERNEL, CHRDEV "%x", minor);\r\nif (name == NULL)\r\nreturn -ENOMEM;\r\nport = parport_find_number (minor);\r\nif (!port) {\r\nprintk (KERN_WARNING "%s: no associated port!\n", name);\r\nkfree (name);\r\nreturn -ENXIO;\r\n}\r\nfl = (pp->flags & PP_EXCL) ? PARPORT_FLAG_EXCL : 0;\r\npdev = parport_register_device (port, name, NULL,\r\nNULL, pp_irq, fl, pp);\r\nparport_put_port (port);\r\nif (!pdev) {\r\nprintk (KERN_WARNING "%s: failed to register device!\n", name);\r\nkfree (name);\r\nreturn -ENXIO;\r\n}\r\npp->pdev = pdev;\r\npr_debug("%s: registered pardevice\n", name);\r\nreturn 0;\r\n}\r\nstatic enum ieee1284_phase init_phase (int mode)\r\n{\r\nswitch (mode & ~(IEEE1284_DEVICEID\r\n| IEEE1284_ADDR)) {\r\ncase IEEE1284_MODE_NIBBLE:\r\ncase IEEE1284_MODE_BYTE:\r\nreturn IEEE1284_PH_REV_IDLE;\r\n}\r\nreturn IEEE1284_PH_FWD_IDLE;\r\n}\r\nstatic int pp_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned int minor = iminor(file->f_path.dentry->d_inode);\r\nstruct pp_struct *pp = file->private_data;\r\nstruct parport * port;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase PPCLAIM:\r\n{\r\nstruct ieee1284_info *info;\r\nint ret;\r\nif (pp->flags & PP_CLAIMED) {\r\npr_debug(CHRDEV "%x: you've already got it!\n", minor);\r\nreturn -EINVAL;\r\n}\r\nif (!pp->pdev) {\r\nint err = register_device (minor, pp);\r\nif (err) {\r\nreturn err;\r\n}\r\n}\r\nret = parport_claim_or_block (pp->pdev);\r\nif (ret < 0)\r\nreturn ret;\r\npp->flags |= PP_CLAIMED;\r\npp_enable_irq (pp);\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->saved_state.mode = info->mode;\r\npp->saved_state.phase = info->phase;\r\ninfo->mode = pp->state.mode;\r\ninfo->phase = pp->state.phase;\r\npp->default_inactivity = parport_set_timeout (pp->pdev, 0);\r\nparport_set_timeout (pp->pdev, pp->default_inactivity);\r\nreturn 0;\r\n}\r\ncase PPEXCL:\r\nif (pp->pdev) {\r\npr_debug(CHRDEV "%x: too late for PPEXCL; "\r\n"already registered\n", minor);\r\nif (pp->flags & PP_EXCL)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\npp->flags |= PP_EXCL;\r\nreturn 0;\r\ncase PPSETMODE:\r\n{\r\nint mode;\r\nif (copy_from_user (&mode, argp, sizeof (mode)))\r\nreturn -EFAULT;\r\npp->state.mode = mode;\r\npp->state.phase = init_phase (mode);\r\nif (pp->flags & PP_CLAIMED) {\r\npp->pdev->port->ieee1284.mode = mode;\r\npp->pdev->port->ieee1284.phase = pp->state.phase;\r\n}\r\nreturn 0;\r\n}\r\ncase PPGETMODE:\r\n{\r\nint mode;\r\nif (pp->flags & PP_CLAIMED) {\r\nmode = pp->pdev->port->ieee1284.mode;\r\n} else {\r\nmode = pp->state.mode;\r\n}\r\nif (copy_to_user (argp, &mode, sizeof (mode))) {\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\ncase PPSETPHASE:\r\n{\r\nint phase;\r\nif (copy_from_user (&phase, argp, sizeof (phase))) {\r\nreturn -EFAULT;\r\n}\r\npp->state.phase = phase;\r\nif (pp->flags & PP_CLAIMED) {\r\npp->pdev->port->ieee1284.phase = phase;\r\n}\r\nreturn 0;\r\n}\r\ncase PPGETPHASE:\r\n{\r\nint phase;\r\nif (pp->flags & PP_CLAIMED) {\r\nphase = pp->pdev->port->ieee1284.phase;\r\n} else {\r\nphase = pp->state.phase;\r\n}\r\nif (copy_to_user (argp, &phase, sizeof (phase))) {\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\ncase PPGETMODES:\r\n{\r\nunsigned int modes;\r\nport = parport_find_number (minor);\r\nif (!port)\r\nreturn -ENODEV;\r\nmodes = port->modes;\r\nparport_put_port(port);\r\nif (copy_to_user (argp, &modes, sizeof (modes))) {\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\ncase PPSETFLAGS:\r\n{\r\nint uflags;\r\nif (copy_from_user (&uflags, argp, sizeof (uflags))) {\r\nreturn -EFAULT;\r\n}\r\npp->flags &= ~PP_FLAGMASK;\r\npp->flags |= (uflags & PP_FLAGMASK);\r\nreturn 0;\r\n}\r\ncase PPGETFLAGS:\r\n{\r\nint uflags;\r\nuflags = pp->flags & PP_FLAGMASK;\r\nif (copy_to_user (argp, &uflags, sizeof (uflags))) {\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nif ((pp->flags & PP_CLAIMED) == 0) {\r\npr_debug(CHRDEV "%x: claim the port first\n", minor);\r\nreturn -EINVAL;\r\n}\r\nport = pp->pdev->port;\r\nswitch (cmd) {\r\nstruct ieee1284_info *info;\r\nunsigned char reg;\r\nunsigned char mask;\r\nint mode;\r\nint ret;\r\nstruct timeval par_timeout;\r\nlong to_jiffies;\r\ncase PPRSTATUS:\r\nreg = parport_read_status (port);\r\nif (copy_to_user (argp, &reg, sizeof (reg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase PPRDATA:\r\nreg = parport_read_data (port);\r\nif (copy_to_user (argp, &reg, sizeof (reg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase PPRCONTROL:\r\nreg = parport_read_control (port);\r\nif (copy_to_user (argp, &reg, sizeof (reg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase PPYIELD:\r\nparport_yield_blocking (pp->pdev);\r\nreturn 0;\r\ncase PPRELEASE:\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->state.mode = info->mode;\r\npp->state.phase = info->phase;\r\ninfo->mode = pp->saved_state.mode;\r\ninfo->phase = pp->saved_state.phase;\r\nparport_release (pp->pdev);\r\npp->flags &= ~PP_CLAIMED;\r\nreturn 0;\r\ncase PPWCONTROL:\r\nif (copy_from_user (&reg, argp, sizeof (reg)))\r\nreturn -EFAULT;\r\nparport_write_control (port, reg);\r\nreturn 0;\r\ncase PPWDATA:\r\nif (copy_from_user (&reg, argp, sizeof (reg)))\r\nreturn -EFAULT;\r\nparport_write_data (port, reg);\r\nreturn 0;\r\ncase PPFCONTROL:\r\nif (copy_from_user (&mask, argp,\r\nsizeof (mask)))\r\nreturn -EFAULT;\r\nif (copy_from_user (&reg, 1 + (unsigned char __user *) arg,\r\nsizeof (reg)))\r\nreturn -EFAULT;\r\nparport_frob_control (port, mask, reg);\r\nreturn 0;\r\ncase PPDATADIR:\r\nif (copy_from_user (&mode, argp, sizeof (mode)))\r\nreturn -EFAULT;\r\nif (mode)\r\nport->ops->data_reverse (port);\r\nelse\r\nport->ops->data_forward (port);\r\nreturn 0;\r\ncase PPNEGOT:\r\nif (copy_from_user (&mode, argp, sizeof (mode)))\r\nreturn -EFAULT;\r\nswitch ((ret = parport_negotiate (port, mode))) {\r\ncase 0: break;\r\ncase -1:\r\nret = -EIO;\r\nbreak;\r\ncase 1:\r\nret = -ENXIO;\r\nbreak;\r\n}\r\npp_enable_irq (pp);\r\nreturn ret;\r\ncase PPWCTLONIRQ:\r\nif (copy_from_user (&reg, argp, sizeof (reg)))\r\nreturn -EFAULT;\r\npp->irqctl = reg;\r\npp->irqresponse = 1;\r\nreturn 0;\r\ncase PPCLRIRQ:\r\nret = atomic_read (&pp->irqc);\r\nif (copy_to_user (argp, &ret, sizeof (ret)))\r\nreturn -EFAULT;\r\natomic_sub (ret, &pp->irqc);\r\nreturn 0;\r\ncase PPSETTIME:\r\nif (copy_from_user (&par_timeout, argp, sizeof(struct timeval))) {\r\nreturn -EFAULT;\r\n}\r\nif ((par_timeout.tv_sec < 0) || (par_timeout.tv_usec < 0)) {\r\nreturn -EINVAL;\r\n}\r\nto_jiffies = ROUND_UP(par_timeout.tv_usec, 1000000/HZ);\r\nto_jiffies += par_timeout.tv_sec * (long)HZ;\r\nif (to_jiffies <= 0) {\r\nreturn -EINVAL;\r\n}\r\npp->pdev->timeout = to_jiffies;\r\nreturn 0;\r\ncase PPGETTIME:\r\nto_jiffies = pp->pdev->timeout;\r\nmemset(&par_timeout, 0, sizeof(par_timeout));\r\npar_timeout.tv_sec = to_jiffies / HZ;\r\npar_timeout.tv_usec = (to_jiffies % (long)HZ) * (1000000/HZ);\r\nif (copy_to_user (argp, &par_timeout, sizeof(struct timeval)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\npr_debug(CHRDEV "%x: What? (cmd=0x%x)\n", minor, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic long pp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nmutex_lock(&pp_do_mutex);\r\nret = pp_do_ioctl(file, cmd, arg);\r\nmutex_unlock(&pp_do_mutex);\r\nreturn ret;\r\n}\r\nstatic int pp_open (struct inode * inode, struct file * file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct pp_struct *pp;\r\nif (minor >= PARPORT_MAX)\r\nreturn -ENXIO;\r\npp = kmalloc (sizeof (struct pp_struct), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\npp->state.mode = IEEE1284_MODE_COMPAT;\r\npp->state.phase = init_phase (pp->state.mode);\r\npp->flags = 0;\r\npp->irqresponse = 0;\r\natomic_set (&pp->irqc, 0);\r\ninit_waitqueue_head (&pp->irq_wait);\r\npp->pdev = NULL;\r\nfile->private_data = pp;\r\nreturn 0;\r\n}\r\nstatic int pp_release (struct inode * inode, struct file * file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct pp_struct *pp = file->private_data;\r\nint compat_negot;\r\ncompat_negot = 0;\r\nif (!(pp->flags & PP_CLAIMED) && pp->pdev &&\r\n(pp->state.mode != IEEE1284_MODE_COMPAT)) {\r\nstruct ieee1284_info *info;\r\nparport_claim_or_block (pp->pdev);\r\npp->flags |= PP_CLAIMED;\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->saved_state.mode = info->mode;\r\npp->saved_state.phase = info->phase;\r\ninfo->mode = pp->state.mode;\r\ninfo->phase = pp->state.phase;\r\ncompat_negot = 1;\r\n} else if ((pp->flags & PP_CLAIMED) && pp->pdev &&\r\n(pp->pdev->port->ieee1284.mode != IEEE1284_MODE_COMPAT)) {\r\ncompat_negot = 2;\r\n}\r\nif (compat_negot) {\r\nparport_negotiate (pp->pdev->port, IEEE1284_MODE_COMPAT);\r\npr_debug(CHRDEV "%x: negotiated back to compatibility "\r\n"mode because user-space forgot\n", minor);\r\n}\r\nif (pp->flags & PP_CLAIMED) {\r\nstruct ieee1284_info *info;\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->state.mode = info->mode;\r\npp->state.phase = info->phase;\r\ninfo->mode = pp->saved_state.mode;\r\ninfo->phase = pp->saved_state.phase;\r\nparport_release (pp->pdev);\r\nif (compat_negot != 1) {\r\npr_debug(CHRDEV "%x: released pardevice "\r\n"because user-space forgot\n", minor);\r\n}\r\n}\r\nif (pp->pdev) {\r\nconst char *name = pp->pdev->name;\r\nparport_unregister_device (pp->pdev);\r\nkfree (name);\r\npp->pdev = NULL;\r\npr_debug(CHRDEV "%x: unregistered pardevice\n", minor);\r\n}\r\nkfree (pp);\r\nreturn 0;\r\n}\r\nstatic unsigned int pp_poll (struct file * file, poll_table * wait)\r\n{\r\nstruct pp_struct *pp = file->private_data;\r\nunsigned int mask = 0;\r\npoll_wait (file, &pp->irq_wait, wait);\r\nif (atomic_read (&pp->irqc))\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic void pp_attach(struct parport *port)\r\n{\r\ndevice_create(ppdev_class, port->dev, MKDEV(PP_MAJOR, port->number),\r\nNULL, "parport%d", port->number);\r\n}\r\nstatic void pp_detach(struct parport *port)\r\n{\r\ndevice_destroy(ppdev_class, MKDEV(PP_MAJOR, port->number));\r\n}\r\nstatic int __init ppdev_init (void)\r\n{\r\nint err = 0;\r\nif (register_chrdev (PP_MAJOR, CHRDEV, &pp_fops)) {\r\nprintk (KERN_WARNING CHRDEV ": unable to get major %d\n",\r\nPP_MAJOR);\r\nreturn -EIO;\r\n}\r\nppdev_class = class_create(THIS_MODULE, CHRDEV);\r\nif (IS_ERR(ppdev_class)) {\r\nerr = PTR_ERR(ppdev_class);\r\ngoto out_chrdev;\r\n}\r\nif (parport_register_driver(&pp_driver)) {\r\nprintk (KERN_WARNING CHRDEV ": unable to register with parport\n");\r\ngoto out_class;\r\n}\r\nprintk (KERN_INFO PP_VERSION "\n");\r\ngoto out;\r\nout_class:\r\nclass_destroy(ppdev_class);\r\nout_chrdev:\r\nunregister_chrdev(PP_MAJOR, CHRDEV);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit ppdev_cleanup (void)\r\n{\r\nparport_unregister_driver(&pp_driver);\r\nclass_destroy(ppdev_class);\r\nunregister_chrdev (PP_MAJOR, CHRDEV);\r\n}
