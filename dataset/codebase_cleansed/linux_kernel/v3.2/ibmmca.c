static irqreturn_t interrupt_handler(int irq, void *dev_id)\r\n{\r\nunsigned int intr_reg;\r\nunsigned int cmd_result;\r\nunsigned int ldn;\r\nunsigned long flags;\r\nScsi_Cmnd *cmd;\r\nint lastSCSI;\r\nstruct device *dev = dev_id;\r\nstruct Scsi_Host *shpnt = dev_get_drvdata(dev);\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nif(!(inb(IM_STAT_REG(shpnt)) & IM_INTR_REQUEST)) {\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif ((reset_status(shpnt) == IM_RESET_NOT_IN_PROGRESS_NO_INT) || (reset_status(shpnt) == IM_RESET_FINISHED_OK_NO_INT)) {\r\nreset_status(shpnt) = IM_RESET_NOT_IN_PROGRESS;\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nwhile (1) {\r\nif (!(inb(IM_STAT_REG(shpnt)) & IM_BUSY))\r\nbreak;\r\ncpu_relax();\r\n}\r\nintr_reg = (unsigned char) (inb(IM_INTR_REG(shpnt)));\r\ncmd_result = intr_reg & 0xf0;\r\nldn = intr_reg & 0x0f;\r\nlastSCSI = last_scsi_command(shpnt)[ldn];\r\noutb(IM_EOI | ldn, IM_ATTN_REG(shpnt));\r\nif (!global_command_error_excuse) {\r\nswitch (cmd_result) {\r\ncase IM_ADAPTER_HW_FAILURE:\r\ncase IM_SOFTWARE_SEQUENCING_ERROR:\r\ncase IM_CMD_ERROR:\r\nprintk(KERN_ERR "IBM MCA SCSI: Fatal Subsystem ERROR!\n");\r\nprintk(KERN_ERR " Last cmd=0x%x, ena=%x, len=", lastSCSI, ld(shpnt)[ldn].scb.enable);\r\nif (ld(shpnt)[ldn].cmd)\r\nprintk("%ld/%ld,", (long) (scsi_bufflen(ld(shpnt)[ldn].cmd)), (long) (ld(shpnt)[ldn].scb.sys_buf_length));\r\nelse\r\nprintk("none,");\r\nif (ld(shpnt)[ldn].cmd)\r\nprintk("Blocksize=%d", ld(shpnt)[ldn].scb.u2.blk.length);\r\nelse\r\nprintk("Blocksize=none");\r\nprintk(", host=%p, ldn=0x%x\n", shpnt, ldn);\r\nif (ld(shpnt)[ldn].cmd) {\r\nprintk(KERN_ERR "Blockcount=%d/%d\n", last_scsi_blockcount(shpnt)[ldn], ld(shpnt)[ldn].scb.u2.blk.count);\r\nprintk(KERN_ERR "Logical block=%lx/%lx\n", last_scsi_logical_block(shpnt)[ldn], ld(shpnt)[ldn].scb.u1.log_blk_adr);\r\n}\r\nprintk(KERN_ERR "Reason given: %s\n", (cmd_result == IM_ADAPTER_HW_FAILURE) ? "HARDWARE FAILURE" : (cmd_result == IM_SOFTWARE_SEQUENCING_ERROR) ? "SOFTWARE SEQUENCING ERROR" : (cmd_result == IM_CMD_ERROR) ? "COMMAND ERROR" : "UNKNOWN");\r\nprintk(KERN_ERR "IBM MCA SCSI: Subsystem Error-Status follows:\n");\r\nprintk(KERN_ERR " Command Type................: %x\n", last_scsi_type(shpnt)[ldn]);\r\nprintk(KERN_ERR " Attention Register..........: %x\n", inb(IM_ATTN_REG(shpnt)));\r\nprintk(KERN_ERR " Basic Control Register......: %x\n", inb(IM_CTR_REG(shpnt)));\r\nprintk(KERN_ERR " Interrupt Status Register...: %x\n", intr_reg);\r\nprintk(KERN_ERR " Basic Status Register.......: %x\n", inb(IM_STAT_REG(shpnt)));\r\nif ((last_scsi_type(shpnt)[ldn] == IM_SCB) || (last_scsi_type(shpnt)[ldn] == IM_LONG_SCB)) {\r\nprintk(KERN_ERR " SCB-Command.................: %x\n", ld(shpnt)[ldn].scb.command);\r\nprintk(KERN_ERR " SCB-Enable..................: %x\n", ld(shpnt)[ldn].scb.enable);\r\nprintk(KERN_ERR " SCB-logical block address...: %lx\n", ld(shpnt)[ldn].scb.u1.log_blk_adr);\r\nprintk(KERN_ERR " SCB-system buffer address...: %lx\n", ld(shpnt)[ldn].scb.sys_buf_adr);\r\nprintk(KERN_ERR " SCB-system buffer length....: %lx\n", ld(shpnt)[ldn].scb.sys_buf_length);\r\nprintk(KERN_ERR " SCB-tsb address.............: %lx\n", ld(shpnt)[ldn].scb.tsb_adr);\r\nprintk(KERN_ERR " SCB-Chain address...........: %lx\n", ld(shpnt)[ldn].scb.scb_chain_adr);\r\nprintk(KERN_ERR " SCB-block count.............: %x\n", ld(shpnt)[ldn].scb.u2.blk.count);\r\nprintk(KERN_ERR " SCB-block length............: %x\n", ld(shpnt)[ldn].scb.u2.blk.length);\r\n}\r\nprintk(KERN_ERR " Send this report to the maintainer.\n");\r\npanic("IBM MCA SCSI: Fatal error message from the subsystem (0x%X,0x%X)!\n", lastSCSI, cmd_result);\r\nbreak;\r\n}\r\n} else {\r\nswitch (cmd_result) {\r\ncase IM_ADAPTER_HW_FAILURE:\r\ncase IM_SOFTWARE_SEQUENCING_ERROR:\r\ncase IM_CMD_ERROR:\r\nglobal_command_error_excuse = CMD_FAIL;\r\nbreak;\r\ndefault:\r\nglobal_command_error_excuse = 0;\r\nbreak;\r\n}\r\n}\r\nIBM_DS(shpnt).total_interrupts++;\r\nif (local_checking_phase_flag(shpnt)) {\r\nstat_result(shpnt) = cmd_result;\r\ngot_interrupt(shpnt) = 1;\r\nreset_status(shpnt) = IM_RESET_FINISHED_OK;\r\nlast_scsi_command(shpnt)[ldn] = NO_SCSI;\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (last_scsi_type(shpnt)[ldn] == IM_IMM_CMD) {\r\nif ((reset_status(shpnt) == IM_RESET_IN_PROGRESS) && (last_scsi_command(shpnt)[ldn] == IM_RESET_IMM_CMD)) {\r\nif (cmd_result == IM_CMD_COMPLETED_WITH_FAILURE) {\r\ndisk_rw_in_progress = 0;\r\nPS2_DISK_LED_OFF();\r\nreset_status(shpnt) = IM_RESET_FINISHED_FAIL;\r\n} else {\r\ndisk_rw_in_progress = 0;\r\nPS2_DISK_LED_OFF();\r\nreset_status(shpnt) = IM_RESET_FINISHED_OK;\r\n}\r\nstat_result(shpnt) = cmd_result;\r\nlast_scsi_command(shpnt)[ldn] = NO_SCSI;\r\nlast_scsi_type(shpnt)[ldn] = 0;\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n} else if (last_scsi_command(shpnt)[ldn] == IM_ABORT_IMM_CMD) {\r\n#ifdef IM_DEBUG_PROBE\r\nprintk("IBM MCA SCSI: Interrupt from SCSI-abort.\n");\r\n#endif\r\ndisk_rw_in_progress = 0;\r\nPS2_DISK_LED_OFF();\r\ncmd = ld(shpnt)[ldn].cmd;\r\nld(shpnt)[ldn].cmd = NULL;\r\nif (cmd_result == IM_CMD_COMPLETED_WITH_FAILURE)\r\ncmd->result = DID_NO_CONNECT << 16;\r\nelse\r\ncmd->result = DID_ABORT << 16;\r\nstat_result(shpnt) = cmd_result;\r\nlast_scsi_command(shpnt)[ldn] = NO_SCSI;\r\nlast_scsi_type(shpnt)[ldn] = 0;\r\nif (cmd->scsi_done)\r\n(cmd->scsi_done) (cmd);\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n} else {\r\ndisk_rw_in_progress = 0;\r\nPS2_DISK_LED_OFF();\r\nreset_status(shpnt) = IM_RESET_FINISHED_OK;\r\nstat_result(shpnt) = cmd_result;\r\nlast_scsi_command(shpnt)[ldn] = NO_SCSI;\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nlast_scsi_command(shpnt)[ldn] = NO_SCSI;\r\nlast_scsi_type(shpnt)[ldn] = 0;\r\ncmd = ld(shpnt)[ldn].cmd;\r\nld(shpnt)[ldn].cmd = NULL;\r\n#ifdef IM_DEBUG_TIMEOUT\r\nif (cmd) {\r\nif ((cmd->target == TIMEOUT_PUN) && (cmd->device->lun == TIMEOUT_LUN)) {\r\nspin_unlock_irqsave(shpnt->host_lock, flags);\r\nprintk("IBM MCA SCSI: Ignoring interrupt from pun=%x, lun=%x.\n", cmd->target, cmd->device->lun);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\n#endif\r\nif (!cmd)\r\n{\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\n#ifdef IM_DEBUG_INT\r\nprintk("cmd=%02x ireg=%02x ds=%02x cs=%02x de=%02x ce=%02x\n", cmd->cmnd[0], intr_reg, ld(shpnt)[ldn].tsb.dev_status, ld(shpnt)[ldn].tsb.cmd_status, ld(shpnt)[ldn].tsb.dev_error, ld(shpnt)[ldn].tsb.cmd_error);\r\n#endif\r\nif ((ld(shpnt)[ldn].device_type != TYPE_NO_LUN) && (ld(shpnt)[ldn].device_type != TYPE_NO_DEVICE)) {\r\nif (--disk_rw_in_progress == 0)\r\nPS2_DISK_LED_OFF();\r\n}\r\nif (cmd_result == IM_CMD_COMPLETED_WITH_FAILURE) {\r\ncmd->result = (unsigned char) (ld(shpnt)[ldn].tsb.dev_status & 0x1e);\r\nIBM_DS(shpnt).total_errors++;\r\n} else\r\ncmd->result = 0;\r\nif (lastSCSI == NO_SCSI) {\r\ncmd->result |= DID_BAD_INTR << 16;\r\nprintk("IBM MCA SCSI: WARNING - Interrupt from non-pending SCSI-command!\n");\r\n} else\r\ncmd->result |= DID_OK << 16;\r\nif (cmd->scsi_done)\r\n(cmd->scsi_done) (cmd);\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void issue_cmd(struct Scsi_Host *shpnt, unsigned long cmd_reg,\r\nunsigned char attn_reg)\r\n{\r\nunsigned long flags;\r\nwhile (1) {\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nif (!(inb(IM_STAT_REG(shpnt)) & IM_BUSY))\r\nbreak;\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\n}\r\noutl(cmd_reg, IM_CMD_REG(shpnt));\r\noutb(attn_reg, IM_ATTN_REG(shpnt));\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\n}\r\nstatic void internal_done(Scsi_Cmnd * cmd)\r\n{\r\ncmd->SCp.Status++;\r\nreturn;\r\n}\r\nstatic int device_inquiry(struct Scsi_Host *shpnt, int ldn)\r\n{\r\nint retr;\r\nstruct im_scb *scb;\r\nstruct im_tsb *tsb;\r\nunsigned char *buf;\r\nscb = &(ld(shpnt)[ldn].scb);\r\ntsb = &(ld(shpnt)[ldn].tsb);\r\nbuf = (unsigned char *) (&(ld(shpnt)[ldn].buf));\r\nld(shpnt)[ldn].tsb.dev_status = 0;\r\nfor (retr = 0; retr < 3; retr++) {\r\nscb->command = IM_DEVICE_INQUIRY_CMD | IM_NO_DISCONNECT;\r\nscb->enable = IM_REPORT_TSB_ONLY_ON_ERROR | IM_READ_CONTROL | IM_SUPRESS_EXCEPTION_SHORT | IM_RETRY_ENABLE | IM_BYPASS_BUFFER;\r\nlast_scsi_command(shpnt)[ldn] = IM_DEVICE_INQUIRY_CMD;\r\nlast_scsi_type(shpnt)[ldn] = IM_SCB;\r\nscb->sys_buf_adr = isa_virt_to_bus(buf);\r\nscb->sys_buf_length = 255;\r\nscb->tsb_adr = isa_virt_to_bus(tsb);\r\ngot_interrupt(shpnt) = 0;\r\nissue_cmd(shpnt, isa_virt_to_bus(scb), IM_SCB | ldn);\r\nwhile (!got_interrupt(shpnt))\r\nbarrier();\r\nif ((stat_result(shpnt) == IM_SCB_CMD_COMPLETED) || (stat_result(shpnt) == IM_SCB_CMD_COMPLETED_WITH_RETRIES))\r\nreturn 1;\r\n}\r\nif (retr >= 3)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int read_capacity(struct Scsi_Host *shpnt, int ldn)\r\n{\r\nint retr;\r\nstruct im_scb *scb;\r\nstruct im_tsb *tsb;\r\nunsigned char *buf;\r\nscb = &(ld(shpnt)[ldn].scb);\r\ntsb = &(ld(shpnt)[ldn].tsb);\r\nbuf = (unsigned char *) (&(ld(shpnt)[ldn].buf));\r\nld(shpnt)[ldn].tsb.dev_status = 0;\r\nfor (retr = 0; retr < 3; retr++) {\r\nscb->command = IM_READ_CAPACITY_CMD;\r\nscb->enable = IM_REPORT_TSB_ONLY_ON_ERROR | IM_READ_CONTROL | IM_RETRY_ENABLE | IM_BYPASS_BUFFER;\r\nlast_scsi_command(shpnt)[ldn] = IM_READ_CAPACITY_CMD;\r\nlast_scsi_type(shpnt)[ldn] = IM_SCB;\r\nscb->sys_buf_adr = isa_virt_to_bus(buf);\r\nscb->sys_buf_length = 8;\r\nscb->tsb_adr = isa_virt_to_bus(tsb);\r\ngot_interrupt(shpnt) = 0;\r\nissue_cmd(shpnt, isa_virt_to_bus(scb), IM_SCB | ldn);\r\nwhile (!got_interrupt(shpnt))\r\nbarrier();\r\nif ((stat_result(shpnt) == IM_SCB_CMD_COMPLETED) || (stat_result(shpnt) == IM_SCB_CMD_COMPLETED_WITH_RETRIES))\r\nreturn 1;\r\n}\r\nif (retr >= 3)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int get_pos_info(struct Scsi_Host *shpnt)\r\n{\r\nint retr;\r\nstruct im_scb *scb;\r\nstruct im_tsb *tsb;\r\nunsigned char *buf;\r\nscb = &(ld(shpnt)[MAX_LOG_DEV].scb);\r\ntsb = &(ld(shpnt)[MAX_LOG_DEV].tsb);\r\nbuf = (unsigned char *) (&(ld(shpnt)[MAX_LOG_DEV].buf));\r\nld(shpnt)[MAX_LOG_DEV].tsb.dev_status = 0;\r\nfor (retr = 0; retr < 3; retr++) {\r\nscb->command = IM_GET_POS_INFO_CMD;\r\nscb->enable = IM_READ_CONTROL | IM_REPORT_TSB_ONLY_ON_ERROR | IM_RETRY_ENABLE | IM_BYPASS_BUFFER;\r\nlast_scsi_command(shpnt)[MAX_LOG_DEV] = IM_GET_POS_INFO_CMD;\r\nlast_scsi_type(shpnt)[MAX_LOG_DEV] = IM_SCB;\r\nscb->sys_buf_adr = isa_virt_to_bus(buf);\r\nif (special(shpnt) == IBM_SCSI2_FW)\r\nscb->sys_buf_length = 256;\r\nelse\r\nscb->sys_buf_length = 18;\r\nscb->tsb_adr = isa_virt_to_bus(tsb);\r\ngot_interrupt(shpnt) = 0;\r\nissue_cmd(shpnt, isa_virt_to_bus(scb), IM_SCB | MAX_LOG_DEV);\r\nwhile (!got_interrupt(shpnt))\r\nbarrier();\r\nif ((stat_result(shpnt) == IM_SCB_CMD_COMPLETED) || (stat_result(shpnt) == IM_SCB_CMD_COMPLETED_WITH_RETRIES))\r\nreturn 1;\r\n}\r\nif (retr >= 3)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int immediate_assign(struct Scsi_Host *shpnt, unsigned int pun,\r\nunsigned int lun, unsigned int ldn,\r\nunsigned int operation)\r\n{\r\nint retr;\r\nunsigned long imm_cmd;\r\nfor (retr = 0; retr < 3; retr++) {\r\nswitch (special(shpnt)) {\r\ncase IBM_SCSI2_FW:\r\nimm_cmd = (unsigned long) (IM_ASSIGN_IMM_CMD);\r\nimm_cmd |= (unsigned long) ((lun & 7) << 24);\r\nimm_cmd |= (unsigned long) ((operation & 1) << 23);\r\nimm_cmd |= (unsigned long) ((pun & 7) << 20) | ((pun & 8) << 24);\r\nimm_cmd |= (unsigned long) ((ldn & 15) << 16);\r\nbreak;\r\ndefault:\r\nimm_cmd = inl(IM_CMD_REG(shpnt));\r\nimm_cmd &= (unsigned long) (0xF8000000);\r\nimm_cmd |= (unsigned long) (IM_ASSIGN_IMM_CMD);\r\nimm_cmd |= (unsigned long) ((lun & 7) << 24);\r\nimm_cmd |= (unsigned long) ((operation & 1) << 23);\r\nimm_cmd |= (unsigned long) ((pun & 7) << 20);\r\nimm_cmd |= (unsigned long) ((ldn & 15) << 16);\r\nbreak;\r\n}\r\nlast_scsi_command(shpnt)[MAX_LOG_DEV] = IM_ASSIGN_IMM_CMD;\r\nlast_scsi_type(shpnt)[MAX_LOG_DEV] = IM_IMM_CMD;\r\ngot_interrupt(shpnt) = 0;\r\nissue_cmd(shpnt, (unsigned long) (imm_cmd), IM_IMM_CMD | MAX_LOG_DEV);\r\nwhile (!got_interrupt(shpnt))\r\nbarrier();\r\nif (stat_result(shpnt) == IM_IMMEDIATE_CMD_COMPLETED)\r\nreturn 1;\r\n}\r\nif (retr >= 3)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int immediate_feature(struct Scsi_Host *shpnt, unsigned int speed, unsigned int timeout)\r\n{\r\nint retr;\r\nunsigned long imm_cmd;\r\nfor (retr = 0; retr < 3; retr++) {\r\nimm_cmd = IM_FEATURE_CTR_IMM_CMD;\r\nimm_cmd |= (unsigned long) ((speed & 0x7) << 29);\r\nimm_cmd |= (unsigned long) ((timeout & 0x1fff) << 16);\r\nlast_scsi_command(shpnt)[MAX_LOG_DEV] = IM_FEATURE_CTR_IMM_CMD;\r\nlast_scsi_type(shpnt)[MAX_LOG_DEV] = IM_IMM_CMD;\r\ngot_interrupt(shpnt) = 0;\r\nglobal_command_error_excuse = 1;\r\nissue_cmd(shpnt, (unsigned long) (imm_cmd), IM_IMM_CMD | MAX_LOG_DEV);\r\nwhile (!got_interrupt(shpnt))\r\nbarrier();\r\nif (global_command_error_excuse == CMD_FAIL) {\r\nglobal_command_error_excuse = 0;\r\nreturn 2;\r\n} else\r\nglobal_command_error_excuse = 0;\r\nif (stat_result(shpnt) == IM_IMMEDIATE_CMD_COMPLETED)\r\nreturn 1;\r\n}\r\nif (retr >= 3)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int immediate_reset(struct Scsi_Host *shpnt, unsigned int ldn)\r\n{\r\nint retries;\r\nint ticks;\r\nunsigned long imm_command;\r\nfor (retries = 0; retries < 3; retries++) {\r\nimm_command = inl(IM_CMD_REG(shpnt));\r\nimm_command &= (unsigned long) (0xFFFF0000);\r\nimm_command |= (unsigned long) (IM_RESET_IMM_CMD);\r\nlast_scsi_command(shpnt)[ldn] = IM_RESET_IMM_CMD;\r\nlast_scsi_type(shpnt)[ldn] = IM_IMM_CMD;\r\ngot_interrupt(shpnt) = 0;\r\nreset_status(shpnt) = IM_RESET_IN_PROGRESS;\r\nissue_cmd(shpnt, (unsigned long) (imm_command), IM_IMM_CMD | ldn);\r\nticks = IM_RESET_DELAY * HZ;\r\nwhile (reset_status(shpnt) == IM_RESET_IN_PROGRESS && --ticks) {\r\nudelay((1 + 999 / HZ) * 1000);\r\nbarrier();\r\n}\r\nif (!ticks) {\r\nprintk(KERN_ERR "IBM MCA SCSI: reset did not complete within %d seconds.\n", IM_RESET_DELAY);\r\nreset_status(shpnt) = IM_RESET_FINISHED_OK;\r\nreturn 1;\r\n}\r\nif (stat_result(shpnt) == IM_IMMEDIATE_CMD_COMPLETED)\r\nreturn 1;\r\n}\r\nif (retries >= 3)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic char *ti_p(int dev)\r\n{\r\nswitch (dev) {\r\ncase TYPE_IBM_SCSI_ADAPTER:\r\nreturn ("A");\r\ncase TYPE_DISK:\r\nreturn ("D");\r\ncase TYPE_TAPE:\r\nreturn ("T");\r\ncase TYPE_PROCESSOR:\r\nreturn ("P");\r\ncase TYPE_WORM:\r\nreturn ("W");\r\ncase TYPE_ROM:\r\nreturn ("R");\r\ncase TYPE_SCANNER:\r\nreturn ("S");\r\ncase TYPE_MOD:\r\nreturn ("M");\r\ncase TYPE_MEDIUM_CHANGER:\r\nreturn ("C");\r\ncase TYPE_NO_LUN:\r\nreturn ("+");\r\n}\r\nreturn ("-");\r\n}\r\nstatic char *ti_l(int val)\r\n{\r\nconst char hex[16] = "0123456789abcdef";\r\nstatic char answer[2];\r\nanswer[1] = (char) (0x0);\r\nif (val <= MAX_LOG_DEV)\r\nanswer[0] = hex[val];\r\nelse\r\nanswer[0] = '-';\r\nreturn (char *) &answer;\r\n}\r\nstatic char *ibmrate(unsigned int speed, int i)\r\n{\r\nswitch (speed) {\r\ncase 0:\r\nreturn i ? "5.00" : "10.00";\r\ncase 1:\r\nreturn i ? "4.00" : "8.00";\r\ncase 2:\r\nreturn i ? "3.33" : "6.66";\r\ncase 3:\r\nreturn i ? "2.86" : "5.00";\r\ncase 4:\r\nreturn i ? "2.50" : "4.00";\r\ncase 5:\r\nreturn i ? "2.22" : "3.10";\r\ncase 6:\r\nreturn i ? "2.00" : "2.50";\r\ncase 7:\r\nreturn i ? "1.82" : "2.00";\r\n}\r\nreturn "---";\r\n}\r\nstatic int probe_display(int what)\r\n{\r\nstatic int rotator = 0;\r\nconst char rotor[] = "|/-\\";\r\nif (!(display_mode & LED_DISP))\r\nreturn 0;\r\nif (!what) {\r\noutl(0x20202020, MOD95_LED_PORT);\r\noutl(0x20202020, MOD95_LED_PORT + 4);\r\n} else {\r\noutb('S', MOD95_LED_PORT + 7);\r\noutb('C', MOD95_LED_PORT + 6);\r\noutb('S', MOD95_LED_PORT + 5);\r\noutb('I', MOD95_LED_PORT + 4);\r\noutb('i', MOD95_LED_PORT + 3);\r\noutb('n', MOD95_LED_PORT + 2);\r\noutb('i', MOD95_LED_PORT + 1);\r\noutb((char) (rotor[rotator]), MOD95_LED_PORT);\r\nrotator++;\r\nif (rotator > 3)\r\nrotator = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int probe_bus_mode(struct Scsi_Host *shpnt)\r\n{\r\nstruct im_pos_info *info;\r\nint num_bus = 0;\r\nint ldn;\r\ninfo = (struct im_pos_info *) (&(ld(shpnt)[MAX_LOG_DEV].buf));\r\nif (get_pos_info(shpnt)) {\r\nif (info->connector_size & 0xf000)\r\nsubsystem_connector_size(shpnt) = 16;\r\nelse\r\nsubsystem_connector_size(shpnt) = 32;\r\nnum_bus |= (info->pos_4b & 8) >> 3;\r\nfor (ldn = 0; ldn <= MAX_LOG_DEV; ldn++) {\r\nif ((special(shpnt) == IBM_SCSI_WCACHE) || (special(shpnt) == IBM_7568_WCACHE)) {\r\nif (!((info->cache_stat >> ldn) & 1))\r\nld(shpnt)[ldn].cache_flag = 0;\r\n}\r\nif (!((info->retry_stat >> ldn) & 1))\r\nld(shpnt)[ldn].retry_flag = 0;\r\n}\r\n#ifdef IM_DEBUG_PROBE\r\nprintk("IBM MCA SCSI: SCSI-Cache bits: ");\r\nfor (ldn = 0; ldn <= MAX_LOG_DEV; ldn++) {\r\nprintk("%d", ld(shpnt)[ldn].cache_flag);\r\n}\r\nprintk("\nIBM MCA SCSI: SCSI-Retry bits: ");\r\nfor (ldn = 0; ldn <= MAX_LOG_DEV; ldn++) {\r\nprintk("%d", ld(shpnt)[ldn].retry_flag);\r\n}\r\nprintk("\n");\r\n#endif\r\n}\r\nreturn num_bus;\r\n}\r\nstatic void check_devices(struct Scsi_Host *shpnt, int adaptertype)\r\n{\r\nint id, lun, ldn, ticks;\r\nint count_devices;\r\nint max_pun;\r\nint num_bus;\r\nint speedrun;\r\nticks = 0;\r\ncount_devices = 0;\r\nIBM_DS(shpnt).dyn_flag = 0;\r\nIBM_DS(shpnt).total_errors = 0;\r\nnext_ldn(shpnt) = 7;\r\nmemset(ld(shpnt), 0, sizeof(ld(shpnt)));\r\nfor (ldn = 0; ldn <= MAX_LOG_DEV; ldn++) {\r\nlast_scsi_command(shpnt)[ldn] = NO_SCSI;\r\nlast_scsi_type(shpnt)[ldn] = 0;\r\nld(shpnt)[ldn].cache_flag = 1;\r\nld(shpnt)[ldn].retry_flag = 1;\r\n}\r\nmemset(get_ldn(shpnt), TYPE_NO_DEVICE, sizeof(get_ldn(shpnt)));\r\nmemset(get_scsi(shpnt), TYPE_NO_DEVICE, sizeof(get_scsi(shpnt)));\r\nfor (lun = 0; lun < 8; lun++) {\r\nget_scsi(shpnt)[subsystem_pun(shpnt)][lun] = TYPE_IBM_SCSI_ADAPTER;\r\nget_ldn(shpnt)[subsystem_pun(shpnt)][lun] = MAX_LOG_DEV;\r\n}\r\nprobe_display(0);\r\nadapter_speed(shpnt) = global_adapter_speed;\r\nspeedrun = adapter_speed(shpnt);\r\nwhile (immediate_feature(shpnt, speedrun, adapter_timeout) == 2) {\r\nprobe_display(1);\r\nif (speedrun == 7)\r\npanic("IBM MCA SCSI: Cannot set Synchronous-Transfer-Rate!\n");\r\nspeedrun++;\r\nif (speedrun > 7)\r\nspeedrun = 7;\r\n}\r\nadapter_speed(shpnt) = speedrun;\r\nnum_bus = probe_bus_mode(shpnt);\r\nif (adaptertype == IBM_SCSI2_FW) {\r\nif (num_bus) {\r\nprintk(KERN_INFO "IBM MCA SCSI: Separate bus mode (wide-addressing enabled)\n");\r\nsubsystem_maxid(shpnt) = 16;\r\n} else {\r\nprintk(KERN_INFO "IBM MCA SCSI: Combined bus mode (wide-addressing disabled)\n");\r\nsubsystem_maxid(shpnt) = 8;\r\n}\r\nprintk(KERN_INFO "IBM MCA SCSI: Sync.-Rate (F/W: 20, Int.: 10, Ext.: %s) MBytes/s\n", ibmrate(speedrun, adaptertype));\r\n} else\r\nprintk(KERN_INFO "IBM MCA SCSI: Synchronous-SCSI-Transfer-Rate: %s MBytes/s\n", ibmrate(speedrun, adaptertype));\r\nmax_pun = subsystem_maxid(shpnt);\r\n#ifdef IM_DEBUG_PROBE\r\nprintk("IBM MCA SCSI: Current SCSI-host index: %d\n", shpnt);\r\nprintk("IBM MCA SCSI: Removing default logical SCSI-device mapping.");\r\n#else\r\nprintk(KERN_INFO "IBM MCA SCSI: Dev. Order: %s, Mapping (takes <2min): ", (ibm_ansi_order) ? "ANSI" : "New");\r\n#endif\r\nfor (ldn = 0; ldn < MAX_LOG_DEV; ldn++) {\r\nprobe_display(1);\r\n#ifdef IM_DEBUG_PROBE\r\nprintk(".");\r\n#endif\r\nimmediate_assign(shpnt, 0, 0, ldn, REMOVE_LDN);\r\n}\r\nlun = 0;\r\n#ifndef IM_DEBUG_PROBE\r\nprintk("cleared,");\r\n#endif\r\n#ifdef IM_DEBUG_PROBE\r\nprintk("\nIBM MCA SCSI: Scanning SCSI-devices.");\r\n#endif\r\nfor (id = 0; id < max_pun; id++)\r\n#ifdef CONFIG_SCSI_MULTI_LUN\r\nfor (lun = 0; lun < 8; lun++)\r\n#endif\r\n{\r\nprobe_display(1);\r\n#ifdef IM_DEBUG_PROBE\r\nprintk(".");\r\n#endif\r\nif (id != subsystem_pun(shpnt)) {\r\nimmediate_assign(shpnt, id, lun, PROBE_LDN, SET_LDN);\r\nif (device_inquiry(shpnt, PROBE_LDN)) {\r\nget_scsi(shpnt)[id][lun] = (unsigned char) (ld(shpnt)[PROBE_LDN].buf[0]);\r\nif (ld(shpnt)[PROBE_LDN].buf[0] != TYPE_NO_LUN)\r\ncount_devices++;\r\n}\r\nimmediate_assign(shpnt, id, lun, PROBE_LDN, REMOVE_LDN);\r\n}\r\n}\r\n#ifndef IM_DEBUG_PROBE\r\nprintk("scanned,");\r\n#endif\r\n#ifdef IM_DEBUG_PROBE\r\nprintk("\nIBM MCA SCSI: Mapping SCSI-devices.");\r\n#endif\r\nldn = 0;\r\nlun = 0;\r\n#ifdef CONFIG_SCSI_MULTI_LUN\r\nfor (lun = 0; lun < 8 && ldn < MAX_LOG_DEV; lun++)\r\n#endif\r\nfor (id = 0; id < max_pun && ldn < MAX_LOG_DEV; id++) {\r\nprobe_display(1);\r\n#ifdef IM_DEBUG_PROBE\r\nprintk(".");\r\n#endif\r\nif (id != subsystem_pun(shpnt)) {\r\nif (get_scsi(shpnt)[id][lun] != TYPE_NO_LUN && get_scsi(shpnt)[id][lun] != TYPE_NO_DEVICE) {\r\nimmediate_assign(shpnt, id, lun, ldn, SET_LDN);\r\nget_ldn(shpnt)[id][lun] = ldn;\r\nif (device_exists(shpnt, ldn, &ld(shpnt)[ldn].block_length, &ld(shpnt)[ldn].device_type)) {\r\n#ifdef CONFIG_IBMMCA_SCSI_DEV_RESET\r\nprintk("resetting device at ldn=%x ... ", ldn);\r\nimmediate_reset(shpnt, ldn);\r\n#endif\r\nldn++;\r\n} else {\r\nif (lun > 0) {\r\nget_ldn(shpnt)[id][lun] = TYPE_NO_DEVICE;\r\nimmediate_assign(shpnt, 0, 0, ldn, REMOVE_LDN);\r\n} else\r\nldn++;\r\n}\r\n} else if (lun == 0) {\r\nimmediate_assign(shpnt, id, lun, ldn, SET_LDN);\r\nget_ldn(shpnt)[id][lun] = ldn;\r\nldn++;\r\n}\r\n}\r\n}\r\nfor (lun = 1; lun < 8 && ldn < MAX_LOG_DEV; lun++)\r\nfor (id = 0; id < max_pun && ldn < MAX_LOG_DEV; id++) {\r\nif (get_scsi(shpnt)[id][lun] == TYPE_NO_LUN || get_scsi(shpnt)[id][lun] == TYPE_NO_DEVICE) {\r\nprobe_display(1);\r\nimmediate_assign(shpnt, id, lun, ldn, SET_LDN);\r\nget_ldn(shpnt)[id][lun] = ldn;\r\nldn++;\r\n}\r\n}\r\n#ifndef IM_DEBUG_PROBE\r\nprintk("mapped.");\r\n#endif\r\nprintk("\n");\r\n#ifdef IM_DEBUG_PROBE\r\nif (ibm_ansi_order)\r\nprintk("IBM MCA SCSI: Device order: IBM/ANSI (pun=7 is first).\n");\r\nelse\r\nprintk("IBM MCA SCSI: Device order: New Industry Standard (pun=0 is first).\n");\r\n#endif\r\n#ifdef IM_DEBUG_PROBE\r\nprintk("IBM MCA SCSI: Determined SCSI-device-mapping:\n");\r\nprintk(" Physical SCSI-Device Map Logical SCSI-Device Map\n");\r\nprintk("ID\\LUN 0 1 2 3 4 5 6 7 ID\\LUN 0 1 2 3 4 5 6 7\n");\r\nfor (id = 0; id < max_pun; id++) {\r\nprintk("%2d ", id);\r\nfor (lun = 0; lun < 8; lun++)\r\nprintk("%2s ", ti_p(get_scsi(shpnt)[id][lun]));\r\nprintk(" %2d ", id);\r\nfor (lun = 0; lun < 8; lun++)\r\nprintk("%2s ", ti_l(get_ldn(shpnt)[id][lun]));\r\nprintk("\n");\r\n}\r\n#endif\r\nIBM_DS(shpnt).total_scsi_devices = count_devices;\r\nif (count_devices >= MAX_LOG_DEV)\r\nIBM_DS(shpnt).dyn_flag = 1;\r\nelse\r\nIBM_DS(shpnt).dyn_flag = 0;\r\nif (ldn == 0)\r\nprintk("IBM MCA SCSI: Warning: No SCSI-devices found/assigned!\n");\r\nIBM_DS(shpnt).scbs = 0;\r\nIBM_DS(shpnt).long_scbs = 0;\r\nIBM_DS(shpnt).total_accesses = 0;\r\nIBM_DS(shpnt).total_interrupts = 0;\r\nIBM_DS(shpnt).dynamical_assignments = 0;\r\nmemset(IBM_DS(shpnt).ldn_access, 0x0, sizeof(IBM_DS(shpnt).ldn_access));\r\nmemset(IBM_DS(shpnt).ldn_read_access, 0x0, sizeof(IBM_DS(shpnt).ldn_read_access));\r\nmemset(IBM_DS(shpnt).ldn_write_access, 0x0, sizeof(IBM_DS(shpnt).ldn_write_access));\r\nmemset(IBM_DS(shpnt).ldn_inquiry_access, 0x0, sizeof(IBM_DS(shpnt).ldn_inquiry_access));\r\nmemset(IBM_DS(shpnt).ldn_modeselect_access, 0x0, sizeof(IBM_DS(shpnt).ldn_modeselect_access));\r\nmemset(IBM_DS(shpnt).ldn_assignments, 0x0, sizeof(IBM_DS(shpnt).ldn_assignments));\r\nprobe_display(0);\r\nreturn;\r\n}\r\nstatic int device_exists(struct Scsi_Host *shpnt, int ldn, int *block_length, int *device_type)\r\n{\r\nunsigned char *buf;\r\nif (!(device_inquiry(shpnt, ldn)))\r\nreturn 0;\r\nbuf = (unsigned char *) (&(ld(shpnt)[ldn].buf));\r\nif (*buf == TYPE_ROM) {\r\n*device_type = TYPE_ROM;\r\n*block_length = 2048;\r\nreturn 1;\r\n}\r\nif (*buf == TYPE_WORM) {\r\n*device_type = TYPE_WORM;\r\n*block_length = 2048;\r\nreturn 1;\r\n}\r\nif (*buf == TYPE_DISK) {\r\n*device_type = TYPE_DISK;\r\nif (read_capacity(shpnt, ldn)) {\r\n*block_length = *(buf + 7) + (*(buf + 6) << 8) + (*(buf + 5) << 16) + (*(buf + 4) << 24);\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nif (*buf == TYPE_MOD) {\r\n*device_type = TYPE_MOD;\r\nif (read_capacity(shpnt, ldn)) {\r\n*block_length = *(buf + 7) + (*(buf + 6) << 8) + (*(buf + 5) << 16) + (*(buf + 4) << 24);\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nif (*buf == TYPE_TAPE) {\r\n*device_type = TYPE_TAPE;\r\n*block_length = 0;\r\nreturn 1;\r\n}\r\nif (*buf == TYPE_PROCESSOR) {\r\n*device_type = TYPE_PROCESSOR;\r\n*block_length = 0;\r\nreturn 1;\r\n}\r\nif (*buf == TYPE_SCANNER) {\r\n*device_type = TYPE_SCANNER;\r\n*block_length = 0;\r\nreturn 1;\r\n}\r\nif (*buf == TYPE_MEDIUM_CHANGER) {\r\n*device_type = TYPE_MEDIUM_CHANGER;\r\n*block_length = 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void internal_ibmmca_scsi_setup(char *str, int *ints)\r\n{\r\nint i, j, io_base, id_base;\r\nchar *token;\r\nio_base = 0;\r\nid_base = 0;\r\nif (str) {\r\nj = 0;\r\nwhile ((token = strsep(&str, ",")) != NULL) {\r\nif (!strcmp(token, "activity"))\r\ndisplay_mode |= LED_ACTIVITY;\r\nif (!strcmp(token, "display"))\r\ndisplay_mode |= LED_DISP;\r\nif (!strcmp(token, "adisplay"))\r\ndisplay_mode |= LED_ADISP;\r\nif (!strcmp(token, "normal"))\r\nibm_ansi_order = 0;\r\nif (!strcmp(token, "ansi"))\r\nibm_ansi_order = 1;\r\nif (!strcmp(token, "fast"))\r\nglobal_adapter_speed = 0;\r\nif (!strcmp(token, "medium"))\r\nglobal_adapter_speed = 4;\r\nif (!strcmp(token, "slow"))\r\nglobal_adapter_speed = 7;\r\nif ((*token == '-') || (isdigit(*token))) {\r\nif (!(j % 2) && (io_base < IM_MAX_HOSTS))\r\nio_port[io_base++] = simple_strtoul(token, NULL, 0);\r\nif ((j % 2) && (id_base < IM_MAX_HOSTS))\r\nscsi_id[id_base++] = simple_strtoul(token, NULL, 0);\r\nj++;\r\n}\r\n}\r\n} else if (ints) {\r\nfor (i = 0; i < IM_MAX_HOSTS && 2 * i + 2 < ints[0]; i++) {\r\nio_port[i] = ints[2 * i + 2];\r\nscsi_id[i] = ints[2 * i + 2];\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int ibmmca_probe(struct device *dev)\r\n{\r\nstruct Scsi_Host *shpnt;\r\nint port, id, i, j, k, irq, enabled, ret = -EINVAL;\r\nstruct mca_device *mca_dev = to_mca_device(dev);\r\nconst char *description = ibmmca_description[mca_dev->index];\r\nprintk(KERN_INFO "IBM MCA SCSI: Version %s\n", IBMMCA_SCSI_DRIVER_VERSION);\r\nfor (j = 0; j < 8; j++)\r\npos[j] = mca_device_read_pos(mca_dev, j);\r\nid = (pos[3] & 0xe0) >> 5;\r\nenabled = (pos[2] &0x01);\r\nif (!enabled) {\r\nprintk(KERN_WARNING "IBM MCA SCSI: WARNING - Your SCSI-subsystem is disabled!\n");\r\nprintk(KERN_WARNING " SCSI-operations may not work.\n");\r\n}\r\nif (mca_dev->slot == MCA_INTEGSCSI &&\r\n((!pos[0] && !pos[1] && pos[2] > 0 &&\r\npos[3] > 0 && !pos[4] && !pos[5] &&\r\n!pos[6] && !pos[7]) ||\r\n(pos[0] == 0xff && pos[1] == 0xff &&\r\npos[2] < 0xff && pos[3] < 0xff &&\r\npos[4] == 0xff && pos[5] == 0xff &&\r\npos[6] == 0xff && pos[7] == 0xff))) {\r\nirq = IM_IRQ;\r\nport = IM_IO_PORT;\r\n} else {\r\nirq = IM_IRQ;\r\nport = IM_IO_PORT + ((pos[2] &0x0e) << 2);\r\nif ((mca_dev->index == IBM_SCSI2_FW) && (pos[6] != 0)) {\r\nprintk(KERN_ERR "IBM MCA SCSI: ERROR - Wrong POS(6)-register setting!\n");\r\nprintk(KERN_ERR " Impossible to determine adapter PUN!\n");\r\nprintk(KERN_ERR " Guessing adapter PUN = 7.\n");\r\nid = 7;\r\n} else {\r\nid = (pos[3] & 0xe0) >> 5;\r\nif (mca_dev->index == IBM_SCSI2_FW) {\r\nid |= (pos[3] & 0x10) >> 1;\r\n}\r\n}\r\nif ((mca_dev->index == IBM_SCSI2_FW) &&\r\n(pos[4] & 0x01) && (pos[6] == 0)) {\r\nprintk(KERN_DEBUG "IBM MCA SCSI: SCSI-2 F/W adapter needs IRQ 11.\n");\r\nirq = IM_IRQ_FW;\r\n}\r\n}\r\nprintk(KERN_INFO "IBM MCA SCSI: %s found, io=0x%x, scsi id=%d,\n",\r\ndescription, port, id);\r\nif (mca_dev->slot == MCA_INTEGSCSI)\r\nprintk(KERN_INFO " chip rev.=%d, 8K NVRAM=%s, subsystem=%s\n", ((pos[2] & 0xf0) >> 4), (pos[2] & 2) ? "locked" : "accessible", (pos[2] & 1) ? "enabled." : "disabled.");\r\nelse {\r\nif ((pos[2] & 0xf0) == 0xf0)\r\nprintk(KERN_DEBUG " ROM Addr.=off,");\r\nelse\r\nprintk(KERN_DEBUG " ROM Addr.=0x%x,", ((pos[2] & 0xf0) << 13) + 0xc0000);\r\nprintk(KERN_DEBUG " port-offset=0x%x, subsystem=%s\n", ((pos[2] & 0x0e) << 2), (pos[2] & 1) ? "enabled." : "disabled.");\r\n}\r\nif (!request_region(port, IM_N_IO_PORT, description)) {\r\nprintk(KERN_ERR "IBM MCA SCSI: Unable to get I/O region 0x%x-0x%x (%d ports).\n", port, port + IM_N_IO_PORT - 1, IM_N_IO_PORT);\r\ngoto out_fail;\r\n}\r\nshpnt = scsi_host_alloc(&ibmmca_driver_template,\r\nsizeof(struct ibmmca_hostdata));\r\nif (!shpnt) {\r\nprintk(KERN_ERR "IBM MCA SCSI: Unable to register host.\n");\r\ngoto out_release;\r\n}\r\ndev_set_drvdata(dev, shpnt);\r\nif(request_irq(irq, interrupt_handler, IRQF_SHARED, description, dev)) {\r\nprintk(KERN_ERR "IBM MCA SCSI: failed to request interrupt %d\n", irq);\r\ngoto out_free_host;\r\n}\r\nspecial(shpnt) = mca_dev->index;\r\nsubsystem_connector_size(shpnt) = 0;\r\nshpnt->irq = irq;\r\nshpnt->io_port = port;\r\nshpnt->n_io_port = IM_N_IO_PORT;\r\nshpnt->this_id = id;\r\nshpnt->max_id = 8;\r\n#ifdef IM_DEBUG_PROBE\r\nctrl = (unsigned int) (inb(IM_CTR_REG(found)));\r\nprintk("IBM MCA SCSI: Control Register contents: %x, status: %x\n", ctrl, inb(IM_STAT_REG(found)));\r\nprintk("IBM MCA SCSI: This adapters' POS-registers: ");\r\nfor (i = 0; i < 8; i++)\r\nprintk("%x ", pos[i]);\r\nprintk("\n");\r\n#endif\r\nreset_status(shpnt) = IM_RESET_NOT_IN_PROGRESS;\r\nfor (i = 0; i < 16; i++)\r\nfor (j = 0; j < 8; j++)\r\nget_ldn(shpnt)[i][j] = MAX_LOG_DEV;\r\nlocal_checking_phase_flag(shpnt) = 1;\r\ncheck_devices(shpnt, mca_dev->index);\r\nlocal_checking_phase_flag(shpnt) = 0;\r\nfor (k = 2; k < 7; k++)\r\n((struct ibmmca_hostdata *) shpnt->hostdata)->_pos[k] = pos[k];\r\n((struct ibmmca_hostdata *) shpnt->hostdata)->_special = INTEGRATED_SCSI;\r\nmca_device_set_name(mca_dev, description);\r\nmca_device_set_claim(mca_dev, 1);\r\nif (scsi_add_host(shpnt, dev)) {\r\ndev_printk(KERN_ERR, dev, "IBM MCA SCSI: scsi_add_host failed\n");\r\ngoto out_free_host;\r\n}\r\nscsi_scan_host(shpnt);\r\nreturn 0;\r\nout_free_host:\r\nscsi_host_put(shpnt);\r\nout_release:\r\nrelease_region(port, IM_N_IO_PORT);\r\nout_fail:\r\nreturn ret;\r\n}\r\nstatic int __devexit ibmmca_remove(struct device *dev)\r\n{\r\nstruct Scsi_Host *shpnt = dev_get_drvdata(dev);\r\nscsi_remove_host(shpnt);\r\nrelease_region(shpnt->io_port, shpnt->n_io_port);\r\nfree_irq(shpnt->irq, dev);\r\nscsi_host_put(shpnt);\r\nreturn 0;\r\n}\r\nstatic int ibmmca_queuecommand_lck(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))\r\n{\r\nunsigned int ldn;\r\nunsigned int scsi_cmd;\r\nstruct im_scb *scb;\r\nstruct Scsi_Host *shpnt;\r\nint current_ldn;\r\nint id, lun;\r\nint target;\r\nint max_pun;\r\nint i;\r\nstruct scatterlist *sg;\r\nshpnt = cmd->device->host;\r\nmax_pun = subsystem_maxid(shpnt);\r\nif (ibm_ansi_order) {\r\ntarget = max_pun - 1 - cmd->device->id;\r\nif ((target <= subsystem_pun(shpnt)) && (cmd->device->id <= subsystem_pun(shpnt)))\r\ntarget--;\r\nelse if ((target >= subsystem_pun(shpnt)) && (cmd->device->id >= subsystem_pun(shpnt)))\r\ntarget++;\r\n} else\r\ntarget = cmd->device->id;\r\nif ((get_scsi(shpnt)[target][cmd->device->lun] == TYPE_NO_LUN) || (get_scsi(shpnt)[target][cmd->device->lun] == TYPE_NO_DEVICE)) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\nif (done)\r\ndone(cmd);\r\nreturn 0;\r\n}\r\nldn = get_ldn(shpnt)[target][cmd->device->lun];\r\nif (ldn >= MAX_LOG_DEV) {\r\nif (ldn > MAX_LOG_DEV) {\r\ncurrent_ldn = next_ldn(shpnt);\r\nwhile (ld(shpnt)[next_ldn(shpnt)].cmd) {\r\nnext_ldn(shpnt)++;\r\nif (next_ldn(shpnt) >= MAX_LOG_DEV)\r\nnext_ldn(shpnt) = 7;\r\nif (current_ldn == next_ldn(shpnt)) {\r\nscmd_printk(KERN_WARNING, cmd,\r\n"IBM MCA SCSI: Cannot assign SCSI-device dynamically!\n"\r\n" On ldn 7-14 SCSI-commands everywhere in progress.\n"\r\n" Reporting DID_NO_CONNECT for device.\n");\r\ncmd->result = DID_NO_CONNECT << 16;\r\nif (done)\r\ndone(cmd);\r\nreturn 0;\r\n}\r\n}\r\nfor (id = 0; id < max_pun; id++)\r\nfor (lun = 0; lun < 8; lun++) {\r\nif (get_ldn(shpnt)[id][lun] == next_ldn(shpnt)) {\r\nget_ldn(shpnt)[id][lun] = TYPE_NO_DEVICE;\r\nget_scsi(shpnt)[id][lun] = TYPE_NO_DEVICE;\r\n}\r\n}\r\nlocal_checking_phase_flag(shpnt) = 1;\r\nget_ldn(shpnt)[target][cmd->device->lun] = next_ldn(shpnt);\r\nldn = next_ldn(shpnt);\r\nimmediate_assign(shpnt, 0, 0, 0, REMOVE_LDN);\r\nimmediate_assign(shpnt, target, cmd->device->lun, ldn, SET_LDN);\r\nif (device_exists(shpnt, ldn, &ld(shpnt)[ldn].block_length, &ld(shpnt)[ldn].device_type)) {\r\nld(shpnt)[ldn].cmd = NULL;\r\nget_scsi(shpnt)[target][cmd->device->lun] = ld(shpnt)[ldn].device_type;\r\nIBM_DS(shpnt).dynamical_assignments++;\r\nIBM_DS(shpnt).ldn_assignments[ldn]++;\r\n} else\r\npanic("IBM MCA SCSI: ldn=0x%x, SCSI-device on (%d,%d) vanished!\n", ldn, target, cmd->device->lun);\r\nimmediate_assign(shpnt, 0, 0, 0, REMOVE_LDN);\r\nlun = 0;\r\n#ifdef CONFIG_SCSI_MULTI_LUN\r\nfor (lun = 0; lun < 8; lun++)\r\n#endif\r\nfor (id = 0; id < max_pun; id++) {\r\nif (get_ldn(shpnt)[id][lun] <= MAX_LOG_DEV)\r\nimmediate_assign(shpnt, id, lun, get_ldn(shpnt)[id][lun], SET_LDN);\r\n}\r\nlocal_checking_phase_flag(shpnt) = 0;\r\n#ifdef IM_DEBUG_PROBE\r\nprintk("IBM MCA SCSI: ldn=0x%x dynamically reassigned to (%d,%d).\n", ldn, target, cmd->device->lun);\r\n#endif\r\nnext_ldn(shpnt)++;\r\nif (next_ldn(shpnt) >= MAX_LOG_DEV)\r\nnext_ldn(shpnt) = 7;\r\n} else {\r\ncmd->result = DID_BAD_TARGET << 16;\r\nif (done)\r\ndone(cmd);\r\nreturn 0;\r\n}\r\n}\r\nif (ld(shpnt)[ldn].cmd)\r\npanic("IBM MCA SCSI: cmd already in progress for this ldn.\n");\r\ncmd->scsi_done = done;\r\nld(shpnt)[ldn].cmd = cmd;\r\nscb = &(ld(shpnt)[ldn].scb);\r\nld(shpnt)[ldn].tsb.dev_status = 0;\r\nscb->enable = IM_REPORT_TSB_ONLY_ON_ERROR | IM_RETRY_ENABLE;\r\nscb->tsb_adr = isa_virt_to_bus(&(ld(shpnt)[ldn].tsb));\r\nscsi_cmd = cmd->cmnd[0];\r\nif (scsi_sg_count(cmd)) {\r\nBUG_ON(scsi_sg_count(cmd) > 16);\r\nscsi_for_each_sg(cmd, sg, scsi_sg_count(cmd), i) {\r\nld(shpnt)[ldn].sge[i].address = (void *) (isa_page_to_bus(sg_page(sg)) + sg->offset);\r\nld(shpnt)[ldn].sge[i].byte_length = sg->length;\r\n}\r\nscb->enable |= IM_POINTER_TO_LIST;\r\nscb->sys_buf_adr = isa_virt_to_bus(&(ld(shpnt)[ldn].sge[0]));\r\nscb->sys_buf_length = scsi_sg_count(cmd) * sizeof(struct im_sge);\r\n} else {\r\nscb->sys_buf_adr = isa_virt_to_bus(scsi_sglist(cmd));\r\nswitch (scsi_cmd) {\r\ncase INQUIRY:\r\ncase REQUEST_SENSE:\r\ncase MODE_SENSE:\r\ncase MODE_SELECT:\r\nif (scsi_bufflen(cmd) > 255)\r\nscb->sys_buf_length = 255;\r\nelse\r\nscb->sys_buf_length = scsi_bufflen(cmd);\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nscb->sys_buf_length = 0;\r\nbreak;\r\ndefault:\r\nscb->sys_buf_length = scsi_bufflen(cmd);\r\nbreak;\r\n}\r\n}\r\n#ifdef IM_DEBUG_CMD\r\nprintk("issue scsi cmd=%02x to ldn=%d\n", scsi_cmd, ldn);\r\n#endif\r\n#ifdef IM_DEBUG_CMD_SPEC_DEV\r\nif (ld(shpnt)[ldn].device_type == IM_DEBUG_CMD_DEVICE)\r\nprintk("(SCSI-device-type=0x%x) issue scsi cmd=%02x to ldn=%d\n", ld(shpnt)[ldn].device_type, scsi_cmd, ldn);\r\n#endif\r\nlast_scsi_command(shpnt)[ldn] = scsi_cmd;\r\nlast_scsi_type(shpnt)[ldn] = IM_SCB;\r\nIBM_DS(shpnt).total_accesses++;\r\nIBM_DS(shpnt).ldn_access[ldn]++;\r\nswitch (scsi_cmd) {\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_12:\r\ncase WRITE_12:\r\nswitch (ld(shpnt)[ldn].device_type) {\r\ncase TYPE_DISK:\r\ncase TYPE_MOD:\r\nif (scsi_cmd == READ_6 || scsi_cmd == READ_10 || scsi_cmd == READ_12) {\r\nscb->enable |= IM_READ_CONTROL;\r\nIBM_DS(shpnt).ldn_read_access[ldn]++;\r\nscb->command = IM_READ_DATA_CMD | IM_NO_DISCONNECT;\r\n} else {\r\nIBM_DS(shpnt).ldn_write_access[ldn]++;\r\nscb->command = IM_WRITE_DATA_CMD | IM_NO_DISCONNECT;\r\n}\r\nif (scsi_cmd == READ_6 || scsi_cmd == WRITE_6) {\r\nscb->u1.log_blk_adr = (((unsigned) cmd->cmnd[3]) << 0) | (((unsigned) cmd->cmnd[2]) << 8) | ((((unsigned) cmd->cmnd[1]) & 0x1f) << 16);\r\nscb->u2.blk.count = (unsigned) cmd->cmnd[4];\r\n} else {\r\nscb->u1.log_blk_adr = (((unsigned) cmd->cmnd[5]) << 0) | (((unsigned) cmd->cmnd[4]) << 8) | (((unsigned) cmd->cmnd[3]) << 16) | (((unsigned) cmd->cmnd[2]) << 24);\r\nscb->u2.blk.count = (((unsigned) cmd->cmnd[8]) << 0) | (((unsigned) cmd->cmnd[7]) << 8);\r\n}\r\nlast_scsi_logical_block(shpnt)[ldn] = scb->u1.log_blk_adr;\r\nlast_scsi_blockcount(shpnt)[ldn] = scb->u2.blk.count;\r\nscb->u2.blk.length = ld(shpnt)[ldn].block_length;\r\nbreak;\r\ncase TYPE_ROM:\r\ncase TYPE_TAPE:\r\ncase TYPE_PROCESSOR:\r\ncase TYPE_WORM:\r\ncase TYPE_SCANNER:\r\ncase TYPE_MEDIUM_CHANGER:\r\nscb->command = IM_OTHER_SCSI_CMD_CMD;\r\nif (scsi_cmd == READ_6 || scsi_cmd == READ_10 || scsi_cmd == READ_12)\r\nscb->enable |= IM_READ_CONTROL;\r\nscb->enable |= IM_BYPASS_BUFFER;\r\nscb->u1.scsi_cmd_length = cmd->cmd_len;\r\nmemcpy(scb->u2.scsi_command, cmd->cmnd, cmd->cmd_len);\r\nlast_scsi_type(shpnt)[ldn] = IM_LONG_SCB;\r\nbreak;\r\n}\r\nbreak;\r\ncase INQUIRY:\r\nIBM_DS(shpnt).ldn_inquiry_access[ldn]++;\r\nscb->command = IM_DEVICE_INQUIRY_CMD;\r\nscb->enable |= IM_READ_CONTROL | IM_SUPRESS_EXCEPTION_SHORT | IM_BYPASS_BUFFER;\r\nscb->u1.log_blk_adr = 0;\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nscb->command = IM_OTHER_SCSI_CMD_CMD;\r\nscb->enable |= IM_READ_CONTROL | IM_SUPRESS_EXCEPTION_SHORT | IM_BYPASS_BUFFER;\r\nscb->u1.log_blk_adr = 0;\r\nscb->u1.scsi_cmd_length = 6;\r\nmemcpy(scb->u2.scsi_command, cmd->cmnd, 6);\r\nlast_scsi_type(shpnt)[ldn] = IM_LONG_SCB;\r\nbreak;\r\ncase READ_CAPACITY:\r\nscb->command = IM_READ_CAPACITY_CMD;\r\nscb->enable |= IM_READ_CONTROL | IM_BYPASS_BUFFER;\r\nif (scb->sys_buf_length > 8)\r\nscb->sys_buf_length = 8;\r\nbreak;\r\ncase REQUEST_SENSE:\r\nscb->command = IM_REQUEST_SENSE_CMD;\r\nscb->enable |= IM_READ_CONTROL | IM_SUPRESS_EXCEPTION_SHORT | IM_BYPASS_BUFFER;\r\nbreak;\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\nIBM_DS(shpnt).ldn_modeselect_access[ldn]++;\r\nscb->command = IM_OTHER_SCSI_CMD_CMD;\r\nscb->enable |= IM_SUPRESS_EXCEPTION_SHORT | IM_BYPASS_BUFFER;\r\nscb->u1.scsi_cmd_length = cmd->cmd_len;\r\nmemcpy(scb->u2.scsi_command, cmd->cmnd, cmd->cmd_len);\r\nlast_scsi_type(shpnt)[ldn] = IM_LONG_SCB;\r\nbreak;\r\ndefault:\r\nscb->command = IM_OTHER_SCSI_CMD_CMD;\r\nscb->enable |= IM_READ_CONTROL | IM_SUPRESS_EXCEPTION_SHORT | IM_BYPASS_BUFFER;\r\nscb->u1.scsi_cmd_length = cmd->cmd_len;\r\nmemcpy(scb->u2.scsi_command, cmd->cmnd, cmd->cmd_len);\r\nlast_scsi_type(shpnt)[ldn] = IM_LONG_SCB;\r\nbreak;\r\n}\r\nif (++disk_rw_in_progress == 1)\r\nPS2_DISK_LED_ON(shpnt->host_no, target);\r\nif (last_scsi_type(shpnt)[ldn] == IM_LONG_SCB) {\r\nissue_cmd(shpnt, isa_virt_to_bus(scb), IM_LONG_SCB | ldn);\r\nIBM_DS(shpnt).long_scbs++;\r\n} else {\r\nissue_cmd(shpnt, isa_virt_to_bus(scb), IM_SCB | ldn);\r\nIBM_DS(shpnt).scbs++;\r\n}\r\nreturn 0;\r\n}\r\nint ibmmca_abort(Scsi_Cmnd * cmd)\r\n{\r\nstruct Scsi_Host *shpnt = cmd->device->host;\r\nint rc;\r\nspin_lock_irq(shpnt->host_lock);\r\nrc = __ibmmca_abort(cmd);\r\nspin_unlock_irq(shpnt->host_lock);\r\nreturn rc;\r\n}\r\nstatic int __ibmmca_host_reset(Scsi_Cmnd * cmd)\r\n{\r\nstruct Scsi_Host *shpnt;\r\nScsi_Cmnd *cmd_aid;\r\nint ticks, i;\r\nunsigned long imm_command;\r\nBUG_ON(cmd == NULL);\r\nticks = IM_RESET_DELAY * HZ;\r\nshpnt = cmd->device->host;\r\nif (local_checking_phase_flag(shpnt)) {\r\nprintk(KERN_WARNING "IBM MCA SCSI: unable to reset while checking devices.\n");\r\nreturn FAILED;\r\n}\r\nprintk("IBM MCA SCSI: resetting all devices.\n");\r\nreset_status(shpnt) = IM_RESET_IN_PROGRESS;\r\nlast_scsi_command(shpnt)[0xf] = IM_RESET_IMM_CMD;\r\nlast_scsi_type(shpnt)[0xf] = IM_IMM_CMD;\r\nimm_command = inl(IM_CMD_REG(shpnt));\r\nimm_command &= (unsigned long) (0xffff0000);\r\nimm_command |= (unsigned long) (IM_RESET_IMM_CMD);\r\nwhile (1) {\r\nif (!(inb(IM_STAT_REG(shpnt)) & IM_BUSY))\r\nbreak;\r\nspin_unlock_irq(shpnt->host_lock);\r\nyield();\r\nspin_lock_irq(shpnt->host_lock);\r\n}\r\noutl(imm_command, IM_CMD_REG(shpnt));\r\noutb(IM_IMM_CMD | 0xf, IM_ATTN_REG(shpnt));\r\nwhile (reset_status(shpnt) == IM_RESET_IN_PROGRESS && --ticks && ((inb(IM_INTR_REG(shpnt)) & 0x8f) != 0x8f)) {\r\nudelay((1 + 999 / HZ) * 1000);\r\nbarrier();\r\n}\r\nif (!ticks) {\r\nprintk(KERN_ERR "IBM MCA SCSI: reset did not complete within %d seconds.\n", IM_RESET_DELAY);\r\nreset_status(shpnt) = IM_RESET_FINISHED_FAIL;\r\nreturn FAILED;\r\n}\r\nif ((inb(IM_INTR_REG(shpnt)) & 0x8f) == 0x8f) {\r\nif (inb(IM_INTR_REG(shpnt)) == 0xaf)\r\nreset_status(shpnt) = IM_RESET_FINISHED_OK_NO_INT;\r\nelse if (inb(IM_INTR_REG(shpnt)) == 0xcf)\r\nreset_status(shpnt) = IM_RESET_FINISHED_FAIL;\r\nelse\r\nreset_status(shpnt) = IM_RESET_NOT_IN_PROGRESS_NO_INT;\r\noutb(IM_EOI | 0xf, IM_ATTN_REG(shpnt));\r\n}\r\nif (reset_status(shpnt) == IM_RESET_FINISHED_FAIL) {\r\nprintk(KERN_ERR "IBM MCA SCSI: reset failed.\n");\r\nreturn FAILED;\r\n}\r\nprintk(KERN_INFO "IBM MCA SCSI: Reset successfully completed.\n");\r\nfor (i = 0; i < MAX_LOG_DEV; i++) {\r\ncmd_aid = ld(shpnt)[i].cmd;\r\nif (cmd_aid && cmd_aid->scsi_done) {\r\nld(shpnt)[i].cmd = NULL;\r\ncmd_aid->result = DID_RESET << 16;\r\n}\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int ibmmca_host_reset(Scsi_Cmnd * cmd)\r\n{\r\nstruct Scsi_Host *shpnt = cmd->device->host;\r\nint rc;\r\nspin_lock_irq(shpnt->host_lock);\r\nrc = __ibmmca_host_reset(cmd);\r\nspin_unlock_irq(shpnt->host_lock);\r\nreturn rc;\r\n}\r\nstatic int ibmmca_biosparam(struct scsi_device *sdev, struct block_device *bdev, sector_t capacity, int *info)\r\n{\r\nint size = capacity;\r\ninfo[0] = 64;\r\ninfo[1] = 32;\r\ninfo[2] = size / (info[0] * info[1]);\r\nif (info[2] >= 1024) {\r\ninfo[0] = 128;\r\ninfo[1] = 63;\r\ninfo[2] = size / (info[0] * info[1]);\r\nif (info[2] >= 1024) {\r\ninfo[0] = 255;\r\ninfo[1] = 63;\r\ninfo[2] = size / (info[0] * info[1]);\r\nif (info[2] >= 1024)\r\ninfo[2] = 1023;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ldn_access_load(struct Scsi_Host *shpnt, int ldn)\r\n{\r\nif (IBM_DS(shpnt).total_accesses == 0)\r\nreturn (0);\r\nif (IBM_DS(shpnt).ldn_access[ldn] == 0)\r\nreturn (0);\r\nreturn (IBM_DS(shpnt).ldn_access[ldn] * 100) / IBM_DS(shpnt).total_accesses;\r\n}\r\nstatic int ldn_access_total_read_write(struct Scsi_Host *shpnt)\r\n{\r\nint a;\r\nint i;\r\na = 0;\r\nfor (i = 0; i <= MAX_LOG_DEV; i++)\r\na += IBM_DS(shpnt).ldn_read_access[i] + IBM_DS(shpnt).ldn_write_access[i];\r\nreturn (a);\r\n}\r\nstatic int ldn_access_total_inquiry(struct Scsi_Host *shpnt)\r\n{\r\nint a;\r\nint i;\r\na = 0;\r\nfor (i = 0; i <= MAX_LOG_DEV; i++)\r\na += IBM_DS(shpnt).ldn_inquiry_access[i];\r\nreturn (a);\r\n}\r\nstatic int ldn_access_total_modeselect(struct Scsi_Host *shpnt)\r\n{\r\nint a;\r\nint i;\r\na = 0;\r\nfor (i = 0; i <= MAX_LOG_DEV; i++)\r\na += IBM_DS(shpnt).ldn_modeselect_access[i];\r\nreturn (a);\r\n}\r\nstatic int ibmmca_proc_info(struct Scsi_Host *shpnt, char *buffer, char **start, off_t offset, int length, int inout)\r\n{\r\nint len = 0;\r\nint i, id, lun;\r\nunsigned long flags;\r\nint max_pun;\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nmax_pun = subsystem_maxid(shpnt);\r\nlen += sprintf(buffer + len, "\n IBM-SCSI-Subsystem-Linux-Driver, Version %s\n\n\n", IBMMCA_SCSI_DRIVER_VERSION);\r\nlen += sprintf(buffer + len, " SCSI Access-Statistics:\n");\r\nlen += sprintf(buffer + len, " Device Scanning Order....: %s\n", (ibm_ansi_order) ? "IBM/ANSI" : "New Industry Standard");\r\n#ifdef CONFIG_SCSI_MULTI_LUN\r\nlen += sprintf(buffer + len, " Multiple LUN probing.....: Yes\n");\r\n#else\r\nlen += sprintf(buffer + len, " Multiple LUN probing.....: No\n");\r\n#endif\r\nlen += sprintf(buffer + len, " This Hostnumber..........: %d\n", shpnt->host_no);\r\nlen += sprintf(buffer + len, " Base I/O-Port............: 0x%x\n", (unsigned int) (IM_CMD_REG(shpnt)));\r\nlen += sprintf(buffer + len, " (Shared) IRQ.............: %d\n", IM_IRQ);\r\nlen += sprintf(buffer + len, " Total Interrupts.........: %d\n", IBM_DS(shpnt).total_interrupts);\r\nlen += sprintf(buffer + len, " Total SCSI Accesses......: %d\n", IBM_DS(shpnt).total_accesses);\r\nlen += sprintf(buffer + len, " Total short SCBs.........: %d\n", IBM_DS(shpnt).scbs);\r\nlen += sprintf(buffer + len, " Total long SCBs..........: %d\n", IBM_DS(shpnt).long_scbs);\r\nlen += sprintf(buffer + len, " Total SCSI READ/WRITE..: %d\n", ldn_access_total_read_write(shpnt));\r\nlen += sprintf(buffer + len, " Total SCSI Inquiries...: %d\n", ldn_access_total_inquiry(shpnt));\r\nlen += sprintf(buffer + len, " Total SCSI Modeselects.: %d\n", ldn_access_total_modeselect(shpnt));\r\nlen += sprintf(buffer + len, " Total SCSI other cmds..: %d\n", IBM_DS(shpnt).total_accesses - ldn_access_total_read_write(shpnt)\r\n- ldn_access_total_modeselect(shpnt)\r\n- ldn_access_total_inquiry(shpnt));\r\nlen += sprintf(buffer + len, " Total SCSI command fails.: %d\n\n", IBM_DS(shpnt).total_errors);\r\nlen += sprintf(buffer + len, " Logical-Device-Number (LDN) Access-Statistics:\n");\r\nlen += sprintf(buffer + len, " LDN | Accesses [%%] | READ | WRITE | ASSIGNMENTS\n");\r\nlen += sprintf(buffer + len, " -----|--------------|-----------|-----------|--------------\n");\r\nfor (i = 0; i <= MAX_LOG_DEV; i++)\r\nlen += sprintf(buffer + len, " %2X | %3d | %8d | %8d | %8d\n", i, ldn_access_load(shpnt, i), IBM_DS(shpnt).ldn_read_access[i], IBM_DS(shpnt).ldn_write_access[i], IBM_DS(shpnt).ldn_assignments[i]);\r\nlen += sprintf(buffer + len, " -----------------------------------------------------------\n\n");\r\nlen += sprintf(buffer + len, " Dynamical-LDN-Assignment-Statistics:\n");\r\nlen += sprintf(buffer + len, " Number of physical SCSI-devices..: %d (+ Adapter)\n", IBM_DS(shpnt).total_scsi_devices);\r\nlen += sprintf(buffer + len, " Dynamical Assignment necessary...: %s\n", IBM_DS(shpnt).dyn_flag ? "Yes" : "No ");\r\nlen += sprintf(buffer + len, " Next LDN to be assigned..........: 0x%x\n", next_ldn(shpnt));\r\nlen += sprintf(buffer + len, " Dynamical assignments done yet...: %d\n", IBM_DS(shpnt).dynamical_assignments);\r\nlen += sprintf(buffer + len, "\n Current SCSI-Device-Mapping:\n");\r\nlen += sprintf(buffer + len, " Physical SCSI-Device Map Logical SCSI-Device Map\n");\r\nlen += sprintf(buffer + len, " ID\\LUN 0 1 2 3 4 5 6 7 ID\\LUN 0 1 2 3 4 5 6 7\n");\r\nfor (id = 0; id < max_pun; id++) {\r\nlen += sprintf(buffer + len, " %2d ", id);\r\nfor (lun = 0; lun < 8; lun++)\r\nlen += sprintf(buffer + len, "%2s ", ti_p(get_scsi(shpnt)[id][lun]));\r\nlen += sprintf(buffer + len, " %2d ", id);\r\nfor (lun = 0; lun < 8; lun++)\r\nlen += sprintf(buffer + len, "%2s ", ti_l(get_ldn(shpnt)[id][lun]));\r\nlen += sprintf(buffer + len, "\n");\r\n}\r\nlen += sprintf(buffer + len, "(A = IBM-Subsystem, D = Harddisk, T = Tapedrive, P = Processor, W = WORM,\n");\r\nlen += sprintf(buffer + len, " R = CD-ROM, S = Scanner, M = MO-Drive, C = Medium-Changer, + = unprovided LUN,\n");\r\nlen += sprintf(buffer + len, " - = nothing found, nothing assigned or unprobed LUN)\n\n");\r\n*start = buffer + offset;\r\nlen -= offset;\r\nif (len > length)\r\nlen = length;\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nreturn len;\r\n}\r\nstatic int option_setup(char *str)\r\n{\r\nint ints[IM_MAX_HOSTS];\r\nchar *cur = str;\r\nint i = 1;\r\nwhile (cur && isdigit(*cur) && i < IM_MAX_HOSTS) {\r\nints[i++] = simple_strtoul(cur, NULL, 0);\r\nif ((cur = strchr(cur, ',')) != NULL)\r\ncur++;\r\n}\r\nints[0] = i - 1;\r\ninternal_ibmmca_scsi_setup(cur, ints);\r\nreturn 1;\r\n}\r\nstatic int __init ibmmca_init(void)\r\n{\r\n#ifdef MODULE\r\nif (boot_options)\r\noption_setup(boot_options);\r\n#endif\r\nreturn mca_register_driver_integrated(&ibmmca_driver, MCA_INTEGSCSI);\r\n}\r\nstatic void __exit ibmmca_exit(void)\r\n{\r\nmca_unregister_driver(&ibmmca_driver);\r\n}
