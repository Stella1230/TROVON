static inline u32 qe_ic_read(volatile __be32 __iomem * base, unsigned int reg)\r\n{\r\nreturn in_be32(base + (reg >> 2));\r\n}\r\nstatic inline void qe_ic_write(volatile __be32 __iomem * base, unsigned int reg,\r\nu32 value)\r\n{\r\nout_be32(base + (reg >> 2), value);\r\n}\r\nstatic inline struct qe_ic *qe_ic_from_irq(unsigned int virq)\r\n{\r\nreturn irq_get_chip_data(virq);\r\n}\r\nstatic inline struct qe_ic *qe_ic_from_irq_data(struct irq_data *d)\r\n{\r\nreturn irq_data_get_irq_chip_data(d);\r\n}\r\nstatic void qe_ic_unmask_irq(struct irq_data *d)\r\n{\r\nstruct qe_ic *qe_ic = qe_ic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 temp;\r\nraw_spin_lock_irqsave(&qe_ic_lock, flags);\r\ntemp = qe_ic_read(qe_ic->regs, qe_ic_info[src].mask_reg);\r\nqe_ic_write(qe_ic->regs, qe_ic_info[src].mask_reg,\r\ntemp | qe_ic_info[src].mask);\r\nraw_spin_unlock_irqrestore(&qe_ic_lock, flags);\r\n}\r\nstatic void qe_ic_mask_irq(struct irq_data *d)\r\n{\r\nstruct qe_ic *qe_ic = qe_ic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 temp;\r\nraw_spin_lock_irqsave(&qe_ic_lock, flags);\r\ntemp = qe_ic_read(qe_ic->regs, qe_ic_info[src].mask_reg);\r\nqe_ic_write(qe_ic->regs, qe_ic_info[src].mask_reg,\r\ntemp & ~qe_ic_info[src].mask);\r\nmb();\r\nraw_spin_unlock_irqrestore(&qe_ic_lock, flags);\r\n}\r\nstatic int qe_ic_host_match(struct irq_host *h, struct device_node *node)\r\n{\r\nreturn h->of_node == NULL || h->of_node == node;\r\n}\r\nstatic int qe_ic_host_map(struct irq_host *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct qe_ic *qe_ic = h->host_data;\r\nstruct irq_chip *chip;\r\nif (qe_ic_info[hw].mask == 0) {\r\nprintk(KERN_ERR "Can't map reserved IRQ\n");\r\nreturn -EINVAL;\r\n}\r\nchip = &qe_ic->hc_irq;\r\nirq_set_chip_data(virq, qe_ic);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, chip, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic int qe_ic_host_xlate(struct irq_host *h, struct device_node *ct,\r\nconst u32 * intspec, unsigned int intsize,\r\nirq_hw_number_t * out_hwirq,\r\nunsigned int *out_flags)\r\n{\r\n*out_hwirq = intspec[0];\r\nif (intsize > 1)\r\n*out_flags = intspec[1];\r\nelse\r\n*out_flags = IRQ_TYPE_NONE;\r\nreturn 0;\r\n}\r\nunsigned int qe_ic_get_low_irq(struct qe_ic *qe_ic)\r\n{\r\nint irq;\r\nBUG_ON(qe_ic == NULL);\r\nirq = qe_ic_read(qe_ic->regs, QEIC_CIVEC) >> 26;\r\nif (irq == 0)\r\nreturn NO_IRQ;\r\nreturn irq_linear_revmap(qe_ic->irqhost, irq);\r\n}\r\nunsigned int qe_ic_get_high_irq(struct qe_ic *qe_ic)\r\n{\r\nint irq;\r\nBUG_ON(qe_ic == NULL);\r\nirq = qe_ic_read(qe_ic->regs, QEIC_CHIVEC) >> 26;\r\nif (irq == 0)\r\nreturn NO_IRQ;\r\nreturn irq_linear_revmap(qe_ic->irqhost, irq);\r\n}\r\nvoid __init qe_ic_init(struct device_node *node, unsigned int flags,\r\nvoid (*low_handler)(unsigned int irq, struct irq_desc *desc),\r\nvoid (*high_handler)(unsigned int irq, struct irq_desc *desc))\r\n{\r\nstruct qe_ic *qe_ic;\r\nstruct resource res;\r\nu32 temp = 0, ret, high_active = 0;\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret)\r\nreturn;\r\nqe_ic = kzalloc(sizeof(*qe_ic), GFP_KERNEL);\r\nif (qe_ic == NULL)\r\nreturn;\r\nqe_ic->irqhost = irq_alloc_host(node, IRQ_HOST_MAP_LINEAR,\r\nNR_QE_IC_INTS, &qe_ic_host_ops, 0);\r\nif (qe_ic->irqhost == NULL) {\r\nkfree(qe_ic);\r\nreturn;\r\n}\r\nqe_ic->regs = ioremap(res.start, resource_size(&res));\r\nqe_ic->irqhost->host_data = qe_ic;\r\nqe_ic->hc_irq = qe_ic_irq_chip;\r\nqe_ic->virq_high = irq_of_parse_and_map(node, 0);\r\nqe_ic->virq_low = irq_of_parse_and_map(node, 1);\r\nif (qe_ic->virq_low == NO_IRQ) {\r\nprintk(KERN_ERR "Failed to map QE_IC low IRQ\n");\r\nkfree(qe_ic);\r\nreturn;\r\n}\r\nif (flags & QE_IC_SPREADMODE_GRP_W)\r\ntemp |= CICR_GWCC;\r\nif (flags & QE_IC_SPREADMODE_GRP_X)\r\ntemp |= CICR_GXCC;\r\nif (flags & QE_IC_SPREADMODE_GRP_Y)\r\ntemp |= CICR_GYCC;\r\nif (flags & QE_IC_SPREADMODE_GRP_Z)\r\ntemp |= CICR_GZCC;\r\nif (flags & QE_IC_SPREADMODE_GRP_RISCA)\r\ntemp |= CICR_GRTA;\r\nif (flags & QE_IC_SPREADMODE_GRP_RISCB)\r\ntemp |= CICR_GRTB;\r\nif (flags & QE_IC_HIGH_SIGNAL) {\r\ntemp |= (SIGNAL_HIGH << CICR_HPIT_SHIFT);\r\nhigh_active = 1;\r\n}\r\nqe_ic_write(qe_ic->regs, QEIC_CICR, temp);\r\nirq_set_handler_data(qe_ic->virq_low, qe_ic);\r\nirq_set_chained_handler(qe_ic->virq_low, low_handler);\r\nif (qe_ic->virq_high != NO_IRQ &&\r\nqe_ic->virq_high != qe_ic->virq_low) {\r\nirq_set_handler_data(qe_ic->virq_high, qe_ic);\r\nirq_set_chained_handler(qe_ic->virq_high, high_handler);\r\n}\r\n}\r\nvoid qe_ic_set_highest_priority(unsigned int virq, int high)\r\n{\r\nstruct qe_ic *qe_ic = qe_ic_from_irq(virq);\r\nunsigned int src = virq_to_hw(virq);\r\nu32 temp = 0;\r\ntemp = qe_ic_read(qe_ic->regs, QEIC_CICR);\r\ntemp &= ~CICR_HP_MASK;\r\ntemp |= src << CICR_HP_SHIFT;\r\ntemp &= ~CICR_HPIT_MASK;\r\ntemp |= (high ? SIGNAL_HIGH : SIGNAL_LOW) << CICR_HPIT_SHIFT;\r\nqe_ic_write(qe_ic->regs, QEIC_CICR, temp);\r\n}\r\nint qe_ic_set_priority(unsigned int virq, unsigned int priority)\r\n{\r\nstruct qe_ic *qe_ic = qe_ic_from_irq(virq);\r\nunsigned int src = virq_to_hw(virq);\r\nu32 temp;\r\nif (priority > 8 || priority == 0)\r\nreturn -EINVAL;\r\nif (src > 127)\r\nreturn -EINVAL;\r\nif (qe_ic_info[src].pri_reg == 0)\r\nreturn -EINVAL;\r\ntemp = qe_ic_read(qe_ic->regs, qe_ic_info[src].pri_reg);\r\nif (priority < 4) {\r\ntemp &= ~(0x7 << (32 - priority * 3));\r\ntemp |= qe_ic_info[src].pri_code << (32 - priority * 3);\r\n} else {\r\ntemp &= ~(0x7 << (24 - priority * 3));\r\ntemp |= qe_ic_info[src].pri_code << (24 - priority * 3);\r\n}\r\nqe_ic_write(qe_ic->regs, qe_ic_info[src].pri_reg, temp);\r\nreturn 0;\r\n}\r\nint qe_ic_set_high_priority(unsigned int virq, unsigned int priority, int high)\r\n{\r\nstruct qe_ic *qe_ic = qe_ic_from_irq(virq);\r\nunsigned int src = virq_to_hw(virq);\r\nu32 temp, control_reg = QEIC_CICNR, shift = 0;\r\nif (priority > 2 || priority == 0)\r\nreturn -EINVAL;\r\nswitch (qe_ic_info[src].pri_reg) {\r\ncase QEIC_CIPZCC:\r\nshift = CICNR_ZCC1T_SHIFT;\r\nbreak;\r\ncase QEIC_CIPWCC:\r\nshift = CICNR_WCC1T_SHIFT;\r\nbreak;\r\ncase QEIC_CIPYCC:\r\nshift = CICNR_YCC1T_SHIFT;\r\nbreak;\r\ncase QEIC_CIPXCC:\r\nshift = CICNR_XCC1T_SHIFT;\r\nbreak;\r\ncase QEIC_CIPRTA:\r\nshift = CRICR_RTA1T_SHIFT;\r\ncontrol_reg = QEIC_CRICR;\r\nbreak;\r\ncase QEIC_CIPRTB:\r\nshift = CRICR_RTB1T_SHIFT;\r\ncontrol_reg = QEIC_CRICR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nshift += (2 - priority) * 2;\r\ntemp = qe_ic_read(qe_ic->regs, control_reg);\r\ntemp &= ~(SIGNAL_MASK << shift);\r\ntemp |= (high ? SIGNAL_HIGH : SIGNAL_LOW) << shift;\r\nqe_ic_write(qe_ic->regs, control_reg, temp);\r\nreturn 0;\r\n}\r\nstatic int __init init_qe_ic_sysfs(void)\r\n{\r\nint rc;\r\nprintk(KERN_DEBUG "Registering qe_ic with sysfs...\n");\r\nrc = sysdev_class_register(&qe_ic_sysclass);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed registering qe_ic sys class\n");\r\nreturn -ENODEV;\r\n}\r\nrc = sysdev_register(&device_qe_ic);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed registering qe_ic sys device\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}
