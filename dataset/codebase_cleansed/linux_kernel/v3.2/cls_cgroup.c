static inline struct cgroup_cls_state *cgrp_cls_state(struct cgroup *cgrp)\r\n{\r\nreturn container_of(cgroup_subsys_state(cgrp, net_cls_subsys_id),\r\nstruct cgroup_cls_state, css);\r\n}\r\nstatic inline struct cgroup_cls_state *task_cls_state(struct task_struct *p)\r\n{\r\nreturn container_of(task_subsys_state(p, net_cls_subsys_id),\r\nstruct cgroup_cls_state, css);\r\n}\r\nstatic struct cgroup_subsys_state *cgrp_create(struct cgroup_subsys *ss,\r\nstruct cgroup *cgrp)\r\n{\r\nstruct cgroup_cls_state *cs;\r\ncs = kzalloc(sizeof(*cs), GFP_KERNEL);\r\nif (!cs)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (cgrp->parent)\r\ncs->classid = cgrp_cls_state(cgrp->parent)->classid;\r\nreturn &cs->css;\r\n}\r\nstatic void cgrp_destroy(struct cgroup_subsys *ss, struct cgroup *cgrp)\r\n{\r\nkfree(cgrp_cls_state(cgrp));\r\n}\r\nstatic u64 read_classid(struct cgroup *cgrp, struct cftype *cft)\r\n{\r\nreturn cgrp_cls_state(cgrp)->classid;\r\n}\r\nstatic int write_classid(struct cgroup *cgrp, struct cftype *cft, u64 value)\r\n{\r\ncgrp_cls_state(cgrp)->classid = (u32) value;\r\nreturn 0;\r\n}\r\nstatic int cgrp_populate(struct cgroup_subsys *ss, struct cgroup *cgrp)\r\n{\r\nreturn cgroup_add_files(cgrp, ss, ss_files, ARRAY_SIZE(ss_files));\r\n}\r\nstatic int cls_cgroup_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct cls_cgroup_head *head = tp->root;\r\nu32 classid;\r\nrcu_read_lock();\r\nclassid = task_cls_state(current)->classid;\r\nrcu_read_unlock();\r\nif (in_serving_softirq()) {\r\nif (!skb->sk)\r\nreturn -1;\r\nclassid = skb->sk->sk_classid;\r\n}\r\nif (!classid)\r\nreturn -1;\r\nif (!tcf_em_tree_match(skb, &head->ematches, NULL))\r\nreturn -1;\r\nres->classid = classid;\r\nres->class = 0;\r\nreturn tcf_exts_exec(skb, &head->exts, res);\r\n}\r\nstatic unsigned long cls_cgroup_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nreturn 0UL;\r\n}\r\nstatic void cls_cgroup_put(struct tcf_proto *tp, unsigned long f)\r\n{\r\n}\r\nstatic int cls_cgroup_init(struct tcf_proto *tp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cls_cgroup_change(struct tcf_proto *tp, unsigned long base,\r\nu32 handle, struct nlattr **tca,\r\nunsigned long *arg)\r\n{\r\nstruct nlattr *tb[TCA_CGROUP_MAX + 1];\r\nstruct cls_cgroup_head *head = tp->root;\r\nstruct tcf_ematch_tree t;\r\nstruct tcf_exts e;\r\nint err;\r\nif (!tca[TCA_OPTIONS])\r\nreturn -EINVAL;\r\nif (head == NULL) {\r\nif (!handle)\r\nreturn -EINVAL;\r\nhead = kzalloc(sizeof(*head), GFP_KERNEL);\r\nif (head == NULL)\r\nreturn -ENOBUFS;\r\nhead->handle = handle;\r\ntcf_tree_lock(tp);\r\ntp->root = head;\r\ntcf_tree_unlock(tp);\r\n}\r\nif (handle != head->handle)\r\nreturn -ENOENT;\r\nerr = nla_parse_nested(tb, TCA_CGROUP_MAX, tca[TCA_OPTIONS],\r\ncgroup_policy);\r\nif (err < 0)\r\nreturn err;\r\nerr = tcf_exts_validate(tp, tb, tca[TCA_RATE], &e, &cgroup_ext_map);\r\nif (err < 0)\r\nreturn err;\r\nerr = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &t);\r\nif (err < 0)\r\nreturn err;\r\ntcf_exts_change(tp, &head->exts, &e);\r\ntcf_em_tree_change(tp, &head->ematches, &t);\r\nreturn 0;\r\n}\r\nstatic void cls_cgroup_destroy(struct tcf_proto *tp)\r\n{\r\nstruct cls_cgroup_head *head = tp->root;\r\nif (head) {\r\ntcf_exts_destroy(tp, &head->exts);\r\ntcf_em_tree_destroy(tp, &head->ematches);\r\nkfree(head);\r\n}\r\n}\r\nstatic int cls_cgroup_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void cls_cgroup_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct cls_cgroup_head *head = tp->root;\r\nif (arg->count < arg->skip)\r\ngoto skip;\r\nif (arg->fn(tp, (unsigned long) head, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\nskip:\r\narg->count++;\r\n}\r\nstatic int cls_cgroup_dump(struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct cls_cgroup_head *head = tp->root;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nt->tcm_handle = head->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &head->exts, &cgroup_ext_map) < 0 ||\r\ntcf_em_tree_dump(skb, &head->ematches, TCA_CGROUP_EMATCHES) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &head->exts, &cgroup_ext_map) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init init_cgroup_cls(void)\r\n{\r\nint ret;\r\nret = cgroup_load_subsys(&net_cls_subsys);\r\nif (ret)\r\ngoto out;\r\n#ifndef CONFIG_NET_CLS_CGROUP\r\nsmp_wmb();\r\nnet_cls_subsys_id = net_cls_subsys.subsys_id;\r\n#endif\r\nret = register_tcf_proto_ops(&cls_cgroup_ops);\r\nif (ret)\r\ncgroup_unload_subsys(&net_cls_subsys);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit exit_cgroup_cls(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_cgroup_ops);\r\n#ifndef CONFIG_NET_CLS_CGROUP\r\nnet_cls_subsys_id = -1;\r\nsynchronize_rcu();\r\n#endif\r\ncgroup_unload_subsys(&net_cls_subsys);\r\n}
