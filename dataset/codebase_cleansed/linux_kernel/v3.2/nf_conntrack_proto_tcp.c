static bool tcp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct tcphdr *hp;\r\nstruct tcphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, 8, &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->src.u.tcp.port = hp->source;\r\ntuple->dst.u.tcp.port = hp->dest;\r\nreturn true;\r\n}\r\nstatic bool tcp_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u.tcp.port = orig->dst.u.tcp.port;\r\ntuple->dst.u.tcp.port = orig->src.u.tcp.port;\r\nreturn true;\r\n}\r\nstatic int tcp_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "sport=%hu dport=%hu ",\r\nntohs(tuple->src.u.tcp.port),\r\nntohs(tuple->dst.u.tcp.port));\r\n}\r\nstatic int tcp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\r\n{\r\nenum tcp_conntrack state;\r\nspin_lock_bh(&ct->lock);\r\nstate = ct->proto.tcp.state;\r\nspin_unlock_bh(&ct->lock);\r\nreturn seq_printf(s, "%s ", tcp_conntrack_names[state]);\r\n}\r\nstatic unsigned int get_conntrack_index(const struct tcphdr *tcph)\r\n{\r\nif (tcph->rst) return TCP_RST_SET;\r\nelse if (tcph->syn) return (tcph->ack ? TCP_SYNACK_SET : TCP_SYN_SET);\r\nelse if (tcph->fin) return TCP_FIN_SET;\r\nelse if (tcph->ack) return TCP_ACK_SET;\r\nelse return TCP_NONE_SET;\r\n}\r\nstatic inline __u32 segment_seq_plus_len(__u32 seq,\r\nsize_t len,\r\nunsigned int dataoff,\r\nconst struct tcphdr *tcph)\r\n{\r\nreturn (seq + len - dataoff - tcph->doff*4\r\n+ (tcph->syn ? 1 : 0) + (tcph->fin ? 1 : 0));\r\n}\r\nstatic void tcp_options(const struct sk_buff *skb,\r\nunsigned int dataoff,\r\nconst struct tcphdr *tcph,\r\nstruct ip_ct_tcp_state *state)\r\n{\r\nunsigned char buff[(15 * 4) - sizeof(struct tcphdr)];\r\nconst unsigned char *ptr;\r\nint length = (tcph->doff*4) - sizeof(struct tcphdr);\r\nif (!length)\r\nreturn;\r\nptr = skb_header_pointer(skb, dataoff + sizeof(struct tcphdr),\r\nlength, buff);\r\nBUG_ON(ptr == NULL);\r\nstate->td_scale =\r\nstate->flags = 0;\r\nwhile (length > 0) {\r\nint opcode=*ptr++;\r\nint opsize;\r\nswitch (opcode) {\r\ncase TCPOPT_EOL:\r\nreturn;\r\ncase TCPOPT_NOP:\r\nlength--;\r\ncontinue;\r\ndefault:\r\nopsize=*ptr++;\r\nif (opsize < 2)\r\nreturn;\r\nif (opsize > length)\r\nreturn;\r\nif (opcode == TCPOPT_SACK_PERM\r\n&& opsize == TCPOLEN_SACK_PERM)\r\nstate->flags |= IP_CT_TCP_FLAG_SACK_PERM;\r\nelse if (opcode == TCPOPT_WINDOW\r\n&& opsize == TCPOLEN_WINDOW) {\r\nstate->td_scale = *(u_int8_t *)ptr;\r\nif (state->td_scale > 14) {\r\nstate->td_scale = 14;\r\n}\r\nstate->flags |=\r\nIP_CT_TCP_FLAG_WINDOW_SCALE;\r\n}\r\nptr += opsize - 2;\r\nlength -= opsize;\r\n}\r\n}\r\n}\r\nstatic void tcp_sack(const struct sk_buff *skb, unsigned int dataoff,\r\nconst struct tcphdr *tcph, __u32 *sack)\r\n{\r\nunsigned char buff[(15 * 4) - sizeof(struct tcphdr)];\r\nconst unsigned char *ptr;\r\nint length = (tcph->doff*4) - sizeof(struct tcphdr);\r\n__u32 tmp;\r\nif (!length)\r\nreturn;\r\nptr = skb_header_pointer(skb, dataoff + sizeof(struct tcphdr),\r\nlength, buff);\r\nBUG_ON(ptr == NULL);\r\nif (length == TCPOLEN_TSTAMP_ALIGNED\r\n&& *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)\r\n| (TCPOPT_NOP << 16)\r\n| (TCPOPT_TIMESTAMP << 8)\r\n| TCPOLEN_TIMESTAMP))\r\nreturn;\r\nwhile (length > 0) {\r\nint opcode = *ptr++;\r\nint opsize, i;\r\nswitch (opcode) {\r\ncase TCPOPT_EOL:\r\nreturn;\r\ncase TCPOPT_NOP:\r\nlength--;\r\ncontinue;\r\ndefault:\r\nopsize = *ptr++;\r\nif (opsize < 2)\r\nreturn;\r\nif (opsize > length)\r\nreturn;\r\nif (opcode == TCPOPT_SACK\r\n&& opsize >= (TCPOLEN_SACK_BASE\r\n+ TCPOLEN_SACK_PERBLOCK)\r\n&& !((opsize - TCPOLEN_SACK_BASE)\r\n% TCPOLEN_SACK_PERBLOCK)) {\r\nfor (i = 0;\r\ni < (opsize - TCPOLEN_SACK_BASE);\r\ni += TCPOLEN_SACK_PERBLOCK) {\r\ntmp = get_unaligned_be32((__be32 *)(ptr+i)+1);\r\nif (after(tmp, *sack))\r\n*sack = tmp;\r\n}\r\nreturn;\r\n}\r\nptr += opsize - 2;\r\nlength -= opsize;\r\n}\r\n}\r\n}\r\nstatic inline s16 nat_offset(const struct nf_conn *ct,\r\nenum ip_conntrack_dir dir,\r\nu32 seq)\r\n{\r\ntypeof(nf_ct_nat_offset) get_offset = rcu_dereference(nf_ct_nat_offset);\r\nreturn get_offset != NULL ? get_offset(ct, dir, seq) : 0;\r\n}\r\nstatic bool tcp_in_window(const struct nf_conn *ct,\r\nstruct ip_ct_tcp *state,\r\nenum ip_conntrack_dir dir,\r\nunsigned int index,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nconst struct tcphdr *tcph,\r\nu_int8_t pf)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct ip_ct_tcp_state *sender = &state->seen[dir];\r\nstruct ip_ct_tcp_state *receiver = &state->seen[!dir];\r\nconst struct nf_conntrack_tuple *tuple = &ct->tuplehash[dir].tuple;\r\n__u32 seq, ack, sack, end, win, swin;\r\ns16 receiver_offset;\r\nbool res;\r\nseq = ntohl(tcph->seq);\r\nack = sack = ntohl(tcph->ack_seq);\r\nwin = ntohs(tcph->window);\r\nend = segment_seq_plus_len(seq, skb->len, dataoff, tcph);\r\nif (receiver->flags & IP_CT_TCP_FLAG_SACK_PERM)\r\ntcp_sack(skb, dataoff, tcph, &sack);\r\nreceiver_offset = NAT_OFFSET(pf, ct, !dir, ack - 1);\r\nack -= receiver_offset;\r\nsack -= receiver_offset;\r\npr_debug("tcp_in_window: START\n");\r\npr_debug("tcp_in_window: ");\r\nnf_ct_dump_tuple(tuple);\r\npr_debug("seq=%u ack=%u+(%d) sack=%u+(%d) win=%u end=%u\n",\r\nseq, ack, receiver_offset, sack, receiver_offset, win, end);\r\npr_debug("tcp_in_window: sender end=%u maxend=%u maxwin=%u scale=%i "\r\n"receiver end=%u maxend=%u maxwin=%u scale=%i\n",\r\nsender->td_end, sender->td_maxend, sender->td_maxwin,\r\nsender->td_scale,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin,\r\nreceiver->td_scale);\r\nif (sender->td_maxwin == 0) {\r\nif (tcph->syn) {\r\nsender->td_end =\r\nsender->td_maxend = end;\r\nsender->td_maxwin = (win == 0 ? 1 : win);\r\ntcp_options(skb, dataoff, tcph, sender);\r\nif (!(sender->flags & IP_CT_TCP_FLAG_WINDOW_SCALE\r\n&& receiver->flags & IP_CT_TCP_FLAG_WINDOW_SCALE))\r\nsender->td_scale =\r\nreceiver->td_scale = 0;\r\nif (!tcph->ack)\r\nreturn true;\r\n} else {\r\nsender->td_end = end;\r\nwin <<= sender->td_scale;\r\nsender->td_maxwin = (win == 0 ? 1 : win);\r\nsender->td_maxend = end + sender->td_maxwin;\r\nif (receiver->td_maxwin == 0)\r\nreceiver->td_end = receiver->td_maxend = sack;\r\n}\r\n} else if (((state->state == TCP_CONNTRACK_SYN_SENT\r\n&& dir == IP_CT_DIR_ORIGINAL)\r\n|| (state->state == TCP_CONNTRACK_SYN_RECV\r\n&& dir == IP_CT_DIR_REPLY))\r\n&& after(end, sender->td_end)) {\r\nsender->td_end =\r\nsender->td_maxend = end;\r\nsender->td_maxwin = (win == 0 ? 1 : win);\r\ntcp_options(skb, dataoff, tcph, sender);\r\n}\r\nif (!(tcph->ack)) {\r\nack = sack = receiver->td_end;\r\n} else if (((tcp_flag_word(tcph) & (TCP_FLAG_ACK|TCP_FLAG_RST)) ==\r\n(TCP_FLAG_ACK|TCP_FLAG_RST))\r\n&& (ack == 0)) {\r\nack = sack = receiver->td_end;\r\n}\r\nif (seq == end\r\n&& (!tcph->rst\r\n|| (seq == 0 && state->state == TCP_CONNTRACK_SYN_SENT)))\r\nseq = end = sender->td_end;\r\npr_debug("tcp_in_window: ");\r\nnf_ct_dump_tuple(tuple);\r\npr_debug("seq=%u ack=%u+(%d) sack=%u+(%d) win=%u end=%u\n",\r\nseq, ack, receiver_offset, sack, receiver_offset, win, end);\r\npr_debug("tcp_in_window: sender end=%u maxend=%u maxwin=%u scale=%i "\r\n"receiver end=%u maxend=%u maxwin=%u scale=%i\n",\r\nsender->td_end, sender->td_maxend, sender->td_maxwin,\r\nsender->td_scale,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin,\r\nreceiver->td_scale);\r\npr_debug("tcp_in_window: I=%i II=%i III=%i IV=%i\n",\r\nbefore(seq, sender->td_maxend + 1),\r\nafter(end, sender->td_end - receiver->td_maxwin - 1),\r\nbefore(sack, receiver->td_end + 1),\r\nafter(sack, receiver->td_end - MAXACKWINDOW(sender) - 1));\r\nif (before(seq, sender->td_maxend + 1) &&\r\nafter(end, sender->td_end - receiver->td_maxwin - 1) &&\r\nbefore(sack, receiver->td_end + 1) &&\r\nafter(sack, receiver->td_end - MAXACKWINDOW(sender) - 1)) {\r\nif (!tcph->syn)\r\nwin <<= sender->td_scale;\r\nswin = win + (sack - ack);\r\nif (sender->td_maxwin < swin)\r\nsender->td_maxwin = swin;\r\nif (after(end, sender->td_end)) {\r\nsender->td_end = end;\r\nsender->flags |= IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;\r\n}\r\nif (tcph->ack) {\r\nif (!(sender->flags & IP_CT_TCP_FLAG_MAXACK_SET)) {\r\nsender->td_maxack = ack;\r\nsender->flags |= IP_CT_TCP_FLAG_MAXACK_SET;\r\n} else if (after(ack, sender->td_maxack))\r\nsender->td_maxack = ack;\r\n}\r\nif (receiver->td_maxwin != 0 && after(end, sender->td_maxend))\r\nreceiver->td_maxwin += end - sender->td_maxend;\r\nif (after(sack + win, receiver->td_maxend - 1)) {\r\nreceiver->td_maxend = sack + win;\r\nif (win == 0)\r\nreceiver->td_maxend++;\r\n}\r\nif (ack == receiver->td_end)\r\nreceiver->flags &= ~IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;\r\nif (index == TCP_ACK_SET) {\r\nif (state->last_dir == dir\r\n&& state->last_seq == seq\r\n&& state->last_ack == ack\r\n&& state->last_end == end\r\n&& state->last_win == win)\r\nstate->retrans++;\r\nelse {\r\nstate->last_dir = dir;\r\nstate->last_seq = seq;\r\nstate->last_ack = ack;\r\nstate->last_end = end;\r\nstate->last_win = win;\r\nstate->retrans = 0;\r\n}\r\n}\r\nres = true;\r\n} else {\r\nres = false;\r\nif (sender->flags & IP_CT_TCP_FLAG_BE_LIBERAL ||\r\nnf_ct_tcp_be_liberal)\r\nres = true;\r\nif (!res && LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: %s ",\r\nbefore(seq, sender->td_maxend + 1) ?\r\nafter(end, sender->td_end - receiver->td_maxwin - 1) ?\r\nbefore(sack, receiver->td_end + 1) ?\r\nafter(sack, receiver->td_end - MAXACKWINDOW(sender) - 1) ? "BUG"\r\n: "ACK is under the lower bound (possible overly delayed ACK)"\r\n: "ACK is over the upper bound (ACKed data not seen yet)"\r\n: "SEQ is under the lower bound (already ACKed data retransmitted)"\r\n: "SEQ is over the upper bound (over the window of the receiver)");\r\n}\r\npr_debug("tcp_in_window: res=%u sender end=%u maxend=%u maxwin=%u "\r\n"receiver end=%u maxend=%u maxwin=%u\n",\r\nres, sender->td_end, sender->td_maxend, sender->td_maxwin,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin);\r\nreturn res;\r\n}\r\nstatic int tcp_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info *ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nunsigned int tcplen = skb->len - dataoff;\r\nu_int8_t tcpflags;\r\nth = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: short packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (th->doff*4 < sizeof(struct tcphdr) || tcplen < th->doff*4) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: truncated/malformed packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_checksum(skb, hooknum, dataoff, IPPROTO_TCP, pf)) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: bad TCP checksum ");\r\nreturn -NF_ACCEPT;\r\n}\r\ntcpflags = (tcp_flag_byte(th) & ~(TCPHDR_ECE|TCPHDR_CWR|TCPHDR_PSH));\r\nif (!tcp_valid_flags[tcpflags]) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid TCP flag combination ");\r\nreturn -NF_ACCEPT;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int tcp_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct nf_conntrack_tuple *tuple;\r\nenum tcp_conntrack new_state, old_state;\r\nenum ip_conntrack_dir dir;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nunsigned long timeout;\r\nunsigned int index;\r\nth = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);\r\nBUG_ON(th == NULL);\r\nspin_lock_bh(&ct->lock);\r\nold_state = ct->proto.tcp.state;\r\ndir = CTINFO2DIR(ctinfo);\r\nindex = get_conntrack_index(th);\r\nnew_state = tcp_conntracks[dir][index][old_state];\r\ntuple = &ct->tuplehash[dir].tuple;\r\nswitch (new_state) {\r\ncase TCP_CONNTRACK_SYN_SENT:\r\nif (old_state < TCP_CONNTRACK_TIME_WAIT)\r\nbreak;\r\nif (((ct->proto.tcp.seen[dir].flags\r\n| ct->proto.tcp.seen[!dir].flags)\r\n& IP_CT_TCP_FLAG_CLOSE_INIT)\r\n|| (ct->proto.tcp.last_dir == dir\r\n&& ct->proto.tcp.last_index == TCP_RST_SET)) {\r\nspin_unlock_bh(&ct->lock);\r\nif (nf_ct_kill(ct))\r\nreturn -NF_REPEAT;\r\nreturn NF_DROP;\r\n}\r\ncase TCP_CONNTRACK_IGNORE:\r\nif (index == TCP_SYNACK_SET\r\n&& ct->proto.tcp.last_index == TCP_SYN_SET\r\n&& ct->proto.tcp.last_dir != dir\r\n&& ntohl(th->ack_seq) == ct->proto.tcp.last_end) {\r\nold_state = TCP_CONNTRACK_SYN_SENT;\r\nnew_state = TCP_CONNTRACK_SYN_RECV;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_end =\r\nct->proto.tcp.last_end;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxend =\r\nct->proto.tcp.last_end;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxwin =\r\nct->proto.tcp.last_win == 0 ?\r\n1 : ct->proto.tcp.last_win;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_scale =\r\nct->proto.tcp.last_wscale;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].flags =\r\nct->proto.tcp.last_flags;\r\nmemset(&ct->proto.tcp.seen[dir], 0,\r\nsizeof(struct ip_ct_tcp_state));\r\nbreak;\r\n}\r\nct->proto.tcp.last_index = index;\r\nct->proto.tcp.last_dir = dir;\r\nct->proto.tcp.last_seq = ntohl(th->seq);\r\nct->proto.tcp.last_end =\r\nsegment_seq_plus_len(ntohl(th->seq), skb->len, dataoff, th);\r\nct->proto.tcp.last_win = ntohs(th->window);\r\nif (index == TCP_SYN_SET && dir == IP_CT_DIR_ORIGINAL) {\r\nstruct ip_ct_tcp_state seen = {};\r\nct->proto.tcp.last_flags =\r\nct->proto.tcp.last_wscale = 0;\r\ntcp_options(skb, dataoff, th, &seen);\r\nif (seen.flags & IP_CT_TCP_FLAG_WINDOW_SCALE) {\r\nct->proto.tcp.last_flags |=\r\nIP_CT_TCP_FLAG_WINDOW_SCALE;\r\nct->proto.tcp.last_wscale = seen.td_scale;\r\n}\r\nif (seen.flags & IP_CT_TCP_FLAG_SACK_PERM) {\r\nct->proto.tcp.last_flags |=\r\nIP_CT_TCP_FLAG_SACK_PERM;\r\n}\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid packet ignored ");\r\nreturn NF_ACCEPT;\r\ncase TCP_CONNTRACK_MAX:\r\npr_debug("nf_ct_tcp: Invalid dir=%i index=%u ostate=%u\n",\r\ndir, get_conntrack_index(th), old_state);\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid state ");\r\nreturn -NF_ACCEPT;\r\ncase TCP_CONNTRACK_CLOSE:\r\nif (index == TCP_RST_SET\r\n&& (ct->proto.tcp.seen[!dir].flags & IP_CT_TCP_FLAG_MAXACK_SET)\r\n&& before(ntohl(th->seq), ct->proto.tcp.seen[!dir].td_maxack)) {\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid RST ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (index == TCP_RST_SET\r\n&& ((test_bit(IPS_SEEN_REPLY_BIT, &ct->status)\r\n&& ct->proto.tcp.last_index == TCP_SYN_SET)\r\n|| (!test_bit(IPS_ASSURED_BIT, &ct->status)\r\n&& ct->proto.tcp.last_index == TCP_ACK_SET))\r\n&& ntohl(th->ack_seq) == ct->proto.tcp.last_end) {\r\ngoto in_window;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (!tcp_in_window(ct, &ct->proto.tcp, dir, index,\r\nskb, dataoff, th, pf)) {\r\nspin_unlock_bh(&ct->lock);\r\nreturn -NF_ACCEPT;\r\n}\r\nin_window:\r\nct->proto.tcp.last_index = index;\r\nct->proto.tcp.last_dir = dir;\r\npr_debug("tcp_conntracks: ");\r\nnf_ct_dump_tuple(tuple);\r\npr_debug("syn=%i ack=%i fin=%i rst=%i old=%i new=%i\n",\r\n(th->syn ? 1 : 0), (th->ack ? 1 : 0),\r\n(th->fin ? 1 : 0), (th->rst ? 1 : 0),\r\nold_state, new_state);\r\nct->proto.tcp.state = new_state;\r\nif (old_state != new_state\r\n&& new_state == TCP_CONNTRACK_FIN_WAIT)\r\nct->proto.tcp.seen[dir].flags |= IP_CT_TCP_FLAG_CLOSE_INIT;\r\nif (ct->proto.tcp.retrans >= nf_ct_tcp_max_retrans &&\r\ntcp_timeouts[new_state] > nf_ct_tcp_timeout_max_retrans)\r\ntimeout = nf_ct_tcp_timeout_max_retrans;\r\nelse if ((ct->proto.tcp.seen[0].flags | ct->proto.tcp.seen[1].flags) &\r\nIP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED &&\r\ntcp_timeouts[new_state] > nf_ct_tcp_timeout_unacknowledged)\r\ntimeout = nf_ct_tcp_timeout_unacknowledged;\r\nelse\r\ntimeout = tcp_timeouts[new_state];\r\nspin_unlock_bh(&ct->lock);\r\nif (new_state != old_state)\r\nnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\r\nif (!test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\r\nif (th->rst) {\r\nnf_ct_kill_acct(ct, ctinfo, skb);\r\nreturn NF_ACCEPT;\r\n}\r\n} else if (!test_bit(IPS_ASSURED_BIT, &ct->status)\r\n&& (old_state == TCP_CONNTRACK_SYN_RECV\r\n|| old_state == TCP_CONNTRACK_ESTABLISHED)\r\n&& new_state == TCP_CONNTRACK_ESTABLISHED) {\r\nset_bit(IPS_ASSURED_BIT, &ct->status);\r\nnf_conntrack_event_cache(IPCT_ASSURED, ct);\r\n}\r\nnf_ct_refresh_acct(ct, ctinfo, skb, timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff)\r\n{\r\nenum tcp_conntrack new_state;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nconst struct ip_ct_tcp_state *sender = &ct->proto.tcp.seen[0];\r\nconst struct ip_ct_tcp_state *receiver = &ct->proto.tcp.seen[1];\r\nth = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);\r\nBUG_ON(th == NULL);\r\nnew_state = tcp_conntracks[0][get_conntrack_index(th)][TCP_CONNTRACK_NONE];\r\nif (new_state >= TCP_CONNTRACK_MAX) {\r\npr_debug("nf_ct_tcp: invalid new deleting.\n");\r\nreturn false;\r\n}\r\nif (new_state == TCP_CONNTRACK_SYN_SENT) {\r\nmemset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));\r\nct->proto.tcp.seen[0].td_end =\r\nsegment_seq_plus_len(ntohl(th->seq), skb->len,\r\ndataoff, th);\r\nct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);\r\nif (ct->proto.tcp.seen[0].td_maxwin == 0)\r\nct->proto.tcp.seen[0].td_maxwin = 1;\r\nct->proto.tcp.seen[0].td_maxend =\r\nct->proto.tcp.seen[0].td_end;\r\ntcp_options(skb, dataoff, th, &ct->proto.tcp.seen[0]);\r\n} else if (nf_ct_tcp_loose == 0) {\r\nreturn false;\r\n} else {\r\nmemset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));\r\nct->proto.tcp.seen[0].td_end =\r\nsegment_seq_plus_len(ntohl(th->seq), skb->len,\r\ndataoff, th);\r\nct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);\r\nif (ct->proto.tcp.seen[0].td_maxwin == 0)\r\nct->proto.tcp.seen[0].td_maxwin = 1;\r\nct->proto.tcp.seen[0].td_maxend =\r\nct->proto.tcp.seen[0].td_end +\r\nct->proto.tcp.seen[0].td_maxwin;\r\nct->proto.tcp.seen[0].flags =\r\nct->proto.tcp.seen[1].flags = IP_CT_TCP_FLAG_SACK_PERM |\r\nIP_CT_TCP_FLAG_BE_LIBERAL;\r\n}\r\nct->proto.tcp.last_index = TCP_NONE_SET;\r\npr_debug("tcp_new: sender end=%u maxend=%u maxwin=%u scale=%i "\r\n"receiver end=%u maxend=%u maxwin=%u scale=%i\n",\r\nsender->td_end, sender->td_maxend, sender->td_maxwin,\r\nsender->td_scale,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin,\r\nreceiver->td_scale);\r\nreturn true;\r\n}\r\nstatic int tcp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\r\nstruct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_parms;\r\nstruct nf_ct_tcp_flags tmp = {};\r\nspin_lock_bh(&ct->lock);\r\nnest_parms = nla_nest_start(skb, CTA_PROTOINFO_TCP | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nNLA_PUT_U8(skb, CTA_PROTOINFO_TCP_STATE, ct->proto.tcp.state);\r\nNLA_PUT_U8(skb, CTA_PROTOINFO_TCP_WSCALE_ORIGINAL,\r\nct->proto.tcp.seen[0].td_scale);\r\nNLA_PUT_U8(skb, CTA_PROTOINFO_TCP_WSCALE_REPLY,\r\nct->proto.tcp.seen[1].td_scale);\r\ntmp.flags = ct->proto.tcp.seen[0].flags;\r\nNLA_PUT(skb, CTA_PROTOINFO_TCP_FLAGS_ORIGINAL,\r\nsizeof(struct nf_ct_tcp_flags), &tmp);\r\ntmp.flags = ct->proto.tcp.seen[1].flags;\r\nNLA_PUT(skb, CTA_PROTOINFO_TCP_FLAGS_REPLY,\r\nsizeof(struct nf_ct_tcp_flags), &tmp);\r\nspin_unlock_bh(&ct->lock);\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nspin_unlock_bh(&ct->lock);\r\nreturn -1;\r\n}\r\nstatic int nlattr_to_tcp(struct nlattr *cda[], struct nf_conn *ct)\r\n{\r\nstruct nlattr *pattr = cda[CTA_PROTOINFO_TCP];\r\nstruct nlattr *tb[CTA_PROTOINFO_TCP_MAX+1];\r\nint err;\r\nif (!pattr)\r\nreturn 0;\r\nerr = nla_parse_nested(tb, CTA_PROTOINFO_TCP_MAX, pattr, tcp_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[CTA_PROTOINFO_TCP_STATE] &&\r\nnla_get_u8(tb[CTA_PROTOINFO_TCP_STATE]) >= TCP_CONNTRACK_MAX)\r\nreturn -EINVAL;\r\nspin_lock_bh(&ct->lock);\r\nif (tb[CTA_PROTOINFO_TCP_STATE])\r\nct->proto.tcp.state = nla_get_u8(tb[CTA_PROTOINFO_TCP_STATE]);\r\nif (tb[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]) {\r\nstruct nf_ct_tcp_flags *attr =\r\nnla_data(tb[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]);\r\nct->proto.tcp.seen[0].flags &= ~attr->mask;\r\nct->proto.tcp.seen[0].flags |= attr->flags & attr->mask;\r\n}\r\nif (tb[CTA_PROTOINFO_TCP_FLAGS_REPLY]) {\r\nstruct nf_ct_tcp_flags *attr =\r\nnla_data(tb[CTA_PROTOINFO_TCP_FLAGS_REPLY]);\r\nct->proto.tcp.seen[1].flags &= ~attr->mask;\r\nct->proto.tcp.seen[1].flags |= attr->flags & attr->mask;\r\n}\r\nif (tb[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL] &&\r\ntb[CTA_PROTOINFO_TCP_WSCALE_REPLY] &&\r\nct->proto.tcp.seen[0].flags & IP_CT_TCP_FLAG_WINDOW_SCALE &&\r\nct->proto.tcp.seen[1].flags & IP_CT_TCP_FLAG_WINDOW_SCALE) {\r\nct->proto.tcp.seen[0].td_scale =\r\nnla_get_u8(tb[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL]);\r\nct->proto.tcp.seen[1].td_scale =\r\nnla_get_u8(tb[CTA_PROTOINFO_TCP_WSCALE_REPLY]);\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nreturn 0;\r\n}\r\nstatic int tcp_nlattr_size(void)\r\n{\r\nreturn nla_total_size(0)\r\n+ nla_policy_len(tcp_nla_policy, CTA_PROTOINFO_TCP_MAX + 1);\r\n}\r\nstatic int tcp_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(nf_ct_port_nla_policy, CTA_PROTO_MAX + 1);\r\n}
