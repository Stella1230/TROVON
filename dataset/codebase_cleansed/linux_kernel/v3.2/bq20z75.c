static int bq20z75_read_word_data(struct i2c_client *client, u8 address)\r\n{\r\nstruct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);\r\ns32 ret = 0;\r\nint retries = 1;\r\nif (bq20z75_device->pdata)\r\nretries = max(bq20z75_device->pdata->i2c_retry_count + 1, 1);\r\nwhile (retries > 0) {\r\nret = i2c_smbus_read_word_data(client, address);\r\nif (ret >= 0)\r\nbreak;\r\nretries--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c read at address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nreturn le16_to_cpu(ret);\r\n}\r\nstatic int bq20z75_write_word_data(struct i2c_client *client, u8 address,\r\nu16 value)\r\n{\r\nstruct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);\r\ns32 ret = 0;\r\nint retries = 1;\r\nif (bq20z75_device->pdata)\r\nretries = max(bq20z75_device->pdata->i2c_retry_count + 1, 1);\r\nwhile (retries > 0) {\r\nret = i2c_smbus_write_word_data(client, address,\r\nle16_to_cpu(value));\r\nif (ret >= 0)\r\nbreak;\r\nretries--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c write to address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq20z75_get_battery_presence_and_health(\r\nstruct i2c_client *client, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\ns32 ret;\r\nstruct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);\r\nif (psp == POWER_SUPPLY_PROP_PRESENT &&\r\nbq20z75_device->gpio_detect) {\r\nret = gpio_get_value(\r\nbq20z75_device->pdata->battery_detect);\r\nif (ret == bq20z75_device->pdata->battery_detect_present)\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nbq20z75_device->is_present = val->intval;\r\nreturn ret;\r\n}\r\nret = bq20z75_write_word_data(client,\r\nbq20z75_data[REG_MANUFACTURER_DATA].addr,\r\nMANUFACTURER_ACCESS_STATUS);\r\nif (ret < 0) {\r\nif (psp == POWER_SUPPLY_PROP_PRESENT)\r\nval->intval = 0;\r\nreturn ret;\r\n}\r\nret = bq20z75_read_word_data(client,\r\nbq20z75_data[REG_MANUFACTURER_DATA].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret < bq20z75_data[REG_MANUFACTURER_DATA].min_value ||\r\nret > bq20z75_data[REG_MANUFACTURER_DATA].max_value) {\r\nval->intval = 0;\r\nreturn 0;\r\n}\r\nret &= 0x0F00;\r\nret >>= 8;\r\nif (psp == POWER_SUPPLY_PROP_PRESENT) {\r\nif (ret == 0x0F)\r\nval->intval = 0;\r\nelse\r\nval->intval = 1;\r\n} else if (psp == POWER_SUPPLY_PROP_HEALTH) {\r\nif (ret == 0x09)\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nelse if (ret == 0x0B)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (ret == 0x0C)\r\nval->intval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq20z75_get_battery_property(struct i2c_client *client,\r\nint reg_offset, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);\r\ns32 ret;\r\nret = bq20z75_read_word_data(client,\r\nbq20z75_data[reg_offset].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (bq20z75_data[reg_offset].min_value < 0)\r\nret = (s16)ret;\r\nif (ret >= bq20z75_data[reg_offset].min_value &&\r\nret <= bq20z75_data[reg_offset].max_value) {\r\nval->intval = ret;\r\nif (psp != POWER_SUPPLY_PROP_STATUS)\r\nreturn 0;\r\nif (ret & BATTERY_FULL_CHARGED)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse if (ret & BATTERY_FULL_DISCHARGED)\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (ret & BATTERY_DISCHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nif (bq20z75_device->poll_time == 0)\r\nbq20z75_device->last_state = val->intval;\r\nelse if (bq20z75_device->last_state != val->intval) {\r\ncancel_delayed_work_sync(&bq20z75_device->work);\r\npower_supply_changed(&bq20z75_device->power_supply);\r\nbq20z75_device->poll_time = 0;\r\n}\r\n} else {\r\nif (psp == POWER_SUPPLY_PROP_STATUS)\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nelse\r\nval->intval = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bq20z75_unit_adjustment(struct i2c_client *client,\r\nenum power_supply_property psp, union power_supply_propval *val)\r\n{\r\n#define BASE_UNIT_CONVERSION 1000\r\n#define BATTERY_MODE_CAP_MULT_WATT (10 * BASE_UNIT_CONVERSION)\r\n#define TIME_UNIT_CONVERSION 60\r\n#define TEMP_KELVIN_TO_CELSIUS 2731\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\nval->intval *= BATTERY_MODE_CAP_MULT_WATT;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval *= BASE_UNIT_CONVERSION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval -= TEMP_KELVIN_TO_CELSIUS;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\r\nval->intval *= TIME_UNIT_CONVERSION;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev,\r\n"%s: no need for unit conversion %d\n", __func__, psp);\r\n}\r\n}\r\nstatic enum bq20z75_battery_mode\r\nbq20z75_set_battery_mode(struct i2c_client *client,\r\nenum bq20z75_battery_mode mode)\r\n{\r\nint ret, original_val;\r\noriginal_val = bq20z75_read_word_data(client, BATTERY_MODE_OFFSET);\r\nif (original_val < 0)\r\nreturn original_val;\r\nif ((original_val & BATTERY_MODE_MASK) == mode)\r\nreturn mode;\r\nif (mode == BATTERY_MODE_AMPS)\r\nret = original_val & ~BATTERY_MODE_MASK;\r\nelse\r\nret = original_val | BATTERY_MODE_MASK;\r\nret = bq20z75_write_word_data(client, BATTERY_MODE_OFFSET, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn original_val & BATTERY_MODE_MASK;\r\n}\r\nstatic int bq20z75_get_battery_capacity(struct i2c_client *client,\r\nint reg_offset, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\ns32 ret;\r\nenum bq20z75_battery_mode mode = BATTERY_MODE_WATTS;\r\nif (power_supply_is_amp_property(psp))\r\nmode = BATTERY_MODE_AMPS;\r\nmode = bq20z75_set_battery_mode(client, mode);\r\nif (mode < 0)\r\nreturn mode;\r\nret = bq20z75_read_word_data(client, bq20z75_data[reg_offset].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (psp == POWER_SUPPLY_PROP_CAPACITY) {\r\nval->intval = min(ret, 100);\r\n} else\r\nval->intval = ret;\r\nret = bq20z75_set_battery_mode(client, mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int bq20z75_get_battery_serial_number(struct i2c_client *client,\r\nunion power_supply_propval *val)\r\n{\r\nint ret;\r\nret = bq20z75_read_word_data(client,\r\nbq20z75_data[REG_SERIAL_NUMBER].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sprintf(bq20z75_serial, "%04x", ret);\r\nval->strval = bq20z75_serial;\r\nreturn 0;\r\n}\r\nstatic int bq20z75_get_property_index(struct i2c_client *client,\r\nenum power_supply_property psp)\r\n{\r\nint count;\r\nfor (count = 0; count < ARRAY_SIZE(bq20z75_data); count++)\r\nif (psp == bq20z75_data[count].psp)\r\nreturn count;\r\ndev_warn(&client->dev,\r\n"%s: Invalid Property - %d\n", __func__, psp);\r\nreturn -EINVAL;\r\n}\r\nstatic int bq20z75_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct bq20z75_info *bq20z75_device = container_of(psy,\r\nstruct bq20z75_info, power_supply);\r\nstruct i2c_client *client = bq20z75_device->client;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nret = bq20z75_get_battery_presence_and_health(client, psp, val);\r\nif (psp == POWER_SUPPLY_PROP_PRESENT)\r\nreturn 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = bq20z75_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = bq20z75_get_battery_capacity(client, ret, psp, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SERIAL_NUMBER:\r\nret = bq20z75_get_battery_serial_number(client, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\ncase POWER_SUPPLY_PROP_CYCLE_COUNT:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_TEMP:\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nret = bq20z75_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = bq20z75_get_battery_property(client, ret, psp, val);\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"%s: INVALID property\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!bq20z75_device->enable_detection)\r\ngoto done;\r\nif (!bq20z75_device->gpio_detect &&\r\nbq20z75_device->is_present != (ret >= 0)) {\r\nbq20z75_device->is_present = (ret >= 0);\r\npower_supply_changed(&bq20z75_device->power_supply);\r\n}\r\ndone:\r\nif (!ret) {\r\nbq20z75_unit_adjustment(client, psp, val);\r\n}\r\ndev_dbg(&client->dev,\r\n"%s: property = %d, value = %x\n", __func__, psp, val->intval);\r\nif (ret && bq20z75_device->is_present)\r\nreturn ret;\r\nif (ret)\r\nreturn -ENODATA;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bq20z75_irq(int irq, void *devid)\r\n{\r\nstruct power_supply *battery = devid;\r\npower_supply_changed(battery);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bq20z75_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct bq20z75_info *bq20z75_device;\r\nbq20z75_device = container_of(psy, struct bq20z75_info, power_supply);\r\nif (bq20z75_device->ignore_changes > 0) {\r\nbq20z75_device->ignore_changes--;\r\nreturn;\r\n}\r\ncancel_delayed_work_sync(&bq20z75_device->work);\r\nschedule_delayed_work(&bq20z75_device->work, HZ);\r\nbq20z75_device->poll_time = bq20z75_device->pdata->poll_retry_count;\r\n}\r\nstatic void bq20z75_delayed_work(struct work_struct *work)\r\n{\r\nstruct bq20z75_info *bq20z75_device;\r\ns32 ret;\r\nbq20z75_device = container_of(work, struct bq20z75_info, work.work);\r\nret = bq20z75_read_word_data(bq20z75_device->client,\r\nbq20z75_data[REG_STATUS].addr);\r\nif (ret < 0) {\r\nbq20z75_device->poll_time = 0;\r\nreturn;\r\n}\r\nif (ret & BATTERY_FULL_CHARGED)\r\nret = POWER_SUPPLY_STATUS_FULL;\r\nelse if (ret & BATTERY_FULL_DISCHARGED)\r\nret = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (ret & BATTERY_DISCHARGING)\r\nret = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nret = POWER_SUPPLY_STATUS_CHARGING;\r\nif (bq20z75_device->last_state != ret) {\r\nbq20z75_device->poll_time = 0;\r\npower_supply_changed(&bq20z75_device->power_supply);\r\nreturn;\r\n}\r\nif (bq20z75_device->poll_time > 0) {\r\nschedule_delayed_work(&bq20z75_device->work, HZ);\r\nbq20z75_device->poll_time--;\r\nreturn;\r\n}\r\n}\r\nstatic int __devinit bq20z75_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bq20z75_info *bq20z75_device;\r\nstruct bq20z75_platform_data *pdata = client->dev.platform_data;\r\nint rc;\r\nint irq;\r\nbq20z75_device = kzalloc(sizeof(struct bq20z75_info), GFP_KERNEL);\r\nif (!bq20z75_device)\r\nreturn -ENOMEM;\r\nbq20z75_device->client = client;\r\nbq20z75_device->enable_detection = false;\r\nbq20z75_device->gpio_detect = false;\r\nbq20z75_device->power_supply.name = "battery";\r\nbq20z75_device->power_supply.type = POWER_SUPPLY_TYPE_BATTERY;\r\nbq20z75_device->power_supply.properties = bq20z75_properties;\r\nbq20z75_device->power_supply.num_properties =\r\nARRAY_SIZE(bq20z75_properties);\r\nbq20z75_device->power_supply.get_property = bq20z75_get_property;\r\nbq20z75_device->ignore_changes = 1;\r\nbq20z75_device->last_state = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbq20z75_device->power_supply.external_power_changed =\r\nbq20z75_external_power_changed;\r\nif (pdata) {\r\nbq20z75_device->gpio_detect =\r\ngpio_is_valid(pdata->battery_detect);\r\nbq20z75_device->pdata = pdata;\r\n}\r\ni2c_set_clientdata(client, bq20z75_device);\r\nif (!bq20z75_device->gpio_detect)\r\ngoto skip_gpio;\r\nrc = gpio_request(pdata->battery_detect, dev_name(&client->dev));\r\nif (rc) {\r\ndev_warn(&client->dev, "Failed to request gpio: %d\n", rc);\r\nbq20z75_device->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nrc = gpio_direction_input(pdata->battery_detect);\r\nif (rc) {\r\ndev_warn(&client->dev, "Failed to get gpio as input: %d\n", rc);\r\ngpio_free(pdata->battery_detect);\r\nbq20z75_device->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nirq = gpio_to_irq(pdata->battery_detect);\r\nif (irq <= 0) {\r\ndev_warn(&client->dev, "Failed to get gpio as irq: %d\n", irq);\r\ngpio_free(pdata->battery_detect);\r\nbq20z75_device->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nrc = request_irq(irq, bq20z75_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\ndev_name(&client->dev), &bq20z75_device->power_supply);\r\nif (rc) {\r\ndev_warn(&client->dev, "Failed to request irq: %d\n", rc);\r\ngpio_free(pdata->battery_detect);\r\nbq20z75_device->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nbq20z75_device->irq = irq;\r\nskip_gpio:\r\nrc = power_supply_register(&client->dev, &bq20z75_device->power_supply);\r\nif (rc) {\r\ndev_err(&client->dev,\r\n"%s: Failed to register power supply\n", __func__);\r\ngoto exit_psupply;\r\n}\r\ndev_info(&client->dev,\r\n"%s: battery gas gauge device registered\n", client->name);\r\nINIT_DELAYED_WORK(&bq20z75_device->work, bq20z75_delayed_work);\r\nbq20z75_device->enable_detection = true;\r\nreturn 0;\r\nexit_psupply:\r\nif (bq20z75_device->irq)\r\nfree_irq(bq20z75_device->irq, &bq20z75_device->power_supply);\r\nif (bq20z75_device->gpio_detect)\r\ngpio_free(pdata->battery_detect);\r\nkfree(bq20z75_device);\r\nreturn rc;\r\n}\r\nstatic int __devexit bq20z75_remove(struct i2c_client *client)\r\n{\r\nstruct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);\r\nif (bq20z75_device->irq)\r\nfree_irq(bq20z75_device->irq, &bq20z75_device->power_supply);\r\nif (bq20z75_device->gpio_detect)\r\ngpio_free(bq20z75_device->pdata->battery_detect);\r\npower_supply_unregister(&bq20z75_device->power_supply);\r\ncancel_delayed_work_sync(&bq20z75_device->work);\r\nkfree(bq20z75_device);\r\nbq20z75_device = NULL;\r\nreturn 0;\r\n}\r\nstatic int bq20z75_suspend(struct i2c_client *client,\r\npm_message_t state)\r\n{\r\nstruct bq20z75_info *bq20z75_device = i2c_get_clientdata(client);\r\ns32 ret;\r\nif (bq20z75_device->poll_time > 0)\r\ncancel_delayed_work_sync(&bq20z75_device->work);\r\nret = bq20z75_write_word_data(client,\r\nbq20z75_data[REG_MANUFACTURER_DATA].addr,\r\nMANUFACTURER_ACCESS_SLEEP);\r\nif (bq20z75_device->is_present && ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int __init bq20z75_battery_init(void)\r\n{\r\nreturn i2c_add_driver(&bq20z75_battery_driver);\r\n}\r\nstatic void __exit bq20z75_battery_exit(void)\r\n{\r\ni2c_del_driver(&bq20z75_battery_driver);\r\n}
