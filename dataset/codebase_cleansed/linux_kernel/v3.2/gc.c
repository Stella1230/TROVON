static struct jffs2_eraseblock *jffs2_find_gc_block(struct jffs2_sb_info *c)\r\n{\r\nstruct jffs2_eraseblock *ret;\r\nstruct list_head *nextlist = NULL;\r\nint n = jiffies % 128;\r\nagain:\r\nif (!list_empty(&c->bad_used_list) && c->nr_free_blocks > c->resv_blocks_gcbad) {\r\nD1(printk(KERN_DEBUG "Picking block from bad_used_list to GC next\n"));\r\nnextlist = &c->bad_used_list;\r\n} else if (n < 50 && !list_empty(&c->erasable_list)) {\r\nD1(printk(KERN_DEBUG "Picking block from erasable_list to GC next\n"));\r\nnextlist = &c->erasable_list;\r\n} else if (n < 110 && !list_empty(&c->very_dirty_list)) {\r\nD1(printk(KERN_DEBUG "Picking block from very_dirty_list to GC next\n"));\r\nnextlist = &c->very_dirty_list;\r\n} else if (n < 126 && !list_empty(&c->dirty_list)) {\r\nD1(printk(KERN_DEBUG "Picking block from dirty_list to GC next\n"));\r\nnextlist = &c->dirty_list;\r\n} else if (!list_empty(&c->clean_list)) {\r\nD1(printk(KERN_DEBUG "Picking block from clean_list to GC next\n"));\r\nnextlist = &c->clean_list;\r\n} else if (!list_empty(&c->dirty_list)) {\r\nD1(printk(KERN_DEBUG "Picking block from dirty_list to GC next (clean_list was empty)\n"));\r\nnextlist = &c->dirty_list;\r\n} else if (!list_empty(&c->very_dirty_list)) {\r\nD1(printk(KERN_DEBUG "Picking block from very_dirty_list to GC next (clean_list and dirty_list were empty)\n"));\r\nnextlist = &c->very_dirty_list;\r\n} else if (!list_empty(&c->erasable_list)) {\r\nD1(printk(KERN_DEBUG "Picking block from erasable_list to GC next (clean_list and {very_,}dirty_list were empty)\n"));\r\nnextlist = &c->erasable_list;\r\n} else if (!list_empty(&c->erasable_pending_wbuf_list)) {\r\nD1(printk(KERN_DEBUG "Synching wbuf in order to reuse erasable_pending_wbuf_list blocks\n"));\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_flush_wbuf_pad(c);\r\nspin_lock(&c->erase_completion_lock);\r\ngoto again;\r\n} else {\r\nD1(printk(KERN_NOTICE "jffs2: No clean, dirty _or_ erasable blocks to GC from! Where are they all?\n"));\r\nreturn NULL;\r\n}\r\nret = list_entry(nextlist->next, struct jffs2_eraseblock, list);\r\nlist_del(&ret->list);\r\nc->gcblock = ret;\r\nret->gc_node = ret->first_node;\r\nif (!ret->gc_node) {\r\nprintk(KERN_WARNING "Eep. ret->gc_node for block at 0x%08x is NULL\n", ret->offset);\r\nBUG();\r\n}\r\nif (ret->wasted_size) {\r\nD1(printk(KERN_DEBUG "Converting wasted_size %08x to dirty_size\n", ret->wasted_size));\r\nret->dirty_size += ret->wasted_size;\r\nc->wasted_size -= ret->wasted_size;\r\nc->dirty_size += ret->wasted_size;\r\nret->wasted_size = 0;\r\n}\r\nreturn ret;\r\n}\r\nint jffs2_garbage_collect_pass(struct jffs2_sb_info *c)\r\n{\r\nstruct jffs2_inode_info *f;\r\nstruct jffs2_inode_cache *ic;\r\nstruct jffs2_eraseblock *jeb;\r\nstruct jffs2_raw_node_ref *raw;\r\nuint32_t gcblock_dirty;\r\nint ret = 0, inum, nlink;\r\nint xattr = 0;\r\nif (mutex_lock_interruptible(&c->alloc_sem))\r\nreturn -EINTR;\r\nfor (;;) {\r\nspin_lock(&c->erase_completion_lock);\r\nif (!c->unchecked_size)\r\nbreak;\r\nif (c->checked_ino > c->highest_ino && xattr) {\r\nprintk(KERN_CRIT "Checked all inodes but still 0x%x bytes of unchecked space?\n",\r\nc->unchecked_size);\r\njffs2_dbg_dump_block_lists_nolock(c);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn -ENOSPC;\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nif (!xattr)\r\nxattr = jffs2_verify_xattr(c);\r\nspin_lock(&c->inocache_lock);\r\nic = jffs2_get_ino_cache(c, c->checked_ino++);\r\nif (!ic) {\r\nspin_unlock(&c->inocache_lock);\r\ncontinue;\r\n}\r\nif (!ic->pino_nlink) {\r\nD1(printk(KERN_DEBUG "Skipping check of ino #%d with nlink/pino zero\n",\r\nic->ino));\r\nspin_unlock(&c->inocache_lock);\r\njffs2_xattr_delete_inode(c, ic);\r\ncontinue;\r\n}\r\nswitch(ic->state) {\r\ncase INO_STATE_CHECKEDABSENT:\r\ncase INO_STATE_PRESENT:\r\nD1(printk(KERN_DEBUG "Skipping ino #%u already checked\n", ic->ino));\r\nspin_unlock(&c->inocache_lock);\r\ncontinue;\r\ncase INO_STATE_GC:\r\ncase INO_STATE_CHECKING:\r\nprintk(KERN_WARNING "Inode #%u is in state %d during CRC check phase!\n", ic->ino, ic->state);\r\nspin_unlock(&c->inocache_lock);\r\nBUG();\r\ncase INO_STATE_READING:\r\nD1(printk(KERN_DEBUG "Waiting for ino #%u to finish reading\n", ic->ino));\r\nc->checked_ino--;\r\nmutex_unlock(&c->alloc_sem);\r\nsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\r\nreturn 0;\r\ndefault:\r\nBUG();\r\ncase INO_STATE_UNCHECKED:\r\n;\r\n}\r\nic->state = INO_STATE_CHECKING;\r\nspin_unlock(&c->inocache_lock);\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_pass() triggering inode scan of ino#%u\n", ic->ino));\r\nret = jffs2_do_crccheck_inode(c, ic);\r\nif (ret)\r\nprintk(KERN_WARNING "Returned error for crccheck of ino #%u. Expect badness...\n", ic->ino);\r\njffs2_set_inocache_state(c, ic, INO_STATE_CHECKEDABSENT);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn ret;\r\n}\r\nif (!list_empty(&c->erase_complete_list) ||\r\n!list_empty(&c->erase_pending_list)) {\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_pass() erasing pending blocks\n"));\r\nif (jffs2_erase_pending_blocks(c, 1))\r\nreturn 0;\r\nD1(printk(KERN_DEBUG "No progress from erasing blocks; doing GC anyway\n"));\r\nspin_lock(&c->erase_completion_lock);\r\nmutex_lock(&c->alloc_sem);\r\n}\r\njeb = c->gcblock;\r\nif (!jeb)\r\njeb = jffs2_find_gc_block(c);\r\nif (!jeb) {\r\nif (c->nr_erasing_blocks) {\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn -EAGAIN;\r\n}\r\nD1(printk(KERN_NOTICE "jffs2: Couldn't find erase block to garbage collect!\n"));\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn -EIO;\r\n}\r\nD1(printk(KERN_DEBUG "GC from block %08x, used_size %08x, dirty_size %08x, free_size %08x\n", jeb->offset, jeb->used_size, jeb->dirty_size, jeb->free_size));\r\nD1(if (c->nextblock)\r\nprintk(KERN_DEBUG "Nextblock at %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\n", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size));\r\nif (!jeb->used_size) {\r\nmutex_unlock(&c->alloc_sem);\r\ngoto eraseit;\r\n}\r\nraw = jeb->gc_node;\r\ngcblock_dirty = jeb->dirty_size;\r\nwhile(ref_obsolete(raw)) {\r\nD1(printk(KERN_DEBUG "Node at 0x%08x is obsolete... skipping\n", ref_offset(raw)));\r\nraw = ref_next(raw);\r\nif (unlikely(!raw)) {\r\nprintk(KERN_WARNING "eep. End of raw list while still supposedly nodes to GC\n");\r\nprintk(KERN_WARNING "erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x\n",\r\njeb->offset, jeb->free_size, jeb->dirty_size, jeb->used_size);\r\njeb->gc_node = raw;\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\nBUG();\r\n}\r\n}\r\njeb->gc_node = raw;\r\nD1(printk(KERN_DEBUG "Going to garbage collect node at 0x%08x\n", ref_offset(raw)));\r\nif (!raw->next_in_ino) {\r\nspin_unlock(&c->erase_completion_lock);\r\nif (ref_flags(raw) == REF_PRISTINE) {\r\njffs2_garbage_collect_pristine(c, NULL, raw);\r\n} else {\r\njffs2_mark_node_obsolete(c, raw);\r\n}\r\nmutex_unlock(&c->alloc_sem);\r\ngoto eraseit_lock;\r\n}\r\nic = jffs2_raw_ref_to_ic(raw);\r\n#ifdef CONFIG_JFFS2_FS_XATTR\r\nif (ic->class == RAWNODE_CLASS_XATTR_DATUM\r\n|| ic->class == RAWNODE_CLASS_XATTR_REF) {\r\nspin_unlock(&c->erase_completion_lock);\r\nif (ic->class == RAWNODE_CLASS_XATTR_DATUM) {\r\nret = jffs2_garbage_collect_xattr_datum(c, (struct jffs2_xattr_datum *)ic, raw);\r\n} else {\r\nret = jffs2_garbage_collect_xattr_ref(c, (struct jffs2_xattr_ref *)ic, raw);\r\n}\r\ngoto test_gcnode;\r\n}\r\n#endif\r\nspin_lock(&c->inocache_lock);\r\nspin_unlock(&c->erase_completion_lock);\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_pass collecting from block @0x%08x. Node @0x%08x(%d), ino #%u\n", jeb->offset, ref_offset(raw), ref_flags(raw), ic->ino));\r\nswitch(ic->state) {\r\ncase INO_STATE_CHECKEDABSENT:\r\nif (ref_flags(raw) == REF_PRISTINE)\r\nic->state = INO_STATE_GC;\r\nelse {\r\nD1(printk(KERN_DEBUG "Ino #%u is absent but node not REF_PRISTINE. Reading.\n",\r\nic->ino));\r\n}\r\nbreak;\r\ncase INO_STATE_PRESENT:\r\nbreak;\r\ncase INO_STATE_UNCHECKED:\r\ncase INO_STATE_CHECKING:\r\ncase INO_STATE_GC:\r\nprintk(KERN_CRIT "Inode #%u already in state %d in jffs2_garbage_collect_pass()!\n",\r\nic->ino, ic->state);\r\nmutex_unlock(&c->alloc_sem);\r\nspin_unlock(&c->inocache_lock);\r\nBUG();\r\ncase INO_STATE_READING:\r\nmutex_unlock(&c->alloc_sem);\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_pass() waiting for ino #%u in state %d\n",\r\nic->ino, ic->state));\r\nsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\r\nreturn 0;\r\n}\r\nif (ic->state == INO_STATE_GC) {\r\nspin_unlock(&c->inocache_lock);\r\nret = jffs2_garbage_collect_pristine(c, ic, raw);\r\nspin_lock(&c->inocache_lock);\r\nic->state = INO_STATE_CHECKEDABSENT;\r\nwake_up(&c->inocache_wq);\r\nif (ret != -EBADFD) {\r\nspin_unlock(&c->inocache_lock);\r\ngoto test_gcnode;\r\n}\r\n}\r\ninum = ic->ino;\r\nnlink = ic->pino_nlink;\r\nspin_unlock(&c->inocache_lock);\r\nf = jffs2_gc_fetch_inode(c, inum, !nlink);\r\nif (IS_ERR(f)) {\r\nret = PTR_ERR(f);\r\ngoto release_sem;\r\n}\r\nif (!f) {\r\nret = 0;\r\ngoto release_sem;\r\n}\r\nret = jffs2_garbage_collect_live(c, jeb, raw, f);\r\njffs2_gc_release_inode(c, f);\r\ntest_gcnode:\r\nif (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {\r\nprintk(KERN_ERR "Error garbage collecting node at %08x!\n", ref_offset(jeb->gc_node));\r\nret = -ENOSPC;\r\n}\r\nrelease_sem:\r\nmutex_unlock(&c->alloc_sem);\r\neraseit_lock:\r\nspin_lock(&c->erase_completion_lock);\r\neraseit:\r\nif (c->gcblock && !c->gcblock->used_size) {\r\nD1(printk(KERN_DEBUG "Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\n", c->gcblock->offset));\r\nlist_add_tail(&c->gcblock->list, &c->erase_pending_list);\r\nc->gcblock = NULL;\r\nc->nr_erasing_blocks++;\r\njffs2_garbage_collect_trigger(c);\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nreturn ret;\r\n}\r\nstatic int jffs2_garbage_collect_live(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\r\nstruct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f)\r\n{\r\nstruct jffs2_node_frag *frag;\r\nstruct jffs2_full_dnode *fn = NULL;\r\nstruct jffs2_full_dirent *fd;\r\nuint32_t start = 0, end = 0, nrfrags = 0;\r\nint ret = 0;\r\nmutex_lock(&f->sem);\r\nspin_lock(&c->erase_completion_lock);\r\nif (c->gcblock != jeb) {\r\nspin_unlock(&c->erase_completion_lock);\r\nD1(printk(KERN_DEBUG "GC block is no longer gcblock. Restart\n"));\r\ngoto upnout;\r\n}\r\nif (ref_obsolete(raw)) {\r\nspin_unlock(&c->erase_completion_lock);\r\nD1(printk(KERN_DEBUG "node to be GC'd was obsoleted in the meantime.\n"));\r\ngoto upnout;\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nif (f->metadata && f->metadata->raw == raw) {\r\nfn = f->metadata;\r\nret = jffs2_garbage_collect_metadata(c, jeb, f, fn);\r\ngoto upnout;\r\n}\r\nfor (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {\r\nif (frag->node && frag->node->raw == raw) {\r\nfn = frag->node;\r\nend = frag->ofs + frag->size;\r\nif (!nrfrags++)\r\nstart = frag->ofs;\r\nif (nrfrags == frag->node->frags)\r\nbreak;\r\n}\r\n}\r\nif (fn) {\r\nif (ref_flags(raw) == REF_PRISTINE) {\r\nret = jffs2_garbage_collect_pristine(c, f->inocache, raw);\r\nif (!ret) {\r\nfrag->node->raw = f->inocache->nodes;\r\n}\r\nif (ret != -EBADFD)\r\ngoto upnout;\r\n}\r\nif((start >> PAGE_CACHE_SHIFT) < ((end-1) >> PAGE_CACHE_SHIFT)) {\r\nret = jffs2_garbage_collect_hole(c, jeb, f, fn, start, end);\r\n} else {\r\nret = jffs2_garbage_collect_dnode(c, jeb, f, fn, start, end);\r\n}\r\ngoto upnout;\r\n}\r\nfor (fd = f->dents; fd; fd=fd->next) {\r\nif (fd->raw == raw)\r\nbreak;\r\n}\r\nif (fd && fd->ino) {\r\nret = jffs2_garbage_collect_dirent(c, jeb, f, fd);\r\n} else if (fd) {\r\nret = jffs2_garbage_collect_deletion_dirent(c, jeb, f, fd);\r\n} else {\r\nprintk(KERN_WARNING "Raw node at 0x%08x wasn't in node lists for ino #%u\n",\r\nref_offset(raw), f->inocache->ino);\r\nif (ref_obsolete(raw)) {\r\nprintk(KERN_WARNING "But it's obsolete so we don't mind too much\n");\r\n} else {\r\njffs2_dbg_dump_node(c, ref_offset(raw));\r\nBUG();\r\n}\r\n}\r\nupnout:\r\nmutex_unlock(&f->sem);\r\nreturn ret;\r\n}\r\nstatic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\r\nstruct jffs2_inode_cache *ic,\r\nstruct jffs2_raw_node_ref *raw)\r\n{\r\nunion jffs2_node_union *node;\r\nsize_t retlen;\r\nint ret;\r\nuint32_t phys_ofs, alloclen;\r\nuint32_t crc, rawlen;\r\nint retried = 0;\r\nD1(printk(KERN_DEBUG "Going to GC REF_PRISTINE node at 0x%08x\n", ref_offset(raw)));\r\nalloclen = rawlen = ref_totlen(c, c->gcblock, raw);\r\nif (ic && alloclen > sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN)\r\nalloclen = sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN;\r\nret = jffs2_reserve_space_gc(c, alloclen, &alloclen, rawlen);\r\nif (ret)\r\nreturn ret;\r\nif (alloclen < rawlen) {\r\nreturn -EBADFD;\r\n}\r\nnode = kmalloc(rawlen, GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)node);\r\nif (!ret && retlen != rawlen)\r\nret = -EIO;\r\nif (ret)\r\ngoto out_node;\r\ncrc = crc32(0, node, sizeof(struct jffs2_unknown_node)-4);\r\nif (je32_to_cpu(node->u.hdr_crc) != crc) {\r\nprintk(KERN_WARNING "Header CRC failed on REF_PRISTINE node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",\r\nref_offset(raw), je32_to_cpu(node->u.hdr_crc), crc);\r\ngoto bail;\r\n}\r\nswitch(je16_to_cpu(node->u.nodetype)) {\r\ncase JFFS2_NODETYPE_INODE:\r\ncrc = crc32(0, node, sizeof(node->i)-8);\r\nif (je32_to_cpu(node->i.node_crc) != crc) {\r\nprintk(KERN_WARNING "Node CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",\r\nref_offset(raw), je32_to_cpu(node->i.node_crc), crc);\r\ngoto bail;\r\n}\r\nif (je32_to_cpu(node->i.dsize)) {\r\ncrc = crc32(0, node->i.data, je32_to_cpu(node->i.csize));\r\nif (je32_to_cpu(node->i.data_crc) != crc) {\r\nprintk(KERN_WARNING "Data CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",\r\nref_offset(raw), je32_to_cpu(node->i.data_crc), crc);\r\ngoto bail;\r\n}\r\n}\r\nbreak;\r\ncase JFFS2_NODETYPE_DIRENT:\r\ncrc = crc32(0, node, sizeof(node->d)-8);\r\nif (je32_to_cpu(node->d.node_crc) != crc) {\r\nprintk(KERN_WARNING "Node CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",\r\nref_offset(raw), je32_to_cpu(node->d.node_crc), crc);\r\ngoto bail;\r\n}\r\nif (strnlen(node->d.name, node->d.nsize) != node->d.nsize) {\r\nprintk(KERN_WARNING "Name in dirent node at 0x%08x contains zeroes\n", ref_offset(raw));\r\ngoto bail;\r\n}\r\nif (node->d.nsize) {\r\ncrc = crc32(0, node->d.name, node->d.nsize);\r\nif (je32_to_cpu(node->d.name_crc) != crc) {\r\nprintk(KERN_WARNING "Name CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",\r\nref_offset(raw), je32_to_cpu(node->d.name_crc), crc);\r\ngoto bail;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nif (ic) {\r\nprintk(KERN_WARNING "Unknown node type for REF_PRISTINE node at 0x%08x: 0x%04x\n",\r\nref_offset(raw), je16_to_cpu(node->u.nodetype));\r\ngoto bail;\r\n}\r\n}\r\nretry:\r\nphys_ofs = write_ofs(c);\r\nret = jffs2_flash_write(c, phys_ofs, rawlen, &retlen, (char *)node);\r\nif (ret || (retlen != rawlen)) {\r\nprintk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %zd\n",\r\nrawlen, phys_ofs, ret, retlen);\r\nif (retlen) {\r\njffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, rawlen, NULL);\r\n} else {\r\nprintk(KERN_NOTICE "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\n", phys_ofs);\r\n}\r\nif (!retried) {\r\nuint32_t dummy;\r\nstruct jffs2_eraseblock *jeb = &c->blocks[phys_ofs / c->sector_size];\r\nretried = 1;\r\nD1(printk(KERN_DEBUG "Retrying failed write of REF_PRISTINE node.\n"));\r\njffs2_dbg_acct_sanity_check(c,jeb);\r\njffs2_dbg_acct_paranoia_check(c, jeb);\r\nret = jffs2_reserve_space_gc(c, rawlen, &dummy, rawlen);\r\nif (!ret) {\r\nD1(printk(KERN_DEBUG "Allocated space at 0x%08x to retry failed write.\n", phys_ofs));\r\njffs2_dbg_acct_sanity_check(c,jeb);\r\njffs2_dbg_acct_paranoia_check(c, jeb);\r\ngoto retry;\r\n}\r\nD1(printk(KERN_DEBUG "Failed to allocate space to retry failed write: %d!\n", ret));\r\n}\r\nif (!ret)\r\nret = -EIO;\r\ngoto out_node;\r\n}\r\njffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, rawlen, ic);\r\njffs2_mark_node_obsolete(c, raw);\r\nD1(printk(KERN_DEBUG "WHEEE! GC REF_PRISTINE node at 0x%08x succeeded\n", ref_offset(raw)));\r\nout_node:\r\nkfree(node);\r\nreturn ret;\r\nbail:\r\nret = -EBADFD;\r\ngoto out_node;\r\n}\r\nstatic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\r\nstruct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\r\n{\r\nstruct jffs2_full_dnode *new_fn;\r\nstruct jffs2_raw_inode ri;\r\nstruct jffs2_node_frag *last_frag;\r\nunion jffs2_device_node dev;\r\nchar *mdata = NULL;\r\nint mdatalen = 0;\r\nuint32_t alloclen, ilen;\r\nint ret;\r\nif (S_ISBLK(JFFS2_F_I_MODE(f)) ||\r\nS_ISCHR(JFFS2_F_I_MODE(f)) ) {\r\nmdatalen = jffs2_encode_dev(&dev, JFFS2_F_I_RDEV(f));\r\nmdata = (char *)&dev;\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_metadata(): Writing %d bytes of kdev_t\n", mdatalen));\r\n} else if (S_ISLNK(JFFS2_F_I_MODE(f))) {\r\nmdatalen = fn->size;\r\nmdata = kmalloc(fn->size, GFP_KERNEL);\r\nif (!mdata) {\r\nprintk(KERN_WARNING "kmalloc of mdata failed in jffs2_garbage_collect_metadata()\n");\r\nreturn -ENOMEM;\r\n}\r\nret = jffs2_read_dnode(c, f, fn, mdata, 0, mdatalen);\r\nif (ret) {\r\nprintk(KERN_WARNING "read of old metadata failed in jffs2_garbage_collect_metadata(): %d\n", ret);\r\nkfree(mdata);\r\nreturn ret;\r\n}\r\nD1(printk(KERN_DEBUG "jffs2_garbage_collect_metadata(): Writing %d bites of symlink target\n", mdatalen));\r\n}\r\nret = jffs2_reserve_space_gc(c, sizeof(ri) + mdatalen, &alloclen,\r\nJFFS2_SUMMARY_INODE_SIZE);\r\nif (ret) {\r\nprintk(KERN_WARNING "jffs2_reserve_space_gc of %zd bytes for garbage_collect_metadata failed: %d\n",\r\nsizeof(ri)+ mdatalen, ret);\r\ngoto out;\r\n}\r\nlast_frag = frag_last(&f->fragtree);\r\nif (last_frag)\r\nilen = last_frag->ofs + last_frag->size;\r\nelse\r\nilen = JFFS2_F_I_SIZE(f);\r\nmemset(&ri, 0, sizeof(ri));\r\nri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\r\nri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\r\nri.totlen = cpu_to_je32(sizeof(ri) + mdatalen);\r\nri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\r\nri.ino = cpu_to_je32(f->inocache->ino);\r\nri.version = cpu_to_je32(++f->highest_version);\r\nri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\r\nri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\r\nri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\r\nri.isize = cpu_to_je32(ilen);\r\nri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\r\nri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\r\nri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\r\nri.offset = cpu_to_je32(0);\r\nri.csize = cpu_to_je32(mdatalen);\r\nri.dsize = cpu_to_je32(mdatalen);\r\nri.compr = JFFS2_COMPR_NONE;\r\nri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\r\nri.data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));\r\nnew_fn = jffs2_write_dnode(c, f, &ri, mdata, mdatalen, ALLOC_GC);\r\nif (IS_ERR(new_fn)) {\r\nprintk(KERN_WARNING "Error writing new dnode: %ld\n", PTR_ERR(new_fn));\r\nret = PTR_ERR(new_fn);\r\ngoto out;\r\n}\r\njffs2_mark_node_obsolete(c, fn->raw);\r\njffs2_free_full_dnode(fn);\r\nf->metadata = new_fn;\r\nout:\r\nif (S_ISLNK(JFFS2_F_I_MODE(f)))\r\nkfree(mdata);\r\nreturn ret;\r\n}\r\nstatic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\r\nstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\r\n{\r\nstruct jffs2_full_dirent *new_fd;\r\nstruct jffs2_raw_dirent rd;\r\nuint32_t alloclen;\r\nint ret;\r\nrd.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\r\nrd.nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\r\nrd.nsize = strlen(fd->name);\r\nrd.totlen = cpu_to_je32(sizeof(rd) + rd.nsize);\r\nrd.hdr_crc = cpu_to_je32(crc32(0, &rd, sizeof(struct jffs2_unknown_node)-4));\r\nrd.pino = cpu_to_je32(f->inocache->ino);\r\nrd.version = cpu_to_je32(++f->highest_version);\r\nrd.ino = cpu_to_je32(fd->ino);\r\nif (JFFS2_F_I_MTIME(f) == JFFS2_F_I_CTIME(f))\r\nrd.mctime = cpu_to_je32(JFFS2_F_I_MTIME(f));\r\nelse\r\nrd.mctime = cpu_to_je32(0);\r\nrd.type = fd->type;\r\nrd.node_crc = cpu_to_je32(crc32(0, &rd, sizeof(rd)-8));\r\nrd.name_crc = cpu_to_je32(crc32(0, fd->name, rd.nsize));\r\nret = jffs2_reserve_space_gc(c, sizeof(rd)+rd.nsize, &alloclen,\r\nJFFS2_SUMMARY_DIRENT_SIZE(rd.nsize));\r\nif (ret) {\r\nprintk(KERN_WARNING "jffs2_reserve_space_gc of %zd bytes for garbage_collect_dirent failed: %d\n",\r\nsizeof(rd)+rd.nsize, ret);\r\nreturn ret;\r\n}\r\nnew_fd = jffs2_write_dirent(c, f, &rd, fd->name, rd.nsize, ALLOC_GC);\r\nif (IS_ERR(new_fd)) {\r\nprintk(KERN_WARNING "jffs2_write_dirent in garbage_collect_dirent failed: %ld\n", PTR_ERR(new_fd));\r\nreturn PTR_ERR(new_fd);\r\n}\r\njffs2_add_fd_to_list(c, new_fd, &f->dents);\r\nreturn 0;\r\n}\r\nstatic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\r\nstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\r\n{\r\nstruct jffs2_full_dirent **fdp = &f->dents;\r\nint found = 0;\r\nif (!jffs2_can_mark_obsolete(c)) {\r\nstruct jffs2_raw_dirent *rd;\r\nstruct jffs2_raw_node_ref *raw;\r\nint ret;\r\nsize_t retlen;\r\nint name_len = strlen(fd->name);\r\nuint32_t name_crc = crc32(0, fd->name, name_len);\r\nuint32_t rawlen = ref_totlen(c, jeb, fd->raw);\r\nrd = kmalloc(rawlen, GFP_KERNEL);\r\nif (!rd)\r\nreturn -ENOMEM;\r\nmutex_lock(&c->erase_free_sem);\r\nfor (raw = f->inocache->nodes; raw != (void *)f->inocache; raw = raw->next_in_ino) {\r\ncond_resched();\r\nif (!(ref_obsolete(raw)))\r\ncontinue;\r\nif (ref_totlen(c, NULL, raw) != rawlen)\r\ncontinue;\r\nif (SECTOR_ADDR(raw->flash_offset) == SECTOR_ADDR(fd->raw->flash_offset))\r\ncontinue;\r\nD1(printk(KERN_DEBUG "Check potential deletion dirent at %08x\n", ref_offset(raw)));\r\nret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)rd);\r\nif (ret) {\r\nprintk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Read error (%d) reading obsolete node at %08x\n", ret, ref_offset(raw));\r\ncontinue;\r\n}\r\nif (retlen != rawlen) {\r\nprintk(KERN_WARNING "jffs2_g_c_deletion_dirent(): Short read (%zd not %u) reading header from obsolete node at %08x\n",\r\nretlen, rawlen, ref_offset(raw));\r\ncontinue;\r\n}\r\nif (je16_to_cpu(rd->nodetype) != JFFS2_NODETYPE_DIRENT)\r\ncontinue;\r\nif (je32_to_cpu(rd->name_crc) != name_crc)\r\ncontinue;\r\nif (rd->nsize != name_len || !je32_to_cpu(rd->ino))\r\ncontinue;\r\nif (memcmp(rd->name, fd->name, name_len))\r\ncontinue;\r\nmutex_unlock(&c->erase_free_sem);\r\nD1(printk(KERN_DEBUG "Deletion dirent at %08x still obsoletes real dirent \"%s\" at %08x for ino #%u\n",\r\nref_offset(fd->raw), fd->name, ref_offset(raw), je32_to_cpu(rd->ino)));\r\nkfree(rd);\r\nreturn jffs2_garbage_collect_dirent(c, jeb, f, fd);\r\n}\r\nmutex_unlock(&c->erase_free_sem);\r\nkfree(rd);\r\n}\r\nwhile (*fdp) {\r\nif ((*fdp) == fd) {\r\nfound = 1;\r\n*fdp = fd->next;\r\nbreak;\r\n}\r\nfdp = &(*fdp)->next;\r\n}\r\nif (!found) {\r\nprintk(KERN_WARNING "Deletion dirent \"%s\" not found in list for ino #%u\n", fd->name, f->inocache->ino);\r\n}\r\njffs2_mark_node_obsolete(c, fd->raw);\r\njffs2_free_full_dirent(fd);\r\nreturn 0;\r\n}\r\nstatic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\r\nstruct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\r\nuint32_t start, uint32_t end)\r\n{\r\nstruct jffs2_raw_inode ri;\r\nstruct jffs2_node_frag *frag;\r\nstruct jffs2_full_dnode *new_fn;\r\nuint32_t alloclen, ilen;\r\nint ret;\r\nD1(printk(KERN_DEBUG "Writing replacement hole node for ino #%u from offset 0x%x to 0x%x\n",\r\nf->inocache->ino, start, end));\r\nmemset(&ri, 0, sizeof(ri));\r\nif(fn->frags > 1) {\r\nsize_t readlen;\r\nuint32_t crc;\r\nret = jffs2_flash_read(c, ref_offset(fn->raw), sizeof(ri), &readlen, (char *)&ri);\r\nif (readlen != sizeof(ri) || ret) {\r\nprintk(KERN_WARNING "Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %zd. Data will be lost by writing new hole node\n", ret, readlen);\r\ngoto fill;\r\n}\r\nif (je16_to_cpu(ri.nodetype) != JFFS2_NODETYPE_INODE) {\r\nprintk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)\n",\r\nref_offset(fn->raw),\r\nje16_to_cpu(ri.nodetype), JFFS2_NODETYPE_INODE);\r\nreturn -EIO;\r\n}\r\nif (je32_to_cpu(ri.totlen) != sizeof(ri)) {\r\nprintk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had totlen 0x%x instead of expected 0x%zx\n",\r\nref_offset(fn->raw),\r\nje32_to_cpu(ri.totlen), sizeof(ri));\r\nreturn -EIO;\r\n}\r\ncrc = crc32(0, &ri, sizeof(ri)-8);\r\nif (crc != je32_to_cpu(ri.node_crc)) {\r\nprintk(KERN_WARNING "jffs2_garbage_collect_hole: Node at 0x%08x had CRC 0x%08x which doesn't match calculated CRC 0x%08x\n",\r\nref_offset(fn->raw),\r\nje32_to_cpu(ri.node_crc), crc);\r\nprintk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%u will be lost\n",\r\nstart, end, f->inocache->ino);\r\ngoto fill;\r\n}\r\nif (ri.compr != JFFS2_COMPR_ZERO) {\r\nprintk(KERN_WARNING "jffs2_garbage_collect_hole: Node 0x%08x wasn't a hole node!\n", ref_offset(fn->raw));\r\nprintk(KERN_WARNING "Data in the range 0x%08x to 0x%08x of inode #%u will be lost\n",\r\nstart, end, f->inocache->ino);\r\ngoto fill;\r\n}\r\n} else {\r\nfill:\r\nri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\r\nri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\r\nri.totlen = cpu_to_je32(sizeof(ri));\r\nri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\r\nri.ino = cpu_to_je32(f->inocache->ino);\r\nri.version = cpu_to_je32(++f->highest_version);\r\nri.offset = cpu_to_je32(start);\r\nri.dsize = cpu_to_je32(end - start);\r\nri.csize = cpu_to_je32(0);\r\nri.compr = JFFS2_COMPR_ZERO;\r\n}\r\nfrag = frag_last(&f->fragtree);\r\nif (frag)\r\nilen = frag->ofs + frag->size;\r\nelse\r\nilen = JFFS2_F_I_SIZE(f);\r\nri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\r\nri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\r\nri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\r\nri.isize = cpu_to_je32(ilen);\r\nri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\r\nri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\r\nri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\r\nri.data_crc = cpu_to_je32(0);\r\nri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\r\nret = jffs2_reserve_space_gc(c, sizeof(ri), &alloclen,\r\nJFFS2_SUMMARY_INODE_SIZE);\r\nif (ret) {\r\nprintk(KERN_WARNING "jffs2_reserve_space_gc of %zd bytes for garbage_collect_hole failed: %d\n",\r\nsizeof(ri), ret);\r\nreturn ret;\r\n}\r\nnew_fn = jffs2_write_dnode(c, f, &ri, NULL, 0, ALLOC_GC);\r\nif (IS_ERR(new_fn)) {\r\nprintk(KERN_WARNING "Error writing new hole node: %ld\n", PTR_ERR(new_fn));\r\nreturn PTR_ERR(new_fn);\r\n}\r\nif (je32_to_cpu(ri.version) == f->highest_version) {\r\njffs2_add_full_dnode_to_inode(c, f, new_fn);\r\nif (f->metadata) {\r\njffs2_mark_node_obsolete(c, f->metadata->raw);\r\njffs2_free_full_dnode(f->metadata);\r\nf->metadata = NULL;\r\n}\r\nreturn 0;\r\n}\r\nD1(if(unlikely(fn->frags <= 1)) {\r\nprintk(KERN_WARNING "jffs2_garbage_collect_hole: Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d\n",\r\nfn->frags, je32_to_cpu(ri.version), f->highest_version,\r\nje32_to_cpu(ri.ino));\r\n});\r\nmark_ref_normal(new_fn->raw);\r\nfor (frag = jffs2_lookup_node_frag(&f->fragtree, fn->ofs);\r\nfrag; frag = frag_next(frag)) {\r\nif (frag->ofs > fn->size + fn->ofs)\r\nbreak;\r\nif (frag->node == fn) {\r\nfrag->node = new_fn;\r\nnew_fn->frags++;\r\nfn->frags--;\r\n}\r\n}\r\nif (fn->frags) {\r\nprintk(KERN_WARNING "jffs2_garbage_collect_hole: Old node still has frags!\n");\r\nBUG();\r\n}\r\nif (!new_fn->frags) {\r\nprintk(KERN_WARNING "jffs2_garbage_collect_hole: New node has no frags!\n");\r\nBUG();\r\n}\r\njffs2_mark_node_obsolete(c, fn->raw);\r\njffs2_free_full_dnode(fn);\r\nreturn 0;\r\n}\r\nstatic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *orig_jeb,\r\nstruct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\r\nuint32_t start, uint32_t end)\r\n{\r\nstruct jffs2_full_dnode *new_fn;\r\nstruct jffs2_raw_inode ri;\r\nuint32_t alloclen, offset, orig_end, orig_start;\r\nint ret = 0;\r\nunsigned char *comprbuf = NULL, *writebuf;\r\nunsigned long pg;\r\nunsigned char *pg_ptr;\r\nmemset(&ri, 0, sizeof(ri));\r\nD1(printk(KERN_DEBUG "Writing replacement dnode for ino #%u from offset 0x%x to 0x%x\n",\r\nf->inocache->ino, start, end));\r\norig_end = end;\r\norig_start = start;\r\nif (c->nr_free_blocks + c->nr_erasing_blocks > c->resv_blocks_gcmerge) {\r\nstruct jffs2_node_frag *frag;\r\nuint32_t min, max;\r\nmin = start & ~(PAGE_CACHE_SIZE-1);\r\nmax = min + PAGE_CACHE_SIZE;\r\nfrag = jffs2_lookup_node_frag(&f->fragtree, start);\r\nBUG_ON(frag->ofs != start);\r\nwhile((frag = frag_prev(frag)) && frag->ofs >= min) {\r\nif (frag->ofs > min) {\r\nD1(printk(KERN_DEBUG "Expanding down to cover partial frag (0x%x-0x%x)\n",\r\nfrag->ofs, frag->ofs+frag->size));\r\nstart = frag->ofs;\r\ncontinue;\r\n}\r\nif (!frag->node || !frag->node->raw) {\r\nD1(printk(KERN_DEBUG "First frag in page is hole (0x%x-0x%x). Not expanding down.\n",\r\nfrag->ofs, frag->ofs+frag->size));\r\nbreak;\r\n} else {\r\nstruct jffs2_raw_node_ref *raw = frag->node->raw;\r\nstruct jffs2_eraseblock *jeb;\r\njeb = &c->blocks[raw->flash_offset / c->sector_size];\r\nif (jeb == c->gcblock) {\r\nD1(printk(KERN_DEBUG "Expanding down to cover frag (0x%x-0x%x) in gcblock at %08x\n",\r\nfrag->ofs, frag->ofs+frag->size, ref_offset(raw)));\r\nstart = frag->ofs;\r\nbreak;\r\n}\r\nif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\r\nD1(printk(KERN_DEBUG "Not expanding down to cover frag (0x%x-0x%x) in clean block %08x\n",\r\nfrag->ofs, frag->ofs+frag->size, jeb->offset));\r\nbreak;\r\n}\r\nD1(printk(KERN_DEBUG "Expanding down to cover frag (0x%x-0x%x) in dirty block %08x\n",\r\nfrag->ofs, frag->ofs+frag->size, jeb->offset));\r\nstart = frag->ofs;\r\nbreak;\r\n}\r\n}\r\nfrag = jffs2_lookup_node_frag(&f->fragtree, end-1);\r\nwhile((frag = frag_next(frag)) && frag->ofs+frag->size <= max) {\r\nif (frag->ofs+frag->size < max) {\r\nD1(printk(KERN_DEBUG "Expanding up to cover partial frag (0x%x-0x%x)\n",\r\nfrag->ofs, frag->ofs+frag->size));\r\nend = frag->ofs + frag->size;\r\ncontinue;\r\n}\r\nif (!frag->node || !frag->node->raw) {\r\nD1(printk(KERN_DEBUG "Last frag in page is hole (0x%x-0x%x). Not expanding up.\n",\r\nfrag->ofs, frag->ofs+frag->size));\r\nbreak;\r\n} else {\r\nstruct jffs2_raw_node_ref *raw = frag->node->raw;\r\nstruct jffs2_eraseblock *jeb;\r\njeb = &c->blocks[raw->flash_offset / c->sector_size];\r\nif (jeb == c->gcblock) {\r\nD1(printk(KERN_DEBUG "Expanding up to cover frag (0x%x-0x%x) in gcblock at %08x\n",\r\nfrag->ofs, frag->ofs+frag->size, ref_offset(raw)));\r\nend = frag->ofs + frag->size;\r\nbreak;\r\n}\r\nif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\r\nD1(printk(KERN_DEBUG "Not expanding up to cover frag (0x%x-0x%x) in clean block %08x\n",\r\nfrag->ofs, frag->ofs+frag->size, jeb->offset));\r\nbreak;\r\n}\r\nD1(printk(KERN_DEBUG "Expanding up to cover frag (0x%x-0x%x) in dirty block %08x\n",\r\nfrag->ofs, frag->ofs+frag->size, jeb->offset));\r\nend = frag->ofs + frag->size;\r\nbreak;\r\n}\r\n}\r\nD1(printk(KERN_DEBUG "Expanded dnode to write from (0x%x-0x%x) to (0x%x-0x%x)\n",\r\norig_start, orig_end, start, end));\r\nD1(BUG_ON(end > frag_last(&f->fragtree)->ofs + frag_last(&f->fragtree)->size));\r\nBUG_ON(end < orig_end);\r\nBUG_ON(start > orig_start);\r\n}\r\npg_ptr = jffs2_gc_fetch_page(c, f, start, &pg);\r\nif (IS_ERR(pg_ptr)) {\r\nprintk(KERN_WARNING "read_cache_page() returned error: %ld\n", PTR_ERR(pg_ptr));\r\nreturn PTR_ERR(pg_ptr);\r\n}\r\noffset = start;\r\nwhile(offset < orig_end) {\r\nuint32_t datalen;\r\nuint32_t cdatalen;\r\nuint16_t comprtype = JFFS2_COMPR_NONE;\r\nret = jffs2_reserve_space_gc(c, sizeof(ri) + JFFS2_MIN_DATA_LEN,\r\n&alloclen, JFFS2_SUMMARY_INODE_SIZE);\r\nif (ret) {\r\nprintk(KERN_WARNING "jffs2_reserve_space_gc of %zd bytes for garbage_collect_dnode failed: %d\n",\r\nsizeof(ri)+ JFFS2_MIN_DATA_LEN, ret);\r\nbreak;\r\n}\r\ncdatalen = min_t(uint32_t, alloclen - sizeof(ri), end - offset);\r\ndatalen = end - offset;\r\nwritebuf = pg_ptr + (offset & (PAGE_CACHE_SIZE -1));\r\ncomprtype = jffs2_compress(c, f, writebuf, &comprbuf, &datalen, &cdatalen);\r\nri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\r\nri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\r\nri.totlen = cpu_to_je32(sizeof(ri) + cdatalen);\r\nri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\r\nri.ino = cpu_to_je32(f->inocache->ino);\r\nri.version = cpu_to_je32(++f->highest_version);\r\nri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\r\nri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\r\nri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\r\nri.isize = cpu_to_je32(JFFS2_F_I_SIZE(f));\r\nri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\r\nri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\r\nri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\r\nri.offset = cpu_to_je32(offset);\r\nri.csize = cpu_to_je32(cdatalen);\r\nri.dsize = cpu_to_je32(datalen);\r\nri.compr = comprtype & 0xff;\r\nri.usercompr = (comprtype >> 8) & 0xff;\r\nri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\r\nri.data_crc = cpu_to_je32(crc32(0, comprbuf, cdatalen));\r\nnew_fn = jffs2_write_dnode(c, f, &ri, comprbuf, cdatalen, ALLOC_GC);\r\njffs2_free_comprbuf(comprbuf, writebuf);\r\nif (IS_ERR(new_fn)) {\r\nprintk(KERN_WARNING "Error writing new dnode: %ld\n", PTR_ERR(new_fn));\r\nret = PTR_ERR(new_fn);\r\nbreak;\r\n}\r\nret = jffs2_add_full_dnode_to_inode(c, f, new_fn);\r\noffset += datalen;\r\nif (f->metadata) {\r\njffs2_mark_node_obsolete(c, f->metadata->raw);\r\njffs2_free_full_dnode(f->metadata);\r\nf->metadata = NULL;\r\n}\r\n}\r\njffs2_gc_release_page(c, pg_ptr, &pg);\r\nreturn ret;\r\n}
