static void no_printf(unsigned char *x, ...)\r\n{\r\n}\r\nstatic void *didd_callback(void *context, DESCRIPTOR * adapter,\r\nint removal)\r\n{\r\nif (adapter->type == IDI_DADAPTER) {\r\nDBG_ERR(("cb: Change in DAdapter ? Oops ?."));\r\n} else if (adapter->type == IDI_DIMAINT) {\r\nif (removal) {\r\nDbgDeregister();\r\nmemset(&MAdapter, 0, sizeof(MAdapter));\r\ndprintf = no_printf;\r\n} else {\r\nmemcpy(&MAdapter, adapter, sizeof(MAdapter));\r\ndprintf = (DIVA_DI_PRINTF) MAdapter.request;\r\nDbgRegister("MAINT", DRIVERRELEASE_MNT, DBG_DEFAULT);\r\n}\r\n} else if ((adapter->type > 0) && (adapter->type < 16)) {\r\nif (removal) {\r\ndiva_mnt_remove_xdi_adapter(adapter);\r\n} else {\r\ndiva_mnt_add_xdi_adapter(adapter);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nstatic int DIVA_INIT_FUNCTION connect_didd(void)\r\n{\r\nint x = 0;\r\nint dadapter = 0;\r\nIDI_SYNC_REQ req;\r\nDESCRIPTOR DIDD_Table[MAX_DESCRIPTORS];\r\nDIVA_DIDD_Read(DIDD_Table, sizeof(DIDD_Table));\r\nfor (x = 0; x < MAX_DESCRIPTORS; x++) {\r\nif (DIDD_Table[x].type == IDI_DADAPTER) {\r\ndadapter = 1;\r\nmemcpy(&DAdapter, &DIDD_Table[x], sizeof(DAdapter));\r\nreq.didd_notify.e.Req = 0;\r\nreq.didd_notify.e.Rc =\r\nIDI_SYNC_REQ_DIDD_REGISTER_ADAPTER_NOTIFY;\r\nreq.didd_notify.info.callback = (void *)didd_callback;\r\nreq.didd_notify.info.context = NULL;\r\nDAdapter.request((ENTITY *) & req);\r\nif (req.didd_notify.e.Rc != 0xff)\r\nreturn (0);\r\nnotify_handle = req.didd_notify.info.handle;\r\nreq.didd_add_adapter.e.Req = 0;\r\nreq.didd_add_adapter.e.Rc =\r\nIDI_SYNC_REQ_DIDD_ADD_ADAPTER;\r\nreq.didd_add_adapter.info.descriptor =\r\n(void *) &MaintDescriptor;\r\nDAdapter.request((ENTITY *) & req);\r\nif (req.didd_add_adapter.e.Rc != 0xff)\r\nreturn (0);\r\n} else if ((DIDD_Table[x].type > 0)\r\n&& (DIDD_Table[x].type < 16)) {\r\ndiva_mnt_add_xdi_adapter(&DIDD_Table[x]);\r\n}\r\n}\r\nreturn (dadapter);\r\n}\r\nstatic void DIVA_EXIT_FUNCTION disconnect_didd(void)\r\n{\r\nIDI_SYNC_REQ req;\r\nreq.didd_notify.e.Req = 0;\r\nreq.didd_notify.e.Rc = IDI_SYNC_REQ_DIDD_REMOVE_ADAPTER_NOTIFY;\r\nreq.didd_notify.info.handle = notify_handle;\r\nDAdapter.request((ENTITY *) & req);\r\nreq.didd_remove_adapter.e.Req = 0;\r\nreq.didd_remove_adapter.e.Rc = IDI_SYNC_REQ_DIDD_REMOVE_ADAPTER;\r\nreq.didd_remove_adapter.info.p_request =\r\n(IDI_CALL) MaintDescriptor.request;\r\nDAdapter.request((ENTITY *) & req);\r\n}\r\nint maint_read_write(void __user *buf, int count)\r\n{\r\nbyte data[128];\r\ndword cmd, id, mask;\r\nint ret = 0;\r\nif (count < (3 * sizeof(dword)))\r\nreturn (-EFAULT);\r\nif (diva_os_copy_from_user(NULL, (void *) &data[0],\r\nbuf, 3 * sizeof(dword))) {\r\nreturn (-EFAULT);\r\n}\r\ncmd = *(dword *) & data[0];\r\nid = *(dword *) & data[4];\r\nmask = *(dword *) & data[8];\r\nswitch (cmd) {\r\ncase DITRACE_CMD_GET_DRIVER_INFO:\r\nif ((ret = diva_get_driver_info(id, data, sizeof(data))) > 0) {\r\nif ((count < ret) || diva_os_copy_to_user\r\n(NULL, buf, (void *) &data[0], ret))\r\nret = -EFAULT;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase DITRACE_READ_DRIVER_DBG_MASK:\r\nif ((ret = diva_get_driver_dbg_mask(id, (byte *) data)) > 0) {\r\nif ((count < ret) || diva_os_copy_to_user\r\n(NULL, buf, (void *) &data[0], ret))\r\nret = -EFAULT;\r\n} else {\r\nret = -ENODEV;\r\n}\r\nbreak;\r\ncase DITRACE_WRITE_DRIVER_DBG_MASK:\r\nif ((ret = diva_set_driver_dbg_mask(id, mask)) <= 0) {\r\nret = -ENODEV;\r\n}\r\nbreak;\r\ncase DITRACE_WRITE_SELECTIVE_TRACE_FILTER:\r\nif (!mask) {\r\nret = diva_set_trace_filter (1, "*");\r\n} else if (mask < sizeof(data)) {\r\nif (diva_os_copy_from_user(NULL, data, (char __user *)buf+12, mask)) {\r\nret = -EFAULT;\r\n} else {\r\nret = diva_set_trace_filter ((int)mask, data);\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase DITRACE_READ_SELECTIVE_TRACE_FILTER:\r\nif ((ret = diva_get_trace_filter (sizeof(data), data)) > 0) {\r\nif (diva_os_copy_to_user (NULL, buf, data, ret))\r\nret = -EFAULT;\r\n} else {\r\nret = -ENODEV;\r\n}\r\nbreak;\r\ncase DITRACE_READ_TRACE_ENTRY:{\r\ndiva_os_spin_lock_magic_t old_irql;\r\nword size;\r\ndiva_dbg_entry_head_t *pmsg;\r\nbyte *pbuf;\r\nif (!(pbuf = diva_os_malloc(0, mask))) {\r\nreturn (-ENOMEM);\r\n}\r\nfor(;;) {\r\nif (!(pmsg =\r\ndiva_maint_get_message(&size, &old_irql))) {\r\nbreak;\r\n}\r\nif (size > mask) {\r\ndiva_maint_ack_message(0, &old_irql);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = size;\r\nmemcpy(pbuf, pmsg, size);\r\ndiva_maint_ack_message(1, &old_irql);\r\nif ((count < size) ||\r\ndiva_os_copy_to_user (NULL, buf, (void *) pbuf, size))\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ndiva_os_free(0, pbuf);\r\n}\r\nbreak;\r\ncase DITRACE_READ_TRACE_ENTRYS:{\r\ndiva_os_spin_lock_magic_t old_irql;\r\nword size;\r\ndiva_dbg_entry_head_t *pmsg;\r\nbyte *pbuf = NULL;\r\nint written = 0;\r\nif (mask < 4096) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!(pbuf = diva_os_malloc(0, mask))) {\r\nreturn (-ENOMEM);\r\n}\r\nfor (;;) {\r\nif (!(pmsg =\r\ndiva_maint_get_message(&size, &old_irql))) {\r\nbreak;\r\n}\r\nif ((size + 8) > mask) {\r\ndiva_maint_ack_message(0, &old_irql);\r\nbreak;\r\n}\r\npbuf[written++] = (byte) size;\r\npbuf[written++] = (byte) (size >> 8);\r\npbuf[written++] = 0;\r\npbuf[written++] = 0;\r\nmemcpy(&pbuf[written], pmsg, size);\r\ndiva_maint_ack_message(1, &old_irql);\r\nwritten += size;\r\nmask -= (size + 4);\r\n}\r\npbuf[written++] = 0;\r\npbuf[written++] = 0;\r\npbuf[written++] = 0;\r\npbuf[written++] = 0;\r\nif ((count < written) || diva_os_copy_to_user(NULL, buf, (void *) pbuf, written)) {\r\nret = -EFAULT;\r\n} else {\r\nret = written;\r\n}\r\ndiva_os_free(0, pbuf);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn (ret);\r\n}\r\nint DIVA_INIT_FUNCTION mntfunc_init(int *buffer_length, void **buffer,\r\nunsigned long diva_dbg_mem)\r\n{\r\nif (*buffer_length < 64) {\r\n*buffer_length = 64;\r\n}\r\nif (*buffer_length > 512) {\r\n*buffer_length = 512;\r\n}\r\n*buffer_length *= 1024;\r\nif (diva_dbg_mem) {\r\n*buffer = (void *) diva_dbg_mem;\r\n} else {\r\nwhile ((*buffer_length >= (64 * 1024))\r\n&&\r\n(!(*buffer = diva_os_malloc (0, *buffer_length)))) {\r\n*buffer_length -= 1024;\r\n}\r\nif (!*buffer) {\r\nDBG_ERR(("init: Can not alloc trace buffer"));\r\nreturn (0);\r\n}\r\n}\r\nif (diva_maint_init(*buffer, *buffer_length, (diva_dbg_mem == 0))) {\r\nif (!diva_dbg_mem) {\r\ndiva_os_free (0, *buffer);\r\n}\r\nDBG_ERR(("init: maint init failed"));\r\nreturn (0);\r\n}\r\nif (!connect_didd()) {\r\nDBG_ERR(("init: failed to connect to DIDD."));\r\ndiva_maint_finit();\r\nif (!diva_dbg_mem) {\r\ndiva_os_free (0, *buffer);\r\n}\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nvoid DIVA_EXIT_FUNCTION mntfunc_finit(void)\r\n{\r\nvoid *buffer;\r\nint i = 100;\r\nDbgDeregister();\r\nwhile (diva_mnt_shutdown_xdi_adapters() && i--) {\r\ndiva_os_sleep(10);\r\n}\r\ndisconnect_didd();\r\nif ((buffer = diva_maint_finit())) {\r\ndiva_os_free (0, buffer);\r\n}\r\nmemset(&MAdapter, 0, sizeof(MAdapter));\r\ndprintf = no_printf;\r\n}
