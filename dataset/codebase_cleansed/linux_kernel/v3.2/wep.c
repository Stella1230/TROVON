int ieee80211_wep_init(struct ieee80211_local *local)\r\n{\r\nget_random_bytes(&local->wep_iv, WEP_IV_LEN);\r\nlocal->wep_tx_tfm = crypto_alloc_cipher("arc4", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(local->wep_tx_tfm)) {\r\nlocal->wep_rx_tfm = ERR_PTR(-EINVAL);\r\nreturn PTR_ERR(local->wep_tx_tfm);\r\n}\r\nlocal->wep_rx_tfm = crypto_alloc_cipher("arc4", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(local->wep_rx_tfm)) {\r\ncrypto_free_cipher(local->wep_tx_tfm);\r\nlocal->wep_tx_tfm = ERR_PTR(-EINVAL);\r\nreturn PTR_ERR(local->wep_rx_tfm);\r\n}\r\nreturn 0;\r\n}\r\nvoid ieee80211_wep_free(struct ieee80211_local *local)\r\n{\r\nif (!IS_ERR(local->wep_tx_tfm))\r\ncrypto_free_cipher(local->wep_tx_tfm);\r\nif (!IS_ERR(local->wep_rx_tfm))\r\ncrypto_free_cipher(local->wep_rx_tfm);\r\n}\r\nstatic inline bool ieee80211_wep_weak_iv(u32 iv, int keylen)\r\n{\r\nif ((iv & 0xff00) == 0xff00) {\r\nu8 B = (iv >> 16) & 0xff;\r\nif (B >= 3 && B < 3 + keylen)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void ieee80211_wep_get_iv(struct ieee80211_local *local,\r\nint keylen, int keyidx, u8 *iv)\r\n{\r\nlocal->wep_iv++;\r\nif (ieee80211_wep_weak_iv(local->wep_iv, keylen))\r\nlocal->wep_iv += 0x0100;\r\nif (!iv)\r\nreturn;\r\n*iv++ = (local->wep_iv >> 16) & 0xff;\r\n*iv++ = (local->wep_iv >> 8) & 0xff;\r\n*iv++ = local->wep_iv & 0xff;\r\n*iv++ = keyidx << 6;\r\n}\r\nstatic u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,\r\nstruct sk_buff *skb,\r\nint keylen, int keyidx)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nunsigned int hdrlen;\r\nu8 *newhdr;\r\nhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\nif (WARN_ON(skb_tailroom(skb) < WEP_ICV_LEN ||\r\nskb_headroom(skb) < WEP_IV_LEN))\r\nreturn NULL;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nnewhdr = skb_push(skb, WEP_IV_LEN);\r\nmemmove(newhdr, newhdr + WEP_IV_LEN, hdrlen);\r\nieee80211_wep_get_iv(local, keylen, keyidx, newhdr + hdrlen);\r\nreturn newhdr + hdrlen;\r\n}\r\nstatic void ieee80211_wep_remove_iv(struct ieee80211_local *local,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_key *key)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nunsigned int hdrlen;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nmemmove(skb->data + WEP_IV_LEN, skb->data, hdrlen);\r\nskb_pull(skb, WEP_IV_LEN);\r\n}\r\nint ieee80211_wep_encrypt_data(struct crypto_cipher *tfm, u8 *rc4key,\r\nsize_t klen, u8 *data, size_t data_len)\r\n{\r\n__le32 icv;\r\nint i;\r\nif (IS_ERR(tfm))\r\nreturn -1;\r\nicv = cpu_to_le32(~crc32_le(~0, data, data_len));\r\nput_unaligned(icv, (__le32 *)(data + data_len));\r\ncrypto_cipher_setkey(tfm, rc4key, klen);\r\nfor (i = 0; i < data_len + WEP_ICV_LEN; i++)\r\ncrypto_cipher_encrypt_one(tfm, data + i, data + i);\r\nreturn 0;\r\n}\r\nint ieee80211_wep_encrypt(struct ieee80211_local *local,\r\nstruct sk_buff *skb,\r\nconst u8 *key, int keylen, int keyidx)\r\n{\r\nu8 *iv;\r\nsize_t len;\r\nu8 rc4key[3 + WLAN_KEY_LEN_WEP104];\r\niv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);\r\nif (!iv)\r\nreturn -1;\r\nlen = skb->len - (iv + WEP_IV_LEN - skb->data);\r\nmemcpy(rc4key, iv, 3);\r\nmemcpy(rc4key + 3, key, keylen);\r\nskb_put(skb, WEP_ICV_LEN);\r\nreturn ieee80211_wep_encrypt_data(local->wep_tx_tfm, rc4key, keylen + 3,\r\niv + WEP_IV_LEN, len);\r\n}\r\nint ieee80211_wep_decrypt_data(struct crypto_cipher *tfm, u8 *rc4key,\r\nsize_t klen, u8 *data, size_t data_len)\r\n{\r\n__le32 crc;\r\nint i;\r\nif (IS_ERR(tfm))\r\nreturn -1;\r\ncrypto_cipher_setkey(tfm, rc4key, klen);\r\nfor (i = 0; i < data_len + WEP_ICV_LEN; i++)\r\ncrypto_cipher_decrypt_one(tfm, data + i, data + i);\r\ncrc = cpu_to_le32(~crc32_le(~0, data, data_len));\r\nif (memcmp(&crc, data + data_len, WEP_ICV_LEN) != 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ieee80211_wep_decrypt(struct ieee80211_local *local,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_key *key)\r\n{\r\nu32 klen;\r\nu8 rc4key[3 + WLAN_KEY_LEN_WEP104];\r\nu8 keyidx;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nunsigned int hdrlen;\r\nsize_t len;\r\nint ret = 0;\r\nif (!ieee80211_has_protected(hdr->frame_control))\r\nreturn -1;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nif (skb->len < hdrlen + WEP_IV_LEN + WEP_ICV_LEN)\r\nreturn -1;\r\nlen = skb->len - hdrlen - WEP_IV_LEN - WEP_ICV_LEN;\r\nkeyidx = skb->data[hdrlen + 3] >> 6;\r\nif (!key || keyidx != key->conf.keyidx)\r\nreturn -1;\r\nklen = 3 + key->conf.keylen;\r\nmemcpy(rc4key, skb->data + hdrlen, 3);\r\nmemcpy(rc4key + 3, key->conf.key, key->conf.keylen);\r\nif (ieee80211_wep_decrypt_data(local->wep_rx_tfm, rc4key, klen,\r\nskb->data + hdrlen + WEP_IV_LEN,\r\nlen))\r\nret = -1;\r\nskb_trim(skb, skb->len - WEP_ICV_LEN);\r\nmemmove(skb->data + WEP_IV_LEN, skb->data, hdrlen);\r\nskb_pull(skb, WEP_IV_LEN);\r\nreturn ret;\r\n}\r\nbool ieee80211_wep_is_weak_iv(struct sk_buff *skb, struct ieee80211_key *key)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nunsigned int hdrlen;\r\nu8 *ivpos;\r\nu32 iv;\r\nif (!ieee80211_has_protected(hdr->frame_control))\r\nreturn false;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nivpos = skb->data + hdrlen;\r\niv = (ivpos[0] << 16) | (ivpos[1] << 8) | ivpos[2];\r\nreturn ieee80211_wep_weak_iv(iv, key->conf.keylen);\r\n}\r\nieee80211_rx_result\r\nieee80211_crypto_wep_decrypt(struct ieee80211_rx_data *rx)\r\n{\r\nstruct sk_buff *skb = rx->skb;\r\nstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nif (!ieee80211_is_data(hdr->frame_control) &&\r\n!ieee80211_is_auth(hdr->frame_control))\r\nreturn RX_CONTINUE;\r\nif (!(status->flag & RX_FLAG_DECRYPTED)) {\r\nif (ieee80211_wep_decrypt(rx->local, rx->skb, rx->key))\r\nreturn RX_DROP_UNUSABLE;\r\n} else if (!(status->flag & RX_FLAG_IV_STRIPPED)) {\r\nieee80211_wep_remove_iv(rx->local, rx->skb, rx->key);\r\nskb_trim(rx->skb, rx->skb->len - WEP_ICV_LEN);\r\n}\r\nreturn RX_CONTINUE;\r\n}\r\nstatic int wep_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nif (!info->control.hw_key) {\r\nif (ieee80211_wep_encrypt(tx->local, skb, tx->key->conf.key,\r\ntx->key->conf.keylen,\r\ntx->key->conf.keyidx))\r\nreturn -1;\r\n} else if (info->control.hw_key->flags &\r\nIEEE80211_KEY_FLAG_GENERATE_IV) {\r\nif (!ieee80211_wep_add_iv(tx->local, skb,\r\ntx->key->conf.keylen,\r\ntx->key->conf.keyidx))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nieee80211_tx_result\r\nieee80211_crypto_wep_encrypt(struct ieee80211_tx_data *tx)\r\n{\r\nstruct sk_buff *skb;\r\nieee80211_tx_set_protected(tx);\r\nskb = tx->skb;\r\ndo {\r\nif (wep_encrypt_skb(tx, skb) < 0) {\r\nI802_DEBUG_INC(tx->local->tx_handlers_drop_wep);\r\nreturn TX_DROP;\r\n}\r\n} while ((skb = skb->next));\r\nreturn TX_CONTINUE;\r\n}
