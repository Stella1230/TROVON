acpi_status acpi_ev_init_global_lock_handler(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_init_global_lock_handler);\r\nstatus = acpi_install_fixed_event_handler(ACPI_EVENT_GLOBAL,\r\nacpi_ev_global_lock_handler,\r\nNULL);\r\nacpi_gbl_global_lock_present = FALSE;\r\nif (status == AE_NO_HARDWARE_RESPONSE) {\r\nACPI_ERROR((AE_INFO,\r\n"No response from Global Lock hardware, disabling lock"));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatus = acpi_os_create_lock(&acpi_gbl_global_lock_pending_lock);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_gbl_global_lock_pending = FALSE;\r\nacpi_gbl_global_lock_present = TRUE;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_ev_remove_global_lock_handler(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_remove_global_lock_handler);\r\nacpi_gbl_global_lock_present = FALSE;\r\nstatus = acpi_remove_fixed_event_handler(ACPI_EVENT_GLOBAL,\r\nacpi_ev_global_lock_handler);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic u32 acpi_ev_global_lock_handler(void *context)\r\n{\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nflags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);\r\nif (!acpi_gbl_global_lock_pending) {\r\ngoto cleanup_and_exit;\r\n}\r\nstatus = acpi_os_signal_semaphore(acpi_gbl_global_lock_semaphore, 1);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Could not signal Global Lock semaphore"));\r\n}\r\nacpi_gbl_global_lock_pending = FALSE;\r\ncleanup_and_exit:\r\nacpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);\r\nreturn (ACPI_INTERRUPT_HANDLED);\r\n}\r\nacpi_status acpi_ev_acquire_global_lock(u16 timeout)\r\n{\r\nacpi_cpu_flags flags;\r\nacpi_status status;\r\nu8 acquired = FALSE;\r\nACPI_FUNCTION_TRACE(ev_acquire_global_lock);\r\nstatus =\r\nacpi_ex_system_wait_mutex(acpi_gbl_global_lock_mutex->mutex.\r\nos_mutex, timeout);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_gbl_global_lock_handle++;\r\nif (acpi_gbl_global_lock_handle == 0) {\r\nacpi_gbl_global_lock_handle = 1;\r\n}\r\nif (!acpi_gbl_global_lock_present) {\r\nacpi_gbl_global_lock_acquired = TRUE;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);\r\ndo {\r\nACPI_ACQUIRE_GLOBAL_LOCK(acpi_gbl_FACS, acquired);\r\nif (acquired) {\r\nacpi_gbl_global_lock_acquired = TRUE;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Acquired hardware Global Lock\n"));\r\nbreak;\r\n}\r\nacpi_gbl_global_lock_pending = TRUE;\r\nacpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Waiting for hardware Global Lock\n"));\r\nstatus =\r\nacpi_ex_system_wait_semaphore\r\n(acpi_gbl_global_lock_semaphore, ACPI_WAIT_FOREVER);\r\nflags = acpi_os_acquire_lock(acpi_gbl_global_lock_pending_lock);\r\n} while (ACPI_SUCCESS(status));\r\nacpi_gbl_global_lock_pending = FALSE;\r\nacpi_os_release_lock(acpi_gbl_global_lock_pending_lock, flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_ev_release_global_lock(void)\r\n{\r\nu8 pending = FALSE;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(ev_release_global_lock);\r\nif (!acpi_gbl_global_lock_acquired) {\r\nACPI_WARNING((AE_INFO,\r\n"Cannot release the ACPI Global Lock, it has not been acquired"));\r\nreturn_ACPI_STATUS(AE_NOT_ACQUIRED);\r\n}\r\nif (acpi_gbl_global_lock_present) {\r\nACPI_RELEASE_GLOBAL_LOCK(acpi_gbl_FACS, pending);\r\nif (pending) {\r\nstatus =\r\nacpi_write_bit_register\r\n(ACPI_BITREG_GLOBAL_LOCK_RELEASE,\r\nACPI_ENABLE_EVENT);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Released hardware Global Lock\n"));\r\n}\r\nacpi_gbl_global_lock_acquired = FALSE;\r\nacpi_os_release_mutex(acpi_gbl_global_lock_mutex->mutex.os_mutex);\r\nreturn_ACPI_STATUS(status);\r\n}
