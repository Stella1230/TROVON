static __cpuinit void check_tsc_warp(void)\r\n{\r\ncycles_t start, now, prev, end;\r\nint i;\r\nrdtsc_barrier();\r\nstart = get_cycles();\r\nrdtsc_barrier();\r\nend = start + tsc_khz * 20ULL;\r\nnow = start;\r\nfor (i = 0; ; i++) {\r\narch_spin_lock(&sync_lock);\r\nprev = last_tsc;\r\nrdtsc_barrier();\r\nnow = get_cycles();\r\nrdtsc_barrier();\r\nlast_tsc = now;\r\narch_spin_unlock(&sync_lock);\r\nif (unlikely(!(i & 7))) {\r\nif (now > end || i > 10000000)\r\nbreak;\r\ncpu_relax();\r\ntouch_nmi_watchdog();\r\n}\r\nif (unlikely(prev > now)) {\r\narch_spin_lock(&sync_lock);\r\nmax_warp = max(max_warp, prev - now);\r\nnr_warps++;\r\narch_spin_unlock(&sync_lock);\r\n}\r\n}\r\nWARN(!(now-start),\r\n"Warning: zero tsc calibration delta: %Ld [max: %Ld]\n",\r\nnow-start, end-start);\r\n}\r\nvoid __cpuinit check_tsc_sync_source(int cpu)\r\n{\r\nint cpus = 2;\r\nif (unsynchronized_tsc())\r\nreturn;\r\nif (boot_cpu_has(X86_FEATURE_TSC_RELIABLE)) {\r\nif (cpu == (nr_cpu_ids-1) || system_state != SYSTEM_BOOTING)\r\npr_info(\r\n"Skipped synchronization checks as TSC is reliable.\n");\r\nreturn;\r\n}\r\natomic_set(&stop_count, 0);\r\nwhile (atomic_read(&start_count) != cpus-1)\r\ncpu_relax();\r\natomic_inc(&start_count);\r\ncheck_tsc_warp();\r\nwhile (atomic_read(&stop_count) != cpus-1)\r\ncpu_relax();\r\nif (nr_warps) {\r\npr_warning("TSC synchronization [CPU#%d -> CPU#%d]:\n",\r\nsmp_processor_id(), cpu);\r\npr_warning("Measured %Ld cycles TSC warp between CPUs, "\r\n"turning off TSC clock.\n", max_warp);\r\nmark_tsc_unstable("check_tsc_sync_source failed");\r\n} else {\r\npr_debug("TSC synchronization [CPU#%d -> CPU#%d]: passed\n",\r\nsmp_processor_id(), cpu);\r\n}\r\natomic_set(&start_count, 0);\r\nnr_warps = 0;\r\nmax_warp = 0;\r\nlast_tsc = 0;\r\natomic_inc(&stop_count);\r\n}\r\nvoid __cpuinit check_tsc_sync_target(void)\r\n{\r\nint cpus = 2;\r\nif (unsynchronized_tsc() || boot_cpu_has(X86_FEATURE_TSC_RELIABLE))\r\nreturn;\r\natomic_inc(&start_count);\r\nwhile (atomic_read(&start_count) != cpus)\r\ncpu_relax();\r\ncheck_tsc_warp();\r\natomic_inc(&stop_count);\r\nwhile (atomic_read(&stop_count) != cpus)\r\ncpu_relax();\r\n}
