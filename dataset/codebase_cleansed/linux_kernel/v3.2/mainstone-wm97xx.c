static void wm97xx_acc_pen_up(struct wm97xx *wm)\r\n{\r\nschedule_timeout_uninterruptible(1);\r\nwhile (MISR & (1 << 2))\r\nMODR;\r\n}\r\nstatic void wm97xx_acc_pen_up(struct wm97xx *wm)\r\n{\r\nunsigned int count;\r\nschedule_timeout_uninterruptible(1);\r\nfor (count = 0; count < 16; count++)\r\nMODR;\r\n}\r\nstatic int wm97xx_acc_pen_down(struct wm97xx *wm)\r\n{\r\nu16 x, y, p = 0x100 | WM97XX_ADCSEL_PRES;\r\nint reads = 0;\r\nschedule_timeout_uninterruptible(1);\r\nif (tries > 5) {\r\ntries = 0;\r\nreturn RC_PENUP;\r\n}\r\nx = MODR;\r\nif (x == last) {\r\ntries++;\r\nreturn RC_AGAIN;\r\n}\r\nlast = x;\r\ndo {\r\nif (reads)\r\nx = MODR;\r\ny = MODR;\r\nif (pressure)\r\np = MODR;\r\ndev_dbg(wm->dev, "Raw coordinates: x=%x, y=%x, p=%x\n",\r\nx, y, p);\r\nif ((x & WM97XX_ADCSEL_MASK) != WM97XX_ADCSEL_X ||\r\n(y & WM97XX_ADCSEL_MASK) != WM97XX_ADCSEL_Y ||\r\n(p & WM97XX_ADCSEL_MASK) != WM97XX_ADCSEL_PRES)\r\ngoto up;\r\ntries = 0;\r\ninput_report_abs(wm->input_dev, ABS_X, x & 0xfff);\r\ninput_report_abs(wm->input_dev, ABS_Y, y & 0xfff);\r\ninput_report_abs(wm->input_dev, ABS_PRESSURE, p & 0xfff);\r\ninput_report_key(wm->input_dev, BTN_TOUCH, (p != 0));\r\ninput_sync(wm->input_dev);\r\nreads++;\r\n} while (reads < cinfo[sp_idx].reads);\r\nup:\r\nreturn RC_PENDOWN | RC_AGAIN;\r\n}\r\nstatic int wm97xx_acc_startup(struct wm97xx *wm)\r\n{\r\nint idx = 0, ret = 0;\r\nif (wm->ac97 == NULL)\r\nreturn -ENODEV;\r\nfor (idx = 0; idx < ARRAY_SIZE(cinfo); idx++) {\r\nif (wm->id != cinfo[idx].id)\r\ncontinue;\r\nsp_idx = idx;\r\nif (cont_rate <= cinfo[idx].speed)\r\nbreak;\r\n}\r\nwm->acc_rate = cinfo[sp_idx].code;\r\nwm->acc_slot = ac97_touch_slot;\r\ndev_info(wm->dev,\r\n"mainstone accelerated touchscreen driver, %d samples/sec\n",\r\ncinfo[sp_idx].speed);\r\nif (machine_is_palmt5() || machine_is_palmtx() || machine_is_palmld()) {\r\npen_int = 1;\r\nirq = 27;\r\nwm->variant = WM97xx_WM1613;\r\n} else if (machine_is_mainstone() && pen_int)\r\nirq = 4;\r\nif (irq) {\r\nret = gpio_request(irq, "Touchscreen IRQ");\r\nif (ret)\r\ngoto out;\r\nret = gpio_direction_input(irq);\r\nif (ret) {\r\ngpio_free(irq);\r\ngoto out;\r\n}\r\nwm->pen_irq = gpio_to_irq(irq);\r\nirq_set_irq_type(wm->pen_irq, IRQ_TYPE_EDGE_BOTH);\r\n} else\r\npen_int = 0;\r\nif (pen_int) {\r\nswitch (wm->id) {\r\ncase WM9705_ID2:\r\nbreak;\r\ncase WM9712_ID2:\r\ncase WM9713_ID2:\r\nwm97xx_config_gpio(wm, WM97XX_GPIO_13, WM97XX_GPIO_IN,\r\nWM97XX_GPIO_POL_HIGH,\r\nWM97XX_GPIO_STICKY,\r\nWM97XX_GPIO_WAKE);\r\nwm97xx_config_gpio(wm, WM97XX_GPIO_2, WM97XX_GPIO_OUT,\r\nWM97XX_GPIO_POL_HIGH,\r\nWM97XX_GPIO_NOTSTICKY,\r\nWM97XX_GPIO_NOWAKE);\r\nbreak;\r\ndefault:\r\ndev_err(wm->dev,\r\n"pen down irq not supported on this device\n");\r\npen_int = 0;\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void wm97xx_acc_shutdown(struct wm97xx *wm)\r\n{\r\nif (pen_int) {\r\nif (irq)\r\ngpio_free(irq);\r\nwm->pen_irq = 0;\r\n}\r\n}\r\nstatic void wm97xx_irq_enable(struct wm97xx *wm, int enable)\r\n{\r\nif (enable)\r\nenable_irq(wm->pen_irq);\r\nelse\r\ndisable_irq_nosync(wm->pen_irq);\r\n}\r\nstatic int mainstone_wm97xx_probe(struct platform_device *pdev)\r\n{\r\nstruct wm97xx *wm = platform_get_drvdata(pdev);\r\nreturn wm97xx_register_mach_ops(wm, &mainstone_mach_ops);\r\n}\r\nstatic int mainstone_wm97xx_remove(struct platform_device *pdev)\r\n{\r\nstruct wm97xx *wm = platform_get_drvdata(pdev);\r\nwm97xx_unregister_mach_ops(wm);\r\nreturn 0;\r\n}\r\nstatic int __init mainstone_wm97xx_init(void)\r\n{\r\nreturn platform_driver_register(&mainstone_wm97xx_driver);\r\n}\r\nstatic void __exit mainstone_wm97xx_exit(void)\r\n{\r\nplatform_driver_unregister(&mainstone_wm97xx_driver);\r\n}
