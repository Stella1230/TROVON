static int set_brk(unsigned long start, unsigned long end)\r\n{\r\nstart = PAGE_ALIGN(start);\r\nend = PAGE_ALIGN(end);\r\nif (end > start) {\r\nunsigned long addr;\r\ndown_write(&current->mm->mmap_sem);\r\naddr = do_brk(start, end - start);\r\nup_write(&current->mm->mmap_sem);\r\nif (BAD_ADDR(addr))\r\nreturn addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aout_core_dump(struct coredump_params *cprm)\r\n{\r\nstruct file *file = cprm->file;\r\nmm_segment_t fs;\r\nint has_dumped = 0;\r\nvoid __user *dump_start;\r\nint dump_size;\r\nstruct user dump;\r\n#ifdef __alpha__\r\n# define START_DATA(u) ((void __user *)u.start_data)\r\n#else\r\n# define START_DATA(u) ((void __user *)((u.u_tsize << PAGE_SHIFT) + \\r\nu.start_code))\r\n#endif\r\n# define START_STACK(u) ((void __user *)u.start_stack)\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nhas_dumped = 1;\r\ncurrent->flags |= PF_DUMPCORE;\r\nstrncpy(dump.u_comm, current->comm, sizeof(dump.u_comm));\r\ndump.u_ar0 = offsetof(struct user, regs);\r\ndump.signal = cprm->signr;\r\naout_dump_thread(cprm->regs, &dump);\r\nif ((dump.u_dsize + dump.u_ssize+1) * PAGE_SIZE > cprm->limit)\r\ndump.u_dsize = 0;\r\nif ((dump.u_ssize + 1) * PAGE_SIZE > cprm->limit)\r\ndump.u_ssize = 0;\r\nset_fs(USER_DS);\r\nif (!access_ok(VERIFY_READ, START_DATA(dump), dump.u_dsize << PAGE_SHIFT))\r\ndump.u_dsize = 0;\r\nif (!access_ok(VERIFY_READ, START_STACK(dump), dump.u_ssize << PAGE_SHIFT))\r\ndump.u_ssize = 0;\r\nset_fs(KERNEL_DS);\r\nif (!dump_write(file, &dump, sizeof(dump)))\r\ngoto end_coredump;\r\nif (!dump_seek(cprm->file, PAGE_SIZE - sizeof(dump)))\r\ngoto end_coredump;\r\nset_fs(USER_DS);\r\nif (dump.u_dsize != 0) {\r\ndump_start = START_DATA(dump);\r\ndump_size = dump.u_dsize << PAGE_SHIFT;\r\nif (!dump_write(file, dump_start, dump_size))\r\ngoto end_coredump;\r\n}\r\nif (dump.u_ssize != 0) {\r\ndump_start = START_STACK(dump);\r\ndump_size = dump.u_ssize << PAGE_SHIFT;\r\nif (!dump_write(file, dump_start, dump_size))\r\ngoto end_coredump;\r\n}\r\nend_coredump:\r\nset_fs(fs);\r\nreturn has_dumped;\r\n}\r\nstatic unsigned long __user *create_aout_tables(char __user *p, struct linux_binprm * bprm)\r\n{\r\nchar __user * __user *argv;\r\nchar __user * __user *envp;\r\nunsigned long __user *sp;\r\nint argc = bprm->argc;\r\nint envc = bprm->envc;\r\nsp = (void __user *)((-(unsigned long)sizeof(char *)) & (unsigned long) p);\r\n#ifdef __alpha__\r\nput_user(0, --sp);\r\nput_user(0, --sp);\r\nif (bprm->loader) {\r\nput_user(0, --sp);\r\nput_user(1003, --sp);\r\nput_user(bprm->loader, --sp);\r\nput_user(1002, --sp);\r\n}\r\nput_user(bprm->exec, --sp);\r\nput_user(1001, --sp);\r\n#endif\r\nsp -= envc+1;\r\nenvp = (char __user * __user *) sp;\r\nsp -= argc+1;\r\nargv = (char __user * __user *) sp;\r\n#ifndef __alpha__\r\nput_user((unsigned long) envp,--sp);\r\nput_user((unsigned long) argv,--sp);\r\n#endif\r\nput_user(argc,--sp);\r\ncurrent->mm->arg_start = (unsigned long) p;\r\nwhile (argc-->0) {\r\nchar c;\r\nput_user(p,argv++);\r\ndo {\r\nget_user(c,p++);\r\n} while (c);\r\n}\r\nput_user(NULL,argv);\r\ncurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\r\nwhile (envc-->0) {\r\nchar c;\r\nput_user(p,envp++);\r\ndo {\r\nget_user(c,p++);\r\n} while (c);\r\n}\r\nput_user(NULL,envp);\r\ncurrent->mm->env_end = (unsigned long) p;\r\nreturn sp;\r\n}\r\nstatic int load_aout_binary(struct linux_binprm * bprm, struct pt_regs * regs)\r\n{\r\nstruct exec ex;\r\nunsigned long error;\r\nunsigned long fd_offset;\r\nunsigned long rlim;\r\nint retval;\r\nex = *((struct exec *) bprm->buf);\r\nif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != OMAGIC &&\r\nN_MAGIC(ex) != QMAGIC && N_MAGIC(ex) != NMAGIC) ||\r\nN_TRSIZE(ex) || N_DRSIZE(ex) ||\r\ni_size_read(bprm->file->f_path.dentry->d_inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\r\nreturn -ENOEXEC;\r\n}\r\nif (!bprm->file->f_op || !bprm->file->f_op->mmap)\r\nreturn -ENOEXEC;\r\nfd_offset = N_TXTOFF(ex);\r\nrlim = rlimit(RLIMIT_DATA);\r\nif (rlim >= RLIM_INFINITY)\r\nrlim = ~0;\r\nif (ex.a_data + ex.a_bss > rlim)\r\nreturn -ENOMEM;\r\nretval = flush_old_exec(bprm);\r\nif (retval)\r\nreturn retval;\r\n#ifdef __alpha__\r\nSET_AOUT_PERSONALITY(bprm, ex);\r\n#else\r\nset_personality(PER_LINUX);\r\n#endif\r\nsetup_new_exec(bprm);\r\ncurrent->mm->end_code = ex.a_text +\r\n(current->mm->start_code = N_TXTADDR(ex));\r\ncurrent->mm->end_data = ex.a_data +\r\n(current->mm->start_data = N_DATADDR(ex));\r\ncurrent->mm->brk = ex.a_bss +\r\n(current->mm->start_brk = N_BSSADDR(ex));\r\ncurrent->mm->free_area_cache = current->mm->mmap_base;\r\ncurrent->mm->cached_hole_size = 0;\r\ninstall_exec_creds(bprm);\r\ncurrent->flags &= ~PF_FORKNOEXEC;\r\nif (N_MAGIC(ex) == OMAGIC) {\r\nunsigned long text_addr, map_size;\r\nloff_t pos;\r\ntext_addr = N_TXTADDR(ex);\r\n#ifdef __alpha__\r\npos = fd_offset;\r\nmap_size = ex.a_text+ex.a_data + PAGE_SIZE - 1;\r\n#else\r\npos = 32;\r\nmap_size = ex.a_text+ex.a_data;\r\n#endif\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_brk(text_addr & PAGE_MASK, map_size);\r\nup_write(&current->mm->mmap_sem);\r\nif (error != (text_addr & PAGE_MASK)) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\nerror = bprm->file->f_op->read(bprm->file,\r\n(char __user *)text_addr,\r\nex.a_text+ex.a_data, &pos);\r\nif ((signed long)error < 0) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\nflush_icache_range(text_addr, text_addr+ex.a_text+ex.a_data);\r\n} else {\r\nif ((ex.a_text & 0xfff || ex.a_data & 0xfff) &&\r\n(N_MAGIC(ex) != NMAGIC) && printk_ratelimit())\r\n{\r\nprintk(KERN_NOTICE "executable not page aligned\n");\r\n}\r\nif ((fd_offset & ~PAGE_MASK) != 0 && printk_ratelimit())\r\n{\r\nprintk(KERN_WARNING\r\n"fd_offset is not page aligned. Please convert program: %s\n",\r\nbprm->file->f_path.dentry->d_name.name);\r\n}\r\nif (!bprm->file->f_op->mmap||((fd_offset & ~PAGE_MASK) != 0)) {\r\nloff_t pos = fd_offset;\r\ndown_write(&current->mm->mmap_sem);\r\ndo_brk(N_TXTADDR(ex), ex.a_text+ex.a_data);\r\nup_write(&current->mm->mmap_sem);\r\nbprm->file->f_op->read(bprm->file,\r\n(char __user *)N_TXTADDR(ex),\r\nex.a_text+ex.a_data, &pos);\r\nflush_icache_range((unsigned long) N_TXTADDR(ex),\r\n(unsigned long) N_TXTADDR(ex) +\r\nex.a_text+ex.a_data);\r\ngoto beyond_if;\r\n}\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_mmap(bprm->file, N_TXTADDR(ex), ex.a_text,\r\nPROT_READ | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\r\nfd_offset);\r\nup_write(&current->mm->mmap_sem);\r\nif (error != N_TXTADDR(ex)) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_mmap(bprm->file, N_DATADDR(ex), ex.a_data,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\r\nfd_offset + ex.a_text);\r\nup_write(&current->mm->mmap_sem);\r\nif (error != N_DATADDR(ex)) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn error;\r\n}\r\n}\r\nbeyond_if:\r\nset_binfmt(&aout_format);\r\nretval = set_brk(current->mm->start_brk, current->mm->brk);\r\nif (retval < 0) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn retval;\r\n}\r\nretval = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\r\nif (retval < 0) {\r\nsend_sig(SIGKILL, current, 0);\r\nreturn retval;\r\n}\r\ncurrent->mm->start_stack =\r\n(unsigned long) create_aout_tables((char __user *) bprm->p, bprm);\r\n#ifdef __alpha__\r\nregs->gp = ex.a_gpvalue;\r\n#endif\r\nstart_thread(regs, ex.a_entry, current->mm->start_stack);\r\nreturn 0;\r\n}\r\nstatic int load_aout_library(struct file *file)\r\n{\r\nstruct inode * inode;\r\nunsigned long bss, start_addr, len;\r\nunsigned long error;\r\nint retval;\r\nstruct exec ex;\r\ninode = file->f_path.dentry->d_inode;\r\nretval = -ENOEXEC;\r\nerror = kernel_read(file, 0, (char *) &ex, sizeof(ex));\r\nif (error != sizeof(ex))\r\ngoto out;\r\nif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\r\nN_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\r\ni_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\r\ngoto out;\r\n}\r\nif (!file->f_op || !file->f_op->mmap)\r\ngoto out;\r\nif (N_FLAGS(ex))\r\ngoto out;\r\nstart_addr = ex.a_entry & 0xfffff000;\r\nif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\r\nloff_t pos = N_TXTOFF(ex);\r\nif (printk_ratelimit())\r\n{\r\nprintk(KERN_WARNING\r\n"N_TXTOFF is not page aligned. Please convert library: %s\n",\r\nfile->f_path.dentry->d_name.name);\r\n}\r\ndown_write(&current->mm->mmap_sem);\r\ndo_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\r\nup_write(&current->mm->mmap_sem);\r\nfile->f_op->read(file, (char __user *)start_addr,\r\nex.a_text + ex.a_data, &pos);\r\nflush_icache_range((unsigned long) start_addr,\r\n(unsigned long) start_addr + ex.a_text + ex.a_data);\r\nretval = 0;\r\ngoto out;\r\n}\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_mmap(file, start_addr, ex.a_text + ex.a_data,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\r\nN_TXTOFF(ex));\r\nup_write(&current->mm->mmap_sem);\r\nretval = error;\r\nif (error != start_addr)\r\ngoto out;\r\nlen = PAGE_ALIGN(ex.a_text + ex.a_data);\r\nbss = ex.a_text + ex.a_data + ex.a_bss;\r\nif (bss > len) {\r\ndown_write(&current->mm->mmap_sem);\r\nerror = do_brk(start_addr + len, bss - len);\r\nup_write(&current->mm->mmap_sem);\r\nretval = error;\r\nif (error != start_addr + len)\r\ngoto out;\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int __init init_aout_binfmt(void)\r\n{\r\nreturn register_binfmt(&aout_format);\r\n}\r\nstatic void __exit exit_aout_binfmt(void)\r\n{\r\nunregister_binfmt(&aout_format);\r\n}
