static unsigned char *response_name(unsigned char value)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(lk_response); i++)\r\nif (lk_response[i].value == value)\r\nreturn lk_response[i].name;\r\nreturn "<unknown>";\r\n}\r\nstatic unsigned char volume_to_hw(int volume_percent)\r\n{\r\nunsigned char ret = 0;\r\nif (volume_percent < 0)\r\nvolume_percent = 0;\r\nif (volume_percent > 100)\r\nvolume_percent = 100;\r\nif (volume_percent >= 0)\r\nret = 7;\r\nif (volume_percent >= 13)\r\nret = 6;\r\nif (volume_percent >= 25)\r\nret = 5;\r\nif (volume_percent >= 38)\r\nret = 4;\r\nif (volume_percent >= 50)\r\nret = 3;\r\nif (volume_percent >= 63)\r\nret = 2;\r\nif (volume_percent >= 75)\r\nret = 1;\r\nif (volume_percent >= 88)\r\nret = 0;\r\nret |= 0x80;\r\nreturn ret;\r\n}\r\nstatic void lkkbd_detection_done(struct lkkbd *lk)\r\n{\r\nint i;\r\nlk->keycode[0xb1] = KEY_COMPOSE;\r\nswitch (lk->id[4]) {\r\ncase 1:\r\nstrlcpy(lk->name, "DEC LK201 keyboard", sizeof(lk->name));\r\nif (lk201_compose_is_alt)\r\nlk->keycode[0xb1] = KEY_LEFTALT;\r\nbreak;\r\ncase 2:\r\nstrlcpy(lk->name, "DEC LK401 keyboard", sizeof(lk->name));\r\nbreak;\r\ndefault:\r\nstrlcpy(lk->name, "Unknown DEC keyboard", sizeof(lk->name));\r\nprintk(KERN_ERR\r\n"lkkbd: keyboard on %s is unknown, please report to "\r\n"Jan-Benedict Glaw <jbglaw@lug-owl.de>\n", lk->phys);\r\nprintk(KERN_ERR "lkkbd: keyboard ID'ed as:");\r\nfor (i = 0; i < LK_NUM_IGNORE_BYTES; i++)\r\nprintk(" 0x%02x", lk->id[i]);\r\nprintk("\n");\r\nbreak;\r\n}\r\nprintk(KERN_INFO "lkkbd: keyboard on %s identified as: %s\n",\r\nlk->phys, lk->name);\r\nswitch (lk->id[2]) {\r\ncase 0x00:\r\nbreak;\r\ncase LK_STUCK_KEY:\r\nprintk(KERN_ERR "lkkbd: Stuck key on keyboard at %s\n",\r\nlk->phys);\r\nbreak;\r\ncase LK_SELFTEST_FAILED:\r\nprintk(KERN_ERR\r\n"lkkbd: Selftest failed on keyboard at %s, "\r\n"keyboard may not work properly\n", lk->phys);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"lkkbd: Unknown error %02x on keyboard at %s\n",\r\nlk->id[2], lk->phys);\r\nbreak;\r\n}\r\nif (lk->id[2] == LK_STUCK_KEY && lk->id[3] != 0)\r\nprintk(KERN_ERR\r\n"Scancode of stuck key is 0x%02x, keycode is 0x%04x\n",\r\nlk->id[3], lk->keycode[lk->id[3]]);\r\n}\r\nstatic irqreturn_t lkkbd_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct lkkbd *lk = serio_get_drvdata(serio);\r\nstruct input_dev *input_dev = lk->dev;\r\nunsigned int keycode;\r\nint i;\r\nDBG(KERN_INFO "Got byte 0x%02x\n", data);\r\nif (lk->ignore_bytes > 0) {\r\nDBG(KERN_INFO "Ignoring a byte on %s\n", lk->name);\r\nlk->id[LK_NUM_IGNORE_BYTES - lk->ignore_bytes--] = data;\r\nif (lk->ignore_bytes == 0)\r\nlkkbd_detection_done(lk);\r\nreturn IRQ_HANDLED;\r\n}\r\nswitch (data) {\r\ncase LK_ALL_KEYS_UP:\r\nfor (i = 0; i < ARRAY_SIZE(lkkbd_keycode); i++)\r\ninput_report_key(input_dev, lk->keycode[i], 0);\r\ninput_sync(input_dev);\r\nbreak;\r\ncase 0x01:\r\nDBG(KERN_INFO "Got 0x01, scheduling re-initialization\n");\r\nlk->ignore_bytes = LK_NUM_IGNORE_BYTES;\r\nlk->id[LK_NUM_IGNORE_BYTES - lk->ignore_bytes--] = data;\r\nschedule_work(&lk->tq);\r\nbreak;\r\ncase LK_METRONOME:\r\ncase LK_OUTPUT_ERROR:\r\ncase LK_INPUT_ERROR:\r\ncase LK_KBD_LOCKED:\r\ncase LK_KBD_TEST_MODE_ACK:\r\ncase LK_PREFIX_KEY_DOWN:\r\ncase LK_MODE_CHANGE_ACK:\r\ncase LK_RESPONSE_RESERVED:\r\nDBG(KERN_INFO "Got %s and don't know how to handle...\n",\r\nresponse_name(data));\r\nbreak;\r\ndefault:\r\nkeycode = lk->keycode[data];\r\nif (keycode != KEY_RESERVED) {\r\ninput_report_key(input_dev, keycode,\r\n!test_bit(keycode, input_dev->key));\r\ninput_sync(input_dev);\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s: Unknown key with scancode 0x%02x on %s.\n",\r\n__FILE__, data, lk->name);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void lkkbd_toggle_leds(struct lkkbd *lk)\r\n{\r\nstruct serio *serio = lk->serio;\r\nunsigned char leds_on = 0;\r\nunsigned char leds_off = 0;\r\nCHECK_LED(lk, leds_on, leds_off, LED_CAPSL, LK_LED_SHIFTLOCK);\r\nCHECK_LED(lk, leds_on, leds_off, LED_COMPOSE, LK_LED_COMPOSE);\r\nCHECK_LED(lk, leds_on, leds_off, LED_SCROLLL, LK_LED_SCROLLLOCK);\r\nCHECK_LED(lk, leds_on, leds_off, LED_SLEEP, LK_LED_WAIT);\r\nif (leds_on != 0) {\r\nserio_write(serio, LK_CMD_LED_ON);\r\nserio_write(serio, leds_on);\r\n}\r\nif (leds_off != 0) {\r\nserio_write(serio, LK_CMD_LED_OFF);\r\nserio_write(serio, leds_off);\r\n}\r\n}\r\nstatic void lkkbd_toggle_keyclick(struct lkkbd *lk, bool on)\r\n{\r\nstruct serio *serio = lk->serio;\r\nif (on) {\r\nDBG("%s: Activating key clicks\n", __func__);\r\nserio_write(serio, LK_CMD_ENABLE_KEYCLICK);\r\nserio_write(serio, volume_to_hw(lk->keyclick_volume));\r\nserio_write(serio, LK_CMD_ENABLE_CTRCLICK);\r\nserio_write(serio, volume_to_hw(lk->ctrlclick_volume));\r\n} else {\r\nDBG("%s: Deactivating key clicks\n", __func__);\r\nserio_write(serio, LK_CMD_DISABLE_KEYCLICK);\r\nserio_write(serio, LK_CMD_DISABLE_CTRCLICK);\r\n}\r\n}\r\nstatic int lkkbd_event(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct lkkbd *lk = input_get_drvdata(dev);\r\nswitch (type) {\r\ncase EV_LED:\r\nlkkbd_toggle_leds(lk);\r\nreturn 0;\r\ncase EV_SND:\r\nswitch (code) {\r\ncase SND_CLICK:\r\nlkkbd_toggle_keyclick(lk, value);\r\nreturn 0;\r\ncase SND_BELL:\r\nif (value != 0)\r\nserio_write(lk->serio, LK_CMD_SOUND_BELL);\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s(): Got unknown type %d, code %d, value %d\n",\r\n__func__, type, code, value);\r\n}\r\nreturn -1;\r\n}\r\nstatic void lkkbd_reinit(struct work_struct *work)\r\n{\r\nstruct lkkbd *lk = container_of(work, struct lkkbd, tq);\r\nint division;\r\nserio_write(lk->serio, LK_CMD_REQUEST_ID);\r\nserio_write(lk->serio, LK_CMD_SET_DEFAULTS);\r\nlkkbd_toggle_leds(lk);\r\nserio_write(lk->serio, LK_CMD_ENABLE_LK401);\r\nfor (division = 1; division <= 14; division++)\r\nserio_write(lk->serio,\r\nLK_CMD_SET_MODE(LK_MODE_UPDOWN, division));\r\nserio_write(lk->serio, LK_CMD_ENABLE_BELL);\r\nserio_write(lk->serio, volume_to_hw(lk->bell_volume));\r\nlkkbd_toggle_keyclick(lk, test_bit(SND_CLICK, lk->dev->snd));\r\nif (test_bit(SND_BELL, lk->dev->snd))\r\nserio_write(lk->serio, LK_CMD_SOUND_BELL);\r\n}\r\nstatic int lkkbd_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct lkkbd *lk;\r\nstruct input_dev *input_dev;\r\nint i;\r\nint err;\r\nlk = kzalloc(sizeof(struct lkkbd), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!lk || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nlk->serio = serio;\r\nlk->dev = input_dev;\r\nINIT_WORK(&lk->tq, lkkbd_reinit);\r\nlk->bell_volume = bell_volume;\r\nlk->keyclick_volume = keyclick_volume;\r\nlk->ctrlclick_volume = ctrlclick_volume;\r\nmemcpy(lk->keycode, lkkbd_keycode, sizeof(lk->keycode));\r\nstrlcpy(lk->name, "DEC LK keyboard", sizeof(lk->name));\r\nsnprintf(lk->phys, sizeof(lk->phys), "%s/input0", serio->phys);\r\ninput_dev->name = lk->name;\r\ninput_dev->phys = lk->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_LKKBD;\r\ninput_dev->id.product = 0;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->event = lkkbd_event;\r\ninput_set_drvdata(input_dev, lk);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_LED, input_dev->evbit);\r\n__set_bit(EV_SND, input_dev->evbit);\r\n__set_bit(EV_REP, input_dev->evbit);\r\n__set_bit(LED_CAPSL, input_dev->ledbit);\r\n__set_bit(LED_SLEEP, input_dev->ledbit);\r\n__set_bit(LED_COMPOSE, input_dev->ledbit);\r\n__set_bit(LED_SCROLLL, input_dev->ledbit);\r\n__set_bit(SND_BELL, input_dev->sndbit);\r\n__set_bit(SND_CLICK, input_dev->sndbit);\r\ninput_dev->keycode = lk->keycode;\r\ninput_dev->keycodesize = sizeof(lk->keycode[0]);\r\ninput_dev->keycodemax = ARRAY_SIZE(lk->keycode);\r\nfor (i = 0; i < LK_NUM_KEYCODES; i++)\r\n__set_bit(lk->keycode[i], input_dev->keybit);\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\nserio_set_drvdata(serio, lk);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(lk->dev);\r\nif (err)\r\ngoto fail3;\r\nserio_write(lk->serio, LK_CMD_POWERCYCLE_RESET);\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(lk);\r\nreturn err;\r\n}\r\nstatic void lkkbd_disconnect(struct serio *serio)\r\n{\r\nstruct lkkbd *lk = serio_get_drvdata(serio);\r\ninput_get_device(lk->dev);\r\ninput_unregister_device(lk->dev);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_put_device(lk->dev);\r\nkfree(lk);\r\n}\r\nstatic int __init lkkbd_init(void)\r\n{\r\nreturn serio_register_driver(&lkkbd_drv);\r\n}\r\nstatic void __exit lkkbd_exit(void)\r\n{\r\nserio_unregister_driver(&lkkbd_drv);\r\n}
