static inline int\r\ncompute_yday(efi_time_t *eft)\r\n{\r\nreturn rtc_year_days(eft->day - 1, eft->month - 1, eft->year);\r\n}\r\nstatic int\r\ncompute_wday(efi_time_t *eft)\r\n{\r\nint y;\r\nint ndays = 0;\r\nif (eft->year < 1998) {\r\nprintk(KERN_ERR "efirtc: EFI year < 1998, invalid date\n");\r\nreturn -1;\r\n}\r\nfor (y = EFI_RTC_EPOCH; y < eft->year; y++)\r\nndays += 365 + (is_leap_year(y) ? 1 : 0);\r\nndays += compute_yday(eft);\r\nreturn (ndays + 4) % 7;\r\n}\r\nstatic void\r\nconvert_to_efi_time(struct rtc_time *wtime, efi_time_t *eft)\r\n{\r\neft->year = wtime->tm_year + 1900;\r\neft->month = wtime->tm_mon + 1;\r\neft->day = wtime->tm_mday;\r\neft->hour = wtime->tm_hour;\r\neft->minute = wtime->tm_min;\r\neft->second = wtime->tm_sec;\r\neft->nanosecond = 0;\r\neft->daylight = wtime->tm_isdst ? EFI_ISDST : 0;\r\neft->timezone = EFI_UNSPECIFIED_TIMEZONE;\r\n}\r\nstatic void\r\nconvert_from_efi_time(efi_time_t *eft, struct rtc_time *wtime)\r\n{\r\nmemset(wtime, 0, sizeof(*wtime));\r\nwtime->tm_sec = eft->second;\r\nwtime->tm_min = eft->minute;\r\nwtime->tm_hour = eft->hour;\r\nwtime->tm_mday = eft->day;\r\nwtime->tm_mon = eft->month - 1;\r\nwtime->tm_year = eft->year - 1900;\r\nwtime->tm_wday = compute_wday(eft);\r\nwtime->tm_yday = compute_yday(eft);\r\nswitch (eft->daylight & EFI_ISDST) {\r\ncase EFI_ISDST:\r\nwtime->tm_isdst = 1;\r\nbreak;\r\ncase EFI_TIME_ADJUST_DAYLIGHT:\r\nwtime->tm_isdst = 0;\r\nbreak;\r\ndefault:\r\nwtime->tm_isdst = -1;\r\n}\r\n}\r\nstatic int efi_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nefi_time_t eft;\r\nefi_status_t status;\r\nstatus = efi.get_wakeup_time((efi_bool_t *)&wkalrm->enabled,\r\n(efi_bool_t *)&wkalrm->pending, &eft);\r\nif (status != EFI_SUCCESS)\r\nreturn -EINVAL;\r\nconvert_from_efi_time(&eft, &wkalrm->time);\r\nreturn rtc_valid_tm(&wkalrm->time);\r\n}\r\nstatic int efi_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nefi_time_t eft;\r\nefi_status_t status;\r\nconvert_to_efi_time(&wkalrm->time, &eft);\r\nstatus = efi.set_wakeup_time((efi_bool_t)wkalrm->enabled, &eft);\r\nprintk(KERN_WARNING "write status is %d\n", (int)status);\r\nreturn status == EFI_SUCCESS ? 0 : -EINVAL;\r\n}\r\nstatic int efi_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nefi_status_t status;\r\nefi_time_t eft;\r\nefi_time_cap_t cap;\r\nstatus = efi.get_time(&eft, &cap);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_ERR "efitime: can't read time\n");\r\nreturn -EINVAL;\r\n}\r\nconvert_from_efi_time(&eft, tm);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int efi_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nefi_status_t status;\r\nefi_time_t eft;\r\nconvert_to_efi_time(tm, &eft);\r\nstatus = efi.set_time(&eft);\r\nreturn status == EFI_SUCCESS ? 0 : -EINVAL;\r\n}\r\nstatic int __init efi_rtc_probe(struct platform_device *dev)\r\n{\r\nstruct rtc_device *rtc;\r\nrtc = rtc_device_register("rtc-efi", &dev->dev, &efi_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\nplatform_set_drvdata(dev, rtc);\r\nreturn 0;\r\n}\r\nstatic int __exit efi_rtc_remove(struct platform_device *dev)\r\n{\r\nstruct rtc_device *rtc = platform_get_drvdata(dev);\r\nrtc_device_unregister(rtc);\r\nreturn 0;\r\n}\r\nstatic int __init efi_rtc_init(void)\r\n{\r\nreturn platform_driver_probe(&efi_rtc_driver, efi_rtc_probe);\r\n}\r\nstatic void __exit efi_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&efi_rtc_driver);\r\n}
