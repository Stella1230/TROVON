static int proc_viocd_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nfor (i = 0; i < viocd_numdev; i++) {\r\nseq_printf(m, "viocd device %d is iSeries resource %10.10s"\r\n"type %4.4s, model %3.3s\n",\r\ni, viocd_diskinfo[i].rsrcname,\r\nviocd_diskinfo[i].type,\r\nviocd_diskinfo[i].model);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_viocd_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_viocd_show, NULL);\r\n}\r\nstatic int viocd_blk_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct disk_info *di = bdev->bd_disk->private_data;\r\nint ret;\r\nmutex_lock(&viocd_mutex);\r\nret = cdrom_open(&di->viocd_info, bdev, mode);\r\nmutex_unlock(&viocd_mutex);\r\nreturn ret;\r\n}\r\nstatic int viocd_blk_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct disk_info *di = disk->private_data;\r\nmutex_lock(&viocd_mutex);\r\ncdrom_release(&di->viocd_info, mode);\r\nmutex_unlock(&viocd_mutex);\r\nreturn 0;\r\n}\r\nstatic int viocd_blk_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned cmd, unsigned long arg)\r\n{\r\nstruct disk_info *di = bdev->bd_disk->private_data;\r\nint ret;\r\nmutex_lock(&viocd_mutex);\r\nret = cdrom_ioctl(&di->viocd_info, bdev, mode, cmd, arg);\r\nmutex_unlock(&viocd_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int viocd_blk_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct disk_info *di = disk->private_data;\r\nreturn cdrom_check_events(&di->viocd_info, clearing);\r\n}\r\nstatic int viocd_open(struct cdrom_device_info *cdi, int purpose)\r\n{\r\nstruct disk_info *diskinfo = cdi->handle;\r\nint device_no = DEVICE_NR(diskinfo);\r\nHvLpEvent_Rc hvrc;\r\nstruct viocd_waitevent we;\r\ninit_completion(&we.com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_cdio | viocdopen,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)&we, VIOVERSION << 16, ((u64)device_no << 48),\r\n0, 0, 0);\r\nif (hvrc != 0) {\r\npr_warning("bad rc on HvCallEvent_signalLpEventFast %d\n",\r\n(int)hvrc);\r\nreturn -EIO;\r\n}\r\nwait_for_completion(&we.com);\r\nif (we.rc) {\r\nconst struct vio_error_entry *err =\r\nvio_lookup_rc(viocd_err_table, we.sub_result);\r\npr_warning("bad rc %d:0x%04X on open: %s\n",\r\nwe.rc, we.sub_result, err->msg);\r\nreturn -err->errno;\r\n}\r\nreturn 0;\r\n}\r\nstatic void viocd_release(struct cdrom_device_info *cdi)\r\n{\r\nint device_no = DEVICE_NR((struct disk_info *)cdi->handle);\r\nHvLpEvent_Rc hvrc;\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_cdio | viocdclose,\r\nHvLpEvent_AckInd_NoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp), 0,\r\nVIOVERSION << 16, ((u64)device_no << 48), 0, 0, 0);\r\nif (hvrc != 0)\r\npr_warning("bad rc on HvCallEvent_signalLpEventFast %d\n",\r\n(int)hvrc);\r\n}\r\nstatic int send_request(struct request *req)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nstruct disk_info *diskinfo = req->rq_disk->private_data;\r\nu64 len;\r\ndma_addr_t dmaaddr;\r\nint direction;\r\nu16 cmd;\r\nstruct scatterlist sg;\r\nBUG_ON(req->nr_phys_segments > 1);\r\nif (rq_data_dir(req) == READ) {\r\ndirection = DMA_FROM_DEVICE;\r\ncmd = viomajorsubtype_cdio | viocdread;\r\n} else {\r\ndirection = DMA_TO_DEVICE;\r\ncmd = viomajorsubtype_cdio | viocdwrite;\r\n}\r\nsg_init_table(&sg, 1);\r\nif (blk_rq_map_sg(req->q, req, &sg) == 0) {\r\npr_warning("error setting up scatter/gather list\n");\r\nreturn -1;\r\n}\r\nif (dma_map_sg(diskinfo->dev, &sg, 1, direction) == 0) {\r\npr_warning("error allocating sg tce\n");\r\nreturn -1;\r\n}\r\ndmaaddr = sg_dma_address(&sg);\r\nlen = sg_dma_len(&sg);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo, cmd,\r\nHvLpEvent_AckInd_DoAck,\r\nHvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)req, VIOVERSION << 16,\r\n((u64)DEVICE_NR(diskinfo) << 48) | dmaaddr,\r\n(u64)blk_rq_pos(req) * 512, len, 0);\r\nif (hvrc != HvLpEvent_Rc_Good) {\r\npr_warning("hv error on op %d\n", (int)hvrc);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_viocd_request(struct request_queue *q)\r\n{\r\nstruct request *req;\r\nwhile ((rwreq == 0) && ((req = blk_fetch_request(q)) != NULL)) {\r\nif (req->cmd_type != REQ_TYPE_FS)\r\n__blk_end_request_all(req, -EIO);\r\nelse if (send_request(req) < 0) {\r\npr_warning("unable to send message to OS/400!\n");\r\n__blk_end_request_all(req, -EIO);\r\n} else\r\nrwreq++;\r\n}\r\n}\r\nstatic unsigned int viocd_check_events(struct cdrom_device_info *cdi,\r\nunsigned int clearing, int disc_nr)\r\n{\r\nstruct viocd_waitevent we;\r\nHvLpEvent_Rc hvrc;\r\nint device_no = DEVICE_NR((struct disk_info *)cdi->handle);\r\ninit_completion(&we.com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_cdio | viocdcheck,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)&we, VIOVERSION << 16, ((u64)device_no << 48),\r\n0, 0, 0);\r\nif (hvrc != 0) {\r\npr_warning("bad rc on HvCallEvent_signalLpEventFast %d\n",\r\n(int)hvrc);\r\nreturn 0;\r\n}\r\nwait_for_completion(&we.com);\r\nif (we.rc) {\r\nconst struct vio_error_entry *err =\r\nvio_lookup_rc(viocd_err_table, we.sub_result);\r\npr_warning("bad rc %d:0x%04X on check_change: %s; Assuming no change\n",\r\nwe.rc, we.sub_result, err->msg);\r\nreturn 0;\r\n}\r\nreturn we.changed ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic int viocd_lock_door(struct cdrom_device_info *cdi, int locking)\r\n{\r\nHvLpEvent_Rc hvrc;\r\nu64 device_no = DEVICE_NR((struct disk_info *)cdi->handle);\r\nu64 flags = !!locking;\r\nstruct viocd_waitevent we;\r\ninit_completion(&we.com);\r\nhvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,\r\nHvLpEvent_Type_VirtualIo,\r\nviomajorsubtype_cdio | viocdlockdoor,\r\nHvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,\r\nviopath_sourceinst(viopath_hostLp),\r\nviopath_targetinst(viopath_hostLp),\r\n(u64)&we, VIOVERSION << 16,\r\n(device_no << 48) | (flags << 32), 0, 0, 0);\r\nif (hvrc != 0) {\r\npr_warning("bad rc on HvCallEvent_signalLpEventFast %d\n",\r\n(int)hvrc);\r\nreturn -EIO;\r\n}\r\nwait_for_completion(&we.com);\r\nif (we.rc != 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int viocd_packet(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc)\r\n{\r\nunsigned int buflen = cgc->buflen;\r\nint ret = -EIO;\r\nswitch (cgc->cmd[0]) {\r\ncase GPCMD_READ_DISC_INFO:\r\n{\r\ndisc_information *di = (disc_information *)cgc->buffer;\r\nif (buflen >= 2) {\r\ndi->disc_information_length = cpu_to_be16(1);\r\nret = 0;\r\n}\r\nif (buflen >= 3)\r\ndi->erasable =\r\n(cdi->ops->capability & ~cdi->mask\r\n& (CDC_DVD_RAM | CDC_RAM)) != 0;\r\n}\r\nbreak;\r\ncase GPCMD_GET_CONFIGURATION:\r\nif (cgc->cmd[3] == CDF_RWRT) {\r\nstruct rwrt_feature_desc *rfd = (struct rwrt_feature_desc *)(cgc->buffer + sizeof(struct feature_header));\r\nif ((buflen >=\r\n(sizeof(struct feature_header) + sizeof(*rfd))) &&\r\n(cdi->ops->capability & ~cdi->mask\r\n& (CDC_DVD_RAM | CDC_RAM))) {\r\nrfd->feature_code = cpu_to_be16(CDF_RWRT);\r\nrfd->curr = 1;\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nif (cgc->sense) {\r\ncgc->sense->sense_key = 0x05;\r\ncgc->sense->asc = 0x20;\r\ncgc->sense->ascq = 0x00;\r\n}\r\nbreak;\r\n}\r\ncgc->stat = ret;\r\nreturn ret;\r\n}\r\nstatic void restart_all_queues(int first_index)\r\n{\r\nint i;\r\nfor (i = first_index + 1; i < viocd_numdev; i++)\r\nif (viocd_diskinfo[i].viocd_disk)\r\nblk_run_queue(viocd_diskinfo[i].viocd_disk->queue);\r\nfor (i = 0; i <= first_index; i++)\r\nif (viocd_diskinfo[i].viocd_disk)\r\nblk_run_queue(viocd_diskinfo[i].viocd_disk->queue);\r\n}\r\nstatic void vio_handle_cd_event(struct HvLpEvent *event)\r\n{\r\nstruct viocdlpevent *bevent;\r\nstruct viocd_waitevent *pwe;\r\nstruct disk_info *di;\r\nunsigned long flags;\r\nstruct request *req;\r\nif (event == NULL)\r\nreturn;\r\nif (hvlpevent_is_int(event)) {\r\npr_warning("Yikes! got an int in viocd event handler!\n");\r\nif (hvlpevent_need_ack(event)) {\r\nevent->xRc = HvLpEvent_Rc_InvalidSubtype;\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\n}\r\nbevent = (struct viocdlpevent *)event;\r\nswitch (event->xSubtype & VIOMINOR_SUBTYPE_MASK) {\r\ncase viocdopen:\r\nif (event->xRc == 0) {\r\ndi = &viocd_diskinfo[bevent->disk];\r\nblk_queue_logical_block_size(di->viocd_disk->queue,\r\nbevent->block_size);\r\nset_capacity(di->viocd_disk,\r\nbevent->media_size *\r\nbevent->block_size / 512);\r\n}\r\ncase viocdlockdoor:\r\npwe = (struct viocd_waitevent *)event->xCorrelationToken;\r\nreturn_complete:\r\npwe->rc = event->xRc;\r\npwe->sub_result = bevent->sub_result;\r\ncomplete(&pwe->com);\r\nbreak;\r\ncase viocdcheck:\r\npwe = (struct viocd_waitevent *)event->xCorrelationToken;\r\npwe->changed = bevent->flags;\r\ngoto return_complete;\r\ncase viocdclose:\r\nbreak;\r\ncase viocdwrite:\r\ncase viocdread:\r\ndi = &viocd_diskinfo[bevent->disk];\r\nspin_lock_irqsave(&viocd_reqlock, flags);\r\ndma_unmap_single(di->dev, bevent->token, bevent->len,\r\n((event->xSubtype & VIOMINOR_SUBTYPE_MASK) == viocdread)\r\n? DMA_FROM_DEVICE : DMA_TO_DEVICE);\r\nreq = (struct request *)bevent->event.xCorrelationToken;\r\nrwreq--;\r\nif (event->xRc != HvLpEvent_Rc_Good) {\r\nconst struct vio_error_entry *err =\r\nvio_lookup_rc(viocd_err_table,\r\nbevent->sub_result);\r\npr_warning("request %p failed with rc %d:0x%04X: %s\n",\r\nreq, event->xRc,\r\nbevent->sub_result, err->msg);\r\n__blk_end_request_all(req, -EIO);\r\n} else\r\n__blk_end_request_all(req, 0);\r\nspin_unlock_irqrestore(&viocd_reqlock, flags);\r\nrestart_all_queues(bevent->disk);\r\nbreak;\r\ndefault:\r\npr_warning("message with invalid subtype %0x04X!\n",\r\nevent->xSubtype & VIOMINOR_SUBTYPE_MASK);\r\nif (hvlpevent_need_ack(event)) {\r\nevent->xRc = HvLpEvent_Rc_InvalidSubtype;\r\nHvCallEvent_ackLpEvent(event);\r\n}\r\n}\r\n}\r\nstatic int viocd_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,\r\nvoid *arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int find_capability(const char *type)\r\n{\r\nstruct capability_entry *entry;\r\nfor(entry = capability_table; entry->type; ++entry)\r\nif(!strncmp(entry->type, type, 4))\r\nbreak;\r\nreturn entry->capability;\r\n}\r\nstatic int viocd_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nstruct gendisk *gendisk;\r\nint deviceno;\r\nstruct disk_info *d;\r\nstruct cdrom_device_info *c;\r\nstruct request_queue *q;\r\nstruct device_node *node = vdev->dev.of_node;\r\ndeviceno = vdev->unit_address;\r\nif (deviceno >= VIOCD_MAX_CD)\r\nreturn -ENODEV;\r\nif (!node)\r\nreturn -ENODEV;\r\nif (deviceno >= viocd_numdev)\r\nviocd_numdev = deviceno + 1;\r\nd = &viocd_diskinfo[deviceno];\r\nd->rsrcname = of_get_property(node, "linux,vio_rsrcname", NULL);\r\nd->type = of_get_property(node, "linux,vio_type", NULL);\r\nd->model = of_get_property(node, "linux,vio_model", NULL);\r\nc = &d->viocd_info;\r\nc->ops = &viocd_dops;\r\nc->speed = 4;\r\nc->capacity = 1;\r\nc->handle = d;\r\nc->mask = ~find_capability(d->type);\r\nsprintf(c->name, VIOCD_DEVICE "%c", 'a' + deviceno);\r\nif (register_cdrom(c) != 0) {\r\npr_warning("Cannot register viocd CD-ROM %s!\n", c->name);\r\ngoto out;\r\n}\r\npr_info("cd %s is iSeries resource %10.10s type %4.4s, model %3.3s\n",\r\nc->name, d->rsrcname, d->type, d->model);\r\nq = blk_init_queue(do_viocd_request, &viocd_reqlock);\r\nif (q == NULL) {\r\npr_warning("Cannot allocate queue for %s!\n", c->name);\r\ngoto out_unregister_cdrom;\r\n}\r\ngendisk = alloc_disk(1);\r\nif (gendisk == NULL) {\r\npr_warning("Cannot create gendisk for %s!\n", c->name);\r\ngoto out_cleanup_queue;\r\n}\r\ngendisk->major = VIOCD_MAJOR;\r\ngendisk->first_minor = deviceno;\r\nstrncpy(gendisk->disk_name, c->name,\r\nsizeof(gendisk->disk_name));\r\nblk_queue_max_segments(q, 1);\r\nblk_queue_max_hw_sectors(q, 4096 / 512);\r\ngendisk->queue = q;\r\ngendisk->fops = &viocd_fops;\r\ngendisk->flags = GENHD_FL_CD | GENHD_FL_REMOVABLE |\r\nGENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\r\nset_capacity(gendisk, 0);\r\ngendisk->private_data = d;\r\nd->viocd_disk = gendisk;\r\nd->dev = &vdev->dev;\r\ngendisk->driverfs_dev = d->dev;\r\nadd_disk(gendisk);\r\nreturn 0;\r\nout_cleanup_queue:\r\nblk_cleanup_queue(q);\r\nout_unregister_cdrom:\r\nunregister_cdrom(c);\r\nout:\r\nreturn -ENODEV;\r\n}\r\nstatic int viocd_remove(struct vio_dev *vdev)\r\n{\r\nstruct disk_info *d = &viocd_diskinfo[vdev->unit_address];\r\nunregister_cdrom(&d->viocd_info);\r\ndel_gendisk(d->viocd_disk);\r\nblk_cleanup_queue(d->viocd_disk->queue);\r\nput_disk(d->viocd_disk);\r\nreturn 0;\r\n}\r\nstatic int __init viocd_init(void)\r\n{\r\nint ret = 0;\r\nif (!firmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn -ENODEV;\r\nif (viopath_hostLp == HvLpIndexInvalid) {\r\nvio_set_hostlp();\r\nif (viopath_hostLp == HvLpIndexInvalid)\r\nreturn -ENODEV;\r\n}\r\npr_info("vers " VIOCD_VERS ", hosting partition %d\n", viopath_hostLp);\r\nif (register_blkdev(VIOCD_MAJOR, VIOCD_DEVICE) != 0) {\r\npr_warning("Unable to get major %d for %s\n",\r\nVIOCD_MAJOR, VIOCD_DEVICE);\r\nreturn -EIO;\r\n}\r\nret = viopath_open(viopath_hostLp, viomajorsubtype_cdio,\r\nMAX_CD_REQ + 2);\r\nif (ret) {\r\npr_warning("error opening path to host partition %d\n",\r\nviopath_hostLp);\r\ngoto out_unregister;\r\n}\r\nvio_setHandler(viomajorsubtype_cdio, vio_handle_cd_event);\r\nspin_lock_init(&viocd_reqlock);\r\nret = vio_register_driver(&viocd_driver);\r\nif (ret)\r\ngoto out_free_info;\r\nproc_create("iSeries/viocd", S_IFREG|S_IRUGO, NULL,\r\n&proc_viocd_operations);\r\nreturn 0;\r\nout_free_info:\r\nvio_clearHandler(viomajorsubtype_cdio);\r\nviopath_close(viopath_hostLp, viomajorsubtype_cdio, MAX_CD_REQ + 2);\r\nout_unregister:\r\nunregister_blkdev(VIOCD_MAJOR, VIOCD_DEVICE);\r\nreturn ret;\r\n}\r\nstatic void __exit viocd_exit(void)\r\n{\r\nremove_proc_entry("iSeries/viocd", NULL);\r\nvio_unregister_driver(&viocd_driver);\r\nviopath_close(viopath_hostLp, viomajorsubtype_cdio, MAX_CD_REQ + 2);\r\nvio_clearHandler(viomajorsubtype_cdio);\r\nunregister_blkdev(VIOCD_MAJOR, VIOCD_DEVICE);\r\n}
