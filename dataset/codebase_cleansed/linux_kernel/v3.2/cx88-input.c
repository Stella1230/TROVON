static void cx88_ir_handle_key(struct cx88_IR *ir)\r\n{\r\nstruct cx88_core *core = ir->core;\r\nu32 gpio, data, auxgpio;\r\ngpio = cx_read(ir->gpio_addr);\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_NPGTECH_REALTV_TOP10FM:\r\nauxgpio = cx_read(MO_GP1_IO);\r\ngpio=(gpio & 0x7fd) + (auxgpio & 0xef);\r\nbreak;\r\ncase CX88_BOARD_WINFAST_DTV1000:\r\ncase CX88_BOARD_WINFAST_DTV1800H:\r\ncase CX88_BOARD_WINFAST_DTV1800H_XC4000:\r\ncase CX88_BOARD_WINFAST_DTV2000H_PLUS:\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL:\r\ngpio = (gpio & 0x6ff) | ((cx_read(MO_GP1_IO) << 8) & 0x900);\r\nauxgpio = gpio;\r\nbreak;\r\ndefault:\r\nauxgpio = gpio;\r\n}\r\nif (ir->polling) {\r\nif (ir->last_gpio == auxgpio)\r\nreturn;\r\nir->last_gpio = auxgpio;\r\n}\r\ndata = ir_extract_bits(gpio, ir->mask_keycode);\r\nir_dprintk("irq gpio=0x%x code=%d | %s%s%s\n",\r\ngpio, data,\r\nir->polling ? "poll" : "irq",\r\n(gpio & ir->mask_keydown) ? " down" : "",\r\n(gpio & ir->mask_keyup) ? " up" : "");\r\nif (ir->core->boardnr == CX88_BOARD_NORWOOD_MICRO) {\r\nu32 gpio_key = cx_read(MO_GP0_IO);\r\ndata = (data << 4) | ((gpio_key & 0xf0) >> 4);\r\nrc_keydown(ir->dev, data, 0);\r\n} else if (ir->mask_keydown) {\r\nif (gpio & ir->mask_keydown)\r\nrc_keydown_notimeout(ir->dev, data, 0);\r\nelse\r\nrc_keyup(ir->dev);\r\n} else if (ir->mask_keyup) {\r\nif (0 == (gpio & ir->mask_keyup))\r\nrc_keydown_notimeout(ir->dev, data, 0);\r\nelse\r\nrc_keyup(ir->dev);\r\n} else {\r\nrc_keydown_notimeout(ir->dev, data, 0);\r\nrc_keyup(ir->dev);\r\n}\r\n}\r\nstatic enum hrtimer_restart cx88_ir_work(struct hrtimer *timer)\r\n{\r\nunsigned long missed;\r\nstruct cx88_IR *ir = container_of(timer, struct cx88_IR, timer);\r\ncx88_ir_handle_key(ir);\r\nmissed = hrtimer_forward_now(&ir->timer,\r\nktime_set(0, ir->polling * 1000000));\r\nif (missed > 1)\r\nir_dprintk("Missed ticks %ld\n", missed - 1);\r\nreturn HRTIMER_RESTART;\r\n}\r\nstatic int __cx88_ir_start(void *priv)\r\n{\r\nstruct cx88_core *core = priv;\r\nstruct cx88_IR *ir;\r\nif (!core || !core->ir)\r\nreturn -EINVAL;\r\nir = core->ir;\r\nif (ir->polling) {\r\nhrtimer_init(&ir->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nir->timer.function = cx88_ir_work;\r\nhrtimer_start(&ir->timer,\r\nktime_set(0, ir->polling * 1000000),\r\nHRTIMER_MODE_REL);\r\n}\r\nif (ir->sampling) {\r\ncore->pci_irqmask |= PCI_INT_IR_SMPINT;\r\ncx_write(MO_DDS_IO, 0x33F286 * ir_samplerate);\r\ncx_write(MO_DDSCFG_IO, 0x5);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __cx88_ir_stop(void *priv)\r\n{\r\nstruct cx88_core *core = priv;\r\nstruct cx88_IR *ir;\r\nif (!core || !core->ir)\r\nreturn;\r\nir = core->ir;\r\nif (ir->sampling) {\r\ncx_write(MO_DDSCFG_IO, 0x0);\r\ncore->pci_irqmask &= ~PCI_INT_IR_SMPINT;\r\n}\r\nif (ir->polling)\r\nhrtimer_cancel(&ir->timer);\r\n}\r\nint cx88_ir_start(struct cx88_core *core)\r\n{\r\nif (core->ir->users)\r\nreturn __cx88_ir_start(core);\r\nreturn 0;\r\n}\r\nvoid cx88_ir_stop(struct cx88_core *core)\r\n{\r\nif (core->ir->users)\r\n__cx88_ir_stop(core);\r\n}\r\nstatic int cx88_ir_open(struct rc_dev *rc)\r\n{\r\nstruct cx88_core *core = rc->priv;\r\ncore->ir->users++;\r\nreturn __cx88_ir_start(core);\r\n}\r\nstatic void cx88_ir_close(struct rc_dev *rc)\r\n{\r\nstruct cx88_core *core = rc->priv;\r\ncore->ir->users--;\r\nif (!core->ir->users)\r\n__cx88_ir_stop(core);\r\n}\r\nint cx88_ir_init(struct cx88_core *core, struct pci_dev *pci)\r\n{\r\nstruct cx88_IR *ir;\r\nstruct rc_dev *dev;\r\nchar *ir_codes = NULL;\r\nu64 rc_type = RC_TYPE_OTHER;\r\nint err = -ENOMEM;\r\nu32 hardware_mask = 0;\r\nir = kzalloc(sizeof(*ir), GFP_KERNEL);\r\ndev = rc_allocate_device();\r\nif (!ir || !dev)\r\ngoto err_out_free;\r\nir->dev = dev;\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_DNTV_LIVE_DVB_T:\r\ncase CX88_BOARD_KWORLD_DVB_T:\r\ncase CX88_BOARD_KWORLD_DVB_T_CX22702:\r\nir_codes = RC_MAP_DNTV_LIVE_DVB_T;\r\nir->gpio_addr = MO_GP1_IO;\r\nir->mask_keycode = 0x1f;\r\nir->mask_keyup = 0x60;\r\nir->polling = 50;\r\nbreak;\r\ncase CX88_BOARD_TERRATEC_CINERGY_1400_DVB_T1:\r\nir_codes = RC_MAP_CINERGY_1400;\r\nir->sampling = 0xeb04;\r\nbreak;\r\ncase CX88_BOARD_HAUPPAUGE:\r\ncase CX88_BOARD_HAUPPAUGE_DVB_T1:\r\ncase CX88_BOARD_HAUPPAUGE_NOVASE2_S1:\r\ncase CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:\r\ncase CX88_BOARD_HAUPPAUGE_HVR1100:\r\ncase CX88_BOARD_HAUPPAUGE_HVR3000:\r\ncase CX88_BOARD_HAUPPAUGE_HVR4000:\r\ncase CX88_BOARD_HAUPPAUGE_HVR4000LITE:\r\ncase CX88_BOARD_PCHDTV_HD3000:\r\ncase CX88_BOARD_PCHDTV_HD5500:\r\ncase CX88_BOARD_HAUPPAUGE_IRONLY:\r\nir_codes = RC_MAP_HAUPPAUGE;\r\nir->sampling = 1;\r\nbreak;\r\ncase CX88_BOARD_WINFAST_DTV2000H:\r\ncase CX88_BOARD_WINFAST_DTV2000H_J:\r\ncase CX88_BOARD_WINFAST_DTV1800H:\r\ncase CX88_BOARD_WINFAST_DTV1800H_XC4000:\r\ncase CX88_BOARD_WINFAST_DTV2000H_PLUS:\r\nir_codes = RC_MAP_WINFAST;\r\nir->gpio_addr = MO_GP0_IO;\r\nir->mask_keycode = 0x8f8;\r\nir->mask_keyup = 0x100;\r\nir->polling = 50;\r\nbreak;\r\ncase CX88_BOARD_WINFAST2000XP_EXPERT:\r\ncase CX88_BOARD_WINFAST_DTV1000:\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL:\r\nir_codes = RC_MAP_WINFAST;\r\nir->gpio_addr = MO_GP0_IO;\r\nir->mask_keycode = 0x8f8;\r\nir->mask_keyup = 0x100;\r\nir->polling = 1;\r\nbreak;\r\ncase CX88_BOARD_IODATA_GVBCTV7E:\r\nir_codes = RC_MAP_IODATA_BCTV7E;\r\nir->gpio_addr = MO_GP0_IO;\r\nir->mask_keycode = 0xfd;\r\nir->mask_keydown = 0x02;\r\nir->polling = 5;\r\nbreak;\r\ncase CX88_BOARD_PROLINK_PLAYTVPVR:\r\ncase CX88_BOARD_PIXELVIEW_PLAYTV_ULTRA_PRO:\r\nir_codes = RC_MAP_PIXELVIEW_MK12;\r\nir->gpio_addr = MO_GP1_IO;\r\nir->mask_keyup = 0x80;\r\nir->polling = 10;\r\nhardware_mask = 0x3f;\r\nbreak;\r\ncase CX88_BOARD_PROLINK_PV_8000GT:\r\ncase CX88_BOARD_PROLINK_PV_GLOBAL_XTREME:\r\nir_codes = RC_MAP_PIXELVIEW_NEW;\r\nir->gpio_addr = MO_GP1_IO;\r\nir->mask_keycode = 0x3f;\r\nir->mask_keyup = 0x80;\r\nir->polling = 1;\r\nbreak;\r\ncase CX88_BOARD_KWORLD_LTV883:\r\nir_codes = RC_MAP_PIXELVIEW;\r\nir->gpio_addr = MO_GP1_IO;\r\nir->mask_keycode = 0x1f;\r\nir->mask_keyup = 0x60;\r\nir->polling = 1;\r\nbreak;\r\ncase CX88_BOARD_ADSTECH_DVB_T_PCI:\r\nir_codes = RC_MAP_ADSTECH_DVB_T_PCI;\r\nir->gpio_addr = MO_GP1_IO;\r\nir->mask_keycode = 0xbf;\r\nir->mask_keyup = 0x40;\r\nir->polling = 50;\r\nbreak;\r\ncase CX88_BOARD_MSI_TVANYWHERE_MASTER:\r\nir_codes = RC_MAP_MSI_TVANYWHERE;\r\nir->gpio_addr = MO_GP1_IO;\r\nir->mask_keycode = 0x1f;\r\nir->mask_keyup = 0x40;\r\nir->polling = 1;\r\nbreak;\r\ncase CX88_BOARD_AVERTV_303:\r\ncase CX88_BOARD_AVERTV_STUDIO_303:\r\nir_codes = RC_MAP_AVERTV_303;\r\nir->gpio_addr = MO_GP2_IO;\r\nir->mask_keycode = 0xfb;\r\nir->mask_keydown = 0x02;\r\nir->polling = 50;\r\nbreak;\r\ncase CX88_BOARD_OMICOM_SS4_PCI:\r\ncase CX88_BOARD_SATTRADE_ST4200:\r\ncase CX88_BOARD_TBS_8920:\r\ncase CX88_BOARD_TBS_8910:\r\ncase CX88_BOARD_PROF_7300:\r\ncase CX88_BOARD_PROF_7301:\r\ncase CX88_BOARD_PROF_6200:\r\nir_codes = RC_MAP_TBS_NEC;\r\nir->sampling = 0xff00;\r\nbreak;\r\ncase CX88_BOARD_TEVII_S464:\r\ncase CX88_BOARD_TEVII_S460:\r\ncase CX88_BOARD_TEVII_S420:\r\nir_codes = RC_MAP_TEVII_NEC;\r\nir->sampling = 0xff00;\r\nbreak;\r\ncase CX88_BOARD_DNTV_LIVE_DVB_T_PRO:\r\nir_codes = RC_MAP_DNTV_LIVE_DVBT_PRO;\r\nir->sampling = 0xff00;\r\nbreak;\r\ncase CX88_BOARD_NORWOOD_MICRO:\r\nir_codes = RC_MAP_NORWOOD;\r\nir->gpio_addr = MO_GP1_IO;\r\nir->mask_keycode = 0x0e;\r\nir->mask_keyup = 0x80;\r\nir->polling = 50;\r\nbreak;\r\ncase CX88_BOARD_NPGTECH_REALTV_TOP10FM:\r\nir_codes = RC_MAP_NPGTECH;\r\nir->gpio_addr = MO_GP0_IO;\r\nir->mask_keycode = 0xfa;\r\nir->polling = 50;\r\nbreak;\r\ncase CX88_BOARD_PINNACLE_PCTV_HD_800i:\r\nir_codes = RC_MAP_PINNACLE_PCTV_HD;\r\nir->sampling = 1;\r\nbreak;\r\ncase CX88_BOARD_POWERCOLOR_REAL_ANGEL:\r\nir_codes = RC_MAP_POWERCOLOR_REAL_ANGEL;\r\nir->gpio_addr = MO_GP2_IO;\r\nir->mask_keycode = 0x7e;\r\nir->polling = 100;\r\nbreak;\r\ncase CX88_BOARD_TWINHAN_VP1027_DVBS:\r\nir_codes = RC_MAP_TWINHAN_VP1027_DVBS;\r\nrc_type = RC_TYPE_NEC;\r\nir->sampling = 0xff00;\r\nbreak;\r\n}\r\nif (!ir_codes) {\r\nerr = -ENODEV;\r\ngoto err_out_free;\r\n}\r\nif (hardware_mask && !ir->mask_keycode)\r\nir->mask_keycode = hardware_mask;\r\nsnprintf(ir->name, sizeof(ir->name), "cx88 IR (%s)", core->board.name);\r\nsnprintf(ir->phys, sizeof(ir->phys), "pci-%s/ir0", pci_name(pci));\r\ndev->input_name = ir->name;\r\ndev->input_phys = ir->phys;\r\ndev->input_id.bustype = BUS_PCI;\r\ndev->input_id.version = 1;\r\nif (pci->subsystem_vendor) {\r\ndev->input_id.vendor = pci->subsystem_vendor;\r\ndev->input_id.product = pci->subsystem_device;\r\n} else {\r\ndev->input_id.vendor = pci->vendor;\r\ndev->input_id.product = pci->device;\r\n}\r\ndev->dev.parent = &pci->dev;\r\ndev->map_name = ir_codes;\r\ndev->driver_name = MODULE_NAME;\r\ndev->priv = core;\r\ndev->open = cx88_ir_open;\r\ndev->close = cx88_ir_close;\r\ndev->scanmask = hardware_mask;\r\nif (ir->sampling) {\r\ndev->driver_type = RC_DRIVER_IR_RAW;\r\ndev->timeout = 10 * 1000 * 1000;\r\n} else {\r\ndev->driver_type = RC_DRIVER_SCANCODE;\r\ndev->allowed_protos = rc_type;\r\n}\r\nir->core = core;\r\ncore->ir = ir;\r\nerr = rc_register_device(dev);\r\nif (err)\r\ngoto err_out_free;\r\nreturn 0;\r\nerr_out_free:\r\nrc_free_device(dev);\r\ncore->ir = NULL;\r\nkfree(ir);\r\nreturn err;\r\n}\r\nint cx88_ir_fini(struct cx88_core *core)\r\n{\r\nstruct cx88_IR *ir = core->ir;\r\nif (NULL == ir)\r\nreturn 0;\r\ncx88_ir_stop(core);\r\nrc_unregister_device(ir->dev);\r\nkfree(ir);\r\ncore->ir = NULL;\r\nreturn 0;\r\n}\r\nvoid cx88_ir_irq(struct cx88_core *core)\r\n{\r\nstruct cx88_IR *ir = core->ir;\r\nu32 samples;\r\nunsigned todo, bits;\r\nstruct ir_raw_event ev;\r\nif (!ir || !ir->sampling)\r\nreturn;\r\nsamples = cx_read(MO_SAMPLE_IO);\r\nif (samples == 0xff && ir->dev->idle)\r\nreturn;\r\ninit_ir_raw_event(&ev);\r\nfor (todo = 32; todo > 0; todo -= bits) {\r\nev.pulse = samples & 0x80000000 ? false : true;\r\nbits = min(todo, 32U - fls(ev.pulse ? samples : ~samples));\r\nev.duration = (bits * (NSEC_PER_SEC / 1000)) / ir_samplerate;\r\nir_raw_event_store_with_filter(ir->dev, &ev);\r\nsamples <<= bits;\r\n}\r\nir_raw_event_handle(ir->dev);\r\n}\r\nstatic int get_key_pvr2000(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)\r\n{\r\nint flags, code;\r\nflags = i2c_smbus_read_byte_data(ir->c, 0x10);\r\nif (flags < 0) {\r\ndprintk("read error\n");\r\nreturn 0;\r\n}\r\nif (0 == (flags & 0x80))\r\nreturn 0;\r\ncode = i2c_smbus_read_byte_data(ir->c, 0x00);\r\nif (code < 0) {\r\ndprintk("read error\n");\r\nreturn 0;\r\n}\r\ndprintk("IR Key/Flags: (0x%02x/0x%02x)\n",\r\ncode & 0xff, flags & 0xff);\r\n*ir_key = code & 0xff;\r\n*ir_raw = code;\r\nreturn 1;\r\n}\r\nvoid cx88_i2c_init_ir(struct cx88_core *core)\r\n{\r\nstruct i2c_board_info info;\r\nconst unsigned short default_addr_list[] = {\r\n0x18, 0x6b, 0x71,\r\nI2C_CLIENT_END\r\n};\r\nconst unsigned short pvr2000_addr_list[] = {\r\n0x18, 0x1a,\r\nI2C_CLIENT_END\r\n};\r\nconst unsigned short *addr_list = default_addr_list;\r\nconst unsigned short *addrp;\r\nif (0 != core->i2c_rc)\r\nreturn;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "ir_video", I2C_NAME_SIZE);\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_LEADTEK_PVR2000:\r\naddr_list = pvr2000_addr_list;\r\ncore->init_data.name = "cx88 Leadtek PVR 2000 remote";\r\ncore->init_data.type = RC_TYPE_UNKNOWN;\r\ncore->init_data.get_key = get_key_pvr2000;\r\ncore->init_data.ir_codes = RC_MAP_EMPTY;\r\nbreak;\r\n}\r\nfor (addrp = addr_list; *addrp != I2C_CLIENT_END; addrp++) {\r\ninfo.platform_data = NULL;\r\nmemset(&core->init_data, 0, sizeof(core->init_data));\r\nif (*addrp == 0x71) {\r\ncore->init_data.name = "cx88 Hauppauge XVR remote";\r\ncore->init_data.ir_codes = RC_MAP_HAUPPAUGE;\r\ncore->init_data.type = RC_TYPE_RC5;\r\ncore->init_data.internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\r\ninfo.platform_data = &core->init_data;\r\n}\r\nif (i2c_smbus_xfer(&core->i2c_adap, *addrp, 0,\r\nI2C_SMBUS_READ, 0,\r\nI2C_SMBUS_QUICK, NULL) >= 0) {\r\ninfo.addr = *addrp;\r\ni2c_new_device(&core->i2c_adap, &info);\r\nbreak;\r\n}\r\n}\r\n}
