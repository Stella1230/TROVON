int sst_get_block_stream(struct intel_sst_drv *sst_drv_ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_ACTIVE_STREAM; i++) {\r\nif (sst_drv_ctx->alloc_block[i].sst_id == BLOCK_UNINIT) {\r\nsst_drv_ctx->alloc_block[i].ops_block.condition = false;\r\nsst_drv_ctx->alloc_block[i].ops_block.ret_code = 0;\r\nsst_drv_ctx->alloc_block[i].sst_id = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == MAX_ACTIVE_STREAM) {\r\npr_err("max alloc_stream reached\n");\r\ni = -EBUSY;\r\n}\r\nreturn i;\r\n}\r\nint sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,\r\nstruct sst_block *block)\r\n{\r\nint retval = 0;\r\nif (!wait_event_interruptible(sst_drv_ctx->wait_queue,\r\nblock->condition)) {\r\nif (block->ret_code < 0) {\r\npr_err("stream failed %d\n", block->ret_code);\r\nretval = -EBUSY;\r\n} else {\r\npr_debug("event up\n");\r\nretval = 0;\r\n}\r\n} else {\r\npr_err("signal interrupted\n");\r\nretval = -EINTR;\r\n}\r\nreturn retval;\r\n}\r\nint sst_wait_interruptible_timeout(\r\nstruct intel_sst_drv *sst_drv_ctx,\r\nstruct sst_block *block, int timeout)\r\n{\r\nint retval = 0;\r\npr_debug("sst_wait_interruptible_timeout - waiting....\n");\r\nif (wait_event_interruptible_timeout(sst_drv_ctx->wait_queue,\r\nblock->condition,\r\nmsecs_to_jiffies(timeout))) {\r\nif (block->ret_code < 0)\r\npr_err("stream failed %d\n", block->ret_code);\r\nelse\r\npr_debug("event up\n");\r\nretval = block->ret_code;\r\n} else {\r\nblock->on = false;\r\npr_err("timeout occurred...\n");\r\nretval = -EBUSY;\r\n}\r\nreturn retval;\r\n}\r\nint sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx,\r\nstruct stream_alloc_block *block)\r\n{\r\nint retval = 0;\r\npr_debug("waiting for %x, condition %x\n",\r\nblock->sst_id, block->ops_block.condition);\r\nif (wait_event_interruptible_timeout(sst_drv_ctx->wait_queue,\r\nblock->ops_block.condition,\r\nmsecs_to_jiffies(SST_BLOCK_TIMEOUT))) {\r\npr_debug("Event wake %x\n", block->ops_block.condition);\r\npr_debug("message ret: %d\n", block->ops_block.ret_code);\r\nretval = block->ops_block.ret_code;\r\n} else {\r\nblock->ops_block.on = false;\r\npr_err("Wait timed-out %x\n", block->ops_block.condition);\r\nretval = -EBUSY;\r\n}\r\nreturn retval;\r\n}\r\nint sst_create_large_msg(struct ipc_post **arg)\r\n{\r\nstruct ipc_post *msg;\r\nmsg = kzalloc(sizeof(struct ipc_post), GFP_ATOMIC);\r\nif (!msg) {\r\npr_err("kzalloc msg failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmsg->mailbox_data = kzalloc(SST_MAILBOX_SIZE, GFP_ATOMIC);\r\nif (!msg->mailbox_data) {\r\nkfree(msg);\r\npr_err("kzalloc mailbox_data failed");\r\nreturn -ENOMEM;\r\n}\r\n*arg = msg;\r\nreturn 0;\r\n}\r\nint sst_create_short_msg(struct ipc_post **arg)\r\n{\r\nstruct ipc_post *msg;\r\nmsg = kzalloc(sizeof(*msg), GFP_ATOMIC);\r\nif (!msg) {\r\npr_err("kzalloc msg failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmsg->mailbox_data = NULL;\r\n*arg = msg;\r\nreturn 0;\r\n}\r\nvoid sst_clean_stream(struct stream_info *stream)\r\n{\r\nstruct sst_stream_bufs *bufs = NULL, *_bufs;\r\nstream->status = STREAM_UN_INIT;\r\nstream->prev = STREAM_UN_INIT;\r\nmutex_lock(&stream->lock);\r\nlist_for_each_entry_safe(bufs, _bufs, &stream->bufs, node) {\r\nlist_del(&bufs->node);\r\nkfree(bufs);\r\n}\r\nmutex_unlock(&stream->lock);\r\nif (stream->ops != STREAM_OPS_PLAYBACK_DRM)\r\nkfree(stream->decode_ibuf);\r\n}\r\nvoid sst_wake_up_alloc_block(struct intel_sst_drv *sst_drv_ctx,\r\nu8 sst_id, int status, void *data)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_ACTIVE_STREAM; i++) {\r\nif (sst_id == sst_drv_ctx->alloc_block[i].sst_id) {\r\nsst_drv_ctx->alloc_block[i].ops_block.condition = true;\r\nsst_drv_ctx->alloc_block[i].ops_block.ret_code = status;\r\nsst_drv_ctx->alloc_block[i].ops_block.data = data;\r\nwake_up(&sst_drv_ctx->wait_queue);\r\nbreak;\r\n}\r\n}\r\n}\r\nint sst_enable_rx_timeslot(int status)\r\n{\r\nint retval = 0;\r\nstruct ipc_post *msg = NULL;\r\nif (sst_create_short_msg(&msg)) {\r\npr_err("mem allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\npr_debug("ipc message sending: ENABLE_RX_TIME_SLOT\n");\r\nsst_fill_header(&msg->header, IPC_IA_ENABLE_RX_TIME_SLOT, 0, 0);\r\nmsg->header.part.data = status;\r\nsst_drv_ctx->hs_info_blk.condition = false;\r\nsst_drv_ctx->hs_info_blk.ret_code = 0;\r\nsst_drv_ctx->hs_info_blk.on = true;\r\nspin_lock(&sst_drv_ctx->list_spin_lock);\r\nlist_add_tail(&msg->node,\r\n&sst_drv_ctx->ipc_dispatch_list);\r\nspin_unlock(&sst_drv_ctx->list_spin_lock);\r\nsst_post_message(&sst_drv_ctx->ipc_post_msg_wq);\r\nretval = sst_wait_interruptible_timeout(sst_drv_ctx,\r\n&sst_drv_ctx->hs_info_blk, SST_BLOCK_TIMEOUT);\r\nreturn retval;\r\n}
