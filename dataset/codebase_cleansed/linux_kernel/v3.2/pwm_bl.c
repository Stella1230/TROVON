static int pwm_backlight_update_status(struct backlight_device *bl)\r\n{\r\nstruct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);\r\nint brightness = bl->props.brightness;\r\nint max = bl->props.max_brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bl->props.fb_blank != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (pb->notify)\r\nbrightness = pb->notify(pb->dev, brightness);\r\nif (brightness == 0) {\r\npwm_config(pb->pwm, 0, pb->period);\r\npwm_disable(pb->pwm);\r\n} else {\r\nbrightness = pb->lth_brightness +\r\n(brightness * (pb->period - pb->lth_brightness) / max);\r\npwm_config(pb->pwm, brightness, pb->period);\r\npwm_enable(pb->pwm);\r\n}\r\nif (pb->notify_after)\r\npb->notify_after(pb->dev, brightness);\r\nreturn 0;\r\n}\r\nstatic int pwm_backlight_get_brightness(struct backlight_device *bl)\r\n{\r\nreturn bl->props.brightness;\r\n}\r\nstatic int pwm_backlight_check_fb(struct backlight_device *bl,\r\nstruct fb_info *info)\r\n{\r\nstruct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);\r\nreturn !pb->check_fb || pb->check_fb(pb->dev, info);\r\n}\r\nstatic int pwm_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct backlight_properties props;\r\nstruct platform_pwm_backlight_data *data = pdev->dev.platform_data;\r\nstruct backlight_device *bl;\r\nstruct pwm_bl_data *pb;\r\nint ret;\r\nif (!data) {\r\ndev_err(&pdev->dev, "failed to find platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (data->init) {\r\nret = data->init(&pdev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npb = kzalloc(sizeof(*pb), GFP_KERNEL);\r\nif (!pb) {\r\ndev_err(&pdev->dev, "no memory for state\n");\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\npb->period = data->pwm_period_ns;\r\npb->notify = data->notify;\r\npb->notify_after = data->notify_after;\r\npb->check_fb = data->check_fb;\r\npb->lth_brightness = data->lth_brightness *\r\n(data->pwm_period_ns / data->max_brightness);\r\npb->dev = &pdev->dev;\r\npb->pwm = pwm_request(data->pwm_id, "backlight");\r\nif (IS_ERR(pb->pwm)) {\r\ndev_err(&pdev->dev, "unable to request PWM for backlight\n");\r\nret = PTR_ERR(pb->pwm);\r\ngoto err_pwm;\r\n} else\r\ndev_dbg(&pdev->dev, "got pwm for backlight\n");\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = data->max_brightness;\r\nbl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, pb,\r\n&pwm_backlight_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&pdev->dev, "failed to register backlight\n");\r\nret = PTR_ERR(bl);\r\ngoto err_bl;\r\n}\r\nbl->props.brightness = data->dft_brightness;\r\nbacklight_update_status(bl);\r\nplatform_set_drvdata(pdev, bl);\r\nreturn 0;\r\nerr_bl:\r\npwm_free(pb->pwm);\r\nerr_pwm:\r\nkfree(pb);\r\nerr_alloc:\r\nif (data->exit)\r\ndata->exit(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int pwm_backlight_remove(struct platform_device *pdev)\r\n{\r\nstruct platform_pwm_backlight_data *data = pdev->dev.platform_data;\r\nstruct backlight_device *bl = platform_get_drvdata(pdev);\r\nstruct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);\r\nbacklight_device_unregister(bl);\r\npwm_config(pb->pwm, 0, pb->period);\r\npwm_disable(pb->pwm);\r\npwm_free(pb->pwm);\r\nkfree(pb);\r\nif (data->exit)\r\ndata->exit(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int pwm_backlight_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct backlight_device *bl = platform_get_drvdata(pdev);\r\nstruct pwm_bl_data *pb = dev_get_drvdata(&bl->dev);\r\nif (pb->notify)\r\npb->notify(pb->dev, 0);\r\npwm_config(pb->pwm, 0, pb->period);\r\npwm_disable(pb->pwm);\r\nif (pb->notify_after)\r\npb->notify_after(pb->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int pwm_backlight_resume(struct platform_device *pdev)\r\n{\r\nstruct backlight_device *bl = platform_get_drvdata(pdev);\r\nbacklight_update_status(bl);\r\nreturn 0;\r\n}\r\nstatic int __init pwm_backlight_init(void)\r\n{\r\nreturn platform_driver_register(&pwm_backlight_driver);\r\n}\r\nstatic void __exit pwm_backlight_exit(void)\r\n{\r\nplatform_driver_unregister(&pwm_backlight_driver);\r\n}
