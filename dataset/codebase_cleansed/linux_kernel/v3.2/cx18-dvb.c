static int yuan_mpc718_mt352_reqfw(struct cx18_stream *stream,\r\nconst struct firmware **fw)\r\n{\r\nstruct cx18 *cx = stream->cx;\r\nconst char *fn = "dvb-cx18-mpc718-mt352.fw";\r\nint ret;\r\nret = request_firmware(fw, fn, &cx->pci_dev->dev);\r\nif (ret)\r\nCX18_ERR("Unable to open firmware file %s\n", fn);\r\nelse {\r\nsize_t sz = (*fw)->size;\r\nif (sz < 2 || sz > 64 || (sz % 2) != 0) {\r\nCX18_ERR("Firmware %s has a bad size: %lu bytes\n",\r\nfn, (unsigned long) sz);\r\nret = -EILSEQ;\r\nrelease_firmware(*fw);\r\n*fw = NULL;\r\n}\r\n}\r\nif (ret) {\r\nCX18_ERR("The MPC718 board variant with the MT352 DVB-T"\r\n"demodualtor will not work without it\n");\r\nCX18_ERR("Run 'linux/Documentation/dvb/get_dvb_firmware "\r\n"mpc718' if you need the firmware\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int yuan_mpc718_mt352_init(struct dvb_frontend *fe)\r\n{\r\nstruct cx18_dvb *dvb = container_of(fe->dvb,\r\nstruct cx18_dvb, dvb_adapter);\r\nstruct cx18_stream *stream = dvb->stream;\r\nconst struct firmware *fw = NULL;\r\nint ret;\r\nint i;\r\nu8 buf[3];\r\nret = yuan_mpc718_mt352_reqfw(stream, &fw);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < fw->size; i += 2) {\r\nbuf[0] = fw->data[i];\r\nswitch (buf[0]) {\r\ncase TRL_NOMINAL_RATE_0:\r\nbreak;\r\ncase TRL_NOMINAL_RATE_1:\r\nbuf[1] = 0x72;\r\nbuf[2] = 0x49;\r\nmt352_write(fe, buf, 3);\r\nbreak;\r\ncase INPUT_FREQ_0:\r\nbreak;\r\ncase INPUT_FREQ_1:\r\nbuf[1] = 0x31;\r\nbuf[2] = 0xc0;\r\nmt352_write(fe, buf, 3);\r\nbreak;\r\ndefault:\r\nbuf[1] = fw->data[i+1];\r\nmt352_write(fe, buf, 2);\r\nbreak;\r\n}\r\n}\r\nbuf[0] = (u8) TUNER_GO;\r\nbuf[1] = 0x01;\r\nmt352_write(fe, buf, 2);\r\nrelease_firmware(fw);\r\nreturn 0;\r\n}\r\nstatic int cx18_dvb_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct cx18_stream *stream = (struct cx18_stream *) demux->priv;\r\nstruct cx18 *cx;\r\nint ret;\r\nu32 v;\r\nif (!stream)\r\nreturn -EINVAL;\r\ncx = stream->cx;\r\nCX18_DEBUG_INFO("Start feed: pid = 0x%x index = %d\n",\r\nfeed->pid, feed->index);\r\nmutex_lock(&cx->serialize_lock);\r\nret = cx18_init_on_first_open(cx);\r\nmutex_unlock(&cx->serialize_lock);\r\nif (ret) {\r\nCX18_ERR("Failed to initialize firmware starting DVB feed\n");\r\nreturn ret;\r\n}\r\nret = -EINVAL;\r\nswitch (cx->card->type) {\r\ncase CX18_CARD_HVR_1600_ESMT:\r\ncase CX18_CARD_HVR_1600_SAMSUNG:\r\ncase CX18_CARD_HVR_1600_S5H1411:\r\nv = cx18_read_reg(cx, CX18_REG_DMUX_NUM_PORT_0_CONTROL);\r\nv |= 0x00400000;\r\nv |= 0x00002000;\r\nv |= 0x00010000;\r\nv |= 0x00020000;\r\nv |= 0x000c0000;\r\ncx18_write_reg(cx, v, CX18_REG_DMUX_NUM_PORT_0_CONTROL);\r\nbreak;\r\ncase CX18_CARD_LEADTEK_DVR3100H:\r\ncase CX18_CARD_YUAN_MPC718:\r\ncase CX18_CARD_GOTVIEW_PCI_DVD3:\r\ndefault:\r\nbreak;\r\n}\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nmutex_lock(&stream->dvb->feedlock);\r\nif (stream->dvb->feeding++ == 0) {\r\nCX18_DEBUG_INFO("Starting Transport DMA\n");\r\nmutex_lock(&cx->serialize_lock);\r\nset_bit(CX18_F_S_STREAMING, &stream->s_flags);\r\nret = cx18_start_v4l2_encode_stream(stream);\r\nif (ret < 0) {\r\nCX18_DEBUG_INFO("Failed to start Transport DMA\n");\r\nstream->dvb->feeding--;\r\nif (stream->dvb->feeding == 0)\r\nclear_bit(CX18_F_S_STREAMING, &stream->s_flags);\r\n}\r\nmutex_unlock(&cx->serialize_lock);\r\n} else\r\nret = 0;\r\nmutex_unlock(&stream->dvb->feedlock);\r\nreturn ret;\r\n}\r\nstatic int cx18_dvb_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct cx18_stream *stream = (struct cx18_stream *)demux->priv;\r\nstruct cx18 *cx;\r\nint ret = -EINVAL;\r\nif (stream) {\r\ncx = stream->cx;\r\nCX18_DEBUG_INFO("Stop feed: pid = 0x%x index = %d\n",\r\nfeed->pid, feed->index);\r\nmutex_lock(&stream->dvb->feedlock);\r\nif (--stream->dvb->feeding == 0) {\r\nCX18_DEBUG_INFO("Stopping Transport DMA\n");\r\nmutex_lock(&cx->serialize_lock);\r\nret = cx18_stop_v4l2_encode_stream(stream, 0);\r\nmutex_unlock(&cx->serialize_lock);\r\n} else\r\nret = 0;\r\nmutex_unlock(&stream->dvb->feedlock);\r\n}\r\nreturn ret;\r\n}\r\nint cx18_dvb_register(struct cx18_stream *stream)\r\n{\r\nstruct cx18 *cx = stream->cx;\r\nstruct cx18_dvb *dvb = stream->dvb;\r\nstruct dvb_adapter *dvb_adapter;\r\nstruct dvb_demux *dvbdemux;\r\nstruct dmx_demux *dmx;\r\nint ret;\r\nif (!dvb)\r\nreturn -EINVAL;\r\ndvb->enabled = 0;\r\ndvb->stream = stream;\r\nret = dvb_register_adapter(&dvb->dvb_adapter,\r\nCX18_DRIVER_NAME,\r\nTHIS_MODULE, &cx->pci_dev->dev, adapter_nr);\r\nif (ret < 0)\r\ngoto err_out;\r\ndvb_adapter = &dvb->dvb_adapter;\r\ndvbdemux = &dvb->demux;\r\ndvbdemux->priv = (void *)stream;\r\ndvbdemux->filternum = 256;\r\ndvbdemux->feednum = 256;\r\ndvbdemux->start_feed = cx18_dvb_start_feed;\r\ndvbdemux->stop_feed = cx18_dvb_stop_feed;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);\r\nret = dvb_dmx_init(dvbdemux);\r\nif (ret < 0)\r\ngoto err_dvb_unregister_adapter;\r\ndmx = &dvbdemux->dmx;\r\ndvb->hw_frontend.source = DMX_FRONTEND_0;\r\ndvb->mem_frontend.source = DMX_MEMORY_FE;\r\ndvb->dmxdev.filternum = 256;\r\ndvb->dmxdev.demux = dmx;\r\nret = dvb_dmxdev_init(&dvb->dmxdev, dvb_adapter);\r\nif (ret < 0)\r\ngoto err_dvb_dmx_release;\r\nret = dmx->add_frontend(dmx, &dvb->hw_frontend);\r\nif (ret < 0)\r\ngoto err_dvb_dmxdev_release;\r\nret = dmx->add_frontend(dmx, &dvb->mem_frontend);\r\nif (ret < 0)\r\ngoto err_remove_hw_frontend;\r\nret = dmx->connect_frontend(dmx, &dvb->hw_frontend);\r\nif (ret < 0)\r\ngoto err_remove_mem_frontend;\r\nret = dvb_register(stream);\r\nif (ret < 0)\r\ngoto err_disconnect_frontend;\r\ndvb_net_init(dvb_adapter, &dvb->dvbnet, dmx);\r\nCX18_INFO("DVB Frontend registered\n");\r\nCX18_INFO("Registered DVB adapter%d for %s (%d x %d.%02d kB)\n",\r\nstream->dvb->dvb_adapter.num, stream->name,\r\nstream->buffers, stream->buf_size/1024,\r\n(stream->buf_size * 100 / 1024) % 100);\r\nmutex_init(&dvb->feedlock);\r\ndvb->enabled = 1;\r\nreturn ret;\r\nerr_disconnect_frontend:\r\ndmx->disconnect_frontend(dmx);\r\nerr_remove_mem_frontend:\r\ndmx->remove_frontend(dmx, &dvb->mem_frontend);\r\nerr_remove_hw_frontend:\r\ndmx->remove_frontend(dmx, &dvb->hw_frontend);\r\nerr_dvb_dmxdev_release:\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\nerr_dvb_dmx_release:\r\ndvb_dmx_release(dvbdemux);\r\nerr_dvb_unregister_adapter:\r\ndvb_unregister_adapter(dvb_adapter);\r\nerr_out:\r\nreturn ret;\r\n}\r\nvoid cx18_dvb_unregister(struct cx18_stream *stream)\r\n{\r\nstruct cx18 *cx = stream->cx;\r\nstruct cx18_dvb *dvb = stream->dvb;\r\nstruct dvb_adapter *dvb_adapter;\r\nstruct dvb_demux *dvbdemux;\r\nstruct dmx_demux *dmx;\r\nCX18_INFO("unregister DVB\n");\r\nif (dvb == NULL || !dvb->enabled)\r\nreturn;\r\ndvb_adapter = &dvb->dvb_adapter;\r\ndvbdemux = &dvb->demux;\r\ndmx = &dvbdemux->dmx;\r\ndmx->close(dmx);\r\ndvb_net_release(&dvb->dvbnet);\r\ndmx->remove_frontend(dmx, &dvb->mem_frontend);\r\ndmx->remove_frontend(dmx, &dvb->hw_frontend);\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\ndvb_dmx_release(dvbdemux);\r\ndvb_unregister_frontend(dvb->fe);\r\ndvb_frontend_detach(dvb->fe);\r\ndvb_unregister_adapter(dvb_adapter);\r\n}\r\nstatic int dvb_register(struct cx18_stream *stream)\r\n{\r\nstruct cx18_dvb *dvb = stream->dvb;\r\nstruct cx18 *cx = stream->cx;\r\nint ret = 0;\r\nswitch (cx->card->type) {\r\ncase CX18_CARD_HVR_1600_ESMT:\r\ncase CX18_CARD_HVR_1600_SAMSUNG:\r\ndvb->fe = dvb_attach(s5h1409_attach,\r\n&hauppauge_hvr1600_config,\r\n&cx->i2c_adap[0]);\r\nif (dvb->fe != NULL) {\r\ndvb_attach(mxl5005s_attach, dvb->fe,\r\n&cx->i2c_adap[0],\r\n&hauppauge_hvr1600_tuner);\r\nret = 0;\r\n}\r\nbreak;\r\ncase CX18_CARD_HVR_1600_S5H1411:\r\ndvb->fe = dvb_attach(s5h1411_attach,\r\n&hcw_s5h1411_config,\r\n&cx->i2c_adap[0]);\r\nif (dvb->fe != NULL)\r\ndvb_attach(tda18271_attach, dvb->fe,\r\n0x60, &cx->i2c_adap[0],\r\n&hauppauge_tda18271_config);\r\nbreak;\r\ncase CX18_CARD_LEADTEK_DVR3100H:\r\ndvb->fe = dvb_attach(zl10353_attach,\r\n&leadtek_dvr3100h_demod,\r\n&cx->i2c_adap[1]);\r\nif (dvb->fe != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &cx->i2c_adap[1],\r\n.i2c_addr = 0xc2 >> 1,\r\n.ctrl = NULL,\r\n};\r\nstatic struct xc2028_ctrl ctrl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_ZARLINK456,\r\n.type = XC2028_AUTO,\r\n};\r\nfe = dvb_attach(xc2028_attach, dvb->fe, &cfg);\r\nif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\r\nfe->ops.tuner_ops.set_config(fe, &ctrl);\r\n}\r\nbreak;\r\ncase CX18_CARD_YUAN_MPC718:\r\ndvb->fe = dvb_attach(mt352_attach,\r\n&yuan_mpc718_mt352_demod,\r\n&cx->i2c_adap[1]);\r\nif (dvb->fe == NULL)\r\ndvb->fe = dvb_attach(zl10353_attach,\r\n&yuan_mpc718_zl10353_demod,\r\n&cx->i2c_adap[1]);\r\nif (dvb->fe != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &cx->i2c_adap[1],\r\n.i2c_addr = 0xc2 >> 1,\r\n.ctrl = NULL,\r\n};\r\nstatic struct xc2028_ctrl ctrl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_ZARLINK456,\r\n.type = XC2028_AUTO,\r\n};\r\nfe = dvb_attach(xc2028_attach, dvb->fe, &cfg);\r\nif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\r\nfe->ops.tuner_ops.set_config(fe, &ctrl);\r\n}\r\nbreak;\r\ncase CX18_CARD_GOTVIEW_PCI_DVD3:\r\ndvb->fe = dvb_attach(zl10353_attach,\r\n&gotview_dvd3_zl10353_demod,\r\n&cx->i2c_adap[1]);\r\nif (dvb->fe != NULL) {\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = &cx->i2c_adap[1],\r\n.i2c_addr = 0xc2 >> 1,\r\n.ctrl = NULL,\r\n};\r\nstatic struct xc2028_ctrl ctrl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n.demod = XC3028_FE_ZARLINK456,\r\n.type = XC2028_AUTO,\r\n};\r\nfe = dvb_attach(xc2028_attach, dvb->fe, &cfg);\r\nif (fe != NULL && fe->ops.tuner_ops.set_config != NULL)\r\nfe->ops.tuner_ops.set_config(fe, &ctrl);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (dvb->fe == NULL) {\r\nCX18_ERR("frontend initialization failed\n");\r\nreturn -1;\r\n}\r\ndvb->fe->callback = cx18_reset_tuner_gpio;\r\nret = dvb_register_frontend(&dvb->dvb_adapter, dvb->fe);\r\nif (ret < 0) {\r\nif (dvb->fe->ops.release)\r\ndvb->fe->ops.release(dvb->fe);\r\nreturn ret;\r\n}\r\ncx18_write_reg_expect(cx,\r\n(CX18_DMUX_CLK_MASK << 16) | CX18_DMUX_CLK_MASK,\r\nCX18_CLOCK_ENABLE2,\r\nCX18_DMUX_CLK_MASK,\r\n(CX18_DMUX_CLK_MASK << 16) | CX18_DMUX_CLK_MASK);\r\nreturn ret;\r\n}
