static bool sctp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct sctphdr *hp;\r\nstruct sctphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, 8, &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->src.u.sctp.port = hp->source;\r\ntuple->dst.u.sctp.port = hp->dest;\r\nreturn true;\r\n}\r\nstatic bool sctp_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u.sctp.port = orig->dst.u.sctp.port;\r\ntuple->dst.u.sctp.port = orig->src.u.sctp.port;\r\nreturn true;\r\n}\r\nstatic int sctp_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "sport=%hu dport=%hu ",\r\nntohs(tuple->src.u.sctp.port),\r\nntohs(tuple->dst.u.sctp.port));\r\n}\r\nstatic int sctp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\r\n{\r\nenum sctp_conntrack state;\r\nspin_lock_bh(&ct->lock);\r\nstate = ct->proto.sctp.state;\r\nspin_unlock_bh(&ct->lock);\r\nreturn seq_printf(s, "%s ", sctp_conntrack_names[state]);\r\n}\r\nstatic int do_basic_checks(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nunsigned long *map)\r\n{\r\nu_int32_t offset, count;\r\nsctp_chunkhdr_t _sch, *sch;\r\nint flag;\r\nflag = 0;\r\nfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\r\npr_debug("Chunk Num: %d Type: %d\n", count, sch->type);\r\nif (sch->type == SCTP_CID_INIT ||\r\nsch->type == SCTP_CID_INIT_ACK ||\r\nsch->type == SCTP_CID_SHUTDOWN_COMPLETE)\r\nflag = 1;\r\nif (((sch->type == SCTP_CID_COOKIE_ACK ||\r\nsch->type == SCTP_CID_COOKIE_ECHO ||\r\nflag) &&\r\ncount != 0) || !sch->length) {\r\npr_debug("Basic checks failed\n");\r\nreturn 1;\r\n}\r\nif (map)\r\nset_bit(sch->type, map);\r\n}\r\npr_debug("Basic checks passed\n");\r\nreturn count == 0;\r\n}\r\nstatic int sctp_new_state(enum ip_conntrack_dir dir,\r\nenum sctp_conntrack cur_state,\r\nint chunk_type)\r\n{\r\nint i;\r\npr_debug("Chunk type: %d\n", chunk_type);\r\nswitch (chunk_type) {\r\ncase SCTP_CID_INIT:\r\npr_debug("SCTP_CID_INIT\n");\r\ni = 0;\r\nbreak;\r\ncase SCTP_CID_INIT_ACK:\r\npr_debug("SCTP_CID_INIT_ACK\n");\r\ni = 1;\r\nbreak;\r\ncase SCTP_CID_ABORT:\r\npr_debug("SCTP_CID_ABORT\n");\r\ni = 2;\r\nbreak;\r\ncase SCTP_CID_SHUTDOWN:\r\npr_debug("SCTP_CID_SHUTDOWN\n");\r\ni = 3;\r\nbreak;\r\ncase SCTP_CID_SHUTDOWN_ACK:\r\npr_debug("SCTP_CID_SHUTDOWN_ACK\n");\r\ni = 4;\r\nbreak;\r\ncase SCTP_CID_ERROR:\r\npr_debug("SCTP_CID_ERROR\n");\r\ni = 5;\r\nbreak;\r\ncase SCTP_CID_COOKIE_ECHO:\r\npr_debug("SCTP_CID_COOKIE_ECHO\n");\r\ni = 6;\r\nbreak;\r\ncase SCTP_CID_COOKIE_ACK:\r\npr_debug("SCTP_CID_COOKIE_ACK\n");\r\ni = 7;\r\nbreak;\r\ncase SCTP_CID_SHUTDOWN_COMPLETE:\r\npr_debug("SCTP_CID_SHUTDOWN_COMPLETE\n");\r\ni = 8;\r\nbreak;\r\ndefault:\r\npr_debug("Unknown chunk type, Will stay in %s\n",\r\nsctp_conntrack_names[cur_state]);\r\nreturn cur_state;\r\n}\r\npr_debug("dir: %d cur_state: %s chunk_type: %d new_state: %s\n",\r\ndir, sctp_conntrack_names[cur_state], chunk_type,\r\nsctp_conntrack_names[sctp_conntracks[dir][i][cur_state]]);\r\nreturn sctp_conntracks[dir][i][cur_state];\r\n}\r\nstatic int sctp_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nenum sctp_conntrack new_state, old_state;\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nconst struct sctphdr *sh;\r\nstruct sctphdr _sctph;\r\nconst struct sctp_chunkhdr *sch;\r\nstruct sctp_chunkhdr _sch;\r\nu_int32_t offset, count;\r\nunsigned long map[256 / sizeof(unsigned long)] = { 0 };\r\nsh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);\r\nif (sh == NULL)\r\ngoto out;\r\nif (do_basic_checks(ct, skb, dataoff, map) != 0)\r\ngoto out;\r\nif (!test_bit(SCTP_CID_INIT, map) &&\r\n!test_bit(SCTP_CID_SHUTDOWN_COMPLETE, map) &&\r\n!test_bit(SCTP_CID_COOKIE_ECHO, map) &&\r\n!test_bit(SCTP_CID_ABORT, map) &&\r\n!test_bit(SCTP_CID_SHUTDOWN_ACK, map) &&\r\nsh->vtag != ct->proto.sctp.vtag[dir]) {\r\npr_debug("Verification tag check failed\n");\r\ngoto out;\r\n}\r\nold_state = new_state = SCTP_CONNTRACK_NONE;\r\nspin_lock_bh(&ct->lock);\r\nfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\r\nif (sch->type == SCTP_CID_INIT) {\r\nif (sh->vtag != 0)\r\ngoto out_unlock;\r\n} else if (sch->type == SCTP_CID_ABORT) {\r\nif (sh->vtag != ct->proto.sctp.vtag[dir] &&\r\nsh->vtag != ct->proto.sctp.vtag[!dir])\r\ngoto out_unlock;\r\n} else if (sch->type == SCTP_CID_SHUTDOWN_COMPLETE) {\r\nif (sh->vtag != ct->proto.sctp.vtag[dir] &&\r\nsh->vtag != ct->proto.sctp.vtag[!dir] &&\r\nsch->flags & SCTP_CHUNK_FLAG_T)\r\ngoto out_unlock;\r\n} else if (sch->type == SCTP_CID_COOKIE_ECHO) {\r\nif (sh->vtag != ct->proto.sctp.vtag[dir])\r\ngoto out_unlock;\r\n}\r\nold_state = ct->proto.sctp.state;\r\nnew_state = sctp_new_state(dir, old_state, sch->type);\r\nif (new_state == SCTP_CONNTRACK_MAX) {\r\npr_debug("nf_conntrack_sctp: Invalid dir=%i ctype=%u "\r\n"conntrack=%u\n",\r\ndir, sch->type, old_state);\r\ngoto out_unlock;\r\n}\r\nif (sch->type == SCTP_CID_INIT ||\r\nsch->type == SCTP_CID_INIT_ACK) {\r\nsctp_inithdr_t _inithdr, *ih;\r\nih = skb_header_pointer(skb, offset + sizeof(sctp_chunkhdr_t),\r\nsizeof(_inithdr), &_inithdr);\r\nif (ih == NULL)\r\ngoto out_unlock;\r\npr_debug("Setting vtag %x for dir %d\n",\r\nih->init_tag, !dir);\r\nct->proto.sctp.vtag[!dir] = ih->init_tag;\r\n}\r\nct->proto.sctp.state = new_state;\r\nif (old_state != new_state)\r\nnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nnf_ct_refresh_acct(ct, ctinfo, skb, sctp_timeouts[new_state]);\r\nif (old_state == SCTP_CONNTRACK_COOKIE_ECHOED &&\r\ndir == IP_CT_DIR_REPLY &&\r\nnew_state == SCTP_CONNTRACK_ESTABLISHED) {\r\npr_debug("Setting assured bit\n");\r\nset_bit(IPS_ASSURED_BIT, &ct->status);\r\nnf_conntrack_event_cache(IPCT_ASSURED, ct);\r\n}\r\nreturn NF_ACCEPT;\r\nout_unlock:\r\nspin_unlock_bh(&ct->lock);\r\nout:\r\nreturn -NF_ACCEPT;\r\n}\r\nstatic bool sctp_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff)\r\n{\r\nenum sctp_conntrack new_state;\r\nconst struct sctphdr *sh;\r\nstruct sctphdr _sctph;\r\nconst struct sctp_chunkhdr *sch;\r\nstruct sctp_chunkhdr _sch;\r\nu_int32_t offset, count;\r\nunsigned long map[256 / sizeof(unsigned long)] = { 0 };\r\nsh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);\r\nif (sh == NULL)\r\nreturn false;\r\nif (do_basic_checks(ct, skb, dataoff, map) != 0)\r\nreturn false;\r\nif (test_bit(SCTP_CID_ABORT, map) ||\r\ntest_bit(SCTP_CID_SHUTDOWN_COMPLETE, map) ||\r\ntest_bit(SCTP_CID_COOKIE_ACK, map))\r\nreturn false;\r\nmemset(&ct->proto.sctp, 0, sizeof(ct->proto.sctp));\r\nnew_state = SCTP_CONNTRACK_MAX;\r\nfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\r\nnew_state = sctp_new_state(IP_CT_DIR_ORIGINAL,\r\nSCTP_CONNTRACK_NONE, sch->type);\r\nif (new_state == SCTP_CONNTRACK_NONE ||\r\nnew_state == SCTP_CONNTRACK_MAX) {\r\npr_debug("nf_conntrack_sctp: invalid new deleting.\n");\r\nreturn false;\r\n}\r\nif (sch->type == SCTP_CID_INIT) {\r\nif (sh->vtag == 0) {\r\nsctp_inithdr_t _inithdr, *ih;\r\nih = skb_header_pointer(skb, offset + sizeof(sctp_chunkhdr_t),\r\nsizeof(_inithdr), &_inithdr);\r\nif (ih == NULL)\r\nreturn false;\r\npr_debug("Setting vtag %x for new conn\n",\r\nih->init_tag);\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY] =\r\nih->init_tag;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nelse {\r\npr_debug("Setting vtag %x for new conn OOTB\n",\r\nsh->vtag);\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY] = sh->vtag;\r\n}\r\nct->proto.sctp.state = new_state;\r\n}\r\nreturn true;\r\n}\r\nstatic int sctp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\r\nstruct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_parms;\r\nspin_lock_bh(&ct->lock);\r\nnest_parms = nla_nest_start(skb, CTA_PROTOINFO_SCTP | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nNLA_PUT_U8(skb, CTA_PROTOINFO_SCTP_STATE, ct->proto.sctp.state);\r\nNLA_PUT_BE32(skb,\r\nCTA_PROTOINFO_SCTP_VTAG_ORIGINAL,\r\nct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL]);\r\nNLA_PUT_BE32(skb,\r\nCTA_PROTOINFO_SCTP_VTAG_REPLY,\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY]);\r\nspin_unlock_bh(&ct->lock);\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nspin_unlock_bh(&ct->lock);\r\nreturn -1;\r\n}\r\nstatic int nlattr_to_sctp(struct nlattr *cda[], struct nf_conn *ct)\r\n{\r\nstruct nlattr *attr = cda[CTA_PROTOINFO_SCTP];\r\nstruct nlattr *tb[CTA_PROTOINFO_SCTP_MAX+1];\r\nint err;\r\nif (!attr)\r\nreturn 0;\r\nerr = nla_parse_nested(tb,\r\nCTA_PROTOINFO_SCTP_MAX,\r\nattr,\r\nsctp_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_PROTOINFO_SCTP_STATE] ||\r\n!tb[CTA_PROTOINFO_SCTP_VTAG_ORIGINAL] ||\r\n!tb[CTA_PROTOINFO_SCTP_VTAG_REPLY])\r\nreturn -EINVAL;\r\nspin_lock_bh(&ct->lock);\r\nct->proto.sctp.state = nla_get_u8(tb[CTA_PROTOINFO_SCTP_STATE]);\r\nct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL] =\r\nnla_get_be32(tb[CTA_PROTOINFO_SCTP_VTAG_ORIGINAL]);\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY] =\r\nnla_get_be32(tb[CTA_PROTOINFO_SCTP_VTAG_REPLY]);\r\nspin_unlock_bh(&ct->lock);\r\nreturn 0;\r\n}\r\nstatic int sctp_nlattr_size(void)\r\n{\r\nreturn nla_total_size(0)\r\n+ nla_policy_len(sctp_nla_policy, CTA_PROTOINFO_SCTP_MAX + 1);\r\n}\r\nstatic int __init nf_conntrack_proto_sctp_init(void)\r\n{\r\nint ret;\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_sctp4);\r\nif (ret) {\r\npr_err("nf_conntrack_l4proto_sctp4: protocol register failed\n");\r\ngoto out;\r\n}\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_sctp6);\r\nif (ret) {\r\npr_err("nf_conntrack_l4proto_sctp6: protocol register failed\n");\r\ngoto cleanup_sctp4;\r\n}\r\nreturn ret;\r\ncleanup_sctp4:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_sctp4);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_proto_sctp_fini(void)\r\n{\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_sctp6);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_sctp4);\r\n}
