static int __cpuinit wakeup_secondary_cpu_via_mip(int cpu, unsigned long eip)\r\n{\r\nunsigned long vect = 0, psaival = 0;\r\nif (psai == NULL)\r\nreturn -1;\r\nvect = ((unsigned long)__pa(eip)/0x1000) << 16;\r\npsaival = (0x1000000 | vect | cpu);\r\nwhile (*psai & 0x1000000)\r\n;\r\n*psai = psaival;\r\nreturn 0;\r\n}\r\nstatic int es7000_apic_is_cluster(void)\r\n{\r\nif (boot_cpu_data.x86 == 6 &&\r\n(boot_cpu_data.x86_model >= 7 && boot_cpu_data.x86_model <= 11))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void setup_unisys(void)\r\n{\r\nif (!(boot_cpu_data.x86 <= 15 && boot_cpu_data.x86_model <= 2))\r\nes7000_plat = ES7000_ZORRO;\r\nelse\r\nes7000_plat = ES7000_CLASSIC;\r\n}\r\nstatic int parse_unisys_oem(char *oemptr)\r\n{\r\nint i;\r\nint success = 0;\r\nunsigned char type, size;\r\nunsigned long val;\r\nchar *tp = NULL;\r\nstruct psai *psaip = NULL;\r\nstruct mip_reg_info *mi;\r\nstruct mip_reg *host, *mip;\r\ntp = oemptr;\r\ntp += 8;\r\nfor (i = 0; i <= 6; i++) {\r\ntype = *tp++;\r\nsize = *tp++;\r\ntp -= 2;\r\nswitch (type) {\r\ncase MIP_REG:\r\nmi = (struct mip_reg_info *)tp;\r\nval = MIP_RD_LO(mi->host_reg);\r\nhost_addr = val;\r\nhost = (struct mip_reg *)val;\r\nhost_reg = __va(host);\r\nval = MIP_RD_LO(mi->mip_reg);\r\nmip_port = MIP_PORT(mi->mip_info);\r\nmip_addr = val;\r\nmip = (struct mip_reg *)val;\r\nmip_reg = __va(mip);\r\npr_debug("host_reg = 0x%lx\n",\r\n(unsigned long)host_reg);\r\npr_debug("mip_reg = 0x%lx\n",\r\n(unsigned long)mip_reg);\r\nsuccess++;\r\nbreak;\r\ncase MIP_PSAI_REG:\r\npsaip = (struct psai *)tp;\r\nif (tp != NULL) {\r\nif (psaip->addr)\r\npsai = __va(psaip->addr);\r\nelse\r\npsai = NULL;\r\nsuccess++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntp += size;\r\n}\r\nif (success < 2)\r\nes7000_plat = NON_UNISYS;\r\nelse\r\nsetup_unisys();\r\nreturn es7000_plat;\r\n}\r\nstatic int __init find_unisys_acpi_oem_table(unsigned long *oem_addr)\r\n{\r\nstruct acpi_table_header *header = NULL;\r\nstruct es7000_oem_table *table;\r\nacpi_size tbl_size;\r\nacpi_status ret;\r\nint i = 0;\r\nfor (;;) {\r\nret = acpi_get_table_with_size("OEM1", i++, &header, &tbl_size);\r\nif (!ACPI_SUCCESS(ret))\r\nreturn -1;\r\nif (!memcmp((char *) &header->oem_id, "UNISYS", 6))\r\nbreak;\r\nearly_acpi_os_unmap_memory(header, tbl_size);\r\n}\r\ntable = (void *)header;\r\noem_addrX = table->OEMTableAddr;\r\noem_size = table->OEMTableSize;\r\nearly_acpi_os_unmap_memory(header, tbl_size);\r\n*oem_addr = (unsigned long)__acpi_map_table(oem_addrX, oem_size);\r\nreturn 0;\r\n}\r\nstatic void __init unmap_unisys_acpi_oem_table(unsigned long oem_addr)\r\n{\r\nif (!oem_addr)\r\nreturn;\r\n__acpi_unmap_table((char *)oem_addr, oem_size);\r\n}\r\nstatic int es7000_check_dsdt(void)\r\n{\r\nstruct acpi_table_header header;\r\nif (ACPI_SUCCESS(acpi_get_table_header(ACPI_SIG_DSDT, 0, &header)) &&\r\n!strncmp(header.oem_id, "UNISYS", 6))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init es7000_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nunsigned long oem_addr = 0;\r\nint check_dsdt;\r\nint ret = 0;\r\ncheck_dsdt = es7000_check_dsdt();\r\nif (!find_unisys_acpi_oem_table(&oem_addr)) {\r\nif (check_dsdt) {\r\nret = parse_unisys_oem((char *)oem_addr);\r\n} else {\r\nsetup_unisys();\r\nret = 1;\r\n}\r\nunmap_unisys_acpi_oem_table(oem_addr);\r\n}\r\nes7000_acpi_ret = ret;\r\nreturn ret && !es7000_apic_is_cluster();\r\n}\r\nstatic int es7000_acpi_madt_oem_check_cluster(char *oem_id, char *oem_table_id)\r\n{\r\nint ret = es7000_acpi_ret;\r\nreturn ret && es7000_apic_is_cluster();\r\n}\r\nstatic int es7000_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nreturn 0;\r\n}\r\nstatic int es7000_acpi_madt_oem_check_cluster(char *oem_id, char *oem_table_id)\r\n{\r\nreturn 0;\r\n}\r\nstatic void es7000_spin(int n)\r\n{\r\nint i = 0;\r\nwhile (i++ < n)\r\nrep_nop();\r\n}\r\nstatic int es7000_mip_write(struct mip_reg *mip_reg)\r\n{\r\nint status = 0;\r\nint spin;\r\nspin = MIP_SPIN;\r\nwhile ((host_reg->off_0x38 & MIP_VALID) != 0) {\r\nif (--spin <= 0) {\r\nWARN(1, "Timeout waiting for Host Valid Flag\n");\r\nreturn -1;\r\n}\r\nes7000_spin(MIP_SPIN);\r\n}\r\nmemcpy(host_reg, mip_reg, sizeof(struct mip_reg));\r\noutb(1, mip_port);\r\nspin = MIP_SPIN;\r\nwhile ((mip_reg->off_0x38 & MIP_VALID) == 0) {\r\nif (--spin <= 0) {\r\nWARN(1, "Timeout waiting for MIP Valid Flag\n");\r\nreturn -1;\r\n}\r\nes7000_spin(MIP_SPIN);\r\n}\r\nstatus = (mip_reg->off_0x00 & 0xffff0000000000ULL) >> 48;\r\nmip_reg->off_0x38 &= ~MIP_VALID;\r\nreturn status;\r\n}\r\nstatic void es7000_enable_apic_mode(void)\r\n{\r\nstruct mip_reg es7000_mip_reg;\r\nint mip_status;\r\nif (!es7000_plat)\r\nreturn;\r\npr_info("Enabling APIC mode.\n");\r\nmemset(&es7000_mip_reg, 0, sizeof(struct mip_reg));\r\nes7000_mip_reg.off_0x00 = MIP_SW_APIC;\r\nes7000_mip_reg.off_0x38 = MIP_VALID;\r\nwhile ((mip_status = es7000_mip_write(&es7000_mip_reg)) != 0)\r\nWARN(1, "Command failed, status = %x\n", mip_status);\r\n}\r\nstatic void es7000_vector_allocation_domain(int cpu, struct cpumask *retmask)\r\n{\r\ncpumask_clear(retmask);\r\ncpumask_bits(retmask)[0] = APIC_ALL_CPUS;\r\n}\r\nstatic void es7000_wait_for_init_deassert(atomic_t *deassert)\r\n{\r\nwhile (!atomic_read(deassert))\r\ncpu_relax();\r\n}\r\nstatic unsigned int es7000_get_apic_id(unsigned long x)\r\n{\r\nreturn (x >> 24) & 0xFF;\r\n}\r\nstatic void es7000_send_IPI_mask(const struct cpumask *mask, int vector)\r\n{\r\ndefault_send_IPI_mask_sequence_phys(mask, vector);\r\n}\r\nstatic void es7000_send_IPI_allbutself(int vector)\r\n{\r\ndefault_send_IPI_mask_allbutself_phys(cpu_online_mask, vector);\r\n}\r\nstatic void es7000_send_IPI_all(int vector)\r\n{\r\nes7000_send_IPI_mask(cpu_online_mask, vector);\r\n}\r\nstatic int es7000_apic_id_registered(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic const struct cpumask *target_cpus_cluster(void)\r\n{\r\nreturn cpu_all_mask;\r\n}\r\nstatic const struct cpumask *es7000_target_cpus(void)\r\n{\r\nreturn cpumask_of(smp_processor_id());\r\n}\r\nstatic unsigned long es7000_check_apicid_used(physid_mask_t *map, int apicid)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned long es7000_check_apicid_present(int bit)\r\n{\r\nreturn physid_isset(bit, phys_cpu_present_map);\r\n}\r\nstatic int es7000_early_logical_apicid(int cpu)\r\n{\r\nreturn early_per_cpu(x86_bios_cpu_apicid, cpu);\r\n}\r\nstatic unsigned long calculate_ldr(int cpu)\r\n{\r\nunsigned long id = per_cpu(x86_bios_cpu_apicid, cpu);\r\nreturn SET_APIC_LOGICAL_ID(id);\r\n}\r\nstatic void es7000_init_apic_ldr_cluster(void)\r\n{\r\nunsigned long val;\r\nint cpu = smp_processor_id();\r\napic_write(APIC_DFR, APIC_DFR_CLUSTER);\r\nval = calculate_ldr(cpu);\r\napic_write(APIC_LDR, val);\r\n}\r\nstatic void es7000_init_apic_ldr(void)\r\n{\r\nunsigned long val;\r\nint cpu = smp_processor_id();\r\napic_write(APIC_DFR, APIC_DFR_FLAT);\r\nval = calculate_ldr(cpu);\r\napic_write(APIC_LDR, val);\r\n}\r\nstatic void es7000_setup_apic_routing(void)\r\n{\r\nint apic = per_cpu(x86_bios_cpu_apicid, smp_processor_id());\r\npr_info("Enabling APIC mode: %s. Using %d I/O APICs, target cpus %lx\n",\r\n(apic_version[apic] == 0x14) ?\r\n"Physical Cluster" : "Logical Cluster",\r\nnr_ioapics, cpumask_bits(es7000_target_cpus())[0]);\r\n}\r\nstatic int es7000_cpu_present_to_apicid(int mps_cpu)\r\n{\r\nif (!mps_cpu)\r\nreturn boot_cpu_physical_apicid;\r\nelse if (mps_cpu < nr_cpu_ids)\r\nreturn per_cpu(x86_bios_cpu_apicid, mps_cpu);\r\nelse\r\nreturn BAD_APICID;\r\n}\r\nstatic void es7000_apicid_to_cpu_present(int phys_apicid, physid_mask_t *retmap)\r\n{\r\nphysid_set_mask_of_physid(cpu_id, retmap);\r\n++cpu_id;\r\n}\r\nstatic void es7000_ioapic_phys_id_map(physid_mask_t *phys_map, physid_mask_t *retmap)\r\n{\r\nphysids_promote(0xFFL, retmap);\r\n}\r\nstatic int es7000_check_phys_apicid_present(int cpu_physical_apicid)\r\n{\r\nboot_cpu_physical_apicid = read_apic_id();\r\nreturn 1;\r\n}\r\nstatic unsigned int es7000_cpu_mask_to_apicid(const struct cpumask *cpumask)\r\n{\r\nunsigned int round = 0;\r\nint cpu, uninitialized_var(apicid);\r\nfor_each_cpu(cpu, cpumask) {\r\nint new_apicid = early_per_cpu(x86_cpu_to_logical_apicid, cpu);\r\nif (round && APIC_CLUSTER(apicid) != APIC_CLUSTER(new_apicid)) {\r\nWARN(1, "Not a valid mask!");\r\nreturn BAD_APICID;\r\n}\r\napicid = new_apicid;\r\nround++;\r\n}\r\nreturn apicid;\r\n}\r\nstatic unsigned int\r\nes7000_cpu_mask_to_apicid_and(const struct cpumask *inmask,\r\nconst struct cpumask *andmask)\r\n{\r\nint apicid = early_per_cpu(x86_cpu_to_logical_apicid, 0);\r\ncpumask_var_t cpumask;\r\nif (!alloc_cpumask_var(&cpumask, GFP_ATOMIC))\r\nreturn apicid;\r\ncpumask_and(cpumask, inmask, andmask);\r\ncpumask_and(cpumask, cpumask, cpu_online_mask);\r\napicid = es7000_cpu_mask_to_apicid(cpumask);\r\nfree_cpumask_var(cpumask);\r\nreturn apicid;\r\n}\r\nstatic int es7000_phys_pkg_id(int cpuid_apic, int index_msb)\r\n{\r\nreturn cpuid_apic >> index_msb;\r\n}\r\nstatic int probe_es7000(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int es7000_mps_oem_check(struct mpc_table *mpc, char *oem,\r\nchar *productid)\r\n{\r\nint ret = 0;\r\nif (mpc->oemptr) {\r\nstruct mpc_oemtable *oem_table =\r\n(struct mpc_oemtable *)mpc->oemptr;\r\nif (!strncmp(oem, "UNISYS", 6))\r\nret = parse_unisys_oem((char *)oem_table);\r\n}\r\nes7000_mps_ret = ret;\r\nreturn ret && !es7000_apic_is_cluster();\r\n}\r\nstatic int es7000_mps_oem_check_cluster(struct mpc_table *mpc, char *oem,\r\nchar *productid)\r\n{\r\nint ret = es7000_mps_ret;\r\nreturn ret && es7000_apic_is_cluster();\r\n}
