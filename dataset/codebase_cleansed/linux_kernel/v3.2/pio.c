static void tx_start(struct b43legacy_pioqueue *queue)\r\n{\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nB43legacy_PIO_TXCTL_INIT);\r\n}\r\nstatic void tx_octet(struct b43legacy_pioqueue *queue,\r\nu8 octet)\r\n{\r\nif (queue->need_workarounds) {\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, octet);\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nB43legacy_PIO_TXCTL_WRITELO);\r\n} else {\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nB43legacy_PIO_TXCTL_WRITELO);\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, octet);\r\n}\r\n}\r\nstatic u16 tx_get_next_word(const u8 *txhdr,\r\nconst u8 *packet,\r\nsize_t txhdr_size,\r\nunsigned int *pos)\r\n{\r\nconst u8 *source;\r\nunsigned int i = *pos;\r\nu16 ret;\r\nif (i < txhdr_size)\r\nsource = txhdr;\r\nelse {\r\nsource = packet;\r\ni -= txhdr_size;\r\n}\r\nret = le16_to_cpu(*((__le16 *)(source + i)));\r\n*pos += 2;\r\nreturn ret;\r\n}\r\nstatic void tx_data(struct b43legacy_pioqueue *queue,\r\nu8 *txhdr,\r\nconst u8 *packet,\r\nunsigned int octets)\r\n{\r\nu16 data;\r\nunsigned int i = 0;\r\nif (queue->need_workarounds) {\r\ndata = tx_get_next_word(txhdr, packet,\r\nsizeof(struct b43legacy_txhdr_fw3), &i);\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, data);\r\n}\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nB43legacy_PIO_TXCTL_WRITELO |\r\nB43legacy_PIO_TXCTL_WRITEHI);\r\nwhile (i < octets - 1) {\r\ndata = tx_get_next_word(txhdr, packet,\r\nsizeof(struct b43legacy_txhdr_fw3), &i);\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, data);\r\n}\r\nif (octets % 2)\r\ntx_octet(queue, packet[octets -\r\nsizeof(struct b43legacy_txhdr_fw3) - 1]);\r\n}\r\nstatic void tx_complete(struct b43legacy_pioqueue *queue,\r\nstruct sk_buff *skb)\r\n{\r\nif (queue->need_workarounds) {\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXDATA,\r\nskb->data[skb->len - 1]);\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nB43legacy_PIO_TXCTL_WRITELO |\r\nB43legacy_PIO_TXCTL_COMPLETE);\r\n} else\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nB43legacy_PIO_TXCTL_COMPLETE);\r\n}\r\nstatic u16 generate_cookie(struct b43legacy_pioqueue *queue,\r\nstruct b43legacy_pio_txpacket *packet)\r\n{\r\nu16 cookie = 0x0000;\r\nint packetindex;\r\nswitch (queue->mmio_base) {\r\ncase B43legacy_MMIO_PIO1_BASE:\r\nbreak;\r\ncase B43legacy_MMIO_PIO2_BASE:\r\ncookie = 0x1000;\r\nbreak;\r\ncase B43legacy_MMIO_PIO3_BASE:\r\ncookie = 0x2000;\r\nbreak;\r\ncase B43legacy_MMIO_PIO4_BASE:\r\ncookie = 0x3000;\r\nbreak;\r\ndefault:\r\nB43legacy_WARN_ON(1);\r\n}\r\npacketindex = pio_txpacket_getindex(packet);\r\nB43legacy_WARN_ON(!(((u16)packetindex & 0xF000) == 0x0000));\r\ncookie |= (u16)packetindex;\r\nreturn cookie;\r\n}\r\nstatic\r\nstruct b43legacy_pioqueue *parse_cookie(struct b43legacy_wldev *dev,\r\nu16 cookie,\r\nstruct b43legacy_pio_txpacket **packet)\r\n{\r\nstruct b43legacy_pio *pio = &dev->pio;\r\nstruct b43legacy_pioqueue *queue = NULL;\r\nint packetindex;\r\nswitch (cookie & 0xF000) {\r\ncase 0x0000:\r\nqueue = pio->queue0;\r\nbreak;\r\ncase 0x1000:\r\nqueue = pio->queue1;\r\nbreak;\r\ncase 0x2000:\r\nqueue = pio->queue2;\r\nbreak;\r\ncase 0x3000:\r\nqueue = pio->queue3;\r\nbreak;\r\ndefault:\r\nB43legacy_WARN_ON(1);\r\n}\r\npacketindex = (cookie & 0x0FFF);\r\nB43legacy_WARN_ON(!(packetindex >= 0 && packetindex\r\n< B43legacy_PIO_MAXTXPACKETS));\r\n*packet = &(queue->tx_packets_cache[packetindex]);\r\nreturn queue;\r\n}\r\nstatic int pio_tx_write_fragment(struct b43legacy_pioqueue *queue,\r\nstruct sk_buff *skb,\r\nstruct b43legacy_pio_txpacket *packet,\r\nsize_t txhdr_size)\r\n{\r\nunion txhdr_union txhdr_data;\r\nu8 *txhdr = NULL;\r\nunsigned int octets;\r\nint err;\r\ntxhdr = (u8 *)(&txhdr_data.txhdr_fw3);\r\nB43legacy_WARN_ON(skb_shinfo(skb)->nr_frags != 0);\r\nerr = b43legacy_generate_txhdr(queue->dev,\r\ntxhdr, skb->data, skb->len,\r\nIEEE80211_SKB_CB(skb),\r\ngenerate_cookie(queue, packet));\r\nif (err)\r\nreturn err;\r\ntx_start(queue);\r\noctets = skb->len + txhdr_size;\r\nif (queue->need_workarounds)\r\noctets--;\r\ntx_data(queue, txhdr, (u8 *)skb->data, octets);\r\ntx_complete(queue, skb);\r\nreturn 0;\r\n}\r\nstatic void free_txpacket(struct b43legacy_pio_txpacket *packet,\r\nint irq_context)\r\n{\r\nstruct b43legacy_pioqueue *queue = packet->queue;\r\nif (packet->skb) {\r\nif (irq_context)\r\ndev_kfree_skb_irq(packet->skb);\r\nelse\r\ndev_kfree_skb(packet->skb);\r\n}\r\nlist_move(&packet->list, &queue->txfree);\r\nqueue->nr_txfree++;\r\n}\r\nstatic int pio_tx_packet(struct b43legacy_pio_txpacket *packet)\r\n{\r\nstruct b43legacy_pioqueue *queue = packet->queue;\r\nstruct sk_buff *skb = packet->skb;\r\nu16 octets;\r\nint err;\r\noctets = (u16)skb->len + sizeof(struct b43legacy_txhdr_fw3);\r\nif (queue->tx_devq_size < octets) {\r\nb43legacywarn(queue->dev->wl, "PIO queue too small. "\r\n"Dropping packet.\n");\r\nfree_txpacket(packet, 1);\r\nreturn 0;\r\n}\r\nB43legacy_WARN_ON(queue->tx_devq_packets >\r\nB43legacy_PIO_MAXTXDEVQPACKETS);\r\nB43legacy_WARN_ON(queue->tx_devq_used > queue->tx_devq_size);\r\nif (queue->tx_devq_packets == B43legacy_PIO_MAXTXDEVQPACKETS)\r\nreturn -EBUSY;\r\nif (queue->tx_devq_used + octets > queue->tx_devq_size)\r\nreturn -EBUSY;\r\nerr = pio_tx_write_fragment(queue, skb, packet,\r\nsizeof(struct b43legacy_txhdr_fw3));\r\nif (unlikely(err == -ENOKEY)) {\r\nfree_txpacket(packet, 1);\r\nreturn 0;\r\n}\r\nqueue->tx_devq_packets++;\r\nqueue->tx_devq_used += octets;\r\nlist_move_tail(&packet->list, &queue->txrunning);\r\nreturn 0;\r\n}\r\nstatic void tx_tasklet(unsigned long d)\r\n{\r\nstruct b43legacy_pioqueue *queue = (struct b43legacy_pioqueue *)d;\r\nstruct b43legacy_wldev *dev = queue->dev;\r\nunsigned long flags;\r\nstruct b43legacy_pio_txpacket *packet, *tmp_packet;\r\nint err;\r\nu16 txctl;\r\nspin_lock_irqsave(&dev->wl->irq_lock, flags);\r\nif (queue->tx_frozen)\r\ngoto out_unlock;\r\ntxctl = b43legacy_pio_read(queue, B43legacy_PIO_TXCTL);\r\nif (txctl & B43legacy_PIO_TXCTL_SUSPEND)\r\ngoto out_unlock;\r\nlist_for_each_entry_safe(packet, tmp_packet, &queue->txqueue, list) {\r\nerr = pio_tx_packet(packet);\r\nif (err)\r\nbreak;\r\n}\r\nout_unlock:\r\nspin_unlock_irqrestore(&dev->wl->irq_lock, flags);\r\n}\r\nstatic void setup_txqueues(struct b43legacy_pioqueue *queue)\r\n{\r\nstruct b43legacy_pio_txpacket *packet;\r\nint i;\r\nqueue->nr_txfree = B43legacy_PIO_MAXTXPACKETS;\r\nfor (i = 0; i < B43legacy_PIO_MAXTXPACKETS; i++) {\r\npacket = &(queue->tx_packets_cache[i]);\r\npacket->queue = queue;\r\nINIT_LIST_HEAD(&packet->list);\r\nlist_add(&packet->list, &queue->txfree);\r\n}\r\n}\r\nstatic\r\nstruct b43legacy_pioqueue *b43legacy_setup_pioqueue(struct b43legacy_wldev *dev,\r\nu16 pio_mmio_base)\r\n{\r\nstruct b43legacy_pioqueue *queue;\r\nu32 value;\r\nu16 qsize;\r\nqueue = kzalloc(sizeof(*queue), GFP_KERNEL);\r\nif (!queue)\r\ngoto out;\r\nqueue->dev = dev;\r\nqueue->mmio_base = pio_mmio_base;\r\nqueue->need_workarounds = (dev->dev->id.revision < 3);\r\nINIT_LIST_HEAD(&queue->txfree);\r\nINIT_LIST_HEAD(&queue->txqueue);\r\nINIT_LIST_HEAD(&queue->txrunning);\r\ntasklet_init(&queue->txtask, tx_tasklet,\r\n(unsigned long)queue);\r\nvalue = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\r\nvalue &= ~B43legacy_MACCTL_BE;\r\nb43legacy_write32(dev, B43legacy_MMIO_MACCTL, value);\r\nqsize = b43legacy_read16(dev, queue->mmio_base\r\n+ B43legacy_PIO_TXQBUFSIZE);\r\nif (qsize == 0) {\r\nb43legacyerr(dev->wl, "This card does not support PIO "\r\n"operation mode. Please use DMA mode "\r\n"(module parameter pio=0).\n");\r\ngoto err_freequeue;\r\n}\r\nif (qsize <= B43legacy_PIO_TXQADJUST) {\r\nb43legacyerr(dev->wl, "PIO tx device-queue too small (%u)\n",\r\nqsize);\r\ngoto err_freequeue;\r\n}\r\nqsize -= B43legacy_PIO_TXQADJUST;\r\nqueue->tx_devq_size = qsize;\r\nsetup_txqueues(queue);\r\nout:\r\nreturn queue;\r\nerr_freequeue:\r\nkfree(queue);\r\nqueue = NULL;\r\ngoto out;\r\n}\r\nstatic void cancel_transfers(struct b43legacy_pioqueue *queue)\r\n{\r\nstruct b43legacy_pio_txpacket *packet, *tmp_packet;\r\ntasklet_disable(&queue->txtask);\r\nlist_for_each_entry_safe(packet, tmp_packet, &queue->txrunning, list)\r\nfree_txpacket(packet, 0);\r\nlist_for_each_entry_safe(packet, tmp_packet, &queue->txqueue, list)\r\nfree_txpacket(packet, 0);\r\n}\r\nstatic void b43legacy_destroy_pioqueue(struct b43legacy_pioqueue *queue)\r\n{\r\nif (!queue)\r\nreturn;\r\ncancel_transfers(queue);\r\nkfree(queue);\r\n}\r\nvoid b43legacy_pio_free(struct b43legacy_wldev *dev)\r\n{\r\nstruct b43legacy_pio *pio;\r\nif (!b43legacy_using_pio(dev))\r\nreturn;\r\npio = &dev->pio;\r\nb43legacy_destroy_pioqueue(pio->queue3);\r\npio->queue3 = NULL;\r\nb43legacy_destroy_pioqueue(pio->queue2);\r\npio->queue2 = NULL;\r\nb43legacy_destroy_pioqueue(pio->queue1);\r\npio->queue1 = NULL;\r\nb43legacy_destroy_pioqueue(pio->queue0);\r\npio->queue0 = NULL;\r\n}\r\nint b43legacy_pio_init(struct b43legacy_wldev *dev)\r\n{\r\nstruct b43legacy_pio *pio = &dev->pio;\r\nstruct b43legacy_pioqueue *queue;\r\nint err = -ENOMEM;\r\nqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO1_BASE);\r\nif (!queue)\r\ngoto out;\r\npio->queue0 = queue;\r\nqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO2_BASE);\r\nif (!queue)\r\ngoto err_destroy0;\r\npio->queue1 = queue;\r\nqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO3_BASE);\r\nif (!queue)\r\ngoto err_destroy1;\r\npio->queue2 = queue;\r\nqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO4_BASE);\r\nif (!queue)\r\ngoto err_destroy2;\r\npio->queue3 = queue;\r\nif (dev->dev->id.revision < 3)\r\ndev->irq_mask |= B43legacy_IRQ_PIO_WORKAROUND;\r\nb43legacydbg(dev->wl, "PIO initialized\n");\r\nerr = 0;\r\nout:\r\nreturn err;\r\nerr_destroy2:\r\nb43legacy_destroy_pioqueue(pio->queue2);\r\npio->queue2 = NULL;\r\nerr_destroy1:\r\nb43legacy_destroy_pioqueue(pio->queue1);\r\npio->queue1 = NULL;\r\nerr_destroy0:\r\nb43legacy_destroy_pioqueue(pio->queue0);\r\npio->queue0 = NULL;\r\ngoto out;\r\n}\r\nint b43legacy_pio_tx(struct b43legacy_wldev *dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct b43legacy_pioqueue *queue = dev->pio.queue1;\r\nstruct b43legacy_pio_txpacket *packet;\r\nB43legacy_WARN_ON(queue->tx_suspended);\r\nB43legacy_WARN_ON(list_empty(&queue->txfree));\r\npacket = list_entry(queue->txfree.next, struct b43legacy_pio_txpacket,\r\nlist);\r\npacket->skb = skb;\r\nlist_move_tail(&packet->list, &queue->txqueue);\r\nqueue->nr_txfree--;\r\nB43legacy_WARN_ON(queue->nr_txfree >= B43legacy_PIO_MAXTXPACKETS);\r\ntasklet_schedule(&queue->txtask);\r\nreturn 0;\r\n}\r\nvoid b43legacy_pio_handle_txstatus(struct b43legacy_wldev *dev,\r\nconst struct b43legacy_txstatus *status)\r\n{\r\nstruct b43legacy_pioqueue *queue;\r\nstruct b43legacy_pio_txpacket *packet;\r\nstruct ieee80211_tx_info *info;\r\nint retry_limit;\r\nqueue = parse_cookie(dev, status->cookie, &packet);\r\nB43legacy_WARN_ON(!queue);\r\nif (!packet->skb)\r\nreturn;\r\nqueue->tx_devq_packets--;\r\nqueue->tx_devq_used -= (packet->skb->len +\r\nsizeof(struct b43legacy_txhdr_fw3));\r\ninfo = IEEE80211_SKB_CB(packet->skb);\r\nretry_limit = info->status.rates[0].count;\r\nieee80211_tx_info_clear_status(info);\r\nif (status->acked)\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\nif (status->rts_count > dev->wl->hw->conf.short_frame_max_tx_count) {\r\ninfo->status.rates[0].count = 0;\r\ninfo->status.rates[1].count = status->frame_count;\r\n} else {\r\nif (status->frame_count > retry_limit) {\r\ninfo->status.rates[0].count = retry_limit;\r\ninfo->status.rates[1].count = status->frame_count -\r\nretry_limit;\r\n} else {\r\ninfo->status.rates[0].count = status->frame_count;\r\ninfo->status.rates[1].idx = -1;\r\n}\r\n}\r\nieee80211_tx_status_irqsafe(dev->wl->hw, packet->skb);\r\npacket->skb = NULL;\r\nfree_txpacket(packet, 1);\r\nif (!list_empty(&queue->txqueue))\r\ntasklet_schedule(&queue->txtask);\r\n}\r\nstatic void pio_rx_error(struct b43legacy_pioqueue *queue,\r\nint clear_buffers,\r\nconst char *error)\r\n{\r\nint i;\r\nb43legacyerr(queue->dev->wl, "PIO RX error: %s\n", error);\r\nb43legacy_pio_write(queue, B43legacy_PIO_RXCTL,\r\nB43legacy_PIO_RXCTL_READY);\r\nif (clear_buffers) {\r\nB43legacy_WARN_ON(queue->mmio_base != B43legacy_MMIO_PIO1_BASE);\r\nfor (i = 0; i < 15; i++) {\r\nb43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\r\n}\r\n}\r\n}\r\nvoid b43legacy_pio_rx(struct b43legacy_pioqueue *queue)\r\n{\r\n__le16 preamble[21] = { 0 };\r\nstruct b43legacy_rxhdr_fw3 *rxhdr;\r\nu16 tmp;\r\nu16 len;\r\nu16 macstat;\r\nint i;\r\nint preamble_readwords;\r\nstruct sk_buff *skb;\r\ntmp = b43legacy_pio_read(queue, B43legacy_PIO_RXCTL);\r\nif (!(tmp & B43legacy_PIO_RXCTL_DATAAVAILABLE))\r\nreturn;\r\nb43legacy_pio_write(queue, B43legacy_PIO_RXCTL,\r\nB43legacy_PIO_RXCTL_DATAAVAILABLE);\r\nfor (i = 0; i < 10; i++) {\r\ntmp = b43legacy_pio_read(queue, B43legacy_PIO_RXCTL);\r\nif (tmp & B43legacy_PIO_RXCTL_READY)\r\ngoto data_ready;\r\nudelay(10);\r\n}\r\nb43legacydbg(queue->dev->wl, "PIO RX timed out\n");\r\nreturn;\r\ndata_ready:\r\nlen = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\r\nif (unlikely(len > 0x700)) {\r\npio_rx_error(queue, 0, "len > 0x700");\r\nreturn;\r\n}\r\nif (unlikely(len == 0 && queue->mmio_base !=\r\nB43legacy_MMIO_PIO4_BASE)) {\r\npio_rx_error(queue, 0, "len == 0");\r\nreturn;\r\n}\r\npreamble[0] = cpu_to_le16(len);\r\nif (queue->mmio_base == B43legacy_MMIO_PIO4_BASE)\r\npreamble_readwords = 14 / sizeof(u16);\r\nelse\r\npreamble_readwords = 18 / sizeof(u16);\r\nfor (i = 0; i < preamble_readwords; i++) {\r\ntmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\r\npreamble[i + 1] = cpu_to_le16(tmp);\r\n}\r\nrxhdr = (struct b43legacy_rxhdr_fw3 *)preamble;\r\nmacstat = le16_to_cpu(rxhdr->mac_status);\r\nif (macstat & B43legacy_RX_MAC_FCSERR) {\r\npio_rx_error(queue,\r\n(queue->mmio_base == B43legacy_MMIO_PIO1_BASE),\r\n"Frame FCS error");\r\nreturn;\r\n}\r\nif (queue->mmio_base == B43legacy_MMIO_PIO4_BASE) {\r\nstruct b43legacy_hwtxstatus *hw;\r\nhw = (struct b43legacy_hwtxstatus *)(preamble + 1);\r\nb43legacy_handle_hwtxstatus(queue->dev, hw);\r\nreturn;\r\n}\r\nskb = dev_alloc_skb(len);\r\nif (unlikely(!skb)) {\r\npio_rx_error(queue, 1, "OOM");\r\nreturn;\r\n}\r\nskb_put(skb, len);\r\nfor (i = 0; i < len - 1; i += 2) {\r\ntmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\r\n*((__le16 *)(skb->data + i)) = cpu_to_le16(tmp);\r\n}\r\nif (len % 2) {\r\ntmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\r\nskb->data[len - 1] = (tmp & 0x00FF);\r\n}\r\nb43legacy_rx(queue->dev, skb, rxhdr);\r\n}\r\nvoid b43legacy_pio_tx_suspend(struct b43legacy_pioqueue *queue)\r\n{\r\nb43legacy_power_saving_ctl_bits(queue->dev, -1, 1);\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nb43legacy_pio_read(queue, B43legacy_PIO_TXCTL)\r\n| B43legacy_PIO_TXCTL_SUSPEND);\r\n}\r\nvoid b43legacy_pio_tx_resume(struct b43legacy_pioqueue *queue)\r\n{\r\nb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\r\nb43legacy_pio_read(queue, B43legacy_PIO_TXCTL)\r\n& ~B43legacy_PIO_TXCTL_SUSPEND);\r\nb43legacy_power_saving_ctl_bits(queue->dev, -1, -1);\r\ntasklet_schedule(&queue->txtask);\r\n}\r\nvoid b43legacy_pio_freeze_txqueues(struct b43legacy_wldev *dev)\r\n{\r\nstruct b43legacy_pio *pio;\r\nB43legacy_WARN_ON(!b43legacy_using_pio(dev));\r\npio = &dev->pio;\r\npio->queue0->tx_frozen = 1;\r\npio->queue1->tx_frozen = 1;\r\npio->queue2->tx_frozen = 1;\r\npio->queue3->tx_frozen = 1;\r\n}\r\nvoid b43legacy_pio_thaw_txqueues(struct b43legacy_wldev *dev)\r\n{\r\nstruct b43legacy_pio *pio;\r\nB43legacy_WARN_ON(!b43legacy_using_pio(dev));\r\npio = &dev->pio;\r\npio->queue0->tx_frozen = 0;\r\npio->queue1->tx_frozen = 0;\r\npio->queue2->tx_frozen = 0;\r\npio->queue3->tx_frozen = 0;\r\nif (!list_empty(&pio->queue0->txqueue))\r\ntasklet_schedule(&pio->queue0->txtask);\r\nif (!list_empty(&pio->queue1->txqueue))\r\ntasklet_schedule(&pio->queue1->txtask);\r\nif (!list_empty(&pio->queue2->txqueue))\r\ntasklet_schedule(&pio->queue2->txtask);\r\nif (!list_empty(&pio->queue3->txqueue))\r\ntasklet_schedule(&pio->queue3->txtask);\r\n}
