static int write_reg(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int write_regs(struct i2c_client *client, u8 *regs)\r\n{\r\nint i;\r\nfor (i = 0; regs[i] != 0x00; i += 2)\r\nif (i2c_smbus_write_byte_data(client, regs[i], regs[i + 1]) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int wis_saa7113_command(struct i2c_client *client,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct wis_saa7113 *dec = i2c_get_clientdata(client);\r\nswitch (cmd) {\r\ncase VIDIOC_S_INPUT:\r\n{\r\nint *input = arg;\r\ni2c_smbus_write_byte_data(client, 0x02, 0xC0 | *input);\r\ni2c_smbus_write_byte_data(client, 0x09,\r\n*input < 6 ? 0x40 : 0x80);\r\nbreak;\r\n}\r\ncase VIDIOC_S_STD:\r\n{\r\nv4l2_std_id *input = arg;\r\ndec->norm = *input;\r\nif (dec->norm & V4L2_STD_NTSC) {\r\nwrite_reg(client, 0x0e, 0x01);\r\nwrite_reg(client, 0x10, 0x40);\r\n} else if (dec->norm & V4L2_STD_PAL) {\r\nwrite_reg(client, 0x0e, 0x01);\r\nwrite_reg(client, 0x10, 0x48);\r\n} else if (dec->norm * V4L2_STD_SECAM) {\r\nwrite_reg(client, 0x0e, 0x50);\r\nwrite_reg(client, 0x10, 0x48);\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYCTRL:\r\n{\r\nstruct v4l2_queryctrl *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Brightness", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 255;\r\nctrl->step = 1;\r\nctrl->default_value = 128;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Contrast", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 71;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Saturation", sizeof(ctrl->name));\r\nctrl->minimum = 0;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 64;\r\nctrl->flags = 0;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrncpy(ctrl->name, "Hue", sizeof(ctrl->name));\r\nctrl->minimum = -128;\r\nctrl->maximum = 127;\r\nctrl->step = 1;\r\nctrl->default_value = 0;\r\nctrl->flags = 0;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nif (ctrl->value > 255)\r\ndec->brightness = 255;\r\nelse if (ctrl->value < 0)\r\ndec->brightness = 0;\r\nelse\r\ndec->brightness = ctrl->value;\r\nwrite_reg(client, 0x0a, dec->brightness);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nif (ctrl->value > 127)\r\ndec->contrast = 127;\r\nelse if (ctrl->value < 0)\r\ndec->contrast = 0;\r\nelse\r\ndec->contrast = ctrl->value;\r\nwrite_reg(client, 0x0b, dec->contrast);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nif (ctrl->value > 127)\r\ndec->saturation = 127;\r\nelse if (ctrl->value < 0)\r\ndec->saturation = 0;\r\nelse\r\ndec->saturation = ctrl->value;\r\nwrite_reg(client, 0x0c, dec->saturation);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nif (ctrl->value > 127)\r\ndec->hue = 127;\r\nelse if (ctrl->value < -128)\r\ndec->hue = -128;\r\nelse\r\ndec->hue = ctrl->value;\r\nwrite_reg(client, 0x0d, dec->hue);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = dec->brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->value = dec->contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->value = dec->saturation;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->value = dec->hue;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_saa7113_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct wis_saa7113 *dec;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndec = kmalloc(sizeof(struct wis_saa7113), GFP_KERNEL);\r\nif (dec == NULL)\r\nreturn -ENOMEM;\r\ndec->norm = V4L2_STD_NTSC;\r\ndec->brightness = 128;\r\ndec->contrast = 71;\r\ndec->saturation = 64;\r\ndec->hue = 0;\r\ni2c_set_clientdata(client, dec);\r\nprintk(KERN_DEBUG\r\n"wis-saa7113: initializing SAA7113 at address %d on %s\n",\r\nclient->addr, adapter->name);\r\nif (write_regs(client, initial_registers) < 0) {\r\nprintk(KERN_ERR\r\n"wis-saa7113: error initializing SAA7113\n");\r\nkfree(dec);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_saa7113_remove(struct i2c_client *client)\r\n{\r\nstruct wis_saa7113 *dec = i2c_get_clientdata(client);\r\nkfree(dec);\r\nreturn 0;\r\n}\r\nstatic int __init wis_saa7113_init(void)\r\n{\r\nreturn i2c_add_driver(&wis_saa7113_driver);\r\n}\r\nstatic void __exit wis_saa7113_cleanup(void)\r\n{\r\ni2c_del_driver(&wis_saa7113_driver);\r\n}
