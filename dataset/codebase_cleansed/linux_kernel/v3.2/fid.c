int v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\r\n{\r\nstruct v9fs_dentry *dent;\r\nP9_DPRINTK(P9_DEBUG_VFS, "fid %d dentry %s\n",\r\nfid->fid, dentry->d_name.name);\r\ndent = dentry->d_fsdata;\r\nif (!dent) {\r\ndent = kmalloc(sizeof(struct v9fs_dentry), GFP_KERNEL);\r\nif (!dent)\r\nreturn -ENOMEM;\r\nspin_lock_init(&dent->lock);\r\nINIT_LIST_HEAD(&dent->fidlist);\r\ndentry->d_fsdata = dent;\r\n}\r\nspin_lock(&dent->lock);\r\nlist_add(&fid->dlist, &dent->fidlist);\r\nspin_unlock(&dent->lock);\r\nreturn 0;\r\n}\r\nstatic struct p9_fid *v9fs_fid_find(struct dentry *dentry, u32 uid, int any)\r\n{\r\nstruct v9fs_dentry *dent;\r\nstruct p9_fid *fid, *ret;\r\nP9_DPRINTK(P9_DEBUG_VFS, " dentry: %s (%p) uid %d any %d\n",\r\ndentry->d_name.name, dentry, uid, any);\r\ndent = (struct v9fs_dentry *) dentry->d_fsdata;\r\nret = NULL;\r\nif (dent) {\r\nspin_lock(&dent->lock);\r\nlist_for_each_entry(fid, &dent->fidlist, dlist) {\r\nif (any || fid->uid == uid) {\r\nret = fid;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dent->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int build_path_from_dentry(struct v9fs_session_info *v9ses,\r\nstruct dentry *dentry, char ***names)\r\n{\r\nint n = 0, i;\r\nchar **wnames;\r\nstruct dentry *ds;\r\nfor (ds = dentry; !IS_ROOT(ds); ds = ds->d_parent)\r\nn++;\r\nwnames = kmalloc(sizeof(char *) * n, GFP_KERNEL);\r\nif (!wnames)\r\ngoto err_out;\r\nfor (ds = dentry, i = (n-1); i >= 0; i--, ds = ds->d_parent)\r\nwnames[i] = (char *)ds->d_name.name;\r\n*names = wnames;\r\nreturn n;\r\nerr_out:\r\nreturn -ENOMEM;\r\n}\r\nstatic struct p9_fid *v9fs_fid_lookup_with_uid(struct dentry *dentry,\r\nuid_t uid, int any)\r\n{\r\nstruct dentry *ds;\r\nchar **wnames, *uname;\r\nint i, n, l, clone, access;\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid, *old_fid = NULL;\r\nv9ses = v9fs_dentry2v9ses(dentry);\r\naccess = v9ses->flags & V9FS_ACCESS_MASK;\r\nfid = v9fs_fid_find(dentry, uid, any);\r\nif (fid)\r\nreturn fid;\r\ndown_read(&v9ses->rename_sem);\r\nds = dentry->d_parent;\r\nfid = v9fs_fid_find(ds, uid, any);\r\nif (fid) {\r\nfid = p9_client_walk(fid, 1, (char **)&dentry->d_name.name, 1);\r\ngoto fid_out;\r\n}\r\nup_read(&v9ses->rename_sem);\r\nfid = v9fs_fid_find(dentry->d_sb->s_root, uid, any);\r\nif (!fid) {\r\nif (access == V9FS_ACCESS_SINGLE)\r\nreturn ERR_PTR(-EPERM);\r\nif (v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses))\r\nuname = NULL;\r\nelse\r\nuname = v9ses->uname;\r\nfid = p9_client_attach(v9ses->clnt, NULL, uname, uid,\r\nv9ses->aname);\r\nif (IS_ERR(fid))\r\nreturn fid;\r\nv9fs_fid_add(dentry->d_sb->s_root, fid);\r\n}\r\nif (dentry->d_sb->s_root == dentry)\r\nreturn fid;\r\ndown_read(&v9ses->rename_sem);\r\nn = build_path_from_dentry(v9ses, dentry, &wnames);\r\nif (n < 0) {\r\nfid = ERR_PTR(n);\r\ngoto err_out;\r\n}\r\nclone = 1;\r\ni = 0;\r\nwhile (i < n) {\r\nl = min(n - i, P9_MAXWELEM);\r\nfid = p9_client_walk(fid, l, &wnames[i], clone);\r\nif (IS_ERR(fid)) {\r\nif (old_fid) {\r\np9_client_clunk(old_fid);\r\n}\r\nkfree(wnames);\r\ngoto err_out;\r\n}\r\nold_fid = fid;\r\ni += l;\r\nclone = 0;\r\n}\r\nkfree(wnames);\r\nfid_out:\r\nif (!IS_ERR(fid))\r\nv9fs_fid_add(dentry, fid);\r\nerr_out:\r\nup_read(&v9ses->rename_sem);\r\nreturn fid;\r\n}\r\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\r\n{\r\nuid_t uid;\r\nint any, access;\r\nstruct v9fs_session_info *v9ses;\r\nv9ses = v9fs_dentry2v9ses(dentry);\r\naccess = v9ses->flags & V9FS_ACCESS_MASK;\r\nswitch (access) {\r\ncase V9FS_ACCESS_SINGLE:\r\ncase V9FS_ACCESS_USER:\r\ncase V9FS_ACCESS_CLIENT:\r\nuid = current_fsuid();\r\nany = 0;\r\nbreak;\r\ncase V9FS_ACCESS_ANY:\r\nuid = v9ses->uid;\r\nany = 1;\r\nbreak;\r\ndefault:\r\nuid = ~0;\r\nany = 0;\r\nbreak;\r\n}\r\nreturn v9fs_fid_lookup_with_uid(dentry, uid, any);\r\n}\r\nstruct p9_fid *v9fs_fid_clone(struct dentry *dentry)\r\n{\r\nstruct p9_fid *fid, *ret;\r\nfid = v9fs_fid_lookup(dentry);\r\nif (IS_ERR(fid))\r\nreturn fid;\r\nret = p9_client_walk(fid, 0, NULL, 1);\r\nreturn ret;\r\n}\r\nstatic struct p9_fid *v9fs_fid_clone_with_uid(struct dentry *dentry, uid_t uid)\r\n{\r\nstruct p9_fid *fid, *ret;\r\nfid = v9fs_fid_lookup_with_uid(dentry, uid, 0);\r\nif (IS_ERR(fid))\r\nreturn fid;\r\nret = p9_client_walk(fid, 0, NULL, 1);\r\nreturn ret;\r\n}\r\nstruct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\r\n{\r\nint err;\r\nstruct p9_fid *fid;\r\nfid = v9fs_fid_clone_with_uid(dentry, 0);\r\nif (IS_ERR(fid))\r\ngoto error_out;\r\nerr = p9_client_open(fid, O_RDWR);\r\nif (err < 0) {\r\np9_client_clunk(fid);\r\nfid = ERR_PTR(err);\r\ngoto error_out;\r\n}\r\nerror_out:\r\nreturn fid;\r\n}
