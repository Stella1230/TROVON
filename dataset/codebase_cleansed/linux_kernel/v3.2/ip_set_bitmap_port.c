static int\r\nbitmap_port_test(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nconst struct bitmap_port *map = set->data;\r\nu16 id = *(u16 *)value;\r\nreturn !!test_bit(id, map->members);\r\n}\r\nstatic int\r\nbitmap_port_add(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nu16 id = *(u16 *)value;\r\nif (test_and_set_bit(id, map->members))\r\nreturn -IPSET_ERR_EXIST;\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_port_del(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nu16 id = *(u16 *)value;\r\nif (!test_and_clear_bit(id, map->members))\r\nreturn -IPSET_ERR_EXIST;\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_port_list(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct bitmap_port *map = set->data;\r\nstruct nlattr *atd, *nested;\r\nu16 id, first = cb->args[2];\r\nu16 last = map->last_port - map->first_port;\r\natd = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!atd)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[2] <= last; cb->args[2]++) {\r\nid = cb->args[2];\r\nif (!test_bit(id, map->members))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (id == first) {\r\nnla_nest_cancel(skb, atd);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT,\r\nhtons(map->first_port + id));\r\nipset_nest_end(skb, nested);\r\n}\r\nipset_nest_end(skb, atd);\r\ncb->args[2] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nipset_nest_end(skb, atd);\r\nif (unlikely(id == first)) {\r\ncb->args[2] = 0;\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_port_ttest(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nconst struct bitmap_port *map = set->data;\r\nconst unsigned long *members = map->members;\r\nu16 id = *(u16 *)value;\r\nreturn ip_set_timeout_test(members[id]);\r\n}\r\nstatic int\r\nbitmap_port_tadd(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nunsigned long *members = map->members;\r\nu16 id = *(u16 *)value;\r\nif (ip_set_timeout_test(members[id]) && !(flags & IPSET_FLAG_EXIST))\r\nreturn -IPSET_ERR_EXIST;\r\nmembers[id] = ip_set_timeout_set(timeout);\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_port_tdel(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nunsigned long *members = map->members;\r\nu16 id = *(u16 *)value;\r\nint ret = -IPSET_ERR_EXIST;\r\nif (ip_set_timeout_test(members[id]))\r\nret = 0;\r\nmembers[id] = IPSET_ELEM_UNSET;\r\nreturn ret;\r\n}\r\nstatic int\r\nbitmap_port_tlist(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct bitmap_port *map = set->data;\r\nstruct nlattr *adt, *nested;\r\nu16 id, first = cb->args[2];\r\nu16 last = map->last_port - map->first_port;\r\nconst unsigned long *members = map->members;\r\nadt = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!adt)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[2] <= last; cb->args[2]++) {\r\nid = cb->args[2];\r\nif (!ip_set_timeout_test(members[id]))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (id == first) {\r\nnla_nest_cancel(skb, adt);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT,\r\nhtons(map->first_port + id));\r\nNLA_PUT_NET32(skb, IPSET_ATTR_TIMEOUT,\r\nhtonl(ip_set_timeout_get(members[id])));\r\nipset_nest_end(skb, nested);\r\n}\r\nipset_nest_end(skb, adt);\r\ncb->args[2] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nipset_nest_end(skb, adt);\r\nif (unlikely(id == first)) {\r\ncb->args[2] = 0;\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_port_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\n__be16 __port;\r\nu16 port = 0;\r\nif (!ip_set_get_ip_port(skb, opt->family,\r\nopt->flags & IPSET_DIM_ONE_SRC, &__port))\r\nreturn -EINVAL;\r\nport = ntohs(__port);\r\nif (port < map->first_port || port > map->last_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nport -= map->first_port;\r\nreturn adtfn(set, &port, opt_timeout(opt, map), opt->cmdflags);\r\n}\r\nstatic int\r\nbitmap_port_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nu32 timeout = map->timeout;\r\nu32 port;\r\nu16 id, port_to;\r\nint ret = 0;\r\nif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nport = ip_set_get_h16(tb[IPSET_ATTR_PORT]);\r\nif (port < map->first_port || port > map->last_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout(map->timeout))\r\nreturn -IPSET_ERR_TIMEOUT;\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nif (adt == IPSET_TEST) {\r\nid = port - map->first_port;\r\nreturn adtfn(set, &id, timeout, flags);\r\n}\r\nif (tb[IPSET_ATTR_PORT_TO]) {\r\nport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (port > port_to) {\r\nswap(port, port_to);\r\nif (port < map->first_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\n}\r\n} else\r\nport_to = port;\r\nif (port_to > map->last_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nfor (; port <= port_to; port++) {\r\nid = port - map->first_port;\r\nret = adtfn(set, &id, timeout, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nelse\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nbitmap_port_destroy(struct ip_set *set)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nif (with_timeout(map->timeout))\r\ndel_timer_sync(&map->gc);\r\nip_set_free(map->members);\r\nkfree(map);\r\nset->data = NULL;\r\n}\r\nstatic void\r\nbitmap_port_flush(struct ip_set *set)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nmemset(map->members, 0, map->memsize);\r\n}\r\nstatic int\r\nbitmap_port_head(struct ip_set *set, struct sk_buff *skb)\r\n{\r\nconst struct bitmap_port *map = set->data;\r\nstruct nlattr *nested;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested)\r\ngoto nla_put_failure;\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT, htons(map->first_port));\r\nNLA_PUT_NET16(skb, IPSET_ATTR_PORT_TO, htons(map->last_port));\r\nNLA_PUT_NET32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1));\r\nNLA_PUT_NET32(skb, IPSET_ATTR_MEMSIZE,\r\nhtonl(sizeof(*map) + map->memsize));\r\nif (with_timeout(map->timeout))\r\nNLA_PUT_NET32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout));\r\nipset_nest_end(skb, nested);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic bool\r\nbitmap_port_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct bitmap_port *x = a->data;\r\nconst struct bitmap_port *y = b->data;\r\nreturn x->first_port == y->first_port &&\r\nx->last_port == y->last_port &&\r\nx->timeout == y->timeout;\r\n}\r\nstatic void\r\nbitmap_port_gc(unsigned long ul_set)\r\n{\r\nstruct ip_set *set = (struct ip_set *) ul_set;\r\nstruct bitmap_port *map = set->data;\r\nunsigned long *table = map->members;\r\nu32 id;\r\nu16 last = map->last_port - map->first_port;\r\nread_lock_bh(&set->lock);\r\nfor (id = 0; id <= last; id++)\r\nif (ip_set_timeout_expired(table[id]))\r\ntable[id] = IPSET_ELEM_UNSET;\r\nread_unlock_bh(&set->lock);\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic void\r\nbitmap_port_gc_init(struct ip_set *set)\r\n{\r\nstruct bitmap_port *map = set->data;\r\ninit_timer(&map->gc);\r\nmap->gc.data = (unsigned long) set;\r\nmap->gc.function = bitmap_port_gc;\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic bool\r\ninit_map_port(struct ip_set *set, struct bitmap_port *map,\r\nu16 first_port, u16 last_port)\r\n{\r\nmap->members = ip_set_alloc(map->memsize);\r\nif (!map->members)\r\nreturn false;\r\nmap->first_port = first_port;\r\nmap->last_port = last_port;\r\nmap->timeout = IPSET_NO_TIMEOUT;\r\nset->data = map;\r\nset->family = AF_UNSPEC;\r\nreturn true;\r\n}\r\nstatic int\r\nbitmap_port_create(struct ip_set *set, struct nlattr *tb[],\r\nu32 flags)\r\n{\r\nstruct bitmap_port *map;\r\nu16 first_port, last_port;\r\nif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_attr_netorder(tb, IPSET_ATTR_PORT_TO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nfirst_port = ip_set_get_h16(tb[IPSET_ATTR_PORT]);\r\nlast_port = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (first_port > last_port) {\r\nu16 tmp = first_port;\r\nfirst_port = last_port;\r\nlast_port = tmp;\r\n}\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nmap->memsize = (last_port - first_port + 1)\r\n* sizeof(unsigned long);\r\nif (!init_map_port(set, map, first_port, last_port)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nmap->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nset->variant = &bitmap_tport;\r\nbitmap_port_gc_init(set);\r\n} else {\r\nmap->memsize = bitmap_bytes(0, last_port - first_port);\r\npr_debug("memsize: %zu\n", map->memsize);\r\nif (!init_map_port(set, map, first_port, last_port)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nset->variant = &bitmap_port;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nbitmap_port_init(void)\r\n{\r\nreturn ip_set_type_register(&bitmap_port_type);\r\n}\r\nstatic void __exit\r\nbitmap_port_fini(void)\r\n{\r\nip_set_type_unregister(&bitmap_port_type);\r\n}
