static u32 get_longbusy_msecs(int longbusy_rc)\r\n{\r\nswitch (longbusy_rc) {\r\ncase H_LONG_BUSY_ORDER_1_MSEC:\r\nreturn 1;\r\ncase H_LONG_BUSY_ORDER_10_MSEC:\r\nreturn 10;\r\ncase H_LONG_BUSY_ORDER_100_MSEC:\r\nreturn 100;\r\ncase H_LONG_BUSY_ORDER_1_SEC:\r\nreturn 1000;\r\ncase H_LONG_BUSY_ORDER_10_SEC:\r\nreturn 10000;\r\ncase H_LONG_BUSY_ORDER_100_SEC:\r\nreturn 100000;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic long ehca_plpar_hcall_norets(unsigned long opcode,\r\nunsigned long arg1,\r\nunsigned long arg2,\r\nunsigned long arg3,\r\nunsigned long arg4,\r\nunsigned long arg5,\r\nunsigned long arg6,\r\nunsigned long arg7)\r\n{\r\nlong ret;\r\nint i, sleep_msecs;\r\nunsigned long flags = 0;\r\nif (unlikely(ehca_debug_level >= 2))\r\nehca_gen_dbg("opcode=%lx " HCALL7_REGS_FORMAT,\r\nopcode, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\r\nfor (i = 0; i < 5; i++) {\r\nif (ehca_lock_hcalls)\r\nspin_lock_irqsave(&hcall_lock, flags);\r\nret = plpar_hcall_norets(opcode, arg1, arg2, arg3, arg4,\r\narg5, arg6, arg7);\r\nif (ehca_lock_hcalls)\r\nspin_unlock_irqrestore(&hcall_lock, flags);\r\nif (H_IS_LONG_BUSY(ret)) {\r\nsleep_msecs = get_longbusy_msecs(ret);\r\nmsleep_interruptible(sleep_msecs);\r\ncontinue;\r\n}\r\nif (ret < H_SUCCESS)\r\nehca_gen_err("opcode=%lx ret=%li " HCALL7_REGS_FORMAT,\r\nopcode, ret, arg1, arg2, arg3,\r\narg4, arg5, arg6, arg7);\r\nelse\r\nif (unlikely(ehca_debug_level >= 2))\r\nehca_gen_dbg("opcode=%lx ret=%li", opcode, ret);\r\nreturn ret;\r\n}\r\nreturn H_BUSY;\r\n}\r\nstatic long ehca_plpar_hcall9(unsigned long opcode,\r\nunsigned long *outs,\r\nunsigned long arg1,\r\nunsigned long arg2,\r\nunsigned long arg3,\r\nunsigned long arg4,\r\nunsigned long arg5,\r\nunsigned long arg6,\r\nunsigned long arg7,\r\nunsigned long arg8,\r\nunsigned long arg9)\r\n{\r\nlong ret;\r\nint i, sleep_msecs;\r\nunsigned long flags = 0;\r\nif (unlikely(ehca_debug_level >= 2))\r\nehca_gen_dbg("INPUT -- opcode=%lx " HCALL9_REGS_FORMAT, opcode,\r\narg1, arg2, arg3, arg4, arg5,\r\narg6, arg7, arg8, arg9);\r\nfor (i = 0; i < 5; i++) {\r\nif (ehca_lock_hcalls)\r\nspin_lock_irqsave(&hcall_lock, flags);\r\nret = plpar_hcall9(opcode, outs,\r\narg1, arg2, arg3, arg4, arg5,\r\narg6, arg7, arg8, arg9);\r\nif (ehca_lock_hcalls)\r\nspin_unlock_irqrestore(&hcall_lock, flags);\r\nif (H_IS_LONG_BUSY(ret)) {\r\nsleep_msecs = get_longbusy_msecs(ret);\r\nmsleep_interruptible(sleep_msecs);\r\ncontinue;\r\n}\r\nif (ret < H_SUCCESS) {\r\nehca_gen_err("INPUT -- opcode=%lx " HCALL9_REGS_FORMAT,\r\nopcode, arg1, arg2, arg3, arg4, arg5,\r\narg6, arg7, arg8, arg9);\r\nehca_gen_err("OUTPUT -- ret=%li " HCALL9_REGS_FORMAT,\r\nret, outs[0], outs[1], outs[2], outs[3],\r\nouts[4], outs[5], outs[6], outs[7],\r\nouts[8]);\r\n} else if (unlikely(ehca_debug_level >= 2))\r\nehca_gen_dbg("OUTPUT -- ret=%li " HCALL9_REGS_FORMAT,\r\nret, outs[0], outs[1], outs[2], outs[3],\r\nouts[4], outs[5], outs[6], outs[7],\r\nouts[8]);\r\nreturn ret;\r\n}\r\nreturn H_BUSY;\r\n}\r\nu64 hipz_h_alloc_resource_eq(const struct ipz_adapter_handle adapter_handle,\r\nstruct ehca_pfeq *pfeq,\r\nconst u32 neq_control,\r\nconst u32 number_of_entries,\r\nstruct ipz_eq_handle *eq_handle,\r\nu32 *act_nr_of_entries,\r\nu32 *act_pages,\r\nu32 *eq_ist)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nu64 allocate_controls;\r\nallocate_controls = 3ULL;\r\nif (neq_control != 1)\r\nallocate_controls = (1ULL << (63 - 7)) | allocate_controls;\r\nelse\r\nallocate_controls = (1ULL << 63) | allocate_controls;\r\nret = ehca_plpar_hcall9(H_ALLOC_RESOURCE, outs,\r\nadapter_handle.handle,\r\nallocate_controls,\r\nnumber_of_entries,\r\n0, 0, 0, 0, 0, 0);\r\neq_handle->handle = outs[0];\r\n*act_nr_of_entries = (u32)outs[3];\r\n*act_pages = (u32)outs[4];\r\n*eq_ist = (u32)outs[5];\r\nif (ret == H_NOT_ENOUGH_RESOURCES)\r\nehca_gen_err("Not enough resource - ret=%lli ", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_reset_event(const struct ipz_adapter_handle adapter_handle,\r\nstruct ipz_eq_handle eq_handle,\r\nconst u64 event_mask)\r\n{\r\nreturn ehca_plpar_hcall_norets(H_RESET_EVENTS,\r\nadapter_handle.handle,\r\neq_handle.handle,\r\nevent_mask,\r\n0, 0, 0, 0);\r\n}\r\nu64 hipz_h_alloc_resource_cq(const struct ipz_adapter_handle adapter_handle,\r\nstruct ehca_cq *cq,\r\nstruct ehca_alloc_cq_parms *param)\r\n{\r\nint rc;\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_ALLOC_RESOURCE, outs,\r\nadapter_handle.handle,\r\n2,\r\nparam->eq_handle.handle,\r\ncq->token,\r\nparam->nr_cqe,\r\n0, 0, 0, 0);\r\ncq->ipz_cq_handle.handle = outs[0];\r\nparam->act_nr_of_entries = (u32)outs[3];\r\nparam->act_pages = (u32)outs[4];\r\nif (ret == H_SUCCESS) {\r\nrc = hcp_galpas_ctor(&cq->galpas, 0, outs[5], outs[6]);\r\nif (rc) {\r\nehca_gen_err("Could not establish HW access. rc=%d paddr=%#lx",\r\nrc, outs[5]);\r\nehca_plpar_hcall_norets(H_FREE_RESOURCE,\r\nadapter_handle.handle,\r\ncq->ipz_cq_handle.handle,\r\n0, 0, 0, 0, 0);\r\nret = H_NO_MEM;\r\n}\r\n}\r\nif (ret == H_NOT_ENOUGH_RESOURCES)\r\nehca_gen_err("Not enough resources. ret=%lli", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_alloc_resource_qp(const struct ipz_adapter_handle adapter_handle,\r\nstruct ehca_alloc_qp_parms *parms, int is_user)\r\n{\r\nint rc;\r\nu64 ret;\r\nu64 allocate_controls, max_r10_reg, r11, r12;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nallocate_controls =\r\nEHCA_BMASK_SET(H_ALL_RES_QP_ENHANCED_OPS, parms->ext_type)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_PTE_PIN, 0)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_SERVICE_TYPE, parms->servicetype)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_SIGNALING_TYPE, parms->sigtype)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_STORAGE, parms->qp_storage)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_SMALL_SQ_PAGE_SIZE,\r\nparms->squeue.page_size)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_SMALL_RQ_PAGE_SIZE,\r\nparms->rqueue.page_size)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_LL_RQ_CQE_POSTING,\r\n!!(parms->ll_comp_flags & LLQP_RECV_COMP))\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_LL_SQ_CQE_POSTING,\r\n!!(parms->ll_comp_flags & LLQP_SEND_COMP))\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_UD_AV_LKEY_CTRL,\r\nparms->ud_av_l_key_ctl)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_RESOURCE_TYPE, 1);\r\nmax_r10_reg =\r\nEHCA_BMASK_SET(H_ALL_RES_QP_MAX_OUTST_SEND_WR,\r\nparms->squeue.max_wr + 1)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_MAX_OUTST_RECV_WR,\r\nparms->rqueue.max_wr + 1)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_MAX_SEND_SGE,\r\nparms->squeue.max_sge)\r\n| EHCA_BMASK_SET(H_ALL_RES_QP_MAX_RECV_SGE,\r\nparms->rqueue.max_sge);\r\nr11 = EHCA_BMASK_SET(H_ALL_RES_QP_SRQ_QP_TOKEN, parms->srq_token);\r\nif (parms->ext_type == EQPT_SRQ)\r\nr12 = EHCA_BMASK_SET(H_ALL_RES_QP_SRQ_LIMIT, parms->srq_limit);\r\nelse\r\nr12 = EHCA_BMASK_SET(H_ALL_RES_QP_SRQ_QPN, parms->srq_qpn);\r\nret = ehca_plpar_hcall9(H_ALLOC_RESOURCE, outs,\r\nadapter_handle.handle,\r\nallocate_controls,\r\nparms->send_cq_handle.handle,\r\nparms->recv_cq_handle.handle,\r\nparms->eq_handle.handle,\r\n((u64)parms->token << 32) | parms->pd.value,\r\nmax_r10_reg, r11, r12);\r\nparms->qp_handle.handle = outs[0];\r\nparms->real_qp_num = (u32)outs[1];\r\nparms->squeue.act_nr_wqes =\r\n(u16)EHCA_BMASK_GET(H_ALL_RES_QP_ACT_OUTST_SEND_WR, outs[2]);\r\nparms->rqueue.act_nr_wqes =\r\n(u16)EHCA_BMASK_GET(H_ALL_RES_QP_ACT_OUTST_RECV_WR, outs[2]);\r\nparms->squeue.act_nr_sges =\r\n(u8)EHCA_BMASK_GET(H_ALL_RES_QP_ACT_SEND_SGE, outs[3]);\r\nparms->rqueue.act_nr_sges =\r\n(u8)EHCA_BMASK_GET(H_ALL_RES_QP_ACT_RECV_SGE, outs[3]);\r\nparms->squeue.queue_size =\r\n(u32)EHCA_BMASK_GET(H_ALL_RES_QP_SQUEUE_SIZE_PAGES, outs[4]);\r\nparms->rqueue.queue_size =\r\n(u32)EHCA_BMASK_GET(H_ALL_RES_QP_RQUEUE_SIZE_PAGES, outs[4]);\r\nif (ret == H_SUCCESS) {\r\nrc = hcp_galpas_ctor(&parms->galpas, is_user, outs[6], outs[6]);\r\nif (rc) {\r\nehca_gen_err("Could not establish HW access. rc=%d paddr=%#lx",\r\nrc, outs[6]);\r\nehca_plpar_hcall_norets(H_FREE_RESOURCE,\r\nadapter_handle.handle,\r\nparms->qp_handle.handle,\r\n0, 0, 0, 0, 0);\r\nret = H_NO_MEM;\r\n}\r\n}\r\nif (ret == H_NOT_ENOUGH_RESOURCES)\r\nehca_gen_err("Not enough resources. ret=%lli", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_query_port(const struct ipz_adapter_handle adapter_handle,\r\nconst u8 port_id,\r\nstruct hipz_query_port *query_port_response_block)\r\n{\r\nu64 ret;\r\nu64 r_cb = virt_to_abs(query_port_response_block);\r\nif (r_cb & (EHCA_PAGESIZE-1)) {\r\nehca_gen_err("response block not page aligned");\r\nreturn H_PARAMETER;\r\n}\r\nret = ehca_plpar_hcall_norets(H_QUERY_PORT,\r\nadapter_handle.handle,\r\nport_id,\r\nr_cb,\r\n0, 0, 0, 0);\r\nif (ehca_debug_level >= 2)\r\nehca_dmp(query_port_response_block, 64, "response_block");\r\nreturn ret;\r\n}\r\nu64 hipz_h_modify_port(const struct ipz_adapter_handle adapter_handle,\r\nconst u8 port_id, const u32 port_cap,\r\nconst u8 init_type, const int modify_mask)\r\n{\r\nu64 port_attributes = port_cap;\r\nif (modify_mask & IB_PORT_SHUTDOWN)\r\nport_attributes |= EHCA_BMASK_SET(H_MP_SHUTDOWN, 1);\r\nif (modify_mask & IB_PORT_INIT_TYPE)\r\nport_attributes |= EHCA_BMASK_SET(H_MP_INIT_TYPE, init_type);\r\nif (modify_mask & IB_PORT_RESET_QKEY_CNTR)\r\nport_attributes |= EHCA_BMASK_SET(H_MP_RESET_QKEY_CTR, 1);\r\nreturn ehca_plpar_hcall_norets(H_MODIFY_PORT,\r\nadapter_handle.handle,\r\nport_id,\r\nport_attributes,\r\n0, 0, 0, 0);\r\n}\r\nu64 hipz_h_query_hca(const struct ipz_adapter_handle adapter_handle,\r\nstruct hipz_query_hca *query_hca_rblock)\r\n{\r\nu64 r_cb = virt_to_abs(query_hca_rblock);\r\nif (r_cb & (EHCA_PAGESIZE-1)) {\r\nehca_gen_err("response_block=%p not page aligned",\r\nquery_hca_rblock);\r\nreturn H_PARAMETER;\r\n}\r\nreturn ehca_plpar_hcall_norets(H_QUERY_HCA,\r\nadapter_handle.handle,\r\nr_cb,\r\n0, 0, 0, 0, 0);\r\n}\r\nu64 hipz_h_register_rpage(const struct ipz_adapter_handle adapter_handle,\r\nconst u8 pagesize,\r\nconst u8 queue_type,\r\nconst u64 resource_handle,\r\nconst u64 logical_address_of_page,\r\nu64 count)\r\n{\r\nreturn ehca_plpar_hcall_norets(H_REGISTER_RPAGES,\r\nadapter_handle.handle,\r\n(u64)queue_type | ((u64)pagesize) << 8,\r\nresource_handle,\r\nlogical_address_of_page,\r\ncount,\r\n0, 0);\r\n}\r\nu64 hipz_h_register_rpage_eq(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_eq_handle eq_handle,\r\nstruct ehca_pfeq *pfeq,\r\nconst u8 pagesize,\r\nconst u8 queue_type,\r\nconst u64 logical_address_of_page,\r\nconst u64 count)\r\n{\r\nif (count != 1) {\r\nehca_gen_err("Ppage counter=%llx", count);\r\nreturn H_PARAMETER;\r\n}\r\nreturn hipz_h_register_rpage(adapter_handle,\r\npagesize,\r\nqueue_type,\r\neq_handle.handle,\r\nlogical_address_of_page, count);\r\n}\r\nu64 hipz_h_query_int_state(const struct ipz_adapter_handle adapter_handle,\r\nu32 ist)\r\n{\r\nu64 ret;\r\nret = ehca_plpar_hcall_norets(H_QUERY_INT_STATE,\r\nadapter_handle.handle,\r\nist,\r\n0, 0, 0, 0, 0);\r\nif (ret != H_SUCCESS && ret != H_BUSY)\r\nehca_gen_err("Could not query interrupt state.");\r\nreturn ret;\r\n}\r\nu64 hipz_h_register_rpage_cq(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_cq_handle cq_handle,\r\nstruct ehca_pfcq *pfcq,\r\nconst u8 pagesize,\r\nconst u8 queue_type,\r\nconst u64 logical_address_of_page,\r\nconst u64 count,\r\nconst struct h_galpa gal)\r\n{\r\nif (count != 1) {\r\nehca_gen_err("Page counter=%llx", count);\r\nreturn H_PARAMETER;\r\n}\r\nreturn hipz_h_register_rpage(adapter_handle, pagesize, queue_type,\r\ncq_handle.handle, logical_address_of_page,\r\ncount);\r\n}\r\nu64 hipz_h_register_rpage_qp(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct ehca_pfqp *pfqp,\r\nconst u8 pagesize,\r\nconst u8 queue_type,\r\nconst u64 logical_address_of_page,\r\nconst u64 count,\r\nconst struct h_galpa galpa)\r\n{\r\nif (count > 1) {\r\nehca_gen_err("Page counter=%llx", count);\r\nreturn H_PARAMETER;\r\n}\r\nreturn hipz_h_register_rpage(adapter_handle, pagesize, queue_type,\r\nqp_handle.handle, logical_address_of_page,\r\ncount);\r\n}\r\nu64 hipz_h_disable_and_get_wqe(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct ehca_pfqp *pfqp,\r\nvoid **log_addr_next_sq_wqe2processed,\r\nvoid **log_addr_next_rq_wqe2processed,\r\nint dis_and_get_function_code)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_DISABLE_AND_GETC, outs,\r\nadapter_handle.handle,\r\ndis_and_get_function_code,\r\nqp_handle.handle,\r\n0, 0, 0, 0, 0, 0);\r\nif (log_addr_next_sq_wqe2processed)\r\n*log_addr_next_sq_wqe2processed = (void *)outs[0];\r\nif (log_addr_next_rq_wqe2processed)\r\n*log_addr_next_rq_wqe2processed = (void *)outs[1];\r\nreturn ret;\r\n}\r\nu64 hipz_h_modify_qp(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct ehca_pfqp *pfqp,\r\nconst u64 update_mask,\r\nstruct hcp_modify_qp_control_block *mqpcb,\r\nstruct h_galpa gal)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_MODIFY_QP, outs,\r\nadapter_handle.handle,\r\nqp_handle.handle,\r\nupdate_mask,\r\nvirt_to_abs(mqpcb),\r\n0, 0, 0, 0, 0);\r\nif (ret == H_NOT_ENOUGH_RESOURCES)\r\nehca_gen_err("Insufficient resources ret=%lli", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_query_qp(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct ehca_pfqp *pfqp,\r\nstruct hcp_modify_qp_control_block *qqpcb,\r\nstruct h_galpa gal)\r\n{\r\nreturn ehca_plpar_hcall_norets(H_QUERY_QP,\r\nadapter_handle.handle,\r\nqp_handle.handle,\r\nvirt_to_abs(qqpcb),\r\n0, 0, 0, 0);\r\n}\r\nu64 hipz_h_destroy_qp(const struct ipz_adapter_handle adapter_handle,\r\nstruct ehca_qp *qp)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = hcp_galpas_dtor(&qp->galpas);\r\nif (ret) {\r\nehca_gen_err("Could not destruct qp->galpas");\r\nreturn H_RESOURCE;\r\n}\r\nret = ehca_plpar_hcall9(H_DISABLE_AND_GETC, outs,\r\nadapter_handle.handle,\r\n1,\r\nqp->ipz_qp_handle.handle,\r\n0, 0, 0, 0, 0, 0);\r\nif (ret == H_HARDWARE)\r\nehca_gen_err("HCA not operational. ret=%lli", ret);\r\nret = ehca_plpar_hcall_norets(H_FREE_RESOURCE,\r\nadapter_handle.handle,\r\nqp->ipz_qp_handle.handle,\r\n0, 0, 0, 0, 0);\r\nif (ret == H_RESOURCE)\r\nehca_gen_err("Resource still in use. ret=%lli", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_define_aqp0(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct h_galpa gal,\r\nu32 port)\r\n{\r\nreturn ehca_plpar_hcall_norets(H_DEFINE_AQP0,\r\nadapter_handle.handle,\r\nqp_handle.handle,\r\nport,\r\n0, 0, 0, 0);\r\n}\r\nu64 hipz_h_define_aqp1(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct h_galpa gal,\r\nu32 port, u32 * pma_qp_nr,\r\nu32 * bma_qp_nr)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_DEFINE_AQP1, outs,\r\nadapter_handle.handle,\r\nqp_handle.handle,\r\nport,\r\n0, 0, 0, 0, 0, 0);\r\n*pma_qp_nr = (u32)outs[0];\r\n*bma_qp_nr = (u32)outs[1];\r\nif (ret == H_ALIAS_EXIST)\r\nehca_gen_err("AQP1 already exists. ret=%lli", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_attach_mcqp(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct h_galpa gal,\r\nu16 mcg_dlid,\r\nu64 subnet_prefix, u64 interface_id)\r\n{\r\nu64 ret;\r\nret = ehca_plpar_hcall_norets(H_ATTACH_MCQP,\r\nadapter_handle.handle,\r\nqp_handle.handle,\r\nmcg_dlid,\r\ninterface_id,\r\nsubnet_prefix,\r\n0, 0);\r\nif (ret == H_NOT_ENOUGH_RESOURCES)\r\nehca_gen_err("Not enough resources. ret=%lli", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_detach_mcqp(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ipz_qp_handle qp_handle,\r\nstruct h_galpa gal,\r\nu16 mcg_dlid,\r\nu64 subnet_prefix, u64 interface_id)\r\n{\r\nreturn ehca_plpar_hcall_norets(H_DETACH_MCQP,\r\nadapter_handle.handle,\r\nqp_handle.handle,\r\nmcg_dlid,\r\ninterface_id,\r\nsubnet_prefix,\r\n0, 0);\r\n}\r\nu64 hipz_h_destroy_cq(const struct ipz_adapter_handle adapter_handle,\r\nstruct ehca_cq *cq,\r\nu8 force_flag)\r\n{\r\nu64 ret;\r\nret = hcp_galpas_dtor(&cq->galpas);\r\nif (ret) {\r\nehca_gen_err("Could not destruct cp->galpas");\r\nreturn H_RESOURCE;\r\n}\r\nret = ehca_plpar_hcall_norets(H_FREE_RESOURCE,\r\nadapter_handle.handle,\r\ncq->ipz_cq_handle.handle,\r\nforce_flag != 0 ? 1L : 0L,\r\n0, 0, 0, 0);\r\nif (ret == H_RESOURCE)\r\nehca_gen_err("H_FREE_RESOURCE failed ret=%lli ", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_destroy_eq(const struct ipz_adapter_handle adapter_handle,\r\nstruct ehca_eq *eq)\r\n{\r\nu64 ret;\r\nret = hcp_galpas_dtor(&eq->galpas);\r\nif (ret) {\r\nehca_gen_err("Could not destruct eq->galpas");\r\nreturn H_RESOURCE;\r\n}\r\nret = ehca_plpar_hcall_norets(H_FREE_RESOURCE,\r\nadapter_handle.handle,\r\neq->ipz_eq_handle.handle,\r\n0, 0, 0, 0, 0);\r\nif (ret == H_RESOURCE)\r\nehca_gen_err("Resource in use. ret=%lli ", ret);\r\nreturn ret;\r\n}\r\nu64 hipz_h_alloc_resource_mr(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mr *mr,\r\nconst u64 vaddr,\r\nconst u64 length,\r\nconst u32 access_ctrl,\r\nconst struct ipz_pd pd,\r\nstruct ehca_mr_hipzout_parms *outparms)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_ALLOC_RESOURCE, outs,\r\nadapter_handle.handle,\r\n5,\r\nvaddr,\r\nlength,\r\n(((u64)access_ctrl) << 32ULL),\r\npd.value,\r\n0, 0, 0);\r\noutparms->handle.handle = outs[0];\r\noutparms->lkey = (u32)outs[2];\r\noutparms->rkey = (u32)outs[3];\r\nreturn ret;\r\n}\r\nu64 hipz_h_register_rpage_mr(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mr *mr,\r\nconst u8 pagesize,\r\nconst u8 queue_type,\r\nconst u64 logical_address_of_page,\r\nconst u64 count)\r\n{\r\nu64 ret;\r\nif (unlikely(ehca_debug_level >= 3)) {\r\nif (count > 1) {\r\nu64 *kpage;\r\nint i;\r\nkpage = (u64 *)abs_to_virt(logical_address_of_page);\r\nfor (i = 0; i < count; i++)\r\nehca_gen_dbg("kpage[%d]=%p",\r\ni, (void *)kpage[i]);\r\n} else\r\nehca_gen_dbg("kpage=%p",\r\n(void *)logical_address_of_page);\r\n}\r\nif ((count > 1) && (logical_address_of_page & (EHCA_PAGESIZE-1))) {\r\nehca_gen_err("logical_address_of_page not on a 4k boundary "\r\n"adapter_handle=%llx mr=%p mr_handle=%llx "\r\n"pagesize=%x queue_type=%x "\r\n"logical_address_of_page=%llx count=%llx",\r\nadapter_handle.handle, mr,\r\nmr->ipz_mr_handle.handle, pagesize, queue_type,\r\nlogical_address_of_page, count);\r\nret = H_PARAMETER;\r\n} else\r\nret = hipz_h_register_rpage(adapter_handle, pagesize,\r\nqueue_type,\r\nmr->ipz_mr_handle.handle,\r\nlogical_address_of_page, count);\r\nreturn ret;\r\n}\r\nu64 hipz_h_query_mr(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mr *mr,\r\nstruct ehca_mr_hipzout_parms *outparms)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_QUERY_MR, outs,\r\nadapter_handle.handle,\r\nmr->ipz_mr_handle.handle,\r\n0, 0, 0, 0, 0, 0, 0);\r\noutparms->len = outs[0];\r\noutparms->vaddr = outs[1];\r\noutparms->acl = outs[4] >> 32;\r\noutparms->lkey = (u32)(outs[5] >> 32);\r\noutparms->rkey = (u32)(outs[5] & (0xffffffff));\r\nreturn ret;\r\n}\r\nu64 hipz_h_free_resource_mr(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mr *mr)\r\n{\r\nreturn ehca_plpar_hcall_norets(H_FREE_RESOURCE,\r\nadapter_handle.handle,\r\nmr->ipz_mr_handle.handle,\r\n0, 0, 0, 0, 0);\r\n}\r\nu64 hipz_h_reregister_pmr(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mr *mr,\r\nconst u64 vaddr_in,\r\nconst u64 length,\r\nconst u32 access_ctrl,\r\nconst struct ipz_pd pd,\r\nconst u64 mr_addr_cb,\r\nstruct ehca_mr_hipzout_parms *outparms)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_REREGISTER_PMR, outs,\r\nadapter_handle.handle,\r\nmr->ipz_mr_handle.handle,\r\nvaddr_in,\r\nlength,\r\n((((u64)access_ctrl) << 32ULL) | pd.value),\r\nmr_addr_cb,\r\n0, 0, 0);\r\noutparms->vaddr = outs[1];\r\noutparms->lkey = (u32)outs[2];\r\noutparms->rkey = (u32)outs[3];\r\nreturn ret;\r\n}\r\nu64 hipz_h_register_smr(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mr *mr,\r\nconst struct ehca_mr *orig_mr,\r\nconst u64 vaddr_in,\r\nconst u32 access_ctrl,\r\nconst struct ipz_pd pd,\r\nstruct ehca_mr_hipzout_parms *outparms)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_REGISTER_SMR, outs,\r\nadapter_handle.handle,\r\norig_mr->ipz_mr_handle.handle,\r\nvaddr_in,\r\n(((u64)access_ctrl) << 32ULL),\r\npd.value,\r\n0, 0, 0, 0);\r\noutparms->handle.handle = outs[0];\r\noutparms->lkey = (u32)outs[2];\r\noutparms->rkey = (u32)outs[3];\r\nreturn ret;\r\n}\r\nu64 hipz_h_alloc_resource_mw(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mw *mw,\r\nconst struct ipz_pd pd,\r\nstruct ehca_mw_hipzout_parms *outparms)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_ALLOC_RESOURCE, outs,\r\nadapter_handle.handle,\r\n6,\r\npd.value,\r\n0, 0, 0, 0, 0, 0);\r\noutparms->handle.handle = outs[0];\r\noutparms->rkey = (u32)outs[3];\r\nreturn ret;\r\n}\r\nu64 hipz_h_query_mw(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mw *mw,\r\nstruct ehca_mw_hipzout_parms *outparms)\r\n{\r\nu64 ret;\r\nunsigned long outs[PLPAR_HCALL9_BUFSIZE];\r\nret = ehca_plpar_hcall9(H_QUERY_MW, outs,\r\nadapter_handle.handle,\r\nmw->ipz_mw_handle.handle,\r\n0, 0, 0, 0, 0, 0, 0);\r\noutparms->rkey = (u32)outs[3];\r\nreturn ret;\r\n}\r\nu64 hipz_h_free_resource_mw(const struct ipz_adapter_handle adapter_handle,\r\nconst struct ehca_mw *mw)\r\n{\r\nreturn ehca_plpar_hcall_norets(H_FREE_RESOURCE,\r\nadapter_handle.handle,\r\nmw->ipz_mw_handle.handle,\r\n0, 0, 0, 0, 0);\r\n}\r\nu64 hipz_h_error_data(const struct ipz_adapter_handle adapter_handle,\r\nconst u64 ressource_handle,\r\nvoid *rblock,\r\nunsigned long *byte_count)\r\n{\r\nu64 r_cb = virt_to_abs(rblock);\r\nif (r_cb & (EHCA_PAGESIZE-1)) {\r\nehca_gen_err("rblock not page aligned.");\r\nreturn H_PARAMETER;\r\n}\r\nreturn ehca_plpar_hcall_norets(H_ERROR_DATA,\r\nadapter_handle.handle,\r\nressource_handle,\r\nr_cb,\r\n0, 0, 0, 0);\r\n}\r\nu64 hipz_h_eoi(int irq)\r\n{\r\nunsigned long xirr;\r\niosync();\r\nxirr = (0xffULL << 24) | irq;\r\nreturn plpar_hcall_norets(H_EOI, xirr);\r\n}
