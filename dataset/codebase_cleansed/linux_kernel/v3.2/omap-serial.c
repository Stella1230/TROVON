static inline unsigned int serial_in(struct uart_omap_port *up, int offset)\r\n{\r\noffset <<= up->port.regshift;\r\nreturn readw(up->port.membase + offset);\r\n}\r\nstatic inline void serial_out(struct uart_omap_port *up, int offset, int value)\r\n{\r\noffset <<= up->port.regshift;\r\nwritew(value, up->port.membase + offset);\r\n}\r\nstatic inline void serial_omap_clear_fifos(struct uart_omap_port *up)\r\n{\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_FCR, 0);\r\n}\r\nstatic unsigned int\r\nserial_omap_get_divisor(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned int divisor;\r\nif (baud > OMAP_MODE13X_SPEED && baud != 3000000)\r\ndivisor = 13;\r\nelse\r\ndivisor = 16;\r\nreturn port->uartclk/(baud * divisor);\r\n}\r\nstatic void serial_omap_stop_rxdma(struct uart_omap_port *up)\r\n{\r\nif (up->uart_dma.rx_dma_used) {\r\ndel_timer(&up->uart_dma.rx_timer);\r\nomap_stop_dma(up->uart_dma.rx_dma_channel);\r\nomap_free_dma(up->uart_dma.rx_dma_channel);\r\nup->uart_dma.rx_dma_channel = OMAP_UART_DMA_CH_FREE;\r\nup->uart_dma.rx_dma_used = false;\r\n}\r\n}\r\nstatic void serial_omap_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\ndev_dbg(up->port.dev, "serial_omap_enable_ms+%d\n", up->pdev->id);\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nstatic void serial_omap_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nif (up->use_dma &&\r\nup->uart_dma.tx_dma_channel != OMAP_UART_DMA_CH_FREE) {\r\nif (omap_get_dma_active_status(up->uart_dma.tx_dma_channel))\r\nreturn;\r\nomap_stop_dma(up->uart_dma.tx_dma_channel);\r\nomap_free_dma(up->uart_dma.tx_dma_channel);\r\nup->uart_dma.tx_dma_channel = OMAP_UART_DMA_CH_FREE;\r\n}\r\nif (up->ier & UART_IER_THRI) {\r\nup->ier &= ~UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nstatic void serial_omap_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nif (up->use_dma)\r\nserial_omap_stop_rxdma(up);\r\nup->ier &= ~UART_IER_RLSI;\r\nup->port.read_status_mask &= ~UART_LSR_DR;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nstatic inline void receive_chars(struct uart_omap_port *up, int *status)\r\n{\r\nstruct tty_struct *tty = up->port.state->port.tty;\r\nunsigned int flag;\r\nunsigned char ch, lsr = *status;\r\nint max_count = 256;\r\ndo {\r\nif (likely(lsr & UART_LSR_DR))\r\nch = serial_in(up, UART_RX);\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (unlikely(lsr & UART_LSR_BRK_ERROR_BITS)) {\r\nif (lsr & UART_LSR_BI) {\r\nlsr &= ~(UART_LSR_FE | UART_LSR_PE);\r\nup->port.icount.brk++;\r\nif (uart_handle_break(&up->port))\r\ngoto ignore_char;\r\n} else if (lsr & UART_LSR_PE) {\r\nup->port.icount.parity++;\r\n} else if (lsr & UART_LSR_FE) {\r\nup->port.icount.frame++;\r\n}\r\nif (lsr & UART_LSR_OE)\r\nup->port.icount.overrun++;\r\nlsr &= up->port.read_status_mask;\r\n#ifdef CONFIG_SERIAL_OMAP_CONSOLE\r\nif (up->port.line == up->port.cons->index) {\r\nlsr |= up->lsr_break_flag;\r\n}\r\n#endif\r\nif (lsr & UART_LSR_BI)\r\nflag = TTY_BREAK;\r\nelse if (lsr & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (lsr & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(&up->port, lsr, UART_LSR_OE, ch, flag);\r\nignore_char:\r\nlsr = serial_in(up, UART_LSR);\r\n} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (max_count-- > 0));\r\nspin_unlock(&up->port.lock);\r\ntty_flip_buffer_push(tty);\r\nspin_lock(&up->port.lock);\r\n}\r\nstatic void transmit_chars(struct uart_omap_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint count;\r\nif (up->port.x_char) {\r\nserial_out(up, UART_TX, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nserial_omap_stop_tx(&up->port);\r\nreturn;\r\n}\r\ncount = up->port.fifosize / 4;\r\ndo {\r\nserial_out(up, UART_TX, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit))\r\nserial_omap_stop_tx(&up->port);\r\n}\r\nstatic inline void serial_omap_enable_ier_thri(struct uart_omap_port *up)\r\n{\r\nif (!(up->ier & UART_IER_THRI)) {\r\nup->ier |= UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nstatic void serial_omap_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nstruct circ_buf *xmit;\r\nunsigned int start;\r\nint ret = 0;\r\nif (!up->use_dma) {\r\nserial_omap_enable_ier_thri(up);\r\nreturn;\r\n}\r\nif (up->uart_dma.tx_dma_used)\r\nreturn;\r\nxmit = &up->port.state->xmit;\r\nif (up->uart_dma.tx_dma_channel == OMAP_UART_DMA_CH_FREE) {\r\nret = omap_request_dma(up->uart_dma.uart_dma_tx,\r\n"UART Tx DMA",\r\n(void *)uart_tx_dma_callback, up,\r\n&(up->uart_dma.tx_dma_channel));\r\nif (ret < 0) {\r\nserial_omap_enable_ier_thri(up);\r\nreturn;\r\n}\r\n}\r\nspin_lock(&(up->uart_dma.tx_lock));\r\nup->uart_dma.tx_dma_used = true;\r\nspin_unlock(&(up->uart_dma.tx_lock));\r\nstart = up->uart_dma.tx_buf_dma_phys +\r\n(xmit->tail & (UART_XMIT_SIZE - 1));\r\nup->uart_dma.tx_buf_size = uart_circ_chars_pending(xmit);\r\nif (start + up->uart_dma.tx_buf_size >=\r\nup->uart_dma.tx_buf_dma_phys + UART_XMIT_SIZE)\r\nup->uart_dma.tx_buf_size =\r\n(up->uart_dma.tx_buf_dma_phys +\r\nUART_XMIT_SIZE) - start;\r\nomap_set_dma_dest_params(up->uart_dma.tx_dma_channel, 0,\r\nOMAP_DMA_AMODE_CONSTANT,\r\nup->uart_dma.uart_base, 0, 0);\r\nomap_set_dma_src_params(up->uart_dma.tx_dma_channel, 0,\r\nOMAP_DMA_AMODE_POST_INC, start, 0, 0);\r\nomap_set_dma_transfer_params(up->uart_dma.tx_dma_channel,\r\nOMAP_DMA_DATA_TYPE_S8,\r\nup->uart_dma.tx_buf_size, 1,\r\nOMAP_DMA_SYNC_ELEMENT,\r\nup->uart_dma.uart_dma_tx, 0);\r\nomap_start_dma(up->uart_dma.tx_dma_channel);\r\n}\r\nstatic unsigned int check_modem_status(struct uart_omap_port *up)\r\n{\r\nunsigned int status;\r\nstatus = serial_in(up, UART_MSR);\r\nstatus |= up->msr_saved_flags;\r\nup->msr_saved_flags = 0;\r\nif ((status & UART_MSR_ANY_DELTA) == 0)\r\nreturn status;\r\nif (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&\r\nup->port.state != NULL) {\r\nif (status & UART_MSR_TERI)\r\nup->port.icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nup->port.icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nuart_handle_dcd_change\r\n(&up->port, status & UART_MSR_DCD);\r\nif (status & UART_MSR_DCTS)\r\nuart_handle_cts_change\r\n(&up->port, status & UART_MSR_CTS);\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nreturn status;\r\n}\r\nstatic inline irqreturn_t serial_omap_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_omap_port *up = dev_id;\r\nunsigned int iir, lsr;\r\nunsigned long flags;\r\niir = serial_in(up, UART_IIR);\r\nif (iir & UART_IIR_NO_INT)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nlsr = serial_in(up, UART_LSR);\r\nif (iir & UART_IIR_RLSI) {\r\nif (!up->use_dma) {\r\nif (lsr & UART_LSR_DR)\r\nreceive_chars(up, &lsr);\r\n} else {\r\nup->ier &= ~(UART_IER_RDI | UART_IER_RLSI);\r\nserial_out(up, UART_IER, up->ier);\r\nif ((serial_omap_start_rxdma(up) != 0) &&\r\n(lsr & UART_LSR_DR))\r\nreceive_chars(up, &lsr);\r\n}\r\n}\r\ncheck_modem_status(up);\r\nif ((lsr & UART_LSR_THRE) && (iir & UART_IIR_THRI))\r\ntransmit_chars(up);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nup->port_activity = jiffies;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int serial_omap_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned long flags = 0;\r\nunsigned int ret = 0;\r\ndev_dbg(up->port.dev, "serial_omap_tx_empty+%d\n", up->pdev->id);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int serial_omap_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned char status;\r\nunsigned int ret = 0;\r\nstatus = check_modem_status(up);\r\ndev_dbg(up->port.dev, "serial_omap_get_mctrl+%d\n", up->pdev->id);\r\nif (status & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (status & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (status & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (status & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void serial_omap_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned char mcr = 0;\r\ndev_dbg(up->port.dev, "serial_omap_set_mctrl+%d\n", up->pdev->id);\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nmcr |= up->mcr;\r\nserial_out(up, UART_MCR, mcr);\r\n}\r\nstatic void serial_omap_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned long flags = 0;\r\ndev_dbg(up->port.dev, "serial_omap_break_ctl+%d\n", up->pdev->id);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (break_state == -1)\r\nup->lcr |= UART_LCR_SBC;\r\nelse\r\nup->lcr &= ~UART_LCR_SBC;\r\nserial_out(up, UART_LCR, up->lcr);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int serial_omap_startup(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned long flags = 0;\r\nint retval;\r\nretval = request_irq(up->port.irq, serial_omap_irq, up->port.irqflags,\r\nup->name, up);\r\nif (retval)\r\nreturn retval;\r\ndev_dbg(up->port.dev, "serial_omap_startup+%d\n", up->pdev->id);\r\nserial_omap_clear_fifos(up);\r\nserial_out(up, UART_MCR, UART_MCR_RTS);\r\n(void) serial_in(up, UART_LSR);\r\nif (serial_in(up, UART_LSR) & UART_LSR_DR)\r\n(void) serial_in(up, UART_RX);\r\n(void) serial_in(up, UART_IIR);\r\n(void) serial_in(up, UART_MSR);\r\nserial_out(up, UART_LCR, UART_LCR_WLEN8);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl |= TIOCM_OUT2;\r\nserial_omap_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nup->msr_saved_flags = 0;\r\nif (up->use_dma) {\r\nfree_page((unsigned long)up->port.state->xmit.buf);\r\nup->port.state->xmit.buf = dma_alloc_coherent(NULL,\r\nUART_XMIT_SIZE,\r\n(dma_addr_t *)&(up->uart_dma.tx_buf_dma_phys),\r\n0);\r\ninit_timer(&(up->uart_dma.rx_timer));\r\nup->uart_dma.rx_timer.function = serial_omap_rx_timeout;\r\nup->uart_dma.rx_timer.data = up->pdev->id;\r\nup->uart_dma.rx_buf = dma_alloc_coherent(NULL,\r\nup->uart_dma.rx_buf_size,\r\n(dma_addr_t *)&(up->uart_dma.rx_buf_dma_phys), 0);\r\n}\r\nup->ier = UART_IER_RLSI | UART_IER_RDI;\r\nserial_out(up, UART_IER, up->ier);\r\nserial_out(up, UART_OMAP_WER, OMAP_UART_WER_MOD_WKUP);\r\nup->port_activity = jiffies;\r\nreturn 0;\r\n}\r\nstatic void serial_omap_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned long flags = 0;\r\ndev_dbg(up->port.dev, "serial_omap_shutdown+%d\n", up->pdev->id);\r\nup->ier = 0;\r\nserial_out(up, UART_IER, 0);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl &= ~TIOCM_OUT2;\r\nserial_omap_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nserial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);\r\nserial_omap_clear_fifos(up);\r\nif (serial_in(up, UART_LSR) & UART_LSR_DR)\r\n(void) serial_in(up, UART_RX);\r\nif (up->use_dma) {\r\ndma_free_coherent(up->port.dev,\r\nUART_XMIT_SIZE, up->port.state->xmit.buf,\r\nup->uart_dma.tx_buf_dma_phys);\r\nup->port.state->xmit.buf = NULL;\r\nserial_omap_stop_rx(port);\r\ndma_free_coherent(up->port.dev,\r\nup->uart_dma.rx_buf_size, up->uart_dma.rx_buf,\r\nup->uart_dma.rx_buf_dma_phys);\r\nup->uart_dma.rx_buf = NULL;\r\n}\r\nfree_irq(up->port.irq, up);\r\n}\r\nstatic inline void\r\nserial_omap_configure_xonxoff\r\n(struct uart_omap_port *up, struct ktermios *termios)\r\n{\r\nunsigned char efr = 0;\r\nup->lcr = serial_in(up, UART_LCR);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nup->efr = serial_in(up, UART_EFR);\r\nserial_out(up, UART_EFR, up->efr & ~UART_EFR_ECB);\r\nserial_out(up, UART_XON1, termios->c_cc[VSTART]);\r\nserial_out(up, UART_XOFF1, termios->c_cc[VSTOP]);\r\nefr = up->efr;\r\nefr &= OMAP_UART_SW_CLR;\r\nif (termios->c_iflag & IXON)\r\nefr |= OMAP_UART_SW_TX;\r\nif (termios->c_iflag & IXOFF)\r\nefr |= OMAP_UART_SW_RX;\r\nserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nup->mcr = serial_in(up, UART_MCR);\r\nif (termios->c_iflag & IXANY)\r\nup->mcr |= UART_MCR_XONANY;\r\nserial_out(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);\r\nserial_out(up, UART_EFR, efr | UART_EFR_SCD);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_MCR, up->mcr & ~UART_MCR_TCRTLR);\r\nserial_out(up, UART_LCR, up->lcr);\r\n}\r\nstatic void\r\nserial_omap_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned char cval = 0;\r\nunsigned char efr = 0;\r\nunsigned long flags = 0;\r\nunsigned int baud, quot;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncval = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\ncval = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= UART_LCR_STOP;\r\nif (termios->c_cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/13);\r\nquot = serial_omap_get_divisor(port, baud);\r\nup->fcr = UART_FCR_R_TRIG_01 | UART_FCR_T_TRIG_01 |\r\nUART_FCR_ENABLE_FIFO;\r\nif (up->use_dma)\r\nup->fcr |= UART_FCR_DMA_SELECT;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (termios->c_iflag & INPCK)\r\nup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nup->port.read_status_mask |= UART_LSR_BI;\r\nup->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= UART_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= UART_LSR_DR;\r\nup->ier &= ~UART_IER_MSI;\r\nif (UART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\nserial_out(up, UART_LCR, cval);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_DLL, 0);\r\nserial_out(up, UART_DLM, 0);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nup->efr = serial_in(up, UART_EFR);\r\nserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nup->mcr = serial_in(up, UART_MCR);\r\nserial_out(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);\r\nserial_out(up, UART_FCR, up->fcr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nif (up->use_dma) {\r\nserial_out(up, UART_TI752_TLR, 0);\r\nserial_out(up, UART_OMAP_SCR,\r\n(UART_FCR_TRIGGER_4 | UART_FCR_TRIGGER_8));\r\n}\r\nserial_out(up, UART_EFR, up->efr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_MCR, up->mcr);\r\nserial_out(up, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nup->efr = serial_in(up, UART_EFR);\r\nserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_IER, 0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_DLL, quot & 0xff);\r\nserial_out(up, UART_DLM, quot >> 8);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_IER, up->ier);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, up->efr);\r\nserial_out(up, UART_LCR, cval);\r\nif (baud > 230400 && baud != 3000000)\r\nserial_out(up, UART_OMAP_MDR1, UART_OMAP_MDR1_13X_MODE);\r\nelse\r\nserial_out(up, UART_OMAP_MDR1, UART_OMAP_MDR1_16X_MODE);\r\nif (termios->c_cflag & CRTSCTS) {\r\nefr |= (UART_EFR_CTS | UART_EFR_RTS);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nup->mcr = serial_in(up, UART_MCR);\r\nserial_out(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nup->efr = serial_in(up, UART_EFR);\r\nserial_out(up, UART_EFR, up->efr | UART_EFR_ECB);\r\nserial_out(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);\r\nserial_out(up, UART_EFR, efr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_MCR, up->mcr | UART_MCR_RTS);\r\nserial_out(up, UART_LCR, cval);\r\n}\r\nserial_omap_set_mctrl(&up->port, up->port.mctrl);\r\nserial_omap_configure_xonxoff(up, termios);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\ndev_dbg(up->port.dev, "serial_omap_set_termios+%d\n", up->pdev->id);\r\n}\r\nstatic void\r\nserial_omap_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned char efr;\r\ndev_dbg(up->port.dev, "serial_omap_pm+%d\n", up->pdev->id);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nefr = serial_in(up, UART_EFR);\r\nserial_out(up, UART_EFR, efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, efr);\r\nserial_out(up, UART_LCR, 0);\r\n}\r\nstatic void serial_omap_release_port(struct uart_port *port)\r\n{\r\ndev_dbg(port->dev, "serial_omap_release_port+\n");\r\n}\r\nstatic int serial_omap_request_port(struct uart_port *port)\r\n{\r\ndev_dbg(port->dev, "serial_omap_request_port+\n");\r\nreturn 0;\r\n}\r\nstatic void serial_omap_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\ndev_dbg(up->port.dev, "serial_omap_config_port+%d\n",\r\nup->pdev->id);\r\nup->port.type = PORT_OMAP;\r\n}\r\nstatic int\r\nserial_omap_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\ndev_dbg(port->dev, "serial_omap_verify_port+\n");\r\nreturn -EINVAL;\r\n}\r\nstatic const char *\r\nserial_omap_type(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\ndev_dbg(up->port.dev, "serial_omap_type+%d\n", up->pdev->id);\r\nreturn up->name;\r\n}\r\nstatic inline void wait_for_xmitr(struct uart_omap_port *up)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = serial_in(up, UART_LSR);\r\nif (status & UART_LSR_BI)\r\nup->lsr_break_flag = UART_LSR_BI;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while ((status & BOTH_EMPTY) != BOTH_EMPTY);\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\ntmout = 1000000;\r\nfor (tmout = 1000000; tmout; tmout--) {\r\nunsigned int msr = serial_in(up, UART_MSR);\r\nup->msr_saved_flags |= msr & MSR_SAVE_FLAGS;\r\nif (msr & UART_MSR_CTS)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nstatic void serial_omap_poll_put_char(struct uart_port *port, unsigned char ch)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_TX, ch);\r\n}\r\nstatic int serial_omap_poll_get_char(struct uart_port *port)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nunsigned int status = serial_in(up, UART_LSR);\r\nif (!(status & UART_LSR_DR))\r\nreturn NO_POLL_CHAR;\r\nreturn serial_in(up, UART_RX);\r\n}\r\nstatic void serial_omap_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)port;\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_TX, ch);\r\n}\r\nstatic void\r\nserial_omap_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_omap_port *up = serial_omap_console_ports[co->index];\r\nunsigned long flags;\r\nunsigned int ier;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\nif (up->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&up->port.lock);\r\nelse\r\nspin_lock(&up->port.lock);\r\nier = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, 0);\r\nuart_console_write(&up->port, s, count, serial_omap_console_putchar);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_IER, ier);\r\nif (up->msr_saved_flags)\r\ncheck_modem_status(up);\r\nif (locked)\r\nspin_unlock(&up->port.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init\r\nserial_omap_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_omap_port *up;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (serial_omap_console_ports[co->index] == NULL)\r\nreturn -ENODEV;\r\nup = serial_omap_console_ports[co->index];\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&up->port, co, baud, parity, bits, flow);\r\n}\r\nstatic void serial_omap_add_console_port(struct uart_omap_port *up)\r\n{\r\nserial_omap_console_ports[up->pdev->id] = up;\r\n}\r\nstatic inline void serial_omap_add_console_port(struct uart_omap_port *up)\r\n{}\r\nstatic int\r\nserial_omap_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct uart_omap_port *up = platform_get_drvdata(pdev);\r\nif (up)\r\nuart_suspend_port(&serial_omap_reg, &up->port);\r\nreturn 0;\r\n}\r\nstatic int serial_omap_resume(struct platform_device *dev)\r\n{\r\nstruct uart_omap_port *up = platform_get_drvdata(dev);\r\nif (up)\r\nuart_resume_port(&serial_omap_reg, &up->port);\r\nreturn 0;\r\n}\r\nstatic void serial_omap_rx_timeout(unsigned long uart_no)\r\n{\r\nstruct uart_omap_port *up = ui[uart_no];\r\nunsigned int curr_dma_pos, curr_transmitted_size;\r\nint ret = 0;\r\ncurr_dma_pos = omap_get_dma_dst_pos(up->uart_dma.rx_dma_channel);\r\nif ((curr_dma_pos == up->uart_dma.prev_rx_dma_pos) ||\r\n(curr_dma_pos == 0)) {\r\nif (jiffies_to_msecs(jiffies - up->port_activity) <\r\nRX_TIMEOUT) {\r\nmod_timer(&up->uart_dma.rx_timer, jiffies +\r\nusecs_to_jiffies(up->uart_dma.rx_timeout));\r\n} else {\r\nserial_omap_stop_rxdma(up);\r\nup->ier |= (UART_IER_RDI | UART_IER_RLSI);\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nreturn;\r\n}\r\ncurr_transmitted_size = curr_dma_pos -\r\nup->uart_dma.prev_rx_dma_pos;\r\nup->port.icount.rx += curr_transmitted_size;\r\ntty_insert_flip_string(up->port.state->port.tty,\r\nup->uart_dma.rx_buf +\r\n(up->uart_dma.prev_rx_dma_pos -\r\nup->uart_dma.rx_buf_dma_phys),\r\ncurr_transmitted_size);\r\ntty_flip_buffer_push(up->port.state->port.tty);\r\nup->uart_dma.prev_rx_dma_pos = curr_dma_pos;\r\nif (up->uart_dma.rx_buf_size +\r\nup->uart_dma.rx_buf_dma_phys == curr_dma_pos) {\r\nret = serial_omap_start_rxdma(up);\r\nif (ret < 0) {\r\nserial_omap_stop_rxdma(up);\r\nup->ier |= (UART_IER_RDI | UART_IER_RLSI);\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n} else {\r\nmod_timer(&up->uart_dma.rx_timer, jiffies +\r\nusecs_to_jiffies(up->uart_dma.rx_timeout));\r\n}\r\nup->port_activity = jiffies;\r\n}\r\nstatic void uart_rx_dma_callback(int lch, u16 ch_status, void *data)\r\n{\r\nreturn;\r\n}\r\nstatic int serial_omap_start_rxdma(struct uart_omap_port *up)\r\n{\r\nint ret = 0;\r\nif (up->uart_dma.rx_dma_channel == -1) {\r\nret = omap_request_dma(up->uart_dma.uart_dma_rx,\r\n"UART Rx DMA",\r\n(void *)uart_rx_dma_callback, up,\r\n&(up->uart_dma.rx_dma_channel));\r\nif (ret < 0)\r\nreturn ret;\r\nomap_set_dma_src_params(up->uart_dma.rx_dma_channel, 0,\r\nOMAP_DMA_AMODE_CONSTANT,\r\nup->uart_dma.uart_base, 0, 0);\r\nomap_set_dma_dest_params(up->uart_dma.rx_dma_channel, 0,\r\nOMAP_DMA_AMODE_POST_INC,\r\nup->uart_dma.rx_buf_dma_phys, 0, 0);\r\nomap_set_dma_transfer_params(up->uart_dma.rx_dma_channel,\r\nOMAP_DMA_DATA_TYPE_S8,\r\nup->uart_dma.rx_buf_size, 1,\r\nOMAP_DMA_SYNC_ELEMENT,\r\nup->uart_dma.uart_dma_rx, 0);\r\n}\r\nup->uart_dma.prev_rx_dma_pos = up->uart_dma.rx_buf_dma_phys;\r\nomap_start_dma(up->uart_dma.rx_dma_channel);\r\nmod_timer(&up->uart_dma.rx_timer, jiffies +\r\nusecs_to_jiffies(up->uart_dma.rx_timeout));\r\nup->uart_dma.rx_dma_used = true;\r\nreturn ret;\r\n}\r\nstatic void serial_omap_continue_tx(struct uart_omap_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nunsigned int start = up->uart_dma.tx_buf_dma_phys\r\n+ (xmit->tail & (UART_XMIT_SIZE - 1));\r\nif (uart_circ_empty(xmit))\r\nreturn;\r\nup->uart_dma.tx_buf_size = uart_circ_chars_pending(xmit);\r\nif (start + up->uart_dma.tx_buf_size >=\r\nup->uart_dma.tx_buf_dma_phys + UART_XMIT_SIZE)\r\nup->uart_dma.tx_buf_size =\r\n(up->uart_dma.tx_buf_dma_phys + UART_XMIT_SIZE) - start;\r\nomap_set_dma_dest_params(up->uart_dma.tx_dma_channel, 0,\r\nOMAP_DMA_AMODE_CONSTANT,\r\nup->uart_dma.uart_base, 0, 0);\r\nomap_set_dma_src_params(up->uart_dma.tx_dma_channel, 0,\r\nOMAP_DMA_AMODE_POST_INC, start, 0, 0);\r\nomap_set_dma_transfer_params(up->uart_dma.tx_dma_channel,\r\nOMAP_DMA_DATA_TYPE_S8,\r\nup->uart_dma.tx_buf_size, 1,\r\nOMAP_DMA_SYNC_ELEMENT,\r\nup->uart_dma.uart_dma_tx, 0);\r\nomap_start_dma(up->uart_dma.tx_dma_channel);\r\n}\r\nstatic void uart_tx_dma_callback(int lch, u16 ch_status, void *data)\r\n{\r\nstruct uart_omap_port *up = (struct uart_omap_port *)data;\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nxmit->tail = (xmit->tail + up->uart_dma.tx_buf_size) & \\r\n(UART_XMIT_SIZE - 1);\r\nup->port.icount.tx += up->uart_dma.tx_buf_size;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit)) {\r\nspin_lock(&(up->uart_dma.tx_lock));\r\nserial_omap_stop_tx(&up->port);\r\nup->uart_dma.tx_dma_used = false;\r\nspin_unlock(&(up->uart_dma.tx_lock));\r\n} else {\r\nomap_stop_dma(up->uart_dma.tx_dma_channel);\r\nserial_omap_continue_tx(up);\r\n}\r\nup->port_activity = jiffies;\r\nreturn;\r\n}\r\nstatic int serial_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct uart_omap_port *up;\r\nstruct resource *mem, *irq, *dma_tx, *dma_rx;\r\nstruct omap_uart_port_info *omap_up_info = pdev->dev.platform_data;\r\nint ret = -ENOSPC;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn -ENODEV;\r\n}\r\nif (!request_mem_region(mem->start, resource_size(mem),\r\npdev->dev.driver->name)) {\r\ndev_err(&pdev->dev, "memory region already claimed\n");\r\nreturn -EBUSY;\r\n}\r\ndma_rx = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx");\r\nif (!dma_rx) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndma_tx = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");\r\nif (!dma_tx) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nup = kzalloc(sizeof(*up), GFP_KERNEL);\r\nif (up == NULL) {\r\nret = -ENOMEM;\r\ngoto do_release_region;\r\n}\r\nsprintf(up->name, "OMAP UART%d", pdev->id);\r\nup->pdev = pdev;\r\nup->port.dev = &pdev->dev;\r\nup->port.type = PORT_OMAP;\r\nup->port.iotype = UPIO_MEM;\r\nup->port.irq = irq->start;\r\nup->port.regshift = 2;\r\nup->port.fifosize = 64;\r\nup->port.ops = &serial_omap_pops;\r\nup->port.line = pdev->id;\r\nup->port.membase = omap_up_info->membase;\r\nup->port.mapbase = omap_up_info->mapbase;\r\nup->port.flags = omap_up_info->flags;\r\nup->port.irqflags = omap_up_info->irqflags;\r\nup->port.uartclk = omap_up_info->uartclk;\r\nup->uart_dma.uart_base = mem->start;\r\nif (omap_up_info->dma_enabled) {\r\nup->uart_dma.uart_dma_tx = dma_tx->start;\r\nup->uart_dma.uart_dma_rx = dma_rx->start;\r\nup->use_dma = 1;\r\nup->uart_dma.rx_buf_size = 4096;\r\nup->uart_dma.rx_timeout = 2;\r\nspin_lock_init(&(up->uart_dma.tx_lock));\r\nspin_lock_init(&(up->uart_dma.rx_lock));\r\nup->uart_dma.tx_dma_channel = OMAP_UART_DMA_CH_FREE;\r\nup->uart_dma.rx_dma_channel = OMAP_UART_DMA_CH_FREE;\r\n}\r\nui[pdev->id] = up;\r\nserial_omap_add_console_port(up);\r\nret = uart_add_one_port(&serial_omap_reg, &up->port);\r\nif (ret != 0)\r\ngoto do_release_region;\r\nplatform_set_drvdata(pdev, up);\r\nreturn 0;\r\nerr:\r\ndev_err(&pdev->dev, "[UART%d]: failure [%s]: %d\n",\r\npdev->id, __func__, ret);\r\ndo_release_region:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn ret;\r\n}\r\nstatic int serial_omap_remove(struct platform_device *dev)\r\n{\r\nstruct uart_omap_port *up = platform_get_drvdata(dev);\r\nplatform_set_drvdata(dev, NULL);\r\nif (up) {\r\nuart_remove_one_port(&serial_omap_reg, &up->port);\r\nkfree(up);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init serial_omap_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&serial_omap_reg);\r\nif (ret != 0)\r\nreturn ret;\r\nret = platform_driver_register(&serial_omap_driver);\r\nif (ret != 0)\r\nuart_unregister_driver(&serial_omap_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit serial_omap_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_omap_driver);\r\nuart_unregister_driver(&serial_omap_reg);\r\n}
