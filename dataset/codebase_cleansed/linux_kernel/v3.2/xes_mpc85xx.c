void __init xes_mpc85xx_pic_init(void)\r\n{\r\nstruct mpic *mpic;\r\nstruct resource r;\r\nstruct device_node *np;\r\nnp = of_find_node_by_type(NULL, "open-pic");\r\nif (np == NULL) {\r\nprintk(KERN_ERR "Could not find open-pic node\n");\r\nreturn;\r\n}\r\nif (of_address_to_resource(np, 0, &r)) {\r\nprintk(KERN_ERR "Failed to map mpic register space\n");\r\nof_node_put(np);\r\nreturn;\r\n}\r\nmpic = mpic_alloc(np, r.start,\r\nMPIC_PRIMARY | MPIC_WANTS_RESET |\r\nMPIC_BIG_ENDIAN | MPIC_BROKEN_FRR_NIRQS,\r\n0, 256, " OpenPIC ");\r\nBUG_ON(mpic == NULL);\r\nof_node_put(np);\r\nmpic_init(mpic);\r\n}\r\nstatic void xes_mpc85xx_configure_l2(void __iomem *l2_base)\r\n{\r\nvolatile uint32_t ctl, tmp;\r\nasm volatile("msync; isync");\r\ntmp = in_be32(l2_base);\r\nprintk(KERN_INFO "xes_mpc85xx: Enabling L2 as cache\n");\r\nctl = MPC85xx_L2CTL_L2E | MPC85xx_L2CTL_L2I;\r\nif (of_machine_is_compatible("MPC8540") ||\r\nof_machine_is_compatible("MPC8560"))\r\nctl |= (tmp & MPC85xx_L2CTL_L2SIZ_MASK) >> 2;\r\nasm volatile("msync; isync");\r\nout_be32(l2_base, ctl);\r\nasm volatile("msync; isync");\r\n}\r\nstatic void xes_mpc85xx_fixups(void)\r\n{\r\nstruct device_node *np;\r\nint err;\r\nfor_each_node_by_name(np, "l2-cache-controller") {\r\nstruct resource r[2];\r\nvoid __iomem *l2_base;\r\nif (!of_device_is_compatible(np,\r\n"fsl,mpc8548-l2-cache-controller") &&\r\n!of_device_is_compatible(np,\r\n"fsl,mpc8540-l2-cache-controller") &&\r\n!of_device_is_compatible(np,\r\n"fsl,mpc8560-l2-cache-controller"))\r\ncontinue;\r\nerr = of_address_to_resource(np, 0, &r[0]);\r\nif (err) {\r\nprintk(KERN_WARNING "xes_mpc85xx: Could not get "\r\n"resource for device tree node '%s'",\r\nnp->full_name);\r\ncontinue;\r\n}\r\nl2_base = ioremap(r[0].start, resource_size(&r[0]));\r\nxes_mpc85xx_configure_l2(l2_base);\r\n}\r\n}\r\nstatic void __init xes_mpc85xx_setup_arch(void)\r\n{\r\n#ifdef CONFIG_PCI\r\nstruct device_node *np;\r\n#endif\r\nstruct device_node *root;\r\nconst char *model = "Unknown";\r\nroot = of_find_node_by_path("/");\r\nif (root == NULL)\r\nreturn;\r\nmodel = of_get_property(root, "model", NULL);\r\nprintk(KERN_INFO "X-ES MPC85xx-based single-board computer: %s\n",\r\nmodel + strlen("xes,"));\r\nxes_mpc85xx_fixups();\r\n#ifdef CONFIG_PCI\r\nfor_each_node_by_type(np, "pci") {\r\nif (of_device_is_compatible(np, "fsl,mpc8540-pci") ||\r\nof_device_is_compatible(np, "fsl,mpc8548-pcie")) {\r\nstruct resource rsrc;\r\nof_address_to_resource(np, 0, &rsrc);\r\nif ((rsrc.start & 0xfffff) == primary_phb_addr)\r\nfsl_add_bridge(np, 1);\r\nelse\r\nfsl_add_bridge(np, 0);\r\n}\r\n}\r\n#endif\r\n#ifdef CONFIG_SMP\r\nmpc85xx_smp_init();\r\n#endif\r\n}\r\nstatic int __init xes_mpc85xx_publish_devices(void)\r\n{\r\nreturn of_platform_bus_probe(NULL, xes_mpc85xx_ids, NULL);\r\n}\r\nstatic int __init xes_mpc8572_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "xes,MPC8572")) {\r\n#ifdef CONFIG_PCI\r\nprimary_phb_addr = 0x8000;\r\n#endif\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int __init xes_mpc8548_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "xes,MPC8548")) {\r\n#ifdef CONFIG_PCI\r\nprimary_phb_addr = 0xb000;\r\n#endif\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int __init xes_mpc8540_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "xes,MPC8540")) {\r\n#ifdef CONFIG_PCI\r\nprimary_phb_addr = 0xb000;\r\n#endif\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}
