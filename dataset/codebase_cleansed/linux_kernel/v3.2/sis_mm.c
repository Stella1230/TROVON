static void *sis_sman_mm_allocate(void *private, unsigned long size,\r\nunsigned alignment)\r\n{\r\nstruct sis_memreq req;\r\nreq.size = size;\r\nsis_malloc(&req);\r\nif (req.size == 0)\r\nreturn NULL;\r\nelse\r\nreturn (void *)(unsigned long)~req.offset;\r\n}\r\nstatic void sis_sman_mm_free(void *private, void *ref)\r\n{\r\nsis_free(~((unsigned long)ref));\r\n}\r\nstatic void sis_sman_mm_destroy(void *private)\r\n{\r\n;\r\n}\r\nstatic unsigned long sis_sman_mm_offset(void *private, void *ref)\r\n{\r\nreturn ~((unsigned long)ref);\r\n}\r\nstatic int sis_fb_init(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_fb_t *fb = data;\r\nint ret;\r\nmutex_lock(&dev->struct_mutex);\r\n#if defined(CONFIG_FB_SIS) || defined(CONFIG_FB_SIS_MODULE)\r\n{\r\nstruct drm_sman_mm sman_mm;\r\nsman_mm.private = (void *)0xFFFFFFFF;\r\nsman_mm.allocate = sis_sman_mm_allocate;\r\nsman_mm.free = sis_sman_mm_free;\r\nsman_mm.destroy = sis_sman_mm_destroy;\r\nsman_mm.offset = sis_sman_mm_offset;\r\nret =\r\ndrm_sman_set_manager(&dev_priv->sman, VIDEO_TYPE, &sman_mm);\r\n}\r\n#else\r\nret = drm_sman_set_range(&dev_priv->sman, VIDEO_TYPE, 0,\r\nfb->size >> SIS_MM_ALIGN_SHIFT);\r\n#endif\r\nif (ret) {\r\nDRM_ERROR("VRAM memory manager initialisation error\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\ndev_priv->vram_initialized = 1;\r\ndev_priv->vram_offset = fb->offset;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("offset = %u, size = %u\n", fb->offset, fb->size);\r\nreturn 0;\r\n}\r\nstatic int sis_drm_alloc(struct drm_device *dev, struct drm_file *file_priv,\r\nvoid *data, int pool)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_mem_t *mem = data;\r\nint retval = 0;\r\nstruct drm_memblock_item *item;\r\nmutex_lock(&dev->struct_mutex);\r\nif (0 == ((pool == 0) ? dev_priv->vram_initialized :\r\ndev_priv->agp_initialized)) {\r\nDRM_ERROR\r\n("Attempt to allocate from uninitialized memory manager.\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nmem->size = (mem->size + SIS_MM_ALIGN_MASK) >> SIS_MM_ALIGN_SHIFT;\r\nitem = drm_sman_alloc(&dev_priv->sman, pool, mem->size, 0,\r\n(unsigned long)file_priv);\r\nmutex_unlock(&dev->struct_mutex);\r\nif (item) {\r\nmem->offset = ((pool == 0) ?\r\ndev_priv->vram_offset : dev_priv->agp_offset) +\r\n(item->mm->\r\noffset(item->mm, item->mm_info) << SIS_MM_ALIGN_SHIFT);\r\nmem->free = item->user_hash.key;\r\nmem->size = mem->size << SIS_MM_ALIGN_SHIFT;\r\n} else {\r\nmem->offset = 0;\r\nmem->size = 0;\r\nmem->free = 0;\r\nretval = -ENOMEM;\r\n}\r\nDRM_DEBUG("alloc %d, size = %d, offset = %d\n", pool, mem->size,\r\nmem->offset);\r\nreturn retval;\r\n}\r\nstatic int sis_drm_free(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_mem_t *mem = data;\r\nint ret;\r\nmutex_lock(&dev->struct_mutex);\r\nret = drm_sman_free_key(&dev_priv->sman, mem->free);\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("free = 0x%lx\n", mem->free);\r\nreturn ret;\r\n}\r\nstatic int sis_fb_alloc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn sis_drm_alloc(dev, file_priv, data, VIDEO_TYPE);\r\n}\r\nstatic int sis_ioctl_agp_init(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_agp_t *agp = data;\r\nint ret;\r\ndev_priv = dev->dev_private;\r\nmutex_lock(&dev->struct_mutex);\r\nret = drm_sman_set_range(&dev_priv->sman, AGP_TYPE, 0,\r\nagp->size >> SIS_MM_ALIGN_SHIFT);\r\nif (ret) {\r\nDRM_ERROR("AGP memory manager initialisation error\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\ndev_priv->agp_initialized = 1;\r\ndev_priv->agp_offset = agp->offset;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("offset = %u, size = %u\n", agp->offset, agp->size);\r\nreturn 0;\r\n}\r\nstatic int sis_ioctl_agp_alloc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn sis_drm_alloc(dev, file_priv, data, AGP_TYPE);\r\n}\r\nstatic drm_local_map_t *sis_reg_init(struct drm_device *dev)\r\n{\r\nstruct drm_map_list *entry;\r\ndrm_local_map_t *map;\r\nlist_for_each_entry(entry, &dev->maplist, head) {\r\nmap = entry->map;\r\nif (!map)\r\ncontinue;\r\nif (map->type == _DRM_REGISTERS)\r\nreturn map;\r\n}\r\nreturn NULL;\r\n}\r\nint sis_idle(struct drm_device *dev)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\nuint32_t idle_reg;\r\nunsigned long end;\r\nint i;\r\nif (dev_priv->idle_fault)\r\nreturn 0;\r\nif (dev_priv->mmio == NULL) {\r\ndev_priv->mmio = sis_reg_init(dev);\r\nif (dev_priv->mmio == NULL) {\r\nDRM_ERROR("Could not find register map.\n");\r\nreturn 0;\r\n}\r\n}\r\nif (dev_priv->chipset != SIS_CHIP_315)\r\nreturn 0;\r\nend = jiffies + (DRM_HZ * 3);\r\nfor (i = 0; i < 4; ++i) {\r\ndo {\r\nidle_reg = SIS_READ(0x85cc);\r\n} while (!time_after_eq(jiffies, end) &&\r\n((idle_reg & 0x80000000) != 0x80000000));\r\n}\r\nif (time_after_eq(jiffies, end)) {\r\nDRM_ERROR("Graphics engine idle timeout. "\r\n"Disabling idle check\n");\r\ndev_priv->idle_fault = 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid sis_lastclose(struct drm_device *dev)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\nif (!dev_priv)\r\nreturn;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_sman_cleanup(&dev_priv->sman);\r\ndev_priv->vram_initialized = 0;\r\ndev_priv->agp_initialized = 0;\r\ndev_priv->mmio = NULL;\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nvoid sis_reclaim_buffers_locked(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\nmutex_lock(&dev->struct_mutex);\r\nif (drm_sman_owner_clean(&dev_priv->sman, (unsigned long)file_priv)) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn;\r\n}\r\nif (dev->driver->dma_quiescent)\r\ndev->driver->dma_quiescent(dev);\r\ndrm_sman_owner_cleanup(&dev_priv->sman, (unsigned long)file_priv);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn;\r\n}
