static void qube_raq_galileo_early_fixup(struct pci_dev *dev)\r\n{\r\nif (dev->devfn == PCI_DEVFN(0, 0) &&\r\n(dev->class >> 8) == PCI_CLASS_MEMORY_OTHER) {\r\ndev->class = (PCI_CLASS_BRIDGE_HOST << 8) | (dev->class & 0xff);\r\nprintk(KERN_INFO "Galileo: fixed bridge class\n");\r\n}\r\n}\r\nstatic void __devinit cobalt_legacy_ide_resource_fixup(struct pci_dev *dev,\r\nstruct resource *res)\r\n{\r\nstruct pci_controller *hose = (struct pci_controller *)dev->sysdata;\r\nunsigned long offset = hose->io_offset;\r\nstruct resource orig = *res;\r\nif (!(res->flags & IORESOURCE_IO) ||\r\n!(res->flags & IORESOURCE_PCI_FIXED))\r\nreturn;\r\nres->start -= offset;\r\nres->end -= offset;\r\ndev_printk(KERN_DEBUG, &dev->dev, "converted legacy %pR to bus %pR\n",\r\n&orig, res);\r\n}\r\nstatic void __devinit cobalt_legacy_ide_fixup(struct pci_dev *dev)\r\n{\r\nu32 class;\r\nu8 progif;\r\nclass = dev->class >> 8;\r\nif (class != PCI_CLASS_STORAGE_IDE)\r\nreturn;\r\npci_read_config_byte(dev, PCI_CLASS_PROG, &progif);\r\nif ((progif & 1) == 0) {\r\ncobalt_legacy_ide_resource_fixup(dev, &dev->resource[0]);\r\ncobalt_legacy_ide_resource_fixup(dev, &dev->resource[1]);\r\n}\r\nif ((progif & 4) == 0) {\r\ncobalt_legacy_ide_resource_fixup(dev, &dev->resource[2]);\r\ncobalt_legacy_ide_resource_fixup(dev, &dev->resource[3]);\r\n}\r\n}\r\nstatic void qube_raq_via_bmIDE_fixup(struct pci_dev *dev)\r\n{\r\nunsigned short cfgword;\r\nunsigned char lt;\r\npci_read_config_word(dev, PCI_COMMAND, &cfgword);\r\ncfgword |= (PCI_COMMAND_FAST_BACK | PCI_COMMAND_MASTER);\r\npci_write_config_word(dev, PCI_COMMAND, cfgword);\r\npci_write_config_byte(dev, 0x40, 0xb);\r\npci_read_config_byte(dev, PCI_LATENCY_TIMER, &lt);\r\nif (lt < 64)\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 64);\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 8);\r\n}\r\nstatic void qube_raq_galileo_fixup(struct pci_dev *dev)\r\n{\r\nif (dev->devfn != PCI_DEVFN(0, 0))\r\nreturn;\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 64);\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 8);\r\nprintk(KERN_INFO "Galileo: revision %u\n", dev->revision);\r\n#if 0\r\nif (dev->revision >= 0x10) {\r\nGT_WRITE(GT_PCI0_TOR_OFS, 0x4020);\r\n} else if (dev->revision == 0x1 || dev->revision == 0x2)\r\n#endif\r\n{\r\nsigned int timeo;\r\ntimeo = GT_READ(GT_PCI0_TOR_OFS);\r\nGT_WRITE(GT_PCI0_TOR_OFS,\r\n(0xff << 16) |\r\n(0xff << 8) |\r\n0xff);\r\nGT_WRITE(GT_INTRMASK_OFS, GT_INTR_RETRYCTR0_MSK | GT_READ(GT_INTRMASK_OFS));\r\n}\r\n}\r\nstatic void qube_raq_via_board_id_fixup(struct pci_dev *dev)\r\n{\r\nu8 id;\r\nint retval;\r\nretval = pci_read_config_byte(dev, VIA_COBALT_BRD_ID_REG, &id);\r\nif (retval) {\r\npanic("Cannot read board ID");\r\nreturn;\r\n}\r\ncobalt_board_id = VIA_COBALT_BRD_REG_to_ID(id);\r\nprintk(KERN_INFO "Cobalt board ID: %d\n", cobalt_board_id);\r\n}\r\nint __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nif (cobalt_board_id <= COBALT_BRD_ID_QUBE1)\r\nreturn irq_tab_qube1[slot];\r\nif (cobalt_board_id == COBALT_BRD_ID_RAQ2)\r\nreturn irq_tab_raq2[slot];\r\nreturn irq_tab_cobalt[slot];\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}
