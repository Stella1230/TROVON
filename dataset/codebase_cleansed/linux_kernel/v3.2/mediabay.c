static u8\r\nohare_mb_content(struct media_bay_info *bay)\r\n{\r\nreturn (MB_IN32(bay, OHARE_MBCR) >> 12) & 7;\r\n}\r\nstatic u8\r\nheathrow_mb_content(struct media_bay_info *bay)\r\n{\r\nreturn (MB_IN32(bay, HEATHROW_MBCR) >> 12) & 7;\r\n}\r\nstatic u8\r\nkeylargo_mb_content(struct media_bay_info *bay)\r\n{\r\nint new_gpio;\r\nnew_gpio = MB_IN8(bay, KL_GPIO_MEDIABAY_IRQ) & KEYLARGO_GPIO_INPUT_DATA;\r\nif (new_gpio) {\r\nbay->cached_gpio = new_gpio;\r\nreturn MB_NO;\r\n} else if (bay->cached_gpio != new_gpio) {\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_ENABLE);\r\n(void)MB_IN32(bay, KEYLARGO_MBCR);\r\nudelay(5);\r\nMB_BIC(bay, KEYLARGO_MBCR, 0x0000000F);\r\n(void)MB_IN32(bay, KEYLARGO_MBCR);\r\nudelay(5);\r\nbay->cached_gpio = new_gpio;\r\n}\r\nreturn (MB_IN32(bay, KEYLARGO_MBCR) >> 4) & 7;\r\n}\r\nstatic void\r\nohare_mb_power(struct media_bay_info* bay, int on_off)\r\n{\r\nif (on_off) {\r\nMB_BIC(bay, OHARE_FCR, OH_BAY_RESET_N);\r\nMB_BIC(bay, OHARE_FCR, OH_BAY_POWER_N);\r\n} else {\r\nMB_BIC(bay, OHARE_FCR, OH_BAY_DEV_MASK);\r\nMB_BIC(bay, OHARE_FCR, OH_FLOPPY_ENABLE);\r\nMB_BIS(bay, OHARE_FCR, OH_BAY_POWER_N);\r\nMB_BIS(bay, OHARE_FCR, OH_BAY_RESET_N);\r\nMB_BIS(bay, OHARE_FCR, OH_IDE1_RESET_N);\r\n}\r\nMB_BIC(bay, OHARE_MBCR, 0x00000F00);\r\n}\r\nstatic void\r\nheathrow_mb_power(struct media_bay_info* bay, int on_off)\r\n{\r\nif (on_off) {\r\nMB_BIC(bay, HEATHROW_FCR, HRW_BAY_RESET_N);\r\nMB_BIC(bay, HEATHROW_FCR, HRW_BAY_POWER_N);\r\n} else {\r\nMB_BIC(bay, HEATHROW_FCR, HRW_BAY_DEV_MASK);\r\nMB_BIC(bay, HEATHROW_FCR, HRW_SWIM_ENABLE);\r\nMB_BIS(bay, HEATHROW_FCR, HRW_BAY_POWER_N);\r\nMB_BIS(bay, HEATHROW_FCR, HRW_BAY_RESET_N);\r\nMB_BIS(bay, HEATHROW_FCR, HRW_IDE1_RESET_N);\r\n}\r\nMB_BIC(bay, HEATHROW_MBCR, 0x00000F00);\r\n}\r\nstatic void\r\nkeylargo_mb_power(struct media_bay_info* bay, int on_off)\r\n{\r\nif (on_off) {\r\nMB_BIC(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_RESET);\r\nMB_BIC(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_POWER);\r\n} else {\r\nMB_BIC(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_MASK);\r\nMB_BIC(bay, KEYLARGO_FCR1, KL1_EIDE0_ENABLE);\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_POWER);\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_RESET);\r\nMB_BIS(bay, KEYLARGO_FCR1, KL1_EIDE0_RESET_N);\r\n}\r\nMB_BIC(bay, KEYLARGO_MBCR, 0x0000000F);\r\n}\r\nstatic int\r\nohare_mb_setup_bus(struct media_bay_info* bay, u8 device_id)\r\n{\r\nswitch(device_id) {\r\ncase MB_FD:\r\ncase MB_FD1:\r\nMB_BIS(bay, OHARE_FCR, OH_BAY_FLOPPY_ENABLE);\r\nMB_BIS(bay, OHARE_FCR, OH_FLOPPY_ENABLE);\r\nreturn 0;\r\ncase MB_CD:\r\nMB_BIC(bay, OHARE_FCR, OH_IDE1_RESET_N);\r\nMB_BIS(bay, OHARE_FCR, OH_BAY_IDE_ENABLE);\r\nreturn 0;\r\ncase MB_PCI:\r\nMB_BIS(bay, OHARE_FCR, OH_BAY_PCI_ENABLE);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nheathrow_mb_setup_bus(struct media_bay_info* bay, u8 device_id)\r\n{\r\nswitch(device_id) {\r\ncase MB_FD:\r\ncase MB_FD1:\r\nMB_BIS(bay, HEATHROW_FCR, HRW_BAY_FLOPPY_ENABLE);\r\nMB_BIS(bay, HEATHROW_FCR, HRW_SWIM_ENABLE);\r\nreturn 0;\r\ncase MB_CD:\r\nMB_BIC(bay, HEATHROW_FCR, HRW_IDE1_RESET_N);\r\nMB_BIS(bay, HEATHROW_FCR, HRW_BAY_IDE_ENABLE);\r\nreturn 0;\r\ncase MB_PCI:\r\nMB_BIS(bay, HEATHROW_FCR, HRW_BAY_PCI_ENABLE);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nkeylargo_mb_setup_bus(struct media_bay_info* bay, u8 device_id)\r\n{\r\nswitch(device_id) {\r\ncase MB_CD:\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_IDE_ENABLE);\r\nMB_BIC(bay, KEYLARGO_FCR1, KL1_EIDE0_RESET_N);\r\nMB_BIS(bay, KEYLARGO_FCR1, KL1_EIDE0_ENABLE);\r\nreturn 0;\r\ncase MB_PCI:\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_PCI_ENABLE);\r\nreturn 0;\r\ncase MB_SOUND:\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_SOUND_ENABLE);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nohare_mb_un_reset(struct media_bay_info* bay)\r\n{\r\nMB_BIS(bay, OHARE_FCR, OH_BAY_RESET_N);\r\n}\r\nstatic void keylargo_mb_init(struct media_bay_info *bay)\r\n{\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_ENABLE);\r\n}\r\nstatic void heathrow_mb_un_reset(struct media_bay_info* bay)\r\n{\r\nMB_BIS(bay, HEATHROW_FCR, HRW_BAY_RESET_N);\r\n}\r\nstatic void keylargo_mb_un_reset(struct media_bay_info* bay)\r\n{\r\nMB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_RESET);\r\n}\r\nstatic void ohare_mb_un_reset_ide(struct media_bay_info* bay)\r\n{\r\nMB_BIS(bay, OHARE_FCR, OH_IDE1_RESET_N);\r\n}\r\nstatic void heathrow_mb_un_reset_ide(struct media_bay_info* bay)\r\n{\r\nMB_BIS(bay, HEATHROW_FCR, HRW_IDE1_RESET_N);\r\n}\r\nstatic void keylargo_mb_un_reset_ide(struct media_bay_info* bay)\r\n{\r\nMB_BIS(bay, KEYLARGO_FCR1, KL1_EIDE0_RESET_N);\r\n}\r\nstatic inline void set_mb_power(struct media_bay_info* bay, int onoff)\r\n{\r\nif (onoff) {\r\nbay->ops->power(bay, 1);\r\nbay->state = mb_powering_up;\r\npr_debug("mediabay%d: powering up\n", bay->index);\r\n} else {\r\nbay->ops->power(bay, 0);\r\nbay->state = mb_powering_down;\r\npr_debug("mediabay%d: powering down\n", bay->index);\r\n}\r\nbay->timer = msecs_to_jiffies(MB_POWER_DELAY);\r\n}\r\nstatic void poll_media_bay(struct media_bay_info* bay)\r\n{\r\nint id = bay->ops->content(bay);\r\nstatic char *mb_content_types[] = {\r\n"a floppy drive",\r\n"a floppy drive",\r\n"an unsuported audio device",\r\n"an ATA device",\r\n"an unsupported PCI device",\r\n"an unknown device",\r\n};\r\nif (id != bay->last_value) {\r\nbay->last_value = id;\r\nbay->value_count = 0;\r\nreturn;\r\n}\r\nif (id == bay->content_id)\r\nreturn;\r\nbay->value_count += msecs_to_jiffies(MB_POLL_DELAY);\r\nif (bay->value_count >= msecs_to_jiffies(MB_STABLE_DELAY)) {\r\nif ((id != MB_NO) && (bay->content_id != MB_NO)) {\r\nid = MB_NO;\r\npr_debug("mediabay%d: forcing MB_NO\n", bay->index);\r\n}\r\npr_debug("mediabay%d: switching to %d\n", bay->index, id);\r\nset_mb_power(bay, id != MB_NO);\r\nbay->content_id = id;\r\nif (id >= MB_NO || id < 0)\r\nprintk(KERN_INFO "mediabay%d: Bay is now empty\n", bay->index);\r\nelse\r\nprintk(KERN_INFO "mediabay%d: Bay contains %s\n",\r\nbay->index, mb_content_types[id]);\r\n}\r\n}\r\nint check_media_bay(struct macio_dev *baydev)\r\n{\r\nstruct media_bay_info* bay;\r\nint id;\r\nif (baydev == NULL)\r\nreturn MB_NO;\r\nbay = macio_get_drvdata(baydev);\r\nif (bay == NULL)\r\nreturn MB_NO;\r\nid = bay->content_id;\r\nif (bay->state != mb_up)\r\nreturn MB_NO;\r\nif (id == MB_FD1)\r\nreturn MB_FD;\r\nreturn id;\r\n}\r\nvoid lock_media_bay(struct macio_dev *baydev)\r\n{\r\nstruct media_bay_info* bay;\r\nif (baydev == NULL)\r\nreturn;\r\nbay = macio_get_drvdata(baydev);\r\nif (bay == NULL)\r\nreturn;\r\nmutex_lock(&bay->lock);\r\nbay->user_lock = 1;\r\n}\r\nvoid unlock_media_bay(struct macio_dev *baydev)\r\n{\r\nstruct media_bay_info* bay;\r\nif (baydev == NULL)\r\nreturn;\r\nbay = macio_get_drvdata(baydev);\r\nif (bay == NULL)\r\nreturn;\r\nif (bay->user_lock) {\r\nbay->user_lock = 0;\r\nmutex_unlock(&bay->lock);\r\n}\r\n}\r\nstatic int mb_broadcast_hotplug(struct device *dev, void *data)\r\n{\r\nstruct media_bay_info* bay = data;\r\nstruct macio_dev *mdev;\r\nstruct macio_driver *drv;\r\nint state;\r\nif (dev->bus != &macio_bus_type)\r\nreturn 0;\r\nstate = bay->state == mb_up ? bay->content_id : MB_NO;\r\nif (state == MB_FD1)\r\nstate = MB_FD;\r\nmdev = to_macio_device(dev);\r\ndrv = to_macio_driver(dev->driver);\r\nif (dev->driver && drv->mediabay_event)\r\ndrv->mediabay_event(mdev, state);\r\nreturn 0;\r\n}\r\nstatic void media_bay_step(int i)\r\n{\r\nstruct media_bay_info* bay = &media_bays[i];\r\nif (bay->state != mb_powering_down)\r\npoll_media_bay(bay);\r\nif (bay->timer != 0) {\r\nbay->timer -= msecs_to_jiffies(MB_POLL_DELAY);\r\nif (bay->timer > 0)\r\nreturn;\r\nbay->timer = 0;\r\n}\r\nswitch(bay->state) {\r\ncase mb_powering_up:\r\nif (bay->ops->setup_bus(bay, bay->last_value) < 0) {\r\npr_debug("mediabay%d: device not supported (kind:%d)\n",\r\ni, bay->content_id);\r\nset_mb_power(bay, 0);\r\nbreak;\r\n}\r\nbay->timer = msecs_to_jiffies(MB_RESET_DELAY);\r\nbay->state = mb_enabling_bay;\r\npr_debug("mediabay%d: enabling (kind:%d)\n", i, bay->content_id);\r\nbreak;\r\ncase mb_enabling_bay:\r\nbay->ops->un_reset(bay);\r\nbay->timer = msecs_to_jiffies(MB_SETUP_DELAY);\r\nbay->state = mb_resetting;\r\npr_debug("mediabay%d: releasing bay reset (kind:%d)\n",\r\ni, bay->content_id);\r\nbreak;\r\ncase mb_resetting:\r\nif (bay->content_id != MB_CD) {\r\npr_debug("mediabay%d: bay is up (kind:%d)\n", i,\r\nbay->content_id);\r\nbay->state = mb_up;\r\ndevice_for_each_child(&bay->mdev->ofdev.dev,\r\nbay, mb_broadcast_hotplug);\r\nbreak;\r\n}\r\npr_debug("mediabay%d: releasing ATA reset (kind:%d)\n",\r\ni, bay->content_id);\r\nbay->ops->un_reset_ide(bay);\r\nbay->timer = msecs_to_jiffies(MB_IDE_WAIT);\r\nbay->state = mb_ide_resetting;\r\nbreak;\r\ncase mb_ide_resetting:\r\npr_debug("mediabay%d: bay is up (kind:%d)\n", i, bay->content_id);\r\nbay->state = mb_up;\r\ndevice_for_each_child(&bay->mdev->ofdev.dev,\r\nbay, mb_broadcast_hotplug);\r\nbreak;\r\ncase mb_powering_down:\r\nbay->state = mb_empty;\r\ndevice_for_each_child(&bay->mdev->ofdev.dev,\r\nbay, mb_broadcast_hotplug);\r\npr_debug("mediabay%d: end of power down\n", i);\r\nbreak;\r\n}\r\n}\r\nstatic int media_bay_task(void *x)\r\n{\r\nint i;\r\nwhile (!kthread_should_stop()) {\r\nfor (i = 0; i < media_bay_count; ++i) {\r\nmutex_lock(&media_bays[i].lock);\r\nif (!media_bays[i].sleeping)\r\nmedia_bay_step(i);\r\nmutex_unlock(&media_bays[i].lock);\r\n}\r\nmsleep_interruptible(MB_POLL_DELAY);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit media_bay_attach(struct macio_dev *mdev, const struct of_device_id *match)\r\n{\r\nstruct media_bay_info* bay;\r\nu32 __iomem *regbase;\r\nstruct device_node *ofnode;\r\nunsigned long base;\r\nint i;\r\nofnode = mdev->ofdev.dev.of_node;\r\nif (macio_resource_count(mdev) < 1)\r\nreturn -ENODEV;\r\nif (macio_request_resources(mdev, "media-bay"))\r\nreturn -EBUSY;\r\nbase = macio_resource_start(mdev, 0) & 0xffff0000u;\r\nregbase = (u32 __iomem *)ioremap(base, 0x100);\r\nif (regbase == NULL) {\r\nmacio_release_resources(mdev);\r\nreturn -ENOMEM;\r\n}\r\ni = media_bay_count++;\r\nbay = &media_bays[i];\r\nbay->mdev = mdev;\r\nbay->base = regbase;\r\nbay->index = i;\r\nbay->ops = match->data;\r\nbay->sleeping = 0;\r\nmutex_init(&bay->lock);\r\nif (bay->ops->init)\r\nbay->ops->init(bay);\r\nprintk(KERN_INFO "mediabay%d: Registered %s media-bay\n", i, bay->ops->name);\r\nset_mb_power(bay, 0);\r\nmsleep(MB_POWER_DELAY);\r\nbay->content_id = MB_NO;\r\nbay->last_value = bay->ops->content(bay);\r\nbay->value_count = msecs_to_jiffies(MB_STABLE_DELAY);\r\nbay->state = mb_empty;\r\nmacio_set_drvdata(mdev, bay);\r\nif (i == 0)\r\nkthread_run(media_bay_task, NULL, "media-bay");\r\nreturn 0;\r\n}\r\nstatic int media_bay_suspend(struct macio_dev *mdev, pm_message_t state)\r\n{\r\nstruct media_bay_info *bay = macio_get_drvdata(mdev);\r\nif (state.event != mdev->ofdev.dev.power.power_state.event\r\n&& (state.event & PM_EVENT_SLEEP)) {\r\nmutex_lock(&bay->lock);\r\nbay->sleeping = 1;\r\nset_mb_power(bay, 0);\r\nmutex_unlock(&bay->lock);\r\nmsleep(MB_POLL_DELAY);\r\nmdev->ofdev.dev.power.power_state = state;\r\n}\r\nreturn 0;\r\n}\r\nstatic int media_bay_resume(struct macio_dev *mdev)\r\n{\r\nstruct media_bay_info *bay = macio_get_drvdata(mdev);\r\nif (mdev->ofdev.dev.power.power_state.event != PM_EVENT_ON) {\r\nmdev->ofdev.dev.power.power_state = PMSG_ON;\r\nmutex_lock(&bay->lock);\r\nset_mb_power(bay, 0);\r\nmsleep(MB_POWER_DELAY);\r\nif (bay->ops->content(bay) != bay->content_id) {\r\nprintk("mediabay%d: Content changed during sleep...\n", bay->index);\r\nmutex_unlock(&bay->lock);\r\nreturn 0;\r\n}\r\nset_mb_power(bay, 1);\r\nbay->last_value = bay->content_id;\r\nbay->value_count = msecs_to_jiffies(MB_STABLE_DELAY);\r\nbay->timer = msecs_to_jiffies(MB_POWER_DELAY);\r\ndo {\r\nmsleep(MB_POLL_DELAY);\r\nmedia_bay_step(bay->index);\r\n} while((bay->state != mb_empty) &&\r\n(bay->state != mb_up));\r\nbay->sleeping = 0;\r\nmutex_unlock(&bay->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init media_bay_init(void)\r\n{\r\nint i;\r\nfor (i=0; i<MAX_BAYS; i++) {\r\nmemset((char *)&media_bays[i], 0, sizeof(struct media_bay_info));\r\nmedia_bays[i].content_id = -1;\r\n}\r\nif (!machine_is(powermac))\r\nreturn 0;\r\nmacio_register_driver(&media_bay_driver);\r\nreturn 0;\r\n}
