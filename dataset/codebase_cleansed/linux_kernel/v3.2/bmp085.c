static s32 bmp085_read_calibration_data(struct i2c_client *client)\r\n{\r\nu16 tmp[BMP085_CALIBRATION_DATA_LENGTH];\r\nstruct bmp085_data *data = i2c_get_clientdata(client);\r\nstruct bmp085_calibration_data *cali = &(data->calibration);\r\ns32 status = i2c_smbus_read_i2c_block_data(client,\r\nBMP085_CALIBRATION_DATA_START,\r\nBMP085_CALIBRATION_DATA_LENGTH*sizeof(u16),\r\n(u8 *)tmp);\r\nif (status < 0)\r\nreturn status;\r\nif (status != BMP085_CALIBRATION_DATA_LENGTH*sizeof(u16))\r\nreturn -EIO;\r\ncali->AC1 = be16_to_cpu(tmp[0]);\r\ncali->AC2 = be16_to_cpu(tmp[1]);\r\ncali->AC3 = be16_to_cpu(tmp[2]);\r\ncali->AC4 = be16_to_cpu(tmp[3]);\r\ncali->AC5 = be16_to_cpu(tmp[4]);\r\ncali->AC6 = be16_to_cpu(tmp[5]);\r\ncali->B1 = be16_to_cpu(tmp[6]);\r\ncali->B2 = be16_to_cpu(tmp[7]);\r\ncali->MB = be16_to_cpu(tmp[8]);\r\ncali->MC = be16_to_cpu(tmp[9]);\r\ncali->MD = be16_to_cpu(tmp[10]);\r\nreturn 0;\r\n}\r\nstatic s32 bmp085_update_raw_temperature(struct bmp085_data *data)\r\n{\r\nu16 tmp;\r\ns32 status;\r\nmutex_lock(&data->lock);\r\nstatus = i2c_smbus_write_byte_data(data->client, BMP085_CTRL_REG,\r\nBMP085_TEMP_MEASUREMENT);\r\nif (status != 0) {\r\ndev_err(&data->client->dev,\r\n"Error while requesting temperature measurement.\n");\r\ngoto exit;\r\n}\r\nmsleep(BMP085_TEMP_CONVERSION_TIME);\r\nstatus = i2c_smbus_read_i2c_block_data(data->client,\r\nBMP085_CONVERSION_REGISTER_MSB, sizeof(tmp), (u8 *)&tmp);\r\nif (status < 0)\r\ngoto exit;\r\nif (status != sizeof(tmp)) {\r\ndev_err(&data->client->dev,\r\n"Error while reading temperature measurement result\n");\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\ndata->raw_temperature = be16_to_cpu(tmp);\r\ndata->last_temp_measurement = jiffies;\r\nstatus = 0;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn status;\r\n}\r\nstatic s32 bmp085_update_raw_pressure(struct bmp085_data *data)\r\n{\r\nu32 tmp = 0;\r\ns32 status;\r\nmutex_lock(&data->lock);\r\nstatus = i2c_smbus_write_byte_data(data->client, BMP085_CTRL_REG,\r\nBMP085_PRESSURE_MEASUREMENT + (data->oversampling_setting<<6));\r\nif (status != 0) {\r\ndev_err(&data->client->dev,\r\n"Error while requesting pressure measurement.\n");\r\ngoto exit;\r\n}\r\nmsleep(2+(3 << data->oversampling_setting));\r\nstatus = i2c_smbus_read_i2c_block_data(data->client,\r\nBMP085_CONVERSION_REGISTER_MSB, 3, ((u8 *)&tmp)+1);\r\nif (status < 0)\r\ngoto exit;\r\nif (status != 3) {\r\ndev_err(&data->client->dev,\r\n"Error while reading pressure measurement results\n");\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\ndata->raw_pressure = be32_to_cpu((tmp));\r\ndata->raw_pressure >>= (8-data->oversampling_setting);\r\nstatus = 0;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn status;\r\n}\r\nstatic s32 bmp085_get_temperature(struct bmp085_data *data, int *temperature)\r\n{\r\nstruct bmp085_calibration_data *cali = &data->calibration;\r\nlong x1, x2;\r\nint status;\r\nstatus = bmp085_update_raw_temperature(data);\r\nif (status != 0)\r\ngoto exit;\r\nx1 = ((data->raw_temperature - cali->AC6) * cali->AC5) >> 15;\r\nx2 = (cali->MC << 11) / (x1 + cali->MD);\r\ndata->b6 = x1 + x2 - 4000;\r\nif (temperature != NULL)\r\n*temperature = (x1+x2+8) >> 4;\r\nexit:\r\nreturn status;;\r\n}\r\nstatic s32 bmp085_get_pressure(struct bmp085_data *data, int *pressure)\r\n{\r\nstruct bmp085_calibration_data *cali = &data->calibration;\r\ns32 x1, x2, x3, b3;\r\nu32 b4, b7;\r\ns32 p;\r\nint status;\r\nif (data->last_temp_measurement + 1*HZ < jiffies) {\r\nstatus = bmp085_get_temperature(data, NULL);\r\nif (status != 0)\r\ngoto exit;\r\n}\r\nstatus = bmp085_update_raw_pressure(data);\r\nif (status != 0)\r\ngoto exit;\r\nx1 = (data->b6 * data->b6) >> 12;\r\nx1 *= cali->B2;\r\nx1 >>= 11;\r\nx2 = cali->AC2 * data->b6;\r\nx2 >>= 11;\r\nx3 = x1 + x2;\r\nb3 = (((((s32)cali->AC1) * 4 + x3) << data->oversampling_setting) + 2);\r\nb3 >>= 2;\r\nx1 = (cali->AC3 * data->b6) >> 13;\r\nx2 = (cali->B1 * ((data->b6 * data->b6) >> 12)) >> 16;\r\nx3 = (x1 + x2 + 2) >> 2;\r\nb4 = (cali->AC4 * (u32)(x3 + 32768)) >> 15;\r\nb7 = ((u32)data->raw_pressure - b3) *\r\n(50000 >> data->oversampling_setting);\r\np = ((b7 < 0x80000000) ? ((b7 << 1) / b4) : ((b7 / b4) * 2));\r\nx1 = p >> 8;\r\nx1 *= x1;\r\nx1 = (x1 * 3038) >> 16;\r\nx2 = (-7357 * p) >> 16;\r\np += (x1 + x2 + 3791) >> 4;\r\n*pressure = p;\r\nexit:\r\nreturn status;\r\n}\r\nstatic void bmp085_set_oversampling(struct bmp085_data *data,\r\nunsigned char oversampling)\r\n{\r\nif (oversampling > 3)\r\noversampling = 3;\r\ndata->oversampling_setting = oversampling;\r\n}\r\nstatic unsigned char bmp085_get_oversampling(struct bmp085_data *data)\r\n{\r\nreturn data->oversampling_setting;\r\n}\r\nstatic ssize_t set_oversampling(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bmp085_data *data = i2c_get_clientdata(client);\r\nunsigned long oversampling;\r\nint success = strict_strtoul(buf, 10, &oversampling);\r\nif (success == 0) {\r\nbmp085_set_oversampling(data, oversampling);\r\nreturn count;\r\n}\r\nreturn success;\r\n}\r\nstatic ssize_t show_oversampling(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bmp085_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%u\n", bmp085_get_oversampling(data));\r\n}\r\nstatic ssize_t show_temperature(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint temperature;\r\nint status;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bmp085_data *data = i2c_get_clientdata(client);\r\nstatus = bmp085_get_temperature(data, &temperature);\r\nif (status != 0)\r\nreturn status;\r\nelse\r\nreturn sprintf(buf, "%d\n", temperature);\r\n}\r\nstatic ssize_t show_pressure(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint pressure;\r\nint status;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bmp085_data *data = i2c_get_clientdata(client);\r\nstatus = bmp085_get_pressure(data, &pressure);\r\nif (status != 0)\r\nreturn status;\r\nelse\r\nreturn sprintf(buf, "%d\n", pressure);\r\n}\r\nstatic int bmp085_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nif (client->addr != BMP085_I2C_ADDRESS)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, BMP085_CHIP_ID_REG) != BMP085_CHIP_ID)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int bmp085_init_client(struct i2c_client *client)\r\n{\r\nunsigned char version;\r\nint status;\r\nstruct bmp085_data *data = i2c_get_clientdata(client);\r\ndata->client = client;\r\nstatus = bmp085_read_calibration_data(client);\r\nif (status != 0)\r\ngoto exit;\r\nversion = i2c_smbus_read_byte_data(client, BMP085_VERSION_REG);\r\ndata->last_temp_measurement = 0;\r\ndata->oversampling_setting = 3;\r\nmutex_init(&data->lock);\r\ndev_info(&data->client->dev, "BMP085 ver. %d.%d found.\n",\r\n(version & 0x0F), (version & 0xF0) >> 4);\r\nexit:\r\nreturn status;\r\n}\r\nstatic int __devinit bmp085_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bmp085_data *data;\r\nint err = 0;\r\ndata = kzalloc(sizeof(struct bmp085_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->oversampling_setting = 0x00;\r\ni2c_set_clientdata(client, data);\r\nerr = bmp085_init_client(client);\r\nif (err != 0)\r\ngoto exit_free;\r\nerr = sysfs_create_group(&client->dev.kobj, &bmp085_attr_group);\r\nif (err)\r\ngoto exit_free;\r\ndev_info(&data->client->dev, "Successfully initialized bmp085!\n");\r\ngoto exit;\r\nexit_free:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit bmp085_remove(struct i2c_client *client)\r\n{\r\nsysfs_remove_group(&client->dev.kobj, &bmp085_attr_group);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init bmp085_init(void)\r\n{\r\nreturn i2c_add_driver(&bmp085_driver);\r\n}\r\nstatic void __exit bmp085_exit(void)\r\n{\r\ni2c_del_driver(&bmp085_driver);\r\n}
