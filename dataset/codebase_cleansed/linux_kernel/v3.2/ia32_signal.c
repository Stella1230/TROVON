int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)\r\n{\r\nint err = 0;\r\nif (!access_ok(VERIFY_WRITE, to, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nput_user_try {\r\nput_user_ex(from->si_signo, &to->si_signo);\r\nput_user_ex(from->si_errno, &to->si_errno);\r\nput_user_ex((short)from->si_code, &to->si_code);\r\nif (from->si_code < 0) {\r\nput_user_ex(from->si_pid, &to->si_pid);\r\nput_user_ex(from->si_uid, &to->si_uid);\r\nput_user_ex(ptr_to_compat(from->si_ptr), &to->si_ptr);\r\n} else {\r\nput_user_ex(from->_sifields._pad[0],\r\n&to->_sifields._pad[0]);\r\nswitch (from->si_code >> 16) {\r\ncase __SI_FAULT >> 16:\r\nbreak;\r\ncase __SI_CHLD >> 16:\r\nput_user_ex(from->si_utime, &to->si_utime);\r\nput_user_ex(from->si_stime, &to->si_stime);\r\nput_user_ex(from->si_status, &to->si_status);\r\ndefault:\r\ncase __SI_KILL >> 16:\r\nput_user_ex(from->si_uid, &to->si_uid);\r\nbreak;\r\ncase __SI_POLL >> 16:\r\nput_user_ex(from->si_fd, &to->si_fd);\r\nbreak;\r\ncase __SI_TIMER >> 16:\r\nput_user_ex(from->si_overrun, &to->si_overrun);\r\nput_user_ex(ptr_to_compat(from->si_ptr),\r\n&to->si_ptr);\r\nbreak;\r\ncase __SI_RT >> 16:\r\ncase __SI_MESGQ >> 16:\r\nput_user_ex(from->si_uid, &to->si_uid);\r\nput_user_ex(from->si_int, &to->si_int);\r\nbreak;\r\n}\r\n}\r\n} put_user_catch(err);\r\nreturn err;\r\n}\r\nint copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)\r\n{\r\nint err = 0;\r\nu32 ptr32;\r\nif (!access_ok(VERIFY_READ, from, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nget_user_try {\r\nget_user_ex(to->si_signo, &from->si_signo);\r\nget_user_ex(to->si_errno, &from->si_errno);\r\nget_user_ex(to->si_code, &from->si_code);\r\nget_user_ex(to->si_pid, &from->si_pid);\r\nget_user_ex(to->si_uid, &from->si_uid);\r\nget_user_ex(ptr32, &from->si_ptr);\r\nto->si_ptr = compat_ptr(ptr32);\r\n} get_user_catch(err);\r\nreturn err;\r\n}\r\nasmlinkage long sys32_sigsuspend(int history0, int history1, old_sigset_t mask)\r\n{\r\nsigset_t blocked;\r\ncurrent->saved_sigmask = current->blocked;\r\nmask &= _BLOCKABLE;\r\nsiginitset(&blocked, mask);\r\nset_current_blocked(&blocked);\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule();\r\nset_restore_sigmask();\r\nreturn -ERESTARTNOHAND;\r\n}\r\nasmlinkage long sys32_sigaltstack(const stack_ia32_t __user *uss_ptr,\r\nstack_ia32_t __user *uoss_ptr,\r\nstruct pt_regs *regs)\r\n{\r\nstack_t uss, uoss;\r\nint ret, err = 0;\r\nmm_segment_t seg;\r\nif (uss_ptr) {\r\nu32 ptr;\r\nmemset(&uss, 0, sizeof(stack_t));\r\nif (!access_ok(VERIFY_READ, uss_ptr, sizeof(stack_ia32_t)))\r\nreturn -EFAULT;\r\nget_user_try {\r\nget_user_ex(ptr, &uss_ptr->ss_sp);\r\nget_user_ex(uss.ss_flags, &uss_ptr->ss_flags);\r\nget_user_ex(uss.ss_size, &uss_ptr->ss_size);\r\n} get_user_catch(err);\r\nif (err)\r\nreturn -EFAULT;\r\nuss.ss_sp = compat_ptr(ptr);\r\n}\r\nseg = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss, regs->sp);\r\nset_fs(seg);\r\nif (ret >= 0 && uoss_ptr) {\r\nif (!access_ok(VERIFY_WRITE, uoss_ptr, sizeof(stack_ia32_t)))\r\nreturn -EFAULT;\r\nput_user_try {\r\nput_user_ex(ptr_to_compat(uoss.ss_sp), &uoss_ptr->ss_sp);\r\nput_user_ex(uoss.ss_flags, &uoss_ptr->ss_flags);\r\nput_user_ex(uoss.ss_size, &uoss_ptr->ss_size);\r\n} put_user_catch(err);\r\nif (err)\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ia32_restore_sigcontext(struct pt_regs *regs,\r\nstruct sigcontext_ia32 __user *sc,\r\nunsigned int *pax)\r\n{\r\nunsigned int tmpflags, err = 0;\r\nvoid __user *buf;\r\nu32 tmp;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nget_user_try {\r\nRELOAD_SEG(gs);\r\nRELOAD_SEG(fs);\r\nRELOAD_SEG(ds);\r\nRELOAD_SEG(es);\r\nCOPY(di); COPY(si); COPY(bp); COPY(sp); COPY(bx);\r\nCOPY(dx); COPY(cx); COPY(ip);\r\nCOPY_SEG_CPL3(cs);\r\nCOPY_SEG_CPL3(ss);\r\nget_user_ex(tmpflags, &sc->flags);\r\nregs->flags = (regs->flags & ~FIX_EFLAGS) | (tmpflags & FIX_EFLAGS);\r\nregs->orig_ax = -1;\r\nget_user_ex(tmp, &sc->fpstate);\r\nbuf = compat_ptr(tmp);\r\nerr |= restore_i387_xstate_ia32(buf);\r\nget_user_ex(*pax, &sc->ax);\r\n} get_user_catch(err);\r\nreturn err;\r\n}\r\nasmlinkage long sys32_sigreturn(struct pt_regs *regs)\r\n{\r\nstruct sigframe_ia32 __user *frame = (struct sigframe_ia32 __user *)(regs->sp-8);\r\nsigset_t set;\r\nunsigned int ax;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__get_user(set.sig[0], &frame->sc.oldmask)\r\n|| (_COMPAT_NSIG_WORDS > 1\r\n&& __copy_from_user((((char *) &set.sig) + 4),\r\n&frame->extramask,\r\nsizeof(frame->extramask))))\r\ngoto badframe;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\nset_current_blocked(&set);\r\nif (ia32_restore_sigcontext(regs, &frame->sc, &ax))\r\ngoto badframe;\r\nreturn ax;\r\nbadframe:\r\nsignal_fault(regs, frame, "32bit sigreturn");\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_rt_sigreturn(struct pt_regs *regs)\r\n{\r\nstruct rt_sigframe_ia32 __user *frame;\r\nsigset_t set;\r\nunsigned int ax;\r\nstruct pt_regs tregs;\r\nframe = (struct rt_sigframe_ia32 __user *)(regs->sp - 4);\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\nset_current_blocked(&set);\r\nif (ia32_restore_sigcontext(regs, &frame->uc.uc_mcontext, &ax))\r\ngoto badframe;\r\ntregs = *regs;\r\nif (sys32_sigaltstack(&frame->uc.uc_stack, NULL, &tregs) == -EFAULT)\r\ngoto badframe;\r\nreturn ax;\r\nbadframe:\r\nsignal_fault(regs, frame, "32bit rt sigreturn");\r\nreturn 0;\r\n}\r\nstatic int ia32_setup_sigcontext(struct sigcontext_ia32 __user *sc,\r\nvoid __user *fpstate,\r\nstruct pt_regs *regs, unsigned int mask)\r\n{\r\nint err = 0;\r\nput_user_try {\r\nput_user_ex(get_user_seg(gs), (unsigned int __user *)&sc->gs);\r\nput_user_ex(get_user_seg(fs), (unsigned int __user *)&sc->fs);\r\nput_user_ex(get_user_seg(ds), (unsigned int __user *)&sc->ds);\r\nput_user_ex(get_user_seg(es), (unsigned int __user *)&sc->es);\r\nput_user_ex(regs->di, &sc->di);\r\nput_user_ex(regs->si, &sc->si);\r\nput_user_ex(regs->bp, &sc->bp);\r\nput_user_ex(regs->sp, &sc->sp);\r\nput_user_ex(regs->bx, &sc->bx);\r\nput_user_ex(regs->dx, &sc->dx);\r\nput_user_ex(regs->cx, &sc->cx);\r\nput_user_ex(regs->ax, &sc->ax);\r\nput_user_ex(current->thread.trap_no, &sc->trapno);\r\nput_user_ex(current->thread.error_code, &sc->err);\r\nput_user_ex(regs->ip, &sc->ip);\r\nput_user_ex(regs->cs, (unsigned int __user *)&sc->cs);\r\nput_user_ex(regs->flags, &sc->flags);\r\nput_user_ex(regs->sp, &sc->sp_at_signal);\r\nput_user_ex(regs->ss, (unsigned int __user *)&sc->ss);\r\nput_user_ex(ptr_to_compat(fpstate), &sc->fpstate);\r\nput_user_ex(mask, &sc->oldmask);\r\nput_user_ex(current->thread.cr2, &sc->cr2);\r\n} put_user_catch(err);\r\nreturn err;\r\n}\r\nstatic void __user *get_sigframe(struct k_sigaction *ka, struct pt_regs *regs,\r\nsize_t frame_size,\r\nvoid **fpstate)\r\n{\r\nunsigned long sp;\r\nsp = regs->sp;\r\nif (ka->sa.sa_flags & SA_ONSTACK) {\r\nif (sas_ss_flags(sp) == 0)\r\nsp = current->sas_ss_sp + current->sas_ss_size;\r\n}\r\nelse if ((regs->ss & 0xffff) != __USER32_DS &&\r\n!(ka->sa.sa_flags & SA_RESTORER) &&\r\nka->sa.sa_restorer)\r\nsp = (unsigned long) ka->sa.sa_restorer;\r\nif (used_math()) {\r\nsp = sp - sig_xstate_ia32_size;\r\n*fpstate = (struct _fpstate_ia32 *) sp;\r\nif (save_i387_xstate_ia32(*fpstate) < 0)\r\nreturn (void __user *) -1L;\r\n}\r\nsp -= frame_size;\r\nsp = ((sp + 4) & -16ul) - 4;\r\nreturn (void __user *) sp;\r\n}\r\nint ia32_setup_frame(int sig, struct k_sigaction *ka,\r\ncompat_sigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct sigframe_ia32 __user *frame;\r\nvoid __user *restorer;\r\nint err = 0;\r\nvoid __user *fpstate = NULL;\r\nstatic const struct {\r\nu16 poplmovl;\r\nu32 val;\r\nu16 int80;\r\n} __attribute__((packed)) code = {\r\n0xb858,\r\n__NR_ia32_sigreturn,\r\n0x80cd,\r\n};\r\nframe = get_sigframe(ka, regs, sizeof(*frame), &fpstate);\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nif (__put_user(sig, &frame->sig))\r\nreturn -EFAULT;\r\nif (ia32_setup_sigcontext(&frame->sc, fpstate, regs, set->sig[0]))\r\nreturn -EFAULT;\r\nif (_COMPAT_NSIG_WORDS > 1) {\r\nif (__copy_to_user(frame->extramask, &set->sig[1],\r\nsizeof(frame->extramask)))\r\nreturn -EFAULT;\r\n}\r\nif (ka->sa.sa_flags & SA_RESTORER) {\r\nrestorer = ka->sa.sa_restorer;\r\n} else {\r\nif (current->mm->context.vdso)\r\nrestorer = VDSO32_SYMBOL(current->mm->context.vdso,\r\nsigreturn);\r\nelse\r\nrestorer = &frame->retcode;\r\n}\r\nput_user_try {\r\nput_user_ex(ptr_to_compat(restorer), &frame->pretcode);\r\nput_user_ex(*((u64 *)&code), (u64 *)frame->retcode);\r\n} put_user_catch(err);\r\nif (err)\r\nreturn -EFAULT;\r\nregs->sp = (unsigned long) frame;\r\nregs->ip = (unsigned long) ka->sa.sa_handler;\r\nregs->ax = sig;\r\nregs->dx = 0;\r\nregs->cx = 0;\r\nloadsegment(ds, __USER32_DS);\r\nloadsegment(es, __USER32_DS);\r\nregs->cs = __USER32_CS;\r\nregs->ss = __USER32_DS;\r\nreturn 0;\r\n}\r\nint ia32_setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\r\ncompat_sigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct rt_sigframe_ia32 __user *frame;\r\nvoid __user *restorer;\r\nint err = 0;\r\nvoid __user *fpstate = NULL;\r\nstatic const struct {\r\nu8 movl;\r\nu32 val;\r\nu16 int80;\r\nu8 pad;\r\n} __attribute__((packed)) code = {\r\n0xb8,\r\n__NR_ia32_rt_sigreturn,\r\n0x80cd,\r\n0,\r\n};\r\nframe = get_sigframe(ka, regs, sizeof(*frame), &fpstate);\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\nreturn -EFAULT;\r\nput_user_try {\r\nput_user_ex(sig, &frame->sig);\r\nput_user_ex(ptr_to_compat(&frame->info), &frame->pinfo);\r\nput_user_ex(ptr_to_compat(&frame->uc), &frame->puc);\r\nerr |= copy_siginfo_to_user32(&frame->info, info);\r\nif (cpu_has_xsave)\r\nput_user_ex(UC_FP_XSTATE, &frame->uc.uc_flags);\r\nelse\r\nput_user_ex(0, &frame->uc.uc_flags);\r\nput_user_ex(0, &frame->uc.uc_link);\r\nput_user_ex(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\r\nput_user_ex(sas_ss_flags(regs->sp),\r\n&frame->uc.uc_stack.ss_flags);\r\nput_user_ex(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\r\nerr |= ia32_setup_sigcontext(&frame->uc.uc_mcontext, fpstate,\r\nregs, set->sig[0]);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (ka->sa.sa_flags & SA_RESTORER)\r\nrestorer = ka->sa.sa_restorer;\r\nelse\r\nrestorer = VDSO32_SYMBOL(current->mm->context.vdso,\r\nrt_sigreturn);\r\nput_user_ex(ptr_to_compat(restorer), &frame->pretcode);\r\nput_user_ex(*((u64 *)&code), (u64 *)frame->retcode);\r\n} put_user_catch(err);\r\nif (err)\r\nreturn -EFAULT;\r\nregs->sp = (unsigned long) frame;\r\nregs->ip = (unsigned long) ka->sa.sa_handler;\r\nregs->ax = sig;\r\nregs->dx = (unsigned long) &frame->info;\r\nregs->cx = (unsigned long) &frame->uc;\r\nloadsegment(ds, __USER32_DS);\r\nloadsegment(es, __USER32_DS);\r\nregs->cs = __USER32_CS;\r\nregs->ss = __USER32_DS;\r\nreturn 0;\r\n}
