static inline u8\r\nFAN_TO_REG(long rpm, int div)\r\n{\r\nif (rpm == 0)\r\nreturn 255;\r\nrpm = SENSORS_LIMIT(rpm, 1, 1000000);\r\nreturn SENSORS_LIMIT((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic inline u8\r\nDIV_TO_REG(long val)\r\n{\r\nint i;\r\nval = SENSORS_LIMIT(val, 1, 128) >> 1;\r\nfor (i = 0; i < 7; i++) {\r\nif (val == 0)\r\nbreak;\r\nval >>= 1;\r\n}\r\nreturn ((u8) i);\r\n}\r\nstatic inline long in_count_from_reg(int nr, struct w83792d_data *data)\r\n{\r\nreturn ((data->in[nr] << 2) | ((data->low_bits >> (2 * nr)) & 0x03));\r\n}\r\nstatic inline int w83792d_read_value(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline int\r\nw83792d_write_value(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf,"%ld\n", IN_FROM_REG(nr,(in_count_from_reg(nr, data))));\r\n}\r\nstatic ssize_t\r\nstore_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index - 1;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nw83792d_write_value(client, W83792D_REG_FAN_MIN[nr],\r\ndata->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan_div(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%u\n", DIV_FROM_REG(data->fan_div[nr - 1]));\r\n}\r\nstatic ssize_t\r\nstore_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index - 1;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nunsigned long min;\r\nu8 fan_div_reg = 0;\r\nu8 tmp_fan_div;\r\nmutex_lock(&data->update_lock);\r\nmin = FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr]));\r\ndata->fan_div[nr] = DIV_TO_REG(simple_strtoul(buf, NULL, 10));\r\nfan_div_reg = w83792d_read_value(client, W83792D_REG_FAN_DIV[nr >> 1]);\r\nfan_div_reg &= (nr & 0x01) ? 0x8f : 0xf8;\r\ntmp_fan_div = (nr & 0x01) ? (((data->fan_div[nr]) << 4) & 0x70)\r\n: ((data->fan_div[nr]) & 0x07);\r\nw83792d_write_value(client, W83792D_REG_FAN_DIV[nr >> 1],\r\nfan_div_reg | tmp_fan_div);\r\ndata->fan_min[nr] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\r\nw83792d_write_value(client, W83792D_REG_FAN_MIN[nr], data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp1(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP1_FROM_REG(data->temp1[nr]));\r\n}\r\nstatic ssize_t store_temp1(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\ns32 val;\r\nval = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->temp1[nr] = TEMP1_TO_REG(val);\r\nw83792d_write_value(client, W83792D_REG_TEMP1[nr],\r\ndata->temp1[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp23(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf,"%ld\n",\r\n(long)TEMP_ADD_FROM_REG(data->temp_add[nr][index],\r\ndata->temp_add[nr][index+1]));\r\n}\r\nstatic ssize_t store_temp23(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\ns32 val;\r\nval = simple_strtol(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_add[nr][index] = TEMP_ADD_TO_REG_HIGH(val);\r\ndata->temp_add[nr][index+1] = TEMP_ADD_TO_REG_LOW(val);\r\nw83792d_write_value(client, W83792D_REG_TEMP_ADD[nr][index],\r\ndata->temp_add[nr][index]);\r\nw83792d_write_value(client, W83792D_REG_TEMP_ADD[nr][index+1],\r\ndata->temp_add[nr][index+1]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_alarms_reg(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->alarms >> nr) & 1);\r\n}\r\nstatic ssize_t\r\nshow_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->pwm[nr] & 0x0f) << 4);\r\n}\r\nstatic ssize_t\r\nshow_pwmenable(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index - 1;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nlong pwm_enable_tmp = 1;\r\nswitch (data->pwmenable[nr]) {\r\ncase 0:\r\npwm_enable_tmp = 1;\r\nbreak;\r\ncase 1:\r\npwm_enable_tmp = 3;\r\nbreak;\r\ncase 2:\r\npwm_enable_tmp = 2;\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%ld\n", pwm_enable_tmp);\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu8 val = SENSORS_LIMIT(simple_strtoul(buf, NULL, 10), 0, 255) >> 4;\r\nmutex_lock(&data->update_lock);\r\nval |= w83792d_read_value(client, W83792D_REG_PWM[nr]) & 0xf0;\r\ndata->pwm[nr] = val;\r\nw83792d_write_value(client, W83792D_REG_PWM[nr], data->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_pwmenable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index - 1;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nu8 fan_cfg_tmp, cfg1_tmp, cfg2_tmp, cfg3_tmp, cfg4_tmp;\r\nval = simple_strtoul(buf, NULL, 10);\r\nif (val < 1 || val > 3)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 1:\r\ndata->pwmenable[nr] = 0;\r\nbreak;\r\ncase 2:\r\ndata->pwmenable[nr] = 2;\r\nbreak;\r\ncase 3:\r\ndata->pwmenable[nr] = 1;\r\nbreak;\r\n}\r\ncfg1_tmp = data->pwmenable[0];\r\ncfg2_tmp = (data->pwmenable[1]) << 2;\r\ncfg3_tmp = (data->pwmenable[2]) << 4;\r\ncfg4_tmp = w83792d_read_value(client,W83792D_REG_FAN_CFG) & 0xc0;\r\nfan_cfg_tmp = ((cfg4_tmp | cfg3_tmp) | cfg2_tmp) | cfg1_tmp;\r\nw83792d_write_value(client, W83792D_REG_FAN_CFG, fan_cfg_tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm[nr] >> 7);\r\n}\r\nstatic ssize_t\r\nstore_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nval = simple_strtoul(buf, NULL, 10);\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = w83792d_read_value(client, W83792D_REG_PWM[nr]);\r\nif (val) {\r\ndata->pwm[nr] |= 0x80;\r\n} else {\r\ndata->pwm[nr] &= 0x7f;\r\n}\r\nw83792d_write_value(client, W83792D_REG_PWM[nr], data->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_chassis(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->chassis);\r\n}\r\nstatic ssize_t\r\nshow_regs_chassis(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\ndev_warn(dev,\r\n"Attribute %s is deprecated, use intrusion0_alarm instead\n",\r\n"chassis");\r\nreturn show_chassis(dev, attr, buf);\r\n}\r\nstatic ssize_t\r\nshow_chassis_clear(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->chassis_clear);\r\n}\r\nstatic ssize_t\r\nstore_chassis_clear_legacy(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nu8 temp1 = 0, temp2 = 0;\r\ndev_warn(dev,\r\n"Attribute %s is deprecated, use intrusion0_alarm instead\n",\r\n"chassis_clear");\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->chassis_clear = SENSORS_LIMIT(val, 0 ,1);\r\ntemp1 = ((data->chassis_clear) << 7) & 0x80;\r\ntemp2 = w83792d_read_value(client,\r\nW83792D_REG_CHASSIS_CLR) & 0x7f;\r\nw83792d_write_value(client, W83792D_REG_CHASSIS_CLR, temp1 | temp2);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_chassis_clear(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nu8 reg;\r\nif (strict_strtoul(buf, 10, &val) || val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nreg = w83792d_read_value(client, W83792D_REG_CHASSIS_CLR);\r\nw83792d_write_value(client, W83792D_REG_CHASSIS_CLR, reg | 0x80);\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_thermal_cruise(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", (long)data->thermal_cruise[nr-1]);\r\n}\r\nstatic ssize_t\r\nstore_thermal_cruise(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index - 1;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nu8 target_tmp=0, target_mask=0;\r\nval = simple_strtoul(buf, NULL, 10);\r\ntarget_tmp = val;\r\ntarget_tmp = target_tmp & 0x7f;\r\nmutex_lock(&data->update_lock);\r\ntarget_mask = w83792d_read_value(client, W83792D_REG_THERMAL[nr]) & 0x80;\r\ndata->thermal_cruise[nr] = SENSORS_LIMIT(target_tmp, 0, 255);\r\nw83792d_write_value(client, W83792D_REG_THERMAL[nr],\r\n(data->thermal_cruise[nr]) | target_mask);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_tolerance(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", (long)data->tolerance[nr-1]);\r\n}\r\nstatic ssize_t\r\nstore_tolerance(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index - 1;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nu8 tol_tmp, tol_mask;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ntol_mask = w83792d_read_value(client,\r\nW83792D_REG_TOLERANCE[nr]) & ((nr == 1) ? 0x0f : 0xf0);\r\ntol_tmp = SENSORS_LIMIT(val, 0, 15);\r\ntol_tmp &= 0x0f;\r\ndata->tolerance[nr] = tol_tmp;\r\nif (nr == 1) {\r\ntol_tmp <<= 4;\r\n}\r\nw83792d_write_value(client, W83792D_REG_TOLERANCE[nr],\r\ntol_mask | tol_tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf2_point(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", (long)data->sf2_points[index-1][nr-1]);\r\n}\r\nstatic ssize_t\r\nstore_sf2_point(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr - 1;\r\nint index = sensor_attr->index - 1;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nu8 mask_tmp = 0;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->sf2_points[index][nr] = SENSORS_LIMIT(val, 0, 127);\r\nmask_tmp = w83792d_read_value(client,\r\nW83792D_REG_POINTS[index][nr]) & 0x80;\r\nw83792d_write_value(client, W83792D_REG_POINTS[index][nr],\r\nmask_tmp|data->sf2_points[index][nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf2_level(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83792d_data *data = w83792d_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\n(((data->sf2_levels[index-1][nr]) * 100) / 15));\r\n}\r\nstatic ssize_t\r\nstore_sf2_level(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index - 1;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nu32 val;\r\nu8 mask_tmp=0, level_tmp=0;\r\nval = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&data->update_lock);\r\ndata->sf2_levels[index][nr] = SENSORS_LIMIT((val * 15) / 100, 0, 15);\r\nmask_tmp = w83792d_read_value(client, W83792D_REG_LEVELS[index][nr])\r\n& ((nr==3) ? 0xf0 : 0x0f);\r\nif (nr==3) {\r\nlevel_tmp = data->sf2_levels[index][nr];\r\n} else {\r\nlevel_tmp = data->sf2_levels[index][nr] << 4;\r\n}\r\nw83792d_write_value(client, W83792D_REG_LEVELS[index][nr], level_tmp | mask_tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int\r\nw83792d_detect_subclients(struct i2c_client *new_client)\r\n{\r\nint i, id, err;\r\nint address = new_client->addr;\r\nu8 val;\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nstruct w83792d_data *data = i2c_get_clientdata(new_client);\r\nid = i2c_adapter_id(adapter);\r\nif (force_subclients[0] == id && force_subclients[1] == address) {\r\nfor (i = 2; i <= 3; i++) {\r\nif (force_subclients[i] < 0x48 ||\r\nforce_subclients[i] > 0x4f) {\r\ndev_err(&new_client->dev, "invalid subclient "\r\n"address %d; must be 0x48-0x4f\n",\r\nforce_subclients[i]);\r\nerr = -ENODEV;\r\ngoto ERROR_SC_0;\r\n}\r\n}\r\nw83792d_write_value(new_client, W83792D_REG_I2C_SUBADDR,\r\n(force_subclients[2] & 0x07) |\r\n((force_subclients[3] & 0x07) << 4));\r\n}\r\nval = w83792d_read_value(new_client, W83792D_REG_I2C_SUBADDR);\r\nif (!(val & 0x08)) {\r\ndata->lm75[0] = i2c_new_dummy(adapter, 0x48 + (val & 0x7));\r\n}\r\nif (!(val & 0x80)) {\r\nif ((data->lm75[0] != NULL) &&\r\n((val & 0x7) == ((val >> 4) & 0x7))) {\r\ndev_err(&new_client->dev, "duplicate addresses 0x%x, "\r\n"use force_subclient\n", data->lm75[0]->addr);\r\nerr = -ENODEV;\r\ngoto ERROR_SC_1;\r\n}\r\ndata->lm75[1] = i2c_new_dummy(adapter,\r\n0x48 + ((val >> 4) & 0x7));\r\n}\r\nreturn 0;\r\nERROR_SC_1:\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nERROR_SC_0:\r\nreturn err;\r\n}\r\nstatic int\r\nw83792d_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint val1, val2;\r\nunsigned short address = client->addr;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\nreturn -ENODEV;\r\n}\r\nif (w83792d_read_value(client, W83792D_REG_CONFIG) & 0x80)\r\nreturn -ENODEV;\r\nval1 = w83792d_read_value(client, W83792D_REG_BANK);\r\nval2 = w83792d_read_value(client, W83792D_REG_CHIPMAN);\r\nif (!(val1 & 0x07)) {\r\nif ((!(val1 & 0x80) && val2 != 0xa3) ||\r\n( (val1 & 0x80) && val2 != 0x5c))\r\nreturn -ENODEV;\r\n}\r\nif (w83792d_read_value(client, W83792D_REG_I2C_ADDR) != address)\r\nreturn -ENODEV;\r\nw83792d_write_value(client,\r\nW83792D_REG_BANK,\r\n(w83792d_read_value(client,\r\nW83792D_REG_BANK) & 0x78) | 0x80);\r\nval1 = w83792d_read_value(client, W83792D_REG_WCHIPID);\r\nval2 = w83792d_read_value(client, W83792D_REG_CHIPMAN);\r\nif (val1 != 0x7a || val2 != 0x5c)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "w83792d", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int\r\nw83792d_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct w83792d_data *data;\r\nstruct device *dev = &client->dev;\r\nint i, val1, err;\r\ndata = kzalloc(sizeof(struct w83792d_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto ERROR0;\r\n}\r\ni2c_set_clientdata(client, data);\r\ndata->valid = 0;\r\nmutex_init(&data->update_lock);\r\nerr = w83792d_detect_subclients(client);\r\nif (err)\r\ngoto ERROR1;\r\nw83792d_init_client(client);\r\nfor (i = 0; i < 7; i++) {\r\ndata->fan_min[i] = w83792d_read_value(client,\r\nW83792D_REG_FAN_MIN[i]);\r\n}\r\nif ((err = sysfs_create_group(&dev->kobj, &w83792d_group)))\r\ngoto ERROR3;\r\nval1 = w83792d_read_value(client, W83792D_REG_GPIO_EN);\r\nif (!(val1 & 0x40))\r\nif ((err = sysfs_create_group(&dev->kobj,\r\n&w83792d_group_fan[0])))\r\ngoto exit_remove_files;\r\nif (!(val1 & 0x20))\r\nif ((err = sysfs_create_group(&dev->kobj,\r\n&w83792d_group_fan[1])))\r\ngoto exit_remove_files;\r\nval1 = w83792d_read_value(client, W83792D_REG_PIN);\r\nif (val1 & 0x40)\r\nif ((err = sysfs_create_group(&dev->kobj,\r\n&w83792d_group_fan[2])))\r\ngoto exit_remove_files;\r\nif (val1 & 0x04)\r\nif ((err = sysfs_create_group(&dev->kobj,\r\n&w83792d_group_fan[3])))\r\ngoto exit_remove_files;\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&dev->kobj, &w83792d_group);\r\nfor (i = 0; i < ARRAY_SIZE(w83792d_group_fan); i++)\r\nsysfs_remove_group(&dev->kobj, &w83792d_group_fan[i]);\r\nERROR3:\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1] != NULL)\r\ni2c_unregister_device(data->lm75[1]);\r\nERROR1:\r\nkfree(data);\r\nERROR0:\r\nreturn err;\r\n}\r\nstatic int\r\nw83792d_remove(struct i2c_client *client)\r\n{\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nint i;\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &w83792d_group);\r\nfor (i = 0; i < ARRAY_SIZE(w83792d_group_fan); i++)\r\nsysfs_remove_group(&client->dev.kobj,\r\n&w83792d_group_fan[i]);\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1] != NULL)\r\ni2c_unregister_device(data->lm75[1]);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic void\r\nw83792d_init_client(struct i2c_client *client)\r\n{\r\nu8 temp2_cfg, temp3_cfg, vid_in_b;\r\nif (init) {\r\nw83792d_write_value(client, W83792D_REG_CONFIG, 0x80);\r\n}\r\nvid_in_b = w83792d_read_value(client, W83792D_REG_VID_IN_B);\r\nw83792d_write_value(client, W83792D_REG_VID_IN_B,\r\nvid_in_b & 0xbf);\r\ntemp2_cfg = w83792d_read_value(client, W83792D_REG_TEMP2_CONFIG);\r\ntemp3_cfg = w83792d_read_value(client, W83792D_REG_TEMP3_CONFIG);\r\nw83792d_write_value(client, W83792D_REG_TEMP2_CONFIG,\r\ntemp2_cfg & 0xe6);\r\nw83792d_write_value(client, W83792D_REG_TEMP3_CONFIG,\r\ntemp3_cfg & 0xe6);\r\nw83792d_write_value(client, W83792D_REG_CONFIG,\r\n(w83792d_read_value(client,\r\nW83792D_REG_CONFIG) & 0xf7)\r\n| 0x01);\r\n}\r\nstatic struct w83792d_data *w83792d_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83792d_data *data = i2c_get_clientdata(client);\r\nint i, j;\r\nu8 reg_array_tmp[4], reg_tmp;\r\nmutex_lock(&data->update_lock);\r\nif (time_after\r\n(jiffies - data->last_updated, (unsigned long) (HZ * 3))\r\n|| time_before(jiffies, data->last_updated) || !data->valid) {\r\ndev_dbg(dev, "Starting device update\n");\r\nfor (i = 0; i < 9; i++) {\r\ndata->in[i] = w83792d_read_value(client,\r\nW83792D_REG_IN[i]);\r\ndata->in_max[i] = w83792d_read_value(client,\r\nW83792D_REG_IN_MAX[i]);\r\ndata->in_min[i] = w83792d_read_value(client,\r\nW83792D_REG_IN_MIN[i]);\r\n}\r\ndata->low_bits = w83792d_read_value(client,\r\nW83792D_REG_LOW_BITS1) +\r\n(w83792d_read_value(client,\r\nW83792D_REG_LOW_BITS2) << 8);\r\nfor (i = 0; i < 7; i++) {\r\ndata->fan[i] = w83792d_read_value(client,\r\nW83792D_REG_FAN[i]);\r\ndata->fan_min[i] = w83792d_read_value(client,\r\nW83792D_REG_FAN_MIN[i]);\r\ndata->pwm[i] = w83792d_read_value(client,\r\nW83792D_REG_PWM[i]);\r\n}\r\nreg_tmp = w83792d_read_value(client, W83792D_REG_FAN_CFG);\r\ndata->pwmenable[0] = reg_tmp & 0x03;\r\ndata->pwmenable[1] = (reg_tmp>>2) & 0x03;\r\ndata->pwmenable[2] = (reg_tmp>>4) & 0x03;\r\nfor (i = 0; i < 3; i++) {\r\ndata->temp1[i] = w83792d_read_value(client,\r\nW83792D_REG_TEMP1[i]);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nfor (j = 0; j < 6; j++) {\r\ndata->temp_add[i][j] = w83792d_read_value(\r\nclient,W83792D_REG_TEMP_ADD[i][j]);\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nreg_array_tmp[i] = w83792d_read_value(client,\r\nW83792D_REG_FAN_DIV[i]);\r\n}\r\ndata->fan_div[0] = reg_array_tmp[0] & 0x07;\r\ndata->fan_div[1] = (reg_array_tmp[0] >> 4) & 0x07;\r\ndata->fan_div[2] = reg_array_tmp[1] & 0x07;\r\ndata->fan_div[3] = (reg_array_tmp[1] >> 4) & 0x07;\r\ndata->fan_div[4] = reg_array_tmp[2] & 0x07;\r\ndata->fan_div[5] = (reg_array_tmp[2] >> 4) & 0x07;\r\ndata->fan_div[6] = reg_array_tmp[3] & 0x07;\r\ndata->alarms = w83792d_read_value(client, W83792D_REG_ALARM1) +\r\n(w83792d_read_value(client, W83792D_REG_ALARM2) << 8) +\r\n(w83792d_read_value(client, W83792D_REG_ALARM3) << 16);\r\ndata->chassis = (w83792d_read_value(client,\r\nW83792D_REG_CHASSIS) >> 5) & 0x01;\r\ndata->chassis_clear = (w83792d_read_value(client,\r\nW83792D_REG_CHASSIS_CLR) >> 7) & 0x01;\r\nfor (i = 0; i < 3; i++) {\r\ndata->thermal_cruise[i] =\r\nw83792d_read_value(client,\r\nW83792D_REG_THERMAL[i]) & 0x7f;\r\n}\r\nreg_tmp = w83792d_read_value(client, W83792D_REG_TOLERANCE[0]);\r\ndata->tolerance[0] = reg_tmp & 0x0f;\r\ndata->tolerance[1] = (reg_tmp >> 4) & 0x0f;\r\ndata->tolerance[2] = w83792d_read_value(client,\r\nW83792D_REG_TOLERANCE[2]) & 0x0f;\r\nfor (i = 0; i < 3; i++) {\r\nfor (j = 0; j < 4; j++) {\r\ndata->sf2_points[i][j] = w83792d_read_value(\r\nclient,W83792D_REG_POINTS[i][j]) & 0x7f;\r\n}\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nreg_tmp = w83792d_read_value(client,\r\nW83792D_REG_LEVELS[i][0]);\r\ndata->sf2_levels[i][0] = reg_tmp & 0x0f;\r\ndata->sf2_levels[i][1] = (reg_tmp >> 4) & 0x0f;\r\nreg_tmp = w83792d_read_value(client,\r\nW83792D_REG_LEVELS[i][2]);\r\ndata->sf2_levels[i][2] = (reg_tmp >> 4) & 0x0f;\r\ndata->sf2_levels[i][3] = reg_tmp & 0x0f;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\n#ifdef DEBUG\r\nw83792d_print_debug(data, dev);\r\n#endif\r\nreturn data;\r\n}\r\nstatic void w83792d_print_debug(struct w83792d_data *data, struct device *dev)\r\n{\r\nint i=0, j=0;\r\ndev_dbg(dev, "==========The following is the debug message...========\n");\r\ndev_dbg(dev, "9 set of Voltages: =====>\n");\r\nfor (i=0; i<9; i++) {\r\ndev_dbg(dev, "vin[%d] is: 0x%x\n", i, data->in[i]);\r\ndev_dbg(dev, "vin[%d] max is: 0x%x\n", i, data->in_max[i]);\r\ndev_dbg(dev, "vin[%d] min is: 0x%x\n", i, data->in_min[i]);\r\n}\r\ndev_dbg(dev, "Low Bit1 is: 0x%x\n", data->low_bits & 0xff);\r\ndev_dbg(dev, "Low Bit2 is: 0x%x\n", data->low_bits >> 8);\r\ndev_dbg(dev, "7 set of Fan Counts and Duty Cycles: =====>\n");\r\nfor (i=0; i<7; i++) {\r\ndev_dbg(dev, "fan[%d] is: 0x%x\n", i, data->fan[i]);\r\ndev_dbg(dev, "fan[%d] min is: 0x%x\n", i, data->fan_min[i]);\r\ndev_dbg(dev, "pwm[%d] is: 0x%x\n", i, data->pwm[i]);\r\n}\r\ndev_dbg(dev, "3 set of Temperatures: =====>\n");\r\nfor (i=0; i<3; i++) {\r\ndev_dbg(dev, "temp1[%d] is: 0x%x\n", i, data->temp1[i]);\r\n}\r\nfor (i=0; i<2; i++) {\r\nfor (j=0; j<6; j++) {\r\ndev_dbg(dev, "temp_add[%d][%d] is: 0x%x\n", i, j,\r\ndata->temp_add[i][j]);\r\n}\r\n}\r\nfor (i=0; i<7; i++) {\r\ndev_dbg(dev, "fan_div[%d] is: 0x%x\n", i, data->fan_div[i]);\r\n}\r\ndev_dbg(dev, "==========End of the debug message...==================\n");\r\ndev_dbg(dev, "\n");\r\n}\r\nstatic int __init\r\nsensors_w83792d_init(void)\r\n{\r\nreturn i2c_add_driver(&w83792d_driver);\r\n}\r\nstatic void __exit\r\nsensors_w83792d_exit(void)\r\n{\r\ni2c_del_driver(&w83792d_driver);\r\n}
