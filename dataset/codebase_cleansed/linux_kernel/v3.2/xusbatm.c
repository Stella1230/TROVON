static struct usb_interface *xusbatm_find_intf(struct usb_device *usb_dev, int altsetting, u8 ep)\r\n{\r\nstruct usb_host_interface *alt;\r\nstruct usb_interface *intf;\r\nint i, j;\r\nfor (i = 0; i < usb_dev->actconfig->desc.bNumInterfaces; i++)\r\nif ((intf = usb_dev->actconfig->interface[i]) && (alt = usb_altnum_to_altsetting(intf, altsetting)))\r\nfor (j = 0; j < alt->desc.bNumEndpoints; j++)\r\nif (alt->endpoint[j].desc.bEndpointAddress == ep)\r\nreturn intf;\r\nreturn NULL;\r\n}\r\nstatic int xusbatm_capture_intf(struct usbatm_data *usbatm, struct usb_device *usb_dev,\r\nstruct usb_interface *intf, int altsetting, int claim)\r\n{\r\nint ifnum = intf->altsetting->desc.bInterfaceNumber;\r\nint ret;\r\nif (claim && (ret = usb_driver_claim_interface(&xusbatm_usb_driver, intf, usbatm))) {\r\nusb_err(usbatm, "%s: failed to claim interface %2d (%d)!\n", __func__, ifnum, ret);\r\nreturn ret;\r\n}\r\nif ((ret = usb_set_interface(usb_dev, ifnum, altsetting))) {\r\nusb_err(usbatm, "%s: altsetting %2d for interface %2d failed (%d)!\n", __func__, altsetting, ifnum, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xusbatm_release_intf(struct usb_device *usb_dev, struct usb_interface *intf, int claimed)\r\n{\r\nif (claimed) {\r\nusb_set_intfdata(intf, NULL);\r\nusb_driver_release_interface(&xusbatm_usb_driver, intf);\r\n}\r\n}\r\nstatic int xusbatm_bind(struct usbatm_data *usbatm,\r\nstruct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nint drv_ix = id - xusbatm_usb_ids;\r\nint rx_alt = rx_altsetting[drv_ix];\r\nint tx_alt = tx_altsetting[drv_ix];\r\nstruct usb_interface *rx_intf = xusbatm_find_intf(usb_dev, rx_alt, rx_endpoint[drv_ix]);\r\nstruct usb_interface *tx_intf = xusbatm_find_intf(usb_dev, tx_alt, tx_endpoint[drv_ix]);\r\nint ret;\r\nusb_dbg(usbatm, "%s: binding driver %d: vendor %04x product %04x"\r\n" rx: ep %02x padd %d alt %2d tx: ep %02x padd %d alt %2d\n",\r\n__func__, drv_ix, vendor[drv_ix], product[drv_ix],\r\nrx_endpoint[drv_ix], rx_padding[drv_ix], rx_alt,\r\ntx_endpoint[drv_ix], tx_padding[drv_ix], tx_alt);\r\nif (!rx_intf || !tx_intf) {\r\nif (!rx_intf)\r\nusb_dbg(usbatm, "%s: no interface contains endpoint %02x in altsetting %2d\n",\r\n__func__, rx_endpoint[drv_ix], rx_alt);\r\nif (!tx_intf)\r\nusb_dbg(usbatm, "%s: no interface contains endpoint %02x in altsetting %2d\n",\r\n__func__, tx_endpoint[drv_ix], tx_alt);\r\nreturn -ENODEV;\r\n}\r\nif ((rx_intf != intf) && (tx_intf != intf))\r\nreturn -ENODEV;\r\nif ((rx_intf == tx_intf) && (rx_alt != tx_alt)) {\r\nusb_err(usbatm, "%s: altsettings clash on interface %2d (%2d vs %2d)!\n", __func__,\r\nrx_intf->altsetting->desc.bInterfaceNumber, rx_alt, tx_alt);\r\nreturn -EINVAL;\r\n}\r\nusb_dbg(usbatm, "%s: rx If#=%2d; tx If#=%2d\n", __func__,\r\nrx_intf->altsetting->desc.bInterfaceNumber,\r\ntx_intf->altsetting->desc.bInterfaceNumber);\r\nif ((ret = xusbatm_capture_intf(usbatm, usb_dev, rx_intf, rx_alt, rx_intf != intf)))\r\nreturn ret;\r\nif ((tx_intf != rx_intf) && (ret = xusbatm_capture_intf(usbatm, usb_dev, tx_intf, tx_alt, tx_intf != intf))) {\r\nxusbatm_release_intf(usb_dev, rx_intf, rx_intf != intf);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xusbatm_unbind(struct usbatm_data *usbatm,\r\nstruct usb_interface *intf)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nint i;\r\nusb_dbg(usbatm, "%s entered\n", __func__);\r\nfor (i = 0; i < usb_dev->actconfig->desc.bNumInterfaces; i++) {\r\nstruct usb_interface *cur_intf = usb_dev->actconfig->interface[i];\r\nif (cur_intf && (usb_get_intfdata(cur_intf) == usbatm)) {\r\nusb_set_intfdata(cur_intf, NULL);\r\nusb_driver_release_interface(&xusbatm_usb_driver, cur_intf);\r\n}\r\n}\r\n}\r\nstatic int xusbatm_atm_start(struct usbatm_data *usbatm,\r\nstruct atm_dev *atm_dev)\r\n{\r\natm_dbg(usbatm, "%s entered\n", __func__);\r\nrandom_ether_addr(atm_dev->esi);\r\nreturn 0;\r\n}\r\nstatic int xusbatm_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn usbatm_usb_probe(intf, id,\r\nxusbatm_drivers + (id - xusbatm_usb_ids));\r\n}\r\nstatic int __init xusbatm_init(void)\r\n{\r\nint i;\r\ndbg("xusbatm_init");\r\nif (!num_vendor ||\r\nnum_vendor != num_product ||\r\nnum_vendor != num_rx_endpoint ||\r\nnum_vendor != num_tx_endpoint) {\r\nprintk(KERN_WARNING "xusbatm: malformed module parameters\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_vendor; i++) {\r\nrx_endpoint[i] |= USB_DIR_IN;\r\ntx_endpoint[i] &= USB_ENDPOINT_NUMBER_MASK;\r\nxusbatm_usb_ids[i].match_flags = USB_DEVICE_ID_MATCH_DEVICE;\r\nxusbatm_usb_ids[i].idVendor = vendor[i];\r\nxusbatm_usb_ids[i].idProduct = product[i];\r\nxusbatm_drivers[i].driver_name = xusbatm_driver_name;\r\nxusbatm_drivers[i].bind = xusbatm_bind;\r\nxusbatm_drivers[i].unbind = xusbatm_unbind;\r\nxusbatm_drivers[i].atm_start = xusbatm_atm_start;\r\nxusbatm_drivers[i].bulk_in = rx_endpoint[i];\r\nxusbatm_drivers[i].bulk_out = tx_endpoint[i];\r\nxusbatm_drivers[i].rx_padding = rx_padding[i];\r\nxusbatm_drivers[i].tx_padding = tx_padding[i];\r\n}\r\nreturn usb_register(&xusbatm_usb_driver);\r\n}\r\nstatic void __exit xusbatm_exit(void)\r\n{\r\ndbg("xusbatm_exit entered");\r\nusb_deregister(&xusbatm_usb_driver);\r\n}
