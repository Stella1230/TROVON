static netdev_tx_t usbpn_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct usbpn_dev *pnd = netdev_priv(dev);\r\nstruct urb *req = NULL;\r\nunsigned long flags;\r\nint err;\r\nif (skb->protocol != htons(ETH_P_PHONET))\r\ngoto drop;\r\nreq = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!req)\r\ngoto drop;\r\nusb_fill_bulk_urb(req, pnd->usb, pnd->tx_pipe, skb->data, skb->len,\r\ntx_complete, skb);\r\nreq->transfer_flags = URB_ZERO_PACKET;\r\nerr = usb_submit_urb(req, GFP_ATOMIC);\r\nif (err) {\r\nusb_free_urb(req);\r\ngoto drop;\r\n}\r\nspin_lock_irqsave(&pnd->tx_lock, flags);\r\npnd->tx_queue++;\r\nif (pnd->tx_queue >= dev->tx_queue_len)\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&pnd->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void tx_complete(struct urb *req)\r\n{\r\nstruct sk_buff *skb = req->context;\r\nstruct net_device *dev = skb->dev;\r\nstruct usbpn_dev *pnd = netdev_priv(dev);\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\ndev->stats.tx_bytes += skb->len;\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\ndev->stats.tx_aborted_errors++;\r\ndefault:\r\ndev->stats.tx_errors++;\r\ndev_dbg(&dev->dev, "TX error (%d)\n", status);\r\n}\r\ndev->stats.tx_packets++;\r\nspin_lock(&pnd->tx_lock);\r\npnd->tx_queue--;\r\nnetif_wake_queue(dev);\r\nspin_unlock(&pnd->tx_lock);\r\ndev_kfree_skb_any(skb);\r\nusb_free_urb(req);\r\n}\r\nstatic int rx_submit(struct usbpn_dev *pnd, struct urb *req, gfp_t gfp_flags)\r\n{\r\nstruct net_device *dev = pnd->dev;\r\nstruct page *page;\r\nint err;\r\npage = __netdev_alloc_page(dev, gfp_flags);\r\nif (!page)\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(req, pnd->usb, pnd->rx_pipe, page_address(page),\r\nPAGE_SIZE, rx_complete, dev);\r\nreq->transfer_flags = 0;\r\nerr = usb_submit_urb(req, gfp_flags);\r\nif (unlikely(err)) {\r\ndev_dbg(&dev->dev, "RX submit error (%d)\n", err);\r\nnetdev_free_page(dev, page);\r\n}\r\nreturn err;\r\n}\r\nstatic void rx_complete(struct urb *req)\r\n{\r\nstruct net_device *dev = req->context;\r\nstruct usbpn_dev *pnd = netdev_priv(dev);\r\nstruct page *page = virt_to_page(req->transfer_buffer);\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\nspin_lock_irqsave(&pnd->rx_lock, flags);\r\nskb = pnd->rx_skb;\r\nif (!skb) {\r\nskb = pnd->rx_skb = netdev_alloc_skb(dev, 12);\r\nif (likely(skb)) {\r\nmemcpy(skb_put(skb, 1), page_address(page), 1);\r\nskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,\r\npage, 1, req->actual_length);\r\npage = NULL;\r\n}\r\n} else {\r\nskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,\r\npage, 0, req->actual_length);\r\npage = NULL;\r\n}\r\nif (req->actual_length < PAGE_SIZE)\r\npnd->rx_skb = NULL;\r\nelse\r\nskb = NULL;\r\nspin_unlock_irqrestore(&pnd->rx_lock, flags);\r\nif (skb) {\r\nskb->protocol = htons(ETH_P_PHONET);\r\nskb_reset_mac_header(skb);\r\n__skb_pull(skb, 1);\r\nskb->dev = dev;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\n}\r\ngoto resubmit;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nreq = NULL;\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev->stats.rx_over_errors++;\r\ndev_dbg(&dev->dev, "RX overflow\n");\r\nbreak;\r\ncase -EILSEQ:\r\ndev->stats.rx_crc_errors++;\r\nbreak;\r\n}\r\ndev->stats.rx_errors++;\r\nresubmit:\r\nif (page)\r\nnetdev_free_page(dev, page);\r\nif (req)\r\nrx_submit(pnd, req, GFP_ATOMIC);\r\n}\r\nstatic int usbpn_open(struct net_device *dev)\r\n{\r\nstruct usbpn_dev *pnd = netdev_priv(dev);\r\nint err;\r\nunsigned i;\r\nunsigned num = pnd->data_intf->cur_altsetting->desc.bInterfaceNumber;\r\nerr = usb_set_interface(pnd->usb, num, pnd->active_setting);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < rxq_size; i++) {\r\nstruct urb *req = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!req || rx_submit(pnd, req, GFP_KERNEL)) {\r\nusbpn_close(dev);\r\nreturn -ENOMEM;\r\n}\r\npnd->urbs[i] = req;\r\n}\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int usbpn_close(struct net_device *dev)\r\n{\r\nstruct usbpn_dev *pnd = netdev_priv(dev);\r\nunsigned i;\r\nunsigned num = pnd->data_intf->cur_altsetting->desc.bInterfaceNumber;\r\nnetif_stop_queue(dev);\r\nfor (i = 0; i < rxq_size; i++) {\r\nstruct urb *req = pnd->urbs[i];\r\nif (!req)\r\ncontinue;\r\nusb_kill_urb(req);\r\nusb_free_urb(req);\r\npnd->urbs[i] = NULL;\r\n}\r\nreturn usb_set_interface(pnd->usb, num, !pnd->active_setting);\r\n}\r\nstatic int usbpn_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct if_phonet_req *req = (struct if_phonet_req *)ifr;\r\nswitch (cmd) {\r\ncase SIOCPNGAUTOCONF:\r\nreq->ifr_phonet_autoconf.device = PN_DEV_PC;\r\nreturn 0;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int usbpn_set_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < PHONET_MIN_MTU) || (new_mtu > PHONET_MAX_MTU))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void usbpn_setup(struct net_device *dev)\r\n{\r\ndev->features = 0;\r\ndev->netdev_ops = &usbpn_ops,\r\ndev->header_ops = &phonet_header_ops;\r\ndev->type = ARPHRD_PHONET;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->mtu = PHONET_MAX_MTU;\r\ndev->hard_header_len = 1;\r\ndev->dev_addr[0] = PN_MEDIA_USB;\r\ndev->addr_len = 1;\r\ndev->tx_queue_len = 3;\r\ndev->destructor = free_netdev;\r\n}\r\nint usbpn_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstatic const char ifname[] = "usbpn%d";\r\nconst struct usb_cdc_union_desc *union_header = NULL;\r\nconst struct usb_host_interface *data_desc;\r\nstruct usb_interface *data_intf;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nstruct net_device *dev;\r\nstruct usbpn_dev *pnd;\r\nu8 *data;\r\nint phonet = 0;\r\nint len, err;\r\ndata = intf->altsetting->extra;\r\nlen = intf->altsetting->extralen;\r\nwhile (len >= 3) {\r\nu8 dlen = data[0];\r\nif (dlen < 3)\r\nreturn -EINVAL;\r\nif (data[1] == USB_DT_CS_INTERFACE) {\r\nswitch (data[2]) {\r\ncase USB_CDC_UNION_TYPE:\r\nif (union_header || dlen < 5)\r\nbreak;\r\nunion_header =\r\n(struct usb_cdc_union_desc *)data;\r\nbreak;\r\ncase 0xAB:\r\nphonet = 1;\r\nbreak;\r\n}\r\n}\r\ndata += dlen;\r\nlen -= dlen;\r\n}\r\nif (!union_header || !phonet)\r\nreturn -EINVAL;\r\ndata_intf = usb_ifnum_to_if(usbdev, union_header->bSlaveInterface0);\r\nif (data_intf == NULL)\r\nreturn -ENODEV;\r\nif (data_intf->num_altsetting != 2)\r\nreturn -EINVAL;\r\nif (data_intf->altsetting[0].desc.bNumEndpoints == 0 &&\r\ndata_intf->altsetting[1].desc.bNumEndpoints == 2)\r\ndata_desc = data_intf->altsetting + 1;\r\nelse\r\nif (data_intf->altsetting[0].desc.bNumEndpoints == 2 &&\r\ndata_intf->altsetting[1].desc.bNumEndpoints == 0)\r\ndata_desc = data_intf->altsetting;\r\nelse\r\nreturn -EINVAL;\r\ndev = alloc_netdev(sizeof(*pnd) + sizeof(pnd->urbs[0]) * rxq_size,\r\nifname, usbpn_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\npnd = netdev_priv(dev);\r\nSET_NETDEV_DEV(dev, &intf->dev);\r\npnd->dev = dev;\r\npnd->usb = usb_get_dev(usbdev);\r\npnd->intf = intf;\r\npnd->data_intf = data_intf;\r\nspin_lock_init(&pnd->tx_lock);\r\nspin_lock_init(&pnd->rx_lock);\r\nif (usb_pipein(data_desc->endpoint[0].desc.bEndpointAddress)) {\r\npnd->rx_pipe = usb_rcvbulkpipe(usbdev,\r\ndata_desc->endpoint[0].desc.bEndpointAddress);\r\npnd->tx_pipe = usb_sndbulkpipe(usbdev,\r\ndata_desc->endpoint[1].desc.bEndpointAddress);\r\n} else {\r\npnd->rx_pipe = usb_rcvbulkpipe(usbdev,\r\ndata_desc->endpoint[1].desc.bEndpointAddress);\r\npnd->tx_pipe = usb_sndbulkpipe(usbdev,\r\ndata_desc->endpoint[0].desc.bEndpointAddress);\r\n}\r\npnd->active_setting = data_desc - data_intf->altsetting;\r\nerr = usb_driver_claim_interface(&usbpn_driver, data_intf, pnd);\r\nif (err)\r\ngoto out;\r\nusb_set_interface(usbdev, union_header->bSlaveInterface0,\r\n!pnd->active_setting);\r\nusb_set_intfdata(intf, pnd);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nusb_driver_release_interface(&usbpn_driver, data_intf);\r\ngoto out;\r\n}\r\ndev_dbg(&dev->dev, "USB CDC Phonet device found\n");\r\nreturn 0;\r\nout:\r\nusb_set_intfdata(intf, NULL);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void usbpn_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbpn_dev *pnd = usb_get_intfdata(intf);\r\nstruct usb_device *usb = pnd->usb;\r\nif (pnd->disconnected)\r\nreturn;\r\npnd->disconnected = 1;\r\nusb_driver_release_interface(&usbpn_driver,\r\n(pnd->intf == intf) ? pnd->data_intf : pnd->intf);\r\nunregister_netdev(pnd->dev);\r\nusb_put_dev(usb);\r\n}\r\nstatic int __init usbpn_init(void)\r\n{\r\nreturn usb_register(&usbpn_driver);\r\n}\r\nstatic void __exit usbpn_exit(void)\r\n{\r\nusb_deregister(&usbpn_driver);\r\n}
