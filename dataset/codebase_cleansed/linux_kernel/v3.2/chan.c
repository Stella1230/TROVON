struct ieee80211_channel *\r\nrdev_freq_to_chan(struct cfg80211_registered_device *rdev,\r\nint freq, enum nl80211_channel_type channel_type)\r\n{\r\nstruct ieee80211_channel *chan;\r\nstruct ieee80211_sta_ht_cap *ht_cap;\r\nchan = ieee80211_get_channel(&rdev->wiphy, freq);\r\nif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\r\nreturn NULL;\r\nif (channel_type == NL80211_CHAN_HT40MINUS &&\r\nchan->flags & IEEE80211_CHAN_NO_HT40MINUS)\r\nreturn NULL;\r\nelse if (channel_type == NL80211_CHAN_HT40PLUS &&\r\nchan->flags & IEEE80211_CHAN_NO_HT40PLUS)\r\nreturn NULL;\r\nht_cap = &rdev->wiphy.bands[chan->band]->ht_cap;\r\nif (channel_type != NL80211_CHAN_NO_HT) {\r\nif (!ht_cap->ht_supported)\r\nreturn NULL;\r\nif (channel_type != NL80211_CHAN_HT20 &&\r\n(!(ht_cap->cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) ||\r\nht_cap->cap & IEEE80211_HT_CAP_40MHZ_INTOLERANT))\r\nreturn NULL;\r\n}\r\nreturn chan;\r\n}\r\nstatic bool can_beacon_sec_chan(struct wiphy *wiphy,\r\nstruct ieee80211_channel *chan,\r\nenum nl80211_channel_type channel_type)\r\n{\r\nstruct ieee80211_channel *sec_chan;\r\nint diff;\r\nswitch (channel_type) {\r\ncase NL80211_CHAN_HT40PLUS:\r\ndiff = 20;\r\nbreak;\r\ncase NL80211_CHAN_HT40MINUS:\r\ndiff = -20;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nsec_chan = ieee80211_get_channel(wiphy, chan->center_freq + diff);\r\nif (!sec_chan)\r\nreturn false;\r\nif (sec_chan->flags & (IEEE80211_CHAN_DISABLED |\r\nIEEE80211_CHAN_PASSIVE_SCAN |\r\nIEEE80211_CHAN_NO_IBSS |\r\nIEEE80211_CHAN_RADAR))\r\nreturn false;\r\nreturn true;\r\n}\r\nint cfg80211_set_freq(struct cfg80211_registered_device *rdev,\r\nstruct wireless_dev *wdev, int freq,\r\nenum nl80211_channel_type channel_type)\r\n{\r\nstruct ieee80211_channel *chan;\r\nint result;\r\nif (wdev && wdev->iftype == NL80211_IFTYPE_MONITOR)\r\nwdev = NULL;\r\nif (wdev) {\r\nASSERT_WDEV_LOCK(wdev);\r\nif (!netif_running(wdev->netdev))\r\nreturn -ENETDOWN;\r\n}\r\nif (!rdev->ops->set_channel)\r\nreturn -EOPNOTSUPP;\r\nchan = rdev_freq_to_chan(rdev, freq, channel_type);\r\nif (!chan)\r\nreturn -EINVAL;\r\nif (wdev && (wdev->iftype == NL80211_IFTYPE_ADHOC ||\r\nwdev->iftype == NL80211_IFTYPE_AP ||\r\nwdev->iftype == NL80211_IFTYPE_AP_VLAN ||\r\nwdev->iftype == NL80211_IFTYPE_MESH_POINT ||\r\nwdev->iftype == NL80211_IFTYPE_P2P_GO)) {\r\nswitch (channel_type) {\r\ncase NL80211_CHAN_HT40PLUS:\r\ncase NL80211_CHAN_HT40MINUS:\r\nif (!can_beacon_sec_chan(&rdev->wiphy, chan,\r\nchannel_type)) {\r\nprintk(KERN_DEBUG\r\n"cfg80211: Secondary channel not "\r\n"allowed to initiate communication\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nresult = rdev->ops->set_channel(&rdev->wiphy,\r\nwdev ? wdev->netdev : NULL,\r\nchan, channel_type);\r\nif (result)\r\nreturn result;\r\nif (wdev)\r\nwdev->channel = chan;\r\nreturn 0;\r\n}
