static inline unsigned short from32to16(unsigned long x)\r\n{\r\nx = (x & 0xffff) + (x >> 16);\r\nx = (x & 0xffff) + (x >> 16);\r\nreturn x;\r\n}\r\nstatic unsigned long do_csum(const unsigned char * buff, int len)\r\n{\r\nint odd, count;\r\nunsigned long result = 0;\r\nif (len <= 0)\r\ngoto out;\r\nodd = 1 & (unsigned long) buff;\r\nif (odd) {\r\nresult = *buff;\r\nlen--;\r\nbuff++;\r\n}\r\ncount = len >> 1;\r\nif (count) {\r\nif (2 & (unsigned long) buff) {\r\nresult += *(unsigned short *) buff;\r\ncount--;\r\nlen -= 2;\r\nbuff += 2;\r\n}\r\ncount >>= 1;\r\nif (count) {\r\nunsigned long carry = 0;\r\ndo {\r\nunsigned long w = *(unsigned long *) buff;\r\ncount--;\r\nbuff += 4;\r\nresult += carry;\r\nresult += w;\r\ncarry = (w > result);\r\n} while (count);\r\nresult += carry;\r\nresult = (result & 0xffff) + (result >> 16);\r\n}\r\nif (len & 2) {\r\nresult += *(unsigned short *) buff;\r\nbuff += 2;\r\n}\r\n}\r\nif (len & 1)\r\nresult += (*buff << 8);\r\nresult = from32to16(result);\r\nif (odd)\r\nresult = ((result >> 8) & 0xff) | ((result & 0xff) << 8);\r\nout:\r\nreturn result;\r\n}\r\n__sum16 ip_fast_csum(const void *iph, unsigned int ihl)\r\n{\r\nreturn (__force __sum16)~do_csum(iph,ihl*4);\r\n}\r\n__wsum csum_partial(const void *buff, int len, __wsum sum)\r\n{\r\nunsigned int result = do_csum(buff, len);\r\nresult += (__force u32)sum;\r\nif ((__force u32)sum > result)\r\nresult += 1;\r\nreturn (__force __wsum)result;\r\n}\r\n__wsum\r\ncsum_partial_copy_from_user(const void __user *src, void *dst,\r\nint len, __wsum sum, int *csum_err)\r\n{\r\nif (csum_err) *csum_err = 0;\r\nmemcpy(dst, (__force const void *)src, len);\r\nreturn csum_partial(dst, len, sum);\r\n}\r\n__wsum\r\ncsum_partial_copy_nocheck(const void *src, void *dst, int len, __wsum sum)\r\n{\r\nmemcpy(dst, src, len);\r\nreturn csum_partial(dst, len, sum);\r\n}
