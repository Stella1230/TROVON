static void o2quo_fence_self(void)\r\n{\r\no2hb_stop_all_regions();\r\nswitch (o2nm_single_cluster->cl_fence_method) {\r\ncase O2NM_FENCE_PANIC:\r\npanic("*** ocfs2 is very sorry to be fencing this system by "\r\n"panicing ***\n");\r\nbreak;\r\ndefault:\r\nWARN_ON(o2nm_single_cluster->cl_fence_method >=\r\nO2NM_FENCE_METHODS);\r\ncase O2NM_FENCE_RESET:\r\nprintk(KERN_ERR "*** ocfs2 is very sorry to be fencing this "\r\n"system by restarting ***\n");\r\nemergency_restart();\r\nbreak;\r\n};\r\n}\r\nvoid o2quo_disk_timeout(void)\r\n{\r\no2quo_fence_self();\r\n}\r\nstatic void o2quo_make_decision(struct work_struct *work)\r\n{\r\nint quorum;\r\nint lowest_hb, lowest_reachable = 0, fence = 0;\r\nstruct o2quo_state *qs = &o2quo_state;\r\nspin_lock(&qs->qs_lock);\r\nlowest_hb = find_first_bit(qs->qs_hb_bm, O2NM_MAX_NODES);\r\nif (lowest_hb != O2NM_MAX_NODES)\r\nlowest_reachable = test_bit(lowest_hb, qs->qs_conn_bm);\r\nmlog(0, "heartbeating: %d, connected: %d, "\r\n"lowest: %d (%sreachable)\n", qs->qs_heartbeating,\r\nqs->qs_connected, lowest_hb, lowest_reachable ? "" : "un");\r\nif (!test_bit(o2nm_this_node(), qs->qs_hb_bm) ||\r\nqs->qs_heartbeating == 1)\r\ngoto out;\r\nif (qs->qs_heartbeating & 1) {\r\nquorum = (qs->qs_heartbeating + 1)/2;\r\nif (qs->qs_connected < quorum) {\r\nmlog(ML_ERROR, "fencing this node because it is "\r\n"only connected to %u nodes and %u is needed "\r\n"to make a quorum out of %u heartbeating nodes\n",\r\nqs->qs_connected, quorum,\r\nqs->qs_heartbeating);\r\nfence = 1;\r\n}\r\n} else {\r\nquorum = qs->qs_heartbeating / 2;\r\nif (qs->qs_connected < quorum) {\r\nmlog(ML_ERROR, "fencing this node because it is "\r\n"only connected to %u nodes and %u is needed "\r\n"to make a quorum out of %u heartbeating nodes\n",\r\nqs->qs_connected, quorum,\r\nqs->qs_heartbeating);\r\nfence = 1;\r\n}\r\nelse if ((qs->qs_connected == quorum) &&\r\n!lowest_reachable) {\r\nmlog(ML_ERROR, "fencing this node because it is "\r\n"connected to a half-quorum of %u out of %u "\r\n"nodes which doesn't include the lowest active "\r\n"node %u\n", quorum, qs->qs_heartbeating,\r\nlowest_hb);\r\nfence = 1;\r\n}\r\n}\r\nout:\r\nspin_unlock(&qs->qs_lock);\r\nif (fence)\r\no2quo_fence_self();\r\n}\r\nstatic void o2quo_set_hold(struct o2quo_state *qs, u8 node)\r\n{\r\nassert_spin_locked(&qs->qs_lock);\r\nif (!test_and_set_bit(node, qs->qs_hold_bm)) {\r\nqs->qs_holds++;\r\nmlog_bug_on_msg(qs->qs_holds == O2NM_MAX_NODES,\r\n"node %u\n", node);\r\nmlog(0, "node %u, %d total\n", node, qs->qs_holds);\r\n}\r\n}\r\nstatic void o2quo_clear_hold(struct o2quo_state *qs, u8 node)\r\n{\r\nassert_spin_locked(&qs->qs_lock);\r\nif (test_and_clear_bit(node, qs->qs_hold_bm)) {\r\nmlog(0, "node %u, %d total\n", node, qs->qs_holds - 1);\r\nif (--qs->qs_holds == 0) {\r\nif (qs->qs_pending) {\r\nqs->qs_pending = 0;\r\nschedule_work(&qs->qs_work);\r\n}\r\n}\r\nmlog_bug_on_msg(qs->qs_holds < 0, "node %u, holds %d\n",\r\nnode, qs->qs_holds);\r\n}\r\n}\r\nvoid o2quo_hb_up(u8 node)\r\n{\r\nstruct o2quo_state *qs = &o2quo_state;\r\nspin_lock(&qs->qs_lock);\r\nqs->qs_heartbeating++;\r\nmlog_bug_on_msg(qs->qs_heartbeating == O2NM_MAX_NODES,\r\n"node %u\n", node);\r\nmlog_bug_on_msg(test_bit(node, qs->qs_hb_bm), "node %u\n", node);\r\nset_bit(node, qs->qs_hb_bm);\r\nmlog(0, "node %u, %d total\n", node, qs->qs_heartbeating);\r\nif (!test_bit(node, qs->qs_conn_bm))\r\no2quo_set_hold(qs, node);\r\nelse\r\no2quo_clear_hold(qs, node);\r\nspin_unlock(&qs->qs_lock);\r\n}\r\nvoid o2quo_hb_down(u8 node)\r\n{\r\nstruct o2quo_state *qs = &o2quo_state;\r\nspin_lock(&qs->qs_lock);\r\nqs->qs_heartbeating--;\r\nmlog_bug_on_msg(qs->qs_heartbeating < 0,\r\n"node %u, %d heartbeating\n",\r\nnode, qs->qs_heartbeating);\r\nmlog_bug_on_msg(!test_bit(node, qs->qs_hb_bm), "node %u\n", node);\r\nclear_bit(node, qs->qs_hb_bm);\r\nmlog(0, "node %u, %d total\n", node, qs->qs_heartbeating);\r\no2quo_clear_hold(qs, node);\r\nspin_unlock(&qs->qs_lock);\r\n}\r\nvoid o2quo_hb_still_up(u8 node)\r\n{\r\nstruct o2quo_state *qs = &o2quo_state;\r\nspin_lock(&qs->qs_lock);\r\nmlog(0, "node %u\n", node);\r\nqs->qs_pending = 1;\r\no2quo_clear_hold(qs, node);\r\nspin_unlock(&qs->qs_lock);\r\n}\r\nvoid o2quo_conn_up(u8 node)\r\n{\r\nstruct o2quo_state *qs = &o2quo_state;\r\nspin_lock(&qs->qs_lock);\r\nqs->qs_connected++;\r\nmlog_bug_on_msg(qs->qs_connected == O2NM_MAX_NODES,\r\n"node %u\n", node);\r\nmlog_bug_on_msg(test_bit(node, qs->qs_conn_bm), "node %u\n", node);\r\nset_bit(node, qs->qs_conn_bm);\r\nmlog(0, "node %u, %d total\n", node, qs->qs_connected);\r\nif (!test_bit(node, qs->qs_hb_bm))\r\no2quo_set_hold(qs, node);\r\nelse\r\no2quo_clear_hold(qs, node);\r\nspin_unlock(&qs->qs_lock);\r\n}\r\nvoid o2quo_conn_err(u8 node)\r\n{\r\nstruct o2quo_state *qs = &o2quo_state;\r\nspin_lock(&qs->qs_lock);\r\nif (test_bit(node, qs->qs_conn_bm)) {\r\nqs->qs_connected--;\r\nmlog_bug_on_msg(qs->qs_connected < 0,\r\n"node %u, connected %d\n",\r\nnode, qs->qs_connected);\r\nclear_bit(node, qs->qs_conn_bm);\r\n}\r\nmlog(0, "node %u, %d total\n", node, qs->qs_connected);\r\nif (test_bit(node, qs->qs_hb_bm))\r\no2quo_set_hold(qs, node);\r\nspin_unlock(&qs->qs_lock);\r\n}\r\nvoid o2quo_init(void)\r\n{\r\nstruct o2quo_state *qs = &o2quo_state;\r\nspin_lock_init(&qs->qs_lock);\r\nINIT_WORK(&qs->qs_work, o2quo_make_decision);\r\n}\r\nvoid o2quo_exit(void)\r\n{\r\nstruct o2quo_state *qs = &o2quo_state;\r\nflush_work_sync(&qs->qs_work);\r\n}
