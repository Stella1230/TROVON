static void __init dtc_setup(char *str, int *ints)\r\n{\r\nstatic int commandline_current = 0;\r\nint i;\r\nif (ints[0] != 2)\r\nprintk("dtc_setup: usage dtc=address,irq\n");\r\nelse if (commandline_current < NO_OVERRIDES) {\r\noverrides[commandline_current].address = ints[1];\r\noverrides[commandline_current].irq = ints[2];\r\nfor (i = 0; i < NO_BASES; ++i)\r\nif (bases[i].address == ints[1]) {\r\nbases[i].noauto = 1;\r\nbreak;\r\n}\r\n++commandline_current;\r\n}\r\n}\r\nstatic int __init dtc_detect(struct scsi_host_template * tpnt)\r\n{\r\nstatic int current_override = 0, current_base = 0;\r\nstruct Scsi_Host *instance;\r\nunsigned int addr;\r\nvoid __iomem *base;\r\nint sig, count;\r\ntpnt->proc_name = "dtc3x80";\r\ntpnt->proc_info = &dtc_proc_info;\r\nfor (count = 0; current_override < NO_OVERRIDES; ++current_override) {\r\naddr = 0;\r\nbase = NULL;\r\nif (overrides[current_override].address) {\r\naddr = overrides[current_override].address;\r\nbase = ioremap(addr, 0x2000);\r\nif (!base)\r\naddr = 0;\r\n} else\r\nfor (; !addr && (current_base < NO_BASES); ++current_base) {\r\n#if (DTCDEBUG & DTCDEBUG_INIT)\r\nprintk(KERN_DEBUG "scsi-dtc : probing address %08x\n", bases[current_base].address);\r\n#endif\r\nif (bases[current_base].noauto)\r\ncontinue;\r\nbase = ioremap(bases[current_base].address, 0x2000);\r\nif (!base)\r\ncontinue;\r\nfor (sig = 0; sig < NO_SIGNATURES; ++sig) {\r\nif (check_signature(base + signatures[sig].offset, signatures[sig].string, strlen(signatures[sig].string))) {\r\naddr = bases[current_base].address;\r\n#if (DTCDEBUG & DTCDEBUG_INIT)\r\nprintk(KERN_DEBUG "scsi-dtc : detected board.\n");\r\n#endif\r\ngoto found;\r\n}\r\n}\r\niounmap(base);\r\n}\r\n#if defined(DTCDEBUG) && (DTCDEBUG & DTCDEBUG_INIT)\r\nprintk(KERN_DEBUG "scsi-dtc : base = %08x\n", addr);\r\n#endif\r\nif (!addr)\r\nbreak;\r\nfound:\r\ninstance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));\r\nif (instance == NULL)\r\nbreak;\r\ninstance->base = addr;\r\n((struct NCR5380_hostdata *)(instance)->hostdata)->base = base;\r\nNCR5380_init(instance, 0);\r\nNCR5380_write(DTC_CONTROL_REG, CSR_5380_INTR);\r\nif (overrides[current_override].irq != IRQ_AUTO)\r\ninstance->irq = overrides[current_override].irq;\r\nelse\r\ninstance->irq = NCR5380_probe_irq(instance, DTC_IRQS);\r\n#ifndef DONT_USE_INTR\r\nif (instance->irq != SCSI_IRQ_NONE)\r\nif (request_irq(instance->irq, dtc_intr, IRQF_DISABLED,\r\n"dtc", instance)) {\r\nprintk(KERN_ERR "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);\r\ninstance->irq = SCSI_IRQ_NONE;\r\n}\r\nif (instance->irq == SCSI_IRQ_NONE) {\r\nprintk(KERN_WARNING "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);\r\nprintk(KERN_WARNING "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);\r\n}\r\n#else\r\nif (instance->irq != SCSI_IRQ_NONE)\r\nprintk(KERN_WARNING "scsi%d : interrupts not used. Might as well not jumper it.\n", instance->host_no);\r\ninstance->irq = SCSI_IRQ_NONE;\r\n#endif\r\n#if defined(DTCDEBUG) && (DTCDEBUG & DTCDEBUG_INIT)\r\nprintk("scsi%d : irq = %d\n", instance->host_no, instance->irq);\r\n#endif\r\nprintk(KERN_INFO "scsi%d : at 0x%05X", instance->host_no, (int) instance->base);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nprintk(" interrupts disabled");\r\nelse\r\nprintk(" irq %d", instance->irq);\r\nprintk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d", CAN_QUEUE, CMD_PER_LUN, DTC_PUBLIC_RELEASE);\r\nNCR5380_print_options(instance);\r\nprintk("\n");\r\n++current_override;\r\n++count;\r\n}\r\nreturn count;\r\n}\r\nstatic int dtc_biosparam(struct scsi_device *sdev, struct block_device *dev,\r\nsector_t capacity, int *ip)\r\n{\r\nint size = capacity;\r\nip[0] = 64;\r\nip[1] = 32;\r\nip[2] = size >> 11;\r\nreturn 0;\r\n}\r\nstatic inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst, int len)\r\n{\r\nunsigned char *d = dst;\r\nint i;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\ni = 0;\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nNCR5380_write(MODE_REG, MR_ENABLE_EOP_INTR | MR_DMA_MODE);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nNCR5380_write(DTC_CONTROL_REG, CSR_DIR_READ);\r\nelse\r\nNCR5380_write(DTC_CONTROL_REG, CSR_DIR_READ | CSR_INT_BASE);\r\nNCR5380_write(DTC_BLK_CNT, len >> 7);\r\nrtrc(1);\r\nwhile (len > 0) {\r\nrtrc(2);\r\nwhile (NCR5380_read(DTC_CONTROL_REG) & CSR_HOST_BUF_NOT_RDY)\r\n++i;\r\nrtrc(3);\r\nmemcpy_fromio(d, base + DTC_DATA_BUF, 128);\r\nd += 128;\r\nlen -= 128;\r\nrtrc(7);\r\n}\r\nrtrc(4);\r\nwhile (!(NCR5380_read(DTC_CONTROL_REG) & D_CR_ACCESS))\r\n++i;\r\nNCR5380_write(MODE_REG, 0);\r\nrtrc(0);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nif (i > dtc_maxi)\r\ndtc_maxi = i;\r\nreturn (0);\r\n}\r\nstatic inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src, int len)\r\n{\r\nint i;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nNCR5380_write(MODE_REG, MR_ENABLE_EOP_INTR | MR_DMA_MODE);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nNCR5380_write(DTC_CONTROL_REG, 0);\r\nelse\r\nNCR5380_write(DTC_CONTROL_REG, CSR_5380_INTR);\r\nNCR5380_write(DTC_BLK_CNT, len >> 7);\r\nfor (i = 0; len > 0; ++i) {\r\nrtrc(5);\r\nwhile (NCR5380_read(DTC_CONTROL_REG) & CSR_HOST_BUF_NOT_RDY)\r\n++i;\r\nrtrc(3);\r\nmemcpy_toio(base + DTC_DATA_BUF, src, 128);\r\nsrc += 128;\r\nlen -= 128;\r\n}\r\nrtrc(4);\r\nwhile (!(NCR5380_read(DTC_CONTROL_REG) & D_CR_ACCESS))\r\n++i;\r\nrtrc(6);\r\nwhile (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT))\r\n++i;\r\nrtrc(7);\r\nNCR5380_write(MODE_REG, 0);\r\nrtrc(0);\r\nif (i > dtc_wmaxi)\r\ndtc_wmaxi = i;\r\nreturn (0);\r\n}\r\nstatic int dtc_release(struct Scsi_Host *shost)\r\n{\r\nNCR5380_local_declare();\r\nNCR5380_setup(shost);\r\nif (shost->irq)\r\nfree_irq(shost->irq, shost);\r\nNCR5380_exit(shost);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\niounmap(base);\r\nreturn 0;\r\n}
