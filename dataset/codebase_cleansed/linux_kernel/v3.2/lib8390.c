static int __ei_open(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif (dev->watchdog_timeo <= 0)\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\n__NS8390_init(dev, 1);\r\nnetif_start_queue(dev);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nei_local->irqlock = 0;\r\nreturn 0;\r\n}\r\nstatic int __ei_close(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\n__NS8390_init(dev, 0);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void __ei_tx_timeout(struct net_device *dev)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint txsr, isr, tickssofar = jiffies - dev_trans_start(dev);\r\nunsigned long flags;\r\ndev->stats.tx_errors++;\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\ntxsr = ei_inb(e8390_base+EN0_TSR);\r\nisr = ei_inb(e8390_base+EN0_ISR);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nnetdev_dbg(dev, "Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d\n",\r\n(txsr & ENTSR_ABT) ? "excess collisions." :\r\n(isr) ? "lost interrupt?" : "cable problem?",\r\ntxsr, isr, tickssofar);\r\nif (!isr && !dev->stats.tx_packets) {\r\nei_local->interface_num ^= 1;\r\n}\r\ndisable_irq_nosync_lockdep(dev->irq);\r\nspin_lock(&ei_local->page_lock);\r\nei_reset_8390(dev);\r\n__NS8390_init(dev, 1);\r\nspin_unlock(&ei_local->page_lock);\r\nenable_irq_lockdep(dev->irq);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t __ei_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint send_length = skb->len, output_page;\r\nunsigned long flags;\r\nchar buf[ETH_ZLEN];\r\nchar *data = skb->data;\r\nif (skb->len < ETH_ZLEN) {\r\nmemset(buf, 0, ETH_ZLEN);\r\nmemcpy(buf, data, skb->len);\r\nsend_length = ETH_ZLEN;\r\ndata = buf;\r\n}\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\nei_outb_p(0x00, e8390_base + EN0_IMR);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\ndisable_irq_nosync_lockdep_irqsave(dev->irq, &flags);\r\nspin_lock(&ei_local->page_lock);\r\nei_local->irqlock = 1;\r\nif (ei_local->tx1 == 0) {\r\noutput_page = ei_local->tx_start_page;\r\nei_local->tx1 = send_length;\r\nif (ei_debug && ei_local->tx2 > 0)\r\nnetdev_dbg(dev, "idle transmitter tx2=%d, lasttx=%d, txing=%d\n",\r\nei_local->tx2, ei_local->lasttx, ei_local->txing);\r\n} else if (ei_local->tx2 == 0) {\r\noutput_page = ei_local->tx_start_page + TX_PAGES/2;\r\nei_local->tx2 = send_length;\r\nif (ei_debug && ei_local->tx1 > 0)\r\nnetdev_dbg(dev, "idle transmitter, tx1=%d, lasttx=%d, txing=%d\n",\r\nei_local->tx1, ei_local->lasttx, ei_local->txing);\r\n} else {\r\nif (ei_debug)\r\nnetdev_dbg(dev, "No Tx buffers free! tx1=%d tx2=%d last=%d\n",\r\nei_local->tx1, ei_local->tx2, ei_local->lasttx);\r\nei_local->irqlock = 0;\r\nnetif_stop_queue(dev);\r\nei_outb_p(ENISR_ALL, e8390_base + EN0_IMR);\r\nspin_unlock(&ei_local->page_lock);\r\nenable_irq_lockdep_irqrestore(dev->irq, &flags);\r\ndev->stats.tx_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nei_block_output(dev, send_length, data, output_page);\r\nif (!ei_local->txing) {\r\nei_local->txing = 1;\r\nNS8390_trigger_send(dev, send_length, output_page);\r\nif (output_page == ei_local->tx_start_page) {\r\nei_local->tx1 = -1;\r\nei_local->lasttx = -1;\r\n} else {\r\nei_local->tx2 = -1;\r\nei_local->lasttx = -2;\r\n}\r\n} else\r\nei_local->txqueue++;\r\nif (ei_local->tx1 && ei_local->tx2)\r\nnetif_stop_queue(dev);\r\nelse\r\nnetif_start_queue(dev);\r\nei_local->irqlock = 0;\r\nei_outb_p(ENISR_ALL, e8390_base + EN0_IMR);\r\nspin_unlock(&ei_local->page_lock);\r\nenable_irq_lockdep_irqrestore(dev->irq, &flags);\r\nskb_tx_timestamp(skb);\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_bytes += send_length;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t __ei_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nunsigned long e8390_base = dev->base_addr;\r\nint interrupts, nr_serviced = 0;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nspin_lock(&ei_local->page_lock);\r\nif (ei_local->irqlock) {\r\nnetdev_err(dev, "Interrupted while interrupts are masked! isr=%#2x imr=%#2x\n",\r\nei_inb_p(e8390_base + EN0_ISR),\r\nei_inb_p(e8390_base + EN0_IMR));\r\nspin_unlock(&ei_local->page_lock);\r\nreturn IRQ_NONE;\r\n}\r\nei_outb_p(E8390_NODMA+E8390_PAGE0, e8390_base + E8390_CMD);\r\nif (ei_debug > 3)\r\nnetdev_dbg(dev, "interrupt(isr=%#2.2x)\n",\r\nei_inb_p(e8390_base + EN0_ISR));\r\nwhile ((interrupts = ei_inb_p(e8390_base + EN0_ISR)) != 0 &&\r\n++nr_serviced < MAX_SERVICE) {\r\nif (!netif_running(dev)) {\r\nnetdev_warn(dev, "interrupt from stopped card\n");\r\nei_outb_p(interrupts, e8390_base + EN0_ISR);\r\ninterrupts = 0;\r\nbreak;\r\n}\r\nif (interrupts & ENISR_OVER)\r\nei_rx_overrun(dev);\r\nelse if (interrupts & (ENISR_RX+ENISR_RX_ERR)) {\r\nei_receive(dev);\r\n}\r\nif (interrupts & ENISR_TX)\r\nei_tx_intr(dev);\r\nelse if (interrupts & ENISR_TX_ERR)\r\nei_tx_err(dev);\r\nif (interrupts & ENISR_COUNTERS) {\r\ndev->stats.rx_frame_errors += ei_inb_p(e8390_base + EN0_COUNTER0);\r\ndev->stats.rx_crc_errors += ei_inb_p(e8390_base + EN0_COUNTER1);\r\ndev->stats.rx_missed_errors += ei_inb_p(e8390_base + EN0_COUNTER2);\r\nei_outb_p(ENISR_COUNTERS, e8390_base + EN0_ISR);\r\n}\r\nif (interrupts & ENISR_RDC)\r\nei_outb_p(ENISR_RDC, e8390_base + EN0_ISR);\r\nei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base + E8390_CMD);\r\n}\r\nif (interrupts && ei_debug) {\r\nei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base + E8390_CMD);\r\nif (nr_serviced >= MAX_SERVICE) {\r\nif (interrupts != 0xFF)\r\nnetdev_warn(dev, "Too much work at interrupt, status %#2.2x\n",\r\ninterrupts);\r\nei_outb_p(ENISR_ALL, e8390_base + EN0_ISR);\r\n} else {\r\nnetdev_warn(dev, "unknown interrupt %#2x\n", interrupts);\r\nei_outb_p(0xff, e8390_base + EN0_ISR);\r\n}\r\n}\r\nspin_unlock(&ei_local->page_lock);\r\nreturn IRQ_RETVAL(nr_serviced > 0);\r\n}\r\nstatic void __ei_poll(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\n__ei_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic void ei_tx_err(struct net_device *dev)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local __maybe_unused = netdev_priv(dev);\r\nunsigned char txsr = ei_inb_p(e8390_base+EN0_TSR);\r\nunsigned char tx_was_aborted = txsr & (ENTSR_ABT+ENTSR_FU);\r\n#ifdef VERBOSE_ERROR_DUMP\r\nnetdev_dbg(dev, "transmitter error (%#2x):", txsr);\r\nif (txsr & ENTSR_ABT)\r\npr_cont(" excess-collisions ");\r\nif (txsr & ENTSR_ND)\r\npr_cont(" non-deferral ");\r\nif (txsr & ENTSR_CRS)\r\npr_cont(" lost-carrier ");\r\nif (txsr & ENTSR_FU)\r\npr_cont(" FIFO-underrun ");\r\nif (txsr & ENTSR_CDH)\r\npr_cont(" lost-heartbeat ");\r\npr_cont("\n");\r\n#endif\r\nei_outb_p(ENISR_TX_ERR, e8390_base + EN0_ISR);\r\nif (tx_was_aborted)\r\nei_tx_intr(dev);\r\nelse {\r\ndev->stats.tx_errors++;\r\nif (txsr & ENTSR_CRS)\r\ndev->stats.tx_carrier_errors++;\r\nif (txsr & ENTSR_CDH)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (txsr & ENTSR_OWC)\r\ndev->stats.tx_window_errors++;\r\n}\r\n}\r\nstatic void ei_tx_intr(struct net_device *dev)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint status = ei_inb(e8390_base + EN0_TSR);\r\nei_outb_p(ENISR_TX, e8390_base + EN0_ISR);\r\nei_local->txqueue--;\r\nif (ei_local->tx1 < 0) {\r\nif (ei_local->lasttx != 1 && ei_local->lasttx != -1)\r\npr_err("%s: bogus last_tx_buffer %d, tx1=%d\n",\r\nei_local->name, ei_local->lasttx, ei_local->tx1);\r\nei_local->tx1 = 0;\r\nif (ei_local->tx2 > 0) {\r\nei_local->txing = 1;\r\nNS8390_trigger_send(dev, ei_local->tx2, ei_local->tx_start_page + 6);\r\ndev->trans_start = jiffies;\r\nei_local->tx2 = -1,\r\nei_local->lasttx = 2;\r\n} else\r\nei_local->lasttx = 20, ei_local->txing = 0;\r\n} else if (ei_local->tx2 < 0) {\r\nif (ei_local->lasttx != 2 && ei_local->lasttx != -2)\r\npr_err("%s: bogus last_tx_buffer %d, tx2=%d\n",\r\nei_local->name, ei_local->lasttx, ei_local->tx2);\r\nei_local->tx2 = 0;\r\nif (ei_local->tx1 > 0) {\r\nei_local->txing = 1;\r\nNS8390_trigger_send(dev, ei_local->tx1, ei_local->tx_start_page);\r\ndev->trans_start = jiffies;\r\nei_local->tx1 = -1;\r\nei_local->lasttx = 1;\r\n} else\r\nei_local->lasttx = 10, ei_local->txing = 0;\r\n}\r\nif (status & ENTSR_COL)\r\ndev->stats.collisions++;\r\nif (status & ENTSR_PTX)\r\ndev->stats.tx_packets++;\r\nelse {\r\ndev->stats.tx_errors++;\r\nif (status & ENTSR_ABT) {\r\ndev->stats.tx_aborted_errors++;\r\ndev->stats.collisions += 16;\r\n}\r\nif (status & ENTSR_CRS)\r\ndev->stats.tx_carrier_errors++;\r\nif (status & ENTSR_FU)\r\ndev->stats.tx_fifo_errors++;\r\nif (status & ENTSR_CDH)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (status & ENTSR_OWC)\r\ndev->stats.tx_window_errors++;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void ei_receive(struct net_device *dev)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned char rxing_page, this_frame, next_frame;\r\nunsigned short current_offset;\r\nint rx_pkt_count = 0;\r\nstruct e8390_pkt_hdr rx_frame;\r\nint num_rx_pages = ei_local->stop_page-ei_local->rx_start_page;\r\nwhile (++rx_pkt_count < 10) {\r\nint pkt_len, pkt_stat;\r\nei_outb_p(E8390_NODMA+E8390_PAGE1, e8390_base + E8390_CMD);\r\nrxing_page = ei_inb_p(e8390_base + EN1_CURPAG);\r\nei_outb_p(E8390_NODMA+E8390_PAGE0, e8390_base + E8390_CMD);\r\nthis_frame = ei_inb_p(e8390_base + EN0_BOUNDARY) + 1;\r\nif (this_frame >= ei_local->stop_page)\r\nthis_frame = ei_local->rx_start_page;\r\nif (ei_debug > 0 &&\r\nthis_frame != ei_local->current_page &&\r\n(this_frame != 0x0 || rxing_page != 0xFF))\r\nnetdev_err(dev, "mismatched read page pointers %2x vs %2x\n",\r\nthis_frame, ei_local->current_page);\r\nif (this_frame == rxing_page)\r\nbreak;\r\ncurrent_offset = this_frame << 8;\r\nei_get_8390_hdr(dev, &rx_frame, this_frame);\r\npkt_len = rx_frame.count - sizeof(struct e8390_pkt_hdr);\r\npkt_stat = rx_frame.status;\r\nnext_frame = this_frame + 1 + ((pkt_len+4)>>8);\r\nif (rx_frame.next != next_frame &&\r\nrx_frame.next != next_frame + 1 &&\r\nrx_frame.next != next_frame - num_rx_pages &&\r\nrx_frame.next != next_frame + 1 - num_rx_pages) {\r\nei_local->current_page = rxing_page;\r\nei_outb(ei_local->current_page-1, e8390_base+EN0_BOUNDARY);\r\ndev->stats.rx_errors++;\r\ncontinue;\r\n}\r\nif (pkt_len < 60 || pkt_len > 1518) {\r\nif (ei_debug)\r\nnetdev_dbg(dev, "bogus packet size: %d, status=%#2x nxpg=%#2x\n",\r\nrx_frame.count, rx_frame.status,\r\nrx_frame.next);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\n} else if ((pkt_stat & 0x0F) == ENRSR_RXOK) {\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(pkt_len+2);\r\nif (skb == NULL) {\r\nif (ei_debug > 1)\r\nnetdev_dbg(dev, "Couldn't allocate a sk_buff of size %d\n",\r\npkt_len);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n} else {\r\nskb_reserve(skb, 2);\r\nskb_put(skb, pkt_len);\r\nei_block_input(dev, pkt_len, skb, current_offset + sizeof(rx_frame));\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (!skb_defer_rx_timestamp(skb))\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\nif (pkt_stat & ENRSR_PHY)\r\ndev->stats.multicast++;\r\n}\r\n} else {\r\nif (ei_debug)\r\nnetdev_dbg(dev, "bogus packet: status=%#2x nxpg=%#2x size=%d\n",\r\nrx_frame.status, rx_frame.next,\r\nrx_frame.count);\r\ndev->stats.rx_errors++;\r\nif (pkt_stat & ENRSR_FO)\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nnext_frame = rx_frame.next;\r\nif (next_frame >= ei_local->stop_page) {\r\nnetdev_notice(dev, "next frame inconsistency, %#2x\n",\r\nnext_frame);\r\nnext_frame = ei_local->rx_start_page;\r\n}\r\nei_local->current_page = next_frame;\r\nei_outb_p(next_frame-1, e8390_base+EN0_BOUNDARY);\r\n}\r\nei_outb_p(ENISR_RX+ENISR_RX_ERR, e8390_base+EN0_ISR);\r\n}\r\nstatic void ei_rx_overrun(struct net_device *dev)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nunsigned char was_txing, must_resend = 0;\r\nstruct ei_device *ei_local __maybe_unused = netdev_priv(dev);\r\nwas_txing = ei_inb_p(e8390_base+E8390_CMD) & E8390_TRANS;\r\nei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\r\nif (ei_debug > 1)\r\nnetdev_dbg(dev, "Receiver overrun\n");\r\ndev->stats.rx_over_errors++;\r\nmdelay(10);\r\nei_outb_p(0x00, e8390_base+EN0_RCNTLO);\r\nei_outb_p(0x00, e8390_base+EN0_RCNTHI);\r\nif (was_txing) {\r\nunsigned char tx_completed = ei_inb_p(e8390_base+EN0_ISR) & (ENISR_TX+ENISR_TX_ERR);\r\nif (!tx_completed)\r\nmust_resend = 1;\r\n}\r\nei_outb_p(E8390_TXOFF, e8390_base + EN0_TXCR);\r\nei_outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START, e8390_base + E8390_CMD);\r\nei_receive(dev);\r\nei_outb_p(ENISR_OVER, e8390_base+EN0_ISR);\r\nei_outb_p(E8390_TXCONFIG, e8390_base + EN0_TXCR);\r\nif (must_resend)\r\nei_outb_p(E8390_NODMA + E8390_PAGE0 + E8390_START + E8390_TRANS, e8390_base + E8390_CMD);\r\n}\r\nstatic struct net_device_stats *__ei_get_stats(struct net_device *dev)\r\n{\r\nunsigned long ioaddr = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned long flags;\r\nif (!netif_running(dev))\r\nreturn &dev->stats;\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\ndev->stats.rx_frame_errors += ei_inb_p(ioaddr + EN0_COUNTER0);\r\ndev->stats.rx_crc_errors += ei_inb_p(ioaddr + EN0_COUNTER1);\r\ndev->stats.rx_missed_errors += ei_inb_p(ioaddr + EN0_COUNTER2);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic inline void make_mc_bits(u8 *bits, struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu32 crc = ether_crc(ETH_ALEN, ha->addr);\r\nbits[crc>>29] |= (1<<((crc>>26)&7));\r\n}\r\n}\r\nstatic void do_set_multicast_list(struct net_device *dev)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nint i;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif (!(dev->flags&(IFF_PROMISC|IFF_ALLMULTI))) {\r\nmemset(ei_local->mcfilter, 0, 8);\r\nif (!netdev_mc_empty(dev))\r\nmake_mc_bits(ei_local->mcfilter, dev);\r\n} else\r\nmemset(ei_local->mcfilter, 0xFF, 8);\r\nif (netif_running(dev))\r\nei_outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);\r\nei_outb_p(E8390_NODMA + E8390_PAGE1, e8390_base + E8390_CMD);\r\nfor (i = 0; i < 8; i++) {\r\nei_outb_p(ei_local->mcfilter[i], e8390_base + EN1_MULT_SHIFT(i));\r\n#ifndef BUG_83C690\r\nif (ei_inb_p(e8390_base + EN1_MULT_SHIFT(i)) != ei_local->mcfilter[i])\r\nnetdev_err(dev, "Multicast filter read/write mismap %d\n",\r\ni);\r\n#endif\r\n}\r\nei_outb_p(E8390_NODMA + E8390_PAGE0, e8390_base + E8390_CMD);\r\nif (dev->flags&IFF_PROMISC)\r\nei_outb_p(E8390_RXCONFIG | 0x18, e8390_base + EN0_RXCR);\r\nelse if (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev))\r\nei_outb_p(E8390_RXCONFIG | 0x08, e8390_base + EN0_RXCR);\r\nelse\r\nei_outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);\r\n}\r\nstatic void __ei_set_multicast_list(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\ndo_set_multicast_list(dev);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\n}\r\nstatic void ethdev_setup(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif (ei_debug > 1)\r\nprintk(version);\r\nether_setup(dev);\r\nspin_lock_init(&ei_local->page_lock);\r\n}\r\nstatic struct net_device *____alloc_ei_netdev(int size)\r\n{\r\nreturn alloc_netdev(sizeof(struct ei_device) + size, "eth%d",\r\nethdev_setup);\r\n}\r\nstatic void __NS8390_init(struct net_device *dev, int startp)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint i;\r\nint endcfg = ei_local->word16\r\n? (0x48 | ENDCFG_WTS | (ei_local->bigendian ? ENDCFG_BOS : 0))\r\n: 0x48;\r\nif (sizeof(struct e8390_pkt_hdr) != 4)\r\npanic("8390.c: header struct mispacked\n");\r\nei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\r\nei_outb_p(endcfg, e8390_base + EN0_DCFG);\r\nei_outb_p(0x00, e8390_base + EN0_RCNTLO);\r\nei_outb_p(0x00, e8390_base + EN0_RCNTHI);\r\nei_outb_p(E8390_RXOFF, e8390_base + EN0_RXCR);\r\nei_outb_p(E8390_TXOFF, e8390_base + EN0_TXCR);\r\nei_outb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);\r\nei_local->tx1 = ei_local->tx2 = 0;\r\nei_outb_p(ei_local->rx_start_page, e8390_base + EN0_STARTPG);\r\nei_outb_p(ei_local->stop_page-1, e8390_base + EN0_BOUNDARY);\r\nei_local->current_page = ei_local->rx_start_page;\r\nei_outb_p(ei_local->stop_page, e8390_base + EN0_STOPPG);\r\nei_outb_p(0xFF, e8390_base + EN0_ISR);\r\nei_outb_p(0x00, e8390_base + EN0_IMR);\r\nei_outb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, e8390_base+E8390_CMD);\r\nfor (i = 0; i < 6; i++) {\r\nei_outb_p(dev->dev_addr[i], e8390_base + EN1_PHYS_SHIFT(i));\r\nif (ei_debug > 1 &&\r\nei_inb_p(e8390_base + EN1_PHYS_SHIFT(i)) != dev->dev_addr[i])\r\nnetdev_err(dev, "Hw. address read/write mismap %d\n", i);\r\n}\r\nei_outb_p(ei_local->rx_start_page, e8390_base + EN1_CURPAG);\r\nei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\r\nei_local->tx1 = ei_local->tx2 = 0;\r\nei_local->txing = 0;\r\nif (startp) {\r\nei_outb_p(0xff, e8390_base + EN0_ISR);\r\nei_outb_p(ENISR_ALL, e8390_base + EN0_IMR);\r\nei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);\r\nei_outb_p(E8390_TXCONFIG, e8390_base + EN0_TXCR);\r\nei_outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR);\r\ndo_set_multicast_list(dev);\r\n}\r\n}\r\nstatic void NS8390_trigger_send(struct net_device *dev, unsigned int length,\r\nint start_page)\r\n{\r\nunsigned long e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local __attribute((unused)) = netdev_priv(dev);\r\nei_outb_p(E8390_NODMA+E8390_PAGE0, e8390_base+E8390_CMD);\r\nif (ei_inb_p(e8390_base + E8390_CMD) & E8390_TRANS) {\r\nnetdev_warn(dev, "trigger_send() called with the transmitter busy\n");\r\nreturn;\r\n}\r\nei_outb_p(length & 0xff, e8390_base + EN0_TCNTLO);\r\nei_outb_p(length >> 8, e8390_base + EN0_TCNTHI);\r\nei_outb_p(start_page, e8390_base + EN0_TPSR);\r\nei_outb_p(E8390_NODMA+E8390_TRANS+E8390_START, e8390_base+E8390_CMD);\r\n}
