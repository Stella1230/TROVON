static bool vhost_sock_zcopy(struct socket *sock)\r\n{\r\nreturn unlikely(experimental_zcopytx) &&\r\nsock_flag(sock->sk, SOCK_ZEROCOPY);\r\n}\r\nstatic int move_iovec_hdr(struct iovec *from, struct iovec *to,\r\nsize_t len, int iov_count)\r\n{\r\nint seg = 0;\r\nsize_t size;\r\nwhile (len && seg < iov_count) {\r\nsize = min(from->iov_len, len);\r\nto->iov_base = from->iov_base;\r\nto->iov_len = size;\r\nfrom->iov_len -= size;\r\nfrom->iov_base += size;\r\nlen -= size;\r\n++from;\r\n++to;\r\n++seg;\r\n}\r\nreturn seg;\r\n}\r\nstatic void copy_iovec_hdr(const struct iovec *from, struct iovec *to,\r\nsize_t len, int iovcount)\r\n{\r\nint seg = 0;\r\nsize_t size;\r\nwhile (len && seg < iovcount) {\r\nsize = min(from->iov_len, len);\r\nto->iov_base = from->iov_base;\r\nto->iov_len = size;\r\nlen -= size;\r\n++from;\r\n++to;\r\n++seg;\r\n}\r\n}\r\nstatic void tx_poll_stop(struct vhost_net *net)\r\n{\r\nif (likely(net->tx_poll_state != VHOST_NET_POLL_STARTED))\r\nreturn;\r\nvhost_poll_stop(net->poll + VHOST_NET_VQ_TX);\r\nnet->tx_poll_state = VHOST_NET_POLL_STOPPED;\r\n}\r\nstatic void tx_poll_start(struct vhost_net *net, struct socket *sock)\r\n{\r\nif (unlikely(net->tx_poll_state != VHOST_NET_POLL_STOPPED))\r\nreturn;\r\nvhost_poll_start(net->poll + VHOST_NET_VQ_TX, sock->file);\r\nnet->tx_poll_state = VHOST_NET_POLL_STARTED;\r\n}\r\nstatic void handle_tx(struct vhost_net *net)\r\n{\r\nstruct vhost_virtqueue *vq = &net->dev.vqs[VHOST_NET_VQ_TX];\r\nunsigned out, in, s;\r\nint head;\r\nstruct msghdr msg = {\r\n.msg_name = NULL,\r\n.msg_namelen = 0,\r\n.msg_control = NULL,\r\n.msg_controllen = 0,\r\n.msg_iov = vq->iov,\r\n.msg_flags = MSG_DONTWAIT,\r\n};\r\nsize_t len, total_len = 0;\r\nint err, wmem;\r\nsize_t hdr_size;\r\nstruct socket *sock;\r\nstruct vhost_ubuf_ref *uninitialized_var(ubufs);\r\nbool zcopy;\r\nsock = rcu_dereference_check(vq->private_data, 1);\r\nif (!sock)\r\nreturn;\r\nwmem = atomic_read(&sock->sk->sk_wmem_alloc);\r\nif (wmem >= sock->sk->sk_sndbuf) {\r\nmutex_lock(&vq->mutex);\r\ntx_poll_start(net, sock);\r\nmutex_unlock(&vq->mutex);\r\nreturn;\r\n}\r\nmutex_lock(&vq->mutex);\r\nvhost_disable_notify(&net->dev, vq);\r\nif (wmem < sock->sk->sk_sndbuf / 2)\r\ntx_poll_stop(net);\r\nhdr_size = vq->vhost_hlen;\r\nzcopy = vhost_sock_zcopy(sock);\r\nfor (;;) {\r\nif (zcopy)\r\nvhost_zerocopy_signal_used(vq);\r\nhead = vhost_get_vq_desc(&net->dev, vq, vq->iov,\r\nARRAY_SIZE(vq->iov),\r\n&out, &in,\r\nNULL, NULL);\r\nif (unlikely(head < 0))\r\nbreak;\r\nif (head == vq->num) {\r\nint num_pends;\r\nwmem = atomic_read(&sock->sk->sk_wmem_alloc);\r\nif (wmem >= sock->sk->sk_sndbuf * 3 / 4) {\r\ntx_poll_start(net, sock);\r\nset_bit(SOCK_ASYNC_NOSPACE, &sock->flags);\r\nbreak;\r\n}\r\nnum_pends = likely(vq->upend_idx >= vq->done_idx) ?\r\n(vq->upend_idx - vq->done_idx) :\r\n(vq->upend_idx + UIO_MAXIOV - vq->done_idx);\r\nif (unlikely(num_pends > VHOST_MAX_PEND)) {\r\ntx_poll_start(net, sock);\r\nset_bit(SOCK_ASYNC_NOSPACE, &sock->flags);\r\nbreak;\r\n}\r\nif (unlikely(vhost_enable_notify(&net->dev, vq))) {\r\nvhost_disable_notify(&net->dev, vq);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (in) {\r\nvq_err(vq, "Unexpected descriptor format for TX: "\r\n"out %d, int %d\n", out, in);\r\nbreak;\r\n}\r\ns = move_iovec_hdr(vq->iov, vq->hdr, hdr_size, out);\r\nmsg.msg_iovlen = out;\r\nlen = iov_length(vq->iov, out);\r\nif (!len) {\r\nvq_err(vq, "Unexpected header len for TX: "\r\n"%zd expected %zd\n",\r\niov_length(vq->hdr, s), hdr_size);\r\nbreak;\r\n}\r\nif (zcopy) {\r\nvq->heads[vq->upend_idx].id = head;\r\nif (len < VHOST_GOODCOPY_LEN) {\r\nvq->heads[vq->upend_idx].len =\r\nVHOST_DMA_DONE_LEN;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nubufs = NULL;\r\n} else {\r\nstruct ubuf_info *ubuf = &vq->ubuf_info[head];\r\nvq->heads[vq->upend_idx].len = len;\r\nubuf->callback = vhost_zerocopy_callback;\r\nubuf->arg = vq->ubufs;\r\nubuf->desc = vq->upend_idx;\r\nmsg.msg_control = ubuf;\r\nmsg.msg_controllen = sizeof(ubuf);\r\nubufs = vq->ubufs;\r\nkref_get(&ubufs->kref);\r\n}\r\nvq->upend_idx = (vq->upend_idx + 1) % UIO_MAXIOV;\r\n}\r\nerr = sock->ops->sendmsg(NULL, sock, &msg, len);\r\nif (unlikely(err < 0)) {\r\nif (zcopy) {\r\nif (ubufs)\r\nvhost_ubuf_put(ubufs);\r\nvq->upend_idx = ((unsigned)vq->upend_idx - 1) %\r\nUIO_MAXIOV;\r\n}\r\nvhost_discard_vq_desc(vq, 1);\r\ntx_poll_start(net, sock);\r\nbreak;\r\n}\r\nif (err != len)\r\npr_debug("Truncated TX packet: "\r\n" len %d != %zd\n", err, len);\r\nif (!zcopy)\r\nvhost_add_used_and_signal(&net->dev, vq, head, 0);\r\ntotal_len += len;\r\nif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\r\nvhost_poll_queue(&vq->poll);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vq->mutex);\r\n}\r\nstatic int peek_head_len(struct sock *sk)\r\n{\r\nstruct sk_buff *head;\r\nint len = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sk->sk_receive_queue.lock, flags);\r\nhead = skb_peek(&sk->sk_receive_queue);\r\nif (likely(head))\r\nlen = head->len;\r\nspin_unlock_irqrestore(&sk->sk_receive_queue.lock, flags);\r\nreturn len;\r\n}\r\nstatic int get_rx_bufs(struct vhost_virtqueue *vq,\r\nstruct vring_used_elem *heads,\r\nint datalen,\r\nunsigned *iovcount,\r\nstruct vhost_log *log,\r\nunsigned *log_num,\r\nunsigned int quota)\r\n{\r\nunsigned int out, in;\r\nint seg = 0;\r\nint headcount = 0;\r\nunsigned d;\r\nint r, nlogs = 0;\r\nwhile (datalen > 0 && headcount < quota) {\r\nif (unlikely(seg >= UIO_MAXIOV)) {\r\nr = -ENOBUFS;\r\ngoto err;\r\n}\r\nd = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\r\nARRAY_SIZE(vq->iov) - seg, &out,\r\n&in, log, log_num);\r\nif (d == vq->num) {\r\nr = 0;\r\ngoto err;\r\n}\r\nif (unlikely(out || in <= 0)) {\r\nvq_err(vq, "unexpected descriptor format for RX: "\r\n"out %d, in %d\n", out, in);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nif (unlikely(log)) {\r\nnlogs += *log_num;\r\nlog += *log_num;\r\n}\r\nheads[headcount].id = d;\r\nheads[headcount].len = iov_length(vq->iov + seg, in);\r\ndatalen -= heads[headcount].len;\r\n++headcount;\r\nseg += in;\r\n}\r\nheads[headcount - 1].len += datalen;\r\n*iovcount = seg;\r\nif (unlikely(log))\r\n*log_num = nlogs;\r\nreturn headcount;\r\nerr:\r\nvhost_discard_vq_desc(vq, headcount);\r\nreturn r;\r\n}\r\nstatic void handle_rx(struct vhost_net *net)\r\n{\r\nstruct vhost_virtqueue *vq = &net->dev.vqs[VHOST_NET_VQ_RX];\r\nunsigned uninitialized_var(in), log;\r\nstruct vhost_log *vq_log;\r\nstruct msghdr msg = {\r\n.msg_name = NULL,\r\n.msg_namelen = 0,\r\n.msg_control = NULL,\r\n.msg_controllen = 0,\r\n.msg_iov = vq->iov,\r\n.msg_flags = MSG_DONTWAIT,\r\n};\r\nstruct virtio_net_hdr_mrg_rxbuf hdr = {\r\n.hdr.flags = 0,\r\n.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE\r\n};\r\nsize_t total_len = 0;\r\nint err, headcount, mergeable;\r\nsize_t vhost_hlen, sock_hlen;\r\nsize_t vhost_len, sock_len;\r\nstruct socket *sock = rcu_dereference_check(vq->private_data, 1);\r\nif (!sock)\r\nreturn;\r\nmutex_lock(&vq->mutex);\r\nvhost_disable_notify(&net->dev, vq);\r\nvhost_hlen = vq->vhost_hlen;\r\nsock_hlen = vq->sock_hlen;\r\nvq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?\r\nvq->log : NULL;\r\nmergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);\r\nwhile ((sock_len = peek_head_len(sock->sk))) {\r\nsock_len += sock_hlen;\r\nvhost_len = sock_len + vhost_hlen;\r\nheadcount = get_rx_bufs(vq, vq->heads, vhost_len,\r\n&in, vq_log, &log,\r\nlikely(mergeable) ? UIO_MAXIOV : 1);\r\nif (unlikely(headcount < 0))\r\nbreak;\r\nif (!headcount) {\r\nif (unlikely(vhost_enable_notify(&net->dev, vq))) {\r\nvhost_disable_notify(&net->dev, vq);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (unlikely((vhost_hlen)))\r\nmove_iovec_hdr(vq->iov, vq->hdr, vhost_hlen, in);\r\nelse\r\ncopy_iovec_hdr(vq->iov, vq->hdr, sock_hlen, in);\r\nmsg.msg_iovlen = in;\r\nerr = sock->ops->recvmsg(NULL, sock, &msg,\r\nsock_len, MSG_DONTWAIT | MSG_TRUNC);\r\nif (unlikely(err != sock_len)) {\r\npr_debug("Discarded rx packet: "\r\n" len %d, expected %zd\n", err, sock_len);\r\nvhost_discard_vq_desc(vq, headcount);\r\ncontinue;\r\n}\r\nif (unlikely(vhost_hlen) &&\r\nmemcpy_toiovecend(vq->hdr, (unsigned char *)&hdr, 0,\r\nvhost_hlen)) {\r\nvq_err(vq, "Unable to write vnet_hdr at addr %p\n",\r\nvq->iov->iov_base);\r\nbreak;\r\n}\r\nif (likely(mergeable) &&\r\nmemcpy_toiovecend(vq->hdr, (unsigned char *)&headcount,\r\noffsetof(typeof(hdr), num_buffers),\r\nsizeof hdr.num_buffers)) {\r\nvq_err(vq, "Failed num_buffers write");\r\nvhost_discard_vq_desc(vq, headcount);\r\nbreak;\r\n}\r\nvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\r\nheadcount);\r\nif (unlikely(vq_log))\r\nvhost_log_write(vq, vq_log, log, vhost_len);\r\ntotal_len += vhost_len;\r\nif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\r\nvhost_poll_queue(&vq->poll);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vq->mutex);\r\n}\r\nstatic void handle_tx_kick(struct vhost_work *work)\r\n{\r\nstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\r\npoll.work);\r\nstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\r\nhandle_tx(net);\r\n}\r\nstatic void handle_rx_kick(struct vhost_work *work)\r\n{\r\nstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\r\npoll.work);\r\nstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\r\nhandle_rx(net);\r\n}\r\nstatic void handle_tx_net(struct vhost_work *work)\r\n{\r\nstruct vhost_net *net = container_of(work, struct vhost_net,\r\npoll[VHOST_NET_VQ_TX].work);\r\nhandle_tx(net);\r\n}\r\nstatic void handle_rx_net(struct vhost_work *work)\r\n{\r\nstruct vhost_net *net = container_of(work, struct vhost_net,\r\npoll[VHOST_NET_VQ_RX].work);\r\nhandle_rx(net);\r\n}\r\nstatic int vhost_net_open(struct inode *inode, struct file *f)\r\n{\r\nstruct vhost_net *n = kmalloc(sizeof *n, GFP_KERNEL);\r\nstruct vhost_dev *dev;\r\nint r;\r\nif (!n)\r\nreturn -ENOMEM;\r\ndev = &n->dev;\r\nn->vqs[VHOST_NET_VQ_TX].handle_kick = handle_tx_kick;\r\nn->vqs[VHOST_NET_VQ_RX].handle_kick = handle_rx_kick;\r\nr = vhost_dev_init(dev, n->vqs, VHOST_NET_VQ_MAX);\r\nif (r < 0) {\r\nkfree(n);\r\nreturn r;\r\n}\r\nvhost_poll_init(n->poll + VHOST_NET_VQ_TX, handle_tx_net, POLLOUT, dev);\r\nvhost_poll_init(n->poll + VHOST_NET_VQ_RX, handle_rx_net, POLLIN, dev);\r\nn->tx_poll_state = VHOST_NET_POLL_DISABLED;\r\nf->private_data = n;\r\nreturn 0;\r\n}\r\nstatic void vhost_net_disable_vq(struct vhost_net *n,\r\nstruct vhost_virtqueue *vq)\r\n{\r\nif (!vq->private_data)\r\nreturn;\r\nif (vq == n->vqs + VHOST_NET_VQ_TX) {\r\ntx_poll_stop(n);\r\nn->tx_poll_state = VHOST_NET_POLL_DISABLED;\r\n} else\r\nvhost_poll_stop(n->poll + VHOST_NET_VQ_RX);\r\n}\r\nstatic void vhost_net_enable_vq(struct vhost_net *n,\r\nstruct vhost_virtqueue *vq)\r\n{\r\nstruct socket *sock;\r\nsock = rcu_dereference_protected(vq->private_data,\r\nlockdep_is_held(&vq->mutex));\r\nif (!sock)\r\nreturn;\r\nif (vq == n->vqs + VHOST_NET_VQ_TX) {\r\nn->tx_poll_state = VHOST_NET_POLL_STOPPED;\r\ntx_poll_start(n, sock);\r\n} else\r\nvhost_poll_start(n->poll + VHOST_NET_VQ_RX, sock->file);\r\n}\r\nstatic struct socket *vhost_net_stop_vq(struct vhost_net *n,\r\nstruct vhost_virtqueue *vq)\r\n{\r\nstruct socket *sock;\r\nmutex_lock(&vq->mutex);\r\nsock = rcu_dereference_protected(vq->private_data,\r\nlockdep_is_held(&vq->mutex));\r\nvhost_net_disable_vq(n, vq);\r\nrcu_assign_pointer(vq->private_data, NULL);\r\nmutex_unlock(&vq->mutex);\r\nreturn sock;\r\n}\r\nstatic void vhost_net_stop(struct vhost_net *n, struct socket **tx_sock,\r\nstruct socket **rx_sock)\r\n{\r\n*tx_sock = vhost_net_stop_vq(n, n->vqs + VHOST_NET_VQ_TX);\r\n*rx_sock = vhost_net_stop_vq(n, n->vqs + VHOST_NET_VQ_RX);\r\n}\r\nstatic void vhost_net_flush_vq(struct vhost_net *n, int index)\r\n{\r\nvhost_poll_flush(n->poll + index);\r\nvhost_poll_flush(&n->dev.vqs[index].poll);\r\n}\r\nstatic void vhost_net_flush(struct vhost_net *n)\r\n{\r\nvhost_net_flush_vq(n, VHOST_NET_VQ_TX);\r\nvhost_net_flush_vq(n, VHOST_NET_VQ_RX);\r\n}\r\nstatic int vhost_net_release(struct inode *inode, struct file *f)\r\n{\r\nstruct vhost_net *n = f->private_data;\r\nstruct socket *tx_sock;\r\nstruct socket *rx_sock;\r\nvhost_net_stop(n, &tx_sock, &rx_sock);\r\nvhost_net_flush(n);\r\nvhost_dev_cleanup(&n->dev);\r\nif (tx_sock)\r\nfput(tx_sock->file);\r\nif (rx_sock)\r\nfput(rx_sock->file);\r\nvhost_net_flush(n);\r\nkfree(n);\r\nreturn 0;\r\n}\r\nstatic struct socket *get_raw_socket(int fd)\r\n{\r\nstruct {\r\nstruct sockaddr_ll sa;\r\nchar buf[MAX_ADDR_LEN];\r\n} uaddr;\r\nint uaddr_len = sizeof uaddr, r;\r\nstruct socket *sock = sockfd_lookup(fd, &r);\r\nif (!sock)\r\nreturn ERR_PTR(-ENOTSOCK);\r\nif (sock->sk->sk_type != SOCK_RAW) {\r\nr = -ESOCKTNOSUPPORT;\r\ngoto err;\r\n}\r\nr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa,\r\n&uaddr_len, 0);\r\nif (r)\r\ngoto err;\r\nif (uaddr.sa.sll_family != AF_PACKET) {\r\nr = -EPFNOSUPPORT;\r\ngoto err;\r\n}\r\nreturn sock;\r\nerr:\r\nfput(sock->file);\r\nreturn ERR_PTR(r);\r\n}\r\nstatic struct socket *get_tap_socket(int fd)\r\n{\r\nstruct file *file = fget(fd);\r\nstruct socket *sock;\r\nif (!file)\r\nreturn ERR_PTR(-EBADF);\r\nsock = tun_get_socket(file);\r\nif (!IS_ERR(sock))\r\nreturn sock;\r\nsock = macvtap_get_socket(file);\r\nif (IS_ERR(sock))\r\nfput(file);\r\nreturn sock;\r\n}\r\nstatic struct socket *get_socket(int fd)\r\n{\r\nstruct socket *sock;\r\nif (fd == -1)\r\nreturn NULL;\r\nsock = get_raw_socket(fd);\r\nif (!IS_ERR(sock))\r\nreturn sock;\r\nsock = get_tap_socket(fd);\r\nif (!IS_ERR(sock))\r\nreturn sock;\r\nreturn ERR_PTR(-ENOTSOCK);\r\n}\r\nstatic long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\r\n{\r\nstruct socket *sock, *oldsock;\r\nstruct vhost_virtqueue *vq;\r\nstruct vhost_ubuf_ref *ubufs, *oldubufs = NULL;\r\nint r;\r\nmutex_lock(&n->dev.mutex);\r\nr = vhost_dev_check_owner(&n->dev);\r\nif (r)\r\ngoto err;\r\nif (index >= VHOST_NET_VQ_MAX) {\r\nr = -ENOBUFS;\r\ngoto err;\r\n}\r\nvq = n->vqs + index;\r\nmutex_lock(&vq->mutex);\r\nif (!vhost_vq_access_ok(vq)) {\r\nr = -EFAULT;\r\ngoto err_vq;\r\n}\r\nsock = get_socket(fd);\r\nif (IS_ERR(sock)) {\r\nr = PTR_ERR(sock);\r\ngoto err_vq;\r\n}\r\noldsock = rcu_dereference_protected(vq->private_data,\r\nlockdep_is_held(&vq->mutex));\r\nif (sock != oldsock) {\r\nubufs = vhost_ubuf_alloc(vq, sock && vhost_sock_zcopy(sock));\r\nif (IS_ERR(ubufs)) {\r\nr = PTR_ERR(ubufs);\r\ngoto err_ubufs;\r\n}\r\noldubufs = vq->ubufs;\r\nvq->ubufs = ubufs;\r\nvhost_net_disable_vq(n, vq);\r\nrcu_assign_pointer(vq->private_data, sock);\r\nvhost_net_enable_vq(n, vq);\r\nr = vhost_init_used(vq);\r\nif (r)\r\ngoto err_vq;\r\n}\r\nmutex_unlock(&vq->mutex);\r\nif (oldubufs) {\r\nvhost_ubuf_put_and_wait(oldubufs);\r\nmutex_lock(&vq->mutex);\r\nvhost_zerocopy_signal_used(vq);\r\nmutex_unlock(&vq->mutex);\r\n}\r\nif (oldsock) {\r\nvhost_net_flush_vq(n, index);\r\nfput(oldsock->file);\r\n}\r\nmutex_unlock(&n->dev.mutex);\r\nreturn 0;\r\nerr_ubufs:\r\nfput(sock->file);\r\nerr_vq:\r\nmutex_unlock(&vq->mutex);\r\nerr:\r\nmutex_unlock(&n->dev.mutex);\r\nreturn r;\r\n}\r\nstatic long vhost_net_reset_owner(struct vhost_net *n)\r\n{\r\nstruct socket *tx_sock = NULL;\r\nstruct socket *rx_sock = NULL;\r\nlong err;\r\nmutex_lock(&n->dev.mutex);\r\nerr = vhost_dev_check_owner(&n->dev);\r\nif (err)\r\ngoto done;\r\nvhost_net_stop(n, &tx_sock, &rx_sock);\r\nvhost_net_flush(n);\r\nerr = vhost_dev_reset_owner(&n->dev);\r\ndone:\r\nmutex_unlock(&n->dev.mutex);\r\nif (tx_sock)\r\nfput(tx_sock->file);\r\nif (rx_sock)\r\nfput(rx_sock->file);\r\nreturn err;\r\n}\r\nstatic int vhost_net_set_features(struct vhost_net *n, u64 features)\r\n{\r\nsize_t vhost_hlen, sock_hlen, hdr_len;\r\nint i;\r\nhdr_len = (features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ?\r\nsizeof(struct virtio_net_hdr_mrg_rxbuf) :\r\nsizeof(struct virtio_net_hdr);\r\nif (features & (1 << VHOST_NET_F_VIRTIO_NET_HDR)) {\r\nvhost_hlen = hdr_len;\r\nsock_hlen = 0;\r\n} else {\r\nvhost_hlen = 0;\r\nsock_hlen = hdr_len;\r\n}\r\nmutex_lock(&n->dev.mutex);\r\nif ((features & (1 << VHOST_F_LOG_ALL)) &&\r\n!vhost_log_access_ok(&n->dev)) {\r\nmutex_unlock(&n->dev.mutex);\r\nreturn -EFAULT;\r\n}\r\nn->dev.acked_features = features;\r\nsmp_wmb();\r\nfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\r\nmutex_lock(&n->vqs[i].mutex);\r\nn->vqs[i].vhost_hlen = vhost_hlen;\r\nn->vqs[i].sock_hlen = sock_hlen;\r\nmutex_unlock(&n->vqs[i].mutex);\r\n}\r\nvhost_net_flush(n);\r\nmutex_unlock(&n->dev.mutex);\r\nreturn 0;\r\n}\r\nstatic long vhost_net_ioctl(struct file *f, unsigned int ioctl,\r\nunsigned long arg)\r\n{\r\nstruct vhost_net *n = f->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nu64 __user *featurep = argp;\r\nstruct vhost_vring_file backend;\r\nu64 features;\r\nint r;\r\nswitch (ioctl) {\r\ncase VHOST_NET_SET_BACKEND:\r\nif (copy_from_user(&backend, argp, sizeof backend))\r\nreturn -EFAULT;\r\nreturn vhost_net_set_backend(n, backend.index, backend.fd);\r\ncase VHOST_GET_FEATURES:\r\nfeatures = VHOST_FEATURES;\r\nif (copy_to_user(featurep, &features, sizeof features))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase VHOST_SET_FEATURES:\r\nif (copy_from_user(&features, featurep, sizeof features))\r\nreturn -EFAULT;\r\nif (features & ~VHOST_FEATURES)\r\nreturn -EOPNOTSUPP;\r\nreturn vhost_net_set_features(n, features);\r\ncase VHOST_RESET_OWNER:\r\nreturn vhost_net_reset_owner(n);\r\ndefault:\r\nmutex_lock(&n->dev.mutex);\r\nr = vhost_dev_ioctl(&n->dev, ioctl, arg);\r\nvhost_net_flush(n);\r\nmutex_unlock(&n->dev.mutex);\r\nreturn r;\r\n}\r\n}\r\nstatic long vhost_net_compat_ioctl(struct file *f, unsigned int ioctl,\r\nunsigned long arg)\r\n{\r\nreturn vhost_net_ioctl(f, ioctl, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int vhost_net_init(void)\r\n{\r\nif (experimental_zcopytx)\r\nvhost_enable_zcopy(VHOST_NET_VQ_TX);\r\nreturn misc_register(&vhost_net_misc);\r\n}\r\nstatic void vhost_net_exit(void)\r\n{\r\nmisc_deregister(&vhost_net_misc);\r\n}
