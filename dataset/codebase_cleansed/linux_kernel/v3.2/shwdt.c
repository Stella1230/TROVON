static void sh_wdt_start(struct sh_wdt *wdt)\r\n{\r\nunsigned long flags;\r\nu8 csr;\r\nspin_lock_irqsave(&shwdt_lock, flags);\r\nnext_heartbeat = jiffies + (heartbeat * HZ);\r\nmod_timer(&wdt->timer, next_ping_period(clock_division_ratio));\r\ncsr = sh_wdt_read_csr();\r\ncsr |= WTCSR_WT | clock_division_ratio;\r\nsh_wdt_write_csr(csr);\r\nsh_wdt_write_cnt(0);\r\ncsr = sh_wdt_read_csr();\r\ncsr |= WTCSR_TME;\r\ncsr &= ~WTCSR_RSTS;\r\nsh_wdt_write_csr(csr);\r\n#ifdef CONFIG_CPU_SH2\r\ncsr = sh_wdt_read_rstcsr();\r\ncsr &= ~RSTCSR_RSTS;\r\nsh_wdt_write_rstcsr(csr);\r\n#endif\r\nspin_unlock_irqrestore(&shwdt_lock, flags);\r\n}\r\nstatic void sh_wdt_stop(struct sh_wdt *wdt)\r\n{\r\nunsigned long flags;\r\nu8 csr;\r\nspin_lock_irqsave(&shwdt_lock, flags);\r\ndel_timer(&wdt->timer);\r\ncsr = sh_wdt_read_csr();\r\ncsr &= ~WTCSR_TME;\r\nsh_wdt_write_csr(csr);\r\nspin_unlock_irqrestore(&shwdt_lock, flags);\r\n}\r\nstatic inline void sh_wdt_keepalive(struct sh_wdt *wdt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&shwdt_lock, flags);\r\nnext_heartbeat = jiffies + (heartbeat * HZ);\r\nspin_unlock_irqrestore(&shwdt_lock, flags);\r\n}\r\nstatic int sh_wdt_set_heartbeat(int t)\r\n{\r\nunsigned long flags;\r\nif (unlikely(t < 1 || t > 3600))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&shwdt_lock, flags);\r\nheartbeat = t;\r\nspin_unlock_irqrestore(&shwdt_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sh_wdt_ping(unsigned long data)\r\n{\r\nstruct sh_wdt *wdt = (struct sh_wdt *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&shwdt_lock, flags);\r\nif (time_before(jiffies, next_heartbeat)) {\r\nu8 csr;\r\ncsr = sh_wdt_read_csr();\r\ncsr &= ~WTCSR_IOVF;\r\nsh_wdt_write_csr(csr);\r\nsh_wdt_write_cnt(0);\r\nmod_timer(&wdt->timer, next_ping_period(clock_division_ratio));\r\n} else\r\ndev_warn(wdt->dev, "Heartbeat lost! Will not ping "\r\n"the watchdog\n");\r\nspin_unlock_irqrestore(&shwdt_lock, flags);\r\n}\r\nstatic int sh_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nstruct sh_wdt *wdt = platform_get_drvdata(sh_wdt_dev);\r\nif (test_and_set_bit(0, &wdt->enabled))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nfile->private_data = wdt;\r\nsh_wdt_start(wdt);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int sh_wdt_close(struct inode *inode, struct file *file)\r\n{\r\nstruct sh_wdt *wdt = file->private_data;\r\nif (wdt->expect_close == 42) {\r\nsh_wdt_stop(wdt);\r\n} else {\r\ndev_crit(wdt->dev, "Unexpected close, not "\r\n"stopping watchdog!\n");\r\nsh_wdt_keepalive(wdt);\r\n}\r\nclear_bit(0, &wdt->enabled);\r\nwdt->expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t sh_wdt_write(struct file *file, const char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct sh_wdt *wdt = file->private_data;\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nwdt->expect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nwdt->expect_close = 42;\r\n}\r\n}\r\nsh_wdt_keepalive(wdt);\r\n}\r\nreturn count;\r\n}\r\nstatic long sh_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sh_wdt *wdt = file->private_data;\r\nint new_heartbeat;\r\nint options, retval = -EINVAL;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user((struct watchdog_info *)arg,\r\n&sh_wdt_info, sizeof(sh_wdt_info)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, (int *)arg);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(options, (int *)arg))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nsh_wdt_stop(wdt);\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nsh_wdt_start(wdt);\r\nretval = 0;\r\n}\r\nreturn retval;\r\ncase WDIOC_KEEPALIVE:\r\nsh_wdt_keepalive(wdt);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_heartbeat, (int *)arg))\r\nreturn -EFAULT;\r\nif (sh_wdt_set_heartbeat(new_heartbeat))\r\nreturn -EINVAL;\r\nsh_wdt_keepalive(wdt);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, (int *)arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_wdt_notify_sys(struct notifier_block *this,\r\nunsigned long code, void *unused)\r\n{\r\nstruct sh_wdt *wdt = platform_get_drvdata(sh_wdt_dev);\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nsh_wdt_stop(wdt);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __devinit sh_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_wdt *wdt;\r\nstruct resource *res;\r\nint rc;\r\nif (pdev->id != -1)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!res))\r\nreturn -EINVAL;\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), DRV_NAME))\r\nreturn -EBUSY;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(struct sh_wdt), GFP_KERNEL);\r\nif (unlikely(!wdt)) {\r\nrc = -ENOMEM;\r\ngoto out_release;\r\n}\r\nwdt->dev = &pdev->dev;\r\nwdt->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (unlikely(!wdt->base)) {\r\nrc = -ENXIO;\r\ngoto out_err;\r\n}\r\nrc = register_reboot_notifier(&sh_wdt_notifier);\r\nif (unlikely(rc)) {\r\ndev_err(&pdev->dev,\r\n"Can't register reboot notifier (err=%d)\n", rc);\r\ngoto out_unmap;\r\n}\r\nsh_wdt_miscdev.parent = wdt->dev;\r\nrc = misc_register(&sh_wdt_miscdev);\r\nif (unlikely(rc)) {\r\ndev_err(&pdev->dev,\r\n"Can't register miscdev on minor=%d (err=%d)\n",\r\nsh_wdt_miscdev.minor, rc);\r\ngoto out_unreg;\r\n}\r\ninit_timer(&wdt->timer);\r\nwdt->timer.function = sh_wdt_ping;\r\nwdt->timer.data = (unsigned long)wdt;\r\nwdt->timer.expires = next_ping_period(clock_division_ratio);\r\nplatform_set_drvdata(pdev, wdt);\r\nsh_wdt_dev = pdev;\r\ndev_info(&pdev->dev, "initialized.\n");\r\nreturn 0;\r\nout_unreg:\r\nunregister_reboot_notifier(&sh_wdt_notifier);\r\nout_unmap:\r\ndevm_iounmap(&pdev->dev, wdt->base);\r\nout_err:\r\ndevm_kfree(&pdev->dev, wdt);\r\nout_release:\r\ndevm_release_mem_region(&pdev->dev, res->start, resource_size(res));\r\nreturn rc;\r\n}\r\nstatic int __devexit sh_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_wdt *wdt = platform_get_drvdata(pdev);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\nmisc_deregister(&sh_wdt_miscdev);\r\nsh_wdt_dev = NULL;\r\nunregister_reboot_notifier(&sh_wdt_notifier);\r\ndevm_release_mem_region(&pdev->dev, res->start, resource_size(res));\r\ndevm_iounmap(&pdev->dev, wdt->base);\r\ndevm_kfree(&pdev->dev, wdt);\r\nreturn 0;\r\n}\r\nstatic int __init sh_wdt_init(void)\r\n{\r\nint rc;\r\nif (unlikely(clock_division_ratio < 0x5 ||\r\nclock_division_ratio > 0x7)) {\r\nclock_division_ratio = WTCSR_CKS_4096;\r\npr_info("%s: divisor must be 0x5<=x<=0x7, using %d\n",\r\nDRV_NAME, clock_division_ratio);\r\n}\r\nrc = sh_wdt_set_heartbeat(heartbeat);\r\nif (unlikely(rc)) {\r\nheartbeat = WATCHDOG_HEARTBEAT;\r\npr_info("%s: heartbeat value must be 1<=x<=3600, using %d\n",\r\nDRV_NAME, heartbeat);\r\n}\r\npr_info("%s: configured with heartbeat=%d sec (nowayout=%d)\n",\r\nDRV_NAME, heartbeat, nowayout);\r\nreturn platform_driver_register(&sh_wdt_driver);\r\n}\r\nstatic void __exit sh_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_wdt_driver);\r\n}
