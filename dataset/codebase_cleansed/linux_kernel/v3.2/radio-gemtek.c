static void gemtek_bu2614_transmit(struct gemtek *gt)\r\n{\r\nint i, bit, q, mute;\r\nmutex_lock(&gt->lock);\r\nmute = gt->muted ? GEMTEK_MT : 0x00;\r\noutb_p(mute | GEMTEK_DA | GEMTEK_CK, gt->io);\r\nudelay(SHORT_DELAY);\r\noutb_p(mute | GEMTEK_CE | GEMTEK_DA | GEMTEK_CK, gt->io);\r\nudelay(LONG_DELAY);\r\nfor (i = 0, q = gt->bu2614data; i < 32; i++, q >>= 1) {\r\nbit = (q & 1) ? GEMTEK_DA : 0;\r\noutb_p(mute | GEMTEK_CE | bit, gt->io);\r\nudelay(SHORT_DELAY);\r\noutb_p(mute | GEMTEK_CE | bit | GEMTEK_CK, gt->io);\r\nudelay(SHORT_DELAY);\r\n}\r\noutb_p(mute | GEMTEK_DA | GEMTEK_CK, gt->io);\r\nudelay(SHORT_DELAY);\r\noutb_p(mute | GEMTEK_CE | GEMTEK_DA | GEMTEK_CK, gt->io);\r\nudelay(LONG_DELAY);\r\nmutex_unlock(&gt->lock);\r\n}\r\nstatic unsigned long gemtek_convfreq(unsigned long freq)\r\n{\r\nreturn ((freq<<FSCALE) + IF_OFFSET + REF_FREQ/2) / REF_FREQ;\r\n}\r\nstatic void gemtek_setfreq(struct gemtek *gt, unsigned long freq)\r\n{\r\nif (keepmuted && hardmute && gt->muted)\r\nreturn;\r\nfreq = clamp_val(freq, GEMTEK_LOWFREQ, GEMTEK_HIGHFREQ);\r\ngt->lastfreq = freq;\r\ngt->muted = 0;\r\ngemtek_bu2614_set(gt, BU2614_PORT, 0);\r\ngemtek_bu2614_set(gt, BU2614_FMES, 0);\r\ngemtek_bu2614_set(gt, BU2614_SWIN, 0);\r\ngemtek_bu2614_set(gt, BU2614_SWAL, 0);\r\ngemtek_bu2614_set(gt, BU2614_FMUN, 1);\r\ngemtek_bu2614_set(gt, BU2614_TEST, 0);\r\ngemtek_bu2614_set(gt, BU2614_STDF, GEMTEK_STDF_3_125_KHZ);\r\ngemtek_bu2614_set(gt, BU2614_FREQ, gemtek_convfreq(freq));\r\ngemtek_bu2614_transmit(gt);\r\n}\r\nstatic void gemtek_mute(struct gemtek *gt)\r\n{\r\nint i;\r\ngt->muted = 1;\r\nif (hardmute) {\r\ngemtek_bu2614_set(gt, BU2614_PORT, 0);\r\ngemtek_bu2614_set(gt, BU2614_FMES, 0);\r\ngemtek_bu2614_set(gt, BU2614_SWIN, 0);\r\ngemtek_bu2614_set(gt, BU2614_SWAL, 0);\r\ngemtek_bu2614_set(gt, BU2614_FMUN, 0);\r\ngemtek_bu2614_set(gt, BU2614_TEST, 0);\r\ngemtek_bu2614_set(gt, BU2614_STDF, GEMTEK_PLL_OFF);\r\ngemtek_bu2614_set(gt, BU2614_FREQ, 0);\r\ngemtek_bu2614_transmit(gt);\r\nreturn;\r\n}\r\nmutex_lock(&gt->lock);\r\ni = inb_p(gt->io);\r\noutb_p((i >> 5) | GEMTEK_MT, gt->io);\r\nudelay(SHORT_DELAY);\r\nmutex_unlock(&gt->lock);\r\n}\r\nstatic void gemtek_unmute(struct gemtek *gt)\r\n{\r\nint i;\r\ngt->muted = 0;\r\nif (hardmute) {\r\ngemtek_setfreq(gt, gt->lastfreq);\r\nreturn;\r\n}\r\nmutex_lock(&gt->lock);\r\ni = inb_p(gt->io);\r\noutb_p(i >> 5, gt->io);\r\nudelay(SHORT_DELAY);\r\nmutex_unlock(&gt->lock);\r\n}\r\nstatic inline int gemtek_getsigstr(struct gemtek *gt)\r\n{\r\nint sig;\r\nmutex_lock(&gt->lock);\r\nsig = inb_p(gt->io) & GEMTEK_NS ? 0 : 1;\r\nmutex_unlock(&gt->lock);\r\nreturn sig;\r\n}\r\nstatic int gemtek_verify(struct gemtek *gt, int port)\r\n{\r\nint i, q;\r\nif (gt->verified == port)\r\nreturn 1;\r\nmutex_lock(&gt->lock);\r\nq = inb_p(port);\r\nfor (i = 0; i < 3; ++i) {\r\noutb_p(1 << i, port);\r\nudelay(SHORT_DELAY);\r\nif ((inb_p(port) & (~GEMTEK_NS)) != (0x17 | (1 << (i + 5)))) {\r\nmutex_unlock(&gt->lock);\r\nreturn 0;\r\n}\r\n}\r\noutb_p(q >> 5, port);\r\nudelay(SHORT_DELAY);\r\nmutex_unlock(&gt->lock);\r\ngt->verified = port;\r\nreturn 1;\r\n}\r\nstatic int gemtek_probe(struct gemtek *gt)\r\n{\r\nstruct v4l2_device *v4l2_dev = &gt->v4l2_dev;\r\nint ioports[] = { 0x20c, 0x30c, 0x24c, 0x34c, 0x248, 0x28c };\r\nint i;\r\nif (!probe) {\r\nv4l2_info(v4l2_dev, "Automatic device probing disabled.\n");\r\nreturn -1;\r\n}\r\nv4l2_info(v4l2_dev, "Automatic device probing enabled.\n");\r\nfor (i = 0; i < ARRAY_SIZE(ioports); ++i) {\r\nv4l2_info(v4l2_dev, "Trying I/O port 0x%x...\n", ioports[i]);\r\nif (!request_region(ioports[i], 1, "gemtek-probe")) {\r\nv4l2_warn(v4l2_dev, "I/O port 0x%x busy!\n",\r\nioports[i]);\r\ncontinue;\r\n}\r\nif (gemtek_verify(gt, ioports[i])) {\r\nv4l2_info(v4l2_dev, "Card found from I/O port "\r\n"0x%x!\n", ioports[i]);\r\nrelease_region(ioports[i], 1);\r\ngt->io = ioports[i];\r\nreturn gt->io;\r\n}\r\nrelease_region(ioports[i], 1);\r\n}\r\nv4l2_err(v4l2_dev, "Automatic probing failed!\n");\r\nreturn -1;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "radio-gemtek", sizeof(v->driver));\r\nstrlcpy(v->card, "GemTek", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\r\n{\r\nstruct gemtek *gt = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = GEMTEK_LOWFREQ;\r\nv->rangehigh = GEMTEK_HIGHFREQ;\r\nv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO;\r\nv->signal = 0xffff * gemtek_getsigstr(gt);\r\nif (v->signal) {\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nv->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\n} else {\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\r\n{\r\nreturn (v->index != 0) ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct gemtek *gt = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = gt->lastfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct gemtek *gt = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\ngemtek_setfreq(gt, f->frequency);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct gemtek *gt = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = gt->muted;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct gemtek *gt = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value)\r\ngemtek_mute(gt);\r\nelse\r\ngemtek_unmute(gt);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn (i != 0) ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nreturn (a->index != 0) ? -EINVAL : 0;\r\n}\r\nstatic int __init gemtek_init(void)\r\n{\r\nstruct gemtek *gt = &gemtek_card;\r\nstruct v4l2_device *v4l2_dev = &gt->v4l2_dev;\r\nint res;\r\nstrlcpy(v4l2_dev->name, "gemtek", sizeof(v4l2_dev->name));\r\nv4l2_info(v4l2_dev, "GemTek Radio card driver: v0.0.3\n");\r\nmutex_init(&gt->lock);\r\ngt->verified = -1;\r\ngt->io = io;\r\ngemtek_probe(gt);\r\nif (gt->io) {\r\nif (!request_region(gt->io, 1, "gemtek")) {\r\nv4l2_err(v4l2_dev, "I/O port 0x%x already in use.\n", gt->io);\r\nreturn -EBUSY;\r\n}\r\nif (!gemtek_verify(gt, gt->io))\r\nv4l2_warn(v4l2_dev, "Card at I/O port 0x%x does not "\r\n"respond properly, check your "\r\n"configuration.\n", gt->io);\r\nelse\r\nv4l2_info(v4l2_dev, "Using I/O port 0x%x.\n", gt->io);\r\n} else if (probe) {\r\nv4l2_err(v4l2_dev, "Automatic probing failed and no "\r\n"fixed I/O port defined.\n");\r\nreturn -ENODEV;\r\n} else {\r\nv4l2_err(v4l2_dev, "Automatic probing disabled but no fixed "\r\n"I/O port defined.");\r\nreturn -EINVAL;\r\n}\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nrelease_region(gt->io, 1);\r\nreturn res;\r\n}\r\nstrlcpy(gt->vdev.name, v4l2_dev->name, sizeof(gt->vdev.name));\r\ngt->vdev.v4l2_dev = v4l2_dev;\r\ngt->vdev.fops = &gemtek_fops;\r\ngt->vdev.ioctl_ops = &gemtek_ioctl_ops;\r\ngt->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&gt->vdev, gt);\r\ngt->lastfreq = GEMTEK_LOWFREQ;\r\ngt->bu2614data = 0;\r\nif (initmute)\r\ngemtek_mute(gt);\r\nif (video_register_device(&gt->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_device_unregister(v4l2_dev);\r\nrelease_region(gt->io, 1);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit gemtek_exit(void)\r\n{\r\nstruct gemtek *gt = &gemtek_card;\r\nstruct v4l2_device *v4l2_dev = &gt->v4l2_dev;\r\nif (shutdown) {\r\nhardmute = 1;\r\ngemtek_mute(gt);\r\n} else {\r\nv4l2_info(v4l2_dev, "Module unloaded but card not muted!\n");\r\n}\r\nvideo_unregister_device(&gt->vdev);\r\nv4l2_device_unregister(&gt->v4l2_dev);\r\nrelease_region(gt->io, 1);\r\n}
