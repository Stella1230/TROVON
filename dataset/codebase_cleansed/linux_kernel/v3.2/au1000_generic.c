static int\r\nau1x00_pcmcia_skt_state(struct au1000_pcmcia_socket *skt)\r\n{\r\nstruct pcmcia_state state;\r\nunsigned int stat;\r\nmemset(&state, 0, sizeof(struct pcmcia_state));\r\nskt->ops->socket_state(skt, &state);\r\nstat = state.detect ? SS_DETECT : 0;\r\nstat |= state.ready ? SS_READY : 0;\r\nstat |= state.wrprot ? SS_WRPROT : 0;\r\nstat |= state.vs_3v ? SS_3VCARD : 0;\r\nstat |= state.vs_Xv ? SS_XVCARD : 0;\r\nstat |= skt->cs_state.Vcc ? SS_POWERON : 0;\r\nif (skt->cs_state.flags & SS_IOCARD)\r\nstat |= state.bvd1 ? SS_STSCHG : 0;\r\nelse {\r\nif (state.bvd1 == 0)\r\nstat |= SS_BATDEAD;\r\nelse if (state.bvd2 == 0)\r\nstat |= SS_BATWARN;\r\n}\r\nreturn stat;\r\n}\r\nstatic int\r\nau1x00_pcmcia_config_skt(struct au1000_pcmcia_socket *skt, socket_state_t *state)\r\n{\r\nint ret;\r\nret = skt->ops->configure_socket(skt, state);\r\nif (ret == 0) {\r\nskt->cs_state = *state;\r\n}\r\nif (ret < 0)\r\ndebug("unable to configure socket %d\n", skt->nr);\r\nreturn ret;\r\n}\r\nstatic int au1x00_pcmcia_sock_init(struct pcmcia_socket *sock)\r\n{\r\nstruct au1000_pcmcia_socket *skt = to_au1000_socket(sock);\r\ndebug("initializing socket %u\n", skt->nr);\r\nskt->ops->socket_init(skt);\r\nreturn 0;\r\n}\r\nstatic int au1x00_pcmcia_suspend(struct pcmcia_socket *sock)\r\n{\r\nstruct au1000_pcmcia_socket *skt = to_au1000_socket(sock);\r\ndebug("suspending socket %u\n", skt->nr);\r\nskt->ops->socket_suspend(skt);\r\nreturn 0;\r\n}\r\nstatic void au1x00_check_status(struct au1000_pcmcia_socket *skt)\r\n{\r\nunsigned int events;\r\ndebug("entering PCMCIA monitoring thread\n");\r\ndo {\r\nunsigned int status;\r\nunsigned long flags;\r\nstatus = au1x00_pcmcia_skt_state(skt);\r\nspin_lock_irqsave(&status_lock, flags);\r\nevents = (status ^ skt->status) & skt->cs_state.csc_mask;\r\nskt->status = status;\r\nspin_unlock_irqrestore(&status_lock, flags);\r\ndebug("events: %s%s%s%s%s%s\n",\r\nevents == 0 ? "<NONE>" : "",\r\nevents & SS_DETECT ? "DETECT " : "",\r\nevents & SS_READY ? "READY " : "",\r\nevents & SS_BATDEAD ? "BATDEAD " : "",\r\nevents & SS_BATWARN ? "BATWARN " : "",\r\nevents & SS_STSCHG ? "STSCHG " : "");\r\nif (events)\r\npcmcia_parse_events(&skt->socket, events);\r\n} while (events);\r\n}\r\nstatic void au1x00_pcmcia_poll_event(unsigned long dummy)\r\n{\r\nstruct au1000_pcmcia_socket *skt = (struct au1000_pcmcia_socket *)dummy;\r\ndebug("polling for events\n");\r\nmod_timer(&skt->poll_timer, jiffies + AU1000_PCMCIA_POLL_PERIOD);\r\nau1x00_check_status(skt);\r\n}\r\nstatic int\r\nau1x00_pcmcia_get_status(struct pcmcia_socket *sock, unsigned int *status)\r\n{\r\nstruct au1000_pcmcia_socket *skt = to_au1000_socket(sock);\r\nskt->status = au1x00_pcmcia_skt_state(skt);\r\n*status = skt->status;\r\nreturn 0;\r\n}\r\nstatic int\r\nau1x00_pcmcia_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\r\n{\r\nstruct au1000_pcmcia_socket *skt = to_au1000_socket(sock);\r\ndebug("for sock %u\n", skt->nr);\r\ndebug("\tmask: %s%s%s%s%s%s\n\tflags: %s%s%s%s%s%s\n",\r\n(state->csc_mask==0)?"<NONE>":"",\r\n(state->csc_mask&SS_DETECT)?"DETECT ":"",\r\n(state->csc_mask&SS_READY)?"READY ":"",\r\n(state->csc_mask&SS_BATDEAD)?"BATDEAD ":"",\r\n(state->csc_mask&SS_BATWARN)?"BATWARN ":"",\r\n(state->csc_mask&SS_STSCHG)?"STSCHG ":"",\r\n(state->flags==0)?"<NONE>":"",\r\n(state->flags&SS_PWR_AUTO)?"PWR_AUTO ":"",\r\n(state->flags&SS_IOCARD)?"IOCARD ":"",\r\n(state->flags&SS_RESET)?"RESET ":"",\r\n(state->flags&SS_SPKR_ENA)?"SPKR_ENA ":"",\r\n(state->flags&SS_OUTPUT_ENA)?"OUTPUT_ENA ":"");\r\ndebug("\tVcc %d Vpp %d irq %d\n",\r\nstate->Vcc, state->Vpp, state->io_irq);\r\nreturn au1x00_pcmcia_config_skt(skt, state);\r\n}\r\nint\r\nau1x00_pcmcia_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *map)\r\n{\r\nstruct au1000_pcmcia_socket *skt = to_au1000_socket(sock);\r\nunsigned int speed;\r\nif(map->map>=MAX_IO_WIN){\r\ndebug("map (%d) out of range\n", map->map);\r\nreturn -1;\r\n}\r\nif(map->flags&MAP_ACTIVE){\r\nspeed=(map->speed>0)?map->speed:AU1000_PCMCIA_IO_SPEED;\r\nskt->spd_io[map->map] = speed;\r\n}\r\nmap->start=(unsigned int)(u32)skt->virt_io;\r\nmap->stop=map->start+MAP_SIZE;\r\nreturn 0;\r\n}\r\nstatic int\r\nau1x00_pcmcia_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *map)\r\n{\r\nstruct au1000_pcmcia_socket *skt = to_au1000_socket(sock);\r\nunsigned short speed = map->speed;\r\nif(map->map>=MAX_WIN){\r\ndebug("map (%d) out of range\n", map->map);\r\nreturn -1;\r\n}\r\nif (map->flags & MAP_ATTRIB) {\r\nskt->spd_attr[map->map] = speed;\r\nskt->spd_mem[map->map] = 0;\r\n} else {\r\nskt->spd_attr[map->map] = 0;\r\nskt->spd_mem[map->map] = speed;\r\n}\r\nif (map->flags & MAP_ATTRIB) {\r\nmap->static_start = skt->phys_attr + map->card_start;\r\n}\r\nelse {\r\nmap->static_start = skt->phys_mem + map->card_start;\r\n}\r\ndebug("set_mem_map %d start %08lx card_start %08x\n",\r\nmap->map, map->static_start, map->card_start);\r\nreturn 0;\r\n}\r\nint au1x00_pcmcia_socket_probe(struct device *dev, struct pcmcia_low_level *ops, int first, int nr)\r\n{\r\nstruct skt_dev_info *sinfo;\r\nstruct au1000_pcmcia_socket *skt;\r\nint ret, i;\r\nsinfo = kzalloc(sizeof(struct skt_dev_info), GFP_KERNEL);\r\nif (!sinfo) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsinfo->nskt = nr;\r\nfor (i = 0; i < nr; i++) {\r\nskt = PCMCIA_SOCKET(i);\r\nmemset(skt, 0, sizeof(*skt));\r\nskt->socket.resource_ops = &pccard_static_ops;\r\nskt->socket.ops = &au1x00_pcmcia_operations;\r\nskt->socket.owner = ops->owner;\r\nskt->socket.dev.parent = dev;\r\ninit_timer(&skt->poll_timer);\r\nskt->poll_timer.function = au1x00_pcmcia_poll_event;\r\nskt->poll_timer.data = (unsigned long)skt;\r\nskt->poll_timer.expires = jiffies + AU1000_PCMCIA_POLL_PERIOD;\r\nskt->nr = first + i;\r\nskt->irq = 255;\r\nskt->dev = dev;\r\nskt->ops = ops;\r\nskt->res_skt.name = skt_names[skt->nr];\r\nskt->res_io.name = "io";\r\nskt->res_io.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nskt->res_mem.name = "memory";\r\nskt->res_mem.flags = IORESOURCE_MEM;\r\nskt->res_attr.name = "attribute";\r\nskt->res_attr.flags = IORESOURCE_MEM;\r\nif (i == 0) {\r\nskt->virt_io = (void *)\r\n(ioremap((phys_t)AU1X_SOCK0_IO, 0x1000) -\r\n(u32)mips_io_port_base);\r\nskt->phys_attr = AU1X_SOCK0_PHYS_ATTR;\r\nskt->phys_mem = AU1X_SOCK0_PHYS_MEM;\r\n}\r\nelse {\r\nskt->virt_io = (void *)\r\n(ioremap((phys_t)AU1X_SOCK1_IO, 0x1000) -\r\n(u32)mips_io_port_base);\r\nskt->phys_attr = AU1X_SOCK1_PHYS_ATTR;\r\nskt->phys_mem = AU1X_SOCK1_PHYS_MEM;\r\n}\r\npcmcia_base_vaddrs[i] = (u32 *)skt->virt_io;\r\nret = ops->hw_init(skt);\r\nskt->socket.features = SS_CAP_STATIC_MAP|SS_CAP_PCCARD;\r\nskt->socket.irq_mask = 0;\r\nskt->socket.map_size = MAP_SIZE;\r\nskt->socket.pci_irq = skt->irq;\r\nskt->socket.io_offset = (unsigned long)skt->virt_io;\r\nskt->status = au1x00_pcmcia_skt_state(skt);\r\nret = pcmcia_register_socket(&skt->socket);\r\nif (ret)\r\ngoto out_err;\r\nWARN_ON(skt->socket.sock != i);\r\nadd_timer(&skt->poll_timer);\r\n}\r\ndev_set_drvdata(dev, sinfo);\r\nreturn 0;\r\nout_err:\r\nops->hw_shutdown(skt);\r\nwhile (i-- > 0) {\r\nskt = PCMCIA_SOCKET(i);\r\ndel_timer_sync(&skt->poll_timer);\r\npcmcia_unregister_socket(&skt->socket);\r\nif (i == 0) {\r\niounmap(skt->virt_io + (u32)mips_io_port_base);\r\nskt->virt_io = NULL;\r\n}\r\n#ifndef CONFIG_MIPS_XXS1500\r\nelse {\r\niounmap(skt->virt_io + (u32)mips_io_port_base);\r\nskt->virt_io = NULL;\r\n}\r\n#endif\r\nops->hw_shutdown(skt);\r\n}\r\nkfree(sinfo);\r\nout:\r\nreturn ret;\r\n}\r\nint au1x00_drv_pcmcia_remove(struct platform_device *dev)\r\n{\r\nstruct skt_dev_info *sinfo = platform_get_drvdata(dev);\r\nint i;\r\nmutex_lock(&pcmcia_sockets_lock);\r\nplatform_set_drvdata(dev, NULL);\r\nfor (i = 0; i < sinfo->nskt; i++) {\r\nstruct au1000_pcmcia_socket *skt = PCMCIA_SOCKET(i);\r\ndel_timer_sync(&skt->poll_timer);\r\npcmcia_unregister_socket(&skt->socket);\r\nskt->ops->hw_shutdown(skt);\r\nau1x00_pcmcia_config_skt(skt, &dead_socket);\r\niounmap(skt->virt_io + (u32)mips_io_port_base);\r\nskt->virt_io = NULL;\r\n}\r\nkfree(sinfo);\r\nmutex_unlock(&pcmcia_sockets_lock);\r\nreturn 0;\r\n}\r\nstatic int au1x00_drv_pcmcia_probe(struct platform_device *dev)\r\n{\r\nint i, ret = -ENODEV;\r\nmutex_lock(&pcmcia_sockets_lock);\r\nfor (i=0; i < ARRAY_SIZE(au1x00_pcmcia_hw_init); i++) {\r\nret = au1x00_pcmcia_hw_init[i](&dev->dev);\r\nif (ret == 0)\r\nbreak;\r\n}\r\nmutex_unlock(&pcmcia_sockets_lock);\r\nreturn ret;\r\n}\r\nstatic int __init au1x00_pcmcia_init(void)\r\n{\r\nint error = 0;\r\nerror = platform_driver_register(&au1x00_pcmcia_driver);\r\nreturn error;\r\n}\r\nstatic void __exit au1x00_pcmcia_exit(void)\r\n{\r\nplatform_driver_unregister(&au1x00_pcmcia_driver);\r\n}
