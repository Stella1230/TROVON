static int kgdb_transition_check(char *buffer)\r\n{\r\nif (buffer[0] != '+' && buffer[0] != '$') {\r\nKDB_STATE_SET(KGDB_TRANS);\r\nkdb_printf("%s", buffer);\r\n} else {\r\nint slen = strlen(buffer);\r\nif (slen > 3 && buffer[slen - 3] == '#') {\r\nkdb_gdb_state_pass(buffer);\r\nstrcpy(buffer, "kgdb");\r\nKDB_STATE_SET(DOING_KGDB);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int kdb_read_get_key(char *buffer, size_t bufsize)\r\n{\r\n#define ESCAPE_UDELAY 1000\r\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY)\r\nchar escape_data[5];\r\nchar *ped = escape_data;\r\nint escape_delay = 0;\r\nget_char_func *f, *f_escape = NULL;\r\nint key;\r\nfor (f = &kdb_poll_funcs[0]; ; ++f) {\r\nif (*f == NULL) {\r\ntouch_nmi_watchdog();\r\nf = &kdb_poll_funcs[0];\r\n}\r\nif (escape_delay == 2) {\r\n*ped = '\0';\r\nped = escape_data;\r\n--escape_delay;\r\n}\r\nif (escape_delay == 1) {\r\nkey = *ped++;\r\nif (!*ped)\r\n--escape_delay;\r\nbreak;\r\n}\r\nkey = (*f)();\r\nif (key == -1) {\r\nif (escape_delay) {\r\nudelay(ESCAPE_UDELAY);\r\n--escape_delay;\r\n}\r\ncontinue;\r\n}\r\nif (bufsize <= 2) {\r\nif (key == '\r')\r\nkey = '\n';\r\n*buffer++ = key;\r\n*buffer = '\0';\r\nreturn -1;\r\n}\r\nif (escape_delay == 0 && key == '\e') {\r\nescape_delay = ESCAPE_DELAY;\r\nped = escape_data;\r\nf_escape = f;\r\n}\r\nif (escape_delay) {\r\n*ped++ = key;\r\nif (f_escape != f) {\r\nescape_delay = 2;\r\ncontinue;\r\n}\r\nif (ped - escape_data == 1) {\r\ncontinue;\r\n} else if (ped - escape_data == 2) {\r\nif (key != '[')\r\nescape_delay = 2;\r\ncontinue;\r\n} else if (ped - escape_data == 3) {\r\nint mapkey = 0;\r\nswitch (key) {\r\ncase 'A':\r\nmapkey = 16;\r\nbreak;\r\ncase 'B':\r\nmapkey = 14;\r\nbreak;\r\ncase 'C':\r\nmapkey = 6;\r\nbreak;\r\ncase 'D':\r\nmapkey = 2;\r\nbreak;\r\ncase '1':\r\ncase '3':\r\ncase '4':\r\nmapkey = -1;\r\nbreak;\r\n}\r\nif (mapkey != -1) {\r\nif (mapkey > 0) {\r\nescape_data[0] = mapkey;\r\nescape_data[1] = '\0';\r\n}\r\nescape_delay = 2;\r\n}\r\ncontinue;\r\n} else if (ped - escape_data == 4) {\r\nint mapkey = 0;\r\nif (key == '~') {\r\nswitch (escape_data[2]) {\r\ncase '1':\r\nmapkey = 1;\r\nbreak;\r\ncase '3':\r\nmapkey = 4;\r\nbreak;\r\ncase '4':\r\nmapkey = 5;\r\nbreak;\r\n}\r\n}\r\nif (mapkey > 0) {\r\nescape_data[0] = mapkey;\r\nescape_data[1] = '\0';\r\n}\r\nescape_delay = 2;\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn key;\r\n}\r\nstatic char *kdb_read(char *buffer, size_t bufsize)\r\n{\r\nchar *cp = buffer;\r\nchar *bufend = buffer+bufsize-2;\r\nchar *lastchar;\r\nchar *p_tmp;\r\nchar tmp;\r\nstatic char tmpbuffer[CMD_BUFLEN];\r\nint len = strlen(buffer);\r\nint len_tmp;\r\nint tab = 0;\r\nint count;\r\nint i;\r\nint diag, dtab_count;\r\nint key;\r\ndiag = kdbgetintenv("DTABCOUNT", &dtab_count);\r\nif (diag)\r\ndtab_count = 30;\r\nif (len > 0) {\r\ncp += len;\r\nif (*(buffer+len-1) == '\n')\r\ncp--;\r\n}\r\nlastchar = cp;\r\n*cp = '\0';\r\nkdb_printf("%s", buffer);\r\npoll_again:\r\nkey = kdb_read_get_key(buffer, bufsize);\r\nif (key == -1)\r\nreturn buffer;\r\nif (key != 9)\r\ntab = 0;\r\nswitch (key) {\r\ncase 8:\r\nif (cp > buffer) {\r\nif (cp < lastchar) {\r\nmemcpy(tmpbuffer, cp, lastchar - cp);\r\nmemcpy(cp-1, tmpbuffer, lastchar - cp);\r\n}\r\n*(--lastchar) = '\0';\r\n--cp;\r\nkdb_printf("\b%s \r", cp);\r\ntmp = *cp;\r\n*cp = '\0';\r\nkdb_printf(kdb_prompt_str);\r\nkdb_printf("%s", buffer);\r\n*cp = tmp;\r\n}\r\nbreak;\r\ncase 13:\r\n*lastchar++ = '\n';\r\n*lastchar++ = '\0';\r\nif (!KDB_STATE(KGDB_TRANS)) {\r\nKDB_STATE_SET(KGDB_TRANS);\r\nkdb_printf("%s", buffer);\r\n}\r\nkdb_printf("\n");\r\nreturn buffer;\r\ncase 4:\r\nif (cp < lastchar) {\r\nmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\r\nmemcpy(cp, tmpbuffer, lastchar - cp - 1);\r\n*(--lastchar) = '\0';\r\nkdb_printf("%s \r", cp);\r\ntmp = *cp;\r\n*cp = '\0';\r\nkdb_printf(kdb_prompt_str);\r\nkdb_printf("%s", buffer);\r\n*cp = tmp;\r\n}\r\nbreak;\r\ncase 1:\r\nif (cp > buffer) {\r\nkdb_printf("\r");\r\nkdb_printf(kdb_prompt_str);\r\ncp = buffer;\r\n}\r\nbreak;\r\ncase 5:\r\nif (cp < lastchar) {\r\nkdb_printf("%s", cp);\r\ncp = lastchar;\r\n}\r\nbreak;\r\ncase 2:\r\nif (cp > buffer) {\r\nkdb_printf("\b");\r\n--cp;\r\n}\r\nbreak;\r\ncase 14:\r\nmemset(tmpbuffer, ' ',\r\nstrlen(kdb_prompt_str) + (lastchar-buffer));\r\n*(tmpbuffer+strlen(kdb_prompt_str) +\r\n(lastchar-buffer)) = '\0';\r\nkdb_printf("\r%s\r", tmpbuffer);\r\n*lastchar = (char)key;\r\n*(lastchar+1) = '\0';\r\nreturn lastchar;\r\ncase 6:\r\nif (cp < lastchar) {\r\nkdb_printf("%c", *cp);\r\n++cp;\r\n}\r\nbreak;\r\ncase 16:\r\nmemset(tmpbuffer, ' ',\r\nstrlen(kdb_prompt_str) + (lastchar-buffer));\r\n*(tmpbuffer+strlen(kdb_prompt_str) +\r\n(lastchar-buffer)) = '\0';\r\nkdb_printf("\r%s\r", tmpbuffer);\r\n*lastchar = (char)key;\r\n*(lastchar+1) = '\0';\r\nreturn lastchar;\r\ncase 9:\r\nif (tab < 2)\r\n++tab;\r\np_tmp = buffer;\r\nwhile (*p_tmp == ' ')\r\np_tmp++;\r\nif (p_tmp > cp)\r\nbreak;\r\nmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\r\n*(tmpbuffer + (cp-p_tmp)) = '\0';\r\np_tmp = strrchr(tmpbuffer, ' ');\r\nif (p_tmp)\r\n++p_tmp;\r\nelse\r\np_tmp = tmpbuffer;\r\nlen = strlen(p_tmp);\r\ncount = kallsyms_symbol_complete(p_tmp,\r\nsizeof(tmpbuffer) -\r\n(p_tmp - tmpbuffer));\r\nif (tab == 2 && count > 0) {\r\nkdb_printf("\n%d symbols are found.", count);\r\nif (count > dtab_count) {\r\ncount = dtab_count;\r\nkdb_printf(" But only first %d symbols will"\r\n" be printed.\nYou can change the"\r\n" environment variable DTABCOUNT.",\r\ncount);\r\n}\r\nkdb_printf("\n");\r\nfor (i = 0; i < count; i++) {\r\nif (kallsyms_symbol_next(p_tmp, i) < 0)\r\nbreak;\r\nkdb_printf("%s ", p_tmp);\r\n*(p_tmp + len) = '\0';\r\n}\r\nif (i >= dtab_count)\r\nkdb_printf("...");\r\nkdb_printf("\n");\r\nkdb_printf(kdb_prompt_str);\r\nkdb_printf("%s", buffer);\r\n} else if (tab != 2 && count > 0) {\r\nlen_tmp = strlen(p_tmp);\r\nstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\r\nlen_tmp = strlen(p_tmp);\r\nstrncpy(cp, p_tmp+len, len_tmp-len + 1);\r\nlen = len_tmp - len;\r\nkdb_printf("%s", cp);\r\ncp += len;\r\nlastchar += len;\r\n}\r\nkdb_nextline = 1;\r\nbreak;\r\ndefault:\r\nif (key >= 32 && lastchar < bufend) {\r\nif (cp < lastchar) {\r\nmemcpy(tmpbuffer, cp, lastchar - cp);\r\nmemcpy(cp+1, tmpbuffer, lastchar - cp);\r\n*++lastchar = '\0';\r\n*cp = key;\r\nkdb_printf("%s\r", cp);\r\n++cp;\r\ntmp = *cp;\r\n*cp = '\0';\r\nkdb_printf(kdb_prompt_str);\r\nkdb_printf("%s", buffer);\r\n*cp = tmp;\r\n} else {\r\n*++lastchar = '\0';\r\n*cp++ = key;\r\nif (!KDB_STATE(KGDB_TRANS)) {\r\nif (kgdb_transition_check(buffer))\r\nreturn buffer;\r\n} else {\r\nkdb_printf("%c", key);\r\n}\r\n}\r\nif (lastchar - buffer >= 5 &&\r\nstrcmp(lastchar - 5, "$?#3f") == 0) {\r\nkdb_gdb_state_pass(lastchar - 5);\r\nstrcpy(buffer, "kgdb");\r\nKDB_STATE_SET(DOING_KGDB);\r\nreturn buffer;\r\n}\r\nif (lastchar - buffer >= 11 &&\r\nstrcmp(lastchar - 11, "$qSupported") == 0) {\r\nkdb_gdb_state_pass(lastchar - 11);\r\nstrcpy(buffer, "kgdb");\r\nKDB_STATE_SET(DOING_KGDB);\r\nreturn buffer;\r\n}\r\n}\r\nbreak;\r\n}\r\ngoto poll_again;\r\n}\r\nchar *kdb_getstr(char *buffer, size_t bufsize, char *prompt)\r\n{\r\nif (prompt && kdb_prompt_str != prompt)\r\nstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\r\nkdb_printf(kdb_prompt_str);\r\nkdb_nextline = 1;\r\nreturn kdb_read(buffer, bufsize);\r\n}\r\nstatic void kdb_input_flush(void)\r\n{\r\nget_char_func *f;\r\nint res;\r\nint flush_delay = 1;\r\nwhile (flush_delay) {\r\nflush_delay--;\r\nempty:\r\ntouch_nmi_watchdog();\r\nfor (f = &kdb_poll_funcs[0]; *f; ++f) {\r\nres = (*f)();\r\nif (res != -1) {\r\nflush_delay = 1;\r\ngoto empty;\r\n}\r\n}\r\nif (flush_delay)\r\nmdelay(1);\r\n}\r\n}\r\nstatic int kdb_search_string(char *searched, char *searchfor)\r\n{\r\nchar firstchar, *cp;\r\nint len1, len2;\r\nlen1 = strlen(searched)-1;\r\nlen2 = strlen(searchfor);\r\nif (len1 < len2)\r\nreturn 0;\r\nif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\r\nreturn 0;\r\nif (kdb_grep_leading) {\r\nif (!strncmp(searched, searchfor, len2))\r\nreturn 1;\r\n} else if (kdb_grep_trailing) {\r\nif (!strncmp(searched+len1-len2, searchfor, len2))\r\nreturn 1;\r\n} else {\r\nfirstchar = *searchfor;\r\ncp = searched;\r\nwhile ((cp = strchr(cp, firstchar))) {\r\nif (!strncmp(cp, searchfor, len2))\r\nreturn 1;\r\ncp++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint vkdb_printf(const char *fmt, va_list ap)\r\n{\r\nint diag;\r\nint linecount;\r\nint logging, saved_loglevel = 0;\r\nint saved_trap_printk;\r\nint got_printf_lock = 0;\r\nint retlen = 0;\r\nint fnd, len;\r\nchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\r\nchar *moreprompt = "more> ";\r\nstruct console *c = console_drivers;\r\nstatic DEFINE_SPINLOCK(kdb_printf_lock);\r\nunsigned long uninitialized_var(flags);\r\npreempt_disable();\r\nsaved_trap_printk = kdb_trap_printk;\r\nkdb_trap_printk = 0;\r\nif (!KDB_STATE(PRINTF_LOCK)) {\r\nKDB_STATE_SET(PRINTF_LOCK);\r\nspin_lock_irqsave(&kdb_printf_lock, flags);\r\ngot_printf_lock = 1;\r\natomic_inc(&kdb_event);\r\n} else {\r\n__acquire(kdb_printf_lock);\r\n}\r\ndiag = kdbgetintenv("LINES", &linecount);\r\nif (diag || linecount <= 1)\r\nlinecount = 24;\r\ndiag = kdbgetintenv("LOGGING", &logging);\r\nif (diag)\r\nlogging = 0;\r\nif (!kdb_grepping_flag || suspend_grep) {\r\nnext_avail = kdb_buffer;\r\nsize_avail = sizeof(kdb_buffer);\r\n}\r\nvsnprintf(next_avail, size_avail, fmt, ap);\r\nif (!suspend_grep && kdb_grepping_flag) {\r\ncp = strchr(kdb_buffer, '\n');\r\nif (!cp) {\r\nif (next_avail == kdb_buffer) {\r\ncp2 = kdb_buffer;\r\nlen = strlen(kdb_prompt_str);\r\nif (!strncmp(cp2, kdb_prompt_str, len)) {\r\nkdb_grepping_flag = 0;\r\ngoto kdb_printit;\r\n}\r\n}\r\nlen = strlen(kdb_buffer);\r\nnext_avail = kdb_buffer + len;\r\nsize_avail = sizeof(kdb_buffer) - len;\r\ngoto kdb_print_out;\r\n}\r\ncp++;\r\nreplaced_byte = *cp;\r\ncphold = cp;\r\n*cp = '\0';\r\nfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\r\nif (!fnd) {\r\n*cphold = replaced_byte;\r\nstrcpy(kdb_buffer, cphold);\r\nlen = strlen(kdb_buffer);\r\nnext_avail = kdb_buffer + len;\r\nsize_avail = sizeof(kdb_buffer) - len;\r\ngoto kdb_print_out;\r\n}\r\n}\r\nkdb_printit:\r\nretlen = strlen(kdb_buffer);\r\nif (!dbg_kdb_mode && kgdb_connected) {\r\ngdbstub_msg_write(kdb_buffer, retlen);\r\n} else {\r\nif (!dbg_io_ops->is_console) {\r\nlen = strlen(kdb_buffer);\r\ncp = kdb_buffer;\r\nwhile (len--) {\r\ndbg_io_ops->write_char(*cp);\r\ncp++;\r\n}\r\n}\r\nwhile (c) {\r\nc->write(c, kdb_buffer, retlen);\r\ntouch_nmi_watchdog();\r\nc = c->next;\r\n}\r\n}\r\nif (logging) {\r\nsaved_loglevel = console_loglevel;\r\nconsole_loglevel = 0;\r\nprintk(KERN_INFO "%s", kdb_buffer);\r\n}\r\nif (KDB_STATE(PAGER) && strchr(kdb_buffer, '\n'))\r\nkdb_nextline++;\r\nif (kdb_nextline == linecount) {\r\nchar buf1[16] = "";\r\n#if defined(CONFIG_SMP)\r\nchar buf2[32];\r\n#endif\r\nkdb_nextline = 1;\r\nmoreprompt = kdbgetenv("MOREPROMPT");\r\nif (moreprompt == NULL)\r\nmoreprompt = "more> ";\r\n#if defined(CONFIG_SMP)\r\nif (strchr(moreprompt, '%')) {\r\nsprintf(buf2, moreprompt, get_cpu());\r\nput_cpu();\r\nmoreprompt = buf2;\r\n}\r\n#endif\r\nkdb_input_flush();\r\nc = console_drivers;\r\nif (!dbg_io_ops->is_console) {\r\nlen = strlen(moreprompt);\r\ncp = moreprompt;\r\nwhile (len--) {\r\ndbg_io_ops->write_char(*cp);\r\ncp++;\r\n}\r\n}\r\nwhile (c) {\r\nc->write(c, moreprompt, strlen(moreprompt));\r\ntouch_nmi_watchdog();\r\nc = c->next;\r\n}\r\nif (logging)\r\nprintk("%s", moreprompt);\r\nkdb_read(buf1, 2);\r\nkdb_nextline = 1;\r\nkdb_buffer[0] = '\0';\r\nnext_avail = kdb_buffer;\r\nsize_avail = sizeof(kdb_buffer);\r\nif ((buf1[0] == 'q') || (buf1[0] == 'Q')) {\r\nKDB_FLAG_SET(CMD_INTERRUPT);\r\nKDB_STATE_CLEAR(PAGER);\r\nkdb_grepping_flag = 0;\r\nkdb_printf("\n");\r\n} else if (buf1[0] == ' ') {\r\nkdb_printf("\n");\r\nsuspend_grep = 1;\r\n} else if (buf1[0] == '\n') {\r\nkdb_nextline = linecount - 1;\r\nkdb_printf("\r");\r\nsuspend_grep = 1;\r\n} else if (buf1[0] && buf1[0] != '\n') {\r\nsuspend_grep = 1;\r\nkdb_printf("\nOnly 'q' or 'Q' are processed at more "\r\n"prompt, input ignored\n");\r\n} else if (kdb_grepping_flag) {\r\nsuspend_grep = 1;\r\nkdb_printf("\n");\r\n}\r\nkdb_input_flush();\r\n}\r\nif (kdb_grepping_flag && !suspend_grep) {\r\n*cphold = replaced_byte;\r\nstrcpy(kdb_buffer, cphold);\r\nlen = strlen(kdb_buffer);\r\nnext_avail = kdb_buffer + len;\r\nsize_avail = sizeof(kdb_buffer) - len;\r\n}\r\nkdb_print_out:\r\nsuspend_grep = 0;\r\nif (logging)\r\nconsole_loglevel = saved_loglevel;\r\nif (KDB_STATE(PRINTF_LOCK) && got_printf_lock) {\r\ngot_printf_lock = 0;\r\nspin_unlock_irqrestore(&kdb_printf_lock, flags);\r\nKDB_STATE_CLEAR(PRINTF_LOCK);\r\natomic_dec(&kdb_event);\r\n} else {\r\n__release(kdb_printf_lock);\r\n}\r\nkdb_trap_printk = saved_trap_printk;\r\npreempt_enable();\r\nreturn retlen;\r\n}\r\nint kdb_printf(const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint r;\r\nva_start(ap, fmt);\r\nr = vkdb_printf(fmt, ap);\r\nva_end(ap);\r\nreturn r;\r\n}
