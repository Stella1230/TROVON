void rose_clear_queues(struct sock *sk)\r\n{\r\nskb_queue_purge(&sk->sk_write_queue);\r\nskb_queue_purge(&rose_sk(sk)->ack_queue);\r\n}\r\nvoid rose_frames_acked(struct sock *sk, unsigned short nr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nif (rose->va != nr) {\r\nwhile (skb_peek(&rose->ack_queue) != NULL && rose->va != nr) {\r\nskb = skb_dequeue(&rose->ack_queue);\r\nkfree_skb(skb);\r\nrose->va = (rose->va + 1) % ROSE_MODULUS;\r\n}\r\n}\r\n}\r\nvoid rose_requeue_frames(struct sock *sk)\r\n{\r\nstruct sk_buff *skb, *skb_prev = NULL;\r\nwhile ((skb = skb_dequeue(&rose_sk(sk)->ack_queue)) != NULL) {\r\nif (skb_prev == NULL)\r\nskb_queue_head(&sk->sk_write_queue, skb);\r\nelse\r\nskb_append(skb_prev, skb, &sk->sk_write_queue);\r\nskb_prev = skb;\r\n}\r\n}\r\nint rose_validate_nr(struct sock *sk, unsigned short nr)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nunsigned short vc = rose->va;\r\nwhile (vc != rose->vs) {\r\nif (nr == vc) return 1;\r\nvc = (vc + 1) % ROSE_MODULUS;\r\n}\r\nreturn nr == rose->vs;\r\n}\r\nvoid rose_write_internal(struct sock *sk, int frametype)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nunsigned char lci1, lci2;\r\nchar buffer[100];\r\nint len, faclen = 0;\r\nlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\r\nswitch (frametype) {\r\ncase ROSE_CALL_REQUEST:\r\nlen += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;\r\nfaclen = rose_create_facilities(buffer, rose);\r\nlen += faclen;\r\nbreak;\r\ncase ROSE_CALL_ACCEPTED:\r\ncase ROSE_CLEAR_REQUEST:\r\ncase ROSE_RESET_REQUEST:\r\nlen += 2;\r\nbreak;\r\n}\r\nif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1);\r\ndptr = skb_put(skb, skb_tailroom(skb));\r\nlci1 = (rose->lci >> 8) & 0x0F;\r\nlci2 = (rose->lci >> 0) & 0xFF;\r\nswitch (frametype) {\r\ncase ROSE_CALL_REQUEST:\r\n*dptr++ = ROSE_GFI | lci1;\r\n*dptr++ = lci2;\r\n*dptr++ = frametype;\r\n*dptr++ = ROSE_CALL_REQ_ADDR_LEN_VAL;\r\nmemcpy(dptr, &rose->dest_addr, ROSE_ADDR_LEN);\r\ndptr += ROSE_ADDR_LEN;\r\nmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\r\ndptr += ROSE_ADDR_LEN;\r\nmemcpy(dptr, buffer, faclen);\r\ndptr += faclen;\r\nbreak;\r\ncase ROSE_CALL_ACCEPTED:\r\n*dptr++ = ROSE_GFI | lci1;\r\n*dptr++ = lci2;\r\n*dptr++ = frametype;\r\n*dptr++ = 0x00;\r\n*dptr++ = 0;\r\nbreak;\r\ncase ROSE_CLEAR_REQUEST:\r\n*dptr++ = ROSE_GFI | lci1;\r\n*dptr++ = lci2;\r\n*dptr++ = frametype;\r\n*dptr++ = rose->cause;\r\n*dptr++ = rose->diagnostic;\r\nbreak;\r\ncase ROSE_RESET_REQUEST:\r\n*dptr++ = ROSE_GFI | lci1;\r\n*dptr++ = lci2;\r\n*dptr++ = frametype;\r\n*dptr++ = ROSE_DTE_ORIGINATED;\r\n*dptr++ = 0;\r\nbreak;\r\ncase ROSE_RR:\r\ncase ROSE_RNR:\r\n*dptr++ = ROSE_GFI | lci1;\r\n*dptr++ = lci2;\r\n*dptr = frametype;\r\n*dptr++ |= (rose->vr << 5) & 0xE0;\r\nbreak;\r\ncase ROSE_CLEAR_CONFIRMATION:\r\ncase ROSE_RESET_CONFIRMATION:\r\n*dptr++ = ROSE_GFI | lci1;\r\n*dptr++ = lci2;\r\n*dptr++ = frametype;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "ROSE: rose_write_internal - invalid frametype %02X\n", frametype);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nrose_transmit_link(skb, rose->neighbour);\r\n}\r\nint rose_decode(struct sk_buff *skb, int *ns, int *nr, int *q, int *d, int *m)\r\n{\r\nunsigned char *frame;\r\nframe = skb->data;\r\n*ns = *nr = *q = *d = *m = 0;\r\nswitch (frame[2]) {\r\ncase ROSE_CALL_REQUEST:\r\ncase ROSE_CALL_ACCEPTED:\r\ncase ROSE_CLEAR_REQUEST:\r\ncase ROSE_CLEAR_CONFIRMATION:\r\ncase ROSE_RESET_REQUEST:\r\ncase ROSE_RESET_CONFIRMATION:\r\nreturn frame[2];\r\ndefault:\r\nbreak;\r\n}\r\nif ((frame[2] & 0x1F) == ROSE_RR ||\r\n(frame[2] & 0x1F) == ROSE_RNR) {\r\n*nr = (frame[2] >> 5) & 0x07;\r\nreturn frame[2] & 0x1F;\r\n}\r\nif ((frame[2] & 0x01) == ROSE_DATA) {\r\n*q = (frame[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\r\n*d = (frame[0] & ROSE_D_BIT) == ROSE_D_BIT;\r\n*m = (frame[2] & ROSE_M_BIT) == ROSE_M_BIT;\r\n*nr = (frame[2] >> 5) & 0x07;\r\n*ns = (frame[2] >> 1) & 0x07;\r\nreturn ROSE_DATA;\r\n}\r\nreturn ROSE_ILLEGAL;\r\n}\r\nstatic int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\r\n{\r\nunsigned char *pt;\r\nunsigned char l, lg, n = 0;\r\nint fac_national_digis_received = 0;\r\ndo {\r\nswitch (*p & 0xC0) {\r\ncase 0x00:\r\nif (len < 2)\r\nreturn -1;\r\np += 2;\r\nn += 2;\r\nlen -= 2;\r\nbreak;\r\ncase 0x40:\r\nif (len < 3)\r\nreturn -1;\r\nif (*p == FAC_NATIONAL_RAND)\r\nfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\r\np += 3;\r\nn += 3;\r\nlen -= 3;\r\nbreak;\r\ncase 0x80:\r\nif (len < 4)\r\nreturn -1;\r\np += 4;\r\nn += 4;\r\nlen -= 4;\r\nbreak;\r\ncase 0xC0:\r\nif (len < 2)\r\nreturn -1;\r\nl = p[1];\r\nif (len < 2 + l)\r\nreturn -1;\r\nif (*p == FAC_NATIONAL_DEST_DIGI) {\r\nif (!fac_national_digis_received) {\r\nif (l < AX25_ADDR_LEN)\r\nreturn -1;\r\nmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\r\nfacilities->source_ndigis = 1;\r\n}\r\n}\r\nelse if (*p == FAC_NATIONAL_SRC_DIGI) {\r\nif (!fac_national_digis_received) {\r\nif (l < AX25_ADDR_LEN)\r\nreturn -1;\r\nmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\r\nfacilities->dest_ndigis = 1;\r\n}\r\n}\r\nelse if (*p == FAC_NATIONAL_FAIL_CALL) {\r\nif (l < AX25_ADDR_LEN)\r\nreturn -1;\r\nmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\r\n}\r\nelse if (*p == FAC_NATIONAL_FAIL_ADD) {\r\nif (l < 1 + ROSE_ADDR_LEN)\r\nreturn -1;\r\nmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\r\n}\r\nelse if (*p == FAC_NATIONAL_DIGIS) {\r\nif (l % AX25_ADDR_LEN)\r\nreturn -1;\r\nfac_national_digis_received = 1;\r\nfacilities->source_ndigis = 0;\r\nfacilities->dest_ndigis = 0;\r\nfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\r\nif (pt[6] & AX25_HBIT) {\r\nif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\r\nreturn -1;\r\nmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\r\n} else {\r\nif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\r\nreturn -1;\r\nmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\r\n}\r\n}\r\n}\r\np += l + 2;\r\nn += l + 2;\r\nlen -= l + 2;\r\nbreak;\r\n}\r\n} while (*p != 0x00 && len > 0);\r\nreturn n;\r\n}\r\nstatic int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\r\n{\r\nunsigned char l, n = 0;\r\nchar callsign[11];\r\ndo {\r\nswitch (*p & 0xC0) {\r\ncase 0x00:\r\nif (len < 2)\r\nreturn -1;\r\np += 2;\r\nn += 2;\r\nlen -= 2;\r\nbreak;\r\ncase 0x40:\r\nif (len < 3)\r\nreturn -1;\r\np += 3;\r\nn += 3;\r\nlen -= 3;\r\nbreak;\r\ncase 0x80:\r\nif (len < 4)\r\nreturn -1;\r\np += 4;\r\nn += 4;\r\nlen -= 4;\r\nbreak;\r\ncase 0xC0:\r\nif (len < 2)\r\nreturn -1;\r\nl = p[1];\r\nif (l < 10 || l > 20)\r\nreturn -1;\r\nif (*p == FAC_CCITT_DEST_NSAP) {\r\nmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\r\nmemcpy(callsign, p + 12, l - 10);\r\ncallsign[l - 10] = '\0';\r\nasc2ax(&facilities->source_call, callsign);\r\n}\r\nif (*p == FAC_CCITT_SRC_NSAP) {\r\nmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\r\nmemcpy(callsign, p + 12, l - 10);\r\ncallsign[l - 10] = '\0';\r\nasc2ax(&facilities->dest_call, callsign);\r\n}\r\np += l + 2;\r\nn += l + 2;\r\nlen -= l + 2;\r\nbreak;\r\n}\r\n} while (*p != 0x00 && len > 0);\r\nreturn n;\r\n}\r\nint rose_parse_facilities(unsigned char *p, unsigned packet_len,\r\nstruct rose_facilities_struct *facilities)\r\n{\r\nint facilities_len, len;\r\nfacilities_len = *p++;\r\nif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\r\nreturn 0;\r\nwhile (facilities_len >= 3 && *p == 0x00) {\r\nfacilities_len--;\r\np++;\r\nswitch (*p) {\r\ncase FAC_NATIONAL:\r\nlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\r\nbreak;\r\ncase FAC_CCITT:\r\nlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "ROSE: rose_parse_facilities - unknown facilities family %02X\n", *p);\r\nlen = 1;\r\nbreak;\r\n}\r\nif (len < 0)\r\nreturn 0;\r\nif (WARN_ON(len >= facilities_len))\r\nreturn 0;\r\nfacilities_len -= len + 1;\r\np += len + 1;\r\n}\r\nreturn facilities_len == 0;\r\n}\r\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)\r\n{\r\nunsigned char *p = buffer + 1;\r\nchar *callsign;\r\nchar buf[11];\r\nint len, nb;\r\nif (rose->rand != 0 || rose->source_ndigis == 1 || rose->dest_ndigis == 1) {\r\n*p++ = 0x00;\r\n*p++ = FAC_NATIONAL;\r\nif (rose->rand != 0) {\r\n*p++ = FAC_NATIONAL_RAND;\r\n*p++ = (rose->rand >> 8) & 0xFF;\r\n*p++ = (rose->rand >> 0) & 0xFF;\r\n}\r\nif ((rose->source_ndigis > 0) || (rose->dest_ndigis > 0)) {\r\nint maxdigi = 0;\r\n*p++ = FAC_NATIONAL_DIGIS;\r\n*p++ = AX25_ADDR_LEN * (rose->source_ndigis + rose->dest_ndigis);\r\nfor (nb = 0 ; nb < rose->source_ndigis ; nb++) {\r\nif (++maxdigi >= ROSE_MAX_DIGIS)\r\nbreak;\r\nmemcpy(p, &rose->source_digis[nb], AX25_ADDR_LEN);\r\np[6] |= AX25_HBIT;\r\np += AX25_ADDR_LEN;\r\n}\r\nfor (nb = 0 ; nb < rose->dest_ndigis ; nb++) {\r\nif (++maxdigi >= ROSE_MAX_DIGIS)\r\nbreak;\r\nmemcpy(p, &rose->dest_digis[nb], AX25_ADDR_LEN);\r\np[6] &= ~AX25_HBIT;\r\np += AX25_ADDR_LEN;\r\n}\r\n}\r\nif (rose->source_ndigis > 0) {\r\n*p++ = FAC_NATIONAL_SRC_DIGI;\r\n*p++ = AX25_ADDR_LEN;\r\nmemcpy(p, &rose->source_digis[0], AX25_ADDR_LEN);\r\np += AX25_ADDR_LEN;\r\n}\r\nif (rose->dest_ndigis > 0) {\r\n*p++ = FAC_NATIONAL_DEST_DIGI;\r\n*p++ = AX25_ADDR_LEN;\r\nmemcpy(p, &rose->dest_digis[0], AX25_ADDR_LEN);\r\np += AX25_ADDR_LEN;\r\n}\r\n}\r\n*p++ = 0x00;\r\n*p++ = FAC_CCITT;\r\n*p++ = FAC_CCITT_DEST_NSAP;\r\ncallsign = ax2asc(buf, &rose->dest_call);\r\n*p++ = strlen(callsign) + 10;\r\n*p++ = (strlen(callsign) + 9) * 2;\r\n*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\r\n*p++ = ROSE_ADDR_LEN * 2;\r\nmemcpy(p, &rose->dest_addr, ROSE_ADDR_LEN);\r\np += ROSE_ADDR_LEN;\r\nmemcpy(p, callsign, strlen(callsign));\r\np += strlen(callsign);\r\n*p++ = FAC_CCITT_SRC_NSAP;\r\ncallsign = ax2asc(buf, &rose->source_call);\r\n*p++ = strlen(callsign) + 10;\r\n*p++ = (strlen(callsign) + 9) * 2;\r\n*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\r\n*p++ = ROSE_ADDR_LEN * 2;\r\nmemcpy(p, &rose->source_addr, ROSE_ADDR_LEN);\r\np += ROSE_ADDR_LEN;\r\nmemcpy(p, callsign, strlen(callsign));\r\np += strlen(callsign);\r\nlen = p - buffer;\r\nbuffer[0] = len - 1;\r\nreturn len;\r\n}\r\nvoid rose_disconnect(struct sock *sk, int reason, int cause, int diagnostic)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nrose_stop_timer(sk);\r\nrose_stop_idletimer(sk);\r\nrose_clear_queues(sk);\r\nrose->lci = 0;\r\nrose->state = ROSE_STATE_0;\r\nif (cause != -1)\r\nrose->cause = cause;\r\nif (diagnostic != -1)\r\nrose->diagnostic = diagnostic;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_err = reason;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\n}\r\n}
