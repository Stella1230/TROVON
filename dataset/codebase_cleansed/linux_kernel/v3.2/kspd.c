static int sp_syscall(int num, int arg0, int arg1, int arg2, int arg3)\r\n{\r\nregister long int _num __asm__("$2") = num;\r\nregister long int _arg0 __asm__("$4") = arg0;\r\nregister long int _arg1 __asm__("$5") = arg1;\r\nregister long int _arg2 __asm__("$6") = arg2;\r\nregister long int _arg3 __asm__("$7") = arg3;\r\nmm_segment_t old_fs;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\n__asm__ __volatile__ (\r\n" syscall \n"\r\n: "=r" (_num), "=r" (_arg3)\r\n: "r" (_num), "r" (_arg0), "r" (_arg1), "r" (_arg2), "r" (_arg3));\r\nset_fs(old_fs);\r\nif (_arg3)\r\nreturn -_num;\r\nreturn _num;\r\n}\r\nstatic int translate_syscall_command(int cmd)\r\n{\r\nint i;\r\nint ret = -1;\r\nfor (i = 0; i < ARRAY_SIZE(syscall_command_table); i++) {\r\nif ((cmd == syscall_command_table[i].sp))\r\nreturn syscall_command_table[i].ap;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int translate_open_flags(int flags)\r\n{\r\nint i;\r\nunsigned int ret = 0;\r\nfor (i = 0; i < ARRAY_SIZE(open_flags_table); i++) {\r\nif( (flags & open_flags_table[i].sp) ) {\r\nret |= open_flags_table[i].ap;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sp_setfsuidgid(uid_t uid, gid_t gid)\r\n{\r\nstruct cred *new;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->fsuid = uid;\r\nnew->fsgid = gid;\r\ncommit_creds(new);\r\nreturn 0;\r\n}\r\nvoid sp_work_handle_request(void)\r\n{\r\nstruct mtsp_syscall sc;\r\nstruct mtsp_syscall_generic generic;\r\nstruct mtsp_syscall_ret ret;\r\nstruct kspd_notifications *n;\r\nunsigned long written;\r\nmm_segment_t old_fs;\r\nstruct timeval tv;\r\nstruct timezone tz;\r\nint err, cmd;\r\nchar *vcwd;\r\nint size;\r\nret.retval = -1;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nif (!rtlx_read(RTLX_CHANNEL_SYSIO, &sc, sizeof(struct mtsp_syscall))) {\r\nset_fs(old_fs);\r\nprintk(KERN_ERR "Expected request but nothing to read\n");\r\nreturn;\r\n}\r\nsize = sc.size;\r\nif (size) {\r\nif (!rtlx_read(RTLX_CHANNEL_SYSIO, &generic, size)) {\r\nset_fs(old_fs);\r\nprintk(KERN_ERR "Expected request but nothing to read\n");\r\nreturn;\r\n}\r\n}\r\nif (vpe_getuid(tclimit)) {\r\nerr = sp_setfsuidgid(vpe_getuid(tclimit), vpe_getgid(tclimit));\r\nif (!err)\r\npr_err("Change of creds failed\n");\r\n}\r\nswitch (sc.cmd) {\r\ncase MTSP_SYSCALL_PIPEFREQ:\r\nret.retval = cpu_khz * 1000;\r\nret.errno = 0;\r\nbreak;\r\ncase MTSP_SYSCALL_GETTOD:\r\nmemset(&tz, 0, sizeof(tz));\r\nif ((ret.retval = sp_syscall(__NR_gettimeofday, (int)&tv,\r\n(int)&tz, 0, 0)) == 0)\r\nret.retval = tv.tv_sec;\r\nbreak;\r\ncase MTSP_SYSCALL_EXIT:\r\nlist_for_each_entry(n, &kspd_notifylist, list)\r\nn->kspd_sp_exit(tclimit);\r\nsp_stopping = 1;\r\nprintk(KERN_DEBUG "KSPD got exit syscall from SP exitcode %d\n",\r\ngeneric.arg0);\r\nbreak;\r\ncase MTSP_SYSCALL_OPEN:\r\ngeneric.arg1 = translate_open_flags(generic.arg1);\r\nvcwd = vpe_getcwd(tclimit);\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nsys_chdir(vcwd);\r\nset_fs(old_fs);\r\nsc.cmd = __NR_open;\r\ndefault:\r\nif ((sc.cmd >= __NR_Linux) &&\r\n(sc.cmd <= (__NR_Linux + __NR_Linux_syscalls)) )\r\ncmd = sc.cmd;\r\nelse\r\ncmd = translate_syscall_command(sc.cmd);\r\nif (cmd >= 0) {\r\nret.retval = sp_syscall(cmd, generic.arg0, generic.arg1,\r\ngeneric.arg2, generic.arg3);\r\n} else\r\nprintk(KERN_WARNING\r\n"KSPD: Unknown SP syscall number %d\n", sc.cmd);\r\nbreak;\r\n}\r\nif (vpe_getuid(tclimit)) {\r\nerr = sp_setfsuidgid(0, 0);\r\nif (!err)\r\npr_err("restoring old creds failed\n");\r\n}\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nwritten = rtlx_write(RTLX_CHANNEL_SYSIO, &ret, sizeof(ret));\r\nset_fs(old_fs);\r\nif (written < sizeof(ret))\r\nprintk("KSPD: sp_work_handle_request failed to send to SP\n");\r\n}\r\nstatic void sp_cleanup(void)\r\n{\r\nstruct files_struct *files = current->files;\r\nint i, j;\r\nstruct fdtable *fdt;\r\nj = 0;\r\nfdt = files_fdtable(files);\r\nfor (;;) {\r\nunsigned long set;\r\ni = j * __NFDBITS;\r\nif (i >= fdt->max_fds)\r\nbreak;\r\nset = fdt->open_fds->fds_bits[j++];\r\nwhile (set) {\r\nif (set & 1) {\r\nstruct file * file = xchg(&fdt->fd[i], NULL);\r\nif (file)\r\nfilp_close(file, files);\r\n}\r\ni++;\r\nset >>= 1;\r\n}\r\n}\r\nsys_chdir("/");\r\n}\r\nstatic void sp_work(struct work_struct *unused)\r\n{\r\nif (!channel_open) {\r\nif( rtlx_open(RTLX_CHANNEL_SYSIO, 1) != 0) {\r\nprintk("KSPD: unable to open sp channel\n");\r\nsp_stopping = 1;\r\n} else {\r\nchannel_open++;\r\nprintk(KERN_DEBUG "KSPD: SP channel opened\n");\r\n}\r\n} else {\r\nrtlx_read_poll(RTLX_CHANNEL_SYSIO, 1);\r\nif (!sp_stopping)\r\nsp_work_handle_request();\r\n}\r\nif (!sp_stopping)\r\nqueue_work(workqueue, &work);\r\nelse\r\nsp_cleanup();\r\n}\r\nstatic void startwork(int vpe)\r\n{\r\nsp_stopping = channel_open = 0;\r\nif (workqueue == NULL) {\r\nif ((workqueue = create_singlethread_workqueue("kspd")) == NULL) {\r\nprintk(KERN_ERR "unable to start kspd\n");\r\nreturn;\r\n}\r\nINIT_WORK(&work, sp_work);\r\n}\r\nqueue_work(workqueue, &work);\r\n}\r\nstatic void stopwork(int vpe)\r\n{\r\nsp_stopping = 1;\r\nprintk(KERN_DEBUG "KSPD: SP stopping\n");\r\n}\r\nvoid kspd_notify(struct kspd_notifications *notify)\r\n{\r\nlist_add(&notify->list, &kspd_notifylist);\r\n}\r\nstatic int kspd_module_init(void)\r\n{\r\nINIT_LIST_HEAD(&kspd_notifylist);\r\nnotify.start = startwork;\r\nnotify.stop = stopwork;\r\nvpe_notify(tclimit, &notify);\r\nreturn 0;\r\n}\r\nstatic void kspd_module_exit(void)\r\n{\r\n}
