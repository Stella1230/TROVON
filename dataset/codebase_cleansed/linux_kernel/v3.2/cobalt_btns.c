static void handle_buttons(struct input_polled_dev *dev)\r\n{\r\nstruct buttons_dev *bdev = dev->private;\r\nstruct input_dev *input = dev->input;\r\nuint32_t status;\r\nint i;\r\nstatus = ~readl(bdev->reg) >> 24;\r\nfor (i = 0; i < ARRAY_SIZE(bdev->keymap); i++) {\r\nif (status & (1U << i)) {\r\nif (++bdev->count[i] == BUTTONS_COUNT_THRESHOLD) {\r\ninput_event(input, EV_MSC, MSC_SCAN, i);\r\ninput_report_key(input, bdev->keymap[i], 1);\r\ninput_sync(input);\r\n}\r\n} else {\r\nif (bdev->count[i] >= BUTTONS_COUNT_THRESHOLD) {\r\ninput_event(input, EV_MSC, MSC_SCAN, i);\r\ninput_report_key(input, bdev->keymap[i], 0);\r\ninput_sync(input);\r\n}\r\nbdev->count[i] = 0;\r\n}\r\n}\r\n}\r\nstatic int __devinit cobalt_buttons_probe(struct platform_device *pdev)\r\n{\r\nstruct buttons_dev *bdev;\r\nstruct input_polled_dev *poll_dev;\r\nstruct input_dev *input;\r\nstruct resource *res;\r\nint error, i;\r\nbdev = kzalloc(sizeof(struct buttons_dev), GFP_KERNEL);\r\npoll_dev = input_allocate_polled_device();\r\nif (!bdev || !poll_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nmemcpy(bdev->keymap, cobalt_map, sizeof(bdev->keymap));\r\npoll_dev->private = bdev;\r\npoll_dev->poll = handle_buttons;\r\npoll_dev->poll_interval = BUTTONS_POLL_INTERVAL;\r\ninput = poll_dev->input;\r\ninput->name = "Cobalt buttons";\r\ninput->phys = "cobalt/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &pdev->dev;\r\ninput->keycode = bdev->keymap;\r\ninput->keycodemax = ARRAY_SIZE(bdev->keymap);\r\ninput->keycodesize = sizeof(unsigned short);\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\n__set_bit(EV_KEY, input->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(cobalt_map); i++)\r\n__set_bit(bdev->keymap[i], input->keybit);\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerror = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nbdev->poll_dev = poll_dev;\r\nbdev->reg = ioremap(res->start, resource_size(res));\r\ndev_set_drvdata(&pdev->dev, bdev);\r\nerror = input_register_polled_device(poll_dev);\r\nif (error)\r\ngoto err_iounmap;\r\nreturn 0;\r\nerr_iounmap:\r\niounmap(bdev->reg);\r\nerr_free_mem:\r\ninput_free_polled_device(poll_dev);\r\nkfree(bdev);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nreturn error;\r\n}\r\nstatic int __devexit cobalt_buttons_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct buttons_dev *bdev = dev_get_drvdata(dev);\r\ninput_unregister_polled_device(bdev->poll_dev);\r\ninput_free_polled_device(bdev->poll_dev);\r\niounmap(bdev->reg);\r\nkfree(bdev);\r\ndev_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init cobalt_buttons_init(void)\r\n{\r\nreturn platform_driver_register(&cobalt_buttons_driver);\r\n}\r\nstatic void __exit cobalt_buttons_exit(void)\r\n{\r\nplatform_driver_unregister(&cobalt_buttons_driver);\r\n}
