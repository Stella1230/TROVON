static int __devinit driver_amplc_pci230_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id\r\n*ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_amplc_pci230.driver_name);\r\n}\r\nstatic void __devexit driver_amplc_pci230_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_amplc_pci230_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_amplc_pci230);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_amplc_pci230_pci_driver.name =\r\n(char *)driver_amplc_pci230.driver_name;\r\nreturn pci_register_driver(&driver_amplc_pci230_pci_driver);\r\n}\r\nstatic void __exit driver_amplc_pci230_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_amplc_pci230_pci_driver);\r\ncomedi_driver_unregister(&driver_amplc_pci230);\r\n}\r\nstatic short pci230_ai_read(struct comedi_device *dev)\r\n{\r\nshort data = (short)inw(dev->iobase + PCI230_ADCDATA);\r\ndata = data >> (16 - thisboard->ai_bits);\r\nif (devpriv->ai_bipolar)\r\ndata ^= 1 << (thisboard->ai_bits - 1);\r\nreturn data;\r\n}\r\nstatic inline unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,\r\nshort datum)\r\n{\r\nif (devpriv->ao_bipolar)\r\ndatum ^= 1 << (thisboard->ao_bits - 1);\r\ndatum <<= (16 - thisboard->ao_bits);\r\nreturn (unsigned short)datum;\r\n}\r\nstatic inline void pci230_ao_write_nofifo(struct comedi_device *dev,\r\nshort datum, unsigned int chan)\r\n{\r\ndevpriv->ao_readback[chan] = datum;\r\noutw(pci230_ao_mangle_datum(dev, datum), dev->iobase + (((chan) == 0)\r\n? PCI230_DACOUT1\r\n:\r\nPCI230_DACOUT2));\r\n}\r\nstatic inline void pci230_ao_write_fifo(struct comedi_device *dev, short datum,\r\nunsigned int chan)\r\n{\r\ndevpriv->ao_readback[chan] = datum;\r\noutw(pci230_ao_mangle_datum(dev, datum),\r\ndev->iobase + PCI230P2_DACDATA);\r\n}\r\nstatic int pci230_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nunsigned long iobase1, iobase2;\r\nstruct pci_dev *pci_dev = NULL;\r\nint i = 0, irq_hdl, rc;\r\nprintk("comedi%d: amplc_pci230: attach %s %d,%d\n", dev->minor,\r\nthisboard->name, it->options[0], it->options[1]);\r\nif ((alloc_private(dev, sizeof(struct pci230_private))) < 0)\r\nreturn -ENOMEM;\r\nspin_lock_init(&devpriv->isr_spinlock);\r\nspin_lock_init(&devpriv->res_spinlock);\r\nspin_lock_init(&devpriv->ai_stop_spinlock);\r\nspin_lock_init(&devpriv->ao_stop_spinlock);\r\nfor_each_pci_dev(pci_dev) {\r\nif (it->options[0] || it->options[1]) {\r\nif (it->options[0] != pci_dev->bus->number ||\r\nit->options[1] != PCI_SLOT(pci_dev->devfn))\r\ncontinue;\r\n}\r\nif (pci_dev->vendor != PCI_VENDOR_ID_AMPLICON)\r\ncontinue;\r\nif (thisboard->id == PCI_DEVICE_ID_INVALID) {\r\nfor (i = 0; i < n_pci230_boards; i++) {\r\nif (pci_dev->device == pci230_boards[i].id) {\r\nif (pci230_boards[i].min_hwver > 0) {\r\nif (pci_resource_len(pci_dev, 3)\r\n< 32) {\r\ncontinue;\r\n}\r\n}\r\ndev->board_ptr = &pci230_boards[i];\r\nbreak;\r\n}\r\n}\r\nif (i < n_pci230_boards)\r\nbreak;\r\n} else {\r\nif (thisboard->id == pci_dev->device) {\r\nif (thisboard->min_hwver > 0) {\r\nif (pci_resource_len(pci_dev, 3) < 32) {\r\ncontinue;\r\n}\r\nbreak;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (!pci_dev) {\r\nprintk("comedi%d: No %s card found\n", dev->minor,\r\nthisboard->name);\r\nreturn -EIO;\r\n}\r\ndevpriv->pci_dev = pci_dev;\r\ndev->board_name = thisboard->name;\r\nif (comedi_pci_enable(pci_dev, "amplc_pci230") < 0) {\r\nprintk("comedi%d: failed to enable PCI device "\r\n"and request regions\n", dev->minor);\r\nreturn -EIO;\r\n}\r\niobase1 = pci_resource_start(pci_dev, 2);\r\niobase2 = pci_resource_start(pci_dev, 3);\r\nprintk("comedi%d: %s I/O region 1 0x%04lx I/O region 2 0x%04lx\n",\r\ndev->minor, dev->board_name, iobase1, iobase2);\r\ndevpriv->iobase1 = iobase1;\r\ndev->iobase = iobase2;\r\ndevpriv->daccon = inw(dev->iobase + PCI230_DACCON) & PCI230_DAC_OR_MASK;\r\nif (pci_resource_len(pci_dev, 3) >= 32) {\r\nunsigned short extfunc = 0;\r\ndevpriv->hwver = inw(dev->iobase + PCI230P_HWVER);\r\nif (devpriv->hwver < thisboard->min_hwver) {\r\nprintk("comedi%d: %s - bad hardware version "\r\n"- got %u, need %u\n", dev->minor,\r\ndev->board_name, devpriv->hwver,\r\nthisboard->min_hwver);\r\nreturn -EIO;\r\n}\r\nif (devpriv->hwver > 0) {\r\nif (!thisboard->have_dio) {\r\nextfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;\r\n}\r\nif ((thisboard->ao_chans > 0)\r\n&& (devpriv->hwver >= 2)) {\r\nextfunc |= PCI230P2_EXTFUNC_DACFIFO;\r\n}\r\n}\r\noutw(extfunc, dev->iobase + PCI230P_EXTFUNC);\r\nif ((extfunc & PCI230P2_EXTFUNC_DACFIFO) != 0) {\r\noutw(devpriv->daccon | PCI230P2_DAC_FIFO_EN\r\n| PCI230P2_DAC_FIFO_RESET,\r\ndev->iobase + PCI230_DACCON);\r\noutw(0, dev->iobase + PCI230P2_DACEN);\r\noutw(devpriv->daccon, dev->iobase + PCI230_DACCON);\r\n}\r\n}\r\noutb(0, devpriv->iobase1 + PCI230_INT_SCE);\r\ndevpriv->adcg = 0;\r\ndevpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE\r\n| PCI230_ADC_IR_BIP;\r\noutw(1 << 0, dev->iobase + PCI230_ADCEN);\r\noutw(devpriv->adcg, dev->iobase + PCI230_ADCG);\r\noutw(devpriv->adccon | PCI230_ADC_FIFO_RESET,\r\ndev->iobase + PCI230_ADCCON);\r\nirq_hdl = request_irq(devpriv->pci_dev->irq, pci230_interrupt,\r\nIRQF_SHARED, "amplc_pci230", dev);\r\nif (irq_hdl < 0) {\r\nprintk("comedi%d: unable to register irq, "\r\n"commands will not be available %d\n", dev->minor,\r\ndevpriv->pci_dev->irq);\r\n} else {\r\ndev->irq = devpriv->pci_dev->irq;\r\nprintk("comedi%d: registered irq %u\n", dev->minor,\r\ndevpriv->pci_dev->irq);\r\n}\r\nif (alloc_subdevices(dev, 3) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;\r\ns->n_chan = thisboard->ai_chans;\r\ns->maxdata = (1 << thisboard->ai_bits) - 1;\r\ns->range_table = &pci230_ai_range;\r\ns->insn_read = &pci230_ai_rinsn;\r\ns->len_chanlist = 256;\r\nif (irq_hdl == 0) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmd = &pci230_ai_cmd;\r\ns->do_cmdtest = &pci230_ai_cmdtest;\r\ns->cancel = pci230_ai_cancel;\r\n}\r\ns = dev->subdevices + 1;\r\nif (thisboard->ao_chans > 0) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = thisboard->ao_chans;\r\ns->maxdata = (1 << thisboard->ao_bits) - 1;\r\ns->range_table = &pci230_ao_range;\r\ns->insn_write = &pci230_ao_winsn;\r\ns->insn_read = &pci230_ao_rinsn;\r\ns->len_chanlist = thisboard->ao_chans;\r\nif (irq_hdl == 0) {\r\ndev->write_subdev = s;\r\ns->subdev_flags |= SDF_CMD_WRITE;\r\ns->do_cmd = &pci230_ao_cmd;\r\ns->do_cmdtest = &pci230_ao_cmdtest;\r\ns->cancel = pci230_ao_cancel;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 2;\r\nif (thisboard->have_dio) {\r\nrc = subdev_8255_init(dev, s, NULL,\r\n(devpriv->iobase1 + PCI230_PPI_X_BASE));\r\nif (rc < 0)\r\nreturn rc;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nprintk("comedi%d: attached\n", dev->minor);\r\nreturn 1;\r\n}\r\nstatic int pci230_detach(struct comedi_device *dev)\r\n{\r\nprintk("comedi%d: amplc_pci230: remove\n", dev->minor);\r\nif (dev->subdevices && thisboard->have_dio)\r\nsubdev_8255_cleanup(dev, dev->subdevices + 2);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->pci_dev) {\r\nif (dev->iobase)\r\ncomedi_pci_disable(devpriv->pci_dev);\r\npci_dev_put(devpriv->pci_dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_resources(struct comedi_device *dev, unsigned int res_mask,\r\nunsigned char owner)\r\n{\r\nint ok;\r\nunsigned int i;\r\nunsigned int b;\r\nunsigned int claimed;\r\nunsigned long irqflags;\r\nok = 1;\r\nclaimed = 0;\r\nspin_lock_irqsave(&devpriv->res_spinlock, irqflags);\r\nfor (b = 1, i = 0; (i < NUM_RESOURCES)\r\n&& (res_mask != 0); b <<= 1, i++) {\r\nif ((res_mask & b) != 0) {\r\nres_mask &= ~b;\r\nif (devpriv->res_owner[i] == OWNER_NONE) {\r\ndevpriv->res_owner[i] = owner;\r\nclaimed |= b;\r\n} else if (devpriv->res_owner[i] != owner) {\r\nfor (b = 1, i = 0; claimed != 0; b <<= 1, i++) {\r\nif ((claimed & b) != 0) {\r\ndevpriv->res_owner[i]\r\n= OWNER_NONE;\r\nclaimed &= ~b;\r\n}\r\n}\r\nok = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);\r\nreturn ok;\r\n}\r\nstatic inline int get_one_resource(struct comedi_device *dev,\r\nunsigned int resource, unsigned char owner)\r\n{\r\nreturn get_resources(dev, (1U << resource), owner);\r\n}\r\nstatic void put_resources(struct comedi_device *dev, unsigned int res_mask,\r\nunsigned char owner)\r\n{\r\nunsigned int i;\r\nunsigned int b;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&devpriv->res_spinlock, irqflags);\r\nfor (b = 1, i = 0; (i < NUM_RESOURCES)\r\n&& (res_mask != 0); b <<= 1, i++) {\r\nif ((res_mask & b) != 0) {\r\nres_mask &= ~b;\r\nif (devpriv->res_owner[i] == owner)\r\ndevpriv->res_owner[i] = OWNER_NONE;\r\n}\r\n}\r\nspin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);\r\n}\r\nstatic inline void put_one_resource(struct comedi_device *dev,\r\nunsigned int resource, unsigned char owner)\r\n{\r\nput_resources(dev, (1U << resource), owner);\r\n}\r\nstatic inline void put_all_resources(struct comedi_device *dev,\r\nunsigned char owner)\r\n{\r\nput_resources(dev, (1U << NUM_RESOURCES) - 1, owner);\r\n}\r\nstatic int pci230_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int n, i;\r\nunsigned int chan, range, aref;\r\nunsigned int gainshift;\r\nunsigned int status;\r\nunsigned short adccon, adcen;\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\naref = CR_AREF(insn->chanspec);\r\nif (aref == AREF_DIFF) {\r\nif (chan >= s->n_chan / 2) {\r\nDPRINTK("comedi%d: amplc_pci230: ai_rinsn: "\r\n"differential channel number out of range "\r\n"0 to %u\n", dev->minor, (s->n_chan / 2) - 1);\r\nreturn -EINVAL;\r\n}\r\n}\r\nadccon = PCI230_ADC_TRIG_Z2CT2 | PCI230_ADC_FIFO_EN;\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE0);\r\ndevpriv->ai_bipolar = pci230_ai_bipolar[range];\r\nif (aref == AREF_DIFF) {\r\ngainshift = chan * 2;\r\nif (devpriv->hwver == 0) {\r\nadcen = 3 << gainshift;\r\n} else {\r\nadcen = 1 << gainshift;\r\n}\r\nadccon |= PCI230_ADC_IM_DIF;\r\n} else {\r\nadcen = 1 << chan;\r\ngainshift = chan & ~1;\r\nadccon |= PCI230_ADC_IM_SE;\r\n}\r\ndevpriv->adcg = (devpriv->adcg & ~(3 << gainshift))\r\n| (pci230_ai_gain[range] << gainshift);\r\nif (devpriv->ai_bipolar)\r\nadccon |= PCI230_ADC_IR_BIP;\r\nelse\r\nadccon |= PCI230_ADC_IR_UNI;\r\noutw(adcen, dev->iobase + PCI230_ADCEN);\r\noutw(devpriv->adcg, dev->iobase + PCI230_ADCG);\r\ndevpriv->adccon = adccon;\r\noutw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);\r\nfor (n = 0; n < insn->n; n++) {\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,\r\nI8254_MODE0);\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,\r\nI8254_MODE1);\r\n#define TIMEOUT 100\r\nfor (i = 0; i < TIMEOUT; i++) {\r\nstatus = inw(dev->iobase + PCI230_ADCCON);\r\nif (!(status & PCI230_ADC_FIFO_EMPTY))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == TIMEOUT) {\r\nprintk("timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ndata[n] = pci230_ai_read(dev);\r\n}\r\nreturn n;\r\n}\r\nstatic int pci230_ao_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nint chan, range;\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\ndevpriv->ao_bipolar = pci230_ao_bipolar[range];\r\noutw(range, dev->iobase + PCI230_DACCON);\r\nfor (i = 0; i < insn->n; i++) {\r\npci230_ao_write_nofifo(dev, data[i], chan);\r\n}\r\nreturn i;\r\n}\r\nstatic int pci230_ao_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn i;\r\n}\r\nstatic int pci230_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\nif ((thisboard->min_hwver > 0) && (devpriv->hwver >= 2)) {\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_INT | TRIG_EXT;\r\n} else {\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_INT;\r\n}\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif ((cmd->start_src & (cmd->start_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->convert_src & (cmd->convert_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->stop_src & (cmd->stop_src - 1)) != 0)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\n#define MAX_SPEED_AO 8000\r\n#define MIN_SPEED_AO 4294967295u\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nif (cmd->scan_begin_arg < MAX_SPEED_AO) {\r\ncmd->scan_begin_arg = MAX_SPEED_AO;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg > MIN_SPEED_AO) {\r\ncmd->scan_begin_arg = MIN_SPEED_AO;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr++;\r\n}\r\nif ((cmd->scan_begin_arg\r\n& (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {\r\ncmd->scan_begin_arg =\r\nCOMBINE(cmd->scan_begin_arg, 0,\r\nCR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_NONE) {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\npci230_ns_to_single_timer(&cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0) {\r\nenum {\r\nseq_err = (1 << 0),\r\nrange_err = (1 << 1)\r\n};\r\nunsigned int errors;\r\nunsigned int n;\r\nunsigned int chan, prev_chan;\r\nunsigned int range, first_range;\r\nprev_chan = CR_CHAN(cmd->chanlist[0]);\r\nfirst_range = CR_RANGE(cmd->chanlist[0]);\r\nerrors = 0;\r\nfor (n = 1; n < cmd->chanlist_len; n++) {\r\nchan = CR_CHAN(cmd->chanlist[n]);\r\nrange = CR_RANGE(cmd->chanlist[n]);\r\nif (chan < prev_chan)\r\nerrors |= seq_err;\r\nif (range != first_range)\r\nerrors |= range_err;\r\nprev_chan = chan;\r\n}\r\nif (errors != 0) {\r\nerr++;\r\nif ((errors & seq_err) != 0) {\r\nDPRINTK("comedi%d: amplc_pci230: ao_cmdtest: "\r\n"channel numbers must increase\n",\r\ndev->minor);\r\n}\r\nif ((errors & range_err) != 0) {\r\nDPRINTK("comedi%d: amplc_pci230: ao_cmdtest: "\r\n"channels must have the same range\n",\r\ndev->minor);\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nunsigned long irqflags;\r\nif (trig_num != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);\r\nif (test_bit(AO_CMD_STARTED, &devpriv->state)) {\r\nif (devpriv->hwver < 2) {\r\nspin_unlock_irqrestore(&devpriv->ao_stop_spinlock,\r\nirqflags);\r\npci230_handle_ao_nofifo(dev, s);\r\ncomedi_event(dev, s);\r\n} else {\r\ninw(dev->iobase + PCI230P2_DACSWTRIG);\r\nspin_unlock_irqrestore(&devpriv->ao_stop_spinlock,\r\nirqflags);\r\n}\r\nudelay(8);\r\n}\r\nreturn 1;\r\n}\r\nstatic void pci230_ao_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned long irqflags;\r\nset_bit(AO_CMD_STARTED, &devpriv->state);\r\nif (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0)) {\r\nasync->events |= COMEDI_CB_EOA;\r\npci230_ao_stop(dev, s);\r\ncomedi_event(dev, s);\r\n} else {\r\nif (devpriv->hwver >= 2) {\r\nunsigned short scantrig;\r\nint run;\r\nrun = pci230_handle_ao_fifo(dev, s);\r\ncomedi_event(dev, s);\r\nif (!run) {\r\nreturn;\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nscantrig = PCI230P2_DAC_TRIG_Z2CT1;\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->scan_begin_arg & CR_INVERT) == 0) {\r\nscantrig = PCI230P2_DAC_TRIG_EXTP;\r\n} else {\r\nscantrig = PCI230P2_DAC_TRIG_EXTN;\r\n}\r\nbreak;\r\ncase TRIG_INT:\r\nscantrig = PCI230P2_DAC_TRIG_SW;\r\nbreak;\r\ndefault:\r\nscantrig = PCI230P2_DAC_TRIG_NONE;\r\nbreak;\r\n}\r\ndevpriv->daccon = (devpriv->daccon\r\n& ~PCI230P2_DAC_TRIG_MASK) |\r\nscantrig;\r\noutw(devpriv->daccon, dev->iobase + PCI230_DACCON);\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nif (devpriv->hwver < 2) {\r\nspin_lock_irqsave(&devpriv->isr_spinlock,\r\nirqflags);\r\ndevpriv->int_en |= PCI230_INT_ZCLK_CT1;\r\ndevpriv->ier |= PCI230_INT_ZCLK_CT1;\r\noutb(devpriv->ier,\r\ndevpriv->iobase1 + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock,\r\nirqflags);\r\n}\r\noutb(GAT_CONFIG(1, GAT_VCC),\r\ndevpriv->iobase1 + PCI230_ZGAT_SCE);\r\nbreak;\r\ncase TRIG_INT:\r\nasync->inttrig = pci230_ao_inttrig_scan_begin;\r\nbreak;\r\n}\r\nif (devpriv->hwver >= 2) {\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->int_en |= PCI230P2_INT_DAC;\r\ndevpriv->ier |= PCI230P2_INT_DAC;\r\noutb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock,\r\nirqflags);\r\n}\r\n}\r\n}\r\nstatic int pci230_ao_inttrig_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nif (trig_num != 0)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULLFUNC;\r\npci230_ao_start(dev, s);\r\nreturn 1;\r\n}\r\nstatic int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned short daccon;\r\nunsigned int range;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (!get_one_resource(dev, RES_Z2CT1, OWNER_AOCMD))\r\nreturn -EBUSY;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\ndevpriv->ao_scan_count = cmd->stop_arg;\r\ndevpriv->ao_continuous = 0;\r\n} else {\r\ndevpriv->ao_scan_count = 0;\r\ndevpriv->ao_continuous = 1;\r\n}\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\ndevpriv->ao_bipolar = pci230_ao_bipolar[range];\r\ndaccon = devpriv->ao_bipolar ? PCI230_DAC_OR_BIP : PCI230_DAC_OR_UNI;\r\nif (devpriv->hwver >= 2) {\r\nunsigned short dacen;\r\nunsigned int i;\r\ndacen = 0;\r\nfor (i = 0; i < cmd->chanlist_len; i++)\r\ndacen |= 1 << CR_CHAN(cmd->chanlist[i]);\r\noutw(dacen, dev->iobase + PCI230P2_DACEN);\r\ndaccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET\r\n| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR\r\n| PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;\r\n}\r\noutw(daccon, dev->iobase + PCI230_DACCON);\r\ndevpriv->daccon = daccon\r\n& ~(PCI230P2_DAC_FIFO_RESET | PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\noutb(GAT_CONFIG(1, GAT_GND),\r\ndevpriv->iobase1 + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,\r\ncmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\n}\r\ns->async->inttrig = pci230_ao_inttrig_start;\r\nreturn 0;\r\n}\r\nstatic int pci230_ai_check_scan_period(struct comedi_cmd *cmd)\r\n{\r\nunsigned int min_scan_period, chanlist_len;\r\nint err = 0;\r\nchanlist_len = cmd->chanlist_len;\r\nif (cmd->chanlist_len == 0)\r\nchanlist_len = 1;\r\nmin_scan_period = chanlist_len * cmd->convert_arg;\r\nif ((min_scan_period < chanlist_len)\r\n|| (min_scan_period < cmd->convert_arg)) {\r\nmin_scan_period = UINT_MAX;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg < min_scan_period) {\r\ncmd->scan_begin_arg = min_scan_period;\r\nerr++;\r\n}\r\nreturn !err;\r\n}\r\nstatic int pci230_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_INT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\nif ((thisboard->have_dio) || (thisboard->min_hwver > 0)) {\r\ncmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT\r\n| TRIG_EXT;\r\n} else {\r\ncmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;\r\n}\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_INT | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif ((cmd->start_src & (cmd->start_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->scan_begin_src & (cmd->scan_begin_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->convert_src & (cmd->convert_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->scan_end_src & (cmd->scan_end_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->stop_src & (cmd->stop_src - 1)) != 0)\r\nerr++;\r\nif ((cmd->scan_begin_src != TRIG_FOLLOW)\r\n&& (cmd->convert_src != TRIG_TIMER))\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\n#define MAX_SPEED_AI_SE 3200\r\n#define MAX_SPEED_AI_DIFF 8000\r\n#define MAX_SPEED_AI_PLUS 4000\r\n#define MIN_SPEED_AI 4294967295u\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned int max_speed_ai;\r\nif (devpriv->hwver == 0) {\r\nif (cmd->chanlist && (cmd->chanlist_len > 0)) {\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_DIFF)\r\nmax_speed_ai = MAX_SPEED_AI_DIFF;\r\nelse\r\nmax_speed_ai = MAX_SPEED_AI_SE;\r\n} else {\r\nmax_speed_ai = MAX_SPEED_AI_SE;\r\n}\r\n} else {\r\nmax_speed_ai = MAX_SPEED_AI_PLUS;\r\n}\r\nif (cmd->convert_arg < max_speed_ai) {\r\ncmd->convert_arg = max_speed_ai;\r\nerr++;\r\n}\r\nif (cmd->convert_arg > MIN_SPEED_AI) {\r\ncmd->convert_arg = MIN_SPEED_AI;\r\nerr++;\r\n}\r\n} else if (cmd->convert_src == TRIG_EXT) {\r\nif ((cmd->convert_arg & CR_FLAGS_MASK) != 0) {\r\nif ((cmd->convert_arg & ~CR_FLAGS_MASK) != 0) {\r\ncmd->convert_arg = COMBINE(cmd->convert_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr++;\r\n}\r\nif ((cmd->convert_arg & (CR_FLAGS_MASK & ~CR_INVERT))\r\n!= CR_EDGE) {\r\ncmd->convert_arg =\r\nCOMBINE(cmd->start_arg, (CR_EDGE | 0),\r\nCR_FLAGS_MASK & ~CR_INVERT);\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->convert_arg > 1) {\r\ncmd->convert_arg = 1;\r\nerr++;\r\n}\r\n}\r\n} else {\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_NONE) {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nif ((cmd->scan_begin_arg & ~CR_FLAGS_MASK) != 0) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\n~CR_FLAGS_MASK);\r\nerr++;\r\n}\r\nif ((cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) != 0) {\r\ncmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\r\nCR_FLAGS_MASK & ~CR_EDGE);\r\nerr++;\r\n}\r\n} else if (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (!pci230_ai_check_scan_period(cmd))\r\nerr++;\r\n} else {\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\npci230_ns_to_single_timer(&cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\npci230_ns_to_single_timer(&cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (!pci230_ai_check_scan_period(cmd)) {\r\npci230_ns_to_single_timer(&cmd->scan_begin_arg,\r\nTRIG_ROUND_UP);\r\npci230_ai_check_scan_period(cmd);\r\n}\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0) {\r\nenum {\r\nseq_err = 1 << 0,\r\nrangepair_err = 1 << 1,\r\npolarity_err = 1 << 2,\r\naref_err = 1 << 3,\r\ndiffchan_err = 1 << 4,\r\nbuggy_chan0_err = 1 << 5\r\n};\r\nunsigned int errors;\r\nunsigned int chan, prev_chan;\r\nunsigned int range, prev_range;\r\nunsigned int polarity, prev_polarity;\r\nunsigned int aref, prev_aref;\r\nunsigned int subseq_len;\r\nunsigned int n;\r\nsubseq_len = 0;\r\nerrors = 0;\r\nprev_chan = prev_aref = prev_range = prev_polarity = 0;\r\nfor (n = 0; n < cmd->chanlist_len; n++) {\r\nchan = CR_CHAN(cmd->chanlist[n]);\r\nrange = CR_RANGE(cmd->chanlist[n]);\r\naref = CR_AREF(cmd->chanlist[n]);\r\npolarity = pci230_ai_bipolar[range];\r\nif ((aref == AREF_DIFF)\r\n&& (chan >= (s->n_chan / 2))) {\r\nerrors |= diffchan_err;\r\n}\r\nif (n > 0) {\r\nif ((chan <= prev_chan)\r\n&& (subseq_len == 0)) {\r\nsubseq_len = n;\r\n}\r\nif ((subseq_len > 0)\r\n&& (cmd->chanlist[n] !=\r\ncmd->chanlist[n % subseq_len])) {\r\nerrors |= seq_err;\r\n}\r\nif (aref != prev_aref)\r\nerrors |= aref_err;\r\nif (polarity != prev_polarity)\r\nerrors |= polarity_err;\r\nif ((aref != AREF_DIFF)\r\n&& (((chan ^ prev_chan) & ~1) == 0)\r\n&& (range != prev_range)) {\r\nerrors |= rangepair_err;\r\n}\r\n}\r\nprev_chan = chan;\r\nprev_range = range;\r\nprev_aref = aref;\r\nprev_polarity = polarity;\r\n}\r\nif (subseq_len == 0) {\r\nsubseq_len = n;\r\n}\r\nif ((n % subseq_len) != 0)\r\nerrors |= seq_err;\r\nif ((devpriv->hwver > 0) && (devpriv->hwver < 4)) {\r\nif ((subseq_len > 1)\r\n&& (CR_CHAN(cmd->chanlist[0]) != 0)) {\r\nerrors |= buggy_chan0_err;\r\n}\r\n}\r\nif (errors != 0) {\r\nerr++;\r\nif ((errors & seq_err) != 0) {\r\nDPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "\r\n"channel numbers must increase or "\r\n"sequence must repeat exactly\n",\r\ndev->minor);\r\n}\r\nif ((errors & rangepair_err) != 0) {\r\nDPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "\r\n"single-ended channel pairs must "\r\n"have the same range\n", dev->minor);\r\n}\r\nif ((errors & polarity_err) != 0) {\r\nDPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "\r\n"channel sequence ranges must be all "\r\n"bipolar or all unipolar\n",\r\ndev->minor);\r\n}\r\nif ((errors & aref_err) != 0) {\r\nDPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "\r\n"channel sequence analogue references "\r\n"must be all the same (single-ended "\r\n"or differential)\n", dev->minor);\r\n}\r\nif ((errors & diffchan_err) != 0) {\r\nDPRINTK("comedi%d: amplc_pci230: ai_cmdtest: "\r\n"differential channel number out of "\r\n"range 0 to %u\n", dev->minor,\r\n(s->n_chan / 2) - 1);\r\n}\r\nif ((errors & buggy_chan0_err) != 0) {\r\nprintk("comedi: comedi%d: amplc_pci230: "\r\n"ai_cmdtest: Buggy PCI230+/260+ "\r\n"h/w version %u requires first channel "\r\n"of multi-channel sequence to be 0 "\r\n"(corrected in h/w version 4)\n",\r\ndev->minor, devpriv->hwver);\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int scanlen = cmd->scan_end_arg;\r\nunsigned int wake;\r\nunsigned short triglev;\r\nunsigned short adccon;\r\nif ((cmd->flags & TRIG_WAKE_EOS) != 0) {\r\nwake = scanlen - devpriv->ai_scan_pos;\r\n} else {\r\nif (devpriv->ai_continuous\r\n|| (devpriv->ai_scan_count >= PCI230_ADC_FIFOLEVEL_HALFFULL)\r\n|| (scanlen >= PCI230_ADC_FIFOLEVEL_HALFFULL)) {\r\nwake = PCI230_ADC_FIFOLEVEL_HALFFULL;\r\n} else {\r\nwake = (devpriv->ai_scan_count * scanlen)\r\n- devpriv->ai_scan_pos;\r\n}\r\n}\r\nif (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {\r\ntriglev = PCI230_ADC_INT_FIFO_HALF;\r\n} else {\r\nif ((wake > 1) && (devpriv->hwver > 0)) {\r\nif (devpriv->adcfifothresh != wake) {\r\ndevpriv->adcfifothresh = wake;\r\noutw(wake, dev->iobase + PCI230P_ADCFFTH);\r\n}\r\ntriglev = PCI230P_ADC_INT_FIFO_THRESH;\r\n} else {\r\ntriglev = PCI230_ADC_INT_FIFO_NEMPTY;\r\n}\r\n}\r\nadccon = (devpriv->adccon & ~PCI230_ADC_INT_FIFO_MASK) | triglev;\r\nif (adccon != devpriv->adccon) {\r\ndevpriv->adccon = adccon;\r\noutw(adccon, dev->iobase + PCI230_ADCCON);\r\n}\r\n}\r\nstatic int pci230_ai_inttrig_convert(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nunsigned long irqflags;\r\nif (trig_num != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\r\nif (test_bit(AI_CMD_STARTED, &devpriv->state)) {\r\nunsigned int delayus;\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,\r\nI8254_MODE0);\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2,\r\nI8254_MODE1);\r\nif (((devpriv->adccon & PCI230_ADC_IM_MASK)\r\n== PCI230_ADC_IM_DIF)\r\n&& (devpriv->hwver == 0)) {\r\ndelayus = 8;\r\n} else {\r\ndelayus = 4;\r\n}\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\nudelay(delayus);\r\n} else {\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\n}\r\nreturn 1;\r\n}\r\nstatic int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nunsigned long irqflags;\r\nunsigned char zgat;\r\nif (trig_num != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\r\nif (test_bit(AI_CMD_STARTED, &devpriv->state)) {\r\nzgat = GAT_CONFIG(0, GAT_GND);\r\noutb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);\r\nzgat = GAT_CONFIG(0, GAT_VCC);\r\noutb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);\r\n}\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\nreturn 1;\r\n}\r\nstatic void pci230_ai_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long irqflags;\r\nunsigned short conv;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nset_bit(AI_CMD_STARTED, &devpriv->state);\r\nif (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {\r\nasync->events |= COMEDI_CB_EOA;\r\npci230_ai_stop(dev, s);\r\ncomedi_event(dev, s);\r\n} else {\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->int_en |= PCI230_INT_ADC;\r\ndevpriv->ier |= PCI230_INT_ADC;\r\noutb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nswitch (cmd->convert_src) {\r\ndefault:\r\nconv = PCI230_ADC_TRIG_NONE;\r\nbreak;\r\ncase TRIG_TIMER:\r\nconv = PCI230_ADC_TRIG_Z2CT2;\r\nbreak;\r\ncase TRIG_EXT:\r\nif ((cmd->convert_arg & CR_EDGE) != 0) {\r\nif ((cmd->convert_arg & CR_INVERT) == 0) {\r\nconv = PCI230_ADC_TRIG_EXTP;\r\n} else {\r\nconv = PCI230_ADC_TRIG_EXTN;\r\n}\r\n} else {\r\nif (cmd->convert_arg != 0) {\r\nconv = PCI230_ADC_TRIG_EXTP;\r\n} else {\r\nconv = PCI230_ADC_TRIG_EXTN;\r\n}\r\n}\r\nbreak;\r\ncase TRIG_INT:\r\nconv = PCI230_ADC_TRIG_Z2CT2;\r\nbreak;\r\n}\r\ndevpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK)\r\n| conv;\r\noutw(devpriv->adccon, dev->iobase + PCI230_ADCCON);\r\nif (cmd->convert_src == TRIG_INT)\r\nasync->inttrig = pci230_ai_inttrig_convert;\r\npci230_ai_update_fifo_trigger_level(dev, s);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned char zgat;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nzgat = GAT_CONFIG(2, GAT_NOUTNM2);\r\n} else {\r\nzgat = GAT_CONFIG(2, GAT_VCC);\r\n}\r\noutb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nswitch (cmd->scan_begin_src) {\r\ndefault:\r\nzgat = GAT_CONFIG(0, GAT_VCC);\r\nbreak;\r\ncase TRIG_EXT:\r\nzgat = GAT_CONFIG(0, GAT_EXT);\r\nbreak;\r\ncase TRIG_TIMER:\r\nzgat = GAT_CONFIG(0, GAT_NOUTNM2);\r\nbreak;\r\ncase TRIG_INT:\r\nzgat = GAT_CONFIG(0, GAT_VCC);\r\nbreak;\r\n}\r\noutb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nzgat = GAT_CONFIG(1, GAT_VCC);\r\noutb(zgat, devpriv->iobase1\r\n+ PCI230_ZGAT_SCE);\r\nbreak;\r\ncase TRIG_INT:\r\nasync->inttrig =\r\npci230_ai_inttrig_scan_begin;\r\nbreak;\r\n}\r\n}\r\n} else if (cmd->convert_src != TRIG_INT) {\r\nput_one_resource(dev, RES_Z2CT2, OWNER_AICMD);\r\n}\r\n}\r\n}\r\nstatic int pci230_ai_inttrig_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nif (trig_num != 0)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULLFUNC;\r\npci230_ai_start(dev, s);\r\nreturn 1;\r\n}\r\nstatic int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned int i, chan, range, diff;\r\nunsigned int res_mask;\r\nunsigned short adccon, adcen;\r\nunsigned char zgat;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nres_mask = 0;\r\nres_mask |= (1U << RES_Z2CT2);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nres_mask |= (1U << RES_Z2CT0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nres_mask |= (1U << RES_Z2CT1);\r\n}\r\n}\r\nif (!get_resources(dev, res_mask, OWNER_AICMD))\r\nreturn -EBUSY;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\ndevpriv->ai_scan_count = cmd->stop_arg;\r\ndevpriv->ai_continuous = 0;\r\n} else {\r\ndevpriv->ai_scan_count = 0;\r\ndevpriv->ai_continuous = 1;\r\n}\r\ndevpriv->ai_scan_pos = 0;\r\nadccon = PCI230_ADC_FIFO_EN;\r\nadcen = 0;\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_DIFF) {\r\ndiff = 1;\r\nadccon |= PCI230_ADC_IM_DIF;\r\n} else {\r\ndiff = 0;\r\nadccon |= PCI230_ADC_IM_SE;\r\n}\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\ndevpriv->ai_bipolar = pci230_ai_bipolar[range];\r\nif (devpriv->ai_bipolar)\r\nadccon |= PCI230_ADC_IR_BIP;\r\nelse\r\nadccon |= PCI230_ADC_IR_UNI;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int gainshift;\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nif (diff) {\r\ngainshift = 2 * chan;\r\nif (devpriv->hwver == 0) {\r\nadcen |= 3 << gainshift;\r\n} else {\r\nadcen |= 1 << gainshift;\r\n}\r\n} else {\r\ngainshift = (chan & ~1);\r\nadcen |= 1 << chan;\r\n}\r\ndevpriv->adcg = (devpriv->adcg & ~(3 << gainshift))\r\n| (pci230_ai_gain[range] << gainshift);\r\n}\r\noutw(adcen, dev->iobase + PCI230_ADCEN);\r\noutw(devpriv->adcg, dev->iobase + PCI230_ADCG);\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, 2, I8254_MODE1);\r\nadccon |= PCI230_ADC_INT_FIFO_FULL | PCI230_ADC_TRIG_Z2CT2;\r\ndevpriv->adccon = adccon;\r\noutw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);\r\nudelay(25);\r\noutw(adccon | PCI230_ADC_FIFO_RESET, dev->iobase + PCI230_ADCCON);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nzgat = GAT_CONFIG(2, GAT_GND);\r\noutb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\nzgat = GAT_CONFIG(0, GAT_VCC);\r\noutb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,\r\n((uint64_t) cmd->convert_arg\r\n* cmd->scan_end_arg),\r\nTRIG_ROUND_UP);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nzgat = GAT_CONFIG(1, GAT_GND);\r\noutb(zgat, devpriv->iobase1 + PCI230_ZGAT_SCE);\r\npci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,\r\ncmd->scan_begin_arg,\r\ncmd->\r\nflags &\r\nTRIG_ROUND_MASK);\r\n}\r\n}\r\n}\r\nif (cmd->start_src == TRIG_INT) {\r\ns->async->inttrig = pci230_ai_inttrig_start;\r\n} else {\r\npci230_ai_start(dev, s);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int divide_ns(uint64_t ns, unsigned int timebase,\r\nunsigned int round_mode)\r\n{\r\nuint64_t div;\r\nunsigned int rem;\r\ndiv = ns;\r\nrem = do_div(div, timebase);\r\nround_mode &= TRIG_ROUND_MASK;\r\nswitch (round_mode) {\r\ndefault:\r\ncase TRIG_ROUND_NEAREST:\r\ndiv += (rem + (timebase / 2)) / timebase;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndiv += (rem + timebase - 1) / timebase;\r\nbreak;\r\n}\r\nreturn div > UINT_MAX ? UINT_MAX : (unsigned int)div;\r\n}\r\nstatic unsigned int pci230_choose_clk_count(uint64_t ns, unsigned int *count,\r\nunsigned int round_mode)\r\n{\r\nunsigned int clk_src, cnt;\r\nfor (clk_src = CLK_10MHZ;; clk_src++) {\r\ncnt = divide_ns(ns, pci230_timebase[clk_src], round_mode);\r\nif ((cnt <= 65536) || (clk_src == CLK_1KHZ))\r\nbreak;\r\n}\r\n*count = cnt;\r\nreturn clk_src;\r\n}\r\nstatic void pci230_ns_to_single_timer(unsigned int *ns, unsigned int round)\r\n{\r\nunsigned int count;\r\nunsigned int clk_src;\r\nclk_src = pci230_choose_clk_count(*ns, &count, round);\r\n*ns = count * pci230_timebase[clk_src];\r\nreturn;\r\n}\r\nstatic void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,\r\nunsigned int mode, uint64_t ns,\r\nunsigned int round)\r\n{\r\nunsigned int clk_src;\r\nunsigned int count;\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, mode);\r\nclk_src = pci230_choose_clk_count(ns, &count, round);\r\noutb(CLK_CONFIG(ct, clk_src), devpriv->iobase1 + PCI230_ZCLK_SCE);\r\nif (count >= 65536)\r\ncount = 0;\r\ni8254_write(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct, count);\r\n}\r\nstatic void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)\r\n{\r\ni8254_set_mode(devpriv->iobase1 + PCI230_Z2_CT_BASE, 0, ct,\r\nI8254_MODE1);\r\n}\r\nstatic irqreturn_t pci230_interrupt(int irq, void *d)\r\n{\r\nunsigned char status_int, valid_status_int;\r\nstruct comedi_device *dev = (struct comedi_device *)d;\r\nstruct comedi_subdevice *s;\r\nunsigned long irqflags;\r\nstatus_int = inb(devpriv->iobase1 + PCI230_INT_STAT);\r\nif (status_int == PCI230_INT_DISABLE)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\nvalid_status_int = devpriv->int_en & status_int;\r\ndevpriv->ier = devpriv->int_en & ~status_int;\r\noutb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);\r\ndevpriv->intr_running = 1;\r\ndevpriv->intr_cpuid = THISCPU;\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nif ((valid_status_int & PCI230_INT_ZCLK_CT1) != 0) {\r\ns = dev->write_subdev;\r\npci230_handle_ao_nofifo(dev, s);\r\ncomedi_event(dev, s);\r\n}\r\nif ((valid_status_int & PCI230P2_INT_DAC) != 0) {\r\ns = dev->write_subdev;\r\npci230_handle_ao_fifo(dev, s);\r\ncomedi_event(dev, s);\r\n}\r\nif ((valid_status_int & PCI230_INT_ADC) != 0) {\r\ns = dev->read_subdev;\r\npci230_handle_ai(dev, s);\r\ncomedi_event(dev, s);\r\n}\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\nif (devpriv->ier != devpriv->int_en) {\r\ndevpriv->ier = devpriv->int_en;\r\noutb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);\r\n}\r\ndevpriv->intr_running = 0;\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pci230_handle_ao_nofifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nshort data;\r\nint i, ret;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nif (!devpriv->ao_continuous && (devpriv->ao_scan_count == 0))\r\nreturn;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nret = comedi_buf_get(s->async, &data);\r\nif (ret == 0) {\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\npci230_ao_stop(dev, s);\r\ncomedi_error(dev, "AO buffer underrun");\r\nreturn;\r\n}\r\npci230_ao_write_nofifo(dev, data, CR_CHAN(cmd->chanlist[i]));\r\n}\r\nasync->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;\r\nif (!devpriv->ao_continuous) {\r\ndevpriv->ao_scan_count--;\r\nif (devpriv->ao_scan_count == 0) {\r\nasync->events |= COMEDI_CB_EOA;\r\npci230_ao_stop(dev, s);\r\n}\r\n}\r\n}\r\nstatic int pci230_handle_ao_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int num_scans;\r\nunsigned int room;\r\nunsigned short dacstat;\r\nunsigned int i, n;\r\nunsigned int bytes_per_scan;\r\nunsigned int events = 0;\r\nint running;\r\ndacstat = inw(dev->iobase + PCI230_DACCON);\r\nbytes_per_scan = cmd->chanlist_len * sizeof(short);\r\nnum_scans = comedi_buf_read_n_available(async) / bytes_per_scan;\r\nif (!devpriv->ao_continuous) {\r\nif (num_scans > devpriv->ao_scan_count)\r\nnum_scans = devpriv->ao_scan_count;\r\nif (devpriv->ao_scan_count == 0) {\r\nevents |= COMEDI_CB_EOA;\r\n}\r\n}\r\nif (events == 0) {\r\nif ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {\r\ncomedi_error(dev, "AO FIFO underrun");\r\nevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\r\n}\r\nif ((num_scans == 0)\r\n&& ((dacstat & PCI230P2_DAC_FIFO_HALF) == 0)) {\r\ncomedi_error(dev, "AO buffer underrun");\r\nevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\r\n}\r\n}\r\nif (events == 0) {\r\nif ((dacstat & PCI230P2_DAC_FIFO_FULL) != 0)\r\nroom = PCI230P2_DAC_FIFOROOM_FULL;\r\nelse if ((dacstat & PCI230P2_DAC_FIFO_HALF) != 0)\r\nroom = PCI230P2_DAC_FIFOROOM_HALFTOFULL;\r\nelse if ((dacstat & PCI230P2_DAC_FIFO_EMPTY) != 0)\r\nroom = PCI230P2_DAC_FIFOROOM_EMPTY;\r\nelse\r\nroom = PCI230P2_DAC_FIFOROOM_ONETOHALF;\r\nroom /= cmd->chanlist_len;\r\nif (num_scans > room)\r\nnum_scans = room;\r\nfor (n = 0; n < num_scans; n++) {\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nshort datum;\r\ncomedi_buf_get(async, &datum);\r\npci230_ao_write_fifo(dev, datum,\r\nCR_CHAN(cmd->chanlist[i]));\r\n}\r\n}\r\nevents |= COMEDI_CB_EOS | COMEDI_CB_BLOCK;\r\nif (!devpriv->ao_continuous) {\r\ndevpriv->ao_scan_count -= num_scans;\r\nif (devpriv->ao_scan_count == 0) {\r\ndevpriv->daccon = (devpriv->daccon\r\n&\r\n~PCI230P2_DAC_INT_FIFO_MASK)\r\n| PCI230P2_DAC_INT_FIFO_EMPTY;\r\noutw(devpriv->daccon,\r\ndev->iobase + PCI230_DACCON);\r\n}\r\n}\r\ndacstat = inw(dev->iobase + PCI230_DACCON);\r\nif ((dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) != 0) {\r\ncomedi_error(dev, "AO FIFO underrun");\r\nevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\r\n}\r\n}\r\nif ((events & (COMEDI_CB_EOA | COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW))\r\n!= 0) {\r\npci230_ao_stop(dev, s);\r\nrunning = 0;\r\n} else {\r\nrunning = 1;\r\n}\r\nasync->events |= events;\r\nreturn running;\r\n}\r\nstatic void pci230_handle_ai(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int events = 0;\r\nunsigned int status_fifo;\r\nunsigned int i;\r\nunsigned int todo;\r\nunsigned int fifoamount;\r\nstruct comedi_async *async = s->async;\r\nunsigned int scanlen = async->cmd.scan_end_arg;\r\nif (devpriv->ai_continuous) {\r\ntodo = PCI230_ADC_FIFOLEVEL_HALFFULL;\r\n} else if (devpriv->ai_scan_count == 0) {\r\ntodo = 0;\r\n} else if ((devpriv->ai_scan_count > PCI230_ADC_FIFOLEVEL_HALFFULL)\r\n|| (scanlen > PCI230_ADC_FIFOLEVEL_HALFFULL)) {\r\ntodo = PCI230_ADC_FIFOLEVEL_HALFFULL;\r\n} else {\r\ntodo = (devpriv->ai_scan_count * scanlen)\r\n- devpriv->ai_scan_pos;\r\nif (todo > PCI230_ADC_FIFOLEVEL_HALFFULL)\r\ntodo = PCI230_ADC_FIFOLEVEL_HALFFULL;\r\n}\r\nif (todo == 0)\r\nreturn;\r\nfifoamount = 0;\r\nfor (i = 0; i < todo; i++) {\r\nif (fifoamount == 0) {\r\nstatus_fifo = inw(dev->iobase + PCI230_ADCCON);\r\nif ((status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) != 0) {\r\ncomedi_error(dev, "AI FIFO overrun");\r\nevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\r\nbreak;\r\n} else if ((status_fifo & PCI230_ADC_FIFO_EMPTY) != 0) {\r\nbreak;\r\n} else if ((status_fifo & PCI230_ADC_FIFO_HALF) != 0) {\r\nfifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;\r\n} else {\r\nif (devpriv->hwver > 0) {\r\nfifoamount = inw(dev->iobase\r\n+ PCI230P_ADCFFLEV);\r\nif (fifoamount == 0) {\r\nbreak;\r\n}\r\n} else {\r\nfifoamount = 1;\r\n}\r\n}\r\n}\r\nif (comedi_buf_put(async, pci230_ai_read(dev)) == 0) {\r\nevents |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;\r\ncomedi_error(dev, "AI buffer overflow");\r\nbreak;\r\n}\r\nfifoamount--;\r\ndevpriv->ai_scan_pos++;\r\nif (devpriv->ai_scan_pos == scanlen) {\r\ndevpriv->ai_scan_pos = 0;\r\ndevpriv->ai_scan_count--;\r\nasync->events |= COMEDI_CB_EOS;\r\n}\r\n}\r\nif (!devpriv->ai_continuous && (devpriv->ai_scan_count == 0)) {\r\nevents |= COMEDI_CB_EOA;\r\n} else {\r\nevents |= COMEDI_CB_BLOCK;\r\n}\r\nasync->events |= events;\r\nif ((async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |\r\nCOMEDI_CB_OVERFLOW)) != 0) {\r\npci230_ai_stop(dev, s);\r\n} else {\r\npci230_ai_update_fifo_trigger_level(dev, s);\r\n}\r\n}\r\nstatic void pci230_ao_stop(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long irqflags;\r\nunsigned char intsrc;\r\nint started;\r\nstruct comedi_cmd *cmd;\r\nspin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);\r\nstarted = test_and_clear_bit(AO_CMD_STARTED, &devpriv->state);\r\nspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\r\nif (!started)\r\nreturn;\r\ncmd = &s->async->cmd;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\npci230_cancel_ct(dev, 1);\r\n}\r\nif (devpriv->hwver < 2) {\r\nintsrc = PCI230_INT_ZCLK_CT1;\r\n} else {\r\nintsrc = PCI230P2_INT_DAC;\r\n}\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->int_en &= ~intsrc;\r\nwhile (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\n}\r\nif (devpriv->ier != devpriv->int_en) {\r\ndevpriv->ier = devpriv->int_en;\r\noutb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);\r\n}\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nif (devpriv->hwver >= 2) {\r\ndevpriv->daccon &= PCI230_DAC_OR_MASK;\r\noutw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET\r\n| PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,\r\ndev->iobase + PCI230_DACCON);\r\n}\r\nput_all_resources(dev, OWNER_AOCMD);\r\n}\r\nstatic int pci230_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\npci230_ao_stop(dev, s);\r\nreturn 0;\r\n}\r\nstatic void pci230_ai_stop(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long irqflags;\r\nstruct comedi_cmd *cmd;\r\nint started;\r\nspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\r\nstarted = test_and_clear_bit(AI_CMD_STARTED, &devpriv->state);\r\nspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\r\nif (!started)\r\nreturn;\r\ncmd = &s->async->cmd;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\npci230_cancel_ct(dev, 2);\r\n}\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\npci230_cancel_ct(dev, 0);\r\n}\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->int_en &= ~PCI230_INT_ADC;\r\nwhile (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\nspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\r\n}\r\nif (devpriv->ier != devpriv->int_en) {\r\ndevpriv->ier = devpriv->int_en;\r\noutb(devpriv->ier, devpriv->iobase1 + PCI230_INT_SCE);\r\n}\r\nspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\r\ndevpriv->adccon = (devpriv->adccon & (PCI230_ADC_IR_MASK\r\n| PCI230_ADC_IM_MASK)) |\r\nPCI230_ADC_TRIG_NONE;\r\noutw(devpriv->adccon | PCI230_ADC_FIFO_RESET,\r\ndev->iobase + PCI230_ADCCON);\r\nput_all_resources(dev, OWNER_AICMD);\r\n}\r\nstatic int pci230_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\npci230_ai_stop(dev, s);\r\nreturn 0;\r\n}
