static int mrst_device_ident(struct drm_device *dev)\r\n{\r\nif (devtype)\r\nreturn devtype;\r\nif (dmi_match(DMI_PRODUCT_NAME, "OakTrail") ||\r\ndmi_match(DMI_PRODUCT_NAME, "OakTrail platform"))\r\nreturn DEVICE_OAKTRAIL;\r\n#if defined(CONFIG_X86_MRST)\r\nif (dmi_match(DMI_PRODUCT_NAME, "MM") ||\r\ndmi_match(DMI_PRODUCT_NAME, "MM 10"))\r\nreturn DEVICE_MOORESTOWN_MM;\r\nif (mrst_identify_cpu())\r\nreturn DEVICE_MOORESTOWN;\r\n#endif\r\nreturn DEVICE_OAKTRAIL;\r\n}\r\nstatic int mrst_output_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (dev_priv->iLVDS_enable)\r\nmrst_lvds_init(dev, &dev_priv->mode_dev);\r\nelse\r\ndev_err(dev->dev, "DSI is not supported\n");\r\nif (dev_priv->hdmi_priv)\r\nmrst_hdmi_init(dev, &dev_priv->mode_dev);\r\nreturn 0;\r\n}\r\nstatic int mrst_set_brightness(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(mrst_backlight_device);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint level = bd->props.brightness;\r\nu32 blc_pwm_ctl;\r\nu32 max_pwm_blc;\r\nif (level < 1)\r\nlevel = 1;\r\nif (gma_power_begin(dev, 0)) {\r\nmax_pwm_blc = REG_READ(BLC_PWM_CTL) >> 16;\r\nblc_pwm_ctl = level * max_pwm_blc / 100;\r\nblc_pwm_ctl = blc_pwm_ctl * dev_priv->blc_adj1;\r\nblc_pwm_ctl = blc_pwm_ctl / 100;\r\nblc_pwm_ctl = blc_pwm_ctl * dev_priv->blc_adj2;\r\nblc_pwm_ctl = blc_pwm_ctl / 100;\r\nREG_WRITE(BLC_PWM_CTL2, (0x80000000 | REG_READ(BLC_PWM_CTL2)));\r\nREG_WRITE(BLC_PWM_CTL, (max_pwm_blc << 16) | blc_pwm_ctl);\r\ngma_power_end(dev);\r\n}\r\nmrst_brightness = level;\r\nreturn 0;\r\n}\r\nstatic int mrst_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn mrst_brightness;\r\n}\r\nstatic int device_backlight_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long core_clock;\r\nu16 bl_max_freq;\r\nuint32_t value;\r\nuint32_t blc_pwm_precision_factor;\r\ndev_priv->blc_adj1 = BLC_ADJUSTMENT_MAX;\r\ndev_priv->blc_adj2 = BLC_ADJUSTMENT_MAX;\r\nbl_max_freq = 256;\r\nblc_pwm_precision_factor = BLC_PWM_PRECISION_FACTOR;\r\ncore_clock = dev_priv->core_freq;\r\nvalue = (core_clock * MHz) / BLC_PWM_FREQ_CALC_CONSTANT;\r\nvalue *= blc_pwm_precision_factor;\r\nvalue /= bl_max_freq;\r\nvalue /= blc_pwm_precision_factor;\r\nif (value > (unsigned long long)MRST_BLC_MAX_PWM_REG_FREQ)\r\nreturn -ERANGE;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE(BLC_PWM_CTL2, (0x80000000 | REG_READ(BLC_PWM_CTL2)));\r\nREG_WRITE(BLC_PWM_CTL, value | (value << 16));\r\ngma_power_end(dev);\r\n}\r\nreturn 0;\r\n}\r\nint mrst_backlight_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint ret;\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = 100;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nmrst_backlight_device = backlight_device_register("mrst-bl",\r\nNULL, (void *)dev, &mrst_ops, &props);\r\nif (IS_ERR(mrst_backlight_device))\r\nreturn PTR_ERR(mrst_backlight_device);\r\nret = device_backlight_init(dev);\r\nif (ret < 0) {\r\nbacklight_device_unregister(mrst_backlight_device);\r\nreturn ret;\r\n}\r\nmrst_backlight_device->props.brightness = 100;\r\nmrst_backlight_device->props.max_brightness = 100;\r\nbacklight_update_status(mrst_backlight_device);\r\ndev_priv->backlight_device = mrst_backlight_device;\r\nreturn 0;\r\n}\r\nstatic void mrst_init_pm(struct drm_device *dev)\r\n{\r\n}\r\nstatic int mrst_save_display_registers(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint i;\r\nu32 pp_stat;\r\ndev_priv->saveDSPARB = PSB_RVDC32(DSPARB);\r\ndev_priv->saveDSPFW1 = PSB_RVDC32(DSPFW1);\r\ndev_priv->saveDSPFW2 = PSB_RVDC32(DSPFW2);\r\ndev_priv->saveDSPFW3 = PSB_RVDC32(DSPFW3);\r\ndev_priv->saveDSPFW4 = PSB_RVDC32(DSPFW4);\r\ndev_priv->saveDSPFW5 = PSB_RVDC32(DSPFW5);\r\ndev_priv->saveDSPFW6 = PSB_RVDC32(DSPFW6);\r\ndev_priv->saveCHICKENBIT = PSB_RVDC32(DSPCHICKENBIT);\r\ndev_priv->savePIPEACONF = PSB_RVDC32(PIPEACONF);\r\ndev_priv->savePIPEASRC = PSB_RVDC32(PIPEASRC);\r\ndev_priv->saveFPA0 = PSB_RVDC32(MRST_FPA0);\r\ndev_priv->saveFPA1 = PSB_RVDC32(MRST_FPA1);\r\ndev_priv->saveDPLL_A = PSB_RVDC32(MRST_DPLL_A);\r\ndev_priv->saveHTOTAL_A = PSB_RVDC32(HTOTAL_A);\r\ndev_priv->saveHBLANK_A = PSB_RVDC32(HBLANK_A);\r\ndev_priv->saveHSYNC_A = PSB_RVDC32(HSYNC_A);\r\ndev_priv->saveVTOTAL_A = PSB_RVDC32(VTOTAL_A);\r\ndev_priv->saveVBLANK_A = PSB_RVDC32(VBLANK_A);\r\ndev_priv->saveVSYNC_A = PSB_RVDC32(VSYNC_A);\r\ndev_priv->saveBCLRPAT_A = PSB_RVDC32(BCLRPAT_A);\r\ndev_priv->saveDSPACNTR = PSB_RVDC32(DSPACNTR);\r\ndev_priv->saveDSPASTRIDE = PSB_RVDC32(DSPASTRIDE);\r\ndev_priv->saveDSPAADDR = PSB_RVDC32(DSPABASE);\r\ndev_priv->saveDSPASURF = PSB_RVDC32(DSPASURF);\r\ndev_priv->saveDSPALINOFF = PSB_RVDC32(DSPALINOFF);\r\ndev_priv->saveDSPATILEOFF = PSB_RVDC32(DSPATILEOFF);\r\ndev_priv->saveDSPACURSOR_CTRL = PSB_RVDC32(CURACNTR);\r\ndev_priv->saveDSPACURSOR_BASE = PSB_RVDC32(CURABASE);\r\ndev_priv->saveDSPACURSOR_POS = PSB_RVDC32(CURAPOS);\r\nfor (i = 0; i < 256; i++)\r\ndev_priv->save_palette_a[i] = PSB_RVDC32(PALETTE_A + (i << 2));\r\nif (dev_priv->hdmi_priv)\r\nmrst_hdmi_save(dev);\r\ndev_priv->savePERF_MODE = PSB_RVDC32(MRST_PERF_MODE);\r\ndev_priv->savePP_CONTROL = PSB_RVDC32(PP_CONTROL);\r\ndev_priv->savePFIT_PGM_RATIOS = PSB_RVDC32(PFIT_PGM_RATIOS);\r\ndev_priv->savePFIT_AUTO_RATIOS = PSB_RVDC32(PFIT_AUTO_RATIOS);\r\ndev_priv->saveBLC_PWM_CTL = PSB_RVDC32(BLC_PWM_CTL);\r\ndev_priv->saveBLC_PWM_CTL2 = PSB_RVDC32(BLC_PWM_CTL2);\r\ndev_priv->saveLVDS = PSB_RVDC32(LVDS);\r\ndev_priv->savePFIT_CONTROL = PSB_RVDC32(PFIT_CONTROL);\r\ndev_priv->savePP_ON_DELAYS = PSB_RVDC32(LVDSPP_ON);\r\ndev_priv->savePP_OFF_DELAYS = PSB_RVDC32(LVDSPP_OFF);\r\ndev_priv->savePP_DIVISOR = PSB_RVDC32(PP_CYCLE);\r\ndev_priv->saveOV_OVADD = PSB_RVDC32(OV_OVADD);\r\ndev_priv->saveOV_OGAMC0 = PSB_RVDC32(OV_OGAMC0);\r\ndev_priv->saveOV_OGAMC1 = PSB_RVDC32(OV_OGAMC1);\r\ndev_priv->saveOV_OGAMC2 = PSB_RVDC32(OV_OGAMC2);\r\ndev_priv->saveOV_OGAMC3 = PSB_RVDC32(OV_OGAMC3);\r\ndev_priv->saveOV_OGAMC4 = PSB_RVDC32(OV_OGAMC4);\r\ndev_priv->saveOV_OGAMC5 = PSB_RVDC32(OV_OGAMC5);\r\ndev_priv->saveHISTOGRAM_INT_CONTROL_REG =\r\nPSB_RVDC32(HISTOGRAM_INT_CONTROL);\r\ndev_priv->saveHISTOGRAM_LOGIC_CONTROL_REG =\r\nPSB_RVDC32(HISTOGRAM_LOGIC_CONTROL);\r\ndev_priv->savePWM_CONTROL_LOGIC = PSB_RVDC32(PWM_CONTROL_LOGIC);\r\nif (dev_priv->iLVDS_enable) {\r\nPSB_WVDC32(0, PP_CONTROL);\r\ndo {\r\npp_stat = PSB_RVDC32(PP_STATUS);\r\n} while (pp_stat & 0x80000000);\r\nPSB_WVDC32(0x58000000, DSPACNTR);\r\nPSB_WVDC32(0, DSPASURF);\r\nmsleep(4);\r\nPSB_WVDC32(0x0, PIPEACONF);\r\nmsleep(8);\r\nPSB_WVDC32(0, MRST_DPLL_A);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mrst_restore_display_registers(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pp_stat;\r\nint i;\r\nPSB_WVDC32(dev_priv->saveDSPARB, DSPARB);\r\nPSB_WVDC32(dev_priv->saveDSPFW1, DSPFW1);\r\nPSB_WVDC32(dev_priv->saveDSPFW2, DSPFW2);\r\nPSB_WVDC32(dev_priv->saveDSPFW3, DSPFW3);\r\nPSB_WVDC32(dev_priv->saveDSPFW4, DSPFW4);\r\nPSB_WVDC32(dev_priv->saveDSPFW5, DSPFW5);\r\nPSB_WVDC32(dev_priv->saveDSPFW6, DSPFW6);\r\nPSB_WVDC32(dev_priv->saveCHICKENBIT, DSPCHICKENBIT);\r\nPSB_WVDC32(0x80000000, VGACNTRL);\r\nPSB_WVDC32(dev_priv->saveFPA0, MRST_FPA0);\r\nPSB_WVDC32(dev_priv->saveFPA1, MRST_FPA1);\r\nPSB_WVDC32(dev_priv->saveDPLL_A, MRST_DPLL_A);\r\nDRM_UDELAY(150);\r\nPSB_WVDC32(dev_priv->saveHTOTAL_A, HTOTAL_A);\r\nPSB_WVDC32(dev_priv->saveHBLANK_A, HBLANK_A);\r\nPSB_WVDC32(dev_priv->saveHSYNC_A, HSYNC_A);\r\nPSB_WVDC32(dev_priv->saveVTOTAL_A, VTOTAL_A);\r\nPSB_WVDC32(dev_priv->saveVBLANK_A, VBLANK_A);\r\nPSB_WVDC32(dev_priv->saveVSYNC_A, VSYNC_A);\r\nPSB_WVDC32(dev_priv->savePIPEASRC, PIPEASRC);\r\nPSB_WVDC32(dev_priv->saveBCLRPAT_A, BCLRPAT_A);\r\nPSB_WVDC32(dev_priv->savePERF_MODE, MRST_PERF_MODE);\r\nif (dev_priv->iLVDS_enable)\r\nPSB_WVDC32(dev_priv->savePIPEACONF, PIPEACONF);\r\nPSB_WVDC32(dev_priv->saveDSPALINOFF, DSPALINOFF);\r\nPSB_WVDC32(dev_priv->saveDSPASTRIDE, DSPASTRIDE);\r\nPSB_WVDC32(dev_priv->saveDSPATILEOFF, DSPATILEOFF);\r\nPSB_WVDC32(dev_priv->saveDSPACNTR, DSPACNTR);\r\nPSB_WVDC32(dev_priv->saveDSPASURF, DSPASURF);\r\nPSB_WVDC32(dev_priv->saveDSPACURSOR_CTRL, CURACNTR);\r\nPSB_WVDC32(dev_priv->saveDSPACURSOR_POS, CURAPOS);\r\nPSB_WVDC32(dev_priv->saveDSPACURSOR_BASE, CURABASE);\r\nfor (i = 0; i < 256; i++)\r\nPSB_WVDC32(dev_priv->save_palette_a[i], PALETTE_A + (i << 2));\r\nif (dev_priv->hdmi_priv)\r\nmrst_hdmi_restore(dev);\r\nif (dev_priv->iLVDS_enable) {\r\nPSB_WVDC32(dev_priv->saveBLC_PWM_CTL2, BLC_PWM_CTL2);\r\nPSB_WVDC32(dev_priv->saveLVDS, LVDS);\r\nPSB_WVDC32(dev_priv->savePFIT_CONTROL, PFIT_CONTROL);\r\nPSB_WVDC32(dev_priv->savePFIT_PGM_RATIOS, PFIT_PGM_RATIOS);\r\nPSB_WVDC32(dev_priv->savePFIT_AUTO_RATIOS, PFIT_AUTO_RATIOS);\r\nPSB_WVDC32(dev_priv->saveBLC_PWM_CTL, BLC_PWM_CTL);\r\nPSB_WVDC32(dev_priv->savePP_ON_DELAYS, LVDSPP_ON);\r\nPSB_WVDC32(dev_priv->savePP_OFF_DELAYS, LVDSPP_OFF);\r\nPSB_WVDC32(dev_priv->savePP_DIVISOR, PP_CYCLE);\r\nPSB_WVDC32(dev_priv->savePP_CONTROL, PP_CONTROL);\r\n}\r\ndo {\r\npp_stat = PSB_RVDC32(PP_STATUS);\r\n} while (pp_stat & 0x08000000);\r\ndo {\r\npp_stat = PSB_RVDC32(PP_STATUS);\r\n} while (pp_stat & 0x10000000);\r\nPSB_WVDC32(dev_priv->saveOV_OVADD, OV_OVADD);\r\nPSB_WVDC32(dev_priv->saveOV_OGAMC0, OV_OGAMC0);\r\nPSB_WVDC32(dev_priv->saveOV_OGAMC1, OV_OGAMC1);\r\nPSB_WVDC32(dev_priv->saveOV_OGAMC2, OV_OGAMC2);\r\nPSB_WVDC32(dev_priv->saveOV_OGAMC3, OV_OGAMC3);\r\nPSB_WVDC32(dev_priv->saveOV_OGAMC4, OV_OGAMC4);\r\nPSB_WVDC32(dev_priv->saveOV_OGAMC5, OV_OGAMC5);\r\nPSB_WVDC32(dev_priv->saveHISTOGRAM_INT_CONTROL_REG,\r\nHISTOGRAM_INT_CONTROL);\r\nPSB_WVDC32(dev_priv->saveHISTOGRAM_LOGIC_CONTROL_REG,\r\nHISTOGRAM_LOGIC_CONTROL);\r\nPSB_WVDC32(dev_priv->savePWM_CONTROL_LOGIC, PWM_CONTROL_LOGIC);\r\nreturn 0;\r\n}\r\nstatic int mrst_power_down(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pwr_mask ;\r\nu32 pwr_sts;\r\npwr_mask = PSB_PWRGT_DISPLAY_MASK;\r\noutl(pwr_mask, dev_priv->ospm_base + PSB_PM_SSC);\r\nwhile (true) {\r\npwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);\r\nif ((pwr_sts & pwr_mask) == pwr_mask)\r\nbreak;\r\nelse\r\nudelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mrst_power_up(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pwr_mask = PSB_PWRGT_DISPLAY_MASK;\r\nu32 pwr_sts, pwr_cnt;\r\npwr_cnt = inl(dev_priv->ospm_base + PSB_PM_SSC);\r\npwr_cnt &= ~pwr_mask;\r\noutl(pwr_cnt, (dev_priv->ospm_base + PSB_PM_SSC));\r\nwhile (true) {\r\npwr_sts = inl(dev_priv->ospm_base + PSB_PM_SSS);\r\nif ((pwr_sts & pwr_mask) == 0)\r\nbreak;\r\nelse\r\nudelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mrst_lvds_cache_bl(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nintel_scu_ipc_ioread8(0x28, &(dev_priv->saveBKLTCNT));\r\nintel_scu_ipc_ioread8(0x29, &(dev_priv->saveBKLTREQ));\r\nintel_scu_ipc_ioread8(0x2A, &(dev_priv->saveBKLTBRTL));\r\n}\r\nstatic void mrst_mm_bl_power(struct drm_device *dev, bool on)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (on) {\r\nintel_scu_ipc_iowrite8(0x2A, dev_priv->saveBKLTBRTL);\r\nintel_scu_ipc_iowrite8(0x28, dev_priv->saveBKLTCNT);\r\nintel_scu_ipc_iowrite8(0x29, dev_priv->saveBKLTREQ);\r\n} else {\r\nintel_scu_ipc_iowrite8(0x2A, 0);\r\nintel_scu_ipc_iowrite8(0x28, 0);\r\nintel_scu_ipc_iowrite8(0x29, 0);\r\n}\r\n}\r\nstatic void oaktrail_teardown(struct drm_device *dev)\r\n{\r\nmrst_hdmi_teardown(dev);\r\n}\r\nstatic int mrst_chip_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nswitch (mrst_device_ident(dev)) {\r\ncase DEVICE_OAKTRAIL:\r\ndev_priv->ops = &oaktrail_chip_ops;\r\nmrst_hdmi_setup(dev);\r\nreturn mid_chip_setup(dev);\r\n#if defined(CONFIG_X86_MRST)\r\ncase DEVICE_MOORESTOWN_MM:\r\nmrst_lvds_cache_bl(dev);\r\ndev_priv->ops = &mrst_mm_chip_ops;\r\nreturn mid_chip_setup(dev);\r\ncase DEVICE_MOORESTOWN:\r\nreturn mid_chip_setup(dev);\r\n#endif\r\ndefault:\r\ndev_err(dev->dev, "unsupported device type.\n");\r\nreturn -ENODEV;\r\n}\r\n}
