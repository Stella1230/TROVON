void\r\nefi_gettimeofday (struct timespec *ts)\r\n{\r\nefi_time_t tm;\r\nif ((*efi.get_time)(&tm, NULL) != EFI_SUCCESS) {\r\nmemset(ts, 0, sizeof(*ts));\r\nreturn;\r\n}\r\nts->tv_sec = mktime(tm.year, tm.month, tm.day,\r\ntm.hour, tm.minute, tm.second);\r\nts->tv_nsec = tm.nanosecond;\r\n}\r\nstatic int\r\nis_memory_available (efi_memory_desc_t *md)\r\n{\r\nif (!(md->attribute & EFI_MEMORY_WB))\r\nreturn 0;\r\nswitch (md->type) {\r\ncase EFI_LOADER_CODE:\r\ncase EFI_LOADER_DATA:\r\ncase EFI_BOOT_SERVICES_CODE:\r\ncase EFI_BOOT_SERVICES_DATA:\r\ncase EFI_CONVENTIONAL_MEMORY:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u64\r\nkmd_end(kern_memdesc_t *kmd)\r\n{\r\nreturn (kmd->start + (kmd->num_pages << EFI_PAGE_SHIFT));\r\n}\r\nstatic inline u64\r\nefi_md_end(efi_memory_desc_t *md)\r\n{\r\nreturn (md->phys_addr + efi_md_size(md));\r\n}\r\nstatic inline int\r\nefi_wb(efi_memory_desc_t *md)\r\n{\r\nreturn (md->attribute & EFI_MEMORY_WB);\r\n}\r\nstatic inline int\r\nefi_uc(efi_memory_desc_t *md)\r\n{\r\nreturn (md->attribute & EFI_MEMORY_UC);\r\n}\r\nstatic void\r\nwalk (efi_freemem_callback_t callback, void *arg, u64 attr)\r\n{\r\nkern_memdesc_t *k;\r\nu64 start, end, voff;\r\nvoff = (attr == EFI_MEMORY_WB) ? PAGE_OFFSET : __IA64_UNCACHED_OFFSET;\r\nfor (k = kern_memmap; k->start != ~0UL; k++) {\r\nif (k->attribute != attr)\r\ncontinue;\r\nstart = PAGE_ALIGN(k->start);\r\nend = (k->start + (k->num_pages << EFI_PAGE_SHIFT)) & PAGE_MASK;\r\nif (start < end)\r\nif ((*callback)(start + voff, end + voff, arg) < 0)\r\nreturn;\r\n}\r\n}\r\nvoid\r\nefi_memmap_walk (efi_freemem_callback_t callback, void *arg)\r\n{\r\nwalk(callback, arg, EFI_MEMORY_WB);\r\n}\r\nvoid\r\nefi_memmap_walk_uc (efi_freemem_callback_t callback, void *arg)\r\n{\r\nwalk(callback, arg, EFI_MEMORY_UC);\r\n}\r\nvoid *\r\nefi_get_pal_addr (void)\r\n{\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nu64 efi_desc_size;\r\nint pal_code_count = 0;\r\nu64 vaddr, mask;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (md->type != EFI_PAL_CODE)\r\ncontinue;\r\nif (++pal_code_count > 1) {\r\nprintk(KERN_ERR "Too many EFI Pal Code memory ranges, "\r\n"dropped @ %llx\n", md->phys_addr);\r\ncontinue;\r\n}\r\nmask = ~((1 << KERNEL_TR_PAGE_SHIFT) - 1);\r\nvaddr = PAGE_OFFSET + md->phys_addr;\r\nif ((vaddr & mask) == (KERNEL_START & mask)) {\r\nprintk(KERN_INFO "%s: no need to install ITR for PAL code\n",\r\n__func__);\r\ncontinue;\r\n}\r\nif (efi_md_size(md) > IA64_GRANULE_SIZE)\r\npanic("Whoa! PAL code size bigger than a granule!");\r\n#if EFI_DEBUG\r\nmask = ~((1 << IA64_GRANULE_SHIFT) - 1);\r\nprintk(KERN_INFO "CPU %d: mapping PAL code "\r\n"[0x%lx-0x%lx) into [0x%lx-0x%lx)\n",\r\nsmp_processor_id(), md->phys_addr,\r\nmd->phys_addr + efi_md_size(md),\r\nvaddr & mask, (vaddr & mask) + IA64_GRANULE_SIZE);\r\n#endif\r\nreturn __va(md->phys_addr);\r\n}\r\nprintk(KERN_WARNING "%s: no PAL-code memory-descriptor found\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nstatic u8 __init palo_checksum(u8 *buffer, u32 length)\r\n{\r\nu8 sum = 0;\r\nu8 *end = buffer + length;\r\nwhile (buffer < end)\r\nsum = (u8) (sum + *(buffer++));\r\nreturn sum;\r\n}\r\nstatic void __init handle_palo(unsigned long palo_phys)\r\n{\r\nstruct palo_table *palo = __va(palo_phys);\r\nu8 checksum;\r\nif (strncmp(palo->signature, PALO_SIG, sizeof(PALO_SIG) - 1)) {\r\nprintk(KERN_INFO "PALO signature incorrect.\n");\r\nreturn;\r\n}\r\nchecksum = palo_checksum((u8 *)palo, palo->length);\r\nif (checksum) {\r\nprintk(KERN_INFO "PALO checksum incorrect.\n");\r\nreturn;\r\n}\r\nsetup_ptcg_sem(palo->max_tlb_purges, NPTCG_FROM_PALO);\r\n}\r\nvoid\r\nefi_map_pal_code (void)\r\n{\r\nvoid *pal_vaddr = efi_get_pal_addr ();\r\nu64 psr;\r\nif (!pal_vaddr)\r\nreturn;\r\npsr = ia64_clear_ic();\r\nia64_itr(0x1, IA64_TR_PALCODE,\r\nGRANULEROUNDDOWN((unsigned long) pal_vaddr),\r\npte_val(pfn_pte(__pa(pal_vaddr) >> PAGE_SHIFT, PAGE_KERNEL)),\r\nIA64_GRANULE_SHIFT);\r\nparavirt_dv_serialize_data();\r\nia64_set_psr(psr);\r\n}\r\nvoid __init\r\nefi_init (void)\r\n{\r\nvoid *efi_map_start, *efi_map_end;\r\nefi_config_table_t *config_tables;\r\nefi_char16_t *c16;\r\nu64 efi_desc_size;\r\nchar *cp, vendor[100] = "unknown";\r\nint i;\r\nunsigned long palo_phys;\r\nfor (cp = boot_command_line; *cp; ) {\r\nif (memcmp(cp, "mem=", 4) == 0) {\r\nmem_limit = memparse(cp + 4, &cp);\r\n} else if (memcmp(cp, "max_addr=", 9) == 0) {\r\nmax_addr = GRANULEROUNDDOWN(memparse(cp + 9, &cp));\r\n} else if (memcmp(cp, "min_addr=", 9) == 0) {\r\nmin_addr = GRANULEROUNDDOWN(memparse(cp + 9, &cp));\r\n} else {\r\nwhile (*cp != ' ' && *cp)\r\n++cp;\r\nwhile (*cp == ' ')\r\n++cp;\r\n}\r\n}\r\nif (min_addr != 0UL)\r\nprintk(KERN_INFO "Ignoring memory below %lluMB\n",\r\nmin_addr >> 20);\r\nif (max_addr != ~0UL)\r\nprintk(KERN_INFO "Ignoring memory above %lluMB\n",\r\nmax_addr >> 20);\r\nefi.systab = __va(ia64_boot_param->efi_systab);\r\nif (efi.systab == NULL)\r\npanic("Whoa! Can't find EFI system table.\n");\r\nif (efi.systab->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\npanic("Whoa! EFI system table signature incorrect\n");\r\nif ((efi.systab->hdr.revision >> 16) == 0)\r\nprintk(KERN_WARNING "Warning: EFI system table version "\r\n"%d.%02d, expected 1.00 or greater\n",\r\nefi.systab->hdr.revision >> 16,\r\nefi.systab->hdr.revision & 0xffff);\r\nconfig_tables = __va(efi.systab->tables);\r\nc16 = __va(efi.systab->fw_vendor);\r\nif (c16) {\r\nfor (i = 0;i < (int) sizeof(vendor) - 1 && *c16; ++i)\r\nvendor[i] = *c16++;\r\nvendor[i] = '\0';\r\n}\r\nprintk(KERN_INFO "EFI v%u.%.02u by %s:",\r\nefi.systab->hdr.revision >> 16,\r\nefi.systab->hdr.revision & 0xffff, vendor);\r\nefi.mps = EFI_INVALID_TABLE_ADDR;\r\nefi.acpi = EFI_INVALID_TABLE_ADDR;\r\nefi.acpi20 = EFI_INVALID_TABLE_ADDR;\r\nefi.smbios = EFI_INVALID_TABLE_ADDR;\r\nefi.sal_systab = EFI_INVALID_TABLE_ADDR;\r\nefi.boot_info = EFI_INVALID_TABLE_ADDR;\r\nefi.hcdp = EFI_INVALID_TABLE_ADDR;\r\nefi.uga = EFI_INVALID_TABLE_ADDR;\r\npalo_phys = EFI_INVALID_TABLE_ADDR;\r\nfor (i = 0; i < (int) efi.systab->nr_tables; i++) {\r\nif (efi_guidcmp(config_tables[i].guid, MPS_TABLE_GUID) == 0) {\r\nefi.mps = config_tables[i].table;\r\nprintk(" MPS=0x%lx", config_tables[i].table);\r\n} else if (efi_guidcmp(config_tables[i].guid, ACPI_20_TABLE_GUID) == 0) {\r\nefi.acpi20 = config_tables[i].table;\r\nprintk(" ACPI 2.0=0x%lx", config_tables[i].table);\r\n} else if (efi_guidcmp(config_tables[i].guid, ACPI_TABLE_GUID) == 0) {\r\nefi.acpi = config_tables[i].table;\r\nprintk(" ACPI=0x%lx", config_tables[i].table);\r\n} else if (efi_guidcmp(config_tables[i].guid, SMBIOS_TABLE_GUID) == 0) {\r\nefi.smbios = config_tables[i].table;\r\nprintk(" SMBIOS=0x%lx", config_tables[i].table);\r\n} else if (efi_guidcmp(config_tables[i].guid, SAL_SYSTEM_TABLE_GUID) == 0) {\r\nefi.sal_systab = config_tables[i].table;\r\nprintk(" SALsystab=0x%lx", config_tables[i].table);\r\n} else if (efi_guidcmp(config_tables[i].guid, HCDP_TABLE_GUID) == 0) {\r\nefi.hcdp = config_tables[i].table;\r\nprintk(" HCDP=0x%lx", config_tables[i].table);\r\n} else if (efi_guidcmp(config_tables[i].guid,\r\nPROCESSOR_ABSTRACTION_LAYER_OVERWRITE_GUID) == 0) {\r\npalo_phys = config_tables[i].table;\r\nprintk(" PALO=0x%lx", config_tables[i].table);\r\n}\r\n}\r\nprintk("\n");\r\nif (palo_phys != EFI_INVALID_TABLE_ADDR)\r\nhandle_palo(palo_phys);\r\nruntime = __va(efi.systab->runtime);\r\nefi.get_time = phys_get_time;\r\nefi.set_time = phys_set_time;\r\nefi.get_wakeup_time = phys_get_wakeup_time;\r\nefi.set_wakeup_time = phys_set_wakeup_time;\r\nefi.get_variable = phys_get_variable;\r\nefi.get_next_variable = phys_get_next_variable;\r\nefi.set_variable = phys_set_variable;\r\nefi.get_next_high_mono_count = phys_get_next_high_mono_count;\r\nefi.reset_system = phys_reset_system;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\n#if EFI_DEBUG\r\n{\r\nefi_memory_desc_t *md;\r\nvoid *p;\r\nfor (i = 0, p = efi_map_start; p < efi_map_end;\r\n++i, p += efi_desc_size)\r\n{\r\nconst char *unit;\r\nunsigned long size;\r\nmd = p;\r\nsize = md->num_pages << EFI_PAGE_SHIFT;\r\nif ((size >> 40) > 0) {\r\nsize >>= 40;\r\nunit = "TB";\r\n} else if ((size >> 30) > 0) {\r\nsize >>= 30;\r\nunit = "GB";\r\n} else if ((size >> 20) > 0) {\r\nsize >>= 20;\r\nunit = "MB";\r\n} else {\r\nsize >>= 10;\r\nunit = "KB";\r\n}\r\nprintk("mem%02d: type=%2u, attr=0x%016lx, "\r\n"range=[0x%016lx-0x%016lx) (%4lu%s)\n",\r\ni, md->type, md->attribute, md->phys_addr,\r\nmd->phys_addr + efi_md_size(md), size, unit);\r\n}\r\n}\r\n#endif\r\nefi_map_pal_code();\r\nefi_enter_virtual_mode();\r\n}\r\nvoid\r\nefi_enter_virtual_mode (void)\r\n{\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nefi_status_t status;\r\nu64 efi_desc_size;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (md->attribute & EFI_MEMORY_RUNTIME) {\r\nif (md->attribute & EFI_MEMORY_WB) {\r\nmd->virt_addr = (u64) __va(md->phys_addr);\r\n} else if (md->attribute & EFI_MEMORY_UC) {\r\nmd->virt_addr = (u64) ioremap(md->phys_addr, 0);\r\n} else if (md->attribute & EFI_MEMORY_WC) {\r\n#if 0\r\nmd->virt_addr = ia64_remap(md->phys_addr,\r\n(_PAGE_A |\r\n_PAGE_P |\r\n_PAGE_D |\r\n_PAGE_MA_WC |\r\n_PAGE_PL_0 |\r\n_PAGE_AR_RW));\r\n#else\r\nprintk(KERN_INFO "EFI_MEMORY_WC mapping\n");\r\nmd->virt_addr = (u64) ioremap(md->phys_addr, 0);\r\n#endif\r\n} else if (md->attribute & EFI_MEMORY_WT) {\r\n#if 0\r\nmd->virt_addr = ia64_remap(md->phys_addr,\r\n(_PAGE_A |\r\n_PAGE_P |\r\n_PAGE_D |\r\n_PAGE_MA_WT |\r\n_PAGE_PL_0 |\r\n_PAGE_AR_RW));\r\n#else\r\nprintk(KERN_INFO "EFI_MEMORY_WT mapping\n");\r\nmd->virt_addr = (u64) ioremap(md->phys_addr, 0);\r\n#endif\r\n}\r\n}\r\n}\r\nstatus = efi_call_phys(__va(runtime->set_virtual_address_map),\r\nia64_boot_param->efi_memmap_size,\r\nefi_desc_size,\r\nia64_boot_param->efi_memdesc_version,\r\nia64_boot_param->efi_memmap);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_WARNING "warning: unable to switch EFI into "\r\n"virtual mode (status=%lu)\n", status);\r\nreturn;\r\n}\r\nefi.get_time = virt_get_time;\r\nefi.set_time = virt_set_time;\r\nefi.get_wakeup_time = virt_get_wakeup_time;\r\nefi.set_wakeup_time = virt_set_wakeup_time;\r\nefi.get_variable = virt_get_variable;\r\nefi.get_next_variable = virt_get_next_variable;\r\nefi.set_variable = virt_set_variable;\r\nefi.get_next_high_mono_count = virt_get_next_high_mono_count;\r\nefi.reset_system = virt_reset_system;\r\n}\r\nu64\r\nefi_get_iobase (void)\r\n{\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nu64 efi_desc_size;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (md->type == EFI_MEMORY_MAPPED_IO_PORT_SPACE) {\r\nif (md->attribute & EFI_MEMORY_UC)\r\nreturn md->phys_addr;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct kern_memdesc *\r\nkern_memory_descriptor (unsigned long phys_addr)\r\n{\r\nstruct kern_memdesc *md;\r\nfor (md = kern_memmap; md->start != ~0UL; md++) {\r\nif (phys_addr - md->start < (md->num_pages << EFI_PAGE_SHIFT))\r\nreturn md;\r\n}\r\nreturn NULL;\r\n}\r\nstatic efi_memory_desc_t *\r\nefi_memory_descriptor (unsigned long phys_addr)\r\n{\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nu64 efi_desc_size;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (phys_addr - md->phys_addr < efi_md_size(md))\r\nreturn md;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nefi_memmap_intersects (unsigned long phys_addr, unsigned long size)\r\n{\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nu64 efi_desc_size;\r\nunsigned long end;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nend = phys_addr + size;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (md->phys_addr < end && efi_md_end(md) > phys_addr)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nu32\r\nefi_mem_type (unsigned long phys_addr)\r\n{\r\nefi_memory_desc_t *md = efi_memory_descriptor(phys_addr);\r\nif (md)\r\nreturn md->type;\r\nreturn 0;\r\n}\r\nu64\r\nefi_mem_attributes (unsigned long phys_addr)\r\n{\r\nefi_memory_desc_t *md = efi_memory_descriptor(phys_addr);\r\nif (md)\r\nreturn md->attribute;\r\nreturn 0;\r\n}\r\nu64\r\nefi_mem_attribute (unsigned long phys_addr, unsigned long size)\r\n{\r\nunsigned long end = phys_addr + size;\r\nefi_memory_desc_t *md = efi_memory_descriptor(phys_addr);\r\nu64 attr;\r\nif (!md)\r\nreturn 0;\r\nattr = md->attribute & ~EFI_MEMORY_RUNTIME;\r\ndo {\r\nunsigned long md_end = efi_md_end(md);\r\nif (end <= md_end)\r\nreturn attr;\r\nmd = efi_memory_descriptor(md_end);\r\nif (!md || (md->attribute & ~EFI_MEMORY_RUNTIME) != attr)\r\nreturn 0;\r\n} while (md);\r\nreturn 0;\r\n}\r\nu64\r\nkern_mem_attribute (unsigned long phys_addr, unsigned long size)\r\n{\r\nunsigned long end = phys_addr + size;\r\nstruct kern_memdesc *md;\r\nu64 attr;\r\nif (!kern_memmap) {\r\nattr = efi_mem_attribute(phys_addr, size);\r\nif (attr & EFI_MEMORY_WB)\r\nreturn EFI_MEMORY_WB;\r\nreturn 0;\r\n}\r\nmd = kern_memory_descriptor(phys_addr);\r\nif (!md)\r\nreturn 0;\r\nattr = md->attribute;\r\ndo {\r\nunsigned long md_end = kmd_end(md);\r\nif (end <= md_end)\r\nreturn attr;\r\nmd = kern_memory_descriptor(md_end);\r\nif (!md || md->attribute != attr)\r\nreturn 0;\r\n} while (md);\r\nreturn 0;\r\n}\r\nint\r\nvalid_phys_addr_range (unsigned long phys_addr, unsigned long size)\r\n{\r\nu64 attr;\r\nattr = kern_mem_attribute(phys_addr, size);\r\nif (attr & EFI_MEMORY_WB || attr & EFI_MEMORY_UC)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint\r\nvalid_mmap_phys_addr_range (unsigned long pfn, unsigned long size)\r\n{\r\nunsigned long phys_addr = pfn << PAGE_SHIFT;\r\nu64 attr;\r\nattr = efi_mem_attribute(phys_addr, size);\r\nif (attr & EFI_MEMORY_WB || attr & EFI_MEMORY_UC)\r\nreturn 1;\r\nif (efi_memmap_intersects(phys_addr, size))\r\nreturn 0;\r\nreturn 1;\r\n}\r\npgprot_t\r\nphys_mem_access_prot(struct file *file, unsigned long pfn, unsigned long size,\r\npgprot_t vma_prot)\r\n{\r\nunsigned long phys_addr = pfn << PAGE_SHIFT;\r\nu64 attr;\r\nattr = kern_mem_attribute(phys_addr, size);\r\nif (attr & EFI_MEMORY_WB)\r\nreturn pgprot_cacheable(vma_prot);\r\nelse if (attr & EFI_MEMORY_UC)\r\nreturn pgprot_noncached(vma_prot);\r\nif (efi_mem_attribute(phys_addr, size) & EFI_MEMORY_WB)\r\nreturn pgprot_cacheable(vma_prot);\r\nreturn pgprot_noncached(vma_prot);\r\n}\r\nint __init\r\nefi_uart_console_only(void)\r\n{\r\nefi_status_t status;\r\nchar *s, name[] = "ConOut";\r\nefi_guid_t guid = EFI_GLOBAL_VARIABLE_GUID;\r\nefi_char16_t *utf16, name_utf16[32];\r\nunsigned char data[1024];\r\nunsigned long size = sizeof(data);\r\nstruct efi_generic_dev_path *hdr, *end_addr;\r\nint uart = 0;\r\nutf16 = name_utf16;\r\ns = name;\r\nwhile (*s)\r\n*utf16++ = *s++ & 0x7f;\r\n*utf16 = 0;\r\nstatus = efi.get_variable(name_utf16, &guid, NULL, &size, data);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_ERR "No EFI %s variable?\n", name);\r\nreturn 0;\r\n}\r\nhdr = (struct efi_generic_dev_path *) data;\r\nend_addr = (struct efi_generic_dev_path *) ((u8 *) data + size);\r\nwhile (hdr < end_addr) {\r\nif (hdr->type == EFI_DEV_MSG &&\r\nhdr->sub_type == EFI_DEV_MSG_UART)\r\nuart = 1;\r\nelse if (hdr->type == EFI_DEV_END_PATH ||\r\nhdr->type == EFI_DEV_END_PATH2) {\r\nif (!uart)\r\nreturn 0;\r\nif (hdr->sub_type == EFI_DEV_END_ENTIRE)\r\nreturn 1;\r\nuart = 0;\r\n}\r\nhdr = (struct efi_generic_dev_path *)((u8 *) hdr + hdr->length);\r\n}\r\nprintk(KERN_ERR "Malformed %s value\n", name);\r\nreturn 0;\r\n}\r\nstruct kern_memdesc *\r\nfind_memmap_space (void)\r\n{\r\nu64 contig_low=0, contig_high=0;\r\nu64 as = 0, ae;\r\nvoid *efi_map_start, *efi_map_end, *p, *q;\r\nefi_memory_desc_t *md, *pmd = NULL, *check_md;\r\nu64 space_needed, efi_desc_size;\r\nunsigned long total_mem = 0;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nspace_needed = sizeof(kern_memdesc_t) *\r\n(3 * (ia64_boot_param->efi_memmap_size/efi_desc_size) + 1);\r\nfor (p = efi_map_start; p < efi_map_end; pmd = md, p += efi_desc_size) {\r\nmd = p;\r\nif (!efi_wb(md)) {\r\ncontinue;\r\n}\r\nif (pmd == NULL || !efi_wb(pmd) ||\r\nefi_md_end(pmd) != md->phys_addr) {\r\ncontig_low = GRANULEROUNDUP(md->phys_addr);\r\ncontig_high = efi_md_end(md);\r\nfor (q = p + efi_desc_size; q < efi_map_end;\r\nq += efi_desc_size) {\r\ncheck_md = q;\r\nif (!efi_wb(check_md))\r\nbreak;\r\nif (contig_high != check_md->phys_addr)\r\nbreak;\r\ncontig_high = efi_md_end(check_md);\r\n}\r\ncontig_high = GRANULEROUNDDOWN(contig_high);\r\n}\r\nif (!is_memory_available(md) || md->type == EFI_LOADER_DATA)\r\ncontinue;\r\nas = max(contig_low, md->phys_addr);\r\nae = min(contig_high, efi_md_end(md));\r\nas = max(as, min_addr);\r\nae = min(ae, max_addr);\r\nif (ae <= as)\r\ncontinue;\r\nif (total_mem + (ae - as) > mem_limit)\r\nae -= total_mem + (ae - as) - mem_limit;\r\nif (ae <= as)\r\ncontinue;\r\nif (ae - as > space_needed)\r\nbreak;\r\n}\r\nif (p >= efi_map_end)\r\npanic("Can't allocate space for kernel memory descriptors");\r\nreturn __va(as);\r\n}\r\nunsigned long\r\nefi_memmap_init(u64 *s, u64 *e)\r\n{\r\nstruct kern_memdesc *k, *prev = NULL;\r\nu64 contig_low=0, contig_high=0;\r\nu64 as, ae, lim;\r\nvoid *efi_map_start, *efi_map_end, *p, *q;\r\nefi_memory_desc_t *md, *pmd = NULL, *check_md;\r\nu64 efi_desc_size;\r\nunsigned long total_mem = 0;\r\nk = kern_memmap = find_memmap_space();\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nfor (p = efi_map_start; p < efi_map_end; pmd = md, p += efi_desc_size) {\r\nmd = p;\r\nif (!efi_wb(md)) {\r\nif (efi_uc(md) &&\r\n(md->type == EFI_CONVENTIONAL_MEMORY ||\r\nmd->type == EFI_BOOT_SERVICES_DATA)) {\r\nk->attribute = EFI_MEMORY_UC;\r\nk->start = md->phys_addr;\r\nk->num_pages = md->num_pages;\r\nk++;\r\n}\r\ncontinue;\r\n}\r\nif (pmd == NULL || !efi_wb(pmd) ||\r\nefi_md_end(pmd) != md->phys_addr) {\r\ncontig_low = GRANULEROUNDUP(md->phys_addr);\r\ncontig_high = efi_md_end(md);\r\nfor (q = p + efi_desc_size; q < efi_map_end;\r\nq += efi_desc_size) {\r\ncheck_md = q;\r\nif (!efi_wb(check_md))\r\nbreak;\r\nif (contig_high != check_md->phys_addr)\r\nbreak;\r\ncontig_high = efi_md_end(check_md);\r\n}\r\ncontig_high = GRANULEROUNDDOWN(contig_high);\r\n}\r\nif (!is_memory_available(md))\r\ncontinue;\r\n#ifdef CONFIG_CRASH_DUMP\r\nif (saved_max_pfn < (efi_md_end(md) >> PAGE_SHIFT))\r\nsaved_max_pfn = (efi_md_end(md) >> PAGE_SHIFT);\r\n#endif\r\nif (md->phys_addr < contig_low) {\r\nlim = min(efi_md_end(md), contig_low);\r\nif (efi_uc(md)) {\r\nif (k > kern_memmap &&\r\n(k-1)->attribute == EFI_MEMORY_UC &&\r\nkmd_end(k-1) == md->phys_addr) {\r\n(k-1)->num_pages +=\r\n(lim - md->phys_addr)\r\n>> EFI_PAGE_SHIFT;\r\n} else {\r\nk->attribute = EFI_MEMORY_UC;\r\nk->start = md->phys_addr;\r\nk->num_pages = (lim - md->phys_addr)\r\n>> EFI_PAGE_SHIFT;\r\nk++;\r\n}\r\n}\r\nas = contig_low;\r\n} else\r\nas = md->phys_addr;\r\nif (efi_md_end(md) > contig_high) {\r\nlim = max(md->phys_addr, contig_high);\r\nif (efi_uc(md)) {\r\nif (lim == md->phys_addr && k > kern_memmap &&\r\n(k-1)->attribute == EFI_MEMORY_UC &&\r\nkmd_end(k-1) == md->phys_addr) {\r\n(k-1)->num_pages += md->num_pages;\r\n} else {\r\nk->attribute = EFI_MEMORY_UC;\r\nk->start = lim;\r\nk->num_pages = (efi_md_end(md) - lim)\r\n>> EFI_PAGE_SHIFT;\r\nk++;\r\n}\r\n}\r\nae = contig_high;\r\n} else\r\nae = efi_md_end(md);\r\nas = max(as, min_addr);\r\nae = min(ae, max_addr);\r\nif (ae <= as)\r\ncontinue;\r\nif (total_mem + (ae - as) > mem_limit)\r\nae -= total_mem + (ae - as) - mem_limit;\r\nif (ae <= as)\r\ncontinue;\r\nif (prev && kmd_end(prev) == md->phys_addr) {\r\nprev->num_pages += (ae - as) >> EFI_PAGE_SHIFT;\r\ntotal_mem += ae - as;\r\ncontinue;\r\n}\r\nk->attribute = EFI_MEMORY_WB;\r\nk->start = as;\r\nk->num_pages = (ae - as) >> EFI_PAGE_SHIFT;\r\ntotal_mem += ae - as;\r\nprev = k++;\r\n}\r\nk->start = ~0L;\r\n*s = (u64)kern_memmap;\r\n*e = (u64)++k;\r\nreturn total_mem;\r\n}\r\nvoid\r\nefi_initialize_iomem_resources(struct resource *code_resource,\r\nstruct resource *data_resource,\r\nstruct resource *bss_resource)\r\n{\r\nstruct resource *res;\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nu64 efi_desc_size;\r\nchar *name;\r\nunsigned long flags;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nres = NULL;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (md->num_pages == 0)\r\ncontinue;\r\nflags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nswitch (md->type) {\r\ncase EFI_MEMORY_MAPPED_IO:\r\ncase EFI_MEMORY_MAPPED_IO_PORT_SPACE:\r\ncontinue;\r\ncase EFI_LOADER_CODE:\r\ncase EFI_LOADER_DATA:\r\ncase EFI_BOOT_SERVICES_DATA:\r\ncase EFI_BOOT_SERVICES_CODE:\r\ncase EFI_CONVENTIONAL_MEMORY:\r\nif (md->attribute & EFI_MEMORY_WP) {\r\nname = "System ROM";\r\nflags |= IORESOURCE_READONLY;\r\n} else if (md->attribute == EFI_MEMORY_UC)\r\nname = "Uncached RAM";\r\nelse\r\nname = "System RAM";\r\nbreak;\r\ncase EFI_ACPI_MEMORY_NVS:\r\nname = "ACPI Non-volatile Storage";\r\nbreak;\r\ncase EFI_UNUSABLE_MEMORY:\r\nname = "reserved";\r\nflags |= IORESOURCE_DISABLED;\r\nbreak;\r\ncase EFI_RESERVED_TYPE:\r\ncase EFI_RUNTIME_SERVICES_CODE:\r\ncase EFI_RUNTIME_SERVICES_DATA:\r\ncase EFI_ACPI_RECLAIM_MEMORY:\r\ndefault:\r\nname = "reserved";\r\nbreak;\r\n}\r\nif ((res = kzalloc(sizeof(struct resource),\r\nGFP_KERNEL)) == NULL) {\r\nprintk(KERN_ERR\r\n"failed to allocate resource for iomem\n");\r\nreturn;\r\n}\r\nres->name = name;\r\nres->start = md->phys_addr;\r\nres->end = md->phys_addr + efi_md_size(md) - 1;\r\nres->flags = flags;\r\nif (insert_resource(&iomem_resource, res) < 0)\r\nkfree(res);\r\nelse {\r\ninsert_resource(res, code_resource);\r\ninsert_resource(res, data_resource);\r\ninsert_resource(res, bss_resource);\r\n#ifdef CONFIG_KEXEC\r\ninsert_resource(res, &efi_memmap_res);\r\ninsert_resource(res, &boot_param_res);\r\nif (crashk_res.end > crashk_res.start)\r\ninsert_resource(res, &crashk_res);\r\n#endif\r\n}\r\n}\r\n}\r\nunsigned long __init\r\nkdump_find_rsvd_region (unsigned long size, struct rsvd_region *r, int n)\r\n{\r\nint i;\r\nu64 start, end;\r\nu64 alignment = 1UL << _PAGE_SIZE_64M;\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nu64 efi_desc_size;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (!efi_wb(md))\r\ncontinue;\r\nstart = ALIGN(md->phys_addr, alignment);\r\nend = efi_md_end(md);\r\nfor (i = 0; i < n; i++) {\r\nif (__pa(r[i].start) >= start && __pa(r[i].end) < end) {\r\nif (__pa(r[i].start) > start + size)\r\nreturn start;\r\nstart = ALIGN(__pa(r[i].end), alignment);\r\nif (i < n-1 &&\r\n__pa(r[i+1].start) < start + size)\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\n}\r\nif (end > start + size)\r\nreturn start;\r\n}\r\nprintk(KERN_WARNING\r\n"Cannot reserve 0x%lx byte of memory for crashdump\n", size);\r\nreturn ~0UL;\r\n}\r\nunsigned long __init\r\nvmcore_find_descriptor_size (unsigned long address)\r\n{\r\nvoid *efi_map_start, *efi_map_end, *p;\r\nefi_memory_desc_t *md;\r\nu64 efi_desc_size;\r\nunsigned long ret = 0;\r\nefi_map_start = __va(ia64_boot_param->efi_memmap);\r\nefi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;\r\nefi_desc_size = ia64_boot_param->efi_memdesc_size;\r\nfor (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {\r\nmd = p;\r\nif (efi_wb(md) && md->type == EFI_LOADER_DATA\r\n&& md->phys_addr == address) {\r\nret = efi_md_size(md);\r\nbreak;\r\n}\r\n}\r\nif (ret == 0)\r\nprintk(KERN_WARNING "Cannot locate EFI vmcore descriptor\n");\r\nreturn ret;\r\n}
