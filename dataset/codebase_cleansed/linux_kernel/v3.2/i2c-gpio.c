static void i2c_gpio_setsda_dir(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nif (state)\r\ngpio_direction_input(pdata->sda_pin);\r\nelse\r\ngpio_direction_output(pdata->sda_pin, 0);\r\n}\r\nstatic void i2c_gpio_setsda_val(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\ngpio_set_value(pdata->sda_pin, state);\r\n}\r\nstatic void i2c_gpio_setscl_dir(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nif (state)\r\ngpio_direction_input(pdata->scl_pin);\r\nelse\r\ngpio_direction_output(pdata->scl_pin, 0);\r\n}\r\nstatic void i2c_gpio_setscl_val(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\ngpio_set_value(pdata->scl_pin, state);\r\n}\r\nstatic int i2c_gpio_getsda(void *data)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nreturn gpio_get_value(pdata->sda_pin);\r\n}\r\nstatic int i2c_gpio_getscl(void *data)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nreturn gpio_get_value(pdata->scl_pin);\r\n}\r\nstatic int __devinit i2c_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_gpio_platform_data *pdata;\r\nstruct i2c_algo_bit_data *bit_data;\r\nstruct i2c_adapter *adap;\r\nint ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -ENXIO;\r\nret = -ENOMEM;\r\nadap = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);\r\nif (!adap)\r\ngoto err_alloc_adap;\r\nbit_data = kzalloc(sizeof(struct i2c_algo_bit_data), GFP_KERNEL);\r\nif (!bit_data)\r\ngoto err_alloc_bit_data;\r\nret = gpio_request(pdata->sda_pin, "sda");\r\nif (ret)\r\ngoto err_request_sda;\r\nret = gpio_request(pdata->scl_pin, "scl");\r\nif (ret)\r\ngoto err_request_scl;\r\nif (pdata->sda_is_open_drain) {\r\ngpio_direction_output(pdata->sda_pin, 1);\r\nbit_data->setsda = i2c_gpio_setsda_val;\r\n} else {\r\ngpio_direction_input(pdata->sda_pin);\r\nbit_data->setsda = i2c_gpio_setsda_dir;\r\n}\r\nif (pdata->scl_is_open_drain || pdata->scl_is_output_only) {\r\ngpio_direction_output(pdata->scl_pin, 1);\r\nbit_data->setscl = i2c_gpio_setscl_val;\r\n} else {\r\ngpio_direction_input(pdata->scl_pin);\r\nbit_data->setscl = i2c_gpio_setscl_dir;\r\n}\r\nif (!pdata->scl_is_output_only)\r\nbit_data->getscl = i2c_gpio_getscl;\r\nbit_data->getsda = i2c_gpio_getsda;\r\nif (pdata->udelay)\r\nbit_data->udelay = pdata->udelay;\r\nelse if (pdata->scl_is_output_only)\r\nbit_data->udelay = 50;\r\nelse\r\nbit_data->udelay = 5;\r\nif (pdata->timeout)\r\nbit_data->timeout = pdata->timeout;\r\nelse\r\nbit_data->timeout = HZ / 10;\r\nbit_data->data = pdata;\r\nadap->owner = THIS_MODULE;\r\nsnprintf(adap->name, sizeof(adap->name), "i2c-gpio%d", pdev->id);\r\nadap->algo_data = bit_data;\r\nadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nadap->dev.parent = &pdev->dev;\r\nadap->nr = (pdev->id != -1) ? pdev->id : 0;\r\nret = i2c_bit_add_numbered_bus(adap);\r\nif (ret)\r\ngoto err_add_bus;\r\nplatform_set_drvdata(pdev, adap);\r\ndev_info(&pdev->dev, "using pins %u (SDA) and %u (SCL%s)\n",\r\npdata->sda_pin, pdata->scl_pin,\r\npdata->scl_is_output_only\r\n? ", no clock stretching" : "");\r\nreturn 0;\r\nerr_add_bus:\r\ngpio_free(pdata->scl_pin);\r\nerr_request_scl:\r\ngpio_free(pdata->sda_pin);\r\nerr_request_sda:\r\nkfree(bit_data);\r\nerr_alloc_bit_data:\r\nkfree(adap);\r\nerr_alloc_adap:\r\nreturn ret;\r\n}\r\nstatic int __devexit i2c_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_gpio_platform_data *pdata;\r\nstruct i2c_adapter *adap;\r\nadap = platform_get_drvdata(pdev);\r\npdata = pdev->dev.platform_data;\r\ni2c_del_adapter(adap);\r\ngpio_free(pdata->scl_pin);\r\ngpio_free(pdata->sda_pin);\r\nkfree(adap->algo_data);\r\nkfree(adap);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_gpio_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&i2c_gpio_driver);\r\nif (ret)\r\nprintk(KERN_ERR "i2c-gpio: probe failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit i2c_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&i2c_gpio_driver);\r\n}
