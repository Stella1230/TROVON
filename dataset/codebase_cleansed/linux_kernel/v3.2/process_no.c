static void default_idle(void)\r\n{\r\nlocal_irq_disable();\r\nwhile (!need_resched()) {\r\n__asm__("stop #0x2000" : : : "cc");\r\nlocal_irq_disable();\r\n}\r\nlocal_irq_enable();\r\n}\r\nvoid cpu_idle(void)\r\n{\r\nwhile (1) {\r\nidle();\r\npreempt_enable_no_resched();\r\nschedule();\r\npreempt_disable();\r\n}\r\n}\r\nvoid machine_restart(char * __unused)\r\n{\r\nif (mach_reset)\r\nmach_reset();\r\nfor (;;);\r\n}\r\nvoid machine_halt(void)\r\n{\r\nif (mach_halt)\r\nmach_halt();\r\nfor (;;);\r\n}\r\nvoid machine_power_off(void)\r\n{\r\nif (mach_power_off)\r\nmach_power_off();\r\nfor (;;);\r\n}\r\nvoid show_regs(struct pt_regs * regs)\r\n{\r\nprintk(KERN_NOTICE "\n");\r\nprintk(KERN_NOTICE "Format %02x Vector: %04x PC: %08lx Status: %04x %s\n",\r\nregs->format, regs->vector, regs->pc, regs->sr, print_tainted());\r\nprintk(KERN_NOTICE "ORIG_D0: %08lx D0: %08lx A2: %08lx A1: %08lx\n",\r\nregs->orig_d0, regs->d0, regs->a2, regs->a1);\r\nprintk(KERN_NOTICE "A0: %08lx D5: %08lx D4: %08lx\n",\r\nregs->a0, regs->d5, regs->d4);\r\nprintk(KERN_NOTICE "D3: %08lx D2: %08lx D1: %08lx\n",\r\nregs->d3, regs->d2, regs->d1);\r\nif (!(regs->sr & PS_S))\r\nprintk(KERN_NOTICE "USP: %08lx\n", rdusp());\r\n}\r\nint kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)\r\n{\r\nint retval;\r\nlong clone_arg = flags | CLONE_VM;\r\nmm_segment_t fs;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\n__asm__ __volatile__ (\r\n"movel %%sp, %%d2\n\t"\r\n"movel %5, %%d1\n\t"\r\n"movel %1, %%d0\n\t"\r\n"trap #0\n\t"\r\n"cmpl %%sp, %%d2\n\t"\r\n"jeq 1f\n\t"\r\n"movel %3, %%sp@-\n\t"\r\n"jsr %4@\n\t"\r\n"movel %2, %%d0\n\t"\r\n"trap #0\n"\r\n"1:\n\t"\r\n"movel %%d0, %0\n"\r\n: "=d" (retval)\r\n: "i" (__NR_clone),\r\n"i" (__NR_exit),\r\n"a" (arg),\r\n"a" (fn),\r\n"a" (clone_arg)\r\n: "cc", "%d0", "%d1", "%d2");\r\nset_fs(fs);\r\nreturn retval;\r\n}\r\nvoid flush_thread(void)\r\n{\r\n#ifdef CONFIG_FPU\r\nunsigned long zero = 0;\r\n#endif\r\ncurrent->thread.fs = __USER_DS;\r\n#ifdef CONFIG_FPU\r\nif (!FPU_IS_EMU)\r\nasm volatile (".chip 68k/68881\n\t"\r\n"frestore %0@\n\t"\r\n".chip 68k" : : "a" (&zero));\r\n#endif\r\n}\r\nasmlinkage int m68k_fork(struct pt_regs *regs)\r\n{\r\nreturn(-EINVAL);\r\n}\r\nasmlinkage int m68k_vfork(struct pt_regs *regs)\r\n{\r\nreturn do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0, NULL, NULL);\r\n}\r\nasmlinkage int m68k_clone(struct pt_regs *regs)\r\n{\r\nunsigned long clone_flags;\r\nunsigned long newsp;\r\nclone_flags = regs->d1;\r\nnewsp = regs->d2;\r\nif (!newsp)\r\nnewsp = rdusp();\r\nreturn do_fork(clone_flags, newsp, regs, 0, NULL, NULL);\r\n}\r\nint copy_thread(unsigned long clone_flags,\r\nunsigned long usp, unsigned long topstk,\r\nstruct task_struct * p, struct pt_regs * regs)\r\n{\r\nstruct pt_regs * childregs;\r\nstruct switch_stack * childstack, *stack;\r\nunsigned long *retp;\r\nchildregs = (struct pt_regs *) (task_stack_page(p) + THREAD_SIZE) - 1;\r\n*childregs = *regs;\r\nchildregs->d0 = 0;\r\nretp = ((unsigned long *) regs);\r\nstack = ((struct switch_stack *) retp) - 1;\r\nchildstack = ((struct switch_stack *) childregs) - 1;\r\n*childstack = *stack;\r\nchildstack->retpc = (unsigned long)ret_from_fork;\r\np->thread.usp = usp;\r\np->thread.ksp = (unsigned long)childstack;\r\nif (clone_flags & CLONE_SETTLS)\r\ntask_thread_info(p)->tp_value = regs->d5;\r\np->thread.fs = get_fs().seg;\r\n#ifdef CONFIG_FPU\r\nif (!FPU_IS_EMU) {\r\nasm volatile ("fsave %0" : : "m" (p->thread.fpstate[0]) : "memory");\r\nif (p->thread.fpstate[0])\r\nasm volatile ("fmovemx %/fp0-%/fp7,%0\n\t"\r\n"fmoveml %/fpiar/%/fpcr/%/fpsr,%1"\r\n: : "m" (p->thread.fp[0]), "m" (p->thread.fpcntl[0])\r\n: "memory");\r\nasm volatile ("frestore %0" : : "m" (p->thread.fpstate[0]));\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint dump_fpu(struct pt_regs *regs, struct user_m68kfp_struct *fpu)\r\n{\r\n#ifdef CONFIG_FPU\r\nchar fpustate[216];\r\nif (FPU_IS_EMU) {\r\nint i;\r\nmemcpy(fpu->fpcntl, current->thread.fpcntl, 12);\r\nmemcpy(fpu->fpregs, current->thread.fp, 96);\r\nfor (i = 0; i < 24; i += 3)\r\nfpu->fpregs[i] = ((fpu->fpregs[i] & 0xffff0000) << 15) |\r\n((fpu->fpregs[i] & 0x0000ffff) << 16);\r\nreturn 1;\r\n}\r\nasm volatile ("fsave %0" :: "m" (fpustate[0]) : "memory");\r\nif (!fpustate[0])\r\nreturn 0;\r\nasm volatile ("fmovem %/fpiar/%/fpcr/%/fpsr,%0"\r\n:: "m" (fpu->fpcntl[0])\r\n: "memory");\r\nasm volatile ("fmovemx %/fp0-%/fp7,%0"\r\n:: "m" (fpu->fpregs[0])\r\n: "memory");\r\n#endif\r\nreturn 1;\r\n}\r\nvoid dump(struct pt_regs *fp)\r\n{\r\nunsigned long *sp;\r\nunsigned char *tp;\r\nint i;\r\nprintk(KERN_EMERG "\nCURRENT PROCESS:\n\n");\r\nprintk(KERN_EMERG "COMM=%s PID=%d\n", current->comm, current->pid);\r\nif (current->mm) {\r\nprintk(KERN_EMERG "TEXT=%08x-%08x DATA=%08x-%08x BSS=%08x-%08x\n",\r\n(int) current->mm->start_code,\r\n(int) current->mm->end_code,\r\n(int) current->mm->start_data,\r\n(int) current->mm->end_data,\r\n(int) current->mm->end_data,\r\n(int) current->mm->brk);\r\nprintk(KERN_EMERG "USER-STACK=%08x KERNEL-STACK=%08x\n\n",\r\n(int) current->mm->start_stack,\r\n(int)(((unsigned long) current) + THREAD_SIZE));\r\n}\r\nprintk(KERN_EMERG "PC: %08lx\n", fp->pc);\r\nprintk(KERN_EMERG "SR: %08lx SP: %08lx\n", (long) fp->sr, (long) fp);\r\nprintk(KERN_EMERG "d0: %08lx d1: %08lx d2: %08lx d3: %08lx\n",\r\nfp->d0, fp->d1, fp->d2, fp->d3);\r\nprintk(KERN_EMERG "d4: %08lx d5: %08lx a0: %08lx a1: %08lx\n",\r\nfp->d4, fp->d5, fp->a0, fp->a1);\r\nprintk(KERN_EMERG "\nUSP: %08x TRAPFRAME: %p\n",\r\n(unsigned int) rdusp(), fp);\r\nprintk(KERN_EMERG "\nCODE:");\r\ntp = ((unsigned char *) fp->pc) - 0x20;\r\nfor (sp = (unsigned long *) tp, i = 0; (i < 0x40); i += 4) {\r\nif ((i % 0x10) == 0)\r\nprintk(KERN_EMERG "%p: ", tp + i);\r\nprintk("%08x ", (int) *sp++);\r\n}\r\nprintk(KERN_EMERG "\n");\r\nprintk(KERN_EMERG "KERNEL STACK:");\r\ntp = ((unsigned char *) fp) - 0x40;\r\nfor (sp = (unsigned long *) tp, i = 0; (i < 0xc0); i += 4) {\r\nif ((i % 0x10) == 0)\r\nprintk(KERN_EMERG "%p: ", tp + i);\r\nprintk("%08x ", (int) *sp++);\r\n}\r\nprintk(KERN_EMERG "\n");\r\nprintk(KERN_EMERG "USER STACK:");\r\ntp = (unsigned char *) (rdusp() - 0x10);\r\nfor (sp = (unsigned long *) tp, i = 0; (i < 0x80); i += 4) {\r\nif ((i % 0x10) == 0)\r\nprintk(KERN_EMERG "%p: ", tp + i);\r\nprintk("%08x ", (int) *sp++);\r\n}\r\nprintk(KERN_EMERG "\n");\r\n}\r\nasmlinkage int sys_execve(const char *name,\r\nconst char *const *argv,\r\nconst char *const *envp)\r\n{\r\nint error;\r\nchar * filename;\r\nstruct pt_regs *regs = (struct pt_regs *) &name;\r\nfilename = getname(name);\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\nreturn error;\r\nerror = do_execve(filename, argv, envp, regs);\r\nputname(filename);\r\nreturn error;\r\n}\r\nunsigned long get_wchan(struct task_struct *p)\r\n{\r\nunsigned long fp, pc;\r\nunsigned long stack_page;\r\nint count = 0;\r\nif (!p || p == current || p->state == TASK_RUNNING)\r\nreturn 0;\r\nstack_page = (unsigned long)p;\r\nfp = ((struct switch_stack *)p->thread.ksp)->a6;\r\ndo {\r\nif (fp < stack_page+sizeof(struct thread_info) ||\r\nfp >= THREAD_SIZE-8+stack_page)\r\nreturn 0;\r\npc = ((unsigned long *)fp)[1];\r\nif (!in_sched_functions(pc))\r\nreturn pc;\r\nfp = *(unsigned long *) fp;\r\n} while (count++ < 16);\r\nreturn 0;\r\n}\r\nunsigned long thread_saved_pc(struct task_struct *tsk)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *)tsk->thread.ksp;\r\nif (in_sched_functions(sw->retpc))\r\nreturn ((unsigned long *)sw->a6)[1];\r\nelse\r\nreturn sw->retpc;\r\n}
