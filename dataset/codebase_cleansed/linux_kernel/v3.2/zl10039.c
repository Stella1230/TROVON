static int zl10039_read(const struct zl10039_state *state,\r\nconst enum zl10039_reg_addr reg, u8 *buf,\r\nconst size_t count)\r\n{\r\nu8 regbuf[] = { reg };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = state->i2c_addr,\r\n.flags = 0,\r\n.buf = regbuf,\r\n.len = 1,\r\n}, {\r\n.addr = state->i2c_addr,\r\n.flags = I2C_M_RD,\r\n.buf = buf,\r\n.len = count,\r\n},\r\n};\r\ndprintk("%s\n", __func__);\r\nif (i2c_transfer(state->i2c, msg, 2) != 2) {\r\ndprintk("%s: i2c read error\n", __func__);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zl10039_write(struct zl10039_state *state,\r\nconst enum zl10039_reg_addr reg, const u8 *src,\r\nconst size_t count)\r\n{\r\nu8 buf[count + 1];\r\nstruct i2c_msg msg = {\r\n.addr = state->i2c_addr,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = count + 1,\r\n};\r\ndprintk("%s\n", __func__);\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], src, count);\r\nif (i2c_transfer(state->i2c, &msg, 1) != 1) {\r\ndprintk("%s: i2c write error\n", __func__);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int zl10039_readreg(struct zl10039_state *state,\r\nconst enum zl10039_reg_addr reg, u8 *val)\r\n{\r\nreturn zl10039_read(state, reg, val, 1);\r\n}\r\nstatic inline int zl10039_writereg(struct zl10039_state *state,\r\nconst enum zl10039_reg_addr reg,\r\nconst u8 val)\r\n{\r\nreturn zl10039_write(state, reg, &val, 1);\r\n}\r\nstatic int zl10039_init(struct dvb_frontend *fe)\r\n{\r\nstruct zl10039_state *state = fe->tuner_priv;\r\nint ret;\r\ndprintk("%s\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = zl10039_writereg(state, GENERAL, 0x40);\r\nif (ret < 0) {\r\ndprintk("Note: i2c write error normal when resetting the "\r\n"tuner\n");\r\n}\r\nret = zl10039_writereg(state, GENERAL, 0x01);\r\nif (ret < 0) {\r\ndprintk("Tuner power up failed\n");\r\nreturn ret;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int zl10039_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct zl10039_state *state = fe->tuner_priv;\r\nint ret;\r\ndprintk("%s\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = zl10039_writereg(state, GENERAL, 0x80);\r\nif (ret < 0) {\r\ndprintk("Tuner sleep failed\n");\r\nreturn ret;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int zl10039_set_params(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *params)\r\n{\r\nstruct zl10039_state *state = fe->tuner_priv;\r\nu8 buf[6];\r\nu8 bf;\r\nu32 fbw;\r\nu32 div;\r\nint ret;\r\ndprintk("%s\n", __func__);\r\ndprintk("Set frequency = %d, symbol rate = %d\n",\r\nparams->frequency, params->u.qpsk.symbol_rate);\r\ndiv = (params->frequency * 1000) / 126387;\r\nfbw = (params->u.qpsk.symbol_rate * 27) / 32000;\r\nbf = ((fbw * 5088) / 1011100) - 1;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = (div >> 0) & 0xff;\r\nbuf[2] = 0x1D;\r\nbuf[3] = 0x40;\r\nbuf[4] = 0x6E;\r\nbuf[5] = bf;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = zl10039_writereg(state, BASE1, 0x0A);\r\nif (ret < 0)\r\ngoto error;\r\nret = zl10039_write(state, PLL0, buf, sizeof(buf));\r\nif (ret < 0)\r\ngoto error;\r\nret = zl10039_writereg(state, BASE1, 0x6A);\r\nif (ret < 0)\r\ngoto error;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\nerror:\r\ndprintk("Error setting tuner\n");\r\nreturn ret;\r\n}\r\nstatic int zl10039_release(struct dvb_frontend *fe)\r\n{\r\nstruct zl10039_state *state = fe->tuner_priv;\r\ndprintk("%s\n", __func__);\r\nkfree(state);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *zl10039_attach(struct dvb_frontend *fe,\r\nu8 i2c_addr, struct i2c_adapter *i2c)\r\n{\r\nstruct zl10039_state *state = NULL;\r\ndprintk("%s\n", __func__);\r\nstate = kmalloc(sizeof(struct zl10039_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->i2c = i2c;\r\nstate->i2c_addr = i2c_addr;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (zl10039_readreg(state, GENERAL, &state->id) < 0) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ngoto error;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nstate->id = state->id & 0x0f;\r\nswitch (state->id) {\r\ncase ID_ZL10039:\r\nstrcpy(fe->ops.tuner_ops.info.name,\r\n"Zarlink ZL10039 DVB-S tuner");\r\nbreak;\r\ndefault:\r\ndprintk("Chip ID=%x does not match a known type\n", state->id);\r\ngoto error;\r\n}\r\nmemcpy(&fe->ops.tuner_ops, &zl10039_ops, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = state;\r\ndprintk("Tuner attached @ i2c address 0x%02x\n", i2c_addr);\r\nreturn fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
