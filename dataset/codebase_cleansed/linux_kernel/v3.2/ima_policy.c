static int __init default_policy_setup(char *str)\r\n{\r\nima_use_tcb = 1;\r\nreturn 1;\r\n}\r\nstatic bool ima_match_rules(struct ima_measure_rule_entry *rule,\r\nstruct inode *inode, enum ima_hooks func, int mask)\r\n{\r\nstruct task_struct *tsk = current;\r\nint i;\r\nif ((rule->flags & IMA_FUNC) && rule->func != func)\r\nreturn false;\r\nif ((rule->flags & IMA_MASK) && rule->mask != mask)\r\nreturn false;\r\nif ((rule->flags & IMA_FSMAGIC)\r\n&& rule->fsmagic != inode->i_sb->s_magic)\r\nreturn false;\r\nif ((rule->flags & IMA_UID) && rule->uid != tsk->cred->uid)\r\nreturn false;\r\nfor (i = 0; i < MAX_LSM_RULES; i++) {\r\nint rc = 0;\r\nu32 osid, sid;\r\nif (!rule->lsm[i].rule)\r\ncontinue;\r\nswitch (i) {\r\ncase LSM_OBJ_USER:\r\ncase LSM_OBJ_ROLE:\r\ncase LSM_OBJ_TYPE:\r\nsecurity_inode_getsecid(inode, &osid);\r\nrc = security_filter_rule_match(osid,\r\nrule->lsm[i].type,\r\nAudit_equal,\r\nrule->lsm[i].rule,\r\nNULL);\r\nbreak;\r\ncase LSM_SUBJ_USER:\r\ncase LSM_SUBJ_ROLE:\r\ncase LSM_SUBJ_TYPE:\r\nsecurity_task_getsecid(tsk, &sid);\r\nrc = security_filter_rule_match(sid,\r\nrule->lsm[i].type,\r\nAudit_equal,\r\nrule->lsm[i].rule,\r\nNULL);\r\ndefault:\r\nbreak;\r\n}\r\nif (!rc)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask)\r\n{\r\nstruct ima_measure_rule_entry *entry;\r\nlist_for_each_entry(entry, ima_measure, list) {\r\nbool rc;\r\nrc = ima_match_rules(entry, inode, func, mask);\r\nif (rc)\r\nreturn entry->action;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init ima_init_policy(void)\r\n{\r\nint i, entries;\r\nif (ima_use_tcb)\r\nentries = ARRAY_SIZE(default_rules);\r\nelse\r\nentries = 0;\r\nfor (i = 0; i < entries; i++)\r\nlist_add_tail(&default_rules[i].list, &measure_default_rules);\r\nima_measure = &measure_default_rules;\r\n}\r\nvoid ima_update_policy(void)\r\n{\r\nconst char *op = "policy_update";\r\nconst char *cause = "already exists";\r\nint result = 1;\r\nint audit_info = 0;\r\nif (ima_measure == &measure_default_rules) {\r\nima_measure = &measure_policy_rules;\r\ncause = "complete";\r\nresult = 0;\r\n}\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, cause, result, audit_info);\r\n}\r\nstatic int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\r\nchar *args, int lsm_rule, int audit_type)\r\n{\r\nint result;\r\nif (entry->lsm[lsm_rule].rule)\r\nreturn -EINVAL;\r\nentry->lsm[lsm_rule].type = audit_type;\r\nresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\r\nAudit_equal, args,\r\n&entry->lsm[lsm_rule].rule);\r\nif (!entry->lsm[lsm_rule].rule)\r\nreturn -EINVAL;\r\nreturn result;\r\n}\r\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\r\n{\r\naudit_log_format(ab, "%s=", key);\r\naudit_log_untrustedstring(ab, value);\r\naudit_log_format(ab, " ");\r\n}\r\nstatic int ima_parse_rule(char *rule, struct ima_measure_rule_entry *entry)\r\n{\r\nstruct audit_buffer *ab;\r\nchar *p;\r\nint result = 0;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\r\nentry->uid = -1;\r\nentry->action = UNKNOWN;\r\nwhile ((p = strsep(&rule, " \t")) != NULL) {\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint token;\r\nunsigned long lnum;\r\nif (result < 0)\r\nbreak;\r\nif ((*p == '\0') || (*p == ' ') || (*p == '\t'))\r\ncontinue;\r\ntoken = match_token(p, policy_tokens, args);\r\nswitch (token) {\r\ncase Opt_measure:\r\nima_log_string(ab, "action", "measure");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = MEASURE;\r\nbreak;\r\ncase Opt_dont_measure:\r\nima_log_string(ab, "action", "dont_measure");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = DONT_MEASURE;\r\nbreak;\r\ncase Opt_func:\r\nima_log_string(ab, "func", args[0].from);\r\nif (entry->func)\r\nresult = -EINVAL;\r\nif (strcmp(args[0].from, "FILE_CHECK") == 0)\r\nentry->func = FILE_CHECK;\r\nelse if (strcmp(args[0].from, "PATH_CHECK") == 0)\r\nentry->func = FILE_CHECK;\r\nelse if (strcmp(args[0].from, "FILE_MMAP") == 0)\r\nentry->func = FILE_MMAP;\r\nelse if (strcmp(args[0].from, "BPRM_CHECK") == 0)\r\nentry->func = BPRM_CHECK;\r\nelse\r\nresult = -EINVAL;\r\nif (!result)\r\nentry->flags |= IMA_FUNC;\r\nbreak;\r\ncase Opt_mask:\r\nima_log_string(ab, "mask", args[0].from);\r\nif (entry->mask)\r\nresult = -EINVAL;\r\nif ((strcmp(args[0].from, "MAY_EXEC")) == 0)\r\nentry->mask = MAY_EXEC;\r\nelse if (strcmp(args[0].from, "MAY_WRITE") == 0)\r\nentry->mask = MAY_WRITE;\r\nelse if (strcmp(args[0].from, "MAY_READ") == 0)\r\nentry->mask = MAY_READ;\r\nelse if (strcmp(args[0].from, "MAY_APPEND") == 0)\r\nentry->mask = MAY_APPEND;\r\nelse\r\nresult = -EINVAL;\r\nif (!result)\r\nentry->flags |= IMA_MASK;\r\nbreak;\r\ncase Opt_fsmagic:\r\nima_log_string(ab, "fsmagic", args[0].from);\r\nif (entry->fsmagic) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = strict_strtoul(args[0].from, 16,\r\n&entry->fsmagic);\r\nif (!result)\r\nentry->flags |= IMA_FSMAGIC;\r\nbreak;\r\ncase Opt_uid:\r\nima_log_string(ab, "uid", args[0].from);\r\nif (entry->uid != -1) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = strict_strtoul(args[0].from, 10, &lnum);\r\nif (!result) {\r\nentry->uid = (uid_t) lnum;\r\nif (entry->uid != lnum)\r\nresult = -EINVAL;\r\nelse\r\nentry->flags |= IMA_UID;\r\n}\r\nbreak;\r\ncase Opt_obj_user:\r\nima_log_string(ab, "obj_user", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args[0].from,\r\nLSM_OBJ_USER,\r\nAUDIT_OBJ_USER);\r\nbreak;\r\ncase Opt_obj_role:\r\nima_log_string(ab, "obj_role", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args[0].from,\r\nLSM_OBJ_ROLE,\r\nAUDIT_OBJ_ROLE);\r\nbreak;\r\ncase Opt_obj_type:\r\nima_log_string(ab, "obj_type", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args[0].from,\r\nLSM_OBJ_TYPE,\r\nAUDIT_OBJ_TYPE);\r\nbreak;\r\ncase Opt_subj_user:\r\nima_log_string(ab, "subj_user", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args[0].from,\r\nLSM_SUBJ_USER,\r\nAUDIT_SUBJ_USER);\r\nbreak;\r\ncase Opt_subj_role:\r\nima_log_string(ab, "subj_role", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args[0].from,\r\nLSM_SUBJ_ROLE,\r\nAUDIT_SUBJ_ROLE);\r\nbreak;\r\ncase Opt_subj_type:\r\nima_log_string(ab, "subj_type", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args[0].from,\r\nLSM_SUBJ_TYPE,\r\nAUDIT_SUBJ_TYPE);\r\nbreak;\r\ncase Opt_err:\r\nima_log_string(ab, "UNKNOWN", p);\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (!result && (entry->action == UNKNOWN))\r\nresult = -EINVAL;\r\naudit_log_format(ab, "res=%d", !!result);\r\naudit_log_end(ab);\r\nreturn result;\r\n}\r\nssize_t ima_parse_add_rule(char *rule)\r\n{\r\nconst char *op = "update_policy";\r\nchar *p;\r\nstruct ima_measure_rule_entry *entry;\r\nssize_t result, len;\r\nint audit_info = 0;\r\nif (ima_measure != &measure_default_rules) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "already exists",\r\n-EACCES, audit_info);\r\nreturn -EACCES;\r\n}\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "-ENOMEM", -ENOMEM, audit_info);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&entry->list);\r\np = strsep(&rule, "\n");\r\nlen = strlen(p) + 1;\r\nif (*p == '#') {\r\nkfree(entry);\r\nreturn len;\r\n}\r\nresult = ima_parse_rule(p, entry);\r\nif (result) {\r\nkfree(entry);\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "invalid policy", result,\r\naudit_info);\r\nreturn result;\r\n}\r\nmutex_lock(&ima_measure_mutex);\r\nlist_add_tail(&entry->list, &measure_policy_rules);\r\nmutex_unlock(&ima_measure_mutex);\r\nreturn len;\r\n}\r\nvoid ima_delete_rules(void)\r\n{\r\nstruct ima_measure_rule_entry *entry, *tmp;\r\nmutex_lock(&ima_measure_mutex);\r\nlist_for_each_entry_safe(entry, tmp, &measure_policy_rules, list) {\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&ima_measure_mutex);\r\n}
