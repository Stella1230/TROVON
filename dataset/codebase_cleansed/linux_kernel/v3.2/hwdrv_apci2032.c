int i_APCI2032_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ul_Command = 0;\r\ndevpriv->tsk_Current = current;\r\nif ((data[0] != 0) && (data[0] != 1)) {\r\ncomedi_error(dev,\r\n"Not a valid Data !!! ,Data should be 1 or 0\n");\r\nreturn -EINVAL;\r\n}\r\nif (data[0]) {\r\ndevpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;\r\n}\r\nelse {\r\ndevpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;\r\n}\r\nif (data[1] == ADDIDATA_ENABLE) {\r\nul_Command = ul_Command | 0x1;\r\n}\r\nelse {\r\nul_Command = ul_Command & 0xFFFFFFFE;\r\n}\r\nif (data[2] == ADDIDATA_ENABLE) {\r\nul_Command = ul_Command | 0x2;\r\n}\r\nelse {\r\nul_Command = ul_Command & 0xFFFFFFFD;\r\n}\r\noutl(ul_Command, devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);\r\nui_InterruptData = inl(devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);\r\nreturn insn->n;\r\n}\r\nint i_APCI2032_WriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Temp, ui_Temp1;\r\nunsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);\r\nif (devpriv->b_OutputMemoryStatus) {\r\nui_Temp = inl(devpriv->iobase + APCI2032_DIGITAL_OP);\r\n}\r\nelse {\r\nui_Temp = 0;\r\n}\r\nif (data[3] == 0) {\r\nif (data[1] == 0) {\r\ndata[0] = (data[0] << ui_NoOfChannel) | ui_Temp;\r\noutl(data[0], devpriv->iobase + APCI2032_DIGITAL_OP);\r\n}\r\nelse {\r\nif (data[1] == 1) {\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\ndata[0] =\r\n(data[0] << (2 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 4:\r\ndata[0] =\r\n(data[0] << (4 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 8:\r\ndata[0] =\r\n(data[0] << (8 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 16:\r\ndata[0] =\r\n(data[0] << (16 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 31:\r\ndata[0] = data[0] | ui_Temp;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, " chan spec wrong");\r\nreturn -EINVAL;\r\n}\r\noutl(data[0],\r\ndevpriv->iobase + APCI2032_DIGITAL_OP);\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported\n");\r\n}\r\n}\r\n}\r\nelse {\r\nif (data[3] == 1) {\r\nif (data[1] == 0) {\r\ndata[0] = ~data[0] & 0x1;\r\nui_Temp1 = 1;\r\nui_Temp1 = ui_Temp1 << ui_NoOfChannel;\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n(data[0] << ui_NoOfChannel) ^\r\n0xffffffff;\r\ndata[0] = data[0] & ui_Temp;\r\noutl(data[0],\r\ndevpriv->iobase + APCI2032_DIGITAL_OP);\r\n}\r\nelse {\r\nif (data[1] == 1) {\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\ndata[0] = ~data[0] & 0x3;\r\nui_Temp1 = 3;\r\nui_Temp1 =\r\nui_Temp1 << 2 * data[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (2 *\r\ndata\r\n[2])) ^\r\n0xffffffff) & ui_Temp;\r\nbreak;\r\ncase 4:\r\ndata[0] = ~data[0] & 0xf;\r\nui_Temp1 = 15;\r\nui_Temp1 =\r\nui_Temp1 << 4 * data[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (4 *\r\ndata\r\n[2])) ^\r\n0xffffffff) & ui_Temp;\r\nbreak;\r\ncase 8:\r\ndata[0] = ~data[0] & 0xff;\r\nui_Temp1 = 255;\r\nui_Temp1 =\r\nui_Temp1 << 8 * data[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (8 *\r\ndata\r\n[2])) ^\r\n0xffffffff) & ui_Temp;\r\nbreak;\r\ncase 16:\r\ndata[0] = ~data[0] & 0xffff;\r\nui_Temp1 = 65535;\r\nui_Temp1 =\r\nui_Temp1 << 16 *\r\ndata[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (16 *\r\ndata\r\n[2])) ^\r\n0xffffffff) & ui_Temp;\r\nbreak;\r\ncase 31:\r\nbreak;\r\ndefault:\r\ncomedi_error(dev,\r\n" chan spec wrong");\r\nreturn -EINVAL;\r\n}\r\noutl(data[0],\r\ndevpriv->iobase +\r\nAPCI2032_DIGITAL_OP);\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported\n");\r\n}\r\n}\r\n}\r\nelse {\r\nprintk("\nSpecified functionality does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI2032_ReadDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Temp;\r\nunsigned int ui_NoOfChannel;\r\nui_NoOfChannel = CR_CHAN(insn->chanspec);\r\nui_Temp = data[0];\r\n*data = inl(devpriv->iobase + APCI2032_DIGITAL_OP_RW);\r\nif (ui_Temp == 0) {\r\n*data = (*data >> ui_NoOfChannel) & 0x1;\r\n}\r\nelse {\r\nif (ui_Temp == 1) {\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\n*data = (*data >> (2 * data[1])) & 3;\r\nbreak;\r\ncase 4:\r\n*data = (*data >> (4 * data[1])) & 15;\r\nbreak;\r\ncase 8:\r\n*data = (*data >> (8 * data[1])) & 255;\r\nbreak;\r\ncase 16:\r\n*data = (*data >> (16 * data[1])) & 65535;\r\nbreak;\r\ncase 31:\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, " chan spec wrong");\r\nreturn -EINVAL;\r\n}\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported \n");\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI2032_ConfigWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0] == 0) {\r\noutl(0x0,\r\ndevpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +\r\nAPCI2032_TCW_PROG);\r\noutl(data[1],\r\ndevpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +\r\nAPCI2032_TCW_RELOAD_VALUE);\r\n} else {\r\nprintk("\nThe input parameters are wrong\n");\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI2032_StartStopWriteWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase 0:\r\noutl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);\r\nbreak;\r\ncase 1:\r\noutl(0x0001,\r\ndevpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +\r\nAPCI2032_TCW_PROG);\r\nbreak;\r\ncase 2:\r\noutl(0x0201,\r\ndevpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +\r\nAPCI2032_TCW_PROG);\r\nbreak;\r\ndefault:\r\nprintk("\nSpecified functionality does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI2032_ReadWatchdog(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] =\r\ninl(devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG +\r\nAPCI2032_TCW_TRIG_STATUS) & 0x1;\r\nreturn insn->n;\r\n}\r\nvoid v_APCI2032_Interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned int ui_DO;\r\nui_DO = inl(devpriv->iobase + APCI2032_DIGITAL_OP_IRQ) & 0x1;\r\nif (ui_DO == 0) {\r\nprintk("\nInterrupt from unKnown source\n");\r\n}\r\nif (ui_DO) {\r\nui_Type =\r\ninl(devpriv->iobase +\r\nAPCI2032_DIGITAL_OP_INTERRUPT_STATUS) & 0x3;\r\noutl(0x0,\r\ndevpriv->iobase + APCI2032_DIGITAL_OP +\r\nAPCI2032_DIGITAL_OP_INTERRUPT);\r\nif (ui_Type == 1) {\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\n}\r\nelse {\r\nif (ui_Type == 2) {\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nint i_APCI2032_ReadInterruptStatus(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\n*data = ui_Type;\r\nreturn insn->n;\r\n}\r\nint i_APCI2032_Reset(struct comedi_device *dev)\r\n{\r\ndevpriv->b_DigitalOutputRegister = 0;\r\nui_Type = 0;\r\noutl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP);\r\noutl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_INTERRUPT);\r\noutl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_PROG);\r\noutl(0x0, devpriv->iobase + APCI2032_DIGITAL_OP_WATCHDOG + APCI2032_TCW_RELOAD_VALUE);\r\nreturn 0;\r\n}
