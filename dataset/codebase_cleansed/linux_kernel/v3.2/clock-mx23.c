static int _raw_clk_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nif (clk->enable_reg) {\r\nreg = __raw_readl(clk->enable_reg);\r\nreg &= ~(1 << clk->enable_shift);\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void _raw_clk_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nif (clk->enable_reg) {\r\nreg = __raw_readl(clk->enable_reg);\r\nreg |= 1 << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\n}\r\nstatic unsigned long ref_xtal_clk_get_rate(struct clk *clk)\r\n{\r\nreturn 24000000;\r\n}\r\nstatic unsigned long pll_clk_get_rate(struct clk *clk)\r\n{\r\nreturn 480000000;\r\n}\r\nstatic int pll_clk_enable(struct clk *clk)\r\n{\r\n__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER |\r\nBM_CLKCTRL_PLLCTRL0_EN_USB_CLKS,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_PLLCTRL0_SET);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic void pll_clk_disable(struct clk *clk)\r\n{\r\n__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER |\r\nBM_CLKCTRL_PLLCTRL0_EN_USB_CLKS,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_PLLCTRL0_CLR);\r\n}\r\nstatic unsigned long rtc_clk_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / 768;\r\n}\r\nstatic unsigned long clk32k_clk_get_rate(struct clk *clk)\r\n{\r\nreturn clk->parent->get_rate(clk->parent) / 750;\r\n}\r\nstatic int cpu_clk_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg, bm_busy, div_max, d, f, div, frac;\r\nunsigned long diff, parent_rate, calc_rate;\r\nint i;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (clk->parent == &ref_xtal_clk) {\r\ndiv_max = BM_CLKCTRL_CPU_DIV_XTAL >> BP_CLKCTRL_CPU_DIV_XTAL;\r\nbm_busy = BM_CLKCTRL_CPU_BUSY_REF_XTAL;\r\ndiv = DIV_ROUND_UP(parent_rate, rate);\r\nif (div == 0 || div > div_max)\r\nreturn -EINVAL;\r\n} else {\r\ndiv_max = BM_CLKCTRL_CPU_DIV_CPU >> BP_CLKCTRL_CPU_DIV_CPU;\r\nbm_busy = BM_CLKCTRL_CPU_BUSY_REF_CPU;\r\nrate >>= PARENT_RATE_SHIFT;\r\nparent_rate >>= PARENT_RATE_SHIFT;\r\ndiff = parent_rate;\r\ndiv = frac = 1;\r\nfor (d = 1; d <= div_max; d++) {\r\nf = parent_rate * 18 / d / rate;\r\nif ((parent_rate * 18 / d) % rate)\r\nf++;\r\nif (f < 18 || f > 35)\r\ncontinue;\r\ncalc_rate = parent_rate * 18 / f / d;\r\nif (calc_rate > rate)\r\ncontinue;\r\nif (rate - calc_rate < diff) {\r\nfrac = f;\r\ndiv = d;\r\ndiff = rate - calc_rate;\r\n}\r\nif (diff == 0)\r\nbreak;\r\n}\r\nif (diff == parent_rate)\r\nreturn -EINVAL;\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);\r\nreg &= ~BM_CLKCTRL_FRAC_CPUFRAC;\r\nreg |= frac;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);\r\n}\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);\r\nreg &= ~BM_CLKCTRL_CPU_DIV_CPU;\r\nreg |= div << BP_CLKCTRL_CPU_DIV_CPU;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);\r\nfor (i = 10000; i; i--)\r\nif (!(__raw_readl(CLKCTRL_BASE_ADDR +\r\nHW_CLKCTRL_CPU) & bm_busy))\r\nbreak;\r\nif (!i) {\r\npr_err("%s: divider writing timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int clk_misc_init(void)\r\n{\r\nu32 reg;\r\nint i;\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);\r\ncpu_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_CPU) ?\r\n&ref_xtal_clk : &ref_cpu_clk;\r\nemi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_EMI) ?\r\n&ref_xtal_clk : &ref_emi_clk;\r\nssp_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP) ?\r\n&ref_xtal_clk : &ref_io_clk;\r\ngpmi_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_GPMI) ?\r\n&ref_xtal_clk : &ref_io_clk;\r\nlcdif_clk.parent = (reg & BM_CLKCTRL_CLKSEQ_BYPASS_PIX) ?\r\n&ref_xtal_clk : &ref_pix_clk;\r\n__raw_writel(BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);\r\n__raw_writel(BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_CLR);\r\n__raw_writel(BM_CLKCTRL_HBUS_DIV_FRAC_EN,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_CLR);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);\r\nreg &= ~BM_CLKCTRL_XBUS_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP);\r\nreg &= ~BM_CLKCTRL_SSP_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);\r\nreg &= ~BM_CLKCTRL_GPMI_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_PIX);\r\nreg &= ~BM_CLKCTRL_PIX_DIV_FRAC_EN;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_PIX);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);\r\nreg &= BM_CLKCTRL_HBUS_DIV;\r\nreg |= 3 << BP_CLKCTRL_HBUS_DIV;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);\r\nfor (i = 10000; i; i--)\r\nif (!(__raw_readl(CLKCTRL_BASE_ADDR +\r\nHW_CLKCTRL_HBUS) & BM_CLKCTRL_HBUS_BUSY))\r\nbreak;\r\nif (!i) {\r\npr_err("%s: divider writing timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\n__raw_writel(BM_CLKCTRL_CPU_INTERRUPT_WAIT,\r\nCLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU_SET);\r\nreg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);\r\nreg &= ~BM_CLKCTRL_FRAC_IOFRAC;\r\nreg |= 30 << BP_CLKCTRL_FRAC_IOFRAC;\r\n__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);\r\nreturn 0;\r\n}\r\nint __init mx23_clocks_init(void)\r\n{\r\nclk_misc_init();\r\nclk_set_parent(&ssp_clk, &ref_io_clk);\r\nclk_enable(&cpu_clk);\r\nclk_enable(&hbus_clk);\r\nclk_enable(&xbus_clk);\r\nclk_enable(&emi_clk);\r\nclk_enable(&uart_clk);\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nmxs_timer_init(&clk32k_clk, MX23_INT_TIMER0);\r\nreturn 0;\r\n}
