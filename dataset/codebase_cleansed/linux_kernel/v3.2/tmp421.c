static int temp_from_s16(s16 reg)\r\n{\r\nint temp = reg & ~0xf;\r\nreturn (temp * 1000 + 128) / 256;\r\n}\r\nstatic int temp_from_u16(u16 reg)\r\n{\r\nint temp = reg & ~0xf;\r\ntemp -= 64 * 256;\r\nreturn (temp * 1000 + 128) / 256;\r\n}\r\nstatic struct tmp421_data *tmp421_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tmp421_data *data = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + 2 * HZ) || !data->valid) {\r\ndata->config = i2c_smbus_read_byte_data(client,\r\nTMP421_CONFIG_REG_1);\r\nfor (i = 0; i < data->channels; i++) {\r\ndata->temp[i] = i2c_smbus_read_byte_data(client,\r\nTMP421_TEMP_MSB[i]) << 8;\r\ndata->temp[i] |= i2c_smbus_read_byte_data(client,\r\nTMP421_TEMP_LSB[i]);\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_temp_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp421_data *data = tmp421_update_device(dev);\r\nint temp;\r\nmutex_lock(&data->update_lock);\r\nif (data->config & TMP421_CONFIG_RANGE)\r\ntemp = temp_from_u16(data->temp[index]);\r\nelse\r\ntemp = temp_from_s16(data->temp[index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t show_fault(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp421_data *data = tmp421_update_device(dev);\r\nif (data->temp[index] & 0x01)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic mode_t tmp421_is_visible(struct kobject *kobj, struct attribute *a,\r\nint n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct tmp421_data *data = dev_get_drvdata(dev);\r\nstruct device_attribute *devattr;\r\nunsigned int index;\r\ndevattr = container_of(a, struct device_attribute, attr);\r\nindex = to_sensor_dev_attr(devattr)->index;\r\nif (index < data->channels)\r\nreturn a->mode;\r\nreturn 0;\r\n}\r\nstatic int tmp421_init_client(struct i2c_client *client)\r\n{\r\nint config, config_orig;\r\ni2c_smbus_write_byte_data(client, TMP421_CONVERSION_RATE_REG, 0x05);\r\nconfig = i2c_smbus_read_byte_data(client, TMP421_CONFIG_REG_1);\r\nif (config < 0) {\r\ndev_err(&client->dev, "Could not read configuration"\r\n" register (%d)\n", config);\r\nreturn -ENODEV;\r\n}\r\nconfig_orig = config;\r\nconfig &= ~TMP421_CONFIG_SHUTDOWN;\r\nif (config != config_orig) {\r\ndev_info(&client->dev, "Enable monitoring chip\n");\r\ni2c_smbus_write_byte_data(client, TMP421_CONFIG_REG_1, config);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tmp421_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nenum chips kind;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nconst char *names[] = { "TMP421", "TMP422", "TMP423" };\r\nu8 reg;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP421_MANUFACTURER_ID_REG);\r\nif (reg != TMP421_MANUFACTURER_ID)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP421_DEVICE_ID_REG);\r\nswitch (reg) {\r\ncase TMP421_DEVICE_ID:\r\nkind = tmp421;\r\nbreak;\r\ncase TMP422_DEVICE_ID:\r\nkind = tmp422;\r\nbreak;\r\ncase TMP423_DEVICE_ID:\r\nkind = tmp423;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, tmp421_id[kind].name, I2C_NAME_SIZE);\r\ndev_info(&adapter->dev, "Detected TI %s chip at 0x%02x\n",\r\nnames[kind], client->addr);\r\nreturn 0;\r\n}\r\nstatic int tmp421_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tmp421_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct tmp421_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->channels = id->driver_data;\r\nerr = tmp421_init_client(client);\r\nif (err)\r\ngoto exit_free;\r\nerr = sysfs_create_group(&client->dev.kobj, &tmp421_group);\r\nif (err)\r\ngoto exit_free;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndata->hwmon_dev = NULL;\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &tmp421_group);\r\nexit_free:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int tmp421_remove(struct i2c_client *client)\r\n{\r\nstruct tmp421_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &tmp421_group);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init tmp421_init(void)\r\n{\r\nreturn i2c_add_driver(&tmp421_driver);\r\n}\r\nstatic void __exit tmp421_exit(void)\r\n{\r\ni2c_del_driver(&tmp421_driver);\r\n}
