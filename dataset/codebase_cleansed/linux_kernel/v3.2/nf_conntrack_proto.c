static int\r\nnf_ct_register_sysctl(struct ctl_table_header **header, struct ctl_path *path,\r\nstruct ctl_table *table, unsigned int *users)\r\n{\r\nif (*header == NULL) {\r\n*header = register_sysctl_paths(path, table);\r\nif (*header == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (users != NULL)\r\n(*users)++;\r\nreturn 0;\r\n}\r\nstatic void\r\nnf_ct_unregister_sysctl(struct ctl_table_header **header,\r\nstruct ctl_table *table, unsigned int *users)\r\n{\r\nif (users != NULL && --*users > 0)\r\nreturn;\r\nunregister_sysctl_table(*header);\r\n*header = NULL;\r\n}\r\nstruct nf_conntrack_l4proto *\r\n__nf_ct_l4proto_find(u_int16_t l3proto, u_int8_t l4proto)\r\n{\r\nif (unlikely(l3proto >= AF_MAX || nf_ct_protos[l3proto] == NULL))\r\nreturn &nf_conntrack_l4proto_generic;\r\nreturn rcu_dereference(nf_ct_protos[l3proto][l4proto]);\r\n}\r\nstruct nf_conntrack_l3proto *\r\nnf_ct_l3proto_find_get(u_int16_t l3proto)\r\n{\r\nstruct nf_conntrack_l3proto *p;\r\nrcu_read_lock();\r\np = __nf_ct_l3proto_find(l3proto);\r\nif (!try_module_get(p->me))\r\np = &nf_conntrack_l3proto_generic;\r\nrcu_read_unlock();\r\nreturn p;\r\n}\r\nvoid nf_ct_l3proto_put(struct nf_conntrack_l3proto *p)\r\n{\r\nmodule_put(p->me);\r\n}\r\nint\r\nnf_ct_l3proto_try_module_get(unsigned short l3proto)\r\n{\r\nint ret;\r\nstruct nf_conntrack_l3proto *p;\r\nretry: p = nf_ct_l3proto_find_get(l3proto);\r\nif (p == &nf_conntrack_l3proto_generic) {\r\nret = request_module("nf_conntrack-%d", l3proto);\r\nif (!ret)\r\ngoto retry;\r\nreturn -EPROTOTYPE;\r\n}\r\nreturn 0;\r\n}\r\nvoid nf_ct_l3proto_module_put(unsigned short l3proto)\r\n{\r\nstruct nf_conntrack_l3proto *p;\r\nrcu_read_lock();\r\np = __nf_ct_l3proto_find(l3proto);\r\nmodule_put(p->me);\r\nrcu_read_unlock();\r\n}\r\nstatic int kill_l3proto(struct nf_conn *i, void *data)\r\n{\r\nreturn nf_ct_l3num(i) == ((struct nf_conntrack_l3proto *)data)->l3proto;\r\n}\r\nstatic int kill_l4proto(struct nf_conn *i, void *data)\r\n{\r\nstruct nf_conntrack_l4proto *l4proto;\r\nl4proto = (struct nf_conntrack_l4proto *)data;\r\nreturn nf_ct_protonum(i) == l4proto->l4proto &&\r\nnf_ct_l3num(i) == l4proto->l3proto;\r\n}\r\nstatic int nf_ct_l3proto_register_sysctl(struct nf_conntrack_l3proto *l3proto)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_SYSCTL\r\nif (l3proto->ctl_table != NULL) {\r\nerr = nf_ct_register_sysctl(&l3proto->ctl_table_header,\r\nl3proto->ctl_table_path,\r\nl3proto->ctl_table, NULL);\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic void nf_ct_l3proto_unregister_sysctl(struct nf_conntrack_l3proto *l3proto)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (l3proto->ctl_table_header != NULL)\r\nnf_ct_unregister_sysctl(&l3proto->ctl_table_header,\r\nl3proto->ctl_table, NULL);\r\n#endif\r\n}\r\nint nf_conntrack_l3proto_register(struct nf_conntrack_l3proto *proto)\r\n{\r\nint ret = 0;\r\nstruct nf_conntrack_l3proto *old;\r\nif (proto->l3proto >= AF_MAX)\r\nreturn -EBUSY;\r\nif (proto->tuple_to_nlattr && !proto->nlattr_tuple_size)\r\nreturn -EINVAL;\r\nmutex_lock(&nf_ct_proto_mutex);\r\nold = rcu_dereference_protected(nf_ct_l3protos[proto->l3proto],\r\nlockdep_is_held(&nf_ct_proto_mutex));\r\nif (old != &nf_conntrack_l3proto_generic) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nret = nf_ct_l3proto_register_sysctl(proto);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nif (proto->nlattr_tuple_size)\r\nproto->nla_size = 3 * proto->nlattr_tuple_size();\r\nrcu_assign_pointer(nf_ct_l3protos[proto->l3proto], proto);\r\nout_unlock:\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nreturn ret;\r\n}\r\nvoid nf_conntrack_l3proto_unregister(struct nf_conntrack_l3proto *proto)\r\n{\r\nstruct net *net;\r\nBUG_ON(proto->l3proto >= AF_MAX);\r\nmutex_lock(&nf_ct_proto_mutex);\r\nBUG_ON(rcu_dereference_protected(nf_ct_l3protos[proto->l3proto],\r\nlockdep_is_held(&nf_ct_proto_mutex)\r\n) != proto);\r\nrcu_assign_pointer(nf_ct_l3protos[proto->l3proto],\r\n&nf_conntrack_l3proto_generic);\r\nnf_ct_l3proto_unregister_sysctl(proto);\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nsynchronize_rcu();\r\nrtnl_lock();\r\nfor_each_net(net)\r\nnf_ct_iterate_cleanup(net, kill_l3proto, proto);\r\nrtnl_unlock();\r\n}\r\nstatic int nf_ct_l4proto_register_sysctl(struct nf_conntrack_l4proto *l4proto)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_SYSCTL\r\nif (l4proto->ctl_table != NULL) {\r\nerr = nf_ct_register_sysctl(l4proto->ctl_table_header,\r\nnf_net_netfilter_sysctl_path,\r\nl4proto->ctl_table,\r\nl4proto->ctl_table_users);\r\nif (err < 0)\r\ngoto out;\r\n}\r\n#ifdef CONFIG_NF_CONNTRACK_PROC_COMPAT\r\nif (l4proto->ctl_compat_table != NULL) {\r\nerr = nf_ct_register_sysctl(&l4proto->ctl_compat_table_header,\r\nnf_net_ipv4_netfilter_sysctl_path,\r\nl4proto->ctl_compat_table, NULL);\r\nif (err == 0)\r\ngoto out;\r\nnf_ct_unregister_sysctl(l4proto->ctl_table_header,\r\nl4proto->ctl_table,\r\nl4proto->ctl_table_users);\r\n}\r\n#endif\r\nout:\r\n#endif\r\nreturn err;\r\n}\r\nstatic void nf_ct_l4proto_unregister_sysctl(struct nf_conntrack_l4proto *l4proto)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (l4proto->ctl_table_header != NULL &&\r\n*l4proto->ctl_table_header != NULL)\r\nnf_ct_unregister_sysctl(l4proto->ctl_table_header,\r\nl4proto->ctl_table,\r\nl4proto->ctl_table_users);\r\n#ifdef CONFIG_NF_CONNTRACK_PROC_COMPAT\r\nif (l4proto->ctl_compat_table_header != NULL)\r\nnf_ct_unregister_sysctl(&l4proto->ctl_compat_table_header,\r\nl4proto->ctl_compat_table, NULL);\r\n#endif\r\n#endif\r\n}\r\nint nf_conntrack_l4proto_register(struct nf_conntrack_l4proto *l4proto)\r\n{\r\nint ret = 0;\r\nif (l4proto->l3proto >= PF_MAX)\r\nreturn -EBUSY;\r\nif ((l4proto->to_nlattr && !l4proto->nlattr_size)\r\n|| (l4proto->tuple_to_nlattr && !l4proto->nlattr_tuple_size))\r\nreturn -EINVAL;\r\nmutex_lock(&nf_ct_proto_mutex);\r\nif (!nf_ct_protos[l4proto->l3proto]) {\r\nstruct nf_conntrack_l4proto __rcu **proto_array;\r\nint i;\r\nproto_array = kmalloc(MAX_NF_CT_PROTO *\r\nsizeof(struct nf_conntrack_l4proto *),\r\nGFP_KERNEL);\r\nif (proto_array == NULL) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < MAX_NF_CT_PROTO; i++)\r\nRCU_INIT_POINTER(proto_array[i], &nf_conntrack_l4proto_generic);\r\nsmp_wmb();\r\nnf_ct_protos[l4proto->l3proto] = proto_array;\r\n} else if (rcu_dereference_protected(\r\nnf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\nlockdep_is_held(&nf_ct_proto_mutex)\r\n) != &nf_conntrack_l4proto_generic) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nret = nf_ct_l4proto_register_sysctl(l4proto);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nl4proto->nla_size = 0;\r\nif (l4proto->nlattr_size)\r\nl4proto->nla_size += l4proto->nlattr_size();\r\nif (l4proto->nlattr_tuple_size)\r\nl4proto->nla_size += 3 * l4proto->nlattr_tuple_size();\r\nrcu_assign_pointer(nf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\nl4proto);\r\nout_unlock:\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nreturn ret;\r\n}\r\nvoid nf_conntrack_l4proto_unregister(struct nf_conntrack_l4proto *l4proto)\r\n{\r\nstruct net *net;\r\nBUG_ON(l4proto->l3proto >= PF_MAX);\r\nmutex_lock(&nf_ct_proto_mutex);\r\nBUG_ON(rcu_dereference_protected(\r\nnf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\nlockdep_is_held(&nf_ct_proto_mutex)\r\n) != l4proto);\r\nrcu_assign_pointer(nf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\n&nf_conntrack_l4proto_generic);\r\nnf_ct_l4proto_unregister_sysctl(l4proto);\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nsynchronize_rcu();\r\nrtnl_lock();\r\nfor_each_net(net)\r\nnf_ct_iterate_cleanup(net, kill_l4proto, l4proto);\r\nrtnl_unlock();\r\n}\r\nint nf_conntrack_proto_init(void)\r\n{\r\nunsigned int i;\r\nint err;\r\nerr = nf_ct_l4proto_register_sysctl(&nf_conntrack_l4proto_generic);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < AF_MAX; i++)\r\nrcu_assign_pointer(nf_ct_l3protos[i],\r\n&nf_conntrack_l3proto_generic);\r\nreturn 0;\r\n}\r\nvoid nf_conntrack_proto_fini(void)\r\n{\r\nunsigned int i;\r\nnf_ct_l4proto_unregister_sysctl(&nf_conntrack_l4proto_generic);\r\nfor (i = 0; i < PF_MAX; i++)\r\nkfree(nf_ct_protos[i]);\r\n}
