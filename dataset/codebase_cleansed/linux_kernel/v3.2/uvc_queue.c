void uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,\r\nint drop_corrupted)\r\n{\r\nmutex_init(&queue->mutex);\r\nspin_lock_init(&queue->irqlock);\r\nINIT_LIST_HEAD(&queue->mainqueue);\r\nINIT_LIST_HEAD(&queue->irqqueue);\r\nqueue->flags = drop_corrupted ? UVC_QUEUE_DROP_CORRUPTED : 0;\r\nqueue->type = type;\r\n}\r\nstatic int __uvc_free_buffers(struct uvc_video_queue *queue)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < queue->count; ++i) {\r\nif (queue->buffer[i].vma_use_count != 0)\r\nreturn -EBUSY;\r\n}\r\nif (queue->count) {\r\nuvc_queue_cancel(queue, 0);\r\nINIT_LIST_HEAD(&queue->mainqueue);\r\nvfree(queue->mem);\r\nqueue->count = 0;\r\n}\r\nreturn 0;\r\n}\r\nint uvc_free_buffers(struct uvc_video_queue *queue)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = __uvc_free_buffers(queue);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_alloc_buffers(struct uvc_video_queue *queue, unsigned int nbuffers,\r\nunsigned int buflength)\r\n{\r\nunsigned int bufsize = PAGE_ALIGN(buflength);\r\nunsigned int i;\r\nvoid *mem = NULL;\r\nint ret;\r\nif (nbuffers > UVC_MAX_VIDEO_BUFFERS)\r\nnbuffers = UVC_MAX_VIDEO_BUFFERS;\r\nmutex_lock(&queue->mutex);\r\nif ((ret = __uvc_free_buffers(queue)) < 0)\r\ngoto done;\r\nif (nbuffers == 0)\r\ngoto done;\r\nfor (; nbuffers > 0; --nbuffers) {\r\nmem = vmalloc_32(nbuffers * bufsize);\r\nif (mem != NULL)\r\nbreak;\r\n}\r\nif (mem == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nfor (i = 0; i < nbuffers; ++i) {\r\nmemset(&queue->buffer[i], 0, sizeof queue->buffer[i]);\r\nqueue->buffer[i].buf.index = i;\r\nqueue->buffer[i].buf.m.offset = i * bufsize;\r\nqueue->buffer[i].buf.length = buflength;\r\nqueue->buffer[i].buf.type = queue->type;\r\nqueue->buffer[i].buf.field = V4L2_FIELD_NONE;\r\nqueue->buffer[i].buf.memory = V4L2_MEMORY_MMAP;\r\nqueue->buffer[i].buf.flags = 0;\r\ninit_waitqueue_head(&queue->buffer[i].wait);\r\n}\r\nqueue->mem = mem;\r\nqueue->count = nbuffers;\r\nqueue->buf_size = bufsize;\r\nret = nbuffers;\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_allocated(struct uvc_video_queue *queue)\r\n{\r\nint allocated;\r\nmutex_lock(&queue->mutex);\r\nallocated = queue->count != 0;\r\nmutex_unlock(&queue->mutex);\r\nreturn allocated;\r\n}\r\nstatic void __uvc_query_buffer(struct uvc_buffer *buf,\r\nstruct v4l2_buffer *v4l2_buf)\r\n{\r\nmemcpy(v4l2_buf, &buf->buf, sizeof *v4l2_buf);\r\nif (buf->vma_use_count)\r\nv4l2_buf->flags |= V4L2_BUF_FLAG_MAPPED;\r\nswitch (buf->state) {\r\ncase UVC_BUF_STATE_ERROR:\r\ncase UVC_BUF_STATE_DONE:\r\nv4l2_buf->flags |= V4L2_BUF_FLAG_DONE;\r\nbreak;\r\ncase UVC_BUF_STATE_QUEUED:\r\ncase UVC_BUF_STATE_ACTIVE:\r\ncase UVC_BUF_STATE_READY:\r\nv4l2_buf->flags |= V4L2_BUF_FLAG_QUEUED;\r\nbreak;\r\ncase UVC_BUF_STATE_IDLE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint uvc_query_buffer(struct uvc_video_queue *queue,\r\nstruct v4l2_buffer *v4l2_buf)\r\n{\r\nint ret = 0;\r\nmutex_lock(&queue->mutex);\r\nif (v4l2_buf->index >= queue->count) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n__uvc_query_buffer(&queue->buffer[v4l2_buf->index], v4l2_buf);\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_buffer(struct uvc_video_queue *queue,\r\nstruct v4l2_buffer *v4l2_buf)\r\n{\r\nstruct uvc_buffer *buf;\r\nunsigned long flags;\r\nint ret = 0;\r\nuvc_trace(UVC_TRACE_CAPTURE, "Queuing buffer %u.\n", v4l2_buf->index);\r\nif (v4l2_buf->type != queue->type ||\r\nv4l2_buf->memory != V4L2_MEMORY_MMAP) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Invalid buffer type (%u) "\r\n"and/or memory (%u).\n", v4l2_buf->type,\r\nv4l2_buf->memory);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&queue->mutex);\r\nif (v4l2_buf->index >= queue->count) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Out of range index.\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbuf = &queue->buffer[v4l2_buf->index];\r\nif (buf->state != UVC_BUF_STATE_IDLE) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Invalid buffer state "\r\n"(%u).\n", buf->state);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (v4l2_buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\nv4l2_buf->bytesused > buf->buf.length) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Bytes used out of bounds.\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nif (queue->flags & UVC_QUEUE_DISCONNECTED) {\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nif (v4l2_buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nbuf->buf.bytesused = 0;\r\nelse\r\nbuf->buf.bytesused = v4l2_buf->bytesused;\r\nlist_add_tail(&buf->stream, &queue->mainqueue);\r\nlist_add_tail(&buf->queue, &queue->irqqueue);\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nstatic int uvc_queue_waiton(struct uvc_buffer *buf, int nonblocking)\r\n{\r\nif (nonblocking) {\r\nreturn (buf->state != UVC_BUF_STATE_QUEUED &&\r\nbuf->state != UVC_BUF_STATE_ACTIVE &&\r\nbuf->state != UVC_BUF_STATE_READY)\r\n? 0 : -EAGAIN;\r\n}\r\nreturn wait_event_interruptible(buf->wait,\r\nbuf->state != UVC_BUF_STATE_QUEUED &&\r\nbuf->state != UVC_BUF_STATE_ACTIVE &&\r\nbuf->state != UVC_BUF_STATE_READY);\r\n}\r\nint uvc_dequeue_buffer(struct uvc_video_queue *queue,\r\nstruct v4l2_buffer *v4l2_buf, int nonblocking)\r\n{\r\nstruct uvc_buffer *buf;\r\nint ret = 0;\r\nif (v4l2_buf->type != queue->type ||\r\nv4l2_buf->memory != V4L2_MEMORY_MMAP) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Invalid buffer type (%u) "\r\n"and/or memory (%u).\n", v4l2_buf->type,\r\nv4l2_buf->memory);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&queue->mutex);\r\nif (list_empty(&queue->mainqueue)) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Empty buffer queue.\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbuf = list_first_entry(&queue->mainqueue, struct uvc_buffer, stream);\r\nif ((ret = uvc_queue_waiton(buf, nonblocking)) < 0)\r\ngoto done;\r\nuvc_trace(UVC_TRACE_CAPTURE, "Dequeuing buffer %u (%u, %u bytes).\n",\r\nbuf->buf.index, buf->state, buf->buf.bytesused);\r\nswitch (buf->state) {\r\ncase UVC_BUF_STATE_ERROR:\r\nuvc_trace(UVC_TRACE_CAPTURE, "[W] Corrupted data "\r\n"(transmission error).\n");\r\nret = -EIO;\r\ncase UVC_BUF_STATE_DONE:\r\nbuf->state = UVC_BUF_STATE_IDLE;\r\nbreak;\r\ncase UVC_BUF_STATE_IDLE:\r\ncase UVC_BUF_STATE_QUEUED:\r\ncase UVC_BUF_STATE_ACTIVE:\r\ncase UVC_BUF_STATE_READY:\r\ndefault:\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Invalid buffer state %u "\r\n"(driver bug?).\n", buf->state);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nlist_del(&buf->stream);\r\n__uvc_query_buffer(buf, v4l2_buf);\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nstatic void uvc_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct uvc_buffer *buffer = vma->vm_private_data;\r\nbuffer->vma_use_count++;\r\n}\r\nstatic void uvc_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct uvc_buffer *buffer = vma->vm_private_data;\r\nbuffer->vma_use_count--;\r\n}\r\nint uvc_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma)\r\n{\r\nstruct uvc_buffer *uninitialized_var(buffer);\r\nstruct page *page;\r\nunsigned long addr, start, size;\r\nunsigned int i;\r\nint ret = 0;\r\nstart = vma->vm_start;\r\nsize = vma->vm_end - vma->vm_start;\r\nmutex_lock(&queue->mutex);\r\nfor (i = 0; i < queue->count; ++i) {\r\nbuffer = &queue->buffer[i];\r\nif ((buffer->buf.m.offset >> PAGE_SHIFT) == vma->vm_pgoff)\r\nbreak;\r\n}\r\nif (i == queue->count || PAGE_ALIGN(size) != queue->buf_size) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nvma->vm_flags |= VM_IO;\r\naddr = (unsigned long)queue->mem + buffer->buf.m.offset;\r\n#ifdef CONFIG_MMU\r\nwhile (size > 0) {\r\npage = vmalloc_to_page((void *)addr);\r\nif ((ret = vm_insert_page(vma, start, page)) < 0)\r\ngoto done;\r\nstart += PAGE_SIZE;\r\naddr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\n#endif\r\nvma->vm_ops = &uvc_vm_ops;\r\nvma->vm_private_data = buffer;\r\nuvc_vm_open(vma);\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nunsigned int uvc_queue_poll(struct uvc_video_queue *queue, struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct uvc_buffer *buf;\r\nunsigned int mask = 0;\r\nmutex_lock(&queue->mutex);\r\nif (list_empty(&queue->mainqueue)) {\r\nmask |= POLLERR;\r\ngoto done;\r\n}\r\nbuf = list_first_entry(&queue->mainqueue, struct uvc_buffer, stream);\r\npoll_wait(file, &buf->wait, wait);\r\nif (buf->state == UVC_BUF_STATE_DONE ||\r\nbuf->state == UVC_BUF_STATE_ERROR) {\r\nif (queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nmask |= POLLIN | POLLRDNORM;\r\nelse\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn mask;\r\n}\r\nunsigned long uvc_queue_get_unmapped_area(struct uvc_video_queue *queue,\r\nunsigned long pgoff)\r\n{\r\nstruct uvc_buffer *buffer;\r\nunsigned int i;\r\nunsigned long ret;\r\nmutex_lock(&queue->mutex);\r\nfor (i = 0; i < queue->count; ++i) {\r\nbuffer = &queue->buffer[i];\r\nif ((buffer->buf.m.offset >> PAGE_SHIFT) == pgoff)\r\nbreak;\r\n}\r\nif (i == queue->count) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = (unsigned long)queue->mem + buffer->buf.m.offset;\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_enable(struct uvc_video_queue *queue, int enable)\r\n{\r\nunsigned int i;\r\nint ret = 0;\r\nmutex_lock(&queue->mutex);\r\nif (enable) {\r\nif (uvc_queue_streaming(queue)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nqueue->flags |= UVC_QUEUE_STREAMING;\r\nqueue->buf_used = 0;\r\n} else {\r\nuvc_queue_cancel(queue, 0);\r\nINIT_LIST_HEAD(&queue->mainqueue);\r\nfor (i = 0; i < queue->count; ++i) {\r\nqueue->buffer[i].error = 0;\r\nqueue->buffer[i].state = UVC_BUF_STATE_IDLE;\r\n}\r\nqueue->flags &= ~UVC_QUEUE_STREAMING;\r\n}\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nvoid uvc_queue_cancel(struct uvc_video_queue *queue, int disconnect)\r\n{\r\nstruct uvc_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nwhile (!list_empty(&queue->irqqueue)) {\r\nbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nlist_del(&buf->queue);\r\nbuf->state = UVC_BUF_STATE_ERROR;\r\nwake_up(&buf->wait);\r\n}\r\nif (disconnect)\r\nqueue->flags |= UVC_QUEUE_DISCONNECTED;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nstruct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,\r\nstruct uvc_buffer *buf)\r\n{\r\nstruct uvc_buffer *nextbuf;\r\nunsigned long flags;\r\nif ((queue->flags & UVC_QUEUE_DROP_CORRUPTED) && buf->error) {\r\nbuf->error = 0;\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nbuf->buf.bytesused = 0;\r\nreturn buf;\r\n}\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nlist_del(&buf->queue);\r\nbuf->error = 0;\r\nbuf->state = UVC_BUF_STATE_DONE;\r\nif (!list_empty(&queue->irqqueue))\r\nnextbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nelse\r\nnextbuf = NULL;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\nwake_up(&buf->wait);\r\nreturn nextbuf;\r\n}
