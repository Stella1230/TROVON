int handle_kernel_fault(struct pt_regs *regs)\r\n{\r\nconst struct exception_table_entry *fixup;\r\nstruct pt_regs *tregs;\r\nfixup = search_exception_tables(regs->pc);\r\nif (!fixup)\r\nreturn 0;\r\nregs->stkadj = frame_extra_sizes[regs->format];\r\ntregs = (struct pt_regs *)((long)regs + regs->stkadj);\r\ntregs->vector = regs->vector;\r\ntregs->format = 0;\r\ntregs->pc = fixup->fixup;\r\ntregs->sr = regs->sr;\r\nreturn 1;\r\n}\r\nasmlinkage int\r\nsys_sigsuspend(int unused0, int unused1, old_sigset_t mask)\r\n{\r\nmask &= _BLOCKABLE;\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->saved_sigmask = current->blocked;\r\nsiginitset(&current->blocked, mask);\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule();\r\nset_restore_sigmask();\r\nreturn -ERESTARTNOHAND;\r\n}\r\nasmlinkage int\r\nsys_sigaction(int sig, const struct old_sigaction __user *act,\r\nstruct old_sigaction __user *oact)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\nif (act) {\r\nold_sigset_t mask;\r\nif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\r\n__get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\r\n__get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\r\n__get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\r\n__get_user(mask, &act->sa_mask))\r\nreturn -EFAULT;\r\nsiginitset(&new_ka.sa.sa_mask, mask);\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\r\n__put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\r\n__put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\r\n__put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\r\n__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage int\r\nsys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)\r\n{\r\nreturn do_sigaltstack(uss, uoss, rdusp());\r\n}\r\nstatic inline int restore_fpu_state(struct sigcontext *sc)\r\n{\r\nint err = 1;\r\nif (FPU_IS_EMU) {\r\nmemcpy(current->thread.fpcntl, sc->sc_fpcntl, 12);\r\nmemcpy(current->thread.fp, sc->sc_fpregs, 24);\r\nreturn 0;\r\n}\r\nif (CPU_IS_060 ? sc->sc_fpstate[2] : sc->sc_fpstate[0]) {\r\nif (!CPU_IS_060 && (sc->sc_fpstate[0] != fpu_version))\r\ngoto out;\r\nif (CPU_IS_020_OR_030) {\r\nif (m68k_fputype & FPU_68881 &&\r\n!(sc->sc_fpstate[1] == 0x18 || sc->sc_fpstate[1] == 0xb4))\r\ngoto out;\r\nif (m68k_fputype & FPU_68882 &&\r\n!(sc->sc_fpstate[1] == 0x38 || sc->sc_fpstate[1] == 0xd4))\r\ngoto out;\r\n} else if (CPU_IS_040) {\r\nif (!(sc->sc_fpstate[1] == 0x00 ||\r\nsc->sc_fpstate[1] == 0x28 ||\r\nsc->sc_fpstate[1] == 0x60))\r\ngoto out;\r\n} else if (CPU_IS_060) {\r\nif (!(sc->sc_fpstate[3] == 0x00 ||\r\nsc->sc_fpstate[3] == 0x60 ||\r\nsc->sc_fpstate[3] == 0xe0))\r\ngoto out;\r\n} else\r\ngoto out;\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %0,%%fp0-%%fp1\n\t"\r\n"fmoveml %1,%%fpcr/%%fpsr/%%fpiar\n\t"\r\n".chip 68k"\r\n:\r\n: "m" (*sc->sc_fpregs), "m" (*sc->sc_fpcntl));\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"frestore %0\n\t"\r\n".chip 68k" : : "m" (*sc->sc_fpstate));\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic inline int rt_restore_fpu_state(struct ucontext __user *uc)\r\n{\r\nunsigned char fpstate[FPCONTEXT_SIZE];\r\nint context_size = CPU_IS_060 ? 8 : 0;\r\nfpregset_t fpregs;\r\nint err = 1;\r\nif (FPU_IS_EMU) {\r\nif (__copy_from_user(current->thread.fpcntl,\r\nuc->uc_mcontext.fpregs.f_fpcntl, 12))\r\ngoto out;\r\nif (__copy_from_user(current->thread.fp,\r\nuc->uc_mcontext.fpregs.f_fpregs, 96))\r\ngoto out;\r\nreturn 0;\r\n}\r\nif (__get_user(*(long *)fpstate, (long __user *)&uc->uc_fpstate))\r\ngoto out;\r\nif (CPU_IS_060 ? fpstate[2] : fpstate[0]) {\r\nif (!CPU_IS_060)\r\ncontext_size = fpstate[1];\r\nif (!CPU_IS_060 && (fpstate[0] != fpu_version))\r\ngoto out;\r\nif (CPU_IS_020_OR_030) {\r\nif (m68k_fputype & FPU_68881 &&\r\n!(context_size == 0x18 || context_size == 0xb4))\r\ngoto out;\r\nif (m68k_fputype & FPU_68882 &&\r\n!(context_size == 0x38 || context_size == 0xd4))\r\ngoto out;\r\n} else if (CPU_IS_040) {\r\nif (!(context_size == 0x00 ||\r\ncontext_size == 0x28 ||\r\ncontext_size == 0x60))\r\ngoto out;\r\n} else if (CPU_IS_060) {\r\nif (!(fpstate[3] == 0x00 ||\r\nfpstate[3] == 0x60 ||\r\nfpstate[3] == 0xe0))\r\ngoto out;\r\n} else\r\ngoto out;\r\nif (__copy_from_user(&fpregs, &uc->uc_mcontext.fpregs,\r\nsizeof(fpregs)))\r\ngoto out;\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %0,%%fp0-%%fp7\n\t"\r\n"fmoveml %1,%%fpcr/%%fpsr/%%fpiar\n\t"\r\n".chip 68k"\r\n:\r\n: "m" (*fpregs.f_fpregs),\r\n"m" (*fpregs.f_fpcntl));\r\n}\r\nif (context_size &&\r\n__copy_from_user(fpstate + 4, (long __user *)&uc->uc_fpstate + 1,\r\ncontext_size))\r\ngoto out;\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"frestore %0\n\t"\r\n".chip 68k" : : "m" (*fpstate));\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int mangle_kernel_stack(struct pt_regs *regs, int formatvec,\r\nvoid __user *fp)\r\n{\r\nint fsize = frame_extra_sizes[formatvec >> 12];\r\nif (fsize < 0) {\r\n#ifdef DEBUG\r\nprintk("user process returning with weird frame format\n");\r\n#endif\r\nreturn 1;\r\n}\r\nif (!fsize) {\r\nregs->format = formatvec >> 12;\r\nregs->vector = formatvec & 0xfff;\r\n} else {\r\nstruct switch_stack *sw = (struct switch_stack *)regs - 1;\r\nunsigned long buf[fsize / 2];\r\nif (copy_from_user(buf + fsize / 4, fp, fsize))\r\nreturn 1;\r\nregs->format = formatvec >> 12;\r\nregs->vector = formatvec & 0xfff;\r\n#define frame_offset (sizeof(struct pt_regs)+sizeof(struct switch_stack))\r\n__asm__ __volatile__\r\n(" movel %0,%/a0\n\t"\r\n" subl %1,%/a0\n\t"\r\n" movel %/a0,%/sp\n\t"\r\n"1: movel %0@+,%/a0@+\n\t"\r\n" dbra %2,1b\n\t"\r\n" lea %/sp@(%c3),%/a0\n\t"\r\n" lsrl #2,%1\n\t"\r\n" subql #1,%1\n\t"\r\n"2: movel %4@+,%/a0@+\n\t"\r\n" dbra %1,2b\n\t"\r\n" bral ret_from_signal\n"\r\n:\r\n: "a" (sw), "d" (fsize), "d" (frame_offset/4-1),\r\n"n" (frame_offset), "a" (buf + fsize/4)\r\n: "a0");\r\n#undef frame_offset\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\nrestore_sigcontext(struct pt_regs *regs, struct sigcontext __user *usc, void __user *fp)\r\n{\r\nint formatvec;\r\nstruct sigcontext context;\r\nint err;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nif (copy_from_user(&context, usc, sizeof(context)))\r\ngoto badframe;\r\nregs->d0 = context.sc_d0;\r\nregs->d1 = context.sc_d1;\r\nregs->a0 = context.sc_a0;\r\nregs->a1 = context.sc_a1;\r\nregs->sr = (regs->sr & 0xff00) | (context.sc_sr & 0xff);\r\nregs->pc = context.sc_pc;\r\nregs->orig_d0 = -1;\r\nwrusp(context.sc_usp);\r\nformatvec = context.sc_formatvec;\r\nerr = restore_fpu_state(&context);\r\nif (err || mangle_kernel_stack(regs, formatvec, fp))\r\ngoto badframe;\r\nreturn 0;\r\nbadframe:\r\nreturn 1;\r\n}\r\nstatic inline int\r\nrt_restore_ucontext(struct pt_regs *regs, struct switch_stack *sw,\r\nstruct ucontext __user *uc)\r\n{\r\nint temp;\r\ngreg_t __user *gregs = uc->uc_mcontext.gregs;\r\nunsigned long usp;\r\nint err;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nerr = __get_user(temp, &uc->uc_mcontext.version);\r\nif (temp != MCONTEXT_VERSION)\r\ngoto badframe;\r\nerr |= __get_user(regs->d0, &gregs[0]);\r\nerr |= __get_user(regs->d1, &gregs[1]);\r\nerr |= __get_user(regs->d2, &gregs[2]);\r\nerr |= __get_user(regs->d3, &gregs[3]);\r\nerr |= __get_user(regs->d4, &gregs[4]);\r\nerr |= __get_user(regs->d5, &gregs[5]);\r\nerr |= __get_user(sw->d6, &gregs[6]);\r\nerr |= __get_user(sw->d7, &gregs[7]);\r\nerr |= __get_user(regs->a0, &gregs[8]);\r\nerr |= __get_user(regs->a1, &gregs[9]);\r\nerr |= __get_user(regs->a2, &gregs[10]);\r\nerr |= __get_user(sw->a3, &gregs[11]);\r\nerr |= __get_user(sw->a4, &gregs[12]);\r\nerr |= __get_user(sw->a5, &gregs[13]);\r\nerr |= __get_user(sw->a6, &gregs[14]);\r\nerr |= __get_user(usp, &gregs[15]);\r\nwrusp(usp);\r\nerr |= __get_user(regs->pc, &gregs[16]);\r\nerr |= __get_user(temp, &gregs[17]);\r\nregs->sr = (regs->sr & 0xff00) | (temp & 0xff);\r\nregs->orig_d0 = -1;\r\nerr |= __get_user(temp, &uc->uc_formatvec);\r\nerr |= rt_restore_fpu_state(uc);\r\nif (err || do_sigaltstack(&uc->uc_stack, NULL, usp) == -EFAULT)\r\ngoto badframe;\r\nif (mangle_kernel_stack(regs, temp, &uc->uc_extra))\r\ngoto badframe;\r\nreturn 0;\r\nbadframe:\r\nreturn 1;\r\n}\r\nasmlinkage int do_sigreturn(unsigned long __unused)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *) &__unused;\r\nstruct pt_regs *regs = (struct pt_regs *) (sw + 1);\r\nunsigned long usp = rdusp();\r\nstruct sigframe __user *frame = (struct sigframe __user *)(usp - 4);\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__get_user(set.sig[0], &frame->sc.sc_mask) ||\r\n(_NSIG_WORDS > 1 &&\r\n__copy_from_user(&set.sig[1], &frame->extramask,\r\nsizeof(frame->extramask))))\r\ngoto badframe;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\ncurrent->blocked = set;\r\nrecalc_sigpending();\r\nif (restore_sigcontext(regs, &frame->sc, frame + 1))\r\ngoto badframe;\r\nreturn regs->d0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nasmlinkage int do_rt_sigreturn(unsigned long __unused)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *) &__unused;\r\nstruct pt_regs *regs = (struct pt_regs *) (sw + 1);\r\nunsigned long usp = rdusp();\r\nstruct rt_sigframe __user *frame = (struct rt_sigframe __user *)(usp - 4);\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nsigdelsetmask(&set, ~_BLOCKABLE);\r\ncurrent->blocked = set;\r\nrecalc_sigpending();\r\nif (rt_restore_ucontext(regs, sw, &frame->uc))\r\ngoto badframe;\r\nreturn regs->d0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nstatic inline void save_fpu_state(struct sigcontext *sc, struct pt_regs *regs)\r\n{\r\nif (FPU_IS_EMU) {\r\nmemcpy(sc->sc_fpcntl, current->thread.fpcntl, 12);\r\nmemcpy(sc->sc_fpregs, current->thread.fp, 24);\r\nreturn;\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fsave %0\n\t"\r\n".chip 68k"\r\n: : "m" (*sc->sc_fpstate) : "memory");\r\nif (CPU_IS_060 ? sc->sc_fpstate[2] : sc->sc_fpstate[0]) {\r\nfpu_version = sc->sc_fpstate[0];\r\nif (CPU_IS_020_OR_030 &&\r\nregs->vector >= (VEC_FPBRUC * 4) &&\r\nregs->vector <= (VEC_FPNAN * 4)) {\r\nif (*(unsigned short *) sc->sc_fpstate == 0x1f38)\r\nsc->sc_fpstate[0x38] |= 1 << 3;\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %%fp0-%%fp1,%0\n\t"\r\n"fmoveml %%fpcr/%%fpsr/%%fpiar,%1\n\t"\r\n".chip 68k"\r\n: "=m" (*sc->sc_fpregs),\r\n"=m" (*sc->sc_fpcntl)\r\n:\r\n: "memory");\r\n}\r\n}\r\nstatic inline int rt_save_fpu_state(struct ucontext __user *uc, struct pt_regs *regs)\r\n{\r\nunsigned char fpstate[FPCONTEXT_SIZE];\r\nint context_size = CPU_IS_060 ? 8 : 0;\r\nint err = 0;\r\nif (FPU_IS_EMU) {\r\nerr |= copy_to_user(uc->uc_mcontext.fpregs.f_fpcntl,\r\ncurrent->thread.fpcntl, 12);\r\nerr |= copy_to_user(uc->uc_mcontext.fpregs.f_fpregs,\r\ncurrent->thread.fp, 96);\r\nreturn err;\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fsave %0\n\t"\r\n".chip 68k"\r\n: : "m" (*fpstate) : "memory");\r\nerr |= __put_user(*(long *)fpstate, (long __user *)&uc->uc_fpstate);\r\nif (CPU_IS_060 ? fpstate[2] : fpstate[0]) {\r\nfpregset_t fpregs;\r\nif (!CPU_IS_060)\r\ncontext_size = fpstate[1];\r\nfpu_version = fpstate[0];\r\nif (CPU_IS_020_OR_030 &&\r\nregs->vector >= (VEC_FPBRUC * 4) &&\r\nregs->vector <= (VEC_FPNAN * 4)) {\r\nif (*(unsigned short *) fpstate == 0x1f38)\r\nfpstate[0x38] |= 1 << 3;\r\n}\r\n__asm__ volatile (".chip 68k/68881\n\t"\r\n"fmovemx %%fp0-%%fp7,%0\n\t"\r\n"fmoveml %%fpcr/%%fpsr/%%fpiar,%1\n\t"\r\n".chip 68k"\r\n: "=m" (*fpregs.f_fpregs),\r\n"=m" (*fpregs.f_fpcntl)\r\n:\r\n: "memory");\r\nerr |= copy_to_user(&uc->uc_mcontext.fpregs, &fpregs,\r\nsizeof(fpregs));\r\n}\r\nif (context_size)\r\nerr |= copy_to_user((long __user *)&uc->uc_fpstate + 1, fpstate + 4,\r\ncontext_size);\r\nreturn err;\r\n}\r\nstatic void setup_sigcontext(struct sigcontext *sc, struct pt_regs *regs,\r\nunsigned long mask)\r\n{\r\nsc->sc_mask = mask;\r\nsc->sc_usp = rdusp();\r\nsc->sc_d0 = regs->d0;\r\nsc->sc_d1 = regs->d1;\r\nsc->sc_a0 = regs->a0;\r\nsc->sc_a1 = regs->a1;\r\nsc->sc_sr = regs->sr;\r\nsc->sc_pc = regs->pc;\r\nsc->sc_formatvec = regs->format << 12 | regs->vector;\r\nsave_fpu_state(sc, regs);\r\n}\r\nstatic inline int rt_setup_ucontext(struct ucontext __user *uc, struct pt_regs *regs)\r\n{\r\nstruct switch_stack *sw = (struct switch_stack *)regs - 1;\r\ngreg_t __user *gregs = uc->uc_mcontext.gregs;\r\nint err = 0;\r\nerr |= __put_user(MCONTEXT_VERSION, &uc->uc_mcontext.version);\r\nerr |= __put_user(regs->d0, &gregs[0]);\r\nerr |= __put_user(regs->d1, &gregs[1]);\r\nerr |= __put_user(regs->d2, &gregs[2]);\r\nerr |= __put_user(regs->d3, &gregs[3]);\r\nerr |= __put_user(regs->d4, &gregs[4]);\r\nerr |= __put_user(regs->d5, &gregs[5]);\r\nerr |= __put_user(sw->d6, &gregs[6]);\r\nerr |= __put_user(sw->d7, &gregs[7]);\r\nerr |= __put_user(regs->a0, &gregs[8]);\r\nerr |= __put_user(regs->a1, &gregs[9]);\r\nerr |= __put_user(regs->a2, &gregs[10]);\r\nerr |= __put_user(sw->a3, &gregs[11]);\r\nerr |= __put_user(sw->a4, &gregs[12]);\r\nerr |= __put_user(sw->a5, &gregs[13]);\r\nerr |= __put_user(sw->a6, &gregs[14]);\r\nerr |= __put_user(rdusp(), &gregs[15]);\r\nerr |= __put_user(regs->pc, &gregs[16]);\r\nerr |= __put_user(regs->sr, &gregs[17]);\r\nerr |= __put_user((regs->format << 12) | regs->vector, &uc->uc_formatvec);\r\nerr |= rt_save_fpu_state(uc, regs);\r\nreturn err;\r\n}\r\nstatic inline void push_cache (unsigned long vaddr)\r\n{\r\nif (CPU_IS_040) {\r\nunsigned long temp;\r\n__asm__ __volatile__ (".chip 68040\n\t"\r\n"nop\n\t"\r\n"ptestr (%1)\n\t"\r\n"movec %%mmusr,%0\n\t"\r\n".chip 68k"\r\n: "=r" (temp)\r\n: "a" (vaddr));\r\ntemp &= PAGE_MASK;\r\ntemp |= vaddr & ~PAGE_MASK;\r\n__asm__ __volatile__ (".chip 68040\n\t"\r\n"nop\n\t"\r\n"cpushl %%bc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (temp));\r\n}\r\nelse if (CPU_IS_060) {\r\nunsigned long temp;\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"plpar (%0)\n\t"\r\n".chip 68k"\r\n: "=a" (temp)\r\n: "0" (vaddr));\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpushl %%bc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (temp));\r\n}\r\nelse {\r\nunsigned long temp;\r\nasm volatile ("movec %%cacr,%0" : "=r" (temp));\r\ntemp += 4;\r\nasm volatile ("movec %0,%%caar\n\t"\r\n"movec %1,%%cacr"\r\n: : "r" (vaddr), "r" (temp));\r\nasm volatile ("movec %0,%%caar\n\t"\r\n"movec %1,%%cacr"\r\n: : "r" (vaddr + 4), "r" (temp));\r\n}\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size)\r\n{\r\nunsigned long usp;\r\nusp = rdusp();\r\nif (ka->sa.sa_flags & SA_ONSTACK) {\r\nif (!sas_ss_flags(usp))\r\nusp = current->sas_ss_sp + current->sas_ss_size;\r\n}\r\nreturn (void __user *)((usp - frame_size) & -8UL);\r\n}\r\nstatic int setup_frame (int sig, struct k_sigaction *ka,\r\nsigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct sigframe __user *frame;\r\nint fsize = frame_extra_sizes[regs->format];\r\nstruct sigcontext context;\r\nint err = 0;\r\nif (fsize < 0) {\r\n#ifdef DEBUG\r\nprintk ("setup_frame: Unknown frame format %#x\n",\r\nregs->format);\r\n#endif\r\ngoto give_sigsegv;\r\n}\r\nframe = get_sigframe(ka, regs, sizeof(*frame) + fsize);\r\nif (fsize)\r\nerr |= copy_to_user (frame + 1, regs + 1, fsize);\r\nerr |= __put_user((current_thread_info()->exec_domain\r\n&& current_thread_info()->exec_domain->signal_invmap\r\n&& sig < 32\r\n? current_thread_info()->exec_domain->signal_invmap[sig]\r\n: sig),\r\n&frame->sig);\r\nerr |= __put_user(regs->vector, &frame->code);\r\nerr |= __put_user(&frame->sc, &frame->psc);\r\nif (_NSIG_WORDS > 1)\r\nerr |= copy_to_user(frame->extramask, &set->sig[1],\r\nsizeof(frame->extramask));\r\nsetup_sigcontext(&context, regs, set->sig[0]);\r\nerr |= copy_to_user (&frame->sc, &context, sizeof(context));\r\nerr |= __put_user(frame->retcode, &frame->pretcode);\r\nerr |= __put_user(0x70004e40 + (__NR_sigreturn << 16),\r\n(long __user *)(frame->retcode));\r\nif (err)\r\ngoto give_sigsegv;\r\npush_cache ((unsigned long) &frame->retcode);\r\nwrusp ((unsigned long) frame);\r\nregs->pc = (unsigned long) ka->sa.sa_handler;\r\nif (fsize)\r\nregs->stkadj = fsize;\r\nif (regs->stkadj) {\r\nstruct pt_regs *tregs =\r\n(struct pt_regs *)((ulong)regs + regs->stkadj);\r\n#ifdef DEBUG\r\nprintk("Performing stackadjust=%04x\n", regs->stkadj);\r\n#endif\r\ntregs->vector = 0;\r\ntregs->format = 0;\r\ntregs->pc = regs->pc;\r\ntregs->sr = regs->sr;\r\n}\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn err;\r\n}\r\nstatic int setup_rt_frame (int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct rt_sigframe __user *frame;\r\nint fsize = frame_extra_sizes[regs->format];\r\nint err = 0;\r\nif (fsize < 0) {\r\n#ifdef DEBUG\r\nprintk ("setup_frame: Unknown frame format %#x\n",\r\nregs->format);\r\n#endif\r\ngoto give_sigsegv;\r\n}\r\nframe = get_sigframe(ka, regs, sizeof(*frame));\r\nif (fsize)\r\nerr |= copy_to_user (&frame->uc.uc_extra, regs + 1, fsize);\r\nerr |= __put_user((current_thread_info()->exec_domain\r\n&& current_thread_info()->exec_domain->signal_invmap\r\n&& sig < 32\r\n? current_thread_info()->exec_domain->signal_invmap[sig]\r\n: sig),\r\n&frame->sig);\r\nerr |= __put_user(&frame->info, &frame->pinfo);\r\nerr |= __put_user(&frame->uc, &frame->puc);\r\nerr |= copy_siginfo_to_user(&frame->info, info);\r\nerr |= __put_user(0, &frame->uc.uc_flags);\r\nerr |= __put_user(NULL, &frame->uc.uc_link);\r\nerr |= __put_user((void __user *)current->sas_ss_sp,\r\n&frame->uc.uc_stack.ss_sp);\r\nerr |= __put_user(sas_ss_flags(rdusp()),\r\n&frame->uc.uc_stack.ss_flags);\r\nerr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\r\nerr |= rt_setup_ucontext(&frame->uc, regs);\r\nerr |= copy_to_user (&frame->uc.uc_sigmask, set, sizeof(*set));\r\nerr |= __put_user(frame->retcode, &frame->pretcode);\r\n#ifdef __mcoldfire__\r\nerr |= __put_user(0x203c0000, (long __user *)(frame->retcode + 0));\r\nerr |= __put_user(0x00004e40 + (__NR_rt_sigreturn << 16),\r\n(long __user *)(frame->retcode + 4));\r\n#else\r\nerr |= __put_user(0x70004600 + ((__NR_rt_sigreturn ^ 0xff) << 16),\r\n(long __user *)(frame->retcode + 0));\r\nerr |= __put_user(0x4e40, (short __user *)(frame->retcode + 4));\r\n#endif\r\nif (err)\r\ngoto give_sigsegv;\r\npush_cache ((unsigned long) &frame->retcode);\r\nwrusp ((unsigned long) frame);\r\nregs->pc = (unsigned long) ka->sa.sa_handler;\r\nif (fsize)\r\nregs->stkadj = fsize;\r\nif (regs->stkadj) {\r\nstruct pt_regs *tregs =\r\n(struct pt_regs *)((ulong)regs + regs->stkadj);\r\n#ifdef DEBUG\r\nprintk("Performing stackadjust=%04x\n", regs->stkadj);\r\n#endif\r\ntregs->vector = 0;\r\ntregs->format = 0;\r\ntregs->pc = regs->pc;\r\ntregs->sr = regs->sr;\r\n}\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn err;\r\n}\r\nstatic inline void\r\nhandle_restart(struct pt_regs *regs, struct k_sigaction *ka, int has_handler)\r\n{\r\nswitch (regs->d0) {\r\ncase -ERESTARTNOHAND:\r\nif (!has_handler)\r\ngoto do_restart;\r\nregs->d0 = -EINTR;\r\nbreak;\r\ncase -ERESTART_RESTARTBLOCK:\r\nif (!has_handler) {\r\nregs->d0 = __NR_restart_syscall;\r\nregs->pc -= 2;\r\nbreak;\r\n}\r\nregs->d0 = -EINTR;\r\nbreak;\r\ncase -ERESTARTSYS:\r\nif (has_handler && !(ka->sa.sa_flags & SA_RESTART)) {\r\nregs->d0 = -EINTR;\r\nbreak;\r\n}\r\ncase -ERESTARTNOINTR:\r\ndo_restart:\r\nregs->d0 = regs->orig_d0;\r\nregs->pc -= 2;\r\nbreak;\r\n}\r\n}\r\nvoid ptrace_signal_deliver(struct pt_regs *regs, void *cookie)\r\n{\r\nif (regs->orig_d0 < 0)\r\nreturn;\r\nswitch (regs->d0) {\r\ncase -ERESTARTNOHAND:\r\ncase -ERESTARTSYS:\r\ncase -ERESTARTNOINTR:\r\nregs->d0 = regs->orig_d0;\r\nregs->orig_d0 = -1;\r\nregs->pc -= 2;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nhandle_signal(int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *oldset, struct pt_regs *regs)\r\n{\r\nint err;\r\nif (regs->orig_d0 >= 0)\r\nhandle_restart(regs, ka, 1);\r\nif (ka->sa.sa_flags & SA_SIGINFO)\r\nerr = setup_rt_frame(sig, ka, info, oldset, regs);\r\nelse\r\nerr = setup_frame(sig, ka, oldset, regs);\r\nif (err)\r\nreturn;\r\nsigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);\r\nif (!(ka->sa.sa_flags & SA_NODEFER))\r\nsigaddset(&current->blocked,sig);\r\nrecalc_sigpending();\r\nif (test_thread_flag(TIF_DELAYED_TRACE)) {\r\nregs->sr &= ~0x8000;\r\nsend_sig(SIGTRAP, current, 1);\r\n}\r\nclear_thread_flag(TIF_RESTORE_SIGMASK);\r\n}\r\nasmlinkage void do_signal(struct pt_regs *regs)\r\n{\r\nsiginfo_t info;\r\nstruct k_sigaction ka;\r\nint signr;\r\nsigset_t *oldset;\r\ncurrent->thread.esp0 = (unsigned long) regs;\r\nif (test_thread_flag(TIF_RESTORE_SIGMASK))\r\noldset = &current->saved_sigmask;\r\nelse\r\noldset = &current->blocked;\r\nsignr = get_signal_to_deliver(&info, &ka, regs, NULL);\r\nif (signr > 0) {\r\nhandle_signal(signr, &ka, &info, oldset, regs);\r\nreturn;\r\n}\r\nif (regs->orig_d0 >= 0)\r\nhandle_restart(regs, NULL, 0);\r\nif (test_thread_flag(TIF_RESTORE_SIGMASK)) {\r\nclear_thread_flag(TIF_RESTORE_SIGMASK);\r\nsigprocmask(SIG_SETMASK, &current->saved_sigmask, NULL);\r\n}\r\n}
