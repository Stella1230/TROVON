static void write_i2c(struct trust *tr, int n, ...)\r\n{\r\nunsigned char val, mask;\r\nva_list args;\r\nva_start(args, n);\r\nTR_SET_SDA;\r\nTR_SET_SCL;\r\nTR_DELAY;\r\nTR_CLR_SDA;\r\nTR_CLR_SCL;\r\nTR_DELAY;\r\nfor(; n; n--) {\r\nval = va_arg(args, unsigned);\r\nfor(mask = 0x80; mask; mask >>= 1) {\r\nif(val & mask)\r\nTR_SET_SDA;\r\nelse\r\nTR_CLR_SDA;\r\nTR_SET_SCL;\r\nTR_DELAY;\r\nTR_CLR_SCL;\r\nTR_DELAY;\r\n}\r\nTR_SET_SDA;\r\nTR_SET_SCL;\r\nTR_DELAY;\r\nTR_CLR_SCL;\r\nTR_DELAY;\r\n}\r\nTR_CLR_SDA;\r\nTR_DELAY;\r\nTR_SET_SCL;\r\nTR_DELAY;\r\nTR_SET_SDA;\r\nTR_DELAY;\r\nva_end(args);\r\n}\r\nstatic void tr_setvol(struct trust *tr, __u16 vol)\r\n{\r\nmutex_lock(&tr->lock);\r\ntr->curvol = vol / 2048;\r\nwrite_i2c(tr, 2, TDA7318_ADDR, tr->curvol ^ 0x1f);\r\nmutex_unlock(&tr->lock);\r\n}\r\nstatic void tr_setbass(struct trust *tr, __u16 bass)\r\n{\r\nmutex_lock(&tr->lock);\r\ntr->curbass = bass / 4370;\r\nwrite_i2c(tr, 2, TDA7318_ADDR, 0x60 | basstreble2chip[tr->curbass]);\r\nmutex_unlock(&tr->lock);\r\n}\r\nstatic void tr_settreble(struct trust *tr, __u16 treble)\r\n{\r\nmutex_lock(&tr->lock);\r\ntr->curtreble = treble / 4370;\r\nwrite_i2c(tr, 2, TDA7318_ADDR, 0x70 | basstreble2chip[tr->curtreble]);\r\nmutex_unlock(&tr->lock);\r\n}\r\nstatic void tr_setstereo(struct trust *tr, int stereo)\r\n{\r\nmutex_lock(&tr->lock);\r\ntr->curstereo = !!stereo;\r\ntr->ioval = (tr->ioval & 0xfb) | (!tr->curstereo << 2);\r\noutb(tr->ioval, tr->io);\r\nmutex_unlock(&tr->lock);\r\n}\r\nstatic void tr_setmute(struct trust *tr, int mute)\r\n{\r\nmutex_lock(&tr->lock);\r\ntr->curmute = !!mute;\r\ntr->ioval = (tr->ioval & 0xf7) | (tr->curmute << 3);\r\noutb(tr->ioval, tr->io);\r\nmutex_unlock(&tr->lock);\r\n}\r\nstatic int tr_getsigstr(struct trust *tr)\r\n{\r\nint i, v;\r\nmutex_lock(&tr->lock);\r\nfor (i = 0, v = 0; i < 100; i++)\r\nv |= inb(tr->io);\r\nmutex_unlock(&tr->lock);\r\nreturn (v & 1) ? 0 : 0xffff;\r\n}\r\nstatic int tr_getstereo(struct trust *tr)\r\n{\r\nreturn tr->curstereo;\r\n}\r\nstatic void tr_setfreq(struct trust *tr, unsigned long f)\r\n{\r\nmutex_lock(&tr->lock);\r\ntr->curfreq = f;\r\nf /= 160;\r\nf += 1070;\r\nwrite_i2c(tr, 5, TSA6060T_ADDR, (f << 1) | 1, f >> 7, 0x60 | ((f >> 15) & 1), 0);\r\nmutex_unlock(&tr->lock);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "radio-trust", sizeof(v->driver));\r\nstrlcpy(v->card, "Trust FM Radio", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct trust *tr = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = 87.5 * 16000;\r\nv->rangehigh = 108 * 16000;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nif (tr_getstereo(tr))\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nelse\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nv->signal = tr_getsigstr(tr);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct trust *tr = video_drvdata(file);\r\nif (v->index)\r\nreturn -EINVAL;\r\ntr_setstereo(tr, v->audmode == V4L2_TUNER_MODE_STEREO);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct trust *tr = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\ntr_setfreq(tr, f->frequency);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct trust *tr = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = tr->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 2048, 65535);\r\ncase V4L2_CID_AUDIO_BASS:\r\ncase V4L2_CID_AUDIO_TREBLE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 4370, 32768);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct trust *tr = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = tr->curmute;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nctrl->value = tr->curvol * 2048;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_BASS:\r\nctrl->value = tr->curbass * 4370;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_TREBLE:\r\nctrl->value = tr->curtreble * 4370;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct trust *tr = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ntr_setmute(tr, ctrl->value);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ntr_setvol(tr, ctrl->value);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_BASS:\r\ntr_setbass(tr, ctrl->value);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_TREBLE:\r\ntr_settreble(tr, ctrl->value);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn a->index ? -EINVAL : 0;\r\n}\r\nstatic int __init trust_init(void)\r\n{\r\nstruct trust *tr = &trust_card;\r\nstruct v4l2_device *v4l2_dev = &tr->v4l2_dev;\r\nint res;\r\nstrlcpy(v4l2_dev->name, "trust", sizeof(v4l2_dev->name));\r\ntr->io = io;\r\ntr->ioval = 0xf;\r\nmutex_init(&tr->lock);\r\nif (tr->io == -1) {\r\nv4l2_err(v4l2_dev, "You must set an I/O address with io=0x0x350 or 0x358\n");\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(tr->io, 2, "Trust FM Radio")) {\r\nv4l2_err(v4l2_dev, "port 0x%x already in use\n", tr->io);\r\nreturn -EBUSY;\r\n}\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(tr->io, 2);\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn res;\r\n}\r\nstrlcpy(tr->vdev.name, v4l2_dev->name, sizeof(tr->vdev.name));\r\ntr->vdev.v4l2_dev = v4l2_dev;\r\ntr->vdev.fops = &trust_fops;\r\ntr->vdev.ioctl_ops = &trust_ioctl_ops;\r\ntr->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&tr->vdev, tr);\r\nwrite_i2c(tr, 2, TDA7318_ADDR, 0x80);\r\nwrite_i2c(tr, 2, TDA7318_ADDR, 0xa0);\r\nwrite_i2c(tr, 2, TDA7318_ADDR, 0xc0);\r\nwrite_i2c(tr, 2, TDA7318_ADDR, 0xe0);\r\nwrite_i2c(tr, 2, TDA7318_ADDR, 0x40);\r\ntr_setvol(tr, 0xffff);\r\ntr_setbass(tr, 0x8000);\r\ntr_settreble(tr, 0x8000);\r\ntr_setstereo(tr, 1);\r\ntr_setmute(tr, 1);\r\nif (video_register_device(&tr->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_device_unregister(v4l2_dev);\r\nrelease_region(tr->io, 2);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(v4l2_dev, "Trust FM Radio card driver v1.0.\n");\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_trust_module(void)\r\n{\r\nstruct trust *tr = &trust_card;\r\nvideo_unregister_device(&tr->vdev);\r\nv4l2_device_unregister(&tr->v4l2_dev);\r\nrelease_region(tr->io, 2);\r\n}
