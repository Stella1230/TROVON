static void rt_mute(struct rtrack2 *dev)\r\n{\r\nif (dev->muted)\r\nreturn;\r\nmutex_lock(&dev->lock);\r\noutb(1, dev->io);\r\nmutex_unlock(&dev->lock);\r\ndev->muted = 1;\r\n}\r\nstatic void rt_unmute(struct rtrack2 *dev)\r\n{\r\nif(dev->muted == 0)\r\nreturn;\r\nmutex_lock(&dev->lock);\r\noutb(0, dev->io);\r\nmutex_unlock(&dev->lock);\r\ndev->muted = 0;\r\n}\r\nstatic void zero(struct rtrack2 *dev)\r\n{\r\noutb_p(1, dev->io);\r\noutb_p(3, dev->io);\r\noutb_p(1, dev->io);\r\n}\r\nstatic void one(struct rtrack2 *dev)\r\n{\r\noutb_p(5, dev->io);\r\noutb_p(7, dev->io);\r\noutb_p(5, dev->io);\r\n}\r\nstatic int rt_setfreq(struct rtrack2 *dev, unsigned long freq)\r\n{\r\nint i;\r\nmutex_lock(&dev->lock);\r\ndev->curfreq = freq;\r\nfreq = freq / 200 + 856;\r\noutb_p(0xc8, dev->io);\r\noutb_p(0xc9, dev->io);\r\noutb_p(0xc9, dev->io);\r\nfor (i = 0; i < 10; i++)\r\nzero(dev);\r\nfor (i = 14; i >= 0; i--)\r\nif (freq & (1 << i))\r\none(dev);\r\nelse\r\nzero(dev);\r\noutb_p(0xc8, dev->io);\r\nif (!dev->muted)\r\noutb_p(0, dev->io);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "radio-rtrack2", sizeof(v->driver));\r\nstrlcpy(v->card, "RadioTrack II", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA", sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int rt_getsigstr(struct rtrack2 *dev)\r\n{\r\nint sig = 1;\r\nmutex_lock(&dev->lock);\r\nif (inb(dev->io) & 2)\r\nsig = 0;\r\nmutex_unlock(&dev->lock);\r\nreturn sig;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct rtrack2 *rt = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = 88 * 16000;\r\nv->rangehigh = 108 * 16000;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nv->capability = V4L2_TUNER_CAP_LOW;\r\nv->audmode = V4L2_TUNER_MODE_MONO;\r\nv->signal = 0xFFFF * rt_getsigstr(rt);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct rtrack2 *rt = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nrt_setfreq(rt, f->frequency);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct rtrack2 *rt = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = rt->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 65535, 65535);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct rtrack2 *rt = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = rt->muted;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nif (rt->muted)\r\nctrl->value = 0;\r\nelse\r\nctrl->value = 65535;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct rtrack2 *rt = video_drvdata(file);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->value)\r\nrt_mute(rt);\r\nelse\r\nrt_unmute(rt);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nif (ctrl->value)\r\nrt_unmute(rt);\r\nelse\r\nrt_mute(rt);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\na->index = 0;\r\nstrlcpy(a->name, "Radio", sizeof(a->name));\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn a->index ? -EINVAL : 0;\r\n}\r\nstatic int __init rtrack2_init(void)\r\n{\r\nstruct rtrack2 *dev = &rtrack2_card;\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\r\nint res;\r\nstrlcpy(v4l2_dev->name, "rtrack2", sizeof(v4l2_dev->name));\r\ndev->io = io;\r\nif (dev->io == -1) {\r\nv4l2_err(v4l2_dev, "You must set an I/O address with io=0x20c or io=0x30c\n");\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(dev->io, 4, "rtrack2")) {\r\nv4l2_err(v4l2_dev, "port 0x%x already in use\n", dev->io);\r\nreturn -EBUSY;\r\n}\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(dev->io, 4);\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn res;\r\n}\r\nstrlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\r\ndev->vdev.v4l2_dev = v4l2_dev;\r\ndev->vdev.fops = &rtrack2_fops;\r\ndev->vdev.ioctl_ops = &rtrack2_ioctl_ops;\r\ndev->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\noutb(1, dev->io);\r\ndev->muted = 1;\r\nmutex_init(&dev->lock);\r\nif (video_register_device(&dev->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_device_unregister(v4l2_dev);\r\nrelease_region(dev->io, 4);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(v4l2_dev, "AIMSlab Radiotrack II card driver.\n");\r\nreturn 0;\r\n}\r\nstatic void __exit rtrack2_exit(void)\r\n{\r\nstruct rtrack2 *dev = &rtrack2_card;\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nrelease_region(dev->io, 4);\r\n}
