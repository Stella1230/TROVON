static int utf8_to_utf16le(const char *s, __le16 *cp, unsigned len)\r\n{\r\nint count = 0;\r\nu8 c;\r\nu16 uchar;\r\nwhile (len != 0 && (c = (u8) *s++) != 0) {\r\nif (unlikely(c & 0x80)) {\r\nif ((c & 0xe0) == 0xc0) {\r\nuchar = (c & 0x1f) << 6;\r\nc = (u8) *s++;\r\nif ((c & 0xc0) != 0x80)\r\ngoto fail;\r\nc &= 0x3f;\r\nuchar |= c;\r\n} else if ((c & 0xf0) == 0xe0) {\r\nuchar = (c & 0x0f) << 12;\r\nc = (u8) *s++;\r\nif ((c & 0xc0) != 0x80)\r\ngoto fail;\r\nc &= 0x3f;\r\nuchar |= c << 6;\r\nc = (u8) *s++;\r\nif ((c & 0xc0) != 0x80)\r\ngoto fail;\r\nc &= 0x3f;\r\nuchar |= c;\r\nif (0xd800 <= uchar && uchar <= 0xdfff)\r\ngoto fail;\r\n} else\r\ngoto fail;\r\n} else\r\nuchar = c;\r\nput_unaligned_le16(uchar, cp++);\r\ncount++;\r\nlen--;\r\n}\r\nreturn count;\r\nfail:\r\nreturn -1;\r\n}\r\nint\r\nusb_gadget_get_string (struct usb_gadget_strings *table, int id, u8 *buf)\r\n{\r\nstruct usb_string *s;\r\nint len;\r\nif (id == 0) {\r\nbuf [0] = 4;\r\nbuf [1] = USB_DT_STRING;\r\nbuf [2] = (u8) table->language;\r\nbuf [3] = (u8) (table->language >> 8);\r\nreturn 4;\r\n}\r\nfor (s = table->strings; s && s->s; s++)\r\nif (s->id == id)\r\nbreak;\r\nif (!s || !s->s)\r\nreturn -EINVAL;\r\nlen = min ((size_t) 126, strlen (s->s));\r\nmemset (buf + 2, 0, 2 * len);\r\nlen = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);\r\nif (len < 0)\r\nreturn -EINVAL;\r\nbuf [0] = (len + 1) * 2;\r\nbuf [1] = USB_DT_STRING;\r\nreturn buf [0];\r\n}
