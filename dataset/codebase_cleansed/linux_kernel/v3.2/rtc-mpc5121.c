static void mpc5121_rtc_update_smh(struct mpc5121_rtc_regs __iomem *regs,\r\nstruct rtc_time *tm)\r\n{\r\nout_8(&regs->second_set, tm->tm_sec);\r\nout_8(&regs->minute_set, tm->tm_min);\r\nout_8(&regs->hour_set, tm->tm_hour);\r\nout_8(&regs->set_time, 0x1);\r\nout_8(&regs->set_time, 0x3);\r\nout_8(&regs->set_time, 0x1);\r\nout_8(&regs->set_time, 0x0);\r\n}\r\nstatic int mpc5121_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nunsigned long now;\r\nnow = in_be32(&regs->actual_time) + in_be32(&regs->target_time);\r\nrtc_time_to_tm(now, tm);\r\nmpc5121_rtc_update_smh(regs, tm);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int mpc5121_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nint ret;\r\nunsigned long now;\r\nret = rtc_tm_to_time(tm, &now);\r\nif (ret == 0)\r\nout_be32(&regs->target_time, now - in_be32(&regs->actual_time));\r\nmpc5121_rtc_update_smh(regs, tm);\r\nreturn 0;\r\n}\r\nstatic int mpc5200_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nint tmp;\r\ntm->tm_sec = in_8(&regs->second);\r\ntm->tm_min = in_8(&regs->minute);\r\nif (in_8(&regs->hour) & 0x20)\r\ntm->tm_hour = (in_8(&regs->hour) >> 1) +\r\n(in_8(&regs->hour) & 1 ? 12 : 0);\r\nelse\r\ntm->tm_hour = in_8(&regs->hour);\r\ntmp = in_8(&regs->wday_mday);\r\ntm->tm_mday = tmp & 0x1f;\r\ntm->tm_mon = in_8(&regs->month) - 1;\r\ntm->tm_year = in_be16(&regs->year) - 1900;\r\ntm->tm_wday = (tmp >> 5) % 7;\r\ntm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\r\ntm->tm_isdst = 0;\r\nreturn 0;\r\n}\r\nstatic int mpc5200_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nmpc5121_rtc_update_smh(regs, tm);\r\nout_8(&regs->month_set, tm->tm_mon + 1);\r\nout_8(&regs->weekday_set, tm->tm_wday ? tm->tm_wday : 7);\r\nout_8(&regs->date_set, tm->tm_mday);\r\nout_be16(&regs->year_set, tm->tm_year + 1900);\r\nout_8(&regs->set_date, 0x1);\r\nout_8(&regs->set_date, 0x3);\r\nout_8(&regs->set_date, 0x1);\r\nout_8(&regs->set_date, 0x0);\r\nreturn 0;\r\n}\r\nstatic int mpc5121_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\n*alarm = rtc->wkalarm;\r\nalarm->pending = in_8(&regs->alm_status);\r\nreturn 0;\r\n}\r\nstatic int mpc5121_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nif (alarm->time.tm_sec) {\r\nalarm->time.tm_sec = 0;\r\nalarm->time.tm_min++;\r\nif (alarm->time.tm_min >= 60) {\r\nalarm->time.tm_min = 0;\r\nalarm->time.tm_hour++;\r\nif (alarm->time.tm_hour >= 24)\r\nalarm->time.tm_hour = 0;\r\n}\r\n}\r\nalarm->time.tm_mday = -1;\r\nalarm->time.tm_mon = -1;\r\nalarm->time.tm_year = -1;\r\nout_8(&regs->alm_min_set, alarm->time.tm_min);\r\nout_8(&regs->alm_hour_set, alarm->time.tm_hour);\r\nout_8(&regs->alm_enable, alarm->enabled);\r\nrtc->wkalarm = *alarm;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mpc5121_rtc_handler(int irq, void *dev)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata((struct device *)dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nif (in_8(&regs->int_alm)) {\r\nout_8(&regs->int_alm, 1);\r\nout_8(&regs->alm_status, 1);\r\nrtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t mpc5121_rtc_handler_upd(int irq, void *dev)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata((struct device *)dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nif (in_8(&regs->int_sec) && (in_8(&regs->int_enable) & 0x1)) {\r\nout_8(&regs->int_sec, 1);\r\nrtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_UF);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int mpc5121_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nint val;\r\nif (enabled)\r\nval = 1;\r\nelse\r\nval = 0;\r\nout_8(&regs->alm_enable, val);\r\nrtc->wkalarm.enabled = val;\r\nreturn 0;\r\n}\r\nstatic int __devinit mpc5121_rtc_probe(struct platform_device *op)\r\n{\r\nstruct mpc5121_rtc_data *rtc;\r\nint err = 0;\r\nrtc = kzalloc(sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nrtc->regs = of_iomap(op->dev.of_node, 0);\r\nif (!rtc->regs) {\r\ndev_err(&op->dev, "%s: couldn't map io space\n", __func__);\r\nerr = -ENOSYS;\r\ngoto out_free;\r\n}\r\ndevice_init_wakeup(&op->dev, 1);\r\ndev_set_drvdata(&op->dev, rtc);\r\nrtc->irq = irq_of_parse_and_map(op->dev.of_node, 1);\r\nerr = request_irq(rtc->irq, mpc5121_rtc_handler, IRQF_DISABLED,\r\n"mpc5121-rtc", &op->dev);\r\nif (err) {\r\ndev_err(&op->dev, "%s: could not request irq: %i\n",\r\n__func__, rtc->irq);\r\ngoto out_dispose;\r\n}\r\nrtc->irq_periodic = irq_of_parse_and_map(op->dev.of_node, 0);\r\nerr = request_irq(rtc->irq_periodic, mpc5121_rtc_handler_upd,\r\nIRQF_DISABLED, "mpc5121-rtc_upd", &op->dev);\r\nif (err) {\r\ndev_err(&op->dev, "%s: could not request irq: %i\n",\r\n__func__, rtc->irq_periodic);\r\ngoto out_dispose2;\r\n}\r\nif (of_device_is_compatible(op->dev.of_node, "fsl,mpc5121-rtc")) {\r\nu32 ka;\r\nka = in_be32(&rtc->regs->keep_alive);\r\nif (ka & 0x02) {\r\ndev_warn(&op->dev,\r\n"mpc5121-rtc: Battery or oscillator failure!\n");\r\nout_be32(&rtc->regs->keep_alive, ka);\r\n}\r\nrtc->rtc = rtc_device_register("mpc5121-rtc", &op->dev,\r\n&mpc5121_rtc_ops, THIS_MODULE);\r\n} else {\r\nrtc->rtc = rtc_device_register("mpc5200-rtc", &op->dev,\r\n&mpc5200_rtc_ops, THIS_MODULE);\r\n}\r\nif (IS_ERR(rtc->rtc)) {\r\nerr = PTR_ERR(rtc->rtc);\r\ngoto out_free_irq;\r\n}\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(rtc->irq_periodic, &op->dev);\r\nout_dispose2:\r\nirq_dispose_mapping(rtc->irq_periodic);\r\nfree_irq(rtc->irq, &op->dev);\r\nout_dispose:\r\nirq_dispose_mapping(rtc->irq);\r\niounmap(rtc->regs);\r\nout_free:\r\nkfree(rtc);\r\nreturn err;\r\n}\r\nstatic int __devexit mpc5121_rtc_remove(struct platform_device *op)\r\n{\r\nstruct mpc5121_rtc_data *rtc = dev_get_drvdata(&op->dev);\r\nstruct mpc5121_rtc_regs __iomem *regs = rtc->regs;\r\nout_8(&regs->alm_enable, 0);\r\nout_8(&regs->int_enable, in_8(&regs->int_enable) & ~0x1);\r\nrtc_device_unregister(rtc->rtc);\r\niounmap(rtc->regs);\r\nfree_irq(rtc->irq, &op->dev);\r\nfree_irq(rtc->irq_periodic, &op->dev);\r\nirq_dispose_mapping(rtc->irq);\r\nirq_dispose_mapping(rtc->irq_periodic);\r\ndev_set_drvdata(&op->dev, NULL);\r\nkfree(rtc);\r\nreturn 0;\r\n}\r\nstatic int __init mpc5121_rtc_init(void)\r\n{\r\nreturn platform_driver_register(&mpc5121_rtc_driver);\r\n}\r\nstatic void __exit mpc5121_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&mpc5121_rtc_driver);\r\n}
