static void __davinci_mdio_reset(struct davinci_mdio_data *data)\r\n{\r\nu32 mdio_in, div, mdio_out_khz, access_time;\r\nmdio_in = clk_get_rate(data->clk);\r\ndiv = (mdio_in / data->pdata.bus_freq) - 1;\r\nif (div > CONTROL_MAX_DIV)\r\ndiv = CONTROL_MAX_DIV;\r\n__raw_writel(div | CONTROL_ENABLE, &data->regs->control);\r\nmdio_out_khz = mdio_in / (1000 * (div + 1));\r\naccess_time = (88 * 1000) / mdio_out_khz;\r\ndata->access_time = usecs_to_jiffies(access_time * 4);\r\nif (!data->access_time)\r\ndata->access_time = 1;\r\n}\r\nstatic int davinci_mdio_reset(struct mii_bus *bus)\r\n{\r\nstruct davinci_mdio_data *data = bus->priv;\r\nu32 phy_mask, ver;\r\n__davinci_mdio_reset(data);\r\nmsleep(PHY_MAX_ADDR * data->access_time);\r\nver = __raw_readl(&data->regs->version);\r\ndev_info(data->dev, "davinci mdio revision %d.%d\n",\r\n(ver >> 8) & 0xff, ver & 0xff);\r\nphy_mask = __raw_readl(&data->regs->alive);\r\nif (phy_mask) {\r\ndev_info(data->dev, "detected phy mask %x\n", ~phy_mask);\r\nphy_mask = ~phy_mask;\r\n} else {\r\ndev_warn(data->dev, "no live phy, scanning all\n");\r\nphy_mask = 0;\r\n}\r\ndata->bus->phy_mask = phy_mask;\r\nreturn 0;\r\n}\r\nstatic inline int wait_for_user_access(struct davinci_mdio_data *data)\r\n{\r\nstruct davinci_mdio_regs __iomem *regs = data->regs;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);\r\nu32 reg;\r\nwhile (time_after(timeout, jiffies)) {\r\nreg = __raw_readl(&regs->user[0].access);\r\nif ((reg & USERACCESS_GO) == 0)\r\nreturn 0;\r\nreg = __raw_readl(&regs->control);\r\nif ((reg & CONTROL_IDLE) == 0)\r\ncontinue;\r\ndev_warn(data->dev, "resetting idled controller\n");\r\n__davinci_mdio_reset(data);\r\nreturn -EAGAIN;\r\n}\r\ndev_err(data->dev, "timed out waiting for user access\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int wait_for_idle(struct davinci_mdio_data *data)\r\n{\r\nstruct davinci_mdio_regs __iomem *regs = data->regs;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);\r\nwhile (time_after(timeout, jiffies)) {\r\nif (__raw_readl(&regs->control) & CONTROL_IDLE)\r\nreturn 0;\r\n}\r\ndev_err(data->dev, "timed out waiting for idle\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int davinci_mdio_read(struct mii_bus *bus, int phy_id, int phy_reg)\r\n{\r\nstruct davinci_mdio_data *data = bus->priv;\r\nu32 reg;\r\nint ret;\r\nif (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)\r\nreturn -EINVAL;\r\nspin_lock(&data->lock);\r\nif (data->suspended) {\r\nspin_unlock(&data->lock);\r\nreturn -ENODEV;\r\n}\r\nreg = (USERACCESS_GO | USERACCESS_READ | (phy_reg << 21) |\r\n(phy_id << 16));\r\nwhile (1) {\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nif (ret < 0)\r\nbreak;\r\n__raw_writel(reg, &data->regs->user[0].access);\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nif (ret < 0)\r\nbreak;\r\nreg = __raw_readl(&data->regs->user[0].access);\r\nret = (reg & USERACCESS_ACK) ? (reg & USERACCESS_DATA) : -EIO;\r\nbreak;\r\n}\r\nspin_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int davinci_mdio_write(struct mii_bus *bus, int phy_id,\r\nint phy_reg, u16 phy_data)\r\n{\r\nstruct davinci_mdio_data *data = bus->priv;\r\nu32 reg;\r\nint ret;\r\nif (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)\r\nreturn -EINVAL;\r\nspin_lock(&data->lock);\r\nif (data->suspended) {\r\nspin_unlock(&data->lock);\r\nreturn -ENODEV;\r\n}\r\nreg = (USERACCESS_GO | USERACCESS_WRITE | (phy_reg << 21) |\r\n(phy_id << 16) | (phy_data & USERACCESS_DATA));\r\nwhile (1) {\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nif (ret < 0)\r\nbreak;\r\n__raw_writel(reg, &data->regs->user[0].access);\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nbreak;\r\n}\r\nspin_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic int __devinit davinci_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct mdio_platform_data *pdata = pdev->dev.platform_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct davinci_mdio_data *data;\r\nstruct resource *res;\r\nstruct phy_device *phy;\r\nint ret, addr;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(dev, "failed to alloc device data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->pdata = pdata ? (*pdata) : default_pdata;\r\ndata->bus = mdiobus_alloc();\r\nif (!data->bus) {\r\ndev_err(dev, "failed to alloc mii bus\n");\r\nret = -ENOMEM;\r\ngoto bail_out;\r\n}\r\ndata->bus->name = dev_name(dev);\r\ndata->bus->read = davinci_mdio_read,\r\ndata->bus->write = davinci_mdio_write,\r\ndata->bus->reset = davinci_mdio_reset,\r\ndata->bus->parent = dev;\r\ndata->bus->priv = data;\r\nsnprintf(data->bus->id, MII_BUS_ID_SIZE, "%x", pdev->id);\r\ndata->clk = clk_get(dev, NULL);\r\nif (IS_ERR(data->clk)) {\r\ndata->clk = NULL;\r\ndev_err(dev, "failed to get device clock\n");\r\nret = PTR_ERR(data->clk);\r\ngoto bail_out;\r\n}\r\nclk_enable(data->clk);\r\ndev_set_drvdata(dev, data);\r\ndata->dev = dev;\r\nspin_lock_init(&data->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "could not find register map resource\n");\r\nret = -ENOENT;\r\ngoto bail_out;\r\n}\r\nres = devm_request_mem_region(dev, res->start, resource_size(res),\r\ndev_name(dev));\r\nif (!res) {\r\ndev_err(dev, "could not allocate register map resource\n");\r\nret = -ENXIO;\r\ngoto bail_out;\r\n}\r\ndata->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!data->regs) {\r\ndev_err(dev, "could not map mdio registers\n");\r\nret = -ENOMEM;\r\ngoto bail_out;\r\n}\r\nret = mdiobus_register(data->bus);\r\nif (ret)\r\ngoto bail_out;\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\r\nphy = data->bus->phy_map[addr];\r\nif (phy) {\r\ndev_info(dev, "phy[%d]: device %s, driver %s\n",\r\nphy->addr, dev_name(&phy->dev),\r\nphy->drv ? phy->drv->name : "unknown");\r\n}\r\n}\r\nreturn 0;\r\nbail_out:\r\nif (data->bus)\r\nmdiobus_free(data->bus);\r\nif (data->clk) {\r\nclk_disable(data->clk);\r\nclk_put(data->clk);\r\n}\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int __devexit davinci_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct davinci_mdio_data *data = dev_get_drvdata(dev);\r\nif (data->bus)\r\nmdiobus_free(data->bus);\r\nif (data->clk) {\r\nclk_disable(data->clk);\r\nclk_put(data->clk);\r\n}\r\ndev_set_drvdata(dev, NULL);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int davinci_mdio_suspend(struct device *dev)\r\n{\r\nstruct davinci_mdio_data *data = dev_get_drvdata(dev);\r\nu32 ctrl;\r\nspin_lock(&data->lock);\r\nctrl = __raw_readl(&data->regs->control);\r\nctrl &= ~CONTROL_ENABLE;\r\n__raw_writel(ctrl, &data->regs->control);\r\nwait_for_idle(data);\r\nif (data->clk)\r\nclk_disable(data->clk);\r\ndata->suspended = true;\r\nspin_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic int davinci_mdio_resume(struct device *dev)\r\n{\r\nstruct davinci_mdio_data *data = dev_get_drvdata(dev);\r\nu32 ctrl;\r\nspin_lock(&data->lock);\r\nif (data->clk)\r\nclk_enable(data->clk);\r\nctrl = __raw_readl(&data->regs->control);\r\nctrl |= CONTROL_ENABLE;\r\n__raw_writel(ctrl, &data->regs->control);\r\ndata->suspended = false;\r\nspin_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_mdio_init(void)\r\n{\r\nreturn platform_driver_register(&davinci_mdio_driver);\r\n}\r\nstatic void __exit davinci_mdio_exit(void)\r\n{\r\nplatform_driver_unregister(&davinci_mdio_driver);\r\n}
