static struct radeon_device *radeon_get_rdev(struct ttm_bo_device *bdev)\r\n{\r\nstruct radeon_mman *mman;\r\nstruct radeon_device *rdev;\r\nmman = container_of(bdev, struct radeon_mman, bdev);\r\nrdev = container_of(mman, struct radeon_device, mman);\r\nreturn rdev;\r\n}\r\nstatic int radeon_ttm_mem_global_init(struct drm_global_reference *ref)\r\n{\r\nreturn ttm_mem_global_init(ref->object);\r\n}\r\nstatic void radeon_ttm_mem_global_release(struct drm_global_reference *ref)\r\n{\r\nttm_mem_global_release(ref->object);\r\n}\r\nstatic int radeon_ttm_global_init(struct radeon_device *rdev)\r\n{\r\nstruct drm_global_reference *global_ref;\r\nint r;\r\nrdev->mman.mem_global_referenced = false;\r\nglobal_ref = &rdev->mman.mem_global_ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_MEM;\r\nglobal_ref->size = sizeof(struct ttm_mem_global);\r\nglobal_ref->init = &radeon_ttm_mem_global_init;\r\nglobal_ref->release = &radeon_ttm_mem_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM memory accounting "\r\n"subsystem.\n");\r\nreturn r;\r\n}\r\nrdev->mman.bo_global_ref.mem_glob =\r\nrdev->mman.mem_global_ref.object;\r\nglobal_ref = &rdev->mman.bo_global_ref.ref;\r\nglobal_ref->global_type = DRM_GLOBAL_TTM_BO;\r\nglobal_ref->size = sizeof(struct ttm_bo_global);\r\nglobal_ref->init = &ttm_bo_global_init;\r\nglobal_ref->release = &ttm_bo_global_release;\r\nr = drm_global_item_ref(global_ref);\r\nif (r != 0) {\r\nDRM_ERROR("Failed setting up TTM BO subsystem.\n");\r\ndrm_global_item_unref(&rdev->mman.mem_global_ref);\r\nreturn r;\r\n}\r\nrdev->mman.mem_global_referenced = true;\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_global_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->mman.mem_global_referenced) {\r\ndrm_global_item_unref(&rdev->mman.bo_global_ref.ref);\r\ndrm_global_item_unref(&rdev->mman.mem_global_ref);\r\nrdev->mman.mem_global_referenced = false;\r\n}\r\n}\r\nstatic struct ttm_backend*\r\nradeon_create_ttm_backend_entry(struct ttm_bo_device *bdev)\r\n{\r\nstruct radeon_device *rdev;\r\nrdev = radeon_get_rdev(bdev);\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nreturn ttm_agp_backend_init(bdev, rdev->ddev->agp->bridge);\r\n} else\r\n#endif\r\n{\r\nreturn radeon_ttm_backend_create(rdev);\r\n}\r\n}\r\nstatic int radeon_invalidate_caches(struct ttm_bo_device *bdev, uint32_t flags)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radeon_init_mem_type(struct ttm_bo_device *bdev, uint32_t type,\r\nstruct ttm_mem_type_manager *man)\r\n{\r\nstruct radeon_device *rdev;\r\nrdev = radeon_get_rdev(bdev);\r\nswitch (type) {\r\ncase TTM_PL_SYSTEM:\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nbreak;\r\ncase TTM_PL_TT:\r\nman->func = &ttm_bo_manager_func;\r\nman->gpu_offset = rdev->mc.gtt_start;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE | TTM_MEMTYPE_FLAG_CMA;\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nif (!(drm_core_has_AGP(rdev->ddev) && rdev->ddev->agp)) {\r\nDRM_ERROR("AGP is not enabled for memory type %u\n",\r\n(unsigned)type);\r\nreturn -EINVAL;\r\n}\r\nif (!rdev->ddev->agp->cant_use_aperture)\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_FLAG_UNCACHED |\r\nTTM_PL_FLAG_WC;\r\nman->default_caching = TTM_PL_FLAG_WC;\r\n}\r\n#endif\r\nbreak;\r\ncase TTM_PL_VRAM:\r\nman->func = &ttm_bo_manager_func;\r\nman->gpu_offset = rdev->mc.vram_start;\r\nman->flags = TTM_MEMTYPE_FLAG_FIXED |\r\nTTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_WC;\r\nman->default_caching = TTM_PL_FLAG_WC;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported memory type %u\n", (unsigned)type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_evict_flags(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement)\r\n{\r\nstruct radeon_bo *rbo;\r\nstatic u32 placements = TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM;\r\nif (!radeon_ttm_bo_is_radeon_bo(bo)) {\r\nplacement->fpfn = 0;\r\nplacement->lpfn = 0;\r\nplacement->placement = &placements;\r\nplacement->busy_placement = &placements;\r\nplacement->num_placement = 1;\r\nplacement->num_busy_placement = 1;\r\nreturn;\r\n}\r\nrbo = container_of(bo, struct radeon_bo, tbo);\r\nswitch (bo->mem.mem_type) {\r\ncase TTM_PL_VRAM:\r\nif (rbo->rdev->cp.ready == false)\r\nradeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_CPU);\r\nelse\r\nradeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_GTT);\r\nbreak;\r\ncase TTM_PL_TT:\r\ndefault:\r\nradeon_ttm_placement_from_domain(rbo, RADEON_GEM_DOMAIN_CPU);\r\n}\r\n*placement = rbo->placement;\r\n}\r\nstatic int radeon_verify_access(struct ttm_buffer_object *bo, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void radeon_move_null(struct ttm_buffer_object *bo,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nBUG_ON(old_mem->mm_node != NULL);\r\n*old_mem = *new_mem;\r\nnew_mem->mm_node = NULL;\r\n}\r\nstatic int radeon_move_blit(struct ttm_buffer_object *bo,\r\nbool evict, int no_wait_reserve, bool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem,\r\nstruct ttm_mem_reg *old_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nuint64_t old_start, new_start;\r\nstruct radeon_fence *fence;\r\nint r;\r\nrdev = radeon_get_rdev(bo->bdev);\r\nr = radeon_fence_create(rdev, &fence);\r\nif (unlikely(r)) {\r\nreturn r;\r\n}\r\nold_start = old_mem->start << PAGE_SHIFT;\r\nnew_start = new_mem->start << PAGE_SHIFT;\r\nswitch (old_mem->mem_type) {\r\ncase TTM_PL_VRAM:\r\nold_start += rdev->mc.vram_start;\r\nbreak;\r\ncase TTM_PL_TT:\r\nold_start += rdev->mc.gtt_start;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown placement %d\n", old_mem->mem_type);\r\nreturn -EINVAL;\r\n}\r\nswitch (new_mem->mem_type) {\r\ncase TTM_PL_VRAM:\r\nnew_start += rdev->mc.vram_start;\r\nbreak;\r\ncase TTM_PL_TT:\r\nnew_start += rdev->mc.gtt_start;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown placement %d\n", old_mem->mem_type);\r\nreturn -EINVAL;\r\n}\r\nif (!rdev->cp.ready) {\r\nDRM_ERROR("Trying to move memory with CP turned off.\n");\r\nreturn -EINVAL;\r\n}\r\nBUILD_BUG_ON((PAGE_SIZE % RADEON_GPU_PAGE_SIZE) != 0);\r\nr = radeon_copy(rdev, old_start, new_start,\r\nnew_mem->num_pages * (PAGE_SIZE / RADEON_GPU_PAGE_SIZE),\r\nfence);\r\nr = ttm_bo_move_accel_cleanup(bo, (void *)fence, NULL,\r\nevict, no_wait_reserve, no_wait_gpu, new_mem);\r\nradeon_fence_unref(&fence);\r\nreturn r;\r\n}\r\nstatic int radeon_move_vram_ram(struct ttm_buffer_object *bo,\r\nbool evict, bool interruptible,\r\nbool no_wait_reserve, bool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nstruct ttm_mem_reg tmp_mem;\r\nu32 placements;\r\nstruct ttm_placement placement;\r\nint r;\r\nrdev = radeon_get_rdev(bo->bdev);\r\ntmp_mem = *new_mem;\r\ntmp_mem.mm_node = NULL;\r\nplacement.fpfn = 0;\r\nplacement.lpfn = 0;\r\nplacement.num_placement = 1;\r\nplacement.placement = &placements;\r\nplacement.num_busy_placement = 1;\r\nplacement.busy_placement = &placements;\r\nplacements = TTM_PL_MASK_CACHING | TTM_PL_FLAG_TT;\r\nr = ttm_bo_mem_space(bo, &placement, &tmp_mem,\r\ninterruptible, no_wait_reserve, no_wait_gpu);\r\nif (unlikely(r)) {\r\nreturn r;\r\n}\r\nr = ttm_tt_set_placement_caching(bo->ttm, tmp_mem.placement);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = ttm_tt_bind(bo->ttm, &tmp_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = radeon_move_blit(bo, true, no_wait_reserve, no_wait_gpu, &tmp_mem, old_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = ttm_bo_move_ttm(bo, true, no_wait_reserve, no_wait_gpu, new_mem);\r\nout_cleanup:\r\nttm_bo_mem_put(bo, &tmp_mem);\r\nreturn r;\r\n}\r\nstatic int radeon_move_ram_vram(struct ttm_buffer_object *bo,\r\nbool evict, bool interruptible,\r\nbool no_wait_reserve, bool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nstruct ttm_mem_reg tmp_mem;\r\nstruct ttm_placement placement;\r\nu32 placements;\r\nint r;\r\nrdev = radeon_get_rdev(bo->bdev);\r\ntmp_mem = *new_mem;\r\ntmp_mem.mm_node = NULL;\r\nplacement.fpfn = 0;\r\nplacement.lpfn = 0;\r\nplacement.num_placement = 1;\r\nplacement.placement = &placements;\r\nplacement.num_busy_placement = 1;\r\nplacement.busy_placement = &placements;\r\nplacements = TTM_PL_MASK_CACHING | TTM_PL_FLAG_TT;\r\nr = ttm_bo_mem_space(bo, &placement, &tmp_mem, interruptible, no_wait_reserve, no_wait_gpu);\r\nif (unlikely(r)) {\r\nreturn r;\r\n}\r\nr = ttm_bo_move_ttm(bo, true, no_wait_reserve, no_wait_gpu, &tmp_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nr = radeon_move_blit(bo, true, no_wait_reserve, no_wait_gpu, new_mem, old_mem);\r\nif (unlikely(r)) {\r\ngoto out_cleanup;\r\n}\r\nout_cleanup:\r\nttm_bo_mem_put(bo, &tmp_mem);\r\nreturn r;\r\n}\r\nstatic int radeon_bo_move(struct ttm_buffer_object *bo,\r\nbool evict, bool interruptible,\r\nbool no_wait_reserve, bool no_wait_gpu,\r\nstruct ttm_mem_reg *new_mem)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct ttm_mem_reg *old_mem = &bo->mem;\r\nint r;\r\nrdev = radeon_get_rdev(bo->bdev);\r\nif (old_mem->mem_type == TTM_PL_SYSTEM && bo->ttm == NULL) {\r\nradeon_move_null(bo, new_mem);\r\nreturn 0;\r\n}\r\nif ((old_mem->mem_type == TTM_PL_TT &&\r\nnew_mem->mem_type == TTM_PL_SYSTEM) ||\r\n(old_mem->mem_type == TTM_PL_SYSTEM &&\r\nnew_mem->mem_type == TTM_PL_TT)) {\r\nradeon_move_null(bo, new_mem);\r\nreturn 0;\r\n}\r\nif (!rdev->cp.ready || rdev->asic->copy == NULL) {\r\ngoto memcpy;\r\n}\r\nif (old_mem->mem_type == TTM_PL_VRAM &&\r\nnew_mem->mem_type == TTM_PL_SYSTEM) {\r\nr = radeon_move_vram_ram(bo, evict, interruptible,\r\nno_wait_reserve, no_wait_gpu, new_mem);\r\n} else if (old_mem->mem_type == TTM_PL_SYSTEM &&\r\nnew_mem->mem_type == TTM_PL_VRAM) {\r\nr = radeon_move_ram_vram(bo, evict, interruptible,\r\nno_wait_reserve, no_wait_gpu, new_mem);\r\n} else {\r\nr = radeon_move_blit(bo, evict, no_wait_reserve, no_wait_gpu, new_mem, old_mem);\r\n}\r\nif (r) {\r\nmemcpy:\r\nr = ttm_bo_move_memcpy(bo, evict, no_wait_reserve, no_wait_gpu, new_mem);\r\n}\r\nreturn r;\r\n}\r\nstatic int radeon_ttm_io_mem_reserve(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];\r\nstruct radeon_device *rdev = radeon_get_rdev(bdev);\r\nmem->bus.addr = NULL;\r\nmem->bus.offset = 0;\r\nmem->bus.size = mem->num_pages << PAGE_SHIFT;\r\nmem->bus.base = 0;\r\nmem->bus.is_iomem = false;\r\nif (!(man->flags & TTM_MEMTYPE_FLAG_MAPPABLE))\r\nreturn -EINVAL;\r\nswitch (mem->mem_type) {\r\ncase TTM_PL_SYSTEM:\r\nreturn 0;\r\ncase TTM_PL_TT:\r\n#if __OS_HAS_AGP\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nmem->bus.offset = mem->start << PAGE_SHIFT;\r\nmem->bus.base = rdev->mc.agp_base;\r\nmem->bus.is_iomem = !rdev->ddev->agp->cant_use_aperture;\r\n}\r\n#endif\r\nbreak;\r\ncase TTM_PL_VRAM:\r\nmem->bus.offset = mem->start << PAGE_SHIFT;\r\nif ((mem->bus.offset + mem->bus.size) > rdev->mc.visible_vram_size)\r\nreturn -EINVAL;\r\nmem->bus.base = rdev->mc.aper_base;\r\nmem->bus.is_iomem = true;\r\n#ifdef __alpha__\r\nif (mem->placement & TTM_PL_FLAG_WC)\r\nmem->bus.addr =\r\nioremap_wc(mem->bus.base + mem->bus.offset,\r\nmem->bus.size);\r\nelse\r\nmem->bus.addr =\r\nioremap_nocache(mem->bus.base + mem->bus.offset,\r\nmem->bus.size);\r\nmem->bus.base = (mem->bus.base & 0x0ffffffffUL) +\r\nrdev->ddev->hose->dense_mem_base;\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_io_mem_free(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem)\r\n{\r\n}\r\nstatic int radeon_sync_obj_wait(void *sync_obj, void *sync_arg,\r\nbool lazy, bool interruptible)\r\n{\r\nreturn radeon_fence_wait((struct radeon_fence *)sync_obj, interruptible);\r\n}\r\nstatic int radeon_sync_obj_flush(void *sync_obj, void *sync_arg)\r\n{\r\nreturn 0;\r\n}\r\nstatic void radeon_sync_obj_unref(void **sync_obj)\r\n{\r\nradeon_fence_unref((struct radeon_fence **)sync_obj);\r\n}\r\nstatic void *radeon_sync_obj_ref(void *sync_obj)\r\n{\r\nreturn radeon_fence_ref((struct radeon_fence *)sync_obj);\r\n}\r\nstatic bool radeon_sync_obj_signaled(void *sync_obj, void *sync_arg)\r\n{\r\nreturn radeon_fence_signaled((struct radeon_fence *)sync_obj);\r\n}\r\nint radeon_ttm_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nr = radeon_ttm_global_init(rdev);\r\nif (r) {\r\nreturn r;\r\n}\r\nr = ttm_bo_device_init(&rdev->mman.bdev,\r\nrdev->mman.bo_global_ref.ref.object,\r\n&radeon_bo_driver, DRM_FILE_PAGE_OFFSET,\r\nrdev->need_dma32);\r\nif (r) {\r\nDRM_ERROR("failed initializing buffer object driver(%d).\n", r);\r\nreturn r;\r\n}\r\nrdev->mman.initialized = true;\r\nr = ttm_bo_init_mm(&rdev->mman.bdev, TTM_PL_VRAM,\r\nrdev->mc.real_vram_size >> PAGE_SHIFT);\r\nif (r) {\r\nDRM_ERROR("Failed initializing VRAM heap.\n");\r\nreturn r;\r\n}\r\nr = radeon_bo_create(rdev, 256 * 1024, PAGE_SIZE, true,\r\nRADEON_GEM_DOMAIN_VRAM,\r\n&rdev->stollen_vga_memory);\r\nif (r) {\r\nreturn r;\r\n}\r\nr = radeon_bo_reserve(rdev->stollen_vga_memory, false);\r\nif (r)\r\nreturn r;\r\nr = radeon_bo_pin(rdev->stollen_vga_memory, RADEON_GEM_DOMAIN_VRAM, NULL);\r\nradeon_bo_unreserve(rdev->stollen_vga_memory);\r\nif (r) {\r\nradeon_bo_unref(&rdev->stollen_vga_memory);\r\nreturn r;\r\n}\r\nDRM_INFO("radeon: %uM of VRAM memory ready\n",\r\n(unsigned)rdev->mc.real_vram_size / (1024 * 1024));\r\nr = ttm_bo_init_mm(&rdev->mman.bdev, TTM_PL_TT,\r\nrdev->mc.gtt_size >> PAGE_SHIFT);\r\nif (r) {\r\nDRM_ERROR("Failed initializing GTT heap.\n");\r\nreturn r;\r\n}\r\nDRM_INFO("radeon: %uM of GTT memory ready.\n",\r\n(unsigned)(rdev->mc.gtt_size / (1024 * 1024)));\r\nif (unlikely(rdev->mman.bdev.dev_mapping == NULL)) {\r\nrdev->mman.bdev.dev_mapping = rdev->ddev->dev_mapping;\r\n}\r\nr = radeon_ttm_debugfs_init(rdev);\r\nif (r) {\r\nDRM_ERROR("Failed to init debugfs\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_ttm_fini(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (!rdev->mman.initialized)\r\nreturn;\r\nif (rdev->stollen_vga_memory) {\r\nr = radeon_bo_reserve(rdev->stollen_vga_memory, false);\r\nif (r == 0) {\r\nradeon_bo_unpin(rdev->stollen_vga_memory);\r\nradeon_bo_unreserve(rdev->stollen_vga_memory);\r\n}\r\nradeon_bo_unref(&rdev->stollen_vga_memory);\r\n}\r\nttm_bo_clean_mm(&rdev->mman.bdev, TTM_PL_VRAM);\r\nttm_bo_clean_mm(&rdev->mman.bdev, TTM_PL_TT);\r\nttm_bo_device_release(&rdev->mman.bdev);\r\nradeon_gart_fini(rdev);\r\nradeon_ttm_global_fini(rdev);\r\nrdev->mman.initialized = false;\r\nDRM_INFO("radeon: ttm finalized\n");\r\n}\r\nvoid radeon_ttm_set_active_vram_size(struct radeon_device *rdev, u64 size)\r\n{\r\nstruct ttm_mem_type_manager *man;\r\nif (!rdev->mman.initialized)\r\nreturn;\r\nman = &rdev->mman.bdev.man[TTM_PL_VRAM];\r\nman->size = size >> PAGE_SHIFT;\r\n}\r\nstatic int radeon_ttm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct ttm_buffer_object *bo;\r\nstruct radeon_device *rdev;\r\nint r;\r\nbo = (struct ttm_buffer_object *)vma->vm_private_data;\r\nif (bo == NULL) {\r\nreturn VM_FAULT_NOPAGE;\r\n}\r\nrdev = radeon_get_rdev(bo->bdev);\r\nmutex_lock(&rdev->vram_mutex);\r\nr = ttm_vm_ops->fault(vma, vmf);\r\nmutex_unlock(&rdev->vram_mutex);\r\nreturn r;\r\n}\r\nint radeon_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv;\r\nstruct radeon_device *rdev;\r\nint r;\r\nif (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET)) {\r\nreturn drm_mmap(filp, vma);\r\n}\r\nfile_priv = filp->private_data;\r\nrdev = file_priv->minor->dev->dev_private;\r\nif (rdev == NULL) {\r\nreturn -EINVAL;\r\n}\r\nr = ttm_bo_mmap(filp, vma, &rdev->mman.bdev);\r\nif (unlikely(r != 0)) {\r\nreturn r;\r\n}\r\nif (unlikely(ttm_vm_ops == NULL)) {\r\nttm_vm_ops = vma->vm_ops;\r\nradeon_ttm_vm_ops = *ttm_vm_ops;\r\nradeon_ttm_vm_ops.fault = &radeon_ttm_fault;\r\n}\r\nvma->vm_ops = &radeon_ttm_vm_ops;\r\nreturn 0;\r\n}\r\nstatic int radeon_ttm_backend_populate(struct ttm_backend *backend,\r\nunsigned long num_pages,\r\nstruct page **pages,\r\nstruct page *dummy_read_page,\r\ndma_addr_t *dma_addrs)\r\n{\r\nstruct radeon_ttm_backend *gtt;\r\ngtt = container_of(backend, struct radeon_ttm_backend, backend);\r\ngtt->pages = pages;\r\ngtt->dma_addrs = dma_addrs;\r\ngtt->num_pages = num_pages;\r\ngtt->dummy_read_page = dummy_read_page;\r\ngtt->populated = true;\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_backend_clear(struct ttm_backend *backend)\r\n{\r\nstruct radeon_ttm_backend *gtt;\r\ngtt = container_of(backend, struct radeon_ttm_backend, backend);\r\ngtt->pages = NULL;\r\ngtt->dma_addrs = NULL;\r\ngtt->num_pages = 0;\r\ngtt->dummy_read_page = NULL;\r\ngtt->populated = false;\r\ngtt->bound = false;\r\n}\r\nstatic int radeon_ttm_backend_bind(struct ttm_backend *backend,\r\nstruct ttm_mem_reg *bo_mem)\r\n{\r\nstruct radeon_ttm_backend *gtt;\r\nint r;\r\ngtt = container_of(backend, struct radeon_ttm_backend, backend);\r\ngtt->offset = bo_mem->start << PAGE_SHIFT;\r\nif (!gtt->num_pages) {\r\nWARN(1, "nothing to bind %lu pages for mreg %p back %p!\n",\r\ngtt->num_pages, bo_mem, backend);\r\n}\r\nr = radeon_gart_bind(gtt->rdev, gtt->offset,\r\ngtt->num_pages, gtt->pages, gtt->dma_addrs);\r\nif (r) {\r\nDRM_ERROR("failed to bind %lu pages at 0x%08X\n",\r\ngtt->num_pages, gtt->offset);\r\nreturn r;\r\n}\r\ngtt->bound = true;\r\nreturn 0;\r\n}\r\nstatic int radeon_ttm_backend_unbind(struct ttm_backend *backend)\r\n{\r\nstruct radeon_ttm_backend *gtt;\r\ngtt = container_of(backend, struct radeon_ttm_backend, backend);\r\nradeon_gart_unbind(gtt->rdev, gtt->offset, gtt->num_pages);\r\ngtt->bound = false;\r\nreturn 0;\r\n}\r\nstatic void radeon_ttm_backend_destroy(struct ttm_backend *backend)\r\n{\r\nstruct radeon_ttm_backend *gtt;\r\ngtt = container_of(backend, struct radeon_ttm_backend, backend);\r\nif (gtt->bound) {\r\nradeon_ttm_backend_unbind(backend);\r\n}\r\nkfree(gtt);\r\n}\r\nstruct ttm_backend *radeon_ttm_backend_create(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ttm_backend *gtt;\r\ngtt = kzalloc(sizeof(struct radeon_ttm_backend), GFP_KERNEL);\r\nif (gtt == NULL) {\r\nreturn NULL;\r\n}\r\ngtt->backend.bdev = &rdev->mman.bdev;\r\ngtt->backend.flags = 0;\r\ngtt->backend.func = &radeon_backend_func;\r\ngtt->rdev = rdev;\r\ngtt->pages = NULL;\r\ngtt->num_pages = 0;\r\ngtt->dummy_read_page = NULL;\r\ngtt->populated = false;\r\ngtt->bound = false;\r\nreturn &gtt->backend;\r\n}\r\nstatic int radeon_mm_dump_table(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_mm *mm = (struct drm_mm *)node->info_ent->data;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint ret;\r\nstruct ttm_bo_global *glob = rdev->mman.bdev.glob;\r\nspin_lock(&glob->lru_lock);\r\nret = drm_mm_dump_table(m, mm);\r\nspin_unlock(&glob->lru_lock);\r\nreturn ret;\r\n}\r\nstatic int radeon_ttm_debugfs_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nstatic struct drm_info_list radeon_mem_types_list[RADEON_DEBUGFS_MEM_TYPES+1];\r\nstatic char radeon_mem_types_names[RADEON_DEBUGFS_MEM_TYPES+1][32];\r\nunsigned i;\r\nfor (i = 0; i < RADEON_DEBUGFS_MEM_TYPES; i++) {\r\nif (i == 0)\r\nsprintf(radeon_mem_types_names[i], "radeon_vram_mm");\r\nelse\r\nsprintf(radeon_mem_types_names[i], "radeon_gtt_mm");\r\nradeon_mem_types_list[i].name = radeon_mem_types_names[i];\r\nradeon_mem_types_list[i].show = &radeon_mm_dump_table;\r\nradeon_mem_types_list[i].driver_features = 0;\r\nif (i == 0)\r\nradeon_mem_types_list[i].data = rdev->mman.bdev.man[TTM_PL_VRAM].priv;\r\nelse\r\nradeon_mem_types_list[i].data = rdev->mman.bdev.man[TTM_PL_TT].priv;\r\n}\r\nsprintf(radeon_mem_types_names[i], "ttm_page_pool");\r\nradeon_mem_types_list[i].name = radeon_mem_types_names[i];\r\nradeon_mem_types_list[i].show = &ttm_page_alloc_debugfs;\r\nradeon_mem_types_list[i].driver_features = 0;\r\nradeon_mem_types_list[i].data = NULL;\r\nreturn radeon_debugfs_add_files(rdev, radeon_mem_types_list, RADEON_DEBUGFS_MEM_TYPES+1);\r\n#endif\r\nreturn 0;\r\n}
