static void dst_packsize(struct dst_state *state, int psize)\r\n{\r\nunion dst_gpio_packet bits;\r\nbits.psize = psize;\r\nbt878_device_control(state->bt, DST_IG_TS, &bits);\r\n}\r\nstatic int dst_gpio_outb(struct dst_state *state, u32 mask, u32 enbb,\r\nu32 outhigh, int delay)\r\n{\r\nunion dst_gpio_packet enb;\r\nunion dst_gpio_packet bits;\r\nint err;\r\nenb.enb.mask = mask;\r\nenb.enb.enable = enbb;\r\ndprintk(verbose, DST_INFO, 1, "mask=[%04x], enbb=[%04x], outhigh=[%04x]", mask, enbb, outhigh);\r\nif ((err = bt878_device_control(state->bt, DST_IG_ENABLE, &enb)) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "dst_gpio_enb error (err == %i, mask == %02x, enb == %02x)", err, mask, enbb);\r\nreturn -EREMOTEIO;\r\n}\r\nudelay(1000);\r\nif (enbb == 0)\r\nreturn 0;\r\nif (delay)\r\nmsleep(10);\r\nbits.outp.mask = enbb;\r\nbits.outp.highvals = outhigh;\r\nif ((err = bt878_device_control(state->bt, DST_IG_WRITE, &bits)) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "dst_gpio_outb error (err == %i, enbb == %02x, outhigh == %02x)", err, enbb, outhigh);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_gpio_inb(struct dst_state *state, u8 *result)\r\n{\r\nunion dst_gpio_packet rd_packet;\r\nint err;\r\n*result = 0;\r\nif ((err = bt878_device_control(state->bt, DST_IG_READ, &rd_packet)) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_inb error (err == %i)", err);\r\nreturn -EREMOTEIO;\r\n}\r\n*result = (u8) rd_packet.rd.value;\r\nreturn 0;\r\n}\r\nint rdc_reset_state(struct dst_state *state)\r\n{\r\ndprintk(verbose, DST_INFO, 1, "Resetting state machine");\r\nif (dst_gpio_outb(state, RDC_8820_INT, RDC_8820_INT, 0, NO_DELAY) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_outb ERROR !");\r\nreturn -1;\r\n}\r\nmsleep(10);\r\nif (dst_gpio_outb(state, RDC_8820_INT, RDC_8820_INT, RDC_8820_INT, NO_DELAY) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_outb ERROR !");\r\nmsleep(10);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rdc_8820_reset(struct dst_state *state)\r\n{\r\ndprintk(verbose, DST_DEBUG, 1, "Resetting DST");\r\nif (dst_gpio_outb(state, RDC_8820_RESET, RDC_8820_RESET, 0, NO_DELAY) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_outb ERROR !");\r\nreturn -1;\r\n}\r\nudelay(1000);\r\nif (dst_gpio_outb(state, RDC_8820_RESET, RDC_8820_RESET, RDC_8820_RESET, DELAY) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_outb ERROR !");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_pio_enable(struct dst_state *state)\r\n{\r\nif (dst_gpio_outb(state, ~0, RDC_8820_PIO_0_ENABLE, 0, NO_DELAY) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_outb ERROR !");\r\nreturn -1;\r\n}\r\nudelay(1000);\r\nreturn 0;\r\n}\r\nint dst_pio_disable(struct dst_state *state)\r\n{\r\nif (dst_gpio_outb(state, ~0, RDC_8820_PIO_0_DISABLE, RDC_8820_PIO_0_DISABLE, NO_DELAY) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_outb ERROR !");\r\nreturn -1;\r\n}\r\nif (state->type_flags & DST_TYPE_HAS_FW_1)\r\nudelay(1000);\r\nreturn 0;\r\n}\r\nint dst_wait_dst_ready(struct dst_state *state, u8 delay_mode)\r\n{\r\nu8 reply;\r\nint i;\r\nfor (i = 0; i < 200; i++) {\r\nif (dst_gpio_inb(state, &reply) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "dst_gpio_inb ERROR !");\r\nreturn -1;\r\n}\r\nif ((reply & RDC_8820_PIO_0_ENABLE) == 0) {\r\ndprintk(verbose, DST_INFO, 1, "dst wait ready after %d", i);\r\nreturn 1;\r\n}\r\nmsleep(10);\r\n}\r\ndprintk(verbose, DST_NOTICE, 1, "dst wait NOT ready after %d", i);\r\nreturn 0;\r\n}\r\nint dst_error_recovery(struct dst_state *state)\r\n{\r\ndprintk(verbose, DST_NOTICE, 1, "Trying to return from previous errors.");\r\ndst_pio_disable(state);\r\nmsleep(10);\r\ndst_pio_enable(state);\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nint dst_error_bailout(struct dst_state *state)\r\n{\r\ndprintk(verbose, DST_INFO, 1, "Trying to bailout from previous error.");\r\nrdc_8820_reset(state);\r\ndst_pio_disable(state);\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nint dst_comm_init(struct dst_state *state)\r\n{\r\ndprintk(verbose, DST_INFO, 1, "Initializing DST.");\r\nif ((dst_pio_enable(state)) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "PIO Enable Failed");\r\nreturn -1;\r\n}\r\nif ((rdc_reset_state(state)) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "RDC 8820 State RESET Failed.");\r\nreturn -1;\r\n}\r\nif (state->type_flags & DST_TYPE_HAS_FW_1)\r\nmsleep(100);\r\nelse\r\nmsleep(5);\r\nreturn 0;\r\n}\r\nint write_dst(struct dst_state *state, u8 *data, u8 len)\r\n{\r\nstruct i2c_msg msg = {\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = data,\r\n.len = len\r\n};\r\nint err;\r\nu8 cnt, i;\r\ndprintk(verbose, DST_NOTICE, 0, "writing [ ");\r\nfor (i = 0; i < len; i++)\r\ndprintk(verbose, DST_NOTICE, 0, "%02x ", data[i]);\r\ndprintk(verbose, DST_NOTICE, 0, "]\n");\r\nfor (cnt = 0; cnt < 2; cnt++) {\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "_write_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)", err, len, data[0]);\r\ndst_error_recovery(state);\r\ncontinue;\r\n} else\r\nbreak;\r\n}\r\nif (cnt >= 2) {\r\ndprintk(verbose, DST_INFO, 1, "RDC 8820 RESET");\r\ndst_error_bailout(state);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint read_dst(struct dst_state *state, u8 *ret, u8 len)\r\n{\r\nstruct i2c_msg msg = {\r\n.addr = state->config->demod_address,\r\n.flags = I2C_M_RD,\r\n.buf = ret,\r\n.len = len\r\n};\r\nint err;\r\nint cnt;\r\nfor (cnt = 0; cnt < 2; cnt++) {\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "read_dst error (err == %i, len == 0x%02x, b0 == 0x%02x)", err, len, ret[0]);\r\ndst_error_recovery(state);\r\ncontinue;\r\n} else\r\nbreak;\r\n}\r\nif (cnt >= 2) {\r\ndprintk(verbose, DST_INFO, 1, "RDC 8820 RESET");\r\ndst_error_bailout(state);\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_DEBUG, 1, "reply is 0x%x", ret[0]);\r\nfor (err = 1; err < len; err++)\r\ndprintk(verbose, DST_DEBUG, 0, " 0x%x", ret[err]);\r\nif (err > 1)\r\ndprintk(verbose, DST_DEBUG, 0, "\n");\r\nreturn 0;\r\n}\r\nstatic int dst_set_polarization(struct dst_state *state)\r\n{\r\nswitch (state->voltage) {\r\ncase SEC_VOLTAGE_13:\r\ndprintk(verbose, DST_INFO, 1, "Polarization=[Vertical]");\r\nstate->tx_tuna[8] &= ~0x40;\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\ndprintk(verbose, DST_INFO, 1, "Polarization=[Horizontal]");\r\nstate->tx_tuna[8] |= 0x40;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_set_freq(struct dst_state *state, u32 freq)\r\n{\r\nstate->frequency = freq;\r\ndprintk(verbose, DST_INFO, 1, "set Frequency %u", freq);\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nfreq = freq / 1000;\r\nif (freq < 950 || freq > 2150)\r\nreturn -EINVAL;\r\nstate->tx_tuna[2] = (freq >> 8);\r\nstate->tx_tuna[3] = (u8) freq;\r\nstate->tx_tuna[4] = 0x01;\r\nstate->tx_tuna[8] &= ~0x04;\r\nif (state->type_flags & DST_TYPE_HAS_OBS_REGS) {\r\nif (freq < 1531)\r\nstate->tx_tuna[8] |= 0x04;\r\n}\r\n} else if (state->dst_type == DST_TYPE_IS_TERR) {\r\nfreq = freq / 1000;\r\nif (freq < 137000 || freq > 858000)\r\nreturn -EINVAL;\r\nstate->tx_tuna[2] = (freq >> 16) & 0xff;\r\nstate->tx_tuna[3] = (freq >> 8) & 0xff;\r\nstate->tx_tuna[4] = (u8) freq;\r\n} else if (state->dst_type == DST_TYPE_IS_CABLE) {\r\nfreq = freq / 1000;\r\nstate->tx_tuna[2] = (freq >> 16) & 0xff;\r\nstate->tx_tuna[3] = (freq >> 8) & 0xff;\r\nstate->tx_tuna[4] = (u8) freq;\r\n} else if (state->dst_type == DST_TYPE_IS_ATSC) {\r\nfreq = freq / 1000;\r\nif (freq < 51000 || freq > 858000)\r\nreturn -EINVAL;\r\nstate->tx_tuna[2] = (freq >> 16) & 0xff;\r\nstate->tx_tuna[3] = (freq >> 8) & 0xff;\r\nstate->tx_tuna[4] = (u8) freq;\r\nstate->tx_tuna[5] = 0x00;\r\nstate->tx_tuna[6] = 0x00;\r\nif (state->dst_hw_cap & DST_TYPE_HAS_ANALOG)\r\nstate->tx_tuna[7] = 0x00;\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dst_set_bandwidth(struct dst_state *state, fe_bandwidth_t bandwidth)\r\n{\r\nstate->bandwidth = bandwidth;\r\nif (state->dst_type != DST_TYPE_IS_TERR)\r\nreturn -EOPNOTSUPP;\r\nswitch (bandwidth) {\r\ncase BANDWIDTH_6_MHZ:\r\nif (state->dst_hw_cap & DST_TYPE_HAS_CA)\r\nstate->tx_tuna[7] = 0x06;\r\nelse {\r\nstate->tx_tuna[6] = 0x06;\r\nstate->tx_tuna[7] = 0x00;\r\n}\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\nif (state->dst_hw_cap & DST_TYPE_HAS_CA)\r\nstate->tx_tuna[7] = 0x07;\r\nelse {\r\nstate->tx_tuna[6] = 0x07;\r\nstate->tx_tuna[7] = 0x00;\r\n}\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\nif (state->dst_hw_cap & DST_TYPE_HAS_CA)\r\nstate->tx_tuna[7] = 0x08;\r\nelse {\r\nstate->tx_tuna[6] = 0x08;\r\nstate->tx_tuna[7] = 0x00;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_set_inversion(struct dst_state *state, fe_spectral_inversion_t inversion)\r\n{\r\nstate->inversion = inversion;\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nstate->tx_tuna[8] &= ~0x80;\r\nbreak;\r\ncase INVERSION_ON:\r\nstate->tx_tuna[8] |= 0x80;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_set_fec(struct dst_state *state, fe_code_rate_t fec)\r\n{\r\nstate->fec = fec;\r\nreturn 0;\r\n}\r\nstatic fe_code_rate_t dst_get_fec(struct dst_state *state)\r\n{\r\nreturn state->fec;\r\n}\r\nstatic int dst_set_symbolrate(struct dst_state *state, u32 srate)\r\n{\r\nu32 symcalc;\r\nu64 sval;\r\nstate->symbol_rate = srate;\r\nif (state->dst_type == DST_TYPE_IS_TERR) {\r\nreturn -EOPNOTSUPP;\r\n}\r\ndprintk(verbose, DST_INFO, 1, "set symrate %u", srate);\r\nsrate /= 1000;\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nif (state->type_flags & DST_TYPE_HAS_SYMDIV) {\r\nsval = srate;\r\nsval <<= 20;\r\ndo_div(sval, 88000);\r\nsymcalc = (u32) sval;\r\ndprintk(verbose, DST_INFO, 1, "set symcalc %u", symcalc);\r\nstate->tx_tuna[5] = (u8) (symcalc >> 12);\r\nstate->tx_tuna[6] = (u8) (symcalc >> 4);\r\nstate->tx_tuna[7] = (u8) (symcalc << 4);\r\n} else {\r\nstate->tx_tuna[5] = (u8) (srate >> 16) & 0x7f;\r\nstate->tx_tuna[6] = (u8) (srate >> 8);\r\nstate->tx_tuna[7] = (u8) srate;\r\n}\r\nstate->tx_tuna[8] &= ~0x20;\r\nif (state->type_flags & DST_TYPE_HAS_OBS_REGS) {\r\nif (srate > 8000)\r\nstate->tx_tuna[8] |= 0x20;\r\n}\r\n} else if (state->dst_type == DST_TYPE_IS_CABLE) {\r\ndprintk(verbose, DST_DEBUG, 1, "%s", state->fw_name);\r\nif (!strncmp(state->fw_name, "DCTNEW", 6)) {\r\nstate->tx_tuna[5] = (u8) (srate >> 8);\r\nstate->tx_tuna[6] = (u8) srate;\r\nstate->tx_tuna[7] = 0x00;\r\n} else if (!strncmp(state->fw_name, "DCT-CI", 6)) {\r\nstate->tx_tuna[5] = 0x00;\r\nstate->tx_tuna[6] = (u8) (srate >> 8);\r\nstate->tx_tuna[7] = (u8) srate;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_set_modulation(struct dst_state *state, fe_modulation_t modulation)\r\n{\r\nif (state->dst_type != DST_TYPE_IS_CABLE)\r\nreturn -EOPNOTSUPP;\r\nstate->modulation = modulation;\r\nswitch (modulation) {\r\ncase QAM_16:\r\nstate->tx_tuna[8] = 0x10;\r\nbreak;\r\ncase QAM_32:\r\nstate->tx_tuna[8] = 0x20;\r\nbreak;\r\ncase QAM_64:\r\nstate->tx_tuna[8] = 0x40;\r\nbreak;\r\ncase QAM_128:\r\nstate->tx_tuna[8] = 0x80;\r\nbreak;\r\ncase QAM_256:\r\nif (!strncmp(state->fw_name, "DCTNEW", 6))\r\nstate->tx_tuna[8] = 0xff;\r\nelse if (!strncmp(state->fw_name, "DCT-CI", 6))\r\nstate->tx_tuna[8] = 0x00;\r\nbreak;\r\ncase QPSK:\r\ncase QAM_AUTO:\r\ncase VSB_8:\r\ncase VSB_16:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic fe_modulation_t dst_get_modulation(struct dst_state *state)\r\n{\r\nreturn state->modulation;\r\n}\r\nu8 dst_check_sum(u8 *buf, u32 len)\r\n{\r\nu32 i;\r\nu8 val = 0;\r\nif (!len)\r\nreturn 0;\r\nfor (i = 0; i < len; i++) {\r\nval += buf[i];\r\n}\r\nreturn ((~val) + 1);\r\n}\r\nstatic void dst_type_flags_print(struct dst_state *state)\r\n{\r\nu32 type_flags = state->type_flags;\r\ndprintk(verbose, DST_ERROR, 0, "DST type flags :");\r\nif (type_flags & DST_TYPE_HAS_TS188)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x newtuner", DST_TYPE_HAS_TS188);\r\nif (type_flags & DST_TYPE_HAS_NEWTUNE_2)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x newtuner 2", DST_TYPE_HAS_NEWTUNE_2);\r\nif (type_flags & DST_TYPE_HAS_TS204)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x ts204", DST_TYPE_HAS_TS204);\r\nif (type_flags & DST_TYPE_HAS_VLF)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x VLF", DST_TYPE_HAS_VLF);\r\nif (type_flags & DST_TYPE_HAS_SYMDIV)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x symdiv", DST_TYPE_HAS_SYMDIV);\r\nif (type_flags & DST_TYPE_HAS_FW_1)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x firmware version = 1", DST_TYPE_HAS_FW_1);\r\nif (type_flags & DST_TYPE_HAS_FW_2)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x firmware version = 2", DST_TYPE_HAS_FW_2);\r\nif (type_flags & DST_TYPE_HAS_FW_3)\r\ndprintk(verbose, DST_ERROR, 0, " 0x%x firmware version = 3", DST_TYPE_HAS_FW_3);\r\ndprintk(verbose, DST_ERROR, 0, "\n");\r\n}\r\nstatic int dst_type_print(struct dst_state *state, u8 type)\r\n{\r\nchar *otype;\r\nswitch (type) {\r\ncase DST_TYPE_IS_SAT:\r\notype = "satellite";\r\nbreak;\r\ncase DST_TYPE_IS_TERR:\r\notype = "terrestrial";\r\nbreak;\r\ncase DST_TYPE_IS_CABLE:\r\notype = "cable";\r\nbreak;\r\ncase DST_TYPE_IS_ATSC:\r\notype = "atsc";\r\nbreak;\r\ndefault:\r\ndprintk(verbose, DST_INFO, 1, "invalid dst type %d", type);\r\nreturn -EINVAL;\r\n}\r\ndprintk(verbose, DST_INFO, 1, "DST type: %s", otype);\r\nreturn 0;\r\n}\r\nstatic int dst_get_mac(struct dst_state *state)\r\n{\r\nu8 get_mac[] = { 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nget_mac[7] = dst_check_sum(get_mac, 7);\r\nif (dst_command(state, get_mac, 8) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Unsupported Command");\r\nreturn -1;\r\n}\r\nmemset(&state->mac_address, '\0', 8);\r\nmemcpy(&state->mac_address, &state->rxbuffer, 6);\r\ndprintk(verbose, DST_ERROR, 1, "MAC Address=[%pM]", state->mac_address);\r\nreturn 0;\r\n}\r\nstatic int dst_fw_ver(struct dst_state *state)\r\n{\r\nu8 get_ver[] = { 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nget_ver[7] = dst_check_sum(get_ver, 7);\r\nif (dst_command(state, get_ver, 8) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Unsupported Command");\r\nreturn -1;\r\n}\r\nmemcpy(&state->fw_version, &state->rxbuffer, 8);\r\ndprintk(verbose, DST_ERROR, 1, "Firmware Ver = %x.%x Build = %02x, on %x:%x, %x-%x-20%02x",\r\nstate->fw_version[0] >> 4, state->fw_version[0] & 0x0f,\r\nstate->fw_version[1],\r\nstate->fw_version[5], state->fw_version[6],\r\nstate->fw_version[4], state->fw_version[3], state->fw_version[2]);\r\nreturn 0;\r\n}\r\nstatic int dst_card_type(struct dst_state *state)\r\n{\r\nint j;\r\nstruct tuner_types *p_tuner_list = NULL;\r\nu8 get_type[] = { 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nget_type[7] = dst_check_sum(get_type, 7);\r\nif (dst_command(state, get_type, 8) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Unsupported Command");\r\nreturn -1;\r\n}\r\nmemset(&state->card_info, '\0', 8);\r\nmemcpy(&state->card_info, &state->rxbuffer, 7);\r\ndprintk(verbose, DST_ERROR, 1, "Device Model=[%s]", &state->card_info[0]);\r\nfor (j = 0, p_tuner_list = tuner_list; j < ARRAY_SIZE(tuner_list); j++, p_tuner_list++) {\r\nif (!strcmp(&state->card_info[0], p_tuner_list->board_name)) {\r\nstate->tuner_type = p_tuner_list->tuner_type;\r\ndprintk(verbose, DST_ERROR, 1, "DST has [%s] tuner, tuner type=[%d]",\r\np_tuner_list->tuner_name, p_tuner_list->tuner_type);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_get_vendor(struct dst_state *state)\r\n{\r\nu8 get_vendor[] = { 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nget_vendor[7] = dst_check_sum(get_vendor, 7);\r\nif (dst_command(state, get_vendor, 8) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Unsupported Command");\r\nreturn -1;\r\n}\r\nmemset(&state->vendor, '\0', 8);\r\nmemcpy(&state->vendor, &state->rxbuffer, 7);\r\ndprintk(verbose, DST_ERROR, 1, "Vendor=[%s]", &state->vendor[0]);\r\nreturn 0;\r\n}\r\nstatic void debug_dst_buffer(struct dst_state *state)\r\n{\r\nint i;\r\nif (verbose > 2) {\r\nprintk("%s: [", __func__);\r\nfor (i = 0; i < 8; i++)\r\nprintk(" %02x", state->rxbuffer[i]);\r\nprintk("]\n");\r\n}\r\n}\r\nstatic int dst_check_stv0299(struct dst_state *state)\r\n{\r\nu8 check_stv0299[] = { 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\ncheck_stv0299[7] = dst_check_sum(check_stv0299, 7);\r\nif (dst_command(state, check_stv0299, 8) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "Cmd=[0x04] failed");\r\nreturn -1;\r\n}\r\ndebug_dst_buffer(state);\r\nif (memcmp(&check_stv0299, &state->rxbuffer, 8)) {\r\ndprintk(verbose, DST_ERROR, 1, "Found a STV0299 NIM");\r\nstate->tuner_type = TUNER_TYPE_STV0299;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int dst_check_mb86a15(struct dst_state *state)\r\n{\r\nu8 check_mb86a15[] = { 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\ncheck_mb86a15[7] = dst_check_sum(check_mb86a15, 7);\r\nif (dst_command(state, check_mb86a15, 8) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "Cmd=[0x10], failed");\r\nreturn -1;\r\n}\r\ndebug_dst_buffer(state);\r\nif (memcmp(&check_mb86a15, &state->rxbuffer, 8) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "Found a MB86A15 NIM");\r\nstate->tuner_type = TUNER_TYPE_MB86A15;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int dst_get_tuner_info(struct dst_state *state)\r\n{\r\nu8 get_tuner_1[] = { 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nu8 get_tuner_2[] = { 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nget_tuner_1[7] = dst_check_sum(get_tuner_1, 7);\r\nget_tuner_2[7] = dst_check_sum(get_tuner_2, 7);\r\ndprintk(verbose, DST_ERROR, 1, "DST TYpe = MULTI FE");\r\nif (state->type_flags & DST_TYPE_HAS_MULTI_FE) {\r\nif (dst_command(state, get_tuner_1, 8) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Cmd=[0x13], Unsupported");\r\ngoto force;\r\n}\r\n} else {\r\nif (dst_command(state, get_tuner_2, 8) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Cmd=[0xb], Unsupported");\r\ngoto force;\r\n}\r\n}\r\nmemcpy(&state->board_info, &state->rxbuffer, 8);\r\nif (state->type_flags & DST_TYPE_HAS_MULTI_FE) {\r\ndprintk(verbose, DST_ERROR, 1, "DST type has TS=188");\r\n}\r\nif (state->board_info[0] == 0xbc) {\r\nif (state->dst_type != DST_TYPE_IS_ATSC)\r\nstate->type_flags |= DST_TYPE_HAS_TS188;\r\nelse\r\nstate->type_flags |= DST_TYPE_HAS_NEWTUNE_2;\r\nif (state->board_info[1] == 0x01) {\r\nstate->dst_hw_cap |= DST_TYPE_HAS_DBOARD;\r\ndprintk(verbose, DST_ERROR, 1, "DST has Daughterboard");\r\n}\r\n}\r\nreturn 0;\r\nforce:\r\nif (!strncmp(state->fw_name, "DCT-CI", 6)) {\r\nstate->type_flags |= DST_TYPE_HAS_TS204;\r\ndprintk(verbose, DST_ERROR, 1, "Forcing [%s] to TS188", state->fw_name);\r\n}\r\nreturn -1;\r\n}\r\nstatic int dst_get_device_id(struct dst_state *state)\r\n{\r\nu8 reply;\r\nint i, j;\r\nstruct dst_types *p_dst_type = NULL;\r\nstruct tuner_types *p_tuner_list = NULL;\r\nu8 use_dst_type = 0;\r\nu32 use_type_flags = 0;\r\nstatic u8 device_type[8] = {0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff};\r\nstate->tuner_type = 0;\r\ndevice_type[7] = dst_check_sum(device_type, 7);\r\nif (write_dst(state, device_type, FIXED_COMM))\r\nreturn -1;\r\nif ((dst_pio_disable(state)) < 0)\r\nreturn -1;\r\nif (read_dst(state, &reply, GET_ACK))\r\nreturn -1;\r\nif (reply != ACK) {\r\ndprintk(verbose, DST_INFO, 1, "Write not Acknowledged! [Reply=0x%02x]", reply);\r\nreturn -1;\r\n}\r\nif (!dst_wait_dst_ready(state, DEVICE_INIT))\r\nreturn -1;\r\nif (read_dst(state, state->rxbuffer, FIXED_COMM))\r\nreturn -1;\r\ndst_pio_disable(state);\r\nif (state->rxbuffer[7] != dst_check_sum(state->rxbuffer, 7)) {\r\ndprintk(verbose, DST_INFO, 1, "Checksum failure!");\r\nreturn -1;\r\n}\r\nstate->rxbuffer[7] = '\0';\r\nfor (i = 0, p_dst_type = dst_tlist; i < ARRAY_SIZE(dst_tlist); i++, p_dst_type++) {\r\nif (!strncmp (&state->rxbuffer[p_dst_type->offset], p_dst_type->device_id, strlen (p_dst_type->device_id))) {\r\nuse_type_flags = p_dst_type->type_flags;\r\nuse_dst_type = p_dst_type->dst_type;\r\nstate->dst_hw_cap = p_dst_type->dst_feature;\r\ndprintk(verbose, DST_ERROR, 1, "Recognise [%s]", p_dst_type->device_id);\r\nstrncpy(&state->fw_name[0], p_dst_type->device_id, 6);\r\nif (p_dst_type->tuner_type & TUNER_TYPE_MULTI) {\r\nswitch (use_dst_type) {\r\ncase DST_TYPE_IS_SAT:\r\nif (dst_check_stv0299(state) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "Unsupported");\r\nstate->tuner_type = TUNER_TYPE_MB86A15;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (dst_check_mb86a15(state) < 0)\r\ndprintk(verbose, DST_ERROR, 1, "Unsupported");\r\n} else {\r\nstate->tuner_type = p_dst_type->tuner_type;\r\n}\r\nfor (j = 0, p_tuner_list = tuner_list; j < ARRAY_SIZE(tuner_list); j++, p_tuner_list++) {\r\nif (!(strncmp(p_dst_type->device_id, p_tuner_list->fw_name, 7)) &&\r\np_tuner_list->tuner_type == state->tuner_type) {\r\ndprintk(verbose, DST_ERROR, 1, "[%s] has a [%s]",\r\np_dst_type->device_id, p_tuner_list->tuner_name);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(dst_tlist)) {\r\ndprintk(verbose, DST_ERROR, 1, "Unable to recognize %s or %s", &state->rxbuffer[0], &state->rxbuffer[1]);\r\ndprintk(verbose, DST_ERROR, 1, "please email linux-dvb@linuxtv.org with this type in");\r\nuse_dst_type = DST_TYPE_IS_SAT;\r\nuse_type_flags = DST_TYPE_HAS_SYMDIV;\r\n}\r\ndst_type_print(state, use_dst_type);\r\nstate->type_flags = use_type_flags;\r\nstate->dst_type = use_dst_type;\r\ndst_type_flags_print(state);\r\nreturn 0;\r\n}\r\nstatic int dst_probe(struct dst_state *state)\r\n{\r\nmutex_init(&state->dst_mutex);\r\nif (dst_addons & DST_TYPE_HAS_CA) {\r\nif ((rdc_8820_reset(state)) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "RDC 8820 RESET Failed.");\r\nreturn -1;\r\n}\r\nmsleep(4000);\r\n} else {\r\nmsleep(100);\r\n}\r\nif ((dst_comm_init(state)) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "DST Initialization Failed.");\r\nreturn -1;\r\n}\r\nmsleep(100);\r\nif (dst_get_device_id(state) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "unknown device.");\r\nreturn -1;\r\n}\r\nif (dst_get_mac(state) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "MAC: Unsupported command");\r\n}\r\nif ((state->type_flags & DST_TYPE_HAS_MULTI_FE) || (state->type_flags & DST_TYPE_HAS_FW_BUILD)) {\r\nif (dst_get_tuner_info(state) < 0)\r\ndprintk(verbose, DST_INFO, 1, "Tuner: Unsupported command");\r\n}\r\nif (state->type_flags & DST_TYPE_HAS_TS204) {\r\ndst_packsize(state, 204);\r\n}\r\nif (state->type_flags & DST_TYPE_HAS_FW_BUILD) {\r\nif (dst_fw_ver(state) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "FW: Unsupported command");\r\nreturn 0;\r\n}\r\nif (dst_card_type(state) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Card: Unsupported command");\r\nreturn 0;\r\n}\r\nif (dst_get_vendor(state) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Vendor: Unsupported command");\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_command(struct dst_state *state, u8 *data, u8 len)\r\n{\r\nu8 reply;\r\nmutex_lock(&state->dst_mutex);\r\nif ((dst_comm_init(state)) < 0) {\r\ndprintk(verbose, DST_NOTICE, 1, "DST Communication Initialization Failed.");\r\ngoto error;\r\n}\r\nif (write_dst(state, data, len)) {\r\ndprintk(verbose, DST_INFO, 1, "Trying to recover.. ");\r\nif ((dst_error_recovery(state)) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "Recovery Failed.");\r\ngoto error;\r\n}\r\ngoto error;\r\n}\r\nif ((dst_pio_disable(state)) < 0) {\r\ndprintk(verbose, DST_ERROR, 1, "PIO Disable Failed.");\r\ngoto error;\r\n}\r\nif (state->type_flags & DST_TYPE_HAS_FW_1)\r\nmdelay(3);\r\nif (read_dst(state, &reply, GET_ACK)) {\r\ndprintk(verbose, DST_DEBUG, 1, "Trying to recover.. ");\r\nif ((dst_error_recovery(state)) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Recovery Failed.");\r\ngoto error;\r\n}\r\ngoto error;\r\n}\r\nif (reply != ACK) {\r\ndprintk(verbose, DST_INFO, 1, "write not acknowledged 0x%02x ", reply);\r\ngoto error;\r\n}\r\nif (len >= 2 && data[0] == 0 && (data[1] == 1 || data[1] == 3))\r\ngoto error;\r\nif (state->type_flags & DST_TYPE_HAS_FW_1)\r\nmdelay(3);\r\nelse\r\nudelay(2000);\r\nif (!dst_wait_dst_ready(state, NO_DELAY))\r\ngoto error;\r\nif (read_dst(state, state->rxbuffer, FIXED_COMM)) {\r\ndprintk(verbose, DST_DEBUG, 1, "Trying to recover.. ");\r\nif ((dst_error_recovery(state)) < 0) {\r\ndprintk(verbose, DST_INFO, 1, "Recovery failed.");\r\ngoto error;\r\n}\r\ngoto error;\r\n}\r\nif (state->rxbuffer[7] != dst_check_sum(state->rxbuffer, 7)) {\r\ndprintk(verbose, DST_INFO, 1, "checksum failure");\r\ngoto error;\r\n}\r\nmutex_unlock(&state->dst_mutex);\r\nreturn 0;\r\nerror:\r\nmutex_unlock(&state->dst_mutex);\r\nreturn -EIO;\r\n}\r\nstatic int dst_get_signal(struct dst_state *state)\r\n{\r\nint retval;\r\nu8 get_signal[] = { 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb };\r\nif ((state->diseq_flags & ATTEMPT_TUNE) == 0) {\r\nstate->decode_lock = state->decode_strength = state->decode_snr = 0;\r\nreturn 0;\r\n}\r\nif (0 == (state->diseq_flags & HAS_LOCK)) {\r\nstate->decode_lock = state->decode_strength = state->decode_snr = 0;\r\nreturn 0;\r\n}\r\nif (time_after_eq(jiffies, state->cur_jiff + (HZ / 5))) {\r\nretval = dst_command(state, get_signal, 8);\r\nif (retval < 0)\r\nreturn retval;\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nstate->decode_lock = ((state->rxbuffer[6] & 0x10) == 0) ? 1 : 0;\r\nstate->decode_strength = state->rxbuffer[5] << 8;\r\nstate->decode_snr = state->rxbuffer[2] << 8 | state->rxbuffer[3];\r\n} else if ((state->dst_type == DST_TYPE_IS_TERR) || (state->dst_type == DST_TYPE_IS_CABLE)) {\r\nstate->decode_lock = (state->rxbuffer[1]) ? 1 : 0;\r\nstate->decode_strength = state->rxbuffer[4] << 8;\r\nstate->decode_snr = state->rxbuffer[3] << 8;\r\n} else if (state->dst_type == DST_TYPE_IS_ATSC) {\r\nstate->decode_lock = (state->rxbuffer[6] == 0x00) ? 1 : 0;\r\nstate->decode_strength = state->rxbuffer[4] << 8;\r\nstate->decode_snr = state->rxbuffer[2] << 8 | state->rxbuffer[3];\r\n}\r\nstate->cur_jiff = jiffies;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_tone_power_cmd(struct dst_state *state)\r\n{\r\nu8 paket[8] = { 0x00, 0x09, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00 };\r\nif (state->dst_type != DST_TYPE_IS_SAT)\r\nreturn -EOPNOTSUPP;\r\npaket[4] = state->tx_tuna[4];\r\npaket[2] = state->tx_tuna[2];\r\npaket[3] = state->tx_tuna[3];\r\npaket[7] = dst_check_sum (paket, 7);\r\nreturn dst_command(state, paket, 8);\r\n}\r\nstatic int dst_get_tuna(struct dst_state *state)\r\n{\r\nint retval;\r\nif ((state->diseq_flags & ATTEMPT_TUNE) == 0)\r\nreturn 0;\r\nstate->diseq_flags &= ~(HAS_LOCK);\r\nif (!dst_wait_dst_ready(state, NO_DELAY))\r\nreturn -EIO;\r\nif ((state->type_flags & DST_TYPE_HAS_VLF) &&\r\n!(state->dst_type == DST_TYPE_IS_ATSC))\r\nretval = read_dst(state, state->rx_tuna, 10);\r\nelse\r\nretval = read_dst(state, &state->rx_tuna[2], FIXED_COMM);\r\nif (retval < 0) {\r\ndprintk(verbose, DST_DEBUG, 1, "read not successful");\r\nreturn retval;\r\n}\r\nif ((state->type_flags & DST_TYPE_HAS_VLF) &&\r\n!(state->dst_type == DST_TYPE_IS_ATSC)) {\r\nif (state->rx_tuna[9] != dst_check_sum(&state->rx_tuna[0], 9)) {\r\ndprintk(verbose, DST_INFO, 1, "checksum failure ? ");\r\nreturn -EIO;\r\n}\r\n} else {\r\nif (state->rx_tuna[9] != dst_check_sum(&state->rx_tuna[2], 7)) {\r\ndprintk(verbose, DST_INFO, 1, "checksum failure? ");\r\nreturn -EIO;\r\n}\r\n}\r\nif (state->rx_tuna[2] == 0 && state->rx_tuna[3] == 0)\r\nreturn 0;\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nstate->decode_freq = ((state->rx_tuna[2] & 0x7f) << 8) + state->rx_tuna[3];\r\n} else {\r\nstate->decode_freq = ((state->rx_tuna[2] & 0x7f) << 16) + (state->rx_tuna[3] << 8) + state->rx_tuna[4];\r\n}\r\nstate->decode_freq = state->decode_freq * 1000;\r\nstate->decode_lock = 1;\r\nstate->diseq_flags |= HAS_LOCK;\r\nreturn 1;\r\n}\r\nstatic int dst_write_tuna(struct dvb_frontend *fe)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nint retval;\r\nu8 reply;\r\ndprintk(verbose, DST_INFO, 1, "type_flags 0x%x ", state->type_flags);\r\nstate->decode_freq = 0;\r\nstate->decode_lock = state->decode_strength = state->decode_snr = 0;\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nif (!(state->diseq_flags & HAS_POWER))\r\ndst_set_voltage(fe, SEC_VOLTAGE_13);\r\n}\r\nstate->diseq_flags &= ~(HAS_LOCK | ATTEMPT_TUNE);\r\nmutex_lock(&state->dst_mutex);\r\nif ((dst_comm_init(state)) < 0) {\r\ndprintk(verbose, DST_DEBUG, 1, "DST Communication initialization failed.");\r\ngoto error;\r\n}\r\nif ((state->type_flags & DST_TYPE_HAS_VLF) &&\r\n(!(state->dst_type == DST_TYPE_IS_ATSC))) {\r\nstate->tx_tuna[9] = dst_check_sum(&state->tx_tuna[0], 9);\r\nretval = write_dst(state, &state->tx_tuna[0], 10);\r\n} else {\r\nstate->tx_tuna[9] = dst_check_sum(&state->tx_tuna[2], 7);\r\nretval = write_dst(state, &state->tx_tuna[2], FIXED_COMM);\r\n}\r\nif (retval < 0) {\r\ndst_pio_disable(state);\r\ndprintk(verbose, DST_DEBUG, 1, "write not successful");\r\ngoto werr;\r\n}\r\nif ((dst_pio_disable(state)) < 0) {\r\ndprintk(verbose, DST_DEBUG, 1, "DST PIO disable failed !");\r\ngoto error;\r\n}\r\nif ((read_dst(state, &reply, GET_ACK) < 0)) {\r\ndprintk(verbose, DST_DEBUG, 1, "read verify not successful.");\r\ngoto error;\r\n}\r\nif (reply != ACK) {\r\ndprintk(verbose, DST_DEBUG, 1, "write not acknowledged 0x%02x ", reply);\r\ngoto error;\r\n}\r\nstate->diseq_flags |= ATTEMPT_TUNE;\r\nretval = dst_get_tuna(state);\r\nwerr:\r\nmutex_unlock(&state->dst_mutex);\r\nreturn retval;\r\nerror:\r\nmutex_unlock(&state->dst_mutex);\r\nreturn -EIO;\r\n}\r\nstatic int dst_set_diseqc(struct dvb_frontend *fe, struct dvb_diseqc_master_cmd *cmd)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nu8 paket[8] = { 0x00, 0x08, 0x04, 0xe0, 0x10, 0x38, 0xf0, 0xec };\r\nif (state->dst_type != DST_TYPE_IS_SAT)\r\nreturn -EOPNOTSUPP;\r\nif (cmd->msg_len > 0 && cmd->msg_len < 5)\r\nmemcpy(&paket[3], cmd->msg, cmd->msg_len);\r\nelse if (cmd->msg_len == 5 && state->dst_hw_cap & DST_TYPE_HAS_DISEQC5)\r\nmemcpy(&paket[2], cmd->msg, cmd->msg_len);\r\nelse\r\nreturn -EINVAL;\r\npaket[7] = dst_check_sum(&paket[0], 7);\r\nreturn dst_command(state, paket, 8);\r\n}\r\nstatic int dst_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)\r\n{\r\nint need_cmd, retval = 0;\r\nstruct dst_state *state = fe->demodulator_priv;\r\nstate->voltage = voltage;\r\nif (state->dst_type != DST_TYPE_IS_SAT)\r\nreturn -EOPNOTSUPP;\r\nneed_cmd = 0;\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\ncase SEC_VOLTAGE_18:\r\nif ((state->diseq_flags & HAS_POWER) == 0)\r\nneed_cmd = 1;\r\nstate->diseq_flags |= HAS_POWER;\r\nstate->tx_tuna[4] = 0x01;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nneed_cmd = 1;\r\nstate->diseq_flags &= ~(HAS_POWER | HAS_LOCK | ATTEMPT_TUNE);\r\nstate->tx_tuna[4] = 0x00;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (need_cmd)\r\nretval = dst_tone_power_cmd(state);\r\nreturn retval;\r\n}\r\nstatic int dst_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nstate->tone = tone;\r\nif (state->dst_type != DST_TYPE_IS_SAT)\r\nreturn -EOPNOTSUPP;\r\nswitch (tone) {\r\ncase SEC_TONE_OFF:\r\nif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\r\nstate->tx_tuna[2] = 0x00;\r\nelse\r\nstate->tx_tuna[2] = 0xff;\r\nbreak;\r\ncase SEC_TONE_ON:\r\nstate->tx_tuna[2] = 0x02;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn dst_tone_power_cmd(state);\r\n}\r\nstatic int dst_send_burst(struct dvb_frontend *fe, fe_sec_mini_cmd_t minicmd)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nif (state->dst_type != DST_TYPE_IS_SAT)\r\nreturn -EOPNOTSUPP;\r\nstate->minicmd = minicmd;\r\nswitch (minicmd) {\r\ncase SEC_MINI_A:\r\nstate->tx_tuna[3] = 0x02;\r\nbreak;\r\ncase SEC_MINI_B:\r\nstate->tx_tuna[3] = 0xff;\r\nbreak;\r\n}\r\nreturn dst_tone_power_cmd(state);\r\n}\r\nstatic int dst_init(struct dvb_frontend *fe)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nstatic u8 sat_tuna_188[] = { 0x09, 0x00, 0x03, 0xb6, 0x01, 0x00, 0x73, 0x21, 0x00, 0x00 };\r\nstatic u8 sat_tuna_204[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x55, 0xbd, 0x50, 0x00, 0x00 };\r\nstatic u8 ter_tuna_188[] = { 0x09, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\r\nstatic u8 ter_tuna_204[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\r\nstatic u8 cab_tuna_188[] = { 0x09, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\r\nstatic u8 cab_tuna_204[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\r\nstatic u8 atsc_tuner[] = { 0x00, 0x00, 0x03, 0xb6, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00 };\r\nstate->inversion = INVERSION_OFF;\r\nstate->voltage = SEC_VOLTAGE_13;\r\nstate->tone = SEC_TONE_OFF;\r\nstate->diseq_flags = 0;\r\nstate->k22 = 0x02;\r\nstate->bandwidth = BANDWIDTH_7_MHZ;\r\nstate->cur_jiff = jiffies;\r\nif (state->dst_type == DST_TYPE_IS_SAT)\r\nmemcpy(state->tx_tuna, ((state->type_flags & DST_TYPE_HAS_VLF) ? sat_tuna_188 : sat_tuna_204), sizeof (sat_tuna_204));\r\nelse if (state->dst_type == DST_TYPE_IS_TERR)\r\nmemcpy(state->tx_tuna, ((state->type_flags & DST_TYPE_HAS_VLF) ? ter_tuna_188 : ter_tuna_204), sizeof (ter_tuna_204));\r\nelse if (state->dst_type == DST_TYPE_IS_CABLE)\r\nmemcpy(state->tx_tuna, ((state->type_flags & DST_TYPE_HAS_VLF) ? cab_tuna_188 : cab_tuna_204), sizeof (cab_tuna_204));\r\nelse if (state->dst_type == DST_TYPE_IS_ATSC)\r\nmemcpy(state->tx_tuna, atsc_tuner, sizeof (atsc_tuner));\r\nreturn 0;\r\n}\r\nstatic int dst_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\n*status = 0;\r\nif (state->diseq_flags & HAS_LOCK) {\r\nif (state->decode_lock)\r\n*status |= FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_SYNC | FE_HAS_VITERBI;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dst_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nint retval = dst_get_signal(state);\r\n*strength = state->decode_strength;\r\nreturn retval;\r\n}\r\nstatic int dst_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nint retval = dst_get_signal(state);\r\n*snr = state->decode_snr;\r\nreturn retval;\r\n}\r\nstatic int dst_set_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)\r\n{\r\nint retval = -EINVAL;\r\nstruct dst_state *state = fe->demodulator_priv;\r\nif (p != NULL) {\r\nretval = dst_set_freq(state, p->frequency);\r\nif(retval != 0)\r\nreturn retval;\r\ndprintk(verbose, DST_DEBUG, 1, "Set Frequency=[%d]", p->frequency);\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\r\ndst_set_inversion(state, p->inversion);\r\ndst_set_fec(state, p->u.qpsk.fec_inner);\r\ndst_set_symbolrate(state, p->u.qpsk.symbol_rate);\r\ndst_set_polarization(state);\r\ndprintk(verbose, DST_DEBUG, 1, "Set Symbolrate=[%d]", p->u.qpsk.symbol_rate);\r\n} else if (state->dst_type == DST_TYPE_IS_TERR)\r\ndst_set_bandwidth(state, p->u.ofdm.bandwidth);\r\nelse if (state->dst_type == DST_TYPE_IS_CABLE) {\r\ndst_set_fec(state, p->u.qam.fec_inner);\r\ndst_set_symbolrate(state, p->u.qam.symbol_rate);\r\ndst_set_modulation(state, p->u.qam.modulation);\r\n}\r\nretval = dst_write_tuna(fe);\r\n}\r\nreturn retval;\r\n}\r\nstatic int dst_tune_frontend(struct dvb_frontend* fe,\r\nstruct dvb_frontend_parameters* p,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nfe_status_t *status)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nif (p != NULL) {\r\ndst_set_freq(state, p->frequency);\r\ndprintk(verbose, DST_DEBUG, 1, "Set Frequency=[%d]", p->frequency);\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\r\ndst_set_inversion(state, p->inversion);\r\ndst_set_fec(state, p->u.qpsk.fec_inner);\r\ndst_set_symbolrate(state, p->u.qpsk.symbol_rate);\r\ndst_set_polarization(state);\r\ndprintk(verbose, DST_DEBUG, 1, "Set Symbolrate=[%d]", p->u.qpsk.symbol_rate);\r\n} else if (state->dst_type == DST_TYPE_IS_TERR)\r\ndst_set_bandwidth(state, p->u.ofdm.bandwidth);\r\nelse if (state->dst_type == DST_TYPE_IS_CABLE) {\r\ndst_set_fec(state, p->u.qam.fec_inner);\r\ndst_set_symbolrate(state, p->u.qam.symbol_rate);\r\ndst_set_modulation(state, p->u.qam.modulation);\r\n}\r\ndst_write_tuna(fe);\r\n}\r\nif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\r\ndst_read_status(fe, status);\r\n*delay = HZ/10;\r\nreturn 0;\r\n}\r\nstatic int dst_get_tuning_algo(struct dvb_frontend *fe)\r\n{\r\nreturn dst_algo ? DVBFE_ALGO_HW : DVBFE_ALGO_SW;\r\n}\r\nstatic int dst_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\np->frequency = state->decode_freq;\r\nif (state->dst_type == DST_TYPE_IS_SAT) {\r\nif (state->type_flags & DST_TYPE_HAS_OBS_REGS)\r\np->inversion = state->inversion;\r\np->u.qpsk.symbol_rate = state->symbol_rate;\r\np->u.qpsk.fec_inner = dst_get_fec(state);\r\n} else if (state->dst_type == DST_TYPE_IS_TERR) {\r\np->u.ofdm.bandwidth = state->bandwidth;\r\n} else if (state->dst_type == DST_TYPE_IS_CABLE) {\r\np->u.qam.symbol_rate = state->symbol_rate;\r\np->u.qam.fec_inner = dst_get_fec(state);\r\np->u.qam.modulation = dst_get_modulation(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dst_release(struct dvb_frontend *fe)\r\n{\r\nstruct dst_state *state = fe->demodulator_priv;\r\nif (state->dst_ca) {\r\ndvb_unregister_device(state->dst_ca);\r\n#ifdef CONFIG_MEDIA_ATTACH\r\nsymbol_put(dst_ca_attach);\r\n#endif\r\n}\r\nkfree(state);\r\n}\r\nstruct dst_state *dst_attach(struct dst_state *state, struct dvb_adapter *dvb_adapter)\r\n{\r\nif (dst_probe(state) < 0) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nswitch (state->dst_type) {\r\ncase DST_TYPE_IS_TERR:\r\nmemcpy(&state->frontend.ops, &dst_dvbt_ops, sizeof(struct dvb_frontend_ops));\r\nbreak;\r\ncase DST_TYPE_IS_CABLE:\r\nmemcpy(&state->frontend.ops, &dst_dvbc_ops, sizeof(struct dvb_frontend_ops));\r\nbreak;\r\ncase DST_TYPE_IS_SAT:\r\nmemcpy(&state->frontend.ops, &dst_dvbs_ops, sizeof(struct dvb_frontend_ops));\r\nbreak;\r\ncase DST_TYPE_IS_ATSC:\r\nmemcpy(&state->frontend.ops, &dst_atsc_ops, sizeof(struct dvb_frontend_ops));\r\nbreak;\r\ndefault:\r\ndprintk(verbose, DST_ERROR, 1, "unknown DST type. please report to the LinuxTV.org DVB mailinglist.");\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nstate->frontend.demodulator_priv = state;\r\nreturn state;\r\n}
