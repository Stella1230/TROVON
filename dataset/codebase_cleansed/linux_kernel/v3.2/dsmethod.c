acpi_status\r\nacpi_ds_method_error(acpi_status status, struct acpi_walk_state *walk_state)\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nif (ACPI_SUCCESS(status) || (status & AE_CODE_CONTROL)) {\r\nreturn (status);\r\n}\r\nif (acpi_gbl_exception_handler) {\r\nacpi_ex_exit_interpreter();\r\nstatus = acpi_gbl_exception_handler(status,\r\nwalk_state->method_node ?\r\nwalk_state->method_node->\r\nname.integer : 0,\r\nwalk_state->opcode,\r\nwalk_state->aml_offset,\r\nNULL);\r\nacpi_ex_enter_interpreter();\r\n}\r\nacpi_ds_clear_implicit_return(walk_state);\r\n#ifdef ACPI_DISASSEMBLER\r\nif (ACPI_FAILURE(status)) {\r\nacpi_dm_dump_method_info(status, walk_state, walk_state->op);\r\n}\r\n#endif\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nacpi_ds_create_method_mutex(union acpi_operand_object *method_desc)\r\n{\r\nunion acpi_operand_object *mutex_desc;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ds_create_method_mutex);\r\nmutex_desc = acpi_ut_create_internal_object(ACPI_TYPE_MUTEX);\r\nif (!mutex_desc) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus = acpi_os_create_mutex(&mutex_desc->mutex.os_mutex);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nmutex_desc->mutex.sync_level = method_desc->method.sync_level;\r\nmethod_desc->method.mutex = mutex_desc;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,\r\nunion acpi_operand_object *obj_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_PTR(ds_begin_method_execution, method_node);\r\nif (!method_node) {\r\nreturn_ACPI_STATUS(AE_NULL_ENTRY);\r\n}\r\nif (obj_desc->method.thread_count == ACPI_UINT8_MAX) {\r\nACPI_ERROR((AE_INFO,\r\n"Method reached maximum reentrancy limit (255)"));\r\nreturn_ACPI_STATUS(AE_AML_METHOD_LIMIT);\r\n}\r\nif (obj_desc->method.info_flags & ACPI_METHOD_SERIALIZED) {\r\nif (!obj_desc->method.mutex) {\r\nstatus = acpi_ds_create_method_mutex(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif (walk_state &&\r\n(walk_state->thread->current_sync_level >\r\nobj_desc->method.mutex->mutex.sync_level)) {\r\nACPI_ERROR((AE_INFO,\r\n"Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%u)",\r\nacpi_ut_get_node_name(method_node),\r\nwalk_state->thread->current_sync_level));\r\nreturn_ACPI_STATUS(AE_AML_MUTEX_ORDER);\r\n}\r\nif (!walk_state ||\r\n!obj_desc->method.mutex->mutex.thread_id ||\r\n(walk_state->thread->thread_id !=\r\nobj_desc->method.mutex->mutex.thread_id)) {\r\nstatus =\r\nacpi_ex_system_wait_mutex(obj_desc->method.mutex->\r\nmutex.os_mutex,\r\nACPI_WAIT_FOREVER);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (walk_state) {\r\nobj_desc->method.mutex->mutex.\r\noriginal_sync_level =\r\nwalk_state->thread->current_sync_level;\r\nobj_desc->method.mutex->mutex.thread_id =\r\nwalk_state->thread->thread_id;\r\nwalk_state->thread->current_sync_level =\r\nobj_desc->method.sync_level;\r\n} else {\r\nobj_desc->method.mutex->mutex.\r\noriginal_sync_level =\r\nobj_desc->method.mutex->mutex.sync_level;\r\n}\r\n}\r\nobj_desc->method.mutex->mutex.acquisition_depth++;\r\n}\r\nif (!obj_desc->method.owner_id) {\r\nstatus = acpi_ut_allocate_owner_id(&obj_desc->method.owner_id);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\n}\r\nobj_desc->method.thread_count++;\r\nreturn_ACPI_STATUS(status);\r\ncleanup:\r\nif (obj_desc->method.mutex) {\r\nacpi_os_release_mutex(obj_desc->method.mutex->mutex.os_mutex);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ds_call_control_method(struct acpi_thread_state *thread,\r\nstruct acpi_walk_state *this_walk_state,\r\nunion acpi_parse_object *op)\r\n{\r\nacpi_status status;\r\nstruct acpi_namespace_node *method_node;\r\nstruct acpi_walk_state *next_walk_state = NULL;\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_evaluate_info *info;\r\nu32 i;\r\nACPI_FUNCTION_TRACE_PTR(ds_call_control_method, this_walk_state);\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"Calling method %p, currentstate=%p\n",\r\nthis_walk_state->prev_op, this_walk_state));\r\nmethod_node = this_walk_state->method_call_node;\r\nif (!method_node) {\r\nreturn_ACPI_STATUS(AE_NULL_ENTRY);\r\n}\r\nobj_desc = acpi_ns_get_attached_object(method_node);\r\nif (!obj_desc) {\r\nreturn_ACPI_STATUS(AE_NULL_OBJECT);\r\n}\r\nstatus = acpi_ds_begin_method_execution(method_node, obj_desc,\r\nthis_walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nnext_walk_state = acpi_ds_create_walk_state(obj_desc->method.owner_id,\r\nNULL, obj_desc, thread);\r\nif (!next_walk_state) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup;\r\n}\r\nthis_walk_state->operands[this_walk_state->num_operands] = NULL;\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ninfo->parameters = &this_walk_state->operands[0];\r\nstatus = acpi_ds_init_aml_walk(next_walk_state, NULL, method_node,\r\nobj_desc->method.aml_start,\r\nobj_desc->method.aml_length, info,\r\nACPI_IMODE_EXECUTE);\r\nACPI_FREE(info);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\nfor (i = 0; i < obj_desc->method.param_count; i++) {\r\nacpi_ut_remove_reference(this_walk_state->operands[i]);\r\nthis_walk_state->operands[i] = NULL;\r\n}\r\nthis_walk_state->num_operands = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"**** Begin nested execution of [%4.4s] **** WalkState=%p\n",\r\nmethod_node->name.ascii, next_walk_state));\r\nif (obj_desc->method.info_flags & ACPI_METHOD_INTERNAL_ONLY) {\r\nstatus =\r\nobj_desc->method.dispatch.implementation(next_walk_state);\r\nif (status == AE_OK) {\r\nstatus = AE_CTRL_TERMINATE;\r\n}\r\n}\r\nreturn_ACPI_STATUS(status);\r\ncleanup:\r\nacpi_ds_terminate_control_method(obj_desc, next_walk_state);\r\nif (next_walk_state) {\r\nacpi_ds_delete_walk_state(next_walk_state);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ds_restart_control_method(struct acpi_walk_state *walk_state,\r\nunion acpi_operand_object *return_desc)\r\n{\r\nacpi_status status;\r\nint same_as_implicit_return;\r\nACPI_FUNCTION_TRACE_PTR(ds_restart_control_method, walk_state);\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"****Restart [%4.4s] Op %p ReturnValueFromCallee %p\n",\r\nacpi_ut_get_node_name(walk_state->method_node),\r\nwalk_state->method_call_op, return_desc));\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n" ReturnFromThisMethodUsed?=%X ResStack %p Walk %p\n",\r\nwalk_state->return_used,\r\nwalk_state->results, walk_state));\r\nif (return_desc) {\r\nsame_as_implicit_return =\r\n(walk_state->implicit_return_obj == return_desc);\r\nif (walk_state->return_used) {\r\nstatus = acpi_ds_result_push(return_desc, walk_state);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_ut_remove_reference(return_desc);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nwalk_state->return_desc = return_desc;\r\n}\r\nelse if (!acpi_ds_do_implicit_return\r\n(return_desc, walk_state, FALSE)\r\n|| same_as_implicit_return) {\r\nacpi_ut_remove_reference(return_desc);\r\n}\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nvoid\r\nacpi_ds_terminate_control_method(union acpi_operand_object *method_desc,\r\nstruct acpi_walk_state *walk_state)\r\n{\r\nACPI_FUNCTION_TRACE_PTR(ds_terminate_control_method, walk_state);\r\nif (!method_desc) {\r\nreturn_VOID;\r\n}\r\nif (walk_state) {\r\nacpi_ds_method_data_delete_all(walk_state);\r\nif (method_desc->method.mutex) {\r\nmethod_desc->method.mutex->mutex.acquisition_depth--;\r\nif (!method_desc->method.mutex->mutex.acquisition_depth) {\r\nwalk_state->thread->current_sync_level =\r\nmethod_desc->method.mutex->mutex.\r\noriginal_sync_level;\r\nacpi_os_release_mutex(method_desc->method.\r\nmutex->mutex.os_mutex);\r\nmethod_desc->method.mutex->mutex.thread_id = 0;\r\n}\r\n}\r\nif (!(method_desc->method.info_flags & ACPI_METHOD_MODULE_LEVEL)\r\n&& (method_desc->method.thread_count == 1)) {\r\nacpi_ns_delete_namespace_subtree(walk_state->\r\nmethod_node);\r\nif (method_desc->method.\r\ninfo_flags & ACPI_METHOD_MODIFIED_NAMESPACE) {\r\nacpi_ns_delete_namespace_by_owner(method_desc->\r\nmethod.\r\nowner_id);\r\nmethod_desc->method.info_flags &=\r\n~ACPI_METHOD_MODIFIED_NAMESPACE;\r\n}\r\n}\r\n}\r\nif (method_desc->method.thread_count) {\r\nmethod_desc->method.thread_count--;\r\n} else {\r\nACPI_ERROR((AE_INFO, "Invalid zero thread count in method"));\r\n}\r\nif (method_desc->method.thread_count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\r\n"*** Completed execution of one thread, %u threads remaining\n",\r\nmethod_desc->method.thread_count));\r\n} else {\r\nif (method_desc->method.\r\ninfo_flags & ACPI_METHOD_SERIALIZED_PENDING) {\r\nif (walk_state) {\r\nACPI_INFO((AE_INFO,\r\n"Marking method %4.4s as Serialized because of AE_ALREADY_EXISTS error",\r\nwalk_state->method_node->name.\r\nascii));\r\n}\r\nmethod_desc->method.info_flags &=\r\n~ACPI_METHOD_SERIALIZED_PENDING;\r\nmethod_desc->method.info_flags |=\r\nACPI_METHOD_SERIALIZED;\r\nmethod_desc->method.sync_level = 0;\r\n}\r\nif (!\r\n(method_desc->method.\r\ninfo_flags & ACPI_METHOD_MODULE_LEVEL)) {\r\nacpi_ut_release_owner_id(&method_desc->method.owner_id);\r\n}\r\n}\r\nreturn_VOID;\r\n}
