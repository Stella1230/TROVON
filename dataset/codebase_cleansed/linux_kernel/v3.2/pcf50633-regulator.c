static u8 auto_voltage_bits(unsigned int millivolts)\r\n{\r\nif (millivolts < 1800)\r\nreturn 0;\r\nif (millivolts > 3800)\r\nreturn 0xff;\r\nmillivolts -= 625;\r\nreturn millivolts / 25;\r\n}\r\nstatic u8 down_voltage_bits(unsigned int millivolts)\r\n{\r\nif (millivolts < 625)\r\nreturn 0;\r\nelse if (millivolts > 3000)\r\nreturn 0xff;\r\nmillivolts -= 625;\r\nreturn millivolts / 25;\r\n}\r\nstatic u8 ldo_voltage_bits(unsigned int millivolts)\r\n{\r\nif (millivolts < 900)\r\nreturn 0;\r\nelse if (millivolts > 3600)\r\nreturn 0x1f;\r\nmillivolts -= 900;\r\nreturn millivolts / 100;\r\n}\r\nstatic unsigned int auto_voltage_value(u8 bits)\r\n{\r\nif (bits < 0x2f)\r\nreturn 0;\r\nreturn 625 + (bits * 25);\r\n}\r\nstatic unsigned int down_voltage_value(u8 bits)\r\n{\r\nreturn 625 + (bits * 25);\r\n}\r\nstatic unsigned int ldo_voltage_value(u8 bits)\r\n{\r\nbits &= 0x1f;\r\nreturn 900 + (bits * 100);\r\n}\r\nstatic int pcf50633_regulator_set_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV,\r\nunsigned *selector)\r\n{\r\nstruct pcf50633 *pcf;\r\nint regulator_id, millivolts;\r\nu8 volt_bits, regnr;\r\npcf = rdev_get_drvdata(rdev);\r\nregulator_id = rdev_get_id(rdev);\r\nif (regulator_id >= PCF50633_NUM_REGULATORS)\r\nreturn -EINVAL;\r\nmillivolts = min_uV / 1000;\r\nregnr = pcf50633_regulator_registers[regulator_id];\r\nswitch (regulator_id) {\r\ncase PCF50633_REGULATOR_AUTO:\r\nvolt_bits = auto_voltage_bits(millivolts);\r\nbreak;\r\ncase PCF50633_REGULATOR_DOWN1:\r\nvolt_bits = down_voltage_bits(millivolts);\r\nbreak;\r\ncase PCF50633_REGULATOR_DOWN2:\r\nvolt_bits = down_voltage_bits(millivolts);\r\nbreak;\r\ncase PCF50633_REGULATOR_LDO1:\r\ncase PCF50633_REGULATOR_LDO2:\r\ncase PCF50633_REGULATOR_LDO3:\r\ncase PCF50633_REGULATOR_LDO4:\r\ncase PCF50633_REGULATOR_LDO5:\r\ncase PCF50633_REGULATOR_LDO6:\r\ncase PCF50633_REGULATOR_HCLDO:\r\nvolt_bits = ldo_voltage_bits(millivolts);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*selector = volt_bits;\r\nreturn pcf50633_reg_write(pcf, regnr, volt_bits);\r\n}\r\nstatic int pcf50633_regulator_voltage_value(enum pcf50633_regulator_id id,\r\nu8 bits)\r\n{\r\nint millivolts;\r\nswitch (id) {\r\ncase PCF50633_REGULATOR_AUTO:\r\nmillivolts = auto_voltage_value(bits);\r\nbreak;\r\ncase PCF50633_REGULATOR_DOWN1:\r\nmillivolts = down_voltage_value(bits);\r\nbreak;\r\ncase PCF50633_REGULATOR_DOWN2:\r\nmillivolts = down_voltage_value(bits);\r\nbreak;\r\ncase PCF50633_REGULATOR_LDO1:\r\ncase PCF50633_REGULATOR_LDO2:\r\ncase PCF50633_REGULATOR_LDO3:\r\ncase PCF50633_REGULATOR_LDO4:\r\ncase PCF50633_REGULATOR_LDO5:\r\ncase PCF50633_REGULATOR_LDO6:\r\ncase PCF50633_REGULATOR_HCLDO:\r\nmillivolts = ldo_voltage_value(bits);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn millivolts * 1000;\r\n}\r\nstatic int pcf50633_regulator_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct pcf50633 *pcf;\r\nint regulator_id;\r\nu8 volt_bits, regnr;\r\npcf = rdev_get_drvdata(rdev);\r\nregulator_id = rdev_get_id(rdev);\r\nif (regulator_id >= PCF50633_NUM_REGULATORS)\r\nreturn -EINVAL;\r\nregnr = pcf50633_regulator_registers[regulator_id];\r\nvolt_bits = pcf50633_reg_read(pcf, regnr);\r\nreturn pcf50633_regulator_voltage_value(regulator_id, volt_bits);\r\n}\r\nstatic int pcf50633_regulator_list_voltage(struct regulator_dev *rdev,\r\nunsigned int index)\r\n{\r\nstruct pcf50633 *pcf;\r\nint regulator_id;\r\npcf = rdev_get_drvdata(rdev);\r\nregulator_id = rdev_get_id(rdev);\r\nswitch (regulator_id) {\r\ncase PCF50633_REGULATOR_AUTO:\r\nindex += 0x2f;\r\nbreak;\r\ncase PCF50633_REGULATOR_HCLDO:\r\nindex += 0x01;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn pcf50633_regulator_voltage_value(regulator_id, index);\r\n}\r\nstatic int pcf50633_regulator_enable(struct regulator_dev *rdev)\r\n{\r\nstruct pcf50633 *pcf = rdev_get_drvdata(rdev);\r\nint regulator_id;\r\nu8 regnr;\r\nregulator_id = rdev_get_id(rdev);\r\nif (regulator_id >= PCF50633_NUM_REGULATORS)\r\nreturn -EINVAL;\r\nregnr = pcf50633_regulator_registers[regulator_id] + 1;\r\nreturn pcf50633_reg_set_bit_mask(pcf, regnr, PCF50633_REGULATOR_ON,\r\nPCF50633_REGULATOR_ON);\r\n}\r\nstatic int pcf50633_regulator_disable(struct regulator_dev *rdev)\r\n{\r\nstruct pcf50633 *pcf = rdev_get_drvdata(rdev);\r\nint regulator_id;\r\nu8 regnr;\r\nregulator_id = rdev_get_id(rdev);\r\nif (regulator_id >= PCF50633_NUM_REGULATORS)\r\nreturn -EINVAL;\r\nregnr = pcf50633_regulator_registers[regulator_id] + 1;\r\nreturn pcf50633_reg_set_bit_mask(pcf, regnr,\r\nPCF50633_REGULATOR_ON, 0);\r\n}\r\nstatic int pcf50633_regulator_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct pcf50633 *pcf = rdev_get_drvdata(rdev);\r\nint regulator_id = rdev_get_id(rdev);\r\nu8 regnr;\r\nregulator_id = rdev_get_id(rdev);\r\nif (regulator_id >= PCF50633_NUM_REGULATORS)\r\nreturn -EINVAL;\r\nregnr = pcf50633_regulator_registers[regulator_id] + 1;\r\nreturn pcf50633_reg_read(pcf, regnr) & PCF50633_REGULATOR_ON;\r\n}\r\nstatic int __devinit pcf50633_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator_dev *rdev;\r\nstruct pcf50633 *pcf;\r\npcf = dev_to_pcf50633(pdev->dev.parent);\r\nrdev = regulator_register(&regulators[pdev->id], &pdev->dev,\r\npdev->dev.platform_data, pcf);\r\nif (IS_ERR(rdev))\r\nreturn PTR_ERR(rdev);\r\nplatform_set_drvdata(pdev, rdev);\r\nif (pcf->pdata->regulator_registered)\r\npcf->pdata->regulator_registered(pcf, pdev->id);\r\nreturn 0;\r\n}\r\nstatic int __devexit pcf50633_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct regulator_dev *rdev = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nregulator_unregister(rdev);\r\nreturn 0;\r\n}\r\nstatic int __init pcf50633_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&pcf50633_regulator_driver);\r\n}\r\nstatic void __exit pcf50633_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&pcf50633_regulator_driver);\r\n}
