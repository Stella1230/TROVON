static irqreturn_t kirkwood_dma_irq(int irq, void *dev_id)\r\n{\r\nstruct kirkwood_dma_priv *prdata = dev_id;\r\nstruct kirkwood_dma_data *priv = prdata->data;\r\nunsigned long mask, status, cause;\r\nmask = readl(priv->io + KIRKWOOD_INT_MASK);\r\nstatus = readl(priv->io + KIRKWOOD_INT_CAUSE) & mask;\r\ncause = readl(priv->io + KIRKWOOD_ERR_CAUSE);\r\nif (unlikely(cause)) {\r\nprintk(KERN_WARNING "%s: got err interrupt 0x%lx\n",\r\n__func__, cause);\r\nwritel(cause, priv->io + KIRKWOOD_ERR_CAUSE);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & ~(KIRKWOOD_INT_CAUSE_PLAY_BYTES | \\r\nKIRKWOOD_INT_CAUSE_REC_BYTES)) {\r\nprintk(KERN_WARNING "%s: unexpected interrupt %lx\n",\r\n__func__, status);\r\nreturn IRQ_NONE;\r\n}\r\nwritel(status, priv->io + KIRKWOOD_INT_CAUSE);\r\nif (status & KIRKWOOD_INT_CAUSE_PLAY_BYTES)\r\nsnd_pcm_period_elapsed(prdata->play_stream);\r\nif (status & KIRKWOOD_INT_CAUSE_REC_BYTES)\r\nsnd_pcm_period_elapsed(prdata->rec_stream);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void kirkwood_dma_conf_mbus_windows(void __iomem *base, int win,\r\nunsigned long dma,\r\nstruct mbus_dram_target_info *dram)\r\n{\r\nint i;\r\nwritel(0, base + KIRKWOOD_AUDIO_WIN_CTRL_REG(win));\r\nwritel(0, base + KIRKWOOD_AUDIO_WIN_BASE_REG(win));\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nstruct mbus_dram_window *cs = dram->cs + i;\r\nif ((cs->base & 0xffff0000) < (dma & 0xffff0000)) {\r\nwritel(cs->base & 0xffff0000,\r\nbase + KIRKWOOD_AUDIO_WIN_BASE_REG(win));\r\nwritel(((cs->size - 1) & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\n(dram->mbus_dram_target_id << 4) | 1,\r\nbase + KIRKWOOD_AUDIO_WIN_CTRL_REG(win));\r\n}\r\n}\r\n}\r\nstatic int kirkwood_dma_open(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct snd_soc_platform *platform = soc_runtime->platform;\r\nstruct snd_soc_dai *cpu_dai = soc_runtime->cpu_dai;\r\nstruct kirkwood_dma_data *priv;\r\nstruct kirkwood_dma_priv *prdata = snd_soc_platform_get_drvdata(platform);\r\nunsigned long addr;\r\npriv = snd_soc_dai_get_dma_data(cpu_dai, substream);\r\nsnd_soc_set_runtime_hwparams(substream, &kirkwood_dma_snd_hw);\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\npriv->burst * 2,\r\nKIRKWOOD_AUDIO_BUF_MAX-1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\npriv->burst);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\npriv->burst);\r\nif (err < 0)\r\nreturn err;\r\nif (prdata == NULL) {\r\nprdata = kzalloc(sizeof(struct kirkwood_dma_priv), GFP_KERNEL);\r\nif (prdata == NULL)\r\nreturn -ENOMEM;\r\nprdata->data = priv;\r\nerr = request_irq(priv->irq, kirkwood_dma_irq, IRQF_SHARED,\r\n"kirkwood-i2s", prdata);\r\nif (err) {\r\nkfree(prdata);\r\nreturn -EBUSY;\r\n}\r\nsnd_soc_platform_set_drvdata(platform, prdata);\r\nwritel((unsigned long)-1, priv->io + KIRKWOOD_ERR_MASK);\r\n}\r\naddr = virt_to_phys(substream->dma_buffer.area);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nprdata->play_stream = substream;\r\nkirkwood_dma_conf_mbus_windows(priv->io,\r\nKIRKWOOD_PLAYBACK_WIN, addr, priv->dram);\r\n} else {\r\nprdata->rec_stream = substream;\r\nkirkwood_dma_conf_mbus_windows(priv->io,\r\nKIRKWOOD_RECORD_WIN, addr, priv->dram);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = soc_runtime->cpu_dai;\r\nstruct snd_soc_platform *platform = soc_runtime->platform;\r\nstruct kirkwood_dma_priv *prdata = snd_soc_platform_get_drvdata(platform);\r\nstruct kirkwood_dma_data *priv;\r\npriv = snd_soc_dai_get_dma_data(cpu_dai, substream);\r\nif (!prdata || !priv)\r\nreturn 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprdata->play_stream = NULL;\r\nelse\r\nprdata->rec_stream = NULL;\r\nif (!prdata->play_stream && !prdata->rec_stream) {\r\nwritel(0, priv->io + KIRKWOOD_ERR_MASK);\r\nfree_irq(priv->irq, prdata);\r\nkfree(prdata);\r\nsnd_soc_platform_set_drvdata(platform, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = params_buffer_bytes(params);\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = soc_runtime->cpu_dai;\r\nstruct kirkwood_dma_data *priv;\r\nunsigned long size, count;\r\npriv = snd_soc_dai_get_dma_data(cpu_dai, substream);\r\nsize = frames_to_bytes(runtime, runtime->buffer_size);\r\nsize = (size>>2)-1;\r\ncount = snd_pcm_lib_period_bytes(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nwritel(count, priv->io + KIRKWOOD_PLAY_BYTE_INT_COUNT);\r\nwritel(runtime->dma_addr, priv->io + KIRKWOOD_PLAY_BUF_ADDR);\r\nwritel(size, priv->io + KIRKWOOD_PLAY_BUF_SIZE);\r\n} else {\r\nwritel(count, priv->io + KIRKWOOD_REC_BYTE_INT_COUNT);\r\nwritel(runtime->dma_addr, priv->io + KIRKWOOD_REC_BUF_ADDR);\r\nwritel(size, priv->io + KIRKWOOD_REC_BUF_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t kirkwood_dma_pointer(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = soc_runtime->cpu_dai;\r\nstruct kirkwood_dma_data *priv;\r\nsnd_pcm_uframes_t count;\r\npriv = snd_soc_dai_get_dma_data(cpu_dai, substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncount = bytes_to_frames(substream->runtime,\r\nreadl(priv->io + KIRKWOOD_PLAY_BYTE_COUNT));\r\nelse\r\ncount = bytes_to_frames(substream->runtime,\r\nreadl(priv->io + KIRKWOOD_REC_BYTE_COUNT));\r\nreturn count;\r\n}\r\nstatic int kirkwood_dma_preallocate_dma_buffer(struct snd_pcm *pcm,\r\nint stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = kirkwood_dma_snd_hw.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->area = dma_alloc_coherent(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nbuf->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nif (!card->dev->dma_mask)\r\ncard->dev->dma_mask = &kirkwood_dma_dmamask;\r\nif (!card->dev->coherent_dma_mask)\r\ncard->dev->coherent_dma_mask = 0xffffffff;\r\nif (dai->driver->playback.channels_min) {\r\nret = kirkwood_dma_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (dai->driver->capture.channels_min) {\r\nret = kirkwood_dma_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void kirkwood_dma_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_coherent(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}\r\nstatic int __devinit kirkwood_soc_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_platform(&pdev->dev, &kirkwood_soc_platform);\r\n}\r\nstatic int __devexit kirkwood_soc_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init kirkwood_pcm_init(void)\r\n{\r\nreturn platform_driver_register(&kirkwood_pcm_driver);\r\n}\r\nstatic void __exit kirkwood_pcm_exit(void)\r\n{\r\nplatform_driver_unregister(&kirkwood_pcm_driver);\r\n}
