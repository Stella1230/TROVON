static int line6_start_listen(struct usb_line6 *line6)\r\n{\r\nint err;\r\nusb_fill_int_urb(line6->urb_listen, line6->usbdev,\r\nusb_rcvintpipe(line6->usbdev, line6->ep_control_read),\r\nline6->buffer_listen, LINE6_BUFSIZE_LISTEN,\r\nline6_data_received, line6, line6->interval);\r\nline6->urb_listen->actual_length = 0;\r\nerr = usb_submit_urb(line6->urb_listen, GFP_ATOMIC);\r\nreturn err;\r\n}\r\nstatic void line6_stop_listen(struct usb_line6 *line6)\r\n{\r\nusb_kill_urb(line6->urb_listen);\r\n}\r\nvoid line6_write_hexdump(struct usb_line6 *line6, char dir,\r\nconst unsigned char *buffer, int size)\r\n{\r\nstatic const int BYTES_PER_LINE = 8;\r\nchar hexdump[100];\r\nchar asc[BYTES_PER_LINE + 1];\r\nint i, j;\r\nfor (i = 0; i < size; i += BYTES_PER_LINE) {\r\nint hexdumpsize = sizeof(hexdump);\r\nchar *p = hexdump;\r\nint n = min(size - i, BYTES_PER_LINE);\r\nasc[n] = 0;\r\nfor (j = 0; j < BYTES_PER_LINE; ++j) {\r\nint bytes;\r\nif (j < n) {\r\nunsigned char val = buffer[i + j];\r\nbytes = snprintf(p, hexdumpsize, " %02X", val);\r\nasc[j] = ((val >= 0x20)\r\n&& (val < 0x7f)) ? val : '.';\r\n} else\r\nbytes = snprintf(p, hexdumpsize, " ");\r\nif (bytes > hexdumpsize)\r\nbreak;\r\np += bytes;\r\nhexdumpsize -= bytes;\r\n}\r\ndev_info(line6->ifcdev, "%c%04X:%s %s\n", dir, i, hexdump, asc);\r\n}\r\n}\r\nstatic void line6_dump_urb(struct urb *urb)\r\n{\r\nstruct usb_line6 *line6 = (struct usb_line6 *)urb->context;\r\nif (urb->status < 0)\r\nreturn;\r\nline6_write_hexdump(line6, 'R', (unsigned char *)urb->transfer_buffer,\r\nurb->actual_length);\r\n}\r\nint line6_send_raw_message(struct usb_line6 *line6, const char *buffer,\r\nint size)\r\n{\r\nint i, done = 0;\r\n#ifdef CONFIG_LINE6_USB_DUMP_CTRL\r\nline6_write_hexdump(line6, 'S', buffer, size);\r\n#endif\r\nfor (i = 0; i < size; i += line6->max_packet_size) {\r\nint partial;\r\nconst char *frag_buf = buffer + i;\r\nint frag_size = min(line6->max_packet_size, size - i);\r\nint retval;\r\nretval = usb_interrupt_msg(line6->usbdev,\r\nusb_sndintpipe(line6->usbdev,\r\nline6->ep_control_write),\r\n(char *)frag_buf, frag_size,\r\n&partial, LINE6_TIMEOUT * HZ);\r\nif (retval) {\r\ndev_err(line6->ifcdev,\r\n"usb_interrupt_msg failed (%d)\n", retval);\r\nbreak;\r\n}\r\ndone += frag_size;\r\n}\r\nreturn done;\r\n}\r\nstatic void line6_async_request_sent(struct urb *urb)\r\n{\r\nstruct message *msg = (struct message *)urb->context;\r\nif (msg->done >= msg->size) {\r\nusb_free_urb(urb);\r\nkfree(msg);\r\n} else\r\nline6_send_raw_message_async_part(msg, urb);\r\n}\r\nstatic int line6_send_raw_message_async_part(struct message *msg,\r\nstruct urb *urb)\r\n{\r\nint retval;\r\nstruct usb_line6 *line6 = msg->line6;\r\nint done = msg->done;\r\nint bytes = min(msg->size - done, line6->max_packet_size);\r\nusb_fill_int_urb(urb, line6->usbdev,\r\nusb_sndintpipe(line6->usbdev, line6->ep_control_write),\r\n(char *)msg->buffer + done, bytes,\r\nline6_async_request_sent, msg, line6->interval);\r\n#ifdef CONFIG_LINE6_USB_DUMP_CTRL\r\nline6_write_hexdump(line6, 'S', (char *)msg->buffer + done, bytes);\r\n#endif\r\nmsg->done += bytes;\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval < 0) {\r\ndev_err(line6->ifcdev, "%s: usb_submit_urb failed (%d)\n",\r\n__func__, retval);\r\nusb_free_urb(urb);\r\nkfree(msg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid line6_start_timer(struct timer_list *timer, unsigned int msecs,\r\nvoid (*function) (unsigned long), unsigned long data)\r\n{\r\nsetup_timer(timer, function, data);\r\ntimer->expires = jiffies + msecs * HZ / 1000;\r\nadd_timer(timer);\r\n}\r\nint line6_send_raw_message_async(struct usb_line6 *line6, const char *buffer,\r\nint size)\r\n{\r\nstruct message *msg;\r\nstruct urb *urb;\r\nmsg = kmalloc(sizeof(struct message), GFP_ATOMIC);\r\nif (msg == NULL) {\r\ndev_err(line6->ifcdev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urb == NULL) {\r\nkfree(msg);\r\ndev_err(line6->ifcdev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmsg->line6 = line6;\r\nmsg->buffer = buffer;\r\nmsg->size = size;\r\nmsg->done = 0;\r\nreturn line6_send_raw_message_async_part(msg, urb);\r\n}\r\nint line6_version_request_async(struct usb_line6 *line6)\r\n{\r\nreturn line6_send_raw_message_async(line6, line6_request_version,\r\nsizeof(line6_request_version0));\r\n}\r\nint line6_send_sysex_message(struct usb_line6 *line6, const char *buffer,\r\nint size)\r\n{\r\nreturn line6_send_raw_message(line6, buffer,\r\nsize + SYSEX_EXTRA_SIZE) -\r\nSYSEX_EXTRA_SIZE;\r\n}\r\nint line6_send_sysex_message_async(struct usb_line6 *line6, const char *buffer,\r\nint size)\r\n{\r\nreturn line6_send_raw_message_async(line6, buffer,\r\nsize + SYSEX_EXTRA_SIZE) -\r\nSYSEX_EXTRA_SIZE;\r\n}\r\nchar *line6_alloc_sysex_buffer(struct usb_line6 *line6, int code1, int code2,\r\nint size)\r\n{\r\nchar *buffer = kmalloc(size + SYSEX_EXTRA_SIZE, GFP_ATOMIC);\r\nif (!buffer) {\r\ndev_err(line6->ifcdev, "out of memory\n");\r\nreturn NULL;\r\n}\r\nbuffer[0] = LINE6_SYSEX_BEGIN;\r\nmemcpy(buffer + 1, line6_midi_id, sizeof(line6_midi_id));\r\nbuffer[sizeof(line6_midi_id) + 1] = code1;\r\nbuffer[sizeof(line6_midi_id) + 2] = code2;\r\nbuffer[sizeof(line6_midi_id) + 3 + size] = LINE6_SYSEX_END;\r\nreturn buffer;\r\n}\r\nstatic void line6_data_received(struct urb *urb)\r\n{\r\nstruct usb_line6 *line6 = (struct usb_line6 *)urb->context;\r\nstruct MidiBuffer *mb = &line6->line6midi->midibuf_in;\r\nint done;\r\nif (urb->status == -ESHUTDOWN)\r\nreturn;\r\n#ifdef CONFIG_LINE6_USB_DUMP_CTRL\r\nline6_dump_urb(urb);\r\n#endif\r\ndone =\r\nline6_midibuf_write(mb, urb->transfer_buffer, urb->actual_length);\r\nif (done < urb->actual_length) {\r\nline6_midibuf_ignore(mb, done);\r\nDEBUG_MESSAGES(dev_err\r\n(line6->ifcdev,\r\n"%d %d buffer overflow - message skipped\n",\r\ndone, urb->actual_length));\r\n}\r\nfor (;;) {\r\ndone =\r\nline6_midibuf_read(mb, line6->buffer_message,\r\nLINE6_MESSAGE_MAXLEN);\r\nif (done == 0)\r\nbreak;\r\nif (line6_midibuf_skip_message\r\n(mb, line6->line6midi->midi_mask_receive))\r\ncontinue;\r\nline6->message_length = done;\r\n#ifdef CONFIG_LINE6_USB_DUMP_MIDI\r\nline6_write_hexdump(line6, 'r', line6->buffer_message, done);\r\n#endif\r\nline6_midi_receive(line6, line6->buffer_message, done);\r\nswitch (line6->usbdev->descriptor.idProduct) {\r\ncase LINE6_DEVID_BASSPODXT:\r\ncase LINE6_DEVID_BASSPODXTLIVE:\r\ncase LINE6_DEVID_BASSPODXTPRO:\r\ncase LINE6_DEVID_PODXT:\r\ncase LINE6_DEVID_PODXTPRO:\r\ncase LINE6_DEVID_POCKETPOD:\r\nline6_pod_process_message((struct usb_line6_pod *)\r\nline6);\r\nbreak;\r\ncase LINE6_DEVID_PODXTLIVE:\r\nswitch (line6->interface_number) {\r\ncase PODXTLIVE_INTERFACE_POD:\r\nline6_pod_process_message((struct usb_line6_pod\r\n*)line6);\r\nbreak;\r\ncase PODXTLIVE_INTERFACE_VARIAX:\r\nline6_variax_process_message((struct\r\nusb_line6_variax\r\n*)line6);\r\nbreak;\r\ndefault:\r\ndev_err(line6->ifcdev,\r\n"PODxt Live interface %d not supported\n",\r\nline6->interface_number);\r\n}\r\nbreak;\r\ncase LINE6_DEVID_VARIAX:\r\nline6_variax_process_message((struct usb_line6_variax *)\r\nline6);\r\nbreak;\r\ndefault:\r\nMISSING_CASE;\r\n}\r\n}\r\nline6_start_listen(line6);\r\n}\r\nint line6_send_program(struct usb_line6 *line6, int value)\r\n{\r\nint retval;\r\nunsigned char *buffer;\r\nint partial;\r\nbuffer = kmalloc(2, GFP_KERNEL);\r\nif (!buffer) {\r\ndev_err(line6->ifcdev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nbuffer[0] = LINE6_PROGRAM_CHANGE | LINE6_CHANNEL_HOST;\r\nbuffer[1] = value;\r\n#ifdef CONFIG_LINE6_USB_DUMP_CTRL\r\nline6_write_hexdump(line6, 'S', buffer, 2);\r\n#endif\r\nretval = usb_interrupt_msg(line6->usbdev,\r\nusb_sndintpipe(line6->usbdev,\r\nline6->ep_control_write),\r\nbuffer, 2, &partial, LINE6_TIMEOUT * HZ);\r\nif (retval)\r\ndev_err(line6->ifcdev, "usb_interrupt_msg failed (%d)\n",\r\nretval);\r\nkfree(buffer);\r\nreturn retval;\r\n}\r\nint line6_transmit_parameter(struct usb_line6 *line6, int param, int value)\r\n{\r\nint retval;\r\nunsigned char *buffer;\r\nint partial;\r\nbuffer = kmalloc(3, GFP_KERNEL);\r\nif (!buffer) {\r\ndev_err(line6->ifcdev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nbuffer[0] = LINE6_PARAM_CHANGE | LINE6_CHANNEL_HOST;\r\nbuffer[1] = param;\r\nbuffer[2] = value;\r\n#ifdef CONFIG_LINE6_USB_DUMP_CTRL\r\nline6_write_hexdump(line6, 'S', buffer, 3);\r\n#endif\r\nretval = usb_interrupt_msg(line6->usbdev,\r\nusb_sndintpipe(line6->usbdev,\r\nline6->ep_control_write),\r\nbuffer, 3, &partial, LINE6_TIMEOUT * HZ);\r\nif (retval)\r\ndev_err(line6->ifcdev, "usb_interrupt_msg failed (%d)\n",\r\nretval);\r\nkfree(buffer);\r\nreturn retval;\r\n}\r\nint line6_read_data(struct usb_line6 *line6, int address, void *data,\r\nsize_t datalen)\r\n{\r\nstruct usb_device *usbdev = line6->usbdev;\r\nint ret;\r\nunsigned char len;\r\nret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0), 0x67,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\n(datalen << 8) | 0x21, address,\r\nNULL, 0, LINE6_TIMEOUT * HZ);\r\nif (ret < 0) {\r\ndev_err(line6->ifcdev, "read request failed (error %d)\n", ret);\r\nreturn ret;\r\n}\r\ndo {\r\nret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0), 0x67,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE |\r\nUSB_DIR_IN,\r\n0x0012, 0x0000, &len, 1,\r\nLINE6_TIMEOUT * HZ);\r\nif (ret < 0) {\r\ndev_err(line6->ifcdev,\r\n"receive length failed (error %d)\n", ret);\r\nreturn ret;\r\n}\r\n} while (len == 0xff);\r\nif (len != datalen) {\r\ndev_err(line6->ifcdev,\r\n"length mismatch (expected %d, got %d)\n",\r\n(int)datalen, (int)len);\r\nreturn -EINVAL;\r\n}\r\nret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0), 0x67,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0x0013, 0x0000, data, datalen,\r\nLINE6_TIMEOUT * HZ);\r\nif (ret < 0) {\r\ndev_err(line6->ifcdev, "read failed (error %d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint line6_write_data(struct usb_line6 *line6, int address, void *data,\r\nsize_t datalen)\r\n{\r\nstruct usb_device *usbdev = line6->usbdev;\r\nint ret;\r\nunsigned char status;\r\nret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0), 0x67,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\r\n0x0022, address, data, datalen,\r\nLINE6_TIMEOUT * HZ);\r\nif (ret < 0) {\r\ndev_err(line6->ifcdev,\r\n"write request failed (error %d)\n", ret);\r\nreturn ret;\r\n}\r\ndo {\r\nret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\r\n0x67,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE |\r\nUSB_DIR_IN,\r\n0x0012, 0x0000,\r\n&status, 1, LINE6_TIMEOUT * HZ);\r\nif (ret < 0) {\r\ndev_err(line6->ifcdev,\r\n"receiving status failed (error %d)\n", ret);\r\nreturn ret;\r\n}\r\n} while (status == 0xff);\r\nif (status != 0) {\r\ndev_err(line6->ifcdev, "write failed (error %d)\n", ret);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint line6_read_serial_number(struct usb_line6 *line6, int *serial_number)\r\n{\r\nreturn line6_read_data(line6, 0x80d0, serial_number,\r\nsizeof(*serial_number));\r\n}\r\nssize_t line6_nop_read(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn 0;\r\n}\r\nssize_t line6_nop_write(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn count;\r\n}\r\nssize_t line6_set_raw(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6 *line6 = usb_get_intfdata(interface);\r\nline6_send_raw_message(line6, buf, count);\r\nreturn count;\r\n}\r\nstatic void line6_destruct(struct usb_interface *interface)\r\n{\r\nstruct usb_line6 *line6;\r\nif (interface == NULL)\r\nreturn;\r\nline6 = usb_get_intfdata(interface);\r\nif (line6 == NULL)\r\nreturn;\r\nkfree(line6->buffer_message);\r\nkfree(line6->buffer_listen);\r\nusb_free_urb(line6->urb_listen);\r\nusb_set_intfdata(interface, NULL);\r\nkfree(line6);\r\n}\r\nstatic int line6_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nint devtype;\r\nstruct usb_device *usbdev = NULL;\r\nstruct usb_line6 *line6 = NULL;\r\nconst struct line6_properties *properties;\r\nint devnum;\r\nint interface_number, alternate = 0;\r\nint product;\r\nint size = 0;\r\nint ep_read = 0, ep_write = 0;\r\nint ret;\r\nif (interface == NULL)\r\nreturn -ENODEV;\r\nusbdev = interface_to_usbdev(interface);\r\nif (usbdev == NULL)\r\nreturn -ENODEV;\r\nif (usbdev->descriptor.bNumConfigurations != 1) {\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nfor (devtype = ARRAY_SIZE(line6_id_table) - 1; devtype--;) {\r\nu16 idVendor = le16_to_cpu(usbdev->descriptor.idVendor);\r\nu16 idProduct = le16_to_cpu(usbdev->descriptor.idProduct);\r\nif (idVendor == line6_id_table[devtype].idVendor &&\r\nidProduct == line6_id_table[devtype].idProduct)\r\nbreak;\r\n}\r\nif (devtype < 0) {\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nfor (devnum = 0; devnum < LINE6_MAX_DEVICES; ++devnum)\r\nif (line6_devices[devnum] == NULL)\r\nbreak;\r\nif (devnum == LINE6_MAX_DEVICES) {\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nproperties = &line6_properties_table[devtype];\r\ndev_info(&interface->dev, "Line6 %s found\n", properties->name);\r\nproduct = le16_to_cpu(usbdev->descriptor.idProduct);\r\ninterface_number = interface->cur_altsetting->desc.bInterfaceNumber;\r\nswitch (product) {\r\ncase LINE6_DEVID_BASSPODXTLIVE:\r\ncase LINE6_DEVID_PODXTLIVE:\r\ncase LINE6_DEVID_VARIAX:\r\nalternate = 1;\r\nbreak;\r\ncase LINE6_DEVID_POCKETPOD:\r\nswitch (interface_number) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nalternate = 0;\r\nbreak;\r\ndefault:\r\nMISSING_CASE;\r\n}\r\nbreak;\r\ncase LINE6_DEVID_PODX3:\r\ncase LINE6_DEVID_PODX3LIVE:\r\nswitch (interface_number) {\r\ncase 0:\r\nalternate = 1;\r\nbreak;\r\ncase 1:\r\nalternate = 0;\r\nbreak;\r\ndefault:\r\nMISSING_CASE;\r\n}\r\nbreak;\r\ncase LINE6_DEVID_BASSPODXT:\r\ncase LINE6_DEVID_BASSPODXTPRO:\r\ncase LINE6_DEVID_PODXT:\r\ncase LINE6_DEVID_PODXTPRO:\r\nalternate = 5;\r\nbreak;\r\ncase LINE6_DEVID_GUITARPORT:\r\ncase LINE6_DEVID_PODSTUDIO_GX:\r\ncase LINE6_DEVID_PODSTUDIO_UX1:\r\ncase LINE6_DEVID_TONEPORT_GX:\r\ncase LINE6_DEVID_TONEPORT_UX1:\r\nalternate = 2;\r\nbreak;\r\ncase LINE6_DEVID_TONEPORT_UX2:\r\ncase LINE6_DEVID_PODSTUDIO_UX2:\r\nswitch (interface_number) {\r\ncase 0:\r\nalternate = 2;\r\nbreak;\r\ncase 1:\r\nreturn -ENODEV;\r\ndefault:\r\nMISSING_CASE;\r\n}\r\nbreak;\r\ndefault:\r\nMISSING_CASE;\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nret = usb_set_interface(usbdev, interface_number, alternate);\r\nif (ret < 0) {\r\ndev_err(&interface->dev, "set_interface failed\n");\r\ngoto err_put;\r\n}\r\nswitch (product) {\r\ncase LINE6_DEVID_BASSPODXT:\r\ncase LINE6_DEVID_BASSPODXTLIVE:\r\ncase LINE6_DEVID_BASSPODXTPRO:\r\ncase LINE6_DEVID_PODXT:\r\ncase LINE6_DEVID_PODXTPRO:\r\nsize = sizeof(struct usb_line6_pod);\r\nep_read = 0x84;\r\nep_write = 0x03;\r\nbreak;\r\ncase LINE6_DEVID_POCKETPOD:\r\nsize = sizeof(struct usb_line6_pod);\r\nep_read = 0x82;\r\nep_write = 0x02;\r\nbreak;\r\ncase LINE6_DEVID_PODX3:\r\ncase LINE6_DEVID_PODX3LIVE:\r\nsize = sizeof(struct usb_line6_pod);\r\nep_read = 0x81;\r\nep_write = 0x01;\r\nbreak;\r\ncase LINE6_DEVID_PODSTUDIO_GX:\r\ncase LINE6_DEVID_PODSTUDIO_UX1:\r\ncase LINE6_DEVID_PODSTUDIO_UX2:\r\ncase LINE6_DEVID_TONEPORT_GX:\r\ncase LINE6_DEVID_TONEPORT_UX1:\r\ncase LINE6_DEVID_TONEPORT_UX2:\r\ncase LINE6_DEVID_GUITARPORT:\r\nsize = sizeof(struct usb_line6_toneport);\r\nbreak;\r\ncase LINE6_DEVID_PODXTLIVE:\r\nswitch (interface_number) {\r\ncase PODXTLIVE_INTERFACE_POD:\r\nsize = sizeof(struct usb_line6_pod);\r\nep_read = 0x84;\r\nep_write = 0x03;\r\nbreak;\r\ncase PODXTLIVE_INTERFACE_VARIAX:\r\nsize = sizeof(struct usb_line6_variax);\r\nep_read = 0x86;\r\nep_write = 0x05;\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nbreak;\r\ncase LINE6_DEVID_VARIAX:\r\nsize = sizeof(struct usb_line6_variax);\r\nep_read = 0x82;\r\nep_write = 0x01;\r\nbreak;\r\ndefault:\r\nMISSING_CASE;\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nif (size == 0) {\r\ndev_err(line6->ifcdev,\r\n"driver bug: interface data size not set\n");\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nline6 = kzalloc(size, GFP_KERNEL);\r\nif (line6 == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nret = -ENODEV;\r\ngoto err_put;\r\n}\r\nline6->interface_number = interface_number;\r\nline6->properties = properties;\r\nline6->usbdev = usbdev;\r\nline6->ifcdev = &interface->dev;\r\nline6->ep_control_read = ep_read;\r\nline6->ep_control_write = ep_write;\r\nline6->product = product;\r\n{\r\nstruct usb_host_endpoint *ep;\r\nunsigned epnum =\r\nusb_pipeendpoint(usb_rcvintpipe(usbdev, ep_read));\r\nep = usbdev->ep_in[epnum];\r\nif (ep != NULL) {\r\nline6->interval = ep->desc.bInterval;\r\nline6->max_packet_size =\r\nle16_to_cpu(ep->desc.wMaxPacketSize);\r\n} else {\r\nline6->interval = LINE6_FALLBACK_INTERVAL;\r\nline6->max_packet_size = LINE6_FALLBACK_MAXPACKETSIZE;\r\ndev_err(line6->ifcdev,\r\n"endpoint not available, using fallback values");\r\n}\r\n}\r\nusb_set_intfdata(interface, line6);\r\nif (properties->capabilities & LINE6_BIT_CONTROL) {\r\nline6->buffer_listen =\r\nkmalloc(LINE6_BUFSIZE_LISTEN, GFP_KERNEL);\r\nif (line6->buffer_listen == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto err_destruct;\r\n}\r\nline6->buffer_message =\r\nkmalloc(LINE6_MESSAGE_MAXLEN, GFP_KERNEL);\r\nif (line6->buffer_message == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto err_destruct;\r\n}\r\nline6->urb_listen = usb_alloc_urb(0, GFP_KERNEL);\r\nif (line6->urb_listen == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nline6_destruct(interface);\r\nret = -ENOMEM;\r\ngoto err_destruct;\r\n}\r\nret = line6_start_listen(line6);\r\nif (ret < 0) {\r\ndev_err(&interface->dev, "%s: usb_submit_urb failed\n",\r\n__func__);\r\ngoto err_destruct;\r\n}\r\n}\r\nswitch (product) {\r\ncase LINE6_DEVID_BASSPODXT:\r\ncase LINE6_DEVID_BASSPODXTLIVE:\r\ncase LINE6_DEVID_BASSPODXTPRO:\r\ncase LINE6_DEVID_POCKETPOD:\r\ncase LINE6_DEVID_PODX3:\r\ncase LINE6_DEVID_PODX3LIVE:\r\ncase LINE6_DEVID_PODXT:\r\ncase LINE6_DEVID_PODXTPRO:\r\nret = line6_pod_init(interface, (struct usb_line6_pod *)line6);\r\nbreak;\r\ncase LINE6_DEVID_PODXTLIVE:\r\nswitch (interface_number) {\r\ncase PODXTLIVE_INTERFACE_POD:\r\nret =\r\nline6_pod_init(interface,\r\n(struct usb_line6_pod *)line6);\r\nbreak;\r\ncase PODXTLIVE_INTERFACE_VARIAX:\r\nret =\r\nline6_variax_init(interface,\r\n(struct usb_line6_variax *)line6);\r\nbreak;\r\ndefault:\r\ndev_err(&interface->dev,\r\n"PODxt Live interface %d not supported\n",\r\ninterface_number);\r\nret = -ENODEV;\r\n}\r\nbreak;\r\ncase LINE6_DEVID_VARIAX:\r\nret =\r\nline6_variax_init(interface,\r\n(struct usb_line6_variax *)line6);\r\nbreak;\r\ncase LINE6_DEVID_PODSTUDIO_GX:\r\ncase LINE6_DEVID_PODSTUDIO_UX1:\r\ncase LINE6_DEVID_PODSTUDIO_UX2:\r\ncase LINE6_DEVID_TONEPORT_GX:\r\ncase LINE6_DEVID_TONEPORT_UX1:\r\ncase LINE6_DEVID_TONEPORT_UX2:\r\ncase LINE6_DEVID_GUITARPORT:\r\nret =\r\nline6_toneport_init(interface,\r\n(struct usb_line6_toneport *)line6);\r\nbreak;\r\ndefault:\r\nMISSING_CASE;\r\nret = -ENODEV;\r\n}\r\nif (ret < 0)\r\ngoto err_destruct;\r\nret = sysfs_create_link(&interface->dev.kobj, &usbdev->dev.kobj,\r\n"usb_device");\r\nif (ret < 0)\r\ngoto err_destruct;\r\ndev_info(&interface->dev, "Line6 %s now attached\n",\r\nline6->properties->name);\r\nline6_devices[devnum] = line6;\r\nswitch (product) {\r\ncase LINE6_DEVID_PODX3:\r\ncase LINE6_DEVID_PODX3LIVE:\r\ndev_info(&interface->dev,\r\n"NOTE: the Line6 %s is detected, but not yet supported\n",\r\nline6->properties->name);\r\n}\r\nusb_get_intf(interface);\r\nusb_get_dev(usbdev);\r\nreturn 0;\r\nerr_destruct:\r\nline6_destruct(interface);\r\nerr_put:\r\nreturn ret;\r\n}\r\nstatic void line6_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_line6 *line6;\r\nstruct usb_device *usbdev;\r\nint interface_number, i;\r\nif (interface == NULL)\r\nreturn;\r\nusbdev = interface_to_usbdev(interface);\r\nif (usbdev == NULL)\r\nreturn;\r\nsysfs_remove_link(&interface->dev.kobj, "usb_device");\r\ninterface_number = interface->cur_altsetting->desc.bInterfaceNumber;\r\nline6 = usb_get_intfdata(interface);\r\nif (line6 != NULL) {\r\nif (line6->urb_listen != NULL)\r\nline6_stop_listen(line6);\r\nif (usbdev != line6->usbdev)\r\ndev_err(line6->ifcdev,\r\n"driver bug: inconsistent usb device\n");\r\nswitch (line6->usbdev->descriptor.idProduct) {\r\ncase LINE6_DEVID_BASSPODXT:\r\ncase LINE6_DEVID_BASSPODXTLIVE:\r\ncase LINE6_DEVID_BASSPODXTPRO:\r\ncase LINE6_DEVID_POCKETPOD:\r\ncase LINE6_DEVID_PODX3:\r\ncase LINE6_DEVID_PODX3LIVE:\r\ncase LINE6_DEVID_PODXT:\r\ncase LINE6_DEVID_PODXTPRO:\r\nline6_pod_disconnect(interface);\r\nbreak;\r\ncase LINE6_DEVID_PODXTLIVE:\r\nswitch (interface_number) {\r\ncase PODXTLIVE_INTERFACE_POD:\r\nline6_pod_disconnect(interface);\r\nbreak;\r\ncase PODXTLIVE_INTERFACE_VARIAX:\r\nline6_variax_disconnect(interface);\r\nbreak;\r\n}\r\nbreak;\r\ncase LINE6_DEVID_VARIAX:\r\nline6_variax_disconnect(interface);\r\nbreak;\r\ncase LINE6_DEVID_PODSTUDIO_GX:\r\ncase LINE6_DEVID_PODSTUDIO_UX1:\r\ncase LINE6_DEVID_PODSTUDIO_UX2:\r\ncase LINE6_DEVID_TONEPORT_GX:\r\ncase LINE6_DEVID_TONEPORT_UX1:\r\ncase LINE6_DEVID_TONEPORT_UX2:\r\ncase LINE6_DEVID_GUITARPORT:\r\nline6_toneport_disconnect(interface);\r\nbreak;\r\ndefault:\r\nMISSING_CASE;\r\n}\r\ndev_info(&interface->dev, "Line6 %s now disconnected\n",\r\nline6->properties->name);\r\nfor (i = LINE6_MAX_DEVICES; i--;)\r\nif (line6_devices[i] == line6)\r\nline6_devices[i] = NULL;\r\n}\r\nline6_destruct(interface);\r\nusb_put_intf(interface);\r\nusb_put_dev(usbdev);\r\n}\r\nstatic int line6_suspend(struct usb_interface *interface, pm_message_t message)\r\n{\r\nstruct usb_line6 *line6 = usb_get_intfdata(interface);\r\nstruct snd_line6_pcm *line6pcm = line6->line6pcm;\r\nsnd_power_change_state(line6->card, SNDRV_CTL_POWER_D3hot);\r\nif (line6->properties->capabilities & LINE6_BIT_CONTROL)\r\nline6_stop_listen(line6);\r\nif (line6pcm != NULL) {\r\nsnd_pcm_suspend_all(line6pcm->pcm);\r\nline6_pcm_disconnect(line6pcm);\r\nline6pcm->flags = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int line6_resume(struct usb_interface *interface)\r\n{\r\nstruct usb_line6 *line6 = usb_get_intfdata(interface);\r\nif (line6->properties->capabilities & LINE6_BIT_CONTROL)\r\nline6_start_listen(line6);\r\nsnd_power_change_state(line6->card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int line6_reset_resume(struct usb_interface *interface)\r\n{\r\nstruct usb_line6 *line6 = usb_get_intfdata(interface);\r\nswitch (line6->usbdev->descriptor.idProduct) {\r\ncase LINE6_DEVID_PODSTUDIO_GX:\r\ncase LINE6_DEVID_PODSTUDIO_UX1:\r\ncase LINE6_DEVID_PODSTUDIO_UX2:\r\ncase LINE6_DEVID_TONEPORT_GX:\r\ncase LINE6_DEVID_TONEPORT_UX1:\r\ncase LINE6_DEVID_TONEPORT_UX2:\r\ncase LINE6_DEVID_GUITARPORT:\r\nline6_toneport_reset_resume((struct usb_line6_toneport *)line6);\r\n}\r\nreturn line6_resume(interface);\r\n}\r\nstatic int __init line6_init(void)\r\n{\r\nint i, retval;\r\nprintk(KERN_INFO "%s driver version %s\n", DRIVER_NAME, DRIVER_VERSION);\r\nfor (i = LINE6_MAX_DEVICES; i--;)\r\nline6_devices[i] = NULL;\r\nretval = usb_register(&line6_driver);\r\nif (retval) {\r\nerr("usb_register failed. Error number %d", retval);\r\nreturn retval;\r\n}\r\nline6_request_version = kmalloc(sizeof(line6_request_version0),\r\nGFP_KERNEL);\r\nif (line6_request_version == NULL) {\r\nerr("Out of memory");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy((char *)line6_request_version, line6_request_version0,\r\nsizeof(line6_request_version0));\r\nreturn retval;\r\n}\r\nstatic void __exit line6_exit(void)\r\n{\r\nint i;\r\nstruct usb_line6 *line6;\r\nstruct snd_line6_pcm *line6pcm;\r\nfor (i = LINE6_MAX_DEVICES; i--;) {\r\nline6 = line6_devices[i];\r\nif (line6 == NULL)\r\ncontinue;\r\nline6pcm = line6->line6pcm;\r\nif (line6pcm == NULL)\r\ncontinue;\r\nline6_pcm_stop(line6pcm, ~0);\r\n}\r\nusb_deregister(&line6_driver);\r\nkfree(line6_request_version);\r\n}
