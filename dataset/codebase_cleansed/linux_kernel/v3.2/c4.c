static inline int wait_for_doorbell(avmcard *card, unsigned long t)\r\n{\r\nunsigned long stop;\r\nstop = jiffies + t;\r\nwhile (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {\r\nif (!time_before(jiffies, stop))\r\nreturn -1;\r\nmb();\r\n}\r\nreturn 0;\r\n}\r\nstatic int c4_poke(avmcard *card, unsigned long off, unsigned long value)\r\n{\r\nif (wait_for_doorbell(card, HZ/10) < 0)\r\nreturn -1;\r\nc4outmeml(card->mbase+MBOX_PEEK_POKE, off);\r\nc4outmeml(card->mbase+DOORBELL, DBELL_ADDR);\r\nif (wait_for_doorbell(card, HZ/10) < 0)\r\nreturn -1;\r\nc4outmeml(card->mbase+MBOX_PEEK_POKE, value);\r\nc4outmeml(card->mbase+DOORBELL, DBELL_DATA | DBELL_ADDR);\r\nreturn 0;\r\n}\r\nstatic int c4_peek(avmcard *card, unsigned long off, unsigned long *valuep)\r\n{\r\nif (wait_for_doorbell(card, HZ/10) < 0)\r\nreturn -1;\r\nc4outmeml(card->mbase+MBOX_PEEK_POKE, off);\r\nc4outmeml(card->mbase+DOORBELL, DBELL_RNWR | DBELL_ADDR);\r\nif (wait_for_doorbell(card, HZ/10) < 0)\r\nreturn -1;\r\n*valuep = c4inmeml(card->mbase+MBOX_PEEK_POKE);\r\nreturn 0;\r\n}\r\nstatic int c4_load_t4file(avmcard *card, capiloaddatapart * t4file)\r\n{\r\nu32 val;\r\nunsigned char *dp;\r\nu_int left;\r\nu32 loadoff = 0;\r\ndp = t4file->data;\r\nleft = t4file->len;\r\nwhile (left >= sizeof(u32)) {\r\nif (t4file->user) {\r\nif (copy_from_user(&val, dp, sizeof(val)))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(&val, dp, sizeof(val));\r\n}\r\nif (c4_poke(card, loadoff, val)) {\r\nprintk(KERN_ERR "%s: corrupted firmware file ?\n",\r\ncard->name);\r\nreturn -EIO;\r\n}\r\nleft -= sizeof(u32);\r\ndp += sizeof(u32);\r\nloadoff += sizeof(u32);\r\n}\r\nif (left) {\r\nval = 0;\r\nif (t4file->user) {\r\nif (copy_from_user(&val, dp, left))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(&val, dp, left);\r\n}\r\nif (c4_poke(card, loadoff, val)) {\r\nprintk(KERN_ERR "%s: corrupted firmware file ?\n",\r\ncard->name);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void _put_byte(void **pp, u8 val)\r\n{\r\nu8 *s = *pp;\r\n*s++ = val;\r\n*pp = s;\r\n}\r\nstatic inline void _put_word(void **pp, u32 val)\r\n{\r\nu8 *s = *pp;\r\n*s++ = val & 0xff;\r\n*s++ = (val >> 8) & 0xff;\r\n*s++ = (val >> 16) & 0xff;\r\n*s++ = (val >> 24) & 0xff;\r\n*pp = s;\r\n}\r\nstatic inline void _put_slice(void **pp, unsigned char *dp, unsigned int len)\r\n{\r\nunsigned i = len;\r\n_put_word(pp, i);\r\nwhile (i-- > 0)\r\n_put_byte(pp, *dp++);\r\n}\r\nstatic inline u8 _get_byte(void **pp)\r\n{\r\nu8 *s = *pp;\r\nu8 val;\r\nval = *s++;\r\n*pp = s;\r\nreturn val;\r\n}\r\nstatic inline u32 _get_word(void **pp)\r\n{\r\nu8 *s = *pp;\r\nu32 val;\r\nval = *s++;\r\nval |= (*s++ << 8);\r\nval |= (*s++ << 16);\r\nval |= (*s++ << 24);\r\n*pp = s;\r\nreturn val;\r\n}\r\nstatic inline u32 _get_slice(void **pp, unsigned char *dp)\r\n{\r\nunsigned int len, i;\r\nlen = i = _get_word(pp);\r\nwhile (i-- > 0) *dp++ = _get_byte(pp);\r\nreturn len;\r\n}\r\nstatic void c4_reset(avmcard *card)\r\n{\r\nunsigned long stop;\r\nc4outmeml(card->mbase+DOORBELL, DBELL_RESET_ARM);\r\nstop = jiffies + HZ*10;\r\nwhile (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {\r\nif (!time_before(jiffies, stop))\r\nreturn;\r\nc4outmeml(card->mbase+DOORBELL, DBELL_ADDR);\r\nmb();\r\n}\r\nc4_poke(card, DC21285_ARMCSR_BASE + CHAN_1_CONTROL, 0);\r\nc4_poke(card, DC21285_ARMCSR_BASE + CHAN_2_CONTROL, 0);\r\n}\r\nstatic int c4_detect(avmcard *card)\r\n{\r\nunsigned long stop, dummy;\r\nc4outmeml(card->mbase+PCI_OUT_INT_MASK, 0x0c);\r\nif (c4inmeml(card->mbase+PCI_OUT_INT_MASK) != 0x0c)\r\nreturn 1;\r\nc4outmeml(card->mbase+DOORBELL, DBELL_RESET_ARM);\r\nstop = jiffies + HZ*10;\r\nwhile (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {\r\nif (!time_before(jiffies, stop))\r\nreturn 2;\r\nc4outmeml(card->mbase+DOORBELL, DBELL_ADDR);\r\nmb();\r\n}\r\nc4_poke(card, DC21285_ARMCSR_BASE + CHAN_1_CONTROL, 0);\r\nc4_poke(card, DC21285_ARMCSR_BASE + CHAN_2_CONTROL, 0);\r\nc4outmeml(card->mbase+MAILBOX_0, 0x55aa55aa);\r\nif (c4inmeml(card->mbase+MAILBOX_0) != 0x55aa55aa) return 3;\r\nc4outmeml(card->mbase+MAILBOX_0, 0xaa55aa55);\r\nif (c4inmeml(card->mbase+MAILBOX_0) != 0xaa55aa55) return 4;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DBELL_SA_MASK, 0)) return 5;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DBELL_PCI_MASK, 0)) return 6;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+SA_CONTROL, SA_CTL_ALLRIGHT))\r\nreturn 7;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+XBUS_CYCLE, INIT_XBUS_CYCLE))\r\nreturn 8;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+XBUS_STROBE, INIT_XBUS_STROBE))\r\nreturn 8;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DRAM_TIMING, 0)) return 9;\r\nmdelay(1);\r\nif (c4_peek(card, DC21285_DRAM_A0MR, &dummy)) return 10;\r\nif (c4_peek(card, DC21285_DRAM_A1MR, &dummy)) return 11;\r\nif (c4_peek(card, DC21285_DRAM_A2MR, &dummy)) return 12;\r\nif (c4_peek(card, DC21285_DRAM_A3MR, &dummy)) return 13;\r\nif (c4_poke(card, DC21285_DRAM_A0MR+CAS_OFFSET, 0)) return 14;\r\nif (c4_poke(card, DC21285_DRAM_A1MR+CAS_OFFSET, 0)) return 15;\r\nif (c4_poke(card, DC21285_DRAM_A2MR+CAS_OFFSET, 0)) return 16;\r\nif (c4_poke(card, DC21285_DRAM_A3MR+CAS_OFFSET, 0)) return 17;\r\nmdelay(1);\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DRAM_TIMING, DRAM_TIMING_DEF))\r\nreturn 18;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DRAM_ADDR_SIZE_0,DRAM_AD_SZ_DEF0))\r\nreturn 19;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DRAM_ADDR_SIZE_1,DRAM_AD_SZ_NULL))\r\nreturn 20;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DRAM_ADDR_SIZE_2,DRAM_AD_SZ_NULL))\r\nreturn 21;\r\nif (c4_poke(card, DC21285_ARMCSR_BASE+DRAM_ADDR_SIZE_3,DRAM_AD_SZ_NULL))\r\nreturn 22;\r\nif ( c4_poke(card, 0x000000, 0x11111111)\r\n|| c4_poke(card, 0x400000, 0x22222222)\r\n|| c4_poke(card, 0x800000, 0x33333333)\r\n|| c4_poke(card, 0xC00000, 0x44444444))\r\nreturn 23;\r\nif ( c4_peek(card, 0x000000, &dummy) || dummy != 0x11111111\r\n|| c4_peek(card, 0x400000, &dummy) || dummy != 0x22222222\r\n|| c4_peek(card, 0x800000, &dummy) || dummy != 0x33333333\r\n|| c4_peek(card, 0xC00000, &dummy) || dummy != 0x44444444)\r\nreturn 24;\r\nif ( c4_poke(card, 0x000000, 0x55555555)\r\n|| c4_poke(card, 0x400000, 0x66666666)\r\n|| c4_poke(card, 0x800000, 0x77777777)\r\n|| c4_poke(card, 0xC00000, 0x88888888))\r\nreturn 25;\r\nif ( c4_peek(card, 0x000000, &dummy) || dummy != 0x55555555\r\n|| c4_peek(card, 0x400000, &dummy) || dummy != 0x66666666\r\n|| c4_peek(card, 0x800000, &dummy) || dummy != 0x77777777\r\n|| c4_peek(card, 0xC00000, &dummy) || dummy != 0x88888888)\r\nreturn 26;\r\nreturn 0;\r\n}\r\nstatic void c4_dispatch_tx(avmcard *card)\r\n{\r\navmcard_dmainfo *dma = card->dma;\r\nstruct sk_buff *skb;\r\nu8 cmd, subcmd;\r\nu16 len;\r\nu32 txlen;\r\nvoid *p;\r\nif (card->csr & DBELL_DOWN_ARM) {\r\nreturn;\r\n}\r\nskb = skb_dequeue(&dma->send_queue);\r\nif (!skb) {\r\n#ifdef AVM_C4_DEBUG\r\nprintk(KERN_DEBUG "%s: tx underrun\n", card->name);\r\n#endif\r\nreturn;\r\n}\r\nlen = CAPIMSG_LEN(skb->data);\r\nif (len) {\r\ncmd = CAPIMSG_COMMAND(skb->data);\r\nsubcmd = CAPIMSG_SUBCOMMAND(skb->data);\r\np = dma->sendbuf.dmabuf;\r\nif (CAPICMD(cmd, subcmd) == CAPI_DATA_B3_REQ) {\r\nu16 dlen = CAPIMSG_DATALEN(skb->data);\r\n_put_byte(&p, SEND_DATA_B3_REQ);\r\n_put_slice(&p, skb->data, len);\r\n_put_slice(&p, skb->data + len, dlen);\r\n} else {\r\n_put_byte(&p, SEND_MESSAGE);\r\n_put_slice(&p, skb->data, len);\r\n}\r\ntxlen = (u8 *)p - (u8 *)dma->sendbuf.dmabuf;\r\n#ifdef AVM_C4_DEBUG\r\nprintk(KERN_DEBUG "%s: tx put msg len=%d\n", card->name, txlen);\r\n#endif\r\n} else {\r\ntxlen = skb->len-2;\r\n#ifdef AVM_C4_POLLDEBUG\r\nif (skb->data[2] == SEND_POLLACK)\r\nprintk(KERN_INFO "%s: ack to c4\n", card->name);\r\n#endif\r\n#ifdef AVM_C4_DEBUG\r\nprintk(KERN_DEBUG "%s: tx put 0x%x len=%d\n",\r\ncard->name, skb->data[2], txlen);\r\n#endif\r\nskb_copy_from_linear_data_offset(skb, 2, dma->sendbuf.dmabuf,\r\nskb->len - 2);\r\n}\r\ntxlen = (txlen + 3) & ~3;\r\nc4outmeml(card->mbase+MBOX_DOWN_ADDR, dma->sendbuf.dmaaddr);\r\nc4outmeml(card->mbase+MBOX_DOWN_LEN, txlen);\r\ncard->csr |= DBELL_DOWN_ARM;\r\nc4outmeml(card->mbase+DOORBELL, DBELL_DOWN_ARM);\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void queue_pollack(avmcard *card)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *p;\r\nskb = alloc_skb(3, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost poll ack\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_POLLACK);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nc4_dispatch_tx(card);\r\n}\r\nstatic void c4_handle_rx(avmcard *card)\r\n{\r\navmcard_dmainfo *dma = card->dma;\r\nstruct capi_ctr *ctrl;\r\navmctrl_info *cinfo;\r\nstruct sk_buff *skb;\r\nvoid *p = dma->recvbuf.dmabuf;\r\nu32 ApplId, MsgLen, DataB3Len, NCCI, WindowSize;\r\nu8 b1cmd = _get_byte(&p);\r\nu32 cidx;\r\n#ifdef AVM_C4_DEBUG\r\nprintk(KERN_DEBUG "%s: rx 0x%x len=%lu\n", card->name,\r\nb1cmd, (unsigned long)dma->recvlen);\r\n#endif\r\nswitch (b1cmd) {\r\ncase RECEIVE_DATA_B3_IND:\r\nApplId = (unsigned) _get_word(&p);\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\nDataB3Len = _get_slice(&p, card->databuf);\r\ncidx = CAPIMSG_CONTROLLER(card->msgbuf)-card->cardnr;\r\nif (cidx >= card->nlogcontr) cidx = 0;\r\nctrl = &card->ctrlinfo[cidx].capi_ctrl;\r\nif (MsgLen < 30) {\r\nmemset(card->msgbuf+MsgLen, 0, 30-MsgLen);\r\nMsgLen = 30;\r\nCAPIMSG_SETLEN(card->msgbuf, 30);\r\n}\r\nif (!(skb = alloc_skb(DataB3Len+MsgLen, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\n} else {\r\nmemcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);\r\nmemcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_MESSAGE:\r\nApplId = (unsigned) _get_word(&p);\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\ncidx = CAPIMSG_CONTROLLER(card->msgbuf)-card->cardnr;\r\nif (cidx >= card->nlogcontr) cidx = 0;\r\ncinfo = &card->ctrlinfo[cidx];\r\nctrl = &card->ctrlinfo[cidx].capi_ctrl;\r\nif (!(skb = alloc_skb(MsgLen, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\n} else {\r\nmemcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);\r\nif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_CONF)\r\ncapilib_data_b3_conf(&cinfo->ncci_head, ApplId,\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_NEW_NCCI:\r\nApplId = _get_word(&p);\r\nNCCI = _get_word(&p);\r\nWindowSize = _get_word(&p);\r\ncidx = (NCCI&0x7f) - card->cardnr;\r\nif (cidx >= card->nlogcontr) cidx = 0;\r\ncapilib_new_ncci(&card->ctrlinfo[cidx].ncci_head, ApplId, NCCI, WindowSize);\r\nbreak;\r\ncase RECEIVE_FREE_NCCI:\r\nApplId = _get_word(&p);\r\nNCCI = _get_word(&p);\r\nif (NCCI != 0xffffffff) {\r\ncidx = (NCCI&0x7f) - card->cardnr;\r\nif (cidx >= card->nlogcontr) cidx = 0;\r\ncapilib_free_ncci(&card->ctrlinfo[cidx].ncci_head, ApplId, NCCI);\r\n}\r\nbreak;\r\ncase RECEIVE_START:\r\n#ifdef AVM_C4_POLLDEBUG\r\nprintk(KERN_INFO "%s: poll from c4\n", card->name);\r\n#endif\r\nif (!suppress_pollack)\r\nqueue_pollack(card);\r\nfor (cidx=0; cidx < card->nr_controllers; cidx++) {\r\nctrl = &card->ctrlinfo[cidx].capi_ctrl;\r\ncapi_ctr_resume_output(ctrl);\r\n}\r\nbreak;\r\ncase RECEIVE_STOP:\r\nfor (cidx=0; cidx < card->nr_controllers; cidx++) {\r\nctrl = &card->ctrlinfo[cidx].capi_ctrl;\r\ncapi_ctr_suspend_output(ctrl);\r\n}\r\nbreak;\r\ncase RECEIVE_INIT:\r\ncidx = card->nlogcontr;\r\nif (cidx >= card->nr_controllers) {\r\nprintk(KERN_ERR "%s: card with %d controllers ??\n",\r\ncard->name, cidx+1);\r\nbreak;\r\n}\r\ncard->nlogcontr++;\r\ncinfo = &card->ctrlinfo[cidx];\r\nctrl = &cinfo->capi_ctrl;\r\ncinfo->versionlen = _get_slice(&p, cinfo->versionbuf);\r\nb1_parse_version(cinfo);\r\nprintk(KERN_INFO "%s: %s-card (%s) now active\n",\r\ncard->name,\r\ncinfo->version[VER_CARDTYPE],\r\ncinfo->version[VER_DRIVER]);\r\ncapi_ctr_ready(&cinfo->capi_ctrl);\r\nbreak;\r\ncase RECEIVE_TASK_READY:\r\nApplId = (unsigned) _get_word(&p);\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile ( MsgLen > 0\r\n&& ( card->msgbuf[MsgLen-1] == '\n'\r\n|| card->msgbuf[MsgLen-1] == '\r')) {\r\ncard->msgbuf[MsgLen-1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: task %d \"%s\" ready.\n",\r\ncard->name, ApplId, card->msgbuf);\r\nbreak;\r\ncase RECEIVE_DEBUGMSG:\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile ( MsgLen > 0\r\n&& ( card->msgbuf[MsgLen-1] == '\n'\r\n|| card->msgbuf[MsgLen-1] == '\r')) {\r\ncard->msgbuf[MsgLen-1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: c4_interrupt: 0x%x ???\n",\r\ncard->name, b1cmd);\r\nreturn;\r\n}\r\n}\r\nstatic irqreturn_t c4_handle_interrupt(avmcard *card)\r\n{\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&card->lock, flags);\r\nstatus = c4inmeml(card->mbase+DOORBELL);\r\nif (status & DBELL_RESET_HOST) {\r\nu_int i;\r\nc4outmeml(card->mbase+PCI_OUT_INT_MASK, 0x0c);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (card->nlogcontr == 0)\r\nreturn IRQ_HANDLED;\r\nprintk(KERN_ERR "%s: unexpected reset\n", card->name);\r\nfor (i=0; i < card->nr_controllers; i++) {\r\navmctrl_info *cinfo = &card->ctrlinfo[i];\r\nmemset(cinfo->version, 0, sizeof(cinfo->version));\r\nspin_lock_irqsave(&card->lock, flags);\r\ncapilib_release(&cinfo->ncci_head);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_down(&cinfo->capi_ctrl);\r\n}\r\ncard->nlogcontr = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatus &= (DBELL_UP_HOST | DBELL_DOWN_HOST);\r\nif (!status) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nc4outmeml(card->mbase+DOORBELL, status);\r\nif ((status & DBELL_UP_HOST) != 0) {\r\ncard->dma->recvlen = c4inmeml(card->mbase+MBOX_UP_LEN);\r\nc4outmeml(card->mbase+MBOX_UP_LEN, 0);\r\nc4_handle_rx(card);\r\ncard->dma->recvlen = 0;\r\nc4outmeml(card->mbase+MBOX_UP_LEN, card->dma->recvbuf.size);\r\nc4outmeml(card->mbase+DOORBELL, DBELL_UP_ARM);\r\n}\r\nif ((status & DBELL_DOWN_HOST) != 0) {\r\ncard->csr &= ~DBELL_DOWN_ARM;\r\nc4_dispatch_tx(card);\r\n} else if (card->csr & DBELL_DOWN_HOST) {\r\nif (c4inmeml(card->mbase+MBOX_DOWN_LEN) == 0) {\r\ncard->csr &= ~DBELL_DOWN_ARM;\r\nc4_dispatch_tx(card);\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t c4_interrupt(int interrupt, void *devptr)\r\n{\r\navmcard *card = devptr;\r\nreturn c4_handle_interrupt(card);\r\n}\r\nstatic void c4_send_init(avmcard *card)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *p;\r\nunsigned long flags;\r\nskb = alloc_skb(15, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost register appl.\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_INIT);\r\n_put_word(&p, CAPI_MAXAPPL);\r\n_put_word(&p, AVM_NCCI_PER_CHANNEL*30);\r\n_put_word(&p, card->cardnr - 1);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nspin_lock_irqsave(&card->lock, flags);\r\nc4_dispatch_tx(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic int queue_sendconfigword(avmcard *card, u32 val)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nvoid *p;\r\nskb = alloc_skb(3+4, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, send config\n",\r\ncard->name);\r\nreturn -ENOMEM;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_CONFIG);\r\n_put_word(&p, val);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nspin_lock_irqsave(&card->lock, flags);\r\nc4_dispatch_tx(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int queue_sendconfig(avmcard *card, char cval[4])\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nvoid *p;\r\nskb = alloc_skb(3+4, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, send config\n",\r\ncard->name);\r\nreturn -ENOMEM;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_CONFIG);\r\n_put_byte(&p, cval[0]);\r\n_put_byte(&p, cval[1]);\r\n_put_byte(&p, cval[2]);\r\n_put_byte(&p, cval[3]);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nspin_lock_irqsave(&card->lock, flags);\r\nc4_dispatch_tx(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int c4_send_config(avmcard *card, capiloaddatapart * config)\r\n{\r\nu8 val[4];\r\nunsigned char *dp;\r\nu_int left;\r\nint retval;\r\nif ((retval = queue_sendconfigword(card, 1)) != 0)\r\nreturn retval;\r\nif ((retval = queue_sendconfigword(card, config->len)) != 0)\r\nreturn retval;\r\ndp = config->data;\r\nleft = config->len;\r\nwhile (left >= sizeof(u32)) {\r\nif (config->user) {\r\nif (copy_from_user(val, dp, sizeof(val)))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(val, dp, sizeof(val));\r\n}\r\nif ((retval = queue_sendconfig(card, val)) != 0)\r\nreturn retval;\r\nleft -= sizeof(val);\r\ndp += sizeof(val);\r\n}\r\nif (left) {\r\nmemset(val, 0, sizeof(val));\r\nif (config->user) {\r\nif (copy_from_user(&val, dp, left))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(&val, dp, left);\r\n}\r\nif ((retval = queue_sendconfig(card, val)) != 0)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int c4_load_firmware(struct capi_ctr *ctrl, capiloaddata *data)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nint retval;\r\nif ((retval = c4_load_t4file(card, &data->firmware))) {\r\nprintk(KERN_ERR "%s: failed to load t4file!!\n",\r\ncard->name);\r\nc4_reset(card);\r\nreturn retval;\r\n}\r\ncard->csr = 0;\r\nc4outmeml(card->mbase+MBOX_UP_LEN, 0);\r\nc4outmeml(card->mbase+MBOX_DOWN_LEN, 0);\r\nc4outmeml(card->mbase+DOORBELL, DBELL_INIT);\r\nmdelay(1);\r\nc4outmeml(card->mbase+DOORBELL,\r\nDBELL_UP_HOST | DBELL_DOWN_HOST | DBELL_RESET_HOST);\r\nc4outmeml(card->mbase+PCI_OUT_INT_MASK, 0x08);\r\ncard->dma->recvlen = 0;\r\nc4outmeml(card->mbase+MBOX_UP_ADDR, card->dma->recvbuf.dmaaddr);\r\nc4outmeml(card->mbase+MBOX_UP_LEN, card->dma->recvbuf.size);\r\nc4outmeml(card->mbase+DOORBELL, DBELL_UP_ARM);\r\nif (data->configuration.len > 0 && data->configuration.data) {\r\nretval = c4_send_config(card, &data->configuration);\r\nif (retval) {\r\nprintk(KERN_ERR "%s: failed to set config!!\n",\r\ncard->name);\r\nc4_reset(card);\r\nreturn retval;\r\n}\r\n}\r\nc4_send_init(card);\r\nreturn 0;\r\n}\r\nstatic void c4_reset_ctr(struct capi_ctr *ctrl)\r\n{\r\navmcard *card = ((avmctrl_info *)(ctrl->driverdata))->card;\r\navmctrl_info *cinfo;\r\nu_int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nc4_reset(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nfor (i=0; i < card->nr_controllers; i++) {\r\ncinfo = &card->ctrlinfo[i];\r\nmemset(cinfo->version, 0, sizeof(cinfo->version));\r\ncapi_ctr_down(&cinfo->capi_ctrl);\r\n}\r\ncard->nlogcontr = 0;\r\n}\r\nstatic void c4_remove(struct pci_dev *pdev)\r\n{\r\navmcard *card = pci_get_drvdata(pdev);\r\navmctrl_info *cinfo;\r\nu_int i;\r\nif (!card)\r\nreturn;\r\nc4_reset(card);\r\nfor (i=0; i < card->nr_controllers; i++) {\r\ncinfo = &card->ctrlinfo[i];\r\ndetach_capi_ctr(&cinfo->capi_ctrl);\r\n}\r\nfree_irq(card->irq, card);\r\niounmap(card->mbase);\r\nrelease_region(card->port, AVMB1_PORTLEN);\r\navmcard_dma_free(card->dma);\r\npci_set_drvdata(pdev, NULL);\r\nb1_free_card(card);\r\n}\r\nstatic void c4_register_appl(struct capi_ctr *ctrl,\r\nu16 appl,\r\ncapi_register_params *rp)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nstruct sk_buff *skb;\r\nint want = rp->level3cnt;\r\nunsigned long flags;\r\nint nconn;\r\nvoid *p;\r\nif (ctrl->cnr == card->cardnr) {\r\nif (want > 0) nconn = want;\r\nelse nconn = ctrl->profile.nbchannel * 4 * -want;\r\nif (nconn == 0) nconn = ctrl->profile.nbchannel * 4;\r\nskb = alloc_skb(23, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost register appl.\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_REGISTER);\r\n_put_word(&p, appl);\r\n_put_word(&p, 1024 * (nconn+1));\r\n_put_word(&p, nconn);\r\n_put_word(&p, rp->datablkcnt);\r\n_put_word(&p, rp->datablklen);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nspin_lock_irqsave(&card->lock, flags);\r\nc4_dispatch_tx(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\n}\r\nstatic void c4_release_appl(struct capi_ctr *ctrl, u16 appl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nvoid *p;\r\nspin_lock_irqsave(&card->lock, flags);\r\ncapilib_release_appl(&cinfo->ncci_head, appl);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (ctrl->cnr == card->cardnr) {\r\nskb = alloc_skb(7, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost release appl.\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_RELEASE);\r\n_put_word(&p, appl);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nspin_lock_irqsave(&card->lock, flags);\r\nc4_dispatch_tx(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\n}\r\nstatic u16 c4_send_message(struct capi_ctr *ctrl, struct sk_buff *skb)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nu16 retval = CAPI_NOERROR;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_REQ) {\r\nretval = capilib_data_b3_req(&cinfo->ncci_head,\r\nCAPIMSG_APPID(skb->data),\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\n}\r\nif (retval == CAPI_NOERROR) {\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nc4_dispatch_tx(card);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn retval;\r\n}\r\nstatic char *c4_procinfo(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\nif (!cinfo)\r\nreturn "";\r\nsprintf(cinfo->infobuf, "%s %s 0x%x %d 0x%lx",\r\ncinfo->cardname[0] ? cinfo->cardname : "-",\r\ncinfo->version[VER_DRIVER] ? cinfo->version[VER_DRIVER] : "-",\r\ncinfo->card ? cinfo->card->port : 0x0,\r\ncinfo->card ? cinfo->card->irq : 0,\r\ncinfo->card ? cinfo->card->membase : 0\r\n);\r\nreturn cinfo->infobuf;\r\n}\r\nstatic int c4_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct capi_ctr *ctrl = m->private;\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nu8 flag;\r\nchar *s;\r\nseq_printf(m, "%-16s %s\n", "name", card->name);\r\nseq_printf(m, "%-16s 0x%x\n", "io", card->port);\r\nseq_printf(m, "%-16s %d\n", "irq", card->irq);\r\nseq_printf(m, "%-16s 0x%lx\n", "membase", card->membase);\r\nswitch (card->cardtype) {\r\ncase avm_b1isa: s = "B1 ISA"; break;\r\ncase avm_b1pci: s = "B1 PCI"; break;\r\ncase avm_b1pcmcia: s = "B1 PCMCIA"; break;\r\ncase avm_m1: s = "M1"; break;\r\ncase avm_m2: s = "M2"; break;\r\ncase avm_t1isa: s = "T1 ISA (HEMA)"; break;\r\ncase avm_t1pci: s = "T1 PCI"; break;\r\ncase avm_c4: s = "C4"; break;\r\ncase avm_c2: s = "C2"; break;\r\ndefault: s = "???"; break;\r\n}\r\nseq_printf(m, "%-16s %s\n", "type", s);\r\nif ((s = cinfo->version[VER_DRIVER]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_driver", s);\r\nif ((s = cinfo->version[VER_CARDTYPE]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_cardtype", s);\r\nif ((s = cinfo->version[VER_SERIAL]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_serial", s);\r\nif (card->cardtype != avm_m1) {\r\nflag = ((u8 *)(ctrl->profile.manu))[3];\r\nif (flag)\r\nseq_printf(m, "%-16s%s%s%s%s%s%s%s\n",\r\n"protocol",\r\n(flag & 0x01) ? " DSS1" : "",\r\n(flag & 0x02) ? " CT1" : "",\r\n(flag & 0x04) ? " VN3" : "",\r\n(flag & 0x08) ? " NI1" : "",\r\n(flag & 0x10) ? " AUSTEL" : "",\r\n(flag & 0x20) ? " ESS" : "",\r\n(flag & 0x40) ? " 1TR6" : ""\r\n);\r\n}\r\nif (card->cardtype != avm_m1) {\r\nflag = ((u8 *)(ctrl->profile.manu))[5];\r\nif (flag)\r\nseq_printf(m, "%-16s%s%s%s%s\n",\r\n"linetype",\r\n(flag & 0x01) ? " point to point" : "",\r\n(flag & 0x02) ? " point to multipoint" : "",\r\n(flag & 0x08) ? " leased line without D-channel" : "",\r\n(flag & 0x04) ? " leased line with D-channel" : ""\r\n);\r\n}\r\nseq_printf(m, "%-16s %s\n", "cardname", cinfo->cardname);\r\nreturn 0;\r\n}\r\nstatic int c4_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, c4_proc_show, PDE(inode)->data);\r\n}\r\nstatic int c4_add_card(struct capicardparams *p, struct pci_dev *dev,\r\nint nr_controllers)\r\n{\r\navmcard *card;\r\navmctrl_info *cinfo;\r\nint retval;\r\nint i;\r\ncard = b1_alloc_card(nr_controllers);\r\nif (!card) {\r\nprintk(KERN_WARNING "c4: no memory.\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\ncard->dma = avmcard_dma_alloc("c4", dev, 2048+128, 2048+128);\r\nif (!card->dma) {\r\nprintk(KERN_WARNING "c4: no memory.\n");\r\nretval = -ENOMEM;\r\ngoto err_free;\r\n}\r\nsprintf(card->name, "c%d-%x", nr_controllers, p->port);\r\ncard->port = p->port;\r\ncard->irq = p->irq;\r\ncard->membase = p->membase;\r\ncard->cardtype = (nr_controllers == 4) ? avm_c4 : avm_c2;\r\nif (!request_region(card->port, AVMB1_PORTLEN, card->name)) {\r\nprintk(KERN_WARNING "c4: ports 0x%03x-0x%03x in use.\n",\r\ncard->port, card->port + AVMB1_PORTLEN);\r\nretval = -EBUSY;\r\ngoto err_free_dma;\r\n}\r\ncard->mbase = ioremap(card->membase, 128);\r\nif (card->mbase == NULL) {\r\nprintk(KERN_NOTICE "c4: can't remap memory at 0x%lx\n",\r\ncard->membase);\r\nretval = -EIO;\r\ngoto err_release_region;\r\n}\r\nretval = c4_detect(card);\r\nif (retval != 0) {\r\nprintk(KERN_NOTICE "c4: NO card at 0x%x error(%d)\n",\r\ncard->port, retval);\r\nretval = -EIO;\r\ngoto err_unmap;\r\n}\r\nc4_reset(card);\r\nretval = request_irq(card->irq, c4_interrupt, IRQF_SHARED, card->name, card);\r\nif (retval) {\r\nprintk(KERN_ERR "c4: unable to get IRQ %d.\n",card->irq);\r\nretval = -EBUSY;\r\ngoto err_unmap;\r\n}\r\nfor (i=0; i < nr_controllers ; i++) {\r\ncinfo = &card->ctrlinfo[i];\r\ncinfo->capi_ctrl.owner = THIS_MODULE;\r\ncinfo->capi_ctrl.driver_name = "c4";\r\ncinfo->capi_ctrl.driverdata = cinfo;\r\ncinfo->capi_ctrl.register_appl = c4_register_appl;\r\ncinfo->capi_ctrl.release_appl = c4_release_appl;\r\ncinfo->capi_ctrl.send_message = c4_send_message;\r\ncinfo->capi_ctrl.load_firmware = c4_load_firmware;\r\ncinfo->capi_ctrl.reset_ctr = c4_reset_ctr;\r\ncinfo->capi_ctrl.procinfo = c4_procinfo;\r\ncinfo->capi_ctrl.proc_fops = &c4_proc_fops;\r\nstrcpy(cinfo->capi_ctrl.name, card->name);\r\nretval = attach_capi_ctr(&cinfo->capi_ctrl);\r\nif (retval) {\r\nprintk(KERN_ERR "c4: attach controller failed (%d).\n", i);\r\nfor (i--; i >= 0; i--) {\r\ncinfo = &card->ctrlinfo[i];\r\ndetach_capi_ctr(&cinfo->capi_ctrl);\r\n}\r\ngoto err_free_irq;\r\n}\r\nif (i == 0)\r\ncard->cardnr = cinfo->capi_ctrl.cnr;\r\n}\r\nprintk(KERN_INFO "c4: AVM C%d at i/o %#x, irq %d, mem %#lx\n",\r\nnr_controllers, card->port, card->irq,\r\ncard->membase);\r\npci_set_drvdata(dev, card);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(card->irq, card);\r\nerr_unmap:\r\niounmap(card->mbase);\r\nerr_release_region:\r\nrelease_region(card->port, AVMB1_PORTLEN);\r\nerr_free_dma:\r\navmcard_dma_free(card->dma);\r\nerr_free:\r\nb1_free_card(card);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int __devinit c4_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint nr = ent->driver_data;\r\nint retval = 0;\r\nstruct capicardparams param;\r\nif (pci_enable_device(dev) < 0) {\r\nprintk(KERN_ERR "c4: failed to enable AVM-C%d\n", nr);\r\nreturn -ENODEV;\r\n}\r\npci_set_master(dev);\r\nparam.port = pci_resource_start(dev, 1);\r\nparam.irq = dev->irq;\r\nparam.membase = pci_resource_start(dev, 0);\r\nprintk(KERN_INFO "c4: PCI BIOS reports AVM-C%d at i/o %#x, irq %d, mem %#x\n",\r\nnr, param.port, param.irq, param.membase);\r\nretval = c4_add_card(&param, dev, nr);\r\nif (retval != 0) {\r\nprintk(KERN_ERR "c4: no AVM-C%d at i/o %#x, irq %d detected, mem %#x\n",\r\nnr, param.port, param.irq, param.membase);\r\npci_disable_device(dev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init c4_init(void)\r\n{\r\nchar *p;\r\nchar rev[32];\r\nint err;\r\nif ((p = strchr(revision, ':')) != NULL && p[1]) {\r\nstrlcpy(rev, p + 2, 32);\r\nif ((p = strchr(rev, '$')) != NULL && p > rev)\r\n*(p-1) = 0;\r\n} else\r\nstrcpy(rev, "1.0");\r\nerr = pci_register_driver(&c4_pci_driver);\r\nif (!err) {\r\nstrlcpy(capi_driver_c2.revision, rev, 32);\r\nregister_capi_driver(&capi_driver_c2);\r\nstrlcpy(capi_driver_c4.revision, rev, 32);\r\nregister_capi_driver(&capi_driver_c4);\r\nprintk(KERN_INFO "c4: revision %s\n", rev);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit c4_exit(void)\r\n{\r\nunregister_capi_driver(&capi_driver_c2);\r\nunregister_capi_driver(&capi_driver_c4);\r\npci_unregister_driver(&c4_pci_driver);\r\n}
