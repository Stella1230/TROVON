static int ICAMEX_msg_to_type4MEX_msg(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nunsigned char *modulus, *exponent, *message;\r\nint mod_len;\r\nmod_len = mex->inputdatalength;\r\nif (mod_len <= 128) {\r\nstruct type4_sme *sme = ap_msg->message;\r\nmemset(sme, 0, sizeof(*sme));\r\nap_msg->length = sizeof(*sme);\r\nsme->header.msg_fmt = TYPE4_SME_FMT;\r\nsme->header.msg_len = sizeof(*sme);\r\nsme->header.msg_type_code = TYPE4_TYPE_CODE;\r\nsme->header.request_code = TYPE4_REQU_CODE;\r\nmodulus = sme->modulus + sizeof(sme->modulus) - mod_len;\r\nexponent = sme->exponent + sizeof(sme->exponent) - mod_len;\r\nmessage = sme->message + sizeof(sme->message) - mod_len;\r\n} else {\r\nstruct type4_lme *lme = ap_msg->message;\r\nmemset(lme, 0, sizeof(*lme));\r\nap_msg->length = sizeof(*lme);\r\nlme->header.msg_fmt = TYPE4_LME_FMT;\r\nlme->header.msg_len = sizeof(*lme);\r\nlme->header.msg_type_code = TYPE4_TYPE_CODE;\r\nlme->header.request_code = TYPE4_REQU_CODE;\r\nmodulus = lme->modulus + sizeof(lme->modulus) - mod_len;\r\nexponent = lme->exponent + sizeof(lme->exponent) - mod_len;\r\nmessage = lme->message + sizeof(lme->message) - mod_len;\r\n}\r\nif (copy_from_user(modulus, mex->n_modulus, mod_len) ||\r\ncopy_from_user(exponent, mex->b_key, mod_len) ||\r\ncopy_from_user(message, mex->inputdata, mod_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ICACRT_msg_to_type4CRT_msg(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nunsigned char *p, *q, *dp, *dq, *u, *inp;\r\nint mod_len, short_len, long_len;\r\nmod_len = crt->inputdatalength;\r\nshort_len = mod_len / 2;\r\nlong_len = mod_len / 2 + 8;\r\nif (mod_len <= 128) {\r\nstruct type4_scr *scr = ap_msg->message;\r\nmemset(scr, 0, sizeof(*scr));\r\nap_msg->length = sizeof(*scr);\r\nscr->header.msg_type_code = TYPE4_TYPE_CODE;\r\nscr->header.request_code = TYPE4_REQU_CODE;\r\nscr->header.msg_fmt = TYPE4_SCR_FMT;\r\nscr->header.msg_len = sizeof(*scr);\r\np = scr->p + sizeof(scr->p) - long_len;\r\nq = scr->q + sizeof(scr->q) - short_len;\r\ndp = scr->dp + sizeof(scr->dp) - long_len;\r\ndq = scr->dq + sizeof(scr->dq) - short_len;\r\nu = scr->u + sizeof(scr->u) - long_len;\r\ninp = scr->message + sizeof(scr->message) - mod_len;\r\n} else {\r\nstruct type4_lcr *lcr = ap_msg->message;\r\nmemset(lcr, 0, sizeof(*lcr));\r\nap_msg->length = sizeof(*lcr);\r\nlcr->header.msg_type_code = TYPE4_TYPE_CODE;\r\nlcr->header.request_code = TYPE4_REQU_CODE;\r\nlcr->header.msg_fmt = TYPE4_LCR_FMT;\r\nlcr->header.msg_len = sizeof(*lcr);\r\np = lcr->p + sizeof(lcr->p) - long_len;\r\nq = lcr->q + sizeof(lcr->q) - short_len;\r\ndp = lcr->dp + sizeof(lcr->dp) - long_len;\r\ndq = lcr->dq + sizeof(lcr->dq) - short_len;\r\nu = lcr->u + sizeof(lcr->u) - long_len;\r\ninp = lcr->message + sizeof(lcr->message) - mod_len;\r\n}\r\nif (copy_from_user(p, crt->np_prime, long_len) ||\r\ncopy_from_user(q, crt->nq_prime, short_len) ||\r\ncopy_from_user(dp, crt->bp_key, long_len) ||\r\ncopy_from_user(dq, crt->bq_key, short_len) ||\r\ncopy_from_user(u, crt->u_mult_inv, long_len) ||\r\ncopy_from_user(inp, crt->inputdata, mod_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_type84(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstruct type84_hdr *t84h = reply->message;\r\nchar *data;\r\nif (t84h->len < sizeof(*t84h) + outputdatalength) {\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\nBUG_ON(t84h->len > PCICA_MAX_RESPONSE_SIZE);\r\ndata = reply->message + t84h->len - outputdatalength;\r\nif (copy_to_user(outputdata, data, outputdatalength))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_response(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nswitch (((unsigned char *) reply->message)[1]) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn convert_error(zdev, reply);\r\ncase TYPE84_RSP_CODE:\r\nreturn convert_type84(zdev, reply,\r\noutputdata, outputdatalength);\r\ndefault:\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void zcrypt_pcica_receive(struct ap_device *ap_dev,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct type84_hdr *t84h;\r\nint length;\r\nif (IS_ERR(reply)) {\r\nmemcpy(msg->message, &error_reply, sizeof(error_reply));\r\ngoto out;\r\n}\r\nt84h = reply->message;\r\nif (t84h->code == TYPE84_RSP_CODE) {\r\nlength = min(PCICA_MAX_RESPONSE_SIZE, (int) t84h->len);\r\nmemcpy(msg->message, reply->message, length);\r\n} else\r\nmemcpy(msg->message, reply->message, sizeof error_reply);\r\nout:\r\ncomplete((struct completion *) msg->private);\r\n}\r\nstatic long zcrypt_pcica_modexpo(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = kmalloc(PCICA_MAX_MESSAGE_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICAMEX_msg_to_type4MEX_msg(zdev, &ap_msg, mex);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0)\r\nrc = convert_response(zdev, &ap_msg, mex->outputdata,\r\nmex->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_pcica_modexpo_crt(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = kmalloc(PCICA_MAX_MESSAGE_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICACRT_msg_to_type4CRT_msg(zdev, &ap_msg, crt);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0)\r\nrc = convert_response(zdev, &ap_msg, crt->outputdata,\r\ncrt->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic int zcrypt_pcica_probe(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint rc;\r\nzdev = zcrypt_device_alloc(PCICA_MAX_RESPONSE_SIZE);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->ap_dev = ap_dev;\r\nzdev->ops = &zcrypt_pcica_ops;\r\nzdev->online = 1;\r\nzdev->user_space_type = ZCRYPT_PCICA;\r\nzdev->type_string = "PCICA";\r\nzdev->min_mod_size = PCICA_MIN_MOD_SIZE;\r\nzdev->max_mod_size = PCICA_MAX_MOD_SIZE;\r\nzdev->speed_rating = PCICA_SPEED_RATING;\r\nzdev->max_exp_bit_length = PCICA_MAX_MOD_SIZE;\r\nap_dev->reply = &zdev->reply;\r\nap_dev->private = zdev;\r\nrc = zcrypt_device_register(zdev);\r\nif (rc)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nap_dev->private = NULL;\r\nzcrypt_device_free(zdev);\r\nreturn rc;\r\n}\r\nstatic void zcrypt_pcica_remove(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev = ap_dev->private;\r\nzcrypt_device_unregister(zdev);\r\n}\r\nint __init zcrypt_pcica_init(void)\r\n{\r\nreturn ap_driver_register(&zcrypt_pcica_driver, THIS_MODULE, "pcica");\r\n}\r\nvoid zcrypt_pcica_exit(void)\r\n{\r\nap_driver_unregister(&zcrypt_pcica_driver);\r\n}
