static void scx200_wdt_ping(void)\r\n{\r\nspin_lock(&scx_lock);\r\noutw(wdto_restart, scx200_cb_base + SCx200_WDT_WDTO);\r\nspin_unlock(&scx_lock);\r\n}\r\nstatic void scx200_wdt_update_margin(void)\r\n{\r\nprintk(KERN_INFO NAME ": timer margin %d seconds\n", margin);\r\nwdto_restart = margin * W_SCALE;\r\n}\r\nstatic void scx200_wdt_enable(void)\r\n{\r\nprintk(KERN_DEBUG NAME ": enabling watchdog timer, wdto_restart = %d\n",\r\nwdto_restart);\r\nspin_lock(&scx_lock);\r\noutw(0, scx200_cb_base + SCx200_WDT_WDTO);\r\noutb(SCx200_WDT_WDSTS_WDOVF, scx200_cb_base + SCx200_WDT_WDSTS);\r\noutw(W_ENABLE, scx200_cb_base + SCx200_WDT_WDCNFG);\r\nspin_unlock(&scx_lock);\r\nscx200_wdt_ping();\r\n}\r\nstatic void scx200_wdt_disable(void)\r\n{\r\nprintk(KERN_DEBUG NAME ": disabling watchdog timer\n");\r\nspin_lock(&scx_lock);\r\noutw(0, scx200_cb_base + SCx200_WDT_WDTO);\r\noutb(SCx200_WDT_WDSTS_WDOVF, scx200_cb_base + SCx200_WDT_WDSTS);\r\noutw(W_DISABLE, scx200_cb_base + SCx200_WDT_WDCNFG);\r\nspin_unlock(&scx_lock);\r\n}\r\nstatic int scx200_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &open_lock))\r\nreturn -EBUSY;\r\nscx200_wdt_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int scx200_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close != 42)\r\nprintk(KERN_WARNING NAME\r\n": watchdog device closed unexpectedly, "\r\n"will not disable the watchdog timer\n");\r\nelse if (!nowayout)\r\nscx200_wdt_disable();\r\nexpect_close = 0;\r\nclear_bit(0, &open_lock);\r\nreturn 0;\r\n}\r\nstatic int scx200_wdt_notify_sys(struct notifier_block *this,\r\nunsigned long code, void *unused)\r\n{\r\nif (code == SYS_HALT || code == SYS_POWER_OFF)\r\nif (!nowayout)\r\nscx200_wdt_disable();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic ssize_t scx200_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nsize_t i;\r\nscx200_wdt_ping();\r\nexpect_close = 0;\r\nfor (i = 0; i < len; ++i) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\nreturn len;\r\n}\r\nreturn 0;\r\n}\r\nstatic long scx200_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.identity = "NatSemi SCx200 Watchdog",\r\n.firmware_version = 1,\r\n.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\r\nWDIOF_MAGICCLOSE,\r\n};\r\nint new_margin;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nif (put_user(0, p))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nscx200_wdt_ping();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_margin, p))\r\nreturn -EFAULT;\r\nif (new_margin < 1)\r\nreturn -EINVAL;\r\nmargin = new_margin;\r\nscx200_wdt_update_margin();\r\nscx200_wdt_ping();\r\ncase WDIOC_GETTIMEOUT:\r\nif (put_user(margin, p))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int __init scx200_wdt_init(void)\r\n{\r\nint r;\r\nprintk(KERN_DEBUG NAME ": NatSemi SCx200 Watchdog Driver\n");\r\nif (!scx200_cb_present())\r\nreturn -ENODEV;\r\nif (!request_region(scx200_cb_base + SCx200_WDT_OFFSET,\r\nSCx200_WDT_SIZE,\r\n"NatSemi SCx200 Watchdog")) {\r\nprintk(KERN_WARNING NAME ": watchdog I/O region busy\n");\r\nreturn -EBUSY;\r\n}\r\nscx200_wdt_update_margin();\r\nscx200_wdt_disable();\r\nr = register_reboot_notifier(&scx200_wdt_notifier);\r\nif (r) {\r\nprintk(KERN_ERR NAME ": unable to register reboot notifier");\r\nrelease_region(scx200_cb_base + SCx200_WDT_OFFSET,\r\nSCx200_WDT_SIZE);\r\nreturn r;\r\n}\r\nr = misc_register(&scx200_wdt_miscdev);\r\nif (r) {\r\nunregister_reboot_notifier(&scx200_wdt_notifier);\r\nrelease_region(scx200_cb_base + SCx200_WDT_OFFSET,\r\nSCx200_WDT_SIZE);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit scx200_wdt_cleanup(void)\r\n{\r\nmisc_deregister(&scx200_wdt_miscdev);\r\nunregister_reboot_notifier(&scx200_wdt_notifier);\r\nrelease_region(scx200_cb_base + SCx200_WDT_OFFSET,\r\nSCx200_WDT_SIZE);\r\n}
