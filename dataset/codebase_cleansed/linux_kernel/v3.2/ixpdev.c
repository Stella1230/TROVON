static int ixpdev_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ixpdev_priv *ip = netdev_priv(dev);\r\nstruct ixpdev_tx_desc *desc;\r\nint entry;\r\nunsigned long flags;\r\nif (unlikely(skb->len > PAGE_SIZE)) {\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nentry = tx_pointer;\r\ntx_pointer = (tx_pointer + 1) % TX_BUF_COUNT;\r\ndesc = tx_desc + entry;\r\ndesc->pkt_length = skb->len;\r\ndesc->channel = ip->channel;\r\nskb_copy_and_csum_dev(skb, phys_to_virt(desc->buf_addr));\r\ndev_kfree_skb(skb);\r\nixp2000_reg_write(RING_TX_PENDING,\r\nTX_BUF_DESC_BASE + (entry * sizeof(struct ixpdev_tx_desc)));\r\nlocal_irq_save(flags);\r\nip->tx_queue_entries++;\r\nif (ip->tx_queue_entries == TX_BUF_COUNT_PER_CHAN)\r\nnetif_stop_queue(dev);\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ixpdev_rx(struct net_device *dev, int processed, int budget)\r\n{\r\nwhile (processed < budget) {\r\nstruct ixpdev_rx_desc *desc;\r\nstruct sk_buff *skb;\r\nvoid *buf;\r\nu32 _desc;\r\n_desc = ixp2000_reg_read(RING_RX_DONE);\r\nif (_desc == 0)\r\nreturn 0;\r\ndesc = rx_desc +\r\n((_desc - RX_BUF_DESC_BASE) / sizeof(struct ixpdev_rx_desc));\r\nbuf = phys_to_virt(desc->buf_addr);\r\nif (desc->pkt_length < 4 || desc->pkt_length > PAGE_SIZE) {\r\nprintk(KERN_ERR "ixp2000: rx err, length %d\n",\r\ndesc->pkt_length);\r\ngoto err;\r\n}\r\nif (desc->channel < 0 || desc->channel >= nds_count) {\r\nprintk(KERN_ERR "ixp2000: rx err, channel %d\n",\r\ndesc->channel);\r\ngoto err;\r\n}\r\ndesc->pkt_length -= 4;\r\nif (unlikely(!netif_running(nds[desc->channel])))\r\ngoto err;\r\nskb = netdev_alloc_skb_ip_align(dev, desc->pkt_length);\r\nif (likely(skb != NULL)) {\r\nskb_copy_to_linear_data(skb, buf, desc->pkt_length);\r\nskb_put(skb, desc->pkt_length);\r\nskb->protocol = eth_type_trans(skb, nds[desc->channel]);\r\nnetif_receive_skb(skb);\r\n}\r\nerr:\r\nixp2000_reg_write(RING_RX_PENDING, _desc);\r\nprocessed++;\r\n}\r\nreturn processed;\r\n}\r\nstatic int ixpdev_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct ixpdev_priv *ip = container_of(napi, struct ixpdev_priv, napi);\r\nstruct net_device *dev = ip->dev;\r\nint rx;\r\nrx = 0;\r\ndo {\r\nixp2000_reg_write(IXP2000_IRQ_THD_RAW_STATUS_A_0, 0x00ff);\r\nrx = ixpdev_rx(dev, rx, budget);\r\nif (rx >= budget)\r\nbreak;\r\n} while (ixp2000_reg_read(IXP2000_IRQ_THD_RAW_STATUS_A_0) & 0x00ff);\r\nnapi_complete(napi);\r\nixp2000_reg_write(IXP2000_IRQ_THD_ENABLE_SET_A_0, 0x00ff);\r\nreturn rx;\r\n}\r\nstatic void ixpdev_tx_complete(void)\r\n{\r\nint channel;\r\nu32 wake;\r\nwake = 0;\r\nwhile (1) {\r\nstruct ixpdev_priv *ip;\r\nu32 desc;\r\nint entry;\r\ndesc = ixp2000_reg_read(RING_TX_DONE);\r\nif (desc == 0)\r\nbreak;\r\nentry = (desc - TX_BUF_DESC_BASE) / sizeof(struct ixpdev_tx_desc);\r\nchannel = tx_desc[entry].channel;\r\nif (channel < 0 || channel >= nds_count) {\r\nprintk(KERN_ERR "ixp2000: txcomp channel index "\r\n"out of bounds (%d, %.8i, %d)\n",\r\nchannel, (unsigned int)desc, entry);\r\ncontinue;\r\n}\r\nip = netdev_priv(nds[channel]);\r\nif (ip->tx_queue_entries == TX_BUF_COUNT_PER_CHAN)\r\nwake |= 1 << channel;\r\nip->tx_queue_entries--;\r\n}\r\nfor (channel = 0; wake != 0; channel++) {\r\nif (wake & (1 << channel)) {\r\nnetif_wake_queue(nds[channel]);\r\nwake &= ~(1 << channel);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t ixpdev_interrupt(int irq, void *dev_id)\r\n{\r\nu32 status;\r\nstatus = ixp2000_reg_read(IXP2000_IRQ_THD_STATUS_A_0);\r\nif (status == 0)\r\nreturn IRQ_NONE;\r\nif (status & 0x00ff) {\r\nstruct net_device *dev = nds[0];\r\nstruct ixpdev_priv *ip = netdev_priv(dev);\r\nixp2000_reg_wrb(IXP2000_IRQ_THD_ENABLE_CLEAR_A_0, 0x00ff);\r\nif (likely(napi_schedule_prep(&ip->napi))) {\r\n__napi_schedule(&ip->napi);\r\n} else {\r\nprintk(KERN_CRIT "ixp2000: irq while polling!!\n");\r\n}\r\n}\r\nif (status & 0xff00) {\r\nixp2000_reg_wrb(IXP2000_IRQ_THD_RAW_STATUS_A_0, 0xff00);\r\nixpdev_tx_complete();\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ixpdev_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(IRQ_IXP2000_THDA0);\r\nixpdev_interrupt(IRQ_IXP2000_THDA0, dev);\r\nenable_irq(IRQ_IXP2000_THDA0);\r\n}\r\nstatic int ixpdev_open(struct net_device *dev)\r\n{\r\nstruct ixpdev_priv *ip = netdev_priv(dev);\r\nint err;\r\nnapi_enable(&ip->napi);\r\nif (!nds_open++) {\r\nerr = request_irq(IRQ_IXP2000_THDA0, ixpdev_interrupt,\r\nIRQF_SHARED, "ixp2000_eth", nds);\r\nif (err) {\r\nnds_open--;\r\nnapi_disable(&ip->napi);\r\nreturn err;\r\n}\r\nixp2000_reg_write(IXP2000_IRQ_THD_ENABLE_SET_A_0, 0xffff);\r\n}\r\nset_port_admin_status(ip->channel, 1);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ixpdev_close(struct net_device *dev)\r\n{\r\nstruct ixpdev_priv *ip = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&ip->napi);\r\nset_port_admin_status(ip->channel, 0);\r\nif (!--nds_open) {\r\nixp2000_reg_write(IXP2000_IRQ_THD_ENABLE_CLEAR_A_0, 0xffff);\r\nfree_irq(IRQ_IXP2000_THDA0, nds);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *ixpdev_get_stats(struct net_device *dev)\r\n{\r\nstruct ixpdev_priv *ip = netdev_priv(dev);\r\npm3386_get_stats(ip->channel, &(dev->stats));\r\nreturn &(dev->stats);\r\n}\r\nstruct net_device *ixpdev_alloc(int channel, int sizeof_priv)\r\n{\r\nstruct net_device *dev;\r\nstruct ixpdev_priv *ip;\r\ndev = alloc_etherdev(sizeof_priv);\r\nif (dev == NULL)\r\nreturn NULL;\r\ndev->netdev_ops = &ixpdev_netdev_ops;\r\ndev->features |= NETIF_F_SG | NETIF_F_HW_CSUM;\r\nip = netdev_priv(dev);\r\nip->dev = dev;\r\nnetif_napi_add(dev, &ip->napi, ixpdev_poll, 64);\r\nip->channel = channel;\r\nip->tx_queue_entries = 0;\r\nreturn dev;\r\n}\r\nint ixpdev_init(int __nds_count, struct net_device **__nds,\r\nvoid (*__set_port_admin_status)(int port, int up))\r\n{\r\nint i;\r\nint err;\r\nBUILD_BUG_ON(RX_BUF_COUNT > 192 || TX_BUF_COUNT > 192);\r\nprintk(KERN_INFO "IXP2000 MSF ethernet driver %s\n", DRV_MODULE_VERSION);\r\nnds_count = __nds_count;\r\nnds = __nds;\r\nset_port_admin_status = __set_port_admin_status;\r\nfor (i = 0; i < RX_BUF_COUNT; i++) {\r\nvoid *buf;\r\nbuf = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (buf == NULL) {\r\nerr = -ENOMEM;\r\nwhile (--i >= 0)\r\nfree_page((unsigned long)phys_to_virt(rx_desc[i].buf_addr));\r\ngoto err_out;\r\n}\r\nrx_desc[i].buf_addr = virt_to_phys(buf);\r\nrx_desc[i].buf_length = PAGE_SIZE;\r\n}\r\nfor (i = 0; i < TX_BUF_COUNT; i++) {\r\nvoid *buf;\r\nbuf = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (buf == NULL) {\r\nerr = -ENOMEM;\r\nwhile (--i >= 0)\r\nfree_page((unsigned long)phys_to_virt(tx_desc[i].buf_addr));\r\ngoto err_free_rx;\r\n}\r\ntx_desc[i].buf_addr = virt_to_phys(buf);\r\n}\r\nixp2000_reg_write(RING_RX_PENDING_BASE, 0x44000000);\r\nixp2000_reg_write(RING_RX_PENDING_HEAD, 0x00000000);\r\nixp2000_reg_write(RING_RX_PENDING_TAIL, 0x00000000);\r\nixp2000_reg_write(RING_RX_DONE_BASE, 0x40000400);\r\nixp2000_reg_write(RING_RX_DONE_HEAD, 0x00000000);\r\nixp2000_reg_write(RING_RX_DONE_TAIL, 0x00000000);\r\nfor (i = 0; i < RX_BUF_COUNT; i++) {\r\nixp2000_reg_write(RING_RX_PENDING,\r\nRX_BUF_DESC_BASE + (i * sizeof(struct ixpdev_rx_desc)));\r\n}\r\nixp2000_uengine_load(0, &ixp2400_rx);\r\nixp2000_uengine_start_contexts(0, 0xff);\r\nixp2000_reg_write(RING_TX_PENDING_BASE, 0x44000800);\r\nixp2000_reg_write(RING_TX_PENDING_HEAD, 0x00000000);\r\nixp2000_reg_write(RING_TX_PENDING_TAIL, 0x00000000);\r\nixp2000_reg_write(RING_TX_DONE_BASE, 0x40000c00);\r\nixp2000_reg_write(RING_TX_DONE_HEAD, 0x00000000);\r\nixp2000_reg_write(RING_TX_DONE_TAIL, 0x00000000);\r\nixp2000_uengine_load(1, &ixp2400_tx);\r\nixp2000_uengine_start_contexts(1, 0xff);\r\nfor (i = 0; i < nds_count; i++) {\r\nerr = register_netdev(nds[i]);\r\nif (err) {\r\nwhile (--i >= 0)\r\nunregister_netdev(nds[i]);\r\ngoto err_free_tx;\r\n}\r\n}\r\nfor (i = 0; i < nds_count; i++) {\r\nprintk(KERN_INFO "%s: IXP2000 MSF ethernet (port %d), "\r\n"%.2x:%.2x:%.2x:%.2x:%.2x:%.2x.\n", nds[i]->name, i,\r\nnds[i]->dev_addr[0], nds[i]->dev_addr[1],\r\nnds[i]->dev_addr[2], nds[i]->dev_addr[3],\r\nnds[i]->dev_addr[4], nds[i]->dev_addr[5]);\r\n}\r\nreturn 0;\r\nerr_free_tx:\r\nfor (i = 0; i < TX_BUF_COUNT; i++)\r\nfree_page((unsigned long)phys_to_virt(tx_desc[i].buf_addr));\r\nerr_free_rx:\r\nfor (i = 0; i < RX_BUF_COUNT; i++)\r\nfree_page((unsigned long)phys_to_virt(rx_desc[i].buf_addr));\r\nerr_out:\r\nreturn err;\r\n}\r\nvoid ixpdev_deinit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < nds_count; i++)\r\nunregister_netdev(nds[i]);\r\nixp2000_uengine_stop_contexts(1, 0xff);\r\nixp2000_uengine_stop_contexts(0, 0xff);\r\nixp2000_uengine_reset(0x3);\r\nfor (i = 0; i < TX_BUF_COUNT; i++)\r\nfree_page((unsigned long)phys_to_virt(tx_desc[i].buf_addr));\r\nfor (i = 0; i < RX_BUF_COUNT; i++)\r\nfree_page((unsigned long)phys_to_virt(rx_desc[i].buf_addr));\r\n}
