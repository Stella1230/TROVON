static struct cache_index_dir *kobj_to_cache_index_dir(struct kobject *k)\r\n{\r\nreturn container_of(k, struct cache_index_dir, kobj);\r\n}\r\nstatic const char *cache_type_string(const struct cache *cache)\r\n{\r\nreturn cache_type_info[cache->type].name;\r\n}\r\nstatic void __cpuinit cache_init(struct cache *cache, int type, int level, struct device_node *ofnode)\r\n{\r\ncache->type = type;\r\ncache->level = level;\r\ncache->ofnode = of_node_get(ofnode);\r\nINIT_LIST_HEAD(&cache->list);\r\nlist_add(&cache->list, &cache_list);\r\n}\r\nstatic struct cache *__cpuinit new_cache(int type, int level, struct device_node *ofnode)\r\n{\r\nstruct cache *cache;\r\ncache = kzalloc(sizeof(*cache), GFP_KERNEL);\r\nif (cache)\r\ncache_init(cache, type, level, ofnode);\r\nreturn cache;\r\n}\r\nstatic void release_cache_debugcheck(struct cache *cache)\r\n{\r\nstruct cache *iter;\r\nlist_for_each_entry(iter, &cache_list, list)\r\nWARN_ONCE(iter->next_local == cache,\r\n"cache for %s(%s) refers to cache for %s(%s)\n",\r\niter->ofnode->full_name,\r\ncache_type_string(iter),\r\ncache->ofnode->full_name,\r\ncache_type_string(cache));\r\n}\r\nstatic void release_cache(struct cache *cache)\r\n{\r\nif (!cache)\r\nreturn;\r\npr_debug("freeing L%d %s cache for %s\n", cache->level,\r\ncache_type_string(cache), cache->ofnode->full_name);\r\nrelease_cache_debugcheck(cache);\r\nlist_del(&cache->list);\r\nof_node_put(cache->ofnode);\r\nkfree(cache);\r\n}\r\nstatic void cache_cpu_set(struct cache *cache, int cpu)\r\n{\r\nstruct cache *next = cache;\r\nwhile (next) {\r\nWARN_ONCE(cpumask_test_cpu(cpu, &next->shared_cpu_map),\r\n"CPU %i already accounted in %s(%s)\n",\r\ncpu, next->ofnode->full_name,\r\ncache_type_string(next));\r\ncpumask_set_cpu(cpu, &next->shared_cpu_map);\r\nnext = next->next_local;\r\n}\r\n}\r\nstatic int cache_size(const struct cache *cache, unsigned int *ret)\r\n{\r\nconst char *propname;\r\nconst u32 *cache_size;\r\npropname = cache_type_info[cache->type].size_prop;\r\ncache_size = of_get_property(cache->ofnode, propname, NULL);\r\nif (!cache_size)\r\nreturn -ENODEV;\r\n*ret = *cache_size;\r\nreturn 0;\r\n}\r\nstatic int cache_size_kb(const struct cache *cache, unsigned int *ret)\r\n{\r\nunsigned int size;\r\nif (cache_size(cache, &size))\r\nreturn -ENODEV;\r\n*ret = size / 1024;\r\nreturn 0;\r\n}\r\nstatic int cache_get_line_size(const struct cache *cache, unsigned int *ret)\r\n{\r\nconst u32 *line_size;\r\nint i, lim;\r\nlim = ARRAY_SIZE(cache_type_info[cache->type].line_size_props);\r\nfor (i = 0; i < lim; i++) {\r\nconst char *propname;\r\npropname = cache_type_info[cache->type].line_size_props[i];\r\nline_size = of_get_property(cache->ofnode, propname, NULL);\r\nif (line_size)\r\nbreak;\r\n}\r\nif (!line_size)\r\nreturn -ENODEV;\r\n*ret = *line_size;\r\nreturn 0;\r\n}\r\nstatic int cache_nr_sets(const struct cache *cache, unsigned int *ret)\r\n{\r\nconst char *propname;\r\nconst u32 *nr_sets;\r\npropname = cache_type_info[cache->type].nr_sets_prop;\r\nnr_sets = of_get_property(cache->ofnode, propname, NULL);\r\nif (!nr_sets)\r\nreturn -ENODEV;\r\n*ret = *nr_sets;\r\nreturn 0;\r\n}\r\nstatic int cache_associativity(const struct cache *cache, unsigned int *ret)\r\n{\r\nunsigned int line_size;\r\nunsigned int nr_sets;\r\nunsigned int size;\r\nif (cache_nr_sets(cache, &nr_sets))\r\ngoto err;\r\nif (nr_sets == 1) {\r\n*ret = 0;\r\nreturn 0;\r\n}\r\nif (cache_get_line_size(cache, &line_size))\r\ngoto err;\r\nif (cache_size(cache, &size))\r\ngoto err;\r\nif (!(nr_sets > 0 && size > 0 && line_size > 0))\r\ngoto err;\r\n*ret = (size / nr_sets) / line_size;\r\nreturn 0;\r\nerr:\r\nreturn -ENODEV;\r\n}\r\nstatic struct cache *cache_find_first_sibling(struct cache *cache)\r\n{\r\nstruct cache *iter;\r\nif (cache->type == CACHE_TYPE_UNIFIED)\r\nreturn cache;\r\nlist_for_each_entry(iter, &cache_list, list)\r\nif (iter->ofnode == cache->ofnode && iter->next_local == cache)\r\nreturn iter;\r\nreturn cache;\r\n}\r\nstatic struct cache *cache_lookup_by_node(const struct device_node *node)\r\n{\r\nstruct cache *cache = NULL;\r\nstruct cache *iter;\r\nlist_for_each_entry(iter, &cache_list, list) {\r\nif (iter->ofnode != node)\r\ncontinue;\r\ncache = cache_find_first_sibling(iter);\r\nbreak;\r\n}\r\nreturn cache;\r\n}\r\nstatic bool cache_node_is_unified(const struct device_node *np)\r\n{\r\nreturn of_get_property(np, "cache-unified", NULL);\r\n}\r\nstatic struct cache *__cpuinit cache_do_one_devnode_unified(struct device_node *node, int level)\r\n{\r\nstruct cache *cache;\r\npr_debug("creating L%d ucache for %s\n", level, node->full_name);\r\ncache = new_cache(CACHE_TYPE_UNIFIED, level, node);\r\nreturn cache;\r\n}\r\nstatic struct cache *__cpuinit cache_do_one_devnode_split(struct device_node *node, int level)\r\n{\r\nstruct cache *dcache, *icache;\r\npr_debug("creating L%d dcache and icache for %s\n", level,\r\nnode->full_name);\r\ndcache = new_cache(CACHE_TYPE_DATA, level, node);\r\nicache = new_cache(CACHE_TYPE_INSTRUCTION, level, node);\r\nif (!dcache || !icache)\r\ngoto err;\r\ndcache->next_local = icache;\r\nreturn dcache;\r\nerr:\r\nrelease_cache(dcache);\r\nrelease_cache(icache);\r\nreturn NULL;\r\n}\r\nstatic struct cache *__cpuinit cache_do_one_devnode(struct device_node *node, int level)\r\n{\r\nstruct cache *cache;\r\nif (cache_node_is_unified(node))\r\ncache = cache_do_one_devnode_unified(node, level);\r\nelse\r\ncache = cache_do_one_devnode_split(node, level);\r\nreturn cache;\r\n}\r\nstatic struct cache *__cpuinit cache_lookup_or_instantiate(struct device_node *node, int level)\r\n{\r\nstruct cache *cache;\r\ncache = cache_lookup_by_node(node);\r\nWARN_ONCE(cache && cache->level != level,\r\n"cache level mismatch on lookup (got %d, expected %d)\n",\r\ncache->level, level);\r\nif (!cache)\r\ncache = cache_do_one_devnode(node, level);\r\nreturn cache;\r\n}\r\nstatic void __cpuinit link_cache_lists(struct cache *smaller, struct cache *bigger)\r\n{\r\nwhile (smaller->next_local) {\r\nif (smaller->next_local == bigger)\r\nreturn;\r\nsmaller = smaller->next_local;\r\n}\r\nsmaller->next_local = bigger;\r\n}\r\nstatic void __cpuinit do_subsidiary_caches_debugcheck(struct cache *cache)\r\n{\r\nWARN_ON_ONCE(cache->level != 1);\r\nWARN_ON_ONCE(strcmp(cache->ofnode->type, "cpu"));\r\n}\r\nstatic void __cpuinit do_subsidiary_caches(struct cache *cache)\r\n{\r\nstruct device_node *subcache_node;\r\nint level = cache->level;\r\ndo_subsidiary_caches_debugcheck(cache);\r\nwhile ((subcache_node = of_find_next_cache_node(cache->ofnode))) {\r\nstruct cache *subcache;\r\nlevel++;\r\nsubcache = cache_lookup_or_instantiate(subcache_node, level);\r\nof_node_put(subcache_node);\r\nif (!subcache)\r\nbreak;\r\nlink_cache_lists(cache, subcache);\r\ncache = subcache;\r\n}\r\n}\r\nstatic struct cache *__cpuinit cache_chain_instantiate(unsigned int cpu_id)\r\n{\r\nstruct device_node *cpu_node;\r\nstruct cache *cpu_cache = NULL;\r\npr_debug("creating cache object(s) for CPU %i\n", cpu_id);\r\ncpu_node = of_get_cpu_node(cpu_id, NULL);\r\nWARN_ONCE(!cpu_node, "no OF node found for CPU %i\n", cpu_id);\r\nif (!cpu_node)\r\ngoto out;\r\ncpu_cache = cache_lookup_or_instantiate(cpu_node, 1);\r\nif (!cpu_cache)\r\ngoto out;\r\ndo_subsidiary_caches(cpu_cache);\r\ncache_cpu_set(cpu_cache, cpu_id);\r\nout:\r\nof_node_put(cpu_node);\r\nreturn cpu_cache;\r\n}\r\nstatic struct cache_dir *__cpuinit cacheinfo_create_cache_dir(unsigned int cpu_id)\r\n{\r\nstruct cache_dir *cache_dir;\r\nstruct sys_device *sysdev;\r\nstruct kobject *kobj = NULL;\r\nsysdev = get_cpu_sysdev(cpu_id);\r\nWARN_ONCE(!sysdev, "no sysdev for CPU %i\n", cpu_id);\r\nif (!sysdev)\r\ngoto err;\r\nkobj = kobject_create_and_add("cache", &sysdev->kobj);\r\nif (!kobj)\r\ngoto err;\r\ncache_dir = kzalloc(sizeof(*cache_dir), GFP_KERNEL);\r\nif (!cache_dir)\r\ngoto err;\r\ncache_dir->kobj = kobj;\r\nWARN_ON_ONCE(per_cpu(cache_dir_pcpu, cpu_id) != NULL);\r\nper_cpu(cache_dir_pcpu, cpu_id) = cache_dir;\r\nreturn cache_dir;\r\nerr:\r\nkobject_put(kobj);\r\nreturn NULL;\r\n}\r\nstatic void cache_index_release(struct kobject *kobj)\r\n{\r\nstruct cache_index_dir *index;\r\nindex = kobj_to_cache_index_dir(kobj);\r\npr_debug("freeing index directory for L%d %s cache\n",\r\nindex->cache->level, cache_type_string(index->cache));\r\nkfree(index);\r\n}\r\nstatic ssize_t cache_index_show(struct kobject *k, struct attribute *attr, char *buf)\r\n{\r\nstruct kobj_attribute *kobj_attr;\r\nkobj_attr = container_of(attr, struct kobj_attribute, attr);\r\nreturn kobj_attr->show(k, kobj_attr, buf);\r\n}\r\nstatic struct cache *index_kobj_to_cache(struct kobject *k)\r\n{\r\nstruct cache_index_dir *index;\r\nindex = kobj_to_cache_index_dir(k);\r\nreturn index->cache;\r\n}\r\nstatic ssize_t size_show(struct kobject *k, struct kobj_attribute *attr, char *buf)\r\n{\r\nunsigned int size_kb;\r\nstruct cache *cache;\r\ncache = index_kobj_to_cache(k);\r\nif (cache_size_kb(cache, &size_kb))\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%uK\n", size_kb);\r\n}\r\nstatic ssize_t line_size_show(struct kobject *k, struct kobj_attribute *attr, char *buf)\r\n{\r\nunsigned int line_size;\r\nstruct cache *cache;\r\ncache = index_kobj_to_cache(k);\r\nif (cache_get_line_size(cache, &line_size))\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%u\n", line_size);\r\n}\r\nstatic ssize_t nr_sets_show(struct kobject *k, struct kobj_attribute *attr, char *buf)\r\n{\r\nunsigned int nr_sets;\r\nstruct cache *cache;\r\ncache = index_kobj_to_cache(k);\r\nif (cache_nr_sets(cache, &nr_sets))\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%u\n", nr_sets);\r\n}\r\nstatic ssize_t associativity_show(struct kobject *k, struct kobj_attribute *attr, char *buf)\r\n{\r\nunsigned int associativity;\r\nstruct cache *cache;\r\ncache = index_kobj_to_cache(k);\r\nif (cache_associativity(cache, &associativity))\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%u\n", associativity);\r\n}\r\nstatic ssize_t type_show(struct kobject *k, struct kobj_attribute *attr, char *buf)\r\n{\r\nstruct cache *cache;\r\ncache = index_kobj_to_cache(k);\r\nreturn sprintf(buf, "%s\n", cache_type_string(cache));\r\n}\r\nstatic ssize_t level_show(struct kobject *k, struct kobj_attribute *attr, char *buf)\r\n{\r\nstruct cache_index_dir *index;\r\nstruct cache *cache;\r\nindex = kobj_to_cache_index_dir(k);\r\ncache = index->cache;\r\nreturn sprintf(buf, "%d\n", cache->level);\r\n}\r\nstatic ssize_t shared_cpu_map_show(struct kobject *k, struct kobj_attribute *attr, char *buf)\r\n{\r\nstruct cache_index_dir *index;\r\nstruct cache *cache;\r\nint len;\r\nint n = 0;\r\nindex = kobj_to_cache_index_dir(k);\r\ncache = index->cache;\r\nlen = PAGE_SIZE - 2;\r\nif (len > 1) {\r\nn = cpumask_scnprintf(buf, len, &cache->shared_cpu_map);\r\nbuf[n++] = '\n';\r\nbuf[n] = '\0';\r\n}\r\nreturn n;\r\n}\r\nstatic void __cpuinit cacheinfo_create_index_opt_attrs(struct cache_index_dir *dir)\r\n{\r\nconst char *cache_name;\r\nconst char *cache_type;\r\nstruct cache *cache;\r\nchar *buf;\r\nint i;\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\ncache = dir->cache;\r\ncache_name = cache->ofnode->full_name;\r\ncache_type = cache_type_string(cache);\r\nfor (i = 0; i < ARRAY_SIZE(cache_index_opt_attrs); i++) {\r\nstruct kobj_attribute *attr;\r\nssize_t rc;\r\nattr = cache_index_opt_attrs[i];\r\nrc = attr->show(&dir->kobj, attr, buf);\r\nif (rc <= 0) {\r\npr_debug("not creating %s attribute for "\r\n"%s(%s) (rc = %zd)\n",\r\nattr->attr.name, cache_name,\r\ncache_type, rc);\r\ncontinue;\r\n}\r\nif (sysfs_create_file(&dir->kobj, &attr->attr))\r\npr_debug("could not create %s attribute for %s(%s)\n",\r\nattr->attr.name, cache_name, cache_type);\r\n}\r\nkfree(buf);\r\n}\r\nstatic void __cpuinit cacheinfo_create_index_dir(struct cache *cache, int index, struct cache_dir *cache_dir)\r\n{\r\nstruct cache_index_dir *index_dir;\r\nint rc;\r\nindex_dir = kzalloc(sizeof(*index_dir), GFP_KERNEL);\r\nif (!index_dir)\r\ngoto err;\r\nindex_dir->cache = cache;\r\nrc = kobject_init_and_add(&index_dir->kobj, &cache_index_type,\r\ncache_dir->kobj, "index%d", index);\r\nif (rc)\r\ngoto err;\r\nindex_dir->next = cache_dir->index;\r\ncache_dir->index = index_dir;\r\ncacheinfo_create_index_opt_attrs(index_dir);\r\nreturn;\r\nerr:\r\nkfree(index_dir);\r\n}\r\nstatic void __cpuinit cacheinfo_sysfs_populate(unsigned int cpu_id, struct cache *cache_list)\r\n{\r\nstruct cache_dir *cache_dir;\r\nstruct cache *cache;\r\nint index = 0;\r\ncache_dir = cacheinfo_create_cache_dir(cpu_id);\r\nif (!cache_dir)\r\nreturn;\r\ncache = cache_list;\r\nwhile (cache) {\r\ncacheinfo_create_index_dir(cache, index, cache_dir);\r\nindex++;\r\ncache = cache->next_local;\r\n}\r\n}\r\nvoid __cpuinit cacheinfo_cpu_online(unsigned int cpu_id)\r\n{\r\nstruct cache *cache;\r\ncache = cache_chain_instantiate(cpu_id);\r\nif (!cache)\r\nreturn;\r\ncacheinfo_sysfs_populate(cpu_id, cache);\r\n}\r\nstatic struct cache *cache_lookup_by_cpu(unsigned int cpu_id)\r\n{\r\nstruct device_node *cpu_node;\r\nstruct cache *cache;\r\ncpu_node = of_get_cpu_node(cpu_id, NULL);\r\nWARN_ONCE(!cpu_node, "no OF node found for CPU %i\n", cpu_id);\r\nif (!cpu_node)\r\nreturn NULL;\r\ncache = cache_lookup_by_node(cpu_node);\r\nof_node_put(cpu_node);\r\nreturn cache;\r\n}\r\nstatic void remove_index_dirs(struct cache_dir *cache_dir)\r\n{\r\nstruct cache_index_dir *index;\r\nindex = cache_dir->index;\r\nwhile (index) {\r\nstruct cache_index_dir *next;\r\nnext = index->next;\r\nkobject_put(&index->kobj);\r\nindex = next;\r\n}\r\n}\r\nstatic void remove_cache_dir(struct cache_dir *cache_dir)\r\n{\r\nremove_index_dirs(cache_dir);\r\nkobject_put(cache_dir->kobj);\r\nkfree(cache_dir);\r\n}\r\nstatic void cache_cpu_clear(struct cache *cache, int cpu)\r\n{\r\nwhile (cache) {\r\nstruct cache *next = cache->next_local;\r\nWARN_ONCE(!cpumask_test_cpu(cpu, &cache->shared_cpu_map),\r\n"CPU %i not accounted in %s(%s)\n",\r\ncpu, cache->ofnode->full_name,\r\ncache_type_string(cache));\r\ncpumask_clear_cpu(cpu, &cache->shared_cpu_map);\r\nif (cpumask_empty(&cache->shared_cpu_map))\r\nrelease_cache(cache);\r\ncache = next;\r\n}\r\n}\r\nvoid cacheinfo_cpu_offline(unsigned int cpu_id)\r\n{\r\nstruct cache_dir *cache_dir;\r\nstruct cache *cache;\r\ncache_dir = per_cpu(cache_dir_pcpu, cpu_id);\r\nif (cache_dir)\r\nremove_cache_dir(cache_dir);\r\nper_cpu(cache_dir_pcpu, cpu_id) = NULL;\r\ncache = cache_lookup_by_cpu(cpu_id);\r\nif (cache)\r\ncache_cpu_clear(cache, cpu_id);\r\n}
