static inline long get_reg(struct task_struct *task, int regno)\r\n{\r\nunsigned long *addr;\r\nif (regno == PT_USP)\r\naddr = &task->thread.usp;\r\nelse if (regno < ARRAY_SIZE(regoff))\r\naddr = (unsigned long *)(task->thread.esp0 + regoff[regno]);\r\nelse\r\nreturn 0;\r\nif (regno == PT_SR || regno == PT_PC) {\r\nlong stkadj = *(long *)(task->thread.esp0 + PT_REG(stkadj));\r\naddr = (unsigned long *) ((unsigned long)addr + stkadj);\r\nif (regno == PT_SR)\r\nreturn *(unsigned short *)addr;\r\n}\r\nreturn *addr;\r\n}\r\nstatic inline int put_reg(struct task_struct *task, int regno,\r\nunsigned long data)\r\n{\r\nunsigned long *addr;\r\nif (regno == PT_USP)\r\naddr = &task->thread.usp;\r\nelse if (regno < ARRAY_SIZE(regoff))\r\naddr = (unsigned long *)(task->thread.esp0 + regoff[regno]);\r\nelse\r\nreturn -1;\r\nif (regno == PT_SR || regno == PT_PC) {\r\nlong stkadj = *(long *)(task->thread.esp0 + PT_REG(stkadj));\r\naddr = (unsigned long *) ((unsigned long)addr + stkadj);\r\nif (regno == PT_SR) {\r\n*(unsigned short *)addr = data;\r\nreturn 0;\r\n}\r\n}\r\n*addr = data;\r\nreturn 0;\r\n}\r\nstatic inline void singlestep_disable(struct task_struct *child)\r\n{\r\nunsigned long tmp = get_reg(child, PT_SR) & ~TRACE_BITS;\r\nput_reg(child, PT_SR, tmp);\r\nclear_tsk_thread_flag(child, TIF_DELAYED_TRACE);\r\n}\r\nvoid ptrace_disable(struct task_struct *child)\r\n{\r\nsinglestep_disable(child);\r\n}\r\nvoid user_enable_single_step(struct task_struct *child)\r\n{\r\nunsigned long tmp = get_reg(child, PT_SR) & ~TRACE_BITS;\r\nput_reg(child, PT_SR, tmp | T1_BIT);\r\nset_tsk_thread_flag(child, TIF_DELAYED_TRACE);\r\n}\r\nvoid user_enable_block_step(struct task_struct *child)\r\n{\r\nunsigned long tmp = get_reg(child, PT_SR) & ~TRACE_BITS;\r\nput_reg(child, PT_SR, tmp | T0_BIT);\r\n}\r\nvoid user_disable_single_step(struct task_struct *child)\r\n{\r\nsinglestep_disable(child);\r\n}\r\nlong arch_ptrace(struct task_struct *child, long request,\r\nunsigned long addr, unsigned long data)\r\n{\r\nunsigned long tmp;\r\nint i, ret = 0;\r\nint regno = addr >> 2;\r\nunsigned long __user *datap = (unsigned long __user *) data;\r\nswitch (request) {\r\ncase PTRACE_PEEKUSR:\r\nif (addr & 3)\r\ngoto out_eio;\r\nif (regno >= 0 && regno < 19) {\r\ntmp = get_reg(child, regno);\r\n} else if (regno >= 21 && regno < 49) {\r\ntmp = child->thread.fp[regno - 21];\r\nif (FPU_IS_EMU && (regno < 45) && !(regno % 3))\r\ntmp = ((tmp & 0xffff0000) << 15) |\r\n((tmp & 0x0000ffff) << 16);\r\n} else\r\ngoto out_eio;\r\nret = put_user(tmp, datap);\r\nbreak;\r\ncase PTRACE_POKEUSR:\r\nif (addr & 3)\r\ngoto out_eio;\r\nif (regno == PT_SR) {\r\ndata &= SR_MASK;\r\ndata |= get_reg(child, PT_SR) & ~SR_MASK;\r\n}\r\nif (regno >= 0 && regno < 19) {\r\nif (put_reg(child, regno, data))\r\ngoto out_eio;\r\n} else if (regno >= 21 && regno < 48) {\r\nif (FPU_IS_EMU && (regno < 45) && !(regno % 3)) {\r\ndata <<= 15;\r\ndata = (data & 0xffff0000) |\r\n((data & 0x0000ffff) >> 1);\r\n}\r\nchild->thread.fp[regno - 21] = data;\r\n} else\r\ngoto out_eio;\r\nbreak;\r\ncase PTRACE_GETREGS:\r\nfor (i = 0; i < 19; i++) {\r\ntmp = get_reg(child, i);\r\nret = put_user(tmp, datap);\r\nif (ret)\r\nbreak;\r\ndatap++;\r\n}\r\nbreak;\r\ncase PTRACE_SETREGS:\r\nfor (i = 0; i < 19; i++) {\r\nret = get_user(tmp, datap);\r\nif (ret)\r\nbreak;\r\nif (i == PT_SR) {\r\ntmp &= SR_MASK;\r\ntmp |= get_reg(child, PT_SR) & ~SR_MASK;\r\n}\r\nput_reg(child, i, tmp);\r\ndatap++;\r\n}\r\nbreak;\r\ncase PTRACE_GETFPREGS:\r\nif (copy_to_user(datap, &child->thread.fp,\r\nsizeof(struct user_m68kfp_struct)))\r\nret = -EFAULT;\r\nbreak;\r\ncase PTRACE_SETFPREGS:\r\nif (copy_from_user(&child->thread.fp, datap,\r\nsizeof(struct user_m68kfp_struct)))\r\nret = -EFAULT;\r\nbreak;\r\ncase PTRACE_GET_THREAD_AREA:\r\nret = put_user(task_thread_info(child)->tp_value, datap);\r\nbreak;\r\ndefault:\r\nret = ptrace_request(child, request, addr, data);\r\nbreak;\r\n}\r\nreturn ret;\r\nout_eio:\r\nreturn -EIO;\r\n}\r\nasmlinkage void syscall_trace(void)\r\n{\r\nptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)\r\n? 0x80 : 0));\r\nif (current->exit_code) {\r\nsend_sig(current->exit_code, current, 1);\r\ncurrent->exit_code = 0;\r\n}\r\n}
