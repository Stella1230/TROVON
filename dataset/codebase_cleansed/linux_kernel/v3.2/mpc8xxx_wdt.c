static void mpc8xxx_wdt_keepalive(void)\r\n{\r\nspin_lock(&wdt_spinlock);\r\nout_be16(&wd_base->swsrr, 0x556c);\r\nout_be16(&wd_base->swsrr, 0xaa39);\r\nspin_unlock(&wdt_spinlock);\r\n}\r\nstatic void mpc8xxx_wdt_timer_ping(unsigned long arg)\r\n{\r\nmpc8xxx_wdt_keepalive();\r\nmod_timer(&wdt_timer, jiffies + HZ * timeout_sec / 2);\r\n}\r\nstatic void mpc8xxx_wdt_pr_warn(const char *msg)\r\n{\r\npr_crit("mpc8xxx_wdt: %s, expect the %s soon!\n", msg,\r\nreset ? "reset" : "machine check exception");\r\n}\r\nstatic ssize_t mpc8xxx_wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count)\r\nmpc8xxx_wdt_keepalive();\r\nreturn count;\r\n}\r\nstatic int mpc8xxx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nu32 tmp = SWCRR_SWEN;\r\nif (test_and_set_bit(0, &wdt_is_open))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nif (prescale)\r\ntmp |= SWCRR_SWPR;\r\nif (reset)\r\ntmp |= SWCRR_SWRI;\r\ntmp |= timeout << 16;\r\nout_be32(&wd_base->swcrr, tmp);\r\ndel_timer_sync(&wdt_timer);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int mpc8xxx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (!nowayout)\r\nmpc8xxx_wdt_timer_ping(0);\r\nelse\r\nmpc8xxx_wdt_pr_warn("watchdog closed");\r\nclear_bit(0, &wdt_is_open);\r\nreturn 0;\r\n}\r\nstatic long mpc8xxx_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING,\r\n.firmware_version = 1,\r\n.identity = "MPC8xxx",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nmpc8xxx_wdt_keepalive();\r\nreturn 0;\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout_sec, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int __devinit mpc8xxx_wdt_probe(struct platform_device *ofdev)\r\n{\r\nint ret;\r\nconst struct of_device_id *match;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct mpc8xxx_wdt_type *wdt_type;\r\nu32 freq = fsl_get_sys_freq();\r\nbool enabled;\r\nmatch = of_match_device(mpc8xxx_wdt_match, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nwdt_type = match->data;\r\nif (!freq || freq == -1)\r\nreturn -EINVAL;\r\nwd_base = of_iomap(np, 0);\r\nif (!wd_base)\r\nreturn -ENOMEM;\r\nenabled = in_be32(&wd_base->swcrr) & SWCRR_SWEN;\r\nif (!enabled && wdt_type->hw_enabled) {\r\npr_info("mpc8xxx_wdt: could not be enabled in software\n");\r\nret = -ENOSYS;\r\ngoto err_unmap;\r\n}\r\nif (prescale)\r\ntimeout_sec = (timeout * wdt_type->prescaler) / freq;\r\nelse\r\ntimeout_sec = timeout / freq;\r\n#ifdef MODULE\r\nret = mpc8xxx_wdt_init_late();\r\nif (ret)\r\ngoto err_unmap;\r\n#endif\r\npr_info("WDT driver for MPC8xxx initialized. mode:%s timeout=%d "\r\n"(%d seconds)\n", reset ? "reset" : "interrupt", timeout,\r\ntimeout_sec);\r\nif (enabled)\r\nmpc8xxx_wdt_timer_ping(0);\r\nreturn 0;\r\nerr_unmap:\r\niounmap(wd_base);\r\nwd_base = NULL;\r\nreturn ret;\r\n}\r\nstatic int __devexit mpc8xxx_wdt_remove(struct platform_device *ofdev)\r\n{\r\nmpc8xxx_wdt_pr_warn("watchdog removed");\r\ndel_timer_sync(&wdt_timer);\r\nmisc_deregister(&mpc8xxx_wdt_miscdev);\r\niounmap(wd_base);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_wdt_init_late(void)\r\n{\r\nint ret;\r\nif (!wd_base)\r\nreturn -ENODEV;\r\nret = misc_register(&mpc8xxx_wdt_miscdev);\r\nif (ret) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mpc8xxx_wdt_init(void)\r\n{\r\nreturn platform_driver_register(&mpc8xxx_wdt_driver);\r\n}\r\nstatic void __exit mpc8xxx_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&mpc8xxx_wdt_driver);\r\n}
