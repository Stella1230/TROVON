static char *\r\nsetup_token(struct krb5_ctx *ctx, struct xdr_netobj *token)\r\n{\r\n__be16 *ptr, *krb5_hdr;\r\nint body_size = GSS_KRB5_TOK_HDR_LEN + ctx->gk5e->cksumlength;\r\ntoken->len = g_token_size(&ctx->mech_used, body_size);\r\nptr = (__be16 *)token->data;\r\ng_make_token_header(&ctx->mech_used, body_size, (unsigned char **)&ptr);\r\nkrb5_hdr = ptr;\r\n*ptr++ = KG_TOK_MIC_MSG;\r\n*ptr++ = cpu_to_le16(ctx->gk5e->signalg);\r\n*ptr++ = SEAL_ALG_NONE;\r\n*ptr++ = 0xffff;\r\nreturn (char *)krb5_hdr;\r\n}\r\nstatic void *\r\nsetup_token_v2(struct krb5_ctx *ctx, struct xdr_netobj *token)\r\n{\r\n__be16 *ptr, *krb5_hdr;\r\nu8 *p, flags = 0x00;\r\nif ((ctx->flags & KRB5_CTX_FLAG_INITIATOR) == 0)\r\nflags |= 0x01;\r\nif (ctx->flags & KRB5_CTX_FLAG_ACCEPTOR_SUBKEY)\r\nflags |= 0x04;\r\nkrb5_hdr = ptr = (__be16 *)token->data;\r\n*ptr++ = KG2_TOK_MIC;\r\np = (u8 *)ptr;\r\n*p++ = flags;\r\n*p++ = 0xff;\r\nptr = (__be16 *)p;\r\n*ptr++ = 0xffff;\r\n*ptr++ = 0xffff;\r\ntoken->len = GSS_KRB5_TOK_HDR_LEN + ctx->gk5e->cksumlength;\r\nreturn krb5_hdr;\r\n}\r\nstatic u32\r\ngss_get_mic_v1(struct krb5_ctx *ctx, struct xdr_buf *text,\r\nstruct xdr_netobj *token)\r\n{\r\nchar cksumdata[GSS_KRB5_MAX_CKSUM_LEN];\r\nstruct xdr_netobj md5cksum = {.len = sizeof(cksumdata),\r\n.data = cksumdata};\r\nvoid *ptr;\r\ns32 now;\r\nu32 seq_send;\r\nu8 *cksumkey;\r\ndprintk("RPC: %s\n", __func__);\r\nBUG_ON(ctx == NULL);\r\nnow = get_seconds();\r\nptr = setup_token(ctx, token);\r\nif (ctx->gk5e->keyed_cksum)\r\ncksumkey = ctx->cksum;\r\nelse\r\ncksumkey = NULL;\r\nif (make_checksum(ctx, ptr, 8, text, 0, cksumkey,\r\nKG_USAGE_SIGN, &md5cksum))\r\nreturn GSS_S_FAILURE;\r\nmemcpy(ptr + GSS_KRB5_TOK_HDR_LEN, md5cksum.data, md5cksum.len);\r\nspin_lock(&krb5_seq_lock);\r\nseq_send = ctx->seq_send++;\r\nspin_unlock(&krb5_seq_lock);\r\nif (krb5_make_seq_num(ctx, ctx->seq, ctx->initiate ? 0 : 0xff,\r\nseq_send, ptr + GSS_KRB5_TOK_HDR_LEN, ptr + 8))\r\nreturn GSS_S_FAILURE;\r\nreturn (ctx->endtime < now) ? GSS_S_CONTEXT_EXPIRED : GSS_S_COMPLETE;\r\n}\r\nu32\r\ngss_get_mic_v2(struct krb5_ctx *ctx, struct xdr_buf *text,\r\nstruct xdr_netobj *token)\r\n{\r\nchar cksumdata[GSS_KRB5_MAX_CKSUM_LEN];\r\nstruct xdr_netobj cksumobj = { .len = sizeof(cksumdata),\r\n.data = cksumdata};\r\nvoid *krb5_hdr;\r\ns32 now;\r\nu64 seq_send;\r\nu8 *cksumkey;\r\nunsigned int cksum_usage;\r\ndprintk("RPC: %s\n", __func__);\r\nkrb5_hdr = setup_token_v2(ctx, token);\r\nspin_lock(&krb5_seq_lock);\r\nseq_send = ctx->seq_send64++;\r\nspin_unlock(&krb5_seq_lock);\r\n*((u64 *)(krb5_hdr + 8)) = cpu_to_be64(seq_send);\r\nif (ctx->initiate) {\r\ncksumkey = ctx->initiator_sign;\r\ncksum_usage = KG_USAGE_INITIATOR_SIGN;\r\n} else {\r\ncksumkey = ctx->acceptor_sign;\r\ncksum_usage = KG_USAGE_ACCEPTOR_SIGN;\r\n}\r\nif (make_checksum_v2(ctx, krb5_hdr, GSS_KRB5_TOK_HDR_LEN,\r\ntext, 0, cksumkey, cksum_usage, &cksumobj))\r\nreturn GSS_S_FAILURE;\r\nmemcpy(krb5_hdr + GSS_KRB5_TOK_HDR_LEN, cksumobj.data, cksumobj.len);\r\nnow = get_seconds();\r\nreturn (ctx->endtime < now) ? GSS_S_CONTEXT_EXPIRED : GSS_S_COMPLETE;\r\n}\r\nu32\r\ngss_get_mic_kerberos(struct gss_ctx *gss_ctx, struct xdr_buf *text,\r\nstruct xdr_netobj *token)\r\n{\r\nstruct krb5_ctx *ctx = gss_ctx->internal_ctx_id;\r\nswitch (ctx->enctype) {\r\ndefault:\r\nBUG();\r\ncase ENCTYPE_DES_CBC_RAW:\r\ncase ENCTYPE_DES3_CBC_RAW:\r\ncase ENCTYPE_ARCFOUR_HMAC:\r\nreturn gss_get_mic_v1(ctx, text, token);\r\ncase ENCTYPE_AES128_CTS_HMAC_SHA1_96:\r\ncase ENCTYPE_AES256_CTS_HMAC_SHA1_96:\r\nreturn gss_get_mic_v2(ctx, text, token);\r\n}\r\n}
