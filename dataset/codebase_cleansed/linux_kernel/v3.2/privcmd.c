static long privcmd_ioctl_hypercall(void __user *udata)\r\n{\r\nstruct privcmd_hypercall hypercall;\r\nlong ret;\r\nif (copy_from_user(&hypercall, udata, sizeof(hypercall)))\r\nreturn -EFAULT;\r\nret = privcmd_call(hypercall.op,\r\nhypercall.arg[0], hypercall.arg[1],\r\nhypercall.arg[2], hypercall.arg[3],\r\nhypercall.arg[4]);\r\nreturn ret;\r\n}\r\nstatic void free_page_list(struct list_head *pages)\r\n{\r\nstruct page *p, *n;\r\nlist_for_each_entry_safe(p, n, pages, lru)\r\n__free_page(p);\r\nINIT_LIST_HEAD(pages);\r\n}\r\nstatic int gather_array(struct list_head *pagelist,\r\nunsigned nelem, size_t size,\r\nvoid __user *data)\r\n{\r\nunsigned pageidx;\r\nvoid *pagedata;\r\nint ret;\r\nif (size > PAGE_SIZE)\r\nreturn 0;\r\npageidx = PAGE_SIZE;\r\npagedata = NULL;\r\nwhile (nelem--) {\r\nif (pageidx > PAGE_SIZE-size) {\r\nstruct page *page = alloc_page(GFP_KERNEL);\r\nret = -ENOMEM;\r\nif (page == NULL)\r\ngoto fail;\r\npagedata = page_address(page);\r\nlist_add_tail(&page->lru, pagelist);\r\npageidx = 0;\r\n}\r\nret = -EFAULT;\r\nif (copy_from_user(pagedata + pageidx, data, size))\r\ngoto fail;\r\ndata += size;\r\npageidx += size;\r\n}\r\nret = 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int traverse_pages(unsigned nelem, size_t size,\r\nstruct list_head *pos,\r\nint (*fn)(void *data, void *state),\r\nvoid *state)\r\n{\r\nvoid *pagedata;\r\nunsigned pageidx;\r\nint ret = 0;\r\nBUG_ON(size > PAGE_SIZE);\r\npageidx = PAGE_SIZE;\r\npagedata = NULL;\r\nwhile (nelem--) {\r\nif (pageidx > PAGE_SIZE-size) {\r\nstruct page *page;\r\npos = pos->next;\r\npage = list_entry(pos, struct page, lru);\r\npagedata = page_address(page);\r\npageidx = 0;\r\n}\r\nret = (*fn)(pagedata + pageidx, state);\r\nif (ret)\r\nbreak;\r\npageidx += size;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mmap_mfn_range(void *data, void *state)\r\n{\r\nstruct privcmd_mmap_entry *msg = data;\r\nstruct mmap_mfn_state *st = state;\r\nstruct vm_area_struct *vma = st->vma;\r\nint rc;\r\nif ((msg->npages > (LONG_MAX >> PAGE_SHIFT)) ||\r\n((unsigned long)(msg->npages << PAGE_SHIFT) >= -st->va))\r\nreturn -EINVAL;\r\nif ((msg->va != st->va) ||\r\n((msg->va+(msg->npages<<PAGE_SHIFT)) > vma->vm_end))\r\nreturn -EINVAL;\r\nrc = xen_remap_domain_mfn_range(vma,\r\nmsg->va & PAGE_MASK,\r\nmsg->mfn, msg->npages,\r\nvma->vm_page_prot,\r\nst->domain);\r\nif (rc < 0)\r\nreturn rc;\r\nst->va += msg->npages << PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic long privcmd_ioctl_mmap(void __user *udata)\r\n{\r\nstruct privcmd_mmap mmapcmd;\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nint rc;\r\nLIST_HEAD(pagelist);\r\nstruct mmap_mfn_state state;\r\nif (!xen_initial_domain())\r\nreturn -EPERM;\r\nif (copy_from_user(&mmapcmd, udata, sizeof(mmapcmd)))\r\nreturn -EFAULT;\r\nrc = gather_array(&pagelist,\r\nmmapcmd.num, sizeof(struct privcmd_mmap_entry),\r\nmmapcmd.entry);\r\nif (rc || list_empty(&pagelist))\r\ngoto out;\r\ndown_write(&mm->mmap_sem);\r\n{\r\nstruct page *page = list_first_entry(&pagelist,\r\nstruct page, lru);\r\nstruct privcmd_mmap_entry *msg = page_address(page);\r\nvma = find_vma(mm, msg->va);\r\nrc = -EINVAL;\r\nif (!vma || (msg->va != vma->vm_start) ||\r\n!privcmd_enforce_singleshot_mapping(vma))\r\ngoto out_up;\r\n}\r\nstate.va = vma->vm_start;\r\nstate.vma = vma;\r\nstate.domain = mmapcmd.dom;\r\nrc = traverse_pages(mmapcmd.num, sizeof(struct privcmd_mmap_entry),\r\n&pagelist,\r\nmmap_mfn_range, &state);\r\nout_up:\r\nup_write(&mm->mmap_sem);\r\nout:\r\nfree_page_list(&pagelist);\r\nreturn rc;\r\n}\r\nstatic int mmap_batch_fn(void *data, void *state)\r\n{\r\nxen_pfn_t *mfnp = data;\r\nstruct mmap_batch_state *st = state;\r\nif (xen_remap_domain_mfn_range(st->vma, st->va & PAGE_MASK, *mfnp, 1,\r\nst->vma->vm_page_prot, st->domain) < 0) {\r\n*mfnp |= 0xf0000000U;\r\nst->err++;\r\n}\r\nst->va += PAGE_SIZE;\r\nreturn 0;\r\n}\r\nstatic int mmap_return_errors(void *data, void *state)\r\n{\r\nxen_pfn_t *mfnp = data;\r\nstruct mmap_batch_state *st = state;\r\nreturn put_user(*mfnp, st->user++);\r\n}\r\nstatic long privcmd_ioctl_mmap_batch(void __user *udata)\r\n{\r\nint ret;\r\nstruct privcmd_mmapbatch m;\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nunsigned long nr_pages;\r\nLIST_HEAD(pagelist);\r\nstruct mmap_batch_state state;\r\nif (!xen_initial_domain())\r\nreturn -EPERM;\r\nif (copy_from_user(&m, udata, sizeof(m)))\r\nreturn -EFAULT;\r\nnr_pages = m.num;\r\nif ((m.num <= 0) || (nr_pages > (LONG_MAX >> PAGE_SHIFT)))\r\nreturn -EINVAL;\r\nret = gather_array(&pagelist, m.num, sizeof(xen_pfn_t),\r\nm.arr);\r\nif (ret || list_empty(&pagelist))\r\ngoto out;\r\ndown_write(&mm->mmap_sem);\r\nvma = find_vma(mm, m.addr);\r\nret = -EINVAL;\r\nif (!vma ||\r\nvma->vm_ops != &privcmd_vm_ops ||\r\n(m.addr != vma->vm_start) ||\r\n((m.addr + (nr_pages << PAGE_SHIFT)) != vma->vm_end) ||\r\n!privcmd_enforce_singleshot_mapping(vma)) {\r\nup_write(&mm->mmap_sem);\r\ngoto out;\r\n}\r\nstate.domain = m.dom;\r\nstate.vma = vma;\r\nstate.va = m.addr;\r\nstate.err = 0;\r\nret = traverse_pages(m.num, sizeof(xen_pfn_t),\r\n&pagelist, mmap_batch_fn, &state);\r\nup_write(&mm->mmap_sem);\r\nif (state.err > 0) {\r\nstate.user = m.arr;\r\nret = traverse_pages(m.num, sizeof(xen_pfn_t),\r\n&pagelist,\r\nmmap_return_errors, &state);\r\n}\r\nout:\r\nfree_page_list(&pagelist);\r\nreturn ret;\r\n}\r\nstatic long privcmd_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long data)\r\n{\r\nint ret = -ENOSYS;\r\nvoid __user *udata = (void __user *) data;\r\nswitch (cmd) {\r\ncase IOCTL_PRIVCMD_HYPERCALL:\r\nret = privcmd_ioctl_hypercall(udata);\r\nbreak;\r\ncase IOCTL_PRIVCMD_MMAP:\r\nret = privcmd_ioctl_mmap(udata);\r\nbreak;\r\ncase IOCTL_PRIVCMD_MMAPBATCH:\r\nret = privcmd_ioctl_mmap_batch(udata);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int privcmd_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nprintk(KERN_DEBUG "privcmd_fault: vma=%p %lx-%lx, pgoff=%lx, uv=%p\n",\r\nvma, vma->vm_start, vma->vm_end,\r\nvmf->pgoff, vmf->virtual_address);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nstatic int privcmd_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nif (xen_feature(XENFEAT_auto_translated_physmap))\r\nreturn -ENOSYS;\r\nvma->vm_flags |= VM_RESERVED | VM_IO | VM_DONTCOPY | VM_PFNMAP;\r\nvma->vm_ops = &privcmd_vm_ops;\r\nvma->vm_private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int privcmd_enforce_singleshot_mapping(struct vm_area_struct *vma)\r\n{\r\nreturn (xchg(&vma->vm_private_data, (void *)1) == NULL);\r\n}
