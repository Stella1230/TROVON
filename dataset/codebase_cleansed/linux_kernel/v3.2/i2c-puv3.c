static short poll_status(unsigned long bit)\r\n{\r\nint loop_cntr = 1000;\r\nif (bit & I2C_STATUS_TFNF) {\r\ndo {\r\nudelay(10);\r\n} while (!(readl(I2C_STATUS) & bit) && (--loop_cntr > 0));\r\n} else {\r\ndo {\r\nif (readl(I2C_TAR) == I2C_TAR_EEPROM)\r\nmsleep(20);\r\nelse\r\nudelay(10);\r\n} while (!(readl(I2C_RXFLR) & 0xf) && (--loop_cntr > 0));\r\n}\r\nreturn (loop_cntr > 0);\r\n}\r\nstatic int xfer_read(struct i2c_adapter *adap, unsigned char *buf, int length)\r\n{\r\nint i2c_reg = *buf;\r\nwhile (length--) {\r\nif (!poll_status(I2C_STATUS_TFNF)) {\r\ndev_dbg(&adap->dev, "Tx FIFO Not Full timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwritel(i2c_reg | I2C_DATACMD_WRITE, I2C_DATACMD);\r\ni2c_reg++;\r\nwritel(I2C_DATACMD_READ, I2C_DATACMD);\r\nif (!poll_status(I2C_STATUS_RFNE)) {\r\ndev_dbg(&adap->dev, "RXRDY timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n*buf = (readl(I2C_DATACMD) & I2C_DATACMD_DAT_MASK);\r\nbuf++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xfer_write(struct i2c_adapter *adap, unsigned char *buf, int length)\r\n{\r\nint i2c_reg = *buf;\r\nif (i2c_reg == -1) {\r\nprintk(KERN_WARNING "Error i2c reg\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (length == 1)\r\nreturn 0;\r\nbuf++;\r\nlength--;\r\nwhile (length--) {\r\nwritel(i2c_reg | I2C_DATACMD_WRITE, I2C_DATACMD);\r\nwritel(*buf | I2C_DATACMD_WRITE, I2C_DATACMD);\r\nmsleep(20);\r\ni2c_reg++;\r\nbuf++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int puv3_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *pmsg,\r\nint num)\r\n{\r\nint i, ret;\r\nunsigned char swap;\r\nwritel(I2C_ENABLE_DISABLE, I2C_ENABLE);\r\nwritel(I2C_CON_MASTER | I2C_CON_SPEED_STD | I2C_CON_SLAVEDISABLE, I2C_CON);\r\nwritel(pmsg->addr, I2C_TAR);\r\nwritel(I2C_ENABLE_ENABLE, I2C_ENABLE);\r\ndev_dbg(&adap->dev, "puv3_i2c_xfer: processing %d messages:\n", num);\r\nfor (i = 0; i < num; i++) {\r\ndev_dbg(&adap->dev, " #%d: %sing %d byte%s %s 0x%02x\n", i,\r\npmsg->flags & I2C_M_RD ? "read" : "writ",\r\npmsg->len, pmsg->len > 1 ? "s" : "",\r\npmsg->flags & I2C_M_RD ? "from" : "to", pmsg->addr);\r\nif (pmsg->len && pmsg->buf) {\r\nif (pmsg->flags & I2C_M_RD)\r\nret = xfer_read(adap, pmsg->buf, pmsg->len);\r\nelse\r\nret = xfer_write(adap, pmsg->buf, pmsg->len);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndev_dbg(&adap->dev, "transfer complete\n");\r\npmsg++;\r\n}\r\nif (pmsg->addr == I2C_TAR_PWIC) {\r\nswap = pmsg->buf[0];\r\npmsg->buf[0] = pmsg->buf[1];\r\npmsg->buf[1] = swap;\r\n}\r\nreturn i;\r\n}\r\nstatic u32 puv3_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int __devinit puv3_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_adapter *adapter;\r\nstruct resource *mem;\r\nint rc;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -ENODEV;\r\nif (!request_mem_region(mem->start, resource_size(mem), "puv3_i2c"))\r\nreturn -EBUSY;\r\nadapter = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);\r\nif (adapter == NULL) {\r\ndev_err(&pdev->dev, "can't allocate inteface!\n");\r\nrc = -ENOMEM;\r\ngoto fail_nomem;\r\n}\r\nsnprintf(adapter->name, sizeof(adapter->name), "PUV3-I2C at 0x%08x",\r\nmem->start);\r\nadapter->algo = &puv3_i2c_algorithm;\r\nadapter->class = I2C_CLASS_HWMON;\r\nadapter->dev.parent = &pdev->dev;\r\nplatform_set_drvdata(pdev, adapter);\r\nadapter->nr = pdev->id;\r\nrc = i2c_add_numbered_adapter(adapter);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Adapter '%s' registration failed\n",\r\nadapter->name);\r\ngoto fail_add_adapter;\r\n}\r\ndev_info(&pdev->dev, "PKUnity v3 i2c bus adapter.\n");\r\nreturn 0;\r\nfail_add_adapter:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(adapter);\r\nfail_nomem:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn rc;\r\n}\r\nstatic int __devexit puv3_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_adapter *adapter = platform_get_drvdata(pdev);\r\nstruct resource *mem;\r\nint rc;\r\nrc = i2c_del_adapter(adapter);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Adapter '%s' delete fail\n",\r\nadapter->name);\r\nreturn rc;\r\n}\r\nput_device(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn rc;\r\n}\r\nstatic int puv3_i2c_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nint poll_count;\r\nwritel(I2C_ENABLE_DISABLE, I2C_ENABLE);\r\nfor (poll_count = 0; poll_count < 50; poll_count++) {\r\nif (readl(I2C_ENSTATUS) & I2C_ENSTATUS_ENABLE)\r\nudelay(25);\r\n}\r\nreturn 0;\r\n}\r\nstatic int puv3_i2c_resume(struct platform_device *dev)\r\n{\r\nreturn 0 ;\r\n}\r\nstatic int __init puv3_i2c_init(void)\r\n{\r\nreturn platform_driver_register(&puv3_i2c_driver);\r\n}\r\nstatic void __exit puv3_i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&puv3_i2c_driver);\r\n}
