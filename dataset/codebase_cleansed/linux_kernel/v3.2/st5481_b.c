static inline void B_L1L2(struct st5481_bcs *bcs, int pr, void *arg)\r\n{\r\nstruct hisax_if *ifc = (struct hisax_if *) &bcs->b_if;\r\nifc->l1l2(ifc, pr, arg);\r\n}\r\nstatic void usb_b_out(struct st5481_bcs *bcs,int buf_nr)\r\n{\r\nstruct st5481_b_out *b_out = &bcs->b_out;\r\nstruct st5481_adapter *adapter = bcs->adapter;\r\nstruct urb *urb;\r\nunsigned int packet_size,offset;\r\nint len,buf_size,bytes_sent;\r\nint i;\r\nstruct sk_buff *skb;\r\nif (test_and_set_bit(buf_nr, &b_out->busy)) {\r\nDBG(4,"ep %d urb %d busy",(bcs->channel+1)*2,buf_nr);\r\nreturn;\r\n}\r\nurb = b_out->urb[buf_nr];\r\nif(b_out->flow_event & (OUT_DOWN | OUT_UNDERRUN)) {\r\nbuf_size = NUM_ISO_PACKETS_B*SIZE_ISO_PACKETS_B_OUT + B_FLOW_ADJUST;\r\npacket_size = SIZE_ISO_PACKETS_B_OUT + B_FLOW_ADJUST;\r\nDBG(4,"B%d,adjust flow,add %d bytes",bcs->channel+1,B_FLOW_ADJUST);\r\n} else if(b_out->flow_event & OUT_UP){\r\nbuf_size = NUM_ISO_PACKETS_B*SIZE_ISO_PACKETS_B_OUT - B_FLOW_ADJUST;\r\npacket_size = SIZE_ISO_PACKETS_B_OUT - B_FLOW_ADJUST;\r\nDBG(4,"B%d,adjust flow,remove %d bytes",bcs->channel+1,B_FLOW_ADJUST);\r\n} else {\r\nbuf_size = NUM_ISO_PACKETS_B*SIZE_ISO_PACKETS_B_OUT;\r\npacket_size = 8;\r\n}\r\nb_out->flow_event = 0;\r\nlen = 0;\r\nwhile (len < buf_size) {\r\nif ((skb = b_out->tx_skb)) {\r\nDBG_SKB(0x100, skb);\r\nDBG(4,"B%d,len=%d",bcs->channel+1,skb->len);\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nbytes_sent = buf_size - len;\r\nif (skb->len < bytes_sent)\r\nbytes_sent = skb->len;\r\n{\r\nregister unsigned char *src = skb->data;\r\nregister unsigned char *dest = urb->transfer_buffer+len;\r\nregister unsigned int count;\r\nfor (count = 0; count < bytes_sent; count++)\r\n*dest++ = bitrev8(*src++);\r\n}\r\nlen += bytes_sent;\r\n} else {\r\nlen += isdnhdlc_encode(&b_out->hdlc_state,\r\nskb->data, skb->len, &bytes_sent,\r\nurb->transfer_buffer+len, buf_size-len);\r\n}\r\nskb_pull(skb, bytes_sent);\r\nif (!skb->len) {\r\nb_out->tx_skb = NULL;\r\nB_L1L2(bcs, PH_DATA | CONFIRM, (void *)(unsigned long) skb->truesize);\r\ndev_kfree_skb_any(skb);\r\n}\r\n} else {\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nmemset(urb->transfer_buffer+len, 0xff, buf_size-len);\r\nlen = buf_size;\r\n} else {\r\nlen += isdnhdlc_encode(&b_out->hdlc_state,\r\nNULL, 0, &bytes_sent,\r\nurb->transfer_buffer+len, buf_size-len);\r\n}\r\n}\r\n}\r\nfor (i = 0, offset = 0; offset < len; i++) {\r\nurb->iso_frame_desc[i].offset = offset;\r\nurb->iso_frame_desc[i].length = packet_size;\r\noffset += packet_size;\r\npacket_size = SIZE_ISO_PACKETS_B_OUT;\r\n}\r\nurb->transfer_buffer_length = len;\r\nurb->number_of_packets = i;\r\nurb->dev = adapter->usb_dev;\r\nDBG_ISO_PACKET(0x200,urb);\r\nSUBMIT_URB(urb, GFP_NOIO);\r\n}\r\nstatic void st5481B_start_xfer(void *context)\r\n{\r\nstruct st5481_bcs *bcs = context;\r\nDBG(4,"B%d",bcs->channel+1);\r\nusb_b_out(bcs,0);\r\nusb_b_out(bcs,1);\r\n}\r\nstatic void led_blink(struct st5481_adapter *adapter)\r\n{\r\nu_char leds = adapter->leds;\r\nif (++adapter->led_counter % 50) {\r\nreturn;\r\n}\r\nif (adapter->led_counter % 100) {\r\nleds |= GREEN_LED;\r\n} else {\r\nleds &= ~GREEN_LED;\r\n}\r\nst5481_usb_device_ctrl_msg(adapter, GPIO_OUT, leds, NULL, NULL);\r\n}\r\nstatic void usb_b_out_complete(struct urb *urb)\r\n{\r\nstruct st5481_bcs *bcs = urb->context;\r\nstruct st5481_b_out *b_out = &bcs->b_out;\r\nstruct st5481_adapter *adapter = bcs->adapter;\r\nint buf_nr;\r\nbuf_nr = get_buf_nr(b_out->urb, urb);\r\ntest_and_clear_bit(buf_nr, &b_out->busy);\r\nif (unlikely(urb->status < 0)) {\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNRESET:\r\nDBG(4,"urb killed status %d", urb->status);\r\nreturn;\r\ndefault:\r\nWARNING("urb status %d",urb->status);\r\nif (b_out->busy == 0) {\r\nst5481_usb_pipe_reset(adapter, (bcs->channel+1)*2 | USB_DIR_OUT, NULL, NULL);\r\n}\r\nbreak;\r\n}\r\n}\r\nusb_b_out(bcs,buf_nr);\r\nif (adapter->number_of_leds == 2)\r\nled_blink(adapter);\r\n}\r\nstatic void st5481B_mode(struct st5481_bcs *bcs, int mode)\r\n{\r\nstruct st5481_b_out *b_out = &bcs->b_out;\r\nstruct st5481_adapter *adapter = bcs->adapter;\r\nDBG(4,"B%d,mode=%d", bcs->channel + 1, mode);\r\nif (bcs->mode == mode)\r\nreturn;\r\nbcs->mode = mode;\r\nusb_unlink_urb(b_out->urb[0]);\r\nusb_unlink_urb(b_out->urb[1]);\r\nb_out->busy = 0;\r\nst5481_in_mode(&bcs->b_in, mode);\r\nif (bcs->mode != L1_MODE_NULL) {\r\nif (bcs->mode != L1_MODE_TRANS) {\r\nu32 features = HDLC_BITREVERSE;\r\nif (bcs->mode == L1_MODE_HDLC_56K)\r\nfeatures |= HDLC_56KBIT;\r\nisdnhdlc_out_init(&b_out->hdlc_state, features);\r\n}\r\nst5481_usb_pipe_reset(adapter, (bcs->channel+1)*2, NULL, NULL);\r\nst5481_usb_device_ctrl_msg(adapter, FFMSK_B1+(bcs->channel*2),\r\nOUT_UP+OUT_DOWN+OUT_UNDERRUN, NULL, NULL);\r\nst5481_usb_device_ctrl_msg(adapter, OUT_B1_COUNTER+(bcs->channel*2), 32, st5481B_start_xfer, bcs);\r\nif (adapter->number_of_leds == 4) {\r\nif (bcs->channel == 0) {\r\nadapter->leds |= B1_LED;\r\n} else {\r\nadapter->leds |= B2_LED;\r\n}\r\n}\r\n} else {\r\nst5481_usb_device_ctrl_msg(adapter, FFMSK_B1+(bcs->channel*2), 0, NULL, NULL);\r\nst5481_usb_device_ctrl_msg(adapter, OUT_B1_COUNTER+(bcs->channel*2), 0, NULL, NULL);\r\nif (adapter->number_of_leds == 4) {\r\nif (bcs->channel == 0) {\r\nadapter->leds &= ~B1_LED;\r\n} else {\r\nadapter->leds &= ~B2_LED;\r\n}\r\n} else {\r\nst5481_usb_device_ctrl_msg(adapter, GPIO_OUT, adapter->leds, NULL, NULL);\r\n}\r\nif (b_out->tx_skb) {\r\ndev_kfree_skb_any(b_out->tx_skb);\r\nb_out->tx_skb = NULL;\r\n}\r\n}\r\n}\r\nstatic int st5481_setup_b_out(struct st5481_bcs *bcs)\r\n{\r\nstruct usb_device *dev = bcs->adapter->usb_dev;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *altsetting = NULL;\r\nstruct usb_host_endpoint *endpoint;\r\nstruct st5481_b_out *b_out = &bcs->b_out;\r\nDBG(4,"");\r\nintf = usb_ifnum_to_if(dev, 0);\r\nif (intf)\r\naltsetting = usb_altnum_to_altsetting(intf, 3);\r\nif (!altsetting)\r\nreturn -ENXIO;\r\nendpoint = &altsetting->endpoint[EP_B1_OUT - 1 + bcs->channel * 2];\r\nDBG(4,"endpoint address=%02x,packet size=%d",\r\nendpoint->desc.bEndpointAddress, le16_to_cpu(endpoint->desc.wMaxPacketSize));\r\nreturn st5481_setup_isocpipes(b_out->urb, dev,\r\nusb_sndisocpipe(dev, endpoint->desc.bEndpointAddress),\r\nNUM_ISO_PACKETS_B, SIZE_ISO_PACKETS_B_OUT,\r\nNUM_ISO_PACKETS_B * SIZE_ISO_PACKETS_B_OUT + B_FLOW_ADJUST,\r\nusb_b_out_complete, bcs);\r\n}\r\nstatic void st5481_release_b_out(struct st5481_bcs *bcs)\r\n{\r\nstruct st5481_b_out *b_out = &bcs->b_out;\r\nDBG(4,"");\r\nst5481_release_isocpipes(b_out->urb);\r\n}\r\nint st5481_setup_b(struct st5481_bcs *bcs)\r\n{\r\nint retval;\r\nDBG(4,"");\r\nretval = st5481_setup_b_out(bcs);\r\nif (retval)\r\ngoto err;\r\nbcs->b_in.bufsize = HSCX_BUFMAX;\r\nbcs->b_in.num_packets = NUM_ISO_PACKETS_B;\r\nbcs->b_in.packet_size = SIZE_ISO_PACKETS_B_IN;\r\nbcs->b_in.ep = (bcs->channel ? EP_B2_IN : EP_B1_IN) | USB_DIR_IN;\r\nbcs->b_in.counter = bcs->channel ? IN_B2_COUNTER : IN_B1_COUNTER;\r\nbcs->b_in.adapter = bcs->adapter;\r\nbcs->b_in.hisax_if = &bcs->b_if.ifc;\r\nretval = st5481_setup_in(&bcs->b_in);\r\nif (retval)\r\ngoto err_b_out;\r\nreturn 0;\r\nerr_b_out:\r\nst5481_release_b_out(bcs);\r\nerr:\r\nreturn retval;\r\n}\r\nvoid st5481_release_b(struct st5481_bcs *bcs)\r\n{\r\nDBG(4,"");\r\nst5481_release_in(&bcs->b_in);\r\nst5481_release_b_out(bcs);\r\n}\r\nvoid st5481_b_l2l1(struct hisax_if *ifc, int pr, void *arg)\r\n{\r\nstruct st5481_bcs *bcs = ifc->priv;\r\nstruct sk_buff *skb = arg;\r\nlong mode;\r\nDBG(4, "");\r\nswitch (pr) {\r\ncase PH_DATA | REQUEST:\r\nBUG_ON(bcs->b_out.tx_skb);\r\nbcs->b_out.tx_skb = skb;\r\nbreak;\r\ncase PH_ACTIVATE | REQUEST:\r\nmode = (long) arg;\r\nDBG(4,"B%d,PH_ACTIVATE_REQUEST %ld", bcs->channel + 1, mode);\r\nst5481B_mode(bcs, mode);\r\nB_L1L2(bcs, PH_ACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase PH_DEACTIVATE | REQUEST:\r\nDBG(4,"B%d,PH_DEACTIVATE_REQUEST", bcs->channel + 1);\r\nst5481B_mode(bcs, L1_MODE_NULL);\r\nB_L1L2(bcs, PH_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\ndefault:\r\nWARNING("pr %#x\n", pr);\r\n}\r\n}
