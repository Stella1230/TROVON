static int __init xd_init(void)\r\n{\r\nu_char i,controller;\r\nunsigned int address;\r\nint err;\r\n#ifdef MODULE\r\n{\r\nu_char count = 0;\r\nfor (i = 4; i > 0; i--)\r\nif (((xd[i] = xd[i-1]) >= 0) && !count)\r\ncount = i;\r\nif ((xd[0] = count))\r\ndo_xd_setup(xd);\r\n}\r\n#endif\r\ninit_timer (&xd_watchdog_int); xd_watchdog_int.function = xd_watchdog;\r\nerr = -EBUSY;\r\nif (register_blkdev(XT_DISK_MAJOR, "xd"))\r\ngoto out1;\r\nerr = -ENOMEM;\r\nxd_queue = blk_init_queue(do_xd_request, &xd_lock);\r\nif (!xd_queue)\r\ngoto out1a;\r\nif (xd_detect(&controller,&address)) {\r\nprintk("Detected a%s controller (type %d) at address %06x\n",\r\nxd_sigs[controller].name,controller,address);\r\nif (!request_region(xd_iobase,4,"xd")) {\r\nprintk("xd: Ports at 0x%x are not available\n",\r\nxd_iobase);\r\ngoto out2;\r\n}\r\nif (controller)\r\nxd_sigs[controller].init_controller(address);\r\nxd_drives = xd_initdrives(xd_sigs[controller].init_drive);\r\nprintk("Detected %d hard drive%s (using IRQ%d & DMA%d)\n",\r\nxd_drives,xd_drives == 1 ? "" : "s",xd_irq,xd_dma);\r\n}\r\nif (!xd_dma_buffer && xd_maxsectors) {\r\nxd_dma_buffer = (char *)xd_dma_mem_alloc(xd_maxsectors * 0x200);\r\nif (!xd_dma_buffer) {\r\nprintk(KERN_ERR "xd: Out of memory.\n");\r\ngoto out3;\r\n}\r\n}\r\nerr = -ENODEV;\r\nif (!xd_drives)\r\ngoto out3;\r\nfor (i = 0; i < xd_drives; i++) {\r\nXD_INFO *p = &xd_info[i];\r\nstruct gendisk *disk = alloc_disk(64);\r\nif (!disk)\r\ngoto Enomem;\r\np->unit = i;\r\ndisk->major = XT_DISK_MAJOR;\r\ndisk->first_minor = i<<6;\r\nsprintf(disk->disk_name, "xd%c", i+'a');\r\ndisk->fops = &xd_fops;\r\ndisk->private_data = p;\r\ndisk->queue = xd_queue;\r\nset_capacity(disk, p->heads * p->cylinders * p->sectors);\r\nprintk(" %s: CHS=%d/%d/%d\n", disk->disk_name,\r\np->cylinders, p->heads, p->sectors);\r\nxd_gendisk[i] = disk;\r\n}\r\nerr = -EBUSY;\r\nif (request_irq(xd_irq,xd_interrupt_handler, 0, "XT hard disk", NULL)) {\r\nprintk("xd: unable to get IRQ%d\n",xd_irq);\r\ngoto out4;\r\n}\r\nif (request_dma(xd_dma,"xd")) {\r\nprintk("xd: unable to get DMA%d\n",xd_dma);\r\ngoto out5;\r\n}\r\nblk_queue_max_hw_sectors(xd_queue, xd_maxsectors);\r\nfor (i = 0; i < xd_drives; i++)\r\nadd_disk(xd_gendisk[i]);\r\nreturn 0;\r\nout5:\r\nfree_irq(xd_irq, NULL);\r\nout4:\r\nfor (i = 0; i < xd_drives; i++)\r\nput_disk(xd_gendisk[i]);\r\nout3:\r\nif (xd_maxsectors)\r\nrelease_region(xd_iobase,4);\r\nif (xd_dma_buffer)\r\nxd_dma_mem_free((unsigned long)xd_dma_buffer,\r\nxd_maxsectors * 0x200);\r\nout2:\r\nblk_cleanup_queue(xd_queue);\r\nout1a:\r\nunregister_blkdev(XT_DISK_MAJOR, "xd");\r\nout1:\r\nreturn err;\r\nEnomem:\r\nerr = -ENOMEM;\r\nwhile (i--)\r\nput_disk(xd_gendisk[i]);\r\ngoto out3;\r\n}\r\nstatic u_char __init xd_detect (u_char *controller, unsigned int *address)\r\n{\r\nint i, j;\r\nif (xd_override)\r\n{\r\n*controller = xd_type;\r\n*address = 0;\r\nreturn(1);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(xd_bases); i++) {\r\nvoid __iomem *p = ioremap(xd_bases[i], 0x2000);\r\nif (!p)\r\ncontinue;\r\nfor (j = 1; j < ARRAY_SIZE(xd_sigs); j++) {\r\nconst char *s = xd_sigs[j].string;\r\nif (check_signature(p + xd_sigs[j].offset, s, strlen(s))) {\r\n*controller = j;\r\nxd_type = j;\r\n*address = xd_bases[i];\r\niounmap(p);\r\nreturn 1;\r\n}\r\n}\r\niounmap(p);\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_xd_request (struct request_queue * q)\r\n{\r\nstruct request *req;\r\nif (xdc_busy)\r\nreturn;\r\nreq = blk_fetch_request(q);\r\nwhile (req) {\r\nunsigned block = blk_rq_pos(req);\r\nunsigned count = blk_rq_cur_sectors(req);\r\nXD_INFO *disk = req->rq_disk->private_data;\r\nint res = -EIO;\r\nint retry;\r\nif (req->cmd_type != REQ_TYPE_FS)\r\ngoto done;\r\nif (block + count > get_capacity(req->rq_disk))\r\ngoto done;\r\nfor (retry = 0; (retry < XD_RETRIES) && !res; retry++)\r\nres = xd_readwrite(rq_data_dir(req), disk, req->buffer,\r\nblock, count);\r\ndone:\r\nif (!__blk_end_request_cur(req, res))\r\nreq = blk_fetch_request(q);\r\n}\r\n}\r\nstatic int xd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nXD_INFO *p = bdev->bd_disk->private_data;\r\ngeo->heads = p->heads;\r\ngeo->sectors = p->sectors;\r\ngeo->cylinders = p->cylinders;\r\nreturn 0;\r\n}\r\nstatic int xd_locked_ioctl(struct block_device *bdev, fmode_t mode, u_int cmd, u_long arg)\r\n{\r\nswitch (cmd) {\r\ncase HDIO_SET_DMA:\r\nif (!capable(CAP_SYS_ADMIN)) return -EACCES;\r\nif (xdc_busy) return -EBUSY;\r\nnodma = !arg;\r\nif (nodma && xd_dma_buffer) {\r\nxd_dma_mem_free((unsigned long)xd_dma_buffer,\r\nxd_maxsectors * 0x200);\r\nxd_dma_buffer = NULL;\r\n} else if (!nodma && !xd_dma_buffer) {\r\nxd_dma_buffer = (char *)xd_dma_mem_alloc(xd_maxsectors * 0x200);\r\nif (!xd_dma_buffer) {\r\nnodma = XD_DONT_USE_DMA;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\ncase HDIO_GET_DMA:\r\nreturn put_user(!nodma, (long __user *) arg);\r\ncase HDIO_GET_MULTCOUNT:\r\nreturn put_user(xd_maxsectors, (long __user *) arg);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int xd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nint ret;\r\nmutex_lock(&xd_mutex);\r\nret = xd_locked_ioctl(bdev, mode, cmd, param);\r\nmutex_unlock(&xd_mutex);\r\nreturn ret;\r\n}\r\nstatic int xd_readwrite (u_char operation,XD_INFO *p,char *buffer,u_int block,u_int count)\r\n{\r\nint drive = p->unit;\r\nu_char cmdblk[6],sense[4];\r\nu_short track,cylinder;\r\nu_char head,sector,control,mode = PIO_MODE,temp;\r\nchar **real_buffer;\r\nregister int i;\r\n#ifdef DEBUG_READWRITE\r\nprintk("xd_readwrite: operation = %s, drive = %d, buffer = 0x%X, block = %d, count = %d\n",operation == READ ? "read" : "write",drive,buffer,block,count);\r\n#endif\r\nspin_unlock_irq(&xd_lock);\r\ncontrol = p->control;\r\nif (!xd_dma_buffer)\r\nxd_dma_buffer = (char *)xd_dma_mem_alloc(xd_maxsectors * 0x200);\r\nwhile (count) {\r\ntemp = count < xd_maxsectors ? count : xd_maxsectors;\r\ntrack = block / p->sectors;\r\nhead = track % p->heads;\r\ncylinder = track / p->heads;\r\nsector = block % p->sectors;\r\n#ifdef DEBUG_READWRITE\r\nprintk("xd_readwrite: drive = %d, head = %d, cylinder = %d, sector = %d, count = %d\n",drive,head,cylinder,sector,temp);\r\n#endif\r\nif (xd_dma_buffer) {\r\nmode = xd_setup_dma(operation == READ ? DMA_MODE_READ : DMA_MODE_WRITE,(u_char *)(xd_dma_buffer),temp * 0x200);\r\nreal_buffer = &xd_dma_buffer;\r\nfor (i=0; i < (temp * 0x200); i++)\r\nxd_dma_buffer[i] = buffer[i];\r\n}\r\nelse\r\nreal_buffer = &buffer;\r\nxd_build(cmdblk,operation == READ ? CMD_READ : CMD_WRITE,drive,head,cylinder,sector,temp & 0xFF,control);\r\nswitch (xd_command(cmdblk,mode,(u_char *)(*real_buffer),(u_char *)(*real_buffer),sense,XD_TIMEOUT)) {\r\ncase 1:\r\nprintk("xd%c: %s timeout, recalibrating drive\n",'a'+drive,(operation == READ ? "read" : "write"));\r\nxd_recalibrate(drive);\r\nspin_lock_irq(&xd_lock);\r\nreturn -EIO;\r\ncase 2:\r\nif (sense[0] & 0x30) {\r\nprintk("xd%c: %s - ",'a'+drive,(operation == READ ? "reading" : "writing"));\r\nswitch ((sense[0] & 0x30) >> 4) {\r\ncase 0: printk("drive error, code = 0x%X",sense[0] & 0x0F);\r\nbreak;\r\ncase 1: printk("controller error, code = 0x%X",sense[0] & 0x0F);\r\nbreak;\r\ncase 2: printk("command error, code = 0x%X",sense[0] & 0x0F);\r\nbreak;\r\ncase 3: printk("miscellaneous error, code = 0x%X",sense[0] & 0x0F);\r\nbreak;\r\n}\r\n}\r\nif (sense[0] & 0x80)\r\nprintk(" - CHS = %d/%d/%d\n",((sense[2] & 0xC0) << 2) | sense[3],sense[1] & 0x1F,sense[2] & 0x3F);\r\nelse\r\nprintk(" - no valid disk address\n");\r\nspin_lock_irq(&xd_lock);\r\nreturn -EIO;\r\n}\r\nif (xd_dma_buffer)\r\nfor (i=0; i < (temp * 0x200); i++)\r\nbuffer[i] = xd_dma_buffer[i];\r\ncount -= temp, buffer += temp * 0x200, block += temp;\r\n}\r\nspin_lock_irq(&xd_lock);\r\nreturn 0;\r\n}\r\nstatic void xd_recalibrate (u_char drive)\r\n{\r\nu_char cmdblk[6];\r\nxd_build(cmdblk,CMD_RECALIBRATE,drive,0,0,0,0,0);\r\nif (xd_command(cmdblk,PIO_MODE,NULL,NULL,NULL,XD_TIMEOUT * 8))\r\nprintk("xd%c: warning! error recalibrating, controller may be unstable\n", 'a'+drive);\r\n}\r\nstatic irqreturn_t xd_interrupt_handler(int irq, void *dev_id)\r\n{\r\nif (inb(XD_STATUS) & STAT_INTERRUPT) {\r\n#ifdef DEBUG_OTHER\r\nprintk("xd_interrupt_handler: interrupt detected\n");\r\n#endif\r\noutb(0,XD_CONTROL);\r\nwake_up(&xd_wait_int);\r\nreturn IRQ_HANDLED;\r\n}\r\nelse\r\nprintk("xd: unexpected interrupt\n");\r\nreturn IRQ_NONE;\r\n}\r\nstatic u_char xd_setup_dma (u_char mode,u_char *buffer,u_int count)\r\n{\r\nunsigned long f;\r\nif (nodma)\r\nreturn (PIO_MODE);\r\nif (((unsigned long) buffer & 0xFFFF0000) != (((unsigned long) buffer + count) & 0xFFFF0000)) {\r\n#ifdef DEBUG_OTHER\r\nprintk("xd_setup_dma: using PIO, transfer overlaps 64k boundary\n");\r\n#endif\r\nreturn (PIO_MODE);\r\n}\r\nf=claim_dma_lock();\r\ndisable_dma(xd_dma);\r\nclear_dma_ff(xd_dma);\r\nset_dma_mode(xd_dma,mode);\r\nset_dma_addr(xd_dma, (unsigned long) buffer);\r\nset_dma_count(xd_dma,count);\r\nrelease_dma_lock(f);\r\nreturn (DMA_MODE);\r\n}\r\nstatic u_char *xd_build (u_char *cmdblk,u_char command,u_char drive,u_char head,u_short cylinder,u_char sector,u_char count,u_char control)\r\n{\r\ncmdblk[0] = command;\r\ncmdblk[1] = ((drive & 0x07) << 5) | (head & 0x1F);\r\ncmdblk[2] = ((cylinder & 0x300) >> 2) | (sector & 0x3F);\r\ncmdblk[3] = cylinder & 0xFF;\r\ncmdblk[4] = count;\r\ncmdblk[5] = control;\r\nreturn (cmdblk);\r\n}\r\nstatic void xd_watchdog (unsigned long unused)\r\n{\r\nxd_error = 1;\r\nwake_up(&xd_wait_int);\r\n}\r\nstatic inline u_char xd_waitport (u_short port,u_char flags,u_char mask,u_long timeout)\r\n{\r\nu_long expiry = jiffies + timeout;\r\nint success;\r\nxdc_busy = 1;\r\nwhile ((success = ((inb(port) & mask) != flags)) && time_before(jiffies, expiry))\r\nschedule_timeout_uninterruptible(1);\r\nxdc_busy = 0;\r\nreturn (success);\r\n}\r\nstatic inline u_int xd_wait_for_IRQ (void)\r\n{\r\nunsigned long flags;\r\nxd_watchdog_int.expires = jiffies + 8 * HZ;\r\nadd_timer(&xd_watchdog_int);\r\nflags=claim_dma_lock();\r\nenable_dma(xd_dma);\r\nrelease_dma_lock(flags);\r\nsleep_on(&xd_wait_int);\r\ndel_timer(&xd_watchdog_int);\r\nxdc_busy = 0;\r\nflags=claim_dma_lock();\r\ndisable_dma(xd_dma);\r\nrelease_dma_lock(flags);\r\nif (xd_error) {\r\nprintk("xd: missed IRQ - command aborted\n");\r\nxd_error = 0;\r\nreturn (1);\r\n}\r\nreturn (0);\r\n}\r\nstatic u_int xd_command (u_char *command,u_char mode,u_char *indata,u_char *outdata,u_char *sense,u_long timeout)\r\n{\r\nu_char cmdblk[6],csb,complete = 0;\r\n#ifdef DEBUG_COMMAND\r\nprintk("xd_command: command = 0x%X, mode = 0x%X, indata = 0x%X, outdata = 0x%X, sense = 0x%X\n",command,mode,indata,outdata,sense);\r\n#endif\r\noutb(0,XD_SELECT);\r\noutb(mode,XD_CONTROL);\r\nif (xd_waitport(XD_STATUS,STAT_SELECT,STAT_SELECT,timeout))\r\nreturn (1);\r\nwhile (!complete) {\r\nif (xd_waitport(XD_STATUS,STAT_READY,STAT_READY,timeout))\r\nreturn (1);\r\nswitch (inb(XD_STATUS) & (STAT_COMMAND | STAT_INPUT)) {\r\ncase 0:\r\nif (mode == DMA_MODE) {\r\nif (xd_wait_for_IRQ())\r\nreturn (1);\r\n} else\r\noutb(outdata ? *outdata++ : 0,XD_DATA);\r\nbreak;\r\ncase STAT_INPUT:\r\nif (mode == DMA_MODE) {\r\nif (xd_wait_for_IRQ())\r\nreturn (1);\r\n} else\r\nif (indata)\r\n*indata++ = inb(XD_DATA);\r\nelse\r\ninb(XD_DATA);\r\nbreak;\r\ncase STAT_COMMAND:\r\noutb(command ? *command++ : 0,XD_DATA);\r\nbreak;\r\ncase STAT_COMMAND | STAT_INPUT:\r\ncomplete = 1;\r\nbreak;\r\n}\r\n}\r\ncsb = inb(XD_DATA);\r\nif (xd_waitport(XD_STATUS,0,STAT_SELECT,timeout))\r\nreturn (1);\r\nif (csb & CSB_ERROR) {\r\nxd_build(cmdblk,CMD_SENSE,(csb & CSB_LUN) >> 5,0,0,0,0,0);\r\nif (xd_command(cmdblk,0,sense,NULL,NULL,XD_TIMEOUT))\r\nprintk("xd: warning! sense command failed!\n");\r\n}\r\n#ifdef DEBUG_COMMAND\r\nprintk("xd_command: completed with csb = 0x%X\n",csb);\r\n#endif\r\nreturn (csb & CSB_ERROR);\r\n}\r\nstatic u_char __init xd_initdrives (void (*init_drive)(u_char drive))\r\n{\r\nu_char cmdblk[6],i,count = 0;\r\nfor (i = 0; i < XD_MAXDRIVES; i++) {\r\nxd_build(cmdblk,CMD_TESTREADY,i,0,0,0,0,0);\r\nif (!xd_command(cmdblk,PIO_MODE,NULL,NULL,NULL,XD_TIMEOUT*8)) {\r\nmsleep_interruptible(XD_INIT_DISK_DELAY);\r\ninit_drive(count);\r\ncount++;\r\nmsleep_interruptible(XD_INIT_DISK_DELAY);\r\n}\r\n}\r\nreturn (count);\r\n}\r\nstatic void __init xd_manual_geo_set (u_char drive)\r\n{\r\nxd_info[drive].heads = (u_char)(xd_geo[3 * drive + 1]);\r\nxd_info[drive].cylinders = (u_short)(xd_geo[3 * drive]);\r\nxd_info[drive].sectors = (u_char)(xd_geo[3 * drive + 2]);\r\n}\r\nstatic void __init xd_dtc_init_controller (unsigned int address)\r\n{\r\nswitch (address) {\r\ncase 0x00000:\r\ncase 0xC8000: break;\r\ncase 0xCA000: xd_iobase = 0x324;\r\ncase 0xD0000:\r\ncase 0xD8000: break;\r\ndefault: printk("xd_dtc_init_controller: unsupported BIOS address %06x\n",address);\r\nbreak;\r\n}\r\nxd_maxsectors = 0x01;\r\noutb(0,XD_RESET);\r\n}\r\nstatic void __init xd_dtc5150cx_init_drive (u_char drive)\r\n{\r\nstatic u_short geometry_table[][4] = {\r\n{0x200,8,0x200,0x100},\r\n{0x267,2,0x267,0x267},\r\n{0x264,4,0x264,0x80},\r\n{0x132,4,0x132,0x0},\r\n{0x132,2,0x80, 0x132},\r\n{0x177,8,0x177,0x0},\r\n{0x132,8,0x84, 0x0},\r\n{},\r\n{0x132,6,0x80, 0x100},\r\n{0x200,6,0x100,0x100},\r\n{0x264,2,0x264,0x80},\r\n{0x280,4,0x280,0x100},\r\n{0x2B9,3,0x2B9,0x2B9},\r\n{0x2B9,5,0x2B9,0x2B9},\r\n{0x280,6,0x280,0x100},\r\n{0x132,4,0x132,0x0}};\r\nu_char n;\r\nn = inb(XD_JUMPER);\r\nn = (drive ? n : (n >> 2)) & 0x33;\r\nn = (n | (n >> 2)) & 0x0F;\r\nif (xd_geo[3*drive])\r\nxd_manual_geo_set(drive);\r\nelse\r\nif (n != 7) {\r\nxd_info[drive].heads = (u_char)(geometry_table[n][1]);\r\nxd_info[drive].cylinders = geometry_table[n][0];\r\nxd_info[drive].sectors = 17;\r\n#if 0\r\nxd_info[drive].rwrite = geometry_table[n][2];\r\nxd_info[drive].precomp = geometry_table[n][3]\r\nxd_info[drive].ecc = 0x0B;\r\n#endif\r\n}\r\nelse {\r\nprintk("xd%c: undetermined drive geometry\n",'a'+drive);\r\nreturn;\r\n}\r\nxd_info[drive].control = 5;\r\nxd_setparam(CMD_DTCSETPARAM,drive,xd_info[drive].heads,xd_info[drive].cylinders,geometry_table[n][2],geometry_table[n][3],0x0B);\r\nxd_recalibrate(drive);\r\n}\r\nstatic void __init xd_dtc_init_drive (u_char drive)\r\n{\r\nu_char cmdblk[6],buf[64];\r\nxd_build(cmdblk,CMD_DTCGETGEOM,drive,0,0,0,0,0);\r\nif (!xd_command(cmdblk,PIO_MODE,buf,NULL,NULL,XD_TIMEOUT * 2)) {\r\nxd_info[drive].heads = buf[0x0A];\r\nxd_info[drive].cylinders = ((u_short *) (buf))[0x04];\r\nxd_info[drive].sectors = 17;\r\nif (xd_geo[3*drive])\r\nxd_manual_geo_set(drive);\r\n#if 0\r\nxd_info[drive].rwrite = ((u_short *) (buf + 1))[0x05];\r\nxd_info[drive].precomp = ((u_short *) (buf + 1))[0x06];\r\nxd_info[drive].ecc = buf[0x0F];\r\n#endif\r\nxd_info[drive].control = 0;\r\nxd_setparam(CMD_DTCSETPARAM,drive,xd_info[drive].heads,xd_info[drive].cylinders,((u_short *) (buf + 1))[0x05],((u_short *) (buf + 1))[0x06],buf[0x0F]);\r\nxd_build(cmdblk,CMD_DTCSETSTEP,drive,0,0,0,0,7);\r\nif (xd_command(cmdblk,PIO_MODE,NULL,NULL,NULL,XD_TIMEOUT * 2))\r\nprintk("xd_dtc_init_drive: error setting step rate for xd%c\n", 'a'+drive);\r\n}\r\nelse\r\nprintk("xd_dtc_init_drive: error reading geometry for xd%c\n", 'a'+drive);\r\n}\r\nstatic void __init xd_wd_init_controller (unsigned int address)\r\n{\r\nswitch (address) {\r\ncase 0x00000:\r\ncase 0xC8000: break;\r\ncase 0xCA000: xd_iobase = 0x324; break;\r\ncase 0xCC000: xd_iobase = 0x328; break;\r\ncase 0xCE000: xd_iobase = 0x32C; break;\r\ncase 0xD0000: xd_iobase = 0x328; break;\r\ncase 0xD8000: xd_iobase = 0x32C; break;\r\ndefault: printk("xd_wd_init_controller: unsupported BIOS address %06x\n",address);\r\nbreak;\r\n}\r\nxd_maxsectors = 0x01;\r\noutb(0,XD_RESET);\r\nmsleep(XD_INIT_DISK_DELAY);\r\n}\r\nstatic void __init xd_wd_init_drive (u_char drive)\r\n{\r\nstatic u_short geometry_table[][4] = {\r\n{0x264,4,0x1C2,0x1C2},\r\n{0x132,4,0x099,0x0},\r\n{0x267,2,0x1C2,0x1C2},\r\n{0x267,4,0x1C2,0x1C2},\r\n{0x334,6,0x335,0x335},\r\n{0x30E,4,0x30F,0x3DC},\r\n{0x30E,2,0x30F,0x30F},\r\n{0x267,4,0x268,0x268},\r\n{0x3D5,5,0x3D6,0x3D6},\r\n{0x3DB,7,0x3DC,0x3DC},\r\n{0x264,4,0x265,0x265},\r\n{0x267,4,0x268,0x268}};\r\nu_char cmdblk[6],buf[0x200];\r\nu_char n = 0,rll,jumper_state,use_jumper_geo;\r\nu_char wd_1002 = (xd_sigs[xd_type].string[7] == '6');\r\njumper_state = ~(inb(0x322));\r\nif (jumper_state & 0x40)\r\nxd_irq = 9;\r\nrll = (jumper_state & 0x30) ? (0x04 << wd_1002) : 0;\r\nxd_build(cmdblk,CMD_READ,drive,0,0,0,1,0);\r\nif (!xd_command(cmdblk,PIO_MODE,buf,NULL,NULL,XD_TIMEOUT * 2)) {\r\nxd_info[drive].heads = buf[0x1AF];\r\nxd_info[drive].cylinders = ((u_short *) (buf + 1))[0xD6];\r\nxd_info[drive].sectors = 17;\r\nif (xd_geo[3*drive])\r\nxd_manual_geo_set(drive);\r\n#if 0\r\nxd_info[drive].rwrite = ((u_short *) (buf))[0xD8];\r\nxd_info[drive].wprecomp = ((u_short *) (buf))[0xDA];\r\nxd_info[drive].ecc = buf[0x1B4];\r\n#endif\r\nxd_info[drive].control = buf[0x1B5];\r\nuse_jumper_geo = !(xd_info[drive].heads) || !(xd_info[drive].cylinders);\r\nif (xd_geo[3*drive]) {\r\nxd_manual_geo_set(drive);\r\nxd_info[drive].control = rll ? 7 : 5;\r\n}\r\nelse if (use_jumper_geo) {\r\nn = (((jumper_state & 0x0F) >> (drive << 1)) & 0x03) | rll;\r\nxd_info[drive].cylinders = geometry_table[n][0];\r\nxd_info[drive].heads = (u_char)(geometry_table[n][1]);\r\nxd_info[drive].control = rll ? 7 : 5;\r\n#if 0\r\nxd_info[drive].rwrite = geometry_table[n][2];\r\nxd_info[drive].wprecomp = geometry_table[n][3];\r\nxd_info[drive].ecc = 0x0B;\r\n#endif\r\n}\r\nif (!wd_1002) {\r\nif (use_jumper_geo)\r\nxd_setparam(CMD_WDSETPARAM,drive,xd_info[drive].heads,xd_info[drive].cylinders,\r\ngeometry_table[n][2],geometry_table[n][3],0x0B);\r\nelse\r\nxd_setparam(CMD_WDSETPARAM,drive,xd_info[drive].heads,xd_info[drive].cylinders,\r\n((u_short *) (buf))[0xD8],((u_short *) (buf))[0xDA],buf[0x1B4]);\r\n}\r\nif (rll & wd_1002) {\r\nif ((xd_info[drive].cylinders *= 26,\r\nxd_info[drive].cylinders /= 17) > 1023)\r\nxd_info[drive].cylinders = 1023;\r\n#if 0\r\nxd_info[drive].rwrite *= 26;\r\nxd_info[drive].rwrite /= 17;\r\nxd_info[drive].wprecomp *= 26\r\nxd_info[drive].wprecomp /= 17;\r\n#endif\r\n}\r\n}\r\nelse\r\nprintk("xd_wd_init_drive: error reading geometry for xd%c\n",'a'+drive);\r\n}\r\nstatic void __init xd_seagate_init_controller (unsigned int address)\r\n{\r\nswitch (address) {\r\ncase 0x00000:\r\ncase 0xC8000: break;\r\ncase 0xD0000: xd_iobase = 0x324; break;\r\ncase 0xD8000: xd_iobase = 0x328; break;\r\ncase 0xE0000: xd_iobase = 0x32C; break;\r\ndefault: printk("xd_seagate_init_controller: unsupported BIOS address %06x\n",address);\r\nbreak;\r\n}\r\nxd_maxsectors = 0x40;\r\noutb(0,XD_RESET);\r\n}\r\nstatic void __init xd_seagate_init_drive (u_char drive)\r\n{\r\nu_char cmdblk[6],buf[0x200];\r\nxd_build(cmdblk,CMD_ST11GETGEOM,drive,0,0,0,1,0);\r\nif (!xd_command(cmdblk,PIO_MODE,buf,NULL,NULL,XD_TIMEOUT * 2)) {\r\nxd_info[drive].heads = buf[0x04];\r\nxd_info[drive].cylinders = (buf[0x02] << 8) | buf[0x03];\r\nxd_info[drive].sectors = buf[0x05];\r\nxd_info[drive].control = 0;\r\n}\r\nelse\r\nprintk("xd_seagate_init_drive: error reading geometry from xd%c\n", 'a'+drive);\r\n}\r\nstatic void __init xd_omti_init_controller (unsigned int address)\r\n{\r\nswitch (address) {\r\ncase 0x00000:\r\ncase 0xC8000: break;\r\ncase 0xD0000: xd_iobase = 0x324; break;\r\ncase 0xD8000: xd_iobase = 0x328; break;\r\ncase 0xE0000: xd_iobase = 0x32C; break;\r\ndefault: printk("xd_omti_init_controller: unsupported BIOS address %06x\n",address);\r\nbreak;\r\n}\r\nxd_maxsectors = 0x40;\r\noutb(0,XD_RESET);\r\n}\r\nstatic void __init xd_omti_init_drive (u_char drive)\r\n{\r\nxd_override_init_drive(drive);\r\nxd_info[drive].control = 2;\r\n}\r\nstatic void __init xd_xebec_init_controller (unsigned int address)\r\n{\r\nswitch (address) {\r\ncase 0x00000:\r\ncase 0xC8000:\r\ncase 0xD0000:\r\ncase 0xD2000:\r\ncase 0xD4000:\r\ncase 0xD6000:\r\ncase 0xD8000:\r\ncase 0xDA000:\r\ncase 0xDC000:\r\ncase 0xDE000:\r\ncase 0xE0000: break;\r\ndefault: printk("xd_xebec_init_controller: unsupported BIOS address %06x\n",address);\r\nbreak;\r\n}\r\nxd_maxsectors = 0x01;\r\noutb(0,XD_RESET);\r\nmsleep(XD_INIT_DISK_DELAY);\r\n}\r\nstatic void __init xd_xebec_init_drive (u_char drive)\r\n{\r\nstatic u_short geometry_table[][5] = {\r\n{0x132,4,0x080,0x080,0x7},\r\n{0x132,4,0x080,0x080,0x17},\r\n{0x264,2,0x100,0x100,0x7},\r\n{0x264,2,0x100,0x100,0x17},\r\n{0x132,8,0x080,0x080,0x7},\r\n{0x132,8,0x080,0x080,0x17},\r\n{0x264,4,0x100,0x100,0x6},\r\n{0x264,4,0x100,0x100,0x17},\r\n{0x2BC,5,0x2BC,0x12C,0x6},\r\n{0x3A5,4,0x3A5,0x3A5,0x7},\r\n{0x26C,6,0x26C,0x26C,0x7},\r\n{0x200,8,0x200,0x100,0x17},\r\n{0x400,5,0x400,0x400,0x7},\r\n{0x400,6,0x400,0x400,0x7},\r\n{0x264,8,0x264,0x200,0x17},\r\n{0x33E,7,0x33E,0x200,0x7}};\r\nu_char n;\r\nn = inb(XD_JUMPER) & 0x0F;\r\nif (xd_geo[3*drive])\r\nxd_manual_geo_set(drive);\r\nelse {\r\nxd_info[drive].heads = (u_char)(geometry_table[n][1]);\r\nxd_info[drive].cylinders = geometry_table[n][0];\r\nxd_info[drive].sectors = 17;\r\n#if 0\r\nxd_info[drive].rwrite = geometry_table[n][2];\r\nxd_info[drive].precomp = geometry_table[n][3]\r\nxd_info[drive].ecc = 0x0B;\r\n#endif\r\n}\r\nxd_info[drive].control = geometry_table[n][4];\r\nxd_setparam(CMD_XBSETPARAM,drive,xd_info[drive].heads,xd_info[drive].cylinders,geometry_table[n][2],geometry_table[n][3],0x0B);\r\nxd_recalibrate(drive);\r\n}\r\nstatic void __init xd_override_init_drive (u_char drive)\r\n{\r\nu_short min[] = { 0,0,0 },max[] = { 16,1024,64 },test[] = { 0,0,0 };\r\nu_char cmdblk[6],i;\r\nif (xd_geo[3*drive])\r\nxd_manual_geo_set(drive);\r\nelse {\r\nfor (i = 0; i < 3; i++) {\r\nwhile (min[i] != max[i] - 1) {\r\ntest[i] = (min[i] + max[i]) / 2;\r\nxd_build(cmdblk,CMD_SEEK,drive,(u_char) test[0],(u_short) test[1],(u_char) test[2],0,0);\r\nif (!xd_command(cmdblk,PIO_MODE,NULL,NULL,NULL,XD_TIMEOUT * 2))\r\nmin[i] = test[i];\r\nelse\r\nmax[i] = test[i];\r\n}\r\ntest[i] = min[i];\r\n}\r\nxd_info[drive].heads = (u_char) min[0] + 1;\r\nxd_info[drive].cylinders = (u_short) min[1] + 1;\r\nxd_info[drive].sectors = (u_char) min[2] + 1;\r\n}\r\nxd_info[drive].control = 0;\r\n}\r\nstatic void __init do_xd_setup (int *integers)\r\n{\r\nswitch (integers[0]) {\r\ncase 4: if (integers[4] < 0)\r\nnodma = 1;\r\nelse if (integers[4] < 8)\r\nxd_dma = integers[4];\r\ncase 3: if ((integers[3] > 0) && (integers[3] <= 0x3FC))\r\nxd_iobase = integers[3];\r\ncase 2: if ((integers[2] > 0) && (integers[2] < 16))\r\nxd_irq = integers[2];\r\ncase 1: xd_override = 1;\r\nif ((integers[1] >= 0) && (integers[1] < ARRAY_SIZE(xd_sigs)))\r\nxd_type = integers[1];\r\ncase 0: break;\r\ndefault:printk("xd: too many parameters for xd\n");\r\n}\r\nxd_maxsectors = 0x01;\r\n}\r\nstatic void __init xd_setparam (u_char command,u_char drive,u_char heads,u_short cylinders,u_short rwrite,u_short wprecomp,u_char ecc)\r\n{\r\nu_char cmdblk[14];\r\nxd_build(cmdblk,command,drive,0,0,0,0,0);\r\ncmdblk[6] = (u_char) (cylinders >> 8) & 0x03;\r\ncmdblk[7] = (u_char) (cylinders & 0xFF);\r\ncmdblk[8] = heads & 0x1F;\r\ncmdblk[9] = (u_char) (rwrite >> 8) & 0x03;\r\ncmdblk[10] = (u_char) (rwrite & 0xFF);\r\ncmdblk[11] = (u_char) (wprecomp >> 8) & 0x03;\r\ncmdblk[12] = (u_char) (wprecomp & 0xFF);\r\ncmdblk[13] = ecc;\r\nif (xd_command(cmdblk,PIO_MODE,NULL,&cmdblk[6],NULL,XD_TIMEOUT * 2))\r\nprintk("xd: error setting characteristics for xd%c\n", 'a'+drive);\r\n}\r\nvoid cleanup_module(void)\r\n{\r\nint i;\r\nunregister_blkdev(XT_DISK_MAJOR, "xd");\r\nfor (i = 0; i < xd_drives; i++) {\r\ndel_gendisk(xd_gendisk[i]);\r\nput_disk(xd_gendisk[i]);\r\n}\r\nblk_cleanup_queue(xd_queue);\r\nrelease_region(xd_iobase,4);\r\nif (xd_drives) {\r\nfree_irq(xd_irq, NULL);\r\nfree_dma(xd_dma);\r\nif (xd_dma_buffer)\r\nxd_dma_mem_free((unsigned long)xd_dma_buffer, xd_maxsectors * 0x200);\r\n}\r\n}\r\nstatic int __init xd_setup (char *str)\r\n{\r\nint ints[5];\r\nget_options (str, ARRAY_SIZE (ints), ints);\r\ndo_xd_setup (ints);\r\nreturn 1;\r\n}\r\nstatic int __init xd_manual_geo_init (char *str)\r\n{\r\nint i, integers[1 + 3*XD_MAXDRIVES];\r\nget_options (str, ARRAY_SIZE (integers), integers);\r\nif (integers[0]%3 != 0) {\r\nprintk("xd: incorrect number of parameters for xd_geo\n");\r\nreturn 1;\r\n}\r\nfor (i = 0; (i < integers[0]) && (i < 3*XD_MAXDRIVES); i++)\r\nxd_geo[i] = integers[i+1];\r\nreturn 1;\r\n}
