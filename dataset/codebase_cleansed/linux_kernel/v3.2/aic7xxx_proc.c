static void\r\nproc_debug(const char *fmt, ...)\r\n{\r\nva_list ap;\r\nchar buf[256];\r\nva_start(ap, fmt);\r\nvsprintf(buf, fmt, ap);\r\nprintk(buf);\r\nva_end(ap);\r\n}\r\nstatic int\r\naic7xxx_set_info(char *buffer, int length, struct Scsi_Host *HBAptr)\r\n{\r\nproc_debug("aic7xxx_set_info(): %s\n", buffer);\r\nreturn (-ENOSYS);\r\n}\r\nint\r\naic7xxx_proc_info ( struct Scsi_Host *HBAptr, char *buffer, char **start, off_t offset, int length,\r\nint inout)\r\n{\r\nstruct aic7xxx_host *p;\r\nstruct aic_dev_data *aic_dev;\r\nstruct scsi_device *sdptr;\r\nint size = 0;\r\nunsigned char i;\r\nunsigned char tindex;\r\nfor(p=first_aic7xxx; p && p->host != HBAptr; p=p->next)\r\n;\r\nif (!p)\r\n{\r\nsize += sprintf(buffer, "Can't find adapter for host number %d\n", HBAptr->host_no);\r\nif (size > length)\r\n{\r\nreturn (size);\r\n}\r\nelse\r\n{\r\nreturn (length);\r\n}\r\n}\r\nif (inout == TRUE)\r\n{\r\nreturn (aic7xxx_set_info(buffer, length, HBAptr));\r\n}\r\np = (struct aic7xxx_host *) HBAptr->hostdata;\r\nsize = 4096;\r\nlist_for_each_entry(aic_dev, &p->aic_devs, list)\r\nsize += 512;\r\nif (aic7xxx_buffer_size != size)\r\n{\r\nif (aic7xxx_buffer != NULL)\r\n{\r\nkfree(aic7xxx_buffer);\r\naic7xxx_buffer_size = 0;\r\n}\r\naic7xxx_buffer = kmalloc(size, GFP_KERNEL);\r\n}\r\nif (aic7xxx_buffer == NULL)\r\n{\r\nsize = sprintf(buffer, "AIC7xxx - kmalloc error at line %d\n",\r\n__LINE__);\r\nreturn size;\r\n}\r\naic7xxx_buffer_size = size;\r\nsize = 0;\r\nsize += sprintf(BLS, "Adaptec AIC7xxx driver version: ");\r\nsize += sprintf(BLS, "%s/", AIC7XXX_C_VERSION);\r\nsize += sprintf(BLS, "%s", AIC7XXX_H_VERSION);\r\nsize += sprintf(BLS, "\n");\r\nsize += sprintf(BLS, "Adapter Configuration:\n");\r\nsize += sprintf(BLS, " SCSI Adapter: %s\n",\r\nboard_names[p->board_name_index]);\r\nif (p->flags & AHC_TWIN)\r\nsize += sprintf(BLS, " Twin Channel Controller ");\r\nelse\r\n{\r\nchar *channel = "";\r\nchar *ultra = "";\r\nchar *wide = "Narrow ";\r\nif (p->flags & AHC_MULTI_CHANNEL)\r\n{\r\nchannel = " Channel A";\r\nif (p->flags & (AHC_CHNLB|AHC_CHNLC))\r\nchannel = (p->flags & AHC_CHNLB) ? " Channel B" : " Channel C";\r\n}\r\nif (p->features & AHC_WIDE)\r\nwide = "Wide ";\r\nif (p->features & AHC_ULTRA3)\r\n{\r\nswitch(p->chip & AHC_CHIPID_MASK)\r\n{\r\ncase AHC_AIC7892:\r\ncase AHC_AIC7899:\r\nultra = "Ultra-160/m LVD/SE ";\r\nbreak;\r\ndefault:\r\nultra = "Ultra-3 LVD/SE ";\r\nbreak;\r\n}\r\n}\r\nelse if (p->features & AHC_ULTRA2)\r\nultra = "Ultra-2 LVD/SE ";\r\nelse if (p->features & AHC_ULTRA)\r\nultra = "Ultra ";\r\nsize += sprintf(BLS, " %s%sController%s ",\r\nultra, wide, channel);\r\n}\r\nswitch(p->chip & ~AHC_CHIPID_MASK)\r\n{\r\ncase AHC_VL:\r\nsize += sprintf(BLS, "at VLB slot %d\n", p->pci_device_fn);\r\nbreak;\r\ncase AHC_EISA:\r\nsize += sprintf(BLS, "at EISA slot %d\n", p->pci_device_fn);\r\nbreak;\r\ndefault:\r\nsize += sprintf(BLS, "at PCI %d/%d/%d\n", p->pci_bus,\r\nPCI_SLOT(p->pci_device_fn), PCI_FUNC(p->pci_device_fn));\r\nbreak;\r\n}\r\nif( !(p->maddr) )\r\n{\r\nsize += sprintf(BLS, " Programmed I/O Base: %lx\n", p->base);\r\n}\r\nelse\r\n{\r\nsize += sprintf(BLS, " PCI MMAPed I/O Base: 0x%lx\n", p->mbase);\r\n}\r\nif( (p->chip & (AHC_VL | AHC_EISA)) )\r\n{\r\nsize += sprintf(BLS, " BIOS Memory Address: 0x%08x\n", p->bios_address);\r\n}\r\nsize += sprintf(BLS, " Adapter SEEPROM Config: %s\n",\r\n(p->flags & AHC_SEEPROM_FOUND) ? "SEEPROM found and used." :\r\n((p->flags & AHC_USEDEFAULTS) ? "SEEPROM not found, using defaults." :\r\n"SEEPROM not found, using leftover BIOS values.") );\r\nsize += sprintf(BLS, " Adaptec SCSI BIOS: %s\n",\r\n(p->flags & AHC_BIOS_ENABLED) ? "Enabled" : "Disabled");\r\nsize += sprintf(BLS, " IRQ: %d\n", HBAptr->irq);\r\nsize += sprintf(BLS, " SCBs: Active %d, Max Active %d,\n",\r\np->activescbs, p->max_activescbs);\r\nsize += sprintf(BLS, " Allocated %d, HW %d, "\r\n"Page %d\n", p->scb_data->numscbs, p->scb_data->maxhscbs,\r\np->scb_data->maxscbs);\r\nif (p->flags & AHC_EXTERNAL_SRAM)\r\nsize += sprintf(BLS, " Using External SCB SRAM\n");\r\nsize += sprintf(BLS, " Interrupts: %ld", p->isr_count);\r\nif (p->chip & AHC_EISA)\r\n{\r\nsize += sprintf(BLS, " %s\n",\r\n(p->pause & IRQMS) ? "(Level Sensitive)" : "(Edge Triggered)");\r\n}\r\nelse\r\n{\r\nsize += sprintf(BLS, "\n");\r\n}\r\nsize += sprintf(BLS, " BIOS Control Word: 0x%04x\n",\r\np->bios_control);\r\nsize += sprintf(BLS, " Adapter Control Word: 0x%04x\n",\r\np->adapter_control);\r\nsize += sprintf(BLS, " Extended Translation: %sabled\n",\r\n(p->flags & AHC_EXTEND_TRANS_A) ? "En" : "Dis");\r\nsize += sprintf(BLS, "Disconnect Enable Flags: 0x%04x\n", p->discenable);\r\nif (p->features & (AHC_ULTRA | AHC_ULTRA2))\r\n{\r\nsize += sprintf(BLS, " Ultra Enable Flags: 0x%04x\n", p->ultraenb);\r\n}\r\nsize += sprintf(BLS, "Default Tag Queue Depth: %d\n", aic7xxx_default_queue_depth);\r\nsize += sprintf(BLS, " Tagged Queue By Device array for aic7xxx host "\r\n"instance %d:\n", p->instance);\r\nsize += sprintf(BLS, " {");\r\nfor(i=0; i < (MAX_TARGETS - 1); i++)\r\nsize += sprintf(BLS, "%d,",aic7xxx_tag_info[p->instance].tag_commands[i]);\r\nsize += sprintf(BLS, "%d}\n",aic7xxx_tag_info[p->instance].tag_commands[i]);\r\nsize += sprintf(BLS, "\n");\r\nsize += sprintf(BLS, "Statistics:\n\n");\r\nlist_for_each_entry(aic_dev, &p->aic_devs, list)\r\n{\r\nsdptr = aic_dev->SDptr;\r\ntindex = sdptr->channel << 3 | sdptr->id;\r\nsize += sprintf(BLS, "(scsi%d:%d:%d:%d)\n",\r\np->host_no, sdptr->channel, sdptr->id, sdptr->lun);\r\nsize += sprintf(BLS, " Device using %s/%s",\r\n(aic_dev->cur.width == MSG_EXT_WDTR_BUS_16_BIT) ?\r\n"Wide" : "Narrow",\r\n(aic_dev->cur.offset != 0) ?\r\n"Sync transfers at " : "Async transfers.\n" );\r\nif (aic_dev->cur.offset != 0)\r\n{\r\nstruct aic7xxx_syncrate *sync_rate;\r\nunsigned char options = aic_dev->cur.options;\r\nint period = aic_dev->cur.period;\r\nint rate = (aic_dev->cur.width ==\r\nMSG_EXT_WDTR_BUS_16_BIT) ? 1 : 0;\r\nsync_rate = aic7xxx_find_syncrate(p, &period, 0, &options);\r\nif (sync_rate != NULL)\r\n{\r\nsize += sprintf(BLS, "%s MByte/sec, offset %d\n",\r\nsync_rate->rate[rate],\r\naic_dev->cur.offset );\r\n}\r\nelse\r\n{\r\nsize += sprintf(BLS, "3.3 MByte/sec, offset %d\n",\r\naic_dev->cur.offset );\r\n}\r\n}\r\nsize += sprintf(BLS, " Transinfo settings: ");\r\nsize += sprintf(BLS, "current(%d/%d/%d/%d), ",\r\naic_dev->cur.period,\r\naic_dev->cur.offset,\r\naic_dev->cur.width,\r\naic_dev->cur.options);\r\nsize += sprintf(BLS, "goal(%d/%d/%d/%d), ",\r\naic_dev->goal.period,\r\naic_dev->goal.offset,\r\naic_dev->goal.width,\r\naic_dev->goal.options);\r\nsize += sprintf(BLS, "user(%d/%d/%d/%d)\n",\r\np->user[tindex].period,\r\np->user[tindex].offset,\r\np->user[tindex].width,\r\np->user[tindex].options);\r\nif(sdptr->simple_tags)\r\n{\r\nsize += sprintf(BLS, " Tagged Command Queueing Enabled, Ordered Tags %s, Depth %d/%d\n", sdptr->ordered_tags ? "Enabled" : "Disabled", sdptr->queue_depth, aic_dev->max_q_depth);\r\n}\r\nif(aic_dev->barrier_total)\r\nsize += sprintf(BLS, " Total transfers %ld:\n (%ld/%ld/%ld/%ld reads/writes/REQ_BARRIER/Ordered Tags)\n",\r\naic_dev->r_total+aic_dev->w_total, aic_dev->r_total, aic_dev->w_total,\r\naic_dev->barrier_total, aic_dev->ordered_total);\r\nelse\r\nsize += sprintf(BLS, " Total transfers %ld:\n (%ld/%ld reads/writes)\n",\r\naic_dev->r_total+aic_dev->w_total, aic_dev->r_total, aic_dev->w_total);\r\nsize += sprintf(BLS, "%s\n", HDRB);\r\nsize += sprintf(BLS, " Reads:");\r\nfor (i = 0; i < ARRAY_SIZE(aic_dev->r_bins); i++)\r\n{\r\nsize += sprintf(BLS, " %10ld", aic_dev->r_bins[i]);\r\n}\r\nsize += sprintf(BLS, "\n");\r\nsize += sprintf(BLS, " Writes:");\r\nfor (i = 0; i < ARRAY_SIZE(aic_dev->w_bins); i++)\r\n{\r\nsize += sprintf(BLS, " %10ld", aic_dev->w_bins[i]);\r\n}\r\nsize += sprintf(BLS, "\n");\r\nsize += sprintf(BLS, "\n\n");\r\n}\r\nif (size >= aic7xxx_buffer_size)\r\n{\r\nprintk(KERN_WARNING "aic7xxx: Overflow in aic7xxx_proc.c\n");\r\n}\r\nif (offset > size - 1)\r\n{\r\nkfree(aic7xxx_buffer);\r\naic7xxx_buffer = NULL;\r\naic7xxx_buffer_size = length = 0;\r\n*start = NULL;\r\n}\r\nelse\r\n{\r\n*start = buffer;\r\nlength = min_t(int, length, size - offset);\r\nmemcpy(buffer, &aic7xxx_buffer[offset], length);\r\n}\r\nreturn (length);\r\n}
