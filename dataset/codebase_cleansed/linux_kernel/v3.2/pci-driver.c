int pci_add_dynid(struct pci_driver *drv,\r\nunsigned int vendor, unsigned int device,\r\nunsigned int subvendor, unsigned int subdevice,\r\nunsigned int class, unsigned int class_mask,\r\nunsigned long driver_data)\r\n{\r\nstruct pci_dynid *dynid;\r\nint retval;\r\ndynid = kzalloc(sizeof(*dynid), GFP_KERNEL);\r\nif (!dynid)\r\nreturn -ENOMEM;\r\ndynid->id.vendor = vendor;\r\ndynid->id.device = device;\r\ndynid->id.subvendor = subvendor;\r\ndynid->id.subdevice = subdevice;\r\ndynid->id.class = class;\r\ndynid->id.class_mask = class_mask;\r\ndynid->id.driver_data = driver_data;\r\nspin_lock(&drv->dynids.lock);\r\nlist_add_tail(&dynid->node, &drv->dynids.list);\r\nspin_unlock(&drv->dynids.lock);\r\nget_driver(&drv->driver);\r\nretval = driver_attach(&drv->driver);\r\nput_driver(&drv->driver);\r\nreturn retval;\r\n}\r\nstatic void pci_free_dynids(struct pci_driver *drv)\r\n{\r\nstruct pci_dynid *dynid, *n;\r\nspin_lock(&drv->dynids.lock);\r\nlist_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {\r\nlist_del(&dynid->node);\r\nkfree(dynid);\r\n}\r\nspin_unlock(&drv->dynids.lock);\r\n}\r\nstatic ssize_t\r\nstore_new_id(struct device_driver *driver, const char *buf, size_t count)\r\n{\r\nstruct pci_driver *pdrv = to_pci_driver(driver);\r\nconst struct pci_device_id *ids = pdrv->id_table;\r\n__u32 vendor, device, subvendor=PCI_ANY_ID,\r\nsubdevice=PCI_ANY_ID, class=0, class_mask=0;\r\nunsigned long driver_data=0;\r\nint fields=0;\r\nint retval;\r\nfields = sscanf(buf, "%x %x %x %x %x %x %lx",\r\n&vendor, &device, &subvendor, &subdevice,\r\n&class, &class_mask, &driver_data);\r\nif (fields < 2)\r\nreturn -EINVAL;\r\nif (ids) {\r\nretval = -EINVAL;\r\nwhile (ids->vendor || ids->subvendor || ids->class_mask) {\r\nif (driver_data == ids->driver_data) {\r\nretval = 0;\r\nbreak;\r\n}\r\nids++;\r\n}\r\nif (retval)\r\nreturn retval;\r\n}\r\nretval = pci_add_dynid(pdrv, vendor, device, subvendor, subdevice,\r\nclass, class_mask, driver_data);\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_remove_id(struct device_driver *driver, const char *buf, size_t count)\r\n{\r\nstruct pci_dynid *dynid, *n;\r\nstruct pci_driver *pdrv = to_pci_driver(driver);\r\n__u32 vendor, device, subvendor = PCI_ANY_ID,\r\nsubdevice = PCI_ANY_ID, class = 0, class_mask = 0;\r\nint fields = 0;\r\nint retval = -ENODEV;\r\nfields = sscanf(buf, "%x %x %x %x %x %x",\r\n&vendor, &device, &subvendor, &subdevice,\r\n&class, &class_mask);\r\nif (fields < 2)\r\nreturn -EINVAL;\r\nspin_lock(&pdrv->dynids.lock);\r\nlist_for_each_entry_safe(dynid, n, &pdrv->dynids.list, node) {\r\nstruct pci_device_id *id = &dynid->id;\r\nif ((id->vendor == vendor) &&\r\n(id->device == device) &&\r\n(subvendor == PCI_ANY_ID || id->subvendor == subvendor) &&\r\n(subdevice == PCI_ANY_ID || id->subdevice == subdevice) &&\r\n!((id->class ^ class) & class_mask)) {\r\nlist_del(&dynid->node);\r\nkfree(dynid);\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&pdrv->dynids.lock);\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic int\r\npci_create_newid_file(struct pci_driver *drv)\r\n{\r\nint error = 0;\r\nif (drv->probe != NULL)\r\nerror = driver_create_file(&drv->driver, &driver_attr_new_id);\r\nreturn error;\r\n}\r\nstatic void pci_remove_newid_file(struct pci_driver *drv)\r\n{\r\ndriver_remove_file(&drv->driver, &driver_attr_new_id);\r\n}\r\nstatic int\r\npci_create_removeid_file(struct pci_driver *drv)\r\n{\r\nint error = 0;\r\nif (drv->probe != NULL)\r\nerror = driver_create_file(&drv->driver,&driver_attr_remove_id);\r\nreturn error;\r\n}\r\nstatic void pci_remove_removeid_file(struct pci_driver *drv)\r\n{\r\ndriver_remove_file(&drv->driver, &driver_attr_remove_id);\r\n}\r\nstatic inline int pci_create_newid_file(struct pci_driver *drv)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void pci_remove_newid_file(struct pci_driver *drv) {}\r\nstatic inline int pci_create_removeid_file(struct pci_driver *drv)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void pci_remove_removeid_file(struct pci_driver *drv) {}\r\nconst struct pci_device_id *pci_match_id(const struct pci_device_id *ids,\r\nstruct pci_dev *dev)\r\n{\r\nif (ids) {\r\nwhile (ids->vendor || ids->subvendor || ids->class_mask) {\r\nif (pci_match_one_device(ids, dev))\r\nreturn ids;\r\nids++;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct pci_device_id *pci_match_device(struct pci_driver *drv,\r\nstruct pci_dev *dev)\r\n{\r\nstruct pci_dynid *dynid;\r\nspin_lock(&drv->dynids.lock);\r\nlist_for_each_entry(dynid, &drv->dynids.list, node) {\r\nif (pci_match_one_device(&dynid->id, dev)) {\r\nspin_unlock(&drv->dynids.lock);\r\nreturn &dynid->id;\r\n}\r\n}\r\nspin_unlock(&drv->dynids.lock);\r\nreturn pci_match_id(drv->id_table, dev);\r\n}\r\nstatic long local_pci_probe(void *_ddi)\r\n{\r\nstruct drv_dev_and_id *ddi = _ddi;\r\nstruct device *dev = &ddi->dev->dev;\r\nint rc;\r\npm_runtime_get_noresume(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nrc = ddi->drv->probe(ddi->dev, ddi->id);\r\nif (rc) {\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_put_noidle(dev);\r\n}\r\nreturn rc;\r\n}\r\nstatic int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint error, node;\r\nstruct drv_dev_and_id ddi = { drv, dev, id };\r\nnode = dev_to_node(&dev->dev);\r\nif (node >= 0) {\r\nint cpu;\r\nget_online_cpus();\r\ncpu = cpumask_any_and(cpumask_of_node(node), cpu_online_mask);\r\nif (cpu < nr_cpu_ids)\r\nerror = work_on_cpu(cpu, local_pci_probe, &ddi);\r\nelse\r\nerror = local_pci_probe(&ddi);\r\nput_online_cpus();\r\n} else\r\nerror = local_pci_probe(&ddi);\r\nreturn error;\r\n}\r\nstatic int\r\n__pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)\r\n{\r\nconst struct pci_device_id *id;\r\nint error = 0;\r\nif (!pci_dev->driver && drv->probe) {\r\nerror = -ENODEV;\r\nid = pci_match_device(drv, pci_dev);\r\nif (id)\r\nerror = pci_call_probe(drv, pci_dev, id);\r\nif (error >= 0) {\r\npci_dev->driver = drv;\r\nerror = 0;\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic int pci_device_probe(struct device * dev)\r\n{\r\nint error = 0;\r\nstruct pci_driver *drv;\r\nstruct pci_dev *pci_dev;\r\ndrv = to_pci_driver(dev->driver);\r\npci_dev = to_pci_dev(dev);\r\npci_dev_get(pci_dev);\r\nerror = __pci_device_probe(drv, pci_dev);\r\nif (error)\r\npci_dev_put(pci_dev);\r\nreturn error;\r\n}\r\nstatic int pci_device_remove(struct device * dev)\r\n{\r\nstruct pci_dev * pci_dev = to_pci_dev(dev);\r\nstruct pci_driver * drv = pci_dev->driver;\r\nif (drv) {\r\nif (drv->remove) {\r\npm_runtime_get_sync(dev);\r\ndrv->remove(pci_dev);\r\npm_runtime_put_noidle(dev);\r\n}\r\npci_dev->driver = NULL;\r\n}\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_put_noidle(dev);\r\nif (pci_dev->current_state == PCI_D0)\r\npci_dev->current_state = PCI_UNKNOWN;\r\npci_dev_put(pci_dev);\r\nreturn 0;\r\n}\r\nstatic void pci_device_shutdown(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *drv = pci_dev->driver;\r\nif (drv && drv->shutdown)\r\ndrv->shutdown(pci_dev);\r\npci_msi_shutdown(pci_dev);\r\npci_msix_shutdown(pci_dev);\r\n}\r\nstatic int pci_restore_standard_config(struct pci_dev *pci_dev)\r\n{\r\npci_update_current_state(pci_dev, PCI_UNKNOWN);\r\nif (pci_dev->current_state != PCI_D0) {\r\nint error = pci_set_power_state(pci_dev, PCI_D0);\r\nif (error)\r\nreturn error;\r\n}\r\npci_restore_state(pci_dev);\r\nreturn 0;\r\n}\r\nstatic void pci_pm_default_resume_early(struct pci_dev *pci_dev)\r\n{\r\npci_restore_standard_config(pci_dev);\r\npci_fixup_device(pci_fixup_resume_early, pci_dev);\r\n}\r\nstatic void pci_pm_set_unknown_state(struct pci_dev *pci_dev)\r\n{\r\nif (pci_dev->current_state == PCI_D0)\r\npci_dev->current_state = PCI_UNKNOWN;\r\n}\r\nstatic int pci_pm_reenable_device(struct pci_dev *pci_dev)\r\n{\r\nint retval;\r\nretval = pci_reenable_device(pci_dev);\r\nif (pci_dev->is_busmaster)\r\npci_set_master(pci_dev);\r\nreturn retval;\r\n}\r\nstatic int pci_legacy_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct pci_dev * pci_dev = to_pci_dev(dev);\r\nstruct pci_driver * drv = pci_dev->driver;\r\nif (drv && drv->suspend) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = drv->suspend(pci_dev, state);\r\nsuspend_report_result(drv->suspend, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: Device state not saved by %pF\n",\r\ndrv->suspend);\r\n}\r\n}\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_legacy_suspend_late(struct device *dev, pm_message_t state)\r\n{\r\nstruct pci_dev * pci_dev = to_pci_dev(dev);\r\nstruct pci_driver * drv = pci_dev->driver;\r\nif (drv && drv->suspend_late) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = drv->suspend_late(pci_dev, state);\r\nsuspend_report_result(drv->suspend_late, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: Device state not saved by %pF\n",\r\ndrv->suspend_late);\r\nreturn 0;\r\n}\r\n}\r\nif (!pci_dev->state_saved)\r\npci_save_state(pci_dev);\r\npci_pm_set_unknown_state(pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_legacy_resume_early(struct device *dev)\r\n{\r\nstruct pci_dev * pci_dev = to_pci_dev(dev);\r\nstruct pci_driver * drv = pci_dev->driver;\r\nreturn drv && drv->resume_early ?\r\ndrv->resume_early(pci_dev) : 0;\r\n}\r\nstatic int pci_legacy_resume(struct device *dev)\r\n{\r\nstruct pci_dev * pci_dev = to_pci_dev(dev);\r\nstruct pci_driver * drv = pci_dev->driver;\r\npci_fixup_device(pci_fixup_resume, pci_dev);\r\nreturn drv && drv->resume ?\r\ndrv->resume(pci_dev) : pci_pm_reenable_device(pci_dev);\r\n}\r\nstatic void pci_pm_default_resume(struct pci_dev *pci_dev)\r\n{\r\npci_fixup_device(pci_fixup_resume, pci_dev);\r\nif (!pci_is_bridge(pci_dev))\r\npci_enable_wake(pci_dev, PCI_D0, false);\r\n}\r\nstatic void pci_pm_default_suspend(struct pci_dev *pci_dev)\r\n{\r\nif (!pci_is_bridge(pci_dev))\r\npci_disable_enabled_device(pci_dev);\r\n}\r\nstatic bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)\r\n{\r\nstruct pci_driver *drv = pci_dev->driver;\r\nbool ret = drv && (drv->suspend || drv->suspend_late || drv->resume\r\n|| drv->resume_early);\r\nWARN_ON(ret && drv->driver.pm);\r\nreturn ret;\r\n}\r\nstatic int pci_pm_prepare(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nint error = 0;\r\npm_runtime_get_noresume(dev);\r\nif (pm_runtime_barrier(dev) && device_may_wakeup(dev))\r\npm_wakeup_event(dev, 0);\r\nif (pm_wakeup_pending()) {\r\npm_runtime_put_sync(dev);\r\nreturn -EBUSY;\r\n}\r\npm_runtime_resume(dev);\r\nif (drv && drv->pm && drv->pm->prepare)\r\nerror = drv->pm->prepare(dev);\r\nreturn error;\r\n}\r\nstatic void pci_pm_complete(struct device *dev)\r\n{\r\nstruct device_driver *drv = dev->driver;\r\nif (drv && drv->pm && drv->pm->complete)\r\ndrv->pm->complete(dev);\r\npm_runtime_put_sync(dev);\r\n}\r\nstatic int pci_pm_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend(dev, PMSG_SUSPEND);\r\nif (!pm) {\r\npci_pm_default_suspend(pci_dev);\r\ngoto Fixup;\r\n}\r\nif (pm->suspend) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = pm->suspend(dev);\r\nsuspend_report_result(pm->suspend, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: State of device not saved by %pF\n",\r\npm->suspend);\r\n}\r\n}\r\nFixup:\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_suspend_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend_late(dev, PMSG_SUSPEND);\r\nif (!pm) {\r\npci_save_state(pci_dev);\r\nreturn 0;\r\n}\r\nif (pm->suspend_noirq) {\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nerror = pm->suspend_noirq(dev);\r\nsuspend_report_result(pm->suspend_noirq, error);\r\nif (error)\r\nreturn error;\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: State of device not saved by %pF\n",\r\npm->suspend_noirq);\r\nreturn 0;\r\n}\r\n}\r\nif (!pci_dev->state_saved) {\r\npci_save_state(pci_dev);\r\nif (!pci_is_bridge(pci_dev))\r\npci_prepare_to_sleep(pci_dev);\r\n}\r\npci_pm_set_unknown_state(pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_resume_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nint error = 0;\r\npci_pm_default_resume_early(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume_early(dev);\r\nif (drv && drv->pm && drv->pm->resume_noirq)\r\nerror = drv->pm->resume_noirq(dev);\r\nreturn error;\r\n}\r\nstatic int pci_pm_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint error = 0;\r\nif (pci_dev->state_saved)\r\npci_restore_standard_config(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume(dev);\r\npci_pm_default_resume(pci_dev);\r\nif (pm) {\r\nif (pm->resume)\r\nerror = pm->resume(dev);\r\n} else {\r\npci_pm_reenable_device(pci_dev);\r\n}\r\nreturn error;\r\n}\r\nstatic int pci_pm_freeze(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend(dev, PMSG_FREEZE);\r\nif (!pm) {\r\npci_pm_default_suspend(pci_dev);\r\nreturn 0;\r\n}\r\nif (pm->freeze) {\r\nint error;\r\nerror = pm->freeze(dev);\r\nsuspend_report_result(pm->freeze, error);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_pm_freeze_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend_late(dev, PMSG_FREEZE);\r\nif (drv && drv->pm && drv->pm->freeze_noirq) {\r\nint error;\r\nerror = drv->pm->freeze_noirq(dev);\r\nsuspend_report_result(drv->pm->freeze_noirq, error);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!pci_dev->state_saved)\r\npci_save_state(pci_dev);\r\npci_pm_set_unknown_state(pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_thaw_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nint error = 0;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume_early(dev);\r\npci_update_current_state(pci_dev, PCI_D0);\r\nif (drv && drv->pm && drv->pm->thaw_noirq)\r\nerror = drv->pm->thaw_noirq(dev);\r\nreturn error;\r\n}\r\nstatic int pci_pm_thaw(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint error = 0;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume(dev);\r\nif (pm) {\r\nif (pm->thaw)\r\nerror = pm->thaw(dev);\r\n} else {\r\npci_pm_reenable_device(pci_dev);\r\n}\r\npci_dev->state_saved = false;\r\nreturn error;\r\n}\r\nstatic int pci_pm_poweroff(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\r\nif (!pm) {\r\npci_pm_default_suspend(pci_dev);\r\ngoto Fixup;\r\n}\r\nif (pm->poweroff) {\r\nint error;\r\nerror = pm->poweroff(dev);\r\nsuspend_report_result(pm->poweroff, error);\r\nif (error)\r\nreturn error;\r\n}\r\nFixup:\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_poweroff_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nif (pci_has_legacy_pm_support(to_pci_dev(dev)))\r\nreturn pci_legacy_suspend_late(dev, PMSG_HIBERNATE);\r\nif (!drv || !drv->pm)\r\nreturn 0;\r\nif (drv->pm->poweroff_noirq) {\r\nint error;\r\nerror = drv->pm->poweroff_noirq(dev);\r\nsuspend_report_result(drv->pm->poweroff_noirq, error);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!pci_dev->state_saved && !pci_is_bridge(pci_dev))\r\npci_prepare_to_sleep(pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_restore_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct device_driver *drv = dev->driver;\r\nint error = 0;\r\npci_pm_default_resume_early(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume_early(dev);\r\nif (drv && drv->pm && drv->pm->restore_noirq)\r\nerror = drv->pm->restore_noirq(dev);\r\nreturn error;\r\n}\r\nstatic int pci_pm_restore(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint error = 0;\r\nif (pci_dev->state_saved)\r\npci_restore_standard_config(pci_dev);\r\nif (pci_has_legacy_pm_support(pci_dev))\r\nreturn pci_legacy_resume(dev);\r\npci_pm_default_resume(pci_dev);\r\nif (pm) {\r\nif (pm->restore)\r\nerror = pm->restore(dev);\r\n} else {\r\npci_pm_reenable_device(pci_dev);\r\n}\r\nreturn error;\r\n}\r\nstatic int pci_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\npci_power_t prev = pci_dev->current_state;\r\nint error;\r\nif (!pm || !pm->runtime_suspend)\r\nreturn -ENOSYS;\r\nerror = pm->runtime_suspend(dev);\r\nsuspend_report_result(pm->runtime_suspend, error);\r\nif (error)\r\nreturn error;\r\npci_fixup_device(pci_fixup_suspend, pci_dev);\r\nif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\r\n&& pci_dev->current_state != PCI_UNKNOWN) {\r\nWARN_ONCE(pci_dev->current_state != prev,\r\n"PCI PM: State of device not saved by %pF\n",\r\npm->runtime_suspend);\r\nreturn 0;\r\n}\r\nif (!pci_dev->state_saved)\r\npci_save_state(pci_dev);\r\npci_finish_runtime_suspend(pci_dev);\r\nreturn 0;\r\n}\r\nstatic int pci_pm_runtime_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (!pm || !pm->runtime_resume)\r\nreturn -ENOSYS;\r\npci_pm_default_resume_early(pci_dev);\r\n__pci_enable_wake(pci_dev, PCI_D0, true, false);\r\npci_fixup_device(pci_fixup_resume, pci_dev);\r\nreturn pm->runtime_resume(dev);\r\n}\r\nstatic int pci_pm_runtime_idle(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nif (!pm)\r\nreturn -ENOSYS;\r\nif (pm->runtime_idle) {\r\nint ret = pm->runtime_idle(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\npm_runtime_suspend(dev);\r\nreturn 0;\r\n}\r\nint __pci_register_driver(struct pci_driver *drv, struct module *owner,\r\nconst char *mod_name)\r\n{\r\nint error;\r\ndrv->driver.name = drv->name;\r\ndrv->driver.bus = &pci_bus_type;\r\ndrv->driver.owner = owner;\r\ndrv->driver.mod_name = mod_name;\r\nspin_lock_init(&drv->dynids.lock);\r\nINIT_LIST_HEAD(&drv->dynids.list);\r\nerror = driver_register(&drv->driver);\r\nif (error)\r\ngoto out;\r\nerror = pci_create_newid_file(drv);\r\nif (error)\r\ngoto out_newid;\r\nerror = pci_create_removeid_file(drv);\r\nif (error)\r\ngoto out_removeid;\r\nout:\r\nreturn error;\r\nout_removeid:\r\npci_remove_newid_file(drv);\r\nout_newid:\r\ndriver_unregister(&drv->driver);\r\ngoto out;\r\n}\r\nvoid\r\npci_unregister_driver(struct pci_driver *drv)\r\n{\r\npci_remove_removeid_file(drv);\r\npci_remove_newid_file(drv);\r\ndriver_unregister(&drv->driver);\r\npci_free_dynids(drv);\r\n}\r\nstruct pci_driver *\r\npci_dev_driver(const struct pci_dev *dev)\r\n{\r\nif (dev->driver)\r\nreturn dev->driver;\r\nelse {\r\nint i;\r\nfor(i=0; i<=PCI_ROM_RESOURCE; i++)\r\nif (dev->resource[i].flags & IORESOURCE_BUSY)\r\nreturn &pci_compat_driver;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int pci_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct pci_driver *pci_drv = to_pci_driver(drv);\r\nconst struct pci_device_id *found_id;\r\nfound_id = pci_match_device(pci_drv, pci_dev);\r\nif (found_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct pci_dev *pci_dev_get(struct pci_dev *dev)\r\n{\r\nif (dev)\r\nget_device(&dev->dev);\r\nreturn dev;\r\n}\r\nvoid pci_dev_put(struct pci_dev *dev)\r\n{\r\nif (dev)\r\nput_device(&dev->dev);\r\n}\r\nint pci_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int __init pci_driver_init(void)\r\n{\r\nreturn bus_register(&pci_bus_type);\r\n}
