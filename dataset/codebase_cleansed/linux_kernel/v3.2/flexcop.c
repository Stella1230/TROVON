static int flexcop_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct flexcop_device *fc = dvbdmxfeed->demux->priv;\r\nreturn flexcop_pid_feed_control(fc, dvbdmxfeed, 1);\r\n}\r\nstatic int flexcop_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct flexcop_device *fc = dvbdmxfeed->demux->priv;\r\nreturn flexcop_pid_feed_control(fc, dvbdmxfeed, 0);\r\n}\r\nstatic int flexcop_dvb_init(struct flexcop_device *fc)\r\n{\r\nint ret = dvb_register_adapter(&fc->dvb_adapter,\r\n"FlexCop Digital TV device", fc->owner,\r\nfc->dev, adapter_nr);\r\nif (ret < 0) {\r\nerr("error registering DVB adapter");\r\nreturn ret;\r\n}\r\nfc->dvb_adapter.priv = fc;\r\nfc->demux.dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING\r\n| DMX_MEMORY_BASED_FILTERING);\r\nfc->demux.priv = fc;\r\nfc->demux.filternum = fc->demux.feednum = FC_MAX_FEED;\r\nfc->demux.start_feed = flexcop_dvb_start_feed;\r\nfc->demux.stop_feed = flexcop_dvb_stop_feed;\r\nfc->demux.write_to_decoder = NULL;\r\nif ((ret = dvb_dmx_init(&fc->demux)) < 0) {\r\nerr("dvb_dmx failed: error %d", ret);\r\ngoto err_dmx;\r\n}\r\nfc->hw_frontend.source = DMX_FRONTEND_0;\r\nfc->dmxdev.filternum = fc->demux.feednum;\r\nfc->dmxdev.demux = &fc->demux.dmx;\r\nfc->dmxdev.capabilities = 0;\r\nif ((ret = dvb_dmxdev_init(&fc->dmxdev, &fc->dvb_adapter)) < 0) {\r\nerr("dvb_dmxdev_init failed: error %d", ret);\r\ngoto err_dmx_dev;\r\n}\r\nif ((ret = fc->demux.dmx.add_frontend(&fc->demux.dmx, &fc->hw_frontend)) < 0) {\r\nerr("adding hw_frontend to dmx failed: error %d", ret);\r\ngoto err_dmx_add_hw_frontend;\r\n}\r\nfc->mem_frontend.source = DMX_MEMORY_FE;\r\nif ((ret = fc->demux.dmx.add_frontend(&fc->demux.dmx, &fc->mem_frontend)) < 0) {\r\nerr("adding mem_frontend to dmx failed: error %d", ret);\r\ngoto err_dmx_add_mem_frontend;\r\n}\r\nif ((ret = fc->demux.dmx.connect_frontend(&fc->demux.dmx, &fc->hw_frontend)) < 0) {\r\nerr("connect frontend failed: error %d", ret);\r\ngoto err_connect_frontend;\r\n}\r\ndvb_net_init(&fc->dvb_adapter, &fc->dvbnet, &fc->demux.dmx);\r\nfc->init_state |= FC_STATE_DVB_INIT;\r\nreturn 0;\r\nerr_connect_frontend:\r\nfc->demux.dmx.remove_frontend(&fc->demux.dmx, &fc->mem_frontend);\r\nerr_dmx_add_mem_frontend:\r\nfc->demux.dmx.remove_frontend(&fc->demux.dmx, &fc->hw_frontend);\r\nerr_dmx_add_hw_frontend:\r\ndvb_dmxdev_release(&fc->dmxdev);\r\nerr_dmx_dev:\r\ndvb_dmx_release(&fc->demux);\r\nerr_dmx:\r\ndvb_unregister_adapter(&fc->dvb_adapter);\r\nreturn ret;\r\n}\r\nstatic void flexcop_dvb_exit(struct flexcop_device *fc)\r\n{\r\nif (fc->init_state & FC_STATE_DVB_INIT) {\r\ndvb_net_release(&fc->dvbnet);\r\nfc->demux.dmx.close(&fc->demux.dmx);\r\nfc->demux.dmx.remove_frontend(&fc->demux.dmx,\r\n&fc->mem_frontend);\r\nfc->demux.dmx.remove_frontend(&fc->demux.dmx,\r\n&fc->hw_frontend);\r\ndvb_dmxdev_release(&fc->dmxdev);\r\ndvb_dmx_release(&fc->demux);\r\ndvb_unregister_adapter(&fc->dvb_adapter);\r\ndeb_info("deinitialized dvb stuff\n");\r\n}\r\nfc->init_state &= ~FC_STATE_DVB_INIT;\r\n}\r\nvoid flexcop_pass_dmx_data(struct flexcop_device *fc, u8 *buf, u32 len)\r\n{\r\ndvb_dmx_swfilter(&fc->demux, buf, len);\r\n}\r\nvoid flexcop_pass_dmx_packets(struct flexcop_device *fc, u8 *buf, u32 no)\r\n{\r\ndvb_dmx_swfilter_packets(&fc->demux, buf, no);\r\n}\r\nstatic void flexcop_reset(struct flexcop_device *fc)\r\n{\r\nflexcop_ibi_value v210, v204;\r\nfc->write_ibi_reg(fc,ctrl_208,ibi_zero);\r\nv210.raw = 0;\r\nv210.sw_reset_210.reset_block_000 = 1;\r\nv210.sw_reset_210.reset_block_100 = 1;\r\nv210.sw_reset_210.reset_block_200 = 1;\r\nv210.sw_reset_210.reset_block_300 = 1;\r\nv210.sw_reset_210.reset_block_400 = 1;\r\nv210.sw_reset_210.reset_block_500 = 1;\r\nv210.sw_reset_210.reset_block_600 = 1;\r\nv210.sw_reset_210.reset_block_700 = 1;\r\nv210.sw_reset_210.Block_reset_enable = 0xb2;\r\nv210.sw_reset_210.Special_controls = 0xc259;\r\nfc->write_ibi_reg(fc,sw_reset_210,v210);\r\nmsleep(1);\r\nv204 = fc->read_ibi_reg(fc,misc_204);\r\nv204.misc_204.Per_reset_sig = 0;\r\nfc->write_ibi_reg(fc,misc_204,v204);\r\nmsleep(1);\r\nv204.misc_204.Per_reset_sig = 1;\r\nfc->write_ibi_reg(fc,misc_204,v204);\r\n}\r\nvoid flexcop_reset_block_300(struct flexcop_device *fc)\r\n{\r\nflexcop_ibi_value v208_save = fc->read_ibi_reg(fc, ctrl_208),\r\nv210 = fc->read_ibi_reg(fc, sw_reset_210);\r\ndeb_rdump("208: %08x, 210: %08x\n", v208_save.raw, v210.raw);\r\nfc->write_ibi_reg(fc,ctrl_208,ibi_zero);\r\nv210.sw_reset_210.reset_block_300 = 1;\r\nv210.sw_reset_210.Block_reset_enable = 0xb2;\r\nfc->write_ibi_reg(fc,sw_reset_210,v210);\r\nfc->write_ibi_reg(fc,ctrl_208,v208_save);\r\n}\r\nstruct flexcop_device *flexcop_device_kmalloc(size_t bus_specific_len)\r\n{\r\nvoid *bus;\r\nstruct flexcop_device *fc = kzalloc(sizeof(struct flexcop_device),\r\nGFP_KERNEL);\r\nif (!fc) {\r\nerr("no memory");\r\nreturn NULL;\r\n}\r\nbus = kzalloc(bus_specific_len, GFP_KERNEL);\r\nif (!bus) {\r\nerr("no memory");\r\nkfree(fc);\r\nreturn NULL;\r\n}\r\nfc->bus_specific = bus;\r\nreturn fc;\r\n}\r\nvoid flexcop_device_kfree(struct flexcop_device *fc)\r\n{\r\nkfree(fc->bus_specific);\r\nkfree(fc);\r\n}\r\nint flexcop_device_initialize(struct flexcop_device *fc)\r\n{\r\nint ret;\r\nibi_zero.raw = 0;\r\nflexcop_reset(fc);\r\nflexcop_determine_revision(fc);\r\nflexcop_sram_init(fc);\r\nflexcop_hw_filter_init(fc);\r\nflexcop_smc_ctrl(fc, 0);\r\nif ((ret = flexcop_dvb_init(fc)))\r\ngoto error;\r\nret = flexcop_i2c_init(fc);\r\nif (ret)\r\ngoto error;\r\nif (fc->get_mac_addr(fc, 0) == 0) {\r\nu8 *b = fc->dvb_adapter.proposed_mac;\r\ninfo("MAC address = %pM", b);\r\nflexcop_set_mac_filter(fc,b);\r\nflexcop_mac_filter_ctrl(fc,1);\r\n} else\r\nwarn("reading of MAC address failed.\n");\r\nif ((ret = flexcop_frontend_init(fc)))\r\ngoto error;\r\nflexcop_device_name(fc,"initialization of","complete");\r\nreturn 0;\r\nerror:\r\nflexcop_device_exit(fc);\r\nreturn ret;\r\n}\r\nvoid flexcop_device_exit(struct flexcop_device *fc)\r\n{\r\nflexcop_frontend_exit(fc);\r\nflexcop_i2c_exit(fc);\r\nflexcop_dvb_exit(fc);\r\n}\r\nstatic int flexcop_module_init(void)\r\n{\r\ninfo(DRIVER_NAME " loaded successfully");\r\nreturn 0;\r\n}\r\nstatic void flexcop_module_cleanup(void)\r\n{\r\ninfo(DRIVER_NAME " unloaded successfully");\r\n}
