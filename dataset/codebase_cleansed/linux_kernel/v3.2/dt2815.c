static int __init driver_dt2815_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_dt2815);\r\n}\r\nstatic void __exit driver_dt2815_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_dt2815);\r\n}\r\nstatic int dt2815_wait_for_status(struct comedi_device *dev, int status)\r\n{\r\nint i;\r\nfor (i = 0; i < 100; i++) {\r\nif (inb(dev->iobase + DT2815_STATUS) == status)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic int dt2815_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn i;\r\n}\r\nstatic int dt2815_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nunsigned int status;\r\nunsigned int lo, hi;\r\nfor (i = 0; i < insn->n; i++) {\r\nlo = ((data[i] & 0x0f) << 4) | (chan << 1) | 0x01;\r\nhi = (data[i] & 0xff0) >> 4;\r\nstatus = dt2815_wait_for_status(dev, 0x00);\r\nif (status != 0) {\r\nprintk(KERN_WARNING "dt2815: failed to write low byte "\r\n"on %d reason %x\n", chan, status);\r\nreturn -EBUSY;\r\n}\r\noutb(lo, dev->iobase + DT2815_DATA);\r\nstatus = dt2815_wait_for_status(dev, 0x10);\r\nif (status != 0x10) {\r\nprintk(KERN_WARNING "dt2815: failed to write high byte "\r\n"on %d reason %x\n", chan, status);\r\nreturn -EBUSY;\r\n}\r\ndevpriv->ao_readback[chan] = data[i];\r\n}\r\nreturn i;\r\n}\r\nstatic int dt2815_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint i;\r\nconst struct comedi_lrange *current_range_type, *voltage_range_type;\r\nunsigned long iobase;\r\niobase = it->options[0];\r\nprintk(KERN_INFO "comedi%d: dt2815: 0x%04lx ", dev->minor, iobase);\r\nif (!request_region(iobase, DT2815_SIZE, "dt2815")) {\r\nprintk(KERN_WARNING "I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\ndev->board_name = "dt2815";\r\nif (alloc_subdevices(dev, 1) < 0)\r\nreturn -ENOMEM;\r\nif (alloc_private(dev, sizeof(struct dt2815_private)) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->maxdata = 0xfff;\r\ns->n_chan = 8;\r\ns->insn_write = dt2815_ao_insn;\r\ns->insn_read = dt2815_ao_insn_read;\r\ns->range_table_list = devpriv->range_type_list;\r\ncurrent_range_type = (it->options[3])\r\n? &range_dt2815_ao_20_current : &range_dt2815_ao_32_current;\r\nvoltage_range_type = (it->options[2])\r\n? &range_bipolar5 : &range_unipolar5;\r\nfor (i = 0; i < 8; i++) {\r\ndevpriv->range_type_list[i] = (it->options[5 + i])\r\n? current_range_type : voltage_range_type;\r\n}\r\noutb(0x00, dev->iobase + DT2815_STATUS);\r\nfor (i = 0; i < 100; i++) {\r\nunsigned int status;\r\nudelay(1000);\r\nstatus = inb(dev->iobase + DT2815_STATUS);\r\nif (status == 4) {\r\nunsigned int program;\r\nprogram = (it->options[4] & 0x3) << 3 | 0x7;\r\noutb(program, dev->iobase + DT2815_DATA);\r\nprintk(KERN_INFO ", program: 0x%x (@t=%d)\n",\r\nprogram, i);\r\nbreak;\r\n} else if (status != 0x00) {\r\nprintk(KERN_WARNING "dt2815: unexpected status 0x%x "\r\n"(@t=%d)\n", status, i);\r\nif (status & 0x60)\r\noutb(0x00, dev->iobase + DT2815_STATUS);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dt2815_free_resources(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, DT2815_SIZE);\r\n}\r\nstatic int dt2815_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_INFO "comedi%d: dt2815: remove\n", dev->minor);\r\ndt2815_free_resources(dev);\r\nreturn 0;\r\n}
