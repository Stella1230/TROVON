void dbll_close(struct dbll_library_obj *zl_lib)\r\n{\r\nstruct dbll_tar_obj *zl_target;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_lib);\r\nDBC_REQUIRE(zl_lib->open_ref > 0);\r\nzl_target = zl_lib->target_obj;\r\nzl_lib->open_ref--;\r\nif (zl_lib->open_ref == 0) {\r\nif (zl_target->head == zl_lib)\r\nzl_target->head = zl_lib->next;\r\nif (zl_lib->prev)\r\n(zl_lib->prev)->next = zl_lib->next;\r\nif (zl_lib->next)\r\n(zl_lib->next)->prev = zl_lib->prev;\r\ndof_close(zl_lib);\r\nkfree(zl_lib->file_name);\r\nif (zl_lib->sym_tab)\r\ngh_delete(zl_lib->sym_tab);\r\nkfree(zl_lib);\r\nzl_lib = NULL;\r\n}\r\n}\r\nint dbll_create(struct dbll_tar_obj **target_obj,\r\nstruct dbll_attrs *pattrs)\r\n{\r\nstruct dbll_tar_obj *pzl_target;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(pattrs != NULL);\r\nDBC_REQUIRE(target_obj != NULL);\r\npzl_target = kzalloc(sizeof(struct dbll_tar_obj), GFP_KERNEL);\r\nif (target_obj != NULL) {\r\nif (pzl_target == NULL) {\r\n*target_obj = NULL;\r\nstatus = -ENOMEM;\r\n} else {\r\npzl_target->attrs = *pattrs;\r\n*target_obj = (struct dbll_tar_obj *)pzl_target;\r\n}\r\nDBC_ENSURE((!status && *target_obj) ||\r\n(status && *target_obj == NULL));\r\n}\r\nreturn status;\r\n}\r\nvoid dbll_delete(struct dbll_tar_obj *target)\r\n{\r\nstruct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_target);\r\nkfree(zl_target);\r\n}\r\nvoid dbll_exit(void)\r\n{\r\nDBC_REQUIRE(refs > 0);\r\nrefs--;\r\nif (refs == 0)\r\ngh_exit();\r\nDBC_ENSURE(refs >= 0);\r\n}\r\nbool dbll_get_addr(struct dbll_library_obj *zl_lib, char *name,\r\nstruct dbll_sym_val **sym_val)\r\n{\r\nstruct dbll_symbol *sym;\r\nbool status = false;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_lib);\r\nDBC_REQUIRE(name != NULL);\r\nDBC_REQUIRE(sym_val != NULL);\r\nDBC_REQUIRE(zl_lib->sym_tab != NULL);\r\nsym = (struct dbll_symbol *)gh_find(zl_lib->sym_tab, name);\r\nif (sym != NULL) {\r\n*sym_val = &sym->value;\r\nstatus = true;\r\n}\r\ndev_dbg(bridge, "%s: lib: %p name: %s paddr: %p, status 0x%x\n",\r\n__func__, zl_lib, name, sym_val, status);\r\nreturn status;\r\n}\r\nvoid dbll_get_attrs(struct dbll_tar_obj *target, struct dbll_attrs *pattrs)\r\n{\r\nstruct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_target);\r\nDBC_REQUIRE(pattrs != NULL);\r\nif ((pattrs != NULL) && (zl_target != NULL))\r\n*pattrs = zl_target->attrs;\r\n}\r\nbool dbll_get_c_addr(struct dbll_library_obj *zl_lib, char *name,\r\nstruct dbll_sym_val **sym_val)\r\n{\r\nstruct dbll_symbol *sym;\r\nchar cname[MAXEXPR + 1];\r\nbool status = false;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_lib);\r\nDBC_REQUIRE(sym_val != NULL);\r\nDBC_REQUIRE(zl_lib->sym_tab != NULL);\r\nDBC_REQUIRE(name != NULL);\r\ncname[0] = '_';\r\nstrncpy(cname + 1, name, sizeof(cname) - 2);\r\ncname[MAXEXPR] = '\0';\r\nsym = (struct dbll_symbol *)gh_find(zl_lib->sym_tab, cname);\r\nif (sym != NULL) {\r\n*sym_val = &sym->value;\r\nstatus = true;\r\n}\r\nreturn status;\r\n}\r\nint dbll_get_sect(struct dbll_library_obj *lib, char *name, u32 *paddr,\r\nu32 *psize)\r\n{\r\nu32 byte_size;\r\nbool opened_doff = false;\r\nconst struct ldr_section_info *sect = NULL;\r\nstruct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(name != NULL);\r\nDBC_REQUIRE(paddr != NULL);\r\nDBC_REQUIRE(psize != NULL);\r\nDBC_REQUIRE(zl_lib);\r\nif (zl_lib != NULL) {\r\nif (zl_lib->fp == NULL) {\r\nstatus = dof_open(zl_lib);\r\nif (!status)\r\nopened_doff = true;\r\n} else {\r\n(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,\r\nzl_lib->pos,\r\nSEEK_SET);\r\n}\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nif (!status) {\r\nbyte_size = 1;\r\nif (dload_get_section_info(zl_lib->desc, name, &sect)) {\r\n*paddr = sect->load_addr;\r\n*psize = sect->size * byte_size;\r\nif (*psize % 2)\r\n(*psize)++;\r\n*psize = DOFF_ALIGN(*psize);\r\n} else {\r\nstatus = -ENXIO;\r\n}\r\n}\r\nif (opened_doff) {\r\ndof_close(zl_lib);\r\nopened_doff = false;\r\n}\r\ndev_dbg(bridge, "%s: lib: %p name: %s paddr: %p psize: %p, "\r\n"status 0x%x\n", __func__, lib, name, paddr, psize, status);\r\nreturn status;\r\n}\r\nbool dbll_init(void)\r\n{\r\nDBC_REQUIRE(refs >= 0);\r\nif (refs == 0)\r\ngh_init();\r\nrefs++;\r\nreturn true;\r\n}\r\nint dbll_load(struct dbll_library_obj *lib, dbll_flags flags,\r\nstruct dbll_attrs *attrs, u32 *entry)\r\n{\r\nstruct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;\r\nstruct dbll_tar_obj *dbzl;\r\nbool got_symbols = true;\r\ns32 err;\r\nint status = 0;\r\nbool opened_doff = false;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_lib);\r\nDBC_REQUIRE(entry != NULL);\r\nDBC_REQUIRE(attrs != NULL);\r\nif (zl_lib->load_ref == 0 || !(flags & DBLL_DYNAMIC)) {\r\ndbzl = zl_lib->target_obj;\r\ndbzl->attrs = *attrs;\r\nif (zl_lib->sym_tab == NULL) {\r\ngot_symbols = false;\r\nzl_lib->sym_tab = gh_create(MAXBUCKETS,\r\nsizeof(struct dbll_symbol),\r\nname_hash,\r\nname_match, sym_delete);\r\nif (zl_lib->sym_tab == NULL)\r\nstatus = -ENOMEM;\r\n}\r\nzl_lib->stream.dl_stream.read_buffer = dbll_read_buffer;\r\nzl_lib->stream.dl_stream.set_file_posn = dbll_set_file_posn;\r\nzl_lib->stream.lib = zl_lib;\r\nzl_lib->symbol.dl_symbol.find_matching_symbol =\r\ndbll_find_symbol;\r\nif (got_symbols) {\r\nzl_lib->symbol.dl_symbol.add_to_symbol_table =\r\nfind_in_symbol_table;\r\n} else {\r\nzl_lib->symbol.dl_symbol.add_to_symbol_table =\r\ndbll_add_to_symbol_table;\r\n}\r\nzl_lib->symbol.dl_symbol.purge_symbol_table =\r\ndbll_purge_symbol_table;\r\nzl_lib->symbol.dl_symbol.dload_allocate = allocate;\r\nzl_lib->symbol.dl_symbol.dload_deallocate = deallocate;\r\nzl_lib->symbol.dl_symbol.error_report = dbll_err_report;\r\nzl_lib->symbol.lib = zl_lib;\r\nzl_lib->allocate.dl_alloc.dload_allocate = dbll_rmm_alloc;\r\nzl_lib->allocate.dl_alloc.dload_deallocate = rmm_dealloc;\r\nzl_lib->allocate.lib = zl_lib;\r\nzl_lib->init.dl_init.connect = connect;\r\nzl_lib->init.dl_init.readmem = read_mem;\r\nzl_lib->init.dl_init.writemem = write_mem;\r\nzl_lib->init.dl_init.fillmem = fill_mem;\r\nzl_lib->init.dl_init.execute = execute;\r\nzl_lib->init.dl_init.release = release;\r\nzl_lib->init.lib = zl_lib;\r\nif (zl_lib->fp == NULL) {\r\nstatus = dof_open(zl_lib);\r\nif (!status)\r\nopened_doff = true;\r\n}\r\nif (!status) {\r\nzl_lib->pos = (*(zl_lib->target_obj->attrs.ftell))\r\n(zl_lib->fp);\r\n(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,\r\n(long)0,\r\nSEEK_SET);\r\nsymbols_reloaded = true;\r\nerr = dynamic_load_module(&zl_lib->stream.dl_stream,\r\n&zl_lib->symbol.dl_symbol,\r\n&zl_lib->allocate.dl_alloc,\r\n&zl_lib->init.dl_init,\r\nDLOAD_INITBSS,\r\n&zl_lib->dload_mod_obj);\r\nif (err != 0) {\r\nstatus = -EILSEQ;\r\n} else if (redefined_symbol) {\r\nzl_lib->load_ref++;\r\ndbll_unload(zl_lib, (struct dbll_attrs *)attrs);\r\nredefined_symbol = false;\r\nstatus = -EILSEQ;\r\n} else {\r\n*entry = zl_lib->entry;\r\n}\r\n}\r\n}\r\nif (!status)\r\nzl_lib->load_ref++;\r\nif (opened_doff)\r\ndof_close(zl_lib);\r\nDBC_ENSURE(status || zl_lib->load_ref > 0);\r\ndev_dbg(bridge, "%s: lib: %p flags: 0x%x entry: %p, status 0x%x\n",\r\n__func__, lib, flags, entry, status);\r\nreturn status;\r\n}\r\nint dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,\r\nstruct dbll_library_obj **lib_obj)\r\n{\r\nstruct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;\r\nstruct dbll_library_obj *zl_lib = NULL;\r\ns32 err;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_target);\r\nDBC_REQUIRE(zl_target->attrs.fopen != NULL);\r\nDBC_REQUIRE(file != NULL);\r\nDBC_REQUIRE(lib_obj != NULL);\r\nzl_lib = zl_target->head;\r\nwhile (zl_lib != NULL) {\r\nif (strcmp(zl_lib->file_name, file) == 0) {\r\nzl_lib->open_ref++;\r\nbreak;\r\n}\r\nzl_lib = zl_lib->next;\r\n}\r\nif (zl_lib == NULL) {\r\nzl_lib = kzalloc(sizeof(struct dbll_library_obj), GFP_KERNEL);\r\nif (zl_lib == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nzl_lib->pos = 0;\r\nzl_lib->open_ref++;\r\nzl_lib->target_obj = zl_target;\r\nzl_lib->file_name = kzalloc(strlen(file) + 1,\r\nGFP_KERNEL);\r\nif (zl_lib->file_name == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nstrncpy(zl_lib->file_name, file,\r\nstrlen(file) + 1);\r\n}\r\nzl_lib->sym_tab = NULL;\r\n}\r\n}\r\nif (status)\r\ngoto func_cont;\r\nzl_lib->stream.dl_stream.read_buffer = dbll_read_buffer;\r\nzl_lib->stream.dl_stream.set_file_posn = dbll_set_file_posn;\r\nzl_lib->stream.lib = zl_lib;\r\nzl_lib->symbol.dl_symbol.add_to_symbol_table = dbll_add_to_symbol_table;\r\nzl_lib->symbol.dl_symbol.find_matching_symbol = dbll_find_symbol;\r\nzl_lib->symbol.dl_symbol.purge_symbol_table = dbll_purge_symbol_table;\r\nzl_lib->symbol.dl_symbol.dload_allocate = allocate;\r\nzl_lib->symbol.dl_symbol.dload_deallocate = deallocate;\r\nzl_lib->symbol.dl_symbol.error_report = dbll_err_report;\r\nzl_lib->symbol.lib = zl_lib;\r\nzl_lib->allocate.dl_alloc.dload_allocate = dbll_rmm_alloc;\r\nzl_lib->allocate.dl_alloc.dload_deallocate = rmm_dealloc;\r\nzl_lib->allocate.lib = zl_lib;\r\nzl_lib->init.dl_init.connect = connect;\r\nzl_lib->init.dl_init.readmem = read_mem;\r\nzl_lib->init.dl_init.writemem = write_mem;\r\nzl_lib->init.dl_init.fillmem = fill_mem;\r\nzl_lib->init.dl_init.execute = execute;\r\nzl_lib->init.dl_init.release = release;\r\nzl_lib->init.lib = zl_lib;\r\nif (!status && zl_lib->fp == NULL)\r\nstatus = dof_open(zl_lib);\r\nzl_lib->pos = (*(zl_lib->target_obj->attrs.ftell)) (zl_lib->fp);\r\n(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp, (long)0, SEEK_SET);\r\nif (zl_lib->sym_tab != NULL || !(flags & DBLL_SYMB))\r\ngoto func_cont;\r\nzl_lib->sym_tab =\r\ngh_create(MAXBUCKETS, sizeof(struct dbll_symbol), name_hash,\r\nname_match, sym_delete);\r\nif (zl_lib->sym_tab == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nzl_lib->init.dl_init.writemem = no_op;\r\nerr = dynamic_open_module(&zl_lib->stream.dl_stream,\r\n&zl_lib->symbol.dl_symbol,\r\n&zl_lib->allocate.dl_alloc,\r\n&zl_lib->init.dl_init, 0,\r\n&zl_lib->dload_mod_obj);\r\nif (err != 0) {\r\nstatus = -EILSEQ;\r\n} else {\r\nerr = dynamic_unload_module(zl_lib->dload_mod_obj,\r\n&zl_lib->symbol.dl_symbol,\r\n&zl_lib->allocate.dl_alloc,\r\n&zl_lib->init.dl_init);\r\nif (err != 0)\r\nstatus = -EILSEQ;\r\nzl_lib->dload_mod_obj = NULL;\r\n}\r\n}\r\nfunc_cont:\r\nif (!status) {\r\nif (zl_lib->open_ref == 1) {\r\nif (zl_target->head)\r\n(zl_target->head)->prev = zl_lib;\r\nzl_lib->prev = NULL;\r\nzl_lib->next = zl_target->head;\r\nzl_target->head = zl_lib;\r\n}\r\n*lib_obj = (struct dbll_library_obj *)zl_lib;\r\n} else {\r\n*lib_obj = NULL;\r\nif (zl_lib != NULL)\r\ndbll_close((struct dbll_library_obj *)zl_lib);\r\n}\r\nDBC_ENSURE((!status && (zl_lib->open_ref > 0) && *lib_obj)\r\n|| (status && *lib_obj == NULL));\r\ndev_dbg(bridge, "%s: target: %p file: %s lib_obj: %p, status 0x%x\n",\r\n__func__, target, file, lib_obj, status);\r\nreturn status;\r\n}\r\nint dbll_read_sect(struct dbll_library_obj *lib, char *name,\r\nchar *buf, u32 size)\r\n{\r\nstruct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;\r\nbool opened_doff = false;\r\nu32 byte_size;\r\nu32 ul_sect_size;\r\nconst struct ldr_section_info *sect = NULL;\r\nint status = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_lib);\r\nDBC_REQUIRE(name != NULL);\r\nDBC_REQUIRE(buf != NULL);\r\nDBC_REQUIRE(size != 0);\r\nif (zl_lib != NULL) {\r\nif (zl_lib->fp == NULL) {\r\nstatus = dof_open(zl_lib);\r\nif (!status)\r\nopened_doff = true;\r\n} else {\r\n(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,\r\nzl_lib->pos,\r\nSEEK_SET);\r\n}\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nif (status)\r\ngoto func_cont;\r\nbyte_size = 1;\r\nif (!dload_get_section_info(zl_lib->desc, name, &sect)) {\r\nstatus = -ENXIO;\r\ngoto func_cont;\r\n}\r\nul_sect_size = sect->size * byte_size;\r\nif (ul_sect_size % 2)\r\nul_sect_size++;\r\nul_sect_size = DOFF_ALIGN(ul_sect_size);\r\nif (ul_sect_size > size) {\r\nstatus = -EPERM;\r\n} else {\r\nif (!dload_get_section(zl_lib->desc, sect, buf))\r\nstatus = -EBADF;\r\n}\r\nfunc_cont:\r\nif (opened_doff) {\r\ndof_close(zl_lib);\r\nopened_doff = false;\r\n}\r\ndev_dbg(bridge, "%s: lib: %p name: %s buf: %p size: 0x%x, "\r\n"status 0x%x\n", __func__, lib, name, buf, size, status);\r\nreturn status;\r\n}\r\nvoid dbll_unload(struct dbll_library_obj *lib, struct dbll_attrs *attrs)\r\n{\r\nstruct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;\r\ns32 err = 0;\r\nDBC_REQUIRE(refs > 0);\r\nDBC_REQUIRE(zl_lib);\r\nDBC_REQUIRE(zl_lib->load_ref > 0);\r\ndev_dbg(bridge, "%s: lib: %p\n", __func__, lib);\r\nzl_lib->load_ref--;\r\nif (zl_lib->load_ref != 0)\r\ngoto func_end;\r\nzl_lib->target_obj->attrs = *attrs;\r\nif (zl_lib->dload_mod_obj) {\r\nerr = dynamic_unload_module(zl_lib->dload_mod_obj,\r\n&zl_lib->symbol.dl_symbol,\r\n&zl_lib->allocate.dl_alloc,\r\n&zl_lib->init.dl_init);\r\nif (err != 0)\r\ndev_dbg(bridge, "%s: failed: 0x%x\n", __func__, err);\r\n}\r\nif (zl_lib->sym_tab != NULL) {\r\ngh_delete(zl_lib->sym_tab);\r\nzl_lib->sym_tab = NULL;\r\n}\r\ndof_close(zl_lib);\r\nfunc_end:\r\nDBC_ENSURE(zl_lib->load_ref >= 0);\r\n}\r\nstatic void dof_close(struct dbll_library_obj *zl_lib)\r\n{\r\nif (zl_lib->desc) {\r\ndload_module_close(zl_lib->desc);\r\nzl_lib->desc = NULL;\r\n}\r\nif (zl_lib->fp) {\r\n(zl_lib->target_obj->attrs.fclose) (zl_lib->fp);\r\nzl_lib->fp = NULL;\r\n}\r\n}\r\nstatic int dof_open(struct dbll_library_obj *zl_lib)\r\n{\r\nvoid *open = *(zl_lib->target_obj->attrs.fopen);\r\nint status = 0;\r\nzl_lib->fp =\r\n(void *)((dbll_f_open_fxn) (open)) (zl_lib->file_name, "rb");\r\nif (zl_lib->fp && zl_lib->desc == NULL) {\r\n(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp, (long)0,\r\nSEEK_SET);\r\nzl_lib->desc =\r\ndload_module_open(&zl_lib->stream.dl_stream,\r\n&zl_lib->symbol.dl_symbol);\r\nif (zl_lib->desc == NULL) {\r\n(zl_lib->target_obj->attrs.fclose) (zl_lib->fp);\r\nzl_lib->fp = NULL;\r\nstatus = -EBADF;\r\n}\r\n} else {\r\nstatus = -EBADF;\r\n}\r\nreturn status;\r\n}\r\nstatic u16 name_hash(void *key, u16 max_bucket)\r\n{\r\nu16 ret;\r\nu16 hash;\r\nchar *name = (char *)key;\r\nDBC_REQUIRE(name != NULL);\r\nhash = 0;\r\nwhile (*name) {\r\nhash <<= 1;\r\nhash ^= *name++;\r\n}\r\nret = hash % max_bucket;\r\nreturn ret;\r\n}\r\nstatic bool name_match(void *key, void *sp)\r\n{\r\nDBC_REQUIRE(key != NULL);\r\nDBC_REQUIRE(sp != NULL);\r\nif ((key != NULL) && (sp != NULL)) {\r\nif (strcmp((char *)key, ((struct dbll_symbol *)sp)->name) ==\r\n0)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int no_op(struct dynamic_loader_initialize *thisptr, void *bufr,\r\nldr_addr locn, struct ldr_section_info *info, unsigned bytsize)\r\n{\r\nreturn 1;\r\n}\r\nstatic void sym_delete(void *value)\r\n{\r\nstruct dbll_symbol *sp = (struct dbll_symbol *)value;\r\nkfree(sp->name);\r\n}\r\nstatic int dbll_read_buffer(struct dynamic_loader_stream *this, void *buffer,\r\nunsigned bufsize)\r\n{\r\nstruct dbll_stream *pstream = (struct dbll_stream *)this;\r\nstruct dbll_library_obj *lib;\r\nint bytes_read = 0;\r\nDBC_REQUIRE(this != NULL);\r\nlib = pstream->lib;\r\nDBC_REQUIRE(lib);\r\nif (lib != NULL) {\r\nbytes_read =\r\n(*(lib->target_obj->attrs.fread)) (buffer, 1, bufsize,\r\nlib->fp);\r\n}\r\nreturn bytes_read;\r\n}\r\nstatic int dbll_set_file_posn(struct dynamic_loader_stream *this,\r\nunsigned int pos)\r\n{\r\nstruct dbll_stream *pstream = (struct dbll_stream *)this;\r\nstruct dbll_library_obj *lib;\r\nint status = 0;\r\nDBC_REQUIRE(this != NULL);\r\nlib = pstream->lib;\r\nDBC_REQUIRE(lib);\r\nif (lib != NULL) {\r\nstatus = (*(lib->target_obj->attrs.fseek)) (lib->fp, (long)pos,\r\nSEEK_SET);\r\n}\r\nreturn status;\r\n}\r\nstatic struct dynload_symbol *dbll_find_symbol(struct dynamic_loader_sym *this,\r\nconst char *name)\r\n{\r\nstruct dynload_symbol *ret_sym;\r\nstruct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;\r\nstruct dbll_library_obj *lib;\r\nstruct dbll_sym_val *dbll_sym = NULL;\r\nbool status = false;\r\nDBC_REQUIRE(this != NULL);\r\nlib = ldr_sym->lib;\r\nDBC_REQUIRE(lib);\r\nif (lib != NULL) {\r\nif (lib->target_obj->attrs.sym_lookup) {\r\nstatus = (*(lib->target_obj->attrs.sym_lookup))\r\n(lib->target_obj->attrs.sym_handle,\r\nlib->target_obj->attrs.sym_arg,\r\nlib->target_obj->attrs.rmm_handle, name,\r\n&dbll_sym);\r\n} else {\r\nstatus = dbll_get_addr((struct dbll_library_obj *)lib,\r\n(char *)name, &dbll_sym);\r\nif (!status) {\r\nstatus =\r\ndbll_get_c_addr((struct dbll_library_obj *)\r\nlib, (char *)name,\r\n&dbll_sym);\r\n}\r\n}\r\n}\r\nif (!status && gbl_search)\r\ndev_dbg(bridge, "%s: Symbol not found: %s\n", __func__, name);\r\nDBC_ASSERT((status && (dbll_sym != NULL))\r\n|| (!status && (dbll_sym == NULL)));\r\nret_sym = (struct dynload_symbol *)dbll_sym;\r\nreturn ret_sym;\r\n}\r\nstatic struct dynload_symbol *find_in_symbol_table(struct dynamic_loader_sym\r\n*this, const char *name,\r\nunsigned moduleid)\r\n{\r\nstruct dynload_symbol *ret_sym;\r\nstruct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;\r\nstruct dbll_library_obj *lib;\r\nstruct dbll_symbol *sym;\r\nDBC_REQUIRE(this != NULL);\r\nlib = ldr_sym->lib;\r\nDBC_REQUIRE(lib);\r\nDBC_REQUIRE(lib->sym_tab != NULL);\r\nsym = (struct dbll_symbol *)gh_find(lib->sym_tab, (char *)name);\r\nret_sym = (struct dynload_symbol *)&sym->value;\r\nreturn ret_sym;\r\n}\r\nstatic struct dynload_symbol *dbll_add_to_symbol_table(struct dynamic_loader_sym\r\n*this, const char *name,\r\nunsigned module_id)\r\n{\r\nstruct dbll_symbol *sym_ptr = NULL;\r\nstruct dbll_symbol symbol;\r\nstruct dynload_symbol *dbll_sym = NULL;\r\nstruct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;\r\nstruct dbll_library_obj *lib;\r\nstruct dynload_symbol *ret;\r\nDBC_REQUIRE(this != NULL);\r\nDBC_REQUIRE(name);\r\nlib = ldr_sym->lib;\r\nDBC_REQUIRE(lib);\r\nif (!(lib->target_obj->attrs.base_image)) {\r\ngbl_search = false;\r\ndbll_sym = dbll_find_symbol(this, name);\r\ngbl_search = true;\r\nif (dbll_sym) {\r\nredefined_symbol = true;\r\ndev_dbg(bridge, "%s already defined in symbol table\n",\r\nname);\r\nreturn NULL;\r\n}\r\n}\r\nsymbol.name = kzalloc(strlen((char *const)name) + 1, GFP_KERNEL);\r\nif (symbol.name == NULL)\r\nreturn NULL;\r\nif (symbol.name != NULL) {\r\nstrncpy(symbol.name, (char *const)name,\r\nstrlen((char *const)name) + 1);\r\nsym_ptr =\r\n(struct dbll_symbol *)gh_insert(lib->sym_tab, (void *)name,\r\n(void *)&symbol);\r\nif (sym_ptr == NULL)\r\nkfree(symbol.name);\r\n}\r\nif (sym_ptr != NULL)\r\nret = (struct dynload_symbol *)&sym_ptr->value;\r\nelse\r\nret = NULL;\r\nreturn ret;\r\n}\r\nstatic void dbll_purge_symbol_table(struct dynamic_loader_sym *this,\r\nunsigned module_id)\r\n{\r\nstruct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;\r\nstruct dbll_library_obj *lib;\r\nDBC_REQUIRE(this != NULL);\r\nlib = ldr_sym->lib;\r\nDBC_REQUIRE(lib);\r\n}\r\nstatic void *allocate(struct dynamic_loader_sym *this, unsigned memsize)\r\n{\r\nstruct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;\r\nstruct dbll_library_obj *lib;\r\nvoid *buf;\r\nDBC_REQUIRE(this != NULL);\r\nlib = ldr_sym->lib;\r\nDBC_REQUIRE(lib);\r\nbuf = kzalloc(memsize, GFP_KERNEL);\r\nreturn buf;\r\n}\r\nstatic void deallocate(struct dynamic_loader_sym *this, void *mem_ptr)\r\n{\r\nstruct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;\r\nstruct dbll_library_obj *lib;\r\nDBC_REQUIRE(this != NULL);\r\nlib = ldr_sym->lib;\r\nDBC_REQUIRE(lib);\r\nkfree(mem_ptr);\r\n}\r\nstatic void dbll_err_report(struct dynamic_loader_sym *this, const char *errstr,\r\nva_list args)\r\n{\r\nstruct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;\r\nstruct dbll_library_obj *lib;\r\nchar temp_buf[MAXEXPR];\r\nDBC_REQUIRE(this != NULL);\r\nlib = ldr_sym->lib;\r\nDBC_REQUIRE(lib);\r\nvsnprintf((char *)temp_buf, MAXEXPR, (char *)errstr, args);\r\ndev_dbg(bridge, "%s\n", temp_buf);\r\n}\r\nstatic int dbll_rmm_alloc(struct dynamic_loader_allocate *this,\r\nstruct ldr_section_info *info, unsigned align)\r\n{\r\nstruct dbll_alloc *dbll_alloc_obj = (struct dbll_alloc *)this;\r\nstruct dbll_library_obj *lib;\r\nint status = 0;\r\nu32 mem_sect_type;\r\nstruct rmm_addr rmm_addr_obj;\r\ns32 ret = true;\r\nunsigned stype = DLOAD_SECTION_TYPE(info->type);\r\nchar *token = NULL;\r\nchar *sz_sec_last_token = NULL;\r\nchar *sz_last_token = NULL;\r\nchar *sz_sect_name = NULL;\r\nchar *psz_cur;\r\ns32 token_len = 0;\r\ns32 seg_id = -1;\r\ns32 req = -1;\r\ns32 count = 0;\r\nu32 alloc_size = 0;\r\nu32 run_addr_flag = 0;\r\nDBC_REQUIRE(this != NULL);\r\nlib = dbll_alloc_obj->lib;\r\nDBC_REQUIRE(lib);\r\nmem_sect_type =\r\n(stype == DLOAD_TEXT) ? DBLL_CODE : (stype ==\r\nDLOAD_BSS) ? DBLL_BSS :\r\nDBLL_DATA;\r\nDBC_REQUIRE(info->name);\r\ntoken_len = strlen((char *)(info->name)) + 1;\r\nsz_sect_name = kzalloc(token_len, GFP_KERNEL);\r\nsz_last_token = kzalloc(token_len, GFP_KERNEL);\r\nsz_sec_last_token = kzalloc(token_len, GFP_KERNEL);\r\nif (sz_sect_name == NULL || sz_sec_last_token == NULL ||\r\nsz_last_token == NULL) {\r\nstatus = -ENOMEM;\r\ngoto func_cont;\r\n}\r\nstrncpy(sz_sect_name, (char *)(info->name), token_len);\r\npsz_cur = sz_sect_name;\r\nwhile ((token = strsep(&psz_cur, ":")) && *token != '\0') {\r\nstrncpy(sz_sec_last_token, sz_last_token,\r\nstrlen(sz_last_token) + 1);\r\nstrncpy(sz_last_token, token, strlen(token) + 1);\r\ntoken = strsep(&psz_cur, ":");\r\ncount++;\r\n}\r\nif (count >= 3)\r\nstrict_strtol(sz_last_token, 10, (long *)&req);\r\nif ((req == 0) || (req == 1)) {\r\nif (strcmp(sz_sec_last_token, "DYN_DARAM") == 0) {\r\nseg_id = 0;\r\n} else {\r\nif (strcmp(sz_sec_last_token, "DYN_SARAM") == 0) {\r\nseg_id = 1;\r\n} else {\r\nif (strcmp(sz_sec_last_token,\r\n"DYN_EXTERNAL") == 0)\r\nseg_id = 2;\r\n}\r\n}\r\n}\r\nfunc_cont:\r\nkfree(sz_sect_name);\r\nsz_sect_name = NULL;\r\nkfree(sz_last_token);\r\nsz_last_token = NULL;\r\nkfree(sz_sec_last_token);\r\nsz_sec_last_token = NULL;\r\nif (mem_sect_type == DBLL_CODE)\r\nalloc_size = info->size + GEM_L1P_PREFETCH_SIZE;\r\nelse\r\nalloc_size = info->size;\r\nif (info->load_addr != info->run_addr)\r\nrun_addr_flag = 1;\r\nif (lib != NULL) {\r\nstatus =\r\n(lib->target_obj->attrs.alloc) (lib->target_obj->attrs.\r\nrmm_handle, mem_sect_type,\r\nalloc_size, align,\r\n(u32 *) &rmm_addr_obj,\r\nseg_id, req, false);\r\n}\r\nif (status) {\r\nret = false;\r\n} else {\r\ninfo->load_addr = rmm_addr_obj.addr * DSPWORDSIZE;\r\nif (!run_addr_flag)\r\ninfo->run_addr = info->load_addr;\r\ninfo->context = (u32) rmm_addr_obj.segid;\r\ndev_dbg(bridge, "%s: %s base = 0x%x len = 0x%x, "\r\n"info->run_addr 0x%x, info->load_addr 0x%x\n",\r\n__func__, info->name, info->load_addr / DSPWORDSIZE,\r\ninfo->size / DSPWORDSIZE, info->run_addr,\r\ninfo->load_addr);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rmm_dealloc(struct dynamic_loader_allocate *this,\r\nstruct ldr_section_info *info)\r\n{\r\nstruct dbll_alloc *dbll_alloc_obj = (struct dbll_alloc *)this;\r\nstruct dbll_library_obj *lib;\r\nu32 segid;\r\nint status = 0;\r\nunsigned stype = DLOAD_SECTION_TYPE(info->type);\r\nu32 mem_sect_type;\r\nu32 free_size = 0;\r\nmem_sect_type =\r\n(stype == DLOAD_TEXT) ? DBLL_CODE : (stype ==\r\nDLOAD_BSS) ? DBLL_BSS :\r\nDBLL_DATA;\r\nDBC_REQUIRE(this != NULL);\r\nlib = dbll_alloc_obj->lib;\r\nDBC_REQUIRE(lib);\r\nsegid = (u32) info->context;\r\nif (mem_sect_type == DBLL_CODE)\r\nfree_size = info->size + GEM_L1P_PREFETCH_SIZE;\r\nelse\r\nfree_size = info->size;\r\nif (lib != NULL) {\r\nstatus =\r\n(lib->target_obj->attrs.free) (lib->target_obj->attrs.\r\nsym_handle, segid,\r\ninfo->load_addr /\r\nDSPWORDSIZE, free_size,\r\nfalse);\r\n}\r\n}\r\nstatic int connect(struct dynamic_loader_initialize *this)\r\n{\r\nreturn true;\r\n}\r\nstatic int read_mem(struct dynamic_loader_initialize *this, void *buf,\r\nldr_addr addr, struct ldr_section_info *info,\r\nunsigned nbytes)\r\n{\r\nstruct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;\r\nstruct dbll_library_obj *lib;\r\nint bytes_read = 0;\r\nDBC_REQUIRE(this != NULL);\r\nlib = init_obj->lib;\r\nDBC_REQUIRE(lib);\r\nreturn bytes_read;\r\n}\r\nstatic int write_mem(struct dynamic_loader_initialize *this, void *buf,\r\nldr_addr addr, struct ldr_section_info *info,\r\nunsigned bytes)\r\n{\r\nstruct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;\r\nstruct dbll_library_obj *lib;\r\nstruct dbll_tar_obj *target_obj;\r\nstruct dbll_sect_info sect_info;\r\nu32 mem_sect_type;\r\nbool ret = true;\r\nDBC_REQUIRE(this != NULL);\r\nlib = init_obj->lib;\r\nif (!lib)\r\nreturn false;\r\ntarget_obj = lib->target_obj;\r\nmem_sect_type =\r\n(DLOAD_SECTION_TYPE(info->type) ==\r\nDLOAD_TEXT) ? DBLL_CODE : DBLL_DATA;\r\nif (target_obj && target_obj->attrs.write) {\r\nret =\r\n(*target_obj->attrs.write) (target_obj->attrs.input_params,\r\naddr, buf, bytes,\r\nmem_sect_type);\r\nif (target_obj->attrs.log_write) {\r\nsect_info.name = info->name;\r\nsect_info.sect_run_addr = info->run_addr;\r\nsect_info.sect_load_addr = info->load_addr;\r\nsect_info.size = info->size;\r\nsect_info.type = mem_sect_type;\r\n(*target_obj->attrs.log_write) (target_obj->attrs.\r\nlog_write_handle,\r\n&sect_info, addr,\r\nbytes);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int fill_mem(struct dynamic_loader_initialize *this, ldr_addr addr,\r\nstruct ldr_section_info *info, unsigned bytes, unsigned val)\r\n{\r\nbool ret = true;\r\nchar *pbuf;\r\nstruct dbll_library_obj *lib;\r\nstruct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;\r\nDBC_REQUIRE(this != NULL);\r\nlib = init_obj->lib;\r\npbuf = NULL;\r\nif ((lib->target_obj->attrs.write) != (dbll_write_fxn) no_op)\r\nwrite_mem(this, &pbuf, addr, info, 0);\r\nif (pbuf)\r\nmemset(pbuf, val, bytes);\r\nreturn ret;\r\n}\r\nstatic int execute(struct dynamic_loader_initialize *this, ldr_addr start)\r\n{\r\nstruct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;\r\nstruct dbll_library_obj *lib;\r\nbool ret = true;\r\nDBC_REQUIRE(this != NULL);\r\nlib = init_obj->lib;\r\nDBC_REQUIRE(lib);\r\nif (lib != NULL)\r\nlib->entry = (u32) start;\r\nreturn ret;\r\n}\r\nstatic void release(struct dynamic_loader_initialize *this)\r\n{\r\n}\r\nvoid find_symbol_callback(void *elem, void *user_data)\r\n{\r\nstruct dbll_symbol *symbol = elem;\r\nstruct find_symbol_context *context = user_data;\r\nu32 symbol_addr = symbol->value.value;\r\nu32 offset = context->address - symbol_addr;\r\nif (context->address >= symbol_addr && symbol_addr < (u32)-1 &&\r\noffset < context->cur_best_offset) {\r\ncontext->cur_best_offset = offset;\r\ncontext->sym_addr = symbol_addr;\r\nstrncpy(context->name, symbol->name, sizeof(context->name));\r\n}\r\nreturn;\r\n}\r\nbool dbll_find_dsp_symbol(struct dbll_library_obj *zl_lib, u32 address,\r\nu32 offset_range, u32 *sym_addr_output,\r\nchar *name_output)\r\n{\r\nbool status = false;\r\nstruct find_symbol_context context;\r\ncontext.address = address;\r\ncontext.offset_range = offset_range;\r\ncontext.cur_best_offset = offset_range;\r\ncontext.sym_addr = 0;\r\ncontext.name[0] = '\0';\r\ngh_iterate(zl_lib->sym_tab, find_symbol_callback, &context);\r\nif (context.name[0]) {\r\nstatus = true;\r\nstrcpy(name_output, context.name);\r\n*sym_addr_output = context.sym_addr;\r\n}\r\nreturn status;\r\n}
