static inline int has_imm13(int insn)\r\n{\r\nreturn (insn & 0x2000);\r\n}\r\nstatic inline int is_foocc(int insn)\r\n{\r\nreturn (insn & 0x800000);\r\n}\r\nstatic inline int sign_extend_imm13(int imm)\r\n{\r\nreturn imm << 19 >> 19;\r\n}\r\nstatic inline void advance(struct pt_regs *regs)\r\n{\r\nregs->pc = regs->npc;\r\nregs->npc += 4;\r\n}\r\nstatic inline void maybe_flush_windows(unsigned int rs1, unsigned int rs2,\r\nunsigned int rd)\r\n{\r\nif(rs2 >= 16 || rs1 >= 16 || rd >= 16) {\r\n__asm__ __volatile__("save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"restore; restore; restore; restore;\n\t"\r\n"restore; restore; restore;\n\t");\r\n}\r\n}\r\nstatic inline int\r\nstore_reg(unsigned int result, unsigned int reg, struct pt_regs *regs)\r\n{\r\nstruct reg_window32 __user *win;\r\nif (!reg)\r\nreturn 0;\r\nif (reg < 16) {\r\nregs->u_regs[reg] = result;\r\nreturn 0;\r\n} else {\r\nwin = (struct reg_window32 __user *) regs->u_regs[UREG_FP];\r\nreturn (put_user(result, &win->locals[reg - 16]));\r\n}\r\n}\r\nint do_user_muldiv(struct pt_regs *regs, unsigned long pc)\r\n{\r\nunsigned int insn;\r\nint inst;\r\nunsigned int rs1, rs2, rdv;\r\nif (!pc)\r\nreturn -1;\r\nif (get_user (insn, (unsigned int __user *)pc))\r\nreturn -1;\r\nif ((insn & 0xc1400000) != 0x80400000)\r\nreturn -1;\r\ninst = ((insn >> 19) & 0xf);\r\nif ((inst & 0xe) != 10 && (inst & 0xe) != 14)\r\nreturn -1;\r\nrs1 = (insn >> 14) & 0x1f;\r\nrs2 = insn & 0x1f;\r\nrdv = (insn >> 25) & 0x1f;\r\nif (has_imm13(insn)) {\r\nmaybe_flush_windows(rs1, 0, rdv);\r\nrs2 = sign_extend_imm13(insn);\r\n} else {\r\nmaybe_flush_windows(rs1, rs2, rdv);\r\nrs2 = fetch_reg(rs2, regs);\r\n}\r\nrs1 = fetch_reg(rs1, regs);\r\nswitch (inst) {\r\ncase 10:\r\n#ifdef DEBUG_MULDIV\r\nprintk ("unsigned muldiv: 0x%x * 0x%x = ", rs1, rs2);\r\n#endif\r\n__asm__ __volatile__ ("\n\t"\r\n"mov %0, %%o0\n\t"\r\n"call .umul\n\t"\r\n" mov %1, %%o1\n\t"\r\n"mov %%o0, %0\n\t"\r\n"mov %%o1, %1\n\t"\r\n: "=r" (rs1), "=r" (rs2)\r\n: "0" (rs1), "1" (rs2)\r\n: "o0", "o1", "o2", "o3", "o4", "o5", "o7", "cc");\r\n#ifdef DEBUG_MULDIV\r\nprintk ("0x%x%08x\n", rs2, rs1);\r\n#endif\r\nif (store_reg(rs1, rdv, regs))\r\nreturn -1;\r\nregs->y = rs2;\r\nbreak;\r\ncase 11:\r\n#ifdef DEBUG_MULDIV\r\nprintk ("signed muldiv: 0x%x * 0x%x = ", rs1, rs2);\r\n#endif\r\n__asm__ __volatile__ ("\n\t"\r\n"mov %0, %%o0\n\t"\r\n"call .mul\n\t"\r\n" mov %1, %%o1\n\t"\r\n"mov %%o0, %0\n\t"\r\n"mov %%o1, %1\n\t"\r\n: "=r" (rs1), "=r" (rs2)\r\n: "0" (rs1), "1" (rs2)\r\n: "o0", "o1", "o2", "o3", "o4", "o5", "o7", "cc");\r\n#ifdef DEBUG_MULDIV\r\nprintk ("0x%x%08x\n", rs2, rs1);\r\n#endif\r\nif (store_reg(rs1, rdv, regs))\r\nreturn -1;\r\nregs->y = rs2;\r\nbreak;\r\ncase 14:\r\n#ifdef DEBUG_MULDIV\r\nprintk ("unsigned muldiv: 0x%x%08x / 0x%x = ", regs->y, rs1, rs2);\r\n#endif\r\nif (!rs2) {\r\n#ifdef DEBUG_MULDIV\r\nprintk ("DIVISION BY ZERO\n");\r\n#endif\r\nhandle_hw_divzero (regs, pc, regs->npc, regs->psr);\r\nreturn 0;\r\n}\r\n__asm__ __volatile__ ("\n\t"\r\n"mov %2, %%o0\n\t"\r\n"mov %0, %%o1\n\t"\r\n"mov %%g0, %%o2\n\t"\r\n"call __udivdi3\n\t"\r\n" mov %1, %%o3\n\t"\r\n"mov %%o1, %0\n\t"\r\n"mov %%o0, %1\n\t"\r\n: "=r" (rs1), "=r" (rs2)\r\n: "r" (regs->y), "0" (rs1), "1" (rs2)\r\n: "o0", "o1", "o2", "o3", "o4", "o5", "o7",\r\n"g1", "g2", "g3", "cc");\r\n#ifdef DEBUG_MULDIV\r\nprintk ("0x%x\n", rs1);\r\n#endif\r\nif (store_reg(rs1, rdv, regs))\r\nreturn -1;\r\nbreak;\r\ncase 15:\r\n#ifdef DEBUG_MULDIV\r\nprintk ("signed muldiv: 0x%x%08x / 0x%x = ", regs->y, rs1, rs2);\r\n#endif\r\nif (!rs2) {\r\n#ifdef DEBUG_MULDIV\r\nprintk ("DIVISION BY ZERO\n");\r\n#endif\r\nhandle_hw_divzero (regs, pc, regs->npc, regs->psr);\r\nreturn 0;\r\n}\r\n__asm__ __volatile__ ("\n\t"\r\n"mov %2, %%o0\n\t"\r\n"mov %0, %%o1\n\t"\r\n"mov %%g0, %%o2\n\t"\r\n"call __divdi3\n\t"\r\n" mov %1, %%o3\n\t"\r\n"mov %%o1, %0\n\t"\r\n"mov %%o0, %1\n\t"\r\n: "=r" (rs1), "=r" (rs2)\r\n: "r" (regs->y), "0" (rs1), "1" (rs2)\r\n: "o0", "o1", "o2", "o3", "o4", "o5", "o7",\r\n"g1", "g2", "g3", "cc");\r\n#ifdef DEBUG_MULDIV\r\nprintk ("0x%x\n", rs1);\r\n#endif\r\nif (store_reg(rs1, rdv, regs))\r\nreturn -1;\r\nbreak;\r\n}\r\nif (is_foocc (insn)) {\r\nregs->psr &= ~PSR_ICC;\r\nif ((inst & 0xe) == 14) {\r\nif (rs2) regs->psr |= PSR_V;\r\n}\r\nif (!rs1) regs->psr |= PSR_Z;\r\nif (((int)rs1) < 0) regs->psr |= PSR_N;\r\n#ifdef DEBUG_MULDIV\r\nprintk ("psr muldiv: %08x\n", regs->psr);\r\n#endif\r\n}\r\nadvance(regs);\r\nreturn 0;\r\n}
