static inline void color_imageblit(const struct fb_image *image,\r\nstruct fb_info *p, u8 __iomem *dst1,\r\nu32 start_index,\r\nu32 pitch_index)\r\n{\r\nu32 __iomem *dst, *dst2;\r\nu32 color = 0, val, shift;\r\nint i, n, bpp = p->var.bits_per_pixel;\r\nu32 null_bits = 32 - bpp;\r\nu32 *palette = (u32 *) p->pseudo_palette;\r\nconst u8 *src = image->data;\r\nu32 bswapmask = fb_compute_bswapmask(p);\r\ndst2 = (u32 __iomem *) dst1;\r\nfor (i = image->height; i--; ) {\r\nn = image->width;\r\ndst = (u32 __iomem *) dst1;\r\nshift = 0;\r\nval = 0;\r\nif (start_index) {\r\nu32 start_mask = ~fb_shifted_pixels_mask_u32(p,\r\nstart_index, bswapmask);\r\nval = FB_READL(dst) & start_mask;\r\nshift = start_index;\r\n}\r\nwhile (n--) {\r\nif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\r\np->fix.visual == FB_VISUAL_DIRECTCOLOR )\r\ncolor = palette[*src];\r\nelse\r\ncolor = *src;\r\ncolor <<= FB_LEFT_POS(p, bpp);\r\nval |= FB_SHIFT_HIGH(p, color, shift ^ bswapmask);\r\nif (shift >= null_bits) {\r\nFB_WRITEL(val, dst++);\r\nval = (shift == null_bits) ? 0 :\r\nFB_SHIFT_LOW(p, color, 32 - shift);\r\n}\r\nshift += bpp;\r\nshift &= (32 - 1);\r\nsrc++;\r\n}\r\nif (shift) {\r\nu32 end_mask = fb_shifted_pixels_mask_u32(p, shift,\r\nbswapmask);\r\nFB_WRITEL((FB_READL(dst) & end_mask) | val, dst);\r\n}\r\ndst1 += p->fix.line_length;\r\nif (pitch_index) {\r\ndst2 += p->fix.line_length;\r\ndst1 = (u8 __iomem *)((long __force)dst2 & ~(sizeof(u32) - 1));\r\nstart_index += pitch_index;\r\nstart_index &= 32 - 1;\r\n}\r\n}\r\n}\r\nstatic inline void slow_imageblit(const struct fb_image *image, struct fb_info *p,\r\nu8 __iomem *dst1, u32 fgcolor,\r\nu32 bgcolor,\r\nu32 start_index,\r\nu32 pitch_index)\r\n{\r\nu32 shift, color = 0, bpp = p->var.bits_per_pixel;\r\nu32 __iomem *dst, *dst2;\r\nu32 val, pitch = p->fix.line_length;\r\nu32 null_bits = 32 - bpp;\r\nu32 spitch = (image->width+7)/8;\r\nconst u8 *src = image->data, *s;\r\nu32 i, j, l;\r\nu32 bswapmask = fb_compute_bswapmask(p);\r\ndst2 = (u32 __iomem *) dst1;\r\nfgcolor <<= FB_LEFT_POS(p, bpp);\r\nbgcolor <<= FB_LEFT_POS(p, bpp);\r\nfor (i = image->height; i--; ) {\r\nshift = val = 0;\r\nl = 8;\r\nj = image->width;\r\ndst = (u32 __iomem *) dst1;\r\ns = src;\r\nif (start_index) {\r\nu32 start_mask = ~fb_shifted_pixels_mask_u32(p,\r\nstart_index, bswapmask);\r\nval = FB_READL(dst) & start_mask;\r\nshift = start_index;\r\n}\r\nwhile (j--) {\r\nl--;\r\ncolor = (*s & (1 << l)) ? fgcolor : bgcolor;\r\nval |= FB_SHIFT_HIGH(p, color, shift ^ bswapmask);\r\nif (shift >= null_bits) {\r\nFB_WRITEL(val, dst++);\r\nval = (shift == null_bits) ? 0 :\r\nFB_SHIFT_LOW(p, color, 32 - shift);\r\n}\r\nshift += bpp;\r\nshift &= (32 - 1);\r\nif (!l) { l = 8; s++; };\r\n}\r\nif (shift) {\r\nu32 end_mask = fb_shifted_pixels_mask_u32(p, shift,\r\nbswapmask);\r\nFB_WRITEL((FB_READL(dst) & end_mask) | val, dst);\r\n}\r\ndst1 += pitch;\r\nsrc += spitch;\r\nif (pitch_index) {\r\ndst2 += pitch;\r\ndst1 = (u8 __iomem *)((long __force)dst2 & ~(sizeof(u32) - 1));\r\nstart_index += pitch_index;\r\nstart_index &= 32 - 1;\r\n}\r\n}\r\n}\r\nstatic inline void fast_imageblit(const struct fb_image *image, struct fb_info *p,\r\nu8 __iomem *dst1, u32 fgcolor,\r\nu32 bgcolor)\r\n{\r\nu32 fgx = fgcolor, bgx = bgcolor, bpp = p->var.bits_per_pixel;\r\nu32 ppw = 32/bpp, spitch = (image->width + 7)/8;\r\nu32 bit_mask, end_mask, eorx, shift;\r\nconst char *s = image->data, *src;\r\nu32 __iomem *dst;\r\nconst u32 *tab = NULL;\r\nint i, j, k;\r\nswitch (bpp) {\r\ncase 8:\r\ntab = fb_be_math(p) ? cfb_tab8_be : cfb_tab8_le;\r\nbreak;\r\ncase 16:\r\ntab = fb_be_math(p) ? cfb_tab16_be : cfb_tab16_le;\r\nbreak;\r\ncase 32:\r\ndefault:\r\ntab = cfb_tab32;\r\nbreak;\r\n}\r\nfor (i = ppw-1; i--; ) {\r\nfgx <<= bpp;\r\nbgx <<= bpp;\r\nfgx |= fgcolor;\r\nbgx |= bgcolor;\r\n}\r\nbit_mask = (1 << ppw) - 1;\r\neorx = fgx ^ bgx;\r\nk = image->width/ppw;\r\nfor (i = image->height; i--; ) {\r\ndst = (u32 __iomem *) dst1, shift = 8; src = s;\r\nfor (j = k; j--; ) {\r\nshift -= ppw;\r\nend_mask = tab[(*src >> shift) & bit_mask];\r\nFB_WRITEL((end_mask & eorx)^bgx, dst++);\r\nif (!shift) { shift = 8; src++; }\r\n}\r\ndst1 += p->fix.line_length;\r\ns += spitch;\r\n}\r\n}\r\nvoid cfb_imageblit(struct fb_info *p, const struct fb_image *image)\r\n{\r\nu32 fgcolor, bgcolor, start_index, bitstart, pitch_index = 0;\r\nu32 bpl = sizeof(u32), bpp = p->var.bits_per_pixel;\r\nu32 width = image->width;\r\nu32 dx = image->dx, dy = image->dy;\r\nu8 __iomem *dst1;\r\nif (p->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nbitstart = (dy * p->fix.line_length * 8) + (dx * bpp);\r\nstart_index = bitstart & (32 - 1);\r\npitch_index = (p->fix.line_length & (bpl - 1)) * 8;\r\nbitstart /= 8;\r\nbitstart &= ~(bpl - 1);\r\ndst1 = p->screen_base + bitstart;\r\nif (p->fbops->fb_sync)\r\np->fbops->fb_sync(p);\r\nif (image->depth == 1) {\r\nif (p->fix.visual == FB_VISUAL_TRUECOLOR ||\r\np->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nfgcolor = ((u32*)(p->pseudo_palette))[image->fg_color];\r\nbgcolor = ((u32*)(p->pseudo_palette))[image->bg_color];\r\n} else {\r\nfgcolor = image->fg_color;\r\nbgcolor = image->bg_color;\r\n}\r\nif (32 % bpp == 0 && !start_index && !pitch_index &&\r\n((width & (32/bpp-1)) == 0) &&\r\nbpp >= 8 && bpp <= 32)\r\nfast_imageblit(image, p, dst1, fgcolor, bgcolor);\r\nelse\r\nslow_imageblit(image, p, dst1, fgcolor, bgcolor,\r\nstart_index, pitch_index);\r\n} else\r\ncolor_imageblit(image, p, dst1, start_index, pitch_index);\r\n}
