static int or51132_writebuf(struct or51132_state *state, const u8 *buf, int len)\r\n{\r\nint err;\r\nstruct i2c_msg msg = { .addr = state->config->demod_address,\r\n.flags = 0, .buf = (u8*)buf, .len = len };\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {\r\nprintk(KERN_WARNING "or51132: I2C write (addr 0x%02x len %d) error: %d\n",\r\nmsg.addr, msg.len, err);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int or51132_readbuf(struct or51132_state *state, u8 *buf, int len)\r\n{\r\nint err;\r\nstruct i2c_msg msg = { .addr = state->config->demod_address,\r\n.flags = I2C_M_RD, .buf = buf, .len = len };\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {\r\nprintk(KERN_WARNING "or51132: I2C read (addr 0x%02x len %d) error: %d\n",\r\nmsg.addr, msg.len, err);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int or51132_readreg(struct or51132_state *state, u8 reg)\r\n{\r\nu8 buf[2] = { 0x04, reg };\r\nstruct i2c_msg msg[2] = {\r\n{.addr = state->config->demod_address, .flags = 0,\r\n.buf = buf, .len = 2 },\r\n{.addr = state->config->demod_address, .flags = I2C_M_RD,\r\n.buf = buf, .len = 2 }};\r\nint err;\r\nif ((err = i2c_transfer(state->i2c, msg, 2)) != 2) {\r\nprintk(KERN_WARNING "or51132: I2C error reading register %d: %d\n",\r\nreg, err);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn buf[0] | (buf[1] << 8);\r\n}\r\nstatic int or51132_load_firmware (struct dvb_frontend* fe, const struct firmware *fw)\r\n{\r\nstruct or51132_state* state = fe->demodulator_priv;\r\nstatic const u8 run_buf[] = {0x7F,0x01};\r\nu8 rec_buf[8];\r\nu32 firmwareAsize, firmwareBsize;\r\nint i,ret;\r\ndprintk("Firmware is %Zd bytes\n",fw->size);\r\nfirmwareAsize = le32_to_cpu(*((__le32*)fw->data));\r\ndprintk("FirmwareA is %i bytes\n",firmwareAsize);\r\nfirmwareBsize = le32_to_cpu(*((__le32*)(fw->data+4)));\r\ndprintk("FirmwareB is %i bytes\n",firmwareBsize);\r\nif ((ret = or51132_writebuf(state, &fw->data[8], firmwareAsize))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error 1\n");\r\nreturn ret;\r\n}\r\nif ((ret = or51132_writebuf(state, &fw->data[8+firmwareAsize],\r\nfirmwareBsize))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error 2\n");\r\nreturn ret;\r\n}\r\nif ((ret = or51132_writebuf(state, run_buf, 2))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error 3\n");\r\nreturn ret;\r\n}\r\nif ((ret = or51132_writebuf(state, run_buf, 2))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error 4\n");\r\nreturn ret;\r\n}\r\nmsleep(50);\r\nif ((ret = or51132_writebytes(state, 0x10, 0x10, 0x00))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error a\n");\r\nreturn ret;\r\n}\r\nif ((ret = or51132_writebytes(state, 0x04, 0x17))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error b\n");\r\nreturn ret;\r\n}\r\nif ((ret = or51132_writebytes(state, 0x00, 0x00))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error c\n");\r\nreturn ret;\r\n}\r\nfor (i=0;i<4;i++) {\r\nif ((ret = or51132_readbuf(state, &rec_buf[i*2], 2))) {\r\nprintk(KERN_WARNING\r\n"or51132: load_firmware error d - %d\n",i);\r\nreturn ret;\r\n}\r\n}\r\nprintk(KERN_WARNING\r\n"or51132: Version: %02X%02X%02X%02X-%02X%02X%02X%02X (%02X%01X-%01X-%02X%01X-%01X)\n",\r\nrec_buf[1],rec_buf[0],rec_buf[3],rec_buf[2],\r\nrec_buf[5],rec_buf[4],rec_buf[7],rec_buf[6],\r\nrec_buf[3],rec_buf[2]>>4,rec_buf[2]&0x0f,\r\nrec_buf[5],rec_buf[4]>>4,rec_buf[4]&0x0f);\r\nif ((ret = or51132_writebytes(state, 0x10, 0x00, 0x00))) {\r\nprintk(KERN_WARNING "or51132: load_firmware error e\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int or51132_init(struct dvb_frontend* fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int or51132_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int or51132_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int or51132_sleep(struct dvb_frontend* fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int or51132_setmode(struct dvb_frontend* fe)\r\n{\r\nstruct or51132_state* state = fe->demodulator_priv;\r\nu8 cmd_buf1[3] = {0x04, 0x01, 0x5f};\r\nu8 cmd_buf2[3] = {0x1c, 0x00, 0 };\r\ndprintk("setmode %d\n",(int)state->current_modulation);\r\nswitch (state->current_modulation) {\r\ncase VSB_8:\r\ncmd_buf1[2] = 0x50;\r\ncmd_buf2[1] = 0x03;\r\ncmd_buf2[2] = 0x06;\r\nbreak;\r\ncase QAM_AUTO:\r\ncmd_buf2[2] = 0x4f;\r\nbreak;\r\ncase QAM_256:\r\ncmd_buf2[2] = 0x45;\r\nbreak;\r\ncase QAM_64:\r\ncmd_buf2[2] = 0x43;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"or51132: setmode: Modulation set to unsupported value (%d)\n",\r\nstate->current_modulation);\r\nreturn -EINVAL;\r\n}\r\nif (or51132_writebuf(state, cmd_buf1, 3)) {\r\nprintk(KERN_WARNING "or51132: set_mode error 1\n");\r\nreturn -EREMOTEIO;\r\n}\r\ndprintk("set #1 to %02x\n", cmd_buf1[2]);\r\nif (or51132_writebuf(state, cmd_buf2, 3)) {\r\nprintk(KERN_WARNING "or51132: set_mode error 2\n");\r\nreturn -EREMOTEIO;\r\n}\r\ndprintk("set #6 to 0x%02x%02x\n", cmd_buf2[1], cmd_buf2[2]);\r\nreturn 0;\r\n}\r\nstatic int modulation_fw_class(fe_modulation_t modulation)\r\n{\r\nswitch(modulation) {\r\ncase VSB_8:\r\nreturn MOD_FWCLASS_VSB;\r\ncase QAM_AUTO:\r\ncase QAM_64:\r\ncase QAM_256:\r\nreturn MOD_FWCLASS_QAM;\r\ndefault:\r\nreturn MOD_FWCLASS_UNKNOWN;\r\n}\r\n}\r\nstatic int or51132_set_parameters(struct dvb_frontend* fe,\r\nstruct dvb_frontend_parameters *param)\r\n{\r\nint ret;\r\nstruct or51132_state* state = fe->demodulator_priv;\r\nconst struct firmware *fw;\r\nconst char *fwname;\r\nint clock_mode;\r\nif (modulation_fw_class(state->current_modulation) !=\r\nmodulation_fw_class(param->u.vsb.modulation)) {\r\nswitch(modulation_fw_class(param->u.vsb.modulation)) {\r\ncase MOD_FWCLASS_VSB:\r\ndprintk("set_parameters VSB MODE\n");\r\nfwname = OR51132_VSB_FIRMWARE;\r\nclock_mode = 0;\r\nbreak;\r\ncase MOD_FWCLASS_QAM:\r\ndprintk("set_parameters QAM MODE\n");\r\nfwname = OR51132_QAM_FIRMWARE;\r\nclock_mode = 1;\r\nbreak;\r\ndefault:\r\nprintk("or51132: Modulation type(%d) UNSUPPORTED\n",\r\nparam->u.vsb.modulation);\r\nreturn -1;\r\n}\r\nprintk("or51132: Waiting for firmware upload(%s)...\n",\r\nfwname);\r\nret = request_firmware(&fw, fwname, state->i2c->dev.parent);\r\nif (ret) {\r\nprintk(KERN_WARNING "or51132: No firmware up"\r\n"loaded(timeout or file not found?)\n");\r\nreturn ret;\r\n}\r\nret = or51132_load_firmware(fe, fw);\r\nrelease_firmware(fw);\r\nif (ret) {\r\nprintk(KERN_WARNING "or51132: Writing firmware to "\r\n"device failed!\n");\r\nreturn ret;\r\n}\r\nprintk("or51132: Firmware upload complete.\n");\r\nstate->config->set_ts_params(fe, clock_mode);\r\n}\r\nif (state->current_modulation != param->u.vsb.modulation) {\r\nstate->current_modulation = param->u.vsb.modulation;\r\nor51132_setmode(fe);\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe, param);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nor51132_setmode(fe);\r\nstate->current_frequency = param->frequency;\r\nreturn 0;\r\n}\r\nstatic int or51132_get_parameters(struct dvb_frontend* fe,\r\nstruct dvb_frontend_parameters *param)\r\n{\r\nstruct or51132_state* state = fe->demodulator_priv;\r\nint status;\r\nint retry = 1;\r\nstart:\r\nif ((status = or51132_readreg(state, 0x00)) < 0) {\r\nprintk(KERN_WARNING "or51132: get_parameters: error reading receiver status\n");\r\nreturn -EREMOTEIO;\r\n}\r\nswitch(status&0xff) {\r\ncase 0x06: param->u.vsb.modulation = VSB_8; break;\r\ncase 0x43: param->u.vsb.modulation = QAM_64; break;\r\ncase 0x45: param->u.vsb.modulation = QAM_256; break;\r\ndefault:\r\nif (retry--) goto start;\r\nprintk(KERN_WARNING "or51132: unknown status 0x%02x\n",\r\nstatus&0xff);\r\nreturn -EREMOTEIO;\r\n}\r\nparam->frequency = state->current_frequency;\r\nparam->inversion = INVERSION_AUTO;\r\nreturn 0;\r\n}\r\nstatic int or51132_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct or51132_state* state = fe->demodulator_priv;\r\nint reg;\r\nif ((reg = or51132_readreg(state, 0x00)) < 0) {\r\nprintk(KERN_WARNING "or51132: read_status: error reading receiver status: %d\n", reg);\r\n*status = 0;\r\nreturn -EREMOTEIO;\r\n}\r\ndprintk("%s: read_status %04x\n", __func__, reg);\r\nif (reg & 0x0100)\r\n*status = FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|\r\nFE_HAS_SYNC|FE_HAS_LOCK;\r\nelse\r\n*status = 0;\r\nreturn 0;\r\n}\r\nstatic u32 calculate_snr(u32 mse, u32 c)\r\n{\r\nif (mse == 0)\r\nreturn 0;\r\nmse = 2*intlog10(mse);\r\nif (mse > c) {\r\nreturn 0;\r\n}\r\nreturn 10*(c - mse);\r\n}\r\nstatic int or51132_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct or51132_state* state = fe->demodulator_priv;\r\nint noise, reg;\r\nu32 c, usK = 0;\r\nint retry = 1;\r\nstart:\r\nnoise = or51132_readreg(state, 0x02);\r\nif (noise < 0) {\r\nprintk(KERN_WARNING "or51132: read_snr: error reading equalizer\n");\r\nreturn -EREMOTEIO;\r\n}\r\ndprintk("read_snr noise (%d)\n", noise);\r\nreg = or51132_readreg(state, 0x00);\r\nif (reg < 0) {\r\nprintk(KERN_WARNING "or51132: read_snr: error reading receiver status\n");\r\nreturn -EREMOTEIO;\r\n}\r\nswitch (reg&0xff) {\r\ncase 0x06:\r\nif (reg & 0x1000) usK = 3 << 24;\r\ncase 0x43:\r\nc = 150204167;\r\nbreak;\r\ncase 0x45:\r\nc = 150290396;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "or51132: unknown status 0x%02x\n", reg&0xff);\r\nif (retry--) goto start;\r\nreturn -EREMOTEIO;\r\n}\r\ndprintk("%s: modulation %02x, NTSC rej O%s\n", __func__,\r\nreg&0xff, reg&0x1000?"n":"ff");\r\nstate->snr = calculate_snr(noise, c) - usK;\r\n*snr = (state->snr) >> 16;\r\ndprintk("%s: noise = 0x%08x, snr = %d.%02d dB\n", __func__, noise,\r\nstate->snr >> 24, (((state->snr>>8) & 0xffff) * 100) >> 16);\r\nreturn 0;\r\n}\r\nstatic int or51132_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct or51132_state* state = (struct or51132_state*) fe->demodulator_priv;\r\nu16 snr;\r\nint ret;\r\nret = fe->ops.read_snr(fe, &snr);\r\nif (ret != 0)\r\nreturn ret;\r\nif (state->snr >= 8960 * 0x10000)\r\n*strength = 0xffff;\r\nelse\r\n*strength = state->snr / 8960;\r\nreturn 0;\r\n}\r\nstatic int or51132_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fe_tune_settings)\r\n{\r\nfe_tune_settings->min_delay_ms = 500;\r\nfe_tune_settings->step_size = 0;\r\nfe_tune_settings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void or51132_release(struct dvb_frontend* fe)\r\n{\r\nstruct or51132_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* or51132_attach(const struct or51132_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct or51132_state* state = NULL;\r\nstate = kzalloc(sizeof(struct or51132_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->current_frequency = -1;\r\nstate->current_modulation = -1;\r\nmemcpy(&state->frontend.ops, &or51132_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\n}
