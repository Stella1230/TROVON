static inline int adt7462_read_word_data(struct i2c_client *client, u8 reg)\r\n{\r\nu16 foo;\r\nfoo = i2c_smbus_read_byte_data(client, reg);\r\nfoo |= ((u16)i2c_smbus_read_byte_data(client, reg + 1) << 8);\r\nreturn foo;\r\n}\r\nstatic int ADT7462_REG_FAN(int fan)\r\n{\r\nif (fan < 4)\r\nreturn ADT7462_REG_FAN_BASE_ADDR + (2 * fan);\r\nreturn ADT7462_REG_FAN2_BASE_ADDR + (2 * (fan - 4));\r\n}\r\nstatic int ADT7462_REG_VOLT_MAX(struct adt7462_data *data, int which)\r\n{\r\nswitch (which) {\r\ncase 0:\r\nif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\r\nreturn 0x7C;\r\nbreak;\r\ncase 1:\r\nreturn 0x69;\r\ncase 2:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\r\nreturn 0x7F;\r\nbreak;\r\ncase 3:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\r\nreturn 0x7E;\r\nbreak;\r\ncase 4:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT))\r\nreturn 0x4B;\r\nbreak;\r\ncase 5:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT))\r\nreturn 0x49;\r\nbreak;\r\ncase 6:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\r\nreturn 0x68;\r\nbreak;\r\ncase 7:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\r\nreturn 0x7D;\r\nbreak;\r\ncase 8:\r\nif (!(data->pin_cfg[2] & ADT7462_PIN26_VOLT_INPUT))\r\nreturn 0x6C;\r\nbreak;\r\ncase 9:\r\nif (!(data->pin_cfg[2] & ADT7462_PIN25_VOLT_INPUT))\r\nreturn 0x6B;\r\nbreak;\r\ncase 10:\r\nreturn 0x6A;\r\ncase 11:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn 0x50;\r\nbreak;\r\ncase 12:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn 0x4C;\r\nbreak;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int ADT7462_REG_VOLT_MIN(struct adt7462_data *data, int which)\r\n{\r\nswitch (which) {\r\ncase 0:\r\nif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\r\nreturn 0x6D;\r\nbreak;\r\ncase 1:\r\nreturn 0x72;\r\ncase 2:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\r\nreturn 0x6F;\r\nbreak;\r\ncase 3:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\r\nreturn 0x71;\r\nbreak;\r\ncase 4:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT))\r\nreturn 0x47;\r\nbreak;\r\ncase 5:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT))\r\nreturn 0x45;\r\nbreak;\r\ncase 6:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\r\nreturn 0x70;\r\nbreak;\r\ncase 7:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\r\nreturn 0x6E;\r\nbreak;\r\ncase 8:\r\nif (!(data->pin_cfg[2] & ADT7462_PIN26_VOLT_INPUT))\r\nreturn 0x75;\r\nbreak;\r\ncase 9:\r\nif (!(data->pin_cfg[2] & ADT7462_PIN25_VOLT_INPUT))\r\nreturn 0x74;\r\nbreak;\r\ncase 10:\r\nreturn 0x73;\r\ncase 11:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn 0x76;\r\nbreak;\r\ncase 12:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn 0x77;\r\nbreak;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int ADT7462_REG_VOLT(struct adt7462_data *data, int which)\r\n{\r\nswitch (which) {\r\ncase 0:\r\nif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\r\nreturn 0xA3;\r\nbreak;\r\ncase 1:\r\nreturn 0x90;\r\ncase 2:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\r\nreturn 0xA9;\r\nbreak;\r\ncase 3:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\r\nreturn 0xA7;\r\nbreak;\r\ncase 4:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT))\r\nreturn 0x8F;\r\nbreak;\r\ncase 5:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT))\r\nreturn 0x8B;\r\nbreak;\r\ncase 6:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\r\nreturn 0x96;\r\nbreak;\r\ncase 7:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\r\nreturn 0xA5;\r\nbreak;\r\ncase 8:\r\nif (!(data->pin_cfg[2] & ADT7462_PIN26_VOLT_INPUT))\r\nreturn 0x93;\r\nbreak;\r\ncase 9:\r\nif (!(data->pin_cfg[2] & ADT7462_PIN25_VOLT_INPUT))\r\nreturn 0x92;\r\nbreak;\r\ncase 10:\r\nreturn 0x91;\r\ncase 11:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn 0x94;\r\nbreak;\r\ncase 12:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn 0x95;\r\nbreak;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic const char *voltage_label(struct adt7462_data *data, int which)\r\n{\r\nswitch (which) {\r\ncase 0:\r\nif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\r\nreturn "+12V1";\r\nbreak;\r\ncase 1:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[1], ADT7462_PIN23)) {\r\ncase 0:\r\nreturn "Vccp1";\r\ncase 1:\r\nreturn "+2.5V";\r\ncase 2:\r\nreturn "+1.8V";\r\ncase 3:\r\nreturn "+1.5V";\r\n}\r\ncase 2:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\r\nreturn "+12V3";\r\nbreak;\r\ncase 3:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\r\nreturn "+5V";\r\nbreak;\r\ncase 4:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT)) {\r\nif (data->pin_cfg[1] & ADT7462_PIN19_INPUT)\r\nreturn "+0.9V";\r\nreturn "+1.25V";\r\n}\r\nbreak;\r\ncase 5:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT)) {\r\nif (data->pin_cfg[1] & ADT7462_PIN19_INPUT)\r\nreturn "+1.8V";\r\nreturn "+2.5V";\r\n}\r\nbreak;\r\ncase 6:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\r\nreturn "+3.3V";\r\nbreak;\r\ncase 7:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\r\nreturn "+12V2";\r\nbreak;\r\ncase 8:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN26)) {\r\ncase 0:\r\nreturn "Vbatt";\r\ncase 1:\r\nreturn "FSB_Vtt";\r\n}\r\nbreak;\r\ncase 9:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN25)) {\r\ncase 0:\r\nreturn "+3.3V";\r\ncase 1:\r\nreturn "+1.2V1";\r\n}\r\nbreak;\r\ncase 10:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN24)) {\r\ncase 0:\r\nreturn "Vccp2";\r\ncase 1:\r\nreturn "+2.5V";\r\ncase 2:\r\nreturn "+1.8V";\r\ncase 3:\r\nreturn "+1.5";\r\n}\r\ncase 11:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn "+1.5V ICH";\r\nbreak;\r\ncase 12:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn "+1.5V 3GPIO";\r\nbreak;\r\n}\r\nreturn "N/A";\r\n}\r\nstatic int voltage_multiplier(struct adt7462_data *data, int which)\r\n{\r\nswitch (which) {\r\ncase 0:\r\nif (!(data->pin_cfg[0] & ADT7462_PIN7_INPUT))\r\nreturn 62500;\r\nbreak;\r\ncase 1:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[1], ADT7462_PIN23)) {\r\ncase 0:\r\nif (data->pin_cfg[0] & ADT7462_VID_INPUT)\r\nreturn 12500;\r\nreturn 6250;\r\ncase 1:\r\nreturn 13000;\r\ncase 2:\r\nreturn 9400;\r\ncase 3:\r\nreturn 7800;\r\n}\r\ncase 2:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN22_INPUT))\r\nreturn 62500;\r\nbreak;\r\ncase 3:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN21_INPUT))\r\nreturn 26000;\r\nbreak;\r\ncase 4:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE3_INPUT)) {\r\nif (data->pin_cfg[1] & ADT7462_PIN19_INPUT)\r\nreturn 4690;\r\nreturn 6500;\r\n}\r\nbreak;\r\ncase 5:\r\nif (!(data->pin_cfg[0] & ADT7462_DIODE1_INPUT)) {\r\nif (data->pin_cfg[1] & ADT7462_PIN15_INPUT)\r\nreturn 9400;\r\nreturn 13000;\r\n}\r\nbreak;\r\ncase 6:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN13_INPUT))\r\nreturn 17200;\r\nbreak;\r\ncase 7:\r\nif (!(data->pin_cfg[1] & ADT7462_PIN8_INPUT))\r\nreturn 62500;\r\nbreak;\r\ncase 8:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN26)) {\r\ncase 0:\r\nreturn 15600;\r\ncase 1:\r\nreturn 6250;\r\n}\r\nbreak;\r\ncase 9:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN25)) {\r\ncase 0:\r\nreturn 17200;\r\ncase 1:\r\nreturn 6250;\r\n}\r\nbreak;\r\ncase 10:\r\nswitch (MASK_AND_SHIFT(data->pin_cfg[2], ADT7462_PIN24)) {\r\ncase 0:\r\nreturn 6250;\r\ncase 1:\r\nreturn 13000;\r\ncase 2:\r\nreturn 9400;\r\ncase 3:\r\nreturn 7800;\r\n}\r\ncase 11:\r\ncase 12:\r\nif (data->pin_cfg[3] >> ADT7462_PIN28_SHIFT ==\r\nADT7462_PIN28_VOLT &&\r\n!(data->pin_cfg[0] & ADT7462_VID_INPUT))\r\nreturn 7800;\r\n}\r\nreturn 0;\r\n}\r\nstatic int temp_enabled(struct adt7462_data *data, int which)\r\n{\r\nswitch (which) {\r\ncase 0:\r\ncase 2:\r\nreturn 1;\r\ncase 1:\r\nif (data->pin_cfg[0] & ADT7462_DIODE1_INPUT)\r\nreturn 1;\r\nbreak;\r\ncase 3:\r\nif (data->pin_cfg[0] & ADT7462_DIODE3_INPUT)\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *temp_label(struct adt7462_data *data, int which)\r\n{\r\nswitch (which) {\r\ncase 0:\r\nreturn "local";\r\ncase 1:\r\nif (data->pin_cfg[0] & ADT7462_DIODE1_INPUT)\r\nreturn "remote1";\r\nbreak;\r\ncase 2:\r\nreturn "remote2";\r\ncase 3:\r\nif (data->pin_cfg[0] & ADT7462_DIODE3_INPUT)\r\nreturn "remote3";\r\nbreak;\r\n}\r\nreturn "N/A";\r\n}\r\nstatic int find_trange_value(int trange)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_TRANGE_VALUES; i++)\r\nif (trange_values[i] == trange)\r\nreturn i;\r\nreturn -ENODEV;\r\n}\r\nstatic struct adt7462_data *adt7462_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nunsigned long local_jiffies = jiffies;\r\nint i;\r\nmutex_lock(&data->lock);\r\nif (time_before(local_jiffies, data->sensors_last_updated +\r\nSENSOR_REFRESH_INTERVAL)\r\n&& data->sensors_valid)\r\ngoto no_sensor_update;\r\nfor (i = 0; i < ADT7462_TEMP_COUNT; i++) {\r\ndata->temp_frac[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_TEMP_REG(i));\r\ndata->temp[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_TEMP_REG(i) + 1);\r\n}\r\nfor (i = 0; i < ADT7462_FAN_COUNT; i++)\r\ndata->fan[i] = adt7462_read_word_data(client,\r\nADT7462_REG_FAN(i));\r\ndata->fan_enabled = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_FAN_ENABLE);\r\nfor (i = 0; i < ADT7462_PWM_COUNT; i++)\r\ndata->pwm[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_PWM(i));\r\nfor (i = 0; i < ADT7462_PIN_CFG_REG_COUNT; i++)\r\ndata->pin_cfg[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_PIN_CFG(i));\r\nfor (i = 0; i < ADT7462_VOLT_COUNT; i++) {\r\nint reg = ADT7462_REG_VOLT(data, i);\r\nif (!reg)\r\ndata->voltages[i] = 0;\r\nelse\r\ndata->voltages[i] = i2c_smbus_read_byte_data(client,\r\nreg);\r\n}\r\ndata->alarms[0] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM1);\r\ndata->alarms[1] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM2);\r\ndata->alarms[2] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM3);\r\ndata->alarms[3] = i2c_smbus_read_byte_data(client, ADT7462_REG_ALARM4);\r\ndata->sensors_last_updated = local_jiffies;\r\ndata->sensors_valid = 1;\r\nno_sensor_update:\r\nif (time_before(local_jiffies, data->limits_last_updated +\r\nLIMIT_REFRESH_INTERVAL)\r\n&& data->limits_valid)\r\ngoto out;\r\nfor (i = 0; i < ADT7462_TEMP_COUNT; i++) {\r\ndata->temp_min[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_TEMP_MIN_REG(i));\r\ndata->temp_max[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_TEMP_MAX_REG(i));\r\n}\r\nfor (i = 0; i < ADT7462_FAN_COUNT; i++)\r\ndata->fan_min[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_FAN_MIN(i));\r\nfor (i = 0; i < ADT7462_VOLT_COUNT; i++) {\r\nint reg = ADT7462_REG_VOLT_MAX(data, i);\r\ndata->volt_max[i] =\r\n(reg ? i2c_smbus_read_byte_data(client, reg) : 0);\r\nreg = ADT7462_REG_VOLT_MIN(data, i);\r\ndata->volt_min[i] =\r\n(reg ? i2c_smbus_read_byte_data(client, reg) : 0);\r\n}\r\nfor (i = 0; i < ADT7462_PWM_COUNT; i++) {\r\ndata->pwm_min[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_PWM_MIN(i));\r\ndata->pwm_tmin[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_PWM_TMIN(i));\r\ndata->pwm_trange[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_PWM_TRANGE(i));\r\ndata->pwm_cfg[i] = i2c_smbus_read_byte_data(client,\r\nADT7462_REG_PWM_CFG(i));\r\n}\r\ndata->pwm_max = i2c_smbus_read_byte_data(client, ADT7462_REG_PWM_MAX);\r\ndata->cfg2 = i2c_smbus_read_byte_data(client, ADT7462_REG_CFG2);\r\ndata->limits_last_updated = local_jiffies;\r\ndata->limits_valid = 1;\r\nout:\r\nmutex_unlock(&data->lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nif (!temp_enabled(data, attr->index))\r\nreturn sprintf(buf, "0\n");\r\nreturn sprintf(buf, "%d\n", 1000 * (data->temp_min[attr->index] - 64));\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp) || !temp_enabled(data, attr->index))\r\nreturn -EINVAL;\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000) + 64;\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->temp_min[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_TEMP_MIN_REG(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nif (!temp_enabled(data, attr->index))\r\nreturn sprintf(buf, "0\n");\r\nreturn sprintf(buf, "%d\n", 1000 * (data->temp_max[attr->index] - 64));\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp) || !temp_enabled(data, attr->index))\r\nreturn -EINVAL;\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000) + 64;\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->temp_max[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_TEMP_MAX_REG(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nu8 frac = data->temp_frac[attr->index] >> TEMP_FRAC_OFFSET;\r\nif (!temp_enabled(data, attr->index))\r\nreturn sprintf(buf, "0\n");\r\nreturn sprintf(buf, "%d\n", 1000 * (data->temp[attr->index] - 64) +\r\n250 * frac);\r\n}\r\nstatic ssize_t show_temp_label(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%s\n", temp_label(data, attr->index));\r\n}\r\nstatic ssize_t show_volt_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nint x = voltage_multiplier(data, attr->index);\r\nx *= data->volt_max[attr->index];\r\nx /= 1000;\r\nreturn sprintf(buf, "%d\n", x);\r\n}\r\nstatic ssize_t set_volt_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nint x = voltage_multiplier(data, attr->index);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp) || !x)\r\nreturn -EINVAL;\r\ntemp *= 1000;\r\ntemp = DIV_ROUND_CLOSEST(temp, x);\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->volt_max[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client,\r\nADT7462_REG_VOLT_MAX(data, attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_volt_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nint x = voltage_multiplier(data, attr->index);\r\nx *= data->volt_min[attr->index];\r\nx /= 1000;\r\nreturn sprintf(buf, "%d\n", x);\r\n}\r\nstatic ssize_t set_volt_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nint x = voltage_multiplier(data, attr->index);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp) || !x)\r\nreturn -EINVAL;\r\ntemp *= 1000;\r\ntemp = DIV_ROUND_CLOSEST(temp, x);\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->volt_min[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client,\r\nADT7462_REG_VOLT_MIN(data, attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_voltage(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nint x = voltage_multiplier(data, attr->index);\r\nx *= data->voltages[attr->index];\r\nx /= 1000;\r\nreturn sprintf(buf, "%d\n", x);\r\n}\r\nstatic ssize_t show_voltage_label(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%s\n", voltage_label(data, attr->index));\r\n}\r\nstatic ssize_t show_alarm(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nint reg = attr->index >> ADT7462_ALARM_REG_SHIFT;\r\nint mask = attr->index & ADT7462_ALARM_FLAG_MASK;\r\nif (data->alarms[reg] & mask)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic int fan_enabled(struct adt7462_data *data, int fan)\r\n{\r\nreturn data->fan_enabled & (1 << fan);\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nu16 temp;\r\ntemp = data->fan_min[attr->index];\r\ntemp <<= 8;\r\nif (!fan_enabled(data, attr->index) ||\r\n!FAN_DATA_VALID(temp))\r\nreturn sprintf(buf, "0\n");\r\nreturn sprintf(buf, "%d\n", FAN_PERIOD_TO_RPM(temp));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp) || !temp ||\r\n!fan_enabled(data, attr->index))\r\nreturn -EINVAL;\r\ntemp = FAN_RPM_TO_PERIOD(temp);\r\ntemp >>= 8;\r\ntemp = SENSORS_LIMIT(temp, 1, 255);\r\nmutex_lock(&data->lock);\r\ndata->fan_min[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_FAN_MIN(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nif (!fan_enabled(data, attr->index) ||\r\n!FAN_DATA_VALID(data->fan[attr->index]))\r\nreturn sprintf(buf, "0\n");\r\nreturn sprintf(buf, "%d\n",\r\nFAN_PERIOD_TO_RPM(data->fan[attr->index]));\r\n}\r\nstatic ssize_t show_force_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->cfg2 & ADT7462_FSPD_MASK ? 1 : 0));\r\n}\r\nstatic ssize_t set_force_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nu8 reg;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nreg = i2c_smbus_read_byte_data(client, ADT7462_REG_CFG2);\r\nif (temp)\r\nreg |= ADT7462_FSPD_MASK;\r\nelse\r\nreg &= ~ADT7462_FSPD_MASK;\r\ndata->cfg2 = reg;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_CFG2, reg);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm[attr->index]);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->pwm[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_PWM(attr->index), temp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_max);\r\n}\r\nstatic ssize_t set_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->pwm_max = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_PWM_MAX, temp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_min[attr->index]);\r\n}\r\nstatic ssize_t set_pwm_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->pwm_min[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_PWM_MIN(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_hyst(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1000 *\r\n(data->pwm_trange[attr->index] & ADT7462_PWM_HYST_MASK));\r\n}\r\nstatic ssize_t set_pwm_hyst(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000);\r\ntemp = SENSORS_LIMIT(temp, 0, 15);\r\ntemp &= ADT7462_PWM_HYST_MASK;\r\ntemp |= data->pwm_trange[attr->index] & ADT7462_PWM_RANGE_MASK;\r\nmutex_lock(&data->lock);\r\ndata->pwm_trange[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_PWM_TRANGE(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_tmax(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nint trange = trange_values[data->pwm_trange[attr->index] >>\r\nADT7462_PWM_RANGE_SHIFT];\r\nint tmin = (data->pwm_tmin[attr->index] - 64) * 1000;\r\nreturn sprintf(buf, "%d\n", tmin + trange);\r\n}\r\nstatic ssize_t set_pwm_tmax(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint temp;\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nint tmin, trange_value;\r\nlong trange;\r\nif (strict_strtol(buf, 10, &trange))\r\nreturn -EINVAL;\r\ntmin = (data->pwm_tmin[attr->index] - 64) * 1000;\r\ntrange_value = find_trange_value(trange - tmin);\r\nif (trange_value < 0)\r\nreturn -EINVAL;\r\ntemp = trange_value << ADT7462_PWM_RANGE_SHIFT;\r\ntemp |= data->pwm_trange[attr->index] & ADT7462_PWM_HYST_MASK;\r\nmutex_lock(&data->lock);\r\ndata->pwm_trange[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_PWM_TRANGE(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_tmin(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1000 * (data->pwm_tmin[attr->index] - 64));\r\n}\r\nstatic ssize_t set_pwm_tmin(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000) + 64;\r\ntemp = SENSORS_LIMIT(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->pwm_tmin[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_PWM_TMIN(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nint cfg = data->pwm_cfg[attr->index] >> ADT7462_PWM_CHANNEL_SHIFT;\r\nswitch (cfg) {\r\ncase 4:\r\nreturn sprintf(buf, "0\n");\r\ncase 7:\r\nreturn sprintf(buf, "1\n");\r\ndefault:\r\nreturn sprintf(buf, "2\n");\r\n}\r\n}\r\nstatic void set_pwm_channel(struct i2c_client *client,\r\nstruct adt7462_data *data,\r\nint which,\r\nint value)\r\n{\r\nint temp = data->pwm_cfg[which] & ~ADT7462_PWM_CHANNEL_MASK;\r\ntemp |= value << ADT7462_PWM_CHANNEL_SHIFT;\r\nmutex_lock(&data->lock);\r\ndata->pwm_cfg[which] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7462_REG_PWM_CFG(which), temp);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic ssize_t set_pwm_auto(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\nswitch (temp) {\r\ncase 0:\r\nset_pwm_channel(client, data, attr->index, 4);\r\nreturn count;\r\ncase 1:\r\nset_pwm_channel(client, data, attr->index, 7);\r\nreturn count;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic ssize_t show_pwm_auto_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7462_data *data = adt7462_update_device(dev);\r\nint channel = data->pwm_cfg[attr->index] >> ADT7462_PWM_CHANNEL_SHIFT;\r\nswitch (channel) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nreturn sprintf(buf, "%d\n", (1 << channel));\r\ncase 5:\r\nreturn sprintf(buf, "9\n");\r\ncase 6:\r\nreturn sprintf(buf, "15\n");\r\ndefault:\r\nreturn sprintf(buf, "0\n");\r\n}\r\n}\r\nstatic int cvt_auto_temp(int input)\r\n{\r\nif (input == 0xF)\r\nreturn 6;\r\nif (input == 0x9)\r\nreturn 5;\r\nif (input < 1 || !is_power_of_2(input))\r\nreturn -EINVAL;\r\nreturn ilog2(input);\r\n}\r\nstatic ssize_t set_pwm_auto_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nif (strict_strtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = cvt_auto_temp(temp);\r\nif (temp < 0)\r\nreturn temp;\r\nset_pwm_channel(client, data, attr->index, temp);\r\nreturn count;\r\n}\r\nstatic int adt7462_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint vendor, device, revision;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nvendor = i2c_smbus_read_byte_data(client, ADT7462_REG_VENDOR);\r\nif (vendor != ADT7462_VENDOR)\r\nreturn -ENODEV;\r\ndevice = i2c_smbus_read_byte_data(client, ADT7462_REG_DEVICE);\r\nif (device != ADT7462_DEVICE)\r\nreturn -ENODEV;\r\nrevision = i2c_smbus_read_byte_data(client, ADT7462_REG_REVISION);\r\nif (revision != ADT7462_REVISION)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "adt7462", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int adt7462_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adt7462_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct adt7462_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->lock);\r\ndev_info(&client->dev, "%s chip found\n", client->name);\r\ndata->attrs.attrs = adt7462_attr;\r\nerr = sysfs_create_group(&client->dev.kobj, &data->attrs);\r\nif (err)\r\ngoto exit_free;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &data->attrs);\r\nexit_free:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int adt7462_remove(struct i2c_client *client)\r\n{\r\nstruct adt7462_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &data->attrs);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init adt7462_init(void)\r\n{\r\nreturn i2c_add_driver(&adt7462_driver);\r\n}\r\nstatic void __exit adt7462_exit(void)\r\n{\r\ni2c_del_driver(&adt7462_driver);\r\n}
