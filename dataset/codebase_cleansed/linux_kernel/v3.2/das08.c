static int das08_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i, n;\r\nint chan;\r\nint range;\r\nint lsb, msb;\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\ninb(dev->iobase + DAS08_LSB);\r\ninb(dev->iobase + DAS08_MSB);\r\nspin_lock(&dev->spinlock);\r\ndevpriv->do_mux_bits &= ~DAS08_MUX_MASK;\r\ndevpriv->do_mux_bits |= DAS08_MUX(chan);\r\noutb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL);\r\nspin_unlock(&dev->spinlock);\r\nif (s->range_table->length > 1) {\r\nrange = CR_RANGE(insn->chanspec);\r\noutb(devpriv->pg_gainlist[range],\r\ndev->iobase + DAS08AO_GAIN_CONTROL);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nif (thisboard->ai_nbits == 16)\r\nif (inb(dev->iobase + DAS08_MSB) & 0x80)\r\nprintk(KERN_INFO "das08: over-range\n");\r\noutb_p(0, dev->iobase + DAS08_TRIG_12BIT);\r\nfor (i = 0; i < TIMEOUT; i++) {\r\nif (!(inb(dev->iobase + DAS08_STATUS) & DAS08_EOC))\r\nbreak;\r\n}\r\nif (i == TIMEOUT) {\r\nprintk(KERN_ERR "das08: timeout\n");\r\nreturn -ETIME;\r\n}\r\nmsb = inb(dev->iobase + DAS08_MSB);\r\nlsb = inb(dev->iobase + DAS08_LSB);\r\nif (thisboard->ai_encoding == das08_encode12) {\r\ndata[n] = (lsb >> 4) | (msb << 4);\r\n} else if (thisboard->ai_encoding == das08_pcm_encode12) {\r\ndata[n] = (msb << 8) + lsb;\r\n} else if (thisboard->ai_encoding == das08_encode16) {\r\nif (msb & 0x80)\r\ndata[n] = (1 << 15) | lsb | ((msb & 0x7f) << 8);\r\nelse\r\ndata[n] = (1 << 15) - (lsb | (msb & 0x7f) << 8);\r\n} else {\r\ncomedi_error(dev, "bug! unknown ai encoding");\r\nreturn -1;\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic int das08_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = 0;\r\ndata[1] = DAS08_IP(inb(dev->iobase + DAS08_STATUS));\r\nreturn 2;\r\n}\r\nstatic int das08_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint wbits;\r\nwbits = (devpriv->do_mux_bits >> 4) & 0xf;\r\nwbits &= ~data[0];\r\nwbits |= data[0] & data[1];\r\nspin_lock(&dev->spinlock);\r\ndevpriv->do_mux_bits &= ~DAS08_DO_MASK;\r\ndevpriv->do_mux_bits |= DAS08_OP(wbits);\r\noutb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL);\r\nspin_unlock(&dev->spinlock);\r\ndata[1] = wbits;\r\nreturn 2;\r\n}\r\nstatic int das08jr_di_rbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = 0;\r\ndata[1] = inb(dev->iobase + DAS08JR_DIO);\r\nreturn 2;\r\n}\r\nstatic int das08jr_do_wbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndevpriv->do_bits &= ~data[0];\r\ndevpriv->do_bits |= data[0] & data[1];\r\noutb(devpriv->do_bits, dev->iobase + DAS08JR_DIO);\r\ndata[1] = devpriv->do_bits;\r\nreturn 2;\r\n}\r\nstatic int das08jr_ao_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint lsb, msb;\r\nint chan;\r\nlsb = data[0] & 0xff;\r\nmsb = (data[0] >> 8) & 0xf;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++) {\r\n#if 0\r\noutb(lsb, dev->iobase + devpriv->ao_offset_lsb[chan]);\r\noutb(msb, dev->iobase + devpriv->ao_offset_msb[chan]);\r\n#else\r\noutb(lsb, dev->iobase + DAS08JR_AO_LSB(chan));\r\noutb(msb, dev->iobase + DAS08JR_AO_MSB(chan));\r\n#endif\r\ninb(dev->iobase + DAS08JR_DIO);\r\n}\r\nreturn n;\r\n}\r\nstatic int das08ao_ao_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint lsb, msb;\r\nint chan;\r\nlsb = data[0] & 0xff;\r\nmsb = (data[0] >> 8) & 0xf;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++) {\r\n#if 0\r\noutb(lsb, dev->iobase + devpriv->ao_offset_lsb[chan]);\r\noutb(msb, dev->iobase + devpriv->ao_offset_msb[chan]);\r\n#else\r\noutb(lsb, dev->iobase + DAS08AO_AO_LSB(chan));\r\noutb(msb, dev->iobase + DAS08AO_AO_MSB(chan));\r\n#endif\r\ninb(dev->iobase + DAS08AO_AO_UPDATE);\r\n}\r\nreturn n;\r\n}\r\nstatic unsigned int i8254_read_channel_low(unsigned int base, int chan)\r\n{\r\nunsigned int msb, lsb;\r\noutb(chan << 6, base + I8254_CTRL);\r\nbase += chan;\r\nlsb = inb(base);\r\nmsb = inb(base);\r\nreturn lsb | (msb << 8);\r\n}\r\nstatic void i8254_write_channel_low(unsigned int base, int chan,\r\nunsigned int value)\r\n{\r\nunsigned int msb, lsb;\r\nlsb = value & 0xFF;\r\nmsb = value >> 8;\r\nbase += chan;\r\noutb(lsb, base);\r\noutb(msb, base);\r\n}\r\nstatic unsigned int i8254_read_channel(struct i8254_struct *st, int channel)\r\n{\r\nint chan = st->logic2phys[channel];\r\nreturn i8254_read_channel_low(st->iobase, chan);\r\n}\r\nstatic void i8254_write_channel(struct i8254_struct *st, int channel,\r\nunsigned int value)\r\n{\r\nint chan = st->logic2phys[channel];\r\ni8254_write_channel_low(st->iobase, chan, value);\r\n}\r\nstatic void i8254_initialize(struct i8254_struct *st)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; ++i)\r\ni8254_set_mode_low(st->iobase, i, st->mode[i]);\r\n}\r\nstatic void i8254_set_mode_low(unsigned int base, int channel,\r\nunsigned int mode)\r\n{\r\noutb((channel << 6) | 0x30 | (mode & 0x0F), base + I8254_CTRL);\r\n}\r\nstatic void i8254_set_mode(struct i8254_struct *st, int channel,\r\nunsigned int mode)\r\n{\r\nint chan = st->logic2phys[channel];\r\nst->mode[chan] = mode;\r\nreturn i8254_set_mode_low(st->iobase, chan, mode);\r\n}\r\nstatic unsigned int i8254_read_status_low(unsigned int base, int channel)\r\n{\r\noutb(0xE0 | (2 << channel), base + I8254_CTRL);\r\nreturn inb(base + channel);\r\n}\r\nstatic unsigned int i8254_read_status(struct i8254_struct *st, int channel)\r\n{\r\nint chan = st->logic2phys[channel];\r\nreturn i8254_read_status_low(st->iobase, chan);\r\n}\r\nstatic int das08_counter_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = insn->chanspec;\r\ndata[0] = i8254_read_channel(&devpriv->i8254, chan);\r\nreturn 1;\r\n}\r\nstatic int das08_counter_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = insn->chanspec;\r\ni8254_write_channel(&devpriv->i8254, chan, data[0]);\r\nreturn 1;\r\n}\r\nstatic int das08_counter_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = insn->chanspec;\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\ni8254_set_mode(&devpriv->i8254, chan, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_8254_READ_STATUS:\r\ndata[1] = i8254_read_status(&devpriv->i8254, chan);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 2;\r\n}\r\nint das08_common_attach(struct comedi_device *dev, unsigned long iobase)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nif ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {\r\nprintk(KERN_INFO " iobase 0x%lx\n", iobase);\r\nif (!request_region(iobase, thisboard->iosize, DRV_NAME)) {\r\nprintk(KERN_ERR " I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\n}\r\ndev->iobase = iobase;\r\ndev->board_name = thisboard->name;\r\nret = alloc_subdevices(dev, 6);\r\nif (ret < 0)\r\nreturn ret;\r\ns = dev->subdevices + 0;\r\nif (thisboard->ai) {\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = 8;\r\ns->maxdata = (1 << thisboard->ai_nbits) - 1;\r\ns->range_table = das08_ai_lranges[thisboard->ai_pg];\r\ns->insn_read = thisboard->ai;\r\ndevpriv->pg_gainlist = das08_gainlists[thisboard->ai_pg];\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 1;\r\nif (thisboard->ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = (1 << thisboard->ao_nbits) - 1;\r\ns->range_table = &range_bipolar5;\r\ns->insn_write = thisboard->ao;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 2;\r\nif (thisboard->di) {\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = (thisboard->di == das08_di_rbits) ? 3 : 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = thisboard->di;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 3;\r\nif (thisboard->do_) {\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = thisboard->do_nchan;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = thisboard->do_;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 4;\r\nif (thisboard->i8255_offset != 0) {\r\nsubdev_8255_init(dev, s, NULL, (unsigned long)(dev->iobase +\r\nthisboard->\r\ni8255_offset));\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 5;\r\nif (thisboard->i8254_offset != 0) {\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 3;\r\ns->maxdata = 0xFFFF;\r\ns->insn_read = das08_counter_read;\r\ns->insn_write = das08_counter_write;\r\ns->insn_config = das08_counter_config;\r\ndevpriv->i8254.channels = 3;\r\ndevpriv->i8254.logic2phys[0] = 0;\r\ndevpriv->i8254.logic2phys[1] = 1;\r\ndevpriv->i8254.logic2phys[2] = 2;\r\ndevpriv->i8254.iobase = iobase + thisboard->i8254_offset;\r\ndevpriv->i8254.mode[0] =\r\ndevpriv->i8254.mode[1] =\r\ndevpriv->i8254.mode[2] = I8254_MODE0 | I8254_BINARY;\r\ni8254_initialize(&devpriv->i8254);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int das08_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nint ret;\r\nunsigned long iobase;\r\n#ifdef CONFIG_COMEDI_PCI\r\nunsigned long pci_iobase = 0;\r\nstruct pci_dev *pdev = NULL;\r\n#endif\r\nret = alloc_private(dev, sizeof(struct das08_private_struct));\r\nif (ret < 0)\r\nreturn ret;\r\nprintk(KERN_INFO "comedi%d: das08: ", dev->minor);\r\nif (thisboard->bustype == pci) {\r\n#ifdef CONFIG_COMEDI_PCI\r\nif (it->options[0] || it->options[1]) {\r\nprintk("bus %i slot %i ",\r\nit->options[0], it->options[1]);\r\n}\r\nprintk("\n");\r\nfor_each_pci_dev(pdev) {\r\nif (pdev->vendor == PCI_VENDOR_ID_COMPUTERBOARDS\r\n&& pdev->device == PCI_DEVICE_ID_PCIDAS08) {\r\nif (it->options[0] || it->options[1]) {\r\nif (pdev->bus->number == it->options[0]\r\n&& PCI_SLOT(pdev->devfn) ==\r\nit->options[1]) {\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!pdev) {\r\nprintk(KERN_ERR "No pci das08 cards found\n");\r\nreturn -EIO;\r\n}\r\ndevpriv->pdev = pdev;\r\nif (comedi_pci_enable(pdev, DRV_NAME)) {\r\nprintk(KERN_ERR " Error enabling PCI device and "\r\n"requesting regions\n");\r\nreturn -EIO;\r\n}\r\npci_iobase = pci_resource_start(pdev, 1);\r\niobase = pci_resource_start(pdev, 2);\r\nprintk(KERN_INFO "pcibase 0x%lx iobase 0x%lx\n",\r\npci_iobase, iobase);\r\ndevpriv->pci_iobase = pci_iobase;\r\n#if 0\r\noutb(CNTRL_INTR | CNTRL_DIR, pci_iobase + CNTRL);\r\noutw(INTR1_ENABLE | PCI_INTR_ENABLE, pci_iobase + INTCSR);\r\n#endif\r\n#else\r\nprintk(KERN_ERR "this driver has not been built with PCI support.\n");\r\nreturn -EINVAL;\r\n#endif\r\n} else {\r\niobase = it->options[0];\r\n}\r\nprintk(KERN_INFO "\n");\r\nreturn das08_common_attach(dev, iobase);\r\n}\r\nint das08_common_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_INFO "comedi%d: das08: remove\n", dev->minor);\r\nif (dev->subdevices)\r\nsubdev_8255_cleanup(dev, dev->subdevices + 4);\r\nif ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, thisboard->iosize);\r\n}\r\n#ifdef CONFIG_COMEDI_PCI\r\nif (devpriv) {\r\nif (devpriv->pdev) {\r\nif (devpriv->pci_iobase)\r\ncomedi_pci_disable(devpriv->pdev);\r\npci_dev_put(devpriv->pdev);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __devinit driver_das08_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_das08.driver_name);\r\n}\r\nstatic void __devexit driver_das08_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_das08_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_das08);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_das08_pci_driver.name = (char *)driver_das08.driver_name;\r\nreturn pci_register_driver(&driver_das08_pci_driver);\r\n}\r\nstatic void __exit driver_das08_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_das08_pci_driver);\r\ncomedi_driver_unregister(&driver_das08);\r\n}\r\nstatic int __init driver_das08_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_das08);\r\n}\r\nstatic void __exit driver_das08_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_das08);\r\n}
