static inline u32 cb_readl(struct yenta_socket *socket, unsigned reg)\r\n{\r\nu32 val = readl(socket->base + reg);\r\ndebug("%04x %08x\n", socket, reg, val);\r\nreturn val;\r\n}\r\nstatic inline void cb_writel(struct yenta_socket *socket, unsigned reg, u32 val)\r\n{\r\ndebug("%04x %08x\n", socket, reg, val);\r\nwritel(val, socket->base + reg);\r\nreadl(socket->base + reg);\r\n}\r\nstatic inline u8 config_readb(struct yenta_socket *socket, unsigned offset)\r\n{\r\nu8 val;\r\npci_read_config_byte(socket->dev, offset, &val);\r\ndebug("%04x %02x\n", socket, offset, val);\r\nreturn val;\r\n}\r\nstatic inline u16 config_readw(struct yenta_socket *socket, unsigned offset)\r\n{\r\nu16 val;\r\npci_read_config_word(socket->dev, offset, &val);\r\ndebug("%04x %04x\n", socket, offset, val);\r\nreturn val;\r\n}\r\nstatic inline u32 config_readl(struct yenta_socket *socket, unsigned offset)\r\n{\r\nu32 val;\r\npci_read_config_dword(socket->dev, offset, &val);\r\ndebug("%04x %08x\n", socket, offset, val);\r\nreturn val;\r\n}\r\nstatic inline void config_writeb(struct yenta_socket *socket, unsigned offset, u8 val)\r\n{\r\ndebug("%04x %02x\n", socket, offset, val);\r\npci_write_config_byte(socket->dev, offset, val);\r\n}\r\nstatic inline void config_writew(struct yenta_socket *socket, unsigned offset, u16 val)\r\n{\r\ndebug("%04x %04x\n", socket, offset, val);\r\npci_write_config_word(socket->dev, offset, val);\r\n}\r\nstatic inline void config_writel(struct yenta_socket *socket, unsigned offset, u32 val)\r\n{\r\ndebug("%04x %08x\n", socket, offset, val);\r\npci_write_config_dword(socket->dev, offset, val);\r\n}\r\nstatic inline u8 exca_readb(struct yenta_socket *socket, unsigned reg)\r\n{\r\nu8 val = readb(socket->base + 0x800 + reg);\r\ndebug("%04x %02x\n", socket, reg, val);\r\nreturn val;\r\n}\r\nstatic inline u8 exca_readw(struct yenta_socket *socket, unsigned reg)\r\n{\r\nu16 val;\r\nval = readb(socket->base + 0x800 + reg);\r\nval |= readb(socket->base + 0x800 + reg + 1) << 8;\r\ndebug("%04x %04x\n", socket, reg, val);\r\nreturn val;\r\n}\r\nstatic inline void exca_writeb(struct yenta_socket *socket, unsigned reg, u8 val)\r\n{\r\ndebug("%04x %02x\n", socket, reg, val);\r\nwriteb(val, socket->base + 0x800 + reg);\r\nreadb(socket->base + 0x800 + reg);\r\n}\r\nstatic void exca_writew(struct yenta_socket *socket, unsigned reg, u16 val)\r\n{\r\ndebug("%04x %04x\n", socket, reg, val);\r\nwriteb(val, socket->base + 0x800 + reg);\r\nwriteb(val >> 8, socket->base + 0x800 + reg + 1);\r\nreadb(socket->base + 0x800 + reg);\r\nreadb(socket->base + 0x800 + reg + 1);\r\n}\r\nstatic ssize_t show_yenta_registers(struct device *yentadev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(yentadev);\r\nstruct yenta_socket *socket = pci_get_drvdata(dev);\r\nint offset = 0, i;\r\noffset = snprintf(buf, PAGE_SIZE, "CB registers:");\r\nfor (i = 0; i < 0x24; i += 4) {\r\nunsigned val;\r\nif (!(i & 15))\r\noffset += snprintf(buf + offset, PAGE_SIZE - offset, "\n%02x:", i);\r\nval = cb_readl(socket, i);\r\noffset += snprintf(buf + offset, PAGE_SIZE - offset, " %08x", val);\r\n}\r\noffset += snprintf(buf + offset, PAGE_SIZE - offset, "\n\nExCA registers:");\r\nfor (i = 0; i < 0x45; i++) {\r\nunsigned char val;\r\nif (!(i & 7)) {\r\nif (i & 8) {\r\nmemcpy(buf + offset, " -", 2);\r\noffset += 2;\r\n} else\r\noffset += snprintf(buf + offset, PAGE_SIZE - offset, "\n%02x:", i);\r\n}\r\nval = exca_readb(socket, i);\r\noffset += snprintf(buf + offset, PAGE_SIZE - offset, " %02x", val);\r\n}\r\nbuf[offset++] = '\n';\r\nreturn offset;\r\n}\r\nstatic int yenta_get_status(struct pcmcia_socket *sock, unsigned int *value)\r\n{\r\nstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\r\nunsigned int val;\r\nu32 state = cb_readl(socket, CB_SOCKET_STATE);\r\nval = (state & CB_3VCARD) ? SS_3VCARD : 0;\r\nval |= (state & CB_XVCARD) ? SS_XVCARD : 0;\r\nval |= (state & (CB_5VCARD | CB_3VCARD | CB_XVCARD | CB_YVCARD)) ? 0 : SS_PENDING;\r\nval |= (state & (CB_CDETECT1 | CB_CDETECT2)) ? SS_PENDING : 0;\r\nif (state & CB_CBCARD) {\r\nval |= SS_CARDBUS;\r\nval |= (state & CB_CARDSTS) ? SS_STSCHG : 0;\r\nval |= (state & (CB_CDETECT1 | CB_CDETECT2)) ? 0 : SS_DETECT;\r\nval |= (state & CB_PWRCYCLE) ? SS_POWERON | SS_READY : 0;\r\n} else if (state & CB_16BITCARD) {\r\nu8 status = exca_readb(socket, I365_STATUS);\r\nval |= ((status & I365_CS_DETECT) == I365_CS_DETECT) ? SS_DETECT : 0;\r\nif (exca_readb(socket, I365_INTCTL) & I365_PC_IOCARD) {\r\nval |= (status & I365_CS_STSCHG) ? 0 : SS_STSCHG;\r\n} else {\r\nval |= (status & I365_CS_BVD1) ? 0 : SS_BATDEAD;\r\nval |= (status & I365_CS_BVD2) ? 0 : SS_BATWARN;\r\n}\r\nval |= (status & I365_CS_WRPROT) ? SS_WRPROT : 0;\r\nval |= (status & I365_CS_READY) ? SS_READY : 0;\r\nval |= (status & I365_CS_POWERON) ? SS_POWERON : 0;\r\n}\r\n*value = val;\r\nreturn 0;\r\n}\r\nstatic void yenta_set_power(struct yenta_socket *socket, socket_state_t *state)\r\n{\r\nif (!(cb_readl(socket, CB_SOCKET_STATE) & CB_CBCARD) &&\r\n(socket->flags & YENTA_16BIT_POWER_EXCA)) {\r\nu8 reg, old;\r\nreg = old = exca_readb(socket, I365_POWER);\r\nreg &= ~(I365_VCC_MASK | I365_VPP1_MASK | I365_VPP2_MASK);\r\nif (socket->flags & YENTA_16BIT_POWER_DF) {\r\nswitch (state->Vcc) {\r\ncase 33:\r\nreg |= I365_VCC_3V;\r\nbreak;\r\ncase 50:\r\nreg |= I365_VCC_5V;\r\nbreak;\r\ndefault:\r\nreg = 0;\r\nbreak;\r\n}\r\nswitch (state->Vpp) {\r\ncase 33:\r\ncase 50:\r\nreg |= I365_VPP1_5V;\r\nbreak;\r\ncase 120:\r\nreg |= I365_VPP1_12V;\r\nbreak;\r\n}\r\n} else {\r\nswitch (state->Vcc) {\r\ncase 50:\r\nreg |= I365_VCC_5V;\r\nbreak;\r\ndefault:\r\nreg = 0;\r\nbreak;\r\n}\r\nswitch (state->Vpp) {\r\ncase 50:\r\nreg |= I365_VPP1_5V | I365_VPP2_5V;\r\nbreak;\r\ncase 120:\r\nreg |= I365_VPP1_12V | I365_VPP2_12V;\r\nbreak;\r\n}\r\n}\r\nif (reg != old)\r\nexca_writeb(socket, I365_POWER, reg);\r\n} else {\r\nu32 reg = 0;\r\nswitch (state->Vcc) {\r\ncase 33:\r\nreg = CB_SC_VCC_3V;\r\nbreak;\r\ncase 50:\r\nreg = CB_SC_VCC_5V;\r\nbreak;\r\ndefault:\r\nreg = 0;\r\nbreak;\r\n}\r\nswitch (state->Vpp) {\r\ncase 33:\r\nreg |= CB_SC_VPP_3V;\r\nbreak;\r\ncase 50:\r\nreg |= CB_SC_VPP_5V;\r\nbreak;\r\ncase 120:\r\nreg |= CB_SC_VPP_12V;\r\nbreak;\r\n}\r\nif (reg != cb_readl(socket, CB_SOCKET_CONTROL))\r\ncb_writel(socket, CB_SOCKET_CONTROL, reg);\r\n}\r\n}\r\nstatic int yenta_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\r\n{\r\nstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\r\nu16 bridge;\r\nif (state->Vcc == 0)\r\nyenta_set_power(socket, state);\r\nsocket->io_irq = state->io_irq;\r\nbridge = config_readw(socket, CB_BRIDGE_CONTROL) & ~(CB_BRIDGE_CRST | CB_BRIDGE_INTR);\r\nif (cb_readl(socket, CB_SOCKET_STATE) & CB_CBCARD) {\r\nu8 intr;\r\nbridge |= (state->flags & SS_RESET) ? CB_BRIDGE_CRST : 0;\r\nintr = exca_readb(socket, I365_INTCTL);\r\nintr = (intr & ~0xf);\r\nif (!socket->dev->irq) {\r\nintr |= socket->cb_irq ? socket->cb_irq : state->io_irq;\r\nbridge |= CB_BRIDGE_INTR;\r\n}\r\nexca_writeb(socket, I365_INTCTL, intr);\r\n} else {\r\nu8 reg;\r\nreg = exca_readb(socket, I365_INTCTL) & (I365_RING_ENA | I365_INTR_ENA);\r\nreg |= (state->flags & SS_RESET) ? 0 : I365_PC_RESET;\r\nreg |= (state->flags & SS_IOCARD) ? I365_PC_IOCARD : 0;\r\nif (state->io_irq != socket->dev->irq) {\r\nreg |= state->io_irq;\r\nbridge |= CB_BRIDGE_INTR;\r\n}\r\nexca_writeb(socket, I365_INTCTL, reg);\r\nreg = exca_readb(socket, I365_POWER) & (I365_VCC_MASK|I365_VPP1_MASK);\r\nreg |= I365_PWR_NORESET;\r\nif (state->flags & SS_PWR_AUTO)\r\nreg |= I365_PWR_AUTO;\r\nif (state->flags & SS_OUTPUT_ENA)\r\nreg |= I365_PWR_OUT;\r\nif (exca_readb(socket, I365_POWER) != reg)\r\nexca_writeb(socket, I365_POWER, reg);\r\nreg = exca_readb(socket, I365_CSCINT);\r\nreg &= I365_CSC_IRQ_MASK;\r\nreg |= I365_CSC_DETECT;\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG)\r\nreg |= I365_CSC_STSCHG;\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD)\r\nreg |= I365_CSC_BVD1;\r\nif (state->csc_mask & SS_BATWARN)\r\nreg |= I365_CSC_BVD2;\r\nif (state->csc_mask & SS_READY)\r\nreg |= I365_CSC_READY;\r\n}\r\nexca_writeb(socket, I365_CSCINT, reg);\r\nexca_readb(socket, I365_CSC);\r\nif (sock->zoom_video)\r\nsock->zoom_video(sock, state->flags & SS_ZVCARD);\r\n}\r\nconfig_writew(socket, CB_BRIDGE_CONTROL, bridge);\r\ncb_writel(socket, CB_SOCKET_EVENT, -1);\r\ncb_writel(socket, CB_SOCKET_MASK, CB_CDMASK);\r\nif (state->Vcc != 0)\r\nyenta_set_power(socket, state);\r\nreturn 0;\r\n}\r\nstatic int yenta_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io)\r\n{\r\nstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\r\nint map;\r\nunsigned char ioctl, addr, enable;\r\nmap = io->map;\r\nif (map > 1)\r\nreturn -EINVAL;\r\nenable = I365_ENA_IO(map);\r\naddr = exca_readb(socket, I365_ADDRWIN);\r\nif (addr & enable) {\r\naddr &= ~enable;\r\nexca_writeb(socket, I365_ADDRWIN, addr);\r\n}\r\nexca_writew(socket, I365_IO(map)+I365_W_START, io->start);\r\nexca_writew(socket, I365_IO(map)+I365_W_STOP, io->stop);\r\nioctl = exca_readb(socket, I365_IOCTL) & ~I365_IOCTL_MASK(map);\r\nif (io->flags & MAP_0WS)\r\nioctl |= I365_IOCTL_0WS(map);\r\nif (io->flags & MAP_16BIT)\r\nioctl |= I365_IOCTL_16BIT(map);\r\nif (io->flags & MAP_AUTOSZ)\r\nioctl |= I365_IOCTL_IOCS16(map);\r\nexca_writeb(socket, I365_IOCTL, ioctl);\r\nif (io->flags & MAP_ACTIVE)\r\nexca_writeb(socket, I365_ADDRWIN, addr | enable);\r\nreturn 0;\r\n}\r\nstatic int yenta_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *mem)\r\n{\r\nstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\r\nstruct pci_bus_region region;\r\nint map;\r\nunsigned char addr, enable;\r\nunsigned int start, stop, card_start;\r\nunsigned short word;\r\npcibios_resource_to_bus(socket->dev, &region, mem->res);\r\nmap = mem->map;\r\nstart = region.start;\r\nstop = region.end;\r\ncard_start = mem->card_start;\r\nif (map > 4 || start > stop || ((start ^ stop) >> 24) ||\r\n(card_start >> 26) || mem->speed > 1000)\r\nreturn -EINVAL;\r\nenable = I365_ENA_MEM(map);\r\naddr = exca_readb(socket, I365_ADDRWIN);\r\nif (addr & enable) {\r\naddr &= ~enable;\r\nexca_writeb(socket, I365_ADDRWIN, addr);\r\n}\r\nexca_writeb(socket, CB_MEM_PAGE(map), start >> 24);\r\nword = (start >> 12) & 0x0fff;\r\nif (mem->flags & MAP_16BIT)\r\nword |= I365_MEM_16BIT;\r\nif (mem->flags & MAP_0WS)\r\nword |= I365_MEM_0WS;\r\nexca_writew(socket, I365_MEM(map) + I365_W_START, word);\r\nword = (stop >> 12) & 0x0fff;\r\nswitch (to_cycles(mem->speed)) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nword |= I365_MEM_WS0;\r\nbreak;\r\ncase 2:\r\nword |= I365_MEM_WS1;\r\nbreak;\r\ndefault:\r\nword |= I365_MEM_WS1 | I365_MEM_WS0;\r\nbreak;\r\n}\r\nexca_writew(socket, I365_MEM(map) + I365_W_STOP, word);\r\nword = ((card_start - start) >> 12) & 0x3fff;\r\nif (mem->flags & MAP_WRPROT)\r\nword |= I365_MEM_WRPROT;\r\nif (mem->flags & MAP_ATTRIB)\r\nword |= I365_MEM_REG;\r\nexca_writew(socket, I365_MEM(map) + I365_W_OFF, word);\r\nif (mem->flags & MAP_ACTIVE)\r\nexca_writeb(socket, I365_ADDRWIN, addr | enable);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t yenta_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned int events;\r\nstruct yenta_socket *socket = (struct yenta_socket *) dev_id;\r\nu8 csc;\r\nu32 cb_event;\r\ncb_event = cb_readl(socket, CB_SOCKET_EVENT);\r\ncb_writel(socket, CB_SOCKET_EVENT, cb_event);\r\ncsc = exca_readb(socket, I365_CSC);\r\nif (!(cb_event || csc))\r\nreturn IRQ_NONE;\r\nevents = (cb_event & (CB_CD1EVENT | CB_CD2EVENT)) ? SS_DETECT : 0 ;\r\nevents |= (csc & I365_CSC_DETECT) ? SS_DETECT : 0;\r\nif (exca_readb(socket, I365_INTCTL) & I365_PC_IOCARD) {\r\nevents |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;\r\n} else {\r\nevents |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;\r\nevents |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;\r\nevents |= (csc & I365_CSC_READY) ? SS_READY : 0;\r\n}\r\nif (events)\r\npcmcia_parse_events(&socket->socket, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void yenta_interrupt_wrapper(unsigned long data)\r\n{\r\nstruct yenta_socket *socket = (struct yenta_socket *) data;\r\nyenta_interrupt(0, (void *)socket);\r\nsocket->poll_timer.expires = jiffies + HZ;\r\nadd_timer(&socket->poll_timer);\r\n}\r\nstatic void yenta_clear_maps(struct yenta_socket *socket)\r\n{\r\nint i;\r\nstruct resource res = { .start = 0, .end = 0x0fff };\r\npccard_io_map io = { 0, 0, 0, 0, 1 };\r\npccard_mem_map mem = { .res = &res, };\r\nyenta_set_socket(&socket->socket, &dead_socket);\r\nfor (i = 0; i < 2; i++) {\r\nio.map = i;\r\nyenta_set_io_map(&socket->socket, &io);\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nmem.map = i;\r\nyenta_set_mem_map(&socket->socket, &mem);\r\n}\r\n}\r\nstatic void yenta_interrogate(struct yenta_socket *socket)\r\n{\r\nu32 state;\r\nstate = cb_readl(socket, CB_SOCKET_STATE);\r\nif (!(state & (CB_5VCARD | CB_3VCARD | CB_XVCARD | CB_YVCARD)) ||\r\n(state & (CB_CDETECT1 | CB_CDETECT2 | CB_NOTACARD | CB_BADVCCREQ)) ||\r\n((state & (CB_16BITCARD | CB_CBCARD)) == (CB_16BITCARD | CB_CBCARD)))\r\ncb_writel(socket, CB_SOCKET_FORCE, CB_CVSTEST);\r\n}\r\nstatic int yenta_sock_init(struct pcmcia_socket *sock)\r\n{\r\nstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\r\nexca_writeb(socket, I365_GBLCTL, 0x00);\r\nexca_writeb(socket, I365_GENCTL, 0x00);\r\nyenta_interrogate(socket);\r\nyenta_clear_maps(socket);\r\nif (socket->type && socket->type->sock_init)\r\nsocket->type->sock_init(socket);\r\ncb_writel(socket, CB_SOCKET_MASK, CB_CDMASK);\r\nreturn 0;\r\n}\r\nstatic int yenta_sock_suspend(struct pcmcia_socket *sock)\r\n{\r\nstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\r\ncb_writel(socket, CB_SOCKET_MASK, 0x0);\r\nreturn 0;\r\n}\r\nstatic int yenta_search_one_res(struct resource *root, struct resource *res,\r\nu32 min)\r\n{\r\nu32 align, size, start, end;\r\nif (res->flags & IORESOURCE_IO) {\r\nalign = 1024;\r\nsize = BRIDGE_IO_MAX;\r\nstart = PCIBIOS_MIN_CARDBUS_IO;\r\nend = ~0U;\r\n} else {\r\nunsigned long avail = root->end - root->start;\r\nint i;\r\nsize = BRIDGE_MEM_MAX;\r\nif (size > avail/8) {\r\nsize = (avail+1)/8;\r\ni = 0;\r\nwhile ((size /= 2) != 0)\r\ni++;\r\nsize = 1 << i;\r\n}\r\nif (size < min)\r\nsize = min;\r\nalign = size;\r\nstart = PCIBIOS_MIN_MEM;\r\nend = ~0U;\r\n}\r\ndo {\r\nif (allocate_resource(root, res, size, start, end, align,\r\nNULL, NULL) == 0) {\r\nreturn 1;\r\n}\r\nsize = size/2;\r\nalign = size;\r\n} while (size >= min);\r\nreturn 0;\r\n}\r\nstatic int yenta_search_res(struct yenta_socket *socket, struct resource *res,\r\nu32 min)\r\n{\r\nstruct resource *root;\r\nint i;\r\npci_bus_for_each_resource(socket->dev->bus, root, i) {\r\nif (!root)\r\ncontinue;\r\nif ((res->flags ^ root->flags) &\r\n(IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH))\r\ncontinue;\r\nif (yenta_search_one_res(root, res, min))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int yenta_allocate_res(struct yenta_socket *socket, int nr, unsigned type, int addr_start, int addr_end)\r\n{\r\nstruct pci_dev *dev = socket->dev;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nunsigned mask;\r\nres = dev->resource + PCI_BRIDGE_RESOURCES + nr;\r\nif (res->parent)\r\nreturn 0;\r\nmask = ~0xfff;\r\nif (type & IORESOURCE_IO)\r\nmask = ~3;\r\nres->name = dev->subordinate->name;\r\nres->flags = type;\r\nregion.start = config_readl(socket, addr_start) & mask;\r\nregion.end = config_readl(socket, addr_end) | ~mask;\r\nif (region.start && region.end > region.start && !override_bios) {\r\npcibios_bus_to_resource(dev, res, &region);\r\nif (pci_claim_resource(dev, PCI_BRIDGE_RESOURCES + nr) == 0)\r\nreturn 0;\r\ndev_printk(KERN_INFO, &dev->dev,\r\n"Preassigned resource %d busy or not available, "\r\n"reconfiguring...\n",\r\nnr);\r\n}\r\nif (type & IORESOURCE_IO) {\r\nif ((yenta_search_res(socket, res, BRIDGE_IO_MAX)) ||\r\n(yenta_search_res(socket, res, BRIDGE_IO_ACC)) ||\r\n(yenta_search_res(socket, res, BRIDGE_IO_MIN)))\r\nreturn 1;\r\n} else {\r\nif (type & IORESOURCE_PREFETCH) {\r\nif ((yenta_search_res(socket, res, BRIDGE_MEM_MAX)) ||\r\n(yenta_search_res(socket, res, BRIDGE_MEM_ACC)) ||\r\n(yenta_search_res(socket, res, BRIDGE_MEM_MIN)))\r\nreturn 1;\r\nres->flags = IORESOURCE_MEM;\r\n}\r\nif ((yenta_search_res(socket, res, BRIDGE_MEM_MAX)) ||\r\n(yenta_search_res(socket, res, BRIDGE_MEM_ACC)) ||\r\n(yenta_search_res(socket, res, BRIDGE_MEM_MIN)))\r\nreturn 1;\r\n}\r\ndev_printk(KERN_INFO, &dev->dev,\r\n"no resource of type %x available, trying to continue...\n",\r\ntype);\r\nres->start = res->end = res->flags = 0;\r\nreturn 0;\r\n}\r\nstatic void yenta_allocate_resources(struct yenta_socket *socket)\r\n{\r\nint program = 0;\r\nprogram += yenta_allocate_res(socket, 0, IORESOURCE_IO,\r\nPCI_CB_IO_BASE_0, PCI_CB_IO_LIMIT_0);\r\nprogram += yenta_allocate_res(socket, 1, IORESOURCE_IO,\r\nPCI_CB_IO_BASE_1, PCI_CB_IO_LIMIT_1);\r\nprogram += yenta_allocate_res(socket, 2, IORESOURCE_MEM|IORESOURCE_PREFETCH,\r\nPCI_CB_MEMORY_BASE_0, PCI_CB_MEMORY_LIMIT_0);\r\nprogram += yenta_allocate_res(socket, 3, IORESOURCE_MEM,\r\nPCI_CB_MEMORY_BASE_1, PCI_CB_MEMORY_LIMIT_1);\r\nif (program)\r\npci_setup_cardbus(socket->dev->subordinate);\r\n}\r\nstatic void yenta_free_resources(struct yenta_socket *socket)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nstruct resource *res;\r\nres = socket->dev->resource + PCI_BRIDGE_RESOURCES + i;\r\nif (res->start != 0 && res->end != 0)\r\nrelease_resource(res);\r\nres->start = res->end = res->flags = 0;\r\n}\r\n}\r\nstatic void __devexit yenta_close(struct pci_dev *dev)\r\n{\r\nstruct yenta_socket *sock = pci_get_drvdata(dev);\r\ndevice_remove_file(&dev->dev, &dev_attr_yenta_registers);\r\npcmcia_unregister_socket(&sock->socket);\r\ncb_writel(sock, CB_SOCKET_MASK, 0x0);\r\nexca_writeb(sock, I365_CSCINT, 0);\r\nif (sock->cb_irq)\r\nfree_irq(sock->cb_irq, sock);\r\nelse\r\ndel_timer_sync(&sock->poll_timer);\r\nif (sock->base)\r\niounmap(sock->base);\r\nyenta_free_resources(sock);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\npci_set_drvdata(dev, NULL);\r\n}\r\nstatic unsigned int yenta_probe_irq(struct yenta_socket *socket, u32 isa_irq_mask)\r\n{\r\nint i;\r\nunsigned long val;\r\nu32 mask;\r\nu8 reg;\r\ncb_writel(socket, CB_SOCKET_EVENT, -1);\r\ncb_writel(socket, CB_SOCKET_MASK, CB_CSTSMASK);\r\nreg = exca_readb(socket, I365_CSCINT);\r\nexca_writeb(socket, I365_CSCINT, 0);\r\nval = probe_irq_on() & isa_irq_mask;\r\nfor (i = 1; i < 16; i++) {\r\nif (!((val >> i) & 1))\r\ncontinue;\r\nexca_writeb(socket, I365_CSCINT, I365_CSC_STSCHG | (i << 4));\r\ncb_writel(socket, CB_SOCKET_FORCE, CB_FCARDSTS);\r\nudelay(100);\r\ncb_writel(socket, CB_SOCKET_EVENT, -1);\r\n}\r\ncb_writel(socket, CB_SOCKET_MASK, 0);\r\nexca_writeb(socket, I365_CSCINT, reg);\r\nmask = probe_irq_mask(val) & 0xffff;\r\nreturn mask;\r\n}\r\nstatic irqreturn_t yenta_probe_handler(int irq, void *dev_id)\r\n{\r\nstruct yenta_socket *socket = (struct yenta_socket *) dev_id;\r\nu8 csc;\r\nu32 cb_event;\r\ncb_event = cb_readl(socket, CB_SOCKET_EVENT);\r\ncb_writel(socket, CB_SOCKET_EVENT, -1);\r\ncsc = exca_readb(socket, I365_CSC);\r\nif (cb_event || csc) {\r\nsocket->probe_status = 1;\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int yenta_probe_cb_irq(struct yenta_socket *socket)\r\n{\r\nu8 reg = 0;\r\nif (!socket->cb_irq)\r\nreturn -1;\r\nsocket->probe_status = 0;\r\nif (request_irq(socket->cb_irq, yenta_probe_handler, IRQF_SHARED, "yenta", socket)) {\r\ndev_printk(KERN_WARNING, &socket->dev->dev,\r\n"request_irq() in yenta_probe_cb_irq() failed!\n");\r\nreturn -1;\r\n}\r\nif (!socket->dev->irq)\r\nreg = exca_readb(socket, I365_CSCINT);\r\nexca_writeb(socket, I365_CSCINT, reg | I365_CSC_STSCHG);\r\ncb_writel(socket, CB_SOCKET_EVENT, -1);\r\ncb_writel(socket, CB_SOCKET_MASK, CB_CSTSMASK);\r\ncb_writel(socket, CB_SOCKET_FORCE, CB_FCARDSTS);\r\nmsleep(100);\r\ncb_writel(socket, CB_SOCKET_MASK, 0);\r\nexca_writeb(socket, I365_CSCINT, reg);\r\ncb_writel(socket, CB_SOCKET_EVENT, -1);\r\nexca_readb(socket, I365_CSC);\r\nfree_irq(socket->cb_irq, socket);\r\nreturn (int) socket->probe_status;\r\n}\r\nstatic void yenta_get_socket_capabilities(struct yenta_socket *socket, u32 isa_irq_mask)\r\n{\r\nsocket->socket.pci_irq = socket->cb_irq;\r\nif (isa_probe)\r\nsocket->socket.irq_mask = yenta_probe_irq(socket, isa_irq_mask);\r\nelse\r\nsocket->socket.irq_mask = 0;\r\ndev_printk(KERN_INFO, &socket->dev->dev,\r\n"ISA IRQ mask 0x%04x, PCI irq %d\n",\r\nsocket->socket.irq_mask, socket->cb_irq);\r\n}\r\nstatic void yenta_config_init(struct yenta_socket *socket)\r\n{\r\nu16 bridge;\r\nstruct pci_dev *dev = socket->dev;\r\nstruct pci_bus_region region;\r\npcibios_resource_to_bus(socket->dev, &region, &dev->resource[0]);\r\nconfig_writel(socket, CB_LEGACY_MODE_BASE, 0);\r\nconfig_writel(socket, PCI_BASE_ADDRESS_0, region.start);\r\nconfig_writew(socket, PCI_COMMAND,\r\nPCI_COMMAND_IO |\r\nPCI_COMMAND_MEMORY |\r\nPCI_COMMAND_MASTER |\r\nPCI_COMMAND_WAIT);\r\nconfig_writeb(socket, PCI_CACHE_LINE_SIZE, L1_CACHE_BYTES / 4);\r\nconfig_writeb(socket, PCI_LATENCY_TIMER, 168);\r\nconfig_writel(socket, PCI_PRIMARY_BUS,\r\n(176 << 24) |\r\n(dev->subordinate->subordinate << 16) |\r\n(dev->subordinate->secondary << 8) |\r\ndev->subordinate->primary);\r\nbridge = config_readw(socket, CB_BRIDGE_CONTROL);\r\nbridge &= ~(CB_BRIDGE_CRST | CB_BRIDGE_PREFETCH1 | CB_BRIDGE_ISAEN | CB_BRIDGE_VGAEN);\r\nbridge |= CB_BRIDGE_PREFETCH0 | CB_BRIDGE_POSTEN;\r\nconfig_writew(socket, CB_BRIDGE_CONTROL, bridge);\r\n}\r\nstatic void yenta_fixup_parent_bridge(struct pci_bus *cardbus_bridge)\r\n{\r\nstruct list_head *tmp;\r\nunsigned char upper_limit;\r\nstruct pci_bus *bridge_to_fix = cardbus_bridge->parent;\r\nif (bridge_to_fix->subordinate >= cardbus_bridge->subordinate)\r\nreturn;\r\nif (!bridge_to_fix->parent)\r\nreturn;\r\nupper_limit = bridge_to_fix->parent->subordinate;\r\nlist_for_each(tmp, &bridge_to_fix->parent->children) {\r\nstruct pci_bus *silbling = pci_bus_b(tmp);\r\nif (silbling->secondary > bridge_to_fix->subordinate\r\n&& silbling->secondary <= upper_limit)\r\nupper_limit = silbling->secondary - 1;\r\n}\r\nif (cardbus_bridge->subordinate > upper_limit)\r\ndev_printk(KERN_WARNING, &cardbus_bridge->dev,\r\n"Upper limit for fixing this "\r\n"bridge's parent bridge: #%02x\n", upper_limit);\r\nif (bridge_to_fix->subordinate < upper_limit) {\r\nunsigned char subordinate_to_assign =\r\nmin(cardbus_bridge->subordinate, upper_limit);\r\ndev_printk(KERN_INFO, &bridge_to_fix->dev,\r\n"Raising subordinate bus# of parent "\r\n"bus (#%02x) from #%02x to #%02x\n",\r\nbridge_to_fix->number,\r\nbridge_to_fix->subordinate, subordinate_to_assign);\r\nbridge_to_fix->subordinate = subordinate_to_assign;\r\npci_write_config_byte(bridge_to_fix->self,\r\nPCI_SUBORDINATE_BUS, bridge_to_fix->subordinate);\r\n}\r\n}\r\nstatic int __devinit yenta_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct yenta_socket *socket;\r\nint ret;\r\nif (!dev->subordinate) {\r\ndev_printk(KERN_ERR, &dev->dev, "no bus associated! "\r\n"(try 'pci=assign-busses')\n");\r\nreturn -ENODEV;\r\n}\r\nsocket = kzalloc(sizeof(struct yenta_socket), GFP_KERNEL);\r\nif (!socket)\r\nreturn -ENOMEM;\r\nsocket->socket.ops = &yenta_socket_operations;\r\nsocket->socket.resource_ops = &pccard_nonstatic_ops;\r\nsocket->socket.dev.parent = &dev->dev;\r\nsocket->socket.driver_data = socket;\r\nsocket->socket.owner = THIS_MODULE;\r\nsocket->socket.features = SS_CAP_PAGE_REGS | SS_CAP_PCCARD;\r\nsocket->socket.map_size = 0x1000;\r\nsocket->socket.cb_dev = dev;\r\nsocket->dev = dev;\r\npci_set_drvdata(dev, socket);\r\nif (pci_enable_device(dev)) {\r\nret = -EBUSY;\r\ngoto free;\r\n}\r\nret = pci_request_regions(dev, "yenta_socket");\r\nif (ret)\r\ngoto disable;\r\nif (!pci_resource_start(dev, 0)) {\r\ndev_printk(KERN_ERR, &dev->dev, "No cardbus resource!\n");\r\nret = -ENODEV;\r\ngoto release;\r\n}\r\nsocket->base = ioremap(pci_resource_start(dev, 0), 0x1000);\r\nif (!socket->base) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\ndev_printk(KERN_INFO, &dev->dev, "CardBus bridge found [%04x:%04x]\n",\r\ndev->subsystem_vendor, dev->subsystem_device);\r\nyenta_config_init(socket);\r\ncb_writel(socket, CB_SOCKET_MASK, 0x0);\r\nyenta_allocate_resources(socket);\r\nsocket->cb_irq = dev->irq;\r\nif (id->driver_data != CARDBUS_TYPE_DEFAULT &&\r\nid->driver_data < ARRAY_SIZE(cardbus_type)) {\r\nsocket->type = &cardbus_type[id->driver_data];\r\nret = socket->type->override(socket);\r\nif (ret < 0)\r\ngoto unmap;\r\n}\r\nif (!socket->cb_irq || request_irq(socket->cb_irq, yenta_interrupt, IRQF_SHARED, "yenta", socket)) {\r\nsocket->cb_irq = 0;\r\ninit_timer(&socket->poll_timer);\r\nsocket->poll_timer.function = yenta_interrupt_wrapper;\r\nsocket->poll_timer.data = (unsigned long)socket;\r\nsocket->poll_timer.expires = jiffies + HZ;\r\nadd_timer(&socket->poll_timer);\r\ndev_printk(KERN_INFO, &dev->dev,\r\n"no PCI IRQ, CardBus support disabled for this "\r\n"socket.\n");\r\ndev_printk(KERN_INFO, &dev->dev,\r\n"check your BIOS CardBus, BIOS IRQ or ACPI "\r\n"settings.\n");\r\n} else {\r\nsocket->socket.features |= SS_CAP_CARDBUS;\r\n}\r\nyenta_interrogate(socket);\r\nyenta_get_socket_capabilities(socket, isa_interrupts);\r\ndev_printk(KERN_INFO, &dev->dev,\r\n"Socket status: %08x\n", cb_readl(socket, CB_SOCKET_STATE));\r\nyenta_fixup_parent_bridge(dev->subordinate);\r\nret = pcmcia_register_socket(&socket->socket);\r\nif (ret == 0) {\r\nret = device_create_file(&dev->dev, &dev_attr_yenta_registers);\r\nif (ret == 0)\r\ngoto out;\r\npcmcia_unregister_socket(&socket->socket);\r\n}\r\nunmap:\r\niounmap(socket->base);\r\nrelease:\r\npci_release_regions(dev);\r\ndisable:\r\npci_disable_device(dev);\r\nfree:\r\nkfree(socket);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int yenta_dev_suspend_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct yenta_socket *socket = pci_get_drvdata(pdev);\r\nif (!socket)\r\nreturn 0;\r\nif (socket->type && socket->type->save_state)\r\nsocket->type->save_state(socket);\r\npci_save_state(pdev);\r\npci_read_config_dword(pdev, 16*4, &socket->saved_state[0]);\r\npci_read_config_dword(pdev, 17*4, &socket->saved_state[1]);\r\npci_disable_device(pdev);\r\nreturn 0;\r\n}\r\nstatic int yenta_dev_resume_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct yenta_socket *socket = pci_get_drvdata(pdev);\r\nint ret;\r\nif (!socket)\r\nreturn 0;\r\npci_write_config_dword(pdev, 16*4, socket->saved_state[0]);\r\npci_write_config_dword(pdev, 17*4, socket->saved_state[1]);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pdev);\r\nif (socket->type && socket->type->restore_state)\r\nsocket->type->restore_state(socket);\r\nreturn 0;\r\n}\r\nstatic int __init yenta_socket_init(void)\r\n{\r\nreturn pci_register_driver(&yenta_cardbus_driver);\r\n}\r\nstatic void __exit yenta_socket_exit(void)\r\n{\r\npci_unregister_driver(&yenta_cardbus_driver);\r\n}
