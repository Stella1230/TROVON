static inline int bq27x00_read(struct bq27x00_device_info *di, u8 reg,\r\nbool single)\r\n{\r\nreturn di->bus.read(di, reg, single);\r\n}\r\nstatic int bq27x00_battery_read_rsoc(struct bq27x00_device_info *di)\r\n{\r\nint rsoc;\r\nif (di->chip == BQ27500)\r\nrsoc = bq27x00_read(di, BQ27500_REG_SOC, false);\r\nelse\r\nrsoc = bq27x00_read(di, BQ27000_REG_RSOC, true);\r\nif (rsoc < 0)\r\ndev_err(di->dev, "error reading relative State-of-Charge\n");\r\nreturn rsoc;\r\n}\r\nstatic int bq27x00_battery_read_charge(struct bq27x00_device_info *di, u8 reg)\r\n{\r\nint charge;\r\ncharge = bq27x00_read(di, reg, false);\r\nif (charge < 0) {\r\ndev_err(di->dev, "error reading nominal available capacity\n");\r\nreturn charge;\r\n}\r\nif (di->chip == BQ27500)\r\ncharge *= 1000;\r\nelse\r\ncharge = charge * 3570 / BQ27000_RS;\r\nreturn charge;\r\n}\r\nstatic inline int bq27x00_battery_read_nac(struct bq27x00_device_info *di)\r\n{\r\nreturn bq27x00_battery_read_charge(di, BQ27x00_REG_NAC);\r\n}\r\nstatic inline int bq27x00_battery_read_lmd(struct bq27x00_device_info *di)\r\n{\r\nreturn bq27x00_battery_read_charge(di, BQ27x00_REG_LMD);\r\n}\r\nstatic int bq27x00_battery_read_ilmd(struct bq27x00_device_info *di)\r\n{\r\nint ilmd;\r\nif (di->chip == BQ27500)\r\nilmd = bq27x00_read(di, BQ27500_REG_DCAP, false);\r\nelse\r\nilmd = bq27x00_read(di, BQ27000_REG_ILMD, true);\r\nif (ilmd < 0) {\r\ndev_err(di->dev, "error reading initial last measured discharge\n");\r\nreturn ilmd;\r\n}\r\nif (di->chip == BQ27500)\r\nilmd *= 1000;\r\nelse\r\nilmd = ilmd * 256 * 3570 / BQ27000_RS;\r\nreturn ilmd;\r\n}\r\nstatic int bq27x00_battery_read_cyct(struct bq27x00_device_info *di)\r\n{\r\nint cyct;\r\ncyct = bq27x00_read(di, BQ27x00_REG_CYCT, false);\r\nif (cyct < 0)\r\ndev_err(di->dev, "error reading cycle count total\n");\r\nreturn cyct;\r\n}\r\nstatic int bq27x00_battery_read_time(struct bq27x00_device_info *di, u8 reg)\r\n{\r\nint tval;\r\ntval = bq27x00_read(di, reg, false);\r\nif (tval < 0) {\r\ndev_err(di->dev, "error reading register %02x: %d\n", reg, tval);\r\nreturn tval;\r\n}\r\nif (tval == 65535)\r\nreturn -ENODATA;\r\nreturn tval * 60;\r\n}\r\nstatic void bq27x00_update(struct bq27x00_device_info *di)\r\n{\r\nstruct bq27x00_reg_cache cache = {0, };\r\nbool is_bq27500 = di->chip == BQ27500;\r\ncache.flags = bq27x00_read(di, BQ27x00_REG_FLAGS, is_bq27500);\r\nif (cache.flags >= 0) {\r\ncache.capacity = bq27x00_battery_read_rsoc(di);\r\ncache.temperature = bq27x00_read(di, BQ27x00_REG_TEMP, false);\r\ncache.time_to_empty = bq27x00_battery_read_time(di, BQ27x00_REG_TTE);\r\ncache.time_to_empty_avg = bq27x00_battery_read_time(di, BQ27x00_REG_TTECP);\r\ncache.time_to_full = bq27x00_battery_read_time(di, BQ27x00_REG_TTF);\r\ncache.charge_full = bq27x00_battery_read_lmd(di);\r\ncache.cycle_count = bq27x00_battery_read_cyct(di);\r\nif (!is_bq27500)\r\ncache.current_now = bq27x00_read(di, BQ27x00_REG_AI, false);\r\nif (di->charge_design_full <= 0)\r\ndi->charge_design_full = bq27x00_battery_read_ilmd(di);\r\n}\r\nif (memcmp(&di->cache, &cache, sizeof(cache) - sizeof(int)) != 0) {\r\ndi->cache = cache;\r\npower_supply_changed(&di->bat);\r\n}\r\ndi->last_update = jiffies;\r\n}\r\nstatic void bq27x00_battery_poll(struct work_struct *work)\r\n{\r\nstruct bq27x00_device_info *di =\r\ncontainer_of(work, struct bq27x00_device_info, work.work);\r\nbq27x00_update(di);\r\nif (poll_interval > 0) {\r\nset_timer_slack(&di->work.timer, poll_interval * HZ / 4);\r\nschedule_delayed_work(&di->work, poll_interval * HZ);\r\n}\r\n}\r\nstatic int bq27x00_battery_temperature(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nif (di->cache.temperature < 0)\r\nreturn di->cache.temperature;\r\nif (di->chip == BQ27500)\r\nval->intval = di->cache.temperature - 2731;\r\nelse\r\nval->intval = ((di->cache.temperature * 5) - 5463) / 2;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_current(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint curr;\r\nif (di->chip == BQ27500)\r\ncurr = bq27x00_read(di, BQ27x00_REG_AI, false);\r\nelse\r\ncurr = di->cache.current_now;\r\nif (curr < 0)\r\nreturn curr;\r\nif (di->chip == BQ27500) {\r\nval->intval = (int)((s16)curr) * 1000;\r\n} else {\r\nif (di->cache.flags & BQ27000_FLAG_CHGS) {\r\ndev_dbg(di->dev, "negative current!\n");\r\ncurr = -curr;\r\n}\r\nval->intval = curr * 3570 / BQ27000_RS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_status(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint status;\r\nif (di->chip == BQ27500) {\r\nif (di->cache.flags & BQ27500_FLAG_FC)\r\nstatus = POWER_SUPPLY_STATUS_FULL;\r\nelse if (di->cache.flags & BQ27500_FLAG_DSC)\r\nstatus = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nstatus = POWER_SUPPLY_STATUS_CHARGING;\r\n} else {\r\nif (di->cache.flags & BQ27000_FLAG_FC)\r\nstatus = POWER_SUPPLY_STATUS_FULL;\r\nelse if (di->cache.flags & BQ27000_FLAG_CHGS)\r\nstatus = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (power_supply_am_i_supplied(&di->bat))\r\nstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse\r\nstatus = POWER_SUPPLY_STATUS_DISCHARGING;\r\n}\r\nval->intval = status;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_voltage(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint volt;\r\nvolt = bq27x00_read(di, BQ27x00_REG_VOLT, false);\r\nif (volt < 0)\r\nreturn volt;\r\nval->intval = volt * 1000;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_energy(struct bq27x00_device_info *di,\r\nunion power_supply_propval *val)\r\n{\r\nint ae;\r\nae = bq27x00_read(di, BQ27x00_REG_AE, false);\r\nif (ae < 0) {\r\ndev_err(di->dev, "error reading available energy\n");\r\nreturn ae;\r\n}\r\nif (di->chip == BQ27500)\r\nae *= 1000;\r\nelse\r\nae = ae * 29200 / BQ27000_RS;\r\nval->intval = ae;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_simple_value(int value,\r\nunion power_supply_propval *val)\r\n{\r\nif (value < 0)\r\nreturn value;\r\nval->intval = value;\r\nreturn 0;\r\n}\r\nstatic int bq27x00_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct bq27x00_device_info *di = to_bq27x00_device_info(psy);\r\nmutex_lock(&di->lock);\r\nif (time_is_before_jiffies(di->last_update + 5 * HZ)) {\r\ncancel_delayed_work_sync(&di->work);\r\nbq27x00_battery_poll(&di->work.work);\r\n}\r\nmutex_unlock(&di->lock);\r\nif (psp != POWER_SUPPLY_PROP_PRESENT && di->cache.flags < 0)\r\nreturn -ENODEV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nret = bq27x00_battery_status(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = bq27x00_battery_voltage(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = di->cache.flags < 0 ? 0 : 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = bq27x00_battery_current(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = bq27x00_simple_value(di->cache.capacity, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nret = bq27x00_battery_temperature(di, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\r\nret = bq27x00_simple_value(di->cache.time_to_empty, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\nret = bq27x00_simple_value(di->cache.time_to_empty_avg, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:\r\nret = bq27x00_simple_value(di->cache.time_to_full, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nret = bq27x00_simple_value(bq27x00_battery_read_nac(di), val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nret = bq27x00_simple_value(di->cache.charge_full, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nret = bq27x00_simple_value(di->charge_design_full, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CYCLE_COUNT:\r\nret = bq27x00_simple_value(di->cache.cycle_count, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\nret = bq27x00_battery_energy(di, val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void bq27x00_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct bq27x00_device_info *di = to_bq27x00_device_info(psy);\r\ncancel_delayed_work_sync(&di->work);\r\nschedule_delayed_work(&di->work, 0);\r\n}\r\nstatic int bq27x00_powersupply_init(struct bq27x00_device_info *di)\r\n{\r\nint ret;\r\ndi->bat.type = POWER_SUPPLY_TYPE_BATTERY;\r\ndi->bat.properties = bq27x00_battery_props;\r\ndi->bat.num_properties = ARRAY_SIZE(bq27x00_battery_props);\r\ndi->bat.get_property = bq27x00_battery_get_property;\r\ndi->bat.external_power_changed = bq27x00_external_power_changed;\r\nINIT_DELAYED_WORK(&di->work, bq27x00_battery_poll);\r\nmutex_init(&di->lock);\r\nret = power_supply_register(di->dev, &di->bat);\r\nif (ret) {\r\ndev_err(di->dev, "failed to register battery: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_info(di->dev, "support ver. %s enabled\n", DRIVER_VERSION);\r\nbq27x00_update(di);\r\nreturn 0;\r\n}\r\nstatic void bq27x00_powersupply_unregister(struct bq27x00_device_info *di)\r\n{\r\ncancel_delayed_work_sync(&di->work);\r\npower_supply_unregister(&di->bat);\r\nmutex_destroy(&di->lock);\r\n}\r\nstatic int bq27x00_read_i2c(struct bq27x00_device_info *di, u8 reg, bool single)\r\n{\r\nstruct i2c_client *client = to_i2c_client(di->dev);\r\nstruct i2c_msg msg[2];\r\nunsigned char data[2];\r\nint ret;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = &reg;\r\nmsg[0].len = sizeof(reg);\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = data;\r\nif (single)\r\nmsg[1].len = 1;\r\nelse\r\nmsg[1].len = 2;\r\nret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\r\nif (ret < 0)\r\nreturn ret;\r\nif (!single)\r\nret = get_unaligned_le16(data);\r\nelse\r\nret = data[0];\r\nreturn ret;\r\n}\r\nstatic int bq27x00_battery_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nchar *name;\r\nstruct bq27x00_device_info *di;\r\nint num;\r\nint retval = 0;\r\nretval = idr_pre_get(&battery_id, GFP_KERNEL);\r\nif (retval == 0)\r\nreturn -ENOMEM;\r\nmutex_lock(&battery_mutex);\r\nretval = idr_get_new(&battery_id, client, &num);\r\nmutex_unlock(&battery_mutex);\r\nif (retval < 0)\r\nreturn retval;\r\nname = kasprintf(GFP_KERNEL, "%s-%d", id->name, num);\r\nif (!name) {\r\ndev_err(&client->dev, "failed to allocate device name\n");\r\nretval = -ENOMEM;\r\ngoto batt_failed_1;\r\n}\r\ndi = kzalloc(sizeof(*di), GFP_KERNEL);\r\nif (!di) {\r\ndev_err(&client->dev, "failed to allocate device info data\n");\r\nretval = -ENOMEM;\r\ngoto batt_failed_2;\r\n}\r\ndi->id = num;\r\ndi->dev = &client->dev;\r\ndi->chip = id->driver_data;\r\ndi->bat.name = name;\r\ndi->bus.read = &bq27x00_read_i2c;\r\nif (bq27x00_powersupply_init(di))\r\ngoto batt_failed_3;\r\ni2c_set_clientdata(client, di);\r\nreturn 0;\r\nbatt_failed_3:\r\nkfree(di);\r\nbatt_failed_2:\r\nkfree(name);\r\nbatt_failed_1:\r\nmutex_lock(&battery_mutex);\r\nidr_remove(&battery_id, num);\r\nmutex_unlock(&battery_mutex);\r\nreturn retval;\r\n}\r\nstatic int bq27x00_battery_remove(struct i2c_client *client)\r\n{\r\nstruct bq27x00_device_info *di = i2c_get_clientdata(client);\r\nbq27x00_powersupply_unregister(di);\r\nkfree(di->bat.name);\r\nmutex_lock(&battery_mutex);\r\nidr_remove(&battery_id, di->id);\r\nmutex_unlock(&battery_mutex);\r\nkfree(di);\r\nreturn 0;\r\n}\r\nstatic inline int bq27x00_battery_i2c_init(void)\r\n{\r\nint ret = i2c_add_driver(&bq27x00_battery_driver);\r\nif (ret)\r\nprintk(KERN_ERR "Unable to register BQ27x00 i2c driver\n");\r\nreturn ret;\r\n}\r\nstatic inline void bq27x00_battery_i2c_exit(void)\r\n{\r\ni2c_del_driver(&bq27x00_battery_driver);\r\n}\r\nstatic inline int bq27x00_battery_i2c_init(void) { return 0; }\r\nstatic inline void bq27x00_battery_i2c_exit(void) {}\r\nstatic int bq27000_read_platform(struct bq27x00_device_info *di, u8 reg,\r\nbool single)\r\n{\r\nstruct device *dev = di->dev;\r\nstruct bq27000_platform_data *pdata = dev->platform_data;\r\nunsigned int timeout = 3;\r\nint upper, lower;\r\nint temp;\r\nif (!single) {\r\nupper = pdata->read(dev, reg + 1);\r\ndo {\r\ntemp = upper;\r\nif (upper < 0)\r\nreturn upper;\r\nlower = pdata->read(dev, reg);\r\nif (lower < 0)\r\nreturn lower;\r\nupper = pdata->read(dev, reg + 1);\r\n} while (temp != upper && --timeout);\r\nif (timeout == 0)\r\nreturn -EIO;\r\nreturn (upper << 8) | lower;\r\n}\r\nreturn pdata->read(dev, reg);\r\n}\r\nstatic int __devinit bq27000_battery_probe(struct platform_device *pdev)\r\n{\r\nstruct bq27x00_device_info *di;\r\nstruct bq27000_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform_data supplied\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->read) {\r\ndev_err(&pdev->dev, "no hdq read callback supplied\n");\r\nreturn -EINVAL;\r\n}\r\ndi = kzalloc(sizeof(*di), GFP_KERNEL);\r\nif (!di) {\r\ndev_err(&pdev->dev, "failed to allocate device info data\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, di);\r\ndi->dev = &pdev->dev;\r\ndi->chip = BQ27000;\r\ndi->bat.name = pdata->name ?: dev_name(&pdev->dev);\r\ndi->bus.read = &bq27000_read_platform;\r\nret = bq27x00_powersupply_init(di);\r\nif (ret)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(di);\r\nreturn ret;\r\n}\r\nstatic int __devexit bq27000_battery_remove(struct platform_device *pdev)\r\n{\r\nstruct bq27x00_device_info *di = platform_get_drvdata(pdev);\r\nbq27x00_powersupply_unregister(di);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(di);\r\nreturn 0;\r\n}\r\nstatic inline int bq27x00_battery_platform_init(void)\r\n{\r\nint ret = platform_driver_register(&bq27000_battery_driver);\r\nif (ret)\r\nprintk(KERN_ERR "Unable to register BQ27000 platform driver\n");\r\nreturn ret;\r\n}\r\nstatic inline void bq27x00_battery_platform_exit(void)\r\n{\r\nplatform_driver_unregister(&bq27000_battery_driver);\r\n}\r\nstatic inline int bq27x00_battery_platform_init(void) { return 0; }\r\nstatic inline void bq27x00_battery_platform_exit(void) {}\r\nstatic int __init bq27x00_battery_init(void)\r\n{\r\nint ret;\r\nret = bq27x00_battery_i2c_init();\r\nif (ret)\r\nreturn ret;\r\nret = bq27x00_battery_platform_init();\r\nif (ret)\r\nbq27x00_battery_i2c_exit();\r\nreturn ret;\r\n}\r\nstatic void __exit bq27x00_battery_exit(void)\r\n{\r\nbq27x00_battery_platform_exit();\r\nbq27x00_battery_i2c_exit();\r\n}
