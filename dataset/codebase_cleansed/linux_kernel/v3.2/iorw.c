int mei_ioctl_connect_client(struct file *file,\r\nstruct mei_connect_client_data *data)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_cl_cb *cb;\r\nstruct mei_client *client;\r\nstruct mei_cl *cl;\r\nstruct mei_cl *cl_pos = NULL;\r\nstruct mei_cl *cl_next = NULL;\r\nlong timeout = CONNECT_TIMEOUT;\r\nint i;\r\nint err;\r\nint rets;\r\ncl = file->private_data;\r\nif (WARN_ON(!cl || !cl->dev))\r\nreturn -ENODEV;\r\ndev = cl->dev;\r\ndev_dbg(&dev->pdev->dev, "mei_ioctl_connect_client() Entry\n");\r\ncb = kzalloc(sizeof(struct mei_cl_cb), GFP_KERNEL);\r\nif (!cb) {\r\nrets = -ENOMEM;\r\ngoto end;\r\n}\r\nINIT_LIST_HEAD(&cb->cb_list);\r\ncb->major_file_operations = MEI_IOCTL;\r\nif (dev->mei_state != MEI_ENABLED) {\r\nrets = -ENODEV;\r\ngoto end;\r\n}\r\nif (cl->state != MEI_FILE_INITIALIZING &&\r\ncl->state != MEI_FILE_DISCONNECTED) {\r\nrets = -EBUSY;\r\ngoto end;\r\n}\r\ni = mei_find_me_client_index(dev, data->in_client_uuid);\r\nif (i >= 0 && !dev->me_clients[i].props.fixed_address) {\r\ncl->me_client_id = dev->me_clients[i].client_id;\r\ncl->state = MEI_FILE_CONNECTING;\r\n}\r\ndev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",\r\ncl->me_client_id);\r\ndev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",\r\ndev->me_clients[i].props.protocol_version);\r\ndev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",\r\ndev->me_clients[i].props.max_msg_length);\r\nif (uuid_le_cmp(data->in_client_uuid, mei_amthi_guid) == 0) {\r\ndev_dbg(&dev->pdev->dev, "FW Client is amthi\n");\r\nif (dev->iamthif_cl.state != MEI_FILE_CONNECTED) {\r\nrets = -ENODEV;\r\ngoto end;\r\n}\r\nclear_bit(cl->host_client_id, dev->host_clients_map);\r\nlist_for_each_entry_safe(cl_pos, cl_next,\r\n&dev->file_list, link) {\r\nif (mei_cl_cmp_id(cl, cl_pos)) {\r\ndev_dbg(&dev->pdev->dev,\r\n"remove file private data node host"\r\n" client = %d, ME client = %d.\n",\r\ncl_pos->host_client_id,\r\ncl_pos->me_client_id);\r\nlist_del(&cl_pos->link);\r\n}\r\n}\r\ndev_dbg(&dev->pdev->dev, "free file private data memory.\n");\r\nkfree(cl);\r\ncl = NULL;\r\nfile->private_data = &dev->iamthif_cl;\r\nclient = &data->out_client_properties;\r\nclient->max_msg_length =\r\ndev->me_clients[i].props.max_msg_length;\r\nclient->protocol_version =\r\ndev->me_clients[i].props.protocol_version;\r\nrets = dev->iamthif_cl.status;\r\ngoto end;\r\n}\r\nif (cl->state != MEI_FILE_CONNECTING) {\r\nrets = -ENODEV;\r\ngoto end;\r\n}\r\nclient = &data->out_client_properties;\r\nclient->max_msg_length = dev->me_clients[i].props.max_msg_length;\r\nclient->protocol_version = dev->me_clients[i].props.protocol_version;\r\ndev_dbg(&dev->pdev->dev, "Can connect?\n");\r\nif (dev->mei_host_buffer_is_empty\r\n&& !mei_other_client_is_connecting(dev, cl)) {\r\ndev_dbg(&dev->pdev->dev, "Sending Connect Message\n");\r\ndev->mei_host_buffer_is_empty = false;\r\nif (!mei_connect(dev, cl)) {\r\ndev_dbg(&dev->pdev->dev, "Sending connect message - failed\n");\r\nrets = -ENODEV;\r\ngoto end;\r\n} else {\r\ndev_dbg(&dev->pdev->dev, "Sending connect message - succeeded\n");\r\ncl->timer_count = MEI_CONNECT_TIMEOUT;\r\ncb->file_private = cl;\r\nlist_add_tail(&cb->cb_list,\r\n&dev->ctrl_rd_list.mei_cb.\r\ncb_list);\r\n}\r\n} else {\r\ndev_dbg(&dev->pdev->dev, "Queuing the connect request due to device busy\n");\r\ncb->file_private = cl;\r\ndev_dbg(&dev->pdev->dev, "add connect cb to control write list.\n");\r\nlist_add_tail(&cb->cb_list,\r\n&dev->ctrl_wr_list.mei_cb.cb_list);\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nerr = wait_event_timeout(dev->wait_recvd_msg,\r\n(MEI_FILE_CONNECTED == cl->state ||\r\nMEI_FILE_DISCONNECTED == cl->state),\r\ntimeout * HZ);\r\nmutex_lock(&dev->device_lock);\r\nif (MEI_FILE_CONNECTED == cl->state) {\r\ndev_dbg(&dev->pdev->dev, "successfully connected to FW client.\n");\r\nrets = cl->status;\r\ngoto end;\r\n} else {\r\ndev_dbg(&dev->pdev->dev, "failed to connect to FW client.cl->state = %d.\n",\r\ncl->state);\r\nif (!err) {\r\ndev_dbg(&dev->pdev->dev,\r\n"wait_event_interruptible_timeout failed on client"\r\n" connect message fw response message.\n");\r\n}\r\nrets = -EFAULT;\r\nmei_io_list_flush(&dev->ctrl_rd_list, cl);\r\nmei_io_list_flush(&dev->ctrl_wr_list, cl);\r\ngoto end;\r\n}\r\nrets = 0;\r\nend:\r\ndev_dbg(&dev->pdev->dev, "free connect cb memory.");\r\nkfree(cb);\r\nreturn rets;\r\n}\r\nstruct mei_cl_cb *find_amthi_read_list_entry(\r\nstruct mei_device *dev,\r\nstruct file *file)\r\n{\r\nstruct mei_cl *cl_temp;\r\nstruct mei_cl_cb *cb_pos = NULL;\r\nstruct mei_cl_cb *cb_next = NULL;\r\nif (!dev->amthi_read_complete_list.status &&\r\n!list_empty(&dev->amthi_read_complete_list.mei_cb.cb_list)) {\r\nlist_for_each_entry_safe(cb_pos, cb_next,\r\n&dev->amthi_read_complete_list.mei_cb.cb_list, cb_list) {\r\ncl_temp = (struct mei_cl *)cb_pos->file_private;\r\nif (cl_temp && cl_temp == &dev->iamthif_cl &&\r\ncb_pos->file_object == file)\r\nreturn cb_pos;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint amthi_read(struct mei_device *dev, struct file *file,\r\nchar __user *ubuf, size_t length, loff_t *offset)\r\n{\r\nint rets;\r\nint wait_ret;\r\nstruct mei_cl_cb *cb = NULL;\r\nstruct mei_cl *cl = file->private_data;\r\nunsigned long timeout;\r\nint i;\r\nif (!cl || cl != &dev->iamthif_cl) {\r\ndev_dbg(&dev->pdev->dev, "bad file ext.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nfor (i = 0; i < dev->me_clients_num; i++) {\r\nif (dev->me_clients[i].client_id ==\r\ndev->iamthif_cl.me_client_id)\r\nbreak;\r\n}\r\nif (i == dev->me_clients_num) {\r\ndev_dbg(&dev->pdev->dev, "amthi client not found.\n");\r\nreturn -ENODEV;\r\n}\r\nif (WARN_ON(dev->me_clients[i].client_id != cl->me_client_id))\r\nreturn -ENODEV;\r\ndev_dbg(&dev->pdev->dev, "checking amthi data\n");\r\ncb = find_amthi_read_list_entry(dev, file);\r\nif (cb == NULL && file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\ndev_dbg(&dev->pdev->dev, "waiting for amthi data\n");\r\nwhile (cb == NULL) {\r\nmutex_unlock(&dev->device_lock);\r\nwait_ret = wait_event_interruptible(dev->iamthif_cl.wait,\r\n(cb = find_amthi_read_list_entry(dev, file)));\r\nif (wait_ret)\r\nreturn -ERESTARTSYS;\r\ndev_dbg(&dev->pdev->dev, "woke up from sleep\n");\r\nmutex_lock(&dev->device_lock);\r\n}\r\ndev_dbg(&dev->pdev->dev, "Got amthi data\n");\r\ndev->iamthif_timer = 0;\r\nif (cb) {\r\ntimeout = cb->read_time +\r\nmsecs_to_jiffies(IAMTHIF_READ_TIMER);\r\ndev_dbg(&dev->pdev->dev, "amthi timeout = %lud\n",\r\ntimeout);\r\nif (time_after(jiffies, timeout)) {\r\ndev_dbg(&dev->pdev->dev, "amthi Time out\n");\r\nlist_del(&cb->cb_list);\r\nrets = -ETIMEDOUT;\r\ngoto free;\r\n}\r\n}\r\nif (cb->information >= *offset &&\r\nlength >= (cb->information - *offset))\r\nlist_del(&cb->cb_list);\r\nelse if (cb->information > 0 && cb->information <= *offset) {\r\nlist_del(&cb->cb_list);\r\nrets = 0;\r\ngoto free;\r\n}\r\ndev_dbg(&dev->pdev->dev, "amthi cb->response_buffer size - %d\n",\r\ncb->response_buffer.size);\r\ndev_dbg(&dev->pdev->dev, "amthi cb->information - %lu\n",\r\ncb->information);\r\nlength = min_t(size_t, length, (cb->information - *offset));\r\nif (copy_to_user(ubuf,\r\ncb->response_buffer.data + *offset,\r\nlength))\r\nrets = -EFAULT;\r\nelse {\r\nrets = length;\r\nif ((*offset + length) < cb->information) {\r\n*offset += length;\r\ngoto out;\r\n}\r\n}\r\nfree:\r\ndev_dbg(&dev->pdev->dev, "free amthi cb memory.\n");\r\n*offset = 0;\r\nmei_free_cb_private(cb);\r\nout:\r\nreturn rets;\r\n}\r\nint mei_start_read(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nstruct mei_cl_cb *cb;\r\nint rets = 0;\r\nint i;\r\nif (cl->state != MEI_FILE_CONNECTED)\r\nreturn -ENODEV;\r\nif (dev->mei_state != MEI_ENABLED)\r\nreturn -ENODEV;\r\ndev_dbg(&dev->pdev->dev, "check if read is pending.\n");\r\nif (cl->read_pending || cl->read_cb) {\r\ndev_dbg(&dev->pdev->dev, "read is pending.\n");\r\nreturn -EBUSY;\r\n}\r\ncb = kzalloc(sizeof(struct mei_cl_cb), GFP_KERNEL);\r\nif (!cb)\r\nreturn -ENOMEM;\r\ndev_dbg(&dev->pdev->dev, "allocation call back successful. host client = %d, ME client = %d\n",\r\ncl->host_client_id, cl->me_client_id);\r\nfor (i = 0; i < dev->me_clients_num; i++) {\r\nif (dev->me_clients[i].client_id == cl->me_client_id)\r\nbreak;\r\n}\r\nif (WARN_ON(dev->me_clients[i].client_id != cl->me_client_id)) {\r\nrets = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (i == dev->me_clients_num) {\r\nrets = -ENODEV;\r\ngoto unlock;\r\n}\r\ncb->response_buffer.size = dev->me_clients[i].props.max_msg_length;\r\ncb->response_buffer.data =\r\nkmalloc(cb->response_buffer.size, GFP_KERNEL);\r\nif (!cb->response_buffer.data) {\r\nrets = -ENOMEM;\r\ngoto unlock;\r\n}\r\ndev_dbg(&dev->pdev->dev, "allocation call back data success.\n");\r\ncb->major_file_operations = MEI_READ;\r\ncb->information = 0;\r\ncb->file_private = (void *) cl;\r\ncl->read_cb = cb;\r\nif (dev->mei_host_buffer_is_empty) {\r\ndev->mei_host_buffer_is_empty = false;\r\nif (!mei_send_flow_control(dev, cl)) {\r\nrets = -ENODEV;\r\ngoto unlock;\r\n} else {\r\nlist_add_tail(&cb->cb_list,\r\n&dev->read_list.mei_cb.cb_list);\r\n}\r\n} else {\r\nlist_add_tail(&cb->cb_list,\r\n&dev->ctrl_wr_list.mei_cb.cb_list);\r\n}\r\nreturn rets;\r\nunlock:\r\nmei_free_cb_private(cb);\r\nreturn rets;\r\n}\r\nint amthi_write(struct mei_device *dev, struct mei_cl_cb *cb)\r\n{\r\nstruct mei_msg_hdr mei_hdr;\r\nint ret;\r\nif (!dev || !cb)\r\nreturn -ENODEV;\r\ndev_dbg(&dev->pdev->dev, "write data to amthi client.\n");\r\ndev->iamthif_state = MEI_IAMTHIF_WRITING;\r\ndev->iamthif_current_cb = cb;\r\ndev->iamthif_file_object = cb->file_object;\r\ndev->iamthif_canceled = false;\r\ndev->iamthif_ioctl = true;\r\ndev->iamthif_msg_buf_size = cb->request_buffer.size;\r\nmemcpy(dev->iamthif_msg_buf, cb->request_buffer.data,\r\ncb->request_buffer.size);\r\nret = mei_flow_ctrl_creds(dev, &dev->iamthif_cl);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret && dev->mei_host_buffer_is_empty) {\r\nret = 0;\r\ndev->mei_host_buffer_is_empty = false;\r\nif (cb->request_buffer.size >\r\n(((dev->host_hw_state & H_CBD) >> 24) * sizeof(u32))\r\n-sizeof(struct mei_msg_hdr)) {\r\nmei_hdr.length =\r\n(((dev->host_hw_state & H_CBD) >> 24) *\r\nsizeof(u32)) - sizeof(struct mei_msg_hdr);\r\nmei_hdr.msg_complete = 0;\r\n} else {\r\nmei_hdr.length = cb->request_buffer.size;\r\nmei_hdr.msg_complete = 1;\r\n}\r\nmei_hdr.host_addr = dev->iamthif_cl.host_client_id;\r\nmei_hdr.me_addr = dev->iamthif_cl.me_client_id;\r\nmei_hdr.reserved = 0;\r\ndev->iamthif_msg_buf_index += mei_hdr.length;\r\nif (!mei_write_message(dev, &mei_hdr,\r\n(unsigned char *)(dev->iamthif_msg_buf),\r\nmei_hdr.length))\r\nreturn -ENODEV;\r\nif (mei_hdr.msg_complete) {\r\nif (mei_flow_ctrl_reduce(dev, &dev->iamthif_cl))\r\nreturn -ENODEV;\r\ndev->iamthif_flow_control_pending = true;\r\ndev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;\r\ndev_dbg(&dev->pdev->dev, "add amthi cb to write waiting list\n");\r\ndev->iamthif_current_cb = cb;\r\ndev->iamthif_file_object = cb->file_object;\r\nlist_add_tail(&cb->cb_list,\r\n&dev->write_waiting_list.mei_cb.cb_list);\r\n} else {\r\ndev_dbg(&dev->pdev->dev, "message does not complete, "\r\n"so add amthi cb to write list.\n");\r\nlist_add_tail(&cb->cb_list,\r\n&dev->write_list.mei_cb.cb_list);\r\n}\r\n} else {\r\nif (!(dev->mei_host_buffer_is_empty))\r\ndev_dbg(&dev->pdev->dev, "host buffer is not empty");\r\ndev_dbg(&dev->pdev->dev, "No flow control credentials, "\r\n"so add iamthif cb to write list.\n");\r\nlist_add_tail(&cb->cb_list,\r\n&dev->write_list.mei_cb.cb_list);\r\n}\r\nreturn 0;\r\n}\r\nvoid mei_run_next_iamthif_cmd(struct mei_device *dev)\r\n{\r\nstruct mei_cl *cl_tmp;\r\nstruct mei_cl_cb *cb_pos = NULL;\r\nstruct mei_cl_cb *cb_next = NULL;\r\nint status;\r\nif (!dev)\r\nreturn;\r\ndev->iamthif_msg_buf_size = 0;\r\ndev->iamthif_msg_buf_index = 0;\r\ndev->iamthif_canceled = false;\r\ndev->iamthif_ioctl = true;\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\ndev->iamthif_timer = 0;\r\ndev->iamthif_file_object = NULL;\r\nif (dev->amthi_cmd_list.status == 0 &&\r\n!list_empty(&dev->amthi_cmd_list.mei_cb.cb_list)) {\r\ndev_dbg(&dev->pdev->dev, "complete amthi cmd_list cb.\n");\r\nlist_for_each_entry_safe(cb_pos, cb_next,\r\n&dev->amthi_cmd_list.mei_cb.cb_list, cb_list) {\r\nlist_del(&cb_pos->cb_list);\r\ncl_tmp = (struct mei_cl *)cb_pos->file_private;\r\nif (cl_tmp && cl_tmp == &dev->iamthif_cl) {\r\nstatus = amthi_write(dev, cb_pos);\r\nif (status) {\r\ndev_dbg(&dev->pdev->dev,\r\n"amthi write failed status = %d\n",\r\nstatus);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nvoid mei_free_cb_private(struct mei_cl_cb *cb)\r\n{\r\nif (cb == NULL)\r\nreturn;\r\nkfree(cb->request_buffer.data);\r\nkfree(cb->response_buffer.data);\r\nkfree(cb);\r\n}
