acpi_status\r\nacpi_ns_check_predefined_names(struct acpi_namespace_node *node,\r\nu32 user_param_count,\r\nacpi_status return_status,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nacpi_status status = AE_OK;\r\nconst union acpi_predefined_info *predefined;\r\nchar *pathname;\r\nstruct acpi_predefined_data *data;\r\npredefined = acpi_ns_check_for_predefined_name(node);\r\npathname = acpi_ns_get_external_pathname(node);\r\nif (!pathname) {\r\nreturn AE_OK;\r\n}\r\nacpi_ns_check_parameter_count(pathname, node, user_param_count,\r\npredefined);\r\nif (!predefined) {\r\ngoto cleanup;\r\n}\r\nif ((return_status != AE_OK) && (return_status != AE_CTRL_RETURN_VALUE)) {\r\ngoto cleanup;\r\n}\r\nif (!return_object) {\r\nif ((predefined->info.expected_btypes) &&\r\n(!(predefined->info.expected_btypes & ACPI_RTYPE_NONE))) {\r\nACPI_WARN_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Missing expected return value"));\r\nstatus = AE_AML_NO_RETURN_VALUE;\r\n}\r\ngoto cleanup;\r\n}\r\nif (acpi_gbl_disable_auto_repair ||\r\n(!predefined->info.expected_btypes) ||\r\n(predefined->info.expected_btypes == ACPI_RTYPE_ALL)) {\r\ngoto cleanup;\r\n}\r\ndata = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_predefined_data));\r\nif (!data) {\r\ngoto cleanup;\r\n}\r\ndata->predefined = predefined;\r\ndata->node = node;\r\ndata->node_flags = node->flags;\r\ndata->pathname = pathname;\r\nstatus = acpi_ns_check_object_type(data, return_object_ptr,\r\npredefined->info.expected_btypes,\r\nACPI_NOT_PACKAGE_ELEMENT);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nif ((*return_object_ptr)->common.type == ACPI_TYPE_PACKAGE) {\r\ndata->parent_package = *return_object_ptr;\r\nstatus = acpi_ns_check_package(data, return_object_ptr);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\n}\r\nstatus = acpi_ns_complex_repairs(data, node, status, return_object_ptr);\r\nexit:\r\nif (ACPI_FAILURE(status) || (data->flags & ACPI_OBJECT_REPAIRED)) {\r\nnode->flags |= ANOBJ_EVALUATED;\r\n}\r\nACPI_FREE(data);\r\ncleanup:\r\nACPI_FREE(pathname);\r\nreturn (status);\r\n}\r\nvoid\r\nacpi_ns_check_parameter_count(char *pathname,\r\nstruct acpi_namespace_node *node,\r\nu32 user_param_count,\r\nconst union acpi_predefined_info *predefined)\r\n{\r\nu32 param_count;\r\nu32 required_params_current;\r\nu32 required_params_old;\r\nparam_count = 0;\r\nif (node->type == ACPI_TYPE_METHOD) {\r\nparam_count = node->object->method.param_count;\r\n}\r\nif (!predefined) {\r\nif (user_param_count < param_count) {\r\nACPI_WARN_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Insufficient arguments - needs %u, found %u",\r\nparam_count, user_param_count));\r\n} else if (user_param_count > param_count) {\r\nACPI_WARN_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Excess arguments - needs %u, found %u",\r\nparam_count, user_param_count));\r\n}\r\nreturn;\r\n}\r\nrequired_params_current = predefined->info.param_count & 0x0F;\r\nrequired_params_old = predefined->info.param_count >> 4;\r\nif (user_param_count != ACPI_UINT32_MAX) {\r\nif ((user_param_count != required_params_current) &&\r\n(user_param_count != required_params_old)) {\r\nACPI_WARN_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Parameter count mismatch - "\r\n"caller passed %u, ACPI requires %u",\r\nuser_param_count,\r\nrequired_params_current));\r\n}\r\n}\r\nif ((param_count != required_params_current) &&\r\n(param_count != required_params_old)) {\r\nACPI_WARN_PREDEFINED((AE_INFO, pathname, node->flags,\r\n"Parameter count mismatch - ASL declared %u, ACPI requires %u",\r\nparam_count, required_params_current));\r\n}\r\n}\r\nconst union acpi_predefined_info *acpi_ns_check_for_predefined_name(struct\r\nacpi_namespace_node\r\n*node)\r\n{\r\nconst union acpi_predefined_info *this_name;\r\nif (node->name.ascii[0] != '_') {\r\nreturn (NULL);\r\n}\r\nthis_name = predefined_names;\r\nwhile (this_name->info.name[0]) {\r\nif (ACPI_COMPARE_NAME(node->name.ascii, this_name->info.name)) {\r\nreturn (this_name);\r\n}\r\nif (this_name->info.expected_btypes & ACPI_RTYPE_PACKAGE) {\r\nthis_name++;\r\n}\r\nthis_name++;\r\n}\r\nreturn (NULL);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_package(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nconst union acpi_predefined_info *package;\r\nunion acpi_operand_object **elements;\r\nacpi_status status = AE_OK;\r\nu32 expected_count;\r\nu32 count;\r\nu32 i;\r\nACPI_FUNCTION_NAME(ns_check_package);\r\npackage = data->predefined + 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"%s Validating return Package of Type %X, Count %X\n",\r\ndata->pathname, package->ret_info.type,\r\nreturn_object->package.count));\r\nacpi_ns_remove_null_elements(data, package->ret_info.type,\r\nreturn_object);\r\nelements = return_object->package.elements;\r\ncount = return_object->package.count;\r\nif (!count) {\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Return Package has no elements (empty)"));\r\nreturn (AE_AML_OPERAND_VALUE);\r\n}\r\nswitch (package->ret_info.type) {\r\ncase ACPI_PTYPE1_FIXED:\r\nexpected_count =\r\npackage->ret_info.count1 + package->ret_info.count2;\r\nif (count < expected_count) {\r\ngoto package_too_small;\r\n} else if (count > expected_count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s: Return Package is larger than needed - "\r\n"found %u, expected %u\n",\r\ndata->pathname, count,\r\nexpected_count));\r\n}\r\nstatus = acpi_ns_check_package_elements(data, elements,\r\npackage->ret_info.\r\nobject_type1,\r\npackage->ret_info.\r\ncount1,\r\npackage->ret_info.\r\nobject_type2,\r\npackage->ret_info.\r\ncount2, 0);\r\nbreak;\r\ncase ACPI_PTYPE1_VAR:\r\nfor (i = 0; i < count; i++) {\r\nstatus = acpi_ns_check_object_type(data, elements,\r\npackage->ret_info.\r\nobject_type1, i);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nelements++;\r\n}\r\nbreak;\r\ncase ACPI_PTYPE1_OPTION:\r\nexpected_count = package->ret_info3.count;\r\nif (count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (i < package->ret_info3.count) {\r\nstatus =\r\nacpi_ns_check_object_type(data, elements,\r\npackage->\r\nret_info3.\r\nobject_type[i],\r\ni);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n} else {\r\nstatus =\r\nacpi_ns_check_object_type(data, elements,\r\npackage->\r\nret_info3.\r\ntail_object_type,\r\ni);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nelements++;\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_REV_FIXED:\r\nstatus = acpi_ns_check_object_type(data, elements,\r\nACPI_RTYPE_INTEGER, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nelements++;\r\ncount--;\r\nstatus =\r\nacpi_ns_check_package_list(data, package, elements, count);\r\nbreak;\r\ncase ACPI_PTYPE2_PKG_COUNT:\r\nstatus = acpi_ns_check_object_type(data, elements,\r\nACPI_RTYPE_INTEGER, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nexpected_count = (u32) (*elements)->integer.value;\r\nif (expected_count >= count) {\r\ngoto package_too_small;\r\n}\r\ncount = expected_count;\r\nelements++;\r\nstatus =\r\nacpi_ns_check_package_list(data, package, elements, count);\r\nbreak;\r\ncase ACPI_PTYPE2:\r\ncase ACPI_PTYPE2_FIXED:\r\ncase ACPI_PTYPE2_MIN:\r\ncase ACPI_PTYPE2_COUNT:\r\nif (*elements\r\n&& ((*elements)->common.type != ACPI_TYPE_PACKAGE)) {\r\nstatus =\r\nacpi_ns_repair_package_list(data,\r\nreturn_object_ptr);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nreturn_object = *return_object_ptr;\r\nelements = return_object->package.elements;\r\ncount = 1;\r\n}\r\nstatus =\r\nacpi_ns_check_package_list(data, package, elements, count);\r\nbreak;\r\ndefault:\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Invalid internal return type in table entry: %X",\r\npackage->ret_info.type));\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nreturn (status);\r\npackage_too_small:\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Return Package is too small - found %u elements, expected %u",\r\ncount, expected_count));\r\nreturn (AE_AML_OPERAND_VALUE);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_package_list(struct acpi_predefined_data *data,\r\nconst union acpi_predefined_info *package,\r\nunion acpi_operand_object **elements, u32 count)\r\n{\r\nunion acpi_operand_object *sub_package;\r\nunion acpi_operand_object **sub_elements;\r\nacpi_status status;\r\nu32 expected_count;\r\nu32 i;\r\nu32 j;\r\nfor (i = 0; i < count; i++) {\r\nsub_package = *elements;\r\nsub_elements = sub_package->package.elements;\r\ndata->parent_package = sub_package;\r\nstatus = acpi_ns_check_object_type(data, &sub_package,\r\nACPI_RTYPE_PACKAGE, i);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\ndata->parent_package = sub_package;\r\nswitch (package->ret_info.type) {\r\ncase ACPI_PTYPE2:\r\ncase ACPI_PTYPE2_PKG_COUNT:\r\ncase ACPI_PTYPE2_REV_FIXED:\r\nexpected_count =\r\npackage->ret_info.count1 + package->ret_info.count2;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nstatus =\r\nacpi_ns_check_package_elements(data, sub_elements,\r\npackage->ret_info.\r\nobject_type1,\r\npackage->ret_info.\r\ncount1,\r\npackage->ret_info.\r\nobject_type2,\r\npackage->ret_info.\r\ncount2, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_FIXED:\r\nexpected_count = package->ret_info2.count;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nfor (j = 0; j < expected_count; j++) {\r\nstatus =\r\nacpi_ns_check_object_type(data,\r\n&sub_elements[j],\r\npackage->\r\nret_info2.\r\nobject_type[j],\r\nj);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_MIN:\r\nexpected_count = package->ret_info.count1;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nstatus =\r\nacpi_ns_check_package_elements(data, sub_elements,\r\npackage->ret_info.\r\nobject_type1,\r\nsub_package->package.\r\ncount, 0, 0, 0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nbreak;\r\ncase ACPI_PTYPE2_COUNT:\r\nstatus = acpi_ns_check_object_type(data, sub_elements,\r\nACPI_RTYPE_INTEGER,\r\n0);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nexpected_count = (u32)(*sub_elements)->integer.value;\r\nif (sub_package->package.count < expected_count) {\r\ngoto package_too_small;\r\n}\r\nif (sub_package->package.count <\r\npackage->ret_info.count1) {\r\nexpected_count = package->ret_info.count1;\r\ngoto package_too_small;\r\n}\r\nif (expected_count == 0) {\r\nexpected_count = sub_package->package.count;\r\n(*sub_elements)->integer.value = expected_count;\r\n}\r\nstatus =\r\nacpi_ns_check_package_elements(data,\r\n(sub_elements + 1),\r\npackage->ret_info.\r\nobject_type1,\r\n(expected_count - 1),\r\n0, 0, 1);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nbreak;\r\ndefault:\r\nreturn (AE_AML_INTERNAL);\r\n}\r\nelements++;\r\n}\r\nreturn (AE_OK);\r\npackage_too_small:\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Return Sub-Package[%u] is too small - found %u elements, expected %u",\r\ni, sub_package->package.count, expected_count));\r\nreturn (AE_AML_OPERAND_VALUE);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_package_elements(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **elements,\r\nu8 type1,\r\nu32 count1,\r\nu8 type2, u32 count2, u32 start_index)\r\n{\r\nunion acpi_operand_object **this_element = elements;\r\nacpi_status status;\r\nu32 i;\r\nfor (i = 0; i < count1; i++) {\r\nstatus = acpi_ns_check_object_type(data, this_element,\r\ntype1, i + start_index);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nthis_element++;\r\n}\r\nfor (i = 0; i < count2; i++) {\r\nstatus = acpi_ns_check_object_type(data, this_element,\r\ntype2,\r\n(i + count1 + start_index));\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nthis_element++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_object_type(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr,\r\nu32 expected_btypes, u32 package_index)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nacpi_status status = AE_OK;\r\nu32 return_btype;\r\nchar type_buffer[48];\r\nif (!return_object) {\r\nstatus = acpi_ns_repair_null_element(data, expected_btypes,\r\npackage_index,\r\nreturn_object_ptr);\r\nif (ACPI_SUCCESS(status)) {\r\nreturn (AE_OK);\r\n}\r\ngoto type_error_exit;\r\n}\r\nif (ACPI_GET_DESCRIPTOR_TYPE(return_object) == ACPI_DESC_TYPE_NAMED) {\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Invalid return type - Found a Namespace node [%4.4s] type %s",\r\nreturn_object->node.name.ascii,\r\nacpi_ut_get_type_name(return_object->node.\r\ntype)));\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nswitch (return_object->common.type) {\r\ncase ACPI_TYPE_INTEGER:\r\nreturn_btype = ACPI_RTYPE_INTEGER;\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\nreturn_btype = ACPI_RTYPE_BUFFER;\r\nbreak;\r\ncase ACPI_TYPE_STRING:\r\nreturn_btype = ACPI_RTYPE_STRING;\r\nbreak;\r\ncase ACPI_TYPE_PACKAGE:\r\nreturn_btype = ACPI_RTYPE_PACKAGE;\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_REFERENCE:\r\nreturn_btype = ACPI_RTYPE_REFERENCE;\r\nbreak;\r\ndefault:\r\ngoto type_error_exit;\r\n}\r\nif (return_btype & expected_btypes) {\r\nif (return_object->common.type == ACPI_TYPE_LOCAL_REFERENCE) {\r\nstatus = acpi_ns_check_reference(data, return_object);\r\n}\r\nreturn (status);\r\n}\r\nstatus = acpi_ns_repair_object(data, expected_btypes,\r\npackage_index, return_object_ptr);\r\nif (ACPI_SUCCESS(status)) {\r\nreturn (AE_OK);\r\n}\r\ntype_error_exit:\r\nacpi_ns_get_expected_types(type_buffer, expected_btypes);\r\nif (package_index == ACPI_NOT_PACKAGE_ELEMENT) {\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Return type mismatch - found %s, expected %s",\r\nacpi_ut_get_object_type_name\r\n(return_object), type_buffer));\r\n} else {\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Return Package type mismatch at index %u - "\r\n"found %s, expected %s", package_index,\r\nacpi_ut_get_object_type_name\r\n(return_object), type_buffer));\r\n}\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_reference(struct acpi_predefined_data *data,\r\nunion acpi_operand_object *return_object)\r\n{\r\nif (return_object->reference.class == ACPI_REFCLASS_NAME) {\r\nreturn (AE_OK);\r\n}\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Return type mismatch - unexpected reference object type [%s] %2.2X",\r\nacpi_ut_get_reference_name(return_object),\r\nreturn_object->reference.class));\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nstatic void acpi_ns_get_expected_types(char *buffer, u32 expected_btypes)\r\n{\r\nu32 this_rtype;\r\nu32 i;\r\nu32 j;\r\nj = 1;\r\nbuffer[0] = 0;\r\nthis_rtype = ACPI_RTYPE_INTEGER;\r\nfor (i = 0; i < ACPI_NUM_RTYPES; i++) {\r\nif (expected_btypes & this_rtype) {\r\nACPI_STRCAT(buffer, &acpi_rtype_names[i][j]);\r\nj = 0;\r\n}\r\nthis_rtype <<= 1;\r\n}\r\n}
