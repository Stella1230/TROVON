static inline struct ov7670_info *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ov7670_info, sd);\r\n}\r\nstatic int ov7670_read_smbus(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char *value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret >= 0) {\r\n*value = (unsigned char)ret;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_write_smbus(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = i2c_smbus_write_byte_data(client, reg, value);\r\nif (reg == REG_COM7 && (value & COM7_RESET))\r\nmsleep(5);\r\nreturn ret;\r\n}\r\nstatic int ov7670_read_i2c(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char *value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 data = reg;\r\nstruct i2c_msg msg;\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 1;\r\nmsg.buf = &data;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Error %d on register write\n", ret);\r\nreturn ret;\r\n}\r\nmsg.flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret >= 0) {\r\n*value = data;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_write_i2c(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct i2c_msg msg;\r\nunsigned char data[2] = { reg, value };\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = data;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret > 0)\r\nret = 0;\r\nif (reg == REG_COM7 && (value & COM7_RESET))\r\nmsleep(5);\r\nreturn ret;\r\n}\r\nstatic int ov7670_read(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char *value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nif (info->use_smbus)\r\nreturn ov7670_read_smbus(sd, reg, value);\r\nelse\r\nreturn ov7670_read_i2c(sd, reg, value);\r\n}\r\nstatic int ov7670_write(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nif (info->use_smbus)\r\nreturn ov7670_write_smbus(sd, reg, value);\r\nelse\r\nreturn ov7670_write_i2c(sd, reg, value);\r\n}\r\nstatic int ov7670_write_array(struct v4l2_subdev *sd, struct regval_list *vals)\r\n{\r\nwhile (vals->reg_num != 0xff || vals->value != 0xff) {\r\nint ret = ov7670_write(sd, vals->reg_num, vals->value);\r\nif (ret < 0)\r\nreturn ret;\r\nvals++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov7670_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nov7670_write(sd, REG_COM7, COM7_RESET);\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int ov7670_init(struct v4l2_subdev *sd, u32 val)\r\n{\r\nreturn ov7670_write_array(sd, ov7670_default_regs);\r\n}\r\nstatic int ov7670_detect(struct v4l2_subdev *sd)\r\n{\r\nunsigned char v;\r\nint ret;\r\nret = ov7670_init(sd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov7670_read(sd, REG_MIDH, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0x7f)\r\nreturn -ENODEV;\r\nret = ov7670_read(sd, REG_MIDL, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0xa2)\r\nreturn -ENODEV;\r\nret = ov7670_read(sd, REG_PID, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0x76)\r\nreturn -ENODEV;\r\nret = ov7670_read(sd, REG_VER, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0x73)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ov7670_set_hw(struct v4l2_subdev *sd, int hstart, int hstop,\r\nint vstart, int vstop)\r\n{\r\nint ret;\r\nunsigned char v;\r\nret = ov7670_write(sd, REG_HSTART, (hstart >> 3) & 0xff);\r\nret += ov7670_write(sd, REG_HSTOP, (hstop >> 3) & 0xff);\r\nret += ov7670_read(sd, REG_HREF, &v);\r\nv = (v & 0xc0) | ((hstop & 0x7) << 3) | (hstart & 0x7);\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_HREF, v);\r\nret += ov7670_write(sd, REG_VSTART, (vstart >> 2) & 0xff);\r\nret += ov7670_write(sd, REG_VSTOP, (vstop >> 2) & 0xff);\r\nret += ov7670_read(sd, REG_VREF, &v);\r\nv = (v & 0xf0) | ((vstop & 0x3) << 2) | (vstart & 0x3);\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_VREF, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= N_OV7670_FMTS)\r\nreturn -EINVAL;\r\n*code = ov7670_formats[index].mbus_code;\r\nreturn 0;\r\n}\r\nstatic int ov7670_try_fmt_internal(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nstruct ov7670_format_struct **ret_fmt,\r\nstruct ov7670_win_size **ret_wsize)\r\n{\r\nint index;\r\nstruct ov7670_win_size *wsize;\r\nfor (index = 0; index < N_OV7670_FMTS; index++)\r\nif (ov7670_formats[index].mbus_code == fmt->code)\r\nbreak;\r\nif (index >= N_OV7670_FMTS) {\r\nindex = 0;\r\nfmt->code = ov7670_formats[0].mbus_code;\r\n}\r\nif (ret_fmt != NULL)\r\n*ret_fmt = ov7670_formats + index;\r\nfmt->field = V4L2_FIELD_NONE;\r\nfor (wsize = ov7670_win_sizes; wsize < ov7670_win_sizes + N_WIN_SIZES;\r\nwsize++)\r\nif (fmt->width >= wsize->width && fmt->height >= wsize->height)\r\nbreak;\r\nif (wsize >= ov7670_win_sizes + N_WIN_SIZES)\r\nwsize--;\r\nif (ret_wsize != NULL)\r\n*ret_wsize = wsize;\r\nfmt->width = wsize->width;\r\nfmt->height = wsize->height;\r\nfmt->colorspace = ov7670_formats[index].colorspace;\r\nreturn 0;\r\n}\r\nstatic int ov7670_try_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nreturn ov7670_try_fmt_internal(sd, fmt, NULL, NULL);\r\n}\r\nstatic int ov7670_s_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct ov7670_format_struct *ovfmt;\r\nstruct ov7670_win_size *wsize;\r\nstruct ov7670_info *info = to_state(sd);\r\nunsigned char com7;\r\nint ret;\r\nret = ov7670_try_fmt_internal(sd, fmt, &ovfmt, &wsize);\r\nif (ret)\r\nreturn ret;\r\ncom7 = ovfmt->regs[0].value;\r\ncom7 |= wsize->com7_bit;\r\nov7670_write(sd, REG_COM7, com7);\r\nov7670_write_array(sd, ovfmt->regs + 1);\r\nov7670_set_hw(sd, wsize->hstart, wsize->hstop, wsize->vstart,\r\nwsize->vstop);\r\nret = 0;\r\nif (wsize->regs)\r\nret = ov7670_write_array(sd, wsize->regs);\r\ninfo->fmt = ovfmt;\r\nif (ret == 0)\r\nret = ov7670_write(sd, REG_CLKRC, info->clkrc);\r\nreturn 0;\r\n}\r\nstatic int ov7670_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct ov7670_info *info = to_state(sd);\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemset(cp, 0, sizeof(struct v4l2_captureparm));\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = 1;\r\ncp->timeperframe.denominator = info->clock_speed;\r\nif ((info->clkrc & CLK_EXT) == 0 && (info->clkrc & CLK_SCALE) > 1)\r\ncp->timeperframe.denominator /= (info->clkrc & CLK_SCALE);\r\nreturn 0;\r\n}\r\nstatic int ov7670_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nstruct ov7670_info *info = to_state(sd);\r\nint div;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cp->extendedmode != 0)\r\nreturn -EINVAL;\r\nif (tpf->numerator == 0 || tpf->denominator == 0)\r\ndiv = 1;\r\nelse\r\ndiv = (tpf->numerator * info->clock_speed) / tpf->denominator;\r\nif (div == 0)\r\ndiv = 1;\r\nelse if (div > CLK_SCALE)\r\ndiv = CLK_SCALE;\r\ninfo->clkrc = (info->clkrc & 0x80) | div;\r\ntpf->numerator = 1;\r\ntpf->denominator = info->clock_speed / div;\r\nreturn ov7670_write(sd, REG_CLKRC, info->clkrc);\r\n}\r\nstatic int ov7670_enum_frameintervals(struct v4l2_subdev *sd,\r\nstruct v4l2_frmivalenum *interval)\r\n{\r\nif (interval->index >= ARRAY_SIZE(ov7670_frame_rates))\r\nreturn -EINVAL;\r\ninterval->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\ninterval->discrete.numerator = 1;\r\ninterval->discrete.denominator = ov7670_frame_rates[interval->index];\r\nreturn 0;\r\n}\r\nstatic int ov7670_enum_framesizes(struct v4l2_subdev *sd,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nint i;\r\nint num_valid = -1;\r\n__u32 index = fsize->index;\r\nfor (i = 0; i < N_WIN_SIZES; i++) {\r\nstruct ov7670_win_size *win = &ov7670_win_sizes[index];\r\nif (info->min_width && win->width < info->min_width)\r\ncontinue;\r\nif (info->min_height && win->height < info->min_height)\r\ncontinue;\r\nif (index == ++num_valid) {\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = win->width;\r\nfsize->discrete.height = win->height;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov7670_store_cmatrix(struct v4l2_subdev *sd,\r\nint matrix[CMATRIX_LEN])\r\n{\r\nint i, ret;\r\nunsigned char signbits = 0;\r\nret = ov7670_read(sd, REG_CMATRIX_SIGN, &signbits);\r\nsignbits &= 0xc0;\r\nfor (i = 0; i < CMATRIX_LEN; i++) {\r\nunsigned char raw;\r\nif (matrix[i] < 0) {\r\nsignbits |= (1 << i);\r\nif (matrix[i] < -255)\r\nraw = 0xff;\r\nelse\r\nraw = (-1 * matrix[i]) & 0xff;\r\n}\r\nelse {\r\nif (matrix[i] > 255)\r\nraw = 0xff;\r\nelse\r\nraw = matrix[i] & 0xff;\r\n}\r\nret += ov7670_write(sd, REG_CMATRIX_BASE + i, raw);\r\n}\r\nret += ov7670_write(sd, REG_CMATRIX_SIGN, signbits);\r\nreturn ret;\r\n}\r\nstatic int ov7670_sine(int theta)\r\n{\r\nint chs = 1;\r\nint sine;\r\nif (theta < 0) {\r\ntheta = -theta;\r\nchs = -1;\r\n}\r\nif (theta <= 90)\r\nsine = ov7670_sin_table[theta/SIN_STEP];\r\nelse {\r\ntheta -= 90;\r\nsine = 1000 - ov7670_sin_table[theta/SIN_STEP];\r\n}\r\nreturn sine*chs;\r\n}\r\nstatic int ov7670_cosine(int theta)\r\n{\r\ntheta = 90 - theta;\r\nif (theta > 180)\r\ntheta -= 360;\r\nelse if (theta < -180)\r\ntheta += 360;\r\nreturn ov7670_sine(theta);\r\n}\r\nstatic void ov7670_calc_cmatrix(struct ov7670_info *info,\r\nint matrix[CMATRIX_LEN])\r\n{\r\nint i;\r\nfor (i = 0; i < CMATRIX_LEN; i++)\r\nmatrix[i] = (info->fmt->cmatrix[i]*info->sat) >> 7;\r\nif (info->hue != 0) {\r\nint sinth, costh, tmpmatrix[CMATRIX_LEN];\r\nmemcpy(tmpmatrix, matrix, CMATRIX_LEN*sizeof(int));\r\nsinth = ov7670_sine(info->hue);\r\ncosth = ov7670_cosine(info->hue);\r\nmatrix[0] = (matrix[3]*sinth + matrix[0]*costh)/1000;\r\nmatrix[1] = (matrix[4]*sinth + matrix[1]*costh)/1000;\r\nmatrix[2] = (matrix[5]*sinth + matrix[2]*costh)/1000;\r\nmatrix[3] = (matrix[3]*costh - matrix[0]*sinth)/1000;\r\nmatrix[4] = (matrix[4]*costh - matrix[1]*sinth)/1000;\r\nmatrix[5] = (matrix[5]*costh - matrix[2]*sinth)/1000;\r\n}\r\n}\r\nstatic int ov7670_s_sat(struct v4l2_subdev *sd, int value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nint matrix[CMATRIX_LEN];\r\nint ret;\r\ninfo->sat = value;\r\nov7670_calc_cmatrix(info, matrix);\r\nret = ov7670_store_cmatrix(sd, matrix);\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_sat(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\n*value = info->sat;\r\nreturn 0;\r\n}\r\nstatic int ov7670_s_hue(struct v4l2_subdev *sd, int value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nint matrix[CMATRIX_LEN];\r\nint ret;\r\nif (value < -180 || value > 180)\r\nreturn -EINVAL;\r\ninfo->hue = value;\r\nov7670_calc_cmatrix(info, matrix);\r\nret = ov7670_store_cmatrix(sd, matrix);\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_hue(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\n*value = info->hue;\r\nreturn 0;\r\n}\r\nstatic unsigned char ov7670_sm_to_abs(unsigned char v)\r\n{\r\nif ((v & 0x80) == 0)\r\nreturn v + 128;\r\nreturn 128 - (v & 0x7f);\r\n}\r\nstatic unsigned char ov7670_abs_to_sm(unsigned char v)\r\n{\r\nif (v > 127)\r\nreturn v & 0x7f;\r\nreturn (128 - v) | 0x80;\r\n}\r\nstatic int ov7670_s_brightness(struct v4l2_subdev *sd, int value)\r\n{\r\nunsigned char com8 = 0, v;\r\nint ret;\r\nov7670_read(sd, REG_COM8, &com8);\r\ncom8 &= ~COM8_AEC;\r\nov7670_write(sd, REG_COM8, com8);\r\nv = ov7670_abs_to_sm(value);\r\nret = ov7670_write(sd, REG_BRIGHT, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_brightness(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nunsigned char v = 0;\r\nint ret = ov7670_read(sd, REG_BRIGHT, &v);\r\n*value = ov7670_sm_to_abs(v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_contrast(struct v4l2_subdev *sd, int value)\r\n{\r\nreturn ov7670_write(sd, REG_CONTRAS, (unsigned char) value);\r\n}\r\nstatic int ov7670_g_contrast(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nunsigned char v = 0;\r\nint ret = ov7670_read(sd, REG_CONTRAS, &v);\r\n*value = v;\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_hflip(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nint ret;\r\nunsigned char v = 0;\r\nret = ov7670_read(sd, REG_MVFP, &v);\r\n*value = (v & MVFP_MIRROR) == MVFP_MIRROR;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_hflip(struct v4l2_subdev *sd, int value)\r\n{\r\nunsigned char v = 0;\r\nint ret;\r\nret = ov7670_read(sd, REG_MVFP, &v);\r\nif (value)\r\nv |= MVFP_MIRROR;\r\nelse\r\nv &= ~MVFP_MIRROR;\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_MVFP, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_vflip(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nint ret;\r\nunsigned char v = 0;\r\nret = ov7670_read(sd, REG_MVFP, &v);\r\n*value = (v & MVFP_FLIP) == MVFP_FLIP;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_vflip(struct v4l2_subdev *sd, int value)\r\n{\r\nunsigned char v = 0;\r\nint ret;\r\nret = ov7670_read(sd, REG_MVFP, &v);\r\nif (value)\r\nv |= MVFP_FLIP;\r\nelse\r\nv &= ~MVFP_FLIP;\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_MVFP, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_gain(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nint ret;\r\nunsigned char gain;\r\nret = ov7670_read(sd, REG_GAIN, &gain);\r\n*value = gain;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_gain(struct v4l2_subdev *sd, int value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nret = ov7670_write(sd, REG_GAIN, value & 0xff);\r\nif (ret == 0) {\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\nret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AGC);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_autogain(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\n*value = (com8 & COM8_AGC) != 0;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_autogain(struct v4l2_subdev *sd, int value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\nif (ret == 0) {\r\nif (value)\r\ncom8 |= COM8_AGC;\r\nelse\r\ncom8 &= ~COM8_AGC;\r\nret = ov7670_write(sd, REG_COM8, com8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_exp(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nint ret;\r\nunsigned char com1, aech, aechh;\r\nret = ov7670_read(sd, REG_COM1, &com1) +\r\nov7670_read(sd, REG_AECH, &aech) +\r\nov7670_read(sd, REG_AECHH, &aechh);\r\n*value = ((aechh & 0x3f) << 10) | (aech << 2) | (com1 & 0x03);\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_exp(struct v4l2_subdev *sd, int value)\r\n{\r\nint ret;\r\nunsigned char com1, com8, aech, aechh;\r\nret = ov7670_read(sd, REG_COM1, &com1) +\r\nov7670_read(sd, REG_COM8, &com8);\r\nov7670_read(sd, REG_AECHH, &aechh);\r\nif (ret)\r\nreturn ret;\r\ncom1 = (com1 & 0xfc) | (value & 0x03);\r\naech = (value >> 2) & 0xff;\r\naechh = (aechh & 0xc0) | ((value >> 10) & 0x3f);\r\nret = ov7670_write(sd, REG_COM1, com1) +\r\nov7670_write(sd, REG_AECH, aech) +\r\nov7670_write(sd, REG_AECHH, aechh);\r\nif (ret == 0)\r\nret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AEC);\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_autoexp(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nenum v4l2_exposure_auto_type *atype = (enum v4l2_exposure_auto_type *) value;\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\nif (com8 & COM8_AEC)\r\n*atype = V4L2_EXPOSURE_AUTO;\r\nelse\r\n*atype = V4L2_EXPOSURE_MANUAL;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_autoexp(struct v4l2_subdev *sd,\r\nenum v4l2_exposure_auto_type value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\nif (ret == 0) {\r\nif (value == V4L2_EXPOSURE_AUTO)\r\ncom8 |= COM8_AEC;\r\nelse\r\ncom8 &= ~COM8_AEC;\r\nret = ov7670_write(sd, REG_COM8, com8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_queryctrl(struct v4l2_subdev *sd,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nswitch (qc->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);\r\ncase V4L2_CID_CONTRAST:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 127, 1, 64);\r\ncase V4L2_CID_VFLIP:\r\ncase V4L2_CID_HFLIP:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);\r\ncase V4L2_CID_SATURATION:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 256, 1, 128);\r\ncase V4L2_CID_HUE:\r\nreturn v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);\r\ncase V4L2_CID_GAIN:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);\r\ncase V4L2_CID_AUTOGAIN:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);\r\ncase V4L2_CID_EXPOSURE:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 65535, 1, 500);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov7670_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn ov7670_g_brightness(sd, &ctrl->value);\r\ncase V4L2_CID_CONTRAST:\r\nreturn ov7670_g_contrast(sd, &ctrl->value);\r\ncase V4L2_CID_SATURATION:\r\nreturn ov7670_g_sat(sd, &ctrl->value);\r\ncase V4L2_CID_HUE:\r\nreturn ov7670_g_hue(sd, &ctrl->value);\r\ncase V4L2_CID_VFLIP:\r\nreturn ov7670_g_vflip(sd, &ctrl->value);\r\ncase V4L2_CID_HFLIP:\r\nreturn ov7670_g_hflip(sd, &ctrl->value);\r\ncase V4L2_CID_GAIN:\r\nreturn ov7670_g_gain(sd, &ctrl->value);\r\ncase V4L2_CID_AUTOGAIN:\r\nreturn ov7670_g_autogain(sd, &ctrl->value);\r\ncase V4L2_CID_EXPOSURE:\r\nreturn ov7670_g_exp(sd, &ctrl->value);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn ov7670_g_autoexp(sd, &ctrl->value);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov7670_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn ov7670_s_brightness(sd, ctrl->value);\r\ncase V4L2_CID_CONTRAST:\r\nreturn ov7670_s_contrast(sd, ctrl->value);\r\ncase V4L2_CID_SATURATION:\r\nreturn ov7670_s_sat(sd, ctrl->value);\r\ncase V4L2_CID_HUE:\r\nreturn ov7670_s_hue(sd, ctrl->value);\r\ncase V4L2_CID_VFLIP:\r\nreturn ov7670_s_vflip(sd, ctrl->value);\r\ncase V4L2_CID_HFLIP:\r\nreturn ov7670_s_hflip(sd, ctrl->value);\r\ncase V4L2_CID_GAIN:\r\nreturn ov7670_s_gain(sd, ctrl->value);\r\ncase V4L2_CID_AUTOGAIN:\r\nreturn ov7670_s_autogain(sd, ctrl->value);\r\ncase V4L2_CID_EXPOSURE:\r\nreturn ov7670_s_exp(sd, ctrl->value);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn ov7670_s_autoexp(sd,\r\n(enum v4l2_exposure_auto_type) ctrl->value);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov7670_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV7670, 0);\r\n}\r\nstatic int ov7670_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nunsigned char val = 0;\r\nint ret;\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nret = ov7670_read(sd, reg->reg & 0xff, &val);\r\nreg->val = val;\r\nreg->size = 1;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nov7670_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int ov7670_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct ov7670_info *info;\r\nint ret;\r\ninfo = kzalloc(sizeof(struct ov7670_info), GFP_KERNEL);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\nsd = &info->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ov7670_ops);\r\ninfo->clock_speed = 30;\r\nif (client->dev.platform_data) {\r\nstruct ov7670_config *config = client->dev.platform_data;\r\ninfo->min_width = config->min_width;\r\ninfo->min_height = config->min_height;\r\ninfo->use_smbus = config->use_smbus;\r\nif (config->clock_speed)\r\ninfo->clock_speed = config->clock_speed;\r\n}\r\nret = ov7670_detect(sd);\r\nif (ret) {\r\nv4l_dbg(1, debug, client,\r\n"chip found @ 0x%x (%s) is not an ov7670 chip.\n",\r\nclient->addr << 1, client->adapter->name);\r\nkfree(info);\r\nreturn ret;\r\n}\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\ninfo->fmt = &ov7670_formats[0];\r\ninfo->sat = 128;\r\ninfo->clkrc = info->clock_speed / 30;\r\nreturn 0;\r\n}\r\nstatic int ov7670_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}\r\nstatic __init int init_ov7670(void)\r\n{\r\nreturn i2c_add_driver(&ov7670_driver);\r\n}\r\nstatic __exit void exit_ov7670(void)\r\n{\r\ni2c_del_driver(&ov7670_driver);\r\n}
