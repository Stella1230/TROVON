static void trigger_event(struct work_struct *work)\r\n{\r\nstruct stripe_c *sc = container_of(work, struct stripe_c,\r\ntrigger_event);\r\ndm_table_event(sc->ti->table);\r\n}\r\nstatic inline struct stripe_c *alloc_context(unsigned int stripes)\r\n{\r\nsize_t len;\r\nif (dm_array_too_big(sizeof(struct stripe_c), sizeof(struct stripe),\r\nstripes))\r\nreturn NULL;\r\nlen = sizeof(struct stripe_c) + (sizeof(struct stripe) * stripes);\r\nreturn kmalloc(len, GFP_KERNEL);\r\n}\r\nstatic int get_stripe(struct dm_target *ti, struct stripe_c *sc,\r\nunsigned int stripe, char **argv)\r\n{\r\nunsigned long long start;\r\nif (sscanf(argv[1], "%llu", &start) != 1)\r\nreturn -EINVAL;\r\nif (dm_get_device(ti, argv[0], dm_table_get_mode(ti->table),\r\n&sc->stripe[stripe].dev))\r\nreturn -ENXIO;\r\nsc->stripe[stripe].physical_start = start;\r\nreturn 0;\r\n}\r\nstatic int stripe_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nstruct stripe_c *sc;\r\nsector_t width;\r\nuint32_t stripes;\r\nuint32_t chunk_size;\r\nchar *end;\r\nint r;\r\nunsigned int i;\r\nif (argc < 2) {\r\nti->error = "Not enough arguments";\r\nreturn -EINVAL;\r\n}\r\nstripes = simple_strtoul(argv[0], &end, 10);\r\nif (!stripes || *end) {\r\nti->error = "Invalid stripe count";\r\nreturn -EINVAL;\r\n}\r\nchunk_size = simple_strtoul(argv[1], &end, 10);\r\nif (*end) {\r\nti->error = "Invalid chunk_size";\r\nreturn -EINVAL;\r\n}\r\nif (!is_power_of_2(chunk_size) ||\r\n(chunk_size < (PAGE_SIZE >> SECTOR_SHIFT))) {\r\nti->error = "Invalid chunk size";\r\nreturn -EINVAL;\r\n}\r\nif (ti->len & (chunk_size - 1)) {\r\nti->error = "Target length not divisible by "\r\n"chunk size";\r\nreturn -EINVAL;\r\n}\r\nwidth = ti->len;\r\nif (sector_div(width, stripes)) {\r\nti->error = "Target length not divisible by "\r\n"number of stripes";\r\nreturn -EINVAL;\r\n}\r\nif (argc != (2 + 2 * stripes)) {\r\nti->error = "Not enough destinations "\r\n"specified";\r\nreturn -EINVAL;\r\n}\r\nsc = alloc_context(stripes);\r\nif (!sc) {\r\nti->error = "Memory allocation for striped context "\r\n"failed";\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&sc->trigger_event, trigger_event);\r\nsc->ti = ti;\r\nsc->stripes = stripes;\r\nsc->stripe_width = width;\r\nif (stripes & (stripes - 1))\r\nsc->stripes_shift = -1;\r\nelse {\r\nsc->stripes_shift = ffs(stripes) - 1;\r\nsc->stripes_mask = ((sector_t) stripes) - 1;\r\n}\r\nti->split_io = chunk_size;\r\nti->num_flush_requests = stripes;\r\nti->num_discard_requests = stripes;\r\nsc->chunk_shift = ffs(chunk_size) - 1;\r\nsc->chunk_mask = ((sector_t) chunk_size) - 1;\r\nfor (i = 0; i < stripes; i++) {\r\nargv += 2;\r\nr = get_stripe(ti, sc, i, argv);\r\nif (r < 0) {\r\nti->error = "Couldn't parse stripe destination";\r\nwhile (i--)\r\ndm_put_device(ti, sc->stripe[i].dev);\r\nkfree(sc);\r\nreturn r;\r\n}\r\natomic_set(&(sc->stripe[i].error_count), 0);\r\n}\r\nti->private = sc;\r\nreturn 0;\r\n}\r\nstatic void stripe_dtr(struct dm_target *ti)\r\n{\r\nunsigned int i;\r\nstruct stripe_c *sc = (struct stripe_c *) ti->private;\r\nfor (i = 0; i < sc->stripes; i++)\r\ndm_put_device(ti, sc->stripe[i].dev);\r\nflush_work_sync(&sc->trigger_event);\r\nkfree(sc);\r\n}\r\nstatic void stripe_map_sector(struct stripe_c *sc, sector_t sector,\r\nuint32_t *stripe, sector_t *result)\r\n{\r\nsector_t offset = dm_target_offset(sc->ti, sector);\r\nsector_t chunk = offset >> sc->chunk_shift;\r\nif (sc->stripes_shift < 0)\r\n*stripe = sector_div(chunk, sc->stripes);\r\nelse {\r\n*stripe = chunk & sc->stripes_mask;\r\nchunk >>= sc->stripes_shift;\r\n}\r\n*result = (chunk << sc->chunk_shift) | (offset & sc->chunk_mask);\r\n}\r\nstatic void stripe_map_range_sector(struct stripe_c *sc, sector_t sector,\r\nuint32_t target_stripe, sector_t *result)\r\n{\r\nuint32_t stripe;\r\nstripe_map_sector(sc, sector, &stripe, result);\r\nif (stripe == target_stripe)\r\nreturn;\r\n*result &= ~sc->chunk_mask;\r\nif (target_stripe < stripe)\r\n*result += sc->chunk_mask + 1;\r\n}\r\nstatic int stripe_map_discard(struct stripe_c *sc, struct bio *bio,\r\nuint32_t target_stripe)\r\n{\r\nsector_t begin, end;\r\nstripe_map_range_sector(sc, bio->bi_sector, target_stripe, &begin);\r\nstripe_map_range_sector(sc, bio->bi_sector + bio_sectors(bio),\r\ntarget_stripe, &end);\r\nif (begin < end) {\r\nbio->bi_bdev = sc->stripe[target_stripe].dev->bdev;\r\nbio->bi_sector = begin + sc->stripe[target_stripe].physical_start;\r\nbio->bi_size = to_bytes(end - begin);\r\nreturn DM_MAPIO_REMAPPED;\r\n} else {\r\nbio_endio(bio, 0);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\n}\r\nstatic int stripe_map(struct dm_target *ti, struct bio *bio,\r\nunion map_info *map_context)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nuint32_t stripe;\r\nunsigned target_request_nr;\r\nif (bio->bi_rw & REQ_FLUSH) {\r\ntarget_request_nr = map_context->target_request_nr;\r\nBUG_ON(target_request_nr >= sc->stripes);\r\nbio->bi_bdev = sc->stripe[target_request_nr].dev->bdev;\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nif (unlikely(bio->bi_rw & REQ_DISCARD)) {\r\ntarget_request_nr = map_context->target_request_nr;\r\nBUG_ON(target_request_nr >= sc->stripes);\r\nreturn stripe_map_discard(sc, bio, target_request_nr);\r\n}\r\nstripe_map_sector(sc, bio->bi_sector, &stripe, &bio->bi_sector);\r\nbio->bi_sector += sc->stripe[stripe].physical_start;\r\nbio->bi_bdev = sc->stripe[stripe].dev->bdev;\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nstatic int stripe_status(struct dm_target *ti,\r\nstatus_type_t type, char *result, unsigned int maxlen)\r\n{\r\nstruct stripe_c *sc = (struct stripe_c *) ti->private;\r\nchar buffer[sc->stripes + 1];\r\nunsigned int sz = 0;\r\nunsigned int i;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%d ", sc->stripes);\r\nfor (i = 0; i < sc->stripes; i++) {\r\nDMEMIT("%s ", sc->stripe[i].dev->name);\r\nbuffer[i] = atomic_read(&(sc->stripe[i].error_count)) ?\r\n'D' : 'A';\r\n}\r\nbuffer[i] = '\0';\r\nDMEMIT("1 %s", buffer);\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%d %llu", sc->stripes,\r\n(unsigned long long)sc->chunk_mask + 1);\r\nfor (i = 0; i < sc->stripes; i++)\r\nDMEMIT(" %s %llu", sc->stripe[i].dev->name,\r\n(unsigned long long)sc->stripe[i].physical_start);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stripe_end_io(struct dm_target *ti, struct bio *bio,\r\nint error, union map_info *map_context)\r\n{\r\nunsigned i;\r\nchar major_minor[16];\r\nstruct stripe_c *sc = ti->private;\r\nif (!error)\r\nreturn 0;\r\nif ((error == -EWOULDBLOCK) && (bio->bi_rw & REQ_RAHEAD))\r\nreturn error;\r\nif (error == -EOPNOTSUPP)\r\nreturn error;\r\nmemset(major_minor, 0, sizeof(major_minor));\r\nsprintf(major_minor, "%d:%d",\r\nMAJOR(disk_devt(bio->bi_bdev->bd_disk)),\r\nMINOR(disk_devt(bio->bi_bdev->bd_disk)));\r\nfor (i = 0; i < sc->stripes; i++)\r\nif (!strcmp(sc->stripe[i].dev->name, major_minor)) {\r\natomic_inc(&(sc->stripe[i].error_count));\r\nif (atomic_read(&(sc->stripe[i].error_count)) <\r\nDM_IO_ERROR_THRESHOLD)\r\nschedule_work(&sc->trigger_event);\r\n}\r\nreturn error;\r\n}\r\nstatic int stripe_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nint ret = 0;\r\nunsigned i = 0;\r\ndo {\r\nret = fn(ti, sc->stripe[i].dev,\r\nsc->stripe[i].physical_start,\r\nsc->stripe_width, data);\r\n} while (!ret && ++i < sc->stripes);\r\nreturn ret;\r\n}\r\nstatic void stripe_io_hints(struct dm_target *ti,\r\nstruct queue_limits *limits)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nunsigned chunk_size = (sc->chunk_mask + 1) << 9;\r\nblk_limits_io_min(limits, chunk_size);\r\nblk_limits_io_opt(limits, chunk_size * sc->stripes);\r\n}\r\nstatic int stripe_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\r\nstruct bio_vec *biovec, int max_size)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nsector_t bvm_sector = bvm->bi_sector;\r\nuint32_t stripe;\r\nstruct request_queue *q;\r\nstripe_map_sector(sc, bvm_sector, &stripe, &bvm_sector);\r\nq = bdev_get_queue(sc->stripe[stripe].dev->bdev);\r\nif (!q->merge_bvec_fn)\r\nreturn max_size;\r\nbvm->bi_bdev = sc->stripe[stripe].dev->bdev;\r\nbvm->bi_sector = sc->stripe[stripe].physical_start + bvm_sector;\r\nreturn min(max_size, q->merge_bvec_fn(q, bvm, biovec));\r\n}\r\nint __init dm_stripe_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&stripe_target);\r\nif (r < 0) {\r\nDMWARN("target registration failed");\r\nreturn r;\r\n}\r\nreturn r;\r\n}\r\nvoid dm_stripe_exit(void)\r\n{\r\ndm_unregister_target(&stripe_target);\r\n}
