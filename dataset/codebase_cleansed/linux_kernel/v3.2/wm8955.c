static int wm8955_reset(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_write(codec, WM8955_RESET, 0);\r\n}\r\nstatic int wm8995_pll_factors(struct device *dev,\r\nint Fref, int Fout, struct pll_factors *pll)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod, target;\r\ndev_dbg(dev, "Fref=%u Fout=%u\n", Fref, Fout);\r\ntarget = Fout * 4;\r\nif (target < 90000000) {\r\npll->outdiv = 1;\r\ntarget *= 2;\r\n} else {\r\npll->outdiv = 0;\r\n}\r\nWARN_ON(target < 90000000 || target > 100000000);\r\ndev_dbg(dev, "Fvco=%dHz\n", target);\r\nNdiv = target / Fref;\r\npll->n = Ndiv;\r\nNmod = target % Fref;\r\ndev_dbg(dev, "Nmod=%d\n", Nmod);\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, Fref);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\npll->k = K / 10;\r\ndev_dbg(dev, "N=%x K=%x OUTDIV=%x\n", pll->n, pll->k, pll->outdiv);\r\nreturn 0;\r\n}\r\nstatic int wm8955_configure_clocking(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nint i, ret, val;\r\nint clocking = 0;\r\nint srate = 0;\r\nint sr = -1;\r\nstruct pll_factors pll;\r\nif (wm8955->fs == 0)\r\nwm8955->fs = 8000;\r\nfor (i = 0; i < ARRAY_SIZE(clock_cfgs); i++) {\r\nif (wm8955->fs != clock_cfgs[i].fs)\r\ncontinue;\r\nsr = i;\r\nif (wm8955->mclk_rate == clock_cfgs[i].mclk)\r\nbreak;\r\n}\r\nif (sr == -1) {\r\ndev_err(codec->dev, "Sample rate %dHz unsupported\n",\r\nwm8955->fs);\r\nWARN_ON(sr == -1);\r\nreturn -EINVAL;\r\n}\r\nif (i == ARRAY_SIZE(clock_cfgs)) {\r\nclocking |= WM8955_MCLKSEL;\r\nret = wm8995_pll_factors(codec->dev, wm8955->mclk_rate,\r\nclock_cfgs[sr].mclk, &pll);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Unable to generate %dHz from %dHz MCLK\n",\r\nwm8955->fs, wm8955->mclk_rate);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8955_PLL_CONTROL_1,\r\nWM8955_N_MASK | WM8955_K_21_18_MASK,\r\n(pll.n << WM8955_N_SHIFT) |\r\npll.k >> 18);\r\nsnd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,\r\nWM8955_K_17_9_MASK,\r\n(pll.k >> 9) & WM8955_K_17_9_MASK);\r\nsnd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,\r\nWM8955_K_8_0_MASK,\r\npll.k & WM8955_K_8_0_MASK);\r\nif (pll.k)\r\nsnd_soc_update_bits(codec, WM8955_PLL_CONTROL_4,\r\nWM8955_KEN, WM8955_KEN);\r\nelse\r\nsnd_soc_update_bits(codec, WM8955_PLL_CONTROL_4,\r\nWM8955_KEN, 0);\r\nif (pll.outdiv)\r\nval = WM8955_PLL_RB | WM8955_PLLOUTDIV2;\r\nelse\r\nval = WM8955_PLL_RB;\r\nsnd_soc_update_bits(codec, WM8955_CLOCKING_PLL,\r\nWM8955_PLL_RB | WM8955_PLLOUTDIV2, val);\r\nsnd_soc_update_bits(codec, WM8955_CLOCKING_PLL,\r\nWM8955_PLLEN, WM8955_PLLEN);\r\n}\r\nsrate = clock_cfgs[sr].usb | (clock_cfgs[sr].sr << WM8955_SR_SHIFT);\r\nsnd_soc_update_bits(codec, WM8955_SAMPLE_RATE,\r\nWM8955_USB | WM8955_SR_MASK, srate);\r\nsnd_soc_update_bits(codec, WM8955_CLOCKING_PLL,\r\nWM8955_MCLKSEL, clocking);\r\nreturn 0;\r\n}\r\nstatic int wm8955_sysclk(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nint ret = 0;\r\nsnd_soc_update_bits(codec, WM8955_POWER_MANAGEMENT_1,\r\nWM8955_DIGENB, 0);\r\nsnd_soc_update_bits(codec, WM8955_CLOCKING_PLL,\r\nWM8955_PLL_RB | WM8955_PLLEN, 0);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMD:\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nret = wm8955_configure_clocking(codec);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wm8955_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nint val, i, best;\r\nif (wm8955->deemph) {\r\nbest = 1;\r\nfor (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {\r\nif (abs(deemph_settings[i] - wm8955->fs) <\r\nabs(deemph_settings[best] - wm8955->fs))\r\nbest = i;\r\n}\r\nval = best << WM8955_DEEMPH_SHIFT;\r\n} else {\r\nval = 0;\r\n}\r\ndev_dbg(codec->dev, "Set deemphasis %d\n", val);\r\nreturn snd_soc_update_bits(codec, WM8955_DAC_CONTROL,\r\nWM8955_DEEMPH_MASK, val);\r\n}\r\nstatic int wm8955_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8955->deemph;\r\nreturn 0;\r\n}\r\nstatic int wm8955_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nint deemph = ucontrol->value.enumerated.item[0];\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nwm8955->deemph = deemph;\r\nreturn wm8955_set_deemph(codec);\r\n}\r\nstatic int wm8955_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nsnd_soc_add_controls(codec, wm8955_snd_controls,\r\nARRAY_SIZE(wm8955_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8955_dapm_widgets,\r\nARRAY_SIZE(wm8955_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, wm8955_intercon,\r\nARRAY_SIZE(wm8955_intercon));\r\nreturn 0;\r\n}\r\nstatic int wm8955_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nint wl;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nwl = 0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nwl = 0x4;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nwl = 0x8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nwl = 0xc;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8955_AUDIO_INTERFACE,\r\nWM8955_WL_MASK, wl);\r\nwm8955->fs = params_rate(params);\r\nwm8955_set_deemph(codec);\r\nret = snd_soc_read(codec, WM8955_POWER_MANAGEMENT_1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & WM8955_DIGENB) {\r\nsnd_soc_update_bits(codec, WM8955_POWER_MANAGEMENT_1,\r\nWM8955_DIGENB, 0);\r\nsnd_soc_update_bits(codec, WM8955_CLOCKING_PLL,\r\nWM8955_PLL_RB | WM8955_PLLEN, 0);\r\nwm8955_configure_clocking(codec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8955_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8955_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nint div;\r\nswitch (clk_id) {\r\ncase WM8955_CLK_MCLK:\r\nif (freq > 15000000) {\r\npriv->mclk_rate = freq /= 2;\r\ndiv = WM8955_MCLKDIV2;\r\n} else {\r\npriv->mclk_rate = freq;\r\ndiv = 0;\r\n}\r\nsnd_soc_update_bits(codec, WM8955_SAMPLE_RATE,\r\nWM8955_MCLKDIV2, div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "Clock source is %d at %uHz\n", clk_id, freq);\r\nreturn 0;\r\n}\r\nstatic int wm8955_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 aif = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif |= WM8955_MS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif |= WM8955_LRP;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif |= 0x3;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif |= 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif |= 0x1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif |= WM8955_BCLKINV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif |= WM8955_BCLKINV | WM8955_LRP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif |= WM8955_BCLKINV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif |= WM8955_LRP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8955_AUDIO_INTERFACE,\r\nWM8955_MS | WM8955_FORMAT_MASK | WM8955_BCLKINV |\r\nWM8955_LRP, aif);\r\nreturn 0;\r\n}\r\nstatic int wm8955_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint val;\r\nif (mute)\r\nval = WM8955_DACMU;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, WM8955_DAC_CONTROL, WM8955_DACMU, val);\r\nreturn 0;\r\n}\r\nstatic int wm8955_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nu16 *reg_cache = codec->reg_cache;\r\nint ret, i;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8955_POWER_MANAGEMENT_1,\r\nWM8955_VMIDSEL_MASK,\r\n0x1 << WM8955_VMIDSEL_SHIFT);\r\nsnd_soc_update_bits(codec, WM8955_ADDITIONAL_CONTROL_1,\r\nWM8955_VSEL_MASK,\r\n0x2 << WM8955_VSEL_SHIFT);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8955->supplies),\r\nwm8955->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < codec->driver->reg_cache_size; i++) {\r\nif (i == WM8955_RESET)\r\ncontinue;\r\nif (reg_cache[i] == wm8955_reg[i])\r\ncontinue;\r\nsnd_soc_write(codec, i, reg_cache[i]);\r\n}\r\nsnd_soc_update_bits(codec, WM8955_POWER_MANAGEMENT_1,\r\nWM8955_VREF |\r\nWM8955_VMIDSEL_MASK,\r\nWM8955_VREF |\r\n0x3 << WM8955_VREF_SHIFT);\r\nmsleep(500);\r\nsnd_soc_update_bits(codec,\r\nWM8955_ADDITIONAL_CONTROL_3,\r\nWM8955_VROI, WM8955_VROI);\r\n}\r\nsnd_soc_update_bits(codec, WM8955_POWER_MANAGEMENT_1,\r\nWM8955_VMIDSEL_MASK,\r\n0x2 << WM8955_VMIDSEL_SHIFT);\r\nsnd_soc_update_bits(codec, WM8955_ADDITIONAL_CONTROL_1,\r\nWM8955_VSEL_MASK, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec,\r\nWM8955_ADDITIONAL_CONTROL_3,\r\nWM8955_VROI, 0);\r\nsnd_soc_update_bits(codec, WM8955_POWER_MANAGEMENT_1,\r\nWM8955_VREF |\r\nWM8955_VMIDSEL_MASK, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8955->supplies),\r\nwm8955->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8955_suspend(struct snd_soc_codec *codec, pm_message_t state)\r\n{\r\nwm8955_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8955_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8955_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8955_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8955_pdata *pdata = dev_get_platdata(codec->dev);\r\nu16 *reg_cache = codec->reg_cache;\r\nint ret, i;\r\nret = snd_soc_codec_set_cache_io(codec, 7, 9, wm8955->control_type);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8955->supplies); i++)\r\nwm8955->supplies[i].supply = wm8955_supply_names[i];\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(wm8955->supplies),\r\nwm8955->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8955->supplies),\r\nwm8955->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_get;\r\n}\r\nret = wm8955_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nsnd_soc_update_bits(codec, WM8955_LEFT_DAC_VOLUME,\r\nWM8955_LDVU, WM8955_LDVU);\r\nsnd_soc_update_bits(codec, WM8955_RIGHT_DAC_VOLUME,\r\nWM8955_RDVU, WM8955_RDVU);\r\nsnd_soc_update_bits(codec, WM8955_LOUT1_VOLUME,\r\nWM8955_LO1VU | WM8955_LO1ZC,\r\nWM8955_LO1VU | WM8955_LO1ZC);\r\nsnd_soc_update_bits(codec, WM8955_ROUT1_VOLUME,\r\nWM8955_RO1VU | WM8955_RO1ZC,\r\nWM8955_RO1VU | WM8955_RO1ZC);\r\nsnd_soc_update_bits(codec, WM8955_LOUT2_VOLUME,\r\nWM8955_LO2VU | WM8955_LO2ZC,\r\nWM8955_LO2VU | WM8955_LO2ZC);\r\nsnd_soc_update_bits(codec, WM8955_ROUT2_VOLUME,\r\nWM8955_RO2VU | WM8955_RO2ZC,\r\nWM8955_RO2VU | WM8955_RO2ZC);\r\nsnd_soc_update_bits(codec, WM8955_MONOOUT_VOLUME,\r\nWM8955_MOZC, WM8955_MOZC);\r\nsnd_soc_update_bits(codec, WM8955_BASS_CONTROL, WM8955_BB, WM8955_BB);\r\nif (pdata) {\r\nif (pdata->out2_speaker)\r\nreg_cache[WM8955_ADDITIONAL_CONTROL_2]\r\n|= WM8955_ROUT2INV;\r\nif (pdata->monoin_diff)\r\nreg_cache[WM8955_MONO_OUT_MIX_1]\r\n|= WM8955_DMEN;\r\n}\r\nwm8955_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8955->supplies), wm8955->supplies);\r\nwm8955_add_widgets(codec);\r\nreturn 0;\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8955->supplies), wm8955->supplies);\r\nerr_get:\r\nregulator_bulk_free(ARRAY_SIZE(wm8955->supplies), wm8955->supplies);\r\nreturn ret;\r\n}\r\nstatic int wm8955_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);\r\nwm8955_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nregulator_bulk_free(ARRAY_SIZE(wm8955->supplies), wm8955->supplies);\r\nreturn 0;\r\n}\r\nstatic __devinit int wm8955_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8955_priv *wm8955;\r\nint ret;\r\nwm8955 = kzalloc(sizeof(struct wm8955_priv), GFP_KERNEL);\r\nif (wm8955 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8955);\r\nwm8955->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8955, &wm8955_dai, 1);\r\nif (ret < 0)\r\nkfree(wm8955);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm8955_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init wm8955_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&wm8955_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register WM8955 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8955_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&wm8955_i2c_driver);\r\n#endif\r\n}
