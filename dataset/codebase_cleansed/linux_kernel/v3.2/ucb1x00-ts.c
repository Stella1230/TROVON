static inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)\r\n{\r\nstruct input_dev *idev = ts->idev;\r\ninput_report_abs(idev, ABS_X, x);\r\ninput_report_abs(idev, ABS_Y, y);\r\ninput_report_abs(idev, ABS_PRESSURE, pressure);\r\ninput_report_key(idev, BTN_TOUCH, 1);\r\ninput_sync(idev);\r\n}\r\nstatic inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)\r\n{\r\nstruct input_dev *idev = ts->idev;\r\ninput_report_abs(idev, ABS_PRESSURE, 0);\r\ninput_report_key(idev, BTN_TOUCH, 0);\r\ninput_sync(idev);\r\n}\r\nstatic inline void ucb1x00_ts_mode_int(struct ucb1x00_ts *ts)\r\n{\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\r\nUCB_TS_CR_MODE_INT);\r\n}\r\nstatic inline unsigned int ucb1x00_ts_read_pressure(struct ucb1x00_ts *ts)\r\n{\r\nif (machine_is_collie()) {\r\nucb1x00_io_write(ts->ucb, COLLIE_TC35143_GPIO_TBL_CHK, 0);\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSPX_POW | UCB_TS_CR_TSMX_POW |\r\nUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\r\nudelay(55);\r\nreturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_AD2, ts->adcsync);\r\n} else {\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nreturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);\r\n}\r\n}\r\nstatic inline unsigned int ucb1x00_ts_read_xpos(struct ucb1x00_ts *ts)\r\n{\r\nif (machine_is_collie())\r\nucb1x00_io_write(ts->ucb, 0, COLLIE_TC35143_GPIO_TBL_CHK);\r\nelse {\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\n}\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\r\nudelay(55);\r\nreturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);\r\n}\r\nstatic inline unsigned int ucb1x00_ts_read_ypos(struct ucb1x00_ts *ts)\r\n{\r\nif (machine_is_collie())\r\nucb1x00_io_write(ts->ucb, 0, COLLIE_TC35143_GPIO_TBL_CHK);\r\nelse {\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\n}\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\r\nudelay(55);\r\nreturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPX, ts->adcsync);\r\n}\r\nstatic inline unsigned int ucb1x00_ts_read_xres(struct ucb1x00_ts *ts)\r\n{\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nreturn ucb1x00_adc_read(ts->ucb, 0, ts->adcsync);\r\n}\r\nstatic inline unsigned int ucb1x00_ts_read_yres(struct ucb1x00_ts *ts)\r\n{\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nreturn ucb1x00_adc_read(ts->ucb, 0, ts->adcsync);\r\n}\r\nstatic inline int ucb1x00_ts_pen_down(struct ucb1x00_ts *ts)\r\n{\r\nunsigned int val = ucb1x00_reg_read(ts->ucb, UCB_TS_CR);\r\nif (machine_is_collie())\r\nreturn (!(val & (UCB_TS_CR_TSPX_LOW)));\r\nelse\r\nreturn (val & (UCB_TS_CR_TSPX_LOW | UCB_TS_CR_TSMX_LOW));\r\n}\r\nstatic int ucb1x00_thread(void *_ts)\r\n{\r\nstruct ucb1x00_ts *ts = _ts;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint valid = 0;\r\nset_freezable();\r\nadd_wait_queue(&ts->irq_wait, &wait);\r\nwhile (!kthread_should_stop()) {\r\nunsigned int x, y, p;\r\nsigned long timeout;\r\nts->restart = 0;\r\nucb1x00_adc_enable(ts->ucb);\r\nx = ucb1x00_ts_read_xpos(ts);\r\ny = ucb1x00_ts_read_ypos(ts);\r\np = ucb1x00_ts_read_pressure(ts);\r\nucb1x00_ts_mode_int(ts);\r\nucb1x00_adc_disable(ts->ucb);\r\nmsleep(10);\r\nucb1x00_enable(ts->ucb);\r\nif (ucb1x00_ts_pen_down(ts)) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nucb1x00_enable_irq(ts->ucb, UCB_IRQ_TSPX, machine_is_collie() ? UCB_RISING : UCB_FALLING);\r\nucb1x00_disable(ts->ucb);\r\nif (valid) {\r\nucb1x00_ts_event_release(ts);\r\nvalid = 0;\r\n}\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\n} else {\r\nucb1x00_disable(ts->ucb);\r\nif (!ts->restart) {\r\nucb1x00_ts_evt_add(ts, p, x, y);\r\nvalid = 1;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ntimeout = HZ / 100;\r\n}\r\ntry_to_freeze();\r\nschedule_timeout(timeout);\r\n}\r\nremove_wait_queue(&ts->irq_wait, &wait);\r\nts->rtask = NULL;\r\nreturn 0;\r\n}\r\nstatic void ucb1x00_ts_irq(int idx, void *id)\r\n{\r\nstruct ucb1x00_ts *ts = id;\r\nucb1x00_disable_irq(ts->ucb, UCB_IRQ_TSPX, UCB_FALLING);\r\nwake_up(&ts->irq_wait);\r\n}\r\nstatic int ucb1x00_ts_open(struct input_dev *idev)\r\n{\r\nstruct ucb1x00_ts *ts = input_get_drvdata(idev);\r\nint ret = 0;\r\nBUG_ON(ts->rtask);\r\ninit_waitqueue_head(&ts->irq_wait);\r\nret = ucb1x00_hook_irq(ts->ucb, UCB_IRQ_TSPX, ucb1x00_ts_irq, ts);\r\nif (ret < 0)\r\ngoto out;\r\nucb1x00_adc_enable(ts->ucb);\r\nts->x_res = ucb1x00_ts_read_xres(ts);\r\nts->y_res = ucb1x00_ts_read_yres(ts);\r\nucb1x00_adc_disable(ts->ucb);\r\nts->rtask = kthread_run(ucb1x00_thread, ts, "ktsd");\r\nif (!IS_ERR(ts->rtask)) {\r\nret = 0;\r\n} else {\r\nucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);\r\nts->rtask = NULL;\r\nret = -EFAULT;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ucb1x00_ts_close(struct input_dev *idev)\r\n{\r\nstruct ucb1x00_ts *ts = input_get_drvdata(idev);\r\nif (ts->rtask)\r\nkthread_stop(ts->rtask);\r\nucb1x00_enable(ts->ucb);\r\nucb1x00_free_irq(ts->ucb, UCB_IRQ_TSPX, ts);\r\nucb1x00_reg_write(ts->ucb, UCB_TS_CR, 0);\r\nucb1x00_disable(ts->ucb);\r\n}\r\nstatic int ucb1x00_ts_resume(struct ucb1x00_dev *dev)\r\n{\r\nstruct ucb1x00_ts *ts = dev->priv;\r\nif (ts->rtask != NULL) {\r\nts->restart = 1;\r\nwake_up(&ts->irq_wait);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_ts_add(struct ucb1x00_dev *dev)\r\n{\r\nstruct ucb1x00_ts *ts;\r\nstruct input_dev *idev;\r\nint err;\r\nts = kzalloc(sizeof(struct ucb1x00_ts), GFP_KERNEL);\r\nidev = input_allocate_device();\r\nif (!ts || !idev) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nts->ucb = dev->ucb;\r\nts->idev = idev;\r\nts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;\r\nidev->name = "Touchscreen panel";\r\nidev->id.product = ts->ucb->id;\r\nidev->open = ucb1x00_ts_open;\r\nidev->close = ucb1x00_ts_close;\r\nidev->evbit[0] = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);\r\nidev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_drvdata(idev, ts);\r\nucb1x00_adc_enable(ts->ucb);\r\nts->x_res = ucb1x00_ts_read_xres(ts);\r\nts->y_res = ucb1x00_ts_read_yres(ts);\r\nucb1x00_adc_disable(ts->ucb);\r\ninput_set_abs_params(idev, ABS_X, 0, ts->x_res, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y, 0, ts->y_res, 0, 0);\r\ninput_set_abs_params(idev, ABS_PRESSURE, 0, 0, 0, 0);\r\nerr = input_register_device(idev);\r\nif (err)\r\ngoto fail;\r\ndev->priv = ts;\r\nreturn 0;\r\nfail:\r\ninput_free_device(idev);\r\nkfree(ts);\r\nreturn err;\r\n}\r\nstatic void ucb1x00_ts_remove(struct ucb1x00_dev *dev)\r\n{\r\nstruct ucb1x00_ts *ts = dev->priv;\r\ninput_unregister_device(ts->idev);\r\nkfree(ts);\r\n}\r\nstatic int __init ucb1x00_ts_init(void)\r\n{\r\nreturn ucb1x00_register_driver(&ucb1x00_ts_driver);\r\n}\r\nstatic void __exit ucb1x00_ts_exit(void)\r\n{\r\nucb1x00_unregister_driver(&ucb1x00_ts_driver);\r\n}
