static void __devinit cnb20le_res(struct pci_dev *dev)\r\n{\r\nstruct pci_root_info *info;\r\nstruct resource res;\r\nu16 word1, word2;\r\nu8 fbus, lbus;\r\nint i;\r\n#ifdef CONFIG_ACPI\r\nif (acpi_os_get_root_pointer())\r\nreturn;\r\n#endif\r\ninfo = &pci_root_info[pci_root_num];\r\npci_root_num++;\r\npci_read_config_byte(dev, 0x44, &fbus);\r\npci_read_config_byte(dev, 0x45, &lbus);\r\ninfo->bus_min = fbus;\r\ninfo->bus_max = lbus;\r\nif (fbus == 0) {\r\nupdate_res(info, 0x01f0, 0x01f7, IORESOURCE_IO, 0);\r\nupdate_res(info, 0x03f6, 0x03f6, IORESOURCE_IO, 0);\r\nupdate_res(info, 0x0170, 0x0177, IORESOURCE_IO, 0);\r\nupdate_res(info, 0x0376, 0x0376, IORESOURCE_IO, 0);\r\nupdate_res(info, 0xffa0, 0xffaf, IORESOURCE_IO, 0);\r\n}\r\npci_read_config_word(dev, 0xc0, &word1);\r\npci_read_config_word(dev, 0xc2, &word2);\r\nif (word1 != word2) {\r\nres.start = (word1 << 16) | 0x0000;\r\nres.end = (word2 << 16) | 0xffff;\r\nres.flags = IORESOURCE_MEM;\r\nupdate_res(info, res.start, res.end, res.flags, 0);\r\n}\r\npci_read_config_word(dev, 0xc4, &word1);\r\npci_read_config_word(dev, 0xc6, &word2);\r\nif (word1 != word2) {\r\nres.start = (word1 << 16) | 0x0000;\r\nres.end = (word2 << 16) | 0xffff;\r\nres.flags = IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nupdate_res(info, res.start, res.end, res.flags, 0);\r\n}\r\npci_read_config_word(dev, 0xd0, &word1);\r\npci_read_config_word(dev, 0xd2, &word2);\r\nif (word1 != word2) {\r\nres.start = word1;\r\nres.end = word2;\r\nres.flags = IORESOURCE_IO;\r\nupdate_res(info, res.start, res.end, res.flags, 0);\r\n}\r\nres.start = fbus;\r\nres.end = lbus;\r\nres.flags = IORESOURCE_BUS;\r\ndev_info(&dev->dev, "CNB20LE PCI Host Bridge (domain %04x %pR)\n",\r\npci_domain_nr(dev->bus), &res);\r\nfor (i = 0; i < info->res_num; i++)\r\ndev_info(&dev->dev, "host bridge window %pR\n", &info->res[i]);\r\n}
