static inline void OUT(struct etnaviv_cmdbuf *buffer, u32 data)\r\n{\r\nu32 *vaddr = (u32 *)buffer->vaddr;\r\nBUG_ON(buffer->user_size >= buffer->size);\r\nvaddr[buffer->user_size / 4] = data;\r\nbuffer->user_size += 4;\r\n}\r\nstatic inline void CMD_LOAD_STATE(struct etnaviv_cmdbuf *buffer,\r\nu32 reg, u32 value)\r\n{\r\nu32 index = reg >> VIV_FE_LOAD_STATE_HEADER_OFFSET__SHR;\r\nbuffer->user_size = ALIGN(buffer->user_size, 8);\r\nOUT(buffer, VIV_FE_LOAD_STATE_HEADER_OP_LOAD_STATE |\r\nVIV_FE_LOAD_STATE_HEADER_COUNT(1) |\r\nVIV_FE_LOAD_STATE_HEADER_OFFSET(index));\r\nOUT(buffer, value);\r\n}\r\nstatic inline void CMD_END(struct etnaviv_cmdbuf *buffer)\r\n{\r\nbuffer->user_size = ALIGN(buffer->user_size, 8);\r\nOUT(buffer, VIV_FE_END_HEADER_OP_END);\r\n}\r\nstatic inline void CMD_WAIT(struct etnaviv_cmdbuf *buffer)\r\n{\r\nbuffer->user_size = ALIGN(buffer->user_size, 8);\r\nOUT(buffer, VIV_FE_WAIT_HEADER_OP_WAIT | 200);\r\n}\r\nstatic inline void CMD_LINK(struct etnaviv_cmdbuf *buffer,\r\nu16 prefetch, u32 address)\r\n{\r\nbuffer->user_size = ALIGN(buffer->user_size, 8);\r\nOUT(buffer, VIV_FE_LINK_HEADER_OP_LINK |\r\nVIV_FE_LINK_HEADER_PREFETCH(prefetch));\r\nOUT(buffer, address);\r\n}\r\nstatic inline void CMD_STALL(struct etnaviv_cmdbuf *buffer,\r\nu32 from, u32 to)\r\n{\r\nbuffer->user_size = ALIGN(buffer->user_size, 8);\r\nOUT(buffer, VIV_FE_STALL_HEADER_OP_STALL);\r\nOUT(buffer, VIV_FE_STALL_TOKEN_FROM(from) | VIV_FE_STALL_TOKEN_TO(to));\r\n}\r\nstatic inline void CMD_SEM(struct etnaviv_cmdbuf *buffer, u32 from, u32 to)\r\n{\r\nCMD_LOAD_STATE(buffer, VIVS_GL_SEMAPHORE_TOKEN,\r\nVIVS_GL_SEMAPHORE_TOKEN_FROM(from) |\r\nVIVS_GL_SEMAPHORE_TOKEN_TO(to));\r\n}\r\nstatic void etnaviv_cmd_select_pipe(struct etnaviv_gpu *gpu,\r\nstruct etnaviv_cmdbuf *buffer, u8 pipe)\r\n{\r\nu32 flush = 0;\r\nif (gpu->exec_state == ETNA_PIPE_2D)\r\nflush = VIVS_GL_FLUSH_CACHE_PE2D;\r\nelse if (gpu->exec_state == ETNA_PIPE_3D)\r\nflush = VIVS_GL_FLUSH_CACHE_DEPTH | VIVS_GL_FLUSH_CACHE_COLOR;\r\nCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_CACHE, flush);\r\nCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\r\nCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\r\nCMD_LOAD_STATE(buffer, VIVS_GL_PIPE_SELECT,\r\nVIVS_GL_PIPE_SELECT_PIPE(pipe));\r\n}\r\nstatic u32 gpu_va(struct etnaviv_gpu *gpu, struct etnaviv_cmdbuf *buf)\r\n{\r\nreturn buf->paddr - gpu->memory_base;\r\n}\r\nstatic void etnaviv_buffer_dump(struct etnaviv_gpu *gpu,\r\nstruct etnaviv_cmdbuf *buf, u32 off, u32 len)\r\n{\r\nu32 size = buf->size;\r\nu32 *ptr = buf->vaddr + off;\r\ndev_info(gpu->dev, "virt %p phys 0x%08x free 0x%08x\n",\r\nptr, gpu_va(gpu, buf) + off, size - len * 4 - off);\r\nprint_hex_dump(KERN_INFO, "cmd ", DUMP_PREFIX_OFFSET, 16, 4,\r\nptr, len * 4, 0);\r\n}\r\nstatic void etnaviv_buffer_replace_wait(struct etnaviv_cmdbuf *buffer,\r\nunsigned int wl_offset, u32 cmd, u32 arg)\r\n{\r\nu32 *lw = buffer->vaddr + wl_offset;\r\nlw[1] = arg;\r\nmb();\r\nlw[0] = cmd;\r\nmb();\r\n}\r\nstatic u32 etnaviv_buffer_reserve(struct etnaviv_gpu *gpu,\r\nstruct etnaviv_cmdbuf *buffer, unsigned int cmd_dwords)\r\n{\r\nif (buffer->user_size + cmd_dwords * sizeof(u64) > buffer->size)\r\nbuffer->user_size = 0;\r\nreturn gpu_va(gpu, buffer) + buffer->user_size;\r\n}\r\nu16 etnaviv_buffer_init(struct etnaviv_gpu *gpu)\r\n{\r\nstruct etnaviv_cmdbuf *buffer = gpu->buffer;\r\nbuffer->user_size = 0;\r\nCMD_WAIT(buffer);\r\nCMD_LINK(buffer, 2, gpu_va(gpu, buffer) + buffer->user_size - 4);\r\nreturn buffer->user_size / 8;\r\n}\r\nvoid etnaviv_buffer_end(struct etnaviv_gpu *gpu)\r\n{\r\nstruct etnaviv_cmdbuf *buffer = gpu->buffer;\r\nunsigned int waitlink_offset = buffer->user_size - 16;\r\nu32 link_target, flush = 0;\r\nif (gpu->exec_state == ETNA_PIPE_2D)\r\nflush = VIVS_GL_FLUSH_CACHE_PE2D;\r\nelse if (gpu->exec_state == ETNA_PIPE_3D)\r\nflush = VIVS_GL_FLUSH_CACHE_DEPTH |\r\nVIVS_GL_FLUSH_CACHE_COLOR |\r\nVIVS_GL_FLUSH_CACHE_TEXTURE |\r\nVIVS_GL_FLUSH_CACHE_TEXTUREVS |\r\nVIVS_GL_FLUSH_CACHE_SHADER_L2;\r\nif (flush) {\r\nunsigned int dwords = 7;\r\nlink_target = etnaviv_buffer_reserve(gpu, buffer, dwords);\r\nCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\r\nCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\r\nCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_CACHE, flush);\r\nif (gpu->exec_state == ETNA_PIPE_3D)\r\nCMD_LOAD_STATE(buffer, VIVS_TS_FLUSH_CACHE,\r\nVIVS_TS_FLUSH_CACHE_FLUSH);\r\nCMD_SEM(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\r\nCMD_STALL(buffer, SYNC_RECIPIENT_FE, SYNC_RECIPIENT_PE);\r\nCMD_END(buffer);\r\netnaviv_buffer_replace_wait(buffer, waitlink_offset,\r\nVIV_FE_LINK_HEADER_OP_LINK |\r\nVIV_FE_LINK_HEADER_PREFETCH(dwords),\r\nlink_target);\r\n} else {\r\netnaviv_buffer_replace_wait(buffer, waitlink_offset,\r\nVIV_FE_END_HEADER_OP_END, 0);\r\n}\r\n}\r\nvoid etnaviv_buffer_queue(struct etnaviv_gpu *gpu, unsigned int event,\r\nstruct etnaviv_cmdbuf *cmdbuf)\r\n{\r\nstruct etnaviv_cmdbuf *buffer = gpu->buffer;\r\nunsigned int waitlink_offset = buffer->user_size - 16;\r\nu32 return_target, return_dwords;\r\nu32 link_target, link_dwords;\r\nif (drm_debug & DRM_UT_DRIVER)\r\netnaviv_buffer_dump(gpu, buffer, 0, 0x50);\r\nlink_target = gpu_va(gpu, cmdbuf);\r\nlink_dwords = cmdbuf->size / 8;\r\nif (gpu->mmu->need_flush || gpu->switch_context) {\r\nu32 target, extra_dwords;\r\nextra_dwords = 1;\r\nif (gpu->mmu->need_flush)\r\nextra_dwords += 1;\r\nif (gpu->switch_context)\r\nextra_dwords += 4;\r\ntarget = etnaviv_buffer_reserve(gpu, buffer, extra_dwords);\r\nif (gpu->mmu->need_flush) {\r\nCMD_LOAD_STATE(buffer, VIVS_GL_FLUSH_MMU,\r\nVIVS_GL_FLUSH_MMU_FLUSH_FEMMU |\r\nVIVS_GL_FLUSH_MMU_FLUSH_UNK1 |\r\nVIVS_GL_FLUSH_MMU_FLUSH_UNK2 |\r\nVIVS_GL_FLUSH_MMU_FLUSH_PEMMU |\r\nVIVS_GL_FLUSH_MMU_FLUSH_UNK4);\r\ngpu->mmu->need_flush = false;\r\n}\r\nif (gpu->switch_context) {\r\netnaviv_cmd_select_pipe(gpu, buffer, cmdbuf->exec_state);\r\ngpu->exec_state = cmdbuf->exec_state;\r\ngpu->switch_context = false;\r\n}\r\nCMD_LINK(buffer, link_dwords, link_target);\r\nlink_target = target;\r\nlink_dwords = extra_dwords;\r\n}\r\nreturn_dwords = 3;\r\nreturn_target = etnaviv_buffer_reserve(gpu, buffer, return_dwords);\r\nCMD_LINK(cmdbuf, return_dwords, return_target);\r\nCMD_LOAD_STATE(buffer, VIVS_GL_EVENT, VIVS_GL_EVENT_EVENT_ID(event) |\r\nVIVS_GL_EVENT_FROM_PE);\r\nCMD_WAIT(buffer);\r\nCMD_LINK(buffer, 2, return_target + 8);\r\nif (drm_debug & DRM_UT_DRIVER)\r\npr_info("stream link to 0x%08x @ 0x%08x %p\n",\r\nreturn_target, gpu_va(gpu, cmdbuf), cmdbuf->vaddr);\r\nif (drm_debug & DRM_UT_DRIVER) {\r\nprint_hex_dump(KERN_INFO, "cmd ", DUMP_PREFIX_OFFSET, 16, 4,\r\ncmdbuf->vaddr, cmdbuf->size, 0);\r\npr_info("link op: %p\n", buffer->vaddr + waitlink_offset);\r\npr_info("addr: 0x%08x\n", link_target);\r\npr_info("back: 0x%08x\n", return_target);\r\npr_info("event: %d\n", event);\r\n}\r\netnaviv_buffer_replace_wait(buffer, waitlink_offset,\r\nVIV_FE_LINK_HEADER_OP_LINK |\r\nVIV_FE_LINK_HEADER_PREFETCH(link_dwords),\r\nlink_target);\r\nif (drm_debug & DRM_UT_DRIVER)\r\netnaviv_buffer_dump(gpu, buffer, 0, 0x50);\r\n}
