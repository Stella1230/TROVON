__s32 fsid_of_op(struct orangefs_kernel_op_s *op)\r\n{\r\n__s32 fsid = ORANGEFS_FS_ID_NULL;\r\nif (op) {\r\nswitch (op->upcall.type) {\r\ncase ORANGEFS_VFS_OP_FILE_IO:\r\nfsid = op->upcall.req.io.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_LOOKUP:\r\nfsid = op->upcall.req.lookup.parent_refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_CREATE:\r\nfsid = op->upcall.req.create.parent_refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_GETATTR:\r\nfsid = op->upcall.req.getattr.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_REMOVE:\r\nfsid = op->upcall.req.remove.parent_refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_MKDIR:\r\nfsid = op->upcall.req.mkdir.parent_refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_READDIR:\r\nfsid = op->upcall.req.readdir.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_SETATTR:\r\nfsid = op->upcall.req.setattr.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_SYMLINK:\r\nfsid = op->upcall.req.sym.parent_refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_RENAME:\r\nfsid = op->upcall.req.rename.old_parent_refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_STATFS:\r\nfsid = op->upcall.req.statfs.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_TRUNCATE:\r\nfsid = op->upcall.req.truncate.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_MMAP_RA_FLUSH:\r\nfsid = op->upcall.req.ra_cache_flush.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_FS_UMOUNT:\r\nfsid = op->upcall.req.fs_umount.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_GETXATTR:\r\nfsid = op->upcall.req.getxattr.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_SETXATTR:\r\nfsid = op->upcall.req.setxattr.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_LISTXATTR:\r\nfsid = op->upcall.req.listxattr.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_REMOVEXATTR:\r\nfsid = op->upcall.req.removexattr.refn.fs_id;\r\nbreak;\r\ncase ORANGEFS_VFS_OP_FSYNC:\r\nfsid = op->upcall.req.fsync.refn.fs_id;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn fsid;\r\n}\r\nstatic int orangefs_inode_flags(struct ORANGEFS_sys_attr_s *attrs)\r\n{\r\nint flags = 0;\r\nif (attrs->flags & ORANGEFS_IMMUTABLE_FL)\r\nflags |= S_IMMUTABLE;\r\nelse\r\nflags &= ~S_IMMUTABLE;\r\nif (attrs->flags & ORANGEFS_APPEND_FL)\r\nflags |= S_APPEND;\r\nelse\r\nflags &= ~S_APPEND;\r\nif (attrs->flags & ORANGEFS_NOATIME_FL)\r\nflags |= S_NOATIME;\r\nelse\r\nflags &= ~S_NOATIME;\r\nreturn flags;\r\n}\r\nstatic int orangefs_inode_perms(struct ORANGEFS_sys_attr_s *attrs)\r\n{\r\nint perm_mode = 0;\r\nif (attrs->perms & ORANGEFS_O_EXECUTE)\r\nperm_mode |= S_IXOTH;\r\nif (attrs->perms & ORANGEFS_O_WRITE)\r\nperm_mode |= S_IWOTH;\r\nif (attrs->perms & ORANGEFS_O_READ)\r\nperm_mode |= S_IROTH;\r\nif (attrs->perms & ORANGEFS_G_EXECUTE)\r\nperm_mode |= S_IXGRP;\r\nif (attrs->perms & ORANGEFS_G_WRITE)\r\nperm_mode |= S_IWGRP;\r\nif (attrs->perms & ORANGEFS_G_READ)\r\nperm_mode |= S_IRGRP;\r\nif (attrs->perms & ORANGEFS_U_EXECUTE)\r\nperm_mode |= S_IXUSR;\r\nif (attrs->perms & ORANGEFS_U_WRITE)\r\nperm_mode |= S_IWUSR;\r\nif (attrs->perms & ORANGEFS_U_READ)\r\nperm_mode |= S_IRUSR;\r\nif (attrs->perms & ORANGEFS_G_SGID)\r\nperm_mode |= S_ISGID;\r\nif (attrs->perms & ORANGEFS_U_SUID)\r\nperm_mode |= S_ISUID;\r\nreturn perm_mode;\r\n}\r\nstatic inline int copy_attributes_from_inode(struct inode *inode,\r\nstruct ORANGEFS_sys_attr_s *attrs,\r\nstruct iattr *iattr)\r\n{\r\numode_t tmp_mode;\r\nif (!iattr || !inode || !attrs) {\r\ngossip_err("NULL iattr (%p), inode (%p), attrs (%p) "\r\n"in copy_attributes_from_inode!\n",\r\niattr,\r\ninode,\r\nattrs);\r\nreturn -EINVAL;\r\n}\r\nattrs->mask = 0;\r\nif (iattr->ia_valid & ATTR_UID) {\r\nattrs->owner = from_kuid(current_user_ns(), iattr->ia_uid);\r\nattrs->mask |= ORANGEFS_ATTR_SYS_UID;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "(UID) %d\n", attrs->owner);\r\n}\r\nif (iattr->ia_valid & ATTR_GID) {\r\nattrs->group = from_kgid(current_user_ns(), iattr->ia_gid);\r\nattrs->mask |= ORANGEFS_ATTR_SYS_GID;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "(GID) %d\n", attrs->group);\r\n}\r\nif (iattr->ia_valid & ATTR_ATIME) {\r\nattrs->mask |= ORANGEFS_ATTR_SYS_ATIME;\r\nif (iattr->ia_valid & ATTR_ATIME_SET) {\r\nattrs->atime = (time64_t)iattr->ia_atime.tv_sec;\r\nattrs->mask |= ORANGEFS_ATTR_SYS_ATIME_SET;\r\n}\r\n}\r\nif (iattr->ia_valid & ATTR_MTIME) {\r\nattrs->mask |= ORANGEFS_ATTR_SYS_MTIME;\r\nif (iattr->ia_valid & ATTR_MTIME_SET) {\r\nattrs->mtime = (time64_t)iattr->ia_mtime.tv_sec;\r\nattrs->mask |= ORANGEFS_ATTR_SYS_MTIME_SET;\r\n}\r\n}\r\nif (iattr->ia_valid & ATTR_CTIME)\r\nattrs->mask |= ORANGEFS_ATTR_SYS_CTIME;\r\nif (iattr->ia_valid & ATTR_MODE) {\r\ntmp_mode = iattr->ia_mode;\r\nif (tmp_mode & (S_ISVTX)) {\r\nif (is_root_handle(inode)) {\r\ntmp_mode -= S_ISVTX;\r\n} else {\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"User attempted to set sticky bit on non-root directory; returning EINVAL.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (tmp_mode & (S_ISUID)) {\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"Attempting to set setuid bit (not supported); returning EINVAL.\n");\r\nreturn -EINVAL;\r\n}\r\nattrs->perms = ORANGEFS_util_translate_mode(tmp_mode);\r\nattrs->mask |= ORANGEFS_ATTR_SYS_PERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int orangefs_inode_type(enum orangefs_ds_type objtype)\r\n{\r\nif (objtype == ORANGEFS_TYPE_METAFILE)\r\nreturn S_IFREG;\r\nelse if (objtype == ORANGEFS_TYPE_DIRECTORY)\r\nreturn S_IFDIR;\r\nelse if (objtype == ORANGEFS_TYPE_SYMLINK)\r\nreturn S_IFLNK;\r\nelse\r\nreturn -1;\r\n}\r\nstatic int orangefs_inode_is_stale(struct inode *inode, int new,\r\nstruct ORANGEFS_sys_attr_s *attrs, char *link_target)\r\n{\r\nstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\r\nint type = orangefs_inode_type(attrs->objtype);\r\nif (!new) {\r\nif (type == -1 || !(inode->i_mode & type)) {\r\norangefs_make_bad_inode(inode);\r\nreturn 1;\r\n}\r\nif (type == S_IFLNK && strncmp(orangefs_inode->link_target,\r\nlink_target, ORANGEFS_NAME_MAX)) {\r\norangefs_make_bad_inode(inode);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint orangefs_inode_getattr(struct inode *inode, int new, int size)\r\n{\r\nstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\r\nstruct orangefs_kernel_op_s *new_op;\r\nloff_t inode_size, rounded_up_size;\r\nint ret, type;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,\r\nget_khandle_from_ino(inode));\r\nnew_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);\r\nif (!new_op)\r\nreturn -ENOMEM;\r\nnew_op->upcall.req.getattr.refn = orangefs_inode->refn;\r\nnew_op->upcall.req.getattr.mask = size ?\r\nORANGEFS_ATTR_SYS_ALL_NOHINT : ORANGEFS_ATTR_SYS_ALL_NOHINT_NOSIZE;\r\nret = service_operation(new_op, __func__,\r\nget_interruptible_flag(inode));\r\nif (ret != 0)\r\ngoto out;\r\ntype = orangefs_inode_type(new_op->\r\ndowncall.resp.getattr.attributes.objtype);\r\nret = orangefs_inode_is_stale(inode, new,\r\n&new_op->downcall.resp.getattr.attributes,\r\nnew_op->downcall.resp.getattr.link_target);\r\nif (ret) {\r\nret = -ESTALE;\r\ngoto out;\r\n}\r\nswitch (type) {\r\ncase S_IFREG:\r\ninode->i_flags = orangefs_inode_flags(&new_op->\r\ndowncall.resp.getattr.attributes);\r\nif (size) {\r\ninode_size = (loff_t)new_op->\r\ndowncall.resp.getattr.attributes.size;\r\nrounded_up_size =\r\n(inode_size + (4096 - (inode_size % 4096)));\r\ninode->i_size = inode_size;\r\norangefs_inode->blksize =\r\nnew_op->downcall.resp.getattr.attributes.blksize;\r\nspin_lock(&inode->i_lock);\r\ninode->i_bytes = inode_size;\r\ninode->i_blocks =\r\n(unsigned long)(rounded_up_size / 512);\r\nspin_unlock(&inode->i_lock);\r\n}\r\nbreak;\r\ncase S_IFDIR:\r\ninode->i_size = PAGE_SIZE;\r\norangefs_inode->blksize = (1 << inode->i_blkbits);\r\nspin_lock(&inode->i_lock);\r\ninode_set_bytes(inode, inode->i_size);\r\nspin_unlock(&inode->i_lock);\r\nset_nlink(inode, 1);\r\nbreak;\r\ncase S_IFLNK:\r\nif (new) {\r\ninode->i_size = (loff_t)strlen(new_op->\r\ndowncall.resp.getattr.link_target);\r\norangefs_inode->blksize = (1 << inode->i_blkbits);\r\nret = strscpy(orangefs_inode->link_target,\r\nnew_op->downcall.resp.getattr.link_target,\r\nORANGEFS_NAME_MAX);\r\nif (ret == -E2BIG) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\ninode->i_link = orangefs_inode->link_target;\r\n}\r\nbreak;\r\n}\r\ninode->i_uid = make_kuid(&init_user_ns, new_op->\r\ndowncall.resp.getattr.attributes.owner);\r\ninode->i_gid = make_kgid(&init_user_ns, new_op->\r\ndowncall.resp.getattr.attributes.group);\r\ninode->i_atime.tv_sec = (time64_t)new_op->\r\ndowncall.resp.getattr.attributes.atime;\r\ninode->i_mtime.tv_sec = (time64_t)new_op->\r\ndowncall.resp.getattr.attributes.mtime;\r\ninode->i_ctime.tv_sec = (time64_t)new_op->\r\ndowncall.resp.getattr.attributes.ctime;\r\ninode->i_atime.tv_nsec = 0;\r\ninode->i_mtime.tv_nsec = 0;\r\ninode->i_ctime.tv_nsec = 0;\r\ninode->i_mode = type | (is_root_handle(inode) ? S_ISVTX : 0) |\r\norangefs_inode_perms(&new_op->downcall.resp.getattr.attributes);\r\nret = 0;\r\nout:\r\nop_release(new_op);\r\nreturn ret;\r\n}\r\nint orangefs_inode_check_changed(struct inode *inode)\r\n{\r\nstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\r\nstruct orangefs_kernel_op_s *new_op;\r\nint ret;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: called on inode %pU\n", __func__,\r\nget_khandle_from_ino(inode));\r\nnew_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);\r\nif (!new_op)\r\nreturn -ENOMEM;\r\nnew_op->upcall.req.getattr.refn = orangefs_inode->refn;\r\nnew_op->upcall.req.getattr.mask = ORANGEFS_ATTR_SYS_TYPE |\r\nORANGEFS_ATTR_SYS_LNK_TARGET;\r\nret = service_operation(new_op, __func__,\r\nget_interruptible_flag(inode));\r\nif (ret != 0)\r\ngoto out;\r\nret = orangefs_inode_is_stale(inode, 0,\r\n&new_op->downcall.resp.getattr.attributes,\r\nnew_op->downcall.resp.getattr.link_target);\r\nout:\r\nop_release(new_op);\r\nreturn ret;\r\n}\r\nint orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)\r\n{\r\nstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\r\nstruct orangefs_kernel_op_s *new_op;\r\nint ret;\r\nnew_op = op_alloc(ORANGEFS_VFS_OP_SETATTR);\r\nif (!new_op)\r\nreturn -ENOMEM;\r\nnew_op->upcall.req.setattr.refn = orangefs_inode->refn;\r\nret = copy_attributes_from_inode(inode,\r\n&new_op->upcall.req.setattr.attributes,\r\niattr);\r\nif (ret >= 0) {\r\nret = service_operation(new_op, __func__,\r\nget_interruptible_flag(inode));\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"orangefs_inode_setattr: returning %d\n",\r\nret);\r\n}\r\nop_release(new_op);\r\nif (ret == 0) {\r\nClearAtimeFlag(orangefs_inode);\r\nClearMtimeFlag(orangefs_inode);\r\nClearCtimeFlag(orangefs_inode);\r\nClearModeFlag(orangefs_inode);\r\n}\r\nreturn ret;\r\n}\r\nint orangefs_flush_inode(struct inode *inode)\r\n{\r\nstruct iattr wbattr;\r\nint ret;\r\nint mtime_flag;\r\nint ctime_flag;\r\nint atime_flag;\r\nint mode_flag;\r\nstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\r\nmemset(&wbattr, 0, sizeof(wbattr));\r\nmtime_flag = MtimeFlag(orangefs_inode);\r\nClearMtimeFlag(orangefs_inode);\r\nctime_flag = CtimeFlag(orangefs_inode);\r\nClearCtimeFlag(orangefs_inode);\r\natime_flag = AtimeFlag(orangefs_inode);\r\nClearAtimeFlag(orangefs_inode);\r\nmode_flag = ModeFlag(orangefs_inode);\r\nClearModeFlag(orangefs_inode);\r\nif (mtime_flag)\r\nwbattr.ia_valid |= ATTR_MTIME;\r\nif (ctime_flag)\r\nwbattr.ia_valid |= ATTR_CTIME;\r\nif (atime_flag)\r\nwbattr.ia_valid |= ATTR_ATIME;\r\nif (mode_flag) {\r\nwbattr.ia_mode = inode->i_mode;\r\nwbattr.ia_valid |= ATTR_MODE;\r\n}\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"*********** orangefs_flush_inode: %pU "\r\n"(ia_valid %d)\n",\r\nget_khandle_from_ino(inode),\r\nwbattr.ia_valid);\r\nif (wbattr.ia_valid == 0) {\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"orangefs_flush_inode skipping setattr()\n");\r\nreturn 0;\r\n}\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"orangefs_flush_inode (%pU) writing mode %o\n",\r\nget_khandle_from_ino(inode),\r\ninode->i_mode);\r\nret = orangefs_inode_setattr(inode, &wbattr);\r\nreturn ret;\r\n}\r\nint orangefs_unmount_sb(struct super_block *sb)\r\n{\r\nint ret = -EINVAL;\r\nstruct orangefs_kernel_op_s *new_op = NULL;\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"orangefs_unmount_sb called on sb %p\n",\r\nsb);\r\nnew_op = op_alloc(ORANGEFS_VFS_OP_FS_UMOUNT);\r\nif (!new_op)\r\nreturn -ENOMEM;\r\nnew_op->upcall.req.fs_umount.id = ORANGEFS_SB(sb)->id;\r\nnew_op->upcall.req.fs_umount.fs_id = ORANGEFS_SB(sb)->fs_id;\r\nstrncpy(new_op->upcall.req.fs_umount.orangefs_config_server,\r\nORANGEFS_SB(sb)->devname,\r\nORANGEFS_MAX_SERVER_ADDR_LEN);\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"Attempting ORANGEFS Unmount via host %s\n",\r\nnew_op->upcall.req.fs_umount.orangefs_config_server);\r\nret = service_operation(new_op, "orangefs_fs_umount", 0);\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"orangefs_unmount: got return value of %d\n", ret);\r\nif (ret)\r\nsb = ERR_PTR(ret);\r\nelse\r\nORANGEFS_SB(sb)->mount_pending = 1;\r\nop_release(new_op);\r\nreturn ret;\r\n}\r\nvoid orangefs_make_bad_inode(struct inode *inode)\r\n{\r\nif (is_root_handle(inode)) {\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"*** NOT making bad root inode %pU\n",\r\nget_khandle_from_ino(inode));\r\n} else {\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"*** making bad inode %pU\n",\r\nget_khandle_from_ino(inode));\r\nmake_bad_inode(inode);\r\n}\r\n}\r\nint orangefs_normalize_to_errno(__s32 error_code)\r\n{\r\n__u32 i;\r\nif (error_code == 0) {\r\nreturn 0;\r\n} else if (error_code > 0) {\r\ngossip_err("orangefs: error status receieved.\n");\r\ngossip_err("orangefs: assuming error code is inverted.\n");\r\nerror_code = -error_code;\r\n}\r\nif ((-error_code) & ORANGEFS_NON_ERRNO_ERROR_BIT) {\r\nif (((-error_code) &\r\n(ORANGEFS_ERROR_NUMBER_BITS|ORANGEFS_NON_ERRNO_ERROR_BIT|\r\nORANGEFS_ERROR_BIT)) == ORANGEFS_ECANCEL) {\r\nerror_code = -ETIMEDOUT;\r\n} else {\r\ngossip_err("orangefs: warning: got error code without errno equivalent: %d.\n", error_code);\r\nerror_code = -EINVAL;\r\n}\r\n} else if ((-error_code) & ORANGEFS_ERROR_BIT) {\r\ni = (-error_code) & ~(ORANGEFS_ERROR_BIT|ORANGEFS_ERROR_CLASS_BITS);\r\nif (i < sizeof(PINT_errno_mapping)/sizeof(*PINT_errno_mapping))\r\nerror_code = -PINT_errno_mapping[i];\r\nelse\r\nerror_code = -EINVAL;\r\n} else {\r\ngossip_err("orangefs: orangefs_normalize_to_errno: got error code which is not from ORANGEFS.\n");\r\n}\r\nreturn error_code;\r\n}\r\n__s32 ORANGEFS_util_translate_mode(int mode)\r\n{\r\nint ret = 0;\r\nint i = 0;\r\nstatic int modes[NUM_MODES] = {\r\nS_IXOTH, S_IWOTH, S_IROTH,\r\nS_IXGRP, S_IWGRP, S_IRGRP,\r\nS_IXUSR, S_IWUSR, S_IRUSR,\r\nS_ISGID, S_ISUID\r\n};\r\nstatic int orangefs_modes[NUM_MODES] = {\r\nORANGEFS_O_EXECUTE, ORANGEFS_O_WRITE, ORANGEFS_O_READ,\r\nORANGEFS_G_EXECUTE, ORANGEFS_G_WRITE, ORANGEFS_G_READ,\r\nORANGEFS_U_EXECUTE, ORANGEFS_U_WRITE, ORANGEFS_U_READ,\r\nORANGEFS_G_SGID, ORANGEFS_U_SUID\r\n};\r\nfor (i = 0; i < NUM_MODES; i++)\r\nif (mode & modes[i])\r\nret |= orangefs_modes[i];\r\nreturn ret;\r\n}\r\nint orangefs_prepare_cdm_array(char *debug_array_string)\r\n{\r\nint i;\r\nint rc = -EINVAL;\r\nchar *cds_head = NULL;\r\nchar *cds_delimiter = NULL;\r\nint keyword_len = 0;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);\r\nfor (i = 0; i < strlen(debug_array_string); i++)\r\nif (debug_array_string[i] == '\n')\r\ncdm_element_count++;\r\nif (!cdm_element_count) {\r\npr_info("No elements in client debug array string!\n");\r\ngoto out;\r\n}\r\ncdm_array =\r\nkzalloc(cdm_element_count * sizeof(struct client_debug_mask),\r\nGFP_KERNEL);\r\nif (!cdm_array) {\r\npr_info("malloc failed for cdm_array!\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ncds_head = debug_array_string;\r\nfor (i = 0; i < cdm_element_count; i++) {\r\ncds_delimiter = strchr(cds_head, '\n');\r\n*cds_delimiter = '\0';\r\nkeyword_len = strcspn(cds_head, " ");\r\ncdm_array[i].keyword = kzalloc(keyword_len + 1, GFP_KERNEL);\r\nif (!cdm_array[i].keyword) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nsscanf(cds_head,\r\n"%s %llx %llx",\r\ncdm_array[i].keyword,\r\n(unsigned long long *)&(cdm_array[i].mask1),\r\n(unsigned long long *)&(cdm_array[i].mask2));\r\nif (!strcmp(cdm_array[i].keyword, ORANGEFS_VERBOSE))\r\nclient_verbose_index = i;\r\nif (!strcmp(cdm_array[i].keyword, ORANGEFS_ALL))\r\nclient_all_index = i;\r\ncds_head = cds_delimiter + 1;\r\n}\r\nrc = cdm_element_count;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: rc:%d:\n", __func__, rc);\r\nout:\r\nreturn rc;\r\n}\r\nint orangefs_prepare_debugfs_help_string(int at_boot)\r\n{\r\nint rc = -EINVAL;\r\nint i;\r\nint byte_count = 0;\r\nchar *client_title = "Client Debug Keywords:\n";\r\nchar *kernel_title = "Kernel Debug Keywords:\n";\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);\r\nif (at_boot) {\r\nbyte_count += strlen(HELP_STRING_UNINITIALIZED);\r\nclient_title = HELP_STRING_UNINITIALIZED;\r\n} else {\r\ncdm_element_count =\r\norangefs_prepare_cdm_array(client_debug_array_string);\r\nif (cdm_element_count <= 0)\r\ngoto out;\r\nbyte_count += strlen(client_title);\r\nfor (i = 0; i < cdm_element_count; i++) {\r\nbyte_count += strlen(cdm_array[i].keyword + 2);\r\nif (byte_count >= DEBUG_HELP_STRING_SIZE) {\r\npr_info("%s: overflow 1!\n", __func__);\r\ngoto out;\r\n}\r\n}\r\ngossip_debug(GOSSIP_UTILS_DEBUG,\r\n"%s: cdm_element_count:%d:\n",\r\n__func__,\r\ncdm_element_count);\r\n}\r\nbyte_count += strlen(kernel_title);\r\nfor (i = 0; i < num_kmod_keyword_mask_map; i++) {\r\nbyte_count +=\r\nstrlen(s_kmod_keyword_mask_map[i].keyword + 2);\r\nif (byte_count >= DEBUG_HELP_STRING_SIZE) {\r\npr_info("%s: overflow 2!\n", __func__);\r\ngoto out;\r\n}\r\n}\r\ndebug_help_string = kzalloc(DEBUG_HELP_STRING_SIZE, GFP_KERNEL);\r\nif (!debug_help_string) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nstrcat(debug_help_string, client_title);\r\nif (!at_boot) {\r\nfor (i = 0; i < cdm_element_count; i++) {\r\nstrcat(debug_help_string, "\t");\r\nstrcat(debug_help_string, cdm_array[i].keyword);\r\nstrcat(debug_help_string, "\n");\r\n}\r\n}\r\nstrcat(debug_help_string, "\n");\r\nstrcat(debug_help_string, kernel_title);\r\nfor (i = 0; i < num_kmod_keyword_mask_map; i++) {\r\nstrcat(debug_help_string, "\t");\r\nstrcat(debug_help_string, s_kmod_keyword_mask_map[i].keyword);\r\nstrcat(debug_help_string, "\n");\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nvoid debug_mask_to_string(void *mask, int type)\r\n{\r\nint i;\r\nint len = 0;\r\nchar *debug_string;\r\nint element_count = 0;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);\r\nif (type) {\r\ndebug_string = client_debug_string;\r\nelement_count = cdm_element_count;\r\n} else {\r\ndebug_string = kernel_debug_string;\r\nelement_count = num_kmod_keyword_mask_map;\r\n}\r\nmemset(debug_string, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);\r\nif (check_amalgam_keyword(mask, type))\r\ngoto out;\r\nfor (i = 0; i < element_count; i++)\r\nif (type)\r\ndo_c_string(mask, i);\r\nelse\r\ndo_k_string(mask, i);\r\nlen = strlen(debug_string);\r\nif ((len) && (type))\r\nclient_debug_string[len - 1] = '\0';\r\nelse if (len)\r\nkernel_debug_string[len - 1] = '\0';\r\nelse if (type)\r\nstrcpy(client_debug_string, "none");\r\nelse\r\nstrcpy(kernel_debug_string, "none");\r\nout:\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: string:%s:\n", __func__, debug_string);\r\nreturn;\r\n}\r\nvoid do_k_string(void *k_mask, int index)\r\n{\r\n__u64 *mask = (__u64 *) k_mask;\r\nif (keyword_is_amalgam((char *) s_kmod_keyword_mask_map[index].keyword))\r\ngoto out;\r\nif (*mask & s_kmod_keyword_mask_map[index].mask_val) {\r\nif ((strlen(kernel_debug_string) +\r\nstrlen(s_kmod_keyword_mask_map[index].keyword))\r\n< ORANGEFS_MAX_DEBUG_STRING_LEN - 1) {\r\nstrcat(kernel_debug_string,\r\ns_kmod_keyword_mask_map[index].keyword);\r\nstrcat(kernel_debug_string, ",");\r\n} else {\r\ngossip_err("%s: overflow!\n", __func__);\r\nstrcpy(kernel_debug_string, ORANGEFS_ALL);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn;\r\n}\r\nvoid do_c_string(void *c_mask, int index)\r\n{\r\nstruct client_debug_mask *mask = (struct client_debug_mask *) c_mask;\r\nif (keyword_is_amalgam(cdm_array[index].keyword))\r\ngoto out;\r\nif ((mask->mask1 & cdm_array[index].mask1) ||\r\n(mask->mask2 & cdm_array[index].mask2)) {\r\nif ((strlen(client_debug_string) +\r\nstrlen(cdm_array[index].keyword) + 1)\r\n< ORANGEFS_MAX_DEBUG_STRING_LEN - 2) {\r\nstrcat(client_debug_string,\r\ncdm_array[index].keyword);\r\nstrcat(client_debug_string, ",");\r\n} else {\r\ngossip_err("%s: overflow!\n", __func__);\r\nstrcpy(client_debug_string, ORANGEFS_ALL);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn;\r\n}\r\nint keyword_is_amalgam(char *keyword)\r\n{\r\nint rc = 0;\r\nif ((!strcmp(keyword, ORANGEFS_ALL)) || (!strcmp(keyword, ORANGEFS_VERBOSE)))\r\nrc = 1;\r\nreturn rc;\r\n}\r\nint check_amalgam_keyword(void *mask, int type)\r\n{\r\n__u64 *k_mask;\r\nstruct client_debug_mask *c_mask;\r\nint k_all_index = num_kmod_keyword_mask_map - 1;\r\nint rc = 0;\r\nif (type) {\r\nc_mask = (struct client_debug_mask *) mask;\r\nif ((c_mask->mask1 == cdm_array[client_all_index].mask1) &&\r\n(c_mask->mask2 == cdm_array[client_all_index].mask2)) {\r\nstrcpy(client_debug_string, ORANGEFS_ALL);\r\nrc = 1;\r\ngoto out;\r\n}\r\nif ((c_mask->mask1 == cdm_array[client_verbose_index].mask1) &&\r\n(c_mask->mask2 == cdm_array[client_verbose_index].mask2)) {\r\nstrcpy(client_debug_string, ORANGEFS_VERBOSE);\r\nrc = 1;\r\ngoto out;\r\n}\r\n} else {\r\nk_mask = (__u64 *) mask;\r\nif (*k_mask >= s_kmod_keyword_mask_map[k_all_index].mask_val) {\r\nstrcpy(kernel_debug_string, ORANGEFS_ALL);\r\nrc = 1;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nvoid debug_string_to_mask(char *debug_string, void *mask, int type)\r\n{\r\nchar *unchecked_keyword;\r\nint i;\r\nchar *strsep_fodder = kstrdup(debug_string, GFP_KERNEL);\r\nchar *original_pointer;\r\nint element_count = 0;\r\nstruct client_debug_mask *c_mask;\r\n__u64 *k_mask;\r\ngossip_debug(GOSSIP_UTILS_DEBUG, "%s: start\n", __func__);\r\nif (type) {\r\nc_mask = (struct client_debug_mask *)mask;\r\nelement_count = cdm_element_count;\r\n} else {\r\nk_mask = (__u64 *)mask;\r\n*k_mask = 0;\r\nelement_count = num_kmod_keyword_mask_map;\r\n}\r\noriginal_pointer = strsep_fodder;\r\nwhile ((unchecked_keyword = strsep(&strsep_fodder, ",")))\r\nif (strlen(unchecked_keyword)) {\r\nfor (i = 0; i < element_count; i++)\r\nif (type)\r\ndo_c_mask(i,\r\nunchecked_keyword,\r\n&c_mask);\r\nelse\r\ndo_k_mask(i,\r\nunchecked_keyword,\r\n&k_mask);\r\n}\r\nkfree(original_pointer);\r\n}\r\nvoid do_c_mask(int i,\r\nchar *unchecked_keyword,\r\nstruct client_debug_mask **sane_mask)\r\n{\r\nif (!strcmp(cdm_array[i].keyword, unchecked_keyword)) {\r\n(**sane_mask).mask1 = (**sane_mask).mask1 | cdm_array[i].mask1;\r\n(**sane_mask).mask2 = (**sane_mask).mask2 | cdm_array[i].mask2;\r\n}\r\n}\r\nvoid do_k_mask(int i, char *unchecked_keyword, __u64 **sane_mask)\r\n{\r\nif (!strcmp(s_kmod_keyword_mask_map[i].keyword, unchecked_keyword))\r\n**sane_mask = (**sane_mask) |\r\ns_kmod_keyword_mask_map[i].mask_val;\r\n}
