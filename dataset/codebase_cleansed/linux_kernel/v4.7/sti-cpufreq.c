static int sti_cpufreq_fetch_major(void) {\r\nstruct device_node *np = ddata.cpu->of_node;\r\nstruct device *dev = ddata.cpu;\r\nunsigned int major_offset;\r\nunsigned int socid;\r\nint ret;\r\nret = of_property_read_u32_index(np, "st,syscfg",\r\nMAJOR_ID_INDEX, &major_offset);\r\nif (ret) {\r\ndev_err(dev, "No major number offset provided in %s [%d]\n",\r\nnp->full_name, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(ddata.syscfg, major_offset, &socid);\r\nif (ret) {\r\ndev_err(dev, "Failed to read major number from syscon [%d]\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn ((socid >> VERSION_SHIFT) & 0xf) + 1;\r\n}\r\nstatic int sti_cpufreq_fetch_minor(void)\r\n{\r\nstruct device *dev = ddata.cpu;\r\nstruct device_node *np = dev->of_node;\r\nunsigned int minor_offset;\r\nunsigned int minid;\r\nint ret;\r\nret = of_property_read_u32_index(np, "st,syscfg-eng",\r\nMINOR_ID_INDEX, &minor_offset);\r\nif (ret) {\r\ndev_err(dev,\r\n"No minor number offset provided %s [%d]\n",\r\nnp->full_name, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(ddata.syscfg_eng, minor_offset, &minid);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to read the minor number from syscon [%d]\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn minid & 0xf;\r\n}\r\nstatic int sti_cpufreq_fetch_regmap_field(const struct reg_field *reg_fields,\r\nint hw_info_offset, int field)\r\n{\r\nstruct regmap_field *regmap_field;\r\nstruct reg_field reg_field = reg_fields[field];\r\nstruct device *dev = ddata.cpu;\r\nunsigned int value;\r\nint ret;\r\nreg_field.reg = hw_info_offset;\r\nregmap_field = devm_regmap_field_alloc(dev,\r\nddata.syscfg_eng,\r\nreg_field);\r\nif (IS_ERR(regmap_field)) {\r\ndev_err(dev, "Failed to allocate reg field\n");\r\nreturn PTR_ERR(regmap_field);\r\n}\r\nret = regmap_field_read(regmap_field, &value);\r\nif (ret) {\r\ndev_err(dev, "Failed to read %s code\n",\r\nfield ? "SUBSTRATE" : "PCODE");\r\nreturn ret;\r\n}\r\nreturn value;\r\n}\r\nstatic const struct reg_field *sti_cpufreq_match(void)\r\n{\r\nif (of_machine_is_compatible("st,stih407") ||\r\nof_machine_is_compatible("st,stih410"))\r\nreturn sti_stih407_dvfs_regfields;\r\nreturn NULL;\r\n}\r\nstatic int sti_cpufreq_set_opp_info(void)\r\n{\r\nstruct device *dev = ddata.cpu;\r\nstruct device_node *np = dev->of_node;\r\nconst struct reg_field *reg_fields;\r\nunsigned int hw_info_offset;\r\nunsigned int version[VERSION_ELEMENTS];\r\nint pcode, substrate, major, minor;\r\nint ret;\r\nchar name[MAX_PCODE_NAME_LEN];\r\nreg_fields = sti_cpufreq_match();\r\nif (!reg_fields) {\r\ndev_err(dev, "This SoC doesn't support voltage scaling");\r\nreturn -ENODEV;\r\n}\r\nret = of_property_read_u32_index(np, "st,syscfg-eng",\r\nHW_INFO_INDEX, &hw_info_offset);\r\nif (ret) {\r\ndev_warn(dev, "Failed to read HW info offset from DT\n");\r\nsubstrate = DEFAULT_VERSION;\r\npcode = 0;\r\ngoto use_defaults;\r\n}\r\npcode = sti_cpufreq_fetch_regmap_field(reg_fields,\r\nhw_info_offset,\r\nPCODE);\r\nif (pcode < 0) {\r\ndev_warn(dev, "Failed to obtain process code\n");\r\npcode = 0;\r\n}\r\nsubstrate = sti_cpufreq_fetch_regmap_field(reg_fields,\r\nhw_info_offset,\r\nSUBSTRATE);\r\nif (substrate) {\r\ndev_warn(dev, "Failed to obtain substrate code\n");\r\nsubstrate = DEFAULT_VERSION;\r\n}\r\nuse_defaults:\r\nmajor = sti_cpufreq_fetch_major();\r\nif (major < 0) {\r\ndev_err(dev, "Failed to obtain major version\n");\r\nmajor = DEFAULT_VERSION;\r\n}\r\nminor = sti_cpufreq_fetch_minor();\r\nif (minor < 0) {\r\ndev_err(dev, "Failed to obtain minor version\n");\r\nminor = DEFAULT_VERSION;\r\n}\r\nsnprintf(name, MAX_PCODE_NAME_LEN, "pcode%d", pcode);\r\nret = dev_pm_opp_set_prop_name(dev, name);\r\nif (ret) {\r\ndev_err(dev, "Failed to set prop name\n");\r\nreturn ret;\r\n}\r\nversion[0] = BIT(major);\r\nversion[1] = BIT(minor);\r\nversion[2] = BIT(substrate);\r\nret = dev_pm_opp_set_supported_hw(dev, version, VERSION_ELEMENTS);\r\nif (ret) {\r\ndev_err(dev, "Failed to set supported hardware\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "pcode: %d major: %d minor: %d substrate: %d\n",\r\npcode, major, minor, substrate);\r\ndev_dbg(dev, "version[0]: %x version[1]: %x version[2]: %x\n",\r\nversion[0], version[1], version[2]);\r\nreturn 0;\r\n}\r\nstatic int sti_cpufreq_fetch_syscon_regsiters(void)\r\n{\r\nstruct device *dev = ddata.cpu;\r\nstruct device_node *np = dev->of_node;\r\nddata.syscfg = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(ddata.syscfg)) {\r\ndev_err(dev, "\"st,syscfg\" not supplied\n");\r\nreturn PTR_ERR(ddata.syscfg);\r\n}\r\nddata.syscfg_eng = syscon_regmap_lookup_by_phandle(np, "st,syscfg-eng");\r\nif (IS_ERR(ddata.syscfg_eng)) {\r\ndev_err(dev, "\"st,syscfg-eng\" not supplied\n");\r\nreturn PTR_ERR(ddata.syscfg_eng);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_cpufreq_init(void)\r\n{\r\nint ret;\r\nif ((!of_machine_is_compatible("st,stih407")) &&\r\n(!of_machine_is_compatible("st,stih410")))\r\nreturn -ENODEV;\r\nddata.cpu = get_cpu_device(0);\r\nif (!ddata.cpu) {\r\ndev_err(ddata.cpu, "Failed to get device for CPU0\n");\r\ngoto skip_voltage_scaling;\r\n}\r\nif (!of_get_property(ddata.cpu->of_node, "operating-points-v2", NULL)) {\r\ndev_err(ddata.cpu, "OPP-v2 not supported\n");\r\ngoto skip_voltage_scaling;\r\n}\r\nret = sti_cpufreq_fetch_syscon_regsiters();\r\nif (ret)\r\ngoto skip_voltage_scaling;\r\nret = sti_cpufreq_set_opp_info();\r\nif (!ret)\r\ngoto register_cpufreq_dt;\r\nskip_voltage_scaling:\r\ndev_err(ddata.cpu, "Not doing voltage scaling\n");\r\nregister_cpufreq_dt:\r\nplatform_device_register_simple("cpufreq-dt", -1, NULL, 0);\r\nreturn 0;\r\n}
