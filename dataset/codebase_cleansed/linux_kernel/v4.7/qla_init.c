void\r\nqla2x00_sp_timeout(unsigned long __data)\r\n{\r\nsrb_t *sp = (srb_t *)__data;\r\nstruct srb_iocb *iocb;\r\nfc_port_t *fcport = sp->fcport;\r\nstruct qla_hw_data *ha = fcport->vha->hw;\r\nstruct req_que *req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nreq = ha->req_q_map[0];\r\nreq->outstanding_cmds[sp->handle] = NULL;\r\niocb = &sp->u.iocb_cmd;\r\niocb->timeout(sp);\r\nsp->free(fcport->vha, sp);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid\r\nqla2x00_sp_free(void *data, void *ptr)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct srb_iocb *iocb = &sp->u.iocb_cmd;\r\nstruct scsi_qla_host *vha = (scsi_qla_host_t *)data;\r\ndel_timer(&iocb->timer);\r\nqla2x00_rel_sp(vha, sp);\r\n}\r\nunsigned long\r\nqla2x00_get_async_timeout(struct scsi_qla_host *vha)\r\n{\r\nunsigned long tmo;\r\nstruct qla_hw_data *ha = vha->hw;\r\ntmo = ha->r_a_tov / 10 * 2;\r\nif (IS_QLAFX00(ha)) {\r\ntmo = FX00_DEF_RATOV * 2;\r\n} else if (!IS_FWI2_CAPABLE(ha)) {\r\ntmo = ha->login_timeout;\r\n}\r\nreturn tmo;\r\n}\r\nstatic void\r\nqla2x00_async_iocb_timeout(void *data)\r\n{\r\nsrb_t *sp = (srb_t *)data;\r\nfc_port_t *fcport = sp->fcport;\r\nql_dbg(ql_dbg_disc, fcport->vha, 0x2071,\r\n"Async-%s timeout - hdl=%x portid=%02x%02x%02x.\n",\r\nsp->name, sp->handle, fcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nfcport->flags &= ~FCF_ASYNC_SENT;\r\nif (sp->type == SRB_LOGIN_CMD) {\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nqla2x00_post_async_logout_work(fcport->vha, fcport, NULL);\r\nlio->u.logio.data[0] = MBS_COMMAND_ERROR;\r\nlio->u.logio.data[1] = lio->u.logio.flags & SRB_LOGIN_RETRIED ?\r\nQLA_LOGIO_LOGIN_RETRIED : 0;\r\nqla2x00_post_async_login_done_work(fcport->vha, fcport,\r\nlio->u.logio.data);\r\n} else if (sp->type == SRB_LOGOUT_CMD) {\r\nqlt_logo_completion_handler(fcport, QLA_FUNCTION_TIMEOUT);\r\n}\r\n}\r\nstatic void\r\nqla2x00_async_login_sp_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nstruct scsi_qla_host *vha = (scsi_qla_host_t *)data;\r\nif (!test_bit(UNLOADING, &vha->dpc_flags))\r\nqla2x00_post_async_login_done_work(sp->fcport->vha, sp->fcport,\r\nlio->u.logio.data);\r\nsp->free(sp->fcport->vha, sp);\r\n}\r\nint\r\nqla2x00_async_login(struct scsi_qla_host *vha, fc_port_t *fcport,\r\nuint16_t *data)\r\n{\r\nsrb_t *sp;\r\nstruct srb_iocb *lio;\r\nint rval;\r\nrval = QLA_FUNCTION_FAILED;\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp)\r\ngoto done;\r\nsp->type = SRB_LOGIN_CMD;\r\nsp->name = "login";\r\nqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\r\nlio = &sp->u.iocb_cmd;\r\nlio->timeout = qla2x00_async_iocb_timeout;\r\nsp->done = qla2x00_async_login_sp_done;\r\nlio->u.logio.flags |= SRB_LOGIN_COND_PLOGI;\r\nif (data[1] & QLA_LOGIO_LOGIN_RETRIED)\r\nlio->u.logio.flags |= SRB_LOGIN_RETRIED;\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS) {\r\nfcport->flags &= ~FCF_ASYNC_SENT;\r\nfcport->flags |= FCF_LOGIN_NEEDED;\r\nset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\r\ngoto done_free_sp;\r\n}\r\nql_dbg(ql_dbg_disc, vha, 0x2072,\r\n"Async-login - hdl=%x, loopid=%x portid=%02x%02x%02x "\r\n"retries=%d.\n", sp->handle, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa,\r\nfcport->login_retry);\r\nreturn rval;\r\ndone_free_sp:\r\nsp->free(fcport->vha, sp);\r\ndone:\r\nreturn rval;\r\n}\r\nstatic void\r\nqla2x00_async_logout_sp_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nstruct scsi_qla_host *vha = (scsi_qla_host_t *)data;\r\nif (!test_bit(UNLOADING, &vha->dpc_flags))\r\nqla2x00_post_async_logout_done_work(sp->fcport->vha, sp->fcport,\r\nlio->u.logio.data);\r\nsp->free(sp->fcport->vha, sp);\r\n}\r\nint\r\nqla2x00_async_logout(struct scsi_qla_host *vha, fc_port_t *fcport)\r\n{\r\nsrb_t *sp;\r\nstruct srb_iocb *lio;\r\nint rval;\r\nrval = QLA_FUNCTION_FAILED;\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp)\r\ngoto done;\r\nsp->type = SRB_LOGOUT_CMD;\r\nsp->name = "logout";\r\nqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\r\nlio = &sp->u.iocb_cmd;\r\nlio->timeout = qla2x00_async_iocb_timeout;\r\nsp->done = qla2x00_async_logout_sp_done;\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS)\r\ngoto done_free_sp;\r\nql_dbg(ql_dbg_disc, vha, 0x2070,\r\n"Async-logout - hdl=%x loop-id=%x portid=%02x%02x%02x.\n",\r\nsp->handle, fcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nreturn rval;\r\ndone_free_sp:\r\nsp->free(fcport->vha, sp);\r\ndone:\r\nreturn rval;\r\n}\r\nstatic void\r\nqla2x00_async_adisc_sp_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\nstruct scsi_qla_host *vha = (scsi_qla_host_t *)data;\r\nif (!test_bit(UNLOADING, &vha->dpc_flags))\r\nqla2x00_post_async_adisc_done_work(sp->fcport->vha, sp->fcport,\r\nlio->u.logio.data);\r\nsp->free(sp->fcport->vha, sp);\r\n}\r\nint\r\nqla2x00_async_adisc(struct scsi_qla_host *vha, fc_port_t *fcport,\r\nuint16_t *data)\r\n{\r\nsrb_t *sp;\r\nstruct srb_iocb *lio;\r\nint rval;\r\nrval = QLA_FUNCTION_FAILED;\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp)\r\ngoto done;\r\nsp->type = SRB_ADISC_CMD;\r\nsp->name = "adisc";\r\nqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\r\nlio = &sp->u.iocb_cmd;\r\nlio->timeout = qla2x00_async_iocb_timeout;\r\nsp->done = qla2x00_async_adisc_sp_done;\r\nif (data[1] & QLA_LOGIO_LOGIN_RETRIED)\r\nlio->u.logio.flags |= SRB_LOGIN_RETRIED;\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS)\r\ngoto done_free_sp;\r\nql_dbg(ql_dbg_disc, vha, 0x206f,\r\n"Async-adisc - hdl=%x loopid=%x portid=%02x%02x%02x.\n",\r\nsp->handle, fcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nreturn rval;\r\ndone_free_sp:\r\nsp->free(fcport->vha, sp);\r\ndone:\r\nreturn rval;\r\n}\r\nstatic void\r\nqla2x00_tmf_iocb_timeout(void *data)\r\n{\r\nsrb_t *sp = (srb_t *)data;\r\nstruct srb_iocb *tmf = &sp->u.iocb_cmd;\r\ntmf->u.tmf.comp_status = CS_TIMEOUT;\r\ncomplete(&tmf->u.tmf.comp);\r\n}\r\nstatic void\r\nqla2x00_tmf_sp_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct srb_iocb *tmf = &sp->u.iocb_cmd;\r\ncomplete(&tmf->u.tmf.comp);\r\n}\r\nint\r\nqla2x00_async_tm_cmd(fc_port_t *fcport, uint32_t flags, uint32_t lun,\r\nuint32_t tag)\r\n{\r\nstruct scsi_qla_host *vha = fcport->vha;\r\nstruct srb_iocb *tm_iocb;\r\nsrb_t *sp;\r\nint rval = QLA_FUNCTION_FAILED;\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp)\r\ngoto done;\r\ntm_iocb = &sp->u.iocb_cmd;\r\nsp->type = SRB_TM_CMD;\r\nsp->name = "tmf";\r\nqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha));\r\ntm_iocb->u.tmf.flags = flags;\r\ntm_iocb->u.tmf.lun = lun;\r\ntm_iocb->u.tmf.data = tag;\r\nsp->done = qla2x00_tmf_sp_done;\r\ntm_iocb->timeout = qla2x00_tmf_iocb_timeout;\r\ninit_completion(&tm_iocb->u.tmf.comp);\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS)\r\ngoto done_free_sp;\r\nql_dbg(ql_dbg_taskm, vha, 0x802f,\r\n"Async-tmf hdl=%x loop-id=%x portid=%02x%02x%02x.\n",\r\nsp->handle, fcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nwait_for_completion(&tm_iocb->u.tmf.comp);\r\nrval = tm_iocb->u.tmf.comp_status == CS_COMPLETE ?\r\nQLA_SUCCESS : QLA_FUNCTION_FAILED;\r\nif ((rval != QLA_SUCCESS) || tm_iocb->u.tmf.data) {\r\nql_dbg(ql_dbg_taskm, vha, 0x8030,\r\n"TM IOCB failed (%x).\n", rval);\r\n}\r\nif (!test_bit(UNLOADING, &vha->dpc_flags) && !IS_QLAFX00(vha->hw)) {\r\nflags = tm_iocb->u.tmf.flags;\r\nlun = (uint16_t)tm_iocb->u.tmf.lun;\r\nqla2x00_marker(vha, vha->hw->req_q_map[0],\r\nvha->hw->rsp_q_map[0], sp->fcport->loop_id, lun,\r\nflags == TCF_LUN_RESET ? MK_SYNC_ID_LUN : MK_SYNC_ID);\r\n}\r\ndone_free_sp:\r\nsp->free(vha, sp);\r\ndone:\r\nreturn rval;\r\n}\r\nstatic void\r\nqla24xx_abort_iocb_timeout(void *data)\r\n{\r\nsrb_t *sp = (srb_t *)data;\r\nstruct srb_iocb *abt = &sp->u.iocb_cmd;\r\nabt->u.abt.comp_status = CS_TIMEOUT;\r\ncomplete(&abt->u.abt.comp);\r\n}\r\nstatic void\r\nqla24xx_abort_sp_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct srb_iocb *abt = &sp->u.iocb_cmd;\r\ncomplete(&abt->u.abt.comp);\r\n}\r\nstatic int\r\nqla24xx_async_abort_cmd(srb_t *cmd_sp)\r\n{\r\nscsi_qla_host_t *vha = cmd_sp->fcport->vha;\r\nfc_port_t *fcport = cmd_sp->fcport;\r\nstruct srb_iocb *abt_iocb;\r\nsrb_t *sp;\r\nint rval = QLA_FUNCTION_FAILED;\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp)\r\ngoto done;\r\nabt_iocb = &sp->u.iocb_cmd;\r\nsp->type = SRB_ABT_CMD;\r\nsp->name = "abort";\r\nqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha));\r\nabt_iocb->u.abt.cmd_hndl = cmd_sp->handle;\r\nsp->done = qla24xx_abort_sp_done;\r\nabt_iocb->timeout = qla24xx_abort_iocb_timeout;\r\ninit_completion(&abt_iocb->u.abt.comp);\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS)\r\ngoto done_free_sp;\r\nql_dbg(ql_dbg_async, vha, 0x507c,\r\n"Abort command issued - hdl=%x, target_id=%x\n",\r\ncmd_sp->handle, fcport->tgt_id);\r\nwait_for_completion(&abt_iocb->u.abt.comp);\r\nrval = abt_iocb->u.abt.comp_status == CS_COMPLETE ?\r\nQLA_SUCCESS : QLA_FUNCTION_FAILED;\r\ndone_free_sp:\r\nsp->free(vha, sp);\r\ndone:\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_async_abort_command(srb_t *sp)\r\n{\r\nunsigned long flags = 0;\r\nuint32_t handle;\r\nfc_port_t *fcport = sp->fcport;\r\nstruct scsi_qla_host *vha = fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = vha->req;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\r\nif (req->outstanding_cmds[handle] == sp)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (handle == req->num_outstanding_cmds) {\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nif (sp->type == SRB_FXIOCB_DCMD)\r\nreturn qlafx00_fx_disc(vha, &vha->hw->mr.fcport,\r\nFXDISC_ABORT_IOCTL);\r\nreturn qla24xx_async_abort_cmd(sp);\r\n}\r\nvoid\r\nqla2x00_async_login_done(struct scsi_qla_host *vha, fc_port_t *fcport,\r\nuint16_t *data)\r\n{\r\nint rval;\r\nswitch (data[0]) {\r\ncase MBS_COMMAND_COMPLETE:\r\nrval = qla2x00_get_port_database(vha, fcport, 0);\r\nif (rval == QLA_NOT_LOGGED_IN) {\r\nfcport->flags &= ~FCF_ASYNC_SENT;\r\nfcport->flags |= FCF_LOGIN_NEEDED;\r\nset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\r\nbreak;\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nqla2x00_post_async_logout_work(vha, fcport, NULL);\r\nqla2x00_post_async_login_work(vha, fcport, NULL);\r\nbreak;\r\n}\r\nif (fcport->flags & FCF_FCP2_DEVICE) {\r\nqla2x00_post_async_adisc_work(vha, fcport, data);\r\nbreak;\r\n}\r\nqla2x00_update_fcport(vha, fcport);\r\nbreak;\r\ncase MBS_COMMAND_ERROR:\r\nfcport->flags &= ~FCF_ASYNC_SENT;\r\nif (data[1] & QLA_LOGIO_LOGIN_RETRIED)\r\nset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\r\nelse\r\nqla2x00_mark_device_lost(vha, fcport, 1, 0);\r\nbreak;\r\ncase MBS_PORT_ID_USED:\r\nfcport->loop_id = data[1];\r\nqla2x00_post_async_logout_work(vha, fcport, NULL);\r\nqla2x00_post_async_login_work(vha, fcport, NULL);\r\nbreak;\r\ncase MBS_LOOP_ID_USED:\r\nfcport->loop_id++;\r\nrval = qla2x00_find_new_loop_id(vha, fcport);\r\nif (rval != QLA_SUCCESS) {\r\nfcport->flags &= ~FCF_ASYNC_SENT;\r\nqla2x00_mark_device_lost(vha, fcport, 1, 0);\r\nbreak;\r\n}\r\nqla2x00_post_async_login_work(vha, fcport, NULL);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid\r\nqla2x00_async_logout_done(struct scsi_qla_host *vha, fc_port_t *fcport,\r\nuint16_t *data)\r\n{\r\nif (!fcport->tgt_session)\r\nqla2x00_mark_device_lost(vha, fcport, 1, 0);\r\nqlt_logo_completion_handler(fcport, data[0]);\r\nreturn;\r\n}\r\nvoid\r\nqla2x00_async_adisc_done(struct scsi_qla_host *vha, fc_port_t *fcport,\r\nuint16_t *data)\r\n{\r\nif (data[0] == MBS_COMMAND_COMPLETE) {\r\nqla2x00_update_fcport(vha, fcport);\r\nreturn;\r\n}\r\nfcport->flags &= ~FCF_ASYNC_SENT;\r\nif (data[1] & QLA_LOGIO_LOGIN_RETRIED)\r\nset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\r\nelse\r\nqla2x00_mark_device_lost(vha, fcport, 1, 0);\r\nreturn;\r\n}\r\nstatic int\r\nqla83xx_nic_core_fw_load(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t idc_major_ver, idc_minor_ver;\r\nuint16_t config[4];\r\nqla83xx_idc_lock(vha, 0);\r\nha->fcoe_dev_init_timeout = QLA83XX_IDC_INITIALIZATION_TIMEOUT;\r\nha->fcoe_reset_timeout = QLA83XX_IDC_RESET_ACK_TIMEOUT;\r\nif (__qla83xx_set_drv_presence(vha) != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb077,\r\n"Error while setting DRV-Presence.\n");\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto exit;\r\n}\r\nqla83xx_reset_ownership(vha);\r\nqla83xx_rd_reg(vha, QLA83XX_IDC_MAJOR_VERSION, &idc_major_ver);\r\nif (ha->flags.nic_core_reset_owner) {\r\nidc_major_ver = QLA83XX_SUPP_IDC_MAJOR_VERSION;\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_MAJOR_VERSION, idc_major_ver);\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_LOCK_RECOVERY, 0);\r\n} else if (idc_major_ver != QLA83XX_SUPP_IDC_MAJOR_VERSION) {\r\nql_log(ql_log_warn, vha, 0xb07d,\r\n"Failing load, idc_major_ver=%d, expected_major_ver=%d.\n",\r\nidc_major_ver, QLA83XX_SUPP_IDC_MAJOR_VERSION);\r\n__qla83xx_clear_drv_presence(vha);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto exit;\r\n}\r\nqla83xx_rd_reg(vha, QLA83XX_IDC_MINOR_VERSION, &idc_minor_ver);\r\nidc_minor_ver |= (QLA83XX_SUPP_IDC_MINOR_VERSION << (ha->portnum * 2));\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_MINOR_VERSION, idc_minor_ver);\r\nif (ha->flags.nic_core_reset_owner) {\r\nmemset(config, 0, sizeof(config));\r\nif (!qla81xx_get_port_config(vha, config))\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\r\nQLA8XXX_DEV_READY);\r\n}\r\nrval = qla83xx_idc_state_handler(vha);\r\nexit:\r\nqla83xx_idc_unlock(vha, 0);\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_initialize_adapter(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nvha->flags.online = 0;\r\nha->flags.chip_reset_done = 0;\r\nvha->flags.reset_active = 0;\r\nha->flags.pci_channel_io_perm_failure = 0;\r\nha->flags.eeh_busy = 0;\r\nvha->qla_stats.jiffies_at_last_reset = get_jiffies_64();\r\natomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nvha->device_flags = DFLG_NO_CABLE;\r\nvha->dpc_flags = 0;\r\nvha->flags.management_server_logged_in = 0;\r\nvha->marker_needed = 0;\r\nha->isp_abort_cnt = 0;\r\nha->beacon_blink_led = 0;\r\nset_bit(0, ha->req_qid_map);\r\nset_bit(0, ha->rsp_qid_map);\r\nql_dbg(ql_dbg_init, vha, 0x0040,\r\n"Configuring PCI space...\n");\r\nrval = ha->isp_ops->pci_config(vha);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x0044,\r\n"Unable to configure PCI space.\n");\r\nreturn (rval);\r\n}\r\nha->isp_ops->reset_chip(vha);\r\nrval = qla2xxx_get_flash_info(vha);\r\nif (rval) {\r\nql_log(ql_log_fatal, vha, 0x004f,\r\n"Unable to validate FLASH data.\n");\r\nreturn rval;\r\n}\r\nif (IS_QLA8044(ha)) {\r\nqla8044_read_reset_template(vha);\r\nif (ql2xdontresethba == 1)\r\nqla8044_set_idc_dontreset(vha);\r\n}\r\nha->isp_ops->get_flash_version(vha, req->ring);\r\nql_dbg(ql_dbg_init, vha, 0x0061,\r\n"Configure NVRAM parameters...\n");\r\nha->isp_ops->nvram_config(vha);\r\nif (ha->flags.disable_serdes) {\r\nql_log(ql_log_info, vha, 0x0077,\r\n"Masking HBA WWPN %8phN (via NVRAM).\n", vha->port_name);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x0078,\r\n"Verifying loaded RISC code...\n");\r\nif (qla2x00_isp_firmware(vha) != QLA_SUCCESS) {\r\nrval = ha->isp_ops->chip_diag(vha);\r\nif (rval)\r\nreturn (rval);\r\nrval = qla2x00_setup_chip(vha);\r\nif (rval)\r\nreturn (rval);\r\n}\r\nif (IS_QLA84XX(ha)) {\r\nha->cs84xx = qla84xx_get_chip(vha);\r\nif (!ha->cs84xx) {\r\nql_log(ql_log_warn, vha, 0x00d0,\r\n"Unable to configure ISP84XX.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nif (qla_ini_mode_enabled(vha))\r\nrval = qla2x00_init_rings(vha);\r\nha->flags.chip_reset_done = 1;\r\nif (rval == QLA_SUCCESS && IS_QLA84XX(ha)) {\r\nrval = qla84xx_init_chip(vha);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x00d4,\r\n"Unable to initialize ISP84XX.\n");\r\nqla84xx_put_chip(vha);\r\n}\r\n}\r\nif (IS_QLA8031(ha)) {\r\nrval = qla83xx_nic_core_fw_load(vha);\r\nif (rval)\r\nql_log(ql_log_warn, vha, 0x0124,\r\n"Error in initializing NIC Core f/w.\n");\r\n}\r\nif (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha))\r\nqla24xx_read_fcp_prio_cfg(vha);\r\nif (IS_P3P_TYPE(ha))\r\nqla82xx_set_driver_version(vha, QLA2XXX_VERSION);\r\nelse\r\nqla25xx_set_driver_version(vha, QLA2XXX_VERSION);\r\nreturn (rval);\r\n}\r\nint\r\nqla2100_pci_config(scsi_qla_host_t *vha)\r\n{\r\nuint16_t w;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\npci_set_master(ha->pdev);\r\npci_try_set_mwi(ha->pdev);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &w);\r\nw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\npci_write_config_word(ha->pdev, PCI_COMMAND, w);\r\npci_disable_rom(ha->pdev);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->pci_attr = RD_REG_WORD(&reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla2300_pci_config(scsi_qla_host_t *vha)\r\n{\r\nuint16_t w;\r\nunsigned long flags = 0;\r\nuint32_t cnt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\npci_set_master(ha->pdev);\r\npci_try_set_mwi(ha->pdev);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &w);\r\nw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\nif (IS_QLA2322(ha) || IS_QLA6322(ha))\r\nw &= ~PCI_COMMAND_INTX_DISABLE;\r\npci_write_config_word(ha->pdev, PCI_COMMAND, w);\r\nif (IS_QLA2300(ha)) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_WORD(&reg->hccr, HCCR_PAUSE_RISC);\r\nfor (cnt = 0; cnt < 30000; cnt++) {\r\nif ((RD_REG_WORD(&reg->hccr) & HCCR_RISC_PAUSE) != 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nWRT_REG_WORD(&reg->ctrl_status, 0x20);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nha->fb_rev = RD_FB_CMD_REG(ha, reg);\r\nif (ha->fb_rev == FPM_2300)\r\npci_clear_mwi(ha->pdev);\r\nWRT_REG_WORD(&reg->ctrl_status, 0x0);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);\r\nfor (cnt = 0; cnt < 30000; cnt++) {\r\nif ((RD_REG_WORD(&reg->hccr) & HCCR_RISC_PAUSE) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\npci_write_config_byte(ha->pdev, PCI_LATENCY_TIMER, 0x80);\r\npci_disable_rom(ha->pdev);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->pci_attr = RD_REG_WORD(&reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla24xx_pci_config(scsi_qla_host_t *vha)\r\n{\r\nuint16_t w;\r\nunsigned long flags = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\npci_set_master(ha->pdev);\r\npci_try_set_mwi(ha->pdev);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &w);\r\nw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\nw &= ~PCI_COMMAND_INTX_DISABLE;\r\npci_write_config_word(ha->pdev, PCI_COMMAND, w);\r\npci_write_config_byte(ha->pdev, PCI_LATENCY_TIMER, 0x80);\r\nif (pci_find_capability(ha->pdev, PCI_CAP_ID_PCIX))\r\npcix_set_mmrbc(ha->pdev, 2048);\r\nif (pci_is_pcie(ha->pdev))\r\npcie_set_readrq(ha->pdev, 4096);\r\npci_disable_rom(ha->pdev);\r\nha->chip_revision = ha->pdev->revision;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->pci_attr = RD_REG_DWORD(&reg->ctrl_status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla25xx_pci_config(scsi_qla_host_t *vha)\r\n{\r\nuint16_t w;\r\nstruct qla_hw_data *ha = vha->hw;\r\npci_set_master(ha->pdev);\r\npci_try_set_mwi(ha->pdev);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &w);\r\nw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\nw &= ~PCI_COMMAND_INTX_DISABLE;\r\npci_write_config_word(ha->pdev, PCI_COMMAND, w);\r\nif (pci_is_pcie(ha->pdev))\r\npcie_set_readrq(ha->pdev, 4096);\r\npci_disable_rom(ha->pdev);\r\nha->chip_revision = ha->pdev->revision;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int\r\nqla2x00_isp_firmware(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint16_t loop_id, topo, sw_cap;\r\nuint8_t domain, area, al_pa;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = QLA_FUNCTION_FAILED;\r\nif (ha->flags.disable_risc_code_load) {\r\nql_log(ql_log_info, vha, 0x0079, "RISC CODE NOT loaded.\n");\r\nrval = qla2x00_verify_checksum(vha, ha->fw_srisc_address);\r\nif (rval == QLA_SUCCESS) {\r\nrval = qla2x00_get_adapter_id(vha, &loop_id, &al_pa,\r\n&area, &domain, &topo, &sw_cap);\r\n}\r\n}\r\nif (rval)\r\nql_dbg(ql_dbg_init, vha, 0x007a,\r\n"**** Load RISC code ****.\n");\r\nreturn (rval);\r\n}\r\nvoid\r\nqla2x00_reset_chip(scsi_qla_host_t *vha)\r\n{\r\nunsigned long flags = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nuint32_t cnt;\r\nuint16_t cmd;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn;\r\nha->isp_ops->disable_intrs(ha);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ncmd = 0;\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &cmd);\r\ncmd &= ~PCI_COMMAND_MASTER;\r\npci_write_config_word(ha->pdev, PCI_COMMAND, cmd);\r\nif (!IS_QLA2100(ha)) {\r\nWRT_REG_WORD(&reg->hccr, HCCR_PAUSE_RISC);\r\nif (IS_QLA2200(ha) || IS_QLA2300(ha)) {\r\nfor (cnt = 0; cnt < 30000; cnt++) {\r\nif ((RD_REG_WORD(&reg->hccr) &\r\nHCCR_RISC_PAUSE) != 0)\r\nbreak;\r\nudelay(100);\r\n}\r\n} else {\r\nRD_REG_WORD(&reg->hccr);\r\nudelay(10);\r\n}\r\nWRT_REG_WORD(&reg->ctrl_status, 0x20);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nWRT_REG_WORD(&reg->fpm_diag_config, 0x100);\r\nRD_REG_WORD(&reg->fpm_diag_config);\r\nif (!IS_QLA2200(ha)) {\r\nWRT_REG_WORD(&reg->fpm_diag_config, 0x0);\r\nRD_REG_WORD(&reg->fpm_diag_config);\r\n}\r\nWRT_REG_WORD(&reg->ctrl_status, 0x10);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nif (IS_QLA2200(ha)) {\r\nWRT_FB_CMD_REG(ha, reg, 0xa000);\r\nRD_FB_CMD_REG(ha, reg);\r\n} else {\r\nWRT_FB_CMD_REG(ha, reg, 0x00fc);\r\nfor (cnt = 0; cnt < 3000; cnt++) {\r\nif ((RD_FB_CMD_REG(ha, reg) & 0xff) == 0)\r\nbreak;\r\nudelay(100);\r\n}\r\n}\r\nWRT_REG_WORD(&reg->ctrl_status, 0);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\n}\r\nWRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);\r\nWRT_REG_WORD(&reg->hccr, HCCR_CLR_HOST_INT);\r\nWRT_REG_WORD(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\r\nudelay(20);\r\nfor (cnt = 30000; cnt; cnt--) {\r\nif ((RD_REG_WORD(&reg->ctrl_status) &\r\nCSR_ISP_SOFT_RESET) == 0)\r\nbreak;\r\nudelay(100);\r\n}\r\n} else\r\nudelay(10);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);\r\nWRT_REG_WORD(&reg->semaphore, 0);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\r\nfor (cnt = 0; cnt < 30000; cnt++) {\r\nif (RD_MAILBOX_REG(ha, reg, 0) != MBS_BUSY)\r\nbreak;\r\nudelay(100);\r\n}\r\n} else\r\nudelay(100);\r\ncmd |= PCI_COMMAND_MASTER;\r\npci_write_config_word(ha->pdev, PCI_COMMAND, cmd);\r\nif (!IS_QLA2100(ha)) {\r\nWRT_REG_WORD(&reg->hccr, HCCR_DISABLE_PARITY_PAUSE);\r\nRD_REG_WORD(&reg->hccr);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic int\r\nqla81xx_reset_mpi(scsi_qla_host_t *vha)\r\n{\r\nuint16_t mb[4] = {0x1010, 0, 1, 0};\r\nif (!IS_QLA81XX(vha->hw))\r\nreturn QLA_SUCCESS;\r\nreturn qla81xx_write_mpi_register(vha, mb);\r\n}\r\nstatic inline int\r\nqla24xx_reset_risc(scsi_qla_host_t *vha)\r\n{\r\nunsigned long flags = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nuint32_t cnt;\r\nuint16_t wd;\r\nstatic int abts_cnt;\r\nint rval = QLA_SUCCESS;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_DWORD(&reg->ctrl_status, CSRX_DMA_SHUTDOWN|MWB_4096_BYTES);\r\nfor (cnt = 0; cnt < 30000; cnt++) {\r\nif ((RD_REG_DWORD(&reg->ctrl_status) & CSRX_DMA_ACTIVE) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!(RD_REG_DWORD(&reg->ctrl_status) & CSRX_DMA_ACTIVE))\r\nset_bit(DMA_SHUTDOWN_CMPL, &ha->fw_dump_cap_flags);\r\nql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x017e,\r\n"HCCR: 0x%x, Control Status %x, DMA active status:0x%x\n",\r\nRD_REG_DWORD(&reg->hccr),\r\nRD_REG_DWORD(&reg->ctrl_status),\r\n(RD_REG_DWORD(&reg->ctrl_status) & CSRX_DMA_ACTIVE));\r\nWRT_REG_DWORD(&reg->ctrl_status,\r\nCSRX_ISP_SOFT_RESET|CSRX_DMA_SHUTDOWN|MWB_4096_BYTES);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &wd);\r\nudelay(100);\r\nRD_REG_WORD(&reg->mailbox0);\r\nfor (cnt = 10000; RD_REG_WORD(&reg->mailbox0) != 0 &&\r\nrval == QLA_SUCCESS; cnt--) {\r\nbarrier();\r\nif (cnt)\r\nudelay(5);\r\nelse\r\nrval = QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (rval == QLA_SUCCESS)\r\nset_bit(ISP_MBX_RDY, &ha->fw_dump_cap_flags);\r\nql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x017f,\r\n"HCCR: 0x%x, MailBox0 Status 0x%x\n",\r\nRD_REG_DWORD(&reg->hccr),\r\nRD_REG_DWORD(&reg->mailbox0));\r\nRD_REG_DWORD(&reg->ctrl_status);\r\nfor (cnt = 0; cnt < 6000000; cnt++) {\r\nbarrier();\r\nif ((RD_REG_DWORD(&reg->ctrl_status) &\r\nCSRX_ISP_SOFT_RESET) == 0)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (!(RD_REG_DWORD(&reg->ctrl_status) & CSRX_ISP_SOFT_RESET))\r\nset_bit(ISP_SOFT_RESET_CMPL, &ha->fw_dump_cap_flags);\r\nql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015d,\r\n"HCCR: 0x%x, Soft Reset status: 0x%x\n",\r\nRD_REG_DWORD(&reg->hccr),\r\nRD_REG_DWORD(&reg->ctrl_status));\r\nif (test_and_clear_bit(MPI_RESET_NEEDED, &vha->dpc_flags)) {\r\nif (qla81xx_reset_mpi(vha) != QLA_SUCCESS) {\r\nif (++abts_cnt < 5) {\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nset_bit(MPI_RESET_NEEDED, &vha->dpc_flags);\r\n} else {\r\nabts_cnt = 0;\r\nvha->flags.online = 0;\r\n}\r\n}\r\n}\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_SET_RISC_RESET);\r\nRD_REG_DWORD(&reg->hccr);\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_REL_RISC_PAUSE);\r\nRD_REG_DWORD(&reg->hccr);\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_RESET);\r\nRD_REG_DWORD(&reg->hccr);\r\nRD_REG_WORD(&reg->mailbox0);\r\nfor (cnt = 6000000; RD_REG_WORD(&reg->mailbox0) != 0 &&\r\nrval == QLA_SUCCESS; cnt--) {\r\nbarrier();\r\nif (cnt)\r\nudelay(5);\r\nelse\r\nrval = QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (rval == QLA_SUCCESS)\r\nset_bit(RISC_RDY_AFT_RESET, &ha->fw_dump_cap_flags);\r\nql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015e,\r\n"Host Risc 0x%x, mailbox0 0x%x\n",\r\nRD_REG_DWORD(&reg->hccr),\r\nRD_REG_WORD(&reg->mailbox0));\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015f,\r\n"Driver in %s mode\n",\r\nIS_NOPOLLING_TYPE(ha) ? "Interrupt" : "Polling");\r\nif (IS_NOPOLLING_TYPE(ha))\r\nha->isp_ops->enable_intrs(ha);\r\nreturn rval;\r\n}\r\nstatic void\r\nqla25xx_read_risc_sema_reg(scsi_qla_host_t *vha, uint32_t *data)\r\n{\r\nstruct device_reg_24xx __iomem *reg = &vha->hw->iobase->isp24;\r\nWRT_REG_DWORD(&reg->iobase_addr, RISC_REGISTER_BASE_OFFSET);\r\n*data = RD_REG_DWORD(&reg->iobase_window + RISC_REGISTER_WINDOW_OFFET);\r\n}\r\nstatic void\r\nqla25xx_write_risc_sema_reg(scsi_qla_host_t *vha, uint32_t data)\r\n{\r\nstruct device_reg_24xx __iomem *reg = &vha->hw->iobase->isp24;\r\nWRT_REG_DWORD(&reg->iobase_addr, RISC_REGISTER_BASE_OFFSET);\r\nWRT_REG_DWORD(&reg->iobase_window + RISC_REGISTER_WINDOW_OFFET, data);\r\n}\r\nstatic void\r\nqla25xx_manipulate_risc_semaphore(scsi_qla_host_t *vha)\r\n{\r\nuint32_t wd32 = 0;\r\nuint delta_msec = 100;\r\nuint elapsed_msec = 0;\r\nuint timeout_msec;\r\nulong n;\r\nif (vha->hw->pdev->subsystem_device != 0x0175 &&\r\nvha->hw->pdev->subsystem_device != 0x0240)\r\nreturn;\r\nWRT_REG_DWORD(&vha->hw->iobase->isp24.hccr, HCCRX_SET_RISC_PAUSE);\r\nudelay(100);\r\nattempt:\r\ntimeout_msec = TIMEOUT_SEMAPHORE;\r\nn = timeout_msec / delta_msec;\r\nwhile (n--) {\r\nqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_SET);\r\nqla25xx_read_risc_sema_reg(vha, &wd32);\r\nif (wd32 & RISC_SEMAPHORE)\r\nbreak;\r\nmsleep(delta_msec);\r\nelapsed_msec += delta_msec;\r\nif (elapsed_msec > TIMEOUT_TOTAL_ELAPSED)\r\ngoto force;\r\n}\r\nif (!(wd32 & RISC_SEMAPHORE))\r\ngoto force;\r\nif (!(wd32 & RISC_SEMAPHORE_FORCE))\r\ngoto acquired;\r\nqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_CLR);\r\ntimeout_msec = TIMEOUT_SEMAPHORE_FORCE;\r\nn = timeout_msec / delta_msec;\r\nwhile (n--) {\r\nqla25xx_read_risc_sema_reg(vha, &wd32);\r\nif (!(wd32 & RISC_SEMAPHORE_FORCE))\r\nbreak;\r\nmsleep(delta_msec);\r\nelapsed_msec += delta_msec;\r\nif (elapsed_msec > TIMEOUT_TOTAL_ELAPSED)\r\ngoto force;\r\n}\r\nif (wd32 & RISC_SEMAPHORE_FORCE)\r\nqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_FORCE_CLR);\r\ngoto attempt;\r\nforce:\r\nqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_FORCE_SET);\r\nacquired:\r\nreturn;\r\n}\r\nvoid\r\nqla24xx_reset_chip(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (pci_channel_offline(ha->pdev) &&\r\nha->flags.pci_channel_io_perm_failure) {\r\nreturn;\r\n}\r\nha->isp_ops->disable_intrs(ha);\r\nqla25xx_manipulate_risc_semaphore(vha);\r\nqla24xx_reset_risc(vha);\r\n}\r\nint\r\nqla2x00_chip_diag(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nunsigned long flags = 0;\r\nuint16_t data;\r\nuint32_t cnt;\r\nuint16_t mb[5];\r\nstruct req_que *req = ha->req_q_map[0];\r\nrval = QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_init, vha, 0x007b,\r\n"Testing device at %lx.\n", (u_long)&reg->flash_address);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_WORD(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\r\nudelay(20);\r\ndata = qla2x00_debounce_register(&reg->ctrl_status);\r\nfor (cnt = 6000000 ; cnt && (data & CSR_ISP_SOFT_RESET); cnt--) {\r\nudelay(5);\r\ndata = RD_REG_WORD(&reg->ctrl_status);\r\nbarrier();\r\n}\r\nif (!cnt)\r\ngoto chip_diag_failed;\r\nql_dbg(ql_dbg_init, vha, 0x007c,\r\n"Reset register cleared by chip reset.\n");\r\nWRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\r\ndata = qla2x00_debounce_register(MAILBOX_REG(ha, reg, 0));\r\nfor (cnt = 6000000; cnt && (data == MBS_BUSY); cnt--) {\r\nudelay(5);\r\ndata = RD_MAILBOX_REG(ha, reg, 0);\r\nbarrier();\r\n}\r\n} else\r\nudelay(10);\r\nif (!cnt)\r\ngoto chip_diag_failed;\r\nql_dbg(ql_dbg_init, vha, 0x007d, "Checking product Id of chip.\n");\r\nmb[1] = RD_MAILBOX_REG(ha, reg, 1);\r\nmb[2] = RD_MAILBOX_REG(ha, reg, 2);\r\nmb[3] = RD_MAILBOX_REG(ha, reg, 3);\r\nmb[4] = qla2x00_debounce_register(MAILBOX_REG(ha, reg, 4));\r\nif (mb[1] != PROD_ID_1 || (mb[2] != PROD_ID_2 && mb[2] != PROD_ID_2a) ||\r\nmb[3] != PROD_ID_3) {\r\nql_log(ql_log_warn, vha, 0x0062,\r\n"Wrong product ID = 0x%x,0x%x,0x%x.\n",\r\nmb[1], mb[2], mb[3]);\r\ngoto chip_diag_failed;\r\n}\r\nha->product_id[0] = mb[1];\r\nha->product_id[1] = mb[2];\r\nha->product_id[2] = mb[3];\r\nha->product_id[3] = mb[4];\r\nif (req->length > 1024)\r\nha->fw_transfer_size = REQUEST_ENTRY_SIZE * 1024;\r\nelse\r\nha->fw_transfer_size = REQUEST_ENTRY_SIZE *\r\nreq->length;\r\nif (IS_QLA2200(ha) &&\r\nRD_MAILBOX_REG(ha, reg, 7) == QLA2200A_RISC_ROM_VER) {\r\nql_dbg(ql_dbg_init, vha, 0x007e, "Found QLA2200A Chip.\n");\r\nha->device_type |= DT_ISP2200A;\r\nha->fw_transfer_size = 128;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nql_dbg(ql_dbg_init, vha, 0x007f, "Checking mailboxes.\n");\r\nrval = qla2x00_mbx_reg_test(vha);\r\nif (rval)\r\nql_log(ql_log_warn, vha, 0x0080,\r\n"Failed mailbox send register test.\n");\r\nelse\r\nrval = QLA_SUCCESS;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nchip_diag_failed:\r\nif (rval)\r\nql_log(ql_log_info, vha, 0x0081,\r\n"Chip diagnostics **** FAILED ****.\n");\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn (rval);\r\n}\r\nint\r\nqla24xx_chip_diag(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nif (IS_P3P_TYPE(ha))\r\nreturn QLA_SUCCESS;\r\nha->fw_transfer_size = REQUEST_ENTRY_SIZE * req->length;\r\nrval = qla2x00_mbx_reg_test(vha);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x0082,\r\n"Failed mailbox send register test.\n");\r\n} else {\r\nrval = QLA_SUCCESS;\r\n}\r\nreturn rval;\r\n}\r\nvoid\r\nqla2x00_alloc_fw_dump(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint32_t dump_size, fixed_size, mem_size, req_q_size, rsp_q_size,\r\neft_size, fce_size, mq_size;\r\ndma_addr_t tc_dma;\r\nvoid *tc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\nif (ha->fw_dump) {\r\nql_dbg(ql_dbg_init, vha, 0x00bd,\r\n"Firmware dump already allocated.\n");\r\nreturn;\r\n}\r\nha->fw_dumped = 0;\r\nha->fw_dump_cap_flags = 0;\r\ndump_size = fixed_size = mem_size = eft_size = fce_size = mq_size = 0;\r\nreq_q_size = rsp_q_size = 0;\r\nif (IS_QLA27XX(ha))\r\ngoto try_fce;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\r\nfixed_size = sizeof(struct qla2100_fw_dump);\r\n} else if (IS_QLA23XX(ha)) {\r\nfixed_size = offsetof(struct qla2300_fw_dump, data_ram);\r\nmem_size = (ha->fw_memory_size - 0x11000 + 1) *\r\nsizeof(uint16_t);\r\n} else if (IS_FWI2_CAPABLE(ha)) {\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha))\r\nfixed_size = offsetof(struct qla83xx_fw_dump, ext_mem);\r\nelse if (IS_QLA81XX(ha))\r\nfixed_size = offsetof(struct qla81xx_fw_dump, ext_mem);\r\nelse if (IS_QLA25XX(ha))\r\nfixed_size = offsetof(struct qla25xx_fw_dump, ext_mem);\r\nelse\r\nfixed_size = offsetof(struct qla24xx_fw_dump, ext_mem);\r\nmem_size = (ha->fw_memory_size - 0x100000 + 1) *\r\nsizeof(uint32_t);\r\nif (ha->mqenable) {\r\nif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha))\r\nmq_size = sizeof(struct qla2xxx_mq_chain);\r\nmq_size += ha->max_req_queues *\r\n(req->length * sizeof(request_t));\r\nmq_size += ha->max_rsp_queues *\r\n(rsp->length * sizeof(response_t));\r\n}\r\nif (ha->tgt.atio_ring)\r\nmq_size += ha->tgt.atio_q_length * sizeof(request_t);\r\nif (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\r\n!IS_QLA27XX(ha))\r\ngoto try_eft;\r\ntry_fce:\r\nif (ha->fce)\r\ndma_free_coherent(&ha->pdev->dev,\r\nFCE_SIZE, ha->fce, ha->fce_dma);\r\ntc = dma_zalloc_coherent(&ha->pdev->dev, FCE_SIZE, &tc_dma,\r\nGFP_KERNEL);\r\nif (!tc) {\r\nql_log(ql_log_warn, vha, 0x00be,\r\n"Unable to allocate (%d KB) for FCE.\n",\r\nFCE_SIZE / 1024);\r\ngoto try_eft;\r\n}\r\nrval = qla2x00_enable_fce_trace(vha, tc_dma, FCE_NUM_BUFFERS,\r\nha->fce_mb, &ha->fce_bufs);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x00bf,\r\n"Unable to initialize FCE (%d).\n", rval);\r\ndma_free_coherent(&ha->pdev->dev, FCE_SIZE, tc,\r\ntc_dma);\r\nha->flags.fce_enabled = 0;\r\ngoto try_eft;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x00c0,\r\n"Allocate (%d KB) for FCE...\n", FCE_SIZE / 1024);\r\nfce_size = sizeof(struct qla2xxx_fce_chain) + FCE_SIZE;\r\nha->flags.fce_enabled = 1;\r\nha->fce_dma = tc_dma;\r\nha->fce = tc;\r\ntry_eft:\r\nif (ha->eft)\r\ndma_free_coherent(&ha->pdev->dev,\r\nEFT_SIZE, ha->eft, ha->eft_dma);\r\ntc = dma_zalloc_coherent(&ha->pdev->dev, EFT_SIZE, &tc_dma,\r\nGFP_KERNEL);\r\nif (!tc) {\r\nql_log(ql_log_warn, vha, 0x00c1,\r\n"Unable to allocate (%d KB) for EFT.\n",\r\nEFT_SIZE / 1024);\r\ngoto cont_alloc;\r\n}\r\nrval = qla2x00_enable_eft_trace(vha, tc_dma, EFT_NUM_BUFFERS);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x00c2,\r\n"Unable to initialize EFT (%d).\n", rval);\r\ndma_free_coherent(&ha->pdev->dev, EFT_SIZE, tc,\r\ntc_dma);\r\ngoto cont_alloc;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x00c3,\r\n"Allocated (%d KB) EFT ...\n", EFT_SIZE / 1024);\r\neft_size = EFT_SIZE;\r\nha->eft_dma = tc_dma;\r\nha->eft = tc;\r\n}\r\ncont_alloc:\r\nif (IS_QLA27XX(ha)) {\r\nif (!ha->fw_dump_template) {\r\nql_log(ql_log_warn, vha, 0x00ba,\r\n"Failed missing fwdump template\n");\r\nreturn;\r\n}\r\ndump_size = qla27xx_fwdt_calculate_dump_size(vha);\r\nql_dbg(ql_dbg_init, vha, 0x00fa,\r\n"-> allocating fwdump (%x bytes)...\n", dump_size);\r\ngoto allocate;\r\n}\r\nreq_q_size = req->length * sizeof(request_t);\r\nrsp_q_size = rsp->length * sizeof(response_t);\r\ndump_size = offsetof(struct qla2xxx_fw_dump, isp);\r\ndump_size += fixed_size + mem_size + req_q_size + rsp_q_size + eft_size;\r\nha->chain_offset = dump_size;\r\ndump_size += mq_size + fce_size;\r\nallocate:\r\nha->fw_dump = vmalloc(dump_size);\r\nif (!ha->fw_dump) {\r\nql_log(ql_log_warn, vha, 0x00c4,\r\n"Unable to allocate (%d KB) for firmware dump.\n",\r\ndump_size / 1024);\r\nif (ha->fce) {\r\ndma_free_coherent(&ha->pdev->dev, FCE_SIZE, ha->fce,\r\nha->fce_dma);\r\nha->fce = NULL;\r\nha->fce_dma = 0;\r\n}\r\nif (ha->eft) {\r\ndma_free_coherent(&ha->pdev->dev, eft_size, ha->eft,\r\nha->eft_dma);\r\nha->eft = NULL;\r\nha->eft_dma = 0;\r\n}\r\nreturn;\r\n}\r\nha->fw_dump_len = dump_size;\r\nql_dbg(ql_dbg_init, vha, 0x00c5,\r\n"Allocated (%d KB) for firmware dump.\n", dump_size / 1024);\r\nif (IS_QLA27XX(ha))\r\nreturn;\r\nha->fw_dump->signature[0] = 'Q';\r\nha->fw_dump->signature[1] = 'L';\r\nha->fw_dump->signature[2] = 'G';\r\nha->fw_dump->signature[3] = 'C';\r\nha->fw_dump->version = htonl(1);\r\nha->fw_dump->fixed_size = htonl(fixed_size);\r\nha->fw_dump->mem_size = htonl(mem_size);\r\nha->fw_dump->req_q_size = htonl(req_q_size);\r\nha->fw_dump->rsp_q_size = htonl(rsp_q_size);\r\nha->fw_dump->eft_size = htonl(eft_size);\r\nha->fw_dump->eft_addr_l = htonl(LSD(ha->eft_dma));\r\nha->fw_dump->eft_addr_h = htonl(MSD(ha->eft_dma));\r\nha->fw_dump->header_size =\r\nhtonl(offsetof(struct qla2xxx_fw_dump, isp));\r\n}\r\nstatic int\r\nqla81xx_mpi_sync(scsi_qla_host_t *vha)\r\n{\r\n#define MPS_MASK 0xe0\r\nint rval;\r\nuint16_t dc;\r\nuint32_t dw;\r\nif (!IS_QLA81XX(vha->hw))\r\nreturn QLA_SUCCESS;\r\nrval = qla2x00_write_ram_word(vha, 0x7c00, 1);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x0105,\r\n"Unable to acquire semaphore.\n");\r\ngoto done;\r\n}\r\npci_read_config_word(vha->hw->pdev, 0x54, &dc);\r\nrval = qla2x00_read_ram_word(vha, 0x7a15, &dw);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x0067, "Unable to read sync.\n");\r\ngoto done_release;\r\n}\r\ndc &= MPS_MASK;\r\nif (dc == (dw & MPS_MASK))\r\ngoto done_release;\r\ndw &= ~MPS_MASK;\r\ndw |= dc;\r\nrval = qla2x00_write_ram_word(vha, 0x7a15, dw);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x0114, "Unable to gain sync.\n");\r\n}\r\ndone_release:\r\nrval = qla2x00_write_ram_word(vha, 0x7c00, 0);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x006d,\r\n"Unable to release semaphore.\n");\r\n}\r\ndone:\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha, struct req_que *req)\r\n{\r\nif (req->outstanding_cmds)\r\nreturn QLA_SUCCESS;\r\nif (!IS_FWI2_CAPABLE(ha) || (ha->mqiobase &&\r\n(ql2xmultique_tag || ql2xmaxqueues > 1)))\r\nreq->num_outstanding_cmds = DEFAULT_OUTSTANDING_COMMANDS;\r\nelse {\r\nif (ha->cur_fw_xcb_count <= ha->cur_fw_iocb_count)\r\nreq->num_outstanding_cmds = ha->cur_fw_xcb_count;\r\nelse\r\nreq->num_outstanding_cmds = ha->cur_fw_iocb_count;\r\n}\r\nreq->outstanding_cmds = kzalloc(sizeof(srb_t *) *\r\nreq->num_outstanding_cmds, GFP_KERNEL);\r\nif (!req->outstanding_cmds) {\r\nreq->num_outstanding_cmds = MIN_OUTSTANDING_COMMANDS;\r\nreq->outstanding_cmds = kzalloc(sizeof(srb_t *) *\r\nreq->num_outstanding_cmds, GFP_KERNEL);\r\nif (!req->outstanding_cmds) {\r\nql_log(ql_log_fatal, NULL, 0x0126,\r\n"Failed to allocate memory for "\r\n"outstanding_cmds for req_que %p.\n", req);\r\nreq->num_outstanding_cmds = 0;\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int\r\nqla2x00_setup_chip(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint32_t srisc_address = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nunsigned long flags;\r\nuint16_t fw_major_version;\r\nif (IS_P3P_TYPE(ha)) {\r\nrval = ha->isp_ops->load_risc(vha, &srisc_address);\r\nif (rval == QLA_SUCCESS) {\r\nqla2x00_stop_firmware(vha);\r\ngoto enable_82xx_npiv;\r\n} else\r\ngoto failed;\r\n}\r\nif (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_WORD(&reg->hccr, (HCCR_ENABLE_PARITY + 0x0));\r\nRD_REG_WORD(&reg->hccr);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nqla81xx_mpi_sync(vha);\r\nrval = ha->isp_ops->load_risc(vha, &srisc_address);\r\nif (rval == QLA_SUCCESS) {\r\nql_dbg(ql_dbg_init, vha, 0x00c9,\r\n"Verifying Checksum of loaded RISC code.\n");\r\nrval = qla2x00_verify_checksum(vha, srisc_address);\r\nif (rval == QLA_SUCCESS) {\r\nql_dbg(ql_dbg_init, vha, 0x00ca,\r\n"Starting firmware.\n");\r\nif (ql2xexlogins)\r\nha->flags.exlogins_enabled = 1;\r\nif (ql2xexchoffld)\r\nha->flags.exchoffld_enabled = 1;\r\nrval = qla2x00_execute_fw(vha, srisc_address);\r\nif (rval == QLA_SUCCESS) {\r\nrval = qla2x00_set_exlogins_buffer(vha);\r\nif (rval != QLA_SUCCESS)\r\ngoto failed;\r\nrval = qla2x00_set_exchoffld_buffer(vha);\r\nif (rval != QLA_SUCCESS)\r\ngoto failed;\r\nenable_82xx_npiv:\r\nfw_major_version = ha->fw_major_version;\r\nif (IS_P3P_TYPE(ha))\r\nqla82xx_check_md_needed(vha);\r\nelse\r\nrval = qla2x00_get_fw_version(vha);\r\nif (rval != QLA_SUCCESS)\r\ngoto failed;\r\nha->flags.npiv_supported = 0;\r\nif (IS_QLA2XXX_MIDTYPE(ha) &&\r\n(ha->fw_attributes & BIT_2)) {\r\nha->flags.npiv_supported = 1;\r\nif ((!ha->max_npiv_vports) ||\r\n((ha->max_npiv_vports + 1) %\r\nMIN_MULTI_ID_FABRIC))\r\nha->max_npiv_vports =\r\nMIN_MULTI_ID_FABRIC - 1;\r\n}\r\nqla2x00_get_resource_cnts(vha);\r\nrval = qla2x00_alloc_outstanding_cmds(ha,\r\nvha->req);\r\nif (rval != QLA_SUCCESS)\r\ngoto failed;\r\nif (!fw_major_version && ql2xallocfwdump\r\n&& !(IS_P3P_TYPE(ha)))\r\nqla2x00_alloc_fw_dump(vha);\r\n} else {\r\ngoto failed;\r\n}\r\n} else {\r\nql_log(ql_log_fatal, vha, 0x00cd,\r\n"ISP Firmware failed checksum.\n");\r\ngoto failed;\r\n}\r\n} else\r\ngoto failed;\r\nif (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (IS_QLA2300(ha))\r\nWRT_REG_WORD(&reg->hccr, HCCR_ENABLE_PARITY + 0x1);\r\nelse\r\nWRT_REG_WORD(&reg->hccr, HCCR_ENABLE_PARITY + 0x7);\r\nRD_REG_WORD(&reg->hccr);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nif (IS_QLA27XX(ha))\r\nha->flags.fac_supported = 1;\r\nelse if (rval == QLA_SUCCESS && IS_FAC_REQUIRED(ha)) {\r\nuint32_t size;\r\nrval = qla81xx_fac_get_sector_size(vha, &size);\r\nif (rval == QLA_SUCCESS) {\r\nha->flags.fac_supported = 1;\r\nha->fdt_block_size = size << 2;\r\n} else {\r\nql_log(ql_log_warn, vha, 0x00ce,\r\n"Unsupported FAC firmware (%d.%02d.%02d).\n",\r\nha->fw_major_version, ha->fw_minor_version,\r\nha->fw_subminor_version);\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {\r\nha->flags.fac_supported = 0;\r\nrval = QLA_SUCCESS;\r\n}\r\n}\r\n}\r\nfailed:\r\nif (rval) {\r\nql_log(ql_log_fatal, vha, 0x00cf,\r\n"Setup chip ****FAILED****.\n");\r\n}\r\nreturn (rval);\r\n}\r\nvoid\r\nqla2x00_init_response_q_entries(struct rsp_que *rsp)\r\n{\r\nuint16_t cnt;\r\nresponse_t *pkt;\r\nrsp->ring_ptr = rsp->ring;\r\nrsp->ring_index = 0;\r\nrsp->status_srb = NULL;\r\npkt = rsp->ring_ptr;\r\nfor (cnt = 0; cnt < rsp->length; cnt++) {\r\npkt->signature = RESPONSE_PROCESSED;\r\npkt++;\r\n}\r\n}\r\nvoid\r\nqla2x00_update_fw_options(scsi_qla_host_t *vha)\r\n{\r\nuint16_t swing, emphasis, tx_sens, rx_sens;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmemset(ha->fw_options, 0, sizeof(ha->fw_options));\r\nqla2x00_get_fw_options(vha, ha->fw_options);\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn;\r\nql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0115,\r\n"Serial link options.\n");\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0109,\r\n(uint8_t *)&ha->fw_seriallink_options,\r\nsizeof(ha->fw_seriallink_options));\r\nha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;\r\nif (ha->fw_seriallink_options[3] & BIT_2) {\r\nha->fw_options[1] |= FO1_SET_EMPHASIS_SWING;\r\nswing = ha->fw_seriallink_options[2] & (BIT_2 | BIT_1 | BIT_0);\r\nemphasis = (ha->fw_seriallink_options[2] &\r\n(BIT_4 | BIT_3)) >> 3;\r\ntx_sens = ha->fw_seriallink_options[0] &\r\n(BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nrx_sens = (ha->fw_seriallink_options[0] &\r\n(BIT_7 | BIT_6 | BIT_5 | BIT_4)) >> 4;\r\nha->fw_options[10] = (emphasis << 14) | (swing << 8);\r\nif (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA6312(ha)) {\r\nif (rx_sens == 0x0)\r\nrx_sens = 0x3;\r\nha->fw_options[10] |= (tx_sens << 4) | rx_sens;\r\n} else if (IS_QLA2322(ha) || IS_QLA6322(ha))\r\nha->fw_options[10] |= BIT_5 |\r\n((rx_sens & (BIT_1 | BIT_0)) << 2) |\r\n(tx_sens & (BIT_1 | BIT_0));\r\nswing = (ha->fw_seriallink_options[2] &\r\n(BIT_7 | BIT_6 | BIT_5)) >> 5;\r\nemphasis = ha->fw_seriallink_options[3] & (BIT_1 | BIT_0);\r\ntx_sens = ha->fw_seriallink_options[1] &\r\n(BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nrx_sens = (ha->fw_seriallink_options[1] &\r\n(BIT_7 | BIT_6 | BIT_5 | BIT_4)) >> 4;\r\nha->fw_options[11] = (emphasis << 14) | (swing << 8);\r\nif (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA6312(ha)) {\r\nif (rx_sens == 0x0)\r\nrx_sens = 0x3;\r\nha->fw_options[11] |= (tx_sens << 4) | rx_sens;\r\n} else if (IS_QLA2322(ha) || IS_QLA6322(ha))\r\nha->fw_options[11] |= BIT_5 |\r\n((rx_sens & (BIT_1 | BIT_0)) << 2) |\r\n(tx_sens & (BIT_1 | BIT_0));\r\n}\r\nha->fw_options[3] |= BIT_13;\r\nif (ha->flags.enable_led_scheme)\r\nha->fw_options[2] |= BIT_12;\r\nif (IS_QLA6312(ha))\r\nha->fw_options[2] |= BIT_13;\r\nqla2x00_set_fw_options(vha, ha->fw_options);\r\n}\r\nvoid\r\nqla24xx_update_fw_options(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_P3P_TYPE(ha))\r\nreturn;\r\nif (ql2xfwholdabts)\r\nha->fw_options[3] |= BIT_12;\r\nif ((le16_to_cpu(ha->fw_seriallink_options24[0]) & BIT_0) == 0)\r\nreturn;\r\nrval = qla2x00_set_serdes_params(vha,\r\nle16_to_cpu(ha->fw_seriallink_options24[1]),\r\nle16_to_cpu(ha->fw_seriallink_options24[2]),\r\nle16_to_cpu(ha->fw_seriallink_options24[3]));\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x0104,\r\n"Unable to update Serial Link options (%x).\n", rval);\r\n}\r\n}\r\nvoid\r\nqla2x00_config_rings(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\nha->init_cb->request_q_outpointer = cpu_to_le16(0);\r\nha->init_cb->response_q_inpointer = cpu_to_le16(0);\r\nha->init_cb->request_q_length = cpu_to_le16(req->length);\r\nha->init_cb->response_q_length = cpu_to_le16(rsp->length);\r\nha->init_cb->request_q_address[0] = cpu_to_le32(LSD(req->dma));\r\nha->init_cb->request_q_address[1] = cpu_to_le32(MSD(req->dma));\r\nha->init_cb->response_q_address[0] = cpu_to_le32(LSD(rsp->dma));\r\nha->init_cb->response_q_address[1] = cpu_to_le32(MSD(rsp->dma));\r\nWRT_REG_WORD(ISP_REQ_Q_IN(ha, reg), 0);\r\nWRT_REG_WORD(ISP_REQ_Q_OUT(ha, reg), 0);\r\nWRT_REG_WORD(ISP_RSP_Q_IN(ha, reg), 0);\r\nWRT_REG_WORD(ISP_RSP_Q_OUT(ha, reg), 0);\r\nRD_REG_WORD(ISP_RSP_Q_OUT(ha, reg));\r\n}\r\nvoid\r\nqla24xx_config_rings(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\ndevice_reg_t *reg = ISP_QUE_REG(ha, 0);\r\nstruct device_reg_2xxx __iomem *ioreg = &ha->iobase->isp;\r\nstruct qla_msix_entry *msix;\r\nstruct init_cb_24xx *icb;\r\nuint16_t rid = 0;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\nicb = (struct init_cb_24xx *)ha->init_cb;\r\nicb->request_q_outpointer = cpu_to_le16(0);\r\nicb->response_q_inpointer = cpu_to_le16(0);\r\nicb->request_q_length = cpu_to_le16(req->length);\r\nicb->response_q_length = cpu_to_le16(rsp->length);\r\nicb->request_q_address[0] = cpu_to_le32(LSD(req->dma));\r\nicb->request_q_address[1] = cpu_to_le32(MSD(req->dma));\r\nicb->response_q_address[0] = cpu_to_le32(LSD(rsp->dma));\r\nicb->response_q_address[1] = cpu_to_le32(MSD(rsp->dma));\r\nicb->atio_q_inpointer = cpu_to_le16(0);\r\nicb->atio_q_length = cpu_to_le16(ha->tgt.atio_q_length);\r\nicb->atio_q_address[0] = cpu_to_le32(LSD(ha->tgt.atio_dma));\r\nicb->atio_q_address[1] = cpu_to_le32(MSD(ha->tgt.atio_dma));\r\nif (IS_SHADOW_REG_CAPABLE(ha))\r\nicb->firmware_options_2 |= cpu_to_le32(BIT_30|BIT_29);\r\nif (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha)) {\r\nicb->qos = cpu_to_le16(QLA_DEFAULT_QUE_QOS);\r\nicb->rid = cpu_to_le16(rid);\r\nif (ha->flags.msix_enabled) {\r\nmsix = &ha->msix_entries[1];\r\nql_dbg(ql_dbg_init, vha, 0x00fd,\r\n"Registering vector 0x%x for base que.\n",\r\nmsix->entry);\r\nicb->msix = cpu_to_le16(msix->entry);\r\n}\r\nif (MSB(rid))\r\nicb->firmware_options_2 |= cpu_to_le32(BIT_19);\r\nif (LSB(rid))\r\nicb->firmware_options_2 |= cpu_to_le32(BIT_18);\r\nif ((ha->fw_attributes & BIT_6) && (IS_MSIX_NACK_CAPABLE(ha)) &&\r\n(ha->flags.msix_enabled)) {\r\nicb->firmware_options_2 &= cpu_to_le32(~BIT_22);\r\nha->flags.disable_msix_handshake = 1;\r\nql_dbg(ql_dbg_init, vha, 0x00fe,\r\n"MSIX Handshake Disable Mode turned on.\n");\r\n} else {\r\nicb->firmware_options_2 |= cpu_to_le32(BIT_22);\r\n}\r\nicb->firmware_options_2 |= cpu_to_le32(BIT_23);\r\nWRT_REG_DWORD(&reg->isp25mq.req_q_in, 0);\r\nWRT_REG_DWORD(&reg->isp25mq.req_q_out, 0);\r\nWRT_REG_DWORD(&reg->isp25mq.rsp_q_in, 0);\r\nWRT_REG_DWORD(&reg->isp25mq.rsp_q_out, 0);\r\n} else {\r\nWRT_REG_DWORD(&reg->isp24.req_q_in, 0);\r\nWRT_REG_DWORD(&reg->isp24.req_q_out, 0);\r\nWRT_REG_DWORD(&reg->isp24.rsp_q_in, 0);\r\nWRT_REG_DWORD(&reg->isp24.rsp_q_out, 0);\r\n}\r\nqlt_24xx_config_rings(vha);\r\nRD_REG_DWORD(&ioreg->hccr);\r\n}\r\nint\r\nqla2x00_init_rings(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nunsigned long flags = 0;\r\nint cnt, que;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nstruct mid_init_cb_24xx *mid_init_cb =\r\n(struct mid_init_cb_24xx *) ha->init_cb;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (que = 0; que < ha->max_req_queues; que++) {\r\nreq = ha->req_q_map[que];\r\nif (!req || !test_bit(que, ha->req_qid_map))\r\ncontinue;\r\nreq->out_ptr = (void *)(req->ring + req->length);\r\n*req->out_ptr = 0;\r\nfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++)\r\nreq->outstanding_cmds[cnt] = NULL;\r\nreq->current_outstanding_cmd = 1;\r\nreq->ring_ptr = req->ring;\r\nreq->ring_index = 0;\r\nreq->cnt = req->length;\r\n}\r\nfor (que = 0; que < ha->max_rsp_queues; que++) {\r\nrsp = ha->rsp_q_map[que];\r\nif (!rsp || !test_bit(que, ha->rsp_qid_map))\r\ncontinue;\r\nrsp->in_ptr = (void *)(rsp->ring + rsp->length);\r\n*rsp->in_ptr = 0;\r\nif (IS_QLAFX00(ha))\r\nqlafx00_init_response_q_entries(rsp);\r\nelse\r\nqla2x00_init_response_q_entries(rsp);\r\n}\r\nha->tgt.atio_ring_ptr = ha->tgt.atio_ring;\r\nha->tgt.atio_ring_index = 0;\r\nqlt_init_atio_q_entries(vha);\r\nha->isp_ops->config_rings(vha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nql_dbg(ql_dbg_init, vha, 0x00d1, "Issue init firmware.\n");\r\nif (IS_QLAFX00(ha)) {\r\nrval = qlafx00_init_firmware(vha, ha->init_cb_size);\r\ngoto next_check;\r\n}\r\nha->isp_ops->update_fw_options(vha);\r\nif (ha->flags.npiv_supported) {\r\nif (ha->operating_mode == LOOP && !IS_CNA_CAPABLE(ha))\r\nha->max_npiv_vports = MIN_MULTI_ID_FABRIC - 1;\r\nmid_init_cb->count = cpu_to_le16(ha->max_npiv_vports);\r\n}\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nmid_init_cb->options = cpu_to_le16(BIT_1);\r\nmid_init_cb->init_cb.execution_throttle =\r\ncpu_to_le16(ha->cur_fw_xcb_count);\r\nif (IS_DPORT_CAPABLE(ha))\r\nmid_init_cb->init_cb.firmware_options_1 |=\r\ncpu_to_le16(BIT_7);\r\nha->flags.fawwpn_enabled =\r\n(mid_init_cb->init_cb.firmware_options_1 & BIT_6) ? 1 : 0;\r\nql_dbg(ql_dbg_init, vha, 0x0141, "FA-WWPN Support: %s.\n",\r\n(ha->flags.fawwpn_enabled) ? "enabled" : "disabled");\r\n}\r\nrval = qla2x00_init_firmware(vha, ha->init_cb_size);\r\nnext_check:\r\nif (rval) {\r\nql_log(ql_log_fatal, vha, 0x00d2,\r\n"Init Firmware **** FAILED ****.\n");\r\n} else {\r\nql_dbg(ql_dbg_init, vha, 0x00d3,\r\n"Init Firmware -- success.\n");\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_fw_ready(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nunsigned long wtime, mtime, cs84xx_time;\r\nuint16_t min_wait;\r\nuint16_t wait_time;\r\nuint16_t state[6];\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLAFX00(vha->hw))\r\nreturn qlafx00_fw_ready(vha);\r\nrval = QLA_SUCCESS;\r\nif (IS_P3P_TYPE(ha))\r\nmin_wait = 30;\r\nelse\r\nmin_wait = 20;\r\nif ((wait_time = (ha->retry_count*ha->login_timeout) + 5) < min_wait) {\r\nwait_time = min_wait;\r\n}\r\nmtime = jiffies + (min_wait * HZ);\r\nwtime = jiffies + (wait_time * HZ);\r\nif (!vha->flags.init_done)\r\nql_log(ql_log_info, vha, 0x801e,\r\n"Waiting for LIP to complete.\n");\r\ndo {\r\nmemset(state, -1, sizeof(state));\r\nrval = qla2x00_get_firmware_state(vha, state);\r\nif (rval == QLA_SUCCESS) {\r\nif (state[0] < FSTATE_LOSS_OF_SYNC) {\r\nvha->device_flags &= ~DFLG_NO_CABLE;\r\n}\r\nif (IS_QLA84XX(ha) && state[0] != FSTATE_READY) {\r\nql_dbg(ql_dbg_taskm, vha, 0x801f,\r\n"fw_state=%x 84xx=%x.\n", state[0],\r\nstate[2]);\r\nif ((state[2] & FSTATE_LOGGED_IN) &&\r\n(state[2] & FSTATE_WAITING_FOR_VERIFY)) {\r\nql_dbg(ql_dbg_taskm, vha, 0x8028,\r\n"Sending verify iocb.\n");\r\ncs84xx_time = jiffies;\r\nrval = qla84xx_init_chip(vha);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn,\r\nvha, 0x8007,\r\n"Init chip failed.\n");\r\nbreak;\r\n}\r\ncs84xx_time = jiffies - cs84xx_time;\r\nwtime += cs84xx_time;\r\nmtime += cs84xx_time;\r\nql_dbg(ql_dbg_taskm, vha, 0x8008,\r\n"Increasing wait time by %ld. "\r\n"New time %ld.\n", cs84xx_time,\r\nwtime);\r\n}\r\n} else if (state[0] == FSTATE_READY) {\r\nql_dbg(ql_dbg_taskm, vha, 0x8037,\r\n"F/W Ready - OK.\n");\r\nqla2x00_get_retry_cnt(vha, &ha->retry_count,\r\n&ha->login_timeout, &ha->r_a_tov);\r\nrval = QLA_SUCCESS;\r\nbreak;\r\n}\r\nrval = QLA_FUNCTION_FAILED;\r\nif (atomic_read(&vha->loop_down_timer) &&\r\nstate[0] != FSTATE_READY) {\r\nif (time_after_eq(jiffies, mtime)) {\r\nql_log(ql_log_info, vha, 0x8038,\r\n"Cable is unplugged...\n");\r\nvha->device_flags |= DFLG_NO_CABLE;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nif (time_after_eq(jiffies, mtime) ||\r\nha->flags.isp82xx_fw_hung)\r\nbreak;\r\n}\r\nif (time_after_eq(jiffies, wtime))\r\nbreak;\r\nmsleep(500);\r\n} while (1);\r\nql_dbg(ql_dbg_taskm, vha, 0x803a,\r\n"fw_state=%x (%x, %x, %x, %x %x) curr time=%lx.\n", state[0],\r\nstate[1], state[2], state[3], state[4], state[5], jiffies);\r\nif (rval && !(vha->device_flags & DFLG_NO_CABLE)) {\r\nql_log(ql_log_warn, vha, 0x803b,\r\n"Firmware ready **** FAILED ****.\n");\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_configure_hba(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint16_t loop_id;\r\nuint16_t topo;\r\nuint16_t sw_cap;\r\nuint8_t al_pa;\r\nuint8_t area;\r\nuint8_t domain;\r\nchar connect_type[22];\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long flags;\r\nscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\r\nrval = qla2x00_get_adapter_id(vha,\r\n&loop_id, &al_pa, &area, &domain, &topo, &sw_cap);\r\nif (rval != QLA_SUCCESS) {\r\nif (LOOP_TRANSITION(vha) || atomic_read(&ha->loop_down_timer) ||\r\nIS_CNA_CAPABLE(ha) ||\r\n(rval == QLA_COMMAND_ERROR && loop_id == 0x7)) {\r\nql_dbg(ql_dbg_disc, vha, 0x2008,\r\n"Loop is in a transition state.\n");\r\n} else {\r\nql_log(ql_log_warn, vha, 0x2009,\r\n"Unable to get host loop ID.\n");\r\nif (IS_FWI2_CAPABLE(ha) && (vha == base_vha) &&\r\n(rval == QLA_COMMAND_ERROR && loop_id == 0x1b)) {\r\nql_log(ql_log_warn, vha, 0x1151,\r\n"Doing link init.\n");\r\nif (qla24xx_link_initialize(vha) == QLA_SUCCESS)\r\nreturn rval;\r\n}\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\n}\r\nreturn (rval);\r\n}\r\nif (topo == 4) {\r\nql_log(ql_log_info, vha, 0x200a,\r\n"Cannot get topology - retrying.\n");\r\nreturn (QLA_FUNCTION_FAILED);\r\n}\r\nvha->loop_id = loop_id;\r\nha->min_external_loopid = SNS_FIRST_LOOP_ID;\r\nha->operating_mode = LOOP;\r\nha->switch_cap = 0;\r\nswitch (topo) {\r\ncase 0:\r\nql_dbg(ql_dbg_disc, vha, 0x200b, "HBA in NL topology.\n");\r\nha->current_topology = ISP_CFG_NL;\r\nstrcpy(connect_type, "(Loop)");\r\nbreak;\r\ncase 1:\r\nql_dbg(ql_dbg_disc, vha, 0x200c, "HBA in FL topology.\n");\r\nha->switch_cap = sw_cap;\r\nha->current_topology = ISP_CFG_FL;\r\nstrcpy(connect_type, "(FL_Port)");\r\nbreak;\r\ncase 2:\r\nql_dbg(ql_dbg_disc, vha, 0x200d, "HBA in N P2P topology.\n");\r\nha->operating_mode = P2P;\r\nha->current_topology = ISP_CFG_N;\r\nstrcpy(connect_type, "(N_Port-to-N_Port)");\r\nbreak;\r\ncase 3:\r\nql_dbg(ql_dbg_disc, vha, 0x200e, "HBA in F P2P topology.\n");\r\nha->switch_cap = sw_cap;\r\nha->operating_mode = P2P;\r\nha->current_topology = ISP_CFG_F;\r\nstrcpy(connect_type, "(F_Port)");\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_disc, vha, 0x200f,\r\n"HBA in unknown topology %x, using NL.\n", topo);\r\nha->current_topology = ISP_CFG_NL;\r\nstrcpy(connect_type, "(Loop)");\r\nbreak;\r\n}\r\nvha->d_id.b.domain = domain;\r\nvha->d_id.b.area = area;\r\nvha->d_id.b.al_pa = al_pa;\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\nqlt_update_vp_map(vha, SET_AL_PA);\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nif (!vha->flags.init_done)\r\nql_log(ql_log_info, vha, 0x2010,\r\n"Topology - %s, Host Loop address 0x%x.\n",\r\nconnect_type, vha->loop_id);\r\nreturn(rval);\r\n}\r\ninline void\r\nqla2x00_set_model_info(scsi_qla_host_t *vha, uint8_t *model, size_t len,\r\nchar *def)\r\n{\r\nchar *st, *en;\r\nuint16_t index;\r\nstruct qla_hw_data *ha = vha->hw;\r\nint use_tbl = !IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&\r\n!IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha);\r\nif (memcmp(model, BINZERO, len) != 0) {\r\nstrncpy(ha->model_number, model, len);\r\nst = en = ha->model_number;\r\nen += len - 1;\r\nwhile (en > st) {\r\nif (*en != 0x20 && *en != 0x00)\r\nbreak;\r\n*en-- = '\0';\r\n}\r\nindex = (ha->pdev->subsystem_device & 0xff);\r\nif (use_tbl &&\r\nha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\r\nindex < QLA_MODEL_NAMES)\r\nstrncpy(ha->model_desc,\r\nqla2x00_model_name[index * 2 + 1],\r\nsizeof(ha->model_desc) - 1);\r\n} else {\r\nindex = (ha->pdev->subsystem_device & 0xff);\r\nif (use_tbl &&\r\nha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\r\nindex < QLA_MODEL_NAMES) {\r\nstrcpy(ha->model_number,\r\nqla2x00_model_name[index * 2]);\r\nstrncpy(ha->model_desc,\r\nqla2x00_model_name[index * 2 + 1],\r\nsizeof(ha->model_desc) - 1);\r\n} else {\r\nstrcpy(ha->model_number, def);\r\n}\r\n}\r\nif (IS_FWI2_CAPABLE(ha))\r\nqla2xxx_get_vpd_field(vha, "\x82", ha->model_desc,\r\nsizeof(ha->model_desc));\r\n}\r\nstatic void qla2xxx_nvram_wwn_from_ofw(scsi_qla_host_t *vha, nvram_t *nv)\r\n{\r\n#ifdef CONFIG_SPARC\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct pci_dev *pdev = ha->pdev;\r\nstruct device_node *dp = pci_device_to_OF_node(pdev);\r\nconst u8 *val;\r\nint len;\r\nval = of_get_property(dp, "port-wwn", &len);\r\nif (val && len >= WWN_SIZE)\r\nmemcpy(nv->port_name, val, WWN_SIZE);\r\nval = of_get_property(dp, "node-wwn", &len);\r\nif (val && len >= WWN_SIZE)\r\nmemcpy(nv->node_name, val, WWN_SIZE);\r\n#endif\r\n}\r\nint\r\nqla2x00_nvram_config(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint8_t chksum = 0;\r\nuint16_t cnt;\r\nuint8_t *dptr1, *dptr2;\r\nstruct qla_hw_data *ha = vha->hw;\r\ninit_cb_t *icb = ha->init_cb;\r\nnvram_t *nv = ha->nvram;\r\nuint8_t *ptr = ha->nvram;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nrval = QLA_SUCCESS;\r\nha->nvram_size = sizeof(nvram_t);\r\nha->nvram_base = 0;\r\nif (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha))\r\nif ((RD_REG_WORD(&reg->ctrl_status) >> 14) == 1)\r\nha->nvram_base = 0x80;\r\nha->isp_ops->read_nvram(vha, ptr, ha->nvram_base, ha->nvram_size);\r\nfor (cnt = 0, chksum = 0; cnt < ha->nvram_size; cnt++)\r\nchksum += *ptr++;\r\nql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x010f,\r\n"Contents of NVRAM.\n");\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0110,\r\n(uint8_t *)nv, ha->nvram_size);\r\nif (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' ||\r\nnv->id[2] != 'P' || nv->id[3] != ' ' || nv->nvram_version < 1) {\r\nql_log(ql_log_warn, vha, 0x0064,\r\n"Inconsistent NVRAM "\r\n"detected: checksum=0x%x id=%c version=0x%x.\n",\r\nchksum, nv->id[0], nv->nvram_version);\r\nql_log(ql_log_warn, vha, 0x0065,\r\n"Falling back to "\r\n"functioning (yet invalid -- WWPN) defaults.\n");\r\nmemset(nv, 0, ha->nvram_size);\r\nnv->parameter_block_version = ICB_VERSION;\r\nif (IS_QLA23XX(ha)) {\r\nnv->firmware_options[0] = BIT_2 | BIT_1;\r\nnv->firmware_options[1] = BIT_7 | BIT_5;\r\nnv->add_firmware_options[0] = BIT_5;\r\nnv->add_firmware_options[1] = BIT_5 | BIT_4;\r\nnv->frame_payload_size = 2048;\r\nnv->special_options[1] = BIT_7;\r\n} else if (IS_QLA2200(ha)) {\r\nnv->firmware_options[0] = BIT_2 | BIT_1;\r\nnv->firmware_options[1] = BIT_7 | BIT_5;\r\nnv->add_firmware_options[0] = BIT_5;\r\nnv->add_firmware_options[1] = BIT_5 | BIT_4;\r\nnv->frame_payload_size = 1024;\r\n} else if (IS_QLA2100(ha)) {\r\nnv->firmware_options[0] = BIT_3 | BIT_1;\r\nnv->firmware_options[1] = BIT_5;\r\nnv->frame_payload_size = 1024;\r\n}\r\nnv->max_iocb_allocation = cpu_to_le16(256);\r\nnv->execution_throttle = cpu_to_le16(16);\r\nnv->retry_count = 8;\r\nnv->retry_delay = 1;\r\nnv->port_name[0] = 33;\r\nnv->port_name[3] = 224;\r\nnv->port_name[4] = 139;\r\nqla2xxx_nvram_wwn_from_ofw(vha, nv);\r\nnv->login_timeout = 4;\r\nnv->host_p[1] = BIT_2;\r\nnv->reset_delay = 5;\r\nnv->port_down_retry_count = 8;\r\nnv->max_luns_per_target = cpu_to_le16(8);\r\nnv->link_down_timeout = 60;\r\nrval = 1;\r\n}\r\n#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)\r\nif (ia64_platform_is("sn2")) {\r\nnv->frame_payload_size = 2048;\r\nif (IS_QLA23XX(ha))\r\nnv->special_options[1] = BIT_7;\r\n}\r\n#endif\r\nmemset(icb, 0, ha->init_cb_size);\r\nnv->firmware_options[0] |= (BIT_6 | BIT_1);\r\nnv->firmware_options[0] &= ~(BIT_5 | BIT_4);\r\nnv->firmware_options[1] |= (BIT_5 | BIT_0);\r\nnv->firmware_options[1] &= ~BIT_4;\r\nif (IS_QLA23XX(ha)) {\r\nnv->firmware_options[0] |= BIT_2;\r\nnv->firmware_options[0] &= ~BIT_3;\r\nnv->special_options[0] &= ~BIT_6;\r\nnv->add_firmware_options[1] |= BIT_5 | BIT_4;\r\nif (IS_QLA2300(ha)) {\r\nif (ha->fb_rev == FPM_2310) {\r\nstrcpy(ha->model_number, "QLA2310");\r\n} else {\r\nstrcpy(ha->model_number, "QLA2300");\r\n}\r\n} else {\r\nqla2x00_set_model_info(vha, nv->model_number,\r\nsizeof(nv->model_number), "QLA23xx");\r\n}\r\n} else if (IS_QLA2200(ha)) {\r\nnv->firmware_options[0] |= BIT_2;\r\nif ((nv->add_firmware_options[0] & (BIT_6 | BIT_5 | BIT_4)) ==\r\n(BIT_5 | BIT_4)) {\r\nnv->add_firmware_options[0] &= ~(BIT_6 | BIT_5 | BIT_4);\r\nnv->add_firmware_options[0] |= BIT_5;\r\n}\r\nstrcpy(ha->model_number, "QLA22xx");\r\n} else {\r\nstrcpy(ha->model_number, "QLA2100");\r\n}\r\ndptr1 = (uint8_t *)icb;\r\ndptr2 = (uint8_t *)&nv->parameter_block_version;\r\ncnt = (uint8_t *)&icb->request_q_outpointer - (uint8_t *)&icb->version;\r\nwhile (cnt--)\r\n*dptr1++ = *dptr2++;\r\ndptr1 = (uint8_t *)icb->add_firmware_options;\r\ncnt = (uint8_t *)icb->reserved_3 - (uint8_t *)icb->add_firmware_options;\r\nwhile (cnt--)\r\n*dptr1++ = *dptr2++;\r\nif (nv->host_p[1] & BIT_7) {\r\nmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\r\nmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\r\n}\r\nif ((icb->firmware_options[1] & BIT_6) == 0) {\r\nmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\r\nicb->node_name[0] &= 0xF0;\r\n}\r\nif (nv->host_p[0] & BIT_7)\r\nql2xextended_error_logging = QL_DBG_DEFAULT1_MASK;\r\nha->flags.disable_risc_code_load = ((nv->host_p[0] & BIT_4) ? 1 : 0);\r\nif (!IS_QLA2100(ha) && !IS_QLA2200(ha))\r\nha->flags.disable_risc_code_load = 0;\r\nha->flags.enable_lip_reset = ((nv->host_p[1] & BIT_1) ? 1 : 0);\r\nha->flags.enable_lip_full_login = ((nv->host_p[1] & BIT_2) ? 1 : 0);\r\nha->flags.enable_target_reset = ((nv->host_p[1] & BIT_3) ? 1 : 0);\r\nha->flags.enable_led_scheme = (nv->special_options[1] & BIT_4) ? 1 : 0;\r\nha->flags.disable_serdes = 0;\r\nha->operating_mode =\r\n(icb->add_firmware_options[0] & (BIT_6 | BIT_5 | BIT_4)) >> 4;\r\nmemcpy(ha->fw_seriallink_options, nv->seriallink_options,\r\nsizeof(ha->fw_seriallink_options));\r\nha->serial0 = icb->port_name[5];\r\nha->serial1 = icb->port_name[6];\r\nha->serial2 = icb->port_name[7];\r\nmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\r\nmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\r\nicb->execution_throttle = cpu_to_le16(0xFFFF);\r\nha->retry_count = nv->retry_count;\r\nif (nv->login_timeout != ql2xlogintimeout)\r\nnv->login_timeout = ql2xlogintimeout;\r\nif (nv->login_timeout < 4)\r\nnv->login_timeout = 4;\r\nha->login_timeout = nv->login_timeout;\r\nha->r_a_tov = 100;\r\nha->loop_reset_delay = nv->reset_delay;\r\nif (nv->link_down_timeout == 0) {\r\nha->loop_down_abort_time =\r\n(LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\r\n} else {\r\nha->link_down_timeout = nv->link_down_timeout;\r\nha->loop_down_abort_time =\r\n(LOOP_DOWN_TIME - ha->link_down_timeout);\r\n}\r\nha->port_down_retry_count = nv->port_down_retry_count;\r\nif (qlport_down_retry)\r\nha->port_down_retry_count = qlport_down_retry;\r\nha->login_retry_count = nv->retry_count;\r\nif (ha->port_down_retry_count == nv->port_down_retry_count &&\r\nha->port_down_retry_count > 3)\r\nha->login_retry_count = ha->port_down_retry_count;\r\nelse if (ha->port_down_retry_count > (int)ha->login_retry_count)\r\nha->login_retry_count = ha->port_down_retry_count;\r\nif (ql2xloginretrycount)\r\nha->login_retry_count = ql2xloginretrycount;\r\nicb->lun_enables = cpu_to_le16(0);\r\nicb->command_resource_count = 0;\r\nicb->immediate_notify_resource_count = 0;\r\nicb->timeout = cpu_to_le16(0);\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\r\nicb->firmware_options[0] &= ~BIT_3;\r\nicb->add_firmware_options[0] &=\r\n~(BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nicb->add_firmware_options[0] |= BIT_2;\r\nicb->response_accumulation_timer = 3;\r\nicb->interrupt_delay_timer = 5;\r\nvha->flags.process_response_queue = 1;\r\n} else {\r\nif (!vha->flags.init_done) {\r\nha->zio_mode = icb->add_firmware_options[0] &\r\n(BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nha->zio_timer = icb->interrupt_delay_timer ?\r\nicb->interrupt_delay_timer: 2;\r\n}\r\nicb->add_firmware_options[0] &=\r\n~(BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nvha->flags.process_response_queue = 0;\r\nif (ha->zio_mode != QLA_ZIO_DISABLED) {\r\nha->zio_mode = QLA_ZIO_MODE_6;\r\nql_log(ql_log_info, vha, 0x0068,\r\n"ZIO mode %d enabled; timer delay (%d us).\n",\r\nha->zio_mode, ha->zio_timer * 100);\r\nicb->add_firmware_options[0] |= (uint8_t)ha->zio_mode;\r\nicb->interrupt_delay_timer = (uint8_t)ha->zio_timer;\r\nvha->flags.process_response_queue = 1;\r\n}\r\n}\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x0069,\r\n"NVRAM configuration failed.\n");\r\n}\r\nreturn (rval);\r\n}\r\nstatic void\r\nqla2x00_rport_del(void *data)\r\n{\r\nfc_port_t *fcport = data;\r\nstruct fc_rport *rport;\r\nunsigned long flags;\r\nspin_lock_irqsave(fcport->vha->host->host_lock, flags);\r\nrport = fcport->drport ? fcport->drport: fcport->rport;\r\nfcport->drport = NULL;\r\nspin_unlock_irqrestore(fcport->vha->host->host_lock, flags);\r\nif (rport)\r\nfc_remote_port_delete(rport);\r\n}\r\nfc_port_t *\r\nqla2x00_alloc_fcport(scsi_qla_host_t *vha, gfp_t flags)\r\n{\r\nfc_port_t *fcport;\r\nfcport = kzalloc(sizeof(fc_port_t), flags);\r\nif (!fcport)\r\nreturn NULL;\r\nfcport->vha = vha;\r\nfcport->port_type = FCT_UNKNOWN;\r\nfcport->loop_id = FC_NO_LOOP_ID;\r\nqla2x00_set_fcport_state(fcport, FCS_UNCONFIGURED);\r\nfcport->supported_classes = FC_COS_UNSPECIFIED;\r\nreturn fcport;\r\n}\r\nstatic int\r\nqla2x00_configure_loop(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nunsigned long flags, save_flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = QLA_SUCCESS;\r\nif (test_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags)) {\r\nrval = qla2x00_configure_hba(vha);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2013,\r\n"Unable to configure HBA.\n");\r\nreturn (rval);\r\n}\r\n}\r\nsave_flags = flags = vha->dpc_flags;\r\nql_dbg(ql_dbg_disc, vha, 0x2014,\r\n"Configure loop -- dpc flags = 0x%lx.\n", flags);\r\nclear_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\r\nclear_bit(RSCN_UPDATE, &vha->dpc_flags);\r\nqla2x00_get_data_rate(vha);\r\nif (ha->current_topology == ISP_CFG_FL &&\r\n(test_bit(LOCAL_LOOP_UPDATE, &flags))) {\r\nset_bit(RSCN_UPDATE, &flags);\r\n} else if (ha->current_topology == ISP_CFG_F &&\r\n(test_bit(LOCAL_LOOP_UPDATE, &flags))) {\r\nset_bit(RSCN_UPDATE, &flags);\r\nclear_bit(LOCAL_LOOP_UPDATE, &flags);\r\n} else if (ha->current_topology == ISP_CFG_N) {\r\nclear_bit(RSCN_UPDATE, &flags);\r\n} else if (!vha->flags.online ||\r\n(test_bit(ABORT_ISP_ACTIVE, &flags))) {\r\nset_bit(RSCN_UPDATE, &flags);\r\nset_bit(LOCAL_LOOP_UPDATE, &flags);\r\n}\r\nif (test_bit(LOCAL_LOOP_UPDATE, &flags)) {\r\nif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\r\nql_dbg(ql_dbg_disc, vha, 0x2015,\r\n"Loop resync needed, failing.\n");\r\nrval = QLA_FUNCTION_FAILED;\r\n} else\r\nrval = qla2x00_configure_local_loop(vha);\r\n}\r\nif (rval == QLA_SUCCESS && test_bit(RSCN_UPDATE, &flags)) {\r\nif (LOOP_TRANSITION(vha)) {\r\nql_dbg(ql_dbg_disc, vha, 0x201e,\r\n"Needs RSCN update and loop transition.\n");\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\nelse\r\nrval = qla2x00_configure_fabric(vha);\r\n}\r\nif (rval == QLA_SUCCESS) {\r\nif (atomic_read(&vha->loop_down_timer) ||\r\ntest_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\natomic_set(&vha->loop_state, LOOP_READY);\r\nql_dbg(ql_dbg_disc, vha, 0x2069,\r\n"LOOP READY.\n");\r\nif (qla_tgt_mode_enabled(vha)) {\r\nif (IS_QLA27XX(ha) || IS_QLA83XX(ha)) {\r\nspin_lock_irqsave(&ha->tgt.atio_lock,\r\nflags);\r\nqlt_24xx_process_atio_queue(vha, 0);\r\nspin_unlock_irqrestore(\r\n&ha->tgt.atio_lock, flags);\r\n} else {\r\nspin_lock_irqsave(&ha->hardware_lock,\r\nflags);\r\nqlt_24xx_process_atio_queue(vha, 1);\r\nspin_unlock_irqrestore(\r\n&ha->hardware_lock, flags);\r\n}\r\n}\r\n}\r\n}\r\nif (rval) {\r\nql_dbg(ql_dbg_disc, vha, 0x206a,\r\n"%s *** FAILED ***.\n", __func__);\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x206b,\r\n"%s: exiting normally.\n", __func__);\r\n}\r\nif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\r\nif (test_bit(LOCAL_LOOP_UPDATE, &save_flags))\r\nset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\r\nif (test_bit(RSCN_UPDATE, &save_flags)) {\r\nset_bit(RSCN_UPDATE, &vha->dpc_flags);\r\n}\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_configure_local_loop(scsi_qla_host_t *vha)\r\n{\r\nint rval, rval2;\r\nint found_devs;\r\nint found;\r\nfc_port_t *fcport, *new_fcport;\r\nuint16_t index;\r\nuint16_t entries;\r\nchar *id_iter;\r\nuint16_t loop_id;\r\nuint8_t domain, area, al_pa;\r\nstruct qla_hw_data *ha = vha->hw;\r\nfound_devs = 0;\r\nnew_fcport = NULL;\r\nentries = MAX_FIBRE_DEVICES_LOOP;\r\nmemset(ha->gid_list, 0, qla2x00_gid_list_size(ha));\r\nrval = qla2x00_get_id_list(vha, ha->gid_list, ha->gid_list_dma,\r\n&entries);\r\nif (rval != QLA_SUCCESS)\r\ngoto cleanup_allocation;\r\nql_dbg(ql_dbg_disc, vha, 0x2017,\r\n"Entries in ID list (%d).\n", entries);\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2075,\r\n(uint8_t *)ha->gid_list,\r\nentries * sizeof(struct gid_list_info));\r\nnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (new_fcport == NULL) {\r\nql_log(ql_log_warn, vha, 0x2018,\r\n"Memory allocation failed for fcport.\n");\r\nrval = QLA_MEMORY_ALLOC_FAILED;\r\ngoto cleanup_allocation;\r\n}\r\nnew_fcport->flags &= ~FCF_FABRIC_DEVICE;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (atomic_read(&fcport->state) == FCS_ONLINE &&\r\nfcport->port_type != FCT_BROADCAST &&\r\n(fcport->flags & FCF_FABRIC_DEVICE) == 0) {\r\nql_dbg(ql_dbg_disc, vha, 0x2019,\r\n"Marking port lost loop_id=0x%04x.\n",\r\nfcport->loop_id);\r\nqla2x00_set_fcport_state(fcport, FCS_DEVICE_LOST);\r\n}\r\n}\r\nid_iter = (char *)ha->gid_list;\r\nfor (index = 0; index < entries; index++) {\r\ndomain = ((struct gid_list_info *)id_iter)->domain;\r\narea = ((struct gid_list_info *)id_iter)->area;\r\nal_pa = ((struct gid_list_info *)id_iter)->al_pa;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nloop_id = (uint16_t)\r\n((struct gid_list_info *)id_iter)->loop_id_2100;\r\nelse\r\nloop_id = le16_to_cpu(\r\n((struct gid_list_info *)id_iter)->loop_id);\r\nid_iter += ha->gid_list_info_size;\r\nif ((domain & 0xf0) == 0xf0)\r\ncontinue;\r\nif (area && domain &&\r\n(area != vha->d_id.b.area || domain != vha->d_id.b.domain))\r\ncontinue;\r\nif (loop_id > LAST_LOCAL_LOOP_ID)\r\ncontinue;\r\nmemset(new_fcport, 0, sizeof(fc_port_t));\r\nnew_fcport->d_id.b.domain = domain;\r\nnew_fcport->d_id.b.area = area;\r\nnew_fcport->d_id.b.al_pa = al_pa;\r\nnew_fcport->loop_id = loop_id;\r\nrval2 = qla2x00_get_port_database(vha, new_fcport, 0);\r\nif (rval2 != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x201a,\r\n"Failed to retrieve fcport information "\r\n"-- get_port_database=%x, loop_id=0x%04x.\n",\r\nrval2, new_fcport->loop_id);\r\nql_dbg(ql_dbg_disc, vha, 0x201b,\r\n"Scheduling resync.\n");\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\ncontinue;\r\n}\r\nfound = 0;\r\nfcport = NULL;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (memcmp(new_fcport->port_name, fcport->port_name,\r\nWWN_SIZE))\r\ncontinue;\r\nfcport->flags &= ~FCF_FABRIC_DEVICE;\r\nfcport->loop_id = new_fcport->loop_id;\r\nfcport->port_type = new_fcport->port_type;\r\nfcport->d_id.b24 = new_fcport->d_id.b24;\r\nmemcpy(fcport->node_name, new_fcport->node_name,\r\nWWN_SIZE);\r\nfound++;\r\nbreak;\r\n}\r\nif (!found) {\r\nlist_add_tail(&new_fcport->list, &vha->vp_fcports);\r\nfcport = new_fcport;\r\nnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (new_fcport == NULL) {\r\nql_log(ql_log_warn, vha, 0x201c,\r\n"Failed to allocate memory for fcport.\n");\r\nrval = QLA_MEMORY_ALLOC_FAILED;\r\ngoto cleanup_allocation;\r\n}\r\nnew_fcport->flags &= ~FCF_FABRIC_DEVICE;\r\n}\r\nfcport->fp_speed = ha->link_data_rate;\r\nqla2x00_update_fcport(vha, fcport);\r\nfound_devs++;\r\n}\r\ncleanup_allocation:\r\nkfree(new_fcport);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x201d,\r\n"Configure local loop error exit: rval=%x.\n", rval);\r\n}\r\nreturn (rval);\r\n}\r\nstatic void\r\nqla2x00_iidma_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nint rval;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_IIDMA_CAPABLE(ha))\r\nreturn;\r\nif (atomic_read(&fcport->state) != FCS_ONLINE)\r\nreturn;\r\nif (fcport->fp_speed == PORT_SPEED_UNKNOWN ||\r\nfcport->fp_speed > ha->link_data_rate)\r\nreturn;\r\nrval = qla2x00_set_idma_speed(vha, fcport->loop_id, fcport->fp_speed,\r\nmb);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x2004,\r\n"Unable to adjust iIDMA %8phN -- %04x %x %04x %04x.\n",\r\nfcport->port_name, rval, fcport->fp_speed, mb[0], mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2005,\r\n"iIDMA adjusted to %s GB/s on %8phN.\n",\r\nqla2x00_get_link_speed_str(ha, fcport->fp_speed),\r\nfcport->port_name);\r\n}\r\n}\r\nstatic void\r\nqla2x00_reg_remote_port(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nstruct fc_rport_identifiers rport_ids;\r\nstruct fc_rport *rport;\r\nunsigned long flags;\r\nrport_ids.node_name = wwn_to_u64(fcport->node_name);\r\nrport_ids.port_name = wwn_to_u64(fcport->port_name);\r\nrport_ids.port_id = fcport->d_id.b.domain << 16 |\r\nfcport->d_id.b.area << 8 | fcport->d_id.b.al_pa;\r\nrport_ids.roles = FC_RPORT_ROLE_UNKNOWN;\r\nfcport->rport = rport = fc_remote_port_add(vha->host, 0, &rport_ids);\r\nif (!rport) {\r\nql_log(ql_log_warn, vha, 0x2006,\r\n"Unable to allocate fc remote port.\n");\r\nreturn;\r\n}\r\nqlt_fc_port_added(vha, fcport);\r\nspin_lock_irqsave(fcport->vha->host->host_lock, flags);\r\n*((fc_port_t **)rport->dd_data) = fcport;\r\nspin_unlock_irqrestore(fcport->vha->host->host_lock, flags);\r\nrport->supported_classes = fcport->supported_classes;\r\nrport_ids.roles = FC_RPORT_ROLE_UNKNOWN;\r\nif (fcport->port_type == FCT_INITIATOR)\r\nrport_ids.roles |= FC_RPORT_ROLE_FCP_INITIATOR;\r\nif (fcport->port_type == FCT_TARGET)\r\nrport_ids.roles |= FC_RPORT_ROLE_FCP_TARGET;\r\nfc_remote_port_rolechg(rport, rport_ids.roles);\r\n}\r\nvoid\r\nqla2x00_update_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nfcport->vha = vha;\r\nif (IS_QLAFX00(vha->hw)) {\r\nqla2x00_set_fcport_state(fcport, FCS_ONLINE);\r\ngoto reg_port;\r\n}\r\nfcport->login_retry = 0;\r\nfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\r\nqla2x00_set_fcport_state(fcport, FCS_ONLINE);\r\nqla2x00_iidma_fcport(vha, fcport);\r\nqla24xx_update_fcport_fcp_prio(vha, fcport);\r\nreg_port:\r\nif (qla_ini_mode_enabled(vha))\r\nqla2x00_reg_remote_port(vha, fcport);\r\nelse {\r\nqlt_fc_port_added(vha, fcport);\r\n}\r\n}\r\nstatic int\r\nqla2x00_configure_fabric(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nfc_port_t *fcport, *fcptemp;\r\nuint16_t next_loopid;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nuint16_t loop_id;\r\nLIST_HEAD(new_fcports);\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nint discovery_gen;\r\nif (IS_FWI2_CAPABLE(ha))\r\nloop_id = NPH_F_PORT;\r\nelse\r\nloop_id = SNS_FL_PORT;\r\nrval = qla2x00_get_port_name(vha, loop_id, vha->fabric_node_name, 1);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_disc, vha, 0x201f,\r\n"MBX_GET_PORT_NAME failed, No FL Port.\n");\r\nvha->device_flags &= ~SWITCH_FOUND;\r\nreturn (QLA_SUCCESS);\r\n}\r\nvha->device_flags |= SWITCH_FOUND;\r\ndo {\r\nif (ql2xfdmienable &&\r\ntest_and_clear_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags))\r\nqla2x00_fdmi_register(vha);\r\nif (IS_FWI2_CAPABLE(ha))\r\nloop_id = NPH_SNS;\r\nelse\r\nloop_id = SIMPLE_NAME_SERVER;\r\nrval = ha->isp_ops->fabric_login(vha, loop_id, 0xff, 0xff,\r\n0xfc, mb, BIT_1|BIT_0);\r\nif (rval != QLA_SUCCESS) {\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nreturn rval;\r\n}\r\nif (mb[0] != MBS_COMMAND_COMPLETE) {\r\nql_dbg(ql_dbg_disc, vha, 0x2042,\r\n"Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x "\r\n"mb[6]=%x mb[7]=%x.\n", loop_id, mb[0], mb[1],\r\nmb[2], mb[6], mb[7]);\r\nreturn (QLA_SUCCESS);\r\n}\r\nif (test_and_clear_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags)) {\r\nif (qla2x00_rft_id(vha)) {\r\nql_dbg(ql_dbg_disc, vha, 0x2045,\r\n"Register FC-4 TYPE failed.\n");\r\n}\r\nif (qla2x00_rff_id(vha)) {\r\nql_dbg(ql_dbg_disc, vha, 0x2049,\r\n"Register FC-4 Features failed.\n");\r\n}\r\nif (qla2x00_rnn_id(vha)) {\r\nql_dbg(ql_dbg_disc, vha, 0x204f,\r\n"Register Node Name failed.\n");\r\n} else if (qla2x00_rsnn_nn(vha)) {\r\nql_dbg(ql_dbg_disc, vha, 0x2053,\r\n"Register Symobilic Node Name failed.\n");\r\n}\r\n}\r\n#define QLA_FCPORT_SCAN 1\r\n#define QLA_FCPORT_FOUND 2\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nfcport->scan_state = QLA_FCPORT_SCAN;\r\n}\r\nqlt_do_generation_tick(vha, &discovery_gen);\r\nrval = qla2x00_find_all_fabric_devs(vha, &new_fcports);\r\nif (rval != QLA_SUCCESS)\r\nbreak;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\r\nbreak;\r\nif ((fcport->flags & FCF_FABRIC_DEVICE) == 0)\r\ncontinue;\r\nif (fcport->scan_state == QLA_FCPORT_SCAN) {\r\nif (qla_ini_mode_enabled(base_vha) &&\r\natomic_read(&fcport->state) == FCS_ONLINE) {\r\nqla2x00_mark_device_lost(vha, fcport,\r\nql2xplogiabsentdevice, 0);\r\nif (fcport->loop_id != FC_NO_LOOP_ID &&\r\n(fcport->flags & FCF_FCP2_DEVICE) == 0 &&\r\nfcport->port_type != FCT_INITIATOR &&\r\nfcport->port_type != FCT_BROADCAST) {\r\nha->isp_ops->fabric_logout(vha,\r\nfcport->loop_id,\r\nfcport->d_id.b.domain,\r\nfcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nqla2x00_clear_loop_id(fcport);\r\n}\r\n} else if (!qla_ini_mode_enabled(base_vha)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf077,\r\n"port gone, logging out/killing session: "\r\n"%8phC state 0x%x flags 0x%x fc4_type 0x%x "\r\n"scan_state %d\n",\r\nfcport->port_name,\r\natomic_read(&fcport->state),\r\nfcport->flags, fcport->fc4_type,\r\nfcport->scan_state);\r\nqlt_fc_port_deleted(vha, fcport,\r\ndiscovery_gen);\r\n}\r\n}\r\n}\r\nnext_loopid = ha->min_external_loopid;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (atomic_read(&vha->loop_down_timer) ||\r\ntest_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\r\nbreak;\r\nif ((fcport->flags & FCF_FABRIC_DEVICE) == 0 ||\r\n(fcport->flags & FCF_LOGIN_NEEDED) == 0)\r\ncontinue;\r\nif (!qla_ini_mode_enabled(base_vha)) {\r\nif (fcport->scan_state == QLA_FCPORT_FOUND) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf078,\r\n"port %8phC state 0x%x flags 0x%x fc4_type 0x%x "\r\n"scan_state %d (initiator mode disabled; skipping "\r\n"login)\n", fcport->port_name,\r\natomic_read(&fcport->state),\r\nfcport->flags, fcport->fc4_type,\r\nfcport->scan_state);\r\n}\r\ncontinue;\r\n}\r\nif (fcport->loop_id == FC_NO_LOOP_ID) {\r\nfcport->loop_id = next_loopid;\r\nrval = qla2x00_find_new_loop_id(\r\nbase_vha, fcport);\r\nif (rval != QLA_SUCCESS) {\r\nbreak;\r\n}\r\n}\r\nqla2x00_fabric_dev_login(vha, fcport, &next_loopid);\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nbreak;\r\n}\r\nlist_for_each_entry_safe(fcport, fcptemp, &new_fcports, list) {\r\nif (atomic_read(&vha->loop_down_timer) ||\r\ntest_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\r\nbreak;\r\nif (qla_ini_mode_enabled(base_vha)) {\r\nfcport->loop_id = next_loopid;\r\nrval = qla2x00_find_new_loop_id(base_vha,\r\nfcport);\r\nif (rval != QLA_SUCCESS) {\r\nbreak;\r\n}\r\nqla2x00_fabric_dev_login(vha, fcport,\r\n&next_loopid);\r\n} else {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf079,\r\n"new port %8phC state 0x%x flags 0x%x fc4_type "\r\n"0x%x scan_state %d (initiator mode disabled; "\r\n"skipping login)\n",\r\nfcport->port_name,\r\natomic_read(&fcport->state),\r\nfcport->flags, fcport->fc4_type,\r\nfcport->scan_state);\r\n}\r\nlist_move_tail(&fcport->list, &vha->vp_fcports);\r\n}\r\n} while (0);\r\nlist_for_each_entry_safe(fcport, fcptemp, &new_fcports, list) {\r\nlist_del(&fcport->list);\r\nkfree(fcport);\r\n}\r\nif (rval) {\r\nql_dbg(ql_dbg_disc, vha, 0x2068,\r\n"Configure fabric error exit rval=%d.\n", rval);\r\n}\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_find_all_fabric_devs(scsi_qla_host_t *vha,\r\nstruct list_head *new_fcports)\r\n{\r\nint rval;\r\nuint16_t loop_id;\r\nfc_port_t *fcport, *new_fcport, *fcptemp;\r\nint found;\r\nsw_info_t *swl;\r\nint swl_idx;\r\nint first_dev, last_dev;\r\nport_id_t wrap = {}, nxt_d_id;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nrval = QLA_SUCCESS;\r\nif (!ha->swl)\r\nha->swl = kcalloc(ha->max_fibre_devices, sizeof(sw_info_t),\r\nGFP_KERNEL);\r\nswl = ha->swl;\r\nif (!swl) {\r\nql_dbg(ql_dbg_disc, vha, 0x2054,\r\n"GID_PT allocations failed, fallback on GA_NXT.\n");\r\n} else {\r\nmemset(swl, 0, ha->max_fibre_devices * sizeof(sw_info_t));\r\nif (qla2x00_gid_pt(vha, swl) != QLA_SUCCESS) {\r\nswl = NULL;\r\n} else if (qla2x00_gpn_id(vha, swl) != QLA_SUCCESS) {\r\nswl = NULL;\r\n} else if (qla2x00_gnn_id(vha, swl) != QLA_SUCCESS) {\r\nswl = NULL;\r\n} else if (ql2xiidmaenable &&\r\nqla2x00_gfpn_id(vha, swl) == QLA_SUCCESS) {\r\nqla2x00_gpsc(vha, swl);\r\n}\r\nif (swl)\r\nqla2x00_gff_id(vha, swl);\r\n}\r\nswl_idx = 0;\r\nnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (new_fcport == NULL) {\r\nql_log(ql_log_warn, vha, 0x205e,\r\n"Failed to allocate memory for fcport.\n");\r\nreturn (QLA_MEMORY_ALLOC_FAILED);\r\n}\r\nnew_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);\r\nfirst_dev = 1;\r\nlast_dev = 0;\r\nloop_id = ha->min_external_loopid;\r\nfor (; loop_id <= ha->max_loop_id; loop_id++) {\r\nif (qla2x00_is_reserved_id(vha, loop_id))\r\ncontinue;\r\nif (ha->current_topology == ISP_CFG_FL &&\r\n(atomic_read(&vha->loop_down_timer) ||\r\nLOOP_TRANSITION(vha))) {\r\natomic_set(&vha->loop_down_timer, 0);\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\r\nbreak;\r\n}\r\nif (swl != NULL) {\r\nif (last_dev) {\r\nwrap.b24 = new_fcport->d_id.b24;\r\n} else {\r\nnew_fcport->d_id.b24 = swl[swl_idx].d_id.b24;\r\nmemcpy(new_fcport->node_name,\r\nswl[swl_idx].node_name, WWN_SIZE);\r\nmemcpy(new_fcport->port_name,\r\nswl[swl_idx].port_name, WWN_SIZE);\r\nmemcpy(new_fcport->fabric_port_name,\r\nswl[swl_idx].fabric_port_name, WWN_SIZE);\r\nnew_fcport->fp_speed = swl[swl_idx].fp_speed;\r\nnew_fcport->fc4_type = swl[swl_idx].fc4_type;\r\nif (swl[swl_idx].d_id.b.rsvd_1 != 0) {\r\nlast_dev = 1;\r\n}\r\nswl_idx++;\r\n}\r\n} else {\r\nrval = qla2x00_ga_nxt(vha, new_fcport);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x2064,\r\n"SNS scan failed -- assuming "\r\n"zero-entry result.\n");\r\nlist_for_each_entry_safe(fcport, fcptemp,\r\nnew_fcports, list) {\r\nlist_del(&fcport->list);\r\nkfree(fcport);\r\n}\r\nrval = QLA_SUCCESS;\r\nbreak;\r\n}\r\n}\r\nif (first_dev) {\r\nwrap.b24 = new_fcport->d_id.b24;\r\nfirst_dev = 0;\r\n} else if (new_fcport->d_id.b24 == wrap.b24) {\r\nql_dbg(ql_dbg_disc, vha, 0x2065,\r\n"Device wrap (%02x%02x%02x).\n",\r\nnew_fcport->d_id.b.domain,\r\nnew_fcport->d_id.b.area,\r\nnew_fcport->d_id.b.al_pa);\r\nbreak;\r\n}\r\nif (new_fcport->d_id.b24 == base_vha->d_id.b24)\r\ncontinue;\r\nif (qla2x00_is_a_vp_did(vha, new_fcport->d_id.b24))\r\ncontinue;\r\nif (((new_fcport->d_id.b24 & 0xffff00) ==\r\n(vha->d_id.b24 & 0xffff00)) && ha->current_topology ==\r\nISP_CFG_FL)\r\ncontinue;\r\nif ((new_fcport->d_id.b.domain & 0xf0) == 0xf0)\r\ncontinue;\r\nif (ql2xgffidenable &&\r\n(new_fcport->fc4_type != FC4_TYPE_FCP_SCSI &&\r\nnew_fcport->fc4_type != FC4_TYPE_UNKNOWN))\r\ncontinue;\r\nfound = 0;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (memcmp(new_fcport->port_name, fcport->port_name,\r\nWWN_SIZE))\r\ncontinue;\r\nfcport->scan_state = QLA_FCPORT_FOUND;\r\nfound++;\r\nmemcpy(fcport->fabric_port_name,\r\nnew_fcport->fabric_port_name, WWN_SIZE);\r\nfcport->fp_speed = new_fcport->fp_speed;\r\nif (fcport->d_id.b24 == new_fcport->d_id.b24 &&\r\n(atomic_read(&fcport->state) == FCS_ONLINE ||\r\n!qla_ini_mode_enabled(base_vha))) {\r\nbreak;\r\n}\r\nif ((fcport->flags & FCF_FABRIC_DEVICE) == 0) {\r\nfcport->d_id.b24 = new_fcport->d_id.b24;\r\nqla2x00_clear_loop_id(fcport);\r\nfcport->flags |= (FCF_FABRIC_DEVICE |\r\nFCF_LOGIN_NEEDED);\r\nbreak;\r\n}\r\nif (!qla_ini_mode_enabled(base_vha)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf080,\r\n"port changed FC ID, %8phC"\r\n" old %x:%x:%x (loop_id 0x%04x)-> new %x:%x:%x\n",\r\nfcport->port_name,\r\nfcport->d_id.b.domain,\r\nfcport->d_id.b.area,\r\nfcport->d_id.b.al_pa,\r\nfcport->loop_id,\r\nnew_fcport->d_id.b.domain,\r\nnew_fcport->d_id.b.area,\r\nnew_fcport->d_id.b.al_pa);\r\nfcport->d_id.b24 = new_fcport->d_id.b24;\r\nbreak;\r\n}\r\nfcport->d_id.b24 = new_fcport->d_id.b24;\r\nfcport->flags |= FCF_LOGIN_NEEDED;\r\nif (fcport->loop_id != FC_NO_LOOP_ID &&\r\n(fcport->flags & FCF_FCP2_DEVICE) == 0 &&\r\n(fcport->flags & FCF_ASYNC_SENT) == 0 &&\r\nfcport->port_type != FCT_INITIATOR &&\r\nfcport->port_type != FCT_BROADCAST) {\r\nha->isp_ops->fabric_logout(vha, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nqla2x00_clear_loop_id(fcport);\r\n}\r\nbreak;\r\n}\r\nif (found)\r\ncontinue;\r\nnew_fcport->scan_state = QLA_FCPORT_FOUND;\r\nlist_add_tail(&new_fcport->list, new_fcports);\r\nnxt_d_id.b24 = new_fcport->d_id.b24;\r\nnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (new_fcport == NULL) {\r\nql_log(ql_log_warn, vha, 0x2066,\r\n"Memory allocation failed for fcport.\n");\r\nreturn (QLA_MEMORY_ALLOC_FAILED);\r\n}\r\nnew_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);\r\nnew_fcport->d_id.b24 = nxt_d_id.b24;\r\n}\r\nkfree(new_fcport);\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_find_new_loop_id(scsi_qla_host_t *vha, fc_port_t *dev)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long flags = 0;\r\nrval = QLA_SUCCESS;\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\ndev->loop_id = find_first_zero_bit(ha->loop_id_map,\r\nLOOPID_MAP_SIZE);\r\nif (dev->loop_id >= LOOPID_MAP_SIZE ||\r\nqla2x00_is_reserved_id(vha, dev->loop_id)) {\r\ndev->loop_id = FC_NO_LOOP_ID;\r\nrval = QLA_FUNCTION_FAILED;\r\n} else\r\nset_bit(dev->loop_id, ha->loop_id_map);\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nif (rval == QLA_SUCCESS)\r\nql_dbg(ql_dbg_disc, dev->vha, 0x2086,\r\n"Assigning new loopid=%x, portid=%x.\n",\r\ndev->loop_id, dev->d_id.b24);\r\nelse\r\nql_log(ql_log_warn, dev->vha, 0x2087,\r\n"No loop_id's available, portid=%x.\n",\r\ndev->d_id.b24);\r\nreturn (rval);\r\n}\r\nstatic int\r\nqla2x00_fabric_dev_login(scsi_qla_host_t *vha, fc_port_t *fcport,\r\nuint16_t *next_loopid)\r\n{\r\nint rval;\r\nuint8_t opts;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = QLA_SUCCESS;\r\nif (IS_ALOGIO_CAPABLE(ha)) {\r\nif (fcport->flags & FCF_ASYNC_SENT)\r\nreturn rval;\r\nfcport->flags |= FCF_ASYNC_SENT;\r\nrval = qla2x00_post_async_login_work(vha, fcport, NULL);\r\nif (!rval)\r\nreturn rval;\r\n}\r\nfcport->flags &= ~FCF_ASYNC_SENT;\r\nrval = qla2x00_fabric_login(vha, fcport, next_loopid);\r\nif (rval == QLA_SUCCESS) {\r\nopts = 0;\r\nif (fcport->flags & FCF_FCP2_DEVICE)\r\nopts |= BIT_1;\r\nrval = qla2x00_get_port_database(vha, fcport, opts);\r\nif (rval != QLA_SUCCESS) {\r\nha->isp_ops->fabric_logout(vha, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nqla2x00_mark_device_lost(vha, fcport, 1, 0);\r\n} else {\r\nqla2x00_update_fcport(vha, fcport);\r\n}\r\n} else {\r\nqla2x00_mark_device_lost(vha, fcport, 1, 0);\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_fabric_login(scsi_qla_host_t *vha, fc_port_t *fcport,\r\nuint16_t *next_loopid)\r\n{\r\nint rval;\r\nint retry;\r\nuint16_t tmp_loopid;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nstruct qla_hw_data *ha = vha->hw;\r\nretry = 0;\r\ntmp_loopid = 0;\r\nfor (;;) {\r\nql_dbg(ql_dbg_disc, vha, 0x2000,\r\n"Trying Fabric Login w/loop id 0x%04x for port "\r\n"%02x%02x%02x.\n",\r\nfcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nrval = ha->isp_ops->fabric_login(vha, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa, mb, BIT_0);\r\nif (rval != QLA_SUCCESS) {\r\nreturn rval;\r\n}\r\nif (mb[0] == MBS_PORT_ID_USED) {\r\nretry++;\r\ntmp_loopid = fcport->loop_id;\r\nfcport->loop_id = mb[1];\r\nql_dbg(ql_dbg_disc, vha, 0x2001,\r\n"Fabric Login: port in use - next loop "\r\n"id=0x%04x, port id= %02x%02x%02x.\n",\r\nfcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\n} else if (mb[0] == MBS_COMMAND_COMPLETE) {\r\nif (retry) {\r\n*next_loopid = tmp_loopid;\r\n} else {\r\n*next_loopid = (fcport->loop_id + 1);\r\n}\r\nif (mb[1] & BIT_0) {\r\nfcport->port_type = FCT_INITIATOR;\r\n} else {\r\nfcport->port_type = FCT_TARGET;\r\nif (mb[1] & BIT_1) {\r\nfcport->flags |= FCF_FCP2_DEVICE;\r\n}\r\n}\r\nif (mb[10] & BIT_0)\r\nfcport->supported_classes |= FC_COS_CLASS2;\r\nif (mb[10] & BIT_1)\r\nfcport->supported_classes |= FC_COS_CLASS3;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nif (mb[10] & BIT_7)\r\nfcport->flags |=\r\nFCF_CONF_COMP_SUPPORTED;\r\n}\r\nrval = QLA_SUCCESS;\r\nbreak;\r\n} else if (mb[0] == MBS_LOOP_ID_USED) {\r\nfcport->loop_id++;\r\nrval = qla2x00_find_new_loop_id(vha, fcport);\r\nif (rval != QLA_SUCCESS) {\r\nbreak;\r\n}\r\n} else if (mb[0] == MBS_COMMAND_ERROR) {\r\n*next_loopid = fcport->loop_id;\r\nha->isp_ops->fabric_logout(vha, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nqla2x00_mark_device_lost(vha, fcport, 1, 0);\r\nrval = 1;\r\nbreak;\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2002,\r\n"Failed=%x port_id=%02x%02x%02x loop_id=%x "\r\n"jiffies=%lx.\n", mb[0], fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa,\r\nfcport->loop_id, jiffies);\r\n*next_loopid = fcport->loop_id;\r\nha->isp_ops->fabric_logout(vha, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nqla2x00_clear_loop_id(fcport);\r\nfcport->login_retry = 0;\r\nrval = 3;\r\nbreak;\r\n}\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_local_device_login(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nint rval;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nmemset(mb, 0, sizeof(mb));\r\nrval = qla2x00_login_local_device(vha, fcport, mb, BIT_0);\r\nif (rval == QLA_SUCCESS) {\r\nif (mb[0] == MBS_COMMAND_ERROR)\r\nrval = 1;\r\nelse if (mb[0] == MBS_COMMAND_PARAMETER_ERROR)\r\nrval = 3;\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_loop_resync(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nuint32_t wait_time;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nif (vha->hw->flags.cpu_affinity_enabled)\r\nreq = vha->hw->req_q_map[0];\r\nelse\r\nreq = vha->req;\r\nrsp = req->rsp;\r\nclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\r\nif (vha->flags.online) {\r\nif (!(rval = qla2x00_fw_ready(vha))) {\r\nwait_time = 256;\r\ndo {\r\nif (!IS_QLAFX00(vha->hw)) {\r\nqla2x00_marker(vha, req, rsp, 0, 0,\r\nMK_SYNC_ALL);\r\nvha->marker_needed = 0;\r\n}\r\nclear_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nif (IS_QLAFX00(vha->hw))\r\nqlafx00_configure_devices(vha);\r\nelse\r\nqla2x00_configure_loop(vha);\r\nwait_time--;\r\n} while (!atomic_read(&vha->loop_down_timer) &&\r\n!(test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags))\r\n&& wait_time && (test_bit(LOOP_RESYNC_NEEDED,\r\n&vha->dpc_flags)));\r\n}\r\n}\r\nif (test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags))\r\nreturn (QLA_FUNCTION_FAILED);\r\nif (rval)\r\nql_dbg(ql_dbg_disc, vha, 0x206c,\r\n"%s *** FAILED ***.\n", __func__);\r\nreturn (rval);\r\n}\r\nint qla2x00_perform_loop_resync(scsi_qla_host_t *ha)\r\n{\r\nint32_t rval = 0;\r\nif (!test_and_set_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags)) {\r\natomic_set(&ha->loop_down_timer, 0);\r\nif (!(ha->device_flags & DFLG_NO_CABLE)) {\r\natomic_set(&ha->loop_state, LOOP_UP);\r\nset_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);\r\nset_bit(REGISTER_FC4_NEEDED, &ha->dpc_flags);\r\nset_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);\r\nrval = qla2x00_loop_resync(ha);\r\n} else\r\natomic_set(&ha->loop_state, LOOP_DEAD);\r\nclear_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags);\r\n}\r\nreturn rval;\r\n}\r\nvoid\r\nqla2x00_update_fcports(scsi_qla_host_t *base_vha)\r\n{\r\nfc_port_t *fcport;\r\nstruct scsi_qla_host *vha;\r\nstruct qla_hw_data *ha = base_vha->hw;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\nlist_for_each_entry(vha, &base_vha->hw->vp_list, list) {\r\natomic_inc(&vha->vref_count);\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (fcport->drport &&\r\natomic_read(&fcport->state) != FCS_UNCONFIGURED) {\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nqla2x00_rport_del(fcport);\r\nqlt_fc_port_deleted(vha, fcport,\r\nbase_vha->total_fcport_update_gen);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\n}\r\n}\r\natomic_dec(&vha->vref_count);\r\n}\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\n}\r\nvoid\r\nqla83xx_reset_ownership(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t drv_presence, drv_presence_mask;\r\nuint32_t dev_part_info1, dev_part_info2, class_type;\r\nuint32_t class_type_mask = 0x3;\r\nuint16_t fcoe_other_function = 0xffff, i;\r\nif (IS_QLA8044(ha)) {\r\ndrv_presence = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_ACTIVE_INDEX);\r\ndev_part_info1 = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DEV_PART_INFO_INDEX);\r\ndev_part_info2 = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DEV_PART_INFO2);\r\n} else {\r\nqla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\r\nqla83xx_rd_reg(vha, QLA83XX_DEV_PARTINFO1, &dev_part_info1);\r\nqla83xx_rd_reg(vha, QLA83XX_DEV_PARTINFO2, &dev_part_info2);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nclass_type = ((dev_part_info1 >> (i * 4)) & class_type_mask);\r\nif ((class_type == QLA83XX_CLASS_TYPE_FCOE) &&\r\n(i != ha->portnum)) {\r\nfcoe_other_function = i;\r\nbreak;\r\n}\r\n}\r\nif (fcoe_other_function == 0xffff) {\r\nfor (i = 0; i < 8; i++) {\r\nclass_type = ((dev_part_info2 >> (i * 4)) &\r\nclass_type_mask);\r\nif ((class_type == QLA83XX_CLASS_TYPE_FCOE) &&\r\n((i + 8) != ha->portnum)) {\r\nfcoe_other_function = i + 8;\r\nbreak;\r\n}\r\n}\r\n}\r\ndrv_presence_mask = ~((1 << (ha->portnum)) |\r\n((fcoe_other_function == 0xffff) ?\r\n0 : (1 << (fcoe_other_function))));\r\nif (!(drv_presence & drv_presence_mask) &&\r\n(ha->portnum < fcoe_other_function)) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb07f,\r\n"This host is Reset owner.\n");\r\nha->flags.nic_core_reset_owner = 1;\r\n}\r\n}\r\nstatic int\r\n__qla83xx_set_drv_ack(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t drv_ack;\r\nrval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRIVER_ACK, &drv_ack);\r\nif (rval == QLA_SUCCESS) {\r\ndrv_ack |= (1 << ha->portnum);\r\nrval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRIVER_ACK, drv_ack);\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\n__qla83xx_clear_drv_ack(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t drv_ack;\r\nrval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRIVER_ACK, &drv_ack);\r\nif (rval == QLA_SUCCESS) {\r\ndrv_ack &= ~(1 << ha->portnum);\r\nrval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRIVER_ACK, drv_ack);\r\n}\r\nreturn rval;\r\n}\r\nstatic const char *\r\nqla83xx_dev_state_to_string(uint32_t dev_state)\r\n{\r\nswitch (dev_state) {\r\ncase QLA8XXX_DEV_COLD:\r\nreturn "COLD/RE-INIT";\r\ncase QLA8XXX_DEV_INITIALIZING:\r\nreturn "INITIALIZING";\r\ncase QLA8XXX_DEV_READY:\r\nreturn "READY";\r\ncase QLA8XXX_DEV_NEED_RESET:\r\nreturn "NEED RESET";\r\ncase QLA8XXX_DEV_NEED_QUIESCENT:\r\nreturn "NEED QUIESCENT";\r\ncase QLA8XXX_DEV_FAILED:\r\nreturn "FAILED";\r\ncase QLA8XXX_DEV_QUIESCENT:\r\nreturn "QUIESCENT";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nvoid\r\nqla83xx_idc_audit(scsi_qla_host_t *vha, int audit_type)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t idc_audit_reg = 0, duration_secs = 0;\r\nswitch (audit_type) {\r\ncase IDC_AUDIT_TIMESTAMP:\r\nha->idc_audit_ts = (jiffies_to_msecs(jiffies) / 1000);\r\nidc_audit_reg = (ha->portnum) |\r\n(IDC_AUDIT_TIMESTAMP << 7) | (ha->idc_audit_ts << 8);\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_AUDIT, idc_audit_reg);\r\nbreak;\r\ncase IDC_AUDIT_COMPLETION:\r\nduration_secs = ((jiffies_to_msecs(jiffies) -\r\njiffies_to_msecs(ha->idc_audit_ts)) / 1000);\r\nidc_audit_reg = (ha->portnum) |\r\n(IDC_AUDIT_COMPLETION << 7) | (duration_secs << 8);\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_AUDIT, idc_audit_reg);\r\nbreak;\r\ndefault:\r\nql_log(ql_log_warn, vha, 0xb078,\r\n"Invalid audit type specified.\n");\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nqla83xx_initiating_reset(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t idc_control, dev_state;\r\n__qla83xx_get_idc_control(vha, &idc_control);\r\nif ((idc_control & QLA83XX_IDC_RESET_DISABLED)) {\r\nql_log(ql_log_info, vha, 0xb080,\r\n"NIC Core reset has been disabled. idc-control=0x%x\n",\r\nidc_control);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nqla83xx_rd_reg(vha, QLA83XX_IDC_DEV_STATE, &dev_state);\r\nif (ha->flags.nic_core_reset_owner && dev_state == QLA8XXX_DEV_READY) {\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\r\nQLA8XXX_DEV_NEED_RESET);\r\nql_log(ql_log_info, vha, 0xb056, "HW State: NEED RESET.\n");\r\nqla83xx_idc_audit(vha, IDC_AUDIT_TIMESTAMP);\r\n} else {\r\nconst char *state = qla83xx_dev_state_to_string(dev_state);\r\nql_log(ql_log_info, vha, 0xb057, "HW State: %s.\n", state);\r\nwhile (dev_state == QLA8XXX_DEV_READY) {\r\nqla83xx_idc_unlock(vha, 0);\r\nmsleep(200);\r\nqla83xx_idc_lock(vha, 0);\r\nqla83xx_rd_reg(vha, QLA83XX_IDC_DEV_STATE, &dev_state);\r\n}\r\n}\r\n__qla83xx_set_drv_ack(vha);\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\n__qla83xx_set_idc_control(scsi_qla_host_t *vha, uint32_t idc_control)\r\n{\r\nreturn qla83xx_wr_reg(vha, QLA83XX_IDC_CONTROL, idc_control);\r\n}\r\nint\r\n__qla83xx_get_idc_control(scsi_qla_host_t *vha, uint32_t *idc_control)\r\n{\r\nreturn qla83xx_rd_reg(vha, QLA83XX_IDC_CONTROL, idc_control);\r\n}\r\nstatic int\r\nqla83xx_check_driver_presence(scsi_qla_host_t *vha)\r\n{\r\nuint32_t drv_presence = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\r\nif (drv_presence & (1 << ha->portnum))\r\nreturn QLA_SUCCESS;\r\nelse\r\nreturn QLA_TEST_FAILED;\r\n}\r\nint\r\nqla83xx_nic_core_reset(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_p3p, vha, 0xb058,\r\n"Entered %s().\n", __func__);\r\nif (vha->device_flags & DFLG_DEV_FAILED) {\r\nql_log(ql_log_warn, vha, 0xb059,\r\n"Device in unrecoverable FAILED state.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nqla83xx_idc_lock(vha, 0);\r\nif (qla83xx_check_driver_presence(vha) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0xb05a,\r\n"Function=0x%x has been removed from IDC participation.\n",\r\nha->portnum);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto exit;\r\n}\r\nqla83xx_reset_ownership(vha);\r\nrval = qla83xx_initiating_reset(vha);\r\nif (rval == QLA_SUCCESS) {\r\nrval = qla83xx_idc_state_handler(vha);\r\nif (rval == QLA_SUCCESS)\r\nha->flags.nic_core_hung = 0;\r\n__qla83xx_clear_drv_ack(vha);\r\n}\r\nexit:\r\nqla83xx_idc_unlock(vha, 0);\r\nql_dbg(ql_dbg_p3p, vha, 0xb05b, "Exiting %s.\n", __func__);\r\nreturn rval;\r\n}\r\nint\r\nqla2xxx_mctp_dump(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = QLA_FUNCTION_FAILED;\r\nif (!IS_MCTP_CAPABLE(ha)) {\r\nql_log(ql_log_info, vha, 0x506d,\r\n"This board is not MCTP capable\n");\r\nreturn rval;\r\n}\r\nif (!ha->mctp_dump) {\r\nha->mctp_dump = dma_alloc_coherent(&ha->pdev->dev,\r\nMCTP_DUMP_SIZE, &ha->mctp_dump_dma, GFP_KERNEL);\r\nif (!ha->mctp_dump) {\r\nql_log(ql_log_warn, vha, 0x506e,\r\n"Failed to allocate memory for mctp dump\n");\r\nreturn rval;\r\n}\r\n}\r\n#define MCTP_DUMP_STR_ADDR 0x00000000\r\nrval = qla2x00_dump_mctp_data(vha, ha->mctp_dump_dma,\r\nMCTP_DUMP_STR_ADDR, MCTP_DUMP_SIZE/4);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x506f,\r\n"Failed to capture mctp dump\n");\r\n} else {\r\nql_log(ql_log_info, vha, 0x5070,\r\n"Mctp dump capture for host (%ld/%p).\n",\r\nvha->host_no, ha->mctp_dump);\r\nha->mctp_dumped = 1;\r\n}\r\nif (!ha->flags.nic_core_reset_hdlr_active && !ha->portnum) {\r\nha->flags.nic_core_reset_hdlr_active = 1;\r\nrval = qla83xx_restart_nic_firmware(vha);\r\nif (rval)\r\nql_log(ql_log_warn, vha, 0x5071,\r\n"Failed to restart nic firmware\n");\r\nelse\r\nql_dbg(ql_dbg_p3p, vha, 0xb084,\r\n"Restarted NIC firmware successfully.\n");\r\nha->flags.nic_core_reset_hdlr_active = 0;\r\n}\r\nreturn rval;\r\n}\r\nvoid\r\nqla2x00_quiesce_io(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *vp;\r\nql_dbg(ql_dbg_dpc, vha, 0x401d,\r\n"Quiescing I/O - ha=%p.\n", ha);\r\natomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nqla2x00_mark_all_devices_lost(vha, 0);\r\nlist_for_each_entry(vp, &ha->vp_list, list)\r\nqla2x00_mark_all_devices_lost(vp, 0);\r\n} else {\r\nif (!atomic_read(&vha->loop_down_timer))\r\natomic_set(&vha->loop_down_timer,\r\nLOOP_DOWN_TIME);\r\n}\r\nqla2x00_eh_wait_for_pending_commands(vha, 0, 0, WAIT_HOST);\r\n}\r\nvoid\r\nqla2x00_abort_isp_cleanup(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *vp;\r\nunsigned long flags;\r\nfc_port_t *fcport;\r\nif (!(IS_P3P_TYPE(ha)))\r\nvha->flags.online = 0;\r\nha->flags.chip_reset_done = 0;\r\nclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nvha->qla_stats.total_isp_aborts++;\r\nql_log(ql_log_info, vha, 0x00af,\r\n"Performing ISP error recovery - ha=%p.\n", ha);\r\nif (!(IS_P3P_TYPE(ha)))\r\nha->isp_ops->reset_chip(vha);\r\natomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nqla2x00_mark_all_devices_lost(vha, 0);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\nlist_for_each_entry(vp, &ha->vp_list, list) {\r\natomic_inc(&vp->vref_count);\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nqla2x00_mark_all_devices_lost(vp, 0);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\natomic_dec(&vp->vref_count);\r\n}\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\n} else {\r\nif (!atomic_read(&vha->loop_down_timer))\r\natomic_set(&vha->loop_down_timer,\r\nLOOP_DOWN_TIME);\r\n}\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list)\r\nfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\nlist_for_each_entry(vp, &ha->vp_list, list) {\r\natomic_inc(&vp->vref_count);\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nlist_for_each_entry(fcport, &vp->vp_fcports, list)\r\nfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\natomic_dec(&vp->vref_count);\r\n}\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nif (!ha->flags.eeh_busy) {\r\nif (IS_P3P_TYPE(ha)) {\r\nqla82xx_chip_reset_cleanup(vha);\r\nql_log(ql_log_info, vha, 0x00b4,\r\n"Done chip reset cleanup.\n");\r\nvha->flags.online = 0;\r\n}\r\nqla2x00_abort_all_cmds(vha, DID_RESET << 16);\r\n}\r\nha->chip_reset++;\r\nwmb();\r\n}\r\nint\r\nqla2x00_abort_isp(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint8_t status = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *vp;\r\nstruct req_que *req = ha->req_q_map[0];\r\nunsigned long flags;\r\nif (vha->flags.online) {\r\nqla2x00_abort_isp_cleanup(vha);\r\nif (IS_QLA8031(ha)) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb05c,\r\n"Clearing fcoe driver presence.\n");\r\nif (qla83xx_clear_drv_presence(vha) != QLA_SUCCESS)\r\nql_dbg(ql_dbg_p3p, vha, 0xb073,\r\n"Error while clearing DRV-Presence.\n");\r\n}\r\nif (unlikely(pci_channel_offline(ha->pdev) &&\r\nha->flags.pci_channel_io_perm_failure)) {\r\nclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\r\nstatus = 0;\r\nreturn status;\r\n}\r\nha->isp_ops->get_flash_version(vha, req->ring);\r\nha->isp_ops->nvram_config(vha);\r\nif (!qla2x00_restart_isp(vha)) {\r\nclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nif (!atomic_read(&vha->loop_down_timer)) {\r\nvha->marker_needed = 1;\r\n}\r\nvha->flags.online = 1;\r\nha->isp_ops->enable_intrs(ha);\r\nha->isp_abort_cnt = 0;\r\nclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\r\nif (IS_QLA81XX(ha) || IS_QLA8031(ha))\r\nqla2x00_get_fw_version(vha);\r\nif (ha->fce) {\r\nha->flags.fce_enabled = 1;\r\nmemset(ha->fce, 0,\r\nfce_calc_size(ha->fce_bufs));\r\nrval = qla2x00_enable_fce_trace(vha,\r\nha->fce_dma, ha->fce_bufs, ha->fce_mb,\r\n&ha->fce_bufs);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x8033,\r\n"Unable to reinitialize FCE "\r\n"(%d).\n", rval);\r\nha->flags.fce_enabled = 0;\r\n}\r\n}\r\nif (ha->eft) {\r\nmemset(ha->eft, 0, EFT_SIZE);\r\nrval = qla2x00_enable_eft_trace(vha,\r\nha->eft_dma, EFT_NUM_BUFFERS);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x8034,\r\n"Unable to reinitialize EFT "\r\n"(%d).\n", rval);\r\n}\r\n}\r\n} else {\r\nvha->flags.online = 1;\r\nif (test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\r\nif (ha->isp_abort_cnt == 0) {\r\nql_log(ql_log_fatal, vha, 0x8035,\r\n"ISP error recover failed - "\r\n"board disabled.\n");\r\nha->isp_ops->reset_adapter(vha);\r\nvha->flags.online = 0;\r\nclear_bit(ISP_ABORT_RETRY,\r\n&vha->dpc_flags);\r\nstatus = 0;\r\n} else {\r\nha->isp_abort_cnt--;\r\nql_dbg(ql_dbg_taskm, vha, 0x8020,\r\n"ISP abort - retry remaining %d.\n",\r\nha->isp_abort_cnt);\r\nstatus = 1;\r\n}\r\n} else {\r\nha->isp_abort_cnt = MAX_RETRIES_OF_ISP_ABORT;\r\nql_dbg(ql_dbg_taskm, vha, 0x8021,\r\n"ISP error recovery - retrying (%d) "\r\n"more times.\n", ha->isp_abort_cnt);\r\nset_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\r\nstatus = 1;\r\n}\r\n}\r\n}\r\nif (!status) {\r\nql_dbg(ql_dbg_taskm, vha, 0x8022, "%s succeeded.\n", __func__);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\nlist_for_each_entry(vp, &ha->vp_list, list) {\r\nif (vp->vp_idx) {\r\natomic_inc(&vp->vref_count);\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nqla2x00_vp_abort_isp(vp);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\natomic_dec(&vp->vref_count);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nif (IS_QLA8031(ha)) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb05d,\r\n"Setting back fcoe driver presence.\n");\r\nif (qla83xx_set_drv_presence(vha) != QLA_SUCCESS)\r\nql_dbg(ql_dbg_p3p, vha, 0xb074,\r\n"Error while setting DRV-Presence.\n");\r\n}\r\n} else {\r\nql_log(ql_log_warn, vha, 0x8023, "%s **** FAILED ****.\n",\r\n__func__);\r\n}\r\nreturn(status);\r\n}\r\nstatic int\r\nqla2x00_restart_isp(scsi_qla_host_t *vha)\r\n{\r\nint status = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\nif (qla2x00_isp_firmware(vha)) {\r\nvha->flags.online = 0;\r\nstatus = ha->isp_ops->chip_diag(vha);\r\nif (!status)\r\nstatus = qla2x00_setup_chip(vha);\r\n}\r\nif (!status && !(status = qla2x00_init_rings(vha))) {\r\nclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nha->flags.chip_reset_done = 1;\r\nqla25xx_init_queues(ha);\r\nstatus = qla2x00_fw_ready(vha);\r\nif (!status) {\r\nqla2x00_marker(vha, req, rsp, 0, 0, MK_SYNC_ALL);\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\n}\r\nif ((vha->device_flags & DFLG_NO_CABLE))\r\nstatus = 0;\r\n}\r\nreturn (status);\r\n}\r\nstatic int\r\nqla25xx_init_queues(struct qla_hw_data *ha)\r\n{\r\nstruct rsp_que *rsp = NULL;\r\nstruct req_que *req = NULL;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nint ret = -1;\r\nint i;\r\nfor (i = 1; i < ha->max_rsp_queues; i++) {\r\nrsp = ha->rsp_q_map[i];\r\nif (rsp && test_bit(i, ha->rsp_qid_map)) {\r\nrsp->options &= ~BIT_0;\r\nret = qla25xx_init_rsp_que(base_vha, rsp);\r\nif (ret != QLA_SUCCESS)\r\nql_dbg(ql_dbg_init, base_vha, 0x00ff,\r\n"%s Rsp que: %d init failed.\n",\r\n__func__, rsp->id);\r\nelse\r\nql_dbg(ql_dbg_init, base_vha, 0x0100,\r\n"%s Rsp que: %d inited.\n",\r\n__func__, rsp->id);\r\n}\r\n}\r\nfor (i = 1; i < ha->max_req_queues; i++) {\r\nreq = ha->req_q_map[i];\r\nif (req && test_bit(i, ha->req_qid_map)) {\r\nreq->options &= ~BIT_0;\r\nret = qla25xx_init_req_que(base_vha, req);\r\nif (ret != QLA_SUCCESS)\r\nql_dbg(ql_dbg_init, base_vha, 0x0101,\r\n"%s Req que: %d init failed.\n",\r\n__func__, req->id);\r\nelse\r\nql_dbg(ql_dbg_init, base_vha, 0x0102,\r\n"%s Req que: %d inited.\n",\r\n__func__, req->id);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nqla2x00_reset_adapter(scsi_qla_host_t *vha)\r\n{\r\nunsigned long flags = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nvha->flags.online = 0;\r\nha->isp_ops->disable_intrs(ha);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid\r\nqla24xx_reset_adapter(scsi_qla_host_t *vha)\r\n{\r\nunsigned long flags = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nif (IS_P3P_TYPE(ha))\r\nreturn;\r\nvha->flags.online = 0;\r\nha->isp_ops->disable_intrs(ha);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_SET_RISC_RESET);\r\nRD_REG_DWORD(&reg->hccr);\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_REL_RISC_PAUSE);\r\nRD_REG_DWORD(&reg->hccr);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (IS_NOPOLLING_TYPE(ha))\r\nha->isp_ops->enable_intrs(ha);\r\n}\r\nstatic void qla24xx_nvram_wwn_from_ofw(scsi_qla_host_t *vha,\r\nstruct nvram_24xx *nv)\r\n{\r\n#ifdef CONFIG_SPARC\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct pci_dev *pdev = ha->pdev;\r\nstruct device_node *dp = pci_device_to_OF_node(pdev);\r\nconst u8 *val;\r\nint len;\r\nval = of_get_property(dp, "port-wwn", &len);\r\nif (val && len >= WWN_SIZE)\r\nmemcpy(nv->port_name, val, WWN_SIZE);\r\nval = of_get_property(dp, "node-wwn", &len);\r\nif (val && len >= WWN_SIZE)\r\nmemcpy(nv->node_name, val, WWN_SIZE);\r\n#endif\r\n}\r\nint\r\nqla24xx_nvram_config(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct init_cb_24xx *icb;\r\nstruct nvram_24xx *nv;\r\nuint32_t *dptr;\r\nuint8_t *dptr1, *dptr2;\r\nuint32_t chksum;\r\nuint16_t cnt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = QLA_SUCCESS;\r\nicb = (struct init_cb_24xx *)ha->init_cb;\r\nnv = ha->nvram;\r\nif (ha->port_no == 0) {\r\nha->nvram_base = FA_NVRAM_FUNC0_ADDR;\r\nha->vpd_base = FA_NVRAM_VPD0_ADDR;\r\n} else {\r\nha->nvram_base = FA_NVRAM_FUNC1_ADDR;\r\nha->vpd_base = FA_NVRAM_VPD1_ADDR;\r\n}\r\nha->nvram_size = sizeof(struct nvram_24xx);\r\nha->vpd_size = FA_NVRAM_VPD_SIZE;\r\nha->vpd = ha->nvram + VPD_OFFSET;\r\nha->isp_ops->read_nvram(vha, (uint8_t *)ha->vpd,\r\nha->nvram_base - FA_NVRAM_FUNC0_ADDR, FA_NVRAM_VPD_SIZE * 4);\r\ndptr = (uint32_t *)nv;\r\nha->isp_ops->read_nvram(vha, (uint8_t *)dptr, ha->nvram_base,\r\nha->nvram_size);\r\nfor (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)\r\nchksum += le32_to_cpu(*dptr);\r\nql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x006a,\r\n"Contents of NVRAM\n");\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010d,\r\n(uint8_t *)nv, ha->nvram_size);\r\nif (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P'\r\n|| nv->id[3] != ' ' ||\r\nnv->nvram_version < cpu_to_le16(ICB_VERSION)) {\r\nql_log(ql_log_warn, vha, 0x006b,\r\n"Inconsistent NVRAM detected: checksum=0x%x id=%c "\r\n"version=0x%x.\n", chksum, nv->id[0], nv->nvram_version);\r\nql_log(ql_log_warn, vha, 0x006c,\r\n"Falling back to functioning (yet invalid -- WWPN) "\r\n"defaults.\n");\r\nmemset(nv, 0, ha->nvram_size);\r\nnv->nvram_version = cpu_to_le16(ICB_VERSION);\r\nnv->version = cpu_to_le16(ICB_VERSION);\r\nnv->frame_payload_size = 2048;\r\nnv->execution_throttle = cpu_to_le16(0xFFFF);\r\nnv->exchange_count = cpu_to_le16(0);\r\nnv->hard_address = cpu_to_le16(124);\r\nnv->port_name[0] = 0x21;\r\nnv->port_name[1] = 0x00 + ha->port_no + 1;\r\nnv->port_name[2] = 0x00;\r\nnv->port_name[3] = 0xe0;\r\nnv->port_name[4] = 0x8b;\r\nnv->port_name[5] = 0x1c;\r\nnv->port_name[6] = 0x55;\r\nnv->port_name[7] = 0x86;\r\nnv->node_name[0] = 0x20;\r\nnv->node_name[1] = 0x00;\r\nnv->node_name[2] = 0x00;\r\nnv->node_name[3] = 0xe0;\r\nnv->node_name[4] = 0x8b;\r\nnv->node_name[5] = 0x1c;\r\nnv->node_name[6] = 0x55;\r\nnv->node_name[7] = 0x86;\r\nqla24xx_nvram_wwn_from_ofw(vha, nv);\r\nnv->login_retry_count = cpu_to_le16(8);\r\nnv->interrupt_delay_timer = cpu_to_le16(0);\r\nnv->login_timeout = cpu_to_le16(0);\r\nnv->firmware_options_1 =\r\ncpu_to_le32(BIT_14|BIT_13|BIT_2|BIT_1);\r\nnv->firmware_options_2 = cpu_to_le32(2 << 4);\r\nnv->firmware_options_2 |= cpu_to_le32(BIT_12);\r\nnv->firmware_options_3 = cpu_to_le32(2 << 13);\r\nnv->host_p = cpu_to_le32(BIT_11|BIT_10);\r\nnv->efi_parameters = cpu_to_le32(0);\r\nnv->reset_delay = 5;\r\nnv->max_luns_per_target = cpu_to_le16(128);\r\nnv->port_down_retry_count = cpu_to_le16(30);\r\nnv->link_down_timeout = cpu_to_le16(30);\r\nrval = 1;\r\n}\r\nif (!qla_ini_mode_enabled(vha)) {\r\nnv->firmware_options_1 &= cpu_to_le32(~BIT_13);\r\nnv->host_p &= cpu_to_le32(~BIT_10);\r\n}\r\nqlt_24xx_config_nvram_stage1(vha, nv);\r\nmemset(icb, 0, ha->init_cb_size);\r\ndptr1 = (uint8_t *)icb;\r\ndptr2 = (uint8_t *)&nv->version;\r\ncnt = (uint8_t *)&icb->response_q_inpointer - (uint8_t *)&icb->version;\r\nwhile (cnt--)\r\n*dptr1++ = *dptr2++;\r\nicb->login_retry_count = nv->login_retry_count;\r\nicb->link_down_on_nos = nv->link_down_on_nos;\r\ndptr1 = (uint8_t *)&icb->interrupt_delay_timer;\r\ndptr2 = (uint8_t *)&nv->interrupt_delay_timer;\r\ncnt = (uint8_t *)&icb->reserved_3 -\r\n(uint8_t *)&icb->interrupt_delay_timer;\r\nwhile (cnt--)\r\n*dptr1++ = *dptr2++;\r\nqla2x00_set_model_info(vha, nv->model_name, sizeof(nv->model_name),\r\n"QLA2462");\r\nqlt_24xx_config_nvram_stage2(vha, icb);\r\nif (nv->host_p & cpu_to_le32(BIT_15)) {\r\nmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\r\nmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\r\n}\r\nif ((icb->firmware_options_1 & cpu_to_le32(BIT_14)) == 0) {\r\nmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\r\nicb->node_name[0] &= 0xF0;\r\n}\r\nha->flags.disable_risc_code_load = 0;\r\nha->flags.enable_lip_reset = 0;\r\nha->flags.enable_lip_full_login =\r\nle32_to_cpu(nv->host_p) & BIT_10 ? 1: 0;\r\nha->flags.enable_target_reset =\r\nle32_to_cpu(nv->host_p) & BIT_11 ? 1: 0;\r\nha->flags.enable_led_scheme = 0;\r\nha->flags.disable_serdes = le32_to_cpu(nv->host_p) & BIT_5 ? 1: 0;\r\nha->operating_mode = (le32_to_cpu(icb->firmware_options_2) &\r\n(BIT_6 | BIT_5 | BIT_4)) >> 4;\r\nmemcpy(ha->fw_seriallink_options24, nv->seriallink_options,\r\nsizeof(ha->fw_seriallink_options24));\r\nha->serial0 = icb->port_name[5];\r\nha->serial1 = icb->port_name[6];\r\nha->serial2 = icb->port_name[7];\r\nmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\r\nmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\r\nicb->execution_throttle = cpu_to_le16(0xFFFF);\r\nha->retry_count = le16_to_cpu(nv->login_retry_count);\r\nif (le16_to_cpu(nv->login_timeout) < ql2xlogintimeout)\r\nnv->login_timeout = cpu_to_le16(ql2xlogintimeout);\r\nif (le16_to_cpu(nv->login_timeout) < 4)\r\nnv->login_timeout = cpu_to_le16(4);\r\nha->login_timeout = le16_to_cpu(nv->login_timeout);\r\nha->r_a_tov = 100;\r\nha->loop_reset_delay = nv->reset_delay;\r\nif (le16_to_cpu(nv->link_down_timeout) == 0) {\r\nha->loop_down_abort_time =\r\n(LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\r\n} else {\r\nha->link_down_timeout = le16_to_cpu(nv->link_down_timeout);\r\nha->loop_down_abort_time =\r\n(LOOP_DOWN_TIME - ha->link_down_timeout);\r\n}\r\nha->port_down_retry_count = le16_to_cpu(nv->port_down_retry_count);\r\nif (qlport_down_retry)\r\nha->port_down_retry_count = qlport_down_retry;\r\nha->login_retry_count = le16_to_cpu(nv->login_retry_count);\r\nif (ha->port_down_retry_count ==\r\nle16_to_cpu(nv->port_down_retry_count) &&\r\nha->port_down_retry_count > 3)\r\nha->login_retry_count = ha->port_down_retry_count;\r\nelse if (ha->port_down_retry_count > (int)ha->login_retry_count)\r\nha->login_retry_count = ha->port_down_retry_count;\r\nif (ql2xloginretrycount)\r\nha->login_retry_count = ql2xloginretrycount;\r\nif (!vha->flags.init_done) {\r\nha->zio_mode = le32_to_cpu(icb->firmware_options_2) &\r\n(BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nha->zio_timer = le16_to_cpu(icb->interrupt_delay_timer) ?\r\nle16_to_cpu(icb->interrupt_delay_timer): 2;\r\n}\r\nicb->firmware_options_2 &= cpu_to_le32(\r\n~(BIT_3 | BIT_2 | BIT_1 | BIT_0));\r\nvha->flags.process_response_queue = 0;\r\nif (ha->zio_mode != QLA_ZIO_DISABLED) {\r\nha->zio_mode = QLA_ZIO_MODE_6;\r\nql_log(ql_log_info, vha, 0x006f,\r\n"ZIO mode %d enabled; timer delay (%d us).\n",\r\nha->zio_mode, ha->zio_timer * 100);\r\nicb->firmware_options_2 |= cpu_to_le32(\r\n(uint32_t)ha->zio_mode);\r\nicb->interrupt_delay_timer = cpu_to_le16(ha->zio_timer);\r\nvha->flags.process_response_queue = 1;\r\n}\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x0070,\r\n"NVRAM configuration failed.\n");\r\n}\r\nreturn (rval);\r\n}\r\nuint8_t qla27xx_find_valid_image(struct scsi_qla_host *vha)\r\n{\r\nstruct qla27xx_image_status pri_image_status, sec_image_status;\r\nuint8_t valid_pri_image, valid_sec_image;\r\nuint32_t *wptr;\r\nuint32_t cnt, chksum, size;\r\nstruct qla_hw_data *ha = vha->hw;\r\nvalid_pri_image = valid_sec_image = 1;\r\nha->active_image = 0;\r\nsize = sizeof(struct qla27xx_image_status) / sizeof(uint32_t);\r\nif (!ha->flt_region_img_status_pri) {\r\nvalid_pri_image = 0;\r\ngoto check_sec_image;\r\n}\r\nqla24xx_read_flash_data(vha, (uint32_t *)(&pri_image_status),\r\nha->flt_region_img_status_pri, size);\r\nif (pri_image_status.signature != QLA27XX_IMG_STATUS_SIGN) {\r\nql_dbg(ql_dbg_init, vha, 0x018b,\r\n"Primary image signature (0x%x) not valid\n",\r\npri_image_status.signature);\r\nvalid_pri_image = 0;\r\ngoto check_sec_image;\r\n}\r\nwptr = (uint32_t *)(&pri_image_status);\r\ncnt = size;\r\nfor (chksum = 0; cnt--; wptr++)\r\nchksum += le32_to_cpu(*wptr);\r\nif (chksum) {\r\nql_dbg(ql_dbg_init, vha, 0x018c,\r\n"Checksum validation failed for primary image (0x%x)\n",\r\nchksum);\r\nvalid_pri_image = 0;\r\n}\r\ncheck_sec_image:\r\nif (!ha->flt_region_img_status_sec) {\r\nvalid_sec_image = 0;\r\ngoto check_valid_image;\r\n}\r\nqla24xx_read_flash_data(vha, (uint32_t *)(&sec_image_status),\r\nha->flt_region_img_status_sec, size);\r\nif (sec_image_status.signature != QLA27XX_IMG_STATUS_SIGN) {\r\nql_dbg(ql_dbg_init, vha, 0x018d,\r\n"Secondary image signature(0x%x) not valid\n",\r\nsec_image_status.signature);\r\nvalid_sec_image = 0;\r\ngoto check_valid_image;\r\n}\r\nwptr = (uint32_t *)(&sec_image_status);\r\ncnt = size;\r\nfor (chksum = 0; cnt--; wptr++)\r\nchksum += le32_to_cpu(*wptr);\r\nif (chksum) {\r\nql_dbg(ql_dbg_init, vha, 0x018e,\r\n"Checksum validation failed for secondary image (0x%x)\n",\r\nchksum);\r\nvalid_sec_image = 0;\r\n}\r\ncheck_valid_image:\r\nif (valid_pri_image && (pri_image_status.image_status_mask & 0x1))\r\nha->active_image = QLA27XX_PRIMARY_IMAGE;\r\nif (valid_sec_image && (sec_image_status.image_status_mask & 0x1)) {\r\nif (!ha->active_image ||\r\npri_image_status.generation_number <\r\nsec_image_status.generation_number)\r\nha->active_image = QLA27XX_SECONDARY_IMAGE;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x018f, "%s image\n",\r\nha->active_image == 0 ? "default bootld and fw" :\r\nha->active_image == 1 ? "primary" :\r\nha->active_image == 2 ? "secondary" :\r\n"Invalid");\r\nreturn ha->active_image;\r\n}\r\nstatic int\r\nqla24xx_load_risc_flash(scsi_qla_host_t *vha, uint32_t *srisc_addr,\r\nuint32_t faddr)\r\n{\r\nint rval = QLA_SUCCESS;\r\nint segments, fragment;\r\nuint32_t *dcode, dlen;\r\nuint32_t risc_addr;\r\nuint32_t risc_size;\r\nuint32_t i;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nql_dbg(ql_dbg_init, vha, 0x008b,\r\n"FW: Loading firmware from flash (%x).\n", faddr);\r\nrval = QLA_SUCCESS;\r\nsegments = FA_RISC_CODE_SEGMENTS;\r\ndcode = (uint32_t *)req->ring;\r\n*srisc_addr = 0;\r\nif (IS_QLA27XX(ha) &&\r\nqla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)\r\nfaddr = ha->flt_region_fw_sec;\r\nqla24xx_read_flash_data(vha, dcode, faddr + 4, 4);\r\nfor (i = 0; i < 4; i++)\r\ndcode[i] = be32_to_cpu(dcode[i]);\r\nif ((dcode[0] == 0xffffffff && dcode[1] == 0xffffffff &&\r\ndcode[2] == 0xffffffff && dcode[3] == 0xffffffff) ||\r\n(dcode[0] == 0 && dcode[1] == 0 && dcode[2] == 0 &&\r\ndcode[3] == 0)) {\r\nql_log(ql_log_fatal, vha, 0x008c,\r\n"Unable to verify the integrity of flash firmware "\r\n"image.\n");\r\nql_log(ql_log_fatal, vha, 0x008d,\r\n"Firmware data: %08x %08x %08x %08x.\n",\r\ndcode[0], dcode[1], dcode[2], dcode[3]);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nwhile (segments && rval == QLA_SUCCESS) {\r\nqla24xx_read_flash_data(vha, dcode, faddr, 4);\r\nrisc_addr = be32_to_cpu(dcode[2]);\r\n*srisc_addr = *srisc_addr == 0 ? risc_addr : *srisc_addr;\r\nrisc_size = be32_to_cpu(dcode[3]);\r\nfragment = 0;\r\nwhile (risc_size > 0 && rval == QLA_SUCCESS) {\r\ndlen = (uint32_t)(ha->fw_transfer_size >> 2);\r\nif (dlen > risc_size)\r\ndlen = risc_size;\r\nql_dbg(ql_dbg_init, vha, 0x008e,\r\n"Loading risc segment@ risc addr %x "\r\n"number of dwords 0x%x offset 0x%x.\n",\r\nrisc_addr, dlen, faddr);\r\nqla24xx_read_flash_data(vha, dcode, faddr, dlen);\r\nfor (i = 0; i < dlen; i++)\r\ndcode[i] = swab32(dcode[i]);\r\nrval = qla2x00_load_ram(vha, req->dma, risc_addr,\r\ndlen);\r\nif (rval) {\r\nql_log(ql_log_fatal, vha, 0x008f,\r\n"Failed to load segment %d of firmware.\n",\r\nfragment);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nfaddr += dlen;\r\nrisc_addr += dlen;\r\nrisc_size -= dlen;\r\nfragment++;\r\n}\r\nsegments--;\r\n}\r\nif (!IS_QLA27XX(ha))\r\nreturn rval;\r\nif (ha->fw_dump_template)\r\nvfree(ha->fw_dump_template);\r\nha->fw_dump_template = NULL;\r\nha->fw_dump_template_len = 0;\r\nql_dbg(ql_dbg_init, vha, 0x0161,\r\n"Loading fwdump template from %x\n", faddr);\r\nqla24xx_read_flash_data(vha, dcode, faddr, 7);\r\nrisc_size = be32_to_cpu(dcode[2]);\r\nql_dbg(ql_dbg_init, vha, 0x0162,\r\n"-> array size %x dwords\n", risc_size);\r\nif (risc_size == 0 || risc_size == ~0)\r\ngoto default_template;\r\ndlen = (risc_size - 8) * sizeof(*dcode);\r\nql_dbg(ql_dbg_init, vha, 0x0163,\r\n"-> template allocating %x bytes...\n", dlen);\r\nha->fw_dump_template = vmalloc(dlen);\r\nif (!ha->fw_dump_template) {\r\nql_log(ql_log_warn, vha, 0x0164,\r\n"Failed fwdump template allocate %x bytes.\n", risc_size);\r\ngoto default_template;\r\n}\r\nfaddr += 7;\r\nrisc_size -= 8;\r\ndcode = ha->fw_dump_template;\r\nqla24xx_read_flash_data(vha, dcode, faddr, risc_size);\r\nfor (i = 0; i < risc_size; i++)\r\ndcode[i] = le32_to_cpu(dcode[i]);\r\nif (!qla27xx_fwdt_template_valid(dcode)) {\r\nql_log(ql_log_warn, vha, 0x0165,\r\n"Failed fwdump template validate\n");\r\ngoto default_template;\r\n}\r\ndlen = qla27xx_fwdt_template_size(dcode);\r\nql_dbg(ql_dbg_init, vha, 0x0166,\r\n"-> template size %x bytes\n", dlen);\r\nif (dlen > risc_size * sizeof(*dcode)) {\r\nql_log(ql_log_warn, vha, 0x0167,\r\n"Failed fwdump template exceeds array by %x bytes\n",\r\n(uint32_t)(dlen - risc_size * sizeof(*dcode)));\r\ngoto default_template;\r\n}\r\nha->fw_dump_template_len = dlen;\r\nreturn rval;\r\ndefault_template:\r\nql_log(ql_log_warn, vha, 0x0168, "Using default fwdump template\n");\r\nif (ha->fw_dump_template)\r\nvfree(ha->fw_dump_template);\r\nha->fw_dump_template = NULL;\r\nha->fw_dump_template_len = 0;\r\ndlen = qla27xx_fwdt_template_default_size();\r\nql_dbg(ql_dbg_init, vha, 0x0169,\r\n"-> template allocating %x bytes...\n", dlen);\r\nha->fw_dump_template = vmalloc(dlen);\r\nif (!ha->fw_dump_template) {\r\nql_log(ql_log_warn, vha, 0x016a,\r\n"Failed fwdump template allocate %x bytes.\n", risc_size);\r\ngoto failed_template;\r\n}\r\ndcode = ha->fw_dump_template;\r\nrisc_size = dlen / sizeof(*dcode);\r\nmemcpy(dcode, qla27xx_fwdt_template_default(), dlen);\r\nfor (i = 0; i < risc_size; i++)\r\ndcode[i] = be32_to_cpu(dcode[i]);\r\nif (!qla27xx_fwdt_template_valid(ha->fw_dump_template)) {\r\nql_log(ql_log_warn, vha, 0x016b,\r\n"Failed fwdump template validate\n");\r\ngoto failed_template;\r\n}\r\ndlen = qla27xx_fwdt_template_size(ha->fw_dump_template);\r\nql_dbg(ql_dbg_init, vha, 0x016c,\r\n"-> template size %x bytes\n", dlen);\r\nha->fw_dump_template_len = dlen;\r\nreturn rval;\r\nfailed_template:\r\nql_log(ql_log_warn, vha, 0x016d, "Failed default fwdump template\n");\r\nif (ha->fw_dump_template)\r\nvfree(ha->fw_dump_template);\r\nha->fw_dump_template = NULL;\r\nha->fw_dump_template_len = 0;\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\r\n{\r\nint rval;\r\nint i, fragment;\r\nuint16_t *wcode, *fwcode;\r\nuint32_t risc_addr, risc_size, fwclen, wlen, *seg;\r\nstruct fw_blob *blob;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nblob = qla2x00_request_firmware(vha);\r\nif (!blob) {\r\nql_log(ql_log_info, vha, 0x0083,\r\n"Firmware image unavailable.\n");\r\nql_log(ql_log_info, vha, 0x0084,\r\n"Firmware images can be retrieved from: "QLA_FW_URL ".\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nrval = QLA_SUCCESS;\r\nwcode = (uint16_t *)req->ring;\r\n*srisc_addr = 0;\r\nfwcode = (uint16_t *)blob->fw->data;\r\nfwclen = 0;\r\nif (blob->fw->size < 8 * sizeof(uint16_t)) {\r\nql_log(ql_log_fatal, vha, 0x0085,\r\n"Unable to verify integrity of firmware image (%Zd).\n",\r\nblob->fw->size);\r\ngoto fail_fw_integrity;\r\n}\r\nfor (i = 0; i < 4; i++)\r\nwcode[i] = be16_to_cpu(fwcode[i + 4]);\r\nif ((wcode[0] == 0xffff && wcode[1] == 0xffff && wcode[2] == 0xffff &&\r\nwcode[3] == 0xffff) || (wcode[0] == 0 && wcode[1] == 0 &&\r\nwcode[2] == 0 && wcode[3] == 0)) {\r\nql_log(ql_log_fatal, vha, 0x0086,\r\n"Unable to verify integrity of firmware image.\n");\r\nql_log(ql_log_fatal, vha, 0x0087,\r\n"Firmware data: %04x %04x %04x %04x.\n",\r\nwcode[0], wcode[1], wcode[2], wcode[3]);\r\ngoto fail_fw_integrity;\r\n}\r\nseg = blob->segs;\r\nwhile (*seg && rval == QLA_SUCCESS) {\r\nrisc_addr = *seg;\r\n*srisc_addr = *srisc_addr == 0 ? *seg : *srisc_addr;\r\nrisc_size = be16_to_cpu(fwcode[3]);\r\nfwclen += risc_size * sizeof(uint16_t);\r\nif (blob->fw->size < fwclen) {\r\nql_log(ql_log_fatal, vha, 0x0088,\r\n"Unable to verify integrity of firmware image "\r\n"(%Zd).\n", blob->fw->size);\r\ngoto fail_fw_integrity;\r\n}\r\nfragment = 0;\r\nwhile (risc_size > 0 && rval == QLA_SUCCESS) {\r\nwlen = (uint16_t)(ha->fw_transfer_size >> 1);\r\nif (wlen > risc_size)\r\nwlen = risc_size;\r\nql_dbg(ql_dbg_init, vha, 0x0089,\r\n"Loading risc segment@ risc addr %x number of "\r\n"words 0x%x.\n", risc_addr, wlen);\r\nfor (i = 0; i < wlen; i++)\r\nwcode[i] = swab16(fwcode[i]);\r\nrval = qla2x00_load_ram(vha, req->dma, risc_addr,\r\nwlen);\r\nif (rval) {\r\nql_log(ql_log_fatal, vha, 0x008a,\r\n"Failed to load segment %d of firmware.\n",\r\nfragment);\r\nbreak;\r\n}\r\nfwcode += wlen;\r\nrisc_addr += wlen;\r\nrisc_size -= wlen;\r\nfragment++;\r\n}\r\nseg++;\r\n}\r\nreturn rval;\r\nfail_fw_integrity:\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nstatic int\r\nqla24xx_load_risc_blob(scsi_qla_host_t *vha, uint32_t *srisc_addr)\r\n{\r\nint rval;\r\nint segments, fragment;\r\nuint32_t *dcode, dlen;\r\nuint32_t risc_addr;\r\nuint32_t risc_size;\r\nuint32_t i;\r\nstruct fw_blob *blob;\r\nconst uint32_t *fwcode;\r\nuint32_t fwclen;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nblob = qla2x00_request_firmware(vha);\r\nif (!blob) {\r\nql_log(ql_log_warn, vha, 0x0090,\r\n"Firmware image unavailable.\n");\r\nql_log(ql_log_warn, vha, 0x0091,\r\n"Firmware images can be retrieved from: "\r\nQLA_FW_URL ".\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x0092,\r\n"FW: Loading via request-firmware.\n");\r\nrval = QLA_SUCCESS;\r\nsegments = FA_RISC_CODE_SEGMENTS;\r\ndcode = (uint32_t *)req->ring;\r\n*srisc_addr = 0;\r\nfwcode = (uint32_t *)blob->fw->data;\r\nfwclen = 0;\r\nif (blob->fw->size < 8 * sizeof(uint32_t)) {\r\nql_log(ql_log_fatal, vha, 0x0093,\r\n"Unable to verify integrity of firmware image (%Zd).\n",\r\nblob->fw->size);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nfor (i = 0; i < 4; i++)\r\ndcode[i] = be32_to_cpu(fwcode[i + 4]);\r\nif ((dcode[0] == 0xffffffff && dcode[1] == 0xffffffff &&\r\ndcode[2] == 0xffffffff && dcode[3] == 0xffffffff) ||\r\n(dcode[0] == 0 && dcode[1] == 0 && dcode[2] == 0 &&\r\ndcode[3] == 0)) {\r\nql_log(ql_log_fatal, vha, 0x0094,\r\n"Unable to verify integrity of firmware image (%Zd).\n",\r\nblob->fw->size);\r\nql_log(ql_log_fatal, vha, 0x0095,\r\n"Firmware data: %08x %08x %08x %08x.\n",\r\ndcode[0], dcode[1], dcode[2], dcode[3]);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nwhile (segments && rval == QLA_SUCCESS) {\r\nrisc_addr = be32_to_cpu(fwcode[2]);\r\n*srisc_addr = *srisc_addr == 0 ? risc_addr : *srisc_addr;\r\nrisc_size = be32_to_cpu(fwcode[3]);\r\nfwclen += risc_size * sizeof(uint32_t);\r\nif (blob->fw->size < fwclen) {\r\nql_log(ql_log_fatal, vha, 0x0096,\r\n"Unable to verify integrity of firmware image "\r\n"(%Zd).\n", blob->fw->size);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nfragment = 0;\r\nwhile (risc_size > 0 && rval == QLA_SUCCESS) {\r\ndlen = (uint32_t)(ha->fw_transfer_size >> 2);\r\nif (dlen > risc_size)\r\ndlen = risc_size;\r\nql_dbg(ql_dbg_init, vha, 0x0097,\r\n"Loading risc segment@ risc addr %x "\r\n"number of dwords 0x%x.\n", risc_addr, dlen);\r\nfor (i = 0; i < dlen; i++)\r\ndcode[i] = swab32(fwcode[i]);\r\nrval = qla2x00_load_ram(vha, req->dma, risc_addr,\r\ndlen);\r\nif (rval) {\r\nql_log(ql_log_fatal, vha, 0x0098,\r\n"Failed to load segment %d of firmware.\n",\r\nfragment);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nfwcode += dlen;\r\nrisc_addr += dlen;\r\nrisc_size -= dlen;\r\nfragment++;\r\n}\r\nsegments--;\r\n}\r\nif (!IS_QLA27XX(ha))\r\nreturn rval;\r\nif (ha->fw_dump_template)\r\nvfree(ha->fw_dump_template);\r\nha->fw_dump_template = NULL;\r\nha->fw_dump_template_len = 0;\r\nql_dbg(ql_dbg_init, vha, 0x171,\r\n"Loading fwdump template from %x\n",\r\n(uint32_t)((void *)fwcode - (void *)blob->fw->data));\r\nrisc_size = be32_to_cpu(fwcode[2]);\r\nql_dbg(ql_dbg_init, vha, 0x172,\r\n"-> array size %x dwords\n", risc_size);\r\nif (risc_size == 0 || risc_size == ~0)\r\ngoto default_template;\r\ndlen = (risc_size - 8) * sizeof(*fwcode);\r\nql_dbg(ql_dbg_init, vha, 0x0173,\r\n"-> template allocating %x bytes...\n", dlen);\r\nha->fw_dump_template = vmalloc(dlen);\r\nif (!ha->fw_dump_template) {\r\nql_log(ql_log_warn, vha, 0x0174,\r\n"Failed fwdump template allocate %x bytes.\n", risc_size);\r\ngoto default_template;\r\n}\r\nfwcode += 7;\r\nrisc_size -= 8;\r\ndcode = ha->fw_dump_template;\r\nfor (i = 0; i < risc_size; i++)\r\ndcode[i] = le32_to_cpu(fwcode[i]);\r\nif (!qla27xx_fwdt_template_valid(dcode)) {\r\nql_log(ql_log_warn, vha, 0x0175,\r\n"Failed fwdump template validate\n");\r\ngoto default_template;\r\n}\r\ndlen = qla27xx_fwdt_template_size(dcode);\r\nql_dbg(ql_dbg_init, vha, 0x0176,\r\n"-> template size %x bytes\n", dlen);\r\nif (dlen > risc_size * sizeof(*fwcode)) {\r\nql_log(ql_log_warn, vha, 0x0177,\r\n"Failed fwdump template exceeds array by %x bytes\n",\r\n(uint32_t)(dlen - risc_size * sizeof(*fwcode)));\r\ngoto default_template;\r\n}\r\nha->fw_dump_template_len = dlen;\r\nreturn rval;\r\ndefault_template:\r\nql_log(ql_log_warn, vha, 0x0178, "Using default fwdump template\n");\r\nif (ha->fw_dump_template)\r\nvfree(ha->fw_dump_template);\r\nha->fw_dump_template = NULL;\r\nha->fw_dump_template_len = 0;\r\ndlen = qla27xx_fwdt_template_default_size();\r\nql_dbg(ql_dbg_init, vha, 0x0179,\r\n"-> template allocating %x bytes...\n", dlen);\r\nha->fw_dump_template = vmalloc(dlen);\r\nif (!ha->fw_dump_template) {\r\nql_log(ql_log_warn, vha, 0x017a,\r\n"Failed fwdump template allocate %x bytes.\n", risc_size);\r\ngoto failed_template;\r\n}\r\ndcode = ha->fw_dump_template;\r\nrisc_size = dlen / sizeof(*fwcode);\r\nfwcode = qla27xx_fwdt_template_default();\r\nfor (i = 0; i < risc_size; i++)\r\ndcode[i] = be32_to_cpu(fwcode[i]);\r\nif (!qla27xx_fwdt_template_valid(ha->fw_dump_template)) {\r\nql_log(ql_log_warn, vha, 0x017b,\r\n"Failed fwdump template validate\n");\r\ngoto failed_template;\r\n}\r\ndlen = qla27xx_fwdt_template_size(ha->fw_dump_template);\r\nql_dbg(ql_dbg_init, vha, 0x017c,\r\n"-> template size %x bytes\n", dlen);\r\nha->fw_dump_template_len = dlen;\r\nreturn rval;\r\nfailed_template:\r\nql_log(ql_log_warn, vha, 0x017d, "Failed default fwdump template\n");\r\nif (ha->fw_dump_template)\r\nvfree(ha->fw_dump_template);\r\nha->fw_dump_template = NULL;\r\nha->fw_dump_template_len = 0;\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\r\n{\r\nint rval;\r\nif (ql2xfwloadbin == 1)\r\nreturn qla81xx_load_risc(vha, srisc_addr);\r\nrval = qla24xx_load_risc_blob(vha, srisc_addr);\r\nif (rval == QLA_SUCCESS)\r\nreturn rval;\r\nreturn qla24xx_load_risc_flash(vha, srisc_addr,\r\nvha->hw->flt_region_fw);\r\n}\r\nint\r\nqla81xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ql2xfwloadbin == 2)\r\ngoto try_blob_fw;\r\nrval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_fw);\r\nif (rval == QLA_SUCCESS)\r\nreturn rval;\r\ntry_blob_fw:\r\nrval = qla24xx_load_risc_blob(vha, srisc_addr);\r\nif (rval == QLA_SUCCESS || !ha->flt_region_gold_fw)\r\nreturn rval;\r\nql_log(ql_log_info, vha, 0x0099,\r\n"Attempting to fallback to golden firmware.\n");\r\nrval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_gold_fw);\r\nif (rval != QLA_SUCCESS)\r\nreturn rval;\r\nql_log(ql_log_info, vha, 0x009a, "Update operational firmware.\n");\r\nha->flags.running_gold_fw = 1;\r\nreturn rval;\r\n}\r\nvoid\r\nqla2x00_try_to_stop_firmware(scsi_qla_host_t *vha)\r\n{\r\nint ret, retries;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ha->flags.pci_channel_io_perm_failure)\r\nreturn;\r\nif (!IS_FWI2_CAPABLE(ha))\r\nreturn;\r\nif (!ha->fw_major_version)\r\nreturn;\r\nret = qla2x00_stop_firmware(vha);\r\nfor (retries = 5; ret != QLA_SUCCESS && ret != QLA_FUNCTION_TIMEOUT &&\r\nret != QLA_INVALID_COMMAND && retries ; retries--) {\r\nha->isp_ops->reset_chip(vha);\r\nif (ha->isp_ops->chip_diag(vha) != QLA_SUCCESS)\r\ncontinue;\r\nif (qla2x00_setup_chip(vha) != QLA_SUCCESS)\r\ncontinue;\r\nql_log(ql_log_info, vha, 0x8015,\r\n"Attempting retry of stop-firmware command.\n");\r\nret = qla2x00_stop_firmware(vha);\r\n}\r\n}\r\nint\r\nqla24xx_configure_vhba(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nint rval2;\r\nuint16_t mb[MAILBOX_REGISTER_COUNT];\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nif (!vha->vp_idx)\r\nreturn -EINVAL;\r\nrval = qla2x00_fw_ready(base_vha);\r\nif (ha->flags.cpu_affinity_enabled)\r\nreq = ha->req_q_map[0];\r\nelse\r\nreq = vha->req;\r\nrsp = req->rsp;\r\nif (rval == QLA_SUCCESS) {\r\nclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nqla2x00_marker(vha, req, rsp, 0, 0, MK_SYNC_ALL);\r\n}\r\nvha->flags.management_server_logged_in = 0;\r\nrval2 = ha->isp_ops->fabric_login(vha, NPH_SNS, 0xff, 0xff, 0xfc, mb,\r\nBIT_1);\r\nif (rval2 != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\r\nif (rval2 == QLA_MEMORY_ALLOC_FAILED)\r\nql_dbg(ql_dbg_init, vha, 0x0120,\r\n"Failed SNS login: loop_id=%x, rval2=%d\n",\r\nNPH_SNS, rval2);\r\nelse\r\nql_dbg(ql_dbg_init, vha, 0x0103,\r\n"Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x "\r\n"mb[2]=%x mb[6]=%x mb[7]=%x.\n",\r\nNPH_SNS, mb[0], mb[1], mb[2], mb[6], mb[7]);\r\nreturn (QLA_FUNCTION_FAILED);\r\n}\r\natomic_set(&vha->loop_down_timer, 0);\r\natomic_set(&vha->loop_state, LOOP_UP);\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\r\nrval = qla2x00_loop_resync(base_vha);\r\nreturn rval;\r\n}\r\nstatic struct qla_chip_state_84xx *\r\nqla84xx_get_chip(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_chip_state_84xx *cs84xx;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmutex_lock(&qla_cs84xx_mutex);\r\nlist_for_each_entry(cs84xx, &qla_cs84xx_list, list) {\r\nif (cs84xx->bus == ha->pdev->bus) {\r\nkref_get(&cs84xx->kref);\r\ngoto done;\r\n}\r\n}\r\ncs84xx = kzalloc(sizeof(*cs84xx), GFP_KERNEL);\r\nif (!cs84xx)\r\ngoto done;\r\nkref_init(&cs84xx->kref);\r\nspin_lock_init(&cs84xx->access_lock);\r\nmutex_init(&cs84xx->fw_update_mutex);\r\ncs84xx->bus = ha->pdev->bus;\r\nlist_add_tail(&cs84xx->list, &qla_cs84xx_list);\r\ndone:\r\nmutex_unlock(&qla_cs84xx_mutex);\r\nreturn cs84xx;\r\n}\r\nstatic void\r\n__qla84xx_chip_release(struct kref *kref)\r\n{\r\nstruct qla_chip_state_84xx *cs84xx =\r\ncontainer_of(kref, struct qla_chip_state_84xx, kref);\r\nmutex_lock(&qla_cs84xx_mutex);\r\nlist_del(&cs84xx->list);\r\nmutex_unlock(&qla_cs84xx_mutex);\r\nkfree(cs84xx);\r\n}\r\nvoid\r\nqla84xx_put_chip(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ha->cs84xx)\r\nkref_put(&ha->cs84xx->kref, __qla84xx_chip_release);\r\n}\r\nstatic int\r\nqla84xx_init_chip(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint16_t status[2];\r\nstruct qla_hw_data *ha = vha->hw;\r\nmutex_lock(&ha->cs84xx->fw_update_mutex);\r\nrval = qla84xx_verify_chip(vha, status);\r\nmutex_unlock(&ha->cs84xx->fw_update_mutex);\r\nreturn rval != QLA_SUCCESS || status[0] ? QLA_FUNCTION_FAILED:\r\nQLA_SUCCESS;\r\n}\r\nint\r\nqla81xx_nvram_config(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct init_cb_81xx *icb;\r\nstruct nvram_81xx *nv;\r\nuint32_t *dptr;\r\nuint8_t *dptr1, *dptr2;\r\nuint32_t chksum;\r\nuint16_t cnt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = QLA_SUCCESS;\r\nicb = (struct init_cb_81xx *)ha->init_cb;\r\nnv = ha->nvram;\r\nha->nvram_size = sizeof(struct nvram_81xx);\r\nha->vpd_size = FA_NVRAM_VPD_SIZE;\r\nif (IS_P3P_TYPE(ha) || IS_QLA8031(ha))\r\nha->vpd_size = FA_VPD_SIZE_82XX;\r\nha->vpd = ha->nvram + VPD_OFFSET;\r\nha->isp_ops->read_optrom(vha, ha->vpd, ha->flt_region_vpd << 2,\r\nha->vpd_size);\r\nha->isp_ops->read_optrom(vha, ha->nvram, ha->flt_region_nvram << 2,\r\nha->nvram_size);\r\ndptr = (uint32_t *)nv;\r\nfor (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)\r\nchksum += le32_to_cpu(*dptr);\r\nql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0111,\r\n"Contents of NVRAM:\n");\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0112,\r\n(uint8_t *)nv, ha->nvram_size);\r\nif (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' || nv->id[2] != 'P'\r\n|| nv->id[3] != ' ' ||\r\nnv->nvram_version < cpu_to_le16(ICB_VERSION)) {\r\nql_log(ql_log_info, vha, 0x0073,\r\n"Inconsistent NVRAM detected: checksum=0x%x id=%c "\r\n"version=0x%x.\n", chksum, nv->id[0],\r\nle16_to_cpu(nv->nvram_version));\r\nql_log(ql_log_info, vha, 0x0074,\r\n"Falling back to functioning (yet invalid -- WWPN) "\r\n"defaults.\n");\r\nmemset(nv, 0, ha->nvram_size);\r\nnv->nvram_version = cpu_to_le16(ICB_VERSION);\r\nnv->version = cpu_to_le16(ICB_VERSION);\r\nnv->frame_payload_size = 2048;\r\nnv->execution_throttle = cpu_to_le16(0xFFFF);\r\nnv->exchange_count = cpu_to_le16(0);\r\nnv->port_name[0] = 0x21;\r\nnv->port_name[1] = 0x00 + ha->port_no + 1;\r\nnv->port_name[2] = 0x00;\r\nnv->port_name[3] = 0xe0;\r\nnv->port_name[4] = 0x8b;\r\nnv->port_name[5] = 0x1c;\r\nnv->port_name[6] = 0x55;\r\nnv->port_name[7] = 0x86;\r\nnv->node_name[0] = 0x20;\r\nnv->node_name[1] = 0x00;\r\nnv->node_name[2] = 0x00;\r\nnv->node_name[3] = 0xe0;\r\nnv->node_name[4] = 0x8b;\r\nnv->node_name[5] = 0x1c;\r\nnv->node_name[6] = 0x55;\r\nnv->node_name[7] = 0x86;\r\nnv->login_retry_count = cpu_to_le16(8);\r\nnv->interrupt_delay_timer = cpu_to_le16(0);\r\nnv->login_timeout = cpu_to_le16(0);\r\nnv->firmware_options_1 =\r\ncpu_to_le32(BIT_14|BIT_13|BIT_2|BIT_1);\r\nnv->firmware_options_2 = cpu_to_le32(2 << 4);\r\nnv->firmware_options_2 |= cpu_to_le32(BIT_12);\r\nnv->firmware_options_3 = cpu_to_le32(2 << 13);\r\nnv->host_p = cpu_to_le32(BIT_11|BIT_10);\r\nnv->efi_parameters = cpu_to_le32(0);\r\nnv->reset_delay = 5;\r\nnv->max_luns_per_target = cpu_to_le16(128);\r\nnv->port_down_retry_count = cpu_to_le16(30);\r\nnv->link_down_timeout = cpu_to_le16(180);\r\nnv->enode_mac[0] = 0x00;\r\nnv->enode_mac[1] = 0xC0;\r\nnv->enode_mac[2] = 0xDD;\r\nnv->enode_mac[3] = 0x04;\r\nnv->enode_mac[4] = 0x05;\r\nnv->enode_mac[5] = 0x06 + ha->port_no + 1;\r\nrval = 1;\r\n}\r\nif (IS_T10_PI_CAPABLE(ha))\r\nnv->frame_payload_size &= ~7;\r\nqlt_81xx_config_nvram_stage1(vha, nv);\r\nmemset(icb, 0, ha->init_cb_size);\r\ndptr1 = (uint8_t *)icb;\r\ndptr2 = (uint8_t *)&nv->version;\r\ncnt = (uint8_t *)&icb->response_q_inpointer - (uint8_t *)&icb->version;\r\nwhile (cnt--)\r\n*dptr1++ = *dptr2++;\r\nicb->login_retry_count = nv->login_retry_count;\r\ndptr1 = (uint8_t *)&icb->interrupt_delay_timer;\r\ndptr2 = (uint8_t *)&nv->interrupt_delay_timer;\r\ncnt = (uint8_t *)&icb->reserved_5 -\r\n(uint8_t *)&icb->interrupt_delay_timer;\r\nwhile (cnt--)\r\n*dptr1++ = *dptr2++;\r\nmemcpy(icb->enode_mac, nv->enode_mac, sizeof(icb->enode_mac));\r\nif (!memcmp(icb->enode_mac, "\0\0\0\0\0\0", sizeof(icb->enode_mac))) {\r\nicb->enode_mac[0] = 0x00;\r\nicb->enode_mac[1] = 0xC0;\r\nicb->enode_mac[2] = 0xDD;\r\nicb->enode_mac[3] = 0x04;\r\nicb->enode_mac[4] = 0x05;\r\nicb->enode_mac[5] = 0x06 + ha->port_no + 1;\r\n}\r\nmemcpy(ha->ex_init_cb, &nv->ex_version, sizeof(*ha->ex_init_cb));\r\nqla2x00_set_model_info(vha, nv->model_name, sizeof(nv->model_name),\r\n"QLE8XXX");\r\nqlt_81xx_config_nvram_stage2(vha, icb);\r\nif (nv->host_p & cpu_to_le32(BIT_15)) {\r\nmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\r\nmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\r\n}\r\nif ((icb->firmware_options_1 & cpu_to_le32(BIT_14)) == 0) {\r\nmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\r\nicb->node_name[0] &= 0xF0;\r\n}\r\nha->flags.disable_risc_code_load = 0;\r\nha->flags.enable_lip_reset = 0;\r\nha->flags.enable_lip_full_login =\r\nle32_to_cpu(nv->host_p) & BIT_10 ? 1: 0;\r\nha->flags.enable_target_reset =\r\nle32_to_cpu(nv->host_p) & BIT_11 ? 1: 0;\r\nha->flags.enable_led_scheme = 0;\r\nha->flags.disable_serdes = le32_to_cpu(nv->host_p) & BIT_5 ? 1: 0;\r\nha->operating_mode = (le32_to_cpu(icb->firmware_options_2) &\r\n(BIT_6 | BIT_5 | BIT_4)) >> 4;\r\nha->serial0 = icb->port_name[5];\r\nha->serial1 = icb->port_name[6];\r\nha->serial2 = icb->port_name[7];\r\nmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\r\nmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\r\nicb->execution_throttle = cpu_to_le16(0xFFFF);\r\nha->retry_count = le16_to_cpu(nv->login_retry_count);\r\nif (le16_to_cpu(nv->login_timeout) < ql2xlogintimeout)\r\nnv->login_timeout = cpu_to_le16(ql2xlogintimeout);\r\nif (le16_to_cpu(nv->login_timeout) < 4)\r\nnv->login_timeout = cpu_to_le16(4);\r\nha->login_timeout = le16_to_cpu(nv->login_timeout);\r\nha->r_a_tov = 100;\r\nha->loop_reset_delay = nv->reset_delay;\r\nif (le16_to_cpu(nv->link_down_timeout) == 0) {\r\nha->loop_down_abort_time =\r\n(LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\r\n} else {\r\nha->link_down_timeout = le16_to_cpu(nv->link_down_timeout);\r\nha->loop_down_abort_time =\r\n(LOOP_DOWN_TIME - ha->link_down_timeout);\r\n}\r\nha->port_down_retry_count = le16_to_cpu(nv->port_down_retry_count);\r\nif (qlport_down_retry)\r\nha->port_down_retry_count = qlport_down_retry;\r\nha->login_retry_count = le16_to_cpu(nv->login_retry_count);\r\nif (ha->port_down_retry_count ==\r\nle16_to_cpu(nv->port_down_retry_count) &&\r\nha->port_down_retry_count > 3)\r\nha->login_retry_count = ha->port_down_retry_count;\r\nelse if (ha->port_down_retry_count > (int)ha->login_retry_count)\r\nha->login_retry_count = ha->port_down_retry_count;\r\nif (ql2xloginretrycount)\r\nha->login_retry_count = ql2xloginretrycount;\r\nif (!vha->hw->flags.msix_enabled && (IS_QLA83XX(ha) || IS_QLA27XX(ha)))\r\nicb->firmware_options_2 |= cpu_to_le32(BIT_22);\r\nif (!vha->flags.init_done) {\r\nha->zio_mode = le32_to_cpu(icb->firmware_options_2) &\r\n(BIT_3 | BIT_2 | BIT_1 | BIT_0);\r\nha->zio_timer = le16_to_cpu(icb->interrupt_delay_timer) ?\r\nle16_to_cpu(icb->interrupt_delay_timer): 2;\r\n}\r\nicb->firmware_options_2 &= cpu_to_le32(\r\n~(BIT_3 | BIT_2 | BIT_1 | BIT_0));\r\nvha->flags.process_response_queue = 0;\r\nif (ha->zio_mode != QLA_ZIO_DISABLED) {\r\nha->zio_mode = QLA_ZIO_MODE_6;\r\nql_log(ql_log_info, vha, 0x0075,\r\n"ZIO mode %d enabled; timer delay (%d us).\n",\r\nha->zio_mode,\r\nha->zio_timer * 100);\r\nicb->firmware_options_2 |= cpu_to_le32(\r\n(uint32_t)ha->zio_mode);\r\nicb->interrupt_delay_timer = cpu_to_le16(ha->zio_timer);\r\nvha->flags.process_response_queue = 1;\r\n}\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x0076,\r\n"NVRAM configuration failed.\n");\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla82xx_restart_isp(scsi_qla_host_t *vha)\r\n{\r\nint status, rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\nstruct scsi_qla_host *vp;\r\nunsigned long flags;\r\nstatus = qla2x00_init_rings(vha);\r\nif (!status) {\r\nclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nha->flags.chip_reset_done = 1;\r\nstatus = qla2x00_fw_ready(vha);\r\nif (!status) {\r\nqla2x00_marker(vha, req, rsp, 0, 0, MK_SYNC_ALL);\r\nvha->flags.online = 1;\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\n}\r\nif ((vha->device_flags & DFLG_NO_CABLE))\r\nstatus = 0;\r\n}\r\nif (!status) {\r\nclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nif (!atomic_read(&vha->loop_down_timer)) {\r\nvha->marker_needed = 1;\r\n}\r\nha->isp_ops->enable_intrs(ha);\r\nha->isp_abort_cnt = 0;\r\nclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\r\nstatus = qla82xx_check_md_needed(vha);\r\nif (ha->fce) {\r\nha->flags.fce_enabled = 1;\r\nmemset(ha->fce, 0,\r\nfce_calc_size(ha->fce_bufs));\r\nrval = qla2x00_enable_fce_trace(vha,\r\nha->fce_dma, ha->fce_bufs, ha->fce_mb,\r\n&ha->fce_bufs);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x8001,\r\n"Unable to reinitialize FCE (%d).\n",\r\nrval);\r\nha->flags.fce_enabled = 0;\r\n}\r\n}\r\nif (ha->eft) {\r\nmemset(ha->eft, 0, EFT_SIZE);\r\nrval = qla2x00_enable_eft_trace(vha,\r\nha->eft_dma, EFT_NUM_BUFFERS);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x8010,\r\n"Unable to reinitialize EFT (%d).\n",\r\nrval);\r\n}\r\n}\r\n}\r\nif (!status) {\r\nql_dbg(ql_dbg_taskm, vha, 0x8011,\r\n"qla82xx_restart_isp succeeded.\n");\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\nlist_for_each_entry(vp, &ha->vp_list, list) {\r\nif (vp->vp_idx) {\r\natomic_inc(&vp->vref_count);\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nqla2x00_vp_abort_isp(vp);\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\natomic_dec(&vp->vref_count);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\n} else {\r\nql_log(ql_log_warn, vha, 0x8016,\r\n"qla82xx_restart_isp **** FAILED ****.\n");\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nqla81xx_update_fw_options(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ql2xfwholdabts)\r\nha->fw_options[3] |= BIT_12;\r\nif (!ql2xetsenable)\r\ngoto out;\r\nmemset(ha->fw_options, 0, sizeof(ha->fw_options));\r\nha->fw_options[2] |= BIT_9;\r\nout:\r\nqla2x00_set_fw_options(vha, ha->fw_options);\r\n}\r\nstatic int\r\nqla24xx_get_fcp_prio(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nint i, entries;\r\nuint8_t pid_match, wwn_match;\r\nint priority;\r\nuint32_t pid1, pid2;\r\nuint64_t wwn1, wwn2;\r\nstruct qla_fcp_prio_entry *pri_entry;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->fcp_prio_cfg || !ha->flags.fcp_prio_enabled)\r\nreturn -1;\r\npriority = -1;\r\nentries = ha->fcp_prio_cfg->num_entries;\r\npri_entry = &ha->fcp_prio_cfg->entry[0];\r\nfor (i = 0; i < entries; i++) {\r\npid_match = wwn_match = 0;\r\nif (!(pri_entry->flags & FCP_PRIO_ENTRY_VALID)) {\r\npri_entry++;\r\ncontinue;\r\n}\r\nif (pri_entry->flags & FCP_PRIO_ENTRY_SPID_VALID) {\r\npid1 = pri_entry->src_pid & INVALID_PORT_ID;\r\npid2 = vha->d_id.b24 & INVALID_PORT_ID;\r\nif (pid1 == INVALID_PORT_ID)\r\npid_match++;\r\nelse if (pid1 == pid2)\r\npid_match++;\r\n}\r\nif (pri_entry->flags & FCP_PRIO_ENTRY_DPID_VALID) {\r\npid1 = pri_entry->dst_pid & INVALID_PORT_ID;\r\npid2 = fcport->d_id.b24 & INVALID_PORT_ID;\r\nif (pid1 == INVALID_PORT_ID)\r\npid_match++;\r\nelse if (pid1 == pid2)\r\npid_match++;\r\n}\r\nif (pri_entry->flags & FCP_PRIO_ENTRY_SWWN_VALID) {\r\nwwn1 = wwn_to_u64(vha->port_name);\r\nwwn2 = wwn_to_u64(pri_entry->src_wwpn);\r\nif (wwn2 == (uint64_t)-1)\r\nwwn_match++;\r\nelse if (wwn1 == wwn2)\r\nwwn_match++;\r\n}\r\nif (pri_entry->flags & FCP_PRIO_ENTRY_DWWN_VALID) {\r\nwwn1 = wwn_to_u64(fcport->port_name);\r\nwwn2 = wwn_to_u64(pri_entry->dst_wwpn);\r\nif (wwn2 == (uint64_t)-1)\r\nwwn_match++;\r\nelse if (wwn1 == wwn2)\r\nwwn_match++;\r\n}\r\nif (pid_match == 2 || wwn_match == 2) {\r\nif (pri_entry->flags & FCP_PRIO_ENTRY_TAG_VALID)\r\npriority = pri_entry->tag;\r\nbreak;\r\n}\r\npri_entry++;\r\n}\r\nreturn priority;\r\n}\r\nint\r\nqla24xx_update_fcport_fcp_prio(scsi_qla_host_t *vha, fc_port_t *fcport)\r\n{\r\nint ret;\r\nint priority;\r\nuint16_t mb[5];\r\nif (fcport->port_type != FCT_TARGET ||\r\nfcport->loop_id == FC_NO_LOOP_ID)\r\nreturn QLA_FUNCTION_FAILED;\r\npriority = qla24xx_get_fcp_prio(vha, fcport);\r\nif (priority < 0)\r\nreturn QLA_FUNCTION_FAILED;\r\nif (IS_P3P_TYPE(vha->hw)) {\r\nfcport->fcp_prio = priority & 0xf;\r\nreturn QLA_SUCCESS;\r\n}\r\nret = qla24xx_set_fcp_prio(vha, fcport->loop_id, priority, mb);\r\nif (ret == QLA_SUCCESS) {\r\nif (fcport->fcp_prio != priority)\r\nql_dbg(ql_dbg_user, vha, 0x709e,\r\n"Updated FCP_CMND priority - value=%d loop_id=%d "\r\n"port_id=%02x%02x%02x.\n", priority,\r\nfcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nfcport->fcp_prio = priority & 0xf;\r\n} else\r\nql_dbg(ql_dbg_user, vha, 0x704f,\r\n"Unable to update FCP_CMND priority - ret=0x%x for "\r\n"loop_id=%d port_id=%02x%02x%02x.\n", ret, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa);\r\nreturn ret;\r\n}\r\nint\r\nqla24xx_update_all_fcp_prio(scsi_qla_host_t *vha)\r\n{\r\nint ret;\r\nfc_port_t *fcport;\r\nret = QLA_FUNCTION_FAILED;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list)\r\nret = qla24xx_update_fcport_fcp_prio(vha, fcport);\r\nreturn ret;\r\n}
