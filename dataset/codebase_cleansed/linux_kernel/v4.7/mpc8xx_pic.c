static inline unsigned long mpc8xx_irqd_to_bit(struct irq_data *d)\r\n{\r\nreturn 0x80000000 >> irqd_to_hwirq(d);\r\n}\r\nstatic void mpc8xx_unmask_irq(struct irq_data *d)\r\n{\r\nmpc8xx_cached_irq_mask |= mpc8xx_irqd_to_bit(d);\r\nout_be32(&siu_reg->sc_simask, mpc8xx_cached_irq_mask);\r\n}\r\nstatic void mpc8xx_mask_irq(struct irq_data *d)\r\n{\r\nmpc8xx_cached_irq_mask &= ~mpc8xx_irqd_to_bit(d);\r\nout_be32(&siu_reg->sc_simask, mpc8xx_cached_irq_mask);\r\n}\r\nstatic void mpc8xx_ack(struct irq_data *d)\r\n{\r\nout_be32(&siu_reg->sc_sipend, mpc8xx_irqd_to_bit(d));\r\n}\r\nstatic void mpc8xx_end_irq(struct irq_data *d)\r\n{\r\nmpc8xx_cached_irq_mask |= mpc8xx_irqd_to_bit(d);\r\nout_be32(&siu_reg->sc_simask, mpc8xx_cached_irq_mask);\r\n}\r\nstatic int mpc8xx_set_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nif ((flow_type & IRQ_TYPE_EDGE_FALLING) && !(irqd_to_hwirq(d) & 1)) {\r\nunsigned int siel = in_be32(&siu_reg->sc_siel);\r\nsiel |= mpc8xx_irqd_to_bit(d);\r\nout_be32(&siu_reg->sc_siel, siel);\r\nirq_set_handler_locked(d, handle_edge_irq);\r\n}\r\nreturn 0;\r\n}\r\nunsigned int mpc8xx_get_irq(void)\r\n{\r\nint irq;\r\nirq = in_be32(&siu_reg->sc_sivec) >> 26;\r\nif (irq == PIC_VEC_SPURRIOUS)\r\nirq = NO_IRQ;\r\nreturn irq_linear_revmap(mpc8xx_pic_host, irq);\r\n}\r\nstatic int mpc8xx_pic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\npr_debug("mpc8xx_pic_host_map(%d, 0x%lx)\n", virq, hw);\r\nirq_set_chip_and_handler(virq, &mpc8xx_pic, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic int mpc8xx_pic_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\nstatic unsigned char map_pic_senses[4] = {\r\nIRQ_TYPE_EDGE_RISING,\r\nIRQ_TYPE_LEVEL_LOW,\r\nIRQ_TYPE_LEVEL_HIGH,\r\nIRQ_TYPE_EDGE_FALLING,\r\n};\r\nif (intspec[0] > 0x1f)\r\nreturn 0;\r\n*out_hwirq = intspec[0];\r\nif (intsize > 1 && intspec[1] < 4)\r\n*out_flags = map_pic_senses[intspec[1]];\r\nelse\r\n*out_flags = IRQ_TYPE_NONE;\r\nreturn 0;\r\n}\r\nint mpc8xx_pic_init(void)\r\n{\r\nstruct resource res;\r\nstruct device_node *np;\r\nint ret;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,pq1-pic");\r\nif (np == NULL)\r\nnp = of_find_node_by_type(NULL, "mpc8xx-pic");\r\nif (np == NULL) {\r\nprintk(KERN_ERR "Could not find fsl,pq1-pic node\n");\r\nreturn -ENOMEM;\r\n}\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret)\r\ngoto out;\r\nsiu_reg = ioremap(res.start, resource_size(&res));\r\nif (siu_reg == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmpc8xx_pic_host = irq_domain_add_linear(np, 64, &mpc8xx_pic_host_ops, NULL);\r\nif (mpc8xx_pic_host == NULL) {\r\nprintk(KERN_ERR "MPC8xx PIC: failed to allocate irq host!\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nof_node_put(np);\r\nreturn ret;\r\n}
