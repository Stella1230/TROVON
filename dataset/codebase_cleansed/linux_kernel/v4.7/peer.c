int\r\nlnet_peer_tables_create(void)\r\n{\r\nstruct lnet_peer_table *ptable;\r\nstruct list_head *hash;\r\nint i;\r\nint j;\r\nthe_lnet.ln_peer_tables = cfs_percpt_alloc(lnet_cpt_table(),\r\nsizeof(*ptable));\r\nif (!the_lnet.ln_peer_tables) {\r\nCERROR("Failed to allocate cpu-partition peer tables\n");\r\nreturn -ENOMEM;\r\n}\r\ncfs_percpt_for_each(ptable, i, the_lnet.ln_peer_tables) {\r\nINIT_LIST_HEAD(&ptable->pt_deathrow);\r\nLIBCFS_CPT_ALLOC(hash, lnet_cpt_table(), i,\r\nLNET_PEER_HASH_SIZE * sizeof(*hash));\r\nif (!hash) {\r\nCERROR("Failed to create peer hash table\n");\r\nlnet_peer_tables_destroy();\r\nreturn -ENOMEM;\r\n}\r\nfor (j = 0; j < LNET_PEER_HASH_SIZE; j++)\r\nINIT_LIST_HEAD(&hash[j]);\r\nptable->pt_hash = hash;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_peer_tables_destroy(void)\r\n{\r\nstruct lnet_peer_table *ptable;\r\nstruct list_head *hash;\r\nint i;\r\nint j;\r\nif (!the_lnet.ln_peer_tables)\r\nreturn;\r\ncfs_percpt_for_each(ptable, i, the_lnet.ln_peer_tables) {\r\nhash = ptable->pt_hash;\r\nif (!hash)\r\nbreak;\r\nLASSERT(list_empty(&ptable->pt_deathrow));\r\nptable->pt_hash = NULL;\r\nfor (j = 0; j < LNET_PEER_HASH_SIZE; j++)\r\nLASSERT(list_empty(&hash[j]));\r\nLIBCFS_FREE(hash, LNET_PEER_HASH_SIZE * sizeof(*hash));\r\n}\r\ncfs_percpt_free(the_lnet.ln_peer_tables);\r\nthe_lnet.ln_peer_tables = NULL;\r\n}\r\nstatic void\r\nlnet_peer_table_cleanup_locked(lnet_ni_t *ni, struct lnet_peer_table *ptable)\r\n{\r\nint i;\r\nlnet_peer_t *lp;\r\nlnet_peer_t *tmp;\r\nfor (i = 0; i < LNET_PEER_HASH_SIZE; i++) {\r\nlist_for_each_entry_safe(lp, tmp, &ptable->pt_hash[i],\r\nlp_hashlist) {\r\nif (ni && ni != lp->lp_ni)\r\ncontinue;\r\nlist_del_init(&lp->lp_hashlist);\r\nptable->pt_zombies++;\r\nlnet_peer_decref_locked(lp);\r\n}\r\n}\r\n}\r\nstatic void\r\nlnet_peer_table_deathrow_wait_locked(struct lnet_peer_table *ptable,\r\nint cpt_locked)\r\n{\r\nint i;\r\nfor (i = 3; ptable->pt_zombies; i++) {\r\nlnet_net_unlock(cpt_locked);\r\nif (is_power_of_2(i)) {\r\nCDEBUG(D_WARNING,\r\n"Waiting for %d zombies on peer table\n",\r\nptable->pt_zombies);\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1) >> 1);\r\nlnet_net_lock(cpt_locked);\r\n}\r\n}\r\nstatic void\r\nlnet_peer_table_del_rtrs_locked(lnet_ni_t *ni, struct lnet_peer_table *ptable,\r\nint cpt_locked)\r\n{\r\nlnet_peer_t *lp;\r\nlnet_peer_t *tmp;\r\nlnet_nid_t lp_nid;\r\nint i;\r\nfor (i = 0; i < LNET_PEER_HASH_SIZE; i++) {\r\nlist_for_each_entry_safe(lp, tmp, &ptable->pt_hash[i],\r\nlp_hashlist) {\r\nif (ni != lp->lp_ni)\r\ncontinue;\r\nif (!lp->lp_rtr_refcount)\r\ncontinue;\r\nlp_nid = lp->lp_nid;\r\nlnet_net_unlock(cpt_locked);\r\nlnet_del_route(LNET_NIDNET(LNET_NID_ANY), lp_nid);\r\nlnet_net_lock(cpt_locked);\r\n}\r\n}\r\n}\r\nvoid\r\nlnet_peer_tables_cleanup(lnet_ni_t *ni)\r\n{\r\nstruct lnet_peer_table *ptable;\r\nstruct list_head deathrow;\r\nlnet_peer_t *lp;\r\nlnet_peer_t *temp;\r\nint i;\r\nINIT_LIST_HEAD(&deathrow);\r\nLASSERT(the_lnet.ln_shutdown || ni);\r\ncfs_percpt_for_each(ptable, i, the_lnet.ln_peer_tables) {\r\nlnet_net_lock(i);\r\nlnet_peer_table_del_rtrs_locked(ni, ptable, i);\r\nlnet_net_unlock(i);\r\n}\r\ncfs_percpt_for_each(ptable, i, the_lnet.ln_peer_tables) {\r\nlnet_net_lock(i);\r\nlnet_peer_table_cleanup_locked(ni, ptable);\r\nlnet_net_unlock(i);\r\n}\r\ncfs_percpt_for_each(ptable, i, the_lnet.ln_peer_tables) {\r\nlnet_net_lock(i);\r\nlnet_peer_table_deathrow_wait_locked(ptable, i);\r\nlist_splice_init(&ptable->pt_deathrow, &deathrow);\r\nlnet_net_unlock(i);\r\n}\r\nlist_for_each_entry_safe(lp, temp, &deathrow, lp_hashlist) {\r\nlist_del(&lp->lp_hashlist);\r\nLIBCFS_FREE(lp, sizeof(*lp));\r\n}\r\n}\r\nvoid\r\nlnet_destroy_peer_locked(lnet_peer_t *lp)\r\n{\r\nstruct lnet_peer_table *ptable;\r\nLASSERT(!lp->lp_refcount);\r\nLASSERT(!lp->lp_rtr_refcount);\r\nLASSERT(list_empty(&lp->lp_txq));\r\nLASSERT(list_empty(&lp->lp_hashlist));\r\nLASSERT(!lp->lp_txqnob);\r\nptable = the_lnet.ln_peer_tables[lp->lp_cpt];\r\nLASSERT(ptable->pt_number > 0);\r\nptable->pt_number--;\r\nlnet_ni_decref_locked(lp->lp_ni, lp->lp_cpt);\r\nlp->lp_ni = NULL;\r\nlist_add(&lp->lp_hashlist, &ptable->pt_deathrow);\r\nLASSERT(ptable->pt_zombies > 0);\r\nptable->pt_zombies--;\r\n}\r\nlnet_peer_t *\r\nlnet_find_peer_locked(struct lnet_peer_table *ptable, lnet_nid_t nid)\r\n{\r\nstruct list_head *peers;\r\nlnet_peer_t *lp;\r\nLASSERT(!the_lnet.ln_shutdown);\r\npeers = &ptable->pt_hash[lnet_nid2peerhash(nid)];\r\nlist_for_each_entry(lp, peers, lp_hashlist) {\r\nif (lp->lp_nid == nid) {\r\nlnet_peer_addref_locked(lp);\r\nreturn lp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nlnet_nid2peer_locked(lnet_peer_t **lpp, lnet_nid_t nid, int cpt)\r\n{\r\nstruct lnet_peer_table *ptable;\r\nlnet_peer_t *lp = NULL;\r\nlnet_peer_t *lp2;\r\nint cpt2;\r\nint rc = 0;\r\n*lpp = NULL;\r\nif (the_lnet.ln_shutdown)\r\nreturn -ESHUTDOWN;\r\ncpt2 = cpt != LNET_LOCK_EX ? cpt : lnet_cpt_of_nid_locked(nid);\r\nptable = the_lnet.ln_peer_tables[cpt2];\r\nlp = lnet_find_peer_locked(ptable, nid);\r\nif (lp) {\r\n*lpp = lp;\r\nreturn 0;\r\n}\r\nif (!list_empty(&ptable->pt_deathrow)) {\r\nlp = list_entry(ptable->pt_deathrow.next,\r\nlnet_peer_t, lp_hashlist);\r\nlist_del(&lp->lp_hashlist);\r\n}\r\nptable->pt_number++;\r\nlnet_net_unlock(cpt);\r\nif (lp)\r\nmemset(lp, 0, sizeof(*lp));\r\nelse\r\nLIBCFS_CPT_ALLOC(lp, lnet_cpt_table(), cpt2, sizeof(*lp));\r\nif (!lp) {\r\nrc = -ENOMEM;\r\nlnet_net_lock(cpt);\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&lp->lp_txq);\r\nINIT_LIST_HEAD(&lp->lp_rtrq);\r\nINIT_LIST_HEAD(&lp->lp_routes);\r\nlp->lp_notify = 0;\r\nlp->lp_notifylnd = 0;\r\nlp->lp_notifying = 0;\r\nlp->lp_alive_count = 0;\r\nlp->lp_timestamp = 0;\r\nlp->lp_alive = !lnet_peers_start_down();\r\nlp->lp_last_alive = cfs_time_current();\r\nlp->lp_last_query = 0;\r\nlp->lp_ping_timestamp = 0;\r\nlp->lp_ping_feats = LNET_PING_FEAT_INVAL;\r\nlp->lp_nid = nid;\r\nlp->lp_cpt = cpt2;\r\nlp->lp_refcount = 2;\r\nlp->lp_rtr_refcount = 0;\r\nlnet_net_lock(cpt);\r\nif (the_lnet.ln_shutdown) {\r\nrc = -ESHUTDOWN;\r\ngoto out;\r\n}\r\nlp2 = lnet_find_peer_locked(ptable, nid);\r\nif (lp2) {\r\n*lpp = lp2;\r\ngoto out;\r\n}\r\nlp->lp_ni = lnet_net2ni_locked(LNET_NIDNET(nid), cpt2);\r\nif (!lp->lp_ni) {\r\nrc = -EHOSTUNREACH;\r\ngoto out;\r\n}\r\nlp->lp_txcredits = lp->lp_ni->ni_peertxcredits;\r\nlp->lp_mintxcredits = lp->lp_ni->ni_peertxcredits;\r\nlp->lp_rtrcredits = lnet_peer_buffer_credits(lp->lp_ni);\r\nlp->lp_minrtrcredits = lnet_peer_buffer_credits(lp->lp_ni);\r\nlist_add_tail(&lp->lp_hashlist,\r\n&ptable->pt_hash[lnet_nid2peerhash(nid)]);\r\nptable->pt_version++;\r\n*lpp = lp;\r\nreturn 0;\r\nout:\r\nif (lp)\r\nlist_add(&lp->lp_hashlist, &ptable->pt_deathrow);\r\nptable->pt_number--;\r\nreturn rc;\r\n}\r\nvoid\r\nlnet_debug_peer(lnet_nid_t nid)\r\n{\r\nchar *aliveness = "NA";\r\nlnet_peer_t *lp;\r\nint rc;\r\nint cpt;\r\ncpt = lnet_cpt_of_nid(nid);\r\nlnet_net_lock(cpt);\r\nrc = lnet_nid2peer_locked(&lp, nid, cpt);\r\nif (rc) {\r\nlnet_net_unlock(cpt);\r\nCDEBUG(D_WARNING, "No peer %s\n", libcfs_nid2str(nid));\r\nreturn;\r\n}\r\nif (lnet_isrouter(lp) || lnet_peer_aliveness_enabled(lp))\r\naliveness = lp->lp_alive ? "up" : "down";\r\nCDEBUG(D_WARNING, "%-24s %4d %5s %5d %5d %5d %5d %5d %ld\n",\r\nlibcfs_nid2str(lp->lp_nid), lp->lp_refcount,\r\naliveness, lp->lp_ni->ni_peertxcredits,\r\nlp->lp_rtrcredits, lp->lp_minrtrcredits,\r\nlp->lp_txcredits, lp->lp_mintxcredits, lp->lp_txqnob);\r\nlnet_peer_decref_locked(lp);\r\nlnet_net_unlock(cpt);\r\n}\r\nint\r\nlnet_get_peer_info(__u32 peer_index, __u64 *nid,\r\nchar aliveness[LNET_MAX_STR_LEN],\r\n__u32 *cpt_iter, __u32 *refcount,\r\n__u32 *ni_peer_tx_credits, __u32 *peer_tx_credits,\r\n__u32 *peer_rtr_credits, __u32 *peer_min_rtr_credits,\r\n__u32 *peer_tx_qnob)\r\n{\r\nstruct lnet_peer_table *peer_table;\r\nlnet_peer_t *lp;\r\nbool found = false;\r\nint lncpt, j;\r\nlncpt = cfs_percpt_number(the_lnet.ln_peer_tables);\r\nif (*cpt_iter >= lncpt)\r\nreturn -ENOENT;\r\npeer_table = the_lnet.ln_peer_tables[*cpt_iter];\r\nif (!peer_table)\r\nreturn -ENOENT;\r\nlnet_net_lock(*cpt_iter);\r\nfor (j = 0; j < LNET_PEER_HASH_SIZE && !found; j++) {\r\nstruct list_head *peers = &peer_table->pt_hash[j];\r\nlist_for_each_entry(lp, peers, lp_hashlist) {\r\nif (peer_index-- > 0)\r\ncontinue;\r\nsnprintf(aliveness, LNET_MAX_STR_LEN, "NA");\r\nif (lnet_isrouter(lp) ||\r\nlnet_peer_aliveness_enabled(lp))\r\nsnprintf(aliveness, LNET_MAX_STR_LEN,\r\nlp->lp_alive ? "up" : "down");\r\n*nid = lp->lp_nid;\r\n*refcount = lp->lp_refcount;\r\n*ni_peer_tx_credits = lp->lp_ni->ni_peertxcredits;\r\n*peer_tx_credits = lp->lp_txcredits;\r\n*peer_rtr_credits = lp->lp_rtrcredits;\r\n*peer_min_rtr_credits = lp->lp_mintxcredits;\r\n*peer_tx_qnob = lp->lp_txqnob;\r\nfound = true;\r\n}\r\n}\r\nlnet_net_unlock(*cpt_iter);\r\n*cpt_iter = lncpt;\r\nreturn found ? 0 : -ENOENT;\r\n}
