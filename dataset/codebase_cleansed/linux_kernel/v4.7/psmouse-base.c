psmouse_ret_t psmouse_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nunsigned char *packet = psmouse->packet;\r\nif (psmouse->pktcnt < psmouse->pktsize)\r\nreturn PSMOUSE_GOOD_DATA;\r\nswitch (psmouse->type) {\r\ncase PSMOUSE_IMPS:\r\ninput_report_rel(dev, REL_WHEEL, -(signed char) packet[3]);\r\nbreak;\r\ncase PSMOUSE_IMEX:\r\nswitch (packet[3] & 0xC0) {\r\ncase 0x80:\r\ninput_report_rel(dev, REL_WHEEL, (int) (packet[3] & 32) - (int) (packet[3] & 31));\r\nbreak;\r\ncase 0x40:\r\ninput_report_rel(dev, REL_HWHEEL, (int) (packet[3] & 32) - (int) (packet[3] & 31));\r\nbreak;\r\ncase 0x00:\r\ncase 0xC0:\r\ninput_report_rel(dev, REL_WHEEL, (int) (packet[3] & 8) - (int) (packet[3] & 7));\r\ninput_report_key(dev, BTN_SIDE, (packet[3] >> 4) & 1);\r\ninput_report_key(dev, BTN_EXTRA, (packet[3] >> 5) & 1);\r\nbreak;\r\n}\r\nbreak;\r\ncase PSMOUSE_GENPS:\r\ninput_report_rel(dev, REL_WHEEL, -(signed char) packet[3]);\r\ninput_report_key(dev, BTN_SIDE, (packet[0] >> 6) & 1);\r\ninput_report_key(dev, BTN_EXTRA, (packet[0] >> 7) & 1);\r\nbreak;\r\ncase PSMOUSE_THINKPS:\r\ninput_report_key(dev, BTN_EXTRA, (packet[0] >> 3) & 1);\r\npacket[1] |= (packet[0] & 0x40) << 1;\r\nbreak;\r\ncase PSMOUSE_CORTRON:\r\ninput_report_key(dev, BTN_SIDE, (packet[0] >> 3) & 1);\r\npacket[0] |= 0x08;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninput_report_key(dev, BTN_LEFT, packet[0] & 1);\r\ninput_report_key(dev, BTN_MIDDLE, (packet[0] >> 2) & 1);\r\ninput_report_key(dev, BTN_RIGHT, (packet[0] >> 1) & 1);\r\ninput_report_rel(dev, REL_X, packet[1] ? (int) packet[1] - (int) ((packet[0] << 4) & 0x100) : 0);\r\ninput_report_rel(dev, REL_Y, packet[2] ? (int) ((packet[0] << 3) & 0x100) - (int) packet[2] : 0);\r\ninput_sync(dev);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nvoid psmouse_queue_work(struct psmouse *psmouse, struct delayed_work *work,\r\nunsigned long delay)\r\n{\r\nqueue_delayed_work(kpsmoused_wq, work, delay);\r\n}\r\nstatic inline void __psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state)\r\n{\r\npsmouse->state = new_state;\r\npsmouse->pktcnt = psmouse->out_of_sync_cnt = 0;\r\npsmouse->ps2dev.flags = 0;\r\npsmouse->last = jiffies;\r\n}\r\nvoid psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state)\r\n{\r\nserio_pause_rx(psmouse->ps2dev.serio);\r\n__psmouse_set_state(psmouse, new_state);\r\nserio_continue_rx(psmouse->ps2dev.serio);\r\n}\r\nstatic int psmouse_handle_byte(struct psmouse *psmouse)\r\n{\r\npsmouse_ret_t rc = psmouse->protocol_handler(psmouse);\r\nswitch (rc) {\r\ncase PSMOUSE_BAD_DATA:\r\nif (psmouse->state == PSMOUSE_ACTIVATED) {\r\npsmouse_warn(psmouse,\r\n"%s at %s lost sync at byte %d\n",\r\npsmouse->name, psmouse->phys,\r\npsmouse->pktcnt);\r\nif (++psmouse->out_of_sync_cnt == psmouse->resetafter) {\r\n__psmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\npsmouse_notice(psmouse,\r\n"issuing reconnect request\n");\r\nserio_reconnect(psmouse->ps2dev.serio);\r\nreturn -1;\r\n}\r\n}\r\npsmouse->pktcnt = 0;\r\nbreak;\r\ncase PSMOUSE_FULL_PACKET:\r\npsmouse->pktcnt = 0;\r\nif (psmouse->out_of_sync_cnt) {\r\npsmouse->out_of_sync_cnt = 0;\r\npsmouse_notice(psmouse,\r\n"%s at %s - driver resynced.\n",\r\npsmouse->name, psmouse->phys);\r\n}\r\nbreak;\r\ncase PSMOUSE_GOOD_DATA:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t psmouse_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct psmouse *psmouse = serio_get_drvdata(serio);\r\nif (psmouse->state == PSMOUSE_IGNORE)\r\ngoto out;\r\nif (unlikely((flags & SERIO_TIMEOUT) ||\r\n((flags & SERIO_PARITY) && !psmouse->ignore_parity))) {\r\nif (psmouse->state == PSMOUSE_ACTIVATED)\r\npsmouse_warn(psmouse,\r\n"bad data from KBC -%s%s\n",\r\nflags & SERIO_TIMEOUT ? " timeout" : "",\r\nflags & SERIO_PARITY ? " bad parity" : "");\r\nps2_cmd_aborted(&psmouse->ps2dev);\r\ngoto out;\r\n}\r\nif (unlikely(psmouse->ps2dev.flags & PS2_FLAG_ACK))\r\nif (ps2_handle_ack(&psmouse->ps2dev, data))\r\ngoto out;\r\nif (unlikely(psmouse->ps2dev.flags & PS2_FLAG_CMD))\r\nif (ps2_handle_response(&psmouse->ps2dev, data))\r\ngoto out;\r\nif (psmouse->state <= PSMOUSE_RESYNCING)\r\ngoto out;\r\nif (psmouse->state == PSMOUSE_ACTIVATED &&\r\npsmouse->pktcnt && time_after(jiffies, psmouse->last + HZ/2)) {\r\npsmouse_info(psmouse, "%s at %s lost synchronization, throwing %d bytes away.\n",\r\npsmouse->name, psmouse->phys, psmouse->pktcnt);\r\npsmouse->badbyte = psmouse->packet[0];\r\n__psmouse_set_state(psmouse, PSMOUSE_RESYNCING);\r\npsmouse_queue_work(psmouse, &psmouse->resync_work, 0);\r\ngoto out;\r\n}\r\npsmouse->packet[psmouse->pktcnt++] = data;\r\nif (unlikely(psmouse->packet[0] == PSMOUSE_RET_BAT && psmouse->pktcnt <= 2)) {\r\nif (psmouse->pktcnt == 1) {\r\npsmouse->last = jiffies;\r\ngoto out;\r\n}\r\nif (psmouse->packet[1] == PSMOUSE_RET_ID ||\r\n(psmouse->type == PSMOUSE_HGPK &&\r\npsmouse->packet[1] == PSMOUSE_RET_BAT)) {\r\n__psmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\nserio_reconnect(serio);\r\ngoto out;\r\n}\r\npsmouse->pktcnt = 1;\r\nif (psmouse_handle_byte(psmouse))\r\ngoto out;\r\npsmouse->packet[psmouse->pktcnt++] = data;\r\n}\r\nif (psmouse->state == PSMOUSE_ACTIVATED &&\r\npsmouse->pktcnt == 1 && psmouse->resync_time &&\r\ntime_after(jiffies, psmouse->last + psmouse->resync_time * HZ)) {\r\npsmouse->badbyte = psmouse->packet[0];\r\n__psmouse_set_state(psmouse, PSMOUSE_RESYNCING);\r\npsmouse_queue_work(psmouse, &psmouse->resync_work, 0);\r\ngoto out;\r\n}\r\npsmouse->last = jiffies;\r\npsmouse_handle_byte(psmouse);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nint psmouse_sliced_command(struct psmouse *psmouse, unsigned char command)\r\n{\r\nint i;\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11))\r\nreturn -1;\r\nfor (i = 6; i >= 0; i -= 2) {\r\nunsigned char d = (command >> i) & 3;\r\nif (ps2_command(&psmouse->ps2dev, &d, PSMOUSE_CMD_SETRES))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint psmouse_reset(struct psmouse *psmouse)\r\n{\r\nunsigned char param[2];\r\nif (ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_RESET_BAT))\r\nreturn -1;\r\nif (param[0] != PSMOUSE_RET_BAT && param[1] != PSMOUSE_RET_ID)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid psmouse_set_resolution(struct psmouse *psmouse, unsigned int resolution)\r\n{\r\nstatic const unsigned char params[] = { 0, 1, 2, 2, 3 };\r\nunsigned char p;\r\nif (resolution == 0 || resolution > 200)\r\nresolution = 200;\r\np = params[resolution / 50];\r\nps2_command(&psmouse->ps2dev, &p, PSMOUSE_CMD_SETRES);\r\npsmouse->resolution = 25 << p;\r\n}\r\nstatic void psmouse_set_rate(struct psmouse *psmouse, unsigned int rate)\r\n{\r\nstatic const unsigned char rates[] = { 200, 100, 80, 60, 40, 20, 10, 0 };\r\nunsigned char r;\r\nint i = 0;\r\nwhile (rates[i] > rate) i++;\r\nr = rates[i];\r\nps2_command(&psmouse->ps2dev, &r, PSMOUSE_CMD_SETRATE);\r\npsmouse->rate = r;\r\n}\r\nstatic void psmouse_set_scale(struct psmouse *psmouse, enum psmouse_scale scale)\r\n{\r\nps2_command(&psmouse->ps2dev, NULL,\r\nscale == PSMOUSE_SCALE21 ? PSMOUSE_CMD_SETSCALE21 :\r\nPSMOUSE_CMD_SETSCALE11);\r\n}\r\nstatic int psmouse_poll(struct psmouse *psmouse)\r\n{\r\nreturn ps2_command(&psmouse->ps2dev, psmouse->packet,\r\nPSMOUSE_CMD_POLL | (psmouse->pktsize << 8));\r\n}\r\nstatic bool psmouse_check_pnp_id(const char *id, const char * const ids[])\r\n{\r\nint i;\r\nfor (i = 0; ids[i]; i++)\r\nif (!strcasecmp(id, ids[i]))\r\nreturn true;\r\nreturn false;\r\n}\r\nbool psmouse_matches_pnp_id(struct psmouse *psmouse, const char * const ids[])\r\n{\r\nstruct serio *serio = psmouse->ps2dev.serio;\r\nchar *p, *fw_id_copy, *save_ptr;\r\nbool found = false;\r\nif (strncmp(serio->firmware_id, "PNP: ", 5))\r\nreturn false;\r\nfw_id_copy = kstrndup(&serio->firmware_id[5],\r\nsizeof(serio->firmware_id) - 5,\r\nGFP_KERNEL);\r\nif (!fw_id_copy)\r\nreturn false;\r\nsave_ptr = fw_id_copy;\r\nwhile ((p = strsep(&fw_id_copy, " ")) != NULL) {\r\nif (psmouse_check_pnp_id(p, ids)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nkfree(save_ptr);\r\nreturn found;\r\n}\r\nstatic int genius_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\nparam[0] = 3;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11);\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11);\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO);\r\nif (param[0] != 0x00 || param[1] != 0x33 || param[2] != 0x55)\r\nreturn -1;\r\nif (set_properties) {\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\n__set_bit(BTN_EXTRA, psmouse->dev->keybit);\r\n__set_bit(BTN_SIDE, psmouse->dev->keybit);\r\n__set_bit(REL_WHEEL, psmouse->dev->relbit);\r\npsmouse->vendor = "Genius";\r\npsmouse->name = "Mouse";\r\npsmouse->pktsize = 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intellimouse_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[2];\r\nparam[0] = 200;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 100;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 80;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\r\nif (param[0] != 3)\r\nreturn -1;\r\nif (set_properties) {\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\n__set_bit(REL_WHEEL, psmouse->dev->relbit);\r\nif (!psmouse->vendor)\r\npsmouse->vendor = "Generic";\r\nif (!psmouse->name)\r\npsmouse->name = "Wheel Mouse";\r\npsmouse->pktsize = 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int im_explorer_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[2];\r\nintellimouse_detect(psmouse, 0);\r\nparam[0] = 200;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 200;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 80;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\r\nif (param[0] != 4)\r\nreturn -1;\r\nparam[0] = 200;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 80;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 40;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nif (set_properties) {\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\n__set_bit(REL_WHEEL, psmouse->dev->relbit);\r\n__set_bit(REL_HWHEEL, psmouse->dev->relbit);\r\n__set_bit(BTN_SIDE, psmouse->dev->keybit);\r\n__set_bit(BTN_EXTRA, psmouse->dev->keybit);\r\nif (!psmouse->vendor)\r\npsmouse->vendor = "Generic";\r\nif (!psmouse->name)\r\npsmouse->name = "Explorer Mouse";\r\npsmouse->pktsize = 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int thinking_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[2];\r\nstatic const unsigned char seq[] = { 20, 60, 40, 20, 20, 60, 40, 20, 20 };\r\nint i;\r\nparam[0] = 10;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\nparam[0] = 0;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\r\nfor (i = 0; i < ARRAY_SIZE(seq); i++) {\r\nparam[0] = seq[i];\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE);\r\n}\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETID);\r\nif (param[0] != 2)\r\nreturn -1;\r\nif (set_properties) {\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\n__set_bit(BTN_EXTRA, psmouse->dev->keybit);\r\npsmouse->vendor = "Kensington";\r\npsmouse->name = "ThinkingMouse";\r\n}\r\nreturn 0;\r\n}\r\nstatic int ps2bare_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nif (set_properties) {\r\nif (!psmouse->vendor)\r\npsmouse->vendor = "Generic";\r\nif (!psmouse->name)\r\npsmouse->name = "Mouse";\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cortron_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nif (set_properties) {\r\npsmouse->vendor = "Cortron";\r\npsmouse->name = "PS/2 Trackball";\r\n__set_bit(BTN_MIDDLE, psmouse->dev->keybit);\r\n__set_bit(BTN_SIDE, psmouse->dev->keybit);\r\n}\r\nreturn 0;\r\n}\r\nstatic const struct psmouse_protocol *__psmouse_protocol_by_type(enum psmouse_type type)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(psmouse_protocols); i++)\r\nif (psmouse_protocols[i].type == type)\r\nreturn &psmouse_protocols[i];\r\nreturn NULL;\r\n}\r\nstatic const struct psmouse_protocol *psmouse_protocol_by_type(enum psmouse_type type)\r\n{\r\nconst struct psmouse_protocol *proto;\r\nproto = __psmouse_protocol_by_type(type);\r\nif (proto)\r\nreturn proto;\r\nWARN_ON(1);\r\nreturn &psmouse_protocols[0];\r\n}\r\nstatic const struct psmouse_protocol *psmouse_protocol_by_name(const char *name, size_t len)\r\n{\r\nconst struct psmouse_protocol *p;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(psmouse_protocols); i++) {\r\np = &psmouse_protocols[i];\r\nif ((strlen(p->name) == len && !strncmp(p->name, name, len)) ||\r\n(strlen(p->alias) == len && !strncmp(p->alias, name, len)))\r\nreturn &psmouse_protocols[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void psmouse_apply_defaults(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *input_dev = psmouse->dev;\r\nmemset(input_dev->evbit, 0, sizeof(input_dev->evbit));\r\nmemset(input_dev->keybit, 0, sizeof(input_dev->keybit));\r\nmemset(input_dev->relbit, 0, sizeof(input_dev->relbit));\r\nmemset(input_dev->absbit, 0, sizeof(input_dev->absbit));\r\nmemset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_REL, input_dev->evbit);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\n__set_bit(REL_X, input_dev->relbit);\r\n__set_bit(REL_Y, input_dev->relbit);\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\npsmouse->set_rate = psmouse_set_rate;\r\npsmouse->set_resolution = psmouse_set_resolution;\r\npsmouse->set_scale = psmouse_set_scale;\r\npsmouse->poll = psmouse_poll;\r\npsmouse->protocol_handler = psmouse_process_byte;\r\npsmouse->pktsize = 3;\r\npsmouse->reconnect = NULL;\r\npsmouse->disconnect = NULL;\r\npsmouse->cleanup = NULL;\r\npsmouse->pt_activate = NULL;\r\npsmouse->pt_deactivate = NULL;\r\n}\r\nstatic bool psmouse_try_protocol(struct psmouse *psmouse,\r\nenum psmouse_type type,\r\nunsigned int *max_proto,\r\nbool set_properties, bool init_allowed)\r\n{\r\nconst struct psmouse_protocol *proto;\r\nproto = __psmouse_protocol_by_type(type);\r\nif (!proto)\r\nreturn false;\r\nif (psmouse->ps2dev.serio->id.type == SERIO_PS_PSTHRU &&\r\n!proto->try_passthru) {\r\nreturn false;\r\n}\r\nif (set_properties)\r\npsmouse_apply_defaults(psmouse);\r\nif (proto->detect(psmouse, set_properties) != 0)\r\nreturn false;\r\nif (set_properties && proto->init && init_allowed) {\r\nif (proto->init(psmouse) != 0) {\r\nif (*max_proto > PSMOUSE_IMEX)\r\n*max_proto = PSMOUSE_IMEX;\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int psmouse_extensions(struct psmouse *psmouse,\r\nunsigned int max_proto, bool set_properties)\r\n{\r\nbool synaptics_hardware = false;\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_FOCALTECH,\r\n&max_proto, set_properties, false)) {\r\nif (max_proto > PSMOUSE_IMEX &&\r\nIS_ENABLED(CONFIG_MOUSE_PS2_FOCALTECH) &&\r\n(!set_properties || focaltech_init(psmouse) == 0)) {\r\nreturn PSMOUSE_FOCALTECH;\r\n}\r\npsmouse_max_proto = max_proto = PSMOUSE_PS2;\r\n}\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_LIFEBOOK, &max_proto,\r\nset_properties, max_proto > PSMOUSE_IMEX))\r\nreturn PSMOUSE_LIFEBOOK;\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_VMMOUSE, &max_proto,\r\nset_properties, max_proto > PSMOUSE_IMEX))\r\nreturn PSMOUSE_VMMOUSE;\r\nif (max_proto > PSMOUSE_IMEX &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_THINKPS, &max_proto,\r\nset_properties, true)) {\r\nreturn PSMOUSE_THINKPS;\r\n}\r\nif (max_proto > PSMOUSE_PS2 &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_SYNAPTICS, &max_proto,\r\nset_properties, false)) {\r\nsynaptics_hardware = true;\r\nif (max_proto > PSMOUSE_IMEX) {\r\nif (IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS) &&\r\n(!set_properties || synaptics_init(psmouse) == 0)) {\r\nreturn PSMOUSE_SYNAPTICS;\r\n}\r\nmax_proto = PSMOUSE_IMEX;\r\n}\r\nsynaptics_reset(psmouse);\r\n}\r\nif (max_proto > PSMOUSE_IMEX &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_CYPRESS, &max_proto,\r\nset_properties, true)) {\r\nreturn PSMOUSE_CYPRESS;\r\n}\r\nif (max_proto > PSMOUSE_IMEX) {\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_ALPS,\r\n&max_proto, set_properties, true))\r\nreturn PSMOUSE_ALPS;\r\n}\r\nif (max_proto > PSMOUSE_IMEX &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_HGPK, &max_proto,\r\nset_properties, true)) {\r\nreturn PSMOUSE_HGPK;\r\n}\r\nif (max_proto > PSMOUSE_IMEX &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_ELANTECH,\r\n&max_proto, set_properties, true)) {\r\nreturn PSMOUSE_ELANTECH;\r\n}\r\nif (max_proto > PSMOUSE_IMEX) {\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_GENPS,\r\n&max_proto, set_properties, true))\r\nreturn PSMOUSE_GENPS;\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_PS2PP,\r\n&max_proto, set_properties, true))\r\nreturn PSMOUSE_PS2PP;\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_TRACKPOINT,\r\n&max_proto, set_properties, true))\r\nreturn PSMOUSE_TRACKPOINT;\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_TOUCHKIT_PS2,\r\n&max_proto, set_properties, true))\r\nreturn PSMOUSE_TOUCHKIT_PS2;\r\nif (psmouse_try_protocol(psmouse, PSMOUSE_BYD,\r\n&max_proto, set_properties, true))\r\nreturn PSMOUSE_BYD;\r\n}\r\nif (max_proto > PSMOUSE_IMEX &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_FSP,\r\n&max_proto, set_properties, true)) {\r\nreturn PSMOUSE_FSP;\r\n}\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\r\npsmouse_reset(psmouse);\r\nif (max_proto >= PSMOUSE_IMEX &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_IMEX,\r\n&max_proto, set_properties, true)) {\r\nreturn PSMOUSE_IMEX;\r\n}\r\nif (max_proto >= PSMOUSE_IMPS &&\r\npsmouse_try_protocol(psmouse, PSMOUSE_IMPS,\r\n&max_proto, set_properties, true)) {\r\nreturn PSMOUSE_IMPS;\r\n}\r\npsmouse_try_protocol(psmouse, PSMOUSE_PS2,\r\n&max_proto, set_properties, true);\r\nif (synaptics_hardware) {\r\npsmouse_reset(psmouse);\r\n}\r\nreturn PSMOUSE_PS2;\r\n}\r\nstatic int psmouse_probe(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[2];\r\nparam[0] = 0xa5;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETID))\r\nreturn -1;\r\nif (param[0] != 0x00 && param[0] != 0x03 &&\r\nparam[0] != 0x04 && param[0] != 0xff)\r\nreturn -1;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_DIS))\r\npsmouse_warn(psmouse, "Failed to reset mouse on %s\n",\r\nps2dev->serio->phys);\r\nreturn 0;\r\n}\r\nstatic void psmouse_initialize(struct psmouse *psmouse)\r\n{\r\nif (psmouse_max_proto != PSMOUSE_PS2) {\r\npsmouse->set_rate(psmouse, psmouse->rate);\r\npsmouse->set_resolution(psmouse, psmouse->resolution);\r\npsmouse->set_scale(psmouse, PSMOUSE_SCALE11);\r\n}\r\n}\r\nint psmouse_activate(struct psmouse *psmouse)\r\n{\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\npsmouse_warn(psmouse, "Failed to enable mouse on %s\n",\r\npsmouse->ps2dev.serio->phys);\r\nreturn -1;\r\n}\r\npsmouse_set_state(psmouse, PSMOUSE_ACTIVATED);\r\nreturn 0;\r\n}\r\nint psmouse_deactivate(struct psmouse *psmouse)\r\n{\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_DISABLE)) {\r\npsmouse_warn(psmouse, "Failed to deactivate mouse on %s\n",\r\npsmouse->ps2dev.serio->phys);\r\nreturn -1;\r\n}\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\nreturn 0;\r\n}\r\nstatic void psmouse_resync(struct work_struct *work)\r\n{\r\nstruct psmouse *parent = NULL, *psmouse =\r\ncontainer_of(work, struct psmouse, resync_work.work);\r\nstruct serio *serio = psmouse->ps2dev.serio;\r\npsmouse_ret_t rc = PSMOUSE_GOOD_DATA;\r\nbool failed = false, enabled = false;\r\nint i;\r\nmutex_lock(&psmouse_mutex);\r\nif (psmouse->state != PSMOUSE_RESYNCING)\r\ngoto out;\r\nif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\r\nparent = serio_get_drvdata(serio->parent);\r\npsmouse_deactivate(parent);\r\n}\r\npsmouse->num_resyncs++;\r\nif (ps2_sendbyte(&psmouse->ps2dev, PSMOUSE_CMD_DISABLE, 20)) {\r\nif (psmouse->num_resyncs < 3 || psmouse->acks_disable_command)\r\nfailed = true;\r\n} else\r\npsmouse->acks_disable_command = true;\r\nif (!failed) {\r\nif (psmouse->poll(psmouse))\r\nfailed = true;\r\nelse {\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\nfor (i = 0; i < psmouse->pktsize; i++) {\r\npsmouse->pktcnt++;\r\nrc = psmouse->protocol_handler(psmouse);\r\nif (rc != PSMOUSE_GOOD_DATA)\r\nbreak;\r\n}\r\nif (rc != PSMOUSE_FULL_PACKET)\r\nfailed = true;\r\npsmouse_set_state(psmouse, PSMOUSE_RESYNCING);\r\n}\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nif (!ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\nenabled = true;\r\nbreak;\r\n}\r\nmsleep(200);\r\n}\r\nif (!enabled) {\r\npsmouse_warn(psmouse, "failed to re-enable mouse on %s\n",\r\npsmouse->ps2dev.serio->phys);\r\nfailed = true;\r\n}\r\nif (failed) {\r\npsmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\npsmouse_info(psmouse,\r\n"resync failed, issuing reconnect request\n");\r\nserio_reconnect(serio);\r\n} else\r\npsmouse_set_state(psmouse, PSMOUSE_ACTIVATED);\r\nif (parent)\r\npsmouse_activate(parent);\r\nout:\r\nmutex_unlock(&psmouse_mutex);\r\n}\r\nstatic void psmouse_cleanup(struct serio *serio)\r\n{\r\nstruct psmouse *psmouse = serio_get_drvdata(serio);\r\nstruct psmouse *parent = NULL;\r\nmutex_lock(&psmouse_mutex);\r\nif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\r\nparent = serio_get_drvdata(serio->parent);\r\npsmouse_deactivate(parent);\r\n}\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_DISABLE))\r\npsmouse_warn(psmouse, "Failed to disable mouse on %s\n",\r\npsmouse->ps2dev.serio->phys);\r\nif (psmouse->cleanup)\r\npsmouse->cleanup(psmouse);\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);\r\nps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_ENABLE);\r\nif (parent) {\r\nif (parent->pt_deactivate)\r\nparent->pt_deactivate(parent);\r\npsmouse_activate(parent);\r\n}\r\nmutex_unlock(&psmouse_mutex);\r\n}\r\nstatic void psmouse_disconnect(struct serio *serio)\r\n{\r\nstruct psmouse *psmouse, *parent = NULL;\r\npsmouse = serio_get_drvdata(serio);\r\nsysfs_remove_group(&serio->dev.kobj, &psmouse_attribute_group);\r\nmutex_lock(&psmouse_mutex);\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\nmutex_unlock(&psmouse_mutex);\r\nflush_workqueue(kpsmoused_wq);\r\nmutex_lock(&psmouse_mutex);\r\nif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\r\nparent = serio_get_drvdata(serio->parent);\r\npsmouse_deactivate(parent);\r\n}\r\nif (psmouse->disconnect)\r\npsmouse->disconnect(psmouse);\r\nif (parent && parent->pt_deactivate)\r\nparent->pt_deactivate(parent);\r\npsmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(psmouse->dev);\r\nkfree(psmouse);\r\nif (parent)\r\npsmouse_activate(parent);\r\nmutex_unlock(&psmouse_mutex);\r\n}\r\nstatic int psmouse_switch_protocol(struct psmouse *psmouse,\r\nconst struct psmouse_protocol *proto)\r\n{\r\nconst struct psmouse_protocol *selected_proto;\r\nstruct input_dev *input_dev = psmouse->dev;\r\ninput_dev->dev.parent = &psmouse->ps2dev.serio->dev;\r\nif (proto && (proto->detect || proto->init)) {\r\npsmouse_apply_defaults(psmouse);\r\nif (proto->detect && proto->detect(psmouse, true) < 0)\r\nreturn -1;\r\nif (proto->init && proto->init(psmouse) < 0)\r\nreturn -1;\r\npsmouse->type = proto->type;\r\nselected_proto = proto;\r\n} else {\r\npsmouse->type = psmouse_extensions(psmouse,\r\npsmouse_max_proto, true);\r\nselected_proto = psmouse_protocol_by_type(psmouse->type);\r\n}\r\npsmouse->ignore_parity = selected_proto->ignore_parity;\r\nif (psmouse->pktsize == 3)\r\npsmouse->resync_time = 0;\r\nif (psmouse->resync_time && psmouse->poll(psmouse))\r\npsmouse->resync_time = 0;\r\nsnprintf(psmouse->devname, sizeof(psmouse->devname), "%s %s %s",\r\nselected_proto->name, psmouse->vendor, psmouse->name);\r\ninput_dev->name = psmouse->devname;\r\ninput_dev->phys = psmouse->phys;\r\ninput_dev->id.bustype = BUS_I8042;\r\ninput_dev->id.vendor = 0x0002;\r\ninput_dev->id.product = psmouse->type;\r\ninput_dev->id.version = psmouse->model;\r\nreturn 0;\r\n}\r\nstatic int psmouse_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct psmouse *psmouse, *parent = NULL;\r\nstruct input_dev *input_dev;\r\nint retval = 0, error = -ENOMEM;\r\nmutex_lock(&psmouse_mutex);\r\nif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\r\nparent = serio_get_drvdata(serio->parent);\r\npsmouse_deactivate(parent);\r\n}\r\npsmouse = kzalloc(sizeof(struct psmouse), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!psmouse || !input_dev)\r\ngoto err_free;\r\nps2_init(&psmouse->ps2dev, serio);\r\nINIT_DELAYED_WORK(&psmouse->resync_work, psmouse_resync);\r\npsmouse->dev = input_dev;\r\nsnprintf(psmouse->phys, sizeof(psmouse->phys), "%s/input0", serio->phys);\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\nserio_set_drvdata(serio, psmouse);\r\nerror = serio_open(serio, drv);\r\nif (error)\r\ngoto err_clear_drvdata;\r\nif (serio->id.type == SERIO_PS_PSTHRU)\r\nusleep_range(10000, 15000);\r\nif (psmouse_probe(psmouse) < 0) {\r\nerror = -ENODEV;\r\ngoto err_close_serio;\r\n}\r\npsmouse->rate = psmouse_rate;\r\npsmouse->resolution = psmouse_resolution;\r\npsmouse->resetafter = psmouse_resetafter;\r\npsmouse->resync_time = parent ? 0 : psmouse_resync_time;\r\npsmouse->smartscroll = psmouse_smartscroll;\r\npsmouse_switch_protocol(psmouse, NULL);\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\npsmouse_initialize(psmouse);\r\nerror = input_register_device(psmouse->dev);\r\nif (error)\r\ngoto err_protocol_disconnect;\r\nif (parent && parent->pt_activate)\r\nparent->pt_activate(parent);\r\nerror = sysfs_create_group(&serio->dev.kobj, &psmouse_attribute_group);\r\nif (error)\r\ngoto err_pt_deactivate;\r\npsmouse_activate(psmouse);\r\nout:\r\nif (parent)\r\npsmouse_activate(parent);\r\nmutex_unlock(&psmouse_mutex);\r\nreturn retval;\r\nerr_pt_deactivate:\r\nif (parent && parent->pt_deactivate)\r\nparent->pt_deactivate(parent);\r\ninput_unregister_device(psmouse->dev);\r\ninput_dev = NULL;\r\nerr_protocol_disconnect:\r\nif (psmouse->disconnect)\r\npsmouse->disconnect(psmouse);\r\npsmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\nerr_close_serio:\r\nserio_close(serio);\r\nerr_clear_drvdata:\r\nserio_set_drvdata(serio, NULL);\r\nerr_free:\r\ninput_free_device(input_dev);\r\nkfree(psmouse);\r\nretval = error;\r\ngoto out;\r\n}\r\nstatic int psmouse_reconnect(struct serio *serio)\r\n{\r\nstruct psmouse *psmouse = serio_get_drvdata(serio);\r\nstruct psmouse *parent = NULL;\r\nunsigned char type;\r\nint rc = -1;\r\nmutex_lock(&psmouse_mutex);\r\nif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\r\nparent = serio_get_drvdata(serio->parent);\r\npsmouse_deactivate(parent);\r\n}\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\nif (psmouse->reconnect) {\r\nif (psmouse->reconnect(psmouse))\r\ngoto out;\r\n} else {\r\npsmouse_reset(psmouse);\r\nif (psmouse_probe(psmouse) < 0)\r\ngoto out;\r\ntype = psmouse_extensions(psmouse, psmouse_max_proto, false);\r\nif (psmouse->type != type)\r\ngoto out;\r\n}\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\npsmouse_initialize(psmouse);\r\nif (parent && parent->pt_activate)\r\nparent->pt_activate(parent);\r\npsmouse_activate(psmouse);\r\nrc = 0;\r\nout:\r\nif (parent)\r\npsmouse_activate(parent);\r\nmutex_unlock(&psmouse_mutex);\r\nreturn rc;\r\n}\r\nssize_t psmouse_attr_show_helper(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct psmouse_attribute *attr = to_psmouse_attr(devattr);\r\nstruct psmouse *psmouse;\r\npsmouse = serio_get_drvdata(serio);\r\nreturn attr->show(psmouse, attr->data, buf);\r\n}\r\nssize_t psmouse_attr_set_helper(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct psmouse_attribute *attr = to_psmouse_attr(devattr);\r\nstruct psmouse *psmouse, *parent = NULL;\r\nint retval;\r\nretval = mutex_lock_interruptible(&psmouse_mutex);\r\nif (retval)\r\ngoto out;\r\npsmouse = serio_get_drvdata(serio);\r\nif (attr->protect) {\r\nif (psmouse->state == PSMOUSE_IGNORE) {\r\nretval = -ENODEV;\r\ngoto out_unlock;\r\n}\r\nif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\r\nparent = serio_get_drvdata(serio->parent);\r\npsmouse_deactivate(parent);\r\n}\r\npsmouse_deactivate(psmouse);\r\n}\r\nretval = attr->set(psmouse, attr->data, buf, count);\r\nif (attr->protect) {\r\nif (retval != -ENODEV)\r\npsmouse_activate(psmouse);\r\nif (parent)\r\npsmouse_activate(parent);\r\n}\r\nout_unlock:\r\nmutex_unlock(&psmouse_mutex);\r\nout:\r\nreturn retval;\r\n}\r\nstatic ssize_t psmouse_show_int_attr(struct psmouse *psmouse, void *offset, char *buf)\r\n{\r\nunsigned int *field = (unsigned int *)((char *)psmouse + (size_t)offset);\r\nreturn sprintf(buf, "%u\n", *field);\r\n}\r\nstatic ssize_t psmouse_set_int_attr(struct psmouse *psmouse, void *offset, const char *buf, size_t count)\r\n{\r\nunsigned int *field = (unsigned int *)((char *)psmouse + (size_t)offset);\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\n*field = value;\r\nreturn count;\r\n}\r\nstatic ssize_t psmouse_attr_show_protocol(struct psmouse *psmouse, void *data, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", psmouse_protocol_by_type(psmouse->type)->name);\r\n}\r\nstatic ssize_t psmouse_attr_set_protocol(struct psmouse *psmouse, void *data, const char *buf, size_t count)\r\n{\r\nstruct serio *serio = psmouse->ps2dev.serio;\r\nstruct psmouse *parent = NULL;\r\nstruct input_dev *old_dev, *new_dev;\r\nconst struct psmouse_protocol *proto, *old_proto;\r\nint error;\r\nint retry = 0;\r\nproto = psmouse_protocol_by_name(buf, count);\r\nif (!proto)\r\nreturn -EINVAL;\r\nif (psmouse->type == proto->type)\r\nreturn count;\r\nnew_dev = input_allocate_device();\r\nif (!new_dev)\r\nreturn -ENOMEM;\r\nwhile (!list_empty(&serio->children)) {\r\nif (++retry > 3) {\r\npsmouse_warn(psmouse,\r\n"failed to destroy children ports, protocol change aborted.\n");\r\ninput_free_device(new_dev);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&psmouse_mutex);\r\nserio_unregister_child_port(serio);\r\nmutex_lock(&psmouse_mutex);\r\nif (serio->drv != &psmouse_drv) {\r\ninput_free_device(new_dev);\r\nreturn -ENODEV;\r\n}\r\nif (psmouse->type == proto->type) {\r\ninput_free_device(new_dev);\r\nreturn count;\r\n}\r\n}\r\nif (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {\r\nparent = serio_get_drvdata(serio->parent);\r\nif (parent->pt_deactivate)\r\nparent->pt_deactivate(parent);\r\n}\r\nold_dev = psmouse->dev;\r\nold_proto = psmouse_protocol_by_type(psmouse->type);\r\nif (psmouse->disconnect)\r\npsmouse->disconnect(psmouse);\r\npsmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\npsmouse->dev = new_dev;\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\nif (psmouse_switch_protocol(psmouse, proto) < 0) {\r\npsmouse_reset(psmouse);\r\npsmouse_switch_protocol(psmouse, &psmouse_protocols[0]);\r\n}\r\npsmouse_initialize(psmouse);\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\nerror = input_register_device(psmouse->dev);\r\nif (error) {\r\nif (psmouse->disconnect)\r\npsmouse->disconnect(psmouse);\r\npsmouse_set_state(psmouse, PSMOUSE_IGNORE);\r\ninput_free_device(new_dev);\r\npsmouse->dev = old_dev;\r\npsmouse_set_state(psmouse, PSMOUSE_INITIALIZING);\r\npsmouse_switch_protocol(psmouse, old_proto);\r\npsmouse_initialize(psmouse);\r\npsmouse_set_state(psmouse, PSMOUSE_CMD_MODE);\r\nreturn error;\r\n}\r\ninput_unregister_device(old_dev);\r\nif (parent && parent->pt_activate)\r\nparent->pt_activate(parent);\r\nreturn count;\r\n}\r\nstatic ssize_t psmouse_attr_set_rate(struct psmouse *psmouse, void *data, const char *buf, size_t count)\r\n{\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\npsmouse->set_rate(psmouse, value);\r\nreturn count;\r\n}\r\nstatic ssize_t psmouse_attr_set_resolution(struct psmouse *psmouse, void *data, const char *buf, size_t count)\r\n{\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\npsmouse->set_resolution(psmouse, value);\r\nreturn count;\r\n}\r\nstatic int psmouse_set_maxproto(const char *val, const struct kernel_param *kp)\r\n{\r\nconst struct psmouse_protocol *proto;\r\nif (!val)\r\nreturn -EINVAL;\r\nproto = psmouse_protocol_by_name(val, strlen(val));\r\nif (!proto || !proto->maxproto)\r\nreturn -EINVAL;\r\n*((unsigned int *)kp->arg) = proto->type;\r\nreturn 0;\r\n}\r\nstatic int psmouse_get_maxproto(char *buffer, const struct kernel_param *kp)\r\n{\r\nint type = *((unsigned int *)kp->arg);\r\nreturn sprintf(buffer, "%s", psmouse_protocol_by_type(type)->name);\r\n}\r\nstatic int __init psmouse_init(void)\r\n{\r\nint err;\r\nlifebook_module_init();\r\nsynaptics_module_init();\r\nhgpk_module_init();\r\nkpsmoused_wq = create_singlethread_workqueue("kpsmoused");\r\nif (!kpsmoused_wq) {\r\npr_err("failed to create kpsmoused workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = serio_register_driver(&psmouse_drv);\r\nif (err)\r\ndestroy_workqueue(kpsmoused_wq);\r\nreturn err;\r\n}\r\nstatic void __exit psmouse_exit(void)\r\n{\r\nserio_unregister_driver(&psmouse_drv);\r\ndestroy_workqueue(kpsmoused_wq);\r\n}
