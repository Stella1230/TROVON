static int zpci_refresh_global(struct zpci_dev *zdev)\r\n{\r\nreturn zpci_refresh_trans((u64) zdev->fh << 32, zdev->start_dma,\r\nzdev->iommu_pages * PAGE_SIZE);\r\n}\r\nunsigned long *dma_alloc_cpu_table(void)\r\n{\r\nunsigned long *table, *entry;\r\ntable = kmem_cache_alloc(dma_region_table_cache, GFP_ATOMIC);\r\nif (!table)\r\nreturn NULL;\r\nfor (entry = table; entry < table + ZPCI_TABLE_ENTRIES; entry++)\r\n*entry = ZPCI_TABLE_INVALID;\r\nreturn table;\r\n}\r\nstatic void dma_free_cpu_table(void *table)\r\n{\r\nkmem_cache_free(dma_region_table_cache, table);\r\n}\r\nstatic unsigned long *dma_alloc_page_table(void)\r\n{\r\nunsigned long *table, *entry;\r\ntable = kmem_cache_alloc(dma_page_table_cache, GFP_ATOMIC);\r\nif (!table)\r\nreturn NULL;\r\nfor (entry = table; entry < table + ZPCI_PT_ENTRIES; entry++)\r\n*entry = ZPCI_PTE_INVALID;\r\nreturn table;\r\n}\r\nstatic void dma_free_page_table(void *table)\r\n{\r\nkmem_cache_free(dma_page_table_cache, table);\r\n}\r\nstatic unsigned long *dma_get_seg_table_origin(unsigned long *entry)\r\n{\r\nunsigned long *sto;\r\nif (reg_entry_isvalid(*entry))\r\nsto = get_rt_sto(*entry);\r\nelse {\r\nsto = dma_alloc_cpu_table();\r\nif (!sto)\r\nreturn NULL;\r\nset_rt_sto(entry, sto);\r\nvalidate_rt_entry(entry);\r\nentry_clr_protected(entry);\r\n}\r\nreturn sto;\r\n}\r\nstatic unsigned long *dma_get_page_table_origin(unsigned long *entry)\r\n{\r\nunsigned long *pto;\r\nif (reg_entry_isvalid(*entry))\r\npto = get_st_pto(*entry);\r\nelse {\r\npto = dma_alloc_page_table();\r\nif (!pto)\r\nreturn NULL;\r\nset_st_pto(entry, pto);\r\nvalidate_st_entry(entry);\r\nentry_clr_protected(entry);\r\n}\r\nreturn pto;\r\n}\r\nunsigned long *dma_walk_cpu_trans(unsigned long *rto, dma_addr_t dma_addr)\r\n{\r\nunsigned long *sto, *pto;\r\nunsigned int rtx, sx, px;\r\nrtx = calc_rtx(dma_addr);\r\nsto = dma_get_seg_table_origin(&rto[rtx]);\r\nif (!sto)\r\nreturn NULL;\r\nsx = calc_sx(dma_addr);\r\npto = dma_get_page_table_origin(&sto[sx]);\r\nif (!pto)\r\nreturn NULL;\r\npx = calc_px(dma_addr);\r\nreturn &pto[px];\r\n}\r\nvoid dma_update_cpu_trans(unsigned long *entry, void *page_addr, int flags)\r\n{\r\nif (flags & ZPCI_PTE_INVALID) {\r\ninvalidate_pt_entry(entry);\r\n} else {\r\nset_pt_pfaa(entry, page_addr);\r\nvalidate_pt_entry(entry);\r\n}\r\nif (flags & ZPCI_TABLE_PROTECTED)\r\nentry_set_protected(entry);\r\nelse\r\nentry_clr_protected(entry);\r\n}\r\nstatic int dma_update_trans(struct zpci_dev *zdev, unsigned long pa,\r\ndma_addr_t dma_addr, size_t size, int flags)\r\n{\r\nunsigned int nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nu8 *page_addr = (u8 *) (pa & PAGE_MASK);\r\ndma_addr_t start_dma_addr = dma_addr;\r\nunsigned long irq_flags;\r\nunsigned long *entry;\r\nint i, rc = 0;\r\nif (!nr_pages)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&zdev->dma_table_lock, irq_flags);\r\nif (!zdev->dma_table) {\r\nrc = -EINVAL;\r\ngoto no_refresh;\r\n}\r\nfor (i = 0; i < nr_pages; i++) {\r\nentry = dma_walk_cpu_trans(zdev->dma_table, dma_addr);\r\nif (!entry) {\r\nrc = -ENOMEM;\r\ngoto undo_cpu_trans;\r\n}\r\ndma_update_cpu_trans(entry, page_addr, flags);\r\npage_addr += PAGE_SIZE;\r\ndma_addr += PAGE_SIZE;\r\n}\r\nif (!zdev->tlb_refresh &&\r\n(!s390_iommu_strict ||\r\n((flags & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_VALID)))\r\ngoto no_refresh;\r\nrc = zpci_refresh_trans((u64) zdev->fh << 32, start_dma_addr,\r\nnr_pages * PAGE_SIZE);\r\nundo_cpu_trans:\r\nif (rc && ((flags & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_VALID)) {\r\nflags = ZPCI_PTE_INVALID;\r\nwhile (i-- > 0) {\r\npage_addr -= PAGE_SIZE;\r\ndma_addr -= PAGE_SIZE;\r\nentry = dma_walk_cpu_trans(zdev->dma_table, dma_addr);\r\nif (!entry)\r\nbreak;\r\ndma_update_cpu_trans(entry, page_addr, flags);\r\n}\r\n}\r\nno_refresh:\r\nspin_unlock_irqrestore(&zdev->dma_table_lock, irq_flags);\r\nreturn rc;\r\n}\r\nvoid dma_free_seg_table(unsigned long entry)\r\n{\r\nunsigned long *sto = get_rt_sto(entry);\r\nint sx;\r\nfor (sx = 0; sx < ZPCI_TABLE_ENTRIES; sx++)\r\nif (reg_entry_isvalid(sto[sx]))\r\ndma_free_page_table(get_st_pto(sto[sx]));\r\ndma_free_cpu_table(sto);\r\n}\r\nvoid dma_cleanup_tables(unsigned long *table)\r\n{\r\nint rtx;\r\nif (!table)\r\nreturn;\r\nfor (rtx = 0; rtx < ZPCI_TABLE_ENTRIES; rtx++)\r\nif (reg_entry_isvalid(table[rtx]))\r\ndma_free_seg_table(table[rtx]);\r\ndma_free_cpu_table(table);\r\n}\r\nstatic unsigned long __dma_alloc_iommu(struct device *dev,\r\nunsigned long start, int size)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long boundary_size;\r\nboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\r\nPAGE_SIZE) >> PAGE_SHIFT;\r\nreturn iommu_area_alloc(zdev->iommu_bitmap, zdev->iommu_pages,\r\nstart, size, 0, boundary_size, 0);\r\n}\r\nstatic unsigned long dma_alloc_iommu(struct device *dev, int size)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long offset, flags;\r\nint wrap = 0;\r\nspin_lock_irqsave(&zdev->iommu_bitmap_lock, flags);\r\noffset = __dma_alloc_iommu(dev, zdev->next_bit, size);\r\nif (offset == -1) {\r\noffset = __dma_alloc_iommu(dev, 0, size);\r\nwrap = 1;\r\n}\r\nif (offset != -1) {\r\nzdev->next_bit = offset + size;\r\nif (!zdev->tlb_refresh && !s390_iommu_strict && wrap)\r\nzpci_refresh_global(zdev);\r\n}\r\nspin_unlock_irqrestore(&zdev->iommu_bitmap_lock, flags);\r\nreturn offset;\r\n}\r\nstatic void dma_free_iommu(struct device *dev, unsigned long offset, int size)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long flags;\r\nspin_lock_irqsave(&zdev->iommu_bitmap_lock, flags);\r\nif (!zdev->iommu_bitmap)\r\ngoto out;\r\nbitmap_clear(zdev->iommu_bitmap, offset, size);\r\nif (!s390_iommu_strict && offset >= zdev->next_bit)\r\nzdev->next_bit = offset + size;\r\nout:\r\nspin_unlock_irqrestore(&zdev->iommu_bitmap_lock, flags);\r\n}\r\nstatic inline void zpci_err_dma(unsigned long rc, unsigned long addr)\r\n{\r\nstruct {\r\nunsigned long rc;\r\nunsigned long addr;\r\n} __packed data = {rc, addr};\r\nzpci_err_hex(&data, sizeof(data));\r\n}\r\nstatic dma_addr_t s390_dma_map_pages(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long nr_pages, iommu_page_index;\r\nunsigned long pa = page_to_phys(page) + offset;\r\nint flags = ZPCI_PTE_VALID;\r\ndma_addr_t dma_addr;\r\nint ret;\r\nnr_pages = iommu_num_pages(pa, size, PAGE_SIZE);\r\niommu_page_index = dma_alloc_iommu(dev, nr_pages);\r\nif (iommu_page_index == -1) {\r\nret = -ENOSPC;\r\ngoto out_err;\r\n}\r\nsize = nr_pages * PAGE_SIZE;\r\ndma_addr = zdev->start_dma + iommu_page_index * PAGE_SIZE;\r\nif (dma_addr + size > zdev->end_dma) {\r\nret = -ERANGE;\r\ngoto out_free;\r\n}\r\nif (direction == DMA_NONE || direction == DMA_TO_DEVICE)\r\nflags |= ZPCI_TABLE_PROTECTED;\r\nret = dma_update_trans(zdev, pa, dma_addr, size, flags);\r\nif (ret)\r\ngoto out_free;\r\natomic64_add(nr_pages, &zdev->mapped_pages);\r\nreturn dma_addr + (offset & ~PAGE_MASK);\r\nout_free:\r\ndma_free_iommu(dev, iommu_page_index, nr_pages);\r\nout_err:\r\nzpci_err("map error:\n");\r\nzpci_err_dma(ret, pa);\r\nreturn DMA_ERROR_CODE;\r\n}\r\nstatic void s390_dma_unmap_pages(struct device *dev, dma_addr_t dma_addr,\r\nsize_t size, enum dma_data_direction direction,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long iommu_page_index;\r\nint npages, ret;\r\nnpages = iommu_num_pages(dma_addr, size, PAGE_SIZE);\r\ndma_addr = dma_addr & PAGE_MASK;\r\nret = dma_update_trans(zdev, 0, dma_addr, npages * PAGE_SIZE,\r\nZPCI_PTE_INVALID);\r\nif (ret) {\r\nzpci_err("unmap error:\n");\r\nzpci_err_dma(ret, dma_addr);\r\nreturn;\r\n}\r\natomic64_add(npages, &zdev->unmapped_pages);\r\niommu_page_index = (dma_addr - zdev->start_dma) >> PAGE_SHIFT;\r\ndma_free_iommu(dev, iommu_page_index, npages);\r\n}\r\nstatic void *s390_dma_alloc(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flag,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nstruct page *page;\r\nunsigned long pa;\r\ndma_addr_t map;\r\nsize = PAGE_ALIGN(size);\r\npage = alloc_pages(flag, get_order(size));\r\nif (!page)\r\nreturn NULL;\r\npa = page_to_phys(page);\r\nmemset((void *) pa, 0, size);\r\nmap = s390_dma_map_pages(dev, page, 0, size, DMA_BIDIRECTIONAL, NULL);\r\nif (dma_mapping_error(dev, map)) {\r\nfree_pages(pa, get_order(size));\r\nreturn NULL;\r\n}\r\natomic64_add(size / PAGE_SIZE, &zdev->allocated_pages);\r\nif (dma_handle)\r\n*dma_handle = map;\r\nreturn (void *) pa;\r\n}\r\nstatic void s390_dma_free(struct device *dev, size_t size,\r\nvoid *pa, dma_addr_t dma_handle,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nsize = PAGE_ALIGN(size);\r\natomic64_sub(size / PAGE_SIZE, &zdev->allocated_pages);\r\ns390_dma_unmap_pages(dev, dma_handle, size, DMA_BIDIRECTIONAL, NULL);\r\nfree_pages((unsigned long) pa, get_order(size));\r\n}\r\nstatic int s390_dma_map_sg(struct device *dev, struct scatterlist *sg,\r\nint nr_elements, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nint mapped_elements = 0;\r\nstruct scatterlist *s;\r\nint i;\r\nfor_each_sg(sg, s, nr_elements, i) {\r\nstruct page *page = sg_page(s);\r\ns->dma_address = s390_dma_map_pages(dev, page, s->offset,\r\ns->length, dir, NULL);\r\nif (!dma_mapping_error(dev, s->dma_address)) {\r\ns->dma_length = s->length;\r\nmapped_elements++;\r\n} else\r\ngoto unmap;\r\n}\r\nout:\r\nreturn mapped_elements;\r\nunmap:\r\nfor_each_sg(sg, s, mapped_elements, i) {\r\nif (s->dma_address)\r\ns390_dma_unmap_pages(dev, s->dma_address, s->dma_length,\r\ndir, NULL);\r\ns->dma_address = 0;\r\ns->dma_length = 0;\r\n}\r\nmapped_elements = 0;\r\ngoto out;\r\n}\r\nstatic void s390_dma_unmap_sg(struct device *dev, struct scatterlist *sg,\r\nint nr_elements, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scatterlist *s;\r\nint i;\r\nfor_each_sg(sg, s, nr_elements, i) {\r\ns390_dma_unmap_pages(dev, s->dma_address, s->dma_length, dir, NULL);\r\ns->dma_address = 0;\r\ns->dma_length = 0;\r\n}\r\n}\r\nint zpci_dma_init_device(struct zpci_dev *zdev)\r\n{\r\nint rc;\r\nWARN_ON(zdev->s390_domain);\r\nspin_lock_init(&zdev->iommu_bitmap_lock);\r\nspin_lock_init(&zdev->dma_table_lock);\r\nzdev->dma_table = dma_alloc_cpu_table();\r\nif (!zdev->dma_table) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nzdev->iommu_size = min3((u64) high_memory,\r\nZPCI_TABLE_SIZE_RT - zdev->start_dma,\r\nzdev->end_dma - zdev->start_dma + 1);\r\nzdev->end_dma = zdev->start_dma + zdev->iommu_size - 1;\r\nzdev->iommu_pages = zdev->iommu_size >> PAGE_SHIFT;\r\nzdev->iommu_bitmap = vzalloc(zdev->iommu_pages / 8);\r\nif (!zdev->iommu_bitmap) {\r\nrc = -ENOMEM;\r\ngoto free_dma_table;\r\n}\r\nrc = zpci_register_ioat(zdev, 0, zdev->start_dma, zdev->end_dma,\r\n(u64) zdev->dma_table);\r\nif (rc)\r\ngoto free_bitmap;\r\nreturn 0;\r\nfree_bitmap:\r\nvfree(zdev->iommu_bitmap);\r\nzdev->iommu_bitmap = NULL;\r\nfree_dma_table:\r\ndma_free_cpu_table(zdev->dma_table);\r\nzdev->dma_table = NULL;\r\nout:\r\nreturn rc;\r\n}\r\nvoid zpci_dma_exit_device(struct zpci_dev *zdev)\r\n{\r\nWARN_ON(zdev->s390_domain);\r\nzpci_unregister_ioat(zdev, 0);\r\ndma_cleanup_tables(zdev->dma_table);\r\nzdev->dma_table = NULL;\r\nvfree(zdev->iommu_bitmap);\r\nzdev->iommu_bitmap = NULL;\r\nzdev->next_bit = 0;\r\n}\r\nstatic int __init dma_alloc_cpu_table_caches(void)\r\n{\r\ndma_region_table_cache = kmem_cache_create("PCI_DMA_region_tables",\r\nZPCI_TABLE_SIZE, ZPCI_TABLE_ALIGN,\r\n0, NULL);\r\nif (!dma_region_table_cache)\r\nreturn -ENOMEM;\r\ndma_page_table_cache = kmem_cache_create("PCI_DMA_page_tables",\r\nZPCI_PT_SIZE, ZPCI_PT_ALIGN,\r\n0, NULL);\r\nif (!dma_page_table_cache) {\r\nkmem_cache_destroy(dma_region_table_cache);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint __init zpci_dma_init(void)\r\n{\r\nreturn dma_alloc_cpu_table_caches();\r\n}\r\nvoid zpci_dma_exit(void)\r\n{\r\nkmem_cache_destroy(dma_page_table_cache);\r\nkmem_cache_destroy(dma_region_table_cache);\r\n}\r\nstatic int __init dma_debug_do_init(void)\r\n{\r\ndma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);\r\nreturn 0;\r\n}\r\nstatic int __init s390_iommu_setup(char *str)\r\n{\r\nif (!strncmp(str, "strict", 6))\r\ns390_iommu_strict = 1;\r\nreturn 0;\r\n}
