int radeon_kfd_init(void)\r\n{\r\nint ret;\r\n#if defined(CONFIG_HSA_AMD_MODULE)\r\nint (*kgd2kfd_init_p)(unsigned, const struct kgd2kfd_calls**);\r\nkgd2kfd_init_p = symbol_request(kgd2kfd_init);\r\nif (kgd2kfd_init_p == NULL)\r\nreturn -ENOENT;\r\nret = kgd2kfd_init_p(KFD_INTERFACE_VERSION, &kgd2kfd);\r\nif (ret) {\r\nsymbol_put(kgd2kfd_init);\r\nkgd2kfd = NULL;\r\n}\r\n#elif defined(CONFIG_HSA_AMD)\r\nret = kgd2kfd_init(KFD_INTERFACE_VERSION, &kgd2kfd);\r\nif (ret)\r\nkgd2kfd = NULL;\r\n#else\r\nret = -ENOENT;\r\n#endif\r\nreturn ret;\r\n}\r\nvoid radeon_kfd_fini(void)\r\n{\r\nif (kgd2kfd) {\r\nkgd2kfd->exit();\r\nsymbol_put(kgd2kfd_init);\r\n}\r\n}\r\nvoid radeon_kfd_device_probe(struct radeon_device *rdev)\r\n{\r\nif (kgd2kfd)\r\nrdev->kfd = kgd2kfd->probe((struct kgd_dev *)rdev,\r\nrdev->pdev, &kfd2kgd);\r\n}\r\nvoid radeon_kfd_device_init(struct radeon_device *rdev)\r\n{\r\nif (rdev->kfd) {\r\nstruct kgd2kfd_shared_resources gpu_resources = {\r\n.compute_vmid_bitmap = 0xFF00,\r\n.first_compute_pipe = 1,\r\n.compute_pipe_count = 4 - 1,\r\n};\r\nradeon_doorbell_get_kfd_info(rdev,\r\n&gpu_resources.doorbell_physical_address,\r\n&gpu_resources.doorbell_aperture_size,\r\n&gpu_resources.doorbell_start_offset);\r\nkgd2kfd->device_init(rdev->kfd, &gpu_resources);\r\n}\r\n}\r\nvoid radeon_kfd_device_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->kfd) {\r\nkgd2kfd->device_exit(rdev->kfd);\r\nrdev->kfd = NULL;\r\n}\r\n}\r\nvoid radeon_kfd_interrupt(struct radeon_device *rdev, const void *ih_ring_entry)\r\n{\r\nif (rdev->kfd)\r\nkgd2kfd->interrupt(rdev->kfd, ih_ring_entry);\r\n}\r\nvoid radeon_kfd_suspend(struct radeon_device *rdev)\r\n{\r\nif (rdev->kfd)\r\nkgd2kfd->suspend(rdev->kfd);\r\n}\r\nint radeon_kfd_resume(struct radeon_device *rdev)\r\n{\r\nint r = 0;\r\nif (rdev->kfd)\r\nr = kgd2kfd->resume(rdev->kfd);\r\nreturn r;\r\n}\r\nstatic int alloc_gtt_mem(struct kgd_dev *kgd, size_t size,\r\nvoid **mem_obj, uint64_t *gpu_addr,\r\nvoid **cpu_ptr)\r\n{\r\nstruct radeon_device *rdev = (struct radeon_device *)kgd;\r\nstruct kgd_mem **mem = (struct kgd_mem **) mem_obj;\r\nint r;\r\nBUG_ON(kgd == NULL);\r\nBUG_ON(gpu_addr == NULL);\r\nBUG_ON(cpu_ptr == NULL);\r\n*mem = kmalloc(sizeof(struct kgd_mem), GFP_KERNEL);\r\nif ((*mem) == NULL)\r\nreturn -ENOMEM;\r\nr = radeon_bo_create(rdev, size, PAGE_SIZE, true, RADEON_GEM_DOMAIN_GTT,\r\nRADEON_GEM_GTT_WC, NULL, NULL, &(*mem)->bo);\r\nif (r) {\r\ndev_err(rdev->dev,\r\n"failed to allocate BO for amdkfd (%d)\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_reserve((*mem)->bo, true);\r\nif (r) {\r\ndev_err(rdev->dev, "(%d) failed to reserve bo for amdkfd\n", r);\r\ngoto allocate_mem_reserve_bo_failed;\r\n}\r\nr = radeon_bo_pin((*mem)->bo, RADEON_GEM_DOMAIN_GTT,\r\n&(*mem)->gpu_addr);\r\nif (r) {\r\ndev_err(rdev->dev, "(%d) failed to pin bo for amdkfd\n", r);\r\ngoto allocate_mem_pin_bo_failed;\r\n}\r\n*gpu_addr = (*mem)->gpu_addr;\r\nr = radeon_bo_kmap((*mem)->bo, &(*mem)->cpu_ptr);\r\nif (r) {\r\ndev_err(rdev->dev,\r\n"(%d) failed to map bo to kernel for amdkfd\n", r);\r\ngoto allocate_mem_kmap_bo_failed;\r\n}\r\n*cpu_ptr = (*mem)->cpu_ptr;\r\nradeon_bo_unreserve((*mem)->bo);\r\nreturn 0;\r\nallocate_mem_kmap_bo_failed:\r\nradeon_bo_unpin((*mem)->bo);\r\nallocate_mem_pin_bo_failed:\r\nradeon_bo_unreserve((*mem)->bo);\r\nallocate_mem_reserve_bo_failed:\r\nradeon_bo_unref(&(*mem)->bo);\r\nreturn r;\r\n}\r\nstatic void free_gtt_mem(struct kgd_dev *kgd, void *mem_obj)\r\n{\r\nstruct kgd_mem *mem = (struct kgd_mem *) mem_obj;\r\nBUG_ON(mem == NULL);\r\nradeon_bo_reserve(mem->bo, true);\r\nradeon_bo_kunmap(mem->bo);\r\nradeon_bo_unpin(mem->bo);\r\nradeon_bo_unreserve(mem->bo);\r\nradeon_bo_unref(&(mem->bo));\r\nkfree(mem);\r\n}\r\nstatic uint64_t get_vmem_size(struct kgd_dev *kgd)\r\n{\r\nstruct radeon_device *rdev = (struct radeon_device *)kgd;\r\nBUG_ON(kgd == NULL);\r\nreturn rdev->mc.real_vram_size;\r\n}\r\nstatic uint64_t get_gpu_clock_counter(struct kgd_dev *kgd)\r\n{\r\nstruct radeon_device *rdev = (struct radeon_device *)kgd;\r\nreturn rdev->asic->get_gpu_clock_counter(rdev);\r\n}\r\nstatic uint32_t get_max_engine_clock_in_mhz(struct kgd_dev *kgd)\r\n{\r\nstruct radeon_device *rdev = (struct radeon_device *)kgd;\r\nreturn rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk / 100;\r\n}\r\nstatic inline struct radeon_device *get_radeon_device(struct kgd_dev *kgd)\r\n{\r\nreturn (struct radeon_device *)kgd;\r\n}\r\nstatic void write_register(struct kgd_dev *kgd, uint32_t offset, uint32_t value)\r\n{\r\nstruct radeon_device *rdev = get_radeon_device(kgd);\r\nwritel(value, (void __iomem *)(rdev->rmmio + offset));\r\n}\r\nstatic uint32_t read_register(struct kgd_dev *kgd, uint32_t offset)\r\n{\r\nstruct radeon_device *rdev = get_radeon_device(kgd);\r\nreturn readl((void __iomem *)(rdev->rmmio + offset));\r\n}\r\nstatic void lock_srbm(struct kgd_dev *kgd, uint32_t mec, uint32_t pipe,\r\nuint32_t queue, uint32_t vmid)\r\n{\r\nstruct radeon_device *rdev = get_radeon_device(kgd);\r\nuint32_t value = PIPEID(pipe) | MEID(mec) | VMID(vmid) | QUEUEID(queue);\r\nmutex_lock(&rdev->srbm_mutex);\r\nwrite_register(kgd, SRBM_GFX_CNTL, value);\r\n}\r\nstatic void unlock_srbm(struct kgd_dev *kgd)\r\n{\r\nstruct radeon_device *rdev = get_radeon_device(kgd);\r\nwrite_register(kgd, SRBM_GFX_CNTL, 0);\r\nmutex_unlock(&rdev->srbm_mutex);\r\n}\r\nstatic void acquire_queue(struct kgd_dev *kgd, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nuint32_t mec = (++pipe_id / CIK_PIPE_PER_MEC) + 1;\r\nuint32_t pipe = (pipe_id % CIK_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, queue_id, 0);\r\n}\r\nstatic void release_queue(struct kgd_dev *kgd)\r\n{\r\nunlock_srbm(kgd);\r\n}\r\nstatic void kgd_program_sh_mem_settings(struct kgd_dev *kgd, uint32_t vmid,\r\nuint32_t sh_mem_config,\r\nuint32_t sh_mem_ape1_base,\r\nuint32_t sh_mem_ape1_limit,\r\nuint32_t sh_mem_bases)\r\n{\r\nlock_srbm(kgd, 0, 0, 0, vmid);\r\nwrite_register(kgd, SH_MEM_CONFIG, sh_mem_config);\r\nwrite_register(kgd, SH_MEM_APE1_BASE, sh_mem_ape1_base);\r\nwrite_register(kgd, SH_MEM_APE1_LIMIT, sh_mem_ape1_limit);\r\nwrite_register(kgd, SH_MEM_BASES, sh_mem_bases);\r\nunlock_srbm(kgd);\r\n}\r\nstatic int kgd_set_pasid_vmid_mapping(struct kgd_dev *kgd, unsigned int pasid,\r\nunsigned int vmid)\r\n{\r\nuint32_t pasid_mapping = (pasid == 0) ? 0 : (uint32_t)pasid |\r\nATC_VMID_PASID_MAPPING_VALID_MASK;\r\nwrite_register(kgd, ATC_VMID0_PASID_MAPPING + vmid*sizeof(uint32_t),\r\npasid_mapping);\r\nwhile (!(read_register(kgd, ATC_VMID_PASID_MAPPING_UPDATE_STATUS) &\r\n(1U << vmid)))\r\ncpu_relax();\r\nwrite_register(kgd, ATC_VMID_PASID_MAPPING_UPDATE_STATUS, 1U << vmid);\r\nwrite_register(kgd, IH_VMID_0_LUT + vmid * sizeof(uint32_t),\r\npasid_mapping);\r\nreturn 0;\r\n}\r\nstatic int kgd_init_pipeline(struct kgd_dev *kgd, uint32_t pipe_id,\r\nuint32_t hpd_size, uint64_t hpd_gpu_addr)\r\n{\r\nuint32_t mec = (pipe_id / CIK_PIPE_PER_MEC) + 1;\r\nuint32_t pipe = (pipe_id % CIK_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, 0, 0);\r\nwrite_register(kgd, CP_HPD_EOP_BASE_ADDR,\r\nlower_32_bits(hpd_gpu_addr >> 8));\r\nwrite_register(kgd, CP_HPD_EOP_BASE_ADDR_HI,\r\nupper_32_bits(hpd_gpu_addr >> 8));\r\nwrite_register(kgd, CP_HPD_EOP_VMID, 0);\r\nwrite_register(kgd, CP_HPD_EOP_CONTROL, hpd_size);\r\nunlock_srbm(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_init_interrupts(struct kgd_dev *kgd, uint32_t pipe_id)\r\n{\r\nuint32_t mec;\r\nuint32_t pipe;\r\nmec = (pipe_id / CIK_PIPE_PER_MEC) + 1;\r\npipe = (pipe_id % CIK_PIPE_PER_MEC);\r\nlock_srbm(kgd, mec, pipe, 0, 0);\r\nwrite_register(kgd, CPC_INT_CNTL,\r\nTIME_STAMP_INT_ENABLE | OPCODE_ERROR_INT_ENABLE);\r\nunlock_srbm(kgd);\r\nreturn 0;\r\n}\r\nstatic inline uint32_t get_sdma_base_addr(struct cik_sdma_rlc_registers *m)\r\n{\r\nuint32_t retval;\r\nretval = m->sdma_engine_id * SDMA1_REGISTER_OFFSET +\r\nm->sdma_queue_id * KFD_CIK_SDMA_QUEUE_OFFSET;\r\npr_debug("kfd: sdma base address: 0x%x\n", retval);\r\nreturn retval;\r\n}\r\nstatic inline struct cik_mqd *get_mqd(void *mqd)\r\n{\r\nreturn (struct cik_mqd *)mqd;\r\n}\r\nstatic inline struct cik_sdma_rlc_registers *get_sdma_mqd(void *mqd)\r\n{\r\nreturn (struct cik_sdma_rlc_registers *)mqd;\r\n}\r\nstatic int kgd_hqd_load(struct kgd_dev *kgd, void *mqd, uint32_t pipe_id,\r\nuint32_t queue_id, uint32_t __user *wptr)\r\n{\r\nuint32_t wptr_shadow, is_wptr_shadow_valid;\r\nstruct cik_mqd *m;\r\nm = get_mqd(mqd);\r\nis_wptr_shadow_valid = !get_user(wptr_shadow, wptr);\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nwrite_register(kgd, CP_MQD_BASE_ADDR, m->cp_mqd_base_addr_lo);\r\nwrite_register(kgd, CP_MQD_BASE_ADDR_HI, m->cp_mqd_base_addr_hi);\r\nwrite_register(kgd, CP_MQD_CONTROL, m->cp_mqd_control);\r\nwrite_register(kgd, CP_HQD_PQ_BASE, m->cp_hqd_pq_base_lo);\r\nwrite_register(kgd, CP_HQD_PQ_BASE_HI, m->cp_hqd_pq_base_hi);\r\nwrite_register(kgd, CP_HQD_PQ_CONTROL, m->cp_hqd_pq_control);\r\nwrite_register(kgd, CP_HQD_IB_CONTROL, m->cp_hqd_ib_control);\r\nwrite_register(kgd, CP_HQD_IB_BASE_ADDR, m->cp_hqd_ib_base_addr_lo);\r\nwrite_register(kgd, CP_HQD_IB_BASE_ADDR_HI, m->cp_hqd_ib_base_addr_hi);\r\nwrite_register(kgd, CP_HQD_IB_RPTR, m->cp_hqd_ib_rptr);\r\nwrite_register(kgd, CP_HQD_PERSISTENT_STATE,\r\nm->cp_hqd_persistent_state);\r\nwrite_register(kgd, CP_HQD_SEMA_CMD, m->cp_hqd_sema_cmd);\r\nwrite_register(kgd, CP_HQD_MSG_TYPE, m->cp_hqd_msg_type);\r\nwrite_register(kgd, CP_HQD_ATOMIC0_PREOP_LO,\r\nm->cp_hqd_atomic0_preop_lo);\r\nwrite_register(kgd, CP_HQD_ATOMIC0_PREOP_HI,\r\nm->cp_hqd_atomic0_preop_hi);\r\nwrite_register(kgd, CP_HQD_ATOMIC1_PREOP_LO,\r\nm->cp_hqd_atomic1_preop_lo);\r\nwrite_register(kgd, CP_HQD_ATOMIC1_PREOP_HI,\r\nm->cp_hqd_atomic1_preop_hi);\r\nwrite_register(kgd, CP_HQD_PQ_RPTR_REPORT_ADDR,\r\nm->cp_hqd_pq_rptr_report_addr_lo);\r\nwrite_register(kgd, CP_HQD_PQ_RPTR_REPORT_ADDR_HI,\r\nm->cp_hqd_pq_rptr_report_addr_hi);\r\nwrite_register(kgd, CP_HQD_PQ_RPTR, m->cp_hqd_pq_rptr);\r\nwrite_register(kgd, CP_HQD_PQ_WPTR_POLL_ADDR,\r\nm->cp_hqd_pq_wptr_poll_addr_lo);\r\nwrite_register(kgd, CP_HQD_PQ_WPTR_POLL_ADDR_HI,\r\nm->cp_hqd_pq_wptr_poll_addr_hi);\r\nwrite_register(kgd, CP_HQD_PQ_DOORBELL_CONTROL,\r\nm->cp_hqd_pq_doorbell_control);\r\nwrite_register(kgd, CP_HQD_VMID, m->cp_hqd_vmid);\r\nwrite_register(kgd, CP_HQD_QUANTUM, m->cp_hqd_quantum);\r\nwrite_register(kgd, CP_HQD_PIPE_PRIORITY, m->cp_hqd_pipe_priority);\r\nwrite_register(kgd, CP_HQD_QUEUE_PRIORITY, m->cp_hqd_queue_priority);\r\nwrite_register(kgd, CP_HQD_IQ_RPTR, m->cp_hqd_iq_rptr);\r\nif (is_wptr_shadow_valid)\r\nwrite_register(kgd, CP_HQD_PQ_WPTR, wptr_shadow);\r\nwrite_register(kgd, CP_HQD_ACTIVE, m->cp_hqd_active);\r\nrelease_queue(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_hqd_sdma_load(struct kgd_dev *kgd, void *mqd)\r\n{\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\nwrite_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_VIRTUAL_ADDR,\r\nm->sdma_rlc_virtual_addr);\r\nwrite_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_RB_BASE,\r\nm->sdma_rlc_rb_base);\r\nwrite_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_RB_BASE_HI,\r\nm->sdma_rlc_rb_base_hi);\r\nwrite_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_RB_RPTR_ADDR_LO,\r\nm->sdma_rlc_rb_rptr_addr_lo);\r\nwrite_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_RB_RPTR_ADDR_HI,\r\nm->sdma_rlc_rb_rptr_addr_hi);\r\nwrite_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_DOORBELL,\r\nm->sdma_rlc_doorbell);\r\nwrite_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_RB_CNTL,\r\nm->sdma_rlc_rb_cntl);\r\nreturn 0;\r\n}\r\nstatic bool kgd_hqd_is_occupied(struct kgd_dev *kgd, uint64_t queue_address,\r\nuint32_t pipe_id, uint32_t queue_id)\r\n{\r\nuint32_t act;\r\nbool retval = false;\r\nuint32_t low, high;\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nact = read_register(kgd, CP_HQD_ACTIVE);\r\nif (act) {\r\nlow = lower_32_bits(queue_address >> 8);\r\nhigh = upper_32_bits(queue_address >> 8);\r\nif (low == read_register(kgd, CP_HQD_PQ_BASE) &&\r\nhigh == read_register(kgd, CP_HQD_PQ_BASE_HI))\r\nretval = true;\r\n}\r\nrelease_queue(kgd);\r\nreturn retval;\r\n}\r\nstatic bool kgd_hqd_sdma_is_occupied(struct kgd_dev *kgd, void *mqd)\r\n{\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nuint32_t sdma_rlc_rb_cntl;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\nsdma_rlc_rb_cntl = read_register(kgd,\r\nsdma_base_addr + SDMA0_RLC0_RB_CNTL);\r\nif (sdma_rlc_rb_cntl & SDMA_RB_ENABLE)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int kgd_hqd_destroy(struct kgd_dev *kgd, uint32_t reset_type,\r\nunsigned int timeout, uint32_t pipe_id,\r\nuint32_t queue_id)\r\n{\r\nuint32_t temp;\r\nacquire_queue(kgd, pipe_id, queue_id);\r\nwrite_register(kgd, CP_HQD_PQ_DOORBELL_CONTROL, 0);\r\nwrite_register(kgd, CP_HQD_DEQUEUE_REQUEST, reset_type);\r\nwhile (true) {\r\ntemp = read_register(kgd, CP_HQD_ACTIVE);\r\nif (temp & 0x1)\r\nbreak;\r\nif (timeout == 0) {\r\npr_err("kfd: cp queue preemption time out (%dms)\n",\r\ntemp);\r\nrelease_queue(kgd);\r\nreturn -ETIME;\r\n}\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nrelease_queue(kgd);\r\nreturn 0;\r\n}\r\nstatic int kgd_hqd_sdma_destroy(struct kgd_dev *kgd, void *mqd,\r\nunsigned int timeout)\r\n{\r\nstruct cik_sdma_rlc_registers *m;\r\nuint32_t sdma_base_addr;\r\nuint32_t temp;\r\nm = get_sdma_mqd(mqd);\r\nsdma_base_addr = get_sdma_base_addr(m);\r\ntemp = read_register(kgd, sdma_base_addr + SDMA0_RLC0_RB_CNTL);\r\ntemp = temp & ~SDMA_RB_ENABLE;\r\nwrite_register(kgd, sdma_base_addr + SDMA0_RLC0_RB_CNTL, temp);\r\nwhile (true) {\r\ntemp = read_register(kgd, sdma_base_addr +\r\nSDMA0_RLC0_CONTEXT_STATUS);\r\nif (temp & SDMA_RLC_IDLE)\r\nbreak;\r\nif (timeout == 0)\r\nreturn -ETIME;\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nwrite_register(kgd, sdma_base_addr + SDMA0_RLC0_DOORBELL, 0);\r\nwrite_register(kgd, sdma_base_addr + SDMA0_RLC0_RB_RPTR, 0);\r\nwrite_register(kgd, sdma_base_addr + SDMA0_RLC0_RB_WPTR, 0);\r\nwrite_register(kgd, sdma_base_addr + SDMA0_RLC0_RB_BASE, 0);\r\nreturn 0;\r\n}\r\nstatic int kgd_address_watch_disable(struct kgd_dev *kgd)\r\n{\r\nunion TCP_WATCH_CNTL_BITS cntl;\r\nunsigned int i;\r\ncntl.u32All = 0;\r\ncntl.bitfields.valid = 0;\r\ncntl.bitfields.mask = ADDRESS_WATCH_REG_CNTL_DEFAULT_MASK;\r\ncntl.bitfields.atc = 1;\r\nfor (i = 0; i < MAX_WATCH_ADDRESSES; i++)\r\nwrite_register(kgd,\r\nwatchRegs[i * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_CNTL],\r\ncntl.u32All);\r\nreturn 0;\r\n}\r\nstatic int kgd_address_watch_execute(struct kgd_dev *kgd,\r\nunsigned int watch_point_id,\r\nuint32_t cntl_val,\r\nuint32_t addr_hi,\r\nuint32_t addr_lo)\r\n{\r\nunion TCP_WATCH_CNTL_BITS cntl;\r\ncntl.u32All = cntl_val;\r\ncntl.bitfields.valid = 0;\r\nwrite_register(kgd,\r\nwatchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_CNTL],\r\ncntl.u32All);\r\nwrite_register(kgd,\r\nwatchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_ADDR_HI],\r\naddr_hi);\r\nwrite_register(kgd,\r\nwatchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_ADDR_LO],\r\naddr_lo);\r\ncntl.bitfields.valid = 1;\r\nwrite_register(kgd,\r\nwatchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX +\r\nADDRESS_WATCH_REG_CNTL],\r\ncntl.u32All);\r\nreturn 0;\r\n}\r\nstatic int kgd_wave_control_execute(struct kgd_dev *kgd,\r\nuint32_t gfx_index_val,\r\nuint32_t sq_cmd)\r\n{\r\nstruct radeon_device *rdev = get_radeon_device(kgd);\r\nuint32_t data;\r\nmutex_lock(&rdev->grbm_idx_mutex);\r\nwrite_register(kgd, GRBM_GFX_INDEX, gfx_index_val);\r\nwrite_register(kgd, SQ_CMD, sq_cmd);\r\ndata = INSTANCE_BROADCAST_WRITES | SH_BROADCAST_WRITES |\r\nSE_BROADCAST_WRITES;\r\nwrite_register(kgd, GRBM_GFX_INDEX, data);\r\nmutex_unlock(&rdev->grbm_idx_mutex);\r\nreturn 0;\r\n}\r\nstatic uint32_t kgd_address_watch_get_offset(struct kgd_dev *kgd,\r\nunsigned int watch_point_id,\r\nunsigned int reg_offset)\r\n{\r\nreturn watchRegs[watch_point_id * ADDRESS_WATCH_REG_MAX + reg_offset];\r\n}\r\nstatic bool get_atc_vmid_pasid_mapping_valid(struct kgd_dev *kgd, uint8_t vmid)\r\n{\r\nuint32_t reg;\r\nstruct radeon_device *rdev = (struct radeon_device *) kgd;\r\nreg = RREG32(ATC_VMID0_PASID_MAPPING + vmid*4);\r\nreturn reg & ATC_VMID_PASID_MAPPING_VALID_MASK;\r\n}\r\nstatic uint16_t get_atc_vmid_pasid_mapping_pasid(struct kgd_dev *kgd,\r\nuint8_t vmid)\r\n{\r\nuint32_t reg;\r\nstruct radeon_device *rdev = (struct radeon_device *) kgd;\r\nreg = RREG32(ATC_VMID0_PASID_MAPPING + vmid*4);\r\nreturn reg & ATC_VMID_PASID_MAPPING_PASID_MASK;\r\n}\r\nstatic void write_vmid_invalidate_request(struct kgd_dev *kgd, uint8_t vmid)\r\n{\r\nstruct radeon_device *rdev = (struct radeon_device *) kgd;\r\nreturn WREG32(VM_INVALIDATE_REQUEST, 1 << vmid);\r\n}\r\nstatic uint16_t get_fw_version(struct kgd_dev *kgd, enum kgd_engine_type type)\r\n{\r\nstruct radeon_device *rdev = (struct radeon_device *) kgd;\r\nconst union radeon_firmware_header *hdr;\r\nBUG_ON(kgd == NULL || rdev->mec_fw == NULL);\r\nswitch (type) {\r\ncase KGD_ENGINE_PFP:\r\nhdr = (const union radeon_firmware_header *) rdev->pfp_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_ME:\r\nhdr = (const union radeon_firmware_header *) rdev->me_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_CE:\r\nhdr = (const union radeon_firmware_header *) rdev->ce_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_MEC1:\r\nhdr = (const union radeon_firmware_header *) rdev->mec_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_MEC2:\r\nhdr = (const union radeon_firmware_header *)\r\nrdev->mec2_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_RLC:\r\nhdr = (const union radeon_firmware_header *) rdev->rlc_fw->data;\r\nbreak;\r\ncase KGD_ENGINE_SDMA1:\r\ncase KGD_ENGINE_SDMA2:\r\nhdr = (const union radeon_firmware_header *)\r\nrdev->sdma_fw->data;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (hdr == NULL)\r\nreturn 0;\r\nreturn hdr->common.ucode_version;\r\n}
