void iriap_next_client_state(struct iriap_cb *self, IRIAP_STATE state)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nself->client_state = state;\r\n}\r\nvoid iriap_next_call_state(struct iriap_cb *self, IRIAP_STATE state)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nself->call_state = state;\r\n}\r\nvoid iriap_next_server_state(struct iriap_cb *self, IRIAP_STATE state)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nself->server_state = state;\r\n}\r\nvoid iriap_next_r_connect_state(struct iriap_cb *self, IRIAP_STATE state)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nself->r_connect_state = state;\r\n}\r\nvoid iriap_do_client_event(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\n(*iriap_state[ self->client_state]) (self, event, skb);\r\n}\r\nvoid iriap_do_call_event(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\n(*iriap_state[ self->call_state]) (self, event, skb);\r\n}\r\nvoid iriap_do_server_event(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\n(*iriap_state[ self->server_state]) (self, event, skb);\r\n}\r\nvoid iriap_do_r_connect_event(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\n(*iriap_state[ self->r_connect_state]) (self, event, skb);\r\n}\r\nstatic void state_s_disconnect(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nswitch (event) {\r\ncase IAP_CALL_REQUEST_GVBC:\r\niriap_next_client_state(self, S_CONNECTING);\r\nIRDA_ASSERT(self->request_skb == NULL, return;);\r\nskb_get(skb);\r\nself->request_skb = skb;\r\niriap_connect_request(self);\r\nbreak;\r\ncase IAP_LM_DISCONNECT_INDICATION:\r\nbreak;\r\ndefault:\r\npr_debug("%s(), Unknown event %d\n", __func__, event);\r\nbreak;\r\n}\r\n}\r\nstatic void state_s_connecting(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nswitch (event) {\r\ncase IAP_LM_CONNECT_CONFIRM:\r\niriap_do_call_event(self, IAP_CALL_REQUEST, skb);\r\niriap_next_client_state(self, S_CALL);\r\nbreak;\r\ncase IAP_LM_DISCONNECT_INDICATION:\r\niriap_next_call_state(self, S_MAKE_CALL);\r\niriap_next_client_state(self, S_DISCONNECT);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), Unknown event %d\n", __func__, event);\r\nbreak;\r\n}\r\n}\r\nstatic void state_s_call(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nswitch (event) {\r\ncase IAP_LM_DISCONNECT_INDICATION:\r\niriap_next_call_state(self, S_MAKE_CALL);\r\niriap_next_client_state(self, S_DISCONNECT);\r\nbreak;\r\ndefault:\r\npr_debug("state_s_call: Unknown event %d\n", event);\r\nbreak;\r\n}\r\n}\r\nstatic void state_s_make_call(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb;\r\nIRDA_ASSERT(self != NULL, return;);\r\nswitch (event) {\r\ncase IAP_CALL_REQUEST:\r\ntx_skb = self->request_skb;\r\nself->request_skb = NULL;\r\nirlmp_data_request(self->lsap, tx_skb);\r\niriap_next_call_state(self, S_OUTSTANDING);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), Unknown event %d\n", __func__, event);\r\nbreak;\r\n}\r\n}\r\nstatic void state_s_calling(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("%s(), Not implemented\n", __func__);\r\n}\r\nstatic void state_s_outstanding(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nswitch (event) {\r\ncase IAP_RECV_F_LST:\r\niriap_next_call_state(self, S_WAIT_FOR_CALL);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), Unknown event %d\n", __func__, event);\r\nbreak;\r\n}\r\n}\r\nstatic void state_s_replying(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("%s(), Not implemented\n", __func__);\r\n}\r\nstatic void state_s_wait_for_call(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("%s(), Not implemented\n", __func__);\r\n}\r\nstatic void state_s_wait_active(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("%s(), Not implemented\n", __func__);\r\n}\r\nstatic void state_r_disconnect(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb;\r\nswitch (event) {\r\ncase IAP_LM_CONNECT_INDICATION:\r\ntx_skb = alloc_skb(LMP_MAX_HEADER, GFP_ATOMIC);\r\nif (tx_skb == NULL)\r\nreturn;\r\nskb_reserve(tx_skb, LMP_MAX_HEADER);\r\nirlmp_connect_response(self->lsap, tx_skb);\r\niriap_next_server_state(self, R_CALL);\r\niriap_next_r_connect_state(self, R_RECEIVING);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), unknown event %d\n", __func__, event);\r\nbreak;\r\n}\r\n}\r\nstatic void state_r_call(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nswitch (event) {\r\ncase IAP_LM_DISCONNECT_INDICATION:\r\niriap_next_server_state(self, R_DISCONNECT);\r\niriap_next_r_connect_state(self, R_WAITING);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), unknown event!\n", __func__);\r\nbreak;\r\n}\r\n}\r\nstatic void state_r_waiting(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("%s(), Not implemented\n", __func__);\r\n}\r\nstatic void state_r_wait_active(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("%s(), Not implemented\n", __func__);\r\n}\r\nstatic void state_r_receiving(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nswitch (event) {\r\ncase IAP_RECV_F_LST:\r\niriap_next_r_connect_state(self, R_EXECUTE);\r\niriap_call_indication(self, skb);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), unknown event!\n", __func__);\r\nbreak;\r\n}\r\n}\r\nstatic void state_r_execute(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nswitch (event) {\r\ncase IAP_CALL_RESPONSE:\r\niriap_next_r_connect_state(self, R_RECEIVING);\r\nskb_get(skb);\r\nirlmp_data_request(self->lsap, skb);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), unknown event!\n", __func__);\r\nbreak;\r\n}\r\n}\r\nstatic void state_r_returning(struct iriap_cb *self, IRIAP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\npr_debug("%s(), event=%d\n", __func__, event);\r\nswitch (event) {\r\ncase IAP_RECV_F_LST:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}
