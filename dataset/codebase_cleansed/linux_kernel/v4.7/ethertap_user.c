static int etap_user_init(void *data, void *dev)\r\n{\r\nstruct ethertap_data *pri = data;\r\npri->dev = dev;\r\nreturn 0;\r\n}\r\nstatic void etap_change(int op, unsigned char *addr, unsigned char *netmask,\r\nint fd)\r\n{\r\nstruct addr_change change;\r\nchar *output;\r\nint n;\r\nchange.what = op;\r\nmemcpy(change.addr, addr, sizeof(change.addr));\r\nmemcpy(change.netmask, netmask, sizeof(change.netmask));\r\nCATCH_EINTR(n = write(fd, &change, sizeof(change)));\r\nif (n != sizeof(change)) {\r\nprintk(UM_KERN_ERR "etap_change - request failed, err = %d\n",\r\nerrno);\r\nreturn;\r\n}\r\noutput = uml_kmalloc(UM_KERN_PAGE_SIZE, UM_GFP_KERNEL);\r\nif (output == NULL)\r\nprintk(UM_KERN_ERR "etap_change : Failed to allocate output "\r\n"buffer\n");\r\nread_output(fd, output, UM_KERN_PAGE_SIZE);\r\nif (output != NULL) {\r\nprintk("%s", output);\r\nkfree(output);\r\n}\r\n}\r\nstatic void etap_open_addr(unsigned char *addr, unsigned char *netmask,\r\nvoid *arg)\r\n{\r\netap_change(ADD_ADDR, addr, netmask, *((int *) arg));\r\n}\r\nstatic void etap_close_addr(unsigned char *addr, unsigned char *netmask,\r\nvoid *arg)\r\n{\r\netap_change(DEL_ADDR, addr, netmask, *((int *) arg));\r\n}\r\nstatic void etap_pre_exec(void *arg)\r\n{\r\nstruct etap_pre_exec_data *data = arg;\r\ndup2(data->control_remote, 1);\r\nclose(data->data_me);\r\nclose(data->control_me);\r\n}\r\nstatic int etap_tramp(char *dev, char *gate, int control_me,\r\nint control_remote, int data_me, int data_remote)\r\n{\r\nstruct etap_pre_exec_data pe_data;\r\nint pid, err, n;\r\nchar version_buf[sizeof("nnnnn\0")];\r\nchar data_fd_buf[sizeof("nnnnnn\0")];\r\nchar gate_buf[sizeof("nnn.nnn.nnn.nnn\0")];\r\nchar *setup_args[] = { "uml_net", version_buf, "ethertap", dev,\r\ndata_fd_buf, gate_buf, NULL };\r\nchar *nosetup_args[] = { "uml_net", version_buf, "ethertap",\r\ndev, data_fd_buf, NULL };\r\nchar **args, c;\r\nsprintf(data_fd_buf, "%d", data_remote);\r\nsprintf(version_buf, "%d", UML_NET_VERSION);\r\nif (gate != NULL) {\r\nstrncpy(gate_buf, gate, 15);\r\nargs = setup_args;\r\n}\r\nelse args = nosetup_args;\r\nerr = 0;\r\npe_data.control_remote = control_remote;\r\npe_data.control_me = control_me;\r\npe_data.data_me = data_me;\r\npid = run_helper(etap_pre_exec, &pe_data, args);\r\nif (pid < 0)\r\nerr = pid;\r\nclose(data_remote);\r\nclose(control_remote);\r\nCATCH_EINTR(n = read(control_me, &c, sizeof(c)));\r\nif (n != sizeof(c)) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "etap_tramp : read of status failed, "\r\n"err = %d\n", -err);\r\nreturn err;\r\n}\r\nif (c != 1) {\r\nprintk(UM_KERN_ERR "etap_tramp : uml_net failed\n");\r\nerr = helper_wait(pid);\r\n}\r\nreturn err;\r\n}\r\nstatic int etap_open(void *data)\r\n{\r\nstruct ethertap_data *pri = data;\r\nchar *output;\r\nint data_fds[2], control_fds[2], err, output_len;\r\nerr = tap_open_common(pri->dev, pri->gate_addr);\r\nif (err)\r\nreturn err;\r\nerr = socketpair(AF_UNIX, SOCK_DGRAM, 0, data_fds);\r\nif (err) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "etap_open - data socketpair failed - "\r\n"err = %d\n", errno);\r\nreturn err;\r\n}\r\nerr = socketpair(AF_UNIX, SOCK_STREAM, 0, control_fds);\r\nif (err) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "etap_open - control socketpair failed - "\r\n"err = %d\n", errno);\r\ngoto out_close_data;\r\n}\r\nerr = etap_tramp(pri->dev_name, pri->gate_addr, control_fds[0],\r\ncontrol_fds[1], data_fds[0], data_fds[1]);\r\noutput_len = UM_KERN_PAGE_SIZE;\r\noutput = uml_kmalloc(output_len, UM_GFP_KERNEL);\r\nread_output(control_fds[0], output, output_len);\r\nif (output == NULL)\r\nprintk(UM_KERN_ERR "etap_open : failed to allocate output "\r\n"buffer\n");\r\nelse {\r\nprintk("%s", output);\r\nkfree(output);\r\n}\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "etap_tramp failed - err = %d\n", -err);\r\ngoto out_close_control;\r\n}\r\npri->data_fd = data_fds[0];\r\npri->control_fd = control_fds[0];\r\niter_addresses(pri->dev, etap_open_addr, &pri->control_fd);\r\nreturn data_fds[0];\r\nout_close_control:\r\nclose(control_fds[0]);\r\nclose(control_fds[1]);\r\nout_close_data:\r\nclose(data_fds[0]);\r\nclose(data_fds[1]);\r\nreturn err;\r\n}\r\nstatic void etap_close(int fd, void *data)\r\n{\r\nstruct ethertap_data *pri = data;\r\niter_addresses(pri->dev, etap_close_addr, &pri->control_fd);\r\nclose(fd);\r\nif (shutdown(pri->data_fd, SHUT_RDWR) < 0)\r\nprintk(UM_KERN_ERR "etap_close - shutdown data socket failed, "\r\n"errno = %d\n", errno);\r\nif (shutdown(pri->control_fd, SHUT_RDWR) < 0)\r\nprintk(UM_KERN_ERR "etap_close - shutdown control socket "\r\n"failed, errno = %d\n", errno);\r\nclose(pri->data_fd);\r\npri->data_fd = -1;\r\nclose(pri->control_fd);\r\npri->control_fd = -1;\r\n}\r\nstatic void etap_add_addr(unsigned char *addr, unsigned char *netmask,\r\nvoid *data)\r\n{\r\nstruct ethertap_data *pri = data;\r\ntap_check_ips(pri->gate_addr, addr);\r\nif (pri->control_fd == -1)\r\nreturn;\r\netap_open_addr(addr, netmask, &pri->control_fd);\r\n}\r\nstatic void etap_del_addr(unsigned char *addr, unsigned char *netmask,\r\nvoid *data)\r\n{\r\nstruct ethertap_data *pri = data;\r\nif (pri->control_fd == -1)\r\nreturn;\r\netap_close_addr(addr, netmask, &pri->control_fd);\r\n}
