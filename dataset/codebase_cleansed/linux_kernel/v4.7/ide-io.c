int ide_end_rq(ide_drive_t *drive, struct request *rq, int error,\r\nunsigned int nr_bytes)\r\n{\r\nif ((drive->dev_flags & IDE_DFLAG_DMA_PIO_RETRY) &&\r\ndrive->retry_pio <= 3) {\r\ndrive->dev_flags &= ~IDE_DFLAG_DMA_PIO_RETRY;\r\nide_dma_on(drive);\r\n}\r\nreturn blk_end_request(rq, error, nr_bytes);\r\n}\r\nvoid ide_complete_cmd(ide_drive_t *drive, struct ide_cmd *cmd, u8 stat, u8 err)\r\n{\r\nconst struct ide_tp_ops *tp_ops = drive->hwif->tp_ops;\r\nstruct ide_taskfile *tf = &cmd->tf;\r\nstruct request *rq = cmd->rq;\r\nu8 tf_cmd = tf->command;\r\ntf->error = err;\r\ntf->status = stat;\r\nif (cmd->ftf_flags & IDE_FTFLAG_IN_DATA) {\r\nu8 data[2];\r\ntp_ops->input_data(drive, cmd, data, 2);\r\ncmd->tf.data = data[0];\r\ncmd->hob.data = data[1];\r\n}\r\nide_tf_readback(drive, cmd);\r\nif ((cmd->tf_flags & IDE_TFLAG_CUSTOM_HANDLER) &&\r\ntf_cmd == ATA_CMD_IDLEIMMEDIATE) {\r\nif (tf->lbal != 0xc4) {\r\nprintk(KERN_ERR "%s: head unload failed!\n",\r\ndrive->name);\r\nide_tf_dump(drive->name, cmd);\r\n} else\r\ndrive->dev_flags |= IDE_DFLAG_PARKED;\r\n}\r\nif (rq && rq->cmd_type == REQ_TYPE_ATA_TASKFILE) {\r\nstruct ide_cmd *orig_cmd = rq->special;\r\nif (cmd->tf_flags & IDE_TFLAG_DYN)\r\nkfree(orig_cmd);\r\nelse\r\nmemcpy(orig_cmd, cmd, sizeof(*cmd));\r\n}\r\n}\r\nint ide_complete_rq(ide_drive_t *drive, int error, unsigned int nr_bytes)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct request *rq = hwif->rq;\r\nint rc;\r\nif (blk_noretry_request(rq) && error <= 0)\r\nnr_bytes = blk_rq_sectors(rq) << 9;\r\nrc = ide_end_rq(drive, rq, error, nr_bytes);\r\nif (rc == 0)\r\nhwif->rq = NULL;\r\nreturn rc;\r\n}\r\nvoid ide_kill_rq(ide_drive_t *drive, struct request *rq)\r\n{\r\nu8 drv_req = (rq->cmd_type == REQ_TYPE_DRV_PRIV) && rq->rq_disk;\r\nu8 media = drive->media;\r\ndrive->failed_pc = NULL;\r\nif ((media == ide_floppy || media == ide_tape) && drv_req) {\r\nrq->errors = 0;\r\n} else {\r\nif (media == ide_tape)\r\nrq->errors = IDE_DRV_ERROR_GENERAL;\r\nelse if (rq->cmd_type != REQ_TYPE_FS && rq->errors == 0)\r\nrq->errors = -EIO;\r\n}\r\nide_complete_rq(drive, -EIO, blk_rq_bytes(rq));\r\n}\r\nstatic void ide_tf_set_specify_cmd(ide_drive_t *drive, struct ide_taskfile *tf)\r\n{\r\ntf->nsect = drive->sect;\r\ntf->lbal = drive->sect;\r\ntf->lbam = drive->cyl;\r\ntf->lbah = drive->cyl >> 8;\r\ntf->device = (drive->head - 1) | drive->select;\r\ntf->command = ATA_CMD_INIT_DEV_PARAMS;\r\n}\r\nstatic void ide_tf_set_restore_cmd(ide_drive_t *drive, struct ide_taskfile *tf)\r\n{\r\ntf->nsect = drive->sect;\r\ntf->command = ATA_CMD_RESTORE;\r\n}\r\nstatic void ide_tf_set_setmult_cmd(ide_drive_t *drive, struct ide_taskfile *tf)\r\n{\r\ntf->nsect = drive->mult_req;\r\ntf->command = ATA_CMD_SET_MULTI;\r\n}\r\nstatic ide_startstop_t do_special(ide_drive_t *drive)\r\n{\r\nstruct ide_cmd cmd;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "%s: %s: 0x%02x\n", drive->name, __func__,\r\ndrive->special_flags);\r\n#endif\r\nif (drive->media != ide_disk) {\r\ndrive->special_flags = 0;\r\ndrive->mult_req = 0;\r\nreturn ide_stopped;\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.protocol = ATA_PROT_NODATA;\r\nif (drive->special_flags & IDE_SFLAG_SET_GEOMETRY) {\r\ndrive->special_flags &= ~IDE_SFLAG_SET_GEOMETRY;\r\nide_tf_set_specify_cmd(drive, &cmd.tf);\r\n} else if (drive->special_flags & IDE_SFLAG_RECALIBRATE) {\r\ndrive->special_flags &= ~IDE_SFLAG_RECALIBRATE;\r\nide_tf_set_restore_cmd(drive, &cmd.tf);\r\n} else if (drive->special_flags & IDE_SFLAG_SET_MULTMODE) {\r\ndrive->special_flags &= ~IDE_SFLAG_SET_MULTMODE;\r\nide_tf_set_setmult_cmd(drive, &cmd.tf);\r\n} else\r\nBUG();\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\ncmd.tf_flags = IDE_TFLAG_CUSTOM_HANDLER;\r\ndo_rw_taskfile(drive, &cmd);\r\nreturn ide_started;\r\n}\r\nvoid ide_map_sg(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct scatterlist *sg = hwif->sg_table;\r\nstruct request *rq = cmd->rq;\r\ncmd->sg_nents = blk_rq_map_sg(drive->queue, rq, sg);\r\n}\r\nvoid ide_init_sg_cmd(struct ide_cmd *cmd, unsigned int nr_bytes)\r\n{\r\ncmd->nbytes = cmd->nleft = nr_bytes;\r\ncmd->cursg_ofs = 0;\r\ncmd->cursg = NULL;\r\n}\r\nstatic ide_startstop_t execute_drive_cmd (ide_drive_t *drive,\r\nstruct request *rq)\r\n{\r\nstruct ide_cmd *cmd = rq->special;\r\nif (cmd) {\r\nif (cmd->protocol == ATA_PROT_PIO) {\r\nide_init_sg_cmd(cmd, blk_rq_sectors(rq) << 9);\r\nide_map_sg(drive, cmd);\r\n}\r\nreturn do_rw_taskfile(drive, cmd);\r\n}\r\n#ifdef DEBUG\r\nprintk("%s: DRIVE_CMD (null)\n", drive->name);\r\n#endif\r\nrq->errors = 0;\r\nide_complete_rq(drive, 0, blk_rq_bytes(rq));\r\nreturn ide_stopped;\r\n}\r\nstatic ide_startstop_t ide_special_rq(ide_drive_t *drive, struct request *rq)\r\n{\r\nu8 cmd = rq->cmd[0];\r\nswitch (cmd) {\r\ncase REQ_PARK_HEADS:\r\ncase REQ_UNPARK_HEADS:\r\nreturn ide_do_park_unpark(drive, rq);\r\ncase REQ_DEVSET_EXEC:\r\nreturn ide_do_devset(drive, rq);\r\ncase REQ_DRIVE_RESET:\r\nreturn ide_do_reset(drive);\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic ide_startstop_t start_request (ide_drive_t *drive, struct request *rq)\r\n{\r\nide_startstop_t startstop;\r\nBUG_ON(!(rq->cmd_flags & REQ_STARTED));\r\n#ifdef DEBUG\r\nprintk("%s: start_request: current=0x%08lx\n",\r\ndrive->hwif->name, (unsigned long) rq);\r\n#endif\r\nif (drive->max_failures && (drive->failures > drive->max_failures)) {\r\nrq->cmd_flags |= REQ_FAILED;\r\ngoto kill_rq;\r\n}\r\nif (ata_pm_request(rq))\r\nide_check_pm_state(drive, rq);\r\ndrive->hwif->tp_ops->dev_select(drive);\r\nif (ide_wait_stat(&startstop, drive, drive->ready_stat,\r\nATA_BUSY | ATA_DRQ, WAIT_READY)) {\r\nprintk(KERN_ERR "%s: drive not ready for command\n", drive->name);\r\nreturn startstop;\r\n}\r\nif (drive->special_flags == 0) {\r\nstruct ide_driver *drv;\r\nif (drive->current_speed == 0xff)\r\nide_config_drive_speed(drive, drive->desired_speed);\r\nif (rq->cmd_type == REQ_TYPE_ATA_TASKFILE)\r\nreturn execute_drive_cmd(drive, rq);\r\nelse if (ata_pm_request(rq)) {\r\nstruct ide_pm_state *pm = rq->special;\r\n#ifdef DEBUG_PM\r\nprintk("%s: start_power_step(step: %d)\n",\r\ndrive->name, pm->pm_step);\r\n#endif\r\nstartstop = ide_start_power_step(drive, rq);\r\nif (startstop == ide_stopped &&\r\npm->pm_step == IDE_PM_COMPLETED)\r\nide_complete_pm_rq(drive, rq);\r\nreturn startstop;\r\n} else if (!rq->rq_disk && rq->cmd_type == REQ_TYPE_DRV_PRIV)\r\nreturn ide_special_rq(drive, rq);\r\ndrv = *(struct ide_driver **)rq->rq_disk->private_data;\r\nreturn drv->do_request(drive, rq, blk_rq_pos(rq));\r\n}\r\nreturn do_special(drive);\r\nkill_rq:\r\nide_kill_rq(drive, rq);\r\nreturn ide_stopped;\r\n}\r\nvoid ide_stall_queue (ide_drive_t *drive, unsigned long timeout)\r\n{\r\nif (timeout > WAIT_WORSTCASE)\r\ntimeout = WAIT_WORSTCASE;\r\ndrive->sleep = timeout + jiffies;\r\ndrive->dev_flags |= IDE_DFLAG_SLEEPING;\r\n}\r\nstatic inline int ide_lock_port(ide_hwif_t *hwif)\r\n{\r\nif (hwif->busy)\r\nreturn 1;\r\nhwif->busy = 1;\r\nreturn 0;\r\n}\r\nstatic inline void ide_unlock_port(ide_hwif_t *hwif)\r\n{\r\nhwif->busy = 0;\r\n}\r\nstatic inline int ide_lock_host(struct ide_host *host, ide_hwif_t *hwif)\r\n{\r\nint rc = 0;\r\nif (host->host_flags & IDE_HFLAG_SERIALIZE) {\r\nrc = test_and_set_bit_lock(IDE_HOST_BUSY, &host->host_busy);\r\nif (rc == 0) {\r\nif (host->get_lock)\r\nhost->get_lock(ide_intr, hwif);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic inline void ide_unlock_host(struct ide_host *host)\r\n{\r\nif (host->host_flags & IDE_HFLAG_SERIALIZE) {\r\nif (host->release_lock)\r\nhost->release_lock();\r\nclear_bit_unlock(IDE_HOST_BUSY, &host->host_busy);\r\n}\r\n}\r\nstatic void __ide_requeue_and_plug(struct request_queue *q, struct request *rq)\r\n{\r\nif (rq)\r\nblk_requeue_request(q, rq);\r\nif (rq || blk_peek_request(q)) {\r\nblk_delay_queue(q, 3);\r\n}\r\n}\r\nvoid ide_requeue_and_plug(ide_drive_t *drive, struct request *rq)\r\n{\r\nstruct request_queue *q = drive->queue;\r\nunsigned long flags;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\n__ide_requeue_and_plug(q, rq);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\n}\r\nvoid do_ide_request(struct request_queue *q)\r\n{\r\nide_drive_t *drive = q->queuedata;\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_host *host = hwif->host;\r\nstruct request *rq = NULL;\r\nide_startstop_t startstop;\r\nunsigned long queue_run_ms = 3;\r\nspin_unlock_irq(q->queue_lock);\r\nmight_sleep();\r\nif (ide_lock_host(host, hwif))\r\ngoto plug_device_2;\r\nspin_lock_irq(&hwif->lock);\r\nif (!ide_lock_port(hwif)) {\r\nide_hwif_t *prev_port;\r\nWARN_ON_ONCE(hwif->rq);\r\nrepeat:\r\nprev_port = hwif->host->cur_port;\r\nif (drive->dev_flags & IDE_DFLAG_SLEEPING &&\r\ntime_after(drive->sleep, jiffies)) {\r\nunsigned long left = jiffies - drive->sleep;\r\nqueue_run_ms = jiffies_to_msecs(left + 1);\r\nide_unlock_port(hwif);\r\ngoto plug_device;\r\n}\r\nif ((hwif->host->host_flags & IDE_HFLAG_SERIALIZE) &&\r\nhwif != prev_port) {\r\nide_drive_t *cur_dev =\r\nprev_port ? prev_port->cur_dev : NULL;\r\nif (cur_dev &&\r\n(cur_dev->dev_flags & IDE_DFLAG_NIEN_QUIRK) == 0)\r\nprev_port->tp_ops->write_devctl(prev_port,\r\nATA_NIEN |\r\nATA_DEVCTL_OBS);\r\nhwif->host->cur_port = hwif;\r\n}\r\nhwif->cur_dev = drive;\r\ndrive->dev_flags &= ~(IDE_DFLAG_SLEEPING | IDE_DFLAG_PARKED);\r\nspin_unlock_irq(&hwif->lock);\r\nspin_lock_irq(q->queue_lock);\r\nif (!rq)\r\nrq = blk_fetch_request(drive->queue);\r\nspin_unlock_irq(q->queue_lock);\r\nspin_lock_irq(&hwif->lock);\r\nif (!rq) {\r\nide_unlock_port(hwif);\r\ngoto out;\r\n}\r\nif ((drive->dev_flags & IDE_DFLAG_BLOCKED) &&\r\nata_pm_request(rq) == 0 &&\r\n(rq->cmd_flags & REQ_PREEMPT) == 0) {\r\nide_unlock_port(hwif);\r\ngoto plug_device;\r\n}\r\nhwif->rq = rq;\r\nspin_unlock_irq(&hwif->lock);\r\nstartstop = start_request(drive, rq);\r\nspin_lock_irq(&hwif->lock);\r\nif (startstop == ide_stopped) {\r\nrq = hwif->rq;\r\nhwif->rq = NULL;\r\ngoto repeat;\r\n}\r\n} else\r\ngoto plug_device;\r\nout:\r\nspin_unlock_irq(&hwif->lock);\r\nif (rq == NULL)\r\nide_unlock_host(host);\r\nspin_lock_irq(q->queue_lock);\r\nreturn;\r\nplug_device:\r\nspin_unlock_irq(&hwif->lock);\r\nide_unlock_host(host);\r\nplug_device_2:\r\nspin_lock_irq(q->queue_lock);\r\n__ide_requeue_and_plug(q, rq);\r\n}\r\nstatic int drive_is_ready(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 stat = 0;\r\nif (drive->waiting_for_dma)\r\nreturn hwif->dma_ops->dma_test_irq(drive);\r\nif (hwif->io_ports.ctl_addr &&\r\n(hwif->host_flags & IDE_HFLAG_BROKEN_ALTSTATUS) == 0)\r\nstat = hwif->tp_ops->read_altstatus(hwif);\r\nelse\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif (stat & ATA_BUSY)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid ide_timer_expiry (unsigned long data)\r\n{\r\nide_hwif_t *hwif = (ide_hwif_t *)data;\r\nide_drive_t *uninitialized_var(drive);\r\nide_handler_t *handler;\r\nunsigned long flags;\r\nint wait = -1;\r\nint plug_device = 0;\r\nstruct request *uninitialized_var(rq_in_flight);\r\nspin_lock_irqsave(&hwif->lock, flags);\r\nhandler = hwif->handler;\r\nif (handler == NULL || hwif->req_gen != hwif->req_gen_timer) {\r\n} else {\r\nide_expiry_t *expiry = hwif->expiry;\r\nide_startstop_t startstop = ide_stopped;\r\ndrive = hwif->cur_dev;\r\nif (expiry) {\r\nwait = expiry(drive);\r\nif (wait > 0) {\r\nhwif->timer.expires = jiffies + wait;\r\nhwif->req_gen_timer = hwif->req_gen;\r\nadd_timer(&hwif->timer);\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\nreturn;\r\n}\r\n}\r\nhwif->handler = NULL;\r\nhwif->expiry = NULL;\r\nspin_unlock(&hwif->lock);\r\ndisable_irq(hwif->irq);\r\nlocal_irq_disable();\r\nif (hwif->polling) {\r\nstartstop = handler(drive);\r\n} else if (drive_is_ready(drive)) {\r\nif (drive->waiting_for_dma)\r\nhwif->dma_ops->dma_lost_irq(drive);\r\nif (hwif->port_ops && hwif->port_ops->clear_irq)\r\nhwif->port_ops->clear_irq(drive);\r\nprintk(KERN_WARNING "%s: lost interrupt\n",\r\ndrive->name);\r\nstartstop = handler(drive);\r\n} else {\r\nif (drive->waiting_for_dma)\r\nstartstop = ide_dma_timeout_retry(drive, wait);\r\nelse\r\nstartstop = ide_error(drive, "irq timeout",\r\nhwif->tp_ops->read_status(hwif));\r\n}\r\nspin_lock_irq(&hwif->lock);\r\nenable_irq(hwif->irq);\r\nif (startstop == ide_stopped && hwif->polling == 0) {\r\nrq_in_flight = hwif->rq;\r\nhwif->rq = NULL;\r\nide_unlock_port(hwif);\r\nplug_device = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\nif (plug_device) {\r\nide_unlock_host(hwif->host);\r\nide_requeue_and_plug(drive, rq_in_flight);\r\n}\r\n}\r\nstatic void unexpected_intr(int irq, ide_hwif_t *hwif)\r\n{\r\nu8 stat = hwif->tp_ops->read_status(hwif);\r\nif (!OK_STAT(stat, ATA_DRDY, BAD_STAT)) {\r\nstatic unsigned long last_msgtime, count;\r\n++count;\r\nif (time_after(jiffies, last_msgtime + HZ)) {\r\nlast_msgtime = jiffies;\r\nprintk(KERN_ERR "%s: unexpected interrupt, "\r\n"status=0x%02x, count=%ld\n",\r\nhwif->name, stat, count);\r\n}\r\n}\r\n}\r\nirqreturn_t ide_intr (int irq, void *dev_id)\r\n{\r\nide_hwif_t *hwif = (ide_hwif_t *)dev_id;\r\nstruct ide_host *host = hwif->host;\r\nide_drive_t *uninitialized_var(drive);\r\nide_handler_t *handler;\r\nunsigned long flags;\r\nide_startstop_t startstop;\r\nirqreturn_t irq_ret = IRQ_NONE;\r\nint plug_device = 0;\r\nstruct request *uninitialized_var(rq_in_flight);\r\nif (host->host_flags & IDE_HFLAG_SERIALIZE) {\r\nif (hwif != host->cur_port)\r\ngoto out_early;\r\n}\r\nspin_lock_irqsave(&hwif->lock, flags);\r\nif (hwif->port_ops && hwif->port_ops->test_irq &&\r\nhwif->port_ops->test_irq(hwif) == 0)\r\ngoto out;\r\nhandler = hwif->handler;\r\nif (handler == NULL || hwif->polling) {\r\nif ((host->irq_flags & IRQF_SHARED) == 0) {\r\nunexpected_intr(irq, hwif);\r\n} else {\r\n(void)hwif->tp_ops->read_status(hwif);\r\n}\r\ngoto out;\r\n}\r\ndrive = hwif->cur_dev;\r\nif (!drive_is_ready(drive))\r\ngoto out;\r\nhwif->handler = NULL;\r\nhwif->expiry = NULL;\r\nhwif->req_gen++;\r\ndel_timer(&hwif->timer);\r\nspin_unlock(&hwif->lock);\r\nif (hwif->port_ops && hwif->port_ops->clear_irq)\r\nhwif->port_ops->clear_irq(drive);\r\nif (drive->dev_flags & IDE_DFLAG_UNMASK)\r\nlocal_irq_enable_in_hardirq();\r\nstartstop = handler(drive);\r\nspin_lock_irq(&hwif->lock);\r\nif (startstop == ide_stopped && hwif->polling == 0) {\r\nBUG_ON(hwif->handler);\r\nrq_in_flight = hwif->rq;\r\nhwif->rq = NULL;\r\nide_unlock_port(hwif);\r\nplug_device = 1;\r\n}\r\nirq_ret = IRQ_HANDLED;\r\nout:\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\nout_early:\r\nif (plug_device) {\r\nide_unlock_host(hwif->host);\r\nide_requeue_and_plug(drive, rq_in_flight);\r\n}\r\nreturn irq_ret;\r\n}\r\nvoid ide_pad_transfer(ide_drive_t *drive, int write, int len)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 buf[4] = { 0 };\r\nwhile (len > 0) {\r\nif (write)\r\nhwif->tp_ops->output_data(drive, NULL, buf, min(4, len));\r\nelse\r\nhwif->tp_ops->input_data(drive, NULL, buf, min(4, len));\r\nlen -= 4;\r\n}\r\n}
