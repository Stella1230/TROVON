static int rmi_set_page(struct rmi_i2c_xport *rmi_i2c, u8 page)\r\n{\r\nstruct i2c_client *client = rmi_i2c->client;\r\nu8 txbuf[2] = {RMI_PAGE_SELECT_REGISTER, page};\r\nint retval;\r\nretval = i2c_master_send(client, txbuf, sizeof(txbuf));\r\nif (retval != sizeof(txbuf)) {\r\ndev_err(&client->dev,\r\n"%s: set page failed: %d.", __func__, retval);\r\nreturn (retval < 0) ? retval : -EIO;\r\n}\r\nrmi_i2c->page = page;\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_write_block(struct rmi_transport_dev *xport, u16 addr,\r\nconst void *buf, size_t len)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c =\r\ncontainer_of(xport, struct rmi_i2c_xport, xport);\r\nstruct i2c_client *client = rmi_i2c->client;\r\nsize_t tx_size = len + 1;\r\nint retval;\r\nmutex_lock(&rmi_i2c->page_mutex);\r\nif (!rmi_i2c->tx_buf || rmi_i2c->tx_buf_size < tx_size) {\r\nif (rmi_i2c->tx_buf)\r\ndevm_kfree(&client->dev, rmi_i2c->tx_buf);\r\nrmi_i2c->tx_buf_size = tx_size + BUFFER_SIZE_INCREMENT;\r\nrmi_i2c->tx_buf = devm_kzalloc(&client->dev,\r\nrmi_i2c->tx_buf_size,\r\nGFP_KERNEL);\r\nif (!rmi_i2c->tx_buf) {\r\nrmi_i2c->tx_buf_size = 0;\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\n}\r\nrmi_i2c->tx_buf[0] = addr & 0xff;\r\nmemcpy(rmi_i2c->tx_buf + 1, buf, len);\r\nif (RMI_I2C_PAGE(addr) != rmi_i2c->page) {\r\nretval = rmi_set_page(rmi_i2c, RMI_I2C_PAGE(addr));\r\nif (retval)\r\ngoto exit;\r\n}\r\nretval = i2c_master_send(client, rmi_i2c->tx_buf, tx_size);\r\nif (retval == tx_size)\r\nretval = 0;\r\nelse if (retval >= 0)\r\nretval = -EIO;\r\nexit:\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev,\r\n"write %zd bytes at %#06x: %d (%*ph)\n",\r\nlen, addr, retval, (int)len, buf);\r\nmutex_unlock(&rmi_i2c->page_mutex);\r\nreturn retval;\r\n}\r\nstatic int rmi_i2c_read_block(struct rmi_transport_dev *xport, u16 addr,\r\nvoid *buf, size_t len)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c =\r\ncontainer_of(xport, struct rmi_i2c_xport, xport);\r\nstruct i2c_client *client = rmi_i2c->client;\r\nu8 addr_offset = addr & 0xff;\r\nint retval;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = sizeof(addr_offset),\r\n.buf = &addr_offset,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n},\r\n};\r\nmutex_lock(&rmi_i2c->page_mutex);\r\nif (RMI_I2C_PAGE(addr) != rmi_i2c->page) {\r\nretval = rmi_set_page(rmi_i2c, RMI_I2C_PAGE(addr));\r\nif (retval)\r\ngoto exit;\r\n}\r\nretval = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (retval == ARRAY_SIZE(msgs))\r\nretval = 0;\r\nelse if (retval >= 0)\r\nretval = -EIO;\r\nexit:\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev,\r\n"read %zd bytes at %#06x: %d (%*ph)\n",\r\nlen, addr, retval, (int)len, buf);\r\nmutex_unlock(&rmi_i2c->page_mutex);\r\nreturn retval;\r\n}\r\nstatic irqreturn_t rmi_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c = dev_id;\r\nstruct rmi_device *rmi_dev = rmi_i2c->xport.rmi_dev;\r\nint ret;\r\nret = rmi_process_interrupt_requests(rmi_dev);\r\nif (ret)\r\nrmi_dbg(RMI_DEBUG_XPORT, &rmi_dev->dev,\r\n"Failed to process interrupt request: %d\n", ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rmi_i2c_init_irq(struct i2c_client *client)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint irq_flags = irqd_get_trigger_type(irq_get_irq_data(rmi_i2c->irq));\r\nint ret;\r\nif (!irq_flags)\r\nirq_flags = IRQF_TRIGGER_LOW;\r\nret = devm_request_threaded_irq(&client->dev, rmi_i2c->irq, NULL,\r\nrmi_i2c_irq, irq_flags | IRQF_ONESHOT, client->name,\r\nrmi_i2c);\r\nif (ret < 0) {\r\ndev_warn(&client->dev, "Failed to register interrupt %d\n",\r\nrmi_i2c->irq);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rmi_device_platform_data *pdata;\r\nstruct rmi_device_platform_data *client_pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct rmi_i2c_xport *rmi_i2c;\r\nint retval;\r\nrmi_i2c = devm_kzalloc(&client->dev, sizeof(struct rmi_i2c_xport),\r\nGFP_KERNEL);\r\nif (!rmi_i2c)\r\nreturn -ENOMEM;\r\npdata = &rmi_i2c->xport.pdata;\r\nif (!client->dev.of_node && client_pdata)\r\n*pdata = *client_pdata;\r\nif (client->irq > 0)\r\nrmi_i2c->irq = client->irq;\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev, "Probing %s.\n",\r\ndev_name(&client->dev));\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev,\r\n"adapter does not support required functionality.\n");\r\nreturn -ENODEV;\r\n}\r\nrmi_i2c->client = client;\r\nmutex_init(&rmi_i2c->page_mutex);\r\nrmi_i2c->xport.dev = &client->dev;\r\nrmi_i2c->xport.proto_name = "i2c";\r\nrmi_i2c->xport.ops = &rmi_i2c_ops;\r\ni2c_set_clientdata(client, rmi_i2c);\r\nretval = rmi_set_page(rmi_i2c, 0);\r\nif (retval) {\r\ndev_err(&client->dev, "Failed to set page select to 0.\n");\r\nreturn retval;\r\n}\r\nretval = rmi_register_transport_device(&rmi_i2c->xport);\r\nif (retval) {\r\ndev_err(&client->dev, "Failed to register transport driver at 0x%.2X.\n",\r\nclient->addr);\r\nreturn retval;\r\n}\r\nretval = rmi_i2c_init_irq(client);\r\nif (retval < 0)\r\nreturn retval;\r\ndev_info(&client->dev, "registered rmi i2c driver at %#04x.\n",\r\nclient->addr);\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nrmi_unregister_transport_device(&rmi_i2c->xport);\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nret = rmi_driver_suspend(rmi_i2c->xport.rmi_dev);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\ndisable_irq(rmi_i2c->irq);\r\nif (device_may_wakeup(&client->dev)) {\r\nret = enable_irq_wake(rmi_i2c->irq);\r\nif (!ret)\r\ndev_warn(dev, "Failed to enable irq for wake: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rmi_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nenable_irq(rmi_i2c->irq);\r\nif (device_may_wakeup(&client->dev)) {\r\nret = disable_irq_wake(rmi_i2c->irq);\r\nif (!ret)\r\ndev_warn(dev, "Failed to disable irq for wake: %d\n",\r\nret);\r\n}\r\nret = rmi_driver_resume(rmi_i2c->xport.rmi_dev);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rmi_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nret = rmi_driver_suspend(rmi_i2c->xport.rmi_dev);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\ndisable_irq(rmi_i2c->irq);\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nenable_irq(rmi_i2c->irq);\r\nret = rmi_driver_resume(rmi_i2c->xport.rmi_dev);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nreturn 0;\r\n}
