static struct rs_control *rs_init(int symsize, int gfpoly, int (*gffunc)(int),\r\nint fcr, int prim, int nroots)\r\n{\r\nstruct rs_control *rs;\r\nint i, j, sr, root, iprim;\r\nrs = kmalloc(sizeof (struct rs_control), GFP_KERNEL);\r\nif (rs == NULL)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&rs->list);\r\nrs->mm = symsize;\r\nrs->nn = (1 << symsize) - 1;\r\nrs->fcr = fcr;\r\nrs->prim = prim;\r\nrs->nroots = nroots;\r\nrs->gfpoly = gfpoly;\r\nrs->gffunc = gffunc;\r\nrs->alpha_to = kmalloc(sizeof(uint16_t) * (rs->nn + 1), GFP_KERNEL);\r\nif (rs->alpha_to == NULL)\r\ngoto errrs;\r\nrs->index_of = kmalloc(sizeof(uint16_t) * (rs->nn + 1), GFP_KERNEL);\r\nif (rs->index_of == NULL)\r\ngoto erralp;\r\nrs->genpoly = kmalloc(sizeof(uint16_t) * (rs->nroots + 1), GFP_KERNEL);\r\nif(rs->genpoly == NULL)\r\ngoto erridx;\r\nrs->index_of[0] = rs->nn;\r\nrs->alpha_to[rs->nn] = 0;\r\nif (gfpoly) {\r\nsr = 1;\r\nfor (i = 0; i < rs->nn; i++) {\r\nrs->index_of[sr] = i;\r\nrs->alpha_to[i] = sr;\r\nsr <<= 1;\r\nif (sr & (1 << symsize))\r\nsr ^= gfpoly;\r\nsr &= rs->nn;\r\n}\r\n} else {\r\nsr = gffunc(0);\r\nfor (i = 0; i < rs->nn; i++) {\r\nrs->index_of[sr] = i;\r\nrs->alpha_to[i] = sr;\r\nsr = gffunc(sr);\r\n}\r\n}\r\nif(sr != rs->alpha_to[0])\r\ngoto errpol;\r\nfor(iprim = 1; (iprim % prim) != 0; iprim += rs->nn);\r\nrs->iprim = iprim / prim;\r\nrs->genpoly[0] = 1;\r\nfor (i = 0, root = fcr * prim; i < nroots; i++, root += prim) {\r\nrs->genpoly[i + 1] = 1;\r\nfor (j = i; j > 0; j--) {\r\nif (rs->genpoly[j] != 0) {\r\nrs->genpoly[j] = rs->genpoly[j -1] ^\r\nrs->alpha_to[rs_modnn(rs,\r\nrs->index_of[rs->genpoly[j]] + root)];\r\n} else\r\nrs->genpoly[j] = rs->genpoly[j - 1];\r\n}\r\nrs->genpoly[0] =\r\nrs->alpha_to[rs_modnn(rs,\r\nrs->index_of[rs->genpoly[0]] + root)];\r\n}\r\nfor (i = 0; i <= nroots; i++)\r\nrs->genpoly[i] = rs->index_of[rs->genpoly[i]];\r\nreturn rs;\r\nerrpol:\r\nkfree(rs->genpoly);\r\nerridx:\r\nkfree(rs->index_of);\r\nerralp:\r\nkfree(rs->alpha_to);\r\nerrrs:\r\nkfree(rs);\r\nreturn NULL;\r\n}\r\nvoid free_rs(struct rs_control *rs)\r\n{\r\nmutex_lock(&rslistlock);\r\nrs->users--;\r\nif(!rs->users) {\r\nlist_del(&rs->list);\r\nkfree(rs->alpha_to);\r\nkfree(rs->index_of);\r\nkfree(rs->genpoly);\r\nkfree(rs);\r\n}\r\nmutex_unlock(&rslistlock);\r\n}\r\nstatic struct rs_control *init_rs_internal(int symsize, int gfpoly,\r\nint (*gffunc)(int), int fcr,\r\nint prim, int nroots)\r\n{\r\nstruct list_head *tmp;\r\nstruct rs_control *rs;\r\nif (symsize < 1)\r\nreturn NULL;\r\nif (fcr < 0 || fcr >= (1<<symsize))\r\nreturn NULL;\r\nif (prim <= 0 || prim >= (1<<symsize))\r\nreturn NULL;\r\nif (nroots < 0 || nroots >= (1<<symsize))\r\nreturn NULL;\r\nmutex_lock(&rslistlock);\r\nlist_for_each(tmp, &rslist) {\r\nrs = list_entry(tmp, struct rs_control, list);\r\nif (symsize != rs->mm)\r\ncontinue;\r\nif (gfpoly != rs->gfpoly)\r\ncontinue;\r\nif (gffunc != rs->gffunc)\r\ncontinue;\r\nif (fcr != rs->fcr)\r\ncontinue;\r\nif (prim != rs->prim)\r\ncontinue;\r\nif (nroots != rs->nroots)\r\ncontinue;\r\nrs->users++;\r\ngoto out;\r\n}\r\nrs = rs_init(symsize, gfpoly, gffunc, fcr, prim, nroots);\r\nif (rs) {\r\nrs->users = 1;\r\nlist_add(&rs->list, &rslist);\r\n}\r\nout:\r\nmutex_unlock(&rslistlock);\r\nreturn rs;\r\n}\r\nstruct rs_control *init_rs(int symsize, int gfpoly, int fcr, int prim,\r\nint nroots)\r\n{\r\nreturn init_rs_internal(symsize, gfpoly, NULL, fcr, prim, nroots);\r\n}\r\nstruct rs_control *init_rs_non_canonical(int symsize, int (*gffunc)(int),\r\nint fcr, int prim, int nroots)\r\n{\r\nreturn init_rs_internal(symsize, 0, gffunc, fcr, prim, nroots);\r\n}\r\nint encode_rs8(struct rs_control *rs, uint8_t *data, int len, uint16_t *par,\r\nuint16_t invmsk)\r\n{\r\n#include "encode_rs.c"\r\n}\r\nint decode_rs8(struct rs_control *rs, uint8_t *data, uint16_t *par, int len,\r\nuint16_t *s, int no_eras, int *eras_pos, uint16_t invmsk,\r\nuint16_t *corr)\r\n{\r\n#include "decode_rs.c"\r\n}\r\nint encode_rs16(struct rs_control *rs, uint16_t *data, int len, uint16_t *par,\r\nuint16_t invmsk)\r\n{\r\n#include "encode_rs.c"\r\n}\r\nint decode_rs16(struct rs_control *rs, uint16_t *data, uint16_t *par, int len,\r\nuint16_t *s, int no_eras, int *eras_pos, uint16_t invmsk,\r\nuint16_t *corr)\r\n{\r\n#include "decode_rs.c"\r\n}
