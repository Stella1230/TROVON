void\r\nnvkm_agp_fini(struct nvkm_pci *pci)\r\n{\r\nif (pci->agp.acquired) {\r\nagp_backend_release(pci->agp.bridge);\r\npci->agp.acquired = false;\r\n}\r\n}\r\nvoid\r\nnvkm_agp_preinit(struct nvkm_pci *pci)\r\n{\r\nstruct nvkm_device *device = pci->subdev.device;\r\nu32 mode = nvkm_pci_rd32(pci, 0x004c);\r\nu32 save[2];\r\nif ((mode | pci->agp.mode) & PCI_AGP_COMMAND_FW) {\r\nmode = pci->agp.mode & ~PCI_AGP_COMMAND_FW;\r\nagp_enable(pci->agp.bridge, mode);\r\n}\r\nsave[0] = nvkm_pci_rd32(pci, 0x0004);\r\nnvkm_pci_wr32(pci, 0x0004, save[0] & ~0x00000004);\r\nnvkm_pci_wr32(pci, 0x004c, 0x00000000);\r\nsave[1] = nvkm_mask(device, 0x000200, 0x00011100, 0x00000000);\r\nnvkm_mask(device, 0x000200, 0x00011100, save[1]);\r\nnvkm_pci_wr32(pci, 0x0004, save[0]);\r\n}\r\nint\r\nnvkm_agp_init(struct nvkm_pci *pci)\r\n{\r\nif (!agp_backend_acquire(pci->pdev)) {\r\nnvkm_error(&pci->subdev, "failed to acquire agp\n");\r\nreturn -ENODEV;\r\n}\r\nagp_enable(pci->agp.bridge, pci->agp.mode);\r\npci->agp.acquired = true;\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_agp_dtor(struct nvkm_pci *pci)\r\n{\r\narch_phys_wc_del(pci->agp.mtrr);\r\n}\r\nvoid\r\nnvkm_agp_ctor(struct nvkm_pci *pci)\r\n{\r\nconst struct nvkm_device_agp_quirk *quirk = nvkm_device_agp_quirks;\r\nstruct nvkm_subdev *subdev = &pci->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct agp_kern_info info;\r\nint mode = -1;\r\n#ifdef __powerpc__\r\nmode = 0;\r\n#endif\r\nmode = nvkm_longopt(device->cfgopt, "NvAGP", mode);\r\nif (!(pci->agp.bridge = agp_backend_acquire(pci->pdev))) {\r\nnvkm_warn(subdev, "failed to acquire agp\n");\r\nreturn;\r\n}\r\nagp_copy_info(pci->agp.bridge, &info);\r\nagp_backend_release(pci->agp.bridge);\r\npci->agp.mode = info.mode;\r\npci->agp.base = info.aper_base;\r\npci->agp.size = info.aper_size * 1024 * 1024;\r\npci->agp.cma = info.cant_use_aperture;\r\npci->agp.mtrr = -1;\r\nwhile (quirk->hostbridge_vendor) {\r\nif (info.device->vendor == quirk->hostbridge_vendor &&\r\ninfo.device->device == quirk->hostbridge_device &&\r\n(quirk->chip_vendor == (u16)PCI_ANY_ID ||\r\npci->pdev->vendor == quirk->chip_vendor) &&\r\n(quirk->chip_device == (u16)PCI_ANY_ID ||\r\npci->pdev->device == quirk->chip_device)) {\r\nnvkm_info(subdev, "forcing default agp mode to %dX, "\r\n"use NvAGP=<mode> to override\n",\r\nquirk->mode);\r\nmode = quirk->mode;\r\nbreak;\r\n}\r\nquirk++;\r\n}\r\nif (mode >= 1) {\r\nif (pci->agp.mode & 0x00000008)\r\nmode /= 4;\r\npci->agp.mode &= ~0x00000007;\r\npci->agp.mode |= (mode & 0x7);\r\n} else\r\nif (mode == 0) {\r\npci->agp.bridge = NULL;\r\nreturn;\r\n}\r\nif (device->chipset == 0x18)\r\npci->agp.mode &= ~PCI_AGP_COMMAND_FW;\r\npci->agp.mtrr = arch_phys_wc_add(pci->agp.base, pci->agp.size);\r\n}
