void tilcdc_module_init(struct tilcdc_module *mod, const char *name,\r\nconst struct tilcdc_module_ops *funcs)\r\n{\r\nmod->name = name;\r\nmod->funcs = funcs;\r\nINIT_LIST_HEAD(&mod->list);\r\nlist_add(&mod->list, &module_list);\r\n}\r\nvoid tilcdc_module_cleanup(struct tilcdc_module *mod)\r\n{\r\nlist_del(&mod->list);\r\n}\r\nstatic struct drm_framebuffer *tilcdc_fb_create(struct drm_device *dev,\r\nstruct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nreturn drm_fb_cma_create(dev, file_priv, mode_cmd);\r\n}\r\nstatic void tilcdc_fb_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\ndrm_fbdev_cma_hotplug_event(priv->fbdev);\r\n}\r\nstatic int modeset_init(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nstruct tilcdc_module *mod;\r\ndrm_mode_config_init(dev);\r\npriv->crtc = tilcdc_crtc_create(dev);\r\nlist_for_each_entry(mod, &module_list, list) {\r\nDBG("loading module: %s", mod->name);\r\nmod->funcs->modeset_init(mod, dev);\r\n}\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.max_width = tilcdc_crtc_max_width(priv->crtc);\r\ndev->mode_config.max_height = 2048;\r\ndev->mode_config.funcs = &mode_config_funcs;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct tilcdc_drm_private *priv = container_of(nb,\r\nstruct tilcdc_drm_private, freq_transition);\r\nif (val == CPUFREQ_POSTCHANGE) {\r\nif (priv->lcd_fck_rate != clk_get_rate(priv->clk)) {\r\npriv->lcd_fck_rate = clk_get_rate(priv->clk);\r\ntilcdc_crtc_update_clk(priv->crtc);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tilcdc_unload(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\ntilcdc_crtc_dpms(priv->crtc, DRM_MODE_DPMS_OFF);\r\ntilcdc_remove_external_encoders(dev);\r\ndrm_fbdev_cma_fini(priv->fbdev);\r\ndrm_kms_helper_poll_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\ndrm_vblank_cleanup(dev);\r\npm_runtime_get_sync(dev->dev);\r\ndrm_irq_uninstall(dev);\r\npm_runtime_put_sync(dev->dev);\r\n#ifdef CONFIG_CPU_FREQ\r\ncpufreq_unregister_notifier(&priv->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n#endif\r\nif (priv->clk)\r\nclk_put(priv->clk);\r\nif (priv->mmio)\r\niounmap(priv->mmio);\r\nflush_workqueue(priv->wq);\r\ndestroy_workqueue(priv->wq);\r\ndev->dev_private = NULL;\r\npm_runtime_disable(dev->dev);\r\nreturn 0;\r\n}\r\nstatic int tilcdc_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct platform_device *pdev = dev->platformdev;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct tilcdc_drm_private *priv;\r\nstruct tilcdc_module *mod;\r\nstruct resource *res;\r\nu32 bpp = 0;\r\nint ret;\r\npriv = devm_kzalloc(dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (priv)\r\npriv->saved_register =\r\ndevm_kcalloc(dev->dev, tilcdc_num_regs(),\r\nsizeof(*priv->saved_register), GFP_KERNEL);\r\nif (!priv || !priv->saved_register) {\r\ndev_err(dev->dev, "failed to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dev_private = priv;\r\npriv->is_componentized =\r\ntilcdc_get_external_components(dev->dev, NULL) > 0;\r\npriv->wq = alloc_ordered_workqueue("tilcdc", 0);\r\nif (!priv->wq) {\r\nret = -ENOMEM;\r\ngoto fail_unset_priv;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev->dev, "failed to get memory resource\n");\r\nret = -EINVAL;\r\ngoto fail_free_wq;\r\n}\r\npriv->mmio = ioremap_nocache(res->start, resource_size(res));\r\nif (!priv->mmio) {\r\ndev_err(dev->dev, "failed to ioremap\n");\r\nret = -ENOMEM;\r\ngoto fail_free_wq;\r\n}\r\npriv->clk = clk_get(dev->dev, "fck");\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev->dev, "failed to get functional clock\n");\r\nret = -ENODEV;\r\ngoto fail_iounmap;\r\n}\r\n#ifdef CONFIG_CPU_FREQ\r\npriv->lcd_fck_rate = clk_get_rate(priv->clk);\r\npriv->freq_transition.notifier_call = cpufreq_transition;\r\nret = cpufreq_register_notifier(&priv->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to register cpufreq notifier\n");\r\ngoto fail_put_clk;\r\n}\r\n#endif\r\nif (of_property_read_u32(node, "max-bandwidth", &priv->max_bandwidth))\r\npriv->max_bandwidth = TILCDC_DEFAULT_MAX_BANDWIDTH;\r\nDBG("Maximum Bandwidth Value %d", priv->max_bandwidth);\r\nif (of_property_read_u32(node, "ti,max-width", &priv->max_width))\r\npriv->max_width = TILCDC_DEFAULT_MAX_WIDTH;\r\nDBG("Maximum Horizontal Pixel Width Value %dpixels", priv->max_width);\r\nif (of_property_read_u32(node, "ti,max-pixelclock",\r\n&priv->max_pixelclock))\r\npriv->max_pixelclock = TILCDC_DEFAULT_MAX_PIXELCLOCK;\r\nDBG("Maximum Pixel Clock Value %dKHz", priv->max_pixelclock);\r\npm_runtime_enable(dev->dev);\r\npm_runtime_get_sync(dev->dev);\r\nswitch (tilcdc_read(dev, LCDC_PID_REG)) {\r\ncase 0x4c100102:\r\npriv->rev = 1;\r\nbreak;\r\ncase 0x4f200800:\r\ncase 0x4f201000:\r\npriv->rev = 2;\r\nbreak;\r\ndefault:\r\ndev_warn(dev->dev, "Unknown PID Reg value 0x%08x, "\r\n"defaulting to LCD revision 1\n",\r\ntilcdc_read(dev, LCDC_PID_REG));\r\npriv->rev = 1;\r\nbreak;\r\n}\r\npm_runtime_put_sync(dev->dev);\r\nret = modeset_init(dev);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "failed to initialize mode setting\n");\r\ngoto fail_cpufreq_unregister;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nif (priv->is_componentized) {\r\nret = component_bind_all(dev->dev, dev);\r\nif (ret < 0)\r\ngoto fail_mode_config_cleanup;\r\nret = tilcdc_add_external_encoders(dev, &bpp);\r\nif (ret < 0)\r\ngoto fail_component_cleanup;\r\n}\r\nif ((priv->num_encoders == 0) || (priv->num_connectors == 0)) {\r\ndev_err(dev->dev, "no encoders/connectors found\n");\r\nret = -ENXIO;\r\ngoto fail_external_cleanup;\r\n}\r\nret = drm_vblank_init(dev, 1);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "failed to initialize vblank\n");\r\ngoto fail_external_cleanup;\r\n}\r\npm_runtime_get_sync(dev->dev);\r\nret = drm_irq_install(dev, platform_get_irq(dev->platformdev, 0));\r\npm_runtime_put_sync(dev->dev);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "failed to install IRQ handler\n");\r\ngoto fail_vblank_cleanup;\r\n}\r\nlist_for_each_entry(mod, &module_list, list) {\r\nDBG("%s: preferred_bpp: %d", mod->name, mod->preferred_bpp);\r\nbpp = mod->preferred_bpp;\r\nif (bpp > 0)\r\nbreak;\r\n}\r\ndrm_helper_disable_unused_functions(dev);\r\npriv->fbdev = drm_fbdev_cma_init(dev, bpp,\r\ndev->mode_config.num_crtc,\r\ndev->mode_config.num_connector);\r\nif (IS_ERR(priv->fbdev)) {\r\nret = PTR_ERR(priv->fbdev);\r\ngoto fail_irq_uninstall;\r\n}\r\ndrm_kms_helper_poll_init(dev);\r\nreturn 0;\r\nfail_irq_uninstall:\r\npm_runtime_get_sync(dev->dev);\r\ndrm_irq_uninstall(dev);\r\npm_runtime_put_sync(dev->dev);\r\nfail_vblank_cleanup:\r\ndrm_vblank_cleanup(dev);\r\nfail_mode_config_cleanup:\r\ndrm_mode_config_cleanup(dev);\r\nfail_component_cleanup:\r\nif (priv->is_componentized)\r\ncomponent_unbind_all(dev->dev, dev);\r\nfail_external_cleanup:\r\ntilcdc_remove_external_encoders(dev);\r\nfail_cpufreq_unregister:\r\npm_runtime_disable(dev->dev);\r\n#ifdef CONFIG_CPU_FREQ\r\ncpufreq_unregister_notifier(&priv->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nfail_put_clk:\r\n#endif\r\nclk_put(priv->clk);\r\nfail_iounmap:\r\niounmap(priv->mmio);\r\nfail_free_wq:\r\nflush_workqueue(priv->wq);\r\ndestroy_workqueue(priv->wq);\r\nfail_unset_priv:\r\ndev->dev_private = NULL;\r\nreturn ret;\r\n}\r\nstatic void tilcdc_lastclose(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\ndrm_fbdev_cma_restore_mode(priv->fbdev);\r\n}\r\nstatic irqreturn_t tilcdc_irq(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = arg;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nreturn tilcdc_crtc_irq(priv->crtc);\r\n}\r\nstatic void tilcdc_irq_preinstall(struct drm_device *dev)\r\n{\r\ntilcdc_clear_irqstatus(dev, 0xffffffff);\r\n}\r\nstatic int tilcdc_irq_postinstall(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nif (priv->rev == 1) {\r\ntilcdc_set(dev, LCDC_RASTER_CTRL_REG, LCDC_V1_UNDERFLOW_INT_ENA);\r\n} else {\r\ntilcdc_write(dev, LCDC_INT_ENABLE_SET_REG,\r\nLCDC_V2_UNDERFLOW_INT_ENA |\r\nLCDC_V2_END_OF_FRAME0_INT_ENA |\r\nLCDC_FRAME_DONE | LCDC_SYNC_LOST);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tilcdc_irq_uninstall(struct drm_device *dev)\r\n{\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nif (priv->rev == 1) {\r\ntilcdc_clear(dev, LCDC_RASTER_CTRL_REG,\r\nLCDC_V1_UNDERFLOW_INT_ENA | LCDC_V1_PL_INT_ENA);\r\ntilcdc_clear(dev, LCDC_DMA_CTRL_REG, LCDC_V1_END_OF_FRAME_INT_ENA);\r\n} else {\r\ntilcdc_write(dev, LCDC_INT_ENABLE_CLR_REG,\r\nLCDC_V2_UNDERFLOW_INT_ENA | LCDC_V2_PL_INT_ENA |\r\nLCDC_V2_END_OF_FRAME0_INT_ENA |\r\nLCDC_FRAME_DONE | LCDC_SYNC_LOST);\r\n}\r\n}\r\nstatic int tilcdc_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tilcdc_disable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nreturn;\r\n}\r\nstatic size_t tilcdc_num_regs(void)\r\n{\r\nreturn ARRAY_SIZE(registers);\r\n}\r\nstatic size_t tilcdc_num_regs(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tilcdc_regs_show(struct seq_file *m, void *arg)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nunsigned i;\r\npm_runtime_get_sync(dev->dev);\r\nseq_printf(m, "revision: %d\n", priv->rev);\r\nfor (i = 0; i < ARRAY_SIZE(registers); i++)\r\nif (priv->rev >= registers[i].rev)\r\nseq_printf(m, "%s:\t %08x\n", registers[i].name,\r\ntilcdc_read(dev, registers[i].reg));\r\npm_runtime_put_sync(dev->dev);\r\nreturn 0;\r\n}\r\nstatic int tilcdc_mm_show(struct seq_file *m, void *arg)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nreturn drm_mm_dump_table(m, &dev->vma_offset_manager->vm_addr_space_mm);\r\n}\r\nstatic int tilcdc_debugfs_init(struct drm_minor *minor)\r\n{\r\nstruct drm_device *dev = minor->dev;\r\nstruct tilcdc_module *mod;\r\nint ret;\r\nret = drm_debugfs_create_files(tilcdc_debugfs_list,\r\nARRAY_SIZE(tilcdc_debugfs_list),\r\nminor->debugfs_root, minor);\r\nlist_for_each_entry(mod, &module_list, list)\r\nif (mod->funcs->debugfs_init)\r\nmod->funcs->debugfs_init(mod, minor);\r\nif (ret) {\r\ndev_err(dev->dev, "could not install tilcdc_debugfs_list\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void tilcdc_debugfs_cleanup(struct drm_minor *minor)\r\n{\r\nstruct tilcdc_module *mod;\r\ndrm_debugfs_remove_files(tilcdc_debugfs_list,\r\nARRAY_SIZE(tilcdc_debugfs_list), minor);\r\nlist_for_each_entry(mod, &module_list, list)\r\nif (mod->funcs->debugfs_cleanup)\r\nmod->funcs->debugfs_cleanup(mod, minor);\r\n}\r\nstatic int tilcdc_pm_suspend(struct device *dev)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct tilcdc_drm_private *priv = ddev->dev_private;\r\nunsigned i, n = 0;\r\ndrm_kms_helper_poll_disable(ddev);\r\npinctrl_pm_select_sleep_state(dev);\r\nif (pm_runtime_suspended(dev)) {\r\npriv->ctx_valid = false;\r\nreturn 0;\r\n}\r\ntilcdc_crtc_dpms(priv->crtc, DRM_MODE_DPMS_OFF);\r\nfor (i = 0; i < ARRAY_SIZE(registers); i++)\r\nif (registers[i].save && (priv->rev >= registers[i].rev))\r\npriv->saved_register[n++] = tilcdc_read(ddev, registers[i].reg);\r\npriv->ctx_valid = true;\r\nreturn 0;\r\n}\r\nstatic int tilcdc_pm_resume(struct device *dev)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct tilcdc_drm_private *priv = ddev->dev_private;\r\nunsigned i, n = 0;\r\npinctrl_pm_select_default_state(dev);\r\nif (priv->ctx_valid == true) {\r\nfor (i = 0; i < ARRAY_SIZE(registers); i++)\r\nif (registers[i].save &&\r\n(priv->rev >= registers[i].rev))\r\ntilcdc_write(ddev, registers[i].reg,\r\npriv->saved_register[n++]);\r\n}\r\ndrm_kms_helper_poll_enable(ddev);\r\nreturn 0;\r\n}\r\nstatic int tilcdc_bind(struct device *dev)\r\n{\r\nreturn drm_platform_init(&tilcdc_driver, to_platform_device(dev));\r\n}\r\nstatic void tilcdc_unbind(struct device *dev)\r\n{\r\ndrm_put_dev(dev_get_drvdata(dev));\r\n}\r\nstatic int tilcdc_pdev_probe(struct platform_device *pdev)\r\n{\r\nstruct component_match *match = NULL;\r\nint ret;\r\nif (!pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "device-tree data is missing\n");\r\nreturn -ENXIO;\r\n}\r\nret = tilcdc_get_external_components(&pdev->dev, &match);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret == 0)\r\nreturn drm_platform_init(&tilcdc_driver, pdev);\r\nelse\r\nreturn component_master_add_with_match(&pdev->dev,\r\n&tilcdc_comp_ops,\r\nmatch);\r\n}\r\nstatic int tilcdc_pdev_remove(struct platform_device *pdev)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(&pdev->dev);\r\nstruct tilcdc_drm_private *priv = ddev->dev_private;\r\nif (!priv)\r\nreturn 0;\r\nif (priv->is_componentized)\r\ncomponent_master_del(&pdev->dev, &tilcdc_comp_ops);\r\nelse\r\ndrm_put_dev(platform_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic int __init tilcdc_drm_init(void)\r\n{\r\nDBG("init");\r\ntilcdc_tfp410_init();\r\ntilcdc_panel_init();\r\nreturn platform_driver_register(&tilcdc_platform_driver);\r\n}\r\nstatic void __exit tilcdc_drm_fini(void)\r\n{\r\nDBG("fini");\r\nplatform_driver_unregister(&tilcdc_platform_driver);\r\ntilcdc_panel_fini();\r\ntilcdc_tfp410_fini();\r\n}
