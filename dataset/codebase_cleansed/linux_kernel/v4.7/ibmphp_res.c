static struct bus_node * __init alloc_error_bus(struct ebda_pci_rsrc *curr, u8 busno, int flag)\r\n{\r\nstruct bus_node *newbus;\r\nif (!(curr) && !(flag)) {\r\nerr("NULL pointer passed\n");\r\nreturn NULL;\r\n}\r\nnewbus = kzalloc(sizeof(struct bus_node), GFP_KERNEL);\r\nif (!newbus) {\r\nerr("out of system memory\n");\r\nreturn NULL;\r\n}\r\nif (flag)\r\nnewbus->busno = busno;\r\nelse\r\nnewbus->busno = curr->bus_num;\r\nlist_add_tail(&newbus->bus_list, &gbuses);\r\nreturn newbus;\r\n}\r\nstatic struct resource_node * __init alloc_resources(struct ebda_pci_rsrc *curr)\r\n{\r\nstruct resource_node *rs;\r\nif (!curr) {\r\nerr("NULL passed to allocate\n");\r\nreturn NULL;\r\n}\r\nrs = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!rs) {\r\nerr("out of system memory\n");\r\nreturn NULL;\r\n}\r\nrs->busno = curr->bus_num;\r\nrs->devfunc = curr->dev_fun;\r\nrs->start = curr->start_addr;\r\nrs->end = curr->end_addr;\r\nrs->len = curr->end_addr - curr->start_addr + 1;\r\nreturn rs;\r\n}\r\nstatic int __init alloc_bus_range(struct bus_node **new_bus, struct range_node **new_range, struct ebda_pci_rsrc *curr, int flag, u8 first_bus)\r\n{\r\nstruct bus_node *newbus;\r\nstruct range_node *newrange;\r\nu8 num_ranges = 0;\r\nif (first_bus) {\r\nnewbus = kzalloc(sizeof(struct bus_node), GFP_KERNEL);\r\nif (!newbus) {\r\nerr("out of system memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nnewbus->busno = curr->bus_num;\r\n} else {\r\nnewbus = *new_bus;\r\nswitch (flag) {\r\ncase MEM:\r\nnum_ranges = newbus->noMemRanges;\r\nbreak;\r\ncase PFMEM:\r\nnum_ranges = newbus->noPFMemRanges;\r\nbreak;\r\ncase IO:\r\nnum_ranges = newbus->noIORanges;\r\nbreak;\r\n}\r\n}\r\nnewrange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\r\nif (!newrange) {\r\nif (first_bus)\r\nkfree(newbus);\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nnewrange->start = curr->start_addr;\r\nnewrange->end = curr->end_addr;\r\nif (first_bus || (!num_ranges))\r\nnewrange->rangeno = 1;\r\nelse {\r\nadd_bus_range(flag, newrange, newbus);\r\ndebug("%d resource Primary Bus inserted on bus %x [%x - %x]\n", flag, newbus->busno, newrange->start, newrange->end);\r\n}\r\nswitch (flag) {\r\ncase MEM:\r\nnewbus->rangeMem = newrange;\r\nif (first_bus)\r\nnewbus->noMemRanges = 1;\r\nelse {\r\ndebug("First Memory Primary on bus %x, [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n++newbus->noMemRanges;\r\nfix_resources(newbus);\r\n}\r\nbreak;\r\ncase IO:\r\nnewbus->rangeIO = newrange;\r\nif (first_bus)\r\nnewbus->noIORanges = 1;\r\nelse {\r\ndebug("First IO Primary on bus %x, [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n++newbus->noIORanges;\r\nfix_resources(newbus);\r\n}\r\nbreak;\r\ncase PFMEM:\r\nnewbus->rangePFMem = newrange;\r\nif (first_bus)\r\nnewbus->noPFMemRanges = 1;\r\nelse {\r\ndebug("1st PFMemory Primary on Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n++newbus->noPFMemRanges;\r\nfix_resources(newbus);\r\n}\r\nbreak;\r\n}\r\n*new_bus = newbus;\r\n*new_range = newrange;\r\nreturn 0;\r\n}\r\nint __init ibmphp_rsrc_init(void)\r\n{\r\nstruct ebda_pci_rsrc *curr;\r\nstruct range_node *newrange = NULL;\r\nstruct bus_node *newbus = NULL;\r\nstruct bus_node *bus_cur;\r\nstruct bus_node *bus_prev;\r\nstruct resource_node *new_io = NULL;\r\nstruct resource_node *new_mem = NULL;\r\nstruct resource_node *new_pfmem = NULL;\r\nint rc;\r\nlist_for_each_entry(curr, &ibmphp_ebda_pci_rsrc_head,\r\nebda_pci_rsrc_list) {\r\nif (!(curr->rsrc_type & PCIDEVMASK)) {\r\ndebug("this is not a PCI DEVICE in rsrc_init, please take care\n");\r\n}\r\nif (curr->rsrc_type & PRIMARYBUSMASK) {\r\nif ((curr->rsrc_type & RESTYPE) == MMASK) {\r\nif (list_empty(&gbuses)) {\r\nrc = alloc_bus_range(&newbus, &newrange, curr, MEM, 1);\r\nif (rc)\r\nreturn rc;\r\nlist_add_tail(&newbus->bus_list, &gbuses);\r\ndebug("gbuses = NULL, Memory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n} else {\r\nbus_cur = find_bus_wprev(curr->bus_num, &bus_prev, 1);\r\nif (bus_cur) {\r\nrc = alloc_bus_range(&bus_cur, &newrange, curr, MEM, 0);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nrc = alloc_bus_range(&newbus, &newrange, curr, MEM, 1);\r\nif (rc)\r\nreturn rc;\r\nlist_add_tail(&newbus->bus_list, &gbuses);\r\ndebug("New Bus, Memory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n}\r\n}\r\n} else if ((curr->rsrc_type & RESTYPE) == PFMASK) {\r\nif (list_empty(&gbuses)) {\r\nrc = alloc_bus_range(&newbus, &newrange, curr, PFMEM, 1);\r\nif (rc)\r\nreturn rc;\r\nlist_add_tail(&newbus->bus_list, &gbuses);\r\ndebug("gbuses = NULL, PFMemory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n} else {\r\nbus_cur = find_bus_wprev(curr->bus_num, &bus_prev, 1);\r\nif (bus_cur) {\r\nrc = alloc_bus_range(&bus_cur, &newrange, curr, PFMEM, 0);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nrc = alloc_bus_range(&newbus, &newrange, curr, PFMEM, 1);\r\nif (rc)\r\nreturn rc;\r\nlist_add_tail(&newbus->bus_list, &gbuses);\r\ndebug("1st Bus, PFMemory Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n}\r\n}\r\n} else if ((curr->rsrc_type & RESTYPE) == IOMASK) {\r\nif (list_empty(&gbuses)) {\r\nrc = alloc_bus_range(&newbus, &newrange, curr, IO, 1);\r\nif (rc)\r\nreturn rc;\r\nlist_add_tail(&newbus->bus_list, &gbuses);\r\ndebug("gbuses = NULL, IO Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n} else {\r\nbus_cur = find_bus_wprev(curr->bus_num, &bus_prev, 1);\r\nif (bus_cur) {\r\nrc = alloc_bus_range(&bus_cur, &newrange, curr, IO, 0);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nrc = alloc_bus_range(&newbus, &newrange, curr, IO, 1);\r\nif (rc)\r\nreturn rc;\r\nlist_add_tail(&newbus->bus_list, &gbuses);\r\ndebug("1st Bus, IO Primary Bus %x [%x - %x]\n", newbus->busno, newrange->start, newrange->end);\r\n}\r\n}\r\n} else {\r\n;\r\n}\r\n} else {\r\nif ((curr->rsrc_type & RESTYPE) == MMASK) {\r\nnew_mem = alloc_resources(curr);\r\nif (!new_mem)\r\nreturn -ENOMEM;\r\nnew_mem->type = MEM;\r\nif (ibmphp_add_resource(new_mem) < 0) {\r\nnewbus = alloc_error_bus(curr, 0, 0);\r\nif (!newbus)\r\nreturn -ENOMEM;\r\nnewbus->firstMem = new_mem;\r\n++newbus->needMemUpdate;\r\nnew_mem->rangeno = -1;\r\n}\r\ndebug("Memory resource for device %x, bus %x, [%x - %x]\n", new_mem->devfunc, new_mem->busno, new_mem->start, new_mem->end);\r\n} else if ((curr->rsrc_type & RESTYPE) == PFMASK) {\r\nnew_pfmem = alloc_resources(curr);\r\nif (!new_pfmem)\r\nreturn -ENOMEM;\r\nnew_pfmem->type = PFMEM;\r\nnew_pfmem->fromMem = 0;\r\nif (ibmphp_add_resource(new_pfmem) < 0) {\r\nnewbus = alloc_error_bus(curr, 0, 0);\r\nif (!newbus)\r\nreturn -ENOMEM;\r\nnewbus->firstPFMem = new_pfmem;\r\n++newbus->needPFMemUpdate;\r\nnew_pfmem->rangeno = -1;\r\n}\r\ndebug("PFMemory resource for device %x, bus %x, [%x - %x]\n", new_pfmem->devfunc, new_pfmem->busno, new_pfmem->start, new_pfmem->end);\r\n} else if ((curr->rsrc_type & RESTYPE) == IOMASK) {\r\nnew_io = alloc_resources(curr);\r\nif (!new_io)\r\nreturn -ENOMEM;\r\nnew_io->type = IO;\r\nif (ibmphp_add_resource(new_io) < 0) {\r\nnewbus = alloc_error_bus(curr, 0, 0);\r\nif (!newbus)\r\nreturn -ENOMEM;\r\nnewbus->firstIO = new_io;\r\n++newbus->needIOUpdate;\r\nnew_io->rangeno = -1;\r\n}\r\ndebug("IO resource for device %x, bus %x, [%x - %x]\n", new_io->devfunc, new_io->busno, new_io->start, new_io->end);\r\n}\r\n}\r\n}\r\nlist_for_each_entry(bus_cur, &gbuses, bus_list) {\r\nrc = update_bridge_ranges(&bus_cur);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn once_over();\r\n}\r\nstatic int add_bus_range(int type, struct range_node *range, struct bus_node *bus_cur)\r\n{\r\nstruct range_node *range_cur = NULL;\r\nstruct range_node *range_prev;\r\nint count = 0, i_init;\r\nint noRanges = 0;\r\nswitch (type) {\r\ncase MEM:\r\nrange_cur = bus_cur->rangeMem;\r\nnoRanges = bus_cur->noMemRanges;\r\nbreak;\r\ncase PFMEM:\r\nrange_cur = bus_cur->rangePFMem;\r\nnoRanges = bus_cur->noPFMemRanges;\r\nbreak;\r\ncase IO:\r\nrange_cur = bus_cur->rangeIO;\r\nnoRanges = bus_cur->noIORanges;\r\nbreak;\r\n}\r\nrange_prev = NULL;\r\nwhile (range_cur) {\r\nif (range->start < range_cur->start)\r\nbreak;\r\nrange_prev = range_cur;\r\nrange_cur = range_cur->next;\r\ncount = count + 1;\r\n}\r\nif (!count) {\r\nswitch (type) {\r\ncase MEM:\r\nbus_cur->rangeMem = range;\r\nbreak;\r\ncase PFMEM:\r\nbus_cur->rangePFMem = range;\r\nbreak;\r\ncase IO:\r\nbus_cur->rangeIO = range;\r\nbreak;\r\n}\r\nrange->next = range_cur;\r\nrange->rangeno = 1;\r\ni_init = 0;\r\n} else if (!range_cur) {\r\nrange->next = NULL;\r\nrange_prev->next = range;\r\nrange->rangeno = range_prev->rangeno + 1;\r\nreturn 0;\r\n} else {\r\nrange_prev->next = range;\r\nrange->next = range_cur;\r\nrange->rangeno = range_cur->rangeno;\r\ni_init = range_prev->rangeno;\r\n}\r\nfor (count = i_init; count < noRanges; ++count) {\r\n++range_cur->rangeno;\r\nrange_cur = range_cur->next;\r\n}\r\nupdate_resources(bus_cur, type, i_init + 1);\r\nreturn 0;\r\n}\r\nstatic void update_resources(struct bus_node *bus_cur, int type, int rangeno)\r\n{\r\nstruct resource_node *res = NULL;\r\nu8 eol = 0;\r\nswitch (type) {\r\ncase MEM:\r\nif (bus_cur->firstMem)\r\nres = bus_cur->firstMem;\r\nbreak;\r\ncase PFMEM:\r\nif (bus_cur->firstPFMem)\r\nres = bus_cur->firstPFMem;\r\nbreak;\r\ncase IO:\r\nif (bus_cur->firstIO)\r\nres = bus_cur->firstIO;\r\nbreak;\r\n}\r\nif (res) {\r\nwhile (res) {\r\nif (res->rangeno == rangeno)\r\nbreak;\r\nif (res->next)\r\nres = res->next;\r\nelse if (res->nextRange)\r\nres = res->nextRange;\r\nelse {\r\neol = 1;\r\nbreak;\r\n}\r\n}\r\nif (!eol) {\r\nwhile (res) {\r\n++res->rangeno;\r\nres = res->next;\r\n}\r\n}\r\n}\r\n}\r\nstatic void fix_me(struct resource_node *res, struct bus_node *bus_cur, struct range_node *range)\r\n{\r\nchar *str = "";\r\nswitch (res->type) {\r\ncase IO:\r\nstr = "io";\r\nbreak;\r\ncase MEM:\r\nstr = "mem";\r\nbreak;\r\ncase PFMEM:\r\nstr = "pfmem";\r\nbreak;\r\n}\r\nwhile (res) {\r\nif (res->rangeno == -1) {\r\nwhile (range) {\r\nif ((res->start >= range->start) && (res->end <= range->end)) {\r\nres->rangeno = range->rangeno;\r\ndebug("%s->rangeno in fix_resources is %d\n", str, res->rangeno);\r\nswitch (res->type) {\r\ncase IO:\r\n--bus_cur->needIOUpdate;\r\nbreak;\r\ncase MEM:\r\n--bus_cur->needMemUpdate;\r\nbreak;\r\ncase PFMEM:\r\n--bus_cur->needPFMemUpdate;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nrange = range->next;\r\n}\r\n}\r\nif (res->next)\r\nres = res->next;\r\nelse\r\nres = res->nextRange;\r\n}\r\n}\r\nstatic void fix_resources(struct bus_node *bus_cur)\r\n{\r\nstruct range_node *range;\r\nstruct resource_node *res;\r\ndebug("%s - bus_cur->busno = %d\n", __func__, bus_cur->busno);\r\nif (bus_cur->needIOUpdate) {\r\nres = bus_cur->firstIO;\r\nrange = bus_cur->rangeIO;\r\nfix_me(res, bus_cur, range);\r\n}\r\nif (bus_cur->needMemUpdate) {\r\nres = bus_cur->firstMem;\r\nrange = bus_cur->rangeMem;\r\nfix_me(res, bus_cur, range);\r\n}\r\nif (bus_cur->needPFMemUpdate) {\r\nres = bus_cur->firstPFMem;\r\nrange = bus_cur->rangePFMem;\r\nfix_me(res, bus_cur, range);\r\n}\r\n}\r\nint ibmphp_add_resource(struct resource_node *res)\r\n{\r\nstruct resource_node *res_cur;\r\nstruct resource_node *res_prev;\r\nstruct bus_node *bus_cur;\r\nstruct range_node *range_cur = NULL;\r\nstruct resource_node *res_start = NULL;\r\ndebug("%s - enter\n", __func__);\r\nif (!res) {\r\nerr("NULL passed to add\n");\r\nreturn -ENODEV;\r\n}\r\nbus_cur = find_bus_wprev(res->busno, NULL, 0);\r\nif (!bus_cur) {\r\ndebug("no bus in the system, either pci_dev's wrong or allocation failed\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (res->type) {\r\ncase IO:\r\nrange_cur = bus_cur->rangeIO;\r\nres_start = bus_cur->firstIO;\r\nbreak;\r\ncase MEM:\r\nrange_cur = bus_cur->rangeMem;\r\nres_start = bus_cur->firstMem;\r\nbreak;\r\ncase PFMEM:\r\nrange_cur = bus_cur->rangePFMem;\r\nres_start = bus_cur->firstPFMem;\r\nbreak;\r\ndefault:\r\nerr("cannot read the type of the resource to add... problem\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (range_cur) {\r\nif ((res->start >= range_cur->start) && (res->end <= range_cur->end)) {\r\nres->rangeno = range_cur->rangeno;\r\nbreak;\r\n}\r\nrange_cur = range_cur->next;\r\n}\r\nif (!range_cur) {\r\nswitch (res->type) {\r\ncase IO:\r\n++bus_cur->needIOUpdate;\r\nbreak;\r\ncase MEM:\r\n++bus_cur->needMemUpdate;\r\nbreak;\r\ncase PFMEM:\r\n++bus_cur->needPFMemUpdate;\r\nbreak;\r\n}\r\nres->rangeno = -1;\r\n}\r\ndebug("The range is %d\n", res->rangeno);\r\nif (!res_start) {\r\nswitch (res->type) {\r\ncase IO:\r\nbus_cur->firstIO = res;\r\nbreak;\r\ncase MEM:\r\nbus_cur->firstMem = res;\r\nbreak;\r\ncase PFMEM:\r\nbus_cur->firstPFMem = res;\r\nbreak;\r\n}\r\nres->next = NULL;\r\nres->nextRange = NULL;\r\n} else {\r\nres_cur = res_start;\r\nres_prev = NULL;\r\ndebug("res_cur->rangeno is %d\n", res_cur->rangeno);\r\nwhile (res_cur) {\r\nif (res_cur->rangeno >= res->rangeno)\r\nbreak;\r\nres_prev = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\n}\r\nif (!res_cur) {\r\ndebug("i should be here, [%x - %x]\n", res->start, res->end);\r\nres_prev->nextRange = res;\r\nres->next = NULL;\r\nres->nextRange = NULL;\r\n} else if (res_cur->rangeno == res->rangeno) {\r\nwhile (res_cur) {\r\nif (res->start < res_cur->start)\r\nbreak;\r\nres_prev = res_cur;\r\nres_cur = res_cur->next;\r\n}\r\nif (!res_cur) {\r\nres_prev->next = res;\r\nres->next = NULL;\r\nres->nextRange = res_prev->nextRange;\r\nres_prev->nextRange = NULL;\r\n} else if (res->start < res_cur->start) {\r\nif (!res_prev) {\r\nswitch (res->type) {\r\ncase IO:\r\nbus_cur->firstIO = res;\r\nbreak;\r\ncase MEM:\r\nbus_cur->firstMem = res;\r\nbreak;\r\ncase PFMEM:\r\nbus_cur->firstPFMem = res;\r\nbreak;\r\n}\r\n} else if (res_prev->rangeno == res_cur->rangeno)\r\nres_prev->next = res;\r\nelse\r\nres_prev->nextRange = res;\r\nres->next = res_cur;\r\nres->nextRange = NULL;\r\n}\r\n} else {\r\nif (!res_prev) {\r\nres->next = NULL;\r\nswitch (res->type) {\r\ncase IO:\r\nres->nextRange = bus_cur->firstIO;\r\nbus_cur->firstIO = res;\r\nbreak;\r\ncase MEM:\r\nres->nextRange = bus_cur->firstMem;\r\nbus_cur->firstMem = res;\r\nbreak;\r\ncase PFMEM:\r\nres->nextRange = bus_cur->firstPFMem;\r\nbus_cur->firstPFMem = res;\r\nbreak;\r\n}\r\n} else if (res_cur->rangeno > res->rangeno) {\r\nres_prev->nextRange = res;\r\nres->next = NULL;\r\nres->nextRange = res_cur;\r\n}\r\n}\r\n}\r\ndebug("%s - exit\n", __func__);\r\nreturn 0;\r\n}\r\nint ibmphp_remove_resource(struct resource_node *res)\r\n{\r\nstruct bus_node *bus_cur;\r\nstruct resource_node *res_cur = NULL;\r\nstruct resource_node *res_prev;\r\nstruct resource_node *mem_cur;\r\nchar *type = "";\r\nif (!res) {\r\nerr("resource to remove is NULL\n");\r\nreturn -ENODEV;\r\n}\r\nbus_cur = find_bus_wprev(res->busno, NULL, 0);\r\nif (!bus_cur) {\r\nerr("cannot find corresponding bus of the io resource to remove bailing out...\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (res->type) {\r\ncase IO:\r\nres_cur = bus_cur->firstIO;\r\ntype = "io";\r\nbreak;\r\ncase MEM:\r\nres_cur = bus_cur->firstMem;\r\ntype = "mem";\r\nbreak;\r\ncase PFMEM:\r\nres_cur = bus_cur->firstPFMem;\r\ntype = "pfmem";\r\nbreak;\r\ndefault:\r\nerr("unknown type for resource to remove\n");\r\nreturn -EINVAL;\r\n}\r\nres_prev = NULL;\r\nwhile (res_cur) {\r\nif ((res_cur->start == res->start) && (res_cur->end == res->end))\r\nbreak;\r\nres_prev = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\n}\r\nif (!res_cur) {\r\nif (res->type == PFMEM) {\r\nres_cur = bus_cur->firstPFMemFromMem;\r\nres_prev = NULL;\r\nwhile (res_cur) {\r\nif ((res_cur->start == res->start) && (res_cur->end == res->end)) {\r\nmem_cur = bus_cur->firstMem;\r\nwhile (mem_cur) {\r\nif ((mem_cur->start == res_cur->start)\r\n&& (mem_cur->end == res_cur->end))\r\nbreak;\r\nif (mem_cur->next)\r\nmem_cur = mem_cur->next;\r\nelse\r\nmem_cur = mem_cur->nextRange;\r\n}\r\nif (!mem_cur) {\r\nerr("cannot find corresponding mem node for pfmem...\n");\r\nreturn -EINVAL;\r\n}\r\nibmphp_remove_resource(mem_cur);\r\nif (!res_prev)\r\nbus_cur->firstPFMemFromMem = res_cur->next;\r\nelse\r\nres_prev->next = res_cur->next;\r\nkfree(res_cur);\r\nreturn 0;\r\n}\r\nres_prev = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\n}\r\nif (!res_cur) {\r\nerr("cannot find pfmem to delete...\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nerr("the %s resource is not in the list to be deleted...\n", type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!res_prev) {\r\nif (res_cur->next) {\r\nswitch (res->type) {\r\ncase IO:\r\nbus_cur->firstIO = res_cur->next;\r\nbreak;\r\ncase MEM:\r\nbus_cur->firstMem = res_cur->next;\r\nbreak;\r\ncase PFMEM:\r\nbus_cur->firstPFMem = res_cur->next;\r\nbreak;\r\n}\r\n} else if (res_cur->nextRange) {\r\nswitch (res->type) {\r\ncase IO:\r\nbus_cur->firstIO = res_cur->nextRange;\r\nbreak;\r\ncase MEM:\r\nbus_cur->firstMem = res_cur->nextRange;\r\nbreak;\r\ncase PFMEM:\r\nbus_cur->firstPFMem = res_cur->nextRange;\r\nbreak;\r\n}\r\n} else {\r\nswitch (res->type) {\r\ncase IO:\r\nbus_cur->firstIO = NULL;\r\nbreak;\r\ncase MEM:\r\nbus_cur->firstMem = NULL;\r\nbreak;\r\ncase PFMEM:\r\nbus_cur->firstPFMem = NULL;\r\nbreak;\r\n}\r\n}\r\nkfree(res_cur);\r\nreturn 0;\r\n} else {\r\nif (res_cur->next) {\r\nif (res_prev->rangeno == res_cur->rangeno)\r\nres_prev->next = res_cur->next;\r\nelse\r\nres_prev->nextRange = res_cur->next;\r\n} else if (res_cur->nextRange) {\r\nres_prev->next = NULL;\r\nres_prev->nextRange = res_cur->nextRange;\r\n} else {\r\nres_prev->next = NULL;\r\nres_prev->nextRange = NULL;\r\n}\r\nkfree(res_cur);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct range_node *find_range(struct bus_node *bus_cur, struct resource_node *res)\r\n{\r\nstruct range_node *range = NULL;\r\nswitch (res->type) {\r\ncase IO:\r\nrange = bus_cur->rangeIO;\r\nbreak;\r\ncase MEM:\r\nrange = bus_cur->rangeMem;\r\nbreak;\r\ncase PFMEM:\r\nrange = bus_cur->rangePFMem;\r\nbreak;\r\ndefault:\r\nerr("cannot read resource type in find_range\n");\r\n}\r\nwhile (range) {\r\nif (res->rangeno == range->rangeno)\r\nbreak;\r\nrange = range->next;\r\n}\r\nreturn range;\r\n}\r\nint ibmphp_check_resource(struct resource_node *res, u8 bridge)\r\n{\r\nstruct bus_node *bus_cur;\r\nstruct range_node *range = NULL;\r\nstruct resource_node *res_prev;\r\nstruct resource_node *res_cur = NULL;\r\nu32 len_cur = 0, start_cur = 0, len_tmp = 0;\r\nint noranges = 0;\r\nu32 tmp_start;\r\nu32 tmp_divide;\r\nu8 flag = 0;\r\nif (!res)\r\nreturn -EINVAL;\r\nif (bridge) {\r\nif (res->type == IO)\r\ntmp_divide = IOBRIDGE;\r\nelse\r\ntmp_divide = MEMBRIDGE;\r\n} else\r\ntmp_divide = res->len;\r\nbus_cur = find_bus_wprev(res->busno, NULL, 0);\r\nif (!bus_cur) {\r\ndebug("no bus in the system, either pci_dev's wrong or allocation failed\n");\r\nreturn -EINVAL;\r\n}\r\ndebug("%s - enter\n", __func__);\r\ndebug("bus_cur->busno is %d\n", bus_cur->busno);\r\nres->len -= 1;\r\nswitch (res->type) {\r\ncase IO:\r\nres_cur = bus_cur->firstIO;\r\nnoranges = bus_cur->noIORanges;\r\nbreak;\r\ncase MEM:\r\nres_cur = bus_cur->firstMem;\r\nnoranges = bus_cur->noMemRanges;\r\nbreak;\r\ncase PFMEM:\r\nres_cur = bus_cur->firstPFMem;\r\nnoranges = bus_cur->noPFMemRanges;\r\nbreak;\r\ndefault:\r\nerr("wrong type of resource to check\n");\r\nreturn -EINVAL;\r\n}\r\nres_prev = NULL;\r\nwhile (res_cur) {\r\nrange = find_range(bus_cur, res_cur);\r\ndebug("%s - rangeno = %d\n", __func__, res_cur->rangeno);\r\nif (!range) {\r\nerr("no range for the device exists... bailing out...\n");\r\nreturn -EINVAL;\r\n}\r\nif (!res_prev) {\r\nlen_tmp = res_cur->start - 1 - range->start;\r\nif ((res_cur->start != range->start) && (len_tmp >= res->len)) {\r\ndebug("len_tmp = %x\n", len_tmp);\r\nif ((len_tmp < len_cur) || (len_cur == 0)) {\r\nif ((range->start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = range->start;\r\n} else {\r\ntmp_start = range->start;\r\nflag = 0;\r\nwhile ((len_tmp = res_cur->start - 1 - tmp_start) >= res->len) {\r\nif ((tmp_start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = tmp_start;\r\nbreak;\r\n}\r\ntmp_start += tmp_divide - tmp_start % tmp_divide;\r\nif (tmp_start >= res_cur->start - 1)\r\nbreak;\r\n}\r\n}\r\nif (flag && len_cur == res->len) {\r\ndebug("but we are not here, right?\n");\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nif (!res_cur->next) {\r\nlen_tmp = range->end - (res_cur->end + 1);\r\nif ((range->end != res_cur->end) && (len_tmp >= res->len)) {\r\ndebug("len_tmp = %x\n", len_tmp);\r\nif ((len_tmp < len_cur) || (len_cur == 0)) {\r\nif (((res_cur->end + 1) % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = res_cur->end + 1;\r\n} else {\r\ntmp_start = res_cur->end + 1;\r\nflag = 0;\r\nwhile ((len_tmp = range->end - tmp_start) >= res->len) {\r\nif ((tmp_start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = tmp_start;\r\nbreak;\r\n}\r\ntmp_start += tmp_divide - tmp_start % tmp_divide;\r\nif (tmp_start >= range->end)\r\nbreak;\r\n}\r\n}\r\nif (flag && len_cur == res->len) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nif (res_prev) {\r\nif (res_prev->rangeno != res_cur->rangeno) {\r\nlen_tmp = res_cur->start - 1 - range->start;\r\nif ((res_cur->start != range->start) && (len_tmp >= res->len)) {\r\nif ((len_tmp < len_cur) || (len_cur == 0)) {\r\nif ((range->start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = range->start;\r\n} else {\r\ntmp_start = range->start;\r\nflag = 0;\r\nwhile ((len_tmp = res_cur->start - 1 - tmp_start) >= res->len) {\r\nif ((tmp_start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = tmp_start;\r\nbreak;\r\n}\r\ntmp_start += tmp_divide - tmp_start % tmp_divide;\r\nif (tmp_start >= res_cur->start - 1)\r\nbreak;\r\n}\r\n}\r\nif (flag && len_cur == res->len) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n} else {\r\nlen_tmp = res_cur->start - 1 - res_prev->end - 1;\r\nif (len_tmp >= res->len) {\r\nif ((len_tmp < len_cur) || (len_cur == 0)) {\r\nif (((res_prev->end + 1) % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = res_prev->end + 1;\r\n} else {\r\ntmp_start = res_prev->end + 1;\r\nflag = 0;\r\nwhile ((len_tmp = res_cur->start - 1 - tmp_start) >= res->len) {\r\nif ((tmp_start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = tmp_start;\r\nbreak;\r\n}\r\ntmp_start += tmp_divide - tmp_start % tmp_divide;\r\nif (tmp_start >= res_cur->start - 1)\r\nbreak;\r\n}\r\n}\r\nif (flag && len_cur == res->len) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nres_prev = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\n}\r\nif (!res_prev) {\r\nswitch (res->type) {\r\ncase IO:\r\nrange = bus_cur->rangeIO;\r\nbreak;\r\ncase MEM:\r\nrange = bus_cur->rangeMem;\r\nbreak;\r\ncase PFMEM:\r\nrange = bus_cur->rangePFMem;\r\nbreak;\r\n}\r\nwhile (range) {\r\nlen_tmp = range->end - range->start;\r\nif (len_tmp >= res->len) {\r\nif ((len_tmp < len_cur) || (len_cur == 0)) {\r\nif ((range->start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = range->start;\r\n} else {\r\ntmp_start = range->start;\r\nflag = 0;\r\nwhile ((len_tmp = range->end - tmp_start) >= res->len) {\r\nif ((tmp_start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = tmp_start;\r\nbreak;\r\n}\r\ntmp_start += tmp_divide - tmp_start % tmp_divide;\r\nif (tmp_start >= range->end)\r\nbreak;\r\n}\r\n}\r\nif (flag && len_cur == res->len) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nrange = range->next;\r\n}\r\nif ((!range) && (len_cur == 0)) {\r\nerr("no appropriate range.. bailing out...\n");\r\nreturn -EINVAL;\r\n} else if (len_cur) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n}\r\nif (!res_cur) {\r\ndebug("prev->rangeno = %d, noranges = %d\n", res_prev->rangeno, noranges);\r\nif (res_prev->rangeno < noranges) {\r\nswitch (res->type) {\r\ncase IO:\r\nrange = bus_cur->rangeIO;\r\nbreak;\r\ncase MEM:\r\nrange = bus_cur->rangeMem;\r\nbreak;\r\ncase PFMEM:\r\nrange = bus_cur->rangePFMem;\r\nbreak;\r\n}\r\nwhile (range) {\r\nlen_tmp = range->end - range->start;\r\nif (len_tmp >= res->len) {\r\nif ((len_tmp < len_cur) || (len_cur == 0)) {\r\nif ((range->start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = range->start;\r\n} else {\r\ntmp_start = range->start;\r\nflag = 0;\r\nwhile ((len_tmp = range->end - tmp_start) >= res->len) {\r\nif ((tmp_start % tmp_divide) == 0) {\r\nflag = 1;\r\nlen_cur = len_tmp;\r\nstart_cur = tmp_start;\r\nbreak;\r\n}\r\ntmp_start += tmp_divide - tmp_start % tmp_divide;\r\nif (tmp_start >= range->end)\r\nbreak;\r\n}\r\n}\r\nif (flag && len_cur == res->len) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nrange = range->next;\r\n}\r\nif ((!range) && (len_cur == 0)) {\r\nerr("no appropriate range.. bailing out...\n");\r\nreturn -EINVAL;\r\n} else if (len_cur) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n}\r\n} else {\r\nif (len_cur) {\r\nres->start = start_cur;\r\nres->len += 1;\r\nres->end = res->start + res->len - 1;\r\nreturn 0;\r\n} else {\r\nerr("no appropriate range.. bailing out...\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint ibmphp_remove_bus(struct bus_node *bus, u8 parent_busno)\r\n{\r\nstruct resource_node *res_cur;\r\nstruct resource_node *res_tmp;\r\nstruct bus_node *prev_bus;\r\nint rc;\r\nprev_bus = find_bus_wprev(parent_busno, NULL, 0);\r\nif (!prev_bus) {\r\ndebug("something terribly wrong. Cannot find parent bus to the one to remove\n");\r\nreturn -ENODEV;\r\n}\r\ndebug("In ibmphp_remove_bus... prev_bus->busno is %x\n", prev_bus->busno);\r\nrc = remove_ranges(bus, prev_bus);\r\nif (rc)\r\nreturn rc;\r\nif (bus->firstIO) {\r\nres_cur = bus->firstIO;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus->firstIO = NULL;\r\n}\r\nif (bus->firstMem) {\r\nres_cur = bus->firstMem;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus->firstMem = NULL;\r\n}\r\nif (bus->firstPFMem) {\r\nres_cur = bus->firstPFMem;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus->firstPFMem = NULL;\r\n}\r\nif (bus->firstPFMemFromMem) {\r\nres_cur = bus->firstPFMemFromMem;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nres_cur = res_cur->next;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus->firstPFMemFromMem = NULL;\r\n}\r\nlist_del(&bus->bus_list);\r\nkfree(bus);\r\nreturn 0;\r\n}\r\nstatic int remove_ranges(struct bus_node *bus_cur, struct bus_node *bus_prev)\r\n{\r\nstruct range_node *range_cur;\r\nstruct range_node *range_tmp;\r\nint i;\r\nstruct resource_node *res = NULL;\r\nif (bus_cur->noIORanges) {\r\nrange_cur = bus_cur->rangeIO;\r\nfor (i = 0; i < bus_cur->noIORanges; i++) {\r\nif (ibmphp_find_resource(bus_prev, range_cur->start, &res, IO) < 0)\r\nreturn -EINVAL;\r\nibmphp_remove_resource(res);\r\nrange_tmp = range_cur;\r\nrange_cur = range_cur->next;\r\nkfree(range_tmp);\r\nrange_tmp = NULL;\r\n}\r\nbus_cur->rangeIO = NULL;\r\n}\r\nif (bus_cur->noMemRanges) {\r\nrange_cur = bus_cur->rangeMem;\r\nfor (i = 0; i < bus_cur->noMemRanges; i++) {\r\nif (ibmphp_find_resource(bus_prev, range_cur->start, &res, MEM) < 0)\r\nreturn -EINVAL;\r\nibmphp_remove_resource(res);\r\nrange_tmp = range_cur;\r\nrange_cur = range_cur->next;\r\nkfree(range_tmp);\r\nrange_tmp = NULL;\r\n}\r\nbus_cur->rangeMem = NULL;\r\n}\r\nif (bus_cur->noPFMemRanges) {\r\nrange_cur = bus_cur->rangePFMem;\r\nfor (i = 0; i < bus_cur->noPFMemRanges; i++) {\r\nif (ibmphp_find_resource(bus_prev, range_cur->start, &res, PFMEM) < 0)\r\nreturn -EINVAL;\r\nibmphp_remove_resource(res);\r\nrange_tmp = range_cur;\r\nrange_cur = range_cur->next;\r\nkfree(range_tmp);\r\nrange_tmp = NULL;\r\n}\r\nbus_cur->rangePFMem = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint ibmphp_find_resource(struct bus_node *bus, u32 start_address, struct resource_node **res, int flag)\r\n{\r\nstruct resource_node *res_cur = NULL;\r\nchar *type = "";\r\nif (!bus) {\r\nerr("The bus passed in NULL to find resource\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (flag) {\r\ncase IO:\r\nres_cur = bus->firstIO;\r\ntype = "io";\r\nbreak;\r\ncase MEM:\r\nres_cur = bus->firstMem;\r\ntype = "mem";\r\nbreak;\r\ncase PFMEM:\r\nres_cur = bus->firstPFMem;\r\ntype = "pfmem";\r\nbreak;\r\ndefault:\r\nerr("wrong type of flag\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (res_cur) {\r\nif (res_cur->start == start_address) {\r\n*res = res_cur;\r\nbreak;\r\n}\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\n}\r\nif (!res_cur) {\r\nif (flag == PFMEM) {\r\nres_cur = bus->firstPFMemFromMem;\r\nwhile (res_cur) {\r\nif (res_cur->start == start_address) {\r\n*res = res_cur;\r\nbreak;\r\n}\r\nres_cur = res_cur->next;\r\n}\r\nif (!res_cur) {\r\ndebug("SOS...cannot find %s resource in the bus.\n", type);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndebug("SOS... cannot find %s resource in the bus.\n", type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (*res)\r\ndebug("*res->start = %x\n", (*res)->start);\r\nreturn 0;\r\n}\r\nvoid ibmphp_free_resources(void)\r\n{\r\nstruct bus_node *bus_cur = NULL, *next;\r\nstruct bus_node *bus_tmp;\r\nstruct range_node *range_cur;\r\nstruct range_node *range_tmp;\r\nstruct resource_node *res_cur;\r\nstruct resource_node *res_tmp;\r\nint i = 0;\r\nflags = 1;\r\nlist_for_each_entry_safe(bus_cur, next, &gbuses, bus_list) {\r\nif (bus_cur->noIORanges) {\r\nrange_cur = bus_cur->rangeIO;\r\nfor (i = 0; i < bus_cur->noIORanges; i++) {\r\nif (!range_cur)\r\nbreak;\r\nrange_tmp = range_cur;\r\nrange_cur = range_cur->next;\r\nkfree(range_tmp);\r\nrange_tmp = NULL;\r\n}\r\n}\r\nif (bus_cur->noMemRanges) {\r\nrange_cur = bus_cur->rangeMem;\r\nfor (i = 0; i < bus_cur->noMemRanges; i++) {\r\nif (!range_cur)\r\nbreak;\r\nrange_tmp = range_cur;\r\nrange_cur = range_cur->next;\r\nkfree(range_tmp);\r\nrange_tmp = NULL;\r\n}\r\n}\r\nif (bus_cur->noPFMemRanges) {\r\nrange_cur = bus_cur->rangePFMem;\r\nfor (i = 0; i < bus_cur->noPFMemRanges; i++) {\r\nif (!range_cur)\r\nbreak;\r\nrange_tmp = range_cur;\r\nrange_cur = range_cur->next;\r\nkfree(range_tmp);\r\nrange_tmp = NULL;\r\n}\r\n}\r\nif (bus_cur->firstIO) {\r\nres_cur = bus_cur->firstIO;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus_cur->firstIO = NULL;\r\n}\r\nif (bus_cur->firstMem) {\r\nres_cur = bus_cur->firstMem;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus_cur->firstMem = NULL;\r\n}\r\nif (bus_cur->firstPFMem) {\r\nres_cur = bus_cur->firstPFMem;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nif (res_cur->next)\r\nres_cur = res_cur->next;\r\nelse\r\nres_cur = res_cur->nextRange;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus_cur->firstPFMem = NULL;\r\n}\r\nif (bus_cur->firstPFMemFromMem) {\r\nres_cur = bus_cur->firstPFMemFromMem;\r\nwhile (res_cur) {\r\nres_tmp = res_cur;\r\nres_cur = res_cur->next;\r\nkfree(res_tmp);\r\nres_tmp = NULL;\r\n}\r\nbus_cur->firstPFMemFromMem = NULL;\r\n}\r\nbus_tmp = bus_cur;\r\nlist_del(&bus_cur->bus_list);\r\nkfree(bus_tmp);\r\nbus_tmp = NULL;\r\n}\r\n}\r\nstatic int __init once_over(void)\r\n{\r\nstruct resource_node *pfmem_cur;\r\nstruct resource_node *pfmem_prev;\r\nstruct resource_node *mem;\r\nstruct bus_node *bus_cur;\r\nlist_for_each_entry(bus_cur, &gbuses, bus_list) {\r\nif ((!bus_cur->rangePFMem) && (bus_cur->firstPFMem)) {\r\nfor (pfmem_cur = bus_cur->firstPFMem, pfmem_prev = NULL; pfmem_cur; pfmem_prev = pfmem_cur, pfmem_cur = pfmem_cur->next) {\r\npfmem_cur->fromMem = 1;\r\nif (pfmem_prev)\r\npfmem_prev->next = pfmem_cur->next;\r\nelse\r\nbus_cur->firstPFMem = pfmem_cur->next;\r\nif (!bus_cur->firstPFMemFromMem)\r\npfmem_cur->next = NULL;\r\nelse\r\npfmem_cur->next = bus_cur->firstPFMemFromMem;\r\nbus_cur->firstPFMemFromMem = pfmem_cur;\r\nmem = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!mem) {\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmem->type = MEM;\r\nmem->busno = pfmem_cur->busno;\r\nmem->devfunc = pfmem_cur->devfunc;\r\nmem->start = pfmem_cur->start;\r\nmem->end = pfmem_cur->end;\r\nmem->len = pfmem_cur->len;\r\nif (ibmphp_add_resource(mem) < 0)\r\nerr("Trouble...trouble... EBDA allocated pfmem from mem, but system doesn't display it has this space... unless not PCI device...\n");\r\npfmem_cur->rangeno = mem->rangeno;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ibmphp_add_pfmem_from_mem(struct resource_node *pfmem)\r\n{\r\nstruct bus_node *bus_cur = find_bus_wprev(pfmem->busno, NULL, 0);\r\nif (!bus_cur) {\r\nerr("cannot find bus of pfmem to add...\n");\r\nreturn -ENODEV;\r\n}\r\nif (bus_cur->firstPFMemFromMem)\r\npfmem->next = bus_cur->firstPFMemFromMem;\r\nelse\r\npfmem->next = NULL;\r\nbus_cur->firstPFMemFromMem = pfmem;\r\nreturn 0;\r\n}\r\nstruct bus_node *ibmphp_find_res_bus(u8 bus_number)\r\n{\r\nreturn find_bus_wprev(bus_number, NULL, 0);\r\n}\r\nstatic struct bus_node *find_bus_wprev(u8 bus_number, struct bus_node **prev, u8 flag)\r\n{\r\nstruct bus_node *bus_cur;\r\nlist_for_each_entry(bus_cur, &gbuses, bus_list) {\r\nif (flag)\r\n*prev = list_prev_entry(bus_cur, bus_list);\r\nif (bus_cur->busno == bus_number)\r\nreturn bus_cur;\r\n}\r\nreturn NULL;\r\n}\r\nvoid ibmphp_print_test(void)\r\n{\r\nint i = 0;\r\nstruct bus_node *bus_cur = NULL;\r\nstruct range_node *range;\r\nstruct resource_node *res;\r\ndebug_pci("*****************START**********************\n");\r\nif ((!list_empty(&gbuses)) && flags) {\r\nerr("The GBUSES is not NULL?!?!?!?!?\n");\r\nreturn;\r\n}\r\nlist_for_each_entry(bus_cur, &gbuses, bus_list) {\r\ndebug_pci ("This is bus # %d. There are\n", bus_cur->busno);\r\ndebug_pci ("IORanges = %d\t", bus_cur->noIORanges);\r\ndebug_pci ("MemRanges = %d\t", bus_cur->noMemRanges);\r\ndebug_pci ("PFMemRanges = %d\n", bus_cur->noPFMemRanges);\r\ndebug_pci ("The IO Ranges are as follows:\n");\r\nif (bus_cur->rangeIO) {\r\nrange = bus_cur->rangeIO;\r\nfor (i = 0; i < bus_cur->noIORanges; i++) {\r\ndebug_pci("rangeno is %d\n", range->rangeno);\r\ndebug_pci("[%x - %x]\n", range->start, range->end);\r\nrange = range->next;\r\n}\r\n}\r\ndebug_pci("The Mem Ranges are as follows:\n");\r\nif (bus_cur->rangeMem) {\r\nrange = bus_cur->rangeMem;\r\nfor (i = 0; i < bus_cur->noMemRanges; i++) {\r\ndebug_pci("rangeno is %d\n", range->rangeno);\r\ndebug_pci("[%x - %x]\n", range->start, range->end);\r\nrange = range->next;\r\n}\r\n}\r\ndebug_pci("The PFMem Ranges are as follows:\n");\r\nif (bus_cur->rangePFMem) {\r\nrange = bus_cur->rangePFMem;\r\nfor (i = 0; i < bus_cur->noPFMemRanges; i++) {\r\ndebug_pci("rangeno is %d\n", range->rangeno);\r\ndebug_pci("[%x - %x]\n", range->start, range->end);\r\nrange = range->next;\r\n}\r\n}\r\ndebug_pci("The resources on this bus are as follows\n");\r\ndebug_pci("IO...\n");\r\nif (bus_cur->firstIO) {\r\nres = bus_cur->firstIO;\r\nwhile (res) {\r\ndebug_pci("The range # is %d\n", res->rangeno);\r\ndebug_pci("The bus, devfnc is %d, %x\n", res->busno, res->devfunc);\r\ndebug_pci("[%x - %x], len=%x\n", res->start, res->end, res->len);\r\nif (res->next)\r\nres = res->next;\r\nelse if (res->nextRange)\r\nres = res->nextRange;\r\nelse\r\nbreak;\r\n}\r\n}\r\ndebug_pci("Mem...\n");\r\nif (bus_cur->firstMem) {\r\nres = bus_cur->firstMem;\r\nwhile (res) {\r\ndebug_pci("The range # is %d\n", res->rangeno);\r\ndebug_pci("The bus, devfnc is %d, %x\n", res->busno, res->devfunc);\r\ndebug_pci("[%x - %x], len=%x\n", res->start, res->end, res->len);\r\nif (res->next)\r\nres = res->next;\r\nelse if (res->nextRange)\r\nres = res->nextRange;\r\nelse\r\nbreak;\r\n}\r\n}\r\ndebug_pci("PFMem...\n");\r\nif (bus_cur->firstPFMem) {\r\nres = bus_cur->firstPFMem;\r\nwhile (res) {\r\ndebug_pci("The range # is %d\n", res->rangeno);\r\ndebug_pci("The bus, devfnc is %d, %x\n", res->busno, res->devfunc);\r\ndebug_pci("[%x - %x], len=%x\n", res->start, res->end, res->len);\r\nif (res->next)\r\nres = res->next;\r\nelse if (res->nextRange)\r\nres = res->nextRange;\r\nelse\r\nbreak;\r\n}\r\n}\r\ndebug_pci("PFMemFromMem...\n");\r\nif (bus_cur->firstPFMemFromMem) {\r\nres = bus_cur->firstPFMemFromMem;\r\nwhile (res) {\r\ndebug_pci("The range # is %d\n", res->rangeno);\r\ndebug_pci("The bus, devfnc is %d, %x\n", res->busno, res->devfunc);\r\ndebug_pci("[%x - %x], len=%x\n", res->start, res->end, res->len);\r\nres = res->next;\r\n}\r\n}\r\n}\r\ndebug_pci("***********************END***********************\n");\r\n}\r\nstatic int range_exists_already(struct range_node *range, struct bus_node *bus_cur, u8 type)\r\n{\r\nstruct range_node *range_cur = NULL;\r\nswitch (type) {\r\ncase IO:\r\nrange_cur = bus_cur->rangeIO;\r\nbreak;\r\ncase MEM:\r\nrange_cur = bus_cur->rangeMem;\r\nbreak;\r\ncase PFMEM:\r\nrange_cur = bus_cur->rangePFMem;\r\nbreak;\r\ndefault:\r\nerr("wrong type passed to find out if range already exists\n");\r\nreturn -ENODEV;\r\n}\r\nwhile (range_cur) {\r\nif ((range_cur->start == range->start) && (range_cur->end == range->end))\r\nreturn 1;\r\nrange_cur = range_cur->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init update_bridge_ranges(struct bus_node **bus)\r\n{\r\nu8 sec_busno, device, function, hdr_type, start_io_address, end_io_address;\r\nu16 vendor_id, upper_io_start, upper_io_end, start_mem_address, end_mem_address;\r\nu32 start_address, end_address, upper_start, upper_end;\r\nstruct bus_node *bus_sec;\r\nstruct bus_node *bus_cur;\r\nstruct resource_node *io;\r\nstruct resource_node *mem;\r\nstruct resource_node *pfmem;\r\nstruct range_node *range;\r\nunsigned int devfn;\r\nbus_cur = *bus;\r\nif (!bus_cur)\r\nreturn -ENODEV;\r\nibmphp_pci_bus->number = bus_cur->busno;\r\ndebug("inside %s\n", __func__);\r\ndebug("bus_cur->busno = %x\n", bus_cur->busno);\r\nfor (device = 0; device < 32; device++) {\r\nfor (function = 0x00; function < 0x08; function++) {\r\ndevfn = PCI_DEVFN(device, function);\r\npci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\r\nif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\r\npci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\r\nswitch (hdr_type) {\r\ncase PCI_HEADER_TYPE_NORMAL:\r\nfunction = 0x8;\r\nbreak;\r\ncase PCI_HEADER_TYPE_MULTIDEVICE:\r\nbreak;\r\ncase PCI_HEADER_TYPE_BRIDGE:\r\nfunction = 0x8;\r\ncase PCI_HEADER_TYPE_MULTIBRIDGE:\r\npci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_busno);\r\nbus_sec = find_bus_wprev(sec_busno, NULL, 0);\r\nif (!bus_sec) {\r\nbus_sec = alloc_error_bus(NULL, sec_busno, 1);\r\nreturn 0;\r\n}\r\npci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_IO_BASE, &start_io_address);\r\npci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_IO_LIMIT, &end_io_address);\r\npci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_IO_BASE_UPPER16, &upper_io_start);\r\npci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_IO_LIMIT_UPPER16, &upper_io_end);\r\nstart_address = (start_io_address & PCI_IO_RANGE_MASK) << 8;\r\nstart_address |= (upper_io_start << 16);\r\nend_address = (end_io_address & PCI_IO_RANGE_MASK) << 8;\r\nend_address |= (upper_io_end << 16);\r\nif ((start_address) && (start_address <= end_address)) {\r\nrange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\r\nif (!range) {\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nrange->start = start_address;\r\nrange->end = end_address + 0xfff;\r\nif (bus_sec->noIORanges > 0) {\r\nif (!range_exists_already(range, bus_sec, IO)) {\r\nadd_bus_range(IO, range, bus_sec);\r\n++bus_sec->noIORanges;\r\n} else {\r\nkfree(range);\r\nrange = NULL;\r\n}\r\n} else {\r\nrange->rangeno = 1;\r\nbus_sec->rangeIO = range;\r\n++bus_sec->noIORanges;\r\n}\r\nfix_resources(bus_sec);\r\nif (ibmphp_find_resource(bus_cur, start_address, &io, IO)) {\r\nio = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!io) {\r\nkfree(range);\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nio->type = IO;\r\nio->busno = bus_cur->busno;\r\nio->devfunc = ((device << 3) | (function & 0x7));\r\nio->start = start_address;\r\nio->end = end_address + 0xfff;\r\nio->len = io->end - io->start + 1;\r\nibmphp_add_resource(io);\r\n}\r\n}\r\npci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_BASE, &start_mem_address);\r\npci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_LIMIT, &end_mem_address);\r\nstart_address = 0x00000000 | (start_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\r\nend_address = 0x00000000 | (end_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\r\nif ((start_address) && (start_address <= end_address)) {\r\nrange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\r\nif (!range) {\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nrange->start = start_address;\r\nrange->end = end_address + 0xfffff;\r\nif (bus_sec->noMemRanges > 0) {\r\nif (!range_exists_already(range, bus_sec, MEM)) {\r\nadd_bus_range(MEM, range, bus_sec);\r\n++bus_sec->noMemRanges;\r\n} else {\r\nkfree(range);\r\nrange = NULL;\r\n}\r\n} else {\r\nrange->rangeno = 1;\r\nbus_sec->rangeMem = range;\r\n++bus_sec->noMemRanges;\r\n}\r\nfix_resources(bus_sec);\r\nif (ibmphp_find_resource(bus_cur, start_address, &mem, MEM)) {\r\nmem = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!mem) {\r\nkfree(range);\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmem->type = MEM;\r\nmem->busno = bus_cur->busno;\r\nmem->devfunc = ((device << 3) | (function & 0x7));\r\nmem->start = start_address;\r\nmem->end = end_address + 0xfffff;\r\nmem->len = mem->end - mem->start + 1;\r\nibmphp_add_resource(mem);\r\n}\r\n}\r\npci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, &start_mem_address);\r\npci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, &end_mem_address);\r\npci_bus_read_config_dword(ibmphp_pci_bus, devfn, PCI_PREF_BASE_UPPER32, &upper_start);\r\npci_bus_read_config_dword(ibmphp_pci_bus, devfn, PCI_PREF_LIMIT_UPPER32, &upper_end);\r\nstart_address = 0x00000000 | (start_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\r\nend_address = 0x00000000 | (end_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\r\n#if BITS_PER_LONG == 64\r\nstart_address |= ((long) upper_start) << 32;\r\nend_address |= ((long) upper_end) << 32;\r\n#endif\r\nif ((start_address) && (start_address <= end_address)) {\r\nrange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\r\nif (!range) {\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nrange->start = start_address;\r\nrange->end = end_address + 0xfffff;\r\nif (bus_sec->noPFMemRanges > 0) {\r\nif (!range_exists_already(range, bus_sec, PFMEM)) {\r\nadd_bus_range(PFMEM, range, bus_sec);\r\n++bus_sec->noPFMemRanges;\r\n} else {\r\nkfree(range);\r\nrange = NULL;\r\n}\r\n} else {\r\nrange->rangeno = 1;\r\nbus_sec->rangePFMem = range;\r\n++bus_sec->noPFMemRanges;\r\n}\r\nfix_resources(bus_sec);\r\nif (ibmphp_find_resource(bus_cur, start_address, &pfmem, PFMEM)) {\r\npfmem = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!pfmem) {\r\nkfree(range);\r\nerr("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\npfmem->type = PFMEM;\r\npfmem->busno = bus_cur->busno;\r\npfmem->devfunc = ((device << 3) | (function & 0x7));\r\npfmem->start = start_address;\r\npfmem->end = end_address + 0xfffff;\r\npfmem->len = pfmem->end - pfmem->start + 1;\r\npfmem->fromMem = 0;\r\nibmphp_add_resource(pfmem);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nbus = &bus_cur;\r\nreturn 0;\r\n}
