static int axp20x_set_dcdc_freq(struct platform_device *pdev, u32 dcdcfreq)\r\n{\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nu32 min, max, def, step;\r\nswitch (axp20x->variant) {\r\ncase AXP202_ID:\r\ncase AXP209_ID:\r\nmin = 750;\r\nmax = 1875;\r\ndef = 1500;\r\nstep = 75;\r\nbreak;\r\ncase AXP221_ID:\r\ncase AXP223_ID:\r\nmin = 1800;\r\nmax = 4050;\r\ndef = 3000;\r\nstep = 150;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev,\r\n"Setting DCDC frequency for unsupported AXP variant\n");\r\nreturn -EINVAL;\r\n}\r\nif (dcdcfreq == 0)\r\ndcdcfreq = def;\r\nif (dcdcfreq < min) {\r\ndcdcfreq = min;\r\ndev_warn(&pdev->dev, "DCDC frequency too low. Set to %ukHz\n",\r\nmin);\r\n}\r\nif (dcdcfreq > max) {\r\ndcdcfreq = max;\r\ndev_warn(&pdev->dev, "DCDC frequency too high. Set to %ukHz\n",\r\nmax);\r\n}\r\ndcdcfreq = (dcdcfreq - min) / step;\r\nreturn regmap_update_bits(axp20x->regmap, AXP20X_DCDC_FREQ,\r\nAXP20X_FREQ_DCDC_MASK, dcdcfreq);\r\n}\r\nstatic int axp20x_regulator_parse_dt(struct platform_device *pdev)\r\n{\r\nstruct device_node *np, *regulators;\r\nint ret;\r\nu32 dcdcfreq = 0;\r\nnp = of_node_get(pdev->dev.parent->of_node);\r\nif (!np)\r\nreturn 0;\r\nregulators = of_get_child_by_name(np, "regulators");\r\nif (!regulators) {\r\ndev_warn(&pdev->dev, "regulators node not found\n");\r\n} else {\r\nof_property_read_u32(regulators, "x-powers,dcdc-freq", &dcdcfreq);\r\nret = axp20x_set_dcdc_freq(pdev, dcdcfreq);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error setting dcdc frequency: %d\n", ret);\r\nreturn ret;\r\n}\r\nof_node_put(regulators);\r\n}\r\nreturn 0;\r\n}\r\nstatic int axp20x_set_dcdc_workmode(struct regulator_dev *rdev, int id, u32 workmode)\r\n{\r\nstruct axp20x_dev *axp20x = rdev_get_drvdata(rdev);\r\nunsigned int mask;\r\nswitch (axp20x->variant) {\r\ncase AXP202_ID:\r\ncase AXP209_ID:\r\nif ((id != AXP20X_DCDC2) && (id != AXP20X_DCDC3))\r\nreturn -EINVAL;\r\nmask = AXP20X_WORKMODE_DCDC2_MASK;\r\nif (id == AXP20X_DCDC3)\r\nmask = AXP20X_WORKMODE_DCDC3_MASK;\r\nworkmode <<= ffs(mask) - 1;\r\nbreak;\r\ncase AXP221_ID:\r\ncase AXP223_ID:\r\nif (id < AXP22X_DCDC1 || id > AXP22X_DCDC5)\r\nreturn -EINVAL;\r\nmask = AXP22X_WORKMODE_DCDCX_MASK(id - AXP22X_DCDC1);\r\nworkmode <<= id - AXP22X_DCDC1;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, AXP20X_DCDC_MODE, mask, workmode);\r\n}\r\nstatic int axp20x_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator_dev *rdev;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nconst struct regulator_desc *regulators;\r\nstruct regulator_config config = {\r\n.dev = pdev->dev.parent,\r\n.regmap = axp20x->regmap,\r\n.driver_data = axp20x,\r\n};\r\nint ret, i, nregulators;\r\nu32 workmode;\r\nconst char *axp22x_dc1_name = axp22x_regulators[AXP22X_DCDC1].name;\r\nconst char *axp22x_dc5_name = axp22x_regulators[AXP22X_DCDC5].name;\r\nswitch (axp20x->variant) {\r\ncase AXP202_ID:\r\ncase AXP209_ID:\r\nregulators = axp20x_regulators;\r\nnregulators = AXP20X_REG_ID_MAX;\r\nbreak;\r\ncase AXP221_ID:\r\ncase AXP223_ID:\r\nregulators = axp22x_regulators;\r\nnregulators = AXP22X_REG_ID_MAX;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported AXP variant: %ld\n",\r\naxp20x->variant);\r\nreturn -EINVAL;\r\n}\r\naxp20x_regulator_parse_dt(pdev);\r\nfor (i = 0; i < nregulators; i++) {\r\nconst struct regulator_desc *desc = &regulators[i];\r\nstruct regulator_desc *new_desc;\r\nif (regulators == axp22x_regulators) {\r\nif (i == AXP22X_DC1SW) {\r\nnew_desc = devm_kzalloc(&pdev->dev,\r\nsizeof(*desc),\r\nGFP_KERNEL);\r\n*new_desc = regulators[i];\r\nnew_desc->supply_name = axp22x_dc1_name;\r\ndesc = new_desc;\r\n} else if (i == AXP22X_DC5LDO) {\r\nnew_desc = devm_kzalloc(&pdev->dev,\r\nsizeof(*desc),\r\nGFP_KERNEL);\r\n*new_desc = regulators[i];\r\nnew_desc->supply_name = axp22x_dc5_name;\r\ndesc = new_desc;\r\n}\r\n}\r\nrdev = devm_regulator_register(&pdev->dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "Failed to register %s\n",\r\nregulators[i].name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nret = of_property_read_u32(rdev->dev.of_node,\r\n"x-powers,dcdc-workmode",\r\n&workmode);\r\nif (!ret) {\r\nif (axp20x_set_dcdc_workmode(rdev, i, workmode))\r\ndev_err(&pdev->dev, "Failed to set workmode on %s\n",\r\nrdev->desc->name);\r\n}\r\nif (regulators == axp22x_regulators) {\r\nif (i == AXP22X_DCDC1)\r\nof_property_read_string(rdev->dev.of_node,\r\n"regulator-name",\r\n&axp22x_dc1_name);\r\nelse if (i == AXP22X_DCDC5)\r\nof_property_read_string(rdev->dev.of_node,\r\n"regulator-name",\r\n&axp22x_dc5_name);\r\n}\r\n}\r\nreturn 0;\r\n}
