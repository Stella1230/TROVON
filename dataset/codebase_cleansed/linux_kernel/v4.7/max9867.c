static inline int get_ni_value(int mclk, int rate)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ni_div); i++) {\r\nif (ni_div[i].mclk >= mclk)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(ni_div))\r\nreturn -EINVAL;\r\nswitch (rate) {\r\ncase 8000:\r\nreturn ni_div[i].ni[pcm_rate_8];\r\ncase 16000:\r\nreturn ni_div[i].ni[pcm_rate_16];\r\ncase 32000:\r\nreturn ni_div[i].ni[pcm_rate_32];\r\ncase 44100:\r\nreturn ni_div[i].ni[pcm_rate_44];\r\ncase 48000:\r\nreturn ni_div[i].ni[pcm_rate_48];\r\ndefault:\r\npr_err("%s wrong rate %d\n", __func__, rate);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int max9867_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int ni_h, ni_l;\r\nint value;\r\nvalue = get_ni_value(max9867->sysclk, params_rate(params));\r\nif (value < 0)\r\nreturn value;\r\nni_h = (0xFF00 & value) >> 8;\r\nni_l = 0x00FF & value;\r\nregmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKHIGH,\r\nMAX9867_NI_HIGH_MASK, ni_h);\r\nregmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKLOW,\r\nMAX9867_NI_LOW_MASK, ni_l);\r\nif (!max9867->master) {\r\nregmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKLOW,\r\nMAX9867_RAPID_LOCK, MAX9867_RAPID_LOCK);\r\nregmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKHIGH,\r\nMAX9867_PLL, MAX9867_PLL);\r\n} else {\r\nunsigned long int bclk_rate, pclk_bclk_ratio;\r\nint bclk_value;\r\nbclk_rate = params_rate(params) * 2 * params_width(params);\r\npclk_bclk_ratio = max9867->pclk/bclk_rate;\r\nswitch (params_width(params)) {\r\ncase 8:\r\ncase 16:\r\nswitch (pclk_bclk_ratio) {\r\ncase 2:\r\nbclk_value = MAX9867_IFC1B_PCLK_2;\r\nbreak;\r\ncase 4:\r\nbclk_value = MAX9867_IFC1B_PCLK_4;\r\nbreak;\r\ncase 8:\r\nbclk_value = MAX9867_IFC1B_PCLK_8;\r\nbreak;\r\ncase 16:\r\nbclk_value = MAX9867_IFC1B_PCLK_16;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev,\r\n"unsupported sampling rate\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 24:\r\nbclk_value = MAX9867_IFC1B_24BIT;\r\nbreak;\r\ncase 32:\r\nbclk_value = MAX9867_IFC1B_32BIT;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported sampling rate\n");\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(max9867->regmap, MAX9867_IFC1B,\r\nMAX9867_IFC1B_BCLK_MASK, bclk_value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max9867_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);\r\nregmap_update_bits(max9867->regmap, MAX9867_PWRMAN,\r\nMAX9867_SHTDOWN_MASK, MAX9867_SHTDOWN_MASK);\r\nreturn 0;\r\n}\r\nstatic int max9867_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);\r\nif (mute)\r\nregmap_update_bits(max9867->regmap, MAX9867_DACLEVEL,\r\nMAX9867_DAC_MUTE_MASK, MAX9867_DAC_MUTE_MASK);\r\nelse\r\nregmap_update_bits(max9867->regmap, MAX9867_DACLEVEL,\r\nMAX9867_DAC_MUTE_MASK, 0);\r\nreturn 0;\r\n}\r\nstatic int max9867_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);\r\nint value = 0;\r\nif (freq >= 10000000 && freq <= 20000000) {\r\nvalue |= MAX9867_PSCLK_10_20;\r\nmax9867->pclk = freq;\r\n} else if (freq >= 20000000 && freq <= 40000000) {\r\nvalue |= MAX9867_PSCLK_20_40;\r\nmax9867->pclk = freq/2;\r\n} else if (freq >= 40000000 && freq <= 60000000) {\r\nvalue |= MAX9867_PSCLK_40_60;\r\nmax9867->pclk = freq/4;\r\n} else {\r\npr_err("bad clock frequency %d", freq);\r\nreturn -EINVAL;\r\n}\r\nvalue = value << MAX9867_PSCLK_SHIFT;\r\nmax9867->sysclk = freq;\r\nvalue &= ~MAX9867_FREQ_MASK;\r\nregmap_update_bits(max9867->regmap, MAX9867_SYSCLK,\r\nMAX9867_PSCLK_MASK, value);\r\nreturn 0;\r\n}\r\nstatic int max9867_dai_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);\r\nu8 iface1A = 0, iface1B = 0;\r\nint ret;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmax9867->master = 1;\r\niface1A |= MAX9867_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmax9867->master = 0;\r\niface1A &= ~MAX9867_MASTER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\niface1A |= MAX9867_I2S_DLY;\r\niface1A |= MAX9867_SDOUT_HIZ;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface1A |= MAX9867_WCI_MODE | MAX9867_BCI_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface1A |= MAX9867_BCI_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface1A |= MAX9867_WCI_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_write(max9867->regmap, MAX9867_IFC1A, iface1A);\r\nret = regmap_write(max9867->regmap, MAX9867_IFC1B, iface1B);\r\nreturn 0;\r\n}\r\nstatic int max9867_suspend(struct device *dev)\r\n{\r\nstruct max9867_priv *max9867 = dev_get_drvdata(dev);\r\nregmap_update_bits(max9867->regmap, MAX9867_PWRMAN,\r\nMAX9867_SHTDOWN_MASK, ~MAX9867_SHTDOWN_MASK);\r\nreturn 0;\r\n}\r\nstatic int max9867_resume(struct device *dev)\r\n{\r\nstruct max9867_priv *max9867 = dev_get_drvdata(dev);\r\nregmap_update_bits(max9867->regmap, MAX9867_PWRMAN,\r\nMAX9867_SHTDOWN_MASK, MAX9867_SHTDOWN_MASK);\r\nreturn 0;\r\n}\r\nstatic int max9867_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "max98090_probe\n");\r\nmax9867->codec = codec;\r\nreturn 0;\r\n}\r\nstatic bool max9867_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX9867_STATUS:\r\ncase MAX9867_JACKSTATUS:\r\ncase MAX9867_AUXHIGH:\r\ncase MAX9867_AUXLOW:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int max9867_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max9867_priv *max9867;\r\nint ret = 0, reg;\r\nmax9867 = devm_kzalloc(&i2c->dev,\r\nsizeof(*max9867), GFP_KERNEL);\r\nif (!max9867)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, max9867);\r\nmax9867->regmap = devm_regmap_init_i2c(i2c, &max9867_regmap);\r\nif (IS_ERR(max9867->regmap)) {\r\nret = PTR_ERR(max9867->regmap);\r\ndev_err(&i2c->dev,\r\n"Failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(max9867->regmap,\r\nMAX9867_REVISION, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_info(&i2c->dev, "device revision: %x\n", reg);\r\nret = snd_soc_register_codec(&i2c->dev, &max9867_codec,\r\nmax9867_dai, ARRAY_SIZE(max9867_dai));\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int max9867_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
