static int rsrc_card_startup(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct rsrc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct rsrc_card_dai *dai_props =\r\nrsrc_priv_to_props(priv, rtd->num);\r\nreturn clk_prepare_enable(dai_props->clk);\r\n}\r\nstatic void rsrc_card_shutdown(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct rsrc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct rsrc_card_dai *dai_props =\r\nrsrc_priv_to_props(priv, rtd->num);\r\nclk_disable_unprepare(dai_props->clk);\r\n}\r\nstatic int rsrc_card_dai_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct rsrc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_soc_dai *dai;\r\nstruct snd_soc_dai_link *dai_link;\r\nstruct rsrc_card_dai *dai_props;\r\nint num = rtd->num;\r\nint ret;\r\ndai_link = rsrc_priv_to_link(priv, num);\r\ndai_props = rsrc_priv_to_props(priv, num);\r\ndai = dai_link->dynamic ?\r\nrtd->cpu_dai :\r\nrtd->codec_dai;\r\nif (dai_props->sysclk) {\r\nret = snd_soc_dai_set_sysclk(dai, 0, dai_props->sysclk, 0);\r\nif (ret && ret != -ENOTSUPP) {\r\ndev_err(dai->dev, "set_sysclk error\n");\r\ngoto err;\r\n}\r\n}\r\nif (dai_props->slots) {\r\nret = snd_soc_dai_set_tdm_slot(dai,\r\ndai_props->tx_slot_mask,\r\ndai_props->rx_slot_mask,\r\ndai_props->slots,\r\ndai_props->slot_width);\r\nif (ret && ret != -ENOTSUPP) {\r\ndev_err(dai->dev, "set_tdm_slot error\n");\r\ngoto err;\r\n}\r\n}\r\nret = 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int rsrc_card_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct rsrc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (priv->convert_rate)\r\nrate->min =\r\nrate->max = priv->convert_rate;\r\nif (priv->convert_channels)\r\nchannels->min =\r\nchannels->max = priv->convert_channels;\r\nreturn 0;\r\n}\r\nstatic int rsrc_card_parse_daifmt(struct device_node *node,\r\nstruct device_node *codec,\r\nstruct rsrc_card_priv *priv,\r\nstruct snd_soc_dai_link *dai_link,\r\nunsigned int *retfmt)\r\n{\r\nstruct device_node *bitclkmaster = NULL;\r\nstruct device_node *framemaster = NULL;\r\nunsigned int daifmt;\r\ndaifmt = snd_soc_of_parse_daifmt(node, NULL,\r\n&bitclkmaster, &framemaster);\r\ndaifmt &= ~SND_SOC_DAIFMT_MASTER_MASK;\r\nif (!bitclkmaster && !framemaster)\r\nreturn -EINVAL;\r\nif (codec == bitclkmaster)\r\ndaifmt |= (codec == framemaster) ?\r\nSND_SOC_DAIFMT_CBM_CFM : SND_SOC_DAIFMT_CBM_CFS;\r\nelse\r\ndaifmt |= (codec == framemaster) ?\r\nSND_SOC_DAIFMT_CBS_CFM : SND_SOC_DAIFMT_CBS_CFS;\r\nof_node_put(bitclkmaster);\r\nof_node_put(framemaster);\r\n*retfmt = daifmt;\r\nreturn 0;\r\n}\r\nstatic int rsrc_card_parse_links(struct device_node *np,\r\nstruct rsrc_card_priv *priv,\r\nint idx, bool is_fe)\r\n{\r\nstruct snd_soc_dai_link *dai_link = rsrc_priv_to_link(priv, idx);\r\nstruct rsrc_card_dai *dai_props = rsrc_priv_to_props(priv, idx);\r\nstruct of_phandle_args args;\r\nint ret;\r\nret = of_parse_phandle_with_args(np, "sound-dai",\r\n"#sound-dai-cells", 0, &args);\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_of_parse_tdm_slot(np,\r\n&dai_props->tx_slot_mask,\r\n&dai_props->rx_slot_mask,\r\n&dai_props->slots,\r\n&dai_props->slot_width);\r\nif (ret)\r\nreturn ret;\r\nif (is_fe) {\r\ndai_link->codec_of_node = NULL;\r\ndai_link->codec_dai_name = "snd-soc-dummy-dai";\r\ndai_link->codec_name = "snd-soc-dummy";\r\ndai_link->dynamic = 1;\r\ndai_link->dpcm_merged_format = 1;\r\ndai_link->cpu_of_node = args.np;\r\nret = snd_soc_of_get_dai_name(np, &dai_link->cpu_dai_name);\r\nif (ret < 0)\r\nreturn ret;\r\nsnprintf(dai_props->dai_name, DAI_NAME_NUM, "fe.%s",\r\ndai_link->cpu_dai_name);\r\nif (!args.args_count)\r\ndai_link->cpu_dai_name = NULL;\r\n} else {\r\nstruct device *dev = rsrc_priv_to_dev(priv);\r\nconst struct rsrc_card_of_data *of_data;\r\nof_data = of_device_get_match_data(dev);\r\ndai_link->cpu_of_node = NULL;\r\ndai_link->cpu_dai_name = "snd-soc-dummy-dai";\r\ndai_link->cpu_name = "snd-soc-dummy";\r\ndai_link->no_pcm = 1;\r\ndai_link->be_hw_params_fixup = rsrc_card_be_hw_params_fixup;\r\ndai_link->codec_of_node = args.np;\r\nret = snd_soc_of_get_dai_name(np, &dai_link->codec_dai_name);\r\nif (ret < 0)\r\nreturn ret;\r\nif (of_data) {\r\npriv->codec_conf.of_node = dai_link->codec_of_node;\r\npriv->codec_conf.name_prefix = of_data->prefix;\r\n} else {\r\nsnd_soc_of_parse_audio_prefix(&priv->snd_card,\r\n&priv->codec_conf,\r\ndai_link->codec_of_node,\r\n"audio-prefix");\r\n}\r\nsnprintf(dai_props->dai_name, DAI_NAME_NUM, "be.%s",\r\ndai_link->codec_dai_name);\r\n}\r\ndai_link->platform_of_node = dai_link->cpu_of_node;\r\ndai_link->dpcm_playback = 1;\r\ndai_link->dpcm_capture = 1;\r\ndai_link->name = dai_props->dai_name;\r\ndai_link->stream_name = dai_props->dai_name;\r\ndai_link->ops = &rsrc_card_ops;\r\ndai_link->init = rsrc_card_dai_init;\r\nreturn 0;\r\n}\r\nstatic int rsrc_card_parse_clk(struct device_node *np,\r\nstruct rsrc_card_priv *priv,\r\nint idx, bool is_fe)\r\n{\r\nstruct snd_soc_dai_link *dai_link = rsrc_priv_to_link(priv, idx);\r\nstruct rsrc_card_dai *dai_props = rsrc_priv_to_props(priv, idx);\r\nstruct clk *clk;\r\nstruct device_node *of_np = is_fe ? dai_link->cpu_of_node :\r\ndai_link->codec_of_node;\r\nu32 val;\r\nif (of_property_read_bool(np, "clocks")) {\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\ndai_props->sysclk = clk_get_rate(clk);\r\ndai_props->clk = clk;\r\n} else if (!of_property_read_u32(np, "system-clock-frequency", &val)) {\r\ndai_props->sysclk = val;\r\n} else {\r\nclk = of_clk_get(of_np, 0);\r\nif (!IS_ERR(clk))\r\ndai_props->sysclk = clk_get_rate(clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rsrc_card_dai_sub_link_of(struct device_node *node,\r\nstruct device_node *np,\r\nstruct rsrc_card_priv *priv,\r\nint idx, bool is_fe)\r\n{\r\nstruct device *dev = rsrc_priv_to_dev(priv);\r\nstruct snd_soc_dai_link *dai_link = rsrc_priv_to_link(priv, idx);\r\nstruct rsrc_card_dai *dai_props = rsrc_priv_to_props(priv, idx);\r\nint ret;\r\nret = rsrc_card_parse_links(np, priv, idx, is_fe);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rsrc_card_parse_clk(np, priv, idx, is_fe);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(dev, "\t%s / %04x / %d\n",\r\ndai_props->dai_name,\r\ndai_link->dai_fmt,\r\ndai_props->sysclk);\r\nreturn ret;\r\n}\r\nstatic int rsrc_card_dai_link_of(struct device_node *node,\r\nstruct rsrc_card_priv *priv)\r\n{\r\nstruct snd_soc_dai_link *dai_link;\r\nstruct device_node *np;\r\nunsigned int daifmt = 0;\r\nint ret, i;\r\nbool is_fe;\r\ni = 0;\r\nfor_each_child_of_node(node, np) {\r\ndai_link = rsrc_priv_to_link(priv, i);\r\nif (strcmp(np->name, "codec") == 0) {\r\nret = rsrc_card_parse_daifmt(node, np, priv,\r\ndai_link, &daifmt);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\ni++;\r\n}\r\ni = 0;\r\nfor_each_child_of_node(node, np) {\r\ndai_link = rsrc_priv_to_link(priv, i);\r\ndai_link->dai_fmt = daifmt;\r\nis_fe = false;\r\nif (strcmp(np->name, "cpu") == 0)\r\nis_fe = true;\r\nret = rsrc_card_dai_sub_link_of(node, np, priv, i, is_fe);\r\nif (ret < 0)\r\nreturn ret;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rsrc_card_parse_of(struct device_node *node,\r\nstruct rsrc_card_priv *priv,\r\nstruct device *dev)\r\n{\r\nconst struct rsrc_card_of_data *of_data = of_device_get_match_data(dev);\r\nstruct rsrc_card_dai *props;\r\nstruct snd_soc_dai_link *links;\r\nint ret;\r\nint num;\r\nif (!node)\r\nreturn -EINVAL;\r\nnum = of_get_child_count(node);\r\nprops = devm_kzalloc(dev, sizeof(*props) * num, GFP_KERNEL);\r\nlinks = devm_kzalloc(dev, sizeof(*links) * num, GFP_KERNEL);\r\nif (!props || !links)\r\nreturn -ENOMEM;\r\npriv->dai_props = props;\r\npriv->dai_link = links;\r\npriv->dai_num = num;\r\npriv->snd_card.owner = THIS_MODULE;\r\npriv->snd_card.dev = dev;\r\npriv->snd_card.dai_link = priv->dai_link;\r\npriv->snd_card.num_links = num;\r\npriv->snd_card.codec_conf = &priv->codec_conf;\r\npriv->snd_card.num_configs = 1;\r\nif (of_data) {\r\npriv->snd_card.of_dapm_routes = of_data->routes;\r\npriv->snd_card.num_of_dapm_routes = of_data->num_routes;\r\n} else {\r\nsnd_soc_of_parse_audio_routing(&priv->snd_card,\r\n"audio-routing");\r\n}\r\nsnd_soc_of_parse_card_name(&priv->snd_card, "card-name");\r\nof_property_read_u32(node, "convert-rate", &priv->convert_rate);\r\nof_property_read_u32(node, "convert-channels", &priv->convert_channels);\r\ndev_dbg(dev, "New rsrc-audio-card: %s\n",\r\npriv->snd_card.name ? priv->snd_card.name : "");\r\ndev_dbg(dev, "SRC : convert_rate %d\n", priv->convert_rate);\r\ndev_dbg(dev, "CTU : convert_channels %d\n", priv->convert_channels);\r\nret = rsrc_card_dai_link_of(node, priv);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!priv->snd_card.name)\r\npriv->snd_card.name = priv->snd_card.dai_link->name;\r\nreturn 0;\r\n}\r\nstatic int rsrc_card_unref(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dai_link *dai_link;\r\nint num_links;\r\nfor (num_links = 0, dai_link = card->dai_link;\r\nnum_links < card->num_links;\r\nnum_links++, dai_link++) {\r\nof_node_put(dai_link->cpu_of_node);\r\nof_node_put(dai_link->codec_of_node);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rsrc_card_probe(struct platform_device *pdev)\r\n{\r\nstruct rsrc_card_priv *priv;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nret = rsrc_card_parse_of(np, priv, dev);\r\nif (ret < 0) {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "parse error %d\n", ret);\r\ngoto err;\r\n}\r\nsnd_soc_card_set_drvdata(&priv->snd_card, priv);\r\nret = devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);\r\nif (ret >= 0)\r\nreturn ret;\r\nerr:\r\nrsrc_card_unref(&priv->snd_card);\r\nreturn ret;\r\n}\r\nstatic int rsrc_card_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_soc_card *card = platform_get_drvdata(pdev);\r\nreturn rsrc_card_unref(card);\r\n}
