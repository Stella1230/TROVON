struct nlm_host *nlmclnt_init(const struct nlmclnt_initdata *nlm_init)\r\n{\r\nstruct nlm_host *host;\r\nu32 nlm_version = (nlm_init->nfs_version == 2) ? 1 : 4;\r\nint status;\r\nstatus = lockd_up(nlm_init->net);\r\nif (status < 0)\r\nreturn ERR_PTR(status);\r\nhost = nlmclnt_lookup_host(nlm_init->address, nlm_init->addrlen,\r\nnlm_init->protocol, nlm_version,\r\nnlm_init->hostname, nlm_init->noresvport,\r\nnlm_init->net);\r\nif (host == NULL)\r\ngoto out_nohost;\r\nif (host->h_rpcclnt == NULL && nlm_bind_host(host) == NULL)\r\ngoto out_nobind;\r\nreturn host;\r\nout_nobind:\r\nnlmclnt_release_host(host);\r\nout_nohost:\r\nlockd_down(nlm_init->net);\r\nreturn ERR_PTR(-ENOLCK);\r\n}\r\nvoid nlmclnt_done(struct nlm_host *host)\r\n{\r\nstruct net *net = host->net;\r\nnlmclnt_release_host(host);\r\nlockd_down(net);\r\n}\r\nstruct nlm_wait *nlmclnt_prepare_block(struct nlm_host *host, struct file_lock *fl)\r\n{\r\nstruct nlm_wait *block;\r\nblock = kmalloc(sizeof(*block), GFP_KERNEL);\r\nif (block != NULL) {\r\nblock->b_host = host;\r\nblock->b_lock = fl;\r\ninit_waitqueue_head(&block->b_wait);\r\nblock->b_status = nlm_lck_blocked;\r\nspin_lock(&nlm_blocked_lock);\r\nlist_add(&block->b_list, &nlm_blocked);\r\nspin_unlock(&nlm_blocked_lock);\r\n}\r\nreturn block;\r\n}\r\nvoid nlmclnt_finish_block(struct nlm_wait *block)\r\n{\r\nif (block == NULL)\r\nreturn;\r\nspin_lock(&nlm_blocked_lock);\r\nlist_del(&block->b_list);\r\nspin_unlock(&nlm_blocked_lock);\r\nkfree(block);\r\n}\r\nint nlmclnt_block(struct nlm_wait *block, struct nlm_rqst *req, long timeout)\r\n{\r\nlong ret;\r\nif (block == NULL)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible_timeout(block->b_wait,\r\nblock->b_status != nlm_lck_blocked,\r\ntimeout);\r\nif (ret < 0)\r\nreturn -ERESTARTSYS;\r\nif (block->b_status == nlm_lck_denied_grace_period)\r\nblock->b_status = nlm_lck_blocked;\r\nreq->a_res.status = block->b_status;\r\nreturn 0;\r\n}\r\n__be32 nlmclnt_grant(const struct sockaddr *addr, const struct nlm_lock *lock)\r\n{\r\nconst struct file_lock *fl = &lock->fl;\r\nconst struct nfs_fh *fh = &lock->fh;\r\nstruct nlm_wait *block;\r\n__be32 res = nlm_lck_denied;\r\nspin_lock(&nlm_blocked_lock);\r\nlist_for_each_entry(block, &nlm_blocked, b_list) {\r\nstruct file_lock *fl_blocked = block->b_lock;\r\nif (fl_blocked->fl_start != fl->fl_start)\r\ncontinue;\r\nif (fl_blocked->fl_end != fl->fl_end)\r\ncontinue;\r\nif (fl_blocked->fl_u.nfs_fl.owner->pid != lock->svid)\r\ncontinue;\r\nif (!rpc_cmp_addr(nlm_addr(block->b_host), addr))\r\ncontinue;\r\nif (nfs_compare_fh(NFS_FH(file_inode(fl_blocked->fl_file)) ,fh) != 0)\r\ncontinue;\r\nblock->b_status = nlm_granted;\r\nwake_up(&block->b_wait);\r\nres = nlm_granted;\r\n}\r\nspin_unlock(&nlm_blocked_lock);\r\nreturn res;\r\n}\r\nvoid\r\nnlmclnt_recovery(struct nlm_host *host)\r\n{\r\nstruct task_struct *task;\r\nif (!host->h_reclaiming++) {\r\nnlm_get_host(host);\r\ntask = kthread_run(reclaimer, host, "%s-reclaim", host->h_name);\r\nif (IS_ERR(task))\r\nprintk(KERN_ERR "lockd: unable to spawn reclaimer "\r\n"thread. Locks for %s won't be reclaimed! "\r\n"(%ld)\n", host->h_name, PTR_ERR(task));\r\n}\r\n}\r\nstatic int\r\nreclaimer(void *ptr)\r\n{\r\nstruct nlm_host *host = (struct nlm_host *) ptr;\r\nstruct nlm_wait *block;\r\nstruct nlm_rqst *req;\r\nstruct file_lock *fl, *next;\r\nu32 nsmstate;\r\nstruct net *net = host->net;\r\nreq = kmalloc(sizeof(*req), GFP_KERNEL);\r\nif (!req) {\r\nprintk(KERN_ERR "lockd: reclaimer unable to alloc memory."\r\n" Locks for %s won't be reclaimed!\n",\r\nhost->h_name);\r\nreturn 0;\r\n}\r\nallow_signal(SIGKILL);\r\ndown_write(&host->h_rwsem);\r\nlockd_up(net);\r\ndprintk("lockd: reclaiming locks for host %s\n", host->h_name);\r\nrestart:\r\nnsmstate = host->h_nsmstate;\r\nhost->h_nextrebind = jiffies;\r\nnlm_rebind_host(host);\r\nlist_splice_init(&host->h_granted, &host->h_reclaim);\r\nlist_for_each_entry_safe(fl, next, &host->h_reclaim, fl_u.nfs_fl.list) {\r\nlist_del_init(&fl->fl_u.nfs_fl.list);\r\nif (signalled())\r\ncontinue;\r\nif (nlmclnt_reclaim(host, fl, req) != 0)\r\ncontinue;\r\nlist_add_tail(&fl->fl_u.nfs_fl.list, &host->h_granted);\r\nif (host->h_nsmstate != nsmstate) {\r\ngoto restart;\r\n}\r\n}\r\nhost->h_reclaiming = 0;\r\nup_write(&host->h_rwsem);\r\ndprintk("NLM: done reclaiming locks for host %s\n", host->h_name);\r\nspin_lock(&nlm_blocked_lock);\r\nlist_for_each_entry(block, &nlm_blocked, b_list) {\r\nif (block->b_host == host) {\r\nblock->b_status = nlm_lck_denied_grace_period;\r\nwake_up(&block->b_wait);\r\n}\r\n}\r\nspin_unlock(&nlm_blocked_lock);\r\nnlmclnt_release_host(host);\r\nlockd_down(net);\r\nkfree(req);\r\nreturn 0;\r\n}
