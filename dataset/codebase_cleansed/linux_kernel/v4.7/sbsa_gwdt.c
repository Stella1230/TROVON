static int sbsa_gwdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);\r\nwdd->timeout = timeout;\r\nif (action)\r\nwritel(gwdt->clk * timeout,\r\ngwdt->control_base + SBSA_GWDT_WOR);\r\nelse\r\nwritel(gwdt->clk / 2 * timeout,\r\ngwdt->control_base + SBSA_GWDT_WOR);\r\nreturn 0;\r\n}\r\nstatic unsigned int sbsa_gwdt_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);\r\nu64 timeleft = 0;\r\nif (!action &&\r\n!(readl(gwdt->control_base + SBSA_GWDT_WCS) & SBSA_GWDT_WCS_WS0))\r\ntimeleft += readl(gwdt->control_base + SBSA_GWDT_WOR);\r\ntimeleft += readq(gwdt->control_base + SBSA_GWDT_WCV) -\r\narch_counter_get_cntvct();\r\ndo_div(timeleft, gwdt->clk);\r\nreturn timeleft;\r\n}\r\nstatic int sbsa_gwdt_keepalive(struct watchdog_device *wdd)\r\n{\r\nstruct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);\r\nwritel(0, gwdt->refresh_base + SBSA_GWDT_WRR);\r\nreturn 0;\r\n}\r\nstatic unsigned int sbsa_gwdt_status(struct watchdog_device *wdd)\r\n{\r\nstruct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);\r\nu32 status = readl(gwdt->control_base + SBSA_GWDT_WCS);\r\nreturn (status & SBSA_GWDT_WCS_EN) << WDOG_ACTIVE;\r\n}\r\nstatic int sbsa_gwdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);\r\nwritel(SBSA_GWDT_WCS_EN, gwdt->control_base + SBSA_GWDT_WCS);\r\nreturn 0;\r\n}\r\nstatic int sbsa_gwdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);\r\nwritel(0, gwdt->control_base + SBSA_GWDT_WCS);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sbsa_gwdt_interrupt(int irq, void *dev_id)\r\n{\r\npanic(WATCHDOG_NAME " timeout");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sbsa_gwdt_probe(struct platform_device *pdev)\r\n{\r\nvoid __iomem *rf_base, *cf_base;\r\nstruct device *dev = &pdev->dev;\r\nstruct watchdog_device *wdd;\r\nstruct sbsa_gwdt *gwdt;\r\nstruct resource *res;\r\nint ret, irq;\r\nu32 status;\r\ngwdt = devm_kzalloc(dev, sizeof(*gwdt), GFP_KERNEL);\r\nif (!gwdt)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, gwdt);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncf_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cf_base))\r\nreturn PTR_ERR(cf_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nrf_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(rf_base))\r\nreturn PTR_ERR(rf_base);\r\ngwdt->clk = arch_timer_get_cntfrq();\r\ngwdt->refresh_base = rf_base;\r\ngwdt->control_base = cf_base;\r\nwdd = &gwdt->wdd;\r\nwdd->parent = dev;\r\nwdd->info = &sbsa_gwdt_info;\r\nwdd->ops = &sbsa_gwdt_ops;\r\nwdd->min_timeout = 1;\r\nwdd->max_timeout = U32_MAX / gwdt->clk;\r\nwdd->timeout = DEFAULT_TIMEOUT;\r\nwatchdog_set_drvdata(wdd, gwdt);\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nstatus = readl(cf_base + SBSA_GWDT_WCS);\r\nif (status & SBSA_GWDT_WCS_WS1) {\r\ndev_warn(dev, "System reset by WDT.\n");\r\nwdd->bootstatus |= WDIOF_CARDRESET;\r\n}\r\nif (action) {\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\naction = 0;\r\ndev_warn(dev, "unable to get ws0 interrupt.\n");\r\n} else {\r\nwritel(0, rf_base + SBSA_GWDT_WRR);\r\nif (devm_request_irq(dev, irq, sbsa_gwdt_interrupt, 0,\r\npdev->name, gwdt)) {\r\naction = 0;\r\ndev_warn(dev, "unable to request IRQ %d.\n",\r\nirq);\r\n}\r\n}\r\nif (!action)\r\ndev_warn(dev, "falling back to single stage mode.\n");\r\n}\r\nif (!action)\r\nwdd->max_timeout *= 2;\r\nwatchdog_init_timeout(wdd, timeout, dev);\r\nsbsa_gwdt_set_timeout(wdd, wdd->timeout);\r\nret = watchdog_register_device(wdd);\r\nif (ret)\r\nreturn ret;\r\ndev_info(dev, "Initialized with %ds timeout @ %u Hz, action=%d.%s\n",\r\nwdd->timeout, gwdt->clk, action,\r\nstatus & SBSA_GWDT_WCS_EN ? " [enabled]" : "");\r\nreturn 0;\r\n}\r\nstatic void sbsa_gwdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct sbsa_gwdt *gwdt = platform_get_drvdata(pdev);\r\nsbsa_gwdt_stop(&gwdt->wdd);\r\n}\r\nstatic int sbsa_gwdt_remove(struct platform_device *pdev)\r\n{\r\nstruct sbsa_gwdt *gwdt = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&gwdt->wdd);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused sbsa_gwdt_suspend(struct device *dev)\r\n{\r\nstruct sbsa_gwdt *gwdt = dev_get_drvdata(dev);\r\nif (watchdog_active(&gwdt->wdd))\r\nsbsa_gwdt_stop(&gwdt->wdd);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused sbsa_gwdt_resume(struct device *dev)\r\n{\r\nstruct sbsa_gwdt *gwdt = dev_get_drvdata(dev);\r\nif (watchdog_active(&gwdt->wdd))\r\nsbsa_gwdt_start(&gwdt->wdd);\r\nreturn 0;\r\n}
