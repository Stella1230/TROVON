static void xgbe_default_config(struct xgbe_prv_data *pdata)\r\n{\r\nDBGPR("-->xgbe_default_config\n");\r\npdata->pblx8 = DMA_PBL_X8_ENABLE;\r\npdata->tx_sf_mode = MTL_TSF_ENABLE;\r\npdata->tx_threshold = MTL_TX_THRESHOLD_64;\r\npdata->tx_pbl = DMA_PBL_16;\r\npdata->tx_osp_mode = DMA_OSP_ENABLE;\r\npdata->rx_sf_mode = MTL_RSF_DISABLE;\r\npdata->rx_threshold = MTL_RX_THRESHOLD_64;\r\npdata->rx_pbl = DMA_PBL_16;\r\npdata->pause_autoneg = 1;\r\npdata->tx_pause = 1;\r\npdata->rx_pause = 1;\r\npdata->phy_speed = SPEED_UNKNOWN;\r\npdata->power_down = 0;\r\nDBGPR("<--xgbe_default_config\n");\r\n}\r\nstatic void xgbe_init_all_fptrs(struct xgbe_prv_data *pdata)\r\n{\r\nxgbe_init_function_ptrs_dev(&pdata->hw_if);\r\nxgbe_init_function_ptrs_phy(&pdata->phy_if);\r\nxgbe_init_function_ptrs_desc(&pdata->desc_if);\r\n}\r\nstatic int xgbe_acpi_support(struct xgbe_prv_data *pdata)\r\n{\r\nstruct device *dev = pdata->dev;\r\nu32 property;\r\nint ret;\r\nret = device_property_read_u32(dev, XGBE_ACPI_DMA_FREQ, &property);\r\nif (ret) {\r\ndev_err(dev, "unable to obtain %s property\n",\r\nXGBE_ACPI_DMA_FREQ);\r\nreturn ret;\r\n}\r\npdata->sysclk_rate = property;\r\nret = device_property_read_u32(dev, XGBE_ACPI_PTP_FREQ, &property);\r\nif (ret) {\r\ndev_err(dev, "unable to obtain %s property\n",\r\nXGBE_ACPI_PTP_FREQ);\r\nreturn ret;\r\n}\r\npdata->ptpclk_rate = property;\r\nreturn 0;\r\n}\r\nstatic int xgbe_acpi_support(struct xgbe_prv_data *pdata)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int xgbe_of_support(struct xgbe_prv_data *pdata)\r\n{\r\nstruct device *dev = pdata->dev;\r\npdata->sysclk = devm_clk_get(dev, XGBE_DMA_CLOCK);\r\nif (IS_ERR(pdata->sysclk)) {\r\ndev_err(dev, "dma devm_clk_get failed\n");\r\nreturn PTR_ERR(pdata->sysclk);\r\n}\r\npdata->sysclk_rate = clk_get_rate(pdata->sysclk);\r\npdata->ptpclk = devm_clk_get(dev, XGBE_PTP_CLOCK);\r\nif (IS_ERR(pdata->ptpclk)) {\r\ndev_err(dev, "ptp devm_clk_get failed\n");\r\nreturn PTR_ERR(pdata->ptpclk);\r\n}\r\npdata->ptpclk_rate = clk_get_rate(pdata->ptpclk);\r\nreturn 0;\r\n}\r\nstatic struct platform_device *xgbe_of_get_phy_pdev(struct xgbe_prv_data *pdata)\r\n{\r\nstruct device *dev = pdata->dev;\r\nstruct device_node *phy_node;\r\nstruct platform_device *phy_pdev;\r\nphy_node = of_parse_phandle(dev->of_node, "phy-handle", 0);\r\nif (phy_node) {\r\nphy_pdev = of_find_device_by_node(phy_node);\r\nof_node_put(phy_node);\r\n} else {\r\nget_device(dev);\r\nphy_pdev = pdata->pdev;\r\n}\r\nreturn phy_pdev;\r\n}\r\nstatic int xgbe_of_support(struct xgbe_prv_data *pdata)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic struct platform_device *xgbe_of_get_phy_pdev(struct xgbe_prv_data *pdata)\r\n{\r\nreturn NULL;\r\n}\r\nstatic unsigned int xgbe_resource_count(struct platform_device *pdev,\r\nunsigned int type)\r\n{\r\nunsigned int count;\r\nint i;\r\nfor (i = 0, count = 0; i < pdev->num_resources; i++) {\r\nstruct resource *res = &pdev->resource[i];\r\nif (type == resource_type(res))\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic struct platform_device *xgbe_get_phy_pdev(struct xgbe_prv_data *pdata)\r\n{\r\nstruct platform_device *phy_pdev;\r\nif (pdata->use_acpi) {\r\nget_device(pdata->dev);\r\nphy_pdev = pdata->pdev;\r\n} else {\r\nphy_pdev = xgbe_of_get_phy_pdev(pdata);\r\n}\r\nreturn phy_pdev;\r\n}\r\nstatic int xgbe_probe(struct platform_device *pdev)\r\n{\r\nstruct xgbe_prv_data *pdata;\r\nstruct net_device *netdev;\r\nstruct device *dev = &pdev->dev, *phy_dev;\r\nstruct platform_device *phy_pdev;\r\nstruct resource *res;\r\nconst char *phy_mode;\r\nunsigned int i, phy_memnum, phy_irqnum;\r\nenum dev_dma_attr attr;\r\nint ret;\r\nDBGPR("--> xgbe_probe\n");\r\nnetdev = alloc_etherdev_mq(sizeof(struct xgbe_prv_data),\r\nXGBE_MAX_DMA_CHANNELS);\r\nif (!netdev) {\r\ndev_err(dev, "alloc_etherdev failed\n");\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nSET_NETDEV_DEV(netdev, dev);\r\npdata = netdev_priv(netdev);\r\npdata->netdev = netdev;\r\npdata->pdev = pdev;\r\npdata->adev = ACPI_COMPANION(dev);\r\npdata->dev = dev;\r\nplatform_set_drvdata(pdev, netdev);\r\nspin_lock_init(&pdata->lock);\r\nspin_lock_init(&pdata->xpcs_lock);\r\nmutex_init(&pdata->rss_mutex);\r\nspin_lock_init(&pdata->tstamp_lock);\r\npdata->msg_enable = netif_msg_init(debug, default_msg_level);\r\nset_bit(XGBE_DOWN, &pdata->dev_state);\r\npdata->use_acpi = dev->of_node ? 0 : 1;\r\nphy_pdev = xgbe_get_phy_pdev(pdata);\r\nif (!phy_pdev) {\r\ndev_err(dev, "unable to obtain phy device\n");\r\nret = -EINVAL;\r\ngoto err_phydev;\r\n}\r\nphy_dev = &phy_pdev->dev;\r\nif (pdev == phy_pdev) {\r\nphy_memnum = xgbe_resource_count(pdev, IORESOURCE_MEM) - 3;\r\nphy_irqnum = xgbe_resource_count(pdev, IORESOURCE_IRQ) - 1;\r\n} else {\r\nphy_memnum = 0;\r\nphy_irqnum = 0;\r\n}\r\nBUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);\r\npdata->tx_desc_count = XGBE_TX_DESC_CNT;\r\nif (pdata->tx_desc_count & (pdata->tx_desc_count - 1)) {\r\ndev_err(dev, "tx descriptor count (%d) is not valid\n",\r\npdata->tx_desc_count);\r\nret = -EINVAL;\r\ngoto err_io;\r\n}\r\nBUILD_BUG_ON_NOT_POWER_OF_2(XGBE_RX_DESC_CNT);\r\npdata->rx_desc_count = XGBE_RX_DESC_CNT;\r\nif (pdata->rx_desc_count & (pdata->rx_desc_count - 1)) {\r\ndev_err(dev, "rx descriptor count (%d) is not valid\n",\r\npdata->rx_desc_count);\r\nret = -EINVAL;\r\ngoto err_io;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npdata->xgmac_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pdata->xgmac_regs)) {\r\ndev_err(dev, "xgmac ioremap failed\n");\r\nret = PTR_ERR(pdata->xgmac_regs);\r\ngoto err_io;\r\n}\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(dev, "xgmac_regs = %p\n", pdata->xgmac_regs);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npdata->xpcs_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pdata->xpcs_regs)) {\r\ndev_err(dev, "xpcs ioremap failed\n");\r\nret = PTR_ERR(pdata->xpcs_regs);\r\ngoto err_io;\r\n}\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(dev, "xpcs_regs = %p\n", pdata->xpcs_regs);\r\nres = platform_get_resource(phy_pdev, IORESOURCE_MEM, phy_memnum++);\r\npdata->rxtx_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pdata->rxtx_regs)) {\r\ndev_err(dev, "rxtx ioremap failed\n");\r\nret = PTR_ERR(pdata->rxtx_regs);\r\ngoto err_io;\r\n}\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(dev, "rxtx_regs = %p\n", pdata->rxtx_regs);\r\nres = platform_get_resource(phy_pdev, IORESOURCE_MEM, phy_memnum++);\r\npdata->sir0_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pdata->sir0_regs)) {\r\ndev_err(dev, "sir0 ioremap failed\n");\r\nret = PTR_ERR(pdata->sir0_regs);\r\ngoto err_io;\r\n}\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(dev, "sir0_regs = %p\n", pdata->sir0_regs);\r\nres = platform_get_resource(phy_pdev, IORESOURCE_MEM, phy_memnum++);\r\npdata->sir1_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pdata->sir1_regs)) {\r\ndev_err(dev, "sir1 ioremap failed\n");\r\nret = PTR_ERR(pdata->sir1_regs);\r\ngoto err_io;\r\n}\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(dev, "sir1_regs = %p\n", pdata->sir1_regs);\r\nret = device_property_read_u8_array(dev, XGBE_MAC_ADDR_PROPERTY,\r\npdata->mac_addr,\r\nsizeof(pdata->mac_addr));\r\nif (ret || !is_valid_ether_addr(pdata->mac_addr)) {\r\ndev_err(dev, "invalid %s property\n", XGBE_MAC_ADDR_PROPERTY);\r\nif (!ret)\r\nret = -EINVAL;\r\ngoto err_io;\r\n}\r\nret = device_property_read_string(dev, XGBE_PHY_MODE_PROPERTY,\r\n&phy_mode);\r\nif (ret || strcmp(phy_mode, phy_modes(PHY_INTERFACE_MODE_XGMII))) {\r\ndev_err(dev, "invalid %s property\n", XGBE_PHY_MODE_PROPERTY);\r\nif (!ret)\r\nret = -EINVAL;\r\ngoto err_io;\r\n}\r\npdata->phy_mode = PHY_INTERFACE_MODE_XGMII;\r\nif (device_property_present(dev, XGBE_DMA_IRQS_PROPERTY))\r\npdata->per_channel_irq = 1;\r\nret = device_property_read_u32(phy_dev, XGBE_SPEEDSET_PROPERTY,\r\n&pdata->speed_set);\r\nif (ret) {\r\ndev_err(dev, "invalid %s property\n", XGBE_SPEEDSET_PROPERTY);\r\ngoto err_io;\r\n}\r\nswitch (pdata->speed_set) {\r\ncase XGBE_SPEEDSET_1000_10000:\r\ncase XGBE_SPEEDSET_2500_10000:\r\nbreak;\r\ndefault:\r\ndev_err(dev, "invalid %s property\n", XGBE_SPEEDSET_PROPERTY);\r\nret = -EINVAL;\r\ngoto err_io;\r\n}\r\nif (device_property_present(phy_dev, XGBE_BLWC_PROPERTY)) {\r\nret = device_property_read_u32_array(phy_dev,\r\nXGBE_BLWC_PROPERTY,\r\npdata->serdes_blwc,\r\nXGBE_SPEEDS);\r\nif (ret) {\r\ndev_err(dev, "invalid %s property\n",\r\nXGBE_BLWC_PROPERTY);\r\ngoto err_io;\r\n}\r\n} else {\r\nmemcpy(pdata->serdes_blwc, xgbe_serdes_blwc,\r\nsizeof(pdata->serdes_blwc));\r\n}\r\nif (device_property_present(phy_dev, XGBE_CDR_RATE_PROPERTY)) {\r\nret = device_property_read_u32_array(phy_dev,\r\nXGBE_CDR_RATE_PROPERTY,\r\npdata->serdes_cdr_rate,\r\nXGBE_SPEEDS);\r\nif (ret) {\r\ndev_err(dev, "invalid %s property\n",\r\nXGBE_CDR_RATE_PROPERTY);\r\ngoto err_io;\r\n}\r\n} else {\r\nmemcpy(pdata->serdes_cdr_rate, xgbe_serdes_cdr_rate,\r\nsizeof(pdata->serdes_cdr_rate));\r\n}\r\nif (device_property_present(phy_dev, XGBE_PQ_SKEW_PROPERTY)) {\r\nret = device_property_read_u32_array(phy_dev,\r\nXGBE_PQ_SKEW_PROPERTY,\r\npdata->serdes_pq_skew,\r\nXGBE_SPEEDS);\r\nif (ret) {\r\ndev_err(dev, "invalid %s property\n",\r\nXGBE_PQ_SKEW_PROPERTY);\r\ngoto err_io;\r\n}\r\n} else {\r\nmemcpy(pdata->serdes_pq_skew, xgbe_serdes_pq_skew,\r\nsizeof(pdata->serdes_pq_skew));\r\n}\r\nif (device_property_present(phy_dev, XGBE_TX_AMP_PROPERTY)) {\r\nret = device_property_read_u32_array(phy_dev,\r\nXGBE_TX_AMP_PROPERTY,\r\npdata->serdes_tx_amp,\r\nXGBE_SPEEDS);\r\nif (ret) {\r\ndev_err(dev, "invalid %s property\n",\r\nXGBE_TX_AMP_PROPERTY);\r\ngoto err_io;\r\n}\r\n} else {\r\nmemcpy(pdata->serdes_tx_amp, xgbe_serdes_tx_amp,\r\nsizeof(pdata->serdes_tx_amp));\r\n}\r\nif (device_property_present(phy_dev, XGBE_DFE_CFG_PROPERTY)) {\r\nret = device_property_read_u32_array(phy_dev,\r\nXGBE_DFE_CFG_PROPERTY,\r\npdata->serdes_dfe_tap_cfg,\r\nXGBE_SPEEDS);\r\nif (ret) {\r\ndev_err(dev, "invalid %s property\n",\r\nXGBE_DFE_CFG_PROPERTY);\r\ngoto err_io;\r\n}\r\n} else {\r\nmemcpy(pdata->serdes_dfe_tap_cfg, xgbe_serdes_dfe_tap_cfg,\r\nsizeof(pdata->serdes_dfe_tap_cfg));\r\n}\r\nif (device_property_present(phy_dev, XGBE_DFE_ENA_PROPERTY)) {\r\nret = device_property_read_u32_array(phy_dev,\r\nXGBE_DFE_ENA_PROPERTY,\r\npdata->serdes_dfe_tap_ena,\r\nXGBE_SPEEDS);\r\nif (ret) {\r\ndev_err(dev, "invalid %s property\n",\r\nXGBE_DFE_ENA_PROPERTY);\r\ngoto err_io;\r\n}\r\n} else {\r\nmemcpy(pdata->serdes_dfe_tap_ena, xgbe_serdes_dfe_tap_ena,\r\nsizeof(pdata->serdes_dfe_tap_ena));\r\n}\r\nif (pdata->use_acpi)\r\nret = xgbe_acpi_support(pdata);\r\nelse\r\nret = xgbe_of_support(pdata);\r\nif (ret)\r\ngoto err_io;\r\nattr = device_get_dma_attr(dev);\r\nif (attr == DEV_DMA_NOT_SUPPORTED) {\r\ndev_err(dev, "DMA is not supported");\r\ngoto err_io;\r\n}\r\npdata->coherent = (attr == DEV_DMA_COHERENT);\r\nif (pdata->coherent) {\r\npdata->axdomain = XGBE_DMA_OS_AXDOMAIN;\r\npdata->arcache = XGBE_DMA_OS_ARCACHE;\r\npdata->awcache = XGBE_DMA_OS_AWCACHE;\r\n} else {\r\npdata->axdomain = XGBE_DMA_SYS_AXDOMAIN;\r\npdata->arcache = XGBE_DMA_SYS_ARCACHE;\r\npdata->awcache = XGBE_DMA_SYS_AWCACHE;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "platform_get_irq 0 failed\n");\r\ngoto err_io;\r\n}\r\npdata->dev_irq = ret;\r\nret = platform_get_irq(phy_pdev, phy_irqnum++);\r\nif (ret < 0) {\r\ndev_err(dev, "platform_get_irq phy 0 failed\n");\r\ngoto err_io;\r\n}\r\npdata->an_irq = ret;\r\nnetdev->irq = pdata->dev_irq;\r\nnetdev->base_addr = (unsigned long)pdata->xgmac_regs;\r\nmemcpy(netdev->dev_addr, pdata->mac_addr, netdev->addr_len);\r\nxgbe_init_all_fptrs(pdata);\r\npdata->hw_if.exit(pdata);\r\nxgbe_get_all_hw_features(pdata);\r\nxgbe_default_config(pdata);\r\nret = dma_set_mask_and_coherent(dev,\r\nDMA_BIT_MASK(pdata->hw_feat.dma_width));\r\nif (ret) {\r\ndev_err(dev, "dma_set_mask_and_coherent failed\n");\r\ngoto err_io;\r\n}\r\npdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),\r\npdata->hw_feat.tx_ch_cnt);\r\npdata->tx_q_count = pdata->tx_ring_count;\r\nret = netif_set_real_num_tx_queues(netdev, pdata->tx_ring_count);\r\nif (ret) {\r\ndev_err(dev, "error setting real tx queue count\n");\r\ngoto err_io;\r\n}\r\npdata->rx_ring_count = min_t(unsigned int,\r\nnetif_get_num_default_rss_queues(),\r\npdata->hw_feat.rx_ch_cnt);\r\npdata->rx_q_count = pdata->hw_feat.rx_q_cnt;\r\nret = netif_set_real_num_rx_queues(netdev, pdata->rx_ring_count);\r\nif (ret) {\r\ndev_err(dev, "error setting real rx queue count\n");\r\ngoto err_io;\r\n}\r\nnetdev_rss_key_fill(pdata->rss_key, sizeof(pdata->rss_key));\r\nfor (i = 0; i < XGBE_RSS_MAX_TABLE_SIZE; i++)\r\nXGMAC_SET_BITS(pdata->rss_table[i], MAC_RSSDR, DMCH,\r\ni % pdata->rx_ring_count);\r\nXGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, IP2TE, 1);\r\nXGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, TCP4TE, 1);\r\nXGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, UDP4TE, 1);\r\npdata->phy_if.phy_init(pdata);\r\nnetdev->netdev_ops = xgbe_get_netdev_ops();\r\nnetdev->ethtool_ops = xgbe_get_ethtool_ops();\r\n#ifdef CONFIG_AMD_XGBE_DCB\r\nnetdev->dcbnl_ops = xgbe_get_dcbnl_ops();\r\n#endif\r\nnetdev->hw_features = NETIF_F_SG |\r\nNETIF_F_IP_CSUM |\r\nNETIF_F_IPV6_CSUM |\r\nNETIF_F_RXCSUM |\r\nNETIF_F_TSO |\r\nNETIF_F_TSO6 |\r\nNETIF_F_GRO |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_FILTER;\r\nif (pdata->hw_feat.rss)\r\nnetdev->hw_features |= NETIF_F_RXHASH;\r\nnetdev->vlan_features |= NETIF_F_SG |\r\nNETIF_F_IP_CSUM |\r\nNETIF_F_IPV6_CSUM |\r\nNETIF_F_TSO |\r\nNETIF_F_TSO6;\r\nnetdev->features |= netdev->hw_features;\r\npdata->netdev_features = netdev->features;\r\nnetdev->priv_flags |= IFF_UNICAST_FLT;\r\nnetdev->watchdog_timeo = 0;\r\nxgbe_init_rx_coalesce(pdata);\r\nxgbe_init_tx_coalesce(pdata);\r\nnetif_carrier_off(netdev);\r\nret = register_netdev(netdev);\r\nif (ret) {\r\ndev_err(dev, "net device registration failed\n");\r\ngoto err_io;\r\n}\r\nsnprintf(pdata->an_name, sizeof(pdata->an_name) - 1, "%s-pcs",\r\nnetdev_name(netdev));\r\npdata->dev_workqueue =\r\ncreate_singlethread_workqueue(netdev_name(netdev));\r\nif (!pdata->dev_workqueue) {\r\nnetdev_err(netdev, "device workqueue creation failed\n");\r\nret = -ENOMEM;\r\ngoto err_netdev;\r\n}\r\npdata->an_workqueue =\r\ncreate_singlethread_workqueue(pdata->an_name);\r\nif (!pdata->an_workqueue) {\r\nnetdev_err(netdev, "phy workqueue creation failed\n");\r\nret = -ENOMEM;\r\ngoto err_wq;\r\n}\r\nxgbe_ptp_register(pdata);\r\nxgbe_debugfs_init(pdata);\r\nplatform_device_put(phy_pdev);\r\nnetdev_notice(netdev, "net device enabled\n");\r\nDBGPR("<-- xgbe_probe\n");\r\nreturn 0;\r\nerr_wq:\r\ndestroy_workqueue(pdata->dev_workqueue);\r\nerr_netdev:\r\nunregister_netdev(netdev);\r\nerr_io:\r\nplatform_device_put(phy_pdev);\r\nerr_phydev:\r\nfree_netdev(netdev);\r\nerr_alloc:\r\ndev_notice(dev, "net device not enabled\n");\r\nreturn ret;\r\n}\r\nstatic int xgbe_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *netdev = platform_get_drvdata(pdev);\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nDBGPR("-->xgbe_remove\n");\r\nxgbe_debugfs_exit(pdata);\r\nxgbe_ptp_unregister(pdata);\r\nflush_workqueue(pdata->an_workqueue);\r\ndestroy_workqueue(pdata->an_workqueue);\r\nflush_workqueue(pdata->dev_workqueue);\r\ndestroy_workqueue(pdata->dev_workqueue);\r\nunregister_netdev(netdev);\r\nfree_netdev(netdev);\r\nDBGPR("<--xgbe_remove\n");\r\nreturn 0;\r\n}\r\nstatic int xgbe_suspend(struct device *dev)\r\n{\r\nstruct net_device *netdev = dev_get_drvdata(dev);\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nint ret = 0;\r\nDBGPR("-->xgbe_suspend\n");\r\nif (netif_running(netdev))\r\nret = xgbe_powerdown(netdev, XGMAC_DRIVER_CONTEXT);\r\npdata->lpm_ctrl = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\r\npdata->lpm_ctrl |= MDIO_CTRL1_LPOWER;\r\nXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\r\nDBGPR("<--xgbe_suspend\n");\r\nreturn ret;\r\n}\r\nstatic int xgbe_resume(struct device *dev)\r\n{\r\nstruct net_device *netdev = dev_get_drvdata(dev);\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nint ret = 0;\r\nDBGPR("-->xgbe_resume\n");\r\npdata->lpm_ctrl &= ~MDIO_CTRL1_LPOWER;\r\nXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\r\nif (netif_running(netdev))\r\nret = xgbe_powerup(netdev, XGMAC_DRIVER_CONTEXT);\r\nDBGPR("<--xgbe_resume\n");\r\nreturn ret;\r\n}
