static int palmas_disable_auto_conversion(struct palmas_gpadc *adc)\r\n{\r\nint ret;\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_CTRL1,\r\nPALMAS_GPADC_CTRL1_GPADC_FORCE,\r\nPALMAS_GPADC_CTRL1_GPADC_FORCE);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "GPADC_CTRL1 update failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_AUTO_CTRL,\r\nPALMAS_GPADC_AUTO_CTRL_SHUTDOWN_CONV1 |\r\nPALMAS_GPADC_AUTO_CTRL_SHUTDOWN_CONV0,\r\n0);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "AUTO_CTRL update failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nudelay(100);\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_CTRL1,\r\nPALMAS_GPADC_CTRL1_GPADC_FORCE, 0);\r\nif (ret < 0)\r\ndev_err(adc->dev, "GPADC_CTRL1 update failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t palmas_gpadc_irq(int irq, void *data)\r\n{\r\nstruct palmas_gpadc *adc = data;\r\ncomplete(&adc->conv_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t palmas_gpadc_irq_auto(int irq, void *data)\r\n{\r\nstruct palmas_gpadc *adc = data;\r\ndev_dbg(adc->dev, "Threshold interrupt %d occurs\n", irq);\r\npalmas_disable_auto_conversion(adc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int palmas_gpadc_start_mask_interrupt(struct palmas_gpadc *adc,\r\nbool mask)\r\n{\r\nint ret;\r\nif (!mask)\r\nret = palmas_update_bits(adc->palmas, PALMAS_INTERRUPT_BASE,\r\nPALMAS_INT3_MASK,\r\nPALMAS_INT3_MASK_GPADC_EOC_SW, 0);\r\nelse\r\nret = palmas_update_bits(adc->palmas, PALMAS_INTERRUPT_BASE,\r\nPALMAS_INT3_MASK,\r\nPALMAS_INT3_MASK_GPADC_EOC_SW,\r\nPALMAS_INT3_MASK_GPADC_EOC_SW);\r\nif (ret < 0)\r\ndev_err(adc->dev, "GPADC INT MASK update failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_gpadc_enable(struct palmas_gpadc *adc, int adc_chan,\r\nint enable)\r\n{\r\nunsigned int mask, val;\r\nint ret;\r\nif (enable) {\r\nval = (adc->extended_delay\r\n<< PALMAS_GPADC_RT_CTRL_EXTEND_DELAY_SHIFT);\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_RT_CTRL,\r\nPALMAS_GPADC_RT_CTRL_EXTEND_DELAY, val);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "RT_CTRL update failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nmask = (PALMAS_GPADC_CTRL1_CURRENT_SRC_CH0_MASK |\r\nPALMAS_GPADC_CTRL1_CURRENT_SRC_CH3_MASK |\r\nPALMAS_GPADC_CTRL1_GPADC_FORCE);\r\nval = (adc->ch0_current\r\n<< PALMAS_GPADC_CTRL1_CURRENT_SRC_CH0_SHIFT);\r\nval |= (adc->ch3_current\r\n<< PALMAS_GPADC_CTRL1_CURRENT_SRC_CH3_SHIFT);\r\nval |= PALMAS_GPADC_CTRL1_GPADC_FORCE;\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_CTRL1, mask, val);\r\nif (ret < 0) {\r\ndev_err(adc->dev,\r\n"Failed to update current setting: %d\n", ret);\r\nreturn ret;\r\n}\r\nmask = (PALMAS_GPADC_SW_SELECT_SW_CONV0_SEL_MASK |\r\nPALMAS_GPADC_SW_SELECT_SW_CONV_EN);\r\nval = (adc_chan | PALMAS_GPADC_SW_SELECT_SW_CONV_EN);\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_SW_SELECT, mask, val);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "SW_SELECT update failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\nret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_SW_SELECT, 0);\r\nif (ret < 0)\r\ndev_err(adc->dev, "SW_SELECT write failed: %d\n", ret);\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_CTRL1,\r\nPALMAS_GPADC_CTRL1_GPADC_FORCE, 0);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "CTRL1 update failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int palmas_gpadc_read_prepare(struct palmas_gpadc *adc, int adc_chan)\r\n{\r\nint ret;\r\nret = palmas_gpadc_enable(adc, adc_chan, true);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn palmas_gpadc_start_mask_interrupt(adc, 0);\r\n}\r\nstatic void palmas_gpadc_read_done(struct palmas_gpadc *adc, int adc_chan)\r\n{\r\npalmas_gpadc_start_mask_interrupt(adc, 1);\r\npalmas_gpadc_enable(adc, adc_chan, false);\r\n}\r\nstatic int palmas_gpadc_calibrate(struct palmas_gpadc *adc, int adc_chan)\r\n{\r\nint k;\r\nint d1;\r\nint d2;\r\nint ret;\r\nint gain;\r\nint x1 = adc->adc_info[adc_chan].x1;\r\nint x2 = adc->adc_info[adc_chan].x2;\r\nint v1 = adc->adc_info[adc_chan].v1;\r\nint v2 = adc->adc_info[adc_chan].v2;\r\nret = palmas_read(adc->palmas, PALMAS_TRIM_GPADC_BASE,\r\nadc->adc_info[adc_chan].trim1_reg, &d1);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "TRIM read failed: %d\n", ret);\r\ngoto scrub;\r\n}\r\nret = palmas_read(adc->palmas, PALMAS_TRIM_GPADC_BASE,\r\nadc->adc_info[adc_chan].trim2_reg, &d2);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "TRIM read failed: %d\n", ret);\r\ngoto scrub;\r\n}\r\nk = (1000 + (1000 * (d2 - d1)) / (x2 - x1));\r\ngain = ((v2 - v1) * 1000) / (x2 - x1);\r\nadc->adc_info[adc_chan].gain_error = k;\r\nadc->adc_info[adc_chan].gain = gain;\r\nadc->adc_info[adc_chan].offset = (d1 * 1000) - ((k - 1000) * x1);\r\nscrub:\r\nreturn ret;\r\n}\r\nstatic int palmas_gpadc_start_conversion(struct palmas_gpadc *adc, int adc_chan)\r\n{\r\nunsigned int val;\r\nint ret;\r\ninit_completion(&adc->conv_completion);\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_SW_SELECT,\r\nPALMAS_GPADC_SW_SELECT_SW_START_CONV0,\r\nPALMAS_GPADC_SW_SELECT_SW_START_CONV0);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "SELECT_SW_START write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = wait_for_completion_timeout(&adc->conv_completion,\r\nPALMAS_ADC_CONVERSION_TIMEOUT);\r\nif (ret == 0) {\r\ndev_err(adc->dev, "conversion not completed\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = palmas_bulk_read(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_SW_CONV0_LSB, &val, 2);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "SW_CONV0_LSB read failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = val & 0xFFF;\r\nreturn ret;\r\n}\r\nstatic int palmas_gpadc_get_calibrated_code(struct palmas_gpadc *adc,\r\nint adc_chan, int val)\r\n{\r\nif (!adc->adc_info[adc_chan].is_uncalibrated)\r\nval = (val*1000 - adc->adc_info[adc_chan].offset) /\r\nadc->adc_info[adc_chan].gain_error;\r\nif (val < 0) {\r\ndev_err(adc->dev, "Mismatch with calibration\n");\r\nreturn 0;\r\n}\r\nval = (val * adc->adc_info[adc_chan].gain) / 1000;\r\nreturn val;\r\n}\r\nstatic int palmas_gpadc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long mask)\r\n{\r\nstruct palmas_gpadc *adc = iio_priv(indio_dev);\r\nint adc_chan = chan->channel;\r\nint ret = 0;\r\nif (adc_chan > PALMAS_ADC_CH_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nret = palmas_gpadc_read_prepare(adc, adc_chan);\r\nif (ret < 0)\r\ngoto out;\r\nret = palmas_gpadc_start_conversion(adc, adc_chan);\r\nif (ret < 0) {\r\ndev_err(adc->dev,\r\n"ADC start conversion failed\n");\r\ngoto out;\r\n}\r\nif (mask == IIO_CHAN_INFO_PROCESSED)\r\nret = palmas_gpadc_get_calibrated_code(\r\nadc, adc_chan, ret);\r\n*val = ret;\r\nret = IIO_VAL_INT;\r\ngoto out;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\nout:\r\npalmas_gpadc_read_done(adc, adc_chan);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int palmas_gpadc_get_adc_dt_data(struct platform_device *pdev,\r\nstruct palmas_gpadc_platform_data **gpadc_pdata)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct palmas_gpadc_platform_data *gp_data;\r\nint ret;\r\nu32 pval;\r\ngp_data = devm_kzalloc(&pdev->dev, sizeof(*gp_data), GFP_KERNEL);\r\nif (!gp_data)\r\nreturn -ENOMEM;\r\nret = of_property_read_u32(np, "ti,channel0-current-microamp", &pval);\r\nif (!ret)\r\ngp_data->ch0_current = pval;\r\nret = of_property_read_u32(np, "ti,channel3-current-microamp", &pval);\r\nif (!ret)\r\ngp_data->ch3_current = pval;\r\ngp_data->extended_delay = of_property_read_bool(np,\r\n"ti,enable-extended-delay");\r\n*gpadc_pdata = gp_data;\r\nreturn 0;\r\n}\r\nstatic int palmas_gpadc_probe(struct platform_device *pdev)\r\n{\r\nstruct palmas_gpadc *adc;\r\nstruct palmas_platform_data *pdata;\r\nstruct palmas_gpadc_platform_data *gpadc_pdata = NULL;\r\nstruct iio_dev *indio_dev;\r\nint ret, i;\r\npdata = dev_get_platdata(pdev->dev.parent);\r\nif (pdata && pdata->gpadc_pdata)\r\ngpadc_pdata = pdata->gpadc_pdata;\r\nif (!gpadc_pdata && pdev->dev.of_node) {\r\nret = palmas_gpadc_get_adc_dt_data(pdev, &gpadc_pdata);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!gpadc_pdata)\r\nreturn -EINVAL;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "iio_device_alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nadc = iio_priv(indio_dev);\r\nadc->dev = &pdev->dev;\r\nadc->palmas = dev_get_drvdata(pdev->dev.parent);\r\nadc->adc_info = palmas_gpadc_info;\r\ninit_completion(&adc->conv_completion);\r\ndev_set_drvdata(&pdev->dev, indio_dev);\r\nadc->auto_conversion_period = gpadc_pdata->auto_conversion_period_ms;\r\nadc->irq = palmas_irq_get_virq(adc->palmas, PALMAS_GPADC_EOC_SW_IRQ);\r\nif (adc->irq < 0) {\r\ndev_err(adc->dev,\r\n"get virq failed: %d\n", adc->irq);\r\nret = adc->irq;\r\ngoto out;\r\n}\r\nret = request_threaded_irq(adc->irq, NULL,\r\npalmas_gpadc_irq,\r\nIRQF_ONESHOT, dev_name(adc->dev),\r\nadc);\r\nif (ret < 0) {\r\ndev_err(adc->dev,\r\n"request irq %d failed: %d\n", adc->irq, ret);\r\ngoto out;\r\n}\r\nif (gpadc_pdata->adc_wakeup1_data) {\r\nmemcpy(&adc->wakeup1_data, gpadc_pdata->adc_wakeup1_data,\r\nsizeof(adc->wakeup1_data));\r\nadc->wakeup1_enable = true;\r\nadc->irq_auto_0 = platform_get_irq(pdev, 1);\r\nret = request_threaded_irq(adc->irq_auto_0, NULL,\r\npalmas_gpadc_irq_auto,\r\nIRQF_ONESHOT,\r\n"palmas-adc-auto-0", adc);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "request auto0 irq %d failed: %d\n",\r\nadc->irq_auto_0, ret);\r\ngoto out_irq_free;\r\n}\r\n}\r\nif (gpadc_pdata->adc_wakeup2_data) {\r\nmemcpy(&adc->wakeup2_data, gpadc_pdata->adc_wakeup2_data,\r\nsizeof(adc->wakeup2_data));\r\nadc->wakeup2_enable = true;\r\nadc->irq_auto_1 = platform_get_irq(pdev, 2);\r\nret = request_threaded_irq(adc->irq_auto_1, NULL,\r\npalmas_gpadc_irq_auto,\r\nIRQF_ONESHOT,\r\n"palmas-adc-auto-1", adc);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "request auto1 irq %d failed: %d\n",\r\nadc->irq_auto_1, ret);\r\ngoto out_irq_auto0_free;\r\n}\r\n}\r\nif (gpadc_pdata->ch0_current <= 1)\r\nadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_0;\r\nelse if (gpadc_pdata->ch0_current <= 5)\r\nadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_5;\r\nelse if (gpadc_pdata->ch0_current <= 15)\r\nadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_15;\r\nelse\r\nadc->ch0_current = PALMAS_ADC_CH0_CURRENT_SRC_20;\r\nif (gpadc_pdata->ch3_current <= 1)\r\nadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_0;\r\nelse if (gpadc_pdata->ch3_current <= 10)\r\nadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_10;\r\nelse if (gpadc_pdata->ch3_current <= 400)\r\nadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_400;\r\nelse\r\nadc->ch3_current = PALMAS_ADC_CH3_CURRENT_SRC_800;\r\nadc->extended_delay = gpadc_pdata->extended_delay;\r\nindio_dev->name = MOD_NAME;\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->info = &palmas_gpadc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = palmas_gpadc_iio_channel;\r\nindio_dev->num_channels = ARRAY_SIZE(palmas_gpadc_iio_channel);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "iio_device_register() failed: %d\n", ret);\r\ngoto out_irq_auto1_free;\r\n}\r\ndevice_set_wakeup_capable(&pdev->dev, 1);\r\nfor (i = 0; i < PALMAS_ADC_CH_MAX; i++) {\r\nif (!(adc->adc_info[i].is_uncalibrated))\r\npalmas_gpadc_calibrate(adc, i);\r\n}\r\nif (adc->wakeup1_enable || adc->wakeup2_enable)\r\ndevice_wakeup_enable(&pdev->dev);\r\nreturn 0;\r\nout_irq_auto1_free:\r\nif (gpadc_pdata->adc_wakeup2_data)\r\nfree_irq(adc->irq_auto_1, adc);\r\nout_irq_auto0_free:\r\nif (gpadc_pdata->adc_wakeup1_data)\r\nfree_irq(adc->irq_auto_0, adc);\r\nout_irq_free:\r\nfree_irq(adc->irq, adc);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int palmas_gpadc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(&pdev->dev);\r\nstruct palmas_gpadc *adc = iio_priv(indio_dev);\r\nif (adc->wakeup1_enable || adc->wakeup2_enable)\r\ndevice_wakeup_disable(&pdev->dev);\r\niio_device_unregister(indio_dev);\r\nfree_irq(adc->irq, adc);\r\nif (adc->wakeup1_enable)\r\nfree_irq(adc->irq_auto_0, adc);\r\nif (adc->wakeup2_enable)\r\nfree_irq(adc->irq_auto_1, adc);\r\nreturn 0;\r\n}\r\nstatic int palmas_adc_wakeup_configure(struct palmas_gpadc *adc)\r\n{\r\nint adc_period, conv;\r\nint i;\r\nint ch0 = 0, ch1 = 0;\r\nint thres;\r\nint ret;\r\nadc_period = adc->auto_conversion_period;\r\nfor (i = 0; i < 16; ++i) {\r\nif (((1000 * (1 << i)) / 32) < adc_period)\r\ncontinue;\r\n}\r\nif (i > 0)\r\ni--;\r\nadc_period = i;\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_AUTO_CTRL,\r\nPALMAS_GPADC_AUTO_CTRL_COUNTER_CONV_MASK,\r\nadc_period);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "AUTO_CTRL write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nconv = 0;\r\nif (adc->wakeup1_enable) {\r\nint polarity;\r\nch0 = adc->wakeup1_data.adc_channel_number;\r\nconv |= PALMAS_GPADC_AUTO_CTRL_AUTO_CONV0_EN;\r\nif (adc->wakeup1_data.adc_high_threshold > 0) {\r\nthres = adc->wakeup1_data.adc_high_threshold;\r\npolarity = 0;\r\n} else {\r\nthres = adc->wakeup1_data.adc_low_threshold;\r\npolarity = PALMAS_GPADC_THRES_CONV0_MSB_THRES_CONV0_POL;\r\n}\r\nret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_THRES_CONV0_LSB, thres & 0xFF);\r\nif (ret < 0) {\r\ndev_err(adc->dev,\r\n"THRES_CONV0_LSB write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_THRES_CONV0_MSB,\r\n((thres >> 8) & 0xF) | polarity);\r\nif (ret < 0) {\r\ndev_err(adc->dev,\r\n"THRES_CONV0_MSB write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (adc->wakeup2_enable) {\r\nint polarity;\r\nch1 = adc->wakeup2_data.adc_channel_number;\r\nconv |= PALMAS_GPADC_AUTO_CTRL_AUTO_CONV1_EN;\r\nif (adc->wakeup2_data.adc_high_threshold > 0) {\r\nthres = adc->wakeup2_data.adc_high_threshold;\r\npolarity = 0;\r\n} else {\r\nthres = adc->wakeup2_data.adc_low_threshold;\r\npolarity = PALMAS_GPADC_THRES_CONV1_MSB_THRES_CONV1_POL;\r\n}\r\nret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_THRES_CONV1_LSB, thres & 0xFF);\r\nif (ret < 0) {\r\ndev_err(adc->dev,\r\n"THRES_CONV1_LSB write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_THRES_CONV1_MSB,\r\n((thres >> 8) & 0xF) | polarity);\r\nif (ret < 0) {\r\ndev_err(adc->dev,\r\n"THRES_CONV1_MSB write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_AUTO_SELECT, (ch1 << 4) | ch0);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "AUTO_SELECT write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = palmas_update_bits(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_AUTO_CTRL,\r\nPALMAS_GPADC_AUTO_CTRL_AUTO_CONV1_EN |\r\nPALMAS_GPADC_AUTO_CTRL_AUTO_CONV0_EN, conv);\r\nif (ret < 0)\r\ndev_err(adc->dev, "AUTO_CTRL write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_adc_wakeup_reset(struct palmas_gpadc *adc)\r\n{\r\nint ret;\r\nret = palmas_write(adc->palmas, PALMAS_GPADC_BASE,\r\nPALMAS_GPADC_AUTO_SELECT, 0);\r\nif (ret < 0) {\r\ndev_err(adc->dev, "AUTO_SELECT write failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = palmas_disable_auto_conversion(adc);\r\nif (ret < 0)\r\ndev_err(adc->dev, "Disable auto conversion failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int palmas_gpadc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct palmas_gpadc *adc = iio_priv(indio_dev);\r\nint wakeup = adc->wakeup1_enable || adc->wakeup2_enable;\r\nint ret;\r\nif (!device_may_wakeup(dev) || !wakeup)\r\nreturn 0;\r\nret = palmas_adc_wakeup_configure(adc);\r\nif (ret < 0)\r\nreturn ret;\r\nif (adc->wakeup1_enable)\r\nenable_irq_wake(adc->irq_auto_0);\r\nif (adc->wakeup2_enable)\r\nenable_irq_wake(adc->irq_auto_1);\r\nreturn 0;\r\n}\r\nstatic int palmas_gpadc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct palmas_gpadc *adc = iio_priv(indio_dev);\r\nint wakeup = adc->wakeup1_enable || adc->wakeup2_enable;\r\nint ret;\r\nif (!device_may_wakeup(dev) || !wakeup)\r\nreturn 0;\r\nret = palmas_adc_wakeup_reset(adc);\r\nif (ret < 0)\r\nreturn ret;\r\nif (adc->wakeup1_enable)\r\ndisable_irq_wake(adc->irq_auto_0);\r\nif (adc->wakeup2_enable)\r\ndisable_irq_wake(adc->irq_auto_1);\r\nreturn 0;\r\n}\r\nstatic int __init palmas_gpadc_init(void)\r\n{\r\nreturn platform_driver_register(&palmas_gpadc_driver);\r\n}\r\nstatic void __exit palmas_gpadc_exit(void)\r\n{\r\nplatform_driver_unregister(&palmas_gpadc_driver);\r\n}
