static struct pci_dev *__xen_pcibk_get_pci_dev(struct xen_pcibk_device *pdev,\r\nunsigned int domain,\r\nunsigned int bus,\r\nunsigned int devfn)\r\n{\r\nstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\r\nstruct pci_dev_entry *dev_entry;\r\nstruct pci_dev *dev = NULL;\r\nmutex_lock(&dev_data->lock);\r\nlist_for_each_entry(dev_entry, &dev_data->dev_list, list) {\r\nif (domain == (unsigned int)pci_domain_nr(dev_entry->dev->bus)\r\n&& bus == (unsigned int)dev_entry->dev->bus->number\r\n&& devfn == dev_entry->dev->devfn) {\r\ndev = dev_entry->dev;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dev_data->lock);\r\nreturn dev;\r\n}\r\nstatic int __xen_pcibk_add_pci_dev(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev,\r\nint devid, publish_pci_dev_cb publish_cb)\r\n{\r\nstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\r\nstruct pci_dev_entry *dev_entry;\r\nunsigned int domain, bus, devfn;\r\nint err;\r\ndev_entry = kmalloc(sizeof(*dev_entry), GFP_KERNEL);\r\nif (!dev_entry)\r\nreturn -ENOMEM;\r\ndev_entry->dev = dev;\r\nmutex_lock(&dev_data->lock);\r\nlist_add_tail(&dev_entry->list, &dev_data->dev_list);\r\nmutex_unlock(&dev_data->lock);\r\ndomain = (unsigned int)pci_domain_nr(dev->bus);\r\nbus = (unsigned int)dev->bus->number;\r\ndevfn = dev->devfn;\r\nerr = publish_cb(pdev, domain, bus, devfn, devid);\r\nreturn err;\r\n}\r\nstatic void __xen_pcibk_release_pci_dev(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev, bool lock)\r\n{\r\nstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\r\nstruct pci_dev_entry *dev_entry, *t;\r\nstruct pci_dev *found_dev = NULL;\r\nmutex_lock(&dev_data->lock);\r\nlist_for_each_entry_safe(dev_entry, t, &dev_data->dev_list, list) {\r\nif (dev_entry->dev == dev) {\r\nlist_del(&dev_entry->list);\r\nfound_dev = dev_entry->dev;\r\nkfree(dev_entry);\r\n}\r\n}\r\nmutex_unlock(&dev_data->lock);\r\nif (found_dev) {\r\nif (lock)\r\ndevice_lock(&found_dev->dev);\r\npcistub_put_pci_dev(found_dev);\r\nif (lock)\r\ndevice_unlock(&found_dev->dev);\r\n}\r\n}\r\nstatic int __xen_pcibk_init_devices(struct xen_pcibk_device *pdev)\r\n{\r\nstruct passthrough_dev_data *dev_data;\r\ndev_data = kmalloc(sizeof(*dev_data), GFP_KERNEL);\r\nif (!dev_data)\r\nreturn -ENOMEM;\r\nmutex_init(&dev_data->lock);\r\nINIT_LIST_HEAD(&dev_data->dev_list);\r\npdev->pci_dev_data = dev_data;\r\nreturn 0;\r\n}\r\nstatic int __xen_pcibk_publish_pci_roots(struct xen_pcibk_device *pdev,\r\npublish_pci_root_cb publish_root_cb)\r\n{\r\nint err = 0;\r\nstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\r\nstruct pci_dev_entry *dev_entry, *e;\r\nstruct pci_dev *dev;\r\nint found;\r\nunsigned int domain, bus;\r\nmutex_lock(&dev_data->lock);\r\nlist_for_each_entry(dev_entry, &dev_data->dev_list, list) {\r\nfound = 0;\r\ndev = dev_entry->dev->bus->self;\r\nfor (; !found && dev != NULL; dev = dev->bus->self) {\r\nlist_for_each_entry(e, &dev_data->dev_list, list) {\r\nif (dev == e->dev) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\ndomain = (unsigned int)pci_domain_nr(dev_entry->dev->bus);\r\nbus = (unsigned int)dev_entry->dev->bus->number;\r\nif (!found) {\r\nerr = publish_root_cb(pdev, domain, bus);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dev_data->lock);\r\nreturn err;\r\n}\r\nstatic void __xen_pcibk_release_devices(struct xen_pcibk_device *pdev)\r\n{\r\nstruct passthrough_dev_data *dev_data = pdev->pci_dev_data;\r\nstruct pci_dev_entry *dev_entry, *t;\r\nlist_for_each_entry_safe(dev_entry, t, &dev_data->dev_list, list) {\r\nstruct pci_dev *dev = dev_entry->dev;\r\nlist_del(&dev_entry->list);\r\ndevice_lock(&dev->dev);\r\npcistub_put_pci_dev(dev);\r\ndevice_unlock(&dev->dev);\r\nkfree(dev_entry);\r\n}\r\nkfree(dev_data);\r\npdev->pci_dev_data = NULL;\r\n}\r\nstatic int __xen_pcibk_get_pcifront_dev(struct pci_dev *pcidev,\r\nstruct xen_pcibk_device *pdev,\r\nunsigned int *domain, unsigned int *bus,\r\nunsigned int *devfn)\r\n{\r\n*domain = pci_domain_nr(pcidev->bus);\r\n*bus = pcidev->bus->number;\r\n*devfn = pcidev->devfn;\r\nreturn 1;\r\n}
