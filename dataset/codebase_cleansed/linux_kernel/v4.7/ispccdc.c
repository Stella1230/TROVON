static void ccdc_print_status(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\ndev_dbg(isp->dev, "-------------CCDC Register dump-------------\n");\r\nCCDC_PRINT_REGISTER(isp, PCR);\r\nCCDC_PRINT_REGISTER(isp, SYN_MODE);\r\nCCDC_PRINT_REGISTER(isp, HD_VD_WID);\r\nCCDC_PRINT_REGISTER(isp, PIX_LINES);\r\nCCDC_PRINT_REGISTER(isp, HORZ_INFO);\r\nCCDC_PRINT_REGISTER(isp, VERT_START);\r\nCCDC_PRINT_REGISTER(isp, VERT_LINES);\r\nCCDC_PRINT_REGISTER(isp, CULLING);\r\nCCDC_PRINT_REGISTER(isp, HSIZE_OFF);\r\nCCDC_PRINT_REGISTER(isp, SDOFST);\r\nCCDC_PRINT_REGISTER(isp, SDR_ADDR);\r\nCCDC_PRINT_REGISTER(isp, CLAMP);\r\nCCDC_PRINT_REGISTER(isp, DCSUB);\r\nCCDC_PRINT_REGISTER(isp, COLPTN);\r\nCCDC_PRINT_REGISTER(isp, BLKCMP);\r\nCCDC_PRINT_REGISTER(isp, FPC);\r\nCCDC_PRINT_REGISTER(isp, FPC_ADDR);\r\nCCDC_PRINT_REGISTER(isp, VDINT);\r\nCCDC_PRINT_REGISTER(isp, ALAW);\r\nCCDC_PRINT_REGISTER(isp, REC656IF);\r\nCCDC_PRINT_REGISTER(isp, CFG);\r\nCCDC_PRINT_REGISTER(isp, FMTCFG);\r\nCCDC_PRINT_REGISTER(isp, FMT_HORZ);\r\nCCDC_PRINT_REGISTER(isp, FMT_VERT);\r\nCCDC_PRINT_REGISTER(isp, PRGEVEN0);\r\nCCDC_PRINT_REGISTER(isp, PRGEVEN1);\r\nCCDC_PRINT_REGISTER(isp, PRGODD0);\r\nCCDC_PRINT_REGISTER(isp, PRGODD1);\r\nCCDC_PRINT_REGISTER(isp, VP_OUT);\r\nCCDC_PRINT_REGISTER(isp, LSC_CONFIG);\r\nCCDC_PRINT_REGISTER(isp, LSC_INITIAL);\r\nCCDC_PRINT_REGISTER(isp, LSC_TABLE_BASE);\r\nCCDC_PRINT_REGISTER(isp, LSC_TABLE_OFFSET);\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nint omap3isp_ccdc_busy(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nreturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR) &\r\nISPCCDC_PCR_BUSY;\r\n}\r\nstatic int ccdc_lsc_validate_config(struct isp_ccdc_device *ccdc,\r\nstruct omap3isp_ccdc_lsc_config *lsc_cfg)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nstruct v4l2_mbus_framefmt *format;\r\nunsigned int paxel_width, paxel_height;\r\nunsigned int paxel_shift_x, paxel_shift_y;\r\nunsigned int min_width, min_height, min_size;\r\nunsigned int input_width, input_height;\r\npaxel_shift_x = lsc_cfg->gain_mode_m;\r\npaxel_shift_y = lsc_cfg->gain_mode_n;\r\nif ((paxel_shift_x < 2) || (paxel_shift_x > 6) ||\r\n(paxel_shift_y < 2) || (paxel_shift_y > 6)) {\r\ndev_dbg(isp->dev, "CCDC: LSC: Invalid paxel size\n");\r\nreturn -EINVAL;\r\n}\r\nif (lsc_cfg->offset & 3) {\r\ndev_dbg(isp->dev, "CCDC: LSC: Offset must be a multiple of "\r\n"4\n");\r\nreturn -EINVAL;\r\n}\r\nif ((lsc_cfg->initial_x & 1) || (lsc_cfg->initial_y & 1)) {\r\ndev_dbg(isp->dev, "CCDC: LSC: initial_x and y must be even\n");\r\nreturn -EINVAL;\r\n}\r\nformat = __ccdc_get_format(ccdc, NULL, CCDC_PAD_SINK,\r\nV4L2_SUBDEV_FORMAT_ACTIVE);\r\ninput_width = format->width;\r\ninput_height = format->height;\r\npaxel_width = 1 << paxel_shift_x;\r\nmin_width = ((input_width + lsc_cfg->initial_x + paxel_width - 1)\r\n>> paxel_shift_x) + 1;\r\npaxel_height = 1 << paxel_shift_y;\r\nmin_height = ((input_height + lsc_cfg->initial_y + paxel_height - 1)\r\n>> paxel_shift_y) + 1;\r\nmin_size = 4 * min_width * min_height;\r\nif (min_size > lsc_cfg->size) {\r\ndev_dbg(isp->dev, "CCDC: LSC: too small table\n");\r\nreturn -EINVAL;\r\n}\r\nif (lsc_cfg->offset < (min_width * 4)) {\r\ndev_dbg(isp->dev, "CCDC: LSC: Offset is too small\n");\r\nreturn -EINVAL;\r\n}\r\nif ((lsc_cfg->size / lsc_cfg->offset) < min_height) {\r\ndev_dbg(isp->dev, "CCDC: LSC: Wrong size/offset combination\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ccdc_lsc_program_table(struct isp_ccdc_device *ccdc,\r\ndma_addr_t addr)\r\n{\r\nisp_reg_writel(to_isp_device(ccdc), addr,\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_BASE);\r\n}\r\nstatic void ccdc_lsc_setup_regs(struct isp_ccdc_device *ccdc,\r\nstruct omap3isp_ccdc_lsc_config *cfg)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nint reg;\r\nisp_reg_writel(isp, cfg->offset, OMAP3_ISP_IOMEM_CCDC,\r\nISPCCDC_LSC_TABLE_OFFSET);\r\nreg = 0;\r\nreg |= cfg->gain_mode_n << ISPCCDC_LSC_GAIN_MODE_N_SHIFT;\r\nreg |= cfg->gain_mode_m << ISPCCDC_LSC_GAIN_MODE_M_SHIFT;\r\nreg |= cfg->gain_format << ISPCCDC_LSC_GAIN_FORMAT_SHIFT;\r\nisp_reg_writel(isp, reg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG);\r\nreg = 0;\r\nreg &= ~ISPCCDC_LSC_INITIAL_X_MASK;\r\nreg |= cfg->initial_x << ISPCCDC_LSC_INITIAL_X_SHIFT;\r\nreg &= ~ISPCCDC_LSC_INITIAL_Y_MASK;\r\nreg |= cfg->initial_y << ISPCCDC_LSC_INITIAL_Y_SHIFT;\r\nisp_reg_writel(isp, reg, OMAP3_ISP_IOMEM_CCDC,\r\nISPCCDC_LSC_INITIAL);\r\n}\r\nstatic int ccdc_lsc_wait_prefetch(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nunsigned int wait;\r\nisp_reg_writel(isp, IRQ0STATUS_CCDC_LSC_PREF_COMP_IRQ,\r\nOMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nfor (wait = 0; wait < 1000; wait++) {\r\nif (isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS) &\r\nIRQ0STATUS_CCDC_LSC_PREF_COMP_IRQ) {\r\nisp_reg_writel(isp, IRQ0STATUS_CCDC_LSC_PREF_COMP_IRQ,\r\nOMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nreturn 0;\r\n}\r\nrmb();\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int __ccdc_lsc_enable(struct isp_ccdc_device *ccdc, int enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nconst struct v4l2_mbus_framefmt *format =\r\n__ccdc_get_format(ccdc, NULL, CCDC_PAD_SINK,\r\nV4L2_SUBDEV_FORMAT_ACTIVE);\r\nif ((format->code != MEDIA_BUS_FMT_SGRBG10_1X10) &&\r\n(format->code != MEDIA_BUS_FMT_SRGGB10_1X10) &&\r\n(format->code != MEDIA_BUS_FMT_SBGGR10_1X10) &&\r\n(format->code != MEDIA_BUS_FMT_SGBRG10_1X10))\r\nreturn -EINVAL;\r\nif (enable)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CCDC_LSC_READ);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG,\r\nISPCCDC_LSC_ENABLE, enable ? ISPCCDC_LSC_ENABLE : 0);\r\nif (enable) {\r\nif (ccdc_lsc_wait_prefetch(ccdc) < 0) {\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC,\r\nISPCCDC_LSC_CONFIG, ISPCCDC_LSC_ENABLE);\r\nccdc->lsc.state = LSC_STATE_STOPPED;\r\ndev_warn(to_device(ccdc), "LSC prefetch timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nccdc->lsc.state = LSC_STATE_RUNNING;\r\n} else {\r\nccdc->lsc.state = LSC_STATE_STOPPING;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccdc_lsc_busy(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nreturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG) &\r\nISPCCDC_LSC_BUSY;\r\n}\r\nstatic int __ccdc_lsc_configure(struct isp_ccdc_device *ccdc,\r\nstruct ispccdc_lsc_config_req *req)\r\n{\r\nif (!req->enable)\r\nreturn -EINVAL;\r\nif (ccdc_lsc_validate_config(ccdc, &req->config) < 0) {\r\ndev_dbg(to_device(ccdc), "Discard LSC configuration\n");\r\nreturn -EINVAL;\r\n}\r\nif (ccdc_lsc_busy(ccdc))\r\nreturn -EBUSY;\r\nccdc_lsc_setup_regs(ccdc, &req->config);\r\nccdc_lsc_program_table(ccdc, req->table.dma);\r\nreturn 0;\r\n}\r\nstatic void ccdc_lsc_error_handler(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG,\r\nISPCCDC_LSC_ENABLE);\r\nccdc->lsc.state = LSC_STATE_STOPPED;\r\n}\r\nstatic void ccdc_lsc_free_request(struct isp_ccdc_device *ccdc,\r\nstruct ispccdc_lsc_config_req *req)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nif (req == NULL)\r\nreturn;\r\nif (req->table.addr) {\r\nsg_free_table(&req->table.sgt);\r\ndma_free_coherent(isp->dev, req->config.size, req->table.addr,\r\nreq->table.dma);\r\n}\r\nkfree(req);\r\n}\r\nstatic void ccdc_lsc_free_queue(struct isp_ccdc_device *ccdc,\r\nstruct list_head *queue)\r\n{\r\nstruct ispccdc_lsc_config_req *req, *n;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\r\nlist_for_each_entry_safe(req, n, queue, list) {\r\nlist_del(&req->list);\r\nspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\r\nccdc_lsc_free_request(ccdc, req);\r\nspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\r\n}\r\nstatic void ccdc_lsc_free_table_work(struct work_struct *work)\r\n{\r\nstruct isp_ccdc_device *ccdc;\r\nstruct ispccdc_lsc *lsc;\r\nlsc = container_of(work, struct ispccdc_lsc, table_work);\r\nccdc = container_of(lsc, struct isp_ccdc_device, lsc);\r\nccdc_lsc_free_queue(ccdc, &lsc->free_queue);\r\n}\r\nstatic int ccdc_lsc_config(struct isp_ccdc_device *ccdc,\r\nstruct omap3isp_ccdc_update_config *config)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nstruct ispccdc_lsc_config_req *req;\r\nunsigned long flags;\r\nu16 update;\r\nint ret;\r\nupdate = config->update &\r\n(OMAP3ISP_CCDC_CONFIG_LSC | OMAP3ISP_CCDC_TBL_LSC);\r\nif (!update)\r\nreturn 0;\r\nif (update != (OMAP3ISP_CCDC_CONFIG_LSC | OMAP3ISP_CCDC_TBL_LSC)) {\r\ndev_dbg(to_device(ccdc), "%s: Both LSC configuration and table "\r\n"need to be supplied\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreq = kzalloc(sizeof(*req), GFP_KERNEL);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nif (config->flag & OMAP3ISP_CCDC_CONFIG_LSC) {\r\nif (copy_from_user(&req->config, config->lsc_cfg,\r\nsizeof(req->config))) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nreq->enable = 1;\r\nreq->table.addr = dma_alloc_coherent(isp->dev, req->config.size,\r\n&req->table.dma,\r\nGFP_KERNEL);\r\nif (req->table.addr == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nret = dma_get_sgtable(isp->dev, &req->table.sgt,\r\nreq->table.addr, req->table.dma,\r\nreq->config.size);\r\nif (ret < 0)\r\ngoto done;\r\ndma_sync_sg_for_cpu(isp->dev, req->table.sgt.sgl,\r\nreq->table.sgt.nents, DMA_TO_DEVICE);\r\nif (copy_from_user(req->table.addr, config->lsc,\r\nreq->config.size)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\ndma_sync_sg_for_device(isp->dev, req->table.sgt.sgl,\r\nreq->table.sgt.nents, DMA_TO_DEVICE);\r\n}\r\nspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\r\nif (ccdc->lsc.request) {\r\nlist_add_tail(&ccdc->lsc.request->list, &ccdc->lsc.free_queue);\r\nschedule_work(&ccdc->lsc.table_work);\r\n}\r\nccdc->lsc.request = req;\r\nspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\r\nret = 0;\r\ndone:\r\nif (ret < 0)\r\nccdc_lsc_free_request(ccdc, req);\r\nreturn ret;\r\n}\r\nstatic inline int ccdc_lsc_is_configured(struct isp_ccdc_device *ccdc)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\r\nret = ccdc->lsc.active != NULL;\r\nspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ccdc_lsc_enable(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct ispccdc_lsc *lsc = &ccdc->lsc;\r\nif (lsc->state != LSC_STATE_STOPPED)\r\nreturn -EINVAL;\r\nif (lsc->active) {\r\nlist_add_tail(&lsc->active->list, &lsc->free_queue);\r\nlsc->active = NULL;\r\n}\r\nif (__ccdc_lsc_configure(ccdc, lsc->request) < 0) {\r\nomap3isp_sbl_disable(to_isp_device(ccdc),\r\nOMAP3_ISP_SBL_CCDC_LSC_READ);\r\nlist_add_tail(&lsc->request->list, &lsc->free_queue);\r\nlsc->request = NULL;\r\ngoto done;\r\n}\r\nlsc->active = lsc->request;\r\nlsc->request = NULL;\r\n__ccdc_lsc_enable(ccdc, 1);\r\ndone:\r\nif (!list_empty(&lsc->free_queue))\r\nschedule_work(&lsc->table_work);\r\nreturn 0;\r\n}\r\nstatic void ccdc_configure_clamp(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nu32 clamp;\r\nif (ccdc->obclamp) {\r\nclamp = ccdc->clamp.obgain << ISPCCDC_CLAMP_OBGAIN_SHIFT;\r\nclamp |= ccdc->clamp.oblen << ISPCCDC_CLAMP_OBSLEN_SHIFT;\r\nclamp |= ccdc->clamp.oblines << ISPCCDC_CLAMP_OBSLN_SHIFT;\r\nclamp |= ccdc->clamp.obstpixel << ISPCCDC_CLAMP_OBST_SHIFT;\r\nisp_reg_writel(isp, clamp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP);\r\n} else {\r\nisp_reg_writel(isp, ccdc->clamp.dcsubval,\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB);\r\n}\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP,\r\nISPCCDC_CLAMP_CLAMPEN,\r\nccdc->obclamp ? ISPCCDC_CLAMP_CLAMPEN : 0);\r\n}\r\nstatic void ccdc_configure_fpc(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC, ISPCCDC_FPC_FPCEN);\r\nif (!ccdc->fpc_en)\r\nreturn;\r\nisp_reg_writel(isp, ccdc->fpc.dma, OMAP3_ISP_IOMEM_CCDC,\r\nISPCCDC_FPC_ADDR);\r\nisp_reg_writel(isp, (ccdc->fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT),\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);\r\nisp_reg_writel(isp, (ccdc->fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT) |\r\nISPCCDC_FPC_FPCEN, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);\r\n}\r\nstatic void ccdc_configure_black_comp(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nu32 blcomp;\r\nblcomp = ccdc->blcomp.b_mg << ISPCCDC_BLKCMP_B_MG_SHIFT;\r\nblcomp |= ccdc->blcomp.gb_g << ISPCCDC_BLKCMP_GB_G_SHIFT;\r\nblcomp |= ccdc->blcomp.gr_cy << ISPCCDC_BLKCMP_GR_CY_SHIFT;\r\nblcomp |= ccdc->blcomp.r_ye << ISPCCDC_BLKCMP_R_YE_SHIFT;\r\nisp_reg_writel(isp, blcomp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_BLKCMP);\r\n}\r\nstatic void ccdc_configure_lpf(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE,\r\nISPCCDC_SYN_MODE_LPF,\r\nccdc->lpf ? ISPCCDC_SYN_MODE_LPF : 0);\r\n}\r\nstatic void ccdc_configure_alaw(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nconst struct isp_format_info *info;\r\nu32 alaw = 0;\r\ninfo = omap3isp_video_format_info(ccdc->formats[CCDC_PAD_SINK].code);\r\nswitch (info->width) {\r\ncase 8:\r\nreturn;\r\ncase 10:\r\nalaw = ISPCCDC_ALAW_GWDI_9_0;\r\nbreak;\r\ncase 11:\r\nalaw = ISPCCDC_ALAW_GWDI_10_1;\r\nbreak;\r\ncase 12:\r\nalaw = ISPCCDC_ALAW_GWDI_11_2;\r\nbreak;\r\ncase 13:\r\nalaw = ISPCCDC_ALAW_GWDI_12_3;\r\nbreak;\r\n}\r\nif (ccdc->alaw)\r\nalaw |= ISPCCDC_ALAW_CCDTBL;\r\nisp_reg_writel(isp, alaw, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW);\r\n}\r\nstatic void ccdc_config_imgattr(struct isp_ccdc_device *ccdc, u32 colptn)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nisp_reg_writel(isp, colptn, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_COLPTN);\r\n}\r\nstatic int ccdc_config(struct isp_ccdc_device *ccdc,\r\nstruct omap3isp_ccdc_update_config *ccdc_struct)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ccdc->lock, flags);\r\nccdc->shadow_update = 1;\r\nspin_unlock_irqrestore(&ccdc->lock, flags);\r\nif (OMAP3ISP_CCDC_ALAW & ccdc_struct->update) {\r\nccdc->alaw = !!(OMAP3ISP_CCDC_ALAW & ccdc_struct->flag);\r\nccdc->update |= OMAP3ISP_CCDC_ALAW;\r\n}\r\nif (OMAP3ISP_CCDC_LPF & ccdc_struct->update) {\r\nccdc->lpf = !!(OMAP3ISP_CCDC_LPF & ccdc_struct->flag);\r\nccdc->update |= OMAP3ISP_CCDC_LPF;\r\n}\r\nif (OMAP3ISP_CCDC_BLCLAMP & ccdc_struct->update) {\r\nif (copy_from_user(&ccdc->clamp, ccdc_struct->bclamp,\r\nsizeof(ccdc->clamp))) {\r\nccdc->shadow_update = 0;\r\nreturn -EFAULT;\r\n}\r\nccdc->obclamp = !!(OMAP3ISP_CCDC_BLCLAMP & ccdc_struct->flag);\r\nccdc->update |= OMAP3ISP_CCDC_BLCLAMP;\r\n}\r\nif (OMAP3ISP_CCDC_BCOMP & ccdc_struct->update) {\r\nif (copy_from_user(&ccdc->blcomp, ccdc_struct->blcomp,\r\nsizeof(ccdc->blcomp))) {\r\nccdc->shadow_update = 0;\r\nreturn -EFAULT;\r\n}\r\nccdc->update |= OMAP3ISP_CCDC_BCOMP;\r\n}\r\nccdc->shadow_update = 0;\r\nif (OMAP3ISP_CCDC_FPC & ccdc_struct->update) {\r\nstruct omap3isp_ccdc_fpc fpc;\r\nstruct ispccdc_fpc fpc_old = { .addr = NULL, };\r\nstruct ispccdc_fpc fpc_new;\r\nu32 size;\r\nif (ccdc->state != ISP_PIPELINE_STREAM_STOPPED)\r\nreturn -EBUSY;\r\nccdc->fpc_en = !!(OMAP3ISP_CCDC_FPC & ccdc_struct->flag);\r\nif (ccdc->fpc_en) {\r\nif (copy_from_user(&fpc, ccdc_struct->fpc, sizeof(fpc)))\r\nreturn -EFAULT;\r\nsize = fpc.fpnum * 4;\r\nfpc_new.fpnum = fpc.fpnum;\r\nfpc_new.addr = dma_alloc_coherent(isp->dev, size,\r\n&fpc_new.dma,\r\nGFP_KERNEL);\r\nif (fpc_new.addr == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(fpc_new.addr,\r\n(__force void __user *)fpc.fpcaddr,\r\nsize)) {\r\ndma_free_coherent(isp->dev, size, fpc_new.addr,\r\nfpc_new.dma);\r\nreturn -EFAULT;\r\n}\r\nfpc_old = ccdc->fpc;\r\nccdc->fpc = fpc_new;\r\n}\r\nccdc_configure_fpc(ccdc);\r\nif (fpc_old.addr != NULL)\r\ndma_free_coherent(isp->dev, fpc_old.fpnum * 4,\r\nfpc_old.addr, fpc_old.dma);\r\n}\r\nreturn ccdc_lsc_config(ccdc, ccdc_struct);\r\n}\r\nstatic void ccdc_apply_controls(struct isp_ccdc_device *ccdc)\r\n{\r\nif (ccdc->update & OMAP3ISP_CCDC_ALAW) {\r\nccdc_configure_alaw(ccdc);\r\nccdc->update &= ~OMAP3ISP_CCDC_ALAW;\r\n}\r\nif (ccdc->update & OMAP3ISP_CCDC_LPF) {\r\nccdc_configure_lpf(ccdc);\r\nccdc->update &= ~OMAP3ISP_CCDC_LPF;\r\n}\r\nif (ccdc->update & OMAP3ISP_CCDC_BLCLAMP) {\r\nccdc_configure_clamp(ccdc);\r\nccdc->update &= ~OMAP3ISP_CCDC_BLCLAMP;\r\n}\r\nif (ccdc->update & OMAP3ISP_CCDC_BCOMP) {\r\nccdc_configure_black_comp(ccdc);\r\nccdc->update &= ~OMAP3ISP_CCDC_BCOMP;\r\n}\r\n}\r\nvoid omap3isp_ccdc_restore_context(struct isp_device *isp)\r\n{\r\nstruct isp_ccdc_device *ccdc = &isp->isp_ccdc;\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG, ISPCCDC_CFG_VDLC);\r\nccdc->update = OMAP3ISP_CCDC_ALAW | OMAP3ISP_CCDC_LPF\r\n| OMAP3ISP_CCDC_BLCLAMP | OMAP3ISP_CCDC_BCOMP;\r\nccdc_apply_controls(ccdc);\r\nccdc_configure_fpc(ccdc);\r\n}\r\nstatic void ccdc_config_vp(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nconst struct isp_format_info *info;\r\nstruct v4l2_mbus_framefmt *format;\r\nunsigned long l3_ick = pipe->l3_ick;\r\nunsigned int max_div = isp->revision == ISP_REVISION_15_0 ? 64 : 8;\r\nunsigned int div = 0;\r\nu32 fmtcfg = ISPCCDC_FMTCFG_VPEN;\r\nformat = &ccdc->formats[CCDC_PAD_SOURCE_VP];\r\nif (!format->code) {\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);\r\nreturn;\r\n}\r\nisp_reg_writel(isp, (0 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |\r\n(format->width << ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_HORZ);\r\nisp_reg_writel(isp, (0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |\r\n((format->height + 1) << ISPCCDC_FMT_VERT_FMTLNV_SHIFT),\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_VERT);\r\nisp_reg_writel(isp, (format->width << ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |\r\n(format->height << ISPCCDC_VP_OUT_VERT_NUM_SHIFT),\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_VP_OUT);\r\ninfo = omap3isp_video_format_info(ccdc->formats[CCDC_PAD_SINK].code);\r\nswitch (info->width) {\r\ncase 8:\r\ncase 10:\r\nfmtcfg |= ISPCCDC_FMTCFG_VPIN_9_0;\r\nbreak;\r\ncase 11:\r\nfmtcfg |= ISPCCDC_FMTCFG_VPIN_10_1;\r\nbreak;\r\ncase 12:\r\nfmtcfg |= ISPCCDC_FMTCFG_VPIN_11_2;\r\nbreak;\r\ncase 13:\r\nfmtcfg |= ISPCCDC_FMTCFG_VPIN_12_3;\r\nbreak;\r\n}\r\nif (pipe->input)\r\ndiv = DIV_ROUND_UP(l3_ick, pipe->max_rate);\r\nelse if (pipe->external_rate)\r\ndiv = l3_ick / pipe->external_rate;\r\ndiv = clamp(div, 2U, max_div);\r\nfmtcfg |= (div - 2) << ISPCCDC_FMTCFG_VPIF_FRQ_SHIFT;\r\nisp_reg_writel(isp, fmtcfg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);\r\n}\r\nstatic void ccdc_config_outlineoffset(struct isp_ccdc_device *ccdc,\r\nunsigned int bpl,\r\nenum v4l2_field field)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nu32 sdofst = 0;\r\nisp_reg_writel(isp, bpl & 0xffff, OMAP3_ISP_IOMEM_CCDC,\r\nISPCCDC_HSIZE_OFF);\r\nswitch (field) {\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nsdofst |= (1 << ISPCCDC_SDOFST_LOFST0_SHIFT)\r\n| (1 << ISPCCDC_SDOFST_LOFST1_SHIFT)\r\n| (1 << ISPCCDC_SDOFST_LOFST2_SHIFT)\r\n| (1 << ISPCCDC_SDOFST_LOFST3_SHIFT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nisp_reg_writel(isp, sdofst, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST);\r\n}\r\nstatic void ccdc_set_outaddr(struct isp_ccdc_device *ccdc, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDR_ADDR);\r\n}\r\nvoid omap3isp_ccdc_max_rate(struct isp_ccdc_device *ccdc,\r\nunsigned int *max_rate)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\r\nunsigned int rate;\r\nif (pipe == NULL)\r\nreturn;\r\nif (ccdc->input == CCDC_INPUT_PARALLEL)\r\nrate = pipe->l3_ick / 2 * 9 / 10;\r\nelse\r\nrate = pipe->l3_ick / 2;\r\n*max_rate = min(*max_rate, rate);\r\n}\r\nstatic void ccdc_config_sync_if(struct isp_ccdc_device *ccdc,\r\nstruct isp_parallel_cfg *parcfg,\r\nunsigned int data_size)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nconst struct v4l2_mbus_framefmt *format;\r\nu32 syn_mode = ISPCCDC_SYN_MODE_VDHDEN;\r\nformat = &ccdc->formats[CCDC_PAD_SINK];\r\nif (format->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\r\nformat->code == MEDIA_BUS_FMT_UYVY8_2X8) {\r\nif (ccdc->bt656)\r\nsyn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR8;\r\nelse\r\nsyn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR16;\r\n}\r\nswitch (data_size) {\r\ncase 8:\r\nsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_8;\r\nbreak;\r\ncase 10:\r\nsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_10;\r\nbreak;\r\ncase 11:\r\nsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_11;\r\nbreak;\r\ncase 12:\r\nsyn_mode |= ISPCCDC_SYN_MODE_DATSIZ_12;\r\nbreak;\r\n}\r\nif (parcfg && parcfg->data_pol)\r\nsyn_mode |= ISPCCDC_SYN_MODE_DATAPOL;\r\nif (parcfg && parcfg->hs_pol)\r\nsyn_mode |= ISPCCDC_SYN_MODE_HDPOL;\r\nif ((parcfg && parcfg->vs_pol) || ccdc->bt656)\r\nsyn_mode |= ISPCCDC_SYN_MODE_VDPOL;\r\nif (parcfg && parcfg->fld_pol)\r\nsyn_mode |= ISPCCDC_SYN_MODE_FLDPOL;\r\nisp_reg_writel(isp, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);\r\nif (format->code == MEDIA_BUS_FMT_UYVY8_2X8)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\r\nISPCCDC_CFG_Y8POS);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\r\nISPCCDC_CFG_Y8POS);\r\nif (ccdc->bt656)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_REC656IF,\r\nISPCCDC_REC656IF_R656ON | ISPCCDC_REC656IF_ECCFVH);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_REC656IF,\r\nISPCCDC_REC656IF_R656ON | ISPCCDC_REC656IF_ECCFVH);\r\n}\r\nstatic void ccdc_configure(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nstruct isp_parallel_cfg *parcfg = NULL;\r\nstruct v4l2_subdev *sensor;\r\nstruct v4l2_mbus_framefmt *format;\r\nconst struct v4l2_rect *crop;\r\nconst struct isp_format_info *fmt_info;\r\nstruct v4l2_subdev_format fmt_src;\r\nunsigned int depth_out;\r\nunsigned int depth_in = 0;\r\nstruct media_pad *pad;\r\nunsigned long flags;\r\nunsigned int bridge;\r\nunsigned int shift;\r\nunsigned int nph;\r\nunsigned int sph;\r\nu32 syn_mode;\r\nu32 ccdc_pattern;\r\nccdc->bt656 = false;\r\nccdc->fields = 0;\r\npad = media_entity_remote_pad(&ccdc->pads[CCDC_PAD_SINK]);\r\nsensor = media_entity_to_v4l2_subdev(pad->entity);\r\nif (ccdc->input == CCDC_INPUT_PARALLEL) {\r\nstruct v4l2_mbus_config cfg;\r\nint ret;\r\nret = v4l2_subdev_call(sensor, video, g_mbus_config, &cfg);\r\nif (!ret)\r\nccdc->bt656 = cfg.type == V4L2_MBUS_BT656;\r\nparcfg = &((struct isp_bus_cfg *)sensor->host_priv)\r\n->bus.parallel;\r\n}\r\nformat = &ccdc->formats[CCDC_PAD_SINK];\r\nfmt_src.pad = pad->index;\r\nfmt_src.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nif (!v4l2_subdev_call(sensor, pad, get_fmt, NULL, &fmt_src)) {\r\nfmt_info = omap3isp_video_format_info(fmt_src.format.code);\r\ndepth_in = fmt_info->width;\r\n}\r\nfmt_info = omap3isp_video_format_info(format->code);\r\ndepth_out = fmt_info->width;\r\nshift = depth_in - depth_out;\r\nif (ccdc->bt656)\r\nbridge = ISPCTRL_PAR_BRIDGE_DISABLE;\r\nelse if (fmt_info->code == MEDIA_BUS_FMT_YUYV8_2X8)\r\nbridge = ISPCTRL_PAR_BRIDGE_LENDIAN;\r\nelse if (fmt_info->code == MEDIA_BUS_FMT_UYVY8_2X8)\r\nbridge = ISPCTRL_PAR_BRIDGE_BENDIAN;\r\nelse\r\nbridge = ISPCTRL_PAR_BRIDGE_DISABLE;\r\nomap3isp_configure_bridge(isp, ccdc->input, parcfg, shift, bridge);\r\nccdc_config_sync_if(ccdc, parcfg, depth_out);\r\nsyn_mode = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);\r\nsyn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;\r\nif (ccdc->output & CCDC_OUTPUT_MEMORY)\r\nsyn_mode |= ISPCCDC_SYN_MODE_WEN;\r\nelse\r\nsyn_mode &= ~ISPCCDC_SYN_MODE_WEN;\r\nif (ccdc->output & CCDC_OUTPUT_RESIZER)\r\nsyn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;\r\nelse\r\nsyn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;\r\nswitch (format->code) {\r\ncase MEDIA_BUS_FMT_SRGGB10_1X10:\r\ncase MEDIA_BUS_FMT_SRGGB12_1X12:\r\nccdc_pattern = ccdc_srggb_pattern;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR10_1X10:\r\ncase MEDIA_BUS_FMT_SBGGR12_1X12:\r\nccdc_pattern = ccdc_sbggr_pattern;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SGBRG10_1X10:\r\ncase MEDIA_BUS_FMT_SGBRG12_1X12:\r\nccdc_pattern = ccdc_sgbrg_pattern;\r\nbreak;\r\ndefault:\r\nccdc_pattern = ccdc_sgrbg_pattern;\r\nbreak;\r\n}\r\nccdc_config_imgattr(ccdc, ccdc_pattern);\r\nisp_reg_writel(isp, ((format->height - 2) << ISPCCDC_VDINT_0_SHIFT) |\r\n((format->height * 2 / 3) << ISPCCDC_VDINT_1_SHIFT),\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_VDINT);\r\nformat = &ccdc->formats[CCDC_PAD_SOURCE_OF];\r\ncrop = &ccdc->crop;\r\nif (ccdc->bt656) {\r\nsph = crop->left * 2;\r\nnph = crop->width * 2 - 1;\r\n} else {\r\nsph = crop->left;\r\nnph = crop->width - 1;\r\n}\r\nisp_reg_writel(isp, (sph << ISPCCDC_HORZ_INFO_SPH_SHIFT) |\r\n(nph << ISPCCDC_HORZ_INFO_NPH_SHIFT),\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_HORZ_INFO);\r\nisp_reg_writel(isp, (crop->top << ISPCCDC_VERT_START_SLV0_SHIFT) |\r\n(crop->top << ISPCCDC_VERT_START_SLV1_SHIFT),\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_VERT_START);\r\nisp_reg_writel(isp, (crop->height - 1)\r\n<< ISPCCDC_VERT_LINES_NLV_SHIFT,\r\nOMAP3_ISP_IOMEM_CCDC, ISPCCDC_VERT_LINES);\r\nccdc_config_outlineoffset(ccdc, ccdc->video_out.bpl_value,\r\nformat->field);\r\nif (ccdc->formats[CCDC_PAD_SINK].field == V4L2_FIELD_ALTERNATE &&\r\n(format->field == V4L2_FIELD_INTERLACED_TB ||\r\nformat->field == V4L2_FIELD_INTERLACED_BT))\r\nsyn_mode |= ISPCCDC_SYN_MODE_FLDMODE;\r\nif (format->code == MEDIA_BUS_FMT_YUYV8_1X16)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\r\nISPCCDC_CFG_BSWD);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\r\nISPCCDC_CFG_BSWD);\r\nif (omap3isp_video_format_info(format->code)->width <= 8 || ccdc->bt656)\r\nsyn_mode |= ISPCCDC_SYN_MODE_PACK8;\r\nelse\r\nsyn_mode &= ~ISPCCDC_SYN_MODE_PACK8;\r\nisp_reg_writel(isp, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);\r\nccdc_config_vp(ccdc);\r\nspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\r\nif (ccdc->lsc.request == NULL)\r\ngoto unlock;\r\nWARN_ON(ccdc->lsc.active);\r\nif (ccdc->lsc.active == NULL &&\r\n__ccdc_lsc_configure(ccdc, ccdc->lsc.request) == 0) {\r\nccdc->lsc.active = ccdc->lsc.request;\r\n} else {\r\nlist_add_tail(&ccdc->lsc.request->list, &ccdc->lsc.free_queue);\r\nschedule_work(&ccdc->lsc.table_work);\r\n}\r\nccdc->lsc.request = NULL;\r\nunlock:\r\nspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\r\nccdc_apply_controls(ccdc);\r\n}\r\nstatic void __ccdc_enable(struct isp_ccdc_device *ccdc, int enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR,\r\nISPCCDC_PCR_EN, enable ? ISPCCDC_PCR_EN : 0);\r\nccdc->running = enable;\r\n}\r\nstatic int ccdc_disable(struct isp_ccdc_device *ccdc)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ccdc->lock, flags);\r\nif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS)\r\nccdc->stopping = CCDC_STOP_REQUEST;\r\nif (!ccdc->running)\r\nccdc->stopping = CCDC_STOP_FINISHED;\r\nspin_unlock_irqrestore(&ccdc->lock, flags);\r\nret = wait_event_timeout(ccdc->wait,\r\nccdc->stopping == CCDC_STOP_FINISHED,\r\nmsecs_to_jiffies(2000));\r\nif (ret == 0) {\r\nret = -ETIMEDOUT;\r\ndev_warn(to_device(ccdc), "CCDC stop timeout!\n");\r\n}\r\nomap3isp_sbl_disable(to_isp_device(ccdc), OMAP3_ISP_SBL_CCDC_LSC_READ);\r\nmutex_lock(&ccdc->ioctl_lock);\r\nccdc_lsc_free_request(ccdc, ccdc->lsc.request);\r\nccdc->lsc.request = ccdc->lsc.active;\r\nccdc->lsc.active = NULL;\r\ncancel_work_sync(&ccdc->lsc.table_work);\r\nccdc_lsc_free_queue(ccdc, &ccdc->lsc.free_queue);\r\nmutex_unlock(&ccdc->ioctl_lock);\r\nccdc->stopping = CCDC_STOP_NOT_REQUESTED;\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nstatic void ccdc_enable(struct isp_ccdc_device *ccdc)\r\n{\r\nif (ccdc_lsc_is_configured(ccdc))\r\n__ccdc_lsc_enable(ccdc, 1);\r\n__ccdc_enable(ccdc, 1);\r\n}\r\nstatic int ccdc_sbl_busy(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nreturn omap3isp_ccdc_busy(ccdc)\r\n| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_0) &\r\nISPSBL_CCDC_WR_0_DATA_READY)\r\n| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_1) &\r\nISPSBL_CCDC_WR_0_DATA_READY)\r\n| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_2) &\r\nISPSBL_CCDC_WR_0_DATA_READY)\r\n| (isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_3) &\r\nISPSBL_CCDC_WR_0_DATA_READY);\r\n}\r\nstatic int ccdc_sbl_wait_idle(struct isp_ccdc_device *ccdc,\r\nunsigned int max_wait)\r\n{\r\nunsigned int wait = 0;\r\nif (max_wait == 0)\r\nmax_wait = 10000;\r\nfor (wait = 0; wait <= max_wait; wait++) {\r\nif (!ccdc_sbl_busy(ccdc))\r\nreturn 0;\r\nrmb();\r\nudelay(1);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int ccdc_handle_stopping(struct isp_ccdc_device *ccdc, u32 event)\r\n{\r\nint rval = 0;\r\nswitch ((ccdc->stopping & 3) | event) {\r\ncase CCDC_STOP_REQUEST | CCDC_EVENT_VD1:\r\nif (ccdc->lsc.state != LSC_STATE_STOPPED)\r\n__ccdc_lsc_enable(ccdc, 0);\r\n__ccdc_enable(ccdc, 0);\r\nccdc->stopping = CCDC_STOP_EXECUTED;\r\nreturn 1;\r\ncase CCDC_STOP_EXECUTED | CCDC_EVENT_VD0:\r\nccdc->stopping |= CCDC_STOP_CCDC_FINISHED;\r\nif (ccdc->lsc.state == LSC_STATE_STOPPED)\r\nccdc->stopping |= CCDC_STOP_LSC_FINISHED;\r\nrval = 1;\r\nbreak;\r\ncase CCDC_STOP_EXECUTED | CCDC_EVENT_LSC_DONE:\r\nccdc->stopping |= CCDC_STOP_LSC_FINISHED;\r\nrval = 1;\r\nbreak;\r\ncase CCDC_STOP_EXECUTED | CCDC_EVENT_VD1:\r\nreturn 1;\r\n}\r\nif (ccdc->stopping == CCDC_STOP_FINISHED) {\r\nwake_up(&ccdc->wait);\r\nrval = 1;\r\n}\r\nreturn rval;\r\n}\r\nstatic void ccdc_hs_vs_isr(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\r\nstruct video_device *vdev = ccdc->subdev.devnode;\r\nstruct v4l2_event event;\r\natomic_inc(&pipe->frame_number);\r\nmemset(&event, 0, sizeof(event));\r\nevent.type = V4L2_EVENT_FRAME_SYNC;\r\nevent.u.frame_sync.frame_sequence = atomic_read(&pipe->frame_number);\r\nv4l2_event_queue(vdev, &event);\r\n}\r\nstatic void ccdc_lsc_isr(struct isp_ccdc_device *ccdc, u32 events)\r\n{\r\nunsigned long flags;\r\nif (events & IRQ0STATUS_CCDC_LSC_PREF_ERR_IRQ) {\r\nstruct isp_pipeline *pipe =\r\nto_isp_pipeline(&ccdc->subdev.entity);\r\nccdc_lsc_error_handler(ccdc);\r\npipe->error = true;\r\ndev_dbg(to_device(ccdc), "lsc prefetch error\n");\r\n}\r\nif (!(events & IRQ0STATUS_CCDC_LSC_DONE_IRQ))\r\nreturn;\r\nspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\r\nif (ccdc->lsc.state == LSC_STATE_STOPPING)\r\nccdc->lsc.state = LSC_STATE_STOPPED;\r\nif (ccdc_handle_stopping(ccdc, CCDC_EVENT_LSC_DONE))\r\ngoto done;\r\nif (ccdc->lsc.state != LSC_STATE_RECONFIG)\r\ngoto done;\r\nccdc->lsc.state = LSC_STATE_STOPPED;\r\nif (events & IRQ0STATUS_HS_VS_IRQ)\r\ngoto done;\r\nif (ccdc->lsc.request == NULL)\r\ngoto done;\r\nccdc_lsc_enable(ccdc);\r\ndone:\r\nspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\r\n}\r\nstatic bool ccdc_has_all_fields(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nenum v4l2_field of_field = ccdc->formats[CCDC_PAD_SOURCE_OF].field;\r\nenum v4l2_field field;\r\nif (of_field == V4L2_FIELD_NONE)\r\nreturn true;\r\nfield = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE)\r\n& ISPCCDC_SYN_MODE_FLDSTAT\r\n? V4L2_FIELD_BOTTOM : V4L2_FIELD_TOP;\r\nif (of_field == V4L2_FIELD_ALTERNATE) {\r\npipe->field = field;\r\nreturn true;\r\n}\r\nccdc->fields |= field == V4L2_FIELD_BOTTOM\r\n? CCDC_FIELD_BOTTOM : CCDC_FIELD_TOP;\r\nif (ccdc->fields != CCDC_FIELD_BOTH)\r\nreturn false;\r\nif ((of_field == V4L2_FIELD_INTERLACED_TB && field == V4L2_FIELD_TOP) ||\r\n(of_field == V4L2_FIELD_INTERLACED_BT && field == V4L2_FIELD_BOTTOM))\r\nreturn false;\r\nccdc->fields = 0;\r\nreturn true;\r\n}\r\nstatic int ccdc_isr_buffer(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccdc->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nstruct isp_buffer *buffer;\r\nif (list_empty(&ccdc->video_out.dmaqueue))\r\nreturn 0;\r\nif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS && ccdc->underrun) {\r\nccdc->underrun = 0;\r\nreturn 1;\r\n}\r\nif (ccdc_sbl_wait_idle(ccdc, 1000)) {\r\ndev_info(isp->dev, "CCDC won't become idle!\n");\r\nmedia_entity_enum_set(&isp->crashed, &ccdc->subdev.entity);\r\nomap3isp_pipeline_cancel_stream(pipe);\r\nreturn 0;\r\n}\r\nif (!ccdc_has_all_fields(ccdc))\r\nreturn 1;\r\nbuffer = omap3isp_video_buffer_next(&ccdc->video_out);\r\nif (buffer != NULL)\r\nccdc_set_outaddr(ccdc, buffer->dma);\r\npipe->state |= ISP_PIPELINE_IDLE_OUTPUT;\r\nif (ccdc->state == ISP_PIPELINE_STREAM_SINGLESHOT &&\r\nisp_pipeline_ready(pipe))\r\nomap3isp_pipeline_set_stream(pipe,\r\nISP_PIPELINE_STREAM_SINGLESHOT);\r\nreturn buffer != NULL;\r\n}\r\nstatic void ccdc_vd0_isr(struct isp_ccdc_device *ccdc)\r\n{\r\nunsigned long flags;\r\nint restart = 0;\r\nif (ccdc->bt656) {\r\nstruct isp_pipeline *pipe =\r\nto_isp_pipeline(&ccdc->subdev.entity);\r\natomic_inc(&pipe->frame_number);\r\n}\r\nif (ccdc->bt656) {\r\nspin_lock_irqsave(&ccdc->lock, flags);\r\nif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\r\nccdc->output & CCDC_OUTPUT_MEMORY) {\r\nif (ccdc->lsc.state != LSC_STATE_STOPPED)\r\n__ccdc_lsc_enable(ccdc, 0);\r\n__ccdc_enable(ccdc, 0);\r\n}\r\nccdc_handle_stopping(ccdc, CCDC_EVENT_VD1);\r\nspin_unlock_irqrestore(&ccdc->lock, flags);\r\n}\r\nif (ccdc->output & CCDC_OUTPUT_MEMORY)\r\nrestart = ccdc_isr_buffer(ccdc);\r\nspin_lock_irqsave(&ccdc->lock, flags);\r\nif (ccdc_handle_stopping(ccdc, CCDC_EVENT_VD0)) {\r\nspin_unlock_irqrestore(&ccdc->lock, flags);\r\nreturn;\r\n}\r\nif (!ccdc->shadow_update)\r\nccdc_apply_controls(ccdc);\r\nspin_unlock_irqrestore(&ccdc->lock, flags);\r\nif (restart)\r\nccdc_enable(ccdc);\r\n}\r\nstatic void ccdc_vd1_isr(struct isp_ccdc_device *ccdc)\r\n{\r\nunsigned long flags;\r\nif (ccdc->bt656)\r\nreturn;\r\nspin_lock_irqsave(&ccdc->lsc.req_lock, flags);\r\nswitch (ccdc->state) {\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nccdc->stopping = CCDC_STOP_REQUEST;\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (ccdc->output & CCDC_OUTPUT_MEMORY) {\r\nif (ccdc->lsc.state != LSC_STATE_STOPPED)\r\n__ccdc_lsc_enable(ccdc, 0);\r\n__ccdc_enable(ccdc, 0);\r\n}\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\nbreak;\r\n}\r\nif (ccdc_handle_stopping(ccdc, CCDC_EVENT_VD1))\r\ngoto done;\r\nif (ccdc->lsc.request == NULL)\r\ngoto done;\r\nif (ccdc->lsc.state == LSC_STATE_RUNNING) {\r\n__ccdc_lsc_enable(ccdc, 0);\r\nccdc->lsc.state = LSC_STATE_RECONFIG;\r\ngoto done;\r\n}\r\nif (ccdc->lsc.state == LSC_STATE_STOPPED)\r\nccdc_lsc_enable(ccdc);\r\ndone:\r\nspin_unlock_irqrestore(&ccdc->lsc.req_lock, flags);\r\n}\r\nint omap3isp_ccdc_isr(struct isp_ccdc_device *ccdc, u32 events)\r\n{\r\nif (ccdc->state == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nif (events & IRQ0STATUS_CCDC_VD1_IRQ)\r\nccdc_vd1_isr(ccdc);\r\nccdc_lsc_isr(ccdc, events);\r\nif (events & IRQ0STATUS_CCDC_VD0_IRQ)\r\nccdc_vd0_isr(ccdc);\r\nif (events & IRQ0STATUS_HS_VS_IRQ)\r\nccdc_hs_vs_isr(ccdc);\r\nreturn 0;\r\n}\r\nstatic int ccdc_video_queue(struct isp_video *video, struct isp_buffer *buffer)\r\n{\r\nstruct isp_ccdc_device *ccdc = &video->isp->isp_ccdc;\r\nunsigned long flags;\r\nbool restart = false;\r\nif (!(ccdc->output & CCDC_OUTPUT_MEMORY))\r\nreturn -ENODEV;\r\nccdc_set_outaddr(ccdc, buffer->dma);\r\nspin_lock_irqsave(&ccdc->lock, flags);\r\nif (ccdc->state == ISP_PIPELINE_STREAM_CONTINUOUS && !ccdc->running &&\r\nccdc->bt656)\r\nrestart = true;\r\nelse\r\nccdc->underrun = 1;\r\nspin_unlock_irqrestore(&ccdc->lock, flags);\r\nif (restart)\r\nccdc_enable(ccdc);\r\nreturn 0;\r\n}\r\nstatic long ccdc_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nint ret;\r\nswitch (cmd) {\r\ncase VIDIOC_OMAP3ISP_CCDC_CFG:\r\nmutex_lock(&ccdc->ioctl_lock);\r\nret = ccdc_config(ccdc, arg);\r\nmutex_unlock(&ccdc->ioctl_lock);\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ccdc_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\r\nstruct v4l2_event_subscription *sub)\r\n{\r\nif (sub->type != V4L2_EVENT_FRAME_SYNC)\r\nreturn -EINVAL;\r\nif (sub->id != 0)\r\nreturn -EINVAL;\r\nreturn v4l2_event_subscribe(fh, sub, OMAP3ISP_CCDC_NEVENTS, NULL);\r\n}\r\nstatic int ccdc_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\r\nstruct v4l2_event_subscription *sub)\r\n{\r\nreturn v4l2_event_unsubscribe(fh, sub);\r\n}\r\nstatic int ccdc_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nint ret = 0;\r\nif (ccdc->state == ISP_PIPELINE_STREAM_STOPPED) {\r\nif (enable == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nomap3isp_subclk_enable(isp, OMAP3_ISP_SUBCLK_CCDC);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,\r\nISPCCDC_CFG_VDLC);\r\nccdc_configure(ccdc);\r\nccdc_print_status(ccdc);\r\n}\r\nswitch (enable) {\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (ccdc->output & CCDC_OUTPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CCDC_WRITE);\r\nif (ccdc->underrun || !(ccdc->output & CCDC_OUTPUT_MEMORY))\r\nccdc_enable(ccdc);\r\nccdc->underrun = 0;\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nif (ccdc->output & CCDC_OUTPUT_MEMORY &&\r\nccdc->state != ISP_PIPELINE_STREAM_SINGLESHOT)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CCDC_WRITE);\r\nccdc_enable(ccdc);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\nret = ccdc_disable(ccdc);\r\nif (ccdc->output & CCDC_OUTPUT_MEMORY)\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_CCDC_WRITE);\r\nomap3isp_subclk_disable(isp, OMAP3_ISP_SUBCLK_CCDC);\r\nccdc->underrun = 0;\r\nbreak;\r\n}\r\nccdc->state = enable;\r\nreturn ret;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__ccdc_get_format(struct isp_ccdc_device *ccdc, struct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(&ccdc->subdev, cfg, pad);\r\nelse\r\nreturn &ccdc->formats[pad];\r\n}\r\nstatic struct v4l2_rect *\r\n__ccdc_get_crop(struct isp_ccdc_device *ccdc, struct v4l2_subdev_pad_config *cfg,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_crop(&ccdc->subdev, cfg, CCDC_PAD_SOURCE_OF);\r\nelse\r\nreturn &ccdc->crop;\r\n}\r\nstatic void\r\nccdc_try_format(struct isp_ccdc_device *ccdc, struct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, struct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nconst struct isp_format_info *info;\r\nu32 pixelcode;\r\nunsigned int width = fmt->width;\r\nunsigned int height = fmt->height;\r\nstruct v4l2_rect *crop;\r\nenum v4l2_field field;\r\nunsigned int i;\r\nswitch (pad) {\r\ncase CCDC_PAD_SINK:\r\nfor (i = 0; i < ARRAY_SIZE(ccdc_fmts); i++) {\r\nif (fmt->code == ccdc_fmts[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(ccdc_fmts))\r\nfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nfmt->width = clamp_t(u32, width, 32, 4096);\r\nfmt->height = clamp_t(u32, height, 32, 4096);\r\nif (fmt->field == V4L2_FIELD_ANY)\r\nfmt->field = V4L2_FIELD_NONE;\r\nbreak;\r\ncase CCDC_PAD_SOURCE_OF:\r\npixelcode = fmt->code;\r\nfield = fmt->field;\r\n*fmt = *__ccdc_get_format(ccdc, cfg, CCDC_PAD_SINK, which);\r\nif (fmt->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\r\nfmt->code == MEDIA_BUS_FMT_UYVY8_2X8) {\r\nif (pixelcode == MEDIA_BUS_FMT_YUYV8_2X8 ||\r\npixelcode == MEDIA_BUS_FMT_UYVY8_2X8 ||\r\npixelcode == MEDIA_BUS_FMT_YUYV8_1X16 ||\r\npixelcode == MEDIA_BUS_FMT_UYVY8_1X16)\r\nfmt->code = pixelcode;\r\nif (fmt->code == MEDIA_BUS_FMT_YUYV8_2X8)\r\nfmt->code = MEDIA_BUS_FMT_YUYV8_1X16;\r\nelse if (fmt->code == MEDIA_BUS_FMT_UYVY8_2X8)\r\nfmt->code = MEDIA_BUS_FMT_UYVY8_1X16;\r\n}\r\ncrop = __ccdc_get_crop(ccdc, cfg, which);\r\nfmt->width = crop->width;\r\nfmt->height = crop->height;\r\nif (fmt->field == V4L2_FIELD_ALTERNATE &&\r\n(field == V4L2_FIELD_INTERLACED_TB ||\r\nfield == V4L2_FIELD_INTERLACED_BT)) {\r\nfmt->field = field;\r\nfmt->height *= 2;\r\n}\r\nbreak;\r\ncase CCDC_PAD_SOURCE_VP:\r\n*fmt = *__ccdc_get_format(ccdc, cfg, CCDC_PAD_SINK, which);\r\ninfo = omap3isp_video_format_info(fmt->code);\r\nfmt->code = info->truncated;\r\nif (fmt->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\r\nfmt->code == MEDIA_BUS_FMT_UYVY8_2X8)\r\nfmt->code = 0;\r\nfmt->width = clamp_t(u32, width, 32, fmt->width);\r\nfmt->height = clamp_t(u32, height, 32, fmt->height - 1);\r\nbreak;\r\n}\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\n}\r\nstatic void ccdc_try_crop(struct isp_ccdc_device *ccdc,\r\nconst struct v4l2_mbus_framefmt *sink,\r\nstruct v4l2_rect *crop)\r\n{\r\nconst struct isp_format_info *info;\r\nunsigned int max_width;\r\ninfo = omap3isp_video_format_info(sink->code);\r\nif (info->flavor != MEDIA_BUS_FMT_Y8_1X8) {\r\ncrop->left &= ~1;\r\ncrop->top &= ~1;\r\n}\r\ncrop->left = clamp_t(u32, crop->left, 0, sink->width - CCDC_MIN_WIDTH);\r\ncrop->top = clamp_t(u32, crop->top, 0, sink->height - CCDC_MIN_HEIGHT);\r\nmax_width = (sink->width - crop->left + 15) & ~15;\r\ncrop->width = clamp_t(u32, crop->width, CCDC_MIN_WIDTH, max_width)\r\n& ~15;\r\ncrop->height = clamp_t(u32, crop->height, CCDC_MIN_HEIGHT,\r\nsink->height - crop->top);\r\nif (info->flavor != MEDIA_BUS_FMT_Y8_1X8) {\r\ncrop->width &= ~1;\r\ncrop->height &= ~1;\r\n}\r\n}\r\nstatic int ccdc_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nswitch (code->pad) {\r\ncase CCDC_PAD_SINK:\r\nif (code->index >= ARRAY_SIZE(ccdc_fmts))\r\nreturn -EINVAL;\r\ncode->code = ccdc_fmts[code->index];\r\nbreak;\r\ncase CCDC_PAD_SOURCE_OF:\r\nformat = __ccdc_get_format(ccdc, cfg, code->pad,\r\ncode->which);\r\nif (format->code == MEDIA_BUS_FMT_YUYV8_2X8 ||\r\nformat->code == MEDIA_BUS_FMT_UYVY8_2X8) {\r\nif (code->index == 0)\r\ncode->code = MEDIA_BUS_FMT_YUYV8_1X16;\r\nelse if (code->index == 1)\r\ncode->code = MEDIA_BUS_FMT_UYVY8_1X16;\r\nelse\r\nreturn -EINVAL;\r\n} else {\r\nif (code->index == 0)\r\ncode->code = format->code;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase CCDC_PAD_SOURCE_VP:\r\nif (code->index != 0)\r\nreturn -EINVAL;\r\nformat = __ccdc_get_format(ccdc, cfg, code->pad,\r\ncode->which);\r\nif (format->code == 0)\r\nreturn -EINVAL;\r\ncode->code = format->code;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccdc_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\nccdc_try_format(ccdc, cfg, fse->pad, &format, fse->which);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\nccdc_try_format(ccdc, cfg, fse->pad, &format, fse->which);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int ccdc_get_selection(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (sel->pad != CCDC_PAD_SOURCE_OF)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = INT_MAX;\r\nsel->r.height = INT_MAX;\r\nformat = __ccdc_get_format(ccdc, cfg, CCDC_PAD_SINK, sel->which);\r\nccdc_try_crop(ccdc, format, &sel->r);\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\nsel->r = *__ccdc_get_crop(ccdc, cfg, sel->which);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccdc_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (sel->target != V4L2_SEL_TGT_CROP ||\r\nsel->pad != CCDC_PAD_SOURCE_OF)\r\nreturn -EINVAL;\r\nif (ccdc->state != ISP_PIPELINE_STREAM_STOPPED)\r\nreturn -EBUSY;\r\nif (sel->flags & V4L2_SEL_FLAG_KEEP_CONFIG) {\r\nsel->r = *__ccdc_get_crop(ccdc, cfg, sel->which);\r\nreturn 0;\r\n}\r\nformat = __ccdc_get_format(ccdc, cfg, CCDC_PAD_SINK, sel->which);\r\nccdc_try_crop(ccdc, format, &sel->r);\r\n*__ccdc_get_crop(ccdc, cfg, sel->which) = sel->r;\r\nformat = __ccdc_get_format(ccdc, cfg, CCDC_PAD_SOURCE_OF, sel->which);\r\nccdc_try_format(ccdc, cfg, CCDC_PAD_SOURCE_OF, format, sel->which);\r\nreturn 0;\r\n}\r\nstatic int ccdc_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __ccdc_get_format(ccdc, cfg, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int ccdc_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\nformat = __ccdc_get_format(ccdc, cfg, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nccdc_try_format(ccdc, cfg, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == CCDC_PAD_SINK) {\r\ncrop = __ccdc_get_crop(ccdc, cfg, fmt->which);\r\ncrop->left = 0;\r\ncrop->top = 0;\r\ncrop->width = fmt->format.width;\r\ncrop->height = fmt->format.height;\r\nccdc_try_crop(ccdc, &fmt->format, crop);\r\nformat = __ccdc_get_format(ccdc, cfg, CCDC_PAD_SOURCE_OF,\r\nfmt->which);\r\n*format = fmt->format;\r\nccdc_try_format(ccdc, cfg, CCDC_PAD_SOURCE_OF, format,\r\nfmt->which);\r\nformat = __ccdc_get_format(ccdc, cfg, CCDC_PAD_SOURCE_VP,\r\nfmt->which);\r\n*format = fmt->format;\r\nccdc_try_format(ccdc, cfg, CCDC_PAD_SOURCE_VP, format,\r\nfmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ccdc_is_shiftable(u32 in, u32 out, unsigned int additional_shift)\r\n{\r\nconst struct isp_format_info *in_info, *out_info;\r\nif (in == out)\r\nreturn true;\r\nin_info = omap3isp_video_format_info(in);\r\nout_info = omap3isp_video_format_info(out);\r\nif ((in_info->flavor == 0) || (out_info->flavor == 0))\r\nreturn false;\r\nif (in_info->flavor != out_info->flavor)\r\nreturn false;\r\nreturn in_info->width - out_info->width + additional_shift <= 6;\r\n}\r\nstatic int ccdc_link_validate(struct v4l2_subdev *sd,\r\nstruct media_link *link,\r\nstruct v4l2_subdev_format *source_fmt,\r\nstruct v4l2_subdev_format *sink_fmt)\r\n{\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nunsigned long parallel_shift;\r\nif (source_fmt->format.width != sink_fmt->format.width ||\r\nsource_fmt->format.height != sink_fmt->format.height)\r\nreturn -EPIPE;\r\nif (ccdc->input == CCDC_INPUT_PARALLEL) {\r\nstruct isp_parallel_cfg *parcfg =\r\n&((struct isp_bus_cfg *)\r\nmedia_entity_to_v4l2_subdev(link->source->entity)\r\n->host_priv)->bus.parallel;\r\nparallel_shift = parcfg->data_lane_shift;\r\n} else {\r\nparallel_shift = 0;\r\n}\r\nif (!ccdc_is_shiftable(source_fmt->format.code,\r\nsink_fmt->format.code, parallel_shift))\r\nreturn -EPIPE;\r\nreturn 0;\r\n}\r\nstatic int ccdc_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = CCDC_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\nccdc_set_format(sd, fh ? fh->pad : NULL, &format);\r\nreturn 0;\r\n}\r\nstatic int ccdc_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct isp_ccdc_device *ccdc = v4l2_get_subdevdata(sd);\r\nstruct isp_device *isp = to_isp_device(ccdc);\r\nunsigned int index = local->index;\r\nif (is_media_entity_v4l2_subdev(remote->entity))\r\nindex |= 2 << 16;\r\nswitch (index) {\r\ncase CCDC_PAD_SINK | 2 << 16:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nccdc->input = CCDC_INPUT_NONE;\r\nbreak;\r\n}\r\nif (ccdc->input != CCDC_INPUT_NONE)\r\nreturn -EBUSY;\r\nif (remote->entity == &isp->isp_ccp2.subdev.entity)\r\nccdc->input = CCDC_INPUT_CCP2B;\r\nelse if (remote->entity == &isp->isp_csi2a.subdev.entity)\r\nccdc->input = CCDC_INPUT_CSI2A;\r\nelse if (remote->entity == &isp->isp_csi2c.subdev.entity)\r\nccdc->input = CCDC_INPUT_CSI2C;\r\nelse\r\nccdc->input = CCDC_INPUT_PARALLEL;\r\nbreak;\r\ncase CCDC_PAD_SOURCE_VP | 2 << 16:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (ccdc->output & ~CCDC_OUTPUT_PREVIEW)\r\nreturn -EBUSY;\r\nccdc->output |= CCDC_OUTPUT_PREVIEW;\r\n} else {\r\nccdc->output &= ~CCDC_OUTPUT_PREVIEW;\r\n}\r\nbreak;\r\ncase CCDC_PAD_SOURCE_OF:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (ccdc->output & ~CCDC_OUTPUT_MEMORY)\r\nreturn -EBUSY;\r\nccdc->output |= CCDC_OUTPUT_MEMORY;\r\n} else {\r\nccdc->output &= ~CCDC_OUTPUT_MEMORY;\r\n}\r\nbreak;\r\ncase CCDC_PAD_SOURCE_OF | 2 << 16:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (ccdc->output & ~CCDC_OUTPUT_RESIZER)\r\nreturn -EBUSY;\r\nccdc->output |= CCDC_OUTPUT_RESIZER;\r\n} else {\r\nccdc->output &= ~CCDC_OUTPUT_RESIZER;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3isp_ccdc_unregister_entities(struct isp_ccdc_device *ccdc)\r\n{\r\nv4l2_device_unregister_subdev(&ccdc->subdev);\r\nomap3isp_video_unregister(&ccdc->video_out);\r\n}\r\nint omap3isp_ccdc_register_entities(struct isp_ccdc_device *ccdc,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &ccdc->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&ccdc->video_out, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap3isp_ccdc_unregister_entities(ccdc);\r\nreturn ret;\r\n}\r\nstatic int ccdc_init_entities(struct isp_ccdc_device *ccdc)\r\n{\r\nstruct v4l2_subdev *sd = &ccdc->subdev;\r\nstruct media_pad *pads = ccdc->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nccdc->input = CCDC_INPUT_NONE;\r\nv4l2_subdev_init(sd, &ccdc_v4l2_ops);\r\nsd->internal_ops = &ccdc_v4l2_internal_ops;\r\nstrlcpy(sd->name, "OMAP3 ISP CCDC", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, ccdc);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[CCDC_PAD_SINK].flags = MEDIA_PAD_FL_SINK\r\n| MEDIA_PAD_FL_MUST_CONNECT;\r\npads[CCDC_PAD_SOURCE_VP].flags = MEDIA_PAD_FL_SOURCE;\r\npads[CCDC_PAD_SOURCE_OF].flags = MEDIA_PAD_FL_SOURCE;\r\nme->ops = &ccdc_media_ops;\r\nret = media_entity_pads_init(me, CCDC_PADS_NUM, pads);\r\nif (ret < 0)\r\nreturn ret;\r\nccdc_init_formats(sd, NULL);\r\nccdc->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nccdc->video_out.ops = &ccdc_video_ops;\r\nccdc->video_out.isp = to_isp_device(ccdc);\r\nccdc->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\r\nccdc->video_out.bpl_alignment = 32;\r\nret = omap3isp_video_init(&ccdc->video_out, "CCDC");\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nmedia_entity_cleanup(me);\r\nreturn ret;\r\n}\r\nint omap3isp_ccdc_init(struct isp_device *isp)\r\n{\r\nstruct isp_ccdc_device *ccdc = &isp->isp_ccdc;\r\nint ret;\r\nspin_lock_init(&ccdc->lock);\r\ninit_waitqueue_head(&ccdc->wait);\r\nmutex_init(&ccdc->ioctl_lock);\r\nccdc->stopping = CCDC_STOP_NOT_REQUESTED;\r\nINIT_WORK(&ccdc->lsc.table_work, ccdc_lsc_free_table_work);\r\nccdc->lsc.state = LSC_STATE_STOPPED;\r\nINIT_LIST_HEAD(&ccdc->lsc.free_queue);\r\nspin_lock_init(&ccdc->lsc.req_lock);\r\nccdc->clamp.oblen = 0;\r\nccdc->clamp.dcsubval = 0;\r\nccdc->update = OMAP3ISP_CCDC_BLCLAMP;\r\nccdc_apply_controls(ccdc);\r\nret = ccdc_init_entities(ccdc);\r\nif (ret < 0) {\r\nmutex_destroy(&ccdc->ioctl_lock);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3isp_ccdc_cleanup(struct isp_device *isp)\r\n{\r\nstruct isp_ccdc_device *ccdc = &isp->isp_ccdc;\r\nomap3isp_video_cleanup(&ccdc->video_out);\r\nmedia_entity_cleanup(&ccdc->subdev.entity);\r\nccdc_lsc_free_request(ccdc, ccdc->lsc.request);\r\ncancel_work_sync(&ccdc->lsc.table_work);\r\nccdc_lsc_free_queue(ccdc, &ccdc->lsc.free_queue);\r\nif (ccdc->fpc.addr != NULL)\r\ndma_free_coherent(isp->dev, ccdc->fpc.fpnum * 4, ccdc->fpc.addr,\r\nccdc->fpc.dma);\r\nmutex_destroy(&ccdc->ioctl_lock);\r\n}
