static int _rsa_enc(const struct rsa_key *key, MPI c, MPI m)\r\n{\r\nif (mpi_cmp_ui(m, 0) < 0 || mpi_cmp(m, key->n) >= 0)\r\nreturn -EINVAL;\r\nreturn mpi_powm(c, m, key->e, key->n);\r\n}\r\nstatic int _rsa_dec(const struct rsa_key *key, MPI m, MPI c)\r\n{\r\nif (mpi_cmp_ui(c, 0) < 0 || mpi_cmp(c, key->n) >= 0)\r\nreturn -EINVAL;\r\nreturn mpi_powm(m, c, key->d, key->n);\r\n}\r\nstatic int _rsa_sign(const struct rsa_key *key, MPI s, MPI m)\r\n{\r\nif (mpi_cmp_ui(m, 0) < 0 || mpi_cmp(m, key->n) >= 0)\r\nreturn -EINVAL;\r\nreturn mpi_powm(s, m, key->d, key->n);\r\n}\r\nstatic int _rsa_verify(const struct rsa_key *key, MPI m, MPI s)\r\n{\r\nif (mpi_cmp_ui(s, 0) < 0 || mpi_cmp(s, key->n) >= 0)\r\nreturn -EINVAL;\r\nreturn mpi_powm(m, s, key->e, key->n);\r\n}\r\nstatic inline struct rsa_key *rsa_get_key(struct crypto_akcipher *tfm)\r\n{\r\nreturn akcipher_tfm_ctx(tfm);\r\n}\r\nstatic int rsa_enc(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nconst struct rsa_key *pkey = rsa_get_key(tfm);\r\nMPI m, c = mpi_alloc(0);\r\nint ret = 0;\r\nint sign;\r\nif (!c)\r\nreturn -ENOMEM;\r\nif (unlikely(!pkey->n || !pkey->e)) {\r\nret = -EINVAL;\r\ngoto err_free_c;\r\n}\r\nret = -ENOMEM;\r\nm = mpi_read_raw_from_sgl(req->src, req->src_len);\r\nif (!m)\r\ngoto err_free_c;\r\nret = _rsa_enc(pkey, c, m);\r\nif (ret)\r\ngoto err_free_m;\r\nret = mpi_write_to_sgl(c, req->dst, &req->dst_len, &sign);\r\nif (ret)\r\ngoto err_free_m;\r\nif (sign < 0)\r\nret = -EBADMSG;\r\nerr_free_m:\r\nmpi_free(m);\r\nerr_free_c:\r\nmpi_free(c);\r\nreturn ret;\r\n}\r\nstatic int rsa_dec(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nconst struct rsa_key *pkey = rsa_get_key(tfm);\r\nMPI c, m = mpi_alloc(0);\r\nint ret = 0;\r\nint sign;\r\nif (!m)\r\nreturn -ENOMEM;\r\nif (unlikely(!pkey->n || !pkey->d)) {\r\nret = -EINVAL;\r\ngoto err_free_m;\r\n}\r\nret = -ENOMEM;\r\nc = mpi_read_raw_from_sgl(req->src, req->src_len);\r\nif (!c)\r\ngoto err_free_m;\r\nret = _rsa_dec(pkey, m, c);\r\nif (ret)\r\ngoto err_free_c;\r\nret = mpi_write_to_sgl(m, req->dst, &req->dst_len, &sign);\r\nif (ret)\r\ngoto err_free_c;\r\nif (sign < 0)\r\nret = -EBADMSG;\r\nerr_free_c:\r\nmpi_free(c);\r\nerr_free_m:\r\nmpi_free(m);\r\nreturn ret;\r\n}\r\nstatic int rsa_sign(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nconst struct rsa_key *pkey = rsa_get_key(tfm);\r\nMPI m, s = mpi_alloc(0);\r\nint ret = 0;\r\nint sign;\r\nif (!s)\r\nreturn -ENOMEM;\r\nif (unlikely(!pkey->n || !pkey->d)) {\r\nret = -EINVAL;\r\ngoto err_free_s;\r\n}\r\nret = -ENOMEM;\r\nm = mpi_read_raw_from_sgl(req->src, req->src_len);\r\nif (!m)\r\ngoto err_free_s;\r\nret = _rsa_sign(pkey, s, m);\r\nif (ret)\r\ngoto err_free_m;\r\nret = mpi_write_to_sgl(s, req->dst, &req->dst_len, &sign);\r\nif (ret)\r\ngoto err_free_m;\r\nif (sign < 0)\r\nret = -EBADMSG;\r\nerr_free_m:\r\nmpi_free(m);\r\nerr_free_s:\r\nmpi_free(s);\r\nreturn ret;\r\n}\r\nstatic int rsa_verify(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nconst struct rsa_key *pkey = rsa_get_key(tfm);\r\nMPI s, m = mpi_alloc(0);\r\nint ret = 0;\r\nint sign;\r\nif (!m)\r\nreturn -ENOMEM;\r\nif (unlikely(!pkey->n || !pkey->e)) {\r\nret = -EINVAL;\r\ngoto err_free_m;\r\n}\r\nret = -ENOMEM;\r\ns = mpi_read_raw_from_sgl(req->src, req->src_len);\r\nif (!s) {\r\nret = -ENOMEM;\r\ngoto err_free_m;\r\n}\r\nret = _rsa_verify(pkey, m, s);\r\nif (ret)\r\ngoto err_free_s;\r\nret = mpi_write_to_sgl(m, req->dst, &req->dst_len, &sign);\r\nif (ret)\r\ngoto err_free_s;\r\nif (sign < 0)\r\nret = -EBADMSG;\r\nerr_free_s:\r\nmpi_free(s);\r\nerr_free_m:\r\nmpi_free(m);\r\nreturn ret;\r\n}\r\nstatic int rsa_check_key_length(unsigned int len)\r\n{\r\nswitch (len) {\r\ncase 512:\r\ncase 1024:\r\ncase 1536:\r\ncase 2048:\r\ncase 3072:\r\ncase 4096:\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct rsa_key *pkey = akcipher_tfm_ctx(tfm);\r\nint ret;\r\nret = rsa_parse_pub_key(pkey, key, keylen);\r\nif (ret)\r\nreturn ret;\r\nif (rsa_check_key_length(mpi_get_size(pkey->n) << 3)) {\r\nrsa_free_key(pkey);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct rsa_key *pkey = akcipher_tfm_ctx(tfm);\r\nint ret;\r\nret = rsa_parse_priv_key(pkey, key, keylen);\r\nif (ret)\r\nreturn ret;\r\nif (rsa_check_key_length(mpi_get_size(pkey->n) << 3)) {\r\nrsa_free_key(pkey);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rsa_max_size(struct crypto_akcipher *tfm)\r\n{\r\nstruct rsa_key *pkey = akcipher_tfm_ctx(tfm);\r\nreturn pkey->n ? mpi_get_size(pkey->n) : -EINVAL;\r\n}\r\nstatic void rsa_exit_tfm(struct crypto_akcipher *tfm)\r\n{\r\nstruct rsa_key *pkey = akcipher_tfm_ctx(tfm);\r\nrsa_free_key(pkey);\r\n}\r\nstatic int rsa_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_akcipher(&rsa);\r\nif (err)\r\nreturn err;\r\nerr = crypto_register_template(&rsa_pkcs1pad_tmpl);\r\nif (err) {\r\ncrypto_unregister_akcipher(&rsa);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rsa_exit(void)\r\n{\r\ncrypto_unregister_template(&rsa_pkcs1pad_tmpl);\r\ncrypto_unregister_akcipher(&rsa);\r\n}
