static inline struct ths8200_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ths8200_state, sd);\r\n}\r\nstatic inline unsigned htotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_FRAME_WIDTH(t);\r\n}\r\nstatic inline unsigned vtotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_FRAME_HEIGHT(t);\r\n}\r\nstatic int ths8200_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int ths8200_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nv4l2_err(sd, "I2C Write Problem\n");\r\nreturn ret;\r\n}\r\nstatic inline void\r\nths8200_write_and_or(struct v4l2_subdev *sd, u8 reg,\r\nuint8_t clr_mask, uint8_t val_mask)\r\n{\r\nths8200_write(sd, reg, (ths8200_read(sd, reg) & clr_mask) | val_mask);\r\n}\r\nstatic int ths8200_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nreg->val = ths8200_read(sd, reg->reg & 0xff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int ths8200_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nths8200_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int ths8200_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct ths8200_state *state = to_state(sd);\r\nuint8_t reg_03 = ths8200_read(sd, THS8200_CHIP_CTL);\r\nv4l2_info(sd, "----- Chip status -----\n");\r\nv4l2_info(sd, "version: %u\n", state->chip_version);\r\nv4l2_info(sd, "power: %s\n", (reg_03 & 0x0c) ? "off" : "on");\r\nv4l2_info(sd, "reset: %s\n", (reg_03 & 0x01) ? "off" : "on");\r\nv4l2_info(sd, "test pattern: %s\n",\r\n(reg_03 & 0x20) ? "enabled" : "disabled");\r\nv4l2_info(sd, "format: %ux%u\n",\r\nths8200_read(sd, THS8200_DTG2_PIXEL_CNT_MSB) * 256 +\r\nths8200_read(sd, THS8200_DTG2_PIXEL_CNT_LSB),\r\n(ths8200_read(sd, THS8200_DTG2_LINE_CNT_MSB) & 0x07) * 256 +\r\nths8200_read(sd, THS8200_DTG2_LINE_CNT_LSB));\r\nv4l2_print_dv_timings(sd->name, "Configured format:",\r\n&state->dv_timings, true);\r\nreturn 0;\r\n}\r\nstatic int ths8200_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct ths8200_state *state = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s: power %s\n", __func__, on ? "on" : "off");\r\nstate->power_on = on;\r\nths8200_write_and_or(sd, THS8200_CHIP_CTL, 0xf2, (on ? 0x00 : 0x0c));\r\nreturn 0;\r\n}\r\nstatic int ths8200_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct ths8200_state *state = to_state(sd);\r\nif (enable && !state->power_on)\r\nths8200_s_power(sd, true);\r\nths8200_write_and_or(sd, THS8200_CHIP_CTL, 0xfe,\r\n(enable ? 0x01 : 0x00));\r\nv4l2_dbg(1, debug, sd, "%s: %sable\n",\r\n__func__, (enable ? "en" : "dis"));\r\nreturn 0;\r\n}\r\nstatic void ths8200_core_init(struct v4l2_subdev *sd)\r\n{\r\nths8200_write_and_or(sd, THS8200_CHIP_CTL, 0x3f, 0xc0);\r\nths8200_write(sd, THS8200_DATA_CNTL, 0x70);\r\nths8200_write(sd, THS8200_DTG1_MODE, 0x87);\r\nths8200_write(sd, THS8200_DTG1_Y_SYNC_MSB, 0x00);\r\nths8200_write(sd, THS8200_DTG1_CBCR_SYNC_MSB, 0x00);\r\n}\r\nstatic void ths8200_setup(struct v4l2_subdev *sd, struct v4l2_bt_timings *bt)\r\n{\r\nuint8_t polarity = 0;\r\nuint16_t line_start_active_video = (bt->vsync + bt->vbackporch);\r\nuint16_t line_start_front_porch = (vtotal(bt) - bt->vfrontporch);\r\nths8200_s_stream(sd, false);\r\nths8200_write(sd, THS8200_DTG1_SPEC_A, bt->hsync);\r\nths8200_write(sd, THS8200_DTG1_SPEC_B, bt->hfrontporch);\r\nif (!bt->interlaced)\r\nths8200_write(sd, THS8200_DTG1_SPEC_C, 0x00);\r\nths8200_write(sd, THS8200_DTG1_SPEC_D_LSB,\r\n(bt->hbackporch + bt->hsync) & 0xff);\r\nths8200_write(sd, THS8200_DTG1_SPEC_E_LSB, 0x00);\r\nths8200_write(sd, THS8200_DTG1_SPEC_DEH_MSB,\r\n((bt->hbackporch + bt->hsync) & 0x100) >> 1);\r\nths8200_write(sd, THS8200_DTG1_SPEC_K_LSB, (bt->hfrontporch) & 0xff);\r\nths8200_write(sd, THS8200_DTG1_SPEC_K_MSB,\r\n((bt->hfrontporch) & 0x700) >> 8);\r\nths8200_write(sd, THS8200_DTG1_SPEC_G_LSB, (htotal(bt)/2) & 0xff);\r\nths8200_write(sd, THS8200_DTG1_SPEC_G_MSB,\r\n((htotal(bt)/2) >> 8) & 0x0f);\r\nths8200_write(sd, THS8200_DTG1_TOT_PIXELS_MSB, htotal(bt) >> 8);\r\nths8200_write(sd, THS8200_DTG1_TOT_PIXELS_LSB, htotal(bt) & 0xff);\r\nths8200_write(sd, THS8200_DTG1_FRAME_FIELD_SZ_MSB,\r\n((vtotal(bt) >> 4) & 0xf0) + 0x7);\r\nths8200_write(sd, THS8200_DTG1_FRAME_SZ_LSB, vtotal(bt) & 0xff);\r\nif (!bt->interlaced)\r\nths8200_write(sd, THS8200_DTG1_FIELD_SZ_LSB, 0xff);\r\nths8200_write_and_or(sd, THS8200_DTG2_BP1_2_MSB, 0x88,\r\n((line_start_active_video >> 4) & 0x70) +\r\n((line_start_front_porch >> 8) & 0x07));\r\nths8200_write(sd, THS8200_DTG2_BP3_4_MSB, ((vtotal(bt)) >> 4) & 0x70);\r\nths8200_write(sd, THS8200_DTG2_BP1_LSB, line_start_active_video & 0xff);\r\nths8200_write(sd, THS8200_DTG2_BP2_LSB, line_start_front_porch & 0xff);\r\nths8200_write(sd, THS8200_DTG2_BP3_LSB, (vtotal(bt)) & 0xff);\r\nths8200_write(sd, THS8200_DTG2_LINETYPE1, 0x90);\r\nths8200_write(sd, THS8200_DTG2_LINETYPE2, 0x90);\r\nths8200_write(sd, THS8200_DTG2_HLENGTH_LSB, bt->hsync & 0xff);\r\nths8200_write_and_or(sd, THS8200_DTG2_HLENGTH_LSB_HDLY_MSB, 0x3f,\r\n(bt->hsync >> 2) & 0xc0);\r\nths8200_write_and_or(sd, THS8200_DTG2_HLENGTH_LSB_HDLY_MSB, 0xe0,\r\n(htotal(bt) >> 8) & 0x1f);\r\nths8200_write(sd, THS8200_DTG2_HLENGTH_HDLY_LSB, htotal(bt));\r\nths8200_write(sd, THS8200_DTG2_VLENGTH1_LSB, (bt->vsync + 1) & 0xff);\r\nths8200_write_and_or(sd, THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB, 0x3f,\r\n((bt->vsync + 1) >> 2) & 0xc0);\r\nths8200_write_and_or(sd, THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB, 0xf8,\r\n((vtotal(bt) + 1) >> 8) & 0x7);\r\nths8200_write(sd, THS8200_DTG2_VDLY1_LSB, vtotal(bt) + 1);\r\nths8200_write(sd, THS8200_DTG2_VLENGTH2_LSB, 0x00);\r\nths8200_write(sd, THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB, 0x07);\r\nths8200_write(sd, THS8200_DTG2_VDLY2_LSB, 0xff);\r\nths8200_write(sd, THS8200_DTG2_HS_IN_DLY_MSB, 0);\r\nths8200_write(sd, THS8200_DTG2_HS_IN_DLY_LSB, 0);\r\nths8200_write(sd, THS8200_DTG2_VS_IN_DLY_MSB, 0);\r\nths8200_write(sd, THS8200_DTG2_VS_IN_DLY_LSB, 0);\r\nif (bt->polarities & V4L2_DV_HSYNC_POS_POL) {\r\npolarity |= 0x01;\r\npolarity |= 0x08;\r\n}\r\nif (bt->polarities & V4L2_DV_VSYNC_POS_POL) {\r\npolarity |= 0x02;\r\npolarity |= 0x10;\r\n}\r\nths8200_write(sd, THS8200_DTG2_CNTL, 0x44 | polarity);\r\nths8200_s_stream(sd, true);\r\nv4l2_dbg(1, debug, sd, "%s: frame %dx%d, polarity %d\n"\r\n"horizontal: front porch %d, back porch %d, sync %d\n"\r\n"vertical: sync %d\n", __func__, htotal(bt), vtotal(bt),\r\npolarity, bt->hfrontporch, bt->hbackporch,\r\nbt->hsync, bt->vsync);\r\n}\r\nstatic int ths8200_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct ths8200_state *state = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (!v4l2_valid_dv_timings(timings, &ths8200_timings_cap,\r\nNULL, NULL))\r\nreturn -EINVAL;\r\nif (!v4l2_find_dv_timings_cap(timings, &ths8200_timings_cap, 10,\r\nNULL, NULL)) {\r\nv4l2_dbg(1, debug, sd, "Unsupported format\n");\r\nreturn -EINVAL;\r\n}\r\ntimings->bt.flags &= ~V4L2_DV_FL_REDUCED_FPS;\r\nstate->dv_timings = *timings;\r\nths8200_setup(sd, &timings->bt);\r\nreturn 0;\r\n}\r\nstatic int ths8200_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct ths8200_state *state = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\n*timings = state->dv_timings;\r\nreturn 0;\r\n}\r\nstatic int ths8200_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->pad != 0)\r\nreturn -EINVAL;\r\nreturn v4l2_enum_dv_timings_cap(timings, &ths8200_timings_cap,\r\nNULL, NULL);\r\n}\r\nstatic int ths8200_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nif (cap->pad != 0)\r\nreturn -EINVAL;\r\n*cap = ths8200_timings_cap;\r\nreturn 0;\r\n}\r\nstatic int ths8200_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ths8200_state *state;\r\nstruct v4l2_subdev *sd;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ths8200_ops);\r\nstate->chip_version = ths8200_read(sd, THS8200_VERSION);\r\nv4l2_dbg(1, debug, sd, "chip version 0x%x\n", state->chip_version);\r\nths8200_core_init(sd);\r\nerror = v4l2_async_register_subdev(&state->sd);\r\nif (error)\r\nreturn error;\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\n}\r\nstatic int ths8200_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ths8200_state *decoder = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s removed @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nths8200_s_power(sd, false);\r\nv4l2_async_unregister_subdev(&decoder->sd);\r\nreturn 0;\r\n}
