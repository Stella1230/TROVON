void menu_warn(struct menu *menu, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, fmt);\r\nfprintf(stderr, "%s:%d:warning: ", menu->file->name, menu->lineno);\r\nvfprintf(stderr, fmt, ap);\r\nfprintf(stderr, "\n");\r\nva_end(ap);\r\n}\r\nstatic void prop_warn(struct property *prop, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, fmt);\r\nfprintf(stderr, "%s:%d:warning: ", prop->file->name, prop->lineno);\r\nvfprintf(stderr, fmt, ap);\r\nfprintf(stderr, "\n");\r\nva_end(ap);\r\n}\r\nvoid _menu_init(void)\r\n{\r\ncurrent_entry = current_menu = &rootmenu;\r\nlast_entry_ptr = &rootmenu.list;\r\n}\r\nvoid menu_add_entry(struct symbol *sym)\r\n{\r\nstruct menu *menu;\r\nmenu = xmalloc(sizeof(*menu));\r\nmemset(menu, 0, sizeof(*menu));\r\nmenu->sym = sym;\r\nmenu->parent = current_menu;\r\nmenu->file = current_file;\r\nmenu->lineno = zconf_lineno();\r\n*last_entry_ptr = menu;\r\nlast_entry_ptr = &menu->next;\r\ncurrent_entry = menu;\r\nif (sym)\r\nmenu_add_symbol(P_SYMBOL, sym, NULL);\r\n}\r\nvoid menu_end_entry(void)\r\n{\r\n}\r\nstruct menu *menu_add_menu(void)\r\n{\r\nmenu_end_entry();\r\nlast_entry_ptr = &current_entry->list;\r\nreturn current_menu = current_entry;\r\n}\r\nvoid menu_end_menu(void)\r\n{\r\nlast_entry_ptr = &current_menu->next;\r\ncurrent_menu = current_menu->parent;\r\n}\r\nstatic struct expr *menu_check_dep(struct expr *e)\r\n{\r\nif (!e)\r\nreturn e;\r\nswitch (e->type) {\r\ncase E_NOT:\r\ne->left.expr = menu_check_dep(e->left.expr);\r\nbreak;\r\ncase E_OR:\r\ncase E_AND:\r\ne->left.expr = menu_check_dep(e->left.expr);\r\ne->right.expr = menu_check_dep(e->right.expr);\r\nbreak;\r\ncase E_SYMBOL:\r\nif (e->left.sym == &symbol_mod)\r\nreturn expr_alloc_and(e, expr_alloc_symbol(modules_sym));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn e;\r\n}\r\nvoid menu_add_dep(struct expr *dep)\r\n{\r\ncurrent_entry->dep = expr_alloc_and(current_entry->dep, menu_check_dep(dep));\r\n}\r\nvoid menu_set_type(int type)\r\n{\r\nstruct symbol *sym = current_entry->sym;\r\nif (sym->type == type)\r\nreturn;\r\nif (sym->type == S_UNKNOWN) {\r\nsym->type = type;\r\nreturn;\r\n}\r\nmenu_warn(current_entry,\r\n"ignoring type redefinition of '%s' from '%s' to '%s'",\r\nsym->name ? sym->name : "<choice>",\r\nsym_type_name(sym->type), sym_type_name(type));\r\n}\r\nstatic struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep)\r\n{\r\nstruct property *prop = prop_alloc(type, current_entry->sym);\r\nprop->menu = current_entry;\r\nprop->expr = expr;\r\nprop->visible.expr = menu_check_dep(dep);\r\nif (prompt) {\r\nif (isspace(*prompt)) {\r\nprop_warn(prop, "leading whitespace ignored");\r\nwhile (isspace(*prompt))\r\nprompt++;\r\n}\r\nif (current_entry->prompt && current_entry != &rootmenu)\r\nprop_warn(prop, "prompt redefined");\r\nif(type == P_PROMPT) {\r\nstruct menu *menu = current_entry;\r\nwhile ((menu = menu->parent) != NULL) {\r\nstruct expr *dup_expr;\r\nif (!menu->visibility)\r\ncontinue;\r\ndup_expr = expr_copy(menu->visibility);\r\nprop->visible.expr\r\n= expr_alloc_and(prop->visible.expr,\r\ndup_expr);\r\n}\r\n}\r\ncurrent_entry->prompt = prop;\r\n}\r\nprop->text = prompt;\r\nreturn prop;\r\n}\r\nstruct property *menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep)\r\n{\r\nreturn menu_add_prop(type, prompt, NULL, dep);\r\n}\r\nvoid menu_add_visibility(struct expr *expr)\r\n{\r\ncurrent_entry->visibility = expr_alloc_and(current_entry->visibility,\r\nexpr);\r\n}\r\nvoid menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)\r\n{\r\nmenu_add_prop(type, NULL, expr, dep);\r\n}\r\nvoid menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)\r\n{\r\nmenu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);\r\n}\r\nvoid menu_add_option(int token, char *arg)\r\n{\r\nswitch (token) {\r\ncase T_OPT_MODULES:\r\nif (modules_sym)\r\nzconf_error("symbol '%s' redefines option 'modules'"\r\n" already defined by symbol '%s'",\r\ncurrent_entry->sym->name,\r\nmodules_sym->name\r\n);\r\nmodules_sym = current_entry->sym;\r\nbreak;\r\ncase T_OPT_DEFCONFIG_LIST:\r\nif (!sym_defconfig_list)\r\nsym_defconfig_list = current_entry->sym;\r\nelse if (sym_defconfig_list != current_entry->sym)\r\nzconf_error("trying to redefine defconfig symbol");\r\nbreak;\r\ncase T_OPT_ENV:\r\nprop_add_env(arg);\r\nbreak;\r\ncase T_OPT_ALLNOCONFIG_Y:\r\ncurrent_entry->sym->flags |= SYMBOL_ALLNOCONFIG_Y;\r\nbreak;\r\n}\r\n}\r\nstatic int menu_validate_number(struct symbol *sym, struct symbol *sym2)\r\n{\r\nreturn sym2->type == S_INT || sym2->type == S_HEX ||\r\n(sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name));\r\n}\r\nstatic void sym_check_prop(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nstruct symbol *sym2;\r\nfor (prop = sym->prop; prop; prop = prop->next) {\r\nswitch (prop->type) {\r\ncase P_DEFAULT:\r\nif ((sym->type == S_STRING || sym->type == S_INT || sym->type == S_HEX) &&\r\nprop->expr->type != E_SYMBOL)\r\nprop_warn(prop,\r\n"default for config symbol '%s'"\r\n" must be a single symbol", sym->name);\r\nif (prop->expr->type != E_SYMBOL)\r\nbreak;\r\nsym2 = prop_get_symbol(prop);\r\nif (sym->type == S_HEX || sym->type == S_INT) {\r\nif (!menu_validate_number(sym, sym2))\r\nprop_warn(prop,\r\n"'%s': number is invalid",\r\nsym->name);\r\n}\r\nbreak;\r\ncase P_SELECT:\r\nsym2 = prop_get_symbol(prop);\r\nif (sym->type != S_BOOLEAN && sym->type != S_TRISTATE)\r\nprop_warn(prop,\r\n"config symbol '%s' uses select, but is "\r\n"not boolean or tristate", sym->name);\r\nelse if (sym2->type != S_UNKNOWN &&\r\nsym2->type != S_BOOLEAN &&\r\nsym2->type != S_TRISTATE)\r\nprop_warn(prop,\r\n"'%s' has wrong type. 'select' only "\r\n"accept arguments of boolean and "\r\n"tristate type", sym2->name);\r\nbreak;\r\ncase P_RANGE:\r\nif (sym->type != S_INT && sym->type != S_HEX)\r\nprop_warn(prop, "range is only allowed "\r\n"for int or hex symbols");\r\nif (!menu_validate_number(sym, prop->expr->left.sym) ||\r\n!menu_validate_number(sym, prop->expr->right.sym))\r\nprop_warn(prop, "range is invalid");\r\nbreak;\r\ndefault:\r\n;\r\n}\r\n}\r\n}\r\nvoid menu_finalize(struct menu *parent)\r\n{\r\nstruct menu *menu, *last_menu;\r\nstruct symbol *sym;\r\nstruct property *prop;\r\nstruct expr *parentdep, *basedep, *dep, *dep2, **ep;\r\nsym = parent->sym;\r\nif (parent->list) {\r\nif (sym && sym_is_choice(sym)) {\r\nif (sym->type == S_UNKNOWN) {\r\ncurrent_entry = parent;\r\nfor (menu = parent->list; menu; menu = menu->next) {\r\nif (menu->sym && menu->sym->type != S_UNKNOWN) {\r\nmenu_set_type(menu->sym->type);\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (menu = parent->list; menu; menu = menu->next) {\r\ncurrent_entry = menu;\r\nif (menu->sym && menu->sym->type == S_UNKNOWN)\r\nmenu_set_type(sym->type);\r\n}\r\nparentdep = expr_alloc_symbol(sym);\r\n} else if (parent->prompt)\r\nparentdep = parent->prompt->visible.expr;\r\nelse\r\nparentdep = parent->dep;\r\nfor (menu = parent->list; menu; menu = menu->next) {\r\nbasedep = expr_transform(menu->dep);\r\nbasedep = expr_alloc_and(expr_copy(parentdep), basedep);\r\nbasedep = expr_eliminate_dups(basedep);\r\nmenu->dep = basedep;\r\nif (menu->sym)\r\nprop = menu->sym->prop;\r\nelse\r\nprop = menu->prompt;\r\nfor (; prop; prop = prop->next) {\r\nif (prop->menu != menu)\r\ncontinue;\r\ndep = expr_transform(prop->visible.expr);\r\ndep = expr_alloc_and(expr_copy(basedep), dep);\r\ndep = expr_eliminate_dups(dep);\r\nif (menu->sym && menu->sym->type != S_TRISTATE)\r\ndep = expr_trans_bool(dep);\r\nprop->visible.expr = dep;\r\nif (prop->type == P_SELECT) {\r\nstruct symbol *es = prop_get_symbol(prop);\r\nes->rev_dep.expr = expr_alloc_or(es->rev_dep.expr,\r\nexpr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));\r\n}\r\n}\r\n}\r\nfor (menu = parent->list; menu; menu = menu->next)\r\nmenu_finalize(menu);\r\n} else if (sym) {\r\nbasedep = parent->prompt ? parent->prompt->visible.expr : NULL;\r\nbasedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);\r\nbasedep = expr_eliminate_dups(expr_transform(basedep));\r\nlast_menu = NULL;\r\nfor (menu = parent->next; menu; menu = menu->next) {\r\ndep = menu->prompt ? menu->prompt->visible.expr : menu->dep;\r\nif (!expr_contains_symbol(dep, sym))\r\nbreak;\r\nif (expr_depends_symbol(dep, sym))\r\ngoto next;\r\ndep = expr_trans_compare(dep, E_UNEQUAL, &symbol_no);\r\ndep = expr_eliminate_dups(expr_transform(dep));\r\ndep2 = expr_copy(basedep);\r\nexpr_eliminate_eq(&dep, &dep2);\r\nexpr_free(dep);\r\nif (!expr_is_yes(dep2)) {\r\nexpr_free(dep2);\r\nbreak;\r\n}\r\nexpr_free(dep2);\r\nnext:\r\nmenu_finalize(menu);\r\nmenu->parent = parent;\r\nlast_menu = menu;\r\n}\r\nif (last_menu) {\r\nparent->list = parent->next;\r\nparent->next = last_menu->next;\r\nlast_menu->next = NULL;\r\n}\r\nsym->dir_dep.expr = expr_alloc_or(sym->dir_dep.expr, parent->dep);\r\n}\r\nfor (menu = parent->list; menu; menu = menu->next) {\r\nif (sym && sym_is_choice(sym) &&\r\nmenu->sym && !sym_is_choice_value(menu->sym)) {\r\ncurrent_entry = menu;\r\nmenu->sym->flags |= SYMBOL_CHOICEVAL;\r\nif (!menu->prompt)\r\nmenu_warn(menu, "choice value must have a prompt");\r\nfor (prop = menu->sym->prop; prop; prop = prop->next) {\r\nif (prop->type == P_DEFAULT)\r\nprop_warn(prop, "defaults for choice "\r\n"values not supported");\r\nif (prop->menu == menu)\r\ncontinue;\r\nif (prop->type == P_PROMPT &&\r\nprop->menu->parent->sym != sym)\r\nprop_warn(prop, "choice value used outside its choice group");\r\n}\r\nif (sym->type == S_TRISTATE && menu->sym->type != S_TRISTATE) {\r\nbasedep = expr_alloc_comp(E_EQUAL, sym, &symbol_yes);\r\nmenu->dep = expr_alloc_and(basedep, menu->dep);\r\nfor (prop = menu->sym->prop; prop; prop = prop->next) {\r\nif (prop->menu != menu)\r\ncontinue;\r\nprop->visible.expr = expr_alloc_and(expr_copy(basedep),\r\nprop->visible.expr);\r\n}\r\n}\r\nmenu_add_symbol(P_CHOICE, sym, NULL);\r\nprop = sym_get_choice_prop(sym);\r\nfor (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)\r\n;\r\n*ep = expr_alloc_one(E_LIST, NULL);\r\n(*ep)->right.sym = menu->sym;\r\n}\r\nif (menu->list && (!menu->prompt || !menu->prompt->text)) {\r\nfor (last_menu = menu->list; ; last_menu = last_menu->next) {\r\nlast_menu->parent = parent;\r\nif (!last_menu->next)\r\nbreak;\r\n}\r\nlast_menu->next = menu->next;\r\nmenu->next = menu->list;\r\nmenu->list = NULL;\r\n}\r\n}\r\nif (sym && !(sym->flags & SYMBOL_WARNED)) {\r\nif (sym->type == S_UNKNOWN)\r\nmenu_warn(parent, "config symbol defined without type");\r\nif (sym_is_choice(sym) && !parent->prompt)\r\nmenu_warn(parent, "choice must have a prompt");\r\nsym_check_prop(sym);\r\nsym->flags |= SYMBOL_WARNED;\r\n}\r\nif (sym && !sym_is_optional(sym) && parent->prompt) {\r\nsym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr,\r\nexpr_alloc_and(parent->prompt->visible.expr,\r\nexpr_alloc_symbol(&symbol_mod)));\r\n}\r\n}\r\nbool menu_has_prompt(struct menu *menu)\r\n{\r\nif (!menu->prompt)\r\nreturn false;\r\nreturn true;\r\n}\r\nbool menu_is_empty(struct menu *menu)\r\n{\r\nstruct menu *child;\r\nfor (child = menu->list; child; child = child->next) {\r\nif (menu_is_visible(child))\r\nreturn(false);\r\n}\r\nreturn(true);\r\n}\r\nbool menu_is_visible(struct menu *menu)\r\n{\r\nstruct menu *child;\r\nstruct symbol *sym;\r\ntristate visible;\r\nif (!menu->prompt)\r\nreturn false;\r\nif (menu->visibility) {\r\nif (expr_calc_value(menu->visibility) == no)\r\nreturn false;\r\n}\r\nsym = menu->sym;\r\nif (sym) {\r\nsym_calc_value(sym);\r\nvisible = menu->prompt->visible.tri;\r\n} else\r\nvisible = menu->prompt->visible.tri = expr_calc_value(menu->prompt->visible.expr);\r\nif (visible != no)\r\nreturn true;\r\nif (!sym || sym_get_tristate_value(menu->sym) == no)\r\nreturn false;\r\nfor (child = menu->list; child; child = child->next) {\r\nif (menu_is_visible(child)) {\r\nif (sym)\r\nsym->flags |= SYMBOL_DEF_USER;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nconst char *menu_get_prompt(struct menu *menu)\r\n{\r\nif (menu->prompt)\r\nreturn menu->prompt->text;\r\nelse if (menu->sym)\r\nreturn menu->sym->name;\r\nreturn NULL;\r\n}\r\nstruct menu *menu_get_root_menu(struct menu *menu)\r\n{\r\nreturn &rootmenu;\r\n}\r\nstruct menu *menu_get_parent_menu(struct menu *menu)\r\n{\r\nenum prop_type type;\r\nfor (; menu != &rootmenu; menu = menu->parent) {\r\ntype = menu->prompt ? menu->prompt->type : 0;\r\nif (type == P_MENU)\r\nbreak;\r\n}\r\nreturn menu;\r\n}\r\nbool menu_has_help(struct menu *menu)\r\n{\r\nreturn menu->help != NULL;\r\n}\r\nconst char *menu_get_help(struct menu *menu)\r\n{\r\nif (menu->help)\r\nreturn menu->help;\r\nelse\r\nreturn "";\r\n}\r\nstatic void get_prompt_str(struct gstr *r, struct property *prop,\r\nstruct list_head *head)\r\n{\r\nint i, j;\r\nstruct menu *submenu[8], *menu, *location = NULL;\r\nstruct jump_key *jump = NULL;\r\nstr_printf(r, _("Prompt: %s\n"), _(prop->text));\r\nmenu = prop->menu->parent;\r\nfor (i = 0; menu != &rootmenu && i < 8; menu = menu->parent) {\r\nbool accessible = menu_is_visible(menu);\r\nsubmenu[i++] = menu;\r\nif (location == NULL && accessible)\r\nlocation = menu;\r\n}\r\nif (head && location) {\r\njump = xmalloc(sizeof(struct jump_key));\r\nif (menu_is_visible(prop->menu)) {\r\njump->target = prop->menu;\r\n} else\r\njump->target = location;\r\nif (list_empty(head))\r\njump->index = 0;\r\nelse\r\njump->index = list_entry(head->prev, struct jump_key,\r\nentries)->index + 1;\r\nlist_add_tail(&jump->entries, head);\r\n}\r\nif (i > 0) {\r\nstr_printf(r, _(" Location:\n"));\r\nfor (j = 4; --i >= 0; j += 2) {\r\nmenu = submenu[i];\r\nif (jump && menu == location)\r\njump->offset = strlen(r->s);\r\nstr_printf(r, "%*c-> %s", j, ' ',\r\n_(menu_get_prompt(menu)));\r\nif (menu->sym) {\r\nstr_printf(r, " (%s [=%s])", menu->sym->name ?\r\nmenu->sym->name : _("<choice>"),\r\nsym_get_string_value(menu->sym));\r\n}\r\nstr_append(r, "\n");\r\n}\r\n}\r\n}\r\nstatic struct property *get_symbol_prop(struct symbol *sym)\r\n{\r\nstruct property *prop = NULL;\r\nfor_all_properties(sym, prop, P_SYMBOL)\r\nbreak;\r\nreturn prop;\r\n}\r\nstatic void get_symbol_str(struct gstr *r, struct symbol *sym,\r\nstruct list_head *head)\r\n{\r\nbool hit;\r\nstruct property *prop;\r\nif (sym && sym->name) {\r\nstr_printf(r, "Symbol: %s [=%s]\n", sym->name,\r\nsym_get_string_value(sym));\r\nstr_printf(r, "Type : %s\n", sym_type_name(sym->type));\r\nif (sym->type == S_INT || sym->type == S_HEX) {\r\nprop = sym_get_range_prop(sym);\r\nif (prop) {\r\nstr_printf(r, "Range : ");\r\nexpr_gstr_print(prop->expr, r);\r\nstr_append(r, "\n");\r\n}\r\n}\r\n}\r\nfor_all_prompts(sym, prop)\r\nget_prompt_str(r, prop, head);\r\nprop = get_symbol_prop(sym);\r\nif (prop) {\r\nstr_printf(r, _(" Defined at %s:%d\n"), prop->menu->file->name,\r\nprop->menu->lineno);\r\nif (!expr_is_yes(prop->visible.expr)) {\r\nstr_append(r, _(" Depends on: "));\r\nexpr_gstr_print(prop->visible.expr, r);\r\nstr_append(r, "\n");\r\n}\r\n}\r\nhit = false;\r\nfor_all_properties(sym, prop, P_SELECT) {\r\nif (!hit) {\r\nstr_append(r, " Selects: ");\r\nhit = true;\r\n} else\r\nstr_printf(r, " && ");\r\nexpr_gstr_print(prop->expr, r);\r\n}\r\nif (hit)\r\nstr_append(r, "\n");\r\nif (sym->rev_dep.expr) {\r\nstr_append(r, _(" Selected by: "));\r\nexpr_gstr_print(sym->rev_dep.expr, r);\r\nstr_append(r, "\n");\r\n}\r\nstr_append(r, "\n\n");\r\n}\r\nstruct gstr get_relations_str(struct symbol **sym_arr, struct list_head *head)\r\n{\r\nstruct symbol *sym;\r\nstruct gstr res = str_new();\r\nint i;\r\nfor (i = 0; sym_arr && (sym = sym_arr[i]); i++)\r\nget_symbol_str(&res, sym, head);\r\nif (!i)\r\nstr_append(&res, _("No matches found.\n"));\r\nreturn res;\r\n}\r\nvoid menu_get_ext_help(struct menu *menu, struct gstr *help)\r\n{\r\nstruct symbol *sym = menu->sym;\r\nconst char *help_text = nohelp_text;\r\nif (menu_has_help(menu)) {\r\nif (sym->name)\r\nstr_printf(help, "%s%s:\n\n", CONFIG_, sym->name);\r\nhelp_text = menu_get_help(menu);\r\n}\r\nstr_printf(help, "%s\n", _(help_text));\r\nif (sym)\r\nget_symbol_str(help, sym, NULL);\r\n}
