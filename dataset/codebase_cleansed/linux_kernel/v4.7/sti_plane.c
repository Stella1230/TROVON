const char *sti_plane_to_str(struct sti_plane *plane)\r\n{\r\nswitch (plane->desc) {\r\ncase STI_GDP_0:\r\nreturn "GDP0";\r\ncase STI_GDP_1:\r\nreturn "GDP1";\r\ncase STI_GDP_2:\r\nreturn "GDP2";\r\ncase STI_GDP_3:\r\nreturn "GDP3";\r\ncase STI_HQVDP_0:\r\nreturn "HQVDP0";\r\ncase STI_CURSOR:\r\nreturn "CURSOR";\r\ndefault:\r\nreturn "<UNKNOWN PLANE>";\r\n}\r\n}\r\nstatic int sti_plane_timespec_ms_diff(struct timespec lhs, struct timespec rhs)\r\n{\r\nstruct timespec tmp_ts = timespec_sub(lhs, rhs);\r\nu64 tmp_ns = (u64)timespec_to_ns(&tmp_ts);\r\ndo_div(tmp_ns, NSEC_PER_MSEC);\r\nreturn (u32)tmp_ns;\r\n}\r\nvoid sti_plane_update_fps(struct sti_plane *plane,\r\nbool new_frame,\r\nbool new_field)\r\n{\r\nstruct timespec now;\r\nstruct sti_fps_info *fps;\r\nint fpks, fipks, ms_since_last, num_frames, num_fields;\r\ngetrawmonotonic(&now);\r\nfps = &plane->fps_info;\r\nif (new_field)\r\nfps->curr_field_counter++;\r\nif (!new_frame)\r\nreturn;\r\nfps->curr_frame_counter++;\r\nms_since_last = sti_plane_timespec_ms_diff(now, fps->last_timestamp);\r\nnum_frames = fps->curr_frame_counter - fps->last_frame_counter;\r\nif (num_frames <= 0 || ms_since_last < STI_FPS_INTERVAL_MS)\r\nreturn;\r\nfps->last_timestamp = now;\r\nfps->last_frame_counter = fps->curr_frame_counter;\r\nfpks = (num_frames * 1000000) / ms_since_last;\r\nsnprintf(plane->fps_info.fps_str, FPS_LENGTH, "%-6s @ %d.%.3d fps",\r\nsti_plane_to_str(plane), fpks / 1000, fpks % 1000);\r\nif (fps->curr_field_counter) {\r\nnum_fields = fps->curr_field_counter - fps->last_field_counter;\r\nfps->last_field_counter = fps->curr_field_counter;\r\nfipks = (num_fields * 1000000) / ms_since_last;\r\nsnprintf(plane->fps_info.fips_str,\r\nFPS_LENGTH, " - %d.%.3d field/sec",\r\nfipks / 1000, fipks % 1000);\r\n} else {\r\nplane->fps_info.fips_str[0] = '\0';\r\n}\r\nif (fps->output)\r\nDRM_INFO("%s%s\n",\r\nplane->fps_info.fps_str,\r\nplane->fps_info.fips_str);\r\n}\r\nstatic void sti_plane_destroy(struct drm_plane *drm_plane)\r\n{\r\nDRM_DEBUG_DRIVER("\n");\r\ndrm_plane_helper_disable(drm_plane);\r\ndrm_plane_cleanup(drm_plane);\r\n}\r\nstatic int sti_plane_set_property(struct drm_plane *drm_plane,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = drm_plane->dev;\r\nstruct sti_private *private = dev->dev_private;\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nDRM_DEBUG_DRIVER("\n");\r\nif (property == private->plane_zorder_property) {\r\nplane->zorder = val;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void sti_plane_attach_zorder_property(struct drm_plane *drm_plane)\r\n{\r\nstruct drm_device *dev = drm_plane->dev;\r\nstruct sti_private *private = dev->dev_private;\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct drm_property *prop;\r\nprop = private->plane_zorder_property;\r\nif (!prop) {\r\nprop = drm_property_create_range(dev, 0, "zpos", 1,\r\nGAM_MIXER_NB_DEPTH_LEVEL);\r\nif (!prop)\r\nreturn;\r\nprivate->plane_zorder_property = prop;\r\n}\r\ndrm_object_attach_property(&drm_plane->base, prop, plane->zorder);\r\n}\r\nvoid sti_plane_init_property(struct sti_plane *plane,\r\nenum drm_plane_type type)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(sti_plane_default_zorder); i++)\r\nif (sti_plane_default_zorder[i] == plane->desc)\r\nbreak;\r\nplane->zorder = i + 1;\r\nif (type == DRM_PLANE_TYPE_OVERLAY)\r\nsti_plane_attach_zorder_property(&plane->drm_plane);\r\nDRM_DEBUG_DRIVER("drm plane:%d mapped to %s with zorder:%d\n",\r\nplane->drm_plane.base.id,\r\nsti_plane_to_str(plane), plane->zorder);\r\n}
