static void swap_copy16(u16 *dest, const u16 *source, unsigned int bytes)\r\n{\r\nunsigned int i = 0;\r\nwhile (i < (bytes / 2)) {\r\ndest[i] = swap16(source[i]);\r\ni++;\r\n}\r\n}\r\nstatic void swap_copy24(u8 *dest, const u8 *source, unsigned int bytes)\r\n{\r\nunsigned int i = 0;\r\nwhile (i < bytes - 2) {\r\ndest[i] = source[i + 2];\r\ndest[i + 1] = source[i + 1];\r\ndest[i + 2] = source[i];\r\ni += 3;\r\n}\r\n}\r\nstatic void swap_copy32(u32 *dest, const u32 *source, unsigned int bytes)\r\n{\r\nunsigned int i = 0;\r\nwhile (i < bytes / 4) {\r\ndest[i] = swap32(source[i]);\r\ni++;\r\n}\r\n}\r\nstatic void alsa_to_most_memcpy(void *alsa, void *most, unsigned int bytes)\r\n{\r\nmemcpy(most, alsa, bytes);\r\n}\r\nstatic void alsa_to_most_copy16(void *alsa, void *most, unsigned int bytes)\r\n{\r\nswap_copy16(most, alsa, bytes);\r\n}\r\nstatic void alsa_to_most_copy24(void *alsa, void *most, unsigned int bytes)\r\n{\r\nswap_copy24(most, alsa, bytes);\r\n}\r\nstatic void alsa_to_most_copy32(void *alsa, void *most, unsigned int bytes)\r\n{\r\nswap_copy32(most, alsa, bytes);\r\n}\r\nstatic void most_to_alsa_memcpy(void *alsa, void *most, unsigned int bytes)\r\n{\r\nmemcpy(alsa, most, bytes);\r\n}\r\nstatic void most_to_alsa_copy16(void *alsa, void *most, unsigned int bytes)\r\n{\r\nswap_copy16(alsa, most, bytes);\r\n}\r\nstatic void most_to_alsa_copy24(void *alsa, void *most, unsigned int bytes)\r\n{\r\nswap_copy24(alsa, most, bytes);\r\n}\r\nstatic void most_to_alsa_copy32(void *alsa, void *most, unsigned int bytes)\r\n{\r\nswap_copy32(alsa, most, bytes);\r\n}\r\nstatic struct channel *get_channel(struct most_interface *iface,\r\nint channel_id)\r\n{\r\nstruct channel *channel, *tmp;\r\nlist_for_each_entry_safe(channel, tmp, &dev_list, list) {\r\nif ((channel->iface == iface) && (channel->id == channel_id))\r\nreturn channel;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool copy_data(struct channel *channel, struct mbo *mbo)\r\n{\r\nstruct snd_pcm_runtime *const runtime = channel->substream->runtime;\r\nunsigned int const frame_bytes = channel->cfg->subbuffer_size;\r\nunsigned int const buffer_size = runtime->buffer_size;\r\nunsigned int frames;\r\nunsigned int fr0;\r\nif (channel->cfg->direction & MOST_CH_RX)\r\nframes = mbo->processed_length / frame_bytes;\r\nelse\r\nframes = mbo->buffer_length / frame_bytes;\r\nfr0 = min(buffer_size - channel->buffer_pos, frames);\r\nchannel->copy_fn(runtime->dma_area + channel->buffer_pos * frame_bytes,\r\nmbo->virt_address,\r\nfr0 * frame_bytes);\r\nif (frames > fr0) {\r\nchannel->copy_fn(runtime->dma_area,\r\nmbo->virt_address + fr0 * frame_bytes,\r\n(frames - fr0) * frame_bytes);\r\n}\r\nchannel->buffer_pos += frames;\r\nif (channel->buffer_pos >= buffer_size)\r\nchannel->buffer_pos -= buffer_size;\r\nchannel->period_pos += frames;\r\nif (channel->period_pos >= runtime->period_size) {\r\nchannel->period_pos -= runtime->period_size;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int playback_thread(void *data)\r\n{\r\nstruct channel *const channel = data;\r\nwhile (!kthread_should_stop()) {\r\nstruct mbo *mbo = NULL;\r\nbool period_elapsed = false;\r\nint ret;\r\nwait_event_interruptible(\r\nchannel->playback_waitq,\r\nkthread_should_stop() ||\r\n(channel->is_stream_running &&\r\n(mbo = most_get_mbo(channel->iface, channel->id,\r\n&audio_aim))));\r\nif (!mbo)\r\ncontinue;\r\nif (channel->is_stream_running)\r\nperiod_elapsed = copy_data(channel, mbo);\r\nelse\r\nmemset(mbo->virt_address, 0, mbo->buffer_length);\r\nret = most_submit_mbo(mbo);\r\nif (ret)\r\nchannel->is_stream_running = false;\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(channel->substream);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct channel *channel = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct most_channel_config *cfg = channel->cfg;\r\nchannel->substream = substream;\r\nif (cfg->direction == MOST_CH_TX) {\r\nchannel->playback_task = kthread_run(playback_thread, channel,\r\n"most_audio_playback");\r\nif (IS_ERR(channel->playback_task)) {\r\npr_err("Couldn't start thread\n");\r\nreturn PTR_ERR(channel->playback_task);\r\n}\r\n}\r\nif (most_start_channel(channel->iface, channel->id, &audio_aim)) {\r\npr_err("most_start_channel() failed!\n");\r\nif (cfg->direction == MOST_CH_TX)\r\nkthread_stop(channel->playback_task);\r\nreturn -EBUSY;\r\n}\r\nruntime->hw = channel->pcm_hardware;\r\nreturn 0;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct channel *channel = substream->private_data;\r\nif (channel->cfg->direction == MOST_CH_TX)\r\nkthread_stop(channel->playback_task);\r\nmost_stop_channel(channel->iface, channel->id, &audio_aim);\r\nreturn 0;\r\n}\r\nstatic int pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct channel *channel = substream->private_data;\r\nif ((params_channels(hw_params) > channel->pcm_hardware.channels_max) ||\r\n(params_channels(hw_params) < channel->pcm_hardware.channels_min)) {\r\npr_err("Requested number of channels not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct channel *channel = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct most_channel_config *cfg = channel->cfg;\r\nint width = snd_pcm_format_physical_width(runtime->format);\r\nchannel->copy_fn = NULL;\r\nif (cfg->direction == MOST_CH_TX) {\r\nif (snd_pcm_format_big_endian(runtime->format) || width == 8)\r\nchannel->copy_fn = alsa_to_most_memcpy;\r\nelse if (width == 16)\r\nchannel->copy_fn = alsa_to_most_copy16;\r\nelse if (width == 24)\r\nchannel->copy_fn = alsa_to_most_copy24;\r\nelse if (width == 32)\r\nchannel->copy_fn = alsa_to_most_copy32;\r\n} else {\r\nif (snd_pcm_format_big_endian(runtime->format) || width == 8)\r\nchannel->copy_fn = most_to_alsa_memcpy;\r\nelse if (width == 16)\r\nchannel->copy_fn = most_to_alsa_copy16;\r\nelse if (width == 24)\r\nchannel->copy_fn = most_to_alsa_copy24;\r\nelse if (width == 32)\r\nchannel->copy_fn = most_to_alsa_copy32;\r\n}\r\nif (!channel->copy_fn) {\r\npr_err("unsupported format\n");\r\nreturn -EINVAL;\r\n}\r\nchannel->period_pos = 0;\r\nchannel->buffer_pos = 0;\r\nreturn 0;\r\n}\r\nstatic int pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct channel *channel = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nchannel->is_stream_running = true;\r\nwake_up_interruptible(&channel->playback_waitq);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nchannel->is_stream_running = false;\r\nreturn 0;\r\ndefault:\r\npr_info("pcm_trigger(), invalid\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct channel *channel = substream->private_data;\r\nreturn channel->buffer_pos;\r\n}\r\nstatic int split_arg_list(char *buf, char **card_name, char **pcm_format)\r\n{\r\n*card_name = strsep(&buf, ".");\r\nif (!*card_name)\r\nreturn -EIO;\r\n*pcm_format = strsep(&buf, ".\n");\r\nif (!*pcm_format)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int audio_set_hw_params(struct snd_pcm_hardware *pcm_hw,\r\nchar *pcm_format,\r\nstruct most_channel_config *cfg)\r\n{\r\npcm_hw->info = MOST_PCM_INFO;\r\npcm_hw->rates = SNDRV_PCM_RATE_48000;\r\npcm_hw->rate_min = 48000;\r\npcm_hw->rate_max = 48000;\r\npcm_hw->buffer_bytes_max = cfg->num_buffers * cfg->buffer_size;\r\npcm_hw->period_bytes_min = cfg->buffer_size;\r\npcm_hw->period_bytes_max = cfg->buffer_size;\r\npcm_hw->periods_min = 1;\r\npcm_hw->periods_max = cfg->num_buffers;\r\nif (!strcmp(pcm_format, "1x8")) {\r\nif (cfg->subbuffer_size != 1)\r\ngoto error;\r\npr_info("PCM format is 8-bit mono\n");\r\npcm_hw->channels_min = 1;\r\npcm_hw->channels_max = 1;\r\npcm_hw->formats = SNDRV_PCM_FMTBIT_S8;\r\n} else if (!strcmp(pcm_format, "2x16")) {\r\nif (cfg->subbuffer_size != 4)\r\ngoto error;\r\npr_info("PCM format is 16-bit stereo\n");\r\npcm_hw->channels_min = 2;\r\npcm_hw->channels_max = 2;\r\npcm_hw->formats = SNDRV_PCM_FMTBIT_S16_LE |\r\nSNDRV_PCM_FMTBIT_S16_BE;\r\n} else if (!strcmp(pcm_format, "2x24")) {\r\nif (cfg->subbuffer_size != 6)\r\ngoto error;\r\npr_info("PCM format is 24-bit stereo\n");\r\npcm_hw->channels_min = 2;\r\npcm_hw->channels_max = 2;\r\npcm_hw->formats = SNDRV_PCM_FMTBIT_S24_3LE |\r\nSNDRV_PCM_FMTBIT_S24_3BE;\r\n} else if (!strcmp(pcm_format, "2x32")) {\r\nif (cfg->subbuffer_size != 8)\r\ngoto error;\r\npr_info("PCM format is 32-bit stereo\n");\r\npcm_hw->channels_min = 2;\r\npcm_hw->channels_max = 2;\r\npcm_hw->formats = SNDRV_PCM_FMTBIT_S32_LE |\r\nSNDRV_PCM_FMTBIT_S32_BE;\r\n} else if (!strcmp(pcm_format, "6x16")) {\r\nif (cfg->subbuffer_size != 12)\r\ngoto error;\r\npr_info("PCM format is 16-bit 5.1 multi channel\n");\r\npcm_hw->channels_min = 6;\r\npcm_hw->channels_max = 6;\r\npcm_hw->formats = SNDRV_PCM_FMTBIT_S16_LE |\r\nSNDRV_PCM_FMTBIT_S16_BE;\r\n} else {\r\npr_err("PCM format %s not supported\n", pcm_format);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\nerror:\r\npr_err("Audio resolution doesn't fit subbuffer size\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int audio_probe_channel(struct most_interface *iface, int channel_id,\r\nstruct most_channel_config *cfg,\r\nstruct kobject *parent, char *arg_list)\r\n{\r\nstruct channel *channel;\r\nstruct snd_card *card;\r\nstruct snd_pcm *pcm;\r\nint playback_count = 0;\r\nint capture_count = 0;\r\nint ret;\r\nint direction;\r\nchar *card_name;\r\nchar *pcm_format;\r\nif (!iface)\r\nreturn -EINVAL;\r\nif (cfg->data_type != MOST_CH_SYNC) {\r\npr_err("Incompatible channel type\n");\r\nreturn -EINVAL;\r\n}\r\nif (get_channel(iface, channel_id)) {\r\npr_err("channel (%s:%d) is already linked\n",\r\niface->description, channel_id);\r\nreturn -EINVAL;\r\n}\r\nif (cfg->direction == MOST_CH_TX) {\r\nplayback_count = 1;\r\ndirection = SNDRV_PCM_STREAM_PLAYBACK;\r\n} else {\r\ncapture_count = 1;\r\ndirection = SNDRV_PCM_STREAM_CAPTURE;\r\n}\r\nret = split_arg_list(arg_list, &card_name, &pcm_format);\r\nif (ret < 0) {\r\npr_info("PCM format missing\n");\r\nreturn ret;\r\n}\r\nret = snd_card_new(NULL, -1, card_name, THIS_MODULE,\r\nsizeof(*channel), &card);\r\nif (ret < 0)\r\nreturn ret;\r\nchannel = card->private_data;\r\nchannel->card = card;\r\nchannel->cfg = cfg;\r\nchannel->iface = iface;\r\nchannel->id = channel_id;\r\ninit_waitqueue_head(&channel->playback_waitq);\r\nif (audio_set_hw_params(&channel->pcm_hardware, pcm_format, cfg))\r\ngoto err_free_card;\r\nsnprintf(card->driver, sizeof(card->driver), "%s", DRIVER_NAME);\r\nsnprintf(card->shortname, sizeof(card->shortname), "Microchip MOST:%d",\r\ncard->number);\r\nsnprintf(card->longname, sizeof(card->longname), "%s at %s, ch %d",\r\ncard->shortname, iface->description, channel_id);\r\nret = snd_pcm_new(card, card_name, 0, playback_count,\r\ncapture_count, &pcm);\r\nif (ret < 0)\r\ngoto err_free_card;\r\npcm->private_data = channel;\r\nsnd_pcm_set_ops(pcm, direction, &pcm_ops);\r\nret = snd_card_register(card);\r\nif (ret < 0)\r\ngoto err_free_card;\r\nlist_add_tail(&channel->list, &dev_list);\r\nreturn 0;\r\nerr_free_card:\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nstatic int audio_disconnect_channel(struct most_interface *iface,\r\nint channel_id)\r\n{\r\nstruct channel *channel;\r\nchannel = get_channel(iface, channel_id);\r\nif (!channel) {\r\npr_err("sound_disconnect_channel(), invalid channel %d\n",\r\nchannel_id);\r\nreturn -EINVAL;\r\n}\r\nlist_del(&channel->list);\r\nsnd_card_free(channel->card);\r\nreturn 0;\r\n}\r\nstatic int audio_rx_completion(struct mbo *mbo)\r\n{\r\nstruct channel *channel = get_channel(mbo->ifp, mbo->hdm_channel_id);\r\nbool period_elapsed = false;\r\nif (!channel) {\r\npr_err("sound_rx_completion(), invalid channel %d\n",\r\nmbo->hdm_channel_id);\r\nreturn -EINVAL;\r\n}\r\nif (channel->is_stream_running)\r\nperiod_elapsed = copy_data(channel, mbo);\r\nmost_put_mbo(mbo);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(channel->substream);\r\nreturn 0;\r\n}\r\nstatic int audio_tx_completion(struct most_interface *iface, int channel_id)\r\n{\r\nstruct channel *channel = get_channel(iface, channel_id);\r\nif (!channel) {\r\npr_err("sound_tx_completion(), invalid channel %d\n",\r\nchannel_id);\r\nreturn -EINVAL;\r\n}\r\nwake_up_interruptible(&channel->playback_waitq);\r\nreturn 0;\r\n}\r\nstatic int __init audio_init(void)\r\n{\r\npr_info("init()\n");\r\nINIT_LIST_HEAD(&dev_list);\r\nreturn most_register_aim(&audio_aim);\r\n}\r\nstatic void __exit audio_exit(void)\r\n{\r\nstruct channel *channel, *tmp;\r\npr_info("exit()\n");\r\nlist_for_each_entry_safe(channel, tmp, &dev_list, list) {\r\nlist_del(&channel->list);\r\nsnd_card_free(channel->card);\r\n}\r\nmost_deregister_aim(&audio_aim);\r\n}
