static void be_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, DRV_VER, sizeof(drvinfo->version));\r\nif (!memcmp(adapter->fw_ver, adapter->fw_on_flash, FW_VER_LEN))\r\nstrlcpy(drvinfo->fw_version, adapter->fw_ver,\r\nsizeof(drvinfo->fw_version));\r\nelse\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%s [%s]", adapter->fw_ver, adapter->fw_on_flash);\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\n}\r\nstatic u32 lancer_cmd_get_file_len(struct be_adapter *adapter, u8 *file_name)\r\n{\r\nu32 data_read = 0, eof;\r\nu8 addn_status;\r\nstruct be_dma_mem data_len_cmd;\r\nmemset(&data_len_cmd, 0, sizeof(data_len_cmd));\r\nlancer_cmd_read_object(adapter, &data_len_cmd, 0, 0, file_name,\r\n&data_read, &eof, &addn_status);\r\nreturn data_read;\r\n}\r\nstatic int be_get_dump_len(struct be_adapter *adapter)\r\n{\r\nu32 dump_size = 0;\r\nif (lancer_chip(adapter))\r\ndump_size = lancer_cmd_get_file_len(adapter,\r\nLANCER_FW_DUMP_FILE);\r\nelse\r\ndump_size = adapter->fat_dump_len;\r\nreturn dump_size;\r\n}\r\nstatic int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,\r\nu32 buf_len, void *buf)\r\n{\r\nstruct be_dma_mem read_cmd;\r\nu32 read_len = 0, total_read_len = 0, chunk_size;\r\nu32 eof = 0;\r\nu8 addn_status;\r\nint status = 0;\r\nread_cmd.size = LANCER_READ_FILE_CHUNK;\r\nread_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev, read_cmd.size,\r\n&read_cmd.dma, GFP_ATOMIC);\r\nif (!read_cmd.va) {\r\ndev_err(&adapter->pdev->dev,\r\n"Memory allocation failure while reading dump\n");\r\nreturn -ENOMEM;\r\n}\r\nwhile ((total_read_len < buf_len) && !eof) {\r\nchunk_size = min_t(u32, (buf_len - total_read_len),\r\nLANCER_READ_FILE_CHUNK);\r\nchunk_size = ALIGN(chunk_size, 4);\r\nstatus = lancer_cmd_read_object(adapter, &read_cmd, chunk_size,\r\ntotal_read_len, file_name,\r\n&read_len, &eof, &addn_status);\r\nif (!status) {\r\nmemcpy(buf + total_read_len, read_cmd.va, read_len);\r\ntotal_read_len += read_len;\r\neof &= LANCER_READ_FILE_EOF_MASK;\r\n} else {\r\nstatus = -EIO;\r\nbreak;\r\n}\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, read_cmd.size, read_cmd.va,\r\nread_cmd.dma);\r\nreturn status;\r\n}\r\nstatic int be_read_dump_data(struct be_adapter *adapter, u32 dump_len,\r\nvoid *buf)\r\n{\r\nint status = 0;\r\nif (lancer_chip(adapter))\r\nstatus = lancer_cmd_read_file(adapter, LANCER_FW_DUMP_FILE,\r\ndump_len, buf);\r\nelse\r\nstatus = be_cmd_get_fat_dump(adapter, dump_len, buf);\r\nreturn status;\r\n}\r\nstatic int be_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *et)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nstruct be_aic_obj *aic = &adapter->aic_obj[0];\r\net->rx_coalesce_usecs = aic->prev_eqd;\r\net->rx_coalesce_usecs_high = aic->max_eqd;\r\net->rx_coalesce_usecs_low = aic->min_eqd;\r\net->tx_coalesce_usecs = aic->prev_eqd;\r\net->tx_coalesce_usecs_high = aic->max_eqd;\r\net->tx_coalesce_usecs_low = aic->min_eqd;\r\net->use_adaptive_rx_coalesce = aic->enable;\r\net->use_adaptive_tx_coalesce = aic->enable;\r\nreturn 0;\r\n}\r\nstatic int be_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *et)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nstruct be_aic_obj *aic = &adapter->aic_obj[0];\r\nstruct be_eq_obj *eqo;\r\nint i;\r\nfor_all_evt_queues(adapter, eqo, i) {\r\naic->enable = et->use_adaptive_rx_coalesce;\r\naic->max_eqd = min(et->rx_coalesce_usecs_high, BE_MAX_EQD);\r\naic->min_eqd = min(et->rx_coalesce_usecs_low, aic->max_eqd);\r\naic->et_eqd = min(et->rx_coalesce_usecs, aic->max_eqd);\r\naic->et_eqd = max(aic->et_eqd, aic->min_eqd);\r\naic++;\r\n}\r\nif (!et->use_adaptive_rx_coalesce && skyhawk_chip(adapter))\r\nbe_eqd_update(adapter, true);\r\nreturn 0;\r\n}\r\nstatic void be_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, uint64_t *data)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nstruct be_rx_obj *rxo;\r\nstruct be_tx_obj *txo;\r\nvoid *p;\r\nunsigned int i, j, base = 0, start;\r\nfor (i = 0; i < ETHTOOL_STATS_NUM; i++) {\r\np = (u8 *)&adapter->drv_stats + et_stats[i].offset;\r\ndata[i] = *(u32 *)p;\r\n}\r\nbase += ETHTOOL_STATS_NUM;\r\nfor_all_rx_queues(adapter, rxo, j) {\r\nstruct be_rx_stats *stats = rx_stats(rxo);\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&stats->sync);\r\ndata[base] = stats->rx_bytes;\r\ndata[base + 1] = stats->rx_pkts;\r\n} while (u64_stats_fetch_retry_irq(&stats->sync, start));\r\nfor (i = 2; i < ETHTOOL_RXSTATS_NUM; i++) {\r\np = (u8 *)stats + et_rx_stats[i].offset;\r\ndata[base + i] = *(u32 *)p;\r\n}\r\nbase += ETHTOOL_RXSTATS_NUM;\r\n}\r\nfor_all_tx_queues(adapter, txo, j) {\r\nstruct be_tx_stats *stats = tx_stats(txo);\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&stats->sync_compl);\r\ndata[base] = stats->tx_compl;\r\n} while (u64_stats_fetch_retry_irq(&stats->sync_compl, start));\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&stats->sync);\r\nfor (i = 1; i < ETHTOOL_TXSTATS_NUM; i++) {\r\np = (u8 *)stats + et_tx_stats[i].offset;\r\ndata[base + i] =\r\n(et_tx_stats[i].size == sizeof(u64)) ?\r\n*(u64 *)p : *(u32 *)p;\r\n}\r\n} while (u64_stats_fetch_retry_irq(&stats->sync, start));\r\nbase += ETHTOOL_TXSTATS_NUM;\r\n}\r\n}\r\nstatic void be_get_stat_strings(struct net_device *netdev, uint32_t stringset,\r\nuint8_t *data)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint i, j;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < ETHTOOL_STATS_NUM; i++) {\r\nmemcpy(data, et_stats[i].desc, ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < adapter->num_rx_qs; i++) {\r\nfor (j = 0; j < ETHTOOL_RXSTATS_NUM; j++) {\r\nsprintf(data, "rxq%d: %s", i,\r\net_rx_stats[j].desc);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\n}\r\nfor (i = 0; i < adapter->num_tx_qs; i++) {\r\nfor (j = 0; j < ETHTOOL_TXSTATS_NUM; j++) {\r\nsprintf(data, "txq%d: %s", i,\r\net_tx_stats[j].desc);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\n}\r\nbreak;\r\ncase ETH_SS_TEST:\r\nfor (i = 0; i < ETHTOOL_TESTS_NUM; i++) {\r\nmemcpy(data, et_self_tests[i], ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int be_get_sset_count(struct net_device *netdev, int stringset)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nreturn ETHTOOL_TESTS_NUM;\r\ncase ETH_SS_STATS:\r\nreturn ETHTOOL_STATS_NUM +\r\nadapter->num_rx_qs * ETHTOOL_RXSTATS_NUM +\r\nadapter->num_tx_qs * ETHTOOL_TXSTATS_NUM;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic u32 be_get_port_type(struct be_adapter *adapter)\r\n{\r\nu32 port;\r\nswitch (adapter->phy.interface_type) {\r\ncase PHY_TYPE_BASET_1GB:\r\ncase PHY_TYPE_BASEX_1GB:\r\ncase PHY_TYPE_SGMII:\r\nport = PORT_TP;\r\nbreak;\r\ncase PHY_TYPE_SFP_PLUS_10GB:\r\nif (adapter->phy.cable_type & SFP_PLUS_COPPER_CABLE)\r\nport = PORT_DA;\r\nelse\r\nport = PORT_FIBRE;\r\nbreak;\r\ncase PHY_TYPE_QSFP:\r\nif (adapter->phy.cable_type & QSFP_PLUS_CR4_CABLE)\r\nport = PORT_DA;\r\nelse\r\nport = PORT_FIBRE;\r\nbreak;\r\ncase PHY_TYPE_XFP_10GB:\r\ncase PHY_TYPE_SFP_1GB:\r\nport = PORT_FIBRE;\r\nbreak;\r\ncase PHY_TYPE_BASET_10GB:\r\nport = PORT_TP;\r\nbreak;\r\ndefault:\r\nport = PORT_OTHER;\r\n}\r\nreturn port;\r\n}\r\nstatic u32 convert_to_et_setting(struct be_adapter *adapter, u32 if_speeds)\r\n{\r\nu32 val = 0;\r\nswitch (adapter->phy.interface_type) {\r\ncase PHY_TYPE_BASET_1GB:\r\ncase PHY_TYPE_BASEX_1GB:\r\ncase PHY_TYPE_SGMII:\r\nval |= SUPPORTED_TP;\r\nif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\r\nval |= SUPPORTED_1000baseT_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_100MBPS)\r\nval |= SUPPORTED_100baseT_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_10MBPS)\r\nval |= SUPPORTED_10baseT_Full;\r\nbreak;\r\ncase PHY_TYPE_KX4_10GB:\r\nval |= SUPPORTED_Backplane;\r\nif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\r\nval |= SUPPORTED_1000baseKX_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\r\nval |= SUPPORTED_10000baseKX4_Full;\r\nbreak;\r\ncase PHY_TYPE_KR2_20GB:\r\nval |= SUPPORTED_Backplane;\r\nif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\r\nval |= SUPPORTED_10000baseKR_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_20GBPS)\r\nval |= SUPPORTED_20000baseKR2_Full;\r\nbreak;\r\ncase PHY_TYPE_KR_10GB:\r\nval |= SUPPORTED_Backplane |\r\nSUPPORTED_10000baseKR_Full;\r\nbreak;\r\ncase PHY_TYPE_KR4_40GB:\r\nval |= SUPPORTED_Backplane;\r\nif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\r\nval |= SUPPORTED_10000baseKR_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_40GBPS)\r\nval |= SUPPORTED_40000baseKR4_Full;\r\nbreak;\r\ncase PHY_TYPE_QSFP:\r\nif (if_speeds & BE_SUPPORTED_SPEED_40GBPS) {\r\nswitch (adapter->phy.cable_type) {\r\ncase QSFP_PLUS_CR4_CABLE:\r\nval |= SUPPORTED_40000baseCR4_Full;\r\nbreak;\r\ncase QSFP_PLUS_LR4_CABLE:\r\nval |= SUPPORTED_40000baseLR4_Full;\r\nbreak;\r\ndefault:\r\nval |= SUPPORTED_40000baseSR4_Full;\r\nbreak;\r\n}\r\n}\r\ncase PHY_TYPE_SFP_PLUS_10GB:\r\ncase PHY_TYPE_XFP_10GB:\r\ncase PHY_TYPE_SFP_1GB:\r\nval |= SUPPORTED_FIBRE;\r\nif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\r\nval |= SUPPORTED_10000baseT_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\r\nval |= SUPPORTED_1000baseT_Full;\r\nbreak;\r\ncase PHY_TYPE_BASET_10GB:\r\nval |= SUPPORTED_TP;\r\nif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\r\nval |= SUPPORTED_10000baseT_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\r\nval |= SUPPORTED_1000baseT_Full;\r\nif (if_speeds & BE_SUPPORTED_SPEED_100MBPS)\r\nval |= SUPPORTED_100baseT_Full;\r\nbreak;\r\ndefault:\r\nval |= SUPPORTED_TP;\r\n}\r\nreturn val;\r\n}\r\nbool be_pause_supported(struct be_adapter *adapter)\r\n{\r\nreturn (adapter->phy.interface_type == PHY_TYPE_SFP_PLUS_10GB ||\r\nadapter->phy.interface_type == PHY_TYPE_XFP_10GB) ?\r\nfalse : true;\r\n}\r\nstatic int be_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nu8 link_status;\r\nu16 link_speed = 0;\r\nint status;\r\nu32 auto_speeds;\r\nu32 fixed_speeds;\r\nif (adapter->phy.link_speed < 0) {\r\nstatus = be_cmd_link_status_query(adapter, &link_speed,\r\n&link_status, 0);\r\nif (!status)\r\nbe_link_status_update(adapter, link_status);\r\nethtool_cmd_speed_set(ecmd, link_speed);\r\nstatus = be_cmd_get_phy_info(adapter);\r\nif (!status) {\r\nauto_speeds = adapter->phy.auto_speeds_supported;\r\nfixed_speeds = adapter->phy.fixed_speeds_supported;\r\nbe_cmd_query_cable_type(adapter);\r\necmd->supported =\r\nconvert_to_et_setting(adapter,\r\nauto_speeds |\r\nfixed_speeds);\r\necmd->advertising =\r\nconvert_to_et_setting(adapter, auto_speeds);\r\necmd->port = be_get_port_type(adapter);\r\nif (adapter->phy.auto_speeds_supported) {\r\necmd->supported |= SUPPORTED_Autoneg;\r\necmd->autoneg = AUTONEG_ENABLE;\r\necmd->advertising |= ADVERTISED_Autoneg;\r\n}\r\necmd->supported |= SUPPORTED_Pause;\r\nif (be_pause_supported(adapter))\r\necmd->advertising |= ADVERTISED_Pause;\r\nswitch (adapter->phy.interface_type) {\r\ncase PHY_TYPE_KR_10GB:\r\ncase PHY_TYPE_KX4_10GB:\r\necmd->transceiver = XCVR_INTERNAL;\r\nbreak;\r\ndefault:\r\necmd->transceiver = XCVR_EXTERNAL;\r\nbreak;\r\n}\r\n} else {\r\necmd->port = PORT_OTHER;\r\necmd->autoneg = AUTONEG_DISABLE;\r\necmd->transceiver = XCVR_DUMMY1;\r\n}\r\nadapter->phy.link_speed = ethtool_cmd_speed(ecmd);\r\nadapter->phy.port_type = ecmd->port;\r\nadapter->phy.transceiver = ecmd->transceiver;\r\nadapter->phy.autoneg = ecmd->autoneg;\r\nadapter->phy.advertising = ecmd->advertising;\r\nadapter->phy.supported = ecmd->supported;\r\n} else {\r\nethtool_cmd_speed_set(ecmd, adapter->phy.link_speed);\r\necmd->port = adapter->phy.port_type;\r\necmd->transceiver = adapter->phy.transceiver;\r\necmd->autoneg = adapter->phy.autoneg;\r\necmd->advertising = adapter->phy.advertising;\r\necmd->supported = adapter->phy.supported;\r\n}\r\necmd->duplex = netif_carrier_ok(netdev) ? DUPLEX_FULL : DUPLEX_UNKNOWN;\r\necmd->phy_address = adapter->port_num;\r\nreturn 0;\r\n}\r\nstatic void be_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nring->rx_max_pending = adapter->rx_obj[0].q.len;\r\nring->rx_pending = adapter->rx_obj[0].q.len;\r\nring->tx_max_pending = adapter->tx_obj[0].q.len;\r\nring->tx_pending = adapter->tx_obj[0].q.len;\r\n}\r\nstatic void\r\nbe_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *ecmd)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nbe_cmd_get_flow_control(adapter, &ecmd->tx_pause, &ecmd->rx_pause);\r\necmd->autoneg = adapter->phy.fc_autoneg;\r\n}\r\nstatic int\r\nbe_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *ecmd)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint status;\r\nif (ecmd->autoneg != adapter->phy.fc_autoneg)\r\nreturn -EINVAL;\r\nstatus = be_cmd_set_flow_control(adapter, ecmd->tx_pause,\r\necmd->rx_pause);\r\nif (status) {\r\ndev_warn(&adapter->pdev->dev, "Pause param set failed\n");\r\nreturn be_cmd_status(status);\r\n}\r\nadapter->tx_fc = ecmd->tx_pause;\r\nadapter->rx_fc = ecmd->rx_pause;\r\nreturn 0;\r\n}\r\nstatic int be_set_phys_id(struct net_device *netdev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint status = 0;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nstatus = be_cmd_get_beacon_state(adapter, adapter->hba_port_num,\r\n&adapter->beacon_state);\r\nif (status)\r\nreturn be_cmd_status(status);\r\nreturn 1;\r\ncase ETHTOOL_ID_ON:\r\nstatus = be_cmd_set_beacon_state(adapter, adapter->hba_port_num,\r\n0, 0, BEACON_STATE_ENABLED);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nstatus = be_cmd_set_beacon_state(adapter, adapter->hba_port_num,\r\n0, 0, BEACON_STATE_DISABLED);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nstatus = be_cmd_set_beacon_state(adapter, adapter->hba_port_num,\r\n0, 0, adapter->beacon_state);\r\n}\r\nreturn be_cmd_status(status);\r\n}\r\nstatic int be_set_dump(struct net_device *netdev, struct ethtool_dump *dump)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nstruct device *dev = &adapter->pdev->dev;\r\nint status;\r\nif (!lancer_chip(adapter) ||\r\n!check_privilege(adapter, MAX_PRIVILEGES))\r\nreturn -EOPNOTSUPP;\r\nswitch (dump->flag) {\r\ncase LANCER_INITIATE_FW_DUMP:\r\nstatus = lancer_initiate_dump(adapter);\r\nif (!status)\r\ndev_info(dev, "FW dump initiated successfully\n");\r\nbreak;\r\ncase LANCER_DELETE_FW_DUMP:\r\nstatus = lancer_delete_dump(adapter);\r\nif (!status)\r\ndev_info(dev, "FW dump deleted successfully\n");\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid dump level: 0x%x\n", dump->flag);\r\nreturn -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic void be_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->wol_cap & BE_WOL_CAP) {\r\nwol->supported |= WAKE_MAGIC;\r\nif (adapter->wol_en)\r\nwol->wolopts |= WAKE_MAGIC;\r\n} else {\r\nwol->wolopts = 0;\r\n}\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int be_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nif (wol->wolopts & ~WAKE_MAGIC)\r\nreturn -EOPNOTSUPP;\r\nif (!(adapter->wol_cap & BE_WOL_CAP)) {\r\ndev_warn(&adapter->pdev->dev, "WOL not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (wol->wolopts & WAKE_MAGIC)\r\nadapter->wol_en = true;\r\nelse\r\nadapter->wol_en = false;\r\nreturn 0;\r\n}\r\nstatic int be_test_ddr_dma(struct be_adapter *adapter)\r\n{\r\nint ret, i;\r\nstruct be_dma_mem ddrdma_cmd;\r\nstatic const u64 pattern[2] = {\r\n0x5a5a5a5a5a5a5a5aULL, 0xa5a5a5a5a5a5a5a5ULL\r\n};\r\nddrdma_cmd.size = sizeof(struct be_cmd_req_ddrdma_test);\r\nddrdma_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,\r\nddrdma_cmd.size, &ddrdma_cmd.dma,\r\nGFP_KERNEL);\r\nif (!ddrdma_cmd.va)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 2; i++) {\r\nret = be_cmd_ddr_dma_test(adapter, pattern[i],\r\n4096, &ddrdma_cmd);\r\nif (ret != 0)\r\ngoto err;\r\n}\r\nerr:\r\ndma_free_coherent(&adapter->pdev->dev, ddrdma_cmd.size, ddrdma_cmd.va,\r\nddrdma_cmd.dma);\r\nreturn be_cmd_status(ret);\r\n}\r\nstatic u64 be_loopback_test(struct be_adapter *adapter, u8 loopback_type,\r\nu64 *status)\r\n{\r\nint ret;\r\nret = be_cmd_set_loopback(adapter, adapter->hba_port_num,\r\nloopback_type, 1);\r\nif (ret)\r\nreturn ret;\r\n*status = be_cmd_loopback_test(adapter, adapter->hba_port_num,\r\nloopback_type, 1500, 2, 0xabc);\r\nret = be_cmd_set_loopback(adapter, adapter->hba_port_num,\r\nBE_NO_LOOPBACK, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn *status;\r\n}\r\nstatic void be_self_test(struct net_device *netdev, struct ethtool_test *test,\r\nu64 *data)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint status;\r\nu8 link_status = 0;\r\nif (adapter->function_caps & BE_FUNCTION_CAPS_SUPER_NIC) {\r\ndev_err(&adapter->pdev->dev, "Self test not supported\n");\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\nreturn;\r\n}\r\nmemset(data, 0, sizeof(u64) * ETHTOOL_TESTS_NUM);\r\nif (test->flags & ETH_TEST_FL_OFFLINE) {\r\nif (be_loopback_test(adapter, BE_MAC_LOOPBACK, &data[0]) != 0)\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\nif (be_loopback_test(adapter, BE_PHY_LOOPBACK, &data[1]) != 0)\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\nif (test->flags & ETH_TEST_FL_EXTERNAL_LB) {\r\nif (be_loopback_test(adapter, BE_ONE_PORT_EXT_LOOPBACK,\r\n&data[2]) != 0)\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\ntest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\r\n}\r\n}\r\nif (!lancer_chip(adapter) && be_test_ddr_dma(adapter) != 0) {\r\ndata[3] = 1;\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\n}\r\nstatus = be_cmd_link_status_query(adapter, NULL, &link_status, 0);\r\nif (status) {\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\ndata[4] = -1;\r\n} else if (!link_status) {\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\ndata[4] = 1;\r\n}\r\n}\r\nstatic int be_do_flash(struct net_device *netdev, struct ethtool_flash *efl)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nreturn be_load_fw(adapter, efl->data);\r\n}\r\nstatic int\r\nbe_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nif (!check_privilege(adapter, MAX_PRIVILEGES))\r\nreturn -EOPNOTSUPP;\r\ndump->len = be_get_dump_len(adapter);\r\ndump->version = 1;\r\ndump->flag = 0x1;\r\nreturn 0;\r\n}\r\nstatic int\r\nbe_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\r\nvoid *buf)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint status;\r\nif (!check_privilege(adapter, MAX_PRIVILEGES))\r\nreturn -EOPNOTSUPP;\r\nstatus = be_read_dump_data(adapter, dump->len, buf);\r\nreturn be_cmd_status(status);\r\n}\r\nstatic int be_get_eeprom_len(struct net_device *netdev)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nif (!check_privilege(adapter, MAX_PRIVILEGES))\r\nreturn 0;\r\nif (lancer_chip(adapter)) {\r\nif (be_physfn(adapter))\r\nreturn lancer_cmd_get_file_len(adapter,\r\nLANCER_VPD_PF_FILE);\r\nelse\r\nreturn lancer_cmd_get_file_len(adapter,\r\nLANCER_VPD_VF_FILE);\r\n} else {\r\nreturn BE_READ_SEEPROM_LEN;\r\n}\r\n}\r\nstatic int be_read_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, uint8_t *data)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nstruct be_dma_mem eeprom_cmd;\r\nstruct be_cmd_resp_seeprom_read *resp;\r\nint status;\r\nif (!eeprom->len)\r\nreturn -EINVAL;\r\nif (lancer_chip(adapter)) {\r\nif (be_physfn(adapter))\r\nreturn lancer_cmd_read_file(adapter, LANCER_VPD_PF_FILE,\r\neeprom->len, data);\r\nelse\r\nreturn lancer_cmd_read_file(adapter, LANCER_VPD_VF_FILE,\r\neeprom->len, data);\r\n}\r\neeprom->magic = BE_VENDOR_ID | (adapter->pdev->device<<16);\r\nmemset(&eeprom_cmd, 0, sizeof(struct be_dma_mem));\r\neeprom_cmd.size = sizeof(struct be_cmd_req_seeprom_read);\r\neeprom_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,\r\neeprom_cmd.size, &eeprom_cmd.dma,\r\nGFP_KERNEL);\r\nif (!eeprom_cmd.va)\r\nreturn -ENOMEM;\r\nstatus = be_cmd_get_seeprom_data(adapter, &eeprom_cmd);\r\nif (!status) {\r\nresp = eeprom_cmd.va;\r\nmemcpy(data, resp->seeprom_data + eeprom->offset, eeprom->len);\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, eeprom_cmd.size, eeprom_cmd.va,\r\neeprom_cmd.dma);\r\nreturn be_cmd_status(status);\r\n}\r\nstatic u32 be_get_msg_level(struct net_device *netdev)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void be_set_msg_level(struct net_device *netdev, u32 level)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->msg_enable == level)\r\nreturn;\r\nif ((level & NETIF_MSG_HW) != (adapter->msg_enable & NETIF_MSG_HW))\r\nif (BEx_chip(adapter))\r\nbe_cmd_set_fw_log_level(adapter, level & NETIF_MSG_HW ?\r\nFW_LOG_LEVEL_DEFAULT :\r\nFW_LOG_LEVEL_FATAL);\r\nadapter->msg_enable = level;\r\n}\r\nstatic u64 be_get_rss_hash_opts(struct be_adapter *adapter, u64 flow_type)\r\n{\r\nu64 data = 0;\r\nswitch (flow_type) {\r\ncase TCP_V4_FLOW:\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV4)\r\ndata |= RXH_IP_DST | RXH_IP_SRC;\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_TCP_IPV4)\r\ndata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV4)\r\ndata |= RXH_IP_DST | RXH_IP_SRC;\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_UDP_IPV4)\r\ndata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV6)\r\ndata |= RXH_IP_DST | RXH_IP_SRC;\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_TCP_IPV6)\r\ndata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV6)\r\ndata |= RXH_IP_DST | RXH_IP_SRC;\r\nif (adapter->rss_info.rss_flags & RSS_ENABLE_UDP_IPV6)\r\ndata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nbreak;\r\n}\r\nreturn data;\r\n}\r\nstatic int be_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nif (!be_multi_rxq(adapter)) {\r\ndev_info(&adapter->pdev->dev,\r\n"ethtool::get_rxnfc: RX flow hashing is disabled\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXFH:\r\ncmd->data = be_get_rss_hash_opts(adapter, cmd->flow_type);\r\nbreak;\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = adapter->num_rx_qs - 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int be_set_rss_hash_opts(struct be_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nint status;\r\nu32 rss_flags = adapter->rss_info.rss_flags;\r\nif (cmd->data != L3_RSS_FLAGS &&\r\ncmd->data != (L3_RSS_FLAGS | L4_RSS_FLAGS))\r\nreturn -EINVAL;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\nif (cmd->data == L3_RSS_FLAGS)\r\nrss_flags &= ~RSS_ENABLE_TCP_IPV4;\r\nelse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\r\nrss_flags |= RSS_ENABLE_IPV4 |\r\nRSS_ENABLE_TCP_IPV4;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\nif (cmd->data == L3_RSS_FLAGS)\r\nrss_flags &= ~RSS_ENABLE_TCP_IPV6;\r\nelse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\r\nrss_flags |= RSS_ENABLE_IPV6 |\r\nRSS_ENABLE_TCP_IPV6;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif ((cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS)) &&\r\nBEx_chip(adapter))\r\nreturn -EINVAL;\r\nif (cmd->data == L3_RSS_FLAGS)\r\nrss_flags &= ~RSS_ENABLE_UDP_IPV4;\r\nelse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\r\nrss_flags |= RSS_ENABLE_IPV4 |\r\nRSS_ENABLE_UDP_IPV4;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif ((cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS)) &&\r\nBEx_chip(adapter))\r\nreturn -EINVAL;\r\nif (cmd->data == L3_RSS_FLAGS)\r\nrss_flags &= ~RSS_ENABLE_UDP_IPV6;\r\nelse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\r\nrss_flags |= RSS_ENABLE_IPV6 |\r\nRSS_ENABLE_UDP_IPV6;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rss_flags == adapter->rss_info.rss_flags)\r\nreturn 0;\r\nstatus = be_cmd_rss_config(adapter, adapter->rss_info.rsstable,\r\nrss_flags, RSS_INDIR_TABLE_LEN,\r\nadapter->rss_info.rss_hkey);\r\nif (!status)\r\nadapter->rss_info.rss_flags = rss_flags;\r\nreturn be_cmd_status(status);\r\n}\r\nstatic int be_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint status = 0;\r\nif (!be_multi_rxq(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"ethtool::set_rxnfc: RX flow hashing is disabled\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nstatus = be_set_rss_hash_opts(adapter, cmd);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic void be_get_channels(struct net_device *netdev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nch->combined_count = adapter->num_evt_qs;\r\nch->max_combined = be_max_qs(adapter);\r\n}\r\nstatic int be_set_channels(struct net_device *netdev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint status;\r\nif (ch->rx_count || ch->tx_count || ch->other_count ||\r\n!ch->combined_count || ch->combined_count > be_max_qs(adapter))\r\nreturn -EINVAL;\r\nadapter->cfg_num_qs = ch->combined_count;\r\nstatus = be_update_queues(adapter);\r\nreturn be_cmd_status(status);\r\n}\r\nstatic u32 be_get_rxfh_indir_size(struct net_device *netdev)\r\n{\r\nreturn RSS_INDIR_TABLE_LEN;\r\n}\r\nstatic u32 be_get_rxfh_key_size(struct net_device *netdev)\r\n{\r\nreturn RSS_HASH_KEY_LEN;\r\n}\r\nstatic int be_get_rxfh(struct net_device *netdev, u32 *indir, u8 *hkey,\r\nu8 *hfunc)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint i;\r\nstruct rss_info *rss = &adapter->rss_info;\r\nif (indir) {\r\nfor (i = 0; i < RSS_INDIR_TABLE_LEN; i++)\r\nindir[i] = rss->rss_queue[i];\r\n}\r\nif (hkey)\r\nmemcpy(hkey, rss->rss_hkey, RSS_HASH_KEY_LEN);\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nreturn 0;\r\n}\r\nstatic int be_set_rxfh(struct net_device *netdev, const u32 *indir,\r\nconst u8 *hkey, const u8 hfunc)\r\n{\r\nint rc = 0, i, j;\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nu8 rsstable[RSS_INDIR_TABLE_LEN];\r\nif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\r\nreturn -EOPNOTSUPP;\r\nif (indir) {\r\nstruct be_rx_obj *rxo;\r\nfor (i = 0; i < RSS_INDIR_TABLE_LEN; i++) {\r\nj = indir[i];\r\nrxo = &adapter->rx_obj[j];\r\nrsstable[i] = rxo->rss_id;\r\nadapter->rss_info.rss_queue[i] = j;\r\n}\r\n} else {\r\nmemcpy(rsstable, adapter->rss_info.rsstable,\r\nRSS_INDIR_TABLE_LEN);\r\n}\r\nif (!hkey)\r\nhkey = adapter->rss_info.rss_hkey;\r\nrc = be_cmd_rss_config(adapter, rsstable,\r\nadapter->rss_info.rss_flags,\r\nRSS_INDIR_TABLE_LEN, hkey);\r\nif (rc) {\r\nadapter->rss_info.rss_flags = RSS_ENABLE_NONE;\r\nreturn -EIO;\r\n}\r\nmemcpy(adapter->rss_info.rss_hkey, hkey, RSS_HASH_KEY_LEN);\r\nmemcpy(adapter->rss_info.rsstable, rsstable,\r\nRSS_INDIR_TABLE_LEN);\r\nreturn 0;\r\n}\r\nstatic int be_get_module_info(struct net_device *netdev,\r\nstruct ethtool_modinfo *modinfo)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nu8 page_data[PAGE_DATA_LEN];\r\nint status;\r\nif (!check_privilege(adapter, MAX_PRIVILEGES))\r\nreturn -EOPNOTSUPP;\r\nstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,\r\npage_data);\r\nif (!status) {\r\nif (!page_data[SFP_PLUS_SFF_8472_COMP]) {\r\nmodinfo->type = ETH_MODULE_SFF_8079;\r\nmodinfo->eeprom_len = PAGE_DATA_LEN;\r\n} else {\r\nmodinfo->type = ETH_MODULE_SFF_8472;\r\nmodinfo->eeprom_len = 2 * PAGE_DATA_LEN;\r\n}\r\n}\r\nreturn be_cmd_status(status);\r\n}\r\nstatic int be_get_module_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev);\r\nint status;\r\nif (!check_privilege(adapter, MAX_PRIVILEGES))\r\nreturn -EOPNOTSUPP;\r\nstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,\r\ndata);\r\nif (status)\r\ngoto err;\r\nif (eeprom->offset + eeprom->len > PAGE_DATA_LEN) {\r\nstatus = be_cmd_read_port_transceiver_data(adapter,\r\nTR_PAGE_A2,\r\ndata +\r\nPAGE_DATA_LEN);\r\nif (status)\r\ngoto err;\r\n}\r\nif (eeprom->offset)\r\nmemcpy(data, data + eeprom->offset, eeprom->len);\r\nerr:\r\nreturn be_cmd_status(status);\r\n}
