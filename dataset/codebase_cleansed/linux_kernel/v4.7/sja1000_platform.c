static u8 sp_read_reg8(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg);\r\n}\r\nstatic void sp_write_reg8(const struct sja1000_priv *priv, int reg, u8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg);\r\n}\r\nstatic u8 sp_read_reg16(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg * 2);\r\n}\r\nstatic void sp_write_reg16(const struct sja1000_priv *priv, int reg, u8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg * 2);\r\n}\r\nstatic u8 sp_read_reg32(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg * 4);\r\n}\r\nstatic void sp_write_reg32(const struct sja1000_priv *priv, int reg, u8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg * 4);\r\n}\r\nstatic u8 sp_technologic_read_reg16(const struct sja1000_priv *priv, int reg)\r\n{\r\nstruct technologic_priv *tp = priv->priv;\r\nunsigned long flags;\r\nu8 val;\r\nspin_lock_irqsave(&tp->io_lock, flags);\r\niowrite16(reg, priv->reg_base + 0);\r\nval = ioread16(priv->reg_base + 2);\r\nspin_unlock_irqrestore(&tp->io_lock, flags);\r\nreturn val;\r\n}\r\nstatic void sp_technologic_write_reg16(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\nstruct technologic_priv *tp = priv->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tp->io_lock, flags);\r\niowrite16(reg, priv->reg_base + 0);\r\niowrite16(val, priv->reg_base + 2);\r\nspin_unlock_irqrestore(&tp->io_lock, flags);\r\n}\r\nstatic int sp_technologic_init(struct sja1000_priv *priv, struct device_node *of)\r\n{\r\nstruct technologic_priv *tp = priv->priv;\r\npriv->read_reg = sp_technologic_read_reg16;\r\npriv->write_reg = sp_technologic_write_reg16;\r\nspin_lock_init(&tp->io_lock);\r\nreturn 0;\r\n}\r\nstatic void sp_populate(struct sja1000_priv *priv,\r\nstruct sja1000_platform_data *pdata,\r\nunsigned long resource_mem_flags)\r\n{\r\npriv->can.clock.freq = pdata->osc_freq / 2;\r\npriv->ocr = pdata->ocr;\r\npriv->cdr = pdata->cdr;\r\nswitch (resource_mem_flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\npriv->read_reg = sp_read_reg32;\r\npriv->write_reg = sp_write_reg32;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\npriv->read_reg = sp_read_reg16;\r\npriv->write_reg = sp_write_reg16;\r\nbreak;\r\ncase IORESOURCE_MEM_8BIT:\r\ndefault:\r\npriv->read_reg = sp_read_reg8;\r\npriv->write_reg = sp_write_reg8;\r\nbreak;\r\n}\r\n}\r\nstatic void sp_populate_of(struct sja1000_priv *priv, struct device_node *of)\r\n{\r\nint err;\r\nu32 prop;\r\nerr = of_property_read_u32(of, "reg-io-width", &prop);\r\nif (err)\r\nprop = 1;\r\nswitch (prop) {\r\ncase 4:\r\npriv->read_reg = sp_read_reg32;\r\npriv->write_reg = sp_write_reg32;\r\nbreak;\r\ncase 2:\r\npriv->read_reg = sp_read_reg16;\r\npriv->write_reg = sp_write_reg16;\r\nbreak;\r\ncase 1:\r\ndefault:\r\npriv->read_reg = sp_read_reg8;\r\npriv->write_reg = sp_write_reg8;\r\n}\r\nerr = of_property_read_u32(of, "nxp,external-clock-frequency", &prop);\r\nif (!err)\r\npriv->can.clock.freq = prop / 2;\r\nelse\r\npriv->can.clock.freq = SP_CAN_CLOCK;\r\nerr = of_property_read_u32(of, "nxp,tx-output-mode", &prop);\r\nif (!err)\r\npriv->ocr |= prop & OCR_MODE_MASK;\r\nelse\r\npriv->ocr |= OCR_MODE_NORMAL;\r\nerr = of_property_read_u32(of, "nxp,tx-output-config", &prop);\r\nif (!err)\r\npriv->ocr |= (prop << OCR_TX_SHIFT) & OCR_TX_MASK;\r\nelse\r\npriv->ocr |= OCR_TX0_PULLDOWN;\r\nerr = of_property_read_u32(of, "nxp,clock-out-frequency", &prop);\r\nif (!err && prop) {\r\nu32 divider = priv->can.clock.freq * 2 / prop;\r\nif (divider > 1)\r\npriv->cdr |= divider / 2 - 1;\r\nelse\r\npriv->cdr |= CDR_CLKOUT_MASK;\r\n} else {\r\npriv->cdr |= CDR_CLK_OFF;\r\n}\r\nif (!of_property_read_bool(of, "nxp,no-comparator-bypass"))\r\npriv->cdr |= CDR_CBP;\r\n}\r\nstatic int sp_probe(struct platform_device *pdev)\r\n{\r\nint err, irq = 0;\r\nvoid __iomem *addr;\r\nstruct net_device *dev;\r\nstruct sja1000_priv *priv;\r\nstruct resource *res_mem, *res_irq = NULL;\r\nstruct sja1000_platform_data *pdata;\r\nstruct device_node *of = pdev->dev.of_node;\r\nconst struct of_device_id *of_id;\r\nconst struct sja1000_of_data *of_data = NULL;\r\nsize_t priv_sz = 0;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata && !of) {\r\ndev_err(&pdev->dev, "No platform data provided!\n");\r\nreturn -ENODEV;\r\n}\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_mem)\r\nreturn -ENODEV;\r\nif (!devm_request_mem_region(&pdev->dev, res_mem->start,\r\nresource_size(res_mem), DRV_NAME))\r\nreturn -EBUSY;\r\naddr = devm_ioremap_nocache(&pdev->dev, res_mem->start,\r\nresource_size(res_mem));\r\nif (!addr)\r\nreturn -ENOMEM;\r\nif (of)\r\nirq = irq_of_parse_and_map(of, 0);\r\nelse\r\nres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq && !res_irq)\r\nreturn -ENODEV;\r\nof_id = of_match_device(sp_of_table, &pdev->dev);\r\nif (of_id && of_id->data) {\r\nof_data = of_id->data;\r\npriv_sz = of_data->priv_sz;\r\n}\r\ndev = alloc_sja1000dev(priv_sz);\r\nif (!dev)\r\nreturn -ENOMEM;\r\npriv = netdev_priv(dev);\r\nif (res_irq) {\r\nirq = res_irq->start;\r\npriv->irq_flags = res_irq->flags & IRQF_TRIGGER_MASK;\r\nif (res_irq->flags & IORESOURCE_IRQ_SHAREABLE)\r\npriv->irq_flags |= IRQF_SHARED;\r\n} else {\r\npriv->irq_flags = IRQF_SHARED;\r\n}\r\ndev->irq = irq;\r\npriv->reg_base = addr;\r\nif (of) {\r\nsp_populate_of(priv, of);\r\nif (of_data && of_data->init) {\r\nerr = of_data->init(priv, of);\r\nif (err)\r\ngoto exit_free;\r\n}\r\n} else {\r\nsp_populate(priv, pdata, res_mem->flags);\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_sja1000dev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_free;\r\n}\r\ndev_info(&pdev->dev, "%s device registered (reg_base=%p, irq=%d)\n",\r\nDRV_NAME, priv->reg_base, dev->irq);\r\nreturn 0;\r\nexit_free:\r\nfree_sja1000dev(dev);\r\nreturn err;\r\n}\r\nstatic int sp_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_sja1000dev(dev);\r\nfree_sja1000dev(dev);\r\nreturn 0;\r\n}
