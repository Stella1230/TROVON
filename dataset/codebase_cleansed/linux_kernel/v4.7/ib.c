static void rds_ib_nodev_connect(void)\r\n{\r\nstruct rds_ib_connection *ic;\r\nspin_lock(&ib_nodev_conns_lock);\r\nlist_for_each_entry(ic, &ib_nodev_conns, ib_node)\r\nrds_conn_connect_if_down(ic->conn);\r\nspin_unlock(&ib_nodev_conns_lock);\r\n}\r\nstatic void rds_ib_dev_shutdown(struct rds_ib_device *rds_ibdev)\r\n{\r\nstruct rds_ib_connection *ic;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rds_ibdev->spinlock, flags);\r\nlist_for_each_entry(ic, &rds_ibdev->conn_list, ib_node)\r\nrds_conn_drop(ic->conn);\r\nspin_unlock_irqrestore(&rds_ibdev->spinlock, flags);\r\n}\r\nstatic void rds_ib_dev_free(struct work_struct *work)\r\n{\r\nstruct rds_ib_ipaddr *i_ipaddr, *i_next;\r\nstruct rds_ib_device *rds_ibdev = container_of(work,\r\nstruct rds_ib_device, free_work);\r\nif (rds_ibdev->mr_8k_pool)\r\nrds_ib_destroy_mr_pool(rds_ibdev->mr_8k_pool);\r\nif (rds_ibdev->mr_1m_pool)\r\nrds_ib_destroy_mr_pool(rds_ibdev->mr_1m_pool);\r\nif (rds_ibdev->pd)\r\nib_dealloc_pd(rds_ibdev->pd);\r\nlist_for_each_entry_safe(i_ipaddr, i_next, &rds_ibdev->ipaddr_list, list) {\r\nlist_del(&i_ipaddr->list);\r\nkfree(i_ipaddr);\r\n}\r\nkfree(rds_ibdev);\r\n}\r\nvoid rds_ib_dev_put(struct rds_ib_device *rds_ibdev)\r\n{\r\nBUG_ON(atomic_read(&rds_ibdev->refcount) <= 0);\r\nif (atomic_dec_and_test(&rds_ibdev->refcount))\r\nqueue_work(rds_wq, &rds_ibdev->free_work);\r\n}\r\nstatic void rds_ib_add_one(struct ib_device *device)\r\n{\r\nstruct rds_ib_device *rds_ibdev;\r\nif (device->node_type != RDMA_NODE_IB_CA)\r\nreturn;\r\nrds_ibdev = kzalloc_node(sizeof(struct rds_ib_device), GFP_KERNEL,\r\nibdev_to_node(device));\r\nif (!rds_ibdev)\r\nreturn;\r\nspin_lock_init(&rds_ibdev->spinlock);\r\natomic_set(&rds_ibdev->refcount, 1);\r\nINIT_WORK(&rds_ibdev->free_work, rds_ib_dev_free);\r\nrds_ibdev->max_wrs = device->attrs.max_qp_wr;\r\nrds_ibdev->max_sge = min(device->attrs.max_sge, RDS_IB_MAX_SGE);\r\nrds_ibdev->has_fr = (device->attrs.device_cap_flags &\r\nIB_DEVICE_MEM_MGT_EXTENSIONS);\r\nrds_ibdev->has_fmr = (device->alloc_fmr && device->dealloc_fmr &&\r\ndevice->map_phys_fmr && device->unmap_fmr);\r\nrds_ibdev->use_fastreg = (rds_ibdev->has_fr && !rds_ibdev->has_fmr);\r\nrds_ibdev->fmr_max_remaps = device->attrs.max_map_per_fmr?: 32;\r\nrds_ibdev->max_1m_mrs = device->attrs.max_mr ?\r\nmin_t(unsigned int, (device->attrs.max_mr / 2),\r\nrds_ib_mr_1m_pool_size) : rds_ib_mr_1m_pool_size;\r\nrds_ibdev->max_8k_mrs = device->attrs.max_mr ?\r\nmin_t(unsigned int, ((device->attrs.max_mr / 2) * RDS_MR_8K_SCALE),\r\nrds_ib_mr_8k_pool_size) : rds_ib_mr_8k_pool_size;\r\nrds_ibdev->max_initiator_depth = device->attrs.max_qp_init_rd_atom;\r\nrds_ibdev->max_responder_resources = device->attrs.max_qp_rd_atom;\r\nrds_ibdev->dev = device;\r\nrds_ibdev->pd = ib_alloc_pd(device);\r\nif (IS_ERR(rds_ibdev->pd)) {\r\nrds_ibdev->pd = NULL;\r\ngoto put_dev;\r\n}\r\nrds_ibdev->mr_1m_pool =\r\nrds_ib_create_mr_pool(rds_ibdev, RDS_IB_MR_1M_POOL);\r\nif (IS_ERR(rds_ibdev->mr_1m_pool)) {\r\nrds_ibdev->mr_1m_pool = NULL;\r\ngoto put_dev;\r\n}\r\nrds_ibdev->mr_8k_pool =\r\nrds_ib_create_mr_pool(rds_ibdev, RDS_IB_MR_8K_POOL);\r\nif (IS_ERR(rds_ibdev->mr_8k_pool)) {\r\nrds_ibdev->mr_8k_pool = NULL;\r\ngoto put_dev;\r\n}\r\nrdsdebug("RDS/IB: max_mr = %d, max_wrs = %d, max_sge = %d, fmr_max_remaps = %d, max_1m_mrs = %d, max_8k_mrs = %d\n",\r\ndevice->attrs.max_fmr, rds_ibdev->max_wrs, rds_ibdev->max_sge,\r\nrds_ibdev->fmr_max_remaps, rds_ibdev->max_1m_mrs,\r\nrds_ibdev->max_8k_mrs);\r\npr_info("RDS/IB: %s: %s supported and preferred\n",\r\ndevice->name,\r\nrds_ibdev->use_fastreg ? "FRMR" : "FMR");\r\nINIT_LIST_HEAD(&rds_ibdev->ipaddr_list);\r\nINIT_LIST_HEAD(&rds_ibdev->conn_list);\r\ndown_write(&rds_ib_devices_lock);\r\nlist_add_tail_rcu(&rds_ibdev->list, &rds_ib_devices);\r\nup_write(&rds_ib_devices_lock);\r\natomic_inc(&rds_ibdev->refcount);\r\nib_set_client_data(device, &rds_ib_client, rds_ibdev);\r\natomic_inc(&rds_ibdev->refcount);\r\nrds_ib_nodev_connect();\r\nput_dev:\r\nrds_ib_dev_put(rds_ibdev);\r\n}\r\nstruct rds_ib_device *rds_ib_get_client_data(struct ib_device *device)\r\n{\r\nstruct rds_ib_device *rds_ibdev;\r\nrcu_read_lock();\r\nrds_ibdev = ib_get_client_data(device, &rds_ib_client);\r\nif (rds_ibdev)\r\natomic_inc(&rds_ibdev->refcount);\r\nrcu_read_unlock();\r\nreturn rds_ibdev;\r\n}\r\nstatic void rds_ib_remove_one(struct ib_device *device, void *client_data)\r\n{\r\nstruct rds_ib_device *rds_ibdev = client_data;\r\nif (!rds_ibdev)\r\nreturn;\r\nrds_ib_dev_shutdown(rds_ibdev);\r\nib_set_client_data(device, &rds_ib_client, NULL);\r\ndown_write(&rds_ib_devices_lock);\r\nlist_del_rcu(&rds_ibdev->list);\r\nup_write(&rds_ib_devices_lock);\r\nsynchronize_rcu();\r\nrds_ib_dev_put(rds_ibdev);\r\nrds_ib_dev_put(rds_ibdev);\r\n}\r\nstatic int rds_ib_conn_info_visitor(struct rds_connection *conn,\r\nvoid *buffer)\r\n{\r\nstruct rds_info_rdma_connection *iinfo = buffer;\r\nstruct rds_ib_connection *ic;\r\nif (conn->c_trans != &rds_ib_transport)\r\nreturn 0;\r\niinfo->src_addr = conn->c_laddr;\r\niinfo->dst_addr = conn->c_faddr;\r\nmemset(&iinfo->src_gid, 0, sizeof(iinfo->src_gid));\r\nmemset(&iinfo->dst_gid, 0, sizeof(iinfo->dst_gid));\r\nif (rds_conn_state(conn) == RDS_CONN_UP) {\r\nstruct rds_ib_device *rds_ibdev;\r\nstruct rdma_dev_addr *dev_addr;\r\nic = conn->c_transport_data;\r\ndev_addr = &ic->i_cm_id->route.addr.dev_addr;\r\nrdma_addr_get_sgid(dev_addr, (union ib_gid *) &iinfo->src_gid);\r\nrdma_addr_get_dgid(dev_addr, (union ib_gid *) &iinfo->dst_gid);\r\nrds_ibdev = ic->rds_ibdev;\r\niinfo->max_send_wr = ic->i_send_ring.w_nr;\r\niinfo->max_recv_wr = ic->i_recv_ring.w_nr;\r\niinfo->max_send_sge = rds_ibdev->max_sge;\r\nrds_ib_get_mr_info(rds_ibdev, iinfo);\r\n}\r\nreturn 1;\r\n}\r\nstatic void rds_ib_ic_info(struct socket *sock, unsigned int len,\r\nstruct rds_info_iterator *iter,\r\nstruct rds_info_lengths *lens)\r\n{\r\nrds_for_each_conn_info(sock, len, iter, lens,\r\nrds_ib_conn_info_visitor,\r\nsizeof(struct rds_info_rdma_connection));\r\n}\r\nstatic int rds_ib_laddr_check(struct net *net, __be32 addr)\r\n{\r\nint ret;\r\nstruct rdma_cm_id *cm_id;\r\nstruct sockaddr_in sin;\r\ncm_id = rdma_create_id(&init_net, NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\r\nif (IS_ERR(cm_id))\r\nreturn PTR_ERR(cm_id);\r\nmemset(&sin, 0, sizeof(sin));\r\nsin.sin_family = AF_INET;\r\nsin.sin_addr.s_addr = addr;\r\nret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\r\nif (ret || !cm_id->device ||\r\ncm_id->device->node_type != RDMA_NODE_IB_CA)\r\nret = -EADDRNOTAVAIL;\r\nrdsdebug("addr %pI4 ret %d node type %d\n",\r\n&addr, ret,\r\ncm_id->device ? cm_id->device->node_type : -1);\r\nrdma_destroy_id(cm_id);\r\nreturn ret;\r\n}\r\nstatic void rds_ib_unregister_client(void)\r\n{\r\nib_unregister_client(&rds_ib_client);\r\nflush_workqueue(rds_wq);\r\n}\r\nvoid rds_ib_exit(void)\r\n{\r\nrds_info_deregister_func(RDS_INFO_IB_CONNECTIONS, rds_ib_ic_info);\r\nrds_ib_unregister_client();\r\nrds_ib_destroy_nodev_conns();\r\nrds_ib_sysctl_exit();\r\nrds_ib_recv_exit();\r\nrds_trans_unregister(&rds_ib_transport);\r\nrds_ib_mr_exit();\r\n}\r\nint rds_ib_init(void)\r\n{\r\nint ret;\r\nINIT_LIST_HEAD(&rds_ib_devices);\r\nret = rds_ib_mr_init();\r\nif (ret)\r\ngoto out;\r\nret = ib_register_client(&rds_ib_client);\r\nif (ret)\r\ngoto out_mr_exit;\r\nret = rds_ib_sysctl_init();\r\nif (ret)\r\ngoto out_ibreg;\r\nret = rds_ib_recv_init();\r\nif (ret)\r\ngoto out_sysctl;\r\nret = rds_trans_register(&rds_ib_transport);\r\nif (ret)\r\ngoto out_recv;\r\nrds_info_register_func(RDS_INFO_IB_CONNECTIONS, rds_ib_ic_info);\r\ngoto out;\r\nout_recv:\r\nrds_ib_recv_exit();\r\nout_sysctl:\r\nrds_ib_sysctl_exit();\r\nout_ibreg:\r\nrds_ib_unregister_client();\r\nout_mr_exit:\r\nrds_ib_mr_exit();\r\nout:\r\nreturn ret;\r\n}
