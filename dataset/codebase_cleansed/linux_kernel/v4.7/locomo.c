static void locomo_handler(struct irq_desc *desc)\r\n{\r\nstruct locomo *lchip = irq_desc_get_chip_data(desc);\r\nint req, i;\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nreq = locomo_readl(lchip->base + LOCOMO_ICR) & 0x0f00;\r\nif (req) {\r\nunsigned int irq;\r\nirq = lchip->irq_base;\r\nfor (i = 0; i <= 3; i++, irq++) {\r\nif (req & (0x0100 << i)) {\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\n}\r\n}\r\nstatic void locomo_ack_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic void locomo_mask_irq(struct irq_data *d)\r\n{\r\nstruct locomo *lchip = irq_data_get_irq_chip_data(d);\r\nunsigned int r;\r\nr = locomo_readl(lchip->base + LOCOMO_ICR);\r\nr &= ~(0x0010 << (d->irq - lchip->irq_base));\r\nlocomo_writel(r, lchip->base + LOCOMO_ICR);\r\n}\r\nstatic void locomo_unmask_irq(struct irq_data *d)\r\n{\r\nstruct locomo *lchip = irq_data_get_irq_chip_data(d);\r\nunsigned int r;\r\nr = locomo_readl(lchip->base + LOCOMO_ICR);\r\nr |= (0x0010 << (d->irq - lchip->irq_base));\r\nlocomo_writel(r, lchip->base + LOCOMO_ICR);\r\n}\r\nstatic void locomo_setup_irq(struct locomo *lchip)\r\n{\r\nint irq = lchip->irq_base;\r\nirq_set_irq_type(lchip->irq, IRQ_TYPE_EDGE_FALLING);\r\nirq_set_chip_data(lchip->irq, lchip);\r\nirq_set_chained_handler(lchip->irq, locomo_handler);\r\nfor ( ; irq <= lchip->irq_base + 3; irq++) {\r\nirq_set_chip_and_handler(irq, &locomo_chip, handle_level_irq);\r\nirq_set_chip_data(irq, lchip);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\n}\r\nstatic void locomo_dev_release(struct device *_dev)\r\n{\r\nstruct locomo_dev *dev = LOCOMO_DEV(_dev);\r\nkfree(dev);\r\n}\r\nstatic int\r\nlocomo_init_one_child(struct locomo *lchip, struct locomo_dev_info *info)\r\n{\r\nstruct locomo_dev *dev;\r\nint ret;\r\ndev = kzalloc(sizeof(struct locomo_dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (lchip->dev->dma_mask) {\r\ndev->dma_mask = *lchip->dev->dma_mask;\r\ndev->dev.dma_mask = &dev->dma_mask;\r\n}\r\ndev_set_name(&dev->dev, "%s", info->name);\r\ndev->devid = info->devid;\r\ndev->dev.parent = lchip->dev;\r\ndev->dev.bus = &locomo_bus_type;\r\ndev->dev.release = locomo_dev_release;\r\ndev->dev.coherent_dma_mask = lchip->dev->coherent_dma_mask;\r\nif (info->offset)\r\ndev->mapbase = lchip->base + info->offset;\r\nelse\r\ndev->mapbase = 0;\r\ndev->length = info->length;\r\ndev->irq[0] = (lchip->irq_base == NO_IRQ) ?\r\nNO_IRQ : lchip->irq_base + info->irq[0];\r\nret = device_register(&dev->dev);\r\nif (ret) {\r\nout:\r\nkfree(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int locomo_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct locomo *lchip = platform_get_drvdata(dev);\r\nstruct locomo_save_data *save;\r\nunsigned long flags;\r\nsave = kmalloc(sizeof(struct locomo_save_data), GFP_KERNEL);\r\nif (!save)\r\nreturn -ENOMEM;\r\nlchip->saved_state = save;\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nsave->LCM_GPO = locomo_readl(lchip->base + LOCOMO_GPO);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_GPO);\r\nsave->LCM_SPICT = locomo_readl(lchip->base + LOCOMO_SPI + LOCOMO_SPICT);\r\nlocomo_writel(0x40, lchip->base + LOCOMO_SPI + LOCOMO_SPICT);\r\nsave->LCM_GPE = locomo_readl(lchip->base + LOCOMO_GPE);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_GPE);\r\nsave->LCM_ASD = locomo_readl(lchip->base + LOCOMO_ASD);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_ASD);\r\nsave->LCM_SPIMD = locomo_readl(lchip->base + LOCOMO_SPI + LOCOMO_SPIMD);\r\nlocomo_writel(0x3C14, lchip->base + LOCOMO_SPI + LOCOMO_SPIMD);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_PAIF);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_DAC);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_BACKLIGHT + LOCOMO_TC);\r\nif ((locomo_readl(lchip->base + LOCOMO_LED + LOCOMO_LPT0) & 0x88) && (locomo_readl(lchip->base + LOCOMO_LED + LOCOMO_LPT1) & 0x88))\r\nlocomo_writel(0x00, lchip->base + LOCOMO_C32K);\r\nelse\r\nlocomo_writel(0xc1, lchip->base + LOCOMO_C32K);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_TADC);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_AUDIO + LOCOMO_ACC);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int locomo_resume(struct platform_device *dev)\r\n{\r\nstruct locomo *lchip = platform_get_drvdata(dev);\r\nstruct locomo_save_data *save;\r\nunsigned long r;\r\nunsigned long flags;\r\nsave = lchip->saved_state;\r\nif (!save)\r\nreturn 0;\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nlocomo_writel(save->LCM_GPO, lchip->base + LOCOMO_GPO);\r\nlocomo_writel(save->LCM_SPICT, lchip->base + LOCOMO_SPI + LOCOMO_SPICT);\r\nlocomo_writel(save->LCM_GPE, lchip->base + LOCOMO_GPE);\r\nlocomo_writel(save->LCM_ASD, lchip->base + LOCOMO_ASD);\r\nlocomo_writel(save->LCM_SPIMD, lchip->base + LOCOMO_SPI + LOCOMO_SPIMD);\r\nlocomo_writel(0x00, lchip->base + LOCOMO_C32K);\r\nlocomo_writel(0x90, lchip->base + LOCOMO_TADC);\r\nlocomo_writel(0, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KSC);\r\nr = locomo_readl(lchip->base + LOCOMO_KEYBOARD + LOCOMO_KIC);\r\nr &= 0xFEFF;\r\nlocomo_writel(r, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KIC);\r\nlocomo_writel(0x1, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KCMD);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\nlchip->saved_state = NULL;\r\nkfree(save);\r\nreturn 0;\r\n}\r\nstatic int\r\n__locomo_probe(struct device *me, struct resource *mem, int irq)\r\n{\r\nstruct locomo_platform_data *pdata = me->platform_data;\r\nstruct locomo *lchip;\r\nunsigned long r;\r\nint i, ret = -ENODEV;\r\nlchip = kzalloc(sizeof(struct locomo), GFP_KERNEL);\r\nif (!lchip)\r\nreturn -ENOMEM;\r\nspin_lock_init(&lchip->lock);\r\nlchip->dev = me;\r\ndev_set_drvdata(lchip->dev, lchip);\r\nlchip->phys = mem->start;\r\nlchip->irq = irq;\r\nlchip->irq_base = (pdata) ? pdata->irq_base : NO_IRQ;\r\nlchip->base = ioremap(mem->start, PAGE_SIZE);\r\nif (!lchip->base) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nlocomo_writel(0, lchip->base + LOCOMO_ICR);\r\nlocomo_writel(0, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KIC);\r\nlocomo_writel(0, lchip->base + LOCOMO_GPO);\r\nlocomo_writel((LOCOMO_GPIO(1) | LOCOMO_GPIO(2) | LOCOMO_GPIO(13) | LOCOMO_GPIO(14))\r\n, lchip->base + LOCOMO_GPE);\r\nlocomo_writel((LOCOMO_GPIO(1) | LOCOMO_GPIO(2) | LOCOMO_GPIO(13) | LOCOMO_GPIO(14))\r\n, lchip->base + LOCOMO_GPD);\r\nlocomo_writel(0, lchip->base + LOCOMO_GIE);\r\nlocomo_writel(0, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);\r\nlocomo_writel(0, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALD);\r\nlocomo_writel(0, lchip->base + LOCOMO_LTINT);\r\nlocomo_writel(0, lchip->base + LOCOMO_SPI + LOCOMO_SPIIE);\r\nlocomo_writel(6 + 8 + 320 + 30 - 10, lchip->base + LOCOMO_ASD);\r\nr = locomo_readl(lchip->base + LOCOMO_ASD);\r\nr |= 0x8000;\r\nlocomo_writel(r, lchip->base + LOCOMO_ASD);\r\nlocomo_writel(6 + 8 + 320 + 30 - 10 - 128 + 4, lchip->base + LOCOMO_HSD);\r\nr = locomo_readl(lchip->base + LOCOMO_HSD);\r\nr |= 0x8000;\r\nlocomo_writel(r, lchip->base + LOCOMO_HSD);\r\nlocomo_writel(128 / 8, lchip->base + LOCOMO_HSC);\r\nlocomo_writel(0x80, lchip->base + LOCOMO_TADC);\r\nudelay(1000);\r\nr = locomo_readl(lchip->base + LOCOMO_TADC);\r\nr |= 0x10;\r\nlocomo_writel(r, lchip->base + LOCOMO_TADC);\r\nudelay(100);\r\nr = locomo_readl(lchip->base + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB | LOCOMO_DAC_SDAOEB;\r\nlocomo_writel(r, lchip->base + LOCOMO_DAC);\r\nr = locomo_readl(lchip->base + LOCOMO_VER);\r\nprintk(KERN_INFO "LoCoMo Chip: %lu%lu\n", (r >> 8), (r & 0xff));\r\nif (lchip->irq != NO_IRQ && lchip->irq_base != NO_IRQ)\r\nlocomo_setup_irq(lchip);\r\nfor (i = 0; i < ARRAY_SIZE(locomo_devices); i++)\r\nlocomo_init_one_child(lchip, &locomo_devices[i]);\r\nreturn 0;\r\nout:\r\nkfree(lchip);\r\nreturn ret;\r\n}\r\nstatic int locomo_remove_child(struct device *dev, void *data)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void __locomo_remove(struct locomo *lchip)\r\n{\r\ndevice_for_each_child(lchip->dev, NULL, locomo_remove_child);\r\nif (lchip->irq != NO_IRQ) {\r\nirq_set_chained_handler_and_data(lchip->irq, NULL, NULL);\r\n}\r\niounmap(lchip->base);\r\nkfree(lchip);\r\n}\r\nstatic int locomo_probe(struct platform_device *dev)\r\n{\r\nstruct resource *mem;\r\nint irq;\r\nmem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0)\r\nreturn -ENXIO;\r\nreturn __locomo_probe(&dev->dev, mem, irq);\r\n}\r\nstatic int locomo_remove(struct platform_device *dev)\r\n{\r\nstruct locomo *lchip = platform_get_drvdata(dev);\r\nif (lchip) {\r\n__locomo_remove(lchip);\r\nplatform_set_drvdata(dev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct locomo *locomo_chip_driver(struct locomo_dev *ldev)\r\n{\r\nreturn (struct locomo *)dev_get_drvdata(ldev->dev.parent);\r\n}\r\nvoid locomo_gpio_set_dir(struct device *dev, unsigned int bits, unsigned int dir)\r\n{\r\nstruct locomo *lchip = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int r;\r\nif (!lchip)\r\nreturn;\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nr = locomo_readl(lchip->base + LOCOMO_GPD);\r\nif (dir)\r\nr |= bits;\r\nelse\r\nr &= ~bits;\r\nlocomo_writel(r, lchip->base + LOCOMO_GPD);\r\nr = locomo_readl(lchip->base + LOCOMO_GPE);\r\nif (dir)\r\nr |= bits;\r\nelse\r\nr &= ~bits;\r\nlocomo_writel(r, lchip->base + LOCOMO_GPE);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\n}\r\nint locomo_gpio_read_level(struct device *dev, unsigned int bits)\r\n{\r\nstruct locomo *lchip = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int ret;\r\nif (!lchip)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nret = locomo_readl(lchip->base + LOCOMO_GPL);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\nret &= bits;\r\nreturn ret;\r\n}\r\nint locomo_gpio_read_output(struct device *dev, unsigned int bits)\r\n{\r\nstruct locomo *lchip = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int ret;\r\nif (!lchip)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nret = locomo_readl(lchip->base + LOCOMO_GPO);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\nret &= bits;\r\nreturn ret;\r\n}\r\nvoid locomo_gpio_write(struct device *dev, unsigned int bits, unsigned int set)\r\n{\r\nstruct locomo *lchip = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int r;\r\nif (!lchip)\r\nreturn;\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nr = locomo_readl(lchip->base + LOCOMO_GPO);\r\nif (set)\r\nr |= bits;\r\nelse\r\nr &= ~bits;\r\nlocomo_writel(r, lchip->base + LOCOMO_GPO);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\n}\r\nstatic void locomo_m62332_sendbit(void *mapbase, int bit)\r\n{\r\nunsigned int r;\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SCLOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nudelay(DAC_DATA_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SCLOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nudelay(DAC_SCL_LOW_HOLD_TIME);\r\nif (bit & 1) {\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SDAOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\n} else {\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SDAOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\n}\r\nudelay(DAC_DATA_SETUP_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\nudelay(DAC_SCL_HIGH_HOLD_TIME);\r\n}\r\nvoid locomo_m62332_senddata(struct locomo_dev *ldev, unsigned int dac_data, int channel)\r\n{\r\nstruct locomo *lchip = locomo_chip_driver(ldev);\r\nint i;\r\nunsigned char data;\r\nunsigned int r;\r\nvoid *mapbase = lchip->base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nudelay(DAC_BUS_FREE_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB | LOCOMO_DAC_SDAOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\nudelay(DAC_SCL_HIGH_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SDAOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_START_HOLD_TIME);\r\nudelay(DAC_DATA_HOLD_TIME);\r\ndata = (M62332_SLAVE_ADDR << 1) | M62332_W_BIT;\r\nfor (i = 1; i <= 8; i++) {\r\nlocomo_m62332_sendbit(mapbase, data >> (8 - i));\r\n}\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SCLOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nudelay(DAC_SCL_LOW_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SDAOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\nudelay(DAC_SCL_HIGH_HOLD_TIME);\r\nif (locomo_readl(mapbase + LOCOMO_DAC) & LOCOMO_DAC_SDAOEB) {\r\nprintk(KERN_WARNING "locomo: m62332_senddata Error 1\n");\r\ngoto out;\r\n}\r\ndata = M62332_SUB_ADDR + channel;\r\nfor (i = 1; i <= 8; i++) {\r\nlocomo_m62332_sendbit(mapbase, data >> (8 - i));\r\n}\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SCLOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nudelay(DAC_SCL_LOW_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SDAOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\nudelay(DAC_SCL_HIGH_HOLD_TIME);\r\nif (locomo_readl(mapbase + LOCOMO_DAC) & LOCOMO_DAC_SDAOEB) {\r\nprintk(KERN_WARNING "locomo: m62332_senddata Error 2\n");\r\ngoto out;\r\n}\r\nfor (i = 1; i <= 8; i++) {\r\nlocomo_m62332_sendbit(mapbase, dac_data >> (8 - i));\r\n}\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SCLOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nudelay(DAC_SCL_LOW_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SDAOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\nudelay(DAC_SCL_HIGH_HOLD_TIME);\r\nif (locomo_readl(mapbase + LOCOMO_DAC) & LOCOMO_DAC_SDAOEB) {\r\nprintk(KERN_WARNING "locomo: m62332_senddata Error 3\n");\r\n}\r\nout:\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr &= ~(LOCOMO_DAC_SCLOEB);\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nudelay(DAC_SCL_LOW_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\nudelay(DAC_SCL_HIGH_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SDAOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_HIGH_SETUP_TIME);\r\nudelay(DAC_SCL_HIGH_HOLD_TIME);\r\nr = locomo_readl(mapbase + LOCOMO_DAC);\r\nr |= LOCOMO_DAC_SCLOEB | LOCOMO_DAC_SDAOEB;\r\nlocomo_writel(r, mapbase + LOCOMO_DAC);\r\nudelay(DAC_LOW_SETUP_TIME);\r\nudelay(DAC_SCL_LOW_HOLD_TIME);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\n}\r\nvoid locomo_frontlight_set(struct locomo_dev *dev, int duty, int vr, int bpwf)\r\n{\r\nunsigned long flags;\r\nstruct locomo *lchip = locomo_chip_driver(dev);\r\nif (vr)\r\nlocomo_gpio_write(dev->dev.parent, LOCOMO_GPIO_FL_VR, 1);\r\nelse\r\nlocomo_gpio_write(dev->dev.parent, LOCOMO_GPIO_FL_VR, 0);\r\nspin_lock_irqsave(&lchip->lock, flags);\r\nlocomo_writel(bpwf, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);\r\nudelay(100);\r\nlocomo_writel(duty, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALD);\r\nlocomo_writel(bpwf | LOCOMO_ALC_EN, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);\r\nspin_unlock_irqrestore(&lchip->lock, flags);\r\n}\r\nstatic int locomo_match(struct device *_dev, struct device_driver *_drv)\r\n{\r\nstruct locomo_dev *dev = LOCOMO_DEV(_dev);\r\nstruct locomo_driver *drv = LOCOMO_DRV(_drv);\r\nreturn dev->devid == drv->devid;\r\n}\r\nstatic int locomo_bus_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct locomo_dev *ldev = LOCOMO_DEV(dev);\r\nstruct locomo_driver *drv = LOCOMO_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv && drv->suspend)\r\nret = drv->suspend(ldev, state);\r\nreturn ret;\r\n}\r\nstatic int locomo_bus_resume(struct device *dev)\r\n{\r\nstruct locomo_dev *ldev = LOCOMO_DEV(dev);\r\nstruct locomo_driver *drv = LOCOMO_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv && drv->resume)\r\nret = drv->resume(ldev);\r\nreturn ret;\r\n}\r\nstatic int locomo_bus_probe(struct device *dev)\r\n{\r\nstruct locomo_dev *ldev = LOCOMO_DEV(dev);\r\nstruct locomo_driver *drv = LOCOMO_DRV(dev->driver);\r\nint ret = -ENODEV;\r\nif (drv->probe)\r\nret = drv->probe(ldev);\r\nreturn ret;\r\n}\r\nstatic int locomo_bus_remove(struct device *dev)\r\n{\r\nstruct locomo_dev *ldev = LOCOMO_DEV(dev);\r\nstruct locomo_driver *drv = LOCOMO_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv->remove)\r\nret = drv->remove(ldev);\r\nreturn ret;\r\n}\r\nint locomo_driver_register(struct locomo_driver *driver)\r\n{\r\ndriver->drv.bus = &locomo_bus_type;\r\nreturn driver_register(&driver->drv);\r\n}\r\nvoid locomo_driver_unregister(struct locomo_driver *driver)\r\n{\r\ndriver_unregister(&driver->drv);\r\n}\r\nstatic int __init locomo_init(void)\r\n{\r\nint ret = bus_register(&locomo_bus_type);\r\nif (ret == 0)\r\nplatform_driver_register(&locomo_device_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit locomo_exit(void)\r\n{\r\nplatform_driver_unregister(&locomo_device_driver);\r\nbus_unregister(&locomo_bus_type);\r\n}
