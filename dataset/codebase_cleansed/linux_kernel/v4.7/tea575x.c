static void snd_tea575x_write(struct snd_tea575x *tea, unsigned int val)\r\n{\r\nu16 l;\r\nu8 data;\r\nif (tea->ops->write_val)\r\nreturn tea->ops->write_val(tea, val);\r\ntea->ops->set_direction(tea, 1);\r\nudelay(16);\r\nfor (l = 25; l > 0; l--) {\r\ndata = (val >> 24) & TEA575X_DATA;\r\nval <<= 1;\r\ntea->ops->set_pins(tea, data | TEA575X_WREN);\r\nudelay(2);\r\ntea->ops->set_pins(tea, data | TEA575X_WREN | TEA575X_CLK);\r\nudelay(2);\r\ntea->ops->set_pins(tea, data | TEA575X_WREN);\r\nudelay(2);\r\n}\r\nif (!tea->mute)\r\ntea->ops->set_pins(tea, 0);\r\n}\r\nstatic u32 snd_tea575x_read(struct snd_tea575x *tea)\r\n{\r\nu16 l, rdata;\r\nu32 data = 0;\r\nif (tea->ops->read_val)\r\nreturn tea->ops->read_val(tea);\r\ntea->ops->set_direction(tea, 0);\r\ntea->ops->set_pins(tea, 0);\r\nudelay(16);\r\nfor (l = 24; l--;) {\r\ntea->ops->set_pins(tea, TEA575X_CLK);\r\nudelay(2);\r\nif (!l)\r\ntea->tuned = tea->ops->get_pins(tea) & TEA575X_MOST ? 0 : 1;\r\ntea->ops->set_pins(tea, 0);\r\nudelay(2);\r\ndata <<= 1;\r\nrdata = tea->ops->get_pins(tea);\r\nif (!l)\r\ntea->stereo = (rdata & TEA575X_MOST) ? 0 : 1;\r\nif (rdata & TEA575X_DATA)\r\ndata++;\r\nudelay(2);\r\n}\r\nif (tea->mute)\r\ntea->ops->set_pins(tea, TEA575X_WREN);\r\nreturn data;\r\n}\r\nstatic u32 snd_tea575x_val_to_freq(struct snd_tea575x *tea, u32 val)\r\n{\r\nu32 freq = val & TEA575X_BIT_FREQ_MASK;\r\nif (freq == 0)\r\nreturn freq;\r\nswitch (tea->band) {\r\ncase BAND_FM:\r\nfreq *= 125;\r\nfreq /= 10;\r\nfreq -= TEA575X_FMIF;\r\nbreak;\r\ncase BAND_FM_JAPAN:\r\nfreq *= 125;\r\nfreq /= 10;\r\nfreq += TEA575X_FMIF;\r\nbreak;\r\ncase BAND_AM:\r\nfreq -= TEA575X_AMIF;\r\nbreak;\r\n}\r\nreturn clamp(freq * 16, bands[tea->band].rangelow,\r\nbands[tea->band].rangehigh);\r\n}\r\nstatic u32 snd_tea575x_get_freq(struct snd_tea575x *tea)\r\n{\r\nreturn snd_tea575x_val_to_freq(tea, snd_tea575x_read(tea));\r\n}\r\nvoid snd_tea575x_set_freq(struct snd_tea575x *tea)\r\n{\r\nu32 freq = tea->freq / 16;\r\nu32 band = 0;\r\nswitch (tea->band) {\r\ncase BAND_FM:\r\nband = TEA575X_BIT_BAND_FM;\r\nfreq += TEA575X_FMIF;\r\nfreq *= 10;\r\nfreq /= 125;\r\nbreak;\r\ncase BAND_FM_JAPAN:\r\nband = TEA575X_BIT_BAND_FM;\r\nfreq -= TEA575X_FMIF;\r\nfreq *= 10;\r\nfreq /= 125;\r\nbreak;\r\ncase BAND_AM:\r\nband = TEA575X_BIT_BAND_MW;\r\nfreq += TEA575X_AMIF;\r\nbreak;\r\n}\r\ntea->val &= ~(TEA575X_BIT_FREQ_MASK | TEA575X_BIT_BAND_MASK);\r\ntea->val |= band;\r\ntea->val |= freq & TEA575X_BIT_FREQ_MASK;\r\nsnd_tea575x_write(tea, tea->val);\r\ntea->freq = snd_tea575x_val_to_freq(tea, tea->val);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct snd_tea575x *tea = video_drvdata(file);\r\nstrlcpy(v->driver, tea->v4l2_dev->name, sizeof(v->driver));\r\nstrlcpy(v->card, tea->card, sizeof(v->card));\r\nstrlcat(v->card, tea->tea5759 ? " TEA5759" : " TEA5757", sizeof(v->card));\r\nstrlcpy(v->bus_info, tea->bus_info, sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nif (!tea->cannot_read_data)\r\nv->device_caps |= V4L2_CAP_HW_FREQ_SEEK;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nint snd_tea575x_enum_freq_bands(struct snd_tea575x *tea,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nint index;\r\nif (band->tuner != 0)\r\nreturn -EINVAL;\r\nswitch (band->index) {\r\ncase 0:\r\nif (tea->tea5759)\r\nindex = BAND_FM_JAPAN;\r\nelse\r\nindex = BAND_FM;\r\nbreak;\r\ncase 1:\r\nif (tea->has_am) {\r\nindex = BAND_AM;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*band = bands[index];\r\nif (!tea->cannot_read_data)\r\nband->capability |= V4L2_TUNER_CAP_HWSEEK_BOUNDED;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct snd_tea575x *tea = video_drvdata(file);\r\nreturn snd_tea575x_enum_freq_bands(tea, band);\r\n}\r\nint snd_tea575x_g_tuner(struct snd_tea575x *tea, struct v4l2_tuner *v)\r\n{\r\nstruct v4l2_frequency_band band_fm = { 0, };\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nsnd_tea575x_read(tea);\r\nsnd_tea575x_enum_freq_bands(tea, &band_fm);\r\nmemset(v, 0, sizeof(*v));\r\nstrlcpy(v->name, tea->has_am ? "FM/AM" : "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->capability = band_fm.capability;\r\nv->rangelow = tea->has_am ? bands[BAND_AM].rangelow : band_fm.rangelow;\r\nv->rangehigh = band_fm.rangehigh;\r\nv->rxsubchans = tea->stereo ? V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\r\nv->audmode = (tea->val & TEA575X_BIT_MONO) ?\r\nV4L2_TUNER_MODE_MONO : V4L2_TUNER_MODE_STEREO;\r\nv->signal = tea->tuned ? 0xffff : 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct snd_tea575x *tea = video_drvdata(file);\r\nreturn snd_tea575x_g_tuner(tea, v);\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct snd_tea575x *tea = video_drvdata(file);\r\nu32 orig_val = tea->val;\r\nif (v->index)\r\nreturn -EINVAL;\r\ntea->val &= ~TEA575X_BIT_MONO;\r\nif (v->audmode == V4L2_TUNER_MODE_MONO)\r\ntea->val |= TEA575X_BIT_MONO;\r\nif (tea->band != BAND_AM && tea->val != orig_val)\r\nsnd_tea575x_set_freq(tea);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct snd_tea575x *tea = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = tea->freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct snd_tea575x *tea = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nif (tea->has_am && f->frequency < (20000 * 16))\r\ntea->band = BAND_AM;\r\nelse if (tea->tea5759)\r\ntea->band = BAND_FM_JAPAN;\r\nelse\r\ntea->band = BAND_FM;\r\ntea->freq = clamp_t(u32, f->frequency, bands[tea->band].rangelow,\r\nbands[tea->band].rangehigh);\r\nsnd_tea575x_set_freq(tea);\r\nreturn 0;\r\n}\r\nint snd_tea575x_s_hw_freq_seek(struct file *file, struct snd_tea575x *tea,\r\nconst struct v4l2_hw_freq_seek *a)\r\n{\r\nunsigned long timeout;\r\nint i, spacing;\r\nif (tea->cannot_read_data)\r\nreturn -ENOTTY;\r\nif (a->tuner || a->wrap_around)\r\nreturn -EINVAL;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nif (a->rangelow || a->rangehigh) {\r\nfor (i = 0; i < ARRAY_SIZE(bands); i++) {\r\nif ((i == BAND_FM && tea->tea5759) ||\r\n(i == BAND_FM_JAPAN && !tea->tea5759) ||\r\n(i == BAND_AM && !tea->has_am))\r\ncontinue;\r\nif (bands[i].rangelow == a->rangelow &&\r\nbands[i].rangehigh == a->rangehigh)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(bands))\r\nreturn -EINVAL;\r\nif (i != tea->band) {\r\ntea->band = i;\r\ntea->freq = clamp(tea->freq, bands[i].rangelow,\r\nbands[i].rangehigh);\r\nsnd_tea575x_set_freq(tea);\r\n}\r\n}\r\nspacing = (tea->band == BAND_AM) ? 5 : 50;\r\ntea->val &= ~TEA575X_BIT_FREQ_MASK;\r\ntea->val |= TEA575X_BIT_SEARCH;\r\nif (a->seek_upward)\r\ntea->val |= TEA575X_BIT_UPDOWN;\r\nelse\r\ntea->val &= ~TEA575X_BIT_UPDOWN;\r\nsnd_tea575x_write(tea, tea->val);\r\ntimeout = jiffies + msecs_to_jiffies(10000);\r\nfor (;;) {\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nif (schedule_timeout_interruptible(msecs_to_jiffies(10))) {\r\ntea->val &= ~TEA575X_BIT_SEARCH;\r\nsnd_tea575x_set_freq(tea);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (!(snd_tea575x_read(tea) & TEA575X_BIT_SEARCH)) {\r\nu32 freq;\r\nfor (i = 0; i < 100; i++) {\r\nmsleep(10);\r\nfreq = snd_tea575x_get_freq(tea);\r\nif (freq)\r\nbreak;\r\n}\r\nif (freq == 0)\r\nbreak;\r\nif (abs(tea->freq - freq) < 16 * spacing ||\r\n(a->seek_upward && freq < tea->freq) ||\r\n(!a->seek_upward && freq > tea->freq)) {\r\nsnd_tea575x_write(tea, tea->val);\r\ncontinue;\r\n}\r\ntea->freq = freq;\r\ntea->val &= ~TEA575X_BIT_SEARCH;\r\nreturn 0;\r\n}\r\n}\r\ntea->val &= ~TEA575X_BIT_SEARCH;\r\nsnd_tea575x_set_freq(tea);\r\nreturn -ENODATA;\r\n}\r\nstatic int vidioc_s_hw_freq_seek(struct file *file, void *fh,\r\nconst struct v4l2_hw_freq_seek *a)\r\n{\r\nstruct snd_tea575x *tea = video_drvdata(file);\r\nreturn snd_tea575x_s_hw_freq_seek(file, tea, a);\r\n}\r\nstatic int tea575x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct snd_tea575x *tea = container_of(ctrl->handler, struct snd_tea575x, ctrl_handler);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ntea->mute = ctrl->val;\r\nsnd_tea575x_set_freq(tea);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint snd_tea575x_hw_init(struct snd_tea575x *tea)\r\n{\r\ntea->mute = true;\r\nif (!tea->cannot_read_data) {\r\nsnd_tea575x_write(tea, 0x55AA);\r\nif (snd_tea575x_read(tea) != 0x55AA)\r\nreturn -ENODEV;\r\n}\r\ntea->val = TEA575X_BIT_BAND_FM | TEA575X_BIT_SEARCH_5_28;\r\ntea->freq = 90500 * 16;\r\nsnd_tea575x_set_freq(tea);\r\nreturn 0;\r\n}\r\nint snd_tea575x_init(struct snd_tea575x *tea, struct module *owner)\r\n{\r\nint retval = snd_tea575x_hw_init(tea);\r\nif (retval)\r\nreturn retval;\r\ntea->vd = tea575x_radio;\r\nvideo_set_drvdata(&tea->vd, tea);\r\nmutex_init(&tea->mutex);\r\nstrlcpy(tea->vd.name, tea->v4l2_dev->name, sizeof(tea->vd.name));\r\ntea->vd.lock = &tea->mutex;\r\ntea->vd.v4l2_dev = tea->v4l2_dev;\r\ntea->fops = tea575x_fops;\r\ntea->fops.owner = owner;\r\ntea->vd.fops = &tea->fops;\r\nif (tea->cannot_read_data)\r\nv4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK);\r\nif (!tea->cannot_mute) {\r\ntea->vd.ctrl_handler = &tea->ctrl_handler;\r\nv4l2_ctrl_handler_init(&tea->ctrl_handler, 1);\r\nv4l2_ctrl_new_std(&tea->ctrl_handler, &tea575x_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nretval = tea->ctrl_handler.error;\r\nif (retval) {\r\nv4l2_err(tea->v4l2_dev, "can't initialize controls\n");\r\nv4l2_ctrl_handler_free(&tea->ctrl_handler);\r\nreturn retval;\r\n}\r\nif (tea->ext_init) {\r\nretval = tea->ext_init(tea);\r\nif (retval) {\r\nv4l2_ctrl_handler_free(&tea->ctrl_handler);\r\nreturn retval;\r\n}\r\n}\r\nv4l2_ctrl_handler_setup(&tea->ctrl_handler);\r\n}\r\nretval = video_register_device(&tea->vd, VFL_TYPE_RADIO, tea->radio_nr);\r\nif (retval) {\r\nv4l2_err(tea->v4l2_dev, "can't register video device!\n");\r\nv4l2_ctrl_handler_free(tea->vd.ctrl_handler);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_tea575x_exit(struct snd_tea575x *tea)\r\n{\r\nvideo_unregister_device(&tea->vd);\r\nv4l2_ctrl_handler_free(tea->vd.ctrl_handler);\r\n}
