static int\r\ncc2520_cmd_strobe(struct cc2520_private *priv, u8 cmd)\r\n{\r\nint ret;\r\nu8 status = 0xff;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 0,\r\n.tx_buf = priv->buf,\r\n.rx_buf = priv->buf,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nmutex_lock(&priv->buffer_mutex);\r\npriv->buf[xfer.len++] = cmd;\r\ndev_vdbg(&priv->spi->dev,\r\n"command strobe buf[0] = %02x\n",\r\npriv->buf[0]);\r\nret = spi_sync(priv->spi, &msg);\r\nif (!ret)\r\nstatus = priv->buf[0];\r\ndev_vdbg(&priv->spi->dev,\r\n"buf[0] = %02x\n", priv->buf[0]);\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\ncc2520_get_status(struct cc2520_private *priv, u8 *status)\r\n{\r\nint ret;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 0,\r\n.tx_buf = priv->buf,\r\n.rx_buf = priv->buf,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nmutex_lock(&priv->buffer_mutex);\r\npriv->buf[xfer.len++] = CC2520_CMD_SNOP;\r\ndev_vdbg(&priv->spi->dev,\r\n"get status command buf[0] = %02x\n", priv->buf[0]);\r\nret = spi_sync(priv->spi, &msg);\r\nif (!ret)\r\n*status = priv->buf[0];\r\ndev_vdbg(&priv->spi->dev,\r\n"buf[0] = %02x\n", priv->buf[0]);\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\ncc2520_write_register(struct cc2520_private *priv, u8 reg, u8 value)\r\n{\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 0,\r\n.tx_buf = priv->buf,\r\n.rx_buf = priv->buf,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nmutex_lock(&priv->buffer_mutex);\r\nif (reg <= CC2520_FREG_MASK) {\r\npriv->buf[xfer.len++] = CC2520_CMD_REGISTER_WRITE | reg;\r\npriv->buf[xfer.len++] = value;\r\n} else {\r\npriv->buf[xfer.len++] = CC2520_CMD_MEMORY_WRITE;\r\npriv->buf[xfer.len++] = reg;\r\npriv->buf[xfer.len++] = value;\r\n}\r\nstatus = spi_sync(priv->spi, &msg);\r\nif (msg.status)\r\nstatus = msg.status;\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn status;\r\n}\r\nstatic int\r\ncc2520_write_ram(struct cc2520_private *priv, u16 reg, u8 len, u8 *data)\r\n{\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_head = {\r\n.len = 0,\r\n.tx_buf = priv->buf,\r\n.rx_buf = priv->buf,\r\n};\r\nstruct spi_transfer xfer_buf = {\r\n.len = len,\r\n.tx_buf = data,\r\n};\r\nmutex_lock(&priv->buffer_mutex);\r\npriv->buf[xfer_head.len++] = (CC2520_CMD_MEMORY_WRITE |\r\n((reg >> 8) & 0xff));\r\npriv->buf[xfer_head.len++] = reg & 0xff;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nstatus = spi_sync(priv->spi, &msg);\r\ndev_dbg(&priv->spi->dev, "spi status = %d\n", status);\r\nif (msg.status)\r\nstatus = msg.status;\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn status;\r\n}\r\nstatic int\r\ncc2520_read_register(struct cc2520_private *priv, u8 reg, u8 *data)\r\n{\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer1 = {\r\n.len = 0,\r\n.tx_buf = priv->buf,\r\n.rx_buf = priv->buf,\r\n};\r\nstruct spi_transfer xfer2 = {\r\n.len = 1,\r\n.rx_buf = data,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer1, &msg);\r\nspi_message_add_tail(&xfer2, &msg);\r\nmutex_lock(&priv->buffer_mutex);\r\npriv->buf[xfer1.len++] = CC2520_CMD_MEMORY_READ;\r\npriv->buf[xfer1.len++] = reg;\r\nstatus = spi_sync(priv->spi, &msg);\r\ndev_dbg(&priv->spi->dev,\r\n"spi status = %d\n", status);\r\nif (msg.status)\r\nstatus = msg.status;\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn status;\r\n}\r\nstatic int\r\ncc2520_write_txfifo(struct cc2520_private *priv, u8 pkt_len, u8 *data, u8 len)\r\n{\r\nint status;\r\nint len_byte = pkt_len;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_head = {\r\n.len = 0,\r\n.tx_buf = priv->buf,\r\n.rx_buf = priv->buf,\r\n};\r\nstruct spi_transfer xfer_len = {\r\n.len = 1,\r\n.tx_buf = &len_byte,\r\n};\r\nstruct spi_transfer xfer_buf = {\r\n.len = len,\r\n.tx_buf = data,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nspi_message_add_tail(&xfer_len, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nmutex_lock(&priv->buffer_mutex);\r\npriv->buf[xfer_head.len++] = CC2520_CMD_TXBUF;\r\ndev_vdbg(&priv->spi->dev,\r\n"TX_FIFO cmd buf[0] = %02x\n", priv->buf[0]);\r\nstatus = spi_sync(priv->spi, &msg);\r\ndev_vdbg(&priv->spi->dev, "status = %d\n", status);\r\nif (msg.status)\r\nstatus = msg.status;\r\ndev_vdbg(&priv->spi->dev, "status = %d\n", status);\r\ndev_vdbg(&priv->spi->dev, "buf[0] = %02x\n", priv->buf[0]);\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn status;\r\n}\r\nstatic int\r\ncc2520_read_rxfifo(struct cc2520_private *priv, u8 *data, u8 len)\r\n{\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_head = {\r\n.len = 0,\r\n.tx_buf = priv->buf,\r\n.rx_buf = priv->buf,\r\n};\r\nstruct spi_transfer xfer_buf = {\r\n.len = len,\r\n.rx_buf = data,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nmutex_lock(&priv->buffer_mutex);\r\npriv->buf[xfer_head.len++] = CC2520_CMD_RXBUF;\r\ndev_vdbg(&priv->spi->dev, "read rxfifo buf[0] = %02x\n", priv->buf[0]);\r\ndev_vdbg(&priv->spi->dev, "buf[1] = %02x\n", priv->buf[1]);\r\nstatus = spi_sync(priv->spi, &msg);\r\ndev_vdbg(&priv->spi->dev, "status = %d\n", status);\r\nif (msg.status)\r\nstatus = msg.status;\r\ndev_vdbg(&priv->spi->dev, "status = %d\n", status);\r\ndev_vdbg(&priv->spi->dev,\r\n"return status buf[0] = %02x\n", priv->buf[0]);\r\ndev_vdbg(&priv->spi->dev, "length buf[1] = %02x\n", priv->buf[1]);\r\nmutex_unlock(&priv->buffer_mutex);\r\nreturn status;\r\n}\r\nstatic int cc2520_start(struct ieee802154_hw *hw)\r\n{\r\nreturn cc2520_cmd_strobe(hw->priv, CC2520_CMD_SRXON);\r\n}\r\nstatic void cc2520_stop(struct ieee802154_hw *hw)\r\n{\r\ncc2520_cmd_strobe(hw->priv, CC2520_CMD_SRFOFF);\r\n}\r\nstatic int\r\ncc2520_tx(struct ieee802154_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct cc2520_private *priv = hw->priv;\r\nunsigned long flags;\r\nint rc;\r\nu8 status = 0;\r\nu8 pkt_len;\r\nif (priv->promiscuous) {\r\nu16 crc = crc_ccitt(0, skb->data, skb->len);\r\nput_unaligned_le16(crc, skb_put(skb, 2));\r\npkt_len = skb->len;\r\n} else {\r\npkt_len = skb->len + 2;\r\n}\r\nrc = cc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHTX);\r\nif (rc)\r\ngoto err_tx;\r\nrc = cc2520_write_txfifo(priv, pkt_len, skb->data, skb->len);\r\nif (rc)\r\ngoto err_tx;\r\nrc = cc2520_get_status(priv, &status);\r\nif (rc)\r\ngoto err_tx;\r\nif (status & CC2520_STATUS_TX_UNDERFLOW) {\r\ndev_err(&priv->spi->dev, "cc2520 tx underflow exception\n");\r\ngoto err_tx;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nBUG_ON(priv->is_tx);\r\npriv->is_tx = 1;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nrc = cc2520_cmd_strobe(priv, CC2520_CMD_STXONCCA);\r\nif (rc)\r\ngoto err;\r\nrc = wait_for_completion_interruptible(&priv->tx_complete);\r\nif (rc < 0)\r\ngoto err;\r\ncc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHTX);\r\ncc2520_cmd_strobe(priv, CC2520_CMD_SRXON);\r\nreturn rc;\r\nerr:\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->is_tx = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nerr_tx:\r\nreturn rc;\r\n}\r\nstatic int cc2520_rx(struct cc2520_private *priv)\r\n{\r\nu8 len = 0, lqi = 0, bytes = 1;\r\nstruct sk_buff *skb;\r\ncc2520_read_rxfifo(priv, &len, bytes);\r\nif (!ieee802154_is_valid_psdu_len(len)) {\r\ndev_dbg(&priv->spi->dev, "corrupted frame received\n");\r\nlen = IEEE802154_MTU;\r\n}\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (cc2520_read_rxfifo(priv, skb_put(skb, len), len)) {\r\ndev_dbg(&priv->spi->dev, "frame reception failed\n");\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (!priv->promiscuous) {\r\nbool crc_ok;\r\ncrc_ok = skb->data[len - 1] & BIT(7);\r\nif (!crc_ok) {\r\ndev_dbg(&priv->spi->dev, "CRC check failed\n");\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nlqi = skb->data[len - 1] & 0x7f;\r\nif (lqi < 50)\r\nlqi = 50;\r\nelse if (lqi > 113)\r\nlqi = 113;\r\nlqi = (lqi - 50) * 4;\r\n}\r\nieee802154_rx_irqsafe(priv->hw, skb, lqi);\r\ndev_vdbg(&priv->spi->dev, "RXFIFO: %x %x\n", len, lqi);\r\nreturn 0;\r\n}\r\nstatic int\r\ncc2520_ed(struct ieee802154_hw *hw, u8 *level)\r\n{\r\nstruct cc2520_private *priv = hw->priv;\r\nu8 status = 0xff;\r\nu8 rssi;\r\nint ret;\r\nret = cc2520_read_register(priv, CC2520_RSSISTAT, &status);\r\nif (ret)\r\nreturn ret;\r\nif (status != RSSI_VALID)\r\nreturn -EINVAL;\r\nret = cc2520_read_register(priv, CC2520_RSSI, &rssi);\r\nif (ret)\r\nreturn ret;\r\n*level = rssi - RSSI_OFFSET;\r\nreturn 0;\r\n}\r\nstatic int\r\ncc2520_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\r\n{\r\nstruct cc2520_private *priv = hw->priv;\r\nint ret;\r\ndev_dbg(&priv->spi->dev, "trying to set channel\n");\r\nBUG_ON(page != 0);\r\nBUG_ON(channel < CC2520_MINCHANNEL);\r\nBUG_ON(channel > CC2520_MAXCHANNEL);\r\nret = cc2520_write_register(priv, CC2520_FREQCTRL,\r\n11 + 5*(channel - 11));\r\nreturn ret;\r\n}\r\nstatic int\r\ncc2520_filter(struct ieee802154_hw *hw,\r\nstruct ieee802154_hw_addr_filt *filt, unsigned long changed)\r\n{\r\nstruct cc2520_private *priv = hw->priv;\r\nint ret = 0;\r\nif (changed & IEEE802154_AFILT_PANID_CHANGED) {\r\nu16 panid = le16_to_cpu(filt->pan_id);\r\ndev_vdbg(&priv->spi->dev,\r\n"cc2520_filter called for pan id\n");\r\nret = cc2520_write_ram(priv, CC2520RAM_PANID,\r\nsizeof(panid), (u8 *)&panid);\r\n}\r\nif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\r\ndev_vdbg(&priv->spi->dev,\r\n"cc2520_filter called for IEEE addr\n");\r\nret = cc2520_write_ram(priv, CC2520RAM_IEEEADDR,\r\nsizeof(filt->ieee_addr),\r\n(u8 *)&filt->ieee_addr);\r\n}\r\nif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\r\nu16 addr = le16_to_cpu(filt->short_addr);\r\ndev_vdbg(&priv->spi->dev,\r\n"cc2520_filter called for saddr\n");\r\nret = cc2520_write_ram(priv, CC2520RAM_SHORTADDR,\r\nsizeof(addr), (u8 *)&addr);\r\n}\r\nif (changed & IEEE802154_AFILT_PANC_CHANGED) {\r\nu8 frmfilt0;\r\ndev_vdbg(&priv->spi->dev,\r\n"cc2520_filter called for panc change\n");\r\ncc2520_read_register(priv, CC2520_FRMFILT0, &frmfilt0);\r\nif (filt->pan_coord)\r\nfrmfilt0 |= FRMFILT0_PAN_COORDINATOR;\r\nelse\r\nfrmfilt0 &= ~FRMFILT0_PAN_COORDINATOR;\r\nret = cc2520_write_register(priv, CC2520_FRMFILT0, frmfilt0);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int cc2520_set_tx_power(struct cc2520_private *priv, s32 mbm)\r\n{\r\nu8 power;\r\nswitch (mbm) {\r\ncase 500:\r\npower = 0xF7;\r\nbreak;\r\ncase 300:\r\npower = 0xF2;\r\nbreak;\r\ncase 200:\r\npower = 0xAB;\r\nbreak;\r\ncase 100:\r\npower = 0x13;\r\nbreak;\r\ncase 0:\r\npower = 0x32;\r\nbreak;\r\ncase -200:\r\npower = 0x81;\r\nbreak;\r\ncase -400:\r\npower = 0x88;\r\nbreak;\r\ncase -700:\r\npower = 0x2C;\r\nbreak;\r\ncase -1800:\r\npower = 0x03;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn cc2520_write_register(priv, CC2520_TXPOWER, power);\r\n}\r\nstatic inline int cc2520_cc2591_set_tx_power(struct cc2520_private *priv,\r\ns32 mbm)\r\n{\r\nu8 power;\r\nswitch (mbm) {\r\ncase 1700:\r\npower = 0xF9;\r\nbreak;\r\ncase 1600:\r\npower = 0xF0;\r\nbreak;\r\ncase 1400:\r\npower = 0xA0;\r\nbreak;\r\ncase 1100:\r\npower = 0x2C;\r\nbreak;\r\ncase -100:\r\npower = 0x03;\r\nbreak;\r\ncase -800:\r\npower = 0x01;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn cc2520_write_register(priv, CC2520_TXPOWER, power);\r\n}\r\nstatic int\r\ncc2520_set_txpower(struct ieee802154_hw *hw, s32 mbm)\r\n{\r\nstruct cc2520_private *priv = hw->priv;\r\nif (!priv->amplified)\r\nreturn cc2520_set_tx_power(priv, mbm);\r\nreturn cc2520_cc2591_set_tx_power(priv, mbm);\r\n}\r\nstatic int\r\ncc2520_set_promiscuous_mode(struct ieee802154_hw *hw, bool on)\r\n{\r\nstruct cc2520_private *priv = hw->priv;\r\nu8 frmfilt0;\r\ndev_dbg(&priv->spi->dev, "%s : mode %d\n", __func__, on);\r\npriv->promiscuous = on;\r\ncc2520_read_register(priv, CC2520_FRMFILT0, &frmfilt0);\r\nif (on) {\r\ncc2520_write_register(priv, CC2520_FRMCTRL0, 0);\r\nfrmfilt0 &= ~FRMFILT0_FRAME_FILTER_EN;\r\n} else {\r\ncc2520_write_register(priv, CC2520_FRMCTRL0, FRMCTRL0_AUTOACK |\r\nFRMCTRL0_AUTOCRC);\r\nfrmfilt0 |= FRMFILT0_FRAME_FILTER_EN;\r\n}\r\nreturn cc2520_write_register(priv, CC2520_FRMFILT0, frmfilt0);\r\n}\r\nstatic int cc2520_register(struct cc2520_private *priv)\r\n{\r\nint ret = -ENOMEM;\r\npriv->hw = ieee802154_alloc_hw(sizeof(*priv), &cc2520_ops);\r\nif (!priv->hw)\r\ngoto err_ret;\r\npriv->hw->priv = priv;\r\npriv->hw->parent = &priv->spi->dev;\r\npriv->hw->extra_tx_headroom = 0;\r\nieee802154_random_extended_addr(&priv->hw->phy->perm_extended_addr);\r\npriv->hw->phy->supported.channels[0] = 0x7FFF800;\r\npriv->hw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\r\nIEEE802154_HW_PROMISCUOUS;\r\npriv->hw->phy->flags = WPAN_PHY_FLAG_TXPOWER;\r\nif (!priv->amplified) {\r\npriv->hw->phy->supported.tx_powers = cc2520_powers;\r\npriv->hw->phy->supported.tx_powers_size = ARRAY_SIZE(cc2520_powers);\r\npriv->hw->phy->transmit_power = priv->hw->phy->supported.tx_powers[4];\r\n} else {\r\npriv->hw->phy->supported.tx_powers = cc2520_cc2591_powers;\r\npriv->hw->phy->supported.tx_powers_size = ARRAY_SIZE(cc2520_cc2591_powers);\r\npriv->hw->phy->transmit_power = priv->hw->phy->supported.tx_powers[0];\r\n}\r\npriv->hw->phy->current_channel = 11;\r\ndev_vdbg(&priv->spi->dev, "registered cc2520\n");\r\nret = ieee802154_register_hw(priv->hw);\r\nif (ret)\r\ngoto err_free_device;\r\nreturn 0;\r\nerr_free_device:\r\nieee802154_free_hw(priv->hw);\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic void cc2520_fifop_irqwork(struct work_struct *work)\r\n{\r\nstruct cc2520_private *priv\r\n= container_of(work, struct cc2520_private, fifop_irqwork);\r\ndev_dbg(&priv->spi->dev, "fifop interrupt received\n");\r\nif (gpio_get_value(priv->fifo_pin))\r\ncc2520_rx(priv);\r\nelse\r\ndev_dbg(&priv->spi->dev, "rxfifo overflow\n");\r\ncc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHRX);\r\ncc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHRX);\r\n}\r\nstatic irqreturn_t cc2520_fifop_isr(int irq, void *data)\r\n{\r\nstruct cc2520_private *priv = data;\r\nschedule_work(&priv->fifop_irqwork);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t cc2520_sfd_isr(int irq, void *data)\r\n{\r\nstruct cc2520_private *priv = data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->is_tx) {\r\npriv->is_tx = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&priv->spi->dev, "SFD for TX\n");\r\ncomplete(&priv->tx_complete);\r\n} else {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&priv->spi->dev, "SFD for RX\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cc2520_get_platform_data(struct spi_device *spi,\r\nstruct cc2520_platform_data *pdata)\r\n{\r\nstruct device_node *np = spi->dev.of_node;\r\nstruct cc2520_private *priv = spi_get_drvdata(spi);\r\nif (!np) {\r\nstruct cc2520_platform_data *spi_pdata = spi->dev.platform_data;\r\nif (!spi_pdata)\r\nreturn -ENOENT;\r\n*pdata = *spi_pdata;\r\npriv->fifo_pin = pdata->fifo;\r\nreturn 0;\r\n}\r\npdata->fifo = of_get_named_gpio(np, "fifo-gpio", 0);\r\npriv->fifo_pin = pdata->fifo;\r\npdata->fifop = of_get_named_gpio(np, "fifop-gpio", 0);\r\npdata->sfd = of_get_named_gpio(np, "sfd-gpio", 0);\r\npdata->cca = of_get_named_gpio(np, "cca-gpio", 0);\r\npdata->vreg = of_get_named_gpio(np, "vreg-gpio", 0);\r\npdata->reset = of_get_named_gpio(np, "reset-gpio", 0);\r\nif (of_property_read_bool(np, "amplified"))\r\npriv->amplified = true;\r\nreturn 0;\r\n}\r\nstatic int cc2520_hw_init(struct cc2520_private *priv)\r\n{\r\nu8 status = 0, state = 0xff;\r\nint ret;\r\nint timeout = 100;\r\nstruct cc2520_platform_data pdata;\r\nret = cc2520_get_platform_data(priv->spi, &pdata);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_read_register(priv, CC2520_FSMSTAT1, &state);\r\nif (ret)\r\ngoto err_ret;\r\nif (state != STATE_IDLE)\r\nreturn -EINVAL;\r\ndo {\r\nret = cc2520_get_status(priv, &status);\r\nif (ret)\r\ngoto err_ret;\r\nif (timeout-- <= 0) {\r\ndev_err(&priv->spi->dev, "oscillator start failed!\n");\r\nreturn ret;\r\n}\r\nudelay(1);\r\n} while (!(status & CC2520_STATUS_XOSC32M_STABLE));\r\ndev_vdbg(&priv->spi->dev, "oscillator brought up\n");\r\nif (priv->amplified) {\r\nret = cc2520_write_register(priv, CC2520_AGCCTRL1, 0x16);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_GPIOCTRL0, 0x46);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_GPIOCTRL5, 0x47);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_GPIOPOLARITY, 0x1e);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_TXCTRL, 0xc1);\r\nif (ret)\r\ngoto err_ret;\r\n} else {\r\nret = cc2520_write_register(priv, CC2520_AGCCTRL1, 0x11);\r\nif (ret)\r\ngoto err_ret;\r\n}\r\nret = cc2520_write_register(priv, CC2520_CCACTRL0, 0x1A);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_MDMCTRL0, 0x85);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_MDMCTRL1, 0x14);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_RXCTRL, 0x3f);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_FSCTRL, 0x5a);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_FSCAL1, 0x2b);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_ADCTEST0, 0x10);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_ADCTEST1, 0x0e);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_ADCTEST2, 0x03);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_FRMCTRL1,\r\nFRMCTRL1_SET_RXENMASK_ON_TX |\r\nFRMCTRL1_IGNORE_TX_UNDERF);\r\nif (ret)\r\ngoto err_ret;\r\nret = cc2520_write_register(priv, CC2520_FIFOPCTRL, 127);\r\nif (ret)\r\ngoto err_ret;\r\nreturn 0;\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic int cc2520_probe(struct spi_device *spi)\r\n{\r\nstruct cc2520_private *priv;\r\nstruct cc2520_platform_data pdata;\r\nint ret;\r\npriv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, priv);\r\nret = cc2520_get_platform_data(spi, &pdata);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\npriv->spi = spi;\r\npriv->buf = devm_kzalloc(&spi->dev,\r\nSPI_COMMAND_BUFFER, GFP_KERNEL);\r\nif (!priv->buf)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->buffer_mutex);\r\nINIT_WORK(&priv->fifop_irqwork, cc2520_fifop_irqwork);\r\nspin_lock_init(&priv->lock);\r\ninit_completion(&priv->tx_complete);\r\npriv->amplified = false;\r\nif (!gpio_is_valid(pdata.fifo)) {\r\ndev_err(&spi->dev, "fifo gpio is not valid\n");\r\nret = -EINVAL;\r\ngoto err_hw_init;\r\n}\r\nret = devm_gpio_request_one(&spi->dev, pdata.fifo,\r\nGPIOF_IN, "fifo");\r\nif (ret)\r\ngoto err_hw_init;\r\nif (!gpio_is_valid(pdata.cca)) {\r\ndev_err(&spi->dev, "cca gpio is not valid\n");\r\nret = -EINVAL;\r\ngoto err_hw_init;\r\n}\r\nret = devm_gpio_request_one(&spi->dev, pdata.cca,\r\nGPIOF_IN, "cca");\r\nif (ret)\r\ngoto err_hw_init;\r\nif (!gpio_is_valid(pdata.fifop)) {\r\ndev_err(&spi->dev, "fifop gpio is not valid\n");\r\nret = -EINVAL;\r\ngoto err_hw_init;\r\n}\r\nret = devm_gpio_request_one(&spi->dev, pdata.fifop,\r\nGPIOF_IN, "fifop");\r\nif (ret)\r\ngoto err_hw_init;\r\nif (!gpio_is_valid(pdata.sfd)) {\r\ndev_err(&spi->dev, "sfd gpio is not valid\n");\r\nret = -EINVAL;\r\ngoto err_hw_init;\r\n}\r\nret = devm_gpio_request_one(&spi->dev, pdata.sfd,\r\nGPIOF_IN, "sfd");\r\nif (ret)\r\ngoto err_hw_init;\r\nif (!gpio_is_valid(pdata.reset)) {\r\ndev_err(&spi->dev, "reset gpio is not valid\n");\r\nret = -EINVAL;\r\ngoto err_hw_init;\r\n}\r\nret = devm_gpio_request_one(&spi->dev, pdata.reset,\r\nGPIOF_OUT_INIT_LOW, "reset");\r\nif (ret)\r\ngoto err_hw_init;\r\nif (!gpio_is_valid(pdata.vreg)) {\r\ndev_err(&spi->dev, "vreg gpio is not valid\n");\r\nret = -EINVAL;\r\ngoto err_hw_init;\r\n}\r\nret = devm_gpio_request_one(&spi->dev, pdata.vreg,\r\nGPIOF_OUT_INIT_LOW, "vreg");\r\nif (ret)\r\ngoto err_hw_init;\r\ngpio_set_value(pdata.vreg, HIGH);\r\nusleep_range(100, 150);\r\ngpio_set_value(pdata.reset, HIGH);\r\nusleep_range(200, 250);\r\nret = cc2520_hw_init(priv);\r\nif (ret)\r\ngoto err_hw_init;\r\nret = devm_request_irq(&spi->dev,\r\ngpio_to_irq(pdata.fifop),\r\ncc2520_fifop_isr,\r\nIRQF_TRIGGER_RISING,\r\ndev_name(&spi->dev),\r\npriv);\r\nif (ret) {\r\ndev_err(&spi->dev, "could not get fifop irq\n");\r\ngoto err_hw_init;\r\n}\r\nret = devm_request_irq(&spi->dev,\r\ngpio_to_irq(pdata.sfd),\r\ncc2520_sfd_isr,\r\nIRQF_TRIGGER_FALLING,\r\ndev_name(&spi->dev),\r\npriv);\r\nif (ret) {\r\ndev_err(&spi->dev, "could not get sfd irq\n");\r\ngoto err_hw_init;\r\n}\r\nret = cc2520_register(priv);\r\nif (ret)\r\ngoto err_hw_init;\r\nreturn 0;\r\nerr_hw_init:\r\nmutex_destroy(&priv->buffer_mutex);\r\nflush_work(&priv->fifop_irqwork);\r\nreturn ret;\r\n}\r\nstatic int cc2520_remove(struct spi_device *spi)\r\n{\r\nstruct cc2520_private *priv = spi_get_drvdata(spi);\r\nmutex_destroy(&priv->buffer_mutex);\r\nflush_work(&priv->fifop_irqwork);\r\nieee802154_unregister_hw(priv->hw);\r\nieee802154_free_hw(priv->hw);\r\nreturn 0;\r\n}
