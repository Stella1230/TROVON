static struct pppox_sock *lookup_chan(u16 call_id, __be32 s_addr)\r\n{\r\nstruct pppox_sock *sock;\r\nstruct pptp_opt *opt;\r\nrcu_read_lock();\r\nsock = rcu_dereference(callid_sock[call_id]);\r\nif (sock) {\r\nopt = &sock->proto.pptp;\r\nif (opt->dst_addr.sin_addr.s_addr != s_addr)\r\nsock = NULL;\r\nelse\r\nsock_hold(sk_pppox(sock));\r\n}\r\nrcu_read_unlock();\r\nreturn sock;\r\n}\r\nstatic int lookup_chan_dst(u16 call_id, __be32 d_addr)\r\n{\r\nstruct pppox_sock *sock;\r\nstruct pptp_opt *opt;\r\nint i;\r\nrcu_read_lock();\r\ni = 1;\r\nfor_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {\r\nsock = rcu_dereference(callid_sock[i]);\r\nif (!sock)\r\ncontinue;\r\nopt = &sock->proto.pptp;\r\nif (opt->dst_addr.call_id == call_id &&\r\nopt->dst_addr.sin_addr.s_addr == d_addr)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn i < MAX_CALLID;\r\n}\r\nstatic int add_chan(struct pppox_sock *sock,\r\nstruct pptp_addr *sa)\r\n{\r\nstatic int call_id;\r\nspin_lock(&chan_lock);\r\nif (!sa->call_id) {\r\ncall_id = find_next_zero_bit(callid_bitmap, MAX_CALLID, call_id + 1);\r\nif (call_id == MAX_CALLID) {\r\ncall_id = find_next_zero_bit(callid_bitmap, MAX_CALLID, 1);\r\nif (call_id == MAX_CALLID)\r\ngoto out_err;\r\n}\r\nsa->call_id = call_id;\r\n} else if (test_bit(sa->call_id, callid_bitmap)) {\r\ngoto out_err;\r\n}\r\nsock->proto.pptp.src_addr = *sa;\r\nset_bit(sa->call_id, callid_bitmap);\r\nrcu_assign_pointer(callid_sock[sa->call_id], sock);\r\nspin_unlock(&chan_lock);\r\nreturn 0;\r\nout_err:\r\nspin_unlock(&chan_lock);\r\nreturn -1;\r\n}\r\nstatic void del_chan(struct pppox_sock *sock)\r\n{\r\nspin_lock(&chan_lock);\r\nclear_bit(sock->proto.pptp.src_addr.call_id, callid_bitmap);\r\nRCU_INIT_POINTER(callid_sock[sock->proto.pptp.src_addr.call_id], NULL);\r\nspin_unlock(&chan_lock);\r\nsynchronize_rcu();\r\n}\r\nstatic int pptp_xmit(struct ppp_channel *chan, struct sk_buff *skb)\r\n{\r\nstruct sock *sk = (struct sock *) chan->private;\r\nstruct pppox_sock *po = pppox_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nstruct pptp_opt *opt = &po->proto.pptp;\r\nstruct pptp_gre_header *hdr;\r\nunsigned int header_len = sizeof(*hdr);\r\nstruct flowi4 fl4;\r\nint islcp;\r\nint len;\r\nunsigned char *data;\r\n__u32 seq_recv;\r\nstruct rtable *rt;\r\nstruct net_device *tdev;\r\nstruct iphdr *iph;\r\nint max_headroom;\r\nif (sk_pppox(po)->sk_state & PPPOX_DEAD)\r\ngoto tx_error;\r\nrt = ip_route_output_ports(net, &fl4, NULL,\r\nopt->dst_addr.sin_addr.s_addr,\r\nopt->src_addr.sin_addr.s_addr,\r\n0, 0, IPPROTO_GRE,\r\nRT_TOS(0), 0);\r\nif (IS_ERR(rt))\r\ngoto tx_error;\r\ntdev = rt->dst.dev;\r\nmax_headroom = LL_RESERVED_SPACE(tdev) + sizeof(*iph) + sizeof(*hdr) + 2;\r\nif (skb_headroom(skb) < max_headroom || skb_cloned(skb) || skb_shared(skb)) {\r\nstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\r\nif (!new_skb) {\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nif (skb->sk)\r\nskb_set_owner_w(new_skb, skb->sk);\r\nconsume_skb(skb);\r\nskb = new_skb;\r\n}\r\ndata = skb->data;\r\nislcp = ((data[0] << 8) + data[1]) == PPP_LCP && 1 <= data[2] && data[2] <= 7;\r\nif ((opt->ppp_flags & SC_COMP_PROT) && data[0] == 0 && !islcp)\r\nskb_pull(skb, 1);\r\nif ((opt->ppp_flags & SC_COMP_AC) == 0 || islcp) {\r\ndata = skb_push(skb, 2);\r\ndata[0] = PPP_ALLSTATIONS;\r\ndata[1] = PPP_UI;\r\n}\r\nlen = skb->len;\r\nseq_recv = opt->seq_recv;\r\nif (opt->ack_sent == seq_recv)\r\nheader_len -= sizeof(hdr->ack);\r\nskb_push(skb, header_len);\r\nhdr = (struct pptp_gre_header *)(skb->data);\r\nhdr->flags = PPTP_GRE_FLAG_K;\r\nhdr->ver = PPTP_GRE_VER;\r\nhdr->protocol = htons(PPTP_GRE_PROTO);\r\nhdr->call_id = htons(opt->dst_addr.call_id);\r\nhdr->flags |= PPTP_GRE_FLAG_S;\r\nhdr->seq = htonl(++opt->seq_sent);\r\nif (opt->ack_sent != seq_recv) {\r\nhdr->ver |= PPTP_GRE_FLAG_A;\r\nhdr->ack = htonl(seq_recv);\r\nopt->ack_sent = seq_recv;\r\n}\r\nhdr->payload_len = htons(len);\r\nskb_reset_transport_header(skb);\r\nskb_push(skb, sizeof(*iph));\r\nskb_reset_network_header(skb);\r\nmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\r\nIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED | IPSKB_REROUTED);\r\niph = ip_hdr(skb);\r\niph->version = 4;\r\niph->ihl = sizeof(struct iphdr) >> 2;\r\nif (ip_dont_fragment(sk, &rt->dst))\r\niph->frag_off = htons(IP_DF);\r\nelse\r\niph->frag_off = 0;\r\niph->protocol = IPPROTO_GRE;\r\niph->tos = 0;\r\niph->daddr = fl4.daddr;\r\niph->saddr = fl4.saddr;\r\niph->ttl = ip4_dst_hoplimit(&rt->dst);\r\niph->tot_len = htons(skb->len);\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nnf_reset(skb);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nip_select_ident(net, skb, NULL);\r\nip_send_check(iph);\r\nip_local_out(net, skb->sk, skb);\r\nreturn 1;\r\ntx_error:\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int pptp_rcv_core(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pppox_sock *po = pppox_sk(sk);\r\nstruct pptp_opt *opt = &po->proto.pptp;\r\nint headersize, payload_len, seq;\r\n__u8 *payload;\r\nstruct pptp_gre_header *header;\r\nif (!(sk->sk_state & PPPOX_CONNECTED)) {\r\nif (sock_queue_rcv_skb(sk, skb))\r\ngoto drop;\r\nreturn NET_RX_SUCCESS;\r\n}\r\nheader = (struct pptp_gre_header *)(skb->data);\r\nheadersize = sizeof(*header);\r\nif (PPTP_GRE_IS_A(header->ver)) {\r\n__u32 ack;\r\nif (!pskb_may_pull(skb, headersize))\r\ngoto drop;\r\nheader = (struct pptp_gre_header *)(skb->data);\r\nack = PPTP_GRE_IS_S(header->flags) ? header->ack : header->seq;\r\nack = ntohl(ack);\r\nif (ack > opt->ack_recv)\r\nopt->ack_recv = ack;\r\nif (WRAPPED(ack, opt->ack_recv))\r\nopt->ack_recv = ack;\r\n} else {\r\nheadersize -= sizeof(header->ack);\r\n}\r\nif (!PPTP_GRE_IS_S(header->flags))\r\ngoto drop;\r\npayload_len = ntohs(header->payload_len);\r\nseq = ntohl(header->seq);\r\nif (!pskb_may_pull(skb, headersize + payload_len))\r\ngoto drop;\r\npayload = skb->data + headersize;\r\nif (seq < opt->seq_recv + 1 || WRAPPED(opt->seq_recv, seq)) {\r\nif ((payload[0] == PPP_ALLSTATIONS) && (payload[1] == PPP_UI) &&\r\n(PPP_PROTOCOL(payload) == PPP_LCP) &&\r\n((payload[4] == PPP_LCP_ECHOREQ) || (payload[4] == PPP_LCP_ECHOREP)))\r\ngoto allow_packet;\r\n} else {\r\nopt->seq_recv = seq;\r\nallow_packet:\r\nskb_pull(skb, headersize);\r\nif (payload[0] == PPP_ALLSTATIONS && payload[1] == PPP_UI) {\r\nif (skb->len < 3)\r\ngoto drop;\r\nskb_pull(skb, 2);\r\n}\r\nif ((*skb->data) & 1) {\r\nskb_push(skb, 1)[0] = 0;\r\n}\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb_set_network_header(skb, skb->head-skb->data);\r\nppp_input(&po->chan, skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int pptp_rcv(struct sk_buff *skb)\r\n{\r\nstruct pppox_sock *po;\r\nstruct pptp_gre_header *header;\r\nstruct iphdr *iph;\r\nif (skb->pkt_type != PACKET_HOST)\r\ngoto drop;\r\nif (!pskb_may_pull(skb, 12))\r\ngoto drop;\r\niph = ip_hdr(skb);\r\nheader = (struct pptp_gre_header *)skb->data;\r\nif (ntohs(header->protocol) != PPTP_GRE_PROTO ||\r\nPPTP_GRE_IS_C(header->flags) ||\r\nPPTP_GRE_IS_R(header->flags) ||\r\n!PPTP_GRE_IS_K(header->flags) ||\r\n(header->flags&0xF) != 0)\r\ngoto drop;\r\npo = lookup_chan(htons(header->call_id), iph->saddr);\r\nif (po) {\r\nskb_dst_drop(skb);\r\nnf_reset(skb);\r\nreturn sk_receive_skb(sk_pppox(po), skb, 0);\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\r\nint sockaddr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\r\nstruct pppox_sock *po = pppox_sk(sk);\r\nint error = 0;\r\nif (sockaddr_len < sizeof(struct sockaddr_pppox))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state & PPPOX_DEAD) {\r\nerror = -EALREADY;\r\ngoto out;\r\n}\r\nif (sk->sk_state & PPPOX_BOUND) {\r\nerror = -EBUSY;\r\ngoto out;\r\n}\r\nif (add_chan(po, &sp->sa_addr.pptp))\r\nerror = -EBUSY;\r\nelse\r\nsk->sk_state |= PPPOX_BOUND;\r\nout:\r\nrelease_sock(sk);\r\nreturn error;\r\n}\r\nstatic int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\r\nint sockaddr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\r\nstruct pppox_sock *po = pppox_sk(sk);\r\nstruct pptp_opt *opt = &po->proto.pptp;\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nint error = 0;\r\nif (sockaddr_len < sizeof(struct sockaddr_pppox))\r\nreturn -EINVAL;\r\nif (sp->sa_protocol != PX_PROTO_PPTP)\r\nreturn -EINVAL;\r\nif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\r\nreturn -EALREADY;\r\nlock_sock(sk);\r\nif (sk->sk_state & PPPOX_CONNECTED) {\r\nerror = -EBUSY;\r\ngoto end;\r\n}\r\nif (sk->sk_state & PPPOX_DEAD) {\r\nerror = -EALREADY;\r\ngoto end;\r\n}\r\nif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\r\nerror = -EINVAL;\r\ngoto end;\r\n}\r\npo->chan.private = sk;\r\npo->chan.ops = &pptp_chan_ops;\r\nrt = ip_route_output_ports(sock_net(sk), &fl4, sk,\r\nopt->dst_addr.sin_addr.s_addr,\r\nopt->src_addr.sin_addr.s_addr,\r\n0, 0,\r\nIPPROTO_GRE, RT_CONN_FLAGS(sk), 0);\r\nif (IS_ERR(rt)) {\r\nerror = -EHOSTUNREACH;\r\ngoto end;\r\n}\r\nsk_setup_caps(sk, &rt->dst);\r\npo->chan.mtu = dst_mtu(&rt->dst);\r\nif (!po->chan.mtu)\r\npo->chan.mtu = PPP_MRU;\r\nip_rt_put(rt);\r\npo->chan.mtu -= PPTP_HEADER_OVERHEAD;\r\npo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\r\nerror = ppp_register_channel(&po->chan);\r\nif (error) {\r\npr_err("PPTP: failed to register PPP channel (%d)\n", error);\r\ngoto end;\r\n}\r\nopt->dst_addr = sp->sa_addr.pptp;\r\nsk->sk_state |= PPPOX_CONNECTED;\r\nend:\r\nrelease_sock(sk);\r\nreturn error;\r\n}\r\nstatic int pptp_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *usockaddr_len, int peer)\r\n{\r\nint len = sizeof(struct sockaddr_pppox);\r\nstruct sockaddr_pppox sp;\r\nmemset(&sp.sa_addr, 0, sizeof(sp.sa_addr));\r\nsp.sa_family = AF_PPPOX;\r\nsp.sa_protocol = PX_PROTO_PPTP;\r\nsp.sa_addr.pptp = pppox_sk(sock->sk)->proto.pptp.src_addr;\r\nmemcpy(uaddr, &sp, len);\r\n*usockaddr_len = len;\r\nreturn 0;\r\n}\r\nstatic int pptp_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct pppox_sock *po;\r\nstruct pptp_opt *opt;\r\nint error = 0;\r\nif (!sk)\r\nreturn 0;\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_DEAD)) {\r\nrelease_sock(sk);\r\nreturn -EBADF;\r\n}\r\npo = pppox_sk(sk);\r\nopt = &po->proto.pptp;\r\ndel_chan(po);\r\npppox_unbind_sock(sk);\r\nsk->sk_state = PPPOX_DEAD;\r\nsock_orphan(sk);\r\nsock->sk = NULL;\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn error;\r\n}\r\nstatic void pptp_sock_destruct(struct sock *sk)\r\n{\r\nif (!(sk->sk_state & PPPOX_DEAD)) {\r\ndel_chan(pppox_sk(sk));\r\npppox_unbind_sock(sk);\r\n}\r\nskb_queue_purge(&sk->sk_receive_queue);\r\n}\r\nstatic int pptp_create(struct net *net, struct socket *sock, int kern)\r\n{\r\nint error = -ENOMEM;\r\nstruct sock *sk;\r\nstruct pppox_sock *po;\r\nstruct pptp_opt *opt;\r\nsk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pptp_sk_proto, kern);\r\nif (!sk)\r\ngoto out;\r\nsock_init_data(sock, sk);\r\nsock->state = SS_UNCONNECTED;\r\nsock->ops = &pptp_ops;\r\nsk->sk_backlog_rcv = pptp_rcv_core;\r\nsk->sk_state = PPPOX_NONE;\r\nsk->sk_type = SOCK_STREAM;\r\nsk->sk_family = PF_PPPOX;\r\nsk->sk_protocol = PX_PROTO_PPTP;\r\nsk->sk_destruct = pptp_sock_destruct;\r\npo = pppox_sk(sk);\r\nopt = &po->proto.pptp;\r\nopt->seq_sent = 0; opt->seq_recv = 0xffffffff;\r\nopt->ack_recv = 0; opt->ack_sent = 0xffffffff;\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nstatic int pptp_ppp_ioctl(struct ppp_channel *chan, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sock *sk = (struct sock *) chan->private;\r\nstruct pppox_sock *po = pppox_sk(sk);\r\nstruct pptp_opt *opt = &po->proto.pptp;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint err, val;\r\nerr = -EFAULT;\r\nswitch (cmd) {\r\ncase PPPIOCGFLAGS:\r\nval = opt->ppp_flags;\r\nif (put_user(val, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSFLAGS:\r\nif (get_user(val, p))\r\nbreak;\r\nopt->ppp_flags = val & ~SC_RCV_BITS;\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\n}\r\nreturn err;\r\n}\r\nstatic int __init pptp_init_module(void)\r\n{\r\nint err = 0;\r\npr_info("PPTP driver version " PPTP_DRIVER_VERSION "\n");\r\ncallid_sock = vzalloc((MAX_CALLID + 1) * sizeof(void *));\r\nif (!callid_sock)\r\nreturn -ENOMEM;\r\nerr = gre_add_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\r\nif (err) {\r\npr_err("PPTP: can't add gre protocol\n");\r\ngoto out_mem_free;\r\n}\r\nerr = proto_register(&pptp_sk_proto, 0);\r\nif (err) {\r\npr_err("PPTP: can't register sk_proto\n");\r\ngoto out_gre_del_protocol;\r\n}\r\nerr = register_pppox_proto(PX_PROTO_PPTP, &pppox_pptp_proto);\r\nif (err) {\r\npr_err("PPTP: can't register pppox_proto\n");\r\ngoto out_unregister_sk_proto;\r\n}\r\nreturn 0;\r\nout_unregister_sk_proto:\r\nproto_unregister(&pptp_sk_proto);\r\nout_gre_del_protocol:\r\ngre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\r\nout_mem_free:\r\nvfree(callid_sock);\r\nreturn err;\r\n}\r\nstatic void __exit pptp_exit_module(void)\r\n{\r\nunregister_pppox_proto(PX_PROTO_PPTP);\r\nproto_unregister(&pptp_sk_proto);\r\ngre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\r\nvfree(callid_sock);\r\n}
