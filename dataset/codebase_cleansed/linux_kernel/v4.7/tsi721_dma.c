static inline struct tsi721_bdma_chan *to_tsi721_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct tsi721_bdma_chan, dchan);\r\n}\r\nstatic inline struct tsi721_device *to_tsi721(struct dma_device *ddev)\r\n{\r\nreturn container_of(ddev, struct rio_mport, dma)->priv;\r\n}\r\nstatic inline\r\nstruct tsi721_tx_desc *to_tsi721_desc(struct dma_async_tx_descriptor *txd)\r\n{\r\nreturn container_of(txd, struct tsi721_tx_desc, txd);\r\n}\r\nstatic int tsi721_bdma_ch_init(struct tsi721_bdma_chan *bdma_chan, int bd_num)\r\n{\r\nstruct tsi721_dma_desc *bd_ptr;\r\nstruct device *dev = bdma_chan->dchan.device->dev;\r\nu64 *sts_ptr;\r\ndma_addr_t bd_phys;\r\ndma_addr_t sts_phys;\r\nint sts_size;\r\n#ifdef CONFIG_PCI_MSI\r\nstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\r\n#endif\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device, "DMAC%d", bdma_chan->id);\r\nbd_ptr = dma_zalloc_coherent(dev,\r\n(bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\n&bd_phys, GFP_ATOMIC);\r\nif (!bd_ptr)\r\nreturn -ENOMEM;\r\nbdma_chan->bd_num = bd_num;\r\nbdma_chan->bd_phys = bd_phys;\r\nbdma_chan->bd_base = bd_ptr;\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device,\r\n"DMAC%d descriptors @ %p (phys = %pad)",\r\nbdma_chan->id, bd_ptr, &bd_phys);\r\nsts_size = ((bd_num + 1) >= TSI721_DMA_MINSTSSZ) ?\r\n(bd_num + 1) : TSI721_DMA_MINSTSSZ;\r\nsts_size = roundup_pow_of_two(sts_size);\r\nsts_ptr = dma_zalloc_coherent(dev,\r\nsts_size * sizeof(struct tsi721_dma_sts),\r\n&sts_phys, GFP_ATOMIC);\r\nif (!sts_ptr) {\r\ndma_free_coherent(dev,\r\n(bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\nbd_ptr, bd_phys);\r\nbdma_chan->bd_base = NULL;\r\nreturn -ENOMEM;\r\n}\r\nbdma_chan->sts_phys = sts_phys;\r\nbdma_chan->sts_base = sts_ptr;\r\nbdma_chan->sts_size = sts_size;\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device,\r\n"DMAC%d desc status FIFO @ %p (phys = %pad) size=0x%x",\r\nbdma_chan->id, sts_ptr, &sts_phys, sts_size);\r\nbd_ptr[bd_num].type_id = cpu_to_le32(DTYPE3 << 29);\r\nbd_ptr[bd_num].next_lo = cpu_to_le32((u64)bd_phys &\r\nTSI721_DMAC_DPTRL_MASK);\r\nbd_ptr[bd_num].next_hi = cpu_to_le32((u64)bd_phys >> 32);\r\niowrite32(((u64)bd_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DPTRH);\r\niowrite32(((u64)bd_phys & TSI721_DMAC_DPTRL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DPTRL);\r\niowrite32(((u64)sts_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DSBH);\r\niowrite32(((u64)sts_phys & TSI721_DMAC_DSBL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DSBL);\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(sts_size),\r\nbdma_chan->regs + TSI721_DMAC_DSSZ);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nint rc, idx;\r\nidx = TSI721_VECT_DMA0_DONE + bdma_chan->id;\r\nrc = request_irq(priv->msix[idx].vector, tsi721_bdma_msix, 0,\r\npriv->msix[idx].irq_name, (void *)bdma_chan);\r\nif (rc) {\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device,\r\n"Unable to get MSI-X for DMAC%d-DONE",\r\nbdma_chan->id);\r\ngoto err_out;\r\n}\r\nidx = TSI721_VECT_DMA0_INT + bdma_chan->id;\r\nrc = request_irq(priv->msix[idx].vector, tsi721_bdma_msix, 0,\r\npriv->msix[idx].irq_name, (void *)bdma_chan);\r\nif (rc) {\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device,\r\n"Unable to get MSI-X for DMAC%d-INT",\r\nbdma_chan->id);\r\nfree_irq(\r\npriv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector,\r\n(void *)bdma_chan);\r\n}\r\nerr_out:\r\nif (rc) {\r\ndma_free_coherent(dev,\r\n(bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\nbd_ptr, bd_phys);\r\nbdma_chan->bd_base = NULL;\r\ndma_free_coherent(dev,\r\nsts_size * sizeof(struct tsi721_dma_sts),\r\nsts_ptr, sts_phys);\r\nbdma_chan->sts_base = NULL;\r\nreturn -EIO;\r\n}\r\n}\r\n#endif\r\niowrite32(TSI721_DMAC_CTL_INIT, bdma_chan->regs + TSI721_DMAC_CTL);\r\nioread32(bdma_chan->regs + TSI721_DMAC_CTL);\r\nbdma_chan->wr_count = bdma_chan->wr_count_next = 0;\r\nbdma_chan->sts_rdptr = 0;\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int tsi721_bdma_ch_free(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 ch_stat;\r\n#ifdef CONFIG_PCI_MSI\r\nstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\r\n#endif\r\nif (bdma_chan->bd_base == NULL)\r\nreturn 0;\r\nch_stat = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\nif (ch_stat & TSI721_DMAC_STS_RUN)\r\nreturn -EFAULT;\r\niowrite32(TSI721_DMAC_CTL_INIT, bdma_chan->regs + TSI721_DMAC_CTL);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nfree_irq(priv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector, (void *)bdma_chan);\r\nfree_irq(priv->msix[TSI721_VECT_DMA0_INT +\r\nbdma_chan->id].vector, (void *)bdma_chan);\r\n}\r\n#endif\r\ndma_free_coherent(bdma_chan->dchan.device->dev,\r\n(bdma_chan->bd_num + 1) * sizeof(struct tsi721_dma_desc),\r\nbdma_chan->bd_base, bdma_chan->bd_phys);\r\nbdma_chan->bd_base = NULL;\r\ndma_free_coherent(bdma_chan->dchan.device->dev,\r\nbdma_chan->sts_size * sizeof(struct tsi721_dma_sts),\r\nbdma_chan->sts_base, bdma_chan->sts_phys);\r\nbdma_chan->sts_base = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\ntsi721_bdma_interrupt_enable(struct tsi721_bdma_chan *bdma_chan, int enable)\r\n{\r\nif (enable) {\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INTE);\r\n} else {\r\niowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\n}\r\n}\r\nstatic bool tsi721_dma_is_idle(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 sts;\r\nsts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\nreturn ((sts & TSI721_DMAC_STS_RUN) == 0);\r\n}\r\nvoid tsi721_bdma_handler(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\niowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\r\nif (bdma_chan->active)\r\ntasklet_hi_schedule(&bdma_chan->tasklet);\r\n}\r\nstatic irqreturn_t tsi721_bdma_msix(int irq, void *ptr)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = ptr;\r\nif (bdma_chan->active)\r\ntasklet_hi_schedule(&bdma_chan->tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsi721_start_dma(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nif (!tsi721_dma_is_idle(bdma_chan)) {\r\ntsi_err(&bdma_chan->dchan.dev->device,\r\n"DMAC%d Attempt to start non-idle channel",\r\nbdma_chan->id);\r\nreturn;\r\n}\r\nif (bdma_chan->wr_count == bdma_chan->wr_count_next) {\r\ntsi_err(&bdma_chan->dchan.dev->device,\r\n"DMAC%d Attempt to start DMA with no BDs ready %d",\r\nbdma_chan->id, task_pid_nr(current));\r\nreturn;\r\n}\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device, "DMAC%d (wrc=%d) %d",\r\nbdma_chan->id, bdma_chan->wr_count_next,\r\ntask_pid_nr(current));\r\niowrite32(bdma_chan->wr_count_next,\r\nbdma_chan->regs + TSI721_DMAC_DWRCNT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_DWRCNT);\r\nbdma_chan->wr_count = bdma_chan->wr_count_next;\r\n}\r\nstatic int\r\ntsi721_desc_fill_init(struct tsi721_tx_desc *desc,\r\nstruct tsi721_dma_desc *bd_ptr,\r\nstruct scatterlist *sg, u32 sys_size)\r\n{\r\nu64 rio_addr;\r\nif (bd_ptr == NULL)\r\nreturn -EINVAL;\r\nbd_ptr->type_id = cpu_to_le32((DTYPE1 << 29) |\r\n(desc->rtype << 19) | desc->destid);\r\nbd_ptr->bcount = cpu_to_le32(((desc->rio_addr & 0x3) << 30) |\r\n(sys_size << 26));\r\nrio_addr = (desc->rio_addr >> 2) |\r\n((u64)(desc->rio_addr_u & 0x3) << 62);\r\nbd_ptr->raddr_lo = cpu_to_le32(rio_addr & 0xffffffff);\r\nbd_ptr->raddr_hi = cpu_to_le32(rio_addr >> 32);\r\nbd_ptr->t1.bufptr_lo = cpu_to_le32(\r\n(u64)sg_dma_address(sg) & 0xffffffff);\r\nbd_ptr->t1.bufptr_hi = cpu_to_le32((u64)sg_dma_address(sg) >> 32);\r\nbd_ptr->t1.s_dist = 0;\r\nbd_ptr->t1.s_size = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ntsi721_desc_fill_end(struct tsi721_dma_desc *bd_ptr, u32 bcount, bool interrupt)\r\n{\r\nif (bd_ptr == NULL)\r\nreturn -EINVAL;\r\nif (interrupt)\r\nbd_ptr->type_id |= cpu_to_le32(TSI721_DMAD_IOF);\r\nbd_ptr->bcount |= cpu_to_le32(bcount & TSI721_DMAD_BCOUNT1);\r\nreturn 0;\r\n}\r\nstatic void tsi721_dma_tx_err(struct tsi721_bdma_chan *bdma_chan,\r\nstruct tsi721_tx_desc *desc)\r\n{\r\nstruct dma_async_tx_descriptor *txd = &desc->txd;\r\ndma_async_tx_callback callback = txd->callback;\r\nvoid *param = txd->callback_param;\r\nlist_move(&desc->desc_node, &bdma_chan->free_list);\r\nif (callback)\r\ncallback(param);\r\n}\r\nstatic void tsi721_clr_stat(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 srd_ptr;\r\nu64 *sts_ptr;\r\nint i, j;\r\nsrd_ptr = bdma_chan->sts_rdptr;\r\nsts_ptr = bdma_chan->sts_base;\r\nj = srd_ptr * 8;\r\nwhile (sts_ptr[j]) {\r\nfor (i = 0; i < 8 && sts_ptr[j]; i++, j++)\r\nsts_ptr[j] = 0;\r\n++srd_ptr;\r\nsrd_ptr %= bdma_chan->sts_size;\r\nj = srd_ptr * 8;\r\n}\r\niowrite32(srd_ptr, bdma_chan->regs + TSI721_DMAC_DSRP);\r\nbdma_chan->sts_rdptr = srd_ptr;\r\n}\r\nstatic int tsi721_submit_sg(struct tsi721_tx_desc *desc)\r\n{\r\nstruct dma_chan *dchan = desc->txd.chan;\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nu32 sys_size;\r\nu64 rio_addr;\r\ndma_addr_t next_addr;\r\nu32 bcount;\r\nstruct scatterlist *sg;\r\nunsigned int i;\r\nint err = 0;\r\nstruct tsi721_dma_desc *bd_ptr = NULL;\r\nu32 idx, rd_idx;\r\nu32 add_count = 0;\r\nstruct device *ch_dev = &dchan->dev->device;\r\nif (!tsi721_dma_is_idle(bdma_chan)) {\r\ntsi_err(ch_dev, "DMAC%d ERR: Attempt to use non-idle channel",\r\nbdma_chan->id);\r\nreturn -EIO;\r\n}\r\nrio_addr = desc->rio_addr;\r\nnext_addr = -1;\r\nbcount = 0;\r\nsys_size = dma_to_mport(dchan->device)->sys_size;\r\nrd_idx = ioread32(bdma_chan->regs + TSI721_DMAC_DRDCNT);\r\nrd_idx %= (bdma_chan->bd_num + 1);\r\nidx = bdma_chan->wr_count_next % (bdma_chan->bd_num + 1);\r\nif (idx == bdma_chan->bd_num) {\r\nidx = 0;\r\nadd_count++;\r\n}\r\ntsi_debug(DMA, ch_dev, "DMAC%d BD ring status: rdi=%d wri=%d",\r\nbdma_chan->id, rd_idx, idx);\r\nfor_each_sg(desc->sg, sg, desc->sg_len, i) {\r\ntsi_debug(DMAV, ch_dev, "DMAC%d sg%d/%d addr: 0x%llx len: %d",\r\nbdma_chan->id, i, desc->sg_len,\r\n(unsigned long long)sg_dma_address(sg), sg_dma_len(sg));\r\nif (sg_dma_len(sg) > TSI721_BDMA_MAX_BCOUNT) {\r\ntsi_err(ch_dev, "DMAC%d SG entry %d is too large",\r\nbdma_chan->id, i);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (next_addr == sg_dma_address(sg) &&\r\nbcount + sg_dma_len(sg) <= TSI721_BDMA_MAX_BCOUNT) {\r\nbcount += sg_dma_len(sg);\r\ngoto entry_done;\r\n} else if (next_addr != -1) {\r\ntsi721_desc_fill_end(bd_ptr, bcount, 0);\r\ntsi_debug(DMAV, ch_dev, "DMAC%d prev desc final len: %d",\r\nbdma_chan->id, bcount);\r\n}\r\ndesc->rio_addr = rio_addr;\r\nif (i && idx == rd_idx) {\r\ntsi_debug(DMAV, ch_dev,\r\n"DMAC%d HW descriptor ring is full @ %d",\r\nbdma_chan->id, i);\r\ndesc->sg = sg;\r\ndesc->sg_len -= i;\r\nbreak;\r\n}\r\nbd_ptr = &((struct tsi721_dma_desc *)bdma_chan->bd_base)[idx];\r\nerr = tsi721_desc_fill_init(desc, bd_ptr, sg, sys_size);\r\nif (err) {\r\ntsi_err(ch_dev, "Failed to build desc: err=%d", err);\r\nbreak;\r\n}\r\ntsi_debug(DMAV, ch_dev, "DMAC%d bd_ptr = %p did=%d raddr=0x%llx",\r\nbdma_chan->id, bd_ptr, desc->destid, desc->rio_addr);\r\nnext_addr = sg_dma_address(sg);\r\nbcount = sg_dma_len(sg);\r\nadd_count++;\r\nif (++idx == bdma_chan->bd_num) {\r\nidx = 0;\r\nadd_count++;\r\n}\r\nentry_done:\r\nif (sg_is_last(sg)) {\r\ntsi721_desc_fill_end(bd_ptr, bcount, 0);\r\ntsi_debug(DMAV, ch_dev,\r\n"DMAC%d last desc final len: %d",\r\nbdma_chan->id, bcount);\r\ndesc->sg_len = 0;\r\n} else {\r\nrio_addr += sg_dma_len(sg);\r\nnext_addr += sg_dma_len(sg);\r\n}\r\n}\r\nif (!err)\r\nbdma_chan->wr_count_next += add_count;\r\nreturn err;\r\n}\r\nstatic void tsi721_advance_work(struct tsi721_bdma_chan *bdma_chan,\r\nstruct tsi721_tx_desc *desc)\r\n{\r\nint err;\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device, "DMAC%d", bdma_chan->id);\r\nif (!tsi721_dma_is_idle(bdma_chan))\r\nreturn;\r\nif (desc == NULL && bdma_chan->active_tx == NULL &&\r\n!list_empty(&bdma_chan->queue)) {\r\ndesc = list_first_entry(&bdma_chan->queue,\r\nstruct tsi721_tx_desc, desc_node);\r\nlist_del_init((&desc->desc_node));\r\nbdma_chan->active_tx = desc;\r\n}\r\nif (desc) {\r\nerr = tsi721_submit_sg(desc);\r\nif (!err)\r\ntsi721_start_dma(bdma_chan);\r\nelse {\r\ntsi721_dma_tx_err(bdma_chan, desc);\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device,\r\n"DMAC%d ERR: tsi721_submit_sg failed with err=%d",\r\nbdma_chan->id, err);\r\n}\r\n}\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device, "DMAC%d Exit",\r\nbdma_chan->id);\r\n}\r\nstatic void tsi721_dma_tasklet(unsigned long data)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = (struct tsi721_bdma_chan *)data;\r\nu32 dmac_int, dmac_sts;\r\ndmac_int = ioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\ntsi_debug(DMA, &bdma_chan->dchan.dev->device, "DMAC%d_INT = 0x%x",\r\nbdma_chan->id, dmac_int);\r\niowrite32(dmac_int, bdma_chan->regs + TSI721_DMAC_INT);\r\nif (dmac_int & TSI721_DMAC_INT_ERR) {\r\nint i = 10000;\r\nstruct tsi721_tx_desc *desc;\r\ndesc = bdma_chan->active_tx;\r\ndmac_sts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\ntsi_err(&bdma_chan->dchan.dev->device,\r\n"DMAC%d_STS = 0x%x did=%d raddr=0x%llx",\r\nbdma_chan->id, dmac_sts, desc->destid, desc->rio_addr);\r\nif ((dmac_sts & TSI721_DMAC_STS_ABORT) == 0)\r\ngoto err_out;\r\ntsi721_clr_stat(bdma_chan);\r\nspin_lock(&bdma_chan->lock);\r\niowrite32(TSI721_DMAC_CTL_INIT,\r\nbdma_chan->regs + TSI721_DMAC_CTL);\r\ndo {\r\nudelay(1);\r\ndmac_sts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\ni--;\r\n} while ((dmac_sts & TSI721_DMAC_STS_ABORT) && i);\r\nif (dmac_sts & TSI721_DMAC_STS_ABORT) {\r\ntsi_err(&bdma_chan->dchan.dev->device,\r\n"Failed to re-initiate DMAC%d", bdma_chan->id);\r\nspin_unlock(&bdma_chan->lock);\r\ngoto err_out;\r\n}\r\niowrite32(((u64)bdma_chan->bd_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DPTRH);\r\niowrite32(((u64)bdma_chan->bd_phys & TSI721_DMAC_DPTRL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DPTRL);\r\niowrite32(((u64)bdma_chan->sts_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DSBH);\r\niowrite32(((u64)bdma_chan->sts_phys & TSI721_DMAC_DSBL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DSBL);\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(bdma_chan->sts_size),\r\nbdma_chan->regs + TSI721_DMAC_DSSZ);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\nbdma_chan->wr_count = bdma_chan->wr_count_next = 0;\r\nbdma_chan->sts_rdptr = 0;\r\nudelay(10);\r\ndesc = bdma_chan->active_tx;\r\ndesc->status = DMA_ERROR;\r\ndma_cookie_complete(&desc->txd);\r\nlist_add(&desc->desc_node, &bdma_chan->free_list);\r\nbdma_chan->active_tx = NULL;\r\nif (bdma_chan->active)\r\ntsi721_advance_work(bdma_chan, NULL);\r\nspin_unlock(&bdma_chan->lock);\r\n}\r\nif (dmac_int & TSI721_DMAC_INT_STFULL) {\r\ntsi_err(&bdma_chan->dchan.dev->device,\r\n"DMAC%d descriptor status FIFO is full",\r\nbdma_chan->id);\r\n}\r\nif (dmac_int & (TSI721_DMAC_INT_DONE | TSI721_DMAC_INT_IOFDONE)) {\r\nstruct tsi721_tx_desc *desc;\r\ntsi721_clr_stat(bdma_chan);\r\nspin_lock(&bdma_chan->lock);\r\ndesc = bdma_chan->active_tx;\r\nif (desc->sg_len == 0) {\r\ndma_async_tx_callback callback = NULL;\r\nvoid *param = NULL;\r\ndesc->status = DMA_COMPLETE;\r\ndma_cookie_complete(&desc->txd);\r\nif (desc->txd.flags & DMA_PREP_INTERRUPT) {\r\ncallback = desc->txd.callback;\r\nparam = desc->txd.callback_param;\r\n}\r\nlist_add(&desc->desc_node, &bdma_chan->free_list);\r\nbdma_chan->active_tx = NULL;\r\nif (bdma_chan->active)\r\ntsi721_advance_work(bdma_chan, NULL);\r\nspin_unlock(&bdma_chan->lock);\r\nif (callback)\r\ncallback(param);\r\n} else {\r\nif (bdma_chan->active)\r\ntsi721_advance_work(bdma_chan,\r\nbdma_chan->active_tx);\r\nspin_unlock(&bdma_chan->lock);\r\n}\r\n}\r\nerr_out:\r\niowrite32(TSI721_DMAC_INT_ALL, bdma_chan->regs + TSI721_DMAC_INTE);\r\n}\r\nstatic dma_cookie_t tsi721_tx_submit(struct dma_async_tx_descriptor *txd)\r\n{\r\nstruct tsi721_tx_desc *desc = to_tsi721_desc(txd);\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(txd->chan);\r\ndma_cookie_t cookie;\r\nif (!list_empty(&desc->desc_node)) {\r\ntsi_err(&bdma_chan->dchan.dev->device,\r\n"DMAC%d wrong state of descriptor %p",\r\nbdma_chan->id, txd);\r\nreturn -EIO;\r\n}\r\nspin_lock_bh(&bdma_chan->lock);\r\nif (!bdma_chan->active) {\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn -ENODEV;\r\n}\r\ncookie = dma_cookie_assign(txd);\r\ndesc->status = DMA_IN_PROGRESS;\r\nlist_add_tail(&desc->desc_node, &bdma_chan->queue);\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn cookie;\r\n}\r\nstatic int tsi721_alloc_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc = NULL;\r\nint i;\r\ntsi_debug(DMA, &dchan->dev->device, "DMAC%d", bdma_chan->id);\r\nif (bdma_chan->bd_base)\r\nreturn TSI721_DMA_TX_QUEUE_SZ;\r\nif (tsi721_bdma_ch_init(bdma_chan, dma_desc_per_channel)) {\r\ntsi_err(&dchan->dev->device, "Unable to initialize DMAC%d",\r\nbdma_chan->id);\r\nreturn -ENODEV;\r\n}\r\ndesc = kcalloc(TSI721_DMA_TX_QUEUE_SZ, sizeof(struct tsi721_tx_desc),\r\nGFP_ATOMIC);\r\nif (!desc) {\r\ntsi_err(&dchan->dev->device,\r\n"DMAC%d Failed to allocate logical descriptors",\r\nbdma_chan->id);\r\ntsi721_bdma_ch_free(bdma_chan);\r\nreturn -ENOMEM;\r\n}\r\nbdma_chan->tx_desc = desc;\r\nfor (i = 0; i < TSI721_DMA_TX_QUEUE_SZ; i++) {\r\ndma_async_tx_descriptor_init(&desc[i].txd, dchan);\r\ndesc[i].txd.tx_submit = tsi721_tx_submit;\r\ndesc[i].txd.flags = DMA_CTRL_ACK;\r\nlist_add(&desc[i].desc_node, &bdma_chan->free_list);\r\n}\r\ndma_cookie_init(dchan);\r\nbdma_chan->active = true;\r\ntsi721_bdma_interrupt_enable(bdma_chan, 1);\r\nreturn TSI721_DMA_TX_QUEUE_SZ;\r\n}\r\nstatic void tsi721_sync_dma_irq(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nsynchronize_irq(priv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector);\r\nsynchronize_irq(priv->msix[TSI721_VECT_DMA0_INT +\r\nbdma_chan->id].vector);\r\n} else\r\n#endif\r\nsynchronize_irq(priv->pdev->irq);\r\n}\r\nstatic void tsi721_free_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\ntsi_debug(DMA, &dchan->dev->device, "DMAC%d", bdma_chan->id);\r\nif (bdma_chan->bd_base == NULL)\r\nreturn;\r\ntsi721_bdma_interrupt_enable(bdma_chan, 0);\r\nbdma_chan->active = false;\r\ntsi721_sync_dma_irq(bdma_chan);\r\ntasklet_kill(&bdma_chan->tasklet);\r\nINIT_LIST_HEAD(&bdma_chan->free_list);\r\nkfree(bdma_chan->tx_desc);\r\ntsi721_bdma_ch_free(bdma_chan);\r\n}\r\nstatic\r\nenum dma_status tsi721_tx_status(struct dma_chan *dchan, dma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nenum dma_status status;\r\nspin_lock_bh(&bdma_chan->lock);\r\nstatus = dma_cookie_status(dchan, cookie, txstate);\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn status;\r\n}\r\nstatic void tsi721_issue_pending(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\ntsi_debug(DMA, &dchan->dev->device, "DMAC%d", bdma_chan->id);\r\nspin_lock_bh(&bdma_chan->lock);\r\nif (tsi721_dma_is_idle(bdma_chan) && bdma_chan->active) {\r\ntsi721_advance_work(bdma_chan, NULL);\r\n}\r\nspin_unlock_bh(&bdma_chan->lock);\r\n}\r\nstatic\r\nstruct dma_async_tx_descriptor *tsi721_prep_rio_sg(struct dma_chan *dchan,\r\nstruct scatterlist *sgl, unsigned int sg_len,\r\nenum dma_transfer_direction dir, unsigned long flags,\r\nvoid *tinfo)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc;\r\nstruct rio_dma_ext *rext = tinfo;\r\nenum dma_rtype rtype;\r\nstruct dma_async_tx_descriptor *txd = NULL;\r\nif (!sgl || !sg_len) {\r\ntsi_err(&dchan->dev->device, "DMAC%d No SG list",\r\nbdma_chan->id);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntsi_debug(DMA, &dchan->dev->device, "DMAC%d %s", bdma_chan->id,\r\n(dir == DMA_DEV_TO_MEM)?"READ":"WRITE");\r\nif (dir == DMA_DEV_TO_MEM)\r\nrtype = NREAD;\r\nelse if (dir == DMA_MEM_TO_DEV) {\r\nswitch (rext->wr_type) {\r\ncase RDW_ALL_NWRITE:\r\nrtype = ALL_NWRITE;\r\nbreak;\r\ncase RDW_ALL_NWRITE_R:\r\nrtype = ALL_NWRITE_R;\r\nbreak;\r\ncase RDW_LAST_NWRITE_R:\r\ndefault:\r\nrtype = LAST_NWRITE_R;\r\nbreak;\r\n}\r\n} else {\r\ntsi_err(&dchan->dev->device,\r\n"DMAC%d Unsupported DMA direction option",\r\nbdma_chan->id);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nspin_lock_bh(&bdma_chan->lock);\r\nif (!list_empty(&bdma_chan->free_list)) {\r\ndesc = list_first_entry(&bdma_chan->free_list,\r\nstruct tsi721_tx_desc, desc_node);\r\nlist_del_init(&desc->desc_node);\r\ndesc->destid = rext->destid;\r\ndesc->rio_addr = rext->rio_addr;\r\ndesc->rio_addr_u = 0;\r\ndesc->rtype = rtype;\r\ndesc->sg_len = sg_len;\r\ndesc->sg = sgl;\r\ntxd = &desc->txd;\r\ntxd->flags = flags;\r\n}\r\nspin_unlock_bh(&bdma_chan->lock);\r\nif (!txd) {\r\ntsi_debug(DMA, &dchan->dev->device,\r\n"DMAC%d free TXD is not available", bdma_chan->id);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nreturn txd;\r\n}\r\nstatic int tsi721_terminate_all(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc, *_d;\r\nLIST_HEAD(list);\r\ntsi_debug(DMA, &dchan->dev->device, "DMAC%d", bdma_chan->id);\r\nspin_lock_bh(&bdma_chan->lock);\r\nbdma_chan->active = false;\r\nwhile (!tsi721_dma_is_idle(bdma_chan)) {\r\nudelay(5);\r\n#if (0)\r\niowrite32(TSI721_DMAC_CTL_SUSP,\r\nbdma_chan->regs + TSI721_DMAC_CTL);\r\ndo {\r\ndmac_int = ioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\n} while ((dmac_int & TSI721_DMAC_INT_SUSP) == 0);\r\n#endif\r\n}\r\nif (bdma_chan->active_tx)\r\nlist_add(&bdma_chan->active_tx->desc_node, &list);\r\nlist_splice_init(&bdma_chan->queue, &list);\r\nlist_for_each_entry_safe(desc, _d, &list, desc_node)\r\ntsi721_dma_tx_err(bdma_chan, desc);\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn 0;\r\n}\r\nstatic void tsi721_dma_stop(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nif (!bdma_chan->active)\r\nreturn;\r\nspin_lock_bh(&bdma_chan->lock);\r\nif (!tsi721_dma_is_idle(bdma_chan)) {\r\nint timeout = 100000;\r\niowrite32(TSI721_DMAC_CTL_SUSP,\r\nbdma_chan->regs + TSI721_DMAC_CTL);\r\nwhile (!tsi721_dma_is_idle(bdma_chan) && --timeout)\r\nudelay(1);\r\n}\r\nspin_unlock_bh(&bdma_chan->lock);\r\n}\r\nvoid tsi721_dma_stop_all(struct tsi721_device *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < TSI721_DMA_MAXCH; i++) {\r\nif (i != TSI721_DMACH_MAINT)\r\ntsi721_dma_stop(&priv->bdma[i]);\r\n}\r\n}\r\nint tsi721_register_dma(struct tsi721_device *priv)\r\n{\r\nint i;\r\nint nr_channels = 0;\r\nint err;\r\nstruct rio_mport *mport = &priv->mport;\r\nINIT_LIST_HEAD(&mport->dma.channels);\r\nfor (i = 0; i < TSI721_DMA_MAXCH; i++) {\r\nstruct tsi721_bdma_chan *bdma_chan = &priv->bdma[i];\r\nif (i == TSI721_DMACH_MAINT)\r\ncontinue;\r\nbdma_chan->regs = priv->regs + TSI721_DMAC_BASE(i);\r\nbdma_chan->dchan.device = &mport->dma;\r\nbdma_chan->dchan.cookie = 1;\r\nbdma_chan->dchan.chan_id = i;\r\nbdma_chan->id = i;\r\nbdma_chan->active = false;\r\nspin_lock_init(&bdma_chan->lock);\r\nbdma_chan->active_tx = NULL;\r\nINIT_LIST_HEAD(&bdma_chan->queue);\r\nINIT_LIST_HEAD(&bdma_chan->free_list);\r\ntasklet_init(&bdma_chan->tasklet, tsi721_dma_tasklet,\r\n(unsigned long)bdma_chan);\r\nlist_add_tail(&bdma_chan->dchan.device_node,\r\n&mport->dma.channels);\r\nnr_channels++;\r\n}\r\nmport->dma.chancnt = nr_channels;\r\ndma_cap_zero(mport->dma.cap_mask);\r\ndma_cap_set(DMA_PRIVATE, mport->dma.cap_mask);\r\ndma_cap_set(DMA_SLAVE, mport->dma.cap_mask);\r\nmport->dma.dev = &priv->pdev->dev;\r\nmport->dma.device_alloc_chan_resources = tsi721_alloc_chan_resources;\r\nmport->dma.device_free_chan_resources = tsi721_free_chan_resources;\r\nmport->dma.device_tx_status = tsi721_tx_status;\r\nmport->dma.device_issue_pending = tsi721_issue_pending;\r\nmport->dma.device_prep_slave_sg = tsi721_prep_rio_sg;\r\nmport->dma.device_terminate_all = tsi721_terminate_all;\r\nerr = dma_async_device_register(&mport->dma);\r\nif (err)\r\ntsi_err(&priv->pdev->dev, "Failed to register DMA device");\r\nreturn err;\r\n}\r\nvoid tsi721_unregister_dma(struct tsi721_device *priv)\r\n{\r\nstruct rio_mport *mport = &priv->mport;\r\nstruct dma_chan *chan, *_c;\r\nstruct tsi721_bdma_chan *bdma_chan;\r\ntsi721_dma_stop_all(priv);\r\ndma_async_device_unregister(&mport->dma);\r\nlist_for_each_entry_safe(chan, _c, &mport->dma.channels,\r\ndevice_node) {\r\nbdma_chan = to_tsi721_chan(chan);\r\nif (bdma_chan->active) {\r\ntsi721_bdma_interrupt_enable(bdma_chan, 0);\r\nbdma_chan->active = false;\r\ntsi721_sync_dma_irq(bdma_chan);\r\ntasklet_kill(&bdma_chan->tasklet);\r\nINIT_LIST_HEAD(&bdma_chan->free_list);\r\nkfree(bdma_chan->tx_desc);\r\ntsi721_bdma_ch_free(bdma_chan);\r\n}\r\nlist_del(&chan->device_node);\r\n}\r\n}
