static int abx80x_is_rc_mode(struct i2c_client *client)\r\n{\r\nint flags = 0;\r\nflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSS);\r\nif (flags < 0) {\r\ndev_err(&client->dev,\r\n"Failed to read autocalibration attribute\n");\r\nreturn flags;\r\n}\r\nreturn (flags & ABX8XX_OSS_OMODE) ? 1 : 0;\r\n}\r\nstatic int abx80x_enable_trickle_charger(struct i2c_client *client,\r\nu8 trickle_cfg)\r\n{\r\nint err;\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CFG_KEY,\r\nABX8XX_CFG_KEY_MISC);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write configuration key\n");\r\nreturn -EIO;\r\n}\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_TRICKLE,\r\nABX8XX_TRICKLE_CHARGE_ENABLE |\r\ntrickle_cfg);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write trickle register\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int abx80x_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned char buf[8];\r\nint err, flags, rc_mode = 0;\r\nrc_mode = abx80x_is_rc_mode(client);\r\nif (rc_mode < 0)\r\nreturn rc_mode;\r\nif (!rc_mode) {\r\nflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSS);\r\nif (flags < 0)\r\nreturn flags;\r\nif (flags & ABX8XX_OSS_OF) {\r\ndev_err(dev, "Oscillator failure, data is invalid.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_HTH,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to read date\n");\r\nreturn -EIO;\r\n}\r\ntm->tm_sec = bcd2bin(buf[ABX8XX_REG_SC] & 0x7F);\r\ntm->tm_min = bcd2bin(buf[ABX8XX_REG_MN] & 0x7F);\r\ntm->tm_hour = bcd2bin(buf[ABX8XX_REG_HR] & 0x3F);\r\ntm->tm_wday = buf[ABX8XX_REG_WD] & 0x7;\r\ntm->tm_mday = bcd2bin(buf[ABX8XX_REG_DA] & 0x3F);\r\ntm->tm_mon = bcd2bin(buf[ABX8XX_REG_MO] & 0x1F) - 1;\r\ntm->tm_year = bcd2bin(buf[ABX8XX_REG_YR]) + 100;\r\nerr = rtc_valid_tm(tm);\r\nif (err < 0)\r\ndev_err(&client->dev, "retrieved date/time is not valid.\n");\r\nreturn err;\r\n}\r\nstatic int abx80x_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned char buf[8];\r\nint err, flags;\r\nif (tm->tm_year < 100)\r\nreturn -EINVAL;\r\nbuf[ABX8XX_REG_HTH] = 0;\r\nbuf[ABX8XX_REG_SC] = bin2bcd(tm->tm_sec);\r\nbuf[ABX8XX_REG_MN] = bin2bcd(tm->tm_min);\r\nbuf[ABX8XX_REG_HR] = bin2bcd(tm->tm_hour);\r\nbuf[ABX8XX_REG_DA] = bin2bcd(tm->tm_mday);\r\nbuf[ABX8XX_REG_MO] = bin2bcd(tm->tm_mon + 1);\r\nbuf[ABX8XX_REG_YR] = bin2bcd(tm->tm_year - 100);\r\nbuf[ABX8XX_REG_WD] = tm->tm_wday;\r\nerr = i2c_smbus_write_i2c_block_data(client, ABX8XX_REG_HTH,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write to date registers\n");\r\nreturn -EIO;\r\n}\r\nflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSS);\r\nif (flags < 0)\r\nreturn flags;\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_OSS,\r\nflags & ~ABX8XX_OSS_OF);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write oscillator status register\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t abx80x_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct rtc_device *rtc = i2c_get_clientdata(client);\r\nint status;\r\nstatus = i2c_smbus_read_byte_data(client, ABX8XX_REG_STATUS);\r\nif (status < 0)\r\nreturn IRQ_NONE;\r\nif (status & ABX8XX_STATUS_AF)\r\nrtc_update_irq(rtc, 1, RTC_AF | RTC_IRQF);\r\ni2c_smbus_write_byte_data(client, ABX8XX_REG_STATUS, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int abx80x_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned char buf[7];\r\nint irq_mask, err;\r\nif (client->irq <= 0)\r\nreturn -EINVAL;\r\nerr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_ASC,\r\nsizeof(buf), buf);\r\nif (err)\r\nreturn err;\r\nirq_mask = i2c_smbus_read_byte_data(client, ABX8XX_REG_IRQ);\r\nif (irq_mask < 0)\r\nreturn irq_mask;\r\nt->time.tm_sec = bcd2bin(buf[0] & 0x7F);\r\nt->time.tm_min = bcd2bin(buf[1] & 0x7F);\r\nt->time.tm_hour = bcd2bin(buf[2] & 0x3F);\r\nt->time.tm_mday = bcd2bin(buf[3] & 0x3F);\r\nt->time.tm_mon = bcd2bin(buf[4] & 0x1F) - 1;\r\nt->time.tm_wday = buf[5] & 0x7;\r\nt->enabled = !!(irq_mask & ABX8XX_IRQ_AIE);\r\nt->pending = (buf[6] & ABX8XX_STATUS_AF) && t->enabled;\r\nreturn err;\r\n}\r\nstatic int abx80x_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 alarm[6];\r\nint err;\r\nif (client->irq <= 0)\r\nreturn -EINVAL;\r\nalarm[0] = 0x0;\r\nalarm[1] = bin2bcd(t->time.tm_sec);\r\nalarm[2] = bin2bcd(t->time.tm_min);\r\nalarm[3] = bin2bcd(t->time.tm_hour);\r\nalarm[4] = bin2bcd(t->time.tm_mday);\r\nalarm[5] = bin2bcd(t->time.tm_mon + 1);\r\nerr = i2c_smbus_write_i2c_block_data(client, ABX8XX_REG_AHTH,\r\nsizeof(alarm), alarm);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write alarm registers\n");\r\nreturn -EIO;\r\n}\r\nif (t->enabled) {\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_IRQ,\r\n(ABX8XX_IRQ_IM_1_4 |\r\nABX8XX_IRQ_AIE));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int abx80x_rtc_set_autocalibration(struct device *dev,\r\nint autocalibration)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint retval, flags = 0;\r\nif ((autocalibration != 0) && (autocalibration != 1024) &&\r\n(autocalibration != 512)) {\r\ndev_err(dev, "autocalibration value outside permitted range\n");\r\nreturn -EINVAL;\r\n}\r\nflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSC);\r\nif (flags < 0)\r\nreturn flags;\r\nif (autocalibration == 0) {\r\nflags &= ~(ABX8XX_OSC_ACAL_512 | ABX8XX_OSC_ACAL_1024);\r\n} else if (autocalibration == 1024) {\r\nflags |= ABX8XX_OSC_ACAL_1024;\r\nflags &= ~(ABX8XX_OSC_ACAL_512);\r\n} else {\r\nflags |= (ABX8XX_OSC_ACAL_1024 | ABX8XX_OSC_ACAL_512);\r\n}\r\nretval = i2c_smbus_write_byte_data(client, ABX8XX_REG_CFG_KEY,\r\nABX8XX_CFG_KEY_OSC);\r\nif (retval < 0) {\r\ndev_err(dev, "Failed to write CONFIG_KEY register\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(client, ABX8XX_REG_OSC, flags);\r\nreturn retval;\r\n}\r\nstatic int abx80x_rtc_get_autocalibration(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint flags = 0, autocalibration;\r\nflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSC);\r\nif (flags < 0)\r\nreturn flags;\r\nif (flags & ABX8XX_OSC_ACAL_512)\r\nautocalibration = 512;\r\nelse if (flags & ABX8XX_OSC_ACAL_1024)\r\nautocalibration = 1024;\r\nelse\r\nautocalibration = 0;\r\nreturn autocalibration;\r\n}\r\nstatic ssize_t autocalibration_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint retval;\r\nunsigned long autocalibration = 0;\r\nretval = kstrtoul(buf, 10, &autocalibration);\r\nif (retval < 0) {\r\ndev_err(dev, "Failed to store RTC autocalibration attribute\n");\r\nreturn -EINVAL;\r\n}\r\nretval = abx80x_rtc_set_autocalibration(dev, autocalibration);\r\nreturn retval ? retval : count;\r\n}\r\nstatic ssize_t autocalibration_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint autocalibration = 0;\r\nautocalibration = abx80x_rtc_get_autocalibration(dev);\r\nif (autocalibration < 0) {\r\ndev_err(dev, "Failed to read RTC autocalibration\n");\r\nsprintf(buf, "0\n");\r\nreturn autocalibration;\r\n}\r\nreturn sprintf(buf, "%d\n", autocalibration);\r\n}\r\nstatic ssize_t oscillator_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint retval, flags, rc_mode = 0;\r\nif (strncmp(buf, "rc", 2) == 0) {\r\nrc_mode = 1;\r\n} else if (strncmp(buf, "xtal", 4) == 0) {\r\nrc_mode = 0;\r\n} else {\r\ndev_err(dev, "Oscillator selection value outside permitted ones\n");\r\nreturn -EINVAL;\r\n}\r\nflags = i2c_smbus_read_byte_data(client, ABX8XX_REG_OSC);\r\nif (flags < 0)\r\nreturn flags;\r\nif (rc_mode == 0)\r\nflags &= ~(ABX8XX_OSC_OSEL);\r\nelse\r\nflags |= (ABX8XX_OSC_OSEL);\r\nretval = i2c_smbus_write_byte_data(client, ABX8XX_REG_CFG_KEY,\r\nABX8XX_CFG_KEY_OSC);\r\nif (retval < 0) {\r\ndev_err(dev, "Failed to write CONFIG_KEY register\n");\r\nreturn retval;\r\n}\r\nretval = i2c_smbus_write_byte_data(client, ABX8XX_REG_OSC, flags);\r\nif (retval < 0) {\r\ndev_err(dev, "Failed to write Oscillator Control register\n");\r\nreturn retval;\r\n}\r\nreturn retval ? retval : count;\r\n}\r\nstatic ssize_t oscillator_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint rc_mode = 0;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nrc_mode = abx80x_is_rc_mode(client);\r\nif (rc_mode < 0) {\r\ndev_err(dev, "Failed to read RTC oscillator selection\n");\r\nsprintf(buf, "\n");\r\nreturn rc_mode;\r\n}\r\nif (rc_mode)\r\nreturn sprintf(buf, "rc\n");\r\nelse\r\nreturn sprintf(buf, "xtal\n");\r\n}\r\nstatic int abx80x_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint err;\r\nif (enabled)\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_IRQ,\r\n(ABX8XX_IRQ_IM_1_4 |\r\nABX8XX_IRQ_AIE));\r\nelse\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_IRQ,\r\nABX8XX_IRQ_IM_1_4);\r\nreturn err;\r\n}\r\nstatic int abx80x_dt_trickle_cfg(struct device_node *np)\r\n{\r\nconst char *diode;\r\nint trickle_cfg = 0;\r\nint i, ret;\r\nu32 tmp;\r\nret = of_property_read_string(np, "abracon,tc-diode", &diode);\r\nif (ret)\r\nreturn ret;\r\nif (!strcmp(diode, "standard"))\r\ntrickle_cfg |= ABX8XX_TRICKLE_STANDARD_DIODE;\r\nelse if (!strcmp(diode, "schottky"))\r\ntrickle_cfg |= ABX8XX_TRICKLE_SCHOTTKY_DIODE;\r\nelse\r\nreturn -EINVAL;\r\nret = of_property_read_u32(np, "abracon,tc-resistor", &tmp);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < sizeof(trickle_resistors); i++)\r\nif (trickle_resistors[i] == tmp)\r\nbreak;\r\nif (i == sizeof(trickle_resistors))\r\nreturn -EINVAL;\r\nreturn (trickle_cfg | i);\r\n}\r\nstatic void rtc_calib_remove_sysfs_group(void *_dev)\r\n{\r\nstruct device *dev = _dev;\r\nsysfs_remove_group(&dev->kobj, &rtc_calib_attr_group);\r\n}\r\nstatic int abx80x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nstruct rtc_device *rtc;\r\nint i, data, err, trickle_cfg = -EINVAL;\r\nchar buf[7];\r\nunsigned int part = id->driver_data;\r\nunsigned int partnumber;\r\nunsigned int majrev, minrev;\r\nunsigned int lot;\r\nunsigned int wafer;\r\nunsigned int uid;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\nerr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_ID0,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to read partnumber\n");\r\nreturn -EIO;\r\n}\r\npartnumber = (buf[0] << 8) | buf[1];\r\nmajrev = buf[2] >> 3;\r\nminrev = buf[2] & 0x7;\r\nlot = ((buf[4] & 0x80) << 2) | ((buf[6] & 0x80) << 1) | buf[3];\r\nuid = ((buf[4] & 0x7f) << 8) | buf[5];\r\nwafer = (buf[6] & 0x7c) >> 2;\r\ndev_info(&client->dev, "model %04x, revision %u.%u, lot %x, wafer %x, uid %x\n",\r\npartnumber, majrev, minrev, lot, wafer, uid);\r\ndata = i2c_smbus_read_byte_data(client, ABX8XX_REG_CTRL1);\r\nif (data < 0) {\r\ndev_err(&client->dev, "Unable to read control register\n");\r\nreturn -EIO;\r\n}\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CTRL1,\r\n((data & ~(ABX8XX_CTRL_12_24 |\r\nABX8XX_CTRL_ARST)) |\r\nABX8XX_CTRL_WRITE));\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write control register\n");\r\nreturn -EIO;\r\n}\r\nif (part == ABX80X) {\r\nfor (i = 0; abx80x_caps[i].pn; i++)\r\nif (partnumber == abx80x_caps[i].pn)\r\nbreak;\r\nif (abx80x_caps[i].pn == 0) {\r\ndev_err(&client->dev, "Unknown part: %04x\n",\r\npartnumber);\r\nreturn -EINVAL;\r\n}\r\npart = i;\r\n}\r\nif (partnumber != abx80x_caps[part].pn) {\r\ndev_err(&client->dev, "partnumber mismatch %04x != %04x\n",\r\npartnumber, abx80x_caps[part].pn);\r\nreturn -EINVAL;\r\n}\r\nif (np && abx80x_caps[part].has_tc)\r\ntrickle_cfg = abx80x_dt_trickle_cfg(np);\r\nif (trickle_cfg > 0) {\r\ndev_info(&client->dev, "Enabling trickle charger: %02x\n",\r\ntrickle_cfg);\r\nabx80x_enable_trickle_charger(client, trickle_cfg);\r\n}\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CD_TIMER_CTL,\r\nBIT(2));\r\nif (err)\r\nreturn err;\r\nrtc = devm_rtc_device_register(&client->dev, "abx8xx",\r\n&abx80x_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\ni2c_set_clientdata(client, rtc);\r\nif (client->irq > 0) {\r\ndev_info(&client->dev, "IRQ %d supplied\n", client->irq);\r\nerr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\nabx80x_handle_irq,\r\nIRQF_SHARED | IRQF_ONESHOT,\r\n"abx8xx",\r\nclient);\r\nif (err) {\r\ndev_err(&client->dev, "unable to request IRQ, alarms disabled\n");\r\nclient->irq = 0;\r\n}\r\n}\r\nerr = sysfs_create_group(&(&client->dev)->kobj, &rtc_calib_attr_group);\r\nif (err) {\r\ndev_err(&client->dev, "Failed to create sysfs group: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = devm_add_action(&client->dev, rtc_calib_remove_sysfs_group,\r\n&client->dev);\r\nif (err) {\r\nrtc_calib_remove_sysfs_group(&client->dev);\r\ndev_err(&client->dev,\r\n"Failed to add sysfs cleanup action: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int abx80x_remove(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}
