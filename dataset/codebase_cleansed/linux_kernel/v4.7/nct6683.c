static inline void\r\nsuperio_outb(int ioreg, int reg, int val)\r\n{\r\noutb(reg, ioreg);\r\noutb(val, ioreg + 1);\r\n}\r\nstatic inline int\r\nsuperio_inb(int ioreg, int reg)\r\n{\r\noutb(reg, ioreg);\r\nreturn inb(ioreg + 1);\r\n}\r\nstatic inline void\r\nsuperio_select(int ioreg, int ld)\r\n{\r\noutb(SIO_REG_LDSEL, ioreg);\r\noutb(ld, ioreg + 1);\r\n}\r\nstatic inline int\r\nsuperio_enter(int ioreg)\r\n{\r\nif (!request_muxed_region(ioreg, 2, DRVNAME))\r\nreturn -EBUSY;\r\noutb(0x87, ioreg);\r\noutb(0x87, ioreg);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsuperio_exit(int ioreg)\r\n{\r\noutb(0xaa, ioreg);\r\noutb(0x02, ioreg);\r\noutb(0x02, ioreg + 1);\r\nrelease_region(ioreg, 2);\r\n}\r\nstatic struct attribute_group *\r\nnct6683_create_attr_group(struct device *dev,\r\nconst struct sensor_template_group *tg,\r\nint repeat)\r\n{\r\nstruct sensor_device_attribute_2 *a2;\r\nstruct sensor_device_attribute *a;\r\nstruct sensor_device_template **t;\r\nstruct sensor_device_attr_u *su;\r\nstruct attribute_group *group;\r\nstruct attribute **attrs;\r\nint i, j, count;\r\nif (repeat <= 0)\r\nreturn ERR_PTR(-EINVAL);\r\nt = tg->templates;\r\nfor (count = 0; *t; t++, count++)\r\n;\r\nif (count == 0)\r\nreturn ERR_PTR(-EINVAL);\r\ngroup = devm_kzalloc(dev, sizeof(*group), GFP_KERNEL);\r\nif (group == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nattrs = devm_kzalloc(dev, sizeof(*attrs) * (repeat * count + 1),\r\nGFP_KERNEL);\r\nif (attrs == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nsu = devm_kzalloc(dev, sizeof(*su) * repeat * count,\r\nGFP_KERNEL);\r\nif (su == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ngroup->attrs = attrs;\r\ngroup->is_visible = tg->is_visible;\r\nfor (i = 0; i < repeat; i++) {\r\nt = tg->templates;\r\nfor (j = 0; *t != NULL; j++) {\r\nsnprintf(su->name, sizeof(su->name),\r\n(*t)->dev_attr.attr.name, tg->base + i);\r\nif ((*t)->s2) {\r\na2 = &su->u.a2;\r\nsysfs_attr_init(&a2->dev_attr.attr);\r\na2->dev_attr.attr.name = su->name;\r\na2->nr = (*t)->u.s.nr + i;\r\na2->index = (*t)->u.s.index;\r\na2->dev_attr.attr.mode =\r\n(*t)->dev_attr.attr.mode;\r\na2->dev_attr.show = (*t)->dev_attr.show;\r\na2->dev_attr.store = (*t)->dev_attr.store;\r\n*attrs = &a2->dev_attr.attr;\r\n} else {\r\na = &su->u.a1;\r\nsysfs_attr_init(&a->dev_attr.attr);\r\na->dev_attr.attr.name = su->name;\r\na->index = (*t)->u.index + i;\r\na->dev_attr.attr.mode =\r\n(*t)->dev_attr.attr.mode;\r\na->dev_attr.show = (*t)->dev_attr.show;\r\na->dev_attr.store = (*t)->dev_attr.store;\r\n*attrs = &a->dev_attr.attr;\r\n}\r\nattrs++;\r\nsu++;\r\nt++;\r\n}\r\n}\r\nreturn group;\r\n}\r\nstatic inline long in_from_reg(u16 reg, u8 src)\r\n{\r\nint scale = 16;\r\nif (src == MON_SRC_VCC || src == MON_SRC_VSB || src == MON_SRC_AVSB ||\r\nsrc == MON_SRC_VBAT)\r\nscale <<= 1;\r\nreturn reg * scale;\r\n}\r\nstatic inline u16 in_to_reg(u32 val, u8 src)\r\n{\r\nint scale = 16;\r\nif (src == MON_SRC_VCC || src == MON_SRC_VSB || src == MON_SRC_AVSB ||\r\nsrc == MON_SRC_VBAT)\r\nscale <<= 1;\r\nreturn clamp_val(DIV_ROUND_CLOSEST(val, scale), 0, 127);\r\n}\r\nstatic u16 nct6683_read(struct nct6683_data *data, u16 reg)\r\n{\r\nint res;\r\noutb_p(0xff, data->addr + EC_PAGE_REG);\r\noutb_p(reg >> 8, data->addr + EC_PAGE_REG);\r\noutb_p(reg & 0xff, data->addr + EC_INDEX_REG);\r\nres = inb_p(data->addr + EC_DATA_REG);\r\nreturn res;\r\n}\r\nstatic u16 nct6683_read16(struct nct6683_data *data, u16 reg)\r\n{\r\nreturn (nct6683_read(data, reg) << 8) | nct6683_read(data, reg + 1);\r\n}\r\nstatic void nct6683_write(struct nct6683_data *data, u16 reg, u16 value)\r\n{\r\noutb_p(0xff, data->addr + EC_PAGE_REG);\r\noutb_p(reg >> 8, data->addr + EC_PAGE_REG);\r\noutb_p(reg & 0xff, data->addr + EC_INDEX_REG);\r\noutb_p(value & 0xff, data->addr + EC_DATA_REG);\r\n}\r\nstatic int get_in_reg(struct nct6683_data *data, int nr, int index)\r\n{\r\nint ch = data->in_index[index];\r\nint reg = -EINVAL;\r\nswitch (nr) {\r\ncase 0:\r\nreg = NCT6683_REG_MON(ch);\r\nbreak;\r\ncase 1:\r\nif (data->customer_id != NCT6683_CUSTOMER_ID_INTEL)\r\nreg = NCT6683_REG_MON_LOW(ch);\r\nbreak;\r\ncase 2:\r\nif (data->customer_id != NCT6683_CUSTOMER_ID_INTEL)\r\nreg = NCT6683_REG_MON_HIGH(ch);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn reg;\r\n}\r\nstatic int get_temp_reg(struct nct6683_data *data, int nr, int index)\r\n{\r\nint ch = data->temp_index[index];\r\nint reg = -EINVAL;\r\nswitch (data->customer_id) {\r\ncase NCT6683_CUSTOMER_ID_INTEL:\r\nswitch (nr) {\r\ndefault:\r\ncase 1:\r\nreg = NCT6683_REG_INTEL_TEMP_MAX(ch);\r\nbreak;\r\ncase 3:\r\nreg = NCT6683_REG_INTEL_TEMP_CRIT(ch);\r\nbreak;\r\n}\r\nbreak;\r\ncase NCT6683_CUSTOMER_ID_MITAC:\r\ndefault:\r\nswitch (nr) {\r\ndefault:\r\ncase 0:\r\nreg = NCT6683_REG_MON_LOW(ch);\r\nbreak;\r\ncase 1:\r\nreg = NCT6683_REG_TEMP_MAX(ch);\r\nbreak;\r\ncase 2:\r\nreg = NCT6683_REG_TEMP_HYST(ch);\r\nbreak;\r\ncase 3:\r\nreg = NCT6683_REG_MON_HIGH(ch);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn reg;\r\n}\r\nstatic void nct6683_update_pwm(struct device *dev)\r\n{\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < NCT6683_NUM_REG_PWM; i++) {\r\nif (!(data->have_pwm & (1 << i)))\r\ncontinue;\r\ndata->pwm[i] = nct6683_read(data, NCT6683_REG_PWM(i));\r\n}\r\n}\r\nstatic struct nct6683_data *nct6683_update_device(struct device *dev)\r\n{\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint i, j;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nfor (i = 0; i < data->in_num; i++) {\r\nfor (j = 0; j < 3; j++) {\r\nint reg = get_in_reg(data, j, i);\r\nif (reg >= 0)\r\ndata->in[j][i] =\r\nnct6683_read(data, reg);\r\n}\r\n}\r\nfor (i = 0; i < data->temp_num; i++) {\r\nu8 ch = data->temp_index[i];\r\ndata->temp_in[i] = nct6683_read16(data,\r\nNCT6683_REG_MON(ch));\r\nfor (j = 0; j < 4; j++) {\r\nint reg = get_temp_reg(data, j, i);\r\nif (reg >= 0)\r\ndata->temp[j][i] =\r\nnct6683_read(data, reg);\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->rpm); i++) {\r\nif (!(data->have_fan & (1 << i)))\r\ncontinue;\r\ndata->rpm[i] = nct6683_read16(data,\r\nNCT6683_REG_FAN_RPM(i));\r\ndata->fan_min[i] = nct6683_read16(data,\r\nNCT6683_REG_FAN_MIN(i));\r\n}\r\nnct6683_update_pwm(dev);\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t\r\nshow_in_label(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%s\n", nct6683_mon_label[data->in_src[nr]]);\r\n}\r\nstatic ssize_t\r\nshow_in_reg(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nint index = sattr->index;\r\nint nr = sattr->nr;\r\nreturn sprintf(buf, "%ld\n",\r\nin_from_reg(data->in[index][nr], data->in_index[index]));\r\n}\r\nstatic umode_t nct6683_in_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint nr = index % 4;\r\nif ((nr == 2 || nr == 3) &&\r\ndata->customer_id == NCT6683_CUSTOMER_ID_INTEL)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->rpm[sattr->index]);\r\n}\r\nstatic ssize_t\r\nshow_fan_min(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%d\n", data->fan_min[nr]);\r\n}\r\nstatic ssize_t\r\nshow_fan_pulses(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\n((data->fanin_cfg[sattr->index] >> 5) & 0x03) + 1);\r\n}\r\nstatic umode_t nct6683_fan_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint fan = index / 3;\r\nint nr = index % 3;\r\nif (!(data->have_fan & (1 << fan)))\r\nreturn 0;\r\nif (nr == 2 && data->customer_id == NCT6683_CUSTOMER_ID_INTEL)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_temp_label(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%s\n", nct6683_mon_label[data->temp_src[nr]]);\r\n}\r\nstatic ssize_t\r\nshow_temp8(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nint index = sattr->index;\r\nint nr = sattr->nr;\r\nreturn sprintf(buf, "%d\n", data->temp[index][nr] * 1000);\r\n}\r\nstatic ssize_t\r\nshow_temp_hyst(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nint nr = sattr->index;\r\nint temp = data->temp[1][nr] - data->temp[2][nr];\r\nreturn sprintf(buf, "%d\n", temp * 1000);\r\n}\r\nstatic ssize_t\r\nshow_temp16(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nint index = sattr->index;\r\nreturn sprintf(buf, "%d\n", (data->temp_in[index] / 128) * 500);\r\n}\r\nstatic int get_temp_type(u8 src)\r\n{\r\nif (src >= 0x02 && src <= 0x07)\r\nreturn 3;\r\nelse if (src >= 0x08 && src <= 0x18)\r\nreturn 4;\r\nelse if (src >= 0x20 && src <= 0x2b)\r\nreturn 6;\r\nelse if (src >= 0x42 && src <= 0x49)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nshow_temp_type(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%d\n", get_temp_type(data->temp_src[nr]));\r\n}\r\nstatic umode_t nct6683_temp_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint temp = index / 7;\r\nint nr = index % 7;\r\nif ((nr == 2 || nr == 4) &&\r\ndata->customer_id == NCT6683_CUSTOMER_ID_INTEL)\r\nreturn 0;\r\nif (nr == 6 && get_temp_type(data->temp_src[temp]) == 0)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint index = sattr->index;\r\nreturn sprintf(buf, "%d\n", data->pwm[index]);\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint index = sattr->index;\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val) || val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nnct6683_write(data, NCT6683_REG_FAN_CFG_CTRL, NCT6683_FAN_CFG_REQ);\r\nusleep_range(1000, 2000);\r\nnct6683_write(data, NCT6683_REG_PWM_WRITE(index), val);\r\nnct6683_write(data, NCT6683_REG_FAN_CFG_CTRL, NCT6683_FAN_CFG_DONE);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic umode_t nct6683_pwm_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint pwm = index;\r\nif (!(data->have_pwm & (1 << pwm)))\r\nreturn 0;\r\nif (data->customer_id == NCT6683_CUSTOMER_ID_MITAC)\r\nreturn attr->mode | S_IWUSR;\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_global_beep(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nu8 reg;\r\nmutex_lock(&data->update_lock);\r\nret = superio_enter(data->sioreg);\r\nif (ret)\r\ngoto error;\r\nsuperio_select(data->sioreg, NCT6683_LD_HWM);\r\nreg = superio_inb(data->sioreg, NCT6683_REG_CR_BEEP);\r\nsuperio_exit(data->sioreg);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%u\n", !!(reg & NCT6683_CR_BEEP_MASK));\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nstore_global_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nu8 reg;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val) || (val != 0 && val != 1))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nret = superio_enter(data->sioreg);\r\nif (ret) {\r\ncount = ret;\r\ngoto error;\r\n}\r\nsuperio_select(data->sioreg, NCT6683_LD_HWM);\r\nreg = superio_inb(data->sioreg, NCT6683_REG_CR_BEEP);\r\nif (val)\r\nreg |= NCT6683_CR_BEEP_MASK;\r\nelse\r\nreg &= ~NCT6683_CR_BEEP_MASK;\r\nsuperio_outb(data->sioreg, NCT6683_REG_CR_BEEP, reg);\r\nsuperio_exit(data->sioreg);\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_caseopen(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nu8 reg;\r\nmutex_lock(&data->update_lock);\r\nret = superio_enter(data->sioreg);\r\nif (ret)\r\ngoto error;\r\nsuperio_select(data->sioreg, NCT6683_LD_ACPI);\r\nreg = superio_inb(data->sioreg, NCT6683_REG_CR_CASEOPEN);\r\nsuperio_exit(data->sioreg);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%u\n", !(reg & NCT6683_CR_CASEOPEN_MASK));\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nclear_caseopen(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nu8 reg;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val) || val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nret = superio_enter(data->sioreg);\r\nif (ret) {\r\ncount = ret;\r\ngoto error;\r\n}\r\nsuperio_select(data->sioreg, NCT6683_LD_ACPI);\r\nreg = superio_inb(data->sioreg, NCT6683_REG_CR_CASEOPEN);\r\nreg |= NCT6683_CR_CASEOPEN_MASK;\r\nsuperio_outb(data->sioreg, NCT6683_REG_CR_CASEOPEN, reg);\r\nreg &= ~NCT6683_CR_CASEOPEN_MASK;\r\nsuperio_outb(data->sioreg, NCT6683_REG_CR_CASEOPEN, reg);\r\nsuperio_exit(data->sioreg);\r\ndata->valid = false;\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic inline void nct6683_init_device(struct nct6683_data *data)\r\n{\r\nu8 tmp;\r\ntmp = nct6683_read(data, NCT6683_HWM_CFG);\r\nif (!(tmp & 0x80))\r\nnct6683_write(data, NCT6683_HWM_CFG, tmp | 0x80);\r\n}\r\nstatic void\r\nnct6683_setup_fans(struct nct6683_data *data)\r\n{\r\nint i;\r\nu8 reg;\r\nfor (i = 0; i < NCT6683_NUM_REG_FAN; i++) {\r\nreg = nct6683_read(data, NCT6683_REG_FANIN_CFG(i));\r\nif (reg & 0x80)\r\ndata->have_fan |= 1 << i;\r\ndata->fanin_cfg[i] = reg;\r\n}\r\nfor (i = 0; i < NCT6683_NUM_REG_PWM; i++) {\r\nreg = nct6683_read(data, NCT6683_REG_FANOUT_CFG(i));\r\nif (reg & 0x80)\r\ndata->have_pwm |= 1 << i;\r\ndata->fanout_cfg[i] = reg;\r\n}\r\n}\r\nstatic void nct6683_setup_sensors(struct nct6683_data *data)\r\n{\r\nu8 reg;\r\nint i;\r\ndata->temp_num = 0;\r\ndata->in_num = 0;\r\nfor (i = 0; i < NCT6683_NUM_REG_MON; i++) {\r\nreg = nct6683_read(data, NCT6683_REG_MON_CFG(i)) & 0x7f;\r\nif (reg >= NUM_MON_LABELS)\r\ncontinue;\r\nif (nct6683_mon_label[reg] == NULL)\r\ncontinue;\r\nif (reg < MON_VOLTAGE_START) {\r\ndata->temp_index[data->temp_num] = i;\r\ndata->temp_src[data->temp_num] = reg;\r\ndata->temp_num++;\r\n} else {\r\ndata->in_index[data->in_num] = i;\r\ndata->in_src[data->in_num] = reg;\r\ndata->in_num++;\r\n}\r\n}\r\n}\r\nstatic int nct6683_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct nct6683_sio_data *sio_data = dev->platform_data;\r\nstruct attribute_group *group;\r\nstruct nct6683_data *data;\r\nstruct device *hwmon_dev;\r\nstruct resource *res;\r\nint groups = 0;\r\nchar build[16];\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!devm_request_region(dev, res->start, IOREGION_LENGTH, DRVNAME))\r\nreturn -EBUSY;\r\ndata = devm_kzalloc(dev, sizeof(struct nct6683_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->kind = sio_data->kind;\r\ndata->sioreg = sio_data->sioreg;\r\ndata->addr = res->start;\r\nmutex_init(&data->update_lock);\r\nplatform_set_drvdata(pdev, data);\r\ndata->customer_id = nct6683_read16(data, NCT6683_REG_CUSTOMER_ID);\r\nswitch (data->customer_id) {\r\ncase NCT6683_CUSTOMER_ID_INTEL:\r\nbreak;\r\ncase NCT6683_CUSTOMER_ID_MITAC:\r\nbreak;\r\ndefault:\r\nif (!force)\r\nreturn -ENODEV;\r\n}\r\nnct6683_init_device(data);\r\nnct6683_setup_fans(data);\r\nnct6683_setup_sensors(data);\r\nif (data->have_pwm) {\r\ngroup = nct6683_create_attr_group(dev,\r\n&nct6683_pwm_template_group,\r\nfls(data->have_pwm));\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[groups++] = group;\r\n}\r\nif (data->in_num) {\r\ngroup = nct6683_create_attr_group(dev,\r\n&nct6683_in_template_group,\r\ndata->in_num);\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[groups++] = group;\r\n}\r\nif (data->have_fan) {\r\ngroup = nct6683_create_attr_group(dev,\r\n&nct6683_fan_template_group,\r\nfls(data->have_fan));\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[groups++] = group;\r\n}\r\nif (data->temp_num) {\r\ngroup = nct6683_create_attr_group(dev,\r\n&nct6683_temp_template_group,\r\ndata->temp_num);\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[groups++] = group;\r\n}\r\ndata->groups[groups++] = &nct6683_group_other;\r\nif (data->customer_id == NCT6683_CUSTOMER_ID_INTEL)\r\nscnprintf(build, sizeof(build), "%02x/%02x/%02x",\r\nnct6683_read(data, NCT6683_REG_BUILD_MONTH),\r\nnct6683_read(data, NCT6683_REG_BUILD_DAY),\r\nnct6683_read(data, NCT6683_REG_BUILD_YEAR));\r\nelse\r\nscnprintf(build, sizeof(build), "%02d/%02d/%02d",\r\nnct6683_read(data, NCT6683_REG_BUILD_MONTH),\r\nnct6683_read(data, NCT6683_REG_BUILD_DAY),\r\nnct6683_read(data, NCT6683_REG_BUILD_YEAR));\r\ndev_info(dev, "%s EC firmware version %d.%d build %s\n",\r\nnct6683_chip_names[data->kind],\r\nnct6683_read(data, NCT6683_REG_VERSION_HI),\r\nnct6683_read(data, NCT6683_REG_VERSION_LO),\r\nbuild);\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev,\r\nnct6683_device_names[data->kind], data, data->groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}\r\nstatic int nct6683_suspend(struct device *dev)\r\n{\r\nstruct nct6683_data *data = nct6683_update_device(dev);\r\nmutex_lock(&data->update_lock);\r\ndata->hwm_cfg = nct6683_read(data, NCT6683_HWM_CFG);\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int nct6683_resume(struct device *dev)\r\n{\r\nstruct nct6683_data *data = dev_get_drvdata(dev);\r\nmutex_lock(&data->update_lock);\r\nnct6683_write(data, NCT6683_HWM_CFG, data->hwm_cfg);\r\ndata->valid = false;\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int __init nct6683_find(int sioaddr, struct nct6683_sio_data *sio_data)\r\n{\r\nint addr;\r\nu16 val;\r\nint err;\r\nerr = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\nval = (superio_inb(sioaddr, SIO_REG_DEVID) << 8)\r\n| superio_inb(sioaddr, SIO_REG_DEVID + 1);\r\nswitch (val & SIO_ID_MASK) {\r\ncase SIO_NCT6683_ID:\r\nsio_data->kind = nct6683;\r\nbreak;\r\ndefault:\r\nif (val != 0xffff)\r\npr_debug("unsupported chip ID: 0x%04x\n", val);\r\ngoto fail;\r\n}\r\nsuperio_select(sioaddr, NCT6683_LD_HWM);\r\nval = (superio_inb(sioaddr, SIO_REG_ADDR) << 8)\r\n| superio_inb(sioaddr, SIO_REG_ADDR + 1);\r\naddr = val & IOREGION_ALIGNMENT;\r\nif (addr == 0) {\r\npr_err("EC base I/O port unconfigured\n");\r\ngoto fail;\r\n}\r\nval = superio_inb(sioaddr, SIO_REG_ENABLE);\r\nif (!(val & 0x01)) {\r\npr_err("EC is disabled\n");\r\ngoto fail;\r\n}\r\nsuperio_exit(sioaddr);\r\npr_info("Found %s or compatible chip at %#x:%#x\n",\r\nnct6683_chip_names[sio_data->kind], sioaddr, addr);\r\nsio_data->sioreg = sioaddr;\r\nreturn addr;\r\nfail:\r\nsuperio_exit(sioaddr);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init sensors_nct6683_init(void)\r\n{\r\nstruct nct6683_sio_data sio_data;\r\nint sioaddr[2] = { 0x2e, 0x4e };\r\nstruct resource res;\r\nbool found = false;\r\nint address;\r\nint i, err;\r\nerr = platform_driver_register(&nct6683_driver);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(pdev); i++) {\r\naddress = nct6683_find(sioaddr[i], &sio_data);\r\nif (address <= 0)\r\ncontinue;\r\nfound = true;\r\npdev[i] = platform_device_alloc(DRVNAME, address);\r\nif (!pdev[i]) {\r\nerr = -ENOMEM;\r\ngoto exit_device_unregister;\r\n}\r\nerr = platform_device_add_data(pdev[i], &sio_data,\r\nsizeof(struct nct6683_sio_data));\r\nif (err)\r\ngoto exit_device_put;\r\nmemset(&res, 0, sizeof(res));\r\nres.name = DRVNAME;\r\nres.start = address + IOREGION_OFFSET;\r\nres.end = address + IOREGION_OFFSET + IOREGION_LENGTH - 1;\r\nres.flags = IORESOURCE_IO;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err) {\r\nplatform_device_put(pdev[i]);\r\npdev[i] = NULL;\r\ncontinue;\r\n}\r\nerr = platform_device_add_resources(pdev[i], &res, 1);\r\nif (err)\r\ngoto exit_device_put;\r\nerr = platform_device_add(pdev[i]);\r\nif (err)\r\ngoto exit_device_put;\r\n}\r\nif (!found) {\r\nerr = -ENODEV;\r\ngoto exit_unregister;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev[i]);\r\nexit_device_unregister:\r\nwhile (--i >= 0) {\r\nif (pdev[i])\r\nplatform_device_unregister(pdev[i]);\r\n}\r\nexit_unregister:\r\nplatform_driver_unregister(&nct6683_driver);\r\nreturn err;\r\n}\r\nstatic void __exit sensors_nct6683_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pdev); i++) {\r\nif (pdev[i])\r\nplatform_device_unregister(pdev[i]);\r\n}\r\nplatform_driver_unregister(&nct6683_driver);\r\n}
