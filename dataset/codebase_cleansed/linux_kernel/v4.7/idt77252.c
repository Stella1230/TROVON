static void\r\nwaitfor_idle(struct idt77252_dev *card)\r\n{\r\nu32 stat;\r\nstat = readl(SAR_REG_STAT);\r\nwhile (stat & SAR_STAT_CMDBZ)\r\nstat = readl(SAR_REG_STAT);\r\n}\r\nstatic u32\r\nread_sram(struct idt77252_dev *card, unsigned long addr)\r\n{\r\nunsigned long flags;\r\nu32 value;\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(SAR_CMD_READ_SRAM | (addr << 2), SAR_REG_CMD);\r\nwaitfor_idle(card);\r\nvalue = readl(SAR_REG_DR0);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\nreturn value;\r\n}\r\nstatic void\r\nwrite_sram(struct idt77252_dev *card, unsigned long addr, u32 value)\r\n{\r\nunsigned long flags;\r\nif ((idt77252_sram_write_errors == 0) &&\r\n(((addr > card->tst[0] + card->tst_size - 2) &&\r\n(addr < card->tst[0] + card->tst_size)) ||\r\n((addr > card->tst[1] + card->tst_size - 2) &&\r\n(addr < card->tst[1] + card->tst_size)))) {\r\nprintk("%s: ERROR: TST JMP section at %08lx written: %08x\n",\r\ncard->name, addr, value);\r\n}\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(value, SAR_REG_DR0);\r\nwritel(SAR_CMD_WRITE_SRAM | (addr << 2), SAR_REG_CMD);\r\nwaitfor_idle(card);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\n}\r\nstatic u8\r\nread_utility(void *dev, unsigned long ubus_addr)\r\n{\r\nstruct idt77252_dev *card = dev;\r\nunsigned long flags;\r\nu8 value;\r\nif (!card) {\r\nprintk("Error: No such device.\n");\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(SAR_CMD_READ_UTILITY + ubus_addr, SAR_REG_CMD);\r\nwaitfor_idle(card);\r\nvalue = readl(SAR_REG_DR0);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\nreturn value;\r\n}\r\nstatic void\r\nwrite_utility(void *dev, unsigned long ubus_addr, u8 value)\r\n{\r\nstruct idt77252_dev *card = dev;\r\nunsigned long flags;\r\nif (!card) {\r\nprintk("Error: No such device.\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel((u32) value, SAR_REG_DR0);\r\nwritel(SAR_CMD_WRITE_UTILITY + ubus_addr, SAR_REG_CMD);\r\nwaitfor_idle(card);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\n}\r\nstatic u32\r\nidt77252_read_gp(struct idt77252_dev *card)\r\n{\r\nu32 gp;\r\ngp = readl(SAR_REG_GP);\r\n#if 0\r\nprintk("RD: %s\n", gp & SAR_GP_EEDI ? "1" : "0");\r\n#endif\r\nreturn gp;\r\n}\r\nstatic void\r\nidt77252_write_gp(struct idt77252_dev *card, u32 value)\r\n{\r\nunsigned long flags;\r\n#if 0\r\nprintk("WR: %s %s %s\n", value & SAR_GP_EECS ? " " : "/CS",\r\nvalue & SAR_GP_EESCLK ? "HIGH" : "LOW ",\r\nvalue & SAR_GP_EEDO ? "1" : "0");\r\n#endif\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwaitfor_idle(card);\r\nwritel(value, SAR_REG_GP);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\n}\r\nstatic u8\r\nidt77252_eeprom_read_status(struct idt77252_dev *card)\r\n{\r\nu8 byte;\r\nu32 gp;\r\nint i, j;\r\ngp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\r\nfor (i = 0; i < ARRAY_SIZE(rdsrtab); i++) {\r\nidt77252_write_gp(card, gp | rdsrtab[i]);\r\nudelay(5);\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nbyte = 0;\r\nfor (i = 0, j = 0; i < 8; i++) {\r\nbyte <<= 1;\r\nidt77252_write_gp(card, gp | clktab[j++]);\r\nudelay(5);\r\nbyte |= idt77252_read_gp(card) & SAR_GP_EEDI ? 1 : 0;\r\nidt77252_write_gp(card, gp | clktab[j++]);\r\nudelay(5);\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nreturn byte;\r\n}\r\nstatic u8\r\nidt77252_eeprom_read_byte(struct idt77252_dev *card, u8 offset)\r\n{\r\nu8 byte;\r\nu32 gp;\r\nint i, j;\r\ngp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\r\nfor (i = 0; i < ARRAY_SIZE(rdtab); i++) {\r\nidt77252_write_gp(card, gp | rdtab[i]);\r\nudelay(5);\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nfor (i = 0, j = 0; i < 8; i++) {\r\nidt77252_write_gp(card, gp | clktab[j++] |\r\n(offset & 1 ? SAR_GP_EEDO : 0));\r\nudelay(5);\r\nidt77252_write_gp(card, gp | clktab[j++] |\r\n(offset & 1 ? SAR_GP_EEDO : 0));\r\nudelay(5);\r\noffset >>= 1;\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nbyte = 0;\r\nfor (i = 0, j = 0; i < 8; i++) {\r\nbyte <<= 1;\r\nidt77252_write_gp(card, gp | clktab[j++]);\r\nudelay(5);\r\nbyte |= idt77252_read_gp(card) & SAR_GP_EEDI ? 1 : 0;\r\nidt77252_write_gp(card, gp | clktab[j++]);\r\nudelay(5);\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nreturn byte;\r\n}\r\nstatic void\r\nidt77252_eeprom_write_byte(struct idt77252_dev *card, u8 offset, u8 data)\r\n{\r\nu32 gp;\r\nint i, j;\r\ngp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\r\nfor (i = 0; i < ARRAY_SIZE(wrentab); i++) {\r\nidt77252_write_gp(card, gp | wrentab[i]);\r\nudelay(5);\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nfor (i = 0; i < ARRAY_SIZE(wrtab); i++) {\r\nidt77252_write_gp(card, gp | wrtab[i]);\r\nudelay(5);\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nfor (i = 0, j = 0; i < 8; i++) {\r\nidt77252_write_gp(card, gp | clktab[j++] |\r\n(offset & 1 ? SAR_GP_EEDO : 0));\r\nudelay(5);\r\nidt77252_write_gp(card, gp | clktab[j++] |\r\n(offset & 1 ? SAR_GP_EEDO : 0));\r\nudelay(5);\r\noffset >>= 1;\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nfor (i = 0, j = 0; i < 8; i++) {\r\nidt77252_write_gp(card, gp | clktab[j++] |\r\n(data & 1 ? SAR_GP_EEDO : 0));\r\nudelay(5);\r\nidt77252_write_gp(card, gp | clktab[j++] |\r\n(data & 1 ? SAR_GP_EEDO : 0));\r\nudelay(5);\r\ndata >>= 1;\r\n}\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\n}\r\nstatic void\r\nidt77252_eeprom_init(struct idt77252_dev *card)\r\n{\r\nu32 gp;\r\ngp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\r\nidt77252_write_gp(card, gp | SAR_GP_EECS | SAR_GP_EESCLK);\r\nudelay(5);\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\nidt77252_write_gp(card, gp | SAR_GP_EECS | SAR_GP_EESCLK);\r\nudelay(5);\r\nidt77252_write_gp(card, gp | SAR_GP_EECS);\r\nudelay(5);\r\n}\r\nstatic void\r\ndump_tct(struct idt77252_dev *card, int index)\r\n{\r\nunsigned long tct;\r\nint i;\r\ntct = (unsigned long) (card->tct_base + index * SAR_SRAM_TCT_SIZE);\r\nprintk("%s: TCT %x:", card->name, index);\r\nfor (i = 0; i < 8; i++) {\r\nprintk(" %08x", read_sram(card, tct + i));\r\n}\r\nprintk("\n");\r\n}\r\nstatic void\r\nidt77252_tx_dump(struct idt77252_dev *card)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct vc_map *vc;\r\nint i;\r\nprintk("%s\n", __func__);\r\nfor (i = 0; i < card->tct_size; i++) {\r\nvc = card->vcs[i];\r\nif (!vc)\r\ncontinue;\r\nvcc = NULL;\r\nif (vc->rx_vcc)\r\nvcc = vc->rx_vcc;\r\nelse if (vc->tx_vcc)\r\nvcc = vc->tx_vcc;\r\nif (!vcc)\r\ncontinue;\r\nprintk("%s: Connection %d:\n", card->name, vc->index);\r\ndump_tct(card, vc->index);\r\n}\r\n}\r\nstatic int\r\nsb_pool_add(struct idt77252_dev *card, struct sk_buff *skb, int queue)\r\n{\r\nstruct sb_pool *pool = &card->sbpool[queue];\r\nint index;\r\nindex = pool->index;\r\nwhile (pool->skb[index]) {\r\nindex = (index + 1) & FBQ_MASK;\r\nif (index == pool->index)\r\nreturn -ENOBUFS;\r\n}\r\npool->skb[index] = skb;\r\nIDT77252_PRV_POOL(skb) = POOL_HANDLE(queue, index);\r\npool->index = (index + 1) & FBQ_MASK;\r\nreturn 0;\r\n}\r\nstatic void\r\nsb_pool_remove(struct idt77252_dev *card, struct sk_buff *skb)\r\n{\r\nunsigned int queue, index;\r\nu32 handle;\r\nhandle = IDT77252_PRV_POOL(skb);\r\nqueue = POOL_QUEUE(handle);\r\nif (queue > 3)\r\nreturn;\r\nindex = POOL_INDEX(handle);\r\nif (index > FBQ_SIZE - 1)\r\nreturn;\r\ncard->sbpool[queue].skb[index] = NULL;\r\n}\r\nstatic struct sk_buff *\r\nsb_pool_skb(struct idt77252_dev *card, u32 handle)\r\n{\r\nunsigned int queue, index;\r\nqueue = POOL_QUEUE(handle);\r\nif (queue > 3)\r\nreturn NULL;\r\nindex = POOL_INDEX(handle);\r\nif (index > FBQ_SIZE - 1)\r\nreturn NULL;\r\nreturn card->sbpool[queue].skb[index];\r\n}\r\nstatic struct scq_info *\r\nalloc_scq(struct idt77252_dev *card, int class)\r\n{\r\nstruct scq_info *scq;\r\nscq = kzalloc(sizeof(struct scq_info), GFP_KERNEL);\r\nif (!scq)\r\nreturn NULL;\r\nscq->base = dma_zalloc_coherent(&card->pcidev->dev, SCQ_SIZE,\r\n&scq->paddr, GFP_KERNEL);\r\nif (scq->base == NULL) {\r\nkfree(scq);\r\nreturn NULL;\r\n}\r\nscq->next = scq->base;\r\nscq->last = scq->base + (SCQ_ENTRIES - 1);\r\natomic_set(&scq->used, 0);\r\nspin_lock_init(&scq->lock);\r\nspin_lock_init(&scq->skblock);\r\nskb_queue_head_init(&scq->transmit);\r\nskb_queue_head_init(&scq->pending);\r\nTXPRINTK("idt77252: SCQ: base 0x%p, next 0x%p, last 0x%p, paddr %08llx\n",\r\nscq->base, scq->next, scq->last, (unsigned long long)scq->paddr);\r\nreturn scq;\r\n}\r\nstatic void\r\nfree_scq(struct idt77252_dev *card, struct scq_info *scq)\r\n{\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc;\r\ndma_free_coherent(&card->pcidev->dev, SCQ_SIZE,\r\nscq->base, scq->paddr);\r\nwhile ((skb = skb_dequeue(&scq->transmit))) {\r\ndma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb->len, DMA_TO_DEVICE);\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb(skb);\r\n}\r\nwhile ((skb = skb_dequeue(&scq->pending))) {\r\ndma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb->len, DMA_TO_DEVICE);\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb(skb);\r\n}\r\nkfree(scq);\r\n}\r\nstatic int\r\npush_on_scq(struct idt77252_dev *card, struct vc_map *vc, struct sk_buff *skb)\r\n{\r\nstruct scq_info *scq = vc->scq;\r\nunsigned long flags;\r\nstruct scqe *tbd;\r\nint entries;\r\nTXPRINTK("%s: SCQ: next 0x%p\n", card->name, scq->next);\r\natomic_inc(&scq->used);\r\nentries = atomic_read(&scq->used);\r\nif (entries > (SCQ_ENTRIES - 1)) {\r\natomic_dec(&scq->used);\r\ngoto out;\r\n}\r\nskb_queue_tail(&scq->transmit, skb);\r\nspin_lock_irqsave(&vc->lock, flags);\r\nif (vc->estimator) {\r\nstruct atm_vcc *vcc = vc->tx_vcc;\r\nstruct sock *sk = sk_atm(vcc);\r\nvc->estimator->cells += (skb->len + 47) / 48;\r\nif (atomic_read(&sk->sk_wmem_alloc) >\r\n(sk->sk_sndbuf >> 1)) {\r\nu32 cps = vc->estimator->maxcps;\r\nvc->estimator->cps = cps;\r\nvc->estimator->avcps = cps << 5;\r\nif (vc->lacr < vc->init_er) {\r\nvc->lacr = vc->init_er;\r\nwritel(TCMDQ_LACR | (vc->lacr << 16) |\r\nvc->index, SAR_REG_TCMDQ);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vc->lock, flags);\r\ntbd = &IDT77252_PRV_TBD(skb);\r\nspin_lock_irqsave(&scq->lock, flags);\r\nscq->next->word_1 = cpu_to_le32(tbd->word_1 |\r\nSAR_TBD_TSIF | SAR_TBD_GTSI);\r\nscq->next->word_2 = cpu_to_le32(tbd->word_2);\r\nscq->next->word_3 = cpu_to_le32(tbd->word_3);\r\nscq->next->word_4 = cpu_to_le32(tbd->word_4);\r\nif (scq->next == scq->last)\r\nscq->next = scq->base;\r\nelse\r\nscq->next++;\r\nwrite_sram(card, scq->scd,\r\nscq->paddr +\r\n(u32)((unsigned long)scq->next - (unsigned long)scq->base));\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\nscq->trans_start = jiffies;\r\nif (test_and_clear_bit(VCF_IDLE, &vc->flags)) {\r\nwritel(TCMDQ_START_LACR | (vc->lacr << 16) | vc->index,\r\nSAR_REG_TCMDQ);\r\n}\r\nTXPRINTK("%d entries in SCQ used (push).\n", atomic_read(&scq->used));\r\nXPRINTK("%s: SCQ (after push %2d) head = 0x%x, next = 0x%p.\n",\r\ncard->name, atomic_read(&scq->used),\r\nread_sram(card, scq->scd + 1), scq->next);\r\nreturn 0;\r\nout:\r\nif (time_after(jiffies, scq->trans_start + HZ)) {\r\nprintk("%s: Error pushing TBD for %d.%d\n",\r\ncard->name, vc->tx_vcc->vpi, vc->tx_vcc->vci);\r\n#ifdef CONFIG_ATM_IDT77252_DEBUG\r\nidt77252_tx_dump(card);\r\n#endif\r\nscq->trans_start = jiffies;\r\n}\r\nreturn -ENOBUFS;\r\n}\r\nstatic void\r\ndrain_scq(struct idt77252_dev *card, struct vc_map *vc)\r\n{\r\nstruct scq_info *scq = vc->scq;\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc;\r\nTXPRINTK("%s: SCQ (before drain %2d) next = 0x%p.\n",\r\ncard->name, atomic_read(&scq->used), scq->next);\r\nskb = skb_dequeue(&scq->transmit);\r\nif (skb) {\r\nTXPRINTK("%s: freeing skb at %p.\n", card->name, skb);\r\ndma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb->len, DMA_TO_DEVICE);\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb(skb);\r\natomic_inc(&vcc->stats->tx);\r\n}\r\natomic_dec(&scq->used);\r\nspin_lock(&scq->skblock);\r\nwhile ((skb = skb_dequeue(&scq->pending))) {\r\nif (push_on_scq(card, vc, skb)) {\r\nskb_queue_head(&vc->scq->pending, skb);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&scq->skblock);\r\n}\r\nstatic int\r\nqueue_skb(struct idt77252_dev *card, struct vc_map *vc,\r\nstruct sk_buff *skb, int oam)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct scqe *tbd;\r\nunsigned long flags;\r\nint error;\r\nint aal;\r\nif (skb->len == 0) {\r\nprintk("%s: invalid skb->len (%d)\n", card->name, skb->len);\r\nreturn -EINVAL;\r\n}\r\nTXPRINTK("%s: Sending %d bytes of data.\n",\r\ncard->name, skb->len);\r\ntbd = &IDT77252_PRV_TBD(skb);\r\nvcc = ATM_SKB(skb)->vcc;\r\nIDT77252_PRV_PADDR(skb) = dma_map_single(&card->pcidev->dev, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\nerror = -EINVAL;\r\nif (oam) {\r\nif (skb->len != 52)\r\ngoto errout;\r\ntbd->word_1 = SAR_TBD_OAM | ATM_CELL_PAYLOAD | SAR_TBD_EPDU;\r\ntbd->word_2 = IDT77252_PRV_PADDR(skb) + 4;\r\ntbd->word_3 = 0x00000000;\r\ntbd->word_4 = (skb->data[0] << 24) | (skb->data[1] << 16) |\r\n(skb->data[2] << 8) | (skb->data[3] << 0);\r\nif (test_bit(VCF_RSV, &vc->flags))\r\nvc = card->vcs[0];\r\ngoto done;\r\n}\r\nif (test_bit(VCF_RSV, &vc->flags)) {\r\nprintk("%s: Trying to transmit on reserved VC\n", card->name);\r\ngoto errout;\r\n}\r\naal = vcc->qos.aal;\r\nswitch (aal) {\r\ncase ATM_AAL0:\r\ncase ATM_AAL34:\r\nif (skb->len > 52)\r\ngoto errout;\r\nif (aal == ATM_AAL0)\r\ntbd->word_1 = SAR_TBD_EPDU | SAR_TBD_AAL0 |\r\nATM_CELL_PAYLOAD;\r\nelse\r\ntbd->word_1 = SAR_TBD_EPDU | SAR_TBD_AAL34 |\r\nATM_CELL_PAYLOAD;\r\ntbd->word_2 = IDT77252_PRV_PADDR(skb) + 4;\r\ntbd->word_3 = 0x00000000;\r\ntbd->word_4 = (skb->data[0] << 24) | (skb->data[1] << 16) |\r\n(skb->data[2] << 8) | (skb->data[3] << 0);\r\nbreak;\r\ncase ATM_AAL5:\r\ntbd->word_1 = SAR_TBD_EPDU | SAR_TBD_AAL5 | skb->len;\r\ntbd->word_2 = IDT77252_PRV_PADDR(skb);\r\ntbd->word_3 = skb->len;\r\ntbd->word_4 = (vcc->vpi << SAR_TBD_VPI_SHIFT) |\r\n(vcc->vci << SAR_TBD_VCI_SHIFT);\r\nbreak;\r\ncase ATM_AAL1:\r\ncase ATM_AAL2:\r\ndefault:\r\nprintk("%s: Traffic type not supported.\n", card->name);\r\nerror = -EPROTONOSUPPORT;\r\ngoto errout;\r\n}\r\ndone:\r\nspin_lock_irqsave(&vc->scq->skblock, flags);\r\nskb_queue_tail(&vc->scq->pending, skb);\r\nwhile ((skb = skb_dequeue(&vc->scq->pending))) {\r\nif (push_on_scq(card, vc, skb)) {\r\nskb_queue_head(&vc->scq->pending, skb);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&vc->scq->skblock, flags);\r\nreturn 0;\r\nerrout:\r\ndma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb->len, DMA_TO_DEVICE);\r\nreturn error;\r\n}\r\nstatic unsigned long\r\nget_free_scd(struct idt77252_dev *card, struct vc_map *vc)\r\n{\r\nint i;\r\nfor (i = 0; i < card->scd_size; i++) {\r\nif (!card->scd2vc[i]) {\r\ncard->scd2vc[i] = vc;\r\nvc->scd_index = i;\r\nreturn card->scd_base + i * SAR_SRAM_SCD_SIZE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfill_scd(struct idt77252_dev *card, struct scq_info *scq, int class)\r\n{\r\nwrite_sram(card, scq->scd, scq->paddr);\r\nwrite_sram(card, scq->scd + 1, 0x00000000);\r\nwrite_sram(card, scq->scd + 2, 0xffffffff);\r\nwrite_sram(card, scq->scd + 3, 0x00000000);\r\n}\r\nstatic void\r\nclear_scd(struct idt77252_dev *card, struct scq_info *scq, int class)\r\n{\r\nreturn;\r\n}\r\nstatic int\r\ninit_rsq(struct idt77252_dev *card)\r\n{\r\nstruct rsq_entry *rsqe;\r\ncard->rsq.base = dma_zalloc_coherent(&card->pcidev->dev, RSQSIZE,\r\n&card->rsq.paddr, GFP_KERNEL);\r\nif (card->rsq.base == NULL) {\r\nprintk("%s: can't allocate RSQ.\n", card->name);\r\nreturn -1;\r\n}\r\ncard->rsq.last = card->rsq.base + RSQ_NUM_ENTRIES - 1;\r\ncard->rsq.next = card->rsq.last;\r\nfor (rsqe = card->rsq.base; rsqe <= card->rsq.last; rsqe++)\r\nrsqe->word_4 = 0;\r\nwritel((unsigned long) card->rsq.last - (unsigned long) card->rsq.base,\r\nSAR_REG_RSQH);\r\nwritel(card->rsq.paddr, SAR_REG_RSQB);\r\nIPRINTK("%s: RSQ base at 0x%lx (0x%x).\n", card->name,\r\n(unsigned long) card->rsq.base,\r\nreadl(SAR_REG_RSQB));\r\nIPRINTK("%s: RSQ head = 0x%x, base = 0x%x, tail = 0x%x.\n",\r\ncard->name,\r\nreadl(SAR_REG_RSQH),\r\nreadl(SAR_REG_RSQB),\r\nreadl(SAR_REG_RSQT));\r\nreturn 0;\r\n}\r\nstatic void\r\ndeinit_rsq(struct idt77252_dev *card)\r\n{\r\ndma_free_coherent(&card->pcidev->dev, RSQSIZE,\r\ncard->rsq.base, card->rsq.paddr);\r\n}\r\nstatic void\r\ndequeue_rx(struct idt77252_dev *card, struct rsq_entry *rsqe)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct sk_buff *skb;\r\nstruct rx_pool *rpp;\r\nstruct vc_map *vc;\r\nu32 header, vpi, vci;\r\nu32 stat;\r\nint i;\r\nstat = le32_to_cpu(rsqe->word_4);\r\nif (stat & SAR_RSQE_IDLE) {\r\nRXPRINTK("%s: message about inactive connection.\n",\r\ncard->name);\r\nreturn;\r\n}\r\nskb = sb_pool_skb(card, le32_to_cpu(rsqe->word_2));\r\nif (skb == NULL) {\r\nprintk("%s: NULL skb in %s, rsqe: %08x %08x %08x %08x\n",\r\ncard->name, __func__,\r\nle32_to_cpu(rsqe->word_1), le32_to_cpu(rsqe->word_2),\r\nle32_to_cpu(rsqe->word_3), le32_to_cpu(rsqe->word_4));\r\nreturn;\r\n}\r\nheader = le32_to_cpu(rsqe->word_1);\r\nvpi = (header >> 16) & 0x00ff;\r\nvci = (header >> 0) & 0xffff;\r\nRXPRINTK("%s: SDU for %d.%d received in buffer 0x%p (data 0x%p).\n",\r\ncard->name, vpi, vci, skb, skb->data);\r\nif ((vpi >= (1 << card->vpibits)) || (vci != (vci & card->vcimask))) {\r\nprintk("%s: SDU received for out-of-range vc %u.%u\n",\r\ncard->name, vpi, vci);\r\nrecycle_rx_skb(card, skb);\r\nreturn;\r\n}\r\nvc = card->vcs[VPCI2VC(card, vpi, vci)];\r\nif (!vc || !test_bit(VCF_RX, &vc->flags)) {\r\nprintk("%s: SDU received on non RX vc %u.%u\n",\r\ncard->name, vpi, vci);\r\nrecycle_rx_skb(card, skb);\r\nreturn;\r\n}\r\nvcc = vc->rx_vcc;\r\ndma_sync_single_for_cpu(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb_end_pointer(skb) - skb->data,\r\nDMA_FROM_DEVICE);\r\nif ((vcc->qos.aal == ATM_AAL0) ||\r\n(vcc->qos.aal == ATM_AAL34)) {\r\nstruct sk_buff *sb;\r\nunsigned char *cell;\r\nu32 aal0;\r\ncell = skb->data;\r\nfor (i = (stat & SAR_RSQE_CELLCNT); i; i--) {\r\nif ((sb = dev_alloc_skb(64)) == NULL) {\r\nprintk("%s: Can't allocate buffers for aal0.\n",\r\ncard->name);\r\natomic_add(i, &vcc->stats->rx_drop);\r\nbreak;\r\n}\r\nif (!atm_charge(vcc, sb->truesize)) {\r\nRXPRINTK("%s: atm_charge() dropped aal0 packets.\n",\r\ncard->name);\r\natomic_add(i - 1, &vcc->stats->rx_drop);\r\ndev_kfree_skb(sb);\r\nbreak;\r\n}\r\naal0 = (vpi << ATM_HDR_VPI_SHIFT) |\r\n(vci << ATM_HDR_VCI_SHIFT);\r\naal0 |= (stat & SAR_RSQE_EPDU) ? 0x00000002 : 0;\r\naal0 |= (stat & SAR_RSQE_CLP) ? 0x00000001 : 0;\r\n*((u32 *) sb->data) = aal0;\r\nskb_put(sb, sizeof(u32));\r\nmemcpy(skb_put(sb, ATM_CELL_PAYLOAD),\r\ncell, ATM_CELL_PAYLOAD);\r\nATM_SKB(sb)->vcc = vcc;\r\n__net_timestamp(sb);\r\nvcc->push(vcc, sb);\r\natomic_inc(&vcc->stats->rx);\r\ncell += ATM_CELL_PAYLOAD;\r\n}\r\nrecycle_rx_skb(card, skb);\r\nreturn;\r\n}\r\nif (vcc->qos.aal != ATM_AAL5) {\r\nprintk("%s: Unexpected AAL type in dequeue_rx(): %d.\n",\r\ncard->name, vcc->qos.aal);\r\nrecycle_rx_skb(card, skb);\r\nreturn;\r\n}\r\nskb->len = (stat & SAR_RSQE_CELLCNT) * ATM_CELL_PAYLOAD;\r\nrpp = &vc->rcv.rx_pool;\r\n__skb_queue_tail(&rpp->queue, skb);\r\nrpp->len += skb->len;\r\nif (stat & SAR_RSQE_EPDU) {\r\nunsigned char *l1l2;\r\nunsigned int len;\r\nl1l2 = (unsigned char *) ((unsigned long) skb->data + skb->len - 6);\r\nlen = (l1l2[0] << 8) | l1l2[1];\r\nlen = len ? len : 0x10000;\r\nRXPRINTK("%s: PDU has %d bytes.\n", card->name, len);\r\nif ((len + 8 > rpp->len) || (len + (47 + 8) < rpp->len)) {\r\nRXPRINTK("%s: AAL5 PDU size mismatch: %d != %d. "\r\n"(CDC: %08x)\n",\r\ncard->name, len, rpp->len, readl(SAR_REG_CDC));\r\nrecycle_rx_pool_skb(card, rpp);\r\natomic_inc(&vcc->stats->rx_err);\r\nreturn;\r\n}\r\nif (stat & SAR_RSQE_CRC) {\r\nRXPRINTK("%s: AAL5 CRC error.\n", card->name);\r\nrecycle_rx_pool_skb(card, rpp);\r\natomic_inc(&vcc->stats->rx_err);\r\nreturn;\r\n}\r\nif (skb_queue_len(&rpp->queue) > 1) {\r\nstruct sk_buff *sb;\r\nskb = dev_alloc_skb(rpp->len);\r\nif (!skb) {\r\nRXPRINTK("%s: Can't alloc RX skb.\n",\r\ncard->name);\r\nrecycle_rx_pool_skb(card, rpp);\r\natomic_inc(&vcc->stats->rx_err);\r\nreturn;\r\n}\r\nif (!atm_charge(vcc, skb->truesize)) {\r\nrecycle_rx_pool_skb(card, rpp);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nskb_queue_walk(&rpp->queue, sb)\r\nmemcpy(skb_put(skb, sb->len),\r\nsb->data, sb->len);\r\nrecycle_rx_pool_skb(card, rpp);\r\nskb_trim(skb, len);\r\nATM_SKB(skb)->vcc = vcc;\r\n__net_timestamp(skb);\r\nvcc->push(vcc, skb);\r\natomic_inc(&vcc->stats->rx);\r\nreturn;\r\n}\r\nflush_rx_pool(card, rpp);\r\nif (!atm_charge(vcc, skb->truesize)) {\r\nrecycle_rx_skb(card, skb);\r\nreturn;\r\n}\r\ndma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb_end_pointer(skb) - skb->data,\r\nDMA_FROM_DEVICE);\r\nsb_pool_remove(card, skb);\r\nskb_trim(skb, len);\r\nATM_SKB(skb)->vcc = vcc;\r\n__net_timestamp(skb);\r\nvcc->push(vcc, skb);\r\natomic_inc(&vcc->stats->rx);\r\nif (skb->truesize > SAR_FB_SIZE_3)\r\nadd_rx_skb(card, 3, SAR_FB_SIZE_3, 1);\r\nelse if (skb->truesize > SAR_FB_SIZE_2)\r\nadd_rx_skb(card, 2, SAR_FB_SIZE_2, 1);\r\nelse if (skb->truesize > SAR_FB_SIZE_1)\r\nadd_rx_skb(card, 1, SAR_FB_SIZE_1, 1);\r\nelse\r\nadd_rx_skb(card, 0, SAR_FB_SIZE_0, 1);\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nidt77252_rx(struct idt77252_dev *card)\r\n{\r\nstruct rsq_entry *rsqe;\r\nif (card->rsq.next == card->rsq.last)\r\nrsqe = card->rsq.base;\r\nelse\r\nrsqe = card->rsq.next + 1;\r\nif (!(le32_to_cpu(rsqe->word_4) & SAR_RSQE_VALID)) {\r\nRXPRINTK("%s: no entry in RSQ.\n", card->name);\r\nreturn;\r\n}\r\ndo {\r\ndequeue_rx(card, rsqe);\r\nrsqe->word_4 = 0;\r\ncard->rsq.next = rsqe;\r\nif (card->rsq.next == card->rsq.last)\r\nrsqe = card->rsq.base;\r\nelse\r\nrsqe = card->rsq.next + 1;\r\n} while (le32_to_cpu(rsqe->word_4) & SAR_RSQE_VALID);\r\nwritel((unsigned long) card->rsq.next - (unsigned long) card->rsq.base,\r\nSAR_REG_RSQH);\r\n}\r\nstatic void\r\nidt77252_rx_raw(struct idt77252_dev *card)\r\n{\r\nstruct sk_buff *queue;\r\nu32 head, tail;\r\nstruct atm_vcc *vcc;\r\nstruct vc_map *vc;\r\nstruct sk_buff *sb;\r\nif (card->raw_cell_head == NULL) {\r\nu32 handle = le32_to_cpu(*(card->raw_cell_hnd + 1));\r\ncard->raw_cell_head = sb_pool_skb(card, handle);\r\n}\r\nqueue = card->raw_cell_head;\r\nif (!queue)\r\nreturn;\r\nhead = IDT77252_PRV_PADDR(queue) + (queue->data - queue->head - 16);\r\ntail = readl(SAR_REG_RAWCT);\r\ndma_sync_single_for_cpu(&card->pcidev->dev, IDT77252_PRV_PADDR(queue),\r\nskb_end_offset(queue) - 16,\r\nDMA_FROM_DEVICE);\r\nwhile (head != tail) {\r\nunsigned int vpi, vci;\r\nu32 header;\r\nheader = le32_to_cpu(*(u32 *) &queue->data[0]);\r\nvpi = (header & ATM_HDR_VPI_MASK) >> ATM_HDR_VPI_SHIFT;\r\nvci = (header & ATM_HDR_VCI_MASK) >> ATM_HDR_VCI_SHIFT;\r\n#ifdef CONFIG_ATM_IDT77252_DEBUG\r\nif (debug & DBG_RAW_CELL) {\r\nint i;\r\nprintk("%s: raw cell %x.%02x.%04x.%x.%x\n",\r\ncard->name, (header >> 28) & 0x000f,\r\n(header >> 20) & 0x00ff,\r\n(header >> 4) & 0xffff,\r\n(header >> 1) & 0x0007,\r\n(header >> 0) & 0x0001);\r\nfor (i = 16; i < 64; i++)\r\nprintk(" %02x", queue->data[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\nif (vpi >= (1<<card->vpibits) || vci >= (1<<card->vcibits)) {\r\nRPRINTK("%s: SDU received for out-of-range vc %u.%u\n",\r\ncard->name, vpi, vci);\r\ngoto drop;\r\n}\r\nvc = card->vcs[VPCI2VC(card, vpi, vci)];\r\nif (!vc || !test_bit(VCF_RX, &vc->flags)) {\r\nRPRINTK("%s: SDU received on non RX vc %u.%u\n",\r\ncard->name, vpi, vci);\r\ngoto drop;\r\n}\r\nvcc = vc->rx_vcc;\r\nif (vcc->qos.aal != ATM_AAL0) {\r\nRPRINTK("%s: raw cell for non AAL0 vc %u.%u\n",\r\ncard->name, vpi, vci);\r\natomic_inc(&vcc->stats->rx_drop);\r\ngoto drop;\r\n}\r\nif ((sb = dev_alloc_skb(64)) == NULL) {\r\nprintk("%s: Can't allocate buffers for AAL0.\n",\r\ncard->name);\r\natomic_inc(&vcc->stats->rx_err);\r\ngoto drop;\r\n}\r\nif (!atm_charge(vcc, sb->truesize)) {\r\nRXPRINTK("%s: atm_charge() dropped AAL0 packets.\n",\r\ncard->name);\r\ndev_kfree_skb(sb);\r\ngoto drop;\r\n}\r\n*((u32 *) sb->data) = header;\r\nskb_put(sb, sizeof(u32));\r\nmemcpy(skb_put(sb, ATM_CELL_PAYLOAD), &(queue->data[16]),\r\nATM_CELL_PAYLOAD);\r\nATM_SKB(sb)->vcc = vcc;\r\n__net_timestamp(sb);\r\nvcc->push(vcc, sb);\r\natomic_inc(&vcc->stats->rx);\r\ndrop:\r\nskb_pull(queue, 64);\r\nhead = IDT77252_PRV_PADDR(queue)\r\n+ (queue->data - queue->head - 16);\r\nif (queue->len < 128) {\r\nstruct sk_buff *next;\r\nu32 handle;\r\nhead = le32_to_cpu(*(u32 *) &queue->data[0]);\r\nhandle = le32_to_cpu(*(u32 *) &queue->data[4]);\r\nnext = sb_pool_skb(card, handle);\r\nrecycle_rx_skb(card, queue);\r\nif (next) {\r\ncard->raw_cell_head = next;\r\nqueue = card->raw_cell_head;\r\ndma_sync_single_for_cpu(&card->pcidev->dev,\r\nIDT77252_PRV_PADDR(queue),\r\n(skb_end_pointer(queue) -\r\nqueue->data),\r\nDMA_FROM_DEVICE);\r\n} else {\r\ncard->raw_cell_head = NULL;\r\nprintk("%s: raw cell queue overrun\n",\r\ncard->name);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\ninit_tsq(struct idt77252_dev *card)\r\n{\r\nstruct tsq_entry *tsqe;\r\ncard->tsq.base = dma_alloc_coherent(&card->pcidev->dev, RSQSIZE,\r\n&card->tsq.paddr, GFP_KERNEL);\r\nif (card->tsq.base == NULL) {\r\nprintk("%s: can't allocate TSQ.\n", card->name);\r\nreturn -1;\r\n}\r\nmemset(card->tsq.base, 0, TSQSIZE);\r\ncard->tsq.last = card->tsq.base + TSQ_NUM_ENTRIES - 1;\r\ncard->tsq.next = card->tsq.last;\r\nfor (tsqe = card->tsq.base; tsqe <= card->tsq.last; tsqe++)\r\ntsqe->word_2 = cpu_to_le32(SAR_TSQE_INVALID);\r\nwritel(card->tsq.paddr, SAR_REG_TSQB);\r\nwritel((unsigned long) card->tsq.next - (unsigned long) card->tsq.base,\r\nSAR_REG_TSQH);\r\nreturn 0;\r\n}\r\nstatic void\r\ndeinit_tsq(struct idt77252_dev *card)\r\n{\r\ndma_free_coherent(&card->pcidev->dev, TSQSIZE,\r\ncard->tsq.base, card->tsq.paddr);\r\n}\r\nstatic void\r\nidt77252_tx(struct idt77252_dev *card)\r\n{\r\nstruct tsq_entry *tsqe;\r\nunsigned int vpi, vci;\r\nstruct vc_map *vc;\r\nu32 conn, stat;\r\nif (card->tsq.next == card->tsq.last)\r\ntsqe = card->tsq.base;\r\nelse\r\ntsqe = card->tsq.next + 1;\r\nTXPRINTK("idt77252_tx: tsq %p: base %p, next %p, last %p\n", tsqe,\r\ncard->tsq.base, card->tsq.next, card->tsq.last);\r\nTXPRINTK("idt77252_tx: tsqb %08x, tsqt %08x, tsqh %08x, \n",\r\nreadl(SAR_REG_TSQB),\r\nreadl(SAR_REG_TSQT),\r\nreadl(SAR_REG_TSQH));\r\nstat = le32_to_cpu(tsqe->word_2);\r\nif (stat & SAR_TSQE_INVALID)\r\nreturn;\r\ndo {\r\nTXPRINTK("tsqe: 0x%p [0x%08x 0x%08x]\n", tsqe,\r\nle32_to_cpu(tsqe->word_1),\r\nle32_to_cpu(tsqe->word_2));\r\nswitch (stat & SAR_TSQE_TYPE) {\r\ncase SAR_TSQE_TYPE_TIMER:\r\nTXPRINTK("%s: Timer RollOver detected.\n", card->name);\r\nbreak;\r\ncase SAR_TSQE_TYPE_IDLE:\r\nconn = le32_to_cpu(tsqe->word_1);\r\nif (SAR_TSQE_TAG(stat) == 0x10) {\r\n#ifdef NOTDEF\r\nprintk("%s: Connection %d halted.\n",\r\ncard->name,\r\nle32_to_cpu(tsqe->word_1) & 0x1fff);\r\n#endif\r\nbreak;\r\n}\r\nvc = card->vcs[conn & 0x1fff];\r\nif (!vc) {\r\nprintk("%s: could not find VC from conn %d\n",\r\ncard->name, conn & 0x1fff);\r\nbreak;\r\n}\r\nprintk("%s: Connection %d IDLE.\n",\r\ncard->name, vc->index);\r\nset_bit(VCF_IDLE, &vc->flags);\r\nbreak;\r\ncase SAR_TSQE_TYPE_TSR:\r\nconn = le32_to_cpu(tsqe->word_1);\r\nvc = card->vcs[conn & 0x1fff];\r\nif (!vc) {\r\nprintk("%s: no VC at index %d\n",\r\ncard->name,\r\nle32_to_cpu(tsqe->word_1) & 0x1fff);\r\nbreak;\r\n}\r\ndrain_scq(card, vc);\r\nbreak;\r\ncase SAR_TSQE_TYPE_TBD_COMP:\r\nconn = le32_to_cpu(tsqe->word_1);\r\nvpi = (conn >> SAR_TBD_VPI_SHIFT) & 0x00ff;\r\nvci = (conn >> SAR_TBD_VCI_SHIFT) & 0xffff;\r\nif (vpi >= (1 << card->vpibits) ||\r\nvci >= (1 << card->vcibits)) {\r\nprintk("%s: TBD complete: "\r\n"out of range VPI.VCI %u.%u\n",\r\ncard->name, vpi, vci);\r\nbreak;\r\n}\r\nvc = card->vcs[VPCI2VC(card, vpi, vci)];\r\nif (!vc) {\r\nprintk("%s: TBD complete: "\r\n"no VC at VPI.VCI %u.%u\n",\r\ncard->name, vpi, vci);\r\nbreak;\r\n}\r\ndrain_scq(card, vc);\r\nbreak;\r\n}\r\ntsqe->word_2 = cpu_to_le32(SAR_TSQE_INVALID);\r\ncard->tsq.next = tsqe;\r\nif (card->tsq.next == card->tsq.last)\r\ntsqe = card->tsq.base;\r\nelse\r\ntsqe = card->tsq.next + 1;\r\nTXPRINTK("tsqe: %p: base %p, next %p, last %p\n", tsqe,\r\ncard->tsq.base, card->tsq.next, card->tsq.last);\r\nstat = le32_to_cpu(tsqe->word_2);\r\n} while (!(stat & SAR_TSQE_INVALID));\r\nwritel((unsigned long)card->tsq.next - (unsigned long)card->tsq.base,\r\nSAR_REG_TSQH);\r\nXPRINTK("idt77252_tx-after writel%d: TSQ head = 0x%x, tail = 0x%x, next = 0x%p.\n",\r\ncard->index, readl(SAR_REG_TSQH),\r\nreadl(SAR_REG_TSQT), card->tsq.next);\r\n}\r\nstatic void\r\ntst_timer(unsigned long data)\r\n{\r\nstruct idt77252_dev *card = (struct idt77252_dev *)data;\r\nunsigned long base, idle, jump;\r\nunsigned long flags;\r\nu32 pc;\r\nint e;\r\nspin_lock_irqsave(&card->tst_lock, flags);\r\nbase = card->tst[card->tst_index];\r\nidle = card->tst[card->tst_index ^ 1];\r\nif (test_bit(TST_SWITCH_WAIT, &card->tst_state)) {\r\njump = base + card->tst_size - 2;\r\npc = readl(SAR_REG_NOW) >> 2;\r\nif ((pc ^ idle) & ~(card->tst_size - 1)) {\r\nmod_timer(&card->tst_timer, jiffies + 1);\r\ngoto out;\r\n}\r\nclear_bit(TST_SWITCH_WAIT, &card->tst_state);\r\ncard->tst_index ^= 1;\r\nwrite_sram(card, jump, TSTE_OPC_JMP | (base << 2));\r\nbase = card->tst[card->tst_index];\r\nidle = card->tst[card->tst_index ^ 1];\r\nfor (e = 0; e < card->tst_size - 2; e++) {\r\nif (card->soft_tst[e].tste & TSTE_PUSH_IDLE) {\r\nwrite_sram(card, idle + e,\r\ncard->soft_tst[e].tste & TSTE_MASK);\r\ncard->soft_tst[e].tste &= ~(TSTE_PUSH_IDLE);\r\n}\r\n}\r\n}\r\nif (test_and_clear_bit(TST_SWITCH_PENDING, &card->tst_state)) {\r\nfor (e = 0; e < card->tst_size - 2; e++) {\r\nif (card->soft_tst[e].tste & TSTE_PUSH_ACTIVE) {\r\nwrite_sram(card, idle + e,\r\ncard->soft_tst[e].tste & TSTE_MASK);\r\ncard->soft_tst[e].tste &= ~(TSTE_PUSH_ACTIVE);\r\ncard->soft_tst[e].tste |= TSTE_PUSH_IDLE;\r\n}\r\n}\r\njump = base + card->tst_size - 2;\r\nwrite_sram(card, jump, TSTE_OPC_NULL);\r\nset_bit(TST_SWITCH_WAIT, &card->tst_state);\r\nmod_timer(&card->tst_timer, jiffies + 1);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&card->tst_lock, flags);\r\n}\r\nstatic int\r\n__fill_tst(struct idt77252_dev *card, struct vc_map *vc,\r\nint n, unsigned int opc)\r\n{\r\nunsigned long cl, avail;\r\nunsigned long idle;\r\nint e, r;\r\nu32 data;\r\navail = card->tst_size - 2;\r\nfor (e = 0; e < avail; e++) {\r\nif (card->soft_tst[e].vc == NULL)\r\nbreak;\r\n}\r\nif (e >= avail) {\r\nprintk("%s: No free TST entries found\n", card->name);\r\nreturn -1;\r\n}\r\nNPRINTK("%s: conn %d: first TST entry at %d.\n",\r\ncard->name, vc ? vc->index : -1, e);\r\nr = n;\r\ncl = avail;\r\ndata = opc & TSTE_OPC_MASK;\r\nif (vc && (opc != TSTE_OPC_NULL))\r\ndata = opc | vc->index;\r\nidle = card->tst[card->tst_index ^ 1];\r\nwhile (r > 0) {\r\nif ((cl >= avail) && (card->soft_tst[e].vc == NULL)) {\r\nif (vc)\r\ncard->soft_tst[e].vc = vc;\r\nelse\r\ncard->soft_tst[e].vc = (void *)-1;\r\ncard->soft_tst[e].tste = data;\r\nif (timer_pending(&card->tst_timer))\r\ncard->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;\r\nelse {\r\nwrite_sram(card, idle + e, data);\r\ncard->soft_tst[e].tste |= TSTE_PUSH_IDLE;\r\n}\r\ncl -= card->tst_size;\r\nr--;\r\n}\r\nif (++e == avail)\r\ne = 0;\r\ncl += n;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfill_tst(struct idt77252_dev *card, struct vc_map *vc, int n, unsigned int opc)\r\n{\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&card->tst_lock, flags);\r\nres = __fill_tst(card, vc, n, opc);\r\nset_bit(TST_SWITCH_PENDING, &card->tst_state);\r\nif (!timer_pending(&card->tst_timer))\r\nmod_timer(&card->tst_timer, jiffies + 1);\r\nspin_unlock_irqrestore(&card->tst_lock, flags);\r\nreturn res;\r\n}\r\nstatic int\r\n__clear_tst(struct idt77252_dev *card, struct vc_map *vc)\r\n{\r\nunsigned long idle;\r\nint e;\r\nidle = card->tst[card->tst_index ^ 1];\r\nfor (e = 0; e < card->tst_size - 2; e++) {\r\nif (card->soft_tst[e].vc == vc) {\r\ncard->soft_tst[e].vc = NULL;\r\ncard->soft_tst[e].tste = TSTE_OPC_VAR;\r\nif (timer_pending(&card->tst_timer))\r\ncard->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;\r\nelse {\r\nwrite_sram(card, idle + e, TSTE_OPC_VAR);\r\ncard->soft_tst[e].tste |= TSTE_PUSH_IDLE;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nclear_tst(struct idt77252_dev *card, struct vc_map *vc)\r\n{\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&card->tst_lock, flags);\r\nres = __clear_tst(card, vc);\r\nset_bit(TST_SWITCH_PENDING, &card->tst_state);\r\nif (!timer_pending(&card->tst_timer))\r\nmod_timer(&card->tst_timer, jiffies + 1);\r\nspin_unlock_irqrestore(&card->tst_lock, flags);\r\nreturn res;\r\n}\r\nstatic int\r\nchange_tst(struct idt77252_dev *card, struct vc_map *vc,\r\nint n, unsigned int opc)\r\n{\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&card->tst_lock, flags);\r\n__clear_tst(card, vc);\r\nres = __fill_tst(card, vc, n, opc);\r\nset_bit(TST_SWITCH_PENDING, &card->tst_state);\r\nif (!timer_pending(&card->tst_timer))\r\nmod_timer(&card->tst_timer, jiffies + 1);\r\nspin_unlock_irqrestore(&card->tst_lock, flags);\r\nreturn res;\r\n}\r\nstatic int\r\nset_tct(struct idt77252_dev *card, struct vc_map *vc)\r\n{\r\nunsigned long tct;\r\ntct = (unsigned long) (card->tct_base + vc->index * SAR_SRAM_TCT_SIZE);\r\nswitch (vc->class) {\r\ncase SCHED_CBR:\r\nOPRINTK("%s: writing TCT at 0x%lx, SCD 0x%lx.\n",\r\ncard->name, tct, vc->scq->scd);\r\nwrite_sram(card, tct + 0, TCT_CBR | vc->scq->scd);\r\nwrite_sram(card, tct + 1, 0);\r\nwrite_sram(card, tct + 2, 0);\r\nwrite_sram(card, tct + 3, 0);\r\nwrite_sram(card, tct + 4, 0);\r\nwrite_sram(card, tct + 5, 0);\r\nwrite_sram(card, tct + 6, 0);\r\nwrite_sram(card, tct + 7, 0);\r\nbreak;\r\ncase SCHED_UBR:\r\nOPRINTK("%s: writing TCT at 0x%lx, SCD 0x%lx.\n",\r\ncard->name, tct, vc->scq->scd);\r\nwrite_sram(card, tct + 0, TCT_UBR | vc->scq->scd);\r\nwrite_sram(card, tct + 1, 0);\r\nwrite_sram(card, tct + 2, TCT_TSIF);\r\nwrite_sram(card, tct + 3, TCT_HALT | TCT_IDLE);\r\nwrite_sram(card, tct + 4, 0);\r\nwrite_sram(card, tct + 5, vc->init_er);\r\nwrite_sram(card, tct + 6, 0);\r\nwrite_sram(card, tct + 7, TCT_FLAG_UBR);\r\nbreak;\r\ncase SCHED_VBR:\r\ncase SCHED_ABR:\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic __inline__ int\r\nidt77252_fbq_level(struct idt77252_dev *card, int queue)\r\n{\r\nreturn (readl(SAR_REG_STAT) >> (16 + (queue << 2))) & 0x0f;\r\n}\r\nstatic __inline__ int\r\nidt77252_fbq_full(struct idt77252_dev *card, int queue)\r\n{\r\nreturn (readl(SAR_REG_STAT) >> (16 + (queue << 2))) == 0x0f;\r\n}\r\nstatic int\r\npush_rx_skb(struct idt77252_dev *card, struct sk_buff *skb, int queue)\r\n{\r\nunsigned long flags;\r\nu32 handle;\r\nu32 addr;\r\nskb->data = skb->head;\r\nskb_reset_tail_pointer(skb);\r\nskb->len = 0;\r\nskb_reserve(skb, 16);\r\nswitch (queue) {\r\ncase 0:\r\nskb_put(skb, SAR_FB_SIZE_0);\r\nbreak;\r\ncase 1:\r\nskb_put(skb, SAR_FB_SIZE_1);\r\nbreak;\r\ncase 2:\r\nskb_put(skb, SAR_FB_SIZE_2);\r\nbreak;\r\ncase 3:\r\nskb_put(skb, SAR_FB_SIZE_3);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nif (idt77252_fbq_full(card, queue))\r\nreturn -1;\r\nmemset(&skb->data[(skb->len & ~(0x3f)) - 64], 0, 2 * sizeof(u32));\r\nhandle = IDT77252_PRV_POOL(skb);\r\naddr = IDT77252_PRV_PADDR(skb);\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(handle, card->fbq[queue]);\r\nwritel(addr, card->fbq[queue]);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nadd_rx_skb(struct idt77252_dev *card, int queue,\r\nunsigned int size, unsigned int count)\r\n{\r\nstruct sk_buff *skb;\r\ndma_addr_t paddr;\r\nu32 handle;\r\nwhile (count--) {\r\nskb = dev_alloc_skb(size);\r\nif (!skb)\r\nreturn;\r\nif (sb_pool_add(card, skb, queue)) {\r\nprintk("%s: SB POOL full\n", __func__);\r\ngoto outfree;\r\n}\r\npaddr = dma_map_single(&card->pcidev->dev, skb->data,\r\nskb_end_pointer(skb) - skb->data,\r\nDMA_FROM_DEVICE);\r\nIDT77252_PRV_PADDR(skb) = paddr;\r\nif (push_rx_skb(card, skb, queue)) {\r\nprintk("%s: FB QUEUE full\n", __func__);\r\ngoto outunmap;\r\n}\r\n}\r\nreturn;\r\noutunmap:\r\ndma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb_end_pointer(skb) - skb->data, DMA_FROM_DEVICE);\r\nhandle = IDT77252_PRV_POOL(skb);\r\ncard->sbpool[POOL_QUEUE(handle)].skb[POOL_INDEX(handle)] = NULL;\r\noutfree:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nrecycle_rx_skb(struct idt77252_dev *card, struct sk_buff *skb)\r\n{\r\nu32 handle = IDT77252_PRV_POOL(skb);\r\nint err;\r\ndma_sync_single_for_device(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb_end_pointer(skb) - skb->data,\r\nDMA_FROM_DEVICE);\r\nerr = push_rx_skb(card, skb, POOL_QUEUE(handle));\r\nif (err) {\r\ndma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\r\nskb_end_pointer(skb) - skb->data,\r\nDMA_FROM_DEVICE);\r\nsb_pool_remove(card, skb);\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic void\r\nflush_rx_pool(struct idt77252_dev *card, struct rx_pool *rpp)\r\n{\r\nskb_queue_head_init(&rpp->queue);\r\nrpp->len = 0;\r\n}\r\nstatic void\r\nrecycle_rx_pool_skb(struct idt77252_dev *card, struct rx_pool *rpp)\r\n{\r\nstruct sk_buff *skb, *tmp;\r\nskb_queue_walk_safe(&rpp->queue, skb, tmp)\r\nrecycle_rx_skb(card, skb);\r\nflush_rx_pool(card, rpp);\r\n}\r\nstatic void\r\nidt77252_phy_put(struct atm_dev *dev, unsigned char value, unsigned long addr)\r\n{\r\nwrite_utility(dev->dev_data, 0x100 + (addr & 0x1ff), value);\r\n}\r\nstatic unsigned char\r\nidt77252_phy_get(struct atm_dev *dev, unsigned long addr)\r\n{\r\nreturn read_utility(dev->dev_data, 0x100 + (addr & 0x1ff));\r\n}\r\nstatic inline int\r\nidt77252_send_skb(struct atm_vcc *vcc, struct sk_buff *skb, int oam)\r\n{\r\nstruct atm_dev *dev = vcc->dev;\r\nstruct idt77252_dev *card = dev->dev_data;\r\nstruct vc_map *vc = vcc->dev_data;\r\nint err;\r\nif (vc == NULL) {\r\nprintk("%s: NULL connection in send().\n", card->name);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (!test_bit(VCF_TX, &vc->flags)) {\r\nprintk("%s: Trying to transmit on a non-tx VC.\n", card->name);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nswitch (vcc->qos.aal) {\r\ncase ATM_AAL0:\r\ncase ATM_AAL1:\r\ncase ATM_AAL5:\r\nbreak;\r\ndefault:\r\nprintk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (skb_shinfo(skb)->nr_frags != 0) {\r\nprintk("%s: No scatter-gather yet.\n", card->name);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nATM_SKB(skb)->vcc = vcc;\r\nerr = queue_skb(card, vc, skb, oam);\r\nif (err) {\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb(skb);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int idt77252_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nreturn idt77252_send_skb(vcc, skb, 0);\r\n}\r\nstatic int\r\nidt77252_send_oam(struct atm_vcc *vcc, void *cell, int flags)\r\n{\r\nstruct atm_dev *dev = vcc->dev;\r\nstruct idt77252_dev *card = dev->dev_data;\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(64);\r\nif (!skb) {\r\nprintk("%s: Out of memory in send_oam().\n", card->name);\r\natomic_inc(&vcc->stats->tx_err);\r\nreturn -ENOMEM;\r\n}\r\natomic_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\r\nmemcpy(skb_put(skb, 52), cell, 52);\r\nreturn idt77252_send_skb(vcc, skb, 1);\r\n}\r\nstatic __inline__ unsigned int\r\nidt77252_fls(unsigned int x)\r\n{\r\nint r = 1;\r\nif (x == 0)\r\nreturn 0;\r\nif (x & 0xffff0000) {\r\nx >>= 16;\r\nr += 16;\r\n}\r\nif (x & 0xff00) {\r\nx >>= 8;\r\nr += 8;\r\n}\r\nif (x & 0xf0) {\r\nx >>= 4;\r\nr += 4;\r\n}\r\nif (x & 0xc) {\r\nx >>= 2;\r\nr += 2;\r\n}\r\nif (x & 0x2)\r\nr += 1;\r\nreturn r;\r\n}\r\nstatic u16\r\nidt77252_int_to_atmfp(unsigned int rate)\r\n{\r\nu16 m, e;\r\nif (rate == 0)\r\nreturn 0;\r\ne = idt77252_fls(rate) - 1;\r\nif (e < 9)\r\nm = (rate - (1 << e)) << (9 - e);\r\nelse if (e == 9)\r\nm = (rate - (1 << e));\r\nelse\r\nm = (rate - (1 << e)) >> (e - 9);\r\nreturn 0x4000 | (e << 9) | m;\r\n}\r\nstatic u8\r\nidt77252_rate_logindex(struct idt77252_dev *card, int pcr)\r\n{\r\nu16 afp;\r\nafp = idt77252_int_to_atmfp(pcr < 0 ? -pcr : pcr);\r\nif (pcr < 0)\r\nreturn rate_to_log[(afp >> 5) & 0x1ff];\r\nreturn rate_to_log[((afp >> 5) + 1) & 0x1ff];\r\n}\r\nstatic void\r\nidt77252_est_timer(unsigned long data)\r\n{\r\nstruct vc_map *vc = (struct vc_map *)data;\r\nstruct idt77252_dev *card = vc->card;\r\nstruct rate_estimator *est;\r\nunsigned long flags;\r\nu32 rate, cps;\r\nu64 ncells;\r\nu8 lacr;\r\nspin_lock_irqsave(&vc->lock, flags);\r\nest = vc->estimator;\r\nif (!est)\r\ngoto out;\r\nncells = est->cells;\r\nrate = ((u32)(ncells - est->last_cells)) << (7 - est->interval);\r\nest->last_cells = ncells;\r\nest->avcps += ((long)rate - (long)est->avcps) >> est->ewma_log;\r\nest->cps = (est->avcps + 0x1f) >> 5;\r\ncps = est->cps;\r\nif (cps < (est->maxcps >> 4))\r\ncps = est->maxcps >> 4;\r\nlacr = idt77252_rate_logindex(card, cps);\r\nif (lacr > vc->max_er)\r\nlacr = vc->max_er;\r\nif (lacr != vc->lacr) {\r\nvc->lacr = lacr;\r\nwritel(TCMDQ_LACR|(vc->lacr << 16)|vc->index, SAR_REG_TCMDQ);\r\n}\r\nest->timer.expires = jiffies + ((HZ / 4) << est->interval);\r\nadd_timer(&est->timer);\r\nout:\r\nspin_unlock_irqrestore(&vc->lock, flags);\r\n}\r\nstatic struct rate_estimator *\r\nidt77252_init_est(struct vc_map *vc, int pcr)\r\n{\r\nstruct rate_estimator *est;\r\nest = kzalloc(sizeof(struct rate_estimator), GFP_KERNEL);\r\nif (!est)\r\nreturn NULL;\r\nest->maxcps = pcr < 0 ? -pcr : pcr;\r\nest->cps = est->maxcps;\r\nest->avcps = est->cps << 5;\r\nest->interval = 2;\r\nest->ewma_log = 2;\r\ninit_timer(&est->timer);\r\nest->timer.data = (unsigned long)vc;\r\nest->timer.function = idt77252_est_timer;\r\nest->timer.expires = jiffies + ((HZ / 4) << est->interval);\r\nadd_timer(&est->timer);\r\nreturn est;\r\n}\r\nstatic int\r\nidt77252_init_cbr(struct idt77252_dev *card, struct vc_map *vc,\r\nstruct atm_vcc *vcc, struct atm_qos *qos)\r\n{\r\nint tst_free, tst_used, tst_entries;\r\nunsigned long tmpl, modl;\r\nint tcr, tcra;\r\nif ((qos->txtp.max_pcr == 0) &&\r\n(qos->txtp.pcr == 0) && (qos->txtp.min_pcr == 0)) {\r\nprintk("%s: trying to open a CBR VC with cell rate = 0\n",\r\ncard->name);\r\nreturn -EINVAL;\r\n}\r\ntst_used = 0;\r\ntst_free = card->tst_free;\r\nif (test_bit(VCF_TX, &vc->flags))\r\ntst_used = vc->ntste;\r\ntst_free += tst_used;\r\ntcr = atm_pcr_goal(&qos->txtp);\r\ntcra = tcr >= 0 ? tcr : -tcr;\r\nTXPRINTK("%s: CBR target cell rate = %d\n", card->name, tcra);\r\ntmpl = (unsigned long) tcra * ((unsigned long) card->tst_size - 2);\r\nmodl = tmpl % (unsigned long)card->utopia_pcr;\r\ntst_entries = (int) (tmpl / card->utopia_pcr);\r\nif (tcr > 0) {\r\nif (modl > 0)\r\ntst_entries++;\r\n} else if (tcr == 0) {\r\ntst_entries = tst_free - SAR_TST_RESERVED;\r\nif (tst_entries <= 0) {\r\nprintk("%s: no CBR bandwidth free.\n", card->name);\r\nreturn -ENOSR;\r\n}\r\n}\r\nif (tst_entries == 0) {\r\nprintk("%s: selected CBR bandwidth < granularity.\n",\r\ncard->name);\r\nreturn -EINVAL;\r\n}\r\nif (tst_entries > (tst_free - SAR_TST_RESERVED)) {\r\nprintk("%s: not enough CBR bandwidth free.\n", card->name);\r\nreturn -ENOSR;\r\n}\r\nvc->ntste = tst_entries;\r\ncard->tst_free = tst_free - tst_entries;\r\nif (test_bit(VCF_TX, &vc->flags)) {\r\nif (tst_used == tst_entries)\r\nreturn 0;\r\nOPRINTK("%s: modify %d -> %d entries in TST.\n",\r\ncard->name, tst_used, tst_entries);\r\nchange_tst(card, vc, tst_entries, TSTE_OPC_CBR);\r\nreturn 0;\r\n}\r\nOPRINTK("%s: setting %d entries in TST.\n", card->name, tst_entries);\r\nfill_tst(card, vc, tst_entries, TSTE_OPC_CBR);\r\nreturn 0;\r\n}\r\nstatic int\r\nidt77252_init_ubr(struct idt77252_dev *card, struct vc_map *vc,\r\nstruct atm_vcc *vcc, struct atm_qos *qos)\r\n{\r\nunsigned long flags;\r\nint tcr;\r\nspin_lock_irqsave(&vc->lock, flags);\r\nif (vc->estimator) {\r\ndel_timer(&vc->estimator->timer);\r\nkfree(vc->estimator);\r\nvc->estimator = NULL;\r\n}\r\nspin_unlock_irqrestore(&vc->lock, flags);\r\ntcr = atm_pcr_goal(&qos->txtp);\r\nif (tcr == 0)\r\ntcr = card->link_pcr;\r\nvc->estimator = idt77252_init_est(vc, tcr);\r\nvc->class = SCHED_UBR;\r\nvc->init_er = idt77252_rate_logindex(card, tcr);\r\nvc->lacr = vc->init_er;\r\nif (tcr < 0)\r\nvc->max_er = vc->init_er;\r\nelse\r\nvc->max_er = 0xff;\r\nreturn 0;\r\n}\r\nstatic int\r\nidt77252_init_tx(struct idt77252_dev *card, struct vc_map *vc,\r\nstruct atm_vcc *vcc, struct atm_qos *qos)\r\n{\r\nint error;\r\nif (test_bit(VCF_TX, &vc->flags))\r\nreturn -EBUSY;\r\nswitch (qos->txtp.traffic_class) {\r\ncase ATM_CBR:\r\nvc->class = SCHED_CBR;\r\nbreak;\r\ncase ATM_UBR:\r\nvc->class = SCHED_UBR;\r\nbreak;\r\ncase ATM_VBR:\r\ncase ATM_ABR:\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nvc->scq = alloc_scq(card, vc->class);\r\nif (!vc->scq) {\r\nprintk("%s: can't get SCQ.\n", card->name);\r\nreturn -ENOMEM;\r\n}\r\nvc->scq->scd = get_free_scd(card, vc);\r\nif (vc->scq->scd == 0) {\r\nprintk("%s: no SCD available.\n", card->name);\r\nfree_scq(card, vc->scq);\r\nreturn -ENOMEM;\r\n}\r\nfill_scd(card, vc->scq, vc->class);\r\nif (set_tct(card, vc)) {\r\nprintk("%s: class %d not supported.\n",\r\ncard->name, qos->txtp.traffic_class);\r\ncard->scd2vc[vc->scd_index] = NULL;\r\nfree_scq(card, vc->scq);\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nswitch (vc->class) {\r\ncase SCHED_CBR:\r\nerror = idt77252_init_cbr(card, vc, vcc, qos);\r\nif (error) {\r\ncard->scd2vc[vc->scd_index] = NULL;\r\nfree_scq(card, vc->scq);\r\nreturn error;\r\n}\r\nclear_bit(VCF_IDLE, &vc->flags);\r\nwritel(TCMDQ_START | vc->index, SAR_REG_TCMDQ);\r\nbreak;\r\ncase SCHED_UBR:\r\nerror = idt77252_init_ubr(card, vc, vcc, qos);\r\nif (error) {\r\ncard->scd2vc[vc->scd_index] = NULL;\r\nfree_scq(card, vc->scq);\r\nreturn error;\r\n}\r\nset_bit(VCF_IDLE, &vc->flags);\r\nbreak;\r\n}\r\nvc->tx_vcc = vcc;\r\nset_bit(VCF_TX, &vc->flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nidt77252_init_rx(struct idt77252_dev *card, struct vc_map *vc,\r\nstruct atm_vcc *vcc, struct atm_qos *qos)\r\n{\r\nunsigned long flags;\r\nunsigned long addr;\r\nu32 rcte = 0;\r\nif (test_bit(VCF_RX, &vc->flags))\r\nreturn -EBUSY;\r\nvc->rx_vcc = vcc;\r\nset_bit(VCF_RX, &vc->flags);\r\nif ((vcc->vci == 3) || (vcc->vci == 4))\r\nreturn 0;\r\nflush_rx_pool(card, &vc->rcv.rx_pool);\r\nrcte |= SAR_RCTE_CONNECTOPEN;\r\nrcte |= SAR_RCTE_RAWCELLINTEN;\r\nswitch (qos->aal) {\r\ncase ATM_AAL0:\r\nrcte |= SAR_RCTE_RCQ;\r\nbreak;\r\ncase ATM_AAL1:\r\nrcte |= SAR_RCTE_OAM;\r\nbreak;\r\ncase ATM_AAL34:\r\nrcte |= SAR_RCTE_AAL34;\r\nbreak;\r\ncase ATM_AAL5:\r\nrcte |= SAR_RCTE_AAL5;\r\nbreak;\r\ndefault:\r\nrcte |= SAR_RCTE_RCQ;\r\nbreak;\r\n}\r\nif (qos->aal != ATM_AAL5)\r\nrcte |= SAR_RCTE_FBP_1;\r\nelse if (qos->rxtp.max_sdu > SAR_FB_SIZE_2)\r\nrcte |= SAR_RCTE_FBP_3;\r\nelse if (qos->rxtp.max_sdu > SAR_FB_SIZE_1)\r\nrcte |= SAR_RCTE_FBP_2;\r\nelse if (qos->rxtp.max_sdu > SAR_FB_SIZE_0)\r\nrcte |= SAR_RCTE_FBP_1;\r\nelse\r\nrcte |= SAR_RCTE_FBP_01;\r\naddr = card->rct_base + (vc->index << 2);\r\nOPRINTK("%s: writing RCT at 0x%lx\n", card->name, addr);\r\nwrite_sram(card, addr, rcte);\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(SAR_CMD_OPEN_CONNECTION | (addr << 2), SAR_REG_CMD);\r\nwaitfor_idle(card);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nidt77252_open(struct atm_vcc *vcc)\r\n{\r\nstruct atm_dev *dev = vcc->dev;\r\nstruct idt77252_dev *card = dev->dev_data;\r\nstruct vc_map *vc;\r\nunsigned int index;\r\nunsigned int inuse;\r\nint error;\r\nint vci = vcc->vci;\r\nshort vpi = vcc->vpi;\r\nif (vpi == ATM_VPI_UNSPEC || vci == ATM_VCI_UNSPEC)\r\nreturn 0;\r\nif (vpi >= (1 << card->vpibits)) {\r\nprintk("%s: unsupported VPI: %d\n", card->name, vpi);\r\nreturn -EINVAL;\r\n}\r\nif (vci >= (1 << card->vcibits)) {\r\nprintk("%s: unsupported VCI: %d\n", card->name, vci);\r\nreturn -EINVAL;\r\n}\r\nset_bit(ATM_VF_ADDR, &vcc->flags);\r\nmutex_lock(&card->mutex);\r\nOPRINTK("%s: opening vpi.vci: %d.%d\n", card->name, vpi, vci);\r\nswitch (vcc->qos.aal) {\r\ncase ATM_AAL0:\r\ncase ATM_AAL1:\r\ncase ATM_AAL5:\r\nbreak;\r\ndefault:\r\nprintk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);\r\nmutex_unlock(&card->mutex);\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nindex = VPCI2VC(card, vpi, vci);\r\nif (!card->vcs[index]) {\r\ncard->vcs[index] = kzalloc(sizeof(struct vc_map), GFP_KERNEL);\r\nif (!card->vcs[index]) {\r\nprintk("%s: can't alloc vc in open()\n", card->name);\r\nmutex_unlock(&card->mutex);\r\nreturn -ENOMEM;\r\n}\r\ncard->vcs[index]->card = card;\r\ncard->vcs[index]->index = index;\r\nspin_lock_init(&card->vcs[index]->lock);\r\n}\r\nvc = card->vcs[index];\r\nvcc->dev_data = vc;\r\nIPRINTK("%s: idt77252_open: vc = %d (%d.%d) %s/%s (max RX SDU: %u)\n",\r\ncard->name, vc->index, vcc->vpi, vcc->vci,\r\nvcc->qos.rxtp.traffic_class != ATM_NONE ? "rx" : "--",\r\nvcc->qos.txtp.traffic_class != ATM_NONE ? "tx" : "--",\r\nvcc->qos.rxtp.max_sdu);\r\ninuse = 0;\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE &&\r\ntest_bit(VCF_TX, &vc->flags))\r\ninuse = 1;\r\nif (vcc->qos.rxtp.traffic_class != ATM_NONE &&\r\ntest_bit(VCF_RX, &vc->flags))\r\ninuse += 2;\r\nif (inuse) {\r\nprintk("%s: %s vci already in use.\n", card->name,\r\ninuse == 1 ? "tx" : inuse == 2 ? "rx" : "tx and rx");\r\nmutex_unlock(&card->mutex);\r\nreturn -EADDRINUSE;\r\n}\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE) {\r\nerror = idt77252_init_tx(card, vc, vcc, &vcc->qos);\r\nif (error) {\r\nmutex_unlock(&card->mutex);\r\nreturn error;\r\n}\r\n}\r\nif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nerror = idt77252_init_rx(card, vc, vcc, &vcc->qos);\r\nif (error) {\r\nmutex_unlock(&card->mutex);\r\nreturn error;\r\n}\r\n}\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\nmutex_unlock(&card->mutex);\r\nreturn 0;\r\n}\r\nstatic void\r\nidt77252_close(struct atm_vcc *vcc)\r\n{\r\nstruct atm_dev *dev = vcc->dev;\r\nstruct idt77252_dev *card = dev->dev_data;\r\nstruct vc_map *vc = vcc->dev_data;\r\nunsigned long flags;\r\nunsigned long addr;\r\nunsigned long timeout;\r\nmutex_lock(&card->mutex);\r\nIPRINTK("%s: idt77252_close: vc = %d (%d.%d)\n",\r\ncard->name, vc->index, vcc->vpi, vcc->vci);\r\nclear_bit(ATM_VF_READY, &vcc->flags);\r\nif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nspin_lock_irqsave(&vc->lock, flags);\r\nclear_bit(VCF_RX, &vc->flags);\r\nvc->rx_vcc = NULL;\r\nspin_unlock_irqrestore(&vc->lock, flags);\r\nif ((vcc->vci == 3) || (vcc->vci == 4))\r\ngoto done;\r\naddr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(SAR_CMD_CLOSE_CONNECTION | (addr << 2), SAR_REG_CMD);\r\nwaitfor_idle(card);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\nif (skb_queue_len(&vc->rcv.rx_pool.queue) != 0) {\r\nDPRINTK("%s: closing a VC with pending rx buffers.\n",\r\ncard->name);\r\nrecycle_rx_pool_skb(card, &vc->rcv.rx_pool);\r\n}\r\n}\r\ndone:\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE) {\r\nspin_lock_irqsave(&vc->lock, flags);\r\nclear_bit(VCF_TX, &vc->flags);\r\nclear_bit(VCF_IDLE, &vc->flags);\r\nclear_bit(VCF_RSV, &vc->flags);\r\nvc->tx_vcc = NULL;\r\nif (vc->estimator) {\r\ndel_timer(&vc->estimator->timer);\r\nkfree(vc->estimator);\r\nvc->estimator = NULL;\r\n}\r\nspin_unlock_irqrestore(&vc->lock, flags);\r\ntimeout = 5 * 1000;\r\nwhile (atomic_read(&vc->scq->used) > 0) {\r\ntimeout = msleep_interruptible(timeout);\r\nif (!timeout) {\r\npr_warn("%s: SCQ drain timeout: %u used\n",\r\ncard->name, atomic_read(&vc->scq->used));\r\nbreak;\r\n}\r\n}\r\nwritel(TCMDQ_HALT | vc->index, SAR_REG_TCMDQ);\r\nclear_scd(card, vc->scq, vc->class);\r\nif (vc->class == SCHED_CBR) {\r\nclear_tst(card, vc);\r\ncard->tst_free += vc->ntste;\r\nvc->ntste = 0;\r\n}\r\ncard->scd2vc[vc->scd_index] = NULL;\r\nfree_scq(card, vc->scq);\r\n}\r\nmutex_unlock(&card->mutex);\r\n}\r\nstatic int\r\nidt77252_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)\r\n{\r\nstruct atm_dev *dev = vcc->dev;\r\nstruct idt77252_dev *card = dev->dev_data;\r\nstruct vc_map *vc = vcc->dev_data;\r\nint error = 0;\r\nmutex_lock(&card->mutex);\r\nif (qos->txtp.traffic_class != ATM_NONE) {\r\nif (!test_bit(VCF_TX, &vc->flags)) {\r\nerror = idt77252_init_tx(card, vc, vcc, qos);\r\nif (error)\r\ngoto out;\r\n} else {\r\nswitch (qos->txtp.traffic_class) {\r\ncase ATM_CBR:\r\nerror = idt77252_init_cbr(card, vc, vcc, qos);\r\nif (error)\r\ngoto out;\r\nbreak;\r\ncase ATM_UBR:\r\nerror = idt77252_init_ubr(card, vc, vcc, qos);\r\nif (error)\r\ngoto out;\r\nif (!test_bit(VCF_IDLE, &vc->flags)) {\r\nwritel(TCMDQ_LACR | (vc->lacr << 16) |\r\nvc->index, SAR_REG_TCMDQ);\r\n}\r\nbreak;\r\ncase ATM_VBR:\r\ncase ATM_ABR:\r\nerror = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif ((qos->rxtp.traffic_class != ATM_NONE) &&\r\n!test_bit(VCF_RX, &vc->flags)) {\r\nerror = idt77252_init_rx(card, vc, vcc, qos);\r\nif (error)\r\ngoto out;\r\n}\r\nmemcpy(&vcc->qos, qos, sizeof(struct atm_qos));\r\nset_bit(ATM_VF_HASQOS, &vcc->flags);\r\nout:\r\nmutex_unlock(&card->mutex);\r\nreturn error;\r\n}\r\nstatic int\r\nidt77252_proc_read(struct atm_dev *dev, loff_t * pos, char *page)\r\n{\r\nstruct idt77252_dev *card = dev->dev_data;\r\nint i, left;\r\nleft = (int) *pos;\r\nif (!left--)\r\nreturn sprintf(page, "IDT77252 Interrupts:\n");\r\nif (!left--)\r\nreturn sprintf(page, "TSIF: %lu\n", card->irqstat[15]);\r\nif (!left--)\r\nreturn sprintf(page, "TXICP: %lu\n", card->irqstat[14]);\r\nif (!left--)\r\nreturn sprintf(page, "TSQF: %lu\n", card->irqstat[12]);\r\nif (!left--)\r\nreturn sprintf(page, "TMROF: %lu\n", card->irqstat[11]);\r\nif (!left--)\r\nreturn sprintf(page, "PHYI: %lu\n", card->irqstat[10]);\r\nif (!left--)\r\nreturn sprintf(page, "FBQ3A: %lu\n", card->irqstat[8]);\r\nif (!left--)\r\nreturn sprintf(page, "FBQ2A: %lu\n", card->irqstat[7]);\r\nif (!left--)\r\nreturn sprintf(page, "RSQF: %lu\n", card->irqstat[6]);\r\nif (!left--)\r\nreturn sprintf(page, "EPDU: %lu\n", card->irqstat[5]);\r\nif (!left--)\r\nreturn sprintf(page, "RAWCF: %lu\n", card->irqstat[4]);\r\nif (!left--)\r\nreturn sprintf(page, "FBQ1A: %lu\n", card->irqstat[3]);\r\nif (!left--)\r\nreturn sprintf(page, "FBQ0A: %lu\n", card->irqstat[2]);\r\nif (!left--)\r\nreturn sprintf(page, "RSQAF: %lu\n", card->irqstat[1]);\r\nif (!left--)\r\nreturn sprintf(page, "IDT77252 Transmit Connection Table:\n");\r\nfor (i = 0; i < card->tct_size; i++) {\r\nunsigned long tct;\r\nstruct atm_vcc *vcc;\r\nstruct vc_map *vc;\r\nchar *p;\r\nvc = card->vcs[i];\r\nif (!vc)\r\ncontinue;\r\nvcc = NULL;\r\nif (vc->tx_vcc)\r\nvcc = vc->tx_vcc;\r\nif (!vcc)\r\ncontinue;\r\nif (left--)\r\ncontinue;\r\np = page;\r\np += sprintf(p, " %4u: %u.%u: ", i, vcc->vpi, vcc->vci);\r\ntct = (unsigned long) (card->tct_base + i * SAR_SRAM_TCT_SIZE);\r\nfor (i = 0; i < 8; i++)\r\np += sprintf(p, " %08x", read_sram(card, tct + i));\r\np += sprintf(p, "\n");\r\nreturn p - page;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nidt77252_collect_stat(struct idt77252_dev *card)\r\n{\r\n(void) readl(SAR_REG_CDC);\r\n(void) readl(SAR_REG_VPEC);\r\n(void) readl(SAR_REG_ICC);\r\n}\r\nstatic irqreturn_t\r\nidt77252_interrupt(int irq, void *dev_id)\r\n{\r\nstruct idt77252_dev *card = dev_id;\r\nu32 stat;\r\nstat = readl(SAR_REG_STAT) & 0xffff;\r\nif (!stat)\r\nreturn IRQ_NONE;\r\nif (test_and_set_bit(IDT77252_BIT_INTERRUPT, &card->flags)) {\r\nprintk("%s: Re-entering irq_handler()\n", card->name);\r\ngoto out;\r\n}\r\nwritel(stat, SAR_REG_STAT);\r\nif (stat & SAR_STAT_TSIF) {\r\nINTPRINTK("%s: TSIF\n", card->name);\r\ncard->irqstat[15]++;\r\nidt77252_tx(card);\r\n}\r\nif (stat & SAR_STAT_TXICP) {\r\nINTPRINTK("%s: TXICP\n", card->name);\r\ncard->irqstat[14]++;\r\n#ifdef CONFIG_ATM_IDT77252_DEBUG\r\nidt77252_tx_dump(card);\r\n#endif\r\n}\r\nif (stat & SAR_STAT_TSQF) {\r\nINTPRINTK("%s: TSQF\n", card->name);\r\ncard->irqstat[12]++;\r\nidt77252_tx(card);\r\n}\r\nif (stat & SAR_STAT_TMROF) {\r\nINTPRINTK("%s: TMROF\n", card->name);\r\ncard->irqstat[11]++;\r\nidt77252_collect_stat(card);\r\n}\r\nif (stat & SAR_STAT_EPDU) {\r\nINTPRINTK("%s: EPDU\n", card->name);\r\ncard->irqstat[5]++;\r\nidt77252_rx(card);\r\n}\r\nif (stat & SAR_STAT_RSQAF) {\r\nINTPRINTK("%s: RSQAF\n", card->name);\r\ncard->irqstat[1]++;\r\nidt77252_rx(card);\r\n}\r\nif (stat & SAR_STAT_RSQF) {\r\nINTPRINTK("%s: RSQF\n", card->name);\r\ncard->irqstat[6]++;\r\nidt77252_rx(card);\r\n}\r\nif (stat & SAR_STAT_RAWCF) {\r\nINTPRINTK("%s: RAWCF\n", card->name);\r\ncard->irqstat[4]++;\r\nidt77252_rx_raw(card);\r\n}\r\nif (stat & SAR_STAT_PHYI) {\r\nINTPRINTK("%s: PHYI", card->name);\r\ncard->irqstat[10]++;\r\nif (card->atmdev->phy && card->atmdev->phy->interrupt)\r\ncard->atmdev->phy->interrupt(card->atmdev);\r\n}\r\nif (stat & (SAR_STAT_FBQ0A | SAR_STAT_FBQ1A |\r\nSAR_STAT_FBQ2A | SAR_STAT_FBQ3A)) {\r\nwritel(readl(SAR_REG_CFG) & ~(SAR_CFG_FBIE), SAR_REG_CFG);\r\nINTPRINTK("%s: FBQA: %04x\n", card->name, stat);\r\nif (stat & SAR_STAT_FBQ0A)\r\ncard->irqstat[2]++;\r\nif (stat & SAR_STAT_FBQ1A)\r\ncard->irqstat[3]++;\r\nif (stat & SAR_STAT_FBQ2A)\r\ncard->irqstat[7]++;\r\nif (stat & SAR_STAT_FBQ3A)\r\ncard->irqstat[8]++;\r\nschedule_work(&card->tqueue);\r\n}\r\nout:\r\nclear_bit(IDT77252_BIT_INTERRUPT, &card->flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nidt77252_softint(struct work_struct *work)\r\n{\r\nstruct idt77252_dev *card =\r\ncontainer_of(work, struct idt77252_dev, tqueue);\r\nu32 stat;\r\nint done;\r\nfor (done = 1; ; done = 1) {\r\nstat = readl(SAR_REG_STAT) >> 16;\r\nif ((stat & 0x0f) < SAR_FBQ0_HIGH) {\r\nadd_rx_skb(card, 0, SAR_FB_SIZE_0, 32);\r\ndone = 0;\r\n}\r\nstat >>= 4;\r\nif ((stat & 0x0f) < SAR_FBQ1_HIGH) {\r\nadd_rx_skb(card, 1, SAR_FB_SIZE_1, 32);\r\ndone = 0;\r\n}\r\nstat >>= 4;\r\nif ((stat & 0x0f) < SAR_FBQ2_HIGH) {\r\nadd_rx_skb(card, 2, SAR_FB_SIZE_2, 32);\r\ndone = 0;\r\n}\r\nstat >>= 4;\r\nif ((stat & 0x0f) < SAR_FBQ3_HIGH) {\r\nadd_rx_skb(card, 3, SAR_FB_SIZE_3, 32);\r\ndone = 0;\r\n}\r\nif (done)\r\nbreak;\r\n}\r\nwritel(readl(SAR_REG_CFG) | SAR_CFG_FBIE, SAR_REG_CFG);\r\n}\r\nstatic int\r\nopen_card_oam(struct idt77252_dev *card)\r\n{\r\nunsigned long flags;\r\nunsigned long addr;\r\nstruct vc_map *vc;\r\nint vpi, vci;\r\nint index;\r\nu32 rcte;\r\nfor (vpi = 0; vpi < (1 << card->vpibits); vpi++) {\r\nfor (vci = 3; vci < 5; vci++) {\r\nindex = VPCI2VC(card, vpi, vci);\r\nvc = kzalloc(sizeof(struct vc_map), GFP_KERNEL);\r\nif (!vc) {\r\nprintk("%s: can't alloc vc\n", card->name);\r\nreturn -ENOMEM;\r\n}\r\nvc->index = index;\r\ncard->vcs[index] = vc;\r\nflush_rx_pool(card, &vc->rcv.rx_pool);\r\nrcte = SAR_RCTE_CONNECTOPEN |\r\nSAR_RCTE_RAWCELLINTEN |\r\nSAR_RCTE_RCQ |\r\nSAR_RCTE_FBP_1;\r\naddr = card->rct_base + (vc->index << 2);\r\nwrite_sram(card, addr, rcte);\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(SAR_CMD_OPEN_CONNECTION | (addr << 2),\r\nSAR_REG_CMD);\r\nwaitfor_idle(card);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nclose_card_oam(struct idt77252_dev *card)\r\n{\r\nunsigned long flags;\r\nunsigned long addr;\r\nstruct vc_map *vc;\r\nint vpi, vci;\r\nint index;\r\nfor (vpi = 0; vpi < (1 << card->vpibits); vpi++) {\r\nfor (vci = 3; vci < 5; vci++) {\r\nindex = VPCI2VC(card, vpi, vci);\r\nvc = card->vcs[index];\r\naddr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;\r\nspin_lock_irqsave(&card->cmd_lock, flags);\r\nwritel(SAR_CMD_CLOSE_CONNECTION | (addr << 2),\r\nSAR_REG_CMD);\r\nwaitfor_idle(card);\r\nspin_unlock_irqrestore(&card->cmd_lock, flags);\r\nif (skb_queue_len(&vc->rcv.rx_pool.queue) != 0) {\r\nDPRINTK("%s: closing a VC "\r\n"with pending rx buffers.\n",\r\ncard->name);\r\nrecycle_rx_pool_skb(card, &vc->rcv.rx_pool);\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nopen_card_ubr0(struct idt77252_dev *card)\r\n{\r\nstruct vc_map *vc;\r\nvc = kzalloc(sizeof(struct vc_map), GFP_KERNEL);\r\nif (!vc) {\r\nprintk("%s: can't alloc vc\n", card->name);\r\nreturn -ENOMEM;\r\n}\r\ncard->vcs[0] = vc;\r\nvc->class = SCHED_UBR0;\r\nvc->scq = alloc_scq(card, vc->class);\r\nif (!vc->scq) {\r\nprintk("%s: can't get SCQ.\n", card->name);\r\nreturn -ENOMEM;\r\n}\r\ncard->scd2vc[0] = vc;\r\nvc->scd_index = 0;\r\nvc->scq->scd = card->scd_base;\r\nfill_scd(card, vc->scq, vc->class);\r\nwrite_sram(card, card->tct_base + 0, TCT_UBR | card->scd_base);\r\nwrite_sram(card, card->tct_base + 1, 0);\r\nwrite_sram(card, card->tct_base + 2, 0);\r\nwrite_sram(card, card->tct_base + 3, 0);\r\nwrite_sram(card, card->tct_base + 4, 0);\r\nwrite_sram(card, card->tct_base + 5, 0);\r\nwrite_sram(card, card->tct_base + 6, 0);\r\nwrite_sram(card, card->tct_base + 7, TCT_FLAG_UBR);\r\nclear_bit(VCF_IDLE, &vc->flags);\r\nwritel(TCMDQ_START | 0, SAR_REG_TCMDQ);\r\nreturn 0;\r\n}\r\nstatic int\r\nidt77252_dev_open(struct idt77252_dev *card)\r\n{\r\nu32 conf;\r\nif (!test_bit(IDT77252_BIT_INIT, &card->flags)) {\r\nprintk("%s: SAR not yet initialized.\n", card->name);\r\nreturn -1;\r\n}\r\nconf = SAR_CFG_RXPTH|\r\nSAR_RX_DELAY |\r\nSAR_CFG_RAWIE |\r\nSAR_CFG_RQFIE |\r\nSAR_CFG_TMOIE |\r\nSAR_CFG_FBIE |\r\nSAR_CFG_TXEN |\r\nSAR_CFG_TXINT |\r\nSAR_CFG_TXUIE |\r\nSAR_CFG_TXSFI |\r\nSAR_CFG_PHYIE\r\n;\r\n#ifdef CONFIG_ATM_IDT77252_RCV_ALL\r\nconf |= SAR_CFG_VPECA;\r\n#endif\r\nwritel(readl(SAR_REG_CFG) | conf, SAR_REG_CFG);\r\nif (open_card_oam(card)) {\r\nprintk("%s: Error initializing OAM.\n", card->name);\r\nreturn -1;\r\n}\r\nif (open_card_ubr0(card)) {\r\nprintk("%s: Error initializing UBR0.\n", card->name);\r\nreturn -1;\r\n}\r\nIPRINTK("%s: opened IDT77252 ABR SAR.\n", card->name);\r\nreturn 0;\r\n}\r\nstatic void idt77252_dev_close(struct atm_dev *dev)\r\n{\r\nstruct idt77252_dev *card = dev->dev_data;\r\nu32 conf;\r\nclose_card_oam(card);\r\nconf = SAR_CFG_RXPTH |\r\nSAR_RX_DELAY |\r\nSAR_CFG_RAWIE |\r\nSAR_CFG_RQFIE |\r\nSAR_CFG_TMOIE |\r\nSAR_CFG_FBIE |\r\nSAR_CFG_TXEN |\r\nSAR_CFG_TXINT |\r\nSAR_CFG_TXUIE |\r\nSAR_CFG_TXSFI\r\n;\r\nwritel(readl(SAR_REG_CFG) & ~(conf), SAR_REG_CFG);\r\nDIPRINTK("%s: closed IDT77252 ABR SAR.\n", card->name);\r\n}\r\nstatic void\r\ndeinit_card(struct idt77252_dev *card)\r\n{\r\nstruct sk_buff *skb;\r\nint i, j;\r\nif (!test_bit(IDT77252_BIT_INIT, &card->flags)) {\r\nprintk("%s: SAR not yet initialized.\n", card->name);\r\nreturn;\r\n}\r\nDIPRINTK("idt77252: deinitialize card %u\n", card->index);\r\nwritel(0, SAR_REG_CFG);\r\nif (card->atmdev)\r\natm_dev_deregister(card->atmdev);\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0; j < FBQ_SIZE; j++) {\r\nskb = card->sbpool[i].skb[j];\r\nif (skb) {\r\ndma_unmap_single(&card->pcidev->dev,\r\nIDT77252_PRV_PADDR(skb),\r\n(skb_end_pointer(skb) -\r\nskb->data),\r\nDMA_FROM_DEVICE);\r\ncard->sbpool[i].skb[j] = NULL;\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\n}\r\nvfree(card->soft_tst);\r\nvfree(card->scd2vc);\r\nvfree(card->vcs);\r\nif (card->raw_cell_hnd) {\r\ndma_free_coherent(&card->pcidev->dev, 2 * sizeof(u32),\r\ncard->raw_cell_hnd, card->raw_cell_paddr);\r\n}\r\nif (card->rsq.base) {\r\nDIPRINTK("%s: Release RSQ ...\n", card->name);\r\ndeinit_rsq(card);\r\n}\r\nif (card->tsq.base) {\r\nDIPRINTK("%s: Release TSQ ...\n", card->name);\r\ndeinit_tsq(card);\r\n}\r\nDIPRINTK("idt77252: Release IRQ.\n");\r\nfree_irq(card->pcidev->irq, card);\r\nfor (i = 0; i < 4; i++) {\r\nif (card->fbq[i])\r\niounmap(card->fbq[i]);\r\n}\r\nif (card->membase)\r\niounmap(card->membase);\r\nclear_bit(IDT77252_BIT_INIT, &card->flags);\r\nDIPRINTK("%s: Card deinitialized.\n", card->name);\r\n}\r\nstatic void init_sram(struct idt77252_dev *card)\r\n{\r\nint i;\r\nfor (i = 0; i < card->sramsize; i += 4)\r\nwrite_sram(card, (i >> 2), 0);\r\nif (card->sramsize == (512 * 1024)) {\r\ncard->tct_base = SAR_SRAM_TCT_128_BASE;\r\ncard->tct_size = (SAR_SRAM_TCT_128_TOP - card->tct_base + 1)\r\n/ SAR_SRAM_TCT_SIZE;\r\ncard->rct_base = SAR_SRAM_RCT_128_BASE;\r\ncard->rct_size = (SAR_SRAM_RCT_128_TOP - card->rct_base + 1)\r\n/ SAR_SRAM_RCT_SIZE;\r\ncard->rt_base = SAR_SRAM_RT_128_BASE;\r\ncard->scd_base = SAR_SRAM_SCD_128_BASE;\r\ncard->scd_size = (SAR_SRAM_SCD_128_TOP - card->scd_base + 1)\r\n/ SAR_SRAM_SCD_SIZE;\r\ncard->tst[0] = SAR_SRAM_TST1_128_BASE;\r\ncard->tst[1] = SAR_SRAM_TST2_128_BASE;\r\ncard->tst_size = SAR_SRAM_TST1_128_TOP - card->tst[0] + 1;\r\ncard->abrst_base = SAR_SRAM_ABRSTD_128_BASE;\r\ncard->abrst_size = SAR_ABRSTD_SIZE_8K;\r\ncard->fifo_base = SAR_SRAM_FIFO_128_BASE;\r\ncard->fifo_size = SAR_RXFD_SIZE_32K;\r\n} else {\r\ncard->tct_base = SAR_SRAM_TCT_32_BASE;\r\ncard->tct_size = (SAR_SRAM_TCT_32_TOP - card->tct_base + 1)\r\n/ SAR_SRAM_TCT_SIZE;\r\ncard->rct_base = SAR_SRAM_RCT_32_BASE;\r\ncard->rct_size = (SAR_SRAM_RCT_32_TOP - card->rct_base + 1)\r\n/ SAR_SRAM_RCT_SIZE;\r\ncard->rt_base = SAR_SRAM_RT_32_BASE;\r\ncard->scd_base = SAR_SRAM_SCD_32_BASE;\r\ncard->scd_size = (SAR_SRAM_SCD_32_TOP - card->scd_base + 1)\r\n/ SAR_SRAM_SCD_SIZE;\r\ncard->tst[0] = SAR_SRAM_TST1_32_BASE;\r\ncard->tst[1] = SAR_SRAM_TST2_32_BASE;\r\ncard->tst_size = (SAR_SRAM_TST1_32_TOP - card->tst[0] + 1);\r\ncard->abrst_base = SAR_SRAM_ABRSTD_32_BASE;\r\ncard->abrst_size = SAR_ABRSTD_SIZE_1K;\r\ncard->fifo_base = SAR_SRAM_FIFO_32_BASE;\r\ncard->fifo_size = SAR_RXFD_SIZE_4K;\r\n}\r\nfor (i = 0; i < card->tct_size; i++) {\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 0, 0);\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 1, 0);\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 2, 0);\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 3, 0);\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 4, 0);\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 5, 0);\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 6, 0);\r\nwrite_sram(card, i * SAR_SRAM_TCT_SIZE + 7, 0);\r\n}\r\nfor (i = 0; i < card->rct_size; i++) {\r\nwrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE,\r\n(u32) SAR_RCTE_RAWCELLINTEN);\r\nwrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 1,\r\n(u32) 0);\r\nwrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 2,\r\n(u32) 0);\r\nwrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 3,\r\n(u32) 0xffffffff);\r\n}\r\nwritel((SAR_FBQ0_LOW << 28) | 0x00000000 | 0x00000000 |\r\n(SAR_FB_SIZE_0 / 48), SAR_REG_FBQS0);\r\nwritel((SAR_FBQ1_LOW << 28) | 0x00000000 | 0x00000000 |\r\n(SAR_FB_SIZE_1 / 48), SAR_REG_FBQS1);\r\nwritel((SAR_FBQ2_LOW << 28) | 0x00000000 | 0x00000000 |\r\n(SAR_FB_SIZE_2 / 48), SAR_REG_FBQS2);\r\nwritel((SAR_FBQ3_LOW << 28) | 0x00000000 | 0x00000000 |\r\n(SAR_FB_SIZE_3 / 48), SAR_REG_FBQS3);\r\nfor (i = 0; i < 256; i++) {\r\nwrite_sram(card, card->rt_base + i, log_to_rate[i]);\r\n}\r\nfor (i = 0; i < 128; i++) {\r\nunsigned int tmp;\r\ntmp = rate_to_log[(i << 2) + 0] << 0;\r\ntmp |= rate_to_log[(i << 2) + 1] << 8;\r\ntmp |= rate_to_log[(i << 2) + 2] << 16;\r\ntmp |= rate_to_log[(i << 2) + 3] << 24;\r\nwrite_sram(card, card->rt_base + 256 + i, tmp);\r\n}\r\n#if 0\r\nfor (i = 0; i < 128; i++) {\r\nunsigned int tmp;\r\ntmp = RDF[0][(i << 1) + 0] << 16;\r\ntmp |= RDF[0][(i << 1) + 1] << 0;\r\nwrite_sram(card, card->rt_base + 512 + i, tmp);\r\n}\r\nfor (i = 0; i < 128; i++) {\r\nunsigned int tmp;\r\ntmp = AIR[0][(i << 1) + 0] << 16;\r\ntmp |= AIR[0][(i << 1) + 1] << 0;\r\nwrite_sram(card, card->rt_base + 640 + i, tmp);\r\n}\r\n#endif\r\nIPRINTK("%s: initialize rate table ...\n", card->name);\r\nwritel(card->rt_base << 2, SAR_REG_RTBL);\r\nIPRINTK("%s: initialize TST ...\n", card->name);\r\ncard->tst_free = card->tst_size - 2;\r\nfor (i = card->tst[0]; i < card->tst[0] + card->tst_size - 2; i++)\r\nwrite_sram(card, i, TSTE_OPC_VAR);\r\nwrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));\r\nidt77252_sram_write_errors = 1;\r\nwrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));\r\nidt77252_sram_write_errors = 0;\r\nfor (i = card->tst[1]; i < card->tst[1] + card->tst_size - 2; i++)\r\nwrite_sram(card, i, TSTE_OPC_VAR);\r\nwrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));\r\nidt77252_sram_write_errors = 1;\r\nwrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));\r\nidt77252_sram_write_errors = 0;\r\ncard->tst_index = 0;\r\nwritel(card->tst[0] << 2, SAR_REG_TSTB);\r\nIPRINTK("%s: initialize ABRSTD ...\n", card->name);\r\nwritel(card->abrst_size | (card->abrst_base << 2),\r\nSAR_REG_ABRSTD);\r\nIPRINTK("%s: initialize receive fifo ...\n", card->name);\r\nwritel(card->fifo_size | (card->fifo_base << 2),\r\nSAR_REG_RXFD);\r\nIPRINTK("%s: SRAM initialization complete.\n", card->name);\r\n}\r\nstatic int init_card(struct atm_dev *dev)\r\n{\r\nstruct idt77252_dev *card = dev->dev_data;\r\nstruct pci_dev *pcidev = card->pcidev;\r\nunsigned long tmpl, modl;\r\nunsigned int linkrate, rsvdcr;\r\nunsigned int tst_entries;\r\nstruct net_device *tmp;\r\nchar tname[10];\r\nu32 size;\r\nu_char pci_byte;\r\nu32 conf;\r\nint i, k;\r\nif (test_bit(IDT77252_BIT_INIT, &card->flags)) {\r\nprintk("Error: SAR already initialized.\n");\r\nreturn -1;\r\n}\r\nIPRINTK("%s: Checking PCI retries.\n", card->name);\r\nif (pci_read_config_byte(pcidev, 0x40, &pci_byte) != 0) {\r\nprintk("%s: can't read PCI retry timeout.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nif (pci_byte != 0) {\r\nIPRINTK("%s: PCI retry timeout: %d, set to 0.\n",\r\ncard->name, pci_byte);\r\nif (pci_write_config_byte(pcidev, 0x40, 0) != 0) {\r\nprintk("%s: can't set PCI retry timeout.\n",\r\ncard->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\n}\r\nIPRINTK("%s: Checking PCI TRDY.\n", card->name);\r\nif (pci_read_config_byte(pcidev, 0x41, &pci_byte) != 0) {\r\nprintk("%s: can't read PCI TRDY timeout.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nif (pci_byte != 0) {\r\nIPRINTK("%s: PCI TRDY timeout: %d, set to 0.\n",\r\ncard->name, pci_byte);\r\nif (pci_write_config_byte(pcidev, 0x41, 0) != 0) {\r\nprintk("%s: can't set PCI TRDY timeout.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\n}\r\nif (readl(SAR_REG_STAT) & SAR_STAT_TMROF) {\r\nprintk("%s: resetting timer overflow.\n", card->name);\r\nwritel(SAR_STAT_TMROF, SAR_REG_STAT);\r\n}\r\nIPRINTK("%s: Request IRQ ... ", card->name);\r\nif (request_irq(pcidev->irq, idt77252_interrupt, IRQF_SHARED,\r\ncard->name, card) != 0) {\r\nprintk("%s: can't allocate IRQ.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nIPRINTK("got %d.\n", pcidev->irq);\r\nIPRINTK("%s: Initializing SRAM\n", card->name);\r\nconf = SAR_CFG_TX_FIFO_SIZE_9 |\r\nSAR_CFG_RXSTQ_SIZE_8k |\r\nSAR_CFG_IDLE_CLP |\r\n#ifndef ATM_IDT77252_SEND_IDLE\r\nSAR_CFG_NO_IDLE |\r\n#endif\r\n0;\r\nif (card->sramsize == (512 * 1024))\r\nconf |= SAR_CFG_CNTBL_1k;\r\nelse\r\nconf |= SAR_CFG_CNTBL_512;\r\nswitch (vpibits) {\r\ncase 0:\r\nconf |= SAR_CFG_VPVCS_0;\r\nbreak;\r\ndefault:\r\ncase 1:\r\nconf |= SAR_CFG_VPVCS_1;\r\nbreak;\r\ncase 2:\r\nconf |= SAR_CFG_VPVCS_2;\r\nbreak;\r\ncase 8:\r\nconf |= SAR_CFG_VPVCS_8;\r\nbreak;\r\n}\r\nwritel(readl(SAR_REG_CFG) | conf, SAR_REG_CFG);\r\ninit_sram(card);\r\nif (0 != init_tsq(card)) {\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nif (0 != init_rsq(card)) {\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\ncard->vpibits = vpibits;\r\nif (card->sramsize == (512 * 1024)) {\r\ncard->vcibits = 10 - card->vpibits;\r\n} else {\r\ncard->vcibits = 9 - card->vpibits;\r\n}\r\ncard->vcimask = 0;\r\nfor (k = 0, i = 1; k < card->vcibits; k++) {\r\ncard->vcimask |= i;\r\ni <<= 1;\r\n}\r\nIPRINTK("%s: Setting VPI/VCI mask to zero.\n", card->name);\r\nwritel(0, SAR_REG_VPM);\r\nwritel(0, SAR_REG_GP);\r\ncard->raw_cell_hnd = dma_zalloc_coherent(&card->pcidev->dev,\r\n2 * sizeof(u32),\r\n&card->raw_cell_paddr,\r\nGFP_KERNEL);\r\nif (!card->raw_cell_hnd) {\r\nprintk("%s: memory allocation failure.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nwritel(card->raw_cell_paddr, SAR_REG_RAWHND);\r\nIPRINTK("%s: raw cell handle is at 0x%p.\n", card->name,\r\ncard->raw_cell_hnd);\r\nsize = sizeof(struct vc_map *) * card->tct_size;\r\nIPRINTK("%s: allocate %d byte for VC map.\n", card->name, size);\r\ncard->vcs = vzalloc(size);\r\nif (!card->vcs) {\r\nprintk("%s: memory allocation failure.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nsize = sizeof(struct vc_map *) * card->scd_size;\r\nIPRINTK("%s: allocate %d byte for SCD to VC mapping.\n",\r\ncard->name, size);\r\ncard->scd2vc = vzalloc(size);\r\nif (!card->scd2vc) {\r\nprintk("%s: memory allocation failure.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nsize = sizeof(struct tst_info) * (card->tst_size - 2);\r\nIPRINTK("%s: allocate %d byte for TST to VC mapping.\n",\r\ncard->name, size);\r\ncard->soft_tst = vmalloc(size);\r\nif (!card->soft_tst) {\r\nprintk("%s: memory allocation failure.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < card->tst_size - 2; i++) {\r\ncard->soft_tst[i].tste = TSTE_OPC_VAR;\r\ncard->soft_tst[i].vc = NULL;\r\n}\r\nif (dev->phy == NULL) {\r\nprintk("%s: No LT device defined.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nif (dev->phy->ioctl == NULL) {\r\nprintk("%s: LT had no IOCTL function defined.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\n#ifdef CONFIG_ATM_IDT77252_USE_SUNI\r\nlinkrate = 149760000;\r\n#endif\r\ncard->link_pcr = (linkrate / 8 / 53);\r\nprintk("%s: Linkrate on ATM line : %u bit/s, %u cell/s.\n",\r\ncard->name, linkrate, card->link_pcr);\r\n#ifdef ATM_IDT77252_SEND_IDLE\r\ncard->utopia_pcr = card->link_pcr;\r\n#else\r\ncard->utopia_pcr = (160000000 / 8 / 54);\r\n#endif\r\nrsvdcr = 0;\r\nif (card->utopia_pcr > card->link_pcr)\r\nrsvdcr = card->utopia_pcr - card->link_pcr;\r\ntmpl = (unsigned long) rsvdcr * ((unsigned long) card->tst_size - 2);\r\nmodl = tmpl % (unsigned long)card->utopia_pcr;\r\ntst_entries = (int) (tmpl / (unsigned long)card->utopia_pcr);\r\nif (modl)\r\ntst_entries++;\r\ncard->tst_free -= tst_entries;\r\nfill_tst(card, NULL, tst_entries, TSTE_OPC_NULL);\r\n#ifdef HAVE_EEPROM\r\nidt77252_eeprom_init(card);\r\nprintk("%s: EEPROM: %02x:", card->name,\r\nidt77252_eeprom_read_status(card));\r\nfor (i = 0; i < 0x80; i++) {\r\nprintk(" %02x",\r\nidt77252_eeprom_read_byte(card, i)\r\n);\r\n}\r\nprintk("\n");\r\n#endif\r\nsprintf(tname, "eth%d", card->index);\r\ntmp = dev_get_by_name(&init_net, tname);\r\nif (tmp) {\r\nmemcpy(card->atmdev->esi, tmp->dev_addr, 6);\r\ndev_put(tmp);\r\nprintk("%s: ESI %pM\n", card->name, card->atmdev->esi);\r\n}\r\nwritel(0xffff, SAR_REG_MDFCT);\r\nset_bit(IDT77252_BIT_INIT, &card->flags);\r\nXPRINTK("%s: IDT77252 ABR SAR initialization complete.\n", card->name);\r\nreturn 0;\r\n}\r\nstatic int idt77252_preset(struct idt77252_dev *card)\r\n{\r\nu16 pci_command;\r\nXPRINTK("%s: Enable PCI master and memory access for SAR.\n",\r\ncard->name);\r\nif (pci_read_config_word(card->pcidev, PCI_COMMAND, &pci_command)) {\r\nprintk("%s: can't read PCI_COMMAND.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nif (!(pci_command & PCI_COMMAND_IO)) {\r\nprintk("%s: PCI_COMMAND: %04x (???)\n",\r\ncard->name, pci_command);\r\ndeinit_card(card);\r\nreturn (-1);\r\n}\r\npci_command |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\r\nif (pci_write_config_word(card->pcidev, PCI_COMMAND, pci_command)) {\r\nprintk("%s: can't write PCI_COMMAND.\n", card->name);\r\ndeinit_card(card);\r\nreturn -1;\r\n}\r\nwritel(SAR_CFG_SWRST, SAR_REG_CFG);\r\nmdelay(1);\r\nwritel(0, SAR_REG_CFG);\r\nIPRINTK("%s: Software resetted.\n", card->name);\r\nreturn 0;\r\n}\r\nstatic unsigned long probe_sram(struct idt77252_dev *card)\r\n{\r\nu32 data, addr;\r\nwritel(0, SAR_REG_DR0);\r\nwritel(SAR_CMD_WRITE_SRAM | (0 << 2), SAR_REG_CMD);\r\nfor (addr = 0x4000; addr < 0x80000; addr += 0x4000) {\r\nwritel(ATM_POISON, SAR_REG_DR0);\r\nwritel(SAR_CMD_WRITE_SRAM | (addr << 2), SAR_REG_CMD);\r\nwritel(SAR_CMD_READ_SRAM | (0 << 2), SAR_REG_CMD);\r\ndata = readl(SAR_REG_DR0);\r\nif (data != 0)\r\nbreak;\r\n}\r\nreturn addr * sizeof(u32);\r\n}\r\nstatic int idt77252_init_one(struct pci_dev *pcidev,\r\nconst struct pci_device_id *id)\r\n{\r\nstatic struct idt77252_dev **last = &idt77252_chain;\r\nstatic int index = 0;\r\nunsigned long membase, srambase;\r\nstruct idt77252_dev *card;\r\nstruct atm_dev *dev;\r\nint i, err;\r\nif ((err = pci_enable_device(pcidev))) {\r\nprintk("idt77252: can't enable PCI device at %s\n", pci_name(pcidev));\r\nreturn err;\r\n}\r\nif ((err = dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(32)))) {\r\nprintk("idt77252: can't enable DMA for PCI device at %s\n", pci_name(pcidev));\r\nreturn err;\r\n}\r\ncard = kzalloc(sizeof(struct idt77252_dev), GFP_KERNEL);\r\nif (!card) {\r\nprintk("idt77252-%d: can't allocate private data\n", index);\r\nerr = -ENOMEM;\r\ngoto err_out_disable_pdev;\r\n}\r\ncard->revision = pcidev->revision;\r\ncard->index = index;\r\ncard->pcidev = pcidev;\r\nsprintf(card->name, "idt77252-%d", card->index);\r\nINIT_WORK(&card->tqueue, idt77252_softint);\r\nmembase = pci_resource_start(pcidev, 1);\r\nsrambase = pci_resource_start(pcidev, 2);\r\nmutex_init(&card->mutex);\r\nspin_lock_init(&card->cmd_lock);\r\nspin_lock_init(&card->tst_lock);\r\ninit_timer(&card->tst_timer);\r\ncard->tst_timer.data = (unsigned long)card;\r\ncard->tst_timer.function = tst_timer;\r\ncard->membase = ioremap(membase, 1024);\r\nif (!card->membase) {\r\nprintk("%s: can't ioremap() membase\n", card->name);\r\nerr = -EIO;\r\ngoto err_out_free_card;\r\n}\r\nif (idt77252_preset(card)) {\r\nprintk("%s: preset failed\n", card->name);\r\nerr = -EIO;\r\ngoto err_out_iounmap;\r\n}\r\ndev = atm_dev_register("idt77252", &pcidev->dev, &idt77252_ops, -1,\r\nNULL);\r\nif (!dev) {\r\nprintk("%s: can't register atm device\n", card->name);\r\nerr = -EIO;\r\ngoto err_out_iounmap;\r\n}\r\ndev->dev_data = card;\r\ncard->atmdev = dev;\r\n#ifdef CONFIG_ATM_IDT77252_USE_SUNI\r\nsuni_init(dev);\r\nif (!dev->phy) {\r\nprintk("%s: can't init SUNI\n", card->name);\r\nerr = -EIO;\r\ngoto err_out_deinit_card;\r\n}\r\n#endif\r\ncard->sramsize = probe_sram(card);\r\nfor (i = 0; i < 4; i++) {\r\ncard->fbq[i] = ioremap(srambase | 0x200000 | (i << 18), 4);\r\nif (!card->fbq[i]) {\r\nprintk("%s: can't ioremap() FBQ%d\n", card->name, i);\r\nerr = -EIO;\r\ngoto err_out_deinit_card;\r\n}\r\n}\r\nprintk("%s: ABR SAR (Rev %c): MEM %08lx SRAM %08lx [%u KB]\n",\r\ncard->name, ((card->revision > 1) && (card->revision < 25)) ?\r\n'A' + card->revision - 1 : '?', membase, srambase,\r\ncard->sramsize / 1024);\r\nif (init_card(dev)) {\r\nprintk("%s: init_card failed\n", card->name);\r\nerr = -EIO;\r\ngoto err_out_deinit_card;\r\n}\r\ndev->ci_range.vpi_bits = card->vpibits;\r\ndev->ci_range.vci_bits = card->vcibits;\r\ndev->link_rate = card->link_pcr;\r\nif (dev->phy->start)\r\ndev->phy->start(dev);\r\nif (idt77252_dev_open(card)) {\r\nprintk("%s: dev_open failed\n", card->name);\r\nerr = -EIO;\r\ngoto err_out_stop;\r\n}\r\n*last = card;\r\nlast = &card->next;\r\nindex++;\r\nreturn 0;\r\nerr_out_stop:\r\nif (dev->phy->stop)\r\ndev->phy->stop(dev);\r\nerr_out_deinit_card:\r\ndeinit_card(card);\r\nerr_out_iounmap:\r\niounmap(card->membase);\r\nerr_out_free_card:\r\nkfree(card);\r\nerr_out_disable_pdev:\r\npci_disable_device(pcidev);\r\nreturn err;\r\n}\r\nstatic int __init idt77252_init(void)\r\n{\r\nstruct sk_buff *skb;\r\nprintk("%s: at %p\n", __func__, idt77252_init);\r\nif (sizeof(skb->cb) < sizeof(struct atm_skb_data) +\r\nsizeof(struct idt77252_skb_prv)) {\r\nprintk(KERN_ERR "%s: skb->cb is too small (%lu < %lu)\n",\r\n__func__, (unsigned long) sizeof(skb->cb),\r\n(unsigned long) sizeof(struct atm_skb_data) +\r\nsizeof(struct idt77252_skb_prv));\r\nreturn -EIO;\r\n}\r\nreturn pci_register_driver(&idt77252_driver);\r\n}\r\nstatic void __exit idt77252_exit(void)\r\n{\r\nstruct idt77252_dev *card;\r\nstruct atm_dev *dev;\r\npci_unregister_driver(&idt77252_driver);\r\nwhile (idt77252_chain) {\r\ncard = idt77252_chain;\r\ndev = card->atmdev;\r\nidt77252_chain = card->next;\r\nif (dev->phy->stop)\r\ndev->phy->stop(dev);\r\ndeinit_card(card);\r\npci_disable_device(card->pcidev);\r\nkfree(card);\r\n}\r\nDIPRINTK("idt77252: finished cleanup-module().\n");\r\n}
