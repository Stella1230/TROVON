static inline void __atalk_insert_socket(struct sock *sk)\r\n{\r\nsk_add_node(sk, &atalk_sockets);\r\n}\r\nstatic inline void atalk_remove_socket(struct sock *sk)\r\n{\r\nwrite_lock_bh(&atalk_sockets_lock);\r\nsk_del_node_init(sk);\r\nwrite_unlock_bh(&atalk_sockets_lock);\r\n}\r\nstatic struct sock *atalk_search_socket(struct sockaddr_at *to,\r\nstruct atalk_iface *atif)\r\n{\r\nstruct sock *s;\r\nread_lock_bh(&atalk_sockets_lock);\r\nsk_for_each(s, &atalk_sockets) {\r\nstruct atalk_sock *at = at_sk(s);\r\nif (to->sat_port != at->src_port)\r\ncontinue;\r\nif (to->sat_addr.s_net == ATADDR_ANYNET &&\r\nto->sat_addr.s_node == ATADDR_BCAST)\r\ngoto found;\r\nif (to->sat_addr.s_net == at->src_net &&\r\n(to->sat_addr.s_node == at->src_node ||\r\nto->sat_addr.s_node == ATADDR_BCAST ||\r\nto->sat_addr.s_node == ATADDR_ANYNODE))\r\ngoto found;\r\nif (to->sat_addr.s_node == ATADDR_ANYNODE &&\r\nto->sat_addr.s_net != ATADDR_ANYNET &&\r\natif->address.s_node == at->src_node) {\r\nto->sat_addr.s_node = atif->address.s_node;\r\ngoto found;\r\n}\r\n}\r\ns = NULL;\r\nfound:\r\nread_unlock_bh(&atalk_sockets_lock);\r\nreturn s;\r\n}\r\nstatic struct sock *atalk_find_or_insert_socket(struct sock *sk,\r\nstruct sockaddr_at *sat)\r\n{\r\nstruct sock *s;\r\nstruct atalk_sock *at;\r\nwrite_lock_bh(&atalk_sockets_lock);\r\nsk_for_each(s, &atalk_sockets) {\r\nat = at_sk(s);\r\nif (at->src_net == sat->sat_addr.s_net &&\r\nat->src_node == sat->sat_addr.s_node &&\r\nat->src_port == sat->sat_port)\r\ngoto found;\r\n}\r\ns = NULL;\r\n__atalk_insert_socket(sk);\r\nfound:\r\nwrite_unlock_bh(&atalk_sockets_lock);\r\nreturn s;\r\n}\r\nstatic void atalk_destroy_timer(unsigned long data)\r\n{\r\nstruct sock *sk = (struct sock *)data;\r\nif (sk_has_allocations(sk)) {\r\nsk->sk_timer.expires = jiffies + SOCK_DESTROY_TIME;\r\nadd_timer(&sk->sk_timer);\r\n} else\r\nsock_put(sk);\r\n}\r\nstatic inline void atalk_destroy_socket(struct sock *sk)\r\n{\r\natalk_remove_socket(sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nif (sk_has_allocations(sk)) {\r\nsetup_timer(&sk->sk_timer, atalk_destroy_timer,\r\n(unsigned long)sk);\r\nsk->sk_timer.expires = jiffies + SOCK_DESTROY_TIME;\r\nadd_timer(&sk->sk_timer);\r\n} else\r\nsock_put(sk);\r\n}\r\nstatic void atif_drop_device(struct net_device *dev)\r\n{\r\nstruct atalk_iface **iface = &atalk_interfaces;\r\nstruct atalk_iface *tmp;\r\nwrite_lock_bh(&atalk_interfaces_lock);\r\nwhile ((tmp = *iface) != NULL) {\r\nif (tmp->dev == dev) {\r\n*iface = tmp->next;\r\ndev_put(dev);\r\nkfree(tmp);\r\ndev->atalk_ptr = NULL;\r\n} else\r\niface = &tmp->next;\r\n}\r\nwrite_unlock_bh(&atalk_interfaces_lock);\r\n}\r\nstatic struct atalk_iface *atif_add_device(struct net_device *dev,\r\nstruct atalk_addr *sa)\r\n{\r\nstruct atalk_iface *iface = kzalloc(sizeof(*iface), GFP_KERNEL);\r\nif (!iface)\r\ngoto out;\r\ndev_hold(dev);\r\niface->dev = dev;\r\ndev->atalk_ptr = iface;\r\niface->address = *sa;\r\niface->status = 0;\r\nwrite_lock_bh(&atalk_interfaces_lock);\r\niface->next = atalk_interfaces;\r\natalk_interfaces = iface;\r\nwrite_unlock_bh(&atalk_interfaces_lock);\r\nout:\r\nreturn iface;\r\n}\r\nstatic int atif_probe_device(struct atalk_iface *atif)\r\n{\r\nint netrange = ntohs(atif->nets.nr_lastnet) -\r\nntohs(atif->nets.nr_firstnet) + 1;\r\nint probe_net = ntohs(atif->address.s_net);\r\nint probe_node = atif->address.s_node;\r\nint netct, nodect;\r\nif (probe_net == ATADDR_ANYNET) {\r\nprobe_net = ntohs(atif->nets.nr_firstnet);\r\nif (netrange)\r\nprobe_net += jiffies % netrange;\r\n}\r\nif (probe_node == ATADDR_ANYNODE)\r\nprobe_node = jiffies & 0xFF;\r\natif->status |= ATIF_PROBE;\r\nfor (netct = 0; netct <= netrange; netct++) {\r\natif->address.s_net = htons(probe_net);\r\nfor (nodect = 0; nodect < 256; nodect++) {\r\natif->address.s_node = (nodect + probe_node) & 0xFF;\r\nif (atif->address.s_node > 0 &&\r\natif->address.s_node < 254) {\r\naarp_probe_network(atif);\r\nif (!(atif->status & ATIF_PROBE_FAIL)) {\r\natif->status &= ~ATIF_PROBE;\r\nreturn 0;\r\n}\r\n}\r\natif->status &= ~ATIF_PROBE_FAIL;\r\n}\r\nprobe_net++;\r\nif (probe_net > ntohs(atif->nets.nr_lastnet))\r\nprobe_net = ntohs(atif->nets.nr_firstnet);\r\n}\r\natif->status &= ~ATIF_PROBE;\r\nreturn -EADDRINUSE;\r\n}\r\nstatic int atif_proxy_probe_device(struct atalk_iface *atif,\r\nstruct atalk_addr *proxy_addr)\r\n{\r\nint netrange = ntohs(atif->nets.nr_lastnet) -\r\nntohs(atif->nets.nr_firstnet) + 1;\r\nint probe_net = ntohs(atif->address.s_net);\r\nint probe_node = ATADDR_ANYNODE;\r\nint netct, nodect;\r\nif (probe_net == ATADDR_ANYNET) {\r\nprobe_net = ntohs(atif->nets.nr_firstnet);\r\nif (netrange)\r\nprobe_net += jiffies % netrange;\r\n}\r\nif (probe_node == ATADDR_ANYNODE)\r\nprobe_node = jiffies & 0xFF;\r\nfor (netct = 0; netct <= netrange; netct++) {\r\nproxy_addr->s_net = htons(probe_net);\r\nfor (nodect = 0; nodect < 256; nodect++) {\r\nproxy_addr->s_node = (nodect + probe_node) & 0xFF;\r\nif (proxy_addr->s_node > 0 &&\r\nproxy_addr->s_node < 254) {\r\nint ret = aarp_proxy_probe_network(atif,\r\nproxy_addr);\r\nif (ret != -EADDRINUSE)\r\nreturn ret;\r\n}\r\n}\r\nprobe_net++;\r\nif (probe_net > ntohs(atif->nets.nr_lastnet))\r\nprobe_net = ntohs(atif->nets.nr_firstnet);\r\n}\r\nreturn -EADDRINUSE;\r\n}\r\nstruct atalk_addr *atalk_find_dev_addr(struct net_device *dev)\r\n{\r\nstruct atalk_iface *iface = dev->atalk_ptr;\r\nreturn iface ? &iface->address : NULL;\r\n}\r\nstatic struct atalk_addr *atalk_find_primary(void)\r\n{\r\nstruct atalk_iface *fiface = NULL;\r\nstruct atalk_addr *retval;\r\nstruct atalk_iface *iface;\r\nread_lock_bh(&atalk_interfaces_lock);\r\nfor (iface = atalk_interfaces; iface; iface = iface->next) {\r\nif (!fiface && !(iface->dev->flags & IFF_LOOPBACK))\r\nfiface = iface;\r\nif (!(iface->dev->flags & (IFF_LOOPBACK | IFF_POINTOPOINT))) {\r\nretval = &iface->address;\r\ngoto out;\r\n}\r\n}\r\nif (fiface)\r\nretval = &fiface->address;\r\nelse if (atalk_interfaces)\r\nretval = &atalk_interfaces->address;\r\nelse\r\nretval = NULL;\r\nout:\r\nread_unlock_bh(&atalk_interfaces_lock);\r\nreturn retval;\r\n}\r\nstatic struct atalk_iface *atalk_find_anynet(int node, struct net_device *dev)\r\n{\r\nstruct atalk_iface *iface = dev->atalk_ptr;\r\nif (!iface || iface->status & ATIF_PROBE)\r\ngoto out_err;\r\nif (node != ATADDR_BCAST &&\r\niface->address.s_node != node &&\r\nnode != ATADDR_ANYNODE)\r\ngoto out_err;\r\nout:\r\nreturn iface;\r\nout_err:\r\niface = NULL;\r\ngoto out;\r\n}\r\nstatic struct atalk_iface *atalk_find_interface(__be16 net, int node)\r\n{\r\nstruct atalk_iface *iface;\r\nread_lock_bh(&atalk_interfaces_lock);\r\nfor (iface = atalk_interfaces; iface; iface = iface->next) {\r\nif ((node == ATADDR_BCAST ||\r\nnode == ATADDR_ANYNODE ||\r\niface->address.s_node == node) &&\r\niface->address.s_net == net &&\r\n!(iface->status & ATIF_PROBE))\r\nbreak;\r\nif (node == ATADDR_ANYNODE && net != ATADDR_ANYNET &&\r\nntohs(iface->nets.nr_firstnet) <= ntohs(net) &&\r\nntohs(net) <= ntohs(iface->nets.nr_lastnet))\r\nbreak;\r\n}\r\nread_unlock_bh(&atalk_interfaces_lock);\r\nreturn iface;\r\n}\r\nstatic struct atalk_route *atrtr_find(struct atalk_addr *target)\r\n{\r\nstruct atalk_route *net_route = NULL;\r\nstruct atalk_route *r;\r\nread_lock_bh(&atalk_routes_lock);\r\nfor (r = atalk_routes; r; r = r->next) {\r\nif (!(r->flags & RTF_UP))\r\ncontinue;\r\nif (r->target.s_net == target->s_net) {\r\nif (r->flags & RTF_HOST) {\r\nif (r->target.s_node == target->s_node)\r\ngoto out;\r\n} else\r\nnet_route = r;\r\n}\r\n}\r\nif (net_route)\r\nr = net_route;\r\nelse if (atrtr_default.dev)\r\nr = &atrtr_default;\r\nelse\r\nr = NULL;\r\nout:\r\nread_unlock_bh(&atalk_routes_lock);\r\nreturn r;\r\n}\r\nstruct net_device *atrtr_get_dev(struct atalk_addr *sa)\r\n{\r\nstruct atalk_route *atr = atrtr_find(sa);\r\nreturn atr ? atr->dev : NULL;\r\n}\r\nstatic void atrtr_set_default(struct net_device *dev)\r\n{\r\natrtr_default.dev = dev;\r\natrtr_default.flags = RTF_UP;\r\natrtr_default.gateway.s_net = htons(0);\r\natrtr_default.gateway.s_node = 0;\r\n}\r\nstatic int atrtr_create(struct rtentry *r, struct net_device *devhint)\r\n{\r\nstruct sockaddr_at *ta = (struct sockaddr_at *)&r->rt_dst;\r\nstruct sockaddr_at *ga = (struct sockaddr_at *)&r->rt_gateway;\r\nstruct atalk_route *rt;\r\nstruct atalk_iface *iface, *riface;\r\nint retval = -EINVAL;\r\nif (ta->sat_family != AF_APPLETALK ||\r\n(!devhint && ga->sat_family != AF_APPLETALK))\r\ngoto out;\r\nwrite_lock_bh(&atalk_routes_lock);\r\nfor (rt = atalk_routes; rt; rt = rt->next) {\r\nif (r->rt_flags != rt->flags)\r\ncontinue;\r\nif (ta->sat_addr.s_net == rt->target.s_net) {\r\nif (!(rt->flags & RTF_HOST))\r\nbreak;\r\nif (ta->sat_addr.s_node == rt->target.s_node)\r\nbreak;\r\n}\r\n}\r\nif (!devhint) {\r\nriface = NULL;\r\nread_lock_bh(&atalk_interfaces_lock);\r\nfor (iface = atalk_interfaces; iface; iface = iface->next) {\r\nif (!riface &&\r\nntohs(ga->sat_addr.s_net) >=\r\nntohs(iface->nets.nr_firstnet) &&\r\nntohs(ga->sat_addr.s_net) <=\r\nntohs(iface->nets.nr_lastnet))\r\nriface = iface;\r\nif (ga->sat_addr.s_net == iface->address.s_net &&\r\nga->sat_addr.s_node == iface->address.s_node)\r\nriface = iface;\r\n}\r\nread_unlock_bh(&atalk_interfaces_lock);\r\nretval = -ENETUNREACH;\r\nif (!riface)\r\ngoto out_unlock;\r\ndevhint = riface->dev;\r\n}\r\nif (!rt) {\r\nrt = kzalloc(sizeof(*rt), GFP_ATOMIC);\r\nretval = -ENOBUFS;\r\nif (!rt)\r\ngoto out_unlock;\r\nrt->next = atalk_routes;\r\natalk_routes = rt;\r\n}\r\nrt->target = ta->sat_addr;\r\ndev_hold(devhint);\r\nrt->dev = devhint;\r\nrt->flags = r->rt_flags;\r\nrt->gateway = ga->sat_addr;\r\nretval = 0;\r\nout_unlock:\r\nwrite_unlock_bh(&atalk_routes_lock);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int atrtr_delete(struct atalk_addr *addr)\r\n{\r\nstruct atalk_route **r = &atalk_routes;\r\nint retval = 0;\r\nstruct atalk_route *tmp;\r\nwrite_lock_bh(&atalk_routes_lock);\r\nwhile ((tmp = *r) != NULL) {\r\nif (tmp->target.s_net == addr->s_net &&\r\n(!(tmp->flags&RTF_GATEWAY) ||\r\ntmp->target.s_node == addr->s_node)) {\r\n*r = tmp->next;\r\ndev_put(tmp->dev);\r\nkfree(tmp);\r\ngoto out;\r\n}\r\nr = &tmp->next;\r\n}\r\nretval = -ENOENT;\r\nout:\r\nwrite_unlock_bh(&atalk_routes_lock);\r\nreturn retval;\r\n}\r\nstatic void atrtr_device_down(struct net_device *dev)\r\n{\r\nstruct atalk_route **r = &atalk_routes;\r\nstruct atalk_route *tmp;\r\nwrite_lock_bh(&atalk_routes_lock);\r\nwhile ((tmp = *r) != NULL) {\r\nif (tmp->dev == dev) {\r\n*r = tmp->next;\r\ndev_put(dev);\r\nkfree(tmp);\r\n} else\r\nr = &tmp->next;\r\n}\r\nwrite_unlock_bh(&atalk_routes_lock);\r\nif (atrtr_default.dev == dev)\r\natrtr_set_default(NULL);\r\n}\r\nstatic inline void atalk_dev_down(struct net_device *dev)\r\n{\r\natrtr_device_down(dev);\r\naarp_device_down(dev);\r\natif_drop_device(dev);\r\n}\r\nstatic int ddp_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_DOWN)\r\natalk_dev_down(dev);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int atif_ioctl(int cmd, void __user *arg)\r\n{\r\nstatic char aarp_mcast[6] = { 0x09, 0x00, 0x00, 0xFF, 0xFF, 0xFF };\r\nstruct ifreq atreq;\r\nstruct atalk_netrange *nr;\r\nstruct sockaddr_at *sa;\r\nstruct net_device *dev;\r\nstruct atalk_iface *atif;\r\nint ct;\r\nint limit;\r\nstruct rtentry rtdef;\r\nint add_route;\r\nif (copy_from_user(&atreq, arg, sizeof(atreq)))\r\nreturn -EFAULT;\r\ndev = __dev_get_by_name(&init_net, atreq.ifr_name);\r\nif (!dev)\r\nreturn -ENODEV;\r\nsa = (struct sockaddr_at *)&atreq.ifr_addr;\r\natif = atalk_find_dev(dev);\r\nswitch (cmd) {\r\ncase SIOCSIFADDR:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (sa->sat_family != AF_APPLETALK)\r\nreturn -EINVAL;\r\nif (dev->type != ARPHRD_ETHER &&\r\ndev->type != ARPHRD_LOOPBACK &&\r\ndev->type != ARPHRD_LOCALTLK &&\r\ndev->type != ARPHRD_PPP)\r\nreturn -EPROTONOSUPPORT;\r\nnr = (struct atalk_netrange *)&sa->sat_zero[0];\r\nadd_route = 1;\r\nif ((dev->flags & IFF_POINTOPOINT) &&\r\natalk_find_interface(sa->sat_addr.s_net,\r\nsa->sat_addr.s_node)) {\r\nprintk(KERN_DEBUG "AppleTalk: point-to-point "\r\n"interface added with "\r\n"existing address\n");\r\nadd_route = 0;\r\n}\r\nif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\r\nreturn -EPROTONOSUPPORT;\r\nif (sa->sat_addr.s_node == ATADDR_BCAST ||\r\nsa->sat_addr.s_node == 254)\r\nreturn -EINVAL;\r\nif (atif) {\r\nif (atif->status & ATIF_PROBE)\r\nreturn -EBUSY;\r\natif->address.s_net = sa->sat_addr.s_net;\r\natif->address.s_node = sa->sat_addr.s_node;\r\natrtr_device_down(dev);\r\n} else {\r\natif = atif_add_device(dev, &sa->sat_addr);\r\nif (!atif)\r\nreturn -ENOMEM;\r\n}\r\natif->nets = *nr;\r\nif (!(dev->flags & IFF_LOOPBACK) &&\r\n!(dev->flags & IFF_POINTOPOINT) &&\r\natif_probe_device(atif) < 0) {\r\natif_drop_device(dev);\r\nreturn -EADDRINUSE;\r\n}\r\nsa = (struct sockaddr_at *)&rtdef.rt_gateway;\r\nsa->sat_family = AF_APPLETALK;\r\nsa->sat_addr.s_net = atif->address.s_net;\r\nsa->sat_addr.s_node = atif->address.s_node;\r\nsa = (struct sockaddr_at *)&rtdef.rt_dst;\r\nrtdef.rt_flags = RTF_UP;\r\nsa->sat_family = AF_APPLETALK;\r\nsa->sat_addr.s_node = ATADDR_ANYNODE;\r\nif (dev->flags & IFF_LOOPBACK ||\r\ndev->flags & IFF_POINTOPOINT)\r\nrtdef.rt_flags |= RTF_HOST;\r\nif (nr->nr_firstnet == htons(0) &&\r\nnr->nr_lastnet == htons(0xFFFE)) {\r\nsa->sat_addr.s_net = atif->address.s_net;\r\natrtr_create(&rtdef, dev);\r\natrtr_set_default(dev);\r\n} else {\r\nlimit = ntohs(nr->nr_lastnet);\r\nif (limit - ntohs(nr->nr_firstnet) > 4096) {\r\nprintk(KERN_WARNING "Too many routes/"\r\n"iface.\n");\r\nreturn -EINVAL;\r\n}\r\nif (add_route)\r\nfor (ct = ntohs(nr->nr_firstnet);\r\nct <= limit; ct++) {\r\nsa->sat_addr.s_net = htons(ct);\r\natrtr_create(&rtdef, dev);\r\n}\r\n}\r\ndev_mc_add_global(dev, aarp_mcast);\r\nreturn 0;\r\ncase SIOCGIFADDR:\r\nif (!atif)\r\nreturn -EADDRNOTAVAIL;\r\nsa->sat_family = AF_APPLETALK;\r\nsa->sat_addr = atif->address;\r\nbreak;\r\ncase SIOCGIFBRDADDR:\r\nif (!atif)\r\nreturn -EADDRNOTAVAIL;\r\nsa->sat_family = AF_APPLETALK;\r\nsa->sat_addr.s_net = atif->address.s_net;\r\nsa->sat_addr.s_node = ATADDR_BCAST;\r\nbreak;\r\ncase SIOCATALKDIFADDR:\r\ncase SIOCDIFADDR:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (sa->sat_family != AF_APPLETALK)\r\nreturn -EINVAL;\r\natalk_dev_down(dev);\r\nbreak;\r\ncase SIOCSARP:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (sa->sat_family != AF_APPLETALK)\r\nreturn -EINVAL;\r\nif (dev->type != ARPHRD_ETHER)\r\nreturn -EPROTONOSUPPORT;\r\nif (!atif)\r\nreturn -EADDRNOTAVAIL;\r\nnr = (struct atalk_netrange *)&(atif->nets);\r\nif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\r\nreturn -EPROTONOSUPPORT;\r\nif (sa->sat_addr.s_node == ATADDR_BCAST ||\r\nsa->sat_addr.s_node == 254)\r\nreturn -EINVAL;\r\nif (atif_proxy_probe_device(atif, &(sa->sat_addr)) < 0)\r\nreturn -EADDRINUSE;\r\nbreak;\r\ncase SIOCDARP:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (sa->sat_family != AF_APPLETALK)\r\nreturn -EINVAL;\r\nif (!atif)\r\nreturn -EADDRNOTAVAIL;\r\naarp_proxy_remove(atif->dev, &(sa->sat_addr));\r\nreturn 0;\r\n}\r\nreturn copy_to_user(arg, &atreq, sizeof(atreq)) ? -EFAULT : 0;\r\n}\r\nstatic int atrtr_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct rtentry rt;\r\nif (copy_from_user(&rt, arg, sizeof(rt)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase SIOCDELRT:\r\nif (rt.rt_dst.sa_family != AF_APPLETALK)\r\nreturn -EINVAL;\r\nreturn atrtr_delete(&((struct sockaddr_at *)\r\n&rt.rt_dst)->sat_addr);\r\ncase SIOCADDRT: {\r\nstruct net_device *dev = NULL;\r\nif (rt.rt_dev) {\r\nchar name[IFNAMSIZ];\r\nif (copy_from_user(name, rt.rt_dev, IFNAMSIZ-1))\r\nreturn -EFAULT;\r\nname[IFNAMSIZ-1] = '\0';\r\ndev = __dev_get_by_name(&init_net, name);\r\nif (!dev)\r\nreturn -ENODEV;\r\n}\r\nreturn atrtr_create(&rt, dev);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned long atalk_sum_partial(const unsigned char *data,\r\nint len, unsigned long sum)\r\n{\r\nwhile (len--) {\r\nsum += *data++;\r\nsum = rol16(sum, 1);\r\n}\r\nreturn sum;\r\n}\r\nstatic unsigned long atalk_sum_skb(const struct sk_buff *skb, int offset,\r\nint len, unsigned long sum)\r\n{\r\nint start = skb_headlen(skb);\r\nstruct sk_buff *frag_iter;\r\nint i, copy;\r\nif ((copy = start - offset) > 0) {\r\nif (copy > len)\r\ncopy = len;\r\nsum = atalk_sum_partial(skb->data + offset, copy, sum);\r\nif ((len -= copy) == 0)\r\nreturn sum;\r\noffset += copy;\r\n}\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nint end;\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nWARN_ON(start > offset + len);\r\nend = start + skb_frag_size(frag);\r\nif ((copy = end - offset) > 0) {\r\nu8 *vaddr;\r\nif (copy > len)\r\ncopy = len;\r\nvaddr = kmap_atomic(skb_frag_page(frag));\r\nsum = atalk_sum_partial(vaddr + frag->page_offset +\r\noffset - start, copy, sum);\r\nkunmap_atomic(vaddr);\r\nif (!(len -= copy))\r\nreturn sum;\r\noffset += copy;\r\n}\r\nstart = end;\r\n}\r\nskb_walk_frags(skb, frag_iter) {\r\nint end;\r\nWARN_ON(start > offset + len);\r\nend = start + frag_iter->len;\r\nif ((copy = end - offset) > 0) {\r\nif (copy > len)\r\ncopy = len;\r\nsum = atalk_sum_skb(frag_iter, offset - start,\r\ncopy, sum);\r\nif ((len -= copy) == 0)\r\nreturn sum;\r\noffset += copy;\r\n}\r\nstart = end;\r\n}\r\nBUG_ON(len > 0);\r\nreturn sum;\r\n}\r\nstatic __be16 atalk_checksum(const struct sk_buff *skb, int len)\r\n{\r\nunsigned long sum;\r\nsum = atalk_sum_skb(skb, 4, len-4, 0);\r\nreturn sum ? htons((unsigned short)sum) : htons(0xFFFF);\r\n}\r\nstatic int atalk_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nint rc = -ESOCKTNOSUPPORT;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\r\ngoto out;\r\nrc = -ENOMEM;\r\nsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\r\nif (!sk)\r\ngoto out;\r\nrc = 0;\r\nsock->ops = &atalk_dgram_ops;\r\nsock_init_data(sock, sk);\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int atalk_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk) {\r\nsock_hold(sk);\r\nlock_sock(sk);\r\nsock_orphan(sk);\r\nsock->sk = NULL;\r\natalk_destroy_socket(sk);\r\nrelease_sock(sk);\r\nsock_put(sk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atalk_pick_and_bind_port(struct sock *sk, struct sockaddr_at *sat)\r\n{\r\nint retval;\r\nwrite_lock_bh(&atalk_sockets_lock);\r\nfor (sat->sat_port = ATPORT_RESERVED;\r\nsat->sat_port < ATPORT_LAST;\r\nsat->sat_port++) {\r\nstruct sock *s;\r\nsk_for_each(s, &atalk_sockets) {\r\nstruct atalk_sock *at = at_sk(s);\r\nif (at->src_net == sat->sat_addr.s_net &&\r\nat->src_node == sat->sat_addr.s_node &&\r\nat->src_port == sat->sat_port)\r\ngoto try_next_port;\r\n}\r\n__atalk_insert_socket(sk);\r\nat_sk(sk)->src_port = sat->sat_port;\r\nretval = 0;\r\ngoto out;\r\ntry_next_port:;\r\n}\r\nretval = -EBUSY;\r\nout:\r\nwrite_unlock_bh(&atalk_sockets_lock);\r\nreturn retval;\r\n}\r\nstatic int atalk_autobind(struct sock *sk)\r\n{\r\nstruct atalk_sock *at = at_sk(sk);\r\nstruct sockaddr_at sat;\r\nstruct atalk_addr *ap = atalk_find_primary();\r\nint n = -EADDRNOTAVAIL;\r\nif (!ap || ap->s_net == htons(ATADDR_ANYNET))\r\ngoto out;\r\nat->src_net = sat.sat_addr.s_net = ap->s_net;\r\nat->src_node = sat.sat_addr.s_node = ap->s_node;\r\nn = atalk_pick_and_bind_port(sk, &sat);\r\nif (!n)\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nout:\r\nreturn n;\r\n}\r\nstatic int atalk_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sockaddr_at *addr = (struct sockaddr_at *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct atalk_sock *at = at_sk(sk);\r\nint err;\r\nif (!sock_flag(sk, SOCK_ZAPPED) ||\r\naddr_len != sizeof(struct sockaddr_at))\r\nreturn -EINVAL;\r\nif (addr->sat_family != AF_APPLETALK)\r\nreturn -EAFNOSUPPORT;\r\nlock_sock(sk);\r\nif (addr->sat_addr.s_net == htons(ATADDR_ANYNET)) {\r\nstruct atalk_addr *ap = atalk_find_primary();\r\nerr = -EADDRNOTAVAIL;\r\nif (!ap)\r\ngoto out;\r\nat->src_net = addr->sat_addr.s_net = ap->s_net;\r\nat->src_node = addr->sat_addr.s_node = ap->s_node;\r\n} else {\r\nerr = -EADDRNOTAVAIL;\r\nif (!atalk_find_interface(addr->sat_addr.s_net,\r\naddr->sat_addr.s_node))\r\ngoto out;\r\nat->src_net = addr->sat_addr.s_net;\r\nat->src_node = addr->sat_addr.s_node;\r\n}\r\nif (addr->sat_port == ATADDR_ANYPORT) {\r\nerr = atalk_pick_and_bind_port(sk, addr);\r\nif (err < 0)\r\ngoto out;\r\n} else {\r\nat->src_port = addr->sat_port;\r\nerr = -EADDRINUSE;\r\nif (atalk_find_or_insert_socket(sk, addr))\r\ngoto out;\r\n}\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int atalk_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct atalk_sock *at = at_sk(sk);\r\nstruct sockaddr_at *addr;\r\nint err;\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nif (addr_len != sizeof(*addr))\r\nreturn -EINVAL;\r\naddr = (struct sockaddr_at *)uaddr;\r\nif (addr->sat_family != AF_APPLETALK)\r\nreturn -EAFNOSUPPORT;\r\nif (addr->sat_addr.s_node == ATADDR_BCAST &&\r\n!sock_flag(sk, SOCK_BROADCAST)) {\r\n#if 1\r\npr_warn("atalk_connect: %s is broken and did not set SO_BROADCAST.\n",\r\ncurrent->comm);\r\n#else\r\nreturn -EACCES;\r\n#endif\r\n}\r\nlock_sock(sk);\r\nerr = -EBUSY;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\nif (atalk_autobind(sk) < 0)\r\ngoto out;\r\nerr = -ENETUNREACH;\r\nif (!atrtr_get_dev(&addr->sat_addr))\r\ngoto out;\r\nat->dest_port = addr->sat_port;\r\nat->dest_net = addr->sat_addr.s_net;\r\nat->dest_node = addr->sat_addr.s_node;\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sockaddr_at sat;\r\nstruct sock *sk = sock->sk;\r\nstruct atalk_sock *at = at_sk(sk);\r\nint err;\r\nlock_sock(sk);\r\nerr = -ENOBUFS;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\nif (atalk_autobind(sk) < 0)\r\ngoto out;\r\n*uaddr_len = sizeof(struct sockaddr_at);\r\nmemset(&sat, 0, sizeof(sat));\r\nif (peer) {\r\nerr = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nsat.sat_addr.s_net = at->dest_net;\r\nsat.sat_addr.s_node = at->dest_node;\r\nsat.sat_port = at->dest_port;\r\n} else {\r\nsat.sat_addr.s_net = at->src_net;\r\nsat.sat_addr.s_node = at->src_node;\r\nsat.sat_port = at->src_port;\r\n}\r\nerr = 0;\r\nsat.sat_family = AF_APPLETALK;\r\nmemcpy(uaddr, &sat, sizeof(sat));\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic __inline__ int is_ip_over_ddp(struct sk_buff *skb)\r\n{\r\nreturn skb->data[12] == 22;\r\n}\r\nstatic int handle_ip_over_ddp(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = __dev_get_by_name(&init_net, "ipddp0");\r\nstruct net_device_stats *stats;\r\nif (!dev) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nskb->protocol = htons(ETH_P_IP);\r\nskb_pull(skb, 13);\r\nskb->dev = dev;\r\nskb_reset_transport_header(skb);\r\nstats = netdev_priv(dev);\r\nstats->rx_packets++;\r\nstats->rx_bytes += skb->len + 13;\r\nreturn netif_rx(skb);\r\n}\r\nstatic int atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\r\nstruct ddpehdr *ddp, __u16 len_hops, int origlen)\r\n{\r\nstruct atalk_route *rt;\r\nstruct atalk_addr ta;\r\nif (skb->pkt_type != PACKET_HOST || !ddp->deh_dnet) {\r\nif (dev->type == ARPHRD_PPP)\r\nprintk(KERN_DEBUG "AppleTalk: didn't forward broadcast "\r\n"packet received from PPP iface\n");\r\ngoto free_it;\r\n}\r\nta.s_net = ddp->deh_dnet;\r\nta.s_node = ddp->deh_dnode;\r\nrt = atrtr_find(&ta);\r\nlen_hops += 1 << 10;\r\nif (!rt || !(len_hops & (15 << 10)))\r\ngoto free_it;\r\nif (rt->flags & RTF_GATEWAY) {\r\nta.s_net = rt->gateway.s_net;\r\nta.s_node = rt->gateway.s_node;\r\n}\r\nskb_trim(skb, min_t(unsigned int, origlen,\r\n(rt->dev->hard_header_len +\r\nddp_dl->header_length + (len_hops & 1023))));\r\nddp->deh_len_hops = htons(len_hops);\r\nif (skb_headroom(skb) < 22) {\r\nstruct sk_buff *nskb = skb_realloc_headroom(skb, 32);\r\nkfree_skb(skb);\r\nskb = nskb;\r\n} else\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto drop;\r\nif (aarp_send_ddp(rt->dev, skb, &ta, NULL) == NET_XMIT_DROP)\r\nreturn NET_RX_DROP;\r\nreturn NET_RX_SUCCESS;\r\nfree_it:\r\nkfree_skb(skb);\r\ndrop:\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct ddpehdr *ddp;\r\nstruct sock *sock;\r\nstruct atalk_iface *atif;\r\nstruct sockaddr_at tosat;\r\nint origlen;\r\n__u16 len_hops;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\r\ngoto out;\r\nif (!pskb_may_pull(skb, sizeof(*ddp)))\r\ngoto drop;\r\nddp = ddp_hdr(skb);\r\nlen_hops = ntohs(ddp->deh_len_hops);\r\noriglen = skb->len;\r\nskb_trim(skb, min_t(unsigned int, skb->len, len_hops & 1023));\r\nif (skb->len < sizeof(*ddp) || skb->len < (len_hops & 1023)) {\r\npr_debug("AppleTalk: dropping corrupted frame (deh_len=%u, "\r\n"skb->len=%u)\n", len_hops & 1023, skb->len);\r\ngoto drop;\r\n}\r\nif (ddp->deh_sum &&\r\natalk_checksum(skb, len_hops & 1023) != ddp->deh_sum)\r\ngoto drop;\r\nif (!ddp->deh_dnet)\r\natif = atalk_find_anynet(ddp->deh_dnode, dev);\r\nelse\r\natif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\r\nif (!atif) {\r\nreturn atalk_route_packet(skb, dev, ddp, len_hops, origlen);\r\n}\r\nif (is_ip_over_ddp(skb))\r\nreturn handle_ip_over_ddp(skb);\r\ntosat.sat_addr.s_net = ddp->deh_dnet;\r\ntosat.sat_addr.s_node = ddp->deh_dnode;\r\ntosat.sat_port = ddp->deh_dport;\r\nsock = atalk_search_socket(&tosat, atif);\r\nif (!sock)\r\ngoto drop;\r\nif (sock_queue_rcv_skb(sock, skb) < 0)\r\ngoto drop;\r\nreturn NET_RX_SUCCESS;\r\ndrop:\r\nkfree_skb(skb);\r\nout:\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto freeit;\r\nif (skb_mac_header(skb)[2] == 1) {\r\nstruct ddpehdr *ddp;\r\nstruct atalk_addr *ap = atalk_find_dev_addr(dev);\r\nif (!ap || skb->len < sizeof(__be16) || skb->len > 1023)\r\ngoto freeit;\r\nif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\r\nreturn 0;\r\nddp = (struct ddpehdr *) skb_push(skb, sizeof(*ddp) - 4);\r\nddp->deh_dnode = skb_mac_header(skb)[0];\r\nddp->deh_snode = skb_mac_header(skb)[1];\r\nddp->deh_dnet = ap->s_net;\r\nddp->deh_snet = ap->s_net;\r\nddp->deh_sum = 0;\r\nddp->deh_len_hops = htons(skb->len + (DDP_MAXHOPS << 10));\r\n}\r\nskb_reset_transport_header(skb);\r\nreturn atalk_rcv(skb, dev, pt, orig_dev);\r\nfreeit:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int atalk_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct atalk_sock *at = at_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_at *, usat, msg->msg_name);\r\nint flags = msg->msg_flags;\r\nint loopback = 0;\r\nstruct sockaddr_at local_satalk, gsat;\r\nstruct sk_buff *skb;\r\nstruct net_device *dev;\r\nstruct ddpehdr *ddp;\r\nint size;\r\nstruct atalk_route *rt;\r\nint err;\r\nif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\r\nreturn -EINVAL;\r\nif (len > DDP_MAXSZ)\r\nreturn -EMSGSIZE;\r\nlock_sock(sk);\r\nif (usat) {\r\nerr = -EBUSY;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\nif (atalk_autobind(sk) < 0)\r\ngoto out;\r\nerr = -EINVAL;\r\nif (msg->msg_namelen < sizeof(*usat) ||\r\nusat->sat_family != AF_APPLETALK)\r\ngoto out;\r\nerr = -EPERM;\r\nif (usat->sat_addr.s_node == ATADDR_BCAST &&\r\n!sock_flag(sk, SOCK_BROADCAST)) {\r\ngoto out;\r\n}\r\n} else {\r\nerr = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nusat = &local_satalk;\r\nusat->sat_family = AF_APPLETALK;\r\nusat->sat_port = at->dest_port;\r\nusat->sat_addr.s_node = at->dest_node;\r\nusat->sat_addr.s_net = at->dest_net;\r\n}\r\nSOCK_DEBUG(sk, "SK %p: Got address.\n", sk);\r\nsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\r\nif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\r\nrt = atrtr_find(&usat->sat_addr);\r\n} else {\r\nstruct atalk_addr at_hint;\r\nat_hint.s_node = 0;\r\nat_hint.s_net = at->src_net;\r\nrt = atrtr_find(&at_hint);\r\n}\r\nerr = -ENETUNREACH;\r\nif (!rt)\r\ngoto out;\r\ndev = rt->dev;\r\nSOCK_DEBUG(sk, "SK %p: Size needed %d, device %s\n",\r\nsk, size, dev->name);\r\nsize += dev->hard_header_len;\r\nrelease_sock(sk);\r\nskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\r\nlock_sock(sk);\r\nif (!skb)\r\ngoto out;\r\nskb_reserve(skb, ddp_dl->header_length);\r\nskb_reserve(skb, dev->hard_header_len);\r\nskb->dev = dev;\r\nSOCK_DEBUG(sk, "SK %p: Begin build.\n", sk);\r\nddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\r\nddp->deh_len_hops = htons(len + sizeof(*ddp));\r\nddp->deh_dnet = usat->sat_addr.s_net;\r\nddp->deh_snet = at->src_net;\r\nddp->deh_dnode = usat->sat_addr.s_node;\r\nddp->deh_snode = at->src_node;\r\nddp->deh_dport = usat->sat_port;\r\nddp->deh_sport = at->src_port;\r\nSOCK_DEBUG(sk, "SK %p: Copy user data (%Zd bytes).\n", sk, len);\r\nerr = memcpy_from_msg(skb_put(skb, len), msg, len);\r\nif (err) {\r\nkfree_skb(skb);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (sk->sk_no_check_tx)\r\nddp->deh_sum = 0;\r\nelse\r\nddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\r\nif (ddp->deh_dnode == ATADDR_BCAST &&\r\n!(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\r\nstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\r\nif (skb2) {\r\nloopback = 1;\r\nSOCK_DEBUG(sk, "SK %p: send out(copy).\n", sk);\r\naarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\r\n}\r\n}\r\nif (dev->flags & IFF_LOOPBACK || loopback) {\r\nSOCK_DEBUG(sk, "SK %p: Loop back.\n", sk);\r\nskb_orphan(skb);\r\nif (ddp->deh_dnode == ATADDR_BCAST) {\r\nstruct atalk_addr at_lo;\r\nat_lo.s_node = 0;\r\nat_lo.s_net = 0;\r\nrt = atrtr_find(&at_lo);\r\nif (!rt) {\r\nkfree_skb(skb);\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\ndev = rt->dev;\r\nskb->dev = dev;\r\n}\r\nddp_dl->request(ddp_dl, skb, dev->dev_addr);\r\n} else {\r\nSOCK_DEBUG(sk, "SK %p: send out.\n", sk);\r\nif (rt->flags & RTF_GATEWAY) {\r\ngsat.sat_addr = rt->gateway;\r\nusat = &gsat;\r\n}\r\naarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\r\n}\r\nSOCK_DEBUG(sk, "SK %p: Done write (%Zd).\n", sk, len);\r\nout:\r\nrelease_sock(sk);\r\nreturn err ? : len;\r\n}\r\nstatic int atalk_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct ddpehdr *ddp;\r\nint copied = 0;\r\nint offset = 0;\r\nint err = 0;\r\nstruct sk_buff *skb;\r\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\r\nflags & MSG_DONTWAIT, &err);\r\nlock_sock(sk);\r\nif (!skb)\r\ngoto out;\r\nddp = ddp_hdr(skb);\r\ncopied = ntohs(ddp->deh_len_hops) & 1023;\r\nif (sk->sk_type != SOCK_RAW) {\r\noffset = sizeof(*ddp);\r\ncopied -= offset;\r\n}\r\nif (copied > size) {\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nerr = skb_copy_datagram_msg(skb, offset, msg, copied);\r\nif (!err && msg->msg_name) {\r\nDECLARE_SOCKADDR(struct sockaddr_at *, sat, msg->msg_name);\r\nsat->sat_family = AF_APPLETALK;\r\nsat->sat_port = ddp->deh_sport;\r\nsat->sat_addr.s_node = ddp->deh_snode;\r\nsat->sat_addr.s_net = ddp->deh_snet;\r\nmsg->msg_namelen = sizeof(*sat);\r\n}\r\nskb_free_datagram(sk, skb);\r\nout:\r\nrelease_sock(sk);\r\nreturn err ? : copied;\r\n}\r\nstatic int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nint rc = -ENOIOCTLCMD;\r\nstruct sock *sk = sock->sk;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase TIOCOUTQ: {\r\nlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nrc = put_user(amount, (int __user *)argp);\r\nbreak;\r\n}\r\ncase TIOCINQ: {\r\nstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\r\nlong amount = 0;\r\nif (skb)\r\namount = skb->len - sizeof(struct ddpehdr);\r\nrc = put_user(amount, (int __user *)argp);\r\nbreak;\r\n}\r\ncase SIOCGSTAMP:\r\nrc = sock_get_timestamp(sk, argp);\r\nbreak;\r\ncase SIOCGSTAMPNS:\r\nrc = sock_get_timestampns(sk, argp);\r\nbreak;\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\nrc = -EPERM;\r\nif (capable(CAP_NET_ADMIN))\r\nrc = atrtr_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCATALKDIFADDR:\r\ncase SIOCDIFADDR:\r\ncase SIOCSARP:\r\ncase SIOCDARP:\r\nrtnl_lock();\r\nrc = atif_ioctl(cmd, argp);\r\nrtnl_unlock();\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int atalk_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nif (cmd == SIOCATALKDIFADDR)\r\nreturn atalk_ioctl(sock, cmd, (unsigned long)compat_ptr(arg));\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int __init atalk_init(void)\r\n{\r\nint rc = proto_register(&ddp_proto, 0);\r\nif (rc != 0)\r\ngoto out;\r\n(void)sock_register(&atalk_family_ops);\r\nddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\r\nif (!ddp_dl)\r\nprintk(atalk_err_snap);\r\ndev_add_pack(&ltalk_packet_type);\r\ndev_add_pack(&ppptalk_packet_type);\r\nregister_netdevice_notifier(&ddp_notifier);\r\naarp_proto_init();\r\natalk_proc_init();\r\natalk_register_sysctl();\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit atalk_exit(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\natalk_unregister_sysctl();\r\n#endif\r\natalk_proc_exit();\r\naarp_cleanup_module();\r\nunregister_netdevice_notifier(&ddp_notifier);\r\ndev_remove_pack(&ltalk_packet_type);\r\ndev_remove_pack(&ppptalk_packet_type);\r\nunregister_snap_client(ddp_dl);\r\nsock_unregister(PF_APPLETALK);\r\nproto_unregister(&ddp_proto);\r\n}
