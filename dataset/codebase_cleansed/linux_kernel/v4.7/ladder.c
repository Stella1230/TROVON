static inline void ladder_do_selection(struct ladder_device *ldev,\r\nint old_idx, int new_idx)\r\n{\r\nldev->states[old_idx].stats.promotion_count = 0;\r\nldev->states[old_idx].stats.demotion_count = 0;\r\nldev->last_state_idx = new_idx;\r\n}\r\nstatic int ladder_select_state(struct cpuidle_driver *drv,\r\nstruct cpuidle_device *dev)\r\n{\r\nstruct ladder_device *ldev = this_cpu_ptr(&ladder_devices);\r\nstruct ladder_device_state *last_state;\r\nint last_residency, last_idx = ldev->last_state_idx;\r\nint latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);\r\nif (unlikely(latency_req == 0)) {\r\nladder_do_selection(ldev, last_idx, 0);\r\nreturn 0;\r\n}\r\nlast_state = &ldev->states[last_idx];\r\nlast_residency = cpuidle_get_last_residency(dev) - drv->states[last_idx].exit_latency;\r\nif (last_idx < drv->state_count - 1 &&\r\n!drv->states[last_idx + 1].disabled &&\r\n!dev->states_usage[last_idx + 1].disable &&\r\nlast_residency > last_state->threshold.promotion_time &&\r\ndrv->states[last_idx + 1].exit_latency <= latency_req) {\r\nlast_state->stats.promotion_count++;\r\nlast_state->stats.demotion_count = 0;\r\nif (last_state->stats.promotion_count >= last_state->threshold.promotion_count) {\r\nladder_do_selection(ldev, last_idx, last_idx + 1);\r\nreturn last_idx + 1;\r\n}\r\n}\r\nif (last_idx > CPUIDLE_DRIVER_STATE_START &&\r\n(drv->states[last_idx].disabled ||\r\ndev->states_usage[last_idx].disable ||\r\ndrv->states[last_idx].exit_latency > latency_req)) {\r\nint i;\r\nfor (i = last_idx - 1; i > CPUIDLE_DRIVER_STATE_START; i--) {\r\nif (drv->states[i].exit_latency <= latency_req)\r\nbreak;\r\n}\r\nladder_do_selection(ldev, last_idx, i);\r\nreturn i;\r\n}\r\nif (last_idx > CPUIDLE_DRIVER_STATE_START &&\r\nlast_residency < last_state->threshold.demotion_time) {\r\nlast_state->stats.demotion_count++;\r\nlast_state->stats.promotion_count = 0;\r\nif (last_state->stats.demotion_count >= last_state->threshold.demotion_count) {\r\nladder_do_selection(ldev, last_idx, last_idx - 1);\r\nreturn last_idx - 1;\r\n}\r\n}\r\nreturn last_idx;\r\n}\r\nstatic int ladder_enable_device(struct cpuidle_driver *drv,\r\nstruct cpuidle_device *dev)\r\n{\r\nint i;\r\nstruct ladder_device *ldev = &per_cpu(ladder_devices, dev->cpu);\r\nstruct ladder_device_state *lstate;\r\nstruct cpuidle_state *state;\r\nldev->last_state_idx = CPUIDLE_DRIVER_STATE_START;\r\nfor (i = CPUIDLE_DRIVER_STATE_START; i < drv->state_count; i++) {\r\nstate = &drv->states[i];\r\nlstate = &ldev->states[i];\r\nlstate->stats.promotion_count = 0;\r\nlstate->stats.demotion_count = 0;\r\nlstate->threshold.promotion_count = PROMOTION_COUNT;\r\nlstate->threshold.demotion_count = DEMOTION_COUNT;\r\nif (i < drv->state_count - 1)\r\nlstate->threshold.promotion_time = state->exit_latency;\r\nif (i > CPUIDLE_DRIVER_STATE_START)\r\nlstate->threshold.demotion_time = state->exit_latency;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ladder_reflect(struct cpuidle_device *dev, int index)\r\n{\r\nstruct ladder_device *ldev = this_cpu_ptr(&ladder_devices);\r\nif (index > 0)\r\nldev->last_state_idx = index;\r\n}\r\nstatic int __init init_ladder(void)\r\n{\r\nif (!tick_nohz_enabled)\r\nladder_governor.rating = 25;\r\nreturn cpuidle_register_governor(&ladder_governor);\r\n}
