static int rng_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct rng_ctx *ctx = ask->private;\r\nint err = -EFAULT;\r\nint genlen = 0;\r\nu8 result[MAXSIZE];\r\nif (len == 0)\r\nreturn 0;\r\nif (len > MAXSIZE)\r\nlen = MAXSIZE;\r\nmemset(result, 0, len);\r\ngenlen = crypto_rng_get_bytes(ctx->drng, result, len);\r\nif (genlen < 0)\r\nreturn genlen;\r\nerr = memcpy_to_msg(msg, result, len);\r\nmemzero_explicit(result, len);\r\nreturn err ? err : len;\r\n}\r\nstatic void *rng_bind(const char *name, u32 type, u32 mask)\r\n{\r\nreturn crypto_alloc_rng(name, type, mask);\r\n}\r\nstatic void rng_release(void *private)\r\n{\r\ncrypto_free_rng(private);\r\n}\r\nstatic void rng_sock_destruct(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct rng_ctx *ctx = ask->private;\r\nsock_kfree_s(sk, ctx, ctx->len);\r\naf_alg_release_parent(sk);\r\n}\r\nstatic int rng_accept_parent(void *private, struct sock *sk)\r\n{\r\nstruct rng_ctx *ctx;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nunsigned int len = sizeof(*ctx);\r\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->len = len;\r\nctx->drng = private;\r\nask->private = ctx;\r\nsk->sk_destruct = rng_sock_destruct;\r\nreturn 0;\r\n}\r\nstatic int rng_setkey(void *private, const u8 *seed, unsigned int seedlen)\r\n{\r\nreturn crypto_rng_reset(private, seed, seedlen);\r\n}\r\nstatic int __init rng_init(void)\r\n{\r\nreturn af_alg_register_type(&algif_type_rng);\r\n}\r\nstatic void __exit rng_exit(void)\r\n{\r\nint err = af_alg_unregister_type(&algif_type_rng);\r\nBUG_ON(err);\r\n}
