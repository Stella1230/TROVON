int lm3533_read(struct lm3533 *lm3533, u8 reg, u8 *val)\r\n{\r\nint tmp;\r\nint ret;\r\nret = regmap_read(lm3533->regmap, reg, &tmp);\r\nif (ret < 0) {\r\ndev_err(lm3533->dev, "failed to read register %02x: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\n*val = tmp;\r\ndev_dbg(lm3533->dev, "read [%02x]: %02x\n", reg, *val);\r\nreturn ret;\r\n}\r\nint lm3533_write(struct lm3533 *lm3533, u8 reg, u8 val)\r\n{\r\nint ret;\r\ndev_dbg(lm3533->dev, "write [%02x]: %02x\n", reg, val);\r\nret = regmap_write(lm3533->regmap, reg, val);\r\nif (ret < 0) {\r\ndev_err(lm3533->dev, "failed to write register %02x: %d\n",\r\nreg, ret);\r\n}\r\nreturn ret;\r\n}\r\nint lm3533_update(struct lm3533 *lm3533, u8 reg, u8 val, u8 mask)\r\n{\r\nint ret;\r\ndev_dbg(lm3533->dev, "update [%02x]: %02x/%02x\n", reg, val, mask);\r\nret = regmap_update_bits(lm3533->regmap, reg, mask, val);\r\nif (ret < 0) {\r\ndev_err(lm3533->dev, "failed to update register %02x: %d\n",\r\nreg, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int lm3533_set_boost_freq(struct lm3533 *lm3533,\r\nenum lm3533_boost_freq freq)\r\n{\r\nint ret;\r\nret = lm3533_update(lm3533, LM3533_REG_BOOST_PWM,\r\nfreq << LM3533_BOOST_FREQ_SHIFT,\r\nLM3533_BOOST_FREQ_MASK);\r\nif (ret)\r\ndev_err(lm3533->dev, "failed to set boost frequency\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_set_boost_ovp(struct lm3533 *lm3533,\r\nenum lm3533_boost_ovp ovp)\r\n{\r\nint ret;\r\nret = lm3533_update(lm3533, LM3533_REG_BOOST_PWM,\r\novp << LM3533_BOOST_OVP_SHIFT,\r\nLM3533_BOOST_OVP_MASK);\r\nif (ret)\r\ndev_err(lm3533->dev, "failed to set boost ovp\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_set_hvled_config(struct lm3533 *lm3533, u8 hvled, u8 bl)\r\n{\r\nu8 val;\r\nu8 mask;\r\nint shift;\r\nint ret;\r\nif (hvled == 0 || hvled > LM3533_HVLED_ID_MAX)\r\nreturn -EINVAL;\r\nif (bl > LM3533_BL_ID_MAX)\r\nreturn -EINVAL;\r\nshift = hvled - 1;\r\nmask = LM3533_BL_ID_MASK << shift;\r\nval = bl << shift;\r\nret = lm3533_update(lm3533, LM3533_REG_OUTPUT_CONF1, val, mask);\r\nif (ret)\r\ndev_err(lm3533->dev, "failed to set hvled config\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_set_lvled_config(struct lm3533 *lm3533, u8 lvled, u8 led)\r\n{\r\nu8 reg;\r\nu8 val;\r\nu8 mask;\r\nint shift;\r\nint ret;\r\nif (lvled == 0 || lvled > LM3533_LVLED_ID_MAX)\r\nreturn -EINVAL;\r\nif (led > LM3533_LED_ID_MAX)\r\nreturn -EINVAL;\r\nif (lvled < 4) {\r\nreg = LM3533_REG_OUTPUT_CONF1;\r\nshift = 2 * lvled;\r\n} else {\r\nreg = LM3533_REG_OUTPUT_CONF2;\r\nshift = 2 * (lvled - 4);\r\n}\r\nmask = LM3533_LED_ID_MASK << shift;\r\nval = led << shift;\r\nret = lm3533_update(lm3533, reg, val, mask);\r\nif (ret)\r\ndev_err(lm3533->dev, "failed to set lvled config\n");\r\nreturn ret;\r\n}\r\nstatic void lm3533_enable(struct lm3533 *lm3533)\r\n{\r\nif (gpio_is_valid(lm3533->gpio_hwen))\r\ngpio_set_value(lm3533->gpio_hwen, 1);\r\n}\r\nstatic void lm3533_disable(struct lm3533 *lm3533)\r\n{\r\nif (gpio_is_valid(lm3533->gpio_hwen))\r\ngpio_set_value(lm3533->gpio_hwen, 0);\r\n}\r\nstatic ssize_t show_output(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm3533 *lm3533 = dev_get_drvdata(dev);\r\nstruct lm3533_device_attribute *lattr = to_lm3533_dev_attr(attr);\r\nint id = lattr->u.output.id;\r\nu8 reg;\r\nu8 val;\r\nu8 mask;\r\nint shift;\r\nint ret;\r\nif (lattr->type == LM3533_ATTR_TYPE_BACKLIGHT) {\r\nreg = LM3533_REG_OUTPUT_CONF1;\r\nshift = id - 1;\r\nmask = LM3533_BL_ID_MASK << shift;\r\n} else {\r\nif (id < 4) {\r\nreg = LM3533_REG_OUTPUT_CONF1;\r\nshift = 2 * id;\r\n} else {\r\nreg = LM3533_REG_OUTPUT_CONF2;\r\nshift = 2 * (id - 4);\r\n}\r\nmask = LM3533_LED_ID_MASK << shift;\r\n}\r\nret = lm3533_read(lm3533, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nval = (val & mask) >> shift;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", val);\r\n}\r\nstatic ssize_t store_output(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lm3533 *lm3533 = dev_get_drvdata(dev);\r\nstruct lm3533_device_attribute *lattr = to_lm3533_dev_attr(attr);\r\nint id = lattr->u.output.id;\r\nu8 val;\r\nint ret;\r\nif (kstrtou8(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (lattr->type == LM3533_ATTR_TYPE_BACKLIGHT)\r\nret = lm3533_set_hvled_config(lm3533, id, val);\r\nelse\r\nret = lm3533_set_lvled_config(lm3533, id, val);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic umode_t lm3533_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct lm3533 *lm3533 = dev_get_drvdata(dev);\r\nstruct device_attribute *dattr = to_dev_attr(attr);\r\nstruct lm3533_device_attribute *lattr = to_lm3533_dev_attr(dattr);\r\nenum lm3533_attribute_type type = lattr->type;\r\numode_t mode = attr->mode;\r\nif (!lm3533->have_backlights && type == LM3533_ATTR_TYPE_BACKLIGHT)\r\nmode = 0;\r\nelse if (!lm3533->have_leds && type == LM3533_ATTR_TYPE_LED)\r\nmode = 0;\r\nreturn mode;\r\n}\r\nstatic int lm3533_device_als_init(struct lm3533 *lm3533)\r\n{\r\nstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\r\nint ret;\r\nif (!pdata->als)\r\nreturn 0;\r\nlm3533_als_devs[0].platform_data = pdata->als;\r\nlm3533_als_devs[0].pdata_size = sizeof(*pdata->als);\r\nret = mfd_add_devices(lm3533->dev, 0, lm3533_als_devs, 1, NULL,\r\n0, NULL);\r\nif (ret) {\r\ndev_err(lm3533->dev, "failed to add ALS device\n");\r\nreturn ret;\r\n}\r\nlm3533->have_als = 1;\r\nreturn 0;\r\n}\r\nstatic int lm3533_device_bl_init(struct lm3533 *lm3533)\r\n{\r\nstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\r\nint i;\r\nint ret;\r\nif (!pdata->backlights || pdata->num_backlights == 0)\r\nreturn 0;\r\nif (pdata->num_backlights > ARRAY_SIZE(lm3533_bl_devs))\r\npdata->num_backlights = ARRAY_SIZE(lm3533_bl_devs);\r\nfor (i = 0; i < pdata->num_backlights; ++i) {\r\nlm3533_bl_devs[i].platform_data = &pdata->backlights[i];\r\nlm3533_bl_devs[i].pdata_size = sizeof(pdata->backlights[i]);\r\n}\r\nret = mfd_add_devices(lm3533->dev, 0, lm3533_bl_devs,\r\npdata->num_backlights, NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(lm3533->dev, "failed to add backlight devices\n");\r\nreturn ret;\r\n}\r\nlm3533->have_backlights = 1;\r\nreturn 0;\r\n}\r\nstatic int lm3533_device_led_init(struct lm3533 *lm3533)\r\n{\r\nstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\r\nint i;\r\nint ret;\r\nif (!pdata->leds || pdata->num_leds == 0)\r\nreturn 0;\r\nif (pdata->num_leds > ARRAY_SIZE(lm3533_led_devs))\r\npdata->num_leds = ARRAY_SIZE(lm3533_led_devs);\r\nfor (i = 0; i < pdata->num_leds; ++i) {\r\nlm3533_led_devs[i].platform_data = &pdata->leds[i];\r\nlm3533_led_devs[i].pdata_size = sizeof(pdata->leds[i]);\r\n}\r\nret = mfd_add_devices(lm3533->dev, 0, lm3533_led_devs,\r\npdata->num_leds, NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(lm3533->dev, "failed to add LED devices\n");\r\nreturn ret;\r\n}\r\nlm3533->have_leds = 1;\r\nreturn 0;\r\n}\r\nstatic int lm3533_device_setup(struct lm3533 *lm3533,\r\nstruct lm3533_platform_data *pdata)\r\n{\r\nint ret;\r\nret = lm3533_set_boost_freq(lm3533, pdata->boost_freq);\r\nif (ret)\r\nreturn ret;\r\nreturn lm3533_set_boost_ovp(lm3533, pdata->boost_ovp);\r\n}\r\nstatic int lm3533_device_init(struct lm3533 *lm3533)\r\n{\r\nstruct lm3533_platform_data *pdata = dev_get_platdata(lm3533->dev);\r\nint ret;\r\ndev_dbg(lm3533->dev, "%s\n", __func__);\r\nif (!pdata) {\r\ndev_err(lm3533->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nlm3533->gpio_hwen = pdata->gpio_hwen;\r\ndev_set_drvdata(lm3533->dev, lm3533);\r\nif (gpio_is_valid(lm3533->gpio_hwen)) {\r\nret = devm_gpio_request_one(lm3533->dev, lm3533->gpio_hwen,\r\nGPIOF_OUT_INIT_LOW, "lm3533-hwen");\r\nif (ret < 0) {\r\ndev_err(lm3533->dev,\r\n"failed to request HWEN GPIO %d\n",\r\nlm3533->gpio_hwen);\r\nreturn ret;\r\n}\r\n}\r\nlm3533_enable(lm3533);\r\nret = lm3533_device_setup(lm3533, pdata);\r\nif (ret)\r\ngoto err_disable;\r\nlm3533_device_als_init(lm3533);\r\nlm3533_device_bl_init(lm3533);\r\nlm3533_device_led_init(lm3533);\r\nret = sysfs_create_group(&lm3533->dev->kobj, &lm3533_attribute_group);\r\nif (ret < 0) {\r\ndev_err(lm3533->dev, "failed to create sysfs attributes\n");\r\ngoto err_unregister;\r\n}\r\nreturn 0;\r\nerr_unregister:\r\nmfd_remove_devices(lm3533->dev);\r\nerr_disable:\r\nlm3533_disable(lm3533);\r\nreturn ret;\r\n}\r\nstatic void lm3533_device_exit(struct lm3533 *lm3533)\r\n{\r\ndev_dbg(lm3533->dev, "%s\n", __func__);\r\nsysfs_remove_group(&lm3533->dev->kobj, &lm3533_attribute_group);\r\nmfd_remove_devices(lm3533->dev);\r\nlm3533_disable(lm3533);\r\n}\r\nstatic bool lm3533_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0x10 ... 0x2c:\r\ncase 0x30 ... 0x38:\r\ncase 0x40 ... 0x45:\r\ncase 0x50 ... 0x57:\r\ncase 0x60 ... 0x6e:\r\ncase 0x70 ... 0x75:\r\ncase 0x80 ... 0x85:\r\ncase 0x90 ... 0x95:\r\ncase 0xa0 ... 0xa5:\r\ncase 0xb0 ... 0xb2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool lm3533_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0x34 ... 0x36:\r\ncase 0x37 ... 0x38:\r\ncase 0xb0 ... 0xb1:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool lm3533_precious_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0x34:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int lm3533_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm3533 *lm3533;\r\ndev_dbg(&i2c->dev, "%s\n", __func__);\r\nlm3533 = devm_kzalloc(&i2c->dev, sizeof(*lm3533), GFP_KERNEL);\r\nif (!lm3533)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, lm3533);\r\nlm3533->regmap = devm_regmap_init_i2c(i2c, &regmap_config);\r\nif (IS_ERR(lm3533->regmap))\r\nreturn PTR_ERR(lm3533->regmap);\r\nlm3533->dev = &i2c->dev;\r\nlm3533->irq = i2c->irq;\r\nreturn lm3533_device_init(lm3533);\r\n}\r\nstatic int lm3533_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct lm3533 *lm3533 = i2c_get_clientdata(i2c);\r\ndev_dbg(&i2c->dev, "%s\n", __func__);\r\nlm3533_device_exit(lm3533);\r\nreturn 0;\r\n}\r\nstatic int __init lm3533_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&lm3533_i2c_driver);\r\n}\r\nstatic void __exit lm3533_i2c_exit(void)\r\n{\r\ni2c_del_driver(&lm3533_i2c_driver);\r\n}
