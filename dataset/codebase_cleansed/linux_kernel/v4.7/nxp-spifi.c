static int nxp_spifi_wait_for_cmd(struct nxp_spifi *spifi)\r\n{\r\nu8 stat;\r\nint ret;\r\nret = readb_poll_timeout(spifi->io_base + SPIFI_STAT, stat,\r\n!(stat & SPIFI_STAT_CMD), 10, 30);\r\nif (ret)\r\ndev_warn(spifi->dev, "command timed out\n");\r\nreturn ret;\r\n}\r\nstatic int nxp_spifi_reset(struct nxp_spifi *spifi)\r\n{\r\nu8 stat;\r\nint ret;\r\nwritel(SPIFI_STAT_RESET, spifi->io_base + SPIFI_STAT);\r\nret = readb_poll_timeout(spifi->io_base + SPIFI_STAT, stat,\r\n!(stat & SPIFI_STAT_RESET), 10, 30);\r\nif (ret)\r\ndev_warn(spifi->dev, "state reset timed out\n");\r\nreturn ret;\r\n}\r\nstatic int nxp_spifi_set_memory_mode_off(struct nxp_spifi *spifi)\r\n{\r\nint ret;\r\nif (!spifi->memory_mode)\r\nreturn 0;\r\nret = nxp_spifi_reset(spifi);\r\nif (ret)\r\ndev_err(spifi->dev, "unable to enter command mode\n");\r\nelse\r\nspifi->memory_mode = false;\r\nreturn ret;\r\n}\r\nstatic int nxp_spifi_set_memory_mode_on(struct nxp_spifi *spifi)\r\n{\r\nu8 stat;\r\nint ret;\r\nif (spifi->memory_mode)\r\nreturn 0;\r\nwritel(spifi->mcmd, spifi->io_base + SPIFI_MCMD);\r\nret = readb_poll_timeout(spifi->io_base + SPIFI_STAT, stat,\r\nstat & SPIFI_STAT_MCINIT, 10, 30);\r\nif (ret)\r\ndev_err(spifi->dev, "unable to enter memory mode\n");\r\nelse\r\nspifi->memory_mode = true;\r\nreturn ret;\r\n}\r\nstatic int nxp_spifi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nstruct nxp_spifi *spifi = nor->priv;\r\nu32 cmd;\r\nint ret;\r\nret = nxp_spifi_set_memory_mode_off(spifi);\r\nif (ret)\r\nreturn ret;\r\ncmd = SPIFI_CMD_DATALEN(len) |\r\nSPIFI_CMD_OPCODE(opcode) |\r\nSPIFI_CMD_FIELDFORM_ALL_SERIAL |\r\nSPIFI_CMD_FRAMEFORM_OPCODE_ONLY;\r\nwritel(cmd, spifi->io_base + SPIFI_CMD);\r\nwhile (len--)\r\n*buf++ = readb(spifi->io_base + SPIFI_DATA);\r\nreturn nxp_spifi_wait_for_cmd(spifi);\r\n}\r\nstatic int nxp_spifi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nstruct nxp_spifi *spifi = nor->priv;\r\nu32 cmd;\r\nint ret;\r\nret = nxp_spifi_set_memory_mode_off(spifi);\r\nif (ret)\r\nreturn ret;\r\ncmd = SPIFI_CMD_DOUT |\r\nSPIFI_CMD_DATALEN(len) |\r\nSPIFI_CMD_OPCODE(opcode) |\r\nSPIFI_CMD_FIELDFORM_ALL_SERIAL |\r\nSPIFI_CMD_FRAMEFORM_OPCODE_ONLY;\r\nwritel(cmd, spifi->io_base + SPIFI_CMD);\r\nwhile (len--)\r\nwriteb(*buf++, spifi->io_base + SPIFI_DATA);\r\nreturn nxp_spifi_wait_for_cmd(spifi);\r\n}\r\nstatic int nxp_spifi_read(struct spi_nor *nor, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct nxp_spifi *spifi = nor->priv;\r\nint ret;\r\nret = nxp_spifi_set_memory_mode_on(spifi);\r\nif (ret)\r\nreturn ret;\r\nmemcpy_fromio(buf, spifi->flash_base + from, len);\r\n*retlen += len;\r\nreturn 0;\r\n}\r\nstatic void nxp_spifi_write(struct spi_nor *nor, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct nxp_spifi *spifi = nor->priv;\r\nu32 cmd;\r\nint ret;\r\nret = nxp_spifi_set_memory_mode_off(spifi);\r\nif (ret)\r\nreturn;\r\nwritel(to, spifi->io_base + SPIFI_ADDR);\r\n*retlen += len;\r\ncmd = SPIFI_CMD_DOUT |\r\nSPIFI_CMD_DATALEN(len) |\r\nSPIFI_CMD_FIELDFORM_ALL_SERIAL |\r\nSPIFI_CMD_OPCODE(nor->program_opcode) |\r\nSPIFI_CMD_FRAMEFORM(spifi->nor.addr_width + 1);\r\nwritel(cmd, spifi->io_base + SPIFI_CMD);\r\nwhile (len--)\r\nwriteb(*buf++, spifi->io_base + SPIFI_DATA);\r\nnxp_spifi_wait_for_cmd(spifi);\r\n}\r\nstatic int nxp_spifi_erase(struct spi_nor *nor, loff_t offs)\r\n{\r\nstruct nxp_spifi *spifi = nor->priv;\r\nu32 cmd;\r\nint ret;\r\nret = nxp_spifi_set_memory_mode_off(spifi);\r\nif (ret)\r\nreturn ret;\r\nwritel(offs, spifi->io_base + SPIFI_ADDR);\r\ncmd = SPIFI_CMD_FIELDFORM_ALL_SERIAL |\r\nSPIFI_CMD_OPCODE(nor->erase_opcode) |\r\nSPIFI_CMD_FRAMEFORM(spifi->nor.addr_width + 1);\r\nwritel(cmd, spifi->io_base + SPIFI_CMD);\r\nreturn nxp_spifi_wait_for_cmd(spifi);\r\n}\r\nstatic int nxp_spifi_setup_memory_cmd(struct nxp_spifi *spifi)\r\n{\r\nswitch (spifi->nor.flash_read) {\r\ncase SPI_NOR_NORMAL:\r\ncase SPI_NOR_FAST:\r\nspifi->mcmd = SPIFI_CMD_FIELDFORM_ALL_SERIAL;\r\nbreak;\r\ncase SPI_NOR_DUAL:\r\ncase SPI_NOR_QUAD:\r\nspifi->mcmd = SPIFI_CMD_FIELDFORM_QUAD_DUAL_DATA;\r\nbreak;\r\ndefault:\r\ndev_err(spifi->dev, "unsupported SPI read mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (spifi->nor.addr_width < 1 || spifi->nor.addr_width > 4)\r\nreturn -EINVAL;\r\nspifi->mcmd |= SPIFI_CMD_OPCODE(spifi->nor.read_opcode) |\r\nSPIFI_CMD_INTLEN(spifi->nor.read_dummy / 8) |\r\nSPIFI_CMD_FRAMEFORM(spifi->nor.addr_width + 1);\r\nreturn 0;\r\n}\r\nstatic void nxp_spifi_dummy_id_read(struct spi_nor *nor)\r\n{\r\nu8 id[SPI_NOR_MAX_ID_LEN];\r\nnor->read_reg(nor, SPINOR_OP_RDID, id, SPI_NOR_MAX_ID_LEN);\r\n}\r\nstatic int nxp_spifi_setup_flash(struct nxp_spifi *spifi,\r\nstruct device_node *np)\r\n{\r\nenum read_mode flash_read;\r\nu32 ctrl, property;\r\nu16 mode = 0;\r\nint ret;\r\nif (!of_property_read_u32(np, "spi-rx-bus-width", &property)) {\r\nswitch (property) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nmode |= SPI_RX_DUAL;\r\nbreak;\r\ncase 4:\r\nmode |= SPI_RX_QUAD;\r\nbreak;\r\ndefault:\r\ndev_err(spifi->dev, "unsupported rx-bus-width\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (of_find_property(np, "spi-cpha", NULL))\r\nmode |= SPI_CPHA;\r\nif (of_find_property(np, "spi-cpol", NULL))\r\nmode |= SPI_CPOL;\r\nctrl = SPIFI_CTRL_TIMEOUT(1000) |\r\nSPIFI_CTRL_CSHIGH(15) |\r\nSPIFI_CTRL_FBCLK;\r\nif (mode & SPI_RX_DUAL) {\r\nctrl |= SPIFI_CTRL_DUAL;\r\nflash_read = SPI_NOR_DUAL;\r\n} else if (mode & SPI_RX_QUAD) {\r\nctrl &= ~SPIFI_CTRL_DUAL;\r\nflash_read = SPI_NOR_QUAD;\r\n} else {\r\nctrl |= SPIFI_CTRL_DUAL;\r\nflash_read = SPI_NOR_NORMAL;\r\n}\r\nswitch (mode & (SPI_CPHA | SPI_CPOL)) {\r\ncase SPI_MODE_0:\r\nctrl &= ~SPIFI_CTRL_MODE3;\r\nbreak;\r\ncase SPI_MODE_3:\r\nctrl |= SPIFI_CTRL_MODE3;\r\nbreak;\r\ndefault:\r\ndev_err(spifi->dev, "only mode 0 and 3 supported\n");\r\nreturn -EINVAL;\r\n}\r\nwritel(ctrl, spifi->io_base + SPIFI_CTRL);\r\nspifi->nor.dev = spifi->dev;\r\nspi_nor_set_flash_node(&spifi->nor, np);\r\nspifi->nor.priv = spifi;\r\nspifi->nor.read = nxp_spifi_read;\r\nspifi->nor.write = nxp_spifi_write;\r\nspifi->nor.erase = nxp_spifi_erase;\r\nspifi->nor.read_reg = nxp_spifi_read_reg;\r\nspifi->nor.write_reg = nxp_spifi_write_reg;\r\nnxp_spifi_dummy_id_read(&spifi->nor);\r\nret = spi_nor_scan(&spifi->nor, NULL, flash_read);\r\nif (ret) {\r\ndev_err(spifi->dev, "device scan failed\n");\r\nreturn ret;\r\n}\r\nret = nxp_spifi_setup_memory_cmd(spifi);\r\nif (ret) {\r\ndev_err(spifi->dev, "memory command setup failed\n");\r\nreturn ret;\r\n}\r\nret = mtd_device_register(&spifi->nor.mtd, NULL, 0);\r\nif (ret) {\r\ndev_err(spifi->dev, "mtd device parse failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nxp_spifi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *flash_np;\r\nstruct nxp_spifi *spifi;\r\nstruct resource *res;\r\nint ret;\r\nspifi = devm_kzalloc(&pdev->dev, sizeof(*spifi), GFP_KERNEL);\r\nif (!spifi)\r\nreturn -ENOMEM;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "spifi");\r\nspifi->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(spifi->io_base))\r\nreturn PTR_ERR(spifi->io_base);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "flash");\r\nspifi->flash_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(spifi->flash_base))\r\nreturn PTR_ERR(spifi->flash_base);\r\nspifi->clk_spifi = devm_clk_get(&pdev->dev, "spifi");\r\nif (IS_ERR(spifi->clk_spifi)) {\r\ndev_err(&pdev->dev, "spifi clock not found\n");\r\nreturn PTR_ERR(spifi->clk_spifi);\r\n}\r\nspifi->clk_reg = devm_clk_get(&pdev->dev, "reg");\r\nif (IS_ERR(spifi->clk_reg)) {\r\ndev_err(&pdev->dev, "reg clock not found\n");\r\nreturn PTR_ERR(spifi->clk_reg);\r\n}\r\nret = clk_prepare_enable(spifi->clk_reg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable reg clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(spifi->clk_spifi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable spifi clock\n");\r\ngoto dis_clk_reg;\r\n}\r\nspifi->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, spifi);\r\nnxp_spifi_reset(spifi);\r\nwritel(0, spifi->io_base + SPIFI_IDATA);\r\nwritel(0, spifi->io_base + SPIFI_MCMD);\r\nnxp_spifi_reset(spifi);\r\nflash_np = of_get_next_available_child(pdev->dev.of_node, NULL);\r\nif (!flash_np) {\r\ndev_err(&pdev->dev, "no SPI flash device to configure\n");\r\nret = -ENODEV;\r\ngoto dis_clks;\r\n}\r\nret = nxp_spifi_setup_flash(spifi, flash_np);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to setup flash chip\n");\r\ngoto dis_clks;\r\n}\r\nreturn 0;\r\ndis_clks:\r\nclk_disable_unprepare(spifi->clk_spifi);\r\ndis_clk_reg:\r\nclk_disable_unprepare(spifi->clk_reg);\r\nreturn ret;\r\n}\r\nstatic int nxp_spifi_remove(struct platform_device *pdev)\r\n{\r\nstruct nxp_spifi *spifi = platform_get_drvdata(pdev);\r\nmtd_device_unregister(&spifi->nor.mtd);\r\nclk_disable_unprepare(spifi->clk_spifi);\r\nclk_disable_unprepare(spifi->clk_reg);\r\nreturn 0;\r\n}
