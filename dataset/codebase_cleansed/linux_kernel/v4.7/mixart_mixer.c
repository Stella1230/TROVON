static int mixart_update_analog_audio_level(struct snd_mixart* chip, int is_capture)\r\n{\r\nint i, err;\r\nstruct mixart_msg request;\r\nstruct mixart_io_level io_level;\r\nstruct mixart_return_uid resp;\r\nmemset(&io_level, 0, sizeof(io_level));\r\nio_level.channel = -1;\r\nfor(i=0; i<2; i++) {\r\nif(is_capture) {\r\nio_level.level[i].analog_level = mixart_analog_level[chip->analog_capture_volume[i]];\r\n} else {\r\nif(chip->analog_playback_active[i])\r\nio_level.level[i].analog_level = mixart_analog_level[chip->analog_playback_volume[i]];\r\nelse\r\nio_level.level[i].analog_level = mixart_analog_level[MIXART_ANALOG_PLAYBACK_LEVEL_MIN];\r\n}\r\n}\r\nif(is_capture) request.uid = chip->uid_in_analog_physio;\r\nelse request.uid = chip->uid_out_analog_physio;\r\nrequest.message_id = MSG_PHYSICALIO_SET_LEVEL;\r\nrequest.data = &io_level;\r\nrequest.size = sizeof(io_level);\r\nerr = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);\r\nif((err<0) || (resp.error_code)) {\r\ndev_dbg(chip->card->dev,\r\n"error MSG_PHYSICALIO_SET_LEVEL card(%d) is_capture(%d) error_code(%x)\n",\r\nchip->chip_idx, is_capture, resp.error_code);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_analog_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nif(kcontrol->private_value == 0) {\r\nuinfo->value.integer.min = MIXART_ANALOG_PLAYBACK_LEVEL_MIN;\r\nuinfo->value.integer.max = MIXART_ANALOG_PLAYBACK_LEVEL_MAX;\r\n} else {\r\nuinfo->value.integer.min = MIXART_ANALOG_CAPTURE_LEVEL_MIN;\r\nuinfo->value.integer.max = MIXART_ANALOG_CAPTURE_LEVEL_MAX;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_analog_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif(kcontrol->private_value == 0) {\r\nucontrol->value.integer.value[0] = chip->analog_playback_volume[0];\r\nucontrol->value.integer.value[1] = chip->analog_playback_volume[1];\r\n} else {\r\nucontrol->value.integer.value[0] = chip->analog_capture_volume[0];\r\nucontrol->value.integer.value[1] = chip->analog_capture_volume[1];\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixart_analog_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint is_capture, i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nis_capture = (kcontrol->private_value != 0);\r\nfor (i = 0; i < 2; i++) {\r\nint new_volume = ucontrol->value.integer.value[i];\r\nint *stored_volume = is_capture ?\r\n&chip->analog_capture_volume[i] :\r\n&chip->analog_playback_volume[i];\r\nif (is_capture) {\r\nif (new_volume < MIXART_ANALOG_CAPTURE_LEVEL_MIN ||\r\nnew_volume > MIXART_ANALOG_CAPTURE_LEVEL_MAX)\r\ncontinue;\r\n} else {\r\nif (new_volume < MIXART_ANALOG_PLAYBACK_LEVEL_MIN ||\r\nnew_volume > MIXART_ANALOG_PLAYBACK_LEVEL_MAX)\r\ncontinue;\r\n}\r\nif (*stored_volume != new_volume) {\r\n*stored_volume = new_volume;\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\nmixart_update_analog_audio_level(chip, is_capture);\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int mixart_audio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->analog_playback_active[0];\r\nucontrol->value.integer.value[1] = chip->analog_playback_active[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixart_audio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint i, changed = 0;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->analog_playback_active[i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->analog_playback_active[i] =\r\n!!ucontrol->value.integer.value[i];\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\nmixart_update_analog_audio_level(chip, 0);\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nint mixart_update_playback_stream_level(struct snd_mixart* chip, int is_aes, int idx)\r\n{\r\nint err, i;\r\nint volume[2];\r\nstruct mixart_msg request;\r\nstruct mixart_set_out_stream_level_req set_level;\r\nu32 status = 0;\r\nstruct mixart_pipe *pipe;\r\nmemset(&set_level, 0, sizeof(set_level));\r\nset_level.nb_of_stream = 1;\r\nset_level.stream_level.desc.stream_idx = idx;\r\nif(is_aes) {\r\npipe = &chip->pipe_out_dig;\r\nidx += MIXART_PLAYBACK_STREAMS;\r\n} else {\r\npipe = &chip->pipe_out_ana;\r\n}\r\nif(pipe->status == PIPE_UNDEFINED)\r\nreturn 0;\r\nset_level.stream_level.desc.uid_pipe = pipe->group_uid;\r\nfor(i=0; i<2; i++) {\r\nif(chip->digital_playback_active[idx][i])\r\nvolume[i] = chip->digital_playback_volume[idx][i];\r\nelse\r\nvolume[i] = MIXART_DIGITAL_LEVEL_MIN;\r\n}\r\nset_level.stream_level.out_level.valid_mask1 = MIXART_OUT_STREAM_SET_LEVEL_LEFT_AUDIO1 | MIXART_OUT_STREAM_SET_LEVEL_RIGHT_AUDIO2;\r\nset_level.stream_level.out_level.left_to_out1_level = mixart_digital_level[volume[0]];\r\nset_level.stream_level.out_level.right_to_out2_level = mixart_digital_level[volume[1]];\r\nrequest.message_id = MSG_STREAM_SET_OUT_STREAM_LEVEL;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &set_level;\r\nrequest.size = sizeof(set_level);\r\nerr = snd_mixart_send_msg(chip->mgr, &request, sizeof(status), &status);\r\nif((err<0) || status) {\r\ndev_dbg(chip->card->dev,\r\n"error MSG_STREAM_SET_OUT_STREAM_LEVEL card(%d) status(%x)\n",\r\nchip->chip_idx, status);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint mixart_update_capture_stream_level(struct snd_mixart* chip, int is_aes)\r\n{\r\nint err, i, idx;\r\nstruct mixart_pipe *pipe;\r\nstruct mixart_msg request;\r\nstruct mixart_set_in_audio_level_req set_level;\r\nu32 status = 0;\r\nif(is_aes) {\r\nidx = 1;\r\npipe = &chip->pipe_in_dig;\r\n} else {\r\nidx = 0;\r\npipe = &chip->pipe_in_ana;\r\n}\r\nif(pipe->status == PIPE_UNDEFINED)\r\nreturn 0;\r\nmemset(&set_level, 0, sizeof(set_level));\r\nset_level.audio_count = 2;\r\nset_level.level[0].connector = pipe->uid_left_connector;\r\nset_level.level[1].connector = pipe->uid_right_connector;\r\nfor(i=0; i<2; i++) {\r\nset_level.level[i].valid_mask1 = MIXART_AUDIO_LEVEL_DIGITAL_MASK;\r\nset_level.level[i].digital_level = mixart_digital_level[chip->digital_capture_volume[idx][i]];\r\n}\r\nrequest.message_id = MSG_STREAM_SET_IN_AUDIO_LEVEL;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &set_level;\r\nrequest.size = sizeof(set_level);\r\nerr = snd_mixart_send_msg(chip->mgr, &request, sizeof(status), &status);\r\nif((err<0) || status) {\r\ndev_dbg(chip->card->dev,\r\n"error MSG_STREAM_SET_IN_AUDIO_LEVEL card(%d) status(%x)\n",\r\nchip->chip_idx, status);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_digital_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = MIXART_DIGITAL_LEVEL_MIN;\r\nuinfo->value.integer.max = MIXART_DIGITAL_LEVEL_MAX;\r\nreturn 0;\r\n}\r\nstatic int mixart_pcm_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint *stored_volume;\r\nint is_capture = kcontrol->private_value & MIXART_VOL_REC_MASK;\r\nint is_aes = kcontrol->private_value & MIXART_VOL_AES_MASK;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif(is_capture) {\r\nif(is_aes) stored_volume = chip->digital_capture_volume[1];\r\nelse stored_volume = chip->digital_capture_volume[0];\r\n} else {\r\nsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\r\nif(is_aes) stored_volume = chip->digital_playback_volume[MIXART_PLAYBACK_STREAMS + idx];\r\nelse stored_volume = chip->digital_playback_volume[idx];\r\n}\r\nucontrol->value.integer.value[0] = stored_volume[0];\r\nucontrol->value.integer.value[1] = stored_volume[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixart_pcm_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint changed = 0;\r\nint is_capture = kcontrol->private_value & MIXART_VOL_REC_MASK;\r\nint is_aes = kcontrol->private_value & MIXART_VOL_AES_MASK;\r\nint* stored_volume;\r\nint i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif (is_capture) {\r\nif (is_aes)\r\nstored_volume = chip->digital_capture_volume[1];\r\nelse\r\nstored_volume = chip->digital_capture_volume[0];\r\n} else {\r\nsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\r\nif (is_aes)\r\nstored_volume = chip->digital_playback_volume[MIXART_PLAYBACK_STREAMS + idx];\r\nelse\r\nstored_volume = chip->digital_playback_volume[idx];\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nint vol = ucontrol->value.integer.value[i];\r\nif (vol < MIXART_DIGITAL_LEVEL_MIN ||\r\nvol > MIXART_DIGITAL_LEVEL_MAX)\r\ncontinue;\r\nif (stored_volume[i] != vol) {\r\nstored_volume[i] = vol;\r\nchanged = 1;\r\n}\r\n}\r\nif (changed) {\r\nif (is_capture)\r\nmixart_update_capture_stream_level(chip, is_aes);\r\nelse\r\nmixart_update_playback_stream_level(chip, is_aes, idx);\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int mixart_pcm_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif(kcontrol->private_value & MIXART_VOL_AES_MASK)\r\nidx += MIXART_PLAYBACK_STREAMS;\r\nucontrol->value.integer.value[0] = chip->digital_playback_active[idx][0];\r\nucontrol->value.integer.value[1] = chip->digital_playback_active[idx][1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixart_pcm_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint is_aes = kcontrol->private_value & MIXART_VOL_AES_MASK;\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint i, j;\r\nsnd_BUG_ON(idx >= MIXART_PLAYBACK_STREAMS);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nj = idx;\r\nif (is_aes)\r\nj += MIXART_PLAYBACK_STREAMS;\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->digital_playback_active[j][i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->digital_playback_active[j][i] =\r\n!!ucontrol->value.integer.value[i];\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\nmixart_update_playback_stream_level(chip, is_aes, idx);\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int mixart_update_monitoring(struct snd_mixart* chip, int channel)\r\n{\r\nint err;\r\nstruct mixart_msg request;\r\nstruct mixart_set_out_audio_level audio_level;\r\nu32 resp;\r\nif(chip->pipe_out_ana.status == PIPE_UNDEFINED)\r\nreturn -EINVAL;\r\nif(!channel) request.uid = chip->pipe_out_ana.uid_left_connector;\r\nelse request.uid = chip->pipe_out_ana.uid_right_connector;\r\nrequest.message_id = MSG_CONNECTOR_SET_OUT_AUDIO_LEVEL;\r\nrequest.data = &audio_level;\r\nrequest.size = sizeof(audio_level);\r\nmemset(&audio_level, 0, sizeof(audio_level));\r\naudio_level.valid_mask1 = MIXART_AUDIO_LEVEL_MONITOR_MASK | MIXART_AUDIO_LEVEL_MUTE_M1_MASK;\r\naudio_level.monitor_level = mixart_digital_level[chip->monitoring_volume[channel!=0]];\r\naudio_level.monitor_mute1 = !chip->monitoring_active[channel!=0];\r\nerr = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);\r\nif((err<0) || resp) {\r\ndev_dbg(chip->card->dev,\r\n"error MSG_CONNECTOR_SET_OUT_AUDIO_LEVEL card(%d) resp(%x)\n",\r\nchip->chip_idx, resp);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_monitor_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->monitoring_volume[0];\r\nucontrol->value.integer.value[1] = chip->monitoring_volume[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixart_monitor_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->monitoring_volume[i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->monitoring_volume[i] =\r\n!!ucontrol->value.integer.value[i];\r\nmixart_update_monitoring(chip, i);\r\nchanged = 1;\r\n}\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int mixart_monitor_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->monitoring_active[0];\r\nucontrol->value.integer.value[1] = chip->monitoring_active[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixart_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_mixart *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->monitoring_active[i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->monitoring_active[i] =\r\n!!ucontrol->value.integer.value[i];\r\nchanged |= (1<<i);\r\n}\r\n}\r\nif (changed) {\r\nint allocate = chip->monitoring_active[0] ||\r\nchip->monitoring_active[1];\r\nif (allocate) {\r\nsnd_mixart_add_ref_pipe(chip, MIXART_PCM_ANALOG, 0, 1);\r\nsnd_mixart_add_ref_pipe(chip, MIXART_PCM_ANALOG, 1, 1);\r\n}\r\nif (changed & 0x01)\r\nmixart_update_monitoring(chip, 0);\r\nif (changed & 0x02)\r\nmixart_update_monitoring(chip, 1);\r\nif (!allocate) {\r\nsnd_mixart_kill_ref_pipe(chip->mgr,\r\n&chip->pipe_in_ana, 1);\r\nsnd_mixart_kill_ref_pipe(chip->mgr,\r\n&chip->pipe_out_ana, 1);\r\n}\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn (changed != 0);\r\n}\r\nstatic void mixart_reset_audio_levels(struct snd_mixart *chip)\r\n{\r\nmixart_update_analog_audio_level(chip, 0);\r\nif(chip->chip_idx < 2) {\r\nmixart_update_analog_audio_level(chip, 1);\r\n}\r\nreturn;\r\n}\r\nint snd_mixart_create_mixer(struct mixart_mgr *mgr)\r\n{\r\nstruct snd_mixart *chip;\r\nint err, i;\r\nmutex_init(&mgr->mixer_mutex);\r\nfor(i=0; i<mgr->num_cards; i++) {\r\nstruct snd_kcontrol_new temp;\r\nchip = mgr->chip[i];\r\ntemp = mixart_control_analog_level;\r\ntemp.name = "Master Playback Volume";\r\ntemp.private_value = 0;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_output_switch, chip))) < 0)\r\nreturn err;\r\nif(i<2) {\r\ntemp = mixart_control_analog_level;\r\ntemp.name = "Master Capture Volume";\r\ntemp.private_value = 1;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\ntemp = snd_mixart_pcm_vol;\r\ntemp.name = "PCM Playback Volume";\r\ntemp.count = MIXART_PLAYBACK_STREAMS;\r\ntemp.private_value = 0;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\ntemp.name = "PCM Capture Volume";\r\ntemp.count = 1;\r\ntemp.private_value = MIXART_VOL_REC_MASK;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\nif(mgr->board_type == MIXART_DAUGHTER_TYPE_AES) {\r\ntemp.name = "AES Playback Volume";\r\ntemp.count = MIXART_PLAYBACK_STREAMS;\r\ntemp.private_value = MIXART_VOL_AES_MASK;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\ntemp.name = "AES Capture Volume";\r\ntemp.count = 0;\r\ntemp.private_value = MIXART_VOL_REC_MASK | MIXART_VOL_AES_MASK;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\ntemp = mixart_control_pcm_switch;\r\ntemp.name = "PCM Playback Switch";\r\ntemp.private_value = 0;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\nif(mgr->board_type == MIXART_DAUGHTER_TYPE_AES) {\r\ntemp.name = "AES Playback Switch";\r\ntemp.private_value = MIXART_VOL_AES_MASK;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_monitor_vol, chip))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_monitor_sw, chip))) < 0)\r\nreturn err;\r\nmixart_reset_audio_levels(chip);\r\n}\r\nreturn 0;\r\n}
