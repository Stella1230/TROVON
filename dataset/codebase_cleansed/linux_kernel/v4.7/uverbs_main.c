int uverbs_dealloc_mw(struct ib_mw *mw)\r\n{\r\nstruct ib_pd *pd = mw->pd;\r\nint ret;\r\nret = mw->device->dealloc_mw(mw);\r\nif (!ret)\r\natomic_dec(&pd->usecnt);\r\nreturn ret;\r\n}\r\nstatic void ib_uverbs_release_dev(struct kobject *kobj)\r\n{\r\nstruct ib_uverbs_device *dev =\r\ncontainer_of(kobj, struct ib_uverbs_device, kobj);\r\ncleanup_srcu_struct(&dev->disassociate_srcu);\r\nkfree(dev);\r\n}\r\nstatic void ib_uverbs_release_event_file(struct kref *ref)\r\n{\r\nstruct ib_uverbs_event_file *file =\r\ncontainer_of(ref, struct ib_uverbs_event_file, ref);\r\nkfree(file);\r\n}\r\nvoid ib_uverbs_release_ucq(struct ib_uverbs_file *file,\r\nstruct ib_uverbs_event_file *ev_file,\r\nstruct ib_ucq_object *uobj)\r\n{\r\nstruct ib_uverbs_event *evt, *tmp;\r\nif (ev_file) {\r\nspin_lock_irq(&ev_file->lock);\r\nlist_for_each_entry_safe(evt, tmp, &uobj->comp_list, obj_list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nspin_unlock_irq(&ev_file->lock);\r\nkref_put(&ev_file->ref, ib_uverbs_release_event_file);\r\n}\r\nspin_lock_irq(&file->async_file->lock);\r\nlist_for_each_entry_safe(evt, tmp, &uobj->async_list, obj_list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nspin_unlock_irq(&file->async_file->lock);\r\n}\r\nvoid ib_uverbs_release_uevent(struct ib_uverbs_file *file,\r\nstruct ib_uevent_object *uobj)\r\n{\r\nstruct ib_uverbs_event *evt, *tmp;\r\nspin_lock_irq(&file->async_file->lock);\r\nlist_for_each_entry_safe(evt, tmp, &uobj->event_list, obj_list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nspin_unlock_irq(&file->async_file->lock);\r\n}\r\nstatic void ib_uverbs_detach_umcast(struct ib_qp *qp,\r\nstruct ib_uqp_object *uobj)\r\n{\r\nstruct ib_uverbs_mcast_entry *mcast, *tmp;\r\nlist_for_each_entry_safe(mcast, tmp, &uobj->mcast_list, list) {\r\nib_detach_mcast(qp, &mcast->gid, mcast->lid);\r\nlist_del(&mcast->list);\r\nkfree(mcast);\r\n}\r\n}\r\nstatic int ib_uverbs_cleanup_ucontext(struct ib_uverbs_file *file,\r\nstruct ib_ucontext *context)\r\n{\r\nstruct ib_uobject *uobj, *tmp;\r\ncontext->closing = 1;\r\nlist_for_each_entry_safe(uobj, tmp, &context->ah_list, list) {\r\nstruct ib_ah *ah = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_ah_idr, uobj);\r\nib_destroy_ah(ah);\r\nkfree(uobj);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->mw_list, list) {\r\nstruct ib_mw *mw = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_mw_idr, uobj);\r\nuverbs_dealloc_mw(mw);\r\nkfree(uobj);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->rule_list, list) {\r\nstruct ib_flow *flow_id = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_rule_idr, uobj);\r\nib_destroy_flow(flow_id);\r\nkfree(uobj);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->qp_list, list) {\r\nstruct ib_qp *qp = uobj->object;\r\nstruct ib_uqp_object *uqp =\r\ncontainer_of(uobj, struct ib_uqp_object, uevent.uobject);\r\nidr_remove_uobj(&ib_uverbs_qp_idr, uobj);\r\nif (qp != qp->real_qp) {\r\nib_close_qp(qp);\r\n} else {\r\nib_uverbs_detach_umcast(qp, uqp);\r\nib_destroy_qp(qp);\r\n}\r\nib_uverbs_release_uevent(file, &uqp->uevent);\r\nkfree(uqp);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->srq_list, list) {\r\nstruct ib_srq *srq = uobj->object;\r\nstruct ib_uevent_object *uevent =\r\ncontainer_of(uobj, struct ib_uevent_object, uobject);\r\nidr_remove_uobj(&ib_uverbs_srq_idr, uobj);\r\nib_destroy_srq(srq);\r\nib_uverbs_release_uevent(file, uevent);\r\nkfree(uevent);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->cq_list, list) {\r\nstruct ib_cq *cq = uobj->object;\r\nstruct ib_uverbs_event_file *ev_file = cq->cq_context;\r\nstruct ib_ucq_object *ucq =\r\ncontainer_of(uobj, struct ib_ucq_object, uobject);\r\nidr_remove_uobj(&ib_uverbs_cq_idr, uobj);\r\nib_destroy_cq(cq);\r\nib_uverbs_release_ucq(file, ev_file, ucq);\r\nkfree(ucq);\r\n}\r\nlist_for_each_entry_safe(uobj, tmp, &context->mr_list, list) {\r\nstruct ib_mr *mr = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_mr_idr, uobj);\r\nib_dereg_mr(mr);\r\nkfree(uobj);\r\n}\r\nmutex_lock(&file->device->xrcd_tree_mutex);\r\nlist_for_each_entry_safe(uobj, tmp, &context->xrcd_list, list) {\r\nstruct ib_xrcd *xrcd = uobj->object;\r\nstruct ib_uxrcd_object *uxrcd =\r\ncontainer_of(uobj, struct ib_uxrcd_object, uobject);\r\nidr_remove_uobj(&ib_uverbs_xrcd_idr, uobj);\r\nib_uverbs_dealloc_xrcd(file->device, xrcd);\r\nkfree(uxrcd);\r\n}\r\nmutex_unlock(&file->device->xrcd_tree_mutex);\r\nlist_for_each_entry_safe(uobj, tmp, &context->pd_list, list) {\r\nstruct ib_pd *pd = uobj->object;\r\nidr_remove_uobj(&ib_uverbs_pd_idr, uobj);\r\nib_dealloc_pd(pd);\r\nkfree(uobj);\r\n}\r\nput_pid(context->tgid);\r\nreturn context->device->dealloc_ucontext(context);\r\n}\r\nstatic void ib_uverbs_comp_dev(struct ib_uverbs_device *dev)\r\n{\r\ncomplete(&dev->comp);\r\n}\r\nstatic void ib_uverbs_release_file(struct kref *ref)\r\n{\r\nstruct ib_uverbs_file *file =\r\ncontainer_of(ref, struct ib_uverbs_file, ref);\r\nstruct ib_device *ib_dev;\r\nint srcu_key;\r\nsrcu_key = srcu_read_lock(&file->device->disassociate_srcu);\r\nib_dev = srcu_dereference(file->device->ib_dev,\r\n&file->device->disassociate_srcu);\r\nif (ib_dev && !ib_dev->disassociate_ucontext)\r\nmodule_put(ib_dev->owner);\r\nsrcu_read_unlock(&file->device->disassociate_srcu, srcu_key);\r\nif (atomic_dec_and_test(&file->device->refcount))\r\nib_uverbs_comp_dev(file->device);\r\nkfree(file);\r\n}\r\nstatic ssize_t ib_uverbs_event_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\nstruct ib_uverbs_event *event;\r\nint eventsz;\r\nint ret = 0;\r\nspin_lock_irq(&file->lock);\r\nwhile (list_empty(&file->event_list)) {\r\nspin_unlock_irq(&file->lock);\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(file->poll_wait,\r\n(!list_empty(&file->event_list) ||\r\n!file->uverbs_file->device->ib_dev)))\r\nreturn -ERESTARTSYS;\r\nif (list_empty(&file->event_list) &&\r\n!file->uverbs_file->device->ib_dev)\r\nreturn -EIO;\r\nspin_lock_irq(&file->lock);\r\n}\r\nevent = list_entry(file->event_list.next, struct ib_uverbs_event, list);\r\nif (file->is_async)\r\neventsz = sizeof (struct ib_uverbs_async_event_desc);\r\nelse\r\neventsz = sizeof (struct ib_uverbs_comp_event_desc);\r\nif (eventsz > count) {\r\nret = -EINVAL;\r\nevent = NULL;\r\n} else {\r\nlist_del(file->event_list.next);\r\nif (event->counter) {\r\n++(*event->counter);\r\nlist_del(&event->obj_list);\r\n}\r\n}\r\nspin_unlock_irq(&file->lock);\r\nif (event) {\r\nif (copy_to_user(buf, event, eventsz))\r\nret = -EFAULT;\r\nelse\r\nret = eventsz;\r\n}\r\nkfree(event);\r\nreturn ret;\r\n}\r\nstatic unsigned int ib_uverbs_event_poll(struct file *filp,\r\nstruct poll_table_struct *wait)\r\n{\r\nunsigned int pollflags = 0;\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\npoll_wait(filp, &file->poll_wait, wait);\r\nspin_lock_irq(&file->lock);\r\nif (!list_empty(&file->event_list))\r\npollflags = POLLIN | POLLRDNORM;\r\nspin_unlock_irq(&file->lock);\r\nreturn pollflags;\r\n}\r\nstatic int ib_uverbs_event_fasync(int fd, struct file *filp, int on)\r\n{\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\nreturn fasync_helper(fd, filp, on, &file->async_queue);\r\n}\r\nstatic int ib_uverbs_event_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_uverbs_event_file *file = filp->private_data;\r\nstruct ib_uverbs_event *entry, *tmp;\r\nint closed_already = 0;\r\nmutex_lock(&file->uverbs_file->device->lists_mutex);\r\nspin_lock_irq(&file->lock);\r\nclosed_already = file->is_closed;\r\nfile->is_closed = 1;\r\nlist_for_each_entry_safe(entry, tmp, &file->event_list, list) {\r\nif (entry->counter)\r\nlist_del(&entry->obj_list);\r\nkfree(entry);\r\n}\r\nspin_unlock_irq(&file->lock);\r\nif (!closed_already) {\r\nlist_del(&file->list);\r\nif (file->is_async)\r\nib_unregister_event_handler(&file->uverbs_file->\r\nevent_handler);\r\n}\r\nmutex_unlock(&file->uverbs_file->device->lists_mutex);\r\nkref_put(&file->uverbs_file->ref, ib_uverbs_release_file);\r\nkref_put(&file->ref, ib_uverbs_release_event_file);\r\nreturn 0;\r\n}\r\nvoid ib_uverbs_comp_handler(struct ib_cq *cq, void *cq_context)\r\n{\r\nstruct ib_uverbs_event_file *file = cq_context;\r\nstruct ib_ucq_object *uobj;\r\nstruct ib_uverbs_event *entry;\r\nunsigned long flags;\r\nif (!file)\r\nreturn;\r\nspin_lock_irqsave(&file->lock, flags);\r\nif (file->is_closed) {\r\nspin_unlock_irqrestore(&file->lock, flags);\r\nreturn;\r\n}\r\nentry = kmalloc(sizeof *entry, GFP_ATOMIC);\r\nif (!entry) {\r\nspin_unlock_irqrestore(&file->lock, flags);\r\nreturn;\r\n}\r\nuobj = container_of(cq->uobject, struct ib_ucq_object, uobject);\r\nentry->desc.comp.cq_handle = cq->uobject->user_handle;\r\nentry->counter = &uobj->comp_events_reported;\r\nlist_add_tail(&entry->list, &file->event_list);\r\nlist_add_tail(&entry->obj_list, &uobj->comp_list);\r\nspin_unlock_irqrestore(&file->lock, flags);\r\nwake_up_interruptible(&file->poll_wait);\r\nkill_fasync(&file->async_queue, SIGIO, POLL_IN);\r\n}\r\nstatic void ib_uverbs_async_handler(struct ib_uverbs_file *file,\r\n__u64 element, __u64 event,\r\nstruct list_head *obj_list,\r\nu32 *counter)\r\n{\r\nstruct ib_uverbs_event *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&file->async_file->lock, flags);\r\nif (file->async_file->is_closed) {\r\nspin_unlock_irqrestore(&file->async_file->lock, flags);\r\nreturn;\r\n}\r\nentry = kmalloc(sizeof *entry, GFP_ATOMIC);\r\nif (!entry) {\r\nspin_unlock_irqrestore(&file->async_file->lock, flags);\r\nreturn;\r\n}\r\nentry->desc.async.element = element;\r\nentry->desc.async.event_type = event;\r\nentry->desc.async.reserved = 0;\r\nentry->counter = counter;\r\nlist_add_tail(&entry->list, &file->async_file->event_list);\r\nif (obj_list)\r\nlist_add_tail(&entry->obj_list, obj_list);\r\nspin_unlock_irqrestore(&file->async_file->lock, flags);\r\nwake_up_interruptible(&file->async_file->poll_wait);\r\nkill_fasync(&file->async_file->async_queue, SIGIO, POLL_IN);\r\n}\r\nvoid ib_uverbs_cq_event_handler(struct ib_event *event, void *context_ptr)\r\n{\r\nstruct ib_ucq_object *uobj = container_of(event->element.cq->uobject,\r\nstruct ib_ucq_object, uobject);\r\nib_uverbs_async_handler(uobj->uverbs_file, uobj->uobject.user_handle,\r\nevent->event, &uobj->async_list,\r\n&uobj->async_events_reported);\r\n}\r\nvoid ib_uverbs_qp_event_handler(struct ib_event *event, void *context_ptr)\r\n{\r\nstruct ib_uevent_object *uobj;\r\nif (!event->element.qp->uobject || !event->element.qp->uobject->live)\r\nreturn;\r\nuobj = container_of(event->element.qp->uobject,\r\nstruct ib_uevent_object, uobject);\r\nib_uverbs_async_handler(context_ptr, uobj->uobject.user_handle,\r\nevent->event, &uobj->event_list,\r\n&uobj->events_reported);\r\n}\r\nvoid ib_uverbs_srq_event_handler(struct ib_event *event, void *context_ptr)\r\n{\r\nstruct ib_uevent_object *uobj;\r\nuobj = container_of(event->element.srq->uobject,\r\nstruct ib_uevent_object, uobject);\r\nib_uverbs_async_handler(context_ptr, uobj->uobject.user_handle,\r\nevent->event, &uobj->event_list,\r\n&uobj->events_reported);\r\n}\r\nvoid ib_uverbs_event_handler(struct ib_event_handler *handler,\r\nstruct ib_event *event)\r\n{\r\nstruct ib_uverbs_file *file =\r\ncontainer_of(handler, struct ib_uverbs_file, event_handler);\r\nib_uverbs_async_handler(file, event->element.port_num, event->event,\r\nNULL, NULL);\r\n}\r\nvoid ib_uverbs_free_async_event_file(struct ib_uverbs_file *file)\r\n{\r\nkref_put(&file->async_file->ref, ib_uverbs_release_event_file);\r\nfile->async_file = NULL;\r\n}\r\nstruct file *ib_uverbs_alloc_event_file(struct ib_uverbs_file *uverbs_file,\r\nstruct ib_device *ib_dev,\r\nint is_async)\r\n{\r\nstruct ib_uverbs_event_file *ev_file;\r\nstruct file *filp;\r\nint ret;\r\nev_file = kzalloc(sizeof(*ev_file), GFP_KERNEL);\r\nif (!ev_file)\r\nreturn ERR_PTR(-ENOMEM);\r\nkref_init(&ev_file->ref);\r\nspin_lock_init(&ev_file->lock);\r\nINIT_LIST_HEAD(&ev_file->event_list);\r\ninit_waitqueue_head(&ev_file->poll_wait);\r\nev_file->uverbs_file = uverbs_file;\r\nkref_get(&ev_file->uverbs_file->ref);\r\nev_file->async_queue = NULL;\r\nev_file->is_closed = 0;\r\nfilp = anon_inode_getfile("[infinibandevent]", &uverbs_event_fops,\r\nev_file, O_RDONLY);\r\nif (IS_ERR(filp))\r\ngoto err_put_refs;\r\nmutex_lock(&uverbs_file->device->lists_mutex);\r\nlist_add_tail(&ev_file->list,\r\n&uverbs_file->device->uverbs_events_file_list);\r\nmutex_unlock(&uverbs_file->device->lists_mutex);\r\nif (is_async) {\r\nWARN_ON(uverbs_file->async_file);\r\nuverbs_file->async_file = ev_file;\r\nkref_get(&uverbs_file->async_file->ref);\r\nINIT_IB_EVENT_HANDLER(&uverbs_file->event_handler,\r\nib_dev,\r\nib_uverbs_event_handler);\r\nret = ib_register_event_handler(&uverbs_file->event_handler);\r\nif (ret)\r\ngoto err_put_file;\r\nev_file->is_async = 1;\r\n}\r\nreturn filp;\r\nerr_put_file:\r\nfput(filp);\r\nkref_put(&uverbs_file->async_file->ref, ib_uverbs_release_event_file);\r\nuverbs_file->async_file = NULL;\r\nreturn ERR_PTR(ret);\r\nerr_put_refs:\r\nkref_put(&ev_file->uverbs_file->ref, ib_uverbs_release_file);\r\nkref_put(&ev_file->ref, ib_uverbs_release_event_file);\r\nreturn filp;\r\n}\r\nstruct ib_uverbs_event_file *ib_uverbs_lookup_comp_file(int fd)\r\n{\r\nstruct ib_uverbs_event_file *ev_file = NULL;\r\nstruct fd f = fdget(fd);\r\nif (!f.file)\r\nreturn NULL;\r\nif (f.file->f_op != &uverbs_event_fops)\r\ngoto out;\r\nev_file = f.file->private_data;\r\nif (ev_file->is_async) {\r\nev_file = NULL;\r\ngoto out;\r\n}\r\nkref_get(&ev_file->ref);\r\nout:\r\nfdput(f);\r\nreturn ev_file;\r\n}\r\nstatic int verify_command_mask(struct ib_device *ib_dev, __u32 command)\r\n{\r\nu64 mask;\r\nif (command <= IB_USER_VERBS_CMD_OPEN_QP)\r\nmask = ib_dev->uverbs_cmd_mask;\r\nelse\r\nmask = ib_dev->uverbs_ex_cmd_mask;\r\nif (mask & ((u64)1 << command))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct ib_uverbs_file *file = filp->private_data;\r\nstruct ib_device *ib_dev;\r\nstruct ib_uverbs_cmd_hdr hdr;\r\n__u32 command;\r\n__u32 flags;\r\nint srcu_key;\r\nssize_t ret;\r\nif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\r\nreturn -EACCES;\r\nif (count < sizeof hdr)\r\nreturn -EINVAL;\r\nif (copy_from_user(&hdr, buf, sizeof hdr))\r\nreturn -EFAULT;\r\nsrcu_key = srcu_read_lock(&file->device->disassociate_srcu);\r\nib_dev = srcu_dereference(file->device->ib_dev,\r\n&file->device->disassociate_srcu);\r\nif (!ib_dev) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (hdr.command & ~(__u32)(IB_USER_VERBS_CMD_FLAGS_MASK |\r\nIB_USER_VERBS_CMD_COMMAND_MASK)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncommand = hdr.command & IB_USER_VERBS_CMD_COMMAND_MASK;\r\nif (verify_command_mask(ib_dev, command)) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (!file->ucontext &&\r\ncommand != IB_USER_VERBS_CMD_GET_CONTEXT) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nflags = (hdr.command &\r\nIB_USER_VERBS_CMD_FLAGS_MASK) >> IB_USER_VERBS_CMD_FLAGS_SHIFT;\r\nif (!flags) {\r\nif (command >= ARRAY_SIZE(uverbs_cmd_table) ||\r\n!uverbs_cmd_table[command]) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (hdr.in_words * 4 != count) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = uverbs_cmd_table[command](file, ib_dev,\r\nbuf + sizeof(hdr),\r\nhdr.in_words * 4,\r\nhdr.out_words * 4);\r\n} else if (flags == IB_USER_VERBS_CMD_FLAG_EXTENDED) {\r\nstruct ib_uverbs_ex_cmd_hdr ex_hdr;\r\nstruct ib_udata ucore;\r\nstruct ib_udata uhw;\r\nsize_t written_count = count;\r\nif (command >= ARRAY_SIZE(uverbs_ex_cmd_table) ||\r\n!uverbs_ex_cmd_table[command]) {\r\nret = -ENOSYS;\r\ngoto out;\r\n}\r\nif (!file->ucontext) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (count < (sizeof(hdr) + sizeof(ex_hdr))) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (copy_from_user(&ex_hdr, buf + sizeof(hdr), sizeof(ex_hdr))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\ncount -= sizeof(hdr) + sizeof(ex_hdr);\r\nbuf += sizeof(hdr) + sizeof(ex_hdr);\r\nif ((hdr.in_words + ex_hdr.provider_in_words) * 8 != count) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ex_hdr.cmd_hdr_reserved) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ex_hdr.response) {\r\nif (!hdr.out_words && !ex_hdr.provider_out_words) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!access_ok(VERIFY_WRITE,\r\n(void __user *) (unsigned long) ex_hdr.response,\r\n(hdr.out_words + ex_hdr.provider_out_words) * 8)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n} else {\r\nif (hdr.out_words || ex_hdr.provider_out_words) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nINIT_UDATA_BUF_OR_NULL(&ucore, buf, (unsigned long) ex_hdr.response,\r\nhdr.in_words * 8, hdr.out_words * 8);\r\nINIT_UDATA_BUF_OR_NULL(&uhw,\r\nbuf + ucore.inlen,\r\n(unsigned long) ex_hdr.response + ucore.outlen,\r\nex_hdr.provider_in_words * 8,\r\nex_hdr.provider_out_words * 8);\r\nret = uverbs_ex_cmd_table[command](file,\r\nib_dev,\r\n&ucore,\r\n&uhw);\r\nif (!ret)\r\nret = written_count;\r\n} else {\r\nret = -ENOSYS;\r\n}\r\nout:\r\nsrcu_read_unlock(&file->device->disassociate_srcu, srcu_key);\r\nreturn ret;\r\n}\r\nstatic int ib_uverbs_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct ib_uverbs_file *file = filp->private_data;\r\nstruct ib_device *ib_dev;\r\nint ret = 0;\r\nint srcu_key;\r\nsrcu_key = srcu_read_lock(&file->device->disassociate_srcu);\r\nib_dev = srcu_dereference(file->device->ib_dev,\r\n&file->device->disassociate_srcu);\r\nif (!ib_dev) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!file->ucontext)\r\nret = -ENODEV;\r\nelse\r\nret = ib_dev->mmap(file->ucontext, vma);\r\nout:\r\nsrcu_read_unlock(&file->device->disassociate_srcu, srcu_key);\r\nreturn ret;\r\n}\r\nstatic int ib_uverbs_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_uverbs_device *dev;\r\nstruct ib_uverbs_file *file;\r\nstruct ib_device *ib_dev;\r\nint ret;\r\nint module_dependent;\r\nint srcu_key;\r\ndev = container_of(inode->i_cdev, struct ib_uverbs_device, cdev);\r\nif (!atomic_inc_not_zero(&dev->refcount))\r\nreturn -ENXIO;\r\nsrcu_key = srcu_read_lock(&dev->disassociate_srcu);\r\nmutex_lock(&dev->lists_mutex);\r\nib_dev = srcu_dereference(dev->ib_dev,\r\n&dev->disassociate_srcu);\r\nif (!ib_dev) {\r\nret = -EIO;\r\ngoto err;\r\n}\r\nmodule_dependent = !(ib_dev->disassociate_ucontext);\r\nif (module_dependent) {\r\nif (!try_module_get(ib_dev->owner)) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\n}\r\nfile = kzalloc(sizeof(*file), GFP_KERNEL);\r\nif (!file) {\r\nret = -ENOMEM;\r\nif (module_dependent)\r\ngoto err_module;\r\ngoto err;\r\n}\r\nfile->device = dev;\r\nfile->ucontext = NULL;\r\nfile->async_file = NULL;\r\nkref_init(&file->ref);\r\nmutex_init(&file->mutex);\r\nfilp->private_data = file;\r\nkobject_get(&dev->kobj);\r\nlist_add_tail(&file->list, &dev->uverbs_file_list);\r\nmutex_unlock(&dev->lists_mutex);\r\nsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\r\nreturn nonseekable_open(inode, filp);\r\nerr_module:\r\nmodule_put(ib_dev->owner);\r\nerr:\r\nmutex_unlock(&dev->lists_mutex);\r\nsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\r\nif (atomic_dec_and_test(&dev->refcount))\r\nib_uverbs_comp_dev(dev);\r\nreturn ret;\r\n}\r\nstatic int ib_uverbs_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_uverbs_file *file = filp->private_data;\r\nstruct ib_uverbs_device *dev = file->device;\r\nstruct ib_ucontext *ucontext = NULL;\r\nmutex_lock(&file->device->lists_mutex);\r\nucontext = file->ucontext;\r\nfile->ucontext = NULL;\r\nif (!file->is_closed) {\r\nlist_del(&file->list);\r\nfile->is_closed = 1;\r\n}\r\nmutex_unlock(&file->device->lists_mutex);\r\nif (ucontext)\r\nib_uverbs_cleanup_ucontext(file, ucontext);\r\nif (file->async_file)\r\nkref_put(&file->async_file->ref, ib_uverbs_release_event_file);\r\nkref_put(&file->ref, ib_uverbs_release_file);\r\nkobject_put(&dev->kobj);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_ibdev(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret = -ENODEV;\r\nint srcu_key;\r\nstruct ib_uverbs_device *dev = dev_get_drvdata(device);\r\nstruct ib_device *ib_dev;\r\nif (!dev)\r\nreturn -ENODEV;\r\nsrcu_key = srcu_read_lock(&dev->disassociate_srcu);\r\nib_dev = srcu_dereference(dev->ib_dev, &dev->disassociate_srcu);\r\nif (ib_dev)\r\nret = sprintf(buf, "%s\n", ib_dev->name);\r\nsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_dev_abi_version(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ib_uverbs_device *dev = dev_get_drvdata(device);\r\nint ret = -ENODEV;\r\nint srcu_key;\r\nstruct ib_device *ib_dev;\r\nif (!dev)\r\nreturn -ENODEV;\r\nsrcu_key = srcu_read_lock(&dev->disassociate_srcu);\r\nib_dev = srcu_dereference(dev->ib_dev, &dev->disassociate_srcu);\r\nif (ib_dev)\r\nret = sprintf(buf, "%d\n", ib_dev->uverbs_abi_ver);\r\nsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\r\nreturn ret;\r\n}\r\nstatic int find_overflow_devnum(void)\r\n{\r\nint ret;\r\nif (!overflow_maj) {\r\nret = alloc_chrdev_region(&overflow_maj, 0, IB_UVERBS_MAX_DEVICES,\r\n"infiniband_verbs");\r\nif (ret) {\r\npr_err("user_verbs: couldn't register dynamic device number\n");\r\nreturn ret;\r\n}\r\n}\r\nret = find_first_zero_bit(overflow_map, IB_UVERBS_MAX_DEVICES);\r\nif (ret >= IB_UVERBS_MAX_DEVICES)\r\nreturn -1;\r\nreturn ret;\r\n}\r\nstatic void ib_uverbs_add_one(struct ib_device *device)\r\n{\r\nint devnum;\r\ndev_t base;\r\nstruct ib_uverbs_device *uverbs_dev;\r\nint ret;\r\nif (!device->alloc_ucontext)\r\nreturn;\r\nuverbs_dev = kzalloc(sizeof *uverbs_dev, GFP_KERNEL);\r\nif (!uverbs_dev)\r\nreturn;\r\nret = init_srcu_struct(&uverbs_dev->disassociate_srcu);\r\nif (ret) {\r\nkfree(uverbs_dev);\r\nreturn;\r\n}\r\natomic_set(&uverbs_dev->refcount, 1);\r\ninit_completion(&uverbs_dev->comp);\r\nuverbs_dev->xrcd_tree = RB_ROOT;\r\nmutex_init(&uverbs_dev->xrcd_tree_mutex);\r\nkobject_init(&uverbs_dev->kobj, &ib_uverbs_dev_ktype);\r\nmutex_init(&uverbs_dev->lists_mutex);\r\nINIT_LIST_HEAD(&uverbs_dev->uverbs_file_list);\r\nINIT_LIST_HEAD(&uverbs_dev->uverbs_events_file_list);\r\nspin_lock(&map_lock);\r\ndevnum = find_first_zero_bit(dev_map, IB_UVERBS_MAX_DEVICES);\r\nif (devnum >= IB_UVERBS_MAX_DEVICES) {\r\nspin_unlock(&map_lock);\r\ndevnum = find_overflow_devnum();\r\nif (devnum < 0)\r\ngoto err;\r\nspin_lock(&map_lock);\r\nuverbs_dev->devnum = devnum + IB_UVERBS_MAX_DEVICES;\r\nbase = devnum + overflow_maj;\r\nset_bit(devnum, overflow_map);\r\n} else {\r\nuverbs_dev->devnum = devnum;\r\nbase = devnum + IB_UVERBS_BASE_DEV;\r\nset_bit(devnum, dev_map);\r\n}\r\nspin_unlock(&map_lock);\r\nrcu_assign_pointer(uverbs_dev->ib_dev, device);\r\nuverbs_dev->num_comp_vectors = device->num_comp_vectors;\r\ncdev_init(&uverbs_dev->cdev, NULL);\r\nuverbs_dev->cdev.owner = THIS_MODULE;\r\nuverbs_dev->cdev.ops = device->mmap ? &uverbs_mmap_fops : &uverbs_fops;\r\nuverbs_dev->cdev.kobj.parent = &uverbs_dev->kobj;\r\nkobject_set_name(&uverbs_dev->cdev.kobj, "uverbs%d", uverbs_dev->devnum);\r\nif (cdev_add(&uverbs_dev->cdev, base, 1))\r\ngoto err_cdev;\r\nuverbs_dev->dev = device_create(uverbs_class, device->dma_device,\r\nuverbs_dev->cdev.dev, uverbs_dev,\r\n"uverbs%d", uverbs_dev->devnum);\r\nif (IS_ERR(uverbs_dev->dev))\r\ngoto err_cdev;\r\nif (device_create_file(uverbs_dev->dev, &dev_attr_ibdev))\r\ngoto err_class;\r\nif (device_create_file(uverbs_dev->dev, &dev_attr_abi_version))\r\ngoto err_class;\r\nib_set_client_data(device, &uverbs_client, uverbs_dev);\r\nreturn;\r\nerr_class:\r\ndevice_destroy(uverbs_class, uverbs_dev->cdev.dev);\r\nerr_cdev:\r\ncdev_del(&uverbs_dev->cdev);\r\nif (uverbs_dev->devnum < IB_UVERBS_MAX_DEVICES)\r\nclear_bit(devnum, dev_map);\r\nelse\r\nclear_bit(devnum, overflow_map);\r\nerr:\r\nif (atomic_dec_and_test(&uverbs_dev->refcount))\r\nib_uverbs_comp_dev(uverbs_dev);\r\nwait_for_completion(&uverbs_dev->comp);\r\nkobject_put(&uverbs_dev->kobj);\r\nreturn;\r\n}\r\nstatic void ib_uverbs_free_hw_resources(struct ib_uverbs_device *uverbs_dev,\r\nstruct ib_device *ib_dev)\r\n{\r\nstruct ib_uverbs_file *file;\r\nstruct ib_uverbs_event_file *event_file;\r\nstruct ib_event event;\r\nsynchronize_srcu(&uverbs_dev->disassociate_srcu);\r\nevent.event = IB_EVENT_DEVICE_FATAL;\r\nevent.element.port_num = 0;\r\nevent.device = ib_dev;\r\nmutex_lock(&uverbs_dev->lists_mutex);\r\nwhile (!list_empty(&uverbs_dev->uverbs_file_list)) {\r\nstruct ib_ucontext *ucontext;\r\nfile = list_first_entry(&uverbs_dev->uverbs_file_list,\r\nstruct ib_uverbs_file, list);\r\nfile->is_closed = 1;\r\nucontext = file->ucontext;\r\nlist_del(&file->list);\r\nfile->ucontext = NULL;\r\nkref_get(&file->ref);\r\nmutex_unlock(&uverbs_dev->lists_mutex);\r\nib_uverbs_event_handler(&file->event_handler, &event);\r\nif (ucontext) {\r\nib_dev->disassociate_ucontext(ucontext);\r\nib_uverbs_cleanup_ucontext(file, ucontext);\r\n}\r\nmutex_lock(&uverbs_dev->lists_mutex);\r\nkref_put(&file->ref, ib_uverbs_release_file);\r\n}\r\nwhile (!list_empty(&uverbs_dev->uverbs_events_file_list)) {\r\nevent_file = list_first_entry(&uverbs_dev->\r\nuverbs_events_file_list,\r\nstruct ib_uverbs_event_file,\r\nlist);\r\nspin_lock_irq(&event_file->lock);\r\nevent_file->is_closed = 1;\r\nspin_unlock_irq(&event_file->lock);\r\nlist_del(&event_file->list);\r\nif (event_file->is_async) {\r\nib_unregister_event_handler(&event_file->uverbs_file->\r\nevent_handler);\r\nevent_file->uverbs_file->event_handler.device = NULL;\r\n}\r\nwake_up_interruptible(&event_file->poll_wait);\r\nkill_fasync(&event_file->async_queue, SIGIO, POLL_IN);\r\n}\r\nmutex_unlock(&uverbs_dev->lists_mutex);\r\n}\r\nstatic void ib_uverbs_remove_one(struct ib_device *device, void *client_data)\r\n{\r\nstruct ib_uverbs_device *uverbs_dev = client_data;\r\nint wait_clients = 1;\r\nif (!uverbs_dev)\r\nreturn;\r\ndev_set_drvdata(uverbs_dev->dev, NULL);\r\ndevice_destroy(uverbs_class, uverbs_dev->cdev.dev);\r\ncdev_del(&uverbs_dev->cdev);\r\nif (uverbs_dev->devnum < IB_UVERBS_MAX_DEVICES)\r\nclear_bit(uverbs_dev->devnum, dev_map);\r\nelse\r\nclear_bit(uverbs_dev->devnum - IB_UVERBS_MAX_DEVICES, overflow_map);\r\nif (device->disassociate_ucontext) {\r\nrcu_assign_pointer(uverbs_dev->ib_dev, NULL);\r\nib_uverbs_free_hw_resources(uverbs_dev, device);\r\nwait_clients = 0;\r\n}\r\nif (atomic_dec_and_test(&uverbs_dev->refcount))\r\nib_uverbs_comp_dev(uverbs_dev);\r\nif (wait_clients)\r\nwait_for_completion(&uverbs_dev->comp);\r\nkobject_put(&uverbs_dev->kobj);\r\n}\r\nstatic char *uverbs_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (mode)\r\n*mode = 0666;\r\nreturn kasprintf(GFP_KERNEL, "infiniband/%s", dev_name(dev));\r\n}\r\nstatic int __init ib_uverbs_init(void)\r\n{\r\nint ret;\r\nret = register_chrdev_region(IB_UVERBS_BASE_DEV, IB_UVERBS_MAX_DEVICES,\r\n"infiniband_verbs");\r\nif (ret) {\r\npr_err("user_verbs: couldn't register device number\n");\r\ngoto out;\r\n}\r\nuverbs_class = class_create(THIS_MODULE, "infiniband_verbs");\r\nif (IS_ERR(uverbs_class)) {\r\nret = PTR_ERR(uverbs_class);\r\npr_err("user_verbs: couldn't create class infiniband_verbs\n");\r\ngoto out_chrdev;\r\n}\r\nuverbs_class->devnode = uverbs_devnode;\r\nret = class_create_file(uverbs_class, &class_attr_abi_version.attr);\r\nif (ret) {\r\npr_err("user_verbs: couldn't create abi_version attribute\n");\r\ngoto out_class;\r\n}\r\nret = ib_register_client(&uverbs_client);\r\nif (ret) {\r\npr_err("user_verbs: couldn't register client\n");\r\ngoto out_class;\r\n}\r\nreturn 0;\r\nout_class:\r\nclass_destroy(uverbs_class);\r\nout_chrdev:\r\nunregister_chrdev_region(IB_UVERBS_BASE_DEV, IB_UVERBS_MAX_DEVICES);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit ib_uverbs_cleanup(void)\r\n{\r\nib_unregister_client(&uverbs_client);\r\nclass_destroy(uverbs_class);\r\nunregister_chrdev_region(IB_UVERBS_BASE_DEV, IB_UVERBS_MAX_DEVICES);\r\nif (overflow_maj)\r\nunregister_chrdev_region(overflow_maj, IB_UVERBS_MAX_DEVICES);\r\nidr_destroy(&ib_uverbs_pd_idr);\r\nidr_destroy(&ib_uverbs_mr_idr);\r\nidr_destroy(&ib_uverbs_mw_idr);\r\nidr_destroy(&ib_uverbs_ah_idr);\r\nidr_destroy(&ib_uverbs_cq_idr);\r\nidr_destroy(&ib_uverbs_qp_idr);\r\nidr_destroy(&ib_uverbs_srq_idr);\r\n}
