static inline int ieee80211_networks_allocate(struct ieee80211_device *ieee)\r\n{\r\nif (ieee->networks)\r\nreturn 0;\r\nieee->networks = kcalloc(\r\nMAX_NETWORK_COUNT, sizeof(struct ieee80211_network),\r\nGFP_KERNEL);\r\nif (!ieee->networks) {\r\nprintk(KERN_WARNING "%s: Out of memory allocating beacons\n",\r\nieee->dev->name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void ieee80211_networks_free(struct ieee80211_device *ieee)\r\n{\r\nif (!ieee->networks)\r\nreturn;\r\nkfree(ieee->networks);\r\nieee->networks = NULL;\r\n}\r\nstatic inline void ieee80211_networks_initialize(struct ieee80211_device *ieee)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&ieee->network_free_list);\r\nINIT_LIST_HEAD(&ieee->network_list);\r\nfor (i = 0; i < MAX_NETWORK_COUNT; i++)\r\nlist_add_tail(&ieee->networks[i].list, &ieee->network_free_list);\r\n}\r\nstruct net_device *alloc_ieee80211(int sizeof_priv)\r\n{\r\nstruct ieee80211_device *ieee;\r\nstruct net_device *dev;\r\nint i, err;\r\nIEEE80211_DEBUG_INFO("Initializing...\n");\r\ndev = alloc_etherdev(sizeof(struct ieee80211_device) + sizeof_priv);\r\nif (!dev) {\r\nIEEE80211_ERROR("Unable to network device.\n");\r\ngoto failed;\r\n}\r\nieee = netdev_priv(dev);\r\nmemset(ieee, 0, sizeof(struct ieee80211_device)+sizeof_priv);\r\nieee->dev = dev;\r\nerr = ieee80211_networks_allocate(ieee);\r\nif (err) {\r\nIEEE80211_ERROR("Unable to allocate beacon storage: %d\n",\r\nerr);\r\ngoto failed;\r\n}\r\nieee80211_networks_initialize(ieee);\r\nieee->fts = DEFAULT_FTS;\r\nieee->scan_age = DEFAULT_MAX_SCAN_AGE;\r\nieee->open_wep = 1;\r\nieee->host_encrypt = 1;\r\nieee->host_decrypt = 1;\r\nieee->ieee802_1x = 1;\r\nINIT_LIST_HEAD(&ieee->crypt_deinit_list);\r\nsetup_timer(&ieee->crypt_deinit_timer,\r\nieee80211_crypt_deinit_handler, (unsigned long)ieee);\r\nspin_lock_init(&ieee->lock);\r\nspin_lock_init(&ieee->wpax_suitlist_lock);\r\nspin_lock_init(&ieee->bw_spinlock);\r\nspin_lock_init(&ieee->reorder_spinlock);\r\natomic_set(&(ieee->atm_chnlop), 0);\r\natomic_set(&(ieee->atm_swbw), 0);\r\nieee->wpax_type_set = 0;\r\nieee->wpa_enabled = 0;\r\nieee->tkip_countermeasures = 0;\r\nieee->drop_unencrypted = 0;\r\nieee->privacy_invoked = 0;\r\nieee->ieee802_1x = 1;\r\nieee->raw_tx = 0;\r\nieee->hwsec_active = 0;\r\nieee80211_softmac_init(ieee);\r\nieee->pHTInfo = kzalloc(sizeof(RT_HIGH_THROUGHPUT), GFP_KERNEL);\r\nif (ieee->pHTInfo == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't alloc memory for HTInfo\n");\r\ngoto failed;\r\n}\r\nHTUpdateDefaultSetting(ieee);\r\nHTInitializeHTInfo(ieee);\r\nTSInitialize(ieee);\r\nfor (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&ieee->ibss_mac_hash[i]);\r\nfor (i = 0; i < 17; i++) {\r\nieee->last_rxseq_num[i] = -1;\r\nieee->last_rxfrag_num[i] = -1;\r\nieee->last_packet_time[i] = 0;\r\n}\r\nieee80211_tkip_null();\r\nieee80211_ccmp_null();\r\nreturn dev;\r\nfailed:\r\nif (dev)\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nvoid free_ieee80211(struct net_device *dev)\r\n{\r\nstruct ieee80211_device *ieee = netdev_priv(dev);\r\nint i;\r\nkfree(ieee->pHTInfo);\r\nieee->pHTInfo = NULL;\r\nRemoveAllTS(ieee);\r\nieee80211_softmac_free(ieee);\r\ndel_timer_sync(&ieee->crypt_deinit_timer);\r\nieee80211_crypt_deinit_entries(ieee, 1);\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nstruct ieee80211_crypt_data *crypt = ieee->crypt[i];\r\nif (crypt) {\r\nif (crypt->ops)\r\ncrypt->ops->deinit(crypt->priv);\r\nkfree(crypt);\r\nieee->crypt[i] = NULL;\r\n}\r\n}\r\nieee80211_networks_free(ieee);\r\nfree_netdev(dev);\r\n}\r\nstatic int show_debug_level(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "0x%08X\n", ieee80211_debug_level);\r\nreturn 0;\r\n}\r\nstatic ssize_t write_debug_level(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long val;\r\nint err = kstrtoul_from_user(buffer, count, 0, &val);\r\nif (err)\r\nreturn err;\r\nieee80211_debug_level = val;\r\nreturn count;\r\n}\r\nstatic int open_debug_level(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_debug_level, NULL);\r\n}\r\nint __init ieee80211_debug_init(void)\r\n{\r\nstruct proc_dir_entry *e;\r\nieee80211_debug_level = debug;\r\nieee80211_proc = proc_mkdir(DRV_NAME, init_net.proc_net);\r\nif (ieee80211_proc == NULL) {\r\nIEEE80211_ERROR("Unable to create " DRV_NAME\r\n" proc directory\n");\r\nreturn -EIO;\r\n}\r\ne = proc_create("debug_level", S_IRUGO | S_IWUSR,\r\nieee80211_proc, &fops);\r\nif (!e) {\r\nremove_proc_entry(DRV_NAME, init_net.proc_net);\r\nieee80211_proc = NULL;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid __exit ieee80211_debug_exit(void)\r\n{\r\nif (ieee80211_proc) {\r\nremove_proc_entry("debug_level", ieee80211_proc);\r\nremove_proc_entry(DRV_NAME, init_net.proc_net);\r\nieee80211_proc = NULL;\r\n}\r\n}
