static struct mpls_route *mpls_route_input_rcu(struct net *net, unsigned index)\r\n{\r\nstruct mpls_route *rt = NULL;\r\nif (index < net->mpls.platform_labels) {\r\nstruct mpls_route __rcu **platform_label =\r\nrcu_dereference(net->mpls.platform_label);\r\nrt = rcu_dereference(platform_label[index]);\r\n}\r\nreturn rt;\r\n}\r\nstatic inline struct mpls_dev *mpls_dev_get(const struct net_device *dev)\r\n{\r\nreturn rcu_dereference_rtnl(dev->mpls_ptr);\r\n}\r\nbool mpls_output_possible(const struct net_device *dev)\r\n{\r\nreturn dev && (dev->flags & IFF_UP) && netif_carrier_ok(dev);\r\n}\r\nstatic u8 *__mpls_nh_via(struct mpls_route *rt, struct mpls_nh *nh)\r\n{\r\nu8 *nh0_via = PTR_ALIGN((u8 *)&rt->rt_nh[rt->rt_nhn], VIA_ALEN_ALIGN);\r\nint nh_index = nh - rt->rt_nh;\r\nreturn nh0_via + rt->rt_max_alen * nh_index;\r\n}\r\nstatic const u8 *mpls_nh_via(const struct mpls_route *rt,\r\nconst struct mpls_nh *nh)\r\n{\r\nreturn __mpls_nh_via((struct mpls_route *)rt, (struct mpls_nh *)nh);\r\n}\r\nstatic unsigned int mpls_nh_header_size(const struct mpls_nh *nh)\r\n{\r\nreturn nh->nh_labels * sizeof(struct mpls_shim_hdr);\r\n}\r\nunsigned int mpls_dev_mtu(const struct net_device *dev)\r\n{\r\nreturn dev->mtu;\r\n}\r\nbool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)\r\n{\r\nif (skb->len <= mtu)\r\nreturn false;\r\nif (skb_is_gso(skb) && skb_gso_network_seglen(skb) <= mtu)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic u32 mpls_multipath_hash(struct mpls_route *rt,\r\nstruct sk_buff *skb, bool bos)\r\n{\r\nstruct mpls_entry_decoded dec;\r\nstruct mpls_shim_hdr *hdr;\r\nbool eli_seen = false;\r\nint label_index;\r\nu32 hash = 0;\r\nfor (label_index = 0; label_index < MAX_MP_SELECT_LABELS && !bos;\r\nlabel_index++) {\r\nif (!pskb_may_pull(skb, sizeof(*hdr) * label_index))\r\nbreak;\r\nhdr = mpls_hdr(skb) + label_index;\r\ndec = mpls_entry_decode(hdr);\r\nif (likely(dec.label >= MPLS_LABEL_FIRST_UNRESERVED)) {\r\nhash = jhash_1word(dec.label, hash);\r\nif (eli_seen)\r\nbreak;\r\n} else if (dec.label == MPLS_LABEL_ENTROPY) {\r\neli_seen = true;\r\n}\r\nbos = dec.bos;\r\nif (bos && pskb_may_pull(skb, sizeof(*hdr) * label_index +\r\nsizeof(struct iphdr))) {\r\nconst struct iphdr *v4hdr;\r\nv4hdr = (const struct iphdr *)(mpls_hdr(skb) +\r\nlabel_index);\r\nif (v4hdr->version == 4) {\r\nhash = jhash_3words(ntohl(v4hdr->saddr),\r\nntohl(v4hdr->daddr),\r\nv4hdr->protocol, hash);\r\n} else if (v4hdr->version == 6 &&\r\npskb_may_pull(skb, sizeof(*hdr) * label_index +\r\nsizeof(struct ipv6hdr))) {\r\nconst struct ipv6hdr *v6hdr;\r\nv6hdr = (const struct ipv6hdr *)(mpls_hdr(skb) +\r\nlabel_index);\r\nhash = __ipv6_addr_jhash(&v6hdr->saddr, hash);\r\nhash = __ipv6_addr_jhash(&v6hdr->daddr, hash);\r\nhash = jhash_1word(v6hdr->nexthdr, hash);\r\n}\r\n}\r\n}\r\nreturn hash;\r\n}\r\nstatic struct mpls_nh *mpls_select_multipath(struct mpls_route *rt,\r\nstruct sk_buff *skb, bool bos)\r\n{\r\nint alive = ACCESS_ONCE(rt->rt_nhn_alive);\r\nu32 hash = 0;\r\nint nh_index = 0;\r\nint n = 0;\r\nif (rt->rt_nhn == 1)\r\ngoto out;\r\nif (alive <= 0)\r\nreturn NULL;\r\nhash = mpls_multipath_hash(rt, skb, bos);\r\nnh_index = hash % alive;\r\nif (alive == rt->rt_nhn)\r\ngoto out;\r\nfor_nexthops(rt) {\r\nif (nh->nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\r\ncontinue;\r\nif (n == nh_index)\r\nreturn nh;\r\nn++;\r\n} endfor_nexthops(rt);\r\nout:\r\nreturn &rt->rt_nh[nh_index];\r\n}\r\nstatic bool mpls_egress(struct mpls_route *rt, struct sk_buff *skb,\r\nstruct mpls_entry_decoded dec)\r\n{\r\nenum mpls_payload_type payload_type;\r\nbool success = false;\r\nif (!pskb_may_pull(skb, 12))\r\nreturn false;\r\npayload_type = rt->rt_payload_type;\r\nif (payload_type == MPT_UNSPEC)\r\npayload_type = ip_hdr(skb)->version;\r\nswitch (payload_type) {\r\ncase MPT_IPV4: {\r\nstruct iphdr *hdr4 = ip_hdr(skb);\r\nskb->protocol = htons(ETH_P_IP);\r\ncsum_replace2(&hdr4->check,\r\nhtons(hdr4->ttl << 8),\r\nhtons(dec.ttl << 8));\r\nhdr4->ttl = dec.ttl;\r\nsuccess = true;\r\nbreak;\r\n}\r\ncase MPT_IPV6: {\r\nstruct ipv6hdr *hdr6 = ipv6_hdr(skb);\r\nskb->protocol = htons(ETH_P_IPV6);\r\nhdr6->hop_limit = dec.ttl;\r\nsuccess = true;\r\nbreak;\r\n}\r\ncase MPT_UNSPEC:\r\nbreak;\r\n}\r\nreturn success;\r\n}\r\nstatic int mpls_forward(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct mpls_shim_hdr *hdr;\r\nstruct mpls_route *rt;\r\nstruct mpls_nh *nh;\r\nstruct mpls_entry_decoded dec;\r\nstruct net_device *out_dev;\r\nstruct mpls_dev *mdev;\r\nunsigned int hh_len;\r\nunsigned int new_header_size;\r\nunsigned int mtu;\r\nint err;\r\nmdev = mpls_dev_get(dev);\r\nif (!mdev || !mdev->input_enabled)\r\ngoto drop;\r\nif (skb->pkt_type != PACKET_HOST)\r\ngoto drop;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\r\ngoto drop;\r\nif (!pskb_may_pull(skb, sizeof(*hdr)))\r\ngoto drop;\r\nhdr = mpls_hdr(skb);\r\ndec = mpls_entry_decode(hdr);\r\nskb_pull(skb, sizeof(*hdr));\r\nskb_reset_network_header(skb);\r\nskb_orphan(skb);\r\nrt = mpls_route_input_rcu(net, dec.label);\r\nif (!rt)\r\ngoto drop;\r\nnh = mpls_select_multipath(rt, skb, dec.bos);\r\nif (!nh)\r\ngoto drop;\r\nout_dev = rcu_dereference(nh->nh_dev);\r\nif (!mpls_output_possible(out_dev))\r\ngoto drop;\r\nif (skb_warn_if_lro(skb))\r\ngoto drop;\r\nskb_forward_csum(skb);\r\nif (dec.ttl <= 1)\r\ngoto drop;\r\ndec.ttl -= 1;\r\nnew_header_size = mpls_nh_header_size(nh);\r\nmtu = mpls_dev_mtu(out_dev);\r\nif (mpls_pkt_too_big(skb, mtu - new_header_size))\r\ngoto drop;\r\nhh_len = LL_RESERVED_SPACE(out_dev);\r\nif (!out_dev->header_ops)\r\nhh_len = 0;\r\nif (skb_cow(skb, hh_len + new_header_size))\r\ngoto drop;\r\nskb->dev = out_dev;\r\nskb->protocol = htons(ETH_P_MPLS_UC);\r\nif (unlikely(!new_header_size && dec.bos)) {\r\nif (!mpls_egress(rt, skb, dec))\r\ngoto drop;\r\n} else {\r\nbool bos;\r\nint i;\r\nskb_push(skb, new_header_size);\r\nskb_reset_network_header(skb);\r\nhdr = mpls_hdr(skb);\r\nbos = dec.bos;\r\nfor (i = nh->nh_labels - 1; i >= 0; i--) {\r\nhdr[i] = mpls_entry_encode(nh->nh_label[i],\r\ndec.ttl, 0, bos);\r\nbos = false;\r\n}\r\n}\r\nif (nh->nh_via_table == MPLS_NEIGH_TABLE_UNSPEC)\r\nerr = neigh_xmit(NEIGH_LINK_TABLE, out_dev,\r\nout_dev->dev_addr, skb);\r\nelse\r\nerr = neigh_xmit(nh->nh_via_table, out_dev,\r\nmpls_nh_via(rt, nh), skb);\r\nif (err)\r\nnet_dbg_ratelimited("%s: packet transmission failed: %d\n",\r\n__func__, err);\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic struct mpls_route *mpls_rt_alloc(int num_nh, u8 max_alen)\r\n{\r\nu8 max_alen_aligned = ALIGN(max_alen, VIA_ALEN_ALIGN);\r\nstruct mpls_route *rt;\r\nrt = kzalloc(ALIGN(sizeof(*rt) + num_nh * sizeof(*rt->rt_nh),\r\nVIA_ALEN_ALIGN) +\r\nnum_nh * max_alen_aligned,\r\nGFP_KERNEL);\r\nif (rt) {\r\nrt->rt_nhn = num_nh;\r\nrt->rt_nhn_alive = num_nh;\r\nrt->rt_max_alen = max_alen_aligned;\r\n}\r\nreturn rt;\r\n}\r\nstatic void mpls_rt_free(struct mpls_route *rt)\r\n{\r\nif (rt)\r\nkfree_rcu(rt, rt_rcu);\r\n}\r\nstatic void mpls_notify_route(struct net *net, unsigned index,\r\nstruct mpls_route *old, struct mpls_route *new,\r\nconst struct nl_info *info)\r\n{\r\nstruct nlmsghdr *nlh = info ? info->nlh : NULL;\r\nunsigned portid = info ? info->portid : 0;\r\nint event = new ? RTM_NEWROUTE : RTM_DELROUTE;\r\nstruct mpls_route *rt = new ? new : old;\r\nunsigned nlm_flags = (old && new) ? NLM_F_REPLACE : 0;\r\nif (rt && (index >= MPLS_LABEL_FIRST_UNRESERVED))\r\nrtmsg_lfib(event, index, rt, nlh, net, portid, nlm_flags);\r\n}\r\nstatic void mpls_route_update(struct net *net, unsigned index,\r\nstruct mpls_route *new,\r\nconst struct nl_info *info)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nstruct mpls_route *rt;\r\nASSERT_RTNL();\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nrt = rtnl_dereference(platform_label[index]);\r\nrcu_assign_pointer(platform_label[index], new);\r\nmpls_notify_route(net, index, rt, new, info);\r\nmpls_rt_free(rt);\r\n}\r\nstatic unsigned find_free_label(struct net *net)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nsize_t platform_labels;\r\nunsigned index;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nplatform_labels = net->mpls.platform_labels;\r\nfor (index = MPLS_LABEL_FIRST_UNRESERVED; index < platform_labels;\r\nindex++) {\r\nif (!rtnl_dereference(platform_label[index]))\r\nreturn index;\r\n}\r\nreturn LABEL_NOT_SPECIFIED;\r\n}\r\nstatic struct net_device *inet_fib_lookup_dev(struct net *net,\r\nconst void *addr)\r\n{\r\nstruct net_device *dev;\r\nstruct rtable *rt;\r\nstruct in_addr daddr;\r\nmemcpy(&daddr, addr, sizeof(struct in_addr));\r\nrt = ip_route_output(net, daddr.s_addr, 0, 0, 0);\r\nif (IS_ERR(rt))\r\nreturn ERR_CAST(rt);\r\ndev = rt->dst.dev;\r\ndev_hold(dev);\r\nip_rt_put(rt);\r\nreturn dev;\r\n}\r\nstatic struct net_device *inet_fib_lookup_dev(struct net *net,\r\nconst void *addr)\r\n{\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\n}\r\nstatic struct net_device *inet6_fib_lookup_dev(struct net *net,\r\nconst void *addr)\r\n{\r\nstruct net_device *dev;\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nint err;\r\nif (!ipv6_stub)\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\nmemset(&fl6, 0, sizeof(fl6));\r\nmemcpy(&fl6.daddr, addr, sizeof(struct in6_addr));\r\nerr = ipv6_stub->ipv6_dst_lookup(net, NULL, &dst, &fl6);\r\nif (err)\r\nreturn ERR_PTR(err);\r\ndev = dst->dev;\r\ndev_hold(dev);\r\ndst_release(dst);\r\nreturn dev;\r\n}\r\nstatic struct net_device *inet6_fib_lookup_dev(struct net *net,\r\nconst void *addr)\r\n{\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\n}\r\nstatic struct net_device *find_outdev(struct net *net,\r\nstruct mpls_route *rt,\r\nstruct mpls_nh *nh, int oif)\r\n{\r\nstruct net_device *dev = NULL;\r\nif (!oif) {\r\nswitch (nh->nh_via_table) {\r\ncase NEIGH_ARP_TABLE:\r\ndev = inet_fib_lookup_dev(net, mpls_nh_via(rt, nh));\r\nbreak;\r\ncase NEIGH_ND_TABLE:\r\ndev = inet6_fib_lookup_dev(net, mpls_nh_via(rt, nh));\r\nbreak;\r\ncase NEIGH_LINK_TABLE:\r\nbreak;\r\n}\r\n} else {\r\ndev = dev_get_by_index(net, oif);\r\n}\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nif (IS_ERR(dev))\r\nreturn dev;\r\ndev_put(dev);\r\nreturn dev;\r\n}\r\nstatic int mpls_nh_assign_dev(struct net *net, struct mpls_route *rt,\r\nstruct mpls_nh *nh, int oif)\r\n{\r\nstruct net_device *dev = NULL;\r\nint err = -ENODEV;\r\ndev = find_outdev(net, rt, nh, oif);\r\nif (IS_ERR(dev)) {\r\nerr = PTR_ERR(dev);\r\ndev = NULL;\r\ngoto errout;\r\n}\r\nerr = -EINVAL;\r\nif (!mpls_dev_get(dev))\r\ngoto errout;\r\nif ((nh->nh_via_table == NEIGH_LINK_TABLE) &&\r\n(dev->addr_len != nh->nh_via_alen))\r\ngoto errout;\r\nRCU_INIT_POINTER(nh->nh_dev, dev);\r\nif (!(dev->flags & IFF_UP)) {\r\nnh->nh_flags |= RTNH_F_DEAD;\r\n} else {\r\nunsigned int flags;\r\nflags = dev_get_flags(dev);\r\nif (!(flags & (IFF_RUNNING | IFF_LOWER_UP)))\r\nnh->nh_flags |= RTNH_F_LINKDOWN;\r\n}\r\nreturn 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_nh_build_from_cfg(struct mpls_route_config *cfg,\r\nstruct mpls_route *rt)\r\n{\r\nstruct net *net = cfg->rc_nlinfo.nl_net;\r\nstruct mpls_nh *nh = rt->rt_nh;\r\nint err;\r\nint i;\r\nif (!nh)\r\nreturn -ENOMEM;\r\nerr = -EINVAL;\r\nif (cfg->rc_output_labels > MAX_NEW_LABELS)\r\ngoto errout;\r\nnh->nh_labels = cfg->rc_output_labels;\r\nfor (i = 0; i < nh->nh_labels; i++)\r\nnh->nh_label[i] = cfg->rc_output_label[i];\r\nnh->nh_via_table = cfg->rc_via_table;\r\nmemcpy(__mpls_nh_via(rt, nh), cfg->rc_via, cfg->rc_via_alen);\r\nnh->nh_via_alen = cfg->rc_via_alen;\r\nerr = mpls_nh_assign_dev(net, rt, nh, cfg->rc_ifindex);\r\nif (err)\r\ngoto errout;\r\nif (nh->nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\r\nrt->rt_nhn_alive--;\r\nreturn 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_nh_build(struct net *net, struct mpls_route *rt,\r\nstruct mpls_nh *nh, int oif, struct nlattr *via,\r\nstruct nlattr *newdst)\r\n{\r\nint err = -ENOMEM;\r\nif (!nh)\r\ngoto errout;\r\nif (newdst) {\r\nerr = nla_get_labels(newdst, MAX_NEW_LABELS,\r\n&nh->nh_labels, nh->nh_label);\r\nif (err)\r\ngoto errout;\r\n}\r\nif (via) {\r\nerr = nla_get_via(via, &nh->nh_via_alen, &nh->nh_via_table,\r\n__mpls_nh_via(rt, nh));\r\nif (err)\r\ngoto errout;\r\n} else {\r\nnh->nh_via_table = MPLS_NEIGH_TABLE_UNSPEC;\r\n}\r\nerr = mpls_nh_assign_dev(net, rt, nh, oif);\r\nif (err)\r\ngoto errout;\r\nreturn 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_count_nexthops(struct rtnexthop *rtnh, int len,\r\nu8 cfg_via_alen, u8 *max_via_alen)\r\n{\r\nint nhs = 0;\r\nint remaining = len;\r\nif (!rtnh) {\r\n*max_via_alen = cfg_via_alen;\r\nreturn 1;\r\n}\r\n*max_via_alen = 0;\r\nwhile (rtnh_ok(rtnh, remaining)) {\r\nstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\r\nint attrlen;\r\nattrlen = rtnh_attrlen(rtnh);\r\nnla = nla_find(attrs, attrlen, RTA_VIA);\r\nif (nla && nla_len(nla) >=\r\noffsetof(struct rtvia, rtvia_addr)) {\r\nint via_alen = nla_len(nla) -\r\noffsetof(struct rtvia, rtvia_addr);\r\nif (via_alen <= MAX_VIA_ALEN)\r\n*max_via_alen = max_t(u16, *max_via_alen,\r\nvia_alen);\r\n}\r\nnhs++;\r\nrtnh = rtnh_next(rtnh, &remaining);\r\n}\r\nreturn remaining > 0 ? 0 : nhs;\r\n}\r\nstatic int mpls_nh_build_multi(struct mpls_route_config *cfg,\r\nstruct mpls_route *rt)\r\n{\r\nstruct rtnexthop *rtnh = cfg->rc_mp;\r\nstruct nlattr *nla_via, *nla_newdst;\r\nint remaining = cfg->rc_mp_len;\r\nint nhs = 0;\r\nint err = 0;\r\nchange_nexthops(rt) {\r\nint attrlen;\r\nnla_via = NULL;\r\nnla_newdst = NULL;\r\nerr = -EINVAL;\r\nif (!rtnh_ok(rtnh, remaining))\r\ngoto errout;\r\nif (rtnh->rtnh_hops || rtnh->rtnh_flags)\r\ngoto errout;\r\nattrlen = rtnh_attrlen(rtnh);\r\nif (attrlen > 0) {\r\nstruct nlattr *attrs = rtnh_attrs(rtnh);\r\nnla_via = nla_find(attrs, attrlen, RTA_VIA);\r\nnla_newdst = nla_find(attrs, attrlen, RTA_NEWDST);\r\n}\r\nerr = mpls_nh_build(cfg->rc_nlinfo.nl_net, rt, nh,\r\nrtnh->rtnh_ifindex, nla_via, nla_newdst);\r\nif (err)\r\ngoto errout;\r\nif (nh->nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\r\nrt->rt_nhn_alive--;\r\nrtnh = rtnh_next(rtnh, &remaining);\r\nnhs++;\r\n} endfor_nexthops(rt);\r\nrt->rt_nhn = nhs;\r\nreturn 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_route_add(struct mpls_route_config *cfg)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nstruct net *net = cfg->rc_nlinfo.nl_net;\r\nstruct mpls_route *rt, *old;\r\nint err = -EINVAL;\r\nu8 max_via_alen;\r\nunsigned index;\r\nint nhs;\r\nindex = cfg->rc_label;\r\nif ((index == LABEL_NOT_SPECIFIED) &&\r\n(cfg->rc_nlflags & NLM_F_CREATE)) {\r\nindex = find_free_label(net);\r\n}\r\nif (index < MPLS_LABEL_FIRST_UNRESERVED)\r\ngoto errout;\r\nif (index >= net->mpls.platform_labels)\r\ngoto errout;\r\nerr = -EOPNOTSUPP;\r\nif (cfg->rc_nlflags & NLM_F_APPEND)\r\ngoto errout;\r\nerr = -EEXIST;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nold = rtnl_dereference(platform_label[index]);\r\nif ((cfg->rc_nlflags & NLM_F_EXCL) && old)\r\ngoto errout;\r\nerr = -EEXIST;\r\nif (!(cfg->rc_nlflags & NLM_F_REPLACE) && old)\r\ngoto errout;\r\nerr = -ENOENT;\r\nif (!(cfg->rc_nlflags & NLM_F_CREATE) && !old)\r\ngoto errout;\r\nerr = -EINVAL;\r\nnhs = mpls_count_nexthops(cfg->rc_mp, cfg->rc_mp_len,\r\ncfg->rc_via_alen, &max_via_alen);\r\nif (nhs == 0)\r\ngoto errout;\r\nerr = -ENOMEM;\r\nrt = mpls_rt_alloc(nhs, max_via_alen);\r\nif (!rt)\r\ngoto errout;\r\nrt->rt_protocol = cfg->rc_protocol;\r\nrt->rt_payload_type = cfg->rc_payload_type;\r\nif (cfg->rc_mp)\r\nerr = mpls_nh_build_multi(cfg, rt);\r\nelse\r\nerr = mpls_nh_build_from_cfg(cfg, rt);\r\nif (err)\r\ngoto freert;\r\nmpls_route_update(net, index, rt, &cfg->rc_nlinfo);\r\nreturn 0;\r\nfreert:\r\nmpls_rt_free(rt);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_route_del(struct mpls_route_config *cfg)\r\n{\r\nstruct net *net = cfg->rc_nlinfo.nl_net;\r\nunsigned index;\r\nint err = -EINVAL;\r\nindex = cfg->rc_label;\r\nif (index < MPLS_LABEL_FIRST_UNRESERVED)\r\ngoto errout;\r\nif (index >= net->mpls.platform_labels)\r\ngoto errout;\r\nmpls_route_update(net, index, NULL, &cfg->rc_nlinfo);\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_dev_sysctl_register(struct net_device *dev,\r\nstruct mpls_dev *mdev)\r\n{\r\nchar path[sizeof("net/mpls/conf/") + IFNAMSIZ];\r\nstruct ctl_table *table;\r\nint i;\r\ntable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\r\nif (!table)\r\ngoto out;\r\nfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++)\r\ntable[i].data = (char *)mdev + (uintptr_t)table[i].data;\r\nsnprintf(path, sizeof(path), "net/mpls/conf/%s", dev->name);\r\nmdev->sysctl = register_net_sysctl(dev_net(dev), path, table);\r\nif (!mdev->sysctl)\r\ngoto free;\r\nreturn 0;\r\nfree:\r\nkfree(table);\r\nout:\r\nreturn -ENOBUFS;\r\n}\r\nstatic void mpls_dev_sysctl_unregister(struct mpls_dev *mdev)\r\n{\r\nstruct ctl_table *table;\r\ntable = mdev->sysctl->ctl_table_arg;\r\nunregister_net_sysctl_table(mdev->sysctl);\r\nkfree(table);\r\n}\r\nstatic struct mpls_dev *mpls_add_dev(struct net_device *dev)\r\n{\r\nstruct mpls_dev *mdev;\r\nint err = -ENOMEM;\r\nASSERT_RTNL();\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn ERR_PTR(err);\r\nerr = mpls_dev_sysctl_register(dev, mdev);\r\nif (err)\r\ngoto free;\r\nrcu_assign_pointer(dev->mpls_ptr, mdev);\r\nreturn mdev;\r\nfree:\r\nkfree(mdev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void mpls_ifdown(struct net_device *dev, int event)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nstruct net *net = dev_net(dev);\r\nunsigned index;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nfor (index = 0; index < net->mpls.platform_labels; index++) {\r\nstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\r\nif (!rt)\r\ncontinue;\r\nchange_nexthops(rt) {\r\nif (rtnl_dereference(nh->nh_dev) != dev)\r\ncontinue;\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\ncase NETDEV_UNREGISTER:\r\nnh->nh_flags |= RTNH_F_DEAD;\r\ncase NETDEV_CHANGE:\r\nnh->nh_flags |= RTNH_F_LINKDOWN;\r\nACCESS_ONCE(rt->rt_nhn_alive) = rt->rt_nhn_alive - 1;\r\nbreak;\r\n}\r\nif (event == NETDEV_UNREGISTER)\r\nRCU_INIT_POINTER(nh->nh_dev, NULL);\r\n} endfor_nexthops(rt);\r\n}\r\nreturn;\r\n}\r\nstatic void mpls_ifup(struct net_device *dev, unsigned int nh_flags)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nstruct net *net = dev_net(dev);\r\nunsigned index;\r\nint alive;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nfor (index = 0; index < net->mpls.platform_labels; index++) {\r\nstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\r\nif (!rt)\r\ncontinue;\r\nalive = 0;\r\nchange_nexthops(rt) {\r\nstruct net_device *nh_dev =\r\nrtnl_dereference(nh->nh_dev);\r\nif (!(nh->nh_flags & nh_flags)) {\r\nalive++;\r\ncontinue;\r\n}\r\nif (nh_dev != dev)\r\ncontinue;\r\nalive++;\r\nnh->nh_flags &= ~nh_flags;\r\n} endfor_nexthops(rt);\r\nACCESS_ONCE(rt->rt_nhn_alive) = alive;\r\n}\r\nreturn;\r\n}\r\nstatic int mpls_dev_notify(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct mpls_dev *mdev;\r\nunsigned int flags;\r\nif (event == NETDEV_REGISTER) {\r\nif ((dev->type == ARPHRD_ETHER) ||\r\n(dev->type == ARPHRD_LOOPBACK)) {\r\nmdev = mpls_add_dev(dev);\r\nif (IS_ERR(mdev))\r\nreturn notifier_from_errno(PTR_ERR(mdev));\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nmdev = mpls_dev_get(dev);\r\nif (!mdev)\r\nreturn NOTIFY_OK;\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\nmpls_ifdown(dev, event);\r\nbreak;\r\ncase NETDEV_UP:\r\nflags = dev_get_flags(dev);\r\nif (flags & (IFF_RUNNING | IFF_LOWER_UP))\r\nmpls_ifup(dev, RTNH_F_DEAD | RTNH_F_LINKDOWN);\r\nelse\r\nmpls_ifup(dev, RTNH_F_DEAD);\r\nbreak;\r\ncase NETDEV_CHANGE:\r\nflags = dev_get_flags(dev);\r\nif (flags & (IFF_RUNNING | IFF_LOWER_UP))\r\nmpls_ifup(dev, RTNH_F_DEAD | RTNH_F_LINKDOWN);\r\nelse\r\nmpls_ifdown(dev, event);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nmpls_ifdown(dev, event);\r\nmdev = mpls_dev_get(dev);\r\nif (mdev) {\r\nmpls_dev_sysctl_unregister(mdev);\r\nRCU_INIT_POINTER(dev->mpls_ptr, NULL);\r\nkfree_rcu(mdev, rcu);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\nmdev = mpls_dev_get(dev);\r\nif (mdev) {\r\nint err;\r\nmpls_dev_sysctl_unregister(mdev);\r\nerr = mpls_dev_sysctl_register(dev, mdev);\r\nif (err)\r\nreturn notifier_from_errno(err);\r\n}\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int nla_put_via(struct sk_buff *skb,\r\nu8 table, const void *addr, int alen)\r\n{\r\nstatic const int table_to_family[NEIGH_NR_TABLES + 1] = {\r\nAF_INET, AF_INET6, AF_DECnet, AF_PACKET,\r\n};\r\nstruct nlattr *nla;\r\nstruct rtvia *via;\r\nint family = AF_UNSPEC;\r\nnla = nla_reserve(skb, RTA_VIA, alen + 2);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nif (table <= NEIGH_NR_TABLES)\r\nfamily = table_to_family[table];\r\nvia = nla_data(nla);\r\nvia->rtvia_family = family;\r\nmemcpy(via->rtvia_addr, addr, alen);\r\nreturn 0;\r\n}\r\nint nla_put_labels(struct sk_buff *skb, int attrtype,\r\nu8 labels, const u32 label[])\r\n{\r\nstruct nlattr *nla;\r\nstruct mpls_shim_hdr *nla_label;\r\nbool bos;\r\nint i;\r\nnla = nla_reserve(skb, attrtype, labels*4);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nnla_label = nla_data(nla);\r\nbos = true;\r\nfor (i = labels - 1; i >= 0; i--) {\r\nnla_label[i] = mpls_entry_encode(label[i], 0, 0, bos);\r\nbos = false;\r\n}\r\nreturn 0;\r\n}\r\nint nla_get_labels(const struct nlattr *nla,\r\nu32 max_labels, u8 *labels, u32 label[])\r\n{\r\nunsigned len = nla_len(nla);\r\nunsigned nla_labels;\r\nstruct mpls_shim_hdr *nla_label;\r\nbool bos;\r\nint i;\r\nif (len & 3)\r\nreturn -EINVAL;\r\nnla_labels = len/4;\r\nif (nla_labels > max_labels)\r\nreturn -EINVAL;\r\nnla_label = nla_data(nla);\r\nbos = true;\r\nfor (i = nla_labels - 1; i >= 0; i--, bos = false) {\r\nstruct mpls_entry_decoded dec;\r\ndec = mpls_entry_decode(nla_label + i);\r\nif ((dec.bos != bos) || dec.ttl || dec.tc)\r\nreturn -EINVAL;\r\nswitch (dec.label) {\r\ncase MPLS_LABEL_IMPLNULL:\r\nreturn -EINVAL;\r\n}\r\nlabel[i] = dec.label;\r\n}\r\n*labels = nla_labels;\r\nreturn 0;\r\n}\r\nint nla_get_via(const struct nlattr *nla, u8 *via_alen,\r\nu8 *via_table, u8 via_addr[])\r\n{\r\nstruct rtvia *via = nla_data(nla);\r\nint err = -EINVAL;\r\nint alen;\r\nif (nla_len(nla) < offsetof(struct rtvia, rtvia_addr))\r\ngoto errout;\r\nalen = nla_len(nla) -\r\noffsetof(struct rtvia, rtvia_addr);\r\nif (alen > MAX_VIA_ALEN)\r\ngoto errout;\r\nswitch (via->rtvia_family) {\r\ncase AF_PACKET:\r\n*via_table = NEIGH_LINK_TABLE;\r\nbreak;\r\ncase AF_INET:\r\n*via_table = NEIGH_ARP_TABLE;\r\nif (alen != 4)\r\ngoto errout;\r\nbreak;\r\ncase AF_INET6:\r\n*via_table = NEIGH_ND_TABLE;\r\nif (alen != 16)\r\ngoto errout;\r\nbreak;\r\ndefault:\r\ngoto errout;\r\n}\r\nmemcpy(via_addr, via->rtvia_addr, alen);\r\n*via_alen = alen;\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int rtm_to_route_config(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct mpls_route_config *cfg)\r\n{\r\nstruct rtmsg *rtm;\r\nstruct nlattr *tb[RTA_MAX+1];\r\nint index;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_mpls_policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = -EINVAL;\r\nrtm = nlmsg_data(nlh);\r\nmemset(cfg, 0, sizeof(*cfg));\r\nif (rtm->rtm_family != AF_MPLS)\r\ngoto errout;\r\nif (rtm->rtm_dst_len != 20)\r\ngoto errout;\r\nif (rtm->rtm_src_len != 0)\r\ngoto errout;\r\nif (rtm->rtm_tos != 0)\r\ngoto errout;\r\nif (rtm->rtm_table != RT_TABLE_MAIN)\r\ngoto errout;\r\nif (rtm->rtm_scope != RT_SCOPE_UNIVERSE)\r\ngoto errout;\r\nif (rtm->rtm_type != RTN_UNICAST)\r\ngoto errout;\r\nif (rtm->rtm_flags != 0)\r\ngoto errout;\r\ncfg->rc_label = LABEL_NOT_SPECIFIED;\r\ncfg->rc_protocol = rtm->rtm_protocol;\r\ncfg->rc_via_table = MPLS_NEIGH_TABLE_UNSPEC;\r\ncfg->rc_nlflags = nlh->nlmsg_flags;\r\ncfg->rc_nlinfo.portid = NETLINK_CB(skb).portid;\r\ncfg->rc_nlinfo.nlh = nlh;\r\ncfg->rc_nlinfo.nl_net = sock_net(skb->sk);\r\nfor (index = 0; index <= RTA_MAX; index++) {\r\nstruct nlattr *nla = tb[index];\r\nif (!nla)\r\ncontinue;\r\nswitch(index) {\r\ncase RTA_OIF:\r\ncfg->rc_ifindex = nla_get_u32(nla);\r\nbreak;\r\ncase RTA_NEWDST:\r\nif (nla_get_labels(nla, MAX_NEW_LABELS,\r\n&cfg->rc_output_labels,\r\ncfg->rc_output_label))\r\ngoto errout;\r\nbreak;\r\ncase RTA_DST:\r\n{\r\nu8 label_count;\r\nif (nla_get_labels(nla, 1, &label_count,\r\n&cfg->rc_label))\r\ngoto errout;\r\nif (cfg->rc_label < MPLS_LABEL_FIRST_UNRESERVED)\r\ngoto errout;\r\nbreak;\r\n}\r\ncase RTA_VIA:\r\n{\r\nif (nla_get_via(nla, &cfg->rc_via_alen,\r\n&cfg->rc_via_table, cfg->rc_via))\r\ngoto errout;\r\nbreak;\r\n}\r\ncase RTA_MULTIPATH:\r\n{\r\ncfg->rc_mp = nla_data(nla);\r\ncfg->rc_mp_len = nla_len(nla);\r\nbreak;\r\n}\r\ndefault:\r\ngoto errout;\r\n}\r\n}\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct mpls_route_config cfg;\r\nint err;\r\nerr = rtm_to_route_config(skb, nlh, &cfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn mpls_route_del(&cfg);\r\n}\r\nstatic int mpls_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct mpls_route_config cfg;\r\nint err;\r\nerr = rtm_to_route_config(skb, nlh, &cfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn mpls_route_add(&cfg);\r\n}\r\nstatic int mpls_dump_route(struct sk_buff *skb, u32 portid, u32 seq, int event,\r\nu32 label, struct mpls_route *rt, int flags)\r\n{\r\nstruct net_device *dev;\r\nstruct nlmsghdr *nlh;\r\nstruct rtmsg *rtm;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nrtm = nlmsg_data(nlh);\r\nrtm->rtm_family = AF_MPLS;\r\nrtm->rtm_dst_len = 20;\r\nrtm->rtm_src_len = 0;\r\nrtm->rtm_tos = 0;\r\nrtm->rtm_table = RT_TABLE_MAIN;\r\nrtm->rtm_protocol = rt->rt_protocol;\r\nrtm->rtm_scope = RT_SCOPE_UNIVERSE;\r\nrtm->rtm_type = RTN_UNICAST;\r\nrtm->rtm_flags = 0;\r\nif (nla_put_labels(skb, RTA_DST, 1, &label))\r\ngoto nla_put_failure;\r\nif (rt->rt_nhn == 1) {\r\nconst struct mpls_nh *nh = rt->rt_nh;\r\nif (nh->nh_labels &&\r\nnla_put_labels(skb, RTA_NEWDST, nh->nh_labels,\r\nnh->nh_label))\r\ngoto nla_put_failure;\r\nif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\r\nnla_put_via(skb, nh->nh_via_table, mpls_nh_via(rt, nh),\r\nnh->nh_via_alen))\r\ngoto nla_put_failure;\r\ndev = rtnl_dereference(nh->nh_dev);\r\nif (dev && nla_put_u32(skb, RTA_OIF, dev->ifindex))\r\ngoto nla_put_failure;\r\nif (nh->nh_flags & RTNH_F_LINKDOWN)\r\nrtm->rtm_flags |= RTNH_F_LINKDOWN;\r\nif (nh->nh_flags & RTNH_F_DEAD)\r\nrtm->rtm_flags |= RTNH_F_DEAD;\r\n} else {\r\nstruct rtnexthop *rtnh;\r\nstruct nlattr *mp;\r\nint dead = 0;\r\nint linkdown = 0;\r\nmp = nla_nest_start(skb, RTA_MULTIPATH);\r\nif (!mp)\r\ngoto nla_put_failure;\r\nfor_nexthops(rt) {\r\nrtnh = nla_reserve_nohdr(skb, sizeof(*rtnh));\r\nif (!rtnh)\r\ngoto nla_put_failure;\r\ndev = rtnl_dereference(nh->nh_dev);\r\nif (dev)\r\nrtnh->rtnh_ifindex = dev->ifindex;\r\nif (nh->nh_flags & RTNH_F_LINKDOWN) {\r\nrtnh->rtnh_flags |= RTNH_F_LINKDOWN;\r\nlinkdown++;\r\n}\r\nif (nh->nh_flags & RTNH_F_DEAD) {\r\nrtnh->rtnh_flags |= RTNH_F_DEAD;\r\ndead++;\r\n}\r\nif (nh->nh_labels && nla_put_labels(skb, RTA_NEWDST,\r\nnh->nh_labels,\r\nnh->nh_label))\r\ngoto nla_put_failure;\r\nif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\r\nnla_put_via(skb, nh->nh_via_table,\r\nmpls_nh_via(rt, nh),\r\nnh->nh_via_alen))\r\ngoto nla_put_failure;\r\nrtnh->rtnh_len = nlmsg_get_pos(skb) - (void *)rtnh;\r\n} endfor_nexthops(rt);\r\nif (linkdown == rt->rt_nhn)\r\nrtm->rtm_flags |= RTNH_F_LINKDOWN;\r\nif (dead == rt->rt_nhn)\r\nrtm->rtm_flags |= RTNH_F_DEAD;\r\nnla_nest_end(skb, mp);\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int mpls_dump_routes(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct mpls_route __rcu **platform_label;\r\nsize_t platform_labels;\r\nunsigned int index;\r\nASSERT_RTNL();\r\nindex = cb->args[0];\r\nif (index < MPLS_LABEL_FIRST_UNRESERVED)\r\nindex = MPLS_LABEL_FIRST_UNRESERVED;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nplatform_labels = net->mpls.platform_labels;\r\nfor (; index < platform_labels; index++) {\r\nstruct mpls_route *rt;\r\nrt = rtnl_dereference(platform_label[index]);\r\nif (!rt)\r\ncontinue;\r\nif (mpls_dump_route(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, RTM_NEWROUTE,\r\nindex, rt, NLM_F_MULTI) < 0)\r\nbreak;\r\n}\r\ncb->args[0] = index;\r\nreturn skb->len;\r\n}\r\nstatic inline size_t lfib_nlmsg_size(struct mpls_route *rt)\r\n{\r\nsize_t payload =\r\nNLMSG_ALIGN(sizeof(struct rtmsg))\r\n+ nla_total_size(4);\r\nif (rt->rt_nhn == 1) {\r\nstruct mpls_nh *nh = rt->rt_nh;\r\nif (nh->nh_dev)\r\npayload += nla_total_size(4);\r\nif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC)\r\npayload += nla_total_size(2 + nh->nh_via_alen);\r\nif (nh->nh_labels)\r\npayload += nla_total_size(nh->nh_labels * 4);\r\n} else {\r\nsize_t nhsize = 0;\r\nfor_nexthops(rt) {\r\nnhsize += nla_total_size(sizeof(struct rtnexthop));\r\nif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC)\r\nnhsize += nla_total_size(2 + nh->nh_via_alen);\r\nif (nh->nh_labels)\r\nnhsize += nla_total_size(nh->nh_labels * 4);\r\n} endfor_nexthops(rt);\r\npayload += nla_total_size(nhsize);\r\n}\r\nreturn payload;\r\n}\r\nstatic void rtmsg_lfib(int event, u32 label, struct mpls_route *rt,\r\nstruct nlmsghdr *nlh, struct net *net, u32 portid,\r\nunsigned int nlm_flags)\r\n{\r\nstruct sk_buff *skb;\r\nu32 seq = nlh ? nlh->nlmsg_seq : 0;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(lfib_nlmsg_size(rt), GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = mpls_dump_route(skb, portid, seq, event, label, rt, nlm_flags);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, portid, RTNLGRP_MPLS_ROUTE, nlh, GFP_KERNEL);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_MPLS_ROUTE, err);\r\n}\r\nstatic int resize_platform_label_table(struct net *net, size_t limit)\r\n{\r\nsize_t size = sizeof(struct mpls_route *) * limit;\r\nsize_t old_limit;\r\nsize_t cp_size;\r\nstruct mpls_route __rcu **labels = NULL, **old;\r\nstruct mpls_route *rt0 = NULL, *rt2 = NULL;\r\nunsigned index;\r\nif (size) {\r\nlabels = kzalloc(size, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\r\nif (!labels)\r\nlabels = vzalloc(size);\r\nif (!labels)\r\ngoto nolabels;\r\n}\r\nif (limit > MPLS_LABEL_IPV4NULL) {\r\nstruct net_device *lo = net->loopback_dev;\r\nrt0 = mpls_rt_alloc(1, lo->addr_len);\r\nif (!rt0)\r\ngoto nort0;\r\nRCU_INIT_POINTER(rt0->rt_nh->nh_dev, lo);\r\nrt0->rt_protocol = RTPROT_KERNEL;\r\nrt0->rt_payload_type = MPT_IPV4;\r\nrt0->rt_nh->nh_via_table = NEIGH_LINK_TABLE;\r\nrt0->rt_nh->nh_via_alen = lo->addr_len;\r\nmemcpy(__mpls_nh_via(rt0, rt0->rt_nh), lo->dev_addr,\r\nlo->addr_len);\r\n}\r\nif (limit > MPLS_LABEL_IPV6NULL) {\r\nstruct net_device *lo = net->loopback_dev;\r\nrt2 = mpls_rt_alloc(1, lo->addr_len);\r\nif (!rt2)\r\ngoto nort2;\r\nRCU_INIT_POINTER(rt2->rt_nh->nh_dev, lo);\r\nrt2->rt_protocol = RTPROT_KERNEL;\r\nrt2->rt_payload_type = MPT_IPV6;\r\nrt2->rt_nh->nh_via_table = NEIGH_LINK_TABLE;\r\nrt2->rt_nh->nh_via_alen = lo->addr_len;\r\nmemcpy(__mpls_nh_via(rt2, rt2->rt_nh), lo->dev_addr,\r\nlo->addr_len);\r\n}\r\nrtnl_lock();\r\nold = rtnl_dereference(net->mpls.platform_label);\r\nold_limit = net->mpls.platform_labels;\r\nfor (index = limit; index < old_limit; index++)\r\nmpls_route_update(net, index, NULL, NULL);\r\ncp_size = size;\r\nif (old_limit < limit)\r\ncp_size = old_limit * sizeof(struct mpls_route *);\r\nmemcpy(labels, old, cp_size);\r\nif ((old_limit <= MPLS_LABEL_IPV6NULL) &&\r\n(limit > MPLS_LABEL_IPV6NULL)) {\r\nRCU_INIT_POINTER(labels[MPLS_LABEL_IPV6NULL], rt2);\r\nrt2 = NULL;\r\n}\r\nif ((old_limit <= MPLS_LABEL_IPV4NULL) &&\r\n(limit > MPLS_LABEL_IPV4NULL)) {\r\nRCU_INIT_POINTER(labels[MPLS_LABEL_IPV4NULL], rt0);\r\nrt0 = NULL;\r\n}\r\nnet->mpls.platform_labels = limit;\r\nrcu_assign_pointer(net->mpls.platform_label, labels);\r\nrtnl_unlock();\r\nmpls_rt_free(rt2);\r\nmpls_rt_free(rt0);\r\nif (old) {\r\nsynchronize_rcu();\r\nkvfree(old);\r\n}\r\nreturn 0;\r\nnort2:\r\nmpls_rt_free(rt0);\r\nnort0:\r\nkvfree(labels);\r\nnolabels:\r\nreturn -ENOMEM;\r\n}\r\nstatic int mpls_platform_labels(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct net *net = table->data;\r\nint platform_labels = net->mpls.platform_labels;\r\nint ret;\r\nstruct ctl_table tmp = {\r\n.procname = table->procname,\r\n.data = &platform_labels,\r\n.maxlen = sizeof(int),\r\n.mode = table->mode,\r\n.extra1 = &zero,\r\n.extra2 = &label_limit,\r\n};\r\nret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\r\nif (write && ret == 0)\r\nret = resize_platform_label_table(net, platform_labels);\r\nreturn ret;\r\n}\r\nstatic int mpls_net_init(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nnet->mpls.platform_labels = 0;\r\nnet->mpls.platform_label = NULL;\r\ntable = kmemdup(mpls_table, sizeof(mpls_table), GFP_KERNEL);\r\nif (table == NULL)\r\nreturn -ENOMEM;\r\ntable[0].data = net;\r\nnet->mpls.ctl = register_net_sysctl(net, "net/mpls", table);\r\nif (net->mpls.ctl == NULL) {\r\nkfree(table);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpls_net_exit(struct net *net)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nsize_t platform_labels;\r\nstruct ctl_table *table;\r\nunsigned int index;\r\ntable = net->mpls.ctl->ctl_table_arg;\r\nunregister_net_sysctl_table(net->mpls.ctl);\r\nkfree(table);\r\nrtnl_lock();\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nplatform_labels = net->mpls.platform_labels;\r\nfor (index = 0; index < platform_labels; index++) {\r\nstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\r\nRCU_INIT_POINTER(platform_label[index], NULL);\r\nmpls_rt_free(rt);\r\n}\r\nrtnl_unlock();\r\nkvfree(platform_label);\r\n}\r\nstatic int __init mpls_init(void)\r\n{\r\nint err;\r\nBUILD_BUG_ON(sizeof(struct mpls_shim_hdr) != 4);\r\nerr = register_pernet_subsys(&mpls_net_ops);\r\nif (err)\r\ngoto out;\r\nerr = register_netdevice_notifier(&mpls_dev_notifier);\r\nif (err)\r\ngoto out_unregister_pernet;\r\ndev_add_pack(&mpls_packet_type);\r\nrtnl_register(PF_MPLS, RTM_NEWROUTE, mpls_rtm_newroute, NULL, NULL);\r\nrtnl_register(PF_MPLS, RTM_DELROUTE, mpls_rtm_delroute, NULL, NULL);\r\nrtnl_register(PF_MPLS, RTM_GETROUTE, NULL, mpls_dump_routes, NULL);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_unregister_pernet:\r\nunregister_pernet_subsys(&mpls_net_ops);\r\ngoto out;\r\n}\r\nstatic void __exit mpls_exit(void)\r\n{\r\nrtnl_unregister_all(PF_MPLS);\r\ndev_remove_pack(&mpls_packet_type);\r\nunregister_netdevice_notifier(&mpls_dev_notifier);\r\nunregister_pernet_subsys(&mpls_net_ops);\r\n}
