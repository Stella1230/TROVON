static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)\r\n{\r\nif (!gc->parent)\r\nreturn false;\r\nreturn ACPI_HANDLE(gc->parent) == data;\r\n}\r\nstatic int acpi_gpiochip_pin_to_gpio_offset(struct gpio_device *gdev, int pin)\r\n{\r\nstruct gpio_pin_range *pin_range;\r\nif (list_empty(&gdev->pin_ranges))\r\nreturn pin;\r\nlist_for_each_entry(pin_range, &gdev->pin_ranges, node) {\r\nconst struct pinctrl_gpio_range *range = &pin_range->range;\r\nint i;\r\nif (range->pins) {\r\nfor (i = 0; i < range->npins; i++) {\r\nif (range->pins[i] == pin)\r\nreturn range->base + i - gdev->base;\r\n}\r\n} else {\r\nif (pin >= range->pin_base &&\r\npin < range->pin_base + range->npins) {\r\nunsigned gpio_base;\r\ngpio_base = range->base - gdev->base;\r\nreturn gpio_base + pin - range->pin_base;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline int acpi_gpiochip_pin_to_gpio_offset(struct gpio_device *gdev,\r\nint pin)\r\n{\r\nreturn pin;\r\n}\r\nstatic struct gpio_desc *acpi_get_gpiod(char *path, int pin)\r\n{\r\nstruct gpio_chip *chip;\r\nacpi_handle handle;\r\nacpi_status status;\r\nint offset;\r\nstatus = acpi_get_handle(NULL, path, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn ERR_PTR(-ENODEV);\r\nchip = gpiochip_find(handle, acpi_gpiochip_find);\r\nif (!chip)\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\noffset = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);\r\nif (offset < 0)\r\nreturn ERR_PTR(offset);\r\nreturn gpiochip_get_desc(chip, offset);\r\n}\r\nstatic irqreturn_t acpi_gpio_irq_handler(int irq, void *data)\r\n{\r\nstruct acpi_gpio_event *event = data;\r\nacpi_evaluate_object(event->handle, NULL, NULL, NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t acpi_gpio_irq_handler_evt(int irq, void *data)\r\n{\r\nstruct acpi_gpio_event *event = data;\r\nacpi_execute_simple_method(event->handle, NULL, event->pin);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void acpi_gpio_chip_dh(acpi_handle handle, void *data)\r\n{\r\n}\r\nstatic acpi_status acpi_gpiochip_request_interrupt(struct acpi_resource *ares,\r\nvoid *context)\r\n{\r\nstruct acpi_gpio_chip *acpi_gpio = context;\r\nstruct gpio_chip *chip = acpi_gpio->chip;\r\nstruct acpi_resource_gpio *agpio;\r\nacpi_handle handle, evt_handle;\r\nstruct acpi_gpio_event *event;\r\nirq_handler_t handler = NULL;\r\nstruct gpio_desc *desc;\r\nunsigned long irqflags;\r\nint ret, pin, irq;\r\nif (ares->type != ACPI_RESOURCE_TYPE_GPIO)\r\nreturn AE_OK;\r\nagpio = &ares->data.gpio;\r\nif (agpio->connection_type != ACPI_RESOURCE_GPIO_TYPE_INT)\r\nreturn AE_OK;\r\nhandle = ACPI_HANDLE(chip->parent);\r\npin = agpio->pin_table[0];\r\nif (pin <= 255) {\r\nchar ev_name[5];\r\nsprintf(ev_name, "_%c%02X",\r\nagpio->triggering == ACPI_EDGE_SENSITIVE ? 'E' : 'L',\r\npin);\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, ev_name, &evt_handle)))\r\nhandler = acpi_gpio_irq_handler;\r\n}\r\nif (!handler) {\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_EVT", &evt_handle)))\r\nhandler = acpi_gpio_irq_handler_evt;\r\n}\r\nif (!handler)\r\nreturn AE_BAD_PARAMETER;\r\npin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);\r\nif (pin < 0)\r\nreturn AE_BAD_PARAMETER;\r\ndesc = gpiochip_request_own_desc(chip, pin, "ACPI:Event");\r\nif (IS_ERR(desc)) {\r\ndev_err(chip->parent, "Failed to request GPIO\n");\r\nreturn AE_ERROR;\r\n}\r\ngpiod_direction_input(desc);\r\nret = gpiochip_lock_as_irq(chip, pin);\r\nif (ret) {\r\ndev_err(chip->parent, "Failed to lock GPIO as interrupt\n");\r\ngoto fail_free_desc;\r\n}\r\nirq = gpiod_to_irq(desc);\r\nif (irq < 0) {\r\ndev_err(chip->parent, "Failed to translate GPIO to IRQ\n");\r\ngoto fail_unlock_irq;\r\n}\r\nirqflags = IRQF_ONESHOT;\r\nif (agpio->triggering == ACPI_LEVEL_SENSITIVE) {\r\nif (agpio->polarity == ACPI_ACTIVE_HIGH)\r\nirqflags |= IRQF_TRIGGER_HIGH;\r\nelse\r\nirqflags |= IRQF_TRIGGER_LOW;\r\n} else {\r\nswitch (agpio->polarity) {\r\ncase ACPI_ACTIVE_HIGH:\r\nirqflags |= IRQF_TRIGGER_RISING;\r\nbreak;\r\ncase ACPI_ACTIVE_LOW:\r\nirqflags |= IRQF_TRIGGER_FALLING;\r\nbreak;\r\ndefault:\r\nirqflags |= IRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING;\r\nbreak;\r\n}\r\n}\r\nevent = kzalloc(sizeof(*event), GFP_KERNEL);\r\nif (!event)\r\ngoto fail_unlock_irq;\r\nevent->handle = evt_handle;\r\nevent->irq = irq;\r\nevent->pin = pin;\r\nevent->desc = desc;\r\nret = request_threaded_irq(event->irq, NULL, handler, irqflags,\r\n"ACPI:Event", event);\r\nif (ret) {\r\ndev_err(chip->parent,\r\n"Failed to setup interrupt handler for %d\n",\r\nevent->irq);\r\ngoto fail_free_event;\r\n}\r\nlist_add_tail(&event->node, &acpi_gpio->events);\r\nreturn AE_OK;\r\nfail_free_event:\r\nkfree(event);\r\nfail_unlock_irq:\r\ngpiochip_unlock_as_irq(chip, pin);\r\nfail_free_desc:\r\ngpiochip_free_own_desc(desc);\r\nreturn AE_ERROR;\r\n}\r\nvoid acpi_gpiochip_request_interrupts(struct gpio_chip *chip)\r\n{\r\nstruct acpi_gpio_chip *acpi_gpio;\r\nacpi_handle handle;\r\nacpi_status status;\r\nif (!chip->parent || !chip->to_irq)\r\nreturn;\r\nhandle = ACPI_HANDLE(chip->parent);\r\nif (!handle)\r\nreturn;\r\nstatus = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);\r\nif (ACPI_FAILURE(status))\r\nreturn;\r\nacpi_walk_resources(handle, "_AEI",\r\nacpi_gpiochip_request_interrupt, acpi_gpio);\r\n}\r\nvoid acpi_gpiochip_free_interrupts(struct gpio_chip *chip)\r\n{\r\nstruct acpi_gpio_chip *acpi_gpio;\r\nstruct acpi_gpio_event *event, *ep;\r\nacpi_handle handle;\r\nacpi_status status;\r\nif (!chip->parent || !chip->to_irq)\r\nreturn;\r\nhandle = ACPI_HANDLE(chip->parent);\r\nif (!handle)\r\nreturn;\r\nstatus = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);\r\nif (ACPI_FAILURE(status))\r\nreturn;\r\nlist_for_each_entry_safe_reverse(event, ep, &acpi_gpio->events, node) {\r\nstruct gpio_desc *desc;\r\nfree_irq(event->irq, event);\r\ndesc = event->desc;\r\nif (WARN_ON(IS_ERR(desc)))\r\ncontinue;\r\ngpiochip_unlock_as_irq(chip, event->pin);\r\ngpiochip_free_own_desc(desc);\r\nlist_del(&event->node);\r\nkfree(event);\r\n}\r\n}\r\nint acpi_dev_add_driver_gpios(struct acpi_device *adev,\r\nconst struct acpi_gpio_mapping *gpios)\r\n{\r\nif (adev && gpios) {\r\nadev->driver_gpios = gpios;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic bool acpi_get_driver_gpio_data(struct acpi_device *adev,\r\nconst char *name, int index,\r\nstruct acpi_reference_args *args)\r\n{\r\nconst struct acpi_gpio_mapping *gm;\r\nif (!adev->driver_gpios)\r\nreturn false;\r\nfor (gm = adev->driver_gpios; gm->name; gm++)\r\nif (!strcmp(name, gm->name) && gm->data && index < gm->size) {\r\nconst struct acpi_gpio_params *par = gm->data + index;\r\nargs->adev = adev;\r\nargs->args[0] = par->crs_entry_index;\r\nargs->args[1] = par->line_index;\r\nargs->args[2] = par->active_low;\r\nargs->nargs = 3;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int acpi_find_gpio(struct acpi_resource *ares, void *data)\r\n{\r\nstruct acpi_gpio_lookup *lookup = data;\r\nif (ares->type != ACPI_RESOURCE_TYPE_GPIO)\r\nreturn 1;\r\nif (lookup->n++ == lookup->index && !lookup->desc) {\r\nconst struct acpi_resource_gpio *agpio = &ares->data.gpio;\r\nint pin_index = lookup->pin_index;\r\nif (pin_index >= agpio->pin_table_length)\r\nreturn 1;\r\nlookup->desc = acpi_get_gpiod(agpio->resource_source.string_ptr,\r\nagpio->pin_table[pin_index]);\r\nlookup->info.gpioint =\r\nagpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;\r\nif (lookup->info.gpioint) {\r\nlookup->info.polarity = agpio->polarity;\r\nlookup->info.triggering = agpio->triggering;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,\r\nstruct acpi_gpio_info *info)\r\n{\r\nstruct list_head res_list;\r\nint ret;\r\nINIT_LIST_HEAD(&res_list);\r\nret = acpi_dev_get_resources(lookup->adev, &res_list, acpi_find_gpio,\r\nlookup);\r\nif (ret < 0)\r\nreturn ret;\r\nacpi_dev_free_resource_list(&res_list);\r\nif (!lookup->desc)\r\nreturn -ENOENT;\r\nif (info) {\r\n*info = lookup->info;\r\nif (lookup->active_low)\r\ninfo->polarity = lookup->active_low;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_gpio_property_lookup(struct fwnode_handle *fwnode,\r\nconst char *propname, int index,\r\nstruct acpi_gpio_lookup *lookup)\r\n{\r\nstruct acpi_reference_args args;\r\nint ret;\r\nmemset(&args, 0, sizeof(args));\r\nret = acpi_node_get_property_reference(fwnode, propname, index, &args);\r\nif (ret) {\r\nstruct acpi_device *adev = to_acpi_device_node(fwnode);\r\nif (!adev)\r\nreturn ret;\r\nif (!acpi_get_driver_gpio_data(adev, propname, index, &args))\r\nreturn ret;\r\n}\r\nlookup->adev = args.adev;\r\nif (args.nargs >= 2) {\r\nlookup->index = args.args[0];\r\nlookup->pin_index = args.args[1];\r\nif (args.nargs >= 3)\r\nlookup->active_low = !!args.args[2];\r\n}\r\nreturn 0;\r\n}\r\nstruct gpio_desc *acpi_get_gpiod_by_index(struct acpi_device *adev,\r\nconst char *propname, int index,\r\nstruct acpi_gpio_info *info)\r\n{\r\nstruct acpi_gpio_lookup lookup;\r\nint ret;\r\nif (!adev)\r\nreturn ERR_PTR(-ENODEV);\r\nmemset(&lookup, 0, sizeof(lookup));\r\nlookup.index = index;\r\nif (propname) {\r\ndev_dbg(&adev->dev, "GPIO: looking up %s\n", propname);\r\nret = acpi_gpio_property_lookup(acpi_fwnode_handle(adev),\r\npropname, index, &lookup);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ndev_dbg(&adev->dev, "GPIO: _DSD returned %s %d %d %u\n",\r\ndev_name(&lookup.adev->dev), lookup.index,\r\nlookup.pin_index, lookup.active_low);\r\n} else {\r\ndev_dbg(&adev->dev, "GPIO: looking up %d in _CRS\n", index);\r\nlookup.adev = adev;\r\n}\r\nret = acpi_gpio_resource_lookup(&lookup, info);\r\nreturn ret ? ERR_PTR(ret) : lookup.desc;\r\n}\r\nstruct gpio_desc *acpi_node_get_gpiod(struct fwnode_handle *fwnode,\r\nconst char *propname, int index,\r\nstruct acpi_gpio_info *info)\r\n{\r\nstruct acpi_gpio_lookup lookup;\r\nstruct acpi_device *adev;\r\nint ret;\r\nadev = to_acpi_device_node(fwnode);\r\nif (adev)\r\nreturn acpi_get_gpiod_by_index(adev, propname, index, info);\r\nif (!is_acpi_data_node(fwnode))\r\nreturn ERR_PTR(-ENODEV);\r\nif (!propname)\r\nreturn ERR_PTR(-EINVAL);\r\nmemset(&lookup, 0, sizeof(lookup));\r\nlookup.index = index;\r\nret = acpi_gpio_property_lookup(fwnode, propname, index, &lookup);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nret = acpi_gpio_resource_lookup(&lookup, info);\r\nreturn ret ? ERR_PTR(ret) : lookup.desc;\r\n}\r\nint acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)\r\n{\r\nint idx, i;\r\nunsigned int irq_flags;\r\nfor (i = 0, idx = 0; idx <= index; i++) {\r\nstruct acpi_gpio_info info;\r\nstruct gpio_desc *desc;\r\ndesc = acpi_get_gpiod_by_index(adev, NULL, i, &info);\r\nif (IS_ERR(desc))\r\nbreak;\r\nif (info.gpioint && idx++ == index) {\r\nint irq = gpiod_to_irq(desc);\r\nif (irq < 0)\r\nreturn irq;\r\nirq_flags = acpi_dev_get_irq_type(info.triggering,\r\ninfo.polarity);\r\nif (irq_flags != IRQ_TYPE_NONE &&\r\nirq_flags != irq_get_trigger_type(irq))\r\nirq_set_irq_type(irq, irq_flags);\r\nreturn irq;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic acpi_status\r\nacpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,\r\nu32 bits, u64 *value, void *handler_context,\r\nvoid *region_context)\r\n{\r\nstruct acpi_gpio_chip *achip = region_context;\r\nstruct gpio_chip *chip = achip->chip;\r\nstruct acpi_resource_gpio *agpio;\r\nstruct acpi_resource *ares;\r\nint pin_index = (int)address;\r\nacpi_status status;\r\nbool pull_up;\r\nint length;\r\nint i;\r\nstatus = acpi_buffer_to_resource(achip->conn_info.connection,\r\nachip->conn_info.length, &ares);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nif (WARN_ON(ares->type != ACPI_RESOURCE_TYPE_GPIO)) {\r\nACPI_FREE(ares);\r\nreturn AE_BAD_PARAMETER;\r\n}\r\nagpio = &ares->data.gpio;\r\npull_up = agpio->pin_config == ACPI_PIN_CONFIG_PULLUP;\r\nif (WARN_ON(agpio->io_restriction == ACPI_IO_RESTRICT_INPUT &&\r\nfunction == ACPI_WRITE)) {\r\nACPI_FREE(ares);\r\nreturn AE_BAD_PARAMETER;\r\n}\r\nlength = min(agpio->pin_table_length, (u16)(pin_index + bits));\r\nfor (i = pin_index; i < length; ++i) {\r\nint pin = agpio->pin_table[i];\r\nstruct acpi_gpio_connection *conn;\r\nstruct gpio_desc *desc;\r\nbool found;\r\npin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);\r\nif (pin < 0) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto out;\r\n}\r\nmutex_lock(&achip->conn_lock);\r\nfound = false;\r\nlist_for_each_entry(conn, &achip->conns, node) {\r\nif (conn->pin == pin) {\r\nfound = true;\r\ndesc = conn->desc;\r\nbreak;\r\n}\r\n}\r\nif (!found && agpio->sharable == ACPI_SHARED &&\r\nfunction == ACPI_READ) {\r\nstruct acpi_gpio_event *event;\r\nlist_for_each_entry(event, &achip->events, node) {\r\nif (event->pin == pin) {\r\ndesc = event->desc;\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!found) {\r\ndesc = gpiochip_request_own_desc(chip, pin,\r\n"ACPI:OpRegion");\r\nif (IS_ERR(desc)) {\r\nstatus = AE_ERROR;\r\nmutex_unlock(&achip->conn_lock);\r\ngoto out;\r\n}\r\nswitch (agpio->io_restriction) {\r\ncase ACPI_IO_RESTRICT_INPUT:\r\ngpiod_direction_input(desc);\r\nbreak;\r\ncase ACPI_IO_RESTRICT_OUTPUT:\r\ngpiod_direction_output(desc, pull_up);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nconn = kzalloc(sizeof(*conn), GFP_KERNEL);\r\nif (!conn) {\r\nstatus = AE_NO_MEMORY;\r\ngpiochip_free_own_desc(desc);\r\nmutex_unlock(&achip->conn_lock);\r\ngoto out;\r\n}\r\nconn->pin = pin;\r\nconn->desc = desc;\r\nlist_add_tail(&conn->node, &achip->conns);\r\n}\r\nmutex_unlock(&achip->conn_lock);\r\nif (function == ACPI_WRITE)\r\ngpiod_set_raw_value_cansleep(desc,\r\n!!((1 << i) & *value));\r\nelse\r\n*value |= (u64)gpiod_get_raw_value_cansleep(desc) << i;\r\n}\r\nout:\r\nACPI_FREE(ares);\r\nreturn status;\r\n}\r\nstatic void acpi_gpiochip_request_regions(struct acpi_gpio_chip *achip)\r\n{\r\nstruct gpio_chip *chip = achip->chip;\r\nacpi_handle handle = ACPI_HANDLE(chip->parent);\r\nacpi_status status;\r\nINIT_LIST_HEAD(&achip->conns);\r\nmutex_init(&achip->conn_lock);\r\nstatus = acpi_install_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,\r\nacpi_gpio_adr_space_handler,\r\nNULL, achip);\r\nif (ACPI_FAILURE(status))\r\ndev_err(chip->parent,\r\n"Failed to install GPIO OpRegion handler\n");\r\n}\r\nstatic void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)\r\n{\r\nstruct gpio_chip *chip = achip->chip;\r\nacpi_handle handle = ACPI_HANDLE(chip->parent);\r\nstruct acpi_gpio_connection *conn, *tmp;\r\nacpi_status status;\r\nstatus = acpi_remove_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,\r\nacpi_gpio_adr_space_handler);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(chip->parent,\r\n"Failed to remove GPIO OpRegion handler\n");\r\nreturn;\r\n}\r\nlist_for_each_entry_safe_reverse(conn, tmp, &achip->conns, node) {\r\ngpiochip_free_own_desc(conn->desc);\r\nlist_del(&conn->node);\r\nkfree(conn);\r\n}\r\n}\r\nvoid acpi_gpiochip_add(struct gpio_chip *chip)\r\n{\r\nstruct acpi_gpio_chip *acpi_gpio;\r\nacpi_handle handle;\r\nacpi_status status;\r\nif (!chip || !chip->parent)\r\nreturn;\r\nhandle = ACPI_HANDLE(chip->parent);\r\nif (!handle)\r\nreturn;\r\nacpi_gpio = kzalloc(sizeof(*acpi_gpio), GFP_KERNEL);\r\nif (!acpi_gpio) {\r\ndev_err(chip->parent,\r\n"Failed to allocate memory for ACPI GPIO chip\n");\r\nreturn;\r\n}\r\nacpi_gpio->chip = chip;\r\nINIT_LIST_HEAD(&acpi_gpio->events);\r\nstatus = acpi_attach_data(handle, acpi_gpio_chip_dh, acpi_gpio);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(chip->parent, "Failed to attach ACPI GPIO chip\n");\r\nkfree(acpi_gpio);\r\nreturn;\r\n}\r\nacpi_gpiochip_request_regions(acpi_gpio);\r\n}\r\nvoid acpi_gpiochip_remove(struct gpio_chip *chip)\r\n{\r\nstruct acpi_gpio_chip *acpi_gpio;\r\nacpi_handle handle;\r\nacpi_status status;\r\nif (!chip || !chip->parent)\r\nreturn;\r\nhandle = ACPI_HANDLE(chip->parent);\r\nif (!handle)\r\nreturn;\r\nstatus = acpi_get_data(handle, acpi_gpio_chip_dh, (void **)&acpi_gpio);\r\nif (ACPI_FAILURE(status)) {\r\ndev_warn(chip->parent, "Failed to retrieve ACPI GPIO chip\n");\r\nreturn;\r\n}\r\nacpi_gpiochip_free_regions(acpi_gpio);\r\nacpi_detach_data(handle, acpi_gpio_chip_dh);\r\nkfree(acpi_gpio);\r\n}\r\nstatic unsigned int acpi_gpio_package_count(const union acpi_object *obj)\r\n{\r\nconst union acpi_object *element = obj->package.elements;\r\nconst union acpi_object *end = element + obj->package.count;\r\nunsigned int count = 0;\r\nwhile (element < end) {\r\nif (element->type == ACPI_TYPE_LOCAL_REFERENCE)\r\ncount++;\r\nelement++;\r\n}\r\nreturn count;\r\n}\r\nstatic int acpi_find_gpio_count(struct acpi_resource *ares, void *data)\r\n{\r\nunsigned int *count = data;\r\nif (ares->type == ACPI_RESOURCE_TYPE_GPIO)\r\n*count += ares->data.gpio.pin_table_length;\r\nreturn 1;\r\n}\r\nint acpi_gpio_count(struct device *dev, const char *con_id)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nconst union acpi_object *obj;\r\nconst struct acpi_gpio_mapping *gm;\r\nint count = -ENOENT;\r\nint ret;\r\nchar propname[32];\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {\r\nif (con_id && strcmp(con_id, "gpios"))\r\nsnprintf(propname, sizeof(propname), "%s-%s",\r\ncon_id, gpio_suffixes[i]);\r\nelse\r\nsnprintf(propname, sizeof(propname), "%s",\r\ngpio_suffixes[i]);\r\nret = acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,\r\n&obj);\r\nif (ret == 0) {\r\nif (obj->type == ACPI_TYPE_LOCAL_REFERENCE)\r\ncount = 1;\r\nelse if (obj->type == ACPI_TYPE_PACKAGE)\r\ncount = acpi_gpio_package_count(obj);\r\n} else if (adev->driver_gpios) {\r\nfor (gm = adev->driver_gpios; gm->name; gm++)\r\nif (strcmp(propname, gm->name) == 0) {\r\ncount = gm->size;\r\nbreak;\r\n}\r\n}\r\nif (count >= 0)\r\nbreak;\r\n}\r\nif (count < 0) {\r\nstruct list_head resource_list;\r\nunsigned int crs_count = 0;\r\nINIT_LIST_HEAD(&resource_list);\r\nacpi_dev_get_resources(adev, &resource_list,\r\nacpi_find_gpio_count, &crs_count);\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (crs_count > 0)\r\ncount = crs_count;\r\n}\r\nreturn count;\r\n}\r\nbool acpi_can_fallback_to_crs(struct acpi_device *adev, const char *con_id)\r\n{\r\nstruct acpi_crs_lookup *l, *lookup = NULL;\r\nif (adev->data.properties || adev->driver_gpios)\r\nreturn false;\r\nmutex_lock(&acpi_crs_lookup_lock);\r\nlist_for_each_entry(l, &acpi_crs_lookup_list, node) {\r\nif (l->adev == adev) {\r\nlookup = l;\r\nbreak;\r\n}\r\n}\r\nif (!lookup) {\r\nlookup = kmalloc(sizeof(*lookup), GFP_KERNEL);\r\nif (lookup) {\r\nlookup->adev = adev;\r\nlookup->con_id = kstrdup(con_id, GFP_KERNEL);\r\nlist_add_tail(&lookup->node, &acpi_crs_lookup_list);\r\n}\r\n}\r\nmutex_unlock(&acpi_crs_lookup_lock);\r\nreturn lookup &&\r\n((!lookup->con_id && !con_id) ||\r\n(lookup->con_id && con_id &&\r\nstrcmp(lookup->con_id, con_id) == 0));\r\n}
