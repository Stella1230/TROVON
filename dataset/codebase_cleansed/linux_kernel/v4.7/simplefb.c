static int simplefb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nu32 *pal = info->pseudo_palette;\r\nu32 cr = red >> (16 - info->var.red.length);\r\nu32 cg = green >> (16 - info->var.green.length);\r\nu32 cb = blue >> (16 - info->var.blue.length);\r\nu32 value;\r\nif (regno >= PSEUDO_PALETTE_SIZE)\r\nreturn -EINVAL;\r\nvalue = (cr << info->var.red.offset) |\r\n(cg << info->var.green.offset) |\r\n(cb << info->var.blue.offset);\r\nif (info->var.transp.length > 0) {\r\nu32 mask = (1 << info->var.transp.length) - 1;\r\nmask <<= info->var.transp.offset;\r\nvalue |= mask;\r\n}\r\npal[regno] = value;\r\nreturn 0;\r\n}\r\nstatic void simplefb_destroy(struct fb_info *info)\r\n{\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\n}\r\nstatic int simplefb_parse_dt(struct platform_device *pdev,\r\nstruct simplefb_params *params)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nconst char *format;\r\nint i;\r\nret = of_property_read_u32(np, "width", &params->width);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't parse width property\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "height", &params->height);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't parse height property\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "stride", &params->stride);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't parse stride property\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_string(np, "format", &format);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't parse format property\n");\r\nreturn ret;\r\n}\r\nparams->format = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(simplefb_formats); i++) {\r\nif (strcmp(format, simplefb_formats[i].name))\r\ncontinue;\r\nparams->format = &simplefb_formats[i];\r\nbreak;\r\n}\r\nif (!params->format) {\r\ndev_err(&pdev->dev, "Invalid format value\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int simplefb_parse_pd(struct platform_device *pdev,\r\nstruct simplefb_params *params)\r\n{\r\nstruct simplefb_platform_data *pd = dev_get_platdata(&pdev->dev);\r\nint i;\r\nparams->width = pd->width;\r\nparams->height = pd->height;\r\nparams->stride = pd->stride;\r\nparams->format = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(simplefb_formats); i++) {\r\nif (strcmp(pd->format, simplefb_formats[i].name))\r\ncontinue;\r\nparams->format = &simplefb_formats[i];\r\nbreak;\r\n}\r\nif (!params->format) {\r\ndev_err(&pdev->dev, "Invalid format value\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int simplefb_clocks_init(struct simplefb_par *par,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct clk *clock;\r\nint i, ret;\r\nif (dev_get_platdata(&pdev->dev) || !np)\r\nreturn 0;\r\npar->clk_count = of_clk_get_parent_count(np);\r\nif (!par->clk_count)\r\nreturn 0;\r\npar->clks = kcalloc(par->clk_count, sizeof(struct clk *), GFP_KERNEL);\r\nif (!par->clks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < par->clk_count; i++) {\r\nclock = of_clk_get(np, i);\r\nif (IS_ERR(clock)) {\r\nif (PTR_ERR(clock) == -EPROBE_DEFER) {\r\nwhile (--i >= 0) {\r\nif (par->clks[i])\r\nclk_put(par->clks[i]);\r\n}\r\nkfree(par->clks);\r\nreturn -EPROBE_DEFER;\r\n}\r\ndev_err(&pdev->dev, "%s: clock %d not found: %ld\n",\r\n__func__, i, PTR_ERR(clock));\r\ncontinue;\r\n}\r\npar->clks[i] = clock;\r\n}\r\nfor (i = 0; i < par->clk_count; i++) {\r\nif (par->clks[i]) {\r\nret = clk_prepare_enable(par->clks[i]);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"%s: failed to enable clock %d: %d\n",\r\n__func__, i, ret);\r\nclk_put(par->clks[i]);\r\npar->clks[i] = NULL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void simplefb_clocks_destroy(struct simplefb_par *par)\r\n{\r\nint i;\r\nif (!par->clks)\r\nreturn;\r\nfor (i = 0; i < par->clk_count; i++) {\r\nif (par->clks[i]) {\r\nclk_disable_unprepare(par->clks[i]);\r\nclk_put(par->clks[i]);\r\n}\r\n}\r\nkfree(par->clks);\r\n}\r\nstatic int simplefb_clocks_init(struct simplefb_par *par,\r\nstruct platform_device *pdev) { return 0; }\r\nstatic void simplefb_clocks_destroy(struct simplefb_par *par) { }\r\nstatic int simplefb_regulators_init(struct simplefb_par *par,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct property *prop;\r\nstruct regulator *regulator;\r\nconst char *p;\r\nint count = 0, i = 0, ret;\r\nif (dev_get_platdata(&pdev->dev) || !np)\r\nreturn 0;\r\nfor_each_property_of_node(np, prop) {\r\np = strstr(prop->name, SUPPLY_SUFFIX);\r\nif (p && p != prop->name)\r\ncount++;\r\n}\r\nif (!count)\r\nreturn 0;\r\npar->regulators = devm_kcalloc(&pdev->dev, count,\r\nsizeof(struct regulator *), GFP_KERNEL);\r\nif (!par->regulators)\r\nreturn -ENOMEM;\r\nfor_each_property_of_node(np, prop) {\r\nchar name[32];\r\np = strstr(prop->name, SUPPLY_SUFFIX);\r\nif (!p || p == prop->name)\r\ncontinue;\r\nstrlcpy(name, prop->name,\r\nstrlen(prop->name) - strlen(SUPPLY_SUFFIX) + 1);\r\nregulator = devm_regulator_get_optional(&pdev->dev, name);\r\nif (IS_ERR(regulator)) {\r\nif (PTR_ERR(regulator) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_err(&pdev->dev, "regulator %s not found: %ld\n",\r\nname, PTR_ERR(regulator));\r\ncontinue;\r\n}\r\npar->regulators[i++] = regulator;\r\n}\r\npar->regulator_count = i;\r\nfor (i = 0; i < par->regulator_count; i++) {\r\nret = regulator_enable(par->regulators[i]);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to enable regulator %d: %d\n",\r\ni, ret);\r\ndevm_regulator_put(par->regulators[i]);\r\npar->regulators[i] = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void simplefb_regulators_destroy(struct simplefb_par *par)\r\n{\r\nint i;\r\nif (!par->regulators)\r\nreturn;\r\nfor (i = 0; i < par->regulator_count; i++)\r\nif (par->regulators[i])\r\nregulator_disable(par->regulators[i]);\r\n}\r\nstatic int simplefb_regulators_init(struct simplefb_par *par,\r\nstruct platform_device *pdev) { return 0; }\r\nstatic void simplefb_regulators_destroy(struct simplefb_par *par) { }\r\nstatic int simplefb_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct simplefb_params params;\r\nstruct fb_info *info;\r\nstruct simplefb_par *par;\r\nstruct resource *mem;\r\nif (fb_get_options("simplefb", NULL))\r\nreturn -ENODEV;\r\nret = -ENODEV;\r\nif (dev_get_platdata(&pdev->dev))\r\nret = simplefb_parse_pd(pdev, &params);\r\nelse if (pdev->dev.of_node)\r\nret = simplefb_parse_dt(pdev, &params);\r\nif (ret)\r\nreturn ret;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "No memory resource\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct simplefb_par), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, info);\r\npar = info->par;\r\ninfo->fix = simplefb_fix;\r\ninfo->fix.smem_start = mem->start;\r\ninfo->fix.smem_len = resource_size(mem);\r\ninfo->fix.line_length = params.stride;\r\ninfo->var = simplefb_var;\r\ninfo->var.xres = params.width;\r\ninfo->var.yres = params.height;\r\ninfo->var.xres_virtual = params.width;\r\ninfo->var.yres_virtual = params.height;\r\ninfo->var.bits_per_pixel = params.format->bits_per_pixel;\r\ninfo->var.red = params.format->red;\r\ninfo->var.green = params.format->green;\r\ninfo->var.blue = params.format->blue;\r\ninfo->var.transp = params.format->transp;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto error_fb_release;\r\n}\r\ninfo->apertures->ranges[0].base = info->fix.smem_start;\r\ninfo->apertures->ranges[0].size = info->fix.smem_len;\r\ninfo->fbops = &simplefb_ops;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_MISC_FIRMWARE;\r\ninfo->screen_base = ioremap_wc(info->fix.smem_start,\r\ninfo->fix.smem_len);\r\nif (!info->screen_base) {\r\nret = -ENOMEM;\r\ngoto error_fb_release;\r\n}\r\ninfo->pseudo_palette = par->palette;\r\nret = simplefb_clocks_init(par, pdev);\r\nif (ret < 0)\r\ngoto error_unmap;\r\nret = simplefb_regulators_init(par, pdev);\r\nif (ret < 0)\r\ngoto error_clocks;\r\ndev_info(&pdev->dev, "framebuffer at 0x%lx, 0x%x bytes, mapped to 0x%p\n",\r\ninfo->fix.smem_start, info->fix.smem_len,\r\ninfo->screen_base);\r\ndev_info(&pdev->dev, "format=%s, mode=%dx%dx%d, linelength=%d\n",\r\nparams.format->name,\r\ninfo->var.xres, info->var.yres,\r\ninfo->var.bits_per_pixel, info->fix.line_length);\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Unable to register simplefb: %d\n", ret);\r\ngoto error_regulators;\r\n}\r\ndev_info(&pdev->dev, "fb%d: simplefb registered!\n", info->node);\r\nreturn 0;\r\nerror_regulators:\r\nsimplefb_regulators_destroy(par);\r\nerror_clocks:\r\nsimplefb_clocks_destroy(par);\r\nerror_unmap:\r\niounmap(info->screen_base);\r\nerror_fb_release:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int simplefb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct simplefb_par *par = info->par;\r\nunregister_framebuffer(info);\r\nsimplefb_regulators_destroy(par);\r\nsimplefb_clocks_destroy(par);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int __init simplefb_init(void)\r\n{\r\nint ret;\r\nstruct device_node *np;\r\nret = platform_driver_register(&simplefb_driver);\r\nif (ret)\r\nreturn ret;\r\nif (IS_ENABLED(CONFIG_OF_ADDRESS) && of_chosen) {\r\nfor_each_child_of_node(of_chosen, np) {\r\nif (of_device_is_compatible(np, "simple-framebuffer"))\r\nof_platform_device_create(np, NULL, NULL);\r\n}\r\n}\r\nreturn 0;\r\n}
