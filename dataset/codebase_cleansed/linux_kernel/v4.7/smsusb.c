static void do_submit_urb(struct work_struct *work)\r\n{\r\nstruct smsusb_urb_t *surb = container_of(work, struct smsusb_urb_t, wq);\r\nstruct smsusb_device_t *dev = surb->dev;\r\nsmsusb_submit_urb(dev, surb);\r\n}\r\nstatic void smsusb_onresponse(struct urb *urb)\r\n{\r\nstruct smsusb_urb_t *surb = (struct smsusb_urb_t *) urb->context;\r\nstruct smsusb_device_t *dev = surb->dev;\r\nif (urb->status == -ESHUTDOWN) {\r\npr_err("error, urb status %d (-ESHUTDOWN), %d bytes\n",\r\nurb->status, urb->actual_length);\r\nreturn;\r\n}\r\nif ((urb->actual_length > 0) && (urb->status == 0)) {\r\nstruct sms_msg_hdr *phdr = (struct sms_msg_hdr *)surb->cb->p;\r\nsmsendian_handle_message_header(phdr);\r\nif (urb->actual_length >= phdr->msg_length) {\r\nsurb->cb->size = phdr->msg_length;\r\nif (dev->response_alignment &&\r\n(phdr->msg_flags & MSG_HDR_FLAG_SPLIT_MSG)) {\r\nsurb->cb->offset =\r\ndev->response_alignment +\r\n((phdr->msg_flags >> 8) & 3);\r\nif (((int) phdr->msg_length +\r\nsurb->cb->offset) > urb->actual_length) {\r\npr_err("invalid response msglen %d offset %d size %d\n",\r\nphdr->msg_length,\r\nsurb->cb->offset,\r\nurb->actual_length);\r\ngoto exit_and_resubmit;\r\n}\r\nmemcpy((char *) phdr + surb->cb->offset,\r\nphdr, sizeof(struct sms_msg_hdr));\r\n} else\r\nsurb->cb->offset = 0;\r\npr_debug("received %s(%d) size: %d\n",\r\nsmscore_translate_msg(phdr->msg_type),\r\nphdr->msg_type, phdr->msg_length);\r\nsmsendian_handle_rx_message((struct sms_msg_data *) phdr);\r\nsmscore_onresponse(dev->coredev, surb->cb);\r\nsurb->cb = NULL;\r\n} else {\r\npr_err("invalid response msglen %d actual %d\n",\r\nphdr->msg_length, urb->actual_length);\r\n}\r\n} else\r\npr_err("error, urb status %d, %d bytes\n",\r\nurb->status, urb->actual_length);\r\nexit_and_resubmit:\r\nINIT_WORK(&surb->wq, do_submit_urb);\r\nschedule_work(&surb->wq);\r\n}\r\nstatic int smsusb_submit_urb(struct smsusb_device_t *dev,\r\nstruct smsusb_urb_t *surb)\r\n{\r\nif (!surb->cb) {\r\nsurb->cb = smscore_getbuffer(dev->coredev);\r\nif (!surb->cb) {\r\npr_err("smscore_getbuffer(...) returned NULL\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nusb_fill_bulk_urb(\r\n&surb->urb,\r\ndev->udev,\r\nusb_rcvbulkpipe(dev->udev, dev->in_ep),\r\nsurb->cb->p,\r\ndev->buffer_size,\r\nsmsusb_onresponse,\r\nsurb\r\n);\r\nsurb->urb.transfer_dma = surb->cb->phys;\r\nsurb->urb.transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nreturn usb_submit_urb(&surb->urb, GFP_ATOMIC);\r\n}\r\nstatic void smsusb_stop_streaming(struct smsusb_device_t *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_URBS; i++) {\r\nusb_kill_urb(&dev->surbs[i].urb);\r\nif (dev->surbs[i].cb) {\r\nsmscore_putbuffer(dev->coredev, dev->surbs[i].cb);\r\ndev->surbs[i].cb = NULL;\r\n}\r\n}\r\n}\r\nstatic int smsusb_start_streaming(struct smsusb_device_t *dev)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < MAX_URBS; i++) {\r\nrc = smsusb_submit_urb(dev, &dev->surbs[i]);\r\nif (rc < 0) {\r\npr_err("smsusb_submit_urb(...) failed\n");\r\nsmsusb_stop_streaming(dev);\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int smsusb_sendrequest(void *context, void *buffer, size_t size)\r\n{\r\nstruct smsusb_device_t *dev = (struct smsusb_device_t *) context;\r\nstruct sms_msg_hdr *phdr = (struct sms_msg_hdr *) buffer;\r\nint dummy;\r\nif (dev->state != SMSUSB_ACTIVE) {\r\npr_debug("Device not active yet\n");\r\nreturn -ENOENT;\r\n}\r\npr_debug("sending %s(%d) size: %d\n",\r\nsmscore_translate_msg(phdr->msg_type), phdr->msg_type,\r\nphdr->msg_length);\r\nsmsendian_handle_tx_message((struct sms_msg_data *) phdr);\r\nsmsendian_handle_message_header((struct sms_msg_hdr *)buffer);\r\nreturn usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 2),\r\nbuffer, size, &dummy, 1000);\r\n}\r\nstatic inline char *sms_get_fw_name(int mode, int board_id)\r\n{\r\nchar **fw = sms_get_board(board_id)->fw;\r\nreturn (fw && fw[mode]) ? fw[mode] : smsusb1_fw_lkup[mode];\r\n}\r\nstatic int smsusb1_load_firmware(struct usb_device *udev, int id, int board_id)\r\n{\r\nconst struct firmware *fw;\r\nu8 *fw_buffer;\r\nint rc, dummy;\r\nchar *fw_filename;\r\nif (id < 0)\r\nid = sms_get_board(board_id)->default_mode;\r\nif (id < DEVICE_MODE_DVBT || id > DEVICE_MODE_DVBT_BDA) {\r\npr_err("invalid firmware id specified %d\n", id);\r\nreturn -EINVAL;\r\n}\r\nfw_filename = sms_get_fw_name(id, board_id);\r\nrc = request_firmware(&fw, fw_filename, &udev->dev);\r\nif (rc < 0) {\r\npr_warn("failed to open '%s' mode %d, trying again with default firmware\n",\r\nfw_filename, id);\r\nfw_filename = smsusb1_fw_lkup[id];\r\nrc = request_firmware(&fw, fw_filename, &udev->dev);\r\nif (rc < 0) {\r\npr_warn("failed to open '%s' mode %d\n",\r\nfw_filename, id);\r\nreturn rc;\r\n}\r\n}\r\nfw_buffer = kmalloc(fw->size, GFP_KERNEL);\r\nif (fw_buffer) {\r\nmemcpy(fw_buffer, fw->data, fw->size);\r\nrc = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 2),\r\nfw_buffer, fw->size, &dummy, 1000);\r\npr_debug("sent %zu(%d) bytes, rc %d\n", fw->size, dummy, rc);\r\nkfree(fw_buffer);\r\n} else {\r\npr_err("failed to allocate firmware buffer\n");\r\nrc = -ENOMEM;\r\n}\r\npr_debug("read FW %s, size=%zu\n", fw_filename, fw->size);\r\nrelease_firmware(fw);\r\nreturn rc;\r\n}\r\nstatic void smsusb1_detectmode(void *context, int *mode)\r\n{\r\nchar *product_string =\r\n((struct smsusb_device_t *) context)->udev->product;\r\n*mode = DEVICE_MODE_NONE;\r\nif (!product_string) {\r\nproduct_string = "none";\r\npr_err("product string not found\n");\r\n} else if (strstr(product_string, "DVBH"))\r\n*mode = 1;\r\nelse if (strstr(product_string, "BDA"))\r\n*mode = 4;\r\nelse if (strstr(product_string, "DVBT"))\r\n*mode = 0;\r\nelse if (strstr(product_string, "TDMB"))\r\n*mode = 2;\r\npr_debug("%d \"%s\"\n", *mode, product_string);\r\n}\r\nstatic int smsusb1_setmode(void *context, int mode)\r\n{\r\nstruct sms_msg_hdr msg = { MSG_SW_RELOAD_REQ, 0, HIF_TASK,\r\nsizeof(struct sms_msg_hdr), 0 };\r\nif (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_DVBT_BDA) {\r\npr_err("invalid firmware id specified %d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nreturn smsusb_sendrequest(context, &msg, sizeof(msg));\r\n}\r\nstatic void smsusb_term_device(struct usb_interface *intf)\r\n{\r\nstruct smsusb_device_t *dev = usb_get_intfdata(intf);\r\nif (dev) {\r\ndev->state = SMSUSB_DISCONNECTED;\r\nsmsusb_stop_streaming(dev);\r\nif (dev->coredev)\r\nsmscore_unregister_device(dev->coredev);\r\npr_debug("device 0x%p destroyed\n", dev);\r\nkfree(dev);\r\n}\r\nusb_set_intfdata(intf, NULL);\r\n}\r\nstatic void *siano_media_device_register(struct smsusb_device_t *dev,\r\nint board_id)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nstruct media_device *mdev;\r\nstruct usb_device *udev = dev->udev;\r\nstruct sms_board *board = sms_get_board(board_id);\r\nint ret;\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn NULL;\r\nmedia_device_usb_init(mdev, udev, board->name);\r\nret = media_device_register(mdev);\r\nif (ret) {\r\nmedia_device_cleanup(mdev);\r\nkfree(mdev);\r\nreturn NULL;\r\n}\r\npr_info("media controller created\n");\r\nreturn mdev;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nstatic int smsusb_init_device(struct usb_interface *intf, int board_id)\r\n{\r\nstruct smsdevice_params_t params;\r\nstruct smsusb_device_t *dev;\r\nvoid *mdev;\r\nint i, rc;\r\ndev = kzalloc(sizeof(struct smsusb_device_t), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nmemset(&params, 0, sizeof(params));\r\nusb_set_intfdata(intf, dev);\r\ndev->udev = interface_to_usbdev(intf);\r\ndev->state = SMSUSB_DISCONNECTED;\r\nparams.device_type = sms_get_board(board_id)->type;\r\nswitch (params.device_type) {\r\ncase SMS_STELLAR:\r\ndev->buffer_size = USB1_BUFFER_SIZE;\r\nparams.setmode_handler = smsusb1_setmode;\r\nparams.detectmode_handler = smsusb1_detectmode;\r\nbreak;\r\ncase SMS_UNKNOWN_TYPE:\r\npr_err("Unspecified sms device type!\n");\r\ndefault:\r\ndev->buffer_size = USB2_BUFFER_SIZE;\r\ndev->response_alignment =\r\nle16_to_cpu(dev->udev->ep_in[1]->desc.wMaxPacketSize) -\r\nsizeof(struct sms_msg_hdr);\r\nparams.flags |= SMS_DEVICE_FAMILY2;\r\nbreak;\r\n}\r\nfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\r\nif (intf->cur_altsetting->endpoint[i].desc. bEndpointAddress & USB_DIR_IN)\r\ndev->in_ep = intf->cur_altsetting->endpoint[i].desc.bEndpointAddress;\r\nelse\r\ndev->out_ep = intf->cur_altsetting->endpoint[i].desc.bEndpointAddress;\r\n}\r\npr_debug("in_ep = %02x, out_ep = %02x\n",\r\ndev->in_ep, dev->out_ep);\r\nparams.device = &dev->udev->dev;\r\nparams.buffer_size = dev->buffer_size;\r\nparams.num_buffers = MAX_BUFFERS;\r\nparams.sendrequest_handler = smsusb_sendrequest;\r\nparams.context = dev;\r\nusb_make_path(dev->udev, params.devpath, sizeof(params.devpath));\r\nmdev = siano_media_device_register(dev, board_id);\r\nrc = smscore_register_device(&params, &dev->coredev, mdev);\r\nif (rc < 0) {\r\npr_err("smscore_register_device(...) failed, rc %d\n", rc);\r\nsmsusb_term_device(intf);\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nmedia_device_unregister(mdev);\r\n#endif\r\nkfree(mdev);\r\nreturn rc;\r\n}\r\nsmscore_set_board_id(dev->coredev, board_id);\r\ndev->coredev->is_usb_device = true;\r\nfor (i = 0; i < MAX_URBS; i++) {\r\ndev->surbs[i].dev = dev;\r\nusb_init_urb(&dev->surbs[i].urb);\r\n}\r\npr_debug("smsusb_start_streaming(...).\n");\r\nrc = smsusb_start_streaming(dev);\r\nif (rc < 0) {\r\npr_err("smsusb_start_streaming(...) failed\n");\r\nsmsusb_term_device(intf);\r\nreturn rc;\r\n}\r\ndev->state = SMSUSB_ACTIVE;\r\nrc = smscore_start_device(dev->coredev);\r\nif (rc < 0) {\r\npr_err("smscore_start_device(...) failed\n");\r\nsmsusb_term_device(intf);\r\nreturn rc;\r\n}\r\npr_debug("device 0x%p created\n", dev);\r\nreturn rc;\r\n}\r\nstatic int smsusb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nchar devpath[32];\r\nint i, rc;\r\npr_info("board id=%lu, interface number %d\n",\r\nid->driver_info,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (sms_get_board(id->driver_info)->intf_num !=\r\nintf->cur_altsetting->desc.bInterfaceNumber) {\r\npr_debug("interface %d won't be used. Expecting interface %d to popup\n",\r\nintf->cur_altsetting->desc.bInterfaceNumber,\r\nsms_get_board(id->driver_info)->intf_num);\r\nreturn -ENODEV;\r\n}\r\nif (intf->num_altsetting > 1) {\r\nrc = usb_set_interface(udev,\r\nintf->cur_altsetting->desc.bInterfaceNumber,\r\n0);\r\nif (rc < 0) {\r\npr_err("usb_set_interface failed, rc %d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\npr_debug("smsusb_probe %d\n",\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\r\npr_debug("endpoint %d %02x %02x %d\n", i,\r\nintf->cur_altsetting->endpoint[i].desc.bEndpointAddress,\r\nintf->cur_altsetting->endpoint[i].desc.bmAttributes,\r\nintf->cur_altsetting->endpoint[i].desc.wMaxPacketSize);\r\nif (intf->cur_altsetting->endpoint[i].desc.bEndpointAddress &\r\nUSB_DIR_IN)\r\nrc = usb_clear_halt(udev, usb_rcvbulkpipe(udev,\r\nintf->cur_altsetting->endpoint[i].desc.bEndpointAddress));\r\nelse\r\nrc = usb_clear_halt(udev, usb_sndbulkpipe(udev,\r\nintf->cur_altsetting->endpoint[i].desc.bEndpointAddress));\r\n}\r\nif ((udev->actconfig->desc.bNumInterfaces == 2) &&\r\n(intf->cur_altsetting->desc.bInterfaceNumber == 0)) {\r\npr_debug("rom interface 0 is not used\n");\r\nreturn -ENODEV;\r\n}\r\nif (id->driver_info == SMS1XXX_BOARD_SIANO_STELLAR_ROM) {\r\nsnprintf(devpath, sizeof(devpath), "usb\\%d-%s",\r\nudev->bus->busnum, udev->devpath);\r\npr_info("stellar device in cold state was found at %s.\n",\r\ndevpath);\r\nrc = smsusb1_load_firmware(\r\nudev, smscore_registry_getmode(devpath),\r\nid->driver_info);\r\nif (!rc)\r\npr_info("stellar device now in warm state\n");\r\nelse\r\npr_err("Failed to put stellar in warm state. Error: %d\n",\r\nrc);\r\nreturn rc;\r\n} else {\r\nrc = smsusb_init_device(intf, id->driver_info);\r\n}\r\npr_info("Device initialized with return code %d\n", rc);\r\nsms_board_load_modules(id->driver_info);\r\nreturn rc;\r\n}\r\nstatic void smsusb_disconnect(struct usb_interface *intf)\r\n{\r\nsmsusb_term_device(intf);\r\n}\r\nstatic int smsusb_suspend(struct usb_interface *intf, pm_message_t msg)\r\n{\r\nstruct smsusb_device_t *dev = usb_get_intfdata(intf);\r\nprintk(KERN_INFO "%s Entering status %d.\n", __func__, msg.event);\r\ndev->state = SMSUSB_SUSPENDED;\r\nsmsusb_stop_streaming(dev);\r\nreturn 0;\r\n}\r\nstatic int smsusb_resume(struct usb_interface *intf)\r\n{\r\nint rc, i;\r\nstruct smsusb_device_t *dev = usb_get_intfdata(intf);\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nprintk(KERN_INFO "%s Entering.\n", __func__);\r\nusb_clear_halt(udev, usb_rcvbulkpipe(udev, dev->in_ep));\r\nusb_clear_halt(udev, usb_sndbulkpipe(udev, dev->out_ep));\r\nfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++)\r\nprintk(KERN_INFO "endpoint %d %02x %02x %d\n", i,\r\nintf->cur_altsetting->endpoint[i].desc.bEndpointAddress,\r\nintf->cur_altsetting->endpoint[i].desc.bmAttributes,\r\nintf->cur_altsetting->endpoint[i].desc.wMaxPacketSize);\r\nif (intf->num_altsetting > 0) {\r\nrc = usb_set_interface(udev,\r\nintf->cur_altsetting->desc.\r\nbInterfaceNumber, 0);\r\nif (rc < 0) {\r\nprintk(KERN_INFO "%s usb_set_interface failed, "\r\n"rc %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\n}\r\nsmsusb_start_streaming(dev);\r\nreturn 0;\r\n}
