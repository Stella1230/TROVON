static u8 crb_status(struct tpm_chip *chip)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nu8 sts = 0;\r\nif ((ioread32(&priv->cca->start) & CRB_START_INVOKE) !=\r\nCRB_START_INVOKE)\r\nsts |= CRB_STS_COMPLETE;\r\nreturn sts;\r\n}\r\nstatic int crb_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nunsigned int expected;\r\nif (count < 6)\r\nreturn -EIO;\r\nif (ioread32(&priv->cca->sts) & CRB_CA_STS_ERROR)\r\nreturn -EIO;\r\nmemcpy_fromio(buf, priv->rsp, 6);\r\nexpected = be32_to_cpup((__be32 *) &buf[2]);\r\nif (expected > count)\r\nreturn -EIO;\r\nmemcpy_fromio(&buf[6], &priv->rsp[6], expected - 6);\r\nreturn expected;\r\n}\r\nstatic int crb_do_acpi_start(struct tpm_chip *chip)\r\n{\r\nunion acpi_object *obj;\r\nint rc;\r\nobj = acpi_evaluate_dsm(chip->acpi_dev_handle,\r\nCRB_ACPI_START_UUID,\r\nCRB_ACPI_START_REVISION_ID,\r\nCRB_ACPI_START_INDEX,\r\nNULL);\r\nif (!obj)\r\nreturn -ENXIO;\r\nrc = obj->integer.value == 0 ? 0 : -ENXIO;\r\nACPI_FREE(obj);\r\nreturn rc;\r\n}\r\nstatic int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nint rc = 0;\r\nif (len > ioread32(&priv->cca->cmd_size)) {\r\ndev_err(&chip->dev,\r\n"invalid command count value %x %zx\n",\r\n(unsigned int) len,\r\n(size_t) ioread32(&priv->cca->cmd_size));\r\nreturn -E2BIG;\r\n}\r\nmemcpy_toio(priv->cmd, buf, len);\r\nwmb();\r\nif (priv->flags & CRB_FL_CRB_START)\r\niowrite32(cpu_to_le32(CRB_START_INVOKE), &priv->cca->start);\r\nif (priv->flags & CRB_FL_ACPI_START)\r\nrc = crb_do_acpi_start(chip);\r\nreturn rc;\r\n}\r\nstatic void crb_cancel(struct tpm_chip *chip)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\niowrite32(cpu_to_le32(CRB_CANCEL_INVOKE), &priv->cca->cancel);\r\nwmb();\r\nif ((priv->flags & CRB_FL_ACPI_START) && crb_do_acpi_start(chip))\r\ndev_err(&chip->dev, "ACPI Start failed\n");\r\niowrite32(0, &priv->cca->cancel);\r\n}\r\nstatic bool crb_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nstruct crb_priv *priv = chip->vendor.priv;\r\nu32 cancel = ioread32(&priv->cca->cancel);\r\nreturn (cancel & CRB_CANCEL_INVOKE) == CRB_CANCEL_INVOKE;\r\n}\r\nstatic int crb_init(struct acpi_device *device, struct crb_priv *priv)\r\n{\r\nstruct tpm_chip *chip;\r\nint rc;\r\nchip = tpmm_chip_alloc(&device->dev, &tpm_crb);\r\nif (IS_ERR(chip))\r\nreturn PTR_ERR(chip);\r\nchip->vendor.priv = priv;\r\nchip->acpi_dev_handle = device->handle;\r\nchip->flags = TPM_CHIP_FLAG_TPM2;\r\nrc = tpm_get_timeouts(chip);\r\nif (rc)\r\nreturn rc;\r\nrc = tpm2_do_selftest(chip);\r\nif (rc)\r\nreturn rc;\r\nreturn tpm_chip_register(chip);\r\n}\r\nstatic int crb_check_resource(struct acpi_resource *ares, void *data)\r\n{\r\nstruct crb_priv *priv = data;\r\nstruct resource res;\r\nif (acpi_dev_resource_memory(ares, &res)) {\r\npriv->res = res;\r\npriv->res.name = NULL;\r\n}\r\nreturn 1;\r\n}\r\nstatic void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,\r\nu64 start, u32 size)\r\n{\r\nstruct resource new_res = {\r\n.start = start,\r\n.end = start + size - 1,\r\n.flags = IORESOURCE_MEM,\r\n};\r\nif (start != new_res.start)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!resource_contains(&priv->res, &new_res))\r\nreturn devm_ioremap_resource(dev, &new_res);\r\nreturn priv->iobase + (new_res.start - priv->res.start);\r\n}\r\nstatic int crb_map_io(struct acpi_device *device, struct crb_priv *priv,\r\nstruct acpi_table_tpm2 *buf)\r\n{\r\nstruct list_head resources;\r\nstruct device *dev = &device->dev;\r\nu64 pa;\r\nint ret;\r\nINIT_LIST_HEAD(&resources);\r\nret = acpi_dev_get_resources(device, &resources, crb_check_resource,\r\npriv);\r\nif (ret < 0)\r\nreturn ret;\r\nacpi_dev_free_resource_list(&resources);\r\nif (resource_type(&priv->res) != IORESOURCE_MEM) {\r\ndev_err(dev,\r\nFW_BUG "TPM2 ACPI table does not define a memory resource\n");\r\nreturn -EINVAL;\r\n}\r\npriv->iobase = devm_ioremap_resource(dev, &priv->res);\r\nif (IS_ERR(priv->iobase))\r\nreturn PTR_ERR(priv->iobase);\r\npriv->cca = crb_map_res(dev, priv, buf->control_address, 0x1000);\r\nif (IS_ERR(priv->cca))\r\nreturn PTR_ERR(priv->cca);\r\npa = ((u64) ioread32(&priv->cca->cmd_pa_high) << 32) |\r\n(u64) ioread32(&priv->cca->cmd_pa_low);\r\npriv->cmd = crb_map_res(dev, priv, pa, ioread32(&priv->cca->cmd_size));\r\nif (IS_ERR(priv->cmd))\r\nreturn PTR_ERR(priv->cmd);\r\nmemcpy_fromio(&pa, &priv->cca->rsp_pa, 8);\r\npa = le64_to_cpu(pa);\r\npriv->rsp = crb_map_res(dev, priv, pa, ioread32(&priv->cca->rsp_size));\r\nreturn PTR_ERR_OR_ZERO(priv->rsp);\r\n}\r\nstatic int crb_acpi_add(struct acpi_device *device)\r\n{\r\nstruct acpi_table_tpm2 *buf;\r\nstruct crb_priv *priv;\r\nstruct device *dev = &device->dev;\r\nacpi_status status;\r\nu32 sm;\r\nint rc;\r\nstatus = acpi_get_table(ACPI_SIG_TPM2, 1,\r\n(struct acpi_table_header **) &buf);\r\nif (ACPI_FAILURE(status) || buf->header.length < sizeof(*buf)) {\r\ndev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");\r\nreturn -EINVAL;\r\n}\r\nsm = buf->start_method;\r\nif (sm == ACPI_TPM2_MEMORY_MAPPED)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(dev, sizeof(struct crb_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (sm == ACPI_TPM2_COMMAND_BUFFER || sm == ACPI_TPM2_MEMORY_MAPPED ||\r\n!strcmp(acpi_device_hid(device), "MSFT0101"))\r\npriv->flags |= CRB_FL_CRB_START;\r\nif (sm == ACPI_TPM2_START_METHOD ||\r\nsm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD)\r\npriv->flags |= CRB_FL_ACPI_START;\r\nrc = crb_map_io(device, priv, buf);\r\nif (rc)\r\nreturn rc;\r\nreturn crb_init(device, priv);\r\n}\r\nstatic int crb_acpi_remove(struct acpi_device *device)\r\n{\r\nstruct device *dev = &device->dev;\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ntpm2_shutdown(chip, TPM2_SU_CLEAR);\r\ntpm_chip_unregister(chip);\r\nreturn 0;\r\n}
