static inline struct usb_usbvision *cd_to_usbvision(struct device *cd)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nreturn video_get_drvdata(vdev);\r\n}\r\nstatic ssize_t show_version(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", USBVISION_VERSION_STRING);\r\n}\r\nstatic ssize_t show_model(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nreturn sprintf(buf, "%s\n",\r\nusbvision_device_data[usbvision->dev_model].model_string);\r\n}\r\nstatic ssize_t show_hue(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nstruct v4l2_control ctrl;\r\nctrl.id = V4L2_CID_HUE;\r\nctrl.value = 0;\r\nif (usbvision->user)\r\ncall_all(usbvision, core, g_ctrl, &ctrl);\r\nreturn sprintf(buf, "%d\n", ctrl.value);\r\n}\r\nstatic ssize_t show_contrast(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nstruct v4l2_control ctrl;\r\nctrl.id = V4L2_CID_CONTRAST;\r\nctrl.value = 0;\r\nif (usbvision->user)\r\ncall_all(usbvision, core, g_ctrl, &ctrl);\r\nreturn sprintf(buf, "%d\n", ctrl.value);\r\n}\r\nstatic ssize_t show_brightness(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nstruct v4l2_control ctrl;\r\nctrl.id = V4L2_CID_BRIGHTNESS;\r\nctrl.value = 0;\r\nif (usbvision->user)\r\ncall_all(usbvision, core, g_ctrl, &ctrl);\r\nreturn sprintf(buf, "%d\n", ctrl.value);\r\n}\r\nstatic ssize_t show_saturation(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nstruct v4l2_control ctrl;\r\nctrl.id = V4L2_CID_SATURATION;\r\nctrl.value = 0;\r\nif (usbvision->user)\r\ncall_all(usbvision, core, g_ctrl, &ctrl);\r\nreturn sprintf(buf, "%d\n", ctrl.value);\r\n}\r\nstatic ssize_t show_streaming(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nreturn sprintf(buf, "%s\n",\r\nYES_NO(usbvision->streaming == stream_on ? 1 : 0));\r\n}\r\nstatic ssize_t show_compression(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nreturn sprintf(buf, "%s\n",\r\nYES_NO(usbvision->isoc_mode == ISOC_MODE_COMPRESS));\r\n}\r\nstatic ssize_t show_device_bridge(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct usb_usbvision *usbvision = video_get_drvdata(vdev);\r\nreturn sprintf(buf, "%d\n", usbvision->bridge_type);\r\n}\r\nstatic void usbvision_create_sysfs(struct video_device *vdev)\r\n{\r\nint res;\r\nif (!vdev)\r\nreturn;\r\ndo {\r\nres = device_create_file(&vdev->dev, &dev_attr_version);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_model);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_hue);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_contrast);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_brightness);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_saturation);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_streaming);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_compression);\r\nif (res < 0)\r\nbreak;\r\nres = device_create_file(&vdev->dev, &dev_attr_bridge);\r\nif (res >= 0)\r\nreturn;\r\n} while (0);\r\ndev_err(&vdev->dev, "%s error: %d\n", __func__, res);\r\n}\r\nstatic void usbvision_remove_sysfs(struct video_device *vdev)\r\n{\r\nif (vdev) {\r\ndevice_remove_file(&vdev->dev, &dev_attr_version);\r\ndevice_remove_file(&vdev->dev, &dev_attr_model);\r\ndevice_remove_file(&vdev->dev, &dev_attr_hue);\r\ndevice_remove_file(&vdev->dev, &dev_attr_contrast);\r\ndevice_remove_file(&vdev->dev, &dev_attr_brightness);\r\ndevice_remove_file(&vdev->dev, &dev_attr_saturation);\r\ndevice_remove_file(&vdev->dev, &dev_attr_streaming);\r\ndevice_remove_file(&vdev->dev, &dev_attr_compression);\r\ndevice_remove_file(&vdev->dev, &dev_attr_bridge);\r\n}\r\n}\r\nstatic int usbvision_v4l2_open(struct file *file)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint err_code = 0;\r\nPDEBUG(DBG_IO, "open");\r\nif (mutex_lock_interruptible(&usbvision->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nif (usbvision->user) {\r\nerr_code = -EBUSY;\r\n} else {\r\nerr_code = v4l2_fh_open(file);\r\nif (err_code)\r\ngoto unlock;\r\nerr_code = usbvision_scratch_alloc(usbvision);\r\nif (isoc_mode == ISOC_MODE_COMPRESS) {\r\nerr_code = usbvision_decompress_alloc(usbvision);\r\n}\r\nif (err_code) {\r\nusbvision_scratch_free(usbvision);\r\nusbvision_decompress_free(usbvision);\r\n}\r\n}\r\nif (!err_code) {\r\nif (!usbvision->initialized) {\r\nint setup_ok = 0;\r\nsetup_ok = usbvision_setup(usbvision, isoc_mode);\r\nif (setup_ok)\r\nusbvision->initialized = 1;\r\nelse\r\nerr_code = -EBUSY;\r\n}\r\nif (!err_code) {\r\nusbvision_begin_streaming(usbvision);\r\nerr_code = usbvision_init_isoc(usbvision);\r\nusbvision_muxsel(usbvision, 0);\r\nusbvision_empty_framequeues(usbvision);\r\nusbvision->user++;\r\n}\r\n}\r\nunlock:\r\nmutex_unlock(&usbvision->v4l2_lock);\r\nPDEBUG(DBG_IO, "success");\r\nreturn err_code;\r\n}\r\nstatic int usbvision_v4l2_close(struct file *file)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nPDEBUG(DBG_IO, "close");\r\nmutex_lock(&usbvision->v4l2_lock);\r\nusbvision_audio_off(usbvision);\r\nusbvision_restart_isoc(usbvision);\r\nusbvision_stop_isoc(usbvision);\r\nusbvision_decompress_free(usbvision);\r\nusbvision_frames_free(usbvision);\r\nusbvision_empty_framequeues(usbvision);\r\nusbvision_scratch_free(usbvision);\r\nusbvision->user--;\r\nmutex_unlock(&usbvision->v4l2_lock);\r\nif (usbvision->remove_pending) {\r\nprintk(KERN_INFO "%s: Final disconnect\n", __func__);\r\nusbvision_release(usbvision);\r\nreturn 0;\r\n}\r\nPDEBUG(DBG_IO, "success");\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint err_code;\r\nerr_code = usbvision_read_reg(usbvision, reg->reg&0xff);\r\nif (err_code < 0) {\r\ndev_err(&usbvision->vdev.dev,\r\n"%s: VIDIOC_DBG_G_REGISTER failed: error %d\n",\r\n__func__, err_code);\r\nreturn err_code;\r\n}\r\nreg->val = err_code;\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint err_code;\r\nerr_code = usbvision_write_reg(usbvision, reg->reg & 0xff, reg->val);\r\nif (err_code < 0) {\r\ndev_err(&usbvision->vdev.dev,\r\n"%s: VIDIOC_DBG_S_REGISTER failed: error %d\n",\r\n__func__, err_code);\r\nreturn err_code;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *vc)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nstrlcpy(vc->driver, "USBVision", sizeof(vc->driver));\r\nstrlcpy(vc->card,\r\nusbvision_device_data[usbvision->dev_model].model_string,\r\nsizeof(vc->card));\r\nusb_make_path(usbvision->dev, vc->bus_info, sizeof(vc->bus_info));\r\nvc->device_caps = usbvision->have_tuner ? V4L2_CAP_TUNER : 0;\r\nif (vdev->vfl_type == VFL_TYPE_GRABBER)\r\nvc->device_caps |= V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nelse\r\nvc->device_caps |= V4L2_CAP_RADIO;\r\nvc->capabilities = vc->device_caps | V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS;\r\nif (usbvision_device_data[usbvision->dev_model].radio)\r\nvc->capabilities |= V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *vi)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint chan;\r\nif (vi->index >= usbvision->video_inputs)\r\nreturn -EINVAL;\r\nif (usbvision->have_tuner)\r\nchan = vi->index;\r\nelse\r\nchan = vi->index + 1;\r\nswitch (chan) {\r\ncase 0:\r\nif (usbvision_device_data[usbvision->dev_model].video_channels == 4) {\r\nstrcpy(vi->name, "White Video Input");\r\n} else {\r\nstrcpy(vi->name, "Television");\r\nvi->type = V4L2_INPUT_TYPE_TUNER;\r\nvi->tuner = chan;\r\nvi->std = USBVISION_NORMS;\r\n}\r\nbreak;\r\ncase 1:\r\nvi->type = V4L2_INPUT_TYPE_CAMERA;\r\nif (usbvision_device_data[usbvision->dev_model].video_channels == 4)\r\nstrcpy(vi->name, "Green Video Input");\r\nelse\r\nstrcpy(vi->name, "Composite Video Input");\r\nvi->std = USBVISION_NORMS;\r\nbreak;\r\ncase 2:\r\nvi->type = V4L2_INPUT_TYPE_CAMERA;\r\nif (usbvision_device_data[usbvision->dev_model].video_channels == 4)\r\nstrcpy(vi->name, "Yellow Video Input");\r\nelse\r\nstrcpy(vi->name, "S-Video Input");\r\nvi->std = USBVISION_NORMS;\r\nbreak;\r\ncase 3:\r\nvi->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(vi->name, "Red Video Input");\r\nvi->std = USBVISION_NORMS;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *input)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\n*input = usbvision->ctl_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int input)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nif (input >= usbvision->video_inputs)\r\nreturn -EINVAL;\r\nusbvision_muxsel(usbvision, input);\r\nusbvision_set_input(usbvision);\r\nusbvision_set_output(usbvision,\r\nusbvision->curwidth,\r\nusbvision->curheight);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nusbvision->tvnorm_id = id;\r\ncall_all(usbvision, video, s_std, usbvision->tvnorm_id);\r\nusbvision_muxsel(usbvision, usbvision->ctl_input);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\n*id = usbvision->tvnorm_id;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *vt)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nif (vt->index)\r\nreturn -EINVAL;\r\nif (vt->type == V4L2_TUNER_RADIO)\r\nstrcpy(vt->name, "Radio");\r\nelse\r\nstrcpy(vt->name, "Television");\r\ncall_all(usbvision, tuner, g_tuner, vt);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *vt)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nif (vt->index)\r\nreturn -EINVAL;\r\ncall_all(usbvision, tuner, s_tuner, vt);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nif (freq->tuner)\r\nreturn -EINVAL;\r\nif (freq->type == V4L2_TUNER_RADIO)\r\nfreq->frequency = usbvision->radio_freq;\r\nelse\r\nfreq->frequency = usbvision->tv_freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *freq)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nstruct v4l2_frequency new_freq = *freq;\r\nif (freq->tuner)\r\nreturn -EINVAL;\r\ncall_all(usbvision, tuner, s_frequency, freq);\r\ncall_all(usbvision, tuner, g_frequency, &new_freq);\r\nif (freq->type == V4L2_TUNER_RADIO)\r\nusbvision->radio_freq = new_freq.frequency;\r\nelse\r\nusbvision->tv_freq = new_freq.frequency;\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file,\r\nvoid *priv, struct v4l2_requestbuffers *vr)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint ret;\r\nRESTRICT_TO_RANGE(vr->count, 1, USBVISION_NUMFRAMES);\r\nif (vr->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nif (usbvision->streaming == stream_on) {\r\nret = usbvision_stream_interrupt(usbvision);\r\nif (ret)\r\nreturn ret;\r\n}\r\nusbvision_frames_free(usbvision);\r\nusbvision_empty_framequeues(usbvision);\r\nvr->count = usbvision_frames_alloc(usbvision, vr->count);\r\nusbvision->cur_frame = NULL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querybuf(struct file *file,\r\nvoid *priv, struct v4l2_buffer *vb)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nstruct usbvision_frame *frame;\r\nif (vb->index >= usbvision->num_frames)\r\nreturn -EINVAL;\r\nvb->flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nframe = &usbvision->frame[vb->index];\r\nif (frame->grabstate >= frame_state_ready)\r\nvb->flags |= V4L2_BUF_FLAG_QUEUED;\r\nif (frame->grabstate >= frame_state_done)\r\nvb->flags |= V4L2_BUF_FLAG_DONE;\r\nif (frame->grabstate == frame_state_unused)\r\nvb->flags |= V4L2_BUF_FLAG_MAPPED;\r\nvb->memory = V4L2_MEMORY_MMAP;\r\nvb->m.offset = vb->index * PAGE_ALIGN(usbvision->max_frame_size);\r\nvb->memory = V4L2_MEMORY_MMAP;\r\nvb->field = V4L2_FIELD_NONE;\r\nvb->length = usbvision->curwidth *\r\nusbvision->curheight *\r\nusbvision->palette.bytes_per_pixel;\r\nvb->timestamp = usbvision->frame[vb->index].timestamp;\r\nvb->sequence = usbvision->frame[vb->index].sequence;\r\nreturn 0;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *vb)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nstruct usbvision_frame *frame;\r\nunsigned long lock_flags;\r\nif (vb->index >= usbvision->num_frames)\r\nreturn -EINVAL;\r\nframe = &usbvision->frame[vb->index];\r\nif (frame->grabstate != frame_state_unused)\r\nreturn -EAGAIN;\r\nframe->grabstate = frame_state_ready;\r\nframe->scanstate = scan_state_scanning;\r\nframe->scanlength = 0;\r\nvb->flags &= ~V4L2_BUF_FLAG_DONE;\r\nframe->v4l2_format = usbvision->palette;\r\nspin_lock_irqsave(&usbvision->queue_lock, lock_flags);\r\nlist_add_tail(&usbvision->frame[vb->index].frame, &usbvision->inqueue);\r\nspin_unlock_irqrestore(&usbvision->queue_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *vb)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint ret;\r\nstruct usbvision_frame *f;\r\nunsigned long lock_flags;\r\nif (list_empty(&(usbvision->outqueue))) {\r\nif (usbvision->streaming == stream_idle)\r\nreturn -EINVAL;\r\nret = wait_event_interruptible\r\n(usbvision->wait_frame,\r\n!list_empty(&(usbvision->outqueue)));\r\nif (ret)\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&usbvision->queue_lock, lock_flags);\r\nf = list_entry(usbvision->outqueue.next,\r\nstruct usbvision_frame, frame);\r\nlist_del(usbvision->outqueue.next);\r\nspin_unlock_irqrestore(&usbvision->queue_lock, lock_flags);\r\nf->grabstate = frame_state_unused;\r\nvb->memory = V4L2_MEMORY_MMAP;\r\nvb->flags = V4L2_BUF_FLAG_MAPPED |\r\nV4L2_BUF_FLAG_QUEUED |\r\nV4L2_BUF_FLAG_DONE |\r\nV4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nvb->index = f->index;\r\nvb->sequence = f->sequence;\r\nvb->timestamp = f->timestamp;\r\nvb->field = V4L2_FIELD_NONE;\r\nvb->bytesused = f->scanlength;\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nusbvision->streaming = stream_on;\r\ncall_all(usbvision, video, s_stream, 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamoff(struct file *file,\r\nvoid *priv, enum v4l2_buf_type type)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (usbvision->streaming == stream_on) {\r\nusbvision_stream_interrupt(usbvision);\r\ncall_all(usbvision, video, s_stream, 0);\r\n}\r\nusbvision_empty_framequeues(usbvision);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *vfd)\r\n{\r\nif (vfd->index >= USBVISION_SUPPORTED_PALETTES - 1)\r\nreturn -EINVAL;\r\nstrcpy(vfd->description, usbvision_v4l2_format[vfd->index].desc);\r\nvfd->pixelformat = usbvision_v4l2_format[vfd->index].format;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *vf)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nvf->fmt.pix.width = usbvision->curwidth;\r\nvf->fmt.pix.height = usbvision->curheight;\r\nvf->fmt.pix.pixelformat = usbvision->palette.format;\r\nvf->fmt.pix.bytesperline =\r\nusbvision->curwidth * usbvision->palette.bytes_per_pixel;\r\nvf->fmt.pix.sizeimage = vf->fmt.pix.bytesperline * usbvision->curheight;\r\nvf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nvf->fmt.pix.field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *vf)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint format_idx;\r\nfor (format_idx = 0; format_idx < USBVISION_SUPPORTED_PALETTES; format_idx++) {\r\nif (vf->fmt.pix.pixelformat ==\r\nusbvision_v4l2_format[format_idx].format) {\r\nusbvision->palette = usbvision_v4l2_format[format_idx];\r\nbreak;\r\n}\r\n}\r\nif (format_idx == USBVISION_SUPPORTED_PALETTES)\r\nreturn -EINVAL;\r\nRESTRICT_TO_RANGE(vf->fmt.pix.width, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH);\r\nRESTRICT_TO_RANGE(vf->fmt.pix.height, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT);\r\nvf->fmt.pix.bytesperline = vf->fmt.pix.width*\r\nusbvision->palette.bytes_per_pixel;\r\nvf->fmt.pix.sizeimage = vf->fmt.pix.bytesperline*vf->fmt.pix.height;\r\nvf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nvf->fmt.pix.field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *vf)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, priv, vf);\r\nif (ret)\r\nreturn ret;\r\nif (usbvision->streaming == stream_on) {\r\nret = usbvision_stream_interrupt(usbvision);\r\nif (ret)\r\nreturn ret;\r\n}\r\nusbvision_frames_free(usbvision);\r\nusbvision_empty_framequeues(usbvision);\r\nusbvision->cur_frame = NULL;\r\nusbvision_set_output(usbvision, vf->fmt.pix.width, vf->fmt.pix.height);\r\nreturn 0;\r\n}\r\nstatic ssize_t usbvision_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint noblock = file->f_flags & O_NONBLOCK;\r\nunsigned long lock_flags;\r\nint ret, i;\r\nstruct usbvision_frame *frame;\r\nPDEBUG(DBG_IO, "%s: %ld bytes, noblock=%d", __func__,\r\n(unsigned long)count, noblock);\r\nif (!USBVISION_IS_OPERATIONAL(usbvision) || (buf == NULL))\r\nreturn -EFAULT;\r\nif (!usbvision->num_frames) {\r\nusbvision_frames_free(usbvision);\r\nusbvision_empty_framequeues(usbvision);\r\nusbvision_frames_alloc(usbvision, USBVISION_NUMFRAMES);\r\n}\r\nif (usbvision->streaming != stream_on) {\r\nusbvision->streaming = stream_on;\r\ncall_all(usbvision, video, s_stream, 1);\r\n}\r\nfor (i = 0; i < usbvision->num_frames; i++) {\r\nframe = &usbvision->frame[i];\r\nif (frame->grabstate == frame_state_unused) {\r\nframe->grabstate = frame_state_ready;\r\nframe->scanstate = scan_state_scanning;\r\nframe->scanlength = 0;\r\nframe->v4l2_format = usbvision->palette;\r\nspin_lock_irqsave(&usbvision->queue_lock, lock_flags);\r\nlist_add_tail(&frame->frame, &usbvision->inqueue);\r\nspin_unlock_irqrestore(&usbvision->queue_lock,\r\nlock_flags);\r\n}\r\n}\r\nif (list_empty(&(usbvision->outqueue))) {\r\nif (noblock)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible\r\n(usbvision->wait_frame,\r\n!list_empty(&(usbvision->outqueue)));\r\nif (ret)\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&usbvision->queue_lock, lock_flags);\r\nframe = list_entry(usbvision->outqueue.next,\r\nstruct usbvision_frame, frame);\r\nlist_del(usbvision->outqueue.next);\r\nspin_unlock_irqrestore(&usbvision->queue_lock, lock_flags);\r\nif (frame->grabstate == frame_state_error) {\r\nframe->bytes_read = 0;\r\nreturn 0;\r\n}\r\nPDEBUG(DBG_IO, "%s: frmx=%d, bytes_read=%ld, scanlength=%ld",\r\n__func__,\r\nframe->index, frame->bytes_read, frame->scanlength);\r\nif ((count + frame->bytes_read) > (unsigned long)frame->scanlength)\r\ncount = frame->scanlength - frame->bytes_read;\r\nif (copy_to_user(buf, frame->data + frame->bytes_read, count))\r\nreturn -EFAULT;\r\nframe->bytes_read += count;\r\nPDEBUG(DBG_IO, "%s: {copy} count used=%ld, new bytes_read=%ld",\r\n__func__,\r\n(unsigned long)count, frame->bytes_read);\r\n#if 1\r\nframe->bytes_read = 0;\r\nframe->grabstate = frame_state_unused;\r\n#else\r\nif (frame->bytes_read >= frame->scanlength) {\r\nframe->bytes_read = 0;\r\nframe->grabstate = frame_state_unused;\r\n}\r\n#endif\r\nreturn count;\r\n}\r\nstatic ssize_t usbvision_v4l2_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint res;\r\nif (mutex_lock_interruptible(&usbvision->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nres = usbvision_read(file, buf, count, ppos);\r\nmutex_unlock(&usbvision->v4l2_lock);\r\nreturn res;\r\n}\r\nstatic int usbvision_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nunsigned long size = vma->vm_end - vma->vm_start,\r\nstart = vma->vm_start;\r\nvoid *pos;\r\nu32 i;\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nPDEBUG(DBG_MMAP, "mmap");\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn -EFAULT;\r\nif (!(vma->vm_flags & VM_WRITE) ||\r\nsize != PAGE_ALIGN(usbvision->max_frame_size)) {\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < usbvision->num_frames; i++) {\r\nif (((PAGE_ALIGN(usbvision->max_frame_size)*i) >> PAGE_SHIFT) ==\r\nvma->vm_pgoff)\r\nbreak;\r\n}\r\nif (i == usbvision->num_frames) {\r\nPDEBUG(DBG_MMAP,\r\n"mmap: user supplied mapping address is out of range");\r\nreturn -EINVAL;\r\n}\r\nvma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;\r\npos = usbvision->frame[i].data;\r\nwhile (size > 0) {\r\nif (vm_insert_page(vma, start, vmalloc_to_page(pos))) {\r\nPDEBUG(DBG_MMAP, "mmap: vm_insert_page failed");\r\nreturn -EAGAIN;\r\n}\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbvision_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint res;\r\nif (mutex_lock_interruptible(&usbvision->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nres = usbvision_mmap(file, vma);\r\nmutex_unlock(&usbvision->v4l2_lock);\r\nreturn res;\r\n}\r\nstatic int usbvision_radio_open(struct file *file)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nint err_code = 0;\r\nPDEBUG(DBG_IO, "%s:", __func__);\r\nif (mutex_lock_interruptible(&usbvision->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nerr_code = v4l2_fh_open(file);\r\nif (err_code)\r\ngoto out;\r\nif (usbvision->user) {\r\ndev_err(&usbvision->rdev.dev,\r\n"%s: Someone tried to open an already opened USBVision Radio!\n",\r\n__func__);\r\nerr_code = -EBUSY;\r\n} else {\r\nerr_code = usbvision_set_alternate(usbvision);\r\nif (err_code < 0) {\r\nusbvision->last_error = err_code;\r\nerr_code = -EBUSY;\r\ngoto out;\r\n}\r\nusbvision->radio = 1;\r\ncall_all(usbvision, tuner, s_radio);\r\nusbvision_set_audio(usbvision, USBVISION_AUDIO_RADIO);\r\nusbvision->user++;\r\n}\r\nout:\r\nmutex_unlock(&usbvision->v4l2_lock);\r\nreturn err_code;\r\n}\r\nstatic int usbvision_radio_close(struct file *file)\r\n{\r\nstruct usb_usbvision *usbvision = video_drvdata(file);\r\nPDEBUG(DBG_IO, "");\r\nmutex_lock(&usbvision->v4l2_lock);\r\nusbvision->iface_alt = 0;\r\nusb_set_interface(usbvision->dev, usbvision->iface,\r\nusbvision->iface_alt);\r\nusbvision_audio_off(usbvision);\r\nusbvision->radio = 0;\r\nusbvision->user--;\r\nmutex_unlock(&usbvision->v4l2_lock);\r\nif (usbvision->remove_pending) {\r\nprintk(KERN_INFO "%s: Final disconnect\n", __func__);\r\nv4l2_fh_release(file);\r\nusbvision_release(usbvision);\r\nreturn 0;\r\n}\r\nPDEBUG(DBG_IO, "success");\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic void usbvision_vdev_init(struct usb_usbvision *usbvision,\r\nstruct video_device *vdev,\r\nconst struct video_device *vdev_template,\r\nconst char *name)\r\n{\r\nstruct usb_device *usb_dev = usbvision->dev;\r\nif (usb_dev == NULL) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: usbvision->dev is not set\n", __func__);\r\nreturn;\r\n}\r\n*vdev = *vdev_template;\r\nvdev->lock = &usbvision->v4l2_lock;\r\nvdev->v4l2_dev = &usbvision->v4l2_dev;\r\nsnprintf(vdev->name, sizeof(vdev->name), "%s", name);\r\nvideo_set_drvdata(vdev, usbvision);\r\n}\r\nstatic void usbvision_unregister_video(struct usb_usbvision *usbvision)\r\n{\r\nif (video_is_registered(&usbvision->rdev)) {\r\nPDEBUG(DBG_PROBE, "unregister %s [v4l2]",\r\nvideo_device_node_name(&usbvision->rdev));\r\nvideo_unregister_device(&usbvision->rdev);\r\n}\r\nif (video_is_registered(&usbvision->vdev)) {\r\nPDEBUG(DBG_PROBE, "unregister %s [v4l2]",\r\nvideo_device_node_name(&usbvision->vdev));\r\nvideo_unregister_device(&usbvision->vdev);\r\n}\r\n}\r\nstatic int usbvision_register_video(struct usb_usbvision *usbvision)\r\n{\r\nint res = -ENOMEM;\r\nusbvision_vdev_init(usbvision, &usbvision->vdev,\r\n&usbvision_video_template, "USBVision Video");\r\nif (!usbvision->have_tuner) {\r\nv4l2_disable_ioctl(&usbvision->vdev, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(&usbvision->vdev, VIDIOC_S_TUNER);\r\nv4l2_disable_ioctl(&usbvision->vdev, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(&usbvision->vdev, VIDIOC_S_TUNER);\r\n}\r\nif (video_register_device(&usbvision->vdev, VFL_TYPE_GRABBER, video_nr) < 0)\r\ngoto err_exit;\r\nprintk(KERN_INFO "USBVision[%d]: registered USBVision Video device %s [v4l2]\n",\r\nusbvision->nr, video_device_node_name(&usbvision->vdev));\r\nif (usbvision_device_data[usbvision->dev_model].radio) {\r\nusbvision_vdev_init(usbvision, &usbvision->rdev,\r\n&usbvision_radio_template, "USBVision Radio");\r\nif (video_register_device(&usbvision->rdev, VFL_TYPE_RADIO, radio_nr) < 0)\r\ngoto err_exit;\r\nprintk(KERN_INFO "USBVision[%d]: registered USBVision Radio device %s [v4l2]\n",\r\nusbvision->nr, video_device_node_name(&usbvision->rdev));\r\n}\r\nreturn 0;\r\nerr_exit:\r\ndev_err(&usbvision->dev->dev,\r\n"USBVision[%d]: video_register_device() failed\n",\r\nusbvision->nr);\r\nusbvision_unregister_video(usbvision);\r\nreturn res;\r\n}\r\nstatic struct usb_usbvision *usbvision_alloc(struct usb_device *dev,\r\nstruct usb_interface *intf)\r\n{\r\nstruct usb_usbvision *usbvision;\r\nusbvision = kzalloc(sizeof(struct usb_usbvision), GFP_KERNEL);\r\nif (usbvision == NULL)\r\nreturn NULL;\r\nusbvision->dev = dev;\r\nif (v4l2_device_register(&intf->dev, &usbvision->v4l2_dev))\r\ngoto err_free;\r\nif (v4l2_ctrl_handler_init(&usbvision->hdl, 4))\r\ngoto err_unreg;\r\nusbvision->v4l2_dev.ctrl_handler = &usbvision->hdl;\r\nmutex_init(&usbvision->v4l2_lock);\r\nusbvision->ctrl_urb = usb_alloc_urb(USBVISION_URB_FRAMES, GFP_KERNEL);\r\nif (usbvision->ctrl_urb == NULL)\r\ngoto err_unreg;\r\ninit_waitqueue_head(&usbvision->ctrl_urb_wq);\r\nreturn usbvision;\r\nerr_unreg:\r\nv4l2_ctrl_handler_free(&usbvision->hdl);\r\nv4l2_device_unregister(&usbvision->v4l2_dev);\r\nerr_free:\r\nkfree(usbvision);\r\nreturn NULL;\r\n}\r\nstatic void usbvision_release(struct usb_usbvision *usbvision)\r\n{\r\nPDEBUG(DBG_PROBE, "");\r\nusbvision->initialized = 0;\r\nusbvision_remove_sysfs(&usbvision->vdev);\r\nusbvision_unregister_video(usbvision);\r\nkfree(usbvision->alt_max_pkt_size);\r\nusb_free_urb(usbvision->ctrl_urb);\r\nv4l2_ctrl_handler_free(&usbvision->hdl);\r\nv4l2_device_unregister(&usbvision->v4l2_dev);\r\nkfree(usbvision);\r\nPDEBUG(DBG_PROBE, "success");\r\n}\r\nstatic void usbvision_configure_video(struct usb_usbvision *usbvision)\r\n{\r\nint model;\r\nif (usbvision == NULL)\r\nreturn;\r\nmodel = usbvision->dev_model;\r\nusbvision->palette = usbvision_v4l2_format[2];\r\nif (usbvision_device_data[usbvision->dev_model].vin_reg2_override) {\r\nusbvision->vin_reg2_preset =\r\nusbvision_device_data[usbvision->dev_model].vin_reg2;\r\n} else {\r\nusbvision->vin_reg2_preset = 0;\r\n}\r\nusbvision->tvnorm_id = usbvision_device_data[model].video_norm;\r\nusbvision->video_inputs = usbvision_device_data[model].video_channels;\r\nusbvision->ctl_input = 0;\r\nusbvision->radio_freq = 87.5 * 16000;\r\nusbvision->tv_freq = 400 * 16;\r\nif (usbvision_device_data[model].audio_channels > 0)\r\nusbvision_audio_off(usbvision);\r\nusbvision_power_on(usbvision);\r\nusbvision_i2c_register(usbvision);\r\n}\r\nstatic int usbvision_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *devid)\r\n{\r\nstruct usb_device *dev = usb_get_dev(interface_to_usbdev(intf));\r\nstruct usb_interface *uif;\r\n__u8 ifnum = intf->altsetting->desc.bInterfaceNumber;\r\nconst struct usb_host_interface *interface;\r\nstruct usb_usbvision *usbvision = NULL;\r\nconst struct usb_endpoint_descriptor *endpoint;\r\nint model, i, ret;\r\nPDEBUG(DBG_PROBE, "VID=%#04x, PID=%#04x, ifnum=%u",\r\ndev->descriptor.idVendor,\r\ndev->descriptor.idProduct, ifnum);\r\nmodel = devid->driver_info;\r\nif (model < 0 || model >= usbvision_device_data_size) {\r\nPDEBUG(DBG_PROBE, "model out of bounds %d", model);\r\nret = -ENODEV;\r\ngoto err_usb;\r\n}\r\nprintk(KERN_INFO "%s: %s found\n", __func__,\r\nusbvision_device_data[model].model_string);\r\nif (usbvision_device_data[model].interface >= 0)\r\ninterface = &dev->actconfig->interface[usbvision_device_data[model].interface]->altsetting[0];\r\nelse if (ifnum < dev->actconfig->desc.bNumInterfaces)\r\ninterface = &dev->actconfig->interface[ifnum]->altsetting[0];\r\nelse {\r\ndev_err(&intf->dev, "interface %d is invalid, max is %d\n",\r\nifnum, dev->actconfig->desc.bNumInterfaces - 1);\r\nret = -ENODEV;\r\ngoto err_usb;\r\n}\r\nif (interface->desc.bNumEndpoints < 2) {\r\ndev_err(&intf->dev, "interface %d has %d endpoints, but must"\r\n" have minimum 2\n", ifnum, interface->desc.bNumEndpoints);\r\nret = -ENODEV;\r\ngoto err_usb;\r\n}\r\nendpoint = &interface->endpoint[1].desc;\r\nif (!usb_endpoint_xfer_isoc(endpoint)) {\r\ndev_err(&intf->dev, "%s: interface %d. has non-ISO endpoint!\n",\r\n__func__, ifnum);\r\ndev_err(&intf->dev, "%s: Endpoint attributes %d",\r\n__func__, endpoint->bmAttributes);\r\nret = -ENODEV;\r\ngoto err_usb;\r\n}\r\nif (usb_endpoint_dir_out(endpoint)) {\r\ndev_err(&intf->dev, "%s: interface %d. has ISO OUT endpoint!\n",\r\n__func__, ifnum);\r\nret = -ENODEV;\r\ngoto err_usb;\r\n}\r\nusbvision = usbvision_alloc(dev, intf);\r\nif (usbvision == NULL) {\r\ndev_err(&intf->dev, "%s: couldn't allocate USBVision struct\n", __func__);\r\nret = -ENOMEM;\r\ngoto err_usb;\r\n}\r\nif (dev->descriptor.bNumConfigurations > 1)\r\nusbvision->bridge_type = BRIDGE_NT1004;\r\nelse if (model == DAZZLE_DVC_90_REV_1_SECAM)\r\nusbvision->bridge_type = BRIDGE_NT1005;\r\nelse\r\nusbvision->bridge_type = BRIDGE_NT1003;\r\nPDEBUG(DBG_PROBE, "bridge_type %d", usbvision->bridge_type);\r\nuif = dev->actconfig->interface[0];\r\nusbvision->num_alt = uif->num_altsetting;\r\nPDEBUG(DBG_PROBE, "Alternate settings: %i", usbvision->num_alt);\r\nusbvision->alt_max_pkt_size = kmalloc(32 * usbvision->num_alt, GFP_KERNEL);\r\nif (usbvision->alt_max_pkt_size == NULL) {\r\ndev_err(&intf->dev, "usbvision: out of memory!\n");\r\nret = -ENOMEM;\r\ngoto err_pkt;\r\n}\r\nfor (i = 0; i < usbvision->num_alt; i++) {\r\nu16 tmp = le16_to_cpu(uif->altsetting[i].endpoint[1].desc.\r\nwMaxPacketSize);\r\nusbvision->alt_max_pkt_size[i] =\r\n(tmp & 0x07ff) * (((tmp & 0x1800) >> 11) + 1);\r\nPDEBUG(DBG_PROBE, "Alternate setting %i, max size= %i", i,\r\nusbvision->alt_max_pkt_size[i]);\r\n}\r\nusbvision->nr = usbvision_nr++;\r\nspin_lock_init(&usbvision->queue_lock);\r\ninit_waitqueue_head(&usbvision->wait_frame);\r\ninit_waitqueue_head(&usbvision->wait_stream);\r\nusbvision->have_tuner = usbvision_device_data[model].tuner;\r\nif (usbvision->have_tuner)\r\nusbvision->tuner_type = usbvision_device_data[model].tuner_type;\r\nusbvision->dev_model = model;\r\nusbvision->remove_pending = 0;\r\nusbvision->iface = ifnum;\r\nusbvision->iface_alt = 0;\r\nusbvision->video_endp = endpoint->bEndpointAddress;\r\nusbvision->isoc_packet_size = 0;\r\nusbvision->usb_bandwidth = 0;\r\nusbvision->user = 0;\r\nusbvision->streaming = stream_off;\r\nusbvision_configure_video(usbvision);\r\nusbvision_register_video(usbvision);\r\nusbvision_create_sysfs(&usbvision->vdev);\r\nPDEBUG(DBG_PROBE, "success");\r\nreturn 0;\r\nerr_pkt:\r\nusbvision_release(usbvision);\r\nerr_usb:\r\nusb_put_dev(dev);\r\nreturn ret;\r\n}\r\nstatic void usbvision_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_usbvision *usbvision = to_usbvision(usb_get_intfdata(intf));\r\nPDEBUG(DBG_PROBE, "");\r\nif (usbvision == NULL) {\r\npr_err("%s: usb_get_intfdata() failed\n", __func__);\r\nreturn;\r\n}\r\nmutex_lock(&usbvision->v4l2_lock);\r\nusbvision_stop_isoc(usbvision);\r\nv4l2_device_disconnect(&usbvision->v4l2_dev);\r\nusbvision_i2c_unregister(usbvision);\r\nusbvision->remove_pending = 1;\r\nusb_put_dev(usbvision->dev);\r\nusbvision->dev = NULL;\r\nmutex_unlock(&usbvision->v4l2_lock);\r\nif (usbvision->user) {\r\nprintk(KERN_INFO "%s: In use, disconnect pending\n",\r\n__func__);\r\nwake_up_interruptible(&usbvision->wait_frame);\r\nwake_up_interruptible(&usbvision->wait_stream);\r\n} else {\r\nusbvision_release(usbvision);\r\n}\r\nPDEBUG(DBG_PROBE, "success");\r\n}\r\nstatic int __init usbvision_init(void)\r\n{\r\nint err_code;\r\nPDEBUG(DBG_PROBE, "");\r\nPDEBUG(DBG_IO, "IO debugging is enabled [video]");\r\nPDEBUG(DBG_PROBE, "PROBE debugging is enabled [video]");\r\nPDEBUG(DBG_MMAP, "MMAP debugging is enabled [video]");\r\nif (isoc_mode != ISOC_MODE_COMPRESS) {\r\nusbvision_v4l2_format[6].supported = 0;\r\nusbvision_v4l2_format[7].supported = 0;\r\n}\r\nerr_code = usb_register(&usbvision_driver);\r\nif (err_code == 0) {\r\nprintk(KERN_INFO DRIVER_DESC " : " USBVISION_VERSION_STRING "\n");\r\nPDEBUG(DBG_PROBE, "success");\r\n}\r\nreturn err_code;\r\n}\r\nstatic void __exit usbvision_exit(void)\r\n{\r\nPDEBUG(DBG_PROBE, "");\r\nusb_deregister(&usbvision_driver);\r\nPDEBUG(DBG_PROBE, "success");\r\n}
