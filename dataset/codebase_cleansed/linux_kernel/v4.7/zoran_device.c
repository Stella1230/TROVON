void\r\nGPIO (struct zoran *zr,\r\nint bit,\r\nunsigned int value)\r\n{\r\nu32 reg;\r\nu32 mask;\r\nmask = (1 << (24 + bit)) & 0xff000000;\r\nreg = btread(ZR36057_GPPGCR1) & ~mask;\r\nif (value) {\r\nreg |= mask;\r\n}\r\nbtwrite(reg, ZR36057_GPPGCR1);\r\nudelay(1);\r\n}\r\nint\r\npost_office_wait (struct zoran *zr)\r\n{\r\nu32 por;\r\nwhile ((por = btread(ZR36057_POR)) & ZR36057_POR_POPen) {\r\n}\r\nif ((por & ZR36057_POR_POTime) && !zr->card.gws_not_connected) {\r\ndprintk(1, KERN_INFO "%s: pop timeout %08x\n", ZR_DEVNAME(zr),\r\npor);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\npost_office_write (struct zoran *zr,\r\nunsigned int guest,\r\nunsigned int reg,\r\nunsigned int value)\r\n{\r\nu32 por;\r\npor =\r\nZR36057_POR_PODir | ZR36057_POR_POTime | ((guest & 7) << 20) |\r\n((reg & 7) << 16) | (value & 0xFF);\r\nbtwrite(por, ZR36057_POR);\r\nreturn post_office_wait(zr);\r\n}\r\nint\r\npost_office_read (struct zoran *zr,\r\nunsigned int guest,\r\nunsigned int reg)\r\n{\r\nu32 por;\r\npor = ZR36057_POR_POTime | ((guest & 7) << 20) | ((reg & 7) << 16);\r\nbtwrite(por, ZR36057_POR);\r\nif (post_office_wait(zr) < 0) {\r\nreturn -1;\r\n}\r\nreturn btread(ZR36057_POR) & 0xFF;\r\n}\r\nstatic void\r\ndump_guests (struct zoran *zr)\r\n{\r\nif (zr36067_debug > 2) {\r\nint i, guest[8];\r\nfor (i = 1; i < 8; i++) {\r\nguest[i] = post_office_read(zr, i, 0);\r\n}\r\nprintk(KERN_INFO "%s: Guests:", ZR_DEVNAME(zr));\r\nfor (i = 1; i < 8; i++) {\r\nprintk(" 0x%02x", guest[i]);\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nvoid\r\ndetect_guest_activity (struct zoran *zr)\r\n{\r\nint timeout, i, j, res, guest[8], guest0[8], change[8][3];\r\nktime_t t0, t1;\r\ndump_guests(zr);\r\nprintk(KERN_INFO "%s: Detecting guests activity, please wait...\n",\r\nZR_DEVNAME(zr));\r\nfor (i = 1; i < 8; i++) {\r\nguest0[i] = guest[i] = post_office_read(zr, i, 0);\r\n}\r\ntimeout = 0;\r\nj = 0;\r\nt0 = ktime_get();\r\nwhile (timeout < 10000) {\r\nudelay(10);\r\ntimeout++;\r\nfor (i = 1; (i < 8) && (j < 8); i++) {\r\nres = post_office_read(zr, i, 0);\r\nif (res != guest[i]) {\r\nt1 = ktime_get();\r\nchange[j][0] = ktime_to_us(ktime_sub(t1, t0));\r\nt0 = t1;\r\nchange[j][1] = i;\r\nchange[j][2] = res;\r\nj++;\r\nguest[i] = res;\r\n}\r\n}\r\nif (j >= 8)\r\nbreak;\r\n}\r\nprintk(KERN_INFO "%s: Guests:", ZR_DEVNAME(zr));\r\nfor (i = 1; i < 8; i++) {\r\nprintk(" 0x%02x", guest0[i]);\r\n}\r\nprintk("\n");\r\nif (j == 0) {\r\nprintk(KERN_INFO "%s: No activity detected.\n", ZR_DEVNAME(zr));\r\nreturn;\r\n}\r\nfor (i = 0; i < j; i++) {\r\nprintk(KERN_INFO "%s: %6d: %d => 0x%02x\n", ZR_DEVNAME(zr),\r\nchange[i][0], change[i][1], change[i][2]);\r\n}\r\n}\r\nvoid\r\njpeg_codec_sleep (struct zoran *zr,\r\nint sleep)\r\n{\r\nGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_SLEEP], !sleep);\r\nif (!sleep) {\r\ndprintk(3,\r\nKERN_DEBUG\r\n"%s: jpeg_codec_sleep() - wake GPIO=0x%08x\n",\r\nZR_DEVNAME(zr), btread(ZR36057_GPPGCR1));\r\nudelay(500);\r\n} else {\r\ndprintk(3,\r\nKERN_DEBUG\r\n"%s: jpeg_codec_sleep() - sleep GPIO=0x%08x\n",\r\nZR_DEVNAME(zr), btread(ZR36057_GPPGCR1));\r\nudelay(2);\r\n}\r\n}\r\nint\r\njpeg_codec_reset (struct zoran *zr)\r\n{\r\njpeg_codec_sleep(zr, 0);\r\nif (zr->card.gpcs[GPCS_JPEG_RESET] != 0xff) {\r\npost_office_write(zr, zr->card.gpcs[GPCS_JPEG_RESET], 0,\r\n0);\r\nudelay(2);\r\n} else {\r\nGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_RESET], 0);\r\nudelay(2);\r\nGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_RESET], 1);\r\nudelay(2);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nzr36057_adjust_vfe (struct zoran *zr,\r\nenum zoran_codec_mode mode)\r\n{\r\nu32 reg;\r\nswitch (mode) {\r\ncase BUZ_MODE_MOTION_DECOMPRESS:\r\nbtand(~ZR36057_VFESPFR_ExtFl, ZR36057_VFESPFR);\r\nreg = btread(ZR36057_VFEHCR);\r\nif ((reg & (1 << 10)) && zr->card.type != LML33R10) {\r\nreg += ((1 << 10) | 1);\r\n}\r\nbtwrite(reg, ZR36057_VFEHCR);\r\nbreak;\r\ncase BUZ_MODE_MOTION_COMPRESS:\r\ncase BUZ_MODE_IDLE:\r\ndefault:\r\nif ((zr->norm & V4L2_STD_NTSC) ||\r\n(zr->card.type == LML33R10 &&\r\n(zr->norm & V4L2_STD_PAL)))\r\nbtand(~ZR36057_VFESPFR_ExtFl, ZR36057_VFESPFR);\r\nelse\r\nbtor(ZR36057_VFESPFR_ExtFl, ZR36057_VFESPFR);\r\nreg = btread(ZR36057_VFEHCR);\r\nif (!(reg & (1 << 10)) && zr->card.type != LML33R10) {\r\nreg -= ((1 << 10) | 1);\r\n}\r\nbtwrite(reg, ZR36057_VFEHCR);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nzr36057_set_vfe (struct zoran *zr,\r\nint video_width,\r\nint video_height,\r\nconst struct zoran_format *format)\r\n{\r\nstruct tvnorm *tvn;\r\nunsigned HStart, HEnd, VStart, VEnd;\r\nunsigned DispMode;\r\nunsigned VidWinWid, VidWinHt;\r\nunsigned hcrop1, hcrop2, vcrop1, vcrop2;\r\nunsigned Wa, We, Ha, He;\r\nunsigned X, Y, HorDcm, VerDcm;\r\nu32 reg;\r\nunsigned mask_line_size;\r\ntvn = zr->timing;\r\nWa = tvn->Wa;\r\nHa = tvn->Ha;\r\ndprintk(2, KERN_INFO "%s: set_vfe() - width = %d, height = %d\n",\r\nZR_DEVNAME(zr), video_width, video_height);\r\nif (video_width < BUZ_MIN_WIDTH ||\r\nvideo_height < BUZ_MIN_HEIGHT ||\r\nvideo_width > Wa || video_height > Ha) {\r\ndprintk(1, KERN_ERR "%s: set_vfe: w=%d h=%d not valid\n",\r\nZR_DEVNAME(zr), video_width, video_height);\r\nreturn;\r\n}\r\nVidWinWid = video_width;\r\nX = DIV_ROUND_UP(VidWinWid * 64, tvn->Wa);\r\nWe = (VidWinWid * 64) / X;\r\nHorDcm = 64 - X;\r\nhcrop1 = 2 * ((tvn->Wa - We) / 4);\r\nhcrop2 = tvn->Wa - We - hcrop1;\r\nHStart = tvn->HStart ? tvn->HStart : 1;\r\nHEnd = HStart + tvn->Wa - 1;\r\nHStart += hcrop1;\r\nHEnd -= hcrop2;\r\nreg = ((HStart & ZR36057_VFEHCR_Hmask) << ZR36057_VFEHCR_HStart)\r\n| ((HEnd & ZR36057_VFEHCR_Hmask) << ZR36057_VFEHCR_HEnd);\r\nif (zr->card.vfe_pol.hsync_pol)\r\nreg |= ZR36057_VFEHCR_HSPol;\r\nbtwrite(reg, ZR36057_VFEHCR);\r\nDispMode = !(video_height > BUZ_MAX_HEIGHT / 2);\r\nVidWinHt = DispMode ? video_height : video_height / 2;\r\nY = DIV_ROUND_UP(VidWinHt * 64 * 2, tvn->Ha);\r\nHe = (VidWinHt * 64) / Y;\r\nVerDcm = 64 - Y;\r\nvcrop1 = (tvn->Ha / 2 - He) / 2;\r\nvcrop2 = tvn->Ha / 2 - He - vcrop1;\r\nVStart = tvn->VStart;\r\nVEnd = VStart + tvn->Ha / 2;\r\nVStart += vcrop1;\r\nVEnd -= vcrop2;\r\nreg = ((VStart & ZR36057_VFEVCR_Vmask) << ZR36057_VFEVCR_VStart)\r\n| ((VEnd & ZR36057_VFEVCR_Vmask) << ZR36057_VFEVCR_VEnd);\r\nif (zr->card.vfe_pol.vsync_pol)\r\nreg |= ZR36057_VFEVCR_VSPol;\r\nbtwrite(reg, ZR36057_VFEVCR);\r\nreg = 0;\r\nreg |= (HorDcm << ZR36057_VFESPFR_HorDcm);\r\nreg |= (VerDcm << ZR36057_VFESPFR_VerDcm);\r\nreg |= (DispMode << ZR36057_VFESPFR_DispMode);\r\nif (!(zr->norm & V4L2_STD_NTSC))\r\nreg |= ZR36057_VFESPFR_ExtFl;\r\nreg |= ZR36057_VFESPFR_TopField;\r\nif (HorDcm >= 48) {\r\nreg |= 3 << ZR36057_VFESPFR_HFilter;\r\n} else if (HorDcm >= 32) {\r\nreg |= 2 << ZR36057_VFESPFR_HFilter;\r\n} else if (HorDcm >= 16) {\r\nreg |= 1 << ZR36057_VFESPFR_HFilter;\r\n}\r\nreg |= format->vfespfr;\r\nbtwrite(reg, ZR36057_VFESPFR);\r\nreg = (16 << ZR36057_VDCR_MinPix)\r\n| (VidWinHt << ZR36057_VDCR_VidWinHt)\r\n| (VidWinWid << ZR36057_VDCR_VidWinWid);\r\nif (pci_pci_problems & PCIPCI_TRITON)\r\nreg &= ~ZR36057_VDCR_Triton;\r\nelse\r\nreg |= ZR36057_VDCR_Triton;\r\nbtwrite(reg, ZR36057_VDCR);\r\nif (zr->overlay_mask) {\r\nmask_line_size = (BUZ_MAX_WIDTH + 31) / 32;\r\nreg = virt_to_bus(zr->overlay_mask);\r\nbtwrite(reg, ZR36057_MMTR);\r\nreg = virt_to_bus(zr->overlay_mask + mask_line_size);\r\nbtwrite(reg, ZR36057_MMBR);\r\nreg =\r\nmask_line_size - (zr->overlay_settings.width +\r\n31) / 32;\r\nif (DispMode == 0)\r\nreg += mask_line_size;\r\nreg <<= ZR36057_OCR_MaskStride;\r\nbtwrite(reg, ZR36057_OCR);\r\n}\r\nzr36057_adjust_vfe(zr, zr->codec_mode);\r\n}\r\nvoid\r\nzr36057_overlay (struct zoran *zr,\r\nint on)\r\n{\r\nu32 reg;\r\nif (on) {\r\nbtand(~ZR36057_VDCR_VidEn, ZR36057_VDCR);\r\nzr36057_set_vfe(zr,\r\nzr->overlay_settings.width,\r\nzr->overlay_settings.height,\r\nzr->overlay_settings.format);\r\nreg = (long) zr->vbuf_base +\r\nzr->overlay_settings.x *\r\n((zr->overlay_settings.format->depth + 7) / 8) +\r\nzr->overlay_settings.y *\r\nzr->vbuf_bytesperline;\r\nbtwrite(reg, ZR36057_VDTR);\r\nif (reg & 3)\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: zr36057_overlay() - video_address not aligned\n",\r\nZR_DEVNAME(zr));\r\nif (zr->overlay_settings.height > BUZ_MAX_HEIGHT / 2)\r\nreg += zr->vbuf_bytesperline;\r\nbtwrite(reg, ZR36057_VDBR);\r\nreg = zr->vbuf_bytesperline -\r\nzr->overlay_settings.width *\r\n((zr->overlay_settings.format->depth + 7) / 8);\r\nif (zr->overlay_settings.height > BUZ_MAX_HEIGHT / 2)\r\nreg += zr->vbuf_bytesperline;\r\nif (reg & 3)\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: zr36057_overlay() - video_stride not aligned\n",\r\nZR_DEVNAME(zr));\r\nreg = (reg << ZR36057_VSSFGR_DispStride);\r\nreg |= ZR36057_VSSFGR_VidOvf;\r\nbtwrite(reg, ZR36057_VSSFGR);\r\nif (zr->overlay_settings.clipcount > 0)\r\nbtor(ZR36057_OCR_OvlEnable, ZR36057_OCR);\r\nbtor(ZR36057_VDCR_VidEn, ZR36057_VDCR);\r\n} else {\r\nbtand(~ZR36057_VDCR_VidEn, ZR36057_VDCR);\r\n}\r\n}\r\nvoid write_overlay_mask(struct zoran_fh *fh, struct v4l2_clip *vp, int count)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nunsigned mask_line_size = (BUZ_MAX_WIDTH + 31) / 32;\r\nu32 *mask;\r\nint x, y, width, height;\r\nunsigned i, j, k;\r\nmemset(fh->overlay_mask, ~0, mask_line_size * 4 * BUZ_MAX_HEIGHT);\r\nfor (i = 0; i < count; ++i) {\r\nx = vp[i].c.left;\r\ny = vp[i].c.top;\r\nwidth = vp[i].c.width;\r\nheight = vp[i].c.height;\r\nif (x < 0) {\r\nwidth += x;\r\nx = 0;\r\n}\r\nif (y < 0) {\r\nheight += y;\r\ny = 0;\r\n}\r\nif (x + width > fh->overlay_settings.width) {\r\nwidth = fh->overlay_settings.width - x;\r\n}\r\nif (y + height > fh->overlay_settings.height) {\r\nheight = fh->overlay_settings.height - y;\r\n}\r\nif (height <= 0) {\r\ncontinue;\r\n}\r\nif (width <= 0) {\r\ncontinue;\r\n}\r\nfor (j = 0; j < height; ++j) {\r\nmask = fh->overlay_mask + (y + j) * mask_line_size;\r\nfor (k = 0; k < width; ++k) {\r\nmask[(x + k) / 32] &=\r\n~((u32) 1 << (x + k) % 32);\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nzr36057_set_memgrab (struct zoran *zr,\r\nint mode)\r\n{\r\nif (mode) {\r\nif (btread(ZR36057_VSSFGR) & ZR36057_VSSFGR_SnapShot)\r\ndprintk(1,\r\nKERN_WARNING\r\n"%s: zr36057_set_memgrab(1) with SnapShot on!?\n",\r\nZR_DEVNAME(zr));\r\nbtwrite(IRQ_MASK, ZR36057_ISR);\r\nbtor(zr->card.vsync_int, ZR36057_ICR);\r\nbtor(ZR36057_VSSFGR_SnapShot, ZR36057_VSSFGR);\r\nzr36057_set_vfe(zr, zr->v4l_settings.width,\r\nzr->v4l_settings.height,\r\nzr->v4l_settings.format);\r\nzr->v4l_memgrab_active = 1;\r\n} else {\r\nbtand(~zr->card.vsync_int, ZR36057_ICR);\r\nzr->v4l_memgrab_active = 0;\r\nzr->v4l_grab_frame = NO_GRAB_ACTIVE;\r\nif (zr->v4l_overlay_active) {\r\nzr36057_overlay(zr, 1);\r\n} else {\r\nbtand(~ZR36057_VDCR_VidEn, ZR36057_VDCR);\r\nbtand(~ZR36057_VSSFGR_SnapShot, ZR36057_VSSFGR);\r\n}\r\n}\r\n}\r\nint\r\nwait_grab_pending (struct zoran *zr)\r\n{\r\nunsigned long flags;\r\nif (!zr->v4l_memgrab_active)\r\nreturn 0;\r\nwait_event_interruptible(zr->v4l_capq,\r\n(zr->v4l_pend_tail == zr->v4l_pend_head));\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nzr36057_set_memgrab(zr, 0);\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nset_frame (struct zoran *zr,\r\nint val)\r\n{\r\nGPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_FRAME], val);\r\n}\r\nstatic void\r\nset_videobus_dir (struct zoran *zr,\r\nint val)\r\n{\r\nswitch (zr->card.type) {\r\ncase LML33:\r\ncase LML33R10:\r\nif (!lml33dpath)\r\nGPIO(zr, 5, val);\r\nelse\r\nGPIO(zr, 5, 1);\r\nbreak;\r\ndefault:\r\nGPIO(zr, zr->card.gpio[ZR_GPIO_VID_DIR],\r\nzr->card.gpio_pol[ZR_GPIO_VID_DIR] ? !val : val);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ninit_jpeg_queue (struct zoran *zr)\r\n{\r\nint i;\r\nzr->jpg_que_head = 0;\r\nzr->jpg_dma_head = 0;\r\nzr->jpg_dma_tail = 0;\r\nzr->jpg_que_tail = 0;\r\nzr->jpg_seq_num = 0;\r\nzr->JPEG_error = 0;\r\nzr->num_errors = 0;\r\nzr->jpg_err_seq = 0;\r\nzr->jpg_err_shift = 0;\r\nzr->jpg_queued_num = 0;\r\nfor (i = 0; i < zr->jpg_buffers.num_buffers; i++) {\r\nzr->jpg_buffers.buffer[i].state = BUZ_STATE_USER;\r\n}\r\nfor (i = 0; i < BUZ_NUM_STAT_COM; i++) {\r\nzr->stat_com[i] = cpu_to_le32(1);\r\n}\r\n}\r\nstatic void\r\nzr36057_set_jpg (struct zoran *zr,\r\nenum zoran_codec_mode mode)\r\n{\r\nstruct tvnorm *tvn;\r\nu32 reg;\r\ntvn = zr->timing;\r\nbtwrite(0, ZR36057_JPC);\r\nswitch (mode) {\r\ncase BUZ_MODE_MOTION_COMPRESS:\r\ndefault:\r\nreg = ZR36057_JMC_MJPGCmpMode;\r\nbreak;\r\ncase BUZ_MODE_MOTION_DECOMPRESS:\r\nreg = ZR36057_JMC_MJPGExpMode;\r\nreg |= ZR36057_JMC_SyncMstr;\r\nbreak;\r\ncase BUZ_MODE_STILL_COMPRESS:\r\nreg = ZR36057_JMC_JPGCmpMode;\r\nbreak;\r\ncase BUZ_MODE_STILL_DECOMPRESS:\r\nreg = ZR36057_JMC_JPGExpMode;\r\nbreak;\r\n}\r\nreg |= ZR36057_JMC_JPG;\r\nif (zr->jpg_settings.field_per_buff == 1)\r\nreg |= ZR36057_JMC_Fld_per_buff;\r\nbtwrite(reg, ZR36057_JMC);\r\nbtor(ZR36057_VFEVCR_VSPol, ZR36057_VFEVCR);\r\nreg = (6 << ZR36057_VSP_VsyncSize) |\r\n(tvn->Ht << ZR36057_VSP_FrmTot);\r\nbtwrite(reg, ZR36057_VSP);\r\nreg = ((zr->jpg_settings.img_y + tvn->VStart) << ZR36057_FVAP_NAY) |\r\n(zr->jpg_settings.img_height << ZR36057_FVAP_PAY);\r\nbtwrite(reg, ZR36057_FVAP);\r\nif (zr->card.vfe_pol.hsync_pol)\r\nbtor(ZR36057_VFEHCR_HSPol, ZR36057_VFEHCR);\r\nelse\r\nbtand(~ZR36057_VFEHCR_HSPol, ZR36057_VFEHCR);\r\nreg = ((tvn->HSyncStart) << ZR36057_HSP_HsyncStart) |\r\n(tvn->Wt << ZR36057_HSP_LineTot);\r\nbtwrite(reg, ZR36057_HSP);\r\nreg = ((zr->jpg_settings.img_x +\r\ntvn->HStart + 4) << ZR36057_FHAP_NAX) |\r\n(zr->jpg_settings.img_width << ZR36057_FHAP_PAX);\r\nbtwrite(reg, ZR36057_FHAP);\r\nif (zr->jpg_settings.odd_even)\r\nreg = ZR36057_FPP_Odd_Even;\r\nelse\r\nreg = 0;\r\nbtwrite(reg, ZR36057_FPP);\r\nreg = virt_to_bus(zr->stat_com);\r\nbtwrite(reg, ZR36057_JCBA);\r\nswitch (mode) {\r\ncase BUZ_MODE_STILL_COMPRESS:\r\ncase BUZ_MODE_MOTION_COMPRESS:\r\nif (zr->card.type != BUZ)\r\nreg = 140;\r\nelse\r\nreg = 60;\r\nbreak;\r\ncase BUZ_MODE_STILL_DECOMPRESS:\r\ncase BUZ_MODE_MOTION_DECOMPRESS:\r\nreg = 20;\r\nbreak;\r\ndefault:\r\nreg = 80;\r\nbreak;\r\n}\r\nbtwrite(reg, ZR36057_JCFT);\r\nzr36057_adjust_vfe(zr, mode);\r\n}\r\nvoid\r\nprint_interrupts (struct zoran *zr)\r\n{\r\nint res, noerr = 0;\r\nprintk(KERN_INFO "%s: interrupts received:", ZR_DEVNAME(zr));\r\nif ((res = zr->field_counter) < -1 || res > 1) {\r\nprintk(" FD:%d", res);\r\n}\r\nif ((res = zr->intr_counter_GIRQ1) != 0) {\r\nprintk(" GIRQ1:%d", res);\r\nnoerr++;\r\n}\r\nif ((res = zr->intr_counter_GIRQ0) != 0) {\r\nprintk(" GIRQ0:%d", res);\r\nnoerr++;\r\n}\r\nif ((res = zr->intr_counter_CodRepIRQ) != 0) {\r\nprintk(" CodRepIRQ:%d", res);\r\nnoerr++;\r\n}\r\nif ((res = zr->intr_counter_JPEGRepIRQ) != 0) {\r\nprintk(" JPEGRepIRQ:%d", res);\r\nnoerr++;\r\n}\r\nif (zr->JPEG_max_missed) {\r\nprintk(" JPEG delays: max=%d min=%d", zr->JPEG_max_missed,\r\nzr->JPEG_min_missed);\r\n}\r\nif (zr->END_event_missed) {\r\nprintk(" ENDs missed: %d", zr->END_event_missed);\r\n}\r\nprintk(" queue_state=%ld/%ld/%ld/%ld", zr->jpg_que_tail,\r\nzr->jpg_dma_tail, zr->jpg_dma_head, zr->jpg_que_head);\r\nif (!noerr) {\r\nprintk(": no interrupts detected.");\r\n}\r\nprintk("\n");\r\n}\r\nvoid\r\nclear_interrupt_counters (struct zoran *zr)\r\n{\r\nzr->intr_counter_GIRQ1 = 0;\r\nzr->intr_counter_GIRQ0 = 0;\r\nzr->intr_counter_CodRepIRQ = 0;\r\nzr->intr_counter_JPEGRepIRQ = 0;\r\nzr->field_counter = 0;\r\nzr->IRQ1_in = 0;\r\nzr->IRQ1_out = 0;\r\nzr->JPEG_in = 0;\r\nzr->JPEG_out = 0;\r\nzr->JPEG_0 = 0;\r\nzr->JPEG_1 = 0;\r\nzr->END_event_missed = 0;\r\nzr->JPEG_missed = 0;\r\nzr->JPEG_max_missed = 0;\r\nzr->JPEG_min_missed = 0x7fffffff;\r\n}\r\nstatic u32\r\ncount_reset_interrupt (struct zoran *zr)\r\n{\r\nu32 isr;\r\nif ((isr = btread(ZR36057_ISR) & 0x78000000)) {\r\nif (isr & ZR36057_ISR_GIRQ1) {\r\nbtwrite(ZR36057_ISR_GIRQ1, ZR36057_ISR);\r\nzr->intr_counter_GIRQ1++;\r\n}\r\nif (isr & ZR36057_ISR_GIRQ0) {\r\nbtwrite(ZR36057_ISR_GIRQ0, ZR36057_ISR);\r\nzr->intr_counter_GIRQ0++;\r\n}\r\nif (isr & ZR36057_ISR_CodRepIRQ) {\r\nbtwrite(ZR36057_ISR_CodRepIRQ, ZR36057_ISR);\r\nzr->intr_counter_CodRepIRQ++;\r\n}\r\nif (isr & ZR36057_ISR_JPEGRepIRQ) {\r\nbtwrite(ZR36057_ISR_JPEGRepIRQ, ZR36057_ISR);\r\nzr->intr_counter_JPEGRepIRQ++;\r\n}\r\n}\r\nreturn isr;\r\n}\r\nvoid\r\njpeg_start (struct zoran *zr)\r\n{\r\nint reg;\r\nzr->frame_num = 0;\r\nbtwrite(ZR36057_JPC_P_Reset, ZR36057_JPC);\r\nbtand(~ZR36057_MCTCR_CFlush, ZR36057_MCTCR);\r\nbtor(ZR36057_JPC_CodTrnsEn, ZR36057_JPC);\r\nbtwrite(IRQ_MASK, ZR36057_ISR);\r\nbtwrite(zr->card.jpeg_int |\r\nZR36057_ICR_JPEGRepIRQ |\r\nZR36057_ICR_IntPinEn,\r\nZR36057_ICR);\r\nset_frame(zr, 0);\r\nreg = (zr->card.gpcs[1] << ZR36057_JCGI_JPEGuestID) |\r\n(0 << ZR36057_JCGI_JPEGuestReg);\r\nbtwrite(reg, ZR36057_JCGI);\r\nif (zr->card.video_vfe == CODEC_TYPE_ZR36016 &&\r\nzr->card.video_codec == CODEC_TYPE_ZR36050) {\r\nif (zr->vfe)\r\nzr36016_write(zr->vfe, 0, 1);\r\npost_office_write(zr, 0, 0, 0);\r\n}\r\nbtor(ZR36057_JPC_Active, ZR36057_JPC);\r\nbtor(ZR36057_JMC_Go_en, ZR36057_JMC);\r\nudelay(30);\r\nset_frame(zr, 1);\r\ndprintk(3, KERN_DEBUG "%s: jpeg_start\n", ZR_DEVNAME(zr));\r\n}\r\nvoid\r\nzr36057_enable_jpg (struct zoran *zr,\r\nenum zoran_codec_mode mode)\r\n{\r\nstruct vfe_settings cap;\r\nint field_size =\r\nzr->jpg_buffers.buffer_size / zr->jpg_settings.field_per_buff;\r\nzr->codec_mode = mode;\r\ncap.x = zr->jpg_settings.img_x;\r\ncap.y = zr->jpg_settings.img_y;\r\ncap.width = zr->jpg_settings.img_width;\r\ncap.height = zr->jpg_settings.img_height;\r\ncap.decimation =\r\nzr->jpg_settings.HorDcm | (zr->jpg_settings.VerDcm << 8);\r\ncap.quality = zr->jpg_settings.jpg_comp.quality;\r\nswitch (mode) {\r\ncase BUZ_MODE_MOTION_COMPRESS: {\r\nstruct jpeg_app_marker app;\r\nstruct jpeg_com_marker com;\r\nset_videobus_dir(zr, 0);\r\ndecoder_call(zr, video, s_stream, 1);\r\nencoder_call(zr, video, s_routing, 0, 0, 0);\r\njpeg_codec_sleep(zr, 0);\r\napp.appn = zr->jpg_settings.jpg_comp.APPn;\r\napp.len = zr->jpg_settings.jpg_comp.APP_len;\r\nmemcpy(app.data, zr->jpg_settings.jpg_comp.APP_data, 60);\r\nzr->codec->control(zr->codec, CODEC_S_JPEG_APP_DATA,\r\nsizeof(struct jpeg_app_marker), &app);\r\ncom.len = zr->jpg_settings.jpg_comp.COM_len;\r\nmemcpy(com.data, zr->jpg_settings.jpg_comp.COM_data, 60);\r\nzr->codec->control(zr->codec, CODEC_S_JPEG_COM_DATA,\r\nsizeof(struct jpeg_com_marker), &com);\r\nzr->codec->control(zr->codec, CODEC_S_JPEG_TDS_BYTE,\r\nsizeof(int), &field_size);\r\nzr->codec->set_video(zr->codec, zr->timing, &cap,\r\n&zr->card.vfe_pol);\r\nzr->codec->set_mode(zr->codec, CODEC_DO_COMPRESSION);\r\nif (zr->vfe) {\r\nzr->vfe->control(zr->vfe, CODEC_S_JPEG_TDS_BYTE,\r\nsizeof(int), &field_size);\r\nzr->vfe->set_video(zr->vfe, zr->timing, &cap,\r\n&zr->card.vfe_pol);\r\nzr->vfe->set_mode(zr->vfe, CODEC_DO_COMPRESSION);\r\n}\r\ninit_jpeg_queue(zr);\r\nzr36057_set_jpg(zr, mode);\r\nclear_interrupt_counters(zr);\r\ndprintk(2, KERN_INFO "%s: enable_jpg(MOTION_COMPRESS)\n",\r\nZR_DEVNAME(zr));\r\nbreak;\r\n}\r\ncase BUZ_MODE_MOTION_DECOMPRESS:\r\ndecoder_call(zr, video, s_stream, 0);\r\nset_videobus_dir(zr, 1);\r\nencoder_call(zr, video, s_routing, 1, 0, 0);\r\njpeg_codec_sleep(zr, 0);\r\nif (zr->vfe) {\r\nzr->vfe->set_video(zr->vfe, zr->timing, &cap,\r\n&zr->card.vfe_pol);\r\nzr->vfe->set_mode(zr->vfe, CODEC_DO_EXPANSION);\r\n}\r\nzr->codec->set_video(zr->codec, zr->timing, &cap,\r\n&zr->card.vfe_pol);\r\nzr->codec->set_mode(zr->codec, CODEC_DO_EXPANSION);\r\ninit_jpeg_queue(zr);\r\nzr36057_set_jpg(zr, mode);\r\nclear_interrupt_counters(zr);\r\ndprintk(2, KERN_INFO "%s: enable_jpg(MOTION_DECOMPRESS)\n",\r\nZR_DEVNAME(zr));\r\nbreak;\r\ncase BUZ_MODE_IDLE:\r\ndefault:\r\nbtand(~(zr->card.jpeg_int | ZR36057_ICR_JPEGRepIRQ),\r\nZR36057_ICR);\r\nbtwrite(zr->card.jpeg_int | ZR36057_ICR_JPEGRepIRQ,\r\nZR36057_ISR);\r\nbtand(~ZR36057_JMC_Go_en, ZR36057_JMC);\r\nmsleep(50);\r\nset_videobus_dir(zr, 0);\r\nset_frame(zr, 1);\r\nbtor(ZR36057_MCTCR_CFlush, ZR36057_MCTCR);\r\nbtwrite(0, ZR36057_JPC);\r\nbtand(~ZR36057_JMC_VFIFO_FB, ZR36057_JMC);\r\nbtand(~ZR36057_JMC_SyncMstr, ZR36057_JMC);\r\njpeg_codec_reset(zr);\r\njpeg_codec_sleep(zr, 1);\r\nzr36057_adjust_vfe(zr, mode);\r\ndecoder_call(zr, video, s_stream, 1);\r\nencoder_call(zr, video, s_routing, 0, 0, 0);\r\ndprintk(2, KERN_INFO "%s: enable_jpg(IDLE)\n", ZR_DEVNAME(zr));\r\nbreak;\r\n}\r\n}\r\nvoid\r\nzoran_feed_stat_com (struct zoran *zr)\r\n{\r\nint frame, i, max_stat_com;\r\nmax_stat_com =\r\n(zr->jpg_settings.TmpDcm ==\r\n1) ? BUZ_NUM_STAT_COM : (BUZ_NUM_STAT_COM >> 1);\r\nwhile ((zr->jpg_dma_head - zr->jpg_dma_tail) < max_stat_com &&\r\nzr->jpg_dma_head < zr->jpg_que_head) {\r\nframe = zr->jpg_pend[zr->jpg_dma_head & BUZ_MASK_FRAME];\r\nif (zr->jpg_settings.TmpDcm == 1) {\r\ni = (zr->jpg_dma_head -\r\nzr->jpg_err_shift) & BUZ_MASK_STAT_COM;\r\nif (!(zr->stat_com[i] & cpu_to_le32(1)))\r\nbreak;\r\nzr->stat_com[i] =\r\ncpu_to_le32(zr->jpg_buffers.buffer[frame].jpg.frag_tab_bus);\r\n} else {\r\ni = ((zr->jpg_dma_head -\r\nzr->jpg_err_shift) & 1) * 2;\r\nif (!(zr->stat_com[i] & cpu_to_le32(1)))\r\nbreak;\r\nzr->stat_com[i] =\r\ncpu_to_le32(zr->jpg_buffers.buffer[frame].jpg.frag_tab_bus);\r\nzr->stat_com[i + 1] =\r\ncpu_to_le32(zr->jpg_buffers.buffer[frame].jpg.frag_tab_bus);\r\n}\r\nzr->jpg_buffers.buffer[frame].state = BUZ_STATE_DMA;\r\nzr->jpg_dma_head++;\r\n}\r\nif (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS)\r\nzr->jpg_queued_num++;\r\n}\r\nstatic void\r\nzoran_reap_stat_com (struct zoran *zr)\r\n{\r\nint i;\r\nu32 stat_com;\r\nunsigned int seq;\r\nunsigned int dif;\r\nstruct zoran_buffer *buffer;\r\nint frame;\r\nif (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS) {\r\nzr->jpg_seq_num++;\r\n}\r\nwhile (zr->jpg_dma_tail < zr->jpg_dma_head) {\r\nif (zr->jpg_settings.TmpDcm == 1)\r\ni = (zr->jpg_dma_tail -\r\nzr->jpg_err_shift) & BUZ_MASK_STAT_COM;\r\nelse\r\ni = ((zr->jpg_dma_tail -\r\nzr->jpg_err_shift) & 1) * 2 + 1;\r\nstat_com = le32_to_cpu(zr->stat_com[i]);\r\nif ((stat_com & 1) == 0) {\r\nreturn;\r\n}\r\nframe = zr->jpg_pend[zr->jpg_dma_tail & BUZ_MASK_FRAME];\r\nbuffer = &zr->jpg_buffers.buffer[frame];\r\nv4l2_get_timestamp(&buffer->bs.timestamp);\r\nif (zr->codec_mode == BUZ_MODE_MOTION_COMPRESS) {\r\nbuffer->bs.length = (stat_com & 0x7fffff) >> 1;\r\nseq = ((stat_com >> 24) + zr->jpg_err_seq) & 0xff;\r\ndif = (seq - zr->jpg_seq_num) & 0xff;\r\nzr->jpg_seq_num += dif;\r\n} else {\r\nbuffer->bs.length = 0;\r\n}\r\nbuffer->bs.seq =\r\nzr->jpg_settings.TmpDcm ==\r\n2 ? (zr->jpg_seq_num >> 1) : zr->jpg_seq_num;\r\nbuffer->state = BUZ_STATE_DONE;\r\nzr->jpg_dma_tail++;\r\n}\r\n}\r\nstatic void zoran_restart(struct zoran *zr)\r\n{\r\nunsigned int status = 0;\r\nint mode;\r\nif (zr->codec_mode == BUZ_MODE_MOTION_COMPRESS) {\r\ndecoder_call(zr, video, g_input_status, &status);\r\nmode = CODEC_DO_COMPRESSION;\r\n} else {\r\nstatus = V4L2_IN_ST_NO_SIGNAL;\r\nmode = CODEC_DO_EXPANSION;\r\n}\r\nif (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS ||\r\n!(status & V4L2_IN_ST_NO_SIGNAL)) {\r\njpeg_codec_reset(zr);\r\nzr->codec->set_mode(zr->codec, mode);\r\nzr36057_set_jpg(zr, zr->codec_mode);\r\njpeg_start(zr);\r\nif (zr->num_errors <= 8)\r\ndprintk(2, KERN_INFO "%s: Restart\n",\r\nZR_DEVNAME(zr));\r\nzr->JPEG_missed = 0;\r\nzr->JPEG_error = 2;\r\n}\r\n}\r\nstatic void\r\nerror_handler (struct zoran *zr,\r\nu32 astat,\r\nu32 stat)\r\n{\r\nint i;\r\nif (zr->codec_mode != BUZ_MODE_MOTION_COMPRESS &&\r\nzr->codec_mode != BUZ_MODE_MOTION_DECOMPRESS) {\r\nreturn;\r\n}\r\nif ((stat & 1) == 0 &&\r\nzr->codec_mode == BUZ_MODE_MOTION_COMPRESS &&\r\nzr->jpg_dma_tail - zr->jpg_que_tail >= zr->jpg_buffers.num_buffers) {\r\nzoran_reap_stat_com(zr);\r\nzoran_feed_stat_com(zr);\r\nwake_up_interruptible(&zr->jpg_capq);\r\nzr->JPEG_missed = 0;\r\nreturn;\r\n}\r\nif (zr->JPEG_error == 1) {\r\nzoran_restart(zr);\r\nreturn;\r\n}\r\nbtand(~ZR36057_JMC_Go_en, ZR36057_JMC);\r\nudelay(1);\r\nstat = stat | (post_office_read(zr, 7, 0) & 3) << 8;\r\nbtwrite(0, ZR36057_JPC);\r\nbtor(ZR36057_MCTCR_CFlush, ZR36057_MCTCR);\r\njpeg_codec_reset(zr);\r\njpeg_codec_sleep(zr, 1);\r\nzr->JPEG_error = 1;\r\nzr->num_errors++;\r\nif (zr36067_debug > 1 && zr->num_errors <= 8) {\r\nlong frame;\r\nint j;\r\nframe = zr->jpg_pend[zr->jpg_dma_tail & BUZ_MASK_FRAME];\r\nprintk(KERN_ERR\r\n"%s: JPEG error stat=0x%08x(0x%08x) queue_state=%ld/%ld/%ld/%ld seq=%ld frame=%ld. Codec stopped. ",\r\nZR_DEVNAME(zr), stat, zr->last_isr,\r\nzr->jpg_que_tail, zr->jpg_dma_tail,\r\nzr->jpg_dma_head, zr->jpg_que_head,\r\nzr->jpg_seq_num, frame);\r\nprintk(KERN_INFO "stat_com frames:");\r\nfor (j = 0; j < BUZ_NUM_STAT_COM; j++) {\r\nfor (i = 0; i < zr->jpg_buffers.num_buffers; i++) {\r\nif (le32_to_cpu(zr->stat_com[j]) == zr->jpg_buffers.buffer[i].jpg.frag_tab_bus)\r\nprintk(KERN_CONT "% d->%d", j, i);\r\n}\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nif (zr->jpg_settings.TmpDcm == 1)\r\ni = (zr->jpg_dma_tail - zr->jpg_err_shift) & BUZ_MASK_STAT_COM;\r\nelse\r\ni = ((zr->jpg_dma_tail - zr->jpg_err_shift) & 1) * 2;\r\nif (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS) {\r\nzr->stat_com[i] |= cpu_to_le32(1);\r\nif (zr->jpg_settings.TmpDcm != 1)\r\nzr->stat_com[i + 1] |= cpu_to_le32(1);\r\nzoran_reap_stat_com(zr);\r\nzoran_feed_stat_com(zr);\r\nwake_up_interruptible(&zr->jpg_capq);\r\nif (zr->jpg_settings.TmpDcm == 1)\r\ni = (zr->jpg_dma_tail - zr->jpg_err_shift) & BUZ_MASK_STAT_COM;\r\nelse\r\ni = ((zr->jpg_dma_tail - zr->jpg_err_shift) & 1) * 2;\r\n}\r\nif (i) {\r\nint j;\r\n__le32 bus_addr[BUZ_NUM_STAT_COM];\r\nmemcpy(bus_addr, zr->stat_com, sizeof(bus_addr));\r\nfor (j = 0; j < BUZ_NUM_STAT_COM; j++)\r\nzr->stat_com[j] = bus_addr[(i + j) & BUZ_MASK_STAT_COM];\r\nzr->jpg_err_shift += i;\r\nzr->jpg_err_shift &= BUZ_MASK_STAT_COM;\r\n}\r\nif (zr->codec_mode == BUZ_MODE_MOTION_COMPRESS)\r\nzr->jpg_err_seq = zr->jpg_seq_num;\r\nzoran_restart(zr);\r\n}\r\nirqreturn_t\r\nzoran_irq (int irq,\r\nvoid *dev_id)\r\n{\r\nu32 stat, astat;\r\nint count;\r\nstruct zoran *zr;\r\nunsigned long flags;\r\nzr = dev_id;\r\ncount = 0;\r\nif (zr->testing) {\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nwhile ((stat = count_reset_interrupt(zr))) {\r\nif (count++ > 100) {\r\nbtand(~ZR36057_ICR_IntPinEn, ZR36057_ICR);\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: IRQ lockup while testing, isr=0x%08x, cleared int mask\n",\r\nZR_DEVNAME(zr), stat);\r\nwake_up_interruptible(&zr->test_q);\r\n}\r\n}\r\nzr->last_isr = stat;\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nwhile (1) {\r\nstat = count_reset_interrupt(zr);\r\nastat = stat & IRQ_MASK;\r\nif (!astat) {\r\nbreak;\r\n}\r\ndprintk(4,\r\nKERN_DEBUG\r\n"zoran_irq: astat: 0x%08x, mask: 0x%08x\n",\r\nastat, btread(ZR36057_ICR));\r\nif (astat & zr->card.vsync_int) {\r\nif (zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS ||\r\nzr->codec_mode == BUZ_MODE_MOTION_COMPRESS) {\r\nzr->JPEG_missed++;\r\n}\r\nif (zr->v4l_memgrab_active) {\r\nif ((btread(ZR36057_VSSFGR) & ZR36057_VSSFGR_SnapShot) == 0)\r\ndprintk(1,\r\nKERN_WARNING\r\n"%s: BuzIRQ with SnapShot off ???\n",\r\nZR_DEVNAME(zr));\r\nif (zr->v4l_grab_frame != NO_GRAB_ACTIVE) {\r\nif ((btread(ZR36057_VSSFGR) & ZR36057_VSSFGR_FrameGrab) == 0) {\r\nzr->v4l_buffers.buffer[zr->v4l_grab_frame].state = BUZ_STATE_DONE;\r\nzr->v4l_buffers.buffer[zr->v4l_grab_frame].bs.seq = zr->v4l_grab_seq;\r\nv4l2_get_timestamp(&zr->v4l_buffers.buffer[zr->v4l_grab_frame].bs.timestamp);\r\nzr->v4l_grab_frame = NO_GRAB_ACTIVE;\r\nzr->v4l_pend_tail++;\r\n}\r\n}\r\nif (zr->v4l_grab_frame == NO_GRAB_ACTIVE)\r\nwake_up_interruptible(&zr->v4l_capq);\r\nif (zr->v4l_grab_frame == NO_GRAB_ACTIVE &&\r\nzr->v4l_pend_tail != zr->v4l_pend_head) {\r\nint frame = zr->v4l_pend[zr->v4l_pend_tail & V4L_MASK_FRAME];\r\nu32 reg;\r\nzr->v4l_grab_frame = frame;\r\nreg = zr->v4l_buffers.buffer[frame].v4l.fbuffer_bus;\r\nbtwrite(reg, ZR36057_VDTR);\r\nif (zr->v4l_settings.height > BUZ_MAX_HEIGHT / 2)\r\nreg += zr->v4l_settings.bytesperline;\r\nbtwrite(reg, ZR36057_VDBR);\r\nreg = 0;\r\nif (zr->v4l_settings.height > BUZ_MAX_HEIGHT / 2)\r\nreg += zr->v4l_settings.bytesperline;\r\nreg = (reg << ZR36057_VSSFGR_DispStride);\r\nreg |= ZR36057_VSSFGR_VidOvf;\r\nreg |= ZR36057_VSSFGR_SnapShot;\r\nreg |= ZR36057_VSSFGR_FrameGrab;\r\nbtwrite(reg, ZR36057_VSSFGR);\r\nbtor(ZR36057_VDCR_VidEn,\r\nZR36057_VDCR);\r\n}\r\n}\r\nzr->v4l_grab_seq++;\r\n}\r\n#if (IRQ_MASK & ZR36057_ISR_CodRepIRQ)\r\nif (astat & ZR36057_ISR_CodRepIRQ) {\r\nzr->intr_counter_CodRepIRQ++;\r\nIDEBUG(printk(KERN_DEBUG "%s: ZR36057_ISR_CodRepIRQ\n",\r\nZR_DEVNAME(zr)));\r\nbtand(~ZR36057_ICR_CodRepIRQ, ZR36057_ICR);\r\n}\r\n#endif\r\n#if (IRQ_MASK & ZR36057_ISR_JPEGRepIRQ)\r\nif ((astat & ZR36057_ISR_JPEGRepIRQ) &&\r\n(zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS ||\r\nzr->codec_mode == BUZ_MODE_MOTION_COMPRESS)) {\r\nif (zr36067_debug > 1 && (!zr->frame_num || zr->JPEG_error)) {\r\nchar sv[BUZ_NUM_STAT_COM + 1];\r\nint i;\r\nprintk(KERN_INFO\r\n"%s: first frame ready: state=0x%08x odd_even=%d field_per_buff=%d delay=%d\n",\r\nZR_DEVNAME(zr), stat,\r\nzr->jpg_settings.odd_even,\r\nzr->jpg_settings.field_per_buff,\r\nzr->JPEG_missed);\r\nfor (i = 0; i < BUZ_NUM_STAT_COM; i++)\r\nsv[i] = le32_to_cpu(zr->stat_com[i]) & 1 ? '1' : '0';\r\nsv[BUZ_NUM_STAT_COM] = 0;\r\nprintk(KERN_INFO\r\n"%s: stat_com=%s queue_state=%ld/%ld/%ld/%ld\n",\r\nZR_DEVNAME(zr), sv,\r\nzr->jpg_que_tail,\r\nzr->jpg_dma_tail,\r\nzr->jpg_dma_head,\r\nzr->jpg_que_head);\r\n} else {\r\nif (zr->JPEG_missed > zr->JPEG_max_missed)\r\nzr->JPEG_max_missed = zr->JPEG_missed;\r\nif (zr->JPEG_missed < zr->JPEG_min_missed)\r\nzr->JPEG_min_missed = zr->JPEG_missed;\r\n}\r\nif (zr36067_debug > 2 && zr->frame_num < 6) {\r\nint i;\r\nprintk(KERN_INFO "%s: seq=%ld stat_com:",\r\nZR_DEVNAME(zr), zr->jpg_seq_num);\r\nfor (i = 0; i < 4; i++) {\r\nprintk(KERN_CONT " %08x",\r\nle32_to_cpu(zr->stat_com[i]));\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nzr->frame_num++;\r\nzr->JPEG_missed = 0;\r\nzr->JPEG_error = 0;\r\nzoran_reap_stat_com(zr);\r\nzoran_feed_stat_com(zr);\r\nwake_up_interruptible(&zr->jpg_capq);\r\n}\r\n#endif\r\nif ((astat & zr->card.jpeg_int) ||\r\nzr->JPEG_missed > 25 ||\r\nzr->JPEG_error == 1 ||\r\n((zr->codec_mode == BUZ_MODE_MOTION_DECOMPRESS) &&\r\n(zr->frame_num && (zr->JPEG_missed > zr->jpg_settings.field_per_buff)))) {\r\nerror_handler(zr, astat, stat);\r\n}\r\ncount++;\r\nif (count > 10) {\r\ndprintk(2, KERN_WARNING "%s: irq loop %d\n",\r\nZR_DEVNAME(zr), count);\r\nif (count > 20) {\r\nbtand(~ZR36057_ICR_IntPinEn, ZR36057_ICR);\r\ndprintk(2,\r\nKERN_ERR\r\n"%s: IRQ lockup, cleared int mask\n",\r\nZR_DEVNAME(zr));\r\nbreak;\r\n}\r\n}\r\nzr->last_isr = stat;\r\n}\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid\r\nzoran_set_pci_master (struct zoran *zr,\r\nint set_master)\r\n{\r\nif (set_master) {\r\npci_set_master(zr->pci_dev);\r\n} else {\r\nu16 command;\r\npci_read_config_word(zr->pci_dev, PCI_COMMAND, &command);\r\ncommand &= ~PCI_COMMAND_MASTER;\r\npci_write_config_word(zr->pci_dev, PCI_COMMAND, command);\r\n}\r\n}\r\nvoid\r\nzoran_init_hardware (struct zoran *zr)\r\n{\r\nzoran_set_pci_master(zr, 1);\r\nif (zr->card.init) {\r\nzr->card.init(zr);\r\n}\r\ndecoder_call(zr, core, init, 0);\r\ndecoder_call(zr, video, s_std, zr->norm);\r\ndecoder_call(zr, video, s_routing,\r\nzr->card.input[zr->input].muxsel, 0, 0);\r\nencoder_call(zr, core, init, 0);\r\nencoder_call(zr, video, s_std_output, zr->norm);\r\nencoder_call(zr, video, s_routing, 0, 0, 0);\r\njpeg_codec_sleep(zr, 1);\r\njpeg_codec_sleep(zr, 0);\r\nzr36057_init_vfe(zr);\r\nzr36057_enable_jpg(zr, BUZ_MODE_IDLE);\r\nbtwrite(IRQ_MASK, ZR36057_ISR);\r\n}\r\nvoid\r\nzr36057_restart (struct zoran *zr)\r\n{\r\nbtwrite(0, ZR36057_SPGPPCR);\r\nmdelay(1);\r\nbtor(ZR36057_SPGPPCR_SoftReset, ZR36057_SPGPPCR);\r\nmdelay(1);\r\nbtwrite(0, ZR36057_JPC);\r\nbtwrite(ZR36057_SPGPPCR_SoftReset | 0, ZR36057_SPGPPCR);\r\nbtwrite((0x81 << 24) | 0x8888, ZR36057_GPPGCR1);\r\n}\r\nstatic void\r\nzr36057_init_vfe (struct zoran *zr)\r\n{\r\nu32 reg;\r\nreg = btread(ZR36057_VFESPFR);\r\nreg |= ZR36057_VFESPFR_LittleEndian;\r\nreg &= ~ZR36057_VFESPFR_VCLKPol;\r\nreg |= ZR36057_VFESPFR_ExtFl;\r\nreg |= ZR36057_VFESPFR_TopField;\r\nbtwrite(reg, ZR36057_VFESPFR);\r\nreg = btread(ZR36057_VDCR);\r\nif (pci_pci_problems & PCIPCI_TRITON)\r\nreg &= ~ZR36057_VDCR_Triton;\r\nelse\r\nreg |= ZR36057_VDCR_Triton;\r\nbtwrite(reg, ZR36057_VDCR);\r\n}
