static inline struct berlin_pwm_chip *to_berlin_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct berlin_pwm_chip, chip);\r\n}\r\nstatic inline u32 berlin_pwm_readl(struct berlin_pwm_chip *chip,\r\nunsigned int channel, unsigned long offset)\r\n{\r\nreturn readl_relaxed(chip->base + channel * 0x10 + offset);\r\n}\r\nstatic inline void berlin_pwm_writel(struct berlin_pwm_chip *chip,\r\nunsigned int channel, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel_relaxed(value, chip->base + channel * 0x10 + offset);\r\n}\r\nstatic int berlin_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm_dev,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct berlin_pwm_chip *pwm = to_berlin_pwm_chip(chip);\r\nunsigned int prescale;\r\nu32 value, duty, period;\r\nu64 cycles, tmp;\r\ncycles = clk_get_rate(pwm->clk);\r\ncycles *= period_ns;\r\ndo_div(cycles, NSEC_PER_SEC);\r\nfor (prescale = 0; prescale < ARRAY_SIZE(prescaler_table); prescale++) {\r\ntmp = cycles;\r\ndo_div(tmp, prescaler_table[prescale]);\r\nif (tmp <= BERLIN_PWM_MAX_TCNT)\r\nbreak;\r\n}\r\nif (tmp > BERLIN_PWM_MAX_TCNT)\r\nreturn -ERANGE;\r\nperiod = tmp;\r\ncycles = tmp * duty_ns;\r\ndo_div(cycles, period_ns);\r\nduty = cycles;\r\nvalue = berlin_pwm_readl(pwm, pwm_dev->hwpwm, BERLIN_PWM_CONTROL);\r\nvalue &= ~BERLIN_PWM_PRESCALE_MASK;\r\nvalue |= prescale;\r\nberlin_pwm_writel(pwm, pwm_dev->hwpwm, value, BERLIN_PWM_CONTROL);\r\nberlin_pwm_writel(pwm, pwm_dev->hwpwm, duty, BERLIN_PWM_DUTY);\r\nberlin_pwm_writel(pwm, pwm_dev->hwpwm, period, BERLIN_PWM_TCNT);\r\nreturn 0;\r\n}\r\nstatic int berlin_pwm_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm_dev,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct berlin_pwm_chip *pwm = to_berlin_pwm_chip(chip);\r\nu32 value;\r\nvalue = berlin_pwm_readl(pwm, pwm_dev->hwpwm, BERLIN_PWM_CONTROL);\r\nif (polarity == PWM_POLARITY_NORMAL)\r\nvalue &= ~BERLIN_PWM_INVERT_POLARITY;\r\nelse\r\nvalue |= BERLIN_PWM_INVERT_POLARITY;\r\nberlin_pwm_writel(pwm, pwm_dev->hwpwm, value, BERLIN_PWM_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int berlin_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm_dev)\r\n{\r\nstruct berlin_pwm_chip *pwm = to_berlin_pwm_chip(chip);\r\nu32 value;\r\nvalue = berlin_pwm_readl(pwm, pwm_dev->hwpwm, BERLIN_PWM_EN);\r\nvalue |= BERLIN_PWM_ENABLE;\r\nberlin_pwm_writel(pwm, pwm_dev->hwpwm, value, BERLIN_PWM_EN);\r\nreturn 0;\r\n}\r\nstatic void berlin_pwm_disable(struct pwm_chip *chip,\r\nstruct pwm_device *pwm_dev)\r\n{\r\nstruct berlin_pwm_chip *pwm = to_berlin_pwm_chip(chip);\r\nu32 value;\r\nvalue = berlin_pwm_readl(pwm, pwm_dev->hwpwm, BERLIN_PWM_EN);\r\nvalue &= ~BERLIN_PWM_ENABLE;\r\nberlin_pwm_writel(pwm, pwm_dev->hwpwm, value, BERLIN_PWM_EN);\r\n}\r\nstatic int berlin_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct berlin_pwm_chip *pwm;\r\nstruct resource *res;\r\nint ret;\r\npwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);\r\nif (!pwm)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pwm->base))\r\nreturn PTR_ERR(pwm->base);\r\npwm->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pwm->clk))\r\nreturn PTR_ERR(pwm->clk);\r\nret = clk_prepare_enable(pwm->clk);\r\nif (ret)\r\nreturn ret;\r\npwm->chip.dev = &pdev->dev;\r\npwm->chip.ops = &berlin_pwm_ops;\r\npwm->chip.base = -1;\r\npwm->chip.npwm = 4;\r\npwm->chip.can_sleep = true;\r\npwm->chip.of_xlate = of_pwm_xlate_with_flags;\r\npwm->chip.of_pwm_n_cells = 3;\r\nret = pwmchip_add(&pwm->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);\r\nclk_disable_unprepare(pwm->clk);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pwm);\r\nreturn 0;\r\n}\r\nstatic int berlin_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct berlin_pwm_chip *pwm = platform_get_drvdata(pdev);\r\nint ret;\r\nret = pwmchip_remove(&pwm->chip);\r\nclk_disable_unprepare(pwm->clk);\r\nreturn ret;\r\n}
