static ssize_t show_card(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vfd = to_video_device(cd);\r\nstruct bttv *btv = video_get_drvdata(vfd);\r\nreturn sprintf(buf, "%d\n", btv ? btv->c.type : UNSET);\r\n}\r\nstatic void request_module_async(struct work_struct *work)\r\n{\r\nrequest_module("dvb-bt8xx");\r\n}\r\nstatic void request_modules(struct bttv *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct bttv *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nstatic\r\nint check_alloc_btres_lock(struct bttv *btv, struct bttv_fh *fh, int bit)\r\n{\r\nint xbits;\r\nif (fh->resources & bit)\r\nreturn 1;\r\nxbits = bit;\r\nif (bit & (RESOURCE_VIDEO_READ | RESOURCE_VIDEO_STREAM))\r\nxbits |= RESOURCE_VIDEO_READ | RESOURCE_VIDEO_STREAM;\r\nif (btv->resources & xbits) {\r\ngoto fail;\r\n}\r\nif ((bit & VIDEO_RESOURCES)\r\n&& 0 == (btv->resources & VIDEO_RESOURCES)) {\r\n__s32 top = btv->crop[!!fh->do_crop].rect.top;\r\nif (btv->vbi_end > top)\r\ngoto fail;\r\nbtv->crop_start = top;\r\n} else if (bit & VBI_RESOURCES) {\r\n__s32 end = fh->vbi_fmt.end;\r\nif (end > btv->crop_start)\r\ngoto fail;\r\nbtv->vbi_end = end;\r\n}\r\nfh->resources |= bit;\r\nbtv->resources |= bit;\r\nreturn 1;\r\nfail:\r\nreturn 0;\r\n}\r\nstatic\r\nint check_btres(struct bttv_fh *fh, int bit)\r\n{\r\nreturn (fh->resources & bit);\r\n}\r\nstatic\r\nint locked_btres(struct bttv *btv, int bit)\r\n{\r\nreturn (btv->resources & bit);\r\n}\r\nstatic void\r\ndisclaim_vbi_lines(struct bttv *btv)\r\n{\r\nbtv->vbi_end = 0;\r\n}\r\nstatic void\r\ndisclaim_video_lines(struct bttv *btv)\r\n{\r\nconst struct bttv_tvnorm *tvnorm;\r\nu8 crop;\r\ntvnorm = &bttv_tvnorms[btv->tvnorm];\r\nbtv->crop_start = tvnorm->cropcap.bounds.top\r\n+ tvnorm->cropcap.bounds.height;\r\ncrop = btread(BT848_E_CROP) | 0xc0;\r\nbtwrite(crop, BT848_E_CROP);\r\nbtwrite(0xfe, BT848_E_VDELAY_LO);\r\nbtwrite(crop, BT848_O_CROP);\r\nbtwrite(0xfe, BT848_O_VDELAY_LO);\r\n}\r\nstatic\r\nvoid free_btres_lock(struct bttv *btv, struct bttv_fh *fh, int bits)\r\n{\r\nif ((fh->resources & bits) != bits) {\r\npr_err("BUG! (btres)\n");\r\n}\r\nfh->resources &= ~bits;\r\nbtv->resources &= ~bits;\r\nbits = btv->resources;\r\nif (0 == (bits & VIDEO_RESOURCES))\r\ndisclaim_video_lines(btv);\r\nif (0 == (bits & VBI_RESOURCES))\r\ndisclaim_vbi_lines(btv);\r\n}\r\nstatic void set_pll_freq(struct bttv *btv, unsigned int fin, unsigned int fout)\r\n{\r\nunsigned char fl, fh, fi;\r\nfin/=4;\r\nfout/=4;\r\nfout*=12;\r\nfi=fout/fin;\r\nfout=(fout%fin)*256;\r\nfh=fout/fin;\r\nfout=(fout%fin)*256;\r\nfl=fout/fin;\r\nbtwrite(fl, BT848_PLL_F_LO);\r\nbtwrite(fh, BT848_PLL_F_HI);\r\nbtwrite(fi|BT848_PLL_X, BT848_PLL_XCI);\r\n}\r\nstatic void set_pll(struct bttv *btv)\r\n{\r\nint i;\r\nif (!btv->pll.pll_crystal)\r\nreturn;\r\nif (btv->pll.pll_ofreq == btv->pll.pll_current) {\r\ndprintk("%d: PLL: no change required\n", btv->c.nr);\r\nreturn;\r\n}\r\nif (btv->pll.pll_ifreq == btv->pll.pll_ofreq) {\r\nif (btv->pll.pll_current == 0)\r\nreturn;\r\nif (bttv_verbose)\r\npr_info("%d: PLL can sleep, using XTAL (%d)\n",\r\nbtv->c.nr, btv->pll.pll_ifreq);\r\nbtwrite(0x00,BT848_TGCTRL);\r\nbtwrite(0x00,BT848_PLL_XCI);\r\nbtv->pll.pll_current = 0;\r\nreturn;\r\n}\r\nif (bttv_verbose)\r\npr_info("%d: Setting PLL: %d => %d (needs up to 100ms)\n",\r\nbtv->c.nr,\r\nbtv->pll.pll_ifreq, btv->pll.pll_ofreq);\r\nset_pll_freq(btv, btv->pll.pll_ifreq, btv->pll.pll_ofreq);\r\nfor (i=0; i<10; i++) {\r\nmsleep(10);\r\nif (btread(BT848_DSTATUS) & BT848_DSTATUS_PLOCK) {\r\nbtwrite(0,BT848_DSTATUS);\r\n} else {\r\nbtwrite(0x08,BT848_TGCTRL);\r\nbtv->pll.pll_current = btv->pll.pll_ofreq;\r\nif (bttv_verbose)\r\npr_info("PLL set ok\n");\r\nreturn;\r\n}\r\n}\r\nbtv->pll.pll_current = -1;\r\nif (bttv_verbose)\r\npr_info("Setting PLL failed\n");\r\nreturn;\r\n}\r\nstatic void bt848A_set_timing(struct bttv *btv)\r\n{\r\nint i, len;\r\nint table_idx = bttv_tvnorms[btv->tvnorm].sram;\r\nint fsc = bttv_tvnorms[btv->tvnorm].Fsc;\r\nif (btv->input == btv->dig) {\r\ndprintk("%d: load digital timing table (table_idx=%d)\n",\r\nbtv->c.nr,table_idx);\r\nbtwrite(0x00, BT848_TGCTRL);\r\nbtwrite(0x02, BT848_TGCTRL);\r\nbtwrite(0x00, BT848_TGCTRL);\r\nlen=SRAM_Table[table_idx][0];\r\nfor(i = 1; i <= len; i++)\r\nbtwrite(SRAM_Table[table_idx][i],BT848_TGLB);\r\nbtv->pll.pll_ofreq = 27000000;\r\nset_pll(btv);\r\nbtwrite(0x11, BT848_TGCTRL);\r\nbtwrite(0x41, BT848_DVSIF);\r\n} else {\r\nbtv->pll.pll_ofreq = fsc;\r\nset_pll(btv);\r\nbtwrite(0x0, BT848_DVSIF);\r\n}\r\n}\r\nstatic void bt848_bright(struct bttv *btv, int bright)\r\n{\r\nint value;\r\nbtv->bright = bright;\r\nvalue = (bright >> 8) - 128;\r\nbtwrite(value & 0xff, BT848_BRIGHT);\r\n}\r\nstatic void bt848_hue(struct bttv *btv, int hue)\r\n{\r\nint value;\r\nbtv->hue = hue;\r\nvalue = (hue >> 8) - 128;\r\nbtwrite(value & 0xff, BT848_HUE);\r\n}\r\nstatic void bt848_contrast(struct bttv *btv, int cont)\r\n{\r\nint value,hibit;\r\nbtv->contrast = cont;\r\nvalue = (cont >> 7);\r\nhibit = (value >> 6) & 4;\r\nbtwrite(value & 0xff, BT848_CONTRAST_LO);\r\nbtaor(hibit, ~4, BT848_E_CONTROL);\r\nbtaor(hibit, ~4, BT848_O_CONTROL);\r\n}\r\nstatic void bt848_sat(struct bttv *btv, int color)\r\n{\r\nint val_u,val_v,hibits;\r\nbtv->saturation = color;\r\nval_u = ((color * btv->opt_uv_ratio) / 50) >> 7;\r\nval_v = (((color * (100 - btv->opt_uv_ratio) / 50) >>7)*180L)/254;\r\nhibits = (val_u >> 7) & 2;\r\nhibits |= (val_v >> 8) & 1;\r\nbtwrite(val_u & 0xff, BT848_SAT_U_LO);\r\nbtwrite(val_v & 0xff, BT848_SAT_V_LO);\r\nbtaor(hibits, ~3, BT848_E_CONTROL);\r\nbtaor(hibits, ~3, BT848_O_CONTROL);\r\n}\r\nstatic int\r\nvideo_mux(struct bttv *btv, unsigned int input)\r\n{\r\nint mux,mask2;\r\nif (input >= bttv_tvcards[btv->c.type].video_inputs)\r\nreturn -EINVAL;\r\nmask2 = bttv_tvcards[btv->c.type].gpiomask2;\r\nif (mask2)\r\ngpio_inout(mask2,mask2);\r\nif (input == btv->svhs) {\r\nbtor(BT848_CONTROL_COMP, BT848_E_CONTROL);\r\nbtor(BT848_CONTROL_COMP, BT848_O_CONTROL);\r\n} else {\r\nbtand(~BT848_CONTROL_COMP, BT848_E_CONTROL);\r\nbtand(~BT848_CONTROL_COMP, BT848_O_CONTROL);\r\n}\r\nmux = bttv_muxsel(btv, input);\r\nbtaor(mux<<5, ~(3<<5), BT848_IFORM);\r\ndprintk("%d: video mux: input=%d mux=%d\n", btv->c.nr, input, mux);\r\nif(bttv_tvcards[btv->c.type].muxsel_hook)\r\nbttv_tvcards[btv->c.type].muxsel_hook (btv, input);\r\nreturn 0;\r\n}\r\nstatic void\r\naudio_mux_gpio(struct bttv *btv, int input, int mute)\r\n{\r\nint gpio_val, signal, mute_gpio;\r\ngpio_inout(bttv_tvcards[btv->c.type].gpiomask,\r\nbttv_tvcards[btv->c.type].gpiomask);\r\nsignal = btread(BT848_DSTATUS) & BT848_DSTATUS_HLOC;\r\nmute_gpio = mute || (btv->opt_automute && (!signal || !btv->users)\r\n&& !btv->has_radio_tuner);\r\nif (mute_gpio)\r\ngpio_val = bttv_tvcards[btv->c.type].gpiomute;\r\nelse\r\ngpio_val = bttv_tvcards[btv->c.type].gpiomux[input];\r\nswitch (btv->c.type) {\r\ncase BTTV_BOARD_VOODOOTV_FM:\r\ncase BTTV_BOARD_VOODOOTV_200:\r\ngpio_val = bttv_tda9880_setnorm(btv, gpio_val);\r\nbreak;\r\ndefault:\r\ngpio_bits(bttv_tvcards[btv->c.type].gpiomask, gpio_val);\r\n}\r\nif (bttv_gpio)\r\nbttv_gpio_tracking(btv, audio_modes[mute_gpio ? 4 : input]);\r\n}\r\nstatic int\r\naudio_mute(struct bttv *btv, int mute)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\naudio_mux_gpio(btv, btv->audio_input, mute);\r\nif (btv->sd_msp34xx) {\r\nctrl = v4l2_ctrl_find(btv->sd_msp34xx->ctrl_handler, V4L2_CID_AUDIO_MUTE);\r\nif (ctrl)\r\nv4l2_ctrl_s_ctrl(ctrl, mute);\r\n}\r\nif (btv->sd_tvaudio) {\r\nctrl = v4l2_ctrl_find(btv->sd_tvaudio->ctrl_handler, V4L2_CID_AUDIO_MUTE);\r\nif (ctrl)\r\nv4l2_ctrl_s_ctrl(ctrl, mute);\r\n}\r\nif (btv->sd_tda7432) {\r\nctrl = v4l2_ctrl_find(btv->sd_tda7432->ctrl_handler, V4L2_CID_AUDIO_MUTE);\r\nif (ctrl)\r\nv4l2_ctrl_s_ctrl(ctrl, mute);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\naudio_input(struct bttv *btv, int input)\r\n{\r\naudio_mux_gpio(btv, input, btv->mute);\r\nif (btv->sd_msp34xx) {\r\nu32 in;\r\nswitch (input) {\r\ncase TVAUDIO_INPUT_RADIO:\r\nif (btv->radio_uses_msp_demodulator) {\r\nin = MSP_INPUT_DEFAULT;\r\nbreak;\r\n}\r\nin = MSP_INPUT(MSP_IN_SCART2, MSP_IN_TUNER1,\r\nMSP_DSP_IN_SCART, MSP_DSP_IN_SCART);\r\nbreak;\r\ncase TVAUDIO_INPUT_EXTERN:\r\nin = MSP_INPUT(MSP_IN_SCART1, MSP_IN_TUNER1,\r\nMSP_DSP_IN_SCART, MSP_DSP_IN_SCART);\r\nbreak;\r\ncase TVAUDIO_INPUT_INTERN:\r\nin = MSP_INPUT(MSP_IN_SCART2, MSP_IN_TUNER1,\r\nMSP_DSP_IN_SCART, MSP_DSP_IN_SCART);\r\nbreak;\r\ncase TVAUDIO_INPUT_TUNER:\r\ndefault:\r\nif (btv->c.type == BTTV_BOARD_VOODOOTV_200)\r\nin = MSP_INPUT(MSP_IN_SCART1, MSP_IN_TUNER2, \\r\nMSP_DSP_IN_TUNER, MSP_DSP_IN_TUNER);\r\nelse\r\nin = MSP_INPUT_DEFAULT;\r\nbreak;\r\n}\r\nv4l2_subdev_call(btv->sd_msp34xx, audio, s_routing,\r\nin, MSP_OUTPUT_DEFAULT, 0);\r\n}\r\nif (btv->sd_tvaudio) {\r\nv4l2_subdev_call(btv->sd_tvaudio, audio, s_routing,\r\ninput, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbttv_crop_calc_limits(struct bttv_crop *c)\r\n{\r\nif (1) {\r\nc->min_scaled_width = 48;\r\nc->min_scaled_height = 32;\r\n} else {\r\nc->min_scaled_width =\r\n(max_t(unsigned int, 48, c->rect.width >> 4) + 3) & ~3;\r\nc->min_scaled_height =\r\nmax_t(unsigned int, 32, c->rect.height >> 4);\r\n}\r\nc->max_scaled_width = c->rect.width & ~3;\r\nc->max_scaled_height = c->rect.height;\r\n}\r\nstatic void\r\nbttv_crop_reset(struct bttv_crop *c, unsigned int norm)\r\n{\r\nc->rect = bttv_tvnorms[norm].cropcap.defrect;\r\nbttv_crop_calc_limits(c);\r\n}\r\nstatic int\r\nset_tvnorm(struct bttv *btv, unsigned int norm)\r\n{\r\nconst struct bttv_tvnorm *tvnorm;\r\nv4l2_std_id id;\r\nBUG_ON(norm >= BTTV_TVNORMS);\r\nBUG_ON(btv->tvnorm >= BTTV_TVNORMS);\r\ntvnorm = &bttv_tvnorms[norm];\r\nif (memcmp(&bttv_tvnorms[btv->tvnorm].cropcap, &tvnorm->cropcap,\r\nsizeof (tvnorm->cropcap))) {\r\nbttv_crop_reset(&btv->crop[0], norm);\r\nbtv->crop[1] = btv->crop[0];\r\nif (0 == (btv->resources & VIDEO_RESOURCES)) {\r\nbtv->crop_start = tvnorm->cropcap.bounds.top\r\n+ tvnorm->cropcap.bounds.height;\r\n}\r\n}\r\nbtv->tvnorm = norm;\r\nbtwrite(tvnorm->adelay, BT848_ADELAY);\r\nbtwrite(tvnorm->bdelay, BT848_BDELAY);\r\nbtaor(tvnorm->iform,~(BT848_IFORM_NORM|BT848_IFORM_XTBOTH),\r\nBT848_IFORM);\r\nbtwrite(tvnorm->vbipack, BT848_VBI_PACK_SIZE);\r\nbtwrite(1, BT848_VBI_PACK_DEL);\r\nbt848A_set_timing(btv);\r\nswitch (btv->c.type) {\r\ncase BTTV_BOARD_VOODOOTV_FM:\r\ncase BTTV_BOARD_VOODOOTV_200:\r\nbttv_tda9880_setnorm(btv, gpio_read());\r\nbreak;\r\n}\r\nid = tvnorm->v4l2_id;\r\nbttv_call_all(btv, video, s_std, id);\r\nreturn 0;\r\n}\r\nstatic void\r\nset_input(struct bttv *btv, unsigned int input, unsigned int norm)\r\n{\r\nunsigned long flags;\r\nbtv->input = input;\r\nif (irq_iswitch) {\r\nspin_lock_irqsave(&btv->s_lock,flags);\r\nif (btv->curr.frame_irq) {\r\nbtv->new_input = input;\r\n} else {\r\nvideo_mux(btv,input);\r\n}\r\nspin_unlock_irqrestore(&btv->s_lock,flags);\r\n} else {\r\nvideo_mux(btv,input);\r\n}\r\nbtv->audio_input = (btv->tuner_type != TUNER_ABSENT && input == 0) ?\r\nTVAUDIO_INPUT_TUNER : TVAUDIO_INPUT_EXTERN;\r\naudio_input(btv, btv->audio_input);\r\nset_tvnorm(btv, norm);\r\n}\r\nstatic void init_irqreg(struct bttv *btv)\r\n{\r\nbtwrite(0xfffffUL, BT848_INT_STAT);\r\nif (bttv_tvcards[btv->c.type].no_video) {\r\nbtwrite(BT848_INT_I2CDONE,\r\nBT848_INT_MASK);\r\n} else {\r\nbtwrite((btv->triton1) |\r\n(btv->gpioirq ? BT848_INT_GPINT : 0) |\r\nBT848_INT_SCERR |\r\n(fdsr ? BT848_INT_FDSR : 0) |\r\nBT848_INT_RISCI | BT848_INT_OCERR |\r\nBT848_INT_FMTCHG|BT848_INT_HLOCK|\r\nBT848_INT_I2CDONE,\r\nBT848_INT_MASK);\r\n}\r\n}\r\nstatic void init_bt848(struct bttv *btv)\r\n{\r\nif (bttv_tvcards[btv->c.type].no_video) {\r\ninit_irqreg(btv);\r\nreturn;\r\n}\r\nbtwrite(0x00, BT848_CAP_CTL);\r\nbtwrite(BT848_COLOR_CTL_GAMMA, BT848_COLOR_CTL);\r\nbtwrite(BT848_IFORM_XTAUTO | BT848_IFORM_AUTO, BT848_IFORM);\r\nbtwrite(BT848_GPIO_DMA_CTL_PKTP_32|\r\nBT848_GPIO_DMA_CTL_PLTP1_16|\r\nBT848_GPIO_DMA_CTL_PLTP23_16|\r\nBT848_GPIO_DMA_CTL_GPINTC|\r\nBT848_GPIO_DMA_CTL_GPINTI,\r\nBT848_GPIO_DMA_CTL);\r\nbtwrite(0x20, BT848_E_VSCALE_HI);\r\nbtwrite(0x20, BT848_O_VSCALE_HI);\r\nv4l2_ctrl_handler_setup(&btv->ctrl_handler);\r\ninit_irqreg(btv);\r\n}\r\nstatic void bttv_reinit_bt848(struct bttv *btv)\r\n{\r\nunsigned long flags;\r\nif (bttv_verbose)\r\npr_info("%d: reset, reinitialize\n", btv->c.nr);\r\nspin_lock_irqsave(&btv->s_lock,flags);\r\nbtv->errors=0;\r\nbttv_set_dma(btv,0);\r\nspin_unlock_irqrestore(&btv->s_lock,flags);\r\ninit_bt848(btv);\r\nbtv->pll.pll_current = -1;\r\nset_input(btv, btv->input, btv->tvnorm);\r\n}\r\nstatic int bttv_s_ctrl(struct v4l2_ctrl *c)\r\n{\r\nstruct bttv *btv = container_of(c->handler, struct bttv, ctrl_handler);\r\nint val;\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nbt848_bright(btv, c->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nbt848_hue(btv, c->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nbt848_contrast(btv, c->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nbt848_sat(btv, c->val);\r\nbreak;\r\ncase V4L2_CID_COLOR_KILLER:\r\nif (c->val) {\r\nbtor(BT848_SCLOOP_CKILL, BT848_E_SCLOOP);\r\nbtor(BT848_SCLOOP_CKILL, BT848_O_SCLOOP);\r\n} else {\r\nbtand(~BT848_SCLOOP_CKILL, BT848_E_SCLOOP);\r\nbtand(~BT848_SCLOOP_CKILL, BT848_O_SCLOOP);\r\n}\r\nbreak;\r\ncase V4L2_CID_AUDIO_MUTE:\r\naudio_mute(btv, c->val);\r\nbtv->mute = c->val;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nbtv->volume_gpio(btv, c->val);\r\nbreak;\r\ncase V4L2_CID_CHROMA_AGC:\r\nval = c->val ? BT848_SCLOOP_CAGC : 0;\r\nbtwrite(val, BT848_E_SCLOOP);\r\nbtwrite(val, BT848_O_SCLOOP);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_COMBFILTER:\r\nbtv->opt_combfilter = c->val;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_LUMAFILTER:\r\nif (c->val) {\r\nbtand(~BT848_CONTROL_LDEC, BT848_E_CONTROL);\r\nbtand(~BT848_CONTROL_LDEC, BT848_O_CONTROL);\r\n} else {\r\nbtor(BT848_CONTROL_LDEC, BT848_E_CONTROL);\r\nbtor(BT848_CONTROL_LDEC, BT848_O_CONTROL);\r\n}\r\nbreak;\r\ncase V4L2_CID_PRIVATE_AUTOMUTE:\r\nbtv->opt_automute = c->val;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_AGC_CRUSH:\r\nbtwrite(BT848_ADC_RESERVED |\r\n(c->val ? BT848_ADC_CRUSH : 0),\r\nBT848_ADC);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_VCR_HACK:\r\nbtv->opt_vcr_hack = c->val;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_WHITECRUSH_UPPER:\r\nbtwrite(c->val, BT848_WC_UP);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_WHITECRUSH_LOWER:\r\nbtwrite(c->val, BT848_WC_DOWN);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_UV_RATIO:\r\nbtv->opt_uv_ratio = c->val;\r\nbt848_sat(btv, btv->saturation);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_FULL_LUMA_RANGE:\r\nbtaor((c->val << 7), ~BT848_OFORM_RANGE, BT848_OFORM);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_CORING:\r\nbtaor((c->val << 5), ~BT848_OFORM_CORE32, BT848_OFORM);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid bttv_gpio_tracking(struct bttv *btv, char *comment)\r\n{\r\nunsigned int outbits, data;\r\noutbits = btread(BT848_GPIO_OUT_EN);\r\ndata = btread(BT848_GPIO_DATA);\r\npr_debug("%d: gpio: en=%08x, out=%08x in=%08x [%s]\n",\r\nbtv->c.nr, outbits, data & outbits, data & ~outbits, comment);\r\n}\r\nstatic void bttv_field_count(struct bttv *btv)\r\n{\r\nint need_count = 0;\r\nif (btv->users)\r\nneed_count++;\r\nif (need_count) {\r\nbtor(BT848_INT_VSYNC,BT848_INT_MASK);\r\n} else {\r\nbtand(~BT848_INT_VSYNC,BT848_INT_MASK);\r\nbtv->field_count = 0;\r\n}\r\n}\r\nstatic const struct bttv_format*\r\nformat_by_fourcc(int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < FORMATS; i++) {\r\nif (-1 == formats[i].fourcc)\r\ncontinue;\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nbttv_switch_overlay(struct bttv *btv, struct bttv_fh *fh,\r\nstruct bttv_buffer *new)\r\n{\r\nstruct bttv_buffer *old;\r\nunsigned long flags;\r\ndprintk("switch_overlay: enter [new=%p]\n", new);\r\nif (new)\r\nnew->vb.state = VIDEOBUF_DONE;\r\nspin_lock_irqsave(&btv->s_lock,flags);\r\nold = btv->screen;\r\nbtv->screen = new;\r\nbtv->loop_irq |= 1;\r\nbttv_set_dma(btv, 0x03);\r\nspin_unlock_irqrestore(&btv->s_lock,flags);\r\nif (NULL != old) {\r\ndprintk("switch_overlay: old=%p state is %d\n",\r\nold, old->vb.state);\r\nbttv_dma_free(&fh->cap,btv, old);\r\nkfree(old);\r\n}\r\nif (NULL == new)\r\nfree_btres_lock(btv,fh,RESOURCE_OVERLAY);\r\ndprintk("switch_overlay: done\n");\r\nreturn 0;\r\n}\r\nstatic int bttv_prepare_buffer(struct videobuf_queue *q,struct bttv *btv,\r\nstruct bttv_buffer *buf,\r\nconst struct bttv_format *fmt,\r\nunsigned int width, unsigned int height,\r\nenum v4l2_field field)\r\n{\r\nstruct bttv_fh *fh = q->priv_data;\r\nint redo_dma_risc = 0;\r\nstruct bttv_crop c;\r\nint norm;\r\nint rc;\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nif (fmt->btformat == BT848_COLOR_FMT_RAW) {\r\nwidth = RAW_BPL;\r\nheight = RAW_LINES*2;\r\nif (width*height > buf->vb.bsize)\r\nreturn -EINVAL;\r\nbuf->vb.size = buf->vb.bsize;\r\nnorm = btv->tvnorm;\r\nif (btv->vbi_end > bttv_tvnorms[norm].cropcap.defrect.top) {\r\nreturn -EINVAL;\r\n}\r\nc.rect = bttv_tvnorms[norm].cropcap.defrect;\r\n} else {\r\nnorm = btv->tvnorm;\r\nc = btv->crop[!!fh->do_crop];\r\nif (width < c.min_scaled_width ||\r\nwidth > c.max_scaled_width ||\r\nheight < c.min_scaled_height)\r\nreturn -EINVAL;\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_ALTERNATE:\r\nif (height * 2 > c.max_scaled_height)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nif (height > c.max_scaled_height)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nbuf->vb.size = (width * height * fmt->depth) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\n}\r\nif (buf->vb.width != width || buf->vb.height != height ||\r\nbuf->vb.field != field ||\r\nbuf->tvnorm != norm || buf->fmt != fmt ||\r\nbuf->crop.top != c.rect.top ||\r\nbuf->crop.left != c.rect.left ||\r\nbuf->crop.width != c.rect.width ||\r\nbuf->crop.height != c.rect.height) {\r\nbuf->vb.width = width;\r\nbuf->vb.height = height;\r\nbuf->vb.field = field;\r\nbuf->tvnorm = norm;\r\nbuf->fmt = fmt;\r\nbuf->crop = c.rect;\r\nredo_dma_risc = 1;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nredo_dma_risc = 1;\r\nif (0 != (rc = videobuf_iolock(q,&buf->vb,&btv->fbuf)))\r\ngoto fail;\r\n}\r\nif (redo_dma_risc)\r\nif (0 != (rc = bttv_buffer_risc(btv,buf)))\r\ngoto fail;\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nbttv_dma_free(q,btv,buf);\r\nreturn rc;\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)\r\n{\r\nstruct bttv_fh *fh = q->priv_data;\r\n*size = fh->fmt->depth*fh->width*fh->height >> 3;\r\nif (0 == *count)\r\n*count = gbuffers;\r\nif (*size * *count > gbuffers * gbufsize)\r\n*count = (gbuffers * gbufsize) / *size;\r\nreturn 0;\r\n}\r\nstatic int\r\nbuffer_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct bttv_buffer *buf = container_of(vb,struct bttv_buffer,vb);\r\nstruct bttv_fh *fh = q->priv_data;\r\nreturn bttv_prepare_buffer(q,fh->btv, buf, fh->fmt,\r\nfh->width, fh->height, field);\r\n}\r\nstatic void\r\nbuffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct bttv_buffer *buf = container_of(vb,struct bttv_buffer,vb);\r\nstruct bttv_fh *fh = q->priv_data;\r\nstruct bttv *btv = fh->btv;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue,&btv->capture);\r\nif (!btv->curr.frame_irq) {\r\nbtv->loop_irq |= 1;\r\nbttv_set_dma(btv, 0x03);\r\n}\r\n}\r\nstatic void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct bttv_buffer *buf = container_of(vb,struct bttv_buffer,vb);\r\nstruct bttv_fh *fh = q->priv_data;\r\nbttv_dma_free(q,fh->btv,buf);\r\n}\r\nstatic void radio_enable(struct bttv *btv)\r\n{\r\nif (!btv->has_radio_tuner) {\r\nbtv->has_radio_tuner = 1;\r\nbttv_call_all(btv, tuner, s_radio);\r\nbtv->audio_input = TVAUDIO_INPUT_RADIO;\r\naudio_input(btv, btv->audio_input);\r\n}\r\n}\r\nstatic int bttv_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nunsigned int i;\r\nfor (i = 0; i < BTTV_TVNORMS; i++)\r\nif (id & bttv_tvnorms[i].v4l2_id)\r\nbreak;\r\nif (i == BTTV_TVNORMS)\r\nreturn -EINVAL;\r\nbtv->std = id;\r\nset_tvnorm(btv, i);\r\nreturn 0;\r\n}\r\nstatic int bttv_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\n*id = btv->std;\r\nreturn 0;\r\n}\r\nstatic int bttv_querystd(struct file *file, void *f, v4l2_std_id *id)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nif (btread(BT848_DSTATUS) & BT848_DSTATUS_NUML)\r\n*id &= V4L2_STD_625_50;\r\nelse\r\n*id &= V4L2_STD_525_60;\r\nreturn 0;\r\n}\r\nstatic int bttv_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (i->index >= bttv_tvcards[btv->c.type].video_inputs)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\ni->audioset = 0;\r\nif (btv->tuner_type != TUNER_ABSENT && i->index == 0) {\r\nsprintf(i->name, "Television");\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->tuner = 0;\r\n} else if (i->index == btv->svhs) {\r\nsprintf(i->name, "S-Video");\r\n} else {\r\nsprintf(i->name, "Composite%d", i->index);\r\n}\r\nif (i->index == btv->input) {\r\n__u32 dstatus = btread(BT848_DSTATUS);\r\nif (0 == (dstatus & BT848_DSTATUS_PRES))\r\ni->status |= V4L2_IN_ST_NO_SIGNAL;\r\nif (0 == (dstatus & BT848_DSTATUS_HLOC))\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\n}\r\ni->std = BTTV_NORMS;\r\nreturn 0;\r\n}\r\nstatic int bttv_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\n*i = btv->input;\r\nreturn 0;\r\n}\r\nstatic int bttv_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (i >= bttv_tvcards[btv->c.type].video_inputs)\r\nreturn -EINVAL;\r\nset_input(btv, i, btv->tvnorm);\r\nreturn 0;\r\n}\r\nstatic int bttv_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (t->index)\r\nreturn -EINVAL;\r\nbttv_call_all(btv, tuner, s_tuner, t);\r\nif (btv->audio_mode_gpio) {\r\nstruct v4l2_tuner copy = *t;\r\nbtv->audio_mode_gpio(btv, &copy, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bttv_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nif (f->type == V4L2_TUNER_RADIO)\r\nradio_enable(btv);\r\nf->frequency = f->type == V4L2_TUNER_RADIO ?\r\nbtv->radio_freq : btv->tv_freq;\r\nreturn 0;\r\n}\r\nstatic void bttv_set_frequency(struct bttv *btv, const struct v4l2_frequency *f)\r\n{\r\nstruct v4l2_frequency new_freq = *f;\r\nbttv_call_all(btv, tuner, s_frequency, f);\r\nbttv_call_all(btv, tuner, g_frequency, &new_freq);\r\nif (new_freq.type == V4L2_TUNER_RADIO) {\r\nradio_enable(btv);\r\nbtv->radio_freq = new_freq.frequency;\r\nif (btv->has_tea575x) {\r\nbtv->tea.freq = btv->radio_freq;\r\nsnd_tea575x_set_freq(&btv->tea);\r\n}\r\n} else {\r\nbtv->tv_freq = new_freq.frequency;\r\n}\r\n}\r\nstatic int bttv_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nbttv_set_frequency(btv, f);\r\nreturn 0;\r\n}\r\nstatic int bttv_log_status(struct file *file, void *f)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nv4l2_ctrl_handler_log_status(vdev->ctrl_handler, btv->c.v4l2_dev.name);\r\nbttv_call_all(btv, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int bttv_g_register(struct file *file, void *f,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nreg->reg &= 0xfff;\r\nreg->val = btread(reg->reg);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int bttv_s_register(struct file *file, void *f,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nbtwrite(reg->val, reg->reg & 0xfff);\r\nreturn 0;\r\n}\r\nstatic void\r\nbttv_crop_adjust (struct bttv_crop * c,\r\nconst struct v4l2_rect * b,\r\n__s32 width,\r\n__s32 height,\r\nenum v4l2_field field)\r\n{\r\n__s32 frame_height = height << !V4L2_FIELD_HAS_BOTH(field);\r\n__s32 max_left;\r\n__s32 max_top;\r\nif (width < c->min_scaled_width) {\r\nc->rect.width = width * 16;\r\n} else if (width > c->max_scaled_width) {\r\nc->rect.width = width;\r\nmax_left = b->left + b->width - width;\r\nmax_left = min(max_left, (__s32) MAX_HDELAY);\r\nif (c->rect.left > max_left)\r\nc->rect.left = max_left;\r\n}\r\nif (height < c->min_scaled_height) {\r\nc->rect.height = height * 16;\r\n} else if (frame_height > c->max_scaled_height) {\r\nc->rect.height = (frame_height + 1) & ~1;\r\nmax_top = b->top + b->height - c->rect.height;\r\nif (c->rect.top > max_top)\r\nc->rect.top = max_top;\r\n}\r\nbttv_crop_calc_limits(c);\r\n}\r\nstatic int\r\nlimit_scaled_size_lock (struct bttv_fh * fh,\r\n__s32 * width,\r\n__s32 * height,\r\nenum v4l2_field field,\r\nunsigned int width_mask,\r\nunsigned int width_bias,\r\nint adjust_size,\r\nint adjust_crop)\r\n{\r\nstruct bttv *btv = fh->btv;\r\nconst struct v4l2_rect *b;\r\nstruct bttv_crop *c;\r\n__s32 min_width;\r\n__s32 min_height;\r\n__s32 max_width;\r\n__s32 max_height;\r\nint rc;\r\nBUG_ON((int) width_mask >= 0 ||\r\nwidth_bias >= (unsigned int) -width_mask);\r\nb = &bttv_tvnorms[btv->tvnorm].cropcap.bounds;\r\nc = &btv->crop[!!fh->do_crop];\r\nif (fh->do_crop\r\n&& adjust_size\r\n&& adjust_crop\r\n&& !locked_btres(btv, VIDEO_RESOURCES)) {\r\nmin_width = 48;\r\nmin_height = 32;\r\nmax_width = min_t(unsigned int, b->width, MAX_HACTIVE);\r\nmax_height = b->height;\r\nif (btv->vbi_end > b->top) {\r\nmax_height -= btv->vbi_end - b->top;\r\nrc = -EBUSY;\r\nif (min_height > max_height)\r\ngoto fail;\r\n}\r\n} else {\r\nrc = -EBUSY;\r\nif (btv->vbi_end > c->rect.top)\r\ngoto fail;\r\nmin_width = c->min_scaled_width;\r\nmin_height = c->min_scaled_height;\r\nmax_width = c->max_scaled_width;\r\nmax_height = c->max_scaled_height;\r\nadjust_crop = 0;\r\n}\r\nmin_width = (min_width - width_mask - 1) & width_mask;\r\nmax_width = max_width & width_mask;\r\nmin_height = min_height;\r\nmax_height >>= !V4L2_FIELD_HAS_BOTH(field);\r\nif (adjust_size) {\r\n*width = clamp(*width, min_width, max_width);\r\n*height = clamp(*height, min_height, max_height);\r\n*width = (*width + width_bias) & width_mask;\r\nif (adjust_crop) {\r\nbttv_crop_adjust(c, b, *width, *height, field);\r\nif (btv->vbi_end > c->rect.top) {\r\nc->rect.top = btv->vbi_end;\r\n}\r\n}\r\n} else {\r\nrc = -EINVAL;\r\nif (*width < min_width ||\r\n*height < min_height ||\r\n*width > max_width ||\r\n*height > max_height ||\r\n0 != (*width & ~width_mask))\r\ngoto fail;\r\n}\r\nrc = 0;\r\nfail:\r\nreturn rc;\r\n}\r\nstatic int\r\nverify_window_lock(struct bttv_fh *fh, struct v4l2_window *win,\r\nint adjust_size, int adjust_crop)\r\n{\r\nenum v4l2_field field;\r\nunsigned int width_mask;\r\nint rc;\r\nif (win->w.width < 48)\r\nwin->w.width = 48;\r\nif (win->w.height < 32)\r\nwin->w.height = 32;\r\nif (win->clipcount > 2048)\r\nwin->clipcount = 2048;\r\nwin->chromakey = 0;\r\nwin->global_alpha = 0;\r\nfield = win->field;\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nfield = V4L2_FIELD_ANY;\r\nbreak;\r\n}\r\nif (V4L2_FIELD_ANY == field) {\r\n__s32 height2;\r\nheight2 = fh->btv->crop[!!fh->do_crop].rect.height >> 1;\r\nfield = (win->w.height > height2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_TOP;\r\n}\r\nwin->field = field;\r\nif (NULL == fh->ovfmt)\r\nreturn -EINVAL;\r\nwidth_mask = ~0;\r\nswitch (fh->ovfmt->depth) {\r\ncase 8:\r\ncase 24:\r\nwidth_mask = ~3;\r\nbreak;\r\ncase 16:\r\nwidth_mask = ~1;\r\nbreak;\r\ncase 32:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nwin->w.width -= win->w.left & ~width_mask;\r\nwin->w.left = (win->w.left - width_mask - 1) & width_mask;\r\nrc = limit_scaled_size_lock(fh, &win->w.width, &win->w.height,\r\nfield, width_mask,\r\n0,\r\nadjust_size, adjust_crop);\r\nif (0 != rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int setup_window_lock(struct bttv_fh *fh, struct bttv *btv,\r\nstruct v4l2_window *win, int fixup)\r\n{\r\nstruct v4l2_clip *clips = NULL;\r\nint n,size,retval = 0;\r\nif (NULL == fh->ovfmt)\r\nreturn -EINVAL;\r\nif (!(fh->ovfmt->flags & FORMAT_FLAGS_PACKED))\r\nreturn -EINVAL;\r\nretval = verify_window_lock(fh, win,\r\nfixup,\r\nfixup);\r\nif (0 != retval)\r\nreturn retval;\r\nn = win->clipcount;\r\nsize = sizeof(*clips)*(n+4);\r\nclips = kmalloc(size,GFP_KERNEL);\r\nif (NULL == clips)\r\nreturn -ENOMEM;\r\nif (n > 0) {\r\nif (copy_from_user(clips,win->clips,sizeof(struct v4l2_clip)*n)) {\r\nkfree(clips);\r\nreturn -EFAULT;\r\n}\r\n}\r\nif (NULL != btv->fbuf.base)\r\nn = btcx_screen_clips(btv->fbuf.fmt.width, btv->fbuf.fmt.height,\r\n&win->w, clips, n);\r\nbtcx_sort_clips(clips,n);\r\nswitch (fh->ovfmt->depth) {\r\ncase 8:\r\ncase 24:\r\nbtcx_align(&win->w, clips, n, 3);\r\nbreak;\r\ncase 16:\r\nbtcx_align(&win->w, clips, n, 1);\r\nbreak;\r\ncase 32:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nkfree(fh->ov.clips);\r\nfh->ov.clips = clips;\r\nfh->ov.nclips = n;\r\nfh->ov.w = win->w;\r\nfh->ov.field = win->field;\r\nfh->ov.setup_ok = 1;\r\nbtv->init.ov.w.width = win->w.width;\r\nbtv->init.ov.w.height = win->w.height;\r\nbtv->init.ov.field = win->field;\r\nretval = 0;\r\nif (check_btres(fh, RESOURCE_OVERLAY)) {\r\nstruct bttv_buffer *new;\r\nnew = videobuf_sg_alloc(sizeof(*new));\r\nnew->crop = btv->crop[!!fh->do_crop].rect;\r\nbttv_overlay_risc(btv, &fh->ov, fh->ovfmt, new);\r\nretval = bttv_switch_overlay(btv,fh,new);\r\n}\r\nreturn retval;\r\n}\r\nstatic struct videobuf_queue* bttv_queue(struct bttv_fh *fh)\r\n{\r\nstruct videobuf_queue* q = NULL;\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nq = &fh->cap;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nq = &fh->vbi;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn q;\r\n}\r\nstatic int bttv_resource(struct bttv_fh *fh)\r\n{\r\nint res = 0;\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nres = RESOURCE_VIDEO_STREAM;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nres = RESOURCE_VBI;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn res;\r\n}\r\nstatic int bttv_switch_type(struct bttv_fh *fh, enum v4l2_buf_type type)\r\n{\r\nstruct videobuf_queue *q = bttv_queue(fh);\r\nint res = bttv_resource(fh);\r\nif (check_btres(fh,res))\r\nreturn -EBUSY;\r\nif (videobuf_queue_is_busy(q))\r\nreturn -EBUSY;\r\nfh->type = type;\r\nreturn 0;\r\n}\r\nstatic void\r\npix_format_set_size (struct v4l2_pix_format * f,\r\nconst struct bttv_format * fmt,\r\nunsigned int width,\r\nunsigned int height)\r\n{\r\nf->width = width;\r\nf->height = height;\r\nif (fmt->flags & FORMAT_FLAGS_PLANAR) {\r\nf->bytesperline = width;\r\nf->sizeimage = (width * height * fmt->depth) >> 3;\r\n} else {\r\nf->bytesperline = (width * fmt->depth) >> 3;\r\nf->sizeimage = height * f->bytesperline;\r\n}\r\n}\r\nstatic int bttv_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct bttv_fh *fh = priv;\r\npix_format_set_size(&f->fmt.pix, fh->fmt,\r\nfh->width, fh->height);\r\nf->fmt.pix.field = fh->cap.field;\r\nf->fmt.pix.pixelformat = fh->fmt->fourcc;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int bttv_g_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nf->fmt.win.w = fh->ov.w;\r\nf->fmt.win.field = fh->ov.field;\r\nreturn 0;\r\n}\r\nstatic void bttv_get_width_mask_vid_cap(const struct bttv_format *fmt,\r\nunsigned int *width_mask,\r\nunsigned int *width_bias)\r\n{\r\nif (fmt->flags & FORMAT_FLAGS_PLANAR) {\r\n*width_mask = ~15;\r\n*width_bias = 8;\r\n} else {\r\n*width_mask = ~3;\r\n*width_bias = 2;\r\n}\r\n}\r\nstatic int bttv_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nconst struct bttv_format *fmt;\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nenum v4l2_field field;\r\n__s32 width, height;\r\n__s32 height2;\r\nunsigned int width_mask, width_bias;\r\nint rc;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_ALTERNATE:\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ncase V4L2_FIELD_SEQ_TB:\r\nif (!(fmt->flags & FORMAT_FLAGS_PLANAR)) {\r\nfield = V4L2_FIELD_SEQ_TB;\r\nbreak;\r\n}\r\ndefault:\r\nheight2 = btv->crop[!!fh->do_crop].rect.height >> 1;\r\nfield = (f->fmt.pix.height > height2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\nbreak;\r\n}\r\nwidth = f->fmt.pix.width;\r\nheight = f->fmt.pix.height;\r\nbttv_get_width_mask_vid_cap(fmt, &width_mask, &width_bias);\r\nrc = limit_scaled_size_lock(fh, &width, &height, field,\r\nwidth_mask, width_bias,\r\n1,\r\n0);\r\nif (0 != rc)\r\nreturn rc;\r\nf->fmt.pix.field = field;\r\npix_format_set_size(&f->fmt.pix, fmt, width, height);\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int bttv_try_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nverify_window_lock(fh, &f->fmt.win,\r\n1,\r\n0);\r\nreturn 0;\r\n}\r\nstatic int bttv_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint retval;\r\nconst struct bttv_format *fmt;\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\n__s32 width, height;\r\nunsigned int width_mask, width_bias;\r\nenum v4l2_field field;\r\nretval = bttv_switch_type(fh, f->type);\r\nif (0 != retval)\r\nreturn retval;\r\nretval = bttv_try_fmt_vid_cap(file, priv, f);\r\nif (0 != retval)\r\nreturn retval;\r\nwidth = f->fmt.pix.width;\r\nheight = f->fmt.pix.height;\r\nfield = f->fmt.pix.field;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nbttv_get_width_mask_vid_cap(fmt, &width_mask, &width_bias);\r\nretval = limit_scaled_size_lock(fh, &width, &height, f->fmt.pix.field,\r\nwidth_mask, width_bias,\r\n1,\r\n1);\r\nif (0 != retval)\r\nreturn retval;\r\nf->fmt.pix.field = field;\r\nfh->fmt = fmt;\r\nfh->cap.field = f->fmt.pix.field;\r\nfh->cap.last = V4L2_FIELD_NONE;\r\nfh->width = f->fmt.pix.width;\r\nfh->height = f->fmt.pix.height;\r\nbtv->init.fmt = fmt;\r\nbtv->init.width = f->fmt.pix.width;\r\nbtv->init.height = f->fmt.pix.height;\r\nreturn 0;\r\n}\r\nstatic int bttv_s_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (no_overlay > 0) {\r\npr_err("V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nreturn setup_window_lock(fh, btv, &f->fmt.win, 1);\r\n}\r\nstatic int bttv_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (0 == v4l2)\r\nreturn -EINVAL;\r\nstrlcpy(cap->driver, "bttv", sizeof(cap->driver));\r\nstrlcpy(cap->card, btv->video_dev.name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"PCI:%s", pci_name(btv->c.pci));\r\ncap->capabilities =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_DEVICE_CAPS;\r\nif (no_overlay <= 0)\r\ncap->capabilities |= V4L2_CAP_VIDEO_OVERLAY;\r\nif (video_is_registered(&btv->vbi_dev))\r\ncap->capabilities |= V4L2_CAP_VBI_CAPTURE;\r\nif (video_is_registered(&btv->radio_dev))\r\ncap->capabilities |= V4L2_CAP_RADIO;\r\nif (btv->has_saa6588)\r\ncap->capabilities |= V4L2_CAP_RDS_CAPTURE;\r\nif (btv->tuner_type != TUNER_ABSENT)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nif (vdev->vfl_type == VFL_TYPE_GRABBER)\r\ncap->device_caps = cap->capabilities &\r\n(V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_VIDEO_OVERLAY |\r\nV4L2_CAP_TUNER);\r\nelse if (vdev->vfl_type == VFL_TYPE_VBI)\r\ncap->device_caps = cap->capabilities &\r\n(V4L2_CAP_VBI_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_TUNER);\r\nelse {\r\ncap->device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\r\nif (btv->has_saa6588)\r\ncap->device_caps |= V4L2_CAP_READWRITE |\r\nV4L2_CAP_RDS_CAPTURE;\r\nif (btv->has_tea575x)\r\ncap->device_caps |= V4L2_CAP_HW_FREQ_SEEK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bttv_enum_fmt_cap_ovr(struct v4l2_fmtdesc *f)\r\n{\r\nint index = -1, i;\r\nfor (i = 0; i < FORMATS; i++) {\r\nif (formats[i].fourcc != -1)\r\nindex++;\r\nif ((unsigned int)index == f->index)\r\nbreak;\r\n}\r\nif (FORMATS == i)\r\nreturn -EINVAL;\r\nf->pixelformat = formats[i].fourcc;\r\nstrlcpy(f->description, formats[i].name, sizeof(f->description));\r\nreturn i;\r\n}\r\nstatic int bttv_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nint rc = bttv_enum_fmt_cap_ovr(f);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int bttv_enum_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nint rc;\r\nif (no_overlay > 0) {\r\npr_err("V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nrc = bttv_enum_fmt_cap_ovr(f);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(formats[rc].flags & FORMAT_FLAGS_PACKED))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int bttv_g_fbuf(struct file *file, void *f,\r\nstruct v4l2_framebuffer *fb)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\n*fb = btv->fbuf;\r\nfb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;\r\nfb->flags = V4L2_FBUF_FLAG_PRIMARY;\r\nif (fh->ovfmt)\r\nfb->fmt.pixelformat = fh->ovfmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int bttv_overlay(struct file *file, void *f, unsigned int on)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nstruct bttv_buffer *new;\r\nint retval = 0;\r\nif (on) {\r\nif (unlikely(!btv->fbuf.base)) {\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!fh->ov.setup_ok)) {\r\ndprintk("%d: overlay: !setup_ok\n", btv->c.nr);\r\nretval = -EINVAL;\r\n}\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (!check_alloc_btres_lock(btv, fh, RESOURCE_OVERLAY))\r\nreturn -EBUSY;\r\nif (on) {\r\nfh->ov.tvnorm = btv->tvnorm;\r\nnew = videobuf_sg_alloc(sizeof(*new));\r\nnew->crop = btv->crop[!!fh->do_crop].rect;\r\nbttv_overlay_risc(btv, &fh->ov, fh->ovfmt, new);\r\n} else {\r\nnew = NULL;\r\n}\r\nretval = bttv_switch_overlay(btv, fh, new);\r\nreturn retval;\r\n}\r\nstatic int bttv_s_fbuf(struct file *file, void *f,\r\nconst struct v4l2_framebuffer *fb)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nconst struct bttv_format *fmt;\r\nint retval;\r\nif (!capable(CAP_SYS_ADMIN) &&\r\n!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nfmt = format_by_fourcc(fb->fmt.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nif (0 == (fmt->flags & FORMAT_FLAGS_PACKED))\r\nreturn -EINVAL;\r\nretval = -EINVAL;\r\nif (fb->flags & V4L2_FBUF_FLAG_OVERLAY) {\r\n__s32 width = fb->fmt.width;\r\n__s32 height = fb->fmt.height;\r\nretval = limit_scaled_size_lock(fh, &width, &height,\r\nV4L2_FIELD_INTERLACED,\r\n~3,\r\n2,\r\n0,\r\n0);\r\nif (0 != retval)\r\nreturn retval;\r\n}\r\nbtv->fbuf.base = fb->base;\r\nbtv->fbuf.fmt.width = fb->fmt.width;\r\nbtv->fbuf.fmt.height = fb->fmt.height;\r\nif (0 != fb->fmt.bytesperline)\r\nbtv->fbuf.fmt.bytesperline = fb->fmt.bytesperline;\r\nelse\r\nbtv->fbuf.fmt.bytesperline = btv->fbuf.fmt.width*fmt->depth/8;\r\nretval = 0;\r\nfh->ovfmt = fmt;\r\nbtv->init.ovfmt = fmt;\r\nif (fb->flags & V4L2_FBUF_FLAG_OVERLAY) {\r\nfh->ov.w.left = 0;\r\nfh->ov.w.top = 0;\r\nfh->ov.w.width = fb->fmt.width;\r\nfh->ov.w.height = fb->fmt.height;\r\nbtv->init.ov.w.width = fb->fmt.width;\r\nbtv->init.ov.w.height = fb->fmt.height;\r\nkfree(fh->ov.clips);\r\nfh->ov.clips = NULL;\r\nfh->ov.nclips = 0;\r\nif (check_btres(fh, RESOURCE_OVERLAY)) {\r\nstruct bttv_buffer *new;\r\nnew = videobuf_sg_alloc(sizeof(*new));\r\nnew->crop = btv->crop[!!fh->do_crop].rect;\r\nbttv_overlay_risc(btv, &fh->ov, fh->ovfmt, new);\r\nretval = bttv_switch_overlay(btv, fh, new);\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int bttv_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nreturn videobuf_reqbufs(bttv_queue(fh), p);\r\n}\r\nstatic int bttv_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nreturn videobuf_querybuf(bttv_queue(fh), b);\r\n}\r\nstatic int bttv_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nint res = bttv_resource(fh);\r\nif (!check_alloc_btres_lock(btv, fh, res))\r\nreturn -EBUSY;\r\nreturn videobuf_qbuf(bttv_queue(fh), b);\r\n}\r\nstatic int bttv_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nreturn videobuf_dqbuf(bttv_queue(fh), b,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int bttv_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nint res = bttv_resource(fh);\r\nif (!check_alloc_btres_lock(btv, fh, res))\r\nreturn -EBUSY;\r\nreturn videobuf_streamon(bttv_queue(fh));\r\n}\r\nstatic int bttv_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nint retval;\r\nint res = bttv_resource(fh);\r\nretval = videobuf_streamoff(bttv_queue(fh));\r\nif (retval < 0)\r\nreturn retval;\r\nfree_btres_lock(btv, fh, res);\r\nreturn 0;\r\n}\r\nstatic int bttv_g_parm(struct file *file, void *f,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nparm->parm.capture.readbuffers = gbuffers;\r\nv4l2_video_std_frame_period(bttv_tvnorms[btv->tvnorm].v4l2_id,\r\n&parm->parm.capture.timeperframe);\r\nreturn 0;\r\n}\r\nstatic int bttv_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nt->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nbttv_call_all(btv, tuner, g_tuner, t);\r\nstrcpy(t->name, "Television");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nif (btread(BT848_DSTATUS)&BT848_DSTATUS_HLOC)\r\nt->signal = 0xffff;\r\nif (btv->audio_mode_gpio)\r\nbtv->audio_mode_gpio(btv, t, 0);\r\nreturn 0;\r\n}\r\nstatic int bttv_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cap)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\n*cap = bttv_tvnorms[btv->tvnorm].cropcap;\r\nreturn 0;\r\n}\r\nstatic int bttv_g_crop(struct file *file, void *f, struct v4l2_crop *crop)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncrop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\ncrop->c = btv->crop[!!fh->do_crop].rect;\r\nreturn 0;\r\n}\r\nstatic int bttv_s_crop(struct file *file, void *f, const struct v4l2_crop *crop)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nconst struct v4l2_rect *b;\r\nint retval;\r\nstruct bttv_crop c;\r\n__s32 b_left;\r\n__s32 b_top;\r\n__s32 b_right;\r\n__s32 b_bottom;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncrop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\nretval = -EBUSY;\r\nif (locked_btres(fh->btv, VIDEO_RESOURCES)) {\r\nreturn retval;\r\n}\r\nb = &bttv_tvnorms[btv->tvnorm].cropcap.bounds;\r\nb_left = b->left;\r\nb_right = b_left + b->width;\r\nb_bottom = b->top + b->height;\r\nb_top = max(b->top, btv->vbi_end);\r\nif (b_top + 32 >= b_bottom) {\r\nreturn retval;\r\n}\r\nc.rect.left = clamp_t(s32, crop->c.left, b_left, b_right - 48);\r\nc.rect.left = min(c.rect.left, (__s32) MAX_HDELAY);\r\nc.rect.width = clamp_t(s32, crop->c.width,\r\n48, b_right - c.rect.left);\r\nc.rect.top = clamp_t(s32, crop->c.top, b_top, b_bottom - 32);\r\nc.rect.top = (c.rect.top + 1) & ~1;\r\nc.rect.height = clamp_t(s32, crop->c.height,\r\n32, b_bottom - c.rect.top);\r\nc.rect.height = (c.rect.height + 1) & ~1;\r\nbttv_crop_calc_limits(&c);\r\nbtv->crop[1] = c;\r\nfh->do_crop = 1;\r\nif (fh->width < c.min_scaled_width) {\r\nfh->width = c.min_scaled_width;\r\nbtv->init.width = c.min_scaled_width;\r\n} else if (fh->width > c.max_scaled_width) {\r\nfh->width = c.max_scaled_width;\r\nbtv->init.width = c.max_scaled_width;\r\n}\r\nif (fh->height < c.min_scaled_height) {\r\nfh->height = c.min_scaled_height;\r\nbtv->init.height = c.min_scaled_height;\r\n} else if (fh->height > c.max_scaled_height) {\r\nfh->height = c.max_scaled_height;\r\nbtv->init.height = c.max_scaled_height;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t bttv_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct bttv_fh *fh = file->private_data;\r\nint retval = 0;\r\nif (fh->btv->errors)\r\nbttv_reinit_bt848(fh->btv);\r\ndprintk("%d: read count=%d type=%s\n",\r\nfh->btv->c.nr, (int)count, v4l2_type_names[fh->type]);\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (!check_alloc_btres_lock(fh->btv, fh, RESOURCE_VIDEO_READ)) {\r\nreturn -EBUSY;\r\n}\r\nretval = videobuf_read_one(&fh->cap, data, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\nfree_btres_lock(fh->btv, fh, RESOURCE_VIDEO_READ);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (!check_alloc_btres_lock(fh->btv,fh,RESOURCE_VBI))\r\nreturn -EBUSY;\r\nretval = videobuf_read_stream(&fh->vbi, data, count, ppos, 1,\r\nfile->f_flags & O_NONBLOCK);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn retval;\r\n}\r\nstatic unsigned int bttv_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct bttv_fh *fh = file->private_data;\r\nstruct bttv_buffer *buf;\r\nenum v4l2_field field;\r\nunsigned int rc = 0;\r\nunsigned long req_events = poll_requested_events(wait);\r\nif (v4l2_event_pending(&fh->fh))\r\nrc = POLLPRI;\r\nelse if (req_events & POLLPRI)\r\npoll_wait(file, &fh->fh.wait, wait);\r\nif (!(req_events & (POLLIN | POLLRDNORM)))\r\nreturn rc;\r\nif (V4L2_BUF_TYPE_VBI_CAPTURE == fh->type) {\r\nif (!check_alloc_btres_lock(fh->btv,fh,RESOURCE_VBI))\r\nreturn rc | POLLERR;\r\nreturn rc | videobuf_poll_stream(file, &fh->vbi, wait);\r\n}\r\nif (check_btres(fh,RESOURCE_VIDEO_STREAM)) {\r\nif (list_empty(&fh->cap.stream))\r\nreturn rc | POLLERR;\r\nbuf = list_entry(fh->cap.stream.next,struct bttv_buffer,vb.stream);\r\n} else {\r\nif (NULL == fh->cap.read_buf) {\r\nif (locked_btres(fh->btv,RESOURCE_VIDEO_STREAM))\r\nreturn rc | POLLERR;\r\nfh->cap.read_buf = videobuf_sg_alloc(fh->cap.msize);\r\nif (NULL == fh->cap.read_buf)\r\nreturn rc | POLLERR;\r\nfh->cap.read_buf->memory = V4L2_MEMORY_USERPTR;\r\nfield = videobuf_next_field(&fh->cap);\r\nif (0 != fh->cap.ops->buf_prepare(&fh->cap,fh->cap.read_buf,field)) {\r\nkfree (fh->cap.read_buf);\r\nfh->cap.read_buf = NULL;\r\nreturn rc | POLLERR;\r\n}\r\nfh->cap.ops->buf_queue(&fh->cap,fh->cap.read_buf);\r\nfh->cap.read_off = 0;\r\n}\r\nbuf = (struct bttv_buffer*)fh->cap.read_buf;\r\n}\r\npoll_wait(file, &buf->vb.done, wait);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nrc = rc | POLLIN|POLLRDNORM;\r\nreturn rc;\r\n}\r\nstatic int bttv_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct bttv *btv = video_drvdata(file);\r\nstruct bttv_fh *fh;\r\nenum v4l2_buf_type type = 0;\r\ndprintk("open dev=%s\n", video_device_node_name(vdev));\r\nif (vdev->vfl_type == VFL_TYPE_GRABBER) {\r\ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\n} else if (vdev->vfl_type == VFL_TYPE_VBI) {\r\ntype = V4L2_BUF_TYPE_VBI_CAPTURE;\r\n} else {\r\nWARN_ON(1);\r\nreturn -ENODEV;\r\n}\r\ndprintk("%d: open called (type=%s)\n",\r\nbtv->c.nr, v4l2_type_names[type]);\r\nfh = kmalloc(sizeof(*fh), GFP_KERNEL);\r\nif (unlikely(!fh))\r\nreturn -ENOMEM;\r\nbtv->users++;\r\nfile->private_data = fh;\r\n*fh = btv->init;\r\nv4l2_fh_init(&fh->fh, vdev);\r\nfh->type = type;\r\nfh->ov.setup_ok = 0;\r\nvideobuf_queue_sg_init(&fh->cap, &bttv_video_qops,\r\n&btv->c.pci->dev, &btv->s_lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct bttv_buffer),\r\nfh, &btv->lock);\r\nvideobuf_queue_sg_init(&fh->vbi, &bttv_vbi_qops,\r\n&btv->c.pci->dev, &btv->s_lock,\r\nV4L2_BUF_TYPE_VBI_CAPTURE,\r\nV4L2_FIELD_SEQ_TB,\r\nsizeof(struct bttv_buffer),\r\nfh, &btv->lock);\r\nset_tvnorm(btv,btv->tvnorm);\r\nset_input(btv, btv->input, btv->tvnorm);\r\naudio_mute(btv, btv->mute);\r\nfh->do_crop = !reset_crop;\r\nbttv_vbi_fmt_reset(&fh->vbi_fmt, btv->tvnorm);\r\nbttv_field_count(btv);\r\nv4l2_fh_add(&fh->fh);\r\nreturn 0;\r\n}\r\nstatic int bttv_release(struct file *file)\r\n{\r\nstruct bttv_fh *fh = file->private_data;\r\nstruct bttv *btv = fh->btv;\r\nif (check_btres(fh, RESOURCE_OVERLAY))\r\nbttv_switch_overlay(btv,fh,NULL);\r\nif (check_btres(fh, RESOURCE_VIDEO_STREAM)) {\r\nvideobuf_streamoff(&fh->cap);\r\nfree_btres_lock(btv,fh,RESOURCE_VIDEO_STREAM);\r\n}\r\nif (fh->cap.read_buf) {\r\nbuffer_release(&fh->cap,fh->cap.read_buf);\r\nkfree(fh->cap.read_buf);\r\n}\r\nif (check_btres(fh, RESOURCE_VIDEO_READ)) {\r\nfree_btres_lock(btv, fh, RESOURCE_VIDEO_READ);\r\n}\r\nif (check_btres(fh, RESOURCE_VBI)) {\r\nvideobuf_stop(&fh->vbi);\r\nfree_btres_lock(btv,fh,RESOURCE_VBI);\r\n}\r\nvideobuf_mmap_free(&fh->cap);\r\nvideobuf_mmap_free(&fh->vbi);\r\nfile->private_data = NULL;\r\nbtv->users--;\r\nbttv_field_count(btv);\r\nif (!btv->users)\r\naudio_mute(btv, btv->mute);\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int\r\nbttv_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct bttv_fh *fh = file->private_data;\r\ndprintk("%d: mmap type=%s 0x%lx+%ld\n",\r\nfh->btv->c.nr, v4l2_type_names[fh->type],\r\nvma->vm_start, vma->vm_end - vma->vm_start);\r\nreturn videobuf_mmap_mapper(bttv_queue(fh),vma);\r\n}\r\nstatic int radio_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct bttv *btv = video_drvdata(file);\r\nstruct bttv_fh *fh;\r\ndprintk("open dev=%s\n", video_device_node_name(vdev));\r\ndprintk("%d: open called (radio)\n", btv->c.nr);\r\nfh = kmalloc(sizeof(*fh), GFP_KERNEL);\r\nif (unlikely(!fh))\r\nreturn -ENOMEM;\r\nfile->private_data = fh;\r\n*fh = btv->init;\r\nv4l2_fh_init(&fh->fh, vdev);\r\nbtv->radio_user++;\r\naudio_mute(btv, btv->mute);\r\nv4l2_fh_add(&fh->fh);\r\nreturn 0;\r\n}\r\nstatic int radio_release(struct file *file)\r\n{\r\nstruct bttv_fh *fh = file->private_data;\r\nstruct bttv *btv = fh->btv;\r\nstruct saa6588_command cmd;\r\nfile->private_data = NULL;\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nkfree(fh);\r\nbtv->radio_user--;\r\nbttv_call_all(btv, core, ioctl, SAA6588_CMD_CLOSE, &cmd);\r\nif (btv->radio_user == 0)\r\nbtv->has_radio_tuner = 0;\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\nt->type = V4L2_TUNER_RADIO;\r\nradio_enable(btv);\r\nbttv_call_all(btv, tuner, g_tuner, t);\r\nif (btv->audio_mode_gpio)\r\nbtv->audio_mode_gpio(btv, t, 0);\r\nif (btv->has_tea575x)\r\nreturn snd_tea575x_g_tuner(&btv->tea, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nradio_enable(btv);\r\nbttv_call_all(btv, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_hw_freq_seek(struct file *file, void *priv,\r\nconst struct v4l2_hw_freq_seek *a)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (btv->has_tea575x)\r\nreturn snd_tea575x_s_hw_freq_seek(file, &btv->tea, a);\r\nreturn -ENOTTY;\r\n}\r\nstatic int radio_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct bttv_fh *fh = priv;\r\nstruct bttv *btv = fh->btv;\r\nif (btv->has_tea575x)\r\nreturn snd_tea575x_enum_freq_bands(&btv->tea, band);\r\nreturn -ENOTTY;\r\n}\r\nstatic ssize_t radio_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct bttv_fh *fh = file->private_data;\r\nstruct bttv *btv = fh->btv;\r\nstruct saa6588_command cmd;\r\ncmd.block_count = count / 3;\r\ncmd.nonblocking = file->f_flags & O_NONBLOCK;\r\ncmd.buffer = data;\r\ncmd.instance = file;\r\ncmd.result = -ENODEV;\r\nradio_enable(btv);\r\nbttv_call_all(btv, core, ioctl, SAA6588_CMD_READ, &cmd);\r\nreturn cmd.result;\r\n}\r\nstatic unsigned int radio_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct bttv_fh *fh = file->private_data;\r\nstruct bttv *btv = fh->btv;\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct saa6588_command cmd;\r\nunsigned int res = 0;\r\nif (v4l2_event_pending(&fh->fh))\r\nres = POLLPRI;\r\nelse if (req_events & POLLPRI)\r\npoll_wait(file, &fh->fh.wait, wait);\r\nradio_enable(btv);\r\ncmd.instance = file;\r\ncmd.event_list = wait;\r\ncmd.result = res;\r\nbttv_call_all(btv, core, ioctl, SAA6588_CMD_POLL, &cmd);\r\nreturn cmd.result;\r\n}\r\nstatic int bttv_risc_decode(u32 risc)\r\n{\r\nstatic char *instr[16] = {\r\n[ BT848_RISC_WRITE >> 28 ] = "write",\r\n[ BT848_RISC_SKIP >> 28 ] = "skip",\r\n[ BT848_RISC_WRITEC >> 28 ] = "writec",\r\n[ BT848_RISC_JUMP >> 28 ] = "jump",\r\n[ BT848_RISC_SYNC >> 28 ] = "sync",\r\n[ BT848_RISC_WRITE123 >> 28 ] = "write123",\r\n[ BT848_RISC_SKIP123 >> 28 ] = "skip123",\r\n[ BT848_RISC_WRITE1S23 >> 28 ] = "write1s23",\r\n};\r\nstatic int incr[16] = {\r\n[ BT848_RISC_WRITE >> 28 ] = 2,\r\n[ BT848_RISC_JUMP >> 28 ] = 2,\r\n[ BT848_RISC_SYNC >> 28 ] = 2,\r\n[ BT848_RISC_WRITE123 >> 28 ] = 5,\r\n[ BT848_RISC_SKIP123 >> 28 ] = 2,\r\n[ BT848_RISC_WRITE1S23 >> 28 ] = 3,\r\n};\r\nstatic char *bits[] = {\r\n"be0", "be1", "be2", "be3/resync",\r\n"set0", "set1", "set2", "set3",\r\n"clr0", "clr1", "clr2", "clr3",\r\n"irq", "res", "eol", "sol",\r\n};\r\nint i;\r\npr_cont("0x%08x [ %s", risc,\r\ninstr[risc >> 28] ? instr[risc >> 28] : "INVALID");\r\nfor (i = ARRAY_SIZE(bits)-1; i >= 0; i--)\r\nif (risc & (1 << (i + 12)))\r\npr_cont(" %s", bits[i]);\r\npr_cont(" count=%d ]\n", risc & 0xfff);\r\nreturn incr[risc >> 28] ? incr[risc >> 28] : 1;\r\n}\r\nstatic void bttv_risc_disasm(struct bttv *btv,\r\nstruct btcx_riscmem *risc)\r\n{\r\nunsigned int i,j,n;\r\npr_info("%s: risc disasm: %p [dma=0x%08lx]\n",\r\nbtv->c.v4l2_dev.name, risc->cpu, (unsigned long)risc->dma);\r\nfor (i = 0; i < (risc->size >> 2); i += n) {\r\npr_info("%s: 0x%lx: ",\r\nbtv->c.v4l2_dev.name,\r\n(unsigned long)(risc->dma + (i<<2)));\r\nn = bttv_risc_decode(le32_to_cpu(risc->cpu[i]));\r\nfor (j = 1; j < n; j++)\r\npr_info("%s: 0x%lx: 0x%08x [ arg #%d ]\n",\r\nbtv->c.v4l2_dev.name,\r\n(unsigned long)(risc->dma + ((i+j)<<2)),\r\nrisc->cpu[i+j], j);\r\nif (0 == risc->cpu[i])\r\nbreak;\r\n}\r\n}\r\nstatic void bttv_print_riscaddr(struct bttv *btv)\r\n{\r\npr_info(" main: %08llx\n", (unsigned long long)btv->main.dma);\r\npr_info(" vbi : o=%08llx e=%08llx\n",\r\nbtv->cvbi ? (unsigned long long)btv->cvbi->top.dma : 0,\r\nbtv->cvbi ? (unsigned long long)btv->cvbi->bottom.dma : 0);\r\npr_info(" cap : o=%08llx e=%08llx\n",\r\nbtv->curr.top\r\n? (unsigned long long)btv->curr.top->top.dma : 0,\r\nbtv->curr.bottom\r\n? (unsigned long long)btv->curr.bottom->bottom.dma : 0);\r\npr_info(" scr : o=%08llx e=%08llx\n",\r\nbtv->screen ? (unsigned long long)btv->screen->top.dma : 0,\r\nbtv->screen ? (unsigned long long)btv->screen->bottom.dma : 0);\r\nbttv_risc_disasm(btv, &btv->main);\r\n}\r\nstatic void bttv_print_irqbits(u32 print, u32 mark)\r\n{\r\nunsigned int i;\r\npr_cont("bits:");\r\nfor (i = 0; i < ARRAY_SIZE(irq_name); i++) {\r\nif (print & (1 << i))\r\npr_cont(" %s", irq_name[i]);\r\nif (mark & (1 << i))\r\npr_cont("*");\r\n}\r\n}\r\nstatic void bttv_irq_debug_low_latency(struct bttv *btv, u32 rc)\r\n{\r\npr_warn("%d: irq: skipped frame [main=%lx,o_vbi=%lx,o_field=%lx,rc=%lx]\n",\r\nbtv->c.nr,\r\n(unsigned long)btv->main.dma,\r\n(unsigned long)le32_to_cpu(btv->main.cpu[RISC_SLOT_O_VBI+1]),\r\n(unsigned long)le32_to_cpu(btv->main.cpu[RISC_SLOT_O_FIELD+1]),\r\n(unsigned long)rc);\r\nif (0 == (btread(BT848_DSTATUS) & BT848_DSTATUS_HLOC)) {\r\npr_notice("%d: Oh, there (temporarily?) is no input signal. "\r\n"Ok, then this is harmless, don't worry ;)\n",\r\nbtv->c.nr);\r\nreturn;\r\n}\r\npr_notice("%d: Uhm. Looks like we have unusual high IRQ latencies\n",\r\nbtv->c.nr);\r\npr_notice("%d: Lets try to catch the culpit red-handed ...\n",\r\nbtv->c.nr);\r\ndump_stack();\r\n}\r\nstatic int\r\nbttv_irq_next_video(struct bttv *btv, struct bttv_buffer_set *set)\r\n{\r\nstruct bttv_buffer *item;\r\nmemset(set,0,sizeof(*set));\r\nif (!list_empty(&btv->capture)) {\r\nset->frame_irq = 1;\r\nitem = list_entry(btv->capture.next, struct bttv_buffer, vb.queue);\r\nif (V4L2_FIELD_HAS_TOP(item->vb.field))\r\nset->top = item;\r\nif (V4L2_FIELD_HAS_BOTTOM(item->vb.field))\r\nset->bottom = item;\r\nif (!V4L2_FIELD_HAS_BOTH(item->vb.field) &&\r\n(item->vb.queue.next != &btv->capture)) {\r\nitem = list_entry(item->vb.queue.next, struct bttv_buffer, vb.queue);\r\nif (!V4L2_FIELD_HAS_BOTH(item->vb.field)) {\r\nif (NULL == set->bottom &&\r\nV4L2_FIELD_BOTTOM == item->vb.field) {\r\nset->bottom = item;\r\n}\r\nif (NULL != set->top && NULL != set->bottom)\r\nset->top_irq = 2;\r\n}\r\n}\r\n}\r\nif (NULL != btv->screen) {\r\nif (V4L2_FIELD_HAS_BOTH(btv->screen->vb.field)) {\r\nif (NULL == set->top && NULL == set->bottom) {\r\nset->top = btv->screen;\r\nset->bottom = btv->screen;\r\n}\r\n} else {\r\nif (V4L2_FIELD_TOP == btv->screen->vb.field &&\r\nNULL == set->top) {\r\nset->top = btv->screen;\r\n}\r\nif (V4L2_FIELD_BOTTOM == btv->screen->vb.field &&\r\nNULL == set->bottom) {\r\nset->bottom = btv->screen;\r\n}\r\n}\r\n}\r\ndprintk("%d: next set: top=%p bottom=%p [screen=%p,irq=%d,%d]\n",\r\nbtv->c.nr, set->top, set->bottom,\r\nbtv->screen, set->frame_irq, set->top_irq);\r\nreturn 0;\r\n}\r\nstatic void\r\nbttv_irq_wakeup_video(struct bttv *btv, struct bttv_buffer_set *wakeup,\r\nstruct bttv_buffer_set *curr, unsigned int state)\r\n{\r\nstruct timeval ts;\r\nv4l2_get_timestamp(&ts);\r\nif (wakeup->top == wakeup->bottom) {\r\nif (NULL != wakeup->top && curr->top != wakeup->top) {\r\nif (irq_debug > 1)\r\npr_debug("%d: wakeup: both=%p\n",\r\nbtv->c.nr, wakeup->top);\r\nwakeup->top->vb.ts = ts;\r\nwakeup->top->vb.field_count = btv->field_count;\r\nwakeup->top->vb.state = state;\r\nwake_up(&wakeup->top->vb.done);\r\n}\r\n} else {\r\nif (NULL != wakeup->top && curr->top != wakeup->top) {\r\nif (irq_debug > 1)\r\npr_debug("%d: wakeup: top=%p\n",\r\nbtv->c.nr, wakeup->top);\r\nwakeup->top->vb.ts = ts;\r\nwakeup->top->vb.field_count = btv->field_count;\r\nwakeup->top->vb.state = state;\r\nwake_up(&wakeup->top->vb.done);\r\n}\r\nif (NULL != wakeup->bottom && curr->bottom != wakeup->bottom) {\r\nif (irq_debug > 1)\r\npr_debug("%d: wakeup: bottom=%p\n",\r\nbtv->c.nr, wakeup->bottom);\r\nwakeup->bottom->vb.ts = ts;\r\nwakeup->bottom->vb.field_count = btv->field_count;\r\nwakeup->bottom->vb.state = state;\r\nwake_up(&wakeup->bottom->vb.done);\r\n}\r\n}\r\n}\r\nstatic void\r\nbttv_irq_wakeup_vbi(struct bttv *btv, struct bttv_buffer *wakeup,\r\nunsigned int state)\r\n{\r\nif (NULL == wakeup)\r\nreturn;\r\nv4l2_get_timestamp(&wakeup->vb.ts);\r\nwakeup->vb.field_count = btv->field_count;\r\nwakeup->vb.state = state;\r\nwake_up(&wakeup->vb.done);\r\n}\r\nstatic void bttv_irq_timeout(unsigned long data)\r\n{\r\nstruct bttv *btv = (struct bttv *)data;\r\nstruct bttv_buffer_set old,new;\r\nstruct bttv_buffer *ovbi;\r\nstruct bttv_buffer *item;\r\nunsigned long flags;\r\nif (bttv_verbose) {\r\npr_info("%d: timeout: drop=%d irq=%d/%d, risc=%08x, ",\r\nbtv->c.nr, btv->framedrop, btv->irq_me, btv->irq_total,\r\nbtread(BT848_RISC_COUNT));\r\nbttv_print_irqbits(btread(BT848_INT_STAT),0);\r\npr_cont("\n");\r\n}\r\nspin_lock_irqsave(&btv->s_lock,flags);\r\nmemset(&new,0,sizeof(new));\r\nold = btv->curr;\r\novbi = btv->cvbi;\r\nbtv->curr = new;\r\nbtv->cvbi = NULL;\r\nbtv->loop_irq = 0;\r\nbttv_buffer_activate_video(btv, &new);\r\nbttv_buffer_activate_vbi(btv, NULL);\r\nbttv_set_dma(btv, 0);\r\nbttv_irq_wakeup_video(btv, &old, &new, VIDEOBUF_ERROR);\r\nbttv_irq_wakeup_vbi(btv, ovbi, VIDEOBUF_ERROR);\r\nwhile (!list_empty(&btv->capture)) {\r\nitem = list_entry(btv->capture.next, struct bttv_buffer, vb.queue);\r\nlist_del(&item->vb.queue);\r\nitem->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&item->vb.done);\r\n}\r\nwhile (!list_empty(&btv->vcapture)) {\r\nitem = list_entry(btv->vcapture.next, struct bttv_buffer, vb.queue);\r\nlist_del(&item->vb.queue);\r\nitem->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&item->vb.done);\r\n}\r\nbtv->errors++;\r\nspin_unlock_irqrestore(&btv->s_lock,flags);\r\n}\r\nstatic void\r\nbttv_irq_wakeup_top(struct bttv *btv)\r\n{\r\nstruct bttv_buffer *wakeup = btv->curr.top;\r\nif (NULL == wakeup)\r\nreturn;\r\nspin_lock(&btv->s_lock);\r\nbtv->curr.top_irq = 0;\r\nbtv->curr.top = NULL;\r\nbttv_risc_hook(btv, RISC_SLOT_O_FIELD, NULL, 0);\r\nv4l2_get_timestamp(&wakeup->vb.ts);\r\nwakeup->vb.field_count = btv->field_count;\r\nwakeup->vb.state = VIDEOBUF_DONE;\r\nwake_up(&wakeup->vb.done);\r\nspin_unlock(&btv->s_lock);\r\n}\r\nstatic inline int is_active(struct btcx_riscmem *risc, u32 rc)\r\n{\r\nif (rc < risc->dma)\r\nreturn 0;\r\nif (rc > risc->dma + risc->size)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\nbttv_irq_switch_video(struct bttv *btv)\r\n{\r\nstruct bttv_buffer_set new;\r\nstruct bttv_buffer_set old;\r\ndma_addr_t rc;\r\nspin_lock(&btv->s_lock);\r\nbttv_irq_next_video(btv, &new);\r\nrc = btread(BT848_RISC_COUNT);\r\nif ((btv->curr.top && is_active(&btv->curr.top->top, rc)) ||\r\n(btv->curr.bottom && is_active(&btv->curr.bottom->bottom, rc))) {\r\nbtv->framedrop++;\r\nif (debug_latency)\r\nbttv_irq_debug_low_latency(btv, rc);\r\nspin_unlock(&btv->s_lock);\r\nreturn;\r\n}\r\nold = btv->curr;\r\nbtv->curr = new;\r\nbtv->loop_irq &= ~1;\r\nbttv_buffer_activate_video(btv, &new);\r\nbttv_set_dma(btv, 0);\r\nif (UNSET != btv->new_input) {\r\nvideo_mux(btv,btv->new_input);\r\nbtv->new_input = UNSET;\r\n}\r\nbttv_irq_wakeup_video(btv, &old, &new, VIDEOBUF_DONE);\r\nspin_unlock(&btv->s_lock);\r\n}\r\nstatic void\r\nbttv_irq_switch_vbi(struct bttv *btv)\r\n{\r\nstruct bttv_buffer *new = NULL;\r\nstruct bttv_buffer *old;\r\nu32 rc;\r\nspin_lock(&btv->s_lock);\r\nif (!list_empty(&btv->vcapture))\r\nnew = list_entry(btv->vcapture.next, struct bttv_buffer, vb.queue);\r\nold = btv->cvbi;\r\nrc = btread(BT848_RISC_COUNT);\r\nif (NULL != old && (is_active(&old->top, rc) ||\r\nis_active(&old->bottom, rc))) {\r\nbtv->framedrop++;\r\nif (debug_latency)\r\nbttv_irq_debug_low_latency(btv, rc);\r\nspin_unlock(&btv->s_lock);\r\nreturn;\r\n}\r\nbtv->cvbi = new;\r\nbtv->loop_irq &= ~4;\r\nbttv_buffer_activate_vbi(btv, new);\r\nbttv_set_dma(btv, 0);\r\nbttv_irq_wakeup_vbi(btv, old, VIDEOBUF_DONE);\r\nspin_unlock(&btv->s_lock);\r\n}\r\nstatic irqreturn_t bttv_irq(int irq, void *dev_id)\r\n{\r\nu32 stat,astat;\r\nu32 dstat;\r\nint count;\r\nstruct bttv *btv;\r\nint handled = 0;\r\nbtv=(struct bttv *)dev_id;\r\ncount=0;\r\nwhile (1) {\r\nstat=btread(BT848_INT_STAT);\r\nastat=stat&btread(BT848_INT_MASK);\r\nif (!astat)\r\nbreak;\r\nhandled = 1;\r\nbtwrite(stat,BT848_INT_STAT);\r\ndstat=btread(BT848_DSTATUS);\r\nif (irq_debug) {\r\npr_debug("%d: irq loop=%d fc=%d riscs=%x, riscc=%08x, ",\r\nbtv->c.nr, count, btv->field_count,\r\nstat>>28, btread(BT848_RISC_COUNT));\r\nbttv_print_irqbits(stat,astat);\r\nif (stat & BT848_INT_HLOCK)\r\npr_cont(" HLOC => %s",\r\ndstat & BT848_DSTATUS_HLOC\r\n? "yes" : "no");\r\nif (stat & BT848_INT_VPRES)\r\npr_cont(" PRES => %s",\r\ndstat & BT848_DSTATUS_PRES\r\n? "yes" : "no");\r\nif (stat & BT848_INT_FMTCHG)\r\npr_cont(" NUML => %s",\r\ndstat & BT848_DSTATUS_NUML\r\n? "625" : "525");\r\npr_cont("\n");\r\n}\r\nif (astat&BT848_INT_VSYNC)\r\nbtv->field_count++;\r\nif ((astat & BT848_INT_GPINT) && btv->remote) {\r\nbttv_input_irq(btv);\r\n}\r\nif (astat & BT848_INT_I2CDONE) {\r\nbtv->i2c_done = stat;\r\nwake_up(&btv->i2c_queue);\r\n}\r\nif ((astat & BT848_INT_RISCI) && (stat & (4<<28)))\r\nbttv_irq_switch_vbi(btv);\r\nif ((astat & BT848_INT_RISCI) && (stat & (2<<28)))\r\nbttv_irq_wakeup_top(btv);\r\nif ((astat & BT848_INT_RISCI) && (stat & (1<<28)))\r\nbttv_irq_switch_video(btv);\r\nif ((astat & BT848_INT_HLOCK) && btv->opt_automute)\r\naudio_mux_gpio(btv, btv->audio_input, btv->mute);\r\nif (astat & (BT848_INT_SCERR|BT848_INT_OCERR)) {\r\npr_info("%d: %s%s @ %08x,",\r\nbtv->c.nr,\r\n(astat & BT848_INT_SCERR) ? "SCERR" : "",\r\n(astat & BT848_INT_OCERR) ? "OCERR" : "",\r\nbtread(BT848_RISC_COUNT));\r\nbttv_print_irqbits(stat,astat);\r\npr_cont("\n");\r\nif (bttv_debug)\r\nbttv_print_riscaddr(btv);\r\n}\r\nif (fdsr && astat & BT848_INT_FDSR) {\r\npr_info("%d: FDSR @ %08x\n",\r\nbtv->c.nr, btread(BT848_RISC_COUNT));\r\nif (bttv_debug)\r\nbttv_print_riscaddr(btv);\r\n}\r\ncount++;\r\nif (count > 4) {\r\nif (count > 8 || !(astat & BT848_INT_GPINT)) {\r\nbtwrite(0, BT848_INT_MASK);\r\npr_err("%d: IRQ lockup, cleared int mask [",\r\nbtv->c.nr);\r\n} else {\r\npr_err("%d: IRQ lockup, clearing GPINT from int mask [",\r\nbtv->c.nr);\r\nbtwrite(btread(BT848_INT_MASK) & (-1 ^ BT848_INT_GPINT),\r\nBT848_INT_MASK);\r\n}\r\nbttv_print_irqbits(stat,astat);\r\npr_cont("]\n");\r\n}\r\n}\r\nbtv->irq_total++;\r\nif (handled)\r\nbtv->irq_me++;\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void vdev_init(struct bttv *btv,\r\nstruct video_device *vfd,\r\nconst struct video_device *template,\r\nconst char *type_name)\r\n{\r\n*vfd = *template;\r\nvfd->v4l2_dev = &btv->c.v4l2_dev;\r\nvfd->release = video_device_release_empty;\r\nvideo_set_drvdata(vfd, btv);\r\nsnprintf(vfd->name, sizeof(vfd->name), "BT%d%s %s (%s)",\r\nbtv->id, (btv->id==848 && btv->revision==0x12) ? "A" : "",\r\ntype_name, bttv_tvcards[btv->c.type].name);\r\nif (btv->tuner_type == TUNER_ABSENT) {\r\nv4l2_disable_ioctl(vfd, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(vfd, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(vfd, VIDIOC_G_TUNER);\r\nv4l2_disable_ioctl(vfd, VIDIOC_S_TUNER);\r\n}\r\n}\r\nstatic void bttv_unregister_video(struct bttv *btv)\r\n{\r\nvideo_unregister_device(&btv->video_dev);\r\nvideo_unregister_device(&btv->vbi_dev);\r\nvideo_unregister_device(&btv->radio_dev);\r\n}\r\nstatic int bttv_register_video(struct bttv *btv)\r\n{\r\nif (no_overlay > 0)\r\npr_notice("Overlay support disabled\n");\r\nvdev_init(btv, &btv->video_dev, &bttv_video_template, "video");\r\nif (video_register_device(&btv->video_dev, VFL_TYPE_GRABBER,\r\nvideo_nr[btv->c.nr]) < 0)\r\ngoto err;\r\npr_info("%d: registered device %s\n",\r\nbtv->c.nr, video_device_node_name(&btv->video_dev));\r\nif (device_create_file(&btv->video_dev.dev,\r\n&dev_attr_card)<0) {\r\npr_err("%d: device_create_file 'card' failed\n", btv->c.nr);\r\ngoto err;\r\n}\r\nvdev_init(btv, &btv->vbi_dev, &bttv_video_template, "vbi");\r\nif (video_register_device(&btv->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[btv->c.nr]) < 0)\r\ngoto err;\r\npr_info("%d: registered device %s\n",\r\nbtv->c.nr, video_device_node_name(&btv->vbi_dev));\r\nif (!btv->has_radio)\r\nreturn 0;\r\nvdev_init(btv, &btv->radio_dev, &radio_template, "radio");\r\nbtv->radio_dev.ctrl_handler = &btv->radio_ctrl_handler;\r\nif (video_register_device(&btv->radio_dev, VFL_TYPE_RADIO,\r\nradio_nr[btv->c.nr]) < 0)\r\ngoto err;\r\npr_info("%d: registered device %s\n",\r\nbtv->c.nr, video_device_node_name(&btv->radio_dev));\r\nreturn 0;\r\nerr:\r\nbttv_unregister_video(btv);\r\nreturn -1;\r\n}\r\nstatic void pci_set_command(struct pci_dev *dev)\r\n{\r\n#if defined(__powerpc__)\r\nunsigned int cmd;\r\npci_read_config_dword(dev, PCI_COMMAND, &cmd);\r\ncmd = (cmd | PCI_COMMAND_MEMORY );\r\npci_write_config_dword(dev, PCI_COMMAND, cmd);\r\n#endif\r\n}\r\nstatic int bttv_probe(struct pci_dev *dev, const struct pci_device_id *pci_id)\r\n{\r\nstruct v4l2_frequency init_freq = {\r\n.tuner = 0,\r\n.type = V4L2_TUNER_ANALOG_TV,\r\n.frequency = 980,\r\n};\r\nint result;\r\nunsigned char lat;\r\nstruct bttv *btv;\r\nstruct v4l2_ctrl_handler *hdl;\r\nif (bttv_num == BTTV_MAX)\r\nreturn -ENOMEM;\r\npr_info("Bt8xx card found (%d)\n", bttv_num);\r\nbttvs[bttv_num] = btv = kzalloc(sizeof(*btv), GFP_KERNEL);\r\nif (btv == NULL) {\r\npr_err("out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nbtv->c.nr = bttv_num;\r\nsnprintf(btv->c.v4l2_dev.name, sizeof(btv->c.v4l2_dev.name),\r\n"bttv%d", btv->c.nr);\r\nmutex_init(&btv->lock);\r\nspin_lock_init(&btv->s_lock);\r\nspin_lock_init(&btv->gpio_lock);\r\ninit_waitqueue_head(&btv->i2c_queue);\r\nINIT_LIST_HEAD(&btv->c.subs);\r\nINIT_LIST_HEAD(&btv->capture);\r\nINIT_LIST_HEAD(&btv->vcapture);\r\ninit_timer(&btv->timeout);\r\nbtv->timeout.function = bttv_irq_timeout;\r\nbtv->timeout.data = (unsigned long)btv;\r\nbtv->i2c_rc = -1;\r\nbtv->tuner_type = UNSET;\r\nbtv->new_input = UNSET;\r\nbtv->has_radio=radio[btv->c.nr];\r\nbtv->c.pci = dev;\r\nbtv->id = dev->device;\r\nif (pci_enable_device(dev)) {\r\npr_warn("%d: Can't enable device\n", btv->c.nr);\r\nreturn -EIO;\r\n}\r\nif (pci_set_dma_mask(dev, DMA_BIT_MASK(32))) {\r\npr_warn("%d: No suitable DMA available\n", btv->c.nr);\r\nreturn -EIO;\r\n}\r\nif (!request_mem_region(pci_resource_start(dev,0),\r\npci_resource_len(dev,0),\r\nbtv->c.v4l2_dev.name)) {\r\npr_warn("%d: can't request iomem (0x%llx)\n",\r\nbtv->c.nr,\r\n(unsigned long long)pci_resource_start(dev, 0));\r\nreturn -EBUSY;\r\n}\r\npci_set_master(dev);\r\npci_set_command(dev);\r\nresult = v4l2_device_register(&dev->dev, &btv->c.v4l2_dev);\r\nif (result < 0) {\r\npr_warn("%d: v4l2_device_register() failed\n", btv->c.nr);\r\ngoto fail0;\r\n}\r\nhdl = &btv->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 20);\r\nbtv->c.v4l2_dev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(&btv->radio_ctrl_handler, 6);\r\nbtv->revision = dev->revision;\r\npci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);\r\npr_info("%d: Bt%d (rev %d) at %s, irq: %d, latency: %d, mmio: 0x%llx\n",\r\nbttv_num, btv->id, btv->revision, pci_name(dev),\r\nbtv->c.pci->irq, lat,\r\n(unsigned long long)pci_resource_start(dev, 0));\r\nschedule();\r\nbtv->bt848_mmio = ioremap(pci_resource_start(dev, 0), 0x1000);\r\nif (NULL == btv->bt848_mmio) {\r\npr_err("%d: ioremap() failed\n", btv->c.nr);\r\nresult = -EIO;\r\ngoto fail1;\r\n}\r\nbttv_idcard(btv);\r\nbtwrite(0, BT848_INT_MASK);\r\nresult = request_irq(btv->c.pci->irq, bttv_irq,\r\nIRQF_SHARED, btv->c.v4l2_dev.name, (void *)btv);\r\nif (result < 0) {\r\npr_err("%d: can't get IRQ %d\n",\r\nbttv_num, btv->c.pci->irq);\r\ngoto fail1;\r\n}\r\nif (0 != bttv_handle_chipset(btv)) {\r\nresult = -EIO;\r\ngoto fail2;\r\n}\r\nbtv->opt_combfilter = combfilter;\r\nbttv_ctrl_combfilter.def = combfilter;\r\nbttv_ctrl_lumafilter.def = lumafilter;\r\nbtv->opt_automute = automute;\r\nbttv_ctrl_automute.def = automute;\r\nbttv_ctrl_agc_crush.def = agc_crush;\r\nbtv->opt_vcr_hack = vcr_hack;\r\nbttv_ctrl_vcr_hack.def = vcr_hack;\r\nbttv_ctrl_whitecrush_upper.def = whitecrush_upper;\r\nbttv_ctrl_whitecrush_lower.def = whitecrush_lower;\r\nbtv->opt_uv_ratio = uv_ratio;\r\nbttv_ctrl_uv_ratio.def = uv_ratio;\r\nbttv_ctrl_full_luma.def = full_luma_range;\r\nbttv_ctrl_coring.def = coring;\r\nbtv->init.btv = btv;\r\nbtv->init.ov.w.width = 320;\r\nbtv->init.ov.w.height = 240;\r\nbtv->init.fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\r\nbtv->init.width = 320;\r\nbtv->init.height = 240;\r\nbtv->init.ov.w.width = 320;\r\nbtv->init.ov.w.height = 240;\r\nbtv->init.ov.field = V4L2_FIELD_INTERLACED;\r\nbtv->input = 0;\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 0xff00, 0x100, 32768);\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 0xff80, 0x80, 0x6c00);\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 0xff80, 0x80, 32768);\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_COLOR_KILLER, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_HUE, 0, 0xff00, 0x100, 32768);\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_CHROMA_AGC, 0, 1, 1, !!chroma_agc);\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 0);\r\nif (btv->volume_gpio)\r\nv4l2_ctrl_new_std(hdl, &bttv_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, 0xff00, 0x100, 0xff00);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_combfilter, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_automute, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_lumafilter, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_agc_crush, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_vcr_hack, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_whitecrush_lower, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_whitecrush_upper, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_uv_ratio, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_full_luma, NULL);\r\nv4l2_ctrl_new_custom(hdl, &bttv_ctrl_coring, NULL);\r\nif (bttv_gpio)\r\nbttv_gpio_tracking(btv,"pre-init");\r\nbttv_risc_init_main(btv);\r\ninit_bt848(btv);\r\nbtwrite(0x00, BT848_GPIO_REG_INP);\r\nbtwrite(0x00, BT848_GPIO_OUT_EN);\r\nif (bttv_verbose)\r\nbttv_gpio_tracking(btv,"init");\r\nbttv_init_card1(btv);\r\ninit_bttv_i2c(btv);\r\nbttv_init_card2(btv);\r\nbttv_init_tuner(btv);\r\nif (btv->tuner_type != TUNER_ABSENT) {\r\nbttv_set_frequency(btv, &init_freq);\r\nbtv->radio_freq = 90500 * 16;\r\n}\r\nbtv->std = V4L2_STD_PAL;\r\ninit_irqreg(btv);\r\nif (!bttv_tvcards[btv->c.type].no_video)\r\nv4l2_ctrl_handler_setup(hdl);\r\nif (hdl->error) {\r\nresult = hdl->error;\r\ngoto fail2;\r\n}\r\naudio_mute(btv, 1);\r\nif (!bttv_tvcards[btv->c.type].no_video) {\r\nv4l2_ctrl_add_handler(&btv->radio_ctrl_handler, hdl,\r\nv4l2_ctrl_radio_filter);\r\nif (btv->radio_ctrl_handler.error) {\r\nresult = btv->radio_ctrl_handler.error;\r\ngoto fail2;\r\n}\r\nset_input(btv, 0, btv->tvnorm);\r\nbttv_crop_reset(&btv->crop[0], btv->tvnorm);\r\nbtv->crop[1] = btv->crop[0];\r\ndisclaim_vbi_lines(btv);\r\ndisclaim_video_lines(btv);\r\nbttv_register_video(btv);\r\n}\r\nif (bttv_tvcards[btv->c.type].has_dvb) {\r\nbttv_sub_add_device(&btv->c, "dvb");\r\nrequest_modules(btv);\r\n}\r\nif (!disable_ir) {\r\ninit_bttv_i2c_ir(btv);\r\nbttv_input_init(btv);\r\n}\r\nbttv_num++;\r\nreturn 0;\r\nfail2:\r\nfree_irq(btv->c.pci->irq,btv);\r\nfail1:\r\nv4l2_ctrl_handler_free(&btv->ctrl_handler);\r\nv4l2_ctrl_handler_free(&btv->radio_ctrl_handler);\r\nv4l2_device_unregister(&btv->c.v4l2_dev);\r\nfail0:\r\nif (btv->bt848_mmio)\r\niounmap(btv->bt848_mmio);\r\nrelease_mem_region(pci_resource_start(btv->c.pci,0),\r\npci_resource_len(btv->c.pci,0));\r\npci_disable_device(btv->c.pci);\r\nreturn result;\r\n}\r\nstatic void bttv_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct bttv *btv = to_bttv(v4l2_dev);\r\nif (bttv_verbose)\r\npr_info("%d: unloading\n", btv->c.nr);\r\nif (bttv_tvcards[btv->c.type].has_dvb)\r\nflush_request_modules(btv);\r\nbtand(~15, BT848_GPIO_DMA_CTL);\r\nbtwrite(0, BT848_INT_MASK);\r\nbtwrite(~0x0, BT848_INT_STAT);\r\nbtwrite(0x0, BT848_GPIO_OUT_EN);\r\nif (bttv_gpio)\r\nbttv_gpio_tracking(btv,"cleanup");\r\nbtv->shutdown=1;\r\nbttv_input_fini(btv);\r\nbttv_sub_del_devices(&btv->c);\r\nfini_bttv_i2c(btv);\r\nbttv_unregister_video(btv);\r\nv4l2_ctrl_handler_free(&btv->ctrl_handler);\r\nv4l2_ctrl_handler_free(&btv->radio_ctrl_handler);\r\nbtcx_riscmem_free(btv->c.pci,&btv->main);\r\nfree_irq(btv->c.pci->irq,btv);\r\niounmap(btv->bt848_mmio);\r\nrelease_mem_region(pci_resource_start(btv->c.pci,0),\r\npci_resource_len(btv->c.pci,0));\r\npci_disable_device(btv->c.pci);\r\nv4l2_device_unregister(&btv->c.v4l2_dev);\r\nbttvs[btv->c.nr] = NULL;\r\nkfree(btv);\r\nreturn;\r\n}\r\nstatic int bttv_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct bttv *btv = to_bttv(v4l2_dev);\r\nstruct bttv_buffer_set idle;\r\nunsigned long flags;\r\ndprintk("%d: suspend %d\n", btv->c.nr, state.event);\r\nspin_lock_irqsave(&btv->s_lock,flags);\r\nmemset(&idle, 0, sizeof(idle));\r\nbtv->state.video = btv->curr;\r\nbtv->state.vbi = btv->cvbi;\r\nbtv->state.loop_irq = btv->loop_irq;\r\nbtv->curr = idle;\r\nbtv->loop_irq = 0;\r\nbttv_buffer_activate_video(btv, &idle);\r\nbttv_buffer_activate_vbi(btv, NULL);\r\nbttv_set_dma(btv, 0);\r\nbtwrite(0, BT848_INT_MASK);\r\nspin_unlock_irqrestore(&btv->s_lock,flags);\r\nbtv->state.gpio_enable = btread(BT848_GPIO_OUT_EN);\r\nbtv->state.gpio_data = gpio_read();\r\npci_save_state(pci_dev);\r\nif (0 != pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state))) {\r\npci_disable_device(pci_dev);\r\nbtv->state.disabled = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bttv_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct bttv *btv = to_bttv(v4l2_dev);\r\nunsigned long flags;\r\nint err;\r\ndprintk("%d: resume\n", btv->c.nr);\r\nif (btv->state.disabled) {\r\nerr=pci_enable_device(pci_dev);\r\nif (err) {\r\npr_warn("%d: Can't enable device\n", btv->c.nr);\r\nreturn err;\r\n}\r\nbtv->state.disabled = 0;\r\n}\r\nerr=pci_set_power_state(pci_dev, PCI_D0);\r\nif (err) {\r\npci_disable_device(pci_dev);\r\npr_warn("%d: Can't enable device\n", btv->c.nr);\r\nbtv->state.disabled = 1;\r\nreturn err;\r\n}\r\npci_restore_state(pci_dev);\r\nbttv_reinit_bt848(btv);\r\ngpio_inout(0xffffff, btv->state.gpio_enable);\r\ngpio_write(btv->state.gpio_data);\r\nspin_lock_irqsave(&btv->s_lock,flags);\r\nbtv->curr = btv->state.video;\r\nbtv->cvbi = btv->state.vbi;\r\nbtv->loop_irq = btv->state.loop_irq;\r\nbttv_buffer_activate_video(btv, &btv->curr);\r\nbttv_buffer_activate_vbi(btv, btv->cvbi);\r\nbttv_set_dma(btv, 0);\r\nspin_unlock_irqrestore(&btv->s_lock,flags);\r\nreturn 0;\r\n}\r\nstatic int __init bttv_init_module(void)\r\n{\r\nint ret;\r\nbttv_num = 0;\r\npr_info("driver version %s loaded\n", BTTV_VERSION);\r\nif (gbuffers < 2 || gbuffers > VIDEO_MAX_FRAME)\r\ngbuffers = 2;\r\nif (gbufsize > BTTV_MAX_FBUF)\r\ngbufsize = BTTV_MAX_FBUF;\r\ngbufsize = (gbufsize + PAGE_SIZE - 1) & PAGE_MASK;\r\nif (bttv_verbose)\r\npr_info("using %d buffers with %dk (%d pages) each for capture\n",\r\ngbuffers, gbufsize >> 10, gbufsize >> PAGE_SHIFT);\r\nbttv_check_chipset();\r\nret = bus_register(&bttv_sub_bus_type);\r\nif (ret < 0) {\r\npr_warn("bus_register error: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = pci_register_driver(&bttv_pci_driver);\r\nif (ret < 0)\r\nbus_unregister(&bttv_sub_bus_type);\r\nreturn ret;\r\n}\r\nstatic void __exit bttv_cleanup_module(void)\r\n{\r\npci_unregister_driver(&bttv_pci_driver);\r\nbus_unregister(&bttv_sub_bus_type);\r\n}
