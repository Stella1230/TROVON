static unsigned int _get_table_maxdiv(const struct clk_div_table *table)\r\n{\r\nunsigned int maxdiv = 0;\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->div > maxdiv)\r\nmaxdiv = clkt->div;\r\nreturn maxdiv;\r\n}\r\nstatic unsigned int _get_maxdiv(struct clk_divider *divider)\r\n{\r\nif (divider->flags & CLK_DIVIDER_ONE_BASED)\r\nreturn div_mask(divider);\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn 1 << div_mask(divider);\r\nif (divider->table)\r\nreturn _get_table_maxdiv(divider->table);\r\nreturn div_mask(divider) + 1;\r\n}\r\nstatic unsigned int _get_table_div(const struct clk_div_table *table,\r\nunsigned int val)\r\n{\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->val == val)\r\nreturn clkt->div;\r\nreturn 0;\r\n}\r\nstatic unsigned int _get_div(struct clk_divider *divider, unsigned int val)\r\n{\r\nif (divider->flags & CLK_DIVIDER_ONE_BASED)\r\nreturn val;\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn 1 << val;\r\nif (divider->table)\r\nreturn _get_table_div(divider->table, val);\r\nreturn val + 1;\r\n}\r\nstatic unsigned int _get_table_val(const struct clk_div_table *table,\r\nunsigned int div)\r\n{\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->div == div)\r\nreturn clkt->val;\r\nreturn 0;\r\n}\r\nstatic unsigned int _get_val(struct clk_divider *divider, u8 div)\r\n{\r\nif (divider->flags & CLK_DIVIDER_ONE_BASED)\r\nreturn div;\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn __ffs(div);\r\nif (divider->table)\r\nreturn _get_table_val(divider->table, div);\r\nreturn div - 1;\r\n}\r\nstatic unsigned long ti_clk_divider_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_divider *divider = to_clk_divider(hw);\r\nunsigned int div, val;\r\nval = ti_clk_ll_ops->clk_readl(divider->reg) >> divider->shift;\r\nval &= div_mask(divider);\r\ndiv = _get_div(divider, val);\r\nif (!div) {\r\nWARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),\r\n"%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n",\r\nclk_hw_get_name(hw));\r\nreturn parent_rate;\r\n}\r\nreturn DIV_ROUND_UP(parent_rate, div);\r\n}\r\nstatic bool _is_valid_table_div(const struct clk_div_table *table,\r\nunsigned int div)\r\n{\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->div == div)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool _is_valid_div(struct clk_divider *divider, unsigned int div)\r\n{\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn is_power_of_2(div);\r\nif (divider->table)\r\nreturn _is_valid_table_div(divider->table, div);\r\nreturn true;\r\n}\r\nstatic int ti_clk_divider_bestdiv(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *best_parent_rate)\r\n{\r\nstruct clk_divider *divider = to_clk_divider(hw);\r\nint i, bestdiv = 0;\r\nunsigned long parent_rate, best = 0, now, maxdiv;\r\nunsigned long parent_rate_saved = *best_parent_rate;\r\nif (!rate)\r\nrate = 1;\r\nmaxdiv = _get_maxdiv(divider);\r\nif (!(clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {\r\nparent_rate = *best_parent_rate;\r\nbestdiv = DIV_ROUND_UP(parent_rate, rate);\r\nbestdiv = bestdiv == 0 ? 1 : bestdiv;\r\nbestdiv = bestdiv > maxdiv ? maxdiv : bestdiv;\r\nreturn bestdiv;\r\n}\r\nmaxdiv = min(ULONG_MAX / rate, maxdiv);\r\nfor (i = 1; i <= maxdiv; i++) {\r\nif (!_is_valid_div(divider, i))\r\ncontinue;\r\nif (rate * i == parent_rate_saved) {\r\n*best_parent_rate = parent_rate_saved;\r\nreturn i;\r\n}\r\nparent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),\r\nMULT_ROUND_UP(rate, i));\r\nnow = DIV_ROUND_UP(parent_rate, i);\r\nif (now <= rate && now > best) {\r\nbestdiv = i;\r\nbest = now;\r\n*best_parent_rate = parent_rate;\r\n}\r\n}\r\nif (!bestdiv) {\r\nbestdiv = _get_maxdiv(divider);\r\n*best_parent_rate =\r\nclk_hw_round_rate(clk_hw_get_parent(hw), 1);\r\n}\r\nreturn bestdiv;\r\n}\r\nstatic long ti_clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nint div;\r\ndiv = ti_clk_divider_bestdiv(hw, rate, prate);\r\nreturn DIV_ROUND_UP(*prate, div);\r\n}\r\nstatic int ti_clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_divider *divider;\r\nunsigned int div, value;\r\nu32 val;\r\nif (!hw || !rate)\r\nreturn -EINVAL;\r\ndivider = to_clk_divider(hw);\r\ndiv = DIV_ROUND_UP(parent_rate, rate);\r\nvalue = _get_val(divider, div);\r\nif (value > div_mask(divider))\r\nvalue = div_mask(divider);\r\nif (divider->flags & CLK_DIVIDER_HIWORD_MASK) {\r\nval = div_mask(divider) << (divider->shift + 16);\r\n} else {\r\nval = ti_clk_ll_ops->clk_readl(divider->reg);\r\nval &= ~(div_mask(divider) << divider->shift);\r\n}\r\nval |= value << divider->shift;\r\nti_clk_ll_ops->clk_writel(val, divider->reg);\r\nreturn 0;\r\n}\r\nstatic struct clk *_register_divider(struct device *dev, const char *name,\r\nconst char *parent_name,\r\nunsigned long flags, void __iomem *reg,\r\nu8 shift, u8 width, u8 clk_divider_flags,\r\nconst struct clk_div_table *table)\r\n{\r\nstruct clk_divider *div;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nif (clk_divider_flags & CLK_DIVIDER_HIWORD_MASK) {\r\nif (width + shift > 16) {\r\npr_warn("divider value exceeds LOWORD field\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div) {\r\npr_err("%s: could not allocate divider clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &ti_clk_divider_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\ndiv->reg = reg;\r\ndiv->shift = shift;\r\ndiv->width = width;\r\ndiv->flags = clk_divider_flags;\r\ndiv->hw.init = &init;\r\ndiv->table = table;\r\nclk = clk_register(dev, &div->hw);\r\nif (IS_ERR(clk))\r\nkfree(div);\r\nreturn clk;\r\n}\r\nstatic struct clk_div_table *\r\n_get_div_table_from_setup(struct ti_clk_divider *setup, u8 *width)\r\n{\r\nint valid_div = 0;\r\nstruct clk_div_table *table;\r\nint i;\r\nint div;\r\nu32 val;\r\nu8 flags;\r\nif (!setup->num_dividers) {\r\nflags = setup->flags;\r\nif (flags & CLKF_INDEX_STARTS_AT_ONE)\r\nval = 1;\r\nelse\r\nval = 0;\r\ndiv = 1;\r\nwhile (div < setup->max_div) {\r\nif (flags & CLKF_INDEX_POWER_OF_TWO)\r\ndiv <<= 1;\r\nelse\r\ndiv++;\r\nval++;\r\n}\r\n*width = fls(val);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < setup->num_dividers; i++)\r\nif (setup->dividers[i])\r\nvalid_div++;\r\ntable = kzalloc(sizeof(*table) * (valid_div + 1), GFP_KERNEL);\r\nif (!table)\r\nreturn ERR_PTR(-ENOMEM);\r\nvalid_div = 0;\r\n*width = 0;\r\nfor (i = 0; i < setup->num_dividers; i++)\r\nif (setup->dividers[i]) {\r\ntable[valid_div].div = setup->dividers[i];\r\ntable[valid_div].val = i;\r\nvalid_div++;\r\n*width = i;\r\n}\r\n*width = fls(*width);\r\nreturn table;\r\n}\r\nstruct clk_hw *ti_clk_build_component_div(struct ti_clk_divider *setup)\r\n{\r\nstruct clk_divider *div;\r\nstruct clk_omap_reg *reg;\r\nif (!setup)\r\nreturn NULL;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn ERR_PTR(-ENOMEM);\r\nreg = (struct clk_omap_reg *)&div->reg;\r\nreg->index = setup->module;\r\nreg->offset = setup->reg;\r\nif (setup->flags & CLKF_INDEX_STARTS_AT_ONE)\r\ndiv->flags |= CLK_DIVIDER_ONE_BASED;\r\nif (setup->flags & CLKF_INDEX_POWER_OF_TWO)\r\ndiv->flags |= CLK_DIVIDER_POWER_OF_TWO;\r\ndiv->table = _get_div_table_from_setup(setup, &div->width);\r\ndiv->shift = setup->bit_shift;\r\nreturn &div->hw;\r\n}\r\nstruct clk *ti_clk_register_divider(struct ti_clk *setup)\r\n{\r\nstruct ti_clk_divider *div;\r\nstruct clk_omap_reg *reg_setup;\r\nu32 reg;\r\nu8 width;\r\nu32 flags = 0;\r\nu8 div_flags = 0;\r\nstruct clk_div_table *table;\r\nstruct clk *clk;\r\ndiv = setup->data;\r\nreg_setup = (struct clk_omap_reg *)&reg;\r\nreg_setup->index = div->module;\r\nreg_setup->offset = div->reg;\r\nif (div->flags & CLKF_INDEX_STARTS_AT_ONE)\r\ndiv_flags |= CLK_DIVIDER_ONE_BASED;\r\nif (div->flags & CLKF_INDEX_POWER_OF_TWO)\r\ndiv_flags |= CLK_DIVIDER_POWER_OF_TWO;\r\nif (div->flags & CLKF_SET_RATE_PARENT)\r\nflags |= CLK_SET_RATE_PARENT;\r\ntable = _get_div_table_from_setup(div, &width);\r\nif (IS_ERR(table))\r\nreturn (struct clk *)table;\r\nclk = _register_divider(NULL, setup->name, div->parent,\r\nflags, (void __iomem *)reg, div->bit_shift,\r\nwidth, div_flags, table);\r\nif (IS_ERR(clk))\r\nkfree(table);\r\nreturn clk;\r\n}\r\nstatic struct clk_div_table *\r\n__init ti_clk_get_div_table(struct device_node *node)\r\n{\r\nstruct clk_div_table *table;\r\nconst __be32 *divspec;\r\nu32 val;\r\nu32 num_div;\r\nu32 valid_div;\r\nint i;\r\ndivspec = of_get_property(node, "ti,dividers", &num_div);\r\nif (!divspec)\r\nreturn NULL;\r\nnum_div /= 4;\r\nvalid_div = 0;\r\nfor (i = 0; i < num_div; i++) {\r\nof_property_read_u32_index(node, "ti,dividers", i, &val);\r\nif (val)\r\nvalid_div++;\r\n}\r\nif (!valid_div) {\r\npr_err("no valid dividers for %s table\n", node->name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntable = kzalloc(sizeof(*table) * (valid_div + 1), GFP_KERNEL);\r\nif (!table)\r\nreturn ERR_PTR(-ENOMEM);\r\nvalid_div = 0;\r\nfor (i = 0; i < num_div; i++) {\r\nof_property_read_u32_index(node, "ti,dividers", i, &val);\r\nif (val) {\r\ntable[valid_div].div = val;\r\ntable[valid_div].val = i;\r\nvalid_div++;\r\n}\r\n}\r\nreturn table;\r\n}\r\nstatic int _get_divider_width(struct device_node *node,\r\nconst struct clk_div_table *table,\r\nu8 flags)\r\n{\r\nu32 min_div;\r\nu32 max_div;\r\nu32 val = 0;\r\nu32 div;\r\nif (!table) {\r\nif (of_property_read_u32(node, "ti,min-div", &min_div))\r\nmin_div = 1;\r\nif (of_property_read_u32(node, "ti,max-div", &max_div)) {\r\npr_err("no max-div for %s!\n", node->name);\r\nreturn -EINVAL;\r\n}\r\nif (flags & CLK_DIVIDER_ONE_BASED)\r\nval = 1;\r\ndiv = min_div;\r\nwhile (div < max_div) {\r\nif (flags & CLK_DIVIDER_POWER_OF_TWO)\r\ndiv <<= 1;\r\nelse\r\ndiv++;\r\nval++;\r\n}\r\n} else {\r\ndiv = 0;\r\nwhile (table[div].div) {\r\nval = table[div].val;\r\ndiv++;\r\n}\r\n}\r\nreturn fls(val);\r\n}\r\nstatic int __init ti_clk_divider_populate(struct device_node *node,\r\nvoid __iomem **reg, const struct clk_div_table **table,\r\nu32 *flags, u8 *div_flags, u8 *width, u8 *shift)\r\n{\r\nu32 val;\r\n*reg = ti_clk_get_reg_addr(node, 0);\r\nif (IS_ERR(*reg))\r\nreturn PTR_ERR(*reg);\r\nif (!of_property_read_u32(node, "ti,bit-shift", &val))\r\n*shift = val;\r\nelse\r\n*shift = 0;\r\n*flags = 0;\r\n*div_flags = 0;\r\nif (of_property_read_bool(node, "ti,index-starts-at-one"))\r\n*div_flags |= CLK_DIVIDER_ONE_BASED;\r\nif (of_property_read_bool(node, "ti,index-power-of-two"))\r\n*div_flags |= CLK_DIVIDER_POWER_OF_TWO;\r\nif (of_property_read_bool(node, "ti,set-rate-parent"))\r\n*flags |= CLK_SET_RATE_PARENT;\r\n*table = ti_clk_get_div_table(node);\r\nif (IS_ERR(*table))\r\nreturn PTR_ERR(*table);\r\n*width = _get_divider_width(node, *table, *div_flags);\r\nreturn 0;\r\n}\r\nstatic void __init of_ti_divider_clk_setup(struct device_node *node)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nvoid __iomem *reg;\r\nu8 clk_divider_flags = 0;\r\nu8 width = 0;\r\nu8 shift = 0;\r\nconst struct clk_div_table *table = NULL;\r\nu32 flags = 0;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\nif (ti_clk_divider_populate(node, &reg, &table, &flags,\r\n&clk_divider_flags, &width, &shift))\r\ngoto cleanup;\r\nclk = _register_divider(NULL, node->name, parent_name, flags, reg,\r\nshift, width, clk_divider_flags, table);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nof_ti_clk_autoidle_setup(node);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(table);\r\n}\r\nstatic void __init of_ti_composite_divider_clk_setup(struct device_node *node)\r\n{\r\nstruct clk_divider *div;\r\nu32 val;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn;\r\nif (ti_clk_divider_populate(node, &div->reg, &div->table, &val,\r\n&div->flags, &div->width, &div->shift) < 0)\r\ngoto cleanup;\r\nif (!ti_clk_add_component(node, &div->hw, CLK_COMPONENT_TYPE_DIVIDER))\r\nreturn;\r\ncleanup:\r\nkfree(div->table);\r\nkfree(div);\r\n}
