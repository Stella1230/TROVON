unsigned fence_context_alloc(unsigned num)\r\n{\r\nBUG_ON(!num);\r\nreturn atomic_add_return(num, &fence_context_counter) - num;\r\n}\r\nint fence_signal_locked(struct fence *fence)\r\n{\r\nstruct fence_cb *cur, *tmp;\r\nint ret = 0;\r\nif (WARN_ON(!fence))\r\nreturn -EINVAL;\r\nif (!ktime_to_ns(fence->timestamp)) {\r\nfence->timestamp = ktime_get();\r\nsmp_mb__before_atomic();\r\n}\r\nif (test_and_set_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags)) {\r\nret = -EINVAL;\r\n} else\r\ntrace_fence_signaled(fence);\r\nlist_for_each_entry_safe(cur, tmp, &fence->cb_list, node) {\r\nlist_del_init(&cur->node);\r\ncur->func(fence, cur);\r\n}\r\nreturn ret;\r\n}\r\nint fence_signal(struct fence *fence)\r\n{\r\nunsigned long flags;\r\nif (!fence)\r\nreturn -EINVAL;\r\nif (!ktime_to_ns(fence->timestamp)) {\r\nfence->timestamp = ktime_get();\r\nsmp_mb__before_atomic();\r\n}\r\nif (test_and_set_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags))\r\nreturn -EINVAL;\r\ntrace_fence_signaled(fence);\r\nif (test_bit(FENCE_FLAG_ENABLE_SIGNAL_BIT, &fence->flags)) {\r\nstruct fence_cb *cur, *tmp;\r\nspin_lock_irqsave(fence->lock, flags);\r\nlist_for_each_entry_safe(cur, tmp, &fence->cb_list, node) {\r\nlist_del_init(&cur->node);\r\ncur->func(fence, cur);\r\n}\r\nspin_unlock_irqrestore(fence->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nsigned long\r\nfence_wait_timeout(struct fence *fence, bool intr, signed long timeout)\r\n{\r\nsigned long ret;\r\nif (WARN_ON(timeout < 0))\r\nreturn -EINVAL;\r\nif (timeout == 0)\r\nreturn fence_is_signaled(fence);\r\ntrace_fence_wait_start(fence);\r\nret = fence->ops->wait(fence, intr, timeout);\r\ntrace_fence_wait_end(fence);\r\nreturn ret;\r\n}\r\nvoid fence_release(struct kref *kref)\r\n{\r\nstruct fence *fence =\r\ncontainer_of(kref, struct fence, refcount);\r\ntrace_fence_destroy(fence);\r\nBUG_ON(!list_empty(&fence->cb_list));\r\nif (fence->ops->release)\r\nfence->ops->release(fence);\r\nelse\r\nfence_free(fence);\r\n}\r\nvoid fence_free(struct fence *fence)\r\n{\r\nkfree_rcu(fence, rcu);\r\n}\r\nvoid fence_enable_sw_signaling(struct fence *fence)\r\n{\r\nunsigned long flags;\r\nif (!test_and_set_bit(FENCE_FLAG_ENABLE_SIGNAL_BIT, &fence->flags) &&\r\n!test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags)) {\r\ntrace_fence_enable_signal(fence);\r\nspin_lock_irqsave(fence->lock, flags);\r\nif (!fence->ops->enable_signaling(fence))\r\nfence_signal_locked(fence);\r\nspin_unlock_irqrestore(fence->lock, flags);\r\n}\r\n}\r\nint fence_add_callback(struct fence *fence, struct fence_cb *cb,\r\nfence_func_t func)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nbool was_set;\r\nif (WARN_ON(!fence || !func))\r\nreturn -EINVAL;\r\nif (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags)) {\r\nINIT_LIST_HEAD(&cb->node);\r\nreturn -ENOENT;\r\n}\r\nspin_lock_irqsave(fence->lock, flags);\r\nwas_set = test_and_set_bit(FENCE_FLAG_ENABLE_SIGNAL_BIT, &fence->flags);\r\nif (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags))\r\nret = -ENOENT;\r\nelse if (!was_set) {\r\ntrace_fence_enable_signal(fence);\r\nif (!fence->ops->enable_signaling(fence)) {\r\nfence_signal_locked(fence);\r\nret = -ENOENT;\r\n}\r\n}\r\nif (!ret) {\r\ncb->func = func;\r\nlist_add_tail(&cb->node, &fence->cb_list);\r\n} else\r\nINIT_LIST_HEAD(&cb->node);\r\nspin_unlock_irqrestore(fence->lock, flags);\r\nreturn ret;\r\n}\r\nbool\r\nfence_remove_callback(struct fence *fence, struct fence_cb *cb)\r\n{\r\nunsigned long flags;\r\nbool ret;\r\nspin_lock_irqsave(fence->lock, flags);\r\nret = !list_empty(&cb->node);\r\nif (ret)\r\nlist_del_init(&cb->node);\r\nspin_unlock_irqrestore(fence->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void\r\nfence_default_wait_cb(struct fence *fence, struct fence_cb *cb)\r\n{\r\nstruct default_wait_cb *wait =\r\ncontainer_of(cb, struct default_wait_cb, base);\r\nwake_up_state(wait->task, TASK_NORMAL);\r\n}\r\nsigned long\r\nfence_default_wait(struct fence *fence, bool intr, signed long timeout)\r\n{\r\nstruct default_wait_cb cb;\r\nunsigned long flags;\r\nsigned long ret = timeout;\r\nbool was_set;\r\nif (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags))\r\nreturn timeout;\r\nspin_lock_irqsave(fence->lock, flags);\r\nif (intr && signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\ngoto out;\r\n}\r\nwas_set = test_and_set_bit(FENCE_FLAG_ENABLE_SIGNAL_BIT, &fence->flags);\r\nif (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags))\r\ngoto out;\r\nif (!was_set) {\r\ntrace_fence_enable_signal(fence);\r\nif (!fence->ops->enable_signaling(fence)) {\r\nfence_signal_locked(fence);\r\ngoto out;\r\n}\r\n}\r\ncb.base.func = fence_default_wait_cb;\r\ncb.task = current;\r\nlist_add(&cb.base.node, &fence->cb_list);\r\nwhile (!test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags) && ret > 0) {\r\nif (intr)\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nelse\r\n__set_current_state(TASK_UNINTERRUPTIBLE);\r\nspin_unlock_irqrestore(fence->lock, flags);\r\nret = schedule_timeout(ret);\r\nspin_lock_irqsave(fence->lock, flags);\r\nif (ret > 0 && intr && signal_pending(current))\r\nret = -ERESTARTSYS;\r\n}\r\nif (!list_empty(&cb.base.node))\r\nlist_del(&cb.base.node);\r\n__set_current_state(TASK_RUNNING);\r\nout:\r\nspin_unlock_irqrestore(fence->lock, flags);\r\nreturn ret;\r\n}\r\nstatic bool\r\nfence_test_signaled_any(struct fence **fences, uint32_t count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; ++i) {\r\nstruct fence *fence = fences[i];\r\nif (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nsigned long\r\nfence_wait_any_timeout(struct fence **fences, uint32_t count,\r\nbool intr, signed long timeout)\r\n{\r\nstruct default_wait_cb *cb;\r\nsigned long ret = timeout;\r\nunsigned i;\r\nif (WARN_ON(!fences || !count || timeout < 0))\r\nreturn -EINVAL;\r\nif (timeout == 0) {\r\nfor (i = 0; i < count; ++i)\r\nif (fence_is_signaled(fences[i]))\r\nreturn 1;\r\nreturn 0;\r\n}\r\ncb = kcalloc(count, sizeof(struct default_wait_cb), GFP_KERNEL);\r\nif (cb == NULL) {\r\nret = -ENOMEM;\r\ngoto err_free_cb;\r\n}\r\nfor (i = 0; i < count; ++i) {\r\nstruct fence *fence = fences[i];\r\nif (fence->ops->wait != fence_default_wait) {\r\nret = -EINVAL;\r\ngoto fence_rm_cb;\r\n}\r\ncb[i].task = current;\r\nif (fence_add_callback(fence, &cb[i].base,\r\nfence_default_wait_cb)) {\r\ngoto fence_rm_cb;\r\n}\r\n}\r\nwhile (ret > 0) {\r\nif (intr)\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nelse\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (fence_test_signaled_any(fences, count))\r\nbreak;\r\nret = schedule_timeout(ret);\r\nif (ret > 0 && intr && signal_pending(current))\r\nret = -ERESTARTSYS;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nfence_rm_cb:\r\nwhile (i-- > 0)\r\nfence_remove_callback(fences[i], &cb[i].base);\r\nerr_free_cb:\r\nkfree(cb);\r\nreturn ret;\r\n}\r\nvoid\r\nfence_init(struct fence *fence, const struct fence_ops *ops,\r\nspinlock_t *lock, unsigned context, unsigned seqno)\r\n{\r\nBUG_ON(!lock);\r\nBUG_ON(!ops || !ops->wait || !ops->enable_signaling ||\r\n!ops->get_driver_name || !ops->get_timeline_name);\r\nkref_init(&fence->refcount);\r\nfence->ops = ops;\r\nINIT_LIST_HEAD(&fence->cb_list);\r\nfence->lock = lock;\r\nfence->context = context;\r\nfence->seqno = seqno;\r\nfence->flags = 0UL;\r\ntrace_fence_init(fence);\r\n}
