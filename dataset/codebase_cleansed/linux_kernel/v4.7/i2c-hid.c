static int __i2c_hid_command(struct i2c_client *client,\r\nconst struct i2c_hid_cmd *command, u8 reportID,\r\nu8 reportType, u8 *args, int args_len,\r\nunsigned char *buf_recv, int data_len)\r\n{\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nunion command *cmd = (union command *)ihid->cmdbuf;\r\nint ret;\r\nstruct i2c_msg msg[2];\r\nint msg_num = 1;\r\nint length = command->length;\r\nbool wait = command->wait;\r\nunsigned int registerIndex = command->registerIndex;\r\nif (command == &hid_descr_cmd) {\r\ncmd->c.reg = ihid->wHIDDescRegister;\r\n} else {\r\ncmd->data[0] = ihid->hdesc_buffer[registerIndex];\r\ncmd->data[1] = ihid->hdesc_buffer[registerIndex + 1];\r\n}\r\nif (length > 2) {\r\ncmd->c.opcode = command->opcode;\r\ncmd->c.reportTypeID = reportID | reportType << 4;\r\n}\r\nmemcpy(cmd->data + length, args, args_len);\r\nlength += args_len;\r\ni2c_hid_dbg(ihid, "%s: cmd=%*ph\n", __func__, length, cmd->data);\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = client->flags & I2C_M_TEN;\r\nmsg[0].len = length;\r\nmsg[0].buf = cmd->data;\r\nif (data_len > 0) {\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = client->flags & I2C_M_TEN;\r\nmsg[1].flags |= I2C_M_RD;\r\nmsg[1].len = data_len;\r\nmsg[1].buf = buf_recv;\r\nmsg_num = 2;\r\nset_bit(I2C_HID_READ_PENDING, &ihid->flags);\r\n}\r\nif (wait)\r\nset_bit(I2C_HID_RESET_PENDING, &ihid->flags);\r\nret = i2c_transfer(client->adapter, msg, msg_num);\r\nif (data_len > 0)\r\nclear_bit(I2C_HID_READ_PENDING, &ihid->flags);\r\nif (ret != msg_num)\r\nreturn ret < 0 ? ret : -EIO;\r\nret = 0;\r\nif (wait) {\r\ni2c_hid_dbg(ihid, "%s: waiting...\n", __func__);\r\nif (!wait_event_timeout(ihid->wait,\r\n!test_bit(I2C_HID_RESET_PENDING, &ihid->flags),\r\nmsecs_to_jiffies(5000)))\r\nret = -ENODATA;\r\ni2c_hid_dbg(ihid, "%s: finished.\n", __func__);\r\n}\r\nreturn ret;\r\n}\r\nstatic int i2c_hid_command(struct i2c_client *client,\r\nconst struct i2c_hid_cmd *command,\r\nunsigned char *buf_recv, int data_len)\r\n{\r\nreturn __i2c_hid_command(client, command, 0, 0, NULL, 0,\r\nbuf_recv, data_len);\r\n}\r\nstatic int i2c_hid_get_report(struct i2c_client *client, u8 reportType,\r\nu8 reportID, unsigned char *buf_recv, int data_len)\r\n{\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nu8 args[3];\r\nint ret;\r\nint args_len = 0;\r\nu16 readRegister = le16_to_cpu(ihid->hdesc.wDataRegister);\r\ni2c_hid_dbg(ihid, "%s\n", __func__);\r\nif (reportID >= 0x0F) {\r\nargs[args_len++] = reportID;\r\nreportID = 0x0F;\r\n}\r\nargs[args_len++] = readRegister & 0xFF;\r\nargs[args_len++] = readRegister >> 8;\r\nret = __i2c_hid_command(client, &hid_get_report_cmd, reportID,\r\nreportType, args, args_len, buf_recv, data_len);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"failed to retrieve report from device.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_set_or_send_report(struct i2c_client *client, u8 reportType,\r\nu8 reportID, unsigned char *buf, size_t data_len, bool use_data)\r\n{\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nu8 *args = ihid->argsbuf;\r\nconst struct i2c_hid_cmd *hidcmd;\r\nint ret;\r\nu16 dataRegister = le16_to_cpu(ihid->hdesc.wDataRegister);\r\nu16 outputRegister = le16_to_cpu(ihid->hdesc.wOutputRegister);\r\nu16 maxOutputLength = le16_to_cpu(ihid->hdesc.wMaxOutputLength);\r\nu16 size;\r\nint args_len;\r\nint index = 0;\r\ni2c_hid_dbg(ihid, "%s\n", __func__);\r\nif (data_len > ihid->bufsize)\r\nreturn -EINVAL;\r\nsize = 2 +\r\n(reportID ? 1 : 0) +\r\ndata_len ;\r\nargs_len = (reportID >= 0x0F ? 1 : 0) +\r\n2 +\r\nsize ;\r\nif (!use_data && maxOutputLength == 0)\r\nreturn -ENOSYS;\r\nif (reportID >= 0x0F) {\r\nargs[index++] = reportID;\r\nreportID = 0x0F;\r\n}\r\nif (use_data) {\r\nargs[index++] = dataRegister & 0xFF;\r\nargs[index++] = dataRegister >> 8;\r\nhidcmd = &hid_set_report_cmd;\r\n} else {\r\nargs[index++] = outputRegister & 0xFF;\r\nargs[index++] = outputRegister >> 8;\r\nhidcmd = &hid_no_cmd;\r\n}\r\nargs[index++] = size & 0xFF;\r\nargs[index++] = size >> 8;\r\nif (reportID)\r\nargs[index++] = reportID;\r\nmemcpy(&args[index], buf, data_len);\r\nret = __i2c_hid_command(client, hidcmd, reportID,\r\nreportType, args, args_len, NULL, 0);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to set a report to device.\n");\r\nreturn ret;\r\n}\r\nreturn data_len;\r\n}\r\nstatic int i2c_hid_set_power(struct i2c_client *client, int power_state)\r\n{\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nint ret;\r\ni2c_hid_dbg(ihid, "%s\n", __func__);\r\nret = __i2c_hid_command(client, &hid_set_power_cmd, power_state,\r\n0, NULL, 0, NULL, 0);\r\nif (ret)\r\ndev_err(&client->dev, "failed to change power setting.\n");\r\nreturn ret;\r\n}\r\nstatic int i2c_hid_hwreset(struct i2c_client *client)\r\n{\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nint ret;\r\ni2c_hid_dbg(ihid, "%s\n", __func__);\r\nmutex_lock(&ihid->reset_lock);\r\nret = i2c_hid_set_power(client, I2C_HID_PWR_ON);\r\nif (ret)\r\ngoto out_unlock;\r\ni2c_hid_dbg(ihid, "resetting...\n");\r\nret = i2c_hid_command(client, &hid_reset_cmd, NULL, 0);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to reset device.\n");\r\ni2c_hid_set_power(client, I2C_HID_PWR_SLEEP);\r\n}\r\nout_unlock:\r\nmutex_unlock(&ihid->reset_lock);\r\nreturn ret;\r\n}\r\nstatic void i2c_hid_get_input(struct i2c_hid *ihid)\r\n{\r\nint ret, ret_size;\r\nint size = le16_to_cpu(ihid->hdesc.wMaxInputLength);\r\nif (size > ihid->bufsize)\r\nsize = ihid->bufsize;\r\nret = i2c_master_recv(ihid->client, ihid->inbuf, size);\r\nif (ret != size) {\r\nif (ret < 0)\r\nreturn;\r\ndev_err(&ihid->client->dev, "%s: got %d data instead of %d\n",\r\n__func__, ret, size);\r\nreturn;\r\n}\r\nret_size = ihid->inbuf[0] | ihid->inbuf[1] << 8;\r\nif (!ret_size) {\r\nif (test_and_clear_bit(I2C_HID_RESET_PENDING, &ihid->flags))\r\nwake_up(&ihid->wait);\r\nreturn;\r\n}\r\nif (ret_size > size) {\r\ndev_err(&ihid->client->dev, "%s: incomplete report (%d/%d)\n",\r\n__func__, size, ret_size);\r\nreturn;\r\n}\r\ni2c_hid_dbg(ihid, "input: %*ph\n", ret_size, ihid->inbuf);\r\nif (test_bit(I2C_HID_STARTED, &ihid->flags))\r\nhid_input_report(ihid->hid, HID_INPUT_REPORT, ihid->inbuf + 2,\r\nret_size - 2, 1);\r\nreturn;\r\n}\r\nstatic irqreturn_t i2c_hid_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_hid *ihid = dev_id;\r\nif (test_bit(I2C_HID_READ_PENDING, &ihid->flags))\r\nreturn IRQ_HANDLED;\r\ni2c_hid_get_input(ihid);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int i2c_hid_get_report_length(struct hid_report *report)\r\n{\r\nreturn ((report->size - 1) >> 3) + 1 +\r\nreport->device->report_enum[report->type].numbered + 2;\r\n}\r\nstatic void i2c_hid_init_report(struct hid_report *report, u8 *buffer,\r\nsize_t bufsize)\r\n{\r\nstruct hid_device *hid = report->device;\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nunsigned int size, ret_size;\r\nsize = i2c_hid_get_report_length(report);\r\nif (i2c_hid_get_report(client,\r\nreport->type == HID_FEATURE_REPORT ? 0x03 : 0x01,\r\nreport->id, buffer, size))\r\nreturn;\r\ni2c_hid_dbg(ihid, "report (len=%d): %*ph\n", size, size, buffer);\r\nret_size = buffer[0] | (buffer[1] << 8);\r\nif (ret_size != size) {\r\ndev_err(&client->dev, "error in %s size:%d / ret_size:%d\n",\r\n__func__, size, ret_size);\r\nreturn;\r\n}\r\nhid_report_raw_event(hid, report->type, buffer + 2, size - 2, 1);\r\n}\r\nstatic void i2c_hid_init_reports(struct hid_device *hid)\r\n{\r\nstruct hid_report *report;\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nu8 *inbuf = kzalloc(ihid->bufsize, GFP_KERNEL);\r\nif (!inbuf) {\r\ndev_err(&client->dev, "can not retrieve initial reports\n");\r\nreturn;\r\n}\r\npm_runtime_get_sync(&client->dev);\r\nlist_for_each_entry(report,\r\n&hid->report_enum[HID_FEATURE_REPORT].report_list, list)\r\ni2c_hid_init_report(report, inbuf, ihid->bufsize);\r\npm_runtime_put(&client->dev);\r\nkfree(inbuf);\r\n}\r\nstatic void i2c_hid_find_max_report(struct hid_device *hid, unsigned int type,\r\nunsigned int *max)\r\n{\r\nstruct hid_report *report;\r\nunsigned int size;\r\nlist_for_each_entry(report, &hid->report_enum[type].report_list, list) {\r\nsize = i2c_hid_get_report_length(report);\r\nif (*max < size)\r\n*max = size;\r\n}\r\n}\r\nstatic void i2c_hid_free_buffers(struct i2c_hid *ihid)\r\n{\r\nkfree(ihid->inbuf);\r\nkfree(ihid->rawbuf);\r\nkfree(ihid->argsbuf);\r\nkfree(ihid->cmdbuf);\r\nihid->inbuf = NULL;\r\nihid->rawbuf = NULL;\r\nihid->cmdbuf = NULL;\r\nihid->argsbuf = NULL;\r\nihid->bufsize = 0;\r\n}\r\nstatic int i2c_hid_alloc_buffers(struct i2c_hid *ihid, size_t report_size)\r\n{\r\nint args_len = sizeof(__u8) +\r\nsizeof(__u16) +\r\nsizeof(__u16) +\r\nreport_size;\r\nihid->inbuf = kzalloc(report_size, GFP_KERNEL);\r\nihid->rawbuf = kzalloc(report_size, GFP_KERNEL);\r\nihid->argsbuf = kzalloc(args_len, GFP_KERNEL);\r\nihid->cmdbuf = kzalloc(sizeof(union command) + args_len, GFP_KERNEL);\r\nif (!ihid->inbuf || !ihid->rawbuf || !ihid->argsbuf || !ihid->cmdbuf) {\r\ni2c_hid_free_buffers(ihid);\r\nreturn -ENOMEM;\r\n}\r\nihid->bufsize = report_size;\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_get_raw_report(struct hid_device *hid,\r\nunsigned char report_number, __u8 *buf, size_t count,\r\nunsigned char report_type)\r\n{\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nsize_t ret_count, ask_count;\r\nint ret;\r\nif (report_type == HID_OUTPUT_REPORT)\r\nreturn -EINVAL;\r\nask_count = min(count + 2, (size_t)ihid->bufsize);\r\nret = i2c_hid_get_report(client,\r\nreport_type == HID_FEATURE_REPORT ? 0x03 : 0x01,\r\nreport_number, ihid->rawbuf, ask_count);\r\nif (ret < 0)\r\nreturn ret;\r\nret_count = ihid->rawbuf[0] | (ihid->rawbuf[1] << 8);\r\nif (ret_count <= 2)\r\nreturn 0;\r\nret_count = min(ret_count, ask_count);\r\ncount = min(count, ret_count - 2);\r\nmemcpy(buf, ihid->rawbuf + 2, count);\r\nreturn count;\r\n}\r\nstatic int i2c_hid_output_raw_report(struct hid_device *hid, __u8 *buf,\r\nsize_t count, unsigned char report_type, bool use_data)\r\n{\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nint report_id = buf[0];\r\nint ret;\r\nif (report_type == HID_INPUT_REPORT)\r\nreturn -EINVAL;\r\nmutex_lock(&ihid->reset_lock);\r\nif (report_id) {\r\nbuf++;\r\ncount--;\r\n}\r\nret = i2c_hid_set_or_send_report(client,\r\nreport_type == HID_FEATURE_REPORT ? 0x03 : 0x02,\r\nreport_id, buf, count, use_data);\r\nif (report_id && ret >= 0)\r\nret++;\r\nmutex_unlock(&ihid->reset_lock);\r\nreturn ret;\r\n}\r\nstatic int i2c_hid_output_report(struct hid_device *hid, __u8 *buf,\r\nsize_t count)\r\n{\r\nreturn i2c_hid_output_raw_report(hid, buf, count, HID_OUTPUT_REPORT,\r\nfalse);\r\n}\r\nstatic int i2c_hid_raw_request(struct hid_device *hid, unsigned char reportnum,\r\n__u8 *buf, size_t len, unsigned char rtype,\r\nint reqtype)\r\n{\r\nswitch (reqtype) {\r\ncase HID_REQ_GET_REPORT:\r\nreturn i2c_hid_get_raw_report(hid, reportnum, buf, len, rtype);\r\ncase HID_REQ_SET_REPORT:\r\nif (buf[0] != reportnum)\r\nreturn -EINVAL;\r\nreturn i2c_hid_output_raw_report(hid, buf, len, rtype, true);\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int i2c_hid_parse(struct hid_device *hid)\r\n{\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nstruct i2c_hid_desc *hdesc = &ihid->hdesc;\r\nunsigned int rsize;\r\nchar *rdesc;\r\nint ret;\r\nint tries = 3;\r\ni2c_hid_dbg(ihid, "entering %s\n", __func__);\r\nrsize = le16_to_cpu(hdesc->wReportDescLength);\r\nif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\r\ndbg_hid("weird size of report descriptor (%u)\n", rsize);\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nret = i2c_hid_hwreset(client);\r\nif (ret)\r\nmsleep(1000);\r\n} while (tries-- > 0 && ret);\r\nif (ret)\r\nreturn ret;\r\nrdesc = kzalloc(rsize, GFP_KERNEL);\r\nif (!rdesc) {\r\ndbg_hid("couldn't allocate rdesc memory\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_hid_dbg(ihid, "asking HID report descriptor\n");\r\nret = i2c_hid_command(client, &hid_report_descr_cmd, rdesc, rsize);\r\nif (ret) {\r\nhid_err(hid, "reading report descriptor failed\n");\r\nkfree(rdesc);\r\nreturn -EIO;\r\n}\r\ni2c_hid_dbg(ihid, "Report Descriptor: %*ph\n", rsize, rdesc);\r\nret = hid_parse_report(hid, rdesc, rsize);\r\nkfree(rdesc);\r\nif (ret) {\r\ndbg_hid("parsing report descriptor failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_start(struct hid_device *hid)\r\n{\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nint ret;\r\nunsigned int bufsize = HID_MIN_BUFFER_SIZE;\r\ni2c_hid_find_max_report(hid, HID_INPUT_REPORT, &bufsize);\r\ni2c_hid_find_max_report(hid, HID_OUTPUT_REPORT, &bufsize);\r\ni2c_hid_find_max_report(hid, HID_FEATURE_REPORT, &bufsize);\r\nif (bufsize > ihid->bufsize) {\r\ni2c_hid_free_buffers(ihid);\r\nret = i2c_hid_alloc_buffers(ihid, bufsize);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!(hid->quirks & HID_QUIRK_NO_INIT_REPORTS))\r\ni2c_hid_init_reports(hid);\r\nreturn 0;\r\n}\r\nstatic void i2c_hid_stop(struct hid_device *hid)\r\n{\r\nhid->claimed = 0;\r\n}\r\nstatic int i2c_hid_open(struct hid_device *hid)\r\n{\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nint ret = 0;\r\nmutex_lock(&i2c_hid_open_mut);\r\nif (!hid->open++) {\r\nret = pm_runtime_get_sync(&client->dev);\r\nif (ret < 0) {\r\nhid->open--;\r\ngoto done;\r\n}\r\nset_bit(I2C_HID_STARTED, &ihid->flags);\r\n}\r\ndone:\r\nmutex_unlock(&i2c_hid_open_mut);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic void i2c_hid_close(struct hid_device *hid)\r\n{\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nmutex_lock(&i2c_hid_open_mut);\r\nif (!--hid->open) {\r\nclear_bit(I2C_HID_STARTED, &ihid->flags);\r\npm_runtime_put(&client->dev);\r\n}\r\nmutex_unlock(&i2c_hid_open_mut);\r\n}\r\nstatic int i2c_hid_power(struct hid_device *hid, int lvl)\r\n{\r\nstruct i2c_client *client = hid->driver_data;\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\ni2c_hid_dbg(ihid, "%s lvl:%d\n", __func__, lvl);\r\nswitch (lvl) {\r\ncase PM_HINT_FULLON:\r\npm_runtime_get_sync(&client->dev);\r\nbreak;\r\ncase PM_HINT_NORMAL:\r\npm_runtime_put(&client->dev);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_init_irq(struct i2c_client *client)\r\n{\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nint ret;\r\ndev_dbg(&client->dev, "Requesting IRQ: %d\n", ihid->irq);\r\nret = request_threaded_irq(ihid->irq, NULL, i2c_hid_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nclient->name, ihid);\r\nif (ret < 0) {\r\ndev_warn(&client->dev,\r\n"Could not register for %s interrupt, irq = %d,"\r\n" ret = %d\n",\r\nclient->name, ihid->irq, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_fetch_hid_descriptor(struct i2c_hid *ihid)\r\n{\r\nstruct i2c_client *client = ihid->client;\r\nstruct i2c_hid_desc *hdesc = &ihid->hdesc;\r\nunsigned int dsize;\r\nint ret;\r\ni2c_hid_dbg(ihid, "Fetching the HID descriptor\n");\r\nret = i2c_hid_command(client, &hid_descr_cmd, ihid->hdesc_buffer,\r\nsizeof(struct i2c_hid_desc));\r\nif (ret) {\r\ndev_err(&client->dev, "hid_descr_cmd failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (le16_to_cpu(hdesc->bcdVersion) != 0x0100) {\r\ndev_err(&client->dev,\r\n"unexpected HID descriptor bcdVersion (0x%04hx)\n",\r\nle16_to_cpu(hdesc->bcdVersion));\r\nreturn -ENODEV;\r\n}\r\ndsize = le16_to_cpu(hdesc->wHIDDescLength);\r\nif (dsize != sizeof(struct i2c_hid_desc)) {\r\ndev_err(&client->dev, "weird size of HID descriptor (%u)\n",\r\ndsize);\r\nreturn -ENODEV;\r\n}\r\ni2c_hid_dbg(ihid, "HID Descriptor: %*ph\n", dsize, ihid->hdesc_buffer);\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_acpi_pdata(struct i2c_client *client,\r\nstruct i2c_hid_platform_data *pdata)\r\n{\r\nstatic u8 i2c_hid_guid[] = {\r\n0xF7, 0xF6, 0xDF, 0x3C, 0x67, 0x42, 0x55, 0x45,\r\n0xAD, 0x05, 0xB3, 0x0A, 0x3D, 0x89, 0x38, 0xDE,\r\n};\r\nunion acpi_object *obj;\r\nstruct acpi_device *adev;\r\nacpi_handle handle;\r\nint ret;\r\nhandle = ACPI_HANDLE(&client->dev);\r\nif (!handle || acpi_bus_get_device(handle, &adev))\r\nreturn -ENODEV;\r\nobj = acpi_evaluate_dsm_typed(handle, i2c_hid_guid, 1, 1, NULL,\r\nACPI_TYPE_INTEGER);\r\nif (!obj) {\r\ndev_err(&client->dev, "device _DSM execution failed\n");\r\nreturn -ENODEV;\r\n}\r\npdata->hid_descriptor_address = obj->integer.value;\r\nACPI_FREE(obj);\r\nret = acpi_dev_add_driver_gpios(adev, i2c_hid_acpi_gpios);\r\nreturn ret < 0 && ret != -ENXIO ? ret : 0;\r\n}\r\nstatic inline int i2c_hid_acpi_pdata(struct i2c_client *client,\r\nstruct i2c_hid_platform_data *pdata)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int i2c_hid_of_probe(struct i2c_client *client,\r\nstruct i2c_hid_platform_data *pdata)\r\n{\r\nstruct device *dev = &client->dev;\r\nu32 val;\r\nint ret;\r\nret = of_property_read_u32(dev->of_node, "hid-descr-addr", &val);\r\nif (ret) {\r\ndev_err(&client->dev, "HID register address not provided\n");\r\nreturn -ENODEV;\r\n}\r\nif (val >> 16) {\r\ndev_err(&client->dev, "Bad HID register address: 0x%08x\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\npdata->hid_descriptor_address = val;\r\nreturn 0;\r\n}\r\nstatic inline int i2c_hid_of_probe(struct i2c_client *client,\r\nstruct i2c_hid_platform_data *pdata)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int i2c_hid_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *dev_id)\r\n{\r\nint ret;\r\nstruct i2c_hid *ihid;\r\nstruct hid_device *hid;\r\n__u16 hidRegister;\r\nstruct i2c_hid_platform_data *platform_data = client->dev.platform_data;\r\ndbg_hid("HID probe called for i2c 0x%02x\n", client->addr);\r\nihid = kzalloc(sizeof(struct i2c_hid), GFP_KERNEL);\r\nif (!ihid)\r\nreturn -ENOMEM;\r\nif (client->dev.of_node) {\r\nret = i2c_hid_of_probe(client, &ihid->pdata);\r\nif (ret)\r\ngoto err;\r\n} else if (!platform_data) {\r\nret = i2c_hid_acpi_pdata(client, &ihid->pdata);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"HID register address not provided\n");\r\ngoto err;\r\n}\r\n} else {\r\nihid->pdata = *platform_data;\r\n}\r\nif (client->irq > 0) {\r\nihid->irq = client->irq;\r\n} else if (ACPI_COMPANION(&client->dev)) {\r\nihid->desc = gpiod_get(&client->dev, NULL, GPIOD_IN);\r\nif (IS_ERR(ihid->desc)) {\r\ndev_err(&client->dev, "Failed to get GPIO interrupt\n");\r\nreturn PTR_ERR(ihid->desc);\r\n}\r\nihid->irq = gpiod_to_irq(ihid->desc);\r\nif (ihid->irq < 0) {\r\ngpiod_put(ihid->desc);\r\ndev_err(&client->dev, "Failed to convert GPIO to IRQ\n");\r\nreturn ihid->irq;\r\n}\r\n}\r\ni2c_set_clientdata(client, ihid);\r\nihid->client = client;\r\nhidRegister = ihid->pdata.hid_descriptor_address;\r\nihid->wHIDDescRegister = cpu_to_le16(hidRegister);\r\ninit_waitqueue_head(&ihid->wait);\r\nmutex_init(&ihid->reset_lock);\r\nret = i2c_hid_alloc_buffers(ihid, HID_MIN_BUFFER_SIZE);\r\nif (ret < 0)\r\ngoto err;\r\npm_runtime_get_noresume(&client->dev);\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_enable(&client->dev);\r\nret = i2c_hid_fetch_hid_descriptor(ihid);\r\nif (ret < 0)\r\ngoto err_pm;\r\nret = i2c_hid_init_irq(client);\r\nif (ret < 0)\r\ngoto err_pm;\r\nhid = hid_allocate_device();\r\nif (IS_ERR(hid)) {\r\nret = PTR_ERR(hid);\r\ngoto err_irq;\r\n}\r\nihid->hid = hid;\r\nhid->driver_data = client;\r\nhid->ll_driver = &i2c_hid_ll_driver;\r\nhid->dev.parent = &client->dev;\r\nhid->bus = BUS_I2C;\r\nhid->version = le16_to_cpu(ihid->hdesc.bcdVersion);\r\nhid->vendor = le16_to_cpu(ihid->hdesc.wVendorID);\r\nhid->product = le16_to_cpu(ihid->hdesc.wProductID);\r\nsnprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX",\r\nclient->name, hid->vendor, hid->product);\r\nstrlcpy(hid->phys, dev_name(&client->dev), sizeof(hid->phys));\r\nret = hid_add_device(hid);\r\nif (ret) {\r\nif (ret != -ENODEV)\r\nhid_err(client, "can't add hid device: %d\n", ret);\r\ngoto err_mem_free;\r\n}\r\npm_runtime_put(&client->dev);\r\nreturn 0;\r\nerr_mem_free:\r\nhid_destroy_device(hid);\r\nerr_irq:\r\nfree_irq(ihid->irq, ihid);\r\nerr_pm:\r\npm_runtime_put_noidle(&client->dev);\r\npm_runtime_disable(&client->dev);\r\nerr:\r\nif (ihid->desc)\r\ngpiod_put(ihid->desc);\r\ni2c_hid_free_buffers(ihid);\r\nkfree(ihid);\r\nreturn ret;\r\n}\r\nstatic int i2c_hid_remove(struct i2c_client *client)\r\n{\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nstruct hid_device *hid;\r\npm_runtime_get_sync(&client->dev);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\nhid = ihid->hid;\r\nhid_destroy_device(hid);\r\nfree_irq(ihid->irq, ihid);\r\nif (ihid->bufsize)\r\ni2c_hid_free_buffers(ihid);\r\nif (ihid->desc)\r\ngpiod_put(ihid->desc);\r\nkfree(ihid);\r\nacpi_dev_remove_driver_gpios(ACPI_COMPANION(&client->dev));\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nstruct hid_device *hid = ihid->hid;\r\nint ret;\r\nint wake_status;\r\nif (hid->driver && hid->driver->suspend) {\r\nret = pm_runtime_resume(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = hid->driver->suspend(hid, PMSG_SUSPEND);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!pm_runtime_suspended(dev)) {\r\ni2c_hid_set_power(client, I2C_HID_PWR_SLEEP);\r\ndisable_irq(ihid->irq);\r\n}\r\nif (device_may_wakeup(&client->dev)) {\r\nwake_status = enable_irq_wake(ihid->irq);\r\nif (!wake_status)\r\nihid->irq_wake_enabled = true;\r\nelse\r\nhid_warn(hid, "Failed to enable irq wake: %d\n",\r\nwake_status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nstruct hid_device *hid = ihid->hid;\r\nint wake_status;\r\nif (device_may_wakeup(&client->dev) && ihid->irq_wake_enabled) {\r\nwake_status = disable_irq_wake(ihid->irq);\r\nif (!wake_status)\r\nihid->irq_wake_enabled = false;\r\nelse\r\nhid_warn(hid, "Failed to disable irq wake: %d\n",\r\nwake_status);\r\n}\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nenable_irq(ihid->irq);\r\nret = i2c_hid_hwreset(client);\r\nif (ret)\r\nreturn ret;\r\nif (hid->driver && hid->driver->reset_resume) {\r\nret = hid->driver->reset_resume(hid);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\ni2c_hid_set_power(client, I2C_HID_PWR_SLEEP);\r\ndisable_irq(ihid->irq);\r\nreturn 0;\r\n}\r\nstatic int i2c_hid_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct i2c_hid *ihid = i2c_get_clientdata(client);\r\nenable_irq(ihid->irq);\r\ni2c_hid_set_power(client, I2C_HID_PWR_ON);\r\nreturn 0;\r\n}
