static int clk_rcg2_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nu32 cmd;\r\nint ret;\r\nret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG, &cmd);\r\nif (ret)\r\nreturn ret;\r\nreturn (cmd & CMD_ROOT_OFF) == 0;\r\n}\r\nstatic u8 clk_rcg2_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nint num_parents = clk_hw_get_num_parents(hw);\r\nu32 cfg;\r\nint i, ret;\r\nret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);\r\nif (ret)\r\ngoto err;\r\ncfg &= CFG_SRC_SEL_MASK;\r\ncfg >>= CFG_SRC_SEL_SHIFT;\r\nfor (i = 0; i < num_parents; i++)\r\nif (cfg == rcg->parent_map[i].cfg)\r\nreturn i;\r\nerr:\r\npr_debug("%s: Clock %s has invalid parent, using default.\n",\r\n__func__, clk_hw_get_name(hw));\r\nreturn 0;\r\n}\r\nstatic int update_config(struct clk_rcg2 *rcg)\r\n{\r\nint count, ret;\r\nu32 cmd;\r\nstruct clk_hw *hw = &rcg->clkr.hw;\r\nconst char *name = clk_hw_get_name(hw);\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG,\r\nCMD_UPDATE, CMD_UPDATE);\r\nif (ret)\r\nreturn ret;\r\nfor (count = 500; count > 0; count--) {\r\nret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG, &cmd);\r\nif (ret)\r\nreturn ret;\r\nif (!(cmd & CMD_UPDATE))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nWARN(1, "%s: rcg didn't update its configuration.", name);\r\nreturn 0;\r\n}\r\nstatic int clk_rcg2_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nint ret;\r\nu32 cfg = rcg->parent_map[index].cfg << CFG_SRC_SEL_SHIFT;\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG,\r\nCFG_SRC_SEL_MASK, cfg);\r\nif (ret)\r\nreturn ret;\r\nreturn update_config(rcg);\r\n}\r\nstatic unsigned long\r\ncalc_rate(unsigned long rate, u32 m, u32 n, u32 mode, u32 hid_div)\r\n{\r\nif (hid_div) {\r\nrate *= 2;\r\nrate /= hid_div + 1;\r\n}\r\nif (mode) {\r\nu64 tmp = rate;\r\ntmp *= m;\r\ndo_div(tmp, n);\r\nrate = tmp;\r\n}\r\nreturn rate;\r\n}\r\nstatic unsigned long\r\nclk_rcg2_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nu32 cfg, hid_div, m = 0, n = 0, mode = 0, mask;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);\r\nif (rcg->mnd_width) {\r\nmask = BIT(rcg->mnd_width) - 1;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + M_REG, &m);\r\nm &= mask;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + N_REG, &n);\r\nn = ~n;\r\nn &= mask;\r\nn += m;\r\nmode = cfg & CFG_MODE_MASK;\r\nmode >>= CFG_MODE_SHIFT;\r\n}\r\nmask = BIT(rcg->hid_width) - 1;\r\nhid_div = cfg >> CFG_SRC_DIV_SHIFT;\r\nhid_div &= mask;\r\nreturn calc_rate(parent_rate, m, n, mode, hid_div);\r\n}\r\nstatic int _freq_tbl_determine_rate(struct clk_hw *hw,\r\nconst struct freq_tbl *f, struct clk_rate_request *req)\r\n{\r\nunsigned long clk_flags, rate = req->rate;\r\nstruct clk_hw *p;\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nint index;\r\nf = qcom_find_freq(f, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nindex = qcom_find_src_index(hw, rcg->parent_map, f->src);\r\nif (index < 0)\r\nreturn index;\r\nclk_flags = clk_hw_get_flags(hw);\r\np = clk_hw_get_parent_by_index(hw, index);\r\nif (clk_flags & CLK_SET_RATE_PARENT) {\r\nif (f->pre_div) {\r\nrate /= 2;\r\nrate *= f->pre_div + 1;\r\n}\r\nif (f->n) {\r\nu64 tmp = rate;\r\ntmp = tmp * f->n;\r\ndo_div(tmp, f->m);\r\nrate = tmp;\r\n}\r\n} else {\r\nrate = clk_hw_get_rate(p);\r\n}\r\nreq->best_parent_hw = p;\r\nreq->best_parent_rate = rate;\r\nreq->rate = f->freq;\r\nreturn 0;\r\n}\r\nstatic int clk_rcg2_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, req);\r\n}\r\nstatic int clk_rcg2_configure(struct clk_rcg2 *rcg, const struct freq_tbl *f)\r\n{\r\nu32 cfg, mask;\r\nstruct clk_hw *hw = &rcg->clkr.hw;\r\nint ret, index = qcom_find_src_index(hw, rcg->parent_map, f->src);\r\nif (index < 0)\r\nreturn index;\r\nif (rcg->mnd_width && f->n) {\r\nmask = BIT(rcg->mnd_width) - 1;\r\nret = regmap_update_bits(rcg->clkr.regmap,\r\nrcg->cmd_rcgr + M_REG, mask, f->m);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(rcg->clkr.regmap,\r\nrcg->cmd_rcgr + N_REG, mask, ~(f->n - f->m));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(rcg->clkr.regmap,\r\nrcg->cmd_rcgr + D_REG, mask, ~f->n);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmask = BIT(rcg->hid_width) - 1;\r\nmask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;\r\ncfg = f->pre_div << CFG_SRC_DIV_SHIFT;\r\ncfg |= rcg->parent_map[index].cfg << CFG_SRC_SEL_SHIFT;\r\nif (rcg->mnd_width && f->n && (f->m != f->n))\r\ncfg |= CFG_MODE_DUAL_EDGE;\r\nret = regmap_update_bits(rcg->clkr.regmap,\r\nrcg->cmd_rcgr + CFG_REG, mask, cfg);\r\nif (ret)\r\nreturn ret;\r\nreturn update_config(rcg);\r\n}\r\nstatic int __clk_rcg2_set_rate(struct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nconst struct freq_tbl *f;\r\nf = qcom_find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nreturn clk_rcg2_configure(rcg, f);\r\n}\r\nstatic int clk_rcg2_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn __clk_rcg2_set_rate(hw, rate);\r\n}\r\nstatic int clk_rcg2_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn __clk_rcg2_set_rate(hw, rate);\r\n}\r\nstatic int clk_rcg2_shared_force_enable(struct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nconst char *name = clk_hw_get_name(hw);\r\nint ret, count;\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG,\r\nCMD_ROOT_EN, CMD_ROOT_EN);\r\nif (ret)\r\nreturn ret;\r\nfor (count = 500; count > 0; count--) {\r\nret = clk_rcg2_is_enabled(hw);\r\nif (ret)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (!count)\r\npr_err("%s: RCG did not turn on\n", name);\r\nret = __clk_rcg2_set_rate(hw, rate);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG,\r\nCMD_ROOT_EN, 0);\r\n}\r\nstatic int clk_rcg2_shared_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nrcg->current_freq = rate;\r\nif (!__clk_is_enabled(hw->clk))\r\nreturn 0;\r\nreturn clk_rcg2_shared_force_enable(hw, rcg->current_freq);\r\n}\r\nstatic unsigned long\r\nclk_rcg2_shared_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nreturn rcg->current_freq = clk_rcg2_recalc_rate(hw, parent_rate);\r\n}\r\nstatic int clk_rcg2_shared_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nreturn clk_rcg2_shared_force_enable(hw, rcg->current_freq);\r\n}\r\nstatic void clk_rcg2_shared_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nclk_rcg2_shared_set_rate(hw, rcg->freq_tbl[0].freq, 0);\r\n}\r\nstatic int clk_edp_pixel_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nstruct freq_tbl f = *rcg->freq_tbl;\r\nconst struct frac_entry *frac;\r\nint delta = 100000;\r\ns64 src_rate = parent_rate;\r\ns64 request;\r\nu32 mask = BIT(rcg->hid_width) - 1;\r\nu32 hid_div;\r\nif (src_rate == 810000000)\r\nfrac = frac_table_810m;\r\nelse\r\nfrac = frac_table_675m;\r\nfor (; frac->num; frac++) {\r\nrequest = rate;\r\nrequest *= frac->den;\r\nrequest = div_s64(request, frac->num);\r\nif ((src_rate < (request - delta)) ||\r\n(src_rate > (request + delta)))\r\ncontinue;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG,\r\n&hid_div);\r\nf.pre_div = hid_div;\r\nf.pre_div >>= CFG_SRC_DIV_SHIFT;\r\nf.pre_div &= mask;\r\nf.m = frac->num;\r\nf.n = frac->den;\r\nreturn clk_rcg2_configure(rcg, &f);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_edp_pixel_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn clk_edp_pixel_set_rate(hw, rate, parent_rate);\r\n}\r\nstatic int clk_edp_pixel_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nconst struct freq_tbl *f = rcg->freq_tbl;\r\nconst struct frac_entry *frac;\r\nint delta = 100000;\r\ns64 request;\r\nu32 mask = BIT(rcg->hid_width) - 1;\r\nu32 hid_div;\r\nint index = qcom_find_src_index(hw, rcg->parent_map, f->src);\r\nreq->best_parent_hw = clk_hw_get_parent_by_index(hw, index);\r\nreq->best_parent_rate = clk_hw_get_rate(req->best_parent_hw);\r\nif (req->best_parent_rate == 810000000)\r\nfrac = frac_table_810m;\r\nelse\r\nfrac = frac_table_675m;\r\nfor (; frac->num; frac++) {\r\nrequest = req->rate;\r\nrequest *= frac->den;\r\nrequest = div_s64(request, frac->num);\r\nif ((req->best_parent_rate < (request - delta)) ||\r\n(req->best_parent_rate > (request + delta)))\r\ncontinue;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG,\r\n&hid_div);\r\nhid_div >>= CFG_SRC_DIV_SHIFT;\r\nhid_div &= mask;\r\nreq->rate = calc_rate(req->best_parent_rate,\r\nfrac->num, frac->den,\r\n!!frac->den, hid_div);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_byte_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nconst struct freq_tbl *f = rcg->freq_tbl;\r\nint index = qcom_find_src_index(hw, rcg->parent_map, f->src);\r\nunsigned long parent_rate, div;\r\nu32 mask = BIT(rcg->hid_width) - 1;\r\nstruct clk_hw *p;\r\nif (req->rate == 0)\r\nreturn -EINVAL;\r\nreq->best_parent_hw = p = clk_hw_get_parent_by_index(hw, index);\r\nreq->best_parent_rate = parent_rate = clk_hw_round_rate(p, req->rate);\r\ndiv = DIV_ROUND_UP((2 * parent_rate), req->rate) - 1;\r\ndiv = min_t(u32, div, mask);\r\nreq->rate = calc_rate(parent_rate, 0, 0, 0, div);\r\nreturn 0;\r\n}\r\nstatic int clk_byte_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nstruct freq_tbl f = *rcg->freq_tbl;\r\nunsigned long div;\r\nu32 mask = BIT(rcg->hid_width) - 1;\r\ndiv = DIV_ROUND_UP((2 * parent_rate), rate) - 1;\r\ndiv = min_t(u32, div, mask);\r\nf.pre_div = div;\r\nreturn clk_rcg2_configure(rcg, &f);\r\n}\r\nstatic int clk_byte_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn clk_byte_set_rate(hw, rate, parent_rate);\r\n}\r\nstatic int clk_byte2_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nunsigned long parent_rate, div;\r\nu32 mask = BIT(rcg->hid_width) - 1;\r\nstruct clk_hw *p;\r\nunsigned long rate = req->rate;\r\nif (rate == 0)\r\nreturn -EINVAL;\r\np = req->best_parent_hw;\r\nreq->best_parent_rate = parent_rate = clk_hw_round_rate(p, rate);\r\ndiv = DIV_ROUND_UP((2 * parent_rate), rate) - 1;\r\ndiv = min_t(u32, div, mask);\r\nreq->rate = calc_rate(parent_rate, 0, 0, 0, div);\r\nreturn 0;\r\n}\r\nstatic int clk_byte2_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nstruct freq_tbl f = { 0 };\r\nunsigned long div;\r\nint i, num_parents = clk_hw_get_num_parents(hw);\r\nu32 mask = BIT(rcg->hid_width) - 1;\r\nu32 cfg;\r\ndiv = DIV_ROUND_UP((2 * parent_rate), rate) - 1;\r\ndiv = min_t(u32, div, mask);\r\nf.pre_div = div;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);\r\ncfg &= CFG_SRC_SEL_MASK;\r\ncfg >>= CFG_SRC_SEL_SHIFT;\r\nfor (i = 0; i < num_parents; i++) {\r\nif (cfg == rcg->parent_map[i].cfg) {\r\nf.src = rcg->parent_map[i].src;\r\nreturn clk_rcg2_configure(rcg, &f);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_byte2_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn clk_byte2_set_rate(hw, rate, parent_rate);\r\n}\r\nstatic int clk_pixel_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nunsigned long request, src_rate;\r\nint delta = 100000;\r\nconst struct frac_entry *frac = frac_table_pixel;\r\nfor (; frac->num; frac++) {\r\nrequest = (req->rate * frac->den) / frac->num;\r\nsrc_rate = clk_hw_round_rate(req->best_parent_hw, request);\r\nif ((src_rate < (request - delta)) ||\r\n(src_rate > (request + delta)))\r\ncontinue;\r\nreq->best_parent_rate = src_rate;\r\nreq->rate = (src_rate * frac->num) / frac->den;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_pixel_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nstruct freq_tbl f = { 0 };\r\nconst struct frac_entry *frac = frac_table_pixel;\r\nunsigned long request;\r\nint delta = 100000;\r\nu32 mask = BIT(rcg->hid_width) - 1;\r\nu32 hid_div, cfg;\r\nint i, num_parents = clk_hw_get_num_parents(hw);\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);\r\ncfg &= CFG_SRC_SEL_MASK;\r\ncfg >>= CFG_SRC_SEL_SHIFT;\r\nfor (i = 0; i < num_parents; i++)\r\nif (cfg == rcg->parent_map[i].cfg) {\r\nf.src = rcg->parent_map[i].src;\r\nbreak;\r\n}\r\nfor (; frac->num; frac++) {\r\nrequest = (rate * frac->den) / frac->num;\r\nif ((parent_rate < (request - delta)) ||\r\n(parent_rate > (request + delta)))\r\ncontinue;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG,\r\n&hid_div);\r\nf.pre_div = hid_div;\r\nf.pre_div >>= CFG_SRC_DIV_SHIFT;\r\nf.pre_div &= mask;\r\nf.m = frac->num;\r\nf.n = frac->den;\r\nreturn clk_rcg2_configure(rcg, &f);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_pixel_set_rate_and_parent(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate, u8 index)\r\n{\r\nreturn clk_pixel_set_rate(hw, rate, parent_rate);\r\n}\r\nstatic int clk_gfx3d_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rate_request parent_req = { };\r\nstruct clk_hw *p2, *p8, *p9, *xo;\r\nunsigned long p9_rate;\r\nint ret;\r\nxo = clk_hw_get_parent_by_index(hw, 0);\r\nif (req->rate == clk_hw_get_rate(xo)) {\r\nreq->best_parent_hw = xo;\r\nreturn 0;\r\n}\r\np9 = clk_hw_get_parent_by_index(hw, 2);\r\np2 = clk_hw_get_parent_by_index(hw, 3);\r\np8 = clk_hw_get_parent_by_index(hw, 4);\r\np9_rate = clk_hw_get_rate(p9);\r\nparent_req.rate = req->rate = min(req->rate, p9_rate);\r\nif (req->rate == p9_rate) {\r\nreq->rate = req->best_parent_rate = p9_rate;\r\nreq->best_parent_hw = p9;\r\nreturn 0;\r\n}\r\nif (req->best_parent_hw == p9) {\r\nif (clk_hw_get_rate(p8) == req->rate)\r\nreq->best_parent_hw = p8;\r\nelse\r\nreq->best_parent_hw = p2;\r\n} else if (req->best_parent_hw == p8) {\r\nreq->best_parent_hw = p2;\r\n} else {\r\nreq->best_parent_hw = p8;\r\n}\r\nret = __clk_determine_rate(req->best_parent_hw, &parent_req);\r\nif (ret)\r\nreturn ret;\r\nreq->rate = req->best_parent_rate = parent_req.rate;\r\nreturn 0;\r\n}\r\nstatic int clk_gfx3d_set_rate_and_parent(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate, u8 index)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nu32 cfg;\r\nint ret;\r\ncfg = rcg->parent_map[index].cfg << CFG_SRC_SEL_SHIFT;\r\nret = regmap_write(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, cfg);\r\nif (ret)\r\nreturn ret;\r\nreturn update_config(rcg);\r\n}\r\nstatic int clk_gfx3d_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn 0;\r\n}
