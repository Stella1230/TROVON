static int eject_tray(struct ata_device *dev)\r\n{\r\nstruct ata_taskfile tf;\r\nconst char cdb[] = { GPCMD_START_STOP_UNIT,\r\n0, 0, 0,\r\n0x02,\r\n0, 0, 0, 0, 0, 0, 0,\r\n};\r\nata_tf_init(dev, &tf);\r\ntf.flags = ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf.command = ATA_CMD_PACKET;\r\ntf.protocol = ATAPI_PROT_NODATA;\r\nreturn ata_exec_internal(dev, &tf, cdb, DMA_NONE, NULL, 0, 0);\r\n}\r\nstatic enum odd_mech_type zpodd_get_mech_type(struct ata_device *dev)\r\n{\r\nchar buf[16];\r\nunsigned int ret;\r\nstruct rm_feature_desc *desc = (void *)(buf + 8);\r\nstruct ata_taskfile tf;\r\nchar cdb[] = { GPCMD_GET_CONFIGURATION,\r\n2,\r\n0, 3,\r\n0, 0, 0,\r\n0, sizeof(buf),\r\n0, 0, 0,\r\n};\r\nata_tf_init(dev, &tf);\r\ntf.flags = ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf.command = ATA_CMD_PACKET;\r\ntf.protocol = ATAPI_PROT_PIO;\r\ntf.lbam = sizeof(buf);\r\nret = ata_exec_internal(dev, &tf, cdb, DMA_FROM_DEVICE,\r\nbuf, sizeof(buf), 0);\r\nif (ret)\r\nreturn ODD_MECH_TYPE_UNSUPPORTED;\r\nif (be16_to_cpu(desc->feature_code) != 3)\r\nreturn ODD_MECH_TYPE_UNSUPPORTED;\r\nif (desc->mech_type == 0 && desc->load == 0 && desc->eject == 1)\r\nreturn ODD_MECH_TYPE_SLOT;\r\nelse if (desc->mech_type == 1 && desc->load == 0 && desc->eject == 1)\r\nreturn ODD_MECH_TYPE_DRAWER;\r\nelse\r\nreturn ODD_MECH_TYPE_UNSUPPORTED;\r\n}\r\nstatic bool zpready(struct ata_device *dev)\r\n{\r\nu8 sense_key, *sense_buf;\r\nunsigned int ret, asc, ascq, add_len;\r\nstruct zpodd *zpodd = dev->zpodd;\r\nret = atapi_eh_tur(dev, &sense_key);\r\nif (!ret || sense_key != NOT_READY)\r\nreturn false;\r\nsense_buf = dev->link->ap->sector_buf;\r\nret = atapi_eh_request_sense(dev, sense_buf, sense_key);\r\nif (ret)\r\nreturn false;\r\nif ((sense_buf[0] & 0x7f) != 0x70)\r\nreturn false;\r\nadd_len = sense_buf[7];\r\nif (add_len < 6)\r\nreturn false;\r\nasc = sense_buf[12];\r\nascq = sense_buf[13];\r\nif (zpodd->mech_type == ODD_MECH_TYPE_SLOT)\r\nreturn asc == 0x3a;\r\nelse\r\nreturn asc == 0x3a && ascq == 0x01;\r\n}\r\nvoid zpodd_on_suspend(struct ata_device *dev)\r\n{\r\nstruct zpodd *zpodd = dev->zpodd;\r\nunsigned long expires;\r\nif (!zpready(dev)) {\r\nzpodd->zp_sampled = false;\r\nzpodd->zp_ready = false;\r\nreturn;\r\n}\r\nif (!zpodd->zp_sampled) {\r\nzpodd->zp_sampled = true;\r\nzpodd->last_ready = jiffies;\r\nreturn;\r\n}\r\nexpires = zpodd->last_ready +\r\nmsecs_to_jiffies(zpodd_poweroff_delay * 1000);\r\nif (time_before(jiffies, expires))\r\nreturn;\r\nzpodd->zp_ready = true;\r\n}\r\nbool zpodd_zpready(struct ata_device *dev)\r\n{\r\nstruct zpodd *zpodd = dev->zpodd;\r\nreturn zpodd->zp_ready;\r\n}\r\nvoid zpodd_enable_run_wake(struct ata_device *dev)\r\n{\r\nstruct zpodd *zpodd = dev->zpodd;\r\nsdev_disable_disk_events(dev->sdev);\r\nzpodd->powered_off = true;\r\ndevice_set_run_wake(&dev->tdev, true);\r\nacpi_pm_device_run_wake(&dev->tdev, true);\r\n}\r\nvoid zpodd_disable_run_wake(struct ata_device *dev)\r\n{\r\nstruct zpodd *zpodd = dev->zpodd;\r\nif (zpodd->powered_off) {\r\nacpi_pm_device_run_wake(&dev->tdev, false);\r\ndevice_set_run_wake(&dev->tdev, false);\r\n}\r\n}\r\nvoid zpodd_post_poweron(struct ata_device *dev)\r\n{\r\nstruct zpodd *zpodd = dev->zpodd;\r\nif (!zpodd->powered_off)\r\nreturn;\r\nzpodd->powered_off = false;\r\nif (zpodd->from_notify) {\r\nzpodd->from_notify = false;\r\nif (zpodd->mech_type == ODD_MECH_TYPE_DRAWER)\r\neject_tray(dev);\r\n}\r\nzpodd->zp_sampled = false;\r\nzpodd->zp_ready = false;\r\nsdev_enable_disk_events(dev->sdev);\r\n}\r\nstatic void zpodd_wake_dev(acpi_handle handle, u32 event, void *context)\r\n{\r\nstruct ata_device *ata_dev = context;\r\nstruct zpodd *zpodd = ata_dev->zpodd;\r\nstruct device *dev = &ata_dev->sdev->sdev_gendev;\r\nif (event == ACPI_NOTIFY_DEVICE_WAKE && pm_runtime_suspended(dev)) {\r\nzpodd->from_notify = true;\r\npm_runtime_resume(dev);\r\n}\r\n}\r\nstatic void ata_acpi_add_pm_notifier(struct ata_device *dev)\r\n{\r\nacpi_handle handle = ata_dev_acpi_handle(dev);\r\nacpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,\r\nzpodd_wake_dev, dev);\r\n}\r\nstatic void ata_acpi_remove_pm_notifier(struct ata_device *dev)\r\n{\r\nacpi_handle handle = ata_dev_acpi_handle(dev);\r\nacpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY, zpodd_wake_dev);\r\n}\r\nvoid zpodd_init(struct ata_device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&dev->tdev);\r\nenum odd_mech_type mech_type;\r\nstruct zpodd *zpodd;\r\nif (dev->zpodd || !adev || !acpi_device_can_poweroff(adev))\r\nreturn;\r\nmech_type = zpodd_get_mech_type(dev);\r\nif (mech_type == ODD_MECH_TYPE_UNSUPPORTED)\r\nreturn;\r\nzpodd = kzalloc(sizeof(struct zpodd), GFP_KERNEL);\r\nif (!zpodd)\r\nreturn;\r\nzpodd->mech_type = mech_type;\r\nata_acpi_add_pm_notifier(dev);\r\nzpodd->dev = dev;\r\ndev->zpodd = zpodd;\r\ndev_pm_qos_expose_flags(&dev->tdev, 0);\r\n}\r\nvoid zpodd_exit(struct ata_device *dev)\r\n{\r\nata_acpi_remove_pm_notifier(dev);\r\nkfree(dev->zpodd);\r\ndev->zpodd = NULL;\r\n}
