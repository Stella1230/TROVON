static int imx6ul_adc_init(struct imx6ul_tsc *tsc)\r\n{\r\nint adc_hc = 0;\r\nint adc_gc;\r\nint adc_gs;\r\nint adc_cfg;\r\nint timeout;\r\nreinit_completion(&tsc->completion);\r\nadc_cfg = readl(tsc->adc_regs + REG_ADC_CFG);\r\nadc_cfg |= ADC_12BIT_MODE | ADC_IPG_CLK;\r\nadc_cfg |= ADC_CLK_DIV_8 | ADC_SHORT_SAMPLE_MODE;\r\nadc_cfg &= ~ADC_HARDWARE_TRIGGER;\r\nwritel(adc_cfg, tsc->adc_regs + REG_ADC_CFG);\r\nadc_hc |= ADC_AIEN;\r\nadc_hc |= ADC_CONV_DISABLE;\r\nwritel(adc_hc, tsc->adc_regs + REG_ADC_HC0);\r\nadc_gc = readl(tsc->adc_regs + REG_ADC_GC);\r\nadc_gc |= ADC_CAL;\r\nwritel(adc_gc, tsc->adc_regs + REG_ADC_GC);\r\ntimeout = wait_for_completion_timeout\r\n(&tsc->completion, ADC_TIMEOUT);\r\nif (timeout == 0) {\r\ndev_err(tsc->dev, "Timeout for adc calibration\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nadc_gs = readl(tsc->adc_regs + REG_ADC_GS);\r\nif (adc_gs & ADC_CALF) {\r\ndev_err(tsc->dev, "ADC calibration failed\n");\r\nreturn -EINVAL;\r\n}\r\nadc_cfg = readl(tsc->adc_regs + REG_ADC_CFG);\r\nadc_cfg |= ADC_HARDWARE_TRIGGER;\r\nwritel(adc_cfg, tsc->adc_regs + REG_ADC_CFG);\r\nreturn 0;\r\n}\r\nstatic void imx6ul_tsc_channel_config(struct imx6ul_tsc *tsc)\r\n{\r\nint adc_hc0, adc_hc1, adc_hc2, adc_hc3, adc_hc4;\r\nadc_hc0 = DISABLE_CONVERSION_INT;\r\nwritel(adc_hc0, tsc->adc_regs + REG_ADC_HC0);\r\nadc_hc1 = DISABLE_CONVERSION_INT | SELECT_CHANNEL_4;\r\nwritel(adc_hc1, tsc->adc_regs + REG_ADC_HC1);\r\nadc_hc2 = DISABLE_CONVERSION_INT;\r\nwritel(adc_hc2, tsc->adc_regs + REG_ADC_HC2);\r\nadc_hc3 = DISABLE_CONVERSION_INT | SELECT_CHANNEL_1;\r\nwritel(adc_hc3, tsc->adc_regs + REG_ADC_HC3);\r\nadc_hc4 = DISABLE_CONVERSION_INT;\r\nwritel(adc_hc4, tsc->adc_regs + REG_ADC_HC4);\r\n}\r\nstatic void imx6ul_tsc_set(struct imx6ul_tsc *tsc)\r\n{\r\nint basic_setting = 0;\r\nint start;\r\nbasic_setting |= tsc->measure_delay_time << 8;\r\nbasic_setting |= DETECT_4_WIRE_MODE | AUTO_MEASURE;\r\nwritel(basic_setting, tsc->tsc_regs + REG_TSC_BASIC_SETING);\r\nwritel(DE_GLITCH_2, tsc->tsc_regs + REG_TSC_DEBUG_MODE2);\r\nwritel(tsc->pre_charge_time, tsc->tsc_regs + REG_TSC_PRE_CHARGE_TIME);\r\nwritel(MEASURE_INT_EN, tsc->tsc_regs + REG_TSC_INT_EN);\r\nwritel(MEASURE_SIG_EN | VALID_SIG_EN,\r\ntsc->tsc_regs + REG_TSC_INT_SIG_EN);\r\nstart = readl(tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\r\nstart |= START_SENSE;\r\nstart &= ~TSC_DISABLE;\r\nwritel(start, tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\r\n}\r\nstatic int imx6ul_tsc_init(struct imx6ul_tsc *tsc)\r\n{\r\nint err;\r\nerr = imx6ul_adc_init(tsc);\r\nif (err)\r\nreturn err;\r\nimx6ul_tsc_channel_config(tsc);\r\nimx6ul_tsc_set(tsc);\r\nreturn 0;\r\n}\r\nstatic void imx6ul_tsc_disable(struct imx6ul_tsc *tsc)\r\n{\r\nint tsc_flow;\r\nint adc_cfg;\r\ntsc_flow = readl(tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\r\ntsc_flow |= TSC_DISABLE;\r\nwritel(tsc_flow, tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\r\nadc_cfg = readl(tsc->adc_regs + REG_ADC_HC0);\r\nadc_cfg |= ADC_CONV_DISABLE;\r\nwritel(adc_cfg, tsc->adc_regs + REG_ADC_HC0);\r\n}\r\nstatic bool tsc_wait_detect_mode(struct imx6ul_tsc *tsc)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(2);\r\nint state_machine;\r\nint debug_mode2;\r\ndo {\r\nif (time_after(jiffies, timeout))\r\nreturn false;\r\nusleep_range(200, 400);\r\ndebug_mode2 = readl(tsc->tsc_regs + REG_TSC_DEBUG_MODE2);\r\nstate_machine = (debug_mode2 >> 20) & 0x7;\r\n} while (state_machine != DETECT_MODE);\r\nusleep_range(200, 400);\r\nreturn true;\r\n}\r\nstatic irqreturn_t tsc_irq_fn(int irq, void *dev_id)\r\n{\r\nstruct imx6ul_tsc *tsc = dev_id;\r\nint status;\r\nint value;\r\nint x, y;\r\nint start;\r\nstatus = readl(tsc->tsc_regs + REG_TSC_INT_STATUS);\r\nwritel(MEASURE_SIGNAL | DETECT_SIGNAL,\r\ntsc->tsc_regs + REG_TSC_INT_STATUS);\r\nstart = readl(tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\r\nstart |= START_SENSE;\r\nwritel(start, tsc->tsc_regs + REG_TSC_FLOW_CONTROL);\r\nif (status & MEASURE_SIGNAL) {\r\nvalue = readl(tsc->tsc_regs + REG_TSC_MEASURE_VALUE);\r\nx = (value >> 16) & 0x0fff;\r\ny = value & 0x0fff;\r\nif (!tsc_wait_detect_mode(tsc) ||\r\ngpiod_get_value_cansleep(tsc->xnur_gpio)) {\r\ninput_report_key(tsc->input, BTN_TOUCH, 1);\r\ninput_report_abs(tsc->input, ABS_X, x);\r\ninput_report_abs(tsc->input, ABS_Y, y);\r\n} else {\r\ninput_report_key(tsc->input, BTN_TOUCH, 0);\r\n}\r\ninput_sync(tsc->input);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t adc_irq_fn(int irq, void *dev_id)\r\n{\r\nstruct imx6ul_tsc *tsc = dev_id;\r\nint coco;\r\nint value;\r\ncoco = readl(tsc->adc_regs + REG_ADC_HS);\r\nif (coco & 0x01) {\r\nvalue = readl(tsc->adc_regs + REG_ADC_R0);\r\ncomplete(&tsc->completion);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int imx6ul_tsc_open(struct input_dev *input_dev)\r\n{\r\nstruct imx6ul_tsc *tsc = input_get_drvdata(input_dev);\r\nint err;\r\nerr = clk_prepare_enable(tsc->adc_clk);\r\nif (err) {\r\ndev_err(tsc->dev,\r\n"Could not prepare or enable the adc clock: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(tsc->tsc_clk);\r\nif (err) {\r\ndev_err(tsc->dev,\r\n"Could not prepare or enable the tsc clock: %d\n",\r\nerr);\r\nclk_disable_unprepare(tsc->adc_clk);\r\nreturn err;\r\n}\r\nreturn imx6ul_tsc_init(tsc);\r\n}\r\nstatic void imx6ul_tsc_close(struct input_dev *input_dev)\r\n{\r\nstruct imx6ul_tsc *tsc = input_get_drvdata(input_dev);\r\nimx6ul_tsc_disable(tsc);\r\nclk_disable_unprepare(tsc->tsc_clk);\r\nclk_disable_unprepare(tsc->adc_clk);\r\n}\r\nstatic int imx6ul_tsc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct imx6ul_tsc *tsc;\r\nstruct input_dev *input_dev;\r\nstruct resource *tsc_mem;\r\nstruct resource *adc_mem;\r\nint err;\r\nint tsc_irq;\r\nint adc_irq;\r\ntsc = devm_kzalloc(&pdev->dev, sizeof(*tsc), GFP_KERNEL);\r\nif (!tsc)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninput_dev->name = "iMX6UL Touchscreen Controller";\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->open = imx6ul_tsc_open;\r\ninput_dev->close = imx6ul_tsc_close;\r\ninput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, 0xFFF, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 0xFFF, 0, 0);\r\ninput_set_drvdata(input_dev, tsc);\r\ntsc->dev = &pdev->dev;\r\ntsc->input = input_dev;\r\ninit_completion(&tsc->completion);\r\ntsc->xnur_gpio = devm_gpiod_get(&pdev->dev, "xnur", GPIOD_IN);\r\nif (IS_ERR(tsc->xnur_gpio)) {\r\nerr = PTR_ERR(tsc->xnur_gpio);\r\ndev_err(&pdev->dev,\r\n"failed to request GPIO tsc_X- (xnur): %d\n", err);\r\nreturn err;\r\n}\r\ntsc_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntsc->tsc_regs = devm_ioremap_resource(&pdev->dev, tsc_mem);\r\nif (IS_ERR(tsc->tsc_regs)) {\r\nerr = PTR_ERR(tsc->tsc_regs);\r\ndev_err(&pdev->dev, "failed to remap tsc memory: %d\n", err);\r\nreturn err;\r\n}\r\nadc_mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ntsc->adc_regs = devm_ioremap_resource(&pdev->dev, adc_mem);\r\nif (IS_ERR(tsc->adc_regs)) {\r\nerr = PTR_ERR(tsc->adc_regs);\r\ndev_err(&pdev->dev, "failed to remap adc memory: %d\n", err);\r\nreturn err;\r\n}\r\ntsc->tsc_clk = devm_clk_get(&pdev->dev, "tsc");\r\nif (IS_ERR(tsc->tsc_clk)) {\r\nerr = PTR_ERR(tsc->tsc_clk);\r\ndev_err(&pdev->dev, "failed getting tsc clock: %d\n", err);\r\nreturn err;\r\n}\r\ntsc->adc_clk = devm_clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(tsc->adc_clk)) {\r\nerr = PTR_ERR(tsc->adc_clk);\r\ndev_err(&pdev->dev, "failed getting adc clock: %d\n", err);\r\nreturn err;\r\n}\r\ntsc_irq = platform_get_irq(pdev, 0);\r\nif (tsc_irq < 0) {\r\ndev_err(&pdev->dev, "no tsc irq resource?\n");\r\nreturn tsc_irq;\r\n}\r\nadc_irq = platform_get_irq(pdev, 1);\r\nif (adc_irq < 0) {\r\ndev_err(&pdev->dev, "no adc irq resource?\n");\r\nreturn adc_irq;\r\n}\r\nerr = devm_request_threaded_irq(tsc->dev, tsc_irq,\r\nNULL, tsc_irq_fn, IRQF_ONESHOT,\r\ndev_name(&pdev->dev), tsc);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"failed requesting tsc irq %d: %d\n",\r\ntsc_irq, err);\r\nreturn err;\r\n}\r\nerr = devm_request_irq(tsc->dev, adc_irq, adc_irq_fn, 0,\r\ndev_name(&pdev->dev), tsc);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"failed requesting adc irq %d: %d\n",\r\nadc_irq, err);\r\nreturn err;\r\n}\r\nerr = of_property_read_u32(np, "measure-delay-time",\r\n&tsc->measure_delay_time);\r\nif (err)\r\ntsc->measure_delay_time = 0xffff;\r\nerr = of_property_read_u32(np, "pre-charge-time",\r\n&tsc->pre_charge_time);\r\nif (err)\r\ntsc->pre_charge_time = 0xfff;\r\nerr = input_register_device(tsc->input);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"failed to register input device: %d\n", err);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, tsc);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imx6ul_tsc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx6ul_tsc *tsc = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = tsc->input;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users) {\r\nimx6ul_tsc_disable(tsc);\r\nclk_disable_unprepare(tsc->tsc_clk);\r\nclk_disable_unprepare(tsc->adc_clk);\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imx6ul_tsc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx6ul_tsc *tsc = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = tsc->input;\r\nint retval = 0;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users) {\r\nretval = clk_prepare_enable(tsc->adc_clk);\r\nif (retval)\r\ngoto out;\r\nretval = clk_prepare_enable(tsc->tsc_clk);\r\nif (retval) {\r\nclk_disable_unprepare(tsc->adc_clk);\r\ngoto out;\r\n}\r\nretval = imx6ul_tsc_init(tsc);\r\n}\r\nout:\r\nmutex_unlock(&input_dev->mutex);\r\nreturn retval;\r\n}
