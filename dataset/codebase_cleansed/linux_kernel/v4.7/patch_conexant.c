static inline void set_beep_amp(struct conexant_spec *spec, hda_nid_t nid,\r\nint idx, int dir)\r\n{\r\nspec->gen.beep_nid = nid;\r\nspec->beep_amp = HDA_COMPOSE_AMP_VAL(nid, 1, idx, dir);\r\n}\r\nstatic int add_beep_ctls(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint err;\r\nif (spec->beep_amp) {\r\nconst struct snd_kcontrol_new *knew;\r\nfor (knew = cxt_beep_mixer; knew->name; knew++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(knew, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = spec->beep_amp;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cx_auto_parse_beep(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nfor_each_hda_codec_node(nid, codec)\r\nif (get_wcaps_type(get_wcaps(codec, nid)) == AC_WID_BEEP) {\r\nset_beep_amp(spec, nid, 0, HDA_OUTPUT);\r\nbreak;\r\n}\r\n}\r\nstatic void cx_auto_parse_eapd(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nfor_each_hda_codec_node(nid, codec) {\r\nif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\r\ncontinue;\r\nif (!(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_EAPD))\r\ncontinue;\r\nspec->eapds[spec->num_eapds++] = nid;\r\nif (spec->num_eapds >= ARRAY_SIZE(spec->eapds))\r\nbreak;\r\n}\r\nif (spec->num_eapds > 2)\r\nspec->dynamic_eapd = 1;\r\n}\r\nstatic void cx_auto_turn_eapd(struct hda_codec *codec, int num_pins,\r\nhda_nid_t *pins, bool on)\r\n{\r\nint i;\r\nfor (i = 0; i < num_pins; i++) {\r\nif (snd_hda_query_pin_caps(codec, pins[i]) & AC_PINCAP_EAPD)\r\nsnd_hda_codec_write(codec, pins[i], 0,\r\nAC_VERB_SET_EAPD_BTLENABLE,\r\non ? 0x02 : 0);\r\n}\r\n}\r\nstatic void cx_auto_vmaster_hook(void *private_data, int enabled)\r\n{\r\nstruct hda_codec *codec = private_data;\r\nstruct conexant_spec *spec = codec->spec;\r\ncx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, enabled);\r\n}\r\nstatic void cx_auto_vmaster_hook_mute_led(void *private_data, int enabled)\r\n{\r\nstruct hda_codec *codec = private_data;\r\nstruct conexant_spec *spec = codec->spec;\r\nsnd_hda_codec_write(codec, spec->mute_led_eapd, 0,\r\nAC_VERB_SET_EAPD_BTLENABLE,\r\nenabled ? 0x00 : 0x02);\r\n}\r\nstatic int cx_auto_build_controls(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = snd_hda_gen_build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_beep_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int cx_auto_init(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nsnd_hda_gen_init(codec);\r\nif (!spec->dynamic_eapd)\r\ncx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, true);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_INIT);\r\nreturn 0;\r\n}\r\nstatic void cx_auto_reboot_notify(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nswitch (codec->core.vendor_id) {\r\ncase 0x14f150f2:\r\ncase 0x14f150f4:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ncx_auto_turn_eapd(codec, spec->num_eapds, spec->eapds, false);\r\nsnd_hda_codec_set_power_to_all(codec, codec->core.afg, AC_PWRST_D3);\r\nsnd_hda_codec_write(codec, codec->core.afg, 0,\r\nAC_VERB_SET_POWER_STATE, AC_PWRST_D3);\r\n}\r\nstatic void cx_auto_free(struct hda_codec *codec)\r\n{\r\ncx_auto_reboot_notify(codec);\r\nsnd_hda_gen_free(codec);\r\n}\r\nstatic void cxt_fixup_stereo_dmic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nspec->gen.inv_dmic_split = 1;\r\n}\r\nstatic void cxt5066_increase_mic_boost(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\nsnd_hda_override_amp_caps(codec, 0x17, HDA_OUTPUT,\r\n(0x3 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x4 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x27 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(0 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic void cxt_update_headset_mode(struct hda_codec *codec)\r\n{\r\nint i;\r\nbool mic_mode = false;\r\nstruct conexant_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\r\nhda_nid_t mux_pin = spec->gen.imux_pins[spec->gen.cur_mux[0]];\r\nfor (i = 0; i < cfg->num_inputs; i++)\r\nif (cfg->inputs[i].pin == mux_pin) {\r\nmic_mode = !!cfg->inputs[i].is_headphone_mic;\r\nbreak;\r\n}\r\nif (mic_mode) {\r\nsnd_hda_codec_write_cache(codec, 0x1c, 0, 0x410, 0x7c);\r\nspec->gen.hp_jack_present = false;\r\n} else {\r\nsnd_hda_codec_write_cache(codec, 0x1c, 0, 0x410, 0x54);\r\nspec->gen.hp_jack_present = snd_hda_jack_detect(codec, spec->gen.autocfg.hp_pins[0]);\r\n}\r\nsnd_hda_gen_update_outputs(codec);\r\n}\r\nstatic void cxt_update_headset_mode_hook(struct hda_codec *codec,\r\nstruct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\ncxt_update_headset_mode(codec);\r\n}\r\nstatic void cxt_fixup_headphone_mic(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nswitch (action) {\r\ncase HDA_FIXUP_ACT_PRE_PROBE:\r\nspec->parse_flags |= HDA_PINCFG_HEADPHONE_MIC;\r\nsnd_hdac_regmap_add_vendor_verb(&codec->core, 0x410);\r\nbreak;\r\ncase HDA_FIXUP_ACT_PROBE:\r\nspec->gen.cap_sync_hook = cxt_update_headset_mode_hook;\r\nspec->gen.automute_hook = cxt_update_headset_mode;\r\nbreak;\r\ncase HDA_FIXUP_ACT_INIT:\r\ncxt_update_headset_mode(codec);\r\nbreak;\r\n}\r\n}\r\nstatic void olpc_xo_update_mic_boost(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint ch, val;\r\nfor (ch = 0; ch < 2; ch++) {\r\nval = AC_AMP_SET_OUTPUT |\r\n(ch ? AC_AMP_SET_RIGHT : AC_AMP_SET_LEFT);\r\nif (!spec->dc_enable)\r\nval |= snd_hda_codec_amp_read(codec, 0x17, ch, HDA_OUTPUT, 0);\r\nsnd_hda_codec_write(codec, 0x17, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, val);\r\n}\r\n}\r\nstatic void olpc_xo_update_mic_pins(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint cur_input, val;\r\nstruct nid_path *path;\r\ncur_input = spec->gen.input_paths[0][spec->gen.cur_mux[0]];\r\nif (!spec->dc_enable) {\r\nupdate_mic_pin(codec, 0x1e, 0);\r\nsnd_hda_activate_path(codec, spec->dc_mode_path, false, false);\r\nupdate_mic_pin(codec, 0x1a, spec->recording ?\r\nsnd_hda_codec_get_pin_target(codec, 0x1a) : 0);\r\nupdate_mic_pin(codec, 0x1b, spec->recording ?\r\nsnd_hda_codec_get_pin_target(codec, 0x1b) : 0);\r\npath = snd_hda_get_path_from_idx(codec, cur_input);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, true, false);\r\n} else {\r\npath = snd_hda_get_path_from_idx(codec, cur_input);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, false, false);\r\nif (spec->recording)\r\nval = olpc_xo_dc_bias.items[spec->dc_input_bias].index;\r\nelse\r\nval = 0;\r\nupdate_mic_pin(codec, 0x1a, val);\r\nupdate_mic_pin(codec, 0x1b, 0);\r\nupdate_mic_pin(codec, 0x1e, spec->recording ? PIN_IN : 0);\r\nsnd_hda_activate_path(codec, spec->dc_mode_path, true, false);\r\n}\r\n}\r\nstatic void olpc_xo_automic(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nif (!spec->dc_enable)\r\nsnd_hda_gen_mic_autoswitch(codec, jack);\r\nolpc_xo_update_mic_pins(codec);\r\nif (spec->dc_enable)\r\nolpc_xo_update_mic_boost(codec);\r\n}\r\nstatic void olpc_xo_capture_hook(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream,\r\nint action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nswitch (action) {\r\ncase HDA_GEN_PCM_ACT_PREPARE:\r\nspec->recording = 1;\r\nolpc_xo_update_mic_pins(codec);\r\nbreak;\r\ncase HDA_GEN_PCM_ACT_CLEANUP:\r\nspec->recording = 0;\r\nolpc_xo_update_mic_pins(codec);\r\nbreak;\r\n}\r\n}\r\nstatic int olpc_xo_dc_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nucontrol->value.integer.value[0] = spec->dc_enable;\r\nreturn 0;\r\n}\r\nstatic int olpc_xo_dc_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nint dc_enable = !!ucontrol->value.integer.value[0];\r\nif (dc_enable == spec->dc_enable)\r\nreturn 0;\r\nspec->dc_enable = dc_enable;\r\nolpc_xo_update_mic_pins(codec);\r\nolpc_xo_update_mic_boost(codec);\r\nreturn 1;\r\n}\r\nstatic int olpc_xo_dc_bias_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->dc_input_bias;\r\nreturn 0;\r\n}\r\nstatic int olpc_xo_dc_bias_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nreturn snd_hda_input_mux_info(&olpc_xo_dc_bias, uinfo);\r\n}\r\nstatic int olpc_xo_dc_bias_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nconst struct hda_input_mux *imux = &olpc_xo_dc_bias;\r\nunsigned int idx;\r\nidx = ucontrol->value.enumerated.item[0];\r\nif (idx >= imux->num_items)\r\nidx = imux->num_items - 1;\r\nif (spec->dc_input_bias == idx)\r\nreturn 0;\r\nspec->dc_input_bias = idx;\r\nif (spec->dc_enable)\r\nolpc_xo_update_mic_pins(codec);\r\nreturn 1;\r\n}\r\nstatic int olpc_xo_mic_boost_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct conexant_spec *spec = codec->spec;\r\nint ret = snd_hda_mixer_amp_volume_put(kcontrol, ucontrol);\r\nif (ret > 0 && spec->dc_enable)\r\nolpc_xo_update_mic_boost(codec);\r\nreturn ret;\r\n}\r\nstatic void cxt_fixup_olpc_xo(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nint i;\r\nif (action != HDA_FIXUP_ACT_PROBE)\r\nreturn;\r\nspec->gen.mic_autoswitch_hook = olpc_xo_automic;\r\nspec->gen.pcm_capture_hook = olpc_xo_capture_hook;\r\nspec->dc_mode_path = snd_hda_add_new_path(codec, 0x1e, 0x14, 0);\r\nsnd_hda_add_new_ctls(codec, olpc_xo_mixers);\r\nsnd_hda_codec_set_pin_target(codec, 0x1a, PIN_VREF50);\r\nfor (i = 0; i < spec->gen.kctls.used; i++) {\r\nstruct snd_kcontrol_new *kctl =\r\nsnd_array_elem(&spec->gen.kctls, i);\r\nif (!strcmp(kctl->name, "Mic Boost Volume")) {\r\nkctl->put = olpc_xo_mic_boost_put;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void cxt_fixup_mute_led_eapd(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nspec->mute_led_eapd = 0x1b;\r\nspec->dynamic_eapd = 1;\r\nspec->gen.vmaster_mute.hook = cx_auto_vmaster_hook_mute_led;\r\n}\r\n}\r\nstatic void cxt_fixup_cap_mix_amp(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nsnd_hda_override_amp_caps(codec, 0x17, HDA_INPUT,\r\n(0x14 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x14 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic void cxt_fixup_cap_mix_amp_5047(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nsnd_hda_override_amp_caps(codec, 0x10, HDA_INPUT,\r\n(0x17 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x05 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic void add_cx5051_fake_mutes(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec = codec->spec;\r\nstatic hda_nid_t out_nids[] = {\r\n0x10, 0x11, 0\r\n};\r\nhda_nid_t *p;\r\nfor (p = out_nids; *p; p++)\r\nsnd_hda_override_amp_caps(codec, *p, HDA_OUTPUT,\r\nAC_AMPCAP_MIN_MUTE |\r\nquery_amp_caps(codec, *p, HDA_OUTPUT));\r\nspec->gen.dac_min_mute = true;\r\n}\r\nstatic int patch_conexant_auto(struct hda_codec *codec)\r\n{\r\nstruct conexant_spec *spec;\r\nint err;\r\ncodec_info(codec, "%s: BIOS auto-probing.\n", codec->core.chip_name);\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nsnd_hda_gen_spec_init(&spec->gen);\r\ncodec->spec = spec;\r\ncodec->patch_ops = cx_auto_patch_ops;\r\ncx_auto_parse_beep(codec);\r\ncx_auto_parse_eapd(codec);\r\nspec->gen.own_eapd_ctl = 1;\r\nif (spec->dynamic_eapd)\r\nspec->gen.vmaster_mute.hook = cx_auto_vmaster_hook;\r\nswitch (codec->core.vendor_id) {\r\ncase 0x14f15045:\r\ncodec->single_adc_amp = 1;\r\nspec->gen.mixer_nid = 0x17;\r\nspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\r\nsnd_hda_pick_fixup(codec, cxt5045_fixup_models,\r\ncxt5045_fixups, cxt_fixups);\r\nbreak;\r\ncase 0x14f15047:\r\ncodec->pin_amp_workaround = 1;\r\nspec->gen.mixer_nid = 0x19;\r\nspec->gen.add_stereo_mix_input = HDA_HINT_STEREO_MIX_AUTO;\r\nsnd_hda_pick_fixup(codec, cxt5047_fixup_models,\r\ncxt5047_fixups, cxt_fixups);\r\nbreak;\r\ncase 0x14f15051:\r\nadd_cx5051_fake_mutes(codec);\r\ncodec->pin_amp_workaround = 1;\r\nsnd_hda_pick_fixup(codec, cxt5051_fixup_models,\r\ncxt5051_fixups, cxt_fixups);\r\nbreak;\r\ncase 0x14f150f2:\r\ncodec->power_save_node = 1;\r\ndefault:\r\ncodec->pin_amp_workaround = 1;\r\nsnd_hda_pick_fixup(codec, cxt5066_fixup_models,\r\ncxt5066_fixups, cxt_fixups);\r\nbreak;\r\n}\r\nswitch (codec->core.subsystem_id >> 16) {\r\ncase 0x103c:\r\nspec->gen.vmaster_mute_enum = 1;\r\nbreak;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL,\r\nspec->parse_flags);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\r\nif (err < 0)\r\ngoto error;\r\nif (!codec->bus->core.sync_write) {\r\ncodec_info(codec,\r\n"Enable sync_write for stable communication\n");\r\ncodec->bus->core.sync_write = 1;\r\ncodec->bus->allow_bus_reset = 1;\r\n}\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\ncx_auto_free(codec);\r\nreturn err;\r\n}
