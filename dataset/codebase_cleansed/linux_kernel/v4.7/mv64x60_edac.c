static void mv64x60_pci_check(struct edac_pci_ctl_info *pci)\r\n{\r\nstruct mv64x60_pci_pdata *pdata = pci->pvt_info;\r\nu32 cause;\r\ncause = in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CAUSE);\r\nif (!cause)\r\nreturn;\r\nprintk(KERN_ERR "Error in PCI %d Interface\n", pdata->pci_hose);\r\nprintk(KERN_ERR "Cause register: 0x%08x\n", cause);\r\nprintk(KERN_ERR "Address Low: 0x%08x\n",\r\nin_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_ADDR_LO));\r\nprintk(KERN_ERR "Address High: 0x%08x\n",\r\nin_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_ADDR_HI));\r\nprintk(KERN_ERR "Attribute: 0x%08x\n",\r\nin_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_ATTR));\r\nprintk(KERN_ERR "Command: 0x%08x\n",\r\nin_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CMD));\r\nout_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CAUSE, ~cause);\r\nif (cause & MV64X60_PCI_PE_MASK)\r\nedac_pci_handle_pe(pci, pci->ctl_name);\r\nif (!(cause & MV64X60_PCI_PE_MASK))\r\nedac_pci_handle_npe(pci, pci->ctl_name);\r\n}\r\nstatic irqreturn_t mv64x60_pci_isr(int irq, void *dev_id)\r\n{\r\nstruct edac_pci_ctl_info *pci = dev_id;\r\nstruct mv64x60_pci_pdata *pdata = pci->pvt_info;\r\nu32 val;\r\nval = in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CAUSE);\r\nif (!val)\r\nreturn IRQ_NONE;\r\nmv64x60_pci_check(pci);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init mv64x60_pci_fixup(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nvoid __iomem *pci_serr;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!r) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"PCI err regs\n", __func__);\r\nreturn -ENOENT;\r\n}\r\npci_serr = ioremap(r->start, resource_size(r));\r\nif (!pci_serr)\r\nreturn -ENOMEM;\r\nout_le32(pci_serr, in_le32(pci_serr) & ~0x1);\r\niounmap(pci_serr);\r\nreturn 0;\r\n}\r\nstatic int mv64x60_pci_err_probe(struct platform_device *pdev)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\nstruct mv64x60_pci_pdata *pdata;\r\nstruct resource *r;\r\nint res = 0;\r\nif (!devres_open_group(&pdev->dev, mv64x60_pci_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\npci = edac_pci_alloc_ctl_info(sizeof(*pdata), "mv64x60_pci_err");\r\nif (!pci)\r\nreturn -ENOMEM;\r\npdata = pci->pvt_info;\r\npdata->pci_hose = pdev->id;\r\npdata->name = "mpc85xx_pci_err";\r\npdata->irq = NO_IRQ;\r\nplatform_set_drvdata(pdev, pci);\r\npci->dev = &pdev->dev;\r\npci->dev_name = dev_name(&pdev->dev);\r\npci->mod_name = EDAC_MOD_STR;\r\npci->ctl_name = pdata->name;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\npci->edac_check = mv64x60_pci_check;\r\npdata->edac_idx = edac_pci_idx++;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"PCI err regs\n", __func__);\r\nres = -ENOENT;\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev,\r\nr->start,\r\nresource_size(r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->pci_vbase = devm_ioremap(&pdev->dev,\r\nr->start,\r\nresource_size(r));\r\nif (!pdata->pci_vbase) {\r\nprintk(KERN_ERR "%s: Unable to setup PCI err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nres = mv64x60_pci_fixup(pdev);\r\nif (res < 0) {\r\nprintk(KERN_ERR "%s: PCI fixup failed\n", __func__);\r\ngoto err;\r\n}\r\nout_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CAUSE, 0);\r\nout_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_MASK, 0);\r\nout_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_MASK,\r\nMV64X60_PCIx_ERR_MASK_VAL);\r\nif (edac_pci_add_device(pci, pdata->edac_idx) > 0) {\r\nedac_dbg(3, "failed edac_pci_add_device()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = platform_get_irq(pdev, 0);\r\nres = devm_request_irq(&pdev->dev,\r\npdata->irq,\r\nmv64x60_pci_isr,\r\n0,\r\n"[EDAC] PCI err",\r\npci);\r\nif (res < 0) {\r\nprintk(KERN_ERR "%s: Unable to request irq %d for "\r\n"MV64x60 PCI ERR\n", __func__, pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO EDAC_MOD_STR " acquired irq %d for PCI Err\n",\r\npdata->irq);\r\n}\r\ndevres_remove_group(&pdev->dev, mv64x60_pci_err_probe);\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nerr2:\r\nedac_pci_del_device(&pdev->dev);\r\nerr:\r\nedac_pci_free_ctl_info(pci);\r\ndevres_release_group(&pdev->dev, mv64x60_pci_err_probe);\r\nreturn res;\r\n}\r\nstatic int mv64x60_pci_err_remove(struct platform_device *pdev)\r\n{\r\nstruct edac_pci_ctl_info *pci = platform_get_drvdata(pdev);\r\nedac_dbg(0, "\n");\r\nedac_pci_del_device(&pdev->dev);\r\nedac_pci_free_ctl_info(pci);\r\nreturn 0;\r\n}\r\nstatic void mv64x60_sram_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct mv64x60_sram_pdata *pdata = edac_dev->pvt_info;\r\nu32 cause;\r\ncause = in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_CAUSE);\r\nif (!cause)\r\nreturn;\r\nprintk(KERN_ERR "Error in internal SRAM\n");\r\nprintk(KERN_ERR "Cause register: 0x%08x\n", cause);\r\nprintk(KERN_ERR "Address Low: 0x%08x\n",\r\nin_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_ADDR_LO));\r\nprintk(KERN_ERR "Address High: 0x%08x\n",\r\nin_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_ADDR_HI));\r\nprintk(KERN_ERR "Data Low: 0x%08x\n",\r\nin_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_DATA_LO));\r\nprintk(KERN_ERR "Data High: 0x%08x\n",\r\nin_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_DATA_HI));\r\nprintk(KERN_ERR "Parity: 0x%08x\n",\r\nin_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_PARITY));\r\nout_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_CAUSE, 0);\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic irqreturn_t mv64x60_sram_isr(int irq, void *dev_id)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = dev_id;\r\nstruct mv64x60_sram_pdata *pdata = edac_dev->pvt_info;\r\nu32 cause;\r\ncause = in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_CAUSE);\r\nif (!cause)\r\nreturn IRQ_NONE;\r\nmv64x60_sram_check(edac_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mv64x60_sram_err_probe(struct platform_device *pdev)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct mv64x60_sram_pdata *pdata;\r\nstruct resource *r;\r\nint res = 0;\r\nif (!devres_open_group(&pdev->dev, mv64x60_sram_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nedac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),\r\n"sram", 1, NULL, 0, 0, NULL, 0,\r\nedac_dev_idx);\r\nif (!edac_dev) {\r\ndevres_release_group(&pdev->dev, mv64x60_sram_err_probe);\r\nreturn -ENOMEM;\r\n}\r\npdata = edac_dev->pvt_info;\r\npdata->name = "mv64x60_sram_err";\r\npdata->irq = NO_IRQ;\r\nedac_dev->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, edac_dev);\r\nedac_dev->dev_name = dev_name(&pdev->dev);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"SRAM err regs\n", __func__);\r\nres = -ENOENT;\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev,\r\nr->start,\r\nresource_size(r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while request mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->sram_vbase = devm_ioremap(&pdev->dev,\r\nr->start,\r\nresource_size(r));\r\nif (!pdata->sram_vbase) {\r\nprintk(KERN_ERR "%s: Unable to setup SRAM err regs\n",\r\n__func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nout_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_CAUSE, 0);\r\nedac_dev->mod_name = EDAC_MOD_STR;\r\nedac_dev->ctl_name = pdata->name;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nedac_dev->edac_check = mv64x60_sram_check;\r\npdata->edac_idx = edac_dev_idx++;\r\nif (edac_device_add_device(edac_dev) > 0) {\r\nedac_dbg(3, "failed edac_device_add_device()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = platform_get_irq(pdev, 0);\r\nres = devm_request_irq(&pdev->dev,\r\npdata->irq,\r\nmv64x60_sram_isr,\r\n0,\r\n"[EDAC] SRAM err",\r\nedac_dev);\r\nif (res < 0) {\r\nprintk(KERN_ERR\r\n"%s: Unable to request irq %d for "\r\n"MV64x60 SRAM ERR\n", __func__, pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO EDAC_MOD_STR " acquired irq %d for SRAM Err\n",\r\npdata->irq);\r\n}\r\ndevres_remove_group(&pdev->dev, mv64x60_sram_err_probe);\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nerr2:\r\nedac_device_del_device(&pdev->dev);\r\nerr:\r\ndevres_release_group(&pdev->dev, mv64x60_sram_err_probe);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn res;\r\n}\r\nstatic int mv64x60_sram_err_remove(struct platform_device *pdev)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = platform_get_drvdata(pdev);\r\nedac_dbg(0, "\n");\r\nedac_device_del_device(&pdev->dev);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn 0;\r\n}\r\nstatic void mv64x60_cpu_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct mv64x60_cpu_pdata *pdata = edac_dev->pvt_info;\r\nu32 cause;\r\ncause = in_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_CAUSE) &\r\nMV64x60_CPU_CAUSE_MASK;\r\nif (!cause)\r\nreturn;\r\nprintk(KERN_ERR "Error on CPU interface\n");\r\nprintk(KERN_ERR "Cause register: 0x%08x\n", cause);\r\nprintk(KERN_ERR "Address Low: 0x%08x\n",\r\nin_le32(pdata->cpu_vbase[0] + MV64x60_CPU_ERR_ADDR_LO));\r\nprintk(KERN_ERR "Address High: 0x%08x\n",\r\nin_le32(pdata->cpu_vbase[0] + MV64x60_CPU_ERR_ADDR_HI));\r\nprintk(KERN_ERR "Data Low: 0x%08x\n",\r\nin_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_DATA_LO));\r\nprintk(KERN_ERR "Data High: 0x%08x\n",\r\nin_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_DATA_HI));\r\nprintk(KERN_ERR "Parity: 0x%08x\n",\r\nin_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_PARITY));\r\nout_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_CAUSE, 0);\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic irqreturn_t mv64x60_cpu_isr(int irq, void *dev_id)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = dev_id;\r\nstruct mv64x60_cpu_pdata *pdata = edac_dev->pvt_info;\r\nu32 cause;\r\ncause = in_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_CAUSE) &\r\nMV64x60_CPU_CAUSE_MASK;\r\nif (!cause)\r\nreturn IRQ_NONE;\r\nmv64x60_cpu_check(edac_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mv64x60_cpu_err_probe(struct platform_device *pdev)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct resource *r;\r\nstruct mv64x60_cpu_pdata *pdata;\r\nint res = 0;\r\nif (!devres_open_group(&pdev->dev, mv64x60_cpu_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nedac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),\r\n"cpu", 1, NULL, 0, 0, NULL, 0,\r\nedac_dev_idx);\r\nif (!edac_dev) {\r\ndevres_release_group(&pdev->dev, mv64x60_cpu_err_probe);\r\nreturn -ENOMEM;\r\n}\r\npdata = edac_dev->pvt_info;\r\npdata->name = "mv64x60_cpu_err";\r\npdata->irq = NO_IRQ;\r\nedac_dev->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, edac_dev);\r\nedac_dev->dev_name = dev_name(&pdev->dev);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"CPU err regs\n", __func__);\r\nres = -ENOENT;\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev,\r\nr->start,\r\nresource_size(r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->cpu_vbase[0] = devm_ioremap(&pdev->dev,\r\nr->start,\r\nresource_size(r));\r\nif (!pdata->cpu_vbase[0]) {\r\nprintk(KERN_ERR "%s: Unable to setup CPU err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!r) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"CPU err regs\n", __func__);\r\nres = -ENOENT;\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev,\r\nr->start,\r\nresource_size(r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->cpu_vbase[1] = devm_ioremap(&pdev->dev,\r\nr->start,\r\nresource_size(r));\r\nif (!pdata->cpu_vbase[1]) {\r\nprintk(KERN_ERR "%s: Unable to setup CPU err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nout_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_CAUSE, 0);\r\nout_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_MASK, 0);\r\nout_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_MASK, 0x000000ff);\r\nedac_dev->mod_name = EDAC_MOD_STR;\r\nedac_dev->ctl_name = pdata->name;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nedac_dev->edac_check = mv64x60_cpu_check;\r\npdata->edac_idx = edac_dev_idx++;\r\nif (edac_device_add_device(edac_dev) > 0) {\r\nedac_dbg(3, "failed edac_device_add_device()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = platform_get_irq(pdev, 0);\r\nres = devm_request_irq(&pdev->dev,\r\npdata->irq,\r\nmv64x60_cpu_isr,\r\n0,\r\n"[EDAC] CPU err",\r\nedac_dev);\r\nif (res < 0) {\r\nprintk(KERN_ERR\r\n"%s: Unable to request irq %d for MV64x60 "\r\n"CPU ERR\n", __func__, pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO EDAC_MOD_STR\r\n" acquired irq %d for CPU Err\n", pdata->irq);\r\n}\r\ndevres_remove_group(&pdev->dev, mv64x60_cpu_err_probe);\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nerr2:\r\nedac_device_del_device(&pdev->dev);\r\nerr:\r\ndevres_release_group(&pdev->dev, mv64x60_cpu_err_probe);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn res;\r\n}\r\nstatic int mv64x60_cpu_err_remove(struct platform_device *pdev)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = platform_get_drvdata(pdev);\r\nedac_dbg(0, "\n");\r\nedac_device_del_device(&pdev->dev);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn 0;\r\n}\r\nstatic void mv64x60_mc_check(struct mem_ctl_info *mci)\r\n{\r\nstruct mv64x60_mc_pdata *pdata = mci->pvt_info;\r\nu32 reg;\r\nu32 err_addr;\r\nu32 sdram_ecc;\r\nu32 comp_ecc;\r\nu32 syndrome;\r\nreg = in_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ADDR);\r\nif (!reg)\r\nreturn;\r\nerr_addr = reg & ~0x3;\r\nsdram_ecc = in_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ECC_RCVD);\r\ncomp_ecc = in_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ECC_CALC);\r\nsyndrome = sdram_ecc ^ comp_ecc;\r\nif (!(reg & 0x1))\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\nerr_addr >> PAGE_SHIFT,\r\nerr_addr & PAGE_MASK, syndrome,\r\n0, 0, -1,\r\nmci->ctl_name, "");\r\nelse\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\nerr_addr >> PAGE_SHIFT,\r\nerr_addr & PAGE_MASK, 0,\r\n0, 0, -1,\r\nmci->ctl_name, "");\r\nout_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ADDR, 0);\r\n}\r\nstatic irqreturn_t mv64x60_mc_isr(int irq, void *dev_id)\r\n{\r\nstruct mem_ctl_info *mci = dev_id;\r\nstruct mv64x60_mc_pdata *pdata = mci->pvt_info;\r\nu32 reg;\r\nreg = in_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ADDR);\r\nif (!reg)\r\nreturn IRQ_NONE;\r\nmv64x60_mc_check(mci);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void get_total_mem(struct mv64x60_mc_pdata *pdata)\r\n{\r\nstruct device_node *np = NULL;\r\nconst unsigned int *reg;\r\nnp = of_find_node_by_type(NULL, "memory");\r\nif (!np)\r\nreturn;\r\nreg = of_get_property(np, "reg", NULL);\r\npdata->total_mem = reg[1];\r\n}\r\nstatic void mv64x60_init_csrows(struct mem_ctl_info *mci,\r\nstruct mv64x60_mc_pdata *pdata)\r\n{\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nu32 devtype;\r\nu32 ctl;\r\nget_total_mem(pdata);\r\nctl = in_le32(pdata->mc_vbase + MV64X60_SDRAM_CONFIG);\r\ncsrow = mci->csrows[0];\r\ndimm = csrow->channels[0]->dimm;\r\ndimm->nr_pages = pdata->total_mem >> PAGE_SHIFT;\r\ndimm->grain = 8;\r\ndimm->mtype = (ctl & MV64X60_SDRAM_REGISTERED) ? MEM_RDDR : MEM_DDR;\r\ndevtype = (ctl >> 20) & 0x3;\r\nswitch (devtype) {\r\ncase 0x0:\r\ndimm->dtype = DEV_X32;\r\nbreak;\r\ncase 0x2:\r\ndimm->dtype = DEV_X16;\r\nbreak;\r\ncase 0x3:\r\ndimm->dtype = DEV_X4;\r\nbreak;\r\ndefault:\r\ndimm->dtype = DEV_UNKNOWN;\r\nbreak;\r\n}\r\ndimm->edac_mode = EDAC_SECDED;\r\n}\r\nstatic int mv64x60_mc_err_probe(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct mv64x60_mc_pdata *pdata;\r\nstruct resource *r;\r\nu32 ctl;\r\nint res = 0;\r\nif (!devres_open_group(&pdev->dev, mv64x60_mc_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 1;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(edac_mc_idx, ARRAY_SIZE(layers), layers,\r\nsizeof(struct mv64x60_mc_pdata));\r\nif (!mci) {\r\nprintk(KERN_ERR "%s: No memory for CPU err\n", __func__);\r\ndevres_release_group(&pdev->dev, mv64x60_mc_err_probe);\r\nreturn -ENOMEM;\r\n}\r\npdata = mci->pvt_info;\r\nmci->pdev = &pdev->dev;\r\nplatform_set_drvdata(pdev, mci);\r\npdata->name = "mv64x60_mc_err";\r\npdata->irq = NO_IRQ;\r\nmci->dev_name = dev_name(&pdev->dev);\r\npdata->edac_idx = edac_mc_idx++;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"MC err regs\n", __func__);\r\nres = -ENOENT;\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev,\r\nr->start,\r\nresource_size(r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->mc_vbase = devm_ioremap(&pdev->dev,\r\nr->start,\r\nresource_size(r));\r\nif (!pdata->mc_vbase) {\r\nprintk(KERN_ERR "%s: Unable to setup MC err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nctl = in_le32(pdata->mc_vbase + MV64X60_SDRAM_CONFIG);\r\nif (!(ctl & MV64X60_SDRAM_ECC)) {\r\nprintk(KERN_WARNING "%s: No ECC DIMMs discovered\n", __func__);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nedac_dbg(3, "init mci\n");\r\nmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_DDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = MV64x60_REVISION;\r\nmci->ctl_name = mv64x60_ctl_name;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nmci->edac_check = mv64x60_mc_check;\r\nmci->ctl_page_to_phys = NULL;\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\nmv64x60_init_csrows(mci, pdata);\r\nout_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ADDR, 0);\r\nctl = in_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ECC_CNTL);\r\nctl = (ctl & 0xff00ffff) | 0x10000;\r\nout_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ECC_CNTL, ctl);\r\nres = edac_mc_add_mc(mci);\r\nif (res) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = platform_get_irq(pdev, 0);\r\nres = devm_request_irq(&pdev->dev,\r\npdata->irq,\r\nmv64x60_mc_isr,\r\n0,\r\n"[EDAC] MC err",\r\nmci);\r\nif (res < 0) {\r\nprintk(KERN_ERR "%s: Unable to request irq %d for "\r\n"MV64x60 DRAM ERR\n", __func__, pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO EDAC_MOD_STR " acquired irq %d for MC Err\n",\r\npdata->irq);\r\n}\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nerr2:\r\nedac_mc_del_mc(&pdev->dev);\r\nerr:\r\ndevres_release_group(&pdev->dev, mv64x60_mc_err_probe);\r\nedac_mc_free(mci);\r\nreturn res;\r\n}\r\nstatic int mv64x60_mc_err_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_dbg(0, "\n");\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}\r\nstatic int __init mv64x60_edac_init(void)\r\n{\r\nint ret = 0;\r\nprintk(KERN_INFO "Marvell MV64x60 EDAC driver " MV64x60_REVISION "\n");\r\nprintk(KERN_INFO "\t(C) 2006-2007 MontaVista Software\n");\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_INT:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_INT;\r\nbreak;\r\n}\r\nreturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\r\n}\r\nstatic void __exit mv64x60_edac_exit(void)\r\n{\r\nplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\r\n}
