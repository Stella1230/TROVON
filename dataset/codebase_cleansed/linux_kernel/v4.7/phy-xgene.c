static void sds_wr(void __iomem *csr_base, u32 indirect_cmd_reg,\r\nu32 indirect_data_reg, u32 addr, u32 data)\r\n{\r\nunsigned long deadline = jiffies + HZ;\r\nu32 val;\r\nu32 cmd;\r\ncmd = CFG_IND_WR_CMD_MASK | CFG_IND_CMD_DONE_MASK;\r\ncmd = CFG_IND_ADDR_SET(cmd, addr);\r\nwritel(data, csr_base + indirect_data_reg);\r\nreadl(csr_base + indirect_data_reg);\r\nwritel(cmd, csr_base + indirect_cmd_reg);\r\nreadl(csr_base + indirect_cmd_reg);\r\ndo {\r\nval = readl(csr_base + indirect_cmd_reg);\r\n} while (!(val & CFG_IND_CMD_DONE_MASK) &&\r\ntime_before(jiffies, deadline));\r\nif (!(val & CFG_IND_CMD_DONE_MASK))\r\npr_err("SDS WR timeout at 0x%p offset 0x%08X value 0x%08X\n",\r\ncsr_base + indirect_cmd_reg, addr, data);\r\n}\r\nstatic void sds_rd(void __iomem *csr_base, u32 indirect_cmd_reg,\r\nu32 indirect_data_reg, u32 addr, u32 *data)\r\n{\r\nunsigned long deadline = jiffies + HZ;\r\nu32 val;\r\nu32 cmd;\r\ncmd = CFG_IND_RD_CMD_MASK | CFG_IND_CMD_DONE_MASK;\r\ncmd = CFG_IND_ADDR_SET(cmd, addr);\r\nwritel(cmd, csr_base + indirect_cmd_reg);\r\nreadl(csr_base + indirect_cmd_reg);\r\ndo {\r\nval = readl(csr_base + indirect_cmd_reg);\r\n} while (!(val & CFG_IND_CMD_DONE_MASK) &&\r\ntime_before(jiffies, deadline));\r\n*data = readl(csr_base + indirect_data_reg);\r\nif (!(val & CFG_IND_CMD_DONE_MASK))\r\npr_err("SDS WR timeout at 0x%p offset 0x%08X value 0x%08X\n",\r\ncsr_base + indirect_cmd_reg, addr, *data);\r\n}\r\nstatic void cmu_wr(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\r\nu32 reg, u32 data)\r\n{\r\nvoid __iomem *sds_base = ctx->sds_base;\r\nu32 val;\r\nif (cmu_type == REF_CMU)\r\nreg += SERDES_PLL_REF_INDIRECT_OFFSET;\r\nelse\r\nreg += SERDES_PLL_INDIRECT_OFFSET;\r\nsds_wr(sds_base, SATA_ENET_SDS_IND_CMD_REG,\r\nSATA_ENET_SDS_IND_WDATA_REG, reg, data);\r\nsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\r\nSATA_ENET_SDS_IND_RDATA_REG, reg, &val);\r\npr_debug("CMU WR addr 0x%X value 0x%08X <-> 0x%08X\n", reg, data, val);\r\n}\r\nstatic void cmu_rd(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\r\nu32 reg, u32 *data)\r\n{\r\nvoid __iomem *sds_base = ctx->sds_base;\r\nif (cmu_type == REF_CMU)\r\nreg += SERDES_PLL_REF_INDIRECT_OFFSET;\r\nelse\r\nreg += SERDES_PLL_INDIRECT_OFFSET;\r\nsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\r\nSATA_ENET_SDS_IND_RDATA_REG, reg, data);\r\npr_debug("CMU RD addr 0x%X value 0x%08X\n", reg, *data);\r\n}\r\nstatic void cmu_toggle1to0(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\r\nu32 reg, u32 bits)\r\n{\r\nu32 val;\r\ncmu_rd(ctx, cmu_type, reg, &val);\r\nval |= bits;\r\ncmu_wr(ctx, cmu_type, reg, val);\r\ncmu_rd(ctx, cmu_type, reg, &val);\r\nval &= ~bits;\r\ncmu_wr(ctx, cmu_type, reg, val);\r\n}\r\nstatic void cmu_clrbits(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\r\nu32 reg, u32 bits)\r\n{\r\nu32 val;\r\ncmu_rd(ctx, cmu_type, reg, &val);\r\nval &= ~bits;\r\ncmu_wr(ctx, cmu_type, reg, val);\r\n}\r\nstatic void cmu_setbits(struct xgene_phy_ctx *ctx, enum cmu_type_t cmu_type,\r\nu32 reg, u32 bits)\r\n{\r\nu32 val;\r\ncmu_rd(ctx, cmu_type, reg, &val);\r\nval |= bits;\r\ncmu_wr(ctx, cmu_type, reg, val);\r\n}\r\nstatic void serdes_wr(struct xgene_phy_ctx *ctx, int lane, u32 reg, u32 data)\r\n{\r\nvoid __iomem *sds_base = ctx->sds_base;\r\nu32 val;\r\nreg += SERDES_INDIRECT_OFFSET;\r\nreg += lane * SERDES_LANE_STRIDE;\r\nsds_wr(sds_base, SATA_ENET_SDS_IND_CMD_REG,\r\nSATA_ENET_SDS_IND_WDATA_REG, reg, data);\r\nsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\r\nSATA_ENET_SDS_IND_RDATA_REG, reg, &val);\r\npr_debug("SERDES WR addr 0x%X value 0x%08X <-> 0x%08X\n", reg, data,\r\nval);\r\n}\r\nstatic void serdes_rd(struct xgene_phy_ctx *ctx, int lane, u32 reg, u32 *data)\r\n{\r\nvoid __iomem *sds_base = ctx->sds_base;\r\nreg += SERDES_INDIRECT_OFFSET;\r\nreg += lane * SERDES_LANE_STRIDE;\r\nsds_rd(sds_base, SATA_ENET_SDS_IND_CMD_REG,\r\nSATA_ENET_SDS_IND_RDATA_REG, reg, data);\r\npr_debug("SERDES RD addr 0x%X value 0x%08X\n", reg, *data);\r\n}\r\nstatic void serdes_clrbits(struct xgene_phy_ctx *ctx, int lane, u32 reg,\r\nu32 bits)\r\n{\r\nu32 val;\r\nserdes_rd(ctx, lane, reg, &val);\r\nval &= ~bits;\r\nserdes_wr(ctx, lane, reg, val);\r\n}\r\nstatic void serdes_setbits(struct xgene_phy_ctx *ctx, int lane, u32 reg,\r\nu32 bits)\r\n{\r\nu32 val;\r\nserdes_rd(ctx, lane, reg, &val);\r\nval |= bits;\r\nserdes_wr(ctx, lane, reg, val);\r\n}\r\nstatic void xgene_phy_cfg_cmu_clk_type(struct xgene_phy_ctx *ctx,\r\nenum cmu_type_t cmu_type,\r\nenum clk_type_t clk_type)\r\n{\r\nu32 val;\r\ncmu_rd(ctx, cmu_type, CMU_REG12, &val);\r\nval = CMU_REG12_STATE_DELAY9_SET(val, 0x1);\r\ncmu_wr(ctx, cmu_type, CMU_REG12, val);\r\ncmu_wr(ctx, cmu_type, CMU_REG13, 0x0222);\r\ncmu_wr(ctx, cmu_type, CMU_REG14, 0x2225);\r\nif (clk_type == CLK_EXT_DIFF) {\r\ncmu_rd(ctx, cmu_type, CMU_REG0, &val);\r\nval = CMU_REG0_PLL_REF_SEL_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG0, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG1, &val);\r\nval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG1, val);\r\ndev_dbg(ctx->dev, "Set external reference clock\n");\r\n} else if (clk_type == CLK_INT_DIFF) {\r\ncmu_rd(ctx, cmu_type, CMU_REG0, &val);\r\nval = CMU_REG0_PLL_REF_SEL_SET(val, 0x1);\r\ncmu_wr(ctx, cmu_type, CMU_REG0, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG1, &val);\r\nval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x1);\r\ncmu_wr(ctx, cmu_type, CMU_REG1, val);\r\ndev_dbg(ctx->dev, "Set internal reference clock\n");\r\n} else if (clk_type == CLK_INT_SING) {\r\ncmu_rd(ctx, cmu_type, CMU_REG1, &val);\r\nval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x1);\r\ncmu_wr(ctx, cmu_type, CMU_REG1, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG1, &val);\r\nval = CMU_REG1_REFCLK_CMOS_SEL_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG1, val);\r\ndev_dbg(ctx->dev,\r\n"Set internal single ended reference clock\n");\r\n}\r\n}\r\nstatic void xgene_phy_sata_cfg_cmu_core(struct xgene_phy_ctx *ctx,\r\nenum cmu_type_t cmu_type,\r\nenum clk_type_t clk_type)\r\n{\r\nu32 val;\r\nint ref_100MHz;\r\nif (cmu_type == REF_CMU) {\r\ncmu_rd(ctx, cmu_type, CMU_REG34, &val);\r\nval = CMU_REG34_VCO_CAL_VTH_LO_MAX_SET(val, 0x7);\r\nval = CMU_REG34_VCO_CAL_VTH_HI_MAX_SET(val, 0xc);\r\nval = CMU_REG34_VCO_CAL_VTH_LO_MIN_SET(val, 0x3);\r\nval = CMU_REG34_VCO_CAL_VTH_HI_MIN_SET(val, 0x8);\r\ncmu_wr(ctx, cmu_type, CMU_REG34, val);\r\n}\r\ncmu_rd(ctx, cmu_type, CMU_REG0, &val);\r\nif (cmu_type == REF_CMU || preA3Chip)\r\nval = CMU_REG0_CAL_COUNT_RESOL_SET(val, 0x4);\r\nelse\r\nval = CMU_REG0_CAL_COUNT_RESOL_SET(val, 0x7);\r\ncmu_wr(ctx, cmu_type, CMU_REG0, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG1, &val);\r\nval = CMU_REG1_PLL_CP_SET(val, 0x1);\r\nif (cmu_type == REF_CMU || preA3Chip)\r\nval = CMU_REG1_PLL_CP_SEL_SET(val, 0x5);\r\nelse\r\nval = CMU_REG1_PLL_CP_SEL_SET(val, 0x3);\r\nif (cmu_type == REF_CMU)\r\nval = CMU_REG1_PLL_MANUALCAL_SET(val, 0x0);\r\nelse\r\nval = CMU_REG1_PLL_MANUALCAL_SET(val, 0x1);\r\ncmu_wr(ctx, cmu_type, CMU_REG1, val);\r\nif (cmu_type != REF_CMU)\r\ncmu_clrbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\r\ncmu_rd(ctx, cmu_type, CMU_REG2, &val);\r\nif (cmu_type == REF_CMU) {\r\nval = CMU_REG2_PLL_LFRES_SET(val, 0xa);\r\nref_100MHz = 1;\r\n} else {\r\nval = CMU_REG2_PLL_LFRES_SET(val, 0x3);\r\nif (clk_type == CLK_EXT_DIFF)\r\nref_100MHz = 0;\r\nelse\r\nref_100MHz = 1;\r\n}\r\nif (ref_100MHz) {\r\nval = CMU_REG2_PLL_FBDIV_SET(val, FBDIV_VAL_100M);\r\nval = CMU_REG2_PLL_REFDIV_SET(val, REFDIV_VAL_100M);\r\n} else {\r\nval = CMU_REG2_PLL_FBDIV_SET(val, FBDIV_VAL_50M);\r\nval = CMU_REG2_PLL_REFDIV_SET(val, REFDIV_VAL_50M);\r\n}\r\ncmu_wr(ctx, cmu_type, CMU_REG2, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG3, &val);\r\nif (cmu_type == REF_CMU) {\r\nval = CMU_REG3_VCOVARSEL_SET(val, 0x3);\r\nval = CMU_REG3_VCO_MOMSEL_INIT_SET(val, 0x10);\r\n} else {\r\nval = CMU_REG3_VCOVARSEL_SET(val, 0xF);\r\nif (preA3Chip)\r\nval = CMU_REG3_VCO_MOMSEL_INIT_SET(val, 0x15);\r\nelse\r\nval = CMU_REG3_VCO_MOMSEL_INIT_SET(val, 0x1a);\r\nval = CMU_REG3_VCO_MANMOMSEL_SET(val, 0x15);\r\n}\r\ncmu_wr(ctx, cmu_type, CMU_REG3, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG26, &val);\r\nval = CMU_REG26_FORCE_PLL_LOCK_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG26, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG5, &val);\r\nval = CMU_REG5_PLL_LFSMCAP_SET(val, 0x3);\r\nval = CMU_REG5_PLL_LFCAP_SET(val, 0x3);\r\nif (cmu_type == REF_CMU || !preA3Chip)\r\nval = CMU_REG5_PLL_LOCK_RESOLUTION_SET(val, 0x7);\r\nelse\r\nval = CMU_REG5_PLL_LOCK_RESOLUTION_SET(val, 0x4);\r\ncmu_wr(ctx, cmu_type, CMU_REG5, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG6, &val);\r\nval = CMU_REG6_PLL_VREGTRIM_SET(val, preA3Chip ? 0x0 : 0x2);\r\nval = CMU_REG6_MAN_PVT_CAL_SET(val, preA3Chip ? 0x1 : 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG6, val);\r\nif (cmu_type == PHY_CMU) {\r\ncmu_rd(ctx, cmu_type, CMU_REG9, &val);\r\nval = CMU_REG9_TX_WORD_MODE_CH1_SET(val,\r\nCMU_REG9_WORD_LEN_20BIT);\r\nval = CMU_REG9_TX_WORD_MODE_CH0_SET(val,\r\nCMU_REG9_WORD_LEN_20BIT);\r\nval = CMU_REG9_PLL_POST_DIVBY2_SET(val, 0x1);\r\nif (!preA3Chip) {\r\nval = CMU_REG9_VBG_BYPASSB_SET(val, 0x0);\r\nval = CMU_REG9_IGEN_BYPASS_SET(val , 0x0);\r\n}\r\ncmu_wr(ctx, cmu_type, CMU_REG9, val);\r\nif (!preA3Chip) {\r\ncmu_rd(ctx, cmu_type, CMU_REG10, &val);\r\nval = CMU_REG10_VREG_REFSEL_SET(val, 0x1);\r\ncmu_wr(ctx, cmu_type, CMU_REG10, val);\r\n}\r\n}\r\ncmu_rd(ctx, cmu_type, CMU_REG16, &val);\r\nval = CMU_REG16_CALIBRATION_DONE_OVERRIDE_SET(val, 0x1);\r\nval = CMU_REG16_BYPASS_PLL_LOCK_SET(val, 0x1);\r\nif (cmu_type == REF_CMU || preA3Chip)\r\nval = CMU_REG16_VCOCAL_WAIT_BTW_CODE_SET(val, 0x4);\r\nelse\r\nval = CMU_REG16_VCOCAL_WAIT_BTW_CODE_SET(val, 0x7);\r\ncmu_wr(ctx, cmu_type, CMU_REG16, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG30, &val);\r\nval = CMU_REG30_PCIE_MODE_SET(val, 0x0);\r\nval = CMU_REG30_LOCK_COUNT_SET(val, 0x3);\r\ncmu_wr(ctx, cmu_type, CMU_REG30, val);\r\ncmu_wr(ctx, cmu_type, CMU_REG31, 0xF);\r\ncmu_rd(ctx, cmu_type, CMU_REG32, &val);\r\nval = CMU_REG32_PVT_CAL_WAIT_SEL_SET(val, 0x3);\r\nif (cmu_type == REF_CMU || preA3Chip)\r\nval = CMU_REG32_IREF_ADJ_SET(val, 0x3);\r\nelse\r\nval = CMU_REG32_IREF_ADJ_SET(val, 0x1);\r\ncmu_wr(ctx, cmu_type, CMU_REG32, val);\r\nif (cmu_type != REF_CMU && preA3Chip)\r\ncmu_wr(ctx, cmu_type, CMU_REG34, 0x8d27);\r\nelse\r\ncmu_wr(ctx, cmu_type, CMU_REG34, 0x873c);\r\ncmu_wr(ctx, cmu_type, CMU_REG37, 0xF00F);\r\n}\r\nstatic void xgene_phy_ssc_enable(struct xgene_phy_ctx *ctx,\r\nenum cmu_type_t cmu_type)\r\n{\r\nu32 val;\r\ncmu_rd(ctx, cmu_type, CMU_REG35, &val);\r\nval = CMU_REG35_PLL_SSC_MOD_SET(val, 98);\r\ncmu_wr(ctx, cmu_type, CMU_REG35, val);\r\ncmu_rd(ctx, cmu_type, CMU_REG36, &val);\r\nval = CMU_REG36_PLL_SSC_VSTEP_SET(val, 30);\r\nval = CMU_REG36_PLL_SSC_EN_SET(val, 1);\r\nval = CMU_REG36_PLL_SSC_DSMSEL_SET(val, 1);\r\ncmu_wr(ctx, cmu_type, CMU_REG36, val);\r\ncmu_clrbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\r\ncmu_setbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\r\ncmu_toggle1to0(ctx, cmu_type, CMU_REG32,\r\nCMU_REG32_FORCE_VCOCAL_START_MASK);\r\n}\r\nstatic void xgene_phy_sata_cfg_lanes(struct xgene_phy_ctx *ctx)\r\n{\r\nu32 val;\r\nu32 reg;\r\nint i;\r\nint lane;\r\nfor (lane = 0; lane < MAX_LANE; lane++) {\r\nserdes_wr(ctx, lane, RXTX_REG147, 0x6);\r\nserdes_rd(ctx, lane, RXTX_REG0, &val);\r\nval = RXTX_REG0_CTLE_EQ_HR_SET(val, 0x10);\r\nval = RXTX_REG0_CTLE_EQ_QR_SET(val, 0x10);\r\nval = RXTX_REG0_CTLE_EQ_FR_SET(val, 0x10);\r\nserdes_wr(ctx, lane, RXTX_REG0, val);\r\nserdes_rd(ctx, lane, RXTX_REG1, &val);\r\nval = RXTX_REG1_RXACVCM_SET(val, 0x7);\r\nval = RXTX_REG1_CTLE_EQ_SET(val,\r\nctx->sata_param.txboostgain[lane * 3 +\r\nctx->sata_param.speed[lane]]);\r\nserdes_wr(ctx, lane, RXTX_REG1, val);\r\nserdes_rd(ctx, lane, RXTX_REG2, &val);\r\nval = RXTX_REG2_VTT_ENA_SET(val, 0x1);\r\nval = RXTX_REG2_VTT_SEL_SET(val, 0x1);\r\nval = RXTX_REG2_TX_FIFO_ENA_SET(val, 0x1);\r\nserdes_wr(ctx, lane, RXTX_REG2, val);\r\nserdes_rd(ctx, lane, RXTX_REG4, &val);\r\nval = RXTX_REG4_TX_WORD_MODE_SET(val, CMU_REG9_WORD_LEN_20BIT);\r\nserdes_wr(ctx, lane, RXTX_REG4, val);\r\nif (!preA3Chip) {\r\nserdes_rd(ctx, lane, RXTX_REG1, &val);\r\nval = RXTX_REG1_RXVREG1_SET(val, 0x2);\r\nval = RXTX_REG1_RXIREF_ADJ_SET(val, 0x2);\r\nserdes_wr(ctx, lane, RXTX_REG1, val);\r\n}\r\nserdes_rd(ctx, lane, RXTX_REG5, &val);\r\nval = RXTX_REG5_TX_CN1_SET(val,\r\nctx->sata_param.txprecursor_cn1[lane * 3 +\r\nctx->sata_param.speed[lane]]);\r\nval = RXTX_REG5_TX_CP1_SET(val,\r\nctx->sata_param.txpostcursor_cp1[lane * 3 +\r\nctx->sata_param.speed[lane]]);\r\nval = RXTX_REG5_TX_CN2_SET(val,\r\nctx->sata_param.txprecursor_cn2[lane * 3 +\r\nctx->sata_param.speed[lane]]);\r\nserdes_wr(ctx, lane, RXTX_REG5, val);\r\nserdes_rd(ctx, lane, RXTX_REG6, &val);\r\nval = RXTX_REG6_TXAMP_CNTL_SET(val,\r\nctx->sata_param.txamplitude[lane * 3 +\r\nctx->sata_param.speed[lane]]);\r\nval = RXTX_REG6_TXAMP_ENA_SET(val, 0x1);\r\nval = RXTX_REG6_TX_IDLE_SET(val, 0x0);\r\nval = RXTX_REG6_RX_BIST_RESYNC_SET(val, 0x0);\r\nval = RXTX_REG6_RX_BIST_ERRCNT_RD_SET(val, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG6, val);\r\nserdes_rd(ctx, lane, RXTX_REG7, &val);\r\nval = RXTX_REG7_BIST_ENA_RX_SET(val, 0x0);\r\nval = RXTX_REG7_RX_WORD_MODE_SET(val, CMU_REG9_WORD_LEN_20BIT);\r\nserdes_wr(ctx, lane, RXTX_REG7, val);\r\nserdes_rd(ctx, lane, RXTX_REG8, &val);\r\nval = RXTX_REG8_CDR_LOOP_ENA_SET(val, 0x1);\r\nval = RXTX_REG8_CDR_BYPASS_RXLOS_SET(val, 0x0);\r\nval = RXTX_REG8_SSC_ENABLE_SET(val, 0x1);\r\nval = RXTX_REG8_SD_DISABLE_SET(val, 0x0);\r\nval = RXTX_REG8_SD_VREF_SET(val, 0x4);\r\nserdes_wr(ctx, lane, RXTX_REG8, val);\r\nserdes_rd(ctx, lane, RXTX_REG11, &val);\r\nval = RXTX_REG11_PHASE_ADJUST_LIMIT_SET(val, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG11, val);\r\nserdes_rd(ctx, lane, RXTX_REG12, &val);\r\nval = RXTX_REG12_LATCH_OFF_ENA_SET(val, 0x1);\r\nval = RXTX_REG12_SUMOS_ENABLE_SET(val, 0x0);\r\nval = RXTX_REG12_RX_DET_TERM_ENABLE_SET(val, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG12, val);\r\nserdes_rd(ctx, lane, RXTX_REG26, &val);\r\nval = RXTX_REG26_PERIOD_ERROR_LATCH_SET(val, 0x0);\r\nval = RXTX_REG26_BLWC_ENA_SET(val, 0x1);\r\nserdes_wr(ctx, lane, RXTX_REG26, val);\r\nserdes_wr(ctx, lane, RXTX_REG28, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG31, 0x0);\r\nserdes_rd(ctx, lane, RXTX_REG61, &val);\r\nval = RXTX_REG61_ISCAN_INBERT_SET(val, 0x1);\r\nval = RXTX_REG61_LOADFREQ_SHIFT_SET(val, 0x0);\r\nval = RXTX_REG61_EYE_COUNT_WIDTH_SEL_SET(val, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG61, val);\r\nserdes_rd(ctx, lane, RXTX_REG62, &val);\r\nval = RXTX_REG62_PERIOD_H1_QLATCH_SET(val, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG62, val);\r\nfor (i = 0; i < 9; i++) {\r\nreg = RXTX_REG81 + i * 2;\r\nserdes_rd(ctx, lane, reg, &val);\r\nval = RXTX_REG89_MU_TH7_SET(val, 0xe);\r\nval = RXTX_REG89_MU_TH8_SET(val, 0xe);\r\nval = RXTX_REG89_MU_TH9_SET(val, 0xe);\r\nserdes_wr(ctx, lane, reg, val);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nreg = RXTX_REG96 + i * 2;\r\nserdes_rd(ctx, lane, reg, &val);\r\nval = RXTX_REG96_MU_FREQ1_SET(val, 0x10);\r\nval = RXTX_REG96_MU_FREQ2_SET(val, 0x10);\r\nval = RXTX_REG96_MU_FREQ3_SET(val, 0x10);\r\nserdes_wr(ctx, lane, reg, val);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nreg = RXTX_REG99 + i * 2;\r\nserdes_rd(ctx, lane, reg, &val);\r\nval = RXTX_REG99_MU_PHASE1_SET(val, 0x7);\r\nval = RXTX_REG99_MU_PHASE2_SET(val, 0x7);\r\nval = RXTX_REG99_MU_PHASE3_SET(val, 0x7);\r\nserdes_wr(ctx, lane, reg, val);\r\n}\r\nserdes_rd(ctx, lane, RXTX_REG102, &val);\r\nval = RXTX_REG102_FREQLOOP_LIMIT_SET(val, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG102, val);\r\nserdes_wr(ctx, lane, RXTX_REG114, 0xffe0);\r\nserdes_rd(ctx, lane, RXTX_REG125, &val);\r\nval = RXTX_REG125_SIGN_PQ_SET(val,\r\nctx->sata_param.txeyedirection[lane * 3 +\r\nctx->sata_param.speed[lane]]);\r\nval = RXTX_REG125_PQ_REG_SET(val,\r\nctx->sata_param.txeyetuning[lane * 3 +\r\nctx->sata_param.speed[lane]]);\r\nval = RXTX_REG125_PHZ_MANUAL_SET(val, 0x1);\r\nserdes_wr(ctx, lane, RXTX_REG125, val);\r\nserdes_rd(ctx, lane, RXTX_REG127, &val);\r\nval = RXTX_REG127_LATCH_MAN_CAL_ENA_SET(val, 0x0);\r\nserdes_wr(ctx, lane, RXTX_REG127, val);\r\nserdes_rd(ctx, lane, RXTX_REG128, &val);\r\nval = RXTX_REG128_LATCH_CAL_WAIT_SEL_SET(val, 0x3);\r\nserdes_wr(ctx, lane, RXTX_REG128, val);\r\nserdes_rd(ctx, lane, RXTX_REG145, &val);\r\nval = RXTX_REG145_RXDFE_CONFIG_SET(val, 0x3);\r\nval = RXTX_REG145_TX_IDLE_SATA_SET(val, 0x0);\r\nif (preA3Chip) {\r\nval = RXTX_REG145_RXES_ENA_SET(val, 0x1);\r\nval = RXTX_REG145_RXVWES_LATENA_SET(val, 0x1);\r\n} else {\r\nval = RXTX_REG145_RXES_ENA_SET(val, 0x0);\r\nval = RXTX_REG145_RXVWES_LATENA_SET(val, 0x0);\r\n}\r\nserdes_wr(ctx, lane, RXTX_REG145, val);\r\nfor (i = 0; i < 4; i++) {\r\nreg = RXTX_REG148 + i * 2;\r\nserdes_wr(ctx, lane, reg, 0xFFFF);\r\n}\r\n}\r\n}\r\nstatic int xgene_phy_cal_rdy_chk(struct xgene_phy_ctx *ctx,\r\nenum cmu_type_t cmu_type,\r\nenum clk_type_t clk_type)\r\n{\r\nvoid __iomem *csr_serdes = ctx->sds_base;\r\nint loop;\r\nu32 val;\r\nwritel(0xdf, csr_serdes + SATA_ENET_SDS_RST_CTL);\r\nreadl(csr_serdes + SATA_ENET_SDS_RST_CTL);\r\nif (cmu_type != REF_CMU) {\r\ncmu_setbits(ctx, cmu_type, CMU_REG5, CMU_REG5_PLL_RESETB_MASK);\r\nusleep_range(800, 1000);\r\ncmu_rd(ctx, cmu_type, CMU_REG1, &val);\r\nval = CMU_REG1_PLL_MANUALCAL_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG1, val);\r\nusleep_range(800, 1000);\r\ncmu_toggle1to0(ctx, cmu_type, CMU_REG32,\r\nCMU_REG32_FORCE_VCOCAL_START_MASK);\r\nusleep_range(800, 1000);\r\n}\r\nif (!preA3Chip)\r\ngoto skip_manual_cal;\r\ncmu_rd(ctx, cmu_type, CMU_REG17, &val);\r\nval = CMU_REG17_PVT_CODE_R2A_SET(val, 0x12);\r\nval = CMU_REG17_RESERVED_7_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG17, val);\r\ncmu_toggle1to0(ctx, cmu_type, CMU_REG17,\r\nCMU_REG17_PVT_TERM_MAN_ENA_MASK);\r\ncmu_rd(ctx, cmu_type, CMU_REG17, &val);\r\nval = CMU_REG17_PVT_CODE_R2A_SET(val, 0x29);\r\nval = CMU_REG17_RESERVED_7_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG17, val);\r\ncmu_toggle1to0(ctx, cmu_type, CMU_REG16,\r\nCMU_REG16_PVT_DN_MAN_ENA_MASK);\r\ncmu_rd(ctx, cmu_type, CMU_REG17, &val);\r\nval = CMU_REG17_PVT_CODE_R2A_SET(val, 0x28);\r\nval = CMU_REG17_RESERVED_7_SET(val, 0x0);\r\ncmu_wr(ctx, cmu_type, CMU_REG17, val);\r\ncmu_toggle1to0(ctx, cmu_type, CMU_REG16,\r\nCMU_REG16_PVT_UP_MAN_ENA_MASK);\r\nskip_manual_cal:\r\nloop = 100;\r\ndo {\r\ncmu_rd(ctx, cmu_type, CMU_REG7, &val);\r\nif (CMU_REG7_PLL_CALIB_DONE_RD(val))\r\nbreak;\r\nusleep_range(10, 100);\r\n} while (--loop > 0);\r\ncmu_rd(ctx, cmu_type, CMU_REG7, &val);\r\ndev_dbg(ctx->dev, "PLL calibration %s\n",\r\nCMU_REG7_PLL_CALIB_DONE_RD(val) ? "done" : "failed");\r\nif (CMU_REG7_VCO_CAL_FAIL_RD(val)) {\r\ndev_err(ctx->dev,\r\n"PLL calibration failed due to VCO failure\n");\r\nreturn -1;\r\n}\r\ndev_dbg(ctx->dev, "PLL calibration successful\n");\r\ncmu_rd(ctx, cmu_type, CMU_REG15, &val);\r\ndev_dbg(ctx->dev, "PHY Tx is %sready\n", val & 0x300 ? "" : "not ");\r\nreturn 0;\r\n}\r\nstatic void xgene_phy_pdwn_force_vco(struct xgene_phy_ctx *ctx,\r\nenum cmu_type_t cmu_type,\r\nenum clk_type_t clk_type)\r\n{\r\nu32 val;\r\ndev_dbg(ctx->dev, "Reset VCO and re-start again\n");\r\nif (cmu_type == PHY_CMU) {\r\ncmu_rd(ctx, cmu_type, CMU_REG16, &val);\r\nval = CMU_REG16_VCOCAL_WAIT_BTW_CODE_SET(val, 0x7);\r\ncmu_wr(ctx, cmu_type, CMU_REG16, val);\r\n}\r\ncmu_toggle1to0(ctx, cmu_type, CMU_REG0, CMU_REG0_PDOWN_MASK);\r\ncmu_toggle1to0(ctx, cmu_type, CMU_REG32,\r\nCMU_REG32_FORCE_VCOCAL_START_MASK);\r\n}\r\nstatic int xgene_phy_hw_init_sata(struct xgene_phy_ctx *ctx,\r\nenum clk_type_t clk_type, int ssc_enable)\r\n{\r\nvoid __iomem *sds_base = ctx->sds_base;\r\nu32 val;\r\nint i;\r\ndev_dbg(ctx->dev, "Reset PHY\n");\r\nwritel(0x0, sds_base + SATA_ENET_SDS_RST_CTL);\r\nval = readl(sds_base + SATA_ENET_SDS_RST_CTL);\r\nwritel(0x20, sds_base + SATA_ENET_SDS_RST_CTL);\r\nreadl(sds_base + SATA_ENET_SDS_RST_CTL);\r\nwritel(0xde, sds_base + SATA_ENET_SDS_RST_CTL);\r\nreadl(sds_base + SATA_ENET_SDS_RST_CTL);\r\nval = readl(sds_base + SATA_ENET_SDS_CTL1);\r\nval = CFG_I_SPD_SEL_CDR_OVR1_SET(val,\r\nctx->sata_param.txspeed[ctx->sata_param.speed[0]]);\r\nwritel(val, sds_base + SATA_ENET_SDS_CTL1);\r\ndev_dbg(ctx->dev, "Set the customer pin mode to SATA\n");\r\nval = readl(sds_base + SATA_ENET_SDS_CTL0);\r\nval = REGSPEC_CFG_I_CUSTOMER_PIN_MODE0_SET(val, 0x4421);\r\nwritel(val, sds_base + SATA_ENET_SDS_CTL0);\r\nxgene_phy_cfg_cmu_clk_type(ctx, PHY_CMU, clk_type);\r\nxgene_phy_sata_cfg_cmu_core(ctx, PHY_CMU, clk_type);\r\nif (ssc_enable)\r\nxgene_phy_ssc_enable(ctx, PHY_CMU);\r\nxgene_phy_sata_cfg_lanes(ctx);\r\nval = readl(sds_base + SATA_ENET_SDS_PCS_CTL0);\r\nval = REGSPEC_CFG_I_RX_WORDMODE0_SET(val, 0x3);\r\nval = REGSPEC_CFG_I_TX_WORDMODE0_SET(val, 0x3);\r\nwritel(val, sds_base + SATA_ENET_SDS_PCS_CTL0);\r\ni = 10;\r\ndo {\r\nif (!xgene_phy_cal_rdy_chk(ctx, PHY_CMU, clk_type))\r\nbreak;\r\nxgene_phy_pdwn_force_vco(ctx, PHY_CMU, clk_type);\r\n} while (--i > 0);\r\nif (i <= 0)\r\ndev_err(ctx->dev, "PLL calibration failed\n");\r\nreturn 0;\r\n}\r\nstatic int xgene_phy_hw_initialize(struct xgene_phy_ctx *ctx,\r\nenum clk_type_t clk_type,\r\nint ssc_enable)\r\n{\r\nint rc;\r\ndev_dbg(ctx->dev, "PHY init clk type %d\n", clk_type);\r\nif (ctx->mode == MODE_SATA) {\r\nrc = xgene_phy_hw_init_sata(ctx, clk_type, ssc_enable);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\ndev_err(ctx->dev, "Un-supported customer pin mode %d\n",\r\nctx->mode);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xgene_phy_force_lat_summer_cal(struct xgene_phy_ctx *ctx, int lane)\r\n{\r\nint i;\r\nstruct {\r\nu32 reg;\r\nu32 val;\r\n} serdes_reg[] = {\r\n{RXTX_REG38, 0x0},\r\n{RXTX_REG39, 0xff00},\r\n{RXTX_REG40, 0xffff},\r\n{RXTX_REG41, 0xffff},\r\n{RXTX_REG42, 0xffff},\r\n{RXTX_REG43, 0xffff},\r\n{RXTX_REG44, 0xffff},\r\n{RXTX_REG45, 0xffff},\r\n{RXTX_REG46, 0xffff},\r\n{RXTX_REG47, 0xfffc},\r\n{RXTX_REG48, 0x0},\r\n{RXTX_REG49, 0x0},\r\n{RXTX_REG50, 0x0},\r\n{RXTX_REG51, 0x0},\r\n{RXTX_REG52, 0x0},\r\n{RXTX_REG53, 0x0},\r\n{RXTX_REG54, 0x0},\r\n{RXTX_REG55, 0x0},\r\n};\r\nserdes_setbits(ctx, lane, RXTX_REG127,\r\nRXTX_REG127_FORCE_SUM_CAL_START_MASK);\r\nusleep_range(100, 500);\r\nserdes_clrbits(ctx, lane, RXTX_REG127,\r\nRXTX_REG127_FORCE_SUM_CAL_START_MASK);\r\nusleep_range(100, 500);\r\nserdes_setbits(ctx, lane, RXTX_REG127,\r\nRXTX_REG127_FORCE_LAT_CAL_START_MASK);\r\nusleep_range(100, 500);\r\nserdes_clrbits(ctx, lane, RXTX_REG127,\r\nRXTX_REG127_FORCE_LAT_CAL_START_MASK);\r\nserdes_wr(ctx, lane, RXTX_REG28, 0x7);\r\nserdes_wr(ctx, lane, RXTX_REG31, 0x7e00);\r\nserdes_clrbits(ctx, lane, RXTX_REG4,\r\nRXTX_REG4_TX_LOOPBACK_BUF_EN_MASK);\r\nserdes_clrbits(ctx, lane, RXTX_REG7,\r\nRXTX_REG7_LOOP_BACK_ENA_CTLE_MASK);\r\nfor (i = 0; i < ARRAY_SIZE(serdes_reg); i++)\r\nserdes_wr(ctx, lane, serdes_reg[i].reg,\r\nserdes_reg[i].val);\r\n}\r\nstatic void xgene_phy_reset_rxd(struct xgene_phy_ctx *ctx, int lane)\r\n{\r\nserdes_clrbits(ctx, lane, RXTX_REG7, RXTX_REG7_RESETB_RXD_MASK);\r\nusleep_range(100, 150);\r\nserdes_setbits(ctx, lane, RXTX_REG7, RXTX_REG7_RESETB_RXD_MASK);\r\n}\r\nstatic int xgene_phy_get_avg(int accum, int samples)\r\n{\r\nreturn (accum + (samples / 2)) / samples;\r\n}\r\nstatic void xgene_phy_gen_avg_val(struct xgene_phy_ctx *ctx, int lane)\r\n{\r\nint max_loop = 10;\r\nint avg_loop = 0;\r\nint lat_do = 0, lat_xo = 0, lat_eo = 0, lat_so = 0;\r\nint lat_de = 0, lat_xe = 0, lat_ee = 0, lat_se = 0;\r\nint sum_cal = 0;\r\nint lat_do_itr, lat_xo_itr, lat_eo_itr, lat_so_itr;\r\nint lat_de_itr, lat_xe_itr, lat_ee_itr, lat_se_itr;\r\nint sum_cal_itr;\r\nint fail_even;\r\nint fail_odd;\r\nu32 val;\r\ndev_dbg(ctx->dev, "Generating avg calibration value for lane %d\n",\r\nlane);\r\nserdes_setbits(ctx, lane, RXTX_REG12,\r\nRXTX_REG12_RX_DET_TERM_ENABLE_MASK);\r\nserdes_wr(ctx, lane, RXTX_REG28, 0x0000);\r\nserdes_wr(ctx, lane, RXTX_REG31, 0x0000);\r\nwhile (avg_loop < max_loop) {\r\nxgene_phy_force_lat_summer_cal(ctx, lane);\r\nserdes_rd(ctx, lane, RXTX_REG21, &val);\r\nlat_do_itr = RXTX_REG21_DO_LATCH_CALOUT_RD(val);\r\nlat_xo_itr = RXTX_REG21_XO_LATCH_CALOUT_RD(val);\r\nfail_odd = RXTX_REG21_LATCH_CAL_FAIL_ODD_RD(val);\r\nserdes_rd(ctx, lane, RXTX_REG22, &val);\r\nlat_eo_itr = RXTX_REG22_EO_LATCH_CALOUT_RD(val);\r\nlat_so_itr = RXTX_REG22_SO_LATCH_CALOUT_RD(val);\r\nfail_even = RXTX_REG22_LATCH_CAL_FAIL_EVEN_RD(val);\r\nserdes_rd(ctx, lane, RXTX_REG23, &val);\r\nlat_de_itr = RXTX_REG23_DE_LATCH_CALOUT_RD(val);\r\nlat_xe_itr = RXTX_REG23_XE_LATCH_CALOUT_RD(val);\r\nserdes_rd(ctx, lane, RXTX_REG24, &val);\r\nlat_ee_itr = RXTX_REG24_EE_LATCH_CALOUT_RD(val);\r\nlat_se_itr = RXTX_REG24_SE_LATCH_CALOUT_RD(val);\r\nserdes_rd(ctx, lane, RXTX_REG121, &val);\r\nsum_cal_itr = RXTX_REG121_SUMOS_CAL_CODE_RD(val);\r\nif ((fail_even == 0 || fail_even == 1) &&\r\n(fail_odd == 0 || fail_odd == 1)) {\r\nlat_do += lat_do_itr;\r\nlat_xo += lat_xo_itr;\r\nlat_eo += lat_eo_itr;\r\nlat_so += lat_so_itr;\r\nlat_de += lat_de_itr;\r\nlat_xe += lat_xe_itr;\r\nlat_ee += lat_ee_itr;\r\nlat_se += lat_se_itr;\r\nsum_cal += sum_cal_itr;\r\ndev_dbg(ctx->dev, "Iteration %d:\n", avg_loop);\r\ndev_dbg(ctx->dev, "DO 0x%x XO 0x%x EO 0x%x SO 0x%x\n",\r\nlat_do_itr, lat_xo_itr, lat_eo_itr,\r\nlat_so_itr);\r\ndev_dbg(ctx->dev, "DE 0x%x XE 0x%x EE 0x%x SE 0x%x\n",\r\nlat_de_itr, lat_xe_itr, lat_ee_itr,\r\nlat_se_itr);\r\ndev_dbg(ctx->dev, "SUM 0x%x\n", sum_cal_itr);\r\n++avg_loop;\r\n} else {\r\ndev_err(ctx->dev,\r\n"Receiver calibration failed at %d loop\n",\r\navg_loop);\r\n}\r\nxgene_phy_reset_rxd(ctx, lane);\r\n}\r\nserdes_rd(ctx, lane, RXTX_REG127, &val);\r\nval = RXTX_REG127_DO_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_do, max_loop));\r\nval = RXTX_REG127_XO_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_xo, max_loop));\r\nserdes_wr(ctx, lane, RXTX_REG127, val);\r\nserdes_rd(ctx, lane, RXTX_REG128, &val);\r\nval = RXTX_REG128_EO_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_eo, max_loop));\r\nval = RXTX_REG128_SO_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_so, max_loop));\r\nserdes_wr(ctx, lane, RXTX_REG128, val);\r\nserdes_rd(ctx, lane, RXTX_REG129, &val);\r\nval = RXTX_REG129_DE_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_de, max_loop));\r\nval = RXTX_REG129_XE_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_xe, max_loop));\r\nserdes_wr(ctx, lane, RXTX_REG129, val);\r\nserdes_rd(ctx, lane, RXTX_REG130, &val);\r\nval = RXTX_REG130_EE_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_ee, max_loop));\r\nval = RXTX_REG130_SE_LATCH_MANCAL_SET(val,\r\nxgene_phy_get_avg(lat_se, max_loop));\r\nserdes_wr(ctx, lane, RXTX_REG130, val);\r\nserdes_rd(ctx, lane, RXTX_REG14, &val);\r\nval = RXTX_REG14_CLTE_LATCAL_MAN_PROG_SET(val,\r\nxgene_phy_get_avg(sum_cal, max_loop));\r\nserdes_wr(ctx, lane, RXTX_REG14, val);\r\ndev_dbg(ctx->dev, "Average Value:\n");\r\ndev_dbg(ctx->dev, "DO 0x%x XO 0x%x EO 0x%x SO 0x%x\n",\r\nxgene_phy_get_avg(lat_do, max_loop),\r\nxgene_phy_get_avg(lat_xo, max_loop),\r\nxgene_phy_get_avg(lat_eo, max_loop),\r\nxgene_phy_get_avg(lat_so, max_loop));\r\ndev_dbg(ctx->dev, "DE 0x%x XE 0x%x EE 0x%x SE 0x%x\n",\r\nxgene_phy_get_avg(lat_de, max_loop),\r\nxgene_phy_get_avg(lat_xe, max_loop),\r\nxgene_phy_get_avg(lat_ee, max_loop),\r\nxgene_phy_get_avg(lat_se, max_loop));\r\ndev_dbg(ctx->dev, "SUM 0x%x\n",\r\nxgene_phy_get_avg(sum_cal, max_loop));\r\nserdes_rd(ctx, lane, RXTX_REG14, &val);\r\nval = RXTX_REG14_CTLE_LATCAL_MAN_ENA_SET(val, 0x1);\r\nserdes_wr(ctx, lane, RXTX_REG14, val);\r\ndev_dbg(ctx->dev, "Enable Manual Summer calibration\n");\r\nserdes_rd(ctx, lane, RXTX_REG127, &val);\r\nval = RXTX_REG127_LATCH_MAN_CAL_ENA_SET(val, 0x1);\r\ndev_dbg(ctx->dev, "Enable Manual Latch calibration\n");\r\nserdes_wr(ctx, lane, RXTX_REG127, val);\r\nserdes_rd(ctx, lane, RXTX_REG12, &val);\r\nval = RXTX_REG12_RX_DET_TERM_ENABLE_SET(val, 0);\r\nserdes_wr(ctx, lane, RXTX_REG12, val);\r\nserdes_wr(ctx, lane, RXTX_REG28, 0x0007);\r\nserdes_wr(ctx, lane, RXTX_REG31, 0x7e00);\r\n}\r\nstatic int xgene_phy_hw_init(struct phy *phy)\r\n{\r\nstruct xgene_phy_ctx *ctx = phy_get_drvdata(phy);\r\nint rc;\r\nint i;\r\nrc = xgene_phy_hw_initialize(ctx, CLK_EXT_DIFF, SSC_DISABLE);\r\nif (rc) {\r\ndev_err(ctx->dev, "PHY initialize failed %d\n", rc);\r\nreturn rc;\r\n}\r\nif (!IS_ERR(ctx->clk)) {\r\nclk_prepare_enable(ctx->clk);\r\nclk_disable_unprepare(ctx->clk);\r\nclk_prepare_enable(ctx->clk);\r\n}\r\nfor (i = 0; i < MAX_LANE; i++)\r\nxgene_phy_gen_avg_val(ctx, i);\r\ndev_dbg(ctx->dev, "PHY initialized\n");\r\nreturn 0;\r\n}\r\nstatic struct phy *xgene_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct xgene_phy_ctx *ctx = dev_get_drvdata(dev);\r\nif (args->args_count <= 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (args->args[0] < MODE_SATA || args->args[0] >= MODE_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nctx->mode = args->args[0];\r\nreturn ctx->phy;\r\n}\r\nstatic void xgene_phy_get_param(struct platform_device *pdev,\r\nconst char *name, u32 *buffer,\r\nint count, u32 *default_val,\r\nu32 conv_factor)\r\n{\r\nint i;\r\nif (!of_property_read_u32_array(pdev->dev.of_node, name, buffer,\r\ncount)) {\r\nfor (i = 0; i < count; i++)\r\nbuffer[i] /= conv_factor;\r\nreturn;\r\n}\r\nfor (i = 0; i < count; i++)\r\nbuffer[i] = default_val[i % 3];\r\n}\r\nstatic int xgene_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct phy_provider *phy_provider;\r\nstruct xgene_phy_ctx *ctx;\r\nstruct resource *res;\r\nu32 default_spd[] = DEFAULT_SATA_SPD_SEL;\r\nu32 default_txboost_gain[] = DEFAULT_SATA_TXBOOST_GAIN;\r\nu32 default_txeye_direction[] = DEFAULT_SATA_TXEYEDIRECTION;\r\nu32 default_txeye_tuning[] = DEFAULT_SATA_TXEYETUNING;\r\nu32 default_txamp[] = DEFAULT_SATA_TXAMP;\r\nu32 default_txcn1[] = DEFAULT_SATA_TXCN1;\r\nu32 default_txcn2[] = DEFAULT_SATA_TXCN2;\r\nu32 default_txcp1[] = DEFAULT_SATA_TXCP1;\r\nint i;\r\nctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nctx->sds_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ctx->sds_base))\r\nreturn PTR_ERR(ctx->sds_base);\r\nctx->clk = clk_get(&pdev->dev, NULL);\r\nxgene_phy_get_param(pdev, "apm,tx-eye-tuning",\r\nctx->sata_param.txeyetuning, 6, default_txeye_tuning, 1);\r\nxgene_phy_get_param(pdev, "apm,tx-eye-direction",\r\nctx->sata_param.txeyedirection, 6, default_txeye_direction, 1);\r\nxgene_phy_get_param(pdev, "apm,tx-boost-gain",\r\nctx->sata_param.txboostgain, 6, default_txboost_gain, 1);\r\nxgene_phy_get_param(pdev, "apm,tx-amplitude",\r\nctx->sata_param.txamplitude, 6, default_txamp, 13300);\r\nxgene_phy_get_param(pdev, "apm,tx-pre-cursor1",\r\nctx->sata_param.txprecursor_cn1, 6, default_txcn1, 18200);\r\nxgene_phy_get_param(pdev, "apm,tx-pre-cursor2",\r\nctx->sata_param.txprecursor_cn2, 6, default_txcn2, 18200);\r\nxgene_phy_get_param(pdev, "apm,tx-post-cursor",\r\nctx->sata_param.txpostcursor_cp1, 6, default_txcp1, 18200);\r\nxgene_phy_get_param(pdev, "apm,tx-speed",\r\nctx->sata_param.txspeed, 3, default_spd, 1);\r\nfor (i = 0; i < MAX_LANE; i++)\r\nctx->sata_param.speed[i] = 2;\r\nplatform_set_drvdata(pdev, ctx);\r\nctx->phy = devm_phy_create(ctx->dev, NULL, &xgene_phy_ops);\r\nif (IS_ERR(ctx->phy)) {\r\ndev_dbg(&pdev->dev, "Failed to create PHY\n");\r\nreturn PTR_ERR(ctx->phy);\r\n}\r\nphy_set_drvdata(ctx->phy, ctx);\r\nphy_provider = devm_of_phy_provider_register(ctx->dev, xgene_phy_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
