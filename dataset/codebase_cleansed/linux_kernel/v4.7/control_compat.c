static int snd_ctl_elem_list_compat(struct snd_card *card,\r\nstruct snd_ctl_elem_list32 __user *data32)\r\n{\r\nstruct snd_ctl_elem_list __user *data;\r\ncompat_caddr_t ptr;\r\nint err;\r\ndata = compat_alloc_user_space(sizeof(*data));\r\nif (copy_in_user(data, data32, 4 * sizeof(u32)))\r\nreturn -EFAULT;\r\nif (get_user(ptr, &data32->pids) ||\r\nput_user(compat_ptr(ptr), &data->pids))\r\nreturn -EFAULT;\r\nerr = snd_ctl_elem_list(card, data);\r\nif (err < 0)\r\nreturn err;\r\nif (copy_in_user(data32, data, 4 * sizeof(u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_ctl_elem_info_compat(struct snd_ctl_file *ctl,\r\nstruct snd_ctl_elem_info32 __user *data32)\r\n{\r\nstruct snd_ctl_elem_info *data;\r\nint err;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (! data)\r\nreturn -ENOMEM;\r\nerr = -EFAULT;\r\nif (copy_from_user(&data->id, &data32->id, sizeof(data->id)))\r\ngoto error;\r\nif (get_user(data->value.enumerated.item, &data32->value.enumerated.item))\r\ngoto error;\r\nsnd_power_lock(ctl->card);\r\nerr = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\r\nif (err >= 0)\r\nerr = snd_ctl_elem_info(ctl, data);\r\nsnd_power_unlock(ctl->card);\r\nif (err < 0)\r\ngoto error;\r\nerr = -EFAULT;\r\nif (copy_to_user(&data32->id, &data->id, sizeof(data->id)) ||\r\ncopy_to_user(&data32->type, &data->type, 3 * sizeof(u32)))\r\ngoto error;\r\nif (put_user(data->owner, &data32->owner))\r\ngoto error;\r\nswitch (data->type) {\r\ncase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\r\ncase SNDRV_CTL_ELEM_TYPE_INTEGER:\r\nif (put_user(data->value.integer.min, &data32->value.integer.min) ||\r\nput_user(data->value.integer.max, &data32->value.integer.max) ||\r\nput_user(data->value.integer.step, &data32->value.integer.step))\r\ngoto error;\r\nbreak;\r\ncase SNDRV_CTL_ELEM_TYPE_INTEGER64:\r\nif (copy_to_user(&data32->value.integer64,\r\n&data->value.integer64,\r\nsizeof(data->value.integer64)))\r\ngoto error;\r\nbreak;\r\ncase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\r\nif (copy_to_user(&data32->value.enumerated,\r\n&data->value.enumerated,\r\nsizeof(data->value.enumerated)))\r\ngoto error;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr = 0;\r\nerror:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int get_ctl_type(struct snd_card *card, struct snd_ctl_elem_id *id,\r\nint *countp)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_ctl_elem_info *info;\r\nint err;\r\ndown_read(&card->controls_rwsem);\r\nkctl = snd_ctl_find_id(card, id);\r\nif (! kctl) {\r\nup_read(&card->controls_rwsem);\r\nreturn -ENOENT;\r\n}\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) {\r\nup_read(&card->controls_rwsem);\r\nreturn -ENOMEM;\r\n}\r\ninfo->id = *id;\r\nerr = kctl->info(kctl, info);\r\nup_read(&card->controls_rwsem);\r\nif (err >= 0) {\r\nerr = info->type;\r\n*countp = info->count;\r\n}\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic int get_elem_size(int type, int count)\r\n{\r\nswitch (type) {\r\ncase SNDRV_CTL_ELEM_TYPE_INTEGER64:\r\nreturn sizeof(s64) * count;\r\ncase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\r\nreturn sizeof(int) * count;\r\ncase SNDRV_CTL_ELEM_TYPE_BYTES:\r\nreturn 512;\r\ncase SNDRV_CTL_ELEM_TYPE_IEC958:\r\nreturn sizeof(struct snd_aes_iec958);\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic int copy_ctl_value_from_user(struct snd_card *card,\r\nstruct snd_ctl_elem_value *data,\r\nvoid __user *userdata,\r\nvoid __user *valuep,\r\nint *typep, int *countp)\r\n{\r\nstruct snd_ctl_elem_value32 __user *data32 = userdata;\r\nint i, type, size;\r\nint uninitialized_var(count);\r\nunsigned int indirect;\r\nif (copy_from_user(&data->id, &data32->id, sizeof(data->id)))\r\nreturn -EFAULT;\r\nif (get_user(indirect, &data32->indirect))\r\nreturn -EFAULT;\r\nif (indirect)\r\nreturn -EINVAL;\r\ntype = get_ctl_type(card, &data->id, &count);\r\nif (type < 0)\r\nreturn type;\r\nif (type == SNDRV_CTL_ELEM_TYPE_BOOLEAN ||\r\ntype == SNDRV_CTL_ELEM_TYPE_INTEGER) {\r\nfor (i = 0; i < count; i++) {\r\ns32 __user *intp = valuep;\r\nint val;\r\nif (get_user(val, &intp[i]))\r\nreturn -EFAULT;\r\ndata->value.integer.value[i] = val;\r\n}\r\n} else {\r\nsize = get_elem_size(type, count);\r\nif (size < 0) {\r\ndev_err(card->dev, "snd_ioctl32_ctl_elem_value: unknown type %d\n", type);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(data->value.bytes.data, valuep, size))\r\nreturn -EFAULT;\r\n}\r\n*typep = type;\r\n*countp = count;\r\nreturn 0;\r\n}\r\nstatic int copy_ctl_value_to_user(void __user *userdata,\r\nvoid __user *valuep,\r\nstruct snd_ctl_elem_value *data,\r\nint type, int count)\r\n{\r\nint i, size;\r\nif (type == SNDRV_CTL_ELEM_TYPE_BOOLEAN ||\r\ntype == SNDRV_CTL_ELEM_TYPE_INTEGER) {\r\nfor (i = 0; i < count; i++) {\r\ns32 __user *intp = valuep;\r\nint val;\r\nval = data->value.integer.value[i];\r\nif (put_user(val, &intp[i]))\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nsize = get_elem_size(type, count);\r\nif (copy_to_user(valuep, data->value.bytes.data, size))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctl_elem_read_user(struct snd_card *card,\r\nvoid __user *userdata, void __user *valuep)\r\n{\r\nstruct snd_ctl_elem_value *data;\r\nint err, type, count;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nerr = copy_ctl_value_from_user(card, data, userdata, valuep,\r\n&type, &count);\r\nif (err < 0)\r\ngoto error;\r\nsnd_power_lock(card);\r\nerr = snd_power_wait(card, SNDRV_CTL_POWER_D0);\r\nif (err >= 0)\r\nerr = snd_ctl_elem_read(card, data);\r\nsnd_power_unlock(card);\r\nif (err >= 0)\r\nerr = copy_ctl_value_to_user(userdata, valuep, data,\r\ntype, count);\r\nerror:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int ctl_elem_write_user(struct snd_ctl_file *file,\r\nvoid __user *userdata, void __user *valuep)\r\n{\r\nstruct snd_ctl_elem_value *data;\r\nstruct snd_card *card = file->card;\r\nint err, type, count;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nerr = copy_ctl_value_from_user(card, data, userdata, valuep,\r\n&type, &count);\r\nif (err < 0)\r\ngoto error;\r\nsnd_power_lock(card);\r\nerr = snd_power_wait(card, SNDRV_CTL_POWER_D0);\r\nif (err >= 0)\r\nerr = snd_ctl_elem_write(card, file, data);\r\nsnd_power_unlock(card);\r\nif (err >= 0)\r\nerr = copy_ctl_value_to_user(userdata, valuep, data,\r\ntype, count);\r\nerror:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int snd_ctl_elem_read_user_compat(struct snd_card *card,\r\nstruct snd_ctl_elem_value32 __user *data32)\r\n{\r\nreturn ctl_elem_read_user(card, data32, &data32->value);\r\n}\r\nstatic int snd_ctl_elem_write_user_compat(struct snd_ctl_file *file,\r\nstruct snd_ctl_elem_value32 __user *data32)\r\n{\r\nreturn ctl_elem_write_user(file, data32, &data32->value);\r\n}\r\nstatic int snd_ctl_elem_read_user_x32(struct snd_card *card,\r\nstruct snd_ctl_elem_value_x32 __user *data32)\r\n{\r\nreturn ctl_elem_read_user(card, data32, &data32->value);\r\n}\r\nstatic int snd_ctl_elem_write_user_x32(struct snd_ctl_file *file,\r\nstruct snd_ctl_elem_value_x32 __user *data32)\r\n{\r\nreturn ctl_elem_write_user(file, data32, &data32->value);\r\n}\r\nstatic int snd_ctl_elem_add_compat(struct snd_ctl_file *file,\r\nstruct snd_ctl_elem_info32 __user *data32,\r\nint replace)\r\n{\r\nstruct snd_ctl_elem_info *data;\r\nint err;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (! data)\r\nreturn -ENOMEM;\r\nerr = -EFAULT;\r\n\\r\nif (copy_from_user(&data->id, &data32->id, sizeof(data->id)) ||\r\ncopy_from_user(&data->type, &data32->type, 3 * sizeof(u32)))\r\ngoto error;\r\nif (get_user(data->owner, &data32->owner) ||\r\nget_user(data->type, &data32->type))\r\ngoto error;\r\nswitch (data->type) {\r\ncase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\r\ncase SNDRV_CTL_ELEM_TYPE_INTEGER:\r\nif (get_user(data->value.integer.min, &data32->value.integer.min) ||\r\nget_user(data->value.integer.max, &data32->value.integer.max) ||\r\nget_user(data->value.integer.step, &data32->value.integer.step))\r\ngoto error;\r\nbreak;\r\ncase SNDRV_CTL_ELEM_TYPE_INTEGER64:\r\nif (copy_from_user(&data->value.integer64,\r\n&data32->value.integer64,\r\nsizeof(data->value.integer64)))\r\ngoto error;\r\nbreak;\r\ncase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\r\nif (copy_from_user(&data->value.enumerated,\r\n&data32->value.enumerated,\r\nsizeof(data->value.enumerated)))\r\ngoto error;\r\ndata->value.enumerated.names_ptr =\r\n(uintptr_t)compat_ptr(data->value.enumerated.names_ptr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr = snd_ctl_elem_add(file, data, replace);\r\nerror:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic inline long snd_ctl_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_ctl_file *ctl;\r\nstruct snd_kctl_ioctl *p;\r\nvoid __user *argp = compat_ptr(arg);\r\nint err;\r\nctl = file->private_data;\r\nif (snd_BUG_ON(!ctl || !ctl->card))\r\nreturn -ENXIO;\r\nswitch (cmd) {\r\ncase SNDRV_CTL_IOCTL_PVERSION:\r\ncase SNDRV_CTL_IOCTL_CARD_INFO:\r\ncase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\r\ncase SNDRV_CTL_IOCTL_POWER:\r\ncase SNDRV_CTL_IOCTL_POWER_STATE:\r\ncase SNDRV_CTL_IOCTL_ELEM_LOCK:\r\ncase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\r\ncase SNDRV_CTL_IOCTL_ELEM_REMOVE:\r\ncase SNDRV_CTL_IOCTL_TLV_READ:\r\ncase SNDRV_CTL_IOCTL_TLV_WRITE:\r\ncase SNDRV_CTL_IOCTL_TLV_COMMAND:\r\nreturn snd_ctl_ioctl(file, cmd, (unsigned long)argp);\r\ncase SNDRV_CTL_IOCTL_ELEM_LIST32:\r\nreturn snd_ctl_elem_list_compat(ctl->card, argp);\r\ncase SNDRV_CTL_IOCTL_ELEM_INFO32:\r\nreturn snd_ctl_elem_info_compat(ctl, argp);\r\ncase SNDRV_CTL_IOCTL_ELEM_READ32:\r\nreturn snd_ctl_elem_read_user_compat(ctl->card, argp);\r\ncase SNDRV_CTL_IOCTL_ELEM_WRITE32:\r\nreturn snd_ctl_elem_write_user_compat(ctl, argp);\r\ncase SNDRV_CTL_IOCTL_ELEM_ADD32:\r\nreturn snd_ctl_elem_add_compat(ctl, argp, 0);\r\ncase SNDRV_CTL_IOCTL_ELEM_REPLACE32:\r\nreturn snd_ctl_elem_add_compat(ctl, argp, 1);\r\n#ifdef CONFIG_X86_X32\r\ncase SNDRV_CTL_IOCTL_ELEM_READ_X32:\r\nreturn snd_ctl_elem_read_user_x32(ctl->card, argp);\r\ncase SNDRV_CTL_IOCTL_ELEM_WRITE_X32:\r\nreturn snd_ctl_elem_write_user_x32(ctl, argp);\r\n#endif\r\n}\r\ndown_read(&snd_ioctl_rwsem);\r\nlist_for_each_entry(p, &snd_control_compat_ioctls, list) {\r\nif (p->fioctl) {\r\nerr = p->fioctl(ctl->card, ctl, cmd, arg);\r\nif (err != -ENOIOCTLCMD) {\r\nup_read(&snd_ioctl_rwsem);\r\nreturn err;\r\n}\r\n}\r\n}\r\nup_read(&snd_ioctl_rwsem);\r\nreturn -ENOIOCTLCMD;\r\n}
