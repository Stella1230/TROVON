void smt_pmf_received_pack(struct s_smc *smc, SMbuf *mb, int local)\r\n{\r\nstruct smt_header *sm ;\r\nSMbuf *reply ;\r\nsm = smtod(mb,struct smt_header *) ;\r\nDB_SMT("SMT: processing PMF frame at %x len %d\n",sm,mb->sm_len) ;\r\n#ifdef DEBUG\r\ndump_smt(smc,sm,"PMF Received") ;\r\n#endif\r\nsmt_start_watchdog(smc) ;\r\nif (sm->smt_class == SMT_PMF_GET ||\r\nsm->smt_class == SMT_PMF_SET) {\r\nreply = smt_build_pmf_response(smc,sm,\r\nsm->smt_class == SMT_PMF_SET,local) ;\r\nif (reply) {\r\nsm = smtod(reply,struct smt_header *) ;\r\n#ifdef DEBUG\r\ndump_smt(smc,sm,"PMF Reply") ;\r\n#endif\r\nsmt_send_frame(smc,reply,FC_SMT_INFO,local) ;\r\n}\r\n}\r\n}\r\nstatic SMbuf *smt_build_pmf_response(struct s_smc *smc, struct smt_header *req,\r\nint set, int local)\r\n{\r\nSMbuf *mb ;\r\nstruct smt_header *smt ;\r\nstruct smt_para *pa ;\r\nstruct smt_p_reason *res ;\r\nconst struct s_p_tab *pt ;\r\nint len ;\r\nint index ;\r\nint idx_end ;\r\nint error ;\r\nint range ;\r\nSK_LOC_DECL(struct s_pcon,pcon) ;\r\nSK_LOC_DECL(struct s_pcon,set_pcon) ;\r\nif (!(mb = smt_get_mbuf(smc)))\r\nreturn mb;\r\nsmt = smtod(mb, struct smt_header *) ;\r\nsmt->smt_dest = req->smt_source ;\r\nsmt->smt_class = req->smt_class ;\r\nsmt->smt_type = SMT_REPLY ;\r\nsmt->smt_version = SMT_VID_2 ;\r\nsmt->smt_tid = req->smt_tid ;\r\nsmt->smt_pad = 0 ;\r\nsmt->smt_len = 0 ;\r\npcon.pc_len = SMT_MAX_INFO_LEN ;\r\npcon.pc_err = 0 ;\r\npcon.pc_badset = 0 ;\r\npcon.pc_p = (void *) (smt + 1) ;\r\nerror = 0 ;\r\nif (set) {\r\nif (!local && smt_authorize(smc,req))\r\nerror = SMT_RDF_AUTHOR ;\r\nelse if (smt_check_set_count(smc,req))\r\npcon.pc_badset = SMT_RDF_BADSET ;\r\n}\r\nres = (struct smt_p_reason *) pcon.pc_p ;\r\nsmt_add_para(smc,&pcon,(u_short) SMT_P_REASON,0,0) ;\r\nsmt_add_para(smc,&pcon,(u_short) SMT_P1033,0,0) ;\r\nset_pcon = pcon ;\r\nsmt_add_para(smc,&pcon,(u_short) SMT_P1035,0,0) ;\r\nsmt_add_para(smc,&pcon,(u_short) SMT_P1036,0,0) ;\r\npcon.pc_err = error ;\r\nlen = req->smt_len ;\r\npa = (struct smt_para *) (req + 1) ;\r\nwhile (!pcon.pc_err && len > 0 ) {\r\nif (((u_short)len < pa->p_len + PARA_LEN) || (pa->p_len & 3)) {\r\npcon.pc_err = SMT_RDF_LENGTH ;\r\nbreak ;\r\n}\r\nif (((range = (pa->p_type & 0xf000)) == 0x2000) ||\r\nrange == 0x3000 || range == 0x4000) {\r\nindex = *((u_char *)pa + PARA_LEN + 3) ;\r\nidx_end = index ;\r\nif (!set && (pa->p_len != 4)) {\r\npcon.pc_err = SMT_RDF_LENGTH ;\r\nbreak ;\r\n}\r\nif (!index && !set) {\r\nswitch (range) {\r\ncase 0x2000 :\r\nindex = INDEX_MAC ;\r\nidx_end = index - 1 + NUMMACS ;\r\nbreak ;\r\ncase 0x3000 :\r\nindex = INDEX_PATH ;\r\nidx_end = index - 1 + NUMPATHS ;\r\nbreak ;\r\ncase 0x4000 :\r\nindex = INDEX_PORT ;\r\nidx_end = index - 1 + NUMPHYS ;\r\n#ifndef CONCENTRATOR\r\nif (smc->s.sas == SMT_SAS)\r\nidx_end = INDEX_PORT ;\r\n#endif\r\nbreak ;\r\n}\r\n}\r\n}\r\nelse {\r\nif (!set && (pa->p_len != 0)) {\r\npcon.pc_err = SMT_RDF_LENGTH ;\r\nbreak ;\r\n}\r\nindex = 0 ;\r\nidx_end = 0 ;\r\n}\r\nwhile (index <= idx_end) {\r\npt = smt_get_ptab(pa->p_type) ;\r\nif (pt && pt->p_access == AC_GROUP && !set) {\r\npt++ ;\r\nwhile (pt->p_access == AC_G ||\r\npt->p_access == AC_GR) {\r\nsmt_add_para(smc,&pcon,pt->p_num,\r\nindex,local);\r\npt++ ;\r\n}\r\n}\r\nelse if (pa->p_type != SMT_P_AUTHOR &&\r\n(!set || (pa->p_type != SMT_P1035))) {\r\nint st ;\r\nif (pcon.pc_badset) {\r\nsmt_add_para(smc,&pcon,pa->p_type,\r\nindex,local) ;\r\n}\r\nelse if (set) {\r\nst = smt_set_para(smc,pa,index,local,1);\r\nsmt_add_para(smc,&pcon,pa->p_type,\r\nindex,local) ;\r\npcon.pc_err = st ;\r\n}\r\nelse {\r\nif (pt && pt->p_access == AC_S) {\r\npcon.pc_err =\r\nSMT_RDF_ILLEGAL ;\r\n}\r\nsmt_add_para(smc,&pcon,pa->p_type,\r\nindex,local) ;\r\n}\r\n}\r\nif (pcon.pc_err)\r\nbreak ;\r\nindex++ ;\r\n}\r\nlen -= pa->p_len + PARA_LEN ;\r\npa = (struct smt_para *) ((char *)pa + pa->p_len + PARA_LEN) ;\r\n}\r\nsmt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;\r\nmb->sm_len = smt->smt_len + sizeof(struct smt_header) ;\r\nres->rdf_reason = pcon.pc_badset ? pcon.pc_badset :\r\npcon.pc_err ? pcon.pc_err : SMT_RDF_SUCCESS ;\r\nif (set && (res->rdf_reason == SMT_RDF_SUCCESS)) {\r\nsmc->mib.fddiSMTSetCount.count++ ;\r\nsmt_set_timestamp(smc,smc->mib.fddiSMTSetCount.timestamp) ;\r\nsmc->mib.fddiSMTLastSetStationId = req->smt_sid ;\r\nsmt_add_para(smc,&set_pcon,(u_short) SMT_P1035,0,0) ;\r\nsmt_add_para(smc,&set_pcon,(u_short) SMT_P1036,0,0) ;\r\n}\r\nreturn mb;\r\n}\r\nstatic int smt_authorize(struct s_smc *smc, struct smt_header *sm)\r\n{\r\nstruct smt_para *pa ;\r\nint i ;\r\nchar *p ;\r\np = (char *) &smc->mib.fddiPRPMFStation ;\r\nfor (i = 0 ; i < 8 && !p[i] ; i++)\r\n;\r\nif (i != 8) {\r\nif (memcmp((char *) &sm->smt_sid,\r\n(char *) &smc->mib.fddiPRPMFStation,8))\r\nreturn 1;\r\n}\r\np = (char *) smc->mib.fddiPRPMFPasswd ;\r\nfor (i = 0 ; i < 8 && !p[i] ; i++)\r\n;\r\nif (i != 8) {\r\npa = (struct smt_para *) sm_to_para(smc,sm,SMT_P_AUTHOR) ;\r\nif (!pa)\r\nreturn 1;\r\nif (pa->p_len != 8)\r\nreturn 1;\r\nif (memcmp((char *)(pa+1),(char *)smc->mib.fddiPRPMFPasswd,8))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smt_check_set_count(struct s_smc *smc, struct smt_header *sm)\r\n{\r\nstruct smt_para *pa ;\r\nstruct smt_p_setcount *sc ;\r\npa = (struct smt_para *) sm_to_para(smc,sm,SMT_P1035) ;\r\nif (pa) {\r\nsc = (struct smt_p_setcount *) pa ;\r\nif ((smc->mib.fddiSMTSetCount.count != sc->count) ||\r\nmemcmp((char *) smc->mib.fddiSMTSetCount.timestamp,\r\n(char *)sc->timestamp,8))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para,\r\nint index, int local)\r\n{\r\nstruct smt_para *pa ;\r\nconst struct s_p_tab *pt ;\r\nstruct fddi_mib_m *mib_m = NULL;\r\nstruct fddi_mib_p *mib_p = NULL;\r\nint len ;\r\nint plen ;\r\nchar *from ;\r\nchar *to ;\r\nconst char *swap ;\r\nchar c ;\r\nint range ;\r\nchar *mib_addr ;\r\nint mac ;\r\nint path ;\r\nint port ;\r\nint sp_len ;\r\nif (pcon->pc_err)\r\nreturn ;\r\npt = smt_get_ptab(para) ;\r\nif (pt && pt->p_access == AC_S)\r\nreturn ;\r\nto = (char *) (pcon->pc_p) ;\r\nlen = pcon->pc_len ;\r\nplen = len ;\r\npa = (struct smt_para *) to ;\r\nto += PARA_LEN ;\r\nlen -= PARA_LEN ;\r\nif (((range = (para & 0xf000)) == 0x2000) ||\r\nrange == 0x3000 || range == 0x4000) {\r\nif (len < 4)\r\ngoto wrong_error ;\r\nto[0] = 0 ;\r\nto[1] = 0 ;\r\nto[2] = 0 ;\r\nto[3] = index ;\r\nlen -= 4 ;\r\nto += 4 ;\r\n}\r\nmac = index - INDEX_MAC ;\r\npath = index - INDEX_PATH ;\r\nport = index - INDEX_PORT ;\r\nswitch (range) {\r\ncase 0x1000 :\r\ndefault :\r\nmib_addr = (char *) (&smc->mib) ;\r\nbreak ;\r\ncase 0x2000 :\r\nif (mac < 0 || mac >= NUMMACS) {\r\npcon->pc_err = SMT_RDF_NOPARAM ;\r\nreturn ;\r\n}\r\nmib_addr = (char *) (&smc->mib.m[mac]) ;\r\nmib_m = (struct fddi_mib_m *) mib_addr ;\r\nbreak ;\r\ncase 0x3000 :\r\nif (path < 0 || path >= NUMPATHS) {\r\npcon->pc_err = SMT_RDF_NOPARAM ;\r\nreturn ;\r\n}\r\nmib_addr = (char *) (&smc->mib.a[path]) ;\r\nbreak ;\r\ncase 0x4000 :\r\nif (port < 0 || port >= smt_mib_phys(smc)) {\r\npcon->pc_err = SMT_RDF_NOPARAM ;\r\nreturn ;\r\n}\r\nmib_addr = (char *) (&smc->mib.p[port_to_mib(smc,port)]) ;\r\nmib_p = (struct fddi_mib_p *) mib_addr ;\r\nbreak ;\r\n}\r\nswap = NULL;\r\nswitch (para) {\r\ncase SMT_P10F0 :\r\ncase SMT_P10F1 :\r\n#ifdef ESS\r\ncase SMT_P10F2 :\r\ncase SMT_P10F3 :\r\ncase SMT_P10F4 :\r\ncase SMT_P10F5 :\r\ncase SMT_P10F6 :\r\ncase SMT_P10F7 :\r\n#endif\r\n#ifdef SBA\r\ncase SMT_P10F8 :\r\ncase SMT_P10F9 :\r\n#endif\r\ncase SMT_P20F1 :\r\nif (!local) {\r\npcon->pc_err = SMT_RDF_NOPARAM ;\r\nreturn ;\r\n}\r\nbreak ;\r\ncase SMT_P2034 :\r\ncase SMT_P2046 :\r\ncase SMT_P2047 :\r\ncase SMT_P204A :\r\ncase SMT_P2051 :\r\ncase SMT_P2052 :\r\nmac_update_counter(smc) ;\r\nbreak ;\r\ncase SMT_P4022:\r\nmib_p->fddiPORTPC_LS = LS2MIB(\r\nsm_pm_get_ls(smc,port_to_mib(smc,port))) ;\r\nbreak ;\r\ncase SMT_P_REASON :\r\n*(u32 *)to = 0 ;\r\nsp_len = 4 ;\r\ngoto sp_done ;\r\ncase SMT_P1033 :\r\nsmt_set_timestamp(smc,smc->mib.fddiSMTTimeStamp) ;\r\nbreak ;\r\ncase SMT_P1020:\r\n#if NUMPHYS == 12\r\nswap = "IIIIIIIIIIII" ;\r\n#else\r\n#if NUMPHYS == 2\r\nif (smc->s.sas == SMT_SAS)\r\nswap = "I" ;\r\nelse\r\nswap = "II" ;\r\n#else\r\n#if NUMPHYS == 24\r\nswap = "IIIIIIIIIIIIIIIIIIIIIIII" ;\r\n#else\r\n????\r\n#endif\r\n#endif\r\n#endif\r\nbreak ;\r\ncase SMT_P3212 :\r\n{\r\nsp_len = cem_build_path(smc,to,path) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P1048 :\r\n{\r\nstruct smt_p_1048 *sp ;\r\nsp = (struct smt_p_1048 *) to ;\r\nsp->p1048_flag = smc->mib.fddiSMTPeerWrapFlag ;\r\nsp->p1048_cf_state = smc->mib.fddiSMTCF_State ;\r\nsp_len = sizeof(struct smt_p_1048) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P208C :\r\n{\r\nstruct smt_p_208c *sp ;\r\nsp = (struct smt_p_208c *) to ;\r\nsp->p208c_flag =\r\nsmc->mib.m[MAC0].fddiMACDuplicateAddressCond ;\r\nsp->p208c_dupcondition =\r\n(mib_m->fddiMACDA_Flag ? SMT_ST_MY_DUPA : 0) |\r\n(mib_m->fddiMACUNDA_Flag ? SMT_ST_UNA_DUPA : 0);\r\nsp->p208c_fddilong =\r\nmib_m->fddiMACSMTAddress ;\r\nsp->p208c_fddiunalong =\r\nmib_m->fddiMACUpstreamNbr ;\r\nsp->p208c_pad = 0 ;\r\nsp_len = sizeof(struct smt_p_208c) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P208D :\r\n{\r\nstruct smt_p_208d *sp ;\r\nsp = (struct smt_p_208d *) to ;\r\nsp->p208d_flag =\r\nmib_m->fddiMACFrameErrorFlag ;\r\nsp->p208d_frame_ct =\r\nmib_m->fddiMACFrame_Ct ;\r\nsp->p208d_error_ct =\r\nmib_m->fddiMACError_Ct ;\r\nsp->p208d_lost_ct =\r\nmib_m->fddiMACLost_Ct ;\r\nsp->p208d_ratio =\r\nmib_m->fddiMACFrameErrorRatio ;\r\nsp_len = sizeof(struct smt_p_208d) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P208E :\r\n{\r\nstruct smt_p_208e *sp ;\r\nsp = (struct smt_p_208e *) to ;\r\nsp->p208e_flag =\r\nmib_m->fddiMACNotCopiedFlag ;\r\nsp->p208e_not_copied =\r\nmib_m->fddiMACNotCopied_Ct ;\r\nsp->p208e_copied =\r\nmib_m->fddiMACCopied_Ct ;\r\nsp->p208e_not_copied_ratio =\r\nmib_m->fddiMACNotCopiedRatio ;\r\nsp_len = sizeof(struct smt_p_208e) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P208F :\r\n{\r\nstruct smt_p_208f *sp ;\r\nsp = (struct smt_p_208f *) to ;\r\nsp->p208f_multiple =\r\nmib_m->fddiMACMultiple_N ;\r\nsp->p208f_nacondition =\r\nmib_m->fddiMACDuplicateAddressCond ;\r\nsp->p208f_old_una =\r\nmib_m->fddiMACOldUpstreamNbr ;\r\nsp->p208f_new_una =\r\nmib_m->fddiMACUpstreamNbr ;\r\nsp->p208f_old_dna =\r\nmib_m->fddiMACOldDownstreamNbr ;\r\nsp->p208f_new_dna =\r\nmib_m->fddiMACDownstreamNbr ;\r\nsp->p208f_curren_path =\r\nmib_m->fddiMACCurrentPath ;\r\nsp->p208f_smt_address =\r\nmib_m->fddiMACSMTAddress ;\r\nsp_len = sizeof(struct smt_p_208f) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P2090 :\r\n{\r\nstruct smt_p_2090 *sp ;\r\nsp = (struct smt_p_2090 *) to ;\r\nsp->p2090_multiple =\r\nmib_m->fddiMACMultiple_P ;\r\nsp->p2090_availablepaths =\r\nmib_m->fddiMACAvailablePaths ;\r\nsp->p2090_currentpath =\r\nmib_m->fddiMACCurrentPath ;\r\nsp->p2090_requestedpaths =\r\nmib_m->fddiMACRequestedPaths ;\r\nsp_len = sizeof(struct smt_p_2090) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P4050 :\r\n{\r\nstruct smt_p_4050 *sp ;\r\nsp = (struct smt_p_4050 *) to ;\r\nsp->p4050_flag =\r\nmib_p->fddiPORTLerFlag ;\r\nsp->p4050_pad = 0 ;\r\nsp->p4050_cutoff =\r\nmib_p->fddiPORTLer_Cutoff ;\r\nsp->p4050_alarm =\r\nmib_p->fddiPORTLer_Alarm ;\r\nsp->p4050_estimate =\r\nmib_p->fddiPORTLer_Estimate ;\r\nsp->p4050_reject_ct =\r\nmib_p->fddiPORTLem_Reject_Ct ;\r\nsp->p4050_ct =\r\nmib_p->fddiPORTLem_Ct ;\r\nsp_len = sizeof(struct smt_p_4050) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P4051 :\r\n{\r\nstruct smt_p_4051 *sp ;\r\nsp = (struct smt_p_4051 *) to ;\r\nsp->p4051_multiple =\r\nmib_p->fddiPORTMultiple_U ;\r\nsp->p4051_porttype =\r\nmib_p->fddiPORTMy_Type ;\r\nsp->p4051_connectstate =\r\nmib_p->fddiPORTConnectState ;\r\nsp->p4051_pc_neighbor =\r\nmib_p->fddiPORTNeighborType ;\r\nsp->p4051_pc_withhold =\r\nmib_p->fddiPORTPC_Withhold ;\r\nsp_len = sizeof(struct smt_p_4051) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P4052 :\r\n{\r\nstruct smt_p_4052 *sp ;\r\nsp = (struct smt_p_4052 *) to ;\r\nsp->p4052_flag =\r\nmib_p->fddiPORTEB_Condition ;\r\nsp->p4052_eberrorcount =\r\nmib_p->fddiPORTEBError_Ct ;\r\nsp_len = sizeof(struct smt_p_4052) ;\r\ngoto sp_done ;\r\n}\r\ncase SMT_P4053 :\r\n{\r\nstruct smt_p_4053 *sp ;\r\nsp = (struct smt_p_4053 *) to ;\r\nsp->p4053_multiple =\r\nmib_p->fddiPORTMultiple_P ;\r\nsp->p4053_availablepaths =\r\nmib_p->fddiPORTAvailablePaths ;\r\nsp->p4053_currentpath =\r\nmib_p->fddiPORTCurrentPath ;\r\nmemcpy( (char *) &sp->p4053_requestedpaths,\r\n(char *) mib_p->fddiPORTRequestedPaths,4) ;\r\nsp->p4053_mytype =\r\nmib_p->fddiPORTMy_Type ;\r\nsp->p4053_neighbortype =\r\nmib_p->fddiPORTNeighborType ;\r\nsp_len = sizeof(struct smt_p_4053) ;\r\ngoto sp_done ;\r\n}\r\ndefault :\r\nbreak ;\r\n}\r\nif (!pt) {\r\npcon->pc_err = (para & 0xff00) ? SMT_RDF_NOPARAM :\r\nSMT_RDF_ILLEGAL ;\r\nreturn ;\r\n}\r\nswitch (pt->p_access) {\r\ncase AC_G :\r\ncase AC_GR :\r\nbreak ;\r\ndefault :\r\npcon->pc_err = SMT_RDF_ILLEGAL ;\r\nreturn ;\r\n}\r\nfrom = mib_addr + pt->p_offset ;\r\nif (!swap)\r\nswap = pt->p_swap ;\r\nwhile ((c = *swap++)) {\r\nswitch(c) {\r\ncase 'b' :\r\ncase 'w' :\r\ncase 'l' :\r\nbreak ;\r\ncase 'S' :\r\ncase 'E' :\r\ncase 'R' :\r\ncase 'r' :\r\nif (len < 4)\r\ngoto len_error ;\r\nto[0] = 0 ;\r\nto[1] = 0 ;\r\n#ifdef LITTLE_ENDIAN\r\nif (c == 'r') {\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\n}\r\nelse {\r\nto[3] = *from++ ;\r\nto[2] = *from++ ;\r\n}\r\n#else\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\n#endif\r\nto += 4 ;\r\nlen -= 4 ;\r\nbreak ;\r\ncase 'I' :\r\nif (len < 2)\r\ngoto len_error ;\r\n#ifdef LITTLE_ENDIAN\r\nto[1] = *from++ ;\r\nto[0] = *from++ ;\r\n#else\r\nto[0] = *from++ ;\r\nto[1] = *from++ ;\r\n#endif\r\nto += 2 ;\r\nlen -= 2 ;\r\nbreak ;\r\ncase 'F' :\r\ncase 'B' :\r\nif (len < 4)\r\ngoto len_error ;\r\nlen -= 4 ;\r\nto[0] = 0 ;\r\nto[1] = 0 ;\r\nto[2] = 0 ;\r\nto[3] = *from++ ;\r\nto += 4 ;\r\nbreak ;\r\ncase 'C' :\r\ncase 'T' :\r\ncase 'L' :\r\nif (len < 4)\r\ngoto len_error ;\r\n#ifdef LITTLE_ENDIAN\r\nto[3] = *from++ ;\r\nto[2] = *from++ ;\r\nto[1] = *from++ ;\r\nto[0] = *from++ ;\r\n#else\r\nto[0] = *from++ ;\r\nto[1] = *from++ ;\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\n#endif\r\nlen -= 4 ;\r\nto += 4 ;\r\nbreak ;\r\ncase '2' :\r\nif (len < 4)\r\ngoto len_error ;\r\nto[0] = 0 ;\r\nto[1] = 0 ;\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\nlen -= 4 ;\r\nto += 4 ;\r\nbreak ;\r\ncase '4' :\r\nif (len < 4)\r\ngoto len_error ;\r\nto[0] = *from++ ;\r\nto[1] = *from++ ;\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\nlen -= 4 ;\r\nto += 4 ;\r\nbreak ;\r\ncase 'A' :\r\nif (len < 8)\r\ngoto len_error ;\r\nto[0] = 0 ;\r\nto[1] = 0 ;\r\nmemcpy((char *) to+2,(char *) from,6) ;\r\nto += 8 ;\r\nfrom += 8 ;\r\nlen -= 8 ;\r\nbreak ;\r\ncase '8' :\r\nif (len < 8)\r\ngoto len_error ;\r\nmemcpy((char *) to,(char *) from,8) ;\r\nto += 8 ;\r\nfrom += 8 ;\r\nlen -= 8 ;\r\nbreak ;\r\ncase 'D' :\r\nif (len < 32)\r\ngoto len_error ;\r\nmemcpy((char *) to,(char *) from,32) ;\r\nto += 32 ;\r\nfrom += 32 ;\r\nlen -= 32 ;\r\nbreak ;\r\ncase 'P' :\r\nif (len < 8)\r\ngoto len_error ;\r\nto[0] = *from++ ;\r\nto[1] = *from++ ;\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\nto[4] = *from++ ;\r\nto[5] = *from++ ;\r\nto[6] = *from++ ;\r\nto[7] = *from++ ;\r\nto += 8 ;\r\nlen -= 8 ;\r\nbreak ;\r\ndefault :\r\nSMT_PANIC(smc,SMT_E0119, SMT_E0119_MSG) ;\r\nbreak ;\r\n}\r\n}\r\ndone:\r\nif (len & 3) {\r\nto[0] = 0 ;\r\nto[1] = 0 ;\r\nto += 4 - (len & 3 ) ;\r\nlen = len & ~ 3 ;\r\n}\r\npa->p_type = para ;\r\npa->p_len = plen - len - PARA_LEN ;\r\npcon->pc_p = (void *) to ;\r\npcon->pc_len = len ;\r\nreturn ;\r\nsp_done:\r\nlen -= sp_len ;\r\nto += sp_len ;\r\ngoto done ;\r\nlen_error:\r\npcon->pc_err = SMT_RDF_TOOLONG ;\r\nreturn ;\r\nwrong_error:\r\npcon->pc_err = SMT_RDF_LENGTH ;\r\n}\r\nstatic int smt_set_para(struct s_smc *smc, struct smt_para *pa, int index,\r\nint local, int set)\r\n{\r\n#define IFSET(x) if (set) (x)\r\nconst struct s_p_tab *pt ;\r\nint len ;\r\nchar *from ;\r\nchar *to ;\r\nconst char *swap ;\r\nchar c ;\r\nchar *mib_addr ;\r\nstruct fddi_mib *mib ;\r\nstruct fddi_mib_m *mib_m = NULL;\r\nstruct fddi_mib_a *mib_a = NULL;\r\nstruct fddi_mib_p *mib_p = NULL;\r\nint mac ;\r\nint path ;\r\nint port ;\r\nSK_LOC_DECL(u_char,byte_val) ;\r\nSK_LOC_DECL(u_short,word_val) ;\r\nSK_LOC_DECL(u_long,long_val) ;\r\nmac = index - INDEX_MAC ;\r\npath = index - INDEX_PATH ;\r\nport = index - INDEX_PORT ;\r\nlen = pa->p_len ;\r\nfrom = (char *) (pa + 1 ) ;\r\nmib = &smc->mib ;\r\nswitch (pa->p_type & 0xf000) {\r\ncase 0x1000 :\r\ndefault :\r\nmib_addr = (char *) mib ;\r\nbreak ;\r\ncase 0x2000 :\r\nif (mac < 0 || mac >= NUMMACS) {\r\nreturn SMT_RDF_NOPARAM;\r\n}\r\nmib_m = &smc->mib.m[mac] ;\r\nmib_addr = (char *) mib_m ;\r\nfrom += 4 ;\r\nlen -= 4 ;\r\nbreak ;\r\ncase 0x3000 :\r\nif (path < 0 || path >= NUMPATHS) {\r\nreturn SMT_RDF_NOPARAM;\r\n}\r\nmib_a = &smc->mib.a[path] ;\r\nmib_addr = (char *) mib_a ;\r\nfrom += 4 ;\r\nlen -= 4 ;\r\nbreak ;\r\ncase 0x4000 :\r\nif (port < 0 || port >= smt_mib_phys(smc)) {\r\nreturn SMT_RDF_NOPARAM;\r\n}\r\nmib_p = &smc->mib.p[port_to_mib(smc,port)] ;\r\nmib_addr = (char *) mib_p ;\r\nfrom += 4 ;\r\nlen -= 4 ;\r\nbreak ;\r\n}\r\nswitch (pa->p_type) {\r\ncase SMT_P10F0 :\r\ncase SMT_P10F1 :\r\n#ifdef ESS\r\ncase SMT_P10F2 :\r\ncase SMT_P10F3 :\r\ncase SMT_P10F4 :\r\ncase SMT_P10F5 :\r\ncase SMT_P10F6 :\r\ncase SMT_P10F7 :\r\n#endif\r\n#ifdef SBA\r\ncase SMT_P10F8 :\r\ncase SMT_P10F9 :\r\n#endif\r\ncase SMT_P20F1 :\r\nif (!local)\r\nreturn SMT_RDF_NOPARAM;\r\nbreak ;\r\n}\r\npt = smt_get_ptab(pa->p_type) ;\r\nif (!pt)\r\nreturn (pa->p_type & 0xff00) ? SMT_RDF_NOPARAM :\r\nSMT_RDF_ILLEGAL;\r\nswitch (pt->p_access) {\r\ncase AC_GR :\r\ncase AC_S :\r\nbreak ;\r\ndefault :\r\nreturn SMT_RDF_ILLEGAL;\r\n}\r\nto = mib_addr + pt->p_offset ;\r\nswap = pt->p_swap ;\r\nwhile (swap && (c = *swap++)) {\r\nswitch(c) {\r\ncase 'b' :\r\nto = (char *) &byte_val ;\r\nbreak ;\r\ncase 'w' :\r\nto = (char *) &word_val ;\r\nbreak ;\r\ncase 'l' :\r\nto = (char *) &long_val ;\r\nbreak ;\r\ncase 'S' :\r\ncase 'E' :\r\ncase 'R' :\r\ncase 'r' :\r\nif (len < 4) {\r\ngoto len_error ;\r\n}\r\nif (from[0] | from[1])\r\ngoto val_error ;\r\n#ifdef LITTLE_ENDIAN\r\nif (c == 'r') {\r\nto[0] = from[2] ;\r\nto[1] = from[3] ;\r\n}\r\nelse {\r\nto[1] = from[2] ;\r\nto[0] = from[3] ;\r\n}\r\n#else\r\nto[0] = from[2] ;\r\nto[1] = from[3] ;\r\n#endif\r\nfrom += 4 ;\r\nto += 2 ;\r\nlen -= 4 ;\r\nbreak ;\r\ncase 'F' :\r\ncase 'B' :\r\nif (len < 4) {\r\ngoto len_error ;\r\n}\r\nif (from[0] | from[1] | from[2])\r\ngoto val_error ;\r\nto[0] = from[3] ;\r\nlen -= 4 ;\r\nfrom += 4 ;\r\nto += 4 ;\r\nbreak ;\r\ncase 'C' :\r\ncase 'T' :\r\ncase 'L' :\r\nif (len < 4) {\r\ngoto len_error ;\r\n}\r\n#ifdef LITTLE_ENDIAN\r\nto[3] = *from++ ;\r\nto[2] = *from++ ;\r\nto[1] = *from++ ;\r\nto[0] = *from++ ;\r\n#else\r\nto[0] = *from++ ;\r\nto[1] = *from++ ;\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\n#endif\r\nlen -= 4 ;\r\nto += 4 ;\r\nbreak ;\r\ncase 'A' :\r\nif (len < 8)\r\ngoto len_error ;\r\nif (set)\r\nmemcpy(to,from+2,6) ;\r\nto += 8 ;\r\nfrom += 8 ;\r\nlen -= 8 ;\r\nbreak ;\r\ncase '4' :\r\nif (len < 4)\r\ngoto len_error ;\r\nif (set)\r\nmemcpy(to,from,4) ;\r\nto += 4 ;\r\nfrom += 4 ;\r\nlen -= 4 ;\r\nbreak ;\r\ncase '8' :\r\nif (len < 8)\r\ngoto len_error ;\r\nif (set)\r\nmemcpy(to,from,8) ;\r\nto += 8 ;\r\nfrom += 8 ;\r\nlen -= 8 ;\r\nbreak ;\r\ncase 'D' :\r\nif (len < 32)\r\ngoto len_error ;\r\nif (set)\r\nmemcpy(to,from,32) ;\r\nto += 32 ;\r\nfrom += 32 ;\r\nlen -= 32 ;\r\nbreak ;\r\ncase 'P' :\r\nif (set) {\r\nto[0] = *from++ ;\r\nto[1] = *from++ ;\r\nto[2] = *from++ ;\r\nto[3] = *from++ ;\r\nto[4] = *from++ ;\r\nto[5] = *from++ ;\r\nto[6] = *from++ ;\r\nto[7] = *from++ ;\r\n}\r\nto += 8 ;\r\nlen -= 8 ;\r\nbreak ;\r\ndefault :\r\nSMT_PANIC(smc,SMT_E0120, SMT_E0120_MSG) ;\r\nreturn SMT_RDF_ILLEGAL;\r\n}\r\n}\r\nswitch (pa->p_type) {\r\ncase SMT_P101A:\r\nif (word_val & ~1)\r\ngoto val_error ;\r\nIFSET(mib->fddiSMTConfigPolicy = word_val) ;\r\nbreak ;\r\ncase SMT_P101B :\r\nif (!(word_val & POLICY_MM))\r\ngoto val_error ;\r\nIFSET(mib->fddiSMTConnectionPolicy = word_val) ;\r\nbreak ;\r\ncase SMT_P101D :\r\nif (word_val < 2 || word_val > 30)\r\ngoto val_error ;\r\nIFSET(mib->fddiSMTTT_Notify = word_val) ;\r\nbreak ;\r\ncase SMT_P101E :\r\nif (byte_val & ~1)\r\ngoto val_error ;\r\nIFSET(mib->fddiSMTStatRptPolicy = byte_val) ;\r\nbreak ;\r\ncase SMT_P101F :\r\nif (long_val < (long)0x478bf51L)\r\ngoto val_error ;\r\nIFSET(mib->fddiSMTTrace_MaxExpiration = long_val) ;\r\nbreak ;\r\n#ifdef ESS\r\ncase SMT_P10F2 :\r\nif (long_val > 1562)\r\ngoto val_error ;\r\nif (set && smc->mib.fddiESSPayload != long_val) {\r\nsmc->ess.raf_act_timer_poll = TRUE ;\r\nsmc->mib.fddiESSPayload = long_val ;\r\n}\r\nbreak ;\r\ncase SMT_P10F3 :\r\nif (long_val < 50 || long_val > 5000)\r\ngoto val_error ;\r\nif (set && smc->mib.fddiESSPayload &&\r\nsmc->mib.fddiESSOverhead != long_val) {\r\nsmc->ess.raf_act_timer_poll = TRUE ;\r\nsmc->mib.fddiESSOverhead = long_val ;\r\n}\r\nbreak ;\r\ncase SMT_P10F4 :\r\nif (long_val > -MS2BCLK(5) || long_val < -MS2BCLK(165))\r\ngoto val_error ;\r\nIFSET(mib->fddiESSMaxTNeg = long_val) ;\r\nbreak ;\r\ncase SMT_P10F5 :\r\nif (long_val < 1 || long_val > 4478)\r\ngoto val_error ;\r\nIFSET(mib->fddiESSMinSegmentSize = long_val) ;\r\nbreak ;\r\ncase SMT_P10F6 :\r\nif ((long_val & 0xffff) != 1)\r\ngoto val_error ;\r\nIFSET(mib->fddiESSCategory = long_val) ;\r\nbreak ;\r\ncase SMT_P10F7 :\r\nif (word_val > 1)\r\ngoto val_error ;\r\nIFSET(mib->fddiESSSynchTxMode = word_val) ;\r\nbreak ;\r\n#endif\r\n#ifdef SBA\r\ncase SMT_P10F8 :\r\nif (byte_val != SB_STOP && byte_val != SB_START)\r\ngoto val_error ;\r\nIFSET(mib->fddiSBACommand = byte_val) ;\r\nbreak ;\r\ncase SMT_P10F9 :\r\nif (byte_val > 100)\r\ngoto val_error ;\r\nIFSET(mib->fddiSBAAvailable = byte_val) ;\r\nbreak ;\r\n#endif\r\ncase SMT_P2020 :\r\nif ((word_val & (MIB_P_PATH_PRIM_PREFER |\r\nMIB_P_PATH_PRIM_ALTER)) == 0 )\r\ngoto val_error ;\r\nIFSET(mib_m->fddiMACRequestedPaths = word_val) ;\r\nbreak ;\r\ncase SMT_P205F :\r\nIFSET(mib_m->fddiMACFrameErrorThreshold = word_val) ;\r\nbreak ;\r\ncase SMT_P2067 :\r\nIFSET(mib_m->fddiMACNotCopiedThreshold = word_val) ;\r\nbreak ;\r\ncase SMT_P2076:\r\nif (byte_val & ~1)\r\ngoto val_error ;\r\nif (set) {\r\nmib_m->fddiMACMA_UnitdataEnable = byte_val ;\r\nqueue_event(smc,EVENT_RMT,RM_ENABLE_FLAG) ;\r\n}\r\nbreak ;\r\ncase SMT_P20F1 :\r\nIFSET(mib_m->fddiMACT_Min = long_val) ;\r\nbreak ;\r\ncase SMT_P320F :\r\nif (long_val > 1562)\r\ngoto val_error ;\r\nIFSET(mib_a->fddiPATHSbaPayload = long_val) ;\r\n#ifdef ESS\r\nif (set)\r\ness_para_change(smc) ;\r\n#endif\r\nbreak ;\r\ncase SMT_P3210 :\r\nif (long_val > 5000)\r\ngoto val_error ;\r\nif (long_val != 0 && mib_a->fddiPATHSbaPayload == 0)\r\ngoto val_error ;\r\nIFSET(mib_a->fddiPATHSbaOverhead = long_val) ;\r\n#ifdef ESS\r\nif (set)\r\ness_para_change(smc) ;\r\n#endif\r\nbreak ;\r\ncase SMT_P3213:\r\nif (set) {\r\nmib_a->fddiPATHT_Rmode = long_val ;\r\nrtm_set_timer(smc) ;\r\n}\r\nbreak ;\r\ncase SMT_P3214 :\r\nif (long_val > 0x00BEBC20L)\r\ngoto val_error ;\r\n#ifdef SBA\r\nif (set && mib->fddiSBACommand == SB_STOP)\r\ngoto val_error ;\r\n#endif\r\nIFSET(mib_a->fddiPATHSbaAvailable = long_val) ;\r\nbreak ;\r\ncase SMT_P3215 :\r\nIFSET(mib_a->fddiPATHTVXLowerBound = long_val) ;\r\ngoto change_mac_para ;\r\ncase SMT_P3216 :\r\nIFSET(mib_a->fddiPATHT_MaxLowerBound = long_val) ;\r\ngoto change_mac_para ;\r\ncase SMT_P3217 :\r\nIFSET(mib_a->fddiPATHMaxT_Req = long_val) ;\r\nchange_mac_para:\r\nif (set && smt_set_mac_opvalues(smc)) {\r\nRS_SET(smc,RS_EVENT) ;\r\nsmc->sm.please_reconnect = 1 ;\r\nqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\r\n}\r\nbreak ;\r\ncase SMT_P400E :\r\nif (byte_val > 1)\r\ngoto val_error ;\r\nIFSET(mib_p->fddiPORTConnectionPolicies = byte_val) ;\r\nbreak ;\r\ncase SMT_P4011 :\r\nIFSET(memcpy((char *)mib_p->fddiPORTRequestedPaths,\r\n(char *)&long_val,4)) ;\r\nbreak ;\r\ncase SMT_P401F:\r\nif (word_val > 4)\r\ngoto val_error ;\r\nIFSET(mib_p->fddiPORTMaint_LS = word_val) ;\r\nbreak ;\r\ncase SMT_P403A :\r\nif (byte_val < 4 || byte_val > 15)\r\ngoto val_error ;\r\nIFSET(mib_p->fddiPORTLer_Cutoff = byte_val) ;\r\nbreak ;\r\ncase SMT_P403B :\r\nif (byte_val < 4 || byte_val > 15)\r\ngoto val_error ;\r\nIFSET(mib_p->fddiPORTLer_Alarm = byte_val) ;\r\nbreak ;\r\ncase SMT_P103C :\r\nif (smt_action(smc,SMT_STATION_ACTION, (int) word_val, 0))\r\ngoto val_error ;\r\nbreak ;\r\ncase SMT_P4046:\r\nif (smt_action(smc,SMT_PORT_ACTION, (int) word_val,\r\nport_to_mib(smc,port)))\r\ngoto val_error ;\r\nbreak ;\r\ndefault :\r\nbreak ;\r\n}\r\nreturn 0;\r\nval_error:\r\nreturn SMT_RDF_RANGE;\r\nlen_error:\r\nreturn SMT_RDF_LENGTH;\r\n#if 0\r\nno_author_error:\r\nreturn SMT_RDF_AUTHOR;\r\n#endif\r\n}\r\nstatic const struct s_p_tab *smt_get_ptab(u_short para)\r\n{\r\nconst struct s_p_tab *pt ;\r\nfor (pt = p_tab ; pt->p_num && pt->p_num != para ; pt++)\r\n;\r\nreturn pt->p_num ? pt : NULL;\r\n}\r\nstatic int smt_mib_phys(struct s_smc *smc)\r\n{\r\n#ifdef CONCENTRATOR\r\nSK_UNUSED(smc) ;\r\nreturn NUMPHYS;\r\n#else\r\nif (smc->s.sas == SMT_SAS)\r\nreturn 1;\r\nreturn NUMPHYS;\r\n#endif\r\n}\r\nstatic int port_to_mib(struct s_smc *smc, int p)\r\n{\r\n#ifdef CONCENTRATOR\r\nSK_UNUSED(smc) ;\r\nreturn p;\r\n#else\r\nif (smc->s.sas == SMT_SAS)\r\nreturn PS;\r\nreturn p;\r\n#endif\r\n}\r\nvoid dump_smt(struct s_smc *smc, struct smt_header *sm, char *text)\r\n{\r\nint len ;\r\nstruct smt_para *pa ;\r\nchar *c ;\r\nint n ;\r\nint nn ;\r\n#ifdef LITTLE_ENDIAN\r\nint smtlen ;\r\n#endif\r\nSK_UNUSED(smc) ;\r\n#ifdef DEBUG_BRD\r\nif (smc->debug.d_smtf < 2)\r\n#else\r\nif (debug.d_smtf < 2)\r\n#endif\r\nreturn ;\r\n#ifdef LITTLE_ENDIAN\r\nsmtlen = sm->smt_len + sizeof(struct smt_header) ;\r\n#endif\r\nprintf("SMT Frame [%s]:\nDA ",text) ;\r\ndump_hex((char *) &sm->smt_dest,6) ;\r\nprintf("\tSA ") ;\r\ndump_hex((char *) &sm->smt_source,6) ;\r\nprintf(" Class %x Type %x Version %x\n",\r\nsm->smt_class,sm->smt_type,sm->smt_version) ;\r\nprintf("TID %lx\t\tSID ",sm->smt_tid) ;\r\ndump_hex((char *) &sm->smt_sid,8) ;\r\nprintf(" LEN %x\n",sm->smt_len) ;\r\nlen = sm->smt_len ;\r\npa = (struct smt_para *) (sm + 1) ;\r\nwhile (len > 0 ) {\r\nint plen ;\r\n#ifdef UNIX\r\nprintf("TYPE %x LEN %x VALUE\t",pa->p_type,pa->p_len) ;\r\n#else\r\nprintf("TYPE %04x LEN %2x VALUE\t",pa->p_type,pa->p_len) ;\r\n#endif\r\nn = pa->p_len ;\r\nif ( (n < 0 ) || (n > (int)(len - PARA_LEN))) {\r\nn = len - PARA_LEN ;\r\nprintf(" BAD LENGTH\n") ;\r\nbreak ;\r\n}\r\n#ifdef LITTLE_ENDIAN\r\nsmt_swap_para(sm,smtlen,0) ;\r\n#endif\r\nif (n < 24) {\r\ndump_hex((char *)(pa+1),(int) n) ;\r\nprintf("\n") ;\r\n}\r\nelse {\r\nint first = 0 ;\r\nc = (char *)(pa+1) ;\r\ndump_hex(c,16) ;\r\nprintf("\n") ;\r\nn -= 16 ;\r\nc += 16 ;\r\nwhile (n > 0) {\r\nnn = (n > 16) ? 16 : n ;\r\nif (n > 64) {\r\nif (first == 0)\r\nprintf("\t\t\t...\n") ;\r\nfirst = 1 ;\r\n}\r\nelse {\r\nprintf("\t\t\t") ;\r\ndump_hex(c,nn) ;\r\nprintf("\n") ;\r\n}\r\nn -= nn ;\r\nc += 16 ;\r\n}\r\n}\r\n#ifdef LITTLE_ENDIAN\r\nsmt_swap_para(sm,smtlen,1) ;\r\n#endif\r\nplen = (pa->p_len + PARA_LEN + 3) & ~3 ;\r\nlen -= plen ;\r\npa = (struct smt_para *)((char *)pa + plen) ;\r\n}\r\nprintf("-------------------------------------------------\n\n") ;\r\n}\r\nvoid dump_hex(char *p, int len)\r\n{\r\nint n = 0 ;\r\nwhile (len--) {\r\nn++ ;\r\n#ifdef UNIX\r\nprintf("%x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;\r\n#else\r\nprintf("%02x%s",*p++ & 0xff,len ? ( (n & 7) ? " " : "-") : "") ;\r\n#endif\r\n}\r\n}
