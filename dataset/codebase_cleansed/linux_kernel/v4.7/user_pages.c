bool hfi1_can_pin_pages(struct hfi1_devdata *dd, u32 nlocked, u32 npages)\r\n{\r\nunsigned long ulimit = rlimit(RLIMIT_MEMLOCK), pinned, cache_limit,\r\nsize = (cache_size * (1UL << 20));\r\nunsigned usr_ctxts = dd->num_rcv_contexts - dd->first_user_ctxt;\r\nbool can_lock = capable(CAP_IPC_LOCK);\r\ncache_limit = (ulimit / usr_ctxts) / 4;\r\nif (ulimit != (-1UL) && size > cache_limit)\r\nsize = cache_limit;\r\nsize = DIV_ROUND_UP(size, PAGE_SIZE);\r\ndown_read(&current->mm->mmap_sem);\r\npinned = current->mm->pinned_vm;\r\nup_read(&current->mm->mmap_sem);\r\nif (pinned + npages >= ulimit && !can_lock)\r\nreturn false;\r\nreturn ((nlocked + npages) <= size) || can_lock;\r\n}\r\nint hfi1_acquire_user_pages(unsigned long vaddr, size_t npages, bool writable,\r\nstruct page **pages)\r\n{\r\nint ret;\r\nret = get_user_pages_fast(vaddr, npages, writable, pages);\r\nif (ret < 0)\r\nreturn ret;\r\ndown_write(&current->mm->mmap_sem);\r\ncurrent->mm->pinned_vm += ret;\r\nup_write(&current->mm->mmap_sem);\r\nreturn ret;\r\n}\r\nvoid hfi1_release_user_pages(struct mm_struct *mm, struct page **p,\r\nsize_t npages, bool dirty)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < npages; i++) {\r\nif (dirty)\r\nset_page_dirty_lock(p[i]);\r\nput_page(p[i]);\r\n}\r\nif (mm) {\r\ndown_write(&mm->mmap_sem);\r\nmm->pinned_vm -= npages;\r\nup_write(&mm->mmap_sem);\r\n}\r\n}
