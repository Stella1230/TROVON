static void *zlib_init(struct squashfs_sb_info *dummy, void *buff)\r\n{\r\nz_stream *stream = kmalloc(sizeof(z_stream), GFP_KERNEL);\r\nif (stream == NULL)\r\ngoto failed;\r\nstream->workspace = vmalloc(zlib_inflate_workspacesize());\r\nif (stream->workspace == NULL)\r\ngoto failed;\r\nreturn stream;\r\nfailed:\r\nERROR("Failed to allocate zlib workspace\n");\r\nkfree(stream);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void zlib_free(void *strm)\r\n{\r\nz_stream *stream = strm;\r\nif (stream)\r\nvfree(stream->workspace);\r\nkfree(stream);\r\n}\r\nstatic int zlib_uncompress(struct squashfs_sb_info *msblk, void *strm,\r\nstruct buffer_head **bh, int b, int offset, int length,\r\nstruct squashfs_page_actor *output)\r\n{\r\nint zlib_err, zlib_init = 0, k = 0;\r\nz_stream *stream = strm;\r\nstream->avail_out = PAGE_SIZE;\r\nstream->next_out = squashfs_first_page(output);\r\nstream->avail_in = 0;\r\ndo {\r\nif (stream->avail_in == 0 && k < b) {\r\nint avail = min(length, msblk->devblksize - offset);\r\nlength -= avail;\r\nstream->next_in = bh[k]->b_data + offset;\r\nstream->avail_in = avail;\r\noffset = 0;\r\n}\r\nif (stream->avail_out == 0) {\r\nstream->next_out = squashfs_next_page(output);\r\nif (stream->next_out != NULL)\r\nstream->avail_out = PAGE_SIZE;\r\n}\r\nif (!zlib_init) {\r\nzlib_err = zlib_inflateInit(stream);\r\nif (zlib_err != Z_OK) {\r\nsquashfs_finish_page(output);\r\ngoto out;\r\n}\r\nzlib_init = 1;\r\n}\r\nzlib_err = zlib_inflate(stream, Z_SYNC_FLUSH);\r\nif (stream->avail_in == 0 && k < b)\r\nput_bh(bh[k++]);\r\n} while (zlib_err == Z_OK);\r\nsquashfs_finish_page(output);\r\nif (zlib_err != Z_STREAM_END)\r\ngoto out;\r\nzlib_err = zlib_inflateEnd(stream);\r\nif (zlib_err != Z_OK)\r\ngoto out;\r\nif (k < b)\r\ngoto out;\r\nreturn stream->total_out;\r\nout:\r\nfor (; k < b; k++)\r\nput_bh(bh[k]);\r\nreturn -EIO;\r\n}
