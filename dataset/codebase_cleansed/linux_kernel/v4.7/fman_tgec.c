static void set_mac_address(struct tgec_regs __iomem *regs, u8 *adr)\r\n{\r\nu32 tmp0, tmp1;\r\ntmp0 = (u32)(adr[0] | adr[1] << 8 | adr[2] << 16 | adr[3] << 24);\r\ntmp1 = (u32)(adr[4] | adr[5] << 8);\r\niowrite32be(tmp0, &regs->mac_addr_0);\r\niowrite32be(tmp1, &regs->mac_addr_1);\r\n}\r\nstatic void set_dflts(struct tgec_cfg *cfg)\r\n{\r\ncfg->promiscuous_mode_enable = false;\r\ncfg->pause_ignore = false;\r\ncfg->tx_ipg_length = DEFAULT_TX_IPG_LENGTH;\r\ncfg->max_frame_length = DEFAULT_MAX_FRAME_LENGTH;\r\ncfg->pause_quant = DEFAULT_PAUSE_QUANT;\r\n}\r\nstatic int init(struct tgec_regs __iomem *regs, struct tgec_cfg *cfg,\r\nu32 exception_mask)\r\n{\r\nu32 tmp;\r\ntmp = CMF_CFG_CRC_FWD;\r\nif (cfg->promiscuous_mode_enable)\r\ntmp |= CMD_CFG_PROMIS_EN;\r\nif (cfg->pause_ignore)\r\ntmp |= CMD_CFG_PAUSE_IGNORE;\r\ntmp |= CMD_CFG_NO_LEN_CHK;\r\niowrite32be(tmp, &regs->command_config);\r\niowrite32be((u32)cfg->max_frame_length, &regs->maxfrm);\r\niowrite32be(cfg->pause_quant, &regs->pause_quant);\r\niowrite32be(0xffffffff, &regs->ievent);\r\niowrite32be(ioread32be(&regs->imask) | exception_mask, &regs->imask);\r\nreturn 0;\r\n}\r\nstatic int check_init_parameters(struct fman_mac *tgec)\r\n{\r\nif (tgec->max_speed < SPEED_10000) {\r\npr_err("10G MAC driver only support 10G speed\n");\r\nreturn -EINVAL;\r\n}\r\nif (tgec->addr == 0) {\r\npr_err("Ethernet 10G MAC Must have valid MAC Address\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tgec->exception_cb) {\r\npr_err("uninitialized exception_cb\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tgec->event_cb) {\r\npr_err("uninitialized event_cb\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_exception_flag(enum fman_mac_exceptions exception)\r\n{\r\nu32 bit_mask;\r\nswitch (exception) {\r\ncase FM_MAC_EX_10G_MDIO_SCAN_EVENT:\r\nbit_mask = TGEC_IMASK_MDIO_SCAN_EVENT;\r\nbreak;\r\ncase FM_MAC_EX_10G_MDIO_CMD_CMPL:\r\nbit_mask = TGEC_IMASK_MDIO_CMD_CMPL;\r\nbreak;\r\ncase FM_MAC_EX_10G_REM_FAULT:\r\nbit_mask = TGEC_IMASK_REM_FAULT;\r\nbreak;\r\ncase FM_MAC_EX_10G_LOC_FAULT:\r\nbit_mask = TGEC_IMASK_LOC_FAULT;\r\nbreak;\r\ncase FM_MAC_EX_10G_TX_ECC_ER:\r\nbit_mask = TGEC_IMASK_TX_ECC_ER;\r\nbreak;\r\ncase FM_MAC_EX_10G_TX_FIFO_UNFL:\r\nbit_mask = TGEC_IMASK_TX_FIFO_UNFL;\r\nbreak;\r\ncase FM_MAC_EX_10G_TX_FIFO_OVFL:\r\nbit_mask = TGEC_IMASK_TX_FIFO_OVFL;\r\nbreak;\r\ncase FM_MAC_EX_10G_TX_ER:\r\nbit_mask = TGEC_IMASK_TX_ER;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_FIFO_OVFL:\r\nbit_mask = TGEC_IMASK_RX_FIFO_OVFL;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_ECC_ER:\r\nbit_mask = TGEC_IMASK_RX_ECC_ER;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_JAB_FRM:\r\nbit_mask = TGEC_IMASK_RX_JAB_FRM;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_OVRSZ_FRM:\r\nbit_mask = TGEC_IMASK_RX_OVRSZ_FRM;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_RUNT_FRM:\r\nbit_mask = TGEC_IMASK_RX_RUNT_FRM;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_FRAG_FRM:\r\nbit_mask = TGEC_IMASK_RX_FRAG_FRM;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_LEN_ER:\r\nbit_mask = TGEC_IMASK_RX_LEN_ER;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_CRC_ER:\r\nbit_mask = TGEC_IMASK_RX_CRC_ER;\r\nbreak;\r\ncase FM_MAC_EX_10G_RX_ALIGN_ER:\r\nbit_mask = TGEC_IMASK_RX_ALIGN_ER;\r\nbreak;\r\ndefault:\r\nbit_mask = 0;\r\nbreak;\r\n}\r\nreturn bit_mask;\r\n}\r\nstatic void tgec_err_exception(void *handle)\r\n{\r\nstruct fman_mac *tgec = (struct fman_mac *)handle;\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nu32 event;\r\nevent = ioread32be(&regs->ievent) &\r\n~(TGEC_IMASK_MDIO_SCAN_EVENT |\r\nTGEC_IMASK_MDIO_CMD_CMPL);\r\nevent &= ioread32be(&regs->imask);\r\niowrite32be(event, &regs->ievent);\r\nif (event & TGEC_IMASK_REM_FAULT)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_REM_FAULT);\r\nif (event & TGEC_IMASK_LOC_FAULT)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_LOC_FAULT);\r\nif (event & TGEC_IMASK_TX_ECC_ER)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_ECC_ER);\r\nif (event & TGEC_IMASK_TX_FIFO_UNFL)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_FIFO_UNFL);\r\nif (event & TGEC_IMASK_TX_FIFO_OVFL)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_FIFO_OVFL);\r\nif (event & TGEC_IMASK_TX_ER)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_ER);\r\nif (event & TGEC_IMASK_RX_FIFO_OVFL)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_FIFO_OVFL);\r\nif (event & TGEC_IMASK_RX_ECC_ER)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_ECC_ER);\r\nif (event & TGEC_IMASK_RX_JAB_FRM)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_JAB_FRM);\r\nif (event & TGEC_IMASK_RX_OVRSZ_FRM)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_OVRSZ_FRM);\r\nif (event & TGEC_IMASK_RX_RUNT_FRM)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_RUNT_FRM);\r\nif (event & TGEC_IMASK_RX_FRAG_FRM)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_FRAG_FRM);\r\nif (event & TGEC_IMASK_RX_LEN_ER)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_LEN_ER);\r\nif (event & TGEC_IMASK_RX_CRC_ER)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_CRC_ER);\r\nif (event & TGEC_IMASK_RX_ALIGN_ER)\r\ntgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_ALIGN_ER);\r\n}\r\nstatic void free_init_resources(struct fman_mac *tgec)\r\n{\r\nfman_unregister_intr(tgec->fm, FMAN_MOD_MAC, tgec->mac_id,\r\nFMAN_INTR_TYPE_ERR);\r\nfree_hash_table(tgec->multicast_addr_hash);\r\ntgec->multicast_addr_hash = NULL;\r\nfree_hash_table(tgec->unicast_addr_hash);\r\ntgec->unicast_addr_hash = NULL;\r\n}\r\nstatic bool is_init_done(struct tgec_cfg *cfg)\r\n{\r\nif (!cfg)\r\nreturn true;\r\nreturn false;\r\n}\r\nint tgec_enable(struct fman_mac *tgec, enum comm_mode mode)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nu32 tmp;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (mode & COMM_MODE_RX)\r\ntmp |= CMD_CFG_RX_EN;\r\nif (mode & COMM_MODE_TX)\r\ntmp |= CMD_CFG_TX_EN;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint tgec_disable(struct fman_mac *tgec, enum comm_mode mode)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nu32 tmp;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (mode & COMM_MODE_RX)\r\ntmp &= ~CMD_CFG_RX_EN;\r\nif (mode & COMM_MODE_TX)\r\ntmp &= ~CMD_CFG_TX_EN;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint tgec_set_promiscuous(struct fman_mac *tgec, bool new_val)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nu32 tmp;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (new_val)\r\ntmp |= CMD_CFG_PROMIS_EN;\r\nelse\r\ntmp &= ~CMD_CFG_PROMIS_EN;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint tgec_cfg_max_frame_len(struct fman_mac *tgec, u16 new_val)\r\n{\r\nif (is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\ntgec->cfg->max_frame_length = new_val;\r\nreturn 0;\r\n}\r\nint tgec_set_tx_pause_frames(struct fman_mac *tgec, u8 __maybe_unused priority,\r\nu16 pause_time, u16 __maybe_unused thresh_time)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\niowrite32be((u32)pause_time, &regs->pause_quant);\r\nreturn 0;\r\n}\r\nint tgec_accept_rx_pause_frames(struct fman_mac *tgec, bool en)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nu32 tmp;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\ntmp = ioread32be(&regs->command_config);\r\nif (!en)\r\ntmp |= CMD_CFG_PAUSE_IGNORE;\r\nelse\r\ntmp &= ~CMD_CFG_PAUSE_IGNORE;\r\niowrite32be(tmp, &regs->command_config);\r\nreturn 0;\r\n}\r\nint tgec_modify_mac_address(struct fman_mac *tgec, enet_addr_t *p_enet_addr)\r\n{\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\ntgec->addr = ENET_ADDR_TO_UINT64(*p_enet_addr);\r\nset_mac_address(tgec->regs, (u8 *)(*p_enet_addr));\r\nreturn 0;\r\n}\r\nint tgec_add_hash_mac_address(struct fman_mac *tgec, enet_addr_t *eth_addr)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nstruct eth_hash_entry *hash_entry;\r\nu32 crc = 0xFFFFFFFF, hash;\r\nu64 addr;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\naddr = ENET_ADDR_TO_UINT64(*eth_addr);\r\nif (!(addr & GROUP_ADDRESS)) {\r\npr_err("Unicast Address\n");\r\nreturn -EINVAL;\r\n}\r\ncrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\r\ncrc = bitrev32(crc);\r\nhash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;\r\nhash_entry = kmalloc(sizeof(*hash_entry), GFP_KERNEL);\r\nif (!hash_entry)\r\nreturn -ENOMEM;\r\nhash_entry->addr = addr;\r\nINIT_LIST_HEAD(&hash_entry->node);\r\nlist_add_tail(&hash_entry->node,\r\n&tgec->multicast_addr_hash->lsts[hash]);\r\niowrite32be((hash | TGEC_HASH_MCAST_EN), &regs->hashtable_ctrl);\r\nreturn 0;\r\n}\r\nint tgec_del_hash_mac_address(struct fman_mac *tgec, enet_addr_t *eth_addr)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nstruct eth_hash_entry *hash_entry = NULL;\r\nstruct list_head *pos;\r\nu32 crc = 0xFFFFFFFF, hash;\r\nu64 addr;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\naddr = ((*(u64 *)eth_addr) >> 16);\r\ncrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\r\ncrc = bitrev32(crc);\r\nhash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;\r\nlist_for_each(pos, &tgec->multicast_addr_hash->lsts[hash]) {\r\nhash_entry = ETH_HASH_ENTRY_OBJ(pos);\r\nif (hash_entry->addr == addr) {\r\nlist_del_init(&hash_entry->node);\r\nkfree(hash_entry);\r\nbreak;\r\n}\r\n}\r\nif (list_empty(&tgec->multicast_addr_hash->lsts[hash]))\r\niowrite32be((hash & ~TGEC_HASH_MCAST_EN),\r\n&regs->hashtable_ctrl);\r\nreturn 0;\r\n}\r\nint tgec_get_version(struct fman_mac *tgec, u32 *mac_version)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\n*mac_version = ioread32be(&regs->tgec_id);\r\nreturn 0;\r\n}\r\nint tgec_set_exception(struct fman_mac *tgec,\r\nenum fman_mac_exceptions exception, bool enable)\r\n{\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nu32 bit_mask = 0;\r\nif (!is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\nbit_mask = get_exception_flag(exception);\r\nif (bit_mask) {\r\nif (enable)\r\ntgec->exceptions |= bit_mask;\r\nelse\r\ntgec->exceptions &= ~bit_mask;\r\n} else {\r\npr_err("Undefined exception\n");\r\nreturn -EINVAL;\r\n}\r\nif (enable)\r\niowrite32be(ioread32be(&regs->imask) | bit_mask, &regs->imask);\r\nelse\r\niowrite32be(ioread32be(&regs->imask) & ~bit_mask, &regs->imask);\r\nreturn 0;\r\n}\r\nint tgec_init(struct fman_mac *tgec)\r\n{\r\nstruct tgec_cfg *cfg;\r\nenet_addr_t eth_addr;\r\nint err;\r\nif (is_init_done(tgec->cfg))\r\nreturn -EINVAL;\r\nif (DEFAULT_RESET_ON_INIT &&\r\n(fman_reset_mac(tgec->fm, tgec->mac_id) != 0)) {\r\npr_err("Can't reset MAC!\n");\r\nreturn -EINVAL;\r\n}\r\nerr = check_init_parameters(tgec);\r\nif (err)\r\nreturn err;\r\ncfg = tgec->cfg;\r\nMAKE_ENET_ADDR_FROM_UINT64(tgec->addr, eth_addr);\r\nset_mac_address(tgec->regs, (u8 *)eth_addr);\r\nif (tgec->fm_rev_info.major <= 2)\r\ntgec->exceptions &= ~(TGEC_IMASK_REM_FAULT |\r\nTGEC_IMASK_LOC_FAULT);\r\nerr = init(tgec->regs, cfg, tgec->exceptions);\r\nif (err) {\r\nfree_init_resources(tgec);\r\npr_err("TGEC version doesn't support this i/f mode\n");\r\nreturn err;\r\n}\r\nerr = fman_set_mac_max_frame(tgec->fm, tgec->mac_id,\r\ncfg->max_frame_length);\r\nif (err) {\r\npr_err("Setting max frame length FAILED\n");\r\nfree_init_resources(tgec);\r\nreturn -EINVAL;\r\n}\r\nif (tgec->fm_rev_info.major == 2) {\r\nstruct tgec_regs __iomem *regs = tgec->regs;\r\nu32 tmp;\r\ntmp = (ioread32be(&regs->tx_ipg_len) &\r\n~TGEC_TX_IPG_LENGTH_MASK) | 12;\r\niowrite32be(tmp, &regs->tx_ipg_len);\r\n}\r\ntgec->multicast_addr_hash = alloc_hash_table(TGEC_HASH_TABLE_SIZE);\r\nif (!tgec->multicast_addr_hash) {\r\nfree_init_resources(tgec);\r\npr_err("allocation hash table is FAILED\n");\r\nreturn -ENOMEM;\r\n}\r\ntgec->unicast_addr_hash = alloc_hash_table(TGEC_HASH_TABLE_SIZE);\r\nif (!tgec->unicast_addr_hash) {\r\nfree_init_resources(tgec);\r\npr_err("allocation hash table is FAILED\n");\r\nreturn -ENOMEM;\r\n}\r\nfman_register_intr(tgec->fm, FMAN_MOD_MAC, tgec->mac_id,\r\nFMAN_INTR_TYPE_ERR, tgec_err_exception, tgec);\r\nkfree(cfg);\r\ntgec->cfg = NULL;\r\nreturn 0;\r\n}\r\nint tgec_free(struct fman_mac *tgec)\r\n{\r\nfree_init_resources(tgec);\r\nif (tgec->cfg)\r\ntgec->cfg = NULL;\r\nkfree(tgec->cfg);\r\nkfree(tgec);\r\nreturn 0;\r\n}\r\nstruct fman_mac *tgec_config(struct fman_mac_params *params)\r\n{\r\nstruct fman_mac *tgec;\r\nstruct tgec_cfg *cfg;\r\nvoid __iomem *base_addr;\r\nbase_addr = params->base_addr;\r\ntgec = kzalloc(sizeof(*tgec), GFP_KERNEL);\r\nif (!tgec)\r\nreturn NULL;\r\ncfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg) {\r\ntgec_free(tgec);\r\nreturn NULL;\r\n}\r\ntgec->cfg = cfg;\r\nset_dflts(cfg);\r\ntgec->regs = base_addr;\r\ntgec->addr = ENET_ADDR_TO_UINT64(params->addr);\r\ntgec->max_speed = params->max_speed;\r\ntgec->mac_id = params->mac_id;\r\ntgec->exceptions = (TGEC_IMASK_MDIO_SCAN_EVENT |\r\nTGEC_IMASK_REM_FAULT |\r\nTGEC_IMASK_LOC_FAULT |\r\nTGEC_IMASK_TX_ECC_ER |\r\nTGEC_IMASK_TX_FIFO_UNFL |\r\nTGEC_IMASK_TX_FIFO_OVFL |\r\nTGEC_IMASK_TX_ER |\r\nTGEC_IMASK_RX_FIFO_OVFL |\r\nTGEC_IMASK_RX_ECC_ER |\r\nTGEC_IMASK_RX_JAB_FRM |\r\nTGEC_IMASK_RX_OVRSZ_FRM |\r\nTGEC_IMASK_RX_RUNT_FRM |\r\nTGEC_IMASK_RX_FRAG_FRM |\r\nTGEC_IMASK_RX_CRC_ER |\r\nTGEC_IMASK_RX_ALIGN_ER);\r\ntgec->exception_cb = params->exception_cb;\r\ntgec->event_cb = params->event_cb;\r\ntgec->dev_id = params->dev_id;\r\ntgec->fm = params->fm;\r\nfman_get_revision(tgec->fm, &tgec->fm_rev_info);\r\nreturn tgec;\r\n}
