static void dapm_assert_locked(struct snd_soc_dapm_context *dapm)\r\n{\r\nif (dapm->card && dapm->card->instantiated)\r\nlockdep_assert_held(&dapm->card->dapm_mutex);\r\n}\r\nstatic void pop_wait(u32 pop_time)\r\n{\r\nif (pop_time)\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(pop_time));\r\n}\r\nstatic void pop_dbg(struct device *dev, u32 pop_time, const char *fmt, ...)\r\n{\r\nva_list args;\r\nchar *buf;\r\nif (!pop_time)\r\nreturn;\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn;\r\nva_start(args, fmt);\r\nvsnprintf(buf, PAGE_SIZE, fmt, args);\r\ndev_info(dev, "%s", buf);\r\nva_end(args);\r\nkfree(buf);\r\n}\r\nstatic bool dapm_dirty_widget(struct snd_soc_dapm_widget *w)\r\n{\r\nreturn !list_empty(&w->dirty);\r\n}\r\nstatic void dapm_mark_dirty(struct snd_soc_dapm_widget *w, const char *reason)\r\n{\r\ndapm_assert_locked(w->dapm);\r\nif (!dapm_dirty_widget(w)) {\r\ndev_vdbg(w->dapm->dev, "Marking %s dirty due to %s\n",\r\nw->name, reason);\r\nlist_add_tail(&w->dirty, &w->dapm->card->dapm_dirty);\r\n}\r\n}\r\nstatic __always_inline void dapm_widget_invalidate_paths(\r\nstruct snd_soc_dapm_widget *w, enum snd_soc_dapm_direction dir)\r\n{\r\nenum snd_soc_dapm_direction rdir = SND_SOC_DAPM_DIR_REVERSE(dir);\r\nstruct snd_soc_dapm_widget *node;\r\nstruct snd_soc_dapm_path *p;\r\nLIST_HEAD(list);\r\ndapm_assert_locked(w->dapm);\r\nif (w->endpoints[dir] == -1)\r\nreturn;\r\nlist_add_tail(&w->work_list, &list);\r\nw->endpoints[dir] = -1;\r\nlist_for_each_entry(w, &list, work_list) {\r\nsnd_soc_dapm_widget_for_each_path(w, dir, p) {\r\nif (p->is_supply || p->weak || !p->connect)\r\ncontinue;\r\nnode = p->node[rdir];\r\nif (node->endpoints[dir] != -1) {\r\nnode->endpoints[dir] = -1;\r\nlist_add_tail(&node->work_list, &list);\r\n}\r\n}\r\n}\r\n}\r\nstatic void dapm_widget_invalidate_input_paths(struct snd_soc_dapm_widget *w)\r\n{\r\ndapm_widget_invalidate_paths(w, SND_SOC_DAPM_DIR_IN);\r\n}\r\nstatic void dapm_widget_invalidate_output_paths(struct snd_soc_dapm_widget *w)\r\n{\r\ndapm_widget_invalidate_paths(w, SND_SOC_DAPM_DIR_OUT);\r\n}\r\nstatic void dapm_path_invalidate(struct snd_soc_dapm_path *p)\r\n{\r\nif (p->weak || p->is_supply)\r\nreturn;\r\nif (p->source->endpoints[SND_SOC_DAPM_DIR_IN] != 0)\r\ndapm_widget_invalidate_input_paths(p->sink);\r\nif (p->sink->endpoints[SND_SOC_DAPM_DIR_OUT] != 0)\r\ndapm_widget_invalidate_output_paths(p->source);\r\n}\r\nvoid dapm_mark_endpoints_dirty(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nmutex_lock(&card->dapm_mutex);\r\nlist_for_each_entry(w, &card->widgets, list) {\r\nif (w->is_ep) {\r\ndapm_mark_dirty(w, "Rechecking endpoints");\r\nif (w->is_ep & SND_SOC_DAPM_EP_SINK)\r\ndapm_widget_invalidate_output_paths(w);\r\nif (w->is_ep & SND_SOC_DAPM_EP_SOURCE)\r\ndapm_widget_invalidate_input_paths(w);\r\n}\r\n}\r\nmutex_unlock(&card->dapm_mutex);\r\n}\r\nstatic inline struct snd_soc_dapm_widget *dapm_cnew_widget(\r\nconst struct snd_soc_dapm_widget *_widget)\r\n{\r\nreturn kmemdup(_widget, sizeof(*_widget), GFP_KERNEL);\r\n}\r\nstatic int dapm_kcontrol_data_alloc(struct snd_soc_dapm_widget *widget,\r\nstruct snd_kcontrol *kcontrol, const char *ctrl_name)\r\n{\r\nstruct dapm_kcontrol_data *data;\r\nstruct soc_mixer_control *mc;\r\nstruct soc_enum *e;\r\nconst char *name;\r\nint ret;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&data->paths);\r\nswitch (widget->id) {\r\ncase snd_soc_dapm_switch:\r\ncase snd_soc_dapm_mixer:\r\ncase snd_soc_dapm_mixer_named_ctl:\r\nmc = (struct soc_mixer_control *)kcontrol->private_value;\r\nif (mc->autodisable) {\r\nstruct snd_soc_dapm_widget template;\r\nname = kasprintf(GFP_KERNEL, "%s %s", ctrl_name,\r\n"Autodisable");\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto err_data;\r\n}\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.reg = mc->reg;\r\ntemplate.mask = (1 << fls(mc->max)) - 1;\r\ntemplate.shift = mc->shift;\r\nif (mc->invert)\r\ntemplate.off_val = mc->max;\r\nelse\r\ntemplate.off_val = 0;\r\ntemplate.on_val = template.off_val;\r\ntemplate.id = snd_soc_dapm_kcontrol;\r\ntemplate.name = name;\r\ndata->value = template.on_val;\r\ndata->widget =\r\nsnd_soc_dapm_new_control_unlocked(widget->dapm,\r\n&template);\r\nkfree(name);\r\nif (!data->widget) {\r\nret = -ENOMEM;\r\ngoto err_data;\r\n}\r\n}\r\nbreak;\r\ncase snd_soc_dapm_demux:\r\ncase snd_soc_dapm_mux:\r\ne = (struct soc_enum *)kcontrol->private_value;\r\nif (e->autodisable) {\r\nstruct snd_soc_dapm_widget template;\r\nname = kasprintf(GFP_KERNEL, "%s %s", ctrl_name,\r\n"Autodisable");\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto err_data;\r\n}\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.reg = e->reg;\r\ntemplate.mask = e->mask << e->shift_l;\r\ntemplate.shift = e->shift_l;\r\ntemplate.off_val = snd_soc_enum_item_to_val(e, 0);\r\ntemplate.on_val = template.off_val;\r\ntemplate.id = snd_soc_dapm_kcontrol;\r\ntemplate.name = name;\r\ndata->value = template.on_val;\r\ndata->widget = snd_soc_dapm_new_control_unlocked(\r\nwidget->dapm, &template);\r\nkfree(name);\r\nif (!data->widget) {\r\nret = -ENOMEM;\r\ngoto err_data;\r\n}\r\nsnd_soc_dapm_add_path(widget->dapm, data->widget,\r\nwidget, NULL, NULL);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nkcontrol->private_data = data;\r\nreturn 0;\r\nerr_data:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic void dapm_kcontrol_free(struct snd_kcontrol *kctl)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kctl);\r\nkfree(data->wlist);\r\nkfree(data);\r\n}\r\nstatic struct snd_soc_dapm_widget_list *dapm_kcontrol_get_wlist(\r\nconst struct snd_kcontrol *kcontrol)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\r\nreturn data->wlist;\r\n}\r\nstatic int dapm_kcontrol_add_widget(struct snd_kcontrol *kcontrol,\r\nstruct snd_soc_dapm_widget *widget)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget_list *new_wlist;\r\nunsigned int n;\r\nif (data->wlist)\r\nn = data->wlist->num_widgets + 1;\r\nelse\r\nn = 1;\r\nnew_wlist = krealloc(data->wlist,\r\nsizeof(*new_wlist) + sizeof(widget) * n, GFP_KERNEL);\r\nif (!new_wlist)\r\nreturn -ENOMEM;\r\nnew_wlist->widgets[n - 1] = widget;\r\nnew_wlist->num_widgets = n;\r\ndata->wlist = new_wlist;\r\nreturn 0;\r\n}\r\nstatic void dapm_kcontrol_add_path(const struct snd_kcontrol *kcontrol,\r\nstruct snd_soc_dapm_path *path)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\r\nlist_add_tail(&path->list_kcontrol, &data->paths);\r\n}\r\nstatic bool dapm_kcontrol_is_powered(const struct snd_kcontrol *kcontrol)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\r\nif (!data->widget)\r\nreturn true;\r\nreturn data->widget->power;\r\n}\r\nstatic struct list_head *dapm_kcontrol_get_path_list(\r\nconst struct snd_kcontrol *kcontrol)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\r\nreturn &data->paths;\r\n}\r\nunsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\r\nreturn data->value;\r\n}\r\nstatic bool dapm_kcontrol_set_value(const struct snd_kcontrol *kcontrol,\r\nunsigned int value)\r\n{\r\nstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\r\nif (data->value == value)\r\nreturn false;\r\nif (data->widget)\r\ndata->widget->on_val = value;\r\ndata->value = value;\r\nreturn true;\r\n}\r\nstruct snd_soc_dapm_widget *snd_soc_dapm_kcontrol_widget(\r\nstruct snd_kcontrol *kcontrol)\r\n{\r\nreturn dapm_kcontrol_get_wlist(kcontrol)->widgets[0];\r\n}\r\nstruct snd_soc_dapm_context *snd_soc_dapm_kcontrol_dapm(\r\nstruct snd_kcontrol *kcontrol)\r\n{\r\nreturn dapm_kcontrol_get_wlist(kcontrol)->widgets[0]->dapm;\r\n}\r\nstatic void dapm_reset(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nlockdep_assert_held(&card->dapm_mutex);\r\nmemset(&card->dapm_stats, 0, sizeof(card->dapm_stats));\r\nlist_for_each_entry(w, &card->widgets, list) {\r\nw->new_power = w->power;\r\nw->power_checked = false;\r\n}\r\n}\r\nstatic const char *soc_dapm_prefix(struct snd_soc_dapm_context *dapm)\r\n{\r\nif (!dapm->component)\r\nreturn NULL;\r\nreturn dapm->component->name_prefix;\r\n}\r\nstatic int soc_dapm_read(struct snd_soc_dapm_context *dapm, int reg,\r\nunsigned int *value)\r\n{\r\nif (!dapm->component)\r\nreturn -EIO;\r\nreturn snd_soc_component_read(dapm->component, reg, value);\r\n}\r\nstatic int soc_dapm_update_bits(struct snd_soc_dapm_context *dapm,\r\nint reg, unsigned int mask, unsigned int value)\r\n{\r\nif (!dapm->component)\r\nreturn -EIO;\r\nreturn snd_soc_component_update_bits(dapm->component, reg,\r\nmask, value);\r\n}\r\nstatic int soc_dapm_test_bits(struct snd_soc_dapm_context *dapm,\r\nint reg, unsigned int mask, unsigned int value)\r\n{\r\nif (!dapm->component)\r\nreturn -EIO;\r\nreturn snd_soc_component_test_bits(dapm->component, reg, mask, value);\r\n}\r\nstatic void soc_dapm_async_complete(struct snd_soc_dapm_context *dapm)\r\n{\r\nif (dapm->component)\r\nsnd_soc_component_async_complete(dapm->component);\r\n}\r\nstatic struct snd_soc_dapm_widget *\r\ndapm_wcache_lookup(struct snd_soc_dapm_wcache *wcache, const char *name)\r\n{\r\nstruct snd_soc_dapm_widget *w = wcache->widget;\r\nstruct list_head *wlist;\r\nconst int depth = 2;\r\nint i = 0;\r\nif (w) {\r\nwlist = &w->dapm->card->widgets;\r\nlist_for_each_entry_from(w, wlist, list) {\r\nif (!strcmp(name, w->name))\r\nreturn w;\r\nif (++i == depth)\r\nbreak;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void dapm_wcache_update(struct snd_soc_dapm_wcache *wcache,\r\nstruct snd_soc_dapm_widget *w)\r\n{\r\nwcache->widget = w;\r\n}\r\nint snd_soc_dapm_force_bias_level(struct snd_soc_dapm_context *dapm,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret = 0;\r\nif (dapm->set_bias_level)\r\nret = dapm->set_bias_level(dapm, level);\r\nif (ret == 0)\r\ndapm->bias_level = level;\r\nreturn ret;\r\n}\r\nstatic int snd_soc_dapm_set_bias_level(struct snd_soc_dapm_context *dapm,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct snd_soc_card *card = dapm->card;\r\nint ret = 0;\r\ntrace_snd_soc_bias_level_start(card, level);\r\nif (card && card->set_bias_level)\r\nret = card->set_bias_level(card, dapm, level);\r\nif (ret != 0)\r\ngoto out;\r\nif (!card || dapm != &card->dapm)\r\nret = snd_soc_dapm_force_bias_level(dapm, level);\r\nif (ret != 0)\r\ngoto out;\r\nif (card && card->set_bias_level_post)\r\nret = card->set_bias_level_post(card, dapm, level);\r\nout:\r\ntrace_snd_soc_bias_level_done(card, level);\r\nreturn ret;\r\n}\r\nstatic int dapm_connect_mux(struct snd_soc_dapm_context *dapm,\r\nstruct snd_soc_dapm_path *path, const char *control_name,\r\nstruct snd_soc_dapm_widget *w)\r\n{\r\nconst struct snd_kcontrol_new *kcontrol = &w->kcontrol_news[0];\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int val, item;\r\nint i;\r\nif (e->reg != SND_SOC_NOPM) {\r\nsoc_dapm_read(dapm, e->reg, &val);\r\nval = (val >> e->shift_l) & e->mask;\r\nitem = snd_soc_enum_val_to_item(e, val);\r\n} else {\r\nitem = 0;\r\n}\r\nfor (i = 0; i < e->items; i++) {\r\nif (!(strcmp(control_name, e->texts[i]))) {\r\npath->name = e->texts[i];\r\nif (i == item)\r\npath->connect = 1;\r\nelse\r\npath->connect = 0;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void dapm_set_mixer_path_status(struct snd_soc_dapm_path *p, int i)\r\n{\r\nstruct soc_mixer_control *mc = (struct soc_mixer_control *)\r\np->sink->kcontrol_news[i].private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nunsigned int max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned int val;\r\nif (reg != SND_SOC_NOPM) {\r\nsoc_dapm_read(p->sink->dapm, reg, &val);\r\nval = (val >> shift) & mask;\r\nif (invert)\r\nval = max - val;\r\np->connect = !!val;\r\n} else {\r\np->connect = 0;\r\n}\r\n}\r\nstatic int dapm_connect_mixer(struct snd_soc_dapm_context *dapm,\r\nstruct snd_soc_dapm_path *path, const char *control_name)\r\n{\r\nint i;\r\nfor (i = 0; i < path->sink->num_kcontrols; i++) {\r\nif (!strcmp(control_name, path->sink->kcontrol_news[i].name)) {\r\npath->name = path->sink->kcontrol_news[i].name;\r\ndapm_set_mixer_path_status(path, i);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int dapm_is_shared_kcontrol(struct snd_soc_dapm_context *dapm,\r\nstruct snd_soc_dapm_widget *kcontrolw,\r\nconst struct snd_kcontrol_new *kcontrol_new,\r\nstruct snd_kcontrol **kcontrol)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nint i;\r\n*kcontrol = NULL;\r\nlist_for_each_entry(w, &dapm->card->widgets, list) {\r\nif (w == kcontrolw || w->dapm != kcontrolw->dapm)\r\ncontinue;\r\nfor (i = 0; i < w->num_kcontrols; i++) {\r\nif (&w->kcontrol_news[i] == kcontrol_new) {\r\nif (w->kcontrols)\r\n*kcontrol = w->kcontrols[i];\r\nreturn 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dapm_create_or_share_kcontrol(struct snd_soc_dapm_widget *w,\r\nint kci)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct snd_card *card = dapm->card->snd_card;\r\nconst char *prefix;\r\nsize_t prefix_len;\r\nint shared;\r\nstruct snd_kcontrol *kcontrol;\r\nbool wname_in_long_name, kcname_in_long_name;\r\nchar *long_name = NULL;\r\nconst char *name;\r\nint ret = 0;\r\nprefix = soc_dapm_prefix(dapm);\r\nif (prefix)\r\nprefix_len = strlen(prefix) + 1;\r\nelse\r\nprefix_len = 0;\r\nshared = dapm_is_shared_kcontrol(dapm, w, &w->kcontrol_news[kci],\r\n&kcontrol);\r\nif (!kcontrol) {\r\nif (shared) {\r\nwname_in_long_name = false;\r\nkcname_in_long_name = true;\r\n} else {\r\nswitch (w->id) {\r\ncase snd_soc_dapm_switch:\r\ncase snd_soc_dapm_mixer:\r\ncase snd_soc_dapm_pga:\r\nwname_in_long_name = true;\r\nkcname_in_long_name = true;\r\nbreak;\r\ncase snd_soc_dapm_mixer_named_ctl:\r\nwname_in_long_name = false;\r\nkcname_in_long_name = true;\r\nbreak;\r\ncase snd_soc_dapm_demux:\r\ncase snd_soc_dapm_mux:\r\nwname_in_long_name = true;\r\nkcname_in_long_name = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (wname_in_long_name && kcname_in_long_name) {\r\nlong_name = kasprintf(GFP_KERNEL, "%s %s",\r\nw->name + prefix_len,\r\nw->kcontrol_news[kci].name);\r\nif (long_name == NULL)\r\nreturn -ENOMEM;\r\nname = long_name;\r\n} else if (wname_in_long_name) {\r\nlong_name = NULL;\r\nname = w->name + prefix_len;\r\n} else {\r\nlong_name = NULL;\r\nname = w->kcontrol_news[kci].name;\r\n}\r\nkcontrol = snd_soc_cnew(&w->kcontrol_news[kci], NULL, name,\r\nprefix);\r\nif (!kcontrol) {\r\nret = -ENOMEM;\r\ngoto exit_free;\r\n}\r\nkcontrol->private_free = dapm_kcontrol_free;\r\nret = dapm_kcontrol_data_alloc(w, kcontrol, name);\r\nif (ret) {\r\nsnd_ctl_free_one(kcontrol);\r\ngoto exit_free;\r\n}\r\nret = snd_ctl_add(card, kcontrol);\r\nif (ret < 0) {\r\ndev_err(dapm->dev,\r\n"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",\r\nw->name, name, ret);\r\ngoto exit_free;\r\n}\r\n}\r\nret = dapm_kcontrol_add_widget(kcontrol, w);\r\nif (ret == 0)\r\nw->kcontrols[kci] = kcontrol;\r\nexit_free:\r\nkfree(long_name);\r\nreturn ret;\r\n}\r\nstatic int dapm_new_mixer(struct snd_soc_dapm_widget *w)\r\n{\r\nint i, ret;\r\nstruct snd_soc_dapm_path *path;\r\nstruct dapm_kcontrol_data *data;\r\nfor (i = 0; i < w->num_kcontrols; i++) {\r\nsnd_soc_dapm_widget_for_each_source_path(w, path) {\r\nif (path->name != (char *)w->kcontrol_news[i].name)\r\ncontinue;\r\nif (!w->kcontrols[i]) {\r\nret = dapm_create_or_share_kcontrol(w, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndapm_kcontrol_add_path(w->kcontrols[i], path);\r\ndata = snd_kcontrol_chip(w->kcontrols[i]);\r\nif (data->widget)\r\nsnd_soc_dapm_add_path(data->widget->dapm,\r\ndata->widget,\r\npath->source,\r\nNULL, NULL);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dapm_new_mux(struct snd_soc_dapm_widget *w)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nenum snd_soc_dapm_direction dir;\r\nstruct snd_soc_dapm_path *path;\r\nconst char *type;\r\nint ret;\r\nswitch (w->id) {\r\ncase snd_soc_dapm_mux:\r\ndir = SND_SOC_DAPM_DIR_OUT;\r\ntype = "mux";\r\nbreak;\r\ncase snd_soc_dapm_demux:\r\ndir = SND_SOC_DAPM_DIR_IN;\r\ntype = "demux";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (w->num_kcontrols != 1) {\r\ndev_err(dapm->dev,\r\n"ASoC: %s %s has incorrect number of controls\n", type,\r\nw->name);\r\nreturn -EINVAL;\r\n}\r\nif (list_empty(&w->edges[dir])) {\r\ndev_err(dapm->dev, "ASoC: %s %s has no paths\n", type, w->name);\r\nreturn -EINVAL;\r\n}\r\nret = dapm_create_or_share_kcontrol(w, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nsnd_soc_dapm_widget_for_each_path(w, dir, path) {\r\nif (path->name)\r\ndapm_kcontrol_add_path(w->kcontrols[0], path);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dapm_new_pga(struct snd_soc_dapm_widget *w)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < w->num_kcontrols; i++) {\r\nret = dapm_create_or_share_kcontrol(w, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dapm_new_dai_link(struct snd_soc_dapm_widget *w)\r\n{\r\nint i, ret;\r\nstruct snd_kcontrol *kcontrol;\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct snd_card *card = dapm->card->snd_card;\r\nif (w->num_params <= 1)\r\nreturn 0;\r\nfor (i = 0; i < w->num_kcontrols; i++) {\r\nkcontrol = snd_soc_cnew(&w->kcontrol_news[i], w,\r\nw->name, NULL);\r\nret = snd_ctl_add(card, kcontrol);\r\nif (ret < 0) {\r\ndev_err(dapm->dev,\r\n"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",\r\nw->name, w->kcontrol_news[i].name, ret);\r\nreturn ret;\r\n}\r\nkcontrol->private_data = w;\r\nw->kcontrols[i] = kcontrol;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_soc_dapm_suspend_check(struct snd_soc_dapm_widget *widget)\r\n{\r\nint level = snd_power_get_state(widget->dapm->card->snd_card);\r\nswitch (level) {\r\ncase SNDRV_CTL_POWER_D3hot:\r\ncase SNDRV_CTL_POWER_D3cold:\r\nif (widget->ignore_suspend)\r\ndev_dbg(widget->dapm->dev, "ASoC: %s ignoring suspend\n",\r\nwidget->name);\r\nreturn widget->ignore_suspend;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int dapm_widget_list_create(struct snd_soc_dapm_widget_list **list,\r\nstruct list_head *widgets)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nstruct list_head *it;\r\nunsigned int size = 0;\r\nunsigned int i = 0;\r\nlist_for_each(it, widgets)\r\nsize++;\r\n*list = kzalloc(sizeof(**list) + size * sizeof(*w), GFP_KERNEL);\r\nif (*list == NULL)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(w, widgets, work_list)\r\n(*list)->widgets[i++] = w;\r\n(*list)->num_widgets = i;\r\nreturn 0;\r\n}\r\nstatic __always_inline int is_connected_ep(struct snd_soc_dapm_widget *widget,\r\nstruct list_head *list, enum snd_soc_dapm_direction dir,\r\nint (*fn)(struct snd_soc_dapm_widget *, struct list_head *))\r\n{\r\nenum snd_soc_dapm_direction rdir = SND_SOC_DAPM_DIR_REVERSE(dir);\r\nstruct snd_soc_dapm_path *path;\r\nint con = 0;\r\nif (widget->endpoints[dir] >= 0)\r\nreturn widget->endpoints[dir];\r\nDAPM_UPDATE_STAT(widget, path_checks);\r\nif (list)\r\nlist_add_tail(&widget->work_list, list);\r\nif ((widget->is_ep & SND_SOC_DAPM_DIR_TO_EP(dir)) && widget->connected) {\r\nwidget->endpoints[dir] = snd_soc_dapm_suspend_check(widget);\r\nreturn widget->endpoints[dir];\r\n}\r\nsnd_soc_dapm_widget_for_each_path(widget, rdir, path) {\r\nDAPM_UPDATE_STAT(widget, neighbour_checks);\r\nif (path->weak || path->is_supply)\r\ncontinue;\r\nif (path->walking)\r\nreturn 1;\r\ntrace_snd_soc_dapm_path(widget, dir, path);\r\nif (path->connect) {\r\npath->walking = 1;\r\ncon += fn(path->node[dir], list);\r\npath->walking = 0;\r\n}\r\n}\r\nwidget->endpoints[dir] = con;\r\nreturn con;\r\n}\r\nstatic int is_connected_output_ep(struct snd_soc_dapm_widget *widget,\r\nstruct list_head *list)\r\n{\r\nreturn is_connected_ep(widget, list, SND_SOC_DAPM_DIR_OUT,\r\nis_connected_output_ep);\r\n}\r\nstatic int is_connected_input_ep(struct snd_soc_dapm_widget *widget,\r\nstruct list_head *list)\r\n{\r\nreturn is_connected_ep(widget, list, SND_SOC_DAPM_DIR_IN,\r\nis_connected_input_ep);\r\n}\r\nint snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,\r\nstruct snd_soc_dapm_widget_list **list)\r\n{\r\nstruct snd_soc_card *card = dai->component->card;\r\nstruct snd_soc_dapm_widget *w;\r\nLIST_HEAD(widgets);\r\nint paths;\r\nint ret;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nlist_for_each_entry(w, &card->widgets, list) {\r\nw->endpoints[SND_SOC_DAPM_DIR_IN] = -1;\r\nw->endpoints[SND_SOC_DAPM_DIR_OUT] = -1;\r\n}\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\npaths = is_connected_output_ep(dai->playback_widget, &widgets);\r\nelse\r\npaths = is_connected_input_ep(dai->capture_widget, &widgets);\r\nlist_del(widgets.next);\r\nret = dapm_widget_list_create(list, &widgets);\r\nif (ret)\r\npaths = ret;\r\ntrace_snd_soc_dapm_connected(paths, stream);\r\nmutex_unlock(&card->dapm_mutex);\r\nreturn paths;\r\n}\r\nint dapm_regulator_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nint ret;\r\nsoc_dapm_async_complete(w->dapm);\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nif (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {\r\nret = regulator_allow_bypass(w->regulator, false);\r\nif (ret != 0)\r\ndev_warn(w->dapm->dev,\r\n"ASoC: Failed to unbypass %s: %d\n",\r\nw->name, ret);\r\n}\r\nreturn regulator_enable(w->regulator);\r\n} else {\r\nif (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {\r\nret = regulator_allow_bypass(w->regulator, true);\r\nif (ret != 0)\r\ndev_warn(w->dapm->dev,\r\n"ASoC: Failed to bypass %s: %d\n",\r\nw->name, ret);\r\n}\r\nreturn regulator_disable_deferred(w->regulator, w->shift);\r\n}\r\n}\r\nint dapm_clock_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nif (!w->clk)\r\nreturn -EIO;\r\nsoc_dapm_async_complete(w->dapm);\r\n#ifdef CONFIG_HAVE_CLK\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nreturn clk_prepare_enable(w->clk);\r\n} else {\r\nclk_disable_unprepare(w->clk);\r\nreturn 0;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dapm_widget_power_check(struct snd_soc_dapm_widget *w)\r\n{\r\nif (w->power_checked)\r\nreturn w->new_power;\r\nif (w->force)\r\nw->new_power = 1;\r\nelse\r\nw->new_power = w->power_check(w);\r\nw->power_checked = true;\r\nreturn w->new_power;\r\n}\r\nstatic int dapm_generic_check_power(struct snd_soc_dapm_widget *w)\r\n{\r\nint in, out;\r\nDAPM_UPDATE_STAT(w, power_checks);\r\nin = is_connected_input_ep(w, NULL);\r\nout = is_connected_output_ep(w, NULL);\r\nreturn out != 0 && in != 0;\r\n}\r\nstatic int dapm_supply_check_power(struct snd_soc_dapm_widget *w)\r\n{\r\nstruct snd_soc_dapm_path *path;\r\nDAPM_UPDATE_STAT(w, power_checks);\r\nsnd_soc_dapm_widget_for_each_sink_path(w, path) {\r\nDAPM_UPDATE_STAT(w, neighbour_checks);\r\nif (path->weak)\r\ncontinue;\r\nif (path->connected &&\r\n!path->connected(path->source, path->sink))\r\ncontinue;\r\nif (dapm_widget_power_check(path->sink))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dapm_always_on_check_power(struct snd_soc_dapm_widget *w)\r\n{\r\nreturn w->connected;\r\n}\r\nstatic int dapm_seq_compare(struct snd_soc_dapm_widget *a,\r\nstruct snd_soc_dapm_widget *b,\r\nbool power_up)\r\n{\r\nint *sort;\r\nif (power_up)\r\nsort = dapm_up_seq;\r\nelse\r\nsort = dapm_down_seq;\r\nif (sort[a->id] != sort[b->id])\r\nreturn sort[a->id] - sort[b->id];\r\nif (a->subseq != b->subseq) {\r\nif (power_up)\r\nreturn a->subseq - b->subseq;\r\nelse\r\nreturn b->subseq - a->subseq;\r\n}\r\nif (a->reg != b->reg)\r\nreturn a->reg - b->reg;\r\nif (a->dapm != b->dapm)\r\nreturn (unsigned long)a->dapm - (unsigned long)b->dapm;\r\nreturn 0;\r\n}\r\nstatic void dapm_seq_insert(struct snd_soc_dapm_widget *new_widget,\r\nstruct list_head *list,\r\nbool power_up)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nlist_for_each_entry(w, list, power_list)\r\nif (dapm_seq_compare(new_widget, w, power_up) < 0) {\r\nlist_add_tail(&new_widget->power_list, &w->power_list);\r\nreturn;\r\n}\r\nlist_add_tail(&new_widget->power_list, list);\r\n}\r\nstatic void dapm_seq_check_event(struct snd_soc_card *card,\r\nstruct snd_soc_dapm_widget *w, int event)\r\n{\r\nconst char *ev_name;\r\nint power, ret;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nev_name = "PRE_PMU";\r\npower = 1;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nev_name = "POST_PMU";\r\npower = 1;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nev_name = "PRE_PMD";\r\npower = 0;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nev_name = "POST_PMD";\r\npower = 0;\r\nbreak;\r\ncase SND_SOC_DAPM_WILL_PMU:\r\nev_name = "WILL_PMU";\r\npower = 1;\r\nbreak;\r\ncase SND_SOC_DAPM_WILL_PMD:\r\nev_name = "WILL_PMD";\r\npower = 0;\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown event %d\n", event);\r\nreturn;\r\n}\r\nif (w->new_power != power)\r\nreturn;\r\nif (w->event && (w->event_flags & event)) {\r\npop_dbg(w->dapm->dev, card->pop_time, "pop test : %s %s\n",\r\nw->name, ev_name);\r\nsoc_dapm_async_complete(w->dapm);\r\ntrace_snd_soc_dapm_widget_event_start(w, event);\r\nret = w->event(w, NULL, event);\r\ntrace_snd_soc_dapm_widget_event_done(w, event);\r\nif (ret < 0)\r\ndev_err(w->dapm->dev, "ASoC: %s: %s event failed: %d\n",\r\nev_name, w->name, ret);\r\n}\r\n}\r\nstatic void dapm_seq_run_coalesced(struct snd_soc_card *card,\r\nstruct list_head *pending)\r\n{\r\nstruct snd_soc_dapm_context *dapm;\r\nstruct snd_soc_dapm_widget *w;\r\nint reg;\r\nunsigned int value = 0;\r\nunsigned int mask = 0;\r\nw = list_first_entry(pending, struct snd_soc_dapm_widget, power_list);\r\nreg = w->reg;\r\ndapm = w->dapm;\r\nlist_for_each_entry(w, pending, power_list) {\r\nWARN_ON(reg != w->reg || dapm != w->dapm);\r\nw->power = w->new_power;\r\nmask |= w->mask << w->shift;\r\nif (w->power)\r\nvalue |= w->on_val << w->shift;\r\nelse\r\nvalue |= w->off_val << w->shift;\r\npop_dbg(dapm->dev, card->pop_time,\r\n"pop test : Queue %s: reg=0x%x, 0x%x/0x%x\n",\r\nw->name, reg, value, mask);\r\ndapm_seq_check_event(card, w, SND_SOC_DAPM_PRE_PMU);\r\ndapm_seq_check_event(card, w, SND_SOC_DAPM_PRE_PMD);\r\n}\r\nif (reg >= 0) {\r\npop_dbg(dapm->dev, card->pop_time,\r\n"pop test : Applying 0x%x/0x%x to %x in %dms\n",\r\nvalue, mask, reg, card->pop_time);\r\npop_wait(card->pop_time);\r\nsoc_dapm_update_bits(dapm, reg, mask, value);\r\n}\r\nlist_for_each_entry(w, pending, power_list) {\r\ndapm_seq_check_event(card, w, SND_SOC_DAPM_POST_PMU);\r\ndapm_seq_check_event(card, w, SND_SOC_DAPM_POST_PMD);\r\n}\r\n}\r\nstatic void dapm_seq_run(struct snd_soc_card *card,\r\nstruct list_head *list, int event, bool power_up)\r\n{\r\nstruct snd_soc_dapm_widget *w, *n;\r\nstruct snd_soc_dapm_context *d;\r\nLIST_HEAD(pending);\r\nint cur_sort = -1;\r\nint cur_subseq = -1;\r\nint cur_reg = SND_SOC_NOPM;\r\nstruct snd_soc_dapm_context *cur_dapm = NULL;\r\nint ret, i;\r\nint *sort;\r\nif (power_up)\r\nsort = dapm_up_seq;\r\nelse\r\nsort = dapm_down_seq;\r\nlist_for_each_entry_safe(w, n, list, power_list) {\r\nret = 0;\r\nif (sort[w->id] != cur_sort || w->reg != cur_reg ||\r\nw->dapm != cur_dapm || w->subseq != cur_subseq) {\r\nif (!list_empty(&pending))\r\ndapm_seq_run_coalesced(card, &pending);\r\nif (cur_dapm && cur_dapm->seq_notifier) {\r\nfor (i = 0; i < ARRAY_SIZE(dapm_up_seq); i++)\r\nif (sort[i] == cur_sort)\r\ncur_dapm->seq_notifier(cur_dapm,\r\ni,\r\ncur_subseq);\r\n}\r\nif (cur_dapm && w->dapm != cur_dapm)\r\nsoc_dapm_async_complete(cur_dapm);\r\nINIT_LIST_HEAD(&pending);\r\ncur_sort = -1;\r\ncur_subseq = INT_MIN;\r\ncur_reg = SND_SOC_NOPM;\r\ncur_dapm = NULL;\r\n}\r\nswitch (w->id) {\r\ncase snd_soc_dapm_pre:\r\nif (!w->event)\r\nlist_for_each_entry_safe_continue(w, n, list,\r\npower_list);\r\nif (event == SND_SOC_DAPM_STREAM_START)\r\nret = w->event(w,\r\nNULL, SND_SOC_DAPM_PRE_PMU);\r\nelse if (event == SND_SOC_DAPM_STREAM_STOP)\r\nret = w->event(w,\r\nNULL, SND_SOC_DAPM_PRE_PMD);\r\nbreak;\r\ncase snd_soc_dapm_post:\r\nif (!w->event)\r\nlist_for_each_entry_safe_continue(w, n, list,\r\npower_list);\r\nif (event == SND_SOC_DAPM_STREAM_START)\r\nret = w->event(w,\r\nNULL, SND_SOC_DAPM_POST_PMU);\r\nelse if (event == SND_SOC_DAPM_STREAM_STOP)\r\nret = w->event(w,\r\nNULL, SND_SOC_DAPM_POST_PMD);\r\nbreak;\r\ndefault:\r\ncur_sort = sort[w->id];\r\ncur_subseq = w->subseq;\r\ncur_reg = w->reg;\r\ncur_dapm = w->dapm;\r\nlist_move(&w->power_list, &pending);\r\nbreak;\r\n}\r\nif (ret < 0)\r\ndev_err(w->dapm->dev,\r\n"ASoC: Failed to apply widget power: %d\n", ret);\r\n}\r\nif (!list_empty(&pending))\r\ndapm_seq_run_coalesced(card, &pending);\r\nif (cur_dapm && cur_dapm->seq_notifier) {\r\nfor (i = 0; i < ARRAY_SIZE(dapm_up_seq); i++)\r\nif (sort[i] == cur_sort)\r\ncur_dapm->seq_notifier(cur_dapm,\r\ni, cur_subseq);\r\n}\r\nlist_for_each_entry(d, &card->dapm_list, list) {\r\nsoc_dapm_async_complete(d);\r\n}\r\n}\r\nstatic void dapm_widget_update(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dapm_update *update = card->update;\r\nstruct snd_soc_dapm_widget_list *wlist;\r\nstruct snd_soc_dapm_widget *w = NULL;\r\nunsigned int wi;\r\nint ret;\r\nif (!update || !dapm_kcontrol_is_powered(update->kcontrol))\r\nreturn;\r\nwlist = dapm_kcontrol_get_wlist(update->kcontrol);\r\nfor (wi = 0; wi < wlist->num_widgets; wi++) {\r\nw = wlist->widgets[wi];\r\nif (w->event && (w->event_flags & SND_SOC_DAPM_PRE_REG)) {\r\nret = w->event(w, update->kcontrol, SND_SOC_DAPM_PRE_REG);\r\nif (ret != 0)\r\ndev_err(w->dapm->dev, "ASoC: %s DAPM pre-event failed: %d\n",\r\nw->name, ret);\r\n}\r\n}\r\nif (!w)\r\nreturn;\r\nret = soc_dapm_update_bits(w->dapm, update->reg, update->mask,\r\nupdate->val);\r\nif (ret < 0)\r\ndev_err(w->dapm->dev, "ASoC: %s DAPM update failed: %d\n",\r\nw->name, ret);\r\nfor (wi = 0; wi < wlist->num_widgets; wi++) {\r\nw = wlist->widgets[wi];\r\nif (w->event && (w->event_flags & SND_SOC_DAPM_POST_REG)) {\r\nret = w->event(w, update->kcontrol, SND_SOC_DAPM_POST_REG);\r\nif (ret != 0)\r\ndev_err(w->dapm->dev, "ASoC: %s DAPM post-event failed: %d\n",\r\nw->name, ret);\r\n}\r\n}\r\n}\r\nstatic void dapm_pre_sequence_async(void *data, async_cookie_t cookie)\r\n{\r\nstruct snd_soc_dapm_context *d = data;\r\nint ret;\r\nif (d->bias_level == SND_SOC_BIAS_OFF &&\r\nd->target_bias_level != SND_SOC_BIAS_OFF) {\r\nif (d->dev)\r\npm_runtime_get_sync(d->dev);\r\nret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_STANDBY);\r\nif (ret != 0)\r\ndev_err(d->dev,\r\n"ASoC: Failed to turn on bias: %d\n", ret);\r\n}\r\nif ((d->target_bias_level == SND_SOC_BIAS_ON &&\r\nd->bias_level != SND_SOC_BIAS_ON) ||\r\n(d->target_bias_level != SND_SOC_BIAS_ON &&\r\nd->bias_level == SND_SOC_BIAS_ON)) {\r\nret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_PREPARE);\r\nif (ret != 0)\r\ndev_err(d->dev,\r\n"ASoC: Failed to prepare bias: %d\n", ret);\r\n}\r\n}\r\nstatic void dapm_post_sequence_async(void *data, async_cookie_t cookie)\r\n{\r\nstruct snd_soc_dapm_context *d = data;\r\nint ret;\r\nif (d->bias_level == SND_SOC_BIAS_PREPARE &&\r\n(d->target_bias_level == SND_SOC_BIAS_STANDBY ||\r\nd->target_bias_level == SND_SOC_BIAS_OFF)) {\r\nret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_STANDBY);\r\nif (ret != 0)\r\ndev_err(d->dev, "ASoC: Failed to apply standby bias: %d\n",\r\nret);\r\n}\r\nif (d->bias_level == SND_SOC_BIAS_STANDBY &&\r\nd->target_bias_level == SND_SOC_BIAS_OFF) {\r\nret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_OFF);\r\nif (ret != 0)\r\ndev_err(d->dev, "ASoC: Failed to turn off bias: %d\n",\r\nret);\r\nif (d->dev)\r\npm_runtime_put(d->dev);\r\n}\r\nif (d->bias_level == SND_SOC_BIAS_PREPARE &&\r\nd->target_bias_level == SND_SOC_BIAS_ON) {\r\nret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_ON);\r\nif (ret != 0)\r\ndev_err(d->dev, "ASoC: Failed to apply active bias: %d\n",\r\nret);\r\n}\r\n}\r\nstatic void dapm_widget_set_peer_power(struct snd_soc_dapm_widget *peer,\r\nbool power, bool connect)\r\n{\r\nif (!connect)\r\nreturn;\r\nif (power != peer->power)\r\ndapm_mark_dirty(peer, "peer state change");\r\n}\r\nstatic void dapm_widget_set_power(struct snd_soc_dapm_widget *w, bool power,\r\nstruct list_head *up_list,\r\nstruct list_head *down_list)\r\n{\r\nstruct snd_soc_dapm_path *path;\r\nif (w->power == power)\r\nreturn;\r\ntrace_snd_soc_dapm_widget_power(w, power);\r\nsnd_soc_dapm_widget_for_each_source_path(w, path)\r\ndapm_widget_set_peer_power(path->source, power, path->connect);\r\nif (!w->is_supply) {\r\nsnd_soc_dapm_widget_for_each_sink_path(w, path)\r\ndapm_widget_set_peer_power(path->sink, power,\r\npath->connect);\r\n}\r\nif (power)\r\ndapm_seq_insert(w, up_list, true);\r\nelse\r\ndapm_seq_insert(w, down_list, false);\r\n}\r\nstatic void dapm_power_one_widget(struct snd_soc_dapm_widget *w,\r\nstruct list_head *up_list,\r\nstruct list_head *down_list)\r\n{\r\nint power;\r\nswitch (w->id) {\r\ncase snd_soc_dapm_pre:\r\ndapm_seq_insert(w, down_list, false);\r\nbreak;\r\ncase snd_soc_dapm_post:\r\ndapm_seq_insert(w, up_list, true);\r\nbreak;\r\ndefault:\r\npower = dapm_widget_power_check(w);\r\ndapm_widget_set_power(w, power, up_list, down_list);\r\nbreak;\r\n}\r\n}\r\nstatic bool dapm_idle_bias_off(struct snd_soc_dapm_context *dapm)\r\n{\r\nif (dapm->idle_bias_off)\r\nreturn true;\r\nswitch (snd_power_get_state(dapm->card->snd_card)) {\r\ncase SNDRV_CTL_POWER_D3hot:\r\ncase SNDRV_CTL_POWER_D3cold:\r\nreturn dapm->suspend_bias_off;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic int dapm_power_widgets(struct snd_soc_card *card, int event)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nstruct snd_soc_dapm_context *d;\r\nLIST_HEAD(up_list);\r\nLIST_HEAD(down_list);\r\nASYNC_DOMAIN_EXCLUSIVE(async_domain);\r\nenum snd_soc_bias_level bias;\r\nlockdep_assert_held(&card->dapm_mutex);\r\ntrace_snd_soc_dapm_start(card);\r\nlist_for_each_entry(d, &card->dapm_list, list) {\r\nif (dapm_idle_bias_off(d))\r\nd->target_bias_level = SND_SOC_BIAS_OFF;\r\nelse\r\nd->target_bias_level = SND_SOC_BIAS_STANDBY;\r\n}\r\ndapm_reset(card);\r\nlist_for_each_entry(w, &card->dapm_dirty, dirty) {\r\ndapm_power_one_widget(w, &up_list, &down_list);\r\n}\r\nlist_for_each_entry(w, &card->widgets, list) {\r\nswitch (w->id) {\r\ncase snd_soc_dapm_pre:\r\ncase snd_soc_dapm_post:\r\nbreak;\r\ndefault:\r\nlist_del_init(&w->dirty);\r\nbreak;\r\n}\r\nif (w->new_power) {\r\nd = w->dapm;\r\nswitch (w->id) {\r\ncase snd_soc_dapm_siggen:\r\ncase snd_soc_dapm_vmid:\r\nbreak;\r\ncase snd_soc_dapm_supply:\r\ncase snd_soc_dapm_regulator_supply:\r\ncase snd_soc_dapm_clock_supply:\r\ncase snd_soc_dapm_micbias:\r\nif (d->target_bias_level < SND_SOC_BIAS_STANDBY)\r\nd->target_bias_level = SND_SOC_BIAS_STANDBY;\r\nbreak;\r\ndefault:\r\nd->target_bias_level = SND_SOC_BIAS_ON;\r\nbreak;\r\n}\r\n}\r\n}\r\nbias = SND_SOC_BIAS_OFF;\r\nlist_for_each_entry(d, &card->dapm_list, list)\r\nif (d->target_bias_level > bias)\r\nbias = d->target_bias_level;\r\nlist_for_each_entry(d, &card->dapm_list, list)\r\nif (!dapm_idle_bias_off(d))\r\nd->target_bias_level = bias;\r\ntrace_snd_soc_dapm_walk_done(card);\r\ndapm_pre_sequence_async(&card->dapm, 0);\r\nlist_for_each_entry(d, &card->dapm_list, list) {\r\nif (d != &card->dapm)\r\nasync_schedule_domain(dapm_pre_sequence_async, d,\r\n&async_domain);\r\n}\r\nasync_synchronize_full_domain(&async_domain);\r\nlist_for_each_entry(w, &down_list, power_list) {\r\ndapm_seq_check_event(card, w, SND_SOC_DAPM_WILL_PMD);\r\n}\r\nlist_for_each_entry(w, &up_list, power_list) {\r\ndapm_seq_check_event(card, w, SND_SOC_DAPM_WILL_PMU);\r\n}\r\ndapm_seq_run(card, &down_list, event, false);\r\ndapm_widget_update(card);\r\ndapm_seq_run(card, &up_list, event, true);\r\nlist_for_each_entry(d, &card->dapm_list, list) {\r\nif (d != &card->dapm)\r\nasync_schedule_domain(dapm_post_sequence_async, d,\r\n&async_domain);\r\n}\r\nasync_synchronize_full_domain(&async_domain);\r\ndapm_post_sequence_async(&card->dapm, 0);\r\nlist_for_each_entry(d, &card->dapm_list, list) {\r\nif (d->stream_event)\r\nd->stream_event(d, event);\r\n}\r\npop_dbg(card->dev, card->pop_time,\r\n"DAPM sequencing finished, waiting %dms\n", card->pop_time);\r\npop_wait(card->pop_time);\r\ntrace_snd_soc_dapm_done(card);\r\nreturn 0;\r\n}\r\nstatic ssize_t dapm_widget_power_read_file(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct snd_soc_dapm_widget *w = file->private_data;\r\nstruct snd_soc_card *card = w->dapm->card;\r\nenum snd_soc_dapm_direction dir, rdir;\r\nchar *buf;\r\nint in, out;\r\nssize_t ret;\r\nstruct snd_soc_dapm_path *p = NULL;\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nmutex_lock(&card->dapm_mutex);\r\nif (w->is_supply) {\r\nin = 0;\r\nout = 0;\r\n} else {\r\nin = is_connected_input_ep(w, NULL);\r\nout = is_connected_output_ep(w, NULL);\r\n}\r\nret = snprintf(buf, PAGE_SIZE, "%s: %s%s in %d out %d",\r\nw->name, w->power ? "On" : "Off",\r\nw->force ? " (forced)" : "", in, out);\r\nif (w->reg >= 0)\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n" - R%d(0x%x) mask 0x%x",\r\nw->reg, w->reg, w->mask << w->shift);\r\nret += snprintf(buf + ret, PAGE_SIZE - ret, "\n");\r\nif (w->sname)\r\nret += snprintf(buf + ret, PAGE_SIZE - ret, " stream %s %s\n",\r\nw->sname,\r\nw->active ? "active" : "inactive");\r\nsnd_soc_dapm_for_each_direction(dir) {\r\nrdir = SND_SOC_DAPM_DIR_REVERSE(dir);\r\nsnd_soc_dapm_widget_for_each_path(w, dir, p) {\r\nif (p->connected && !p->connected(w, p->node[rdir]))\r\ncontinue;\r\nif (!p->connect)\r\ncontinue;\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n" %s \"%s\" \"%s\"\n",\r\n(rdir == SND_SOC_DAPM_DIR_IN) ? "in" : "out",\r\np->name ? p->name : "static",\r\np->node[rdir]->name);\r\n}\r\n}\r\nmutex_unlock(&card->dapm_mutex);\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t dapm_bias_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct snd_soc_dapm_context *dapm = file->private_data;\r\nchar *level;\r\nswitch (dapm->bias_level) {\r\ncase SND_SOC_BIAS_ON:\r\nlevel = "On\n";\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nlevel = "Prepare\n";\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nlevel = "Standby\n";\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nlevel = "Off\n";\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown bias_level %d\n", dapm->bias_level);\r\nlevel = "Unknown\n";\r\nbreak;\r\n}\r\nreturn simple_read_from_buffer(user_buf, count, ppos, level,\r\nstrlen(level));\r\n}\r\nvoid snd_soc_dapm_debugfs_init(struct snd_soc_dapm_context *dapm,\r\nstruct dentry *parent)\r\n{\r\nstruct dentry *d;\r\nif (!parent)\r\nreturn;\r\ndapm->debugfs_dapm = debugfs_create_dir("dapm", parent);\r\nif (!dapm->debugfs_dapm) {\r\ndev_warn(dapm->dev,\r\n"ASoC: Failed to create DAPM debugfs directory\n");\r\nreturn;\r\n}\r\nd = debugfs_create_file("bias_level", 0444,\r\ndapm->debugfs_dapm, dapm,\r\n&dapm_bias_fops);\r\nif (!d)\r\ndev_warn(dapm->dev,\r\n"ASoC: Failed to create bias level debugfs file\n");\r\n}\r\nstatic void dapm_debugfs_add_widget(struct snd_soc_dapm_widget *w)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct dentry *d;\r\nif (!dapm->debugfs_dapm || !w->name)\r\nreturn;\r\nd = debugfs_create_file(w->name, 0444,\r\ndapm->debugfs_dapm, w,\r\n&dapm_widget_power_fops);\r\nif (!d)\r\ndev_warn(w->dapm->dev,\r\n"ASoC: Failed to create %s debugfs file\n",\r\nw->name);\r\n}\r\nstatic void dapm_debugfs_cleanup(struct snd_soc_dapm_context *dapm)\r\n{\r\ndebugfs_remove_recursive(dapm->debugfs_dapm);\r\n}\r\nvoid snd_soc_dapm_debugfs_init(struct snd_soc_dapm_context *dapm,\r\nstruct dentry *parent)\r\n{\r\n}\r\nstatic inline void dapm_debugfs_add_widget(struct snd_soc_dapm_widget *w)\r\n{\r\n}\r\nstatic inline void dapm_debugfs_cleanup(struct snd_soc_dapm_context *dapm)\r\n{\r\n}\r\nstatic void soc_dapm_connect_path(struct snd_soc_dapm_path *path,\r\nbool connect, const char *reason)\r\n{\r\nif (path->connect == connect)\r\nreturn;\r\npath->connect = connect;\r\ndapm_mark_dirty(path->source, reason);\r\ndapm_mark_dirty(path->sink, reason);\r\ndapm_path_invalidate(path);\r\n}\r\nstatic int soc_dapm_mux_update_power(struct snd_soc_card *card,\r\nstruct snd_kcontrol *kcontrol, int mux, struct soc_enum *e)\r\n{\r\nstruct snd_soc_dapm_path *path;\r\nint found = 0;\r\nbool connect;\r\nlockdep_assert_held(&card->dapm_mutex);\r\ndapm_kcontrol_for_each_path(path, kcontrol) {\r\nfound = 1;\r\nif (!(strcmp(path->name, e->texts[mux])))\r\nconnect = true;\r\nelse\r\nconnect = false;\r\nsoc_dapm_connect_path(path, connect, "mux update");\r\n}\r\nif (found)\r\ndapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);\r\nreturn found;\r\n}\r\nint snd_soc_dapm_mux_update_power(struct snd_soc_dapm_context *dapm,\r\nstruct snd_kcontrol *kcontrol, int mux, struct soc_enum *e,\r\nstruct snd_soc_dapm_update *update)\r\n{\r\nstruct snd_soc_card *card = dapm->card;\r\nint ret;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\ncard->update = update;\r\nret = soc_dapm_mux_update_power(card, kcontrol, mux, e);\r\ncard->update = NULL;\r\nmutex_unlock(&card->dapm_mutex);\r\nif (ret > 0)\r\nsoc_dpcm_runtime_update(card);\r\nreturn ret;\r\n}\r\nstatic int soc_dapm_mixer_update_power(struct snd_soc_card *card,\r\nstruct snd_kcontrol *kcontrol, int connect)\r\n{\r\nstruct snd_soc_dapm_path *path;\r\nint found = 0;\r\nlockdep_assert_held(&card->dapm_mutex);\r\ndapm_kcontrol_for_each_path(path, kcontrol) {\r\nfound = 1;\r\nsoc_dapm_connect_path(path, connect, "mixer update");\r\n}\r\nif (found)\r\ndapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);\r\nreturn found;\r\n}\r\nint snd_soc_dapm_mixer_update_power(struct snd_soc_dapm_context *dapm,\r\nstruct snd_kcontrol *kcontrol, int connect,\r\nstruct snd_soc_dapm_update *update)\r\n{\r\nstruct snd_soc_card *card = dapm->card;\r\nint ret;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\ncard->update = update;\r\nret = soc_dapm_mixer_update_power(card, kcontrol, connect);\r\ncard->update = NULL;\r\nmutex_unlock(&card->dapm_mutex);\r\nif (ret > 0)\r\nsoc_dpcm_runtime_update(card);\r\nreturn ret;\r\n}\r\nstatic ssize_t dapm_widget_show_component(struct snd_soc_component *cmpnt,\r\nchar *buf)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(cmpnt);\r\nstruct snd_soc_dapm_widget *w;\r\nint count = 0;\r\nchar *state = "not set";\r\nif (!cmpnt->card)\r\nreturn 0;\r\nlist_for_each_entry(w, &cmpnt->card->widgets, list) {\r\nif (w->dapm != dapm)\r\ncontinue;\r\nswitch (w->id) {\r\ncase snd_soc_dapm_hp:\r\ncase snd_soc_dapm_mic:\r\ncase snd_soc_dapm_spk:\r\ncase snd_soc_dapm_line:\r\ncase snd_soc_dapm_micbias:\r\ncase snd_soc_dapm_dac:\r\ncase snd_soc_dapm_adc:\r\ncase snd_soc_dapm_pga:\r\ncase snd_soc_dapm_out_drv:\r\ncase snd_soc_dapm_mixer:\r\ncase snd_soc_dapm_mixer_named_ctl:\r\ncase snd_soc_dapm_supply:\r\ncase snd_soc_dapm_regulator_supply:\r\ncase snd_soc_dapm_clock_supply:\r\nif (w->name)\r\ncount += sprintf(buf + count, "%s: %s\n",\r\nw->name, w->power ? "On":"Off");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (snd_soc_dapm_get_bias_level(dapm)) {\r\ncase SND_SOC_BIAS_ON:\r\nstate = "On";\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nstate = "Prepare";\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nstate = "Standby";\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nstate = "Off";\r\nbreak;\r\n}\r\ncount += sprintf(buf + count, "PM State: %s\n", state);\r\nreturn count;\r\n}\r\nstatic ssize_t dapm_widget_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);\r\nint i, count = 0;\r\nmutex_lock(&rtd->card->dapm_mutex);\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nstruct snd_soc_component *cmpnt = rtd->codec_dais[i]->component;\r\ncount += dapm_widget_show_component(cmpnt, buf + count);\r\n}\r\nmutex_unlock(&rtd->card->dapm_mutex);\r\nreturn count;\r\n}\r\nstatic void dapm_free_path(struct snd_soc_dapm_path *path)\r\n{\r\nlist_del(&path->list_node[SND_SOC_DAPM_DIR_IN]);\r\nlist_del(&path->list_node[SND_SOC_DAPM_DIR_OUT]);\r\nlist_del(&path->list_kcontrol);\r\nlist_del(&path->list);\r\nkfree(path);\r\n}\r\nvoid snd_soc_dapm_free_widget(struct snd_soc_dapm_widget *w)\r\n{\r\nstruct snd_soc_dapm_path *p, *next_p;\r\nenum snd_soc_dapm_direction dir;\r\nlist_del(&w->list);\r\nsnd_soc_dapm_for_each_direction(dir) {\r\nsnd_soc_dapm_widget_for_each_path_safe(w, dir, p, next_p)\r\ndapm_free_path(p);\r\n}\r\nkfree(w->kcontrols);\r\nkfree_const(w->name);\r\nkfree(w);\r\n}\r\nvoid snd_soc_dapm_reset_cache(struct snd_soc_dapm_context *dapm)\r\n{\r\ndapm->path_sink_cache.widget = NULL;\r\ndapm->path_source_cache.widget = NULL;\r\n}\r\nstatic void dapm_free_widgets(struct snd_soc_dapm_context *dapm)\r\n{\r\nstruct snd_soc_dapm_widget *w, *next_w;\r\nlist_for_each_entry_safe(w, next_w, &dapm->card->widgets, list) {\r\nif (w->dapm != dapm)\r\ncontinue;\r\nsnd_soc_dapm_free_widget(w);\r\n}\r\nsnd_soc_dapm_reset_cache(dapm);\r\n}\r\nstatic struct snd_soc_dapm_widget *dapm_find_widget(\r\nstruct snd_soc_dapm_context *dapm, const char *pin,\r\nbool search_other_contexts)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nstruct snd_soc_dapm_widget *fallback = NULL;\r\nlist_for_each_entry(w, &dapm->card->widgets, list) {\r\nif (!strcmp(w->name, pin)) {\r\nif (w->dapm == dapm)\r\nreturn w;\r\nelse\r\nfallback = w;\r\n}\r\n}\r\nif (search_other_contexts)\r\nreturn fallback;\r\nreturn NULL;\r\n}\r\nstatic int snd_soc_dapm_set_pin(struct snd_soc_dapm_context *dapm,\r\nconst char *pin, int status)\r\n{\r\nstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);\r\ndapm_assert_locked(dapm);\r\nif (!w) {\r\ndev_err(dapm->dev, "ASoC: DAPM unknown pin %s\n", pin);\r\nreturn -EINVAL;\r\n}\r\nif (w->connected != status) {\r\ndapm_mark_dirty(w, "pin configuration");\r\ndapm_widget_invalidate_input_paths(w);\r\ndapm_widget_invalidate_output_paths(w);\r\n}\r\nw->connected = status;\r\nif (status == 0)\r\nw->force = 0;\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_sync_unlocked(struct snd_soc_dapm_context *dapm)\r\n{\r\nif (!dapm->card || !dapm->card->instantiated)\r\nreturn 0;\r\nreturn dapm_power_widgets(dapm->card, SND_SOC_DAPM_STREAM_NOP);\r\n}\r\nint snd_soc_dapm_sync(struct snd_soc_dapm_context *dapm)\r\n{\r\nint ret;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nret = snd_soc_dapm_sync_unlocked(dapm);\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nstatic void dapm_update_widget_flags(struct snd_soc_dapm_widget *w)\r\n{\r\nenum snd_soc_dapm_direction dir;\r\nstruct snd_soc_dapm_path *p;\r\nunsigned int ep;\r\nswitch (w->id) {\r\ncase snd_soc_dapm_input:\r\nif (w->dapm->card->fully_routed)\r\nreturn;\r\nep = SND_SOC_DAPM_EP_SOURCE;\r\nsnd_soc_dapm_widget_for_each_source_path(w, p) {\r\nif (p->source->id == snd_soc_dapm_micbias ||\r\np->source->id == snd_soc_dapm_mic ||\r\np->source->id == snd_soc_dapm_line ||\r\np->source->id == snd_soc_dapm_output) {\r\nep = 0;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase snd_soc_dapm_output:\r\nif (w->dapm->card->fully_routed)\r\nreturn;\r\nep = SND_SOC_DAPM_EP_SINK;\r\nsnd_soc_dapm_widget_for_each_sink_path(w, p) {\r\nif (p->sink->id == snd_soc_dapm_spk ||\r\np->sink->id == snd_soc_dapm_hp ||\r\np->sink->id == snd_soc_dapm_line ||\r\np->sink->id == snd_soc_dapm_input) {\r\nep = 0;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase snd_soc_dapm_line:\r\nep = 0;\r\nsnd_soc_dapm_for_each_direction(dir) {\r\nif (!list_empty(&w->edges[dir]))\r\nep |= SND_SOC_DAPM_DIR_TO_EP(dir);\r\n}\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nw->is_ep = ep;\r\n}\r\nstatic int snd_soc_dapm_check_dynamic_path(struct snd_soc_dapm_context *dapm,\r\nstruct snd_soc_dapm_widget *source, struct snd_soc_dapm_widget *sink,\r\nconst char *control)\r\n{\r\nbool dynamic_source = false;\r\nbool dynamic_sink = false;\r\nif (!control)\r\nreturn 0;\r\nswitch (source->id) {\r\ncase snd_soc_dapm_demux:\r\ndynamic_source = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (sink->id) {\r\ncase snd_soc_dapm_mux:\r\ncase snd_soc_dapm_switch:\r\ncase snd_soc_dapm_mixer:\r\ncase snd_soc_dapm_mixer_named_ctl:\r\ndynamic_sink = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (dynamic_source && dynamic_sink) {\r\ndev_err(dapm->dev,\r\n"Direct connection between demux and mixer/mux not supported for path %s -> [%s] -> %s\n",\r\nsource->name, control, sink->name);\r\nreturn -EINVAL;\r\n} else if (!dynamic_source && !dynamic_sink) {\r\ndev_err(dapm->dev,\r\n"Control not supported for path %s -> [%s] -> %s\n",\r\nsource->name, control, sink->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm,\r\nstruct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,\r\nconst char *control,\r\nint (*connected)(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink))\r\n{\r\nstruct snd_soc_dapm_widget *widgets[2];\r\nenum snd_soc_dapm_direction dir;\r\nstruct snd_soc_dapm_path *path;\r\nint ret;\r\nif (wsink->is_supply && !wsource->is_supply) {\r\ndev_err(dapm->dev,\r\n"Connecting non-supply widget to supply widget is not supported (%s -> %s)\n",\r\nwsource->name, wsink->name);\r\nreturn -EINVAL;\r\n}\r\nif (connected && !wsource->is_supply) {\r\ndev_err(dapm->dev,\r\n"connected() callback only supported for supply widgets (%s -> %s)\n",\r\nwsource->name, wsink->name);\r\nreturn -EINVAL;\r\n}\r\nif (wsource->is_supply && control) {\r\ndev_err(dapm->dev,\r\n"Conditional paths are not supported for supply widgets (%s -> [%s] -> %s)\n",\r\nwsource->name, control, wsink->name);\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_dapm_check_dynamic_path(dapm, wsource, wsink, control);\r\nif (ret)\r\nreturn ret;\r\npath = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->node[SND_SOC_DAPM_DIR_IN] = wsource;\r\npath->node[SND_SOC_DAPM_DIR_OUT] = wsink;\r\nwidgets[SND_SOC_DAPM_DIR_IN] = wsource;\r\nwidgets[SND_SOC_DAPM_DIR_OUT] = wsink;\r\npath->connected = connected;\r\nINIT_LIST_HEAD(&path->list);\r\nINIT_LIST_HEAD(&path->list_kcontrol);\r\nif (wsource->is_supply || wsink->is_supply)\r\npath->is_supply = 1;\r\nif (control == NULL) {\r\npath->connect = 1;\r\n} else {\r\nswitch (wsource->id) {\r\ncase snd_soc_dapm_demux:\r\nret = dapm_connect_mux(dapm, path, control, wsource);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (wsink->id) {\r\ncase snd_soc_dapm_mux:\r\nret = dapm_connect_mux(dapm, path, control, wsink);\r\nif (ret != 0)\r\ngoto err;\r\nbreak;\r\ncase snd_soc_dapm_switch:\r\ncase snd_soc_dapm_mixer:\r\ncase snd_soc_dapm_mixer_named_ctl:\r\nret = dapm_connect_mixer(dapm, path, control);\r\nif (ret != 0)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nlist_add(&path->list, &dapm->card->paths);\r\nsnd_soc_dapm_for_each_direction(dir)\r\nlist_add(&path->list_node[dir], &widgets[dir]->edges[dir]);\r\nsnd_soc_dapm_for_each_direction(dir) {\r\ndapm_update_widget_flags(widgets[dir]);\r\ndapm_mark_dirty(widgets[dir], "Route added");\r\n}\r\nif (dapm->card->instantiated && path->connect)\r\ndapm_path_invalidate(path);\r\nreturn 0;\r\nerr:\r\nkfree(path);\r\nreturn ret;\r\n}\r\nstatic int snd_soc_dapm_add_route(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_route *route)\r\n{\r\nstruct snd_soc_dapm_widget *wsource = NULL, *wsink = NULL, *w;\r\nstruct snd_soc_dapm_widget *wtsource = NULL, *wtsink = NULL;\r\nconst char *sink;\r\nconst char *source;\r\nchar prefixed_sink[80];\r\nchar prefixed_source[80];\r\nconst char *prefix;\r\nint ret;\r\nprefix = soc_dapm_prefix(dapm);\r\nif (prefix) {\r\nsnprintf(prefixed_sink, sizeof(prefixed_sink), "%s %s",\r\nprefix, route->sink);\r\nsink = prefixed_sink;\r\nsnprintf(prefixed_source, sizeof(prefixed_source), "%s %s",\r\nprefix, route->source);\r\nsource = prefixed_source;\r\n} else {\r\nsink = route->sink;\r\nsource = route->source;\r\n}\r\nwsource = dapm_wcache_lookup(&dapm->path_source_cache, source);\r\nwsink = dapm_wcache_lookup(&dapm->path_sink_cache, sink);\r\nif (wsink && wsource)\r\ngoto skip_search;\r\nlist_for_each_entry(w, &dapm->card->widgets, list) {\r\nif (!wsink && !(strcmp(w->name, sink))) {\r\nwtsink = w;\r\nif (w->dapm == dapm) {\r\nwsink = w;\r\nif (wsource)\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nif (!wsource && !(strcmp(w->name, source))) {\r\nwtsource = w;\r\nif (w->dapm == dapm) {\r\nwsource = w;\r\nif (wsink)\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!wsink)\r\nwsink = wtsink;\r\nif (!wsource)\r\nwsource = wtsource;\r\nif (wsource == NULL) {\r\ndev_err(dapm->dev, "ASoC: no source widget found for %s\n",\r\nroute->source);\r\nreturn -ENODEV;\r\n}\r\nif (wsink == NULL) {\r\ndev_err(dapm->dev, "ASoC: no sink widget found for %s\n",\r\nroute->sink);\r\nreturn -ENODEV;\r\n}\r\nskip_search:\r\ndapm_wcache_update(&dapm->path_sink_cache, wsink);\r\ndapm_wcache_update(&dapm->path_source_cache, wsource);\r\nret = snd_soc_dapm_add_path(dapm, wsource, wsink, route->control,\r\nroute->connected);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_warn(dapm->dev, "ASoC: no dapm match for %s --> %s --> %s\n",\r\nsource, route->control, sink);\r\nreturn ret;\r\n}\r\nstatic int snd_soc_dapm_del_route(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_route *route)\r\n{\r\nstruct snd_soc_dapm_widget *wsource, *wsink;\r\nstruct snd_soc_dapm_path *path, *p;\r\nconst char *sink;\r\nconst char *source;\r\nchar prefixed_sink[80];\r\nchar prefixed_source[80];\r\nconst char *prefix;\r\nif (route->control) {\r\ndev_err(dapm->dev,\r\n"ASoC: Removal of routes with controls not supported\n");\r\nreturn -EINVAL;\r\n}\r\nprefix = soc_dapm_prefix(dapm);\r\nif (prefix) {\r\nsnprintf(prefixed_sink, sizeof(prefixed_sink), "%s %s",\r\nprefix, route->sink);\r\nsink = prefixed_sink;\r\nsnprintf(prefixed_source, sizeof(prefixed_source), "%s %s",\r\nprefix, route->source);\r\nsource = prefixed_source;\r\n} else {\r\nsink = route->sink;\r\nsource = route->source;\r\n}\r\npath = NULL;\r\nlist_for_each_entry(p, &dapm->card->paths, list) {\r\nif (strcmp(p->source->name, source) != 0)\r\ncontinue;\r\nif (strcmp(p->sink->name, sink) != 0)\r\ncontinue;\r\npath = p;\r\nbreak;\r\n}\r\nif (path) {\r\nwsource = path->source;\r\nwsink = path->sink;\r\ndapm_mark_dirty(wsource, "Route removed");\r\ndapm_mark_dirty(wsink, "Route removed");\r\nif (path->connect)\r\ndapm_path_invalidate(path);\r\ndapm_free_path(path);\r\ndapm_update_widget_flags(wsource);\r\ndapm_update_widget_flags(wsink);\r\n} else {\r\ndev_warn(dapm->dev, "ASoC: Route %s->%s does not exist\n",\r\nsource, sink);\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_add_routes(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_route *route, int num)\r\n{\r\nint i, r, ret = 0;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);\r\nfor (i = 0; i < num; i++) {\r\nr = snd_soc_dapm_add_route(dapm, route);\r\nif (r < 0) {\r\ndev_err(dapm->dev, "ASoC: Failed to add route %s -> %s -> %s\n",\r\nroute->source,\r\nroute->control ? route->control : "direct",\r\nroute->sink);\r\nret = r;\r\n}\r\nroute++;\r\n}\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_del_routes(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_route *route, int num)\r\n{\r\nint i;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);\r\nfor (i = 0; i < num; i++) {\r\nsnd_soc_dapm_del_route(dapm, route);\r\nroute++;\r\n}\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_soc_dapm_weak_route(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_route *route)\r\n{\r\nstruct snd_soc_dapm_widget *source = dapm_find_widget(dapm,\r\nroute->source,\r\ntrue);\r\nstruct snd_soc_dapm_widget *sink = dapm_find_widget(dapm,\r\nroute->sink,\r\ntrue);\r\nstruct snd_soc_dapm_path *path;\r\nint count = 0;\r\nif (!source) {\r\ndev_err(dapm->dev, "ASoC: Unable to find source %s for weak route\n",\r\nroute->source);\r\nreturn -ENODEV;\r\n}\r\nif (!sink) {\r\ndev_err(dapm->dev, "ASoC: Unable to find sink %s for weak route\n",\r\nroute->sink);\r\nreturn -ENODEV;\r\n}\r\nif (route->control || route->connected)\r\ndev_warn(dapm->dev, "ASoC: Ignoring control for weak route %s->%s\n",\r\nroute->source, route->sink);\r\nsnd_soc_dapm_widget_for_each_sink_path(source, path) {\r\nif (path->sink == sink) {\r\npath->weak = 1;\r\ncount++;\r\n}\r\n}\r\nif (count == 0)\r\ndev_err(dapm->dev, "ASoC: No path found for weak route %s->%s\n",\r\nroute->source, route->sink);\r\nif (count > 1)\r\ndev_warn(dapm->dev, "ASoC: %d paths found for weak route %s->%s\n",\r\ncount, route->source, route->sink);\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_weak_routes(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_route *route, int num)\r\n{\r\nint i, err;\r\nint ret = 0;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);\r\nfor (i = 0; i < num; i++) {\r\nerr = snd_soc_dapm_weak_route(dapm, route);\r\nif (err)\r\nret = err;\r\nroute++;\r\n}\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_new_widgets(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nunsigned int val;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);\r\nlist_for_each_entry(w, &card->widgets, list)\r\n{\r\nif (w->new)\r\ncontinue;\r\nif (w->num_kcontrols) {\r\nw->kcontrols = kzalloc(w->num_kcontrols *\r\nsizeof(struct snd_kcontrol *),\r\nGFP_KERNEL);\r\nif (!w->kcontrols) {\r\nmutex_unlock(&card->dapm_mutex);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nswitch(w->id) {\r\ncase snd_soc_dapm_switch:\r\ncase snd_soc_dapm_mixer:\r\ncase snd_soc_dapm_mixer_named_ctl:\r\ndapm_new_mixer(w);\r\nbreak;\r\ncase snd_soc_dapm_mux:\r\ncase snd_soc_dapm_demux:\r\ndapm_new_mux(w);\r\nbreak;\r\ncase snd_soc_dapm_pga:\r\ncase snd_soc_dapm_out_drv:\r\ndapm_new_pga(w);\r\nbreak;\r\ncase snd_soc_dapm_dai_link:\r\ndapm_new_dai_link(w);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (w->reg >= 0) {\r\nsoc_dapm_read(w->dapm, w->reg, &val);\r\nval = val >> w->shift;\r\nval &= w->mask;\r\nif (val == w->on_val)\r\nw->power = 1;\r\n}\r\nw->new = 1;\r\ndapm_mark_dirty(w, "new widget");\r\ndapm_debugfs_add_widget(w);\r\n}\r\ndapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);\r\nmutex_unlock(&card->dapm_mutex);\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned int val;\r\nint ret = 0;\r\nif (snd_soc_volsw_is_stereo(mc))\r\ndev_warn(dapm->dev,\r\n"ASoC: Control '%s' is stereo, which is not supported\n",\r\nkcontrol->id.name);\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nif (dapm_kcontrol_is_powered(kcontrol) && reg != SND_SOC_NOPM) {\r\nret = soc_dapm_read(dapm, reg, &val);\r\nval = (val >> shift) & mask;\r\n} else {\r\nval = dapm_kcontrol_get_value(kcontrol);\r\n}\r\nmutex_unlock(&card->dapm_mutex);\r\nif (invert)\r\nucontrol->value.integer.value[0] = max - val;\r\nelse\r\nucontrol->value.integer.value[0] = val;\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned int val;\r\nint connect, change, reg_change = 0;\r\nstruct snd_soc_dapm_update update;\r\nint ret = 0;\r\nif (snd_soc_volsw_is_stereo(mc))\r\ndev_warn(dapm->dev,\r\n"ASoC: Control '%s' is stereo, which is not supported\n",\r\nkcontrol->id.name);\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nconnect = !!val;\r\nif (invert)\r\nval = max - val;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nchange = dapm_kcontrol_set_value(kcontrol, val);\r\nif (reg != SND_SOC_NOPM) {\r\nmask = mask << shift;\r\nval = val << shift;\r\nreg_change = soc_dapm_test_bits(dapm, reg, mask, val);\r\n}\r\nif (change || reg_change) {\r\nif (reg_change) {\r\nupdate.kcontrol = kcontrol;\r\nupdate.reg = reg;\r\nupdate.mask = mask;\r\nupdate.val = val;\r\ncard->update = &update;\r\n}\r\nchange |= reg_change;\r\nret = soc_dapm_mixer_update_power(card, kcontrol, connect);\r\ncard->update = NULL;\r\n}\r\nmutex_unlock(&card->dapm_mutex);\r\nif (ret > 0)\r\nsoc_dpcm_runtime_update(card);\r\nreturn change;\r\n}\r\nint snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int reg_val, val;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nif (e->reg != SND_SOC_NOPM && dapm_kcontrol_is_powered(kcontrol)) {\r\nint ret = soc_dapm_read(dapm, e->reg, &reg_val);\r\nif (ret) {\r\nmutex_unlock(&card->dapm_mutex);\r\nreturn ret;\r\n}\r\n} else {\r\nreg_val = dapm_kcontrol_get_value(kcontrol);\r\n}\r\nmutex_unlock(&card->dapm_mutex);\r\nval = (reg_val >> e->shift_l) & e->mask;\r\nucontrol->value.enumerated.item[0] = snd_soc_enum_val_to_item(e, val);\r\nif (e->shift_l != e->shift_r) {\r\nval = (reg_val >> e->shift_r) & e->mask;\r\nval = snd_soc_enum_val_to_item(e, val);\r\nucontrol->value.enumerated.item[1] = val;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int *item = ucontrol->value.enumerated.item;\r\nunsigned int val, change, reg_change = 0;\r\nunsigned int mask;\r\nstruct snd_soc_dapm_update update;\r\nint ret = 0;\r\nif (item[0] >= e->items)\r\nreturn -EINVAL;\r\nval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\r\nmask = e->mask << e->shift_l;\r\nif (e->shift_l != e->shift_r) {\r\nif (item[1] > e->items)\r\nreturn -EINVAL;\r\nval |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_l;\r\nmask |= e->mask << e->shift_r;\r\n}\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nchange = dapm_kcontrol_set_value(kcontrol, val);\r\nif (e->reg != SND_SOC_NOPM)\r\nreg_change = soc_dapm_test_bits(dapm, e->reg, mask, val);\r\nif (change || reg_change) {\r\nif (reg_change) {\r\nupdate.kcontrol = kcontrol;\r\nupdate.reg = e->reg;\r\nupdate.mask = mask;\r\nupdate.val = val;\r\ncard->update = &update;\r\n}\r\nchange |= reg_change;\r\nret = soc_dapm_mux_update_power(card, kcontrol, item[0], e);\r\ncard->update = NULL;\r\n}\r\nmutex_unlock(&card->dapm_mutex);\r\nif (ret > 0)\r\nsoc_dpcm_runtime_update(card);\r\nreturn change;\r\n}\r\nint snd_soc_dapm_info_pin_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_get_pin_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\r\nconst char *pin = (const char *)kcontrol->private_value;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nucontrol->value.integer.value[0] =\r\nsnd_soc_dapm_get_pin_status(&card->dapm, pin);\r\nmutex_unlock(&card->dapm_mutex);\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_put_pin_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\r\nconst char *pin = (const char *)kcontrol->private_value;\r\nif (ucontrol->value.integer.value[0])\r\nsnd_soc_dapm_enable_pin(&card->dapm, pin);\r\nelse\r\nsnd_soc_dapm_disable_pin(&card->dapm, pin);\r\nsnd_soc_dapm_sync(&card->dapm);\r\nreturn 0;\r\n}\r\nstruct snd_soc_dapm_widget *\r\nsnd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_widget *widget)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nw = snd_soc_dapm_new_control_unlocked(dapm, widget);\r\nif (!w)\r\ndev_err(dapm->dev,\r\n"ASoC: Failed to create DAPM control %s\n",\r\nwidget->name);\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn w;\r\n}\r\nstruct snd_soc_dapm_widget *\r\nsnd_soc_dapm_new_control_unlocked(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_widget *widget)\r\n{\r\nenum snd_soc_dapm_direction dir;\r\nstruct snd_soc_dapm_widget *w;\r\nconst char *prefix;\r\nint ret;\r\nif ((w = dapm_cnew_widget(widget)) == NULL)\r\nreturn NULL;\r\nswitch (w->id) {\r\ncase snd_soc_dapm_regulator_supply:\r\nw->regulator = devm_regulator_get(dapm->dev, w->name);\r\nif (IS_ERR(w->regulator)) {\r\nret = PTR_ERR(w->regulator);\r\ndev_err(dapm->dev, "ASoC: Failed to request %s: %d\n",\r\nw->name, ret);\r\nreturn NULL;\r\n}\r\nif (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {\r\nret = regulator_allow_bypass(w->regulator, true);\r\nif (ret != 0)\r\ndev_warn(w->dapm->dev,\r\n"ASoC: Failed to bypass %s: %d\n",\r\nw->name, ret);\r\n}\r\nbreak;\r\ncase snd_soc_dapm_clock_supply:\r\n#ifdef CONFIG_CLKDEV_LOOKUP\r\nw->clk = devm_clk_get(dapm->dev, w->name);\r\nif (IS_ERR(w->clk)) {\r\nret = PTR_ERR(w->clk);\r\ndev_err(dapm->dev, "ASoC: Failed to request %s: %d\n",\r\nw->name, ret);\r\nreturn NULL;\r\n}\r\n#else\r\nreturn NULL;\r\n#endif\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nprefix = soc_dapm_prefix(dapm);\r\nif (prefix)\r\nw->name = kasprintf(GFP_KERNEL, "%s %s", prefix, widget->name);\r\nelse\r\nw->name = kstrdup_const(widget->name, GFP_KERNEL);\r\nif (w->name == NULL) {\r\nkfree(w);\r\nreturn NULL;\r\n}\r\nswitch (w->id) {\r\ncase snd_soc_dapm_mic:\r\nw->is_ep = SND_SOC_DAPM_EP_SOURCE;\r\nw->power_check = dapm_generic_check_power;\r\nbreak;\r\ncase snd_soc_dapm_input:\r\nif (!dapm->card->fully_routed)\r\nw->is_ep = SND_SOC_DAPM_EP_SOURCE;\r\nw->power_check = dapm_generic_check_power;\r\nbreak;\r\ncase snd_soc_dapm_spk:\r\ncase snd_soc_dapm_hp:\r\nw->is_ep = SND_SOC_DAPM_EP_SINK;\r\nw->power_check = dapm_generic_check_power;\r\nbreak;\r\ncase snd_soc_dapm_output:\r\nif (!dapm->card->fully_routed)\r\nw->is_ep = SND_SOC_DAPM_EP_SINK;\r\nw->power_check = dapm_generic_check_power;\r\nbreak;\r\ncase snd_soc_dapm_vmid:\r\ncase snd_soc_dapm_siggen:\r\nw->is_ep = SND_SOC_DAPM_EP_SOURCE;\r\nw->power_check = dapm_always_on_check_power;\r\nbreak;\r\ncase snd_soc_dapm_sink:\r\nw->is_ep = SND_SOC_DAPM_EP_SINK;\r\nw->power_check = dapm_always_on_check_power;\r\nbreak;\r\ncase snd_soc_dapm_mux:\r\ncase snd_soc_dapm_demux:\r\ncase snd_soc_dapm_switch:\r\ncase snd_soc_dapm_mixer:\r\ncase snd_soc_dapm_mixer_named_ctl:\r\ncase snd_soc_dapm_adc:\r\ncase snd_soc_dapm_aif_out:\r\ncase snd_soc_dapm_dac:\r\ncase snd_soc_dapm_aif_in:\r\ncase snd_soc_dapm_pga:\r\ncase snd_soc_dapm_out_drv:\r\ncase snd_soc_dapm_micbias:\r\ncase snd_soc_dapm_line:\r\ncase snd_soc_dapm_dai_link:\r\ncase snd_soc_dapm_dai_out:\r\ncase snd_soc_dapm_dai_in:\r\nw->power_check = dapm_generic_check_power;\r\nbreak;\r\ncase snd_soc_dapm_supply:\r\ncase snd_soc_dapm_regulator_supply:\r\ncase snd_soc_dapm_clock_supply:\r\ncase snd_soc_dapm_kcontrol:\r\nw->is_supply = 1;\r\nw->power_check = dapm_supply_check_power;\r\nbreak;\r\ndefault:\r\nw->power_check = dapm_always_on_check_power;\r\nbreak;\r\n}\r\nw->dapm = dapm;\r\nINIT_LIST_HEAD(&w->list);\r\nINIT_LIST_HEAD(&w->dirty);\r\nlist_add_tail(&w->list, &dapm->card->widgets);\r\nsnd_soc_dapm_for_each_direction(dir) {\r\nINIT_LIST_HEAD(&w->edges[dir]);\r\nw->endpoints[dir] = -1;\r\n}\r\nw->connected = 1;\r\nreturn w;\r\n}\r\nint snd_soc_dapm_new_controls(struct snd_soc_dapm_context *dapm,\r\nconst struct snd_soc_dapm_widget *widget,\r\nint num)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nint i;\r\nint ret = 0;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_INIT);\r\nfor (i = 0; i < num; i++) {\r\nw = snd_soc_dapm_new_control_unlocked(dapm, widget);\r\nif (!w) {\r\ndev_err(dapm->dev,\r\n"ASoC: Failed to create DAPM control %s\n",\r\nwidget->name);\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nwidget++;\r\n}\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nstatic int snd_soc_dai_link_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_dapm_path *source_p, *sink_p;\r\nstruct snd_soc_dai *source, *sink;\r\nconst struct snd_soc_pcm_stream *config = w->params + w->params_select;\r\nstruct snd_pcm_substream substream;\r\nstruct snd_pcm_hw_params *params = NULL;\r\nu64 fmt;\r\nint ret;\r\nif (WARN_ON(!config) ||\r\nWARN_ON(list_empty(&w->edges[SND_SOC_DAPM_DIR_OUT]) ||\r\nlist_empty(&w->edges[SND_SOC_DAPM_DIR_IN])))\r\nreturn -EINVAL;\r\nsource_p = list_first_entry(&w->edges[SND_SOC_DAPM_DIR_OUT],\r\nstruct snd_soc_dapm_path,\r\nlist_node[SND_SOC_DAPM_DIR_OUT]);\r\nsink_p = list_first_entry(&w->edges[SND_SOC_DAPM_DIR_IN],\r\nstruct snd_soc_dapm_path,\r\nlist_node[SND_SOC_DAPM_DIR_IN]);\r\nsource = source_p->source->priv;\r\nsink = sink_p->sink->priv;\r\nif (config->formats) {\r\nfmt = ffs(config->formats) - 1;\r\n} else {\r\ndev_warn(w->dapm->dev, "ASoC: Invalid format %llx specified\n",\r\nconfig->formats);\r\nfmt = 0;\r\n}\r\nparams = kzalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsnd_mask_set(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT), fmt);\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min =\r\nconfig->rate_min;\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->max =\r\nconfig->rate_max;\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS)->min\r\n= config->channels_min;\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS)->max\r\n= config->channels_max;\r\nmemset(&substream, 0, sizeof(substream));\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsubstream.stream = SNDRV_PCM_STREAM_CAPTURE;\r\nif (source->driver->ops && source->driver->ops->startup) {\r\nret = source->driver->ops->startup(&substream, source);\r\nif (ret < 0) {\r\ndev_err(source->dev,\r\n"ASoC: startup() failed: %d\n", ret);\r\ngoto out;\r\n}\r\nsource->active++;\r\n}\r\nret = soc_dai_hw_params(&substream, params, source);\r\nif (ret < 0)\r\ngoto out;\r\nsubstream.stream = SNDRV_PCM_STREAM_PLAYBACK;\r\nif (sink->driver->ops && sink->driver->ops->startup) {\r\nret = sink->driver->ops->startup(&substream, sink);\r\nif (ret < 0) {\r\ndev_err(sink->dev,\r\n"ASoC: startup() failed: %d\n", ret);\r\ngoto out;\r\n}\r\nsink->active++;\r\n}\r\nret = soc_dai_hw_params(&substream, params, sink);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nret = snd_soc_dai_digital_mute(sink, 0,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret != 0 && ret != -ENOTSUPP)\r\ndev_warn(sink->dev, "ASoC: Failed to unmute: %d\n", ret);\r\nret = 0;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nret = snd_soc_dai_digital_mute(sink, 1,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret != 0 && ret != -ENOTSUPP)\r\ndev_warn(sink->dev, "ASoC: Failed to mute: %d\n", ret);\r\nret = 0;\r\nsource->active--;\r\nif (source->driver->ops && source->driver->ops->shutdown) {\r\nsubstream.stream = SNDRV_PCM_STREAM_CAPTURE;\r\nsource->driver->ops->shutdown(&substream, source);\r\n}\r\nsink->active--;\r\nif (sink->driver->ops && sink->driver->ops->shutdown) {\r\nsubstream.stream = SNDRV_PCM_STREAM_PLAYBACK;\r\nsink->driver->ops->shutdown(&substream, sink);\r\n}\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown event %d\n", event);\r\nret = -EINVAL;\r\n}\r\nout:\r\nkfree(params);\r\nreturn ret;\r\n}\r\nstatic int snd_soc_dapm_dai_link_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = w->params_select;\r\nreturn 0;\r\n}\r\nstatic int snd_soc_dapm_dai_link_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);\r\nif (w->power)\r\nreturn -EBUSY;\r\nif (ucontrol->value.enumerated.item[0] == w->params_select)\r\nreturn 0;\r\nif (ucontrol->value.enumerated.item[0] >= w->num_params)\r\nreturn -EINVAL;\r\nw->params_select = ucontrol->value.enumerated.item[0];\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_new_pcm(struct snd_soc_card *card,\r\nconst struct snd_soc_pcm_stream *params,\r\nunsigned int num_params,\r\nstruct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_dapm_widget template;\r\nstruct snd_soc_dapm_widget *w;\r\nchar *link_name;\r\nint ret, count;\r\nunsigned long private_value;\r\nconst char **w_param_text;\r\nstruct soc_enum w_param_enum[] = {\r\nSOC_ENUM_SINGLE(0, 0, 0, NULL),\r\n};\r\nstruct snd_kcontrol_new kcontrol_dai_link[] = {\r\nSOC_ENUM_EXT(NULL, w_param_enum[0],\r\nsnd_soc_dapm_dai_link_get,\r\nsnd_soc_dapm_dai_link_put),\r\n};\r\nconst struct snd_soc_pcm_stream *config = params;\r\nw_param_text = devm_kcalloc(card->dev, num_params,\r\nsizeof(char *), GFP_KERNEL);\r\nif (!w_param_text)\r\nreturn -ENOMEM;\r\nlink_name = devm_kasprintf(card->dev, GFP_KERNEL, "%s-%s",\r\nsource->name, sink->name);\r\nif (!link_name) {\r\nret = -ENOMEM;\r\ngoto outfree_w_param;\r\n}\r\nfor (count = 0 ; count < num_params; count++) {\r\nif (!config->stream_name) {\r\ndev_warn(card->dapm.dev,\r\n"ASoC: anonymous config %d for dai link %s\n",\r\ncount, link_name);\r\nw_param_text[count] =\r\ndevm_kasprintf(card->dev, GFP_KERNEL,\r\n"Anonymous Configuration %d",\r\ncount);\r\nif (!w_param_text[count]) {\r\nret = -ENOMEM;\r\ngoto outfree_link_name;\r\n}\r\n} else {\r\nw_param_text[count] = devm_kmemdup(card->dev,\r\nconfig->stream_name,\r\nstrlen(config->stream_name) + 1,\r\nGFP_KERNEL);\r\nif (!w_param_text[count]) {\r\nret = -ENOMEM;\r\ngoto outfree_link_name;\r\n}\r\n}\r\nconfig++;\r\n}\r\nw_param_enum[0].items = num_params;\r\nw_param_enum[0].texts = w_param_text;\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.reg = SND_SOC_NOPM;\r\ntemplate.id = snd_soc_dapm_dai_link;\r\ntemplate.name = link_name;\r\ntemplate.event = snd_soc_dai_link_event;\r\ntemplate.event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\r\nSND_SOC_DAPM_PRE_PMD;\r\ntemplate.num_kcontrols = 1;\r\nprivate_value =\r\n(unsigned long) devm_kmemdup(card->dev,\r\n(void *)(kcontrol_dai_link[0].private_value),\r\nsizeof(struct soc_enum), GFP_KERNEL);\r\nif (!private_value) {\r\ndev_err(card->dev, "ASoC: Failed to create control for %s widget\n",\r\nlink_name);\r\nret = -ENOMEM;\r\ngoto outfree_link_name;\r\n}\r\nkcontrol_dai_link[0].private_value = private_value;\r\ntemplate.kcontrol_news =\r\ndevm_kmemdup(card->dev, &kcontrol_dai_link[0],\r\nsizeof(struct snd_kcontrol_new),\r\nGFP_KERNEL);\r\nif (!template.kcontrol_news) {\r\ndev_err(card->dev, "ASoC: Failed to create control for %s widget\n",\r\nlink_name);\r\nret = -ENOMEM;\r\ngoto outfree_private_value;\r\n}\r\ndev_dbg(card->dev, "ASoC: adding %s widget\n", link_name);\r\nw = snd_soc_dapm_new_control_unlocked(&card->dapm, &template);\r\nif (!w) {\r\ndev_err(card->dev, "ASoC: Failed to create %s widget\n",\r\nlink_name);\r\nret = -ENOMEM;\r\ngoto outfree_kcontrol_news;\r\n}\r\nw->params = params;\r\nw->num_params = num_params;\r\nret = snd_soc_dapm_add_path(&card->dapm, source, w, NULL, NULL);\r\nif (ret)\r\ngoto outfree_w;\r\nreturn snd_soc_dapm_add_path(&card->dapm, w, sink, NULL, NULL);\r\noutfree_w:\r\ndevm_kfree(card->dev, w);\r\noutfree_kcontrol_news:\r\ndevm_kfree(card->dev, (void *)template.kcontrol_news);\r\noutfree_private_value:\r\ndevm_kfree(card->dev, (void *)private_value);\r\noutfree_link_name:\r\ndevm_kfree(card->dev, link_name);\r\noutfree_w_param:\r\nfor (count = 0 ; count < num_params; count++)\r\ndevm_kfree(card->dev, (void *)w_param_text[count]);\r\ndevm_kfree(card->dev, w_param_text);\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_dapm_widget template;\r\nstruct snd_soc_dapm_widget *w;\r\nWARN_ON(dapm->dev != dai->dev);\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.reg = SND_SOC_NOPM;\r\nif (dai->driver->playback.stream_name) {\r\ntemplate.id = snd_soc_dapm_dai_in;\r\ntemplate.name = dai->driver->playback.stream_name;\r\ntemplate.sname = dai->driver->playback.stream_name;\r\ndev_dbg(dai->dev, "ASoC: adding %s widget\n",\r\ntemplate.name);\r\nw = snd_soc_dapm_new_control_unlocked(dapm, &template);\r\nif (!w) {\r\ndev_err(dapm->dev, "ASoC: Failed to create %s widget\n",\r\ndai->driver->playback.stream_name);\r\nreturn -ENOMEM;\r\n}\r\nw->priv = dai;\r\ndai->playback_widget = w;\r\n}\r\nif (dai->driver->capture.stream_name) {\r\ntemplate.id = snd_soc_dapm_dai_out;\r\ntemplate.name = dai->driver->capture.stream_name;\r\ntemplate.sname = dai->driver->capture.stream_name;\r\ndev_dbg(dai->dev, "ASoC: adding %s widget\n",\r\ntemplate.name);\r\nw = snd_soc_dapm_new_control_unlocked(dapm, &template);\r\nif (!w) {\r\ndev_err(dapm->dev, "ASoC: Failed to create %s widget\n",\r\ndai->driver->capture.stream_name);\r\nreturn -ENOMEM;\r\n}\r\nw->priv = dai;\r\ndai->capture_widget = w;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_link_dai_widgets(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dapm_widget *dai_w, *w;\r\nstruct snd_soc_dapm_widget *src, *sink;\r\nstruct snd_soc_dai *dai;\r\nlist_for_each_entry(dai_w, &card->widgets, list) {\r\nswitch (dai_w->id) {\r\ncase snd_soc_dapm_dai_in:\r\ncase snd_soc_dapm_dai_out:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\ndai = dai_w->priv;\r\nlist_for_each_entry(w, &card->widgets, list) {\r\nif (w->dapm != dai_w->dapm)\r\ncontinue;\r\nswitch (w->id) {\r\ncase snd_soc_dapm_dai_in:\r\ncase snd_soc_dapm_dai_out:\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\nif (!w->sname || !strstr(w->sname, dai_w->sname))\r\ncontinue;\r\nif (dai_w->id == snd_soc_dapm_dai_in) {\r\nsrc = dai_w;\r\nsink = w;\r\n} else {\r\nsrc = w;\r\nsink = dai_w;\r\n}\r\ndev_dbg(dai->dev, "%s -> %s\n", src->name, sink->name);\r\nsnd_soc_dapm_add_path(w->dapm, src, sink, NULL, NULL);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dapm_connect_dai_link_widgets(struct snd_soc_card *card,\r\nstruct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dapm_widget *sink, *source;\r\nint i;\r\nfor (i = 0; i < rtd->num_codecs; i++) {\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dais[i];\r\nif (codec_dai->playback_widget && cpu_dai->playback_widget) {\r\nsource = cpu_dai->playback_widget;\r\nsink = codec_dai->playback_widget;\r\ndev_dbg(rtd->dev, "connected DAI link %s:%s -> %s:%s\n",\r\ncpu_dai->component->name, source->name,\r\ncodec_dai->component->name, sink->name);\r\nsnd_soc_dapm_add_path(&card->dapm, source, sink,\r\nNULL, NULL);\r\n}\r\nif (codec_dai->capture_widget && cpu_dai->capture_widget) {\r\nsource = codec_dai->capture_widget;\r\nsink = cpu_dai->capture_widget;\r\ndev_dbg(rtd->dev, "connected DAI link %s:%s -> %s:%s\n",\r\ncodec_dai->component->name, source->name,\r\ncpu_dai->component->name, sink->name);\r\nsnd_soc_dapm_add_path(&card->dapm, source, sink,\r\nNULL, NULL);\r\n}\r\n}\r\n}\r\nstatic void soc_dapm_dai_stream_event(struct snd_soc_dai *dai, int stream,\r\nint event)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nunsigned int ep;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nw = dai->playback_widget;\r\nelse\r\nw = dai->capture_widget;\r\nif (w) {\r\ndapm_mark_dirty(w, "stream event");\r\nif (w->id == snd_soc_dapm_dai_in) {\r\nep = SND_SOC_DAPM_EP_SOURCE;\r\ndapm_widget_invalidate_input_paths(w);\r\n} else {\r\nep = SND_SOC_DAPM_EP_SINK;\r\ndapm_widget_invalidate_output_paths(w);\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_STREAM_START:\r\nw->active = 1;\r\nw->is_ep = ep;\r\nbreak;\r\ncase SND_SOC_DAPM_STREAM_STOP:\r\nw->active = 0;\r\nw->is_ep = 0;\r\nbreak;\r\ncase SND_SOC_DAPM_STREAM_SUSPEND:\r\ncase SND_SOC_DAPM_STREAM_RESUME:\r\ncase SND_SOC_DAPM_STREAM_PAUSE_PUSH:\r\ncase SND_SOC_DAPM_STREAM_PAUSE_RELEASE:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid snd_soc_dapm_connect_dai_link_widgets(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (rtd->dai_link->dynamic || rtd->dai_link->params)\r\ncontinue;\r\ndapm_connect_dai_link_widgets(card, rtd);\r\n}\r\n}\r\nstatic void soc_dapm_stream_event(struct snd_soc_pcm_runtime *rtd, int stream,\r\nint event)\r\n{\r\nint i;\r\nsoc_dapm_dai_stream_event(rtd->cpu_dai, stream, event);\r\nfor (i = 0; i < rtd->num_codecs; i++)\r\nsoc_dapm_dai_stream_event(rtd->codec_dais[i], stream, event);\r\ndapm_power_widgets(rtd->card, event);\r\n}\r\nvoid snd_soc_dapm_stream_event(struct snd_soc_pcm_runtime *rtd, int stream,\r\nint event)\r\n{\r\nstruct snd_soc_card *card = rtd->card;\r\nmutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nsoc_dapm_stream_event(rtd, stream, event);\r\nmutex_unlock(&card->dapm_mutex);\r\n}\r\nint snd_soc_dapm_enable_pin_unlocked(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nreturn snd_soc_dapm_set_pin(dapm, pin, 1);\r\n}\r\nint snd_soc_dapm_enable_pin(struct snd_soc_dapm_context *dapm, const char *pin)\r\n{\r\nint ret;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nret = snd_soc_dapm_set_pin(dapm, pin, 1);\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_force_enable_pin_unlocked(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);\r\nif (!w) {\r\ndev_err(dapm->dev, "ASoC: unknown pin %s\n", pin);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(w->dapm->dev, "ASoC: force enable pin %s\n", pin);\r\nif (!w->connected) {\r\ndapm_widget_invalidate_input_paths(w);\r\ndapm_widget_invalidate_output_paths(w);\r\nw->connected = 1;\r\n}\r\nw->force = 1;\r\ndapm_mark_dirty(w, "force enable");\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_force_enable_pin(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nint ret;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nret = snd_soc_dapm_force_enable_pin_unlocked(dapm, pin);\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_disable_pin_unlocked(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nreturn snd_soc_dapm_set_pin(dapm, pin, 0);\r\n}\r\nint snd_soc_dapm_disable_pin(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nint ret;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nret = snd_soc_dapm_set_pin(dapm, pin, 0);\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_nc_pin_unlocked(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nreturn snd_soc_dapm_set_pin(dapm, pin, 0);\r\n}\r\nint snd_soc_dapm_nc_pin(struct snd_soc_dapm_context *dapm, const char *pin)\r\n{\r\nint ret;\r\nmutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);\r\nret = snd_soc_dapm_set_pin(dapm, pin, 0);\r\nmutex_unlock(&dapm->card->dapm_mutex);\r\nreturn ret;\r\n}\r\nint snd_soc_dapm_get_pin_status(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);\r\nif (w)\r\nreturn w->connected;\r\nreturn 0;\r\n}\r\nint snd_soc_dapm_ignore_suspend(struct snd_soc_dapm_context *dapm,\r\nconst char *pin)\r\n{\r\nstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, false);\r\nif (!w) {\r\ndev_err(dapm->dev, "ASoC: unknown pin %s\n", pin);\r\nreturn -EINVAL;\r\n}\r\nw->ignore_suspend = 1;\r\nreturn 0;\r\n}\r\nvoid snd_soc_dapm_free(struct snd_soc_dapm_context *dapm)\r\n{\r\ndapm_debugfs_cleanup(dapm);\r\ndapm_free_widgets(dapm);\r\nlist_del(&dapm->list);\r\n}\r\nstatic void soc_dapm_shutdown_dapm(struct snd_soc_dapm_context *dapm)\r\n{\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct snd_soc_dapm_widget *w;\r\nLIST_HEAD(down_list);\r\nint powerdown = 0;\r\nmutex_lock(&card->dapm_mutex);\r\nlist_for_each_entry(w, &dapm->card->widgets, list) {\r\nif (w->dapm != dapm)\r\ncontinue;\r\nif (w->power) {\r\ndapm_seq_insert(w, &down_list, false);\r\nw->power = 0;\r\npowerdown = 1;\r\n}\r\n}\r\nif (powerdown) {\r\nif (dapm->bias_level == SND_SOC_BIAS_ON)\r\nsnd_soc_dapm_set_bias_level(dapm,\r\nSND_SOC_BIAS_PREPARE);\r\ndapm_seq_run(card, &down_list, 0, false);\r\nif (dapm->bias_level == SND_SOC_BIAS_PREPARE)\r\nsnd_soc_dapm_set_bias_level(dapm,\r\nSND_SOC_BIAS_STANDBY);\r\n}\r\nmutex_unlock(&card->dapm_mutex);\r\n}\r\nvoid snd_soc_dapm_shutdown(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_dapm_context *dapm;\r\nlist_for_each_entry(dapm, &card->dapm_list, list) {\r\nif (dapm != &card->dapm) {\r\nsoc_dapm_shutdown_dapm(dapm);\r\nif (dapm->bias_level == SND_SOC_BIAS_STANDBY)\r\nsnd_soc_dapm_set_bias_level(dapm,\r\nSND_SOC_BIAS_OFF);\r\n}\r\n}\r\nsoc_dapm_shutdown_dapm(&card->dapm);\r\nif (card->dapm.bias_level == SND_SOC_BIAS_STANDBY)\r\nsnd_soc_dapm_set_bias_level(&card->dapm,\r\nSND_SOC_BIAS_OFF);\r\n}
