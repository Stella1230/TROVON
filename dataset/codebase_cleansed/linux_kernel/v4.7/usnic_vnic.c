static enum vnic_res_type _to_vnic_res_type(enum usnic_vnic_res_type res_type)\r\n{\r\n#define DEFINE_USNIC_VNIC_RES_AT(usnic_vnic_res_t, vnic_res_type, desc, val) \\r\nvnic_res_type,\r\n#define DEFINE_USNIC_VNIC_RES(usnic_vnic_res_t, vnic_res_type, desc) \\r\nvnic_res_type,\r\nstatic enum vnic_res_type usnic_vnic_type_2_vnic_type[] = {\r\nUSNIC_VNIC_RES_TYPES};\r\n#undef DEFINE_USNIC_VNIC_RES\r\n#undef DEFINE_USNIC_VNIC_RES_AT\r\nif (res_type >= USNIC_VNIC_RES_TYPE_MAX)\r\nreturn RES_TYPE_MAX;\r\nreturn usnic_vnic_type_2_vnic_type[res_type];\r\n}\r\nconst char *usnic_vnic_res_type_to_str(enum usnic_vnic_res_type res_type)\r\n{\r\n#define DEFINE_USNIC_VNIC_RES_AT(usnic_vnic_res_t, vnic_res_type, desc, val) \\r\ndesc,\r\n#define DEFINE_USNIC_VNIC_RES(usnic_vnic_res_t, vnic_res_type, desc) \\r\ndesc,\r\nstatic const char * const usnic_vnic_res_type_desc[] = {\r\nUSNIC_VNIC_RES_TYPES};\r\n#undef DEFINE_USNIC_VNIC_RES\r\n#undef DEFINE_USNIC_VNIC_RES_AT\r\nif (res_type >= USNIC_VNIC_RES_TYPE_MAX)\r\nreturn "unknown";\r\nreturn usnic_vnic_res_type_desc[res_type];\r\n}\r\nconst char *usnic_vnic_pci_name(struct usnic_vnic *vnic)\r\n{\r\nreturn pci_name(usnic_vnic_get_pdev(vnic));\r\n}\r\nint usnic_vnic_dump(struct usnic_vnic *vnic, char *buf,\r\nint buf_sz,\r\nvoid *hdr_obj,\r\nint (*printtitle)(void *, char*, int),\r\nint (*printcols)(char *, int),\r\nint (*printrow)(void *, char *, int))\r\n{\r\nstruct usnic_vnic_res_chunk *chunk;\r\nstruct usnic_vnic_res *res;\r\nstruct vnic_dev_bar *bar0;\r\nint i, j, offset;\r\noffset = 0;\r\nbar0 = usnic_vnic_get_bar(vnic, 0);\r\noffset += scnprintf(buf + offset, buf_sz - offset,\r\n"VF:%hu BAR0 bus_addr=%pa vaddr=0x%p size=%ld ",\r\nusnic_vnic_get_index(vnic),\r\n&bar0->bus_addr,\r\nbar0->vaddr, bar0->len);\r\nif (printtitle)\r\noffset += printtitle(hdr_obj, buf + offset, buf_sz - offset);\r\noffset += scnprintf(buf + offset, buf_sz - offset, "\n");\r\noffset += scnprintf(buf + offset, buf_sz - offset,\r\n"|RES\t|CTRL_PIN\t\t|IN_USE\t");\r\nif (printcols)\r\noffset += printcols(buf + offset, buf_sz - offset);\r\noffset += scnprintf(buf + offset, buf_sz - offset, "\n");\r\nspin_lock(&vnic->res_lock);\r\nfor (i = 0; i < ARRAY_SIZE(vnic->chunks); i++) {\r\nchunk = &vnic->chunks[i];\r\nfor (j = 0; j < chunk->cnt; j++) {\r\nres = chunk->res[j];\r\noffset += scnprintf(buf + offset, buf_sz - offset,\r\n"|%s[%u]\t|0x%p\t|%u\t",\r\nusnic_vnic_res_type_to_str(res->type),\r\nres->vnic_idx, res->ctrl, !!res->owner);\r\nif (printrow) {\r\noffset += printrow(res->owner, buf + offset,\r\nbuf_sz - offset);\r\n}\r\noffset += scnprintf(buf + offset, buf_sz - offset,\r\n"\n");\r\n}\r\n}\r\nspin_unlock(&vnic->res_lock);\r\nreturn offset;\r\n}\r\nvoid usnic_vnic_res_spec_update(struct usnic_vnic_res_spec *spec,\r\nenum usnic_vnic_res_type trgt_type,\r\nu16 cnt)\r\n{\r\nint i;\r\nfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\r\nif (spec->resources[i].type == trgt_type) {\r\nspec->resources[i].cnt = cnt;\r\nreturn;\r\n}\r\n}\r\nWARN_ON(1);\r\n}\r\nint usnic_vnic_res_spec_satisfied(const struct usnic_vnic_res_spec *min_spec,\r\nstruct usnic_vnic_res_spec *res_spec)\r\n{\r\nint found, i, j;\r\nfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\r\nfound = 0;\r\nfor (j = 0; j < USNIC_VNIC_RES_TYPE_MAX; j++) {\r\nif (res_spec->resources[i].type !=\r\nmin_spec->resources[i].type)\r\ncontinue;\r\nfound = 1;\r\nif (min_spec->resources[i].cnt >\r\nres_spec->resources[i].cnt)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint usnic_vnic_spec_dump(char *buf, int buf_sz,\r\nstruct usnic_vnic_res_spec *res_spec)\r\n{\r\nenum usnic_vnic_res_type res_type;\r\nint res_cnt;\r\nint i;\r\nint offset = 0;\r\nfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\r\nres_type = res_spec->resources[i].type;\r\nres_cnt = res_spec->resources[i].cnt;\r\noffset += scnprintf(buf + offset, buf_sz - offset,\r\n"Res: %s Cnt: %d ",\r\nusnic_vnic_res_type_to_str(res_type),\r\nres_cnt);\r\n}\r\nreturn offset;\r\n}\r\nint usnic_vnic_check_room(struct usnic_vnic *vnic,\r\nstruct usnic_vnic_res_spec *res_spec)\r\n{\r\nint i;\r\nenum usnic_vnic_res_type res_type;\r\nint res_cnt;\r\nfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\r\nres_type = res_spec->resources[i].type;\r\nres_cnt = res_spec->resources[i].cnt;\r\nif (res_type == USNIC_VNIC_RES_TYPE_EOL)\r\nbreak;\r\nif (res_cnt > usnic_vnic_res_free_cnt(vnic, res_type))\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint usnic_vnic_res_cnt(struct usnic_vnic *vnic,\r\nenum usnic_vnic_res_type type)\r\n{\r\nreturn vnic->chunks[type].cnt;\r\n}\r\nint usnic_vnic_res_free_cnt(struct usnic_vnic *vnic,\r\nenum usnic_vnic_res_type type)\r\n{\r\nreturn vnic->chunks[type].free_cnt;\r\n}\r\nstruct usnic_vnic_res_chunk *\r\nusnic_vnic_get_resources(struct usnic_vnic *vnic, enum usnic_vnic_res_type type,\r\nint cnt, void *owner)\r\n{\r\nstruct usnic_vnic_res_chunk *src, *ret;\r\nstruct usnic_vnic_res *res;\r\nint i;\r\nif (usnic_vnic_res_free_cnt(vnic, type) < cnt || cnt < 0 || !owner)\r\nreturn ERR_PTR(-EINVAL);\r\nret = kzalloc(sizeof(*ret), GFP_ATOMIC);\r\nif (!ret) {\r\nusnic_err("Failed to allocate chunk for %s - Out of memory\n",\r\nusnic_vnic_pci_name(vnic));\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (cnt > 0) {\r\nret->res = kcalloc(cnt, sizeof(*(ret->res)), GFP_ATOMIC);\r\nif (!ret->res) {\r\nusnic_err("Failed to allocate resources for %s. Out of memory\n",\r\nusnic_vnic_pci_name(vnic));\r\nkfree(ret);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock(&vnic->res_lock);\r\nsrc = &vnic->chunks[type];\r\nfor (i = 0; i < src->cnt && ret->cnt < cnt; i++) {\r\nres = src->res[i];\r\nif (!res->owner) {\r\nsrc->free_cnt--;\r\nres->owner = owner;\r\nret->res[ret->cnt++] = res;\r\n}\r\n}\r\nspin_unlock(&vnic->res_lock);\r\n}\r\nret->type = type;\r\nret->vnic = vnic;\r\nWARN_ON(ret->cnt != cnt);\r\nreturn ret;\r\n}\r\nvoid usnic_vnic_put_resources(struct usnic_vnic_res_chunk *chunk)\r\n{\r\nstruct usnic_vnic_res *res;\r\nint i;\r\nstruct usnic_vnic *vnic = chunk->vnic;\r\nif (chunk->cnt > 0) {\r\nspin_lock(&vnic->res_lock);\r\nwhile ((i = --chunk->cnt) >= 0) {\r\nres = chunk->res[i];\r\nchunk->res[i] = NULL;\r\nres->owner = NULL;\r\nvnic->chunks[res->type].free_cnt++;\r\n}\r\nspin_unlock(&vnic->res_lock);\r\n}\r\nkfree(chunk->res);\r\nkfree(chunk);\r\n}\r\nu16 usnic_vnic_get_index(struct usnic_vnic *vnic)\r\n{\r\nreturn usnic_vnic_get_pdev(vnic)->devfn - 1;\r\n}\r\nstatic int usnic_vnic_alloc_res_chunk(struct usnic_vnic *vnic,\r\nenum usnic_vnic_res_type type,\r\nstruct usnic_vnic_res_chunk *chunk)\r\n{\r\nint cnt, err, i;\r\nstruct usnic_vnic_res *res;\r\ncnt = vnic_dev_get_res_count(vnic->vdev, _to_vnic_res_type(type));\r\nif (cnt < 1)\r\nreturn -EINVAL;\r\nchunk->cnt = chunk->free_cnt = cnt;\r\nchunk->res = kzalloc(sizeof(*(chunk->res))*cnt, GFP_KERNEL);\r\nif (!chunk->res)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < cnt; i++) {\r\nres = kzalloc(sizeof(*res), GFP_KERNEL);\r\nif (!res) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nres->type = type;\r\nres->vnic_idx = i;\r\nres->vnic = vnic;\r\nres->ctrl = vnic_dev_get_res(vnic->vdev,\r\n_to_vnic_res_type(type), i);\r\nchunk->res[i] = res;\r\n}\r\nchunk->vnic = vnic;\r\nreturn 0;\r\nfail:\r\nfor (i--; i >= 0; i--)\r\nkfree(chunk->res[i]);\r\nkfree(chunk->res);\r\nreturn err;\r\n}\r\nstatic void usnic_vnic_free_res_chunk(struct usnic_vnic_res_chunk *chunk)\r\n{\r\nint i;\r\nfor (i = 0; i < chunk->cnt; i++)\r\nkfree(chunk->res[i]);\r\nkfree(chunk->res);\r\n}\r\nstatic int usnic_vnic_discover_resources(struct pci_dev *pdev,\r\nstruct usnic_vnic *vnic)\r\n{\r\nenum usnic_vnic_res_type res_type;\r\nint i;\r\nint err = 0;\r\nfor (i = 0; i < ARRAY_SIZE(vnic->bar); i++) {\r\nif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\r\ncontinue;\r\nvnic->bar[i].len = pci_resource_len(pdev, i);\r\nvnic->bar[i].vaddr = pci_iomap(pdev, i, vnic->bar[i].len);\r\nif (!vnic->bar[i].vaddr) {\r\nusnic_err("Cannot memory-map BAR %d, aborting\n",\r\ni);\r\nerr = -ENODEV;\r\ngoto out_clean_bar;\r\n}\r\nvnic->bar[i].bus_addr = pci_resource_start(pdev, i);\r\n}\r\nvnic->vdev = vnic_dev_register(NULL, pdev, pdev, vnic->bar,\r\nARRAY_SIZE(vnic->bar));\r\nif (!vnic->vdev) {\r\nusnic_err("Failed to register device %s\n",\r\npci_name(pdev));\r\nerr = -EINVAL;\r\ngoto out_clean_bar;\r\n}\r\nfor (res_type = USNIC_VNIC_RES_TYPE_EOL + 1;\r\nres_type < USNIC_VNIC_RES_TYPE_MAX; res_type++) {\r\nerr = usnic_vnic_alloc_res_chunk(vnic, res_type,\r\n&vnic->chunks[res_type]);\r\nif (err) {\r\nusnic_err("Failed to alloc res %s with err %d\n",\r\nusnic_vnic_res_type_to_str(res_type),\r\nerr);\r\ngoto out_clean_chunks;\r\n}\r\n}\r\nreturn 0;\r\nout_clean_chunks:\r\nfor (res_type--; res_type > USNIC_VNIC_RES_TYPE_EOL; res_type--)\r\nusnic_vnic_free_res_chunk(&vnic->chunks[res_type]);\r\nvnic_dev_unregister(vnic->vdev);\r\nout_clean_bar:\r\nfor (i = 0; i < ARRAY_SIZE(vnic->bar); i++) {\r\nif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\r\ncontinue;\r\nif (!vnic->bar[i].vaddr)\r\nbreak;\r\niounmap(vnic->bar[i].vaddr);\r\n}\r\nreturn err;\r\n}\r\nstruct pci_dev *usnic_vnic_get_pdev(struct usnic_vnic *vnic)\r\n{\r\nreturn vnic_dev_get_pdev(vnic->vdev);\r\n}\r\nstruct vnic_dev_bar *usnic_vnic_get_bar(struct usnic_vnic *vnic,\r\nint bar_num)\r\n{\r\nreturn (bar_num < ARRAY_SIZE(vnic->bar)) ? &vnic->bar[bar_num] : NULL;\r\n}\r\nstatic void usnic_vnic_release_resources(struct usnic_vnic *vnic)\r\n{\r\nint i;\r\nstruct pci_dev *pdev;\r\nenum usnic_vnic_res_type res_type;\r\npdev = usnic_vnic_get_pdev(vnic);\r\nfor (res_type = USNIC_VNIC_RES_TYPE_EOL + 1;\r\nres_type < USNIC_VNIC_RES_TYPE_MAX; res_type++)\r\nusnic_vnic_free_res_chunk(&vnic->chunks[res_type]);\r\nvnic_dev_unregister(vnic->vdev);\r\nfor (i = 0; i < ARRAY_SIZE(vnic->bar); i++) {\r\nif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\r\ncontinue;\r\niounmap(vnic->bar[i].vaddr);\r\n}\r\n}\r\nstruct usnic_vnic *usnic_vnic_alloc(struct pci_dev *pdev)\r\n{\r\nstruct usnic_vnic *vnic;\r\nint err = 0;\r\nif (!pci_is_enabled(pdev)) {\r\nusnic_err("PCI dev %s is disabled\n", pci_name(pdev));\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvnic = kzalloc(sizeof(*vnic), GFP_KERNEL);\r\nif (!vnic) {\r\nusnic_err("Failed to alloc vnic for %s - out of memory\n",\r\npci_name(pdev));\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock_init(&vnic->res_lock);\r\nerr = usnic_vnic_discover_resources(pdev, vnic);\r\nif (err) {\r\nusnic_err("Failed to discover %s resources with err %d\n",\r\npci_name(pdev), err);\r\ngoto out_free_vnic;\r\n}\r\nusnic_dbg("Allocated vnic for %s\n", usnic_vnic_pci_name(vnic));\r\nreturn vnic;\r\nout_free_vnic:\r\nkfree(vnic);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid usnic_vnic_free(struct usnic_vnic *vnic)\r\n{\r\nusnic_vnic_release_resources(vnic);\r\nkfree(vnic);\r\n}
