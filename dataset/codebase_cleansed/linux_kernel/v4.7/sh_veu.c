static enum v4l2_colorspace sh_veu_4cc2cspace(u32 fourcc)\r\n{\r\nswitch (fourcc) {\r\ndefault:\r\nBUG();\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV24:\r\nreturn V4L2_COLORSPACE_SMPTE170M;\r\ncase V4L2_PIX_FMT_RGB332:\r\ncase V4L2_PIX_FMT_RGB444:\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_BGR666:\r\ncase V4L2_PIX_FMT_RGB24:\r\nreturn V4L2_COLORSPACE_SRGB;\r\n}\r\n}\r\nstatic u32 sh_veu_reg_read(struct sh_veu_dev *veu, unsigned int reg)\r\n{\r\nreturn ioread32(veu->base + reg);\r\n}\r\nstatic void sh_veu_reg_write(struct sh_veu_dev *veu, unsigned int reg,\r\nu32 value)\r\n{\r\niowrite32(value, veu->base + reg);\r\n}\r\nstatic void sh_veu_job_abort(void *priv)\r\n{\r\nstruct sh_veu_dev *veu = priv;\r\nveu->aborting = true;\r\n}\r\nstatic void sh_veu_process(struct sh_veu_dev *veu,\r\nstruct vb2_buffer *src_buf,\r\nstruct vb2_buffer *dst_buf)\r\n{\r\ndma_addr_t addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\nsh_veu_reg_write(veu, VEU_DAYR, addr + veu->vfmt_out.offset_y);\r\nsh_veu_reg_write(veu, VEU_DACR, veu->vfmt_out.offset_c ?\r\naddr + veu->vfmt_out.offset_c : 0);\r\ndev_dbg(veu->dev, "%s(): dst base %lx, y: %x, c: %x\n", __func__,\r\n(unsigned long)addr,\r\nveu->vfmt_out.offset_y, veu->vfmt_out.offset_c);\r\naddr = vb2_dma_contig_plane_dma_addr(src_buf, 0);\r\nsh_veu_reg_write(veu, VEU_SAYR, addr + veu->vfmt_in.offset_y);\r\nsh_veu_reg_write(veu, VEU_SACR, veu->vfmt_in.offset_c ?\r\naddr + veu->vfmt_in.offset_c : 0);\r\ndev_dbg(veu->dev, "%s(): src base %lx, y: %x, c: %x\n", __func__,\r\n(unsigned long)addr,\r\nveu->vfmt_in.offset_y, veu->vfmt_in.offset_c);\r\nsh_veu_reg_write(veu, VEU_STR, 1);\r\nsh_veu_reg_write(veu, VEU_EIER, 1);\r\n}\r\nstatic void sh_veu_device_run(void *priv)\r\n{\r\nstruct sh_veu_dev *veu = priv;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nsrc_buf = v4l2_m2m_next_src_buf(veu->m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(veu->m2m_ctx);\r\nif (src_buf && dst_buf)\r\nsh_veu_process(veu, src_buf, dst_buf);\r\n}\r\nstatic bool sh_veu_is_streamer(struct sh_veu_dev *veu, struct sh_veu_file *veu_file,\r\nenum v4l2_buf_type type)\r\n{\r\nreturn (type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nveu_file == veu->capture) ||\r\n(type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\nveu_file == veu->output);\r\n}\r\nstatic int sh_veu_stream_init(struct sh_veu_dev *veu, struct sh_veu_file *veu_file,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct sh_veu_file **stream;\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nstream = &veu->capture;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nstream = &veu->output;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (*stream == veu_file)\r\nreturn 0;\r\nif (*stream)\r\nreturn -EBUSY;\r\n*stream = veu_file;\r\nreturn 0;\r\n}\r\nstatic int sh_veu_context_init(struct sh_veu_dev *veu)\r\n{\r\nif (veu->m2m_ctx)\r\nreturn 0;\r\nveu->m2m_ctx = v4l2_m2m_ctx_init(veu->m2m_dev, veu,\r\nsh_veu_queue_init);\r\nreturn PTR_ERR_OR_ZERO(veu->m2m_ctx);\r\n}\r\nstatic int sh_veu_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->driver, "sh-veu", sizeof(cap->driver));\r\nstrlcpy(cap->card, "sh-mobile VEU", sizeof(cap->card));\r\nstrlcpy(cap->bus_info, "platform:sh-veu", sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int sh_veu_enum_fmt(struct v4l2_fmtdesc *f, const int *fmt, int fmt_num)\r\n{\r\nif (f->index >= fmt_num)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, sh_veu_fmt[fmt[f->index]].name, sizeof(f->description));\r\nf->pixelformat = sh_veu_fmt[fmt[f->index]].fourcc;\r\nreturn 0;\r\n}\r\nstatic int sh_veu_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn sh_veu_enum_fmt(f, sh_veu_fmt_out, ARRAY_SIZE(sh_veu_fmt_out));\r\n}\r\nstatic int sh_veu_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn sh_veu_enum_fmt(f, sh_veu_fmt_in, ARRAY_SIZE(sh_veu_fmt_in));\r\n}\r\nstatic struct sh_veu_vfmt *sh_veu_get_vfmt(struct sh_veu_dev *veu,\r\nenum v4l2_buf_type type)\r\n{\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &veu->vfmt_out;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn &veu->vfmt_in;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int sh_veu_g_fmt(struct sh_veu_file *veu_file, struct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct sh_veu_dev *veu = veu_file->veu_dev;\r\nstruct sh_veu_vfmt *vfmt;\r\nvfmt = sh_veu_get_vfmt(veu, f->type);\r\npix->width = vfmt->frame.width;\r\npix->height = vfmt->frame.height;\r\npix->field = V4L2_FIELD_NONE;\r\npix->pixelformat = vfmt->fmt->fourcc;\r\npix->colorspace = sh_veu_4cc2cspace(pix->pixelformat);\r\npix->bytesperline = vfmt->bytesperline;\r\npix->sizeimage = vfmt->bytesperline * pix->height *\r\nvfmt->fmt->depth / vfmt->fmt->ydepth;\r\ndev_dbg(veu->dev, "%s(): type: %d, size %u @ %ux%u, fmt %x\n", __func__,\r\nf->type, pix->sizeimage, pix->width, pix->height, pix->pixelformat);\r\nreturn 0;\r\n}\r\nstatic int sh_veu_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn sh_veu_g_fmt(priv, f);\r\n}\r\nstatic int sh_veu_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn sh_veu_g_fmt(priv, f);\r\n}\r\nstatic int sh_veu_try_fmt(struct v4l2_format *f, const struct sh_veu_format *fmt)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nunsigned int y_bytes_used;\r\nswitch (pix->field) {\r\ndefault:\r\ncase V4L2_FIELD_ANY:\r\npix->field = V4L2_FIELD_NONE;\r\ncase V4L2_FIELD_NONE:\r\nbreak;\r\n}\r\nv4l_bound_align_image(&pix->width, MIN_W, MAX_W, ALIGN_W,\r\n&pix->height, MIN_H, MAX_H, 0, 0);\r\ny_bytes_used = (pix->width * fmt->ydepth) >> 3;\r\nif (pix->bytesperline < y_bytes_used)\r\npix->bytesperline = y_bytes_used;\r\npix->sizeimage = pix->height * pix->bytesperline * fmt->depth / fmt->ydepth;\r\npix->pixelformat = fmt->fourcc;\r\npix->colorspace = sh_veu_4cc2cspace(pix->pixelformat);\r\npr_debug("%s(): type: %d, size %u\n", __func__, f->type, pix->sizeimage);\r\nreturn 0;\r\n}\r\nstatic const struct sh_veu_format *sh_veu_find_fmt(const struct v4l2_format *f)\r\n{\r\nconst int *fmt;\r\nint i, n, dflt;\r\npr_debug("%s(%d;%d)\n", __func__, f->type, f->fmt.pix.field);\r\nswitch (f->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nfmt = sh_veu_fmt_out;\r\nn = ARRAY_SIZE(sh_veu_fmt_out);\r\ndflt = DEFAULT_OUT_FMTIDX;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\ndefault:\r\nfmt = sh_veu_fmt_in;\r\nn = ARRAY_SIZE(sh_veu_fmt_in);\r\ndflt = DEFAULT_IN_FMTIDX;\r\nbreak;\r\n}\r\nfor (i = 0; i < n; i++)\r\nif (sh_veu_fmt[fmt[i]].fourcc == f->fmt.pix.pixelformat)\r\nreturn &sh_veu_fmt[fmt[i]];\r\nreturn &sh_veu_fmt[dflt];\r\n}\r\nstatic int sh_veu_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nconst struct sh_veu_format *fmt;\r\nfmt = sh_veu_find_fmt(f);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nreturn sh_veu_try_fmt(f, fmt);\r\n}\r\nstatic int sh_veu_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nconst struct sh_veu_format *fmt;\r\nfmt = sh_veu_find_fmt(f);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nreturn sh_veu_try_fmt(f, fmt);\r\n}\r\nstatic void sh_veu_colour_offset(struct sh_veu_dev *veu, struct sh_veu_vfmt *vfmt)\r\n{\r\nunsigned int left = vfmt->frame.left & ~0x03;\r\nunsigned int top = vfmt->frame.top;\r\ndma_addr_t offset = ((left * veu->vfmt_out.fmt->depth) >> 3) +\r\ntop * veu->vfmt_out.bytesperline;\r\nunsigned int y_line;\r\nvfmt->offset_y = offset;\r\nswitch (vfmt->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV24:\r\ny_line = ALIGN(vfmt->frame.width, 16);\r\nvfmt->offset_c = offset + y_line * vfmt->frame.height;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB332:\r\ncase V4L2_PIX_FMT_RGB444:\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_BGR666:\r\ncase V4L2_PIX_FMT_RGB24:\r\nvfmt->offset_c = 0;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int sh_veu_s_fmt(struct sh_veu_file *veu_file, struct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct sh_veu_dev *veu = veu_file->veu_dev;\r\nstruct sh_veu_vfmt *vfmt;\r\nstruct vb2_queue *vq;\r\nint ret = sh_veu_context_init(veu);\r\nif (ret < 0)\r\nreturn ret;\r\nvq = v4l2_m2m_get_vq(veu->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&veu_file->veu_dev->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nvfmt = sh_veu_get_vfmt(veu, f->type);\r\nvfmt->fmt = sh_veu_find_fmt(f);\r\nvfmt->frame.width = pix->width;\r\nvfmt->frame.height = pix->height;\r\nvfmt->bytesperline = pix->bytesperline;\r\nsh_veu_colour_offset(veu, vfmt);\r\nveu_file->cfg_needed = true;\r\ndev_dbg(veu->dev,\r\n"Setting format for type %d, wxh: %dx%d, fmt: %x\n",\r\nf->type, pix->width, pix->height, vfmt->fmt->fourcc);\r\nreturn 0;\r\n}\r\nstatic int sh_veu_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret = sh_veu_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn sh_veu_s_fmt(priv, f);\r\n}\r\nstatic int sh_veu_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret = sh_veu_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn sh_veu_s_fmt(priv, f);\r\n}\r\nstatic int sh_veu_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct sh_veu_file *veu_file = priv;\r\nstruct sh_veu_dev *veu = veu_file->veu_dev;\r\nint ret = sh_veu_context_init(veu);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sh_veu_stream_init(veu, veu_file, reqbufs->type);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn v4l2_m2m_reqbufs(file, veu->m2m_ctx, reqbufs);\r\n}\r\nstatic int sh_veu_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct sh_veu_file *veu_file = priv;\r\nif (!sh_veu_is_streamer(veu_file->veu_dev, veu_file, buf->type))\r\nreturn -EBUSY;\r\nreturn v4l2_m2m_querybuf(file, veu_file->veu_dev->m2m_ctx, buf);\r\n}\r\nstatic int sh_veu_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct sh_veu_file *veu_file = priv;\r\ndev_dbg(veu_file->veu_dev->dev, "%s(%d)\n", __func__, buf->type);\r\nif (!sh_veu_is_streamer(veu_file->veu_dev, veu_file, buf->type))\r\nreturn -EBUSY;\r\nreturn v4l2_m2m_qbuf(file, veu_file->veu_dev->m2m_ctx, buf);\r\n}\r\nstatic int sh_veu_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct sh_veu_file *veu_file = priv;\r\ndev_dbg(veu_file->veu_dev->dev, "%s(%d)\n", __func__, buf->type);\r\nif (!sh_veu_is_streamer(veu_file->veu_dev, veu_file, buf->type))\r\nreturn -EBUSY;\r\nreturn v4l2_m2m_dqbuf(file, veu_file->veu_dev->m2m_ctx, buf);\r\n}\r\nstatic void sh_veu_calc_scale(struct sh_veu_dev *veu,\r\nint size_in, int size_out, int crop_out,\r\nu32 *mant, u32 *frac, u32 *rep)\r\n{\r\nu32 fixpoint;\r\n*rep = *mant = *frac = 0;\r\nif (size_in == size_out) {\r\nif (crop_out != size_out)\r\n*mant = 1;\r\nreturn;\r\n}\r\nif (veu->is_2h && size_out > size_in) {\r\nu32 fixpoint = (4096 * size_in) / size_out;\r\n*mant = fixpoint / 4096;\r\n*frac = (fixpoint - (*mant * 4096)) & ~0x07;\r\nswitch (*frac) {\r\ncase 0x800:\r\n*rep = 1;\r\nbreak;\r\ncase 0x400:\r\n*rep = 3;\r\nbreak;\r\ncase 0x200:\r\n*rep = 7;\r\nbreak;\r\n}\r\nif (*rep)\r\nreturn;\r\n}\r\nfixpoint = (4096 * (size_in - 1)) / (size_out + 1);\r\n*mant = fixpoint / 4096;\r\n*frac = fixpoint - (*mant * 4096);\r\nif (*frac & 0x07) {\r\n*frac &= ~0x07;\r\nif (size_out > size_in)\r\n*frac -= 8;\r\nelse\r\n*frac += 8;\r\n}\r\n}\r\nstatic unsigned long sh_veu_scale_v(struct sh_veu_dev *veu,\r\nint size_in, int size_out, int crop_out)\r\n{\r\nu32 mant, frac, value, rep;\r\nsh_veu_calc_scale(veu, size_in, size_out, crop_out, &mant, &frac, &rep);\r\nvalue = (sh_veu_reg_read(veu, VEU_RFCR) & ~0xffff0000) |\r\n(((mant << 12) | frac) << 16);\r\nsh_veu_reg_write(veu, VEU_RFCR, value);\r\nvalue = (sh_veu_reg_read(veu, VEU_RFSR) & ~0xffff0000) |\r\n(((rep << 12) | crop_out) << 16);\r\nsh_veu_reg_write(veu, VEU_RFSR, value);\r\nreturn ALIGN((size_in * crop_out) / size_out, 4);\r\n}\r\nstatic unsigned long sh_veu_scale_h(struct sh_veu_dev *veu,\r\nint size_in, int size_out, int crop_out)\r\n{\r\nu32 mant, frac, value, rep;\r\nsh_veu_calc_scale(veu, size_in, size_out, crop_out, &mant, &frac, &rep);\r\nvalue = (sh_veu_reg_read(veu, VEU_RFCR) & ~0xffff) |\r\n(mant << 12) | frac;\r\nsh_veu_reg_write(veu, VEU_RFCR, value);\r\nvalue = (sh_veu_reg_read(veu, VEU_RFSR) & ~0xffff) |\r\n(rep << 12) | crop_out;\r\nsh_veu_reg_write(veu, VEU_RFSR, value);\r\nreturn ALIGN((size_in * crop_out) / size_out, 4);\r\n}\r\nstatic void sh_veu_configure(struct sh_veu_dev *veu)\r\n{\r\nu32 src_width, src_stride, src_height;\r\nu32 dst_width, dst_stride, dst_height;\r\nu32 real_w, real_h;\r\nsh_veu_reg_write(veu, VEU_BSRR, 0x100);\r\nsrc_width = veu->vfmt_in.frame.width;\r\nsrc_height = veu->vfmt_in.frame.height;\r\nsrc_stride = ALIGN(veu->vfmt_in.frame.width, 16);\r\ndst_width = real_w = veu->vfmt_out.frame.width;\r\ndst_height = real_h = veu->vfmt_out.frame.height;\r\ndst_stride = veu->vfmt_out.bytesperline;\r\nsrc_width = sh_veu_scale_h(veu, src_width, real_w, dst_width);\r\nsrc_height = sh_veu_scale_v(veu, src_height, real_h, dst_height);\r\nsh_veu_reg_write(veu, VEU_SWR, src_stride);\r\nsh_veu_reg_write(veu, VEU_SSR, src_width | (src_height << 16));\r\nsh_veu_reg_write(veu, VEU_BSSR, 0);\r\nsh_veu_reg_write(veu, VEU_EDWR, dst_stride);\r\nsh_veu_reg_write(veu, VEU_DACR, 0);\r\nsh_veu_reg_write(veu, VEU_SWPR, 0x67);\r\nsh_veu_reg_write(veu, VEU_TRCR, (6 << 16) | (0 << 14) | 2 | 4);\r\nif (veu->is_2h) {\r\nsh_veu_reg_write(veu, VEU_MCR00, 0x0cc5);\r\nsh_veu_reg_write(veu, VEU_MCR01, 0x0950);\r\nsh_veu_reg_write(veu, VEU_MCR02, 0x0000);\r\nsh_veu_reg_write(veu, VEU_MCR10, 0x397f);\r\nsh_veu_reg_write(veu, VEU_MCR11, 0x0950);\r\nsh_veu_reg_write(veu, VEU_MCR12, 0x3ccd);\r\nsh_veu_reg_write(veu, VEU_MCR20, 0x0000);\r\nsh_veu_reg_write(veu, VEU_MCR21, 0x0950);\r\nsh_veu_reg_write(veu, VEU_MCR22, 0x1023);\r\nsh_veu_reg_write(veu, VEU_COFFR, 0x00800010);\r\n}\r\n}\r\nstatic int sh_veu_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct sh_veu_file *veu_file = priv;\r\nif (!sh_veu_is_streamer(veu_file->veu_dev, veu_file, type))\r\nreturn -EBUSY;\r\nif (veu_file->cfg_needed) {\r\nstruct sh_veu_dev *veu = veu_file->veu_dev;\r\nveu_file->cfg_needed = false;\r\nsh_veu_configure(veu_file->veu_dev);\r\nveu->xaction = 0;\r\nveu->aborting = false;\r\n}\r\nreturn v4l2_m2m_streamon(file, veu_file->veu_dev->m2m_ctx, type);\r\n}\r\nstatic int sh_veu_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct sh_veu_file *veu_file = priv;\r\nif (!sh_veu_is_streamer(veu_file->veu_dev, veu_file, type))\r\nreturn -EBUSY;\r\nreturn v4l2_m2m_streamoff(file, veu_file->veu_dev->m2m_ctx, type);\r\n}\r\nstatic int sh_veu_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct sh_veu_dev *veu = vb2_get_drv_priv(vq);\r\nstruct sh_veu_vfmt *vfmt = sh_veu_get_vfmt(veu, vq->type);\r\nunsigned int count = *nbuffers;\r\nunsigned int size = vfmt->bytesperline * vfmt->frame.height *\r\nvfmt->fmt->depth / vfmt->fmt->ydepth;\r\nif (count < 2)\r\n*nbuffers = count = 2;\r\nif (size * count > VIDEO_MEM_LIMIT) {\r\ncount = VIDEO_MEM_LIMIT / size;\r\n*nbuffers = count;\r\n}\r\nif (*nplanes) {\r\nalloc_ctxs[0] = veu->alloc_ctx;\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n}\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = veu->alloc_ctx;\r\ndev_dbg(veu->dev, "get %d buffer(s) of size %d each.\n", count, size);\r\nreturn 0;\r\n}\r\nstatic int sh_veu_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct sh_veu_dev *veu = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct sh_veu_vfmt *vfmt;\r\nunsigned int sizeimage;\r\nvfmt = sh_veu_get_vfmt(veu, vb->vb2_queue->type);\r\nsizeimage = vfmt->bytesperline * vfmt->frame.height *\r\nvfmt->fmt->depth / vfmt->fmt->ydepth;\r\nif (vb2_plane_size(vb, 0) < sizeimage) {\r\ndev_dbg(veu->dev, "%s data will not fit into plane (%lu < %u)\n",\r\n__func__, vb2_plane_size(vb, 0), sizeimage);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, sizeimage);\r\nreturn 0;\r\n}\r\nstatic void sh_veu_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct sh_veu_dev *veu = vb2_get_drv_priv(vb->vb2_queue);\r\ndev_dbg(veu->dev, "%s(%d)\n", __func__, vb->type);\r\nv4l2_m2m_buf_queue(veu->m2m_ctx, vbuf);\r\n}\r\nstatic int sh_veu_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct sh_veu_dev *veu = priv;\r\nint ret;\r\nmemset(src_vq, 0, sizeof(*src_vq));\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = veu;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->ops = &sh_veu_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->lock = &veu->fop_lock;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nret = vb2_queue_init(src_vq);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(dst_vq, 0, sizeof(*dst_vq));\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = veu;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &sh_veu_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->lock = &veu->fop_lock;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int sh_veu_open(struct file *file)\r\n{\r\nstruct sh_veu_dev *veu = video_drvdata(file);\r\nstruct sh_veu_file *veu_file;\r\nveu_file = kzalloc(sizeof(*veu_file), GFP_KERNEL);\r\nif (!veu_file)\r\nreturn -ENOMEM;\r\nveu_file->veu_dev = veu;\r\nveu_file->cfg_needed = true;\r\nfile->private_data = veu_file;\r\npm_runtime_get_sync(veu->dev);\r\ndev_dbg(veu->dev, "Created instance %p\n", veu_file);\r\nreturn 0;\r\n}\r\nstatic int sh_veu_release(struct file *file)\r\n{\r\nstruct sh_veu_dev *veu = video_drvdata(file);\r\nstruct sh_veu_file *veu_file = file->private_data;\r\ndev_dbg(veu->dev, "Releasing instance %p\n", veu_file);\r\nif (veu_file == veu->capture) {\r\nveu->capture = NULL;\r\nvb2_queue_release(v4l2_m2m_get_vq(veu->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE));\r\n}\r\nif (veu_file == veu->output) {\r\nveu->output = NULL;\r\nvb2_queue_release(v4l2_m2m_get_vq(veu->m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT));\r\n}\r\nif (!veu->output && !veu->capture && veu->m2m_ctx) {\r\nv4l2_m2m_ctx_release(veu->m2m_ctx);\r\nveu->m2m_ctx = NULL;\r\n}\r\npm_runtime_put(veu->dev);\r\nkfree(veu_file);\r\nreturn 0;\r\n}\r\nstatic unsigned int sh_veu_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct sh_veu_file *veu_file = file->private_data;\r\nreturn v4l2_m2m_poll(file, veu_file->veu_dev->m2m_ctx, wait);\r\n}\r\nstatic int sh_veu_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct sh_veu_file *veu_file = file->private_data;\r\nreturn v4l2_m2m_mmap(file, veu_file->veu_dev->m2m_ctx, vma);\r\n}\r\nstatic irqreturn_t sh_veu_bh(int irq, void *dev_id)\r\n{\r\nstruct sh_veu_dev *veu = dev_id;\r\nif (veu->xaction == MEM2MEM_DEF_TRANSLEN || veu->aborting) {\r\nv4l2_m2m_job_finish(veu->m2m_dev, veu->m2m_ctx);\r\nveu->xaction = 0;\r\n} else {\r\nsh_veu_device_run(veu);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sh_veu_isr(int irq, void *dev_id)\r\n{\r\nstruct sh_veu_dev *veu = dev_id;\r\nstruct vb2_v4l2_buffer *dst;\r\nstruct vb2_v4l2_buffer *src;\r\nu32 status = sh_veu_reg_read(veu, VEU_EVTR);\r\nif (!(status & 1))\r\nreturn IRQ_NONE;\r\nsh_veu_reg_write(veu, VEU_EIER, 0);\r\nsh_veu_reg_write(veu, VEU_STR, 0);\r\nsh_veu_reg_write(veu, VEU_EVTR, status & ~1);\r\ndst = v4l2_m2m_dst_buf_remove(veu->m2m_ctx);\r\nsrc = v4l2_m2m_src_buf_remove(veu->m2m_ctx);\r\nif (!src || !dst)\r\nreturn IRQ_NONE;\r\ndst->vb2_buf.timestamp = src->vb2_buf.timestamp;\r\ndst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst->flags |=\r\nsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst->timecode = src->timecode;\r\nspin_lock(&veu->lock);\r\nv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\r\nspin_unlock(&veu->lock);\r\nveu->xaction++;\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int sh_veu_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_veu_dev *veu;\r\nstruct resource *reg_res;\r\nstruct video_device *vdev;\r\nint irq, ret;\r\nreg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!reg_res || irq <= 0) {\r\ndev_err(&pdev->dev, "Insufficient VEU platform information.\n");\r\nreturn -ENODEV;\r\n}\r\nveu = devm_kzalloc(&pdev->dev, sizeof(*veu), GFP_KERNEL);\r\nif (!veu)\r\nreturn -ENOMEM;\r\nveu->is_2h = resource_size(reg_res) == 0x22c;\r\nveu->base = devm_ioremap_resource(&pdev->dev, reg_res);\r\nif (IS_ERR(veu->base))\r\nreturn PTR_ERR(veu->base);\r\nret = devm_request_threaded_irq(&pdev->dev, irq, sh_veu_isr, sh_veu_bh,\r\n0, "veu", veu);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_device_register(&pdev->dev, &veu->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error registering v4l2 device\n");\r\nreturn ret;\r\n}\r\nvdev = &veu->vdev;\r\nveu->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(veu->alloc_ctx)) {\r\nret = PTR_ERR(veu->alloc_ctx);\r\ngoto einitctx;\r\n}\r\n*vdev = sh_veu_videodev;\r\nvdev->v4l2_dev = &veu->v4l2_dev;\r\nspin_lock_init(&veu->lock);\r\nmutex_init(&veu->fop_lock);\r\nvdev->lock = &veu->fop_lock;\r\nvideo_set_drvdata(vdev, veu);\r\nveu->dev = &pdev->dev;\r\nveu->vfmt_out = DEFAULT_OUT_VFMT;\r\nveu->vfmt_in = DEFAULT_IN_VFMT;\r\nveu->m2m_dev = v4l2_m2m_init(&sh_veu_m2m_ops);\r\nif (IS_ERR(veu->m2m_dev)) {\r\nret = PTR_ERR(veu->m2m_dev);\r\nv4l2_err(&veu->v4l2_dev, "Failed to init mem2mem device: %d\n", ret);\r\ngoto em2minit;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\npm_runtime_suspend(&pdev->dev);\r\nif (ret < 0)\r\ngoto evidreg;\r\nreturn ret;\r\nevidreg:\r\npm_runtime_disable(&pdev->dev);\r\nv4l2_m2m_release(veu->m2m_dev);\r\nem2minit:\r\nvb2_dma_contig_cleanup_ctx(veu->alloc_ctx);\r\neinitctx:\r\nv4l2_device_unregister(&veu->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int sh_veu_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct sh_veu_dev *veu = container_of(v4l2_dev,\r\nstruct sh_veu_dev, v4l2_dev);\r\nvideo_unregister_device(&veu->vdev);\r\npm_runtime_disable(&pdev->dev);\r\nv4l2_m2m_release(veu->m2m_dev);\r\nvb2_dma_contig_cleanup_ctx(veu->alloc_ctx);\r\nv4l2_device_unregister(&veu->v4l2_dev);\r\nreturn 0;\r\n}
