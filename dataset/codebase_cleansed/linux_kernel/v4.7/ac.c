static int acpi_ac_get_state(struct acpi_ac *ac)\r\n{\r\nacpi_status status = AE_OK;\r\nif (!ac)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(ac->device->handle, "_PSR", NULL,\r\n&ac->state);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Error reading AC Adapter state"));\r\nac->state = ACPI_AC_STATUS_UNKNOWN;\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_ac_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct acpi_ac *ac = to_acpi_ac(psy);\r\nif (!ac)\r\nreturn -ENODEV;\r\nif (acpi_ac_get_state(ac))\r\nreturn -ENODEV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = ac->state;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_seq_show(struct seq_file *seq, void *offset)\r\n{\r\nstruct acpi_ac *ac = seq->private;\r\nif (!ac)\r\nreturn 0;\r\nif (acpi_ac_get_state(ac)) {\r\nseq_puts(seq, "ERROR: Unable to read AC Adapter state\n");\r\nreturn 0;\r\n}\r\nseq_puts(seq, "state: ");\r\nswitch (ac->state) {\r\ncase ACPI_AC_STATUS_OFFLINE:\r\nseq_puts(seq, "off-line\n");\r\nbreak;\r\ncase ACPI_AC_STATUS_ONLINE:\r\nseq_puts(seq, "on-line\n");\r\nbreak;\r\ndefault:\r\nseq_puts(seq, "unknown\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_open_fs(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, acpi_ac_seq_show, PDE_DATA(inode));\r\n}\r\nstatic int acpi_ac_add_fs(struct acpi_ac *ac)\r\n{\r\nstruct proc_dir_entry *entry = NULL;\r\nprintk(KERN_WARNING PREFIX "Deprecated procfs I/F for AC is loaded,"\r\n" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");\r\nif (!acpi_device_dir(ac->device)) {\r\nacpi_device_dir(ac->device) =\r\nproc_mkdir(acpi_device_bid(ac->device), acpi_ac_dir);\r\nif (!acpi_device_dir(ac->device))\r\nreturn -ENODEV;\r\n}\r\nentry = proc_create_data(ACPI_AC_FILE_STATE,\r\nS_IRUGO, acpi_device_dir(ac->device),\r\n&acpi_ac_fops, ac);\r\nif (!entry)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_remove_fs(struct acpi_ac *ac)\r\n{\r\nif (acpi_device_dir(ac->device)) {\r\nremove_proc_entry(ACPI_AC_FILE_STATE,\r\nacpi_device_dir(ac->device));\r\nremove_proc_entry(acpi_device_bid(ac->device), acpi_ac_dir);\r\nacpi_device_dir(ac->device) = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_ac_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_ac *ac = acpi_driver_data(device);\r\nif (!ac)\r\nreturn;\r\nswitch (event) {\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\ncase ACPI_AC_NOTIFY_STATUS:\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nif (ac_sleep_before_get_state_ms > 0)\r\nmsleep(ac_sleep_before_get_state_ms);\r\nacpi_ac_get_state(ac);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event,\r\n(u32) ac->state);\r\nacpi_notifier_call_chain(device, event, (u32) ac->state);\r\nkobject_uevent(&ac->charger->dev.kobj, KOBJ_CHANGE);\r\n}\r\nreturn;\r\n}\r\nstatic int acpi_ac_battery_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct acpi_ac *ac = container_of(nb, struct acpi_ac, battery_nb);\r\nstruct acpi_bus_event *event = (struct acpi_bus_event *)data;\r\nif (strcmp(event->device_class, ACPI_BATTERY_CLASS) == 0 &&\r\nevent->type == ACPI_BATTERY_NOTIFY_STATUS)\r\nacpi_ac_get_state(ac);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int thinkpad_e530_quirk(const struct dmi_system_id *d)\r\n{\r\nac_sleep_before_get_state_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_add(struct acpi_device *device)\r\n{\r\nstruct power_supply_config psy_cfg = {};\r\nint result = 0;\r\nstruct acpi_ac *ac = NULL;\r\nif (!device)\r\nreturn -EINVAL;\r\nac = kzalloc(sizeof(struct acpi_ac), GFP_KERNEL);\r\nif (!ac)\r\nreturn -ENOMEM;\r\nac->device = device;\r\nstrcpy(acpi_device_name(device), ACPI_AC_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_AC_CLASS);\r\ndevice->driver_data = ac;\r\nresult = acpi_ac_get_state(ac);\r\nif (result)\r\ngoto end;\r\npsy_cfg.drv_data = ac;\r\nac->charger_desc.name = acpi_device_bid(device);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nresult = acpi_ac_add_fs(ac);\r\nif (result)\r\ngoto end;\r\n#endif\r\nac->charger_desc.type = POWER_SUPPLY_TYPE_MAINS;\r\nac->charger_desc.properties = ac_props;\r\nac->charger_desc.num_properties = ARRAY_SIZE(ac_props);\r\nac->charger_desc.get_property = get_ac_property;\r\nac->charger = power_supply_register(&ac->device->dev,\r\n&ac->charger_desc, &psy_cfg);\r\nif (IS_ERR(ac->charger)) {\r\nresult = PTR_ERR(ac->charger);\r\ngoto end;\r\n}\r\nprintk(KERN_INFO PREFIX "%s [%s] (%s)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\nac->state ? "on-line" : "off-line");\r\nac->battery_nb.notifier_call = acpi_ac_battery_notify;\r\nregister_acpi_notifier(&ac->battery_nb);\r\nend:\r\nif (result) {\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_ac_remove_fs(ac);\r\n#endif\r\nkfree(ac);\r\n}\r\ndmi_check_system(ac_dmi_table);\r\nreturn result;\r\n}\r\nstatic int acpi_ac_resume(struct device *dev)\r\n{\r\nstruct acpi_ac *ac;\r\nunsigned old_state;\r\nif (!dev)\r\nreturn -EINVAL;\r\nac = acpi_driver_data(to_acpi_device(dev));\r\nif (!ac)\r\nreturn -EINVAL;\r\nold_state = ac->state;\r\nif (acpi_ac_get_state(ac))\r\nreturn 0;\r\nif (old_state != ac->state)\r\nkobject_uevent(&ac->charger->dev.kobj, KOBJ_CHANGE);\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_ac *ac = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nac = acpi_driver_data(device);\r\npower_supply_unregister(ac->charger);\r\nunregister_acpi_notifier(&ac->battery_nb);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_ac_remove_fs(ac);\r\n#endif\r\nkfree(ac);\r\nreturn 0;\r\n}\r\nstatic int __init acpi_ac_init(void)\r\n{\r\nint result;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_ac_dir = acpi_lock_ac_dir();\r\nif (!acpi_ac_dir)\r\nreturn -ENODEV;\r\n#endif\r\nresult = acpi_bus_register_driver(&acpi_ac_driver);\r\nif (result < 0) {\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_unlock_ac_dir(acpi_ac_dir);\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_ac_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_ac_driver);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_unlock_ac_dir(acpi_ac_dir);\r\n#endif\r\n}
