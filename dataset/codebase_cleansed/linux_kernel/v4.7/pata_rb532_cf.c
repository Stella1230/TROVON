static irqreturn_t rb532_pata_irq_handler(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *ah = dev_instance;\r\nstruct rb532_cf_info *info = ah->private_data;\r\nif (gpio_get_value(info->gpio_line)) {\r\nirq_set_irq_type(info->irq, IRQ_TYPE_LEVEL_LOW);\r\nata_sff_interrupt(info->irq, dev_instance);\r\n} else {\r\nirq_set_irq_type(info->irq, IRQ_TYPE_LEVEL_HIGH);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rb532_pata_setup_ports(struct ata_host *ah)\r\n{\r\nstruct rb532_cf_info *info = ah->private_data;\r\nstruct ata_port *ap;\r\nap = ah->ports[0];\r\nap->ops = &rb532_pata_port_ops;\r\nap->pio_mask = ATA_PIO4;\r\nap->ioaddr.cmd_addr = info->iobase + RB500_CF_REG_BASE;\r\nap->ioaddr.ctl_addr = info->iobase + RB500_CF_REG_CTRL;\r\nap->ioaddr.altstatus_addr = info->iobase + RB500_CF_REG_CTRL;\r\nata_sff_std_ports(&ap->ioaddr);\r\nap->ioaddr.data_addr = info->iobase + RB500_CF_REG_DBUF32;\r\nap->ioaddr.error_addr = info->iobase + RB500_CF_REG_ERR;\r\n}\r\nstatic int rb532_pata_driver_probe(struct platform_device *pdev)\r\n{\r\nint irq;\r\nint gpio;\r\nstruct resource *res;\r\nstruct ata_host *ah;\r\nstruct cf_device *pdata;\r\nstruct rb532_cf_info *info;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no IOMEM resource found\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(&pdev->dev, "no IRQ resource found\n");\r\nreturn -ENOENT;\r\n}\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data specified\n");\r\nreturn -EINVAL;\r\n}\r\ngpio = pdata->gpio_pin;\r\nif (gpio < 0) {\r\ndev_err(&pdev->dev, "no GPIO found for irq%d\n", irq);\r\nreturn -ENOENT;\r\n}\r\nret = gpio_request(gpio, DRV_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "GPIO request failed\n");\r\nreturn ret;\r\n}\r\nah = ata_host_alloc(&pdev->dev, RB500_CF_MAXPORTS);\r\nif (!ah)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ah);\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nah->private_data = info;\r\ninfo->gpio_line = gpio;\r\ninfo->irq = irq;\r\ninfo->iobase = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!info->iobase)\r\nreturn -ENOMEM;\r\nret = gpio_direction_input(gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to set GPIO direction, err=%d\n",\r\nret);\r\ngoto err_free_gpio;\r\n}\r\nrb532_pata_setup_ports(ah);\r\nret = ata_host_activate(ah, irq, rb532_pata_irq_handler,\r\nIRQF_TRIGGER_LOW, &rb532_pata_sht);\r\nif (ret)\r\ngoto err_free_gpio;\r\nreturn 0;\r\nerr_free_gpio:\r\ngpio_free(gpio);\r\nreturn ret;\r\n}\r\nstatic int rb532_pata_driver_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *ah = platform_get_drvdata(pdev);\r\nstruct rb532_cf_info *info = ah->private_data;\r\nata_host_detach(ah);\r\ngpio_free(info->gpio_line);\r\nreturn 0;\r\n}
