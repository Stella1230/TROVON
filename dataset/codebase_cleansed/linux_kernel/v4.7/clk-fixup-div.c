static inline struct clk_fixup_div *to_clk_fixup_div(struct clk_hw *hw)\r\n{\r\nstruct clk_divider *divider = to_clk_divider(hw);\r\nreturn container_of(divider, struct clk_fixup_div, divider);\r\n}\r\nstatic unsigned long clk_fixup_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fixup_div *fixup_div = to_clk_fixup_div(hw);\r\nreturn fixup_div->ops->recalc_rate(&fixup_div->divider.hw, parent_rate);\r\n}\r\nstatic long clk_fixup_div_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_fixup_div *fixup_div = to_clk_fixup_div(hw);\r\nreturn fixup_div->ops->round_rate(&fixup_div->divider.hw, rate, prate);\r\n}\r\nstatic int clk_fixup_div_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fixup_div *fixup_div = to_clk_fixup_div(hw);\r\nstruct clk_divider *div = to_clk_divider(hw);\r\nunsigned int divider, value;\r\nunsigned long flags = 0;\r\nu32 val;\r\ndivider = parent_rate / rate;\r\nvalue = divider - 1;\r\nif (value > div_mask(div))\r\nvalue = div_mask(div);\r\nspin_lock_irqsave(div->lock, flags);\r\nval = readl(div->reg);\r\nval &= ~(div_mask(div) << div->shift);\r\nval |= value << div->shift;\r\nfixup_div->fixup(&val);\r\nwritel(val, div->reg);\r\nspin_unlock_irqrestore(div->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *imx_clk_fixup_divider(const char *name, const char *parent,\r\nvoid __iomem *reg, u8 shift, u8 width,\r\nvoid (*fixup)(u32 *val))\r\n{\r\nstruct clk_fixup_div *fixup_div;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nif (!fixup)\r\nreturn ERR_PTR(-EINVAL);\r\nfixup_div = kzalloc(sizeof(*fixup_div), GFP_KERNEL);\r\nif (!fixup_div)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clk_fixup_div_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.parent_names = parent ? &parent : NULL;\r\ninit.num_parents = parent ? 1 : 0;\r\nfixup_div->divider.reg = reg;\r\nfixup_div->divider.shift = shift;\r\nfixup_div->divider.width = width;\r\nfixup_div->divider.lock = &imx_ccm_lock;\r\nfixup_div->divider.hw.init = &init;\r\nfixup_div->ops = &clk_divider_ops;\r\nfixup_div->fixup = fixup;\r\nclk = clk_register(NULL, &fixup_div->divider.hw);\r\nif (IS_ERR(clk))\r\nkfree(fixup_div);\r\nreturn clk;\r\n}
