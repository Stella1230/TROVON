static const struct fimc_fmt *fimc_lite_find_format(const u32 *pixelformat,\r\nconst u32 *mbus_code, unsigned int mask, int index)\r\n{\r\nconst struct fimc_fmt *fmt, *def_fmt = NULL;\r\nunsigned int i;\r\nint id = 0;\r\nif (index >= (int)ARRAY_SIZE(fimc_lite_formats))\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(fimc_lite_formats); ++i) {\r\nfmt = &fimc_lite_formats[i];\r\nif (mask && !(fmt->flags & mask))\r\ncontinue;\r\nif (pixelformat && fmt->fourcc == *pixelformat)\r\nreturn fmt;\r\nif (mbus_code && fmt->mbus_code == *mbus_code)\r\nreturn fmt;\r\nif (index == id)\r\ndef_fmt = fmt;\r\nid++;\r\n}\r\nreturn def_fmt;\r\n}\r\nstatic int fimc_lite_hw_init(struct fimc_lite *fimc, bool isp_output)\r\n{\r\nstruct fimc_source_info *si;\r\nunsigned long flags;\r\nif (fimc->sensor == NULL)\r\nreturn -ENXIO;\r\nif (fimc->inp_frame.fmt == NULL || fimc->out_frame.fmt == NULL)\r\nreturn -EINVAL;\r\nsi = v4l2_get_subdev_hostdata(fimc->sensor);\r\nif (!si)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nflite_hw_set_camera_bus(fimc, si);\r\nflite_hw_set_source_format(fimc, &fimc->inp_frame);\r\nflite_hw_set_window_offset(fimc, &fimc->inp_frame);\r\nflite_hw_set_dma_buf_mask(fimc, 0);\r\nflite_hw_set_output_dma(fimc, &fimc->out_frame, !isp_output);\r\nflite_hw_set_interrupt_mask(fimc);\r\nflite_hw_set_test_pattern(fimc, fimc->test_pattern->val);\r\nif (debug > 0)\r\nflite_hw_dump_regs(fimc, __func__);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_reinit(struct fimc_lite *fimc, bool suspend)\r\n{\r\nstruct flite_buffer *buf;\r\nunsigned long flags;\r\nbool streaming;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nstreaming = fimc->state & (1 << ST_SENSOR_STREAM);\r\nfimc->state &= ~(1 << ST_FLITE_RUN | 1 << ST_FLITE_OFF |\r\n1 << ST_FLITE_STREAM | 1 << ST_SENSOR_STREAM);\r\nif (suspend)\r\nfimc->state |= (1 << ST_FLITE_SUSPENDED);\r\nelse\r\nfimc->state &= ~(1 << ST_FLITE_PENDING |\r\n1 << ST_FLITE_SUSPENDED);\r\nwhile (!suspend && !list_empty(&fimc->pending_buf_q)) {\r\nbuf = fimc_lite_pending_queue_pop(fimc);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&fimc->active_buf_q)) {\r\nbuf = fimc_lite_active_queue_pop(fimc);\r\nif (suspend)\r\nfimc_lite_pending_queue_add(fimc, buf);\r\nelse\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nflite_hw_reset(fimc);\r\nif (!streaming)\r\nreturn 0;\r\nreturn fimc_pipeline_call(&fimc->ve, set_stream, 0);\r\n}\r\nstatic int fimc_lite_stop_capture(struct fimc_lite *fimc, bool suspend)\r\n{\r\nunsigned long flags;\r\nif (!fimc_lite_active(fimc))\r\nreturn 0;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nset_bit(ST_FLITE_OFF, &fimc->state);\r\nflite_hw_capture_stop(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nwait_event_timeout(fimc->irq_queue,\r\n!test_bit(ST_FLITE_OFF, &fimc->state),\r\n(2*HZ/10));\r\nreturn fimc_lite_reinit(fimc, suspend);\r\n}\r\nstatic void fimc_lite_config_update(struct fimc_lite *fimc)\r\n{\r\nflite_hw_set_window_offset(fimc, &fimc->inp_frame);\r\nflite_hw_set_dma_window(fimc, &fimc->out_frame);\r\nflite_hw_set_test_pattern(fimc, fimc->test_pattern->val);\r\nclear_bit(ST_FLITE_CONFIG, &fimc->state);\r\n}\r\nstatic irqreturn_t flite_irq_handler(int irq, void *priv)\r\n{\r\nstruct fimc_lite *fimc = priv;\r\nstruct flite_buffer *vbuf;\r\nunsigned long flags;\r\nu32 intsrc;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nintsrc = flite_hw_get_interrupt_source(fimc);\r\nflite_hw_clear_pending_irq(fimc);\r\nif (test_and_clear_bit(ST_FLITE_OFF, &fimc->state)) {\r\nwake_up(&fimc->irq_queue);\r\ngoto done;\r\n}\r\nif (intsrc & FLITE_REG_CISTATUS_IRQ_SRC_OVERFLOW) {\r\nclear_bit(ST_FLITE_RUN, &fimc->state);\r\nfimc->events.data_overflow++;\r\n}\r\nif (intsrc & FLITE_REG_CISTATUS_IRQ_SRC_LASTCAPEND) {\r\nflite_hw_clear_last_capture_end(fimc);\r\nclear_bit(ST_FLITE_STREAM, &fimc->state);\r\nwake_up(&fimc->irq_queue);\r\n}\r\nif (atomic_read(&fimc->out_path) != FIMC_IO_DMA)\r\ngoto done;\r\nif ((intsrc & FLITE_REG_CISTATUS_IRQ_SRC_FRMSTART) &&\r\ntest_bit(ST_FLITE_RUN, &fimc->state) &&\r\n!list_empty(&fimc->pending_buf_q)) {\r\nvbuf = fimc_lite_pending_queue_pop(fimc);\r\nflite_hw_set_dma_buffer(fimc, vbuf);\r\nfimc_lite_active_queue_add(fimc, vbuf);\r\n}\r\nif ((intsrc & FLITE_REG_CISTATUS_IRQ_SRC_FRMEND) &&\r\ntest_bit(ST_FLITE_RUN, &fimc->state) &&\r\n!list_empty(&fimc->active_buf_q)) {\r\nvbuf = fimc_lite_active_queue_pop(fimc);\r\nvbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvbuf->vb.sequence = fimc->frame_count++;\r\nflite_hw_mask_dma_buffer(fimc, vbuf->index);\r\nvb2_buffer_done(&vbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nif (test_bit(ST_FLITE_CONFIG, &fimc->state))\r\nfimc_lite_config_update(fimc);\r\nif (list_empty(&fimc->pending_buf_q)) {\r\nflite_hw_capture_stop(fimc);\r\nclear_bit(ST_FLITE_STREAM, &fimc->state);\r\n}\r\ndone:\r\nset_bit(ST_FLITE_RUN, &fimc->state);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct fimc_lite *fimc = q->drv_priv;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nfimc->buf_index = 0;\r\nfimc->frame_count = 0;\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nret = fimc_lite_hw_init(fimc, false);\r\nif (ret) {\r\nfimc_lite_reinit(fimc, false);\r\nreturn ret;\r\n}\r\nset_bit(ST_FLITE_PENDING, &fimc->state);\r\nif (!list_empty(&fimc->active_buf_q) &&\r\n!test_and_set_bit(ST_FLITE_STREAM, &fimc->state)) {\r\nflite_hw_capture_start(fimc);\r\nif (!test_and_set_bit(ST_SENSOR_STREAM, &fimc->state))\r\nfimc_pipeline_call(&fimc->ve, set_stream, 1);\r\n}\r\nif (debug > 0)\r\nflite_hw_dump_regs(fimc, __func__);\r\nreturn 0;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct fimc_lite *fimc = q->drv_priv;\r\nif (!fimc_lite_active(fimc))\r\nreturn;\r\nfimc_lite_stop_capture(fimc, false);\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *allocators[])\r\n{\r\nstruct fimc_lite *fimc = vq->drv_priv;\r\nstruct flite_frame *frame = &fimc->out_frame;\r\nconst struct fimc_fmt *fmt = frame->fmt;\r\nunsigned long wh = frame->f_width * frame->f_height;\r\nint i;\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nif (*num_planes) {\r\nif (*num_planes != fmt->memplanes)\r\nreturn -EINVAL;\r\nfor (i = 0; i < *num_planes; i++) {\r\nif (sizes[i] < (wh * fmt->depth[i]) / 8)\r\nreturn -EINVAL;\r\nallocators[i] = fimc->alloc_ctx;\r\n}\r\nreturn 0;\r\n}\r\n*num_planes = fmt->memplanes;\r\nfor (i = 0; i < fmt->memplanes; i++) {\r\nsizes[i] = (wh * fmt->depth[i]) / 8;\r\nallocators[i] = fimc->alloc_ctx;\r\n}\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct fimc_lite *fimc = vq->drv_priv;\r\nint i;\r\nif (fimc->out_frame.fmt == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < fimc->out_frame.fmt->memplanes; i++) {\r\nunsigned long size = fimc->payload[i];\r\nif (vb2_plane_size(vb, i) < size) {\r\nv4l2_err(&fimc->ve.vdev,\r\n"User buffer too small (%ld < %ld)\n",\r\nvb2_plane_size(vb, i), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, i, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct flite_buffer *buf\r\n= container_of(vbuf, struct flite_buffer, vb);\r\nstruct fimc_lite *fimc = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long flags;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nbuf->paddr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nbuf->index = fimc->buf_index++;\r\nif (fimc->buf_index >= fimc->reqbufs_count)\r\nfimc->buf_index = 0;\r\nif (!test_bit(ST_FLITE_SUSPENDED, &fimc->state) &&\r\n!test_bit(ST_FLITE_STREAM, &fimc->state) &&\r\nlist_empty(&fimc->active_buf_q)) {\r\nflite_hw_set_dma_buffer(fimc, buf);\r\nfimc_lite_active_queue_add(fimc, buf);\r\n} else {\r\nfimc_lite_pending_queue_add(fimc, buf);\r\n}\r\nif (vb2_is_streaming(&fimc->vb_queue) &&\r\n!list_empty(&fimc->pending_buf_q) &&\r\n!test_and_set_bit(ST_FLITE_STREAM, &fimc->state)) {\r\nflite_hw_capture_start(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nif (!test_and_set_bit(ST_SENSOR_STREAM, &fimc->state))\r\nfimc_pipeline_call(&fimc->ve, set_stream, 1);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\n}\r\nstatic void fimc_lite_clear_event_counters(struct fimc_lite *fimc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nmemset(&fimc->events, 0, sizeof(fimc->events));\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\n}\r\nstatic int fimc_lite_open(struct file *file)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstruct media_entity *me = &fimc->ve.vdev.entity;\r\nint ret;\r\nmutex_lock(&fimc->lock);\r\nif (atomic_read(&fimc->out_path) != FIMC_IO_DMA) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nset_bit(ST_FLITE_IN_USE, &fimc->state);\r\nret = pm_runtime_get_sync(&fimc->pdev->dev);\r\nif (ret < 0)\r\ngoto unlock;\r\nret = v4l2_fh_open(file);\r\nif (ret < 0)\r\ngoto err_pm;\r\nif (!v4l2_fh_is_singular_file(file) ||\r\natomic_read(&fimc->out_path) != FIMC_IO_DMA)\r\ngoto unlock;\r\nmutex_lock(&me->graph_obj.mdev->graph_mutex);\r\nret = fimc_pipeline_call(&fimc->ve, open, me, true);\r\nif (ret == 0)\r\nme->use_count++;\r\nmutex_unlock(&me->graph_obj.mdev->graph_mutex);\r\nif (!ret) {\r\nfimc_lite_clear_event_counters(fimc);\r\ngoto unlock;\r\n}\r\nv4l2_fh_release(file);\r\nerr_pm:\r\npm_runtime_put_sync(&fimc->pdev->dev);\r\nclear_bit(ST_FLITE_IN_USE, &fimc->state);\r\nunlock:\r\nmutex_unlock(&fimc->lock);\r\nreturn ret;\r\n}\r\nstatic int fimc_lite_release(struct file *file)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstruct media_entity *entity = &fimc->ve.vdev.entity;\r\nmutex_lock(&fimc->lock);\r\nif (v4l2_fh_is_singular_file(file) &&\r\natomic_read(&fimc->out_path) == FIMC_IO_DMA) {\r\nif (fimc->streaming) {\r\nmedia_entity_pipeline_stop(entity);\r\nfimc->streaming = false;\r\n}\r\nfimc_lite_stop_capture(fimc, false);\r\nfimc_pipeline_call(&fimc->ve, close);\r\nclear_bit(ST_FLITE_IN_USE, &fimc->state);\r\nmutex_lock(&entity->graph_obj.mdev->graph_mutex);\r\nentity->use_count--;\r\nmutex_unlock(&entity->graph_obj.mdev->graph_mutex);\r\n}\r\n_vb2_fop_release(file, NULL);\r\npm_runtime_put(&fimc->pdev->dev);\r\nclear_bit(ST_FLITE_SUSPENDED, &fimc->state);\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nstatic const struct fimc_fmt *fimc_lite_subdev_try_fmt(struct fimc_lite *fimc,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct flite_drvdata *dd = fimc->dd;\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nconst struct fimc_fmt *fmt = NULL;\r\nif (format->pad == FLITE_SD_PAD_SINK) {\r\nv4l_bound_align_image(&mf->width, 8, dd->max_width,\r\nffs(dd->out_width_align) - 1,\r\n&mf->height, 0, dd->max_height, 0, 0);\r\nfmt = fimc_lite_find_format(NULL, &mf->code, 0, 0);\r\nif (WARN_ON(!fmt))\r\nreturn NULL;\r\nmf->colorspace = fmt->colorspace;\r\nmf->code = fmt->mbus_code;\r\n} else {\r\nstruct flite_frame *sink = &fimc->inp_frame;\r\nstruct v4l2_mbus_framefmt *sink_fmt;\r\nstruct v4l2_rect *rect;\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nsink_fmt = v4l2_subdev_get_try_format(&fimc->subdev, cfg,\r\nFLITE_SD_PAD_SINK);\r\nmf->code = sink_fmt->code;\r\nmf->colorspace = sink_fmt->colorspace;\r\nrect = v4l2_subdev_get_try_crop(&fimc->subdev, cfg,\r\nFLITE_SD_PAD_SINK);\r\n} else {\r\nmf->code = sink->fmt->mbus_code;\r\nmf->colorspace = sink->fmt->colorspace;\r\nrect = &sink->rect;\r\n}\r\nmf->width = rect->width;\r\nmf->height = rect->height;\r\n}\r\nmf->field = V4L2_FIELD_NONE;\r\nv4l2_dbg(1, debug, &fimc->subdev, "code: %#x (%d), %dx%d\n",\r\nmf->code, mf->colorspace, mf->width, mf->height);\r\nreturn fmt;\r\n}\r\nstatic void fimc_lite_try_crop(struct fimc_lite *fimc, struct v4l2_rect *r)\r\n{\r\nstruct flite_frame *frame = &fimc->inp_frame;\r\nv4l_bound_align_image(&r->width, 0, frame->f_width, 0,\r\n&r->height, 0, frame->f_height, 0, 0);\r\nr->left = clamp_t(u32, r->left, 0, frame->f_width - r->width);\r\nr->left = round_down(r->left, fimc->dd->win_hor_offs_align);\r\nr->top = clamp_t(u32, r->top, 0, frame->f_height - r->height);\r\nv4l2_dbg(1, debug, &fimc->subdev, "(%d,%d)/%dx%d, sink fmt: %dx%d\n",\r\nr->left, r->top, r->width, r->height,\r\nframe->f_width, frame->f_height);\r\n}\r\nstatic void fimc_lite_try_compose(struct fimc_lite *fimc, struct v4l2_rect *r)\r\n{\r\nstruct flite_frame *frame = &fimc->out_frame;\r\nstruct v4l2_rect *crop_rect = &fimc->inp_frame.rect;\r\nr->width = crop_rect->width;\r\nr->height = crop_rect->height;\r\nr->left = clamp_t(u32, r->left, 0, frame->f_width - r->width);\r\nr->left = round_down(r->left, fimc->dd->out_hor_offs_align);\r\nr->top = clamp_t(u32, r->top, 0, fimc->out_frame.f_height - r->height);\r\nv4l2_dbg(1, debug, &fimc->subdev, "(%d,%d)/%dx%d, source fmt: %dx%d\n",\r\nr->left, r->top, r->width, r->height,\r\nframe->f_width, frame->f_height);\r\n}\r\nstatic int fimc_lite_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstrlcpy(cap->driver, FIMC_LITE_DRV_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, FIMC_LITE_DRV_NAME, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(&fimc->pdev->dev));\r\ncap->device_caps = V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_enum_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nconst struct fimc_fmt *fmt;\r\nif (f->index >= ARRAY_SIZE(fimc_lite_formats))\r\nreturn -EINVAL;\r\nfmt = &fimc_lite_formats[f->index];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_g_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\r\nstruct v4l2_plane_pix_format *plane_fmt = &pixm->plane_fmt[0];\r\nstruct flite_frame *frame = &fimc->out_frame;\r\nconst struct fimc_fmt *fmt = frame->fmt;\r\nplane_fmt->bytesperline = (frame->f_width * fmt->depth[0]) / 8;\r\nplane_fmt->sizeimage = plane_fmt->bytesperline * frame->f_height;\r\npixm->num_planes = fmt->memplanes;\r\npixm->pixelformat = fmt->fourcc;\r\npixm->width = frame->f_width;\r\npixm->height = frame->f_height;\r\npixm->field = V4L2_FIELD_NONE;\r\npixm->colorspace = fmt->colorspace;\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_try_fmt(struct fimc_lite *fimc,\r\nstruct v4l2_pix_format_mplane *pixm,\r\nconst struct fimc_fmt **ffmt)\r\n{\r\nu32 bpl = pixm->plane_fmt[0].bytesperline;\r\nstruct flite_drvdata *dd = fimc->dd;\r\nconst struct fimc_fmt *inp_fmt = fimc->inp_frame.fmt;\r\nconst struct fimc_fmt *fmt;\r\nif (WARN_ON(inp_fmt == NULL))\r\nreturn -EINVAL;\r\nif (inp_fmt->flags & FMT_FLAGS_YUV)\r\nfmt = fimc_lite_find_format(&pixm->pixelformat, NULL,\r\ninp_fmt->flags, 0);\r\nelse\r\nfmt = inp_fmt;\r\nif (WARN_ON(fmt == NULL))\r\nreturn -EINVAL;\r\nif (ffmt)\r\n*ffmt = fmt;\r\nv4l_bound_align_image(&pixm->width, 8, dd->max_width,\r\nffs(dd->out_width_align) - 1,\r\n&pixm->height, 0, dd->max_height, 0, 0);\r\nif ((bpl == 0 || ((bpl * 8) / fmt->depth[0]) < pixm->width))\r\npixm->plane_fmt[0].bytesperline = (pixm->width *\r\nfmt->depth[0]) / 8;\r\nif (pixm->plane_fmt[0].sizeimage == 0)\r\npixm->plane_fmt[0].sizeimage = (pixm->width * pixm->height *\r\nfmt->depth[0]) / 8;\r\npixm->num_planes = fmt->memplanes;\r\npixm->pixelformat = fmt->fourcc;\r\npixm->colorspace = fmt->colorspace;\r\npixm->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_try_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nreturn fimc_lite_try_fmt(fimc, &f->fmt.pix_mp, NULL);\r\n}\r\nstatic int fimc_lite_s_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstruct flite_frame *frame = &fimc->out_frame;\r\nconst struct fimc_fmt *fmt = NULL;\r\nint ret;\r\nif (vb2_is_busy(&fimc->vb_queue))\r\nreturn -EBUSY;\r\nret = fimc_lite_try_fmt(fimc, &f->fmt.pix_mp, &fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nframe->fmt = fmt;\r\nfimc->payload[0] = max((pixm->width * pixm->height * fmt->depth[0]) / 8,\r\npixm->plane_fmt[0].sizeimage);\r\nframe->f_width = pixm->width;\r\nframe->f_height = pixm->height;\r\nreturn 0;\r\n}\r\nstatic int fimc_pipeline_validate(struct fimc_lite *fimc)\r\n{\r\nstruct v4l2_subdev *sd = &fimc->subdev;\r\nstruct v4l2_subdev_format sink_fmt, src_fmt;\r\nstruct media_pad *pad;\r\nint ret;\r\nwhile (1) {\r\npad = &sd->entity.pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\nif (sd == &fimc->subdev) {\r\nstruct flite_frame *ff = &fimc->out_frame;\r\nsink_fmt.format.width = ff->f_width;\r\nsink_fmt.format.height = ff->f_height;\r\nsink_fmt.format.code = fimc->inp_frame.fmt->mbus_code;\r\n} else {\r\nsink_fmt.pad = pad->index;\r\nsink_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL,\r\n&sink_fmt);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\n}\r\npad = media_entity_remote_pad(pad);\r\nif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\r\nbreak;\r\nsd = media_entity_to_v4l2_subdev(pad->entity);\r\nsrc_fmt.pad = pad->index;\r\nsrc_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &src_fmt);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\nif (src_fmt.format.width != sink_fmt.format.width ||\r\nsrc_fmt.format.height != sink_fmt.format.height ||\r\nsrc_fmt.format.code != sink_fmt.format.code)\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstruct media_entity *entity = &fimc->ve.vdev.entity;\r\nint ret;\r\nif (fimc_lite_active(fimc))\r\nreturn -EBUSY;\r\nret = media_entity_pipeline_start(entity, &fimc->ve.pipe->mp);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fimc_pipeline_validate(fimc);\r\nif (ret < 0)\r\ngoto err_p_stop;\r\nfimc->sensor = fimc_find_remote_sensor(&fimc->subdev.entity);\r\nret = vb2_ioctl_streamon(file, priv, type);\r\nif (!ret) {\r\nfimc->streaming = true;\r\nreturn ret;\r\n}\r\nerr_p_stop:\r\nmedia_entity_pipeline_stop(entity);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nint ret;\r\nret = vb2_ioctl_streamoff(file, priv, type);\r\nif (ret < 0)\r\nreturn ret;\r\nmedia_entity_pipeline_stop(&fimc->ve.vdev.entity);\r\nfimc->streaming = false;\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nint ret;\r\nreqbufs->count = max_t(u32, FLITE_REQ_BUFS_MIN, reqbufs->count);\r\nret = vb2_ioctl_reqbufs(file, priv, reqbufs);\r\nif (!ret)\r\nfimc->reqbufs_count = reqbufs->count;\r\nreturn ret;\r\n}\r\nstatic int enclosed_rectangle(struct v4l2_rect *a, struct v4l2_rect *b)\r\n{\r\nif (a->left < b->left || a->top < b->top)\r\nreturn 0;\r\nif (a->left + a->width > b->left + b->width)\r\nreturn 0;\r\nif (a->top + a->height > b->top + b->height)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int fimc_lite_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstruct flite_frame *f = &fimc->out_frame;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = f->f_width;\r\nsel->r.height = f->f_height;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nsel->r = f->rect;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int fimc_lite_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct fimc_lite *fimc = video_drvdata(file);\r\nstruct flite_frame *f = &fimc->out_frame;\r\nstruct v4l2_rect rect = sel->r;\r\nunsigned long flags;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ||\r\nsel->target != V4L2_SEL_TGT_COMPOSE)\r\nreturn -EINVAL;\r\nfimc_lite_try_compose(fimc, &rect);\r\nif ((sel->flags & V4L2_SEL_FLAG_LE) &&\r\n!enclosed_rectangle(&rect, &sel->r))\r\nreturn -ERANGE;\r\nif ((sel->flags & V4L2_SEL_FLAG_GE) &&\r\n!enclosed_rectangle(&sel->r, &rect))\r\nreturn -ERANGE;\r\nsel->r = rect;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nf->rect = rect;\r\nset_bit(ST_FLITE_CONFIG, &fimc->state);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nint ret = 0;\r\nif (WARN_ON(fimc == NULL))\r\nreturn 0;\r\nv4l2_dbg(1, debug, sd, "%s: %s --> %s, flags: 0x%x. source_id: 0x%x\n",\r\n__func__, remote->entity->name, local->entity->name,\r\nflags, fimc->source_subdev_grp_id);\r\nswitch (local->index) {\r\ncase FLITE_SD_PAD_SINK:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (fimc->source_subdev_grp_id == 0)\r\nfimc->source_subdev_grp_id = sd->grp_id;\r\nelse\r\nret = -EBUSY;\r\n} else {\r\nfimc->source_subdev_grp_id = 0;\r\nfimc->sensor = NULL;\r\n}\r\nbreak;\r\ncase FLITE_SD_PAD_SOURCE_DMA:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED))\r\natomic_set(&fimc->out_path, FIMC_IO_NONE);\r\nelse\r\natomic_set(&fimc->out_path, FIMC_IO_DMA);\r\nbreak;\r\ncase FLITE_SD_PAD_SOURCE_ISP:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED))\r\natomic_set(&fimc->out_path, FIMC_IO_NONE);\r\nelse\r\natomic_set(&fimc->out_path, FIMC_IO_ISP);\r\nbreak;\r\ndefault:\r\nv4l2_err(sd, "Invalid pad index\n");\r\nret = -EINVAL;\r\n}\r\nmb();\r\nreturn ret;\r\n}\r\nstatic int fimc_lite_subdev_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nconst struct fimc_fmt *fmt;\r\nfmt = fimc_lite_find_format(NULL, NULL, 0, code->index);\r\nif (!fmt)\r\nreturn -EINVAL;\r\ncode->code = fmt->mbus_code;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *__fimc_lite_subdev_get_try_fmt(\r\nstruct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg, unsigned int pad)\r\n{\r\nif (pad != FLITE_SD_PAD_SINK)\r\npad = FLITE_SD_PAD_SOURCE_DMA;\r\nreturn v4l2_subdev_get_try_format(sd, cfg, pad);\r\n}\r\nstatic int fimc_lite_subdev_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nstruct flite_frame *f = &fimc->inp_frame;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = __fimc_lite_subdev_get_try_fmt(sd, cfg, fmt->pad);\r\nfmt->format = *mf;\r\nreturn 0;\r\n}\r\nmutex_lock(&fimc->lock);\r\nmf->colorspace = f->fmt->colorspace;\r\nmf->code = f->fmt->mbus_code;\r\nif (fmt->pad == FLITE_SD_PAD_SINK) {\r\nmf->width = f->f_width;\r\nmf->height = f->f_height;\r\n} else {\r\nmf->width = f->rect.width;\r\nmf->height = f->rect.height;\r\n}\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_subdev_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nstruct flite_frame *sink = &fimc->inp_frame;\r\nstruct flite_frame *source = &fimc->out_frame;\r\nconst struct fimc_fmt *ffmt;\r\nv4l2_dbg(1, debug, sd, "pad%d: code: 0x%x, %dx%d\n",\r\nfmt->pad, mf->code, mf->width, mf->height);\r\nmutex_lock(&fimc->lock);\r\nif ((atomic_read(&fimc->out_path) == FIMC_IO_ISP &&\r\nsd->entity.stream_count > 0) ||\r\n(atomic_read(&fimc->out_path) == FIMC_IO_DMA &&\r\nvb2_is_busy(&fimc->vb_queue))) {\r\nmutex_unlock(&fimc->lock);\r\nreturn -EBUSY;\r\n}\r\nffmt = fimc_lite_subdev_try_fmt(fimc, cfg, fmt);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *src_fmt;\r\nmf = __fimc_lite_subdev_get_try_fmt(sd, cfg, fmt->pad);\r\n*mf = fmt->format;\r\nif (fmt->pad == FLITE_SD_PAD_SINK) {\r\nunsigned int pad = FLITE_SD_PAD_SOURCE_DMA;\r\nsrc_fmt = __fimc_lite_subdev_get_try_fmt(sd, cfg, pad);\r\n*src_fmt = *mf;\r\n}\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nif (fmt->pad == FLITE_SD_PAD_SINK) {\r\nsink->f_width = mf->width;\r\nsink->f_height = mf->height;\r\nsink->fmt = ffmt;\r\nsink->rect.width = mf->width;\r\nsink->rect.height = mf->height;\r\nsink->rect.left = 0;\r\nsink->rect.top = 0;\r\nsource->rect = sink->rect;\r\nsource->f_width = mf->width;\r\nsource->f_height = mf->height;\r\n}\r\nmutex_unlock(&fimc->lock);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_subdev_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nstruct flite_frame *f = &fimc->inp_frame;\r\nif ((sel->target != V4L2_SEL_TGT_CROP &&\r\nsel->target != V4L2_SEL_TGT_CROP_BOUNDS) ||\r\nsel->pad != FLITE_SD_PAD_SINK)\r\nreturn -EINVAL;\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nsel->r = *v4l2_subdev_get_try_crop(sd, cfg, sel->pad);\r\nreturn 0;\r\n}\r\nmutex_lock(&fimc->lock);\r\nif (sel->target == V4L2_SEL_TGT_CROP) {\r\nsel->r = f->rect;\r\n} else {\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = f->f_width;\r\nsel->r.height = f->f_height;\r\n}\r\nmutex_unlock(&fimc->lock);\r\nv4l2_dbg(1, debug, sd, "%s: (%d,%d) %dx%d, f_w: %d, f_h: %d\n",\r\n__func__, f->rect.left, f->rect.top, f->rect.width,\r\nf->rect.height, f->f_width, f->f_height);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_subdev_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nstruct flite_frame *f = &fimc->inp_frame;\r\nint ret = 0;\r\nif (sel->target != V4L2_SEL_TGT_CROP || sel->pad != FLITE_SD_PAD_SINK)\r\nreturn -EINVAL;\r\nmutex_lock(&fimc->lock);\r\nfimc_lite_try_crop(fimc, &sel->r);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\n*v4l2_subdev_get_try_crop(sd, cfg, sel->pad) = sel->r;\r\n} else {\r\nunsigned long flags;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nf->rect = sel->r;\r\nfimc->out_frame.rect = sel->r;\r\nset_bit(ST_FLITE_CONFIG, &fimc->state);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\n}\r\nmutex_unlock(&fimc->lock);\r\nv4l2_dbg(1, debug, sd, "%s: (%d,%d) %dx%d, f_w: %d, f_h: %d\n",\r\n__func__, f->rect.left, f->rect.top, f->rect.width,\r\nf->rect.height, f->f_width, f->f_height);\r\nreturn ret;\r\n}\r\nstatic int fimc_lite_subdev_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nunsigned long flags;\r\nint ret;\r\nfimc->sensor = fimc_find_remote_sensor(&sd->entity);\r\nif (atomic_read(&fimc->out_path) != FIMC_IO_ISP)\r\nreturn -ENOIOCTLCMD;\r\nmutex_lock(&fimc->lock);\r\nif (on) {\r\nflite_hw_reset(fimc);\r\nret = fimc_lite_hw_init(fimc, true);\r\nif (!ret) {\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nflite_hw_capture_start(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\n}\r\n} else {\r\nset_bit(ST_FLITE_OFF, &fimc->state);\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nflite_hw_capture_stop(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nret = wait_event_timeout(fimc->irq_queue,\r\n!test_bit(ST_FLITE_OFF, &fimc->state),\r\nmsecs_to_jiffies(200));\r\nif (ret == 0)\r\nv4l2_err(sd, "s_stream(0) timeout\n");\r\nclear_bit(ST_FLITE_RUN, &fimc->state);\r\n}\r\nmutex_unlock(&fimc->lock);\r\nreturn ret;\r\n}\r\nstatic int fimc_lite_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nflite_hw_dump_regs(fimc, __func__);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_subdev_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nstruct vb2_queue *q = &fimc->vb_queue;\r\nstruct video_device *vfd = &fimc->ve.vdev;\r\nint ret;\r\nmemset(vfd, 0, sizeof(*vfd));\r\natomic_set(&fimc->out_path, FIMC_IO_DMA);\r\nsnprintf(vfd->name, sizeof(vfd->name), "fimc-lite.%d.capture",\r\nfimc->index);\r\nvfd->fops = &fimc_lite_fops;\r\nvfd->ioctl_ops = &fimc_lite_ioctl_ops;\r\nvfd->v4l2_dev = sd->v4l2_dev;\r\nvfd->minor = -1;\r\nvfd->release = video_device_release_empty;\r\nvfd->queue = q;\r\nfimc->reqbufs_count = 0;\r\nINIT_LIST_HEAD(&fimc->pending_buf_q);\r\nINIT_LIST_HEAD(&fimc->active_buf_q);\r\nmemset(q, 0, sizeof(*q));\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->ops = &fimc_lite_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct flite_buffer);\r\nq->drv_priv = fimc;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &fimc->lock;\r\nret = vb2_queue_init(q);\r\nif (ret < 0)\r\nreturn ret;\r\nfimc->vd_pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_pads_init(&vfd->entity, 1, &fimc->vd_pad);\r\nif (ret < 0)\r\nreturn ret;\r\nvideo_set_drvdata(vfd, fimc);\r\nfimc->ve.pipe = v4l2_get_subdev_hostdata(sd);\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\nmedia_entity_cleanup(&vfd->entity);\r\nfimc->ve.pipe = NULL;\r\nreturn ret;\r\n}\r\nv4l2_info(sd->v4l2_dev, "Registered %s as /dev/%s\n",\r\nvfd->name, video_device_node_name(vfd));\r\nreturn 0;\r\n}\r\nstatic void fimc_lite_subdev_unregistered(struct v4l2_subdev *sd)\r\n{\r\nstruct fimc_lite *fimc = v4l2_get_subdevdata(sd);\r\nif (fimc == NULL)\r\nreturn;\r\nmutex_lock(&fimc->lock);\r\nif (video_is_registered(&fimc->ve.vdev)) {\r\nvideo_unregister_device(&fimc->ve.vdev);\r\nmedia_entity_cleanup(&fimc->ve.vdev.entity);\r\nfimc->ve.pipe = NULL;\r\n}\r\nmutex_unlock(&fimc->lock);\r\n}\r\nstatic int fimc_lite_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fimc_lite *fimc = container_of(ctrl->handler, struct fimc_lite,\r\nctrl_handler);\r\nset_bit(ST_FLITE_CONFIG, &fimc->state);\r\nreturn 0;\r\n}\r\nstatic void fimc_lite_set_default_config(struct fimc_lite *fimc)\r\n{\r\nstruct flite_frame *sink = &fimc->inp_frame;\r\nstruct flite_frame *source = &fimc->out_frame;\r\nsink->fmt = &fimc_lite_formats[0];\r\nsink->f_width = FLITE_DEFAULT_WIDTH;\r\nsink->f_height = FLITE_DEFAULT_HEIGHT;\r\nsink->rect.width = FLITE_DEFAULT_WIDTH;\r\nsink->rect.height = FLITE_DEFAULT_HEIGHT;\r\nsink->rect.left = 0;\r\nsink->rect.top = 0;\r\n*source = *sink;\r\n}\r\nstatic int fimc_lite_create_capture_subdev(struct fimc_lite *fimc)\r\n{\r\nstruct v4l2_ctrl_handler *handler = &fimc->ctrl_handler;\r\nstruct v4l2_subdev *sd = &fimc->subdev;\r\nint ret;\r\nv4l2_subdev_init(sd, &fimc_lite_subdev_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsnprintf(sd->name, sizeof(sd->name), "FIMC-LITE.%d", fimc->index);\r\nfimc->subdev_pads[FLITE_SD_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\nfimc->subdev_pads[FLITE_SD_PAD_SOURCE_DMA].flags = MEDIA_PAD_FL_SOURCE;\r\nfimc->subdev_pads[FLITE_SD_PAD_SOURCE_ISP].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&sd->entity, FLITE_SD_PADS_NUM,\r\nfimc->subdev_pads);\r\nif (ret)\r\nreturn ret;\r\nv4l2_ctrl_handler_init(handler, 1);\r\nfimc->test_pattern = v4l2_ctrl_new_custom(handler, &fimc_lite_ctrl,\r\nNULL);\r\nif (handler->error) {\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn handler->error;\r\n}\r\nsd->ctrl_handler = handler;\r\nsd->internal_ops = &fimc_lite_subdev_internal_ops;\r\nsd->entity.ops = &fimc_lite_subdev_media_ops;\r\nsd->owner = THIS_MODULE;\r\nv4l2_set_subdevdata(sd, fimc);\r\nreturn 0;\r\n}\r\nstatic void fimc_lite_unregister_capture_subdev(struct fimc_lite *fimc)\r\n{\r\nstruct v4l2_subdev *sd = &fimc->subdev;\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_ctrl_handler_free(&fimc->ctrl_handler);\r\nv4l2_set_subdevdata(sd, NULL);\r\n}\r\nstatic void fimc_lite_clk_put(struct fimc_lite *fimc)\r\n{\r\nif (IS_ERR(fimc->clock))\r\nreturn;\r\nclk_unprepare(fimc->clock);\r\nclk_put(fimc->clock);\r\nfimc->clock = ERR_PTR(-EINVAL);\r\n}\r\nstatic int fimc_lite_clk_get(struct fimc_lite *fimc)\r\n{\r\nint ret;\r\nfimc->clock = clk_get(&fimc->pdev->dev, FLITE_CLK_NAME);\r\nif (IS_ERR(fimc->clock))\r\nreturn PTR_ERR(fimc->clock);\r\nret = clk_prepare(fimc->clock);\r\nif (ret < 0) {\r\nclk_put(fimc->clock);\r\nfimc->clock = ERR_PTR(-EINVAL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fimc_lite_probe(struct platform_device *pdev)\r\n{\r\nstruct flite_drvdata *drv_data = NULL;\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id;\r\nstruct fimc_lite *fimc;\r\nstruct resource *res;\r\nint ret;\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nfimc = devm_kzalloc(dev, sizeof(*fimc), GFP_KERNEL);\r\nif (!fimc)\r\nreturn -ENOMEM;\r\nof_id = of_match_node(flite_of_match, dev->of_node);\r\nif (of_id)\r\ndrv_data = (struct flite_drvdata *)of_id->data;\r\nfimc->index = of_alias_get_id(dev->of_node, "fimc-lite");\r\nif (!drv_data || fimc->index >= drv_data->num_instances ||\r\nfimc->index < 0) {\r\ndev_err(dev, "Wrong %s node alias\n",\r\ndev->of_node->full_name);\r\nreturn -EINVAL;\r\n}\r\nfimc->dd = drv_data;\r\nfimc->pdev = pdev;\r\ninit_waitqueue_head(&fimc->irq_queue);\r\nspin_lock_init(&fimc->slock);\r\nmutex_init(&fimc->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nfimc->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(fimc->regs))\r\nreturn PTR_ERR(fimc->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "Failed to get IRQ resource\n");\r\nreturn -ENXIO;\r\n}\r\nret = fimc_lite_clk_get(fimc);\r\nif (ret)\r\nreturn ret;\r\nret = devm_request_irq(dev, res->start, flite_irq_handler,\r\n0, dev_name(dev), fimc);\r\nif (ret) {\r\ndev_err(dev, "Failed to install irq (%d)\n", ret);\r\ngoto err_clk_put;\r\n}\r\nret = fimc_lite_create_capture_subdev(fimc);\r\nif (ret)\r\ngoto err_clk_put;\r\nplatform_set_drvdata(pdev, fimc);\r\npm_runtime_enable(dev);\r\nif (!pm_runtime_enabled(dev)) {\r\nret = clk_enable(fimc->clock);\r\nif (ret < 0)\r\ngoto err_sd;\r\n}\r\nfimc->alloc_ctx = vb2_dma_contig_init_ctx(dev);\r\nif (IS_ERR(fimc->alloc_ctx)) {\r\nret = PTR_ERR(fimc->alloc_ctx);\r\ngoto err_clk_dis;\r\n}\r\nfimc_lite_set_default_config(fimc);\r\ndev_dbg(dev, "FIMC-LITE.%d registered successfully\n",\r\nfimc->index);\r\nreturn 0;\r\nerr_clk_dis:\r\nif (!pm_runtime_enabled(dev))\r\nclk_disable(fimc->clock);\r\nerr_sd:\r\nfimc_lite_unregister_capture_subdev(fimc);\r\nerr_clk_put:\r\nfimc_lite_clk_put(fimc);\r\nreturn ret;\r\n}\r\nstatic int fimc_lite_runtime_resume(struct device *dev)\r\n{\r\nstruct fimc_lite *fimc = dev_get_drvdata(dev);\r\nclk_enable(fimc->clock);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_runtime_suspend(struct device *dev)\r\n{\r\nstruct fimc_lite *fimc = dev_get_drvdata(dev);\r\nclk_disable(fimc->clock);\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_resume(struct device *dev)\r\n{\r\nstruct fimc_lite *fimc = dev_get_drvdata(dev);\r\nstruct flite_buffer *buf;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&fimc->slock, flags);\r\nif (!test_and_clear_bit(ST_LPM, &fimc->state) ||\r\n!test_bit(ST_FLITE_IN_USE, &fimc->state)) {\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nreturn 0;\r\n}\r\nflite_hw_reset(fimc);\r\nspin_unlock_irqrestore(&fimc->slock, flags);\r\nif (!test_and_clear_bit(ST_FLITE_SUSPENDED, &fimc->state))\r\nreturn 0;\r\nINIT_LIST_HEAD(&fimc->active_buf_q);\r\nfimc_pipeline_call(&fimc->ve, open,\r\n&fimc->ve.vdev.entity, false);\r\nfimc_lite_hw_init(fimc, atomic_read(&fimc->out_path) == FIMC_IO_ISP);\r\nclear_bit(ST_FLITE_SUSPENDED, &fimc->state);\r\nfor (i = 0; i < fimc->reqbufs_count; i++) {\r\nif (list_empty(&fimc->pending_buf_q))\r\nbreak;\r\nbuf = fimc_lite_pending_queue_pop(fimc);\r\nbuffer_queue(&buf->vb.vb2_buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_lite_suspend(struct device *dev)\r\n{\r\nstruct fimc_lite *fimc = dev_get_drvdata(dev);\r\nbool suspend = test_bit(ST_FLITE_IN_USE, &fimc->state);\r\nint ret;\r\nif (test_and_set_bit(ST_LPM, &fimc->state))\r\nreturn 0;\r\nret = fimc_lite_stop_capture(fimc, suspend);\r\nif (ret < 0 || !fimc_lite_active(fimc))\r\nreturn ret;\r\nreturn fimc_pipeline_call(&fimc->ve, close);\r\n}\r\nstatic int fimc_lite_remove(struct platform_device *pdev)\r\n{\r\nstruct fimc_lite *fimc = platform_get_drvdata(pdev);\r\nstruct device *dev = &pdev->dev;\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\nfimc_lite_unregister_capture_subdev(fimc);\r\nvb2_dma_contig_cleanup_ctx(fimc->alloc_ctx);\r\nfimc_lite_clk_put(fimc);\r\ndev_info(dev, "Driver unloaded\n");\r\nreturn 0;\r\n}
