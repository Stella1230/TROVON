static void rmi_free_function_list(struct rmi_device *rmi_dev)\r\n{\r\nstruct rmi_function *fn, *tmp;\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\ndata->f01_container = NULL;\r\nlist_for_each_entry_safe_reverse(fn, tmp,\r\n&data->function_list, node) {\r\nlist_del(&fn->node);\r\nrmi_unregister_function(fn);\r\n}\r\n}\r\nstatic int reset_one_function(struct rmi_function *fn)\r\n{\r\nstruct rmi_function_handler *fh;\r\nint retval = 0;\r\nif (!fn || !fn->dev.driver)\r\nreturn 0;\r\nfh = to_rmi_function_handler(fn->dev.driver);\r\nif (fh->reset) {\r\nretval = fh->reset(fn);\r\nif (retval < 0)\r\ndev_err(&fn->dev, "Reset failed with code %d.\n",\r\nretval);\r\n}\r\nreturn retval;\r\n}\r\nstatic int configure_one_function(struct rmi_function *fn)\r\n{\r\nstruct rmi_function_handler *fh;\r\nint retval = 0;\r\nif (!fn || !fn->dev.driver)\r\nreturn 0;\r\nfh = to_rmi_function_handler(fn->dev.driver);\r\nif (fh->config) {\r\nretval = fh->config(fn);\r\nif (retval < 0)\r\ndev_err(&fn->dev, "Config failed with code %d.\n",\r\nretval);\r\n}\r\nreturn retval;\r\n}\r\nstatic int rmi_driver_process_reset_requests(struct rmi_device *rmi_dev)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct rmi_function *entry;\r\nint retval;\r\nlist_for_each_entry(entry, &data->function_list, node) {\r\nretval = reset_one_function(entry);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_driver_process_config_requests(struct rmi_device *rmi_dev)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct rmi_function *entry;\r\nint retval;\r\nlist_for_each_entry(entry, &data->function_list, node) {\r\nretval = configure_one_function(entry);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_one_interrupt(struct rmi_driver_data *data,\r\nstruct rmi_function *fn)\r\n{\r\nstruct rmi_function_handler *fh;\r\nif (!fn || !fn->dev.driver)\r\nreturn;\r\nfh = to_rmi_function_handler(fn->dev.driver);\r\nif (fh->attention) {\r\nbitmap_and(data->fn_irq_bits, data->irq_status, fn->irq_mask,\r\ndata->irq_count);\r\nif (!bitmap_empty(data->fn_irq_bits, data->irq_count))\r\nfh->attention(fn, data->fn_irq_bits);\r\n}\r\n}\r\nint rmi_process_interrupt_requests(struct rmi_device *rmi_dev)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct device *dev = &rmi_dev->dev;\r\nstruct rmi_function *entry;\r\nint error;\r\nif (!data)\r\nreturn 0;\r\nif (!rmi_dev->xport->attn_data) {\r\nerror = rmi_read_block(rmi_dev,\r\ndata->f01_container->fd.data_base_addr + 1,\r\ndata->irq_status, data->num_of_irq_regs);\r\nif (error < 0) {\r\ndev_err(dev, "Failed to read irqs, code=%d\n", error);\r\nreturn error;\r\n}\r\n}\r\nmutex_lock(&data->irq_mutex);\r\nbitmap_and(data->irq_status, data->irq_status, data->current_irq_mask,\r\ndata->irq_count);\r\nmutex_unlock(&data->irq_mutex);\r\nlist_for_each_entry(entry, &data->function_list, node)\r\nprocess_one_interrupt(data, entry);\r\nif (data->input)\r\ninput_sync(data->input);\r\nreturn 0;\r\n}\r\nstatic int suspend_one_function(struct rmi_function *fn)\r\n{\r\nstruct rmi_function_handler *fh;\r\nint retval = 0;\r\nif (!fn || !fn->dev.driver)\r\nreturn 0;\r\nfh = to_rmi_function_handler(fn->dev.driver);\r\nif (fh->suspend) {\r\nretval = fh->suspend(fn);\r\nif (retval < 0)\r\ndev_err(&fn->dev, "Suspend failed with code %d.\n",\r\nretval);\r\n}\r\nreturn retval;\r\n}\r\nstatic int rmi_suspend_functions(struct rmi_device *rmi_dev)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct rmi_function *entry;\r\nint retval;\r\nlist_for_each_entry(entry, &data->function_list, node) {\r\nretval = suspend_one_function(entry);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int resume_one_function(struct rmi_function *fn)\r\n{\r\nstruct rmi_function_handler *fh;\r\nint retval = 0;\r\nif (!fn || !fn->dev.driver)\r\nreturn 0;\r\nfh = to_rmi_function_handler(fn->dev.driver);\r\nif (fh->resume) {\r\nretval = fh->resume(fn);\r\nif (retval < 0)\r\ndev_err(&fn->dev, "Resume failed with code %d.\n",\r\nretval);\r\n}\r\nreturn retval;\r\n}\r\nstatic int rmi_resume_functions(struct rmi_device *rmi_dev)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct rmi_function *entry;\r\nint retval;\r\nlist_for_each_entry(entry, &data->function_list, node) {\r\nretval = resume_one_function(entry);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int enable_sensor(struct rmi_device *rmi_dev)\r\n{\r\nint retval = 0;\r\nretval = rmi_driver_process_config_requests(rmi_dev);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn rmi_process_interrupt_requests(rmi_dev);\r\n}\r\nstatic int rmi_driver_set_input_params(struct rmi_device *rmi_dev,\r\nstruct input_dev *input)\r\n{\r\ninput->name = SYNAPTICS_INPUT_DEVICE_NAME;\r\ninput->id.vendor = SYNAPTICS_VENDOR_ID;\r\ninput->id.bustype = BUS_RMI;\r\nreturn 0;\r\n}\r\nstatic void rmi_driver_set_input_name(struct rmi_device *rmi_dev,\r\nstruct input_dev *input)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nchar *device_name = rmi_f01_get_product_ID(data->f01_container);\r\nchar *name;\r\nname = devm_kasprintf(&rmi_dev->dev, GFP_KERNEL,\r\n"Synaptics %s", device_name);\r\nif (!name)\r\nreturn;\r\ninput->name = name;\r\n}\r\nstatic int rmi_driver_set_irq_bits(struct rmi_device *rmi_dev,\r\nunsigned long *mask)\r\n{\r\nint error = 0;\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct device *dev = &rmi_dev->dev;\r\nmutex_lock(&data->irq_mutex);\r\nbitmap_or(data->new_irq_mask,\r\ndata->current_irq_mask, mask, data->irq_count);\r\nerror = rmi_write_block(rmi_dev,\r\ndata->f01_container->fd.control_base_addr + 1,\r\ndata->new_irq_mask, data->num_of_irq_regs);\r\nif (error < 0) {\r\ndev_err(dev, "%s: Failed to change enabled interrupts!",\r\n__func__);\r\ngoto error_unlock;\r\n}\r\nbitmap_copy(data->current_irq_mask, data->new_irq_mask,\r\ndata->num_of_irq_regs);\r\nerror_unlock:\r\nmutex_unlock(&data->irq_mutex);\r\nreturn error;\r\n}\r\nstatic int rmi_driver_clear_irq_bits(struct rmi_device *rmi_dev,\r\nunsigned long *mask)\r\n{\r\nint error = 0;\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct device *dev = &rmi_dev->dev;\r\nmutex_lock(&data->irq_mutex);\r\nbitmap_andnot(data->new_irq_mask,\r\ndata->current_irq_mask, mask, data->irq_count);\r\nerror = rmi_write_block(rmi_dev,\r\ndata->f01_container->fd.control_base_addr + 1,\r\ndata->new_irq_mask, data->num_of_irq_regs);\r\nif (error < 0) {\r\ndev_err(dev, "%s: Failed to change enabled interrupts!",\r\n__func__);\r\ngoto error_unlock;\r\n}\r\nbitmap_copy(data->current_irq_mask, data->new_irq_mask,\r\ndata->num_of_irq_regs);\r\nerror_unlock:\r\nmutex_unlock(&data->irq_mutex);\r\nreturn error;\r\n}\r\nstatic int rmi_driver_reset_handler(struct rmi_device *rmi_dev)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nint error;\r\nif (!data || !data->f01_container) {\r\ndev_warn(&rmi_dev->dev,\r\n"Not ready to handle reset yet!\n");\r\nreturn 0;\r\n}\r\nerror = rmi_read_block(rmi_dev,\r\ndata->f01_container->fd.control_base_addr + 1,\r\ndata->current_irq_mask, data->num_of_irq_regs);\r\nif (error < 0) {\r\ndev_err(&rmi_dev->dev, "%s: Failed to read current IRQ mask.\n",\r\n__func__);\r\nreturn error;\r\n}\r\nerror = rmi_driver_process_reset_requests(rmi_dev);\r\nif (error < 0)\r\nreturn error;\r\nerror = rmi_driver_process_config_requests(rmi_dev);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nint rmi_read_pdt_entry(struct rmi_device *rmi_dev, struct pdt_entry *entry,\r\nu16 pdt_address)\r\n{\r\nu8 buf[RMI_PDT_ENTRY_SIZE];\r\nint error;\r\nerror = rmi_read_block(rmi_dev, pdt_address, buf, RMI_PDT_ENTRY_SIZE);\r\nif (error) {\r\ndev_err(&rmi_dev->dev, "Read PDT entry at %#06x failed, code: %d.\n",\r\npdt_address, error);\r\nreturn error;\r\n}\r\nentry->page_start = pdt_address & RMI4_PAGE_MASK;\r\nentry->query_base_addr = buf[0];\r\nentry->command_base_addr = buf[1];\r\nentry->control_base_addr = buf[2];\r\nentry->data_base_addr = buf[3];\r\nentry->interrupt_source_count = buf[4] & RMI_PDT_INT_SOURCE_COUNT_MASK;\r\nentry->function_version = (buf[4] & RMI_PDT_FUNCTION_VERSION_MASK) >> 5;\r\nentry->function_number = buf[5];\r\nreturn 0;\r\n}\r\nstatic void rmi_driver_copy_pdt_to_fd(const struct pdt_entry *pdt,\r\nstruct rmi_function_descriptor *fd)\r\n{\r\nfd->query_base_addr = pdt->query_base_addr + pdt->page_start;\r\nfd->command_base_addr = pdt->command_base_addr + pdt->page_start;\r\nfd->control_base_addr = pdt->control_base_addr + pdt->page_start;\r\nfd->data_base_addr = pdt->data_base_addr + pdt->page_start;\r\nfd->function_number = pdt->function_number;\r\nfd->interrupt_source_count = pdt->interrupt_source_count;\r\nfd->function_version = pdt->function_version;\r\n}\r\nstatic int rmi_scan_pdt_page(struct rmi_device *rmi_dev,\r\nint page,\r\nvoid *ctx,\r\nint (*callback)(struct rmi_device *rmi_dev,\r\nvoid *ctx,\r\nconst struct pdt_entry *entry))\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct pdt_entry pdt_entry;\r\nu16 page_start = RMI4_PAGE_SIZE * page;\r\nu16 pdt_start = page_start + PDT_START_SCAN_LOCATION;\r\nu16 pdt_end = page_start + PDT_END_SCAN_LOCATION;\r\nu16 addr;\r\nint error;\r\nint retval;\r\nfor (addr = pdt_start; addr >= pdt_end; addr -= RMI_PDT_ENTRY_SIZE) {\r\nerror = rmi_read_pdt_entry(rmi_dev, &pdt_entry, addr);\r\nif (error)\r\nreturn error;\r\nif (RMI4_END_OF_PDT(pdt_entry.function_number))\r\nbreak;\r\nretval = callback(rmi_dev, ctx, &pdt_entry);\r\nif (retval != RMI_SCAN_CONTINUE)\r\nreturn retval;\r\n}\r\nreturn (data->f01_bootloader_mode || addr == pdt_start) ?\r\nRMI_SCAN_DONE : RMI_SCAN_CONTINUE;\r\n}\r\nstatic int rmi_scan_pdt(struct rmi_device *rmi_dev, void *ctx,\r\nint (*callback)(struct rmi_device *rmi_dev,\r\nvoid *ctx,\r\nconst struct pdt_entry *entry))\r\n{\r\nint page;\r\nint retval = RMI_SCAN_DONE;\r\nfor (page = 0; page <= RMI4_MAX_PAGE; page++) {\r\nretval = rmi_scan_pdt_page(rmi_dev, page, ctx, callback);\r\nif (retval != RMI_SCAN_CONTINUE)\r\nbreak;\r\n}\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nint rmi_read_register_desc(struct rmi_device *d, u16 addr,\r\nstruct rmi_register_descriptor *rdesc)\r\n{\r\nint ret;\r\nu8 size_presence_reg;\r\nu8 buf[35];\r\nint presense_offset = 1;\r\nu8 *struct_buf;\r\nint reg;\r\nint offset = 0;\r\nint map_offset = 0;\r\nint i;\r\nint b;\r\nret = rmi_read(d, addr, &size_presence_reg);\r\nif (ret)\r\nreturn ret;\r\n++addr;\r\nif (size_presence_reg < 0 || size_presence_reg > 35)\r\nreturn -EIO;\r\nmemset(buf, 0, sizeof(buf));\r\nret = rmi_read_block(d, addr, buf, size_presence_reg);\r\nif (ret)\r\nreturn ret;\r\n++addr;\r\nif (buf[0] == 0) {\r\npresense_offset = 3;\r\nrdesc->struct_size = buf[1] | (buf[2] << 8);\r\n} else {\r\nrdesc->struct_size = buf[0];\r\n}\r\nfor (i = presense_offset; i < size_presence_reg; i++) {\r\nfor (b = 0; b < 8; b++) {\r\nif (buf[i] & (0x1 << b))\r\nbitmap_set(rdesc->presense_map, map_offset, 1);\r\n++map_offset;\r\n}\r\n}\r\nrdesc->num_registers = bitmap_weight(rdesc->presense_map,\r\nRMI_REG_DESC_PRESENSE_BITS);\r\nrdesc->registers = devm_kzalloc(&d->dev, rdesc->num_registers *\r\nsizeof(struct rmi_register_desc_item),\r\nGFP_KERNEL);\r\nif (!rdesc->registers)\r\nreturn -ENOMEM;\r\nstruct_buf = kzalloc(rdesc->struct_size, GFP_KERNEL);\r\nif (!struct_buf)\r\nreturn -ENOMEM;\r\nret = rmi_read_block(d, addr, struct_buf, rdesc->struct_size);\r\nif (ret)\r\ngoto free_struct_buff;\r\nreg = find_first_bit(rdesc->presense_map, RMI_REG_DESC_PRESENSE_BITS);\r\nmap_offset = 0;\r\nfor (i = 0; i < rdesc->num_registers; i++) {\r\nstruct rmi_register_desc_item *item = &rdesc->registers[i];\r\nint reg_size = struct_buf[offset];\r\n++offset;\r\nif (reg_size == 0) {\r\nreg_size = struct_buf[offset] |\r\n(struct_buf[offset + 1] << 8);\r\noffset += 2;\r\n}\r\nif (reg_size == 0) {\r\nreg_size = struct_buf[offset] |\r\n(struct_buf[offset + 1] << 8) |\r\n(struct_buf[offset + 2] << 16) |\r\n(struct_buf[offset + 3] << 24);\r\noffset += 4;\r\n}\r\nitem->reg = reg;\r\nitem->reg_size = reg_size;\r\ndo {\r\nfor (b = 0; b < 7; b++) {\r\nif (struct_buf[offset] & (0x1 << b))\r\nbitmap_set(item->subpacket_map,\r\nmap_offset, 1);\r\n++map_offset;\r\n}\r\n} while (struct_buf[offset++] & 0x80);\r\nitem->num_subpackets = bitmap_weight(item->subpacket_map,\r\nRMI_REG_DESC_SUBPACKET_BITS);\r\nrmi_dbg(RMI_DEBUG_CORE, &d->dev,\r\n"%s: reg: %d reg size: %ld subpackets: %d\n", __func__,\r\nitem->reg, item->reg_size, item->num_subpackets);\r\nreg = find_next_bit(rdesc->presense_map,\r\nRMI_REG_DESC_PRESENSE_BITS, reg + 1);\r\n}\r\nfree_struct_buff:\r\nkfree(struct_buf);\r\nreturn ret;\r\n}\r\nconst struct rmi_register_desc_item *rmi_get_register_desc_item(\r\nstruct rmi_register_descriptor *rdesc, u16 reg)\r\n{\r\nconst struct rmi_register_desc_item *item;\r\nint i;\r\nfor (i = 0; i < rdesc->num_registers; i++) {\r\nitem = &rdesc->registers[i];\r\nif (item->reg == reg)\r\nreturn item;\r\n}\r\nreturn NULL;\r\n}\r\nsize_t rmi_register_desc_calc_size(struct rmi_register_descriptor *rdesc)\r\n{\r\nconst struct rmi_register_desc_item *item;\r\nint i;\r\nsize_t size = 0;\r\nfor (i = 0; i < rdesc->num_registers; i++) {\r\nitem = &rdesc->registers[i];\r\nsize += item->reg_size;\r\n}\r\nreturn size;\r\n}\r\nint rmi_register_desc_calc_reg_offset(\r\nstruct rmi_register_descriptor *rdesc, u16 reg)\r\n{\r\nconst struct rmi_register_desc_item *item;\r\nint offset = 0;\r\nint i;\r\nfor (i = 0; i < rdesc->num_registers; i++) {\r\nitem = &rdesc->registers[i];\r\nif (item->reg == reg)\r\nreturn offset;\r\n++offset;\r\n}\r\nreturn -1;\r\n}\r\nbool rmi_register_desc_has_subpacket(const struct rmi_register_desc_item *item,\r\nu8 subpacket)\r\n{\r\nreturn find_next_bit(item->subpacket_map, RMI_REG_DESC_PRESENSE_BITS,\r\nsubpacket) == subpacket;\r\n}\r\nstatic int rmi_check_bootloader_mode(struct rmi_device *rmi_dev,\r\nconst struct pdt_entry *pdt)\r\n{\r\nint error;\r\nu8 device_status;\r\nerror = rmi_read(rmi_dev, pdt->data_base_addr + pdt->page_start,\r\n&device_status);\r\nif (error) {\r\ndev_err(&rmi_dev->dev,\r\n"Failed to read device status: %d.\n", error);\r\nreturn error;\r\n}\r\nreturn RMI_F01_STATUS_BOOTLOADER(device_status);\r\n}\r\nstatic int rmi_count_irqs(struct rmi_device *rmi_dev,\r\nvoid *ctx, const struct pdt_entry *pdt)\r\n{\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nint *irq_count = ctx;\r\n*irq_count += pdt->interrupt_source_count;\r\nif (pdt->function_number == 0x01) {\r\ndata->f01_bootloader_mode =\r\nrmi_check_bootloader_mode(rmi_dev, pdt);\r\nif (data->f01_bootloader_mode)\r\ndev_warn(&rmi_dev->dev,\r\n"WARNING: RMI4 device is in bootloader mode!\n");\r\n}\r\nreturn RMI_SCAN_CONTINUE;\r\n}\r\nstatic int rmi_initial_reset(struct rmi_device *rmi_dev,\r\nvoid *ctx, const struct pdt_entry *pdt)\r\n{\r\nint error;\r\nif (pdt->function_number == 0x01) {\r\nu16 cmd_addr = pdt->page_start + pdt->command_base_addr;\r\nu8 cmd_buf = RMI_DEVICE_RESET_CMD;\r\nconst struct rmi_device_platform_data *pdata =\r\nrmi_get_platform_data(rmi_dev);\r\nif (rmi_dev->xport->ops->reset) {\r\nerror = rmi_dev->xport->ops->reset(rmi_dev->xport,\r\ncmd_addr);\r\nif (error)\r\nreturn error;\r\nreturn RMI_SCAN_DONE;\r\n}\r\nerror = rmi_write_block(rmi_dev, cmd_addr, &cmd_buf, 1);\r\nif (error) {\r\ndev_err(&rmi_dev->dev,\r\n"Initial reset failed. Code = %d.\n", error);\r\nreturn error;\r\n}\r\nmdelay(pdata->reset_delay_ms ?: DEFAULT_RESET_DELAY_MS);\r\nreturn RMI_SCAN_DONE;\r\n}\r\nreturn pdt->page_start == 0 ? RMI_SCAN_CONTINUE : -ENODEV;\r\n}\r\nstatic int rmi_create_function(struct rmi_device *rmi_dev,\r\nvoid *ctx, const struct pdt_entry *pdt)\r\n{\r\nstruct device *dev = &rmi_dev->dev;\r\nstruct rmi_driver_data *data = dev_get_drvdata(&rmi_dev->dev);\r\nint *current_irq_count = ctx;\r\nstruct rmi_function *fn;\r\nint i;\r\nint error;\r\nrmi_dbg(RMI_DEBUG_CORE, dev, "Initializing F%02X.\n",\r\npdt->function_number);\r\nfn = kzalloc(sizeof(struct rmi_function) +\r\nBITS_TO_LONGS(data->irq_count) * sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!fn) {\r\ndev_err(dev, "Failed to allocate memory for F%02X\n",\r\npdt->function_number);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&fn->node);\r\nrmi_driver_copy_pdt_to_fd(pdt, &fn->fd);\r\nfn->rmi_dev = rmi_dev;\r\nfn->num_of_irqs = pdt->interrupt_source_count;\r\nfn->irq_pos = *current_irq_count;\r\n*current_irq_count += fn->num_of_irqs;\r\nfor (i = 0; i < fn->num_of_irqs; i++)\r\nset_bit(fn->irq_pos + i, fn->irq_mask);\r\nerror = rmi_register_function(fn);\r\nif (error)\r\ngoto err_put_fn;\r\nif (pdt->function_number == 0x01)\r\ndata->f01_container = fn;\r\nlist_add_tail(&fn->node, &data->function_list);\r\nreturn RMI_SCAN_CONTINUE;\r\nerr_put_fn:\r\nput_device(&fn->dev);\r\nreturn error;\r\n}\r\nint rmi_driver_suspend(struct rmi_device *rmi_dev)\r\n{\r\nint retval = 0;\r\nretval = rmi_suspend_functions(rmi_dev);\r\nif (retval)\r\ndev_warn(&rmi_dev->dev, "Failed to suspend functions: %d\n",\r\nretval);\r\nreturn retval;\r\n}\r\nint rmi_driver_resume(struct rmi_device *rmi_dev)\r\n{\r\nint retval;\r\nretval = rmi_resume_functions(rmi_dev);\r\nif (retval)\r\ndev_warn(&rmi_dev->dev, "Failed to suspend functions: %d\n",\r\nretval);\r\nreturn retval;\r\n}\r\nstatic int rmi_driver_remove(struct device *dev)\r\n{\r\nstruct rmi_device *rmi_dev = to_rmi_device(dev);\r\nrmi_free_function_list(rmi_dev);\r\nreturn 0;\r\n}\r\nstatic int rmi_driver_of_probe(struct device *dev,\r\nstruct rmi_device_platform_data *pdata)\r\n{\r\nint retval;\r\nretval = rmi_of_property_read_u32(dev, &pdata->reset_delay_ms,\r\n"syna,reset-delay-ms", 1);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic inline int rmi_driver_of_probe(struct device *dev,\r\nstruct rmi_device_platform_data *pdata)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int rmi_driver_probe(struct device *dev)\r\n{\r\nstruct rmi_driver *rmi_driver;\r\nstruct rmi_driver_data *data;\r\nstruct rmi_device_platform_data *pdata;\r\nstruct rmi_device *rmi_dev;\r\nsize_t size;\r\nvoid *irq_memory;\r\nint irq_count;\r\nint retval;\r\nrmi_dbg(RMI_DEBUG_CORE, dev, "%s: Starting probe.\n",\r\n__func__);\r\nif (!rmi_is_physical_device(dev)) {\r\nrmi_dbg(RMI_DEBUG_CORE, dev, "Not a physical device.\n");\r\nreturn -ENODEV;\r\n}\r\nrmi_dev = to_rmi_device(dev);\r\nrmi_driver = to_rmi_driver(dev->driver);\r\nrmi_dev->driver = rmi_driver;\r\npdata = rmi_get_platform_data(rmi_dev);\r\nif (rmi_dev->xport->dev->of_node) {\r\nretval = rmi_driver_of_probe(rmi_dev->xport->dev, pdata);\r\nif (retval)\r\nreturn retval;\r\n}\r\ndata = devm_kzalloc(dev, sizeof(struct rmi_driver_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&data->function_list);\r\ndata->rmi_dev = rmi_dev;\r\ndev_set_drvdata(&rmi_dev->dev, data);\r\nretval = rmi_scan_pdt(rmi_dev, NULL, rmi_initial_reset);\r\nif (retval < 0)\r\ndev_warn(dev, "RMI initial reset failed! Continuing in spite of this.\n");\r\nretval = rmi_read(rmi_dev, PDT_PROPERTIES_LOCATION, &data->pdt_props);\r\nif (retval < 0) {\r\ndev_warn(dev, "Could not read PDT properties from %#06x (code %d). Assuming 0x00.\n",\r\nPDT_PROPERTIES_LOCATION, retval);\r\n}\r\nrmi_dbg(RMI_DEBUG_CORE, dev, "Counting IRQs.\n");\r\nirq_count = 0;\r\nretval = rmi_scan_pdt(rmi_dev, &irq_count, rmi_count_irqs);\r\nif (retval < 0) {\r\ndev_err(dev, "IRQ counting failed with code %d.\n", retval);\r\ngoto err;\r\n}\r\ndata->irq_count = irq_count;\r\ndata->num_of_irq_regs = (data->irq_count + 7) / 8;\r\nmutex_init(&data->irq_mutex);\r\nsize = BITS_TO_LONGS(data->irq_count) * sizeof(unsigned long);\r\nirq_memory = devm_kzalloc(dev, size * 4, GFP_KERNEL);\r\nif (!irq_memory) {\r\ndev_err(dev, "Failed to allocate memory for irq masks.\n");\r\ngoto err;\r\n}\r\ndata->irq_status = irq_memory + size * 0;\r\ndata->fn_irq_bits = irq_memory + size * 1;\r\ndata->current_irq_mask = irq_memory + size * 2;\r\ndata->new_irq_mask = irq_memory + size * 3;\r\nif (rmi_dev->xport->input) {\r\ndata->input = rmi_dev->xport->input;\r\n} else {\r\ndata->input = devm_input_allocate_device(dev);\r\nif (!data->input) {\r\ndev_err(dev, "%s: Failed to allocate input device.\n",\r\n__func__);\r\nretval = -ENOMEM;\r\ngoto err_destroy_functions;\r\n}\r\nrmi_driver_set_input_params(rmi_dev, data->input);\r\ndata->input->phys = devm_kasprintf(dev, GFP_KERNEL,\r\n"%s/input0", dev_name(dev));\r\n}\r\nirq_count = 0;\r\nrmi_dbg(RMI_DEBUG_CORE, dev, "Creating functions.");\r\nretval = rmi_scan_pdt(rmi_dev, &irq_count, rmi_create_function);\r\nif (retval < 0) {\r\ndev_err(dev, "Function creation failed with code %d.\n",\r\nretval);\r\ngoto err_destroy_functions;\r\n}\r\nif (!data->f01_container) {\r\ndev_err(dev, "Missing F01 container!\n");\r\nretval = -EINVAL;\r\ngoto err_destroy_functions;\r\n}\r\nretval = rmi_read_block(rmi_dev,\r\ndata->f01_container->fd.control_base_addr + 1,\r\ndata->current_irq_mask, data->num_of_irq_regs);\r\nif (retval < 0) {\r\ndev_err(dev, "%s: Failed to read current IRQ mask.\n",\r\n__func__);\r\ngoto err_destroy_functions;\r\n}\r\nif (data->input) {\r\nrmi_driver_set_input_name(rmi_dev, data->input);\r\nif (!rmi_dev->xport->input) {\r\nif (input_register_device(data->input)) {\r\ndev_err(dev, "%s: Failed to register input device.\n",\r\n__func__);\r\ngoto err_destroy_functions;\r\n}\r\n}\r\n}\r\nif (data->f01_container->dev.driver)\r\nreturn enable_sensor(rmi_dev);\r\nreturn 0;\r\nerr_destroy_functions:\r\nrmi_free_function_list(rmi_dev);\r\nerr:\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nbool rmi_is_physical_driver(struct device_driver *drv)\r\n{\r\nreturn drv == &rmi_physical_driver.driver;\r\n}\r\nint __init rmi_register_physical_driver(void)\r\n{\r\nint error;\r\nerror = driver_register(&rmi_physical_driver.driver);\r\nif (error) {\r\npr_err("%s: driver register failed, code=%d.\n", __func__,\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nvoid __exit rmi_unregister_physical_driver(void)\r\n{\r\ndriver_unregister(&rmi_physical_driver.driver);\r\n}
