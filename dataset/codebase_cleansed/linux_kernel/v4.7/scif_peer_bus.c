static inline struct scif_peer_dev *\r\ndev_to_scif_peer(struct device *dev)\r\n{\r\nreturn container_of(dev, struct scif_peer_dev, dev);\r\n}\r\nstatic void scif_peer_release_dev(struct device *d)\r\n{\r\nstruct scif_peer_dev *sdev = dev_to_scif_peer(d);\r\nstruct scif_dev *scifdev = &scif_dev[sdev->dnode];\r\nscif_cleanup_scifdev(scifdev);\r\nkfree(sdev);\r\n}\r\nstatic int scif_peer_initialize_device(struct scif_dev *scifdev)\r\n{\r\nstruct scif_peer_dev *spdev;\r\nint ret;\r\nspdev = kzalloc(sizeof(*spdev), GFP_KERNEL);\r\nif (!spdev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nspdev->dev.parent = scifdev->sdev->dev.parent;\r\nspdev->dev.release = scif_peer_release_dev;\r\nspdev->dnode = scifdev->node;\r\nspdev->dev.bus = &scif_peer_bus;\r\ndev_set_name(&spdev->dev, "scif_peer-dev%u", spdev->dnode);\r\ndevice_initialize(&spdev->dev);\r\nget_device(&spdev->dev);\r\nrcu_assign_pointer(scifdev->spdev, spdev);\r\nmutex_lock(&scif_info.conflock);\r\nscif_info.total++;\r\nscif_info.maxid = max_t(u32, spdev->dnode, scif_info.maxid);\r\nmutex_unlock(&scif_info.conflock);\r\nreturn 0;\r\nerr:\r\ndev_err(&scifdev->sdev->dev,\r\n"dnode %d: initialize_device rc %d\n", scifdev->node, ret);\r\nreturn ret;\r\n}\r\nstatic int scif_peer_add_device(struct scif_dev *scifdev)\r\n{\r\nstruct scif_peer_dev *spdev = rcu_dereference(scifdev->spdev);\r\nchar pool_name[16];\r\nint ret;\r\nret = device_add(&spdev->dev);\r\nput_device(&spdev->dev);\r\nif (ret) {\r\ndev_err(&scifdev->sdev->dev,\r\n"dnode %d: peer device_add failed\n", scifdev->node);\r\ngoto put_spdev;\r\n}\r\nscnprintf(pool_name, sizeof(pool_name), "scif-%d", spdev->dnode);\r\nscifdev->signal_pool = dmam_pool_create(pool_name, &scifdev->sdev->dev,\r\nsizeof(struct scif_status), 1,\r\n0);\r\nif (!scifdev->signal_pool) {\r\ndev_err(&scifdev->sdev->dev,\r\n"dnode %d: dmam_pool_create failed\n", scifdev->node);\r\nret = -ENOMEM;\r\ngoto del_spdev;\r\n}\r\ndev_dbg(&spdev->dev, "Added peer dnode %d\n", spdev->dnode);\r\nreturn 0;\r\ndel_spdev:\r\ndevice_del(&spdev->dev);\r\nput_spdev:\r\nRCU_INIT_POINTER(scifdev->spdev, NULL);\r\nsynchronize_rcu();\r\nput_device(&spdev->dev);\r\nmutex_lock(&scif_info.conflock);\r\nscif_info.total--;\r\nmutex_unlock(&scif_info.conflock);\r\nreturn ret;\r\n}\r\nvoid scif_add_peer_device(struct work_struct *work)\r\n{\r\nstruct scif_dev *scifdev = container_of(work, struct scif_dev,\r\npeer_add_work);\r\nscif_peer_add_device(scifdev);\r\n}\r\nvoid scif_peer_register_device(struct scif_dev *scifdev)\r\n{\r\nint ret;\r\nmutex_lock(&scifdev->lock);\r\nret = scif_peer_initialize_device(scifdev);\r\nif (ret)\r\ngoto exit;\r\nschedule_work(&scifdev->peer_add_work);\r\nexit:\r\nmutex_unlock(&scifdev->lock);\r\n}\r\nint scif_peer_unregister_device(struct scif_dev *scifdev)\r\n{\r\nstruct scif_peer_dev *spdev;\r\nmutex_lock(&scifdev->lock);\r\nflush_work(&scifdev->peer_add_work);\r\nspdev = rcu_dereference(scifdev->spdev);\r\nif (!spdev) {\r\nmutex_unlock(&scifdev->lock);\r\nreturn -ENODEV;\r\n}\r\nRCU_INIT_POINTER(scifdev->spdev, NULL);\r\nsynchronize_rcu();\r\nmutex_unlock(&scifdev->lock);\r\ndev_dbg(&spdev->dev, "Removing peer dnode %d\n", spdev->dnode);\r\ndevice_unregister(&spdev->dev);\r\nmutex_lock(&scif_info.conflock);\r\nscif_info.total--;\r\nmutex_unlock(&scif_info.conflock);\r\nreturn 0;\r\n}\r\nint scif_peer_bus_init(void)\r\n{\r\nreturn bus_register(&scif_peer_bus);\r\n}\r\nvoid scif_peer_bus_exit(void)\r\n{\r\nbus_unregister(&scif_peer_bus);\r\n}
