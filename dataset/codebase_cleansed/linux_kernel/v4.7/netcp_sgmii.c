static void sgmii_write_reg(void __iomem *base, int reg, u32 val)\r\n{\r\nwritel(val, base + reg);\r\n}\r\nstatic u32 sgmii_read_reg(void __iomem *base, int reg)\r\n{\r\nreturn readl(base + reg);\r\n}\r\nstatic void sgmii_write_reg_bit(void __iomem *base, int reg, u32 val)\r\n{\r\nwritel((readl(base + reg) | val), base + reg);\r\n}\r\nint netcp_sgmii_reset(void __iomem *sgmii_ofs, int port)\r\n{\r\nsgmii_write_reg_bit(sgmii_ofs, SGMII_SRESET_REG(port),\r\nSGMII_SRESET_RESET);\r\nwhile ((sgmii_read_reg(sgmii_ofs, SGMII_SRESET_REG(port)) &\r\nSGMII_SRESET_RESET) != 0x0)\r\n;\r\nreturn 0;\r\n}\r\nbool netcp_sgmii_rtreset(void __iomem *sgmii_ofs, int port, bool set)\r\n{\r\nu32 reg;\r\nbool oldval;\r\nreg = sgmii_read_reg(sgmii_ofs, SGMII_SRESET_REG(port));\r\noldval = (reg & SGMII_SRESET_RTRESET) != 0x0;\r\nif (set)\r\nreg |= SGMII_SRESET_RTRESET;\r\nelse\r\nreg &= ~SGMII_SRESET_RTRESET;\r\nsgmii_write_reg(sgmii_ofs, SGMII_SRESET_REG(port), reg);\r\nwmb();\r\nreturn oldval;\r\n}\r\nint netcp_sgmii_get_port_link(void __iomem *sgmii_ofs, int port)\r\n{\r\nu32 status = 0, link = 0;\r\nstatus = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));\r\nif ((status & SGMII_REG_STATUS_LINK) != 0)\r\nlink = 1;\r\nreturn link;\r\n}\r\nint netcp_sgmii_config(void __iomem *sgmii_ofs, int port, u32 interface)\r\n{\r\nunsigned int i, status, mask;\r\nu32 mr_adv_ability;\r\nu32 control;\r\nswitch (interface) {\r\ncase SGMII_LINK_MAC_MAC_AUTONEG:\r\nmr_adv_ability = 0x9801;\r\ncontrol = 0x21;\r\nbreak;\r\ncase SGMII_LINK_MAC_PHY:\r\ncase SGMII_LINK_MAC_PHY_NO_MDIO:\r\nmr_adv_ability = 1;\r\ncontrol = 1;\r\nbreak;\r\ncase SGMII_LINK_MAC_MAC_FORCED:\r\nmr_adv_ability = 0x9801;\r\ncontrol = 0x20;\r\nbreak;\r\ncase SGMII_LINK_MAC_FIBER:\r\nmr_adv_ability = 0x20;\r\ncontrol = 0x1;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "Invalid sgmii interface: %d\n", interface);\r\nreturn -EINVAL;\r\n}\r\nsgmii_write_reg(sgmii_ofs, SGMII_CTL_REG(port), 0);\r\nfor (i = 0; i < 1000; i++) {\r\nusleep_range(1000, 2000);\r\nstatus = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));\r\nif ((status & SGMII_REG_STATUS_LOCK) != 0)\r\nbreak;\r\n}\r\nif ((status & SGMII_REG_STATUS_LOCK) == 0)\r\npr_err("serdes PLL not locked\n");\r\nsgmii_write_reg(sgmii_ofs, SGMII_MRADV_REG(port), mr_adv_ability);\r\nsgmii_write_reg(sgmii_ofs, SGMII_CTL_REG(port), control);\r\nmask = SGMII_REG_STATUS_LINK;\r\nif (control & SGMII_REG_CONTROL_AUTONEG)\r\nmask |= SGMII_REG_STATUS_AUTONEG;\r\nfor (i = 0; i < 1000; i++) {\r\nusleep_range(200, 500);\r\nstatus = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));\r\nif ((status & mask) == mask)\r\nbreak;\r\n}\r\nreturn 0;\r\n}
