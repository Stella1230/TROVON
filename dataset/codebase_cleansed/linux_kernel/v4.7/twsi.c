static void i2c_wait_for_writes(struct hfi1_devdata *dd, u32 target)\r\n{\r\nhfi1_gpio_mod(dd, target, 0, 0, 0);\r\nrmb();\r\n}\r\nstatic void scl_out(struct hfi1_devdata *dd, u32 target, u8 bit)\r\n{\r\nu32 mask;\r\nudelay(1);\r\nmask = QSFP_HFI0_I2CCLK;\r\nhfi1_gpio_mod(dd, target, 0, bit ? 0 : mask, mask);\r\nif (!bit) {\r\nudelay(2);\r\n} else {\r\nint rise_usec;\r\nfor (rise_usec = SCL_WAIT_USEC; rise_usec > 0; rise_usec -= 2) {\r\nif (mask & hfi1_gpio_mod(dd, target, 0, 0, 0))\r\nbreak;\r\nudelay(2);\r\n}\r\nif (rise_usec <= 0)\r\ndd_dev_err(dd, "SCL interface stuck low > %d uSec\n",\r\nSCL_WAIT_USEC);\r\n}\r\ni2c_wait_for_writes(dd, target);\r\n}\r\nstatic u8 scl_in(struct hfi1_devdata *dd, u32 target, int wait)\r\n{\r\nu32 read_val, mask;\r\nmask = QSFP_HFI0_I2CCLK;\r\nhfi1_gpio_mod(dd, target, 0, 0, mask);\r\nread_val = hfi1_gpio_mod(dd, target, 0, 0, 0);\r\nif (wait)\r\ni2c_wait_for_writes(dd, target);\r\nreturn (read_val & mask) >> GPIO_SCL_NUM;\r\n}\r\nstatic void sda_out(struct hfi1_devdata *dd, u32 target, u8 bit)\r\n{\r\nu32 mask;\r\nmask = QSFP_HFI0_I2CDAT;\r\nhfi1_gpio_mod(dd, target, 0, bit ? 0 : mask, mask);\r\ni2c_wait_for_writes(dd, target);\r\nudelay(2);\r\n}\r\nstatic u8 sda_in(struct hfi1_devdata *dd, u32 target, int wait)\r\n{\r\nu32 read_val, mask;\r\nmask = QSFP_HFI0_I2CDAT;\r\nhfi1_gpio_mod(dd, target, 0, 0, mask);\r\nread_val = hfi1_gpio_mod(dd, target, 0, 0, 0);\r\nif (wait)\r\ni2c_wait_for_writes(dd, target);\r\nreturn (read_val & mask) >> GPIO_SDA_NUM;\r\n}\r\nstatic int i2c_ackrcv(struct hfi1_devdata *dd, u32 target)\r\n{\r\nu8 ack_received;\r\nack_received = sda_in(dd, target, 1);\r\nscl_out(dd, target, 1);\r\nack_received = sda_in(dd, target, 1) == 0;\r\nscl_out(dd, target, 0);\r\nreturn ack_received;\r\n}\r\nstatic int rd_byte(struct hfi1_devdata *dd, u32 target, int last)\r\n{\r\nint bit_cntr, data;\r\ndata = 0;\r\nfor (bit_cntr = 7; bit_cntr >= 0; --bit_cntr) {\r\ndata <<= 1;\r\nscl_out(dd, target, 1);\r\ndata |= sda_in(dd, target, 0);\r\nscl_out(dd, target, 0);\r\n}\r\nif (last) {\r\nscl_out(dd, target, 1);\r\nstop_cmd(dd, target);\r\n} else {\r\nsda_out(dd, target, 0);\r\nscl_out(dd, target, 1);\r\nscl_out(dd, target, 0);\r\nsda_out(dd, target, 1);\r\n}\r\nreturn data;\r\n}\r\nstatic int wr_byte(struct hfi1_devdata *dd, u32 target, u8 data)\r\n{\r\nint bit_cntr;\r\nu8 bit;\r\nfor (bit_cntr = 7; bit_cntr >= 0; bit_cntr--) {\r\nbit = (data >> bit_cntr) & 1;\r\nsda_out(dd, target, bit);\r\nscl_out(dd, target, 1);\r\nscl_out(dd, target, 0);\r\n}\r\nreturn (!i2c_ackrcv(dd, target)) ? 1 : 0;\r\n}\r\nstatic void start_seq(struct hfi1_devdata *dd, u32 target)\r\n{\r\nsda_out(dd, target, 1);\r\nscl_out(dd, target, 1);\r\nsda_out(dd, target, 0);\r\nudelay(1);\r\nscl_out(dd, target, 0);\r\n}\r\nstatic void stop_seq(struct hfi1_devdata *dd, u32 target)\r\n{\r\nscl_out(dd, target, 0);\r\nsda_out(dd, target, 0);\r\nscl_out(dd, target, 1);\r\nsda_out(dd, target, 1);\r\n}\r\nstatic void stop_cmd(struct hfi1_devdata *dd, u32 target)\r\n{\r\nstop_seq(dd, target);\r\nudelay(TWSI_BUF_WAIT_USEC);\r\n}\r\nint hfi1_twsi_reset(struct hfi1_devdata *dd, u32 target)\r\n{\r\nint clock_cycles_left = 9;\r\nu32 mask;\r\nmask = QSFP_HFI0_I2CCLK | QSFP_HFI0_I2CDAT;\r\nhfi1_gpio_mod(dd, target, 0, 0, mask);\r\nif (!scl_in(dd, target, 0))\r\nreturn -EIO;\r\nwhile (clock_cycles_left--) {\r\nif (sda_in(dd, target, 0))\r\nreturn 0;\r\nscl_out(dd, target, 0);\r\nscl_out(dd, target, 1);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int twsi_wr(struct hfi1_devdata *dd, u32 target, int data, int flags)\r\n{\r\nint ret = 1;\r\nif (flags & HFI1_TWSI_START)\r\nstart_seq(dd, target);\r\nret = wr_byte(dd, target, data);\r\nif (flags & HFI1_TWSI_STOP)\r\nstop_cmd(dd, target);\r\nreturn ret;\r\n}\r\nint hfi1_twsi_blk_rd(struct hfi1_devdata *dd, u32 target, int dev, int addr,\r\nvoid *buffer, int len)\r\n{\r\nu8 *bp = buffer;\r\nint ret = 1;\r\nint i;\r\nint offset_size;\r\noffset_size = (dev >> 8) & 0xff;\r\ndev &= 0xff;\r\nif (offset_size > 2)\r\ngoto bail;\r\nif (dev == HFI1_TWSI_NO_DEV) {\r\naddr = (addr << 1) | READ_CMD;\r\nret = twsi_wr(dd, target, addr, HFI1_TWSI_START);\r\n} else {\r\nif (offset_size) {\r\nret = twsi_wr(dd, target,\r\ndev | WRITE_CMD, HFI1_TWSI_START);\r\nif (ret) {\r\nstop_cmd(dd, target);\r\ngoto bail;\r\n}\r\nfor (i = 0; i < offset_size; i++) {\r\nret = twsi_wr(dd, target,\r\n(addr >> (i * 8)) & 0xff, 0);\r\nudelay(TWSI_BUF_WAIT_USEC);\r\nif (ret) {\r\ndd_dev_err(dd, "Failed to write byte %d of offset 0x%04X\n",\r\ni, addr);\r\ngoto bail;\r\n}\r\n}\r\n}\r\nret = twsi_wr(dd, target, dev | READ_CMD, HFI1_TWSI_START);\r\n}\r\nif (ret) {\r\nstop_cmd(dd, target);\r\ngoto bail;\r\n}\r\nwhile (len-- > 0) {\r\n*bp++ = rd_byte(dd, target, !len);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nint hfi1_twsi_blk_wr(struct hfi1_devdata *dd, u32 target, int dev, int addr,\r\nconst void *buffer, int len)\r\n{\r\nconst u8 *bp = buffer;\r\nint ret = 1;\r\nint i;\r\nint offset_size;\r\noffset_size = (dev >> 8) & 0xff;\r\ndev &= 0xff;\r\nif (offset_size > 2)\r\ngoto bail;\r\nif (dev == HFI1_TWSI_NO_DEV) {\r\nif (twsi_wr(dd, target, (addr << 1) | WRITE_CMD,\r\nHFI1_TWSI_START)) {\r\ngoto failed_write;\r\n}\r\n} else {\r\nif (twsi_wr(dd, target, dev | WRITE_CMD, HFI1_TWSI_START))\r\ngoto failed_write;\r\n}\r\nfor (i = 0; i < offset_size; i++) {\r\nret = twsi_wr(dd, target, (addr >> (i * 8)) & 0xff, 0);\r\nudelay(TWSI_BUF_WAIT_USEC);\r\nif (ret) {\r\ndd_dev_err(dd, "Failed to write byte %d of offset 0x%04X\n",\r\ni, addr);\r\ngoto bail;\r\n}\r\n}\r\nfor (i = 0; i < len; i++)\r\nif (twsi_wr(dd, target, *bp++, 0))\r\ngoto failed_write;\r\nret = 0;\r\nfailed_write:\r\nstop_cmd(dd, target);\r\nbail:\r\nreturn ret;\r\n}
