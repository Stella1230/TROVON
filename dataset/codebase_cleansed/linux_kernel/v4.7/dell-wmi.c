static int __init dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nwmi_requires_smbios_request = 1;\r\nreturn 1;\r\n}\r\nstatic void dell_wmi_process_key(int reported_key)\r\n{\r\nconst struct key_entry *key;\r\nkey = sparse_keymap_entry_from_scancode(dell_wmi_input_dev,\r\nreported_key);\r\nif (!key) {\r\npr_info("Unknown key with scancode 0x%x pressed\n",\r\nreported_key);\r\nreturn;\r\n}\r\npr_debug("Key %x pressed\n", reported_key);\r\nif ((key->keycode == KEY_BRIGHTNESSUP ||\r\nkey->keycode == KEY_BRIGHTNESSDOWN) &&\r\nacpi_video_handles_brightness_key_presses())\r\nreturn;\r\nif (reported_key == 0xe025 && !wmi_requires_smbios_request)\r\nreturn;\r\nsparse_keymap_report_entry(dell_wmi_input_dev, key, 1, true);\r\n}\r\nstatic void dell_wmi_notify(u32 value, void *context)\r\n{\r\nstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nacpi_size buffer_size;\r\nu16 *buffer_entry, *buffer_end;\r\nint len, i;\r\nstatus = wmi_get_event_data(value, &response);\r\nif (status != AE_OK) {\r\npr_warn("bad event status 0x%x\n", status);\r\nreturn;\r\n}\r\nobj = (union acpi_object *)response.pointer;\r\nif (!obj) {\r\npr_warn("no response\n");\r\nreturn;\r\n}\r\nif (obj->type != ACPI_TYPE_BUFFER) {\r\npr_warn("bad response type %x\n", obj->type);\r\nkfree(obj);\r\nreturn;\r\n}\r\npr_debug("Received WMI event (%*ph)\n",\r\nobj->buffer.length, obj->buffer.pointer);\r\nbuffer_entry = (u16 *)obj->buffer.pointer;\r\nbuffer_size = obj->buffer.length/2;\r\nif (!dell_new_hk_type) {\r\nif (buffer_size >= 3 && buffer_entry[1] == 0x0)\r\ndell_wmi_process_key(buffer_entry[2]);\r\nelse if (buffer_size >= 2)\r\ndell_wmi_process_key(buffer_entry[1]);\r\nelse\r\npr_info("Received unknown WMI event\n");\r\nkfree(obj);\r\nreturn;\r\n}\r\nbuffer_end = buffer_entry + buffer_size;\r\nif (dell_wmi_interface_version == 0 && buffer_entry < buffer_end)\r\nif (buffer_end > buffer_entry + buffer_entry[0] + 1)\r\nbuffer_end = buffer_entry + buffer_entry[0] + 1;\r\nwhile (buffer_entry < buffer_end) {\r\nlen = buffer_entry[0];\r\nif (len == 0)\r\nbreak;\r\nlen++;\r\nif (buffer_entry + len > buffer_end) {\r\npr_warn("Invalid length of WMI event\n");\r\nbreak;\r\n}\r\npr_debug("Process buffer (%*ph)\n", len*2, buffer_entry);\r\nswitch (buffer_entry[1]) {\r\ncase 0x00:\r\nfor (i = 2; i < len; ++i) {\r\nswitch (buffer_entry[i]) {\r\ncase 0xe043:\r\npr_debug("NIC Link is Up\n");\r\nbreak;\r\ncase 0xe044:\r\npr_debug("NIC Link is Down\n");\r\nbreak;\r\ncase 0xe045:\r\ndefault:\r\npr_info("Unknown WMI event type 0x00: "\r\n"0x%x\n", (int)buffer_entry[i]);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase 0x10:\r\nfor (i = 2; i < len; ++i)\r\ndell_wmi_process_key(buffer_entry[i]);\r\nbreak;\r\ncase 0x11:\r\nfor (i = 2; i < len; ++i) {\r\nswitch (buffer_entry[i]) {\r\ncase 0xfff0:\r\npr_debug("Battery unplugged\n");\r\nbreak;\r\ncase 0xfff1:\r\npr_debug("Battery inserted\n");\r\nbreak;\r\ncase 0x01e1:\r\ncase 0x02ea:\r\ncase 0x02eb:\r\ncase 0x02ec:\r\ncase 0x02f6:\r\npr_debug("Keyboard backlight level "\r\n"changed\n");\r\nbreak;\r\ndefault:\r\npr_info("Unknown WMI event type 0x11: "\r\n"0x%x\n", (int)buffer_entry[i]);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\npr_info("Unknown WMI event type 0x%x\n",\r\n(int)buffer_entry[1]);\r\nbreak;\r\n}\r\nbuffer_entry += len;\r\n}\r\nkfree(obj);\r\n}\r\nstatic bool have_scancode(u32 scancode, const struct key_entry *keymap, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (keymap[i].code == scancode)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void __init handle_dmi_entry(const struct dmi_header *dm,\r\nvoid *opaque)\r\n{\r\nstruct dell_dmi_results *results = opaque;\r\nstruct dell_bios_hotkey_table *table;\r\nint hotkey_num, i, pos = 0;\r\nstruct key_entry *keymap;\r\nint num_bios_keys;\r\nif (results->err || results->keymap)\r\nreturn;\r\nif (dm->type != 0xb2)\r\nreturn;\r\ntable = container_of(dm, struct dell_bios_hotkey_table, header);\r\nhotkey_num = (table->header.length -\r\nsizeof(struct dell_bios_hotkey_table)) /\r\nsizeof(struct dell_bios_keymap_entry);\r\nif (hotkey_num < 1) {\r\nreturn;\r\n}\r\nkeymap = kcalloc(hotkey_num + ARRAY_SIZE(dell_wmi_extra_keymap) + 1,\r\nsizeof(struct key_entry), GFP_KERNEL);\r\nif (!keymap) {\r\nresults->err = -ENOMEM;\r\nreturn;\r\n}\r\nfor (i = 0; i < hotkey_num; i++) {\r\nconst struct dell_bios_keymap_entry *bios_entry =\r\n&table->keymap[i];\r\nu16 keycode = (bios_entry->keycode <\r\nARRAY_SIZE(bios_to_linux_keycode)) ?\r\nbios_to_linux_keycode[bios_entry->keycode] :\r\nKEY_RESERVED;\r\nif (keycode == KEY_RESERVED) {\r\npr_info("firmware scancode 0x%x maps to unrecognized keycode 0x%x\n",\r\nbios_entry->scancode, bios_entry->keycode);\r\ncontinue;\r\n}\r\nif (keycode == KEY_KBDILLUMTOGGLE)\r\nkeymap[pos].type = KE_IGNORE;\r\nelse\r\nkeymap[pos].type = KE_KEY;\r\nkeymap[pos].code = bios_entry->scancode;\r\nkeymap[pos].keycode = keycode;\r\npos++;\r\n}\r\nnum_bios_keys = pos;\r\nfor (i = 0; i < ARRAY_SIZE(dell_wmi_extra_keymap); i++) {\r\nconst struct key_entry *entry = &dell_wmi_extra_keymap[i];\r\nif (!have_scancode(entry->code, keymap, num_bios_keys)) {\r\nkeymap[pos] = *entry;\r\npos++;\r\n}\r\n}\r\nkeymap[pos].type = KE_END;\r\nresults->keymap = keymap;\r\n}\r\nstatic int __init dell_wmi_input_setup(void)\r\n{\r\nstruct dell_dmi_results dmi_results = {};\r\nint err;\r\ndell_wmi_input_dev = input_allocate_device();\r\nif (!dell_wmi_input_dev)\r\nreturn -ENOMEM;\r\ndell_wmi_input_dev->name = "Dell WMI hotkeys";\r\ndell_wmi_input_dev->phys = "wmi/input0";\r\ndell_wmi_input_dev->id.bustype = BUS_HOST;\r\nif (dmi_walk(handle_dmi_entry, &dmi_results)) {\r\npr_warn("no DMI; using the old-style hotkey interface\n");\r\n}\r\nif (dmi_results.err) {\r\nerr = dmi_results.err;\r\ngoto err_free_dev;\r\n}\r\nif (dmi_results.keymap) {\r\ndell_new_hk_type = true;\r\nerr = sparse_keymap_setup(dell_wmi_input_dev,\r\ndmi_results.keymap, NULL);\r\nkfree(dmi_results.keymap);\r\n} else {\r\nerr = sparse_keymap_setup(dell_wmi_input_dev,\r\ndell_wmi_legacy_keymap, NULL);\r\n}\r\nif (err)\r\ngoto err_free_dev;\r\nerr = input_register_device(dell_wmi_input_dev);\r\nif (err)\r\ngoto err_free_keymap;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(dell_wmi_input_dev);\r\nerr_free_dev:\r\ninput_free_device(dell_wmi_input_dev);\r\nreturn err;\r\n}\r\nstatic void dell_wmi_input_destroy(void)\r\n{\r\nsparse_keymap_free(dell_wmi_input_dev);\r\ninput_unregister_device(dell_wmi_input_dev);\r\n}\r\nstatic int __init dell_wmi_check_descriptor_buffer(void)\r\n{\r\nstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nu32 *buffer;\r\nstatus = wmi_query_block(DELL_DESCRIPTOR_GUID, 0, &out);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Cannot read Dell descriptor buffer - %d\n", status);\r\nreturn status;\r\n}\r\nobj = (union acpi_object *)out.pointer;\r\nif (!obj) {\r\npr_err("Dell descriptor buffer is empty\n");\r\nreturn -EINVAL;\r\n}\r\nif (obj->type != ACPI_TYPE_BUFFER) {\r\npr_err("Cannot read Dell descriptor buffer\n");\r\nkfree(obj);\r\nreturn -EINVAL;\r\n}\r\nif (obj->buffer.length != 128) {\r\npr_err("Dell descriptor buffer has invalid length (%d)\n",\r\nobj->buffer.length);\r\nif (obj->buffer.length < 16) {\r\nkfree(obj);\r\nreturn -EINVAL;\r\n}\r\n}\r\nbuffer = (u32 *)obj->buffer.pointer;\r\nif (buffer[0] != 0x4C4C4544 && buffer[1] != 0x494D5720)\r\npr_warn("Dell descriptor buffer has invalid signature (%*ph)\n",\r\n8, buffer);\r\nif (buffer[2] != 0 && buffer[2] != 1)\r\npr_warn("Dell descriptor buffer has unknown version (%d)\n",\r\nbuffer[2]);\r\nif (buffer[3] != 4096)\r\npr_warn("Dell descriptor buffer has invalid buffer length (%d)\n",\r\nbuffer[3]);\r\ndell_wmi_interface_version = buffer[2];\r\npr_info("Detected Dell WMI interface version %u\n",\r\ndell_wmi_interface_version);\r\nkfree(obj);\r\nreturn 0;\r\n}\r\nstatic int dell_wmi_events_set_enabled(bool enable)\r\n{\r\nstruct calling_interface_buffer *buffer;\r\nint ret;\r\nbuffer = dell_smbios_get_buffer();\r\nbuffer->input[0] = 0x10000;\r\nbuffer->input[1] = 0x51534554;\r\nbuffer->input[3] = enable;\r\ndell_smbios_send_request(17, 3);\r\nret = buffer->output[0];\r\ndell_smbios_release_buffer();\r\nreturn dell_smbios_error(ret);\r\n}\r\nstatic int __init dell_wmi_init(void)\r\n{\r\nint err;\r\nacpi_status status;\r\nif (!wmi_has_guid(DELL_EVENT_GUID) ||\r\n!wmi_has_guid(DELL_DESCRIPTOR_GUID)) {\r\npr_warn("Dell WMI GUID were not found\n");\r\nreturn -ENODEV;\r\n}\r\nerr = dell_wmi_check_descriptor_buffer();\r\nif (err)\r\nreturn err;\r\nerr = dell_wmi_input_setup();\r\nif (err)\r\nreturn err;\r\nstatus = wmi_install_notify_handler(DELL_EVENT_GUID,\r\ndell_wmi_notify, NULL);\r\nif (ACPI_FAILURE(status)) {\r\ndell_wmi_input_destroy();\r\npr_err("Unable to register notify handler - %d\n", status);\r\nreturn -ENODEV;\r\n}\r\ndmi_check_system(dell_wmi_smbios_list);\r\nif (wmi_requires_smbios_request) {\r\nerr = dell_wmi_events_set_enabled(true);\r\nif (err) {\r\npr_err("Failed to enable WMI events\n");\r\nwmi_remove_notify_handler(DELL_EVENT_GUID);\r\ndell_wmi_input_destroy();\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit dell_wmi_exit(void)\r\n{\r\nif (wmi_requires_smbios_request)\r\ndell_wmi_events_set_enabled(false);\r\nwmi_remove_notify_handler(DELL_EVENT_GUID);\r\ndell_wmi_input_destroy();\r\n}
