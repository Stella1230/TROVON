static int rmi_f01_read_properties(struct rmi_device *rmi_dev,\r\nu16 query_base_addr,\r\nstruct f01_basic_properties *props)\r\n{\r\nu8 queries[RMI_F01_BASIC_QUERY_LEN];\r\nint ret;\r\nint query_offset = query_base_addr;\r\nbool has_ds4_queries = false;\r\nbool has_query42 = false;\r\nbool has_sensor_id = false;\r\nbool has_package_id_query = false;\r\nbool has_build_id_query = false;\r\nu16 prod_info_addr;\r\nu8 ds4_query_len;\r\nret = rmi_read_block(rmi_dev, query_offset,\r\nqueries, RMI_F01_BASIC_QUERY_LEN);\r\nif (ret) {\r\ndev_err(&rmi_dev->dev,\r\n"Failed to read device query registers: %d\n", ret);\r\nreturn ret;\r\n}\r\nprod_info_addr = query_offset + 17;\r\nquery_offset += RMI_F01_BASIC_QUERY_LEN;\r\nprops->manufacturer_id = queries[0];\r\nprops->has_lts = queries[1] & RMI_F01_QRY1_HAS_LTS;\r\nprops->has_adjustable_doze =\r\nqueries[1] & RMI_F01_QRY1_HAS_ADJ_DOZE;\r\nprops->has_adjustable_doze_holdoff =\r\nqueries[1] & RMI_F01_QRY1_HAS_ADJ_DOZE_HOFF;\r\nhas_query42 = queries[1] & RMI_F01_QRY1_HAS_QUERY42;\r\nhas_sensor_id = queries[1] & RMI_F01_QRY1_HAS_SENSOR_ID;\r\nsnprintf(props->dom, sizeof(props->dom), "20%02d/%02d/%02d",\r\nqueries[5] & RMI_F01_QRY5_YEAR_MASK,\r\nqueries[6] & RMI_F01_QRY6_MONTH_MASK,\r\nqueries[7] & RMI_F01_QRY7_DAY_MASK);\r\nmemcpy(props->product_id, &queries[11],\r\nRMI_PRODUCT_ID_LENGTH);\r\nprops->product_id[RMI_PRODUCT_ID_LENGTH] = '\0';\r\nprops->productinfo =\r\n((queries[2] & RMI_F01_QRY2_PRODINFO_MASK) << 7) |\r\n(queries[3] & RMI_F01_QRY2_PRODINFO_MASK);\r\nif (has_sensor_id)\r\nquery_offset++;\r\nif (has_query42) {\r\nret = rmi_read(rmi_dev, query_offset, queries);\r\nif (ret) {\r\ndev_err(&rmi_dev->dev,\r\n"Failed to read query 42 register: %d\n", ret);\r\nreturn ret;\r\n}\r\nhas_ds4_queries = !!(queries[0] & BIT(0));\r\nquery_offset++;\r\n}\r\nif (has_ds4_queries) {\r\nret = rmi_read(rmi_dev, query_offset, &ds4_query_len);\r\nif (ret) {\r\ndev_err(&rmi_dev->dev,\r\n"Failed to read DS4 queries length: %d\n", ret);\r\nreturn ret;\r\n}\r\nquery_offset++;\r\nif (ds4_query_len > 0) {\r\nret = rmi_read(rmi_dev, query_offset, queries);\r\nif (ret) {\r\ndev_err(&rmi_dev->dev,\r\n"Failed to read DS4 queries: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nhas_package_id_query = !!(queries[0] & BIT(0));\r\nhas_build_id_query = !!(queries[0] & BIT(1));\r\n}\r\nif (has_package_id_query)\r\nprod_info_addr++;\r\nif (has_build_id_query) {\r\nret = rmi_read_block(rmi_dev, prod_info_addr, queries,\r\n3);\r\nif (ret) {\r\ndev_err(&rmi_dev->dev,\r\n"Failed to read product info: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nprops->firmware_id = queries[1] << 8 | queries[0];\r\nprops->firmware_id += queries[2] * 65536;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nchar *rmi_f01_get_product_ID(struct rmi_function *fn)\r\n{\r\nstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\r\nreturn f01->properties.product_id;\r\n}\r\nstatic int rmi_f01_of_probe(struct device *dev,\r\nstruct rmi_device_platform_data *pdata)\r\n{\r\nint retval;\r\nu32 val;\r\nretval = rmi_of_property_read_u32(dev,\r\n(u32 *)&pdata->power_management.nosleep,\r\n"syna,nosleep-mode", 1);\r\nif (retval)\r\nreturn retval;\r\nretval = rmi_of_property_read_u32(dev, &val,\r\n"syna,wakeup-threshold", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->power_management.wakeup_threshold = val;\r\nretval = rmi_of_property_read_u32(dev, &val,\r\n"syna,doze-holdoff-ms", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->power_management.doze_holdoff = val * 100;\r\nretval = rmi_of_property_read_u32(dev, &val,\r\n"syna,doze-interval-ms", 1);\r\nif (retval)\r\nreturn retval;\r\npdata->power_management.doze_interval = val / 10;\r\nreturn 0;\r\n}\r\nstatic inline int rmi_f01_of_probe(struct device *dev,\r\nstruct rmi_device_platform_data *pdata)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int rmi_f01_probe(struct rmi_function *fn)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct rmi_driver_data *driver_data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\r\nstruct f01_data *f01;\r\nint error;\r\nu16 ctrl_base_addr = fn->fd.control_base_addr;\r\nu8 device_status;\r\nu8 temp;\r\nif (fn->dev.of_node) {\r\nerror = rmi_f01_of_probe(&fn->dev, pdata);\r\nif (error)\r\nreturn error;\r\n}\r\nf01 = devm_kzalloc(&fn->dev, sizeof(struct f01_data), GFP_KERNEL);\r\nif (!f01)\r\nreturn -ENOMEM;\r\nf01->num_of_irq_regs = driver_data->num_of_irq_regs;\r\nerror = rmi_read(rmi_dev, fn->fd.control_base_addr,\r\n&f01->device_control.ctrl0);\r\nif (error) {\r\ndev_err(&fn->dev, "Failed to read F01 control: %d\n", error);\r\nreturn error;\r\n}\r\nswitch (pdata->power_management.nosleep) {\r\ncase RMI_F01_NOSLEEP_DEFAULT:\r\nbreak;\r\ncase RMI_F01_NOSLEEP_OFF:\r\nf01->device_control.ctrl0 &= ~RMI_F01_CRTL0_NOSLEEP_BIT;\r\nbreak;\r\ncase RMI_F01_NOSLEEP_ON:\r\nf01->device_control.ctrl0 |= RMI_F01_CRTL0_NOSLEEP_BIT;\r\nbreak;\r\n}\r\nif ((f01->device_control.ctrl0 & RMI_F01_CTRL0_SLEEP_MODE_MASK) !=\r\nRMI_SLEEP_MODE_NORMAL) {\r\ndev_warn(&fn->dev,\r\n"WARNING: Non-zero sleep mode found. Clearing...\n");\r\nf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\r\n}\r\nf01->device_control.ctrl0 |= RMI_F01_CRTL0_CONFIGURED_BIT;\r\nerror = rmi_write(rmi_dev, fn->fd.control_base_addr,\r\nf01->device_control.ctrl0);\r\nif (error) {\r\ndev_err(&fn->dev, "Failed to write F01 control: %d\n", error);\r\nreturn error;\r\n}\r\nerror = rmi_read(rmi_dev, fn->fd.data_base_addr + 1, &temp);\r\nif (error < 0) {\r\ndev_err(&fn->dev, "Failed to read Interrupt Status.\n");\r\nreturn error;\r\n}\r\nerror = rmi_f01_read_properties(rmi_dev, fn->fd.query_base_addr,\r\n&f01->properties);\r\nif (error < 0) {\r\ndev_err(&fn->dev, "Failed to read F01 properties.\n");\r\nreturn error;\r\n}\r\ndev_info(&fn->dev, "found RMI device, manufacturer: %s, product: %s, fw id: %d\n",\r\nf01->properties.manufacturer_id == 1 ? "Synaptics" : "unknown",\r\nf01->properties.product_id, f01->properties.firmware_id);\r\nctrl_base_addr++;\r\nctrl_base_addr += f01->num_of_irq_regs;\r\nif (f01->properties.has_adjustable_doze) {\r\nf01->doze_interval_addr = ctrl_base_addr;\r\nctrl_base_addr++;\r\nif (pdata->power_management.doze_interval) {\r\nf01->device_control.doze_interval =\r\npdata->power_management.doze_interval;\r\nerror = rmi_write(rmi_dev, f01->doze_interval_addr,\r\nf01->device_control.doze_interval);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to configure F01 doze interval register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n} else {\r\nerror = rmi_read(rmi_dev, f01->doze_interval_addr,\r\n&f01->device_control.doze_interval);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to read F01 doze interval register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n}\r\nf01->wakeup_threshold_addr = ctrl_base_addr;\r\nctrl_base_addr++;\r\nif (pdata->power_management.wakeup_threshold) {\r\nf01->device_control.wakeup_threshold =\r\npdata->power_management.wakeup_threshold;\r\nerror = rmi_write(rmi_dev, f01->wakeup_threshold_addr,\r\nf01->device_control.wakeup_threshold);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to configure F01 wakeup threshold register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n} else {\r\nerror = rmi_read(rmi_dev, f01->wakeup_threshold_addr,\r\n&f01->device_control.wakeup_threshold);\r\nif (error < 0) {\r\ndev_err(&fn->dev,\r\n"Failed to read F01 wakeup threshold register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n}\r\n}\r\nif (f01->properties.has_lts)\r\nctrl_base_addr++;\r\nif (f01->properties.has_adjustable_doze_holdoff) {\r\nf01->doze_holdoff_addr = ctrl_base_addr;\r\nctrl_base_addr++;\r\nif (pdata->power_management.doze_holdoff) {\r\nf01->device_control.doze_holdoff =\r\npdata->power_management.doze_holdoff;\r\nerror = rmi_write(rmi_dev, f01->doze_holdoff_addr,\r\nf01->device_control.doze_holdoff);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to configure F01 doze holdoff register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n} else {\r\nerror = rmi_read(rmi_dev, f01->doze_holdoff_addr,\r\n&f01->device_control.doze_holdoff);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to read F01 doze holdoff register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n}\r\n}\r\nerror = rmi_read(rmi_dev, fn->fd.data_base_addr, &device_status);\r\nif (error < 0) {\r\ndev_err(&fn->dev,\r\n"Failed to read device status: %d\n", error);\r\nreturn error;\r\n}\r\nif (RMI_F01_STATUS_UNCONFIGURED(device_status)) {\r\ndev_err(&fn->dev,\r\n"Device was reset during configuration process, status: %#02x!\n",\r\nRMI_F01_STATUS_CODE(device_status));\r\nreturn -EINVAL;\r\n}\r\ndev_set_drvdata(&fn->dev, f01);\r\nreturn 0;\r\n}\r\nstatic int rmi_f01_config(struct rmi_function *fn)\r\n{\r\nstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\r\nint error;\r\nerror = rmi_write(fn->rmi_dev, fn->fd.control_base_addr,\r\nf01->device_control.ctrl0);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to write device_control register: %d\n", error);\r\nreturn error;\r\n}\r\nif (f01->properties.has_adjustable_doze) {\r\nerror = rmi_write(fn->rmi_dev, f01->doze_interval_addr,\r\nf01->device_control.doze_interval);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to write doze interval: %d\n", error);\r\nreturn error;\r\n}\r\nerror = rmi_write_block(fn->rmi_dev,\r\nf01->wakeup_threshold_addr,\r\n&f01->device_control.wakeup_threshold,\r\nsizeof(u8));\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to write wakeup threshold: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n}\r\nif (f01->properties.has_adjustable_doze_holdoff) {\r\nerror = rmi_write(fn->rmi_dev, f01->doze_holdoff_addr,\r\nf01->device_control.doze_holdoff);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to write doze holdoff: %d\n", error);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f01_suspend(struct rmi_function *fn)\r\n{\r\nstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\r\nint error;\r\nf01->old_nosleep =\r\nf01->device_control.ctrl0 & RMI_F01_CRTL0_NOSLEEP_BIT;\r\nf01->device_control.ctrl0 &= ~RMI_F01_CRTL0_NOSLEEP_BIT;\r\nf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\r\nif (device_may_wakeup(fn->rmi_dev->xport->dev))\r\nf01->device_control.ctrl0 |= RMI_SLEEP_MODE_RESERVED1;\r\nelse\r\nf01->device_control.ctrl0 |= RMI_SLEEP_MODE_SENSOR_SLEEP;\r\nerror = rmi_write(fn->rmi_dev, fn->fd.control_base_addr,\r\nf01->device_control.ctrl0);\r\nif (error) {\r\ndev_err(&fn->dev, "Failed to write sleep mode: %d.\n", error);\r\nif (f01->old_nosleep)\r\nf01->device_control.ctrl0 |= RMI_F01_CRTL0_NOSLEEP_BIT;\r\nf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\r\nf01->device_control.ctrl0 |= RMI_SLEEP_MODE_NORMAL;\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f01_resume(struct rmi_function *fn)\r\n{\r\nstruct f01_data *f01 = dev_get_drvdata(&fn->dev);\r\nint error;\r\nif (f01->old_nosleep)\r\nf01->device_control.ctrl0 |= RMI_F01_CRTL0_NOSLEEP_BIT;\r\nf01->device_control.ctrl0 &= ~RMI_F01_CTRL0_SLEEP_MODE_MASK;\r\nf01->device_control.ctrl0 |= RMI_SLEEP_MODE_NORMAL;\r\nerror = rmi_write(fn->rmi_dev, fn->fd.control_base_addr,\r\nf01->device_control.ctrl0);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to restore normal operation: %d.\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f01_attention(struct rmi_function *fn,\r\nunsigned long *irq_bits)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nint error;\r\nu8 device_status;\r\nerror = rmi_read(rmi_dev, fn->fd.data_base_addr, &device_status);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to read device status: %d.\n", error);\r\nreturn error;\r\n}\r\nif (RMI_F01_STATUS_UNCONFIGURED(device_status)) {\r\ndev_warn(&fn->dev, "Device reset detected.\n");\r\nerror = rmi_dev->driver->reset_handler(rmi_dev);\r\nif (error) {\r\ndev_err(&fn->dev, "Device reset failed: %d\n", error);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}
