static int has_hid(struct acpi_device *dev, const char *hid)\r\n{\r\nstruct acpi_hardware_id *id;\r\nlist_for_each_entry(id, &dev->pnp.ids, list)\r\nif (!strcmp(hid, id->id))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int is_itpm(struct acpi_device *dev)\r\n{\r\nreturn has_hid(dev, "INTC0102");\r\n}\r\nstatic inline int is_itpm(struct acpi_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wait_startup(struct tpm_chip *chip, int l)\r\n{\r\nunsigned long stop = jiffies + chip->vendor.timeout_a;\r\ndo {\r\nif (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\nTPM_ACCESS_VALID)\r\nreturn 0;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -1;\r\n}\r\nstatic int check_locality(struct tpm_chip *chip, int l)\r\n{\r\nif ((ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID))\r\nreturn chip->vendor.locality = l;\r\nreturn -1;\r\n}\r\nstatic void release_locality(struct tpm_chip *chip, int l, int force)\r\n{\r\nif (force || (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\n(TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID))\r\niowrite8(TPM_ACCESS_ACTIVE_LOCALITY,\r\nchip->vendor.iobase + TPM_ACCESS(l));\r\n}\r\nstatic int request_locality(struct tpm_chip *chip, int l)\r\n{\r\nunsigned long stop, timeout;\r\nlong rc;\r\nif (check_locality(chip, l) >= 0)\r\nreturn l;\r\niowrite8(TPM_ACCESS_REQUEST_USE,\r\nchip->vendor.iobase + TPM_ACCESS(l));\r\nstop = jiffies + chip->vendor.timeout_a;\r\nif (chip->vendor.irq) {\r\nagain:\r\ntimeout = stop - jiffies;\r\nif ((long)timeout <= 0)\r\nreturn -1;\r\nrc = wait_event_interruptible_timeout(chip->vendor.int_queue,\r\n(check_locality\r\n(chip, l) >= 0),\r\ntimeout);\r\nif (rc > 0)\r\nreturn l;\r\nif (rc == -ERESTARTSYS && freezing(current)) {\r\nclear_thread_flag(TIF_SIGPENDING);\r\ngoto again;\r\n}\r\n} else {\r\ndo {\r\nif (check_locality(chip, l) >= 0)\r\nreturn l;\r\nmsleep(TPM_TIMEOUT);\r\n}\r\nwhile (time_before(jiffies, stop));\r\n}\r\nreturn -1;\r\n}\r\nstatic u8 tpm_tis_status(struct tpm_chip *chip)\r\n{\r\nreturn ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality));\r\n}\r\nstatic void tpm_tis_ready(struct tpm_chip *chip)\r\n{\r\niowrite8(TPM_STS_COMMAND_READY,\r\nchip->vendor.iobase + TPM_STS(chip->vendor.locality));\r\n}\r\nstatic int get_burstcount(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nint burstcnt;\r\nstop = jiffies + chip->vendor.timeout_d;\r\ndo {\r\nburstcnt = ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality) + 1);\r\nburstcnt += ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality) +\r\n2) << 8;\r\nif (burstcnt)\r\nreturn burstcnt;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -EBUSY;\r\n}\r\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0, burstcnt;\r\nwhile (size < count &&\r\nwait_for_tpm_stat(chip,\r\nTPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\nchip->vendor.timeout_c,\r\n&chip->vendor.read_queue, true)\r\n== 0) {\r\nburstcnt = get_burstcount(chip);\r\nfor (; burstcnt > 0 && size < count; burstcnt--)\r\nbuf[size++] = ioread8(chip->vendor.iobase +\r\nTPM_DATA_FIFO(chip->vendor.\r\nlocality));\r\n}\r\nreturn size;\r\n}\r\nstatic int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0;\r\nint expected, status;\r\nif (count < TPM_HEADER_SIZE) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nif ((size =\r\nrecv_data(chip, buf, TPM_HEADER_SIZE)) < TPM_HEADER_SIZE) {\r\ndev_err(chip->pdev, "Unable to read header\n");\r\ngoto out;\r\n}\r\nexpected = be32_to_cpu(*(__be32 *) (buf + 2));\r\nif (expected > count) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nif ((size +=\r\nrecv_data(chip, &buf[TPM_HEADER_SIZE],\r\nexpected - TPM_HEADER_SIZE)) < expected) {\r\ndev_err(chip->pdev, "Unable to read remainder of result\n");\r\nsize = -ETIME;\r\ngoto out;\r\n}\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif (status & TPM_STS_DATA_AVAIL) {\r\ndev_err(chip->pdev, "Error left over data\n");\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nout:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn size;\r\n}\r\nstatic int tpm_tis_send_data(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc, status, burstcnt;\r\nsize_t count = 0;\r\nif (request_locality(chip, 0) < 0)\r\nreturn -EBUSY;\r\nstatus = tpm_tis_status(chip);\r\nif ((status & TPM_STS_COMMAND_READY) == 0) {\r\ntpm_tis_ready(chip);\r\nif (wait_for_tpm_stat\r\n(chip, TPM_STS_COMMAND_READY, chip->vendor.timeout_b,\r\n&chip->vendor.int_queue, false) < 0) {\r\nrc = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nwhile (count < len - 1) {\r\nburstcnt = get_burstcount(chip);\r\nfor (; burstcnt > 0 && count < len - 1; burstcnt--) {\r\niowrite8(buf[count], chip->vendor.iobase +\r\nTPM_DATA_FIFO(chip->vendor.locality));\r\ncount++;\r\n}\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif (!itpm && (status & TPM_STS_DATA_EXPECT) == 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\n}\r\niowrite8(buf[count],\r\nchip->vendor.iobase + TPM_DATA_FIFO(chip->vendor.locality));\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif ((status & TPM_STS_DATA_EXPECT) != 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic void disable_interrupts(struct tpm_chip *chip)\r\n{\r\nu32 intmask;\r\nintmask =\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask &= ~TPM_GLOBAL_INT_ENABLE;\r\niowrite32(intmask,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\ndevm_free_irq(chip->pdev, chip->vendor.irq, chip);\r\nchip->vendor.irq = 0;\r\n}\r\nstatic int tpm_tis_send_main(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc;\r\nu32 ordinal;\r\nunsigned long dur;\r\nrc = tpm_tis_send_data(chip, buf, len);\r\nif (rc < 0)\r\nreturn rc;\r\niowrite8(TPM_STS_GO,\r\nchip->vendor.iobase + TPM_STS(chip->vendor.locality));\r\nif (chip->vendor.irq) {\r\nordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ndur = tpm2_calc_ordinal_duration(chip, ordinal);\r\nelse\r\ndur = tpm_calc_ordinal_duration(chip, ordinal);\r\nif (wait_for_tpm_stat\r\n(chip, TPM_STS_DATA_AVAIL | TPM_STS_VALID, dur,\r\n&chip->vendor.read_queue, false) < 0) {\r\nrc = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nreturn len;\r\nout_err:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc, irq;\r\nstruct priv_data *priv = chip->vendor.priv;\r\nif (!chip->vendor.irq || priv->irq_tested)\r\nreturn tpm_tis_send_main(chip, buf, len);\r\nirq = chip->vendor.irq;\r\nchip->vendor.irq = 0;\r\nrc = tpm_tis_send_main(chip, buf, len);\r\nchip->vendor.irq = irq;\r\nif (!priv->irq_tested)\r\nmsleep(1);\r\nif (!priv->irq_tested)\r\ndisable_interrupts(chip);\r\npriv->irq_tested = true;\r\nreturn rc;\r\n}\r\nstatic bool tpm_tis_update_timeouts(struct tpm_chip *chip,\r\nunsigned long *timeout_cap)\r\n{\r\nint i;\r\nu32 did_vid;\r\ndid_vid = ioread32(chip->vendor.iobase + TPM_DID_VID(0));\r\nfor (i = 0; i != ARRAY_SIZE(vendor_timeout_overrides); i++) {\r\nif (vendor_timeout_overrides[i].did_vid != did_vid)\r\ncontinue;\r\nmemcpy(timeout_cap, vendor_timeout_overrides[i].timeout_us,\r\nsizeof(vendor_timeout_overrides[i].timeout_us));\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int probe_itpm(struct tpm_chip *chip)\r\n{\r\nint rc = 0;\r\nu8 cmd_getticks[] = {\r\n0x00, 0xc1, 0x00, 0x00, 0x00, 0x0a,\r\n0x00, 0x00, 0x00, 0xf1\r\n};\r\nsize_t len = sizeof(cmd_getticks);\r\nbool rem_itpm = itpm;\r\nu16 vendor = ioread16(chip->vendor.iobase + TPM_DID_VID(0));\r\nif (vendor != TPM_VID_INTEL)\r\nreturn 0;\r\nitpm = false;\r\nrc = tpm_tis_send_data(chip, cmd_getticks, len);\r\nif (rc == 0)\r\ngoto out;\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nitpm = true;\r\nrc = tpm_tis_send_data(chip, cmd_getticks, len);\r\nif (rc == 0) {\r\ndev_info(chip->pdev, "Detected an iTPM.\n");\r\nrc = 1;\r\n} else\r\nrc = -EFAULT;\r\nout:\r\nitpm = rem_itpm;\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nswitch (chip->vendor.manufacturer_id) {\r\ncase TPM_VID_WINBOND:\r\nreturn ((status == TPM_STS_VALID) ||\r\n(status == (TPM_STS_VALID | TPM_STS_COMMAND_READY)));\r\ncase TPM_VID_STM:\r\nreturn (status == (TPM_STS_VALID | TPM_STS_COMMAND_READY));\r\ndefault:\r\nreturn (status == TPM_STS_COMMAND_READY);\r\n}\r\n}\r\nstatic irqreturn_t tis_int_handler(int dummy, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nu32 interrupt;\r\nint i;\r\ninterrupt = ioread32(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nif (interrupt == 0)\r\nreturn IRQ_NONE;\r\n((struct priv_data *)chip->vendor.priv)->irq_tested = true;\r\nif (interrupt & TPM_INTF_DATA_AVAIL_INT)\r\nwake_up_interruptible(&chip->vendor.read_queue);\r\nif (interrupt & TPM_INTF_LOCALITY_CHANGE_INT)\r\nfor (i = 0; i < 5; i++)\r\nif (check_locality(chip, i) >= 0)\r\nbreak;\r\nif (interrupt &\r\n(TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_STS_VALID_INT |\r\nTPM_INTF_CMD_READY_INT))\r\nwake_up_interruptible(&chip->vendor.int_queue);\r\niowrite32(interrupt,\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nioread32(chip->vendor.iobase + TPM_INT_STATUS(chip->vendor.locality));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tpm_tis_probe_irq_single(struct tpm_chip *chip, u32 intmask,\r\nint flags, int irq)\r\n{\r\nstruct priv_data *priv = chip->vendor.priv;\r\nu8 original_int_vec;\r\nif (devm_request_irq(chip->pdev, irq, tis_int_handler, flags,\r\nchip->devname, chip) != 0) {\r\ndev_info(chip->pdev, "Unable to request irq: %d for probe\n",\r\nirq);\r\nreturn -1;\r\n}\r\nchip->vendor.irq = irq;\r\noriginal_int_vec = ioread8(chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\niowrite8(irq,\r\nchip->vendor.iobase + TPM_INT_VECTOR(chip->vendor.locality));\r\niowrite32(ioread32(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality)),\r\nchip->vendor.iobase + TPM_INT_STATUS(chip->vendor.locality));\r\niowrite32(intmask | TPM_GLOBAL_INT_ENABLE,\r\nchip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));\r\npriv->irq_tested = false;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ntpm2_gen_interrupt(chip);\r\nelse\r\ntpm_gen_interrupt(chip);\r\nif (!chip->vendor.irq) {\r\niowrite8(original_int_vec,\r\nchip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tpm_tis_probe_irq(struct tpm_chip *chip, u32 intmask)\r\n{\r\nu8 original_int_vec;\r\nint i;\r\noriginal_int_vec = ioread8(chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nif (!original_int_vec) {\r\nif (IS_ENABLED(CONFIG_X86))\r\nfor (i = 3; i <= 15; i++)\r\nif (!tpm_tis_probe_irq_single(chip, intmask, 0,\r\ni))\r\nreturn;\r\n} else if (!tpm_tis_probe_irq_single(chip, intmask, 0,\r\noriginal_int_vec))\r\nreturn;\r\n}\r\nstatic void tpm_tis_remove(struct tpm_chip *chip)\r\n{\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ntpm2_shutdown(chip, TPM2_SU_CLEAR);\r\niowrite32(~TPM_GLOBAL_INT_ENABLE &\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.\r\nlocality)),\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nrelease_locality(chip, chip->vendor.locality, 1);\r\n}\r\nstatic int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info,\r\nacpi_handle acpi_dev_handle)\r\n{\r\nu32 vendor, intfcaps, intmask;\r\nint rc, probe;\r\nstruct tpm_chip *chip;\r\nstruct priv_data *priv;\r\npriv = devm_kzalloc(dev, sizeof(struct priv_data), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\nchip = tpmm_chip_alloc(dev, &tpm_tis);\r\nif (IS_ERR(chip))\r\nreturn PTR_ERR(chip);\r\nchip->vendor.priv = priv;\r\n#ifdef CONFIG_ACPI\r\nchip->acpi_dev_handle = acpi_dev_handle;\r\n#endif\r\nchip->vendor.iobase = devm_ioremap_resource(dev, &tpm_info->res);\r\nif (IS_ERR(chip->vendor.iobase))\r\nreturn PTR_ERR(chip->vendor.iobase);\r\nchip->vendor.timeout_a = TIS_TIMEOUT_A_MAX;\r\nchip->vendor.timeout_b = TIS_TIMEOUT_B_MAX;\r\nchip->vendor.timeout_c = TIS_TIMEOUT_C_MAX;\r\nchip->vendor.timeout_d = TIS_TIMEOUT_D_MAX;\r\nif (wait_startup(chip, 0) != 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nintmask = ioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask |= TPM_INTF_CMD_READY_INT | TPM_INTF_LOCALITY_CHANGE_INT |\r\nTPM_INTF_DATA_AVAIL_INT | TPM_INTF_STS_VALID_INT;\r\nintmask &= ~TPM_GLOBAL_INT_ENABLE;\r\niowrite32(intmask,\r\nchip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));\r\nif (request_locality(chip, 0) != 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nrc = tpm2_probe(chip);\r\nif (rc)\r\ngoto out_err;\r\nvendor = ioread32(chip->vendor.iobase + TPM_DID_VID(0));\r\nchip->vendor.manufacturer_id = vendor;\r\ndev_info(dev, "%s TPM (device-id 0x%X, rev-id %d)\n",\r\n(chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",\r\nvendor >> 16, ioread8(chip->vendor.iobase + TPM_RID(0)));\r\nif (!itpm) {\r\nprobe = probe_itpm(chip);\r\nif (probe < 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nitpm = !!probe;\r\n}\r\nif (itpm)\r\ndev_info(dev, "Intel iTPM workaround enabled\n");\r\nintfcaps =\r\nioread32(chip->vendor.iobase +\r\nTPM_INTF_CAPS(chip->vendor.locality));\r\ndev_dbg(dev, "TPM interface capabilities (0x%x):\n",\r\nintfcaps);\r\nif (intfcaps & TPM_INTF_BURST_COUNT_STATIC)\r\ndev_dbg(dev, "\tBurst Count Static\n");\r\nif (intfcaps & TPM_INTF_CMD_READY_INT)\r\ndev_dbg(dev, "\tCommand Ready Int Support\n");\r\nif (intfcaps & TPM_INTF_INT_EDGE_FALLING)\r\ndev_dbg(dev, "\tInterrupt Edge Falling\n");\r\nif (intfcaps & TPM_INTF_INT_EDGE_RISING)\r\ndev_dbg(dev, "\tInterrupt Edge Rising\n");\r\nif (intfcaps & TPM_INTF_INT_LEVEL_LOW)\r\ndev_dbg(dev, "\tInterrupt Level Low\n");\r\nif (intfcaps & TPM_INTF_INT_LEVEL_HIGH)\r\ndev_dbg(dev, "\tInterrupt Level High\n");\r\nif (intfcaps & TPM_INTF_LOCALITY_CHANGE_INT)\r\ndev_dbg(dev, "\tLocality Change Int Support\n");\r\nif (intfcaps & TPM_INTF_STS_VALID_INT)\r\ndev_dbg(dev, "\tSts Valid Int Support\n");\r\nif (intfcaps & TPM_INTF_DATA_AVAIL_INT)\r\ndev_dbg(dev, "\tData Avail Int Support\n");\r\nif (tpm_get_timeouts(chip)) {\r\ndev_err(dev, "Could not get TPM timeouts and durations\n");\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\ninit_waitqueue_head(&chip->vendor.read_queue);\r\ninit_waitqueue_head(&chip->vendor.int_queue);\r\nif (interrupts && tpm_info->irq != -1) {\r\nif (tpm_info->irq) {\r\ntpm_tis_probe_irq_single(chip, intmask, IRQF_SHARED,\r\ntpm_info->irq);\r\nif (!chip->vendor.irq)\r\ndev_err(chip->pdev, FW_BUG\r\n"TPM interrupt not working, polling instead\n");\r\n} else\r\ntpm_tis_probe_irq(chip, intmask);\r\n}\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2) {\r\nrc = tpm2_do_selftest(chip);\r\nif (rc == TPM2_RC_INITIALIZE) {\r\ndev_warn(dev, "Firmware has not started TPM\n");\r\nrc = tpm2_startup(chip, TPM2_SU_CLEAR);\r\nif (!rc)\r\nrc = tpm2_do_selftest(chip);\r\n}\r\nif (rc) {\r\ndev_err(dev, "TPM self test failed\n");\r\nif (rc > 0)\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\n} else {\r\nif (tpm_do_selftest(chip)) {\r\ndev_err(dev, "TPM self test failed\n");\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\n}\r\nreturn tpm_chip_register(chip);\r\nout_err:\r\ntpm_tis_remove(chip);\r\nreturn rc;\r\n}\r\nstatic void tpm_tis_reenable_interrupts(struct tpm_chip *chip)\r\n{\r\nu32 intmask;\r\niowrite8(chip->vendor.irq, chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nintmask =\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask |= TPM_INTF_CMD_READY_INT\r\n| TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_DATA_AVAIL_INT\r\n| TPM_INTF_STS_VALID_INT | TPM_GLOBAL_INT_ENABLE;\r\niowrite32(intmask,\r\nchip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));\r\n}\r\nstatic int tpm_tis_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nint ret;\r\nif (chip->vendor.irq)\r\ntpm_tis_reenable_interrupts(chip);\r\nret = tpm_pm_resume(dev);\r\nif (ret)\r\nreturn ret;\r\nif (!(chip->flags & TPM_CHIP_FLAG_TPM2))\r\ntpm_do_selftest(chip);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,\r\nconst struct pnp_device_id *pnp_id)\r\n{\r\nstruct tpm_info tpm_info = {};\r\nacpi_handle acpi_dev_handle = NULL;\r\nstruct resource *res;\r\nres = pnp_get_resource(pnp_dev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\ntpm_info.res = *res;\r\nif (pnp_irq_valid(pnp_dev, 0))\r\ntpm_info.irq = pnp_irq(pnp_dev, 0);\r\nelse\r\ntpm_info.irq = -1;\r\nif (pnp_acpi_device(pnp_dev)) {\r\nif (is_itpm(pnp_acpi_device(pnp_dev)))\r\nitpm = true;\r\nacpi_dev_handle = ACPI_HANDLE(&pnp_dev->dev);\r\n}\r\nreturn tpm_tis_init(&pnp_dev->dev, &tpm_info, acpi_dev_handle);\r\n}\r\nstatic void tpm_tis_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct tpm_chip *chip = pnp_get_drvdata(dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\n}\r\nstatic int tpm_check_resource(struct acpi_resource *ares, void *data)\r\n{\r\nstruct tpm_info *tpm_info = (struct tpm_info *) data;\r\nstruct resource res;\r\nif (acpi_dev_resource_interrupt(ares, 0, &res))\r\ntpm_info->irq = res.start;\r\nelse if (acpi_dev_resource_memory(ares, &res)) {\r\ntpm_info->res = res;\r\ntpm_info->res.name = NULL;\r\n}\r\nreturn 1;\r\n}\r\nstatic int tpm_tis_acpi_init(struct acpi_device *acpi_dev)\r\n{\r\nstruct acpi_table_tpm2 *tbl;\r\nacpi_status st;\r\nstruct list_head resources;\r\nstruct tpm_info tpm_info = {};\r\nint ret;\r\nst = acpi_get_table(ACPI_SIG_TPM2, 1,\r\n(struct acpi_table_header **) &tbl);\r\nif (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {\r\ndev_err(&acpi_dev->dev,\r\nFW_BUG "failed to get TPM2 ACPI table\n");\r\nreturn -EINVAL;\r\n}\r\nif (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)\r\nreturn -ENODEV;\r\nINIT_LIST_HEAD(&resources);\r\ntpm_info.irq = -1;\r\nret = acpi_dev_get_resources(acpi_dev, &resources, tpm_check_resource,\r\n&tpm_info);\r\nif (ret < 0)\r\nreturn ret;\r\nacpi_dev_free_resource_list(&resources);\r\nif (resource_type(&tpm_info.res) != IORESOURCE_MEM) {\r\ndev_err(&acpi_dev->dev,\r\nFW_BUG "TPM2 ACPI table does not define a memory resource\n");\r\nreturn -EINVAL;\r\n}\r\nif (is_itpm(acpi_dev))\r\nitpm = true;\r\nreturn tpm_tis_init(&acpi_dev->dev, &tpm_info, acpi_dev->handle);\r\n}\r\nstatic int tpm_tis_acpi_remove(struct acpi_device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&dev->dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_plat_probe(struct platform_device *pdev)\r\n{\r\nstruct tpm_info tpm_info = {};\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\ntpm_info.res = *res;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res) {\r\ntpm_info.irq = res->start;\r\n} else {\r\nif (pdev == force_pdev)\r\ntpm_info.irq = -1;\r\nelse\r\ntpm_info.irq = 0;\r\n}\r\nreturn tpm_tis_init(&pdev->dev, &tpm_info, NULL);\r\n}\r\nstatic int tpm_tis_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&pdev->dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_force_device(void)\r\n{\r\nstruct platform_device *pdev;\r\nstatic const struct resource x86_resources[] = {\r\n{\r\n.start = 0xFED40000,\r\n.end = 0xFED40000 + TIS_MEM_LEN - 1,\r\n.flags = IORESOURCE_MEM,\r\n},\r\n};\r\nif (!force)\r\nreturn 0;\r\npdev = platform_device_register_simple("tpm_tis", -1, x86_resources,\r\nARRAY_SIZE(x86_resources));\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nforce_pdev = pdev;\r\nreturn 0;\r\n}\r\nstatic int __init init_tis(void)\r\n{\r\nint rc;\r\nrc = tpm_tis_force_device();\r\nif (rc)\r\ngoto err_force;\r\nrc = platform_driver_register(&tis_drv);\r\nif (rc)\r\ngoto err_platform;\r\n#ifdef CONFIG_ACPI\r\nrc = acpi_bus_register_driver(&tis_acpi_driver);\r\nif (rc)\r\ngoto err_acpi;\r\n#endif\r\nif (IS_ENABLED(CONFIG_PNP)) {\r\nrc = pnp_register_driver(&tis_pnp_driver);\r\nif (rc)\r\ngoto err_pnp;\r\n}\r\nreturn 0;\r\nerr_pnp:\r\n#ifdef CONFIG_ACPI\r\nacpi_bus_unregister_driver(&tis_acpi_driver);\r\nerr_acpi:\r\n#endif\r\nplatform_device_unregister(force_pdev);\r\nerr_platform:\r\nif (force_pdev)\r\nplatform_device_unregister(force_pdev);\r\nerr_force:\r\nreturn rc;\r\n}\r\nstatic void __exit cleanup_tis(void)\r\n{\r\npnp_unregister_driver(&tis_pnp_driver);\r\n#ifdef CONFIG_ACPI\r\nacpi_bus_unregister_driver(&tis_acpi_driver);\r\n#endif\r\nplatform_driver_unregister(&tis_drv);\r\nif (force_pdev)\r\nplatform_device_unregister(force_pdev);\r\n}
