static u32 acp_reg_read(void __iomem *acp_mmio, u32 reg)\r\n{\r\nreturn readl(acp_mmio + (reg * 4));\r\n}\r\nstatic void acp_reg_write(u32 val, void __iomem *acp_mmio, u32 reg)\r\n{\r\nwritel(val, acp_mmio + (reg * 4));\r\n}\r\nstatic void config_acp_dma_channel(void __iomem *acp_mmio, u8 ch_num,\r\nu16 dscr_strt_idx, u16 num_dscrs,\r\nenum acp_dma_priority_level priority_level)\r\n{\r\nu32 dma_ctrl;\r\ndma_ctrl = acp_reg_read(acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\r\ndma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;\r\nacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\r\nacp_reg_write((ACP_DMA_DSCR_STRT_IDX_0__DMAChDscrStrtIdx_MASK\r\n& dscr_strt_idx),\r\nacp_mmio, mmACP_DMA_DSCR_STRT_IDX_0 + ch_num);\r\nacp_reg_write(ACP_DMA_DSCR_CNT_0__DMAChDscrCnt_MASK & num_dscrs,\r\nacp_mmio, mmACP_DMA_DSCR_CNT_0 + ch_num);\r\nacp_reg_write(priority_level, acp_mmio, mmACP_DMA_PRIO_0 + ch_num);\r\n}\r\nstatic void config_dma_descriptor_in_sram(void __iomem *acp_mmio,\r\nu16 descr_idx,\r\nacp_dma_dscr_transfer_t *descr_info)\r\n{\r\nu32 sram_offset;\r\nsram_offset = (descr_idx * sizeof(acp_dma_dscr_transfer_t));\r\nacp_reg_write(sram_offset, acp_mmio, mmACP_SRBM_Targ_Idx_Addr);\r\nacp_reg_write(descr_info->src, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\r\nacp_reg_write(sram_offset + 4, acp_mmio, mmACP_SRBM_Targ_Idx_Addr);\r\nacp_reg_write(descr_info->dest, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\r\nacp_reg_write(sram_offset + 8, acp_mmio, mmACP_SRBM_Targ_Idx_Addr);\r\nacp_reg_write(descr_info->xfer_val, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\r\n}\r\nstatic void set_acp_sysmem_dma_descriptors(void __iomem *acp_mmio,\r\nu32 size, int direction,\r\nu32 pte_offset)\r\n{\r\nu16 i;\r\nu16 dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH12;\r\nacp_dma_dscr_transfer_t dmadscr[NUM_DSCRS_PER_CHANNEL];\r\nfor (i = 0; i < NUM_DSCRS_PER_CHANNEL; i++) {\r\ndmadscr[i].xfer_val = 0;\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH12 + i;\r\ndmadscr[i].dest = ACP_SHARED_RAM_BANK_1_ADDRESS +\r\n(size / 2) - (i * (size/2));\r\ndmadscr[i].src = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS\r\n+ (pte_offset * SZ_4K) + (i * (size/2));\r\ndmadscr[i].xfer_val |=\r\n(ACP_DMA_ATTRIBUTES_DAGB_ONION_TO_SHAREDMEM << 16) |\r\n(size / 2);\r\n} else {\r\ndma_dscr_idx = CAPTURE_START_DMA_DESCR_CH14 + i;\r\ndmadscr[i].src = ACP_SHARED_RAM_BANK_5_ADDRESS +\r\n(i * (size/2));\r\ndmadscr[i].dest = ACP_INTERNAL_APERTURE_WINDOW_0_ADDRESS\r\n+ (pte_offset * SZ_4K) +\r\n(i * (size/2));\r\ndmadscr[i].xfer_val |=\r\nBIT(22) |\r\n(ACP_DMA_ATTRIBUTES_SHAREDMEM_TO_DAGB_ONION << 16) |\r\n(size / 2);\r\n}\r\nconfig_dma_descriptor_in_sram(acp_mmio, dma_dscr_idx,\r\n&dmadscr[i]);\r\n}\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK)\r\nconfig_acp_dma_channel(acp_mmio, SYSRAM_TO_ACP_CH_NUM,\r\nPLAYBACK_START_DMA_DESCR_CH12,\r\nNUM_DSCRS_PER_CHANNEL,\r\nACP_DMA_PRIORITY_LEVEL_NORMAL);\r\nelse\r\nconfig_acp_dma_channel(acp_mmio, ACP_TO_SYSRAM_CH_NUM,\r\nCAPTURE_START_DMA_DESCR_CH14,\r\nNUM_DSCRS_PER_CHANNEL,\r\nACP_DMA_PRIORITY_LEVEL_NORMAL);\r\n}\r\nstatic void set_acp_to_i2s_dma_descriptors(void __iomem *acp_mmio,\r\nu32 size, int direction)\r\n{\r\nu16 i;\r\nu16 dma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13;\r\nacp_dma_dscr_transfer_t dmadscr[NUM_DSCRS_PER_CHANNEL];\r\nfor (i = 0; i < NUM_DSCRS_PER_CHANNEL; i++) {\r\ndmadscr[i].xfer_val = 0;\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndma_dscr_idx = PLAYBACK_START_DMA_DESCR_CH13 + i;\r\ndmadscr[i].src = ACP_SHARED_RAM_BANK_1_ADDRESS +\r\n(i * (size/2));\r\ndmadscr[i].dest = 0;\r\ndmadscr[i].xfer_val |= BIT(22) | (TO_ACP_I2S_1 << 16) |\r\n(size / 2);\r\n} else {\r\ndma_dscr_idx = CAPTURE_START_DMA_DESCR_CH15 + i;\r\ndmadscr[i].src = 0;\r\ndmadscr[i].dest = ACP_SHARED_RAM_BANK_5_ADDRESS +\r\n(i * (size / 2));\r\ndmadscr[i].xfer_val |= BIT(22) |\r\n(FROM_ACP_I2S_1 << 16) | (size / 2);\r\n}\r\nconfig_dma_descriptor_in_sram(acp_mmio, dma_dscr_idx,\r\n&dmadscr[i]);\r\n}\r\nif (direction == SNDRV_PCM_STREAM_PLAYBACK)\r\nconfig_acp_dma_channel(acp_mmio, ACP_TO_I2S_DMA_CH_NUM,\r\nPLAYBACK_START_DMA_DESCR_CH13,\r\nNUM_DSCRS_PER_CHANNEL,\r\nACP_DMA_PRIORITY_LEVEL_NORMAL);\r\nelse\r\nconfig_acp_dma_channel(acp_mmio, I2S_TO_ACP_DMA_CH_NUM,\r\nCAPTURE_START_DMA_DESCR_CH15,\r\nNUM_DSCRS_PER_CHANNEL,\r\nACP_DMA_PRIORITY_LEVEL_NORMAL);\r\n}\r\nstatic void acp_pte_config(void __iomem *acp_mmio, struct page *pg,\r\nu16 num_of_pages, u32 pte_offset)\r\n{\r\nu16 page_idx;\r\nu64 addr;\r\nu32 low;\r\nu32 high;\r\nu32 offset;\r\noffset = ACP_DAGB_GRP_SRBM_SRAM_BASE_OFFSET + (pte_offset * 8);\r\nfor (page_idx = 0; page_idx < (num_of_pages); page_idx++) {\r\nacp_reg_write((offset + (page_idx * 8)),\r\nacp_mmio, mmACP_SRBM_Targ_Idx_Addr);\r\naddr = page_to_phys(pg);\r\nlow = lower_32_bits(addr);\r\nhigh = upper_32_bits(addr);\r\nacp_reg_write(low, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\r\nacp_reg_write((offset + (page_idx * 8) + 4),\r\nacp_mmio, mmACP_SRBM_Targ_Idx_Addr);\r\nhigh |= BIT(31);\r\nacp_reg_write(high, acp_mmio, mmACP_SRBM_Targ_Idx_Data);\r\npg++;\r\n}\r\n}\r\nstatic void config_acp_dma(void __iomem *acp_mmio,\r\nstruct audio_substream_data *audio_config)\r\n{\r\nu32 pte_offset;\r\nif (audio_config->direction == SNDRV_PCM_STREAM_PLAYBACK)\r\npte_offset = ACP_PLAYBACK_PTE_OFFSET;\r\nelse\r\npte_offset = ACP_CAPTURE_PTE_OFFSET;\r\nacp_pte_config(acp_mmio, audio_config->pg, audio_config->num_of_pages,\r\npte_offset);\r\nset_acp_sysmem_dma_descriptors(acp_mmio, audio_config->size,\r\naudio_config->direction, pte_offset);\r\nset_acp_to_i2s_dma_descriptors(acp_mmio, audio_config->size,\r\naudio_config->direction);\r\n}\r\nstatic void acp_dma_start(void __iomem *acp_mmio,\r\nu16 ch_num, bool is_circular)\r\n{\r\nu32 dma_ctrl;\r\ndma_ctrl = acp_reg_read(acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\r\nacp_reg_write(1, acp_mmio, mmACP_DAGB_ATU_CTRL);\r\ndma_ctrl |= ACP_DMA_CNTL_0__DMAChRun_MASK;\r\nswitch (ch_num) {\r\ncase ACP_TO_I2S_DMA_CH_NUM:\r\ncase ACP_TO_SYSRAM_CH_NUM:\r\ncase I2S_TO_ACP_DMA_CH_NUM:\r\ndma_ctrl |= ACP_DMA_CNTL_0__DMAChIOCEn_MASK;\r\nbreak;\r\ndefault:\r\ndma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;\r\nbreak;\r\n}\r\nif (is_circular == true)\r\ndma_ctrl |= ACP_DMA_CNTL_0__Circular_DMA_En_MASK;\r\nelse\r\ndma_ctrl &= ~ACP_DMA_CNTL_0__Circular_DMA_En_MASK;\r\nacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\r\n}\r\nstatic int acp_dma_stop(void __iomem *acp_mmio, u8 ch_num)\r\n{\r\nu32 dma_ctrl;\r\nu32 dma_ch_sts;\r\nu32 count = ACP_DMA_RESET_TIME;\r\ndma_ctrl = acp_reg_read(acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\r\ndma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRun_MASK;\r\ndma_ctrl &= ~ACP_DMA_CNTL_0__DMAChIOCEn_MASK;\r\nacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\r\ndma_ch_sts = acp_reg_read(acp_mmio, mmACP_DMA_CH_STS);\r\nif (dma_ch_sts & BIT(ch_num)) {\r\ndma_ctrl |= ACP_DMA_CNTL_0__DMAChRst_MASK;\r\nacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0 + ch_num);\r\n}\r\nwhile (true) {\r\ndma_ch_sts = acp_reg_read(acp_mmio, mmACP_DMA_CH_STS);\r\nif (!(dma_ch_sts & BIT(ch_num))) {\r\ndma_ctrl &= ~ACP_DMA_CNTL_0__DMAChRst_MASK;\r\nacp_reg_write(dma_ctrl, acp_mmio, mmACP_DMA_CNTL_0\r\n+ ch_num);\r\nbreak;\r\n}\r\nif (--count == 0) {\r\npr_err("Failed to stop ACP DMA channel : %d\n", ch_num);\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic void acp_set_sram_bank_state(void __iomem *acp_mmio, u16 bank,\r\nbool power_on)\r\n{\r\nu32 val, req_reg, sts_reg, sts_reg_mask;\r\nu32 loops = 1000;\r\nif (bank < 32) {\r\nreq_reg = mmACP_MEM_SHUT_DOWN_REQ_LO;\r\nsts_reg = mmACP_MEM_SHUT_DOWN_STS_LO;\r\nsts_reg_mask = 0xFFFFFFFF;\r\n} else {\r\nbank -= 32;\r\nreq_reg = mmACP_MEM_SHUT_DOWN_REQ_HI;\r\nsts_reg = mmACP_MEM_SHUT_DOWN_STS_HI;\r\nsts_reg_mask = 0x0000FFFF;\r\n}\r\nval = acp_reg_read(acp_mmio, req_reg);\r\nif (val & (1 << bank)) {\r\nif (power_on == true)\r\nval &= ~(1 << bank);\r\nelse\r\nreturn;\r\n} else {\r\nif (power_on == false)\r\nval |= 1 << bank;\r\nelse\r\nreturn;\r\n}\r\nacp_reg_write(val, acp_mmio, req_reg);\r\nwhile (acp_reg_read(acp_mmio, sts_reg) != sts_reg_mask) {\r\nif (!loops--) {\r\npr_err("ACP SRAM bank %d state change failed\n", bank);\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic int acp_init(void __iomem *acp_mmio)\r\n{\r\nu16 bank;\r\nu32 val, count, sram_pte_offset;\r\nval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\r\nval |= ACP_SOFT_RESET__SoftResetAud_MASK;\r\nacp_reg_write(val, acp_mmio, mmACP_SOFT_RESET);\r\ncount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\r\nwhile (true) {\r\nval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\r\nif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\r\n(val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\r\nbreak;\r\nif (--count == 0) {\r\npr_err("Failed to reset ACP\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(100);\r\n}\r\nval = acp_reg_read(acp_mmio, mmACP_CONTROL);\r\nval = val | ACP_CONTROL__ClkEn_MASK;\r\nacp_reg_write(val, acp_mmio, mmACP_CONTROL);\r\ncount = ACP_CLOCK_EN_TIME_OUT_VALUE;\r\nwhile (true) {\r\nval = acp_reg_read(acp_mmio, mmACP_STATUS);\r\nif (val & (u32) 0x1)\r\nbreak;\r\nif (--count == 0) {\r\npr_err("Failed to reset ACP\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(100);\r\n}\r\nval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\r\nval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\r\nacp_reg_write(val, acp_mmio, mmACP_SOFT_RESET);\r\nacp_reg_write(ACP_ONION_CNTL_DEFAULT, acp_mmio,\r\nmmACP_AXI2DAGB_ONION_CNTL);\r\nacp_reg_write(ACP_GARLIC_CNTL_DEFAULT, acp_mmio,\r\nmmACP_AXI2DAGB_GARLIC_CNTL);\r\nsram_pte_offset = ACP_DAGB_GRP_SRAM_BASE_ADDRESS |\r\nACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBSnoopSel_MASK |\r\nACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBTargetMemSel_MASK |\r\nACP_DAGB_BASE_ADDR_GRP_1__AXI2DAGBGrpEnable_MASK;\r\nacp_reg_write(sram_pte_offset, acp_mmio, mmACP_DAGB_BASE_ADDR_GRP_1);\r\nacp_reg_write(ACP_PAGE_SIZE_4K_ENABLE, acp_mmio,\r\nmmACP_DAGB_PAGE_SIZE_GRP_1);\r\nacp_reg_write(ACP_SRAM_BASE_ADDRESS, acp_mmio,\r\nmmACP_DMA_DESC_BASE_ADDR);\r\nacp_reg_write(0x4, acp_mmio, mmACP_DMA_DESC_MAX_NUM_DSCR);\r\nacp_reg_write(ACP_EXTERNAL_INTR_CNTL__DMAIOCMask_MASK,\r\nacp_mmio, mmACP_EXTERNAL_INTR_CNTL);\r\nfor (bank = 1; bank < 48; bank++)\r\nacp_set_sram_bank_state(acp_mmio, bank, false);\r\nreturn 0;\r\n}\r\nstatic int acp_deinit(void __iomem *acp_mmio)\r\n{\r\nu32 val;\r\nu32 count;\r\nval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\r\nval |= ACP_SOFT_RESET__SoftResetAud_MASK;\r\nacp_reg_write(val, acp_mmio, mmACP_SOFT_RESET);\r\ncount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\r\nwhile (true) {\r\nval = acp_reg_read(acp_mmio, mmACP_SOFT_RESET);\r\nif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\r\n(val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\r\nbreak;\r\nif (--count == 0) {\r\npr_err("Failed to reset ACP\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(100);\r\n}\r\nval = acp_reg_read(acp_mmio, mmACP_CONTROL);\r\nval &= ~ACP_CONTROL__ClkEn_MASK;\r\nacp_reg_write(val, acp_mmio, mmACP_CONTROL);\r\ncount = ACP_CLOCK_EN_TIME_OUT_VALUE;\r\nwhile (true) {\r\nval = acp_reg_read(acp_mmio, mmACP_STATUS);\r\nif (!(val & (u32) 0x1))\r\nbreak;\r\nif (--count == 0) {\r\npr_err("Failed to reset ACP\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dma_irq_handler(int irq, void *arg)\r\n{\r\nu16 dscr_idx;\r\nu32 intr_flag, ext_intr_status;\r\nstruct audio_drv_data *irq_data;\r\nvoid __iomem *acp_mmio;\r\nstruct device *dev = arg;\r\nbool valid_irq = false;\r\nirq_data = dev_get_drvdata(dev);\r\nacp_mmio = irq_data->acp_mmio;\r\next_intr_status = acp_reg_read(acp_mmio, mmACP_EXTERNAL_INTR_STAT);\r\nintr_flag = (((ext_intr_status &\r\nACP_EXTERNAL_INTR_STAT__DMAIOCStat_MASK) >>\r\nACP_EXTERNAL_INTR_STAT__DMAIOCStat__SHIFT));\r\nif ((intr_flag & BIT(ACP_TO_I2S_DMA_CH_NUM)) != 0) {\r\nvalid_irq = true;\r\nif (acp_reg_read(acp_mmio, mmACP_DMA_CUR_DSCR_13) ==\r\nPLAYBACK_START_DMA_DESCR_CH13)\r\ndscr_idx = PLAYBACK_START_DMA_DESCR_CH12;\r\nelse\r\ndscr_idx = PLAYBACK_END_DMA_DESCR_CH12;\r\nconfig_acp_dma_channel(acp_mmio, SYSRAM_TO_ACP_CH_NUM, dscr_idx,\r\n1, 0);\r\nacp_dma_start(acp_mmio, SYSRAM_TO_ACP_CH_NUM, false);\r\nsnd_pcm_period_elapsed(irq_data->play_stream);\r\nacp_reg_write((intr_flag & BIT(ACP_TO_I2S_DMA_CH_NUM)) << 16,\r\nacp_mmio, mmACP_EXTERNAL_INTR_STAT);\r\n}\r\nif ((intr_flag & BIT(I2S_TO_ACP_DMA_CH_NUM)) != 0) {\r\nvalid_irq = true;\r\nif (acp_reg_read(acp_mmio, mmACP_DMA_CUR_DSCR_15) ==\r\nCAPTURE_START_DMA_DESCR_CH15)\r\ndscr_idx = CAPTURE_END_DMA_DESCR_CH14;\r\nelse\r\ndscr_idx = CAPTURE_START_DMA_DESCR_CH14;\r\nconfig_acp_dma_channel(acp_mmio, ACP_TO_SYSRAM_CH_NUM, dscr_idx,\r\n1, 0);\r\nacp_dma_start(acp_mmio, ACP_TO_SYSRAM_CH_NUM, false);\r\nacp_reg_write((intr_flag & BIT(I2S_TO_ACP_DMA_CH_NUM)) << 16,\r\nacp_mmio, mmACP_EXTERNAL_INTR_STAT);\r\n}\r\nif ((intr_flag & BIT(ACP_TO_SYSRAM_CH_NUM)) != 0) {\r\nvalid_irq = true;\r\nsnd_pcm_period_elapsed(irq_data->capture_stream);\r\nacp_reg_write((intr_flag & BIT(ACP_TO_SYSRAM_CH_NUM)) << 16,\r\nacp_mmio, mmACP_EXTERNAL_INTR_STAT);\r\n}\r\nif (valid_irq)\r\nreturn IRQ_HANDLED;\r\nelse\r\nreturn IRQ_NONE;\r\n}\r\nstatic int acp_dma_open(struct snd_pcm_substream *substream)\r\n{\r\nu16 bank;\r\nint ret = 0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *prtd = substream->private_data;\r\nstruct audio_drv_data *intr_data = dev_get_drvdata(prtd->platform->dev);\r\nstruct audio_substream_data *adata =\r\nkzalloc(sizeof(struct audio_substream_data), GFP_KERNEL);\r\nif (adata == NULL)\r\nreturn -ENOMEM;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nruntime->hw = acp_pcm_hardware_playback;\r\nelse\r\nruntime->hw = acp_pcm_hardware_capture;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0) {\r\ndev_err(prtd->platform->dev, "set integer constraint failed\n");\r\nkfree(adata);\r\nreturn ret;\r\n}\r\nadata->acp_mmio = intr_data->acp_mmio;\r\nruntime->private_data = adata;\r\nif (!intr_data->play_stream && !intr_data->capture_stream)\r\nacp_reg_write(1, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nintr_data->play_stream = substream;\r\nfor (bank = 1; bank <= 4; bank++)\r\nacp_set_sram_bank_state(intr_data->acp_mmio, bank,\r\ntrue);\r\n} else {\r\nintr_data->capture_stream = substream;\r\nfor (bank = 5; bank <= 8; bank++)\r\nacp_set_sram_bank_state(intr_data->acp_mmio, bank,\r\ntrue);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acp_dma_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nint status;\r\nuint64_t size;\r\nstruct snd_dma_buffer *dma_buffer;\r\nstruct page *pg;\r\nstruct snd_pcm_runtime *runtime;\r\nstruct audio_substream_data *rtd;\r\ndma_buffer = &substream->dma_buffer;\r\nruntime = substream->runtime;\r\nrtd = runtime->private_data;\r\nif (WARN_ON(!rtd))\r\nreturn -EINVAL;\r\nsize = params_buffer_bytes(params);\r\nstatus = snd_pcm_lib_malloc_pages(substream, size);\r\nif (status < 0)\r\nreturn status;\r\nmemset(substream->runtime->dma_area, 0, params_buffer_bytes(params));\r\npg = virt_to_page(substream->dma_buffer.area);\r\nif (pg != NULL) {\r\nacp_set_sram_bank_state(rtd->acp_mmio, 0, true);\r\nrtd->pg = pg;\r\nrtd->order = get_order(size);\r\nrtd->pg = pg;\r\nrtd->size = size;\r\nrtd->num_of_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nrtd->direction = substream->stream;\r\nconfig_acp_dma(rtd->acp_mmio, rtd);\r\nstatus = 0;\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nreturn status;\r\n}\r\nstatic int acp_dma_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic snd_pcm_uframes_t acp_dma_pointer(struct snd_pcm_substream *substream)\r\n{\r\nu16 dscr;\r\nu32 mul, dma_config, period_bytes;\r\nu32 pos = 0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct audio_substream_data *rtd = runtime->private_data;\r\nperiod_bytes = frames_to_bytes(runtime, runtime->period_size);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndscr = acp_reg_read(rtd->acp_mmio, mmACP_DMA_CUR_DSCR_13);\r\nif (dscr == PLAYBACK_START_DMA_DESCR_CH13)\r\nmul = 0;\r\nelse\r\nmul = 1;\r\npos = (mul * period_bytes);\r\n} else {\r\ndma_config = acp_reg_read(rtd->acp_mmio, mmACP_DMA_CNTL_14);\r\nif (dma_config != 0) {\r\ndscr = acp_reg_read(rtd->acp_mmio,\r\nmmACP_DMA_CUR_DSCR_14);\r\nif (dscr == CAPTURE_START_DMA_DESCR_CH14)\r\nmul = 1;\r\nelse\r\nmul = 2;\r\npos = (mul * period_bytes);\r\n}\r\nif (pos >= (2 * period_bytes))\r\npos = 0;\r\n}\r\nreturn bytes_to_frames(runtime, pos);\r\n}\r\nstatic int acp_dma_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nreturn snd_pcm_lib_default_mmap(substream, vma);\r\n}\r\nstatic int acp_dma_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct audio_substream_data *rtd = runtime->private_data;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nconfig_acp_dma_channel(rtd->acp_mmio, SYSRAM_TO_ACP_CH_NUM,\r\nPLAYBACK_START_DMA_DESCR_CH12,\r\nNUM_DSCRS_PER_CHANNEL, 0);\r\nconfig_acp_dma_channel(rtd->acp_mmio, ACP_TO_I2S_DMA_CH_NUM,\r\nPLAYBACK_START_DMA_DESCR_CH13,\r\nNUM_DSCRS_PER_CHANNEL, 0);\r\nacp_dma_start(rtd->acp_mmio, SYSRAM_TO_ACP_CH_NUM, false);\r\nconfig_acp_dma_channel(rtd->acp_mmio, SYSRAM_TO_ACP_CH_NUM,\r\nPLAYBACK_START_DMA_DESCR_CH12,\r\n1, 0);\r\n} else {\r\nconfig_acp_dma_channel(rtd->acp_mmio, ACP_TO_SYSRAM_CH_NUM,\r\nCAPTURE_START_DMA_DESCR_CH14,\r\nNUM_DSCRS_PER_CHANNEL, 0);\r\nconfig_acp_dma_channel(rtd->acp_mmio, I2S_TO_ACP_DMA_CH_NUM,\r\nCAPTURE_START_DMA_DESCR_CH15,\r\nNUM_DSCRS_PER_CHANNEL, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acp_dma_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nint ret;\r\nu32 loops = 1000;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *prtd = substream->private_data;\r\nstruct audio_substream_data *rtd = runtime->private_data;\r\nif (!rtd)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nacp_dma_start(rtd->acp_mmio,\r\nSYSRAM_TO_ACP_CH_NUM, false);\r\nwhile (acp_reg_read(rtd->acp_mmio, mmACP_DMA_CH_STS) &\r\nBIT(SYSRAM_TO_ACP_CH_NUM)) {\r\nif (!loops--) {\r\ndev_err(prtd->platform->dev,\r\n"acp dma start timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\nacp_dma_start(rtd->acp_mmio,\r\nACP_TO_I2S_DMA_CH_NUM, true);\r\n} else {\r\nacp_dma_start(rtd->acp_mmio,\r\nI2S_TO_ACP_DMA_CH_NUM, true);\r\n}\r\nret = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nret = acp_dma_stop(rtd->acp_mmio,\r\nACP_TO_I2S_DMA_CH_NUM);\r\nelse\r\nret = acp_dma_stop(rtd->acp_mmio,\r\nI2S_TO_ACP_DMA_CH_NUM);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int acp_dma_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nreturn snd_pcm_lib_preallocate_pages_for_all(rtd->pcm,\r\nSNDRV_DMA_TYPE_DEV,\r\nNULL, MIN_BUFFER,\r\nMAX_BUFFER);\r\n}\r\nstatic int acp_dma_close(struct snd_pcm_substream *substream)\r\n{\r\nu16 bank;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct audio_substream_data *rtd = runtime->private_data;\r\nstruct snd_soc_pcm_runtime *prtd = substream->private_data;\r\nstruct audio_drv_data *adata = dev_get_drvdata(prtd->platform->dev);\r\nkfree(rtd);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nadata->play_stream = NULL;\r\nfor (bank = 1; bank <= 4; bank++)\r\nacp_set_sram_bank_state(adata->acp_mmio, bank,\r\nfalse);\r\n} else {\r\nadata->capture_stream = NULL;\r\nfor (bank = 5; bank <= 8; bank++)\r\nacp_set_sram_bank_state(adata->acp_mmio, bank,\r\nfalse);\r\n}\r\nif (!adata->play_stream && !adata->capture_stream)\r\nacp_reg_write(0, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\r\nreturn 0;\r\n}\r\nstatic int acp_audio_probe(struct platform_device *pdev)\r\n{\r\nint status;\r\nstruct audio_drv_data *audio_drv_data;\r\nstruct resource *res;\r\naudio_drv_data = devm_kzalloc(&pdev->dev, sizeof(struct audio_drv_data),\r\nGFP_KERNEL);\r\nif (audio_drv_data == NULL)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naudio_drv_data->acp_mmio = devm_ioremap_resource(&pdev->dev, res);\r\naudio_drv_data->play_stream = NULL;\r\naudio_drv_data->capture_stream = NULL;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "IORESOURCE_IRQ FAILED\n");\r\nreturn -ENODEV;\r\n}\r\nstatus = devm_request_irq(&pdev->dev, res->start, dma_irq_handler,\r\n0, "ACP_IRQ", &pdev->dev);\r\nif (status) {\r\ndev_err(&pdev->dev, "ACP IRQ request failed\n");\r\nreturn status;\r\n}\r\ndev_set_drvdata(&pdev->dev, audio_drv_data);\r\nacp_init(audio_drv_data->acp_mmio);\r\nstatus = snd_soc_register_platform(&pdev->dev, &acp_asoc_platform);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "Fail to register ALSA platform device\n");\r\nreturn status;\r\n}\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 10000);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nreturn status;\r\n}\r\nstatic int acp_audio_remove(struct platform_device *pdev)\r\n{\r\nstruct audio_drv_data *adata = dev_get_drvdata(&pdev->dev);\r\nacp_deinit(adata->acp_mmio);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int acp_pcm_resume(struct device *dev)\r\n{\r\nu16 bank;\r\nstruct audio_drv_data *adata = dev_get_drvdata(dev);\r\nacp_init(adata->acp_mmio);\r\nif (adata->play_stream && adata->play_stream->runtime) {\r\nfor (bank = 1; bank <= 4; bank++)\r\nacp_set_sram_bank_state(adata->acp_mmio, bank,\r\ntrue);\r\nconfig_acp_dma(adata->acp_mmio,\r\nadata->play_stream->runtime->private_data);\r\n}\r\nif (adata->capture_stream && adata->capture_stream->runtime) {\r\nfor (bank = 5; bank <= 8; bank++)\r\nacp_set_sram_bank_state(adata->acp_mmio, bank,\r\ntrue);\r\nconfig_acp_dma(adata->acp_mmio,\r\nadata->capture_stream->runtime->private_data);\r\n}\r\nacp_reg_write(1, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\r\nreturn 0;\r\n}\r\nstatic int acp_pcm_runtime_suspend(struct device *dev)\r\n{\r\nstruct audio_drv_data *adata = dev_get_drvdata(dev);\r\nacp_deinit(adata->acp_mmio);\r\nacp_reg_write(0, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\r\nreturn 0;\r\n}\r\nstatic int acp_pcm_runtime_resume(struct device *dev)\r\n{\r\nstruct audio_drv_data *adata = dev_get_drvdata(dev);\r\nacp_init(adata->acp_mmio);\r\nacp_reg_write(1, adata->acp_mmio, mmACP_EXTERNAL_INTR_ENB);\r\nreturn 0;\r\n}
