static void nfp_netvf_get_mac_addr(struct nfp_net *nn)\r\n{\r\nu8 mac_addr[ETH_ALEN];\r\nput_unaligned_be32(nn_readl(nn, NFP_NET_CFG_MACADDR + 0), &mac_addr[0]);\r\nput_unaligned_be16(nn_readl(nn, NFP_NET_CFG_MACADDR + 4) >> 16,\r\n&mac_addr[4]);\r\nif (!is_valid_ether_addr(mac_addr)) {\r\neth_hw_addr_random(nn->netdev);\r\nreturn;\r\n}\r\nether_addr_copy(nn->netdev->dev_addr, mac_addr);\r\nether_addr_copy(nn->netdev->perm_addr, mac_addr);\r\n}\r\nstatic int nfp_netvf_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct nfp_net_fw_version fw_ver;\r\nint max_tx_rings, max_rx_rings;\r\nu32 tx_bar_off, rx_bar_off;\r\nu32 tx_bar_sz, rx_bar_sz;\r\nint tx_bar_no, rx_bar_no;\r\nu8 __iomem *ctrl_bar;\r\nstruct nfp_net *nn;\r\nint is_nfp3200;\r\nu32 startq;\r\nint stride;\r\nint err;\r\nerr = pci_enable_device_mem(pdev);\r\nif (err)\r\nreturn err;\r\nerr = pci_request_regions(pdev, nfp_net_driver_name);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to allocate device memory.\n");\r\ngoto err_pci_disable;\r\n}\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_NFP6000VF:\r\nis_nfp3200 = 0;\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto err_pci_regions;\r\n}\r\npci_set_master(pdev);\r\nerr = dma_set_mask_and_coherent(&pdev->dev,\r\nDMA_BIT_MASK(NFP_NET_MAX_DMA_BITS));\r\nif (err)\r\ngoto err_pci_regions;\r\nctrl_bar = ioremap_nocache(pci_resource_start(pdev, NFP_NET_CRTL_BAR),\r\nNFP_NET_CFG_BAR_SZ);\r\nif (!ctrl_bar) {\r\ndev_err(&pdev->dev,\r\n"Failed to map resource %d\n", NFP_NET_CRTL_BAR);\r\nerr = -EIO;\r\ngoto err_pci_regions;\r\n}\r\nnfp_net_get_fw_version(&fw_ver, ctrl_bar);\r\nif (fw_ver.class != NFP_NET_CFG_VERSION_CLASS_GENERIC) {\r\ndev_err(&pdev->dev, "Unknown Firmware ABI %d.%d.%d.%d\n",\r\nfw_ver.resv, fw_ver.class, fw_ver.major, fw_ver.minor);\r\nerr = -EINVAL;\r\ngoto err_ctrl_unmap;\r\n}\r\nif (nfp_net_fw_ver_eq(&fw_ver, 0, 0, 0, 0) ||\r\nnfp_net_fw_ver_eq(&fw_ver, 0, 0, 0, 1) ||\r\nnfp_net_fw_ver_eq(&fw_ver, 0, 0, 0x12, 0x48)) {\r\nstride = 2;\r\ntx_bar_no = NFP_NET_Q0_BAR;\r\nrx_bar_no = NFP_NET_Q1_BAR;\r\ndev_warn(&pdev->dev, "OBSOLETE Firmware detected - VF isolation not available\n");\r\n} else {\r\nswitch (fw_ver.major) {\r\ncase 1 ... 3:\r\nif (is_nfp3200) {\r\nstride = 2;\r\ntx_bar_no = NFP_NET_Q0_BAR;\r\nrx_bar_no = NFP_NET_Q1_BAR;\r\n} else {\r\nstride = 4;\r\ntx_bar_no = NFP_NET_Q0_BAR;\r\nrx_bar_no = tx_bar_no;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported Firmware ABI %d.%d.%d.%d\n",\r\nfw_ver.resv, fw_ver.class,\r\nfw_ver.major, fw_ver.minor);\r\nerr = -EINVAL;\r\ngoto err_ctrl_unmap;\r\n}\r\n}\r\nmax_tx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_TXRINGS);\r\nmax_rx_rings = readl(ctrl_bar + NFP_NET_CFG_MAX_RXRINGS);\r\ntx_bar_sz = NFP_QCP_QUEUE_ADDR_SZ * max_tx_rings * stride;\r\nrx_bar_sz = NFP_QCP_QUEUE_ADDR_SZ * max_rx_rings * stride;\r\nif (tx_bar_sz > pci_resource_len(pdev, tx_bar_no)) {\r\ndev_err(&pdev->dev,\r\n"TX BAR too small for number of TX rings. Adjusting\n");\r\ntx_bar_sz = pci_resource_len(pdev, tx_bar_no);\r\nmax_tx_rings = (tx_bar_sz / NFP_QCP_QUEUE_ADDR_SZ) / 2;\r\n}\r\nif (rx_bar_sz > pci_resource_len(pdev, rx_bar_no)) {\r\ndev_err(&pdev->dev,\r\n"RX BAR too small for number of RX rings. Adjusting\n");\r\nrx_bar_sz = pci_resource_len(pdev, rx_bar_no);\r\nmax_rx_rings = (rx_bar_sz / NFP_QCP_QUEUE_ADDR_SZ) / 2;\r\n}\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_NFP6000VF:\r\nstartq = readl(ctrl_bar + NFP_NET_CFG_START_TXQ);\r\ntx_bar_off = NFP_PCIE_QUEUE(startq);\r\nstartq = readl(ctrl_bar + NFP_NET_CFG_START_RXQ);\r\nrx_bar_off = NFP_PCIE_QUEUE(startq);\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\ngoto err_ctrl_unmap;\r\n}\r\nnn = nfp_net_netdev_alloc(pdev, max_tx_rings, max_rx_rings);\r\nif (IS_ERR(nn)) {\r\nerr = PTR_ERR(nn);\r\ngoto err_ctrl_unmap;\r\n}\r\nnn->fw_ver = fw_ver;\r\nnn->ctrl_bar = ctrl_bar;\r\nnn->is_vf = 1;\r\nnn->is_nfp3200 = is_nfp3200;\r\nnn->stride_tx = stride;\r\nnn->stride_rx = stride;\r\nif (rx_bar_no == tx_bar_no) {\r\nu32 bar_off, bar_sz;\r\nresource_size_t map_addr;\r\nif (tx_bar_off < rx_bar_off)\r\nbar_off = tx_bar_off;\r\nelse\r\nbar_off = rx_bar_off;\r\nif ((tx_bar_off + tx_bar_sz) > (rx_bar_off + rx_bar_sz))\r\nbar_sz = (tx_bar_off + tx_bar_sz) - bar_off;\r\nelse\r\nbar_sz = (rx_bar_off + rx_bar_sz) - bar_off;\r\nmap_addr = pci_resource_start(pdev, tx_bar_no) + bar_off;\r\nnn->q_bar = ioremap_nocache(map_addr, bar_sz);\r\nif (!nn->q_bar) {\r\nnn_err(nn, "Failed to map resource %d\n", tx_bar_no);\r\nerr = -EIO;\r\ngoto err_netdev_free;\r\n}\r\nnn->tx_bar = nn->q_bar + (tx_bar_off - bar_off);\r\nnn->rx_bar = nn->q_bar + (rx_bar_off - bar_off);\r\n} else {\r\nresource_size_t map_addr;\r\nmap_addr = pci_resource_start(pdev, tx_bar_no) + tx_bar_off;\r\nnn->tx_bar = ioremap_nocache(map_addr, tx_bar_sz);\r\nif (!nn->tx_bar) {\r\nnn_err(nn, "Failed to map resource %d\n", tx_bar_no);\r\nerr = -EIO;\r\ngoto err_netdev_free;\r\n}\r\nmap_addr = pci_resource_start(pdev, rx_bar_no) + rx_bar_off;\r\nnn->rx_bar = ioremap_nocache(map_addr, rx_bar_sz);\r\nif (!nn->rx_bar) {\r\nnn_err(nn, "Failed to map resource %d\n", rx_bar_no);\r\nerr = -EIO;\r\ngoto err_unmap_tx;\r\n}\r\n}\r\nnfp_netvf_get_mac_addr(nn);\r\nerr = nfp_net_irqs_alloc(nn);\r\nif (!err) {\r\nnn_warn(nn, "Unable to allocate MSI-X Vectors. Exiting\n");\r\nerr = -EIO;\r\ngoto err_unmap_rx;\r\n}\r\nnn->me_freq_mhz = 1200;\r\nerr = nfp_net_netdev_init(nn->netdev);\r\nif (err)\r\ngoto err_irqs_disable;\r\npci_set_drvdata(pdev, nn);\r\nnfp_net_info(nn);\r\nnfp_net_debugfs_adapter_add(nn);\r\nreturn 0;\r\nerr_irqs_disable:\r\nnfp_net_irqs_disable(nn);\r\nerr_unmap_rx:\r\nif (!nn->q_bar)\r\niounmap(nn->rx_bar);\r\nerr_unmap_tx:\r\nif (!nn->q_bar)\r\niounmap(nn->tx_bar);\r\nelse\r\niounmap(nn->q_bar);\r\nerr_netdev_free:\r\npci_set_drvdata(pdev, NULL);\r\nnfp_net_netdev_free(nn);\r\nerr_ctrl_unmap:\r\niounmap(ctrl_bar);\r\nerr_pci_regions:\r\npci_release_regions(pdev);\r\nerr_pci_disable:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void nfp_netvf_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct nfp_net *nn = pci_get_drvdata(pdev);\r\nnfp_net_debugfs_adapter_del(nn);\r\nnfp_net_netdev_clean(nn->netdev);\r\nnfp_net_irqs_disable(nn);\r\nif (!nn->q_bar) {\r\niounmap(nn->rx_bar);\r\niounmap(nn->tx_bar);\r\n} else {\r\niounmap(nn->q_bar);\r\n}\r\niounmap(nn->ctrl_bar);\r\npci_set_drvdata(pdev, NULL);\r\nnfp_net_netdev_free(nn);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init nfp_netvf_init(void)\r\n{\r\nint err;\r\npr_info("%s: NFP VF Network driver, Copyright (C) 2014-2015 Netronome Systems\n",\r\nnfp_net_driver_name);\r\nnfp_net_debugfs_create();\r\nerr = pci_register_driver(&nfp_netvf_pci_driver);\r\nif (err) {\r\nnfp_net_debugfs_destroy();\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit nfp_netvf_exit(void)\r\n{\r\npci_unregister_driver(&nfp_netvf_pci_driver);\r\nnfp_net_debugfs_destroy();\r\n}
