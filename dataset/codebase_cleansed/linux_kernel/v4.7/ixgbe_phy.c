static s32 ixgbe_out_i2c_byte_ack(struct ixgbe_hw *hw, u8 byte)\r\n{\r\ns32 status;\r\nstatus = ixgbe_clock_out_i2c_byte(hw, byte);\r\nif (status)\r\nreturn status;\r\nreturn ixgbe_get_i2c_ack(hw);\r\n}\r\nstatic s32 ixgbe_in_i2c_byte_ack(struct ixgbe_hw *hw, u8 *byte)\r\n{\r\ns32 status;\r\nstatus = ixgbe_clock_in_i2c_byte(hw, byte);\r\nif (status)\r\nreturn status;\r\nreturn ixgbe_clock_out_i2c_bit(hw, false);\r\n}\r\nstatic u8 ixgbe_ones_comp_byte_add(u8 add1, u8 add2)\r\n{\r\nu16 sum = add1 + add2;\r\nsum = (sum & 0xFF) + (sum >> 8);\r\nreturn sum & 0xFF;\r\n}\r\nstatic s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,\r\nu16 reg, u16 *val, bool lock)\r\n{\r\nu32 swfw_mask = hw->phy.phy_semaphore_mask;\r\nint max_retry = 10;\r\nint retry = 0;\r\nu8 csum_byte;\r\nu8 high_bits;\r\nu8 low_bits;\r\nu8 reg_high;\r\nu8 csum;\r\nreg_high = ((reg >> 7) & 0xFE) | 1;\r\ncsum = ixgbe_ones_comp_byte_add(reg_high, reg & 0xFF);\r\ncsum = ~csum;\r\ndo {\r\nif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nixgbe_i2c_start(hw);\r\nif (ixgbe_out_i2c_byte_ack(hw, addr))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, reg_high))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, reg & 0xFF))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, csum))\r\ngoto fail;\r\nixgbe_i2c_start(hw);\r\nif (ixgbe_out_i2c_byte_ack(hw, addr | 1))\r\ngoto fail;\r\nif (ixgbe_in_i2c_byte_ack(hw, &high_bits))\r\ngoto fail;\r\nif (ixgbe_in_i2c_byte_ack(hw, &low_bits))\r\ngoto fail;\r\nif (ixgbe_clock_in_i2c_byte(hw, &csum_byte))\r\ngoto fail;\r\nif (ixgbe_clock_out_i2c_bit(hw, false))\r\ngoto fail;\r\nixgbe_i2c_stop(hw);\r\nif (lock)\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\n*val = (high_bits << 8) | low_bits;\r\nreturn 0;\r\nfail:\r\nixgbe_i2c_bus_clear(hw);\r\nif (lock)\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\nretry++;\r\nif (retry < max_retry)\r\nhw_dbg(hw, "I2C byte read combined error - Retry.\n");\r\nelse\r\nhw_dbg(hw, "I2C byte read combined error.\n");\r\n} while (retry < max_retry);\r\nreturn IXGBE_ERR_I2C;\r\n}\r\ns32 ixgbe_read_i2c_combined_generic(struct ixgbe_hw *hw, u8 addr,\r\nu16 reg, u16 *val)\r\n{\r\nreturn ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, true);\r\n}\r\ns32 ixgbe_read_i2c_combined_generic_unlocked(struct ixgbe_hw *hw, u8 addr,\r\nu16 reg, u16 *val)\r\n{\r\nreturn ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, false);\r\n}\r\nstatic s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,\r\nu16 reg, u16 val, bool lock)\r\n{\r\nu32 swfw_mask = hw->phy.phy_semaphore_mask;\r\nint max_retry = 1;\r\nint retry = 0;\r\nu8 reg_high;\r\nu8 csum;\r\nreg_high = (reg >> 7) & 0xFE;\r\ncsum = ixgbe_ones_comp_byte_add(reg_high, reg & 0xFF);\r\ncsum = ixgbe_ones_comp_byte_add(csum, val >> 8);\r\ncsum = ixgbe_ones_comp_byte_add(csum, val & 0xFF);\r\ncsum = ~csum;\r\ndo {\r\nif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nixgbe_i2c_start(hw);\r\nif (ixgbe_out_i2c_byte_ack(hw, addr))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, reg_high))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, reg & 0xFF))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, val >> 8))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, val & 0xFF))\r\ngoto fail;\r\nif (ixgbe_out_i2c_byte_ack(hw, csum))\r\ngoto fail;\r\nixgbe_i2c_stop(hw);\r\nif (lock)\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\nreturn 0;\r\nfail:\r\nixgbe_i2c_bus_clear(hw);\r\nif (lock)\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\nretry++;\r\nif (retry < max_retry)\r\nhw_dbg(hw, "I2C byte write combined error - Retry.\n");\r\nelse\r\nhw_dbg(hw, "I2C byte write combined error.\n");\r\n} while (retry < max_retry);\r\nreturn IXGBE_ERR_I2C;\r\n}\r\ns32 ixgbe_write_i2c_combined_generic(struct ixgbe_hw *hw,\r\nu8 addr, u16 reg, u16 val)\r\n{\r\nreturn ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, true);\r\n}\r\ns32 ixgbe_write_i2c_combined_generic_unlocked(struct ixgbe_hw *hw,\r\nu8 addr, u16 reg, u16 val)\r\n{\r\nreturn ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, false);\r\n}\r\ns32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 phy_addr;\r\nu16 ext_ability = 0;\r\nif (!hw->phy.phy_semaphore_mask) {\r\nif (hw->bus.lan_id)\r\nhw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;\r\nelse\r\nhw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;\r\n}\r\nif (hw->phy.type == ixgbe_phy_unknown) {\r\nfor (phy_addr = 0; phy_addr < IXGBE_MAX_PHY_ADDR; phy_addr++) {\r\nhw->phy.mdio.prtad = phy_addr;\r\nif (mdio45_probe(&hw->phy.mdio, phy_addr) == 0) {\r\nixgbe_get_phy_id(hw);\r\nhw->phy.type =\r\nixgbe_get_phy_type_from_id(hw->phy.id);\r\nif (hw->phy.type == ixgbe_phy_unknown) {\r\nhw->phy.ops.read_reg(hw,\r\nMDIO_PMA_EXTABLE,\r\nMDIO_MMD_PMAPMD,\r\n&ext_ability);\r\nif (ext_ability &\r\n(MDIO_PMA_EXTABLE_10GBT |\r\nMDIO_PMA_EXTABLE_1000BT))\r\nhw->phy.type =\r\nixgbe_phy_cu_unknown;\r\nelse\r\nhw->phy.type =\r\nixgbe_phy_generic;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nhw->phy.mdio.prtad = 0;\r\nreturn IXGBE_ERR_PHY_ADDR_INVALID;\r\n}\r\nreturn 0;\r\n}\r\nbool ixgbe_check_reset_blocked(struct ixgbe_hw *hw)\r\n{\r\nu32 mmngc;\r\nif (hw->mac.type == ixgbe_mac_82598EB)\r\nreturn false;\r\nmmngc = IXGBE_READ_REG(hw, IXGBE_MMNGC);\r\nif (mmngc & IXGBE_MMNGC_MNG_VETO) {\r\nhw_dbg(hw, "MNG_VETO bit detected.\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic s32 ixgbe_get_phy_id(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu16 phy_id_high = 0;\r\nu16 phy_id_low = 0;\r\nstatus = hw->phy.ops.read_reg(hw, MDIO_DEVID1, MDIO_MMD_PMAPMD,\r\n&phy_id_high);\r\nif (!status) {\r\nhw->phy.id = (u32)(phy_id_high << 16);\r\nstatus = hw->phy.ops.read_reg(hw, MDIO_DEVID2, MDIO_MMD_PMAPMD,\r\n&phy_id_low);\r\nhw->phy.id |= (u32)(phy_id_low & IXGBE_PHY_REVISION_MASK);\r\nhw->phy.revision = (u32)(phy_id_low & ~IXGBE_PHY_REVISION_MASK);\r\n}\r\nreturn status;\r\n}\r\nstatic enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id)\r\n{\r\nenum ixgbe_phy_type phy_type;\r\nswitch (phy_id) {\r\ncase TN1010_PHY_ID:\r\nphy_type = ixgbe_phy_tn;\r\nbreak;\r\ncase X550_PHY_ID:\r\ncase X540_PHY_ID:\r\nphy_type = ixgbe_phy_aq;\r\nbreak;\r\ncase QT2022_PHY_ID:\r\nphy_type = ixgbe_phy_qt;\r\nbreak;\r\ncase ATH_PHY_ID:\r\nphy_type = ixgbe_phy_nl;\r\nbreak;\r\ncase X557_PHY_ID:\r\nphy_type = ixgbe_phy_x550em_ext_t;\r\nbreak;\r\ndefault:\r\nphy_type = ixgbe_phy_unknown;\r\nbreak;\r\n}\r\nreturn phy_type;\r\n}\r\ns32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)\r\n{\r\nu32 i;\r\nu16 ctrl = 0;\r\ns32 status = 0;\r\nif (hw->phy.type == ixgbe_phy_unknown)\r\nstatus = ixgbe_identify_phy_generic(hw);\r\nif (status != 0 || hw->phy.type == ixgbe_phy_none)\r\nreturn status;\r\nif (!hw->phy.reset_if_overtemp &&\r\n(IXGBE_ERR_OVERTEMP == hw->phy.ops.check_overtemp(hw)))\r\nreturn 0;\r\nif (ixgbe_check_reset_blocked(hw))\r\nreturn 0;\r\nhw->phy.ops.write_reg(hw, MDIO_CTRL1,\r\nMDIO_MMD_PHYXS,\r\nMDIO_CTRL1_RESET);\r\nfor (i = 0; i < 30; i++) {\r\nmsleep(100);\r\nhw->phy.ops.read_reg(hw, MDIO_CTRL1,\r\nMDIO_MMD_PHYXS, &ctrl);\r\nif (!(ctrl & MDIO_CTRL1_RESET)) {\r\nudelay(2);\r\nbreak;\r\n}\r\n}\r\nif (ctrl & MDIO_CTRL1_RESET) {\r\nhw_dbg(hw, "PHY reset polling failed to complete.\n");\r\nreturn IXGBE_ERR_RESET_FAILED;\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,\r\nu16 *phy_data)\r\n{\r\nu32 i, data, command;\r\ncommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT) |\r\n(device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\r\n(hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\r\n(IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND));\r\nIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\r\nfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\r\nudelay(10);\r\ncommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\r\nbreak;\r\n}\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\r\nhw_dbg(hw, "PHY address command did not complete.\n");\r\nreturn IXGBE_ERR_PHY;\r\n}\r\ncommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT) |\r\n(device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\r\n(hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\r\n(IXGBE_MSCA_READ | IXGBE_MSCA_MDI_COMMAND));\r\nIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\r\nfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\r\nudelay(10);\r\ncommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\r\nbreak;\r\n}\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\r\nhw_dbg(hw, "PHY read command didn't complete\n");\r\nreturn IXGBE_ERR_PHY;\r\n}\r\ndata = IXGBE_READ_REG(hw, IXGBE_MSRWD);\r\ndata >>= IXGBE_MSRWD_READ_DATA_SHIFT;\r\n*phy_data = (u16)(data);\r\nreturn 0;\r\n}\r\ns32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,\r\nu32 device_type, u16 *phy_data)\r\n{\r\ns32 status;\r\nu32 gssr = hw->phy.phy_semaphore_mask;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, gssr) == 0) {\r\nstatus = ixgbe_read_phy_reg_mdi(hw, reg_addr, device_type,\r\nphy_data);\r\nhw->mac.ops.release_swfw_sync(hw, gssr);\r\n} else {\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\n}\r\nreturn status;\r\n}\r\ns32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,\r\nu32 device_type, u16 phy_data)\r\n{\r\nu32 i, command;\r\nIXGBE_WRITE_REG(hw, IXGBE_MSRWD, (u32)phy_data);\r\ncommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT) |\r\n(device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\r\n(hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\r\n(IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND));\r\nIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\r\nfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\r\nudelay(10);\r\ncommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\r\nbreak;\r\n}\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\r\nhw_dbg(hw, "PHY address cmd didn't complete\n");\r\nreturn IXGBE_ERR_PHY;\r\n}\r\ncommand = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT) |\r\n(device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |\r\n(hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |\r\n(IXGBE_MSCA_WRITE | IXGBE_MSCA_MDI_COMMAND));\r\nIXGBE_WRITE_REG(hw, IXGBE_MSCA, command);\r\nfor (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {\r\nudelay(10);\r\ncommand = IXGBE_READ_REG(hw, IXGBE_MSCA);\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) == 0)\r\nbreak;\r\n}\r\nif ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {\r\nhw_dbg(hw, "PHY write cmd didn't complete\n");\r\nreturn IXGBE_ERR_PHY;\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,\r\nu32 device_type, u16 phy_data)\r\n{\r\ns32 status;\r\nu32 gssr = hw->phy.phy_semaphore_mask;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, gssr) == 0) {\r\nstatus = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type,\r\nphy_data);\r\nhw->mac.ops.release_swfw_sync(hw, gssr);\r\n} else {\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\n}\r\nreturn status;\r\n}\r\ns32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw)\r\n{\r\ns32 status = 0;\r\nu16 autoneg_reg = IXGBE_MII_AUTONEG_REG;\r\nbool autoneg = false;\r\nixgbe_link_speed speed;\r\nixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL) {\r\nhw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL,\r\nMDIO_MMD_AN,\r\n&autoneg_reg);\r\nautoneg_reg &= ~MDIO_AN_10GBT_CTRL_ADV10G;\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL)\r\nautoneg_reg |= MDIO_AN_10GBT_CTRL_ADV10G;\r\nhw->phy.ops.write_reg(hw, MDIO_AN_10GBT_CTRL,\r\nMDIO_MMD_AN,\r\nautoneg_reg);\r\n}\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL) {\r\nhw->phy.ops.read_reg(hw,\r\nIXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,\r\nMDIO_MMD_AN,\r\n&autoneg_reg);\r\nautoneg_reg &= ~IXGBE_MII_1GBASE_T_ADVERTISE;\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_1GB_FULL)\r\nautoneg_reg |= IXGBE_MII_1GBASE_T_ADVERTISE;\r\nhw->phy.ops.write_reg(hw,\r\nIXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,\r\nMDIO_MMD_AN,\r\nautoneg_reg);\r\n}\r\nif (speed & IXGBE_LINK_SPEED_100_FULL) {\r\nhw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,\r\nMDIO_MMD_AN,\r\n&autoneg_reg);\r\nautoneg_reg &= ~(ADVERTISE_100FULL |\r\nADVERTISE_100HALF);\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL)\r\nautoneg_reg |= ADVERTISE_100FULL;\r\nhw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE,\r\nMDIO_MMD_AN,\r\nautoneg_reg);\r\n}\r\nif (ixgbe_check_reset_blocked(hw))\r\nreturn 0;\r\nhw->phy.ops.read_reg(hw, MDIO_CTRL1,\r\nMDIO_MMD_AN, &autoneg_reg);\r\nautoneg_reg |= MDIO_AN_CTRL1_RESTART;\r\nhw->phy.ops.write_reg(hw, MDIO_CTRL1,\r\nMDIO_MMD_AN, autoneg_reg);\r\nreturn status;\r\n}\r\ns32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\nhw->phy.autoneg_advertised = 0;\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;\r\nif (speed & IXGBE_LINK_SPEED_100_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_100_FULL;\r\nhw->phy.ops.setup_link(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_get_copper_speeds_supported(struct ixgbe_hw *hw)\r\n{\r\nu16 speed_ability;\r\ns32 status;\r\nstatus = hw->phy.ops.read_reg(hw, MDIO_SPEED, MDIO_MMD_PMAPMD,\r\n&speed_ability);\r\nif (status)\r\nreturn status;\r\nif (speed_ability & MDIO_SPEED_10G)\r\nhw->phy.speeds_supported |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (speed_ability & MDIO_PMA_SPEED_1000)\r\nhw->phy.speeds_supported |= IXGBE_LINK_SPEED_1GB_FULL;\r\nif (speed_ability & MDIO_PMA_SPEED_100)\r\nhw->phy.speeds_supported |= IXGBE_LINK_SPEED_100_FULL;\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X550:\r\nhw->phy.speeds_supported |= IXGBE_LINK_SPEED_2_5GB_FULL;\r\nhw->phy.speeds_supported |= IXGBE_LINK_SPEED_5GB_FULL;\r\nbreak;\r\ncase ixgbe_mac_X550EM_x:\r\nhw->phy.speeds_supported &= ~IXGBE_LINK_SPEED_100_FULL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,\r\nixgbe_link_speed *speed,\r\nbool *autoneg)\r\n{\r\ns32 status = 0;\r\n*autoneg = true;\r\nif (!hw->phy.speeds_supported)\r\nstatus = ixgbe_get_copper_speeds_supported(hw);\r\n*speed = hw->phy.speeds_supported;\r\nreturn status;\r\n}\r\ns32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed,\r\nbool *link_up)\r\n{\r\ns32 status;\r\nu32 time_out;\r\nu32 max_time_out = 10;\r\nu16 phy_link = 0;\r\nu16 phy_speed = 0;\r\nu16 phy_data = 0;\r\n*link_up = false;\r\n*speed = IXGBE_LINK_SPEED_10GB_FULL;\r\nfor (time_out = 0; time_out < max_time_out; time_out++) {\r\nudelay(10);\r\nstatus = hw->phy.ops.read_reg(hw,\r\nMDIO_STAT1,\r\nMDIO_MMD_VEND1,\r\n&phy_data);\r\nphy_link = phy_data &\r\nIXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS;\r\nphy_speed = phy_data &\r\nIXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS;\r\nif (phy_link == IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS) {\r\n*link_up = true;\r\nif (phy_speed ==\r\nIXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS)\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\ns32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)\r\n{\r\nu16 autoneg_reg = IXGBE_MII_AUTONEG_REG;\r\nbool autoneg = false;\r\nixgbe_link_speed speed;\r\nixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL) {\r\nhw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL,\r\nMDIO_MMD_AN,\r\n&autoneg_reg);\r\nautoneg_reg &= ~MDIO_AN_10GBT_CTRL_ADV10G;\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL)\r\nautoneg_reg |= MDIO_AN_10GBT_CTRL_ADV10G;\r\nhw->phy.ops.write_reg(hw, MDIO_AN_10GBT_CTRL,\r\nMDIO_MMD_AN,\r\nautoneg_reg);\r\n}\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL) {\r\nhw->phy.ops.read_reg(hw, IXGBE_MII_AUTONEG_XNP_TX_REG,\r\nMDIO_MMD_AN,\r\n&autoneg_reg);\r\nautoneg_reg &= ~IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX;\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_1GB_FULL)\r\nautoneg_reg |= IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX;\r\nhw->phy.ops.write_reg(hw, IXGBE_MII_AUTONEG_XNP_TX_REG,\r\nMDIO_MMD_AN,\r\nautoneg_reg);\r\n}\r\nif (speed & IXGBE_LINK_SPEED_100_FULL) {\r\nhw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,\r\nMDIO_MMD_AN,\r\n&autoneg_reg);\r\nautoneg_reg &= ~(ADVERTISE_100FULL |\r\nADVERTISE_100HALF);\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL)\r\nautoneg_reg |= ADVERTISE_100FULL;\r\nhw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE,\r\nMDIO_MMD_AN,\r\nautoneg_reg);\r\n}\r\nif (ixgbe_check_reset_blocked(hw))\r\nreturn 0;\r\nhw->phy.ops.read_reg(hw, MDIO_CTRL1,\r\nMDIO_MMD_AN, &autoneg_reg);\r\nautoneg_reg |= MDIO_AN_CTRL1_RESTART;\r\nhw->phy.ops.write_reg(hw, MDIO_CTRL1,\r\nMDIO_MMD_AN, autoneg_reg);\r\nreturn 0;\r\n}\r\ns32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw,\r\nu16 *firmware_version)\r\n{\r\ns32 status;\r\nstatus = hw->phy.ops.read_reg(hw, TNX_FW_REV,\r\nMDIO_MMD_VEND1,\r\nfirmware_version);\r\nreturn status;\r\n}\r\ns32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw,\r\nu16 *firmware_version)\r\n{\r\ns32 status;\r\nstatus = hw->phy.ops.read_reg(hw, AQ_FW_REV,\r\nMDIO_MMD_VEND1,\r\nfirmware_version);\r\nreturn status;\r\n}\r\ns32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)\r\n{\r\nu16 phy_offset, control, eword, edata, block_crc;\r\nbool end_data = false;\r\nu16 list_offset, data_offset;\r\nu16 phy_data = 0;\r\ns32 ret_val;\r\nu32 i;\r\nif (ixgbe_check_reset_blocked(hw))\r\nreturn 0;\r\nhw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS, &phy_data);\r\nhw->phy.ops.write_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS,\r\n(phy_data | MDIO_CTRL1_RESET));\r\nfor (i = 0; i < 100; i++) {\r\nhw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS,\r\n&phy_data);\r\nif ((phy_data & MDIO_CTRL1_RESET) == 0)\r\nbreak;\r\nusleep_range(10000, 20000);\r\n}\r\nif ((phy_data & MDIO_CTRL1_RESET) != 0) {\r\nhw_dbg(hw, "PHY reset did not complete.\n");\r\nreturn IXGBE_ERR_PHY;\r\n}\r\nret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,\r\n&data_offset);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = hw->eeprom.ops.read(hw, data_offset, &block_crc);\r\ndata_offset++;\r\nwhile (!end_data) {\r\nret_val = hw->eeprom.ops.read(hw, data_offset, &eword);\r\nif (ret_val)\r\ngoto err_eeprom;\r\ncontrol = (eword & IXGBE_CONTROL_MASK_NL) >>\r\nIXGBE_CONTROL_SHIFT_NL;\r\nedata = eword & IXGBE_DATA_MASK_NL;\r\nswitch (control) {\r\ncase IXGBE_DELAY_NL:\r\ndata_offset++;\r\nhw_dbg(hw, "DELAY: %d MS\n", edata);\r\nusleep_range(edata * 1000, edata * 2000);\r\nbreak;\r\ncase IXGBE_DATA_NL:\r\nhw_dbg(hw, "DATA:\n");\r\ndata_offset++;\r\nret_val = hw->eeprom.ops.read(hw, data_offset++,\r\n&phy_offset);\r\nif (ret_val)\r\ngoto err_eeprom;\r\nfor (i = 0; i < edata; i++) {\r\nret_val = hw->eeprom.ops.read(hw, data_offset,\r\n&eword);\r\nif (ret_val)\r\ngoto err_eeprom;\r\nhw->phy.ops.write_reg(hw, phy_offset,\r\nMDIO_MMD_PMAPMD, eword);\r\nhw_dbg(hw, "Wrote %4.4x to %4.4x\n", eword,\r\nphy_offset);\r\ndata_offset++;\r\nphy_offset++;\r\n}\r\nbreak;\r\ncase IXGBE_CONTROL_NL:\r\ndata_offset++;\r\nhw_dbg(hw, "CONTROL:\n");\r\nif (edata == IXGBE_CONTROL_EOL_NL) {\r\nhw_dbg(hw, "EOL\n");\r\nend_data = true;\r\n} else if (edata == IXGBE_CONTROL_SOL_NL) {\r\nhw_dbg(hw, "SOL\n");\r\n} else {\r\nhw_dbg(hw, "Bad control value\n");\r\nreturn IXGBE_ERR_PHY;\r\n}\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Bad control type\n");\r\nreturn IXGBE_ERR_PHY;\r\n}\r\n}\r\nreturn ret_val;\r\nerr_eeprom:\r\nhw_err(hw, "eeprom read at offset %d failed\n", data_offset);\r\nreturn IXGBE_ERR_PHY;\r\n}\r\ns32 ixgbe_identify_module_generic(struct ixgbe_hw *hw)\r\n{\r\nswitch (hw->mac.ops.get_media_type(hw)) {\r\ncase ixgbe_media_type_fiber:\r\nreturn ixgbe_identify_sfp_module_generic(hw);\r\ncase ixgbe_media_type_fiber_qsfp:\r\nreturn ixgbe_identify_qsfp_module_generic(hw);\r\ndefault:\r\nhw->phy.sfp_type = ixgbe_sfp_type_not_present;\r\nreturn IXGBE_ERR_SFP_NOT_PRESENT;\r\n}\r\nreturn IXGBE_ERR_SFP_NOT_PRESENT;\r\n}\r\ns32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_adapter *adapter = hw->back;\r\ns32 status;\r\nu32 vendor_oui = 0;\r\nenum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;\r\nu8 identifier = 0;\r\nu8 comp_codes_1g = 0;\r\nu8 comp_codes_10g = 0;\r\nu8 oui_bytes[3] = {0, 0, 0};\r\nu8 cable_tech = 0;\r\nu8 cable_spec = 0;\r\nu16 enforce_sfp = 0;\r\nif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber) {\r\nhw->phy.sfp_type = ixgbe_sfp_type_not_present;\r\nreturn IXGBE_ERR_SFP_NOT_PRESENT;\r\n}\r\nhw->mac.ops.set_lan_id(hw);\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_IDENTIFIER,\r\n&identifier);\r\nif (status)\r\ngoto err_read_i2c_eeprom;\r\nif (identifier != IXGBE_SFF_IDENTIFIER_SFP) {\r\nhw->phy.type = ixgbe_phy_sfp_unsupported;\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n}\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_1GBE_COMP_CODES,\r\n&comp_codes_1g);\r\nif (status)\r\ngoto err_read_i2c_eeprom;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_10GBE_COMP_CODES,\r\n&comp_codes_10g);\r\nif (status)\r\ngoto err_read_i2c_eeprom;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_CABLE_TECHNOLOGY,\r\n&cable_tech);\r\nif (status)\r\ngoto err_read_i2c_eeprom;\r\nif (hw->mac.type == ixgbe_mac_82598EB) {\r\nif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)\r\nhw->phy.sfp_type = ixgbe_sfp_type_da_cu;\r\nelse if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)\r\nhw->phy.sfp_type = ixgbe_sfp_type_sr;\r\nelse if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)\r\nhw->phy.sfp_type = ixgbe_sfp_type_lr;\r\nelse\r\nhw->phy.sfp_type = ixgbe_sfp_type_unknown;\r\n} else {\r\nif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_da_cu_core0;\r\nelse\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_da_cu_core1;\r\n} else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE) {\r\nhw->phy.ops.read_i2c_eeprom(\r\nhw, IXGBE_SFF_CABLE_SPEC_COMP,\r\n&cable_spec);\r\nif (cable_spec &\r\nIXGBE_SFF_DA_SPEC_ACTIVE_LIMITING) {\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_da_act_lmt_core0;\r\nelse\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_da_act_lmt_core1;\r\n} else {\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_unknown;\r\n}\r\n} else if (comp_codes_10g &\r\n(IXGBE_SFF_10GBASESR_CAPABLE |\r\nIXGBE_SFF_10GBASELR_CAPABLE)) {\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_srlr_core0;\r\nelse\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_srlr_core1;\r\n} else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE) {\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_1g_cu_core0;\r\nelse\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_1g_cu_core1;\r\n} else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) {\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_1g_sx_core0;\r\nelse\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_1g_sx_core1;\r\n} else if (comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) {\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_1g_lx_core0;\r\nelse\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_1g_lx_core1;\r\n} else {\r\nhw->phy.sfp_type = ixgbe_sfp_type_unknown;\r\n}\r\n}\r\nif (hw->phy.sfp_type != stored_sfp_type)\r\nhw->phy.sfp_setup_needed = true;\r\nhw->phy.multispeed_fiber = false;\r\nif (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&\r\n(comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||\r\n((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&\r\n(comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))\r\nhw->phy.multispeed_fiber = true;\r\nif (hw->phy.type != ixgbe_phy_nl) {\r\nhw->phy.id = identifier;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_VENDOR_OUI_BYTE0,\r\n&oui_bytes[0]);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_VENDOR_OUI_BYTE1,\r\n&oui_bytes[1]);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_VENDOR_OUI_BYTE2,\r\n&oui_bytes[2]);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nvendor_oui =\r\n((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |\r\n(oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |\r\n(oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));\r\nswitch (vendor_oui) {\r\ncase IXGBE_SFF_VENDOR_OUI_TYCO:\r\nif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)\r\nhw->phy.type =\r\nixgbe_phy_sfp_passive_tyco;\r\nbreak;\r\ncase IXGBE_SFF_VENDOR_OUI_FTL:\r\nif (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)\r\nhw->phy.type = ixgbe_phy_sfp_ftl_active;\r\nelse\r\nhw->phy.type = ixgbe_phy_sfp_ftl;\r\nbreak;\r\ncase IXGBE_SFF_VENDOR_OUI_AVAGO:\r\nhw->phy.type = ixgbe_phy_sfp_avago;\r\nbreak;\r\ncase IXGBE_SFF_VENDOR_OUI_INTEL:\r\nhw->phy.type = ixgbe_phy_sfp_intel;\r\nbreak;\r\ndefault:\r\nif (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)\r\nhw->phy.type =\r\nixgbe_phy_sfp_passive_unknown;\r\nelse if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)\r\nhw->phy.type =\r\nixgbe_phy_sfp_active_unknown;\r\nelse\r\nhw->phy.type = ixgbe_phy_sfp_unknown;\r\nbreak;\r\n}\r\n}\r\nif (cable_tech & (IXGBE_SFF_DA_PASSIVE_CABLE |\r\nIXGBE_SFF_DA_ACTIVE_CABLE))\r\nreturn 0;\r\nif (comp_codes_10g == 0 &&\r\n!(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {\r\nhw->phy.type = ixgbe_phy_sfp_unsupported;\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n}\r\nif (hw->mac.type == ixgbe_mac_82598EB)\r\nreturn 0;\r\nhw->mac.ops.get_device_caps(hw, &enforce_sfp);\r\nif (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP) &&\r\n!(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {\r\nif (hw->phy.type == ixgbe_phy_sfp_intel)\r\nreturn 0;\r\nif (hw->allow_unsupported_sfp) {\r\ne_warn(drv, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");\r\nreturn 0;\r\n}\r\nhw_dbg(hw, "SFP+ module not supported\n");\r\nhw->phy.type = ixgbe_phy_sfp_unsupported;\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n}\r\nreturn 0;\r\nerr_read_i2c_eeprom:\r\nhw->phy.sfp_type = ixgbe_sfp_type_not_present;\r\nif (hw->phy.type != ixgbe_phy_nl) {\r\nhw->phy.id = 0;\r\nhw->phy.type = ixgbe_phy_unknown;\r\n}\r\nreturn IXGBE_ERR_SFP_NOT_PRESENT;\r\n}\r\nstatic s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_adapter *adapter = hw->back;\r\ns32 status;\r\nu32 vendor_oui = 0;\r\nenum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;\r\nu8 identifier = 0;\r\nu8 comp_codes_1g = 0;\r\nu8 comp_codes_10g = 0;\r\nu8 oui_bytes[3] = {0, 0, 0};\r\nu16 enforce_sfp = 0;\r\nu8 connector = 0;\r\nu8 cable_length = 0;\r\nu8 device_tech = 0;\r\nbool active_cable = false;\r\nif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber_qsfp) {\r\nhw->phy.sfp_type = ixgbe_sfp_type_not_present;\r\nreturn IXGBE_ERR_SFP_NOT_PRESENT;\r\n}\r\nhw->mac.ops.set_lan_id(hw);\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_IDENTIFIER,\r\n&identifier);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nif (identifier != IXGBE_SFF_IDENTIFIER_QSFP_PLUS) {\r\nhw->phy.type = ixgbe_phy_sfp_unsupported;\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n}\r\nhw->phy.id = identifier;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_QSFP_10GBE_COMP,\r\n&comp_codes_10g);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_QSFP_1GBE_COMP,\r\n&comp_codes_1g);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nif (comp_codes_10g & IXGBE_SFF_QSFP_DA_PASSIVE_CABLE) {\r\nhw->phy.type = ixgbe_phy_qsfp_passive_unknown;\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type = ixgbe_sfp_type_da_cu_core0;\r\nelse\r\nhw->phy.sfp_type = ixgbe_sfp_type_da_cu_core1;\r\n} else if (comp_codes_10g & (IXGBE_SFF_10GBASESR_CAPABLE |\r\nIXGBE_SFF_10GBASELR_CAPABLE)) {\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type = ixgbe_sfp_type_srlr_core0;\r\nelse\r\nhw->phy.sfp_type = ixgbe_sfp_type_srlr_core1;\r\n} else {\r\nif (comp_codes_10g & IXGBE_SFF_QSFP_DA_ACTIVE_CABLE)\r\nactive_cable = true;\r\nif (!active_cable) {\r\nhw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_QSFP_CONNECTOR,\r\n&connector);\r\nhw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_QSFP_CABLE_LENGTH,\r\n&cable_length);\r\nhw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_QSFP_DEVICE_TECH,\r\n&device_tech);\r\nif ((connector ==\r\nIXGBE_SFF_QSFP_CONNECTOR_NOT_SEPARABLE) &&\r\n(cable_length > 0) &&\r\n((device_tech >> 4) ==\r\nIXGBE_SFF_QSFP_TRANSMITER_850NM_VCSEL))\r\nactive_cable = true;\r\n}\r\nif (active_cable) {\r\nhw->phy.type = ixgbe_phy_qsfp_active_unknown;\r\nif (hw->bus.lan_id == 0)\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_da_act_lmt_core0;\r\nelse\r\nhw->phy.sfp_type =\r\nixgbe_sfp_type_da_act_lmt_core1;\r\n} else {\r\nhw->phy.type = ixgbe_phy_sfp_unsupported;\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n}\r\n}\r\nif (hw->phy.sfp_type != stored_sfp_type)\r\nhw->phy.sfp_setup_needed = true;\r\nhw->phy.multispeed_fiber = false;\r\nif (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&\r\n(comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||\r\n((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&\r\n(comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))\r\nhw->phy.multispeed_fiber = true;\r\nif (comp_codes_10g & (IXGBE_SFF_10GBASESR_CAPABLE |\r\nIXGBE_SFF_10GBASELR_CAPABLE)) {\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_QSFP_VENDOR_OUI_BYTE0,\r\n&oui_bytes[0]);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_QSFP_VENDOR_OUI_BYTE1,\r\n&oui_bytes[1]);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_QSFP_VENDOR_OUI_BYTE2,\r\n&oui_bytes[2]);\r\nif (status != 0)\r\ngoto err_read_i2c_eeprom;\r\nvendor_oui =\r\n((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |\r\n(oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |\r\n(oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));\r\nif (vendor_oui == IXGBE_SFF_VENDOR_OUI_INTEL)\r\nhw->phy.type = ixgbe_phy_qsfp_intel;\r\nelse\r\nhw->phy.type = ixgbe_phy_qsfp_unknown;\r\nhw->mac.ops.get_device_caps(hw, &enforce_sfp);\r\nif (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP)) {\r\nif (hw->phy.type == ixgbe_phy_qsfp_intel)\r\nreturn 0;\r\nif (hw->allow_unsupported_sfp) {\r\ne_warn(drv, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");\r\nreturn 0;\r\n}\r\nhw_dbg(hw, "QSFP module not supported\n");\r\nhw->phy.type = ixgbe_phy_sfp_unsupported;\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n}\r\nreturn 0;\r\n}\r\nreturn 0;\r\nerr_read_i2c_eeprom:\r\nhw->phy.sfp_type = ixgbe_sfp_type_not_present;\r\nhw->phy.id = 0;\r\nhw->phy.type = ixgbe_phy_unknown;\r\nreturn IXGBE_ERR_SFP_NOT_PRESENT;\r\n}\r\ns32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,\r\nu16 *list_offset,\r\nu16 *data_offset)\r\n{\r\nu16 sfp_id;\r\nu16 sfp_type = hw->phy.sfp_type;\r\nif (hw->phy.sfp_type == ixgbe_sfp_type_unknown)\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\nif (hw->phy.sfp_type == ixgbe_sfp_type_not_present)\r\nreturn IXGBE_ERR_SFP_NOT_PRESENT;\r\nif ((hw->device_id == IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM) &&\r\n(hw->phy.sfp_type == ixgbe_sfp_type_da_cu))\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\nif (sfp_type == ixgbe_sfp_type_da_act_lmt_core0 ||\r\nsfp_type == ixgbe_sfp_type_1g_lx_core0 ||\r\nsfp_type == ixgbe_sfp_type_1g_cu_core0 ||\r\nsfp_type == ixgbe_sfp_type_1g_sx_core0)\r\nsfp_type = ixgbe_sfp_type_srlr_core0;\r\nelse if (sfp_type == ixgbe_sfp_type_da_act_lmt_core1 ||\r\nsfp_type == ixgbe_sfp_type_1g_lx_core1 ||\r\nsfp_type == ixgbe_sfp_type_1g_cu_core1 ||\r\nsfp_type == ixgbe_sfp_type_1g_sx_core1)\r\nsfp_type = ixgbe_sfp_type_srlr_core1;\r\nif (hw->eeprom.ops.read(hw, IXGBE_PHY_INIT_OFFSET_NL, list_offset)) {\r\nhw_err(hw, "eeprom read at %d failed\n",\r\nIXGBE_PHY_INIT_OFFSET_NL);\r\nreturn IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT;\r\n}\r\nif ((!*list_offset) || (*list_offset == 0xFFFF))\r\nreturn IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT;\r\n(*list_offset)++;\r\nif (hw->eeprom.ops.read(hw, *list_offset, &sfp_id))\r\ngoto err_phy;\r\nwhile (sfp_id != IXGBE_PHY_INIT_END_NL) {\r\nif (sfp_id == sfp_type) {\r\n(*list_offset)++;\r\nif (hw->eeprom.ops.read(hw, *list_offset, data_offset))\r\ngoto err_phy;\r\nif ((!*data_offset) || (*data_offset == 0xFFFF)) {\r\nhw_dbg(hw, "SFP+ module not supported\n");\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n} else {\r\nbreak;\r\n}\r\n} else {\r\n(*list_offset) += 2;\r\nif (hw->eeprom.ops.read(hw, *list_offset, &sfp_id))\r\ngoto err_phy;\r\n}\r\n}\r\nif (sfp_id == IXGBE_PHY_INIT_END_NL) {\r\nhw_dbg(hw, "No matching SFP+ module found\n");\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\n}\r\nreturn 0;\r\nerr_phy:\r\nhw_err(hw, "eeprom read at offset %d failed\n", *list_offset);\r\nreturn IXGBE_ERR_PHY;\r\n}\r\ns32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 *eeprom_data)\r\n{\r\nreturn hw->phy.ops.read_i2c_byte(hw, byte_offset,\r\nIXGBE_I2C_EEPROM_DEV_ADDR,\r\neeprom_data);\r\n}\r\ns32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 *sff8472_data)\r\n{\r\nreturn hw->phy.ops.read_i2c_byte(hw, byte_offset,\r\nIXGBE_I2C_EEPROM_DEV_ADDR2,\r\nsff8472_data);\r\n}\r\ns32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 eeprom_data)\r\n{\r\nreturn hw->phy.ops.write_i2c_byte(hw, byte_offset,\r\nIXGBE_I2C_EEPROM_DEV_ADDR,\r\neeprom_data);\r\n}\r\nstatic bool ixgbe_is_sfp_probe(struct ixgbe_hw *hw, u8 offset, u8 addr)\r\n{\r\nif (addr == IXGBE_I2C_EEPROM_DEV_ADDR &&\r\noffset == IXGBE_SFF_IDENTIFIER &&\r\nhw->phy.sfp_type == ixgbe_sfp_type_not_present)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic s32 ixgbe_read_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 *data, bool lock)\r\n{\r\ns32 status;\r\nu32 max_retry = 10;\r\nu32 retry = 0;\r\nu32 swfw_mask = hw->phy.phy_semaphore_mask;\r\nbool nack = true;\r\nif (ixgbe_is_sfp_probe(hw, byte_offset, dev_addr))\r\nmax_retry = IXGBE_SFP_DETECT_RETRIES;\r\n*data = 0;\r\ndo {\r\nif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nixgbe_i2c_start(hw);\r\nstatus = ixgbe_clock_out_i2c_byte(hw, dev_addr);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_get_i2c_ack(hw);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_clock_out_i2c_byte(hw, byte_offset);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_get_i2c_ack(hw);\r\nif (status != 0)\r\ngoto fail;\r\nixgbe_i2c_start(hw);\r\nstatus = ixgbe_clock_out_i2c_byte(hw, (dev_addr | 0x1));\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_get_i2c_ack(hw);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_clock_in_i2c_byte(hw, data);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_clock_out_i2c_bit(hw, nack);\r\nif (status != 0)\r\ngoto fail;\r\nixgbe_i2c_stop(hw);\r\nif (lock)\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\nreturn 0;\r\nfail:\r\nixgbe_i2c_bus_clear(hw);\r\nif (lock) {\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\nmsleep(100);\r\n}\r\nretry++;\r\nif (retry < max_retry)\r\nhw_dbg(hw, "I2C byte read error - Retrying.\n");\r\nelse\r\nhw_dbg(hw, "I2C byte read error.\n");\r\n} while (retry < max_retry);\r\nreturn status;\r\n}\r\ns32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 *data)\r\n{\r\nreturn ixgbe_read_i2c_byte_generic_int(hw, byte_offset, dev_addr,\r\ndata, true);\r\n}\r\ns32 ixgbe_read_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 *data)\r\n{\r\nreturn ixgbe_read_i2c_byte_generic_int(hw, byte_offset, dev_addr,\r\ndata, false);\r\n}\r\nstatic s32 ixgbe_write_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 data, bool lock)\r\n{\r\ns32 status;\r\nu32 max_retry = 1;\r\nu32 retry = 0;\r\nu32 swfw_mask = hw->phy.phy_semaphore_mask;\r\nif (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\ndo {\r\nixgbe_i2c_start(hw);\r\nstatus = ixgbe_clock_out_i2c_byte(hw, dev_addr);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_get_i2c_ack(hw);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_clock_out_i2c_byte(hw, byte_offset);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_get_i2c_ack(hw);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_clock_out_i2c_byte(hw, data);\r\nif (status != 0)\r\ngoto fail;\r\nstatus = ixgbe_get_i2c_ack(hw);\r\nif (status != 0)\r\ngoto fail;\r\nixgbe_i2c_stop(hw);\r\nif (lock)\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\nreturn 0;\r\nfail:\r\nixgbe_i2c_bus_clear(hw);\r\nretry++;\r\nif (retry < max_retry)\r\nhw_dbg(hw, "I2C byte write error - Retrying.\n");\r\nelse\r\nhw_dbg(hw, "I2C byte write error.\n");\r\n} while (retry < max_retry);\r\nif (lock)\r\nhw->mac.ops.release_swfw_sync(hw, swfw_mask);\r\nreturn status;\r\n}\r\ns32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 data)\r\n{\r\nreturn ixgbe_write_i2c_byte_generic_int(hw, byte_offset, dev_addr,\r\ndata, true);\r\n}\r\ns32 ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 data)\r\n{\r\nreturn ixgbe_write_i2c_byte_generic_int(hw, byte_offset, dev_addr,\r\ndata, false);\r\n}\r\nstatic void ixgbe_i2c_start(struct ixgbe_hw *hw)\r\n{\r\nu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\ni2cctl |= IXGBE_I2C_BB_EN(hw);\r\nixgbe_set_i2c_data(hw, &i2cctl, 1);\r\nixgbe_raise_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_SU_STA);\r\nixgbe_set_i2c_data(hw, &i2cctl, 0);\r\nudelay(IXGBE_I2C_T_HD_STA);\r\nixgbe_lower_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_LOW);\r\n}\r\nstatic void ixgbe_i2c_stop(struct ixgbe_hw *hw)\r\n{\r\nu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\r\nu32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN(hw);\r\nu32 bb_en_bit = IXGBE_I2C_BB_EN(hw);\r\nixgbe_set_i2c_data(hw, &i2cctl, 0);\r\nixgbe_raise_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_SU_STO);\r\nixgbe_set_i2c_data(hw, &i2cctl, 1);\r\nudelay(IXGBE_I2C_T_BUF);\r\nif (bb_en_bit || data_oe_bit || clk_oe_bit) {\r\ni2cctl &= ~bb_en_bit;\r\ni2cctl |= data_oe_bit | clk_oe_bit;\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\n}\r\nstatic s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data)\r\n{\r\ns32 i;\r\nbool bit = false;\r\n*data = 0;\r\nfor (i = 7; i >= 0; i--) {\r\nixgbe_clock_in_i2c_bit(hw, &bit);\r\n*data |= bit << i;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data)\r\n{\r\ns32 status;\r\ns32 i;\r\nu32 i2cctl;\r\nbool bit = false;\r\nfor (i = 7; i >= 0; i--) {\r\nbit = (data >> i) & 0x1;\r\nstatus = ixgbe_clock_out_i2c_bit(hw, bit);\r\nif (status != 0)\r\nbreak;\r\n}\r\ni2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\ni2cctl |= IXGBE_I2C_DATA_OUT(hw);\r\ni2cctl |= IXGBE_I2C_DATA_OE_N_EN(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw)\r\n{\r\nu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\r\ns32 status = 0;\r\nu32 i = 0;\r\nu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nu32 timeout = 10;\r\nbool ack = true;\r\nif (data_oe_bit) {\r\ni2cctl |= IXGBE_I2C_DATA_OUT(hw);\r\ni2cctl |= data_oe_bit;\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nixgbe_raise_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_HIGH);\r\nfor (i = 0; i < timeout; i++) {\r\ni2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nack = ixgbe_get_i2c_data(hw, &i2cctl);\r\nudelay(1);\r\nif (ack == 0)\r\nbreak;\r\n}\r\nif (ack == 1) {\r\nhw_dbg(hw, "I2C ack was not received.\n");\r\nstatus = IXGBE_ERR_I2C;\r\n}\r\nixgbe_lower_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_LOW);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data)\r\n{\r\nu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\r\nif (data_oe_bit) {\r\ni2cctl |= IXGBE_I2C_DATA_OUT(hw);\r\ni2cctl |= data_oe_bit;\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nixgbe_raise_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_HIGH);\r\ni2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\n*data = ixgbe_get_i2c_data(hw, &i2cctl);\r\nixgbe_lower_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_LOW);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data)\r\n{\r\ns32 status;\r\nu32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nstatus = ixgbe_set_i2c_data(hw, &i2cctl, data);\r\nif (status == 0) {\r\nixgbe_raise_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_HIGH);\r\nixgbe_lower_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_LOW);\r\n} else {\r\nhw_dbg(hw, "I2C data was not set to %X\n", data);\r\nreturn IXGBE_ERR_I2C;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)\r\n{\r\nu32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN(hw);\r\nu32 i = 0;\r\nu32 timeout = IXGBE_I2C_CLOCK_STRETCHING_TIMEOUT;\r\nu32 i2cctl_r = 0;\r\nif (clk_oe_bit) {\r\n*i2cctl |= clk_oe_bit;\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\r\n}\r\nfor (i = 0; i < timeout; i++) {\r\n*i2cctl |= IXGBE_I2C_CLK_OUT(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(IXGBE_I2C_T_RISE);\r\ni2cctl_r = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nif (i2cctl_r & IXGBE_I2C_CLK_IN(hw))\r\nbreak;\r\n}\r\n}\r\nstatic void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)\r\n{\r\n*i2cctl &= ~IXGBE_I2C_CLK_OUT(hw);\r\n*i2cctl &= ~IXGBE_I2C_CLK_OE_N_EN(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(IXGBE_I2C_T_FALL);\r\n}\r\nstatic s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data)\r\n{\r\nu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\r\nif (data)\r\n*i2cctl |= IXGBE_I2C_DATA_OUT(hw);\r\nelse\r\n*i2cctl &= ~IXGBE_I2C_DATA_OUT(hw);\r\n*i2cctl &= ~data_oe_bit;\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(IXGBE_I2C_T_RISE + IXGBE_I2C_T_FALL + IXGBE_I2C_T_SU_DATA);\r\nif (!data)\r\nreturn 0;\r\nif (data_oe_bit) {\r\n*i2cctl |= data_oe_bit;\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\n*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nif (data != ixgbe_get_i2c_data(hw, i2cctl)) {\r\nhw_dbg(hw, "Error - I2C data was not set to %X.\n", data);\r\nreturn IXGBE_ERR_I2C;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl)\r\n{\r\nu32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);\r\nif (data_oe_bit) {\r\n*i2cctl |= data_oe_bit;\r\nIXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(IXGBE_I2C_T_FALL);\r\n}\r\nif (*i2cctl & IXGBE_I2C_DATA_IN(hw))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)\r\n{\r\nu32 i2cctl;\r\nu32 i;\r\nixgbe_i2c_start(hw);\r\ni2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));\r\nixgbe_set_i2c_data(hw, &i2cctl, 1);\r\nfor (i = 0; i < 9; i++) {\r\nixgbe_raise_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_HIGH);\r\nixgbe_lower_i2c_clk(hw, &i2cctl);\r\nudelay(IXGBE_I2C_T_LOW);\r\n}\r\nixgbe_i2c_start(hw);\r\nixgbe_i2c_stop(hw);\r\n}\r\ns32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw)\r\n{\r\nu16 phy_data = 0;\r\nif (hw->device_id != IXGBE_DEV_ID_82599_T3_LOM)\r\nreturn 0;\r\nhw->phy.ops.read_reg(hw, IXGBE_TN_LASI_STATUS_REG,\r\nMDIO_MMD_PMAPMD, &phy_data);\r\nif (!(phy_data & IXGBE_TN_LASI_STATUS_TEMP_ALARM))\r\nreturn 0;\r\nreturn IXGBE_ERR_OVERTEMP;\r\n}\r\ns32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on)\r\n{\r\nu32 status;\r\nu16 reg;\r\nif (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)\r\nreturn 0;\r\nif (!on && ixgbe_mng_present(hw))\r\nreturn 0;\r\nstatus = hw->phy.ops.read_reg(hw, IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL,\r\nIXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,\r\n&reg);\r\nif (status)\r\nreturn status;\r\nif (on) {\r\nreg &= ~IXGBE_MDIO_PHY_SET_LOW_POWER_MODE;\r\n} else {\r\nif (ixgbe_check_reset_blocked(hw))\r\nreturn 0;\r\nreg |= IXGBE_MDIO_PHY_SET_LOW_POWER_MODE;\r\n}\r\nstatus = hw->phy.ops.write_reg(hw, IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL,\r\nIXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,\r\nreg);\r\nreturn status;\r\n}
