static int mv_conf_mbus_windows(struct platform_device *pdev,\r\nconst struct mbus_dram_target_info *dram)\r\n{\r\nint i;\r\nvoid __iomem *regs;\r\nstruct resource *res;\r\nif (!dram) {\r\ndev_err(&pdev->dev, "no mbus dram info\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot get mbus registers\n");\r\nreturn -EINVAL;\r\n}\r\nregs = ioremap(res->start, resource_size(res));\r\nif (!regs) {\r\ndev_err(&pdev->dev, "cannot map mbus registers\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < SDHCI_MAX_WIN_NUM; i++) {\r\nwritel(0, regs + SDHCI_WINDOW_CTRL(i));\r\nwritel(0, regs + SDHCI_WINDOW_BASE(i));\r\n}\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nconst struct mbus_dram_window *cs = dram->cs + i;\r\nwritel(((cs->size - 1) & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\n(dram->mbus_dram_target_id << 4) | 1,\r\nregs + SDHCI_WINDOW_CTRL(i));\r\nwritel(cs->base, regs + SDHCI_WINDOW_BASE(i));\r\n}\r\niounmap(regs);\r\nreturn 0;\r\n}\r\nstatic int armada_38x_quirks(struct platform_device *pdev,\r\nstruct sdhci_host *host)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\r\nstruct resource *res;\r\nhost->quirks &= ~SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN;\r\nhost->quirks |= SDHCI_QUIRK_MISSING_CAPS;\r\nhost->caps = sdhci_readl(host, SDHCI_CAPABILITIES);\r\nhost->caps1 = sdhci_readl(host, SDHCI_CAPABILITIES_1);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"conf-sdio3");\r\nif (res) {\r\npxa->sdio3_conf_reg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pxa->sdio3_conf_reg))\r\nreturn PTR_ERR(pxa->sdio3_conf_reg);\r\n} else {\r\nhost->caps1 &= ~(SDHCI_SUPPORT_SDR50 | SDHCI_SUPPORT_DDR50);\r\ndev_warn(&pdev->dev, "conf-sdio3 register not found: disabling SDR50 and DDR50 modes.\nConsider updating your dtb\n");\r\n}\r\nif (of_property_read_bool(np, "no-1-8-v")) {\r\nhost->caps &= ~SDHCI_CAN_VDD_180;\r\nhost->mmc->caps &= ~MMC_CAP_1_8V_DDR;\r\n} else {\r\nhost->caps &= ~SDHCI_CAN_VDD_330;\r\n}\r\nhost->caps1 &= ~(SDHCI_SUPPORT_SDR104 | SDHCI_USE_SDR50_TUNING);\r\nreturn 0;\r\n}\r\nstatic void pxav3_reset(struct sdhci_host *host, u8 mask)\r\n{\r\nstruct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));\r\nstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\r\nsdhci_reset(host, mask);\r\nif (mask == SDHCI_RESET_ALL) {\r\nif (pdata && 0 != pdata->clk_delay_cycles) {\r\nu16 tmp;\r\ntmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\r\ntmp |= (pdata->clk_delay_cycles & SDCLK_DELAY_MASK)\r\n<< SDCLK_DELAY_SHIFT;\r\ntmp |= SDCLK_SEL;\r\nwritew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\r\n}\r\n}\r\n}\r\nstatic void pxav3_gen_init_74_clocks(struct sdhci_host *host, u8 power_mode)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\r\nu16 tmp;\r\nint count;\r\nif (pxa->power_mode == MMC_POWER_UP\r\n&& power_mode == MMC_POWER_ON) {\r\ndev_dbg(mmc_dev(host->mmc),\r\n"%s: slot->power_mode = %d,"\r\n"ios->power_mode = %d\n",\r\n__func__,\r\npxa->power_mode,\r\npower_mode);\r\ntmp = readw(host->ioaddr + SD_CE_ATA_2);\r\ntmp |= SDCE_MISC_INT_EN;\r\nwritew(tmp, host->ioaddr + SD_CE_ATA_2);\r\ntmp = readw(host->ioaddr + SD_CFG_FIFO_PARAM);\r\ntmp |= SDCFG_GEN_PAD_CLK_ON;\r\nwritew(tmp, host->ioaddr + SD_CFG_FIFO_PARAM);\r\nudelay(740);\r\ncount = 0;\r\nwhile (count++ < MAX_WAIT_COUNT) {\r\nif ((readw(host->ioaddr + SD_CE_ATA_2)\r\n& SDCE_MISC_INT) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (count == MAX_WAIT_COUNT)\r\ndev_warn(mmc_dev(host->mmc), "74 clock interrupt not cleared\n");\r\ntmp = readw(host->ioaddr + SD_CE_ATA_2);\r\ntmp |= SDCE_MISC_INT;\r\nwritew(tmp, host->ioaddr + SD_CE_ATA_2);\r\n}\r\npxa->power_mode = power_mode;\r\n}\r\nstatic void pxav3_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\r\nu16 ctrl_2;\r\nctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\r\nctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\r\nswitch (uhs) {\r\ncase MMC_TIMING_UHS_SDR12:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR12;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR25:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR25;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR50:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR50 | SDHCI_CTRL_VDD_180;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR104:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR104 | SDHCI_CTRL_VDD_180;\r\nbreak;\r\ncase MMC_TIMING_MMC_DDR52:\r\ncase MMC_TIMING_UHS_DDR50:\r\nctrl_2 |= SDHCI_CTRL_UHS_DDR50 | SDHCI_CTRL_VDD_180;\r\nbreak;\r\n}\r\nif (pxa->sdio3_conf_reg) {\r\nu8 reg_val = readb(pxa->sdio3_conf_reg);\r\nif (uhs == MMC_TIMING_UHS_SDR50 ||\r\nuhs == MMC_TIMING_UHS_DDR50) {\r\nreg_val &= ~SDIO3_CONF_CLK_INV;\r\nreg_val |= SDIO3_CONF_SD_FB_CLK;\r\n} else if (uhs == MMC_TIMING_MMC_HS) {\r\nreg_val &= ~SDIO3_CONF_CLK_INV;\r\nreg_val &= ~SDIO3_CONF_SD_FB_CLK;\r\n} else {\r\nreg_val |= SDIO3_CONF_CLK_INV;\r\nreg_val &= ~SDIO3_CONF_SD_FB_CLK;\r\n}\r\nwriteb(reg_val, pxa->sdio3_conf_reg);\r\n}\r\nsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"%s uhs = %d, ctrl_2 = %04X\n",\r\n__func__, uhs, ctrl_2);\r\n}\r\nstatic void pxav3_set_power(struct sdhci_host *host, unsigned char mode,\r\nunsigned short vdd)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nu8 pwr = host->pwr;\r\nsdhci_set_power(host, mode, vdd);\r\nif (host->pwr == pwr)\r\nreturn;\r\nif (host->pwr == 0)\r\nvdd = 0;\r\nif (!IS_ERR(mmc->supply.vmmc)) {\r\nspin_unlock_irq(&host->lock);\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);\r\nspin_lock_irq(&host->lock);\r\n}\r\n}\r\nstatic struct sdhci_pxa_platdata *pxav3_get_mmc_pdata(struct device *dev)\r\n{\r\nstruct sdhci_pxa_platdata *pdata;\r\nstruct device_node *np = dev->of_node;\r\nu32 clk_delay_cycles;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nif (!of_property_read_u32(np, "mrvl,clk-delay-cycles",\r\n&clk_delay_cycles))\r\npdata->clk_delay_cycles = clk_delay_cycles;\r\nreturn pdata;\r\n}\r\nstatic inline struct sdhci_pxa_platdata *pxav3_get_mmc_pdata(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int sdhci_pxav3_probe(struct platform_device *pdev)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct sdhci_host *host = NULL;\r\nstruct sdhci_pxa *pxa = NULL;\r\nconst struct of_device_id *match;\r\nint ret;\r\nhost = sdhci_pltfm_init(pdev, &sdhci_pxav3_pdata, sizeof(*pxa));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\npxa = sdhci_pltfm_priv(pltfm_host);\r\npxa->clk_io = devm_clk_get(dev, "io");\r\nif (IS_ERR(pxa->clk_io))\r\npxa->clk_io = devm_clk_get(dev, NULL);\r\nif (IS_ERR(pxa->clk_io)) {\r\ndev_err(dev, "failed to get io clock\n");\r\nret = PTR_ERR(pxa->clk_io);\r\ngoto err_clk_get;\r\n}\r\npltfm_host->clk = pxa->clk_io;\r\nclk_prepare_enable(pxa->clk_io);\r\npxa->clk_core = devm_clk_get(dev, "core");\r\nif (!IS_ERR(pxa->clk_core))\r\nclk_prepare_enable(pxa->clk_core);\r\nhost->mmc->caps |= MMC_CAP_1_8V_DDR;\r\nif (of_device_is_compatible(np, "marvell,armada-380-sdhci")) {\r\nret = armada_38x_quirks(pdev, host);\r\nif (ret < 0)\r\ngoto err_mbus_win;\r\nret = mv_conf_mbus_windows(pdev, mv_mbus_dram_info());\r\nif (ret < 0)\r\ngoto err_mbus_win;\r\n}\r\nmatch = of_match_device(of_match_ptr(sdhci_pxav3_of_match), &pdev->dev);\r\nif (match) {\r\nret = mmc_of_parse(host->mmc);\r\nif (ret)\r\ngoto err_of_parse;\r\nsdhci_get_of_property(pdev);\r\npdata = pxav3_get_mmc_pdata(dev);\r\npdev->dev.platform_data = pdata;\r\n} else if (pdata) {\r\nif (pdata->flags & PXA_FLAG_CARD_PERMANENT)\r\nhost->mmc->caps |= MMC_CAP_NONREMOVABLE;\r\nif (pdata->flags & PXA_FLAG_SD_8_BIT_CAPABLE_SLOT)\r\nhost->mmc->caps |= MMC_CAP_8_BIT_DATA;\r\nif (pdata->quirks)\r\nhost->quirks |= pdata->quirks;\r\nif (pdata->quirks2)\r\nhost->quirks2 |= pdata->quirks2;\r\nif (pdata->host_caps)\r\nhost->mmc->caps |= pdata->host_caps;\r\nif (pdata->host_caps2)\r\nhost->mmc->caps2 |= pdata->host_caps2;\r\nif (pdata->pm_caps)\r\nhost->mmc->pm_caps |= pdata->pm_caps;\r\nif (gpio_is_valid(pdata->ext_cd_gpio)) {\r\nret = mmc_gpio_request_cd(host->mmc, pdata->ext_cd_gpio,\r\n0);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to allocate card detect gpio\n");\r\ngoto err_cd_req;\r\n}\r\n}\r\n}\r\npm_runtime_get_noresume(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, PXAV3_RPM_DELAY_MS);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_suspend_ignore_children(&pdev->dev, 1);\r\nret = sdhci_add_host(host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add host\n");\r\ngoto err_add_host;\r\n}\r\nplatform_set_drvdata(pdev, host);\r\nif (host->mmc->pm_caps & MMC_PM_WAKE_SDIO_IRQ)\r\ndevice_init_wakeup(&pdev->dev, 1);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nreturn 0;\r\nerr_add_host:\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nerr_of_parse:\r\nerr_cd_req:\r\nerr_mbus_win:\r\nclk_disable_unprepare(pxa->clk_io);\r\nclk_disable_unprepare(pxa->clk_core);\r\nerr_clk_get:\r\nsdhci_pltfm_free(pdev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pxav3_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\r\npm_runtime_get_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nsdhci_remove_host(host, 1);\r\nclk_disable_unprepare(pxa->clk_io);\r\nclk_disable_unprepare(pxa->clk_core);\r\nsdhci_pltfm_free(pdev);\r\nreturn 0;\r\n}\r\nstatic int sdhci_pxav3_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\npm_runtime_get_sync(dev);\r\nret = sdhci_suspend_host(host);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pxav3_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\npm_runtime_get_sync(dev);\r\nret = sdhci_resume_host(host);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pxav3_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\r\nint ret;\r\nret = sdhci_runtime_suspend_host(host);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(pxa->clk_io);\r\nif (!IS_ERR(pxa->clk_core))\r\nclk_disable_unprepare(pxa->clk_core);\r\nreturn 0;\r\n}\r\nstatic int sdhci_pxav3_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\r\nclk_prepare_enable(pxa->clk_io);\r\nif (!IS_ERR(pxa->clk_core))\r\nclk_prepare_enable(pxa->clk_core);\r\nreturn sdhci_runtime_resume_host(host);\r\n}
