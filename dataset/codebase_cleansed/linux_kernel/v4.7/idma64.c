static struct device *chan2dev(struct dma_chan *chan)\r\n{\r\nreturn &chan->dev->device;\r\n}\r\nstatic void idma64_off(struct idma64 *idma64)\r\n{\r\nunsigned short count = 100;\r\ndma_writel(idma64, CFG, 0);\r\nchannel_clear_bit(idma64, MASK(XFER), idma64->all_chan_mask);\r\nchannel_clear_bit(idma64, MASK(BLOCK), idma64->all_chan_mask);\r\nchannel_clear_bit(idma64, MASK(SRC_TRAN), idma64->all_chan_mask);\r\nchannel_clear_bit(idma64, MASK(DST_TRAN), idma64->all_chan_mask);\r\nchannel_clear_bit(idma64, MASK(ERROR), idma64->all_chan_mask);\r\ndo {\r\ncpu_relax();\r\n} while (dma_readl(idma64, CFG) & IDMA64_CFG_DMA_EN && --count);\r\n}\r\nstatic void idma64_on(struct idma64 *idma64)\r\n{\r\ndma_writel(idma64, CFG, IDMA64_CFG_DMA_EN);\r\n}\r\nstatic void idma64_chan_init(struct idma64 *idma64, struct idma64_chan *idma64c)\r\n{\r\nu32 cfghi = IDMA64C_CFGH_SRC_PER(1) | IDMA64C_CFGH_DST_PER(0);\r\nu32 cfglo = 0;\r\ncfglo |= IDMA64C_CFGL_DST_BURST_ALIGN | IDMA64C_CFGL_SRC_BURST_ALIGN;\r\nchannel_writel(idma64c, CFG_LO, cfglo);\r\nchannel_writel(idma64c, CFG_HI, cfghi);\r\nchannel_set_bit(idma64, MASK(XFER), idma64c->mask);\r\nchannel_set_bit(idma64, MASK(ERROR), idma64c->mask);\r\nidma64_on(idma64);\r\n}\r\nstatic void idma64_chan_stop(struct idma64 *idma64, struct idma64_chan *idma64c)\r\n{\r\nchannel_clear_bit(idma64, CH_EN, idma64c->mask);\r\n}\r\nstatic void idma64_chan_start(struct idma64 *idma64, struct idma64_chan *idma64c)\r\n{\r\nstruct idma64_desc *desc = idma64c->desc;\r\nstruct idma64_hw_desc *hw = &desc->hw[0];\r\nchannel_writeq(idma64c, SAR, 0);\r\nchannel_writeq(idma64c, DAR, 0);\r\nchannel_writel(idma64c, CTL_HI, IDMA64C_CTLH_BLOCK_TS(~0UL));\r\nchannel_writel(idma64c, CTL_LO, IDMA64C_CTLL_LLP_S_EN | IDMA64C_CTLL_LLP_D_EN);\r\nchannel_writeq(idma64c, LLP, hw->llp);\r\nchannel_set_bit(idma64, CH_EN, idma64c->mask);\r\n}\r\nstatic void idma64_stop_transfer(struct idma64_chan *idma64c)\r\n{\r\nstruct idma64 *idma64 = to_idma64(idma64c->vchan.chan.device);\r\nidma64_chan_stop(idma64, idma64c);\r\n}\r\nstatic void idma64_start_transfer(struct idma64_chan *idma64c)\r\n{\r\nstruct idma64 *idma64 = to_idma64(idma64c->vchan.chan.device);\r\nstruct virt_dma_desc *vdesc;\r\nvdesc = vchan_next_desc(&idma64c->vchan);\r\nif (!vdesc) {\r\nidma64c->desc = NULL;\r\nreturn;\r\n}\r\nlist_del(&vdesc->node);\r\nidma64c->desc = to_idma64_desc(vdesc);\r\nidma64_chan_init(idma64, idma64c);\r\nidma64_chan_start(idma64, idma64c);\r\n}\r\nstatic void idma64_chan_irq(struct idma64 *idma64, unsigned short c,\r\nu32 status_err, u32 status_xfer)\r\n{\r\nstruct idma64_chan *idma64c = &idma64->chan[c];\r\nstruct idma64_desc *desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&idma64c->vchan.lock, flags);\r\ndesc = idma64c->desc;\r\nif (desc) {\r\nif (status_err & (1 << c)) {\r\ndma_writel(idma64, CLEAR(ERROR), idma64c->mask);\r\ndesc->status = DMA_ERROR;\r\n} else if (status_xfer & (1 << c)) {\r\ndma_writel(idma64, CLEAR(XFER), idma64c->mask);\r\ndesc->status = DMA_COMPLETE;\r\nvchan_cookie_complete(&desc->vdesc);\r\nidma64_start_transfer(idma64c);\r\n}\r\nif (idma64c->desc == NULL || desc->status == DMA_ERROR)\r\nidma64_stop_transfer(idma64c);\r\n}\r\nspin_unlock_irqrestore(&idma64c->vchan.lock, flags);\r\n}\r\nstatic irqreturn_t idma64_irq(int irq, void *dev)\r\n{\r\nstruct idma64 *idma64 = dev;\r\nu32 status = dma_readl(idma64, STATUS_INT);\r\nu32 status_xfer;\r\nu32 status_err;\r\nunsigned short i;\r\ndev_vdbg(idma64->dma.dev, "%s: status=%#x\n", __func__, status);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nstatus_xfer = dma_readl(idma64, RAW(XFER));\r\nstatus_err = dma_readl(idma64, RAW(ERROR));\r\nfor (i = 0; i < idma64->dma.chancnt; i++)\r\nidma64_chan_irq(idma64, i, status_err, status_xfer);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct idma64_desc *idma64_alloc_desc(unsigned int ndesc)\r\n{\r\nstruct idma64_desc *desc;\r\ndesc = kzalloc(sizeof(*desc), GFP_NOWAIT);\r\nif (!desc)\r\nreturn NULL;\r\ndesc->hw = kcalloc(ndesc, sizeof(*desc->hw), GFP_NOWAIT);\r\nif (!desc->hw) {\r\nkfree(desc);\r\nreturn NULL;\r\n}\r\nreturn desc;\r\n}\r\nstatic void idma64_desc_free(struct idma64_chan *idma64c,\r\nstruct idma64_desc *desc)\r\n{\r\nstruct idma64_hw_desc *hw;\r\nif (desc->ndesc) {\r\nunsigned int i = desc->ndesc;\r\ndo {\r\nhw = &desc->hw[--i];\r\ndma_pool_free(idma64c->pool, hw->lli, hw->llp);\r\n} while (i);\r\n}\r\nkfree(desc->hw);\r\nkfree(desc);\r\n}\r\nstatic void idma64_vdesc_free(struct virt_dma_desc *vdesc)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(vdesc->tx.chan);\r\nidma64_desc_free(idma64c, to_idma64_desc(vdesc));\r\n}\r\nstatic void idma64_hw_desc_fill(struct idma64_hw_desc *hw,\r\nstruct dma_slave_config *config,\r\nenum dma_transfer_direction direction, u64 llp)\r\n{\r\nstruct idma64_lli *lli = hw->lli;\r\nu64 sar, dar;\r\nu32 ctlhi = IDMA64C_CTLH_BLOCK_TS(hw->len);\r\nu32 ctllo = IDMA64C_CTLL_LLP_S_EN | IDMA64C_CTLL_LLP_D_EN;\r\nu32 src_width, dst_width;\r\nif (direction == DMA_MEM_TO_DEV) {\r\nsar = hw->phys;\r\ndar = config->dst_addr;\r\nctllo |= IDMA64C_CTLL_DST_FIX | IDMA64C_CTLL_SRC_INC |\r\nIDMA64C_CTLL_FC_M2P;\r\nsrc_width = __ffs(sar | hw->len | 4);\r\ndst_width = __ffs(config->dst_addr_width);\r\n} else {\r\nsar = config->src_addr;\r\ndar = hw->phys;\r\nctllo |= IDMA64C_CTLL_DST_INC | IDMA64C_CTLL_SRC_FIX |\r\nIDMA64C_CTLL_FC_P2M;\r\nsrc_width = __ffs(config->src_addr_width);\r\ndst_width = __ffs(dar | hw->len | 4);\r\n}\r\nlli->sar = sar;\r\nlli->dar = dar;\r\nlli->ctlhi = ctlhi;\r\nlli->ctllo = ctllo |\r\nIDMA64C_CTLL_SRC_MSIZE(config->src_maxburst) |\r\nIDMA64C_CTLL_DST_MSIZE(config->dst_maxburst) |\r\nIDMA64C_CTLL_DST_WIDTH(dst_width) |\r\nIDMA64C_CTLL_SRC_WIDTH(src_width);\r\nlli->llp = llp;\r\n}\r\nstatic void idma64_desc_fill(struct idma64_chan *idma64c,\r\nstruct idma64_desc *desc)\r\n{\r\nstruct dma_slave_config *config = &idma64c->config;\r\nunsigned int i = desc->ndesc;\r\nstruct idma64_hw_desc *hw = &desc->hw[i - 1];\r\nstruct idma64_lli *lli = hw->lli;\r\nu64 llp = 0;\r\ndo {\r\nhw = &desc->hw[--i];\r\nidma64_hw_desc_fill(hw, config, desc->direction, llp);\r\nllp = hw->llp;\r\ndesc->length += hw->len;\r\n} while (i);\r\nlli->ctllo |= IDMA64C_CTLL_INT_EN;\r\nlli->ctllo &= ~(IDMA64C_CTLL_LLP_S_EN | IDMA64C_CTLL_LLP_D_EN);\r\n}\r\nstatic struct dma_async_tx_descriptor *idma64_prep_slave_sg(\r\nstruct dma_chan *chan, struct scatterlist *sgl,\r\nunsigned int sg_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nstruct idma64_desc *desc;\r\nstruct scatterlist *sg;\r\nunsigned int i;\r\ndesc = idma64_alloc_desc(sg_len);\r\nif (!desc)\r\nreturn NULL;\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\nstruct idma64_hw_desc *hw = &desc->hw[i];\r\nhw->lli = dma_pool_alloc(idma64c->pool, GFP_NOWAIT, &hw->llp);\r\nif (!hw->lli) {\r\ndesc->ndesc = i;\r\nidma64_desc_free(idma64c, desc);\r\nreturn NULL;\r\n}\r\nhw->phys = sg_dma_address(sg);\r\nhw->len = sg_dma_len(sg);\r\n}\r\ndesc->ndesc = sg_len;\r\ndesc->direction = direction;\r\ndesc->status = DMA_IN_PROGRESS;\r\nidma64_desc_fill(idma64c, desc);\r\nreturn vchan_tx_prep(&idma64c->vchan, &desc->vdesc, flags);\r\n}\r\nstatic void idma64_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&idma64c->vchan.lock, flags);\r\nif (vchan_issue_pending(&idma64c->vchan) && !idma64c->desc)\r\nidma64_start_transfer(idma64c);\r\nspin_unlock_irqrestore(&idma64c->vchan.lock, flags);\r\n}\r\nstatic size_t idma64_active_desc_size(struct idma64_chan *idma64c)\r\n{\r\nstruct idma64_desc *desc = idma64c->desc;\r\nstruct idma64_hw_desc *hw;\r\nsize_t bytes = desc->length;\r\nu64 llp = channel_readq(idma64c, LLP);\r\nu32 ctlhi = channel_readl(idma64c, CTL_HI);\r\nunsigned int i = 0;\r\ndo {\r\nhw = &desc->hw[i];\r\nif (hw->llp == llp)\r\nbreak;\r\nbytes -= hw->len;\r\n} while (++i < desc->ndesc);\r\nif (!i)\r\nreturn bytes;\r\nbytes += desc->hw[--i].len;\r\nreturn bytes - IDMA64C_CTLH_BLOCK_TS(ctlhi);\r\n}\r\nstatic enum dma_status idma64_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie, struct dma_tx_state *state)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nstruct virt_dma_desc *vdesc;\r\nenum dma_status status;\r\nsize_t bytes;\r\nunsigned long flags;\r\nstatus = dma_cookie_status(chan, cookie, state);\r\nif (status == DMA_COMPLETE)\r\nreturn status;\r\nspin_lock_irqsave(&idma64c->vchan.lock, flags);\r\nvdesc = vchan_find_desc(&idma64c->vchan, cookie);\r\nif (idma64c->desc && cookie == idma64c->desc->vdesc.tx.cookie) {\r\nbytes = idma64_active_desc_size(idma64c);\r\ndma_set_residue(state, bytes);\r\nstatus = idma64c->desc->status;\r\n} else if (vdesc) {\r\nbytes = to_idma64_desc(vdesc)->length;\r\ndma_set_residue(state, bytes);\r\n}\r\nspin_unlock_irqrestore(&idma64c->vchan.lock, flags);\r\nreturn status;\r\n}\r\nstatic void convert_burst(u32 *maxburst)\r\n{\r\nif (*maxburst)\r\n*maxburst = __fls(*maxburst);\r\nelse\r\n*maxburst = 0;\r\n}\r\nstatic int idma64_slave_config(struct dma_chan *chan,\r\nstruct dma_slave_config *config)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nif (!is_slave_direction(config->direction))\r\nreturn -EINVAL;\r\nmemcpy(&idma64c->config, config, sizeof(idma64c->config));\r\nconvert_burst(&idma64c->config.src_maxburst);\r\nconvert_burst(&idma64c->config.dst_maxburst);\r\nreturn 0;\r\n}\r\nstatic void idma64_chan_deactivate(struct idma64_chan *idma64c, bool drain)\r\n{\r\nunsigned short count = 100;\r\nu32 cfglo;\r\ncfglo = channel_readl(idma64c, CFG_LO);\r\nif (drain)\r\ncfglo |= IDMA64C_CFGL_CH_DRAIN;\r\nelse\r\ncfglo &= ~IDMA64C_CFGL_CH_DRAIN;\r\nchannel_writel(idma64c, CFG_LO, cfglo | IDMA64C_CFGL_CH_SUSP);\r\ndo {\r\nudelay(1);\r\ncfglo = channel_readl(idma64c, CFG_LO);\r\n} while (!(cfglo & IDMA64C_CFGL_FIFO_EMPTY) && --count);\r\n}\r\nstatic void idma64_chan_activate(struct idma64_chan *idma64c)\r\n{\r\nu32 cfglo;\r\ncfglo = channel_readl(idma64c, CFG_LO);\r\nchannel_writel(idma64c, CFG_LO, cfglo & ~IDMA64C_CFGL_CH_SUSP);\r\n}\r\nstatic int idma64_pause(struct dma_chan *chan)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&idma64c->vchan.lock, flags);\r\nif (idma64c->desc && idma64c->desc->status == DMA_IN_PROGRESS) {\r\nidma64_chan_deactivate(idma64c, false);\r\nidma64c->desc->status = DMA_PAUSED;\r\n}\r\nspin_unlock_irqrestore(&idma64c->vchan.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int idma64_resume(struct dma_chan *chan)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&idma64c->vchan.lock, flags);\r\nif (idma64c->desc && idma64c->desc->status == DMA_PAUSED) {\r\nidma64c->desc->status = DMA_IN_PROGRESS;\r\nidma64_chan_activate(idma64c);\r\n}\r\nspin_unlock_irqrestore(&idma64c->vchan.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int idma64_terminate_all(struct dma_chan *chan)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nunsigned long flags;\r\nLIST_HEAD(head);\r\nspin_lock_irqsave(&idma64c->vchan.lock, flags);\r\nidma64_chan_deactivate(idma64c, true);\r\nidma64_stop_transfer(idma64c);\r\nif (idma64c->desc) {\r\nidma64_vdesc_free(&idma64c->desc->vdesc);\r\nidma64c->desc = NULL;\r\n}\r\nvchan_get_all_descriptors(&idma64c->vchan, &head);\r\nspin_unlock_irqrestore(&idma64c->vchan.lock, flags);\r\nvchan_dma_desc_free_list(&idma64c->vchan, &head);\r\nreturn 0;\r\n}\r\nstatic int idma64_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nidma64c->pool = dma_pool_create(dev_name(chan2dev(chan)),\r\nchan->device->dev,\r\nsizeof(struct idma64_lli), 8, 0);\r\nif (!idma64c->pool) {\r\ndev_err(chan2dev(chan), "No memory for descriptors\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void idma64_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct idma64_chan *idma64c = to_idma64_chan(chan);\r\nvchan_free_chan_resources(to_virt_chan(chan));\r\ndma_pool_destroy(idma64c->pool);\r\nidma64c->pool = NULL;\r\n}\r\nstatic int idma64_probe(struct idma64_chip *chip)\r\n{\r\nstruct idma64 *idma64;\r\nunsigned short nr_chan = IDMA64_NR_CHAN;\r\nunsigned short i;\r\nint ret;\r\nidma64 = devm_kzalloc(chip->dev, sizeof(*idma64), GFP_KERNEL);\r\nif (!idma64)\r\nreturn -ENOMEM;\r\nidma64->regs = chip->regs;\r\nchip->idma64 = idma64;\r\nidma64->chan = devm_kcalloc(chip->dev, nr_chan, sizeof(*idma64->chan),\r\nGFP_KERNEL);\r\nif (!idma64->chan)\r\nreturn -ENOMEM;\r\nidma64->all_chan_mask = (1 << nr_chan) - 1;\r\nidma64_off(idma64);\r\nret = devm_request_irq(chip->dev, chip->irq, idma64_irq, IRQF_SHARED,\r\ndev_name(chip->dev), idma64);\r\nif (ret)\r\nreturn ret;\r\nINIT_LIST_HEAD(&idma64->dma.channels);\r\nfor (i = 0; i < nr_chan; i++) {\r\nstruct idma64_chan *idma64c = &idma64->chan[i];\r\nidma64c->vchan.desc_free = idma64_vdesc_free;\r\nvchan_init(&idma64c->vchan, &idma64->dma);\r\nidma64c->regs = idma64->regs + i * IDMA64_CH_LENGTH;\r\nidma64c->mask = BIT(i);\r\n}\r\ndma_cap_set(DMA_SLAVE, idma64->dma.cap_mask);\r\ndma_cap_set(DMA_PRIVATE, idma64->dma.cap_mask);\r\nidma64->dma.device_alloc_chan_resources = idma64_alloc_chan_resources;\r\nidma64->dma.device_free_chan_resources = idma64_free_chan_resources;\r\nidma64->dma.device_prep_slave_sg = idma64_prep_slave_sg;\r\nidma64->dma.device_issue_pending = idma64_issue_pending;\r\nidma64->dma.device_tx_status = idma64_tx_status;\r\nidma64->dma.device_config = idma64_slave_config;\r\nidma64->dma.device_pause = idma64_pause;\r\nidma64->dma.device_resume = idma64_resume;\r\nidma64->dma.device_terminate_all = idma64_terminate_all;\r\nidma64->dma.src_addr_widths = IDMA64_BUSWIDTHS;\r\nidma64->dma.dst_addr_widths = IDMA64_BUSWIDTHS;\r\nidma64->dma.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\r\nidma64->dma.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\r\nidma64->dma.dev = chip->dev;\r\ndma_set_max_seg_size(idma64->dma.dev, IDMA64C_CTLH_BLOCK_TS_MASK);\r\nret = dma_async_device_register(&idma64->dma);\r\nif (ret)\r\nreturn ret;\r\ndev_info(chip->dev, "Found Intel integrated DMA 64-bit\n");\r\nreturn 0;\r\n}\r\nstatic int idma64_remove(struct idma64_chip *chip)\r\n{\r\nstruct idma64 *idma64 = chip->idma64;\r\nunsigned short i;\r\ndma_async_device_unregister(&idma64->dma);\r\ndevm_free_irq(chip->dev, chip->irq, idma64);\r\nfor (i = 0; i < idma64->dma.chancnt; i++) {\r\nstruct idma64_chan *idma64c = &idma64->chan[i];\r\ntasklet_kill(&idma64c->vchan.task);\r\n}\r\nreturn 0;\r\n}\r\nstatic int idma64_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct idma64_chip *chip;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *mem;\r\nint ret;\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->irq = platform_get_irq(pdev, 0);\r\nif (chip->irq < 0)\r\nreturn chip->irq;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchip->regs = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(chip->regs))\r\nreturn PTR_ERR(chip->regs);\r\nret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\r\nif (ret)\r\nreturn ret;\r\nchip->dev = dev;\r\nret = idma64_probe(chip);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, chip);\r\nreturn 0;\r\n}\r\nstatic int idma64_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct idma64_chip *chip = platform_get_drvdata(pdev);\r\nreturn idma64_remove(chip);\r\n}\r\nstatic int idma64_pm_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct idma64_chip *chip = platform_get_drvdata(pdev);\r\nidma64_off(chip->idma64);\r\nreturn 0;\r\n}\r\nstatic int idma64_pm_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct idma64_chip *chip = platform_get_drvdata(pdev);\r\nidma64_on(chip->idma64);\r\nreturn 0;\r\n}
