static int nx_xcbc_set_key(struct crypto_shash *desc,\r\nconst u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_shash_ctx(desc);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nswitch (key_len) {\r\ncase AES_KEYSIZE_128:\r\nnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_128];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmemcpy(csbcpb->cpb.aes_xcbc.key, in_key, key_len);\r\nreturn 0;\r\n}\r\nstatic int nx_xcbc_empty(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct nx_sg *in_sg, *out_sg;\r\nu8 keys[2][AES_BLOCK_SIZE];\r\nu8 key[32];\r\nint rc = 0;\r\nint len;\r\ncsbcpb->cpb.hdr.mode = NX_MODE_AES_ECB;\r\nmemcpy(key, csbcpb->cpb.aes_xcbc.key, AES_BLOCK_SIZE);\r\nmemcpy(csbcpb->cpb.aes_ecb.key, key, AES_BLOCK_SIZE);\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_ENDE_ENCRYPT;\r\nmemset(keys[0], 0x01, sizeof(keys[0]));\r\nmemset(keys[1], 0x03, sizeof(keys[1]));\r\nlen = sizeof(keys);\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *) keys, &len,\r\nnx_ctx->ap->sglen);\r\nif (len != sizeof(keys))\r\nreturn -EINVAL;\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, (u8 *) keys, &len,\r\nnx_ctx->ap->sglen);\r\nif (len != sizeof(keys))\r\nreturn -EINVAL;\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\nkeys[1][0] ^= 0x80;\r\nlen = sizeof(keys[1]);\r\nmemcpy(csbcpb->cpb.aes_ecb.key, keys[0], AES_BLOCK_SIZE);\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *) keys[1], &len,\r\nnx_ctx->ap->sglen);\r\nif (len != sizeof(keys[1]))\r\nreturn -EINVAL;\r\nlen = AES_BLOCK_SIZE;\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, out, &len,\r\nnx_ctx->ap->sglen);\r\nif (len != AES_BLOCK_SIZE)\r\nreturn -EINVAL;\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\nout:\r\ncsbcpb->cpb.hdr.mode = NX_MODE_AES_XCBC_MAC;\r\nmemcpy(csbcpb->cpb.aes_xcbc.key, key, AES_BLOCK_SIZE);\r\nNX_CPB_FDM(csbcpb) &= ~NX_FDM_ENDE_ENCRYPT;\r\nreturn rc;\r\n}\r\nstatic int nx_crypto_ctx_aes_xcbc_init2(struct crypto_tfm *tfm)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(tfm);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nint err;\r\nerr = nx_crypto_ctx_aes_xcbc_init(tfm);\r\nif (err)\r\nreturn err;\r\nnx_ctx_init(nx_ctx, HCOP_FC_AES);\r\nNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_128);\r\ncsbcpb->cpb.hdr.mode = NX_MODE_AES_XCBC_MAC;\r\nreturn 0;\r\n}\r\nstatic int nx_xcbc_init(struct shash_desc *desc)\r\n{\r\nstruct xcbc_state *sctx = shash_desc_ctx(desc);\r\nmemset(sctx, 0, sizeof *sctx);\r\nreturn 0;\r\n}\r\nstatic int nx_xcbc_update(struct shash_desc *desc,\r\nconst u8 *data,\r\nunsigned int len)\r\n{\r\nstruct xcbc_state *sctx = shash_desc_ctx(desc);\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct nx_sg *in_sg;\r\nstruct nx_sg *out_sg;\r\nu32 to_process = 0, leftover, total;\r\nunsigned int max_sg_len;\r\nunsigned long irq_flags;\r\nint rc = 0;\r\nint data_len;\r\nspin_lock_irqsave(&nx_ctx->lock, irq_flags);\r\ntotal = sctx->count + len;\r\nif (total <= AES_BLOCK_SIZE) {\r\nmemcpy(sctx->buffer + sctx->count, data, len);\r\nsctx->count += len;\r\ngoto out;\r\n}\r\nin_sg = nx_ctx->in_sg;\r\nmax_sg_len = min_t(u64, nx_driver.of.max_sg_len/sizeof(struct nx_sg),\r\nnx_ctx->ap->sglen);\r\nmax_sg_len = min_t(u64, max_sg_len,\r\nnx_ctx->ap->databytelen/NX_PAGE_SIZE);\r\ndata_len = AES_BLOCK_SIZE;\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, (u8 *)sctx->state,\r\n&len, nx_ctx->ap->sglen);\r\nif (data_len != AES_BLOCK_SIZE) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\ndo {\r\nto_process = total - to_process;\r\nto_process = to_process & ~(AES_BLOCK_SIZE - 1);\r\nleftover = total - to_process;\r\nif (!leftover) {\r\nto_process -= AES_BLOCK_SIZE;\r\nleftover = AES_BLOCK_SIZE;\r\n}\r\nif (sctx->count) {\r\ndata_len = sctx->count;\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg,\r\n(u8 *) sctx->buffer,\r\n&data_len,\r\nmax_sg_len);\r\nif (data_len != sctx->count) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\ndata_len = to_process - sctx->count;\r\nin_sg = nx_build_sg_list(in_sg,\r\n(u8 *) data,\r\n&data_len,\r\nmax_sg_len);\r\nif (data_len != to_process - sctx->count) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) *\r\nsizeof(struct nx_sg);\r\nif (NX_CPB_FDM(csbcpb) & NX_FDM_CONTINUATION) {\r\nmemcpy(csbcpb->cpb.aes_xcbc.cv,\r\ncsbcpb->cpb.aes_xcbc.out_cv_mac,\r\nAES_BLOCK_SIZE);\r\n}\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_INTERMEDIATE;\r\nif (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;\r\ntotal -= to_process;\r\ndata += to_process - sctx->count;\r\nsctx->count = 0;\r\nin_sg = nx_ctx->in_sg;\r\n} while (leftover > AES_BLOCK_SIZE);\r\nmemcpy(sctx->buffer, data, leftover);\r\nsctx->count = leftover;\r\nout:\r\nspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\r\nreturn rc;\r\n}\r\nstatic int nx_xcbc_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct xcbc_state *sctx = shash_desc_ctx(desc);\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct nx_sg *in_sg, *out_sg;\r\nunsigned long irq_flags;\r\nint rc = 0;\r\nint len;\r\nspin_lock_irqsave(&nx_ctx->lock, irq_flags);\r\nif (NX_CPB_FDM(csbcpb) & NX_FDM_CONTINUATION) {\r\nmemcpy(csbcpb->cpb.aes_xcbc.cv,\r\ncsbcpb->cpb.aes_xcbc.out_cv_mac, AES_BLOCK_SIZE);\r\n} else if (sctx->count == 0) {\r\nrc = nx_xcbc_empty(desc, out);\r\ngoto out;\r\n}\r\nNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\r\nlen = sctx->count;\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *)sctx->buffer,\r\n&len, nx_ctx->ap->sglen);\r\nif (len != sctx->count) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlen = AES_BLOCK_SIZE;\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, out, &len,\r\nnx_ctx->ap->sglen);\r\nif (len != AES_BLOCK_SIZE) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\nif (!nx_ctx->op.outlen) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\nmemcpy(out, csbcpb->cpb.aes_xcbc.out_cv_mac, AES_BLOCK_SIZE);\r\nout:\r\nspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\r\nreturn rc;\r\n}
