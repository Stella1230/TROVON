static u8 reg_r(struct gspca_dev *gspca_dev,\r\nu16 index)\r\n{\r\nusb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex,\r\ngspca_dev->usb_buf, 1, 500);\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\nu16 index)\r\n{\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index,\r\nNULL, 0, 500);\r\n}\r\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\r\nconst u8 *buffer, u16 len)\r\n{\r\nif (len <= USB_BUF_SZ) {\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x01, 0,\r\ngspca_dev->usb_buf, len, 500);\r\n} else {\r\nu8 *tmpbuf;\r\ntmpbuf = kmemdup(buffer, len, GFP_KERNEL);\r\nif (!tmpbuf) {\r\npr_err("Out of memory\n");\r\nreturn;\r\n}\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x01, 0,\r\ntmpbuf, len, 500);\r\nkfree(tmpbuf);\r\n}\r\n}\r\nstatic void reg_w_ixbuf(struct gspca_dev *gspca_dev,\r\nu8 reg,\r\nconst u8 *buffer, u16 len)\r\n{\r\nint i;\r\nu8 *p, *tmpbuf;\r\nif (len * 2 <= USB_BUF_SZ) {\r\np = tmpbuf = gspca_dev->usb_buf;\r\n} else {\r\np = tmpbuf = kmalloc(len * 2, GFP_KERNEL);\r\nif (!tmpbuf) {\r\npr_err("Out of memory\n");\r\nreturn;\r\n}\r\n}\r\ni = len;\r\nwhile (--i >= 0) {\r\n*p++ = reg++;\r\n*p++ = *buffer++;\r\n}\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x01, 0,\r\ntmpbuf, len * 2, 500);\r\nif (len * 2 > USB_BUF_SZ)\r\nkfree(tmpbuf);\r\n}\r\nstatic void om6802_sensor_init(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nconst u8 *p;\r\nu8 byte;\r\nu8 val[6] = {0x62, 0, 0x64, 0, 0x60, 0x05};\r\nstatic const u8 sensor_init[] = {\r\n0xdf, 0x6d,\r\n0xdd, 0x18,\r\n0x5a, 0xe0,\r\n0x5c, 0x07,\r\n0x5d, 0xb0,\r\n0x5e, 0x1e,\r\n0x60, 0x71,\r\n0xef, 0x00,\r\n0xe9, 0x00,\r\n0xea, 0x00,\r\n0x90, 0x24,\r\n0x91, 0xb2,\r\n0x82, 0x32,\r\n0xfd, 0x41,\r\n0x00\r\n};\r\nreg_w_buf(gspca_dev, sensor_reset, sizeof sensor_reset);\r\nmsleep(100);\r\ni = 4;\r\nwhile (--i > 0) {\r\nbyte = reg_r(gspca_dev, 0x0060);\r\nif (!(byte & 0x01))\r\nbreak;\r\nmsleep(100);\r\n}\r\nbyte = reg_r(gspca_dev, 0x0063);\r\nif (byte != 0x17) {\r\npr_err("Bad sensor reset %02x\n", byte);\r\n}\r\np = sensor_init;\r\nwhile (*p != 0) {\r\nval[1] = *p++;\r\nval[3] = *p++;\r\nif (*p == 0)\r\nreg_w(gspca_dev, 0x3c80);\r\nreg_w_buf(gspca_dev, val, sizeof val);\r\ni = 4;\r\nwhile (--i >= 0) {\r\nmsleep(15);\r\nbyte = reg_r(gspca_dev, 0x60);\r\nif (!(byte & 0x01))\r\nbreak;\r\n}\r\n}\r\nmsleep(15);\r\nreg_w(gspca_dev, 0x3c80);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode_t16;\r\ncam->nmodes = ARRAY_SIZE(vga_mode_t16);\r\nreturn 0;\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 brightness)\r\n{\r\nu8 set6[4] = { 0x8f, 0x24, 0xc3, 0x00 };\r\nif (brightness < 7) {\r\nset6[1] = 0x26;\r\nset6[3] = 0x70 - brightness * 0x10;\r\n} else {\r\nset6[3] = 0x00 + ((brightness - 7) * 0x10);\r\n}\r\nreg_w_buf(gspca_dev, set6, sizeof set6);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 contrast)\r\n{\r\nu16 reg_to_write;\r\nif (contrast < 7)\r\nreg_to_write = 0x8ea9 - contrast * 0x200;\r\nelse\r\nreg_to_write = 0x00a9 + (contrast - 7) * 0x200;\r\nreg_w(gspca_dev, reg_to_write);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu16 reg_to_write;\r\nreg_to_write = 0x80bb + val * 0x100;\r\nreg_w(gspca_dev, reg_to_write);\r\n}\r\nstatic void setgamma(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nPDEBUG(D_CONF, "Gamma: %d", val);\r\nreg_w_ixbuf(gspca_dev, 0x90,\r\ngamma_table[val], sizeof gamma_table[0]);\r\n}\r\nstatic void setawb_n_RGB(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 all_gain_reg[8] = {\r\n0x87, 0x00, 0x88, 0x00, 0x89, 0x00, 0x80, 0x00 };\r\ns32 red_gain, blue_gain, green_gain;\r\ngreen_gain = sd->gain->val;\r\nred_gain = green_gain + sd->red_balance->val;\r\nif (red_gain > 0x40)\r\nred_gain = 0x40;\r\nelse if (red_gain < 0x10)\r\nred_gain = 0x10;\r\nblue_gain = green_gain + sd->blue_balance->val;\r\nif (blue_gain > 0x40)\r\nblue_gain = 0x40;\r\nelse if (blue_gain < 0x10)\r\nblue_gain = 0x10;\r\nall_gain_reg[1] = red_gain;\r\nall_gain_reg[3] = blue_gain;\r\nall_gain_reg[5] = green_gain;\r\nall_gain_reg[7] = sensor_data[sd->sensor].reg80;\r\nif (!sd->awb->val)\r\nall_gain_reg[7] &= ~0x04;\r\nreg_w_buf(gspca_dev, all_gain_reg, sizeof all_gain_reg);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu16 reg_to_write;\r\nreg_to_write = 0x0aa6 + 0x1000 * val;\r\nreg_w(gspca_dev, reg_to_write);\r\n}\r\nstatic void setfreq(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 reg66;\r\nu8 freq[4] = { 0x66, 0x00, 0xa8, 0xe8 };\r\nswitch (sd->sensor) {\r\ncase SENSOR_LT168G:\r\nif (val != 0)\r\nfreq[3] = 0xa8;\r\nreg66 = 0x41;\r\nbreak;\r\ncase SENSOR_OM6802:\r\nreg66 = 0xca;\r\nbreak;\r\ndefault:\r\nreg66 = 0x40;\r\nbreak;\r\n}\r\nswitch (val) {\r\ncase 0:\r\nfreq[3] = 0xf0;\r\nbreak;\r\ncase 2:\r\nreg66 &= ~0x40;\r\nbreak;\r\n}\r\nfreq[1] = reg66;\r\nreg_w_buf(gspca_dev, freq, sizeof freq);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst struct additional_sensor_data *sensor;\r\nint i;\r\nu16 sensor_id;\r\nu8 test_byte = 0;\r\nstatic const u8 read_indexs[] =\r\n{ 0x0a, 0x0b, 0x66, 0x80, 0x81, 0x8e, 0x8f, 0xa5,\r\n0xa6, 0xa8, 0xbb, 0xbc, 0xc6, 0x00 };\r\nstatic const u8 n1[] =\r\n{0x08, 0x03, 0x09, 0x03, 0x12, 0x04};\r\nstatic const u8 n2[] =\r\n{0x08, 0x00};\r\nsensor_id = (reg_r(gspca_dev, 0x06) << 8)\r\n| reg_r(gspca_dev, 0x07);\r\nswitch (sensor_id & 0xff0f) {\r\ncase 0x0801:\r\nPDEBUG(D_PROBE, "sensor tas5130a");\r\nsd->sensor = SENSOR_TAS5130A;\r\nbreak;\r\ncase 0x0802:\r\nPDEBUG(D_PROBE, "sensor lt168g");\r\nsd->sensor = SENSOR_LT168G;\r\nbreak;\r\ncase 0x0803:\r\nPDEBUG(D_PROBE, "sensor 'other'");\r\nsd->sensor = SENSOR_OTHER;\r\nbreak;\r\ncase 0x0807:\r\nPDEBUG(D_PROBE, "sensor om6802");\r\nsd->sensor = SENSOR_OM6802;\r\nbreak;\r\ndefault:\r\npr_err("unknown sensor %04x\n", sensor_id);\r\nreturn -EINVAL;\r\n}\r\nif (sd->sensor == SENSOR_OM6802) {\r\nreg_w_buf(gspca_dev, n1, sizeof n1);\r\ni = 5;\r\nwhile (--i >= 0) {\r\nreg_w_buf(gspca_dev, sensor_reset, sizeof sensor_reset);\r\ntest_byte = reg_r(gspca_dev, 0x0063);\r\nmsleep(100);\r\nif (test_byte == 0x17)\r\nbreak;\r\n}\r\nif (i < 0) {\r\npr_err("Bad sensor reset %02x\n", test_byte);\r\nreturn -EIO;\r\n}\r\nreg_w_buf(gspca_dev, n2, sizeof n2);\r\n}\r\ni = 0;\r\nwhile (read_indexs[i] != 0x00) {\r\ntest_byte = reg_r(gspca_dev, read_indexs[i]);\r\nPDEBUG(D_STREAM, "Reg 0x%02x = 0x%02x", read_indexs[i],\r\ntest_byte);\r\ni++;\r\n}\r\nsensor = &sensor_data[sd->sensor];\r\nreg_w_buf(gspca_dev, sensor->n3, sizeof sensor->n3);\r\nreg_w_buf(gspca_dev, sensor->n4, sensor->n4sz);\r\nif (sd->sensor == SENSOR_LT168G) {\r\ntest_byte = reg_r(gspca_dev, 0x80);\r\nPDEBUG(D_STREAM, "Reg 0x%02x = 0x%02x", 0x80,\r\ntest_byte);\r\nreg_w(gspca_dev, 0x6c80);\r\n}\r\nreg_w_ixbuf(gspca_dev, 0xd0, sensor->data1, sizeof sensor->data1);\r\nreg_w_ixbuf(gspca_dev, 0xc7, sensor->data2, sizeof sensor->data2);\r\nreg_w_ixbuf(gspca_dev, 0xe0, sensor->data3, sizeof sensor->data3);\r\nreg_w(gspca_dev, (sensor->reg80 << 8) + 0x80);\r\nreg_w(gspca_dev, (sensor->reg80 << 8) + 0x80);\r\nreg_w(gspca_dev, (sensor->reg8e << 8) + 0x8e);\r\nreg_w(gspca_dev, (0x20 << 8) + 0x87);\r\nreg_w(gspca_dev, (0x20 << 8) + 0x88);\r\nreg_w(gspca_dev, (0x20 << 8) + 0x89);\r\nreg_w_buf(gspca_dev, sensor->data5, sizeof sensor->data5);\r\nreg_w_buf(gspca_dev, sensor->nset8, sizeof sensor->nset8);\r\nreg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\r\nif (sd->sensor == SENSOR_LT168G) {\r\ntest_byte = reg_r(gspca_dev, 0x80);\r\nPDEBUG(D_STREAM, "Reg 0x%02x = 0x%02x", 0x80,\r\ntest_byte);\r\nreg_w(gspca_dev, 0x6c80);\r\n}\r\nreg_w_ixbuf(gspca_dev, 0xd0, sensor->data1, sizeof sensor->data1);\r\nreg_w_ixbuf(gspca_dev, 0xc7, sensor->data2, sizeof sensor->data2);\r\nreg_w_ixbuf(gspca_dev, 0xe0, sensor->data3, sizeof sensor->data3);\r\nreturn 0;\r\n}\r\nstatic void setmirror(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu8 hflipcmd[8] =\r\n{0x62, 0x07, 0x63, 0x03, 0x64, 0x00, 0x60, 0x09};\r\nif (val)\r\nhflipcmd[3] = 0x01;\r\nreg_w_buf(gspca_dev, hflipcmd, sizeof hflipcmd);\r\n}\r\nstatic void seteffect(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nint idx = 0;\r\nswitch (val) {\r\ncase V4L2_COLORFX_NONE:\r\nbreak;\r\ncase V4L2_COLORFX_BW:\r\nidx = 2;\r\nbreak;\r\ncase V4L2_COLORFX_SEPIA:\r\nidx = 3;\r\nbreak;\r\ncase V4L2_COLORFX_SKETCH:\r\nidx = 4;\r\nbreak;\r\ncase V4L2_COLORFX_NEGATIVE:\r\nidx = 6;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreg_w_buf(gspca_dev, effects_table[idx],\r\nsizeof effects_table[0]);\r\nif (val == V4L2_COLORFX_SKETCH)\r\nreg_w(gspca_dev, 0x4aa6);\r\nelse\r\nreg_w(gspca_dev, 0xfaa6);\r\n}\r\nstatic void poll_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstatic const u8 poll1[] =\r\n{0x67, 0x05, 0x68, 0x81, 0x69, 0x80, 0x6a, 0x82,\r\n0x6b, 0x68, 0x6c, 0x69, 0x72, 0xd9, 0x73, 0x34,\r\n0x74, 0x32, 0x75, 0x92, 0x76, 0x00, 0x09, 0x01,\r\n0x60, 0x14};\r\nstatic const u8 poll2[] =\r\n{0x67, 0x02, 0x68, 0x71, 0x69, 0x72, 0x72, 0xa9,\r\n0x73, 0x02, 0x73, 0x02, 0x60, 0x14};\r\nstatic const u8 noise03[] =\r\n{0xa6, 0x0a, 0xea, 0xcf, 0xbe, 0x26, 0xb1, 0x5f,\r\n0xa1, 0xb1, 0xda, 0x6b, 0xdb, 0x98, 0xdf, 0x0c,\r\n0xc2, 0x80, 0xc3, 0x10};\r\nPDEBUG(D_STREAM, "[Sensor requires polling]");\r\nreg_w_buf(gspca_dev, poll1, sizeof poll1);\r\nreg_w_buf(gspca_dev, poll2, sizeof poll2);\r\nreg_w_buf(gspca_dev, noise03, sizeof noise03);\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst struct additional_sensor_data *sensor;\r\nint i, mode;\r\nu8 t2[] = { 0x07, 0x00, 0x0d, 0x60, 0x0e, 0x80 };\r\nstatic const u8 t3[] =\r\n{ 0x07, 0x00, 0x88, 0x02, 0x06, 0x00, 0xe7, 0x01 };\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nswitch (mode) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nt2[1] = 0x40;\r\nbreak;\r\ncase 2:\r\nt2[1] = 0x10;\r\nbreak;\r\ncase 3:\r\nt2[1] = 0x50;\r\nbreak;\r\ndefault:\r\nt2[1] = 0x20;\r\nbreak;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_OM6802:\r\nom6802_sensor_init(gspca_dev);\r\nbreak;\r\ncase SENSOR_TAS5130A:\r\ni = 0;\r\nfor (;;) {\r\nreg_w_buf(gspca_dev, tas5130a_sensor_init[i],\r\nsizeof tas5130a_sensor_init[0]);\r\nif (i >= ARRAY_SIZE(tas5130a_sensor_init) - 1)\r\nbreak;\r\ni++;\r\n}\r\nreg_w(gspca_dev, 0x3c80);\r\nreg_w_buf(gspca_dev, tas5130a_sensor_init[i],\r\nsizeof tas5130a_sensor_init[0]);\r\nreg_w(gspca_dev, 0x3c80);\r\nbreak;\r\n}\r\nsensor = &sensor_data[sd->sensor];\r\nsetfreq(gspca_dev, v4l2_ctrl_g_ctrl(sd->freq));\r\nreg_r(gspca_dev, 0x0012);\r\nreg_w_buf(gspca_dev, t2, sizeof t2);\r\nreg_w_ixbuf(gspca_dev, 0xb3, t3, sizeof t3);\r\nreg_w(gspca_dev, 0x0013);\r\nmsleep(15);\r\nreg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\r\nreg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\r\nif (sd->sensor == SENSOR_OM6802)\r\npoll_sensor(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w_buf(gspca_dev, sensor_data[sd->sensor].stream,\r\nsizeof sensor_data[sd->sensor].stream);\r\nreg_w_buf(gspca_dev, sensor_data[sd->sensor].stream,\r\nsizeof sensor_data[sd->sensor].stream);\r\nif (sd->sensor == SENSOR_OM6802) {\r\nmsleep(20);\r\nreg_w(gspca_dev, 0x0309);\r\n}\r\n#if IS_ENABLED(CONFIG_INPUT)\r\nif (sd->button_pressed) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->button_pressed = 0;\r\n}\r\n#endif\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint pkt_type;\r\nif (data[0] == 0x5a) {\r\n#if IS_ENABLED(CONFIG_INPUT)\r\nif (len > 20) {\r\nu8 state = (data[20] & 0x80) ? 1 : 0;\r\nif (sd->button_pressed != state) {\r\ninput_report_key(gspca_dev->input_dev,\r\nKEY_CAMERA, state);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->button_pressed = state;\r\n}\r\n}\r\n#endif\r\nreturn;\r\n}\r\ndata += 2;\r\nlen -= 2;\r\nif (data[0] == 0xff && data[1] == 0xd8)\r\npkt_type = FIRST_PACKET;\r\nelse if (data[len - 2] == 0xff && data[len - 1] == 0xd9)\r\npkt_type = LAST_PACKET;\r\nelse\r\npkt_type = INTER_PACKET;\r\ngspca_frame_add(gspca_dev, pkt_type, data, len);\r\n}\r\nstatic int sd_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ns32 red_gain, blue_gain, green_gain;\r\ngspca_dev->usb_err = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nred_gain = reg_r(gspca_dev, 0x0087);\r\nif (red_gain > 0x40)\r\nred_gain = 0x40;\r\nelse if (red_gain < 0x10)\r\nred_gain = 0x10;\r\nblue_gain = reg_r(gspca_dev, 0x0088);\r\nif (blue_gain > 0x40)\r\nblue_gain = 0x40;\r\nelse if (blue_gain < 0x10)\r\nblue_gain = 0x10;\r\ngreen_gain = reg_r(gspca_dev, 0x0089);\r\nif (green_gain > 0x40)\r\ngreen_gain = 0x40;\r\nelse if (green_gain < 0x10)\r\ngreen_gain = 0x10;\r\nsd->gain->val = green_gain;\r\nsd->red_balance->val = red_gain - green_gain;\r\nsd->blue_balance->val = blue_gain - green_gain;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nsetgamma(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nsetmirror(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nsetfreq(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BACKLIGHT_COMPENSATION:\r\nreg_w(gspca_dev, ctrl->val ? 0xf48e : 0xb48e);\r\nbreak;\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nsetawb_n_RGB(gspca_dev);\r\nbreak;\r\ncase V4L2_CID_COLORFX:\r\nseteffect(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 12);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 14, 1, 8);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 0x0d, 1, 7);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 0xf, 1, 5);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAMMA, 0, GAMMA_MAX, 1, 10);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BACKLIGHT_COMPENSATION, 0, 1, 1, 1);\r\nif (sd->sensor == SENSOR_TAS5130A)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsd->awb = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\r\nsd->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0x10, 0x40, 1, 0x20);\r\nsd->blue_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, -0x30, 0x30, 1, 0);\r\nsd->red_balance = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, -0x30, 0x30, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 15, 1, 6);\r\nv4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\r\nV4L2_CID_COLORFX, V4L2_COLORFX_SKETCH,\r\n~((1 << V4L2_COLORFX_NONE) |\r\n(1 << V4L2_COLORFX_BW) |\r\n(1 << V4L2_COLORFX_SEPIA) |\r\n(1 << V4L2_COLORFX_SKETCH) |\r\n(1 << V4L2_COLORFX_NEGATIVE)),\r\nV4L2_COLORFX_NONE);\r\nsd->freq = v4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 1,\r\nV4L2_CID_POWER_LINE_FREQUENCY_50HZ);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_auto_cluster(4, &sd->awb, 0, true);\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
