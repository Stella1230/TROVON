static void qmi_wwan_netdev_setup(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nif (info->flags & QMI_WWAN_FLAG_RAWIP) {\r\nnet->header_ops = NULL;\r\nnet->type = ARPHRD_NONE;\r\nnet->hard_header_len = 0;\r\nnet->addr_len = 0;\r\nnet->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\r\nnetdev_dbg(net, "mode: raw IP\n");\r\n} else if (!net->header_ops) {\r\nether_setup(net);\r\nnetdev_dbg(net, "mode: Ethernet\n");\r\n}\r\nusbnet_change_mtu(net, net->mtu);\r\n}\r\nstatic ssize_t raw_ip_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nreturn sprintf(buf, "%c\n", info->flags & QMI_WWAN_FLAG_RAWIP ? 'Y' : 'N');\r\n}\r\nstatic ssize_t raw_ip_store(struct device *d, struct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct usbnet *dev = netdev_priv(to_net_dev(d));\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nbool enable;\r\nint ret;\r\nif (strtobool(buf, &enable))\r\nreturn -EINVAL;\r\nif (enable == (info->flags & QMI_WWAN_FLAG_RAWIP))\r\nreturn len;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nif (netif_running(dev->net)) {\r\nnetdev_err(dev->net, "Cannot change a running device\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nret = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE, dev->net);\r\nret = notifier_to_errno(ret);\r\nif (ret) {\r\nnetdev_err(dev->net, "Type change was refused\n");\r\ngoto err;\r\n}\r\nif (enable)\r\ninfo->flags |= QMI_WWAN_FLAG_RAWIP;\r\nelse\r\ninfo->flags &= ~QMI_WWAN_FLAG_RAWIP;\r\nqmi_wwan_netdev_setup(dev->net);\r\ncall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev->net);\r\nret = len;\r\nerr:\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nbool rawip = info->flags & QMI_WWAN_FLAG_RAWIP;\r\n__be16 proto;\r\nif (skb->len < dev->net->hard_header_len)\r\nreturn 0;\r\nswitch (skb->data[0] & 0xf0) {\r\ncase 0x40:\r\nproto = htons(ETH_P_IP);\r\nbreak;\r\ncase 0x60:\r\nproto = htons(ETH_P_IPV6);\r\nbreak;\r\ncase 0x00:\r\nif (rawip)\r\nreturn 0;\r\nif (is_multicast_ether_addr(skb->data))\r\nreturn 1;\r\nskb_reset_mac_header(skb);\r\ngoto fix_dest;\r\ndefault:\r\nif (rawip)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nif (rawip) {\r\nskb->dev = dev->net;\r\nskb->protocol = proto;\r\nreturn 1;\r\n}\r\nif (skb_headroom(skb) < ETH_HLEN)\r\nreturn 0;\r\nskb_push(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\neth_hdr(skb)->h_proto = proto;\r\neth_zero_addr(eth_hdr(skb)->h_source);\r\nfix_dest:\r\nmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\r\nreturn 1;\r\n}\r\nstatic bool possibly_iphdr(const char *data)\r\n{\r\nreturn (data[0] & 0xd0) == 0x40;\r\n}\r\nstatic int qmi_wwan_mac_addr(struct net_device *dev, void *p)\r\n{\r\nint ret;\r\nstruct sockaddr *addr = p;\r\nret = eth_prepare_mac_addr_change(dev, p);\r\nif (ret < 0)\r\nreturn ret;\r\nif (possibly_iphdr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\neth_commit_mac_addr_change(dev, p);\r\nreturn 0;\r\n}\r\nstatic int qmi_wwan_manage_power(struct usbnet *dev, int on)\r\n{\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nint rv;\r\ndev_dbg(&dev->intf->dev, "%s() pmcount=%d, on=%d\n", __func__,\r\natomic_read(&info->pmcount), on);\r\nif ((on && atomic_add_return(1, &info->pmcount) == 1) ||\r\n(!on && atomic_dec_and_test(&info->pmcount))) {\r\nrv = usb_autopm_get_interface(dev->intf);\r\ndev->intf->needs_remote_wakeup = on;\r\nif (!rv)\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qmi_wwan_cdc_wdm_manage_power(struct usb_interface *intf, int on)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn 0;\r\nreturn qmi_wwan_manage_power(dev, on);\r\n}\r\nstatic int qmi_wwan_register_subdriver(struct usbnet *dev)\r\n{\r\nint rv;\r\nstruct usb_driver *subdriver = NULL;\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nrv = usbnet_get_endpoints(dev, info->data);\r\nif (rv < 0)\r\ngoto err;\r\nif (info->control != info->data)\r\ndev->status = &info->control->cur_altsetting->endpoint[0];\r\nif (!dev->status) {\r\nrv = -EINVAL;\r\ngoto err;\r\n}\r\natomic_set(&info->pmcount, 0);\r\nsubdriver = usb_cdc_wdm_register(info->control, &dev->status->desc,\r\n4096, &qmi_wwan_cdc_wdm_manage_power);\r\nif (IS_ERR(subdriver)) {\r\ndev_err(&info->control->dev, "subdriver registration failed\n");\r\nrv = PTR_ERR(subdriver);\r\ngoto err;\r\n}\r\ndev->status = NULL;\r\ninfo->subdriver = subdriver;\r\nerr:\r\nreturn rv;\r\n}\r\nstatic int qmi_wwan_change_dtr(struct usbnet *dev, bool on)\r\n{\r\nu8 intf = dev->intf->cur_altsetting->desc.bInterfaceNumber;\r\nreturn usbnet_write_cmd(dev, USB_CDC_REQ_SET_CONTROL_LINE_STATE,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\non ? 0x01 : 0x00, intf, NULL, 0);\r\n}\r\nstatic int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status = -1;\r\nu8 *buf = intf->cur_altsetting->extra;\r\nint len = intf->cur_altsetting->extralen;\r\nstruct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;\r\nstruct usb_cdc_union_desc *cdc_union;\r\nstruct usb_cdc_ether_desc *cdc_ether;\r\nstruct usb_driver *driver = driver_of(intf);\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nstruct usb_cdc_parsed_header hdr;\r\nBUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) <\r\nsizeof(struct qmi_wwan_state)));\r\ninfo->control = intf;\r\ninfo->data = intf;\r\ncdc_parse_cdc_header(&hdr, intf, buf, len);\r\ncdc_union = hdr.usb_cdc_union_desc;\r\ncdc_ether = hdr.usb_cdc_ether_desc;\r\nif (cdc_union) {\r\ninfo->data = usb_ifnum_to_if(dev->udev,\r\ncdc_union->bSlaveInterface0);\r\nif (desc->bInterfaceNumber != cdc_union->bMasterInterface0 ||\r\n!info->data) {\r\ndev_err(&intf->dev,\r\n"bogus CDC Union: master=%u, slave=%u\n",\r\ncdc_union->bMasterInterface0,\r\ncdc_union->bSlaveInterface0);\r\ncdc_union = NULL;\r\ninfo->data = intf;\r\n}\r\n}\r\nif (cdc_ether) {\r\ndev->hard_mtu = le16_to_cpu(cdc_ether->wMaxSegmentSize);\r\nusbnet_get_ethernet_addr(dev, cdc_ether->iMACAddress);\r\n}\r\nif (info->control != info->data) {\r\nstatus = usb_driver_claim_interface(driver, info->data, dev);\r\nif (status < 0)\r\ngoto err;\r\n}\r\nstatus = qmi_wwan_register_subdriver(dev);\r\nif (status < 0 && info->control != info->data) {\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver, info->data);\r\n}\r\nif (le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {\r\nqmi_wwan_manage_power(dev, 1);\r\nqmi_wwan_change_dtr(dev, true);\r\n}\r\nif (ether_addr_equal(dev->net->dev_addr, default_modem_addr) ||\r\nether_addr_equal(dev->net->dev_addr, buggy_fw_addr))\r\neth_hw_addr_random(dev->net);\r\nif (possibly_iphdr(dev->net->dev_addr)) {\r\ndev->net->dev_addr[0] |= 0x02;\r\ndev->net->dev_addr[0] &= 0xbf;\r\n}\r\ndev->net->netdev_ops = &qmi_wwan_netdev_ops;\r\ndev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;\r\nerr:\r\nreturn status;\r\n}\r\nstatic void qmi_wwan_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nstruct usb_driver *driver = driver_of(intf);\r\nstruct usb_interface *other;\r\nif (info->subdriver && info->subdriver->disconnect)\r\ninfo->subdriver->disconnect(info->control);\r\nif (le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {\r\nqmi_wwan_change_dtr(dev, false);\r\nqmi_wwan_manage_power(dev, 0);\r\n}\r\nif (intf == info->control)\r\nother = info->data;\r\nelse\r\nother = info->control;\r\nif (other && intf != other) {\r\nusb_set_intfdata(other, NULL);\r\nusb_driver_release_interface(driver, other);\r\n}\r\ninfo->subdriver = NULL;\r\ninfo->data = NULL;\r\ninfo->control = NULL;\r\n}\r\nstatic int qmi_wwan_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nint ret;\r\nret = usbnet_suspend(intf, message);\r\nif (ret < 0)\r\ngoto err;\r\nif (intf == info->control && info->subdriver &&\r\ninfo->subdriver->suspend)\r\nret = info->subdriver->suspend(intf, message);\r\nif (ret < 0)\r\nusbnet_resume(intf);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int qmi_wwan_resume(struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nint ret = 0;\r\nbool callsub = (intf == info->control && info->subdriver &&\r\ninfo->subdriver->resume);\r\nif (callsub)\r\nret = info->subdriver->resume(intf);\r\nif (ret < 0)\r\ngoto err;\r\nret = usbnet_resume(intf);\r\nif (ret < 0 && callsub)\r\ninfo->subdriver->suspend(intf, PMSG_SUSPEND);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic bool quectel_ec20_detected(struct usb_interface *intf)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nif (dev->actconfig &&\r\nle16_to_cpu(dev->descriptor.idVendor) == 0x05c6 &&\r\nle16_to_cpu(dev->descriptor.idProduct) == 0x9215 &&\r\ndev->actconfig->desc.bNumInterfaces == 5)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int qmi_wwan_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *prod)\r\n{\r\nstruct usb_device_id *id = (struct usb_device_id *)prod;\r\nstruct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;\r\nif (!id->driver_info) {\r\ndev_dbg(&intf->dev, "setting defaults for dynamic device id\n");\r\nid->driver_info = (unsigned long)&qmi_wwan_info;\r\n}\r\nif (quectel_ec20_detected(intf) && desc->bInterfaceNumber == 0) {\r\ndev_dbg(&intf->dev, "Quectel EC20 quirk, skipping interface 0\n");\r\nreturn -ENODEV;\r\n}\r\nreturn usbnet_probe(intf, id);\r\n}
