static int si2165_write(struct si2165_state *state, const u16 reg,\r\nconst u8 *src, const int count)\r\n{\r\nint ret;\r\nstruct i2c_msg msg;\r\nu8 buf[2 + 4];\r\nif (count + 2 > sizeof(buf)) {\r\ndev_warn(&state->i2c->dev,\r\n"%s: i2c wr reg=%04x: count=%d is too big!\n",\r\nKBUILD_MODNAME, reg, count);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = reg >> 8;\r\nbuf[1] = reg & 0xff;\r\nmemcpy(buf + 2, src, count);\r\nmsg.addr = state->config.i2c_addr;\r\nmsg.flags = 0;\r\nmsg.buf = buf;\r\nmsg.len = count + 2;\r\nif (debug & DEBUG_I2C_WRITE)\r\ndeb_i2c_write("reg: 0x%04x, data: %*ph\n", reg, count, src);\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1) {\r\ndev_err(&state->i2c->dev, "%s: ret == %d\n", __func__, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int si2165_read(struct si2165_state *state,\r\nconst u16 reg, u8 *val, const int count)\r\n{\r\nint ret;\r\nu8 reg_buf[] = { reg >> 8, reg & 0xff };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config.i2c_addr,\r\n.flags = 0, .buf = reg_buf, .len = 2 },\r\n{ .addr = state->config.i2c_addr,\r\n.flags = I2C_M_RD, .buf = val, .len = count },\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\ndev_err(&state->i2c->dev, "%s: error (addr %02x reg %04x error (ret == %i)\n",\r\n__func__, state->config.i2c_addr, reg, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nif (debug & DEBUG_I2C_READ)\r\ndeb_i2c_read("reg: 0x%04x, data: %*ph\n", reg, count, val);\r\nreturn 0;\r\n}\r\nstatic int si2165_readreg8(struct si2165_state *state,\r\nconst u16 reg, u8 *val)\r\n{\r\nint ret;\r\nret = si2165_read(state, reg, val, 1);\r\ndeb_readreg("R(0x%04x)=0x%02x\n", reg, *val);\r\nreturn ret;\r\n}\r\nstatic int si2165_readreg16(struct si2165_state *state,\r\nconst u16 reg, u16 *val)\r\n{\r\nu8 buf[2];\r\nint ret = si2165_read(state, reg, buf, 2);\r\n*val = buf[0] | buf[1] << 8;\r\ndeb_readreg("R(0x%04x)=0x%04x\n", reg, *val);\r\nreturn ret;\r\n}\r\nstatic int si2165_writereg8(struct si2165_state *state, const u16 reg, u8 val)\r\n{\r\nreturn si2165_write(state, reg, &val, 1);\r\n}\r\nstatic int si2165_writereg16(struct si2165_state *state, const u16 reg, u16 val)\r\n{\r\nu8 buf[2] = { val & 0xff, (val >> 8) & 0xff };\r\nreturn si2165_write(state, reg, buf, 2);\r\n}\r\nstatic int si2165_writereg24(struct si2165_state *state, const u16 reg, u32 val)\r\n{\r\nu8 buf[3] = { val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff };\r\nreturn si2165_write(state, reg, buf, 3);\r\n}\r\nstatic int si2165_writereg32(struct si2165_state *state, const u16 reg, u32 val)\r\n{\r\nu8 buf[4] = {\r\nval & 0xff,\r\n(val >> 8) & 0xff,\r\n(val >> 16) & 0xff,\r\n(val >> 24) & 0xff\r\n};\r\nreturn si2165_write(state, reg, buf, 4);\r\n}\r\nstatic int si2165_writereg_mask8(struct si2165_state *state, const u16 reg,\r\nu8 val, u8 mask)\r\n{\r\nif (mask != 0xff) {\r\nu8 tmp;\r\nint ret = si2165_readreg8(state, reg, &tmp);\r\nif (ret < 0)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn si2165_writereg8(state, reg, val);\r\n}\r\nstatic int si2165_write_reg_list(struct si2165_state *state,\r\nconst struct si2165_reg_value_pair *regs,\r\nint count)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < count; i++) {\r\nret = si2165_writereg8(state, regs[i].reg, regs[i].val);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int si2165_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int si2165_init_pll(struct si2165_state *state)\r\n{\r\nu32 ref_freq_Hz = state->config.ref_freq_Hz;\r\nu8 divr = 1;\r\nu8 divp = 1;\r\nu8 divn = 56;\r\nu8 divm = 8;\r\nu8 divl = 12;\r\nu8 buf[4];\r\nswitch (ref_freq_Hz) {\r\ncase 16000000u:\r\ndivn = 56;\r\nbreak;\r\ncase 24000000u:\r\ndivr = 2;\r\ndivp = 4;\r\ndivn = 19;\r\nbreak;\r\ndefault:\r\nif (ref_freq_Hz > 16000000u)\r\ndivr = 2;\r\nif (1624000000u * divr > ref_freq_Hz * 2u * 63u)\r\ndivp = 4;\r\ndivn = 1624000000u * divr / (ref_freq_Hz * 2u * divp);\r\nbreak;\r\n}\r\nstate->fvco_hz = ref_freq_Hz / divr\r\n* 2u * divn * divp;\r\nstate->adc_clk = state->fvco_hz / (divm * 4u);\r\nstate->sys_clk = state->fvco_hz / (divl * 2u);\r\nbuf[0] = divl;\r\nbuf[1] = divm;\r\nbuf[2] = (divn & 0x3f) | ((divp == 1) ? 0x40 : 0x00) | 0x80;\r\nbuf[3] = divr;\r\nreturn si2165_write(state, 0x00a0, buf, 4);\r\n}\r\nstatic int si2165_adjust_pll_divl(struct si2165_state *state, u8 divl)\r\n{\r\nstate->sys_clk = state->fvco_hz / (divl * 2u);\r\nreturn si2165_writereg8(state, 0x00a0, divl);\r\n}\r\nstatic u32 si2165_get_fe_clk(struct si2165_state *state)\r\n{\r\nreturn state->adc_clk;\r\n}\r\nstatic int si2165_wait_init_done(struct si2165_state *state)\r\n{\r\nint ret = -EINVAL;\r\nu8 val = 0;\r\nint i;\r\nfor (i = 0; i < 3; ++i) {\r\nsi2165_readreg8(state, 0x0054, &val);\r\nif (val == 0x01)\r\nreturn 0;\r\nusleep_range(1000, 50000);\r\n}\r\ndev_err(&state->i2c->dev, "%s: init_done was not set\n",\r\nKBUILD_MODNAME);\r\nreturn ret;\r\n}\r\nstatic int si2165_upload_firmware_block(struct si2165_state *state,\r\nconst u8 *data, u32 len, u32 *poffset, u32 block_count)\r\n{\r\nint ret;\r\nu8 buf_ctrl[4] = { 0x00, 0x00, 0x00, 0xc0 };\r\nu8 wordcount;\r\nu32 cur_block = 0;\r\nu32 offset = poffset ? *poffset : 0;\r\nif (len < 4)\r\nreturn -EINVAL;\r\nif (len % 4 != 0)\r\nreturn -EINVAL;\r\ndeb_fw_load(\r\n"si2165_upload_firmware_block called with len=0x%x offset=0x%x blockcount=0x%x\n",\r\nlen, offset, block_count);\r\nwhile (offset+12 <= len && cur_block < block_count) {\r\ndeb_fw_load(\r\n"si2165_upload_firmware_block in while len=0x%x offset=0x%x cur_block=0x%x blockcount=0x%x\n",\r\nlen, offset, cur_block, block_count);\r\nwordcount = data[offset];\r\nif (wordcount < 1 || data[offset+1] ||\r\ndata[offset+2] || data[offset+3]) {\r\ndev_warn(&state->i2c->dev,\r\n"%s: bad fw data[0..3] = %*ph\n",\r\nKBUILD_MODNAME, 4, data);\r\nreturn -EINVAL;\r\n}\r\nif (offset + 8 + wordcount * 4 > len) {\r\ndev_warn(&state->i2c->dev,\r\n"%s: len is too small for block len=%d, wordcount=%d\n",\r\nKBUILD_MODNAME, len, wordcount);\r\nreturn -EINVAL;\r\n}\r\nbuf_ctrl[0] = wordcount - 1;\r\nret = si2165_write(state, 0x0364, buf_ctrl, 4);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_write(state, 0x0368, data+offset+4, 4);\r\nif (ret < 0)\r\ngoto error;\r\noffset += 8;\r\nwhile (wordcount > 0) {\r\nret = si2165_write(state, 0x36c, data+offset, 4);\r\nif (ret < 0)\r\ngoto error;\r\nwordcount--;\r\noffset += 4;\r\n}\r\ncur_block++;\r\n}\r\ndeb_fw_load(\r\n"si2165_upload_firmware_block after while len=0x%x offset=0x%x cur_block=0x%x blockcount=0x%x\n",\r\nlen, offset, cur_block, block_count);\r\nif (poffset)\r\n*poffset = offset;\r\ndeb_fw_load("si2165_upload_firmware_block returned offset=0x%x\n",\r\noffset);\r\nreturn 0;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int si2165_upload_firmware(struct si2165_state *state)\r\n{\r\nu8 val[3];\r\nu16 val16;\r\nint ret;\r\nconst struct firmware *fw = NULL;\r\nu8 *fw_file;\r\nconst u8 *data;\r\nu32 len;\r\nu32 offset;\r\nu8 patch_version;\r\nu8 block_count;\r\nu16 crc_expected;\r\nswitch (state->chip_revcode) {\r\ncase 0x03:\r\nfw_file = SI2165_FIRMWARE_REV_D;\r\nbreak;\r\ndefault:\r\ndev_info(&state->i2c->dev, "%s: no firmware file for revision=%d\n",\r\nKBUILD_MODNAME, state->chip_revcode);\r\nreturn 0;\r\n}\r\nret = request_firmware(&fw, fw_file, state->i2c->dev.parent);\r\nif (ret) {\r\ndev_warn(&state->i2c->dev, "%s: firmware file '%s' not found\n",\r\nKBUILD_MODNAME, fw_file);\r\ngoto error;\r\n}\r\ndata = fw->data;\r\nlen = fw->size;\r\ndev_info(&state->i2c->dev, "%s: downloading firmware from file '%s' size=%d\n",\r\nKBUILD_MODNAME, fw_file, len);\r\nif (len % 4 != 0) {\r\ndev_warn(&state->i2c->dev, "%s: firmware size is not multiple of 4\n",\r\nKBUILD_MODNAME);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (len < 8) {\r\ndev_warn(&state->i2c->dev, "%s: firmware header is missing\n",\r\nKBUILD_MODNAME);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (data[0] != 1 || data[1] != 0) {\r\ndev_warn(&state->i2c->dev, "%s: firmware file version is wrong\n",\r\nKBUILD_MODNAME);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\npatch_version = data[2];\r\nblock_count = data[4];\r\ncrc_expected = data[7] << 8 | data[6];\r\nret = si2165_writereg8(state, 0x0341, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x00c0, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_readreg8(state, 0x0341, val);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_readreg8(state, 0x035c, val);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_readreg8(state, 0x035c, val);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x035c, 0x02);\r\nif (ret < 0)\r\ngoto error;\r\noffset = 8;\r\ndev_info(&state->i2c->dev, "%s: si2165_upload_firmware extracted patch_version=0x%02x, block_count=0x%02x, crc_expected=0x%04x\n",\r\nKBUILD_MODNAME, patch_version, block_count, crc_expected);\r\nret = si2165_upload_firmware_block(state, data, len, &offset, 1);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0344, patch_version);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0379, 0x01);\r\nif (ret)\r\ngoto error;\r\nret = si2165_upload_firmware_block(state, data, len,\r\n&offset, block_count);\r\nif (ret < 0) {\r\ndev_err(&state->i2c->dev,\r\n"%s: firmware could not be uploaded\n",\r\nKBUILD_MODNAME);\r\ngoto error;\r\n}\r\nret = si2165_readreg16(state, 0x037a, &val16);\r\nif (ret)\r\ngoto error;\r\nif (val16 != crc_expected) {\r\ndev_err(&state->i2c->dev,\r\n"%s: firmware crc mismatch %04x != %04x\n",\r\nKBUILD_MODNAME, val16, crc_expected);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = si2165_upload_firmware_block(state, data, len, &offset, 5);\r\nif (ret)\r\ngoto error;\r\nif (len != offset) {\r\ndev_err(&state->i2c->dev,\r\n"%s: firmware len mismatch %04x != %04x\n",\r\nKBUILD_MODNAME, len, offset);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = si2165_writereg_mask8(state, 0x0341, 0x02, 0x02);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg_mask8(state, 0x035c, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto error;\r\ndev_info(&state->i2c->dev, "%s: fw load finished\n", KBUILD_MODNAME);\r\nret = 0;\r\nstate->firmware_loaded = true;\r\nerror:\r\nif (fw) {\r\nrelease_firmware(fw);\r\nfw = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int si2165_init(struct dvb_frontend *fe)\r\n{\r\nint ret = 0;\r\nstruct si2165_state *state = fe->demodulator_priv;\r\nu8 val;\r\nu8 patch_version = 0x00;\r\ndprintk("%s: called\n", __func__);\r\nret = si2165_writereg8(state, 0x0000, state->config.chip_mode);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0104, 0x01);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_readreg8(state, 0x0000, &val);\r\nif (ret < 0)\r\ngoto error;\r\nif (val != state->config.chip_mode) {\r\ndev_err(&state->i2c->dev, "%s: could not set chip_mode\n",\r\nKBUILD_MODNAME);\r\nreturn -EINVAL;\r\n}\r\nret = si2165_writereg8(state, 0x018b, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0190, 0x01);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0170, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0171, 0x07);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0646, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0641, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_init_pll(state);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0050, 0x01);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0096, 0x01);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_wait_init_done(state);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x0050, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg16(state, 0x0470, 0x7530);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_readreg8(state, 0x0344, &patch_version);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg8(state, 0x00cb, 0x00);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_writereg32(state, 0x0348, 0xf4000000);\r\nif (ret < 0)\r\ngoto error;\r\nret = si2165_readreg8(state, 0x0341, &val);\r\nif (ret < 0)\r\ngoto error;\r\nif (patch_version == 0x00) {\r\nret = si2165_upload_firmware(state);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nret = si2165_writereg8(state, 0x04e4, 0x20);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg16(state, 0x04ef, 0x00fe);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg24(state, 0x04f4, 0x555555);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg8(state, 0x04e5, 0x01);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int si2165_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct si2165_state *state = fe->demodulator_priv;\r\nret = si2165_writereg8(state, 0x0104, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg8(state, 0x0000, SI2165_MODE_OFF);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int si2165_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nint ret;\r\nu8 fec_lock = 0;\r\nstruct si2165_state *state = fe->demodulator_priv;\r\nif (!state->has_dvbt)\r\nreturn -EINVAL;\r\nret = si2165_readreg8(state, 0x4e0, &fec_lock);\r\nif (ret < 0)\r\nreturn ret;\r\n*status = 0;\r\nif (fec_lock & 0x01) {\r\n*status |= FE_HAS_SIGNAL;\r\n*status |= FE_HAS_CARRIER;\r\n*status |= FE_HAS_VITERBI;\r\n*status |= FE_HAS_SYNC;\r\n*status |= FE_HAS_LOCK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int si2165_set_oversamp(struct si2165_state *state, u32 dvb_rate)\r\n{\r\nu64 oversamp;\r\nu32 reg_value;\r\noversamp = si2165_get_fe_clk(state);\r\noversamp <<= 23;\r\ndo_div(oversamp, dvb_rate);\r\nreg_value = oversamp & 0x3fffffff;\r\ndprintk("%s: Write oversamp=%#x\n", __func__, reg_value);\r\nreturn si2165_writereg32(state, 0x00e4, reg_value);\r\n}\r\nstatic int si2165_set_if_freq_shift(struct si2165_state *state)\r\n{\r\nstruct dvb_frontend *fe = &state->fe;\r\nu64 if_freq_shift;\r\ns32 reg_value = 0;\r\nu32 fe_clk = si2165_get_fe_clk(state);\r\nu32 IF = 0;\r\nif (!fe->ops.tuner_ops.get_if_frequency) {\r\ndev_err(&state->i2c->dev,\r\n"%s: Error: get_if_frequency() not defined at tuner. Can't work without it!\n",\r\nKBUILD_MODNAME);\r\nreturn -EINVAL;\r\n}\r\nfe->ops.tuner_ops.get_if_frequency(fe, &IF);\r\nif_freq_shift = IF;\r\nif_freq_shift <<= 29;\r\ndo_div(if_freq_shift, fe_clk);\r\nreg_value = (s32)if_freq_shift;\r\nif (state->config.inversion)\r\nreg_value = -reg_value;\r\nreg_value = reg_value & 0x1fffffff;\r\nreturn si2165_writereg32(state, 0x00e8, reg_value);\r\n}\r\nstatic int si2165_set_frontend_dvbt(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct si2165_state *state = fe->demodulator_priv;\r\nu32 dvb_rate = 0;\r\nu16 bw10k;\r\nu32 bw_hz = p->bandwidth_hz;\r\ndprintk("%s: called\n", __func__);\r\nif (!state->has_dvbt)\r\nreturn -EINVAL;\r\nif (bw_hz == 0)\r\nreturn -EINVAL;\r\ndvb_rate = bw_hz * 8 / 7;\r\nbw10k = bw_hz / 10000;\r\nret = si2165_adjust_pll_divl(state, 12);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg16(state, 0x0308, bw10k);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_set_oversamp(state, dvb_rate);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_write_reg_list(state, dvbt_regs, ARRAY_SIZE(dvbt_regs));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int si2165_set_frontend_dvbc(struct dvb_frontend *fe)\r\n{\r\nstruct si2165_state *state = fe->demodulator_priv;\r\nint ret;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nconst u32 dvb_rate = p->symbol_rate;\r\nconst u32 bw_hz = p->bandwidth_hz;\r\nif (!state->has_dvbc)\r\nreturn -EINVAL;\r\nif (dvb_rate == 0)\r\nreturn -EINVAL;\r\nret = si2165_adjust_pll_divl(state, 14);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_set_oversamp(state, dvb_rate);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg32(state, 0x00c4, bw_hz);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_write_reg_list(state, dvbc_regs, ARRAY_SIZE(dvbc_regs));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int si2165_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct si2165_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu32 delsys = p->delivery_system;\r\nint ret;\r\nu8 val[3];\r\nret = si2165_set_if_freq_shift(state);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (delsys) {\r\ncase SYS_DVBT:\r\nret = si2165_set_frontend_dvbt(fe);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = si2165_set_frontend_dvbc(fe);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = si2165_writereg32(state, 0x0348, 0xf4000000);\r\nif (ret < 0)\r\nreturn ret;\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nret = si2165_set_if_freq_shift(state);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_readreg8(state, 0x0341, val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg8(state, 0x0341, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg8(state, 0x00c0, 0x00);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg32(state, 0x0384, 0x00000000);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_write_reg_list(state, agc_rewrite,\r\nARRAY_SIZE(agc_rewrite));\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_writereg8(state, 0x02e0, 0x01);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si2165_readreg8(state, 0x0341, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void si2165_release(struct dvb_frontend *fe)\r\n{\r\nstruct si2165_state *state = fe->demodulator_priv;\r\ndprintk("%s: called\n", __func__);\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *si2165_attach(const struct si2165_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct si2165_state *state = NULL;\r\nint n;\r\nint io_ret;\r\nu8 val;\r\nchar rev_char;\r\nconst char *chip_name;\r\nif (config == NULL || i2c == NULL)\r\ngoto error;\r\nstate = kzalloc(sizeof(struct si2165_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->i2c = i2c;\r\nstate->config = *config;\r\nif (state->config.ref_freq_Hz < 4000000\r\n|| state->config.ref_freq_Hz > 27000000) {\r\ndev_err(&state->i2c->dev, "%s: ref_freq of %d Hz not supported by this driver\n",\r\nKBUILD_MODNAME, state->config.ref_freq_Hz);\r\ngoto error;\r\n}\r\nmemcpy(&state->fe.ops, &si2165_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->fe.demodulator_priv = state;\r\nio_ret = si2165_writereg8(state, 0x0000, state->config.chip_mode);\r\nif (io_ret < 0)\r\ngoto error;\r\nio_ret = si2165_readreg8(state, 0x0000, &val);\r\nif (io_ret < 0)\r\ngoto error;\r\nif (val != state->config.chip_mode)\r\ngoto error;\r\nio_ret = si2165_readreg8(state, 0x0023, &state->chip_revcode);\r\nif (io_ret < 0)\r\ngoto error;\r\nio_ret = si2165_readreg8(state, 0x0118, &state->chip_type);\r\nif (io_ret < 0)\r\ngoto error;\r\nio_ret = si2165_writereg8(state, 0x0000, SI2165_MODE_OFF);\r\nif (io_ret < 0)\r\ngoto error;\r\nif (state->chip_revcode < 26)\r\nrev_char = 'A' + state->chip_revcode;\r\nelse\r\nrev_char = '?';\r\nswitch (state->chip_type) {\r\ncase 0x06:\r\nchip_name = "Si2161";\r\nstate->has_dvbt = true;\r\nbreak;\r\ncase 0x07:\r\nchip_name = "Si2165";\r\nstate->has_dvbt = true;\r\nstate->has_dvbc = true;\r\nbreak;\r\ndefault:\r\ndev_err(&state->i2c->dev, "%s: Unsupported Silicon Labs chip (type %d, rev %d)\n",\r\nKBUILD_MODNAME, state->chip_type, state->chip_revcode);\r\ngoto error;\r\n}\r\ndev_info(&state->i2c->dev,\r\n"%s: Detected Silicon Labs %s-%c (type %d, rev %d)\n",\r\nKBUILD_MODNAME, chip_name, rev_char, state->chip_type,\r\nstate->chip_revcode);\r\nstrlcat(state->fe.ops.info.name, chip_name,\r\nsizeof(state->fe.ops.info.name));\r\nn = 0;\r\nif (state->has_dvbt) {\r\nstate->fe.ops.delsys[n++] = SYS_DVBT;\r\nstrlcat(state->fe.ops.info.name, " DVB-T",\r\nsizeof(state->fe.ops.info.name));\r\n}\r\nif (state->has_dvbc) {\r\nstate->fe.ops.delsys[n++] = SYS_DVBC_ANNEX_A;\r\nstrlcat(state->fe.ops.info.name, " DVB-C",\r\nsizeof(state->fe.ops.info.name));\r\n}\r\nreturn &state->fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
