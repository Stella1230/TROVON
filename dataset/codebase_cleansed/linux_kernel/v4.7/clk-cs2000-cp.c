static int cs2000_bset(struct cs2000_priv *priv, u8 addr, u8 mask, u8 val)\r\n{\r\ns32 data;\r\ndata = cs2000_read(priv, addr);\r\nif (data < 0)\r\nreturn data;\r\ndata &= ~mask;\r\ndata |= (val & mask);\r\nreturn cs2000_write(priv, addr, data);\r\n}\r\nstatic int cs2000_enable_dev_config(struct cs2000_priv *priv, bool enable)\r\n{\r\nint ret;\r\nret = cs2000_bset(priv, DEVICE_CFG1, ENDEV1,\r\nenable ? ENDEV1 : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_bset(priv, GLOBAL_CFG, ENDEV2,\r\nenable ? ENDEV2 : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cs2000_clk_in_bound_rate(struct cs2000_priv *priv,\r\nu32 rate_in)\r\n{\r\nu32 val;\r\nif (rate_in >= 32000000 && rate_in < 56000000)\r\nval = 0x0;\r\nelse if (rate_in >= 16000000 && rate_in < 28000000)\r\nval = 0x1;\r\nelse if (rate_in >= 8000000 && rate_in < 14000000)\r\nval = 0x2;\r\nelse\r\nreturn -EINVAL;\r\nreturn cs2000_bset(priv, FUNC_CFG1, 0x3 << 3, val << 3);\r\n}\r\nstatic int cs2000_wait_pll_lock(struct cs2000_priv *priv)\r\n{\r\nstruct device *dev = priv_to_dev(priv);\r\ns32 val;\r\nunsigned int i;\r\nfor (i = 0; i < 256; i++) {\r\nval = cs2000_read(priv, DEVICE_CTRL);\r\nif (val < 0)\r\nreturn val;\r\nif (!(val & PLL_UNLOCK))\r\nreturn 0;\r\nudelay(1);\r\n}\r\ndev_err(dev, "pll lock failed\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int cs2000_clk_out_enable(struct cs2000_priv *priv, bool enable)\r\n{\r\nreturn cs2000_write(priv, DEVICE_CTRL, enable ? 0 : 0x3);\r\n}\r\nstatic u32 cs2000_rate_to_ratio(u32 rate_in, u32 rate_out)\r\n{\r\nu64 ratio;\r\nratio = (u64)rate_out << 20;\r\ndo_div(ratio, rate_in);\r\nreturn ratio;\r\n}\r\nstatic unsigned long cs2000_ratio_to_rate(u32 ratio, u32 rate_in)\r\n{\r\nu64 rate_out;\r\nrate_out = (u64)ratio * rate_in;\r\nreturn rate_out >> 20;\r\n}\r\nstatic int cs2000_ratio_set(struct cs2000_priv *priv,\r\nint ch, u32 rate_in, u32 rate_out)\r\n{\r\nu32 val;\r\nunsigned int i;\r\nint ret;\r\nif (CH_SIZE_ERR(ch))\r\nreturn -EINVAL;\r\nval = cs2000_rate_to_ratio(rate_in, rate_out);\r\nfor (i = 0; i < RATIO_REG_SIZE; i++) {\r\nret = cs2000_write(priv,\r\nRatio_Add(ch, i),\r\nRatio_Val(val, i));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 cs2000_ratio_get(struct cs2000_priv *priv, int ch)\r\n{\r\ns32 tmp;\r\nu32 val;\r\nunsigned int i;\r\nval = 0;\r\nfor (i = 0; i < RATIO_REG_SIZE; i++) {\r\ntmp = cs2000_read(priv, Ratio_Add(ch, i));\r\nif (tmp < 0)\r\nreturn 0;\r\nval |= Val_Ratio(tmp, i);\r\n}\r\nreturn val;\r\n}\r\nstatic int cs2000_ratio_select(struct cs2000_priv *priv, int ch)\r\n{\r\nint ret;\r\nif (CH_SIZE_ERR(ch))\r\nreturn -EINVAL;\r\nret = cs2000_bset(priv, DEVICE_CFG1, RSEL_MASK, RSEL(ch));\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_write(priv, DEVICE_CFG2, 0x0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic unsigned long cs2000_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct cs2000_priv *priv = hw_to_priv(hw);\r\nint ch = 0;\r\nu32 ratio;\r\nratio = cs2000_ratio_get(priv, ch);\r\nreturn cs2000_ratio_to_rate(ratio, parent_rate);\r\n}\r\nstatic long cs2000_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nu32 ratio;\r\nratio = cs2000_rate_to_ratio(*parent_rate, rate);\r\nreturn cs2000_ratio_to_rate(ratio, *parent_rate);\r\n}\r\nstatic int __cs2000_set_rate(struct cs2000_priv *priv, int ch,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nint ret;\r\nret = cs2000_clk_in_bound_rate(priv, parent_rate);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_ratio_set(priv, ch, parent_rate, rate);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_ratio_select(priv, ch);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cs2000_set_rate(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nstruct cs2000_priv *priv = hw_to_priv(hw);\r\nint ch = 0;\r\nreturn __cs2000_set_rate(priv, ch, rate, parent_rate);\r\n}\r\nstatic int cs2000_enable(struct clk_hw *hw)\r\n{\r\nstruct cs2000_priv *priv = hw_to_priv(hw);\r\nint ret;\r\nret = cs2000_enable_dev_config(priv, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_clk_out_enable(priv, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_wait_pll_lock(priv);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic void cs2000_disable(struct clk_hw *hw)\r\n{\r\nstruct cs2000_priv *priv = hw_to_priv(hw);\r\ncs2000_enable_dev_config(priv, false);\r\ncs2000_clk_out_enable(priv, false);\r\n}\r\nstatic u8 cs2000_get_parent(struct clk_hw *hw)\r\n{\r\nreturn REF_CLK;\r\n}\r\nstatic int cs2000_clk_get(struct cs2000_priv *priv)\r\n{\r\nstruct i2c_client *client = priv_to_client(priv);\r\nstruct device *dev = &client->dev;\r\nstruct clk *clk_in, *ref_clk;\r\nclk_in = devm_clk_get(dev, "clk_in");\r\nif (IS_ERR(clk_in))\r\nreturn -EPROBE_DEFER;\r\nref_clk = devm_clk_get(dev, "ref_clk");\r\nif (IS_ERR(ref_clk))\r\nreturn -EPROBE_DEFER;\r\npriv->clk_in = clk_in;\r\npriv->ref_clk = ref_clk;\r\nreturn 0;\r\n}\r\nstatic int cs2000_clk_register(struct cs2000_priv *priv)\r\n{\r\nstruct device *dev = priv_to_dev(priv);\r\nstruct device_node *np = dev->of_node;\r\nstruct clk_init_data init;\r\nconst char *name = np->name;\r\nstruct clk *clk;\r\nstatic const char *parent_names[CLK_MAX];\r\nint ch = 0;\r\nint rate;\r\nint ret;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nrate = clk_get_rate(priv->ref_clk);\r\nret = __cs2000_set_rate(priv, ch, rate, rate);\r\nif (ret < 0)\r\nreturn ret;\r\nparent_names[CLK_IN] = __clk_get_name(priv->clk_in);\r\nparent_names[REF_CLK] = __clk_get_name(priv->ref_clk);\r\ninit.name = name;\r\ninit.ops = &cs2000_ops;\r\ninit.flags = CLK_SET_RATE_GATE;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = ARRAY_SIZE(parent_names);\r\npriv->hw.init = &init;\r\nclk = clk_register(dev, &priv->hw);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nret = of_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nif (ret < 0) {\r\nclk_unregister(clk);\r\nreturn ret;\r\n}\r\npriv->clk_out = clk;\r\nreturn 0;\r\n}\r\nstatic int cs2000_version_print(struct cs2000_priv *priv)\r\n{\r\nstruct i2c_client *client = priv_to_client(priv);\r\nstruct device *dev = &client->dev;\r\ns32 val;\r\nconst char *revision;\r\nval = cs2000_read(priv, DEVICE_ID);\r\nif (val < 0)\r\nreturn val;\r\nif (val >> 3)\r\nreturn -EIO;\r\nswitch (val & REVISION_MASK) {\r\ncase REVISION_B2_B3:\r\nrevision = "B2 / B3";\r\nbreak;\r\ncase REVISION_C1:\r\nrevision = "C1";\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\ndev_info(dev, "revision - %s\n", revision);\r\nreturn 0;\r\n}\r\nstatic int cs2000_remove(struct i2c_client *client)\r\n{\r\nstruct cs2000_priv *priv = i2c_get_clientdata(client);\r\nstruct device *dev = &client->dev;\r\nstruct device_node *np = dev->of_node;\r\nof_clk_del_provider(np);\r\nclk_unregister(priv->clk_out);\r\nreturn 0;\r\n}\r\nstatic int cs2000_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs2000_priv *priv;\r\nstruct device *dev = &client->dev;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->client = client;\r\ni2c_set_clientdata(client, priv);\r\nret = cs2000_clk_get(priv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_clk_register(priv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cs2000_version_print(priv);\r\nif (ret < 0)\r\ngoto probe_err;\r\nreturn 0;\r\nprobe_err:\r\ncs2000_remove(client);\r\nreturn ret;\r\n}
