static void convert_ticks_to_time(struct timer_group_priv *priv,\r\nconst u64 ticks, struct timeval *time)\r\n{\r\nu64 tmp_sec;\r\ntime->tv_sec = (__kernel_time_t)div_u64(ticks, priv->timerfreq);\r\ntmp_sec = (u64)time->tv_sec * (u64)priv->timerfreq;\r\ntime->tv_usec = 0;\r\nif (tmp_sec <= ticks)\r\ntime->tv_usec = (__kernel_suseconds_t)\r\ndiv_u64((ticks - tmp_sec) * 1000000, priv->timerfreq);\r\nreturn;\r\n}\r\nstatic int convert_time_to_ticks(struct timer_group_priv *priv,\r\nconst struct timeval *time, u64 *ticks)\r\n{\r\nu64 max_value;\r\nu64 tmp = 0;\r\nu64 tmp_sec;\r\nu64 tmp_ms;\r\nu64 tmp_us;\r\nmax_value = div_u64(ULLONG_MAX, priv->timerfreq);\r\nif (time->tv_sec > max_value ||\r\n(time->tv_sec == max_value && time->tv_usec > 0))\r\nreturn -EINVAL;\r\ntmp_sec = (u64)time->tv_sec * (u64)priv->timerfreq;\r\ntmp += tmp_sec;\r\ntmp_ms = time->tv_usec / 1000;\r\ntmp_ms = div_u64((u64)tmp_ms * (u64)priv->timerfreq, 1000);\r\ntmp += tmp_ms;\r\ntmp_us = time->tv_usec % 1000;\r\ntmp_us = div_u64((u64)tmp_us * (u64)priv->timerfreq, 1000000);\r\ntmp += tmp_us;\r\n*ticks = tmp;\r\nreturn 0;\r\n}\r\nstatic struct mpic_timer *detect_idle_cascade_timer(\r\nstruct timer_group_priv *priv)\r\n{\r\nstruct cascade_priv *casc_priv;\r\nunsigned int map;\r\nunsigned int array_size = ARRAY_SIZE(cascade_timer);\r\nunsigned int num;\r\nunsigned int i;\r\nunsigned long flags;\r\ncasc_priv = cascade_timer;\r\nfor (i = 0; i < array_size; i++) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmap = casc_priv->cascade_map & priv->idle;\r\nif (map == casc_priv->cascade_map) {\r\nnum = casc_priv->timer_num;\r\npriv->timer[num].cascade_handle = casc_priv;\r\npriv->idle &= ~casc_priv->cascade_map;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn &priv->timer[num];\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ncasc_priv++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int set_cascade_timer(struct timer_group_priv *priv, u64 ticks,\r\nunsigned int num)\r\n{\r\nstruct cascade_priv *casc_priv;\r\nu32 tcr;\r\nu32 tmp_ticks;\r\nu32 rem_ticks;\r\ncasc_priv = priv->timer[num].cascade_handle;\r\nif (!casc_priv)\r\nreturn -EINVAL;\r\ntcr = casc_priv->tcr_value |\r\n(casc_priv->tcr_value << MPIC_TIMER_TCR_ROVR_OFFSET);\r\nsetbits32(priv->group_tcr, tcr);\r\ntmp_ticks = div_u64_rem(ticks, MAX_TICKS_CASCADE, &rem_ticks);\r\nout_be32(&priv->regs[num].gtccr, 0);\r\nout_be32(&priv->regs[num].gtbcr, tmp_ticks | TIMER_STOP);\r\nout_be32(&priv->regs[num - 1].gtccr, 0);\r\nout_be32(&priv->regs[num - 1].gtbcr, rem_ticks);\r\nreturn 0;\r\n}\r\nstatic struct mpic_timer *get_cascade_timer(struct timer_group_priv *priv,\r\nu64 ticks)\r\n{\r\nstruct mpic_timer *allocated_timer;\r\nconst u64 max_ticks = (u64)MAX_TICKS * (u64)MAX_TICKS_CASCADE;\r\nint ret;\r\nif (ticks > max_ticks)\r\nreturn NULL;\r\nallocated_timer = detect_idle_cascade_timer(priv);\r\nif (!allocated_timer)\r\nreturn NULL;\r\nret = set_cascade_timer(priv, ticks, allocated_timer->num);\r\nif (ret < 0)\r\nreturn NULL;\r\nreturn allocated_timer;\r\n}\r\nstatic struct mpic_timer *get_timer(const struct timeval *time)\r\n{\r\nstruct timer_group_priv *priv;\r\nstruct mpic_timer *timer;\r\nu64 ticks;\r\nunsigned int num;\r\nunsigned int i;\r\nunsigned long flags;\r\nint ret;\r\nlist_for_each_entry(priv, &timer_group_list, node) {\r\nret = convert_time_to_ticks(priv, time, &ticks);\r\nif (ret < 0)\r\nreturn NULL;\r\nif (ticks > MAX_TICKS) {\r\nif (!(priv->flags & FSL_GLOBAL_TIMER))\r\nreturn NULL;\r\ntimer = get_cascade_timer(priv, ticks);\r\nif (!timer)\r\ncontinue;\r\nreturn timer;\r\n}\r\nfor (i = 0; i < TIMERS_PER_GROUP; i++) {\r\nnum = TIMERS_PER_GROUP - 1 - i;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->idle & (1 << i)) {\r\npriv->idle &= ~(1 << i);\r\nout_be32(&priv->regs[num].gtbcr,\r\nticks | TIMER_STOP);\r\nout_be32(&priv->regs[num].gtccr, 0);\r\npriv->timer[num].cascade_handle = NULL;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn &priv->timer[num];\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid mpic_start_timer(struct mpic_timer *handle)\r\n{\r\nstruct timer_group_priv *priv = container_of(handle,\r\nstruct timer_group_priv, timer[handle->num]);\r\nclrbits32(&priv->regs[handle->num].gtbcr, TIMER_STOP);\r\n}\r\nvoid mpic_stop_timer(struct mpic_timer *handle)\r\n{\r\nstruct timer_group_priv *priv = container_of(handle,\r\nstruct timer_group_priv, timer[handle->num]);\r\nstruct cascade_priv *casc_priv;\r\nsetbits32(&priv->regs[handle->num].gtbcr, TIMER_STOP);\r\ncasc_priv = priv->timer[handle->num].cascade_handle;\r\nif (casc_priv) {\r\nout_be32(&priv->regs[handle->num].gtccr, 0);\r\nout_be32(&priv->regs[handle->num - 1].gtccr, 0);\r\n} else {\r\nout_be32(&priv->regs[handle->num].gtccr, 0);\r\n}\r\n}\r\nvoid mpic_get_remain_time(struct mpic_timer *handle, struct timeval *time)\r\n{\r\nstruct timer_group_priv *priv = container_of(handle,\r\nstruct timer_group_priv, timer[handle->num]);\r\nstruct cascade_priv *casc_priv;\r\nu64 ticks;\r\nu32 tmp_ticks;\r\ncasc_priv = priv->timer[handle->num].cascade_handle;\r\nif (casc_priv) {\r\ntmp_ticks = in_be32(&priv->regs[handle->num].gtccr);\r\ntmp_ticks &= ~GTCCR_TOG;\r\nticks = ((u64)tmp_ticks & UINT_MAX) * (u64)MAX_TICKS_CASCADE;\r\ntmp_ticks = in_be32(&priv->regs[handle->num - 1].gtccr);\r\nticks += tmp_ticks;\r\n} else {\r\nticks = in_be32(&priv->regs[handle->num].gtccr);\r\nticks &= ~GTCCR_TOG;\r\n}\r\nconvert_ticks_to_time(priv, ticks, time);\r\n}\r\nvoid mpic_free_timer(struct mpic_timer *handle)\r\n{\r\nstruct timer_group_priv *priv = container_of(handle,\r\nstruct timer_group_priv, timer[handle->num]);\r\nstruct cascade_priv *casc_priv;\r\nunsigned long flags;\r\nmpic_stop_timer(handle);\r\ncasc_priv = priv->timer[handle->num].cascade_handle;\r\nfree_irq(priv->timer[handle->num].irq, priv->timer[handle->num].dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (casc_priv) {\r\nu32 tcr;\r\ntcr = casc_priv->tcr_value | (casc_priv->tcr_value <<\r\nMPIC_TIMER_TCR_ROVR_OFFSET);\r\nclrbits32(priv->group_tcr, tcr);\r\npriv->idle |= casc_priv->cascade_map;\r\npriv->timer[handle->num].cascade_handle = NULL;\r\n} else {\r\npriv->idle |= TIMER_OFFSET(handle->num);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstruct mpic_timer *mpic_request_timer(irq_handler_t fn, void *dev,\r\nconst struct timeval *time)\r\n{\r\nstruct mpic_timer *allocated_timer;\r\nint ret;\r\nif (list_empty(&timer_group_list))\r\nreturn NULL;\r\nif (!(time->tv_sec + time->tv_usec) ||\r\ntime->tv_sec < 0 || time->tv_usec < 0)\r\nreturn NULL;\r\nif (time->tv_usec > ONE_SECOND)\r\nreturn NULL;\r\nallocated_timer = get_timer(time);\r\nif (!allocated_timer)\r\nreturn NULL;\r\nret = request_irq(allocated_timer->irq, fn,\r\nIRQF_TRIGGER_LOW, "global-timer", dev);\r\nif (ret) {\r\nmpic_free_timer(allocated_timer);\r\nreturn NULL;\r\n}\r\nallocated_timer->dev = dev;\r\nreturn allocated_timer;\r\n}\r\nstatic int timer_group_get_freq(struct device_node *np,\r\nstruct timer_group_priv *priv)\r\n{\r\nu32 div;\r\nif (priv->flags & FSL_GLOBAL_TIMER) {\r\nstruct device_node *dn;\r\ndn = of_find_compatible_node(NULL, NULL, "fsl,mpic");\r\nif (dn) {\r\nof_property_read_u32(dn, "clock-frequency",\r\n&priv->timerfreq);\r\nof_node_put(dn);\r\n}\r\n}\r\nif (priv->timerfreq <= 0)\r\nreturn -EINVAL;\r\nif (priv->flags & FSL_GLOBAL_TIMER) {\r\ndiv = (1 << (MPIC_TIMER_TCR_CLKDIV >> 8)) * 8;\r\npriv->timerfreq /= div;\r\n}\r\nreturn 0;\r\n}\r\nstatic int timer_group_get_irq(struct device_node *np,\r\nstruct timer_group_priv *priv)\r\n{\r\nconst u32 all_timer[] = { 0, TIMERS_PER_GROUP };\r\nconst u32 *p;\r\nu32 offset;\r\nu32 count;\r\nunsigned int i;\r\nunsigned int j;\r\nunsigned int irq_index = 0;\r\nunsigned int irq;\r\nint len;\r\np = of_get_property(np, "fsl,available-ranges", &len);\r\nif (p && len % (2 * sizeof(u32)) != 0) {\r\npr_err("%s: malformed available-ranges property.\n",\r\nnp->full_name);\r\nreturn -EINVAL;\r\n}\r\nif (!p) {\r\np = all_timer;\r\nlen = sizeof(all_timer);\r\n}\r\nlen /= 2 * sizeof(u32);\r\nfor (i = 0; i < len; i++) {\r\noffset = p[i * 2];\r\ncount = p[i * 2 + 1];\r\nfor (j = 0; j < count; j++) {\r\nirq = irq_of_parse_and_map(np, irq_index);\r\nif (!irq) {\r\npr_err("%s: irq parse and map failed.\n",\r\nnp->full_name);\r\nreturn -EINVAL;\r\n}\r\npriv->idle |= TIMER_OFFSET((offset + j));\r\npriv->timer[offset + j].irq = irq;\r\npriv->timer[offset + j].num = offset + j;\r\nirq_index++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void timer_group_init(struct device_node *np)\r\n{\r\nstruct timer_group_priv *priv;\r\nunsigned int i = 0;\r\nint ret;\r\npriv = kzalloc(sizeof(struct timer_group_priv), GFP_KERNEL);\r\nif (!priv) {\r\npr_err("%s: cannot allocate memory for group.\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_device_is_compatible(np, "fsl,mpic-global-timer"))\r\npriv->flags |= FSL_GLOBAL_TIMER;\r\npriv->regs = of_iomap(np, i++);\r\nif (!priv->regs) {\r\npr_err("%s: cannot ioremap timer register address.\n",\r\nnp->full_name);\r\ngoto out;\r\n}\r\nif (priv->flags & FSL_GLOBAL_TIMER) {\r\npriv->group_tcr = of_iomap(np, i++);\r\nif (!priv->group_tcr) {\r\npr_err("%s: cannot ioremap tcr address.\n",\r\nnp->full_name);\r\ngoto out;\r\n}\r\n}\r\nret = timer_group_get_freq(np, priv);\r\nif (ret < 0) {\r\npr_err("%s: cannot get timer frequency.\n", np->full_name);\r\ngoto out;\r\n}\r\nret = timer_group_get_irq(np, priv);\r\nif (ret < 0) {\r\npr_err("%s: cannot get timer irqs.\n", np->full_name);\r\ngoto out;\r\n}\r\nspin_lock_init(&priv->lock);\r\nif (priv->flags & FSL_GLOBAL_TIMER)\r\nsetbits32(priv->group_tcr, MPIC_TIMER_TCR_CLKDIV);\r\nlist_add_tail(&priv->node, &timer_group_list);\r\nreturn;\r\nout:\r\nif (priv->regs)\r\niounmap(priv->regs);\r\nif (priv->group_tcr)\r\niounmap(priv->group_tcr);\r\nkfree(priv);\r\n}\r\nstatic void mpic_timer_resume(void)\r\n{\r\nstruct timer_group_priv *priv;\r\nlist_for_each_entry(priv, &timer_group_list, node) {\r\nif (priv->flags & FSL_GLOBAL_TIMER)\r\nsetbits32(priv->group_tcr, MPIC_TIMER_TCR_CLKDIV);\r\n}\r\n}\r\nstatic int __init mpic_timer_init(void)\r\n{\r\nstruct device_node *np = NULL;\r\nfor_each_matching_node(np, mpic_timer_ids)\r\ntimer_group_init(np);\r\nregister_syscore_ops(&mpic_timer_syscore_ops);\r\nif (list_empty(&timer_group_list))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}
