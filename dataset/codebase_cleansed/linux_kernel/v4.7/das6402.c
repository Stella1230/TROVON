static void das6402_set_mode(struct comedi_device *dev,\r\nunsigned int mode)\r\n{\r\noutb(DAS6402_MODE_ENHANCED | mode, dev->iobase + DAS6402_MODE_REG);\r\n}\r\nstatic void das6402_set_extended(struct comedi_device *dev,\r\nunsigned int val)\r\n{\r\noutb(DAS6402_STATUS_W_EXTEND, dev->iobase + DAS6402_STATUS_REG);\r\noutb(DAS6402_STATUS_W_EXTEND | val, dev->iobase + DAS6402_STATUS_REG);\r\noutb(val, dev->iobase + DAS6402_STATUS_REG);\r\n}\r\nstatic void das6402_clear_all_interrupts(struct comedi_device *dev)\r\n{\r\noutb(DAS6402_STATUS_W_CLRINT |\r\nDAS6402_STATUS_W_CLRXTR |\r\nDAS6402_STATUS_W_CLRXIN, dev->iobase + DAS6402_STATUS_REG);\r\n}\r\nstatic void das6402_ai_clear_eoc(struct comedi_device *dev)\r\n{\r\noutb(DAS6402_STATUS_W_CLRINT, dev->iobase + DAS6402_STATUS_REG);\r\n}\r\nstatic unsigned int das6402_ai_read_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int val;\r\nval = inw(dev->iobase + DAS6402_AI_DATA_REG);\r\nif (s->maxdata == 0x0fff)\r\nval >>= 4;\r\nreturn val;\r\n}\r\nstatic irqreturn_t das6402_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int status;\r\nstatus = inb(dev->iobase + DAS6402_STATUS_REG);\r\nif ((status & DAS6402_STATUS_INT) == 0)\r\nreturn IRQ_NONE;\r\nif (status & DAS6402_STATUS_FFULL) {\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\n} else if (status & DAS6402_STATUS_FFNE) {\r\nunsigned int val;\r\nval = das6402_ai_read_sample(dev, s);\r\ncomedi_buf_write_samples(s, &val, 1);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\ndas6402_clear_all_interrupts(dev);\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void das6402_ai_set_mode(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec,\r\nunsigned int mode)\r\n{\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nmode |= DAS6402_MODE_RANGE(range);\r\nif (aref == AREF_GROUND)\r\nmode |= DAS6402_MODE_SE;\r\nif (comedi_range_is_unipolar(s, range))\r\nmode |= DAS6402_MODE_UNI;\r\ndas6402_set_mode(dev, mode);\r\n}\r\nstatic int das6402_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct das6402_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int chan_lo = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int chan_hi = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\r\ndas6402_ai_set_mode(dev, s, cmd->chanlist[0], DAS6402_MODE_FIFONEPTY);\r\noutw(DAS6402_AI_MUX_HI(chan_hi) | DAS6402_AI_MUX_LO(chan_lo),\r\ndev->iobase + DAS6402_AI_MUX_REG);\r\ncomedi_8254_update_divisors(dev->pacer);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\noutb(DAS6402_CTRL_INTE |\r\nDAS6402_CTRL_IRQ(devpriv->irq) |\r\nDAS6402_CTRL_PACER_TRIG, dev->iobase + DAS6402_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic int das6402_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nunsigned int aref = CR_AREF(cmd->chanlist[i]);\r\nif (chan != chan0 + i) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist must be consecutive\n");\r\nreturn -EINVAL;\r\n}\r\nif (range != range0) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist must have the same range\n");\r\nreturn -EINVAL;\r\n}\r\nif (aref != aref0) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist must have the same reference\n");\r\nreturn -EINVAL;\r\n}\r\nif (aref0 == AREF_DIFF && chan > (s->n_chan / 2)) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist differential channel to large\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int das6402_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 10000);\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\narg = cmd->convert_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= das6402_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int das6402_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\noutb(DAS6402_CTRL_SOFT_TRIG, dev->iobase + DAS6402_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic void das6402_ai_soft_trig(struct comedi_device *dev)\r\n{\r\noutw(0, dev->iobase + DAS6402_AI_DATA_REG);\r\n}\r\nstatic int das6402_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inb(dev->iobase + DAS6402_STATUS_REG);\r\nif (status & DAS6402_STATUS_FFNE)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int das6402_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nint ret;\r\nint i;\r\nif (aref == AREF_DIFF && chan > (s->n_chan / 2))\r\nreturn -EINVAL;\r\noutb(DAS6402_CTRL_SOFT_TRIG, dev->iobase + DAS6402_CTRL_REG);\r\ndas6402_ai_set_mode(dev, s, insn->chanspec, DAS6402_MODE_POLLED);\r\noutw(DAS6402_AI_MUX_HI(chan) | DAS6402_AI_MUX_LO(chan),\r\ndev->iobase + DAS6402_AI_MUX_REG);\r\nfor (i = 0; i < insn->n; i++) {\r\ndas6402_ai_clear_eoc(dev);\r\ndas6402_ai_soft_trig(dev);\r\nret = comedi_timeout(dev, s, insn, das6402_ai_eoc, 0);\r\nif (ret)\r\nbreak;\r\ndata[i] = das6402_ai_read_sample(dev, s);\r\n}\r\ndas6402_ai_clear_eoc(dev);\r\nreturn insn->n;\r\n}\r\nstatic int das6402_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct das6402_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val;\r\nint i;\r\nval = devpriv->ao_range;\r\nval &= ~DAS6402_AO_RANGE_MASK(chan);\r\nval |= DAS6402_AO_RANGE(chan, range);\r\nif (val != devpriv->ao_range) {\r\ndevpriv->ao_range = val;\r\noutb(val, dev->iobase + DAS6402_TRIG_REG);\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\ns->readback[chan] = val;\r\nif (s->maxdata == 0x0fff) {\r\nval <<= 4;\r\noutw(val, dev->iobase + DAS6402_AO_DATA_REG(chan));\r\n} else {\r\noutb(val & 0xff,\r\ndev->iobase + DAS6402_AO_LSB_REG(chan));\r\noutb((val >> 8) & 0xff,\r\ndev->iobase + DAS6402_AO_LSB_REG(chan));\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int das6402_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\ninw(dev->iobase + DAS6402_AO_LSB_REG(chan));\r\nreturn comedi_readback_insn_read(dev, s, insn, data);\r\n}\r\nstatic int das6402_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + DAS6402_DI_DO_REG);\r\nreturn insn->n;\r\n}\r\nstatic int das6402_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\noutb(s->state, dev->iobase + DAS6402_DI_DO_REG);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic void das6402_reset(struct comedi_device *dev)\r\n{\r\nstruct das6402_private *devpriv = dev->private;\r\noutb(DAS6402_MODE_ENHANCED, dev->iobase + DAS6402_MODE_REG);\r\ndas6402_set_extended(dev, DAS6402_STATUS_W_10MHZ);\r\noutb(DAS6402_CTRL_SOFT_TRIG, dev->iobase + DAS6402_CTRL_REG);\r\ndas6402_set_mode(dev, DAS6402_MODE_RANGE(0) |\r\nDAS6402_MODE_POLLED |\r\nDAS6402_MODE_SE |\r\nDAS6402_MODE_UNI);\r\noutw(DAS6402_AI_MUX_HI(0) | DAS6402_AI_MUX_LO(0),\r\ndev->iobase + DAS6402_AI_MUX_REG);\r\ndevpriv->ao_range = DAS6402_AO_RANGE(0, 2) | DAS6402_AO_RANGE(1, 2);\r\noutb(devpriv->ao_range, dev->iobase + DAS6402_TRIG_REG);\r\noutw(0, dev->iobase + DAS6402_AO_DATA_REG(0));\r\noutw(0, dev->iobase + DAS6402_AO_DATA_REG(0));\r\ninw(dev->iobase + DAS6402_AO_LSB_REG(0));\r\noutb(0, dev->iobase + DAS6402_DI_DO_REG);\r\ndas6402_clear_all_interrupts(dev);\r\n}\r\nstatic int das6402_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nconst struct das6402_boardinfo *board = dev->board_ptr;\r\nstruct das6402_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_request_region(dev, it->options[0], 0x10);\r\nif (ret)\r\nreturn ret;\r\ndas6402_reset(dev);\r\nif ((1 << it->options[1]) & 0x8cec) {\r\nret = request_irq(it->options[1], das6402_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0) {\r\ndev->irq = it->options[1];\r\nswitch (dev->irq) {\r\ncase 10:\r\ndevpriv->irq = 4;\r\nbreak;\r\ncase 11:\r\ndevpriv->irq = 1;\r\nbreak;\r\ncase 15:\r\ndevpriv->irq = 6;\r\nbreak;\r\ndefault:\r\ndevpriv->irq = dev->irq;\r\nbreak;\r\n}\r\n}\r\n}\r\ndev->pacer = comedi_8254_init(dev->iobase + DAS6402_TIMER_BASE,\r\nI8254_OSC_BASE_10MHZ, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = 64;\r\ns->maxdata = board->maxdata;\r\ns->range_table = &das6402_ai_ranges;\r\ns->insn_read = das6402_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = das6402_ai_cmdtest;\r\ns->do_cmd = das6402_ai_cmd;\r\ns->cancel = das6402_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = board->maxdata;\r\ns->range_table = &das6402_ao_ranges;\r\ns->insn_write = das6402_ao_insn_write;\r\ns->insn_read = das6402_ao_insn_read;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das6402_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das6402_do_insn_bits;\r\nreturn 0;\r\n}
