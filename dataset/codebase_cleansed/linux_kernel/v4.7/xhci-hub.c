static int xhci_create_usb3_bos_desc(struct xhci_hcd *xhci, char *buf,\r\nu16 wLength)\r\n{\r\nint i, ssa_count;\r\nu32 temp;\r\nu16 desc_size, ssp_cap_size, ssa_size = 0;\r\nbool usb3_1 = false;\r\ndesc_size = USB_DT_BOS_SIZE + USB_DT_USB_SS_CAP_SIZE;\r\nssp_cap_size = sizeof(usb_bos_descriptor) - desc_size;\r\nif (xhci->usb3_rhub.min_rev >= 0x01) {\r\nif (xhci->usb3_rhub.psi_count) {\r\nssa_count = xhci->usb3_rhub.psi_uid_count * 2;\r\nssa_size = ssa_count * sizeof(u32);\r\nssp_cap_size -= 16;\r\n}\r\ndesc_size += ssp_cap_size;\r\nusb3_1 = true;\r\n}\r\nmemcpy(buf, &usb_bos_descriptor, min(desc_size, wLength));\r\nif (usb3_1) {\r\nbuf[4] += 1;\r\nput_unaligned_le16(desc_size + ssa_size, &buf[2]);\r\n}\r\nif (wLength < USB_DT_BOS_SIZE + USB_DT_USB_SS_CAP_SIZE)\r\nreturn wLength;\r\ntemp = readl(&xhci->cap_regs->hcc_params);\r\nif (HCC_LTC(temp))\r\nbuf[8] |= USB_LTM_SUPPORT;\r\nif ((xhci->quirks & XHCI_LPM_SUPPORT)) {\r\ntemp = readl(&xhci->cap_regs->hcs_params3);\r\nbuf[12] = HCS_U1_LATENCY(temp);\r\nput_unaligned_le16(HCS_U2_LATENCY(temp), &buf[13]);\r\n}\r\nif (usb3_1 && xhci->usb3_rhub.psi_count) {\r\nu32 ssp_cap_base, bm_attrib, psi;\r\nint offset;\r\nssp_cap_base = USB_DT_BOS_SIZE + USB_DT_USB_SS_CAP_SIZE;\r\nif (wLength < desc_size)\r\nreturn wLength;\r\nbuf[ssp_cap_base] = ssp_cap_size + ssa_size;\r\nbm_attrib = (ssa_count - 1) & 0x1f;\r\nbm_attrib |= (xhci->usb3_rhub.psi_uid_count - 1) << 5;\r\nput_unaligned_le32(bm_attrib, &buf[ssp_cap_base + 4]);\r\nif (wLength < desc_size + ssa_size)\r\nreturn wLength;\r\noffset = desc_size;\r\nfor (i = 0; i < xhci->usb3_rhub.psi_count; i++) {\r\npsi = xhci->usb3_rhub.psi[i];\r\npsi &= ~USB_SSP_SUBLINK_SPEED_RSVD;\r\nif ((psi & PLT_MASK) == PLT_SYM) {\r\nput_unaligned_le32(psi, &buf[offset]);\r\npsi |= 1 << 7;\r\noffset += 4;\r\nif (offset >= desc_size + ssa_size)\r\nreturn desc_size + ssa_size;\r\n} else if ((psi & PLT_MASK) == PLT_ASYM_RX) {\r\npsi ^= PLT_MASK;\r\n}\r\nput_unaligned_le32(psi, &buf[offset]);\r\noffset += 4;\r\nif (offset >= desc_size + ssa_size)\r\nreturn desc_size + ssa_size;\r\n}\r\n}\r\nreturn desc_size + ssa_size;\r\n}\r\nstatic void xhci_common_hub_descriptor(struct xhci_hcd *xhci,\r\nstruct usb_hub_descriptor *desc, int ports)\r\n{\r\nu16 temp;\r\ndesc->bPwrOn2PwrGood = 10;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ports;\r\ntemp = 0;\r\nif (HCC_PPC(xhci->hcc_params))\r\ntemp |= HUB_CHAR_INDV_PORT_LPSM;\r\nelse\r\ntemp |= HUB_CHAR_NO_LPSM;\r\ntemp |= HUB_CHAR_INDV_PORT_OCPM;\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\n}\r\nstatic void xhci_usb2_hub_descriptor(struct usb_hcd *hcd, struct xhci_hcd *xhci,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nint ports;\r\nu16 temp;\r\n__u8 port_removable[(USB_MAXCHILDREN + 1 + 7) / 8];\r\nu32 portsc;\r\nunsigned int i;\r\nports = xhci->num_usb2_ports;\r\nxhci_common_hub_descriptor(xhci, desc, ports);\r\ndesc->bDescriptorType = USB_DT_HUB;\r\ntemp = 1 + (ports / 8);\r\ndesc->bDescLength = USB_DT_HUB_NONVAR_SIZE + 2 * temp;\r\nmemset(port_removable, 0, sizeof(port_removable));\r\nfor (i = 0; i < ports; i++) {\r\nportsc = readl(xhci->usb2_ports[i]);\r\nif (portsc & PORT_DEV_REMOVE)\r\nport_removable[(i + 1) / 8] |= 1 << ((i + 1) % 8);\r\n}\r\nmemset(desc->u.hs.DeviceRemovable, 0xff,\r\nsizeof(desc->u.hs.DeviceRemovable));\r\nmemset(desc->u.hs.PortPwrCtrlMask, 0xff,\r\nsizeof(desc->u.hs.PortPwrCtrlMask));\r\nfor (i = 0; i < (ports + 1 + 7) / 8; i++)\r\nmemset(&desc->u.hs.DeviceRemovable[i], port_removable[i],\r\nsizeof(__u8));\r\n}\r\nstatic void xhci_usb3_hub_descriptor(struct usb_hcd *hcd, struct xhci_hcd *xhci,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nint ports;\r\nu16 port_removable;\r\nu32 portsc;\r\nunsigned int i;\r\nports = xhci->num_usb3_ports;\r\nxhci_common_hub_descriptor(xhci, desc, ports);\r\ndesc->bDescriptorType = USB_DT_SS_HUB;\r\ndesc->bDescLength = USB_DT_SS_HUB_SIZE;\r\ndesc->u.ss.bHubHdrDecLat = 0;\r\ndesc->u.ss.wHubDelay = 0;\r\nport_removable = 0;\r\nfor (i = 0; i < ports; i++) {\r\nportsc = readl(xhci->usb3_ports[i]);\r\nif (portsc & PORT_DEV_REMOVE)\r\nport_removable |= 1 << (i + 1);\r\n}\r\ndesc->u.ss.DeviceRemovable = cpu_to_le16(port_removable);\r\n}\r\nstatic void xhci_hub_descriptor(struct usb_hcd *hcd, struct xhci_hcd *xhci,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nif (hcd->speed >= HCD_USB3)\r\nxhci_usb3_hub_descriptor(hcd, xhci, desc);\r\nelse\r\nxhci_usb2_hub_descriptor(hcd, xhci, desc);\r\n}\r\nstatic unsigned int xhci_port_speed(unsigned int port_status)\r\n{\r\nif (DEV_LOWSPEED(port_status))\r\nreturn USB_PORT_STAT_LOW_SPEED;\r\nif (DEV_HIGHSPEED(port_status))\r\nreturn USB_PORT_STAT_HIGH_SPEED;\r\nreturn 0;\r\n}\r\nu32 xhci_port_state_to_neutral(u32 state)\r\n{\r\nreturn (state & XHCI_PORT_RO) | (state & XHCI_PORT_RWS);\r\n}\r\nint xhci_find_slot_id_by_port(struct usb_hcd *hcd, struct xhci_hcd *xhci,\r\nu16 port)\r\n{\r\nint slot_id;\r\nint i;\r\nenum usb_device_speed speed;\r\nslot_id = 0;\r\nfor (i = 0; i < MAX_HC_SLOTS; i++) {\r\nif (!xhci->devs[i])\r\ncontinue;\r\nspeed = xhci->devs[i]->udev->speed;\r\nif (((speed >= USB_SPEED_SUPER) == (hcd->speed >= HCD_USB3))\r\n&& xhci->devs[i]->fake_port == port) {\r\nslot_id = i;\r\nbreak;\r\n}\r\n}\r\nreturn slot_id;\r\n}\r\nstatic int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)\r\n{\r\nstruct xhci_virt_device *virt_dev;\r\nstruct xhci_command *cmd;\r\nunsigned long flags;\r\nint ret;\r\nint i;\r\nret = 0;\r\nvirt_dev = xhci->devs[slot_id];\r\ncmd = xhci_alloc_command(xhci, false, true, GFP_NOIO);\r\nif (!cmd) {\r\nxhci_dbg(xhci, "Couldn't allocate command structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nfor (i = LAST_EP_INDEX; i > 0; i--) {\r\nif (virt_dev->eps[i].ring && virt_dev->eps[i].ring->dequeue) {\r\nstruct xhci_command *command;\r\ncommand = xhci_alloc_command(xhci, false, false,\r\nGFP_NOWAIT);\r\nif (!command) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nxhci_free_command(xhci, cmd);\r\nreturn -ENOMEM;\r\n}\r\nxhci_queue_stop_endpoint(xhci, command, slot_id, i,\r\nsuspend);\r\n}\r\n}\r\nxhci_queue_stop_endpoint(xhci, cmd, slot_id, 0, suspend);\r\nxhci_ring_cmd_db(xhci);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nwait_for_completion(cmd->completion);\r\nif (cmd->status == COMP_CMD_ABORT || cmd->status == COMP_CMD_STOP) {\r\nxhci_warn(xhci, "Timeout while waiting for stop endpoint command\n");\r\nret = -ETIME;\r\n}\r\nxhci_free_command(xhci, cmd);\r\nreturn ret;\r\n}\r\nvoid xhci_ring_device(struct xhci_hcd *xhci, int slot_id)\r\n{\r\nint i, s;\r\nstruct xhci_virt_ep *ep;\r\nfor (i = 0; i < LAST_EP_INDEX + 1; i++) {\r\nep = &xhci->devs[slot_id]->eps[i];\r\nif (ep->ep_state & EP_HAS_STREAMS) {\r\nfor (s = 1; s < ep->stream_info->num_streams; s++)\r\nxhci_ring_ep_doorbell(xhci, slot_id, i, s);\r\n} else if (ep->ring && ep->ring->dequeue) {\r\nxhci_ring_ep_doorbell(xhci, slot_id, i, 0);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void xhci_disable_port(struct usb_hcd *hcd, struct xhci_hcd *xhci,\r\nu16 wIndex, __le32 __iomem *addr, u32 port_status)\r\n{\r\nif (hcd->speed >= HCD_USB3) {\r\nxhci_dbg(xhci, "Ignoring request to disable "\r\n"SuperSpeed port.\n");\r\nreturn;\r\n}\r\nwritel(port_status | PORT_PE, addr);\r\nport_status = readl(addr);\r\nxhci_dbg(xhci, "disable port, actual port %d status = 0x%x\n",\r\nwIndex, port_status);\r\n}\r\nstatic void xhci_clear_port_change_bit(struct xhci_hcd *xhci, u16 wValue,\r\nu16 wIndex, __le32 __iomem *addr, u32 port_status)\r\n{\r\nchar *port_change_bit;\r\nu32 status;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_C_RESET:\r\nstatus = PORT_RC;\r\nport_change_bit = "reset";\r\nbreak;\r\ncase USB_PORT_FEAT_C_BH_PORT_RESET:\r\nstatus = PORT_WRC;\r\nport_change_bit = "warm(BH) reset";\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nstatus = PORT_CSC;\r\nport_change_bit = "connect";\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nstatus = PORT_OCC;\r\nport_change_bit = "over-current";\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nstatus = PORT_PEC;\r\nport_change_bit = "enable/disable";\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nstatus = PORT_PLC;\r\nport_change_bit = "suspend/resume";\r\nbreak;\r\ncase USB_PORT_FEAT_C_PORT_LINK_STATE:\r\nstatus = PORT_PLC;\r\nport_change_bit = "link state";\r\nbreak;\r\ncase USB_PORT_FEAT_C_PORT_CONFIG_ERROR:\r\nstatus = PORT_CEC;\r\nport_change_bit = "config error";\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nwritel(port_status | status, addr);\r\nport_status = readl(addr);\r\nxhci_dbg(xhci, "clear port %s change, actual port %d status = 0x%x\n",\r\nport_change_bit, wIndex, port_status);\r\n}\r\nstatic int xhci_get_ports(struct usb_hcd *hcd, __le32 __iomem ***port_array)\r\n{\r\nint max_ports;\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nif (hcd->speed >= HCD_USB3) {\r\nmax_ports = xhci->num_usb3_ports;\r\n*port_array = xhci->usb3_ports;\r\n} else {\r\nmax_ports = xhci->num_usb2_ports;\r\n*port_array = xhci->usb2_ports;\r\n}\r\nreturn max_ports;\r\n}\r\nvoid xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,\r\nint port_id, u32 link_state)\r\n{\r\nu32 temp;\r\ntemp = readl(port_array[port_id]);\r\ntemp = xhci_port_state_to_neutral(temp);\r\ntemp &= ~PORT_PLS_MASK;\r\ntemp |= PORT_LINK_STROBE | link_state;\r\nwritel(temp, port_array[port_id]);\r\n}\r\nstatic void xhci_set_remote_wake_mask(struct xhci_hcd *xhci,\r\n__le32 __iomem **port_array, int port_id, u16 wake_mask)\r\n{\r\nu32 temp;\r\ntemp = readl(port_array[port_id]);\r\ntemp = xhci_port_state_to_neutral(temp);\r\nif (wake_mask & USB_PORT_FEAT_REMOTE_WAKE_CONNECT)\r\ntemp |= PORT_WKCONN_E;\r\nelse\r\ntemp &= ~PORT_WKCONN_E;\r\nif (wake_mask & USB_PORT_FEAT_REMOTE_WAKE_DISCONNECT)\r\ntemp |= PORT_WKDISC_E;\r\nelse\r\ntemp &= ~PORT_WKDISC_E;\r\nif (wake_mask & USB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT)\r\ntemp |= PORT_WKOC_E;\r\nelse\r\ntemp &= ~PORT_WKOC_E;\r\nwritel(temp, port_array[port_id]);\r\n}\r\nvoid xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,\r\nint port_id, u32 port_bit)\r\n{\r\nu32 temp;\r\ntemp = readl(port_array[port_id]);\r\nif (temp & port_bit) {\r\ntemp = xhci_port_state_to_neutral(temp);\r\ntemp |= port_bit;\r\nwritel(temp, port_array[port_id]);\r\n}\r\n}\r\nstatic void xhci_hub_report_usb2_link_state(u32 *status, u32 status_reg)\r\n{\r\nif ((status_reg & PORT_PLS_MASK) == XDEV_U2)\r\n*status |= USB_PORT_STAT_L1;\r\n}\r\nstatic void xhci_hub_report_usb3_link_state(struct xhci_hcd *xhci,\r\nu32 *status, u32 status_reg)\r\n{\r\nu32 pls = status_reg & PORT_PLS_MASK;\r\nif (pls == XDEV_RESUME) {\r\n*status |= USB_SS_PORT_LS_U3;\r\nreturn;\r\n}\r\nif (status_reg & PORT_CAS) {\r\nif (pls != USB_SS_PORT_LS_COMP_MOD &&\r\npls != USB_SS_PORT_LS_SS_INACTIVE) {\r\npls = USB_SS_PORT_LS_COMP_MOD;\r\n}\r\npls |= USB_PORT_STAT_CONNECTION;\r\n} else {\r\nif ((xhci->quirks & XHCI_COMP_MODE_QUIRK) &&\r\n(pls == USB_SS_PORT_LS_COMP_MOD))\r\npls |= USB_PORT_STAT_CONNECTION;\r\n}\r\n*status |= pls;\r\n}\r\nstatic void xhci_del_comp_mod_timer(struct xhci_hcd *xhci, u32 status,\r\nu16 wIndex)\r\n{\r\nu32 all_ports_seen_u0 = ((1 << xhci->num_usb3_ports)-1);\r\nbool port_in_u0 = ((status & PORT_PLS_MASK) == XDEV_U0);\r\nif (!(xhci->quirks & XHCI_COMP_MODE_QUIRK))\r\nreturn;\r\nif ((xhci->port_status_u0 != all_ports_seen_u0) && port_in_u0) {\r\nxhci->port_status_u0 |= 1 << wIndex;\r\nif (xhci->port_status_u0 == all_ports_seen_u0) {\r\ndel_timer_sync(&xhci->comp_mode_recovery_timer);\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\r\n"All USB3 ports have entered U0 already!");\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\r\n"Compliance Mode Recovery Timer Deleted.");\r\n}\r\n}\r\n}\r\nstatic u32 xhci_get_ext_port_status(u32 raw_port_status, u32 port_li)\r\n{\r\nu32 ext_stat = 0;\r\nint speed_id;\r\nspeed_id = DEV_PORT_SPEED(raw_port_status);\r\next_stat |= speed_id;\r\next_stat |= speed_id << 4;\r\next_stat |= PORT_RX_LANES(port_li) << 8;\r\next_stat |= PORT_TX_LANES(port_li) << 12;\r\nreturn ext_stat;\r\n}\r\nstatic u32 xhci_get_port_status(struct usb_hcd *hcd,\r\nstruct xhci_bus_state *bus_state,\r\n__le32 __iomem **port_array,\r\nu16 wIndex, u32 raw_port_status,\r\nunsigned long flags)\r\n__releases(&xhci->lock\r\nint xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nint max_ports;\r\nunsigned long flags;\r\nu32 temp, status;\r\nint retval = 0;\r\n__le32 __iomem **port_array;\r\nint slot_id;\r\nstruct xhci_bus_state *bus_state;\r\nu16 link_state = 0;\r\nu16 wake_mask = 0;\r\nu16 timeout = 0;\r\nmax_ports = xhci_get_ports(hcd, &port_array);\r\nbus_state = &xhci->bus_state[hcd_index(hcd)];\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nswitch (typeReq) {\r\ncase GetHubStatus:\r\nmemset(buf, 0, 4);\r\nbreak;\r\ncase GetHubDescriptor:\r\nif (hcd->speed >= HCD_USB3 &&\r\n(wLength < USB_DT_SS_HUB_SIZE ||\r\nwValue != (USB_DT_SS_HUB << 8))) {\r\nxhci_dbg(xhci, "Wrong hub descriptor type for "\r\n"USB 3.0 roothub.\n");\r\ngoto error;\r\n}\r\nxhci_hub_descriptor(hcd, xhci,\r\n(struct usb_hub_descriptor *) buf);\r\nbreak;\r\ncase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\r\nif ((wValue & 0xff00) != (USB_DT_BOS << 8))\r\ngoto error;\r\nif (hcd->speed < HCD_USB3)\r\ngoto error;\r\nretval = xhci_create_usb3_bos_desc(xhci, buf, wLength);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn retval;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > max_ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = readl(port_array[wIndex]);\r\nif (temp == 0xffffffff) {\r\nretval = -ENODEV;\r\nbreak;\r\n}\r\nstatus = xhci_get_port_status(hcd, bus_state, port_array,\r\nwIndex, temp, flags);\r\nif (status == 0xffffffff)\r\ngoto error;\r\nxhci_dbg(xhci, "get port status, actual port %d status = 0x%x\n",\r\nwIndex, temp);\r\nxhci_dbg(xhci, "Get port status returned 0x%x\n", status);\r\nput_unaligned(cpu_to_le32(status), (__le32 *) buf);\r\nif (wValue == 0x02) {\r\nu32 port_li;\r\nif (hcd->speed < HCD_USB31 || wLength != 8) {\r\nxhci_err(xhci, "get ext port status invalid parameter\n");\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nport_li = readl(port_array[wIndex] + PORTLI);\r\nstatus = xhci_get_ext_port_status(temp, port_li);\r\nput_unaligned_le32(cpu_to_le32(status), &buf[4]);\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nif (wValue == USB_PORT_FEAT_LINK_STATE)\r\nlink_state = (wIndex & 0xff00) >> 3;\r\nif (wValue == USB_PORT_FEAT_REMOTE_WAKE_MASK)\r\nwake_mask = wIndex & 0xff00;\r\ntimeout = (wIndex & 0xff00) >> 8;\r\nwIndex &= 0xff;\r\nif (!wIndex || wIndex > max_ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = readl(port_array[wIndex]);\r\nif (temp == 0xffffffff) {\r\nretval = -ENODEV;\r\nbreak;\r\n}\r\ntemp = xhci_port_state_to_neutral(temp);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\ntemp = readl(port_array[wIndex]);\r\nif ((temp & PORT_PLS_MASK) != XDEV_U0) {\r\nxhci_set_link_state(xhci, port_array, wIndex,\r\nXDEV_U0);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\n}\r\ntemp = readl(port_array[wIndex]);\r\nif ((temp & PORT_PE) == 0 || (temp & PORT_RESET)\r\n|| (temp & PORT_PLS_MASK) >= XDEV_U3) {\r\nxhci_warn(xhci, "USB core suspending device "\r\n"not in U0/U1/U2.\n");\r\ngoto error;\r\n}\r\nslot_id = xhci_find_slot_id_by_port(hcd, xhci,\r\nwIndex + 1);\r\nif (!slot_id) {\r\nxhci_warn(xhci, "slot_id is zero\n");\r\ngoto error;\r\n}\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nxhci_stop_device(xhci, slot_id, 1);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nxhci_set_link_state(xhci, port_array, wIndex, XDEV_U3);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\ntemp = readl(port_array[wIndex]);\r\nbus_state->suspended_ports |= 1 << wIndex;\r\nbreak;\r\ncase USB_PORT_FEAT_LINK_STATE:\r\ntemp = readl(port_array[wIndex]);\r\nif (link_state == USB_SS_PORT_LS_SS_DISABLED) {\r\nxhci_dbg(xhci, "Disable port %d\n", wIndex);\r\ntemp = xhci_port_state_to_neutral(temp);\r\ntemp |= PORT_CSC | PORT_PEC | PORT_WRC |\r\nPORT_OCC | PORT_RC | PORT_PLC |\r\nPORT_CEC;\r\nwritel(temp | PORT_PE, port_array[wIndex]);\r\ntemp = readl(port_array[wIndex]);\r\nbreak;\r\n}\r\nif (link_state == USB_SS_PORT_LS_RX_DETECT) {\r\nxhci_dbg(xhci, "Enable port %d\n", wIndex);\r\nxhci_set_link_state(xhci, port_array, wIndex,\r\nlink_state);\r\ntemp = readl(port_array[wIndex]);\r\nbreak;\r\n}\r\nif ((temp & PORT_PE) == 0 ||\r\n(link_state > USB_SS_PORT_LS_U3)) {\r\nxhci_warn(xhci, "Cannot set link state.\n");\r\ngoto error;\r\n}\r\nif (link_state == USB_SS_PORT_LS_U3) {\r\nslot_id = xhci_find_slot_id_by_port(hcd, xhci,\r\nwIndex + 1);\r\nif (slot_id) {\r\nspin_unlock_irqrestore(&xhci->lock,\r\nflags);\r\nxhci_stop_device(xhci, slot_id, 1);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\n}\r\n}\r\nxhci_set_link_state(xhci, port_array, wIndex,\r\nlink_state);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nmsleep(20);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\ntemp = readl(port_array[wIndex]);\r\nif (link_state == USB_SS_PORT_LS_U3)\r\nbus_state->suspended_ports |= 1 << wIndex;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nwritel(temp | PORT_POWER, port_array[wIndex]);\r\ntemp = readl(port_array[wIndex]);\r\nxhci_dbg(xhci, "set port power, actual port %d status = 0x%x\n", wIndex, temp);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\ntemp = usb_acpi_power_manageable(hcd->self.root_hub,\r\nwIndex);\r\nif (temp)\r\nusb_acpi_set_power_state(hcd->self.root_hub,\r\nwIndex, true);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\ntemp = (temp | PORT_RESET);\r\nwritel(temp, port_array[wIndex]);\r\ntemp = readl(port_array[wIndex]);\r\nxhci_dbg(xhci, "set port reset, actual port %d status = 0x%x\n", wIndex, temp);\r\nbreak;\r\ncase USB_PORT_FEAT_REMOTE_WAKE_MASK:\r\nxhci_set_remote_wake_mask(xhci, port_array,\r\nwIndex, wake_mask);\r\ntemp = readl(port_array[wIndex]);\r\nxhci_dbg(xhci, "set port remote wake mask, "\r\n"actual port %d status = 0x%x\n",\r\nwIndex, temp);\r\nbreak;\r\ncase USB_PORT_FEAT_BH_PORT_RESET:\r\ntemp |= PORT_WR;\r\nwritel(temp, port_array[wIndex]);\r\ntemp = readl(port_array[wIndex]);\r\nbreak;\r\ncase USB_PORT_FEAT_U1_TIMEOUT:\r\nif (hcd->speed < HCD_USB3)\r\ngoto error;\r\ntemp = readl(port_array[wIndex] + PORTPMSC);\r\ntemp &= ~PORT_U1_TIMEOUT_MASK;\r\ntemp |= PORT_U1_TIMEOUT(timeout);\r\nwritel(temp, port_array[wIndex] + PORTPMSC);\r\nbreak;\r\ncase USB_PORT_FEAT_U2_TIMEOUT:\r\nif (hcd->speed < HCD_USB3)\r\ngoto error;\r\ntemp = readl(port_array[wIndex] + PORTPMSC);\r\ntemp &= ~PORT_U2_TIMEOUT_MASK;\r\ntemp |= PORT_U2_TIMEOUT(timeout);\r\nwritel(temp, port_array[wIndex] + PORTPMSC);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\ntemp = readl(port_array[wIndex]);\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > max_ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = readl(port_array[wIndex]);\r\nif (temp == 0xffffffff) {\r\nretval = -ENODEV;\r\nbreak;\r\n}\r\ntemp = xhci_port_state_to_neutral(temp);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\ntemp = readl(port_array[wIndex]);\r\nxhci_dbg(xhci, "clear USB_PORT_FEAT_SUSPEND\n");\r\nxhci_dbg(xhci, "PORTSC %04x\n", temp);\r\nif (temp & PORT_RESET)\r\ngoto error;\r\nif ((temp & PORT_PLS_MASK) == XDEV_U3) {\r\nif ((temp & PORT_PE) == 0)\r\ngoto error;\r\nset_bit(wIndex, &bus_state->resuming_ports);\r\nxhci_set_link_state(xhci, port_array, wIndex,\r\nXDEV_RESUME);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nmsleep(20);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nxhci_set_link_state(xhci, port_array, wIndex,\r\nXDEV_U0);\r\nclear_bit(wIndex, &bus_state->resuming_ports);\r\n}\r\nbus_state->port_c_suspend |= 1 << wIndex;\r\nslot_id = xhci_find_slot_id_by_port(hcd, xhci,\r\nwIndex + 1);\r\nif (!slot_id) {\r\nxhci_dbg(xhci, "slot_id is zero\n");\r\ngoto error;\r\n}\r\nxhci_ring_device(xhci, slot_id);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nbus_state->port_c_suspend &= ~(1 << wIndex);\r\ncase USB_PORT_FEAT_C_RESET:\r\ncase USB_PORT_FEAT_C_BH_PORT_RESET:\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ncase USB_PORT_FEAT_C_PORT_LINK_STATE:\r\ncase USB_PORT_FEAT_C_PORT_CONFIG_ERROR:\r\nxhci_clear_port_change_bit(xhci, wValue, wIndex,\r\nport_array[wIndex], temp);\r\nbreak;\r\ncase USB_PORT_FEAT_ENABLE:\r\nxhci_disable_port(hcd, xhci, wIndex,\r\nport_array[wIndex], temp);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nwritel(temp & ~PORT_POWER, port_array[wIndex]);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\ntemp = usb_acpi_power_manageable(hcd->self.root_hub,\r\nwIndex);\r\nif (temp)\r\nusb_acpi_set_power_state(hcd->self.root_hub,\r\nwIndex, false);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn retval;\r\n}\r\nint xhci_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nunsigned long flags;\r\nu32 temp, status;\r\nu32 mask;\r\nint i, retval;\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nint max_ports;\r\n__le32 __iomem **port_array;\r\nstruct xhci_bus_state *bus_state;\r\nbool reset_change = false;\r\nmax_ports = xhci_get_ports(hcd, &port_array);\r\nbus_state = &xhci->bus_state[hcd_index(hcd)];\r\nretval = (max_ports + 8) / 8;\r\nmemset(buf, 0, retval);\r\nstatus = bus_state->resuming_ports;\r\nmask = PORT_CSC | PORT_PEC | PORT_OCC | PORT_PLC | PORT_WRC | PORT_CEC;\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nfor (i = 0; i < max_ports; i++) {\r\ntemp = readl(port_array[i]);\r\nif (temp == 0xffffffff) {\r\nretval = -ENODEV;\r\nbreak;\r\n}\r\nif ((temp & mask) != 0 ||\r\n(bus_state->port_c_suspend & 1 << i) ||\r\n(bus_state->resume_done[i] && time_after_eq(\r\njiffies, bus_state->resume_done[i]))) {\r\nbuf[(i + 1) / 8] |= 1 << (i + 1) % 8;\r\nstatus = 1;\r\n}\r\nif ((temp & PORT_RC))\r\nreset_change = true;\r\n}\r\nif (!status && !reset_change) {\r\nxhci_dbg(xhci, "%s: stopping port polling.\n", __func__);\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\n}\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn status ? retval : 0;\r\n}\r\nint xhci_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nint max_ports, port_index;\r\n__le32 __iomem **port_array;\r\nstruct xhci_bus_state *bus_state;\r\nunsigned long flags;\r\nmax_ports = xhci_get_ports(hcd, &port_array);\r\nbus_state = &xhci->bus_state[hcd_index(hcd)];\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nif (hcd->self.root_hub->do_remote_wakeup) {\r\nif (bus_state->resuming_ports ||\r\nbus_state->port_remote_wakeup) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nxhci_dbg(xhci, "suspend failed because a port is resuming\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nport_index = max_ports;\r\nbus_state->bus_suspended = 0;\r\nwhile (port_index--) {\r\nu32 t1, t2;\r\nint slot_id;\r\nt1 = readl(port_array[port_index]);\r\nt2 = xhci_port_state_to_neutral(t1);\r\nif ((t1 & PORT_PE) && !(t1 & PORT_PLS_MASK)) {\r\nxhci_dbg(xhci, "port %d not suspended\n", port_index);\r\nslot_id = xhci_find_slot_id_by_port(hcd, xhci,\r\nport_index + 1);\r\nif (slot_id) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nxhci_stop_device(xhci, slot_id, 1);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\n}\r\nt2 &= ~PORT_PLS_MASK;\r\nt2 |= PORT_LINK_STROBE | XDEV_U3;\r\nset_bit(port_index, &bus_state->bus_suspended);\r\n}\r\nif (hcd->self.root_hub->do_remote_wakeup) {\r\nif (t1 & PORT_CONNECT) {\r\nt2 |= PORT_WKOC_E | PORT_WKDISC_E;\r\nt2 &= ~PORT_WKCONN_E;\r\n} else {\r\nt2 |= PORT_WKOC_E | PORT_WKCONN_E;\r\nt2 &= ~PORT_WKDISC_E;\r\n}\r\n} else\r\nt2 &= ~PORT_WAKE_BITS;\r\nt1 = xhci_port_state_to_neutral(t1);\r\nif (t1 != t2)\r\nwritel(t2, port_array[port_index]);\r\n}\r\nhcd->state = HC_STATE_SUSPENDED;\r\nbus_state->next_statechange = jiffies + msecs_to_jiffies(10);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn 0;\r\n}\r\nint xhci_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nint max_ports, port_index;\r\n__le32 __iomem **port_array;\r\nstruct xhci_bus_state *bus_state;\r\nu32 temp;\r\nunsigned long flags;\r\nunsigned long port_was_suspended = 0;\r\nbool need_usb2_u3_exit = false;\r\nint slot_id;\r\nint sret;\r\nmax_ports = xhci_get_ports(hcd, &port_array);\r\nbus_state = &xhci->bus_state[hcd_index(hcd)];\r\nif (time_before(jiffies, bus_state->next_statechange))\r\nmsleep(5);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\ntemp = readl(&xhci->op_regs->command);\r\ntemp &= ~CMD_EIE;\r\nwritel(temp, &xhci->op_regs->command);\r\nport_index = max_ports;\r\nwhile (port_index--) {\r\nu32 temp;\r\ntemp = readl(port_array[port_index]);\r\nif (DEV_SUPERSPEED_ANY(temp))\r\ntemp &= ~(PORT_RWC_BITS | PORT_CEC | PORT_WAKE_BITS);\r\nelse\r\ntemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\r\nif (test_bit(port_index, &bus_state->bus_suspended) &&\r\n(temp & PORT_PLS_MASK)) {\r\nset_bit(port_index, &port_was_suspended);\r\nif (!DEV_SUPERSPEED_ANY(temp)) {\r\nxhci_set_link_state(xhci, port_array,\r\nport_index, XDEV_RESUME);\r\nneed_usb2_u3_exit = true;\r\n}\r\n} else\r\nwritel(temp, port_array[port_index]);\r\n}\r\nif (need_usb2_u3_exit) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nmsleep(20);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\n}\r\nport_index = max_ports;\r\nwhile (port_index--) {\r\nif (!(port_was_suspended & BIT(port_index)))\r\ncontinue;\r\nxhci_test_and_clear_bit(xhci, port_array, port_index, PORT_PLC);\r\nxhci_set_link_state(xhci, port_array, port_index, XDEV_U0);\r\n}\r\nport_index = max_ports;\r\nwhile (port_index--) {\r\nif (!(port_was_suspended & BIT(port_index)))\r\ncontinue;\r\nsret = xhci_handshake(port_array[port_index], PORT_PLC,\r\nPORT_PLC, 10 * 1000);\r\nif (sret)\r\nxhci_warn(xhci, "port %d resume PLC timeout\n",\r\nport_index);\r\nxhci_test_and_clear_bit(xhci, port_array, port_index, PORT_PLC);\r\nslot_id = xhci_find_slot_id_by_port(hcd, xhci, port_index + 1);\r\nif (slot_id)\r\nxhci_ring_device(xhci, slot_id);\r\n}\r\n(void) readl(&xhci->op_regs->command);\r\nbus_state->next_statechange = jiffies + msecs_to_jiffies(5);\r\ntemp = readl(&xhci->op_regs->command);\r\ntemp |= CMD_EIE;\r\nwritel(temp, &xhci->op_regs->command);\r\ntemp = readl(&xhci->op_regs->command);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn 0;\r\n}
