void dlpar_free_cc_property(struct property *prop)\r\n{\r\nkfree(prop->name);\r\nkfree(prop->value);\r\nkfree(prop);\r\n}\r\nstatic struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\r\n{\r\nstruct property *prop;\r\nchar *name;\r\nchar *value;\r\nprop = kzalloc(sizeof(*prop), GFP_KERNEL);\r\nif (!prop)\r\nreturn NULL;\r\nname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\r\nprop->name = kstrdup(name, GFP_KERNEL);\r\nprop->length = be32_to_cpu(ccwa->prop_length);\r\nvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\r\nprop->value = kmemdup(value, prop->length, GFP_KERNEL);\r\nif (!prop->value) {\r\ndlpar_free_cc_property(prop);\r\nreturn NULL;\r\n}\r\nreturn prop;\r\n}\r\nstatic struct device_node *dlpar_parse_cc_node(struct cc_workarea *ccwa,\r\nconst char *path)\r\n{\r\nstruct device_node *dn;\r\nchar *name;\r\nif (!path[1])\r\npath++;\r\ndn = kzalloc(sizeof(*dn), GFP_KERNEL);\r\nif (!dn)\r\nreturn NULL;\r\nname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\r\ndn->full_name = kasprintf(GFP_KERNEL, "%s/%s", path, name);\r\nif (!dn->full_name) {\r\nkfree(dn);\r\nreturn NULL;\r\n}\r\nof_node_set_flag(dn, OF_DYNAMIC);\r\nof_node_init(dn);\r\nreturn dn;\r\n}\r\nstatic void dlpar_free_one_cc_node(struct device_node *dn)\r\n{\r\nstruct property *prop;\r\nwhile (dn->properties) {\r\nprop = dn->properties;\r\ndn->properties = prop->next;\r\ndlpar_free_cc_property(prop);\r\n}\r\nkfree(dn->full_name);\r\nkfree(dn);\r\n}\r\nvoid dlpar_free_cc_nodes(struct device_node *dn)\r\n{\r\nif (dn->child)\r\ndlpar_free_cc_nodes(dn->child);\r\nif (dn->sibling)\r\ndlpar_free_cc_nodes(dn->sibling);\r\ndlpar_free_one_cc_node(dn);\r\n}\r\nstruct device_node *dlpar_configure_connector(__be32 drc_index,\r\nstruct device_node *parent)\r\n{\r\nstruct device_node *dn;\r\nstruct device_node *first_dn = NULL;\r\nstruct device_node *last_dn = NULL;\r\nstruct property *property;\r\nstruct property *last_property = NULL;\r\nstruct cc_workarea *ccwa;\r\nchar *data_buf;\r\nconst char *parent_path = parent->full_name;\r\nint cc_token;\r\nint rc = -1;\r\ncc_token = rtas_token("ibm,configure-connector");\r\nif (cc_token == RTAS_UNKNOWN_SERVICE)\r\nreturn NULL;\r\ndata_buf = kzalloc(RTAS_DATA_BUF_SIZE, GFP_KERNEL);\r\nif (!data_buf)\r\nreturn NULL;\r\nccwa = (struct cc_workarea *)&data_buf[0];\r\nccwa->drc_index = drc_index;\r\nccwa->zero = 0;\r\ndo {\r\nspin_lock(&rtas_data_buf_lock);\r\nmemcpy(rtas_data_buf, data_buf, RTAS_DATA_BUF_SIZE);\r\nrc = rtas_call(cc_token, 2, 1, NULL, rtas_data_buf, NULL);\r\nmemcpy(data_buf, rtas_data_buf, RTAS_DATA_BUF_SIZE);\r\nspin_unlock(&rtas_data_buf_lock);\r\nswitch (rc) {\r\ncase COMPLETE:\r\nbreak;\r\ncase NEXT_SIBLING:\r\ndn = dlpar_parse_cc_node(ccwa, parent_path);\r\nif (!dn)\r\ngoto cc_error;\r\ndn->parent = last_dn->parent;\r\nlast_dn->sibling = dn;\r\nlast_dn = dn;\r\nbreak;\r\ncase NEXT_CHILD:\r\nif (first_dn)\r\nparent_path = last_dn->full_name;\r\ndn = dlpar_parse_cc_node(ccwa, parent_path);\r\nif (!dn)\r\ngoto cc_error;\r\nif (!first_dn) {\r\ndn->parent = parent;\r\nfirst_dn = dn;\r\n} else {\r\ndn->parent = last_dn;\r\nif (last_dn)\r\nlast_dn->child = dn;\r\n}\r\nlast_dn = dn;\r\nbreak;\r\ncase NEXT_PROPERTY:\r\nproperty = dlpar_parse_cc_property(ccwa);\r\nif (!property)\r\ngoto cc_error;\r\nif (!last_dn->properties)\r\nlast_dn->properties = property;\r\nelse\r\nlast_property->next = property;\r\nlast_property = property;\r\nbreak;\r\ncase PREV_PARENT:\r\nlast_dn = last_dn->parent;\r\nparent_path = last_dn->parent->full_name;\r\nbreak;\r\ncase CALL_AGAIN:\r\nbreak;\r\ncase MORE_MEMORY:\r\ncase ERR_CFG_USE:\r\ndefault:\r\nprintk(KERN_ERR "Unexpected Error (%d) "\r\n"returned from configure-connector\n", rc);\r\ngoto cc_error;\r\n}\r\n} while (rc);\r\ncc_error:\r\nkfree(data_buf);\r\nif (rc) {\r\nif (first_dn)\r\ndlpar_free_cc_nodes(first_dn);\r\nreturn NULL;\r\n}\r\nreturn first_dn;\r\n}\r\nint dlpar_attach_node(struct device_node *dn)\r\n{\r\nint rc;\r\ndn->parent = pseries_of_derive_parent(dn->full_name);\r\nif (IS_ERR(dn->parent))\r\nreturn PTR_ERR(dn->parent);\r\nrc = of_attach_node(dn);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed to add device node %s\n",\r\ndn->full_name);\r\nreturn rc;\r\n}\r\nof_node_put(dn->parent);\r\nreturn 0;\r\n}\r\nint dlpar_detach_node(struct device_node *dn)\r\n{\r\nstruct device_node *child;\r\nint rc;\r\nchild = of_get_next_child(dn, NULL);\r\nwhile (child) {\r\ndlpar_detach_node(child);\r\nchild = of_get_next_child(dn, child);\r\n}\r\nrc = of_detach_node(dn);\r\nif (rc)\r\nreturn rc;\r\nof_node_put(dn);\r\nreturn 0;\r\n}\r\nint dlpar_acquire_drc(u32 drc_index)\r\n{\r\nint dr_status, rc;\r\nrc = rtas_call(rtas_token("get-sensor-state"), 2, 2, &dr_status,\r\nDR_ENTITY_SENSE, drc_index);\r\nif (rc || dr_status != DR_ENTITY_UNUSABLE)\r\nreturn -1;\r\nrc = rtas_set_indicator(ALLOCATION_STATE, drc_index, ALLOC_USABLE);\r\nif (rc)\r\nreturn rc;\r\nrc = rtas_set_indicator(ISOLATION_STATE, drc_index, UNISOLATE);\r\nif (rc) {\r\nrtas_set_indicator(ALLOCATION_STATE, drc_index, ALLOC_UNUSABLE);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint dlpar_release_drc(u32 drc_index)\r\n{\r\nint dr_status, rc;\r\nrc = rtas_call(rtas_token("get-sensor-state"), 2, 2, &dr_status,\r\nDR_ENTITY_SENSE, drc_index);\r\nif (rc || dr_status != DR_ENTITY_PRESENT)\r\nreturn -1;\r\nrc = rtas_set_indicator(ISOLATION_STATE, drc_index, ISOLATE);\r\nif (rc)\r\nreturn rc;\r\nrc = rtas_set_indicator(ALLOCATION_STATE, drc_index, ALLOC_UNUSABLE);\r\nif (rc) {\r\nrtas_set_indicator(ISOLATION_STATE, drc_index, UNISOLATE);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_dlpar_errorlog(struct pseries_hp_errorlog *hp_elog)\r\n{\r\nint rc;\r\nswitch (hp_elog->id_type) {\r\ncase PSERIES_HP_ELOG_ID_DRC_COUNT:\r\nhp_elog->_drc_u.drc_count =\r\nbe32_to_cpu(hp_elog->_drc_u.drc_count);\r\nbreak;\r\ncase PSERIES_HP_ELOG_ID_DRC_INDEX:\r\nhp_elog->_drc_u.drc_index =\r\nbe32_to_cpu(hp_elog->_drc_u.drc_index);\r\n}\r\nswitch (hp_elog->resource) {\r\ncase PSERIES_HP_ELOG_RESOURCE_MEM:\r\nrc = dlpar_memory(hp_elog);\r\nbreak;\r\ncase PSERIES_HP_ELOG_RESOURCE_CPU:\r\nrc = dlpar_cpu(hp_elog);\r\nbreak;\r\ndefault:\r\npr_warn_ratelimited("Invalid resource (%d) specified\n",\r\nhp_elog->resource);\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t dlpar_store(struct class *class, struct class_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pseries_hp_errorlog *hp_elog;\r\nconst char *arg;\r\nint rc;\r\nhp_elog = kzalloc(sizeof(*hp_elog), GFP_KERNEL);\r\nif (!hp_elog) {\r\nrc = -ENOMEM;\r\ngoto dlpar_store_out;\r\n}\r\narg = buf;\r\nif (!strncmp(arg, "memory", 6)) {\r\nhp_elog->resource = PSERIES_HP_ELOG_RESOURCE_MEM;\r\narg += strlen("memory ");\r\n} else if (!strncmp(arg, "cpu", 3)) {\r\nhp_elog->resource = PSERIES_HP_ELOG_RESOURCE_CPU;\r\narg += strlen("cpu ");\r\n} else {\r\npr_err("Invalid resource specified: \"%s\"\n", buf);\r\nrc = -EINVAL;\r\ngoto dlpar_store_out;\r\n}\r\nif (!strncmp(arg, "add", 3)) {\r\nhp_elog->action = PSERIES_HP_ELOG_ACTION_ADD;\r\narg += strlen("add ");\r\n} else if (!strncmp(arg, "remove", 6)) {\r\nhp_elog->action = PSERIES_HP_ELOG_ACTION_REMOVE;\r\narg += strlen("remove ");\r\n} else {\r\npr_err("Invalid action specified: \"%s\"\n", buf);\r\nrc = -EINVAL;\r\ngoto dlpar_store_out;\r\n}\r\nif (!strncmp(arg, "index", 5)) {\r\nu32 index;\r\nhp_elog->id_type = PSERIES_HP_ELOG_ID_DRC_INDEX;\r\narg += strlen("index ");\r\nif (kstrtou32(arg, 0, &index)) {\r\nrc = -EINVAL;\r\npr_err("Invalid drc_index specified: \"%s\"\n", buf);\r\ngoto dlpar_store_out;\r\n}\r\nhp_elog->_drc_u.drc_index = cpu_to_be32(index);\r\n} else if (!strncmp(arg, "count", 5)) {\r\nu32 count;\r\nhp_elog->id_type = PSERIES_HP_ELOG_ID_DRC_COUNT;\r\narg += strlen("count ");\r\nif (kstrtou32(arg, 0, &count)) {\r\nrc = -EINVAL;\r\npr_err("Invalid count specified: \"%s\"\n", buf);\r\ngoto dlpar_store_out;\r\n}\r\nhp_elog->_drc_u.drc_count = cpu_to_be32(count);\r\n} else {\r\npr_err("Invalid id_type specified: \"%s\"\n", buf);\r\nrc = -EINVAL;\r\ngoto dlpar_store_out;\r\n}\r\nrc = handle_dlpar_errorlog(hp_elog);\r\ndlpar_store_out:\r\nkfree(hp_elog);\r\nreturn rc ? rc : count;\r\n}\r\nstatic int __init pseries_dlpar_init(void)\r\n{\r\nreturn sysfs_create_file(kernel_kobj, &class_attr_dlpar.attr);\r\n}
