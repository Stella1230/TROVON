static inline u32 spfi_readl(struct img_spfi *spfi, u32 reg)\r\n{\r\nreturn readl(spfi->regs + reg);\r\n}\r\nstatic inline void spfi_writel(struct img_spfi *spfi, u32 val, u32 reg)\r\n{\r\nwritel(val, spfi->regs + reg);\r\n}\r\nstatic inline void spfi_start(struct img_spfi *spfi)\r\n{\r\nu32 val;\r\nval = spfi_readl(spfi, SPFI_CONTROL);\r\nval |= SPFI_CONTROL_SPFI_EN;\r\nspfi_writel(spfi, val, SPFI_CONTROL);\r\n}\r\nstatic inline void spfi_reset(struct img_spfi *spfi)\r\n{\r\nspfi_writel(spfi, SPFI_CONTROL_SOFT_RESET, SPFI_CONTROL);\r\nspfi_writel(spfi, 0, SPFI_CONTROL);\r\n}\r\nstatic int spfi_wait_all_done(struct img_spfi *spfi)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(50);\r\nwhile (time_before(jiffies, timeout)) {\r\nu32 status = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\r\nif (status & SPFI_INTERRUPT_ALLDONETRIG) {\r\nspfi_writel(spfi, SPFI_INTERRUPT_ALLDONETRIG,\r\nSPFI_INTERRUPT_CLEAR);\r\nreturn 0;\r\n}\r\ncpu_relax();\r\n}\r\ndev_err(spfi->dev, "Timed out waiting for transaction to complete\n");\r\nspfi_reset(spfi);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic unsigned int spfi_pio_write32(struct img_spfi *spfi, const u32 *buf,\r\nunsigned int max)\r\n{\r\nunsigned int count = 0;\r\nu32 status;\r\nwhile (count < max / 4) {\r\nspfi_writel(spfi, SPFI_INTERRUPT_SDFUL, SPFI_INTERRUPT_CLEAR);\r\nstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\r\nif (status & SPFI_INTERRUPT_SDFUL)\r\nbreak;\r\nspfi_writel(spfi, buf[count], SPFI_TX_32BIT_VALID_DATA);\r\ncount++;\r\n}\r\nreturn count * 4;\r\n}\r\nstatic unsigned int spfi_pio_write8(struct img_spfi *spfi, const u8 *buf,\r\nunsigned int max)\r\n{\r\nunsigned int count = 0;\r\nu32 status;\r\nwhile (count < max) {\r\nspfi_writel(spfi, SPFI_INTERRUPT_SDFUL, SPFI_INTERRUPT_CLEAR);\r\nstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\r\nif (status & SPFI_INTERRUPT_SDFUL)\r\nbreak;\r\nspfi_writel(spfi, buf[count], SPFI_TX_8BIT_VALID_DATA);\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned int spfi_pio_read32(struct img_spfi *spfi, u32 *buf,\r\nunsigned int max)\r\n{\r\nunsigned int count = 0;\r\nu32 status;\r\nwhile (count < max / 4) {\r\nspfi_writel(spfi, SPFI_INTERRUPT_GDEX32BIT,\r\nSPFI_INTERRUPT_CLEAR);\r\nstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\r\nif (!(status & SPFI_INTERRUPT_GDEX32BIT))\r\nbreak;\r\nbuf[count] = spfi_readl(spfi, SPFI_RX_32BIT_VALID_DATA);\r\ncount++;\r\n}\r\nreturn count * 4;\r\n}\r\nstatic unsigned int spfi_pio_read8(struct img_spfi *spfi, u8 *buf,\r\nunsigned int max)\r\n{\r\nunsigned int count = 0;\r\nu32 status;\r\nwhile (count < max) {\r\nspfi_writel(spfi, SPFI_INTERRUPT_GDEX8BIT,\r\nSPFI_INTERRUPT_CLEAR);\r\nstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\r\nif (!(status & SPFI_INTERRUPT_GDEX8BIT))\r\nbreak;\r\nbuf[count] = spfi_readl(spfi, SPFI_RX_8BIT_VALID_DATA);\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic int img_spfi_start_pio(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct img_spfi *spfi = spi_master_get_devdata(spi->master);\r\nunsigned int tx_bytes = 0, rx_bytes = 0;\r\nconst void *tx_buf = xfer->tx_buf;\r\nvoid *rx_buf = xfer->rx_buf;\r\nunsigned long timeout;\r\nint ret;\r\nif (tx_buf)\r\ntx_bytes = xfer->len;\r\nif (rx_buf)\r\nrx_bytes = xfer->len;\r\nspfi_start(spfi);\r\ntimeout = jiffies +\r\nmsecs_to_jiffies(xfer->len * 8 * 1000 / xfer->speed_hz + 100);\r\nwhile ((tx_bytes > 0 || rx_bytes > 0) &&\r\ntime_before(jiffies, timeout)) {\r\nunsigned int tx_count, rx_count;\r\nif (tx_bytes >= 4)\r\ntx_count = spfi_pio_write32(spfi, tx_buf, tx_bytes);\r\nelse\r\ntx_count = spfi_pio_write8(spfi, tx_buf, tx_bytes);\r\nif (rx_bytes >= 4)\r\nrx_count = spfi_pio_read32(spfi, rx_buf, rx_bytes);\r\nelse\r\nrx_count = spfi_pio_read8(spfi, rx_buf, rx_bytes);\r\ntx_buf += tx_count;\r\nrx_buf += rx_count;\r\ntx_bytes -= tx_count;\r\nrx_bytes -= rx_count;\r\ncpu_relax();\r\n}\r\nif (rx_bytes > 0 || tx_bytes > 0) {\r\ndev_err(spfi->dev, "PIO transfer timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = spfi_wait_all_done(spfi);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void img_spfi_dma_rx_cb(void *data)\r\n{\r\nstruct img_spfi *spfi = data;\r\nunsigned long flags;\r\nspfi_wait_all_done(spfi);\r\nspin_lock_irqsave(&spfi->lock, flags);\r\nspfi->rx_dma_busy = false;\r\nif (!spfi->tx_dma_busy)\r\nspi_finalize_current_transfer(spfi->master);\r\nspin_unlock_irqrestore(&spfi->lock, flags);\r\n}\r\nstatic void img_spfi_dma_tx_cb(void *data)\r\n{\r\nstruct img_spfi *spfi = data;\r\nunsigned long flags;\r\nspfi_wait_all_done(spfi);\r\nspin_lock_irqsave(&spfi->lock, flags);\r\nspfi->tx_dma_busy = false;\r\nif (!spfi->rx_dma_busy)\r\nspi_finalize_current_transfer(spfi->master);\r\nspin_unlock_irqrestore(&spfi->lock, flags);\r\n}\r\nstatic int img_spfi_start_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct img_spfi *spfi = spi_master_get_devdata(spi->master);\r\nstruct dma_async_tx_descriptor *rxdesc = NULL, *txdesc = NULL;\r\nstruct dma_slave_config rxconf, txconf;\r\nspfi->rx_dma_busy = false;\r\nspfi->tx_dma_busy = false;\r\nif (xfer->rx_buf) {\r\nrxconf.direction = DMA_DEV_TO_MEM;\r\nif (xfer->len % 4 == 0) {\r\nrxconf.src_addr = spfi->phys + SPFI_RX_32BIT_VALID_DATA;\r\nrxconf.src_addr_width = 4;\r\nrxconf.src_maxburst = 4;\r\n} else {\r\nrxconf.src_addr = spfi->phys + SPFI_RX_8BIT_VALID_DATA;\r\nrxconf.src_addr_width = 1;\r\nrxconf.src_maxburst = 4;\r\n}\r\ndmaengine_slave_config(spfi->rx_ch, &rxconf);\r\nrxdesc = dmaengine_prep_slave_sg(spfi->rx_ch, xfer->rx_sg.sgl,\r\nxfer->rx_sg.nents,\r\nDMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\nif (!rxdesc)\r\ngoto stop_dma;\r\nrxdesc->callback = img_spfi_dma_rx_cb;\r\nrxdesc->callback_param = spfi;\r\n}\r\nif (xfer->tx_buf) {\r\ntxconf.direction = DMA_MEM_TO_DEV;\r\nif (xfer->len % 4 == 0) {\r\ntxconf.dst_addr = spfi->phys + SPFI_TX_32BIT_VALID_DATA;\r\ntxconf.dst_addr_width = 4;\r\ntxconf.dst_maxburst = 4;\r\n} else {\r\ntxconf.dst_addr = spfi->phys + SPFI_TX_8BIT_VALID_DATA;\r\ntxconf.dst_addr_width = 1;\r\ntxconf.dst_maxburst = 4;\r\n}\r\ndmaengine_slave_config(spfi->tx_ch, &txconf);\r\ntxdesc = dmaengine_prep_slave_sg(spfi->tx_ch, xfer->tx_sg.sgl,\r\nxfer->tx_sg.nents,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT);\r\nif (!txdesc)\r\ngoto stop_dma;\r\ntxdesc->callback = img_spfi_dma_tx_cb;\r\ntxdesc->callback_param = spfi;\r\n}\r\nif (xfer->rx_buf) {\r\nspfi->rx_dma_busy = true;\r\ndmaengine_submit(rxdesc);\r\ndma_async_issue_pending(spfi->rx_ch);\r\n}\r\nspfi_start(spfi);\r\nif (xfer->tx_buf) {\r\nspfi->tx_dma_busy = true;\r\ndmaengine_submit(txdesc);\r\ndma_async_issue_pending(spfi->tx_ch);\r\n}\r\nreturn 1;\r\nstop_dma:\r\ndmaengine_terminate_all(spfi->rx_ch);\r\ndmaengine_terminate_all(spfi->tx_ch);\r\nreturn -EIO;\r\n}\r\nstatic void img_spfi_handle_err(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct img_spfi *spfi = spi_master_get_devdata(master);\r\nunsigned long flags;\r\nspin_lock_irqsave(&spfi->lock, flags);\r\nif (spfi->tx_dma_busy || spfi->rx_dma_busy) {\r\nspfi->tx_dma_busy = false;\r\nspfi->rx_dma_busy = false;\r\ndmaengine_terminate_all(spfi->tx_ch);\r\ndmaengine_terminate_all(spfi->rx_ch);\r\n}\r\nspin_unlock_irqrestore(&spfi->lock, flags);\r\n}\r\nstatic int img_spfi_prepare(struct spi_master *master, struct spi_message *msg)\r\n{\r\nstruct img_spfi *spfi = spi_master_get_devdata(master);\r\nu32 val;\r\nval = spfi_readl(spfi, SPFI_PORT_STATE);\r\nif (msg->spi->mode & SPI_CPHA)\r\nval |= SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);\r\nelse\r\nval &= ~SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);\r\nif (msg->spi->mode & SPI_CPOL)\r\nval |= SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);\r\nelse\r\nval &= ~SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);\r\nspfi_writel(spfi, val, SPFI_PORT_STATE);\r\nreturn 0;\r\n}\r\nstatic int img_spfi_unprepare(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct img_spfi *spfi = spi_master_get_devdata(master);\r\nspfi_reset(spfi);\r\nreturn 0;\r\n}\r\nstatic int img_spfi_setup(struct spi_device *spi)\r\n{\r\nint ret = -EINVAL;\r\nstruct img_spfi_device_data *spfi_data = spi_get_ctldata(spi);\r\nif (!spfi_data) {\r\nspfi_data = kzalloc(sizeof(*spfi_data), GFP_KERNEL);\r\nif (!spfi_data)\r\nreturn -ENOMEM;\r\nspfi_data->gpio_requested = false;\r\nspi_set_ctldata(spi, spfi_data);\r\n}\r\nif (!spfi_data->gpio_requested) {\r\nret = gpio_request_one(spi->cs_gpio,\r\n(spi->mode & SPI_CS_HIGH) ?\r\nGPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,\r\ndev_name(&spi->dev));\r\nif (ret)\r\ndev_err(&spi->dev, "can't request chipselect gpio %d\n",\r\nspi->cs_gpio);\r\nelse\r\nspfi_data->gpio_requested = true;\r\n} else {\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\nint mode = ((spi->mode & SPI_CS_HIGH) ?\r\nGPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH);\r\nret = gpio_direction_output(spi->cs_gpio, mode);\r\nif (ret)\r\ndev_err(&spi->dev, "chipselect gpio %d setup failed (%d)\n",\r\nspi->cs_gpio, ret);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void img_spfi_cleanup(struct spi_device *spi)\r\n{\r\nstruct img_spfi_device_data *spfi_data = spi_get_ctldata(spi);\r\nif (spfi_data) {\r\nif (spfi_data->gpio_requested)\r\ngpio_free(spi->cs_gpio);\r\nkfree(spfi_data);\r\nspi_set_ctldata(spi, NULL);\r\n}\r\n}\r\nstatic void img_spfi_config(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct img_spfi *spfi = spi_master_get_devdata(spi->master);\r\nu32 val, div;\r\ndiv = DIV_ROUND_UP(clk_get_rate(spfi->spfi_clk), xfer->speed_hz);\r\ndiv = clamp(512 / (1 << get_count_order(div)), 1, 128);\r\nval = spfi_readl(spfi, SPFI_DEVICE_PARAMETER(spi->chip_select));\r\nval &= ~(SPFI_DEVICE_PARAMETER_BITCLK_MASK <<\r\nSPFI_DEVICE_PARAMETER_BITCLK_SHIFT);\r\nval |= div << SPFI_DEVICE_PARAMETER_BITCLK_SHIFT;\r\nspfi_writel(spfi, val, SPFI_DEVICE_PARAMETER(spi->chip_select));\r\nspfi_writel(spfi, xfer->len << SPFI_TRANSACTION_TSIZE_SHIFT,\r\nSPFI_TRANSACTION);\r\nval = spfi_readl(spfi, SPFI_CONTROL);\r\nval &= ~(SPFI_CONTROL_SEND_DMA | SPFI_CONTROL_GET_DMA);\r\nif (xfer->tx_buf)\r\nval |= SPFI_CONTROL_SEND_DMA;\r\nif (xfer->rx_buf)\r\nval |= SPFI_CONTROL_GET_DMA;\r\nval &= ~(SPFI_CONTROL_TMODE_MASK << SPFI_CONTROL_TMODE_SHIFT);\r\nif (xfer->tx_nbits == SPI_NBITS_DUAL &&\r\nxfer->rx_nbits == SPI_NBITS_DUAL)\r\nval |= SPFI_CONTROL_TMODE_DUAL << SPFI_CONTROL_TMODE_SHIFT;\r\nelse if (xfer->tx_nbits == SPI_NBITS_QUAD &&\r\nxfer->rx_nbits == SPI_NBITS_QUAD)\r\nval |= SPFI_CONTROL_TMODE_QUAD << SPFI_CONTROL_TMODE_SHIFT;\r\nval |= SPFI_CONTROL_SE;\r\nspfi_writel(spfi, val, SPFI_CONTROL);\r\n}\r\nstatic int img_spfi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct img_spfi *spfi = spi_master_get_devdata(spi->master);\r\nint ret;\r\nif (xfer->len > SPFI_TRANSACTION_TSIZE_MASK) {\r\ndev_err(spfi->dev,\r\n"Transfer length (%d) is greater than the max supported (%d)",\r\nxfer->len, SPFI_TRANSACTION_TSIZE_MASK);\r\nreturn -EINVAL;\r\n}\r\nimg_spfi_config(master, spi, xfer);\r\nif (master->can_dma && master->can_dma(master, spi, xfer))\r\nret = img_spfi_start_dma(master, spi, xfer);\r\nelse\r\nret = img_spfi_start_pio(master, spi, xfer);\r\nreturn ret;\r\n}\r\nstatic bool img_spfi_can_dma(struct spi_master *master, struct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nif (xfer->len > SPFI_32BIT_FIFO_SIZE)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic irqreturn_t img_spfi_irq(int irq, void *dev_id)\r\n{\r\nstruct img_spfi *spfi = (struct img_spfi *)dev_id;\r\nu32 status;\r\nstatus = spfi_readl(spfi, SPFI_INTERRUPT_STATUS);\r\nif (status & SPFI_INTERRUPT_IACCESS) {\r\nspfi_writel(spfi, SPFI_INTERRUPT_IACCESS, SPFI_INTERRUPT_CLEAR);\r\ndev_err(spfi->dev, "Illegal access interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int img_spfi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct img_spfi *spfi;\r\nstruct resource *res;\r\nint ret;\r\nu32 max_speed_hz;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spfi));\r\nif (!master)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, master);\r\nspfi = spi_master_get_devdata(master);\r\nspfi->dev = &pdev->dev;\r\nspfi->master = master;\r\nspin_lock_init(&spfi->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspfi->regs = devm_ioremap_resource(spfi->dev, res);\r\nif (IS_ERR(spfi->regs)) {\r\nret = PTR_ERR(spfi->regs);\r\ngoto put_spi;\r\n}\r\nspfi->phys = res->start;\r\nspfi->irq = platform_get_irq(pdev, 0);\r\nif (spfi->irq < 0) {\r\nret = spfi->irq;\r\ngoto put_spi;\r\n}\r\nret = devm_request_irq(spfi->dev, spfi->irq, img_spfi_irq,\r\nIRQ_TYPE_LEVEL_HIGH, dev_name(spfi->dev), spfi);\r\nif (ret)\r\ngoto put_spi;\r\nspfi->sys_clk = devm_clk_get(spfi->dev, "sys");\r\nif (IS_ERR(spfi->sys_clk)) {\r\nret = PTR_ERR(spfi->sys_clk);\r\ngoto put_spi;\r\n}\r\nspfi->spfi_clk = devm_clk_get(spfi->dev, "spfi");\r\nif (IS_ERR(spfi->spfi_clk)) {\r\nret = PTR_ERR(spfi->spfi_clk);\r\ngoto put_spi;\r\n}\r\nret = clk_prepare_enable(spfi->sys_clk);\r\nif (ret)\r\ngoto put_spi;\r\nret = clk_prepare_enable(spfi->spfi_clk);\r\nif (ret)\r\ngoto disable_pclk;\r\nspfi_reset(spfi);\r\nspfi_writel(spfi, SPFI_INTERRUPT_IACCESS, SPFI_INTERRUPT_ENABLE);\r\nmaster->auto_runtime_pm = true;\r\nmaster->bus_num = pdev->id;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_TX_DUAL | SPI_RX_DUAL;\r\nif (of_property_read_bool(spfi->dev->of_node, "img,supports-quad-mode"))\r\nmaster->mode_bits |= SPI_TX_QUAD | SPI_RX_QUAD;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(8);\r\nmaster->max_speed_hz = clk_get_rate(spfi->spfi_clk) / 4;\r\nmaster->min_speed_hz = clk_get_rate(spfi->spfi_clk) / 512;\r\nif (!of_property_read_u32(spfi->dev->of_node, "spfi-max-frequency",\r\n&max_speed_hz)) {\r\nif (master->max_speed_hz > max_speed_hz)\r\nmaster->max_speed_hz = max_speed_hz;\r\n}\r\nmaster->setup = img_spfi_setup;\r\nmaster->cleanup = img_spfi_cleanup;\r\nmaster->transfer_one = img_spfi_transfer_one;\r\nmaster->prepare_message = img_spfi_prepare;\r\nmaster->unprepare_message = img_spfi_unprepare;\r\nmaster->handle_err = img_spfi_handle_err;\r\nspfi->tx_ch = dma_request_slave_channel(spfi->dev, "tx");\r\nspfi->rx_ch = dma_request_slave_channel(spfi->dev, "rx");\r\nif (!spfi->tx_ch || !spfi->rx_ch) {\r\nif (spfi->tx_ch)\r\ndma_release_channel(spfi->tx_ch);\r\nif (spfi->rx_ch)\r\ndma_release_channel(spfi->rx_ch);\r\ndev_warn(spfi->dev, "Failed to get DMA channels, falling back to PIO mode\n");\r\n} else {\r\nmaster->dma_tx = spfi->tx_ch;\r\nmaster->dma_rx = spfi->rx_ch;\r\nmaster->can_dma = img_spfi_can_dma;\r\n}\r\npm_runtime_set_active(spfi->dev);\r\npm_runtime_enable(spfi->dev);\r\nret = devm_spi_register_master(spfi->dev, master);\r\nif (ret)\r\ngoto disable_pm;\r\nreturn 0;\r\ndisable_pm:\r\npm_runtime_disable(spfi->dev);\r\nif (spfi->rx_ch)\r\ndma_release_channel(spfi->rx_ch);\r\nif (spfi->tx_ch)\r\ndma_release_channel(spfi->tx_ch);\r\nclk_disable_unprepare(spfi->spfi_clk);\r\ndisable_pclk:\r\nclk_disable_unprepare(spfi->sys_clk);\r\nput_spi:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int img_spfi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct img_spfi *spfi = spi_master_get_devdata(master);\r\nif (spfi->tx_ch)\r\ndma_release_channel(spfi->tx_ch);\r\nif (spfi->rx_ch)\r\ndma_release_channel(spfi->rx_ch);\r\npm_runtime_disable(spfi->dev);\r\nif (!pm_runtime_status_suspended(spfi->dev)) {\r\nclk_disable_unprepare(spfi->spfi_clk);\r\nclk_disable_unprepare(spfi->sys_clk);\r\n}\r\nspi_master_put(master);\r\nreturn 0;\r\n}\r\nstatic int img_spfi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct img_spfi *spfi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(spfi->spfi_clk);\r\nclk_disable_unprepare(spfi->sys_clk);\r\nreturn 0;\r\n}\r\nstatic int img_spfi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct img_spfi *spfi = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(spfi->sys_clk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(spfi->spfi_clk);\r\nif (ret) {\r\nclk_disable_unprepare(spfi->sys_clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int img_spfi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nreturn spi_master_suspend(master);\r\n}\r\nstatic int img_spfi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct img_spfi *spfi = spi_master_get_devdata(master);\r\nint ret;\r\nret = pm_runtime_get_sync(dev);\r\nif (ret)\r\nreturn ret;\r\nspfi_reset(spfi);\r\npm_runtime_put(dev);\r\nreturn spi_master_resume(master);\r\n}
