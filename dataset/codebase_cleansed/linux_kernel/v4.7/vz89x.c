static int vz89x_measurement_is_valid(struct vz89x_data *data)\r\n{\r\nif (data->buffer[VZ89X_VOC_SHORT_IDX] == 0)\r\nreturn 1;\r\nreturn !!(data->buffer[VZ89X_REG_MEASUREMENT_SIZE - 1] > 0);\r\n}\r\nstatic int vz89x_i2c_xfer(struct vz89x_data *data, u8 cmd)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct i2c_msg msg[2];\r\nint ret;\r\nu8 buf[3] = { cmd, 0, 0};\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = client->flags;\r\nmsg[0].len = 3;\r\nmsg[0].buf = (char *) &buf;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = client->flags | I2C_M_RD;\r\nmsg[1].len = VZ89X_REG_MEASUREMENT_SIZE;\r\nmsg[1].buf = (char *) &data->buffer;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nreturn (ret == 2) ? 0 : ret;\r\n}\r\nstatic int vz89x_smbus_xfer(struct vz89x_data *data, u8 cmd)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nint i;\r\nret = i2c_smbus_write_word_data(client, cmd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < VZ89X_REG_MEASUREMENT_SIZE; i++) {\r\nret = i2c_smbus_read_byte(client);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->buffer[i] = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vz89x_get_measurement(struct vz89x_data *data)\r\n{\r\nint ret;\r\nif (!time_after(jiffies, data->last_update + HZ))\r\nreturn 0;\r\nret = data->xfer(data, VZ89X_REG_MEASUREMENT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = vz89x_measurement_is_valid(data);\r\nif (ret)\r\nreturn -EAGAIN;\r\ndata->last_update = jiffies;\r\nreturn 0;\r\n}\r\nstatic int vz89x_get_resistance_reading(struct vz89x_data *data)\r\n{\r\nu8 *buf = &data->buffer[VZ89X_VOC_RESISTANCE_IDX];\r\nreturn buf[0] | (buf[1] << 8);\r\n}\r\nstatic int vz89x_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nstruct vz89x_data *data = iio_priv(indio_dev);\r\nint ret = -EINVAL;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&data->lock);\r\nret = vz89x_get_measurement(data);\r\nmutex_unlock(&data->lock);\r\nif (ret)\r\nreturn ret;\r\nswitch (chan->address) {\r\ncase VZ89X_VOC_CO2_IDX:\r\ncase VZ89X_VOC_SHORT_IDX:\r\ncase VZ89X_VOC_TVOC_IDX:\r\n*val = data->buffer[chan->address];\r\nreturn IIO_VAL_INT;\r\ncase VZ89X_VOC_RESISTANCE_IDX:\r\n*val = vz89x_get_resistance_reading(data);\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_RESISTANCE:\r\n*val = 10;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (chan->address) {\r\ncase VZ89X_VOC_CO2_IDX:\r\n*val = 44;\r\n*val2 = 250000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase VZ89X_VOC_TVOC_IDX:\r\n*val = -13;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int vz89x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct vz89x_data *data;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\ndata->xfer = vz89x_i2c_xfer;\r\nelse if (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BYTE))\r\ndata->xfer = vz89x_smbus_xfer;\r\nelse\r\nreturn -EOPNOTSUPP;\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\ndata->last_update = jiffies - HZ;\r\nmutex_init(&data->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &vz89x_info,\r\nindio_dev->name = dev_name(&client->dev);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = vz89x_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(vz89x_channels);\r\nreturn devm_iio_device_register(&client->dev, indio_dev);\r\n}
