static irqreturn_t asm9260_rtc_irq(int irq, void *dev_id)\r\n{\r\nstruct asm9260_rtc_priv *priv = dev_id;\r\nu32 isr;\r\nunsigned long events = 0;\r\nisr = ioread32(priv->iobase + HW_CIIR);\r\nif (!isr)\r\nreturn IRQ_NONE;\r\niowrite32(0, priv->iobase + HW_CIIR);\r\nevents |= RTC_AF | RTC_IRQF;\r\nrtc_update_irq(priv->rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int asm9260_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\r\nu32 ctime0, ctime1, ctime2;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&priv->lock, irq_flags);\r\nctime0 = ioread32(priv->iobase + HW_CTIME0);\r\nctime1 = ioread32(priv->iobase + HW_CTIME1);\r\nctime2 = ioread32(priv->iobase + HW_CTIME2);\r\nif (ctime1 != ioread32(priv->iobase + HW_CTIME1)) {\r\nctime0 = ioread32(priv->iobase + HW_CTIME0);\r\nctime1 = ioread32(priv->iobase + HW_CTIME1);\r\nctime2 = ioread32(priv->iobase + HW_CTIME2);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, irq_flags);\r\ntm->tm_sec = (ctime0 >> BM_CTIME0_SEC_S) & BM_CTIME0_SEC_M;\r\ntm->tm_min = (ctime0 >> BM_CTIME0_MIN_S) & BM_CTIME0_MIN_M;\r\ntm->tm_hour = (ctime0 >> BM_CTIME0_HOUR_S) & BM_CTIME0_HOUR_M;\r\ntm->tm_wday = (ctime0 >> BM_CTIME0_DOW_S) & BM_CTIME0_DOW_M;\r\ntm->tm_mday = (ctime1 >> BM_CTIME1_DOM_S) & BM_CTIME1_DOM_M;\r\ntm->tm_mon = (ctime1 >> BM_CTIME1_MON_S) & BM_CTIME1_MON_M;\r\ntm->tm_year = (ctime1 >> BM_CTIME1_YEAR_S) & BM_CTIME1_YEAR_M;\r\ntm->tm_yday = (ctime2 >> BM_CTIME2_DOY_S) & BM_CTIME2_DOY_M;\r\nreturn 0;\r\n}\r\nstatic int asm9260_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&priv->lock, irq_flags);\r\niowrite32(0, priv->iobase + HW_SEC);\r\niowrite32(tm->tm_year, priv->iobase + HW_YEAR);\r\niowrite32(tm->tm_mon, priv->iobase + HW_MONTH);\r\niowrite32(tm->tm_mday, priv->iobase + HW_DOM);\r\niowrite32(tm->tm_wday, priv->iobase + HW_DOW);\r\niowrite32(tm->tm_yday, priv->iobase + HW_DOY);\r\niowrite32(tm->tm_hour, priv->iobase + HW_HOUR);\r\niowrite32(tm->tm_min, priv->iobase + HW_MIN);\r\niowrite32(tm->tm_sec, priv->iobase + HW_SEC);\r\nspin_unlock_irqrestore(&priv->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int asm9260_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&priv->lock, irq_flags);\r\nalrm->time.tm_year = ioread32(priv->iobase + HW_ALYEAR);\r\nalrm->time.tm_mon = ioread32(priv->iobase + HW_ALMON);\r\nalrm->time.tm_mday = ioread32(priv->iobase + HW_ALDOM);\r\nalrm->time.tm_wday = ioread32(priv->iobase + HW_ALDOW);\r\nalrm->time.tm_yday = ioread32(priv->iobase + HW_ALDOY);\r\nalrm->time.tm_hour = ioread32(priv->iobase + HW_ALHOUR);\r\nalrm->time.tm_min = ioread32(priv->iobase + HW_ALMIN);\r\nalrm->time.tm_sec = ioread32(priv->iobase + HW_ALSEC);\r\nalrm->enabled = ioread32(priv->iobase + HW_AMR) ? 1 : 0;\r\nalrm->pending = ioread32(priv->iobase + HW_CIIR) ? 1 : 0;\r\nspin_unlock_irqrestore(&priv->lock, irq_flags);\r\nreturn rtc_valid_tm(&alrm->time);\r\n}\r\nstatic int asm9260_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&priv->lock, irq_flags);\r\niowrite32(alrm->time.tm_year, priv->iobase + HW_ALYEAR);\r\niowrite32(alrm->time.tm_mon, priv->iobase + HW_ALMON);\r\niowrite32(alrm->time.tm_mday, priv->iobase + HW_ALDOM);\r\niowrite32(alrm->time.tm_wday, priv->iobase + HW_ALDOW);\r\niowrite32(alrm->time.tm_yday, priv->iobase + HW_ALDOY);\r\niowrite32(alrm->time.tm_hour, priv->iobase + HW_ALHOUR);\r\niowrite32(alrm->time.tm_min, priv->iobase + HW_ALMIN);\r\niowrite32(alrm->time.tm_sec, priv->iobase + HW_ALSEC);\r\niowrite32(alrm->enabled ? 0 : BM_AMR_OFF, priv->iobase + HW_AMR);\r\nspin_unlock_irqrestore(&priv->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int asm9260_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct asm9260_rtc_priv *priv = dev_get_drvdata(dev);\r\niowrite32(enabled ? 0 : BM_AMR_OFF, priv->iobase + HW_AMR);\r\nreturn 0;\r\n}\r\nstatic int asm9260_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct asm9260_rtc_priv *priv;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nint irq_alarm, ret;\r\nu32 ccr;\r\npriv = devm_kzalloc(dev, sizeof(struct asm9260_rtc_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, priv);\r\nirq_alarm = platform_get_irq(pdev, 0);\r\nif (irq_alarm < 0) {\r\ndev_err(dev, "No alarm IRQ resource defined\n");\r\nreturn irq_alarm;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->iobase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->iobase))\r\nreturn PTR_ERR(priv->iobase);\r\npriv->clk = devm_clk_get(dev, "ahb");\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable clk!\n");\r\nreturn ret;\r\n}\r\nccr = ioread32(priv->iobase + HW_CCR);\r\nif ((ccr & (BM_CLKEN | BM_CTCRST)) != BM_CLKEN) {\r\niowrite32(BM_CTCRST, priv->iobase + HW_CCR);\r\nccr = 0;\r\n}\r\niowrite32(BM_CLKEN | ccr, priv->iobase + HW_CCR);\r\niowrite32(0, priv->iobase + HW_CIIR);\r\niowrite32(BM_AMR_OFF, priv->iobase + HW_AMR);\r\npriv->rtc = devm_rtc_device_register(dev, dev_name(dev),\r\n&asm9260_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(priv->rtc)) {\r\nret = PTR_ERR(priv->rtc);\r\ndev_err(dev, "Failed to register RTC device: %d\n", ret);\r\ngoto err_return;\r\n}\r\nret = devm_request_threaded_irq(dev, irq_alarm, NULL,\r\nasm9260_rtc_irq, IRQF_ONESHOT,\r\ndev_name(dev), priv);\r\nif (ret < 0) {\r\ndev_err(dev, "can't get irq %i, err %d\n",\r\nirq_alarm, ret);\r\ngoto err_return;\r\n}\r\nreturn 0;\r\nerr_return:\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int asm9260_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct asm9260_rtc_priv *priv = platform_get_drvdata(pdev);\r\niowrite32(BM_AMR_OFF, priv->iobase + HW_AMR);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}
