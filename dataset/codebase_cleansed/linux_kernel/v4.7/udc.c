static inline int hw_ep_bit(int num, int dir)\r\n{\r\nreturn num + (dir ? 16 : 0);\r\n}\r\nstatic inline int ep_to_bit(struct ci_hdrc *ci, int n)\r\n{\r\nint fill = 16 - ci->hw_ep_max / 2;\r\nif (n >= ci->hw_ep_max / 2)\r\nn += fill;\r\nreturn n;\r\n}\r\nstatic int hw_device_state(struct ci_hdrc *ci, u32 dma)\r\n{\r\nif (dma) {\r\nhw_write(ci, OP_ENDPTLISTADDR, ~0, dma);\r\nhw_write(ci, OP_USBINTR, ~0,\r\nUSBi_UI|USBi_UEI|USBi_PCI|USBi_URI|USBi_SLI);\r\n} else {\r\nhw_write(ci, OP_USBINTR, ~0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_ep_flush(struct ci_hdrc *ci, int num, int dir)\r\n{\r\nint n = hw_ep_bit(num, dir);\r\ndo {\r\nhw_write(ci, OP_ENDPTFLUSH, ~0, BIT(n));\r\nwhile (hw_read(ci, OP_ENDPTFLUSH, BIT(n)))\r\ncpu_relax();\r\n} while (hw_read(ci, OP_ENDPTSTAT, BIT(n)));\r\nreturn 0;\r\n}\r\nstatic int hw_ep_disable(struct ci_hdrc *ci, int num, int dir)\r\n{\r\nhw_ep_flush(ci, num, dir);\r\nhw_write(ci, OP_ENDPTCTRL + num,\r\ndir ? ENDPTCTRL_TXE : ENDPTCTRL_RXE, 0);\r\nreturn 0;\r\n}\r\nstatic int hw_ep_enable(struct ci_hdrc *ci, int num, int dir, int type)\r\n{\r\nu32 mask, data;\r\nif (dir) {\r\nmask = ENDPTCTRL_TXT;\r\ndata = type << __ffs(mask);\r\nmask |= ENDPTCTRL_TXS;\r\nmask |= ENDPTCTRL_TXR;\r\ndata |= ENDPTCTRL_TXR;\r\nmask |= ENDPTCTRL_TXE;\r\ndata |= ENDPTCTRL_TXE;\r\n} else {\r\nmask = ENDPTCTRL_RXT;\r\ndata = type << __ffs(mask);\r\nmask |= ENDPTCTRL_RXS;\r\nmask |= ENDPTCTRL_RXR;\r\ndata |= ENDPTCTRL_RXR;\r\nmask |= ENDPTCTRL_RXE;\r\ndata |= ENDPTCTRL_RXE;\r\n}\r\nhw_write(ci, OP_ENDPTCTRL + num, mask, data);\r\nreturn 0;\r\n}\r\nstatic int hw_ep_get_halt(struct ci_hdrc *ci, int num, int dir)\r\n{\r\nu32 mask = dir ? ENDPTCTRL_TXS : ENDPTCTRL_RXS;\r\nreturn hw_read(ci, OP_ENDPTCTRL + num, mask) ? 1 : 0;\r\n}\r\nstatic int hw_ep_prime(struct ci_hdrc *ci, int num, int dir, int is_ctrl)\r\n{\r\nint n = hw_ep_bit(num, dir);\r\nif (is_ctrl && dir == RX && hw_read(ci, OP_ENDPTSETUPSTAT, BIT(num)))\r\nreturn -EAGAIN;\r\nhw_write(ci, OP_ENDPTPRIME, ~0, BIT(n));\r\nwhile (hw_read(ci, OP_ENDPTPRIME, BIT(n)))\r\ncpu_relax();\r\nif (is_ctrl && dir == RX && hw_read(ci, OP_ENDPTSETUPSTAT, BIT(num)))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int hw_ep_set_halt(struct ci_hdrc *ci, int num, int dir, int value)\r\n{\r\nif (value != 0 && value != 1)\r\nreturn -EINVAL;\r\ndo {\r\nenum ci_hw_regs reg = OP_ENDPTCTRL + num;\r\nu32 mask_xs = dir ? ENDPTCTRL_TXS : ENDPTCTRL_RXS;\r\nu32 mask_xr = dir ? ENDPTCTRL_TXR : ENDPTCTRL_RXR;\r\nhw_write(ci, reg, mask_xs|mask_xr,\r\nvalue ? mask_xs : mask_xr);\r\n} while (value != hw_ep_get_halt(ci, num, dir));\r\nreturn 0;\r\n}\r\nstatic int hw_port_is_high_speed(struct ci_hdrc *ci)\r\n{\r\nreturn ci->hw_bank.lpm ? hw_read(ci, OP_DEVLC, DEVLC_PSPD) :\r\nhw_read(ci, OP_PORTSC, PORTSC_HSP);\r\n}\r\nstatic int hw_test_and_clear_complete(struct ci_hdrc *ci, int n)\r\n{\r\nn = ep_to_bit(ci, n);\r\nreturn hw_test_and_clear(ci, OP_ENDPTCOMPLETE, BIT(n));\r\n}\r\nstatic u32 hw_test_and_clear_intr_active(struct ci_hdrc *ci)\r\n{\r\nu32 reg = hw_read_intr_status(ci) & hw_read_intr_enable(ci);\r\nhw_write(ci, OP_USBSTS, ~0, reg);\r\nreturn reg;\r\n}\r\nstatic int hw_test_and_clear_setup_guard(struct ci_hdrc *ci)\r\n{\r\nreturn hw_test_and_write(ci, OP_USBCMD, USBCMD_SUTW, 0);\r\n}\r\nstatic int hw_test_and_set_setup_guard(struct ci_hdrc *ci)\r\n{\r\nreturn hw_test_and_write(ci, OP_USBCMD, USBCMD_SUTW, USBCMD_SUTW);\r\n}\r\nstatic void hw_usb_set_address(struct ci_hdrc *ci, u8 value)\r\n{\r\nhw_write(ci, OP_DEVICEADDR, DEVICEADDR_USBADR,\r\nvalue << __ffs(DEVICEADDR_USBADR));\r\n}\r\nstatic int hw_usb_reset(struct ci_hdrc *ci)\r\n{\r\nhw_usb_set_address(ci, 0);\r\nhw_write(ci, OP_ENDPTFLUSH, ~0, ~0);\r\nhw_write(ci, OP_ENDPTSETUPSTAT, 0, 0);\r\nhw_write(ci, OP_ENDPTCOMPLETE, 0, 0);\r\nwhile (hw_read(ci, OP_ENDPTPRIME, ~0))\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int add_td_to_list(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq,\r\nunsigned length)\r\n{\r\nint i;\r\nu32 temp;\r\nstruct td_node *lastnode, *node = kzalloc(sizeof(struct td_node),\r\nGFP_ATOMIC);\r\nif (node == NULL)\r\nreturn -ENOMEM;\r\nnode->ptr = dma_pool_zalloc(hwep->td_pool, GFP_ATOMIC,\r\n&node->dma);\r\nif (node->ptr == NULL) {\r\nkfree(node);\r\nreturn -ENOMEM;\r\n}\r\nnode->ptr->token = cpu_to_le32(length << __ffs(TD_TOTAL_BYTES));\r\nnode->ptr->token &= cpu_to_le32(TD_TOTAL_BYTES);\r\nnode->ptr->token |= cpu_to_le32(TD_STATUS_ACTIVE);\r\nif (hwep->type == USB_ENDPOINT_XFER_ISOC && hwep->dir == TX) {\r\nu32 mul = hwreq->req.length / hwep->ep.maxpacket;\r\nif (hwreq->req.length == 0\r\n|| hwreq->req.length % hwep->ep.maxpacket)\r\nmul++;\r\nnode->ptr->token |= mul << __ffs(TD_MULTO);\r\n}\r\ntemp = (u32) (hwreq->req.dma + hwreq->req.actual);\r\nif (length) {\r\nnode->ptr->page[0] = cpu_to_le32(temp);\r\nfor (i = 1; i < TD_PAGE_COUNT; i++) {\r\nu32 page = temp + i * CI_HDRC_PAGE_SIZE;\r\npage &= ~TD_RESERVED_MASK;\r\nnode->ptr->page[i] = cpu_to_le32(page);\r\n}\r\n}\r\nhwreq->req.actual += length;\r\nif (!list_empty(&hwreq->tds)) {\r\nlastnode = list_entry(hwreq->tds.prev,\r\nstruct td_node, td);\r\nlastnode->ptr->next = cpu_to_le32(node->dma);\r\n}\r\nINIT_LIST_HEAD(&node->td);\r\nlist_add_tail(&node->td, &hwreq->tds);\r\nreturn 0;\r\n}\r\nstatic inline u8 _usb_addr(struct ci_hw_ep *ep)\r\n{\r\nreturn ((ep->dir == TX) ? USB_ENDPOINT_DIR_MASK : 0) | ep->num;\r\n}\r\nstatic int _hardware_enqueue(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq)\r\n{\r\nstruct ci_hdrc *ci = hwep->ci;\r\nint ret = 0;\r\nunsigned rest = hwreq->req.length;\r\nint pages = TD_PAGE_COUNT;\r\nstruct td_node *firstnode, *lastnode;\r\nif (hwreq->req.status == -EALREADY)\r\nreturn -EALREADY;\r\nhwreq->req.status = -EALREADY;\r\nret = usb_gadget_map_request(&ci->gadget, &hwreq->req, hwep->dir);\r\nif (ret)\r\nreturn ret;\r\nif (hwreq->req.dma % PAGE_SIZE)\r\npages--;\r\nif (rest == 0) {\r\nret = add_td_to_list(hwep, hwreq, 0);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nwhile (rest > 0) {\r\nunsigned count = min(hwreq->req.length - hwreq->req.actual,\r\n(unsigned)(pages * CI_HDRC_PAGE_SIZE));\r\nret = add_td_to_list(hwep, hwreq, count);\r\nif (ret < 0)\r\ngoto done;\r\nrest -= count;\r\n}\r\nif (hwreq->req.zero && hwreq->req.length && hwep->dir == TX\r\n&& (hwreq->req.length % hwep->ep.maxpacket == 0)) {\r\nret = add_td_to_list(hwep, hwreq, 0);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nfirstnode = list_first_entry(&hwreq->tds, struct td_node, td);\r\nlastnode = list_entry(hwreq->tds.prev,\r\nstruct td_node, td);\r\nlastnode->ptr->next = cpu_to_le32(TD_TERMINATE);\r\nif (!hwreq->req.no_interrupt)\r\nlastnode->ptr->token |= cpu_to_le32(TD_IOC);\r\nwmb();\r\nhwreq->req.actual = 0;\r\nif (!list_empty(&hwep->qh.queue)) {\r\nstruct ci_hw_req *hwreqprev;\r\nint n = hw_ep_bit(hwep->num, hwep->dir);\r\nint tmp_stat;\r\nstruct td_node *prevlastnode;\r\nu32 next = firstnode->dma & TD_ADDR_MASK;\r\nhwreqprev = list_entry(hwep->qh.queue.prev,\r\nstruct ci_hw_req, queue);\r\nprevlastnode = list_entry(hwreqprev->tds.prev,\r\nstruct td_node, td);\r\nprevlastnode->ptr->next = cpu_to_le32(next);\r\nwmb();\r\nif (hw_read(ci, OP_ENDPTPRIME, BIT(n)))\r\ngoto done;\r\ndo {\r\nhw_write(ci, OP_USBCMD, USBCMD_ATDTW, USBCMD_ATDTW);\r\ntmp_stat = hw_read(ci, OP_ENDPTSTAT, BIT(n));\r\n} while (!hw_read(ci, OP_USBCMD, USBCMD_ATDTW));\r\nhw_write(ci, OP_USBCMD, USBCMD_ATDTW, 0);\r\nif (tmp_stat)\r\ngoto done;\r\n}\r\nhwep->qh.ptr->td.next = cpu_to_le32(firstnode->dma);\r\nhwep->qh.ptr->td.token &=\r\ncpu_to_le32(~(TD_STATUS_HALTED|TD_STATUS_ACTIVE));\r\nif (hwep->type == USB_ENDPOINT_XFER_ISOC && hwep->dir == RX) {\r\nu32 mul = hwreq->req.length / hwep->ep.maxpacket;\r\nif (hwreq->req.length == 0\r\n|| hwreq->req.length % hwep->ep.maxpacket)\r\nmul++;\r\nhwep->qh.ptr->cap |= mul << __ffs(QH_MULT);\r\n}\r\nwmb();\r\nret = hw_ep_prime(ci, hwep->num, hwep->dir,\r\nhwep->type == USB_ENDPOINT_XFER_CONTROL);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void free_pending_td(struct ci_hw_ep *hwep)\r\n{\r\nstruct td_node *pending = hwep->pending_td;\r\ndma_pool_free(hwep->td_pool, pending->ptr, pending->dma);\r\nhwep->pending_td = NULL;\r\nkfree(pending);\r\n}\r\nstatic int reprime_dtd(struct ci_hdrc *ci, struct ci_hw_ep *hwep,\r\nstruct td_node *node)\r\n{\r\nhwep->qh.ptr->td.next = node->dma;\r\nhwep->qh.ptr->td.token &=\r\ncpu_to_le32(~(TD_STATUS_HALTED | TD_STATUS_ACTIVE));\r\nwmb();\r\nreturn hw_ep_prime(ci, hwep->num, hwep->dir,\r\nhwep->type == USB_ENDPOINT_XFER_CONTROL);\r\n}\r\nstatic int _hardware_dequeue(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq)\r\n{\r\nu32 tmptoken;\r\nstruct td_node *node, *tmpnode;\r\nunsigned remaining_length;\r\nunsigned actual = hwreq->req.length;\r\nstruct ci_hdrc *ci = hwep->ci;\r\nif (hwreq->req.status != -EALREADY)\r\nreturn -EINVAL;\r\nhwreq->req.status = 0;\r\nlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\r\ntmptoken = le32_to_cpu(node->ptr->token);\r\nif ((TD_STATUS_ACTIVE & tmptoken) != 0) {\r\nint n = hw_ep_bit(hwep->num, hwep->dir);\r\nif (ci->rev == CI_REVISION_24)\r\nif (!hw_read(ci, OP_ENDPTSTAT, BIT(n)))\r\nreprime_dtd(ci, hwep, node);\r\nhwreq->req.status = -EALREADY;\r\nreturn -EBUSY;\r\n}\r\nremaining_length = (tmptoken & TD_TOTAL_BYTES);\r\nremaining_length >>= __ffs(TD_TOTAL_BYTES);\r\nactual -= remaining_length;\r\nhwreq->req.status = tmptoken & TD_STATUS;\r\nif ((TD_STATUS_HALTED & hwreq->req.status)) {\r\nhwreq->req.status = -EPIPE;\r\nbreak;\r\n} else if ((TD_STATUS_DT_ERR & hwreq->req.status)) {\r\nhwreq->req.status = -EPROTO;\r\nbreak;\r\n} else if ((TD_STATUS_TR_ERR & hwreq->req.status)) {\r\nhwreq->req.status = -EILSEQ;\r\nbreak;\r\n}\r\nif (remaining_length) {\r\nif (hwep->dir) {\r\nhwreq->req.status = -EPROTO;\r\nbreak;\r\n}\r\n}\r\nif (hwep->pending_td)\r\nfree_pending_td(hwep);\r\nhwep->pending_td = node;\r\nlist_del_init(&node->td);\r\n}\r\nusb_gadget_unmap_request(&hwep->ci->gadget, &hwreq->req, hwep->dir);\r\nhwreq->req.actual += actual;\r\nif (hwreq->req.status)\r\nreturn hwreq->req.status;\r\nreturn hwreq->req.actual;\r\n}\r\nstatic int _ep_nuke(struct ci_hw_ep *hwep)\r\n__releases(hwep->lock)\r\n__acquires(hwep->lock)\r\n{\r\nstruct td_node *node, *tmpnode;\r\nif (hwep == NULL)\r\nreturn -EINVAL;\r\nhw_ep_flush(hwep->ci, hwep->num, hwep->dir);\r\nwhile (!list_empty(&hwep->qh.queue)) {\r\nstruct ci_hw_req *hwreq = list_entry(hwep->qh.queue.next,\r\nstruct ci_hw_req, queue);\r\nlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\r\ndma_pool_free(hwep->td_pool, node->ptr, node->dma);\r\nlist_del_init(&node->td);\r\nnode->ptr = NULL;\r\nkfree(node);\r\n}\r\nlist_del_init(&hwreq->queue);\r\nhwreq->req.status = -ESHUTDOWN;\r\nif (hwreq->req.complete != NULL) {\r\nspin_unlock(hwep->lock);\r\nusb_gadget_giveback_request(&hwep->ep, &hwreq->req);\r\nspin_lock(hwep->lock);\r\n}\r\n}\r\nif (hwep->pending_td)\r\nfree_pending_td(hwep);\r\nreturn 0;\r\n}\r\nstatic int _ep_set_halt(struct usb_ep *ep, int value, bool check_transfer)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nint direction, retval = 0;\r\nunsigned long flags;\r\nif (ep == NULL || hwep->ep.desc == NULL)\r\nreturn -EINVAL;\r\nif (usb_endpoint_xfer_isoc(hwep->ep.desc))\r\nreturn -EOPNOTSUPP;\r\nspin_lock_irqsave(hwep->lock, flags);\r\nif (value && hwep->dir == TX && check_transfer &&\r\n!list_empty(&hwep->qh.queue) &&\r\n!usb_endpoint_xfer_control(hwep->ep.desc)) {\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\ndirection = hwep->dir;\r\ndo {\r\nretval |= hw_ep_set_halt(hwep->ci, hwep->num, hwep->dir, value);\r\nif (!value)\r\nhwep->wedge = 0;\r\nif (hwep->type == USB_ENDPOINT_XFER_CONTROL)\r\nhwep->dir = (hwep->dir == TX) ? RX : TX;\r\n} while (hwep->dir != direction);\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int _gadget_stop_activity(struct usb_gadget *gadget)\r\n{\r\nstruct usb_ep *ep;\r\nstruct ci_hdrc *ci = container_of(gadget, struct ci_hdrc, gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nci->gadget.speed = USB_SPEED_UNKNOWN;\r\nci->remote_wakeup = 0;\r\nci->suspended = 0;\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\ngadget_for_each_ep(ep, gadget) {\r\nusb_ep_fifo_flush(ep);\r\n}\r\nusb_ep_fifo_flush(&ci->ep0out->ep);\r\nusb_ep_fifo_flush(&ci->ep0in->ep);\r\ngadget_for_each_ep(ep, gadget) {\r\nusb_ep_disable(ep);\r\n}\r\nif (ci->status != NULL) {\r\nusb_ep_free_request(&ci->ep0in->ep, ci->status);\r\nci->status = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isr_reset_handler(struct ci_hdrc *ci)\r\n__releases(ci->lock)\r\n__acquires(ci->lock)\r\n{\r\nint retval;\r\nspin_unlock(&ci->lock);\r\nif (ci->gadget.speed != USB_SPEED_UNKNOWN)\r\nusb_gadget_udc_reset(&ci->gadget, ci->driver);\r\nretval = _gadget_stop_activity(&ci->gadget);\r\nif (retval)\r\ngoto done;\r\nretval = hw_usb_reset(ci);\r\nif (retval)\r\ngoto done;\r\nci->status = usb_ep_alloc_request(&ci->ep0in->ep, GFP_ATOMIC);\r\nif (ci->status == NULL)\r\nretval = -ENOMEM;\r\ndone:\r\nspin_lock(&ci->lock);\r\nif (retval)\r\ndev_err(ci->dev, "error: %i\n", retval);\r\n}\r\nstatic void isr_get_status_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nif (ep == NULL || req == NULL)\r\nreturn;\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic int _ep_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t __maybe_unused gfp_flags)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nstruct ci_hw_req *hwreq = container_of(req, struct ci_hw_req, req);\r\nstruct ci_hdrc *ci = hwep->ci;\r\nint retval = 0;\r\nif (ep == NULL || req == NULL || hwep->ep.desc == NULL)\r\nreturn -EINVAL;\r\nif (hwep->type == USB_ENDPOINT_XFER_CONTROL) {\r\nif (req->length)\r\nhwep = (ci->ep0_dir == RX) ?\r\nci->ep0out : ci->ep0in;\r\nif (!list_empty(&hwep->qh.queue)) {\r\n_ep_nuke(hwep);\r\ndev_warn(hwep->ci->dev, "endpoint ctrl %X nuked\n",\r\n_usb_addr(hwep));\r\n}\r\n}\r\nif (usb_endpoint_xfer_isoc(hwep->ep.desc) &&\r\nhwreq->req.length > (1 + hwep->ep.mult) * hwep->ep.maxpacket) {\r\ndev_err(hwep->ci->dev, "request length too big for isochronous\n");\r\nreturn -EMSGSIZE;\r\n}\r\nif (!list_empty(&hwreq->queue)) {\r\ndev_err(hwep->ci->dev, "request already in queue\n");\r\nreturn -EBUSY;\r\n}\r\nhwreq->req.status = -EINPROGRESS;\r\nhwreq->req.actual = 0;\r\nretval = _hardware_enqueue(hwep, hwreq);\r\nif (retval == -EALREADY)\r\nretval = 0;\r\nif (!retval)\r\nlist_add_tail(&hwreq->queue, &hwep->qh.queue);\r\nreturn retval;\r\n}\r\nstatic int isr_get_status_response(struct ci_hdrc *ci,\r\nstruct usb_ctrlrequest *setup)\r\n__releases(hwep->lock)\r\n__acquires(hwep->lock)\r\n{\r\nstruct ci_hw_ep *hwep = ci->ep0in;\r\nstruct usb_request *req = NULL;\r\ngfp_t gfp_flags = GFP_ATOMIC;\r\nint dir, num, retval;\r\nif (hwep == NULL || setup == NULL)\r\nreturn -EINVAL;\r\nspin_unlock(hwep->lock);\r\nreq = usb_ep_alloc_request(&hwep->ep, gfp_flags);\r\nspin_lock(hwep->lock);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->complete = isr_get_status_complete;\r\nreq->length = 2;\r\nreq->buf = kzalloc(req->length, gfp_flags);\r\nif (req->buf == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_free_req;\r\n}\r\nif ((setup->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\r\n*(u16 *)req->buf = (ci->remote_wakeup << 1) |\r\nci->gadget.is_selfpowered;\r\n} else if ((setup->bRequestType & USB_RECIP_MASK) \\r\n== USB_RECIP_ENDPOINT) {\r\ndir = (le16_to_cpu(setup->wIndex) & USB_ENDPOINT_DIR_MASK) ?\r\nTX : RX;\r\nnum = le16_to_cpu(setup->wIndex) & USB_ENDPOINT_NUMBER_MASK;\r\n*(u16 *)req->buf = hw_ep_get_halt(ci, num, dir);\r\n}\r\nretval = _ep_queue(&hwep->ep, req, gfp_flags);\r\nif (retval)\r\ngoto err_free_buf;\r\nreturn 0;\r\nerr_free_buf:\r\nkfree(req->buf);\r\nerr_free_req:\r\nspin_unlock(hwep->lock);\r\nusb_ep_free_request(&hwep->ep, req);\r\nspin_lock(hwep->lock);\r\nreturn retval;\r\n}\r\nstatic void\r\nisr_setup_status_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ci_hdrc *ci = req->context;\r\nunsigned long flags;\r\nif (ci->setaddr) {\r\nhw_usb_set_address(ci, ci->address);\r\nci->setaddr = false;\r\nif (ci->address)\r\nusb_gadget_set_state(&ci->gadget, USB_STATE_ADDRESS);\r\n}\r\nspin_lock_irqsave(&ci->lock, flags);\r\nif (ci->test_mode)\r\nhw_port_test_set(ci, ci->test_mode);\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\n}\r\nstatic int isr_setup_status_phase(struct ci_hdrc *ci)\r\n{\r\nint retval;\r\nstruct ci_hw_ep *hwep;\r\nhwep = (ci->ep0_dir == TX) ? ci->ep0out : ci->ep0in;\r\nci->status->context = ci;\r\nci->status->complete = isr_setup_status_complete;\r\nretval = _ep_queue(&hwep->ep, ci->status, GFP_ATOMIC);\r\nreturn retval;\r\n}\r\nstatic int isr_tr_complete_low(struct ci_hw_ep *hwep)\r\n__releases(hwep->lock)\r\n__acquires(hwep->lock)\r\n{\r\nstruct ci_hw_req *hwreq, *hwreqtemp;\r\nstruct ci_hw_ep *hweptemp = hwep;\r\nint retval = 0;\r\nlist_for_each_entry_safe(hwreq, hwreqtemp, &hwep->qh.queue,\r\nqueue) {\r\nretval = _hardware_dequeue(hwep, hwreq);\r\nif (retval < 0)\r\nbreak;\r\nlist_del_init(&hwreq->queue);\r\nif (hwreq->req.complete != NULL) {\r\nspin_unlock(hwep->lock);\r\nif ((hwep->type == USB_ENDPOINT_XFER_CONTROL) &&\r\nhwreq->req.length)\r\nhweptemp = hwep->ci->ep0in;\r\nusb_gadget_giveback_request(&hweptemp->ep, &hwreq->req);\r\nspin_lock(hwep->lock);\r\n}\r\n}\r\nif (retval == -EBUSY)\r\nretval = 0;\r\nreturn retval;\r\n}\r\nstatic int otg_a_alt_hnp_support(struct ci_hdrc *ci)\r\n{\r\ndev_warn(&ci->gadget.dev,\r\n"connect the device to an alternate port if you want HNP\n");\r\nreturn isr_setup_status_phase(ci);\r\n}\r\nstatic void isr_setup_packet_handler(struct ci_hdrc *ci)\r\n__releases(ci->lock)\r\n__acquires(ci->lock)\r\n{\r\nstruct ci_hw_ep *hwep = &ci->ci_hw_ep[0];\r\nstruct usb_ctrlrequest req;\r\nint type, num, dir, err = -EINVAL;\r\nu8 tmode = 0;\r\n_ep_nuke(ci->ep0out);\r\n_ep_nuke(ci->ep0in);\r\ndo {\r\nhw_test_and_set_setup_guard(ci);\r\nmemcpy(&req, &hwep->qh.ptr->setup, sizeof(req));\r\n} while (!hw_test_and_clear_setup_guard(ci));\r\ntype = req.bRequestType;\r\nci->ep0_dir = (type & USB_DIR_IN) ? TX : RX;\r\nswitch (req.bRequest) {\r\ncase USB_REQ_CLEAR_FEATURE:\r\nif (type == (USB_DIR_OUT|USB_RECIP_ENDPOINT) &&\r\nle16_to_cpu(req.wValue) ==\r\nUSB_ENDPOINT_HALT) {\r\nif (req.wLength != 0)\r\nbreak;\r\nnum = le16_to_cpu(req.wIndex);\r\ndir = num & USB_ENDPOINT_DIR_MASK;\r\nnum &= USB_ENDPOINT_NUMBER_MASK;\r\nif (dir)\r\nnum += ci->hw_ep_max / 2;\r\nif (!ci->ci_hw_ep[num].wedge) {\r\nspin_unlock(&ci->lock);\r\nerr = usb_ep_clear_halt(\r\n&ci->ci_hw_ep[num].ep);\r\nspin_lock(&ci->lock);\r\nif (err)\r\nbreak;\r\n}\r\nerr = isr_setup_status_phase(ci);\r\n} else if (type == (USB_DIR_OUT|USB_RECIP_DEVICE) &&\r\nle16_to_cpu(req.wValue) ==\r\nUSB_DEVICE_REMOTE_WAKEUP) {\r\nif (req.wLength != 0)\r\nbreak;\r\nci->remote_wakeup = 0;\r\nerr = isr_setup_status_phase(ci);\r\n} else {\r\ngoto delegate;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nif ((type != (USB_DIR_IN|USB_RECIP_DEVICE) ||\r\nle16_to_cpu(req.wIndex) == OTG_STS_SELECTOR) &&\r\ntype != (USB_DIR_IN|USB_RECIP_ENDPOINT) &&\r\ntype != (USB_DIR_IN|USB_RECIP_INTERFACE))\r\ngoto delegate;\r\nif (le16_to_cpu(req.wLength) != 2 ||\r\nle16_to_cpu(req.wValue) != 0)\r\nbreak;\r\nerr = isr_get_status_response(ci, &req);\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\nif (type != (USB_DIR_OUT|USB_RECIP_DEVICE))\r\ngoto delegate;\r\nif (le16_to_cpu(req.wLength) != 0 ||\r\nle16_to_cpu(req.wIndex) != 0)\r\nbreak;\r\nci->address = (u8)le16_to_cpu(req.wValue);\r\nci->setaddr = true;\r\nerr = isr_setup_status_phase(ci);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nif (type == (USB_DIR_OUT|USB_RECIP_ENDPOINT) &&\r\nle16_to_cpu(req.wValue) ==\r\nUSB_ENDPOINT_HALT) {\r\nif (req.wLength != 0)\r\nbreak;\r\nnum = le16_to_cpu(req.wIndex);\r\ndir = num & USB_ENDPOINT_DIR_MASK;\r\nnum &= USB_ENDPOINT_NUMBER_MASK;\r\nif (dir)\r\nnum += ci->hw_ep_max / 2;\r\nspin_unlock(&ci->lock);\r\nerr = _ep_set_halt(&ci->ci_hw_ep[num].ep, 1, false);\r\nspin_lock(&ci->lock);\r\nif (!err)\r\nisr_setup_status_phase(ci);\r\n} else if (type == (USB_DIR_OUT|USB_RECIP_DEVICE)) {\r\nif (req.wLength != 0)\r\nbreak;\r\nswitch (le16_to_cpu(req.wValue)) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nci->remote_wakeup = 1;\r\nerr = isr_setup_status_phase(ci);\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\ntmode = le16_to_cpu(req.wIndex) >> 8;\r\nswitch (tmode) {\r\ncase TEST_J:\r\ncase TEST_K:\r\ncase TEST_SE0_NAK:\r\ncase TEST_PACKET:\r\ncase TEST_FORCE_EN:\r\nci->test_mode = tmode;\r\nerr = isr_setup_status_phase(\r\nci);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_DEVICE_B_HNP_ENABLE:\r\nif (ci_otg_is_fsm_mode(ci)) {\r\nci->gadget.b_hnp_enable = 1;\r\nerr = isr_setup_status_phase(\r\nci);\r\n}\r\nbreak;\r\ncase USB_DEVICE_A_ALT_HNP_SUPPORT:\r\nif (ci_otg_is_fsm_mode(ci))\r\nerr = otg_a_alt_hnp_support(ci);\r\nbreak;\r\ncase USB_DEVICE_A_HNP_SUPPORT:\r\nif (ci_otg_is_fsm_mode(ci)) {\r\nci->gadget.a_hnp_support = 1;\r\nerr = isr_setup_status_phase(\r\nci);\r\n}\r\nbreak;\r\ndefault:\r\ngoto delegate;\r\n}\r\n} else {\r\ngoto delegate;\r\n}\r\nbreak;\r\ndefault:\r\ndelegate:\r\nif (req.wLength == 0)\r\nci->ep0_dir = TX;\r\nspin_unlock(&ci->lock);\r\nerr = ci->driver->setup(&ci->gadget, &req);\r\nspin_lock(&ci->lock);\r\nbreak;\r\n}\r\nif (err < 0) {\r\nspin_unlock(&ci->lock);\r\nif (_ep_set_halt(&hwep->ep, 1, false))\r\ndev_err(ci->dev, "error: _ep_set_halt\n");\r\nspin_lock(&ci->lock);\r\n}\r\n}\r\nstatic void isr_tr_complete_handler(struct ci_hdrc *ci)\r\n__releases(ci->lock)\r\n__acquires(ci->lock)\r\n{\r\nunsigned i;\r\nint err;\r\nfor (i = 0; i < ci->hw_ep_max; i++) {\r\nstruct ci_hw_ep *hwep = &ci->ci_hw_ep[i];\r\nif (hwep->ep.desc == NULL)\r\ncontinue;\r\nif (hw_test_and_clear_complete(ci, i)) {\r\nerr = isr_tr_complete_low(hwep);\r\nif (hwep->type == USB_ENDPOINT_XFER_CONTROL) {\r\nif (err > 0)\r\nerr = isr_setup_status_phase(ci);\r\nif (err < 0) {\r\nspin_unlock(&ci->lock);\r\nif (_ep_set_halt(&hwep->ep, 1, false))\r\ndev_err(ci->dev,\r\n"error: _ep_set_halt\n");\r\nspin_lock(&ci->lock);\r\n}\r\n}\r\n}\r\nif (i == 0 &&\r\nhw_test_and_clear(ci, OP_ENDPTSETUPSTAT, BIT(0)))\r\nisr_setup_packet_handler(ci);\r\n}\r\n}\r\nstatic int ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nint retval = 0;\r\nunsigned long flags;\r\nu32 cap = 0;\r\nif (ep == NULL || desc == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(hwep->lock, flags);\r\nif (!list_empty(&hwep->qh.queue)) {\r\ndev_warn(hwep->ci->dev, "enabling a non-empty endpoint!\n");\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nhwep->ep.desc = desc;\r\nhwep->dir = usb_endpoint_dir_in(desc) ? TX : RX;\r\nhwep->num = usb_endpoint_num(desc);\r\nhwep->type = usb_endpoint_type(desc);\r\nhwep->ep.maxpacket = usb_endpoint_maxp(desc) & 0x07ff;\r\nhwep->ep.mult = QH_ISO_MULT(usb_endpoint_maxp(desc));\r\nif (hwep->type == USB_ENDPOINT_XFER_CONTROL)\r\ncap |= QH_IOS;\r\ncap |= QH_ZLT;\r\ncap |= (hwep->ep.maxpacket << __ffs(QH_MAX_PKT)) & QH_MAX_PKT;\r\nif (hwep->type == USB_ENDPOINT_XFER_ISOC && hwep->dir == TX)\r\ncap |= 3 << __ffs(QH_MULT);\r\nhwep->qh.ptr->cap = cpu_to_le32(cap);\r\nhwep->qh.ptr->td.next |= cpu_to_le32(TD_TERMINATE);\r\nif (hwep->num != 0 && hwep->type == USB_ENDPOINT_XFER_CONTROL) {\r\ndev_err(hwep->ci->dev, "Set control xfer at non-ep0\n");\r\nretval = -EINVAL;\r\n}\r\nif (hwep->num)\r\nretval |= hw_ep_enable(hwep->ci, hwep->num, hwep->dir,\r\nhwep->type);\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ep_disable(struct usb_ep *ep)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nint direction, retval = 0;\r\nunsigned long flags;\r\nif (ep == NULL)\r\nreturn -EINVAL;\r\nelse if (hwep->ep.desc == NULL)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(hwep->lock, flags);\r\ndirection = hwep->dir;\r\ndo {\r\nretval |= _ep_nuke(hwep);\r\nretval |= hw_ep_disable(hwep->ci, hwep->num, hwep->dir);\r\nif (hwep->type == USB_ENDPOINT_XFER_CONTROL)\r\nhwep->dir = (hwep->dir == TX) ? RX : TX;\r\n} while (hwep->dir != direction);\r\nhwep->ep.desc = NULL;\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn retval;\r\n}\r\nstatic struct usb_request *ep_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\r\n{\r\nstruct ci_hw_req *hwreq = NULL;\r\nif (ep == NULL)\r\nreturn NULL;\r\nhwreq = kzalloc(sizeof(struct ci_hw_req), gfp_flags);\r\nif (hwreq != NULL) {\r\nINIT_LIST_HEAD(&hwreq->queue);\r\nINIT_LIST_HEAD(&hwreq->tds);\r\n}\r\nreturn (hwreq == NULL) ? NULL : &hwreq->req;\r\n}\r\nstatic void ep_free_request(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nstruct ci_hw_req *hwreq = container_of(req, struct ci_hw_req, req);\r\nstruct td_node *node, *tmpnode;\r\nunsigned long flags;\r\nif (ep == NULL || req == NULL) {\r\nreturn;\r\n} else if (!list_empty(&hwreq->queue)) {\r\ndev_err(hwep->ci->dev, "freeing queued request\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(hwep->lock, flags);\r\nlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\r\ndma_pool_free(hwep->td_pool, node->ptr, node->dma);\r\nlist_del_init(&node->td);\r\nnode->ptr = NULL;\r\nkfree(node);\r\n}\r\nkfree(hwreq);\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\n}\r\nstatic int ep_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t __maybe_unused gfp_flags)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nint retval = 0;\r\nunsigned long flags;\r\nif (ep == NULL || req == NULL || hwep->ep.desc == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(hwep->lock, flags);\r\nretval = _ep_queue(ep, req, gfp_flags);\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ep_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nstruct ci_hw_req *hwreq = container_of(req, struct ci_hw_req, req);\r\nunsigned long flags;\r\nstruct td_node *node, *tmpnode;\r\nif (ep == NULL || req == NULL || hwreq->req.status != -EALREADY ||\r\nhwep->ep.desc == NULL || list_empty(&hwreq->queue) ||\r\nlist_empty(&hwep->qh.queue))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(hwep->lock, flags);\r\nhw_ep_flush(hwep->ci, hwep->num, hwep->dir);\r\nlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\r\ndma_pool_free(hwep->td_pool, node->ptr, node->dma);\r\nlist_del(&node->td);\r\nkfree(node);\r\n}\r\nlist_del_init(&hwreq->queue);\r\nusb_gadget_unmap_request(&hwep->ci->gadget, req, hwep->dir);\r\nreq->status = -ECONNRESET;\r\nif (hwreq->req.complete != NULL) {\r\nspin_unlock(hwep->lock);\r\nusb_gadget_giveback_request(&hwep->ep, &hwreq->req);\r\nspin_lock(hwep->lock);\r\n}\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ep_set_halt(struct usb_ep *ep, int value)\r\n{\r\nreturn _ep_set_halt(ep, value, true);\r\n}\r\nstatic int ep_set_wedge(struct usb_ep *ep)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nunsigned long flags;\r\nif (ep == NULL || hwep->ep.desc == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(hwep->lock, flags);\r\nhwep->wedge = 1;\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn usb_ep_set_halt(ep);\r\n}\r\nstatic void ep_fifo_flush(struct usb_ep *ep)\r\n{\r\nstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\r\nunsigned long flags;\r\nif (ep == NULL) {\r\ndev_err(hwep->ci->dev, "%02X: -EINVAL\n", _usb_addr(hwep));\r\nreturn;\r\n}\r\nspin_lock_irqsave(hwep->lock, flags);\r\nhw_ep_flush(hwep->ci, hwep->num, hwep->dir);\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\n}\r\nstatic int ci_udc_vbus_session(struct usb_gadget *_gadget, int is_active)\r\n{\r\nstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\r\nunsigned long flags;\r\nint gadget_ready = 0;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nci->vbus_active = is_active;\r\nif (ci->driver)\r\ngadget_ready = 1;\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nif (gadget_ready) {\r\nif (is_active) {\r\npm_runtime_get_sync(&_gadget->dev);\r\nhw_device_reset(ci);\r\nhw_device_state(ci, ci->ep0out->qh.dma);\r\nusb_gadget_set_state(_gadget, USB_STATE_POWERED);\r\nusb_udc_vbus_handler(_gadget, true);\r\n} else {\r\nusb_udc_vbus_handler(_gadget, false);\r\nif (ci->driver)\r\nci->driver->disconnect(&ci->gadget);\r\nhw_device_state(ci, 0);\r\nif (ci->platdata->notify_event)\r\nci->platdata->notify_event(ci,\r\nCI_HDRC_CONTROLLER_STOPPED_EVENT);\r\n_gadget_stop_activity(&ci->gadget);\r\npm_runtime_put_sync(&_gadget->dev);\r\nusb_gadget_set_state(_gadget, USB_STATE_NOTATTACHED);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_udc_wakeup(struct usb_gadget *_gadget)\r\n{\r\nstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nif (!ci->remote_wakeup) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (!hw_read(ci, OP_PORTSC, PORTSC_SUSP)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nhw_write(ci, OP_PORTSC, PORTSC_FPR, PORTSC_FPR);\r\nout:\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ci_udc_vbus_draw(struct usb_gadget *_gadget, unsigned ma)\r\n{\r\nstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\r\nif (ci->usb_phy)\r\nreturn usb_phy_set_power(ci->usb_phy, ma);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int ci_udc_selfpowered(struct usb_gadget *_gadget, int is_on)\r\n{\r\nstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\r\nstruct ci_hw_ep *hwep = ci->ep0in;\r\nunsigned long flags;\r\nspin_lock_irqsave(hwep->lock, flags);\r\n_gadget->is_selfpowered = (is_on != 0);\r\nspin_unlock_irqrestore(hwep->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ci_udc_pullup(struct usb_gadget *_gadget, int is_on)\r\n{\r\nstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\r\nif (ci_otg_is_fsm_mode(ci))\r\nreturn 0;\r\npm_runtime_get_sync(&ci->gadget.dev);\r\nif (is_on)\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);\r\nelse\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, 0);\r\npm_runtime_put_sync(&ci->gadget.dev);\r\nreturn 0;\r\n}\r\nstatic int init_eps(struct ci_hdrc *ci)\r\n{\r\nint retval = 0, i, j;\r\nfor (i = 0; i < ci->hw_ep_max/2; i++)\r\nfor (j = RX; j <= TX; j++) {\r\nint k = i + j * ci->hw_ep_max/2;\r\nstruct ci_hw_ep *hwep = &ci->ci_hw_ep[k];\r\nscnprintf(hwep->name, sizeof(hwep->name), "ep%i%s", i,\r\n(j == TX) ? "in" : "out");\r\nhwep->ci = ci;\r\nhwep->lock = &ci->lock;\r\nhwep->td_pool = ci->td_pool;\r\nhwep->ep.name = hwep->name;\r\nhwep->ep.ops = &usb_ep_ops;\r\nif (i == 0) {\r\nhwep->ep.caps.type_control = true;\r\n} else {\r\nhwep->ep.caps.type_iso = true;\r\nhwep->ep.caps.type_bulk = true;\r\nhwep->ep.caps.type_int = true;\r\n}\r\nif (j == TX)\r\nhwep->ep.caps.dir_in = true;\r\nelse\r\nhwep->ep.caps.dir_out = true;\r\nusb_ep_set_maxpacket_limit(&hwep->ep, (unsigned short)~0);\r\nINIT_LIST_HEAD(&hwep->qh.queue);\r\nhwep->qh.ptr = dma_pool_alloc(ci->qh_pool, GFP_KERNEL,\r\n&hwep->qh.dma);\r\nif (hwep->qh.ptr == NULL)\r\nretval = -ENOMEM;\r\nelse\r\nmemset(hwep->qh.ptr, 0, sizeof(*hwep->qh.ptr));\r\nif (i == 0) {\r\nif (j == RX)\r\nci->ep0out = hwep;\r\nelse\r\nci->ep0in = hwep;\r\nusb_ep_set_maxpacket_limit(&hwep->ep, CTRL_PAYLOAD_MAX);\r\ncontinue;\r\n}\r\nlist_add_tail(&hwep->ep.ep_list, &ci->gadget.ep_list);\r\n}\r\nreturn retval;\r\n}\r\nstatic void destroy_eps(struct ci_hdrc *ci)\r\n{\r\nint i;\r\nfor (i = 0; i < ci->hw_ep_max; i++) {\r\nstruct ci_hw_ep *hwep = &ci->ci_hw_ep[i];\r\nif (hwep->pending_td)\r\nfree_pending_td(hwep);\r\ndma_pool_free(ci->qh_pool, hwep->qh.ptr, hwep->qh.dma);\r\n}\r\n}\r\nstatic int ci_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct ci_hdrc *ci = container_of(gadget, struct ci_hdrc, gadget);\r\nunsigned long flags;\r\nint retval = -ENOMEM;\r\nif (driver->disconnect == NULL)\r\nreturn -EINVAL;\r\nci->ep0out->ep.desc = &ctrl_endpt_out_desc;\r\nretval = usb_ep_enable(&ci->ep0out->ep);\r\nif (retval)\r\nreturn retval;\r\nci->ep0in->ep.desc = &ctrl_endpt_in_desc;\r\nretval = usb_ep_enable(&ci->ep0in->ep);\r\nif (retval)\r\nreturn retval;\r\nci->driver = driver;\r\nif (ci_otg_is_fsm_mode(ci) && ci->fsm.id) {\r\nci_hdrc_otg_fsm_start(ci);\r\nreturn retval;\r\n}\r\npm_runtime_get_sync(&ci->gadget.dev);\r\nif (ci->vbus_active) {\r\nspin_lock_irqsave(&ci->lock, flags);\r\nhw_device_reset(ci);\r\n} else {\r\nusb_udc_vbus_handler(&ci->gadget, false);\r\npm_runtime_put_sync(&ci->gadget.dev);\r\nreturn retval;\r\n}\r\nretval = hw_device_state(ci, ci->ep0out->qh.dma);\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nif (retval)\r\npm_runtime_put_sync(&ci->gadget.dev);\r\nreturn retval;\r\n}\r\nstatic void ci_udc_stop_for_otg_fsm(struct ci_hdrc *ci)\r\n{\r\nif (!ci_otg_is_fsm_mode(ci))\r\nreturn;\r\nmutex_lock(&ci->fsm.lock);\r\nif (ci->fsm.otg->state == OTG_STATE_A_PERIPHERAL) {\r\nci->fsm.a_bidl_adis_tmout = 1;\r\nci_hdrc_otg_fsm_start(ci);\r\n} else if (ci->fsm.otg->state == OTG_STATE_B_PERIPHERAL) {\r\nci->fsm.protocol = PROTO_UNDEF;\r\nci->fsm.otg->state = OTG_STATE_UNDEFINED;\r\n}\r\nmutex_unlock(&ci->fsm.lock);\r\n}\r\nstatic int ci_udc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct ci_hdrc *ci = container_of(gadget, struct ci_hdrc, gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nif (ci->vbus_active) {\r\nhw_device_state(ci, 0);\r\nif (ci->platdata->notify_event)\r\nci->platdata->notify_event(ci,\r\nCI_HDRC_CONTROLLER_STOPPED_EVENT);\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\n_gadget_stop_activity(&ci->gadget);\r\nspin_lock_irqsave(&ci->lock, flags);\r\npm_runtime_put(&ci->gadget.dev);\r\n}\r\nci->driver = NULL;\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nci_udc_stop_for_otg_fsm(ci);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t udc_irq(struct ci_hdrc *ci)\r\n{\r\nirqreturn_t retval;\r\nu32 intr;\r\nif (ci == NULL)\r\nreturn IRQ_HANDLED;\r\nspin_lock(&ci->lock);\r\nif (ci->platdata->flags & CI_HDRC_REGS_SHARED) {\r\nif (hw_read(ci, OP_USBMODE, USBMODE_CM) !=\r\nUSBMODE_CM_DC) {\r\nspin_unlock(&ci->lock);\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nintr = hw_test_and_clear_intr_active(ci);\r\nif (intr) {\r\nif (USBi_URI & intr)\r\nisr_reset_handler(ci);\r\nif (USBi_PCI & intr) {\r\nci->gadget.speed = hw_port_is_high_speed(ci) ?\r\nUSB_SPEED_HIGH : USB_SPEED_FULL;\r\nif (ci->suspended && ci->driver->resume) {\r\nspin_unlock(&ci->lock);\r\nci->driver->resume(&ci->gadget);\r\nspin_lock(&ci->lock);\r\nci->suspended = 0;\r\n}\r\n}\r\nif (USBi_UI & intr)\r\nisr_tr_complete_handler(ci);\r\nif (USBi_SLI & intr) {\r\nif (ci->gadget.speed != USB_SPEED_UNKNOWN &&\r\nci->driver->suspend) {\r\nci->suspended = 1;\r\nspin_unlock(&ci->lock);\r\nci->driver->suspend(&ci->gadget);\r\nusb_gadget_set_state(&ci->gadget,\r\nUSB_STATE_SUSPENDED);\r\nspin_lock(&ci->lock);\r\n}\r\n}\r\nretval = IRQ_HANDLED;\r\n} else {\r\nretval = IRQ_NONE;\r\n}\r\nspin_unlock(&ci->lock);\r\nreturn retval;\r\n}\r\nstatic int udc_start(struct ci_hdrc *ci)\r\n{\r\nstruct device *dev = ci->dev;\r\nstruct usb_otg_caps *otg_caps = &ci->platdata->ci_otg_caps;\r\nint retval = 0;\r\nspin_lock_init(&ci->lock);\r\nci->gadget.ops = &usb_gadget_ops;\r\nci->gadget.speed = USB_SPEED_UNKNOWN;\r\nci->gadget.max_speed = USB_SPEED_HIGH;\r\nci->gadget.name = ci->platdata->name;\r\nci->gadget.otg_caps = otg_caps;\r\nif (ci->is_otg && (otg_caps->hnp_support || otg_caps->srp_support ||\r\notg_caps->adp_support))\r\nci->gadget.is_otg = 1;\r\nINIT_LIST_HEAD(&ci->gadget.ep_list);\r\nci->qh_pool = dma_pool_create("ci_hw_qh", dev,\r\nsizeof(struct ci_hw_qh),\r\n64, CI_HDRC_PAGE_SIZE);\r\nif (ci->qh_pool == NULL)\r\nreturn -ENOMEM;\r\nci->td_pool = dma_pool_create("ci_hw_td", dev,\r\nsizeof(struct ci_hw_td),\r\n64, CI_HDRC_PAGE_SIZE);\r\nif (ci->td_pool == NULL) {\r\nretval = -ENOMEM;\r\ngoto free_qh_pool;\r\n}\r\nretval = init_eps(ci);\r\nif (retval)\r\ngoto free_pools;\r\nci->gadget.ep0 = &ci->ep0in->ep;\r\nretval = usb_add_gadget_udc(dev, &ci->gadget);\r\nif (retval)\r\ngoto destroy_eps;\r\npm_runtime_no_callbacks(&ci->gadget.dev);\r\npm_runtime_enable(&ci->gadget.dev);\r\nreturn retval;\r\ndestroy_eps:\r\ndestroy_eps(ci);\r\nfree_pools:\r\ndma_pool_destroy(ci->td_pool);\r\nfree_qh_pool:\r\ndma_pool_destroy(ci->qh_pool);\r\nreturn retval;\r\n}\r\nvoid ci_hdrc_gadget_destroy(struct ci_hdrc *ci)\r\n{\r\nif (!ci->roles[CI_ROLE_GADGET])\r\nreturn;\r\nusb_del_gadget_udc(&ci->gadget);\r\ndestroy_eps(ci);\r\ndma_pool_destroy(ci->td_pool);\r\ndma_pool_destroy(ci->qh_pool);\r\n}\r\nstatic int udc_id_switch_for_device(struct ci_hdrc *ci)\r\n{\r\nif (ci->is_otg)\r\nhw_write_otgsc(ci, OTGSC_BSVIS | OTGSC_BSVIE,\r\nOTGSC_BSVIS | OTGSC_BSVIE);\r\nreturn 0;\r\n}\r\nstatic void udc_id_switch_for_host(struct ci_hdrc *ci)\r\n{\r\nif (ci->is_otg)\r\nhw_write_otgsc(ci, OTGSC_BSVIE | OTGSC_BSVIS, OTGSC_BSVIS);\r\n}\r\nint ci_hdrc_gadget_init(struct ci_hdrc *ci)\r\n{\r\nstruct ci_role_driver *rdrv;\r\nif (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_DC))\r\nreturn -ENXIO;\r\nrdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);\r\nif (!rdrv)\r\nreturn -ENOMEM;\r\nrdrv->start = udc_id_switch_for_device;\r\nrdrv->stop = udc_id_switch_for_host;\r\nrdrv->irq = udc_irq;\r\nrdrv->name = "gadget";\r\nci->roles[CI_ROLE_GADGET] = rdrv;\r\nreturn udc_start(ci);\r\n}
