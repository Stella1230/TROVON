static int drv260x_calculate_voltage(unsigned int voltage)\r\n{\r\nreturn (voltage * 255 / 5600);\r\n}\r\nstatic void drv260x_worker(struct work_struct *work)\r\n{\r\nstruct drv260x_data *haptics = container_of(work, struct drv260x_data, work);\r\nint error;\r\ngpiod_set_value(haptics->enable_gpio, 1);\r\nudelay(250);\r\nerror = regmap_write(haptics->regmap,\r\nDRV260X_MODE, DRV260X_RT_PLAYBACK);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write set mode: %d\n", error);\r\n} else {\r\nerror = regmap_write(haptics->regmap,\r\nDRV260X_RT_PB_IN, haptics->magnitude);\r\nif (error)\r\ndev_err(&haptics->client->dev,\r\n"Failed to set magnitude: %d\n", error);\r\n}\r\n}\r\nstatic int drv260x_haptics_play(struct input_dev *input, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct drv260x_data *haptics = input_get_drvdata(input);\r\nhaptics->mode = DRV260X_LRA_NO_CAL_MODE;\r\nif (effect->u.rumble.strong_magnitude > 0)\r\nhaptics->magnitude = effect->u.rumble.strong_magnitude;\r\nelse if (effect->u.rumble.weak_magnitude > 0)\r\nhaptics->magnitude = effect->u.rumble.weak_magnitude;\r\nelse\r\nhaptics->magnitude = 0;\r\nschedule_work(&haptics->work);\r\nreturn 0;\r\n}\r\nstatic void drv260x_close(struct input_dev *input)\r\n{\r\nstruct drv260x_data *haptics = input_get_drvdata(input);\r\nint error;\r\ncancel_work_sync(&haptics->work);\r\nerror = regmap_write(haptics->regmap, DRV260X_MODE, DRV260X_STANDBY);\r\nif (error)\r\ndev_err(&haptics->client->dev,\r\n"Failed to enter standby mode: %d\n", error);\r\ngpiod_set_value(haptics->enable_gpio, 0);\r\n}\r\nstatic int drv260x_init(struct drv260x_data *haptics)\r\n{\r\nint error;\r\nunsigned int cal_buf;\r\nerror = regmap_write(haptics->regmap,\r\nDRV260X_RATED_VOLT, haptics->rated_voltage);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write DRV260X_RATED_VOLT register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = regmap_write(haptics->regmap,\r\nDRV260X_OD_CLAMP_VOLT, haptics->overdrive_voltage);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write DRV260X_OD_CLAMP_VOLT register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nswitch (haptics->mode) {\r\ncase DRV260X_LRA_MODE:\r\nerror = regmap_register_patch(haptics->regmap,\r\ndrv260x_lra_cal_regs,\r\nARRAY_SIZE(drv260x_lra_cal_regs));\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write LRA calibration registers: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nbreak;\r\ncase DRV260X_ERM_MODE:\r\nerror = regmap_register_patch(haptics->regmap,\r\ndrv260x_erm_cal_regs,\r\nARRAY_SIZE(drv260x_erm_cal_regs));\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write ERM calibration registers: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = regmap_update_bits(haptics->regmap, DRV260X_LIB_SEL,\r\nDRV260X_LIB_SEL_MASK,\r\nhaptics->library);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write DRV260X_LIB_SEL register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nbreak;\r\ndefault:\r\nerror = regmap_register_patch(haptics->regmap,\r\ndrv260x_lra_init_regs,\r\nARRAY_SIZE(drv260x_lra_init_regs));\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write LRA init registers: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = regmap_update_bits(haptics->regmap, DRV260X_LIB_SEL,\r\nDRV260X_LIB_SEL_MASK,\r\nhaptics->library);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write DRV260X_LIB_SEL register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nerror = regmap_write(haptics->regmap, DRV260X_GO, DRV260X_GO_BIT);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write GO register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\ndo {\r\nerror = regmap_read(haptics->regmap, DRV260X_GO, &cal_buf);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to read GO register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n} while (cal_buf == DRV260X_GO_BIT);\r\nreturn 0;\r\n}\r\nstatic int drv260x_parse_dt(struct device *dev,\r\nstruct drv260x_data *haptics)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nunsigned int voltage;\r\nint error;\r\nerror = of_property_read_u32(np, "mode", &haptics->mode);\r\nif (error) {\r\ndev_err(dev, "%s: No entry for mode\n", __func__);\r\nreturn error;\r\n}\r\nerror = of_property_read_u32(np, "library-sel", &haptics->library);\r\nif (error) {\r\ndev_err(dev, "%s: No entry for library selection\n",\r\n__func__);\r\nreturn error;\r\n}\r\nerror = of_property_read_u32(np, "vib-rated-mv", &voltage);\r\nif (!error)\r\nhaptics->rated_voltage = drv260x_calculate_voltage(voltage);\r\nerror = of_property_read_u32(np, "vib-overdrive-mv", &voltage);\r\nif (!error)\r\nhaptics->overdrive_voltage = drv260x_calculate_voltage(voltage);\r\nreturn 0;\r\n}\r\nstatic inline int drv260x_parse_dt(struct device *dev,\r\nstruct drv260x_data *haptics)\r\n{\r\ndev_err(dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int drv260x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct drv260x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct drv260x_data *haptics;\r\nint error;\r\nhaptics = devm_kzalloc(&client->dev, sizeof(*haptics), GFP_KERNEL);\r\nif (!haptics)\r\nreturn -ENOMEM;\r\nhaptics->rated_voltage = DRV260X_DEF_OD_CLAMP_VOLT;\r\nhaptics->rated_voltage = DRV260X_DEF_RATED_VOLT;\r\nif (pdata) {\r\nhaptics->mode = pdata->mode;\r\nhaptics->library = pdata->library_selection;\r\nif (pdata->vib_overdrive_voltage)\r\nhaptics->overdrive_voltage = drv260x_calculate_voltage(pdata->vib_overdrive_voltage);\r\nif (pdata->vib_rated_voltage)\r\nhaptics->rated_voltage = drv260x_calculate_voltage(pdata->vib_rated_voltage);\r\n} else if (client->dev.of_node) {\r\nerror = drv260x_parse_dt(&client->dev, haptics);\r\nif (error)\r\nreturn error;\r\n} else {\r\ndev_err(&client->dev, "Platform data not set\n");\r\nreturn -ENODEV;\r\n}\r\nif (haptics->mode < DRV260X_LRA_MODE ||\r\nhaptics->mode > DRV260X_ERM_MODE) {\r\ndev_err(&client->dev,\r\n"Vibrator mode is invalid: %i\n",\r\nhaptics->mode);\r\nreturn -EINVAL;\r\n}\r\nif (haptics->library < DRV260X_LIB_EMPTY ||\r\nhaptics->library > DRV260X_ERM_LIB_F) {\r\ndev_err(&client->dev,\r\n"Library value is invalid: %i\n", haptics->library);\r\nreturn -EINVAL;\r\n}\r\nif (haptics->mode == DRV260X_LRA_MODE &&\r\nhaptics->library != DRV260X_LIB_EMPTY &&\r\nhaptics->library != DRV260X_LIB_LRA) {\r\ndev_err(&client->dev,\r\n"LRA Mode with ERM Library mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nif (haptics->mode == DRV260X_ERM_MODE &&\r\n(haptics->library == DRV260X_LIB_EMPTY ||\r\nhaptics->library == DRV260X_LIB_LRA)) {\r\ndev_err(&client->dev,\r\n"ERM Mode with LRA Library mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nhaptics->regulator = devm_regulator_get(&client->dev, "vbat");\r\nif (IS_ERR(haptics->regulator)) {\r\nerror = PTR_ERR(haptics->regulator);\r\ndev_err(&client->dev,\r\n"unable to get regulator, error: %d\n", error);\r\nreturn error;\r\n}\r\nhaptics->enable_gpio = devm_gpiod_get_optional(&client->dev, "enable",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(haptics->enable_gpio))\r\nreturn PTR_ERR(haptics->enable_gpio);\r\nhaptics->input_dev = devm_input_allocate_device(&client->dev);\r\nif (!haptics->input_dev) {\r\ndev_err(&client->dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nhaptics->input_dev->name = "drv260x:haptics";\r\nhaptics->input_dev->dev.parent = client->dev.parent;\r\nhaptics->input_dev->close = drv260x_close;\r\ninput_set_drvdata(haptics->input_dev, haptics);\r\ninput_set_capability(haptics->input_dev, EV_FF, FF_RUMBLE);\r\nerror = input_ff_create_memless(haptics->input_dev, NULL,\r\ndrv260x_haptics_play);\r\nif (error) {\r\ndev_err(&client->dev, "input_ff_create() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nINIT_WORK(&haptics->work, drv260x_worker);\r\nhaptics->client = client;\r\ni2c_set_clientdata(client, haptics);\r\nhaptics->regmap = devm_regmap_init_i2c(client, &drv260x_regmap_config);\r\nif (IS_ERR(haptics->regmap)) {\r\nerror = PTR_ERR(haptics->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = drv260x_init(haptics);\r\nif (error) {\r\ndev_err(&client->dev, "Device init failed: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(haptics->input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "couldn't register input device: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused drv260x_suspend(struct device *dev)\r\n{\r\nstruct drv260x_data *haptics = dev_get_drvdata(dev);\r\nint ret = 0;\r\nmutex_lock(&haptics->input_dev->mutex);\r\nif (haptics->input_dev->users) {\r\nret = regmap_update_bits(haptics->regmap,\r\nDRV260X_MODE,\r\nDRV260X_STANDBY_MASK,\r\nDRV260X_STANDBY);\r\nif (ret) {\r\ndev_err(dev, "Failed to set standby mode\n");\r\ngoto out;\r\n}\r\ngpiod_set_value(haptics->enable_gpio, 0);\r\nret = regulator_disable(haptics->regulator);\r\nif (ret) {\r\ndev_err(dev, "Failed to disable regulator\n");\r\nregmap_update_bits(haptics->regmap,\r\nDRV260X_MODE,\r\nDRV260X_STANDBY_MASK, 0);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&haptics->input_dev->mutex);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused drv260x_resume(struct device *dev)\r\n{\r\nstruct drv260x_data *haptics = dev_get_drvdata(dev);\r\nint ret = 0;\r\nmutex_lock(&haptics->input_dev->mutex);\r\nif (haptics->input_dev->users) {\r\nret = regulator_enable(haptics->regulator);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator\n");\r\ngoto out;\r\n}\r\nret = regmap_update_bits(haptics->regmap,\r\nDRV260X_MODE,\r\nDRV260X_STANDBY_MASK, 0);\r\nif (ret) {\r\ndev_err(dev, "Failed to unset standby mode\n");\r\nregulator_disable(haptics->regulator);\r\ngoto out;\r\n}\r\ngpiod_set_value(haptics->enable_gpio, 1);\r\n}\r\nout:\r\nmutex_unlock(&haptics->input_dev->mutex);\r\nreturn ret;\r\n}
