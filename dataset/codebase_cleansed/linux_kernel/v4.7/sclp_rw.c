static void sclp_rw_pm_event(struct sclp_register *reg,\r\nenum sclp_pm_event sclp_pm_event)\r\n{\r\nsclp_console_pm_event(sclp_pm_event);\r\n}\r\nstruct sclp_buffer *\r\nsclp_make_buffer(void *page, unsigned short columns, unsigned short htab)\r\n{\r\nstruct sclp_buffer *buffer;\r\nstruct sccb_header *sccb;\r\nsccb = (struct sccb_header *) page;\r\nbuffer = ((struct sclp_buffer *) ((addr_t) sccb + PAGE_SIZE)) - 1;\r\nbuffer->sccb = sccb;\r\nbuffer->retry_count = 0;\r\nbuffer->messages = 0;\r\nbuffer->char_sum = 0;\r\nbuffer->current_line = NULL;\r\nbuffer->current_length = 0;\r\nbuffer->columns = columns;\r\nbuffer->htab = htab;\r\nmemset(sccb, 0, sizeof(struct sccb_header));\r\nsccb->length = sizeof(struct sccb_header);\r\nreturn buffer;\r\n}\r\nvoid *\r\nsclp_unmake_buffer(struct sclp_buffer *buffer)\r\n{\r\nreturn buffer->sccb;\r\n}\r\nstatic int\r\nsclp_initialize_mto(struct sclp_buffer *buffer, int max_len)\r\n{\r\nstruct sccb_header *sccb;\r\nstruct msg_buf *msg;\r\nstruct mdb *mdb;\r\nstruct go *go;\r\nstruct mto *mto;\r\nint msg_size;\r\nmsg_size = sizeof(struct msg_buf) + max_len;\r\nsccb = buffer->sccb;\r\nif ((MAX_SCCB_ROOM - sccb->length) < msg_size)\r\nreturn -ENOMEM;\r\nmsg = (struct msg_buf *)((addr_t) sccb + sccb->length);\r\nmemset(msg, 0, sizeof(struct msg_buf));\r\nmsg->header.length = sizeof(struct msg_buf);\r\nmsg->header.type = EVTYP_MSG;\r\nmdb = &msg->mdb;\r\nmdb->header.length = sizeof(struct mdb);\r\nmdb->header.type = 1;\r\nmdb->header.tag = 0xD4C4C240;\r\nmdb->header.revision_code = 1;\r\ngo = &mdb->go;\r\ngo->length = sizeof(struct go);\r\ngo->type = 1;\r\nmto = &mdb->mto;\r\nmto->length = sizeof(struct mto);\r\nmto->type = 4;\r\nmto->line_type_flags = LNTPFLGS_ENDTEXT;\r\nbuffer->current_msg = msg;\r\nbuffer->current_line = (char *) (mto + 1);\r\nbuffer->current_length = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nsclp_finalize_mto(struct sclp_buffer *buffer)\r\n{\r\nstruct sccb_header *sccb;\r\nstruct msg_buf *msg;\r\nsccb = buffer->sccb;\r\nmsg = buffer->current_msg;\r\nmsg->header.length += buffer->current_length;\r\nmsg->mdb.header.length += buffer->current_length;\r\nmsg->mdb.mto.length += buffer->current_length;\r\nsccb->length += msg->header.length;\r\nbuffer->messages++;\r\nbuffer->char_sum += buffer->current_length;\r\nbuffer->current_line = NULL;\r\nbuffer->current_length = 0;\r\nbuffer->current_msg = NULL;\r\n}\r\nint\r\nsclp_write(struct sclp_buffer *buffer, const unsigned char *msg, int count)\r\n{\r\nint spaces, i_msg;\r\nint rc;\r\nfor (i_msg = 0; i_msg < count; i_msg++) {\r\nswitch (msg[i_msg]) {\r\ncase '\n':\r\nif (buffer->current_line == NULL) {\r\nrc = sclp_initialize_mto(buffer, 0);\r\nif (rc)\r\nreturn i_msg;\r\n}\r\nsclp_finalize_mto(buffer);\r\nbreak;\r\ncase '\a':\r\nif (buffer->current_line == NULL) {\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\n}\r\nbuffer->current_msg->mdb.go.general_msg_flags |=\r\nGNRLMSGFLGS_SNDALRM;\r\nbreak;\r\ncase '\t':\r\nif (buffer->current_line == NULL) {\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\n}\r\ndo {\r\nif (buffer->current_length >= buffer->columns)\r\nbreak;\r\n*buffer->current_line++ = 0x40;\r\nbuffer->current_length++;\r\n} while (buffer->current_length % buffer->htab);\r\nbreak;\r\ncase '\f':\r\ncase '\v':\r\nif (buffer->current_line != NULL) {\r\nspaces = buffer->current_length;\r\nsclp_finalize_mto(buffer);\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\nmemset(buffer->current_line, 0x40, spaces);\r\nbuffer->current_line += spaces;\r\nbuffer->current_length = spaces;\r\n} else {\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\nsclp_finalize_mto(buffer);\r\n}\r\nbreak;\r\ncase '\b':\r\nif (buffer->current_line != NULL &&\r\nbuffer->current_length > 0) {\r\nbuffer->current_length--;\r\nbuffer->current_line--;\r\n}\r\nbreak;\r\ncase 0x00:\r\nif (buffer->current_line != NULL)\r\nsclp_finalize_mto(buffer);\r\ni_msg = count - 1;\r\nbreak;\r\ndefault:\r\nif (!isprint(msg[i_msg]))\r\nbreak;\r\nif (buffer->current_line == NULL) {\r\nrc = sclp_initialize_mto(buffer,\r\nbuffer->columns);\r\nif (rc)\r\nreturn i_msg;\r\n}\r\n*buffer->current_line++ = sclp_ascebc(msg[i_msg]);\r\nbuffer->current_length++;\r\nbreak;\r\n}\r\nif (buffer->current_line != NULL &&\r\nbuffer->current_length >= buffer->columns)\r\nsclp_finalize_mto(buffer);\r\n}\r\nreturn i_msg;\r\n}\r\nint\r\nsclp_buffer_space(struct sclp_buffer *buffer)\r\n{\r\nstruct sccb_header *sccb;\r\nint count;\r\nsccb = buffer->sccb;\r\ncount = MAX_SCCB_ROOM - sccb->length;\r\nif (buffer->current_line != NULL)\r\ncount -= sizeof(struct msg_buf) + buffer->current_length;\r\nreturn count;\r\n}\r\nint\r\nsclp_chars_in_buffer(struct sclp_buffer *buffer)\r\n{\r\nint count;\r\ncount = buffer->char_sum;\r\nif (buffer->current_line != NULL)\r\ncount += buffer->current_length;\r\nreturn count;\r\n}\r\nvoid\r\nsclp_set_columns(struct sclp_buffer *buffer, unsigned short columns)\r\n{\r\nbuffer->columns = columns;\r\nif (buffer->current_line != NULL &&\r\nbuffer->current_length > buffer->columns)\r\nsclp_finalize_mto(buffer);\r\n}\r\nvoid\r\nsclp_set_htab(struct sclp_buffer *buffer, unsigned short htab)\r\n{\r\nbuffer->htab = htab;\r\n}\r\nint\r\nsclp_rw_init(void)\r\n{\r\nstatic int init_done = 0;\r\nint rc;\r\nif (init_done)\r\nreturn 0;\r\nrc = sclp_register(&sclp_rw_event);\r\nif (rc == 0)\r\ninit_done = 1;\r\nreturn rc;\r\n}\r\nstatic void\r\nsclp_writedata_callback(struct sclp_req *request, void *data)\r\n{\r\nint rc;\r\nstruct sclp_buffer *buffer;\r\nstruct sccb_header *sccb;\r\nbuffer = (struct sclp_buffer *) data;\r\nsccb = buffer->sccb;\r\nif (request->status == SCLP_REQ_FAILED) {\r\nif (buffer->callback != NULL)\r\nbuffer->callback(buffer, -EIO);\r\nreturn;\r\n}\r\nswitch (sccb->response_code) {\r\ncase 0x0020 :\r\nrc = 0;\r\nbreak;\r\ncase 0x0340:\r\nif (++buffer->retry_count > SCLP_BUFFER_MAX_RETRY) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif (sclp_remove_processed((struct sccb_header *) sccb) > 0) {\r\nsccb->response_code = 0x0000;\r\nbuffer->request.status = SCLP_REQ_FILLED;\r\nrc = sclp_add_request(request);\r\nif (rc == 0)\r\nreturn;\r\n} else\r\nrc = 0;\r\nbreak;\r\ncase 0x0040:\r\ncase 0x05f0:\r\nif (++buffer->retry_count > SCLP_BUFFER_MAX_RETRY) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nsccb->response_code = 0x0000;\r\nbuffer->request.status = SCLP_REQ_FILLED;\r\nrc = sclp_add_request(request);\r\nif (rc == 0)\r\nreturn;\r\nbreak;\r\ndefault:\r\nif (sccb->response_code == 0x71f0)\r\nrc = -ENOMEM;\r\nelse\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (buffer->callback != NULL)\r\nbuffer->callback(buffer, rc);\r\n}\r\nint\r\nsclp_emit_buffer(struct sclp_buffer *buffer,\r\nvoid (*callback)(struct sclp_buffer *, int))\r\n{\r\nif (buffer->current_line != NULL)\r\nsclp_finalize_mto(buffer);\r\nif (buffer->messages == 0)\r\nreturn -EIO;\r\nbuffer->request.command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nbuffer->request.status = SCLP_REQ_FILLED;\r\nbuffer->request.callback = sclp_writedata_callback;\r\nbuffer->request.callback_data = buffer;\r\nbuffer->request.sccb = buffer->sccb;\r\nbuffer->callback = callback;\r\nreturn sclp_add_request(&buffer->request);\r\n}
