static int LM93_VID_FROM_REG(u8 reg)\r\n{\r\nreturn vid_from_reg((reg & 0x3f), 100);\r\n}\r\nstatic unsigned LM93_IN_FROM_REG(int nr, u8 reg)\r\n{\r\nconst long uv_max = lm93_vin_val_max[nr] * 1000;\r\nconst long uv_min = lm93_vin_val_min[nr] * 1000;\r\nconst long slope = (uv_max - uv_min) /\r\n(lm93_vin_reg_max[nr] - lm93_vin_reg_min[nr]);\r\nconst long intercept = uv_min - slope * lm93_vin_reg_min[nr];\r\nreturn (slope * reg + intercept + 500) / 1000;\r\n}\r\nstatic u8 LM93_IN_TO_REG(int nr, unsigned val)\r\n{\r\nconst long mv = clamp_val(val,\r\nlm93_vin_val_min[nr], lm93_vin_val_max[nr]);\r\nconst long uv = mv * 1000;\r\nconst long uv_max = lm93_vin_val_max[nr] * 1000;\r\nconst long uv_min = lm93_vin_val_min[nr] * 1000;\r\nconst long slope = (uv_max - uv_min) /\r\n(lm93_vin_reg_max[nr] - lm93_vin_reg_min[nr]);\r\nconst long intercept = uv_min - slope * lm93_vin_reg_min[nr];\r\nu8 result = ((uv - intercept + (slope/2)) / slope);\r\nresult = clamp_val(result,\r\nlm93_vin_reg_min[nr], lm93_vin_reg_max[nr]);\r\nreturn result;\r\n}\r\nstatic unsigned LM93_IN_REL_FROM_REG(u8 reg, int upper, int vid)\r\n{\r\nconst long uv_offset = upper ? (((reg >> 4 & 0x0f) + 1) * 12500) :\r\n(((reg >> 0 & 0x0f) + 1) * -25000);\r\nconst long uv_vid = vid * 1000;\r\nreturn (uv_vid + uv_offset + 5000) / 10000;\r\n}\r\nstatic u8 LM93_IN_REL_TO_REG(unsigned val, int upper, int vid)\r\n{\r\nlong uv_offset = vid * 1000 - val * 10000;\r\nif (upper) {\r\nuv_offset = clamp_val(uv_offset, 12500, 200000);\r\nreturn (u8)((uv_offset / 12500 - 1) << 4);\r\n} else {\r\nuv_offset = clamp_val(uv_offset, -400000, -25000);\r\nreturn (u8)((uv_offset / -25000 - 1) << 0);\r\n}\r\n}\r\nstatic int LM93_TEMP_FROM_REG(u8 reg)\r\n{\r\nreturn (s8)reg * 1000;\r\n}\r\nstatic u8 LM93_TEMP_TO_REG(long temp)\r\n{\r\nint ntemp = clamp_val(temp, LM93_TEMP_MIN, LM93_TEMP_MAX);\r\nntemp += (ntemp < 0 ? -500 : 500);\r\nreturn (u8)(ntemp / 1000);\r\n}\r\nstatic int LM93_TEMP_OFFSET_MODE_FROM_REG(u8 sfc2, int nr)\r\n{\r\nreturn sfc2 & (nr < 2 ? 0x10 : 0x20);\r\n}\r\nstatic int LM93_TEMP_OFFSET_FROM_REG(u8 reg, int mode)\r\n{\r\nreturn (reg & 0x0f) * (mode ? 5 : 10);\r\n}\r\nstatic u8 LM93_TEMP_OFFSET_TO_REG(int off, int mode)\r\n{\r\nint factor = mode ? 5 : 10;\r\noff = clamp_val(off, LM93_TEMP_OFFSET_MIN,\r\nmode ? LM93_TEMP_OFFSET_MAX1 : LM93_TEMP_OFFSET_MAX0);\r\nreturn (u8)((off + factor/2) / factor);\r\n}\r\nstatic int LM93_TEMP_AUTO_OFFSET_FROM_REG(u8 reg, int nr, int mode)\r\n{\r\nif (nr < 2)\r\nreturn LM93_TEMP_OFFSET_FROM_REG(reg & 0x0f, mode);\r\nelse\r\nreturn LM93_TEMP_OFFSET_FROM_REG(reg >> 4 & 0x0f, mode);\r\n}\r\nstatic u8 LM93_TEMP_AUTO_OFFSET_TO_REG(u8 old, int off, int nr, int mode)\r\n{\r\nu8 new = LM93_TEMP_OFFSET_TO_REG(off, mode);\r\nif (nr < 2)\r\nreturn (old & 0xf0) | (new & 0x0f);\r\nelse\r\nreturn (new << 4 & 0xf0) | (old & 0x0f);\r\n}\r\nstatic int LM93_AUTO_BOOST_HYST_FROM_REGS(struct lm93_data *data, int nr,\r\nint mode)\r\n{\r\nu8 reg;\r\nswitch (nr) {\r\ncase 0:\r\nreg = data->boost_hyst[0] & 0x0f;\r\nbreak;\r\ncase 1:\r\nreg = data->boost_hyst[0] >> 4 & 0x0f;\r\nbreak;\r\ncase 2:\r\nreg = data->boost_hyst[1] & 0x0f;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nreg = data->boost_hyst[1] >> 4 & 0x0f;\r\nbreak;\r\n}\r\nreturn LM93_TEMP_FROM_REG(data->boost[nr]) -\r\nLM93_TEMP_OFFSET_FROM_REG(reg, mode);\r\n}\r\nstatic u8 LM93_AUTO_BOOST_HYST_TO_REG(struct lm93_data *data, long hyst,\r\nint nr, int mode)\r\n{\r\nu8 reg = LM93_TEMP_OFFSET_TO_REG(\r\n(LM93_TEMP_FROM_REG(data->boost[nr]) - hyst), mode);\r\nswitch (nr) {\r\ncase 0:\r\nreg = (data->boost_hyst[0] & 0xf0) | (reg & 0x0f);\r\nbreak;\r\ncase 1:\r\nreg = (reg << 4 & 0xf0) | (data->boost_hyst[0] & 0x0f);\r\nbreak;\r\ncase 2:\r\nreg = (data->boost_hyst[1] & 0xf0) | (reg & 0x0f);\r\nbreak;\r\ncase 3:\r\ndefault:\r\nreg = (reg << 4 & 0xf0) | (data->boost_hyst[1] & 0x0f);\r\nbreak;\r\n}\r\nreturn reg;\r\n}\r\nstatic int LM93_PWM_FROM_REG(u8 reg, enum pwm_freq freq)\r\n{\r\nreturn lm93_pwm_map[freq][reg & 0x0f];\r\n}\r\nstatic u8 LM93_PWM_TO_REG(int pwm, enum pwm_freq freq)\r\n{\r\nint i;\r\nfor (i = 0; i < 13; i++)\r\nif (pwm <= lm93_pwm_map[freq][i])\r\nbreak;\r\nreturn (u8)i;\r\n}\r\nstatic int LM93_FAN_FROM_REG(u16 regs)\r\n{\r\nconst u16 count = le16_to_cpu(regs) >> 2;\r\nreturn count == 0 ? -1 : count == 0x3fff ? 0 : 1350000 / count;\r\n}\r\nstatic u16 LM93_FAN_TO_REG(long rpm)\r\n{\r\nu16 count, regs;\r\nif (rpm == 0) {\r\ncount = 0x3fff;\r\n} else {\r\nrpm = clamp_val(rpm, 1, 1000000);\r\ncount = clamp_val((1350000 + rpm) / rpm, 1, 0x3ffe);\r\n}\r\nregs = count << 2;\r\nreturn cpu_to_le16(regs);\r\n}\r\nstatic int LM93_PWM_FREQ_FROM_REG(u8 reg)\r\n{\r\nreturn lm93_pwm_freq_map[reg & 0x07];\r\n}\r\nstatic u8 LM93_PWM_FREQ_TO_REG(int freq)\r\n{\r\nint i;\r\nfor (i = 7; i > 0; i--)\r\nif (freq <= lm93_pwm_freq_map[i])\r\nbreak;\r\nreturn (u8)i;\r\n}\r\nstatic int LM93_SPINUP_TIME_FROM_REG(u8 reg)\r\n{\r\nreturn lm93_spinup_time_map[reg >> 5 & 0x07];\r\n}\r\nstatic u8 LM93_SPINUP_TIME_TO_REG(int time)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++)\r\nif (time <= lm93_spinup_time_map[i])\r\nbreak;\r\nreturn (u8)i;\r\n}\r\nstatic int LM93_RAMP_FROM_REG(u8 reg)\r\n{\r\nreturn (reg & 0x0f) * 5;\r\n}\r\nstatic u8 LM93_RAMP_TO_REG(int ramp)\r\n{\r\nramp = clamp_val(ramp, LM93_RAMP_MIN, LM93_RAMP_MAX);\r\nreturn (u8)((ramp + 2) / 5);\r\n}\r\nstatic u8 LM93_PROCHOT_TO_REG(long prochot)\r\n{\r\nprochot = clamp_val(prochot, 0, 255);\r\nreturn (u8)prochot;\r\n}\r\nstatic int LM93_INTERVAL_FROM_REG(u8 reg)\r\n{\r\nreturn lm93_interval_map[reg & 0x0f];\r\n}\r\nstatic u8 LM93_INTERVAL_TO_REG(long interval)\r\n{\r\nint i;\r\nfor (i = 0; i < 9; i++)\r\nif (interval <= lm93_interval_map[i])\r\nbreak;\r\nreturn (u8)i;\r\n}\r\nstatic unsigned LM93_GPI_FROM_REG(u8 reg)\r\n{\r\nreturn ~reg & 0xff;\r\n}\r\nstatic unsigned LM93_ALARMS_FROM_REG(struct block1_t b1)\r\n{\r\nunsigned result;\r\nresult = b1.host_status_2 & 0x3f;\r\nif (vccp_limit_type[0])\r\nresult |= (b1.host_status_4 & 0x10) << 2;\r\nelse\r\nresult |= b1.host_status_2 & 0x40;\r\nif (vccp_limit_type[1])\r\nresult |= (b1.host_status_4 & 0x20) << 2;\r\nelse\r\nresult |= b1.host_status_2 & 0x80;\r\nresult |= b1.host_status_3 << 8;\r\nresult |= (b1.fan_status & 0x0f) << 16;\r\nresult |= (b1.p1_prochot_status & 0x80) << 13;\r\nresult |= (b1.p2_prochot_status & 0x80) << 14;\r\nresult |= (b1.host_status_4 & 0xfc) << 20;\r\nresult |= (b1.host_status_1 & 0x07) << 28;\r\nreturn result;\r\n}\r\nstatic u8 lm93_read_byte(struct i2c_client *client, u8 reg)\r\n{\r\nint value, i;\r\nfor (i = 1; i <= MAX_RETRIES; i++) {\r\nvalue = i2c_smbus_read_byte_data(client, reg);\r\nif (value >= 0) {\r\nreturn value;\r\n} else {\r\ndev_warn(&client->dev,\r\n"lm93: read byte data failed, address 0x%02x.\n",\r\nreg);\r\nmdelay(i + 3);\r\n}\r\n}\r\ndev_err(&client->dev, "lm93: All read byte retries failed!!\n");\r\nreturn 0;\r\n}\r\nstatic int lm93_write_byte(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nint result;\r\nresult = i2c_smbus_write_byte_data(client, reg, value);\r\nif (result < 0)\r\ndev_warn(&client->dev,\r\n"lm93: write byte data failed, 0x%02x at address 0x%02x.\n",\r\nvalue, reg);\r\nreturn result;\r\n}\r\nstatic u16 lm93_read_word(struct i2c_client *client, u8 reg)\r\n{\r\nint value, i;\r\nfor (i = 1; i <= MAX_RETRIES; i++) {\r\nvalue = i2c_smbus_read_word_data(client, reg);\r\nif (value >= 0) {\r\nreturn value;\r\n} else {\r\ndev_warn(&client->dev,\r\n"lm93: read word data failed, address 0x%02x.\n",\r\nreg);\r\nmdelay(i + 3);\r\n}\r\n}\r\ndev_err(&client->dev, "lm93: All read word retries failed!!\n");\r\nreturn 0;\r\n}\r\nstatic int lm93_write_word(struct i2c_client *client, u8 reg, u16 value)\r\n{\r\nint result;\r\nresult = i2c_smbus_write_word_data(client, reg, value);\r\nif (result < 0)\r\ndev_warn(&client->dev,\r\n"lm93: write word data failed, 0x%04x at address 0x%02x.\n",\r\nvalue, reg);\r\nreturn result;\r\n}\r\nstatic void lm93_read_block(struct i2c_client *client, u8 fbn, u8 *values)\r\n{\r\nint i, result = 0;\r\nfor (i = 1; i <= MAX_RETRIES; i++) {\r\nresult = i2c_smbus_read_block_data(client,\r\nlm93_block_read_cmds[fbn].cmd, lm93_block_buffer);\r\nif (result == lm93_block_read_cmds[fbn].len) {\r\nbreak;\r\n} else {\r\ndev_warn(&client->dev,\r\n"lm93: block read data failed, command 0x%02x.\n",\r\nlm93_block_read_cmds[fbn].cmd);\r\nmdelay(i + 3);\r\n}\r\n}\r\nif (result == lm93_block_read_cmds[fbn].len) {\r\nmemcpy(values, lm93_block_buffer,\r\nlm93_block_read_cmds[fbn].len);\r\n} else {\r\n}\r\n}\r\nstatic struct lm93_data *lm93_update_device(struct device *dev)\r\n{\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nconst unsigned long interval = HZ + (HZ / 2);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + interval) ||\r\n!data->valid) {\r\ndata->update(data, client);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic void lm93_update_client_common(struct lm93_data *data,\r\nstruct i2c_client *client)\r\n{\r\nint i;\r\nu8 *ptr;\r\nfor (i = 0; i < 4; i++) {\r\ndata->temp_lim[i].min =\r\nlm93_read_byte(client, LM93_REG_TEMP_MIN(i));\r\ndata->temp_lim[i].max =\r\nlm93_read_byte(client, LM93_REG_TEMP_MAX(i));\r\n}\r\ndata->config = lm93_read_byte(client, LM93_REG_CONFIG);\r\nfor (i = 0; i < 2; i++)\r\ndata->vid[i] = lm93_read_byte(client, LM93_REG_VID(i));\r\nfor (i = 0; i < 2; i++)\r\ndata->prochot_max[i] = lm93_read_byte(client,\r\nLM93_REG_PROCHOT_MAX(i));\r\nfor (i = 0; i < 2; i++)\r\ndata->vccp_limits[i] = lm93_read_byte(client,\r\nLM93_REG_VCCP_LIMIT_OFF(i));\r\ndata->gpi = lm93_read_byte(client, LM93_REG_GPI);\r\ndata->prochot_override = lm93_read_byte(client,\r\nLM93_REG_PROCHOT_OVERRIDE);\r\ndata->prochot_interval = lm93_read_byte(client,\r\nLM93_REG_PROCHOT_INTERVAL);\r\nfor (i = 0; i < 4; i++)\r\ndata->boost[i] = lm93_read_byte(client, LM93_REG_BOOST(i));\r\ndata->boost_hyst[0] = lm93_read_byte(client, LM93_REG_BOOST_HYST_12);\r\ndata->boost_hyst[1] = lm93_read_byte(client, LM93_REG_BOOST_HYST_34);\r\ndata->auto_pwm_min_hyst[0] =\r\nlm93_read_byte(client, LM93_REG_PWM_MIN_HYST_12);\r\ndata->auto_pwm_min_hyst[1] =\r\nlm93_read_byte(client, LM93_REG_PWM_MIN_HYST_34);\r\ndata->pwm_ramp_ctl = lm93_read_byte(client, LM93_REG_PWM_RAMP_CTL);\r\ndata->sfc1 = lm93_read_byte(client, LM93_REG_SFC1);\r\ndata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\r\ndata->sf_tach_to_pwm = lm93_read_byte(client,\r\nLM93_REG_SF_TACH_TO_PWM);\r\nfor (i = 0, ptr = (u8 *)(&data->block1); i < 8; i++)\r\nlm93_write_byte(client, LM93_REG_HOST_ERROR_1 + i, *(ptr + i));\r\n}\r\nstatic void lm93_update_client_full(struct lm93_data *data,\r\nstruct i2c_client *client)\r\n{\r\ndev_dbg(&client->dev, "starting device update (block data enabled)\n");\r\nlm93_read_block(client, 3, (u8 *)(data->block3));\r\nlm93_read_block(client, 7, (u8 *)(data->block7));\r\nlm93_read_block(client, 2, (u8 *)(data->block2));\r\nlm93_read_block(client, 4, (u8 *)(data->block4));\r\nlm93_read_block(client, 5, (u8 *)(data->block5));\r\nlm93_read_block(client, 8, (u8 *)(data->block8));\r\nlm93_read_block(client, 9, (u8 *)(data->block9));\r\nlm93_read_block(client, 1, (u8 *)(&data->block1));\r\nlm93_read_block(client, 10, (u8 *)(&data->block10));\r\nlm93_update_client_common(data, client);\r\n}\r\nstatic void lm93_update_client_min(struct lm93_data *data,\r\nstruct i2c_client *client)\r\n{\r\nint i, j;\r\nu8 *ptr;\r\ndev_dbg(&client->dev, "starting device update (block data disabled)\n");\r\nfor (i = 0; i < 16; i++) {\r\ndata->block3[i] =\r\nlm93_read_byte(client, LM93_REG_IN(i));\r\ndata->block7[i].min =\r\nlm93_read_byte(client, LM93_REG_IN_MIN(i));\r\ndata->block7[i].max =\r\nlm93_read_byte(client, LM93_REG_IN_MAX(i));\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ndata->block2[i] =\r\nlm93_read_byte(client, LM93_REG_TEMP(i));\r\n}\r\nfor (i = 0; i < 2; i++) {\r\ndata->block4[i].cur =\r\nlm93_read_byte(client, LM93_REG_PROCHOT_CUR(i));\r\ndata->block4[i].avg =\r\nlm93_read_byte(client, LM93_REG_PROCHOT_AVG(i));\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ndata->block5[i] =\r\nlm93_read_word(client, LM93_REG_FAN(i));\r\ndata->block8[i] =\r\nlm93_read_word(client, LM93_REG_FAN_MIN(i));\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nfor (j = 0; j < 4; j++) {\r\ndata->block9[i][j] =\r\nlm93_read_byte(client, LM93_REG_PWM_CTL(i, j));\r\n}\r\n}\r\nfor (i = 0, ptr = (u8 *)(&data->block1); i < 8; i++) {\r\n*(ptr + i) =\r\nlm93_read_byte(client, LM93_REG_HOST_ERROR_1 + i);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ndata->block10.base[i] =\r\nlm93_read_byte(client, LM93_REG_TEMP_BASE(i));\r\n}\r\nfor (i = 0; i < 12; i++) {\r\ndata->block10.offset[i] =\r\nlm93_read_byte(client, LM93_REG_TEMP_OFFSET(i));\r\n}\r\nlm93_update_client_common(data, client);\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_IN_FROM_REG(nr, data->block3[nr]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nint vccp = nr - 6;\r\nlong rc, vid;\r\nif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\r\nvid = LM93_VID_FROM_REG(data->vid[vccp]);\r\nrc = LM93_IN_MIN_FROM_REG(data->vccp_limits[vccp], vid);\r\n} else {\r\nrc = LM93_IN_FROM_REG(nr, data->block7[nr].min);\r\n}\r\nreturn sprintf(buf, "%ld\n", rc);\r\n}\r\nstatic ssize_t store_in_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint vccp = nr - 6;\r\nlong vid;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\r\nvid = LM93_VID_FROM_REG(data->vid[vccp]);\r\ndata->vccp_limits[vccp] = (data->vccp_limits[vccp] & 0xf0) |\r\nLM93_IN_REL_TO_REG(val, 0, vid);\r\nlm93_write_byte(client, LM93_REG_VCCP_LIMIT_OFF(vccp),\r\ndata->vccp_limits[vccp]);\r\n} else {\r\ndata->block7[nr].min = LM93_IN_TO_REG(nr, val);\r\nlm93_write_byte(client, LM93_REG_IN_MIN(nr),\r\ndata->block7[nr].min);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nint vccp = nr - 6;\r\nlong rc, vid;\r\nif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\r\nvid = LM93_VID_FROM_REG(data->vid[vccp]);\r\nrc = LM93_IN_MAX_FROM_REG(data->vccp_limits[vccp], vid);\r\n} else {\r\nrc = LM93_IN_FROM_REG(nr, data->block7[nr].max);\r\n}\r\nreturn sprintf(buf, "%ld\n", rc);\r\n}\r\nstatic ssize_t store_in_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint vccp = nr - 6;\r\nlong vid;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif ((nr == 6 || nr == 7) && vccp_limit_type[vccp]) {\r\nvid = LM93_VID_FROM_REG(data->vid[vccp]);\r\ndata->vccp_limits[vccp] = (data->vccp_limits[vccp] & 0x0f) |\r\nLM93_IN_REL_TO_REG(val, 1, vid);\r\nlm93_write_byte(client, LM93_REG_VCCP_LIMIT_OFF(vccp),\r\ndata->vccp_limits[vccp]);\r\n} else {\r\ndata->block7[nr].max = LM93_IN_TO_REG(nr, val);\r\nlm93_write_byte(client, LM93_REG_IN_MAX(nr),\r\ndata->block7[nr].max);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_TEMP_FROM_REG(data->block2[nr]));\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_TEMP_FROM_REG(data->temp_lim[nr].min));\r\n}\r\nstatic ssize_t store_temp_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_lim[nr].min = LM93_TEMP_TO_REG(val);\r\nlm93_write_byte(client, LM93_REG_TEMP_MIN(nr), data->temp_lim[nr].min);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_TEMP_FROM_REG(data->temp_lim[nr].max));\r\n}\r\nstatic ssize_t store_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_lim[nr].max = LM93_TEMP_TO_REG(val);\r\nlm93_write_byte(client, LM93_REG_TEMP_MAX(nr), data->temp_lim[nr].max);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_base(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_TEMP_FROM_REG(data->block10.base[nr]));\r\n}\r\nstatic ssize_t store_temp_auto_base(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->block10.base[nr] = LM93_TEMP_TO_REG(val);\r\nlm93_write_byte(client, LM93_REG_TEMP_BASE(nr), data->block10.base[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_boost(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_TEMP_FROM_REG(data->boost[nr]));\r\n}\r\nstatic ssize_t store_temp_auto_boost(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->boost[nr] = LM93_TEMP_TO_REG(val);\r\nlm93_write_byte(client, LM93_REG_BOOST(nr), data->boost[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_boost_hyst(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nint mode = LM93_TEMP_OFFSET_MODE_FROM_REG(data->sfc2, nr);\r\nreturn sprintf(buf, "%d\n",\r\nLM93_AUTO_BOOST_HYST_FROM_REGS(data, nr, mode));\r\n}\r\nstatic ssize_t store_temp_auto_boost_hyst(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\r\ndata->sfc2 |= ((nr < 2) ? 0x10 : 0x20);\r\nlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\r\ndata->boost_hyst[nr/2] = LM93_AUTO_BOOST_HYST_TO_REG(data, val, nr, 1);\r\nlm93_write_byte(client, LM93_REG_BOOST_HYST(nr),\r\ndata->boost_hyst[nr/2]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_offset(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *s_attr = to_sensor_dev_attr_2(attr);\r\nint nr = s_attr->index;\r\nint ofs = s_attr->nr;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nint mode = LM93_TEMP_OFFSET_MODE_FROM_REG(data->sfc2, nr);\r\nreturn sprintf(buf, "%d\n",\r\nLM93_TEMP_AUTO_OFFSET_FROM_REG(data->block10.offset[ofs],\r\nnr, mode));\r\n}\r\nstatic ssize_t store_temp_auto_offset(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *s_attr = to_sensor_dev_attr_2(attr);\r\nint nr = s_attr->index;\r\nint ofs = s_attr->nr;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\r\ndata->sfc2 |= ((nr < 2) ? 0x10 : 0x20);\r\nlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\r\ndata->block10.offset[ofs] = LM93_TEMP_AUTO_OFFSET_TO_REG(\r\ndata->block10.offset[ofs], val, nr, 1);\r\nlm93_write_byte(client, LM93_REG_TEMP_OFFSET(ofs),\r\ndata->block10.offset[ofs]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_pwm_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nu8 reg, ctl4;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreg = data->auto_pwm_min_hyst[nr/2] >> 4 & 0x0f;\r\nctl4 = data->block9[nr][LM93_PWM_CTL4];\r\nreturn sprintf(buf, "%d\n", LM93_PWM_FROM_REG(reg, (ctl4 & 0x07) ?\r\nLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ));\r\n}\r\nstatic ssize_t store_temp_auto_pwm_min(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 reg, ctl4;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nreg = lm93_read_byte(client, LM93_REG_PWM_MIN_HYST(nr));\r\nctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\r\nreg = (reg & 0x0f) |\r\nLM93_PWM_TO_REG(val, (ctl4 & 0x07) ?\r\nLM93_PWM_MAP_LO_FREQ :\r\nLM93_PWM_MAP_HI_FREQ) << 4;\r\ndata->auto_pwm_min_hyst[nr/2] = reg;\r\nlm93_write_byte(client, LM93_REG_PWM_MIN_HYST(nr), reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_offset_hyst(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nint mode = LM93_TEMP_OFFSET_MODE_FROM_REG(data->sfc2, nr);\r\nreturn sprintf(buf, "%d\n", LM93_TEMP_OFFSET_FROM_REG(\r\ndata->auto_pwm_min_hyst[nr / 2], mode));\r\n}\r\nstatic ssize_t store_temp_auto_offset_hyst(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\r\ndata->sfc2 |= ((nr < 2) ? 0x10 : 0x20);\r\nlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\r\nreg = data->auto_pwm_min_hyst[nr/2];\r\nreg = (reg & 0xf0) | (LM93_TEMP_OFFSET_TO_REG(val, 1) & 0x0f);\r\ndata->auto_pwm_min_hyst[nr/2] = reg;\r\nlm93_write_byte(client, LM93_REG_PWM_MIN_HYST(nr), reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_input(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *s_attr = to_sensor_dev_attr(attr);\r\nint nr = s_attr->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_FAN_FROM_REG(data->block5[nr]));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_FAN_FROM_REG(data->block8[nr]));\r\n}\r\nstatic ssize_t store_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->block8[nr] = LM93_FAN_TO_REG(val);\r\nlm93_write_word(client, LM93_REG_FAN_MIN(nr), data->block8[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_smart_tach(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nlong rc = 0;\r\nint mapping;\r\nmapping = (data->sf_tach_to_pwm >> (nr * 2)) & 0x03;\r\nif (mapping && ((data->sfc2 >> nr) & 0x01))\r\nrc = mapping;\r\nreturn sprintf(buf, "%ld\n", rc);\r\n}\r\nstatic void lm93_write_fan_smart_tach(struct i2c_client *client,\r\nstruct lm93_data *data, int fan, long value)\r\n{\r\ndata->sf_tach_to_pwm = lm93_read_byte(client, LM93_REG_SF_TACH_TO_PWM);\r\ndata->sf_tach_to_pwm &= ~(0x3 << fan * 2);\r\ndata->sf_tach_to_pwm |= value << fan * 2;\r\nlm93_write_byte(client, LM93_REG_SF_TACH_TO_PWM, data->sf_tach_to_pwm);\r\ndata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\r\nif (value)\r\ndata->sfc2 |= 1 << fan;\r\nelse\r\ndata->sfc2 &= ~(1 << fan);\r\nlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\r\n}\r\nstatic ssize_t store_fan_smart_tach(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (val <= 2) {\r\nif (val) {\r\nu8 ctl4 = lm93_read_byte(client,\r\nLM93_REG_PWM_CTL(val - 1, LM93_PWM_CTL4));\r\nif ((ctl4 & 0x07) == 0)\r\nval = 0;\r\n}\r\nlm93_write_fan_smart_tach(client, data, nr, val);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nu8 ctl2, ctl4;\r\nlong rc;\r\nctl2 = data->block9[nr][LM93_PWM_CTL2];\r\nctl4 = data->block9[nr][LM93_PWM_CTL4];\r\nif (ctl2 & 0x01)\r\nrc = data->pwm_override[nr];\r\nelse\r\nrc = LM93_PWM_FROM_REG(ctl2 >> 4, (ctl4 & 0x07) ?\r\nLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ);\r\nreturn sprintf(buf, "%ld\n", rc);\r\n}\r\nstatic ssize_t store_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 ctl2, ctl4;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nctl2 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2));\r\nctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\r\nctl2 = (ctl2 & 0x0f) | LM93_PWM_TO_REG(val, (ctl4 & 0x07) ?\r\nLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ) << 4;\r\ndata->pwm_override[nr] = LM93_PWM_FROM_REG(ctl2 >> 4,\r\n(ctl4 & 0x07) ? LM93_PWM_MAP_LO_FREQ :\r\nLM93_PWM_MAP_HI_FREQ);\r\nlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2), ctl2);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nu8 ctl2;\r\nlong rc;\r\nctl2 = data->block9[nr][LM93_PWM_CTL2];\r\nif (ctl2 & 0x01)\r\nrc = ((ctl2 & 0xF0) == 0xF0) ? 0 : 1;\r\nelse\r\nrc = 2;\r\nreturn sprintf(buf, "%ld\n", rc);\r\n}\r\nstatic ssize_t store_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 ctl2;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nctl2 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2));\r\nswitch (val) {\r\ncase 0:\r\nctl2 |= 0xF1;\r\nbreak;\r\ncase 1:\r\nctl2 |= 0x01;\r\nbreak;\r\ncase 2:\r\nctl2 &= ~0x01;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\nlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL2), ctl2);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_freq(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nu8 ctl4;\r\nctl4 = data->block9[nr][LM93_PWM_CTL4];\r\nreturn sprintf(buf, "%d\n", LM93_PWM_FREQ_FROM_REG(ctl4));\r\n}\r\nstatic void lm93_disable_fan_smart_tach(struct i2c_client *client,\r\nstruct lm93_data *data, int pwm)\r\n{\r\nint mapping = lm93_read_byte(client, LM93_REG_SF_TACH_TO_PWM);\r\nint mask;\r\nmapping = (mapping >> pwm) & 0x55;\r\nmask = mapping & 0x01;\r\nmask |= (mapping & 0x04) >> 1;\r\nmask |= (mapping & 0x10) >> 2;\r\nmask |= (mapping & 0x40) >> 3;\r\ndata->sfc2 = lm93_read_byte(client, LM93_REG_SFC2);\r\ndata->sfc2 &= ~mask;\r\nlm93_write_byte(client, LM93_REG_SFC2, data->sfc2);\r\n}\r\nstatic ssize_t store_pwm_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 ctl4;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\r\nctl4 = (ctl4 & 0xf8) | LM93_PWM_FREQ_TO_REG(val);\r\ndata->block9[nr][LM93_PWM_CTL4] = ctl4;\r\nif (!ctl4)\r\nlm93_disable_fan_smart_tach(client, data, nr);\r\nlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4), ctl4);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_channels(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->block9[nr][LM93_PWM_CTL1]);\r\n}\r\nstatic ssize_t store_pwm_auto_channels(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->block9[nr][LM93_PWM_CTL1] = clamp_val(val, 0, 255);\r\nlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL1),\r\ndata->block9[nr][LM93_PWM_CTL1]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_spinup_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nu8 ctl3, ctl4;\r\nctl3 = data->block9[nr][LM93_PWM_CTL3];\r\nctl4 = data->block9[nr][LM93_PWM_CTL4];\r\nreturn sprintf(buf, "%d\n",\r\nLM93_PWM_FROM_REG(ctl3 & 0x0f, (ctl4 & 0x07) ?\r\nLM93_PWM_MAP_LO_FREQ : LM93_PWM_MAP_HI_FREQ));\r\n}\r\nstatic ssize_t store_pwm_auto_spinup_min(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 ctl3, ctl4;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nctl3 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3));\r\nctl4 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL4));\r\nctl3 = (ctl3 & 0xf0) | LM93_PWM_TO_REG(val, (ctl4 & 0x07) ?\r\nLM93_PWM_MAP_LO_FREQ :\r\nLM93_PWM_MAP_HI_FREQ);\r\ndata->block9[nr][LM93_PWM_CTL3] = ctl3;\r\nlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3), ctl3);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_spinup_time(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_SPINUP_TIME_FROM_REG(\r\ndata->block9[nr][LM93_PWM_CTL3]));\r\n}\r\nstatic ssize_t store_pwm_auto_spinup_time(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 ctl3;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nctl3 = lm93_read_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3));\r\nctl3 = (ctl3 & 0x1f) | (LM93_SPINUP_TIME_TO_REG(val) << 5 & 0xe0);\r\ndata->block9[nr][LM93_PWM_CTL3] = ctl3;\r\nlm93_write_byte(client, LM93_REG_PWM_CTL(nr, LM93_PWM_CTL3), ctl3);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_prochot_ramp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\nLM93_RAMP_FROM_REG(data->pwm_ramp_ctl >> 4 & 0x0f));\r\n}\r\nstatic ssize_t store_pwm_auto_prochot_ramp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 ramp;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nramp = lm93_read_byte(client, LM93_REG_PWM_RAMP_CTL);\r\nramp = (ramp & 0x0f) | (LM93_RAMP_TO_REG(val) << 4 & 0xf0);\r\nlm93_write_byte(client, LM93_REG_PWM_RAMP_CTL, ramp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_vrdhot_ramp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\nLM93_RAMP_FROM_REG(data->pwm_ramp_ctl & 0x0f));\r\n}\r\nstatic ssize_t store_pwm_auto_vrdhot_ramp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 ramp;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nramp = lm93_read_byte(client, LM93_REG_PWM_RAMP_CTL);\r\nramp = (ramp & 0xf0) | (LM93_RAMP_TO_REG(val) & 0x0f);\r\nlm93_write_byte(client, LM93_REG_PWM_RAMP_CTL, ramp);\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_vid(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_VID_FROM_REG(data->vid[nr]));\r\n}\r\nstatic ssize_t show_prochot(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->block4[nr].cur);\r\n}\r\nstatic ssize_t show_prochot_avg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->block4[nr].avg);\r\n}\r\nstatic ssize_t show_prochot_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->prochot_max[nr]);\r\n}\r\nstatic ssize_t store_prochot_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->prochot_max[nr] = LM93_PROCHOT_TO_REG(val);\r\nlm93_write_byte(client, LM93_REG_PROCHOT_MAX(nr),\r\ndata->prochot_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_prochot_override(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\n(data->prochot_override & prochot_override_mask[nr]) ? 1 : 0);\r\n}\r\nstatic ssize_t store_prochot_override(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (val)\r\ndata->prochot_override |= prochot_override_mask[nr];\r\nelse\r\ndata->prochot_override &= (~prochot_override_mask[nr]);\r\nlm93_write_byte(client, LM93_REG_PROCHOT_OVERRIDE,\r\ndata->prochot_override);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_prochot_interval(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nu8 tmp;\r\nif (nr == 1)\r\ntmp = (data->prochot_interval & 0xf0) >> 4;\r\nelse\r\ntmp = data->prochot_interval & 0x0f;\r\nreturn sprintf(buf, "%d\n", LM93_INTERVAL_FROM_REG(tmp));\r\n}\r\nstatic ssize_t store_prochot_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 tmp;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ntmp = lm93_read_byte(client, LM93_REG_PROCHOT_INTERVAL);\r\nif (nr == 1)\r\ntmp = (tmp & 0x0f) | (LM93_INTERVAL_TO_REG(val) << 4);\r\nelse\r\ntmp = (tmp & 0xf0) | LM93_INTERVAL_TO_REG(val);\r\ndata->prochot_interval = tmp;\r\nlm93_write_byte(client, LM93_REG_PROCHOT_INTERVAL, tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_prochot_override_duty_cycle(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->prochot_override & 0x0f);\r\n}\r\nstatic ssize_t store_prochot_override_duty_cycle(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->prochot_override = (data->prochot_override & 0xf0) |\r\nclamp_val(val, 0, 15);\r\nlm93_write_byte(client, LM93_REG_PROCHOT_OVERRIDE,\r\ndata->prochot_override);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_prochot_short(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->config & 0x10) ? 1 : 0);\r\n}\r\nstatic ssize_t store_prochot_short(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm93_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (val)\r\ndata->config |= 0x10;\r\nelse\r\ndata->config &= ~0x10;\r\nlm93_write_byte(client, LM93_REG_CONFIG, data->config);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vrdhot(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = (to_sensor_dev_attr(attr))->index;\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\ndata->block1.host_status_1 & (1 << (nr + 4)) ? 1 : 0);\r\n}\r\nstatic ssize_t show_gpio(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_GPI_FROM_REG(data->gpi));\r\n}\r\nstatic ssize_t show_alarms(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lm93_data *data = lm93_update_device(dev);\r\nreturn sprintf(buf, "%d\n", LM93_ALARMS_FROM_REG(data->block1));\r\n}\r\nstatic void lm93_init_client(struct i2c_client *client)\r\n{\r\nint i;\r\nu8 reg;\r\nreg = lm93_read_byte(client, LM93_REG_GPI_VID_CTL);\r\nlm93_write_byte(client, LM93_REG_GPI_VID_CTL,\r\nreg | (vid_agtl ? 0x03 : 0x00));\r\nif (init) {\r\nreg = lm93_read_byte(client, LM93_REG_CONFIG);\r\nlm93_write_byte(client, LM93_REG_CONFIG, reg | 0x08);\r\nreg = lm93_read_byte(client, LM93_REG_STATUS_CONTROL);\r\nlm93_write_byte(client, LM93_REG_STATUS_CONTROL, reg | 0x02);\r\nlm93_write_byte(client, LM93_REG_SLEEP_CONTROL, 0);\r\nreg = lm93_read_byte(client, LM93_REG_MISC_ERR_MASK);\r\nreg &= ~0x03;\r\nreg &= ~(vccp_limit_type[0] ? 0x10 : 0);\r\nreg &= ~(vccp_limit_type[1] ? 0x20 : 0);\r\nlm93_write_byte(client, LM93_REG_MISC_ERR_MASK, reg);\r\n}\r\nreg = lm93_read_byte(client, LM93_REG_CONFIG);\r\nlm93_write_byte(client, LM93_REG_CONFIG, reg | 0x01);\r\nfor (i = 0; i < 20; i++) {\r\nmsleep(10);\r\nif ((lm93_read_byte(client, LM93_REG_CONFIG) & 0x80) == 0x80)\r\nreturn;\r\n}\r\ndev_warn(&client->dev,\r\n"timed out waiting for sensor chip to signal ready!\n");\r\n}\r\nstatic int lm93_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint mfr, ver;\r\nconst char *name;\r\nif (!i2c_check_functionality(adapter, LM93_SMBUS_FUNC_MIN))\r\nreturn -ENODEV;\r\nmfr = lm93_read_byte(client, LM93_REG_MFR_ID);\r\nif (mfr != 0x01) {\r\ndev_dbg(&adapter->dev,\r\n"detect failed, bad manufacturer id 0x%02x!\n", mfr);\r\nreturn -ENODEV;\r\n}\r\nver = lm93_read_byte(client, LM93_REG_VER);\r\nswitch (ver) {\r\ncase LM93_MFR_ID:\r\ncase LM93_MFR_ID_PROTOTYPE:\r\nname = "lm93";\r\nbreak;\r\ncase LM94_MFR_ID_2:\r\ncase LM94_MFR_ID:\r\ncase LM94_MFR_ID_PROTOTYPE:\r\nname = "lm94";\r\nbreak;\r\ndefault:\r\ndev_dbg(&adapter->dev,\r\n"detect failed, bad version id 0x%02x!\n", ver);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\ndev_dbg(&adapter->dev, "loading %s at %d, 0x%02x\n",\r\nclient->name, i2c_adapter_id(client->adapter),\r\nclient->addr);\r\nreturn 0;\r\n}\r\nstatic int lm93_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct lm93_data *data;\r\nstruct device *hwmon_dev;\r\nint func;\r\nvoid (*update)(struct lm93_data *, struct i2c_client *);\r\nfunc = i2c_get_functionality(client->adapter);\r\nif (((LM93_SMBUS_FUNC_FULL & func) == LM93_SMBUS_FUNC_FULL) &&\r\n(!disable_block)) {\r\ndev_dbg(dev, "using SMBus block data transactions\n");\r\nupdate = lm93_update_client_full;\r\n} else if ((LM93_SMBUS_FUNC_MIN & func) == LM93_SMBUS_FUNC_MIN) {\r\ndev_dbg(dev, "disabled SMBus block data transactions\n");\r\nupdate = lm93_update_client_min;\r\n} else {\r\ndev_dbg(dev, "detect failed, smbus byte and/or word data not supported!\n");\r\nreturn -ENODEV;\r\n}\r\ndata = devm_kzalloc(dev, sizeof(struct lm93_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\ndata->update = update;\r\nmutex_init(&data->update_lock);\r\nlm93_init_client(client);\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata,\r\nlm93_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
