static inline bool is_w83667hg(struct nvt_dev *nvt)\r\n{\r\nreturn nvt->chip_ver == NVT_W83667HG;\r\n}\r\nstatic inline void nvt_cr_write(struct nvt_dev *nvt, u8 val, u8 reg)\r\n{\r\noutb(reg, nvt->cr_efir);\r\noutb(val, nvt->cr_efdr);\r\n}\r\nstatic inline u8 nvt_cr_read(struct nvt_dev *nvt, u8 reg)\r\n{\r\noutb(reg, nvt->cr_efir);\r\nreturn inb(nvt->cr_efdr);\r\n}\r\nstatic inline void nvt_set_reg_bit(struct nvt_dev *nvt, u8 val, u8 reg)\r\n{\r\nu8 tmp = nvt_cr_read(nvt, reg) | val;\r\nnvt_cr_write(nvt, tmp, reg);\r\n}\r\nstatic inline void nvt_clear_reg_bit(struct nvt_dev *nvt, u8 val, u8 reg)\r\n{\r\nu8 tmp = nvt_cr_read(nvt, reg) & ~val;\r\nnvt_cr_write(nvt, tmp, reg);\r\n}\r\nstatic inline int nvt_efm_enable(struct nvt_dev *nvt)\r\n{\r\nif (!request_muxed_region(nvt->cr_efir, 2, NVT_DRIVER_NAME))\r\nreturn -EBUSY;\r\noutb(EFER_EFM_ENABLE, nvt->cr_efir);\r\noutb(EFER_EFM_ENABLE, nvt->cr_efir);\r\nreturn 0;\r\n}\r\nstatic inline void nvt_efm_disable(struct nvt_dev *nvt)\r\n{\r\noutb(EFER_EFM_DISABLE, nvt->cr_efir);\r\nrelease_region(nvt->cr_efir, 2);\r\n}\r\nstatic inline void nvt_select_logical_dev(struct nvt_dev *nvt, u8 ldev)\r\n{\r\nnvt_cr_write(nvt, ldev, CR_LOGICAL_DEV_SEL);\r\n}\r\nstatic inline void nvt_enable_logical_dev(struct nvt_dev *nvt, u8 ldev)\r\n{\r\nnvt_efm_enable(nvt);\r\nnvt_select_logical_dev(nvt, ldev);\r\nnvt_cr_write(nvt, LOGICAL_DEV_ENABLE, CR_LOGICAL_DEV_EN);\r\nnvt_efm_disable(nvt);\r\n}\r\nstatic inline void nvt_disable_logical_dev(struct nvt_dev *nvt, u8 ldev)\r\n{\r\nnvt_efm_enable(nvt);\r\nnvt_select_logical_dev(nvt, ldev);\r\nnvt_cr_write(nvt, LOGICAL_DEV_DISABLE, CR_LOGICAL_DEV_EN);\r\nnvt_efm_disable(nvt);\r\n}\r\nstatic inline void nvt_cir_reg_write(struct nvt_dev *nvt, u8 val, u8 offset)\r\n{\r\noutb(val, nvt->cir_addr + offset);\r\n}\r\nstatic u8 nvt_cir_reg_read(struct nvt_dev *nvt, u8 offset)\r\n{\r\nu8 val;\r\nval = inb(nvt->cir_addr + offset);\r\nreturn val;\r\n}\r\nstatic inline void nvt_cir_wake_reg_write(struct nvt_dev *nvt,\r\nu8 val, u8 offset)\r\n{\r\noutb(val, nvt->cir_wake_addr + offset);\r\n}\r\nstatic u8 nvt_cir_wake_reg_read(struct nvt_dev *nvt, u8 offset)\r\n{\r\nu8 val;\r\nval = inb(nvt->cir_wake_addr + offset);\r\nreturn val;\r\n}\r\nstatic void nvt_set_ioaddr(struct nvt_dev *nvt, unsigned long *ioaddr)\r\n{\r\nunsigned long old_addr;\r\nold_addr = nvt_cr_read(nvt, CR_CIR_BASE_ADDR_HI) << 8;\r\nold_addr |= nvt_cr_read(nvt, CR_CIR_BASE_ADDR_LO);\r\nif (old_addr)\r\n*ioaddr = old_addr;\r\nelse {\r\nnvt_cr_write(nvt, *ioaddr >> 8, CR_CIR_BASE_ADDR_HI);\r\nnvt_cr_write(nvt, *ioaddr & 0xff, CR_CIR_BASE_ADDR_LO);\r\n}\r\n}\r\nstatic ssize_t wakeup_data_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct rc_dev *rc_dev = to_rc_dev(dev);\r\nstruct nvt_dev *nvt = rc_dev->priv;\r\nint fifo_len, duration;\r\nunsigned long flags;\r\nssize_t buf_len = 0;\r\nint i;\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nfifo_len = nvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_COUNT);\r\nfifo_len = min(fifo_len, WAKEUP_MAX_SIZE);\r\nwhile (nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX))\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);\r\nfor (i = 0; i < fifo_len; i++) {\r\nduration = nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);\r\nduration = (duration & BUF_LEN_MASK) * SAMPLE_PERIOD;\r\nbuf_len += snprintf(buf + buf_len, PAGE_SIZE - buf_len,\r\n"%d ", duration);\r\n}\r\nbuf_len += snprintf(buf + buf_len, PAGE_SIZE - buf_len, "\n");\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nreturn buf_len;\r\n}\r\nstatic ssize_t wakeup_data_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct rc_dev *rc_dev = to_rc_dev(dev);\r\nstruct nvt_dev *nvt = rc_dev->priv;\r\nunsigned long flags;\r\nu8 tolerance, config, wake_buf[WAKEUP_MAX_SIZE];\r\nchar **argv;\r\nint i, count;\r\nunsigned int val;\r\nssize_t ret;\r\nargv = argv_split(GFP_KERNEL, buf, &count);\r\nif (!argv)\r\nreturn -ENOMEM;\r\nif (!count || count > WAKEUP_MAX_SIZE) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nret = kstrtouint(argv[i], 10, &val);\r\nif (ret)\r\ngoto out;\r\nval = DIV_ROUND_CLOSEST(val, SAMPLE_PERIOD);\r\nif (!val || val > 0x7f) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nwake_buf[i] = val;\r\nif (i % 2 == 0)\r\nwake_buf[i] |= BUF_PULSE_BIT;\r\n}\r\ntolerance = DIV_ROUND_UP(count, 10);\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nnvt_clear_cir_wake_fifo(nvt);\r\nnvt_cir_wake_reg_write(nvt, count, CIR_WAKE_FIFO_CMP_DEEP);\r\nnvt_cir_wake_reg_write(nvt, tolerance, CIR_WAKE_FIFO_CMP_TOL);\r\nconfig = nvt_cir_wake_reg_read(nvt, CIR_WAKE_IRCON);\r\nnvt_cir_wake_reg_write(nvt, config | CIR_WAKE_IRCON_MODE1,\r\nCIR_WAKE_IRCON);\r\nfor (i = 0; i < count; i++)\r\nnvt_cir_wake_reg_write(nvt, wake_buf[i], CIR_WAKE_WR_FIFO_DATA);\r\nnvt_cir_wake_reg_write(nvt, config, CIR_WAKE_IRCON);\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nret = len;\r\nout:\r\nargv_free(argv);\r\nreturn ret;\r\n}\r\nstatic void cir_dump_regs(struct nvt_dev *nvt)\r\n{\r\nnvt_efm_enable(nvt);\r\nnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR);\r\npr_info("%s: Dump CIR logical device registers:\n", NVT_DRIVER_NAME);\r\npr_info(" * CR CIR ACTIVE : 0x%x\n",\r\nnvt_cr_read(nvt, CR_LOGICAL_DEV_EN));\r\npr_info(" * CR CIR BASE ADDR: 0x%x\n",\r\n(nvt_cr_read(nvt, CR_CIR_BASE_ADDR_HI) << 8) |\r\nnvt_cr_read(nvt, CR_CIR_BASE_ADDR_LO));\r\npr_info(" * CR CIR IRQ NUM: 0x%x\n",\r\nnvt_cr_read(nvt, CR_CIR_IRQ_RSRC));\r\nnvt_efm_disable(nvt);\r\npr_info("%s: Dump CIR registers:\n", NVT_DRIVER_NAME);\r\npr_info(" * IRCON: 0x%x\n", nvt_cir_reg_read(nvt, CIR_IRCON));\r\npr_info(" * IRSTS: 0x%x\n", nvt_cir_reg_read(nvt, CIR_IRSTS));\r\npr_info(" * IREN: 0x%x\n", nvt_cir_reg_read(nvt, CIR_IREN));\r\npr_info(" * RXFCONT: 0x%x\n", nvt_cir_reg_read(nvt, CIR_RXFCONT));\r\npr_info(" * CP: 0x%x\n", nvt_cir_reg_read(nvt, CIR_CP));\r\npr_info(" * CC: 0x%x\n", nvt_cir_reg_read(nvt, CIR_CC));\r\npr_info(" * SLCH: 0x%x\n", nvt_cir_reg_read(nvt, CIR_SLCH));\r\npr_info(" * SLCL: 0x%x\n", nvt_cir_reg_read(nvt, CIR_SLCL));\r\npr_info(" * FIFOCON: 0x%x\n", nvt_cir_reg_read(nvt, CIR_FIFOCON));\r\npr_info(" * IRFIFOSTS: 0x%x\n", nvt_cir_reg_read(nvt, CIR_IRFIFOSTS));\r\npr_info(" * SRXFIFO: 0x%x\n", nvt_cir_reg_read(nvt, CIR_SRXFIFO));\r\npr_info(" * TXFCONT: 0x%x\n", nvt_cir_reg_read(nvt, CIR_TXFCONT));\r\npr_info(" * STXFIFO: 0x%x\n", nvt_cir_reg_read(nvt, CIR_STXFIFO));\r\npr_info(" * FCCH: 0x%x\n", nvt_cir_reg_read(nvt, CIR_FCCH));\r\npr_info(" * FCCL: 0x%x\n", nvt_cir_reg_read(nvt, CIR_FCCL));\r\npr_info(" * IRFSM: 0x%x\n", nvt_cir_reg_read(nvt, CIR_IRFSM));\r\n}\r\nstatic void cir_wake_dump_regs(struct nvt_dev *nvt)\r\n{\r\nu8 i, fifo_len;\r\nnvt_efm_enable(nvt);\r\nnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\r\npr_info("%s: Dump CIR WAKE logical device registers:\n",\r\nNVT_DRIVER_NAME);\r\npr_info(" * CR CIR WAKE ACTIVE : 0x%x\n",\r\nnvt_cr_read(nvt, CR_LOGICAL_DEV_EN));\r\npr_info(" * CR CIR WAKE BASE ADDR: 0x%x\n",\r\n(nvt_cr_read(nvt, CR_CIR_BASE_ADDR_HI) << 8) |\r\nnvt_cr_read(nvt, CR_CIR_BASE_ADDR_LO));\r\npr_info(" * CR CIR WAKE IRQ NUM: 0x%x\n",\r\nnvt_cr_read(nvt, CR_CIR_IRQ_RSRC));\r\nnvt_efm_disable(nvt);\r\npr_info("%s: Dump CIR WAKE registers\n", NVT_DRIVER_NAME);\r\npr_info(" * IRCON: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_IRCON));\r\npr_info(" * IRSTS: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_IRSTS));\r\npr_info(" * IREN: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_IREN));\r\npr_info(" * FIFO CMP DEEP: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_CMP_DEEP));\r\npr_info(" * FIFO CMP TOL: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_CMP_TOL));\r\npr_info(" * FIFO COUNT: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_COUNT));\r\npr_info(" * SLCH: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_SLCH));\r\npr_info(" * SLCL: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_SLCL));\r\npr_info(" * FIFOCON: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFOCON));\r\npr_info(" * SRXFSTS: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_SRXFSTS));\r\npr_info(" * SAMPLE RX FIFO: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_SAMPLE_RX_FIFO));\r\npr_info(" * WR FIFO DATA: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_WR_FIFO_DATA));\r\npr_info(" * RD FIFO ONLY: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY));\r\npr_info(" * RD FIFO ONLY IDX: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX));\r\npr_info(" * FIFO IGNORE: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_IGNORE));\r\npr_info(" * IRFSM: 0x%x\n",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_IRFSM));\r\nfifo_len = nvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFO_COUNT);\r\npr_info("%s: Dump CIR WAKE FIFO (len %d)\n", NVT_DRIVER_NAME, fifo_len);\r\npr_info("* Contents =");\r\nfor (i = 0; i < fifo_len; i++)\r\npr_cont(" %02x",\r\nnvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY));\r\npr_cont("\n");\r\n}\r\nstatic inline const char *nvt_find_chip(struct nvt_dev *nvt, int id)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nvt_chips); i++)\r\nif ((id & SIO_ID_MASK) == nvt_chips[i].chip_ver) {\r\nnvt->chip_ver = nvt_chips[i].chip_ver;\r\nreturn nvt_chips[i].name;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int nvt_hw_detect(struct nvt_dev *nvt)\r\n{\r\nconst char *chip_name;\r\nint chip_id;\r\nnvt_efm_enable(nvt);\r\nnvt->chip_major = nvt_cr_read(nvt, CR_CHIP_ID_HI);\r\nif (nvt->chip_major == 0xff) {\r\nnvt->cr_efir = CR_EFIR2;\r\nnvt->cr_efdr = CR_EFDR2;\r\nnvt_efm_enable(nvt);\r\nnvt->chip_major = nvt_cr_read(nvt, CR_CHIP_ID_HI);\r\n}\r\nnvt->chip_minor = nvt_cr_read(nvt, CR_CHIP_ID_LO);\r\nnvt_efm_disable(nvt);\r\nchip_id = nvt->chip_major << 8 | nvt->chip_minor;\r\nif (chip_id == NVT_INVALID) {\r\ndev_err(&nvt->pdev->dev,\r\n"No device found on either EFM port\n");\r\nreturn -ENODEV;\r\n}\r\nchip_name = nvt_find_chip(nvt, chip_id);\r\nif (!chip_name)\r\ndev_warn(&nvt->pdev->dev,\r\n"unknown chip, id: 0x%02x 0x%02x, it may not work...",\r\nnvt->chip_major, nvt->chip_minor);\r\nelse\r\ndev_info(&nvt->pdev->dev,\r\n"found %s or compatible: chip id: 0x%02x 0x%02x",\r\nchip_name, nvt->chip_major, nvt->chip_minor);\r\nreturn 0;\r\n}\r\nstatic void nvt_cir_ldev_init(struct nvt_dev *nvt)\r\n{\r\nu8 val, psreg, psmask, psval;\r\nif (is_w83667hg(nvt)) {\r\npsreg = CR_MULTIFUNC_PIN_SEL;\r\npsmask = MULTIFUNC_PIN_SEL_MASK;\r\npsval = MULTIFUNC_ENABLE_CIR | MULTIFUNC_ENABLE_CIRWB;\r\n} else {\r\npsreg = CR_OUTPUT_PIN_SEL;\r\npsmask = OUTPUT_PIN_SEL_MASK;\r\npsval = OUTPUT_ENABLE_CIR | OUTPUT_ENABLE_CIRWB;\r\n}\r\nval = nvt_cr_read(nvt, psreg);\r\nval &= psmask;\r\nval |= psval;\r\nnvt_cr_write(nvt, val, psreg);\r\nnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR);\r\nnvt_set_ioaddr(nvt, &nvt->cir_addr);\r\nnvt_cr_write(nvt, nvt->cir_irq, CR_CIR_IRQ_RSRC);\r\nnvt_dbg("CIR initialized, base io port address: 0x%lx, irq: %d",\r\nnvt->cir_addr, nvt->cir_irq);\r\n}\r\nstatic void nvt_cir_wake_ldev_init(struct nvt_dev *nvt)\r\n{\r\nnvt_select_logical_dev(nvt, LOGICAL_DEV_ACPI);\r\nnvt_cr_write(nvt, LOGICAL_DEV_ENABLE, CR_LOGICAL_DEV_EN);\r\nnvt_set_reg_bit(nvt, CIR_WAKE_ENABLE_BIT, CR_ACPI_CIR_WAKE);\r\nnvt_set_reg_bit(nvt, PME_INTR_CIR_PASS_BIT, CR_ACPI_IRQ_EVENTS2);\r\nnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\r\nnvt_set_ioaddr(nvt, &nvt->cir_wake_addr);\r\nnvt_cr_write(nvt, nvt->cir_wake_irq, CR_CIR_IRQ_RSRC);\r\nnvt_dbg("CIR Wake initialized, base io port address: 0x%lx, irq: %d",\r\nnvt->cir_wake_addr, nvt->cir_wake_irq);\r\n}\r\nstatic void nvt_clear_cir_fifo(struct nvt_dev *nvt)\r\n{\r\nu8 val;\r\nval = nvt_cir_reg_read(nvt, CIR_FIFOCON);\r\nnvt_cir_reg_write(nvt, val | CIR_FIFOCON_RXFIFOCLR, CIR_FIFOCON);\r\n}\r\nstatic void nvt_clear_cir_wake_fifo(struct nvt_dev *nvt)\r\n{\r\nu8 val, config;\r\nconfig = nvt_cir_wake_reg_read(nvt, CIR_WAKE_IRCON);\r\nnvt_cir_wake_reg_write(nvt, config & ~CIR_WAKE_IRCON_MODE0,\r\nCIR_WAKE_IRCON);\r\nval = nvt_cir_wake_reg_read(nvt, CIR_WAKE_FIFOCON);\r\nnvt_cir_wake_reg_write(nvt, val | CIR_WAKE_FIFOCON_RXFIFOCLR,\r\nCIR_WAKE_FIFOCON);\r\nnvt_cir_wake_reg_write(nvt, config, CIR_WAKE_IRCON);\r\n}\r\nstatic void nvt_clear_tx_fifo(struct nvt_dev *nvt)\r\n{\r\nu8 val;\r\nval = nvt_cir_reg_read(nvt, CIR_FIFOCON);\r\nnvt_cir_reg_write(nvt, val | CIR_FIFOCON_TXFIFOCLR, CIR_FIFOCON);\r\n}\r\nstatic void nvt_set_cir_iren(struct nvt_dev *nvt)\r\n{\r\nu8 iren;\r\niren = CIR_IREN_RTR | CIR_IREN_PE;\r\nnvt_cir_reg_write(nvt, iren, CIR_IREN);\r\n}\r\nstatic void nvt_cir_regs_init(struct nvt_dev *nvt)\r\n{\r\nnvt_cir_reg_write(nvt, CIR_RX_LIMIT_COUNT >> 8, CIR_SLCH);\r\nnvt_cir_reg_write(nvt, CIR_RX_LIMIT_COUNT & 0xff, CIR_SLCL);\r\nnvt_cir_reg_write(nvt, CIR_FIFOCON_TX_TRIGGER_LEV |\r\nCIR_FIFOCON_RX_TRIGGER_LEV, CIR_FIFOCON);\r\nnvt_cir_reg_write(nvt,\r\nCIR_IRCON_TXEN | CIR_IRCON_RXEN |\r\nCIR_IRCON_RXINV | CIR_IRCON_SAMPLE_PERIOD_SEL,\r\nCIR_IRCON);\r\nnvt_clear_cir_fifo(nvt);\r\nnvt_clear_tx_fifo(nvt);\r\nnvt_cir_reg_write(nvt, 0xff, CIR_IRSTS);\r\nnvt_set_cir_iren(nvt);\r\nnvt_enable_logical_dev(nvt, LOGICAL_DEV_CIR);\r\n}\r\nstatic void nvt_cir_wake_regs_init(struct nvt_dev *nvt)\r\n{\r\nnvt_cir_wake_reg_write(nvt, CIR_WAKE_FIFO_CMP_BYTES,\r\nCIR_WAKE_FIFO_CMP_DEEP);\r\nnvt_cir_wake_reg_write(nvt, CIR_WAKE_CMP_TOLERANCE,\r\nCIR_WAKE_FIFO_CMP_TOL);\r\nnvt_cir_wake_reg_write(nvt, CIR_RX_LIMIT_COUNT >> 8, CIR_WAKE_SLCH);\r\nnvt_cir_wake_reg_write(nvt, CIR_RX_LIMIT_COUNT & 0xff, CIR_WAKE_SLCL);\r\nnvt_cir_wake_reg_write(nvt, CIR_WAKE_FIFOCON_RX_TRIGGER_LEV,\r\nCIR_WAKE_FIFOCON);\r\nnvt_cir_wake_reg_write(nvt, CIR_WAKE_IRCON_MODE0 | CIR_WAKE_IRCON_RXEN |\r\nCIR_WAKE_IRCON_R | CIR_WAKE_IRCON_RXINV |\r\nCIR_WAKE_IRCON_SAMPLE_PERIOD_SEL,\r\nCIR_WAKE_IRCON);\r\nnvt_clear_cir_wake_fifo(nvt);\r\nnvt_cir_wake_reg_write(nvt, 0xff, CIR_WAKE_IRSTS);\r\nnvt_enable_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\r\n}\r\nstatic void nvt_enable_wake(struct nvt_dev *nvt)\r\n{\r\nunsigned long flags;\r\nnvt_efm_enable(nvt);\r\nnvt_select_logical_dev(nvt, LOGICAL_DEV_ACPI);\r\nnvt_set_reg_bit(nvt, CIR_WAKE_ENABLE_BIT, CR_ACPI_CIR_WAKE);\r\nnvt_set_reg_bit(nvt, PME_INTR_CIR_PASS_BIT, CR_ACPI_IRQ_EVENTS2);\r\nnvt_select_logical_dev(nvt, LOGICAL_DEV_CIR_WAKE);\r\nnvt_cr_write(nvt, LOGICAL_DEV_ENABLE, CR_LOGICAL_DEV_EN);\r\nnvt_efm_disable(nvt);\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nnvt_cir_wake_reg_write(nvt, CIR_WAKE_IRCON_MODE0 | CIR_WAKE_IRCON_RXEN |\r\nCIR_WAKE_IRCON_R | CIR_WAKE_IRCON_RXINV |\r\nCIR_WAKE_IRCON_SAMPLE_PERIOD_SEL,\r\nCIR_WAKE_IRCON);\r\nnvt_cir_wake_reg_write(nvt, 0xff, CIR_WAKE_IRSTS);\r\nnvt_cir_wake_reg_write(nvt, 0, CIR_WAKE_IREN);\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\n}\r\nstatic int nvt_set_tx_carrier(struct rc_dev *dev, u32 carrier)\r\n{\r\nstruct nvt_dev *nvt = dev->priv;\r\nu16 val;\r\nif (carrier == 0)\r\nreturn -EINVAL;\r\nnvt_cir_reg_write(nvt, 1, CIR_CP);\r\nval = 3000000 / (carrier) - 1;\r\nnvt_cir_reg_write(nvt, val & 0xff, CIR_CC);\r\nnvt_dbg("cp: 0x%x cc: 0x%x\n",\r\nnvt_cir_reg_read(nvt, CIR_CP), nvt_cir_reg_read(nvt, CIR_CC));\r\nreturn 0;\r\n}\r\nstatic int nvt_tx_ir(struct rc_dev *dev, unsigned *txbuf, unsigned n)\r\n{\r\nstruct nvt_dev *nvt = dev->priv;\r\nunsigned long flags;\r\nunsigned int i;\r\nu8 iren;\r\nint ret;\r\nspin_lock_irqsave(&nvt->tx.lock, flags);\r\nret = min((unsigned)(TX_BUF_LEN / sizeof(unsigned)), n);\r\nnvt->tx.buf_count = (ret * sizeof(unsigned));\r\nmemcpy(nvt->tx.buf, txbuf, nvt->tx.buf_count);\r\nnvt->tx.cur_buf_num = 0;\r\niren = nvt_cir_reg_read(nvt, CIR_IREN);\r\nnvt_cir_reg_write(nvt, CIR_IREN_TFU | CIR_IREN_TTR, CIR_IREN);\r\nnvt->tx.tx_state = ST_TX_REPLY;\r\nnvt_cir_reg_write(nvt, CIR_FIFOCON_TX_TRIGGER_LEV_8 |\r\nCIR_FIFOCON_RXFIFOCLR, CIR_FIFOCON);\r\nfor (i = 0; i < 9; i++)\r\nnvt_cir_reg_write(nvt, 0x01, CIR_STXFIFO);\r\nspin_unlock_irqrestore(&nvt->tx.lock, flags);\r\nwait_event(nvt->tx.queue, nvt->tx.tx_state == ST_TX_REQUEST);\r\nspin_lock_irqsave(&nvt->tx.lock, flags);\r\nnvt->tx.tx_state = ST_TX_NONE;\r\nspin_unlock_irqrestore(&nvt->tx.lock, flags);\r\nnvt_cir_reg_write(nvt, iren, CIR_IREN);\r\nreturn ret;\r\n}\r\nstatic void nvt_dump_rx_buf(struct nvt_dev *nvt)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "%s (len %d): ", __func__, nvt->pkts);\r\nfor (i = 0; (i < nvt->pkts) && (i < RX_BUF_LEN); i++)\r\nprintk(KERN_CONT "0x%02x ", nvt->buf[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void nvt_process_rx_ir_data(struct nvt_dev *nvt)\r\n{\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nu8 sample;\r\nint i;\r\nnvt_dbg_verbose("%s firing", __func__);\r\nif (debug)\r\nnvt_dump_rx_buf(nvt);\r\nnvt_dbg_verbose("Processing buffer of len %d", nvt->pkts);\r\ninit_ir_raw_event(&rawir);\r\nfor (i = 0; i < nvt->pkts; i++) {\r\nsample = nvt->buf[i];\r\nrawir.pulse = ((sample & BUF_PULSE_BIT) != 0);\r\nrawir.duration = US_TO_NS((sample & BUF_LEN_MASK)\r\n* SAMPLE_PERIOD);\r\nnvt_dbg("Storing %s with duration %d",\r\nrawir.pulse ? "pulse" : "space", rawir.duration);\r\nir_raw_event_store_with_filter(nvt->rdev, &rawir);\r\nif ((sample == BUF_PULSE_BIT) && (i + 1 < nvt->pkts)) {\r\nnvt_dbg("Calling ir_raw_event_handle (signal end)\n");\r\nir_raw_event_handle(nvt->rdev);\r\n}\r\n}\r\nnvt->pkts = 0;\r\nnvt_dbg("Calling ir_raw_event_handle (buffer empty)\n");\r\nir_raw_event_handle(nvt->rdev);\r\nnvt_dbg_verbose("%s done", __func__);\r\n}\r\nstatic void nvt_handle_rx_fifo_overrun(struct nvt_dev *nvt)\r\n{\r\ndev_warn(&nvt->pdev->dev, "RX FIFO overrun detected, flushing data!");\r\nnvt->pkts = 0;\r\nnvt_clear_cir_fifo(nvt);\r\nir_raw_event_reset(nvt->rdev);\r\n}\r\nstatic void nvt_get_rx_ir_data(struct nvt_dev *nvt)\r\n{\r\nu8 fifocount, val;\r\nunsigned int b_idx;\r\nbool overrun = false;\r\nint i;\r\nfifocount = nvt_cir_reg_read(nvt, CIR_RXFCONT);\r\nif (fifocount == 0xff)\r\nreturn;\r\nelse if (fifocount > RX_BUF_LEN) {\r\noverrun = true;\r\nfifocount = RX_BUF_LEN;\r\n}\r\nnvt_dbg("attempting to fetch %u bytes from hw rx fifo", fifocount);\r\nb_idx = nvt->pkts;\r\nif (b_idx + fifocount > RX_BUF_LEN) {\r\nnvt_process_rx_ir_data(nvt);\r\nb_idx = 0;\r\n}\r\nfor (i = 0; i < fifocount; i++) {\r\nval = nvt_cir_reg_read(nvt, CIR_SRXFIFO);\r\nnvt->buf[b_idx + i] = val;\r\n}\r\nnvt->pkts += fifocount;\r\nnvt_dbg("%s: pkts now %d", __func__, nvt->pkts);\r\nnvt_process_rx_ir_data(nvt);\r\nif (overrun)\r\nnvt_handle_rx_fifo_overrun(nvt);\r\n}\r\nstatic void nvt_cir_log_irqs(u8 status, u8 iren)\r\n{\r\nnvt_dbg("IRQ 0x%02x (IREN 0x%02x) :%s%s%s%s%s%s%s%s%s",\r\nstatus, iren,\r\nstatus & CIR_IRSTS_RDR ? " RDR" : "",\r\nstatus & CIR_IRSTS_RTR ? " RTR" : "",\r\nstatus & CIR_IRSTS_PE ? " PE" : "",\r\nstatus & CIR_IRSTS_RFO ? " RFO" : "",\r\nstatus & CIR_IRSTS_TE ? " TE" : "",\r\nstatus & CIR_IRSTS_TTR ? " TTR" : "",\r\nstatus & CIR_IRSTS_TFU ? " TFU" : "",\r\nstatus & CIR_IRSTS_GH ? " GH" : "",\r\nstatus & ~(CIR_IRSTS_RDR | CIR_IRSTS_RTR | CIR_IRSTS_PE |\r\nCIR_IRSTS_RFO | CIR_IRSTS_TE | CIR_IRSTS_TTR |\r\nCIR_IRSTS_TFU | CIR_IRSTS_GH) ? " ?" : "");\r\n}\r\nstatic bool nvt_cir_tx_inactive(struct nvt_dev *nvt)\r\n{\r\nunsigned long flags;\r\nu8 tx_state;\r\nspin_lock_irqsave(&nvt->tx.lock, flags);\r\ntx_state = nvt->tx.tx_state;\r\nspin_unlock_irqrestore(&nvt->tx.lock, flags);\r\nreturn tx_state == ST_TX_NONE;\r\n}\r\nstatic irqreturn_t nvt_cir_isr(int irq, void *data)\r\n{\r\nstruct nvt_dev *nvt = data;\r\nu8 status, iren, cur_state;\r\nunsigned long flags;\r\nnvt_dbg_verbose("%s firing", __func__);\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nstatus = nvt_cir_reg_read(nvt, CIR_IRSTS);\r\niren = nvt_cir_reg_read(nvt, CIR_IREN);\r\nif (!(status & iren)) {\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nnvt_dbg_verbose("%s exiting, IRSTS 0x0", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nnvt_cir_reg_write(nvt, status, CIR_IRSTS);\r\nnvt_cir_reg_write(nvt, 0, CIR_IRSTS);\r\nnvt_cir_log_irqs(status, iren);\r\nif (status & CIR_IRSTS_RTR) {\r\nif (nvt_cir_tx_inactive(nvt))\r\nnvt_get_rx_ir_data(nvt);\r\n}\r\nif (status & CIR_IRSTS_PE) {\r\nif (nvt_cir_tx_inactive(nvt))\r\nnvt_get_rx_ir_data(nvt);\r\ncur_state = nvt->study_state;\r\nif (cur_state == ST_STUDY_NONE)\r\nnvt_clear_cir_fifo(nvt);\r\n}\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nif (status & CIR_IRSTS_TE)\r\nnvt_clear_tx_fifo(nvt);\r\nif (status & CIR_IRSTS_TTR) {\r\nunsigned int pos, count;\r\nu8 tmp;\r\nspin_lock_irqsave(&nvt->tx.lock, flags);\r\npos = nvt->tx.cur_buf_num;\r\ncount = nvt->tx.buf_count;\r\nif (pos < count) {\r\nnvt_cir_reg_write(nvt, nvt->tx.buf[pos], CIR_STXFIFO);\r\nnvt->tx.cur_buf_num++;\r\n} else {\r\ntmp = nvt_cir_reg_read(nvt, CIR_IREN);\r\nnvt_cir_reg_write(nvt, tmp & ~CIR_IREN_TTR, CIR_IREN);\r\n}\r\nspin_unlock_irqrestore(&nvt->tx.lock, flags);\r\n}\r\nif (status & CIR_IRSTS_TFU) {\r\nspin_lock_irqsave(&nvt->tx.lock, flags);\r\nif (nvt->tx.tx_state == ST_TX_REPLY) {\r\nnvt->tx.tx_state = ST_TX_REQUEST;\r\nwake_up(&nvt->tx.queue);\r\n}\r\nspin_unlock_irqrestore(&nvt->tx.lock, flags);\r\n}\r\nnvt_dbg_verbose("%s done", __func__);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t nvt_cir_wake_isr(int irq, void *data)\r\n{\r\nu8 status, iren, val;\r\nstruct nvt_dev *nvt = data;\r\nunsigned long flags;\r\nnvt_dbg_wake("%s firing", __func__);\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nstatus = nvt_cir_wake_reg_read(nvt, CIR_WAKE_IRSTS);\r\niren = nvt_cir_wake_reg_read(nvt, CIR_WAKE_IREN);\r\nif (!(status & iren)) {\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (status & CIR_WAKE_IRSTS_IR_PENDING)\r\nnvt_clear_cir_wake_fifo(nvt);\r\nnvt_cir_wake_reg_write(nvt, status, CIR_WAKE_IRSTS);\r\nnvt_cir_wake_reg_write(nvt, 0, CIR_WAKE_IRSTS);\r\nif ((status & CIR_WAKE_IRSTS_PE) &&\r\n(nvt->wake_state == ST_WAKE_START)) {\r\nwhile (nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY_IDX)) {\r\nval = nvt_cir_wake_reg_read(nvt, CIR_WAKE_RD_FIFO_ONLY);\r\nnvt_dbg("setting wake up key: 0x%x", val);\r\n}\r\nnvt_cir_wake_reg_write(nvt, 0, CIR_WAKE_IREN);\r\nnvt->wake_state = ST_WAKE_FINISH;\r\n}\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nnvt_dbg_wake("%s done", __func__);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void nvt_disable_cir(struct nvt_dev *nvt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nnvt_cir_reg_write(nvt, 0, CIR_IREN);\r\nnvt_cir_reg_write(nvt, 0xff, CIR_IRSTS);\r\nnvt_cir_reg_write(nvt, 0, CIR_IRCON);\r\nnvt_clear_cir_fifo(nvt);\r\nnvt_clear_tx_fifo(nvt);\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nnvt_disable_logical_dev(nvt, LOGICAL_DEV_CIR);\r\n}\r\nstatic int nvt_open(struct rc_dev *dev)\r\n{\r\nstruct nvt_dev *nvt = dev->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nnvt_cir_reg_write(nvt, CIR_IRCON_TXEN | CIR_IRCON_RXEN |\r\nCIR_IRCON_RXINV | CIR_IRCON_SAMPLE_PERIOD_SEL,\r\nCIR_IRCON);\r\nnvt_cir_reg_write(nvt, 0xff, CIR_IRSTS);\r\nnvt_set_cir_iren(nvt);\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nnvt_enable_logical_dev(nvt, LOGICAL_DEV_CIR);\r\nreturn 0;\r\n}\r\nstatic void nvt_close(struct rc_dev *dev)\r\n{\r\nstruct nvt_dev *nvt = dev->priv;\r\nnvt_disable_cir(nvt);\r\n}\r\nstatic int nvt_probe(struct pnp_dev *pdev, const struct pnp_device_id *dev_id)\r\n{\r\nstruct nvt_dev *nvt;\r\nstruct rc_dev *rdev;\r\nint ret = -ENOMEM;\r\nnvt = devm_kzalloc(&pdev->dev, sizeof(struct nvt_dev), GFP_KERNEL);\r\nif (!nvt)\r\nreturn ret;\r\nrdev = rc_allocate_device();\r\nif (!rdev)\r\ngoto exit_free_dev_rdev;\r\nret = -ENODEV;\r\nif (pnp_activate_dev(pdev) < 0) {\r\ndev_err(&pdev->dev, "Could not activate PNP device!\n");\r\ngoto exit_free_dev_rdev;\r\n}\r\nif (!pnp_port_valid(pdev, 0) ||\r\npnp_port_len(pdev, 0) < CIR_IOREG_LENGTH) {\r\ndev_err(&pdev->dev, "IR PNP Port not valid!\n");\r\ngoto exit_free_dev_rdev;\r\n}\r\nif (!pnp_irq_valid(pdev, 0)) {\r\ndev_err(&pdev->dev, "PNP IRQ not valid!\n");\r\ngoto exit_free_dev_rdev;\r\n}\r\nif (!pnp_port_valid(pdev, 1) ||\r\npnp_port_len(pdev, 1) < CIR_IOREG_LENGTH) {\r\ndev_err(&pdev->dev, "Wake PNP Port not valid!\n");\r\ngoto exit_free_dev_rdev;\r\n}\r\nnvt->cir_addr = pnp_port_start(pdev, 0);\r\nnvt->cir_irq = pnp_irq(pdev, 0);\r\nnvt->cir_wake_addr = pnp_port_start(pdev, 1);\r\nnvt->cir_wake_irq = nvt->cir_irq;\r\nnvt->cr_efir = CR_EFIR;\r\nnvt->cr_efdr = CR_EFDR;\r\nspin_lock_init(&nvt->nvt_lock);\r\nspin_lock_init(&nvt->tx.lock);\r\npnp_set_drvdata(pdev, nvt);\r\nnvt->pdev = pdev;\r\ninit_waitqueue_head(&nvt->tx.queue);\r\nret = nvt_hw_detect(nvt);\r\nif (ret)\r\ngoto exit_free_dev_rdev;\r\nnvt_efm_enable(nvt);\r\nnvt_cir_ldev_init(nvt);\r\nnvt_cir_wake_ldev_init(nvt);\r\nnvt_efm_disable(nvt);\r\nnvt_cir_regs_init(nvt);\r\nnvt_cir_wake_regs_init(nvt);\r\nrdev->priv = nvt;\r\nrdev->driver_type = RC_DRIVER_IR_RAW;\r\nrdev->allowed_protocols = RC_BIT_ALL;\r\nrdev->open = nvt_open;\r\nrdev->close = nvt_close;\r\nrdev->tx_ir = nvt_tx_ir;\r\nrdev->s_tx_carrier = nvt_set_tx_carrier;\r\nrdev->input_name = "Nuvoton w836x7hg Infrared Remote Transceiver";\r\nrdev->input_phys = "nuvoton/cir0";\r\nrdev->input_id.bustype = BUS_HOST;\r\nrdev->input_id.vendor = PCI_VENDOR_ID_WINBOND2;\r\nrdev->input_id.product = nvt->chip_major;\r\nrdev->input_id.version = nvt->chip_minor;\r\nrdev->dev.parent = &pdev->dev;\r\nrdev->driver_name = NVT_DRIVER_NAME;\r\nrdev->map_name = RC_MAP_RC6_MCE;\r\nrdev->timeout = MS_TO_NS(100);\r\nrdev->rx_resolution = US_TO_NS(CIR_SAMPLE_PERIOD);\r\n#if 0\r\nrdev->min_timeout = XYZ;\r\nrdev->max_timeout = XYZ;\r\nrdev->tx_resolution = XYZ;\r\n#endif\r\nnvt->rdev = rdev;\r\nret = rc_register_device(rdev);\r\nif (ret)\r\ngoto exit_free_dev_rdev;\r\nret = -EBUSY;\r\nif (!devm_request_region(&pdev->dev, nvt->cir_addr,\r\nCIR_IOREG_LENGTH, NVT_DRIVER_NAME))\r\ngoto exit_unregister_device;\r\nif (devm_request_irq(&pdev->dev, nvt->cir_irq, nvt_cir_isr,\r\nIRQF_SHARED, NVT_DRIVER_NAME, (void *)nvt))\r\ngoto exit_unregister_device;\r\nif (!devm_request_region(&pdev->dev, nvt->cir_wake_addr,\r\nCIR_IOREG_LENGTH, NVT_DRIVER_NAME "-wake"))\r\ngoto exit_unregister_device;\r\nif (devm_request_irq(&pdev->dev, nvt->cir_wake_irq,\r\nnvt_cir_wake_isr, IRQF_SHARED,\r\nNVT_DRIVER_NAME "-wake", (void *)nvt))\r\ngoto exit_unregister_device;\r\nret = device_create_file(&rdev->dev, &dev_attr_wakeup_data);\r\nif (ret)\r\ngoto exit_unregister_device;\r\ndevice_init_wakeup(&pdev->dev, true);\r\ndev_notice(&pdev->dev, "driver has been successfully loaded\n");\r\nif (debug) {\r\ncir_dump_regs(nvt);\r\ncir_wake_dump_regs(nvt);\r\n}\r\nreturn 0;\r\nexit_unregister_device:\r\nrc_unregister_device(rdev);\r\nrdev = NULL;\r\nexit_free_dev_rdev:\r\nrc_free_device(rdev);\r\nreturn ret;\r\n}\r\nstatic void nvt_remove(struct pnp_dev *pdev)\r\n{\r\nstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\r\ndevice_remove_file(&nvt->rdev->dev, &dev_attr_wakeup_data);\r\nnvt_disable_cir(nvt);\r\nnvt_enable_wake(nvt);\r\nrc_unregister_device(nvt->rdev);\r\n}\r\nstatic int nvt_suspend(struct pnp_dev *pdev, pm_message_t state)\r\n{\r\nstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\r\nunsigned long flags;\r\nnvt_dbg("%s called", __func__);\r\nspin_lock_irqsave(&nvt->tx.lock, flags);\r\nnvt->tx.tx_state = ST_TX_NONE;\r\nspin_unlock_irqrestore(&nvt->tx.lock, flags);\r\nspin_lock_irqsave(&nvt->nvt_lock, flags);\r\nnvt->study_state = ST_STUDY_NONE;\r\nnvt->wake_state = ST_WAKE_NONE;\r\nnvt_cir_reg_write(nvt, 0, CIR_IREN);\r\nspin_unlock_irqrestore(&nvt->nvt_lock, flags);\r\nnvt_disable_logical_dev(nvt, LOGICAL_DEV_CIR);\r\nnvt_enable_wake(nvt);\r\nreturn 0;\r\n}\r\nstatic int nvt_resume(struct pnp_dev *pdev)\r\n{\r\nstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\r\nnvt_dbg("%s called", __func__);\r\nnvt_cir_regs_init(nvt);\r\nnvt_cir_wake_regs_init(nvt);\r\nreturn 0;\r\n}\r\nstatic void nvt_shutdown(struct pnp_dev *pdev)\r\n{\r\nstruct nvt_dev *nvt = pnp_get_drvdata(pdev);\r\nnvt_enable_wake(nvt);\r\n}
