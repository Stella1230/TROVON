static void *not_configged_init(char *str, int device,\r\nconst struct chan_opts *opts)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\nreturn NULL;\r\n}\r\nstatic int not_configged_open(int input, int output, int primary, void *data,\r\nchar **dev_out)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void not_configged_close(int fd, void *data)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\n}\r\nstatic int not_configged_read(int fd, char *c_out, void *data)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\nreturn -EIO;\r\n}\r\nstatic int not_configged_write(int fd, const char *buf, int len, void *data)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\nreturn -EIO;\r\n}\r\nstatic int not_configged_console_write(int fd, const char *buf, int len)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\nreturn -EIO;\r\n}\r\nstatic int not_configged_window_size(int fd, void *data, unsigned short *rows,\r\nunsigned short *cols)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void not_configged_free(void *data)\r\n{\r\nprintk(KERN_ERR "Using a channel type which is configured out of "\r\n"UML\n");\r\n}\r\nstatic int open_one_chan(struct chan *chan)\r\n{\r\nint fd, err;\r\nif (chan->opened)\r\nreturn 0;\r\nif (chan->ops->open == NULL)\r\nfd = 0;\r\nelse fd = (*chan->ops->open)(chan->input, chan->output, chan->primary,\r\nchan->data, &chan->dev);\r\nif (fd < 0)\r\nreturn fd;\r\nerr = os_set_fd_block(fd, 0);\r\nif (err) {\r\n(*chan->ops->close)(fd, chan->data);\r\nreturn err;\r\n}\r\nchan->fd = fd;\r\nchan->opened = 1;\r\nreturn 0;\r\n}\r\nstatic int open_chan(struct list_head *chans)\r\n{\r\nstruct list_head *ele;\r\nstruct chan *chan;\r\nint ret, err = 0;\r\nlist_for_each(ele, chans) {\r\nchan = list_entry(ele, struct chan, list);\r\nret = open_one_chan(chan);\r\nif (chan->primary)\r\nerr = ret;\r\n}\r\nreturn err;\r\n}\r\nvoid chan_enable_winch(struct chan *chan, struct tty_port *port)\r\n{\r\nif (chan && chan->primary && chan->ops->winch)\r\nregister_winch(chan->fd, port);\r\n}\r\nstatic void line_timer_cb(struct work_struct *work)\r\n{\r\nstruct line *line = container_of(work, struct line, task.work);\r\nif (!line->throttled)\r\nchan_interrupt(line, line->driver->read_irq);\r\n}\r\nint enable_chan(struct line *line)\r\n{\r\nstruct list_head *ele;\r\nstruct chan *chan;\r\nint err;\r\nINIT_DELAYED_WORK(&line->task, line_timer_cb);\r\nlist_for_each(ele, &line->chan_list) {\r\nchan = list_entry(ele, struct chan, list);\r\nerr = open_one_chan(chan);\r\nif (err) {\r\nif (chan->primary)\r\ngoto out_close;\r\ncontinue;\r\n}\r\nif (chan->enabled)\r\ncontinue;\r\nerr = line_setup_irq(chan->fd, chan->input, chan->output, line,\r\nchan);\r\nif (err)\r\ngoto out_close;\r\nchan->enabled = 1;\r\n}\r\nreturn 0;\r\nout_close:\r\nclose_chan(line);\r\nreturn err;\r\n}\r\nvoid free_irqs(void)\r\n{\r\nstruct chan *chan;\r\nLIST_HEAD(list);\r\nstruct list_head *ele;\r\nunsigned long flags;\r\nspin_lock_irqsave(&irqs_to_free_lock, flags);\r\nlist_splice_init(&irqs_to_free, &list);\r\nspin_unlock_irqrestore(&irqs_to_free_lock, flags);\r\nlist_for_each(ele, &list) {\r\nchan = list_entry(ele, struct chan, free_list);\r\nif (chan->input && chan->enabled)\r\num_free_irq(chan->line->driver->read_irq, chan);\r\nif (chan->output && chan->enabled)\r\num_free_irq(chan->line->driver->write_irq, chan);\r\nchan->enabled = 0;\r\n}\r\n}\r\nstatic void close_one_chan(struct chan *chan, int delay_free_irq)\r\n{\r\nunsigned long flags;\r\nif (!chan->opened)\r\nreturn;\r\nif (delay_free_irq) {\r\nspin_lock_irqsave(&irqs_to_free_lock, flags);\r\nlist_add(&chan->free_list, &irqs_to_free);\r\nspin_unlock_irqrestore(&irqs_to_free_lock, flags);\r\n}\r\nelse {\r\nif (chan->input && chan->enabled)\r\num_free_irq(chan->line->driver->read_irq, chan);\r\nif (chan->output && chan->enabled)\r\num_free_irq(chan->line->driver->write_irq, chan);\r\nchan->enabled = 0;\r\n}\r\nif (chan->ops->close != NULL)\r\n(*chan->ops->close)(chan->fd, chan->data);\r\nchan->opened = 0;\r\nchan->fd = -1;\r\n}\r\nvoid close_chan(struct line *line)\r\n{\r\nstruct chan *chan;\r\nlist_for_each_entry_reverse(chan, &line->chan_list, list) {\r\nclose_one_chan(chan, 0);\r\n}\r\n}\r\nvoid deactivate_chan(struct chan *chan, int irq)\r\n{\r\nif (chan && chan->enabled)\r\ndeactivate_fd(chan->fd, irq);\r\n}\r\nvoid reactivate_chan(struct chan *chan, int irq)\r\n{\r\nif (chan && chan->enabled)\r\nreactivate_fd(chan->fd, irq);\r\n}\r\nint write_chan(struct chan *chan, const char *buf, int len,\r\nint write_irq)\r\n{\r\nint n, ret = 0;\r\nif (len == 0 || !chan || !chan->ops->write)\r\nreturn 0;\r\nn = chan->ops->write(chan->fd, buf, len, chan->data);\r\nif (chan->primary) {\r\nret = n;\r\nif ((ret == -EAGAIN) || ((ret >= 0) && (ret < len)))\r\nreactivate_fd(chan->fd, write_irq);\r\n}\r\nreturn ret;\r\n}\r\nint console_write_chan(struct chan *chan, const char *buf, int len)\r\n{\r\nint n, ret = 0;\r\nif (!chan || !chan->ops->console_write)\r\nreturn 0;\r\nn = chan->ops->console_write(chan->fd, buf, len);\r\nif (chan->primary)\r\nret = n;\r\nreturn ret;\r\n}\r\nint console_open_chan(struct line *line, struct console *co)\r\n{\r\nint err;\r\nerr = open_chan(&line->chan_list);\r\nif (err)\r\nreturn err;\r\nprintk(KERN_INFO "Console initialized on /dev/%s%d\n", co->name,\r\nco->index);\r\nreturn 0;\r\n}\r\nint chan_window_size(struct line *line, unsigned short *rows_out,\r\nunsigned short *cols_out)\r\n{\r\nstruct chan *chan;\r\nchan = line->chan_in;\r\nif (chan && chan->primary) {\r\nif (chan->ops->window_size == NULL)\r\nreturn 0;\r\nreturn chan->ops->window_size(chan->fd, chan->data,\r\nrows_out, cols_out);\r\n}\r\nchan = line->chan_out;\r\nif (chan && chan->primary) {\r\nif (chan->ops->window_size == NULL)\r\nreturn 0;\r\nreturn chan->ops->window_size(chan->fd, chan->data,\r\nrows_out, cols_out);\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_one_chan(struct chan *chan)\r\n{\r\nlist_del(&chan->list);\r\nclose_one_chan(chan, 0);\r\nif (chan->ops->free != NULL)\r\n(*chan->ops->free)(chan->data);\r\nif (chan->primary && chan->output)\r\nignore_sigio_fd(chan->fd);\r\nkfree(chan);\r\n}\r\nstatic void free_chan(struct list_head *chans)\r\n{\r\nstruct list_head *ele, *next;\r\nstruct chan *chan;\r\nlist_for_each_safe(ele, next, chans) {\r\nchan = list_entry(ele, struct chan, list);\r\nfree_one_chan(chan);\r\n}\r\n}\r\nstatic int one_chan_config_string(struct chan *chan, char *str, int size,\r\nchar **error_out)\r\n{\r\nint n = 0;\r\nif (chan == NULL) {\r\nCONFIG_CHUNK(str, size, n, "none", 1);\r\nreturn n;\r\n}\r\nCONFIG_CHUNK(str, size, n, chan->ops->type, 0);\r\nif (chan->dev == NULL) {\r\nCONFIG_CHUNK(str, size, n, "", 1);\r\nreturn n;\r\n}\r\nCONFIG_CHUNK(str, size, n, ":", 0);\r\nCONFIG_CHUNK(str, size, n, chan->dev, 0);\r\nreturn n;\r\n}\r\nstatic int chan_pair_config_string(struct chan *in, struct chan *out,\r\nchar *str, int size, char **error_out)\r\n{\r\nint n;\r\nn = one_chan_config_string(in, str, size, error_out);\r\nstr += n;\r\nsize -= n;\r\nif (in == out) {\r\nCONFIG_CHUNK(str, size, n, "", 1);\r\nreturn n;\r\n}\r\nCONFIG_CHUNK(str, size, n, ",", 1);\r\nn = one_chan_config_string(out, str, size, error_out);\r\nstr += n;\r\nsize -= n;\r\nCONFIG_CHUNK(str, size, n, "", 1);\r\nreturn n;\r\n}\r\nint chan_config_string(struct line *line, char *str, int size,\r\nchar **error_out)\r\n{\r\nstruct chan *in = line->chan_in, *out = line->chan_out;\r\nif (in && !in->primary)\r\nin = NULL;\r\nif (out && !out->primary)\r\nout = NULL;\r\nreturn chan_pair_config_string(in, out, str, size, error_out);\r\n}\r\nstatic struct chan *parse_chan(struct line *line, char *str, int device,\r\nconst struct chan_opts *opts, char **error_out)\r\n{\r\nconst struct chan_type *entry;\r\nconst struct chan_ops *ops;\r\nstruct chan *chan;\r\nvoid *data;\r\nint i;\r\nops = NULL;\r\ndata = NULL;\r\nfor(i = 0; i < ARRAY_SIZE(chan_table); i++) {\r\nentry = &chan_table[i];\r\nif (!strncmp(str, entry->key, strlen(entry->key))) {\r\nops = entry->ops;\r\nstr += strlen(entry->key);\r\nbreak;\r\n}\r\n}\r\nif (ops == NULL) {\r\n*error_out = "No match for configured backends";\r\nreturn NULL;\r\n}\r\ndata = (*ops->init)(str, device, opts);\r\nif (data == NULL) {\r\n*error_out = "Configuration failed";\r\nreturn NULL;\r\n}\r\nchan = kmalloc(sizeof(*chan), GFP_ATOMIC);\r\nif (chan == NULL) {\r\n*error_out = "Memory allocation failed";\r\nreturn NULL;\r\n}\r\n*chan = ((struct chan) { .list = LIST_HEAD_INIT(chan->list),\r\n.free_list =\r\nLIST_HEAD_INIT(chan->free_list),\r\n.line = line,\r\n.primary = 1,\r\n.input = 0,\r\n.output = 0,\r\n.opened = 0,\r\n.enabled = 0,\r\n.fd = -1,\r\n.ops = ops,\r\n.data = data });\r\nreturn chan;\r\n}\r\nint parse_chan_pair(char *str, struct line *line, int device,\r\nconst struct chan_opts *opts, char **error_out)\r\n{\r\nstruct list_head *chans = &line->chan_list;\r\nstruct chan *new;\r\nchar *in, *out;\r\nif (!list_empty(chans)) {\r\nline->chan_in = line->chan_out = NULL;\r\nfree_chan(chans);\r\nINIT_LIST_HEAD(chans);\r\n}\r\nif (!str)\r\nreturn 0;\r\nout = strchr(str, ',');\r\nif (out != NULL) {\r\nin = str;\r\n*out = '\0';\r\nout++;\r\nnew = parse_chan(line, in, device, opts, error_out);\r\nif (new == NULL)\r\nreturn -1;\r\nnew->input = 1;\r\nlist_add(&new->list, chans);\r\nline->chan_in = new;\r\nnew = parse_chan(line, out, device, opts, error_out);\r\nif (new == NULL)\r\nreturn -1;\r\nlist_add(&new->list, chans);\r\nnew->output = 1;\r\nline->chan_out = new;\r\n}\r\nelse {\r\nnew = parse_chan(line, str, device, opts, error_out);\r\nif (new == NULL)\r\nreturn -1;\r\nlist_add(&new->list, chans);\r\nnew->input = 1;\r\nnew->output = 1;\r\nline->chan_in = line->chan_out = new;\r\n}\r\nreturn 0;\r\n}\r\nvoid chan_interrupt(struct line *line, int irq)\r\n{\r\nstruct tty_port *port = &line->port;\r\nstruct chan *chan = line->chan_in;\r\nint err;\r\nchar c;\r\nif (!chan || !chan->ops->read)\r\ngoto out;\r\ndo {\r\nif (!tty_buffer_request_room(port, 1)) {\r\nschedule_delayed_work(&line->task, 1);\r\ngoto out;\r\n}\r\nerr = chan->ops->read(chan->fd, &c, chan->data);\r\nif (err > 0)\r\ntty_insert_flip_char(port, c, TTY_NORMAL);\r\n} while (err > 0);\r\nif (err == 0)\r\nreactivate_fd(chan->fd, irq);\r\nif (err == -EIO) {\r\nif (chan->primary) {\r\ntty_port_tty_hangup(&line->port, false);\r\nif (line->chan_out != chan)\r\nclose_one_chan(line->chan_out, 1);\r\n}\r\nclose_one_chan(chan, 1);\r\nif (chan->primary)\r\nreturn;\r\n}\r\nout:\r\ntty_flip_buffer_push(port);\r\n}
