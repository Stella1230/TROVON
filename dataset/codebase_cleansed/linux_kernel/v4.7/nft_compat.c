static int nft_compat_chain_validate_dependency(const char *tablename,\r\nconst struct nft_chain *chain)\r\n{\r\nconst struct nft_base_chain *basechain;\r\nif (!tablename || !(chain->flags & NFT_BASE_CHAIN))\r\nreturn 0;\r\nbasechain = nft_base_chain(chain);\r\nif (strcmp(tablename, "nat") == 0 &&\r\nbasechain->type->type != NFT_CHAIN_T_NAT)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nnft_compat_set_par(struct xt_action_param *par, void *xt, const void *xt_info)\r\n{\r\npar->target = xt;\r\npar->targinfo = xt_info;\r\npar->hotdrop = false;\r\n}\r\nstatic void nft_target_eval_xt(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_target *target = expr->ops->data;\r\nstruct sk_buff *skb = pkt->skb;\r\nint ret;\r\nnft_compat_set_par((struct xt_action_param *)&pkt->xt, target, info);\r\nret = target->target(skb, &pkt->xt);\r\nif (pkt->xt.hotdrop)\r\nret = NF_DROP;\r\nswitch (ret) {\r\ncase XT_CONTINUE:\r\nregs->verdict.code = NFT_CONTINUE;\r\nbreak;\r\ndefault:\r\nregs->verdict.code = ret;\r\nbreak;\r\n}\r\n}\r\nstatic void nft_target_eval_bridge(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_target *target = expr->ops->data;\r\nstruct sk_buff *skb = pkt->skb;\r\nint ret;\r\nnft_compat_set_par((struct xt_action_param *)&pkt->xt, target, info);\r\nret = target->target(skb, &pkt->xt);\r\nif (pkt->xt.hotdrop)\r\nret = NF_DROP;\r\nswitch (ret) {\r\ncase EBT_ACCEPT:\r\nregs->verdict.code = NF_ACCEPT;\r\nbreak;\r\ncase EBT_DROP:\r\nregs->verdict.code = NF_DROP;\r\nbreak;\r\ncase EBT_CONTINUE:\r\nregs->verdict.code = NFT_CONTINUE;\r\nbreak;\r\ncase EBT_RETURN:\r\nregs->verdict.code = NFT_RETURN;\r\nbreak;\r\ndefault:\r\nregs->verdict.code = ret;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nnft_target_set_tgchk_param(struct xt_tgchk_param *par,\r\nconst struct nft_ctx *ctx,\r\nstruct xt_target *target, void *info,\r\nunion nft_entry *entry, u16 proto, bool inv)\r\n{\r\npar->net = ctx->net;\r\npar->table = ctx->table->name;\r\nswitch (ctx->afi->family) {\r\ncase AF_INET:\r\nentry->e4.ip.proto = proto;\r\nentry->e4.ip.invflags = inv ? IPT_INV_PROTO : 0;\r\nbreak;\r\ncase AF_INET6:\r\nif (proto)\r\nentry->e6.ipv6.flags |= IP6T_F_PROTO;\r\nentry->e6.ipv6.proto = proto;\r\nentry->e6.ipv6.invflags = inv ? IP6T_INV_PROTO : 0;\r\nbreak;\r\ncase NFPROTO_BRIDGE:\r\nentry->ebt.ethproto = (__force __be16)proto;\r\nentry->ebt.invflags = inv ? EBT_IPROTO : 0;\r\nbreak;\r\ncase NFPROTO_ARP:\r\nbreak;\r\n}\r\npar->entryinfo = entry;\r\npar->target = target;\r\npar->targinfo = info;\r\nif (ctx->chain->flags & NFT_BASE_CHAIN) {\r\nconst struct nft_base_chain *basechain =\r\nnft_base_chain(ctx->chain);\r\nconst struct nf_hook_ops *ops = &basechain->ops[0];\r\npar->hook_mask = 1 << ops->hooknum;\r\n} else {\r\npar->hook_mask = 0;\r\n}\r\npar->family = ctx->afi->family;\r\npar->nft_compat = true;\r\n}\r\nstatic void target_compat_from_user(struct xt_target *t, void *in, void *out)\r\n{\r\nint pad;\r\nmemcpy(out, in, t->targetsize);\r\npad = XT_ALIGN(t->targetsize) - t->targetsize;\r\nif (pad > 0)\r\nmemset(out + t->targetsize, 0, pad);\r\n}\r\nstatic int nft_parse_compat(const struct nlattr *attr, u16 *proto, bool *inv)\r\n{\r\nstruct nlattr *tb[NFTA_RULE_COMPAT_MAX+1];\r\nu32 flags;\r\nint err;\r\nerr = nla_parse_nested(tb, NFTA_RULE_COMPAT_MAX, attr,\r\nnft_rule_compat_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[NFTA_RULE_COMPAT_PROTO] || !tb[NFTA_RULE_COMPAT_FLAGS])\r\nreturn -EINVAL;\r\nflags = ntohl(nla_get_be32(tb[NFTA_RULE_COMPAT_FLAGS]));\r\nif (flags & ~NFT_RULE_COMPAT_F_MASK)\r\nreturn -EINVAL;\r\nif (flags & NFT_RULE_COMPAT_F_INV)\r\n*inv = true;\r\n*proto = ntohl(nla_get_be32(tb[NFTA_RULE_COMPAT_PROTO]));\r\nreturn 0;\r\n}\r\nstatic int\r\nnft_target_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_target *target = expr->ops->data;\r\nstruct xt_tgchk_param par;\r\nsize_t size = XT_ALIGN(nla_len(tb[NFTA_TARGET_INFO]));\r\nu16 proto = 0;\r\nbool inv = false;\r\nunion nft_entry e = {};\r\nint ret;\r\nret = nft_compat_chain_validate_dependency(target->table, ctx->chain);\r\nif (ret < 0)\r\ngoto err;\r\ntarget_compat_from_user(target, nla_data(tb[NFTA_TARGET_INFO]), info);\r\nif (ctx->nla[NFTA_RULE_COMPAT]) {\r\nret = nft_parse_compat(ctx->nla[NFTA_RULE_COMPAT], &proto, &inv);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nnft_target_set_tgchk_param(&par, ctx, target, info, &e, proto, inv);\r\nret = xt_check_target(&par, size, proto, inv);\r\nif (ret < 0)\r\ngoto err;\r\nif (target->target == NULL) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nmodule_put(target->me);\r\nreturn ret;\r\n}\r\nstatic void\r\nnft_target_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\r\n{\r\nstruct xt_target *target = expr->ops->data;\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_tgdtor_param par;\r\npar.net = ctx->net;\r\npar.target = target;\r\npar.targinfo = info;\r\npar.family = ctx->afi->family;\r\nif (par.target->destroy != NULL)\r\npar.target->destroy(&par);\r\nmodule_put(target->me);\r\n}\r\nstatic int nft_target_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct xt_target *target = expr->ops->data;\r\nvoid *info = nft_expr_priv(expr);\r\nif (nla_put_string(skb, NFTA_TARGET_NAME, target->name) ||\r\nnla_put_be32(skb, NFTA_TARGET_REV, htonl(target->revision)) ||\r\nnla_put(skb, NFTA_TARGET_INFO, XT_ALIGN(target->targetsize), info))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_target_validate(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nstruct xt_target *target = expr->ops->data;\r\nunsigned int hook_mask = 0;\r\nint ret;\r\nif (ctx->chain->flags & NFT_BASE_CHAIN) {\r\nconst struct nft_base_chain *basechain =\r\nnft_base_chain(ctx->chain);\r\nconst struct nf_hook_ops *ops = &basechain->ops[0];\r\nhook_mask = 1 << ops->hooknum;\r\nif (!(hook_mask & target->hooks))\r\nreturn -EINVAL;\r\nret = nft_compat_chain_validate_dependency(target->table,\r\nctx->chain);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nft_match_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_match *match = expr->ops->data;\r\nstruct sk_buff *skb = pkt->skb;\r\nbool ret;\r\nnft_compat_set_par((struct xt_action_param *)&pkt->xt, match, info);\r\nret = match->match(skb, (struct xt_action_param *)&pkt->xt);\r\nif (pkt->xt.hotdrop) {\r\nregs->verdict.code = NF_DROP;\r\nreturn;\r\n}\r\nswitch (ret ? 1 : 0) {\r\ncase 1:\r\nregs->verdict.code = NFT_CONTINUE;\r\nbreak;\r\ncase 0:\r\nregs->verdict.code = NFT_BREAK;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nnft_match_set_mtchk_param(struct xt_mtchk_param *par, const struct nft_ctx *ctx,\r\nstruct xt_match *match, void *info,\r\nunion nft_entry *entry, u16 proto, bool inv)\r\n{\r\npar->net = ctx->net;\r\npar->table = ctx->table->name;\r\nswitch (ctx->afi->family) {\r\ncase AF_INET:\r\nentry->e4.ip.proto = proto;\r\nentry->e4.ip.invflags = inv ? IPT_INV_PROTO : 0;\r\nbreak;\r\ncase AF_INET6:\r\nif (proto)\r\nentry->e6.ipv6.flags |= IP6T_F_PROTO;\r\nentry->e6.ipv6.proto = proto;\r\nentry->e6.ipv6.invflags = inv ? IP6T_INV_PROTO : 0;\r\nbreak;\r\ncase NFPROTO_BRIDGE:\r\nentry->ebt.ethproto = (__force __be16)proto;\r\nentry->ebt.invflags = inv ? EBT_IPROTO : 0;\r\nbreak;\r\ncase NFPROTO_ARP:\r\nbreak;\r\n}\r\npar->entryinfo = entry;\r\npar->match = match;\r\npar->matchinfo = info;\r\nif (ctx->chain->flags & NFT_BASE_CHAIN) {\r\nconst struct nft_base_chain *basechain =\r\nnft_base_chain(ctx->chain);\r\nconst struct nf_hook_ops *ops = &basechain->ops[0];\r\npar->hook_mask = 1 << ops->hooknum;\r\n} else {\r\npar->hook_mask = 0;\r\n}\r\npar->family = ctx->afi->family;\r\npar->nft_compat = true;\r\n}\r\nstatic void match_compat_from_user(struct xt_match *m, void *in, void *out)\r\n{\r\nint pad;\r\nmemcpy(out, in, m->matchsize);\r\npad = XT_ALIGN(m->matchsize) - m->matchsize;\r\nif (pad > 0)\r\nmemset(out + m->matchsize, 0, pad);\r\n}\r\nstatic int\r\nnft_match_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_match *match = expr->ops->data;\r\nstruct xt_mtchk_param par;\r\nsize_t size = XT_ALIGN(nla_len(tb[NFTA_MATCH_INFO]));\r\nu16 proto = 0;\r\nbool inv = false;\r\nunion nft_entry e = {};\r\nint ret;\r\nret = nft_compat_chain_validate_dependency(match->table, ctx->chain);\r\nif (ret < 0)\r\ngoto err;\r\nmatch_compat_from_user(match, nla_data(tb[NFTA_MATCH_INFO]), info);\r\nif (ctx->nla[NFTA_RULE_COMPAT]) {\r\nret = nft_parse_compat(ctx->nla[NFTA_RULE_COMPAT], &proto, &inv);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nnft_match_set_mtchk_param(&par, ctx, match, info, &e, proto, inv);\r\nret = xt_check_match(&par, size, proto, inv);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nmodule_put(match->me);\r\nreturn ret;\r\n}\r\nstatic void\r\nnft_match_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)\r\n{\r\nstruct xt_match *match = expr->ops->data;\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_mtdtor_param par;\r\npar.net = ctx->net;\r\npar.match = match;\r\npar.matchinfo = info;\r\npar.family = ctx->afi->family;\r\nif (par.match->destroy != NULL)\r\npar.match->destroy(&par);\r\nmodule_put(match->me);\r\n}\r\nstatic int nft_match_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nvoid *info = nft_expr_priv(expr);\r\nstruct xt_match *match = expr->ops->data;\r\nif (nla_put_string(skb, NFTA_MATCH_NAME, match->name) ||\r\nnla_put_be32(skb, NFTA_MATCH_REV, htonl(match->revision)) ||\r\nnla_put(skb, NFTA_MATCH_INFO, XT_ALIGN(match->matchsize), info))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_match_validate(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nstruct xt_match *match = expr->ops->data;\r\nunsigned int hook_mask = 0;\r\nint ret;\r\nif (ctx->chain->flags & NFT_BASE_CHAIN) {\r\nconst struct nft_base_chain *basechain =\r\nnft_base_chain(ctx->chain);\r\nconst struct nf_hook_ops *ops = &basechain->ops[0];\r\nhook_mask = 1 << ops->hooknum;\r\nif (!(hook_mask & match->hooks))\r\nreturn -EINVAL;\r\nret = nft_compat_chain_validate_dependency(match->table,\r\nctx->chain);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnfnl_compat_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\r\nint event, u16 family, const char *name,\r\nint rev, int target)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0;\r\nevent |= NFNL_SUBSYS_NFT_COMPAT << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_string(skb, NFTA_COMPAT_NAME, name) ||\r\nnla_put_be32(skb, NFTA_COMPAT_REV, htonl(rev)) ||\r\nnla_put_be32(skb, NFTA_COMPAT_TYPE, htonl(target)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int nfnl_compat_get(struct net *net, struct sock *nfnl,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const tb[])\r\n{\r\nint ret = 0, target;\r\nstruct nfgenmsg *nfmsg;\r\nconst char *fmt;\r\nconst char *name;\r\nu32 rev;\r\nstruct sk_buff *skb2;\r\nif (tb[NFTA_COMPAT_NAME] == NULL ||\r\ntb[NFTA_COMPAT_REV] == NULL ||\r\ntb[NFTA_COMPAT_TYPE] == NULL)\r\nreturn -EINVAL;\r\nname = nla_data(tb[NFTA_COMPAT_NAME]);\r\nrev = ntohl(nla_get_be32(tb[NFTA_COMPAT_REV]));\r\ntarget = ntohl(nla_get_be32(tb[NFTA_COMPAT_TYPE]));\r\nnfmsg = nlmsg_data(nlh);\r\nswitch(nfmsg->nfgen_family) {\r\ncase AF_INET:\r\nfmt = "ipt_%s";\r\nbreak;\r\ncase AF_INET6:\r\nfmt = "ip6t_%s";\r\nbreak;\r\ncase NFPROTO_BRIDGE:\r\nfmt = "ebt_%s";\r\nbreak;\r\ncase NFPROTO_ARP:\r\nfmt = "arpt_%s";\r\nbreak;\r\ndefault:\r\npr_err("nft_compat: unsupported protocol %d\n",\r\nnfmsg->nfgen_family);\r\nreturn -EINVAL;\r\n}\r\ntry_then_request_module(xt_find_revision(nfmsg->nfgen_family, name,\r\nrev, target, &ret),\r\nfmt, name);\r\nif (ret < 0)\r\nreturn ret;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nif (nfnl_compat_fill_info(skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type),\r\nNFNL_MSG_COMPAT_GET,\r\nnfmsg->nfgen_family,\r\nname, ret, target) <= 0) {\r\nkfree_skb(skb2);\r\nreturn -ENOSPC;\r\n}\r\nret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,\r\nMSG_DONTWAIT);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret == -EAGAIN ? -ENOBUFS : ret;\r\n}\r\nstatic bool nft_match_cmp(const struct xt_match *match,\r\nconst char *name, u32 rev, u32 family)\r\n{\r\nreturn strcmp(match->name, name) == 0 && match->revision == rev &&\r\n(match->family == NFPROTO_UNSPEC || match->family == family);\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_match_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_xt *nft_match;\r\nstruct xt_match *match;\r\nchar *mt_name;\r\nu32 rev, family;\r\nif (tb[NFTA_MATCH_NAME] == NULL ||\r\ntb[NFTA_MATCH_REV] == NULL ||\r\ntb[NFTA_MATCH_INFO] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nmt_name = nla_data(tb[NFTA_MATCH_NAME]);\r\nrev = ntohl(nla_get_be32(tb[NFTA_MATCH_REV]));\r\nfamily = ctx->afi->family;\r\nlist_for_each_entry(nft_match, &nft_match_list, head) {\r\nstruct xt_match *match = nft_match->ops.data;\r\nif (nft_match_cmp(match, mt_name, rev, family)) {\r\nif (!try_module_get(match->me))\r\nreturn ERR_PTR(-ENOENT);\r\nreturn &nft_match->ops;\r\n}\r\n}\r\nmatch = xt_request_find_match(family, mt_name, rev);\r\nif (IS_ERR(match))\r\nreturn ERR_PTR(-ENOENT);\r\nif (match->matchsize > nla_len(tb[NFTA_MATCH_INFO]))\r\nreturn ERR_PTR(-EINVAL);\r\nnft_match = kzalloc(sizeof(struct nft_xt), GFP_KERNEL);\r\nif (nft_match == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nnft_match->ops.type = &nft_match_type;\r\nnft_match->ops.size = NFT_EXPR_SIZE(XT_ALIGN(match->matchsize));\r\nnft_match->ops.eval = nft_match_eval;\r\nnft_match->ops.init = nft_match_init;\r\nnft_match->ops.destroy = nft_match_destroy;\r\nnft_match->ops.dump = nft_match_dump;\r\nnft_match->ops.validate = nft_match_validate;\r\nnft_match->ops.data = match;\r\nlist_add(&nft_match->head, &nft_match_list);\r\nreturn &nft_match->ops;\r\n}\r\nstatic void nft_match_release(void)\r\n{\r\nstruct nft_xt *nft_match, *tmp;\r\nlist_for_each_entry_safe(nft_match, tmp, &nft_match_list, head)\r\nkfree(nft_match);\r\n}\r\nstatic bool nft_target_cmp(const struct xt_target *tg,\r\nconst char *name, u32 rev, u32 family)\r\n{\r\nreturn strcmp(tg->name, name) == 0 && tg->revision == rev &&\r\n(tg->family == NFPROTO_UNSPEC || tg->family == family);\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_target_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_xt *nft_target;\r\nstruct xt_target *target;\r\nchar *tg_name;\r\nu32 rev, family;\r\nif (tb[NFTA_TARGET_NAME] == NULL ||\r\ntb[NFTA_TARGET_REV] == NULL ||\r\ntb[NFTA_TARGET_INFO] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\ntg_name = nla_data(tb[NFTA_TARGET_NAME]);\r\nrev = ntohl(nla_get_be32(tb[NFTA_TARGET_REV]));\r\nfamily = ctx->afi->family;\r\nlist_for_each_entry(nft_target, &nft_target_list, head) {\r\nstruct xt_target *target = nft_target->ops.data;\r\nif (nft_target_cmp(target, tg_name, rev, family)) {\r\nif (!try_module_get(target->me))\r\nreturn ERR_PTR(-ENOENT);\r\nreturn &nft_target->ops;\r\n}\r\n}\r\ntarget = xt_request_find_target(family, tg_name, rev);\r\nif (IS_ERR(target))\r\nreturn ERR_PTR(-ENOENT);\r\nif (target->targetsize > nla_len(tb[NFTA_TARGET_INFO]))\r\nreturn ERR_PTR(-EINVAL);\r\nnft_target = kzalloc(sizeof(struct nft_xt), GFP_KERNEL);\r\nif (nft_target == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nnft_target->ops.type = &nft_target_type;\r\nnft_target->ops.size = NFT_EXPR_SIZE(XT_ALIGN(target->targetsize));\r\nnft_target->ops.init = nft_target_init;\r\nnft_target->ops.destroy = nft_target_destroy;\r\nnft_target->ops.dump = nft_target_dump;\r\nnft_target->ops.validate = nft_target_validate;\r\nnft_target->ops.data = target;\r\nif (family == NFPROTO_BRIDGE)\r\nnft_target->ops.eval = nft_target_eval_bridge;\r\nelse\r\nnft_target->ops.eval = nft_target_eval_xt;\r\nlist_add(&nft_target->head, &nft_target_list);\r\nreturn &nft_target->ops;\r\n}\r\nstatic void nft_target_release(void)\r\n{\r\nstruct nft_xt *nft_target, *tmp;\r\nlist_for_each_entry_safe(nft_target, tmp, &nft_target_list, head)\r\nkfree(nft_target);\r\n}\r\nstatic int __init nft_compat_module_init(void)\r\n{\r\nint ret;\r\nret = nft_register_expr(&nft_match_type);\r\nif (ret < 0)\r\nreturn ret;\r\nret = nft_register_expr(&nft_target_type);\r\nif (ret < 0)\r\ngoto err_match;\r\nret = nfnetlink_subsys_register(&nfnl_compat_subsys);\r\nif (ret < 0) {\r\npr_err("nft_compat: cannot register with nfnetlink.\n");\r\ngoto err_target;\r\n}\r\npr_info("nf_tables_compat: (c) 2012 Pablo Neira Ayuso <pablo@netfilter.org>\n");\r\nreturn ret;\r\nerr_target:\r\nnft_unregister_expr(&nft_target_type);\r\nerr_match:\r\nnft_unregister_expr(&nft_match_type);\r\nreturn ret;\r\n}\r\nstatic void __exit nft_compat_module_exit(void)\r\n{\r\nnfnetlink_subsys_unregister(&nfnl_compat_subsys);\r\nnft_unregister_expr(&nft_target_type);\r\nnft_unregister_expr(&nft_match_type);\r\nnft_match_release();\r\nnft_target_release();\r\n}
