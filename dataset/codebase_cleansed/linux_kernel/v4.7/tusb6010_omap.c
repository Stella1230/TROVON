static inline int tusb_omap_use_shared_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nif (reg != 0) {\r\ndev_dbg(chdat->musb->controller, "ep%i dmareq0 is busy for ep%i\n",\r\nchdat->epnum, reg & 0xf);\r\nreturn -EAGAIN;\r\n}\r\nif (chdat->tx)\r\nreg = (1 << 4) | chdat->epnum;\r\nelse\r\nreg = chdat->epnum;\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\r\nreturn 0;\r\n}\r\nstatic inline void tusb_omap_free_shared_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nif ((reg & 0xf) != chdat->epnum) {\r\nprintk(KERN_ERR "ep%i trying to release dmareq0 for ep%i\n",\r\nchdat->epnum, reg & 0xf);\r\nreturn;\r\n}\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, 0);\r\n}\r\nstatic void tusb_omap_dma_cb(int lch, u16 ch_status, void *data)\r\n{\r\nstruct dma_channel *channel = (struct dma_channel *)data;\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nstruct tusb_omap_dma *tusb_dma = chdat->tusb_dma;\r\nstruct musb *musb = chdat->musb;\r\nstruct device *dev = musb->controller;\r\nstruct musb_hw_ep *hw_ep = chdat->hw_ep;\r\nvoid __iomem *ep_conf = hw_ep->conf;\r\nvoid __iomem *mbase = musb->mregs;\r\nunsigned long remaining, flags, pio;\r\nint ch;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (tusb_dma->multichannel)\r\nch = chdat->ch;\r\nelse\r\nch = tusb_dma->ch;\r\nif (ch_status != OMAP_DMA_BLOCK_IRQ)\r\nprintk(KERN_ERR "TUSB DMA error status: %i\n", ch_status);\r\ndev_dbg(musb->controller, "ep%i %s dma callback ch: %i status: %x\n",\r\nchdat->epnum, chdat->tx ? "tx" : "rx",\r\nch, ch_status);\r\nif (chdat->tx)\r\nremaining = musb_readl(ep_conf, TUSB_EP_TX_OFFSET);\r\nelse\r\nremaining = musb_readl(ep_conf, TUSB_EP_RX_OFFSET);\r\nremaining = TUSB_EP_CONFIG_XFR_SIZE(remaining);\r\nif (unlikely(remaining > chdat->transfer_len)) {\r\ndev_dbg(musb->controller, "Corrupt %s dma ch%i XFR_SIZE: 0x%08lx\n",\r\nchdat->tx ? "tx" : "rx", chdat->ch,\r\nremaining);\r\nremaining = 0;\r\n}\r\nchannel->actual_len = chdat->transfer_len - remaining;\r\npio = chdat->len - channel->actual_len;\r\ndev_dbg(musb->controller, "DMA remaining %lu/%u\n", remaining, chdat->transfer_len);\r\nif (pio > 0 && pio < 32) {\r\nu8 *buf;\r\ndev_dbg(musb->controller, "Using PIO for remaining %lu bytes\n", pio);\r\nbuf = phys_to_virt((u32)chdat->dma_addr) + chdat->transfer_len;\r\nif (chdat->tx) {\r\ndma_unmap_single(dev, chdat->dma_addr,\r\nchdat->transfer_len,\r\nDMA_TO_DEVICE);\r\nmusb_write_fifo(hw_ep, pio, buf);\r\n} else {\r\ndma_unmap_single(dev, chdat->dma_addr,\r\nchdat->transfer_len,\r\nDMA_FROM_DEVICE);\r\nmusb_read_fifo(hw_ep, pio, buf);\r\n}\r\nchannel->actual_len += pio;\r\n}\r\nif (!tusb_dma->multichannel)\r\ntusb_omap_free_shared_dmareq(chdat);\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nif (!chdat->tx)\r\nmusb_dma_completion(musb, chdat->epnum, chdat->tx);\r\nif ((chdat->transfer_len < chdat->packet_sz)\r\n|| (chdat->transfer_len % chdat->packet_sz != 0)) {\r\nu16 csr;\r\nif (chdat->tx) {\r\ndev_dbg(musb->controller, "terminating short tx packet\n");\r\nmusb_ep_select(mbase, chdat->epnum);\r\ncsr = musb_readw(hw_ep->regs, MUSB_TXCSR);\r\ncsr |= MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY\r\n| MUSB_TXCSR_P_WZC_BITS;\r\nmusb_writew(hw_ep->regs, MUSB_TXCSR, csr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic int tusb_omap_dma_program(struct dma_channel *channel, u16 packet_sz,\r\nu8 rndis_mode, dma_addr_t dma_addr, u32 len)\r\n{\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nstruct tusb_omap_dma *tusb_dma = chdat->tusb_dma;\r\nstruct musb *musb = chdat->musb;\r\nstruct device *dev = musb->controller;\r\nstruct musb_hw_ep *hw_ep = chdat->hw_ep;\r\nvoid __iomem *mbase = musb->mregs;\r\nvoid __iomem *ep_conf = hw_ep->conf;\r\ndma_addr_t fifo = hw_ep->fifo_sync;\r\nstruct omap_dma_channel_params dma_params;\r\nu32 dma_remaining;\r\nint src_burst, dst_burst;\r\nu16 csr;\r\nint ch;\r\ns8 dmareq;\r\ns8 sync_dev;\r\nif (unlikely(dma_addr & 0x1) || (len < 32) || (len > packet_sz))\r\nreturn false;\r\nif (dma_addr & 0x2)\r\nreturn false;\r\nif (chdat->tx)\r\ndma_remaining = musb_readl(ep_conf, TUSB_EP_TX_OFFSET);\r\nelse\r\ndma_remaining = musb_readl(ep_conf, TUSB_EP_RX_OFFSET);\r\ndma_remaining = TUSB_EP_CONFIG_XFR_SIZE(dma_remaining);\r\nif (dma_remaining) {\r\ndev_dbg(musb->controller, "Busy %s dma ch%i, not using: %08x\n",\r\nchdat->tx ? "tx" : "rx", chdat->ch,\r\ndma_remaining);\r\nreturn false;\r\n}\r\nchdat->transfer_len = len & ~0x1f;\r\nif (len < packet_sz)\r\nchdat->transfer_packet_sz = chdat->transfer_len;\r\nelse\r\nchdat->transfer_packet_sz = packet_sz;\r\nif (tusb_dma->multichannel) {\r\nch = chdat->ch;\r\ndmareq = chdat->dmareq;\r\nsync_dev = chdat->sync_dev;\r\n} else {\r\nif (tusb_omap_use_shared_dmareq(chdat) != 0) {\r\ndev_dbg(musb->controller, "could not get dma for ep%i\n", chdat->epnum);\r\nreturn false;\r\n}\r\nif (tusb_dma->ch < 0) {\r\nWARN_ON(1);\r\nreturn false;\r\n}\r\nch = tusb_dma->ch;\r\ndmareq = tusb_dma->dmareq;\r\nsync_dev = tusb_dma->sync_dev;\r\nomap_set_dma_callback(ch, tusb_omap_dma_cb, channel);\r\n}\r\nchdat->packet_sz = packet_sz;\r\nchdat->len = len;\r\nchannel->actual_len = 0;\r\nchdat->dma_addr = dma_addr;\r\nchannel->status = MUSB_DMA_STATUS_BUSY;\r\nif (chdat->tx)\r\ndma_map_single(dev, phys_to_virt(dma_addr), len,\r\nDMA_TO_DEVICE);\r\nelse\r\ndma_map_single(dev, phys_to_virt(dma_addr), len,\r\nDMA_FROM_DEVICE);\r\nif ((dma_addr & 0x3) == 0) {\r\ndma_params.data_type = OMAP_DMA_DATA_TYPE_S32;\r\ndma_params.elem_count = 8;\r\n} else {\r\ndma_params.data_type = OMAP_DMA_DATA_TYPE_S16;\r\ndma_params.elem_count = 16;\r\nfifo = hw_ep->fifo_async;\r\n}\r\ndma_params.frame_count = chdat->transfer_len / 32;\r\ndev_dbg(musb->controller, "ep%i %s dma ch%i dma: %pad len: %u(%u) packet_sz: %i(%i)\n",\r\nchdat->epnum, chdat->tx ? "tx" : "rx",\r\nch, &dma_addr, chdat->transfer_len, len,\r\nchdat->transfer_packet_sz, packet_sz);\r\nif (chdat->tx) {\r\ndma_params.src_amode = OMAP_DMA_AMODE_POST_INC;\r\ndma_params.src_start = (unsigned long)dma_addr;\r\ndma_params.src_ei = 0;\r\ndma_params.src_fi = 0;\r\ndma_params.dst_amode = OMAP_DMA_AMODE_DOUBLE_IDX;\r\ndma_params.dst_start = (unsigned long)fifo;\r\ndma_params.dst_ei = 1;\r\ndma_params.dst_fi = -31;\r\ndma_params.trigger = sync_dev;\r\ndma_params.sync_mode = OMAP_DMA_SYNC_FRAME;\r\ndma_params.src_or_dst_synch = 0;\r\nsrc_burst = OMAP_DMA_DATA_BURST_16;\r\ndst_burst = OMAP_DMA_DATA_BURST_8;\r\n} else {\r\ndma_params.src_amode = OMAP_DMA_AMODE_DOUBLE_IDX;\r\ndma_params.src_start = (unsigned long)fifo;\r\ndma_params.src_ei = 1;\r\ndma_params.src_fi = -31;\r\ndma_params.dst_amode = OMAP_DMA_AMODE_POST_INC;\r\ndma_params.dst_start = (unsigned long)dma_addr;\r\ndma_params.dst_ei = 0;\r\ndma_params.dst_fi = 0;\r\ndma_params.trigger = sync_dev;\r\ndma_params.sync_mode = OMAP_DMA_SYNC_FRAME;\r\ndma_params.src_or_dst_synch = 1;\r\nsrc_burst = OMAP_DMA_DATA_BURST_8;\r\ndst_burst = OMAP_DMA_DATA_BURST_16;\r\n}\r\ndev_dbg(musb->controller, "ep%i %s using %i-bit %s dma from 0x%08lx to 0x%08lx\n",\r\nchdat->epnum, chdat->tx ? "tx" : "rx",\r\n(dma_params.data_type == OMAP_DMA_DATA_TYPE_S32) ? 32 : 16,\r\n((dma_addr & 0x3) == 0) ? "sync" : "async",\r\ndma_params.src_start, dma_params.dst_start);\r\nomap_set_dma_params(ch, &dma_params);\r\nomap_set_dma_src_burst_mode(ch, src_burst);\r\nomap_set_dma_dest_burst_mode(ch, dst_burst);\r\nomap_set_dma_write_mode(ch, OMAP_DMA_WRITE_LAST_NON_POSTED);\r\nif (chdat->tx) {\r\nmusb_ep_select(mbase, chdat->epnum);\r\ncsr = musb_readw(hw_ep->regs, MUSB_TXCSR);\r\ncsr |= (MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB\r\n| MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);\r\ncsr &= ~MUSB_TXCSR_P_UNDERRUN;\r\nmusb_writew(hw_ep->regs, MUSB_TXCSR, csr);\r\n} else {\r\nmusb_ep_select(mbase, chdat->epnum);\r\ncsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_DMAENAB;\r\ncsr &= ~(MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAMODE);\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR,\r\ncsr | MUSB_RXCSR_P_WZC_BITS);\r\n}\r\nomap_start_dma(ch);\r\nif (chdat->tx) {\r\nmusb_writel(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET,\r\nchdat->transfer_packet_sz);\r\nmusb_writel(ep_conf, TUSB_EP_TX_OFFSET,\r\nTUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));\r\n} else {\r\nmusb_writel(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET,\r\nchdat->transfer_packet_sz << 16);\r\nmusb_writel(ep_conf, TUSB_EP_RX_OFFSET,\r\nTUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));\r\n}\r\nreturn true;\r\n}\r\nstatic int tusb_omap_dma_abort(struct dma_channel *channel)\r\n{\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nstruct tusb_omap_dma *tusb_dma = chdat->tusb_dma;\r\nif (!tusb_dma->multichannel) {\r\nif (tusb_dma->ch >= 0) {\r\nomap_stop_dma(tusb_dma->ch);\r\nomap_free_dma(tusb_dma->ch);\r\ntusb_dma->ch = -1;\r\n}\r\ntusb_dma->dmareq = -1;\r\ntusb_dma->sync_dev = -1;\r\n}\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nreturn 0;\r\n}\r\nstatic inline int tusb_omap_dma_allocate_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nint i, dmareq_nr = -1;\r\nconst int sync_dev[6] = {\r\nOMAP24XX_DMA_EXT_DMAREQ0,\r\nOMAP24XX_DMA_EXT_DMAREQ1,\r\nOMAP242X_DMA_EXT_DMAREQ2,\r\nOMAP242X_DMA_EXT_DMAREQ3,\r\nOMAP242X_DMA_EXT_DMAREQ4,\r\nOMAP242X_DMA_EXT_DMAREQ5,\r\n};\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nint cur = (reg & (0xf << (i * 5))) >> (i * 5);\r\nif (cur == 0) {\r\ndmareq_nr = i;\r\nbreak;\r\n}\r\n}\r\nif (dmareq_nr == -1)\r\nreturn -EAGAIN;\r\nreg |= (chdat->epnum << (dmareq_nr * 5));\r\nif (chdat->tx)\r\nreg |= ((1 << 4) << (dmareq_nr * 5));\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\r\nchdat->dmareq = dmareq_nr;\r\nchdat->sync_dev = sync_dev[chdat->dmareq];\r\nreturn 0;\r\n}\r\nstatic inline void tusb_omap_dma_free_dmareq(struct tusb_omap_dma_ch *chdat)\r\n{\r\nu32 reg;\r\nif (!chdat || chdat->dmareq < 0)\r\nreturn;\r\nreg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\r\nreg &= ~(0x1f << (chdat->dmareq * 5));\r\nmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\r\nchdat->dmareq = -1;\r\nchdat->sync_dev = -1;\r\n}\r\nstatic struct dma_channel *\r\ntusb_omap_dma_allocate(struct dma_controller *c,\r\nstruct musb_hw_ep *hw_ep,\r\nu8 tx)\r\n{\r\nint ret, i;\r\nconst char *dev_name;\r\nstruct tusb_omap_dma *tusb_dma;\r\nstruct musb *musb;\r\nvoid __iomem *tbase;\r\nstruct dma_channel *channel = NULL;\r\nstruct tusb_omap_dma_ch *chdat = NULL;\r\nu32 reg;\r\ntusb_dma = container_of(c, struct tusb_omap_dma, controller);\r\nmusb = tusb_dma->musb;\r\ntbase = musb->ctrl_base;\r\nreg = musb_readl(tbase, TUSB_DMA_INT_MASK);\r\nif (tx)\r\nreg &= ~(1 << hw_ep->epnum);\r\nelse\r\nreg &= ~(1 << (hw_ep->epnum + 15));\r\nmusb_writel(tbase, TUSB_DMA_INT_MASK, reg);\r\nif (hw_ep->epnum == 0) {\r\ndev_dbg(musb->controller, "Not allowing DMA for ep0 %s\n", tx ? "tx" : "rx");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nstruct dma_channel *ch = dma_channel_pool[i];\r\nif (ch->status == MUSB_DMA_STATUS_UNKNOWN) {\r\nch->status = MUSB_DMA_STATUS_FREE;\r\nchannel = ch;\r\nchdat = ch->private_data;\r\nbreak;\r\n}\r\n}\r\nif (!channel)\r\nreturn NULL;\r\nif (tx) {\r\nchdat->tx = 1;\r\ndev_name = "TUSB transmit";\r\n} else {\r\nchdat->tx = 0;\r\ndev_name = "TUSB receive";\r\n}\r\nchdat->musb = tusb_dma->musb;\r\nchdat->tbase = tusb_dma->tbase;\r\nchdat->hw_ep = hw_ep;\r\nchdat->epnum = hw_ep->epnum;\r\nchdat->dmareq = -1;\r\nchdat->completed_len = 0;\r\nchdat->tusb_dma = tusb_dma;\r\nchannel->max_len = 0x7fffffff;\r\nchannel->desired_mode = 0;\r\nchannel->actual_len = 0;\r\nif (tusb_dma->multichannel) {\r\nret = tusb_omap_dma_allocate_dmareq(chdat);\r\nif (ret != 0)\r\ngoto free_dmareq;\r\nret = omap_request_dma(chdat->sync_dev, dev_name,\r\ntusb_omap_dma_cb, channel, &chdat->ch);\r\nif (ret != 0)\r\ngoto free_dmareq;\r\n} else if (tusb_dma->ch == -1) {\r\ntusb_dma->dmareq = 0;\r\ntusb_dma->sync_dev = OMAP24XX_DMA_EXT_DMAREQ0;\r\nret = omap_request_dma(tusb_dma->sync_dev, "TUSB shared",\r\ntusb_omap_dma_cb, NULL, &tusb_dma->ch);\r\nif (ret != 0)\r\ngoto free_dmareq;\r\nchdat->dmareq = -1;\r\nchdat->ch = -1;\r\n}\r\ndev_dbg(musb->controller, "ep%i %s dma: %s dma%i dmareq%i sync%i\n",\r\nchdat->epnum,\r\nchdat->tx ? "tx" : "rx",\r\nchdat->ch >= 0 ? "dedicated" : "shared",\r\nchdat->ch >= 0 ? chdat->ch : tusb_dma->ch,\r\nchdat->dmareq >= 0 ? chdat->dmareq : tusb_dma->dmareq,\r\nchdat->sync_dev >= 0 ? chdat->sync_dev : tusb_dma->sync_dev);\r\nreturn channel;\r\nfree_dmareq:\r\ntusb_omap_dma_free_dmareq(chdat);\r\ndev_dbg(musb->controller, "ep%i: Could not get a DMA channel\n", chdat->epnum);\r\nchannel->status = MUSB_DMA_STATUS_UNKNOWN;\r\nreturn NULL;\r\n}\r\nstatic void tusb_omap_dma_release(struct dma_channel *channel)\r\n{\r\nstruct tusb_omap_dma_ch *chdat = to_chdat(channel);\r\nstruct musb *musb = chdat->musb;\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 reg;\r\ndev_dbg(musb->controller, "ep%i ch%i\n", chdat->epnum, chdat->ch);\r\nreg = musb_readl(tbase, TUSB_DMA_INT_MASK);\r\nif (chdat->tx)\r\nreg |= (1 << chdat->epnum);\r\nelse\r\nreg |= (1 << (chdat->epnum + 15));\r\nmusb_writel(tbase, TUSB_DMA_INT_MASK, reg);\r\nreg = musb_readl(tbase, TUSB_DMA_INT_CLEAR);\r\nif (chdat->tx)\r\nreg |= (1 << chdat->epnum);\r\nelse\r\nreg |= (1 << (chdat->epnum + 15));\r\nmusb_writel(tbase, TUSB_DMA_INT_CLEAR, reg);\r\nchannel->status = MUSB_DMA_STATUS_UNKNOWN;\r\nif (chdat->ch >= 0) {\r\nomap_stop_dma(chdat->ch);\r\nomap_free_dma(chdat->ch);\r\nchdat->ch = -1;\r\n}\r\nif (chdat->dmareq >= 0)\r\ntusb_omap_dma_free_dmareq(chdat);\r\nchannel = NULL;\r\n}\r\nvoid tusb_dma_controller_destroy(struct dma_controller *c)\r\n{\r\nstruct tusb_omap_dma *tusb_dma;\r\nint i;\r\ntusb_dma = container_of(c, struct tusb_omap_dma, controller);\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nstruct dma_channel *ch = dma_channel_pool[i];\r\nif (ch) {\r\nkfree(ch->private_data);\r\nkfree(ch);\r\n}\r\n}\r\nif (tusb_dma && !tusb_dma->multichannel && tusb_dma->ch >= 0)\r\nomap_free_dma(tusb_dma->ch);\r\nkfree(tusb_dma);\r\n}\r\nstruct dma_controller *\r\ntusb_dma_controller_create(struct musb *musb, void __iomem *base)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nstruct tusb_omap_dma *tusb_dma;\r\nint i;\r\nmusb_writel(musb->ctrl_base, TUSB_DMA_INT_MASK, 0x7fffffff);\r\nmusb_writel(musb->ctrl_base, TUSB_DMA_EP_MAP, 0);\r\nmusb_writel(tbase, TUSB_DMA_REQ_CONF,\r\nTUSB_DMA_REQ_CONF_BURST_SIZE(2)\r\n| TUSB_DMA_REQ_CONF_DMA_REQ_EN(0x3f)\r\n| TUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));\r\ntusb_dma = kzalloc(sizeof(struct tusb_omap_dma), GFP_KERNEL);\r\nif (!tusb_dma)\r\ngoto out;\r\ntusb_dma->musb = musb;\r\ntusb_dma->tbase = musb->ctrl_base;\r\ntusb_dma->ch = -1;\r\ntusb_dma->dmareq = -1;\r\ntusb_dma->sync_dev = -1;\r\ntusb_dma->controller.channel_alloc = tusb_omap_dma_allocate;\r\ntusb_dma->controller.channel_release = tusb_omap_dma_release;\r\ntusb_dma->controller.channel_program = tusb_omap_dma_program;\r\ntusb_dma->controller.channel_abort = tusb_omap_dma_abort;\r\nif (musb->tusb_revision >= TUSB_REV_30)\r\ntusb_dma->multichannel = 1;\r\nfor (i = 0; i < MAX_DMAREQ; i++) {\r\nstruct dma_channel *ch;\r\nstruct tusb_omap_dma_ch *chdat;\r\nch = kzalloc(sizeof(struct dma_channel), GFP_KERNEL);\r\nif (!ch)\r\ngoto cleanup;\r\ndma_channel_pool[i] = ch;\r\nchdat = kzalloc(sizeof(struct tusb_omap_dma_ch), GFP_KERNEL);\r\nif (!chdat)\r\ngoto cleanup;\r\nch->status = MUSB_DMA_STATUS_UNKNOWN;\r\nch->private_data = chdat;\r\n}\r\nreturn &tusb_dma->controller;\r\ncleanup:\r\nmusb_dma_controller_destroy(&tusb_dma->controller);\r\nout:\r\nreturn NULL;\r\n}
