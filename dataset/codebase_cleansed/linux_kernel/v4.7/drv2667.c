static int drv2667_set_waveform_freq(struct drv2667_data *haptics)\r\n{\r\nunsigned int read_buf;\r\nint freq;\r\nint error;\r\nfreq = (haptics->frequency * 1000) / 78125;\r\nif (freq <= 0) {\r\ndev_err(&haptics->client->dev,\r\n"ERROR: Frequency calculated to %i\n", freq);\r\nreturn -EINVAL;\r\n}\r\nerror = regmap_read(haptics->regmap, DRV2667_PAGE, &read_buf);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to read the page number: %d\n", error);\r\nreturn -EIO;\r\n}\r\nif (read_buf == DRV2667_PAGE_0 ||\r\nhaptics->page != read_buf) {\r\nerror = regmap_write(haptics->regmap,\r\nDRV2667_PAGE, haptics->page);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to set the page: %d\n", error);\r\nreturn -EIO;\r\n}\r\n}\r\nerror = regmap_write(haptics->regmap, DRV2667_RAM_FREQ, freq);\r\nif (error)\r\ndev_err(&haptics->client->dev,\r\n"Failed to set the frequency: %d\n", error);\r\nif (read_buf == DRV2667_PAGE_0 ||\r\nhaptics->page != read_buf) {\r\nerror = regmap_write(haptics->regmap, DRV2667_PAGE, read_buf);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to set the page: %d\n", error);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic void drv2667_worker(struct work_struct *work)\r\n{\r\nstruct drv2667_data *haptics = container_of(work, struct drv2667_data, work);\r\nint error;\r\nif (haptics->magnitude) {\r\nerror = regmap_write(haptics->regmap,\r\nDRV2667_PAGE, haptics->page);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to set the page: %d\n", error);\r\nreturn;\r\n}\r\nerror = regmap_write(haptics->regmap, DRV2667_RAM_AMP,\r\nhaptics->magnitude);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to set the amplitude: %d\n", error);\r\nreturn;\r\n}\r\nerror = regmap_write(haptics->regmap,\r\nDRV2667_PAGE, DRV2667_PAGE_0);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to set the page: %d\n", error);\r\nreturn;\r\n}\r\nerror = regmap_write(haptics->regmap,\r\nDRV2667_CTRL_2, DRV2667_GO);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to set the GO bit: %d\n", error);\r\n}\r\n} else {\r\nerror = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\r\nDRV2667_GO, 0);\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to unset the GO bit: %d\n", error);\r\n}\r\n}\r\n}\r\nstatic int drv2667_haptics_play(struct input_dev *input, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct drv2667_data *haptics = input_get_drvdata(input);\r\nif (effect->u.rumble.strong_magnitude > 0)\r\nhaptics->magnitude = effect->u.rumble.strong_magnitude;\r\nelse if (effect->u.rumble.weak_magnitude > 0)\r\nhaptics->magnitude = effect->u.rumble.weak_magnitude;\r\nelse\r\nhaptics->magnitude = 0;\r\nschedule_work(&haptics->work);\r\nreturn 0;\r\n}\r\nstatic void drv2667_close(struct input_dev *input)\r\n{\r\nstruct drv2667_data *haptics = input_get_drvdata(input);\r\nint error;\r\ncancel_work_sync(&haptics->work);\r\nerror = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\r\nDRV2667_STANDBY, 1);\r\nif (error)\r\ndev_err(&haptics->client->dev,\r\n"Failed to enter standby mode: %d\n", error);\r\n}\r\nstatic int drv2667_init(struct drv2667_data *haptics)\r\n{\r\nint error;\r\nhaptics->frequency = 195;\r\nhaptics->page = DRV2667_PAGE_1;\r\nerror = regmap_register_patch(haptics->regmap,\r\ndrv2667_init_regs,\r\nARRAY_SIZE(drv2667_init_regs));\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write init registers: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = regmap_write(haptics->regmap, DRV2667_PAGE, haptics->page);\r\nif (error) {\r\ndev_err(&haptics->client->dev, "Failed to set page: %d\n",\r\nerror);\r\ngoto error_out;\r\n}\r\nerror = drv2667_set_waveform_freq(haptics);\r\nif (error)\r\ngoto error_page;\r\nerror = regmap_register_patch(haptics->regmap,\r\ndrv2667_page1_init,\r\nARRAY_SIZE(drv2667_page1_init));\r\nif (error) {\r\ndev_err(&haptics->client->dev,\r\n"Failed to write page registers: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = regmap_write(haptics->regmap, DRV2667_PAGE, DRV2667_PAGE_0);\r\nreturn error;\r\nerror_page:\r\nregmap_write(haptics->regmap, DRV2667_PAGE, DRV2667_PAGE_0);\r\nerror_out:\r\nreturn error;\r\n}\r\nstatic int drv2667_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct drv2667_data *haptics;\r\nint error;\r\nhaptics = devm_kzalloc(&client->dev, sizeof(*haptics), GFP_KERNEL);\r\nif (!haptics)\r\nreturn -ENOMEM;\r\nhaptics->regulator = devm_regulator_get(&client->dev, "vbat");\r\nif (IS_ERR(haptics->regulator)) {\r\nerror = PTR_ERR(haptics->regulator);\r\ndev_err(&client->dev,\r\n"unable to get regulator, error: %d\n", error);\r\nreturn error;\r\n}\r\nhaptics->input_dev = devm_input_allocate_device(&client->dev);\r\nif (!haptics->input_dev) {\r\ndev_err(&client->dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nhaptics->input_dev->name = "drv2667:haptics";\r\nhaptics->input_dev->dev.parent = client->dev.parent;\r\nhaptics->input_dev->close = drv2667_close;\r\ninput_set_drvdata(haptics->input_dev, haptics);\r\ninput_set_capability(haptics->input_dev, EV_FF, FF_RUMBLE);\r\nerror = input_ff_create_memless(haptics->input_dev, NULL,\r\ndrv2667_haptics_play);\r\nif (error) {\r\ndev_err(&client->dev, "input_ff_create() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nINIT_WORK(&haptics->work, drv2667_worker);\r\nhaptics->client = client;\r\ni2c_set_clientdata(client, haptics);\r\nhaptics->regmap = devm_regmap_init_i2c(client, &drv2667_regmap_config);\r\nif (IS_ERR(haptics->regmap)) {\r\nerror = PTR_ERR(haptics->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = drv2667_init(haptics);\r\nif (error) {\r\ndev_err(&client->dev, "Device init failed: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(haptics->input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "couldn't register input device: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused drv2667_suspend(struct device *dev)\r\n{\r\nstruct drv2667_data *haptics = dev_get_drvdata(dev);\r\nint ret = 0;\r\nmutex_lock(&haptics->input_dev->mutex);\r\nif (haptics->input_dev->users) {\r\nret = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\r\nDRV2667_STANDBY, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to set standby mode\n");\r\nregulator_disable(haptics->regulator);\r\ngoto out;\r\n}\r\nret = regulator_disable(haptics->regulator);\r\nif (ret) {\r\ndev_err(dev, "Failed to disable regulator\n");\r\nregmap_update_bits(haptics->regmap,\r\nDRV2667_CTRL_2,\r\nDRV2667_STANDBY, 0);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&haptics->input_dev->mutex);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused drv2667_resume(struct device *dev)\r\n{\r\nstruct drv2667_data *haptics = dev_get_drvdata(dev);\r\nint ret = 0;\r\nmutex_lock(&haptics->input_dev->mutex);\r\nif (haptics->input_dev->users) {\r\nret = regulator_enable(haptics->regulator);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator\n");\r\ngoto out;\r\n}\r\nret = regmap_update_bits(haptics->regmap, DRV2667_CTRL_2,\r\nDRV2667_STANDBY, 0);\r\nif (ret) {\r\ndev_err(dev, "Failed to unset standby mode\n");\r\nregulator_disable(haptics->regulator);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&haptics->input_dev->mutex);\r\nreturn ret;\r\n}
