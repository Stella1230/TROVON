static u32 ns_to_src(struct src_sel *s, u32 ns)\r\n{\r\nns >>= s->src_sel_shift;\r\nns &= SRC_SEL_MASK;\r\nreturn ns;\r\n}\r\nstatic u32 src_to_ns(struct src_sel *s, u8 src, u32 ns)\r\n{\r\nu32 mask;\r\nmask = SRC_SEL_MASK;\r\nmask <<= s->src_sel_shift;\r\nns &= ~mask;\r\nns |= src << s->src_sel_shift;\r\nreturn ns;\r\n}\r\nstatic u8 clk_rcg_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nint num_parents = clk_hw_get_num_parents(hw);\r\nu32 ns;\r\nint i, ret;\r\nret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (ret)\r\ngoto err;\r\nns = ns_to_src(&rcg->s, ns);\r\nfor (i = 0; i < num_parents; i++)\r\nif (ns == rcg->s.parent_map[i].cfg)\r\nreturn i;\r\nerr:\r\npr_debug("%s: Clock %s has invalid parent, using default.\n",\r\n__func__, clk_hw_get_name(hw));\r\nreturn 0;\r\n}\r\nstatic int reg_to_bank(struct clk_dyn_rcg *rcg, u32 bank)\r\n{\r\nbank &= BIT(rcg->mux_sel_bit);\r\nreturn !!bank;\r\n}\r\nstatic u8 clk_dyn_rcg_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nint num_parents = clk_hw_get_num_parents(hw);\r\nu32 ns, reg;\r\nint bank;\r\nint i, ret;\r\nstruct src_sel *s;\r\nret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nif (ret)\r\ngoto err;\r\nbank = reg_to_bank(rcg, reg);\r\ns = &rcg->s[bank];\r\nret = regmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\r\nif (ret)\r\ngoto err;\r\nns = ns_to_src(s, ns);\r\nfor (i = 0; i < num_parents; i++)\r\nif (ns == s->parent_map[i].cfg)\r\nreturn i;\r\nerr:\r\npr_debug("%s: Clock %s has invalid parent, using default.\n",\r\n__func__, clk_hw_get_name(hw));\r\nreturn 0;\r\n}\r\nstatic int clk_rcg_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 ns;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nns = src_to_ns(&rcg->s, rcg->s.parent_map[index].cfg, ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nreturn 0;\r\n}\r\nstatic u32 md_to_m(struct mn *mn, u32 md)\r\n{\r\nmd >>= mn->m_val_shift;\r\nmd &= BIT(mn->width) - 1;\r\nreturn md;\r\n}\r\nstatic u32 ns_to_pre_div(struct pre_div *p, u32 ns)\r\n{\r\nns >>= p->pre_div_shift;\r\nns &= BIT(p->pre_div_width) - 1;\r\nreturn ns;\r\n}\r\nstatic u32 pre_div_to_ns(struct pre_div *p, u8 pre_div, u32 ns)\r\n{\r\nu32 mask;\r\nmask = BIT(p->pre_div_width) - 1;\r\nmask <<= p->pre_div_shift;\r\nns &= ~mask;\r\nns |= pre_div << p->pre_div_shift;\r\nreturn ns;\r\n}\r\nstatic u32 mn_to_md(struct mn *mn, u32 m, u32 n, u32 md)\r\n{\r\nu32 mask, mask_w;\r\nmask_w = BIT(mn->width) - 1;\r\nmask = (mask_w << mn->m_val_shift) | mask_w;\r\nmd &= ~mask;\r\nif (n) {\r\nm <<= mn->m_val_shift;\r\nmd |= m;\r\nmd |= ~n & mask_w;\r\n}\r\nreturn md;\r\n}\r\nstatic u32 ns_m_to_n(struct mn *mn, u32 ns, u32 m)\r\n{\r\nns = ~ns >> mn->n_val_shift;\r\nns &= BIT(mn->width) - 1;\r\nreturn ns + m;\r\n}\r\nstatic u32 reg_to_mnctr_mode(struct mn *mn, u32 val)\r\n{\r\nval >>= mn->mnctr_mode_shift;\r\nval &= MNCTR_MODE_MASK;\r\nreturn val;\r\n}\r\nstatic u32 mn_to_ns(struct mn *mn, u32 m, u32 n, u32 ns)\r\n{\r\nu32 mask;\r\nmask = BIT(mn->width) - 1;\r\nmask <<= mn->n_val_shift;\r\nns &= ~mask;\r\nif (n) {\r\nn = n - m;\r\nn = ~n;\r\nn &= BIT(mn->width) - 1;\r\nn <<= mn->n_val_shift;\r\nns |= n;\r\n}\r\nreturn ns;\r\n}\r\nstatic u32 mn_to_reg(struct mn *mn, u32 m, u32 n, u32 val)\r\n{\r\nu32 mask;\r\nmask = MNCTR_MODE_MASK << mn->mnctr_mode_shift;\r\nmask |= BIT(mn->mnctr_en_bit);\r\nval &= ~mask;\r\nif (n) {\r\nval |= BIT(mn->mnctr_en_bit);\r\nval |= MNCTR_MODE_DUAL << mn->mnctr_mode_shift;\r\n}\r\nreturn val;\r\n}\r\nstatic int configure_bank(struct clk_dyn_rcg *rcg, const struct freq_tbl *f)\r\n{\r\nu32 ns, md, reg;\r\nint bank, new_bank, ret, index;\r\nstruct mn *mn;\r\nstruct pre_div *p;\r\nstruct src_sel *s;\r\nbool enabled;\r\nu32 md_reg, ns_reg;\r\nbool banked_mn = !!rcg->mn[1].width;\r\nbool banked_p = !!rcg->p[1].pre_div_width;\r\nstruct clk_hw *hw = &rcg->clkr.hw;\r\nenabled = __clk_is_enabled(hw->clk);\r\nret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nif (ret)\r\nreturn ret;\r\nbank = reg_to_bank(rcg, reg);\r\nnew_bank = enabled ? !bank : bank;\r\nns_reg = rcg->ns_reg[new_bank];\r\nret = regmap_read(rcg->clkr.regmap, ns_reg, &ns);\r\nif (ret)\r\nreturn ret;\r\nif (banked_mn) {\r\nmn = &rcg->mn[new_bank];\r\nmd_reg = rcg->md_reg[new_bank];\r\nns |= BIT(mn->mnctr_reset_bit);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(rcg->clkr.regmap, md_reg, &md);\r\nif (ret)\r\nreturn ret;\r\nmd = mn_to_md(mn, f->m, f->n, md);\r\nret = regmap_write(rcg->clkr.regmap, md_reg, md);\r\nif (ret)\r\nreturn ret;\r\nns = mn_to_ns(mn, f->m, f->n, ns);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\nif (rcg->ns_reg[0] != rcg->ns_reg[1]) {\r\nns = mn_to_reg(mn, f->m, f->n, ns);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreg = mn_to_reg(mn, f->m, f->n, reg);\r\nret = regmap_write(rcg->clkr.regmap, rcg->bank_reg,\r\nreg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nns &= ~BIT(mn->mnctr_reset_bit);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (banked_p) {\r\np = &rcg->p[new_bank];\r\nns = pre_div_to_ns(p, f->pre_div - 1, ns);\r\n}\r\ns = &rcg->s[new_bank];\r\nindex = qcom_find_src_index(hw, s->parent_map, f->src);\r\nif (index < 0)\r\nreturn index;\r\nns = src_to_ns(s, s->parent_map[index].cfg, ns);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\nif (enabled) {\r\nret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nif (ret)\r\nreturn ret;\r\nreg ^= BIT(rcg->mux_sel_bit);\r\nret = regmap_write(rcg->clkr.regmap, rcg->bank_reg, reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int clk_dyn_rcg_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 ns, md, reg;\r\nint bank;\r\nstruct freq_tbl f = { 0 };\r\nbool banked_mn = !!rcg->mn[1].width;\r\nbool banked_p = !!rcg->p[1].pre_div_width;\r\nregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nbank = reg_to_bank(rcg, reg);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\r\nif (banked_mn) {\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\r\nf.m = md_to_m(&rcg->mn[bank], md);\r\nf.n = ns_m_to_n(&rcg->mn[bank], ns, f.m);\r\n}\r\nif (banked_p)\r\nf.pre_div = ns_to_pre_div(&rcg->p[bank], ns) + 1;\r\nf.src = qcom_find_src_index(hw, rcg->s[bank].parent_map, index);\r\nreturn configure_bank(rcg, &f);\r\n}\r\nstatic unsigned long\r\ncalc_rate(unsigned long rate, u32 m, u32 n, u32 mode, u32 pre_div)\r\n{\r\nif (pre_div)\r\nrate /= pre_div + 1;\r\nif (mode) {\r\nu64 tmp = rate;\r\ntmp *= m;\r\ndo_div(tmp, n);\r\nrate = tmp;\r\n}\r\nreturn rate;\r\n}\r\nstatic unsigned long\r\nclk_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 pre_div, m = 0, n = 0, ns, md, mode = 0;\r\nstruct mn *mn = &rcg->mn;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\npre_div = ns_to_pre_div(&rcg->p, ns);\r\nif (rcg->mn.width) {\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\r\nm = md_to_m(mn, md);\r\nn = ns_m_to_n(mn, ns, m);\r\nif (rcg->clkr.enable_reg != rcg->ns_reg)\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &mode);\r\nelse\r\nmode = ns;\r\nmode = reg_to_mnctr_mode(mn, mode);\r\n}\r\nreturn calc_rate(parent_rate, m, n, mode, pre_div);\r\n}\r\nstatic unsigned long\r\nclk_dyn_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 m, n, pre_div, ns, md, mode, reg;\r\nint bank;\r\nstruct mn *mn;\r\nbool banked_p = !!rcg->p[1].pre_div_width;\r\nbool banked_mn = !!rcg->mn[1].width;\r\nregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nbank = reg_to_bank(rcg, reg);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\r\nm = n = pre_div = mode = 0;\r\nif (banked_mn) {\r\nmn = &rcg->mn[bank];\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\r\nm = md_to_m(mn, md);\r\nn = ns_m_to_n(mn, ns, m);\r\nif (rcg->ns_reg[0] != rcg->ns_reg[1])\r\nreg = ns;\r\nmode = reg_to_mnctr_mode(mn, reg);\r\n}\r\nif (banked_p)\r\npre_div = ns_to_pre_div(&rcg->p[bank], ns);\r\nreturn calc_rate(parent_rate, m, n, mode, pre_div);\r\n}\r\nstatic int _freq_tbl_determine_rate(struct clk_hw *hw, const struct freq_tbl *f,\r\nstruct clk_rate_request *req,\r\nconst struct parent_map *parent_map)\r\n{\r\nunsigned long clk_flags, rate = req->rate;\r\nstruct clk_hw *p;\r\nint index;\r\nf = qcom_find_freq(f, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nindex = qcom_find_src_index(hw, parent_map, f->src);\r\nif (index < 0)\r\nreturn index;\r\nclk_flags = clk_hw_get_flags(hw);\r\np = clk_hw_get_parent_by_index(hw, index);\r\nif (clk_flags & CLK_SET_RATE_PARENT) {\r\nrate = rate * f->pre_div;\r\nif (f->n) {\r\nu64 tmp = rate;\r\ntmp = tmp * f->n;\r\ndo_div(tmp, f->m);\r\nrate = tmp;\r\n}\r\n} else {\r\nrate = clk_hw_get_rate(p);\r\n}\r\nreq->best_parent_hw = p;\r\nreq->best_parent_rate = rate;\r\nreq->rate = f->freq;\r\nreturn 0;\r\n}\r\nstatic int clk_rcg_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, req,\r\nrcg->s.parent_map);\r\n}\r\nstatic int clk_dyn_rcg_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 reg;\r\nint bank;\r\nstruct src_sel *s;\r\nregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nbank = reg_to_bank(rcg, reg);\r\ns = &rcg->s[bank];\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, req, s->parent_map);\r\n}\r\nstatic int clk_rcg_bypass_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nconst struct freq_tbl *f = rcg->freq_tbl;\r\nstruct clk_hw *p;\r\nint index = qcom_find_src_index(hw, rcg->s.parent_map, f->src);\r\nreq->best_parent_hw = p = clk_hw_get_parent_by_index(hw, index);\r\nreq->best_parent_rate = clk_hw_round_rate(p, req->rate);\r\nreq->rate = req->best_parent_rate;\r\nreturn 0;\r\n}\r\nstatic int __clk_rcg_set_rate(struct clk_rcg *rcg, const struct freq_tbl *f)\r\n{\r\nu32 ns, md, ctl;\r\nstruct mn *mn = &rcg->mn;\r\nu32 mask = 0;\r\nunsigned int reset_reg;\r\nif (rcg->mn.reset_in_cc)\r\nreset_reg = rcg->clkr.enable_reg;\r\nelse\r\nreset_reg = rcg->ns_reg;\r\nif (rcg->mn.width) {\r\nmask = BIT(mn->mnctr_reset_bit);\r\nregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, mask);\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\r\nmd = mn_to_md(mn, f->m, f->n, md);\r\nregmap_write(rcg->clkr.regmap, rcg->md_reg, md);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (rcg->clkr.enable_reg != rcg->ns_reg) {\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\r\nctl = mn_to_reg(mn, f->m, f->n, ctl);\r\nregmap_write(rcg->clkr.regmap, rcg->clkr.enable_reg, ctl);\r\n} else {\r\nns = mn_to_reg(mn, f->m, f->n, ns);\r\n}\r\nns = mn_to_ns(mn, f->m, f->n, ns);\r\n} else {\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\n}\r\nns = pre_div_to_ns(&rcg->p, f->pre_div - 1, ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, 0);\r\nreturn 0;\r\n}\r\nstatic int clk_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nconst struct freq_tbl *f;\r\nf = qcom_find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nreturn __clk_rcg_set_rate(rcg, f);\r\n}\r\nstatic int clk_rcg_bypass_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nreturn __clk_rcg_set_rate(rcg, rcg->freq_tbl);\r\n}\r\nstatic int clk_rcg_bypass2_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_hw *p;\r\np = req->best_parent_hw;\r\nreq->best_parent_rate = clk_hw_round_rate(p, req->rate);\r\nreq->rate = req->best_parent_rate;\r\nreturn 0;\r\n}\r\nstatic int clk_rcg_bypass2_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nstruct freq_tbl f = { 0 };\r\nu32 ns, src;\r\nint i, ret, num_parents = clk_hw_get_num_parents(hw);\r\nret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (ret)\r\nreturn ret;\r\nsrc = ns_to_src(&rcg->s, ns);\r\nf.pre_div = ns_to_pre_div(&rcg->p, ns) + 1;\r\nfor (i = 0; i < num_parents; i++) {\r\nif (src == rcg->s.parent_map[i].cfg) {\r\nf.src = rcg->s.parent_map[i].src;\r\nreturn __clk_rcg_set_rate(rcg, &f);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_rcg_bypass2_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn clk_rcg_bypass2_set_rate(hw, rate, parent_rate);\r\n}\r\nstatic int clk_rcg_pixel_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nint delta = 100000;\r\nconst struct frac_entry *frac = pixel_table;\r\nunsigned long request, src_rate;\r\nfor (; frac->num; frac++) {\r\nrequest = (req->rate * frac->den) / frac->num;\r\nsrc_rate = clk_hw_round_rate(req->best_parent_hw, request);\r\nif ((src_rate < (request - delta)) ||\r\n(src_rate > (request + delta)))\r\ncontinue;\r\nreq->best_parent_rate = src_rate;\r\nreq->rate = (src_rate * frac->num) / frac->den;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_rcg_pixel_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nint delta = 100000;\r\nconst struct frac_entry *frac = pixel_table;\r\nunsigned long request;\r\nstruct freq_tbl f = { 0 };\r\nu32 ns, src;\r\nint i, ret, num_parents = clk_hw_get_num_parents(hw);\r\nret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (ret)\r\nreturn ret;\r\nsrc = ns_to_src(&rcg->s, ns);\r\nfor (i = 0; i < num_parents; i++) {\r\nif (src == rcg->s.parent_map[i].cfg) {\r\nf.src = rcg->s.parent_map[i].src;\r\nbreak;\r\n}\r\n}\r\nf.pre_div = 1;\r\nfor (; frac->num; frac++) {\r\nrequest = (rate * frac->den) / frac->num;\r\nif ((parent_rate < (request - delta)) ||\r\n(parent_rate > (request + delta)))\r\ncontinue;\r\nf.m = frac->num;\r\nf.n = frac->den;\r\nreturn __clk_rcg_set_rate(rcg, &f);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_rcg_pixel_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn clk_rcg_pixel_set_rate(hw, rate, parent_rate);\r\n}\r\nstatic int clk_rcg_esc_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nint pre_div_max = BIT(rcg->p.pre_div_width);\r\nint div;\r\nunsigned long src_rate;\r\nif (req->rate == 0)\r\nreturn -EINVAL;\r\nsrc_rate = clk_hw_get_rate(req->best_parent_hw);\r\ndiv = src_rate / req->rate;\r\nif (div >= 1 && div <= pre_div_max) {\r\nreq->best_parent_rate = src_rate;\r\nreq->rate = src_rate / div;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_rcg_esc_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nstruct freq_tbl f = { 0 };\r\nint pre_div_max = BIT(rcg->p.pre_div_width);\r\nint div;\r\nu32 ns;\r\nint i, ret, num_parents = clk_hw_get_num_parents(hw);\r\nif (rate == 0)\r\nreturn -EINVAL;\r\nret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (ret)\r\nreturn ret;\r\nns = ns_to_src(&rcg->s, ns);\r\nfor (i = 0; i < num_parents; i++) {\r\nif (ns == rcg->s.parent_map[i].cfg) {\r\nf.src = rcg->s.parent_map[i].src;\r\nbreak;\r\n}\r\n}\r\ndiv = parent_rate / rate;\r\nif (div >= 1 && div <= pre_div_max) {\r\nf.pre_div = div;\r\nreturn __clk_rcg_set_rate(rcg, &f);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_rcg_esc_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn clk_rcg_esc_set_rate(hw, rate, parent_rate);\r\n}\r\nstatic int clk_rcg_lcc_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nconst struct freq_tbl *f;\r\nint ret;\r\nu32 gfm = BIT(10);\r\nf = qcom_find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, 0);\r\nret = __clk_rcg_set_rate(rcg, f);\r\nif (__clk_is_enabled(hw->clk))\r\nregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, gfm);\r\nreturn ret;\r\n}\r\nstatic int clk_rcg_lcc_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 gfm = BIT(10);\r\nreturn regmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, gfm);\r\n}\r\nstatic void clk_rcg_lcc_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 gfm = BIT(10);\r\nregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, 0);\r\n}\r\nstatic int __clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nconst struct freq_tbl *f;\r\nf = qcom_find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nreturn configure_bank(rcg, f);\r\n}\r\nstatic int clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn __clk_dyn_rcg_set_rate(hw, rate);\r\n}\r\nstatic int clk_dyn_rcg_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn __clk_dyn_rcg_set_rate(hw, rate);\r\n}
