static int sst25l_status(struct sst25l_flash *flash, int *status)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nunsigned char cmd_resp[2];\r\nint err;\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(struct spi_transfer));\r\ncmd_resp[0] = SST25L_CMD_RDSR;\r\ncmd_resp[1] = 0xff;\r\nt.tx_buf = cmd_resp;\r\nt.rx_buf = cmd_resp;\r\nt.len = sizeof(cmd_resp);\r\nspi_message_add_tail(&t, &m);\r\nerr = spi_sync(flash->spi, &m);\r\nif (err < 0)\r\nreturn err;\r\n*status = cmd_resp[1];\r\nreturn 0;\r\n}\r\nstatic int sst25l_write_enable(struct sst25l_flash *flash, int enable)\r\n{\r\nunsigned char command[2];\r\nint status, err;\r\ncommand[0] = enable ? SST25L_CMD_WREN : SST25L_CMD_WRDI;\r\nerr = spi_write(flash->spi, command, 1);\r\nif (err)\r\nreturn err;\r\ncommand[0] = SST25L_CMD_EWSR;\r\nerr = spi_write(flash->spi, command, 1);\r\nif (err)\r\nreturn err;\r\ncommand[0] = SST25L_CMD_WRSR;\r\ncommand[1] = enable ? 0 : SST25L_STATUS_BP0 | SST25L_STATUS_BP1;\r\nerr = spi_write(flash->spi, command, 2);\r\nif (err)\r\nreturn err;\r\nif (enable) {\r\nerr = sst25l_status(flash, &status);\r\nif (err)\r\nreturn err;\r\nif (!(status & SST25L_STATUS_WREN))\r\nreturn -EROFS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst25l_wait_till_ready(struct sst25l_flash *flash)\r\n{\r\nunsigned long deadline;\r\nint status, err;\r\ndeadline = jiffies + MAX_READY_WAIT_JIFFIES;\r\ndo {\r\nerr = sst25l_status(flash, &status);\r\nif (err)\r\nreturn err;\r\nif (!(status & SST25L_STATUS_BUSY))\r\nreturn 0;\r\ncond_resched();\r\n} while (!time_after_eq(jiffies, deadline));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int sst25l_erase_sector(struct sst25l_flash *flash, uint32_t offset)\r\n{\r\nunsigned char command[4];\r\nint err;\r\nerr = sst25l_write_enable(flash, 1);\r\nif (err)\r\nreturn err;\r\ncommand[0] = SST25L_CMD_SECTOR_ERASE;\r\ncommand[1] = offset >> 16;\r\ncommand[2] = offset >> 8;\r\ncommand[3] = offset;\r\nerr = spi_write(flash->spi, command, 4);\r\nif (err)\r\nreturn err;\r\nerr = sst25l_wait_till_ready(flash);\r\nif (err)\r\nreturn err;\r\nreturn sst25l_write_enable(flash, 0);\r\n}\r\nstatic int sst25l_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct sst25l_flash *flash = to_sst25l_flash(mtd);\r\nuint32_t addr, end;\r\nint err;\r\nif ((uint32_t)instr->len % mtd->erasesize)\r\nreturn -EINVAL;\r\nif ((uint32_t)instr->addr % mtd->erasesize)\r\nreturn -EINVAL;\r\naddr = instr->addr;\r\nend = addr + instr->len;\r\nmutex_lock(&flash->lock);\r\nerr = sst25l_wait_till_ready(flash);\r\nif (err) {\r\nmutex_unlock(&flash->lock);\r\nreturn err;\r\n}\r\nwhile (addr < end) {\r\nerr = sst25l_erase_sector(flash, addr);\r\nif (err) {\r\nmutex_unlock(&flash->lock);\r\ninstr->state = MTD_ERASE_FAILED;\r\ndev_err(&flash->spi->dev, "Erase failed\n");\r\nreturn err;\r\n}\r\naddr += mtd->erasesize;\r\n}\r\nmutex_unlock(&flash->lock);\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int sst25l_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, unsigned char *buf)\r\n{\r\nstruct sst25l_flash *flash = to_sst25l_flash(mtd);\r\nstruct spi_transfer transfer[2];\r\nstruct spi_message message;\r\nunsigned char command[4];\r\nint ret;\r\nspi_message_init(&message);\r\nmemset(&transfer, 0, sizeof(transfer));\r\ncommand[0] = SST25L_CMD_READ;\r\ncommand[1] = from >> 16;\r\ncommand[2] = from >> 8;\r\ncommand[3] = from;\r\ntransfer[0].tx_buf = command;\r\ntransfer[0].len = sizeof(command);\r\nspi_message_add_tail(&transfer[0], &message);\r\ntransfer[1].rx_buf = buf;\r\ntransfer[1].len = len;\r\nspi_message_add_tail(&transfer[1], &message);\r\nmutex_lock(&flash->lock);\r\nret = sst25l_wait_till_ready(flash);\r\nif (ret) {\r\nmutex_unlock(&flash->lock);\r\nreturn ret;\r\n}\r\nspi_sync(flash->spi, &message);\r\nif (retlen && message.actual_length > sizeof(command))\r\n*retlen += message.actual_length - sizeof(command);\r\nmutex_unlock(&flash->lock);\r\nreturn 0;\r\n}\r\nstatic int sst25l_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const unsigned char *buf)\r\n{\r\nstruct sst25l_flash *flash = to_sst25l_flash(mtd);\r\nint i, j, ret, bytes, copied = 0;\r\nunsigned char command[5];\r\nif ((uint32_t)to % mtd->writesize)\r\nreturn -EINVAL;\r\nmutex_lock(&flash->lock);\r\nret = sst25l_write_enable(flash, 1);\r\nif (ret)\r\ngoto out;\r\nfor (i = 0; i < len; i += mtd->writesize) {\r\nret = sst25l_wait_till_ready(flash);\r\nif (ret)\r\ngoto out;\r\ncommand[0] = SST25L_CMD_AAI_PROGRAM;\r\ncommand[1] = (to + i) >> 16;\r\ncommand[2] = (to + i) >> 8;\r\ncommand[3] = (to + i);\r\ncommand[4] = buf[i];\r\nret = spi_write(flash->spi, command, 5);\r\nif (ret < 0)\r\ngoto out;\r\ncopied++;\r\nbytes = min_t(uint32_t, mtd->writesize, len - i);\r\nfor (j = 1; j < bytes; j++, copied++) {\r\nret = sst25l_wait_till_ready(flash);\r\nif (ret)\r\ngoto out;\r\ncommand[1] = buf[i + j];\r\nret = spi_write(flash->spi, command, 2);\r\nif (ret)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nret = sst25l_write_enable(flash, 0);\r\nif (retlen)\r\n*retlen = copied;\r\nmutex_unlock(&flash->lock);\r\nreturn ret;\r\n}\r\nstatic struct flash_info *sst25l_match_device(struct spi_device *spi)\r\n{\r\nstruct flash_info *flash_info = NULL;\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nunsigned char cmd_resp[6];\r\nint i, err;\r\nuint16_t id;\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(struct spi_transfer));\r\ncmd_resp[0] = SST25L_CMD_READ_ID;\r\ncmd_resp[1] = 0;\r\ncmd_resp[2] = 0;\r\ncmd_resp[3] = 0;\r\ncmd_resp[4] = 0xff;\r\ncmd_resp[5] = 0xff;\r\nt.tx_buf = cmd_resp;\r\nt.rx_buf = cmd_resp;\r\nt.len = sizeof(cmd_resp);\r\nspi_message_add_tail(&t, &m);\r\nerr = spi_sync(spi, &m);\r\nif (err < 0) {\r\ndev_err(&spi->dev, "error reading device id\n");\r\nreturn NULL;\r\n}\r\nid = (cmd_resp[4] << 8) | cmd_resp[5];\r\nfor (i = 0; i < ARRAY_SIZE(sst25l_flash_info); i++)\r\nif (sst25l_flash_info[i].device_id == id)\r\nflash_info = &sst25l_flash_info[i];\r\nif (!flash_info)\r\ndev_err(&spi->dev, "unknown id %.4x\n", id);\r\nreturn flash_info;\r\n}\r\nstatic int sst25l_probe(struct spi_device *spi)\r\n{\r\nstruct flash_info *flash_info;\r\nstruct sst25l_flash *flash;\r\nstruct flash_platform_data *data;\r\nint ret;\r\nflash_info = sst25l_match_device(spi);\r\nif (!flash_info)\r\nreturn -ENODEV;\r\nflash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);\r\nif (!flash)\r\nreturn -ENOMEM;\r\nflash->spi = spi;\r\nmutex_init(&flash->lock);\r\nspi_set_drvdata(spi, flash);\r\ndata = dev_get_platdata(&spi->dev);\r\nif (data && data->name)\r\nflash->mtd.name = data->name;\r\nflash->mtd.dev.parent = &spi->dev;\r\nflash->mtd.type = MTD_NORFLASH;\r\nflash->mtd.flags = MTD_CAP_NORFLASH;\r\nflash->mtd.erasesize = flash_info->erase_size;\r\nflash->mtd.writesize = flash_info->page_size;\r\nflash->mtd.writebufsize = flash_info->page_size;\r\nflash->mtd.size = flash_info->page_size * flash_info->nr_pages;\r\nflash->mtd._erase = sst25l_erase;\r\nflash->mtd._read = sst25l_read;\r\nflash->mtd._write = sst25l_write;\r\ndev_info(&spi->dev, "%s (%lld KiB)\n", flash_info->name,\r\n(long long)flash->mtd.size >> 10);\r\npr_debug("mtd .name = %s, .size = 0x%llx (%lldMiB) "\r\n".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",\r\nflash->mtd.name,\r\n(long long)flash->mtd.size, (long long)(flash->mtd.size >> 20),\r\nflash->mtd.erasesize, flash->mtd.erasesize / 1024,\r\nflash->mtd.numeraseregions);\r\nret = mtd_device_parse_register(&flash->mtd, NULL, NULL,\r\ndata ? data->parts : NULL,\r\ndata ? data->nr_parts : 0);\r\nif (ret)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int sst25l_remove(struct spi_device *spi)\r\n{\r\nstruct sst25l_flash *flash = spi_get_drvdata(spi);\r\nreturn mtd_device_unregister(&flash->mtd);\r\n}
