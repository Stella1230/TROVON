int xen_remap_domain_gfn_array(struct vm_area_struct *vma,\r\nunsigned long addr,\r\nxen_pfn_t *gfn, int nr,\r\nint *err_ptr, pgprot_t prot,\r\nunsigned domid,\r\nstruct page **pages)\r\n{\r\nreturn xen_xlate_remap_gfn_array(vma, addr, gfn, nr, err_ptr,\r\nprot, domid, pages);\r\n}\r\nint xen_remap_domain_gfn_range(struct vm_area_struct *vma,\r\nunsigned long addr,\r\nxen_pfn_t gfn, int nr,\r\npgprot_t prot, unsigned domid,\r\nstruct page **pages)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint xen_unmap_domain_gfn_range(struct vm_area_struct *vma,\r\nint nr, struct page **pages)\r\n{\r\nreturn xen_xlate_unmap_gfn_range(vma, nr, pages);\r\n}\r\nstatic unsigned long long xen_stolen_accounting(int cpu)\r\n{\r\nstruct vcpu_runstate_info state;\r\nBUG_ON(cpu != smp_processor_id());\r\nxen_get_runstate_snapshot(&state);\r\nWARN_ON(state.state != RUNSTATE_running);\r\nreturn state.time[RUNSTATE_runnable] + state.time[RUNSTATE_offline];\r\n}\r\nstatic void xen_read_wallclock(struct timespec64 *ts)\r\n{\r\nu32 version;\r\nstruct timespec64 now, ts_monotonic;\r\nstruct shared_info *s = HYPERVISOR_shared_info;\r\nstruct pvclock_wall_clock *wall_clock = &(s->wc);\r\ndo {\r\nversion = wall_clock->version;\r\nrmb();\r\nnow.tv_sec = ((uint64_t)wall_clock->sec_hi << 32) | wall_clock->sec;\r\nnow.tv_nsec = wall_clock->nsec;\r\nrmb();\r\n} while ((wall_clock->version & 1) || (version != wall_clock->version));\r\nktime_get_ts64(&ts_monotonic);\r\n*ts = timespec64_add(now, ts_monotonic);\r\n}\r\nstatic int xen_pvclock_gtod_notify(struct notifier_block *nb,\r\nunsigned long was_set, void *priv)\r\n{\r\nstatic struct timespec64 next_sync;\r\nstruct xen_platform_op op;\r\nstruct timespec64 now, system_time;\r\nstruct timekeeper *tk = priv;\r\nnow.tv_sec = tk->xtime_sec;\r\nnow.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\r\nsystem_time = timespec64_add(now, tk->wall_to_monotonic);\r\nif (!was_set && timespec64_compare(&now, &next_sync) < 0)\r\nreturn NOTIFY_OK;\r\nop.cmd = XENPF_settime64;\r\nop.u.settime64.mbz = 0;\r\nop.u.settime64.secs = now.tv_sec;\r\nop.u.settime64.nsecs = now.tv_nsec;\r\nop.u.settime64.system_time = timespec64_to_ns(&system_time);\r\n(void)HYPERVISOR_platform_op(&op);\r\nnext_sync = now;\r\nnext_sync.tv_sec += 11 * 60;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void xen_percpu_init(void)\r\n{\r\nstruct vcpu_register_vcpu_info info;\r\nstruct vcpu_info *vcpup;\r\nint err;\r\nint cpu = get_cpu();\r\nif (per_cpu(xen_vcpu, cpu) != NULL)\r\ngoto after_register_vcpu_info;\r\npr_info("Xen: initializing cpu%d\n", cpu);\r\nvcpup = per_cpu_ptr(xen_vcpu_info, cpu);\r\ninfo.mfn = virt_to_gfn(vcpup);\r\ninfo.offset = xen_offset_in_page(vcpup);\r\nerr = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_info, cpu, &info);\r\nBUG_ON(err);\r\nper_cpu(xen_vcpu, cpu) = vcpup;\r\nxen_setup_runstate_info(cpu);\r\nafter_register_vcpu_info:\r\nenable_percpu_irq(xen_events_irq, 0);\r\nput_cpu();\r\n}\r\nstatic void xen_restart(enum reboot_mode reboot_mode, const char *cmd)\r\n{\r\nstruct sched_shutdown r = { .reason = SHUTDOWN_reboot };\r\nint rc;\r\nrc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);\r\nBUG_ON(rc);\r\n}\r\nstatic void xen_power_off(void)\r\n{\r\nstruct sched_shutdown r = { .reason = SHUTDOWN_poweroff };\r\nint rc;\r\nrc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);\r\nBUG_ON(rc);\r\n}\r\nstatic int xen_cpu_notification(struct notifier_block *self,\r\nunsigned long action,\r\nvoid *hcpu)\r\n{\r\nswitch (action) {\r\ncase CPU_STARTING:\r\nxen_percpu_init();\r\nbreak;\r\ncase CPU_DYING:\r\ndisable_percpu_irq(xen_events_irq);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic irqreturn_t xen_arm_callback(int irq, void *arg)\r\n{\r\nxen_hvm_evtchn_do_upcall();\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init xen_early_init(void)\r\n{\r\nint len;\r\nconst char *s = NULL;\r\nconst char *version = NULL;\r\nconst char *xen_prefix = "xen,xen-";\r\nxen_node = of_find_compatible_node(NULL, NULL, "xen,xen");\r\nif (!xen_node) {\r\npr_debug("No Xen support\n");\r\nreturn;\r\n}\r\ns = of_get_property(xen_node, "compatible", &len);\r\nif (strlen(xen_prefix) + 3 < len &&\r\n!strncmp(xen_prefix, s, strlen(xen_prefix)))\r\nversion = s + strlen(xen_prefix);\r\nif (version == NULL) {\r\npr_debug("Xen version not found\n");\r\nreturn;\r\n}\r\npr_info("Xen %s support found\n", version);\r\nxen_domain_type = XEN_HVM_DOMAIN;\r\nxen_setup_features();\r\nif (xen_feature(XENFEAT_dom0))\r\nxen_start_info->flags |= SIF_INITDOMAIN|SIF_PRIVILEGED;\r\nelse\r\nxen_start_info->flags &= ~(SIF_INITDOMAIN|SIF_PRIVILEGED);\r\nif (!console_set_on_cmdline && !xen_initial_domain())\r\nadd_preferred_console("hvc", 0, NULL);\r\n}\r\nstatic int __init xen_guest_init(void)\r\n{\r\nstruct xen_add_to_physmap xatp;\r\nstruct shared_info *shared_info_page = NULL;\r\nstruct resource res;\r\nphys_addr_t grant_frames;\r\nif (!xen_domain())\r\nreturn 0;\r\nif (of_address_to_resource(xen_node, GRANT_TABLE_PHYSADDR, &res)) {\r\npr_err("Xen grant table base address not found\n");\r\nreturn -ENODEV;\r\n}\r\ngrant_frames = res.start;\r\nxen_events_irq = irq_of_parse_and_map(xen_node, 0);\r\nif (!xen_events_irq) {\r\npr_err("Xen event channel interrupt not found\n");\r\nreturn -ENODEV;\r\n}\r\nshared_info_page = (struct shared_info *)get_zeroed_page(GFP_KERNEL);\r\nif (!shared_info_page) {\r\npr_err("not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nxatp.domid = DOMID_SELF;\r\nxatp.idx = 0;\r\nxatp.space = XENMAPSPACE_shared_info;\r\nxatp.gpfn = virt_to_gfn(shared_info_page);\r\nif (HYPERVISOR_memory_op(XENMEM_add_to_physmap, &xatp))\r\nBUG();\r\nHYPERVISOR_shared_info = (struct shared_info *)shared_info_page;\r\nxen_vcpu_info = __alloc_percpu(sizeof(struct vcpu_info),\r\nsizeof(struct vcpu_info));\r\nif (xen_vcpu_info == NULL)\r\nreturn -ENOMEM;\r\nif (gnttab_setup_auto_xlat_frames(grant_frames)) {\r\nfree_percpu(xen_vcpu_info);\r\nreturn -ENOMEM;\r\n}\r\ngnttab_init();\r\nif (!xen_initial_domain())\r\nxenbus_probe(NULL);\r\ndisable_cpuidle();\r\ndisable_cpufreq();\r\nxen_init_IRQ();\r\nif (request_percpu_irq(xen_events_irq, xen_arm_callback,\r\n"events", &xen_vcpu)) {\r\npr_err("Error request IRQ %d\n", xen_events_irq);\r\nreturn -EINVAL;\r\n}\r\nxen_percpu_init();\r\nregister_cpu_notifier(&xen_cpu_notifier);\r\npv_time_ops.steal_clock = xen_stolen_accounting;\r\nstatic_key_slow_inc(&paravirt_steal_enabled);\r\nif (xen_initial_domain())\r\npvclock_gtod_register_notifier(&xen_pvclock_gtod_notifier);\r\nreturn 0;\r\n}\r\nstatic int __init xen_pm_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\npm_power_off = xen_power_off;\r\narm_pm_restart = xen_restart;\r\nif (!xen_initial_domain()) {\r\nstruct timespec64 ts;\r\nxen_read_wallclock(&ts);\r\ndo_settimeofday64(&ts);\r\n}\r\nreturn 0;\r\n}\r\nvoid xen_arch_pre_suspend(void) { }\r\nvoid xen_arch_post_suspend(int suspend_cancelled) { }\r\nvoid xen_timer_resume(void) { }\r\nvoid xen_arch_resume(void) { }\r\nvoid xen_arch_suspend(void) { }
