static u8 mgmt_status(u8 hci_status)\r\n{\r\nif (hci_status < ARRAY_SIZE(mgmt_status_table))\r\nreturn mgmt_status_table[hci_status];\r\nreturn MGMT_STATUS_FAILED;\r\n}\r\nstatic int mgmt_index_event(u16 event, struct hci_dev *hdev, void *data,\r\nu16 len, int flag)\r\n{\r\nreturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\r\nflag, NULL);\r\n}\r\nstatic int mgmt_limited_event(u16 event, struct hci_dev *hdev, void *data,\r\nu16 len, int flag, struct sock *skip_sk)\r\n{\r\nreturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\r\nflag, skip_sk);\r\n}\r\nstatic int mgmt_generic_event(u16 event, struct hci_dev *hdev, void *data,\r\nu16 len, struct sock *skip_sk)\r\n{\r\nreturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\r\nHCI_MGMT_GENERIC_EVENTS, skip_sk);\r\n}\r\nstatic int mgmt_event(u16 event, struct hci_dev *hdev, void *data, u16 len,\r\nstruct sock *skip_sk)\r\n{\r\nreturn mgmt_send_event(event, hdev, HCI_CHANNEL_CONTROL, data, len,\r\nHCI_SOCK_TRUSTED, skip_sk);\r\n}\r\nstatic u8 le_addr_type(u8 mgmt_addr_type)\r\n{\r\nif (mgmt_addr_type == BDADDR_LE_PUBLIC)\r\nreturn ADDR_LE_DEV_PUBLIC;\r\nelse\r\nreturn ADDR_LE_DEV_RANDOM;\r\n}\r\nstatic int read_version(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_read_version rp;\r\nBT_DBG("sock %p", sk);\r\nrp.version = MGMT_VERSION;\r\nrp.revision = cpu_to_le16(MGMT_REVISION);\r\nreturn mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_VERSION, 0,\r\n&rp, sizeof(rp));\r\n}\r\nstatic int read_commands(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_read_commands *rp;\r\nu16 num_commands, num_events;\r\nsize_t rp_size;\r\nint i, err;\r\nBT_DBG("sock %p", sk);\r\nif (hci_sock_test_flag(sk, HCI_SOCK_TRUSTED)) {\r\nnum_commands = ARRAY_SIZE(mgmt_commands);\r\nnum_events = ARRAY_SIZE(mgmt_events);\r\n} else {\r\nnum_commands = ARRAY_SIZE(mgmt_untrusted_commands);\r\nnum_events = ARRAY_SIZE(mgmt_untrusted_events);\r\n}\r\nrp_size = sizeof(*rp) + ((num_commands + num_events) * sizeof(u16));\r\nrp = kmalloc(rp_size, GFP_KERNEL);\r\nif (!rp)\r\nreturn -ENOMEM;\r\nrp->num_commands = cpu_to_le16(num_commands);\r\nrp->num_events = cpu_to_le16(num_events);\r\nif (hci_sock_test_flag(sk, HCI_SOCK_TRUSTED)) {\r\n__le16 *opcode = rp->opcodes;\r\nfor (i = 0; i < num_commands; i++, opcode++)\r\nput_unaligned_le16(mgmt_commands[i], opcode);\r\nfor (i = 0; i < num_events; i++, opcode++)\r\nput_unaligned_le16(mgmt_events[i], opcode);\r\n} else {\r\n__le16 *opcode = rp->opcodes;\r\nfor (i = 0; i < num_commands; i++, opcode++)\r\nput_unaligned_le16(mgmt_untrusted_commands[i], opcode);\r\nfor (i = 0; i < num_events; i++, opcode++)\r\nput_unaligned_le16(mgmt_untrusted_events[i], opcode);\r\n}\r\nerr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_COMMANDS, 0,\r\nrp, rp_size);\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic int read_index_list(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_read_index_list *rp;\r\nstruct hci_dev *d;\r\nsize_t rp_len;\r\nu16 count;\r\nint err;\r\nBT_DBG("sock %p", sk);\r\nread_lock(&hci_dev_list_lock);\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (d->dev_type == HCI_BREDR &&\r\n!hci_dev_test_flag(d, HCI_UNCONFIGURED))\r\ncount++;\r\n}\r\nrp_len = sizeof(*rp) + (2 * count);\r\nrp = kmalloc(rp_len, GFP_ATOMIC);\r\nif (!rp) {\r\nread_unlock(&hci_dev_list_lock);\r\nreturn -ENOMEM;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (hci_dev_test_flag(d, HCI_SETUP) ||\r\nhci_dev_test_flag(d, HCI_CONFIG) ||\r\nhci_dev_test_flag(d, HCI_USER_CHANNEL))\r\ncontinue;\r\nif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\r\ncontinue;\r\nif (d->dev_type == HCI_BREDR &&\r\n!hci_dev_test_flag(d, HCI_UNCONFIGURED)) {\r\nrp->index[count++] = cpu_to_le16(d->id);\r\nBT_DBG("Added hci%u", d->id);\r\n}\r\n}\r\nrp->num_controllers = cpu_to_le16(count);\r\nrp_len = sizeof(*rp) + (2 * count);\r\nread_unlock(&hci_dev_list_lock);\r\nerr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE, MGMT_OP_READ_INDEX_LIST,\r\n0, rp, rp_len);\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic int read_unconf_index_list(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_rp_read_unconf_index_list *rp;\r\nstruct hci_dev *d;\r\nsize_t rp_len;\r\nu16 count;\r\nint err;\r\nBT_DBG("sock %p", sk);\r\nread_lock(&hci_dev_list_lock);\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (d->dev_type == HCI_BREDR &&\r\nhci_dev_test_flag(d, HCI_UNCONFIGURED))\r\ncount++;\r\n}\r\nrp_len = sizeof(*rp) + (2 * count);\r\nrp = kmalloc(rp_len, GFP_ATOMIC);\r\nif (!rp) {\r\nread_unlock(&hci_dev_list_lock);\r\nreturn -ENOMEM;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (hci_dev_test_flag(d, HCI_SETUP) ||\r\nhci_dev_test_flag(d, HCI_CONFIG) ||\r\nhci_dev_test_flag(d, HCI_USER_CHANNEL))\r\ncontinue;\r\nif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\r\ncontinue;\r\nif (d->dev_type == HCI_BREDR &&\r\nhci_dev_test_flag(d, HCI_UNCONFIGURED)) {\r\nrp->index[count++] = cpu_to_le16(d->id);\r\nBT_DBG("Added hci%u", d->id);\r\n}\r\n}\r\nrp->num_controllers = cpu_to_le16(count);\r\nrp_len = sizeof(*rp) + (2 * count);\r\nread_unlock(&hci_dev_list_lock);\r\nerr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\r\nMGMT_OP_READ_UNCONF_INDEX_LIST, 0, rp, rp_len);\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic int read_ext_index_list(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_rp_read_ext_index_list *rp;\r\nstruct hci_dev *d;\r\nsize_t rp_len;\r\nu16 count;\r\nint err;\r\nBT_DBG("sock %p", sk);\r\nread_lock(&hci_dev_list_lock);\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (d->dev_type == HCI_BREDR || d->dev_type == HCI_AMP)\r\ncount++;\r\n}\r\nrp_len = sizeof(*rp) + (sizeof(rp->entry[0]) * count);\r\nrp = kmalloc(rp_len, GFP_ATOMIC);\r\nif (!rp) {\r\nread_unlock(&hci_dev_list_lock);\r\nreturn -ENOMEM;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (hci_dev_test_flag(d, HCI_SETUP) ||\r\nhci_dev_test_flag(d, HCI_CONFIG) ||\r\nhci_dev_test_flag(d, HCI_USER_CHANNEL))\r\ncontinue;\r\nif (test_bit(HCI_QUIRK_RAW_DEVICE, &d->quirks))\r\ncontinue;\r\nif (d->dev_type == HCI_BREDR) {\r\nif (hci_dev_test_flag(d, HCI_UNCONFIGURED))\r\nrp->entry[count].type = 0x01;\r\nelse\r\nrp->entry[count].type = 0x00;\r\n} else if (d->dev_type == HCI_AMP) {\r\nrp->entry[count].type = 0x02;\r\n} else {\r\ncontinue;\r\n}\r\nrp->entry[count].bus = d->bus;\r\nrp->entry[count++].index = cpu_to_le16(d->id);\r\nBT_DBG("Added hci%u", d->id);\r\n}\r\nrp->num_controllers = cpu_to_le16(count);\r\nrp_len = sizeof(*rp) + (sizeof(rp->entry[0]) * count);\r\nread_unlock(&hci_dev_list_lock);\r\nhci_sock_set_flag(sk, HCI_MGMT_EXT_INDEX_EVENTS);\r\nhci_sock_clear_flag(sk, HCI_MGMT_INDEX_EVENTS);\r\nhci_sock_clear_flag(sk, HCI_MGMT_UNCONF_INDEX_EVENTS);\r\nerr = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,\r\nMGMT_OP_READ_EXT_INDEX_LIST, 0, rp, rp_len);\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic bool is_configured(struct hci_dev *hdev)\r\n{\r\nif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) &&\r\n!hci_dev_test_flag(hdev, HCI_EXT_CONFIGURED))\r\nreturn false;\r\nif (test_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks) &&\r\n!bacmp(&hdev->public_addr, BDADDR_ANY))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic __le32 get_missing_options(struct hci_dev *hdev)\r\n{\r\nu32 options = 0;\r\nif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) &&\r\n!hci_dev_test_flag(hdev, HCI_EXT_CONFIGURED))\r\noptions |= MGMT_OPTION_EXTERNAL_CONFIG;\r\nif (test_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks) &&\r\n!bacmp(&hdev->public_addr, BDADDR_ANY))\r\noptions |= MGMT_OPTION_PUBLIC_ADDRESS;\r\nreturn cpu_to_le32(options);\r\n}\r\nstatic int new_options(struct hci_dev *hdev, struct sock *skip)\r\n{\r\n__le32 options = get_missing_options(hdev);\r\nreturn mgmt_generic_event(MGMT_EV_NEW_CONFIG_OPTIONS, hdev, &options,\r\nsizeof(options), skip);\r\n}\r\nstatic int send_options_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)\r\n{\r\n__le32 options = get_missing_options(hdev);\r\nreturn mgmt_cmd_complete(sk, hdev->id, opcode, 0, &options,\r\nsizeof(options));\r\n}\r\nstatic int read_config_info(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_rp_read_config_info rp;\r\nu32 options = 0;\r\nBT_DBG("sock %p %s", sk, hdev->name);\r\nhci_dev_lock(hdev);\r\nmemset(&rp, 0, sizeof(rp));\r\nrp.manufacturer = cpu_to_le16(hdev->manufacturer);\r\nif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks))\r\noptions |= MGMT_OPTION_EXTERNAL_CONFIG;\r\nif (hdev->set_bdaddr)\r\noptions |= MGMT_OPTION_PUBLIC_ADDRESS;\r\nrp.supported_options = cpu_to_le32(options);\r\nrp.missing_options = get_missing_options(hdev);\r\nhci_dev_unlock(hdev);\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONFIG_INFO, 0,\r\n&rp, sizeof(rp));\r\n}\r\nstatic u32 get_supported_settings(struct hci_dev *hdev)\r\n{\r\nu32 settings = 0;\r\nsettings |= MGMT_SETTING_POWERED;\r\nsettings |= MGMT_SETTING_BONDABLE;\r\nsettings |= MGMT_SETTING_DEBUG_KEYS;\r\nsettings |= MGMT_SETTING_CONNECTABLE;\r\nsettings |= MGMT_SETTING_DISCOVERABLE;\r\nif (lmp_bredr_capable(hdev)) {\r\nif (hdev->hci_ver >= BLUETOOTH_VER_1_2)\r\nsettings |= MGMT_SETTING_FAST_CONNECTABLE;\r\nsettings |= MGMT_SETTING_BREDR;\r\nsettings |= MGMT_SETTING_LINK_SECURITY;\r\nif (lmp_ssp_capable(hdev)) {\r\nsettings |= MGMT_SETTING_SSP;\r\nsettings |= MGMT_SETTING_HS;\r\n}\r\nif (lmp_sc_capable(hdev))\r\nsettings |= MGMT_SETTING_SECURE_CONN;\r\n}\r\nif (lmp_le_capable(hdev)) {\r\nsettings |= MGMT_SETTING_LE;\r\nsettings |= MGMT_SETTING_ADVERTISING;\r\nsettings |= MGMT_SETTING_SECURE_CONN;\r\nsettings |= MGMT_SETTING_PRIVACY;\r\nsettings |= MGMT_SETTING_STATIC_ADDRESS;\r\n}\r\nif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) ||\r\nhdev->set_bdaddr)\r\nsettings |= MGMT_SETTING_CONFIGURATION;\r\nreturn settings;\r\n}\r\nstatic u32 get_current_settings(struct hci_dev *hdev)\r\n{\r\nu32 settings = 0;\r\nif (hdev_is_powered(hdev))\r\nsettings |= MGMT_SETTING_POWERED;\r\nif (hci_dev_test_flag(hdev, HCI_CONNECTABLE))\r\nsettings |= MGMT_SETTING_CONNECTABLE;\r\nif (hci_dev_test_flag(hdev, HCI_FAST_CONNECTABLE))\r\nsettings |= MGMT_SETTING_FAST_CONNECTABLE;\r\nif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\r\nsettings |= MGMT_SETTING_DISCOVERABLE;\r\nif (hci_dev_test_flag(hdev, HCI_BONDABLE))\r\nsettings |= MGMT_SETTING_BONDABLE;\r\nif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\r\nsettings |= MGMT_SETTING_BREDR;\r\nif (hci_dev_test_flag(hdev, HCI_LE_ENABLED))\r\nsettings |= MGMT_SETTING_LE;\r\nif (hci_dev_test_flag(hdev, HCI_LINK_SECURITY))\r\nsettings |= MGMT_SETTING_LINK_SECURITY;\r\nif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\r\nsettings |= MGMT_SETTING_SSP;\r\nif (hci_dev_test_flag(hdev, HCI_HS_ENABLED))\r\nsettings |= MGMT_SETTING_HS;\r\nif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\r\nsettings |= MGMT_SETTING_ADVERTISING;\r\nif (hci_dev_test_flag(hdev, HCI_SC_ENABLED))\r\nsettings |= MGMT_SETTING_SECURE_CONN;\r\nif (hci_dev_test_flag(hdev, HCI_KEEP_DEBUG_KEYS))\r\nsettings |= MGMT_SETTING_DEBUG_KEYS;\r\nif (hci_dev_test_flag(hdev, HCI_PRIVACY))\r\nsettings |= MGMT_SETTING_PRIVACY;\r\nif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\r\n!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) ||\r\n!bacmp(&hdev->bdaddr, BDADDR_ANY)) {\r\nif (bacmp(&hdev->static_addr, BDADDR_ANY))\r\nsettings |= MGMT_SETTING_STATIC_ADDRESS;\r\n}\r\nreturn settings;\r\n}\r\nstatic struct mgmt_pending_cmd *pending_find(u16 opcode, struct hci_dev *hdev)\r\n{\r\nreturn mgmt_pending_find(HCI_CHANNEL_CONTROL, opcode, hdev);\r\n}\r\nstatic struct mgmt_pending_cmd *pending_find_data(u16 opcode,\r\nstruct hci_dev *hdev,\r\nconst void *data)\r\n{\r\nreturn mgmt_pending_find_data(HCI_CHANNEL_CONTROL, opcode, hdev, data);\r\n}\r\nu8 mgmt_get_adv_discov_flags(struct hci_dev *hdev)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\ncmd = pending_find(MGMT_OP_SET_DISCOVERABLE, hdev);\r\nif (cmd) {\r\nstruct mgmt_mode *cp = cmd->param;\r\nif (cp->val == 0x01)\r\nreturn LE_AD_GENERAL;\r\nelse if (cp->val == 0x02)\r\nreturn LE_AD_LIMITED;\r\n} else {\r\nif (hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE))\r\nreturn LE_AD_LIMITED;\r\nelse if (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\r\nreturn LE_AD_GENERAL;\r\n}\r\nreturn 0;\r\n}\r\nbool mgmt_get_connectable(struct hci_dev *hdev)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\ncmd = pending_find(MGMT_OP_SET_CONNECTABLE, hdev);\r\nif (cmd) {\r\nstruct mgmt_mode *cp = cmd->param;\r\nreturn cp->val;\r\n}\r\nreturn hci_dev_test_flag(hdev, HCI_CONNECTABLE);\r\n}\r\nstatic void service_cache_off(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev,\r\nservice_cache.work);\r\nstruct hci_request req;\r\nif (!hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE))\r\nreturn;\r\nhci_req_init(&req, hdev);\r\nhci_dev_lock(hdev);\r\n__hci_req_update_eir(&req);\r\n__hci_req_update_class(&req);\r\nhci_dev_unlock(hdev);\r\nhci_req_run(&req, NULL);\r\n}\r\nstatic void rpa_expired(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev,\r\nrpa_expired.work);\r\nstruct hci_request req;\r\nBT_DBG("");\r\nhci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\r\nif (!hci_dev_test_flag(hdev, HCI_ADVERTISING))\r\nreturn;\r\nhci_req_init(&req, hdev);\r\n__hci_req_enable_advertising(&req);\r\nhci_req_run(&req, NULL);\r\n}\r\nstatic void mgmt_init_hdev(struct sock *sk, struct hci_dev *hdev)\r\n{\r\nif (hci_dev_test_and_set_flag(hdev, HCI_MGMT))\r\nreturn;\r\nINIT_DELAYED_WORK(&hdev->service_cache, service_cache_off);\r\nINIT_DELAYED_WORK(&hdev->rpa_expired, rpa_expired);\r\nhci_dev_clear_flag(hdev, HCI_BONDABLE);\r\n}\r\nstatic int read_controller_info(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_rp_read_info rp;\r\nBT_DBG("sock %p %s", sk, hdev->name);\r\nhci_dev_lock(hdev);\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.bdaddr, &hdev->bdaddr);\r\nrp.version = hdev->hci_ver;\r\nrp.manufacturer = cpu_to_le16(hdev->manufacturer);\r\nrp.supported_settings = cpu_to_le32(get_supported_settings(hdev));\r\nrp.current_settings = cpu_to_le32(get_current_settings(hdev));\r\nmemcpy(rp.dev_class, hdev->dev_class, 3);\r\nmemcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));\r\nmemcpy(rp.short_name, hdev->short_name, sizeof(hdev->short_name));\r\nhci_dev_unlock(hdev);\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_INFO, 0, &rp,\r\nsizeof(rp));\r\n}\r\nstatic int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)\r\n{\r\n__le32 settings = cpu_to_le32(get_current_settings(hdev));\r\nreturn mgmt_cmd_complete(sk, hdev->id, opcode, 0, &settings,\r\nsizeof(settings));\r\n}\r\nstatic void clean_up_hci_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nBT_DBG("%s status 0x%02x", hdev->name, status);\r\nif (hci_conn_count(hdev) == 0) {\r\ncancel_delayed_work(&hdev->power_off);\r\nqueue_work(hdev->req_workqueue, &hdev->power_off.work);\r\n}\r\n}\r\nvoid mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev, u8 instance)\r\n{\r\nstruct mgmt_ev_advertising_added ev;\r\nev.instance = instance;\r\nmgmt_event(MGMT_EV_ADVERTISING_ADDED, hdev, &ev, sizeof(ev), sk);\r\n}\r\nvoid mgmt_advertising_removed(struct sock *sk, struct hci_dev *hdev,\r\nu8 instance)\r\n{\r\nstruct mgmt_ev_advertising_removed ev;\r\nev.instance = instance;\r\nmgmt_event(MGMT_EV_ADVERTISING_REMOVED, hdev, &ev, sizeof(ev), sk);\r\n}\r\nstatic void cancel_adv_timeout(struct hci_dev *hdev)\r\n{\r\nif (hdev->adv_instance_timeout) {\r\nhdev->adv_instance_timeout = 0;\r\ncancel_delayed_work(&hdev->adv_instance_expire);\r\n}\r\n}\r\nstatic int clean_up_hci_state(struct hci_dev *hdev)\r\n{\r\nstruct hci_request req;\r\nstruct hci_conn *conn;\r\nbool discov_stopped;\r\nint err;\r\nhci_req_init(&req, hdev);\r\nif (test_bit(HCI_ISCAN, &hdev->flags) ||\r\ntest_bit(HCI_PSCAN, &hdev->flags)) {\r\nu8 scan = 0x00;\r\nhci_req_add(&req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);\r\n}\r\nhci_req_clear_adv_instance(hdev, NULL, 0x00, false);\r\nif (hci_dev_test_flag(hdev, HCI_LE_ADV))\r\n__hci_req_disable_advertising(&req);\r\ndiscov_stopped = hci_req_stop_discovery(&req);\r\nlist_for_each_entry(conn, &hdev->conn_hash.list, list) {\r\n__hci_abort_conn(&req, conn, 0x15);\r\n}\r\nerr = hci_req_run(&req, clean_up_hci_complete);\r\nif (!err && discov_stopped)\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPING);\r\nreturn err;\r\n}\r\nstatic int set_powered(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (pending_find(MGMT_OP_SET_POWERED, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_POWERED,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nif (!!cp->val == hdev_is_powered(hdev)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (cp->val) {\r\nqueue_work(hdev->req_workqueue, &hdev->power_on);\r\nerr = 0;\r\n} else {\r\nerr = clean_up_hci_state(hdev);\r\nif (!err)\r\nqueue_delayed_work(hdev->req_workqueue, &hdev->power_off,\r\nHCI_POWER_OFF_TIMEOUT);\r\nif (err == -ENODATA) {\r\ncancel_delayed_work(&hdev->power_off);\r\nqueue_work(hdev->req_workqueue, &hdev->power_off.work);\r\nerr = 0;\r\n}\r\n}\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int new_settings(struct hci_dev *hdev, struct sock *skip)\r\n{\r\n__le32 ev = cpu_to_le32(get_current_settings(hdev));\r\nreturn mgmt_generic_event(MGMT_EV_NEW_SETTINGS, hdev, &ev,\r\nsizeof(ev), skip);\r\n}\r\nint mgmt_new_settings(struct hci_dev *hdev)\r\n{\r\nreturn new_settings(hdev, NULL);\r\n}\r\nstatic void settings_rsp(struct mgmt_pending_cmd *cmd, void *data)\r\n{\r\nstruct cmd_lookup *match = data;\r\nsend_settings_rsp(cmd->sk, cmd->opcode, match->hdev);\r\nlist_del(&cmd->list);\r\nif (match->sk == NULL) {\r\nmatch->sk = cmd->sk;\r\nsock_hold(match->sk);\r\n}\r\nmgmt_pending_free(cmd);\r\n}\r\nstatic void cmd_status_rsp(struct mgmt_pending_cmd *cmd, void *data)\r\n{\r\nu8 *status = data;\r\nmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, *status);\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic void cmd_complete_rsp(struct mgmt_pending_cmd *cmd, void *data)\r\n{\r\nif (cmd->cmd_complete) {\r\nu8 *status = data;\r\ncmd->cmd_complete(cmd, *status);\r\nmgmt_pending_remove(cmd);\r\nreturn;\r\n}\r\ncmd_status_rsp(cmd, data);\r\n}\r\nstatic int generic_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\r\n{\r\nreturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\r\ncmd->param, cmd->param_len);\r\n}\r\nstatic int addr_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\r\n{\r\nreturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\r\ncmd->param, sizeof(struct mgmt_addr_info));\r\n}\r\nstatic u8 mgmt_bredr_support(struct hci_dev *hdev)\r\n{\r\nif (!lmp_bredr_capable(hdev))\r\nreturn MGMT_STATUS_NOT_SUPPORTED;\r\nelse if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\r\nreturn MGMT_STATUS_REJECTED;\r\nelse\r\nreturn MGMT_STATUS_SUCCESS;\r\n}\r\nstatic u8 mgmt_le_support(struct hci_dev *hdev)\r\n{\r\nif (!lmp_le_capable(hdev))\r\nreturn MGMT_STATUS_NOT_SUPPORTED;\r\nelse if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\r\nreturn MGMT_STATUS_REJECTED;\r\nelse\r\nreturn MGMT_STATUS_SUCCESS;\r\n}\r\nvoid mgmt_set_discoverable_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_SET_DISCOVERABLE, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\r\nhci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\r\ngoto remove_cmd;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\r\nhdev->discov_timeout > 0) {\r\nint to = msecs_to_jiffies(hdev->discov_timeout * 1000);\r\nqueue_delayed_work(hdev->req_workqueue, &hdev->discov_off, to);\r\n}\r\nsend_settings_rsp(cmd->sk, MGMT_OP_SET_DISCOVERABLE, hdev);\r\nnew_settings(hdev, cmd->sk);\r\nremove_cmd:\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_discoverable(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_discoverable *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nu16 timeout;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) &&\r\n!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_REJECTED);\r\nif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ntimeout = __le16_to_cpu(cp->timeout);\r\nif ((cp->val == 0x00 && timeout > 0) ||\r\n(cp->val == 0x02 && timeout == 0))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev) && timeout > 0) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto failed;\r\n}\r\nif (pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\r\npending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_CONNECTABLE)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DISCOVERABLE,\r\nMGMT_STATUS_REJECTED);\r\ngoto failed;\r\n}\r\nif (!hdev_is_powered(hdev)) {\r\nbool changed = false;\r\nif (!!cp->val != hci_dev_test_flag(hdev, HCI_DISCOVERABLE)) {\r\nhci_dev_change_flag(hdev, HCI_DISCOVERABLE);\r\nchanged = true;\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (!!cp->val == hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\r\n(cp->val == 0x02) == hci_dev_test_flag(hdev,\r\nHCI_LIMITED_DISCOVERABLE)) {\r\ncancel_delayed_work(&hdev->discov_off);\r\nhdev->discov_timeout = timeout;\r\nif (cp->val && hdev->discov_timeout > 0) {\r\nint to = msecs_to_jiffies(hdev->discov_timeout * 1000);\r\nqueue_delayed_work(hdev->req_workqueue,\r\n&hdev->discov_off, to);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\ncancel_delayed_work(&hdev->discov_off);\r\nhdev->discov_timeout = timeout;\r\nif (cp->val)\r\nhci_dev_set_flag(hdev, HCI_DISCOVERABLE);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\r\nif (cp->val == 0x02)\r\nhci_dev_set_flag(hdev, HCI_LIMITED_DISCOVERABLE);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\r\nqueue_work(hdev->req_workqueue, &hdev->discoverable_update);\r\nerr = 0;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nvoid mgmt_set_connectable_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_SET_CONNECTABLE, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\r\ngoto remove_cmd;\r\n}\r\nsend_settings_rsp(cmd->sk, MGMT_OP_SET_CONNECTABLE, hdev);\r\nnew_settings(hdev, cmd->sk);\r\nremove_cmd:\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_connectable_update_settings(struct hci_dev *hdev,\r\nstruct sock *sk, u8 val)\r\n{\r\nbool changed = false;\r\nint err;\r\nif (!!val != hci_dev_test_flag(hdev, HCI_CONNECTABLE))\r\nchanged = true;\r\nif (val) {\r\nhci_dev_set_flag(hdev, HCI_CONNECTABLE);\r\n} else {\r\nhci_dev_clear_flag(hdev, HCI_CONNECTABLE);\r\nhci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);\r\nif (err < 0)\r\nreturn err;\r\nif (changed) {\r\nhci_req_update_scan(hdev);\r\nhci_update_background_scan(hdev);\r\nreturn new_settings(hdev, sk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED) &&\r\n!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\r\nMGMT_STATUS_REJECTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = set_connectable_update_settings(hdev, sk, cp->val);\r\ngoto failed;\r\n}\r\nif (pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||\r\npending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_CONNECTABLE,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (cp->val) {\r\nhci_dev_set_flag(hdev, HCI_CONNECTABLE);\r\n} else {\r\nif (hdev->discov_timeout > 0)\r\ncancel_delayed_work(&hdev->discov_off);\r\nhci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\r\nhci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\r\nhci_dev_clear_flag(hdev, HCI_CONNECTABLE);\r\n}\r\nqueue_work(hdev->req_workqueue, &hdev->connectable_update);\r\nerr = 0;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_bondable(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nbool changed;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BONDABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (cp->val)\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_BONDABLE);\r\nelse\r\nchanged = hci_dev_test_and_clear_flag(hdev, HCI_BONDABLE);\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_BONDABLE, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (changed) {\r\nif (hdev_is_powered(hdev) &&\r\nhci_dev_test_flag(hdev, HCI_ADVERTISING) &&\r\nhci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&\r\nhci_dev_test_flag(hdev, HCI_LIMITED_PRIVACY))\r\nqueue_work(hdev->req_workqueue,\r\n&hdev->discoverable_update);\r\nerr = new_settings(hdev, sk);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_link_security(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nu8 val, status;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nstatus = mgmt_bredr_support(hdev);\r\nif (status)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\r\nstatus);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nbool changed = false;\r\nif (!!cp->val != hci_dev_test_flag(hdev, HCI_LINK_SECURITY)) {\r\nhci_dev_change_flag(hdev, HCI_LINK_SECURITY);\r\nchanged = true;\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (pending_find(MGMT_OP_SET_LINK_SECURITY, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LINK_SECURITY,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nval = !!cp->val;\r\nif (test_bit(HCI_AUTH, &hdev->flags) == val) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_LINK_SECURITY, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_LINK_SECURITY, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nerr = hci_send_cmd(hdev, HCI_OP_WRITE_AUTH_ENABLE, sizeof(val), &val);\r\nif (err < 0) {\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_ssp(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nu8 status;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nstatus = mgmt_bredr_support(hdev);\r\nif (status)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP, status);\r\nif (!lmp_ssp_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nbool changed;\r\nif (cp->val) {\r\nchanged = !hci_dev_test_and_set_flag(hdev,\r\nHCI_SSP_ENABLED);\r\n} else {\r\nchanged = hci_dev_test_and_clear_flag(hdev,\r\nHCI_SSP_ENABLED);\r\nif (!changed)\r\nchanged = hci_dev_test_and_clear_flag(hdev,\r\nHCI_HS_ENABLED);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_HS_ENABLED);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (pending_find(MGMT_OP_SET_SSP, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SSP,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nif (!!cp->val == hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_SSP, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_SSP, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (!cp->val && hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS))\r\nhci_send_cmd(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE,\r\nsizeof(cp->val), &cp->val);\r\nerr = hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE, 1, &cp->val);\r\nif (err < 0) {\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_hs(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nbool changed;\r\nu8 status;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nstatus = mgmt_bredr_support(hdev);\r\nif (status)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS, status);\r\nif (!lmp_ssp_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (!hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\r\nMGMT_STATUS_REJECTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (pending_find(MGMT_OP_SET_SSP, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif (cp->val) {\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_HS_ENABLED);\r\n} else {\r\nif (hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_HS,\r\nMGMT_STATUS_REJECTED);\r\ngoto unlock;\r\n}\r\nchanged = hci_dev_test_and_clear_flag(hdev, HCI_HS_ENABLED);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_HS, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void le_enable_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nhci_dev_lock(hdev);\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, cmd_status_rsp,\r\n&mgmt_err);\r\ngoto unlock;\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_LE, hdev, settings_rsp, &match);\r\nnew_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nif (hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\r\nstruct hci_request req;\r\nhci_req_init(&req, hdev);\r\n__hci_req_update_adv_data(&req, 0x00);\r\n__hci_req_update_scan_rsp_data(&req, 0x00);\r\nhci_req_run(&req, NULL);\r\nhci_update_background_scan(hdev);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_le(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct hci_cp_write_le_host_supported hci_cp;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nu8 val, enabled;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\r\nif (cp->val == 0x01)\r\nreturn send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_REJECTED);\r\n}\r\nhci_dev_lock(hdev);\r\nval = !!cp->val;\r\nenabled = lmp_host_le_capable(hdev);\r\nif (!val)\r\nhci_req_clear_adv_instance(hdev, NULL, 0x00, true);\r\nif (!hdev_is_powered(hdev) || val == enabled) {\r\nbool changed = false;\r\nif (val != hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\r\nhci_dev_change_flag(hdev, HCI_LE_ENABLED);\r\nchanged = true;\r\n}\r\nif (!val && hci_dev_test_flag(hdev, HCI_ADVERTISING)) {\r\nhci_dev_clear_flag(hdev, HCI_ADVERTISING);\r\nchanged = true;\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_LE, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto unlock;\r\n}\r\nif (pending_find(MGMT_OP_SET_LE, hdev) ||\r\npending_find(MGMT_OP_SET_ADVERTISING, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_LE,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_LE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nmemset(&hci_cp, 0, sizeof(hci_cp));\r\nif (val) {\r\nhci_cp.le = val;\r\nhci_cp.simul = 0x00;\r\n} else {\r\nif (hci_dev_test_flag(hdev, HCI_LE_ADV))\r\n__hci_req_disable_advertising(&req);\r\n}\r\nhci_req_add(&req, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(hci_cp),\r\n&hci_cp);\r\nerr = hci_req_run(&req, le_enable_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool pending_eir_or_class(struct hci_dev *hdev)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\r\nswitch (cmd->opcode) {\r\ncase MGMT_OP_ADD_UUID:\r\ncase MGMT_OP_REMOVE_UUID:\r\ncase MGMT_OP_SET_DEV_CLASS:\r\ncase MGMT_OP_SET_POWERED:\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic u8 get_uuid_size(const u8 *uuid)\r\n{\r\nu32 val;\r\nif (memcmp(uuid, bluetooth_base_uuid, 12))\r\nreturn 128;\r\nval = get_unaligned_le32(&uuid[12]);\r\nif (val > 0xffff)\r\nreturn 32;\r\nreturn 16;\r\n}\r\nstatic void mgmt_class_complete(struct hci_dev *hdev, u16 mgmt_op, u8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(mgmt_op, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\r\nmgmt_status(status), hdev->dev_class, 3);\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void add_uuid_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nBT_DBG("status 0x%02x", status);\r\nmgmt_class_complete(hdev, MGMT_OP_ADD_UUID, status);\r\n}\r\nstatic int add_uuid(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_cp_add_uuid *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nstruct bt_uuid *uuid;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (pending_eir_or_class(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_UUID,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nuuid = kmalloc(sizeof(*uuid), GFP_KERNEL);\r\nif (!uuid) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nmemcpy(uuid->uuid, cp->uuid, 16);\r\nuuid->svc_hint = cp->svc_hint;\r\nuuid->size = get_uuid_size(cp->uuid);\r\nlist_add_tail(&uuid->list, &hdev->uuids);\r\nhci_req_init(&req, hdev);\r\n__hci_req_update_class(&req);\r\n__hci_req_update_eir(&req);\r\nerr = hci_req_run(&req, add_uuid_complete);\r\nif (err < 0) {\r\nif (err != -ENODATA)\r\ngoto failed;\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_UUID, 0,\r\nhdev->dev_class, 3);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_ADD_UUID, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nerr = 0;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool enable_service_cache(struct hci_dev *hdev)\r\n{\r\nif (!hdev_is_powered(hdev))\r\nreturn false;\r\nif (!hci_dev_test_and_set_flag(hdev, HCI_SERVICE_CACHE)) {\r\nqueue_delayed_work(hdev->workqueue, &hdev->service_cache,\r\nCACHE_TIMEOUT);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void remove_uuid_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nBT_DBG("status 0x%02x", status);\r\nmgmt_class_complete(hdev, MGMT_OP_REMOVE_UUID, status);\r\n}\r\nstatic int remove_uuid(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_remove_uuid *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct bt_uuid *match, *tmp;\r\nu8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nstruct hci_request req;\r\nint err, found;\r\nBT_DBG("request for %s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (pending_eir_or_class(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {\r\nhci_uuids_clear(hdev);\r\nif (enable_service_cache(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_UUID,\r\n0, hdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\ngoto update_class;\r\n}\r\nfound = 0;\r\nlist_for_each_entry_safe(match, tmp, &hdev->uuids, list) {\r\nif (memcmp(match->uuid, cp->uuid, 16) != 0)\r\ncontinue;\r\nlist_del(&match->list);\r\nkfree(match);\r\nfound++;\r\n}\r\nif (found == 0) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_UUID,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nupdate_class:\r\nhci_req_init(&req, hdev);\r\n__hci_req_update_class(&req);\r\n__hci_req_update_eir(&req);\r\nerr = hci_req_run(&req, remove_uuid_complete);\r\nif (err < 0) {\r\nif (err != -ENODATA)\r\ngoto unlock;\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_UUID, 0,\r\nhdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_UUID, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nerr = 0;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void set_class_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nBT_DBG("status 0x%02x", status);\r\nmgmt_class_complete(hdev, MGMT_OP_SET_DEV_CLASS, status);\r\n}\r\nstatic int set_dev_class(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_dev_class *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_bredr_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nhci_dev_lock(hdev);\r\nif (pending_eir_or_class(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif ((cp->minor & 0x03) != 0 || (cp->major & 0xe0) != 0) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEV_CLASS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nhdev->major_class = cp->major;\r\nhdev->minor_class = cp->minor;\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,\r\nhdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nif (hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE)) {\r\nhci_dev_unlock(hdev);\r\ncancel_delayed_work_sync(&hdev->service_cache);\r\nhci_dev_lock(hdev);\r\n__hci_req_update_eir(&req);\r\n}\r\n__hci_req_update_class(&req);\r\nerr = hci_req_run(&req, set_class_complete);\r\nif (err < 0) {\r\nif (err != -ENODATA)\r\ngoto unlock;\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEV_CLASS, 0,\r\nhdev->dev_class, 3);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_DEV_CLASS, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nerr = 0;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int load_link_keys(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_load_link_keys *cp = data;\r\nconst u16 max_key_count = ((U16_MAX - sizeof(*cp)) /\r\nsizeof(struct mgmt_link_key_info));\r\nu16 key_count, expected_len;\r\nbool changed;\r\nint i;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_bredr_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nkey_count = __le16_to_cpu(cp->key_count);\r\nif (key_count > max_key_count) {\r\nBT_ERR("load_link_keys: too big key_count value %u",\r\nkey_count);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nexpected_len = sizeof(*cp) + key_count *\r\nsizeof(struct mgmt_link_key_info);\r\nif (expected_len != len) {\r\nBT_ERR("load_link_keys: expected %u bytes, got %u bytes",\r\nexpected_len, len);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nif (cp->debug_keys != 0x00 && cp->debug_keys != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nBT_DBG("%s debug_keys %u key_count %u", hdev->name, cp->debug_keys,\r\nkey_count);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_link_key_info *key = &cp->keys[i];\r\nif (key->addr.type != BDADDR_BREDR || key->type > 0x08)\r\nreturn mgmt_cmd_status(sk, hdev->id,\r\nMGMT_OP_LOAD_LINK_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nhci_dev_lock(hdev);\r\nhci_link_keys_clear(hdev);\r\nif (cp->debug_keys)\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_KEEP_DEBUG_KEYS);\r\nelse\r\nchanged = hci_dev_test_and_clear_flag(hdev,\r\nHCI_KEEP_DEBUG_KEYS);\r\nif (changed)\r\nnew_settings(hdev, NULL);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_link_key_info *key = &cp->keys[i];\r\nif (key->type == HCI_LK_DEBUG_COMBINATION)\r\ncontinue;\r\nhci_add_link_key(hdev, NULL, &key->addr.bdaddr, key->val,\r\nkey->type, key->pin_len, NULL);\r\n}\r\nmgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LINK_KEYS, 0, NULL, 0);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int device_unpaired(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 addr_type, struct sock *skip_sk)\r\n{\r\nstruct mgmt_ev_device_unpaired ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = addr_type;\r\nreturn mgmt_event(MGMT_EV_DEVICE_UNPAIRED, hdev, &ev, sizeof(ev),\r\nskip_sk);\r\n}\r\nstatic int unpair_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_unpair_device *cp = data;\r\nstruct mgmt_rp_unpair_device rp;\r\nstruct hci_conn_params *params;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nu8 addr_type;\r\nint err;\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nif (cp->disconnect != 0x00 && cp->disconnect != 0x01)\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_NOT_POWERED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nif (cp->addr.type == BDADDR_BREDR) {\r\nif (cp->disconnect)\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\r\n&cp->addr.bdaddr);\r\nelse\r\nconn = NULL;\r\nerr = hci_remove_link_key(hdev, &cp->addr.bdaddr);\r\nif (err < 0) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_NOT_PAIRED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\ngoto done;\r\n}\r\naddr_type = le_addr_type(cp->addr.type);\r\nhci_remove_irk(hdev, &cp->addr.bdaddr, addr_type);\r\nerr = hci_remove_ltk(hdev, &cp->addr.bdaddr, addr_type);\r\nif (err < 0) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE,\r\nMGMT_STATUS_NOT_PAIRED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nconn = hci_conn_hash_lookup_le(hdev, &cp->addr.bdaddr, addr_type);\r\nif (!conn) {\r\nhci_conn_params_del(hdev, &cp->addr.bdaddr, addr_type);\r\ngoto done;\r\n}\r\nsmp_cancel_pairing(conn);\r\nset_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags);\r\nparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr, addr_type);\r\nif (params) {\r\nif (params->explicit_connect)\r\nparams->auto_connect = HCI_AUTO_CONN_EXPLICIT;\r\nelse\r\nparams->auto_connect = HCI_AUTO_CONN_DISABLED;\r\n}\r\nif (!cp->disconnect)\r\nconn = NULL;\r\ndone:\r\nif (!conn) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNPAIR_DEVICE, 0,\r\n&rp, sizeof(rp));\r\ndevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, sk);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_UNPAIR_DEVICE, hdev, cp,\r\nsizeof(*cp));\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ncmd->cmd_complete = addr_cmd_complete;\r\nerr = hci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int disconnect(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_disconnect *cp = data;\r\nstruct mgmt_rp_disconnect rp;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nint err;\r\nBT_DBG("");\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!test_bit(HCI_UP, &hdev->flags)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_NOT_POWERED, &rp,\r\nsizeof(rp));\r\ngoto failed;\r\n}\r\nif (pending_find(MGMT_OP_DISCONNECT, hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_BUSY, &rp, sizeof(rp));\r\ngoto failed;\r\n}\r\nif (cp->addr.type == BDADDR_BREDR)\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\r\n&cp->addr.bdaddr);\r\nelse\r\nconn = hci_conn_hash_lookup_le(hdev, &cp->addr.bdaddr,\r\nle_addr_type(cp->addr.type));\r\nif (!conn || conn->state == BT_OPEN || conn->state == BT_CLOSED) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_DISCONNECT,\r\nMGMT_STATUS_NOT_CONNECTED, &rp,\r\nsizeof(rp));\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\ncmd->cmd_complete = generic_cmd_complete;\r\nerr = hci_disconnect(conn, HCI_ERROR_REMOTE_USER_TERM);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic u8 link_to_bdaddr(u8 link_type, u8 addr_type)\r\n{\r\nswitch (link_type) {\r\ncase LE_LINK:\r\nswitch (addr_type) {\r\ncase ADDR_LE_DEV_PUBLIC:\r\nreturn BDADDR_LE_PUBLIC;\r\ndefault:\r\nreturn BDADDR_LE_RANDOM;\r\n}\r\ndefault:\r\nreturn BDADDR_BREDR;\r\n}\r\n}\r\nstatic int get_connections(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 data_len)\r\n{\r\nstruct mgmt_rp_get_connections *rp;\r\nstruct hci_conn *c;\r\nsize_t rp_len;\r\nint err;\r\nu16 i;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_CONNECTIONS,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto unlock;\r\n}\r\ni = 0;\r\nlist_for_each_entry(c, &hdev->conn_hash.list, list) {\r\nif (test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\r\ni++;\r\n}\r\nrp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));\r\nrp = kmalloc(rp_len, GFP_KERNEL);\r\nif (!rp) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ni = 0;\r\nlist_for_each_entry(c, &hdev->conn_hash.list, list) {\r\nif (!test_bit(HCI_CONN_MGMT_CONNECTED, &c->flags))\r\ncontinue;\r\nbacpy(&rp->addr[i].bdaddr, &c->dst);\r\nrp->addr[i].type = link_to_bdaddr(c->type, c->dst_type);\r\nif (c->type == SCO_LINK || c->type == ESCO_LINK)\r\ncontinue;\r\ni++;\r\n}\r\nrp->conn_count = cpu_to_le16(i);\r\nrp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONNECTIONS, 0, rp,\r\nrp_len);\r\nkfree(rp);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int send_pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nstruct mgmt_cp_pin_code_neg_reply *cp)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nint err;\r\ncmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, hdev, cp,\r\nsizeof(*cp));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nerr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,\r\nsizeof(cp->addr.bdaddr), &cp->addr.bdaddr);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nstatic int pin_code_reply(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct hci_conn *conn;\r\nstruct mgmt_cp_pin_code_reply *cp = data;\r\nstruct hci_cp_pin_code_reply reply;\r\nstruct mgmt_pending_cmd *cmd;\r\nint err;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto failed;\r\n}\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->addr.bdaddr);\r\nif (!conn) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\r\nMGMT_STATUS_NOT_CONNECTED);\r\ngoto failed;\r\n}\r\nif (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {\r\nstruct mgmt_cp_pin_code_neg_reply ncp;\r\nmemcpy(&ncp.addr, &cp->addr, sizeof(ncp.addr));\r\nBT_ERR("PIN code is not 16 bytes long");\r\nerr = send_pin_code_neg_reply(sk, hdev, &ncp);\r\nif (err >= 0)\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_PIN_CODE_REPLY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\ncmd->cmd_complete = addr_cmd_complete;\r\nbacpy(&reply.bdaddr, &cp->addr.bdaddr);\r\nreply.pin_len = cp->pin_len;\r\nmemcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));\r\nerr = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_io_capability(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_io_capability *cp = data;\r\nBT_DBG("");\r\nif (cp->io_capability > SMP_IO_KEYBOARD_DISPLAY)\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY,\r\nMGMT_STATUS_INVALID_PARAMS, NULL, 0);\r\nhci_dev_lock(hdev);\r\nhdev->io_capability = cp->io_capability;\r\nBT_DBG("%s IO capability set to 0x%02x", hdev->name,\r\nhdev->io_capability);\r\nhci_dev_unlock(hdev);\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_IO_CAPABILITY, 0,\r\nNULL, 0);\r\n}\r\nstatic struct mgmt_pending_cmd *find_pairing(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct mgmt_pending_cmd *cmd;\r\nlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\r\nif (cmd->opcode != MGMT_OP_PAIR_DEVICE)\r\ncontinue;\r\nif (cmd->user_data != conn)\r\ncontinue;\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int pairing_complete(struct mgmt_pending_cmd *cmd, u8 status)\r\n{\r\nstruct mgmt_rp_pair_device rp;\r\nstruct hci_conn *conn = cmd->user_data;\r\nint err;\r\nbacpy(&rp.addr.bdaddr, &conn->dst);\r\nrp.addr.type = link_to_bdaddr(conn->type, conn->dst_type);\r\nerr = mgmt_cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE,\r\nstatus, &rp, sizeof(rp));\r\nconn->connect_cfm_cb = NULL;\r\nconn->security_cfm_cb = NULL;\r\nconn->disconn_cfm_cb = NULL;\r\nhci_conn_drop(conn);\r\nclear_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags);\r\nhci_conn_put(conn);\r\nreturn err;\r\n}\r\nvoid mgmt_smp_complete(struct hci_conn *conn, bool complete)\r\n{\r\nu8 status = complete ? MGMT_STATUS_SUCCESS : MGMT_STATUS_FAILED;\r\nstruct mgmt_pending_cmd *cmd;\r\ncmd = find_pairing(conn);\r\nif (cmd) {\r\ncmd->cmd_complete(cmd, status);\r\nmgmt_pending_remove(cmd);\r\n}\r\n}\r\nstatic void pairing_complete_cb(struct hci_conn *conn, u8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status %u", status);\r\ncmd = find_pairing(conn);\r\nif (!cmd) {\r\nBT_DBG("Unable to find a pending command");\r\nreturn;\r\n}\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic void le_pairing_complete_cb(struct hci_conn *conn, u8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status %u", status);\r\nif (!status)\r\nreturn;\r\ncmd = find_pairing(conn);\r\nif (!cmd) {\r\nBT_DBG("Unable to find a pending command");\r\nreturn;\r\n}\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic int pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_pair_device *cp = data;\r\nstruct mgmt_rp_pair_device rp;\r\nstruct mgmt_pending_cmd *cmd;\r\nu8 sec_level, auth_type;\r\nstruct hci_conn *conn;\r\nint err;\r\nBT_DBG("");\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nif (cp->io_cap > SMP_IO_KEYBOARD_DISPLAY)\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_NOT_POWERED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nif (hci_bdaddr_is_paired(hdev, &cp->addr.bdaddr, cp->addr.type)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_ALREADY_PAIRED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nsec_level = BT_SECURITY_MEDIUM;\r\nauth_type = HCI_AT_DEDICATED_BONDING;\r\nif (cp->addr.type == BDADDR_BREDR) {\r\nconn = hci_connect_acl(hdev, &cp->addr.bdaddr, sec_level,\r\nauth_type);\r\n} else {\r\nu8 addr_type = le_addr_type(cp->addr.type);\r\nstruct hci_conn_params *p;\r\np = hci_conn_params_add(hdev, &cp->addr.bdaddr, addr_type);\r\nif (p->auto_connect == HCI_AUTO_CONN_EXPLICIT)\r\np->auto_connect = HCI_AUTO_CONN_DISABLED;\r\nconn = hci_connect_le_scan(hdev, &cp->addr.bdaddr,\r\naddr_type, sec_level,\r\nHCI_LE_CONN_TIMEOUT);\r\n}\r\nif (IS_ERR(conn)) {\r\nint status;\r\nif (PTR_ERR(conn) == -EBUSY)\r\nstatus = MGMT_STATUS_BUSY;\r\nelse if (PTR_ERR(conn) == -EOPNOTSUPP)\r\nstatus = MGMT_STATUS_NOT_SUPPORTED;\r\nelse if (PTR_ERR(conn) == -ECONNREFUSED)\r\nstatus = MGMT_STATUS_REJECTED;\r\nelse\r\nstatus = MGMT_STATUS_CONNECT_FAILED;\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nstatus, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\nif (conn->connect_cfm_cb) {\r\nhci_conn_drop(conn);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\r\nMGMT_STATUS_BUSY, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\nhci_conn_drop(conn);\r\ngoto unlock;\r\n}\r\ncmd->cmd_complete = pairing_complete;\r\nif (cp->addr.type == BDADDR_BREDR) {\r\nconn->connect_cfm_cb = pairing_complete_cb;\r\nconn->security_cfm_cb = pairing_complete_cb;\r\nconn->disconn_cfm_cb = pairing_complete_cb;\r\n} else {\r\nconn->connect_cfm_cb = le_pairing_complete_cb;\r\nconn->security_cfm_cb = le_pairing_complete_cb;\r\nconn->disconn_cfm_cb = le_pairing_complete_cb;\r\n}\r\nconn->io_capability = cp->io_cap;\r\ncmd->user_data = hci_conn_get(conn);\r\nif ((conn->state == BT_CONNECTED || conn->state == BT_CONFIG) &&\r\nhci_conn_security(conn, sec_level, auth_type, true)) {\r\ncmd->cmd_complete(cmd, 0);\r\nmgmt_pending_remove(cmd);\r\n}\r\nerr = 0;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int cancel_pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_addr_info *addr = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nint err;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto unlock;\r\n}\r\ncmd = pending_find(MGMT_OP_PAIR_DEVICE, hdev);\r\nif (!cmd) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nconn = cmd->user_data;\r\nif (bacmp(&addr->bdaddr, &conn->dst) != 0) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\ncmd->cmd_complete(cmd, MGMT_STATUS_CANCELLED);\r\nmgmt_pending_remove(cmd);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CANCEL_PAIR_DEVICE, 0,\r\naddr, sizeof(*addr));\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int user_pairing_resp(struct sock *sk, struct hci_dev *hdev,\r\nstruct mgmt_addr_info *addr, u16 mgmt_op,\r\nu16 hci_op, __le32 passkey)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nint err;\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_NOT_POWERED, addr,\r\nsizeof(*addr));\r\ngoto done;\r\n}\r\nif (addr->type == BDADDR_BREDR)\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &addr->bdaddr);\r\nelse\r\nconn = hci_conn_hash_lookup_le(hdev, &addr->bdaddr,\r\nle_addr_type(addr->type));\r\nif (!conn) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_NOT_CONNECTED, addr,\r\nsizeof(*addr));\r\ngoto done;\r\n}\r\nif (addr->type == BDADDR_LE_PUBLIC || addr->type == BDADDR_LE_RANDOM) {\r\nerr = smp_user_confirm_reply(conn, mgmt_op, passkey);\r\nif (!err)\r\nerr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_SUCCESS, addr,\r\nsizeof(*addr));\r\nelse\r\nerr = mgmt_cmd_complete(sk, hdev->id, mgmt_op,\r\nMGMT_STATUS_FAILED, addr,\r\nsizeof(*addr));\r\ngoto done;\r\n}\r\ncmd = mgmt_pending_add(sk, mgmt_op, hdev, addr, sizeof(*addr));\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\ncmd->cmd_complete = addr_cmd_complete;\r\nif (hci_op == HCI_OP_USER_PASSKEY_REPLY) {\r\nstruct hci_cp_user_passkey_reply cp;\r\nbacpy(&cp.bdaddr, &addr->bdaddr);\r\ncp.passkey = passkey;\r\nerr = hci_send_cmd(hdev, hci_op, sizeof(cp), &cp);\r\n} else\r\nerr = hci_send_cmd(hdev, hci_op, sizeof(addr->bdaddr),\r\n&addr->bdaddr);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\ndone:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int pin_code_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_pin_code_neg_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_PIN_CODE_NEG_REPLY,\r\nHCI_OP_PIN_CODE_NEG_REPLY, 0);\r\n}\r\nstatic int user_confirm_reply(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_user_confirm_reply *cp = data;\r\nBT_DBG("");\r\nif (len != sizeof(*cp))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_USER_CONFIRM_REPLY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_CONFIRM_REPLY,\r\nHCI_OP_USER_CONFIRM_REPLY, 0);\r\n}\r\nstatic int user_confirm_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_user_confirm_neg_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_CONFIRM_NEG_REPLY,\r\nHCI_OP_USER_CONFIRM_NEG_REPLY, 0);\r\n}\r\nstatic int user_passkey_reply(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_user_passkey_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_PASSKEY_REPLY,\r\nHCI_OP_USER_PASSKEY_REPLY, cp->passkey);\r\n}\r\nstatic int user_passkey_neg_reply(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_user_passkey_neg_reply *cp = data;\r\nBT_DBG("");\r\nreturn user_pairing_resp(sk, hdev, &cp->addr,\r\nMGMT_OP_USER_PASSKEY_NEG_REPLY,\r\nHCI_OP_USER_PASSKEY_NEG_REPLY, 0);\r\n}\r\nstatic void set_name_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nstruct mgmt_cp_set_local_name *cp;\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\ncp = cmd->param;\r\nif (status)\r\nmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,\r\nmgmt_status(status));\r\nelse\r\nmgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\r\ncp, sizeof(*cp));\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_local_name(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_local_name *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("");\r\nhci_dev_lock(hdev);\r\nif (!memcmp(hdev->dev_name, cp->name, sizeof(hdev->dev_name)) &&\r\n!memcmp(hdev->short_name, cp->short_name,\r\nsizeof(hdev->short_name))) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\r\ndata, len);\r\ngoto failed;\r\n}\r\nmemcpy(hdev->short_name, cp->short_name, sizeof(hdev->short_name));\r\nif (!hdev_is_powered(hdev)) {\r\nmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, 0,\r\ndata, len);\r\nif (err < 0)\r\ngoto failed;\r\nerr = mgmt_generic_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev,\r\ndata, len, sk);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nmemcpy(hdev->dev_name, cp->name, sizeof(hdev->dev_name));\r\nhci_req_init(&req, hdev);\r\nif (lmp_bredr_capable(hdev)) {\r\n__hci_req_update_name(&req);\r\n__hci_req_update_eir(&req);\r\n}\r\nif (lmp_le_capable(hdev))\r\n__hci_req_update_scan_rsp_data(&req, hdev->cur_adv_instance);\r\nerr = hci_req_run(&req, set_name_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode, struct sk_buff *skb)\r\n{\r\nstruct mgmt_rp_read_local_oob_data mgmt_rp;\r\nsize_t rp_size = sizeof(mgmt_rp);\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("%s status %u", hdev->name, status);\r\ncmd = pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);\r\nif (!cmd)\r\nreturn;\r\nif (status || !skb) {\r\nmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nstatus ? mgmt_status(status) : MGMT_STATUS_FAILED);\r\ngoto remove;\r\n}\r\nmemset(&mgmt_rp, 0, sizeof(mgmt_rp));\r\nif (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {\r\nstruct hci_rp_read_local_oob_data *rp = (void *) skb->data;\r\nif (skb->len < sizeof(*rp)) {\r\nmgmt_cmd_status(cmd->sk, hdev->id,\r\nMGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_FAILED);\r\ngoto remove;\r\n}\r\nmemcpy(mgmt_rp.hash192, rp->hash, sizeof(rp->hash));\r\nmemcpy(mgmt_rp.rand192, rp->rand, sizeof(rp->rand));\r\nrp_size -= sizeof(mgmt_rp.hash256) + sizeof(mgmt_rp.rand256);\r\n} else {\r\nstruct hci_rp_read_local_oob_ext_data *rp = (void *) skb->data;\r\nif (skb->len < sizeof(*rp)) {\r\nmgmt_cmd_status(cmd->sk, hdev->id,\r\nMGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_FAILED);\r\ngoto remove;\r\n}\r\nmemcpy(mgmt_rp.hash192, rp->hash192, sizeof(rp->hash192));\r\nmemcpy(mgmt_rp.rand192, rp->rand192, sizeof(rp->rand192));\r\nmemcpy(mgmt_rp.hash256, rp->hash256, sizeof(rp->hash256));\r\nmemcpy(mgmt_rp.rand256, rp->rand256, sizeof(rp->rand256));\r\n}\r\nmgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_SUCCESS, &mgmt_rp, rp_size);\r\nremove:\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_NOT_POWERED);\r\ngoto unlock;\r\n}\r\nif (!lmp_ssp_capable(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\ngoto unlock;\r\n}\r\nif (pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nif (bredr_sc_enabled(hdev))\r\nhci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);\r\nelse\r\nhci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);\r\nerr = hci_req_run_skb(&req, read_local_oob_data_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int add_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_addr_info *addr = data;\r\nint err;\r\nBT_DBG("%s ", hdev->name);\r\nif (!bdaddr_type_is_valid(addr->type))\r\nreturn mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_ADD_REMOTE_OOB_DATA,\r\nMGMT_STATUS_INVALID_PARAMS,\r\naddr, sizeof(*addr));\r\nhci_dev_lock(hdev);\r\nif (len == MGMT_ADD_REMOTE_OOB_DATA_SIZE) {\r\nstruct mgmt_cp_add_remote_oob_data *cp = data;\r\nu8 status;\r\nif (cp->addr.type != BDADDR_BREDR) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_ADD_REMOTE_OOB_DATA,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nerr = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,\r\ncp->addr.type, cp->hash,\r\ncp->rand, NULL, NULL);\r\nif (err < 0)\r\nstatus = MGMT_STATUS_FAILED;\r\nelse\r\nstatus = MGMT_STATUS_SUCCESS;\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_ADD_REMOTE_OOB_DATA, status,\r\n&cp->addr, sizeof(cp->addr));\r\n} else if (len == MGMT_ADD_REMOTE_OOB_EXT_DATA_SIZE) {\r\nstruct mgmt_cp_add_remote_oob_ext_data *cp = data;\r\nu8 *rand192, *hash192, *rand256, *hash256;\r\nu8 status;\r\nif (bdaddr_type_is_le(cp->addr.type)) {\r\nif (memcmp(cp->rand192, ZERO_KEY, 16) ||\r\nmemcmp(cp->hash192, ZERO_KEY, 16)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_ADD_REMOTE_OOB_DATA,\r\nMGMT_STATUS_INVALID_PARAMS,\r\naddr, sizeof(*addr));\r\ngoto unlock;\r\n}\r\nrand192 = NULL;\r\nhash192 = NULL;\r\n} else {\r\nif (!memcmp(cp->rand192, ZERO_KEY, 16) ||\r\n!memcmp(cp->hash192, ZERO_KEY, 16)) {\r\nrand192 = NULL;\r\nhash192 = NULL;\r\n} else {\r\nrand192 = cp->rand192;\r\nhash192 = cp->hash192;\r\n}\r\n}\r\nif (!memcmp(cp->rand256, ZERO_KEY, 16) ||\r\n!memcmp(cp->hash256, ZERO_KEY, 16)) {\r\nrand256 = NULL;\r\nhash256 = NULL;\r\n} else {\r\nrand256 = cp->rand256;\r\nhash256 = cp->hash256;\r\n}\r\nerr = hci_add_remote_oob_data(hdev, &cp->addr.bdaddr,\r\ncp->addr.type, hash192, rand192,\r\nhash256, rand256);\r\nif (err < 0)\r\nstatus = MGMT_STATUS_FAILED;\r\nelse\r\nstatus = MGMT_STATUS_SUCCESS;\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_ADD_REMOTE_OOB_DATA,\r\nstatus, &cp->addr, sizeof(cp->addr));\r\n} else {\r\nBT_ERR("add_remote_oob_data: invalid length of %u bytes", len);\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_REMOTE_OOB_DATA,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int remove_remote_oob_data(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_remove_remote_oob_data *cp = data;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (cp->addr.type != BDADDR_BREDR)\r\nreturn mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_REMOTE_OOB_DATA,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_lock(hdev);\r\nif (!bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\r\nhci_remote_oob_data_clear(hdev);\r\nstatus = MGMT_STATUS_SUCCESS;\r\ngoto done;\r\n}\r\nerr = hci_remove_remote_oob_data(hdev, &cp->addr.bdaddr, cp->addr.type);\r\nif (err < 0)\r\nstatus = MGMT_STATUS_INVALID_PARAMS;\r\nelse\r\nstatus = MGMT_STATUS_SUCCESS;\r\ndone:\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_REMOTE_OOB_DATA,\r\nstatus, &cp->addr, sizeof(cp->addr));\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nvoid mgmt_start_discovery_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status %d", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_START_DISCOVERY, hdev);\r\nif (!cmd)\r\ncmd = pending_find(MGMT_OP_START_SERVICE_DISCOVERY, hdev);\r\nif (!cmd)\r\ncmd = pending_find(MGMT_OP_START_LIMITED_DISCOVERY, hdev);\r\nif (cmd) {\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic bool discovery_type_is_valid(struct hci_dev *hdev, uint8_t type,\r\nuint8_t *mgmt_status)\r\n{\r\nswitch (type) {\r\ncase DISCOV_TYPE_LE:\r\n*mgmt_status = mgmt_le_support(hdev);\r\nif (*mgmt_status)\r\nreturn false;\r\nbreak;\r\ncase DISCOV_TYPE_INTERLEAVED:\r\n*mgmt_status = mgmt_le_support(hdev);\r\nif (*mgmt_status)\r\nreturn false;\r\ncase DISCOV_TYPE_BREDR:\r\n*mgmt_status = mgmt_bredr_support(hdev);\r\nif (*mgmt_status)\r\nreturn false;\r\nbreak;\r\ndefault:\r\n*mgmt_status = MGMT_STATUS_INVALID_PARAMS;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int start_discovery_internal(struct sock *sk, struct hci_dev *hdev,\r\nu16 op, void *data, u16 len)\r\n{\r\nstruct mgmt_cp_start_discovery *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, op,\r\nMGMT_STATUS_NOT_POWERED,\r\n&cp->type, sizeof(cp->type));\r\ngoto failed;\r\n}\r\nif (hdev->discovery.state != DISCOVERY_STOPPED ||\r\nhci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, op, MGMT_STATUS_BUSY,\r\n&cp->type, sizeof(cp->type));\r\ngoto failed;\r\n}\r\nif (!discovery_type_is_valid(hdev, cp->type, &status)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, op, status,\r\n&cp->type, sizeof(cp->type));\r\ngoto failed;\r\n}\r\nhci_discovery_filter_clear(hdev);\r\nhdev->discovery.type = cp->type;\r\nhdev->discovery.report_invalid_rssi = false;\r\nif (op == MGMT_OP_START_LIMITED_DISCOVERY)\r\nhdev->discovery.limited = true;\r\nelse\r\nhdev->discovery.limited = false;\r\ncmd = mgmt_pending_add(sk, op, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\ncmd->cmd_complete = generic_cmd_complete;\r\nhci_discovery_set_state(hdev, DISCOVERY_STARTING);\r\nqueue_work(hdev->req_workqueue, &hdev->discov_update);\r\nerr = 0;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int start_discovery(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nreturn start_discovery_internal(sk, hdev, MGMT_OP_START_DISCOVERY,\r\ndata, len);\r\n}\r\nstatic int start_limited_discovery(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nreturn start_discovery_internal(sk, hdev,\r\nMGMT_OP_START_LIMITED_DISCOVERY,\r\ndata, len);\r\n}\r\nstatic int service_discovery_cmd_complete(struct mgmt_pending_cmd *cmd,\r\nu8 status)\r\n{\r\nreturn mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status,\r\ncmd->param, 1);\r\n}\r\nstatic int start_service_discovery(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_start_service_discovery *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nconst u16 max_uuid_count = ((U16_MAX - sizeof(*cp)) / 16);\r\nu16 uuid_count, expected_len;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_START_SERVICE_DISCOVERY,\r\nMGMT_STATUS_NOT_POWERED,\r\n&cp->type, sizeof(cp->type));\r\ngoto failed;\r\n}\r\nif (hdev->discovery.state != DISCOVERY_STOPPED ||\r\nhci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_START_SERVICE_DISCOVERY,\r\nMGMT_STATUS_BUSY, &cp->type,\r\nsizeof(cp->type));\r\ngoto failed;\r\n}\r\nuuid_count = __le16_to_cpu(cp->uuid_count);\r\nif (uuid_count > max_uuid_count) {\r\nBT_ERR("service_discovery: too big uuid_count value %u",\r\nuuid_count);\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_START_SERVICE_DISCOVERY,\r\nMGMT_STATUS_INVALID_PARAMS, &cp->type,\r\nsizeof(cp->type));\r\ngoto failed;\r\n}\r\nexpected_len = sizeof(*cp) + uuid_count * 16;\r\nif (expected_len != len) {\r\nBT_ERR("service_discovery: expected %u bytes, got %u bytes",\r\nexpected_len, len);\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_START_SERVICE_DISCOVERY,\r\nMGMT_STATUS_INVALID_PARAMS, &cp->type,\r\nsizeof(cp->type));\r\ngoto failed;\r\n}\r\nif (!discovery_type_is_valid(hdev, cp->type, &status)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_START_SERVICE_DISCOVERY,\r\nstatus, &cp->type, sizeof(cp->type));\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_START_SERVICE_DISCOVERY,\r\nhdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\ncmd->cmd_complete = service_discovery_cmd_complete;\r\nhci_discovery_filter_clear(hdev);\r\nhdev->discovery.result_filtering = true;\r\nhdev->discovery.type = cp->type;\r\nhdev->discovery.rssi = cp->rssi;\r\nhdev->discovery.uuid_count = uuid_count;\r\nif (uuid_count > 0) {\r\nhdev->discovery.uuids = kmemdup(cp->uuids, uuid_count * 16,\r\nGFP_KERNEL);\r\nif (!hdev->discovery.uuids) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_START_SERVICE_DISCOVERY,\r\nMGMT_STATUS_FAILED,\r\n&cp->type, sizeof(cp->type));\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\n}\r\nhci_discovery_set_state(hdev, DISCOVERY_STARTING);\r\nqueue_work(hdev->req_workqueue, &hdev->discov_update);\r\nerr = 0;\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nvoid mgmt_stop_discovery_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status %d", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_STOP_DISCOVERY, hdev);\r\nif (cmd) {\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int stop_discovery(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_stop_discovery *mgmt_cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hci_discovery_active(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\r\nMGMT_STATUS_REJECTED, &mgmt_cp->type,\r\nsizeof(mgmt_cp->type));\r\ngoto unlock;\r\n}\r\nif (hdev->discovery.type != mgmt_cp->type) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_STOP_DISCOVERY,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&mgmt_cp->type, sizeof(mgmt_cp->type));\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ncmd->cmd_complete = generic_cmd_complete;\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPING);\r\nqueue_work(hdev->req_workqueue, &hdev->discov_update);\r\nerr = 0;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int confirm_name(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_confirm_name *cp = data;\r\nstruct inquiry_entry *e;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hci_discovery_active(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\r\nMGMT_STATUS_FAILED, &cp->addr,\r\nsizeof(cp->addr));\r\ngoto failed;\r\n}\r\ne = hci_inquiry_cache_lookup_unknown(hdev, &cp->addr.bdaddr);\r\nif (!e) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME,\r\nMGMT_STATUS_INVALID_PARAMS, &cp->addr,\r\nsizeof(cp->addr));\r\ngoto failed;\r\n}\r\nif (cp->name_known) {\r\ne->name_state = NAME_KNOWN;\r\nlist_del(&e->list);\r\n} else {\r\ne->name_state = NAME_NEEDED;\r\nhci_inquiry_cache_update_resolve(hdev, e);\r\n}\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_CONFIRM_NAME, 0,\r\n&cp->addr, sizeof(cp->addr));\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int block_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_block_device *cp = data;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_lock(hdev);\r\nerr = hci_bdaddr_list_add(&hdev->blacklist, &cp->addr.bdaddr,\r\ncp->addr.type);\r\nif (err < 0) {\r\nstatus = MGMT_STATUS_FAILED;\r\ngoto done;\r\n}\r\nmgmt_event(MGMT_EV_DEVICE_BLOCKED, hdev, &cp->addr, sizeof(cp->addr),\r\nsk);\r\nstatus = MGMT_STATUS_SUCCESS;\r\ndone:\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_BLOCK_DEVICE, status,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int unblock_device(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_unblock_device *cp = data;\r\nu8 status;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_lock(hdev);\r\nerr = hci_bdaddr_list_del(&hdev->blacklist, &cp->addr.bdaddr,\r\ncp->addr.type);\r\nif (err < 0) {\r\nstatus = MGMT_STATUS_INVALID_PARAMS;\r\ngoto done;\r\n}\r\nmgmt_event(MGMT_EV_DEVICE_UNBLOCKED, hdev, &cp->addr, sizeof(cp->addr),\r\nsk);\r\nstatus = MGMT_STATUS_SUCCESS;\r\ndone:\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_UNBLOCK_DEVICE, status,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_device_id(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_device_id *cp = data;\r\nstruct hci_request req;\r\nint err;\r\n__u16 source;\r\nBT_DBG("%s", hdev->name);\r\nsource = __le16_to_cpu(cp->source);\r\nif (source > 0x0002)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEVICE_ID,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nhdev->devid_source = source;\r\nhdev->devid_vendor = __le16_to_cpu(cp->vendor);\r\nhdev->devid_product = __le16_to_cpu(cp->product);\r\nhdev->devid_version = __le16_to_cpu(cp->version);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_ID, 0,\r\nNULL, 0);\r\nhci_req_init(&req, hdev);\r\n__hci_req_update_eir(&req);\r\nhci_req_run(&req, NULL);\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void enable_advertising_instance(struct hci_dev *hdev, u8 status,\r\nu16 opcode)\r\n{\r\nBT_DBG("status %d", status);\r\n}\r\nstatic void set_advertising_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nstruct hci_request req;\r\nu8 instance;\r\nstruct adv_info *adv_instance;\r\nint err;\r\nhci_dev_lock(hdev);\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nmgmt_pending_foreach(MGMT_OP_SET_ADVERTISING, hdev,\r\ncmd_status_rsp, &mgmt_err);\r\ngoto unlock;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_LE_ADV))\r\nhci_dev_set_flag(hdev, HCI_ADVERTISING);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_ADVERTISING);\r\nmgmt_pending_foreach(MGMT_OP_SET_ADVERTISING, hdev, settings_rsp,\r\n&match);\r\nnew_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nif (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||\r\nlist_empty(&hdev->adv_instances))\r\ngoto unlock;\r\ninstance = hdev->cur_adv_instance;\r\nif (!instance) {\r\nadv_instance = list_first_entry_or_null(&hdev->adv_instances,\r\nstruct adv_info, list);\r\nif (!adv_instance)\r\ngoto unlock;\r\ninstance = adv_instance->instance;\r\n}\r\nhci_req_init(&req, hdev);\r\nerr = __hci_req_schedule_adv_instance(&req, instance, true);\r\nif (!err)\r\nerr = hci_req_run(&req, enable_advertising_instance);\r\nif (err)\r\nBT_ERR("Failed to re-configure advertising");\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_advertising(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nu8 val, status;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nstatus = mgmt_le_support(hdev);\r\nif (status)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\r\nstatus);\r\nif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nval = !!cp->val;\r\nif (!hdev_is_powered(hdev) ||\r\n(val == hci_dev_test_flag(hdev, HCI_ADVERTISING) &&\r\n(cp->val == 0x02) == hci_dev_test_flag(hdev, HCI_ADVERTISING_CONNECTABLE)) ||\r\nhci_conn_num(hdev, LE_LINK) > 0 ||\r\n(hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\r\nhdev->le_scan_type == LE_SCAN_ACTIVE)) {\r\nbool changed;\r\nif (cp->val) {\r\nhdev->cur_adv_instance = 0x00;\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_ADVERTISING);\r\nif (cp->val == 0x02)\r\nhci_dev_set_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\r\n} else {\r\nchanged = hci_dev_test_and_clear_flag(hdev, HCI_ADVERTISING);\r\nhci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_ADVERTISING, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto unlock;\r\n}\r\nif (pending_find(MGMT_OP_SET_ADVERTISING, hdev) ||\r\npending_find(MGMT_OP_SET_LE, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_ADVERTISING,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_ADVERTISING, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nif (cp->val == 0x02)\r\nhci_dev_set_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_ADVERTISING_CONNECTABLE);\r\ncancel_adv_timeout(hdev);\r\nif (val) {\r\nhdev->cur_adv_instance = 0x00;\r\n__hci_req_update_adv_data(&req, 0x00);\r\n__hci_req_update_scan_rsp_data(&req, 0x00);\r\n__hci_req_enable_advertising(&req);\r\n} else {\r\n__hci_req_disable_advertising(&req);\r\n}\r\nerr = hci_req_run(&req, set_advertising_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_static_address(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_set_static_address *cp = data;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_STATIC_ADDRESS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (hdev_is_powered(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_STATIC_ADDRESS,\r\nMGMT_STATUS_REJECTED);\r\nif (bacmp(&cp->bdaddr, BDADDR_ANY)) {\r\nif (!bacmp(&cp->bdaddr, BDADDR_NONE))\r\nreturn mgmt_cmd_status(sk, hdev->id,\r\nMGMT_OP_SET_STATIC_ADDRESS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif ((cp->bdaddr.b[5] & 0xc0) != 0xc0)\r\nreturn mgmt_cmd_status(sk, hdev->id,\r\nMGMT_OP_SET_STATIC_ADDRESS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nhci_dev_lock(hdev);\r\nbacpy(&hdev->static_addr, &cp->bdaddr);\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_STATIC_ADDRESS, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = new_settings(hdev, sk);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_scan_params(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_set_scan_params *cp = data;\r\n__u16 interval, window;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\ninterval = __le16_to_cpu(cp->interval);\r\nif (interval < 0x0004 || interval > 0x4000)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nwindow = __le16_to_cpu(cp->window);\r\nif (window < 0x0004 || window > 0x4000)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (window > interval)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nhdev->le_scan_interval = interval;\r\nhdev->le_scan_window = window;\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_SCAN_PARAMS, 0,\r\nNULL, 0);\r\nif (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\r\nhdev->discovery.state == DISCOVERY_STOPPED) {\r\nstruct hci_request req;\r\nhci_req_init(&req, hdev);\r\nhci_req_add_le_scan_disable(&req);\r\nhci_req_add_le_passive_scan(&req);\r\nhci_req_run(&req, NULL);\r\n}\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void fast_connectable_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_SET_FAST_CONNECTABLE, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nif (status) {\r\nmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nmgmt_status(status));\r\n} else {\r\nstruct mgmt_mode *cp = cmd->param;\r\nif (cp->val)\r\nhci_dev_set_flag(hdev, HCI_FAST_CONNECTABLE);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_FAST_CONNECTABLE);\r\nsend_settings_rsp(cmd->sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev);\r\nnew_settings(hdev, cmd->sk);\r\n}\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_fast_connectable(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) ||\r\nhdev->hci_ver < BLUETOOTH_VER_1_2)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (pending_find(MGMT_OP_SET_FAST_CONNECTABLE, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif (!!cp->val == hci_dev_test_flag(hdev, HCI_FAST_CONNECTABLE)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_FAST_CONNECTABLE,\r\nhdev);\r\ngoto unlock;\r\n}\r\nif (!hdev_is_powered(hdev)) {\r\nhci_dev_change_flag(hdev, HCI_FAST_CONNECTABLE);\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_FAST_CONNECTABLE,\r\nhdev);\r\nnew_settings(hdev, sk);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_FAST_CONNECTABLE, hdev,\r\ndata, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\n__hci_req_write_fast_connectable(&req, cp->val);\r\nerr = hci_req_run(&req, fast_connectable_complete);\r\nif (err < 0) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_FAST_CONNECTABLE,\r\nMGMT_STATUS_FAILED);\r\nmgmt_pending_remove(cmd);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void set_bredr_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nBT_DBG("status 0x%02x", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_SET_BREDR, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nhci_dev_clear_flag(hdev, HCI_BREDR_ENABLED);\r\nmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);\r\n} else {\r\nsend_settings_rsp(cmd->sk, MGMT_OP_SET_BREDR, hdev);\r\nnew_settings(hdev, cmd->sk);\r\n}\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_bredr(struct sock *sk, struct hci_dev *hdev, void *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_bredr_capable(hdev) || !lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\r\nMGMT_STATUS_REJECTED);\r\nif (cp->val != 0x00 && cp->val != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (cp->val == hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_BREDR, hdev);\r\ngoto unlock;\r\n}\r\nif (!hdev_is_powered(hdev)) {\r\nif (!cp->val) {\r\nhci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\r\nhci_dev_clear_flag(hdev, HCI_SSP_ENABLED);\r\nhci_dev_clear_flag(hdev, HCI_LINK_SECURITY);\r\nhci_dev_clear_flag(hdev, HCI_FAST_CONNECTABLE);\r\nhci_dev_clear_flag(hdev, HCI_HS_ENABLED);\r\n}\r\nhci_dev_change_flag(hdev, HCI_BREDR_ENABLED);\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_BREDR, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = new_settings(hdev, sk);\r\ngoto unlock;\r\n}\r\nif (!cp->val) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\r\nMGMT_STATUS_REJECTED);\r\ngoto unlock;\r\n} else {\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\r\n(bacmp(&hdev->static_addr, BDADDR_ANY) ||\r\nhci_dev_test_flag(hdev, HCI_SC_ENABLED))) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\r\nMGMT_STATUS_REJECTED);\r\ngoto unlock;\r\n}\r\n}\r\nif (pending_find(MGMT_OP_SET_BREDR, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BREDR,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_BREDR, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_dev_set_flag(hdev, HCI_BREDR_ENABLED);\r\nhci_req_init(&req, hdev);\r\n__hci_req_write_fast_connectable(&req, false);\r\n__hci_req_update_scan(&req);\r\n__hci_req_update_adv_data(&req, hdev->cur_adv_instance);\r\nerr = hci_req_run(&req, set_bredr_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void sc_enable_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct mgmt_mode *cp;\r\nBT_DBG("%s status %u", hdev->name, status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_SET_SECURE_CONN, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\nif (status) {\r\nmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\r\nmgmt_status(status));\r\ngoto remove;\r\n}\r\ncp = cmd->param;\r\nswitch (cp->val) {\r\ncase 0x00:\r\nhci_dev_clear_flag(hdev, HCI_SC_ENABLED);\r\nhci_dev_clear_flag(hdev, HCI_SC_ONLY);\r\nbreak;\r\ncase 0x01:\r\nhci_dev_set_flag(hdev, HCI_SC_ENABLED);\r\nhci_dev_clear_flag(hdev, HCI_SC_ONLY);\r\nbreak;\r\ncase 0x02:\r\nhci_dev_set_flag(hdev, HCI_SC_ENABLED);\r\nhci_dev_set_flag(hdev, HCI_SC_ONLY);\r\nbreak;\r\n}\r\nsend_settings_rsp(cmd->sk, MGMT_OP_SET_SECURE_CONN, hdev);\r\nnew_settings(hdev, cmd->sk);\r\nremove:\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int set_secure_conn(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nu8 val;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_sc_capable(hdev) &&\r\n!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\r\nlmp_sc_capable(hdev) &&\r\n!hci_dev_test_flag(hdev, HCI_SSP_ENABLED))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\r\nMGMT_STATUS_REJECTED);\r\nif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev) || !lmp_sc_capable(hdev) ||\r\n!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\r\nbool changed;\r\nif (cp->val) {\r\nchanged = !hci_dev_test_and_set_flag(hdev,\r\nHCI_SC_ENABLED);\r\nif (cp->val == 0x02)\r\nhci_dev_set_flag(hdev, HCI_SC_ONLY);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_SC_ONLY);\r\n} else {\r\nchanged = hci_dev_test_and_clear_flag(hdev,\r\nHCI_SC_ENABLED);\r\nhci_dev_clear_flag(hdev, HCI_SC_ONLY);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_SECURE_CONN, hdev);\r\nif (err < 0)\r\ngoto failed;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\ngoto failed;\r\n}\r\nif (pending_find(MGMT_OP_SET_SECURE_CONN, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_SECURE_CONN,\r\nMGMT_STATUS_BUSY);\r\ngoto failed;\r\n}\r\nval = !!cp->val;\r\nif (val == hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\r\n(cp->val == 0x02) == hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_SECURE_CONN, hdev);\r\ngoto failed;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_SET_SECURE_CONN, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nhci_req_init(&req, hdev);\r\nhci_req_add(&req, HCI_OP_WRITE_SC_SUPPORT, 1, &val);\r\nerr = hci_req_run(&req, sc_enable_complete);\r\nif (err < 0) {\r\nmgmt_pending_remove(cmd);\r\ngoto failed;\r\n}\r\nfailed:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_debug_keys(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_mode *cp = data;\r\nbool changed, use_changed;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (cp->val != 0x00 && cp->val != 0x01 && cp->val != 0x02)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_DEBUG_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (cp->val)\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_KEEP_DEBUG_KEYS);\r\nelse\r\nchanged = hci_dev_test_and_clear_flag(hdev,\r\nHCI_KEEP_DEBUG_KEYS);\r\nif (cp->val == 0x02)\r\nuse_changed = !hci_dev_test_and_set_flag(hdev,\r\nHCI_USE_DEBUG_KEYS);\r\nelse\r\nuse_changed = hci_dev_test_and_clear_flag(hdev,\r\nHCI_USE_DEBUG_KEYS);\r\nif (hdev_is_powered(hdev) && use_changed &&\r\nhci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\r\nu8 mode = (cp->val == 0x02) ? 0x01 : 0x00;\r\nhci_send_cmd(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE,\r\nsizeof(mode), &mode);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_DEBUG_KEYS, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_privacy(struct sock *sk, struct hci_dev *hdev, void *cp_data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_set_privacy *cp = cp_data;\r\nbool changed;\r\nint err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nif (cp->privacy != 0x00 && cp->privacy != 0x01 && cp->privacy != 0x02)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (hdev_is_powered(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PRIVACY,\r\nMGMT_STATUS_REJECTED);\r\nhci_dev_lock(hdev);\r\nhci_dev_set_flag(hdev, HCI_RPA_RESOLVING);\r\nif (cp->privacy) {\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_PRIVACY);\r\nmemcpy(hdev->irk, cp->irk, sizeof(hdev->irk));\r\nhci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\r\nif (cp->privacy == 0x02)\r\nhci_dev_set_flag(hdev, HCI_LIMITED_PRIVACY);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_LIMITED_PRIVACY);\r\n} else {\r\nchanged = hci_dev_test_and_clear_flag(hdev, HCI_PRIVACY);\r\nmemset(hdev->irk, 0, sizeof(hdev->irk));\r\nhci_dev_clear_flag(hdev, HCI_RPA_EXPIRED);\r\nhci_dev_clear_flag(hdev, HCI_LIMITED_PRIVACY);\r\n}\r\nerr = send_settings_rsp(sk, MGMT_OP_SET_PRIVACY, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (changed)\r\nerr = new_settings(hdev, sk);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool irk_is_valid(struct mgmt_irk_info *irk)\r\n{\r\nswitch (irk->addr.type) {\r\ncase BDADDR_LE_PUBLIC:\r\nreturn true;\r\ncase BDADDR_LE_RANDOM:\r\nif ((irk->addr.bdaddr.b[5] & 0xc0) != 0xc0)\r\nreturn false;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int load_irks(struct sock *sk, struct hci_dev *hdev, void *cp_data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_load_irks *cp = cp_data;\r\nconst u16 max_irk_count = ((U16_MAX - sizeof(*cp)) /\r\nsizeof(struct mgmt_irk_info));\r\nu16 irk_count, expected_len;\r\nint i, err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nirk_count = __le16_to_cpu(cp->irk_count);\r\nif (irk_count > max_irk_count) {\r\nBT_ERR("load_irks: too big irk_count value %u", irk_count);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nexpected_len = sizeof(*cp) + irk_count * sizeof(struct mgmt_irk_info);\r\nif (expected_len != len) {\r\nBT_ERR("load_irks: expected %u bytes, got %u bytes",\r\nexpected_len, len);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_IRKS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nBT_DBG("%s irk_count %u", hdev->name, irk_count);\r\nfor (i = 0; i < irk_count; i++) {\r\nstruct mgmt_irk_info *key = &cp->irks[i];\r\nif (!irk_is_valid(key))\r\nreturn mgmt_cmd_status(sk, hdev->id,\r\nMGMT_OP_LOAD_IRKS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nhci_dev_lock(hdev);\r\nhci_smp_irks_clear(hdev);\r\nfor (i = 0; i < irk_count; i++) {\r\nstruct mgmt_irk_info *irk = &cp->irks[i];\r\nhci_add_irk(hdev, &irk->addr.bdaddr,\r\nle_addr_type(irk->addr.type), irk->val,\r\nBDADDR_ANY);\r\n}\r\nhci_dev_set_flag(hdev, HCI_RPA_RESOLVING);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_IRKS, 0, NULL, 0);\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool ltk_is_valid(struct mgmt_ltk_info *key)\r\n{\r\nif (key->master != 0x00 && key->master != 0x01)\r\nreturn false;\r\nswitch (key->addr.type) {\r\ncase BDADDR_LE_PUBLIC:\r\nreturn true;\r\ncase BDADDR_LE_RANDOM:\r\nif ((key->addr.bdaddr.b[5] & 0xc0) != 0xc0)\r\nreturn false;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int load_long_term_keys(struct sock *sk, struct hci_dev *hdev,\r\nvoid *cp_data, u16 len)\r\n{\r\nstruct mgmt_cp_load_long_term_keys *cp = cp_data;\r\nconst u16 max_key_count = ((U16_MAX - sizeof(*cp)) /\r\nsizeof(struct mgmt_ltk_info));\r\nu16 key_count, expected_len;\r\nint i, err;\r\nBT_DBG("request for %s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nkey_count = __le16_to_cpu(cp->key_count);\r\nif (key_count > max_key_count) {\r\nBT_ERR("load_ltks: too big key_count value %u", key_count);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nexpected_len = sizeof(*cp) + key_count *\r\nsizeof(struct mgmt_ltk_info);\r\nif (expected_len != len) {\r\nBT_ERR("load_keys: expected %u bytes, got %u bytes",\r\nexpected_len, len);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nBT_DBG("%s key_count %u", hdev->name, key_count);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_ltk_info *key = &cp->keys[i];\r\nif (!ltk_is_valid(key))\r\nreturn mgmt_cmd_status(sk, hdev->id,\r\nMGMT_OP_LOAD_LONG_TERM_KEYS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nhci_dev_lock(hdev);\r\nhci_smp_ltks_clear(hdev);\r\nfor (i = 0; i < key_count; i++) {\r\nstruct mgmt_ltk_info *key = &cp->keys[i];\r\nu8 type, authenticated;\r\nswitch (key->type) {\r\ncase MGMT_LTK_UNAUTHENTICATED:\r\nauthenticated = 0x00;\r\ntype = key->master ? SMP_LTK : SMP_LTK_SLAVE;\r\nbreak;\r\ncase MGMT_LTK_AUTHENTICATED:\r\nauthenticated = 0x01;\r\ntype = key->master ? SMP_LTK : SMP_LTK_SLAVE;\r\nbreak;\r\ncase MGMT_LTK_P256_UNAUTH:\r\nauthenticated = 0x00;\r\ntype = SMP_LTK_P256;\r\nbreak;\r\ncase MGMT_LTK_P256_AUTH:\r\nauthenticated = 0x01;\r\ntype = SMP_LTK_P256;\r\nbreak;\r\ncase MGMT_LTK_P256_DEBUG:\r\nauthenticated = 0x00;\r\ntype = SMP_LTK_P256_DEBUG;\r\ndefault:\r\ncontinue;\r\n}\r\nhci_add_ltk(hdev, &key->addr.bdaddr,\r\nle_addr_type(key->addr.type), type, authenticated,\r\nkey->val, key->enc_size, key->ediv, key->rand);\r\n}\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_LONG_TERM_KEYS, 0,\r\nNULL, 0);\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int conn_info_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\r\n{\r\nstruct hci_conn *conn = cmd->user_data;\r\nstruct mgmt_rp_get_conn_info rp;\r\nint err;\r\nmemcpy(&rp.addr, cmd->param, sizeof(rp.addr));\r\nif (status == MGMT_STATUS_SUCCESS) {\r\nrp.rssi = conn->rssi;\r\nrp.tx_power = conn->tx_power;\r\nrp.max_tx_power = conn->max_tx_power;\r\n} else {\r\nrp.rssi = HCI_RSSI_INVALID;\r\nrp.tx_power = HCI_TX_POWER_INVALID;\r\nrp.max_tx_power = HCI_TX_POWER_INVALID;\r\n}\r\nerr = mgmt_cmd_complete(cmd->sk, cmd->index, MGMT_OP_GET_CONN_INFO,\r\nstatus, &rp, sizeof(rp));\r\nhci_conn_drop(conn);\r\nhci_conn_put(conn);\r\nreturn err;\r\n}\r\nstatic void conn_info_refresh_complete(struct hci_dev *hdev, u8 hci_status,\r\nu16 opcode)\r\n{\r\nstruct hci_cp_read_rssi *cp;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nu16 handle;\r\nu8 status;\r\nBT_DBG("status 0x%02x", hci_status);\r\nhci_dev_lock(hdev);\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_READ_RSSI);\r\nif (!cp) {\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_READ_TX_POWER);\r\nstatus = MGMT_STATUS_SUCCESS;\r\n} else {\r\nstatus = mgmt_status(hci_status);\r\n}\r\nif (!cp) {\r\nBT_ERR("invalid sent_cmd in conn_info response");\r\ngoto unlock;\r\n}\r\nhandle = __le16_to_cpu(cp->handle);\r\nconn = hci_conn_hash_lookup_handle(hdev, handle);\r\nif (!conn) {\r\nBT_ERR("unknown handle (%d) in conn_info response", handle);\r\ngoto unlock;\r\n}\r\ncmd = pending_find_data(MGMT_OP_GET_CONN_INFO, hdev, conn);\r\nif (!cmd)\r\ngoto unlock;\r\ncmd->cmd_complete(cmd, status);\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int get_conn_info(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_get_conn_info *cp = data;\r\nstruct mgmt_rp_get_conn_info rp;\r\nstruct hci_conn *conn;\r\nunsigned long conn_info_age;\r\nint err = 0;\r\nBT_DBG("%s", hdev->name);\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (!bdaddr_type_is_valid(cp->addr.type))\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\r\nMGMT_STATUS_NOT_POWERED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nif (cp->addr.type == BDADDR_BREDR)\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\r\n&cp->addr.bdaddr);\r\nelse\r\nconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->addr.bdaddr);\r\nif (!conn || conn->state != BT_CONNECTED) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\r\nMGMT_STATUS_NOT_CONNECTED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nif (pending_find_data(MGMT_OP_GET_CONN_INFO, hdev, conn)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\r\nMGMT_STATUS_BUSY, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\nconn_info_age = hdev->conn_info_min_age +\r\nprandom_u32_max(hdev->conn_info_max_age -\r\nhdev->conn_info_min_age);\r\nif (time_after(jiffies, conn->conn_info_timestamp +\r\nmsecs_to_jiffies(conn_info_age)) ||\r\n!conn->conn_info_timestamp) {\r\nstruct hci_request req;\r\nstruct hci_cp_read_tx_power req_txp_cp;\r\nstruct hci_cp_read_rssi req_rssi_cp;\r\nstruct mgmt_pending_cmd *cmd;\r\nhci_req_init(&req, hdev);\r\nreq_rssi_cp.handle = cpu_to_le16(conn->handle);\r\nhci_req_add(&req, HCI_OP_READ_RSSI, sizeof(req_rssi_cp),\r\n&req_rssi_cp);\r\nif (!bdaddr_type_is_le(cp->addr.type) ||\r\nconn->tx_power == HCI_TX_POWER_INVALID) {\r\nreq_txp_cp.handle = cpu_to_le16(conn->handle);\r\nreq_txp_cp.type = 0x00;\r\nhci_req_add(&req, HCI_OP_READ_TX_POWER,\r\nsizeof(req_txp_cp), &req_txp_cp);\r\n}\r\nif (conn->max_tx_power == HCI_TX_POWER_INVALID) {\r\nreq_txp_cp.handle = cpu_to_le16(conn->handle);\r\nreq_txp_cp.type = 0x01;\r\nhci_req_add(&req, HCI_OP_READ_TX_POWER,\r\nsizeof(req_txp_cp), &req_txp_cp);\r\n}\r\nerr = hci_req_run(&req, conn_info_refresh_complete);\r\nif (err < 0)\r\ngoto unlock;\r\ncmd = mgmt_pending_add(sk, MGMT_OP_GET_CONN_INFO, hdev,\r\ndata, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_conn_hold(conn);\r\ncmd->user_data = hci_conn_get(conn);\r\ncmd->cmd_complete = conn_info_cmd_complete;\r\nconn->conn_info_timestamp = jiffies;\r\n} else {\r\nrp.rssi = conn->rssi;\r\nrp.tx_power = conn->tx_power;\r\nrp.max_tx_power = conn->max_tx_power;\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CONN_INFO,\r\nMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int clock_info_cmd_complete(struct mgmt_pending_cmd *cmd, u8 status)\r\n{\r\nstruct hci_conn *conn = cmd->user_data;\r\nstruct mgmt_rp_get_clock_info rp;\r\nstruct hci_dev *hdev;\r\nint err;\r\nmemset(&rp, 0, sizeof(rp));\r\nmemcpy(&rp.addr, &cmd->param, sizeof(rp.addr));\r\nif (status)\r\ngoto complete;\r\nhdev = hci_dev_get(cmd->index);\r\nif (hdev) {\r\nrp.local_clock = cpu_to_le32(hdev->clock);\r\nhci_dev_put(hdev);\r\n}\r\nif (conn) {\r\nrp.piconet_clock = cpu_to_le32(conn->clock);\r\nrp.accuracy = cpu_to_le16(conn->clock_accuracy);\r\n}\r\ncomplete:\r\nerr = mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, status, &rp,\r\nsizeof(rp));\r\nif (conn) {\r\nhci_conn_drop(conn);\r\nhci_conn_put(conn);\r\n}\r\nreturn err;\r\n}\r\nstatic void get_clock_info_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nstruct hci_cp_read_clock *hci_cp;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status %u", hdev->name, status);\r\nhci_dev_lock(hdev);\r\nhci_cp = hci_sent_cmd_data(hdev, HCI_OP_READ_CLOCK);\r\nif (!hci_cp)\r\ngoto unlock;\r\nif (hci_cp->which) {\r\nu16 handle = __le16_to_cpu(hci_cp->handle);\r\nconn = hci_conn_hash_lookup_handle(hdev, handle);\r\n} else {\r\nconn = NULL;\r\n}\r\ncmd = pending_find_data(MGMT_OP_GET_CLOCK_INFO, hdev, conn);\r\nif (!cmd)\r\ngoto unlock;\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int get_clock_info(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_get_clock_info *cp = data;\r\nstruct mgmt_rp_get_clock_info rp;\r\nstruct hci_cp_read_clock hci_cp;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nstruct hci_conn *conn;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nmemset(&rp, 0, sizeof(rp));\r\nbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\r\nrp.addr.type = cp->addr.type;\r\nif (cp->addr.type != BDADDR_BREDR)\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&rp, sizeof(rp));\r\nhci_dev_lock(hdev);\r\nif (!hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_CLOCK_INFO,\r\nMGMT_STATUS_NOT_POWERED, &rp,\r\nsizeof(rp));\r\ngoto unlock;\r\n}\r\nif (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,\r\n&cp->addr.bdaddr);\r\nif (!conn || conn->state != BT_CONNECTED) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_GET_CLOCK_INFO,\r\nMGMT_STATUS_NOT_CONNECTED,\r\n&rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\n} else {\r\nconn = NULL;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_GET_CLOCK_INFO, hdev, data, len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ncmd->cmd_complete = clock_info_cmd_complete;\r\nhci_req_init(&req, hdev);\r\nmemset(&hci_cp, 0, sizeof(hci_cp));\r\nhci_req_add(&req, HCI_OP_READ_CLOCK, sizeof(hci_cp), &hci_cp);\r\nif (conn) {\r\nhci_conn_hold(conn);\r\ncmd->user_data = hci_conn_get(conn);\r\nhci_cp.handle = cpu_to_le16(conn->handle);\r\nhci_cp.which = 0x01;\r\nhci_req_add(&req, HCI_OP_READ_CLOCK, sizeof(hci_cp), &hci_cp);\r\n}\r\nerr = hci_req_run(&req, get_clock_info_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)\r\n{\r\nstruct hci_conn *conn;\r\nconn = hci_conn_hash_lookup_ba(hdev, LE_LINK, addr);\r\nif (!conn)\r\nreturn false;\r\nif (conn->dst_type != type)\r\nreturn false;\r\nif (conn->state != BT_CONNECTED)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr,\r\nu8 addr_type, u8 auto_connect)\r\n{\r\nstruct hci_conn_params *params;\r\nparams = hci_conn_params_add(hdev, addr, addr_type);\r\nif (!params)\r\nreturn -EIO;\r\nif (params->auto_connect == auto_connect)\r\nreturn 0;\r\nlist_del_init(&params->action);\r\nswitch (auto_connect) {\r\ncase HCI_AUTO_CONN_DISABLED:\r\ncase HCI_AUTO_CONN_LINK_LOSS:\r\nif (params->explicit_connect)\r\nlist_add(&params->action, &hdev->pend_le_conns);\r\nbreak;\r\ncase HCI_AUTO_CONN_REPORT:\r\nif (params->explicit_connect)\r\nlist_add(&params->action, &hdev->pend_le_conns);\r\nelse\r\nlist_add(&params->action, &hdev->pend_le_reports);\r\nbreak;\r\ncase HCI_AUTO_CONN_DIRECT:\r\ncase HCI_AUTO_CONN_ALWAYS:\r\nif (!is_connected(hdev, addr, addr_type))\r\nlist_add(&params->action, &hdev->pend_le_conns);\r\nbreak;\r\n}\r\nparams->auto_connect = auto_connect;\r\nBT_DBG("addr %pMR (type %u) auto_connect %u", addr, addr_type,\r\nauto_connect);\r\nreturn 0;\r\n}\r\nstatic void device_added(struct sock *sk, struct hci_dev *hdev,\r\nbdaddr_t *bdaddr, u8 type, u8 action)\r\n{\r\nstruct mgmt_ev_device_added ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = type;\r\nev.action = action;\r\nmgmt_event(MGMT_EV_DEVICE_ADDED, hdev, &ev, sizeof(ev), sk);\r\n}\r\nstatic int add_device(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_add_device *cp = data;\r\nu8 auto_conn, addr_type;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!bdaddr_type_is_valid(cp->addr.type) ||\r\n!bacmp(&cp->addr.bdaddr, BDADDR_ANY))\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\nif (cp->action != 0x00 && cp->action != 0x01 && cp->action != 0x02)\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\nhci_dev_lock(hdev);\r\nif (cp->addr.type == BDADDR_BREDR) {\r\nif (cp->action != 0x01) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_ADD_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nerr = hci_bdaddr_list_add(&hdev->whitelist, &cp->addr.bdaddr,\r\ncp->addr.type);\r\nif (err)\r\ngoto unlock;\r\nhci_req_update_scan(hdev);\r\ngoto added;\r\n}\r\naddr_type = le_addr_type(cp->addr.type);\r\nif (cp->action == 0x02)\r\nauto_conn = HCI_AUTO_CONN_ALWAYS;\r\nelse if (cp->action == 0x01)\r\nauto_conn = HCI_AUTO_CONN_DIRECT;\r\nelse\r\nauto_conn = HCI_AUTO_CONN_REPORT;\r\nif (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nif (hci_conn_params_set(hdev, &cp->addr.bdaddr, addr_type,\r\nauto_conn) < 0) {\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\r\nMGMT_STATUS_FAILED, &cp->addr,\r\nsizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nhci_update_background_scan(hdev);\r\nadded:\r\ndevice_added(sk, hdev, &cp->addr.bdaddr, cp->addr.type, cp->action);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_DEVICE,\r\nMGMT_STATUS_SUCCESS, &cp->addr,\r\nsizeof(cp->addr));\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void device_removed(struct sock *sk, struct hci_dev *hdev,\r\nbdaddr_t *bdaddr, u8 type)\r\n{\r\nstruct mgmt_ev_device_removed ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = type;\r\nmgmt_event(MGMT_EV_DEVICE_REMOVED, hdev, &ev, sizeof(ev), sk);\r\n}\r\nstatic int remove_device(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_remove_device *cp = data;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (bacmp(&cp->addr.bdaddr, BDADDR_ANY)) {\r\nstruct hci_conn_params *params;\r\nu8 addr_type;\r\nif (!bdaddr_type_is_valid(cp->addr.type)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nif (cp->addr.type == BDADDR_BREDR) {\r\nerr = hci_bdaddr_list_del(&hdev->whitelist,\r\n&cp->addr.bdaddr,\r\ncp->addr.type);\r\nif (err) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr,\r\nsizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nhci_req_update_scan(hdev);\r\ndevice_removed(sk, hdev, &cp->addr.bdaddr,\r\ncp->addr.type);\r\ngoto complete;\r\n}\r\naddr_type = le_addr_type(cp->addr.type);\r\nif (!hci_is_identity_address(&cp->addr.bdaddr, addr_type)) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nparams = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,\r\naddr_type);\r\nif (!params) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nif (params->auto_connect == HCI_AUTO_CONN_DISABLED ||\r\nparams->auto_connect == HCI_AUTO_CONN_EXPLICIT) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nlist_del(&params->action);\r\nlist_del(&params->list);\r\nkfree(params);\r\nhci_update_background_scan(hdev);\r\ndevice_removed(sk, hdev, &cp->addr.bdaddr, cp->addr.type);\r\n} else {\r\nstruct hci_conn_params *p, *tmp;\r\nstruct bdaddr_list *b, *btmp;\r\nif (cp->addr.type) {\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_DEVICE,\r\nMGMT_STATUS_INVALID_PARAMS,\r\n&cp->addr, sizeof(cp->addr));\r\ngoto unlock;\r\n}\r\nlist_for_each_entry_safe(b, btmp, &hdev->whitelist, list) {\r\ndevice_removed(sk, hdev, &b->bdaddr, b->bdaddr_type);\r\nlist_del(&b->list);\r\nkfree(b);\r\n}\r\nhci_req_update_scan(hdev);\r\nlist_for_each_entry_safe(p, tmp, &hdev->le_conn_params, list) {\r\nif (p->auto_connect == HCI_AUTO_CONN_DISABLED)\r\ncontinue;\r\ndevice_removed(sk, hdev, &p->addr, p->addr_type);\r\nif (p->explicit_connect) {\r\np->auto_connect = HCI_AUTO_CONN_EXPLICIT;\r\ncontinue;\r\n}\r\nlist_del(&p->action);\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nBT_DBG("All LE connection parameters were removed");\r\nhci_update_background_scan(hdev);\r\n}\r\ncomplete:\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_DEVICE,\r\nMGMT_STATUS_SUCCESS, &cp->addr,\r\nsizeof(cp->addr));\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int load_conn_param(struct sock *sk, struct hci_dev *hdev, void *data,\r\nu16 len)\r\n{\r\nstruct mgmt_cp_load_conn_param *cp = data;\r\nconst u16 max_param_count = ((U16_MAX - sizeof(*cp)) /\r\nsizeof(struct mgmt_conn_param));\r\nu16 param_count, expected_len;\r\nint i;\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nparam_count = __le16_to_cpu(cp->param_count);\r\nif (param_count > max_param_count) {\r\nBT_ERR("load_conn_param: too big param_count value %u",\r\nparam_count);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nexpected_len = sizeof(*cp) + param_count *\r\nsizeof(struct mgmt_conn_param);\r\nif (expected_len != len) {\r\nBT_ERR("load_conn_param: expected %u bytes, got %u bytes",\r\nexpected_len, len);\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM,\r\nMGMT_STATUS_INVALID_PARAMS);\r\n}\r\nBT_DBG("%s param_count %u", hdev->name, param_count);\r\nhci_dev_lock(hdev);\r\nhci_conn_params_clear_disabled(hdev);\r\nfor (i = 0; i < param_count; i++) {\r\nstruct mgmt_conn_param *param = &cp->params[i];\r\nstruct hci_conn_params *hci_param;\r\nu16 min, max, latency, timeout;\r\nu8 addr_type;\r\nBT_DBG("Adding %pMR (type %u)", &param->addr.bdaddr,\r\nparam->addr.type);\r\nif (param->addr.type == BDADDR_LE_PUBLIC) {\r\naddr_type = ADDR_LE_DEV_PUBLIC;\r\n} else if (param->addr.type == BDADDR_LE_RANDOM) {\r\naddr_type = ADDR_LE_DEV_RANDOM;\r\n} else {\r\nBT_ERR("Ignoring invalid connection parameters");\r\ncontinue;\r\n}\r\nmin = le16_to_cpu(param->min_interval);\r\nmax = le16_to_cpu(param->max_interval);\r\nlatency = le16_to_cpu(param->latency);\r\ntimeout = le16_to_cpu(param->timeout);\r\nBT_DBG("min 0x%04x max 0x%04x latency 0x%04x timeout 0x%04x",\r\nmin, max, latency, timeout);\r\nif (hci_check_conn_params(min, max, latency, timeout) < 0) {\r\nBT_ERR("Ignoring invalid connection parameters");\r\ncontinue;\r\n}\r\nhci_param = hci_conn_params_add(hdev, &param->addr.bdaddr,\r\naddr_type);\r\nif (!hci_param) {\r\nBT_ERR("Failed to add connection parameters");\r\ncontinue;\r\n}\r\nhci_param->conn_min_interval = min;\r\nhci_param->conn_max_interval = max;\r\nhci_param->conn_latency = latency;\r\nhci_param->supervision_timeout = timeout;\r\n}\r\nhci_dev_unlock(hdev);\r\nreturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_LOAD_CONN_PARAM, 0,\r\nNULL, 0);\r\n}\r\nstatic int set_external_config(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_set_external_config *cp = data;\r\nbool changed;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (hdev_is_powered(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\r\nMGMT_STATUS_REJECTED);\r\nif (cp->config != 0x00 && cp->config != 0x01)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (!test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_EXTERNAL_CONFIG,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nhci_dev_lock(hdev);\r\nif (cp->config)\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_EXT_CONFIGURED);\r\nelse\r\nchanged = hci_dev_test_and_clear_flag(hdev, HCI_EXT_CONFIGURED);\r\nerr = send_options_rsp(sk, MGMT_OP_SET_EXTERNAL_CONFIG, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (!changed)\r\ngoto unlock;\r\nerr = new_options(hdev, sk);\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED) == is_configured(hdev)) {\r\nmgmt_index_removed(hdev);\r\nif (hci_dev_test_and_change_flag(hdev, HCI_UNCONFIGURED)) {\r\nhci_dev_set_flag(hdev, HCI_CONFIG);\r\nhci_dev_set_flag(hdev, HCI_AUTO_OFF);\r\nqueue_work(hdev->req_workqueue, &hdev->power_on);\r\n} else {\r\nset_bit(HCI_RAW, &hdev->flags);\r\nmgmt_index_added(hdev);\r\n}\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic int set_public_address(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_cp_set_public_address *cp = data;\r\nbool changed;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (hdev_is_powered(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\r\nMGMT_STATUS_REJECTED);\r\nif (!bacmp(&cp->bdaddr, BDADDR_ANY))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (!hdev->set_bdaddr)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_PUBLIC_ADDRESS,\r\nMGMT_STATUS_NOT_SUPPORTED);\r\nhci_dev_lock(hdev);\r\nchanged = !!bacmp(&hdev->public_addr, &cp->bdaddr);\r\nbacpy(&hdev->public_addr, &cp->bdaddr);\r\nerr = send_options_rsp(sk, MGMT_OP_SET_PUBLIC_ADDRESS, hdev);\r\nif (err < 0)\r\ngoto unlock;\r\nif (!changed)\r\ngoto unlock;\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\r\nerr = new_options(hdev, sk);\r\nif (is_configured(hdev)) {\r\nmgmt_index_removed(hdev);\r\nhci_dev_clear_flag(hdev, HCI_UNCONFIGURED);\r\nhci_dev_set_flag(hdev, HCI_CONFIG);\r\nhci_dev_set_flag(hdev, HCI_AUTO_OFF);\r\nqueue_work(hdev->req_workqueue, &hdev->power_on);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,\r\nu8 data_len)\r\n{\r\neir[eir_len++] = sizeof(type) + data_len;\r\neir[eir_len++] = type;\r\nmemcpy(&eir[eir_len], data, data_len);\r\neir_len += data_len;\r\nreturn eir_len;\r\n}\r\nstatic void read_local_oob_ext_data_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode, struct sk_buff *skb)\r\n{\r\nconst struct mgmt_cp_read_local_oob_ext_data *mgmt_cp;\r\nstruct mgmt_rp_read_local_oob_ext_data *mgmt_rp;\r\nu8 *h192, *r192, *h256, *r256;\r\nstruct mgmt_pending_cmd *cmd;\r\nu16 eir_len;\r\nint err;\r\nBT_DBG("%s status %u", hdev->name, status);\r\ncmd = pending_find(MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev);\r\nif (!cmd)\r\nreturn;\r\nmgmt_cp = cmd->param;\r\nif (status) {\r\nstatus = mgmt_status(status);\r\neir_len = 0;\r\nh192 = NULL;\r\nr192 = NULL;\r\nh256 = NULL;\r\nr256 = NULL;\r\n} else if (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {\r\nstruct hci_rp_read_local_oob_data *rp;\r\nif (skb->len != sizeof(*rp)) {\r\nstatus = MGMT_STATUS_FAILED;\r\neir_len = 0;\r\n} else {\r\nstatus = MGMT_STATUS_SUCCESS;\r\nrp = (void *)skb->data;\r\neir_len = 5 + 18 + 18;\r\nh192 = rp->hash;\r\nr192 = rp->rand;\r\nh256 = NULL;\r\nr256 = NULL;\r\n}\r\n} else {\r\nstruct hci_rp_read_local_oob_ext_data *rp;\r\nif (skb->len != sizeof(*rp)) {\r\nstatus = MGMT_STATUS_FAILED;\r\neir_len = 0;\r\n} else {\r\nstatus = MGMT_STATUS_SUCCESS;\r\nrp = (void *)skb->data;\r\nif (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\r\neir_len = 5 + 18 + 18;\r\nh192 = NULL;\r\nr192 = NULL;\r\n} else {\r\neir_len = 5 + 18 + 18 + 18 + 18;\r\nh192 = rp->hash192;\r\nr192 = rp->rand192;\r\n}\r\nh256 = rp->hash256;\r\nr256 = rp->rand256;\r\n}\r\n}\r\nmgmt_rp = kmalloc(sizeof(*mgmt_rp) + eir_len, GFP_KERNEL);\r\nif (!mgmt_rp)\r\ngoto done;\r\nif (status)\r\ngoto send_rsp;\r\neir_len = eir_append_data(mgmt_rp->eir, 0, EIR_CLASS_OF_DEV,\r\nhdev->dev_class, 3);\r\nif (h192 && r192) {\r\neir_len = eir_append_data(mgmt_rp->eir, eir_len,\r\nEIR_SSP_HASH_C192, h192, 16);\r\neir_len = eir_append_data(mgmt_rp->eir, eir_len,\r\nEIR_SSP_RAND_R192, r192, 16);\r\n}\r\nif (h256 && r256) {\r\neir_len = eir_append_data(mgmt_rp->eir, eir_len,\r\nEIR_SSP_HASH_C256, h256, 16);\r\neir_len = eir_append_data(mgmt_rp->eir, eir_len,\r\nEIR_SSP_RAND_R256, r256, 16);\r\n}\r\nsend_rsp:\r\nmgmt_rp->type = mgmt_cp->type;\r\nmgmt_rp->eir_len = cpu_to_le16(eir_len);\r\nerr = mgmt_cmd_complete(cmd->sk, hdev->id,\r\nMGMT_OP_READ_LOCAL_OOB_EXT_DATA, status,\r\nmgmt_rp, sizeof(*mgmt_rp) + eir_len);\r\nif (err < 0 || status)\r\ngoto done;\r\nhci_sock_set_flag(cmd->sk, HCI_MGMT_OOB_DATA_EVENTS);\r\nerr = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,\r\nmgmt_rp, sizeof(*mgmt_rp) + eir_len,\r\nHCI_MGMT_OOB_DATA_EVENTS, cmd->sk);\r\ndone:\r\nkfree(mgmt_rp);\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic int read_local_ssp_oob_req(struct hci_dev *hdev, struct sock *sk,\r\nstruct mgmt_cp_read_local_oob_ext_data *cp)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\ncmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev,\r\ncp, sizeof(*cp));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nhci_req_init(&req, hdev);\r\nif (bredr_sc_enabled(hdev))\r\nhci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);\r\nelse\r\nhci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);\r\nerr = hci_req_run_skb(&req, read_local_oob_ext_data_complete);\r\nif (err < 0) {\r\nmgmt_pending_remove(cmd);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_local_oob_ext_data(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_cp_read_local_oob_ext_data *cp = data;\r\nstruct mgmt_rp_read_local_oob_ext_data *rp;\r\nsize_t rp_len;\r\nu16 eir_len;\r\nu8 status, flags, role, addr[7], hash[16], rand[16];\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (hdev_is_powered(hdev)) {\r\nswitch (cp->type) {\r\ncase BIT(BDADDR_BREDR):\r\nstatus = mgmt_bredr_support(hdev);\r\nif (status)\r\neir_len = 0;\r\nelse\r\neir_len = 5;\r\nbreak;\r\ncase (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):\r\nstatus = mgmt_le_support(hdev);\r\nif (status)\r\neir_len = 0;\r\nelse\r\neir_len = 9 + 3 + 18 + 18 + 3;\r\nbreak;\r\ndefault:\r\nstatus = MGMT_STATUS_INVALID_PARAMS;\r\neir_len = 0;\r\nbreak;\r\n}\r\n} else {\r\nstatus = MGMT_STATUS_NOT_POWERED;\r\neir_len = 0;\r\n}\r\nrp_len = sizeof(*rp) + eir_len;\r\nrp = kmalloc(rp_len, GFP_ATOMIC);\r\nif (!rp)\r\nreturn -ENOMEM;\r\nif (status)\r\ngoto complete;\r\nhci_dev_lock(hdev);\r\neir_len = 0;\r\nswitch (cp->type) {\r\ncase BIT(BDADDR_BREDR):\r\nif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\r\nerr = read_local_ssp_oob_req(hdev, sk, cp);\r\nhci_dev_unlock(hdev);\r\nif (!err)\r\ngoto done;\r\nstatus = MGMT_STATUS_FAILED;\r\ngoto complete;\r\n} else {\r\neir_len = eir_append_data(rp->eir, eir_len,\r\nEIR_CLASS_OF_DEV,\r\nhdev->dev_class, 3);\r\n}\r\nbreak;\r\ncase (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):\r\nif (hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&\r\nsmp_generate_oob(hdev, hash, rand) < 0) {\r\nhci_dev_unlock(hdev);\r\nstatus = MGMT_STATUS_FAILED;\r\ngoto complete;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_PRIVACY)) {\r\nhci_dev_unlock(hdev);\r\nstatus = MGMT_STATUS_REJECTED;\r\ngoto complete;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\r\n!bacmp(&hdev->bdaddr, BDADDR_ANY) ||\r\n(!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\r\nbacmp(&hdev->static_addr, BDADDR_ANY))) {\r\nmemcpy(addr, &hdev->static_addr, 6);\r\naddr[6] = 0x01;\r\n} else {\r\nmemcpy(addr, &hdev->bdaddr, 6);\r\naddr[6] = 0x00;\r\n}\r\neir_len = eir_append_data(rp->eir, eir_len, EIR_LE_BDADDR,\r\naddr, sizeof(addr));\r\nif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\r\nrole = 0x02;\r\nelse\r\nrole = 0x01;\r\neir_len = eir_append_data(rp->eir, eir_len, EIR_LE_ROLE,\r\n&role, sizeof(role));\r\nif (hci_dev_test_flag(hdev, HCI_SC_ENABLED)) {\r\neir_len = eir_append_data(rp->eir, eir_len,\r\nEIR_LE_SC_CONFIRM,\r\nhash, sizeof(hash));\r\neir_len = eir_append_data(rp->eir, eir_len,\r\nEIR_LE_SC_RANDOM,\r\nrand, sizeof(rand));\r\n}\r\nflags = mgmt_get_adv_discov_flags(hdev);\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\r\nflags |= LE_AD_NO_BREDR;\r\neir_len = eir_append_data(rp->eir, eir_len, EIR_FLAGS,\r\n&flags, sizeof(flags));\r\nbreak;\r\n}\r\nhci_dev_unlock(hdev);\r\nhci_sock_set_flag(sk, HCI_MGMT_OOB_DATA_EVENTS);\r\nstatus = MGMT_STATUS_SUCCESS;\r\ncomplete:\r\nrp->type = cp->type;\r\nrp->eir_len = cpu_to_le16(eir_len);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_EXT_DATA,\r\nstatus, rp, sizeof(*rp) + eir_len);\r\nif (err < 0 || status)\r\ngoto done;\r\nerr = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,\r\nrp, sizeof(*rp) + eir_len,\r\nHCI_MGMT_OOB_DATA_EVENTS, sk);\r\ndone:\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic u32 get_supported_adv_flags(struct hci_dev *hdev)\r\n{\r\nu32 flags = 0;\r\nflags |= MGMT_ADV_FLAG_CONNECTABLE;\r\nflags |= MGMT_ADV_FLAG_DISCOV;\r\nflags |= MGMT_ADV_FLAG_LIMITED_DISCOV;\r\nflags |= MGMT_ADV_FLAG_MANAGED_FLAGS;\r\nif (hdev->adv_tx_power != HCI_TX_POWER_INVALID)\r\nflags |= MGMT_ADV_FLAG_TX_POWER;\r\nreturn flags;\r\n}\r\nstatic int read_adv_features(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_rp_read_adv_features *rp;\r\nsize_t rp_len;\r\nint err;\r\nstruct adv_info *adv_instance;\r\nu32 supported_flags;\r\nu8 *instance;\r\nBT_DBG("%s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,\r\nMGMT_STATUS_REJECTED);\r\nhci_dev_lock(hdev);\r\nrp_len = sizeof(*rp) + hdev->adv_instance_cnt;\r\nrp = kmalloc(rp_len, GFP_ATOMIC);\r\nif (!rp) {\r\nhci_dev_unlock(hdev);\r\nreturn -ENOMEM;\r\n}\r\nsupported_flags = get_supported_adv_flags(hdev);\r\nrp->supported_flags = cpu_to_le32(supported_flags);\r\nrp->max_adv_data_len = HCI_MAX_AD_LENGTH;\r\nrp->max_scan_rsp_len = HCI_MAX_AD_LENGTH;\r\nrp->max_instances = HCI_MAX_ADV_INSTANCES;\r\nrp->num_instances = hdev->adv_instance_cnt;\r\ninstance = rp->instance;\r\nlist_for_each_entry(adv_instance, &hdev->adv_instances, list) {\r\n*instance = adv_instance->instance;\r\ninstance++;\r\n}\r\nhci_dev_unlock(hdev);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,\r\nMGMT_STATUS_SUCCESS, rp, rp_len);\r\nkfree(rp);\r\nreturn err;\r\n}\r\nstatic bool tlv_data_is_valid(struct hci_dev *hdev, u32 adv_flags, u8 *data,\r\nu8 len, bool is_adv_data)\r\n{\r\nu8 max_len = HCI_MAX_AD_LENGTH;\r\nint i, cur_len;\r\nbool flags_managed = false;\r\nbool tx_power_managed = false;\r\nif (is_adv_data) {\r\nif (adv_flags & (MGMT_ADV_FLAG_DISCOV |\r\nMGMT_ADV_FLAG_LIMITED_DISCOV |\r\nMGMT_ADV_FLAG_MANAGED_FLAGS)) {\r\nflags_managed = true;\r\nmax_len -= 3;\r\n}\r\nif (adv_flags & MGMT_ADV_FLAG_TX_POWER) {\r\ntx_power_managed = true;\r\nmax_len -= 3;\r\n}\r\n}\r\nif (len > max_len)\r\nreturn false;\r\nfor (i = 0, cur_len = 0; i < len; i += (cur_len + 1)) {\r\ncur_len = data[i];\r\nif (flags_managed && data[i + 1] == EIR_FLAGS)\r\nreturn false;\r\nif (tx_power_managed && data[i + 1] == EIR_TX_POWER)\r\nreturn false;\r\nif (i + cur_len >= len)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void add_advertising_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct mgmt_cp_add_advertising *cp;\r\nstruct mgmt_rp_add_advertising rp;\r\nstruct adv_info *adv_instance, *n;\r\nu8 instance;\r\nBT_DBG("status %d", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_ADD_ADVERTISING, hdev);\r\nlist_for_each_entry_safe(adv_instance, n, &hdev->adv_instances, list) {\r\nif (!adv_instance->pending)\r\ncontinue;\r\nif (!status) {\r\nadv_instance->pending = false;\r\ncontinue;\r\n}\r\ninstance = adv_instance->instance;\r\nif (hdev->cur_adv_instance == instance)\r\ncancel_adv_timeout(hdev);\r\nhci_remove_adv_instance(hdev, instance);\r\nmgmt_advertising_removed(cmd ? cmd->sk : NULL, hdev, instance);\r\n}\r\nif (!cmd)\r\ngoto unlock;\r\ncp = cmd->param;\r\nrp.instance = cp->instance;\r\nif (status)\r\nmgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,\r\nmgmt_status(status));\r\nelse\r\nmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,\r\nmgmt_status(status), &rp, sizeof(rp));\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int add_advertising(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_cp_add_advertising *cp = data;\r\nstruct mgmt_rp_add_advertising rp;\r\nu32 flags;\r\nu32 supported_flags;\r\nu8 status;\r\nu16 timeout, duration;\r\nunsigned int prev_instance_cnt = hdev->adv_instance_cnt;\r\nu8 schedule_instance = 0;\r\nstruct adv_info *next_instance;\r\nint err;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nBT_DBG("%s", hdev->name);\r\nstatus = mgmt_le_support(hdev);\r\nif (status)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nstatus);\r\nif (cp->instance < 1 || cp->instance > HCI_MAX_ADV_INSTANCES)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nif (data_len != sizeof(*cp) + cp->adv_data_len + cp->scan_rsp_len)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nflags = __le32_to_cpu(cp->flags);\r\ntimeout = __le16_to_cpu(cp->timeout);\r\nduration = __le16_to_cpu(cp->duration);\r\nsupported_flags = get_supported_adv_flags(hdev);\r\nif (flags & ~supported_flags)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nhci_dev_lock(hdev);\r\nif (timeout && !hdev_is_powered(hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_REJECTED);\r\ngoto unlock;\r\n}\r\nif (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||\r\npending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||\r\npending_find(MGMT_OP_SET_LE, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif (!tlv_data_is_valid(hdev, flags, cp->data, cp->adv_data_len, true) ||\r\n!tlv_data_is_valid(hdev, flags, cp->data + cp->adv_data_len,\r\ncp->scan_rsp_len, false)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nerr = hci_add_adv_instance(hdev, cp->instance, flags,\r\ncp->adv_data_len, cp->data,\r\ncp->scan_rsp_len,\r\ncp->data + cp->adv_data_len,\r\ntimeout, duration);\r\nif (err < 0) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_FAILED);\r\ngoto unlock;\r\n}\r\nif (hdev->adv_instance_cnt > prev_instance_cnt)\r\nmgmt_advertising_added(sk, hdev, cp->instance);\r\nif (hdev->cur_adv_instance == cp->instance) {\r\ncancel_adv_timeout(hdev);\r\nnext_instance = hci_get_next_instance(hdev, cp->instance);\r\nif (next_instance)\r\nschedule_instance = next_instance->instance;\r\n} else if (!hdev->adv_instance_timeout) {\r\nschedule_instance = cp->instance;\r\n}\r\nif (!hdev_is_powered(hdev) ||\r\nhci_dev_test_flag(hdev, HCI_ADVERTISING) ||\r\n!schedule_instance) {\r\nrp.instance = cp->instance;\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,\r\nMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_ADD_ADVERTISING, hdev, data,\r\ndata_len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nerr = __hci_req_schedule_adv_instance(&req, schedule_instance, true);\r\nif (!err)\r\nerr = hci_req_run(&req, add_advertising_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic void remove_advertising_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct mgmt_cp_remove_advertising *cp;\r\nstruct mgmt_rp_remove_advertising rp;\r\nBT_DBG("status %d", status);\r\nhci_dev_lock(hdev);\r\ncmd = pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev);\r\nif (!cmd)\r\ngoto unlock;\r\ncp = cmd->param;\r\nrp.instance = cp->instance;\r\nmgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, MGMT_STATUS_SUCCESS,\r\n&rp, sizeof(rp));\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int remove_advertising(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_cp_remove_advertising *cp = data;\r\nstruct mgmt_rp_remove_advertising rp;\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct hci_request req;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (cp->instance && !hci_find_adv_instance(hdev, cp->instance)) {\r\nerr = mgmt_cmd_status(sk, hdev->id,\r\nMGMT_OP_REMOVE_ADVERTISING,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nif (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||\r\npending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||\r\npending_find(MGMT_OP_SET_LE, hdev)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,\r\nMGMT_STATUS_BUSY);\r\ngoto unlock;\r\n}\r\nif (list_empty(&hdev->adv_instances)) {\r\nerr = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,\r\nMGMT_STATUS_INVALID_PARAMS);\r\ngoto unlock;\r\n}\r\nhci_req_init(&req, hdev);\r\nhci_req_clear_adv_instance(hdev, &req, cp->instance, true);\r\nif (list_empty(&hdev->adv_instances))\r\n__hci_req_disable_advertising(&req);\r\nif (skb_queue_empty(&req.cmd_q) ||\r\n!hdev_is_powered(hdev) ||\r\nhci_dev_test_flag(hdev, HCI_ADVERTISING)) {\r\nrp.instance = cp->instance;\r\nerr = mgmt_cmd_complete(sk, hdev->id,\r\nMGMT_OP_REMOVE_ADVERTISING,\r\nMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\r\ngoto unlock;\r\n}\r\ncmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_ADVERTISING, hdev, data,\r\ndata_len);\r\nif (!cmd) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nerr = hci_req_run(&req, remove_advertising_complete);\r\nif (err < 0)\r\nmgmt_pending_remove(cmd);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nreturn err;\r\n}\r\nstatic u8 tlv_data_max_len(u32 adv_flags, bool is_adv_data)\r\n{\r\nu8 max_len = HCI_MAX_AD_LENGTH;\r\nif (is_adv_data) {\r\nif (adv_flags & (MGMT_ADV_FLAG_DISCOV |\r\nMGMT_ADV_FLAG_LIMITED_DISCOV |\r\nMGMT_ADV_FLAG_MANAGED_FLAGS))\r\nmax_len -= 3;\r\nif (adv_flags & MGMT_ADV_FLAG_TX_POWER)\r\nmax_len -= 3;\r\n}\r\nreturn max_len;\r\n}\r\nstatic int get_adv_size_info(struct sock *sk, struct hci_dev *hdev,\r\nvoid *data, u16 data_len)\r\n{\r\nstruct mgmt_cp_get_adv_size_info *cp = data;\r\nstruct mgmt_rp_get_adv_size_info rp;\r\nu32 flags, supported_flags;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!lmp_le_capable(hdev))\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\r\nMGMT_STATUS_REJECTED);\r\nif (cp->instance < 1 || cp->instance > HCI_MAX_ADV_INSTANCES)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nflags = __le32_to_cpu(cp->flags);\r\nsupported_flags = get_supported_adv_flags(hdev);\r\nif (flags & ~supported_flags)\r\nreturn mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\r\nMGMT_STATUS_INVALID_PARAMS);\r\nrp.instance = cp->instance;\r\nrp.flags = cp->flags;\r\nrp.max_adv_data_len = tlv_data_max_len(flags, true);\r\nrp.max_scan_rsp_len = tlv_data_max_len(flags, false);\r\nerr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,\r\nMGMT_STATUS_SUCCESS, &rp, sizeof(rp));\r\nreturn err;\r\n}\r\nvoid mgmt_index_added(struct hci_dev *hdev)\r\n{\r\nstruct mgmt_ev_ext_index ev;\r\nif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\r\nreturn;\r\nswitch (hdev->dev_type) {\r\ncase HCI_BREDR:\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nmgmt_index_event(MGMT_EV_UNCONF_INDEX_ADDED, hdev,\r\nNULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);\r\nev.type = 0x01;\r\n} else {\r\nmgmt_index_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0,\r\nHCI_MGMT_INDEX_EVENTS);\r\nev.type = 0x00;\r\n}\r\nbreak;\r\ncase HCI_AMP:\r\nev.type = 0x02;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nev.bus = hdev->bus;\r\nmgmt_index_event(MGMT_EV_EXT_INDEX_ADDED, hdev, &ev, sizeof(ev),\r\nHCI_MGMT_EXT_INDEX_EVENTS);\r\n}\r\nvoid mgmt_index_removed(struct hci_dev *hdev)\r\n{\r\nstruct mgmt_ev_ext_index ev;\r\nu8 status = MGMT_STATUS_INVALID_INDEX;\r\nif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\r\nreturn;\r\nswitch (hdev->dev_type) {\r\ncase HCI_BREDR:\r\nmgmt_pending_foreach(0, hdev, cmd_complete_rsp, &status);\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nmgmt_index_event(MGMT_EV_UNCONF_INDEX_REMOVED, hdev,\r\nNULL, 0, HCI_MGMT_UNCONF_INDEX_EVENTS);\r\nev.type = 0x01;\r\n} else {\r\nmgmt_index_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0,\r\nHCI_MGMT_INDEX_EVENTS);\r\nev.type = 0x00;\r\n}\r\nbreak;\r\ncase HCI_AMP:\r\nev.type = 0x02;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nev.bus = hdev->bus;\r\nmgmt_index_event(MGMT_EV_EXT_INDEX_REMOVED, hdev, &ev, sizeof(ev),\r\nHCI_MGMT_EXT_INDEX_EVENTS);\r\n}\r\nstatic void restart_le_actions(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn_params *p;\r\nlist_for_each_entry(p, &hdev->le_conn_params, list) {\r\nlist_del_init(&p->action);\r\nswitch (p->auto_connect) {\r\ncase HCI_AUTO_CONN_DIRECT:\r\ncase HCI_AUTO_CONN_ALWAYS:\r\nlist_add(&p->action, &hdev->pend_le_conns);\r\nbreak;\r\ncase HCI_AUTO_CONN_REPORT:\r\nlist_add(&p->action, &hdev->pend_le_reports);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid mgmt_power_on(struct hci_dev *hdev, int err)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nBT_DBG("err %d", err);\r\nhci_dev_lock(hdev);\r\nif (!err) {\r\nrestart_le_actions(hdev);\r\nhci_update_background_scan(hdev);\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\r\nnew_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nhci_dev_unlock(hdev);\r\n}\r\nvoid __mgmt_power_off(struct hci_dev *hdev)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nu8 status, zero_cod[] = { 0, 0, 0 };\r\nmgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);\r\nif (hci_dev_test_flag(hdev, HCI_UNREGISTER))\r\nstatus = MGMT_STATUS_INVALID_INDEX;\r\nelse\r\nstatus = MGMT_STATUS_NOT_POWERED;\r\nmgmt_pending_foreach(0, hdev, cmd_complete_rsp, &status);\r\nif (memcmp(hdev->dev_class, zero_cod, sizeof(zero_cod)) != 0)\r\nmgmt_generic_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev,\r\nzero_cod, sizeof(zero_cod), NULL);\r\nnew_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\n}\r\nvoid mgmt_set_powered_failed(struct hci_dev *hdev, int err)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nu8 status;\r\ncmd = pending_find(MGMT_OP_SET_POWERED, hdev);\r\nif (!cmd)\r\nreturn;\r\nif (err == -ERFKILL)\r\nstatus = MGMT_STATUS_RFKILLED;\r\nelse\r\nstatus = MGMT_STATUS_FAILED;\r\nmgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_POWERED, status);\r\nmgmt_pending_remove(cmd);\r\n}\r\nvoid mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,\r\nbool persistent)\r\n{\r\nstruct mgmt_ev_new_link_key ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.store_hint = persistent;\r\nbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\r\nev.key.addr.type = BDADDR_BREDR;\r\nev.key.type = key->type;\r\nmemcpy(ev.key.val, key->val, HCI_LINK_KEY_SIZE);\r\nev.key.pin_len = key->pin_len;\r\nmgmt_event(MGMT_EV_NEW_LINK_KEY, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nstatic u8 mgmt_ltk_type(struct smp_ltk *ltk)\r\n{\r\nswitch (ltk->type) {\r\ncase SMP_LTK:\r\ncase SMP_LTK_SLAVE:\r\nif (ltk->authenticated)\r\nreturn MGMT_LTK_AUTHENTICATED;\r\nreturn MGMT_LTK_UNAUTHENTICATED;\r\ncase SMP_LTK_P256:\r\nif (ltk->authenticated)\r\nreturn MGMT_LTK_P256_AUTH;\r\nreturn MGMT_LTK_P256_UNAUTH;\r\ncase SMP_LTK_P256_DEBUG:\r\nreturn MGMT_LTK_P256_DEBUG;\r\n}\r\nreturn MGMT_LTK_UNAUTHENTICATED;\r\n}\r\nvoid mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent)\r\n{\r\nstruct mgmt_ev_new_long_term_key ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nif (key->bdaddr_type == ADDR_LE_DEV_RANDOM &&\r\n(key->bdaddr.b[5] & 0xc0) != 0xc0)\r\nev.store_hint = 0x00;\r\nelse\r\nev.store_hint = persistent;\r\nbacpy(&ev.key.addr.bdaddr, &key->bdaddr);\r\nev.key.addr.type = link_to_bdaddr(LE_LINK, key->bdaddr_type);\r\nev.key.type = mgmt_ltk_type(key);\r\nev.key.enc_size = key->enc_size;\r\nev.key.ediv = key->ediv;\r\nev.key.rand = key->rand;\r\nif (key->type == SMP_LTK)\r\nev.key.master = 1;\r\nmemcpy(ev.key.val, key->val, key->enc_size);\r\nmemset(ev.key.val + key->enc_size, 0,\r\nsizeof(ev.key.val) - key->enc_size);\r\nmgmt_event(MGMT_EV_NEW_LONG_TERM_KEY, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nvoid mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk, bool persistent)\r\n{\r\nstruct mgmt_ev_new_irk ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.store_hint = persistent;\r\nbacpy(&ev.rpa, &irk->rpa);\r\nbacpy(&ev.irk.addr.bdaddr, &irk->bdaddr);\r\nev.irk.addr.type = link_to_bdaddr(LE_LINK, irk->addr_type);\r\nmemcpy(ev.irk.val, irk->val, sizeof(irk->val));\r\nmgmt_event(MGMT_EV_NEW_IRK, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nvoid mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,\r\nbool persistent)\r\n{\r\nstruct mgmt_ev_new_csrk ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nif (csrk->bdaddr_type == ADDR_LE_DEV_RANDOM &&\r\n(csrk->bdaddr.b[5] & 0xc0) != 0xc0)\r\nev.store_hint = 0x00;\r\nelse\r\nev.store_hint = persistent;\r\nbacpy(&ev.key.addr.bdaddr, &csrk->bdaddr);\r\nev.key.addr.type = link_to_bdaddr(LE_LINK, csrk->bdaddr_type);\r\nev.key.type = csrk->type;\r\nmemcpy(ev.key.val, csrk->val, sizeof(csrk->val));\r\nmgmt_event(MGMT_EV_NEW_CSRK, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nvoid mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 bdaddr_type, u8 store_hint, u16 min_interval,\r\nu16 max_interval, u16 latency, u16 timeout)\r\n{\r\nstruct mgmt_ev_new_conn_param ev;\r\nif (!hci_is_identity_address(bdaddr, bdaddr_type))\r\nreturn;\r\nmemset(&ev, 0, sizeof(ev));\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(LE_LINK, bdaddr_type);\r\nev.store_hint = store_hint;\r\nev.min_interval = cpu_to_le16(min_interval);\r\nev.max_interval = cpu_to_le16(max_interval);\r\nev.latency = cpu_to_le16(latency);\r\nev.timeout = cpu_to_le16(timeout);\r\nmgmt_event(MGMT_EV_NEW_CONN_PARAM, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nvoid mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,\r\nu32 flags, u8 *name, u8 name_len)\r\n{\r\nchar buf[512];\r\nstruct mgmt_ev_device_connected *ev = (void *) buf;\r\nu16 eir_len = 0;\r\nbacpy(&ev->addr.bdaddr, &conn->dst);\r\nev->addr.type = link_to_bdaddr(conn->type, conn->dst_type);\r\nev->flags = __cpu_to_le32(flags);\r\nif (conn->le_adv_data_len > 0) {\r\nmemcpy(&ev->eir[eir_len],\r\nconn->le_adv_data, conn->le_adv_data_len);\r\neir_len = conn->le_adv_data_len;\r\n} else {\r\nif (name_len > 0)\r\neir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE,\r\nname, name_len);\r\nif (memcmp(conn->dev_class, "\0\0\0", 3) != 0)\r\neir_len = eir_append_data(ev->eir, eir_len,\r\nEIR_CLASS_OF_DEV,\r\nconn->dev_class, 3);\r\n}\r\nev->eir_len = cpu_to_le16(eir_len);\r\nmgmt_event(MGMT_EV_DEVICE_CONNECTED, hdev, buf,\r\nsizeof(*ev) + eir_len, NULL);\r\n}\r\nstatic void disconnect_rsp(struct mgmt_pending_cmd *cmd, void *data)\r\n{\r\nstruct sock **sk = data;\r\ncmd->cmd_complete(cmd, 0);\r\n*sk = cmd->sk;\r\nsock_hold(*sk);\r\nmgmt_pending_remove(cmd);\r\n}\r\nstatic void unpair_device_rsp(struct mgmt_pending_cmd *cmd, void *data)\r\n{\r\nstruct hci_dev *hdev = data;\r\nstruct mgmt_cp_unpair_device *cp = cmd->param;\r\ndevice_unpaired(hdev, &cp->addr.bdaddr, cp->addr.type, cmd->sk);\r\ncmd->cmd_complete(cmd, 0);\r\nmgmt_pending_remove(cmd);\r\n}\r\nbool mgmt_powering_down(struct hci_dev *hdev)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nstruct mgmt_mode *cp;\r\ncmd = pending_find(MGMT_OP_SET_POWERED, hdev);\r\nif (!cmd)\r\nreturn false;\r\ncp = cmd->param;\r\nif (!cp->val)\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 reason,\r\nbool mgmt_connected)\r\n{\r\nstruct mgmt_ev_device_disconnected ev;\r\nstruct sock *sk = NULL;\r\nif (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {\r\ncancel_delayed_work(&hdev->power_off);\r\nqueue_work(hdev->req_workqueue, &hdev->power_off.work);\r\n}\r\nif (!mgmt_connected)\r\nreturn;\r\nif (link_type != ACL_LINK && link_type != LE_LINK)\r\nreturn;\r\nmgmt_pending_foreach(MGMT_OP_DISCONNECT, hdev, disconnect_rsp, &sk);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.reason = reason;\r\nmgmt_event(MGMT_EV_DEVICE_DISCONNECTED, hdev, &ev, sizeof(ev), sk);\r\nif (sk)\r\nsock_put(sk);\r\nmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\r\nhdev);\r\n}\r\nvoid mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nu8 bdaddr_type = link_to_bdaddr(link_type, addr_type);\r\nstruct mgmt_cp_disconnect *cp;\r\nstruct mgmt_pending_cmd *cmd;\r\nmgmt_pending_foreach(MGMT_OP_UNPAIR_DEVICE, hdev, unpair_device_rsp,\r\nhdev);\r\ncmd = pending_find(MGMT_OP_DISCONNECT, hdev);\r\nif (!cmd)\r\nreturn;\r\ncp = cmd->param;\r\nif (bacmp(bdaddr, &cp->addr.bdaddr))\r\nreturn;\r\nif (cp->addr.type != bdaddr_type)\r\nreturn;\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\n}\r\nvoid mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, u8 status)\r\n{\r\nstruct mgmt_ev_connect_failed ev;\r\nif (mgmt_powering_down(hdev) && hci_conn_count(hdev) == 1) {\r\ncancel_delayed_work(&hdev->power_off);\r\nqueue_work(hdev->req_workqueue, &hdev->power_off.work);\r\n}\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.status = mgmt_status(status);\r\nmgmt_event(MGMT_EV_CONNECT_FAILED, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nvoid mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)\r\n{\r\nstruct mgmt_ev_pin_code_request ev;\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = BDADDR_BREDR;\r\nev.secure = secure;\r\nmgmt_event(MGMT_EV_PIN_CODE_REQUEST, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nvoid mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\ncmd = pending_find(MGMT_OP_PIN_CODE_REPLY, hdev);\r\nif (!cmd)\r\nreturn;\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\n}\r\nvoid mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 status)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\ncmd = pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, hdev);\r\nif (!cmd)\r\nreturn;\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\n}\r\nint mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u32 value,\r\nu8 confirm_hint)\r\n{\r\nstruct mgmt_ev_user_confirm_request ev;\r\nBT_DBG("%s", hdev->name);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.confirm_hint = confirm_hint;\r\nev.value = cpu_to_le32(value);\r\nreturn mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, hdev, &ev, sizeof(ev),\r\nNULL);\r\n}\r\nint mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type)\r\n{\r\nstruct mgmt_ev_user_passkey_request ev;\r\nBT_DBG("%s", hdev->name);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nreturn mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, hdev, &ev, sizeof(ev),\r\nNULL);\r\n}\r\nstatic int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status,\r\nu8 opcode)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\ncmd = pending_find(opcode, hdev);\r\nif (!cmd)\r\nreturn -ENOENT;\r\ncmd->cmd_complete(cmd, mgmt_status(status));\r\nmgmt_pending_remove(cmd);\r\nreturn 0;\r\n}\r\nint mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus, MGMT_OP_USER_CONFIRM_REPLY);\r\n}\r\nint mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus,\r\nMGMT_OP_USER_CONFIRM_NEG_REPLY);\r\n}\r\nint mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus, MGMT_OP_USER_PASSKEY_REPLY);\r\n}\r\nint mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u8 status)\r\n{\r\nreturn user_pairing_resp_complete(hdev, bdaddr, link_type, addr_type,\r\nstatus,\r\nMGMT_OP_USER_PASSKEY_NEG_REPLY);\r\n}\r\nint mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 link_type, u8 addr_type, u32 passkey,\r\nu8 entered)\r\n{\r\nstruct mgmt_ev_passkey_notify ev;\r\nBT_DBG("%s", hdev->name);\r\nbacpy(&ev.addr.bdaddr, bdaddr);\r\nev.addr.type = link_to_bdaddr(link_type, addr_type);\r\nev.passkey = __cpu_to_le32(passkey);\r\nev.entered = entered;\r\nreturn mgmt_event(MGMT_EV_PASSKEY_NOTIFY, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nvoid mgmt_auth_failed(struct hci_conn *conn, u8 hci_status)\r\n{\r\nstruct mgmt_ev_auth_failed ev;\r\nstruct mgmt_pending_cmd *cmd;\r\nu8 status = mgmt_status(hci_status);\r\nbacpy(&ev.addr.bdaddr, &conn->dst);\r\nev.addr.type = link_to_bdaddr(conn->type, conn->dst_type);\r\nev.status = status;\r\ncmd = find_pairing(conn);\r\nmgmt_event(MGMT_EV_AUTH_FAILED, conn->hdev, &ev, sizeof(ev),\r\ncmd ? cmd->sk : NULL);\r\nif (cmd) {\r\ncmd->cmd_complete(cmd, status);\r\nmgmt_pending_remove(cmd);\r\n}\r\n}\r\nvoid mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nbool changed;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev,\r\ncmd_status_rsp, &mgmt_err);\r\nreturn;\r\n}\r\nif (test_bit(HCI_AUTH, &hdev->flags))\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_LINK_SECURITY);\r\nelse\r\nchanged = hci_dev_test_and_clear_flag(hdev, HCI_LINK_SECURITY);\r\nmgmt_pending_foreach(MGMT_OP_SET_LINK_SECURITY, hdev, settings_rsp,\r\n&match);\r\nif (changed)\r\nnew_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\n}\r\nstatic void clear_eir(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_write_eir cp;\r\nif (!lmp_ext_inq_capable(hdev))\r\nreturn;\r\nmemset(hdev->eir, 0, sizeof(hdev->eir));\r\nmemset(&cp, 0, sizeof(cp));\r\nhci_req_add(req, HCI_OP_WRITE_EIR, sizeof(cp), &cp);\r\n}\r\nvoid mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev };\r\nstruct hci_request req;\r\nbool changed = false;\r\nif (status) {\r\nu8 mgmt_err = mgmt_status(status);\r\nif (enable && hci_dev_test_and_clear_flag(hdev,\r\nHCI_SSP_ENABLED)) {\r\nhci_dev_clear_flag(hdev, HCI_HS_ENABLED);\r\nnew_settings(hdev, NULL);\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, cmd_status_rsp,\r\n&mgmt_err);\r\nreturn;\r\n}\r\nif (enable) {\r\nchanged = !hci_dev_test_and_set_flag(hdev, HCI_SSP_ENABLED);\r\n} else {\r\nchanged = hci_dev_test_and_clear_flag(hdev, HCI_SSP_ENABLED);\r\nif (!changed)\r\nchanged = hci_dev_test_and_clear_flag(hdev,\r\nHCI_HS_ENABLED);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_HS_ENABLED);\r\n}\r\nmgmt_pending_foreach(MGMT_OP_SET_SSP, hdev, settings_rsp, &match);\r\nif (changed)\r\nnew_settings(hdev, match.sk);\r\nif (match.sk)\r\nsock_put(match.sk);\r\nhci_req_init(&req, hdev);\r\nif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\r\nif (hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS))\r\nhci_req_add(&req, HCI_OP_WRITE_SSP_DEBUG_MODE,\r\nsizeof(enable), &enable);\r\n__hci_req_update_eir(&req);\r\n} else {\r\nclear_eir(&req);\r\n}\r\nhci_req_run(&req, NULL);\r\n}\r\nstatic void sk_lookup(struct mgmt_pending_cmd *cmd, void *data)\r\n{\r\nstruct cmd_lookup *match = data;\r\nif (match->sk == NULL) {\r\nmatch->sk = cmd->sk;\r\nsock_hold(match->sk);\r\n}\r\n}\r\nvoid mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,\r\nu8 status)\r\n{\r\nstruct cmd_lookup match = { NULL, hdev, mgmt_status(status) };\r\nmgmt_pending_foreach(MGMT_OP_SET_DEV_CLASS, hdev, sk_lookup, &match);\r\nmgmt_pending_foreach(MGMT_OP_ADD_UUID, hdev, sk_lookup, &match);\r\nmgmt_pending_foreach(MGMT_OP_REMOVE_UUID, hdev, sk_lookup, &match);\r\nif (!status)\r\nmgmt_generic_event(MGMT_EV_CLASS_OF_DEV_CHANGED, hdev,\r\ndev_class, 3, NULL);\r\nif (match.sk)\r\nsock_put(match.sk);\r\n}\r\nvoid mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)\r\n{\r\nstruct mgmt_cp_set_local_name ev;\r\nstruct mgmt_pending_cmd *cmd;\r\nif (status)\r\nreturn;\r\nmemset(&ev, 0, sizeof(ev));\r\nmemcpy(ev.name, name, HCI_MAX_NAME_LENGTH);\r\nmemcpy(ev.short_name, hdev->short_name, HCI_MAX_SHORT_NAME_LENGTH);\r\ncmd = pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);\r\nif (!cmd) {\r\nmemcpy(hdev->dev_name, name, sizeof(hdev->dev_name));\r\nif (pending_find(MGMT_OP_SET_POWERED, hdev))\r\nreturn;\r\n}\r\nmgmt_generic_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, &ev, sizeof(ev),\r\ncmd ? cmd->sk : NULL);\r\n}\r\nstatic void restart_le_scan(struct hci_dev *hdev)\r\n{\r\nif (!hci_dev_test_flag(hdev, HCI_LE_SCAN))\r\nreturn;\r\nif (time_after(jiffies + DISCOV_LE_RESTART_DELAY,\r\nhdev->discovery.scan_start +\r\nhdev->discovery.scan_duration))\r\nreturn;\r\nqueue_delayed_work(hdev->req_workqueue, &hdev->le_scan_restart,\r\nDISCOV_LE_RESTART_DELAY);\r\n}\r\nstatic bool is_filter_match(struct hci_dev *hdev, s8 rssi, u8 *eir,\r\nu16 eir_len, u8 *scan_rsp, u8 scan_rsp_len)\r\n{\r\nif (hdev->discovery.rssi != HCI_RSSI_INVALID &&\r\n(rssi == HCI_RSSI_INVALID ||\r\n(rssi < hdev->discovery.rssi &&\r\n!test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks))))\r\nreturn false;\r\nif (hdev->discovery.uuid_count != 0) {\r\nif (!eir_has_uuids(eir, eir_len, hdev->discovery.uuid_count,\r\nhdev->discovery.uuids) &&\r\n!eir_has_uuids(scan_rsp, scan_rsp_len,\r\nhdev->discovery.uuid_count,\r\nhdev->discovery.uuids))\r\nreturn false;\r\n}\r\nif (test_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks)) {\r\nrestart_le_scan(hdev);\r\nif (hdev->discovery.rssi != HCI_RSSI_INVALID &&\r\nrssi < hdev->discovery.rssi)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, u8 *dev_class, s8 rssi, u32 flags,\r\nu8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len)\r\n{\r\nchar buf[512];\r\nstruct mgmt_ev_device_found *ev = (void *)buf;\r\nsize_t ev_size;\r\nif (!hci_discovery_active(hdev)) {\r\nif (link_type == ACL_LINK)\r\nreturn;\r\nif (link_type == LE_LINK && list_empty(&hdev->pend_le_reports))\r\nreturn;\r\n}\r\nif (hdev->discovery.result_filtering) {\r\nif (!is_filter_match(hdev, rssi, eir, eir_len, scan_rsp,\r\nscan_rsp_len))\r\nreturn;\r\n}\r\nif (hdev->discovery.limited) {\r\nif (dev_class) {\r\nif (!(dev_class[1] & 0x20))\r\nreturn;\r\n} else {\r\nu8 *flags = eir_get_data(eir, eir_len, EIR_FLAGS, NULL);\r\nif (!flags || !(flags[0] & LE_AD_LIMITED))\r\nreturn;\r\n}\r\n}\r\nif (sizeof(*ev) + eir_len + scan_rsp_len + 5 > sizeof(buf))\r\nreturn;\r\nmemset(buf, 0, sizeof(buf));\r\nif (rssi == HCI_RSSI_INVALID && !hdev->discovery.report_invalid_rssi &&\r\nlink_type == ACL_LINK)\r\nrssi = 0;\r\nbacpy(&ev->addr.bdaddr, bdaddr);\r\nev->addr.type = link_to_bdaddr(link_type, addr_type);\r\nev->rssi = rssi;\r\nev->flags = cpu_to_le32(flags);\r\nif (eir_len > 0)\r\nmemcpy(ev->eir, eir, eir_len);\r\nif (dev_class && !eir_get_data(ev->eir, eir_len, EIR_CLASS_OF_DEV,\r\nNULL))\r\neir_len = eir_append_data(ev->eir, eir_len, EIR_CLASS_OF_DEV,\r\ndev_class, 3);\r\nif (scan_rsp_len > 0)\r\nmemcpy(ev->eir + eir_len, scan_rsp, scan_rsp_len);\r\nev->eir_len = cpu_to_le16(eir_len + scan_rsp_len);\r\nev_size = sizeof(*ev) + eir_len + scan_rsp_len;\r\nmgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev, ev_size, NULL);\r\n}\r\nvoid mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,\r\nu8 addr_type, s8 rssi, u8 *name, u8 name_len)\r\n{\r\nstruct mgmt_ev_device_found *ev;\r\nchar buf[sizeof(*ev) + HCI_MAX_NAME_LENGTH + 2];\r\nu16 eir_len;\r\nev = (struct mgmt_ev_device_found *) buf;\r\nmemset(buf, 0, sizeof(buf));\r\nbacpy(&ev->addr.bdaddr, bdaddr);\r\nev->addr.type = link_to_bdaddr(link_type, addr_type);\r\nev->rssi = rssi;\r\neir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE, name,\r\nname_len);\r\nev->eir_len = cpu_to_le16(eir_len);\r\nmgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev, sizeof(*ev) + eir_len, NULL);\r\n}\r\nvoid mgmt_discovering(struct hci_dev *hdev, u8 discovering)\r\n{\r\nstruct mgmt_ev_discovering ev;\r\nBT_DBG("%s discovering %u", hdev->name, discovering);\r\nmemset(&ev, 0, sizeof(ev));\r\nev.type = hdev->discovery.type;\r\nev.discovering = discovering;\r\nmgmt_event(MGMT_EV_DISCOVERING, hdev, &ev, sizeof(ev), NULL);\r\n}\r\nint mgmt_init(void)\r\n{\r\nreturn hci_mgmt_chan_register(&chan);\r\n}\r\nvoid mgmt_exit(void)\r\n{\r\nhci_mgmt_chan_unregister(&chan);\r\n}
