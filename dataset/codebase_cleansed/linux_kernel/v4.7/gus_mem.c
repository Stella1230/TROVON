void snd_gf1_mem_lock(struct snd_gf1_mem * alloc, int xup)\r\n{\r\nif (!xup) {\r\nmutex_lock(&alloc->memory_mutex);\r\n} else {\r\nmutex_unlock(&alloc->memory_mutex);\r\n}\r\n}\r\nstatic struct snd_gf1_mem_block *snd_gf1_mem_xalloc(struct snd_gf1_mem * alloc,\r\nstruct snd_gf1_mem_block * block)\r\n{\r\nstruct snd_gf1_mem_block *pblock, *nblock;\r\nnblock = kmalloc(sizeof(struct snd_gf1_mem_block), GFP_KERNEL);\r\nif (nblock == NULL)\r\nreturn NULL;\r\n*nblock = *block;\r\npblock = alloc->first;\r\nwhile (pblock) {\r\nif (pblock->ptr > nblock->ptr) {\r\nnblock->prev = pblock->prev;\r\nnblock->next = pblock;\r\npblock->prev = nblock;\r\nif (pblock == alloc->first)\r\nalloc->first = nblock;\r\nelse\r\nnblock->prev->next = nblock;\r\nmutex_unlock(&alloc->memory_mutex);\r\nreturn NULL;\r\n}\r\npblock = pblock->next;\r\n}\r\nnblock->next = NULL;\r\nif (alloc->last == NULL) {\r\nnblock->prev = NULL;\r\nalloc->first = alloc->last = nblock;\r\n} else {\r\nnblock->prev = alloc->last;\r\nalloc->last->next = nblock;\r\nalloc->last = nblock;\r\n}\r\nreturn nblock;\r\n}\r\nint snd_gf1_mem_xfree(struct snd_gf1_mem * alloc, struct snd_gf1_mem_block * block)\r\n{\r\nif (block->share) {\r\nblock->share--;\r\nmutex_unlock(&alloc->memory_mutex);\r\nreturn 0;\r\n}\r\nif (alloc->first == block) {\r\nalloc->first = block->next;\r\nif (block->next)\r\nblock->next->prev = NULL;\r\n} else {\r\nblock->prev->next = block->next;\r\nif (block->next)\r\nblock->next->prev = block->prev;\r\n}\r\nif (alloc->last == block) {\r\nalloc->last = block->prev;\r\nif (block->prev)\r\nblock->prev->next = NULL;\r\n} else {\r\nblock->next->prev = block->prev;\r\nif (block->prev)\r\nblock->prev->next = block->next;\r\n}\r\nkfree(block->name);\r\nkfree(block);\r\nreturn 0;\r\n}\r\nstatic struct snd_gf1_mem_block *snd_gf1_mem_look(struct snd_gf1_mem * alloc,\r\nunsigned int address)\r\n{\r\nstruct snd_gf1_mem_block *block;\r\nfor (block = alloc->first; block; block = block->next) {\r\nif (block->ptr == address) {\r\nreturn block;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct snd_gf1_mem_block *snd_gf1_mem_share(struct snd_gf1_mem * alloc,\r\nunsigned int *share_id)\r\n{\r\nstruct snd_gf1_mem_block *block;\r\nif (!share_id[0] && !share_id[1] &&\r\n!share_id[2] && !share_id[3])\r\nreturn NULL;\r\nfor (block = alloc->first; block; block = block->next)\r\nif (!memcmp(share_id, block->share_id,\r\nsizeof(block->share_id)))\r\nreturn block;\r\nreturn NULL;\r\n}\r\nstatic int snd_gf1_mem_find(struct snd_gf1_mem * alloc,\r\nstruct snd_gf1_mem_block * block,\r\nunsigned int size, int w_16, int align)\r\n{\r\nstruct snd_gf1_bank_info *info = w_16 ? alloc->banks_16 : alloc->banks_8;\r\nunsigned int idx, boundary;\r\nint size1;\r\nstruct snd_gf1_mem_block *pblock;\r\nunsigned int ptr1, ptr2;\r\nif (w_16 && align < 2)\r\nalign = 2;\r\nblock->flags = w_16 ? SNDRV_GF1_MEM_BLOCK_16BIT : 0;\r\nblock->owner = SNDRV_GF1_MEM_OWNER_DRIVER;\r\nblock->share = 0;\r\nblock->share_id[0] = block->share_id[1] =\r\nblock->share_id[2] = block->share_id[3] = 0;\r\nblock->name = NULL;\r\nblock->prev = block->next = NULL;\r\nfor (pblock = alloc->first, idx = 0; pblock; pblock = pblock->next) {\r\nwhile (pblock->ptr >= (boundary = info[idx].address + info[idx].size))\r\nidx++;\r\nwhile (pblock->ptr + pblock->size >= (boundary = info[idx].address + info[idx].size))\r\nidx++;\r\nptr2 = boundary;\r\nif (pblock->next) {\r\nif (pblock->ptr + pblock->size == pblock->next->ptr)\r\ncontinue;\r\nif (pblock->next->ptr < boundary)\r\nptr2 = pblock->next->ptr;\r\n}\r\nptr1 = ALIGN(pblock->ptr + pblock->size, align);\r\nif (ptr1 >= ptr2)\r\ncontinue;\r\nsize1 = ptr2 - ptr1;\r\nif ((int)size <= size1) {\r\nblock->ptr = ptr1;\r\nblock->size = size;\r\nreturn 0;\r\n}\r\n}\r\nwhile (++idx < 4) {\r\nif (size <= info[idx].size) {\r\nblock->ptr = info[idx].address;\r\nblock->size = size;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstruct snd_gf1_mem_block *snd_gf1_mem_alloc(struct snd_gf1_mem * alloc, int owner,\r\nchar *name, int size, int w_16, int align,\r\nunsigned int *share_id)\r\n{\r\nstruct snd_gf1_mem_block block, *nblock;\r\nsnd_gf1_mem_lock(alloc, 0);\r\nif (share_id != NULL) {\r\nnblock = snd_gf1_mem_share(alloc, share_id);\r\nif (nblock != NULL) {\r\nif (size != (int)nblock->size) {\r\nsnd_printk(KERN_ERR "snd_gf1_mem_alloc - share: sizes differ\n");\r\ngoto __std;\r\n}\r\nnblock->share++;\r\nsnd_gf1_mem_lock(alloc, 1);\r\nreturn NULL;\r\n}\r\n}\r\n__std:\r\nif (snd_gf1_mem_find(alloc, &block, size, w_16, align) < 0) {\r\nsnd_gf1_mem_lock(alloc, 1);\r\nreturn NULL;\r\n}\r\nif (share_id != NULL)\r\nmemcpy(&block.share_id, share_id, sizeof(block.share_id));\r\nblock.owner = owner;\r\nblock.name = kstrdup(name, GFP_KERNEL);\r\nnblock = snd_gf1_mem_xalloc(alloc, &block);\r\nsnd_gf1_mem_lock(alloc, 1);\r\nreturn nblock;\r\n}\r\nint snd_gf1_mem_free(struct snd_gf1_mem * alloc, unsigned int address)\r\n{\r\nint result;\r\nstruct snd_gf1_mem_block *block;\r\nsnd_gf1_mem_lock(alloc, 0);\r\nif ((block = snd_gf1_mem_look(alloc, address)) != NULL) {\r\nresult = snd_gf1_mem_xfree(alloc, block);\r\nsnd_gf1_mem_lock(alloc, 1);\r\nreturn result;\r\n}\r\nsnd_gf1_mem_lock(alloc, 1);\r\nreturn -EINVAL;\r\n}\r\nint snd_gf1_mem_init(struct snd_gus_card * gus)\r\n{\r\nstruct snd_gf1_mem *alloc;\r\nstruct snd_gf1_mem_block block;\r\n#ifdef CONFIG_SND_DEBUG\r\nstruct snd_info_entry *entry;\r\n#endif\r\nalloc = &gus->gf1.mem_alloc;\r\nmutex_init(&alloc->memory_mutex);\r\nalloc->first = alloc->last = NULL;\r\nif (!gus->gf1.memory)\r\nreturn 0;\r\nmemset(&block, 0, sizeof(block));\r\nblock.owner = SNDRV_GF1_MEM_OWNER_DRIVER;\r\nif (gus->gf1.enh_mode) {\r\nblock.ptr = 0;\r\nblock.size = 1024;\r\nblock.name = kstrdup("InterWave LFOs", GFP_KERNEL);\r\nif (snd_gf1_mem_xalloc(alloc, &block) == NULL)\r\nreturn -ENOMEM;\r\n}\r\nblock.ptr = gus->gf1.default_voice_address;\r\nblock.size = 4;\r\nblock.name = kstrdup("Voice default (NULL's)", GFP_KERNEL);\r\nif (snd_gf1_mem_xalloc(alloc, &block) == NULL)\r\nreturn -ENOMEM;\r\n#ifdef CONFIG_SND_DEBUG\r\nif (! snd_card_proc_new(gus->card, "gusmem", &entry))\r\nsnd_info_set_text_ops(entry, gus, snd_gf1_mem_info_read);\r\n#endif\r\nreturn 0;\r\n}\r\nint snd_gf1_mem_done(struct snd_gus_card * gus)\r\n{\r\nstruct snd_gf1_mem *alloc;\r\nstruct snd_gf1_mem_block *block, *nblock;\r\nalloc = &gus->gf1.mem_alloc;\r\nblock = alloc->first;\r\nwhile (block) {\r\nnblock = block->next;\r\nsnd_gf1_mem_xfree(alloc, block);\r\nblock = nblock;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_gf1_mem_info_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_gus_card *gus;\r\nstruct snd_gf1_mem *alloc;\r\nstruct snd_gf1_mem_block *block;\r\nunsigned int total, used;\r\nint i;\r\ngus = entry->private_data;\r\nalloc = &gus->gf1.mem_alloc;\r\nmutex_lock(&alloc->memory_mutex);\r\nsnd_iprintf(buffer, "8-bit banks : \n ");\r\nfor (i = 0; i < 4; i++)\r\nsnd_iprintf(buffer, "0x%06x (%04ik)%s", alloc->banks_8[i].address, alloc->banks_8[i].size >> 10, i + 1 < 4 ? "," : "");\r\nsnd_iprintf(buffer, "\n"\r\n"16-bit banks : \n ");\r\nfor (i = total = 0; i < 4; i++) {\r\nsnd_iprintf(buffer, "0x%06x (%04ik)%s", alloc->banks_16[i].address, alloc->banks_16[i].size >> 10, i + 1 < 4 ? "," : "");\r\ntotal += alloc->banks_16[i].size;\r\n}\r\nsnd_iprintf(buffer, "\n");\r\nused = 0;\r\nfor (block = alloc->first, i = 0; block; block = block->next, i++) {\r\nused += block->size;\r\nsnd_iprintf(buffer, "Block %i at 0x%lx onboard 0x%x size %i (0x%x):\n", i, (long) block, block->ptr, block->size, block->size);\r\nif (block->share ||\r\nblock->share_id[0] || block->share_id[1] ||\r\nblock->share_id[2] || block->share_id[3])\r\nsnd_iprintf(buffer, " Share : %i [id0 0x%x] [id1 0x%x] [id2 0x%x] [id3 0x%x]\n",\r\nblock->share,\r\nblock->share_id[0], block->share_id[1],\r\nblock->share_id[2], block->share_id[3]);\r\nsnd_iprintf(buffer, " Flags :%s\n",\r\nblock->flags & SNDRV_GF1_MEM_BLOCK_16BIT ? " 16-bit" : "");\r\nsnd_iprintf(buffer, " Owner : ");\r\nswitch (block->owner) {\r\ncase SNDRV_GF1_MEM_OWNER_DRIVER:\r\nsnd_iprintf(buffer, "driver - %s\n", block->name);\r\nbreak;\r\ncase SNDRV_GF1_MEM_OWNER_WAVE_SIMPLE:\r\nsnd_iprintf(buffer, "SIMPLE wave\n");\r\nbreak;\r\ncase SNDRV_GF1_MEM_OWNER_WAVE_GF1:\r\nsnd_iprintf(buffer, "GF1 wave\n");\r\nbreak;\r\ncase SNDRV_GF1_MEM_OWNER_WAVE_IWFFFF:\r\nsnd_iprintf(buffer, "IWFFFF wave\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "unknown\n");\r\n}\r\n}\r\nsnd_iprintf(buffer, " Total: memory = %i, used = %i, free = %i\n",\r\ntotal, used, total - used);\r\nmutex_unlock(&alloc->memory_mutex);\r\n#if 0\r\nultra_iprintf(buffer, " Verify: free = %i, max 8-bit block = %i, max 16-bit block = %i\n",\r\nultra_memory_free_size(card, &card->gf1.mem_alloc),\r\nultra_memory_free_block(card, &card->gf1.mem_alloc, 0),\r\nultra_memory_free_block(card, &card->gf1.mem_alloc, 1));\r\n#endif\r\n}
