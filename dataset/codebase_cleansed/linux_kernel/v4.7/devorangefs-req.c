static int hash_func(__u64 tag, int table_size)\r\n{\r\nreturn do_div(tag, (unsigned int)table_size);\r\n}\r\nstatic void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)\r\n{\r\nint index = hash_func(op->tag, hash_table_size);\r\nlist_add_tail(&op->list, &htable_ops_in_progress[index]);\r\n}\r\nstatic struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)\r\n{\r\nstruct orangefs_kernel_op_s *op, *next;\r\nint index;\r\nindex = hash_func(tag, hash_table_size);\r\nspin_lock(&htable_ops_in_progress_lock);\r\nlist_for_each_entry_safe(op,\r\nnext,\r\n&htable_ops_in_progress[index],\r\nlist) {\r\nif (op->tag == tag && !op_state_purged(op) &&\r\n!op_state_given_up(op)) {\r\nlist_del_init(&op->list);\r\nspin_unlock(&htable_ops_in_progress_lock);\r\nreturn op;\r\n}\r\n}\r\nspin_unlock(&htable_ops_in_progress_lock);\r\nreturn NULL;\r\n}\r\nstatic int mark_all_pending_mounts(void)\r\n{\r\nint unmounted = 1;\r\nstruct orangefs_sb_info_s *orangefs_sb = NULL;\r\nspin_lock(&orangefs_superblocks_lock);\r\nlist_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {\r\norangefs_sb->mount_pending = 1;\r\nunmounted = 0;\r\n}\r\nspin_unlock(&orangefs_superblocks_lock);\r\nreturn unmounted;\r\n}\r\nstatic int fs_mount_pending(__s32 fsid)\r\n{\r\nint mount_pending = -1;\r\nstruct orangefs_sb_info_s *orangefs_sb = NULL;\r\nspin_lock(&orangefs_superblocks_lock);\r\nlist_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {\r\nif (orangefs_sb->fs_id == fsid) {\r\nmount_pending = orangefs_sb->mount_pending;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&orangefs_superblocks_lock);\r\nreturn mount_pending;\r\n}\r\nstatic int orangefs_devreq_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = -EINVAL;\r\nif (!(file->f_flags & O_NONBLOCK)) {\r\ngossip_err("%s: device cannot be opened in blocking mode\n",\r\n__func__);\r\ngoto out;\r\n}\r\nret = -EACCES;\r\ngossip_debug(GOSSIP_DEV_DEBUG, "client-core: opening device\n");\r\nmutex_lock(&devreq_mutex);\r\nif (open_access_count == 0) {\r\nopen_access_count = 1;\r\nret = 0;\r\n} else {\r\nDUMP_DEVICE_ERROR();\r\n}\r\nmutex_unlock(&devreq_mutex);\r\nout:\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"pvfs2-client-core: open device complete (ret = %d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic ssize_t orangefs_devreq_read(struct file *file,\r\nchar __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct orangefs_kernel_op_s *op, *temp;\r\n__s32 proto_ver = ORANGEFS_KERNEL_PROTO_VERSION;\r\nstatic __s32 magic = ORANGEFS_DEVREQ_MAGIC;\r\nstruct orangefs_kernel_op_s *cur_op = NULL;\r\nunsigned long ret;\r\nif (!(file->f_flags & O_NONBLOCK)) {\r\ngossip_err("%s: blocking read from client-core.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (count != MAX_DEV_REQ_UPSIZE) {\r\ngossip_err("orangefs: client-core tried to read wrong size\n");\r\nreturn -EINVAL;\r\n}\r\nrestart:\r\nspin_lock(&orangefs_request_list_lock);\r\nlist_for_each_entry_safe(op, temp, &orangefs_request_list, list) {\r\n__s32 fsid;\r\nspin_lock(&op->lock);\r\nif (unlikely(op_state_purged(op) || op_state_given_up(op))) {\r\nspin_unlock(&op->lock);\r\ncontinue;\r\n}\r\nfsid = fsid_of_op(op);\r\nif (fsid != ORANGEFS_FS_ID_NULL) {\r\nint ret;\r\nret = fs_mount_pending(fsid);\r\nif (ret == 1) {\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: mount pending, skipping op tag "\r\n"%llu %s\n",\r\n__func__,\r\nllu(op->tag),\r\nget_opname_string(op));\r\nspin_unlock(&op->lock);\r\ncontinue;\r\n} else if (ret == -1 &&\r\n!(op->upcall.type ==\r\nORANGEFS_VFS_OP_FS_MOUNT ||\r\nop->upcall.type ==\r\nORANGEFS_VFS_OP_GETATTR)) {\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"orangefs: skipping op tag %llu %s\n",\r\nllu(op->tag), get_opname_string(op));\r\ngossip_err(\r\n"orangefs: ERROR: fs_mount_pending %d\n",\r\nfsid);\r\nspin_unlock(&op->lock);\r\ncontinue;\r\n}\r\n}\r\ncur_op = op;\r\nbreak;\r\n}\r\nif (!cur_op) {\r\nspin_unlock(&orangefs_request_list_lock);\r\nreturn -EAGAIN;\r\n}\r\ngossip_debug(GOSSIP_DEV_DEBUG, "%s: reading op tag %llu %s\n",\r\n__func__,\r\nllu(cur_op->tag),\r\nget_opname_string(cur_op));\r\nif (op_state_in_progress(cur_op) || op_state_serviced(cur_op)) {\r\ngossip_err("orangefs: ERROR: Current op already queued.\n");\r\nlist_del_init(&cur_op->list);\r\nspin_unlock(&cur_op->lock);\r\nspin_unlock(&orangefs_request_list_lock);\r\nreturn -EAGAIN;\r\n}\r\nlist_del_init(&cur_op->list);\r\nspin_unlock(&orangefs_request_list_lock);\r\nspin_unlock(&cur_op->lock);\r\nret = copy_to_user(buf, &proto_ver, sizeof(__s32));\r\nif (ret != 0)\r\ngoto error;\r\nret = copy_to_user(buf+sizeof(__s32), &magic, sizeof(__s32));\r\nif (ret != 0)\r\ngoto error;\r\nret = copy_to_user(buf+2 * sizeof(__s32), &cur_op->tag, sizeof(__u64));\r\nif (ret != 0)\r\ngoto error;\r\nret = copy_to_user(buf+2*sizeof(__s32)+sizeof(__u64), &cur_op->upcall,\r\nsizeof(struct orangefs_upcall_s));\r\nif (ret != 0)\r\ngoto error;\r\nspin_lock(&htable_ops_in_progress_lock);\r\nspin_lock(&cur_op->lock);\r\nif (unlikely(op_state_given_up(cur_op))) {\r\nspin_unlock(&cur_op->lock);\r\nspin_unlock(&htable_ops_in_progress_lock);\r\ncomplete(&cur_op->waitq);\r\ngoto restart;\r\n}\r\nset_op_state_inprogress(cur_op);\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: 1 op:%s: op_state:%d: process:%s:\n",\r\n__func__,\r\nget_opname_string(cur_op),\r\ncur_op->op_state,\r\ncurrent->comm);\r\norangefs_devreq_add_op(cur_op);\r\nspin_unlock(&cur_op->lock);\r\nspin_unlock(&htable_ops_in_progress_lock);\r\nreturn MAX_DEV_REQ_UPSIZE;\r\nerror:\r\ngossip_err("orangefs: Failed to copy data to user space\n");\r\nspin_lock(&orangefs_request_list_lock);\r\nspin_lock(&cur_op->lock);\r\nif (likely(!op_state_given_up(cur_op))) {\r\nset_op_state_waiting(cur_op);\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: 2 op:%s: op_state:%d: process:%s:\n",\r\n__func__,\r\nget_opname_string(cur_op),\r\ncur_op->op_state,\r\ncurrent->comm);\r\nlist_add(&cur_op->list, &orangefs_request_list);\r\nspin_unlock(&cur_op->lock);\r\n} else {\r\nspin_unlock(&cur_op->lock);\r\ncomplete(&cur_op->waitq);\r\n}\r\nspin_unlock(&orangefs_request_list_lock);\r\nreturn -EFAULT;\r\n}\r\nstatic ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,\r\nstruct iov_iter *iter)\r\n{\r\nssize_t ret;\r\nstruct orangefs_kernel_op_s *op = NULL;\r\nstruct {\r\n__u32 version;\r\n__u32 magic;\r\n__u64 tag;\r\n} head;\r\nint total = ret = iov_iter_count(iter);\r\nint n;\r\nint downcall_size = sizeof(struct orangefs_downcall_s);\r\nint head_size = sizeof(head);\r\ngossip_debug(GOSSIP_DEV_DEBUG, "%s: total:%d: ret:%zd:\n",\r\n__func__,\r\ntotal,\r\nret);\r\nif (total < MAX_DEV_REQ_DOWNSIZE) {\r\ngossip_err("%s: total:%d: must be at least:%u:\n",\r\n__func__,\r\ntotal,\r\n(unsigned int) MAX_DEV_REQ_DOWNSIZE);\r\nreturn -EFAULT;\r\n}\r\nn = copy_from_iter(&head, head_size, iter);\r\nif (n < head_size) {\r\ngossip_err("%s: failed to copy head.\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nif (head.version < ORANGEFS_MINIMUM_USERSPACE_VERSION) {\r\ngossip_err("%s: userspace claims version"\r\n"%d, minimum version required: %d.\n",\r\n__func__,\r\nhead.version,\r\nORANGEFS_MINIMUM_USERSPACE_VERSION);\r\nreturn -EPROTO;\r\n}\r\nif (head.magic != ORANGEFS_DEVREQ_MAGIC) {\r\ngossip_err("Error: Device magic number does not match.\n");\r\nreturn -EPROTO;\r\n}\r\nop = orangefs_devreq_remove_op(head.tag);\r\nif (!op) {\r\ngossip_err("WARNING: No one's waiting for tag %llu\n",\r\nllu(head.tag));\r\nreturn ret;\r\n}\r\nn = copy_from_iter(&op->downcall, downcall_size, iter);\r\nif (n != downcall_size) {\r\ngossip_err("%s: failed to copy downcall.\n", __func__);\r\ngoto Efault;\r\n}\r\nif (op->downcall.status)\r\ngoto wakeup;\r\nif ((head_size + downcall_size + op->downcall.trailer_size) != total) {\r\ngossip_err("%s: funky write, head_size:%d"\r\n": downcall_size:%d: trailer_size:%lld"\r\n": total size:%d:\n",\r\n__func__,\r\nhead_size,\r\ndowncall_size,\r\nop->downcall.trailer_size,\r\ntotal);\r\ngoto Efault;\r\n}\r\nif ((op->downcall.type != ORANGEFS_VFS_OP_READDIR) &&\r\n(op->downcall.trailer_size != 0)) {\r\ngossip_err("%s: %x operation with trailer.",\r\n__func__,\r\nop->downcall.type);\r\ngoto Efault;\r\n}\r\nif ((op->downcall.type == ORANGEFS_VFS_OP_READDIR) &&\r\n(op->downcall.trailer_size == 0)) {\r\ngossip_err("%s: %x operation with no trailer.",\r\n__func__,\r\nop->downcall.type);\r\ngoto Efault;\r\n}\r\nif (op->downcall.type != ORANGEFS_VFS_OP_READDIR)\r\ngoto wakeup;\r\nop->downcall.trailer_buf =\r\nvmalloc(op->downcall.trailer_size);\r\nif (op->downcall.trailer_buf == NULL) {\r\ngossip_err("%s: failed trailer vmalloc.\n",\r\n__func__);\r\ngoto Enomem;\r\n}\r\nmemset(op->downcall.trailer_buf, 0, op->downcall.trailer_size);\r\nn = copy_from_iter(op->downcall.trailer_buf,\r\nop->downcall.trailer_size,\r\niter);\r\nif (n != op->downcall.trailer_size) {\r\ngossip_err("%s: failed to copy trailer.\n", __func__);\r\nvfree(op->downcall.trailer_buf);\r\ngoto Efault;\r\n}\r\nwakeup:\r\nspin_lock(&op->lock);\r\nif (unlikely(op_is_cancel(op))) {\r\nspin_unlock(&op->lock);\r\nput_cancel(op);\r\n} else if (unlikely(op_state_given_up(op))) {\r\nspin_unlock(&op->lock);\r\ncomplete(&op->waitq);\r\n} else {\r\nset_op_state_serviced(op);\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: op:%s: op_state:%d: process:%s:\n",\r\n__func__,\r\nget_opname_string(op),\r\nop->op_state,\r\ncurrent->comm);\r\nspin_unlock(&op->lock);\r\n}\r\nreturn ret;\r\nEfault:\r\nop->downcall.status = -(ORANGEFS_ERROR_BIT | 9);\r\nret = -EFAULT;\r\ngoto wakeup;\r\nEnomem:\r\nop->downcall.status = -(ORANGEFS_ERROR_BIT | 8);\r\nret = -ENOMEM;\r\ngoto wakeup;\r\n}\r\nstatic int orangefs_devreq_release(struct inode *inode, struct file *file)\r\n{\r\nint unmounted = 0;\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s:pvfs2-client-core: exiting, closing device\n",\r\n__func__);\r\nmutex_lock(&devreq_mutex);\r\norangefs_bufmap_finalize();\r\nopen_access_count = -1;\r\nunmounted = mark_all_pending_mounts();\r\ngossip_debug(GOSSIP_DEV_DEBUG, "ORANGEFS Device Close: Filesystem(s) %s\n",\r\n(unmounted ? "UNMOUNTED" : "MOUNTED"));\r\npurge_waiting_ops();\r\npurge_inprogress_ops();\r\norangefs_bufmap_run_down();\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"pvfs2-client-core: device close complete\n");\r\nopen_access_count = 0;\r\nmutex_unlock(&devreq_mutex);\r\nreturn 0;\r\n}\r\nint is_daemon_in_service(void)\r\n{\r\nint in_service;\r\nmutex_lock(&devreq_mutex);\r\nin_service = open_access_count == 1 ? 0 : -EIO;\r\nmutex_unlock(&devreq_mutex);\r\nreturn in_service;\r\n}\r\nbool __is_daemon_in_service(void)\r\n{\r\nreturn open_access_count == 1;\r\n}\r\nstatic inline long check_ioctl_command(unsigned int command)\r\n{\r\nif (_IOC_TYPE(command) != ORANGEFS_DEV_MAGIC) {\r\ngossip_err("device ioctl magic numbers don't match! Did you rebuild pvfs2-client-core/libpvfs2? [cmd %x, magic %x != %x]\n",\r\ncommand,\r\n_IOC_TYPE(command),\r\nORANGEFS_DEV_MAGIC);\r\nreturn -EINVAL;\r\n}\r\nif (_IOC_NR(command) >= ORANGEFS_DEV_MAXNR || _IOC_NR(command) <= 0) {\r\ngossip_err("Invalid ioctl command number [%d >= %d]\n",\r\n_IOC_NR(command), ORANGEFS_DEV_MAXNR);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic long dispatch_ioctl_command(unsigned int command, unsigned long arg)\r\n{\r\nstatic __s32 magic = ORANGEFS_DEVREQ_MAGIC;\r\nstatic __s32 max_up_size = MAX_DEV_REQ_UPSIZE;\r\nstatic __s32 max_down_size = MAX_DEV_REQ_DOWNSIZE;\r\nstruct ORANGEFS_dev_map_desc user_desc;\r\nint ret = 0;\r\nstruct dev_mask_info_s mask_info = { 0 };\r\nstruct dev_mask2_info_s mask2_info = { 0, 0 };\r\nint upstream_kmod = 1;\r\nstruct orangefs_sb_info_s *orangefs_sb;\r\nswitch (command) {\r\ncase ORANGEFS_DEV_GET_MAGIC:\r\nreturn ((put_user(magic, (__s32 __user *) arg) == -EFAULT) ?\r\n-EIO :\r\n0);\r\ncase ORANGEFS_DEV_GET_MAX_UPSIZE:\r\nreturn ((put_user(max_up_size,\r\n(__s32 __user *) arg) == -EFAULT) ?\r\n-EIO :\r\n0);\r\ncase ORANGEFS_DEV_GET_MAX_DOWNSIZE:\r\nreturn ((put_user(max_down_size,\r\n(__s32 __user *) arg) == -EFAULT) ?\r\n-EIO :\r\n0);\r\ncase ORANGEFS_DEV_MAP:\r\nret = copy_from_user(&user_desc,\r\n(struct ORANGEFS_dev_map_desc __user *)\r\narg,\r\nsizeof(struct ORANGEFS_dev_map_desc));\r\nreturn ret ? -EIO : orangefs_bufmap_initialize(&user_desc);\r\ncase ORANGEFS_DEV_REMOUNT_ALL:\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: got ORANGEFS_DEV_REMOUNT_ALL\n",\r\n__func__);\r\nret = mutex_lock_interruptible(&request_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: priority remount in progress\n",\r\n__func__);\r\nspin_lock(&orangefs_superblocks_lock);\r\nlist_for_each_entry(orangefs_sb, &orangefs_superblocks, list) {\r\nif (!orangefs_sb->list.prev)\r\ncontinue;\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: Remounting SB %p\n",\r\n__func__,\r\norangefs_sb);\r\nspin_unlock(&orangefs_superblocks_lock);\r\nret = orangefs_remount(orangefs_sb);\r\nspin_lock(&orangefs_superblocks_lock);\r\nif (ret) {\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"SB %p remount failed\n",\r\norangefs_sb);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&orangefs_superblocks_lock);\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"%s: priority remount complete\n",\r\n__func__);\r\nmutex_unlock(&request_mutex);\r\nreturn ret;\r\ncase ORANGEFS_DEV_UPSTREAM:\r\nret = copy_to_user((void __user *)arg,\r\n&upstream_kmod,\r\nsizeof(upstream_kmod));\r\nif (ret != 0)\r\nreturn -EIO;\r\nelse\r\nreturn ret;\r\ncase ORANGEFS_DEV_CLIENT_MASK:\r\nret = copy_from_user(&mask2_info,\r\n(void __user *)arg,\r\nsizeof(struct dev_mask2_info_s));\r\nif (ret != 0)\r\nreturn -EIO;\r\nclient_debug_mask.mask1 = mask2_info.mask1_value;\r\nclient_debug_mask.mask2 = mask2_info.mask2_value;\r\npr_info("%s: client debug mask has been been received "\r\n":%llx: :%llx:\n",\r\n__func__,\r\n(unsigned long long)client_debug_mask.mask1,\r\n(unsigned long long)client_debug_mask.mask2);\r\nreturn ret;\r\ncase ORANGEFS_DEV_CLIENT_STRING:\r\nret = copy_from_user(&client_debug_array_string,\r\n(void __user *)arg,\r\nORANGEFS_MAX_DEBUG_STRING_LEN);\r\nclient_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN - 1] =\r\n'\0';\r\nif (ret != 0) {\r\npr_info("%s: CLIENT_STRING: copy_from_user failed\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\npr_info("%s: client debug array string has been received.\n",\r\n__func__);\r\nif (!help_string_initialized) {\r\nkfree(debug_help_string);\r\nif (orangefs_prepare_debugfs_help_string(0)) {\r\ngossip_err("%s: no debug help string \n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\ndebugfs_remove(help_file_dentry);\r\nhelp_file_dentry =\r\ndebugfs_create_file(\r\nORANGEFS_KMOD_DEBUG_HELP_FILE,\r\n0444,\r\ndebug_dir,\r\ndebug_help_string,\r\n&debug_help_fops);\r\nif (!help_file_dentry) {\r\ngossip_err("%s: debugfs_create_file failed for"\r\n" :%s:!\n",\r\n__func__,\r\nORANGEFS_KMOD_DEBUG_HELP_FILE);\r\nreturn -EIO;\r\n}\r\n}\r\ndebug_mask_to_string(&client_debug_mask, 1);\r\ndebugfs_remove(client_debug_dentry);\r\norangefs_client_debug_init();\r\nhelp_string_initialized++;\r\nreturn ret;\r\ncase ORANGEFS_DEV_DEBUG:\r\nret = copy_from_user(&mask_info,\r\n(void __user *)arg,\r\nsizeof(mask_info));\r\nif (ret != 0)\r\nreturn -EIO;\r\nif (mask_info.mask_type == KERNEL_MASK) {\r\nif ((mask_info.mask_value == 0)\r\n&& (kernel_mask_set_mod_init)) {\r\nreturn 0;\r\n}\r\ndebug_mask_to_string(&mask_info.mask_value,\r\nmask_info.mask_type);\r\ngossip_debug_mask = mask_info.mask_value;\r\npr_info("%s: kernel debug mask has been modified to "\r\n":%s: :%llx:\n",\r\n__func__,\r\nkernel_debug_string,\r\n(unsigned long long)gossip_debug_mask);\r\n} else if (mask_info.mask_type == CLIENT_MASK) {\r\ndebug_mask_to_string(&mask_info.mask_value,\r\nmask_info.mask_type);\r\npr_info("%s: client debug mask has been modified to"\r\n":%s: :%llx:\n",\r\n__func__,\r\nclient_debug_string,\r\nllu(mask_info.mask_value));\r\n} else {\r\ngossip_lerr("Invalid mask type....\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic long orangefs_devreq_ioctl(struct file *file,\r\nunsigned int command, unsigned long arg)\r\n{\r\nlong ret;\r\nret = check_ioctl_command(command);\r\nif (ret < 0)\r\nreturn (int)ret;\r\nreturn (int)dispatch_ioctl_command(command, arg);\r\n}\r\nstatic unsigned long translate_dev_map26(unsigned long args, long *error)\r\n{\r\nstruct ORANGEFS_dev_map_desc32 __user *p32 = (void __user *)args;\r\nstruct ORANGEFS_dev_map_desc __user *p =\r\ncompat_alloc_user_space(sizeof(*p));\r\ncompat_uptr_t addr;\r\n*error = 0;\r\nif (get_user(addr, &p32->ptr))\r\ngoto err;\r\nif (put_user(compat_ptr(addr), &p->ptr))\r\ngoto err;\r\nif (copy_in_user(&p->total_size, &p32->total_size, sizeof(__s32)))\r\ngoto err;\r\nif (copy_in_user(&p->size, &p32->size, sizeof(__s32)))\r\ngoto err;\r\nif (copy_in_user(&p->count, &p32->count, sizeof(__s32)))\r\ngoto err;\r\nreturn (unsigned long)p;\r\nerr:\r\n*error = -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long args)\r\n{\r\nlong ret;\r\nunsigned long arg = args;\r\nret = check_ioctl_command(cmd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cmd == ORANGEFS_DEV_MAP) {\r\narg = translate_dev_map26(args, &ret);\r\nif (ret < 0) {\r\ngossip_err("Could not translate dev map\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn dispatch_ioctl_command(cmd, arg);\r\n}\r\nint orangefs_dev_init(void)\r\n{\r\norangefs_dev_major = register_chrdev(0,\r\nORANGEFS_REQDEVICE_NAME,\r\n&orangefs_devreq_file_operations);\r\nif (orangefs_dev_major < 0) {\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"Failed to register /dev/%s (error %d)\n",\r\nORANGEFS_REQDEVICE_NAME, orangefs_dev_major);\r\nreturn orangefs_dev_major;\r\n}\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"*** /dev/%s character device registered ***\n",\r\nORANGEFS_REQDEVICE_NAME);\r\ngossip_debug(GOSSIP_DEV_DEBUG, "'mknod /dev/%s c %d 0'.\n",\r\nORANGEFS_REQDEVICE_NAME, orangefs_dev_major);\r\nreturn 0;\r\n}\r\nvoid orangefs_dev_cleanup(void)\r\n{\r\nunregister_chrdev(orangefs_dev_major, ORANGEFS_REQDEVICE_NAME);\r\ngossip_debug(GOSSIP_DEV_DEBUG,\r\n"*** /dev/%s character device unregistered ***\n",\r\nORANGEFS_REQDEVICE_NAME);\r\n}\r\nstatic unsigned int orangefs_devreq_poll(struct file *file,\r\nstruct poll_table_struct *poll_table)\r\n{\r\nint poll_revent_mask = 0;\r\npoll_wait(file, &orangefs_request_list_waitq, poll_table);\r\nif (!list_empty(&orangefs_request_list))\r\npoll_revent_mask |= POLL_IN;\r\nreturn poll_revent_mask;\r\n}
