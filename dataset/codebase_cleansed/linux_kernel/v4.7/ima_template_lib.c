static bool ima_template_hash_algo_allowed(u8 algo)\r\n{\r\nif (algo == HASH_ALGO_SHA1 || algo == HASH_ALGO_MD5)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int ima_write_template_field_data(const void *data, const u32 datalen,\r\nenum data_formats datafmt,\r\nstruct ima_field_data *field_data)\r\n{\r\nu8 *buf, *buf_ptr;\r\nu32 buflen = datalen;\r\nif (datafmt == DATA_FMT_STRING)\r\nbuflen = datalen + 1;\r\nbuf = kzalloc(buflen, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nmemcpy(buf, data, datalen);\r\nif (datafmt == DATA_FMT_STRING) {\r\nfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\r\nif (*buf_ptr == ' ')\r\n*buf_ptr = '_';\r\n}\r\nfield_data->data = buf;\r\nfield_data->len = buflen;\r\nreturn 0;\r\n}\r\nstatic void ima_show_template_data_ascii(struct seq_file *m,\r\nenum ima_show_type show,\r\nenum data_formats datafmt,\r\nstruct ima_field_data *field_data)\r\n{\r\nu8 *buf_ptr = field_data->data;\r\nu32 buflen = field_data->len;\r\nswitch (datafmt) {\r\ncase DATA_FMT_DIGEST_WITH_ALGO:\r\nbuf_ptr = strnchr(field_data->data, buflen, ':');\r\nif (buf_ptr != field_data->data)\r\nseq_printf(m, "%s", field_data->data);\r\nbuf_ptr += 2;\r\nbuflen -= buf_ptr - field_data->data;\r\ncase DATA_FMT_DIGEST:\r\ncase DATA_FMT_HEX:\r\nif (!buflen)\r\nbreak;\r\nima_print_digest(m, buf_ptr, buflen);\r\nbreak;\r\ncase DATA_FMT_STRING:\r\nseq_printf(m, "%s", buf_ptr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ima_show_template_data_binary(struct seq_file *m,\r\nenum ima_show_type show,\r\nenum data_formats datafmt,\r\nstruct ima_field_data *field_data)\r\n{\r\nu32 len = (show == IMA_SHOW_BINARY_OLD_STRING_FMT) ?\r\nstrlen(field_data->data) : field_data->len;\r\nif (show != IMA_SHOW_BINARY_NO_FIELD_LEN)\r\nima_putc(m, &len, sizeof(len));\r\nif (!len)\r\nreturn;\r\nima_putc(m, field_data->data, len);\r\n}\r\nstatic void ima_show_template_field_data(struct seq_file *m,\r\nenum ima_show_type show,\r\nenum data_formats datafmt,\r\nstruct ima_field_data *field_data)\r\n{\r\nswitch (show) {\r\ncase IMA_SHOW_ASCII:\r\nima_show_template_data_ascii(m, show, datafmt, field_data);\r\nbreak;\r\ncase IMA_SHOW_BINARY:\r\ncase IMA_SHOW_BINARY_NO_FIELD_LEN:\r\ncase IMA_SHOW_BINARY_OLD_STRING_FMT:\r\nima_show_template_data_binary(m, show, datafmt, field_data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ima_show_template_digest(struct seq_file *m, enum ima_show_type show,\r\nstruct ima_field_data *field_data)\r\n{\r\nima_show_template_field_data(m, show, DATA_FMT_DIGEST, field_data);\r\n}\r\nvoid ima_show_template_digest_ng(struct seq_file *m, enum ima_show_type show,\r\nstruct ima_field_data *field_data)\r\n{\r\nima_show_template_field_data(m, show, DATA_FMT_DIGEST_WITH_ALGO,\r\nfield_data);\r\n}\r\nvoid ima_show_template_string(struct seq_file *m, enum ima_show_type show,\r\nstruct ima_field_data *field_data)\r\n{\r\nima_show_template_field_data(m, show, DATA_FMT_STRING, field_data);\r\n}\r\nvoid ima_show_template_sig(struct seq_file *m, enum ima_show_type show,\r\nstruct ima_field_data *field_data)\r\n{\r\nima_show_template_field_data(m, show, DATA_FMT_HEX, field_data);\r\n}\r\nstatic int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,\r\nstruct ima_field_data *field_data)\r\n{\r\nu8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };\r\nenum data_formats fmt = DATA_FMT_DIGEST;\r\nu32 offset = 0;\r\nif (hash_algo < HASH_ALGO__LAST) {\r\nfmt = DATA_FMT_DIGEST_WITH_ALGO;\r\noffset += snprintf(buffer, CRYPTO_MAX_ALG_NAME + 1, "%s",\r\nhash_algo_name[hash_algo]);\r\nbuffer[offset] = ':';\r\noffset += 2;\r\n}\r\nif (digest)\r\nmemcpy(buffer + offset, digest, digestsize);\r\nelse\r\noffset += IMA_DIGEST_SIZE;\r\nreturn ima_write_template_field_data(buffer, offset + digestsize,\r\nfmt, field_data);\r\n}\r\nint ima_eventdigest_init(struct ima_event_data *event_data,\r\nstruct ima_field_data *field_data)\r\n{\r\nstruct {\r\nstruct ima_digest_data hdr;\r\nchar digest[IMA_MAX_DIGEST_SIZE];\r\n} hash;\r\nu8 *cur_digest = NULL;\r\nu32 cur_digestsize = 0;\r\nstruct inode *inode;\r\nint result;\r\nmemset(&hash, 0, sizeof(hash));\r\nif (event_data->violation)\r\ngoto out;\r\nif (ima_template_hash_algo_allowed(event_data->iint->ima_hash->algo)) {\r\ncur_digest = event_data->iint->ima_hash->digest;\r\ncur_digestsize = event_data->iint->ima_hash->length;\r\ngoto out;\r\n}\r\nif (!event_data->file)\r\nreturn -EINVAL;\r\ninode = file_inode(event_data->file);\r\nhash.hdr.algo = ima_template_hash_algo_allowed(ima_hash_algo) ?\r\nima_hash_algo : HASH_ALGO_SHA1;\r\nresult = ima_calc_file_hash(event_data->file, &hash.hdr);\r\nif (result) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\r\nevent_data->filename, "collect_data",\r\n"failed", result, 0);\r\nreturn result;\r\n}\r\ncur_digest = hash.hdr.digest;\r\ncur_digestsize = hash.hdr.length;\r\nout:\r\nreturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\r\nHASH_ALGO__LAST, field_data);\r\n}\r\nint ima_eventdigest_ng_init(struct ima_event_data *event_data,\r\nstruct ima_field_data *field_data)\r\n{\r\nu8 *cur_digest = NULL, hash_algo = HASH_ALGO_SHA1;\r\nu32 cur_digestsize = 0;\r\nif (event_data->violation)\r\ngoto out;\r\ncur_digest = event_data->iint->ima_hash->digest;\r\ncur_digestsize = event_data->iint->ima_hash->length;\r\nhash_algo = event_data->iint->ima_hash->algo;\r\nout:\r\nreturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\r\nhash_algo, field_data);\r\n}\r\nstatic int ima_eventname_init_common(struct ima_event_data *event_data,\r\nstruct ima_field_data *field_data,\r\nbool size_limit)\r\n{\r\nconst char *cur_filename = NULL;\r\nu32 cur_filename_len = 0;\r\nBUG_ON(event_data->filename == NULL && event_data->file == NULL);\r\nif (event_data->filename) {\r\ncur_filename = event_data->filename;\r\ncur_filename_len = strlen(event_data->filename);\r\nif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\r\ngoto out;\r\n}\r\nif (event_data->file) {\r\ncur_filename = event_data->file->f_path.dentry->d_name.name;\r\ncur_filename_len = strlen(cur_filename);\r\n} else\r\ncur_filename_len = IMA_EVENT_NAME_LEN_MAX;\r\nout:\r\nreturn ima_write_template_field_data(cur_filename, cur_filename_len,\r\nDATA_FMT_STRING, field_data);\r\n}\r\nint ima_eventname_init(struct ima_event_data *event_data,\r\nstruct ima_field_data *field_data)\r\n{\r\nreturn ima_eventname_init_common(event_data, field_data, true);\r\n}\r\nint ima_eventname_ng_init(struct ima_event_data *event_data,\r\nstruct ima_field_data *field_data)\r\n{\r\nreturn ima_eventname_init_common(event_data, field_data, false);\r\n}\r\nint ima_eventsig_init(struct ima_event_data *event_data,\r\nstruct ima_field_data *field_data)\r\n{\r\nenum data_formats fmt = DATA_FMT_HEX;\r\nstruct evm_ima_xattr_data *xattr_value = event_data->xattr_value;\r\nint xattr_len = event_data->xattr_len;\r\nint rc = 0;\r\nif ((!xattr_value) || (xattr_value->type != EVM_IMA_XATTR_DIGSIG))\r\ngoto out;\r\nrc = ima_write_template_field_data(xattr_value, xattr_len, fmt,\r\nfield_data);\r\nout:\r\nreturn rc;\r\n}
