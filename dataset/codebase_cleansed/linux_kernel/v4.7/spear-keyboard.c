static irqreturn_t spear_kbd_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spear_kbd *kbd = dev_id;\r\nstruct input_dev *input = kbd->input;\r\nunsigned int key;\r\nu32 sts, val;\r\nsts = readl_relaxed(kbd->io_base + STATUS_REG);\r\nif (!(sts & STATUS_DATA_AVAIL))\r\nreturn IRQ_NONE;\r\nif (kbd->last_key != KEY_RESERVED) {\r\ninput_report_key(input, kbd->last_key, 0);\r\nkbd->last_key = KEY_RESERVED;\r\n}\r\nval = readl_relaxed(kbd->io_base + DATA_REG) &\r\n(DATA_ROW_MASK | DATA_COLUMN_MASK);\r\nkey = kbd->keycodes[val];\r\ninput_event(input, EV_MSC, MSC_SCAN, val);\r\ninput_report_key(input, key, 1);\r\ninput_sync(input);\r\nkbd->last_key = key;\r\nwritel_relaxed(0, kbd->io_base + STATUS_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spear_kbd_open(struct input_dev *dev)\r\n{\r\nstruct spear_kbd *kbd = input_get_drvdata(dev);\r\nint error;\r\nu32 val;\r\nkbd->last_key = KEY_RESERVED;\r\nerror = clk_enable(kbd->clk);\r\nif (error)\r\nreturn error;\r\nval = clk_get_rate(kbd->clk) / 1000000 - 1;\r\nval = (val & MODE_CTL_PCLK_FREQ_MSK) << MODE_CTL_PCLK_FREQ_SHIFT;\r\nval = MODE_CTL_SCAN_RATE_80 | MODE_CTL_KEYBOARD | val |\r\n(kbd->mode << MODE_CTL_KEYNUM_SHIFT);\r\nwritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\r\nwritel_relaxed(1, kbd->io_base + STATUS_REG);\r\nval = readl_relaxed(kbd->io_base + MODE_CTL_REG);\r\nval |= MODE_CTL_START_SCAN;\r\nwritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\r\nreturn 0;\r\n}\r\nstatic void spear_kbd_close(struct input_dev *dev)\r\n{\r\nstruct spear_kbd *kbd = input_get_drvdata(dev);\r\nu32 val;\r\nval = readl_relaxed(kbd->io_base + MODE_CTL_REG);\r\nval &= ~MODE_CTL_START_SCAN;\r\nwritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\r\nclk_disable(kbd->clk);\r\nkbd->last_key = KEY_RESERVED;\r\n}\r\nstatic int spear_kbd_parse_dt(struct platform_device *pdev,\r\nstruct spear_kbd *kbd)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint error;\r\nu32 val, suspended_rate;\r\nif (!np) {\r\ndev_err(&pdev->dev, "Missing DT data\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_bool(np, "autorepeat"))\r\nkbd->rep = true;\r\nif (of_property_read_u32(np, "suspended_rate", &suspended_rate))\r\nkbd->suspended_rate = suspended_rate;\r\nerror = of_property_read_u32(np, "st,mode", &val);\r\nif (error) {\r\ndev_err(&pdev->dev, "DT: Invalid or missing mode\n");\r\nreturn error;\r\n}\r\nkbd->mode = val;\r\nreturn 0;\r\n}\r\nstatic inline int spear_kbd_parse_dt(struct platform_device *pdev,\r\nstruct spear_kbd *kbd)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int spear_kbd_probe(struct platform_device *pdev)\r\n{\r\nstruct kbd_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nconst struct matrix_keymap_data *keymap = pdata ? pdata->keymap : NULL;\r\nstruct spear_kbd *kbd;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint irq;\r\nint error;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "not able to get irq for the device\n");\r\nreturn irq;\r\n}\r\nkbd = devm_kzalloc(&pdev->dev, sizeof(*kbd), GFP_KERNEL);\r\nif (!kbd) {\r\ndev_err(&pdev->dev, "not enough memory for driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "unable to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nkbd->input = input_dev;\r\nkbd->irq = irq;\r\nif (!pdata) {\r\nerror = spear_kbd_parse_dt(pdev, kbd);\r\nif (error)\r\nreturn error;\r\n} else {\r\nkbd->mode = pdata->mode;\r\nkbd->rep = pdata->rep;\r\nkbd->suspended_rate = pdata->suspended_rate;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkbd->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(kbd->io_base))\r\nreturn PTR_ERR(kbd->io_base);\r\nkbd->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(kbd->clk))\r\nreturn PTR_ERR(kbd->clk);\r\ninput_dev->name = "Spear Keyboard";\r\ninput_dev->phys = "keyboard/input0";\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->open = spear_kbd_open;\r\ninput_dev->close = spear_kbd_close;\r\nerror = matrix_keypad_build_keymap(keymap, NULL, NUM_ROWS, NUM_COLS,\r\nkbd->keycodes, input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to build keymap\n");\r\nreturn error;\r\n}\r\nif (kbd->rep)\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input_dev, kbd);\r\nerror = devm_request_irq(&pdev->dev, irq, spear_kbd_interrupt, 0,\r\n"keyboard", kbd);\r\nif (error) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\nreturn error;\r\n}\r\nerror = clk_prepare(kbd->clk);\r\nif (error)\r\nreturn error;\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to register keyboard device\n");\r\nclk_unprepare(kbd->clk);\r\nreturn error;\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nplatform_set_drvdata(pdev, kbd);\r\nreturn 0;\r\n}\r\nstatic int spear_kbd_remove(struct platform_device *pdev)\r\n{\r\nstruct spear_kbd *kbd = platform_get_drvdata(pdev);\r\ninput_unregister_device(kbd->input);\r\nclk_unprepare(kbd->clk);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused spear_kbd_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spear_kbd *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input;\r\nunsigned int rate = 0, mode_ctl_reg, val;\r\nmutex_lock(&input_dev->mutex);\r\nclk_enable(kbd->clk);\r\nmode_ctl_reg = readl_relaxed(kbd->io_base + MODE_CTL_REG);\r\nif (device_may_wakeup(&pdev->dev)) {\r\nif (!enable_irq_wake(kbd->irq))\r\nkbd->irq_wake_enabled = true;\r\nif (kbd->suspended_rate)\r\nrate = kbd->suspended_rate / 1000000 - 1;\r\nelse\r\nrate = clk_get_rate(kbd->clk) / 1000000 - 1;\r\nval = mode_ctl_reg &\r\n~(MODE_CTL_PCLK_FREQ_MSK << MODE_CTL_PCLK_FREQ_SHIFT);\r\nval |= (rate & MODE_CTL_PCLK_FREQ_MSK)\r\n<< MODE_CTL_PCLK_FREQ_SHIFT;\r\nwritel_relaxed(val, kbd->io_base + MODE_CTL_REG);\r\n} else {\r\nif (input_dev->users) {\r\nwritel_relaxed(mode_ctl_reg & ~MODE_CTL_START_SCAN,\r\nkbd->io_base + MODE_CTL_REG);\r\nclk_disable(kbd->clk);\r\n}\r\n}\r\nif (input_dev->users)\r\nkbd->mode_ctl_reg = mode_ctl_reg;\r\nclk_disable(kbd->clk);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused spear_kbd_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spear_kbd *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input;\r\nmutex_lock(&input_dev->mutex);\r\nif (device_may_wakeup(&pdev->dev)) {\r\nif (kbd->irq_wake_enabled) {\r\nkbd->irq_wake_enabled = false;\r\ndisable_irq_wake(kbd->irq);\r\n}\r\n} else {\r\nif (input_dev->users)\r\nclk_enable(kbd->clk);\r\n}\r\nif (input_dev->users)\r\nwritel_relaxed(kbd->mode_ctl_reg, kbd->io_base + MODE_CTL_REG);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
