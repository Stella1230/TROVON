static int ziirave_wdt_revision(struct i2c_client *client,\r\nstruct ziirave_wdt_rev *rev, u8 command)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, command);\r\nif (ret < 0)\r\nreturn ret;\r\nrev->major = ret;\r\nret = i2c_smbus_read_byte_data(client, command + 1);\r\nif (ret < 0)\r\nreturn ret;\r\nrev->minor = ret;\r\nreturn 0;\r\n}\r\nstatic int ziirave_wdt_set_state(struct watchdog_device *wdd, int state)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nreturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_STATE, state);\r\n}\r\nstatic int ziirave_wdt_start(struct watchdog_device *wdd)\r\n{\r\nreturn ziirave_wdt_set_state(wdd, ZIIRAVE_STATE_ON);\r\n}\r\nstatic int ziirave_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nreturn ziirave_wdt_set_state(wdd, ZIIRAVE_STATE_OFF);\r\n}\r\nstatic int ziirave_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nreturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_PING,\r\nZIIRAVE_PING_VALUE);\r\n}\r\nstatic int ziirave_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_TIMEOUT, timeout);\r\nif (!ret)\r\nwdd->timeout = timeout;\r\nreturn ret;\r\n}\r\nstatic unsigned int ziirave_wdt_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_TIME_LEFT);\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic ssize_t ziirave_wdt_sysfs_show_firm(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "02.%02u.%02u", w_priv->firmware_rev.major,\r\nw_priv->firmware_rev.minor);\r\n}\r\nstatic ssize_t ziirave_wdt_sysfs_show_boot(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "01.%02u.%02u", w_priv->bootloader_rev.major,\r\nw_priv->bootloader_rev.minor);\r\n}\r\nstatic ssize_t ziirave_wdt_sysfs_show_reason(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%s", ziirave_reasons[w_priv->reset_reason]);\r\n}\r\nstatic int ziirave_wdt_init_duration(struct i2c_client *client)\r\n{\r\nint ret;\r\nif (!reset_duration) {\r\nif (!client->dev.of_node)\r\nret = -ENODEV;\r\nelse\r\nret = of_property_read_u32(client->dev.of_node,\r\n"reset-duration-ms",\r\n&reset_duration);\r\nif (ret) {\r\ndev_info(&client->dev,\r\n"Unable to set reset pulse duration, using default\n");\r\nreturn 0;\r\n}\r\n}\r\nif (reset_duration < 1 || reset_duration > 255)\r\nreturn -EINVAL;\r\ndev_info(&client->dev, "Setting reset duration to %dms",\r\nreset_duration);\r\nreturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_RESET_DURATION,\r\nreset_duration);\r\n}\r\nstatic int ziirave_wdt_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct ziirave_wdt_data *w_priv;\r\nint val;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nw_priv = devm_kzalloc(&client->dev, sizeof(*w_priv), GFP_KERNEL);\r\nif (!w_priv)\r\nreturn -ENOMEM;\r\nw_priv->wdd.info = &ziirave_wdt_info;\r\nw_priv->wdd.ops = &ziirave_wdt_ops;\r\nw_priv->wdd.min_timeout = ZIIRAVE_TIMEOUT_MIN;\r\nw_priv->wdd.max_timeout = ZIIRAVE_TIMEOUT_MAX;\r\nw_priv->wdd.parent = &client->dev;\r\nw_priv->wdd.groups = ziirave_wdt_groups;\r\nret = watchdog_init_timeout(&w_priv->wdd, wdt_timeout, &client->dev);\r\nif (ret) {\r\ndev_info(&client->dev,\r\n"Unable to select timeout value, using default\n");\r\n}\r\nif (w_priv->wdd.timeout == 0) {\r\nval = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_TIMEOUT);\r\nif (val < 0)\r\nreturn val;\r\nif (val < ZIIRAVE_TIMEOUT_MIN)\r\nreturn -ENODEV;\r\nw_priv->wdd.timeout = val;\r\n} else {\r\nret = ziirave_wdt_set_timeout(&w_priv->wdd,\r\nw_priv->wdd.timeout);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&client->dev, "Timeout set to %ds.",\r\nw_priv->wdd.timeout);\r\n}\r\nwatchdog_set_nowayout(&w_priv->wdd, nowayout);\r\ni2c_set_clientdata(client, w_priv);\r\nval = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_STATE);\r\nif (val < 0)\r\nreturn val;\r\nif (val == ZIIRAVE_STATE_INITIAL)\r\nziirave_wdt_stop(&w_priv->wdd);\r\nret = ziirave_wdt_init_duration(client);\r\nif (ret)\r\nreturn ret;\r\nret = ziirave_wdt_revision(client, &w_priv->firmware_rev,\r\nZIIRAVE_WDT_FIRM_VER_MAJOR);\r\nif (ret)\r\nreturn ret;\r\nret = ziirave_wdt_revision(client, &w_priv->bootloader_rev,\r\nZIIRAVE_WDT_BOOT_VER_MAJOR);\r\nif (ret)\r\nreturn ret;\r\nw_priv->reset_reason = i2c_smbus_read_byte_data(client,\r\nZIIRAVE_WDT_RESET_REASON);\r\nif (w_priv->reset_reason < 0)\r\nreturn w_priv->reset_reason;\r\nif (w_priv->reset_reason >= ARRAY_SIZE(ziirave_reasons) ||\r\n!ziirave_reasons[w_priv->reset_reason])\r\nreturn -ENODEV;\r\nret = watchdog_register_device(&w_priv->wdd);\r\nreturn ret;\r\n}\r\nstatic int ziirave_wdt_remove(struct i2c_client *client)\r\n{\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nwatchdog_unregister_device(&w_priv->wdd);\r\nreturn 0;\r\n}
