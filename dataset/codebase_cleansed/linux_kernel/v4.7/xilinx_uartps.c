static void cdns_uart_handle_rx(struct uart_port *port, unsigned int isrstatus)\r\n{\r\nif (isrstatus & CDNS_UART_IXR_FRAMING) {\r\nwhile (!(readl(port->membase + CDNS_UART_SR) &\r\nCDNS_UART_SR_RXEMPTY)) {\r\nif (!readl(port->membase + CDNS_UART_FIFO)) {\r\nport->read_status_mask |= CDNS_UART_IXR_BRK;\r\nisrstatus &= ~CDNS_UART_IXR_FRAMING;\r\n}\r\n}\r\nwritel(CDNS_UART_IXR_FRAMING, port->membase + CDNS_UART_ISR);\r\n}\r\nif (isrstatus & port->ignore_status_mask & CDNS_UART_IXR_PARITY)\r\nisrstatus &= ~(CDNS_UART_IXR_RXTRIG | CDNS_UART_IXR_TOUT);\r\nisrstatus &= port->read_status_mask;\r\nisrstatus &= ~port->ignore_status_mask;\r\nif (!(isrstatus & (CDNS_UART_IXR_TOUT | CDNS_UART_IXR_RXTRIG)))\r\nreturn;\r\nwhile (!(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_RXEMPTY)) {\r\nu32 data;\r\nchar status = TTY_NORMAL;\r\ndata = readl(port->membase + CDNS_UART_FIFO);\r\nif (data && (port->read_status_mask & CDNS_UART_IXR_BRK)) {\r\nport->read_status_mask &= ~CDNS_UART_IXR_BRK;\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (uart_handle_sysrq_char(port, data))\r\ncontinue;\r\nport->icount.rx++;\r\nif (isrstatus & CDNS_UART_IXR_PARITY) {\r\nport->icount.parity++;\r\nstatus = TTY_PARITY;\r\n} else if (isrstatus & CDNS_UART_IXR_FRAMING) {\r\nport->icount.frame++;\r\nstatus = TTY_FRAME;\r\n} else if (isrstatus & CDNS_UART_IXR_OVERRUN) {\r\nport->icount.overrun++;\r\n}\r\nuart_insert_char(port, isrstatus, CDNS_UART_IXR_OVERRUN,\r\ndata, status);\r\n}\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nstatic void cdns_uart_handle_tx(struct uart_port *port)\r\n{\r\nunsigned int numbytes;\r\nif (uart_circ_empty(&port->state->xmit)) {\r\nwritel(CDNS_UART_IXR_TXEMPTY, port->membase + CDNS_UART_IDR);\r\nreturn;\r\n}\r\nnumbytes = port->fifosize;\r\nwhile (numbytes && !uart_circ_empty(&port->state->xmit) &&\r\n!(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_TXFULL)) {\r\nwritel(port->state->xmit.buf[port->state->xmit.tail],\r\nport->membase + CDNS_UART_FIFO);\r\nport->icount.tx++;\r\nport->state->xmit.tail =\r\n(port->state->xmit.tail + 1) & (UART_XMIT_SIZE - 1);\r\nnumbytes--;\r\n}\r\nif (uart_circ_chars_pending(&port->state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic irqreturn_t cdns_uart_isr(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = (struct uart_port *)dev_id;\r\nunsigned long flags;\r\nunsigned int isrstatus;\r\nspin_lock_irqsave(&port->lock, flags);\r\nisrstatus = readl(port->membase + CDNS_UART_ISR);\r\nif (isrstatus & CDNS_UART_RX_IRQS)\r\ncdns_uart_handle_rx(port, isrstatus);\r\nif ((isrstatus & CDNS_UART_IXR_TXEMPTY) == CDNS_UART_IXR_TXEMPTY)\r\ncdns_uart_handle_tx(port);\r\nwritel(isrstatus, port->membase + CDNS_UART_ISR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int cdns_uart_calc_baud_divs(unsigned int clk,\r\nunsigned int baud, u32 *rbdiv, u32 *rcd, int *div8)\r\n{\r\nu32 cd, bdiv;\r\nunsigned int calc_baud;\r\nunsigned int bestbaud = 0;\r\nunsigned int bauderror;\r\nunsigned int besterror = ~0;\r\nif (baud < clk / ((CDNS_UART_BDIV_MAX + 1) * CDNS_UART_CD_MAX)) {\r\n*div8 = 1;\r\nclk /= 8;\r\n} else {\r\n*div8 = 0;\r\n}\r\nfor (bdiv = CDNS_UART_BDIV_MIN; bdiv <= CDNS_UART_BDIV_MAX; bdiv++) {\r\ncd = DIV_ROUND_CLOSEST(clk, baud * (bdiv + 1));\r\nif (cd < 1 || cd > CDNS_UART_CD_MAX)\r\ncontinue;\r\ncalc_baud = clk / (cd * (bdiv + 1));\r\nif (baud > calc_baud)\r\nbauderror = baud - calc_baud;\r\nelse\r\nbauderror = calc_baud - baud;\r\nif (besterror > bauderror) {\r\n*rbdiv = bdiv;\r\n*rcd = cd;\r\nbestbaud = calc_baud;\r\nbesterror = bauderror;\r\n}\r\n}\r\nif (((besterror * 100) / baud) < 3)\r\nbestbaud = baud;\r\nreturn bestbaud;\r\n}\r\nstatic unsigned int cdns_uart_set_baud_rate(struct uart_port *port,\r\nunsigned int baud)\r\n{\r\nunsigned int calc_baud;\r\nu32 cd = 0, bdiv = 0;\r\nu32 mreg;\r\nint div8;\r\nstruct cdns_uart *cdns_uart = port->private_data;\r\ncalc_baud = cdns_uart_calc_baud_divs(port->uartclk, baud, &bdiv, &cd,\r\n&div8);\r\nmreg = readl(port->membase + CDNS_UART_MR);\r\nif (div8)\r\nmreg |= CDNS_UART_MR_CLKSEL;\r\nelse\r\nmreg &= ~CDNS_UART_MR_CLKSEL;\r\nwritel(mreg, port->membase + CDNS_UART_MR);\r\nwritel(cd, port->membase + CDNS_UART_BAUDGEN);\r\nwritel(bdiv, port->membase + CDNS_UART_BAUDDIV);\r\ncdns_uart->baud = baud;\r\nreturn calc_baud;\r\n}\r\nstatic int cdns_uart_clk_notifier_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nu32 ctrl_reg;\r\nstruct uart_port *port;\r\nint locked = 0;\r\nstruct clk_notifier_data *ndata = data;\r\nunsigned long flags = 0;\r\nstruct cdns_uart *cdns_uart = to_cdns_uart(nb);\r\nport = cdns_uart->port;\r\nif (port->suspended)\r\nreturn NOTIFY_OK;\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\n{\r\nu32 bdiv, cd;\r\nint div8;\r\nif (!cdns_uart_calc_baud_divs(ndata->new_rate, cdns_uart->baud,\r\n&bdiv, &cd, &div8)) {\r\ndev_warn(port->dev, "clock rate change rejected\n");\r\nreturn NOTIFY_BAD;\r\n}\r\nspin_lock_irqsave(&cdns_uart->port->lock, flags);\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg |= CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nspin_unlock_irqrestore(&cdns_uart->port->lock, flags);\r\nreturn NOTIFY_OK;\r\n}\r\ncase POST_RATE_CHANGE:\r\nspin_lock_irqsave(&cdns_uart->port->lock, flags);\r\nlocked = 1;\r\nport->uartclk = ndata->new_rate;\r\ncdns_uart->baud = cdns_uart_set_baud_rate(cdns_uart->port,\r\ncdns_uart->baud);\r\ncase ABORT_RATE_CHANGE:\r\nif (!locked)\r\nspin_lock_irqsave(&cdns_uart->port->lock, flags);\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg |= CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nwhile (readl(port->membase + CDNS_UART_CR) &\r\n(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST))\r\ncpu_relax();\r\nwritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg &= ~(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS);\r\nctrl_reg |= CDNS_UART_CR_TX_EN | CDNS_UART_CR_RX_EN;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nspin_unlock_irqrestore(&cdns_uart->port->lock, flags);\r\nreturn NOTIFY_OK;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic void cdns_uart_start_tx(struct uart_port *port)\r\n{\r\nunsigned int status;\r\nif (uart_tx_stopped(port))\r\nreturn;\r\nstatus = readl(port->membase + CDNS_UART_CR);\r\nstatus &= ~CDNS_UART_CR_TX_DIS;\r\nstatus |= CDNS_UART_CR_TX_EN;\r\nwritel(status, port->membase + CDNS_UART_CR);\r\nif (uart_circ_empty(&port->state->xmit))\r\nreturn;\r\ncdns_uart_handle_tx(port);\r\nwritel(CDNS_UART_IXR_TXEMPTY, port->membase + CDNS_UART_ISR);\r\nwritel(CDNS_UART_IXR_TXEMPTY, port->membase + CDNS_UART_IER);\r\n}\r\nstatic void cdns_uart_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int regval;\r\nregval = readl(port->membase + CDNS_UART_CR);\r\nregval |= CDNS_UART_CR_TX_DIS;\r\nwritel(regval, port->membase + CDNS_UART_CR);\r\n}\r\nstatic void cdns_uart_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int regval;\r\nwritel(CDNS_UART_RX_IRQS, port->membase + CDNS_UART_IDR);\r\nregval = readl(port->membase + CDNS_UART_CR);\r\nregval |= CDNS_UART_CR_RX_DIS;\r\nwritel(regval, port->membase + CDNS_UART_CR);\r\n}\r\nstatic unsigned int cdns_uart_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int status;\r\nstatus = readl(port->membase + CDNS_UART_SR) &\r\nCDNS_UART_SR_TXEMPTY;\r\nreturn status ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void cdns_uart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nunsigned int status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = readl(port->membase + CDNS_UART_CR);\r\nif (ctl == -1)\r\nwritel(CDNS_UART_CR_STARTBRK | status,\r\nport->membase + CDNS_UART_CR);\r\nelse {\r\nif ((status & CDNS_UART_CR_STOPBRK) == 0)\r\nwritel(CDNS_UART_CR_STOPBRK | status,\r\nport->membase + CDNS_UART_CR);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void cdns_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nunsigned int cval = 0;\r\nunsigned int baud, minbaud, maxbaud;\r\nunsigned long flags;\r\nunsigned int ctrl_reg, mode_reg;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!(readl(port->membase + CDNS_UART_CR) &\r\nCDNS_UART_CR_TX_DIS)) {\r\nwhile (!(readl(port->membase + CDNS_UART_SR) &\r\nCDNS_UART_SR_TXEMPTY)) {\r\ncpu_relax();\r\n}\r\n}\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg |= CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nminbaud = port->uartclk /\r\n((CDNS_UART_BDIV_MAX + 1) * CDNS_UART_CD_MAX * 8);\r\nmaxbaud = port->uartclk / (CDNS_UART_BDIV_MIN + 1);\r\nbaud = uart_get_baud_rate(port, termios, old, minbaud, maxbaud);\r\nbaud = cdns_uart_set_baud_rate(port, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg |= CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg &= ~(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS);\r\nctrl_reg |= CDNS_UART_CR_TX_EN | CDNS_UART_CR_RX_EN;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nwritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\r\nport->read_status_mask = CDNS_UART_IXR_TXEMPTY | CDNS_UART_IXR_RXTRIG |\r\nCDNS_UART_IXR_OVERRUN | CDNS_UART_IXR_TOUT;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= CDNS_UART_IXR_PARITY |\r\nCDNS_UART_IXR_FRAMING;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= CDNS_UART_IXR_PARITY |\r\nCDNS_UART_IXR_FRAMING | CDNS_UART_IXR_OVERRUN;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= CDNS_UART_IXR_RXTRIG |\r\nCDNS_UART_IXR_TOUT | CDNS_UART_IXR_PARITY |\r\nCDNS_UART_IXR_FRAMING | CDNS_UART_IXR_OVERRUN;\r\nmode_reg = readl(port->membase + CDNS_UART_MR);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS6:\r\ncval |= CDNS_UART_MR_CHARLEN_6_BIT;\r\nbreak;\r\ncase CS7:\r\ncval |= CDNS_UART_MR_CHARLEN_7_BIT;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval |= CDNS_UART_MR_CHARLEN_8_BIT;\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= CDNS_UART_MR_STOPMODE_2_BIT;\r\nelse\r\ncval |= CDNS_UART_MR_STOPMODE_1_BIT;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\ncval |= CDNS_UART_MR_PARITY_MARK;\r\nelse\r\ncval |= CDNS_UART_MR_PARITY_SPACE;\r\n} else {\r\nif (termios->c_cflag & PARODD)\r\ncval |= CDNS_UART_MR_PARITY_ODD;\r\nelse\r\ncval |= CDNS_UART_MR_PARITY_EVEN;\r\n}\r\n} else {\r\ncval |= CDNS_UART_MR_PARITY_NONE;\r\n}\r\ncval |= mode_reg & 1;\r\nwritel(cval, port->membase + CDNS_UART_MR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int cdns_uart_startup(struct uart_port *port)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nunsigned int status = 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwritel(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS,\r\nport->membase + CDNS_UART_CR);\r\nwritel(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST,\r\nport->membase + CDNS_UART_CR);\r\nstatus = readl(port->membase + CDNS_UART_CR);\r\nstatus &= CDNS_UART_CR_RX_DIS;\r\nstatus |= CDNS_UART_CR_RX_EN;\r\nwritel(status, port->membase + CDNS_UART_CR);\r\nwritel(CDNS_UART_MR_CHMODE_NORM | CDNS_UART_MR_STOPMODE_1_BIT\r\n| CDNS_UART_MR_PARITY_NONE | CDNS_UART_MR_CHARLEN_8_BIT,\r\nport->membase + CDNS_UART_MR);\r\nwritel(rx_trigger_level, port->membase + CDNS_UART_RXWM);\r\nwritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\r\nwritel(readl(port->membase + CDNS_UART_ISR),\r\nport->membase + CDNS_UART_ISR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nret = request_irq(port->irq, cdns_uart_isr, 0, CDNS_UART_NAME, port);\r\nif (ret) {\r\ndev_err(port->dev, "request_irq '%d' failed with %d\n",\r\nport->irq, ret);\r\nreturn ret;\r\n}\r\nwritel(CDNS_UART_RX_IRQS, port->membase + CDNS_UART_IER);\r\nreturn 0;\r\n}\r\nstatic void cdns_uart_shutdown(struct uart_port *port)\r\n{\r\nint status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = readl(port->membase + CDNS_UART_IMR);\r\nwritel(status, port->membase + CDNS_UART_IDR);\r\nwritel(0xffffffff, port->membase + CDNS_UART_ISR);\r\nwritel(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS,\r\nport->membase + CDNS_UART_CR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic const char *cdns_uart_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_XUARTPS ? CDNS_UART_NAME : NULL;\r\n}\r\nstatic int cdns_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_XUARTPS)\r\nreturn -EINVAL;\r\nif (port->irq != ser->irq)\r\nreturn -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nreturn -EINVAL;\r\nif (port->iobase != ser->port)\r\nreturn -EINVAL;\r\nif (ser->hub6 != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cdns_uart_request_port(struct uart_port *port)\r\n{\r\nif (!request_mem_region(port->mapbase, CDNS_UART_REGISTER_SPACE,\r\nCDNS_UART_NAME)) {\r\nreturn -ENOMEM;\r\n}\r\nport->membase = ioremap(port->mapbase, CDNS_UART_REGISTER_SPACE);\r\nif (!port->membase) {\r\ndev_err(port->dev, "Unable to map registers\n");\r\nrelease_mem_region(port->mapbase, CDNS_UART_REGISTER_SPACE);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cdns_uart_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, CDNS_UART_REGISTER_SPACE);\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nstatic void cdns_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE && cdns_uart_request_port(port) == 0)\r\nport->type = PORT_XUARTPS;\r\n}\r\nstatic unsigned int cdns_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void cdns_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nu32 val;\r\nval = readl(port->membase + CDNS_UART_MODEMCR);\r\nval &= ~(CDNS_UART_MODEMCR_RTS | CDNS_UART_MODEMCR_DTR);\r\nif (mctrl & TIOCM_RTS)\r\nval |= CDNS_UART_MODEMCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nval |= CDNS_UART_MODEMCR_DTR;\r\nwritel(val, port->membase + CDNS_UART_MODEMCR);\r\n}\r\nstatic int cdns_uart_poll_get_char(struct uart_port *port)\r\n{\r\nint c;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_RXEMPTY)\r\nc = NO_POLL_CHAR;\r\nelse\r\nc = (unsigned char) readl(port->membase + CDNS_UART_FIFO);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn c;\r\n}\r\nstatic void cdns_uart_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (!(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_TXEMPTY))\r\ncpu_relax();\r\nwritel(c, port->membase + CDNS_UART_FIFO);\r\nwhile (!(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_TXEMPTY))\r\ncpu_relax();\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn;\r\n}\r\nstatic struct uart_port *cdns_uart_get_port(int id)\r\n{\r\nstruct uart_port *port;\r\nif (cdns_uart_port[id].mapbase != 0) {\r\nfor (id = 0; id < CDNS_UART_NR_PORTS; id++)\r\nif (cdns_uart_port[id].mapbase == 0)\r\nbreak;\r\n}\r\nif (id >= CDNS_UART_NR_PORTS)\r\nreturn NULL;\r\nport = &cdns_uart_port[id];\r\nspin_lock_init(&port->lock);\r\nport->membase = NULL;\r\nport->irq = 0;\r\nport->type = PORT_UNKNOWN;\r\nport->iotype = UPIO_MEM32;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &cdns_uart_ops;\r\nport->fifosize = CDNS_UART_FIFO_SIZE;\r\nport->line = id;\r\nport->dev = NULL;\r\nreturn port;\r\n}\r\nstatic void cdns_uart_console_wait_tx(struct uart_port *port)\r\n{\r\nwhile (!(readl(port->membase + CDNS_UART_SR) & CDNS_UART_SR_TXEMPTY))\r\nbarrier();\r\n}\r\nstatic void cdns_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\ncdns_uart_console_wait_tx(port);\r\nwritel(ch, port->membase + CDNS_UART_FIFO);\r\n}\r\nstatic void __init cdns_early_write(struct console *con, const char *s,\r\nunsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\nuart_console_write(&dev->port, s, n, cdns_uart_console_putchar);\r\n}\r\nstatic int __init cdns_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = cdns_early_write;\r\nreturn 0;\r\n}\r\nstatic void cdns_uart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &cdns_uart_port[co->index];\r\nunsigned long flags;\r\nunsigned int imr, ctrl;\r\nint locked = 1;\r\nif (port->sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nimr = readl(port->membase + CDNS_UART_IMR);\r\nwritel(imr, port->membase + CDNS_UART_IDR);\r\nctrl = readl(port->membase + CDNS_UART_CR);\r\nctrl &= ~CDNS_UART_CR_TX_DIS;\r\nctrl |= CDNS_UART_CR_TX_EN;\r\nwritel(ctrl, port->membase + CDNS_UART_CR);\r\nuart_console_write(port, s, count, cdns_uart_console_putchar);\r\ncdns_uart_console_wait_tx(port);\r\nwritel(ctrl, port->membase + CDNS_UART_CR);\r\nwritel(imr, port->membase + CDNS_UART_IER);\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int __init cdns_uart_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port = &cdns_uart_port[co->index];\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= CDNS_UART_NR_PORTS)\r\nreturn -EINVAL;\r\nif (!port->membase) {\r\npr_debug("console on " CDNS_UART_TTY_NAME "%i not present\n",\r\nco->index);\r\nreturn -ENODEV;\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init cdns_uart_console_init(void)\r\n{\r\nregister_console(&cdns_uart_console);\r\nreturn 0;\r\n}\r\nstatic int cdns_uart_suspend(struct device *device)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(device);\r\nstruct tty_struct *tty;\r\nstruct device *tty_dev;\r\nint may_wake = 0;\r\ntty = tty_port_tty_get(&port->state->port);\r\nif (tty) {\r\ntty_dev = tty->dev;\r\nmay_wake = device_may_wakeup(tty_dev);\r\ntty_kref_put(tty);\r\n}\r\nuart_suspend_port(&cdns_uart_uart_driver, port);\r\nif (console_suspend_enabled && !may_wake) {\r\nstruct cdns_uart *cdns_uart = port->private_data;\r\nclk_disable(cdns_uart->uartclk);\r\nclk_disable(cdns_uart->pclk);\r\n} else {\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (!(readl(port->membase + CDNS_UART_SR) &\r\nCDNS_UART_SR_RXEMPTY))\r\nreadl(port->membase + CDNS_UART_FIFO);\r\nwritel(1, port->membase + CDNS_UART_RXWM);\r\nwritel(CDNS_UART_IXR_TOUT, port->membase + CDNS_UART_IDR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdns_uart_resume(struct device *device)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(device);\r\nunsigned long flags = 0;\r\nu32 ctrl_reg;\r\nstruct tty_struct *tty;\r\nstruct device *tty_dev;\r\nint may_wake = 0;\r\ntty = tty_port_tty_get(&port->state->port);\r\nif (tty) {\r\ntty_dev = tty->dev;\r\nmay_wake = device_may_wakeup(tty_dev);\r\ntty_kref_put(tty);\r\n}\r\nif (console_suspend_enabled && !may_wake) {\r\nstruct cdns_uart *cdns_uart = port->private_data;\r\nclk_enable(cdns_uart->pclk);\r\nclk_enable(cdns_uart->uartclk);\r\nspin_lock_irqsave(&port->lock, flags);\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg |= CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nwhile (readl(port->membase + CDNS_UART_CR) &\r\n(CDNS_UART_CR_TXRST | CDNS_UART_CR_RXRST))\r\ncpu_relax();\r\nwritel(rx_timeout, port->membase + CDNS_UART_RXTOUT);\r\nctrl_reg = readl(port->membase + CDNS_UART_CR);\r\nctrl_reg &= ~(CDNS_UART_CR_TX_DIS | CDNS_UART_CR_RX_DIS);\r\nctrl_reg |= CDNS_UART_CR_TX_EN | CDNS_UART_CR_RX_EN;\r\nwritel(ctrl_reg, port->membase + CDNS_UART_CR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n} else {\r\nspin_lock_irqsave(&port->lock, flags);\r\nwritel(rx_trigger_level, port->membase + CDNS_UART_RXWM);\r\nwritel(CDNS_UART_IXR_TOUT, port->membase + CDNS_UART_IER);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nreturn uart_resume_port(&cdns_uart_uart_driver, port);\r\n}\r\nstatic int cdns_uart_probe(struct platform_device *pdev)\r\n{\r\nint rc, id, irq;\r\nstruct uart_port *port;\r\nstruct resource *res;\r\nstruct cdns_uart *cdns_uart_data;\r\ncdns_uart_data = devm_kzalloc(&pdev->dev, sizeof(*cdns_uart_data),\r\nGFP_KERNEL);\r\nif (!cdns_uart_data)\r\nreturn -ENOMEM;\r\ncdns_uart_data->pclk = devm_clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(cdns_uart_data->pclk)) {\r\ncdns_uart_data->pclk = devm_clk_get(&pdev->dev, "aper_clk");\r\nif (!IS_ERR(cdns_uart_data->pclk))\r\ndev_err(&pdev->dev, "clock name 'aper_clk' is deprecated.\n");\r\n}\r\nif (IS_ERR(cdns_uart_data->pclk)) {\r\ndev_err(&pdev->dev, "pclk clock not found.\n");\r\nreturn PTR_ERR(cdns_uart_data->pclk);\r\n}\r\ncdns_uart_data->uartclk = devm_clk_get(&pdev->dev, "uart_clk");\r\nif (IS_ERR(cdns_uart_data->uartclk)) {\r\ncdns_uart_data->uartclk = devm_clk_get(&pdev->dev, "ref_clk");\r\nif (!IS_ERR(cdns_uart_data->uartclk))\r\ndev_err(&pdev->dev, "clock name 'ref_clk' is deprecated.\n");\r\n}\r\nif (IS_ERR(cdns_uart_data->uartclk)) {\r\ndev_err(&pdev->dev, "uart_clk clock not found.\n");\r\nreturn PTR_ERR(cdns_uart_data->uartclk);\r\n}\r\nrc = clk_prepare_enable(cdns_uart_data->pclk);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Unable to enable pclk clock.\n");\r\nreturn rc;\r\n}\r\nrc = clk_prepare_enable(cdns_uart_data->uartclk);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Unable to enable device clock.\n");\r\ngoto err_out_clk_dis_pclk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nrc = -ENODEV;\r\ngoto err_out_clk_disable;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\nrc = -ENXIO;\r\ngoto err_out_clk_disable;\r\n}\r\n#ifdef CONFIG_COMMON_CLK\r\ncdns_uart_data->clk_rate_change_nb.notifier_call =\r\ncdns_uart_clk_notifier_cb;\r\nif (clk_notifier_register(cdns_uart_data->uartclk,\r\n&cdns_uart_data->clk_rate_change_nb))\r\ndev_warn(&pdev->dev, "Unable to register clock notifier.\n");\r\n#endif\r\nid = of_alias_get_id(pdev->dev.of_node, "serial");\r\nif (id < 0)\r\nid = 0;\r\nport = cdns_uart_get_port(id);\r\nif (!port) {\r\ndev_err(&pdev->dev, "Cannot get uart_port structure\n");\r\nrc = -ENODEV;\r\ngoto err_out_notif_unreg;\r\n}\r\nport->mapbase = res->start;\r\nport->irq = irq;\r\nport->dev = &pdev->dev;\r\nport->uartclk = clk_get_rate(cdns_uart_data->uartclk);\r\nport->private_data = cdns_uart_data;\r\ncdns_uart_data->port = port;\r\nplatform_set_drvdata(pdev, port);\r\nrc = uart_add_one_port(&cdns_uart_uart_driver, port);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"uart_add_one_port() failed; err=%i\n", rc);\r\ngoto err_out_notif_unreg;\r\n}\r\nreturn 0;\r\nerr_out_notif_unreg:\r\n#ifdef CONFIG_COMMON_CLK\r\nclk_notifier_unregister(cdns_uart_data->uartclk,\r\n&cdns_uart_data->clk_rate_change_nb);\r\n#endif\r\nerr_out_clk_disable:\r\nclk_disable_unprepare(cdns_uart_data->uartclk);\r\nerr_out_clk_dis_pclk:\r\nclk_disable_unprepare(cdns_uart_data->pclk);\r\nreturn rc;\r\n}\r\nstatic int cdns_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct cdns_uart *cdns_uart_data = port->private_data;\r\nint rc;\r\n#ifdef CONFIG_COMMON_CLK\r\nclk_notifier_unregister(cdns_uart_data->uartclk,\r\n&cdns_uart_data->clk_rate_change_nb);\r\n#endif\r\nrc = uart_remove_one_port(&cdns_uart_uart_driver, port);\r\nport->mapbase = 0;\r\nclk_disable_unprepare(cdns_uart_data->uartclk);\r\nclk_disable_unprepare(cdns_uart_data->pclk);\r\nreturn rc;\r\n}\r\nstatic int __init cdns_uart_init(void)\r\n{\r\nint retval = 0;\r\nretval = uart_register_driver(&cdns_uart_uart_driver);\r\nif (retval)\r\nreturn retval;\r\nretval = platform_driver_register(&cdns_uart_platform_driver);\r\nif (retval)\r\nuart_unregister_driver(&cdns_uart_uart_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit cdns_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&cdns_uart_platform_driver);\r\nuart_unregister_driver(&cdns_uart_uart_driver);\r\n}
