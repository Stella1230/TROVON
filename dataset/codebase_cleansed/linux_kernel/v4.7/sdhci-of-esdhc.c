static u32 esdhc_readl_fixup(struct sdhci_host *host,\r\nint spec_reg, u32 value)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\r\nu32 ret;\r\nif ((spec_reg == SDHCI_CAPABILITIES) && (value & SDHCI_CAN_DO_ADMA1)) {\r\nif (esdhc->vendor_ver > VENDOR_V_22) {\r\nret = value | SDHCI_CAN_DO_ADMA2;\r\nreturn ret;\r\n}\r\n}\r\nret = value;\r\nreturn ret;\r\n}\r\nstatic u16 esdhc_readw_fixup(struct sdhci_host *host,\r\nint spec_reg, u32 value)\r\n{\r\nu16 ret;\r\nint shift = (spec_reg & 0x2) * 8;\r\nif (spec_reg == SDHCI_HOST_VERSION)\r\nret = value & 0xffff;\r\nelse\r\nret = (value >> shift) & 0xffff;\r\nreturn ret;\r\n}\r\nstatic u8 esdhc_readb_fixup(struct sdhci_host *host,\r\nint spec_reg, u32 value)\r\n{\r\nu8 ret;\r\nu8 dma_bits;\r\nint shift = (spec_reg & 0x3) * 8;\r\nret = (value >> shift) & 0xff;\r\nif (spec_reg == SDHCI_HOST_CONTROL) {\r\ndma_bits = (value >> 5) & SDHCI_CTRL_DMA_MASK;\r\nret &= ~SDHCI_CTRL_DMA_MASK;\r\nret |= dma_bits;\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 esdhc_writel_fixup(struct sdhci_host *host,\r\nint spec_reg, u32 value, u32 old_value)\r\n{\r\nu32 ret;\r\nif (spec_reg == SDHCI_INT_ENABLE)\r\nret = value | SDHCI_INT_BLK_GAP;\r\nelse\r\nret = value;\r\nreturn ret;\r\n}\r\nstatic u32 esdhc_writew_fixup(struct sdhci_host *host,\r\nint spec_reg, u16 value, u32 old_value)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nint shift = (spec_reg & 0x2) * 8;\r\nu32 ret;\r\nswitch (spec_reg) {\r\ncase SDHCI_TRANSFER_MODE:\r\npltfm_host->xfer_mode_shadow = value;\r\nreturn old_value;\r\ncase SDHCI_COMMAND:\r\nret = (value << 16) | pltfm_host->xfer_mode_shadow;\r\nreturn ret;\r\n}\r\nret = old_value & (~(0xffff << shift));\r\nret |= (value << shift);\r\nif (spec_reg == SDHCI_BLOCK_SIZE) {\r\nret &= (~SDHCI_MAKE_BLKSZ(0x7, 0));\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 esdhc_writeb_fixup(struct sdhci_host *host,\r\nint spec_reg, u8 value, u32 old_value)\r\n{\r\nu32 ret;\r\nu32 dma_bits;\r\nu8 tmp;\r\nint shift = (spec_reg & 0x3) * 8;\r\nif (spec_reg == SDHCI_POWER_CONTROL)\r\nreturn old_value;\r\nif (spec_reg == SDHCI_HOST_CONTROL) {\r\nif (host->quirks2 & SDHCI_QUIRK2_BROKEN_HOST_CONTROL)\r\nreturn old_value;\r\ndma_bits = (value & SDHCI_CTRL_DMA_MASK) << 5;\r\nret = (old_value & (~(SDHCI_CTRL_DMA_MASK << 5))) | dma_bits;\r\ntmp = (value & (~SDHCI_CTRL_DMA_MASK)) |\r\n(old_value & SDHCI_CTRL_DMA_MASK);\r\nret = (ret & (~0xff)) | tmp;\r\nret &= ~ESDHC_HOST_CONTROL_RES;\r\nreturn ret;\r\n}\r\nret = (old_value & (~(0xff << shift))) | (value << shift);\r\nreturn ret;\r\n}\r\nstatic u32 esdhc_be_readl(struct sdhci_host *host, int reg)\r\n{\r\nu32 ret;\r\nu32 value;\r\nvalue = ioread32be(host->ioaddr + reg);\r\nret = esdhc_readl_fixup(host, reg, value);\r\nreturn ret;\r\n}\r\nstatic u32 esdhc_le_readl(struct sdhci_host *host, int reg)\r\n{\r\nu32 ret;\r\nu32 value;\r\nvalue = ioread32(host->ioaddr + reg);\r\nret = esdhc_readl_fixup(host, reg, value);\r\nreturn ret;\r\n}\r\nstatic u16 esdhc_be_readw(struct sdhci_host *host, int reg)\r\n{\r\nu16 ret;\r\nu32 value;\r\nint base = reg & ~0x3;\r\nvalue = ioread32be(host->ioaddr + base);\r\nret = esdhc_readw_fixup(host, reg, value);\r\nreturn ret;\r\n}\r\nstatic u16 esdhc_le_readw(struct sdhci_host *host, int reg)\r\n{\r\nu16 ret;\r\nu32 value;\r\nint base = reg & ~0x3;\r\nvalue = ioread32(host->ioaddr + base);\r\nret = esdhc_readw_fixup(host, reg, value);\r\nreturn ret;\r\n}\r\nstatic u8 esdhc_be_readb(struct sdhci_host *host, int reg)\r\n{\r\nu8 ret;\r\nu32 value;\r\nint base = reg & ~0x3;\r\nvalue = ioread32be(host->ioaddr + base);\r\nret = esdhc_readb_fixup(host, reg, value);\r\nreturn ret;\r\n}\r\nstatic u8 esdhc_le_readb(struct sdhci_host *host, int reg)\r\n{\r\nu8 ret;\r\nu32 value;\r\nint base = reg & ~0x3;\r\nvalue = ioread32(host->ioaddr + base);\r\nret = esdhc_readb_fixup(host, reg, value);\r\nreturn ret;\r\n}\r\nstatic void esdhc_be_writel(struct sdhci_host *host, u32 val, int reg)\r\n{\r\nu32 value;\r\nvalue = esdhc_writel_fixup(host, reg, val, 0);\r\niowrite32be(value, host->ioaddr + reg);\r\n}\r\nstatic void esdhc_le_writel(struct sdhci_host *host, u32 val, int reg)\r\n{\r\nu32 value;\r\nvalue = esdhc_writel_fixup(host, reg, val, 0);\r\niowrite32(value, host->ioaddr + reg);\r\n}\r\nstatic void esdhc_be_writew(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nint base = reg & ~0x3;\r\nu32 value;\r\nu32 ret;\r\nvalue = ioread32be(host->ioaddr + base);\r\nret = esdhc_writew_fixup(host, reg, val, value);\r\nif (reg != SDHCI_TRANSFER_MODE)\r\niowrite32be(ret, host->ioaddr + base);\r\n}\r\nstatic void esdhc_le_writew(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nint base = reg & ~0x3;\r\nu32 value;\r\nu32 ret;\r\nvalue = ioread32(host->ioaddr + base);\r\nret = esdhc_writew_fixup(host, reg, val, value);\r\nif (reg != SDHCI_TRANSFER_MODE)\r\niowrite32(ret, host->ioaddr + base);\r\n}\r\nstatic void esdhc_be_writeb(struct sdhci_host *host, u8 val, int reg)\r\n{\r\nint base = reg & ~0x3;\r\nu32 value;\r\nu32 ret;\r\nvalue = ioread32be(host->ioaddr + base);\r\nret = esdhc_writeb_fixup(host, reg, val, value);\r\niowrite32be(ret, host->ioaddr + base);\r\n}\r\nstatic void esdhc_le_writeb(struct sdhci_host *host, u8 val, int reg)\r\n{\r\nint base = reg & ~0x3;\r\nu32 value;\r\nu32 ret;\r\nvalue = ioread32(host->ioaddr + base);\r\nret = esdhc_writeb_fixup(host, reg, val, value);\r\niowrite32(ret, host->ioaddr + base);\r\n}\r\nstatic void esdhc_of_adma_workaround(struct sdhci_host *host, u32 intmask)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\r\nbool applicable;\r\ndma_addr_t dmastart;\r\ndma_addr_t dmanow;\r\napplicable = (intmask & SDHCI_INT_DATA_END) &&\r\n(intmask & SDHCI_INT_BLK_GAP) &&\r\n(esdhc->vendor_ver == VENDOR_V_23);\r\nif (!applicable)\r\nreturn;\r\nhost->data->error = 0;\r\ndmastart = sg_dma_address(host->data->sg);\r\ndmanow = dmastart + host->data->bytes_xfered;\r\ndmanow = (dmanow & ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1)) +\r\nSDHCI_DEFAULT_BOUNDARY_SIZE;\r\nhost->data->bytes_xfered = dmanow - dmastart;\r\nsdhci_writel(host, dmanow, SDHCI_DMA_ADDRESS);\r\n}\r\nstatic int esdhc_of_enable_dma(struct sdhci_host *host)\r\n{\r\nu32 value;\r\nvalue = sdhci_readl(host, ESDHC_DMA_SYSCTL);\r\nvalue |= ESDHC_DMA_SNOOP;\r\nsdhci_writel(host, value, ESDHC_DMA_SYSCTL);\r\nreturn 0;\r\n}\r\nstatic unsigned int esdhc_of_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn pltfm_host->clock;\r\n}\r\nstatic unsigned int esdhc_of_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn pltfm_host->clock / 256 / 16;\r\n}\r\nstatic void esdhc_of_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\r\nint pre_div = 1;\r\nint div = 1;\r\nu32 temp;\r\nhost->mmc->actual_clock = 0;\r\nif (clock == 0)\r\nreturn;\r\nif (esdhc->vendor_ver < VENDOR_V_23)\r\npre_div = 2;\r\nif (of_find_compatible_node(NULL, NULL, "fsl,p1010-esdhc")) {\r\nif (clock > 20000000)\r\nclock -= 5000000;\r\nif (clock > 40000000)\r\nclock -= 5000000;\r\n}\r\ntemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\r\ntemp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\r\n| ESDHC_CLOCK_MASK);\r\nsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\r\nwhile (host->max_clk / pre_div / 16 > clock && pre_div < 256)\r\npre_div *= 2;\r\nwhile (host->max_clk / pre_div / div > clock && div < 16)\r\ndiv++;\r\ndev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",\r\nclock, host->max_clk / pre_div / div);\r\nhost->mmc->actual_clock = host->max_clk / pre_div / div;\r\npre_div >>= 1;\r\ndiv--;\r\ntemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\r\ntemp |= (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\r\n| (div << ESDHC_DIVIDER_SHIFT)\r\n| (pre_div << ESDHC_PREDIV_SHIFT));\r\nsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\r\nmdelay(1);\r\n}\r\nstatic void esdhc_pltfm_set_bus_width(struct sdhci_host *host, int width)\r\n{\r\nu32 ctrl;\r\nctrl = sdhci_readl(host, ESDHC_PROCTL);\r\nctrl &= (~ESDHC_CTRL_BUSWIDTH_MASK);\r\nswitch (width) {\r\ncase MMC_BUS_WIDTH_8:\r\nctrl |= ESDHC_CTRL_8BITBUS;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nctrl |= ESDHC_CTRL_4BITBUS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsdhci_writel(host, ctrl, ESDHC_PROCTL);\r\n}\r\nstatic void esdhc_reset(struct sdhci_host *host, u8 mask)\r\n{\r\nsdhci_reset(host, mask);\r\nsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\r\nsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\r\n}\r\nstatic int esdhc_of_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nesdhc_proctl = sdhci_readl(host, SDHCI_HOST_CONTROL);\r\nreturn sdhci_suspend_host(host);\r\n}\r\nstatic int esdhc_of_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nint ret = sdhci_resume_host(host);\r\nif (ret == 0) {\r\nesdhc_of_enable_dma(host);\r\nsdhci_writel(host, esdhc_proctl, SDHCI_HOST_CONTROL);\r\n}\r\nreturn ret;\r\n}\r\nstatic void esdhc_init(struct platform_device *pdev, struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_esdhc *esdhc;\r\nu16 host_ver;\r\npltfm_host = sdhci_priv(host);\r\nesdhc = sdhci_pltfm_priv(pltfm_host);\r\nhost_ver = sdhci_readw(host, SDHCI_HOST_VERSION);\r\nesdhc->vendor_ver = (host_ver & SDHCI_VENDOR_VER_MASK) >>\r\nSDHCI_VENDOR_VER_SHIFT;\r\nesdhc->spec_ver = host_ver & SDHCI_SPEC_VER_MASK;\r\n}\r\nstatic int sdhci_esdhc_probe(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host;\r\nstruct device_node *np;\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_esdhc *esdhc;\r\nint ret;\r\nnp = pdev->dev.of_node;\r\nif (of_get_property(np, "little-endian", NULL))\r\nhost = sdhci_pltfm_init(pdev, &sdhci_esdhc_le_pdata,\r\nsizeof(struct sdhci_esdhc));\r\nelse\r\nhost = sdhci_pltfm_init(pdev, &sdhci_esdhc_be_pdata,\r\nsizeof(struct sdhci_esdhc));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\nesdhc_init(pdev, host);\r\nsdhci_get_of_property(pdev);\r\npltfm_host = sdhci_priv(host);\r\nesdhc = sdhci_pltfm_priv(pltfm_host);\r\nif (esdhc->vendor_ver == VENDOR_V_22)\r\nhost->quirks2 |= SDHCI_QUIRK2_HOST_NO_CMD23;\r\nif (esdhc->vendor_ver > VENDOR_V_22)\r\nhost->quirks &= ~SDHCI_QUIRK_NO_BUSY_IRQ;\r\nif (of_device_is_compatible(np, "fsl,p5040-esdhc") ||\r\nof_device_is_compatible(np, "fsl,p5020-esdhc") ||\r\nof_device_is_compatible(np, "fsl,p4080-esdhc") ||\r\nof_device_is_compatible(np, "fsl,p1020-esdhc") ||\r\nof_device_is_compatible(np, "fsl,t1040-esdhc") ||\r\nof_device_is_compatible(np, "fsl,ls1021a-esdhc"))\r\nhost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nif (of_device_is_compatible(np, "fsl,ls1021a-esdhc"))\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;\r\nif (of_device_is_compatible(np, "fsl,p2020-esdhc")) {\r\nhost->quirks2 |= SDHCI_QUIRK2_BROKEN_HOST_CONTROL;\r\n}\r\nret = mmc_of_parse(host->mmc);\r\nif (ret)\r\ngoto err;\r\nmmc_of_parse_voltage(np, &host->ocr_mask);\r\nret = sdhci_add_host(host);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nsdhci_pltfm_free(pdev);\r\nreturn ret;\r\n}
