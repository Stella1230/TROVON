void __init MMU_init_hw(void)\r\n{\r\n}\r\nunsigned long __init mmu_mapin_ram(unsigned long top)\r\n{\r\nunsigned long v, s, mapped;\r\nphys_addr_t p;\r\nv = KERNELBASE;\r\np = 0;\r\ns = top;\r\nif (__map_without_ltlbs)\r\nreturn 0;\r\n#ifdef CONFIG_PPC_4K_PAGES\r\nwhile (s >= LARGE_PAGE_SIZE_8M) {\r\npmd_t *pmdp;\r\nunsigned long val = p | MD_PS8MEG;\r\npmdp = pmd_offset(pud_offset(pgd_offset_k(v), v), v);\r\n*pmdp++ = __pmd(val);\r\n*pmdp++ = __pmd(val + LARGE_PAGE_SIZE_4M);\r\nv += LARGE_PAGE_SIZE_8M;\r\np += LARGE_PAGE_SIZE_8M;\r\ns -= LARGE_PAGE_SIZE_8M;\r\n}\r\n#else\r\nwhile (s >= LARGE_PAGE_SIZE_64M) {\r\npmd_t *pmdp;\r\nunsigned long val = p | MD_PS8MEG;\r\npmdp = pmd_offset(pud_offset(pgd_offset_k(v), v), v);\r\n*pmdp++ = __pmd(val);\r\nv += LARGE_PAGE_SIZE_64M;\r\np += LARGE_PAGE_SIZE_64M;\r\ns -= LARGE_PAGE_SIZE_64M;\r\n}\r\n#endif\r\nmapped = top - s;\r\nmemblock_set_current_limit(mapped);\r\nreturn mapped;\r\n}\r\nvoid setup_initial_memory_limit(phys_addr_t first_memblock_base,\r\nphys_addr_t first_memblock_size)\r\n{\r\nBUG_ON(first_memblock_base != 0);\r\n#ifdef CONFIG_PIN_TLB\r\nmemblock_set_current_limit(min_t(u64, first_memblock_size, 0x01800000));\r\n#else\r\nmemblock_set_current_limit(min_t(u64, first_memblock_size, 0x00800000));\r\n#endif\r\n}\r\nvoid set_context(unsigned long id, pgd_t *pgd)\r\n{\r\ns16 offset = (s16)(__pa(swapper_pg_dir));\r\n#ifdef CONFIG_BDI_SWITCH\r\npgd_t **ptr = *(pgd_t ***)(KERNELBASE + 0xf0);\r\n*(ptr + 1) = pgd;\r\n#endif\r\nmtspr(SPRN_M_TW, __pa(pgd) - offset);\r\nmtspr(SPRN_M_CASID, id);\r\nmb();\r\n}\r\nvoid flush_instruction_cache(void)\r\n{\r\nisync();\r\nmtspr(SPRN_IC_CST, IDC_INVALL);\r\nisync();\r\n}
