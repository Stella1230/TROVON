static inline int status_reg(struct pi_adapter *pi)\r\n{\r\nreturn pi_read_regr(pi, 1, 6);\r\n}\r\nstatic inline int read_reg(struct pi_adapter *pi, int reg)\r\n{\r\nreturn pi_read_regr(pi, 0, reg);\r\n}\r\nstatic inline void write_reg(struct pi_adapter *pi, int reg, int val)\r\n{\r\npi_write_regr(pi, 0, reg, val);\r\n}\r\nstatic inline u8 DRIVE(struct pt_unit *tape)\r\n{\r\nreturn 0xa0+0x10*tape->drive;\r\n}\r\nstatic int pt_wait(struct pt_unit *tape, int go, int stop, char *fun, char *msg)\r\n{\r\nint j, r, e, s, p;\r\nstruct pi_adapter *pi = tape->pi;\r\nj = 0;\r\nwhile ((((r = status_reg(pi)) & go) || (stop && (!(r & stop))))\r\n&& (j++ < PT_SPIN))\r\nudelay(PT_SPIN_DEL);\r\nif ((r & (STAT_ERR & stop)) || (j > PT_SPIN)) {\r\ns = read_reg(pi, 7);\r\ne = read_reg(pi, 1);\r\np = read_reg(pi, 2);\r\nif (j > PT_SPIN)\r\ne |= 0x100;\r\nif (fun)\r\nprintk("%s: %s %s: alt=0x%x stat=0x%x err=0x%x"\r\n" loop=%d phase=%d\n",\r\ntape->name, fun, msg, r, s, e, j, p);\r\nreturn (e << 8) + s;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pt_command(struct pt_unit *tape, char *cmd, int dlen, char *fun)\r\n{\r\nstruct pi_adapter *pi = tape->pi;\r\npi_connect(pi);\r\nwrite_reg(pi, 6, DRIVE(tape));\r\nif (pt_wait(tape, STAT_BUSY | STAT_DRQ, 0, fun, "before command")) {\r\npi_disconnect(pi);\r\nreturn -1;\r\n}\r\nwrite_reg(pi, 4, dlen % 256);\r\nwrite_reg(pi, 5, dlen / 256);\r\nwrite_reg(pi, 7, 0xa0);\r\nif (pt_wait(tape, STAT_BUSY, STAT_DRQ, fun, "command DRQ")) {\r\npi_disconnect(pi);\r\nreturn -1;\r\n}\r\nif (read_reg(pi, 2) != 1) {\r\nprintk("%s: %s: command phase error\n", tape->name, fun);\r\npi_disconnect(pi);\r\nreturn -1;\r\n}\r\npi_write_block(pi, cmd, 12);\r\nreturn 0;\r\n}\r\nstatic int pt_completion(struct pt_unit *tape, char *buf, char *fun)\r\n{\r\nstruct pi_adapter *pi = tape->pi;\r\nint r, s, n, p;\r\nr = pt_wait(tape, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,\r\nfun, "completion");\r\nif (read_reg(pi, 7) & STAT_DRQ) {\r\nn = (((read_reg(pi, 4) + 256 * read_reg(pi, 5)) +\r\n3) & 0xfffc);\r\np = read_reg(pi, 2) & 3;\r\nif (p == 0)\r\npi_write_block(pi, buf, n);\r\nif (p == 2)\r\npi_read_block(pi, buf, n);\r\n}\r\ns = pt_wait(tape, STAT_BUSY, STAT_READY | STAT_ERR, fun, "data done");\r\npi_disconnect(pi);\r\nreturn (r ? r : s);\r\n}\r\nstatic void pt_req_sense(struct pt_unit *tape, int quiet)\r\n{\r\nchar rs_cmd[12] = { ATAPI_REQ_SENSE, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\r\nchar buf[16];\r\nint r;\r\nr = pt_command(tape, rs_cmd, 16, "Request sense");\r\nmdelay(1);\r\nif (!r)\r\npt_completion(tape, buf, "Request sense");\r\ntape->last_sense = -1;\r\nif (!r) {\r\nif (!quiet)\r\nprintk("%s: Sense key: %x, ASC: %x, ASQ: %x\n",\r\ntape->name, buf[2] & 0xf, buf[12], buf[13]);\r\ntape->last_sense = (buf[2] & 0xf) | ((buf[12] & 0xff) << 8)\r\n| ((buf[13] & 0xff) << 16);\r\n}\r\n}\r\nstatic int pt_atapi(struct pt_unit *tape, char *cmd, int dlen, char *buf, char *fun)\r\n{\r\nint r;\r\nr = pt_command(tape, cmd, dlen, fun);\r\nmdelay(1);\r\nif (!r)\r\nr = pt_completion(tape, buf, fun);\r\nif (r)\r\npt_req_sense(tape, !fun);\r\nreturn r;\r\n}\r\nstatic void pt_sleep(int cs)\r\n{\r\nschedule_timeout_interruptible(cs);\r\n}\r\nstatic int pt_poll_dsc(struct pt_unit *tape, int pause, int tmo, char *msg)\r\n{\r\nstruct pi_adapter *pi = tape->pi;\r\nint k, e, s;\r\nk = 0;\r\ne = 0;\r\ns = 0;\r\nwhile (k < tmo) {\r\npt_sleep(pause);\r\nk++;\r\npi_connect(pi);\r\nwrite_reg(pi, 6, DRIVE(tape));\r\ns = read_reg(pi, 7);\r\ne = read_reg(pi, 1);\r\npi_disconnect(pi);\r\nif (s & (STAT_ERR | STAT_SEEK))\r\nbreak;\r\n}\r\nif ((k >= tmo) || (s & STAT_ERR)) {\r\nif (k >= tmo)\r\nprintk("%s: %s DSC timeout\n", tape->name, msg);\r\nelse\r\nprintk("%s: %s stat=0x%x err=0x%x\n", tape->name, msg, s,\r\ne);\r\npt_req_sense(tape, 0);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void pt_media_access_cmd(struct pt_unit *tape, int tmo, char *cmd, char *fun)\r\n{\r\nif (pt_command(tape, cmd, 0, fun)) {\r\npt_req_sense(tape, 0);\r\nreturn;\r\n}\r\npi_disconnect(tape->pi);\r\npt_poll_dsc(tape, HZ, tmo, fun);\r\n}\r\nstatic void pt_rewind(struct pt_unit *tape)\r\n{\r\nchar rw_cmd[12] = { ATAPI_REWIND, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\npt_media_access_cmd(tape, PT_REWIND_TMO, rw_cmd, "rewind");\r\n}\r\nstatic void pt_write_fm(struct pt_unit *tape)\r\n{\r\nchar wm_cmd[12] = { ATAPI_WFM, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };\r\npt_media_access_cmd(tape, PT_TMO, wm_cmd, "write filemark");\r\n}\r\nstatic int pt_reset(struct pt_unit *tape)\r\n{\r\nstruct pi_adapter *pi = tape->pi;\r\nint i, k, flg;\r\nint expect[5] = { 1, 1, 1, 0x14, 0xeb };\r\npi_connect(pi);\r\nwrite_reg(pi, 6, DRIVE(tape));\r\nwrite_reg(pi, 7, 8);\r\npt_sleep(20 * HZ / 1000);\r\nk = 0;\r\nwhile ((k++ < PT_RESET_TMO) && (status_reg(pi) & STAT_BUSY))\r\npt_sleep(HZ / 10);\r\nflg = 1;\r\nfor (i = 0; i < 5; i++)\r\nflg &= (read_reg(pi, i + 1) == expect[i]);\r\nif (verbose) {\r\nprintk("%s: Reset (%d) signature = ", tape->name, k);\r\nfor (i = 0; i < 5; i++)\r\nprintk("%3x", read_reg(pi, i + 1));\r\nif (!flg)\r\nprintk(" (incorrect)");\r\nprintk("\n");\r\n}\r\npi_disconnect(pi);\r\nreturn flg - 1;\r\n}\r\nstatic int pt_ready_wait(struct pt_unit *tape, int tmo)\r\n{\r\nchar tr_cmd[12] = { ATAPI_TEST_READY, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nint k, p;\r\nk = 0;\r\nwhile (k < tmo) {\r\ntape->last_sense = 0;\r\npt_atapi(tape, tr_cmd, 0, NULL, DBMSG("test unit ready"));\r\np = tape->last_sense;\r\nif (!p)\r\nreturn 0;\r\nif (!(((p & 0xffff) == 0x0402) || ((p & 0xff) == 6)))\r\nreturn p;\r\nk++;\r\npt_sleep(HZ);\r\n}\r\nreturn 0x000020;\r\n}\r\nstatic void xs(char *buf, char *targ, int offs, int len)\r\n{\r\nint j, k, l;\r\nj = 0;\r\nl = 0;\r\nfor (k = 0; k < len; k++)\r\nif ((buf[k + offs] != 0x20) || (buf[k + offs] != l))\r\nl = targ[j++] = buf[k + offs];\r\nif (l == 0x20)\r\nj--;\r\ntarg[j] = 0;\r\n}\r\nstatic int xn(char *buf, int offs, int size)\r\n{\r\nint v, k;\r\nv = 0;\r\nfor (k = 0; k < size; k++)\r\nv = v * 256 + (buf[k + offs] & 0xff);\r\nreturn v;\r\n}\r\nstatic int pt_identify(struct pt_unit *tape)\r\n{\r\nint dt, s;\r\nchar *ms[2] = { "master", "slave" };\r\nchar mf[10], id[18];\r\nchar id_cmd[12] = { ATAPI_IDENTIFY, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\r\nchar ms_cmd[12] =\r\n{ ATAPI_MODE_SENSE, 0, 0x2a, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\r\nchar ls_cmd[12] =\r\n{ ATAPI_LOG_SENSE, 0, 0x71, 0, 0, 0, 0, 0, 36, 0, 0, 0 };\r\nchar buf[36];\r\ns = pt_atapi(tape, id_cmd, 36, buf, "identify");\r\nif (s)\r\nreturn -1;\r\ndt = buf[0] & 0x1f;\r\nif (dt != 1) {\r\nif (verbose)\r\nprintk("%s: Drive %d, unsupported type %d\n",\r\ntape->name, tape->drive, dt);\r\nreturn -1;\r\n}\r\nxs(buf, mf, 8, 8);\r\nxs(buf, id, 16, 16);\r\ntape->flags = 0;\r\ntape->capacity = 0;\r\ntape->bs = 0;\r\nif (!pt_ready_wait(tape, PT_READY_TMO))\r\ntape->flags |= PT_MEDIA;\r\nif (!pt_atapi(tape, ms_cmd, 36, buf, "mode sense")) {\r\nif (!(buf[2] & 0x80))\r\ntape->flags |= PT_WRITE_OK;\r\ntape->bs = xn(buf, 10, 2);\r\n}\r\nif (!pt_atapi(tape, ls_cmd, 36, buf, "log sense"))\r\ntape->capacity = xn(buf, 24, 4);\r\nprintk("%s: %s %s, %s", tape->name, mf, id, ms[tape->drive]);\r\nif (!(tape->flags & PT_MEDIA))\r\nprintk(", no media\n");\r\nelse {\r\nif (!(tape->flags & PT_WRITE_OK))\r\nprintk(", RO");\r\nprintk(", blocksize %d, %d MB\n", tape->bs, tape->capacity / 1024);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pt_probe(struct pt_unit *tape)\r\n{\r\nif (tape->drive == -1) {\r\nfor (tape->drive = 0; tape->drive <= 1; tape->drive++)\r\nif (!pt_reset(tape))\r\nreturn pt_identify(tape);\r\n} else {\r\nif (!pt_reset(tape))\r\nreturn pt_identify(tape);\r\n}\r\nreturn -1;\r\n}\r\nstatic int pt_detect(void)\r\n{\r\nstruct pt_unit *tape;\r\nint specified = 0, found = 0;\r\nint unit;\r\nprintk("%s: %s version %s, major %d\n", name, name, PT_VERSION, major);\r\npar_drv = pi_register_driver(name);\r\nif (!par_drv) {\r\npr_err("failed to register %s driver\n", name);\r\nreturn -1;\r\n}\r\nspecified = 0;\r\nfor (unit = 0; unit < PT_UNITS; unit++) {\r\nstruct pt_unit *tape = &pt[unit];\r\ntape->pi = &tape->pia;\r\natomic_set(&tape->available, 1);\r\ntape->flags = 0;\r\ntape->last_sense = 0;\r\ntape->present = 0;\r\ntape->bufptr = NULL;\r\ntape->drive = DU[D_SLV];\r\nsnprintf(tape->name, PT_NAMELEN, "%s%d", name, unit);\r\nif (!DU[D_PRT])\r\ncontinue;\r\nspecified++;\r\nif (pi_init(tape->pi, 0, DU[D_PRT], DU[D_MOD], DU[D_UNI],\r\nDU[D_PRO], DU[D_DLY], pt_scratch, PI_PT,\r\nverbose, tape->name)) {\r\nif (!pt_probe(tape)) {\r\ntape->present = 1;\r\nfound++;\r\n} else\r\npi_release(tape->pi);\r\n}\r\n}\r\nif (specified == 0) {\r\ntape = pt;\r\nif (pi_init(tape->pi, 1, -1, -1, -1, -1, -1, pt_scratch,\r\nPI_PT, verbose, tape->name)) {\r\nif (!pt_probe(tape)) {\r\ntape->present = 1;\r\nfound++;\r\n} else\r\npi_release(tape->pi);\r\n}\r\n}\r\nif (found)\r\nreturn 0;\r\npi_unregister_driver(par_drv);\r\nprintk("%s: No ATAPI tape drive detected\n", name);\r\nreturn -1;\r\n}\r\nstatic int pt_open(struct inode *inode, struct file *file)\r\n{\r\nint unit = iminor(inode) & 0x7F;\r\nstruct pt_unit *tape = pt + unit;\r\nint err;\r\nmutex_lock(&pt_mutex);\r\nif (unit >= PT_UNITS || (!tape->present)) {\r\nmutex_unlock(&pt_mutex);\r\nreturn -ENODEV;\r\n}\r\nerr = -EBUSY;\r\nif (!atomic_dec_and_test(&tape->available))\r\ngoto out;\r\npt_identify(tape);\r\nerr = -ENODEV;\r\nif (!(tape->flags & PT_MEDIA))\r\ngoto out;\r\nerr = -EROFS;\r\nif ((!(tape->flags & PT_WRITE_OK)) && (file->f_mode & FMODE_WRITE))\r\ngoto out;\r\nif (!(iminor(inode) & 128))\r\ntape->flags |= PT_REWIND;\r\nerr = -ENOMEM;\r\ntape->bufptr = kmalloc(PT_BUFSIZE, GFP_KERNEL);\r\nif (tape->bufptr == NULL) {\r\nprintk("%s: buffer allocation failed\n", tape->name);\r\ngoto out;\r\n}\r\nfile->private_data = tape;\r\nmutex_unlock(&pt_mutex);\r\nreturn 0;\r\nout:\r\natomic_inc(&tape->available);\r\nmutex_unlock(&pt_mutex);\r\nreturn err;\r\n}\r\nstatic long pt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct pt_unit *tape = file->private_data;\r\nstruct mtop __user *p = (void __user *)arg;\r\nstruct mtop mtop;\r\nswitch (cmd) {\r\ncase MTIOCTOP:\r\nif (copy_from_user(&mtop, p, sizeof(struct mtop)))\r\nreturn -EFAULT;\r\nswitch (mtop.mt_op) {\r\ncase MTREW:\r\nmutex_lock(&pt_mutex);\r\npt_rewind(tape);\r\nmutex_unlock(&pt_mutex);\r\nreturn 0;\r\ncase MTWEOF:\r\nmutex_lock(&pt_mutex);\r\npt_write_fm(tape);\r\nmutex_unlock(&pt_mutex);\r\nreturn 0;\r\ndefault:\r\nprintk(KERN_DEBUG "%s: Unimplemented mt_op %d\n", tape->name,\r\nmtop.mt_op);\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int\r\npt_release(struct inode *inode, struct file *file)\r\n{\r\nstruct pt_unit *tape = file->private_data;\r\nif (atomic_read(&tape->available) > 1)\r\nreturn -EINVAL;\r\nif (tape->flags & PT_WRITING)\r\npt_write_fm(tape);\r\nif (tape->flags & PT_REWIND)\r\npt_rewind(tape);\r\nkfree(tape->bufptr);\r\ntape->bufptr = NULL;\r\natomic_inc(&tape->available);\r\nreturn 0;\r\n}\r\nstatic ssize_t pt_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nstruct pt_unit *tape = filp->private_data;\r\nstruct pi_adapter *pi = tape->pi;\r\nchar rd_cmd[12] = { ATAPI_READ_6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nint k, n, r, p, s, t, b;\r\nif (!(tape->flags & (PT_READING | PT_WRITING))) {\r\ntape->flags |= PT_READING;\r\nif (pt_atapi(tape, rd_cmd, 0, NULL, "start read-ahead"))\r\nreturn -EIO;\r\n} else if (tape->flags & PT_WRITING)\r\nreturn -EIO;\r\nif (tape->flags & PT_EOF)\r\nreturn 0;\r\nt = 0;\r\nwhile (count > 0) {\r\nif (!pt_poll_dsc(tape, HZ / 100, PT_TMO, "read"))\r\nreturn -EIO;\r\nn = count;\r\nif (n > 32768)\r\nn = 32768;\r\nb = (n - 1 + tape->bs) / tape->bs;\r\nn = b * tape->bs;\r\nrd_cmd[4] = b;\r\nr = pt_command(tape, rd_cmd, n, "read");\r\nmdelay(1);\r\nif (r) {\r\npt_req_sense(tape, 0);\r\nreturn -EIO;\r\n}\r\nwhile (1) {\r\nr = pt_wait(tape, STAT_BUSY,\r\nSTAT_DRQ | STAT_ERR | STAT_READY,\r\nDBMSG("read DRQ"), "");\r\nif (r & STAT_SENSE) {\r\npi_disconnect(pi);\r\npt_req_sense(tape, 0);\r\nreturn -EIO;\r\n}\r\nif (r)\r\ntape->flags |= PT_EOF;\r\ns = read_reg(pi, 7);\r\nif (!(s & STAT_DRQ))\r\nbreak;\r\nn = (read_reg(pi, 4) + 256 * read_reg(pi, 5));\r\np = (read_reg(pi, 2) & 3);\r\nif (p != 2) {\r\npi_disconnect(pi);\r\nprintk("%s: Phase error on read: %d\n", tape->name,\r\np);\r\nreturn -EIO;\r\n}\r\nwhile (n > 0) {\r\nk = n;\r\nif (k > PT_BUFSIZE)\r\nk = PT_BUFSIZE;\r\npi_read_block(pi, tape->bufptr, k);\r\nn -= k;\r\nb = k;\r\nif (b > count)\r\nb = count;\r\nif (copy_to_user(buf + t, tape->bufptr, b)) {\r\npi_disconnect(pi);\r\nreturn -EFAULT;\r\n}\r\nt += b;\r\ncount -= b;\r\n}\r\n}\r\npi_disconnect(pi);\r\nif (tape->flags & PT_EOF)\r\nbreak;\r\n}\r\nreturn t;\r\n}\r\nstatic ssize_t pt_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nstruct pt_unit *tape = filp->private_data;\r\nstruct pi_adapter *pi = tape->pi;\r\nchar wr_cmd[12] = { ATAPI_WRITE_6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nint k, n, r, p, s, t, b;\r\nif (!(tape->flags & PT_WRITE_OK))\r\nreturn -EROFS;\r\nif (!(tape->flags & (PT_READING | PT_WRITING))) {\r\ntape->flags |= PT_WRITING;\r\nif (pt_atapi\r\n(tape, wr_cmd, 0, NULL, "start buffer-available mode"))\r\nreturn -EIO;\r\n} else if (tape->flags & PT_READING)\r\nreturn -EIO;\r\nif (tape->flags & PT_EOF)\r\nreturn -ENOSPC;\r\nt = 0;\r\nwhile (count > 0) {\r\nif (!pt_poll_dsc(tape, HZ / 100, PT_TMO, "write"))\r\nreturn -EIO;\r\nn = count;\r\nif (n > 32768)\r\nn = 32768;\r\nb = (n - 1 + tape->bs) / tape->bs;\r\nn = b * tape->bs;\r\nwr_cmd[4] = b;\r\nr = pt_command(tape, wr_cmd, n, "write");\r\nmdelay(1);\r\nif (r) {\r\npt_req_sense(tape, 0);\r\nreturn -EIO;\r\n}\r\nwhile (1) {\r\nr = pt_wait(tape, STAT_BUSY,\r\nSTAT_DRQ | STAT_ERR | STAT_READY,\r\nDBMSG("write DRQ"), NULL);\r\nif (r & STAT_SENSE) {\r\npi_disconnect(pi);\r\npt_req_sense(tape, 0);\r\nreturn -EIO;\r\n}\r\nif (r)\r\ntape->flags |= PT_EOF;\r\ns = read_reg(pi, 7);\r\nif (!(s & STAT_DRQ))\r\nbreak;\r\nn = (read_reg(pi, 4) + 256 * read_reg(pi, 5));\r\np = (read_reg(pi, 2) & 3);\r\nif (p != 0) {\r\npi_disconnect(pi);\r\nprintk("%s: Phase error on write: %d \n",\r\ntape->name, p);\r\nreturn -EIO;\r\n}\r\nwhile (n > 0) {\r\nk = n;\r\nif (k > PT_BUFSIZE)\r\nk = PT_BUFSIZE;\r\nb = k;\r\nif (b > count)\r\nb = count;\r\nif (copy_from_user(tape->bufptr, buf + t, b)) {\r\npi_disconnect(pi);\r\nreturn -EFAULT;\r\n}\r\npi_write_block(pi, tape->bufptr, k);\r\nt += b;\r\ncount -= b;\r\nn -= k;\r\n}\r\n}\r\npi_disconnect(pi);\r\nif (tape->flags & PT_EOF)\r\nbreak;\r\n}\r\nreturn t;\r\n}\r\nstatic int __init pt_init(void)\r\n{\r\nint unit;\r\nint err;\r\nif (disable) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (pt_detect()) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nerr = register_chrdev(major, name, &pt_fops);\r\nif (err < 0) {\r\nprintk("pt_init: unable to get major number %d\n", major);\r\nfor (unit = 0; unit < PT_UNITS; unit++)\r\nif (pt[unit].present)\r\npi_release(pt[unit].pi);\r\ngoto out;\r\n}\r\nmajor = err;\r\npt_class = class_create(THIS_MODULE, "pt");\r\nif (IS_ERR(pt_class)) {\r\nerr = PTR_ERR(pt_class);\r\ngoto out_chrdev;\r\n}\r\nfor (unit = 0; unit < PT_UNITS; unit++)\r\nif (pt[unit].present) {\r\ndevice_create(pt_class, NULL, MKDEV(major, unit), NULL,\r\n"pt%d", unit);\r\ndevice_create(pt_class, NULL, MKDEV(major, unit + 128),\r\nNULL, "pt%dn", unit);\r\n}\r\ngoto out;\r\nout_chrdev:\r\nunregister_chrdev(major, "pt");\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit pt_exit(void)\r\n{\r\nint unit;\r\nfor (unit = 0; unit < PT_UNITS; unit++)\r\nif (pt[unit].present) {\r\ndevice_destroy(pt_class, MKDEV(major, unit));\r\ndevice_destroy(pt_class, MKDEV(major, unit + 128));\r\n}\r\nclass_destroy(pt_class);\r\nunregister_chrdev(major, name);\r\nfor (unit = 0; unit < PT_UNITS; unit++)\r\nif (pt[unit].present)\r\npi_release(pt[unit].pi);\r\n}
