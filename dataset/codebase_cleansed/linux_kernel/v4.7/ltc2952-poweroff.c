static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)\r\n{\r\nktime_t now;\r\nint state;\r\nunsigned long overruns;\r\nstruct ltc2952_poweroff *data = to_ltc2952(timer, timer_wde);\r\nif (data->kernel_panic)\r\nreturn HRTIMER_NORESTART;\r\nstate = gpiod_get_value(data->gpio_watchdog);\r\ngpiod_set_value(data->gpio_watchdog, !state);\r\nnow = hrtimer_cb_get_time(timer);\r\noverruns = hrtimer_forward(timer, now, data->wde_interval);\r\nreturn HRTIMER_RESTART;\r\n}\r\nstatic void ltc2952_poweroff_start_wde(struct ltc2952_poweroff *data)\r\n{\r\nhrtimer_start(&data->timer_wde, data->wde_interval, HRTIMER_MODE_REL);\r\n}\r\nstatic enum hrtimer_restart\r\nltc2952_poweroff_timer_trigger(struct hrtimer *timer)\r\n{\r\nstruct ltc2952_poweroff *data = to_ltc2952(timer, timer_trigger);\r\nltc2952_poweroff_start_wde(data);\r\ndev_info(data->dev, "executing shutdown\n");\r\norderly_poweroff(true);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)\r\n{\r\nstruct ltc2952_poweroff *data = dev_id;\r\nif (data->kernel_panic || hrtimer_active(&data->timer_wde)) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif (gpiod_get_value(data->gpio_trigger)) {\r\nhrtimer_start(&data->timer_trigger, data->trigger_delay,\r\nHRTIMER_MODE_REL);\r\n} else {\r\nhrtimer_cancel(&data->timer_trigger);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ltc2952_poweroff_kill(void)\r\n{\r\ngpiod_set_value(ltc2952_data->gpio_kill, 1);\r\n}\r\nstatic void ltc2952_poweroff_default(struct ltc2952_poweroff *data)\r\n{\r\ndata->wde_interval = ktime_set(0, 300L*1E6L);\r\ndata->trigger_delay = ktime_set(2, 500L*1E6L);\r\nhrtimer_init(&data->timer_trigger, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\ndata->timer_trigger.function = ltc2952_poweroff_timer_trigger;\r\nhrtimer_init(&data->timer_wde, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\ndata->timer_wde.function = ltc2952_poweroff_timer_wde;\r\n}\r\nstatic int ltc2952_poweroff_init(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct ltc2952_poweroff *data = platform_get_drvdata(pdev);\r\nltc2952_poweroff_default(data);\r\ndata->gpio_watchdog = devm_gpiod_get(&pdev->dev, "watchdog",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(data->gpio_watchdog)) {\r\nret = PTR_ERR(data->gpio_watchdog);\r\ndev_err(&pdev->dev, "unable to claim gpio \"watchdog\"\n");\r\nreturn ret;\r\n}\r\ndata->gpio_kill = devm_gpiod_get(&pdev->dev, "kill", GPIOD_OUT_LOW);\r\nif (IS_ERR(data->gpio_kill)) {\r\nret = PTR_ERR(data->gpio_kill);\r\ndev_err(&pdev->dev, "unable to claim gpio \"kill\"\n");\r\nreturn ret;\r\n}\r\ndata->gpio_trigger = devm_gpiod_get_optional(&pdev->dev, "trigger",\r\nGPIOD_IN);\r\nif (IS_ERR(data->gpio_trigger)) {\r\ndev_err(&pdev->dev, "unable to claim gpio \"trigger\"\n");\r\ndata->gpio_trigger = NULL;\r\n}\r\nif (devm_request_irq(&pdev->dev, gpiod_to_irq(data->gpio_trigger),\r\nltc2952_poweroff_handler,\r\n(IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),\r\n"ltc2952-poweroff",\r\ndata)) {\r\nif (data->gpio_trigger) {\r\ndev_warn(&pdev->dev,\r\n"unable to configure the trigger interrupt\n");\r\ndevm_gpiod_put(&pdev->dev, data->gpio_trigger);\r\ndata->gpio_trigger = NULL;\r\n}\r\ndev_info(&pdev->dev,\r\n"power down trigger input will not be used\n");\r\nltc2952_poweroff_start_wde(data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ltc2952_poweroff_notify_panic(struct notifier_block *nb,\r\nunsigned long code, void *unused)\r\n{\r\nstruct ltc2952_poweroff *data = to_ltc2952(nb, panic_notifier);\r\ndata->kernel_panic = true;\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ltc2952_poweroff_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct ltc2952_poweroff *data;\r\nif (pm_power_off) {\r\ndev_err(&pdev->dev, "pm_power_off already registered");\r\nreturn -EBUSY;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, data);\r\nret = ltc2952_poweroff_init(pdev);\r\nif (ret)\r\nreturn ret;\r\nltc2952_data = data;\r\npm_power_off = ltc2952_poweroff_kill;\r\ndata->panic_notifier.notifier_call = ltc2952_poweroff_notify_panic;\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&data->panic_notifier);\r\ndev_info(&pdev->dev, "probe successful\n");\r\nreturn 0;\r\n}\r\nstatic int ltc2952_poweroff_remove(struct platform_device *pdev)\r\n{\r\nstruct ltc2952_poweroff *data = platform_get_drvdata(pdev);\r\npm_power_off = NULL;\r\nhrtimer_cancel(&data->timer_trigger);\r\nhrtimer_cancel(&data->timer_wde);\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&data->panic_notifier);\r\nreturn 0;\r\n}
