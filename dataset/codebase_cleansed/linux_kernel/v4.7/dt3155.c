static int read_i2c_reg(void __iomem *addr, u8 index, u8 *data)\r\n{\r\nu32 tmp = index;\r\niowrite32((tmp << 17) | IIC_READ, addr + IIC_CSR2);\r\nmmiowb();\r\nudelay(45);\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nreturn -EIO;\r\ntmp = ioread32(addr + IIC_CSR1);\r\nif (tmp & DIRECT_ABORT) {\r\niowrite32(DIRECT_ABORT, addr + IIC_CSR1);\r\nreturn -EIO;\r\n}\r\n*data = tmp >> 24;\r\nreturn 0;\r\n}\r\nstatic int write_i2c_reg(void __iomem *addr, u8 index, u8 data)\r\n{\r\nu32 tmp = index;\r\niowrite32((tmp << 17) | IIC_WRITE | data, addr + IIC_CSR2);\r\nmmiowb();\r\nudelay(65);\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nreturn -EIO;\r\nif (ioread32(addr + IIC_CSR1) & DIRECT_ABORT) {\r\niowrite32(DIRECT_ABORT, addr + IIC_CSR1);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void write_i2c_reg_nowait(void __iomem *addr, u8 index, u8 data)\r\n{\r\nu32 tmp = index;\r\niowrite32((tmp << 17) | IIC_WRITE | data, addr + IIC_CSR2);\r\nmmiowb();\r\n}\r\nstatic int wait_i2c_reg(void __iomem *addr)\r\n{\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nudelay(65);\r\nif (ioread32(addr + IIC_CSR2) & NEW_CYCLE)\r\nreturn -EIO;\r\nif (ioread32(addr + IIC_CSR1) & DIRECT_ABORT) {\r\niowrite32(DIRECT_ABORT, addr + IIC_CSR1);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndt3155_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(vq);\r\nunsigned size = pd->width * pd->height;\r\nif (vq->num_buffers + *nbuffers < 2)\r\n*nbuffers = 2 - vq->num_buffers;\r\nalloc_ctxs[0] = pd->alloc_ctx;\r\nif (*num_planes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*num_planes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic int dt3155_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(vb->vb2_queue);\r\nvb2_set_plane_payload(vb, 0, pd->width * pd->height);\r\nreturn 0;\r\n}\r\nstatic int dt3155_start_streaming(struct vb2_queue *q, unsigned count)\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(q);\r\nstruct vb2_buffer *vb = &pd->curr_buf->vb2_buf;\r\ndma_addr_t dma_addr;\r\npd->sequence = 0;\r\ndma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\niowrite32(dma_addr, pd->regs + EVEN_DMA_START);\r\niowrite32(dma_addr + pd->width, pd->regs + ODD_DMA_START);\r\niowrite32(pd->width, pd->regs + EVEN_DMA_STRIDE);\r\niowrite32(pd->width, pd->regs + ODD_DMA_STRIDE);\r\niowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START |\r\nFLD_END_EVEN | FLD_END_ODD, pd->regs + INT_CSR);\r\niowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\r\nFLD_DN_ODD | FLD_DN_EVEN | CAP_CONT_EVEN | CAP_CONT_ODD,\r\npd->regs + CSR1);\r\nwait_i2c_reg(pd->regs);\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config);\r\nwrite_i2c_reg(pd->regs, EVEN_CSR, CSR_ERROR | CSR_DONE);\r\nwrite_i2c_reg(pd->regs, ODD_CSR, CSR_ERROR | CSR_DONE);\r\nwrite_i2c_reg(pd->regs, CSR2, pd->csr2 | BUSY_EVEN | BUSY_ODD);\r\nreturn 0;\r\n}\r\nstatic void dt3155_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(q);\r\nstruct vb2_buffer *vb;\r\nspin_lock_irq(&pd->lock);\r\nwrite_i2c_reg_nowait(pd->regs, CSR2, pd->csr2);\r\niowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\r\nFLD_DN_ODD | FLD_DN_EVEN, pd->regs + CSR1);\r\niowrite32(FLD_START | FLD_END_EVEN | FLD_END_ODD, pd->regs + INT_CSR);\r\nspin_unlock_irq(&pd->lock);\r\nmsleep(45);\r\nspin_lock_irq(&pd->lock);\r\nif (pd->curr_buf) {\r\nvb2_buffer_done(&pd->curr_buf->vb2_buf, VB2_BUF_STATE_ERROR);\r\npd->curr_buf = NULL;\r\n}\r\nwhile (!list_empty(&pd->dmaq)) {\r\nvb = list_first_entry(&pd->dmaq, typeof(*vb), done_entry);\r\nlist_del(&vb->done_entry);\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irq(&pd->lock);\r\n}\r\nstatic void dt3155_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct dt3155_priv *pd = vb2_get_drv_priv(vb->vb2_queue);\r\nspin_lock_irq(&pd->lock);\r\nif (pd->curr_buf)\r\nlist_add_tail(&vb->done_entry, &pd->dmaq);\r\nelse\r\npd->curr_buf = vbuf;\r\nspin_unlock_irq(&pd->lock);\r\n}\r\nstatic irqreturn_t dt3155_irq_handler_even(int irq, void *dev_id)\r\n{\r\nstruct dt3155_priv *ipd = dev_id;\r\nstruct vb2_buffer *ivb;\r\ndma_addr_t dma_addr;\r\nu32 tmp;\r\ntmp = ioread32(ipd->regs + INT_CSR) & (FLD_START | FLD_END_ODD);\r\nif (!tmp)\r\nreturn IRQ_NONE;\r\nif ((tmp & FLD_START) && !(tmp & FLD_END_ODD)) {\r\niowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START,\r\nipd->regs + INT_CSR);\r\nreturn IRQ_HANDLED;\r\n}\r\ntmp = ioread32(ipd->regs + CSR1) & (FLD_CRPT_EVEN | FLD_CRPT_ODD);\r\nif (tmp) {\r\niowrite32(FIFO_EN | SRST | FLD_CRPT_ODD | FLD_CRPT_EVEN |\r\nFLD_DN_ODD | FLD_DN_EVEN |\r\nCAP_CONT_EVEN | CAP_CONT_ODD,\r\nipd->regs + CSR1);\r\nmmiowb();\r\n}\r\nspin_lock(&ipd->lock);\r\nif (ipd->curr_buf && !list_empty(&ipd->dmaq)) {\r\nipd->curr_buf->vb2_buf.timestamp = ktime_get_ns();\r\nipd->curr_buf->sequence = ipd->sequence++;\r\nipd->curr_buf->field = V4L2_FIELD_NONE;\r\nvb2_buffer_done(&ipd->curr_buf->vb2_buf, VB2_BUF_STATE_DONE);\r\nivb = list_first_entry(&ipd->dmaq, typeof(*ivb), done_entry);\r\nlist_del(&ivb->done_entry);\r\nipd->curr_buf = to_vb2_v4l2_buffer(ivb);\r\ndma_addr = vb2_dma_contig_plane_dma_addr(ivb, 0);\r\niowrite32(dma_addr, ipd->regs + EVEN_DMA_START);\r\niowrite32(dma_addr + ipd->width, ipd->regs + ODD_DMA_START);\r\niowrite32(ipd->width, ipd->regs + EVEN_DMA_STRIDE);\r\niowrite32(ipd->width, ipd->regs + ODD_DMA_STRIDE);\r\nmmiowb();\r\n}\r\niowrite32(FLD_START_EN | FLD_END_ODD_EN | FLD_START |\r\nFLD_END_EVEN | FLD_END_ODD, ipd->regs + INT_CSR);\r\nspin_unlock(&ipd->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dt3155_querycap(struct file *filp, void *p,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nstrcpy(cap->driver, DT3155_NAME);\r\nstrcpy(cap->card, DT3155_NAME " frame grabber");\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(pd->pdev));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int dt3155_enum_fmt_vid_cap(struct file *filp,\r\nvoid *p, struct v4l2_fmtdesc *f)\r\n{\r\nif (f->index)\r\nreturn -EINVAL;\r\nf->pixelformat = V4L2_PIX_FMT_GREY;\r\nstrcpy(f->description, "8-bit Greyscale");\r\nreturn 0;\r\n}\r\nstatic int dt3155_fmt_vid_cap(struct file *filp, void *p, struct v4l2_format *f)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nf->fmt.pix.width = pd->width;\r\nf->fmt.pix.height = pd->height;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_GREY;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width;\r\nf->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int dt3155_g_std(struct file *filp, void *p, v4l2_std_id *norm)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\n*norm = pd->std;\r\nreturn 0;\r\n}\r\nstatic int dt3155_s_std(struct file *filp, void *p, v4l2_std_id norm)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nif (pd->std == norm)\r\nreturn 0;\r\nif (vb2_is_busy(&pd->vidq))\r\nreturn -EBUSY;\r\npd->std = norm;\r\nif (pd->std & V4L2_STD_525_60) {\r\npd->csr2 = VT_60HZ;\r\npd->width = 640;\r\npd->height = 480;\r\n} else {\r\npd->csr2 = VT_50HZ;\r\npd->width = 768;\r\npd->height = 576;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dt3155_enum_input(struct file *filp, void *p,\r\nstruct v4l2_input *input)\r\n{\r\nif (input->index > 3)\r\nreturn -EINVAL;\r\nif (input->index)\r\nsnprintf(input->name, sizeof(input->name), "VID%d",\r\ninput->index);\r\nelse\r\nstrlcpy(input->name, "J2/VID0", sizeof(input->name));\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\ninput->std = V4L2_STD_ALL;\r\ninput->status = 0;\r\nreturn 0;\r\n}\r\nstatic int dt3155_g_input(struct file *filp, void *p, unsigned int *i)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\n*i = pd->input;\r\nreturn 0;\r\n}\r\nstatic int dt3155_s_input(struct file *filp, void *p, unsigned int i)\r\n{\r\nstruct dt3155_priv *pd = video_drvdata(filp);\r\nif (i > 3)\r\nreturn -EINVAL;\r\npd->input = i;\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\r\nwrite_i2c_reg(pd->regs, AD_CMD, (i << 6) | (i << 4) | SYNC_LVL_3);\r\nreturn 0;\r\n}\r\nstatic int dt3155_init_board(struct dt3155_priv *pd)\r\n{\r\nstruct pci_dev *pdev = pd->pdev;\r\nint i;\r\nu8 tmp = 0;\r\npci_set_master(pdev);\r\niowrite32(ADDR_ERR_ODD | ADDR_ERR_EVEN | FLD_CRPT_ODD | FLD_CRPT_EVEN |\r\nFLD_DN_ODD | FLD_DN_EVEN, pd->regs + CSR1);\r\nmmiowb();\r\nmsleep(20);\r\niowrite32(FIFO_EN | SRST, pd->regs + CSR1);\r\nmmiowb();\r\niowrite32(0xEEEEEE01, pd->regs + EVEN_PIXEL_FMT);\r\niowrite32(0xEEEEEE01, pd->regs + ODD_PIXEL_FMT);\r\niowrite32(0x00000020, pd->regs + FIFO_TRIGER);\r\niowrite32(0x00000103, pd->regs + XFER_MODE);\r\niowrite32(0, pd->regs + RETRY_WAIT_CNT);\r\niowrite32(0, pd->regs + INT_CSR);\r\niowrite32(1, pd->regs + EVEN_FLD_MASK);\r\niowrite32(1, pd->regs + ODD_FLD_MASK);\r\niowrite32(0, pd->regs + MASK_LENGTH);\r\niowrite32(0x0005007C, pd->regs + FIFO_FLAG_CNT);\r\niowrite32(0x01010101, pd->regs + IIC_CLK_DUR);\r\nmmiowb();\r\nread_i2c_reg(pd->regs, DT_ID, &tmp);\r\nif (tmp != DT3155_ID)\r\nreturn -ENODEV;\r\nwrite_i2c_reg(pd->regs, AD_ADDR, 0);\r\nfor (i = 0; i < 256; i++)\r\nwrite_i2c_reg(pd->regs, AD_LUT, i);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\r\nwrite_i2c_reg(pd->regs, AD_CMD, VIDEO_CNL_1 | SYNC_CNL_1 | SYNC_LVL_3);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_POS_REF);\r\nwrite_i2c_reg(pd->regs, AD_CMD, 34);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_NEG_REF);\r\nwrite_i2c_reg(pd->regs, AD_CMD, 0);\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config | PM_LUT_PGM);\r\nfor (i = 0; i < 256; i++) {\r\nwrite_i2c_reg(pd->regs, PM_LUT_ADDR, i);\r\nwrite_i2c_reg(pd->regs, PM_LUT_DATA, i);\r\n}\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config | PM_LUT_PGM | PM_LUT_SEL);\r\nfor (i = 0; i < 256; i++) {\r\nwrite_i2c_reg(pd->regs, PM_LUT_ADDR, i);\r\nwrite_i2c_reg(pd->regs, PM_LUT_DATA, i);\r\n}\r\nwrite_i2c_reg(pd->regs, CONFIG, pd->config);\r\nwrite_i2c_reg(pd->regs, AD_ADDR, AD_CMD_REG);\r\nwrite_i2c_reg(pd->regs, AD_CMD, VIDEO_CNL_1 | SYNC_CNL_1 | SYNC_LVL_3);\r\niowrite32(FLD_START | FLD_END_EVEN | FLD_END_ODD,\r\npd->regs + INT_CSR);\r\nreturn 0;\r\n}\r\nstatic int dt3155_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint err;\r\nstruct dt3155_priv *pd;\r\nerr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\nreturn -ENODEV;\r\npd = devm_kzalloc(&pdev->dev, sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\nerr = v4l2_device_register(&pdev->dev, &pd->v4l2_dev);\r\nif (err)\r\nreturn err;\r\npd->vdev = dt3155_vdev;\r\npd->vdev.v4l2_dev = &pd->v4l2_dev;\r\nvideo_set_drvdata(&pd->vdev, pd);\r\npd->pdev = pdev;\r\npd->std = V4L2_STD_625_50;\r\npd->csr2 = VT_50HZ;\r\npd->width = 768;\r\npd->height = 576;\r\nINIT_LIST_HEAD(&pd->dmaq);\r\nmutex_init(&pd->mux);\r\npd->vdev.lock = &pd->mux;\r\npd->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\npd->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\npd->vidq.io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\r\npd->vidq.ops = &q_ops;\r\npd->vidq.mem_ops = &vb2_dma_contig_memops;\r\npd->vidq.drv_priv = pd;\r\npd->vidq.min_buffers_needed = 2;\r\npd->vidq.gfp_flags = GFP_DMA32;\r\npd->vidq.lock = &pd->mux;\r\npd->vdev.queue = &pd->vidq;\r\nerr = vb2_queue_init(&pd->vidq);\r\nif (err < 0)\r\ngoto err_v4l2_dev_unreg;\r\npd->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(pd->alloc_ctx)) {\r\ndev_err(&pdev->dev, "Can't allocate buffer context");\r\nerr = PTR_ERR(pd->alloc_ctx);\r\ngoto err_v4l2_dev_unreg;\r\n}\r\nspin_lock_init(&pd->lock);\r\npd->config = ACQ_MODE_EVEN;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto err_free_ctx;\r\nerr = pci_request_region(pdev, 0, pci_name(pdev));\r\nif (err)\r\ngoto err_pci_disable;\r\npd->regs = pci_iomap(pdev, 0, pci_resource_len(pd->pdev, 0));\r\nif (!pd->regs) {\r\nerr = -ENOMEM;\r\ngoto err_free_reg;\r\n}\r\nerr = dt3155_init_board(pd);\r\nif (err)\r\ngoto err_iounmap;\r\nerr = request_irq(pd->pdev->irq, dt3155_irq_handler_even,\r\nIRQF_SHARED, DT3155_NAME, pd);\r\nif (err)\r\ngoto err_iounmap;\r\nerr = video_register_device(&pd->vdev, VFL_TYPE_GRABBER, -1);\r\nif (err)\r\ngoto err_free_irq;\r\ndev_info(&pdev->dev, "/dev/video%i is ready\n", pd->vdev.minor);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(pd->pdev->irq, pd);\r\nerr_iounmap:\r\npci_iounmap(pdev, pd->regs);\r\nerr_free_reg:\r\npci_release_region(pdev, 0);\r\nerr_pci_disable:\r\npci_disable_device(pdev);\r\nerr_free_ctx:\r\nvb2_dma_contig_cleanup_ctx(pd->alloc_ctx);\r\nerr_v4l2_dev_unreg:\r\nv4l2_device_unregister(&pd->v4l2_dev);\r\nreturn err;\r\n}\r\nstatic void dt3155_remove(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct dt3155_priv *pd = container_of(v4l2_dev, struct dt3155_priv,\r\nv4l2_dev);\r\nvideo_unregister_device(&pd->vdev);\r\nfree_irq(pd->pdev->irq, pd);\r\nvb2_queue_release(&pd->vidq);\r\nv4l2_device_unregister(&pd->v4l2_dev);\r\npci_iounmap(pdev, pd->regs);\r\npci_release_region(pdev, 0);\r\npci_disable_device(pdev);\r\nvb2_dma_contig_cleanup_ctx(pd->alloc_ctx);\r\n}
