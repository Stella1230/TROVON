static unsigned long ti_composite_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn ti_clk_divider_ops.recalc_rate(hw, parent_rate);\r\n}\r\nstatic long ti_composite_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int ti_composite_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic struct device_node *_get_component_node(struct device_node *node, int i)\r\n{\r\nint rc;\r\nstruct of_phandle_args clkspec;\r\nrc = of_parse_phandle_with_args(node, "clocks", "#clock-cells", i,\r\n&clkspec);\r\nif (rc)\r\nreturn NULL;\r\nreturn clkspec.np;\r\n}\r\nstatic struct component_clk *_lookup_component(struct device_node *node)\r\n{\r\nstruct component_clk *comp;\r\nlist_for_each_entry(comp, &component_clks, link) {\r\nif (comp->node == node)\r\nreturn comp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct clk_hw *_get_hw(struct clk_hw_omap_comp *clk, int idx)\r\n{\r\nif (!clk)\r\nreturn NULL;\r\nif (!clk->comp_clks[idx])\r\nreturn NULL;\r\nreturn clk->comp_clks[idx]->hw;\r\n}\r\nstruct clk *ti_clk_register_composite(struct ti_clk *setup)\r\n{\r\nstruct ti_clk_composite *comp;\r\nstruct clk_hw *gate;\r\nstruct clk_hw *mux;\r\nstruct clk_hw *div;\r\nint num_parents = 1;\r\nconst char **parent_names = NULL;\r\nstruct clk *clk;\r\ncomp = setup->data;\r\ndiv = ti_clk_build_component_div(comp->divider);\r\ngate = ti_clk_build_component_gate(comp->gate);\r\nmux = ti_clk_build_component_mux(comp->mux);\r\nif (div)\r\nparent_names = &comp->divider->parent;\r\nif (gate)\r\nparent_names = &comp->gate->parent;\r\nif (mux) {\r\nnum_parents = comp->mux->num_parents;\r\nparent_names = comp->mux->parents;\r\n}\r\nclk = clk_register_composite(NULL, setup->name,\r\nparent_names, num_parents, mux,\r\n&ti_clk_mux_ops, div,\r\n&ti_composite_divider_ops, gate,\r\n&ti_composite_gate_ops, 0);\r\nreturn clk;\r\n}\r\nstatic void __init _register_composite(struct clk_hw *hw,\r\nstruct device_node *node)\r\n{\r\nstruct clk *clk;\r\nstruct clk_hw_omap_comp *cclk = to_clk_hw_comp(hw);\r\nstruct component_clk *comp;\r\nint num_parents = 0;\r\nconst char **parent_names = NULL;\r\nint i;\r\nfor (i = 0; i < CLK_COMPONENT_TYPE_MAX; i++) {\r\nif (!cclk->comp_nodes[i])\r\ncontinue;\r\ncomp = _lookup_component(cclk->comp_nodes[i]);\r\nif (!comp) {\r\npr_debug("component %s not ready for %s, retry\n",\r\ncclk->comp_nodes[i]->name, node->name);\r\nif (!ti_clk_retry_init(node, hw,\r\n_register_composite))\r\nreturn;\r\ngoto cleanup;\r\n}\r\nif (cclk->comp_clks[comp->type] != NULL) {\r\npr_err("duplicate component types for %s (%s)!\n",\r\nnode->name, component_clk_types[comp->type]);\r\ngoto cleanup;\r\n}\r\ncclk->comp_clks[comp->type] = comp;\r\ncclk->comp_nodes[i] = NULL;\r\n}\r\nfor (i = CLK_COMPONENT_TYPE_MAX - 1; i >= 0; i--) {\r\ncomp = cclk->comp_clks[i];\r\nif (!comp)\r\ncontinue;\r\nif (comp->num_parents) {\r\nnum_parents = comp->num_parents;\r\nparent_names = comp->parent_names;\r\nbreak;\r\n}\r\n}\r\nif (!num_parents) {\r\npr_err("%s: no parents found for %s!\n", __func__, node->name);\r\ngoto cleanup;\r\n}\r\nclk = clk_register_composite(NULL, node->name,\r\nparent_names, num_parents,\r\n_get_hw(cclk, CLK_COMPONENT_TYPE_MUX),\r\n&ti_clk_mux_ops,\r\n_get_hw(cclk, CLK_COMPONENT_TYPE_DIVIDER),\r\n&ti_composite_divider_ops,\r\n_get_hw(cclk, CLK_COMPONENT_TYPE_GATE),\r\n&ti_composite_gate_ops, 0);\r\nif (!IS_ERR(clk))\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\ncleanup:\r\nfor (i = 0; i < CLK_COMPONENT_TYPE_MAX; i++) {\r\nif (!cclk->comp_clks[i])\r\ncontinue;\r\nlist_del(&cclk->comp_clks[i]->link);\r\nkfree(cclk->comp_clks[i]);\r\n}\r\nkfree(cclk);\r\n}\r\nstatic void __init of_ti_composite_clk_setup(struct device_node *node)\r\n{\r\nunsigned int num_clks;\r\nint i;\r\nstruct clk_hw_omap_comp *cclk;\r\nnum_clks = of_clk_get_parent_count(node);\r\nif (!num_clks) {\r\npr_err("composite clk %s must have component(s)\n", node->name);\r\nreturn;\r\n}\r\ncclk = kzalloc(sizeof(*cclk), GFP_KERNEL);\r\nif (!cclk)\r\nreturn;\r\nfor (i = 0; i < num_clks; i++)\r\ncclk->comp_nodes[i] = _get_component_node(node, i);\r\n_register_composite(&cclk->hw, node);\r\n}\r\nint __init ti_clk_add_component(struct device_node *node, struct clk_hw *hw,\r\nint type)\r\n{\r\nunsigned int num_parents;\r\nconst char **parent_names;\r\nstruct component_clk *clk;\r\nnum_parents = of_clk_get_parent_count(node);\r\nif (!num_parents) {\r\npr_err("component-clock %s must have parent(s)\n", node->name);\r\nreturn -EINVAL;\r\n}\r\nparent_names = kzalloc((sizeof(char *) * num_parents), GFP_KERNEL);\r\nif (!parent_names)\r\nreturn -ENOMEM;\r\nof_clk_parent_fill(node, parent_names, num_parents);\r\nclk = kzalloc(sizeof(*clk), GFP_KERNEL);\r\nif (!clk) {\r\nkfree(parent_names);\r\nreturn -ENOMEM;\r\n}\r\nclk->num_parents = num_parents;\r\nclk->parent_names = parent_names;\r\nclk->hw = hw;\r\nclk->node = node;\r\nclk->type = type;\r\nlist_add(&clk->link, &component_clks);\r\nreturn 0;\r\n}
