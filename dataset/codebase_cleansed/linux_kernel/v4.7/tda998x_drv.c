static void\r\ncec_write(struct tda998x_priv *priv, u16 addr, u8 val)\r\n{\r\nstruct i2c_client *client = priv->cec;\r\nu8 buf[] = {addr, val};\r\nint ret;\r\nret = i2c_master_send(client, buf, sizeof(buf));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to cec:0x%x\n", ret, addr);\r\n}\r\nstatic u8\r\ncec_read(struct tda998x_priv *priv, u8 addr)\r\n{\r\nstruct i2c_client *client = priv->cec;\r\nu8 val;\r\nint ret;\r\nret = i2c_master_send(client, &addr, sizeof(addr));\r\nif (ret < 0)\r\ngoto fail;\r\nret = i2c_master_recv(client, &val, sizeof(val));\r\nif (ret < 0)\r\ngoto fail;\r\nreturn val;\r\nfail:\r\ndev_err(&client->dev, "Error %d reading from cec:0x%x\n", ret, addr);\r\nreturn 0;\r\n}\r\nstatic int\r\nset_page(struct tda998x_priv *priv, u16 reg)\r\n{\r\nif (REG2PAGE(reg) != priv->current_page) {\r\nstruct i2c_client *client = priv->hdmi;\r\nu8 buf[] = {\r\nREG_CURPAGE, REG2PAGE(reg)\r\n};\r\nint ret = i2c_master_send(client, buf, sizeof(buf));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "%s %04x err %d\n", __func__,\r\nreg, ret);\r\nreturn ret;\r\n}\r\npriv->current_page = REG2PAGE(reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nreg_read_range(struct tda998x_priv *priv, u16 reg, char *buf, int cnt)\r\n{\r\nstruct i2c_client *client = priv->hdmi;\r\nu8 addr = REG2ADDR(reg);\r\nint ret;\r\nmutex_lock(&priv->mutex);\r\nret = set_page(priv, reg);\r\nif (ret < 0)\r\ngoto out;\r\nret = i2c_master_send(client, &addr, sizeof(addr));\r\nif (ret < 0)\r\ngoto fail;\r\nret = i2c_master_recv(client, buf, cnt);\r\nif (ret < 0)\r\ngoto fail;\r\ngoto out;\r\nfail:\r\ndev_err(&client->dev, "Error %d reading from 0x%x\n", ret, reg);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nreg_write_range(struct tda998x_priv *priv, u16 reg, u8 *p, int cnt)\r\n{\r\nstruct i2c_client *client = priv->hdmi;\r\nu8 buf[cnt+1];\r\nint ret;\r\nbuf[0] = REG2ADDR(reg);\r\nmemcpy(&buf[1], p, cnt);\r\nmutex_lock(&priv->mutex);\r\nret = set_page(priv, reg);\r\nif (ret < 0)\r\ngoto out;\r\nret = i2c_master_send(client, buf, cnt + 1);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to 0x%x\n", ret, reg);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int\r\nreg_read(struct tda998x_priv *priv, u16 reg)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nret = reg_read_range(priv, reg, &val, sizeof(val));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic void\r\nreg_write(struct tda998x_priv *priv, u16 reg, u8 val)\r\n{\r\nstruct i2c_client *client = priv->hdmi;\r\nu8 buf[] = {REG2ADDR(reg), val};\r\nint ret;\r\nmutex_lock(&priv->mutex);\r\nret = set_page(priv, reg);\r\nif (ret < 0)\r\ngoto out;\r\nret = i2c_master_send(client, buf, sizeof(buf));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to 0x%x\n", ret, reg);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void\r\nreg_write16(struct tda998x_priv *priv, u16 reg, u16 val)\r\n{\r\nstruct i2c_client *client = priv->hdmi;\r\nu8 buf[] = {REG2ADDR(reg), val >> 8, val};\r\nint ret;\r\nmutex_lock(&priv->mutex);\r\nret = set_page(priv, reg);\r\nif (ret < 0)\r\ngoto out;\r\nret = i2c_master_send(client, buf, sizeof(buf));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to 0x%x\n", ret, reg);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void\r\nreg_set(struct tda998x_priv *priv, u16 reg, u8 val)\r\n{\r\nint old_val;\r\nold_val = reg_read(priv, reg);\r\nif (old_val >= 0)\r\nreg_write(priv, reg, old_val | val);\r\n}\r\nstatic void\r\nreg_clear(struct tda998x_priv *priv, u16 reg, u8 val)\r\n{\r\nint old_val;\r\nold_val = reg_read(priv, reg);\r\nif (old_val >= 0)\r\nreg_write(priv, reg, old_val & ~val);\r\n}\r\nstatic void\r\ntda998x_reset(struct tda998x_priv *priv)\r\n{\r\nreg_write(priv, REG_SOFTRESET, SOFTRESET_AUDIO | SOFTRESET_I2C_MASTER);\r\nmsleep(50);\r\nreg_write(priv, REG_SOFTRESET, 0);\r\nmsleep(50);\r\nreg_set(priv, REG_MAIN_CNTRL0, MAIN_CNTRL0_SR);\r\nreg_clear(priv, REG_MAIN_CNTRL0, MAIN_CNTRL0_SR);\r\nreg_write(priv, REG_PLL_SERIAL_1, 0x00);\r\nreg_write(priv, REG_PLL_SERIAL_2, PLL_SERIAL_2_SRL_NOSC(1));\r\nreg_write(priv, REG_PLL_SERIAL_3, 0x00);\r\nreg_write(priv, REG_SERIALIZER, 0x00);\r\nreg_write(priv, REG_BUFFER_OUT, 0x00);\r\nreg_write(priv, REG_PLL_SCG1, 0x00);\r\nreg_write(priv, REG_AUDIO_DIV, AUDIO_DIV_SERCLK_8);\r\nreg_write(priv, REG_SEL_CLK, SEL_CLK_SEL_CLK1 | SEL_CLK_ENA_SC_CLK);\r\nreg_write(priv, REG_PLL_SCGN1, 0xfa);\r\nreg_write(priv, REG_PLL_SCGN2, 0x00);\r\nreg_write(priv, REG_PLL_SCGR1, 0x5b);\r\nreg_write(priv, REG_PLL_SCGR2, 0x00);\r\nreg_write(priv, REG_PLL_SCG2, 0x10);\r\nreg_write(priv, REG_MUX_VP_VIP_OUT, 0x24);\r\n}\r\nstatic void tda998x_edid_delay_done(unsigned long data)\r\n{\r\nstruct tda998x_priv *priv = (struct tda998x_priv *)data;\r\npriv->edid_delay_active = false;\r\nwake_up(&priv->edid_delay_waitq);\r\nschedule_work(&priv->detect_work);\r\n}\r\nstatic void tda998x_edid_delay_start(struct tda998x_priv *priv)\r\n{\r\npriv->edid_delay_active = true;\r\nmod_timer(&priv->edid_delay_timer, jiffies + HZ/10);\r\n}\r\nstatic int tda998x_edid_delay_wait(struct tda998x_priv *priv)\r\n{\r\nreturn wait_event_killable(priv->edid_delay_waitq, !priv->edid_delay_active);\r\n}\r\nstatic void tda998x_detect_work(struct work_struct *work)\r\n{\r\nstruct tda998x_priv *priv =\r\ncontainer_of(work, struct tda998x_priv, detect_work);\r\nstruct drm_device *dev = priv->encoder.dev;\r\nif (dev)\r\ndrm_kms_helper_hotplug_event(dev);\r\n}\r\nstatic irqreturn_t tda998x_irq_thread(int irq, void *data)\r\n{\r\nstruct tda998x_priv *priv = data;\r\nu8 sta, cec, lvl, flag0, flag1, flag2;\r\nbool handled = false;\r\nsta = cec_read(priv, REG_CEC_INTSTATUS);\r\ncec = cec_read(priv, REG_CEC_RXSHPDINT);\r\nlvl = cec_read(priv, REG_CEC_RXSHPDLEV);\r\nflag0 = reg_read(priv, REG_INT_FLAGS_0);\r\nflag1 = reg_read(priv, REG_INT_FLAGS_1);\r\nflag2 = reg_read(priv, REG_INT_FLAGS_2);\r\nDRM_DEBUG_DRIVER(\r\n"tda irq sta %02x cec %02x lvl %02x f0 %02x f1 %02x f2 %02x\n",\r\nsta, cec, lvl, flag0, flag1, flag2);\r\nif (cec & CEC_RXSHPDINT_HPD) {\r\nif (lvl & CEC_RXSHPDLEV_HPD)\r\ntda998x_edid_delay_start(priv);\r\nelse\r\nschedule_work(&priv->detect_work);\r\nhandled = true;\r\n}\r\nif ((flag2 & INT_FLAGS_2_EDID_BLK_RD) && priv->wq_edid_wait) {\r\npriv->wq_edid_wait = 0;\r\nwake_up(&priv->wq_edid);\r\nhandled = true;\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void\r\ntda998x_write_if(struct tda998x_priv *priv, u8 bit, u16 addr,\r\nunion hdmi_infoframe *frame)\r\n{\r\nu8 buf[32];\r\nssize_t len;\r\nlen = hdmi_infoframe_pack(frame, buf, sizeof(buf));\r\nif (len < 0) {\r\ndev_err(&priv->hdmi->dev,\r\n"hdmi_infoframe_pack() type=0x%02x failed: %zd\n",\r\nframe->any.type, len);\r\nreturn;\r\n}\r\nreg_clear(priv, REG_DIP_IF_FLAGS, bit);\r\nreg_write_range(priv, addr, buf, len);\r\nreg_set(priv, REG_DIP_IF_FLAGS, bit);\r\n}\r\nstatic void\r\ntda998x_write_aif(struct tda998x_priv *priv, struct tda998x_encoder_params *p)\r\n{\r\nunion hdmi_infoframe frame;\r\nhdmi_audio_infoframe_init(&frame.audio);\r\nframe.audio.channels = p->audio_frame[1] & 0x07;\r\nframe.audio.channel_allocation = p->audio_frame[4];\r\nframe.audio.level_shift_value = (p->audio_frame[5] & 0x78) >> 3;\r\nframe.audio.downmix_inhibit = (p->audio_frame[5] & 0x80) >> 7;\r\nframe.audio.sample_frequency = (p->audio_frame[2] & 0x1c) >> 2;\r\ntda998x_write_if(priv, DIP_IF_FLAGS_IF4, REG_IF4_HB0, &frame);\r\n}\r\nstatic void\r\ntda998x_write_avi(struct tda998x_priv *priv, struct drm_display_mode *mode)\r\n{\r\nunion hdmi_infoframe frame;\r\ndrm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode);\r\nframe.avi.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;\r\ntda998x_write_if(priv, DIP_IF_FLAGS_IF2, REG_IF2_HB0, &frame);\r\n}\r\nstatic void tda998x_audio_mute(struct tda998x_priv *priv, bool on)\r\n{\r\nif (on) {\r\nreg_set(priv, REG_SOFTRESET, SOFTRESET_AUDIO);\r\nreg_clear(priv, REG_SOFTRESET, SOFTRESET_AUDIO);\r\nreg_set(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_FIFO);\r\n} else {\r\nreg_clear(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_FIFO);\r\n}\r\n}\r\nstatic void\r\ntda998x_configure_audio(struct tda998x_priv *priv,\r\nstruct drm_display_mode *mode, struct tda998x_encoder_params *p)\r\n{\r\nu8 buf[6], clksel_aip, clksel_fs, cts_n, adiv;\r\nu32 n;\r\nreg_write(priv, REG_ENA_AP, p->audio_cfg);\r\nreg_write(priv, REG_ENA_ACLK, p->audio_clk_cfg);\r\nswitch (p->audio_format) {\r\ncase AFMT_SPDIF:\r\nreg_write(priv, REG_MUX_AP, MUX_AP_SELECT_SPDIF);\r\nclksel_aip = AIP_CLKSEL_AIP_SPDIF;\r\nclksel_fs = AIP_CLKSEL_FS_FS64SPDIF;\r\ncts_n = CTS_N_M(3) | CTS_N_K(3);\r\nbreak;\r\ncase AFMT_I2S:\r\nreg_write(priv, REG_MUX_AP, MUX_AP_SELECT_I2S);\r\nclksel_aip = AIP_CLKSEL_AIP_I2S;\r\nclksel_fs = AIP_CLKSEL_FS_ACLK;\r\ncts_n = CTS_N_M(3) | CTS_N_K(3);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nreg_write(priv, REG_AIP_CLKSEL, clksel_aip);\r\nreg_clear(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_LAYOUT |\r\nAIP_CNTRL_0_ACR_MAN);\r\nreg_write(priv, REG_CTS_N, cts_n);\r\nadiv = AUDIO_DIV_SERCLK_8;\r\nif (mode->clock > 100000)\r\nadiv++;\r\nif (p->audio_format == AFMT_SPDIF)\r\nadiv++;\r\nreg_write(priv, REG_AUDIO_DIV, adiv);\r\nn = 128 * p->audio_sample_rate / 1000;\r\nbuf[0] = 0x44;\r\nbuf[1] = 0x42;\r\nbuf[2] = 0x01;\r\nbuf[3] = n;\r\nbuf[4] = n >> 8;\r\nbuf[5] = n >> 16;\r\nreg_write_range(priv, REG_ACR_CTS_0, buf, 6);\r\nreg_write(priv, REG_AIP_CLKSEL, clksel_aip | clksel_fs);\r\nreg_set(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_CTS);\r\nreg_clear(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_CTS);\r\nbuf[0] = IEC958_AES0_CON_NOT_COPYRIGHT;\r\nbuf[1] = 0x00;\r\nbuf[2] = IEC958_AES3_CON_FS_NOTID;\r\nbuf[3] = IEC958_AES4_CON_ORIGFS_NOTID |\r\nIEC958_AES4_CON_MAX_WORDLEN_24;\r\nreg_write_range(priv, REG_CH_STAT_B(0), buf, 4);\r\ntda998x_audio_mute(priv, true);\r\nmsleep(20);\r\ntda998x_audio_mute(priv, false);\r\ntda998x_write_aif(priv, p);\r\n}\r\nstatic void tda998x_encoder_set_config(struct tda998x_priv *priv,\r\nconst struct tda998x_encoder_params *p)\r\n{\r\npriv->vip_cntrl_0 = VIP_CNTRL_0_SWAP_A(p->swap_a) |\r\n(p->mirr_a ? VIP_CNTRL_0_MIRR_A : 0) |\r\nVIP_CNTRL_0_SWAP_B(p->swap_b) |\r\n(p->mirr_b ? VIP_CNTRL_0_MIRR_B : 0);\r\npriv->vip_cntrl_1 = VIP_CNTRL_1_SWAP_C(p->swap_c) |\r\n(p->mirr_c ? VIP_CNTRL_1_MIRR_C : 0) |\r\nVIP_CNTRL_1_SWAP_D(p->swap_d) |\r\n(p->mirr_d ? VIP_CNTRL_1_MIRR_D : 0);\r\npriv->vip_cntrl_2 = VIP_CNTRL_2_SWAP_E(p->swap_e) |\r\n(p->mirr_e ? VIP_CNTRL_2_MIRR_E : 0) |\r\nVIP_CNTRL_2_SWAP_F(p->swap_f) |\r\n(p->mirr_f ? VIP_CNTRL_2_MIRR_F : 0);\r\npriv->params = *p;\r\n}\r\nstatic void tda998x_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct tda998x_priv *priv = enc_to_tda998x_priv(encoder);\r\nif (mode != DRM_MODE_DPMS_ON)\r\nmode = DRM_MODE_DPMS_OFF;\r\nif (mode == priv->dpms)\r\nreturn;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nreg_write(priv, REG_ENA_VP_0, 0xff);\r\nreg_write(priv, REG_ENA_VP_1, 0xff);\r\nreg_write(priv, REG_ENA_VP_2, 0xff);\r\nreg_write(priv, REG_VIP_CNTRL_0, priv->vip_cntrl_0);\r\nreg_write(priv, REG_VIP_CNTRL_1, priv->vip_cntrl_1);\r\nreg_write(priv, REG_VIP_CNTRL_2, priv->vip_cntrl_2);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nreg_write(priv, REG_ENA_VP_0, 0x00);\r\nreg_write(priv, REG_ENA_VP_1, 0x00);\r\nreg_write(priv, REG_ENA_VP_2, 0x00);\r\nbreak;\r\n}\r\npriv->dpms = mode;\r\n}\r\nstatic int tda998x_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct tda998x_priv *priv = conn_to_tda998x_priv(connector);\r\nif (mode->clock > ((priv->rev == TDA19988) ? 165000 : 150000))\r\nreturn MODE_CLOCK_HIGH;\r\nif (mode->htotal >= BIT(13))\r\nreturn MODE_BAD_HVALUE;\r\nif (mode->vtotal >= BIT(11))\r\nreturn MODE_BAD_VVALUE;\r\nreturn MODE_OK;\r\n}\r\nstatic void\r\ntda998x_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct tda998x_priv *priv = enc_to_tda998x_priv(encoder);\r\nu16 ref_pix, ref_line, n_pix, n_line;\r\nu16 hs_pix_s, hs_pix_e;\r\nu16 vs1_pix_s, vs1_pix_e, vs1_line_s, vs1_line_e;\r\nu16 vs2_pix_s, vs2_pix_e, vs2_line_s, vs2_line_e;\r\nu16 vwin1_line_s, vwin1_line_e;\r\nu16 vwin2_line_s, vwin2_line_e;\r\nu16 de_pix_s, de_pix_e;\r\nu8 reg, div, rep;\r\nn_pix = mode->htotal;\r\nn_line = mode->vtotal;\r\nhs_pix_e = mode->hsync_end - mode->hdisplay;\r\nhs_pix_s = mode->hsync_start - mode->hdisplay;\r\nde_pix_e = mode->htotal;\r\nde_pix_s = mode->htotal - mode->hdisplay;\r\nref_pix = 3 + hs_pix_s;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_HSKEW)\r\nref_pix += adjusted_mode->hskew;\r\nif ((mode->flags & DRM_MODE_FLAG_INTERLACE) == 0) {\r\nref_line = 1 + mode->vsync_start - mode->vdisplay;\r\nvwin1_line_s = mode->vtotal - mode->vdisplay - 1;\r\nvwin1_line_e = vwin1_line_s + mode->vdisplay;\r\nvs1_pix_s = vs1_pix_e = hs_pix_s;\r\nvs1_line_s = mode->vsync_start - mode->vdisplay;\r\nvs1_line_e = vs1_line_s +\r\nmode->vsync_end - mode->vsync_start;\r\nvwin2_line_s = vwin2_line_e = 0;\r\nvs2_pix_s = vs2_pix_e = 0;\r\nvs2_line_s = vs2_line_e = 0;\r\n} else {\r\nref_line = 1 + (mode->vsync_start - mode->vdisplay)/2;\r\nvwin1_line_s = (mode->vtotal - mode->vdisplay)/2;\r\nvwin1_line_e = vwin1_line_s + mode->vdisplay/2;\r\nvs1_pix_s = vs1_pix_e = hs_pix_s;\r\nvs1_line_s = (mode->vsync_start - mode->vdisplay)/2;\r\nvs1_line_e = vs1_line_s +\r\n(mode->vsync_end - mode->vsync_start)/2;\r\nvwin2_line_s = vwin1_line_s + mode->vtotal/2;\r\nvwin2_line_e = vwin2_line_s + mode->vdisplay/2;\r\nvs2_pix_s = vs2_pix_e = hs_pix_s + mode->htotal/2;\r\nvs2_line_s = vs1_line_s + mode->vtotal/2 ;\r\nvs2_line_e = vs2_line_s +\r\n(mode->vsync_end - mode->vsync_start)/2;\r\n}\r\ndiv = 148500 / mode->clock;\r\nif (div != 0) {\r\ndiv--;\r\nif (div > 3)\r\ndiv = 3;\r\n}\r\nreg_set(priv, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_FIFO);\r\nreg_write(priv, REG_TBG_CNTRL_1, TBG_CNTRL_1_DWIN_DIS);\r\nreg_clear(priv, REG_TX33, TX33_HDMI);\r\nreg_write(priv, REG_ENC_CNTRL, ENC_CNTRL_CTL_CODE(0));\r\nreg_write(priv, REG_HVF_CNTRL_0, HVF_CNTRL_0_PREFIL(0) |\r\nHVF_CNTRL_0_INTPOL(0));\r\nreg_write(priv, REG_VIP_CNTRL_5, VIP_CNTRL_5_SP_CNT(0));\r\nreg_write(priv, REG_VIP_CNTRL_4, VIP_CNTRL_4_BLANKIT(0) |\r\nVIP_CNTRL_4_BLC(0));\r\nreg_clear(priv, REG_PLL_SERIAL_1, PLL_SERIAL_1_SRL_MAN_IZ);\r\nreg_clear(priv, REG_PLL_SERIAL_3, PLL_SERIAL_3_SRL_CCIR |\r\nPLL_SERIAL_3_SRL_DE);\r\nreg_write(priv, REG_SERIALIZER, 0);\r\nreg_write(priv, REG_HVF_CNTRL_1, HVF_CNTRL_1_VQR(0));\r\nrep = 0;\r\nreg_write(priv, REG_RPT_CNTRL, 0);\r\nreg_write(priv, REG_SEL_CLK, SEL_CLK_SEL_VRF_CLK(0) |\r\nSEL_CLK_SEL_CLK1 | SEL_CLK_ENA_SC_CLK);\r\nreg_write(priv, REG_PLL_SERIAL_2, PLL_SERIAL_2_SRL_NOSC(div) |\r\nPLL_SERIAL_2_SRL_PR(rep));\r\nreg_write(priv, REG_MAT_CONTRL, MAT_CONTRL_MAT_BP |\r\nMAT_CONTRL_MAT_SC(1));\r\nreg_write(priv, REG_ANA_GENERAL, 0x09);\r\nreg = VIP_CNTRL_3_SYNC_HS;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nreg |= VIP_CNTRL_3_H_TGL;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nreg |= VIP_CNTRL_3_V_TGL;\r\nreg_write(priv, REG_VIP_CNTRL_3, reg);\r\nreg_write(priv, REG_VIDFORMAT, 0x00);\r\nreg_write16(priv, REG_REFPIX_MSB, ref_pix);\r\nreg_write16(priv, REG_REFLINE_MSB, ref_line);\r\nreg_write16(priv, REG_NPIX_MSB, n_pix);\r\nreg_write16(priv, REG_NLINE_MSB, n_line);\r\nreg_write16(priv, REG_VS_LINE_STRT_1_MSB, vs1_line_s);\r\nreg_write16(priv, REG_VS_PIX_STRT_1_MSB, vs1_pix_s);\r\nreg_write16(priv, REG_VS_LINE_END_1_MSB, vs1_line_e);\r\nreg_write16(priv, REG_VS_PIX_END_1_MSB, vs1_pix_e);\r\nreg_write16(priv, REG_VS_LINE_STRT_2_MSB, vs2_line_s);\r\nreg_write16(priv, REG_VS_PIX_STRT_2_MSB, vs2_pix_s);\r\nreg_write16(priv, REG_VS_LINE_END_2_MSB, vs2_line_e);\r\nreg_write16(priv, REG_VS_PIX_END_2_MSB, vs2_pix_e);\r\nreg_write16(priv, REG_HS_PIX_START_MSB, hs_pix_s);\r\nreg_write16(priv, REG_HS_PIX_STOP_MSB, hs_pix_e);\r\nreg_write16(priv, REG_VWIN_START_1_MSB, vwin1_line_s);\r\nreg_write16(priv, REG_VWIN_END_1_MSB, vwin1_line_e);\r\nreg_write16(priv, REG_VWIN_START_2_MSB, vwin2_line_s);\r\nreg_write16(priv, REG_VWIN_END_2_MSB, vwin2_line_e);\r\nreg_write16(priv, REG_DE_START_MSB, de_pix_s);\r\nreg_write16(priv, REG_DE_STOP_MSB, de_pix_e);\r\nif (priv->rev == TDA19988) {\r\nreg_write(priv, REG_ENABLE_SPACE, 0x00);\r\n}\r\nreg = TBG_CNTRL_1_DWIN_DIS | TBG_CNTRL_1_TGL_EN;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nreg |= TBG_CNTRL_1_H_TGL;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nreg |= TBG_CNTRL_1_V_TGL;\r\nreg_write(priv, REG_TBG_CNTRL_1, reg);\r\nreg_write(priv, REG_TBG_CNTRL_0, 0);\r\nif (priv->is_hdmi_sink) {\r\nreg &= ~TBG_CNTRL_1_DWIN_DIS;\r\nreg_write(priv, REG_TBG_CNTRL_1, reg);\r\nreg_write(priv, REG_ENC_CNTRL, ENC_CNTRL_CTL_CODE(1));\r\nreg_set(priv, REG_TX33, TX33_HDMI);\r\ntda998x_write_avi(priv, adjusted_mode);\r\nif (priv->params.audio_cfg)\r\ntda998x_configure_audio(priv, adjusted_mode,\r\n&priv->params);\r\n}\r\n}\r\nstatic enum drm_connector_status\r\ntda998x_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct tda998x_priv *priv = conn_to_tda998x_priv(connector);\r\nu8 val = cec_read(priv, REG_CEC_RXSHPDLEV);\r\nreturn (val & CEC_RXSHPDLEV_HPD) ? connector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nstatic int read_edid_block(void *data, u8 *buf, unsigned int blk, size_t length)\r\n{\r\nstruct tda998x_priv *priv = data;\r\nu8 offset, segptr;\r\nint ret, i;\r\noffset = (blk & 1) ? 128 : 0;\r\nsegptr = blk / 2;\r\nreg_write(priv, REG_DDC_ADDR, 0xa0);\r\nreg_write(priv, REG_DDC_OFFS, offset);\r\nreg_write(priv, REG_DDC_SEGM_ADDR, 0x60);\r\nreg_write(priv, REG_DDC_SEGM, segptr);\r\npriv->wq_edid_wait = 1;\r\nreg_write(priv, REG_EDID_CTRL, 0x1);\r\nreg_write(priv, REG_EDID_CTRL, 0x0);\r\nif (priv->hdmi->irq) {\r\ni = wait_event_timeout(priv->wq_edid,\r\n!priv->wq_edid_wait,\r\nmsecs_to_jiffies(100));\r\nif (i < 0) {\r\ndev_err(&priv->hdmi->dev, "read edid wait err %d\n", i);\r\nreturn i;\r\n}\r\n} else {\r\nfor (i = 100; i > 0; i--) {\r\nmsleep(1);\r\nret = reg_read(priv, REG_INT_FLAGS_2);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & INT_FLAGS_2_EDID_BLK_RD)\r\nbreak;\r\n}\r\n}\r\nif (i == 0) {\r\ndev_err(&priv->hdmi->dev, "read edid timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = reg_read_range(priv, REG_EDID_DATA_0, buf, length);\r\nif (ret != length) {\r\ndev_err(&priv->hdmi->dev, "failed to read edid block %d: %d\n",\r\nblk, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda998x_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct tda998x_priv *priv = conn_to_tda998x_priv(connector);\r\nstruct edid *edid;\r\nint n;\r\nif (tda998x_edid_delay_wait(priv))\r\nreturn 0;\r\nif (priv->rev == TDA19988)\r\nreg_clear(priv, REG_TX4, TX4_PD_RAM);\r\nedid = drm_do_get_edid(connector, read_edid_block, priv);\r\nif (priv->rev == TDA19988)\r\nreg_set(priv, REG_TX4, TX4_PD_RAM);\r\nif (!edid) {\r\ndev_warn(&priv->hdmi->dev, "failed to read EDID\n");\r\nreturn 0;\r\n}\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nn = drm_add_edid_modes(connector, edid);\r\npriv->is_hdmi_sink = drm_detect_hdmi_monitor(edid);\r\nkfree(edid);\r\nreturn n;\r\n}\r\nstatic void tda998x_encoder_set_polling(struct tda998x_priv *priv,\r\nstruct drm_connector *connector)\r\n{\r\nif (priv->hdmi->irq)\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nelse\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\n}\r\nstatic void tda998x_destroy(struct tda998x_priv *priv)\r\n{\r\ncec_write(priv, REG_CEC_RXSHPDINTENA, 0);\r\nreg_clear(priv, REG_INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);\r\nif (priv->hdmi->irq)\r\nfree_irq(priv->hdmi->irq, priv);\r\ndel_timer_sync(&priv->edid_delay_timer);\r\ncancel_work_sync(&priv->detect_work);\r\ni2c_unregister_device(priv->cec);\r\n}\r\nstatic int tda998x_create(struct i2c_client *client, struct tda998x_priv *priv)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nu32 video;\r\nint rev_lo, rev_hi, ret;\r\nunsigned short cec_addr;\r\npriv->vip_cntrl_0 = VIP_CNTRL_0_SWAP_A(2) | VIP_CNTRL_0_SWAP_B(3);\r\npriv->vip_cntrl_1 = VIP_CNTRL_1_SWAP_C(0) | VIP_CNTRL_1_SWAP_D(1);\r\npriv->vip_cntrl_2 = VIP_CNTRL_2_SWAP_E(4) | VIP_CNTRL_2_SWAP_F(5);\r\npriv->current_page = 0xff;\r\npriv->hdmi = client;\r\ncec_addr = 0x34 + (client->addr & 0x03);\r\npriv->cec = i2c_new_dummy(client->adapter, cec_addr);\r\nif (!priv->cec)\r\nreturn -ENODEV;\r\npriv->dpms = DRM_MODE_DPMS_OFF;\r\nmutex_init(&priv->mutex);\r\ninit_waitqueue_head(&priv->edid_delay_waitq);\r\nsetup_timer(&priv->edid_delay_timer, tda998x_edid_delay_done,\r\n(unsigned long)priv);\r\nINIT_WORK(&priv->detect_work, tda998x_detect_work);\r\ncec_write(priv, REG_CEC_ENAMODS,\r\nCEC_ENAMODS_EN_RXSENS | CEC_ENAMODS_EN_HDMI);\r\ntda998x_reset(priv);\r\nrev_lo = reg_read(priv, REG_VERSION_LSB);\r\nrev_hi = reg_read(priv, REG_VERSION_MSB);\r\nif (rev_lo < 0 || rev_hi < 0) {\r\nret = rev_lo < 0 ? rev_lo : rev_hi;\r\ngoto fail;\r\n}\r\npriv->rev = rev_lo | rev_hi << 8;\r\npriv->rev &= ~0x30;\r\nswitch (priv->rev) {\r\ncase TDA9989N2:\r\ndev_info(&client->dev, "found TDA9989 n2");\r\nbreak;\r\ncase TDA19989:\r\ndev_info(&client->dev, "found TDA19989");\r\nbreak;\r\ncase TDA19989N2:\r\ndev_info(&client->dev, "found TDA19989 n2");\r\nbreak;\r\ncase TDA19988:\r\ndev_info(&client->dev, "found TDA19988");\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "found unsupported device: %04x\n",\r\npriv->rev);\r\ngoto fail;\r\n}\r\nreg_write(priv, REG_DDC_DISABLE, 0x00);\r\nreg_write(priv, REG_TX3, 39);\r\nif (priv->rev == TDA19989)\r\nreg_set(priv, REG_I2C_MASTER, I2C_MASTER_DIS_MM);\r\ncec_write(priv, REG_CEC_FRO_IM_CLK_CTRL,\r\nCEC_FRO_IM_CLK_CTRL_GHOST_DIS | CEC_FRO_IM_CLK_CTRL_IMCLK_SEL);\r\nif (client->irq) {\r\nint irqf_trigger;\r\ninit_waitqueue_head(&priv->wq_edid);\r\nreg_read(priv, REG_INT_FLAGS_0);\r\nreg_read(priv, REG_INT_FLAGS_1);\r\nreg_read(priv, REG_INT_FLAGS_2);\r\nirqf_trigger =\r\nirqd_get_trigger_type(irq_get_irq_data(client->irq));\r\nret = request_threaded_irq(client->irq, NULL,\r\ntda998x_irq_thread,\r\nirqf_trigger | IRQF_ONESHOT,\r\n"tda998x", priv);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"failed to request IRQ#%u: %d\n",\r\nclient->irq, ret);\r\ngoto fail;\r\n}\r\ncec_write(priv, REG_CEC_RXSHPDINTENA, CEC_RXSHPDLEV_HPD);\r\n}\r\nreg_set(priv, REG_INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);\r\nif (!np)\r\nreturn 0;\r\nret = of_property_read_u32(np, "video-ports", &video);\r\nif (ret == 0) {\r\npriv->vip_cntrl_0 = video >> 16;\r\npriv->vip_cntrl_1 = video >> 8;\r\npriv->vip_cntrl_2 = video;\r\n}\r\nreturn 0;\r\nfail:\r\nif (priv->cec)\r\ni2c_unregister_device(priv->cec);\r\nreturn -ENXIO;\r\n}\r\nstatic void tda998x_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\ntda998x_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void tda998x_encoder_commit(struct drm_encoder *encoder)\r\n{\r\ntda998x_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nstatic void tda998x_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct tda998x_priv *priv = enc_to_tda998x_priv(encoder);\r\ntda998x_destroy(priv);\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic struct drm_encoder *\r\ntda998x_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct tda998x_priv *priv = conn_to_tda998x_priv(connector);\r\nreturn &priv->encoder;\r\n}\r\nstatic void tda998x_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int tda998x_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\nif (drm_core_check_feature(connector->dev, DRIVER_ATOMIC))\r\nreturn drm_atomic_helper_connector_dpms(connector, mode);\r\nelse\r\nreturn drm_helper_connector_dpms(connector, mode);\r\n}\r\nstatic int tda998x_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct tda998x_encoder_params *params = dev->platform_data;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct drm_device *drm = data;\r\nstruct tda998x_priv *priv;\r\nu32 crtcs = 0;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, priv);\r\nif (dev->of_node)\r\ncrtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\r\nif (crtcs == 0) {\r\ndev_warn(dev, "Falling back to first CRTC\n");\r\ncrtcs = 1 << 0;\r\n}\r\npriv->connector.interlace_allowed = 1;\r\npriv->encoder.possible_crtcs = crtcs;\r\nret = tda998x_create(client, priv);\r\nif (ret)\r\nreturn ret;\r\nif (!dev->of_node && params)\r\ntda998x_encoder_set_config(priv, params);\r\ntda998x_encoder_set_polling(priv, &priv->connector);\r\ndrm_encoder_helper_add(&priv->encoder, &tda998x_encoder_helper_funcs);\r\nret = drm_encoder_init(drm, &priv->encoder, &tda998x_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\nif (ret)\r\ngoto err_encoder;\r\ndrm_connector_helper_add(&priv->connector,\r\n&tda998x_connector_helper_funcs);\r\nret = drm_connector_init(drm, &priv->connector,\r\n&tda998x_connector_funcs,\r\nDRM_MODE_CONNECTOR_HDMIA);\r\nif (ret)\r\ngoto err_connector;\r\nret = drm_connector_register(&priv->connector);\r\nif (ret)\r\ngoto err_sysfs;\r\ndrm_mode_connector_attach_encoder(&priv->connector, &priv->encoder);\r\nreturn 0;\r\nerr_sysfs:\r\ndrm_connector_cleanup(&priv->connector);\r\nerr_connector:\r\ndrm_encoder_cleanup(&priv->encoder);\r\nerr_encoder:\r\ntda998x_destroy(priv);\r\nreturn ret;\r\n}\r\nstatic void tda998x_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct tda998x_priv *priv = dev_get_drvdata(dev);\r\ndrm_connector_unregister(&priv->connector);\r\ndrm_connector_cleanup(&priv->connector);\r\ndrm_encoder_cleanup(&priv->encoder);\r\ntda998x_destroy(priv);\r\n}\r\nstatic int\r\ntda998x_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nreturn component_add(&client->dev, &tda998x_ops);\r\n}\r\nstatic int tda998x_remove(struct i2c_client *client)\r\n{\r\ncomponent_del(&client->dev, &tda998x_ops);\r\nreturn 0;\r\n}
