static bool ads1015_is_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn (reg == ADS1015_CFG_REG);\r\n}\r\nstatic int ads1015_set_power_state(struct ads1015_data *data, bool on)\r\n{\r\nint ret;\r\nstruct device *dev = regmap_get_device(data->regmap);\r\nif (on) {\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0)\r\npm_runtime_put_noidle(dev);\r\n} else {\r\npm_runtime_mark_last_busy(dev);\r\nret = pm_runtime_put_autosuspend(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic\r\nint ads1015_get_adc_result(struct ads1015_data *data, int chan, int *val)\r\n{\r\nint ret, pga, dr, conv_time;\r\nbool change;\r\nif (chan < 0 || chan >= ADS1015_CHANNELS)\r\nreturn -EINVAL;\r\npga = data->channel_data[chan].pga;\r\ndr = data->channel_data[chan].data_rate;\r\nret = regmap_update_bits_check(data->regmap, ADS1015_CFG_REG,\r\nADS1015_CFG_MUX_MASK |\r\nADS1015_CFG_PGA_MASK,\r\nchan << ADS1015_CFG_MUX_SHIFT |\r\npga << ADS1015_CFG_PGA_SHIFT,\r\n&change);\r\nif (ret < 0)\r\nreturn ret;\r\nif (change) {\r\nconv_time = DIV_ROUND_UP(USEC_PER_SEC, ads1015_data_rate[dr]);\r\nusleep_range(conv_time, conv_time + 1);\r\n}\r\nreturn regmap_read(data->regmap, ADS1015_CONV_REG, val);\r\n}\r\nstatic irqreturn_t ads1015_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct ads1015_data *data = iio_priv(indio_dev);\r\ns16 buf[8];\r\nint chan, ret, res;\r\nmemset(buf, 0, sizeof(buf));\r\nmutex_lock(&data->lock);\r\nchan = find_first_bit(indio_dev->active_scan_mask,\r\nindio_dev->masklength);\r\nret = ads1015_get_adc_result(data, chan, &res);\r\nif (ret < 0) {\r\nmutex_unlock(&data->lock);\r\ngoto err;\r\n}\r\nbuf[0] = res;\r\nmutex_unlock(&data->lock);\r\niio_push_to_buffers_with_timestamp(indio_dev, buf, iio_get_time_ns());\r\nerr:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ads1015_set_scale(struct ads1015_data *data, int chan,\r\nint scale, int uscale)\r\n{\r\nint i, ret, rindex = -1;\r\nfor (i = 0; i < ARRAY_SIZE(ads1015_scale); i++)\r\nif (ads1015_scale[i].scale == scale &&\r\nads1015_scale[i].uscale == uscale) {\r\nrindex = i;\r\nbreak;\r\n}\r\nif (rindex < 0)\r\nreturn -EINVAL;\r\nret = regmap_update_bits(data->regmap, ADS1015_CFG_REG,\r\nADS1015_CFG_PGA_MASK,\r\nrindex << ADS1015_CFG_PGA_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->channel_data[chan].pga = rindex;\r\nreturn 0;\r\n}\r\nstatic int ads1015_set_data_rate(struct ads1015_data *data, int chan, int rate)\r\n{\r\nint i, ret, rindex = -1;\r\nfor (i = 0; i < ARRAY_SIZE(ads1015_data_rate); i++)\r\nif (ads1015_data_rate[i] == rate) {\r\nrindex = i;\r\nbreak;\r\n}\r\nif (rindex < 0)\r\nreturn -EINVAL;\r\nret = regmap_update_bits(data->regmap, ADS1015_CFG_REG,\r\nADS1015_CFG_DR_MASK,\r\nrindex << ADS1015_CFG_DR_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->channel_data[chan].data_rate = rindex;\r\nreturn 0;\r\n}\r\nstatic int ads1015_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nint ret, idx;\r\nstruct ads1015_data *data = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\nmutex_lock(&data->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (iio_buffer_enabled(indio_dev)) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nret = ads1015_set_power_state(data, true);\r\nif (ret < 0)\r\nbreak;\r\nret = ads1015_get_adc_result(data, chan->address, val);\r\nif (ret < 0) {\r\nads1015_set_power_state(data, false);\r\nbreak;\r\n}\r\n*val = sign_extend32(*val >> 4, 11);\r\nret = ads1015_set_power_state(data, false);\r\nif (ret < 0)\r\nbreak;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nidx = data->channel_data[chan->address].pga;\r\n*val = ads1015_scale[idx].scale;\r\n*val2 = ads1015_scale[idx].uscale;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nidx = data->channel_data[chan->address].data_rate;\r\n*val = ads1015_data_rate[idx];\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&data->lock);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ads1015_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val,\r\nint val2, long mask)\r\n{\r\nstruct ads1015_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = ads1015_set_scale(data, chan->address, val, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nret = ads1015_set_data_rate(data, chan->address, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int ads1015_buffer_preenable(struct iio_dev *indio_dev)\r\n{\r\nreturn ads1015_set_power_state(iio_priv(indio_dev), true);\r\n}\r\nstatic int ads1015_buffer_postdisable(struct iio_dev *indio_dev)\r\n{\r\nreturn ads1015_set_power_state(iio_priv(indio_dev), false);\r\n}\r\nstatic int ads1015_get_channels_config_of(struct i2c_client *client)\r\n{\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nstruct device_node *node;\r\nif (!client->dev.of_node ||\r\n!of_get_next_child(client->dev.of_node, NULL))\r\nreturn -EINVAL;\r\nfor_each_child_of_node(client->dev.of_node, node) {\r\nu32 pval;\r\nunsigned int channel;\r\nunsigned int pga = ADS1015_DEFAULT_PGA;\r\nunsigned int data_rate = ADS1015_DEFAULT_DATA_RATE;\r\nif (of_property_read_u32(node, "reg", &pval)) {\r\ndev_err(&client->dev, "invalid reg on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\nchannel = pval;\r\nif (channel >= ADS1015_CHANNELS) {\r\ndev_err(&client->dev,\r\n"invalid channel index %d on %s\n",\r\nchannel, node->full_name);\r\ncontinue;\r\n}\r\nif (!of_property_read_u32(node, "ti,gain", &pval)) {\r\npga = pval;\r\nif (pga > 6) {\r\ndev_err(&client->dev, "invalid gain on %s\n",\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!of_property_read_u32(node, "ti,datarate", &pval)) {\r\ndata_rate = pval;\r\nif (data_rate > 7) {\r\ndev_err(&client->dev,\r\n"invalid data_rate on %s\n",\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndata->channel_data[channel].pga = pga;\r\ndata->channel_data[channel].data_rate = data_rate;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ads1015_get_channels_config(struct i2c_client *client)\r\n{\r\nunsigned int k;\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ads1015_data *data = iio_priv(indio_dev);\r\nstruct ads1015_platform_data *pdata = dev_get_platdata(&client->dev);\r\nif (pdata) {\r\nmemcpy(data->channel_data, pdata->channel_data,\r\nsizeof(data->channel_data));\r\nreturn;\r\n}\r\n#ifdef CONFIG_OF\r\nif (!ads1015_get_channels_config_of(client))\r\nreturn;\r\n#endif\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k) {\r\ndata->channel_data[k].pga = ADS1015_DEFAULT_PGA;\r\ndata->channel_data[k].data_rate = ADS1015_DEFAULT_DATA_RATE;\r\n}\r\n}\r\nstatic int ads1015_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct ads1015_data *data;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nmutex_init(&data->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &ads1015_info;\r\nindio_dev->name = ADS1015_DRV_NAME;\r\nindio_dev->channels = ads1015_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ads1015_channels);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nads1015_get_channels_config(client);\r\ndata->regmap = devm_regmap_init_i2c(client, &ads1015_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\ndev_err(&client->dev, "Failed to allocate register map\n");\r\nreturn PTR_ERR(data->regmap);\r\n}\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\nads1015_trigger_handler,\r\n&ads1015_buffer_setup_ops);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "iio triggered buffer setup failed\n");\r\nreturn ret;\r\n}\r\nret = pm_runtime_set_active(&client->dev);\r\nif (ret)\r\ngoto err_buffer_cleanup;\r\npm_runtime_set_autosuspend_delay(&client->dev, ADS1015_SLEEP_DELAY_MS);\r\npm_runtime_use_autosuspend(&client->dev);\r\npm_runtime_enable(&client->dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to register IIO device\n");\r\ngoto err_buffer_cleanup;\r\n}\r\nreturn 0;\r\nerr_buffer_cleanup:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int ads1015_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ads1015_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn regmap_update_bits(data->regmap, ADS1015_CFG_REG,\r\nADS1015_CFG_MOD_MASK,\r\nADS1015_SINGLESHOT << ADS1015_CFG_MOD_SHIFT);\r\n}\r\nstatic int ads1015_runtime_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct ads1015_data *data = iio_priv(indio_dev);\r\nreturn regmap_update_bits(data->regmap, ADS1015_CFG_REG,\r\nADS1015_CFG_MOD_MASK,\r\nADS1015_SINGLESHOT << ADS1015_CFG_MOD_SHIFT);\r\n}\r\nstatic int ads1015_runtime_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct ads1015_data *data = iio_priv(indio_dev);\r\nreturn regmap_update_bits(data->regmap, ADS1015_CFG_REG,\r\nADS1015_CFG_MOD_MASK,\r\nADS1015_CONTINUOUS << ADS1015_CFG_MOD_SHIFT);\r\n}
