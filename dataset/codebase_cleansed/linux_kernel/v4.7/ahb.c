static inline struct ath10k_ahb *ath10k_ahb_priv(struct ath10k *ar)\r\n{\r\nreturn &((struct ath10k_pci *)ar->drv_priv)->ahb[0];\r\n}\r\nstatic void ath10k_ahb_write32(struct ath10k *ar, u32 offset, u32 value)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\niowrite32(value, ar_ahb->mem + offset);\r\n}\r\nstatic u32 ath10k_ahb_read32(struct ath10k *ar, u32 offset)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nreturn ioread32(ar_ahb->mem + offset);\r\n}\r\nstatic u32 ath10k_ahb_gcc_read32(struct ath10k *ar, u32 offset)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nreturn ioread32(ar_ahb->gcc_mem + offset);\r\n}\r\nstatic void ath10k_ahb_tcsr_write32(struct ath10k *ar, u32 offset, u32 value)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\niowrite32(value, ar_ahb->tcsr_mem + offset);\r\n}\r\nstatic u32 ath10k_ahb_tcsr_read32(struct ath10k *ar, u32 offset)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nreturn ioread32(ar_ahb->tcsr_mem + offset);\r\n}\r\nstatic u32 ath10k_ahb_soc_read32(struct ath10k *ar, u32 addr)\r\n{\r\nreturn ath10k_ahb_read32(ar, RTC_SOC_BASE_ADDRESS + addr);\r\n}\r\nstatic int ath10k_ahb_get_num_banks(struct ath10k *ar)\r\n{\r\nif (ar->hw_rev == ATH10K_HW_QCA4019)\r\nreturn 1;\r\nath10k_warn(ar, "unknown number of banks, assuming 1\n");\r\nreturn 1;\r\n}\r\nstatic int ath10k_ahb_clock_init(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nstruct device *dev;\r\nint ret;\r\ndev = &ar_ahb->pdev->dev;\r\nar_ahb->cmd_clk = clk_get(dev, "wifi_wcss_cmd");\r\nif (IS_ERR_OR_NULL(ar_ahb->cmd_clk)) {\r\nath10k_err(ar, "failed to get cmd clk: %ld\n",\r\nPTR_ERR(ar_ahb->cmd_clk));\r\nret = ar_ahb->cmd_clk ? PTR_ERR(ar_ahb->cmd_clk) : -ENODEV;\r\ngoto out;\r\n}\r\nar_ahb->ref_clk = clk_get(dev, "wifi_wcss_ref");\r\nif (IS_ERR_OR_NULL(ar_ahb->ref_clk)) {\r\nath10k_err(ar, "failed to get ref clk: %ld\n",\r\nPTR_ERR(ar_ahb->ref_clk));\r\nret = ar_ahb->ref_clk ? PTR_ERR(ar_ahb->ref_clk) : -ENODEV;\r\ngoto err_cmd_clk_put;\r\n}\r\nar_ahb->rtc_clk = clk_get(dev, "wifi_wcss_rtc");\r\nif (IS_ERR_OR_NULL(ar_ahb->rtc_clk)) {\r\nath10k_err(ar, "failed to get rtc clk: %ld\n",\r\nPTR_ERR(ar_ahb->rtc_clk));\r\nret = ar_ahb->rtc_clk ? PTR_ERR(ar_ahb->rtc_clk) : -ENODEV;\r\ngoto err_ref_clk_put;\r\n}\r\nreturn 0;\r\nerr_ref_clk_put:\r\nclk_put(ar_ahb->ref_clk);\r\nerr_cmd_clk_put:\r\nclk_put(ar_ahb->cmd_clk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ath10k_ahb_clock_deinit(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nif (!IS_ERR_OR_NULL(ar_ahb->cmd_clk))\r\nclk_put(ar_ahb->cmd_clk);\r\nif (!IS_ERR_OR_NULL(ar_ahb->ref_clk))\r\nclk_put(ar_ahb->ref_clk);\r\nif (!IS_ERR_OR_NULL(ar_ahb->rtc_clk))\r\nclk_put(ar_ahb->rtc_clk);\r\nar_ahb->cmd_clk = NULL;\r\nar_ahb->ref_clk = NULL;\r\nar_ahb->rtc_clk = NULL;\r\n}\r\nstatic int ath10k_ahb_clock_enable(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nstruct device *dev;\r\nint ret;\r\ndev = &ar_ahb->pdev->dev;\r\nif (IS_ERR_OR_NULL(ar_ahb->cmd_clk) ||\r\nIS_ERR_OR_NULL(ar_ahb->ref_clk) ||\r\nIS_ERR_OR_NULL(ar_ahb->rtc_clk)) {\r\nath10k_err(ar, "clock(s) is/are not initialized\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(ar_ahb->cmd_clk);\r\nif (ret) {\r\nath10k_err(ar, "failed to enable cmd clk: %d\n", ret);\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(ar_ahb->ref_clk);\r\nif (ret) {\r\nath10k_err(ar, "failed to enable ref clk: %d\n", ret);\r\ngoto err_cmd_clk_disable;\r\n}\r\nret = clk_prepare_enable(ar_ahb->rtc_clk);\r\nif (ret) {\r\nath10k_err(ar, "failed to enable rtc clk: %d\n", ret);\r\ngoto err_ref_clk_disable;\r\n}\r\nreturn 0;\r\nerr_ref_clk_disable:\r\nclk_disable_unprepare(ar_ahb->ref_clk);\r\nerr_cmd_clk_disable:\r\nclk_disable_unprepare(ar_ahb->cmd_clk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ath10k_ahb_clock_disable(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nif (!IS_ERR_OR_NULL(ar_ahb->cmd_clk))\r\nclk_disable_unprepare(ar_ahb->cmd_clk);\r\nif (!IS_ERR_OR_NULL(ar_ahb->ref_clk))\r\nclk_disable_unprepare(ar_ahb->ref_clk);\r\nif (!IS_ERR_OR_NULL(ar_ahb->rtc_clk))\r\nclk_disable_unprepare(ar_ahb->rtc_clk);\r\n}\r\nstatic int ath10k_ahb_rst_ctrl_init(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nstruct device *dev;\r\nint ret;\r\ndev = &ar_ahb->pdev->dev;\r\nar_ahb->core_cold_rst = reset_control_get(dev, "wifi_core_cold");\r\nif (IS_ERR_OR_NULL(ar_ahb->core_cold_rst)) {\r\nath10k_err(ar, "failed to get core cold rst ctrl: %ld\n",\r\nPTR_ERR(ar_ahb->core_cold_rst));\r\nret = ar_ahb->core_cold_rst ?\r\nPTR_ERR(ar_ahb->core_cold_rst) : -ENODEV;\r\ngoto out;\r\n}\r\nar_ahb->radio_cold_rst = reset_control_get(dev, "wifi_radio_cold");\r\nif (IS_ERR_OR_NULL(ar_ahb->radio_cold_rst)) {\r\nath10k_err(ar, "failed to get radio cold rst ctrl: %ld\n",\r\nPTR_ERR(ar_ahb->radio_cold_rst));\r\nret = ar_ahb->radio_cold_rst ?\r\nPTR_ERR(ar_ahb->radio_cold_rst) : -ENODEV;\r\ngoto err_core_cold_rst_put;\r\n}\r\nar_ahb->radio_warm_rst = reset_control_get(dev, "wifi_radio_warm");\r\nif (IS_ERR_OR_NULL(ar_ahb->radio_warm_rst)) {\r\nath10k_err(ar, "failed to get radio warm rst ctrl: %ld\n",\r\nPTR_ERR(ar_ahb->radio_warm_rst));\r\nret = ar_ahb->radio_warm_rst ?\r\nPTR_ERR(ar_ahb->radio_warm_rst) : -ENODEV;\r\ngoto err_radio_cold_rst_put;\r\n}\r\nar_ahb->radio_srif_rst = reset_control_get(dev, "wifi_radio_srif");\r\nif (IS_ERR_OR_NULL(ar_ahb->radio_srif_rst)) {\r\nath10k_err(ar, "failed to get radio srif rst ctrl: %ld\n",\r\nPTR_ERR(ar_ahb->radio_srif_rst));\r\nret = ar_ahb->radio_srif_rst ?\r\nPTR_ERR(ar_ahb->radio_srif_rst) : -ENODEV;\r\ngoto err_radio_warm_rst_put;\r\n}\r\nar_ahb->cpu_init_rst = reset_control_get(dev, "wifi_cpu_init");\r\nif (IS_ERR_OR_NULL(ar_ahb->cpu_init_rst)) {\r\nath10k_err(ar, "failed to get cpu init rst ctrl: %ld\n",\r\nPTR_ERR(ar_ahb->cpu_init_rst));\r\nret = ar_ahb->cpu_init_rst ?\r\nPTR_ERR(ar_ahb->cpu_init_rst) : -ENODEV;\r\ngoto err_radio_srif_rst_put;\r\n}\r\nreturn 0;\r\nerr_radio_srif_rst_put:\r\nreset_control_put(ar_ahb->radio_srif_rst);\r\nerr_radio_warm_rst_put:\r\nreset_control_put(ar_ahb->radio_warm_rst);\r\nerr_radio_cold_rst_put:\r\nreset_control_put(ar_ahb->radio_cold_rst);\r\nerr_core_cold_rst_put:\r\nreset_control_put(ar_ahb->core_cold_rst);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ath10k_ahb_rst_ctrl_deinit(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nif (!IS_ERR_OR_NULL(ar_ahb->core_cold_rst))\r\nreset_control_put(ar_ahb->core_cold_rst);\r\nif (!IS_ERR_OR_NULL(ar_ahb->radio_cold_rst))\r\nreset_control_put(ar_ahb->radio_cold_rst);\r\nif (!IS_ERR_OR_NULL(ar_ahb->radio_warm_rst))\r\nreset_control_put(ar_ahb->radio_warm_rst);\r\nif (!IS_ERR_OR_NULL(ar_ahb->radio_srif_rst))\r\nreset_control_put(ar_ahb->radio_srif_rst);\r\nif (!IS_ERR_OR_NULL(ar_ahb->cpu_init_rst))\r\nreset_control_put(ar_ahb->cpu_init_rst);\r\nar_ahb->core_cold_rst = NULL;\r\nar_ahb->radio_cold_rst = NULL;\r\nar_ahb->radio_warm_rst = NULL;\r\nar_ahb->radio_srif_rst = NULL;\r\nar_ahb->cpu_init_rst = NULL;\r\n}\r\nstatic int ath10k_ahb_release_reset(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nint ret;\r\nif (IS_ERR_OR_NULL(ar_ahb->radio_cold_rst) ||\r\nIS_ERR_OR_NULL(ar_ahb->radio_warm_rst) ||\r\nIS_ERR_OR_NULL(ar_ahb->radio_srif_rst) ||\r\nIS_ERR_OR_NULL(ar_ahb->cpu_init_rst)) {\r\nath10k_err(ar, "rst ctrl(s) is/are not initialized\n");\r\nreturn -EINVAL;\r\n}\r\nret = reset_control_deassert(ar_ahb->radio_cold_rst);\r\nif (ret) {\r\nath10k_err(ar, "failed to deassert radio cold rst: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = reset_control_deassert(ar_ahb->radio_warm_rst);\r\nif (ret) {\r\nath10k_err(ar, "failed to deassert radio warm rst: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = reset_control_deassert(ar_ahb->radio_srif_rst);\r\nif (ret) {\r\nath10k_err(ar, "failed to deassert radio srif rst: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = reset_control_deassert(ar_ahb->cpu_init_rst);\r\nif (ret) {\r\nath10k_err(ar, "failed to deassert cpu init rst: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath10k_ahb_halt_axi_bus(struct ath10k *ar, u32 haltreq_reg,\r\nu32 haltack_reg)\r\n{\r\nunsigned long timeout;\r\nu32 val;\r\nval = ath10k_ahb_tcsr_read32(ar, haltreq_reg);\r\nval |= AHB_AXI_BUS_HALT_REQ;\r\nath10k_ahb_tcsr_write32(ar, haltreq_reg, val);\r\ntimeout = jiffies + msecs_to_jiffies(ATH10K_AHB_AXI_BUS_HALT_TIMEOUT);\r\ndo {\r\nval = ath10k_ahb_tcsr_read32(ar, haltack_reg);\r\nif (val & AHB_AXI_BUS_HALT_ACK)\r\nbreak;\r\nmdelay(1);\r\n} while (time_before(jiffies, timeout));\r\nif (!(val & AHB_AXI_BUS_HALT_ACK)) {\r\nath10k_err(ar, "failed to halt axi bus: %d\n", val);\r\nreturn;\r\n}\r\nath10k_dbg(ar, ATH10K_DBG_AHB, "axi bus halted\n");\r\n}\r\nstatic void ath10k_ahb_halt_chip(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nu32 core_id, glb_cfg_reg, haltreq_reg, haltack_reg;\r\nu32 val;\r\nint ret;\r\nif (IS_ERR_OR_NULL(ar_ahb->core_cold_rst) ||\r\nIS_ERR_OR_NULL(ar_ahb->radio_cold_rst) ||\r\nIS_ERR_OR_NULL(ar_ahb->radio_warm_rst) ||\r\nIS_ERR_OR_NULL(ar_ahb->radio_srif_rst) ||\r\nIS_ERR_OR_NULL(ar_ahb->cpu_init_rst)) {\r\nath10k_err(ar, "rst ctrl(s) is/are not initialized\n");\r\nreturn;\r\n}\r\ncore_id = ath10k_ahb_read32(ar, ATH10K_AHB_WLAN_CORE_ID_REG);\r\nswitch (core_id) {\r\ncase 0:\r\nglb_cfg_reg = ATH10K_AHB_TCSR_WIFI0_GLB_CFG;\r\nhaltreq_reg = ATH10K_AHB_TCSR_WCSS0_HALTREQ;\r\nhaltack_reg = ATH10K_AHB_TCSR_WCSS0_HALTACK;\r\nbreak;\r\ncase 1:\r\nglb_cfg_reg = ATH10K_AHB_TCSR_WIFI1_GLB_CFG;\r\nhaltreq_reg = ATH10K_AHB_TCSR_WCSS1_HALTREQ;\r\nhaltack_reg = ATH10K_AHB_TCSR_WCSS1_HALTACK;\r\nbreak;\r\ndefault:\r\nath10k_err(ar, "invalid core id %d found, skipping reset sequence\n",\r\ncore_id);\r\nreturn;\r\n}\r\nath10k_ahb_halt_axi_bus(ar, haltreq_reg, haltack_reg);\r\nval = ath10k_ahb_tcsr_read32(ar, glb_cfg_reg);\r\nval |= TCSR_WIFIX_GLB_CFG_DISABLE_CORE_CLK;\r\nath10k_ahb_tcsr_write32(ar, glb_cfg_reg, val);\r\nret = reset_control_assert(ar_ahb->core_cold_rst);\r\nif (ret)\r\nath10k_err(ar, "failed to assert core cold rst: %d\n", ret);\r\nmsleep(1);\r\nret = reset_control_assert(ar_ahb->radio_cold_rst);\r\nif (ret)\r\nath10k_err(ar, "failed to assert radio cold rst: %d\n", ret);\r\nmsleep(1);\r\nret = reset_control_assert(ar_ahb->radio_warm_rst);\r\nif (ret)\r\nath10k_err(ar, "failed to assert radio warm rst: %d\n", ret);\r\nmsleep(1);\r\nret = reset_control_assert(ar_ahb->radio_srif_rst);\r\nif (ret)\r\nath10k_err(ar, "failed to assert radio srif rst: %d\n", ret);\r\nmsleep(1);\r\nret = reset_control_assert(ar_ahb->cpu_init_rst);\r\nif (ret)\r\nath10k_err(ar, "failed to assert cpu init rst: %d\n", ret);\r\nmsleep(10);\r\nval = ath10k_ahb_tcsr_read32(ar, haltreq_reg);\r\nval &= ~AHB_AXI_BUS_HALT_REQ;\r\nath10k_ahb_tcsr_write32(ar, haltreq_reg, val);\r\nval = ath10k_ahb_tcsr_read32(ar, glb_cfg_reg);\r\nval &= ~TCSR_WIFIX_GLB_CFG_DISABLE_CORE_CLK;\r\nath10k_ahb_tcsr_write32(ar, glb_cfg_reg, val);\r\nret = reset_control_deassert(ar_ahb->core_cold_rst);\r\nif (ret)\r\nath10k_err(ar, "failed to deassert core cold rst: %d\n", ret);\r\nath10k_dbg(ar, ATH10K_DBG_AHB, "core %d reset done\n", core_id);\r\n}\r\nstatic irqreturn_t ath10k_ahb_interrupt_handler(int irq, void *arg)\r\n{\r\nstruct ath10k *ar = arg;\r\nstruct ath10k_pci *ar_pci = ath10k_pci_priv(ar);\r\nif (!ath10k_pci_irq_pending(ar))\r\nreturn IRQ_NONE;\r\nath10k_pci_disable_and_clear_legacy_irq(ar);\r\ntasklet_schedule(&ar_pci->intr_tq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ath10k_ahb_request_irq_legacy(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nint ret;\r\nret = request_irq(ar_ahb->irq,\r\nath10k_ahb_interrupt_handler,\r\nIRQF_SHARED, "ath10k_ahb", ar);\r\nif (ret) {\r\nath10k_warn(ar, "failed to request legacy irq %d: %d\n",\r\nar_ahb->irq, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath10k_ahb_release_irq_legacy(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nfree_irq(ar_ahb->irq, ar);\r\n}\r\nstatic void ath10k_ahb_irq_disable(struct ath10k *ar)\r\n{\r\nath10k_ce_disable_interrupts(ar);\r\nath10k_pci_disable_and_clear_legacy_irq(ar);\r\n}\r\nstatic int ath10k_ahb_resource_init(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nstruct platform_device *pdev;\r\nstruct device *dev;\r\nstruct resource *res;\r\nint ret;\r\npdev = ar_ahb->pdev;\r\ndev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nath10k_err(ar, "failed to get memory resource\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nar_ahb->mem = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ar_ahb->mem)) {\r\nath10k_err(ar, "mem ioremap error\n");\r\nret = PTR_ERR(ar_ahb->mem);\r\ngoto out;\r\n}\r\nar_ahb->mem_len = resource_size(res);\r\nar_ahb->gcc_mem = ioremap_nocache(ATH10K_GCC_REG_BASE,\r\nATH10K_GCC_REG_SIZE);\r\nif (!ar_ahb->gcc_mem) {\r\nath10k_err(ar, "gcc mem ioremap error\n");\r\nret = -ENOMEM;\r\ngoto err_mem_unmap;\r\n}\r\nar_ahb->tcsr_mem = ioremap_nocache(ATH10K_TCSR_REG_BASE,\r\nATH10K_TCSR_REG_SIZE);\r\nif (!ar_ahb->tcsr_mem) {\r\nath10k_err(ar, "tcsr mem ioremap error\n");\r\nret = -ENOMEM;\r\ngoto err_gcc_mem_unmap;\r\n}\r\nret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\nath10k_err(ar, "failed to set 32-bit dma mask: %d\n", ret);\r\ngoto err_tcsr_mem_unmap;\r\n}\r\nret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\nath10k_err(ar, "failed to set 32-bit consistent dma: %d\n",\r\nret);\r\ngoto err_tcsr_mem_unmap;\r\n}\r\nret = ath10k_ahb_clock_init(ar);\r\nif (ret)\r\ngoto err_tcsr_mem_unmap;\r\nret = ath10k_ahb_rst_ctrl_init(ar);\r\nif (ret)\r\ngoto err_clock_deinit;\r\nar_ahb->irq = platform_get_irq_byname(pdev, "legacy");\r\nif (ar_ahb->irq < 0) {\r\nath10k_err(ar, "failed to get irq number: %d\n", ar_ahb->irq);\r\ngoto err_clock_deinit;\r\n}\r\nath10k_dbg(ar, ATH10K_DBG_BOOT, "irq: %d\n", ar_ahb->irq);\r\nath10k_dbg(ar, ATH10K_DBG_BOOT, "mem: 0x%p mem_len: %lu gcc mem: 0x%p tcsr_mem: 0x%p\n",\r\nar_ahb->mem, ar_ahb->mem_len,\r\nar_ahb->gcc_mem, ar_ahb->tcsr_mem);\r\nreturn 0;\r\nerr_clock_deinit:\r\nath10k_ahb_clock_deinit(ar);\r\nerr_tcsr_mem_unmap:\r\niounmap(ar_ahb->tcsr_mem);\r\nerr_gcc_mem_unmap:\r\nar_ahb->tcsr_mem = NULL;\r\niounmap(ar_ahb->gcc_mem);\r\nerr_mem_unmap:\r\nar_ahb->gcc_mem = NULL;\r\ndevm_iounmap(&pdev->dev, ar_ahb->mem);\r\nout:\r\nar_ahb->mem = NULL;\r\nreturn ret;\r\n}\r\nstatic void ath10k_ahb_resource_deinit(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nstruct device *dev;\r\ndev = &ar_ahb->pdev->dev;\r\nif (ar_ahb->mem)\r\ndevm_iounmap(dev, ar_ahb->mem);\r\nif (ar_ahb->gcc_mem)\r\niounmap(ar_ahb->gcc_mem);\r\nif (ar_ahb->tcsr_mem)\r\niounmap(ar_ahb->tcsr_mem);\r\nar_ahb->mem = NULL;\r\nar_ahb->gcc_mem = NULL;\r\nar_ahb->tcsr_mem = NULL;\r\nath10k_ahb_clock_deinit(ar);\r\nath10k_ahb_rst_ctrl_deinit(ar);\r\n}\r\nstatic int ath10k_ahb_prepare_device(struct ath10k *ar)\r\n{\r\nu32 val;\r\nint ret;\r\nret = ath10k_ahb_clock_enable(ar);\r\nif (ret) {\r\nath10k_err(ar, "failed to enable clocks\n");\r\nreturn ret;\r\n}\r\nval = ath10k_ahb_gcc_read32(ar, ATH10K_AHB_GCC_FEPLL_PLL_DIV);\r\nath10k_ahb_write32(ar, ATH10K_AHB_WIFI_SCRATCH_5_REG, val);\r\nret = ath10k_ahb_release_reset(ar);\r\nif (ret)\r\ngoto err_clk_disable;\r\nath10k_ahb_irq_disable(ar);\r\nath10k_ahb_write32(ar, FW_INDICATOR_ADDRESS, FW_IND_HOST_READY);\r\nret = ath10k_pci_wait_for_target_init(ar);\r\nif (ret)\r\ngoto err_halt_chip;\r\nreturn 0;\r\nerr_halt_chip:\r\nath10k_ahb_halt_chip(ar);\r\nerr_clk_disable:\r\nath10k_ahb_clock_disable(ar);\r\nreturn ret;\r\n}\r\nstatic int ath10k_ahb_chip_reset(struct ath10k *ar)\r\n{\r\nint ret;\r\nath10k_ahb_halt_chip(ar);\r\nath10k_ahb_clock_disable(ar);\r\nret = ath10k_ahb_prepare_device(ar);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ath10k_ahb_wake_target_cpu(struct ath10k *ar)\r\n{\r\nu32 addr, val;\r\naddr = SOC_CORE_BASE_ADDRESS | CORE_CTRL_ADDRESS;\r\nval = ath10k_ahb_read32(ar, addr);\r\nval |= ATH10K_AHB_CORE_CTRL_CPU_INTR_MASK;\r\nath10k_ahb_write32(ar, addr, val);\r\nreturn 0;\r\n}\r\nstatic int ath10k_ahb_hif_start(struct ath10k *ar)\r\n{\r\nath10k_dbg(ar, ATH10K_DBG_BOOT, "boot ahb hif start\n");\r\nath10k_ce_enable_interrupts(ar);\r\nath10k_pci_enable_legacy_irq(ar);\r\nath10k_pci_rx_post(ar);\r\nreturn 0;\r\n}\r\nstatic void ath10k_ahb_hif_stop(struct ath10k *ar)\r\n{\r\nstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\r\nath10k_dbg(ar, ATH10K_DBG_BOOT, "boot ahb hif stop\n");\r\nath10k_ahb_irq_disable(ar);\r\nsynchronize_irq(ar_ahb->irq);\r\nath10k_pci_flush(ar);\r\n}\r\nstatic int ath10k_ahb_hif_power_up(struct ath10k *ar)\r\n{\r\nint ret;\r\nath10k_dbg(ar, ATH10K_DBG_BOOT, "boot ahb hif power up\n");\r\nret = ath10k_ahb_chip_reset(ar);\r\nif (ret) {\r\nath10k_err(ar, "failed to reset chip: %d\n", ret);\r\ngoto out;\r\n}\r\nret = ath10k_pci_init_pipes(ar);\r\nif (ret) {\r\nath10k_err(ar, "failed to initialize CE: %d\n", ret);\r\ngoto out;\r\n}\r\nret = ath10k_pci_init_config(ar);\r\nif (ret) {\r\nath10k_err(ar, "failed to setup init config: %d\n", ret);\r\ngoto err_ce_deinit;\r\n}\r\nret = ath10k_ahb_wake_target_cpu(ar);\r\nif (ret) {\r\nath10k_err(ar, "could not wake up target CPU: %d\n", ret);\r\ngoto err_ce_deinit;\r\n}\r\nreturn 0;\r\nerr_ce_deinit:\r\nath10k_pci_ce_deinit(ar);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ath10k_ahb_probe(struct platform_device *pdev)\r\n{\r\nstruct ath10k *ar;\r\nstruct ath10k_ahb *ar_ahb;\r\nstruct ath10k_pci *ar_pci;\r\nconst struct of_device_id *of_id;\r\nenum ath10k_hw_rev hw_rev;\r\nsize_t size;\r\nint ret;\r\nu32 chip_id;\r\nof_id = of_match_device(ath10k_ahb_of_match, &pdev->dev);\r\nif (!of_id) {\r\ndev_err(&pdev->dev, "failed to find matching device tree id\n");\r\nreturn -EINVAL;\r\n}\r\nhw_rev = (enum ath10k_hw_rev)of_id->data;\r\nsize = sizeof(*ar_pci) + sizeof(*ar_ahb);\r\nar = ath10k_core_create(size, &pdev->dev, ATH10K_BUS_AHB,\r\nhw_rev, &ath10k_ahb_hif_ops);\r\nif (!ar) {\r\ndev_err(&pdev->dev, "failed to allocate core\n");\r\nreturn -ENOMEM;\r\n}\r\nath10k_dbg(ar, ATH10K_DBG_BOOT, "ahb probe\n");\r\nar_pci = ath10k_pci_priv(ar);\r\nar_ahb = ath10k_ahb_priv(ar);\r\nar_ahb->pdev = pdev;\r\nplatform_set_drvdata(pdev, ar);\r\nret = ath10k_ahb_resource_init(ar);\r\nif (ret)\r\ngoto err_core_destroy;\r\nar->dev_id = 0;\r\nar_pci->mem = ar_ahb->mem;\r\nar_pci->mem_len = ar_ahb->mem_len;\r\nar_pci->ar = ar;\r\nar_pci->bus_ops = &ath10k_ahb_bus_ops;\r\nret = ath10k_pci_setup_resource(ar);\r\nif (ret) {\r\nath10k_err(ar, "failed to setup resource: %d\n", ret);\r\ngoto err_resource_deinit;\r\n}\r\nath10k_pci_init_irq_tasklets(ar);\r\nret = ath10k_ahb_request_irq_legacy(ar);\r\nif (ret)\r\ngoto err_free_pipes;\r\nret = ath10k_ahb_prepare_device(ar);\r\nif (ret)\r\ngoto err_free_irq;\r\nath10k_pci_ce_deinit(ar);\r\nchip_id = ath10k_ahb_soc_read32(ar, SOC_CHIP_ID_ADDRESS);\r\nif (chip_id == 0xffffffff) {\r\nath10k_err(ar, "failed to get chip id\n");\r\ngoto err_halt_device;\r\n}\r\nret = ath10k_core_register(ar, chip_id);\r\nif (ret) {\r\nath10k_err(ar, "failed to register driver core: %d\n", ret);\r\ngoto err_halt_device;\r\n}\r\nreturn 0;\r\nerr_halt_device:\r\nath10k_ahb_halt_chip(ar);\r\nath10k_ahb_clock_disable(ar);\r\nerr_free_irq:\r\nath10k_ahb_release_irq_legacy(ar);\r\nerr_free_pipes:\r\nath10k_pci_free_pipes(ar);\r\nerr_resource_deinit:\r\nath10k_ahb_resource_deinit(ar);\r\nerr_core_destroy:\r\nath10k_core_destroy(ar);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int ath10k_ahb_remove(struct platform_device *pdev)\r\n{\r\nstruct ath10k *ar = platform_get_drvdata(pdev);\r\nstruct ath10k_ahb *ar_ahb;\r\nif (!ar)\r\nreturn -EINVAL;\r\nar_ahb = ath10k_ahb_priv(ar);\r\nif (!ar_ahb)\r\nreturn -EINVAL;\r\nath10k_dbg(ar, ATH10K_DBG_AHB, "ahb remove\n");\r\nath10k_core_unregister(ar);\r\nath10k_ahb_irq_disable(ar);\r\nath10k_ahb_release_irq_legacy(ar);\r\nath10k_pci_release_resource(ar);\r\nath10k_ahb_halt_chip(ar);\r\nath10k_ahb_clock_disable(ar);\r\nath10k_ahb_resource_deinit(ar);\r\nath10k_core_destroy(ar);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nint ath10k_ahb_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_ERR "AHB support is still work in progress\n");\r\nret = platform_driver_register(&ath10k_ahb_driver);\r\nif (ret)\r\nprintk(KERN_ERR "failed to register ath10k ahb driver: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nvoid ath10k_ahb_exit(void)\r\n{\r\nplatform_driver_unregister(&ath10k_ahb_driver);\r\n}
