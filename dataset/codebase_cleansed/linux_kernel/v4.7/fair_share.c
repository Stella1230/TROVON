static int get_trip_level(struct thermal_zone_device *tz)\r\n{\r\nint count = 0;\r\nint trip_temp;\r\nenum thermal_trip_type trip_type;\r\nif (tz->trips == 0 || !tz->ops->get_trip_temp)\r\nreturn 0;\r\nfor (count = 0; count < tz->trips; count++) {\r\ntz->ops->get_trip_temp(tz, count, &trip_temp);\r\nif (tz->temperature < trip_temp)\r\nbreak;\r\n}\r\nif (count > 0) {\r\ntz->ops->get_trip_type(tz, count - 1, &trip_type);\r\ntrace_thermal_zone_trip(tz, count - 1, trip_type);\r\n}\r\nreturn count;\r\n}\r\nstatic long get_target_state(struct thermal_zone_device *tz,\r\nstruct thermal_cooling_device *cdev, int percentage, int level)\r\n{\r\nunsigned long max_state;\r\ncdev->ops->get_max_state(cdev, &max_state);\r\nreturn (long)(percentage * level * max_state) / (100 * tz->trips);\r\n}\r\nstatic int fair_share_throttle(struct thermal_zone_device *tz, int trip)\r\n{\r\nstruct thermal_instance *instance;\r\nint total_weight = 0;\r\nint total_instance = 0;\r\nint cur_trip_level = get_trip_level(tz);\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nif (instance->trip != trip)\r\ncontinue;\r\ntotal_weight += instance->weight;\r\ntotal_instance++;\r\n}\r\nlist_for_each_entry(instance, &tz->thermal_instances, tz_node) {\r\nint percentage;\r\nstruct thermal_cooling_device *cdev = instance->cdev;\r\nif (instance->trip != trip)\r\ncontinue;\r\nif (!total_weight)\r\npercentage = 100 / total_instance;\r\nelse\r\npercentage = (instance->weight * 100) / total_weight;\r\ninstance->target = get_target_state(tz, cdev, percentage,\r\ncur_trip_level);\r\ninstance->cdev->updated = false;\r\nthermal_cdev_update(cdev);\r\n}\r\nreturn 0;\r\n}\r\nint thermal_gov_fair_share_register(void)\r\n{\r\nreturn thermal_register_governor(&thermal_gov_fair_share);\r\n}\r\nvoid thermal_gov_fair_share_unregister(void)\r\n{\r\nthermal_unregister_governor(&thermal_gov_fair_share);\r\n}
