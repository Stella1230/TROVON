static int check_free_space(struct bsd_acct_struct *acct)\r\n{\r\nstruct kstatfs sbuf;\r\nif (time_is_before_jiffies(acct->needcheck))\r\ngoto out;\r\nif (vfs_statfs(&acct->file->f_path, &sbuf))\r\ngoto out;\r\nif (acct->active) {\r\nu64 suspend = sbuf.f_blocks * SUSPEND;\r\ndo_div(suspend, 100);\r\nif (sbuf.f_bavail <= suspend) {\r\nacct->active = 0;\r\npr_info("Process accounting paused\n");\r\n}\r\n} else {\r\nu64 resume = sbuf.f_blocks * RESUME;\r\ndo_div(resume, 100);\r\nif (sbuf.f_bavail >= resume) {\r\nacct->active = 1;\r\npr_info("Process accounting resumed\n");\r\n}\r\n}\r\nacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\r\nout:\r\nreturn acct->active;\r\n}\r\nstatic void acct_put(struct bsd_acct_struct *p)\r\n{\r\nif (atomic_long_dec_and_test(&p->count))\r\nkfree_rcu(p, rcu);\r\n}\r\nstatic inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\r\n{\r\nreturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\r\n}\r\nstatic struct bsd_acct_struct *acct_get(struct pid_namespace *ns)\r\n{\r\nstruct bsd_acct_struct *res;\r\nagain:\r\nsmp_rmb();\r\nrcu_read_lock();\r\nres = to_acct(ACCESS_ONCE(ns->bacct));\r\nif (!res) {\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nif (!atomic_long_inc_not_zero(&res->count)) {\r\nrcu_read_unlock();\r\ncpu_relax();\r\ngoto again;\r\n}\r\nrcu_read_unlock();\r\nmutex_lock(&res->lock);\r\nif (res != to_acct(ACCESS_ONCE(ns->bacct))) {\r\nmutex_unlock(&res->lock);\r\nacct_put(res);\r\ngoto again;\r\n}\r\nreturn res;\r\n}\r\nstatic void acct_pin_kill(struct fs_pin *pin)\r\n{\r\nstruct bsd_acct_struct *acct = to_acct(pin);\r\nmutex_lock(&acct->lock);\r\ndo_acct_process(acct);\r\nschedule_work(&acct->work);\r\nwait_for_completion(&acct->done);\r\ncmpxchg(&acct->ns->bacct, pin, NULL);\r\nmutex_unlock(&acct->lock);\r\npin_remove(pin);\r\nacct_put(acct);\r\n}\r\nstatic void close_work(struct work_struct *work)\r\n{\r\nstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);\r\nstruct file *file = acct->file;\r\nif (file->f_op->flush)\r\nfile->f_op->flush(file, NULL);\r\n__fput_sync(file);\r\ncomplete(&acct->done);\r\n}\r\nstatic int acct_on(struct filename *pathname)\r\n{\r\nstruct file *file;\r\nstruct vfsmount *mnt, *internal;\r\nstruct pid_namespace *ns = task_active_pid_ns(current);\r\nstruct bsd_acct_struct *acct;\r\nstruct fs_pin *old;\r\nint err;\r\nacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);\r\nif (!acct)\r\nreturn -ENOMEM;\r\nfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);\r\nif (IS_ERR(file)) {\r\nkfree(acct);\r\nreturn PTR_ERR(file);\r\n}\r\nif (!S_ISREG(file_inode(file)->i_mode)) {\r\nkfree(acct);\r\nfilp_close(file, NULL);\r\nreturn -EACCES;\r\n}\r\nif (!(file->f_mode & FMODE_CAN_WRITE)) {\r\nkfree(acct);\r\nfilp_close(file, NULL);\r\nreturn -EIO;\r\n}\r\ninternal = mnt_clone_internal(&file->f_path);\r\nif (IS_ERR(internal)) {\r\nkfree(acct);\r\nfilp_close(file, NULL);\r\nreturn PTR_ERR(internal);\r\n}\r\nerr = mnt_want_write(internal);\r\nif (err) {\r\nmntput(internal);\r\nkfree(acct);\r\nfilp_close(file, NULL);\r\nreturn err;\r\n}\r\nmnt = file->f_path.mnt;\r\nfile->f_path.mnt = internal;\r\natomic_long_set(&acct->count, 1);\r\ninit_fs_pin(&acct->pin, acct_pin_kill);\r\nacct->file = file;\r\nacct->needcheck = jiffies;\r\nacct->ns = ns;\r\nmutex_init(&acct->lock);\r\nINIT_WORK(&acct->work, close_work);\r\ninit_completion(&acct->done);\r\nmutex_lock_nested(&acct->lock, 1);\r\npin_insert(&acct->pin, mnt);\r\nrcu_read_lock();\r\nold = xchg(&ns->bacct, &acct->pin);\r\nmutex_unlock(&acct->lock);\r\npin_kill(old);\r\nmnt_drop_write(mnt);\r\nmntput(mnt);\r\nreturn 0;\r\n}\r\nvoid acct_exit_ns(struct pid_namespace *ns)\r\n{\r\nrcu_read_lock();\r\npin_kill(ns->bacct);\r\n}\r\nstatic comp_t encode_comp_t(unsigned long value)\r\n{\r\nint exp, rnd;\r\nexp = rnd = 0;\r\nwhile (value > MAXFRACT) {\r\nrnd = value & (1 << (EXPSIZE - 1));\r\nvalue >>= EXPSIZE;\r\nexp++;\r\n}\r\nif (rnd && (++value > MAXFRACT)) {\r\nvalue >>= EXPSIZE;\r\nexp++;\r\n}\r\nexp <<= MANTSIZE;\r\nexp += value;\r\nreturn exp;\r\n}\r\nstatic comp2_t encode_comp2_t(u64 value)\r\n{\r\nint exp, rnd;\r\nexp = (value > (MAXFRACT2>>1));\r\nrnd = 0;\r\nwhile (value > MAXFRACT2) {\r\nrnd = value & 1;\r\nvalue >>= 1;\r\nexp++;\r\n}\r\nif (rnd && (++value > MAXFRACT2)) {\r\nvalue >>= 1;\r\nexp++;\r\n}\r\nif (exp > MAXEXP2) {\r\nreturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;\r\n} else {\r\nreturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));\r\n}\r\n}\r\nstatic u32 encode_float(u64 value)\r\n{\r\nunsigned exp = 190;\r\nunsigned u;\r\nif (value == 0)\r\nreturn 0;\r\nwhile ((s64)value > 0) {\r\nvalue <<= 1;\r\nexp--;\r\n}\r\nu = (u32)(value >> 40) & 0x7fffffu;\r\nreturn u | (exp << 23);\r\n}\r\nstatic void fill_ac(acct_t *ac)\r\n{\r\nstruct pacct_struct *pacct = &current->signal->pacct;\r\nu64 elapsed, run_time;\r\nstruct tty_struct *tty;\r\nmemset(ac, 0, sizeof(acct_t));\r\nac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;\r\nstrlcpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));\r\nrun_time = ktime_get_ns();\r\nrun_time -= current->group_leader->start_time;\r\nelapsed = nsec_to_AHZ(run_time);\r\n#if ACCT_VERSION == 3\r\nac->ac_etime = encode_float(elapsed);\r\n#else\r\nac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?\r\n(unsigned long) elapsed : (unsigned long) -1l);\r\n#endif\r\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\r\n{\r\ncomp2_t etime = encode_comp2_t(elapsed);\r\nac->ac_etime_hi = etime >> 16;\r\nac->ac_etime_lo = (u16) etime;\r\n}\r\n#endif\r\ndo_div(elapsed, AHZ);\r\nac->ac_btime = get_seconds() - elapsed;\r\n#if ACCT_VERSION==2\r\nac->ac_ahz = AHZ;\r\n#endif\r\nspin_lock_irq(&current->sighand->siglock);\r\ntty = current->signal->tty;\r\nac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;\r\nac->ac_utime = encode_comp_t(jiffies_to_AHZ(cputime_to_jiffies(pacct->ac_utime)));\r\nac->ac_stime = encode_comp_t(jiffies_to_AHZ(cputime_to_jiffies(pacct->ac_stime)));\r\nac->ac_flag = pacct->ac_flag;\r\nac->ac_mem = encode_comp_t(pacct->ac_mem);\r\nac->ac_minflt = encode_comp_t(pacct->ac_minflt);\r\nac->ac_majflt = encode_comp_t(pacct->ac_majflt);\r\nac->ac_exitcode = pacct->ac_exitcode;\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nstatic void do_acct_process(struct bsd_acct_struct *acct)\r\n{\r\nacct_t ac;\r\nunsigned long flim;\r\nconst struct cred *orig_cred;\r\nstruct file *file = acct->file;\r\nflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\r\ncurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\r\norig_cred = override_creds(file->f_cred);\r\nif (!check_free_space(acct))\r\ngoto out;\r\nfill_ac(&ac);\r\nac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\r\nac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\r\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\r\nac.ac_uid16 = ac.ac_uid;\r\nac.ac_gid16 = ac.ac_gid;\r\n#endif\r\n#if ACCT_VERSION == 3\r\n{\r\nstruct pid_namespace *ns = acct->ns;\r\nac.ac_pid = task_tgid_nr_ns(current, ns);\r\nrcu_read_lock();\r\nac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\r\nns);\r\nrcu_read_unlock();\r\n}\r\n#endif\r\nif (file_start_write_trylock(file)) {\r\nloff_t pos = 0;\r\n__kernel_write(file, (char *)&ac, sizeof(acct_t), &pos);\r\nfile_end_write(file);\r\n}\r\nout:\r\ncurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\r\nrevert_creds(orig_cred);\r\n}\r\nvoid acct_collect(long exitcode, int group_dead)\r\n{\r\nstruct pacct_struct *pacct = &current->signal->pacct;\r\ncputime_t utime, stime;\r\nunsigned long vsize = 0;\r\nif (group_dead && current->mm) {\r\nstruct vm_area_struct *vma;\r\ndown_read(&current->mm->mmap_sem);\r\nvma = current->mm->mmap;\r\nwhile (vma) {\r\nvsize += vma->vm_end - vma->vm_start;\r\nvma = vma->vm_next;\r\n}\r\nup_read(&current->mm->mmap_sem);\r\n}\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (group_dead)\r\npacct->ac_mem = vsize / 1024;\r\nif (thread_group_leader(current)) {\r\npacct->ac_exitcode = exitcode;\r\nif (current->flags & PF_FORKNOEXEC)\r\npacct->ac_flag |= AFORK;\r\n}\r\nif (current->flags & PF_SUPERPRIV)\r\npacct->ac_flag |= ASU;\r\nif (current->flags & PF_DUMPCORE)\r\npacct->ac_flag |= ACORE;\r\nif (current->flags & PF_SIGNALED)\r\npacct->ac_flag |= AXSIG;\r\ntask_cputime(current, &utime, &stime);\r\npacct->ac_utime += utime;\r\npacct->ac_stime += stime;\r\npacct->ac_minflt += current->min_flt;\r\npacct->ac_majflt += current->maj_flt;\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nstatic void slow_acct_process(struct pid_namespace *ns)\r\n{\r\nfor ( ; ns; ns = ns->parent) {\r\nstruct bsd_acct_struct *acct = acct_get(ns);\r\nif (acct) {\r\ndo_acct_process(acct);\r\nmutex_unlock(&acct->lock);\r\nacct_put(acct);\r\n}\r\n}\r\n}\r\nvoid acct_process(void)\r\n{\r\nstruct pid_namespace *ns;\r\nfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\r\nif (ns->bacct)\r\nbreak;\r\n}\r\nif (unlikely(ns))\r\nslow_acct_process(ns);\r\n}
