static void ceph_pagelist_unmap_tail(struct ceph_pagelist *pl)\r\n{\r\nif (pl->mapped_tail) {\r\nstruct page *page = list_entry(pl->head.prev, struct page, lru);\r\nkunmap(page);\r\npl->mapped_tail = NULL;\r\n}\r\n}\r\nvoid ceph_pagelist_release(struct ceph_pagelist *pl)\r\n{\r\nif (!atomic_dec_and_test(&pl->refcnt))\r\nreturn;\r\nceph_pagelist_unmap_tail(pl);\r\nwhile (!list_empty(&pl->head)) {\r\nstruct page *page = list_first_entry(&pl->head, struct page,\r\nlru);\r\nlist_del(&page->lru);\r\n__free_page(page);\r\n}\r\nceph_pagelist_free_reserve(pl);\r\nkfree(pl);\r\n}\r\nstatic int ceph_pagelist_addpage(struct ceph_pagelist *pl)\r\n{\r\nstruct page *page;\r\nif (!pl->num_pages_free) {\r\npage = __page_cache_alloc(GFP_NOFS);\r\n} else {\r\npage = list_first_entry(&pl->free_list, struct page, lru);\r\nlist_del(&page->lru);\r\n--pl->num_pages_free;\r\n}\r\nif (!page)\r\nreturn -ENOMEM;\r\npl->room += PAGE_SIZE;\r\nceph_pagelist_unmap_tail(pl);\r\nlist_add_tail(&page->lru, &pl->head);\r\npl->mapped_tail = kmap(page);\r\nreturn 0;\r\n}\r\nint ceph_pagelist_append(struct ceph_pagelist *pl, const void *buf, size_t len)\r\n{\r\nwhile (pl->room < len) {\r\nsize_t bit = pl->room;\r\nint ret;\r\nmemcpy(pl->mapped_tail + (pl->length & ~PAGE_MASK),\r\nbuf, bit);\r\npl->length += bit;\r\npl->room -= bit;\r\nbuf += bit;\r\nlen -= bit;\r\nret = ceph_pagelist_addpage(pl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmemcpy(pl->mapped_tail + (pl->length & ~PAGE_MASK), buf, len);\r\npl->length += len;\r\npl->room -= len;\r\nreturn 0;\r\n}\r\nint ceph_pagelist_reserve(struct ceph_pagelist *pl, size_t space)\r\n{\r\nif (space <= pl->room)\r\nreturn 0;\r\nspace -= pl->room;\r\nspace = (space + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nwhile (space > pl->num_pages_free) {\r\nstruct page *page = __page_cache_alloc(GFP_NOFS);\r\nif (!page)\r\nreturn -ENOMEM;\r\nlist_add_tail(&page->lru, &pl->free_list);\r\n++pl->num_pages_free;\r\n}\r\nreturn 0;\r\n}\r\nint ceph_pagelist_free_reserve(struct ceph_pagelist *pl)\r\n{\r\nwhile (!list_empty(&pl->free_list)) {\r\nstruct page *page = list_first_entry(&pl->free_list,\r\nstruct page, lru);\r\nlist_del(&page->lru);\r\n__free_page(page);\r\n--pl->num_pages_free;\r\n}\r\nBUG_ON(pl->num_pages_free);\r\nreturn 0;\r\n}\r\nvoid ceph_pagelist_set_cursor(struct ceph_pagelist *pl,\r\nstruct ceph_pagelist_cursor *c)\r\n{\r\nc->pl = pl;\r\nc->page_lru = pl->head.prev;\r\nc->room = pl->room;\r\n}\r\nint ceph_pagelist_truncate(struct ceph_pagelist *pl,\r\nstruct ceph_pagelist_cursor *c)\r\n{\r\nstruct page *page;\r\nif (pl != c->pl)\r\nreturn -EINVAL;\r\nceph_pagelist_unmap_tail(pl);\r\nwhile (pl->head.prev != c->page_lru) {\r\npage = list_entry(pl->head.prev, struct page, lru);\r\nlist_move_tail(&page->lru, &pl->free_list);\r\n++pl->num_pages_free;\r\n}\r\npl->room = c->room;\r\nif (!list_empty(&pl->head)) {\r\npage = list_entry(pl->head.prev, struct page, lru);\r\npl->mapped_tail = kmap(page);\r\n}\r\nreturn 0;\r\n}
