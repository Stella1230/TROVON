static bool rt5659_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT5659_RESET:\r\ncase RT5659_EJD_CTRL_2:\r\ncase RT5659_SILENCE_CTRL:\r\ncase RT5659_DAC2_DIG_VOL:\r\ncase RT5659_HP_IMP_GAIN_2:\r\ncase RT5659_PDM_OUT_CTRL:\r\ncase RT5659_PDM_DATA_CTRL_1:\r\ncase RT5659_PDM_DATA_CTRL_4:\r\ncase RT5659_HAPTIC_GEN_CTRL_1:\r\ncase RT5659_HAPTIC_GEN_CTRL_3:\r\ncase RT5659_HAPTIC_LPF_CTRL_3:\r\ncase RT5659_CLK_DET:\r\ncase RT5659_MICBIAS_1:\r\ncase RT5659_ASRC_11:\r\ncase RT5659_ADC_EQ_CTRL_1:\r\ncase RT5659_DAC_EQ_CTRL_1:\r\ncase RT5659_INT_ST_1:\r\ncase RT5659_INT_ST_2:\r\ncase RT5659_GPIO_STA:\r\ncase RT5659_SINE_GEN_CTRL_1:\r\ncase RT5659_IL_CMD_1:\r\ncase RT5659_4BTN_IL_CMD_1:\r\ncase RT5659_PSV_IL_CMD_1:\r\ncase RT5659_AJD1_CTRL:\r\ncase RT5659_AJD2_AJD3_CTRL:\r\ncase RT5659_JD_CTRL_3:\r\ncase RT5659_VENDOR_ID:\r\ncase RT5659_VENDOR_ID_1:\r\ncase RT5659_DEVICE_ID:\r\ncase RT5659_MEMORY_TEST:\r\ncase RT5659_SOFT_RAMP_DEPOP_DAC_CLK_CTRL:\r\ncase RT5659_VOL_TEST:\r\ncase RT5659_STO_NG2_CTRL_1:\r\ncase RT5659_STO_NG2_CTRL_5:\r\ncase RT5659_STO_NG2_CTRL_6:\r\ncase RT5659_STO_NG2_CTRL_7:\r\ncase RT5659_MONO_NG2_CTRL_1:\r\ncase RT5659_MONO_NG2_CTRL_5:\r\ncase RT5659_MONO_NG2_CTRL_6:\r\ncase RT5659_HP_IMP_SENS_CTRL_1:\r\ncase RT5659_HP_IMP_SENS_CTRL_3:\r\ncase RT5659_HP_IMP_SENS_CTRL_4:\r\ncase RT5659_HP_CALIB_CTRL_1:\r\ncase RT5659_HP_CALIB_CTRL_9:\r\ncase RT5659_HP_CALIB_STA_1:\r\ncase RT5659_HP_CALIB_STA_2:\r\ncase RT5659_HP_CALIB_STA_3:\r\ncase RT5659_HP_CALIB_STA_4:\r\ncase RT5659_HP_CALIB_STA_5:\r\ncase RT5659_HP_CALIB_STA_6:\r\ncase RT5659_HP_CALIB_STA_7:\r\ncase RT5659_HP_CALIB_STA_8:\r\ncase RT5659_HP_CALIB_STA_9:\r\ncase RT5659_MONO_AMP_CALIB_CTRL_1:\r\ncase RT5659_MONO_AMP_CALIB_CTRL_3:\r\ncase RT5659_MONO_AMP_CALIB_STA_1:\r\ncase RT5659_MONO_AMP_CALIB_STA_2:\r\ncase RT5659_MONO_AMP_CALIB_STA_3:\r\ncase RT5659_MONO_AMP_CALIB_STA_4:\r\ncase RT5659_SPK_PWR_LMT_STA_1:\r\ncase RT5659_SPK_PWR_LMT_STA_2:\r\ncase RT5659_SPK_PWR_LMT_STA_3:\r\ncase RT5659_SPK_PWR_LMT_STA_4:\r\ncase RT5659_SPK_PWR_LMT_STA_5:\r\ncase RT5659_SPK_PWR_LMT_STA_6:\r\ncase RT5659_SPK_DC_CAILB_CTRL_1:\r\ncase RT5659_SPK_DC_CAILB_STA_1:\r\ncase RT5659_SPK_DC_CAILB_STA_2:\r\ncase RT5659_SPK_DC_CAILB_STA_3:\r\ncase RT5659_SPK_DC_CAILB_STA_4:\r\ncase RT5659_SPK_DC_CAILB_STA_5:\r\ncase RT5659_SPK_DC_CAILB_STA_6:\r\ncase RT5659_SPK_DC_CAILB_STA_7:\r\ncase RT5659_SPK_DC_CAILB_STA_8:\r\ncase RT5659_SPK_DC_CAILB_STA_9:\r\ncase RT5659_SPK_DC_CAILB_STA_10:\r\ncase RT5659_SPK_VDD_STA_1:\r\ncase RT5659_SPK_VDD_STA_2:\r\ncase RT5659_SPK_DC_DET_CTRL_1:\r\ncase RT5659_PURE_DC_DET_CTRL_1:\r\ncase RT5659_PURE_DC_DET_CTRL_2:\r\ncase RT5659_DRC1_PRIV_1:\r\ncase RT5659_DRC1_PRIV_4:\r\ncase RT5659_DRC1_PRIV_5:\r\ncase RT5659_DRC1_PRIV_6:\r\ncase RT5659_DRC1_PRIV_7:\r\ncase RT5659_DRC2_PRIV_1:\r\ncase RT5659_DRC2_PRIV_4:\r\ncase RT5659_DRC2_PRIV_5:\r\ncase RT5659_DRC2_PRIV_6:\r\ncase RT5659_DRC2_PRIV_7:\r\ncase RT5659_ALC_PGA_STA_1:\r\ncase RT5659_ALC_PGA_STA_2:\r\ncase RT5659_ALC_PGA_STA_3:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rt5659_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT5659_RESET:\r\ncase RT5659_SPO_VOL:\r\ncase RT5659_HP_VOL:\r\ncase RT5659_LOUT:\r\ncase RT5659_MONO_OUT:\r\ncase RT5659_HPL_GAIN:\r\ncase RT5659_HPR_GAIN:\r\ncase RT5659_MONO_GAIN:\r\ncase RT5659_SPDIF_CTRL_1:\r\ncase RT5659_SPDIF_CTRL_2:\r\ncase RT5659_CAL_BST_CTRL:\r\ncase RT5659_IN1_IN2:\r\ncase RT5659_IN3_IN4:\r\ncase RT5659_INL1_INR1_VOL:\r\ncase RT5659_EJD_CTRL_1:\r\ncase RT5659_EJD_CTRL_2:\r\ncase RT5659_EJD_CTRL_3:\r\ncase RT5659_SILENCE_CTRL:\r\ncase RT5659_PSV_CTRL:\r\ncase RT5659_SIDETONE_CTRL:\r\ncase RT5659_DAC1_DIG_VOL:\r\ncase RT5659_DAC2_DIG_VOL:\r\ncase RT5659_DAC_CTRL:\r\ncase RT5659_STO1_ADC_DIG_VOL:\r\ncase RT5659_MONO_ADC_DIG_VOL:\r\ncase RT5659_STO2_ADC_DIG_VOL:\r\ncase RT5659_STO1_BOOST:\r\ncase RT5659_MONO_BOOST:\r\ncase RT5659_STO2_BOOST:\r\ncase RT5659_HP_IMP_GAIN_1:\r\ncase RT5659_HP_IMP_GAIN_2:\r\ncase RT5659_STO1_ADC_MIXER:\r\ncase RT5659_MONO_ADC_MIXER:\r\ncase RT5659_AD_DA_MIXER:\r\ncase RT5659_STO_DAC_MIXER:\r\ncase RT5659_MONO_DAC_MIXER:\r\ncase RT5659_DIG_MIXER:\r\ncase RT5659_A_DAC_MUX:\r\ncase RT5659_DIG_INF23_DATA:\r\ncase RT5659_PDM_OUT_CTRL:\r\ncase RT5659_PDM_DATA_CTRL_1:\r\ncase RT5659_PDM_DATA_CTRL_2:\r\ncase RT5659_PDM_DATA_CTRL_3:\r\ncase RT5659_PDM_DATA_CTRL_4:\r\ncase RT5659_SPDIF_CTRL:\r\ncase RT5659_REC1_GAIN:\r\ncase RT5659_REC1_L1_MIXER:\r\ncase RT5659_REC1_L2_MIXER:\r\ncase RT5659_REC1_R1_MIXER:\r\ncase RT5659_REC1_R2_MIXER:\r\ncase RT5659_CAL_REC:\r\ncase RT5659_REC2_L1_MIXER:\r\ncase RT5659_REC2_L2_MIXER:\r\ncase RT5659_REC2_R1_MIXER:\r\ncase RT5659_REC2_R2_MIXER:\r\ncase RT5659_SPK_L_MIXER:\r\ncase RT5659_SPK_R_MIXER:\r\ncase RT5659_SPO_AMP_GAIN:\r\ncase RT5659_ALC_BACK_GAIN:\r\ncase RT5659_MONOMIX_GAIN:\r\ncase RT5659_MONOMIX_IN_GAIN:\r\ncase RT5659_OUT_L_GAIN:\r\ncase RT5659_OUT_L_MIXER:\r\ncase RT5659_OUT_R_GAIN:\r\ncase RT5659_OUT_R_MIXER:\r\ncase RT5659_LOUT_MIXER:\r\ncase RT5659_HAPTIC_GEN_CTRL_1:\r\ncase RT5659_HAPTIC_GEN_CTRL_2:\r\ncase RT5659_HAPTIC_GEN_CTRL_3:\r\ncase RT5659_HAPTIC_GEN_CTRL_4:\r\ncase RT5659_HAPTIC_GEN_CTRL_5:\r\ncase RT5659_HAPTIC_GEN_CTRL_6:\r\ncase RT5659_HAPTIC_GEN_CTRL_7:\r\ncase RT5659_HAPTIC_GEN_CTRL_8:\r\ncase RT5659_HAPTIC_GEN_CTRL_9:\r\ncase RT5659_HAPTIC_GEN_CTRL_10:\r\ncase RT5659_HAPTIC_GEN_CTRL_11:\r\ncase RT5659_HAPTIC_LPF_CTRL_1:\r\ncase RT5659_HAPTIC_LPF_CTRL_2:\r\ncase RT5659_HAPTIC_LPF_CTRL_3:\r\ncase RT5659_PWR_DIG_1:\r\ncase RT5659_PWR_DIG_2:\r\ncase RT5659_PWR_ANLG_1:\r\ncase RT5659_PWR_ANLG_2:\r\ncase RT5659_PWR_ANLG_3:\r\ncase RT5659_PWR_MIXER:\r\ncase RT5659_PWR_VOL:\r\ncase RT5659_PRIV_INDEX:\r\ncase RT5659_CLK_DET:\r\ncase RT5659_PRIV_DATA:\r\ncase RT5659_PRE_DIV_1:\r\ncase RT5659_PRE_DIV_2:\r\ncase RT5659_I2S1_SDP:\r\ncase RT5659_I2S2_SDP:\r\ncase RT5659_I2S3_SDP:\r\ncase RT5659_ADDA_CLK_1:\r\ncase RT5659_ADDA_CLK_2:\r\ncase RT5659_DMIC_CTRL_1:\r\ncase RT5659_DMIC_CTRL_2:\r\ncase RT5659_TDM_CTRL_1:\r\ncase RT5659_TDM_CTRL_2:\r\ncase RT5659_TDM_CTRL_3:\r\ncase RT5659_TDM_CTRL_4:\r\ncase RT5659_TDM_CTRL_5:\r\ncase RT5659_GLB_CLK:\r\ncase RT5659_PLL_CTRL_1:\r\ncase RT5659_PLL_CTRL_2:\r\ncase RT5659_ASRC_1:\r\ncase RT5659_ASRC_2:\r\ncase RT5659_ASRC_3:\r\ncase RT5659_ASRC_4:\r\ncase RT5659_ASRC_5:\r\ncase RT5659_ASRC_6:\r\ncase RT5659_ASRC_7:\r\ncase RT5659_ASRC_8:\r\ncase RT5659_ASRC_9:\r\ncase RT5659_ASRC_10:\r\ncase RT5659_DEPOP_1:\r\ncase RT5659_DEPOP_2:\r\ncase RT5659_DEPOP_3:\r\ncase RT5659_HP_CHARGE_PUMP_1:\r\ncase RT5659_HP_CHARGE_PUMP_2:\r\ncase RT5659_MICBIAS_1:\r\ncase RT5659_MICBIAS_2:\r\ncase RT5659_ASRC_11:\r\ncase RT5659_ASRC_12:\r\ncase RT5659_ASRC_13:\r\ncase RT5659_REC_M1_M2_GAIN_CTRL:\r\ncase RT5659_RC_CLK_CTRL:\r\ncase RT5659_CLASSD_CTRL_1:\r\ncase RT5659_CLASSD_CTRL_2:\r\ncase RT5659_ADC_EQ_CTRL_1:\r\ncase RT5659_ADC_EQ_CTRL_2:\r\ncase RT5659_DAC_EQ_CTRL_1:\r\ncase RT5659_DAC_EQ_CTRL_2:\r\ncase RT5659_DAC_EQ_CTRL_3:\r\ncase RT5659_IRQ_CTRL_1:\r\ncase RT5659_IRQ_CTRL_2:\r\ncase RT5659_IRQ_CTRL_3:\r\ncase RT5659_IRQ_CTRL_4:\r\ncase RT5659_IRQ_CTRL_5:\r\ncase RT5659_IRQ_CTRL_6:\r\ncase RT5659_INT_ST_1:\r\ncase RT5659_INT_ST_2:\r\ncase RT5659_GPIO_CTRL_1:\r\ncase RT5659_GPIO_CTRL_2:\r\ncase RT5659_GPIO_CTRL_3:\r\ncase RT5659_GPIO_CTRL_4:\r\ncase RT5659_GPIO_CTRL_5:\r\ncase RT5659_GPIO_STA:\r\ncase RT5659_SINE_GEN_CTRL_1:\r\ncase RT5659_SINE_GEN_CTRL_2:\r\ncase RT5659_SINE_GEN_CTRL_3:\r\ncase RT5659_HP_AMP_DET_CTRL_1:\r\ncase RT5659_HP_AMP_DET_CTRL_2:\r\ncase RT5659_SV_ZCD_1:\r\ncase RT5659_SV_ZCD_2:\r\ncase RT5659_IL_CMD_1:\r\ncase RT5659_IL_CMD_2:\r\ncase RT5659_IL_CMD_3:\r\ncase RT5659_IL_CMD_4:\r\ncase RT5659_4BTN_IL_CMD_1:\r\ncase RT5659_4BTN_IL_CMD_2:\r\ncase RT5659_4BTN_IL_CMD_3:\r\ncase RT5659_PSV_IL_CMD_1:\r\ncase RT5659_PSV_IL_CMD_2:\r\ncase RT5659_ADC_STO1_HP_CTRL_1:\r\ncase RT5659_ADC_STO1_HP_CTRL_2:\r\ncase RT5659_ADC_MONO_HP_CTRL_1:\r\ncase RT5659_ADC_MONO_HP_CTRL_2:\r\ncase RT5659_AJD1_CTRL:\r\ncase RT5659_AJD2_AJD3_CTRL:\r\ncase RT5659_JD1_THD:\r\ncase RT5659_JD2_THD:\r\ncase RT5659_JD3_THD:\r\ncase RT5659_JD_CTRL_1:\r\ncase RT5659_JD_CTRL_2:\r\ncase RT5659_JD_CTRL_3:\r\ncase RT5659_JD_CTRL_4:\r\ncase RT5659_DIG_MISC:\r\ncase RT5659_DUMMY_2:\r\ncase RT5659_DUMMY_3:\r\ncase RT5659_VENDOR_ID:\r\ncase RT5659_VENDOR_ID_1:\r\ncase RT5659_DEVICE_ID:\r\ncase RT5659_DAC_ADC_DIG_VOL:\r\ncase RT5659_BIAS_CUR_CTRL_1:\r\ncase RT5659_BIAS_CUR_CTRL_2:\r\ncase RT5659_BIAS_CUR_CTRL_3:\r\ncase RT5659_BIAS_CUR_CTRL_4:\r\ncase RT5659_BIAS_CUR_CTRL_5:\r\ncase RT5659_BIAS_CUR_CTRL_6:\r\ncase RT5659_BIAS_CUR_CTRL_7:\r\ncase RT5659_BIAS_CUR_CTRL_8:\r\ncase RT5659_BIAS_CUR_CTRL_9:\r\ncase RT5659_BIAS_CUR_CTRL_10:\r\ncase RT5659_MEMORY_TEST:\r\ncase RT5659_VREF_REC_OP_FB_CAP_CTRL:\r\ncase RT5659_CLASSD_0:\r\ncase RT5659_CLASSD_1:\r\ncase RT5659_CLASSD_2:\r\ncase RT5659_CLASSD_3:\r\ncase RT5659_CLASSD_4:\r\ncase RT5659_CLASSD_5:\r\ncase RT5659_CLASSD_6:\r\ncase RT5659_CLASSD_7:\r\ncase RT5659_CLASSD_8:\r\ncase RT5659_CLASSD_9:\r\ncase RT5659_CLASSD_10:\r\ncase RT5659_CHARGE_PUMP_1:\r\ncase RT5659_CHARGE_PUMP_2:\r\ncase RT5659_DIG_IN_CTRL_1:\r\ncase RT5659_DIG_IN_CTRL_2:\r\ncase RT5659_PAD_DRIVING_CTRL:\r\ncase RT5659_SOFT_RAMP_DEPOP:\r\ncase RT5659_PLL:\r\ncase RT5659_CHOP_DAC:\r\ncase RT5659_CHOP_ADC:\r\ncase RT5659_CALIB_ADC_CTRL:\r\ncase RT5659_SOFT_RAMP_DEPOP_DAC_CLK_CTRL:\r\ncase RT5659_VOL_TEST:\r\ncase RT5659_TEST_MODE_CTRL_1:\r\ncase RT5659_TEST_MODE_CTRL_2:\r\ncase RT5659_TEST_MODE_CTRL_3:\r\ncase RT5659_TEST_MODE_CTRL_4:\r\ncase RT5659_BASSBACK_CTRL:\r\ncase RT5659_MP3_PLUS_CTRL_1:\r\ncase RT5659_MP3_PLUS_CTRL_2:\r\ncase RT5659_MP3_HPF_A1:\r\ncase RT5659_MP3_HPF_A2:\r\ncase RT5659_MP3_HPF_H0:\r\ncase RT5659_MP3_LPF_H0:\r\ncase RT5659_3D_SPK_CTRL:\r\ncase RT5659_3D_SPK_COEF_1:\r\ncase RT5659_3D_SPK_COEF_2:\r\ncase RT5659_3D_SPK_COEF_3:\r\ncase RT5659_3D_SPK_COEF_4:\r\ncase RT5659_3D_SPK_COEF_5:\r\ncase RT5659_3D_SPK_COEF_6:\r\ncase RT5659_3D_SPK_COEF_7:\r\ncase RT5659_STO_NG2_CTRL_1:\r\ncase RT5659_STO_NG2_CTRL_2:\r\ncase RT5659_STO_NG2_CTRL_3:\r\ncase RT5659_STO_NG2_CTRL_4:\r\ncase RT5659_STO_NG2_CTRL_5:\r\ncase RT5659_STO_NG2_CTRL_6:\r\ncase RT5659_STO_NG2_CTRL_7:\r\ncase RT5659_STO_NG2_CTRL_8:\r\ncase RT5659_MONO_NG2_CTRL_1:\r\ncase RT5659_MONO_NG2_CTRL_2:\r\ncase RT5659_MONO_NG2_CTRL_3:\r\ncase RT5659_MONO_NG2_CTRL_4:\r\ncase RT5659_MONO_NG2_CTRL_5:\r\ncase RT5659_MONO_NG2_CTRL_6:\r\ncase RT5659_MID_HP_AMP_DET:\r\ncase RT5659_LOW_HP_AMP_DET:\r\ncase RT5659_LDO_CTRL:\r\ncase RT5659_HP_DECROSS_CTRL_1:\r\ncase RT5659_HP_DECROSS_CTRL_2:\r\ncase RT5659_HP_DECROSS_CTRL_3:\r\ncase RT5659_HP_DECROSS_CTRL_4:\r\ncase RT5659_HP_IMP_SENS_CTRL_1:\r\ncase RT5659_HP_IMP_SENS_CTRL_2:\r\ncase RT5659_HP_IMP_SENS_CTRL_3:\r\ncase RT5659_HP_IMP_SENS_CTRL_4:\r\ncase RT5659_HP_IMP_SENS_MAP_1:\r\ncase RT5659_HP_IMP_SENS_MAP_2:\r\ncase RT5659_HP_IMP_SENS_MAP_3:\r\ncase RT5659_HP_IMP_SENS_MAP_4:\r\ncase RT5659_HP_IMP_SENS_MAP_5:\r\ncase RT5659_HP_IMP_SENS_MAP_6:\r\ncase RT5659_HP_IMP_SENS_MAP_7:\r\ncase RT5659_HP_IMP_SENS_MAP_8:\r\ncase RT5659_HP_LOGIC_CTRL_1:\r\ncase RT5659_HP_LOGIC_CTRL_2:\r\ncase RT5659_HP_CALIB_CTRL_1:\r\ncase RT5659_HP_CALIB_CTRL_2:\r\ncase RT5659_HP_CALIB_CTRL_3:\r\ncase RT5659_HP_CALIB_CTRL_4:\r\ncase RT5659_HP_CALIB_CTRL_5:\r\ncase RT5659_HP_CALIB_CTRL_6:\r\ncase RT5659_HP_CALIB_CTRL_7:\r\ncase RT5659_HP_CALIB_CTRL_9:\r\ncase RT5659_HP_CALIB_CTRL_10:\r\ncase RT5659_HP_CALIB_CTRL_11:\r\ncase RT5659_HP_CALIB_STA_1:\r\ncase RT5659_HP_CALIB_STA_2:\r\ncase RT5659_HP_CALIB_STA_3:\r\ncase RT5659_HP_CALIB_STA_4:\r\ncase RT5659_HP_CALIB_STA_5:\r\ncase RT5659_HP_CALIB_STA_6:\r\ncase RT5659_HP_CALIB_STA_7:\r\ncase RT5659_HP_CALIB_STA_8:\r\ncase RT5659_HP_CALIB_STA_9:\r\ncase RT5659_MONO_AMP_CALIB_CTRL_1:\r\ncase RT5659_MONO_AMP_CALIB_CTRL_2:\r\ncase RT5659_MONO_AMP_CALIB_CTRL_3:\r\ncase RT5659_MONO_AMP_CALIB_CTRL_4:\r\ncase RT5659_MONO_AMP_CALIB_CTRL_5:\r\ncase RT5659_MONO_AMP_CALIB_STA_1:\r\ncase RT5659_MONO_AMP_CALIB_STA_2:\r\ncase RT5659_MONO_AMP_CALIB_STA_3:\r\ncase RT5659_MONO_AMP_CALIB_STA_4:\r\ncase RT5659_SPK_PWR_LMT_CTRL_1:\r\ncase RT5659_SPK_PWR_LMT_CTRL_2:\r\ncase RT5659_SPK_PWR_LMT_CTRL_3:\r\ncase RT5659_SPK_PWR_LMT_STA_1:\r\ncase RT5659_SPK_PWR_LMT_STA_2:\r\ncase RT5659_SPK_PWR_LMT_STA_3:\r\ncase RT5659_SPK_PWR_LMT_STA_4:\r\ncase RT5659_SPK_PWR_LMT_STA_5:\r\ncase RT5659_SPK_PWR_LMT_STA_6:\r\ncase RT5659_FLEX_SPK_BST_CTRL_1:\r\ncase RT5659_FLEX_SPK_BST_CTRL_2:\r\ncase RT5659_FLEX_SPK_BST_CTRL_3:\r\ncase RT5659_FLEX_SPK_BST_CTRL_4:\r\ncase RT5659_SPK_EX_LMT_CTRL_1:\r\ncase RT5659_SPK_EX_LMT_CTRL_2:\r\ncase RT5659_SPK_EX_LMT_CTRL_3:\r\ncase RT5659_SPK_EX_LMT_CTRL_4:\r\ncase RT5659_SPK_EX_LMT_CTRL_5:\r\ncase RT5659_SPK_EX_LMT_CTRL_6:\r\ncase RT5659_SPK_EX_LMT_CTRL_7:\r\ncase RT5659_ADJ_HPF_CTRL_1:\r\ncase RT5659_ADJ_HPF_CTRL_2:\r\ncase RT5659_SPK_DC_CAILB_CTRL_1:\r\ncase RT5659_SPK_DC_CAILB_CTRL_2:\r\ncase RT5659_SPK_DC_CAILB_CTRL_3:\r\ncase RT5659_SPK_DC_CAILB_CTRL_4:\r\ncase RT5659_SPK_DC_CAILB_CTRL_5:\r\ncase RT5659_SPK_DC_CAILB_STA_1:\r\ncase RT5659_SPK_DC_CAILB_STA_2:\r\ncase RT5659_SPK_DC_CAILB_STA_3:\r\ncase RT5659_SPK_DC_CAILB_STA_4:\r\ncase RT5659_SPK_DC_CAILB_STA_5:\r\ncase RT5659_SPK_DC_CAILB_STA_6:\r\ncase RT5659_SPK_DC_CAILB_STA_7:\r\ncase RT5659_SPK_DC_CAILB_STA_8:\r\ncase RT5659_SPK_DC_CAILB_STA_9:\r\ncase RT5659_SPK_DC_CAILB_STA_10:\r\ncase RT5659_SPK_VDD_STA_1:\r\ncase RT5659_SPK_VDD_STA_2:\r\ncase RT5659_SPK_DC_DET_CTRL_1:\r\ncase RT5659_SPK_DC_DET_CTRL_2:\r\ncase RT5659_SPK_DC_DET_CTRL_3:\r\ncase RT5659_PURE_DC_DET_CTRL_1:\r\ncase RT5659_PURE_DC_DET_CTRL_2:\r\ncase RT5659_DUMMY_4:\r\ncase RT5659_DUMMY_5:\r\ncase RT5659_DUMMY_6:\r\ncase RT5659_DRC1_CTRL_1:\r\ncase RT5659_DRC1_CTRL_2:\r\ncase RT5659_DRC1_CTRL_3:\r\ncase RT5659_DRC1_CTRL_4:\r\ncase RT5659_DRC1_CTRL_5:\r\ncase RT5659_DRC1_CTRL_6:\r\ncase RT5659_DRC1_HARD_LMT_CTRL_1:\r\ncase RT5659_DRC1_HARD_LMT_CTRL_2:\r\ncase RT5659_DRC2_CTRL_1:\r\ncase RT5659_DRC2_CTRL_2:\r\ncase RT5659_DRC2_CTRL_3:\r\ncase RT5659_DRC2_CTRL_4:\r\ncase RT5659_DRC2_CTRL_5:\r\ncase RT5659_DRC2_CTRL_6:\r\ncase RT5659_DRC2_HARD_LMT_CTRL_1:\r\ncase RT5659_DRC2_HARD_LMT_CTRL_2:\r\ncase RT5659_DRC1_PRIV_1:\r\ncase RT5659_DRC1_PRIV_2:\r\ncase RT5659_DRC1_PRIV_3:\r\ncase RT5659_DRC1_PRIV_4:\r\ncase RT5659_DRC1_PRIV_5:\r\ncase RT5659_DRC1_PRIV_6:\r\ncase RT5659_DRC1_PRIV_7:\r\ncase RT5659_DRC2_PRIV_1:\r\ncase RT5659_DRC2_PRIV_2:\r\ncase RT5659_DRC2_PRIV_3:\r\ncase RT5659_DRC2_PRIV_4:\r\ncase RT5659_DRC2_PRIV_5:\r\ncase RT5659_DRC2_PRIV_6:\r\ncase RT5659_DRC2_PRIV_7:\r\ncase RT5659_MULTI_DRC_CTRL:\r\ncase RT5659_CROSS_OVER_1:\r\ncase RT5659_CROSS_OVER_2:\r\ncase RT5659_CROSS_OVER_3:\r\ncase RT5659_CROSS_OVER_4:\r\ncase RT5659_CROSS_OVER_5:\r\ncase RT5659_CROSS_OVER_6:\r\ncase RT5659_CROSS_OVER_7:\r\ncase RT5659_CROSS_OVER_8:\r\ncase RT5659_CROSS_OVER_9:\r\ncase RT5659_CROSS_OVER_10:\r\ncase RT5659_ALC_PGA_CTRL_1:\r\ncase RT5659_ALC_PGA_CTRL_2:\r\ncase RT5659_ALC_PGA_CTRL_3:\r\ncase RT5659_ALC_PGA_CTRL_4:\r\ncase RT5659_ALC_PGA_CTRL_5:\r\ncase RT5659_ALC_PGA_CTRL_6:\r\ncase RT5659_ALC_PGA_CTRL_7:\r\ncase RT5659_ALC_PGA_CTRL_8:\r\ncase RT5659_ALC_PGA_STA_1:\r\ncase RT5659_ALC_PGA_STA_2:\r\ncase RT5659_ALC_PGA_STA_3:\r\ncase RT5659_DAC_L_EQ_PRE_VOL:\r\ncase RT5659_DAC_R_EQ_PRE_VOL:\r\ncase RT5659_DAC_L_EQ_POST_VOL:\r\ncase RT5659_DAC_R_EQ_POST_VOL:\r\ncase RT5659_DAC_L_EQ_LPF1_A1:\r\ncase RT5659_DAC_L_EQ_LPF1_H0:\r\ncase RT5659_DAC_R_EQ_LPF1_A1:\r\ncase RT5659_DAC_R_EQ_LPF1_H0:\r\ncase RT5659_DAC_L_EQ_BPF2_A1:\r\ncase RT5659_DAC_L_EQ_BPF2_A2:\r\ncase RT5659_DAC_L_EQ_BPF2_H0:\r\ncase RT5659_DAC_R_EQ_BPF2_A1:\r\ncase RT5659_DAC_R_EQ_BPF2_A2:\r\ncase RT5659_DAC_R_EQ_BPF2_H0:\r\ncase RT5659_DAC_L_EQ_BPF3_A1:\r\ncase RT5659_DAC_L_EQ_BPF3_A2:\r\ncase RT5659_DAC_L_EQ_BPF3_H0:\r\ncase RT5659_DAC_R_EQ_BPF3_A1:\r\ncase RT5659_DAC_R_EQ_BPF3_A2:\r\ncase RT5659_DAC_R_EQ_BPF3_H0:\r\ncase RT5659_DAC_L_EQ_BPF4_A1:\r\ncase RT5659_DAC_L_EQ_BPF4_A2:\r\ncase RT5659_DAC_L_EQ_BPF4_H0:\r\ncase RT5659_DAC_R_EQ_BPF4_A1:\r\ncase RT5659_DAC_R_EQ_BPF4_A2:\r\ncase RT5659_DAC_R_EQ_BPF4_H0:\r\ncase RT5659_DAC_L_EQ_HPF1_A1:\r\ncase RT5659_DAC_L_EQ_HPF1_H0:\r\ncase RT5659_DAC_R_EQ_HPF1_A1:\r\ncase RT5659_DAC_R_EQ_HPF1_H0:\r\ncase RT5659_DAC_L_EQ_HPF2_A1:\r\ncase RT5659_DAC_L_EQ_HPF2_A2:\r\ncase RT5659_DAC_L_EQ_HPF2_H0:\r\ncase RT5659_DAC_R_EQ_HPF2_A1:\r\ncase RT5659_DAC_R_EQ_HPF2_A2:\r\ncase RT5659_DAC_R_EQ_HPF2_H0:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_H0_1:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_H0_2:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_B1_1:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_B1_2:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_B2_1:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_B2_2:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_A1_1:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_A1_2:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_A2_1:\r\ncase RT5659_DAC_L_BI_EQ_BPF1_A2_2:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_H0_1:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_H0_2:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_B1_1:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_B1_2:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_B2_1:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_B2_2:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_A1_1:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_A1_2:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_A2_1:\r\ncase RT5659_DAC_R_BI_EQ_BPF1_A2_2:\r\ncase RT5659_ADC_L_EQ_LPF1_A1:\r\ncase RT5659_ADC_R_EQ_LPF1_A1:\r\ncase RT5659_ADC_L_EQ_LPF1_H0:\r\ncase RT5659_ADC_R_EQ_LPF1_H0:\r\ncase RT5659_ADC_L_EQ_BPF1_A1:\r\ncase RT5659_ADC_R_EQ_BPF1_A1:\r\ncase RT5659_ADC_L_EQ_BPF1_A2:\r\ncase RT5659_ADC_R_EQ_BPF1_A2:\r\ncase RT5659_ADC_L_EQ_BPF1_H0:\r\ncase RT5659_ADC_R_EQ_BPF1_H0:\r\ncase RT5659_ADC_L_EQ_BPF2_A1:\r\ncase RT5659_ADC_R_EQ_BPF2_A1:\r\ncase RT5659_ADC_L_EQ_BPF2_A2:\r\ncase RT5659_ADC_R_EQ_BPF2_A2:\r\ncase RT5659_ADC_L_EQ_BPF2_H0:\r\ncase RT5659_ADC_R_EQ_BPF2_H0:\r\ncase RT5659_ADC_L_EQ_BPF3_A1:\r\ncase RT5659_ADC_R_EQ_BPF3_A1:\r\ncase RT5659_ADC_L_EQ_BPF3_A2:\r\ncase RT5659_ADC_R_EQ_BPF3_A2:\r\ncase RT5659_ADC_L_EQ_BPF3_H0:\r\ncase RT5659_ADC_R_EQ_BPF3_H0:\r\ncase RT5659_ADC_L_EQ_BPF4_A1:\r\ncase RT5659_ADC_R_EQ_BPF4_A1:\r\ncase RT5659_ADC_L_EQ_BPF4_A2:\r\ncase RT5659_ADC_R_EQ_BPF4_A2:\r\ncase RT5659_ADC_L_EQ_BPF4_H0:\r\ncase RT5659_ADC_R_EQ_BPF4_H0:\r\ncase RT5659_ADC_L_EQ_HPF1_A1:\r\ncase RT5659_ADC_R_EQ_HPF1_A1:\r\ncase RT5659_ADC_L_EQ_HPF1_H0:\r\ncase RT5659_ADC_R_EQ_HPF1_H0:\r\ncase RT5659_ADC_L_EQ_PRE_VOL:\r\ncase RT5659_ADC_R_EQ_PRE_VOL:\r\ncase RT5659_ADC_L_EQ_POST_VOL:\r\ncase RT5659_ADC_R_EQ_POST_VOL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int rt5659_hp_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nint ret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (snd_soc_read(codec, RT5659_STO_NG2_CTRL_1) & RT5659_NG2_EN) {\r\nsnd_soc_update_bits(codec, RT5659_STO_NG2_CTRL_1,\r\nRT5659_NG2_EN_MASK, RT5659_NG2_DIS);\r\nsnd_soc_update_bits(codec, RT5659_STO_NG2_CTRL_1,\r\nRT5659_NG2_EN_MASK, RT5659_NG2_EN);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rt5659_enable_push_button_irq(struct snd_soc_codec *codec,\r\nbool enable)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nif (enable) {\r\nsnd_soc_write(codec, RT5659_4BTN_IL_CMD_1, 0x000b);\r\nsnd_soc_dapm_force_enable_pin(dapm, "MICBIAS1");\r\nsnd_soc_dapm_force_enable_pin(dapm,\r\n"Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\nsnd_soc_update_bits(codec, RT5659_PWR_ANLG_2,\r\nRT5659_PWR_MB1, RT5659_PWR_MB1);\r\nsnd_soc_update_bits(codec, RT5659_PWR_VOL,\r\nRT5659_PWR_MIC_DET, RT5659_PWR_MIC_DET);\r\nsnd_soc_update_bits(codec, RT5659_IRQ_CTRL_2,\r\nRT5659_IL_IRQ_MASK, RT5659_IL_IRQ_EN);\r\nsnd_soc_update_bits(codec, RT5659_4BTN_IL_CMD_2,\r\nRT5659_4BTN_IL_MASK, RT5659_4BTN_IL_EN);\r\n} else {\r\nsnd_soc_update_bits(codec, RT5659_4BTN_IL_CMD_2,\r\nRT5659_4BTN_IL_MASK, RT5659_4BTN_IL_DIS);\r\nsnd_soc_update_bits(codec, RT5659_IRQ_CTRL_2,\r\nRT5659_IL_IRQ_MASK, RT5659_IL_IRQ_DIS);\r\nsnd_soc_dapm_disable_pin(dapm, "MICBIAS1");\r\nsnd_soc_dapm_disable_pin(dapm, "Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\n}\r\nstatic int rt5659_headset_detect(struct snd_soc_codec *codec, int jack_insert)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nint val, i = 0, sleep_time[5] = {300, 150, 100, 50, 30};\r\nint reg_63;\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nif (jack_insert) {\r\nsnd_soc_dapm_force_enable_pin(dapm,\r\n"Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\nreg_63 = snd_soc_read(codec, RT5659_PWR_ANLG_1);\r\nsnd_soc_update_bits(codec, RT5659_PWR_ANLG_1,\r\nRT5659_PWR_VREF2 | RT5659_PWR_MB,\r\nRT5659_PWR_VREF2 | RT5659_PWR_MB);\r\nmsleep(20);\r\nsnd_soc_update_bits(codec, RT5659_PWR_ANLG_1,\r\nRT5659_PWR_FV2, RT5659_PWR_FV2);\r\nsnd_soc_write(codec, RT5659_EJD_CTRL_2, 0x4160);\r\nsnd_soc_update_bits(codec, RT5659_EJD_CTRL_1,\r\n0x20, 0x0);\r\nmsleep(20);\r\nsnd_soc_update_bits(codec, RT5659_EJD_CTRL_1,\r\n0x20, 0x20);\r\nwhile (i < 5) {\r\nmsleep(sleep_time[i]);\r\nval = snd_soc_read(codec, RT5659_EJD_CTRL_2) & 0x0003;\r\ni++;\r\nif (val == 0x1 || val == 0x2 || val == 0x3)\r\nbreak;\r\n}\r\nswitch (val) {\r\ncase 1:\r\nrt5659->jack_type = SND_JACK_HEADSET;\r\nrt5659_enable_push_button_irq(codec, true);\r\nbreak;\r\ndefault:\r\nsnd_soc_write(codec, RT5659_PWR_ANLG_1, reg_63);\r\nrt5659->jack_type = SND_JACK_HEADPHONE;\r\nsnd_soc_dapm_disable_pin(dapm, "Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\nbreak;\r\n}\r\n} else {\r\nsnd_soc_dapm_disable_pin(dapm, "Mic Det Power");\r\nsnd_soc_dapm_sync(dapm);\r\nif (rt5659->jack_type == SND_JACK_HEADSET)\r\nrt5659_enable_push_button_irq(codec, false);\r\nrt5659->jack_type = 0;\r\n}\r\ndev_dbg(codec->dev, "jack_type = %d\n", rt5659->jack_type);\r\nreturn rt5659->jack_type;\r\n}\r\nstatic int rt5659_button_detect(struct snd_soc_codec *codec)\r\n{\r\nint btn_type, val;\r\nval = snd_soc_read(codec, RT5659_4BTN_IL_CMD_1);\r\nbtn_type = val & 0xfff0;\r\nsnd_soc_write(codec, RT5659_4BTN_IL_CMD_1, val);\r\nreturn btn_type;\r\n}\r\nstatic irqreturn_t rt5659_irq(int irq, void *data)\r\n{\r\nstruct rt5659_priv *rt5659 = data;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&rt5659->jack_detect_work, msecs_to_jiffies(250));\r\nreturn IRQ_HANDLED;\r\n}\r\nint rt5659_set_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *hs_jack)\r\n{\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nrt5659->hs_jack = hs_jack;\r\nrt5659_irq(0, rt5659);\r\nreturn 0;\r\n}\r\nstatic void rt5659_jack_detect_work(struct work_struct *work)\r\n{\r\nstruct rt5659_priv *rt5659 =\r\ncontainer_of(work, struct rt5659_priv, jack_detect_work.work);\r\nint val, btn_type, report = 0;\r\nif (!rt5659->codec)\r\nreturn;\r\nval = snd_soc_read(rt5659->codec, RT5659_INT_ST_1) & 0x0080;\r\nif (!val) {\r\nif (rt5659->jack_type == 0) {\r\nreport = rt5659_headset_detect(rt5659->codec, 1);\r\n} else {\r\nreport = SND_JACK_HEADSET;\r\nbtn_type = rt5659_button_detect(rt5659->codec);\r\nswitch (btn_type) {\r\ncase 0x8000:\r\ncase 0x4000:\r\ncase 0x2000:\r\nreport |= SND_JACK_BTN_0;\r\nbreak;\r\ncase 0x1000:\r\ncase 0x0800:\r\ncase 0x0400:\r\nreport |= SND_JACK_BTN_1;\r\nbreak;\r\ncase 0x0200:\r\ncase 0x0100:\r\ncase 0x0080:\r\nreport |= SND_JACK_BTN_2;\r\nbreak;\r\ncase 0x0040:\r\ncase 0x0020:\r\ncase 0x0010:\r\nreport |= SND_JACK_BTN_3;\r\nbreak;\r\ncase 0x0000:\r\nbreak;\r\ndefault:\r\nbtn_type = 0;\r\ndev_err(rt5659->codec->dev,\r\n"Unexpected button code 0x%04x\n",\r\nbtn_type);\r\nbreak;\r\n}\r\nif (btn_type == 0)\r\nreport = rt5659->jack_type;\r\n}\r\n} else {\r\nreport = rt5659_headset_detect(rt5659->codec, 0);\r\n}\r\nsnd_soc_jack_report(rt5659->hs_jack, report, SND_JACK_HEADSET |\r\nSND_JACK_BTN_0 | SND_JACK_BTN_1 |\r\nSND_JACK_BTN_2 | SND_JACK_BTN_3);\r\n}\r\nstatic int set_dmic_clk(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nint pd, idx = -EINVAL;\r\npd = rl6231_get_pre_div(rt5659->regmap,\r\nRT5659_ADDA_CLK_1, RT5659_I2S_PD1_SFT);\r\nidx = rl6231_calc_dmic_clk(rt5659->sysclk / pd);\r\nif (idx < 0)\r\ndev_err(codec->dev, "Failed to set DMIC clock\n");\r\nelse {\r\nsnd_soc_update_bits(codec, RT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_CLK_MASK, idx << RT5659_DMIC_CLK_SFT);\r\n}\r\nreturn idx;\r\n}\r\nstatic int set_adc_clk(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, RT5659_CHOP_ADC,\r\nRT5659_CKXEN_ADCC_MASK | RT5659_CKGEN_ADCC_MASK,\r\nRT5659_CKXEN_ADCC_MASK | RT5659_CKGEN_ADCC_MASK);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, RT5659_CHOP_ADC,\r\nRT5659_CKXEN_ADCC_MASK | RT5659_CKGEN_ADCC_MASK, 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_charge_pump_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_write(codec, RT5659_DEPOP_1, 0x0009);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(codec, RT5659_HP_CHARGE_PUMP_1, 0x0c16);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_sys_clk_from_pll(struct snd_soc_dapm_widget *w,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int val;\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nval = snd_soc_read(codec, RT5659_GLB_CLK);\r\nval &= RT5659_SCLK_SRC_MASK;\r\nif (val == RT5659_SCLK_SRC_PLL1)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int is_using_asrc(struct snd_soc_dapm_widget *w,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg, shift, val;\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (w->shift) {\r\ncase RT5659_ADC_MONO_R_ASRC_SFT:\r\nreg = RT5659_ASRC_3;\r\nshift = RT5659_AD_MONO_R_T_SFT;\r\nbreak;\r\ncase RT5659_ADC_MONO_L_ASRC_SFT:\r\nreg = RT5659_ASRC_3;\r\nshift = RT5659_AD_MONO_L_T_SFT;\r\nbreak;\r\ncase RT5659_ADC_STO1_ASRC_SFT:\r\nreg = RT5659_ASRC_2;\r\nshift = RT5659_AD_STO1_T_SFT;\r\nbreak;\r\ncase RT5659_DAC_MONO_R_ASRC_SFT:\r\nreg = RT5659_ASRC_2;\r\nshift = RT5659_DA_MONO_R_T_SFT;\r\nbreak;\r\ncase RT5659_DAC_MONO_L_ASRC_SFT:\r\nreg = RT5659_ASRC_2;\r\nshift = RT5659_DA_MONO_L_T_SFT;\r\nbreak;\r\ncase RT5659_DAC_STO_ASRC_SFT:\r\nreg = RT5659_ASRC_2;\r\nshift = RT5659_DA_STO_T_SFT;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nval = (snd_soc_read(codec, reg) >> shift) & 0xf;\r\nswitch (val) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nsnd_soc_update_bits(codec, RT5659_ADDA_CLK_1,\r\nRT5659_I2S_PD1_MASK, RT5659_I2S_PD1_2);\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int rt5659_spk_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, RT5659_CLASSD_CTRL_1,\r\nRT5659_POW_CLSD_DB_MASK, RT5659_POW_CLSD_DB_EN);\r\nsnd_soc_update_bits(codec, RT5659_CLASSD_2,\r\nRT5659_M_RI_DIG, RT5659_M_RI_DIG);\r\nsnd_soc_write(codec, RT5659_CLASSD_1, 0x0803);\r\nsnd_soc_write(codec, RT5659_SPK_DC_CAILB_CTRL_3, 0x0000);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(codec, RT5659_CLASSD_1, 0x0011);\r\nsnd_soc_update_bits(codec, RT5659_CLASSD_2,\r\nRT5659_M_RI_DIG, 0x0);\r\nsnd_soc_write(codec, RT5659_SPK_DC_CAILB_CTRL_3, 0x0003);\r\nsnd_soc_update_bits(codec, RT5659_CLASSD_CTRL_1,\r\nRT5659_POW_CLSD_DB_MASK, RT5659_POW_CLSD_DB_DIS);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_mono_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_write(codec, RT5659_MONO_AMP_CALIB_CTRL_1, 0x1e00);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(codec, RT5659_MONO_AMP_CALIB_CTRL_1, 0x1e04);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_write(codec, RT5659_HP_CHARGE_PUMP_1, 0x0e1e);\r\nsnd_soc_update_bits(codec, RT5659_DEPOP_1, 0x0010, 0x0010);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_write(codec, RT5659_DEPOP_1, 0x0000);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_dmic_power(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nmsleep(450);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val_len = 0, val_clk, mask_clk;\r\nint pre_div, frame_size;\r\nrt5659->lrck[dai->id] = params_rate(params);\r\npre_div = rl6231_get_clk_info(rt5659->sysclk, rt5659->lrck[dai->id]);\r\nif (pre_div < 0) {\r\ndev_err(codec->dev, "Unsupported clock setting %d for DAI %d\n",\r\nrt5659->lrck[dai->id], dai->id);\r\nreturn -EINVAL;\r\n}\r\nframe_size = snd_soc_params_to_frame_size(params);\r\nif (frame_size < 0) {\r\ndev_err(codec->dev, "Unsupported frame size: %d\n", frame_size);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "lrck is %dHz and pre_div is %d for iis %d\n",\r\nrt5659->lrck[dai->id], pre_div, dai->id);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\nval_len |= RT5659_I2S_DL_20;\r\nbreak;\r\ncase 24:\r\nval_len |= RT5659_I2S_DL_24;\r\nbreak;\r\ncase 8:\r\nval_len |= RT5659_I2S_DL_8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (dai->id) {\r\ncase RT5659_AIF1:\r\nmask_clk = RT5659_I2S_PD1_MASK;\r\nval_clk = pre_div << RT5659_I2S_PD1_SFT;\r\nsnd_soc_update_bits(codec, RT5659_I2S1_SDP,\r\nRT5659_I2S_DL_MASK, val_len);\r\nbreak;\r\ncase RT5659_AIF2:\r\nmask_clk = RT5659_I2S_PD2_MASK;\r\nval_clk = pre_div << RT5659_I2S_PD2_SFT;\r\nsnd_soc_update_bits(codec, RT5659_I2S2_SDP,\r\nRT5659_I2S_DL_MASK, val_len);\r\nbreak;\r\ncase RT5659_AIF3:\r\nmask_clk = RT5659_I2S_PD3_MASK;\r\nval_clk = pre_div << RT5659_I2S_PD3_SFT;\r\nsnd_soc_update_bits(codec, RT5659_I2S3_SDP,\r\nRT5659_I2S_DL_MASK, val_len);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT5659_ADDA_CLK_1, mask_clk, val_clk);\r\nswitch (rt5659->lrck[dai->id]) {\r\ncase 192000:\r\nsnd_soc_update_bits(codec, RT5659_ADDA_CLK_1,\r\nRT5659_DAC_OSR_MASK, RT5659_DAC_OSR_32);\r\nbreak;\r\ncase 96000:\r\nsnd_soc_update_bits(codec, RT5659_ADDA_CLK_1,\r\nRT5659_DAC_OSR_MASK, RT5659_DAC_OSR_64);\r\nbreak;\r\ndefault:\r\nsnd_soc_update_bits(codec, RT5659_ADDA_CLK_1,\r\nRT5659_DAC_OSR_MASK, RT5659_DAC_OSR_128);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg_val = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nrt5659->master[dai->id] = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nreg_val |= RT5659_I2S_MS_S;\r\nrt5659->master[dai->id] = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nreg_val |= RT5659_I2S_BP_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nreg_val |= RT5659_I2S_DF_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nreg_val |= RT5659_I2S_DF_PCM_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nreg_val |= RT5659_I2S_DF_PCM_B;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (dai->id) {\r\ncase RT5659_AIF1:\r\nsnd_soc_update_bits(codec, RT5659_I2S1_SDP,\r\nRT5659_I2S_MS_MASK | RT5659_I2S_BP_MASK |\r\nRT5659_I2S_DF_MASK, reg_val);\r\nbreak;\r\ncase RT5659_AIF2:\r\nsnd_soc_update_bits(codec, RT5659_I2S2_SDP,\r\nRT5659_I2S_MS_MASK | RT5659_I2S_BP_MASK |\r\nRT5659_I2S_DF_MASK, reg_val);\r\nbreak;\r\ncase RT5659_AIF3:\r\nsnd_soc_update_bits(codec, RT5659_I2S3_SDP,\r\nRT5659_I2S_MS_MASK | RT5659_I2S_BP_MASK |\r\nRT5659_I2S_DF_MASK, reg_val);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg_val = 0;\r\nif (freq == rt5659->sysclk && clk_id == rt5659->sysclk_src)\r\nreturn 0;\r\nswitch (clk_id) {\r\ncase RT5659_SCLK_S_MCLK:\r\nreg_val |= RT5659_SCLK_SRC_MCLK;\r\nbreak;\r\ncase RT5659_SCLK_S_PLL1:\r\nreg_val |= RT5659_SCLK_SRC_PLL1;\r\nbreak;\r\ncase RT5659_SCLK_S_RCCLK:\r\nreg_val |= RT5659_SCLK_SRC_RCCLK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid clock id (%d)\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT5659_GLB_CLK,\r\nRT5659_SCLK_SRC_MASK, reg_val);\r\nrt5659->sysclk = freq;\r\nrt5659->sysclk_src = clk_id;\r\ndev_dbg(dai->dev, "Sysclk is %dHz and clock id is %d\n", freq, clk_id);\r\nreturn 0;\r\n}\r\nstatic int rt5659_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int Source,\r\nunsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nstruct rl6231_pll_code pll_code;\r\nint ret;\r\nif (Source == rt5659->pll_src && freq_in == rt5659->pll_in &&\r\nfreq_out == rt5659->pll_out)\r\nreturn 0;\r\nif (!freq_in || !freq_out) {\r\ndev_dbg(codec->dev, "PLL disabled\n");\r\nrt5659->pll_in = 0;\r\nrt5659->pll_out = 0;\r\nsnd_soc_update_bits(codec, RT5659_GLB_CLK,\r\nRT5659_SCLK_SRC_MASK, RT5659_SCLK_SRC_MCLK);\r\nreturn 0;\r\n}\r\nswitch (Source) {\r\ncase RT5659_PLL1_S_MCLK:\r\nsnd_soc_update_bits(codec, RT5659_GLB_CLK,\r\nRT5659_PLL1_SRC_MASK, RT5659_PLL1_SRC_MCLK);\r\nbreak;\r\ncase RT5659_PLL1_S_BCLK1:\r\nsnd_soc_update_bits(codec, RT5659_GLB_CLK,\r\nRT5659_PLL1_SRC_MASK, RT5659_PLL1_SRC_BCLK1);\r\nbreak;\r\ncase RT5659_PLL1_S_BCLK2:\r\nsnd_soc_update_bits(codec, RT5659_GLB_CLK,\r\nRT5659_PLL1_SRC_MASK, RT5659_PLL1_SRC_BCLK2);\r\nbreak;\r\ncase RT5659_PLL1_S_BCLK3:\r\nsnd_soc_update_bits(codec, RT5659_GLB_CLK,\r\nRT5659_PLL1_SRC_MASK, RT5659_PLL1_SRC_BCLK3);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown PLL Source %d\n", Source);\r\nreturn -EINVAL;\r\n}\r\nret = rl6231_pll_calc(freq_in, freq_out, &pll_code);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Unsupport input clock %d\n", freq_in);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "bypass=%d m=%d n=%d k=%d\n",\r\npll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\r\npll_code.n_code, pll_code.k_code);\r\nsnd_soc_write(codec, RT5659_PLL_CTRL_1,\r\npll_code.n_code << RT5659_PLL_N_SFT | pll_code.k_code);\r\nsnd_soc_write(codec, RT5659_PLL_CTRL_2,\r\n(pll_code.m_bp ? 0 : pll_code.m_code) << RT5659_PLL_M_SFT |\r\npll_code.m_bp << RT5659_PLL_M_BP_SFT);\r\nrt5659->pll_in = freq_in;\r\nrt5659->pll_out = freq_out;\r\nrt5659->pll_src = Source;\r\nreturn 0;\r\n}\r\nstatic int rt5659_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val = 0;\r\nif (rx_mask || tx_mask)\r\nval |= (1 << 15);\r\nswitch (slots) {\r\ncase 4:\r\nval |= (1 << 10);\r\nval |= (1 << 8);\r\nbreak;\r\ncase 6:\r\nval |= (2 << 10);\r\nval |= (2 << 8);\r\nbreak;\r\ncase 8:\r\nval |= (3 << 10);\r\nval |= (3 << 8);\r\nbreak;\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (slot_width) {\r\ncase 20:\r\nval |= (1 << 6);\r\nval |= (1 << 4);\r\nbreak;\r\ncase 24:\r\nval |= (2 << 6);\r\nval |= (2 << 4);\r\nbreak;\r\ncase 32:\r\nval |= (3 << 6);\r\nval |= (3 << 4);\r\nbreak;\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT5659_TDM_CTRL_1, 0x8ff0, val);\r\nreturn 0;\r\n}\r\nstatic int rt5659_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "%s ratio=%d\n", __func__, ratio);\r\nrt5659->bclk[dai->id] = ratio;\r\nif (ratio == 64) {\r\nswitch (dai->id) {\r\ncase RT5659_AIF2:\r\nsnd_soc_update_bits(codec, RT5659_ADDA_CLK_1,\r\nRT5659_I2S_BCLK_MS2_MASK,\r\nRT5659_I2S_BCLK_MS2_64);\r\nbreak;\r\ncase RT5659_AIF3:\r\nsnd_soc_update_bits(codec, RT5659_ADDA_CLK_1,\r\nRT5659_I2S_BCLK_MS3_MASK,\r\nRT5659_I2S_BCLK_MS3_64);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nregmap_update_bits(rt5659->regmap, RT5659_DIG_MISC,\r\nRT5659_DIG_GATE_CTRL, RT5659_DIG_GATE_CTRL);\r\nregmap_update_bits(rt5659->regmap, RT5659_PWR_DIG_1,\r\nRT5659_PWR_LDO, RT5659_PWR_LDO);\r\nregmap_update_bits(rt5659->regmap, RT5659_PWR_ANLG_1,\r\nRT5659_PWR_MB | RT5659_PWR_VREF1 | RT5659_PWR_VREF2,\r\nRT5659_PWR_MB | RT5659_PWR_VREF1 | RT5659_PWR_VREF2);\r\nmsleep(20);\r\nregmap_update_bits(rt5659->regmap, RT5659_PWR_ANLG_1,\r\nRT5659_PWR_FV1 | RT5659_PWR_FV2,\r\nRT5659_PWR_FV1 | RT5659_PWR_FV2);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(rt5659->regmap, RT5659_PWR_DIG_1,\r\nRT5659_PWR_LDO, 0);\r\nregmap_update_bits(rt5659->regmap, RT5659_PWR_ANLG_1,\r\nRT5659_PWR_MB | RT5659_PWR_VREF1 | RT5659_PWR_VREF2\r\n| RT5659_PWR_FV1 | RT5659_PWR_FV2,\r\nRT5659_PWR_MB | RT5659_PWR_VREF2);\r\nregmap_update_bits(rt5659->regmap, RT5659_DIG_MISC,\r\nRT5659_DIG_GATE_CTRL, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5659_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nrt5659->codec = codec;\r\nreturn 0;\r\n}\r\nstatic int rt5659_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nregmap_write(rt5659->regmap, RT5659_RESET, 0);\r\nreturn 0;\r\n}\r\nstatic int rt5659_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(rt5659->regmap, true);\r\nregcache_mark_dirty(rt5659->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt5659_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5659_priv *rt5659 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(rt5659->regmap, false);\r\nregcache_sync(rt5659->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt5659_parse_dt(struct rt5659_priv *rt5659, struct device *dev)\r\n{\r\nrt5659->pdata.in1_diff = device_property_read_bool(dev,\r\n"realtek,in1-differential");\r\nrt5659->pdata.in3_diff = device_property_read_bool(dev,\r\n"realtek,in3-differential");\r\nrt5659->pdata.in4_diff = device_property_read_bool(dev,\r\n"realtek,in4-differential");\r\ndevice_property_read_u32(dev, "realtek,dmic1-data-pin",\r\n&rt5659->pdata.dmic1_data_pin);\r\ndevice_property_read_u32(dev, "realtek,dmic2-data-pin",\r\n&rt5659->pdata.dmic2_data_pin);\r\ndevice_property_read_u32(dev, "realtek,jd-src",\r\n&rt5659->pdata.jd_src);\r\nreturn 0;\r\n}\r\nstatic void rt5659_calibrate(struct rt5659_priv *rt5659)\r\n{\r\nint value, count;\r\nregmap_write(rt5659->regmap, RT5659_BIAS_CUR_CTRL_8, 0xa502);\r\nregmap_write(rt5659->regmap, RT5659_CHOP_DAC, 0x3030);\r\nregmap_write(rt5659->regmap, RT5659_PRE_DIV_1, 0xef00);\r\nregmap_write(rt5659->regmap, RT5659_PRE_DIV_2, 0xeffc);\r\nregmap_write(rt5659->regmap, RT5659_MICBIAS_2, 0x0280);\r\nregmap_write(rt5659->regmap, RT5659_DIG_MISC, 0x0001);\r\nregmap_write(rt5659->regmap, RT5659_GLB_CLK, 0x8000);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_1, 0xaa7e);\r\nmsleep(60);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_1, 0xfe7e);\r\nmsleep(50);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_3, 0x0004);\r\nregmap_write(rt5659->regmap, RT5659_PWR_DIG_2, 0x0400);\r\nmsleep(50);\r\nregmap_write(rt5659->regmap, RT5659_PWR_DIG_1, 0x0080);\r\nusleep_range(10000, 10005);\r\nregmap_write(rt5659->regmap, RT5659_DEPOP_1, 0x0009);\r\nmsleep(50);\r\nregmap_write(rt5659->regmap, RT5659_PWR_DIG_1, 0x0f80);\r\nmsleep(50);\r\nregmap_write(rt5659->regmap, RT5659_HP_CHARGE_PUMP_1, 0x0e16);\r\nmsleep(50);\r\nregmap_write(rt5659->regmap, RT5659_CAL_REC, 0x0505);\r\nmsleep(50);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_3, 0x0184);\r\nregmap_write(rt5659->regmap, RT5659_CALIB_ADC_CTRL, 0x3c05);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_2, 0x20c1);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_2, 0x2cc1);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_1, 0x5100);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_7, 0x0014);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_1, 0xd100);\r\nmsleep(60);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_2, 0x2cc1);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_1, 0x4900);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_7, 0x0016);\r\nregmap_update_bits(rt5659->regmap, RT5659_HP_CALIB_CTRL_1,\r\n0x8000, 0x8000);\r\ncount = 0;\r\nwhile (true) {\r\nregmap_read(rt5659->regmap, RT5659_HP_CALIB_CTRL_1, &value);\r\nif (value & 0x8000)\r\nusleep_range(10000, 10005);\r\nelse\r\nbreak;\r\nif (count > 30) {\r\ndev_err(rt5659->codec->dev,\r\n"HP Calibration 1 Failure\n");\r\nreturn;\r\n}\r\ncount++;\r\n}\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_2, 0x2cc1);\r\nregmap_write(rt5659->regmap, RT5659_HP_VOL, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_1, 0x4500);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_7, 0x001f);\r\nregmap_update_bits(rt5659->regmap, RT5659_HP_CALIB_CTRL_1,\r\n0x8000, 0x8000);\r\ncount = 0;\r\nwhile (true) {\r\nregmap_read(rt5659->regmap, RT5659_HP_CALIB_CTRL_1, &value);\r\nif (value & 0x8000)\r\nusleep_range(10000, 10005);\r\nelse\r\nbreak;\r\nif (count > 85) {\r\ndev_err(rt5659->codec->dev,\r\n"HP Calibration 2 Failure\n");\r\nreturn;\r\n}\r\ncount++;\r\n}\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_7, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_2, 0x20c0);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_0, 0x2021);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_CTRL_1, 0x0260);\r\nregmap_write(rt5659->regmap, RT5659_PWR_MIXER, 0x3000);\r\nregmap_write(rt5659->regmap, RT5659_PWR_VOL, 0xc000);\r\nregmap_write(rt5659->regmap, RT5659_A_DAC_MUX, 0x000c);\r\nregmap_write(rt5659->regmap, RT5659_DIG_MISC, 0x8000);\r\nregmap_write(rt5659->regmap, RT5659_SPO_VOL, 0x0808);\r\nregmap_write(rt5659->regmap, RT5659_SPK_L_MIXER, 0x001e);\r\nregmap_write(rt5659->regmap, RT5659_SPK_R_MIXER, 0x001e);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_1, 0x0803);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_2, 0x0554);\r\nregmap_write(rt5659->regmap, RT5659_SPO_AMP_GAIN, 0x1103);\r\nregmap_write(rt5659->regmap, RT5659_CAL_REC, 0x0909);\r\nregmap_update_bits(rt5659->regmap, RT5659_HP_CALIB_CTRL_2, 0x0001,\r\n0x0001);\r\nregmap_write(rt5659->regmap, RT5659_SPK_DC_CAILB_CTRL_3, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_0, 0x0021);\r\nregmap_write(rt5659->regmap, RT5659_SPK_DC_CAILB_CTRL_1, 0x3e80);\r\nregmap_update_bits(rt5659->regmap, RT5659_SPK_DC_CAILB_CTRL_1,\r\n0x8000, 0x8000);\r\ncount = 0;\r\nwhile (true) {\r\nregmap_read(rt5659->regmap,\r\nRT5659_SPK_DC_CAILB_CTRL_1, &value);\r\nif (value & 0x8000)\r\nusleep_range(10000, 10005);\r\nelse\r\nbreak;\r\nif (count > 10) {\r\ndev_err(rt5659->codec->dev,\r\n"SPK Calibration Failure\n");\r\nreturn;\r\n}\r\ncount++;\r\n}\r\nregmap_write(rt5659->regmap, RT5659_DIG_MISC, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_MONOMIX_IN_GAIN, 0x021f);\r\nregmap_write(rt5659->regmap, RT5659_MONO_OUT, 0x480a);\r\nregmap_write(rt5659->regmap, RT5659_MONO_GAIN, 0x0003);\r\nregmap_write(rt5659->regmap, RT5659_MONO_NG2_CTRL_5, 0x0009);\r\nregmap_write(rt5659->regmap, RT5659_SPK_DC_CAILB_CTRL_3, 0x000f);\r\nregmap_write(rt5659->regmap, RT5659_MONO_AMP_CALIB_CTRL_1, 0x1e00);\r\nregmap_update_bits(rt5659->regmap, RT5659_MONO_AMP_CALIB_CTRL_1,\r\n0x8000, 0x8000);\r\ncount = 0;\r\nwhile (true) {\r\nregmap_read(rt5659->regmap, RT5659_MONO_AMP_CALIB_CTRL_1,\r\n&value);\r\nif (value & 0x8000)\r\nusleep_range(10000, 10005);\r\nelse\r\nbreak;\r\nif (count > 35) {\r\ndev_err(rt5659->codec->dev,\r\n"Mono Calibration Failure\n");\r\nreturn;\r\n}\r\ncount++;\r\n}\r\nregmap_write(rt5659->regmap, RT5659_SPK_DC_CAILB_CTRL_3, 0x0003);\r\nregmap_write(rt5659->regmap, RT5659_CAL_REC, 0x0808);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_3, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_CALIB_ADC_CTRL, 0x2005);\r\nregmap_write(rt5659->regmap, RT5659_HP_CALIB_CTRL_2, 0x20c0);\r\nregmap_write(rt5659->regmap, RT5659_DEPOP_1, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_1, 0x0011);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_2, 0x0150);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_1, 0xfe3e);\r\nregmap_write(rt5659->regmap, RT5659_MONO_OUT, 0xc80a);\r\nregmap_write(rt5659->regmap, RT5659_MONO_AMP_CALIB_CTRL_1, 0x1e04);\r\nregmap_write(rt5659->regmap, RT5659_PWR_MIXER, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_PWR_VOL, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_PWR_DIG_1, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_PWR_DIG_2, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_1, 0x003e);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_CTRL_1, 0x0060);\r\nregmap_write(rt5659->regmap, RT5659_CLASSD_0, 0x2021);\r\nregmap_write(rt5659->regmap, RT5659_GLB_CLK, 0x0000);\r\nregmap_write(rt5659->regmap, RT5659_MICBIAS_2, 0x0080);\r\nregmap_write(rt5659->regmap, RT5659_HP_VOL, 0x8080);\r\nregmap_write(rt5659->regmap, RT5659_HP_CHARGE_PUMP_1, 0x0c16);\r\n}\r\nstatic int rt5659_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rt5659_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct rt5659_priv *rt5659;\r\nint ret;\r\nunsigned int val;\r\nrt5659 = devm_kzalloc(&i2c->dev, sizeof(struct rt5659_priv),\r\nGFP_KERNEL);\r\nif (rt5659 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, rt5659);\r\nif (pdata)\r\nrt5659->pdata = *pdata;\r\nelse\r\nrt5659_parse_dt(rt5659, &i2c->dev);\r\nrt5659->gpiod_ldo1_en = devm_gpiod_get_optional(&i2c->dev, "ldo1-en",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(rt5659->gpiod_ldo1_en))\r\ndev_warn(&i2c->dev, "Request ldo1-en GPIO failed\n");\r\nrt5659->gpiod_reset = devm_gpiod_get_optional(&i2c->dev, "reset",\r\nGPIOD_OUT_HIGH);\r\nusleep_range(300000, 350000);\r\nrt5659->regmap = devm_regmap_init_i2c(i2c, &rt5659_regmap);\r\nif (IS_ERR(rt5659->regmap)) {\r\nret = PTR_ERR(rt5659->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregmap_read(rt5659->regmap, RT5659_DEVICE_ID, &val);\r\nif (val != DEVICE_ID) {\r\ndev_err(&i2c->dev,\r\n"Device with ID register %x is not rt5659\n", val);\r\nreturn -ENODEV;\r\n}\r\nregmap_write(rt5659->regmap, RT5659_RESET, 0);\r\nrt5659_calibrate(rt5659);\r\nif (rt5659->pdata.in1_diff)\r\nregmap_update_bits(rt5659->regmap, RT5659_IN1_IN2,\r\nRT5659_IN1_DF_MASK, RT5659_IN1_DF_MASK);\r\nif (rt5659->pdata.in3_diff)\r\nregmap_update_bits(rt5659->regmap, RT5659_IN3_IN4,\r\nRT5659_IN3_DF_MASK, RT5659_IN3_DF_MASK);\r\nif (rt5659->pdata.in4_diff)\r\nregmap_update_bits(rt5659->regmap, RT5659_IN3_IN4,\r\nRT5659_IN4_DF_MASK, RT5659_IN4_DF_MASK);\r\nif (rt5659->pdata.dmic1_data_pin != RT5659_DMIC1_NULL ||\r\nrt5659->pdata.dmic2_data_pin != RT5659_DMIC2_NULL) {\r\nregmap_update_bits(rt5659->regmap, RT5659_GPIO_CTRL_1,\r\nRT5659_GP2_PIN_MASK, RT5659_GP2_PIN_DMIC1_SCL);\r\nswitch (rt5659->pdata.dmic1_data_pin) {\r\ncase RT5659_DMIC1_DATA_IN2N:\r\nregmap_update_bits(rt5659->regmap, RT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_1_DP_MASK, RT5659_DMIC_1_DP_IN2N);\r\nbreak;\r\ncase RT5659_DMIC1_DATA_GPIO5:\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_GPIO_CTRL_3,\r\nRT5659_I2S2_PIN_MASK,\r\nRT5659_I2S2_PIN_GPIO);\r\nregmap_update_bits(rt5659->regmap, RT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_1_DP_MASK, RT5659_DMIC_1_DP_GPIO5);\r\nregmap_update_bits(rt5659->regmap, RT5659_GPIO_CTRL_1,\r\nRT5659_GP5_PIN_MASK, RT5659_GP5_PIN_DMIC1_SDA);\r\nbreak;\r\ncase RT5659_DMIC1_DATA_GPIO9:\r\nregmap_update_bits(rt5659->regmap, RT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_1_DP_MASK, RT5659_DMIC_1_DP_GPIO9);\r\nregmap_update_bits(rt5659->regmap, RT5659_GPIO_CTRL_1,\r\nRT5659_GP9_PIN_MASK, RT5659_GP9_PIN_DMIC1_SDA);\r\nbreak;\r\ncase RT5659_DMIC1_DATA_GPIO11:\r\nregmap_update_bits(rt5659->regmap, RT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_1_DP_MASK, RT5659_DMIC_1_DP_GPIO11);\r\nregmap_update_bits(rt5659->regmap, RT5659_GPIO_CTRL_1,\r\nRT5659_GP11_PIN_MASK,\r\nRT5659_GP11_PIN_DMIC1_SDA);\r\nbreak;\r\ndefault:\r\ndev_dbg(&i2c->dev, "no DMIC1\n");\r\nbreak;\r\n}\r\nswitch (rt5659->pdata.dmic2_data_pin) {\r\ncase RT5659_DMIC2_DATA_IN2P:\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_2_DP_MASK,\r\nRT5659_DMIC_2_DP_IN2P);\r\nbreak;\r\ncase RT5659_DMIC2_DATA_GPIO6:\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_2_DP_MASK,\r\nRT5659_DMIC_2_DP_GPIO6);\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_GPIO_CTRL_1,\r\nRT5659_GP6_PIN_MASK,\r\nRT5659_GP6_PIN_DMIC2_SDA);\r\nbreak;\r\ncase RT5659_DMIC2_DATA_GPIO10:\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_2_DP_MASK,\r\nRT5659_DMIC_2_DP_GPIO10);\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_GPIO_CTRL_1,\r\nRT5659_GP10_PIN_MASK,\r\nRT5659_GP10_PIN_DMIC2_SDA);\r\nbreak;\r\ncase RT5659_DMIC2_DATA_GPIO12:\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_2_DP_MASK,\r\nRT5659_DMIC_2_DP_GPIO12);\r\nregmap_update_bits(rt5659->regmap,\r\nRT5659_GPIO_CTRL_1,\r\nRT5659_GP12_PIN_MASK,\r\nRT5659_GP12_PIN_DMIC2_SDA);\r\nbreak;\r\ndefault:\r\ndev_dbg(&i2c->dev, "no DMIC2\n");\r\nbreak;\r\n}\r\n} else {\r\nregmap_update_bits(rt5659->regmap, RT5659_GPIO_CTRL_1,\r\nRT5659_GP2_PIN_MASK | RT5659_GP5_PIN_MASK |\r\nRT5659_GP9_PIN_MASK | RT5659_GP11_PIN_MASK |\r\nRT5659_GP6_PIN_MASK | RT5659_GP10_PIN_MASK |\r\nRT5659_GP12_PIN_MASK,\r\nRT5659_GP2_PIN_GPIO2 | RT5659_GP5_PIN_GPIO5 |\r\nRT5659_GP9_PIN_GPIO9 | RT5659_GP11_PIN_GPIO11 |\r\nRT5659_GP6_PIN_GPIO6 | RT5659_GP10_PIN_GPIO10 |\r\nRT5659_GP12_PIN_GPIO12);\r\nregmap_update_bits(rt5659->regmap, RT5659_DMIC_CTRL_1,\r\nRT5659_DMIC_1_DP_MASK | RT5659_DMIC_2_DP_MASK,\r\nRT5659_DMIC_1_DP_IN2N | RT5659_DMIC_2_DP_IN2P);\r\n}\r\nswitch (rt5659->pdata.jd_src) {\r\ncase RT5659_JD3:\r\nregmap_write(rt5659->regmap, RT5659_EJD_CTRL_1, 0xa880);\r\nregmap_write(rt5659->regmap, RT5659_RC_CLK_CTRL, 0x9000);\r\nregmap_write(rt5659->regmap, RT5659_GPIO_CTRL_1, 0xc800);\r\nregmap_update_bits(rt5659->regmap, RT5659_PWR_ANLG_1,\r\nRT5659_PWR_MB, RT5659_PWR_MB);\r\nregmap_write(rt5659->regmap, RT5659_PWR_ANLG_2, 0x0001);\r\nregmap_write(rt5659->regmap, RT5659_IRQ_CTRL_2, 0x0040);\r\nbreak;\r\ncase RT5659_JD_NULL:\r\nbreak;\r\ndefault:\r\ndev_warn(&i2c->dev, "Currently, support JD3 only\n");\r\nbreak;\r\n}\r\nINIT_DELAYED_WORK(&rt5659->jack_detect_work, rt5659_jack_detect_work);\r\nif (i2c->irq) {\r\nret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\r\nrt5659_irq, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING\r\n| IRQF_ONESHOT, "rt5659", rt5659);\r\nif (ret)\r\ndev_err(&i2c->dev, "Failed to reguest IRQ: %d\n", ret);\r\n}\r\nreturn snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5659,\r\nrt5659_dai, ARRAY_SIZE(rt5659_dai));\r\n}\r\nstatic int rt5659_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}\r\nstatic void rt5659_i2c_shutdown(struct i2c_client *client)\r\n{\r\nstruct rt5659_priv *rt5659 = i2c_get_clientdata(client);\r\nregmap_write(rt5659->regmap, RT5659_RESET, 0);\r\n}
