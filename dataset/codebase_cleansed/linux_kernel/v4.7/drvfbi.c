static void card_start(struct s_smc *smc)\r\n{\r\nint i ;\r\n#ifdef PCI\r\nu_char rev_id ;\r\nu_short word;\r\n#endif\r\nsmt_stop_watchdog(smc) ;\r\n#ifdef PCI\r\noutpw(FM_A(FM_MDREG1),FM_MINIT) ;\r\noutp(ADDR(B0_CTRL), CTRL_HPI_SET) ;\r\nhwt_wait_time(smc,hwt_quick_read(smc),MS2BCLK(10)) ;\r\noutp(ADDR(B0_CTRL),CTRL_RST_SET) ;\r\ni = (int) inp(ADDR(B0_CTRL)) ;\r\nSK_UNUSED(i) ;\r\noutp(ADDR(B0_CTRL), CTRL_RST_CLR) ;\r\noutp(ADDR(B0_TST_CTRL), TST_CFG_WRITE_ON) ;\r\nword = inpw(PCI_C(PCI_STATUS)) ;\r\noutpw(PCI_C(PCI_STATUS), word | PCI_ERRBITS) ;\r\noutp(ADDR(B0_TST_CTRL), TST_CFG_WRITE_OFF) ;\r\noutp(ADDR(B0_CTRL), CTRL_MRST_CLR|CTRL_HPI_CLR) ;\r\nrev_id = inp(PCI_C(PCI_REV_ID)) ;\r\nif ((rev_id & 0xf0) == SK_ML_ID_1 || (rev_id & 0xf0) == SK_ML_ID_2) {\r\nsmc->hw.hw_is_64bit = TRUE ;\r\n} else {\r\nsmc->hw.hw_is_64bit = FALSE ;\r\n}\r\nif (!smc->hw.hw_is_64bit) {\r\noutpd(ADDR(B4_R1_F), RX_WATERMARK) ;\r\noutpd(ADDR(B5_XA_F), TX_WATERMARK) ;\r\noutpd(ADDR(B5_XS_F), TX_WATERMARK) ;\r\n}\r\noutp(ADDR(B0_CTRL),CTRL_RST_CLR) ;\r\noutp(ADDR(B0_LED),LED_GA_OFF|LED_MY_ON|LED_GB_OFF) ;\r\noutpd(ADDR(B2_WDOG_INI),0x6FC23AC0) ;\r\nsmc->hw.is_imask = ISR_MASK ;\r\nsmc->hw.hw_state = STOPPED ;\r\n#endif\r\nGET_PAGE(0) ;\r\n}\r\nvoid card_stop(struct s_smc *smc)\r\n{\r\nsmt_stop_watchdog(smc) ;\r\nsmc->hw.mac_ring_is_up = 0 ;\r\n#ifdef PCI\r\noutpw(FM_A(FM_MDREG1),FM_MINIT) ;\r\noutp(ADDR(B0_CTRL), CTRL_HPI_SET) ;\r\nhwt_wait_time(smc,hwt_quick_read(smc),MS2BCLK(10)) ;\r\noutp(ADDR(B0_CTRL),CTRL_RST_SET) ;\r\noutp(ADDR(B0_CTRL),CTRL_RST_CLR) ;\r\noutp(ADDR(B0_LED),LED_GA_OFF|LED_MY_OFF|LED_GB_OFF) ;\r\nsmc->hw.hw_state = STOPPED ;\r\n#endif\r\n}\r\nvoid mac1_irq(struct s_smc *smc, u_short stu, u_short stl)\r\n{\r\nint restart_tx = 0 ;\r\nagain:\r\nif (stl & (FM_SPCEPDS |\r\nFM_SPCEPDA0 |\r\nFM_SPCEPDA1)) {\r\nSMT_PANIC(smc,SMT_E0134, SMT_E0134_MSG) ;\r\n}\r\nif (stl & (FM_STBURS |\r\nFM_STBURA0 |\r\nFM_STBURA1)) {\r\nSMT_PANIC(smc,SMT_E0133, SMT_E0133_MSG) ;\r\n}\r\nif ( (stu & (FM_SXMTABT |\r\nFM_STXABRS |\r\nFM_STXABRA0)) ||\r\n(stl & (FM_SQLCKS |\r\nFM_SQLCKA0)) ) {\r\nformac_tx_restart(smc) ;\r\nrestart_tx = 1 ;\r\nstu = inpw(FM_A(FM_ST1U)) ;\r\nstl = inpw(FM_A(FM_ST1L)) ;\r\nstu &= ~ (FM_STECFRMA0 | FM_STEFRMA0 | FM_STEFRMS) ;\r\nif (stu || stl)\r\ngoto again ;\r\n}\r\nif (stu & (FM_STEFRMA0 |\r\nFM_STEFRMS)) {\r\nrestart_tx = 1 ;\r\n}\r\nif (restart_tx)\r\nllc_restart_tx(smc) ;\r\n}\r\nvoid plc1_irq(struct s_smc *smc)\r\n{\r\nu_short st = inpw(PLC(PB,PL_INTR_EVENT)) ;\r\nplc_irq(smc,PB,st) ;\r\n}\r\nvoid plc2_irq(struct s_smc *smc)\r\n{\r\nu_short st = inpw(PLC(PA,PL_INTR_EVENT)) ;\r\nplc_irq(smc,PA,st) ;\r\n}\r\nvoid timer_irq(struct s_smc *smc)\r\n{\r\nhwt_restart(smc);\r\nsmc->hw.t_stop = smc->hw.t_start;\r\nsmt_timer_done(smc) ;\r\n}\r\nint pcm_get_s_port(struct s_smc *smc)\r\n{\r\nSK_UNUSED(smc) ;\r\nreturn PS;\r\n}\r\nvoid read_address(struct s_smc *smc, u_char *mac_addr)\r\n{\r\nchar ConnectorType ;\r\nchar PmdType ;\r\nint i ;\r\n#ifdef PCI\r\nfor (i = 0; i < 6; i++) {\r\nsmc->hw.fddi_phys_addr.a[i] =\r\nbitrev8(inp(ADDR(B2_MAC_0+i)));\r\n}\r\n#endif\r\nConnectorType = inp(ADDR(B2_CONN_TYP)) ;\r\nPmdType = inp(ADDR(B2_PMD_TYP)) ;\r\nsmc->y[PA].pmd_type[PMD_SK_CONN] =\r\nsmc->y[PB].pmd_type[PMD_SK_CONN] = ConnectorType ;\r\nsmc->y[PA].pmd_type[PMD_SK_PMD ] =\r\nsmc->y[PB].pmd_type[PMD_SK_PMD ] = PmdType ;\r\nif (mac_addr) {\r\nfor (i = 0; i < 6 ;i++) {\r\nsmc->hw.fddi_canon_addr.a[i] = mac_addr[i] ;\r\nsmc->hw.fddi_home_addr.a[i] = bitrev8(mac_addr[i]);\r\n}\r\nreturn ;\r\n}\r\nsmc->hw.fddi_home_addr = smc->hw.fddi_phys_addr ;\r\nfor (i = 0; i < 6 ;i++) {\r\nsmc->hw.fddi_canon_addr.a[i] =\r\nbitrev8(smc->hw.fddi_phys_addr.a[i]);\r\n}\r\n}\r\nvoid init_board(struct s_smc *smc, u_char *mac_addr)\r\n{\r\ncard_start(smc) ;\r\nread_address(smc,mac_addr) ;\r\nif (!(inp(ADDR(B0_DAS)) & DAS_AVAIL))\r\nsmc->s.sas = SMT_SAS ;\r\nelse\r\nsmc->s.sas = SMT_DAS ;\r\nif (!(inp(ADDR(B0_DAS)) & DAS_BYP_ST))\r\nsmc->mib.fddiSMTBypassPresent = 0 ;\r\nelse\r\nsmc->mib.fddiSMTBypassPresent = 1 ;\r\n}\r\nvoid sm_pm_bypass_req(struct s_smc *smc, int mode)\r\n{\r\nDB_ECMN(1,"ECM : sm_pm_bypass_req(%s)\n",(mode == BP_INSERT) ?\r\n"BP_INSERT" : "BP_DEINSERT",0) ;\r\nif (smc->s.sas != SMT_DAS)\r\nreturn ;\r\n#ifdef PCI\r\nswitch(mode) {\r\ncase BP_INSERT :\r\noutp(ADDR(B0_DAS),DAS_BYP_INS) ;\r\nbreak ;\r\ncase BP_DEINSERT :\r\noutp(ADDR(B0_DAS),DAS_BYP_RMV) ;\r\nbreak ;\r\n}\r\n#endif\r\n}\r\nint sm_pm_bypass_present(struct s_smc *smc)\r\n{\r\nreturn (inp(ADDR(B0_DAS)) & DAS_BYP_ST) ? TRUE : FALSE;\r\n}\r\nvoid plc_clear_irq(struct s_smc *smc, int p)\r\n{\r\nSK_UNUSED(p) ;\r\nSK_UNUSED(smc) ;\r\n}\r\nstatic void led_indication(struct s_smc *smc, int led_event)\r\n{\r\nu_short led_state ;\r\nstruct s_phy *phy ;\r\nstruct fddi_mib_p *mib_a ;\r\nstruct fddi_mib_p *mib_b ;\r\nphy = &smc->y[PA] ;\r\nmib_a = phy->mib ;\r\nphy = &smc->y[PB] ;\r\nmib_b = phy->mib ;\r\n#ifdef PCI\r\nled_state = 0 ;\r\nif (led_event == LED_Y_ON) {\r\nled_state |= LED_MY_ON ;\r\n}\r\nelse if (led_event == LED_Y_OFF) {\r\nled_state |= LED_MY_OFF ;\r\n}\r\nelse {\r\nif (mib_a->fddiPORTPCMState == PC8_ACTIVE) {\r\nled_state |= LED_GA_ON ;\r\n}\r\nelse {\r\nled_state |= LED_GA_OFF ;\r\n}\r\nif (mib_b->fddiPORTPCMState == PC8_ACTIVE) {\r\nled_state |= LED_GB_ON ;\r\n}\r\nelse {\r\nled_state |= LED_GB_OFF ;\r\n}\r\n}\r\noutp(ADDR(B0_LED), led_state) ;\r\n#endif\r\n}\r\nvoid pcm_state_change(struct s_smc *smc, int plc, int p_state)\r\n{\r\nDRV_PCM_STATE_CHANGE(smc,plc,p_state) ;\r\nled_indication(smc,0) ;\r\n}\r\nvoid rmt_indication(struct s_smc *smc, int i)\r\n{\r\nDRV_RMT_INDICATION(smc,i) ;\r\nled_indication(smc, i ? LED_Y_OFF : LED_Y_ON) ;\r\n}\r\nvoid llc_recover_tx(struct s_smc *smc)\r\n{\r\n#ifdef LOAD_GEN\r\nextern int load_gen_flag ;\r\nload_gen_flag = 0 ;\r\n#endif\r\n#ifndef SYNC\r\nsmc->hw.n_a_send= 0 ;\r\n#else\r\nSK_UNUSED(smc) ;\r\n#endif\r\n}\r\nstatic int is_equal_num(char comp1[], char comp2[], int num)\r\n{\r\nint i ;\r\nfor (i = 0 ; i < num ; i++) {\r\nif (comp1[i] != comp2[i])\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint set_oi_id_def(struct s_smc *smc)\r\n{\r\nint sel_id ;\r\nint i ;\r\nint act_entries ;\r\ni = 0 ;\r\nsel_id = -1 ;\r\nact_entries = FALSE ;\r\nsmc->hw.oem_id = 0 ;\r\nsmc->hw.oem_min_status = OI_STAT_ACTIVE ;\r\nwhile (oem_ids[i].oi_status) {\r\nswitch (oem_ids[i].oi_status) {\r\ncase OI_STAT_ACTIVE:\r\nact_entries = TRUE ;\r\nif (sel_id == -1)\r\nsel_id = i ;\r\ncase OI_STAT_VALID:\r\ncase OI_STAT_PRESENT:\r\ni++ ;\r\nbreak ;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nif (i == 0)\r\nreturn 2;\r\nif (!act_entries)\r\nreturn 3;\r\nsmc->hw.oem_id = (struct s_oem_ids *) &oem_ids[sel_id] ;\r\nreturn 0;\r\n}\r\nvoid driver_get_bia(struct s_smc *smc, struct fddi_addr *bia_addr)\r\n{\r\nint i ;\r\nfor (i = 0 ; i < 6 ; i++)\r\nbia_addr->a[i] = bitrev8(smc->hw.fddi_phys_addr.a[i]);\r\n}\r\nvoid smt_start_watchdog(struct s_smc *smc)\r\n{\r\nSK_UNUSED(smc) ;\r\n#ifndef DEBUG\r\n#ifdef PCI\r\nif (smc->hw.wdog_used) {\r\noutpw(ADDR(B2_WDOG_CRTL),TIM_START) ;\r\n}\r\n#endif\r\n#endif\r\n}\r\nstatic void smt_stop_watchdog(struct s_smc *smc)\r\n{\r\nSK_UNUSED(smc) ;\r\n#ifndef DEBUG\r\n#ifdef PCI\r\nif (smc->hw.wdog_used) {\r\noutpw(ADDR(B2_WDOG_CRTL),TIM_STOP) ;\r\n}\r\n#endif\r\n#endif\r\n}\r\nvoid mac_do_pci_fix(struct s_smc *smc)\r\n{\r\nSK_UNUSED(smc) ;\r\n}
