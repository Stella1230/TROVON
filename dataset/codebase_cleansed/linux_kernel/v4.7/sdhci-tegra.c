static u16 tegra_sdhci_readw(struct sdhci_host *host, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\r\nconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\r\nif (unlikely((soc_data->nvquirks & NVQUIRK_FORCE_SDHCI_SPEC_200) &&\r\n(reg == SDHCI_HOST_VERSION))) {\r\nreturn SDHCI_SPEC_200;\r\n}\r\nreturn readw(host->ioaddr + reg);\r\n}\r\nstatic void tegra_sdhci_writew(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nswitch (reg) {\r\ncase SDHCI_TRANSFER_MODE:\r\npltfm_host->xfer_mode_shadow = val;\r\nreturn;\r\ncase SDHCI_COMMAND:\r\nwritel((val << 16) | pltfm_host->xfer_mode_shadow,\r\nhost->ioaddr + SDHCI_TRANSFER_MODE);\r\nreturn;\r\n}\r\nwritew(val, host->ioaddr + reg);\r\n}\r\nstatic void tegra_sdhci_writel(struct sdhci_host *host, u32 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\r\nconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\r\nif (unlikely(reg == SDHCI_SIGNAL_ENABLE))\r\nval &= ~(SDHCI_INT_TIMEOUT|SDHCI_INT_CRC);\r\nwritel(val, host->ioaddr + reg);\r\nif (unlikely((soc_data->nvquirks & NVQUIRK_ENABLE_BLOCK_GAP_DET) &&\r\n(reg == SDHCI_INT_ENABLE))) {\r\nu8 gap_ctrl = readb(host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);\r\nif (val & SDHCI_INT_CARD_INT)\r\ngap_ctrl |= 0x8;\r\nelse\r\ngap_ctrl &= ~0x8;\r\nwriteb(gap_ctrl, host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);\r\n}\r\n}\r\nstatic unsigned int tegra_sdhci_get_ro(struct sdhci_host *host)\r\n{\r\nreturn mmc_gpio_get_ro(host->mmc);\r\n}\r\nstatic void tegra_sdhci_reset(struct sdhci_host *host, u8 mask)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\r\nconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\r\nu32 misc_ctrl, clk_ctrl;\r\nsdhci_reset(host, mask);\r\nif (!(mask & SDHCI_RESET_ALL))\r\nreturn;\r\nmisc_ctrl = sdhci_readl(host, SDHCI_TEGRA_VENDOR_MISC_CTRL);\r\nif (soc_data->nvquirks & NVQUIRK_ENABLE_SDHCI_SPEC_300)\r\nmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300;\r\nif (soc_data->nvquirks & NVQUIRK_ENABLE_SDR50)\r\nmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR50;\r\nelse\r\nmisc_ctrl &= ~SDHCI_MISC_CTRL_ENABLE_SDR50;\r\nif (soc_data->nvquirks & NVQUIRK_ENABLE_DDR50)\r\nmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_DDR50;\r\nelse\r\nmisc_ctrl &= ~SDHCI_MISC_CTRL_ENABLE_DDR50;\r\nif (soc_data->nvquirks & NVQUIRK_ENABLE_SDR104)\r\nmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR104;\r\nelse\r\nmisc_ctrl &= ~SDHCI_MISC_CTRL_ENABLE_SDR104;\r\nsdhci_writel(host, misc_ctrl, SDHCI_TEGRA_VENDOR_MISC_CTRL);\r\nclk_ctrl = sdhci_readl(host, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\r\nclk_ctrl &= ~SDHCI_CLOCK_CTRL_SPI_MODE_CLKEN_OVERRIDE;\r\nif (soc_data->nvquirks & SDHCI_MISC_CTRL_ENABLE_SDR50)\r\nclk_ctrl |= SDHCI_CLOCK_CTRL_SDR50_TUNING_OVERRIDE;\r\nsdhci_writel(host, clk_ctrl, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\r\nif (soc_data->nvquirks & NVQUIRK_HAS_PADCALIB)\r\ntegra_host->pad_calib_required = true;\r\ntegra_host->ddr_signaling = false;\r\n}\r\nstatic void tegra_sdhci_set_bus_width(struct sdhci_host *host, int bus_width)\r\n{\r\nu32 ctrl;\r\nctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\r\nif ((host->mmc->caps & MMC_CAP_8_BIT_DATA) &&\r\n(bus_width == MMC_BUS_WIDTH_8)) {\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\nctrl |= SDHCI_CTRL_8BITBUS;\r\n} else {\r\nctrl &= ~SDHCI_CTRL_8BITBUS;\r\nif (bus_width == MMC_BUS_WIDTH_4)\r\nctrl |= SDHCI_CTRL_4BITBUS;\r\nelse\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\n}\r\nsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\r\n}\r\nstatic void tegra_sdhci_pad_autocalib(struct sdhci_host *host)\r\n{\r\nu32 val;\r\nmdelay(1);\r\nval = sdhci_readl(host, SDHCI_TEGRA_AUTO_CAL_CONFIG);\r\nval |= SDHCI_AUTO_CAL_ENABLE | SDHCI_AUTO_CAL_START;\r\nsdhci_writel(host,val, SDHCI_TEGRA_AUTO_CAL_CONFIG);\r\n}\r\nstatic void tegra_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\r\nunsigned long host_clk;\r\nif (!clock)\r\nreturn sdhci_set_clock(host, clock);\r\nhost_clk = tegra_host->ddr_signaling ? clock * 2 : clock;\r\nclk_set_rate(pltfm_host->clk, host_clk);\r\nhost->max_clk = clk_get_rate(pltfm_host->clk);\r\nsdhci_set_clock(host, clock);\r\nif (tegra_host->pad_calib_required) {\r\ntegra_sdhci_pad_autocalib(host);\r\ntegra_host->pad_calib_required = false;\r\n}\r\n}\r\nstatic void tegra_sdhci_set_uhs_signaling(struct sdhci_host *host,\r\nunsigned timing)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\r\nif (timing == MMC_TIMING_UHS_DDR50)\r\ntegra_host->ddr_signaling = true;\r\nreturn sdhci_set_uhs_signaling(host, timing);\r\n}\r\nstatic unsigned int tegra_sdhci_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn clk_round_rate(pltfm_host->clk, UINT_MAX) / 2;\r\n}\r\nstatic void tegra_sdhci_set_tap(struct sdhci_host *host, unsigned int tap)\r\n{\r\nu32 reg;\r\nreg = sdhci_readl(host, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\r\nreg &= ~SDHCI_CLOCK_CTRL_TAP_MASK;\r\nreg |= tap << SDHCI_CLOCK_CTRL_TAP_SHIFT;\r\nsdhci_writel(host, reg, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\r\n}\r\nstatic int tegra_sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)\r\n{\r\nunsigned int min, max;\r\nmin = 10;\r\nwhile (min < 255) {\r\ntegra_sdhci_set_tap(host, min);\r\nif (!mmc_send_tuning(host->mmc, opcode, NULL))\r\nbreak;\r\nmin++;\r\n}\r\nmax = min + 1;\r\nwhile (max < 255) {\r\ntegra_sdhci_set_tap(host, max);\r\nif (mmc_send_tuning(host->mmc, opcode, NULL)) {\r\nmax--;\r\nbreak;\r\n}\r\nmax++;\r\n}\r\ntegra_sdhci_set_tap(host, min + ((max - min) * 3 / 4));\r\nreturn mmc_send_tuning(host->mmc, opcode, NULL);\r\n}\r\nstatic void tegra_sdhci_voltage_switch(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\r\nconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\r\nif (soc_data->nvquirks & NVQUIRK_HAS_PADCALIB)\r\ntegra_host->pad_calib_required = true;\r\n}\r\nstatic int sdhci_tegra_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct sdhci_tegra_soc_data *soc_data;\r\nstruct sdhci_host *host;\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_tegra *tegra_host;\r\nstruct clk *clk;\r\nint rc;\r\nmatch = of_match_device(sdhci_tegra_dt_match, &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nsoc_data = match->data;\r\nhost = sdhci_pltfm_init(pdev, soc_data->pdata, sizeof(*tegra_host));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\ntegra_host = sdhci_pltfm_priv(pltfm_host);\r\ntegra_host->ddr_signaling = false;\r\ntegra_host->pad_calib_required = false;\r\ntegra_host->soc_data = soc_data;\r\nrc = mmc_of_parse(host->mmc);\r\nif (rc)\r\ngoto err_parse_dt;\r\nif (tegra_host->soc_data->nvquirks & NVQUIRK_ENABLE_DDR50)\r\nhost->mmc->caps |= MMC_CAP_1_8V_DDR;\r\ntegra_host->power_gpio = devm_gpiod_get_optional(&pdev->dev, "power",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(tegra_host->power_gpio)) {\r\nrc = PTR_ERR(tegra_host->power_gpio);\r\ngoto err_power_req;\r\n}\r\nclk = devm_clk_get(mmc_dev(host->mmc), NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(mmc_dev(host->mmc), "clk err\n");\r\nrc = PTR_ERR(clk);\r\ngoto err_clk_get;\r\n}\r\nclk_prepare_enable(clk);\r\npltfm_host->clk = clk;\r\nrc = sdhci_add_host(host);\r\nif (rc)\r\ngoto err_add_host;\r\nreturn 0;\r\nerr_add_host:\r\nclk_disable_unprepare(pltfm_host->clk);\r\nerr_clk_get:\r\nerr_power_req:\r\nerr_parse_dt:\r\nsdhci_pltfm_free(pdev);\r\nreturn rc;\r\n}
