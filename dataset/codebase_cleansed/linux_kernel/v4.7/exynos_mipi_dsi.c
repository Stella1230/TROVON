static struct mipi_dsim_platform_data *to_dsim_plat(struct platform_device\r\n*pdev)\r\n{\r\nreturn pdev->dev.platform_data;\r\n}\r\nstatic int exynos_mipi_regulator_enable(struct mipi_dsim_device *dsim)\r\n{\r\nint ret;\r\nmutex_lock(&dsim->lock);\r\nret = regulator_bulk_enable(ARRAY_SIZE(supplies), supplies);\r\nmutex_unlock(&dsim->lock);\r\nreturn ret;\r\n}\r\nstatic int exynos_mipi_regulator_disable(struct mipi_dsim_device *dsim)\r\n{\r\nint ret;\r\nmutex_lock(&dsim->lock);\r\nret = regulator_bulk_disable(ARRAY_SIZE(supplies), supplies);\r\nmutex_unlock(&dsim->lock);\r\nreturn ret;\r\n}\r\nstatic void exynos_mipi_update_cfg(struct mipi_dsim_device *dsim)\r\n{\r\nexynos_mipi_dsi_stand_by(dsim, 0);\r\nexynos_mipi_dsi_init_dsim(dsim);\r\nexynos_mipi_dsi_init_link(dsim);\r\nexynos_mipi_dsi_set_hs_enable(dsim);\r\nexynos_mipi_dsi_set_display_mode(dsim, dsim->dsim_config);\r\nexynos_mipi_dsi_init_interrupt(dsim);\r\nexynos_mipi_dsi_stand_by(dsim, 1);\r\n}\r\nstatic int exynos_mipi_dsi_early_blank_mode(struct mipi_dsim_device *dsim,\r\nint power)\r\n{\r\nstruct mipi_dsim_lcd_driver *client_drv = dsim->dsim_lcd_drv;\r\nstruct mipi_dsim_lcd_device *client_dev = dsim->dsim_lcd_dev;\r\nswitch (power) {\r\ncase FB_BLANK_POWERDOWN:\r\nif (dsim->suspended)\r\nreturn 0;\r\nif (client_drv && client_drv->suspend)\r\nclient_drv->suspend(client_dev);\r\nclk_disable(dsim->clock);\r\nexynos_mipi_regulator_disable(dsim);\r\ndsim->suspended = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_mipi_dsi_blank_mode(struct mipi_dsim_device *dsim, int power)\r\n{\r\nstruct mipi_dsim_lcd_driver *client_drv = dsim->dsim_lcd_drv;\r\nstruct mipi_dsim_lcd_device *client_dev = dsim->dsim_lcd_dev;\r\nswitch (power) {\r\ncase FB_BLANK_UNBLANK:\r\nif (!dsim->suspended)\r\nreturn 0;\r\nif (client_drv && client_drv->power_on)\r\nclient_drv->power_on(client_dev, 1);\r\nexynos_mipi_regulator_enable(dsim);\r\nphy_power_on(dsim->phy);\r\nclk_enable(dsim->clock);\r\nexynos_mipi_update_cfg(dsim);\r\nif (client_drv && client_drv->set_sequence)\r\nclient_drv->set_sequence(client_dev);\r\ndsim->suspended = false;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint exynos_mipi_dsi_register_lcd_device(struct mipi_dsim_lcd_device *lcd_dev)\r\n{\r\nstruct mipi_dsim_ddi *dsim_ddi;\r\nif (!lcd_dev->name) {\r\npr_err("dsim_lcd_device name is NULL.\n");\r\nreturn -EFAULT;\r\n}\r\ndsim_ddi = kzalloc(sizeof(struct mipi_dsim_ddi), GFP_KERNEL);\r\nif (!dsim_ddi) {\r\npr_err("failed to allocate dsim_ddi object.\n");\r\nreturn -ENOMEM;\r\n}\r\ndsim_ddi->dsim_lcd_dev = lcd_dev;\r\nmutex_lock(&mipi_dsim_lock);\r\nlist_add_tail(&dsim_ddi->list, &dsim_ddi_list);\r\nmutex_unlock(&mipi_dsim_lock);\r\nreturn 0;\r\n}\r\nstatic struct mipi_dsim_ddi *exynos_mipi_dsi_find_lcd_device(\r\nstruct mipi_dsim_lcd_driver *lcd_drv)\r\n{\r\nstruct mipi_dsim_ddi *dsim_ddi, *next;\r\nstruct mipi_dsim_lcd_device *lcd_dev;\r\nmutex_lock(&mipi_dsim_lock);\r\nlist_for_each_entry_safe(dsim_ddi, next, &dsim_ddi_list, list) {\r\nif (!dsim_ddi)\r\ngoto out;\r\nlcd_dev = dsim_ddi->dsim_lcd_dev;\r\nif (!lcd_dev)\r\ncontinue;\r\nif ((strcmp(lcd_drv->name, lcd_dev->name)) == 0) {\r\ndsim_ddi->bus_id = lcd_dev->bus_id;\r\nmutex_unlock(&mipi_dsim_lock);\r\nreturn dsim_ddi;\r\n}\r\nlist_del(&dsim_ddi->list);\r\nkfree(dsim_ddi);\r\n}\r\nout:\r\nmutex_unlock(&mipi_dsim_lock);\r\nreturn NULL;\r\n}\r\nint exynos_mipi_dsi_register_lcd_driver(struct mipi_dsim_lcd_driver *lcd_drv)\r\n{\r\nstruct mipi_dsim_ddi *dsim_ddi;\r\nif (!lcd_drv->name) {\r\npr_err("dsim_lcd_driver name is NULL.\n");\r\nreturn -EFAULT;\r\n}\r\ndsim_ddi = exynos_mipi_dsi_find_lcd_device(lcd_drv);\r\nif (!dsim_ddi) {\r\npr_err("mipi_dsim_ddi object not found.\n");\r\nreturn -EFAULT;\r\n}\r\ndsim_ddi->dsim_lcd_drv = lcd_drv;\r\npr_info("registered panel driver(%s) to mipi-dsi driver.\n",\r\nlcd_drv->name);\r\nreturn 0;\r\n}\r\nstatic struct mipi_dsim_ddi *exynos_mipi_dsi_bind_lcd_ddi(\r\nstruct mipi_dsim_device *dsim,\r\nconst char *name)\r\n{\r\nstruct mipi_dsim_ddi *dsim_ddi, *next;\r\nstruct mipi_dsim_lcd_driver *lcd_drv;\r\nstruct mipi_dsim_lcd_device *lcd_dev;\r\nint ret;\r\nmutex_lock(&dsim->lock);\r\nlist_for_each_entry_safe(dsim_ddi, next, &dsim_ddi_list, list) {\r\nlcd_drv = dsim_ddi->dsim_lcd_drv;\r\nlcd_dev = dsim_ddi->dsim_lcd_dev;\r\nif (!lcd_drv || !lcd_dev ||\r\n(dsim->id != dsim_ddi->bus_id))\r\ncontinue;\r\ndev_dbg(dsim->dev, "lcd_drv->id = %d, lcd_dev->id = %d\n",\r\nlcd_drv->id, lcd_dev->id);\r\ndev_dbg(dsim->dev, "lcd_dev->bus_id = %d, dsim->id = %d\n",\r\nlcd_dev->bus_id, dsim->id);\r\nif ((strcmp(lcd_drv->name, name) == 0)) {\r\nlcd_dev->master = dsim;\r\nlcd_dev->dev.parent = dsim->dev;\r\ndev_set_name(&lcd_dev->dev, "%s", lcd_drv->name);\r\nret = device_register(&lcd_dev->dev);\r\nif (ret < 0) {\r\ndev_err(dsim->dev,\r\n"can't register %s, status %d\n",\r\ndev_name(&lcd_dev->dev), ret);\r\nmutex_unlock(&dsim->lock);\r\nreturn NULL;\r\n}\r\ndsim->dsim_lcd_dev = lcd_dev;\r\ndsim->dsim_lcd_drv = lcd_drv;\r\nmutex_unlock(&dsim->lock);\r\nreturn dsim_ddi;\r\n}\r\n}\r\nmutex_unlock(&dsim->lock);\r\nreturn NULL;\r\n}\r\nstatic int exynos_mipi_dsi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct mipi_dsim_device *dsim;\r\nstruct mipi_dsim_config *dsim_config;\r\nstruct mipi_dsim_platform_data *dsim_pd;\r\nstruct mipi_dsim_ddi *dsim_ddi;\r\nint ret = -EINVAL;\r\ndsim = devm_kzalloc(&pdev->dev, sizeof(struct mipi_dsim_device),\r\nGFP_KERNEL);\r\nif (!dsim) {\r\ndev_err(&pdev->dev, "failed to allocate dsim object.\n");\r\nreturn -ENOMEM;\r\n}\r\ndsim->pd = to_dsim_plat(pdev);\r\ndsim->dev = &pdev->dev;\r\ndsim->id = pdev->id;\r\ndsim_pd = (struct mipi_dsim_platform_data *)dsim->pd;\r\nif (dsim_pd == NULL) {\r\ndev_err(&pdev->dev, "failed to get platform data for dsim.\n");\r\nreturn -EINVAL;\r\n}\r\ndsim_config = dsim_pd->dsim_config;\r\nif (dsim_config == NULL) {\r\ndev_err(&pdev->dev, "failed to get dsim config data.\n");\r\nreturn -EINVAL;\r\n}\r\ndsim->dsim_config = dsim_config;\r\ndsim->master_ops = &master_ops;\r\nmutex_init(&dsim->lock);\r\nret = devm_regulator_bulk_get(&pdev->dev, ARRAY_SIZE(supplies),\r\nsupplies);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to get regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\ndsim->phy = devm_phy_get(&pdev->dev, "dsim");\r\nif (IS_ERR(dsim->phy))\r\nreturn PTR_ERR(dsim->phy);\r\ndsim->clock = devm_clk_get(&pdev->dev, "dsim0");\r\nif (IS_ERR(dsim->clock)) {\r\ndev_err(&pdev->dev, "failed to get dsim clock source\n");\r\nreturn -ENODEV;\r\n}\r\nclk_enable(dsim->clock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndsim->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dsim->reg_base)) {\r\nret = PTR_ERR(dsim->reg_base);\r\ngoto error;\r\n}\r\nmutex_init(&dsim->lock);\r\ndsim_ddi = exynos_mipi_dsi_bind_lcd_ddi(dsim, dsim_pd->lcd_panel_name);\r\nif (!dsim_ddi) {\r\ndev_err(&pdev->dev, "mipi_dsim_ddi object not found.\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request dsim irq resource\n");\r\ngoto error;\r\n}\r\ndsim->irq = ret;\r\ninit_completion(&dsim_wr_comp);\r\ninit_completion(&dsim_rd_comp);\r\nplatform_set_drvdata(pdev, dsim);\r\nret = devm_request_irq(&pdev->dev, dsim->irq,\r\nexynos_mipi_dsi_interrupt_handler,\r\nIRQF_SHARED, dev_name(&pdev->dev), dsim);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "failed to request dsim irq\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nexynos_mipi_dsi_init_interrupt(dsim);\r\nif (dsim_ddi->dsim_lcd_drv && dsim_ddi->dsim_lcd_drv->probe)\r\ndsim_ddi->dsim_lcd_drv->probe(dsim_ddi->dsim_lcd_dev);\r\nif (dsim_pd->enabled) {\r\nexynos_mipi_regulator_enable(dsim);\r\ngoto done;\r\n}\r\nif (dsim_ddi->dsim_lcd_drv && dsim_ddi->dsim_lcd_drv->power_on)\r\ndsim_ddi->dsim_lcd_drv->power_on(dsim_ddi->dsim_lcd_dev, 1);\r\nexynos_mipi_regulator_enable(dsim);\r\nphy_power_on(dsim->phy);\r\nexynos_mipi_update_cfg(dsim);\r\nif (dsim_ddi->dsim_lcd_drv && dsim_ddi->dsim_lcd_drv->set_sequence)\r\ndsim_ddi->dsim_lcd_drv->set_sequence(dsim_ddi->dsim_lcd_dev);\r\ndsim->suspended = false;\r\ndone:\r\nplatform_set_drvdata(pdev, dsim);\r\ndev_dbg(&pdev->dev, "%s() completed successfully (%s mode)\n", __func__,\r\ndsim_config->e_interface == DSIM_COMMAND ? "CPU" : "RGB");\r\nreturn 0;\r\nerror:\r\nclk_disable(dsim->clock);\r\nreturn ret;\r\n}\r\nstatic int exynos_mipi_dsi_remove(struct platform_device *pdev)\r\n{\r\nstruct mipi_dsim_device *dsim = platform_get_drvdata(pdev);\r\nstruct mipi_dsim_ddi *dsim_ddi, *next;\r\nstruct mipi_dsim_lcd_driver *dsim_lcd_drv;\r\nclk_disable(dsim->clock);\r\nlist_for_each_entry_safe(dsim_ddi, next, &dsim_ddi_list, list) {\r\nif (dsim_ddi) {\r\nif (dsim->id != dsim_ddi->bus_id)\r\ncontinue;\r\ndsim_lcd_drv = dsim_ddi->dsim_lcd_drv;\r\nif (dsim_lcd_drv->remove)\r\ndsim_lcd_drv->remove(dsim_ddi->dsim_lcd_dev);\r\nkfree(dsim_ddi);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_mipi_dsi_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mipi_dsim_device *dsim = platform_get_drvdata(pdev);\r\nstruct mipi_dsim_lcd_driver *client_drv = dsim->dsim_lcd_drv;\r\nstruct mipi_dsim_lcd_device *client_dev = dsim->dsim_lcd_dev;\r\ndisable_irq(dsim->irq);\r\nif (dsim->suspended)\r\nreturn 0;\r\nif (client_drv && client_drv->suspend)\r\nclient_drv->suspend(client_dev);\r\nphy_power_off(dsim->phy);\r\nclk_disable(dsim->clock);\r\nexynos_mipi_regulator_disable(dsim);\r\ndsim->suspended = true;\r\nreturn 0;\r\n}\r\nstatic int exynos_mipi_dsi_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mipi_dsim_device *dsim = platform_get_drvdata(pdev);\r\nstruct mipi_dsim_lcd_driver *client_drv = dsim->dsim_lcd_drv;\r\nstruct mipi_dsim_lcd_device *client_dev = dsim->dsim_lcd_dev;\r\nenable_irq(dsim->irq);\r\nif (!dsim->suspended)\r\nreturn 0;\r\nif (client_drv && client_drv->power_on)\r\nclient_drv->power_on(client_dev, 1);\r\nexynos_mipi_regulator_enable(dsim);\r\nphy_power_on(dsim->phy);\r\nclk_enable(dsim->clock);\r\nexynos_mipi_update_cfg(dsim);\r\nif (client_drv && client_drv->set_sequence)\r\nclient_drv->set_sequence(client_dev);\r\ndsim->suspended = false;\r\nreturn 0;\r\n}
