int msi_bitmap_alloc_hwirqs(struct msi_bitmap *bmp, int num)\r\n{\r\nunsigned long flags;\r\nint offset, order = get_count_order(num);\r\nspin_lock_irqsave(&bmp->lock, flags);\r\noffset = bitmap_find_next_zero_area(bmp->bitmap, bmp->irq_count, 0,\r\nnum, (1 << order) - 1);\r\nif (offset > bmp->irq_count)\r\ngoto err;\r\nbitmap_set(bmp->bitmap, offset, num);\r\nspin_unlock_irqrestore(&bmp->lock, flags);\r\npr_debug("msi_bitmap: allocated 0x%x at offset 0x%x\n", num, offset);\r\nreturn offset;\r\nerr:\r\nspin_unlock_irqrestore(&bmp->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nvoid msi_bitmap_free_hwirqs(struct msi_bitmap *bmp, unsigned int offset,\r\nunsigned int num)\r\n{\r\nunsigned long flags;\r\npr_debug("msi_bitmap: freeing 0x%x at offset 0x%x\n",\r\nnum, offset);\r\nspin_lock_irqsave(&bmp->lock, flags);\r\nbitmap_clear(bmp->bitmap, offset, num);\r\nspin_unlock_irqrestore(&bmp->lock, flags);\r\n}\r\nvoid msi_bitmap_reserve_hwirq(struct msi_bitmap *bmp, unsigned int hwirq)\r\n{\r\nunsigned long flags;\r\npr_debug("msi_bitmap: reserving hwirq 0x%x\n", hwirq);\r\nspin_lock_irqsave(&bmp->lock, flags);\r\nbitmap_allocate_region(bmp->bitmap, hwirq, 0);\r\nspin_unlock_irqrestore(&bmp->lock, flags);\r\n}\r\nint msi_bitmap_reserve_dt_hwirqs(struct msi_bitmap *bmp)\r\n{\r\nint i, j, len;\r\nconst u32 *p;\r\nif (!bmp->of_node)\r\nreturn 1;\r\np = of_get_property(bmp->of_node, "msi-available-ranges", &len);\r\nif (!p) {\r\npr_debug("msi_bitmap: no msi-available-ranges property " \\r\n"found on %s\n", bmp->of_node->full_name);\r\nreturn 1;\r\n}\r\nif (len % (2 * sizeof(u32)) != 0) {\r\nprintk(KERN_WARNING "msi_bitmap: Malformed msi-available-ranges"\r\n" property on %s\n", bmp->of_node->full_name);\r\nreturn -EINVAL;\r\n}\r\nbitmap_allocate_region(bmp->bitmap, 0, get_count_order(bmp->irq_count));\r\nspin_lock(&bmp->lock);\r\nlen /= 2 * sizeof(u32);\r\nfor (i = 0; i < len; i++, p += 2) {\r\nfor (j = 0; j < *(p + 1); j++)\r\nbitmap_release_region(bmp->bitmap, *p + j, 0);\r\n}\r\nspin_unlock(&bmp->lock);\r\nreturn 0;\r\n}\r\nint __init_refok msi_bitmap_alloc(struct msi_bitmap *bmp, unsigned int irq_count,\r\nstruct device_node *of_node)\r\n{\r\nint size;\r\nif (!irq_count)\r\nreturn -EINVAL;\r\nsize = BITS_TO_LONGS(irq_count) * sizeof(long);\r\npr_debug("msi_bitmap: allocator bitmap size is 0x%x bytes\n", size);\r\nbmp->bitmap_from_slab = slab_is_available();\r\nif (bmp->bitmap_from_slab)\r\nbmp->bitmap = kzalloc(size, GFP_KERNEL);\r\nelse {\r\nbmp->bitmap = memblock_virt_alloc(size, 0);\r\nkmemleak_not_leak(bmp->bitmap);\r\n}\r\nif (!bmp->bitmap) {\r\npr_debug("msi_bitmap: ENOMEM allocating allocator bitmap!\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&bmp->lock);\r\nbmp->of_node = of_node_get(of_node);\r\nbmp->irq_count = irq_count;\r\nreturn 0;\r\n}\r\nvoid msi_bitmap_free(struct msi_bitmap *bmp)\r\n{\r\nif (bmp->bitmap_from_slab)\r\nkfree(bmp->bitmap);\r\nof_node_put(bmp->of_node);\r\nbmp->bitmap = NULL;\r\n}\r\nstatic void __init test_basics(void)\r\n{\r\nstruct msi_bitmap bmp;\r\nint rc, i, size = 512;\r\nWARN_ON(msi_bitmap_alloc(&bmp, 0, NULL) == 0);\r\nWARN_ON(msi_bitmap_alloc(&bmp, size, NULL));\r\nWARN_ON(bitmap_find_free_region(bmp.bitmap, size, get_count_order(size)));\r\nbitmap_release_region(bmp.bitmap, 0, get_count_order(size));\r\nWARN_ON(msi_bitmap_reserve_dt_hwirqs(&bmp) <= 0);\r\nWARN_ON(bitmap_find_free_region(bmp.bitmap, size, get_count_order(size)));\r\nbitmap_release_region(bmp.bitmap, 0, get_count_order(size));\r\nfor (i = 0; i < size; i++)\r\nWARN_ON(msi_bitmap_alloc_hwirqs(&bmp, 1) < 0);\r\nWARN_ON(msi_bitmap_alloc_hwirqs(&bmp, 1) >= 0);\r\nWARN_ON(bitmap_find_free_region(bmp.bitmap, size, 0) >= 0);\r\nmsi_bitmap_free_hwirqs(&bmp, size / 2, 1);\r\nWARN_ON(msi_bitmap_alloc_hwirqs(&bmp, 1) != size / 2);\r\nmsi_bitmap_free_hwirqs(&bmp, 3, size - 3);\r\nrc = msi_bitmap_alloc_hwirqs(&bmp, 2);\r\nWARN_ON(rc < 0 && rc % 2 != 0);\r\nrc = msi_bitmap_alloc_hwirqs(&bmp, 4);\r\nWARN_ON(rc < 0 && rc % 4 != 0);\r\nrc = msi_bitmap_alloc_hwirqs(&bmp, 8);\r\nWARN_ON(rc < 0 && rc % 8 != 0);\r\nrc = msi_bitmap_alloc_hwirqs(&bmp, 9);\r\nWARN_ON(rc < 0 && rc % 16 != 0);\r\nrc = msi_bitmap_alloc_hwirqs(&bmp, 3);\r\nWARN_ON(rc < 0 && rc % 4 != 0);\r\nrc = msi_bitmap_alloc_hwirqs(&bmp, 7);\r\nWARN_ON(rc < 0 && rc % 8 != 0);\r\nrc = msi_bitmap_alloc_hwirqs(&bmp, 121);\r\nWARN_ON(rc < 0 && rc % 128 != 0);\r\nmsi_bitmap_free(&bmp);\r\nWARN_ON(bmp.bitmap != NULL);\r\n}\r\nstatic void __init test_of_node(void)\r\n{\r\nu32 prop_data[] = { 10, 10, 25, 3, 40, 1, 100, 100, 200, 20 };\r\nconst char *expected_str = "0-9,20-24,28-39,41-99,220-255";\r\nchar *prop_name = "msi-available-ranges";\r\nchar *node_name = "/fakenode";\r\nstruct device_node of_node;\r\nstruct property prop;\r\nstruct msi_bitmap bmp;\r\nint size = 256;\r\nDECLARE_BITMAP(expected, size);\r\nmemset(&of_node, 0, sizeof(of_node));\r\nof_node_init(&of_node);\r\nof_node.full_name = node_name;\r\nWARN_ON(msi_bitmap_alloc(&bmp, size, &of_node));\r\nWARN_ON(msi_bitmap_reserve_dt_hwirqs(&bmp) <= 0);\r\nWARN_ON(bitmap_find_free_region(bmp.bitmap, size, get_count_order(size)));\r\nbitmap_release_region(bmp.bitmap, 0, get_count_order(size));\r\nmemset(&prop, 0, sizeof(prop));\r\nprop.name = prop_name;\r\nprop.value = &prop_data;\r\nprop.length = sizeof(prop_data);\r\nof_node.properties = &prop;\r\nWARN_ON(msi_bitmap_reserve_dt_hwirqs(&bmp));\r\nWARN_ON(bitmap_parselist(expected_str, expected, size));\r\nWARN_ON(!bitmap_equal(expected, bmp.bitmap, size));\r\nmsi_bitmap_free(&bmp);\r\nkfree(bmp.bitmap);\r\n}\r\nstatic int __init msi_bitmap_selftest(void)\r\n{\r\nprintk(KERN_DEBUG "Running MSI bitmap self-tests ...\n");\r\ntest_basics();\r\ntest_of_node();\r\nreturn 0;\r\n}
