static void *waking_workerfn(void *arg)\r\n{\r\nstruct thread_data *waker = (struct thread_data *) arg;\r\nstruct timeval start, end;\r\ngettimeofday(&start, NULL);\r\nwaker->nwoken = futex_wake(&futex, nwakes, futex_flag);\r\nif (waker->nwoken != nwakes)\r\nwarnx("couldn't wakeup all tasks (%d/%d)",\r\nwaker->nwoken, nwakes);\r\ngettimeofday(&end, NULL);\r\ntimersub(&end, &start, &waker->runtime);\r\npthread_exit(NULL);\r\nreturn NULL;\r\n}\r\nstatic void wakeup_threads(struct thread_data *td, pthread_attr_t thread_attr)\r\n{\r\nunsigned int i;\r\npthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_JOINABLE);\r\nfor (i = 0; i < nwaking_threads; i++) {\r\nif (pthread_create(&td[i].worker, &thread_attr,\r\nwaking_workerfn, (void *)&td[i]))\r\nerr(EXIT_FAILURE, "pthread_create");\r\n}\r\nfor (i = 0; i < nwaking_threads; i++)\r\nif (pthread_join(td[i].worker, NULL))\r\nerr(EXIT_FAILURE, "pthread_join");\r\n}\r\nstatic void *blocked_workerfn(void *arg __maybe_unused)\r\n{\r\npthread_mutex_lock(&thread_lock);\r\nthreads_starting--;\r\nif (!threads_starting)\r\npthread_cond_signal(&thread_parent);\r\npthread_cond_wait(&thread_worker, &thread_lock);\r\npthread_mutex_unlock(&thread_lock);\r\nwhile (1) {\r\nif (futex_wait(&futex, 0, NULL, futex_flag) != EINTR)\r\nbreak;\r\n}\r\npthread_exit(NULL);\r\nreturn NULL;\r\n}\r\nstatic void block_threads(pthread_t *w, pthread_attr_t thread_attr)\r\n{\r\ncpu_set_t cpu;\r\nunsigned int i;\r\nthreads_starting = nblocked_threads;\r\nfor (i = 0; i < nblocked_threads; i++) {\r\nCPU_ZERO(&cpu);\r\nCPU_SET(i % ncpus, &cpu);\r\nif (pthread_attr_setaffinity_np(&thread_attr, sizeof(cpu_set_t), &cpu))\r\nerr(EXIT_FAILURE, "pthread_attr_setaffinity_np");\r\nif (pthread_create(&w[i], &thread_attr, blocked_workerfn, NULL))\r\nerr(EXIT_FAILURE, "pthread_create");\r\n}\r\n}\r\nstatic void print_run(struct thread_data *waking_worker, unsigned int run_num)\r\n{\r\nunsigned int i, wakeup_avg;\r\ndouble waketime_avg, waketime_stddev;\r\nstruct stats __waketime_stats, __wakeup_stats;\r\ninit_stats(&__wakeup_stats);\r\ninit_stats(&__waketime_stats);\r\nfor (i = 0; i < nwaking_threads; i++) {\r\nupdate_stats(&__waketime_stats, waking_worker[i].runtime.tv_usec);\r\nupdate_stats(&__wakeup_stats, waking_worker[i].nwoken);\r\n}\r\nwaketime_avg = avg_stats(&__waketime_stats);\r\nwaketime_stddev = stddev_stats(&__waketime_stats);\r\nwakeup_avg = avg_stats(&__wakeup_stats);\r\nprintf("[Run %d]: Avg per-thread latency (waking %d/%d threads) "\r\n"in %.4f ms (+-%.2f%%)\n", run_num + 1, wakeup_avg,\r\nnblocked_threads, waketime_avg/1e3,\r\nrel_stddev_stats(waketime_stddev, waketime_avg));\r\n}\r\nstatic void print_summary(void)\r\n{\r\nunsigned int wakeup_avg;\r\ndouble waketime_avg, waketime_stddev;\r\nwaketime_avg = avg_stats(&waketime_stats);\r\nwaketime_stddev = stddev_stats(&waketime_stats);\r\nwakeup_avg = avg_stats(&wakeup_stats);\r\nprintf("Avg per-thread latency (waking %d/%d threads) in %.4f ms (+-%.2f%%)\n",\r\nwakeup_avg,\r\nnblocked_threads,\r\nwaketime_avg/1e3,\r\nrel_stddev_stats(waketime_stddev, waketime_avg));\r\n}\r\nstatic void do_run_stats(struct thread_data *waking_worker)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < nwaking_threads; i++) {\r\nupdate_stats(&waketime_stats, waking_worker[i].runtime.tv_usec);\r\nupdate_stats(&wakeup_stats, waking_worker[i].nwoken);\r\n}\r\n}\r\nstatic void toggle_done(int sig __maybe_unused,\r\nsiginfo_t *info __maybe_unused,\r\nvoid *uc __maybe_unused)\r\n{\r\ndone = true;\r\n}\r\nint bench_futex_wake_parallel(int argc, const char **argv,\r\nconst char *prefix __maybe_unused)\r\n{\r\nint ret = 0;\r\nunsigned int i, j;\r\nstruct sigaction act;\r\npthread_attr_t thread_attr;\r\nstruct thread_data *waking_worker;\r\nargc = parse_options(argc, argv, options,\r\nbench_futex_wake_parallel_usage, 0);\r\nif (argc) {\r\nusage_with_options(bench_futex_wake_parallel_usage, options);\r\nexit(EXIT_FAILURE);\r\n}\r\nsigfillset(&act.sa_mask);\r\nact.sa_sigaction = toggle_done;\r\nsigaction(SIGINT, &act, NULL);\r\nncpus = sysconf(_SC_NPROCESSORS_ONLN);\r\nif (!nblocked_threads)\r\nnblocked_threads = ncpus;\r\nif (nwaking_threads > nblocked_threads || !nwaking_threads)\r\nnwaking_threads = nblocked_threads;\r\nif (nblocked_threads % nwaking_threads)\r\nerrx(EXIT_FAILURE, "Must be perfectly divisible");\r\nnwakes = nblocked_threads/nwaking_threads;\r\nblocked_worker = calloc(nblocked_threads, sizeof(*blocked_worker));\r\nif (!blocked_worker)\r\nerr(EXIT_FAILURE, "calloc");\r\nif (!fshared)\r\nfutex_flag = FUTEX_PRIVATE_FLAG;\r\nprintf("Run summary [PID %d]: blocking on %d threads (at [%s] "\r\n"futex %p), %d threads waking up %d at a time.\n\n",\r\ngetpid(), nblocked_threads, fshared ? "shared":"private",\r\n&futex, nwaking_threads, nwakes);\r\ninit_stats(&wakeup_stats);\r\ninit_stats(&waketime_stats);\r\npthread_attr_init(&thread_attr);\r\npthread_mutex_init(&thread_lock, NULL);\r\npthread_cond_init(&thread_parent, NULL);\r\npthread_cond_init(&thread_worker, NULL);\r\nfor (j = 0; j < bench_repeat && !done; j++) {\r\nwaking_worker = calloc(nwaking_threads, sizeof(*waking_worker));\r\nif (!waking_worker)\r\nerr(EXIT_FAILURE, "calloc");\r\nblock_threads(blocked_worker, thread_attr);\r\npthread_mutex_lock(&thread_lock);\r\nwhile (threads_starting)\r\npthread_cond_wait(&thread_parent, &thread_lock);\r\npthread_cond_broadcast(&thread_worker);\r\npthread_mutex_unlock(&thread_lock);\r\nusleep(100000);\r\nwakeup_threads(waking_worker, thread_attr);\r\nfor (i = 0; i < nblocked_threads; i++) {\r\nret = pthread_join(blocked_worker[i], NULL);\r\nif (ret)\r\nerr(EXIT_FAILURE, "pthread_join");\r\n}\r\ndo_run_stats(waking_worker);\r\nif (!silent)\r\nprint_run(waking_worker, j);\r\nfree(waking_worker);\r\n}\r\npthread_cond_destroy(&thread_parent);\r\npthread_cond_destroy(&thread_worker);\r\npthread_mutex_destroy(&thread_lock);\r\npthread_attr_destroy(&thread_attr);\r\nprint_summary();\r\nfree(blocked_worker);\r\nreturn ret;\r\n}
