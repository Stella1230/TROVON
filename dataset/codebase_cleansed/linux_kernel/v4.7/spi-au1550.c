static u32 au1550_spi_baudcfg(struct au1550_spi *hw, unsigned speed_hz)\r\n{\r\nu32 mainclk_hz = hw->pdata->mainclk_hz;\r\nu32 div, brg;\r\nfor (div = 0; div < 4; div++) {\r\nbrg = mainclk_hz / speed_hz / (4 << div);\r\nif (brg < (4 + 1)) {\r\nbrg = (4 + 1);\r\nbreak;\r\n}\r\nif (brg <= (63 + 1))\r\nbreak;\r\n}\r\nif (div == 4) {\r\ndiv = 3;\r\nbrg = (63 + 1);\r\n}\r\nbrg--;\r\nreturn PSC_SPICFG_SET_BAUD(brg) | PSC_SPICFG_SET_DIV(div);\r\n}\r\nstatic inline void au1550_spi_mask_ack_all(struct au1550_spi *hw)\r\n{\r\nhw->regs->psc_spimsk =\r\nPSC_SPIMSK_MM | PSC_SPIMSK_RR | PSC_SPIMSK_RO\r\n| PSC_SPIMSK_RU | PSC_SPIMSK_TR | PSC_SPIMSK_TO\r\n| PSC_SPIMSK_TU | PSC_SPIMSK_SD | PSC_SPIMSK_MD;\r\nwmb();\r\nhw->regs->psc_spievent =\r\nPSC_SPIEVNT_MM | PSC_SPIEVNT_RR | PSC_SPIEVNT_RO\r\n| PSC_SPIEVNT_RU | PSC_SPIEVNT_TR | PSC_SPIEVNT_TO\r\n| PSC_SPIEVNT_TU | PSC_SPIEVNT_SD | PSC_SPIEVNT_MD;\r\nwmb();\r\n}\r\nstatic void au1550_spi_reset_fifos(struct au1550_spi *hw)\r\n{\r\nu32 pcr;\r\nhw->regs->psc_spipcr = PSC_SPIPCR_RC | PSC_SPIPCR_TC;\r\nwmb();\r\ndo {\r\npcr = hw->regs->psc_spipcr;\r\nwmb();\r\n} while (pcr != 0);\r\n}\r\nstatic void au1550_spi_chipsel(struct spi_device *spi, int value)\r\n{\r\nstruct au1550_spi *hw = spi_master_get_devdata(spi->master);\r\nunsigned cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;\r\nu32 cfg, stat;\r\nswitch (value) {\r\ncase BITBANG_CS_INACTIVE:\r\nif (hw->pdata->deactivate_cs)\r\nhw->pdata->deactivate_cs(hw->pdata, spi->chip_select,\r\ncspol);\r\nbreak;\r\ncase BITBANG_CS_ACTIVE:\r\nau1550_spi_bits_handlers_set(hw, spi->bits_per_word);\r\ncfg = hw->regs->psc_spicfg;\r\nwmb();\r\nhw->regs->psc_spicfg = cfg & ~PSC_SPICFG_DE_ENABLE;\r\nwmb();\r\nif (spi->mode & SPI_CPOL)\r\ncfg |= PSC_SPICFG_BI;\r\nelse\r\ncfg &= ~PSC_SPICFG_BI;\r\nif (spi->mode & SPI_CPHA)\r\ncfg &= ~PSC_SPICFG_CDE;\r\nelse\r\ncfg |= PSC_SPICFG_CDE;\r\nif (spi->mode & SPI_LSB_FIRST)\r\ncfg |= PSC_SPICFG_MLF;\r\nelse\r\ncfg &= ~PSC_SPICFG_MLF;\r\nif (hw->usedma && spi->bits_per_word <= 8)\r\ncfg &= ~PSC_SPICFG_DD_DISABLE;\r\nelse\r\ncfg |= PSC_SPICFG_DD_DISABLE;\r\ncfg = PSC_SPICFG_CLR_LEN(cfg);\r\ncfg |= PSC_SPICFG_SET_LEN(spi->bits_per_word);\r\ncfg = PSC_SPICFG_CLR_BAUD(cfg);\r\ncfg &= ~PSC_SPICFG_SET_DIV(3);\r\ncfg |= au1550_spi_baudcfg(hw, spi->max_speed_hz);\r\nhw->regs->psc_spicfg = cfg | PSC_SPICFG_DE_ENABLE;\r\nwmb();\r\ndo {\r\nstat = hw->regs->psc_spistat;\r\nwmb();\r\n} while ((stat & PSC_SPISTAT_DR) == 0);\r\nif (hw->pdata->activate_cs)\r\nhw->pdata->activate_cs(hw->pdata, spi->chip_select,\r\ncspol);\r\nbreak;\r\n}\r\n}\r\nstatic int au1550_spi_setupxfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct au1550_spi *hw = spi_master_get_devdata(spi->master);\r\nunsigned bpw, hz;\r\nu32 cfg, stat;\r\nif (t) {\r\nbpw = t->bits_per_word;\r\nhz = t->speed_hz;\r\n} else {\r\nbpw = spi->bits_per_word;\r\nhz = spi->max_speed_hz;\r\n}\r\nif (!hz)\r\nreturn -EINVAL;\r\nau1550_spi_bits_handlers_set(hw, spi->bits_per_word);\r\ncfg = hw->regs->psc_spicfg;\r\nwmb();\r\nhw->regs->psc_spicfg = cfg & ~PSC_SPICFG_DE_ENABLE;\r\nwmb();\r\nif (hw->usedma && bpw <= 8)\r\ncfg &= ~PSC_SPICFG_DD_DISABLE;\r\nelse\r\ncfg |= PSC_SPICFG_DD_DISABLE;\r\ncfg = PSC_SPICFG_CLR_LEN(cfg);\r\ncfg |= PSC_SPICFG_SET_LEN(bpw);\r\ncfg = PSC_SPICFG_CLR_BAUD(cfg);\r\ncfg &= ~PSC_SPICFG_SET_DIV(3);\r\ncfg |= au1550_spi_baudcfg(hw, hz);\r\nhw->regs->psc_spicfg = cfg;\r\nwmb();\r\nif (cfg & PSC_SPICFG_DE_ENABLE) {\r\ndo {\r\nstat = hw->regs->psc_spistat;\r\nwmb();\r\n} while ((stat & PSC_SPISTAT_DR) == 0);\r\n}\r\nau1550_spi_reset_fifos(hw);\r\nau1550_spi_mask_ack_all(hw);\r\nreturn 0;\r\n}\r\nstatic int au1550_spi_dma_rxtmp_alloc(struct au1550_spi *hw, unsigned size)\r\n{\r\nhw->dma_rx_tmpbuf = kmalloc(size, GFP_KERNEL);\r\nif (!hw->dma_rx_tmpbuf)\r\nreturn -ENOMEM;\r\nhw->dma_rx_tmpbuf_size = size;\r\nhw->dma_rx_tmpbuf_addr = dma_map_single(hw->dev, hw->dma_rx_tmpbuf,\r\nsize, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(hw->dev, hw->dma_rx_tmpbuf_addr)) {\r\nkfree(hw->dma_rx_tmpbuf);\r\nhw->dma_rx_tmpbuf = 0;\r\nhw->dma_rx_tmpbuf_size = 0;\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void au1550_spi_dma_rxtmp_free(struct au1550_spi *hw)\r\n{\r\ndma_unmap_single(hw->dev, hw->dma_rx_tmpbuf_addr,\r\nhw->dma_rx_tmpbuf_size, DMA_FROM_DEVICE);\r\nkfree(hw->dma_rx_tmpbuf);\r\nhw->dma_rx_tmpbuf = 0;\r\nhw->dma_rx_tmpbuf_size = 0;\r\n}\r\nstatic int au1550_spi_dma_txrxb(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct au1550_spi *hw = spi_master_get_devdata(spi->master);\r\ndma_addr_t dma_tx_addr;\r\ndma_addr_t dma_rx_addr;\r\nu32 res;\r\nhw->len = t->len;\r\nhw->tx_count = 0;\r\nhw->rx_count = 0;\r\nhw->tx = t->tx_buf;\r\nhw->rx = t->rx_buf;\r\ndma_tx_addr = t->tx_dma;\r\ndma_rx_addr = t->rx_dma;\r\nif (t->tx_buf) {\r\nif (t->tx_dma == 0) {\r\ndma_tx_addr = dma_map_single(hw->dev,\r\n(void *)t->tx_buf,\r\nt->len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(hw->dev, dma_tx_addr))\r\ndev_err(hw->dev, "tx dma map error\n");\r\n}\r\n}\r\nif (t->rx_buf) {\r\nif (t->rx_dma == 0) {\r\ndma_rx_addr = dma_map_single(hw->dev,\r\n(void *)t->rx_buf,\r\nt->len, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(hw->dev, dma_rx_addr))\r\ndev_err(hw->dev, "rx dma map error\n");\r\n}\r\n} else {\r\nif (t->len > hw->dma_rx_tmpbuf_size) {\r\nint ret;\r\nau1550_spi_dma_rxtmp_free(hw);\r\nret = au1550_spi_dma_rxtmp_alloc(hw, max(t->len,\r\nAU1550_SPI_DMA_RXTMP_MINSIZE));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nhw->rx = hw->dma_rx_tmpbuf;\r\ndma_rx_addr = hw->dma_rx_tmpbuf_addr;\r\ndma_sync_single_for_device(hw->dev, dma_rx_addr,\r\nt->len, DMA_FROM_DEVICE);\r\n}\r\nif (!t->tx_buf) {\r\ndma_sync_single_for_device(hw->dev, dma_rx_addr,\r\nt->len, DMA_BIDIRECTIONAL);\r\nhw->tx = hw->rx;\r\n}\r\nres = au1xxx_dbdma_put_dest(hw->dma_rx_ch, virt_to_phys(hw->rx),\r\nt->len, DDMA_FLAGS_IE);\r\nif (!res)\r\ndev_err(hw->dev, "rx dma put dest error\n");\r\nres = au1xxx_dbdma_put_source(hw->dma_tx_ch, virt_to_phys(hw->tx),\r\nt->len, DDMA_FLAGS_IE);\r\nif (!res)\r\ndev_err(hw->dev, "tx dma put source error\n");\r\nau1xxx_dbdma_start(hw->dma_rx_ch);\r\nau1xxx_dbdma_start(hw->dma_tx_ch);\r\nhw->regs->psc_spimsk = PSC_SPIMSK_SD;\r\nwmb();\r\nhw->regs->psc_spipcr = PSC_SPIPCR_MS;\r\nwmb();\r\nwait_for_completion(&hw->master_done);\r\nau1xxx_dbdma_stop(hw->dma_tx_ch);\r\nau1xxx_dbdma_stop(hw->dma_rx_ch);\r\nif (!t->rx_buf) {\r\ndma_sync_single_for_cpu(hw->dev, dma_rx_addr, t->len,\r\nDMA_FROM_DEVICE);\r\n}\r\nif (t->rx_buf && t->rx_dma == 0 )\r\ndma_unmap_single(hw->dev, dma_rx_addr, t->len,\r\nDMA_FROM_DEVICE);\r\nif (t->tx_buf && t->tx_dma == 0 )\r\ndma_unmap_single(hw->dev, dma_tx_addr, t->len,\r\nDMA_TO_DEVICE);\r\nreturn hw->rx_count < hw->tx_count ? hw->rx_count : hw->tx_count;\r\n}\r\nstatic irqreturn_t au1550_spi_dma_irq_callback(struct au1550_spi *hw)\r\n{\r\nu32 stat, evnt;\r\nstat = hw->regs->psc_spistat;\r\nevnt = hw->regs->psc_spievent;\r\nwmb();\r\nif ((stat & PSC_SPISTAT_DI) == 0) {\r\ndev_err(hw->dev, "Unexpected IRQ!\n");\r\nreturn IRQ_NONE;\r\n}\r\nif ((evnt & (PSC_SPIEVNT_MM | PSC_SPIEVNT_RO\r\n| PSC_SPIEVNT_RU | PSC_SPIEVNT_TO\r\n| PSC_SPIEVNT_TU | PSC_SPIEVNT_SD))\r\n!= 0) {\r\nau1550_spi_mask_ack_all(hw);\r\nau1xxx_dbdma_stop(hw->dma_rx_ch);\r\nau1xxx_dbdma_stop(hw->dma_tx_ch);\r\nhw->rx_count = hw->len - au1xxx_get_dma_residue(hw->dma_rx_ch);\r\nhw->tx_count = hw->len - au1xxx_get_dma_residue(hw->dma_tx_ch);\r\nau1xxx_dbdma_reset(hw->dma_rx_ch);\r\nau1xxx_dbdma_reset(hw->dma_tx_ch);\r\nau1550_spi_reset_fifos(hw);\r\nif (evnt == PSC_SPIEVNT_RO)\r\ndev_err(hw->dev,\r\n"dma transfer: receive FIFO overflow!\n");\r\nelse\r\ndev_err(hw->dev,\r\n"dma transfer: unexpected SPI error "\r\n"(event=0x%x stat=0x%x)!\n", evnt, stat);\r\ncomplete(&hw->master_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((evnt & PSC_SPIEVNT_MD) != 0) {\r\nau1550_spi_mask_ack_all(hw);\r\nhw->rx_count = hw->len;\r\nhw->tx_count = hw->len;\r\ncomplete(&hw->master_done);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int au1550_spi_pio_txrxb(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nu32 stat, mask;\r\nstruct au1550_spi *hw = spi_master_get_devdata(spi->master);\r\nhw->tx = t->tx_buf;\r\nhw->rx = t->rx_buf;\r\nhw->len = t->len;\r\nhw->tx_count = 0;\r\nhw->rx_count = 0;\r\nmask = PSC_SPIMSK_SD;\r\nwhile (hw->tx_count < hw->len) {\r\nhw->tx_word(hw);\r\nif (hw->tx_count >= hw->len) {\r\nmask |= PSC_SPIMSK_TR;\r\n}\r\nstat = hw->regs->psc_spistat;\r\nwmb();\r\nif (stat & PSC_SPISTAT_TF)\r\nbreak;\r\n}\r\nhw->regs->psc_spimsk = mask;\r\nwmb();\r\nhw->regs->psc_spipcr = PSC_SPIPCR_MS;\r\nwmb();\r\nwait_for_completion(&hw->master_done);\r\nreturn hw->rx_count < hw->tx_count ? hw->rx_count : hw->tx_count;\r\n}\r\nstatic irqreturn_t au1550_spi_pio_irq_callback(struct au1550_spi *hw)\r\n{\r\nint busy;\r\nu32 stat, evnt;\r\nstat = hw->regs->psc_spistat;\r\nevnt = hw->regs->psc_spievent;\r\nwmb();\r\nif ((stat & PSC_SPISTAT_DI) == 0) {\r\ndev_err(hw->dev, "Unexpected IRQ!\n");\r\nreturn IRQ_NONE;\r\n}\r\nif ((evnt & (PSC_SPIEVNT_MM | PSC_SPIEVNT_RO\r\n| PSC_SPIEVNT_RU | PSC_SPIEVNT_TO\r\n| PSC_SPIEVNT_SD))\r\n!= 0) {\r\nau1550_spi_mask_ack_all(hw);\r\nau1550_spi_reset_fifos(hw);\r\ndev_err(hw->dev,\r\n"pio transfer: unexpected SPI error "\r\n"(event=0x%x stat=0x%x)!\n", evnt, stat);\r\ncomplete(&hw->master_done);\r\nreturn IRQ_HANDLED;\r\n}\r\ndo {\r\nbusy = 0;\r\nstat = hw->regs->psc_spistat;\r\nwmb();\r\nif (!(stat & PSC_SPISTAT_RE) && hw->rx_count < hw->len) {\r\nhw->rx_word(hw);\r\nbusy = 1;\r\nif (!(stat & PSC_SPISTAT_TF) && hw->tx_count < hw->len)\r\nhw->tx_word(hw);\r\n}\r\n} while (busy);\r\nhw->regs->psc_spievent = PSC_SPIEVNT_RR | PSC_SPIEVNT_TR;\r\nwmb();\r\nif (evnt & PSC_SPIEVNT_TU) {\r\nhw->regs->psc_spievent = PSC_SPIEVNT_TU | PSC_SPIEVNT_MD;\r\nwmb();\r\nhw->regs->psc_spipcr = PSC_SPIPCR_MS;\r\nwmb();\r\n}\r\nif (hw->rx_count >= hw->len) {\r\nau1550_spi_mask_ack_all(hw);\r\ncomplete(&hw->master_done);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int au1550_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct au1550_spi *hw = spi_master_get_devdata(spi->master);\r\nreturn hw->txrx_bufs(spi, t);\r\n}\r\nstatic irqreturn_t au1550_spi_irq(int irq, void *dev)\r\n{\r\nstruct au1550_spi *hw = dev;\r\nreturn hw->irq_callback(hw);\r\n}\r\nstatic void au1550_spi_bits_handlers_set(struct au1550_spi *hw, int bpw)\r\n{\r\nif (bpw <= 8) {\r\nif (hw->usedma) {\r\nhw->txrx_bufs = &au1550_spi_dma_txrxb;\r\nhw->irq_callback = &au1550_spi_dma_irq_callback;\r\n} else {\r\nhw->rx_word = &au1550_spi_rx_word_8;\r\nhw->tx_word = &au1550_spi_tx_word_8;\r\nhw->txrx_bufs = &au1550_spi_pio_txrxb;\r\nhw->irq_callback = &au1550_spi_pio_irq_callback;\r\n}\r\n} else if (bpw <= 16) {\r\nhw->rx_word = &au1550_spi_rx_word_16;\r\nhw->tx_word = &au1550_spi_tx_word_16;\r\nhw->txrx_bufs = &au1550_spi_pio_txrxb;\r\nhw->irq_callback = &au1550_spi_pio_irq_callback;\r\n} else {\r\nhw->rx_word = &au1550_spi_rx_word_32;\r\nhw->tx_word = &au1550_spi_tx_word_32;\r\nhw->txrx_bufs = &au1550_spi_pio_txrxb;\r\nhw->irq_callback = &au1550_spi_pio_irq_callback;\r\n}\r\n}\r\nstatic void au1550_spi_setup_psc_as_spi(struct au1550_spi *hw)\r\n{\r\nu32 stat, cfg;\r\nhw->regs->psc_ctrl = PSC_CTRL_DISABLE;\r\nwmb();\r\nhw->regs->psc_sel = PSC_SEL_PS_SPIMODE;\r\nwmb();\r\nhw->regs->psc_spicfg = 0;\r\nwmb();\r\nhw->regs->psc_ctrl = PSC_CTRL_ENABLE;\r\nwmb();\r\ndo {\r\nstat = hw->regs->psc_spistat;\r\nwmb();\r\n} while ((stat & PSC_SPISTAT_SR) == 0);\r\ncfg = hw->usedma ? 0 : PSC_SPICFG_DD_DISABLE;\r\ncfg |= PSC_SPICFG_SET_LEN(8);\r\ncfg |= PSC_SPICFG_RT_FIFO8 | PSC_SPICFG_TT_FIFO8;\r\ncfg |= PSC_SPICFG_SET_BAUD(4) | PSC_SPICFG_SET_DIV(0);\r\n#ifdef AU1550_SPI_DEBUG_LOOPBACK\r\ncfg |= PSC_SPICFG_LB;\r\n#endif\r\nhw->regs->psc_spicfg = cfg;\r\nwmb();\r\nau1550_spi_mask_ack_all(hw);\r\nhw->regs->psc_spicfg |= PSC_SPICFG_DE_ENABLE;\r\nwmb();\r\ndo {\r\nstat = hw->regs->psc_spistat;\r\nwmb();\r\n} while ((stat & PSC_SPISTAT_DR) == 0);\r\nau1550_spi_reset_fifos(hw);\r\n}\r\nstatic int au1550_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct au1550_spi *hw;\r\nstruct spi_master *master;\r\nstruct resource *r;\r\nint err = 0;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct au1550_spi));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "No memory for spi_master\n");\r\nerr = -ENOMEM;\r\ngoto err_nomem;\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 24);\r\nhw = spi_master_get_devdata(master);\r\nhw->master = master;\r\nhw->pdata = dev_get_platdata(&pdev->dev);\r\nhw->dev = &pdev->dev;\r\nif (hw->pdata == NULL) {\r\ndev_err(&pdev->dev, "No platform data supplied\n");\r\nerr = -ENOENT;\r\ngoto err_no_pdata;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no IRQ\n");\r\nerr = -ENODEV;\r\ngoto err_no_iores;\r\n}\r\nhw->irq = r->start;\r\nhw->usedma = 0;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (r) {\r\nhw->dma_tx_id = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (r) {\r\nhw->dma_rx_id = r->start;\r\nif (usedma && ddma_memid) {\r\nif (pdev->dev.dma_mask == NULL)\r\ndev_warn(&pdev->dev, "no dma mask\n");\r\nelse\r\nhw->usedma = 1;\r\n}\r\n}\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no mmio resource\n");\r\nerr = -ENODEV;\r\ngoto err_no_iores;\r\n}\r\nhw->ioarea = request_mem_region(r->start, sizeof(psc_spi_t),\r\npdev->name);\r\nif (!hw->ioarea) {\r\ndev_err(&pdev->dev, "Cannot reserve iomem region\n");\r\nerr = -ENXIO;\r\ngoto err_no_iores;\r\n}\r\nhw->regs = (psc_spi_t __iomem *)ioremap(r->start, sizeof(psc_spi_t));\r\nif (!hw->regs) {\r\ndev_err(&pdev->dev, "cannot ioremap\n");\r\nerr = -ENXIO;\r\ngoto err_ioremap;\r\n}\r\nplatform_set_drvdata(pdev, hw);\r\ninit_completion(&hw->master_done);\r\nhw->bitbang.master = hw->master;\r\nhw->bitbang.setup_transfer = au1550_spi_setupxfer;\r\nhw->bitbang.chipselect = au1550_spi_chipsel;\r\nhw->bitbang.txrx_bufs = au1550_spi_txrx_bufs;\r\nif (hw->usedma) {\r\nhw->dma_tx_ch = au1xxx_dbdma_chan_alloc(ddma_memid,\r\nhw->dma_tx_id, NULL, (void *)hw);\r\nif (hw->dma_tx_ch == 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot allocate tx dma channel\n");\r\nerr = -ENXIO;\r\ngoto err_no_txdma;\r\n}\r\nau1xxx_dbdma_set_devwidth(hw->dma_tx_ch, 8);\r\nif (au1xxx_dbdma_ring_alloc(hw->dma_tx_ch,\r\nAU1550_SPI_DBDMA_DESCRIPTORS) == 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot allocate tx dma descriptors\n");\r\nerr = -ENXIO;\r\ngoto err_no_txdma_descr;\r\n}\r\nhw->dma_rx_ch = au1xxx_dbdma_chan_alloc(hw->dma_rx_id,\r\nddma_memid, NULL, (void *)hw);\r\nif (hw->dma_rx_ch == 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot allocate rx dma channel\n");\r\nerr = -ENXIO;\r\ngoto err_no_rxdma;\r\n}\r\nau1xxx_dbdma_set_devwidth(hw->dma_rx_ch, 8);\r\nif (au1xxx_dbdma_ring_alloc(hw->dma_rx_ch,\r\nAU1550_SPI_DBDMA_DESCRIPTORS) == 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot allocate rx dma descriptors\n");\r\nerr = -ENXIO;\r\ngoto err_no_rxdma_descr;\r\n}\r\nerr = au1550_spi_dma_rxtmp_alloc(hw,\r\nAU1550_SPI_DMA_RXTMP_MINSIZE);\r\nif (err < 0) {\r\ndev_err(&pdev->dev,\r\n"Cannot allocate initial rx dma tmp buffer\n");\r\ngoto err_dma_rxtmp_alloc;\r\n}\r\n}\r\nau1550_spi_bits_handlers_set(hw, 8);\r\nerr = request_irq(hw->irq, au1550_spi_irq, 0, pdev->name, hw);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot claim IRQ\n");\r\ngoto err_no_irq;\r\n}\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = hw->pdata->num_chipselect;\r\n{\r\nint min_div = (2 << 0) * (2 * (4 + 1));\r\nint max_div = (2 << 3) * (2 * (63 + 1));\r\nmaster->max_speed_hz = hw->pdata->mainclk_hz / min_div;\r\nmaster->min_speed_hz =\r\nhw->pdata->mainclk_hz / (max_div + 1) + 1;\r\n}\r\nau1550_spi_setup_psc_as_spi(hw);\r\nerr = spi_bitbang_start(&hw->bitbang);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register SPI master\n");\r\ngoto err_register;\r\n}\r\ndev_info(&pdev->dev,\r\n"spi master registered: bus_num=%d num_chipselect=%d\n",\r\nmaster->bus_num, master->num_chipselect);\r\nreturn 0;\r\nerr_register:\r\nfree_irq(hw->irq, hw);\r\nerr_no_irq:\r\nau1550_spi_dma_rxtmp_free(hw);\r\nerr_dma_rxtmp_alloc:\r\nerr_no_rxdma_descr:\r\nif (hw->usedma)\r\nau1xxx_dbdma_chan_free(hw->dma_rx_ch);\r\nerr_no_rxdma:\r\nerr_no_txdma_descr:\r\nif (hw->usedma)\r\nau1xxx_dbdma_chan_free(hw->dma_tx_ch);\r\nerr_no_txdma:\r\niounmap((void __iomem *)hw->regs);\r\nerr_ioremap:\r\nrelease_mem_region(r->start, sizeof(psc_spi_t));\r\nerr_no_iores:\r\nerr_no_pdata:\r\nspi_master_put(hw->master);\r\nerr_nomem:\r\nreturn err;\r\n}\r\nstatic int au1550_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct au1550_spi *hw = platform_get_drvdata(pdev);\r\ndev_info(&pdev->dev, "spi master remove: bus_num=%d\n",\r\nhw->master->bus_num);\r\nspi_bitbang_stop(&hw->bitbang);\r\nfree_irq(hw->irq, hw);\r\niounmap((void __iomem *)hw->regs);\r\nrelease_mem_region(hw->ioarea->start, sizeof(psc_spi_t));\r\nif (hw->usedma) {\r\nau1550_spi_dma_rxtmp_free(hw);\r\nau1xxx_dbdma_chan_free(hw->dma_rx_ch);\r\nau1xxx_dbdma_chan_free(hw->dma_tx_ch);\r\n}\r\nspi_master_put(hw->master);\r\nreturn 0;\r\n}\r\nstatic int __init au1550_spi_init(void)\r\n{\r\nswitch (alchemy_get_cputype()) {\r\ncase ALCHEMY_CPU_AU1550:\r\ncase ALCHEMY_CPU_AU1200:\r\ncase ALCHEMY_CPU_AU1300:\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nif (usedma) {\r\nddma_memid = au1xxx_ddma_add_device(&au1550_spi_mem_dbdev);\r\nif (!ddma_memid)\r\nprintk(KERN_ERR "au1550-spi: cannot add memory"\r\n"dbdma device\n");\r\n}\r\nreturn platform_driver_register(&au1550_spi_drv);\r\n}\r\nstatic void __exit au1550_spi_exit(void)\r\n{\r\nif (usedma && ddma_memid)\r\nau1xxx_ddma_del_device(ddma_memid);\r\nplatform_driver_unregister(&au1550_spi_drv);\r\n}
