struct iwl_trans *iwl_trans_alloc(unsigned int priv_size,\r\nstruct device *dev,\r\nconst struct iwl_cfg *cfg,\r\nconst struct iwl_trans_ops *ops,\r\nsize_t dev_cmd_headroom)\r\n{\r\nstruct iwl_trans *trans;\r\n#ifdef CONFIG_LOCKDEP\r\nstatic struct lock_class_key __key;\r\n#endif\r\ntrans = kzalloc(sizeof(*trans) + priv_size, GFP_KERNEL);\r\nif (!trans)\r\nreturn NULL;\r\n#ifdef CONFIG_LOCKDEP\r\nlockdep_init_map(&trans->sync_cmd_lockdep_map, "sync_cmd_lockdep_map",\r\n&__key, 0);\r\n#endif\r\ntrans->dev = dev;\r\ntrans->cfg = cfg;\r\ntrans->ops = ops;\r\ntrans->dev_cmd_headroom = dev_cmd_headroom;\r\ntrans->num_rx_queues = 1;\r\nsnprintf(trans->dev_cmd_pool_name, sizeof(trans->dev_cmd_pool_name),\r\n"iwl_cmd_pool:%s", dev_name(trans->dev));\r\ntrans->dev_cmd_pool =\r\nkmem_cache_create(trans->dev_cmd_pool_name,\r\nsizeof(struct iwl_device_cmd)\r\n+ trans->dev_cmd_headroom,\r\nsizeof(void *),\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!trans->dev_cmd_pool)\r\ngoto free;\r\nreturn trans;\r\nfree:\r\nkfree(trans);\r\nreturn NULL;\r\n}\r\nvoid iwl_trans_free(struct iwl_trans *trans)\r\n{\r\nkmem_cache_destroy(trans->dev_cmd_pool);\r\nkfree(trans);\r\n}\r\nint iwl_trans_send_cmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd)\r\n{\r\nint ret;\r\nif (unlikely(!(cmd->flags & CMD_SEND_IN_RFKILL) &&\r\ntest_bit(STATUS_RFKILL, &trans->status)))\r\nreturn -ERFKILL;\r\nif (unlikely(test_bit(STATUS_FW_ERROR, &trans->status)))\r\nreturn -EIO;\r\nif (unlikely(trans->state != IWL_TRANS_FW_ALIVE)) {\r\nIWL_ERR(trans, "%s bad state = %d\n", __func__, trans->state);\r\nreturn -EIO;\r\n}\r\nif (WARN_ON((cmd->flags & CMD_WANT_ASYNC_CALLBACK) &&\r\n!(cmd->flags & CMD_ASYNC)))\r\nreturn -EINVAL;\r\nif (!(cmd->flags & CMD_ASYNC))\r\nlock_map_acquire_read(&trans->sync_cmd_lockdep_map);\r\nret = trans->ops->send_cmd(trans, cmd);\r\nif (!(cmd->flags & CMD_ASYNC))\r\nlock_map_release(&trans->sync_cmd_lockdep_map);\r\nreturn ret;\r\n}\r\nstatic int iwl_hcmd_names_cmp(const void *key, const void *elt)\r\n{\r\nconst struct iwl_hcmd_names *name = elt;\r\nu8 cmd1 = *(u8 *)key;\r\nu8 cmd2 = name->cmd_id;\r\nreturn (cmd1 - cmd2);\r\n}\r\nconst char *iwl_get_cmd_string(struct iwl_trans *trans, u32 id)\r\n{\r\nu8 grp, cmd;\r\nstruct iwl_hcmd_names *ret;\r\nconst struct iwl_hcmd_arr *arr;\r\nsize_t size = sizeof(struct iwl_hcmd_names);\r\ngrp = iwl_cmd_groupid(id);\r\ncmd = iwl_cmd_opcode(id);\r\nif (!trans->command_groups || grp >= trans->command_groups_size ||\r\n!trans->command_groups[grp].arr)\r\nreturn "UNKNOWN";\r\narr = &trans->command_groups[grp];\r\nret = bsearch(&cmd, arr->arr, arr->size, size, iwl_hcmd_names_cmp);\r\nif (!ret)\r\nreturn "UNKNOWN";\r\nreturn ret->cmd_name;\r\n}\r\nint iwl_cmd_groups_verify_sorted(const struct iwl_trans_config *trans)\r\n{\r\nint i, j;\r\nconst struct iwl_hcmd_arr *arr;\r\nfor (i = 0; i < trans->command_groups_size; i++) {\r\narr = &trans->command_groups[i];\r\nif (!arr->arr)\r\ncontinue;\r\nfor (j = 0; j < arr->size - 1; j++)\r\nif (arr->arr[j].cmd_id > arr->arr[j + 1].cmd_id)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}
