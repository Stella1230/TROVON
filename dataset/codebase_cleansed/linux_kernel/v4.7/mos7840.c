static int mos7840_set_reg_sync(struct usb_serial_port *port, __u16 reg,\r\n__u16 val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nval = val & 0x00ff;\r\ndev_dbg(&port->dev, "mos7840_set_reg_sync offset is %x, value %x\n", reg, val);\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ,\r\nMCS_WR_RTYPE, val, reg, NULL, 0,\r\nMOS_WDR_TIMEOUT);\r\n}\r\nstatic int mos7840_get_reg_sync(struct usb_serial_port *port, __u16 reg,\r\n__u16 *val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nint ret = 0;\r\nu8 *buf;\r\nbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,\r\nMCS_RD_RTYPE, 0, reg, buf, VENDOR_READ_LENGTH,\r\nMOS_WDR_TIMEOUT);\r\n*val = buf[0];\r\ndev_dbg(&port->dev, "%s offset is %x, return val %x\n", __func__, reg, *val);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int mos7840_set_uart_reg(struct usb_serial_port *port, __u16 reg,\r\n__u16 val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nval = val & 0x00ff;\r\nif (port->serial->num_ports == 4) {\r\nval |= ((__u16)port->port_number + 1) << 8;\r\n} else {\r\nif (port->port_number == 0) {\r\nval |= ((__u16)port->port_number + 1) << 8;\r\n} else {\r\nval |= ((__u16)port->port_number + 2) << 8;\r\n}\r\n}\r\ndev_dbg(&port->dev, "%s application number is %x\n", __func__, val);\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ,\r\nMCS_WR_RTYPE, val, reg, NULL, 0,\r\nMOS_WDR_TIMEOUT);\r\n}\r\nstatic int mos7840_get_uart_reg(struct usb_serial_port *port, __u16 reg,\r\n__u16 *val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nint ret = 0;\r\n__u16 Wval;\r\nu8 *buf;\r\nbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (port->serial->num_ports == 4) {\r\nWval = ((__u16)port->port_number + 1) << 8;\r\n} else {\r\nif (port->port_number == 0) {\r\nWval = ((__u16)port->port_number + 1) << 8;\r\n} else {\r\nWval = ((__u16)port->port_number + 2) << 8;\r\n}\r\n}\r\ndev_dbg(&port->dev, "%s application number is %x\n", __func__, Wval);\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,\r\nMCS_RD_RTYPE, Wval, reg, buf, VENDOR_READ_LENGTH,\r\nMOS_WDR_TIMEOUT);\r\n*val = buf[0];\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void mos7840_dump_serial_port(struct usb_serial_port *port,\r\nstruct moschip_port *mos7840_port)\r\n{\r\ndev_dbg(&port->dev, "SpRegOffset is %2x\n", mos7840_port->SpRegOffset);\r\ndev_dbg(&port->dev, "ControlRegOffset is %2x\n", mos7840_port->ControlRegOffset);\r\ndev_dbg(&port->dev, "DCRRegOffset is %2x\n", mos7840_port->DcrRegOffset);\r\n}\r\nstatic inline void mos7840_set_port_private(struct usb_serial_port *port,\r\nstruct moschip_port *data)\r\n{\r\nusb_set_serial_port_data(port, (void *)data);\r\n}\r\nstatic inline struct moschip_port *mos7840_get_port_private(struct\r\nusb_serial_port\r\n*port)\r\n{\r\nreturn (struct moschip_port *)usb_get_serial_port_data(port);\r\n}\r\nstatic void mos7840_handle_new_msr(struct moschip_port *port, __u8 new_msr)\r\n{\r\nstruct moschip_port *mos7840_port;\r\nstruct async_icount *icount;\r\nmos7840_port = port;\r\nif (new_msr &\r\n(MOS_MSR_DELTA_CTS | MOS_MSR_DELTA_DSR | MOS_MSR_DELTA_RI |\r\nMOS_MSR_DELTA_CD)) {\r\nicount = &mos7840_port->port->icount;\r\nif (new_msr & MOS_MSR_DELTA_CTS)\r\nicount->cts++;\r\nif (new_msr & MOS_MSR_DELTA_DSR)\r\nicount->dsr++;\r\nif (new_msr & MOS_MSR_DELTA_CD)\r\nicount->dcd++;\r\nif (new_msr & MOS_MSR_DELTA_RI)\r\nicount->rng++;\r\nwake_up_interruptible(&port->port->port.delta_msr_wait);\r\n}\r\n}\r\nstatic void mos7840_handle_new_lsr(struct moschip_port *port, __u8 new_lsr)\r\n{\r\nstruct async_icount *icount;\r\nif (new_lsr & SERIAL_LSR_BI) {\r\nnew_lsr &= (__u8) (SERIAL_LSR_OE | SERIAL_LSR_BI);\r\n}\r\nicount = &port->port->icount;\r\nif (new_lsr & SERIAL_LSR_BI)\r\nicount->brk++;\r\nif (new_lsr & SERIAL_LSR_OE)\r\nicount->overrun++;\r\nif (new_lsr & SERIAL_LSR_PE)\r\nicount->parity++;\r\nif (new_lsr & SERIAL_LSR_FE)\r\nicount->frame++;\r\n}\r\nstatic void mos7840_control_callback(struct urb *urb)\r\n{\r\nunsigned char *data;\r\nstruct moschip_port *mos7840_port;\r\nstruct device *dev = &urb->dev->dev;\r\n__u8 regval = 0x0;\r\nint status = urb->status;\r\nmos7840_port = urb->context;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n", __func__, status);\r\ngoto out;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n", __func__, status);\r\ngoto out;\r\n}\r\ndev_dbg(dev, "%s urb buffer size is %d\n", __func__, urb->actual_length);\r\ndev_dbg(dev, "%s mos7840_port->MsrLsr is %d port %d\n", __func__,\r\nmos7840_port->MsrLsr, mos7840_port->port_num);\r\ndata = urb->transfer_buffer;\r\nregval = (__u8) data[0];\r\ndev_dbg(dev, "%s data is %x\n", __func__, regval);\r\nif (mos7840_port->MsrLsr == 0)\r\nmos7840_handle_new_msr(mos7840_port, regval);\r\nelse if (mos7840_port->MsrLsr == 1)\r\nmos7840_handle_new_lsr(mos7840_port, regval);\r\nout:\r\nclear_bit_unlock(MOS7840_FLAG_CTRL_BUSY, &mos7840_port->flags);\r\n}\r\nstatic int mos7840_get_reg(struct moschip_port *mcs, __u16 Wval, __u16 reg,\r\n__u16 *val)\r\n{\r\nstruct usb_device *dev = mcs->port->serial->dev;\r\nstruct usb_ctrlrequest *dr = mcs->dr;\r\nunsigned char *buffer = mcs->ctrl_buf;\r\nint ret;\r\nif (test_and_set_bit_lock(MOS7840_FLAG_CTRL_BUSY, &mcs->flags))\r\nreturn -EBUSY;\r\ndr->bRequestType = MCS_RD_RTYPE;\r\ndr->bRequest = MCS_RDREQ;\r\ndr->wValue = cpu_to_le16(Wval);\r\ndr->wIndex = cpu_to_le16(reg);\r\ndr->wLength = cpu_to_le16(2);\r\nusb_fill_control_urb(mcs->control_urb, dev, usb_rcvctrlpipe(dev, 0),\r\n(unsigned char *)dr, buffer, 2,\r\nmos7840_control_callback, mcs);\r\nmcs->control_urb->transfer_buffer_length = 2;\r\nret = usb_submit_urb(mcs->control_urb, GFP_ATOMIC);\r\nif (ret)\r\nclear_bit_unlock(MOS7840_FLAG_CTRL_BUSY, &mcs->flags);\r\nreturn ret;\r\n}\r\nstatic void mos7840_set_led_callback(struct urb *urb)\r\n{\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&urb->dev->dev, "%s - urb shutting down: %d\n",\r\n__func__, urb->status);\r\nbreak;\r\ndefault:\r\ndev_dbg(&urb->dev->dev, "%s - nonzero urb status: %d\n",\r\n__func__, urb->status);\r\n}\r\n}\r\nstatic void mos7840_set_led_async(struct moschip_port *mcs, __u16 wval,\r\n__u16 reg)\r\n{\r\nstruct usb_device *dev = mcs->port->serial->dev;\r\nstruct usb_ctrlrequest *dr = mcs->led_dr;\r\ndr->bRequestType = MCS_WR_RTYPE;\r\ndr->bRequest = MCS_WRREQ;\r\ndr->wValue = cpu_to_le16(wval);\r\ndr->wIndex = cpu_to_le16(reg);\r\ndr->wLength = cpu_to_le16(0);\r\nusb_fill_control_urb(mcs->led_urb, dev, usb_sndctrlpipe(dev, 0),\r\n(unsigned char *)dr, NULL, 0, mos7840_set_led_callback, NULL);\r\nusb_submit_urb(mcs->led_urb, GFP_ATOMIC);\r\n}\r\nstatic void mos7840_set_led_sync(struct usb_serial_port *port, __u16 reg,\r\n__u16 val)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nusb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ, MCS_WR_RTYPE,\r\nval, reg, NULL, 0, MOS_WDR_TIMEOUT);\r\n}\r\nstatic void mos7840_led_off(unsigned long arg)\r\n{\r\nstruct moschip_port *mcs = (struct moschip_port *) arg;\r\nmos7840_set_led_async(mcs, 0x0300, MODEM_CONTROL_REGISTER);\r\nmod_timer(&mcs->led_timer2,\r\njiffies + msecs_to_jiffies(LED_OFF_MS));\r\n}\r\nstatic void mos7840_led_flag_off(unsigned long arg)\r\n{\r\nstruct moschip_port *mcs = (struct moschip_port *) arg;\r\nclear_bit_unlock(MOS7840_FLAG_LED_BUSY, &mcs->flags);\r\n}\r\nstatic void mos7840_led_activity(struct usb_serial_port *port)\r\n{\r\nstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\r\nif (test_and_set_bit_lock(MOS7840_FLAG_LED_BUSY, &mos7840_port->flags))\r\nreturn;\r\nmos7840_set_led_async(mos7840_port, 0x0301, MODEM_CONTROL_REGISTER);\r\nmod_timer(&mos7840_port->led_timer1,\r\njiffies + msecs_to_jiffies(LED_ON_MS));\r\n}\r\nstatic void mos7840_interrupt_callback(struct urb *urb)\r\n{\r\nint result;\r\nint length;\r\nstruct moschip_port *mos7840_port;\r\nstruct usb_serial *serial;\r\n__u16 Data;\r\nunsigned char *data;\r\n__u8 sp[5], st;\r\nint i, rv = 0;\r\n__u16 wval, wreg = 0;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&urb->dev->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&urb->dev->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nlength = urb->actual_length;\r\ndata = urb->transfer_buffer;\r\nserial = urb->context;\r\nif (length > 5) {\r\ndev_dbg(&urb->dev->dev, "%s", "Wrong data !!!\n");\r\nreturn;\r\n}\r\nsp[0] = (__u8) data[0];\r\nsp[1] = (__u8) data[1];\r\nsp[2] = (__u8) data[2];\r\nsp[3] = (__u8) data[3];\r\nst = (__u8) data[4];\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nmos7840_port = mos7840_get_port_private(serial->port[i]);\r\nwval = ((__u16)serial->port[i]->port_number + 1) << 8;\r\nif (mos7840_port->open) {\r\nif (sp[i] & 0x01) {\r\ndev_dbg(&urb->dev->dev, "SP%d No Interrupt !!!\n", i);\r\n} else {\r\nswitch (sp[i] & 0x0f) {\r\ncase SERIAL_IIR_RLS:\r\ndev_dbg(&urb->dev->dev, "Serial Port %d: Receiver status error or \n", i);\r\ndev_dbg(&urb->dev->dev, "address bit detected in 9-bit mode\n");\r\nmos7840_port->MsrLsr = 1;\r\nwreg = LINE_STATUS_REGISTER;\r\nbreak;\r\ncase SERIAL_IIR_MS:\r\ndev_dbg(&urb->dev->dev, "Serial Port %d: Modem status change\n", i);\r\nmos7840_port->MsrLsr = 0;\r\nwreg = MODEM_STATUS_REGISTER;\r\nbreak;\r\n}\r\nrv = mos7840_get_reg(mos7840_port, wval, wreg, &Data);\r\n}\r\n}\r\n}\r\nif (!(rv < 0))\r\nreturn;\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting interrupt urb\n",\r\n__func__, result);\r\n}\r\n}\r\nstatic int mos7840_port_paranoia_check(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port) {\r\npr_debug("%s - port == NULL\n", function);\r\nreturn -1;\r\n}\r\nif (!port->serial) {\r\npr_debug("%s - port->serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mos7840_serial_paranoia_check(struct usb_serial *serial,\r\nconst char *function)\r\n{\r\nif (!serial) {\r\npr_debug("%s - serial == NULL\n", function);\r\nreturn -1;\r\n}\r\nif (!serial->type) {\r\npr_debug("%s - serial->type == NULL!\n", function);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct usb_serial *mos7840_get_usb_serial(struct usb_serial_port *port,\r\nconst char *function)\r\n{\r\nif (!port ||\r\nmos7840_port_paranoia_check(port, function) ||\r\nmos7840_serial_paranoia_check(port->serial, function)) {\r\nreturn NULL;\r\n}\r\nreturn port->serial;\r\n}\r\nstatic void mos7840_bulk_in_callback(struct urb *urb)\r\n{\r\nint retval;\r\nunsigned char *data;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nstruct moschip_port *mos7840_port;\r\nint status = urb->status;\r\nmos7840_port = urb->context;\r\nif (!mos7840_port)\r\nreturn;\r\nif (status) {\r\ndev_dbg(&urb->dev->dev, "nonzero read bulk status received: %d\n", status);\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\nport = mos7840_port->port;\r\nif (mos7840_port_paranoia_check(port, __func__)) {\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\nserial = mos7840_get_usb_serial(port, __func__);\r\nif (!serial) {\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\ndata = urb->transfer_buffer;\r\nusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\r\nif (urb->actual_length) {\r\nstruct tty_port *tport = &mos7840_port->port->port;\r\ntty_insert_flip_string(tport, data, urb->actual_length);\r\ntty_flip_buffer_push(tport);\r\nport->icount.rx += urb->actual_length;\r\ndev_dbg(&port->dev, "icount.rx is %d:\n", port->icount.rx);\r\n}\r\nif (!mos7840_port->read_urb) {\r\ndev_dbg(&port->dev, "%s", "URB KILLED !!!\n");\r\nmos7840_port->read_urb_busy = false;\r\nreturn;\r\n}\r\nif (mos7840_port->has_led)\r\nmos7840_led_activity(port);\r\nmos7840_port->read_urb_busy = true;\r\nretval = usb_submit_urb(mos7840_port->read_urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_dbg(&port->dev, "usb_submit_urb(read bulk) failed, retval = %d\n", retval);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\n}\r\nstatic void mos7840_bulk_out_data_callback(struct urb *urb)\r\n{\r\nstruct moschip_port *mos7840_port;\r\nstruct usb_serial_port *port;\r\nint status = urb->status;\r\nint i;\r\nmos7840_port = urb->context;\r\nport = mos7840_port->port;\r\nspin_lock(&mos7840_port->pool_lock);\r\nfor (i = 0; i < NUM_URBS; i++) {\r\nif (urb == mos7840_port->write_urb_pool[i]) {\r\nmos7840_port->busy[i] = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&mos7840_port->pool_lock);\r\nif (status) {\r\ndev_dbg(&port->dev, "nonzero write bulk status received:%d\n", status);\r\nreturn;\r\n}\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn;\r\nif (mos7840_port->open)\r\ntty_port_tty_wakeup(&port->port);\r\n}\r\nstatic int mos7840_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint response;\r\nint j;\r\nstruct usb_serial *serial;\r\nstruct urb *urb;\r\n__u16 Data;\r\nint status;\r\nstruct moschip_port *mos7840_port;\r\nstruct moschip_port *port0;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn -ENODEV;\r\nserial = port->serial;\r\nif (mos7840_serial_paranoia_check(serial, __func__))\r\nreturn -ENODEV;\r\nmos7840_port = mos7840_get_port_private(port);\r\nport0 = mos7840_get_port_private(serial->port[0]);\r\nif (mos7840_port == NULL || port0 == NULL)\r\nreturn -ENODEV;\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nport0->open_ports++;\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nmos7840_port->write_urb_pool[j] = urb;\r\nif (!urb)\r\ncontinue;\r\nurb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (!urb->transfer_buffer) {\r\nusb_free_urb(urb);\r\nmos7840_port->write_urb_pool[j] = NULL;\r\ncontinue;\r\n}\r\n}\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset, &Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Reading Spreg failed\n");\r\ngoto err;\r\n}\r\nData |= 0x80;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "writing Spreg failed\n");\r\ngoto err;\r\n}\r\nData &= ~0x80;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "writing Spreg failed\n");\r\ngoto err;\r\n}\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\r\n&Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Reading Controlreg failed\n");\r\ngoto err;\r\n}\r\nData |= 0x08;\r\nData |= 0x20;\r\nstatus = mos7840_set_reg_sync(port,\r\nmos7840_port->ControlRegOffset, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "writing Controlreg failed\n");\r\ngoto err;\r\n}\r\nData = 0x00;\r\nstatus = mos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "disabling interrupts failed\n");\r\ngoto err;\r\n}\r\nData = 0x00;\r\nstatus = mos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing FIFO_CONTROL_REGISTER failed\n");\r\ngoto err;\r\n}\r\nData = 0xcf;\r\nstatus = mos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing FIFO_CONTROL_REGISTER failed\n");\r\ngoto err;\r\n}\r\nData = 0x03;\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowLCR = Data;\r\nData = 0x0b;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowMCR = Data;\r\nData = 0x00;\r\nstatus = mos7840_get_uart_reg(port, LINE_CONTROL_REGISTER, &Data);\r\nmos7840_port->shadowLCR = Data;\r\nData |= SERIAL_LCR_DLAB;\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nData = 0x0c;\r\nstatus = mos7840_set_uart_reg(port, DIVISOR_LATCH_LSB, Data);\r\nData = 0x0;\r\nstatus = mos7840_set_uart_reg(port, DIVISOR_LATCH_MSB, Data);\r\nData = 0x00;\r\nstatus = mos7840_get_uart_reg(port, LINE_CONTROL_REGISTER, &Data);\r\nData = Data & ~SERIAL_LCR_DLAB;\r\nstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowLCR = Data;\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset, &Data);\r\nData = Data | 0x0c;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nData = Data & ~0x0c;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\r\nData = 0x0c;\r\nstatus = mos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\r\n&Data);\r\nData = Data & ~0x20;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->ControlRegOffset,\r\nData);\r\nData = 0x0;\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\r\n&Data);\r\nData = Data | 0x10;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->ControlRegOffset,\r\nData);\r\nif (port0->open_ports == 1) {\r\nif (serial->port[0]->interrupt_in_buffer == NULL) {\r\nusb_fill_int_urb(serial->port[0]->interrupt_in_urb,\r\nserial->dev,\r\nusb_rcvintpipe(serial->dev,\r\nserial->port[0]->interrupt_in_endpointAddress),\r\nserial->port[0]->interrupt_in_buffer,\r\nserial->port[0]->interrupt_in_urb->\r\ntransfer_buffer_length,\r\nmos7840_interrupt_callback,\r\nserial,\r\nserial->port[0]->interrupt_in_urb->interval);\r\nresponse =\r\nusb_submit_urb(serial->port[0]->interrupt_in_urb,\r\nGFP_KERNEL);\r\nif (response) {\r\ndev_err(&port->dev, "%s - Error %d submitting "\r\n"interrupt urb\n", __func__, response);\r\n}\r\n}\r\n}\r\ndev_dbg(&port->dev, "port number is %d\n", port->port_number);\r\ndev_dbg(&port->dev, "minor number is %d\n", port->minor);\r\ndev_dbg(&port->dev, "Bulkin endpoint is %d\n", port->bulk_in_endpointAddress);\r\ndev_dbg(&port->dev, "BulkOut endpoint is %d\n", port->bulk_out_endpointAddress);\r\ndev_dbg(&port->dev, "Interrupt endpoint is %d\n", port->interrupt_in_endpointAddress);\r\ndev_dbg(&port->dev, "port's number in the device is %d\n", mos7840_port->port_num);\r\nmos7840_port->read_urb = port->read_urb;\r\nif ((serial->num_ports == 2) && (((__u16)port->port_number % 2) != 0)) {\r\nusb_fill_bulk_urb(mos7840_port->read_urb,\r\nserial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\n(port->bulk_in_endpointAddress) + 2),\r\nport->bulk_in_buffer,\r\nmos7840_port->read_urb->transfer_buffer_length,\r\nmos7840_bulk_in_callback, mos7840_port);\r\n} else {\r\nusb_fill_bulk_urb(mos7840_port->read_urb,\r\nserial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->bulk_in_buffer,\r\nmos7840_port->read_urb->transfer_buffer_length,\r\nmos7840_bulk_in_callback, mos7840_port);\r\n}\r\ndev_dbg(&port->dev, "%s: bulkin endpoint is %d\n", __func__, port->bulk_in_endpointAddress);\r\nmos7840_port->read_urb_busy = true;\r\nresponse = usb_submit_urb(mos7840_port->read_urb, GFP_KERNEL);\r\nif (response) {\r\ndev_err(&port->dev, "%s - Error %d submitting control urb\n",\r\n__func__, response);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\nmos7840_port->shadowMCR = MCR_MASTER_IE;\r\nmos7840_port->open = 1;\r\nreturn 0;\r\nerr:\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nurb = mos7840_port->write_urb_pool[j];\r\nif (!urb)\r\ncontinue;\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\nreturn status;\r\n}\r\nstatic int mos7840_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint i;\r\nint chars = 0;\r\nunsigned long flags;\r\nstruct moschip_port *mos7840_port;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn 0;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn 0;\r\nspin_lock_irqsave(&mos7840_port->pool_lock, flags);\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (mos7840_port->busy[i]) {\r\nstruct urb *urb = mos7840_port->write_urb_pool[i];\r\nchars += urb->transfer_buffer_length;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\r\ndev_dbg(&port->dev, "%s - returns %d\n", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic void mos7840_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7840_port;\r\nstruct moschip_port *port0;\r\nint j;\r\n__u16 Data;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn;\r\nserial = mos7840_get_usb_serial(port, __func__);\r\nif (!serial)\r\nreturn;\r\nmos7840_port = mos7840_get_port_private(port);\r\nport0 = mos7840_get_port_private(serial->port[0]);\r\nif (mos7840_port == NULL || port0 == NULL)\r\nreturn;\r\nfor (j = 0; j < NUM_URBS; ++j)\r\nusb_kill_urb(mos7840_port->write_urb_pool[j]);\r\nfor (j = 0; j < NUM_URBS; ++j) {\r\nif (mos7840_port->write_urb_pool[j]) {\r\nkfree(mos7840_port->write_urb_pool[j]->transfer_buffer);\r\nusb_free_urb(mos7840_port->write_urb_pool[j]);\r\n}\r\n}\r\nusb_kill_urb(mos7840_port->write_urb);\r\nusb_kill_urb(mos7840_port->read_urb);\r\nmos7840_port->read_urb_busy = false;\r\nport0->open_ports--;\r\ndev_dbg(&port->dev, "%s in close%d\n", __func__, port0->open_ports);\r\nif (port0->open_ports == 0) {\r\nif (serial->port[0]->interrupt_in_urb) {\r\ndev_dbg(&port->dev, "Shutdown interrupt_in_urb\n");\r\nusb_kill_urb(serial->port[0]->interrupt_in_urb);\r\n}\r\n}\r\nif (mos7840_port->write_urb) {\r\nkfree(mos7840_port->write_urb->transfer_buffer);\r\nusb_free_urb(mos7840_port->write_urb);\r\n}\r\nData = 0x0;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nData = 0x00;\r\nmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nmos7840_port->open = 0;\r\n}\r\nstatic void mos7840_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned char data;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7840_port;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn;\r\nserial = mos7840_get_usb_serial(port, __func__);\r\nif (!serial)\r\nreturn;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (break_state == -1)\r\ndata = mos7840_port->shadowLCR | LCR_SET_BREAK;\r\nelse\r\ndata = mos7840_port->shadowLCR & ~LCR_SET_BREAK;\r\nmos7840_port->shadowLCR = data;\r\ndev_dbg(&port->dev, "%s mos7840_port->shadowLCR is %x\n", __func__, mos7840_port->shadowLCR);\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER,\r\nmos7840_port->shadowLCR);\r\n}\r\nstatic int mos7840_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint i;\r\nint room = 0;\r\nunsigned long flags;\r\nstruct moschip_port *mos7840_port;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn -1;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\nspin_lock_irqsave(&mos7840_port->pool_lock, flags);\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (!mos7840_port->busy[i])\r\nroom += URB_TRANSFER_BUFFER_SIZE;\r\n}\r\nspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\r\nroom = (room == 0) ? 0 : room - URB_TRANSFER_BUFFER_SIZE + 1;\r\ndev_dbg(&mos7840_port->port->dev, "%s - returns %d\n", __func__, room);\r\nreturn room;\r\n}\r\nstatic int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *data, int count)\r\n{\r\nint status;\r\nint i;\r\nint bytes_sent = 0;\r\nint transfer_size;\r\nunsigned long flags;\r\nstruct moschip_port *mos7840_port;\r\nstruct usb_serial *serial;\r\nstruct urb *urb;\r\nconst unsigned char *current_position = data;\r\nunsigned char *data1;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn -1;\r\nserial = port->serial;\r\nif (mos7840_serial_paranoia_check(serial, __func__))\r\nreturn -1;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\nurb = NULL;\r\nspin_lock_irqsave(&mos7840_port->pool_lock, flags);\r\nfor (i = 0; i < NUM_URBS; ++i) {\r\nif (!mos7840_port->busy[i]) {\r\nmos7840_port->busy[i] = 1;\r\nurb = mos7840_port->write_urb_pool[i];\r\ndev_dbg(&port->dev, "URB:%d\n", i);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\r\nif (urb == NULL) {\r\ndev_dbg(&port->dev, "%s - no more free urbs\n", __func__);\r\ngoto exit;\r\n}\r\nif (urb->transfer_buffer == NULL) {\r\nurb->transfer_buffer =\r\nkmalloc(URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\ngoto exit;\r\n}\r\ntransfer_size = min(count, URB_TRANSFER_BUFFER_SIZE);\r\nmemcpy(urb->transfer_buffer, current_position, transfer_size);\r\nif ((serial->num_ports == 2) && (((__u16)port->port_number % 2) != 0)) {\r\nusb_fill_bulk_urb(urb,\r\nserial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\n(port->bulk_out_endpointAddress) + 2),\r\nurb->transfer_buffer,\r\ntransfer_size,\r\nmos7840_bulk_out_data_callback, mos7840_port);\r\n} else {\r\nusb_fill_bulk_urb(urb,\r\nserial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress),\r\nurb->transfer_buffer,\r\ntransfer_size,\r\nmos7840_bulk_out_data_callback, mos7840_port);\r\n}\r\ndata1 = urb->transfer_buffer;\r\ndev_dbg(&port->dev, "bulkout endpoint is %d\n", port->bulk_out_endpointAddress);\r\nif (mos7840_port->has_led)\r\nmos7840_led_activity(port);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\nmos7840_port->busy[i] = 0;\r\ndev_err_console(port, "%s - usb_submit_urb(write bulk) failed "\r\n"with status = %d\n", __func__, status);\r\nbytes_sent = status;\r\ngoto exit;\r\n}\r\nbytes_sent = transfer_size;\r\nport->icount.tx += transfer_size;\r\ndev_dbg(&port->dev, "icount.tx is %d:\n", port->icount.tx);\r\nexit:\r\nreturn bytes_sent;\r\n}\r\nstatic void mos7840_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7840_port;\r\nint status;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (!mos7840_port->open) {\r\ndev_dbg(&port->dev, "%s", "port not opened\n");\r\nreturn;\r\n}\r\nif (I_IXOFF(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nstatus = mos7840_write(tty, port, &stop_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (C_CRTSCTS(tty)) {\r\nmos7840_port->shadowMCR &= ~MCR_RTS;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nmos7840_port->shadowMCR);\r\nif (status < 0)\r\nreturn;\r\n}\r\n}\r\nstatic void mos7840_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint status;\r\nstruct moschip_port *mos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn;\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (!mos7840_port->open) {\r\ndev_dbg(&port->dev, "%s - port not opened\n", __func__);\r\nreturn;\r\n}\r\nif (I_IXOFF(tty)) {\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus = mos7840_write(tty, port, &start_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (C_CRTSCTS(tty)) {\r\nmos7840_port->shadowMCR |= MCR_RTS;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nmos7840_port->shadowMCR);\r\nif (status < 0)\r\nreturn;\r\n}\r\n}\r\nstatic int mos7840_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7840_port;\r\nunsigned int result;\r\n__u16 msr;\r\n__u16 mcr;\r\nint status;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn -ENODEV;\r\nstatus = mos7840_get_uart_reg(port, MODEM_STATUS_REGISTER, &msr);\r\nif (status != 1)\r\nreturn -EIO;\r\nstatus = mos7840_get_uart_reg(port, MODEM_CONTROL_REGISTER, &mcr);\r\nif (status != 1)\r\nreturn -EIO;\r\nresult = ((mcr & MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((mcr & MCR_LOOPBACK) ? TIOCM_LOOP : 0)\r\n| ((msr & MOS7840_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr & MOS7840_MSR_CD) ? TIOCM_CAR : 0)\r\n| ((msr & MOS7840_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr & MOS7840_MSR_DSR) ? TIOCM_DSR : 0);\r\ndev_dbg(&port->dev, "%s - 0x%04X\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic int mos7840_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct moschip_port *mos7840_port;\r\nunsigned int mcr;\r\nint status;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn -ENODEV;\r\nmcr = mos7840_port->shadowMCR;\r\nif (clear & TIOCM_RTS)\r\nmcr &= ~MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr &= ~MCR_DTR;\r\nif (clear & TIOCM_LOOP)\r\nmcr &= ~MCR_LOOPBACK;\r\nif (set & TIOCM_RTS)\r\nmcr |= MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr |= MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr |= MCR_LOOPBACK;\r\nmos7840_port->shadowMCR = mcr;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, mcr);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "setting MODEM_CONTROL_REGISTER Failed\n");\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mos7840_calc_baud_rate_divisor(struct usb_serial_port *port,\r\nint baudRate, int *divisor,\r\n__u16 *clk_sel_val)\r\n{\r\ndev_dbg(&port->dev, "%s - %d\n", __func__, baudRate);\r\nif (baudRate <= 115200) {\r\n*divisor = 115200 / baudRate;\r\n*clk_sel_val = 0x0;\r\n}\r\nif ((baudRate > 115200) && (baudRate <= 230400)) {\r\n*divisor = 230400 / baudRate;\r\n*clk_sel_val = 0x10;\r\n} else if ((baudRate > 230400) && (baudRate <= 403200)) {\r\n*divisor = 403200 / baudRate;\r\n*clk_sel_val = 0x20;\r\n} else if ((baudRate > 403200) && (baudRate <= 460800)) {\r\n*divisor = 460800 / baudRate;\r\n*clk_sel_val = 0x30;\r\n} else if ((baudRate > 460800) && (baudRate <= 806400)) {\r\n*divisor = 806400 / baudRate;\r\n*clk_sel_val = 0x40;\r\n} else if ((baudRate > 806400) && (baudRate <= 921600)) {\r\n*divisor = 921600 / baudRate;\r\n*clk_sel_val = 0x50;\r\n} else if ((baudRate > 921600) && (baudRate <= 1572864)) {\r\n*divisor = 1572864 / baudRate;\r\n*clk_sel_val = 0x60;\r\n} else if ((baudRate > 1572864) && (baudRate <= 3145728)) {\r\n*divisor = 3145728 / baudRate;\r\n*clk_sel_val = 0x70;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mos7840_send_cmd_write_baud_rate(struct moschip_port *mos7840_port,\r\nint baudRate)\r\n{\r\nint divisor = 0;\r\nint status;\r\n__u16 Data;\r\nunsigned char number;\r\n__u16 clk_sel_val;\r\nstruct usb_serial_port *port;\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\nport = mos7840_port->port;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn -1;\r\nif (mos7840_serial_paranoia_check(port->serial, __func__))\r\nreturn -1;\r\nnumber = mos7840_port->port->port_number;\r\ndev_dbg(&port->dev, "%s - baud = %d\n", __func__, baudRate);\r\nif (baudRate > 115200) {\r\n#ifdef HW_flow_control\r\nData = 0x2b;\r\nmos7840_port->shadowMCR = Data;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nData);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing spreg failed in set_serial_baud\n");\r\nreturn -1;\r\n}\r\n#endif\r\n} else {\r\n#ifdef HW_flow_control\r\nData = 0xb;\r\nmos7840_port->shadowMCR = Data;\r\nstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\r\nData);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing spreg failed in set_serial_baud\n");\r\nreturn -1;\r\n}\r\n#endif\r\n}\r\nif (1) {\r\nclk_sel_val = 0x0;\r\nData = 0x0;\r\nstatus = mos7840_calc_baud_rate_divisor(port, baudRate, &divisor,\r\n&clk_sel_val);\r\nstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset,\r\n&Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "reading spreg failed in set_serial_baud\n");\r\nreturn -1;\r\n}\r\nData = (Data & 0x8f) | clk_sel_val;\r\nstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset,\r\nData);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing spreg failed in set_serial_baud\n");\r\nreturn -1;\r\n}\r\nif (status) {\r\ndev_err(&port->dev, "%s - bad baud rate\n", __func__);\r\nreturn status;\r\n}\r\nData = mos7840_port->shadowLCR | SERIAL_LCR_DLAB;\r\nmos7840_port->shadowLCR = Data;\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nData = (unsigned char)(divisor & 0xff);\r\ndev_dbg(&port->dev, "set_serial_baud Value to write DLL is %x\n", Data);\r\nmos7840_set_uart_reg(port, DIVISOR_LATCH_LSB, Data);\r\nData = (unsigned char)((divisor & 0xff00) >> 8);\r\ndev_dbg(&port->dev, "set_serial_baud Value to write DLM is %x\n", Data);\r\nmos7840_set_uart_reg(port, DIVISOR_LATCH_MSB, Data);\r\nData = mos7840_port->shadowLCR & ~SERIAL_LCR_DLAB;\r\nmos7840_port->shadowLCR = Data;\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\n}\r\nreturn status;\r\n}\r\nstatic void mos7840_change_port_settings(struct tty_struct *tty,\r\nstruct moschip_port *mos7840_port, struct ktermios *old_termios)\r\n{\r\nint baud;\r\nunsigned cflag;\r\nunsigned iflag;\r\n__u8 lData;\r\n__u8 lParity;\r\n__u8 lStop;\r\nint status;\r\n__u16 Data;\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nif (mos7840_port == NULL)\r\nreturn;\r\nport = mos7840_port->port;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn;\r\nif (mos7840_serial_paranoia_check(port->serial, __func__))\r\nreturn;\r\nserial = port->serial;\r\nif (!mos7840_port->open) {\r\ndev_dbg(&port->dev, "%s - port not opened\n", __func__);\r\nreturn;\r\n}\r\nlData = LCR_BITS_8;\r\nlStop = LCR_STOP_1;\r\nlParity = LCR_PAR_NONE;\r\ncflag = tty->termios.c_cflag;\r\niflag = tty->termios.c_iflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nlData = LCR_BITS_5;\r\nbreak;\r\ncase CS6:\r\nlData = LCR_BITS_6;\r\nbreak;\r\ncase CS7:\r\nlData = LCR_BITS_7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nlData = LCR_BITS_8;\r\nbreak;\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD) {\r\nlParity = LCR_PAR_ODD;\r\ndev_dbg(&port->dev, "%s - parity = odd\n", __func__);\r\n} else {\r\nlParity = LCR_PAR_EVEN;\r\ndev_dbg(&port->dev, "%s - parity = even\n", __func__);\r\n}\r\n} else {\r\ndev_dbg(&port->dev, "%s - parity = none\n", __func__);\r\n}\r\nif (cflag & CMSPAR)\r\nlParity = lParity | 0x20;\r\nif (cflag & CSTOPB) {\r\nlStop = LCR_STOP_2;\r\ndev_dbg(&port->dev, "%s - stop bits = 2\n", __func__);\r\n} else {\r\nlStop = LCR_STOP_1;\r\ndev_dbg(&port->dev, "%s - stop bits = 1\n", __func__);\r\n}\r\nmos7840_port->shadowLCR &=\r\n~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\r\nmos7840_port->shadowLCR |= (lData | lParity | lStop);\r\ndev_dbg(&port->dev, "%s - mos7840_port->shadowLCR is %x\n", __func__,\r\nmos7840_port->shadowLCR);\r\nData = 0x00;\r\nmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nData = 0x00;\r\nmos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nData = 0xcf;\r\nmos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\r\nData = mos7840_port->shadowLCR;\r\nmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\r\nData = 0x00b;\r\nmos7840_port->shadowMCR = Data;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nData = 0x00b;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nmos7840_port->shadowMCR = MCR_MASTER_IE;\r\nif (cflag & CBAUD)\r\nmos7840_port->shadowMCR |= (MCR_DTR | MCR_RTS);\r\nif (cflag & CRTSCTS)\r\nmos7840_port->shadowMCR |= (MCR_XON_ANY);\r\nelse\r\nmos7840_port->shadowMCR &= ~(MCR_XON_ANY);\r\nData = mos7840_port->shadowMCR;\r\nmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud) {\r\ndev_dbg(&port->dev, "%s", "Picked default baud...\n");\r\nbaud = 9600;\r\n}\r\ndev_dbg(&port->dev, "%s - baud rate = %d\n", __func__, baud);\r\nstatus = mos7840_send_cmd_write_baud_rate(mos7840_port, baud);\r\nData = 0x0c;\r\nmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\r\nif (!mos7840_port->read_urb_busy) {\r\nmos7840_port->read_urb_busy = true;\r\nstatus = usb_submit_urb(mos7840_port->read_urb, GFP_KERNEL);\r\nif (status) {\r\ndev_dbg(&port->dev, "usb_submit_urb(read bulk) failed, status = %d\n",\r\nstatus);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\n}\r\ndev_dbg(&port->dev, "%s - mos7840_port->shadowLCR is End %x\n", __func__,\r\nmos7840_port->shadowLCR);\r\n}\r\nstatic void mos7840_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nint status;\r\nunsigned int cflag;\r\nstruct usb_serial *serial;\r\nstruct moschip_port *mos7840_port;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn;\r\nserial = port->serial;\r\nif (mos7840_serial_paranoia_check(serial, __func__))\r\nreturn;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn;\r\nif (!mos7840_port->open) {\r\ndev_dbg(&port->dev, "%s - port not opened\n", __func__);\r\nreturn;\r\n}\r\ndev_dbg(&port->dev, "%s", "setting termios - \n");\r\ncflag = tty->termios.c_cflag;\r\ndev_dbg(&port->dev, "%s - clfag %08x iflag %08x\n", __func__,\r\ntty->termios.c_cflag, RELEVANT_IFLAG(tty->termios.c_iflag));\r\ndev_dbg(&port->dev, "%s - old clfag %08x old iflag %08x\n", __func__,\r\nold_termios->c_cflag, RELEVANT_IFLAG(old_termios->c_iflag));\r\nmos7840_change_port_settings(tty, mos7840_port, old_termios);\r\nif (!mos7840_port->read_urb) {\r\ndev_dbg(&port->dev, "%s", "URB KILLED !!!!!\n");\r\nreturn;\r\n}\r\nif (!mos7840_port->read_urb_busy) {\r\nmos7840_port->read_urb_busy = true;\r\nstatus = usb_submit_urb(mos7840_port->read_urb, GFP_KERNEL);\r\nif (status) {\r\ndev_dbg(&port->dev, "usb_submit_urb(read bulk) failed, status = %d\n",\r\nstatus);\r\nmos7840_port->read_urb_busy = false;\r\n}\r\n}\r\n}\r\nstatic int mos7840_get_lsr_info(struct tty_struct *tty,\r\nunsigned int __user *value)\r\n{\r\nint count;\r\nunsigned int result = 0;\r\ncount = mos7840_chars_in_buffer(tty);\r\nif (count == 0)\r\nresult = TIOCSER_TEMT;\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7840_get_serial_info(struct moschip_port *mos7840_port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = mos7840_port->port->minor;\r\ntmp.port = mos7840_port->port->port_number;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = NUM_URBS * URB_TRANSFER_BUFFER_SIZE;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5 * HZ;\r\ntmp.closing_wait = 30 * HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mos7840_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct moschip_port *mos7840_port;\r\nif (mos7840_port_paranoia_check(port, __func__))\r\nreturn -1;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port == NULL)\r\nreturn -1;\r\nswitch (cmd) {\r\ncase TIOCSERGETLSR:\r\ndev_dbg(&port->dev, "%s TIOCSERGETLSR\n", __func__);\r\nreturn mos7840_get_lsr_info(tty, argp);\r\ncase TIOCGSERIAL:\r\ndev_dbg(&port->dev, "%s TIOCGSERIAL\n", __func__);\r\nreturn mos7840_get_serial_info(mos7840_port, argp);\r\ncase TIOCSSERIAL:\r\ndev_dbg(&port->dev, "%s TIOCSSERIAL\n", __func__);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int mos7810_check(struct usb_serial *serial)\r\n{\r\nint i, pass_count = 0;\r\nu8 *buf;\r\n__u16 data = 0, mcr_data = 0;\r\n__u16 test_pattern = 0x55AA;\r\nint res;\r\nbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nres = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nMCS_RDREQ, MCS_RD_RTYPE, 0x0300, MODEM_CONTROL_REGISTER,\r\nbuf, VENDOR_READ_LENGTH, MOS_WDR_TIMEOUT);\r\nif (res == VENDOR_READ_LENGTH)\r\nmcr_data = *buf;\r\nfor (i = 0; i < 16; i++) {\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nMCS_WRREQ, MCS_WR_RTYPE,\r\n(0x0300 | (((test_pattern >> i) & 0x0001) << 1)),\r\nMODEM_CONTROL_REGISTER, NULL, 0, MOS_WDR_TIMEOUT);\r\nres = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0), MCS_RDREQ,\r\nMCS_RD_RTYPE, 0, GPIO_REGISTER, buf,\r\nVENDOR_READ_LENGTH, MOS_WDR_TIMEOUT);\r\nif (res == VENDOR_READ_LENGTH)\r\ndata = *buf;\r\nif (((test_pattern >> i) ^ (~data >> 1)) & 0x0001)\r\nbreak;\r\npass_count++;\r\n}\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0), MCS_WRREQ,\r\nMCS_WR_RTYPE, 0x0300 | mcr_data, MODEM_CONTROL_REGISTER, NULL,\r\n0, MOS_WDR_TIMEOUT);\r\nkfree(buf);\r\nif (pass_count == 16)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mos7840_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nu16 product = le16_to_cpu(serial->dev->descriptor.idProduct);\r\nu8 *buf;\r\nint device_type;\r\nif (product == MOSCHIP_DEVICE_ID_7810 ||\r\nproduct == MOSCHIP_DEVICE_ID_7820) {\r\ndevice_type = product;\r\ngoto out;\r\n}\r\nbuf = kzalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nusb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nMCS_RDREQ, MCS_RD_RTYPE, 0, GPIO_REGISTER, buf,\r\nVENDOR_READ_LENGTH, MOS_WDR_TIMEOUT);\r\nif (buf[0] & 0x01)\r\ndevice_type = MOSCHIP_DEVICE_ID_7840;\r\nelse if (mos7810_check(serial))\r\ndevice_type = MOSCHIP_DEVICE_ID_7810;\r\nelse\r\ndevice_type = MOSCHIP_DEVICE_ID_7820;\r\nkfree(buf);\r\nout:\r\nusb_set_serial_data(serial, (void *)(unsigned long)device_type);\r\nreturn 0;\r\n}\r\nstatic int mos7840_calc_num_ports(struct usb_serial *serial)\r\n{\r\nint device_type = (unsigned long)usb_get_serial_data(serial);\r\nint mos7840_num_ports;\r\nmos7840_num_ports = (device_type >> 4) & 0x000F;\r\nreturn mos7840_num_ports;\r\n}\r\nstatic int mos7840_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nint device_type = (unsigned long)usb_get_serial_data(serial);\r\nstruct moschip_port *mos7840_port;\r\nint status;\r\nint pnum;\r\n__u16 Data;\r\npnum = port->port_number;\r\ndev_dbg(&port->dev, "mos7840_startup: configuring port %d\n", pnum);\r\nmos7840_port = kzalloc(sizeof(struct moschip_port), GFP_KERNEL);\r\nif (!mos7840_port)\r\nreturn -ENOMEM;\r\nmos7840_port->port = port;\r\nmos7840_set_port_private(port, mos7840_port);\r\nspin_lock_init(&mos7840_port->pool_lock);\r\nmos7840_port->port_num = pnum + 1;\r\ndev_dbg(&port->dev, "port->minor = %d\n", port->minor);\r\ndev_dbg(&port->dev, "mos7840_port->port_num = %d\n", mos7840_port->port_num);\r\nif (mos7840_port->port_num == 1) {\r\nmos7840_port->SpRegOffset = 0x0;\r\nmos7840_port->ControlRegOffset = 0x1;\r\nmos7840_port->DcrRegOffset = 0x4;\r\n} else if ((mos7840_port->port_num == 2) && (serial->num_ports == 4)) {\r\nmos7840_port->SpRegOffset = 0x8;\r\nmos7840_port->ControlRegOffset = 0x9;\r\nmos7840_port->DcrRegOffset = 0x16;\r\n} else if ((mos7840_port->port_num == 2) && (serial->num_ports == 2)) {\r\nmos7840_port->SpRegOffset = 0xa;\r\nmos7840_port->ControlRegOffset = 0xb;\r\nmos7840_port->DcrRegOffset = 0x19;\r\n} else if ((mos7840_port->port_num == 3) && (serial->num_ports == 4)) {\r\nmos7840_port->SpRegOffset = 0xa;\r\nmos7840_port->ControlRegOffset = 0xb;\r\nmos7840_port->DcrRegOffset = 0x19;\r\n} else if ((mos7840_port->port_num == 4) && (serial->num_ports == 4)) {\r\nmos7840_port->SpRegOffset = 0xc;\r\nmos7840_port->ControlRegOffset = 0xd;\r\nmos7840_port->DcrRegOffset = 0x1c;\r\n}\r\nmos7840_dump_serial_port(port, mos7840_port);\r\nmos7840_set_port_private(port, mos7840_port);\r\nstatus = mos7840_get_reg_sync(port,\r\nmos7840_port->ControlRegOffset, &Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Reading ControlReg failed status-0x%x\n", status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "ControlReg Reading success val is %x, status%d\n", Data, status);\r\nData |= 0x08;\r\nData |= 0x04;\r\nstatus = mos7840_set_reg_sync(port,\r\nmos7840_port->ControlRegOffset, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing ControlReg failed(rx_disable) status-0x%x\n", status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "ControlReg Writing success(rx_disable) status%d\n", status);\r\nData = 0x01;\r\nstatus = mos7840_set_reg_sync(port,\r\n(__u16) (mos7840_port->DcrRegOffset + 0), Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing DCR0 failed status-0x%x\n", status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "DCR0 Writing success status%d\n", status);\r\nData = 0x05;\r\nstatus = mos7840_set_reg_sync(port,\r\n(__u16) (mos7840_port->DcrRegOffset + 1), Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing DCR1 failed status-0x%x\n", status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "DCR1 Writing success status%d\n", status);\r\nData = 0x24;\r\nstatus = mos7840_set_reg_sync(port,\r\n(__u16) (mos7840_port->DcrRegOffset + 2), Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing DCR2 failed status-0x%x\n", status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "DCR2 Writing success status%d\n", status);\r\nData = 0x0;\r\nstatus = mos7840_set_reg_sync(port, CLK_START_VALUE_REGISTER, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing CLK_START_VALUE_REGISTER failed status-0x%x\n", status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "CLK_START_VALUE_REGISTER Writing success status%d\n", status);\r\nData = 0x20;\r\nstatus = mos7840_set_reg_sync(port, CLK_MULTI_REGISTER, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing CLK_MULTI_REGISTER failed status-0x%x\n", status);\r\ngoto error;\r\n} else\r\ndev_dbg(&port->dev, "CLK_MULTI_REGISTER Writing success status%d\n", status);\r\nData = 0x00;\r\nstatus = mos7840_set_uart_reg(port, SCRATCH_PAD_REGISTER, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing SCRATCH_PAD_REGISTER failed status-0x%x\n", status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "SCRATCH_PAD_REGISTER Writing success status%d\n", status);\r\nif ((mos7840_port->port_num != 1) && (serial->num_ports == 2)) {\r\nData = 0xff;\r\nstatus = mos7840_set_reg_sync(port,\r\n(__u16) (ZLP_REG1 +\r\n((__u16)mos7840_port->port_num)), Data);\r\ndev_dbg(&port->dev, "ZLIP offset %x\n",\r\n(__u16)(ZLP_REG1 + ((__u16) mos7840_port->port_num)));\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing ZLP_REG%d failed status-0x%x\n", pnum + 2, status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "ZLP_REG%d Writing success status%d\n", pnum + 2, status);\r\n} else {\r\nData = 0xff;\r\nstatus = mos7840_set_reg_sync(port,\r\n(__u16) (ZLP_REG1 +\r\n((__u16)mos7840_port->port_num) - 0x1), Data);\r\ndev_dbg(&port->dev, "ZLIP offset %x\n",\r\n(__u16)(ZLP_REG1 + ((__u16) mos7840_port->port_num) - 0x1));\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing ZLP_REG%d failed status-0x%x\n", pnum + 1, status);\r\ngoto out;\r\n} else\r\ndev_dbg(&port->dev, "ZLP_REG%d Writing success status%d\n", pnum + 1, status);\r\n}\r\nmos7840_port->control_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nmos7840_port->ctrl_buf = kmalloc(16, GFP_KERNEL);\r\nmos7840_port->dr = kmalloc(sizeof(struct usb_ctrlrequest),\r\nGFP_KERNEL);\r\nif (!mos7840_port->control_urb || !mos7840_port->ctrl_buf ||\r\n!mos7840_port->dr) {\r\nstatus = -ENOMEM;\r\ngoto error;\r\n}\r\nmos7840_port->has_led = false;\r\nif (device_type == MOSCHIP_DEVICE_ID_7810) {\r\nmos7840_port->has_led = true;\r\nmos7840_port->led_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nmos7840_port->led_dr = kmalloc(sizeof(*mos7840_port->led_dr),\r\nGFP_KERNEL);\r\nif (!mos7840_port->led_urb || !mos7840_port->led_dr) {\r\nstatus = -ENOMEM;\r\ngoto error;\r\n}\r\nsetup_timer(&mos7840_port->led_timer1, mos7840_led_off,\r\n(unsigned long)mos7840_port);\r\nmos7840_port->led_timer1.expires =\r\njiffies + msecs_to_jiffies(LED_ON_MS);\r\nsetup_timer(&mos7840_port->led_timer2, mos7840_led_flag_off,\r\n(unsigned long)mos7840_port);\r\nmos7840_port->led_timer2.expires =\r\njiffies + msecs_to_jiffies(LED_OFF_MS);\r\nmos7840_set_led_sync(port, MODEM_CONTROL_REGISTER, 0x0300);\r\n}\r\nout:\r\nif (pnum == serial->num_ports - 1) {\r\nData = 0x0f;\r\nstatus = mos7840_set_reg_sync(serial->port[0], ZLP_REG5, Data);\r\nif (status < 0) {\r\ndev_dbg(&port->dev, "Writing ZLP_REG5 failed status-0x%x\n", status);\r\ngoto error;\r\n} else\r\ndev_dbg(&port->dev, "ZLP_REG5 Writing success status%d\n", status);\r\nusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n0x03, 0x00, 0x01, 0x00, NULL, 0x00,\r\nMOS_WDR_TIMEOUT);\r\n}\r\nreturn 0;\r\nerror:\r\nkfree(mos7840_port->led_dr);\r\nusb_free_urb(mos7840_port->led_urb);\r\nkfree(mos7840_port->dr);\r\nkfree(mos7840_port->ctrl_buf);\r\nusb_free_urb(mos7840_port->control_urb);\r\nkfree(mos7840_port);\r\nreturn status;\r\n}\r\nstatic int mos7840_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct moschip_port *mos7840_port;\r\nmos7840_port = mos7840_get_port_private(port);\r\nif (mos7840_port->has_led) {\r\nmos7840_set_led_sync(port, MODEM_CONTROL_REGISTER, 0x0300);\r\ndel_timer_sync(&mos7840_port->led_timer1);\r\ndel_timer_sync(&mos7840_port->led_timer2);\r\nusb_kill_urb(mos7840_port->led_urb);\r\nusb_free_urb(mos7840_port->led_urb);\r\nkfree(mos7840_port->led_dr);\r\n}\r\nusb_kill_urb(mos7840_port->control_urb);\r\nusb_free_urb(mos7840_port->control_urb);\r\nkfree(mos7840_port->ctrl_buf);\r\nkfree(mos7840_port->dr);\r\nkfree(mos7840_port);\r\nreturn 0;\r\n}
