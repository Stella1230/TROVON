static int snooze_loop(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nu64 snooze_exit_time;\r\nlocal_irq_enable();\r\nset_thread_flag(TIF_POLLING_NRFLAG);\r\nsnooze_exit_time = get_tb() + snooze_timeout;\r\nppc64_runlatch_off();\r\nwhile (!need_resched()) {\r\nHMT_low();\r\nHMT_very_low();\r\nif (snooze_timeout_en && get_tb() > snooze_exit_time)\r\nbreak;\r\n}\r\nHMT_medium();\r\nppc64_runlatch_on();\r\nclear_thread_flag(TIF_POLLING_NRFLAG);\r\nsmp_mb();\r\nreturn index;\r\n}\r\nstatic int nap_loop(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nppc64_runlatch_off();\r\npower7_idle();\r\nppc64_runlatch_on();\r\nreturn index;\r\n}\r\nstatic int fastsleep_loop(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nunsigned long old_lpcr = mfspr(SPRN_LPCR);\r\nunsigned long new_lpcr;\r\nif (unlikely(system_state < SYSTEM_RUNNING))\r\nreturn index;\r\nnew_lpcr = old_lpcr;\r\nnew_lpcr &= ~LPCR_PECE1;\r\nmtspr(SPRN_LPCR, new_lpcr);\r\npower7_sleep();\r\nmtspr(SPRN_LPCR, old_lpcr);\r\nreturn index;\r\n}\r\nstatic int powernv_cpuidle_add_cpu_notifier(struct notifier_block *n,\r\nunsigned long action, void *hcpu)\r\n{\r\nint hotcpu = (unsigned long)hcpu;\r\nstruct cpuidle_device *dev =\r\nper_cpu(cpuidle_devices, hotcpu);\r\nif (dev && cpuidle_get_driver()) {\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\ncpuidle_pause_and_lock();\r\ncpuidle_enable_device(dev);\r\ncpuidle_resume_and_unlock();\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\ncpuidle_pause_and_lock();\r\ncpuidle_disable_device(dev);\r\ncpuidle_resume_and_unlock();\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int powernv_cpuidle_driver_init(void)\r\n{\r\nint idle_state;\r\nstruct cpuidle_driver *drv = &powernv_idle_driver;\r\ndrv->state_count = 0;\r\nfor (idle_state = 0; idle_state < max_idle_state; ++idle_state) {\r\nif (cpuidle_state_table[idle_state].enter == NULL)\r\ncontinue;\r\ndrv->states[drv->state_count] =\r\ncpuidle_state_table[idle_state];\r\ndrv->state_count += 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int powernv_add_idle_states(void)\r\n{\r\nstruct device_node *power_mgt;\r\nint nr_idle_states = 1;\r\nint dt_idle_states;\r\nu32 *latency_ns, *residency_ns, *flags;\r\nint i, rc;\r\npower_mgt = of_find_node_by_path("/ibm,opal/power-mgt");\r\nif (!power_mgt) {\r\npr_warn("opal: PowerMgmt Node not found\n");\r\ngoto out;\r\n}\r\ndt_idle_states = of_property_count_u32_elems(power_mgt, "ibm,cpu-idle-state-flags");\r\nif (dt_idle_states < 0) {\r\npr_warn("cpuidle-powernv: no idle states found in the DT\n");\r\ngoto out;\r\n}\r\nflags = kzalloc(sizeof(*flags) * dt_idle_states, GFP_KERNEL);\r\nif (of_property_read_u32_array(power_mgt,\r\n"ibm,cpu-idle-state-flags", flags, dt_idle_states)) {\r\npr_warn("cpuidle-powernv : missing ibm,cpu-idle-state-flags in DT\n");\r\ngoto out_free_flags;\r\n}\r\nlatency_ns = kzalloc(sizeof(*latency_ns) * dt_idle_states, GFP_KERNEL);\r\nrc = of_property_read_u32_array(power_mgt,\r\n"ibm,cpu-idle-state-latencies-ns", latency_ns, dt_idle_states);\r\nif (rc) {\r\npr_warn("cpuidle-powernv: missing ibm,cpu-idle-state-latencies-ns in DT\n");\r\ngoto out_free_latency;\r\n}\r\nresidency_ns = kzalloc(sizeof(*residency_ns) * dt_idle_states, GFP_KERNEL);\r\nrc = of_property_read_u32_array(power_mgt,\r\n"ibm,cpu-idle-state-residency-ns", residency_ns, dt_idle_states);\r\nfor (i = 0; i < dt_idle_states; i++) {\r\nif (flags[i] & OPAL_PM_NAP_ENABLED) {\r\nstrcpy(powernv_states[nr_idle_states].name, "Nap");\r\nstrcpy(powernv_states[nr_idle_states].desc, "Nap");\r\npowernv_states[nr_idle_states].flags = 0;\r\npowernv_states[nr_idle_states].target_residency = 100;\r\npowernv_states[nr_idle_states].enter = &nap_loop;\r\n}\r\n#ifdef CONFIG_TICK_ONESHOT\r\nif (flags[i] & OPAL_PM_SLEEP_ENABLED ||\r\nflags[i] & OPAL_PM_SLEEP_ENABLED_ER1) {\r\nstrcpy(powernv_states[nr_idle_states].name, "FastSleep");\r\nstrcpy(powernv_states[nr_idle_states].desc, "FastSleep");\r\npowernv_states[nr_idle_states].flags = CPUIDLE_FLAG_TIMER_STOP;\r\npowernv_states[nr_idle_states].target_residency = 300000;\r\npowernv_states[nr_idle_states].enter = &fastsleep_loop;\r\n}\r\n#endif\r\npowernv_states[nr_idle_states].exit_latency =\r\n((unsigned int)latency_ns[i]) / 1000;\r\nif (!rc) {\r\npowernv_states[nr_idle_states].target_residency =\r\n((unsigned int)residency_ns[i]) / 1000;\r\n}\r\nnr_idle_states++;\r\n}\r\nkfree(residency_ns);\r\nout_free_latency:\r\nkfree(latency_ns);\r\nout_free_flags:\r\nkfree(flags);\r\nout:\r\nreturn nr_idle_states;\r\n}\r\nstatic int powernv_idle_probe(void)\r\n{\r\nif (cpuidle_disable != IDLE_NO_OVERRIDE)\r\nreturn -ENODEV;\r\nif (firmware_has_feature(FW_FEATURE_OPAL)) {\r\ncpuidle_state_table = powernv_states;\r\nmax_idle_state = powernv_add_idle_states();\r\nif (max_idle_state > 1) {\r\nsnooze_timeout_en = true;\r\nsnooze_timeout = powernv_states[1].target_residency *\r\ntb_ticks_per_usec;\r\n}\r\n} else\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __init powernv_processor_idle_init(void)\r\n{\r\nint retval;\r\nretval = powernv_idle_probe();\r\nif (retval)\r\nreturn retval;\r\npowernv_cpuidle_driver_init();\r\nretval = cpuidle_register(&powernv_idle_driver, NULL);\r\nif (retval) {\r\nprintk(KERN_DEBUG "Registration of powernv driver failed.\n");\r\nreturn retval;\r\n}\r\nregister_cpu_notifier(&setup_hotplug_notifier);\r\nprintk(KERN_DEBUG "powernv_idle_driver registered\n");\r\nreturn 0;\r\n}
