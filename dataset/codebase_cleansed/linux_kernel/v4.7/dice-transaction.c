static u64 get_subaddr(struct snd_dice *dice, enum snd_dice_addr_type type,\r\nu64 offset)\r\n{\r\nswitch (type) {\r\ncase SND_DICE_ADDR_TYPE_TX:\r\noffset += dice->tx_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_RX:\r\noffset += dice->rx_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_SYNC:\r\noffset += dice->sync_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_RSRV:\r\noffset += dice->rsrv_offset;\r\nbreak;\r\ncase SND_DICE_ADDR_TYPE_GLOBAL:\r\ndefault:\r\noffset += dice->global_offset;\r\nbreak;\r\n}\r\noffset += DICE_PRIVATE_SPACE;\r\nreturn offset;\r\n}\r\nint snd_dice_transaction_write(struct snd_dice *dice,\r\nenum snd_dice_addr_type type,\r\nunsigned int offset, void *buf, unsigned int len)\r\n{\r\nreturn snd_fw_transaction(dice->unit,\r\n(len == 4) ? TCODE_WRITE_QUADLET_REQUEST :\r\nTCODE_WRITE_BLOCK_REQUEST,\r\nget_subaddr(dice, type, offset), buf, len, 0);\r\n}\r\nint snd_dice_transaction_read(struct snd_dice *dice,\r\nenum snd_dice_addr_type type, unsigned int offset,\r\nvoid *buf, unsigned int len)\r\n{\r\nreturn snd_fw_transaction(dice->unit,\r\n(len == 4) ? TCODE_READ_QUADLET_REQUEST :\r\nTCODE_READ_BLOCK_REQUEST,\r\nget_subaddr(dice, type, offset), buf, len, 0);\r\n}\r\nstatic unsigned int get_clock_info(struct snd_dice *dice, __be32 *info)\r\n{\r\nreturn snd_dice_transaction_read_global(dice, GLOBAL_CLOCK_SELECT,\r\ninfo, 4);\r\n}\r\nint snd_dice_transaction_get_clock_source(struct snd_dice *dice,\r\nunsigned int *source)\r\n{\r\n__be32 info;\r\nint err;\r\nerr = get_clock_info(dice, &info);\r\nif (err >= 0)\r\n*source = be32_to_cpu(info) & CLOCK_SOURCE_MASK;\r\nreturn err;\r\n}\r\nint snd_dice_transaction_get_rate(struct snd_dice *dice, unsigned int *rate)\r\n{\r\n__be32 info;\r\nunsigned int index;\r\nint err;\r\nerr = get_clock_info(dice, &info);\r\nif (err < 0)\r\ngoto end;\r\nindex = (be32_to_cpu(info) & CLOCK_RATE_MASK) >> CLOCK_RATE_SHIFT;\r\nif (index >= SND_DICE_RATES_COUNT) {\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\n*rate = snd_dice_rates[index];\r\nend:\r\nreturn err;\r\n}\r\nint snd_dice_transaction_set_enable(struct snd_dice *dice)\r\n{\r\n__be32 value;\r\nint err = 0;\r\nif (dice->global_enabled)\r\ngoto end;\r\nvalue = cpu_to_be32(1);\r\nerr = snd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nget_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_ENABLE),\r\n&value, 4,\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\nif (err < 0)\r\ngoto end;\r\ndice->global_enabled = true;\r\nend:\r\nreturn err;\r\n}\r\nvoid snd_dice_transaction_clear_enable(struct snd_dice *dice)\r\n{\r\n__be32 value;\r\nvalue = 0;\r\nsnd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nget_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_ENABLE),\r\n&value, 4, FW_QUIET |\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\ndice->global_enabled = false;\r\n}\r\nstatic void dice_notification(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct snd_dice *dice = callback_data;\r\nu32 bits;\r\nunsigned long flags;\r\nif (tcode != TCODE_WRITE_QUADLET_REQUEST) {\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\nreturn;\r\n}\r\nif ((offset & 3) != 0) {\r\nfw_send_response(card, request, RCODE_ADDRESS_ERROR);\r\nreturn;\r\n}\r\nbits = be32_to_cpup(data);\r\nspin_lock_irqsave(&dice->lock, flags);\r\ndice->notification_bits |= bits;\r\nspin_unlock_irqrestore(&dice->lock, flags);\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\nif (bits & NOTIFY_LOCK_CHG)\r\ncomplete(&dice->clock_accepted);\r\nwake_up(&dice->hwdep_wait);\r\n}\r\nstatic int register_notification_address(struct snd_dice *dice, bool retry)\r\n{\r\nstruct fw_device *device = fw_parent_device(dice->unit);\r\n__be64 *buffer;\r\nunsigned int retries;\r\nint err;\r\nretries = (retry) ? 3 : 0;\r\nbuffer = kmalloc(2 * 8, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nfor (;;) {\r\nbuffer[0] = cpu_to_be64(OWNER_NO_OWNER);\r\nbuffer[1] = cpu_to_be64(\r\n((u64)device->card->node_id << OWNER_NODE_SHIFT) |\r\ndice->notification_handler.offset);\r\ndice->owner_generation = device->generation;\r\nsmp_rmb();\r\nerr = snd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\r\nget_subaddr(dice,\r\nSND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_OWNER),\r\nbuffer, 2 * 8,\r\nFW_FIXED_GENERATION |\r\ndice->owner_generation);\r\nif (err == 0) {\r\nif (buffer[0] == cpu_to_be64(OWNER_NO_OWNER))\r\nbreak;\r\nif (buffer[0] == buffer[1])\r\nbreak;\r\ndev_err(&dice->unit->device,\r\n"device is already in use\n");\r\nerr = -EBUSY;\r\n}\r\nif (err != -EAGAIN || retries-- > 0)\r\nbreak;\r\nmsleep(20);\r\n}\r\nkfree(buffer);\r\nif (err < 0)\r\ndice->owner_generation = -1;\r\nreturn err;\r\n}\r\nstatic void unregister_notification_address(struct snd_dice *dice)\r\n{\r\nstruct fw_device *device = fw_parent_device(dice->unit);\r\n__be64 *buffer;\r\nbuffer = kmalloc(2 * 8, GFP_KERNEL);\r\nif (buffer == NULL)\r\nreturn;\r\nbuffer[0] = cpu_to_be64(\r\n((u64)device->card->node_id << OWNER_NODE_SHIFT) |\r\ndice->notification_handler.offset);\r\nbuffer[1] = cpu_to_be64(OWNER_NO_OWNER);\r\nsnd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\r\nget_subaddr(dice, SND_DICE_ADDR_TYPE_GLOBAL,\r\nGLOBAL_OWNER),\r\nbuffer, 2 * 8, FW_QUIET |\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\nkfree(buffer);\r\ndice->owner_generation = -1;\r\n}\r\nvoid snd_dice_transaction_destroy(struct snd_dice *dice)\r\n{\r\nstruct fw_address_handler *handler = &dice->notification_handler;\r\nif (handler->callback_data == NULL)\r\nreturn;\r\nunregister_notification_address(dice);\r\nfw_core_remove_address_handler(handler);\r\nhandler->callback_data = NULL;\r\n}\r\nint snd_dice_transaction_reinit(struct snd_dice *dice)\r\n{\r\nstruct fw_address_handler *handler = &dice->notification_handler;\r\nif (handler->callback_data == NULL)\r\nreturn -EINVAL;\r\nreturn register_notification_address(dice, false);\r\n}\r\nstatic int get_subaddrs(struct snd_dice *dice)\r\n{\r\nstatic const int min_values[10] = {\r\n10, 0x64 / 4,\r\n10, 0x18 / 4,\r\n10, 0x18 / 4,\r\n0, 0,\r\n0, 0,\r\n};\r\n__be32 *pointers;\r\n__be32 version;\r\nu32 data;\r\nunsigned int i;\r\nint err;\r\npointers = kmalloc_array(ARRAY_SIZE(min_values), sizeof(__be32),\r\nGFP_KERNEL);\r\nif (pointers == NULL)\r\nreturn -ENOMEM;\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE, pointers,\r\nsizeof(__be32) * ARRAY_SIZE(min_values), 0);\r\nif (err < 0)\r\ngoto end;\r\nfor (i = 0; i < ARRAY_SIZE(min_values); ++i) {\r\ndata = be32_to_cpu(pointers[i]);\r\nif (data < min_values[i] || data >= 0x40000) {\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\n}\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_QUADLET_REQUEST,\r\nDICE_PRIVATE_SPACE +\r\nbe32_to_cpu(pointers[0]) * 4 + GLOBAL_VERSION,\r\n&version, sizeof(version), 0);\r\nif (err < 0)\r\ngoto end;\r\nif ((version & cpu_to_be32(0xff000000)) != cpu_to_be32(0x01000000)) {\r\ndev_err(&dice->unit->device,\r\n"unknown DICE version: 0x%08x\n", be32_to_cpu(version));\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\ndice->global_offset = be32_to_cpu(pointers[0]) * 4;\r\ndice->tx_offset = be32_to_cpu(pointers[2]) * 4;\r\ndice->rx_offset = be32_to_cpu(pointers[4]) * 4;\r\ndice->sync_offset = be32_to_cpu(pointers[6]) * 4;\r\ndice->rsrv_offset = be32_to_cpu(pointers[8]) * 4;\r\nif (be32_to_cpu(pointers[1]) * 4 >= GLOBAL_CLOCK_CAPABILITIES + 4)\r\ndice->clock_caps = 1;\r\nend:\r\nkfree(pointers);\r\nreturn err;\r\n}\r\nint snd_dice_transaction_init(struct snd_dice *dice)\r\n{\r\nstruct fw_address_handler *handler = &dice->notification_handler;\r\nint err;\r\nerr = get_subaddrs(dice);\r\nif (err < 0)\r\nreturn err;\r\nhandler->length = 4;\r\nhandler->address_callback = dice_notification;\r\nhandler->callback_data = dice;\r\nerr = fw_core_add_address_handler(handler, &fw_high_memory_region);\r\nif (err < 0) {\r\nhandler->callback_data = NULL;\r\nreturn err;\r\n}\r\nerr = register_notification_address(dice, true);\r\nif (err < 0) {\r\nfw_core_remove_address_handler(handler);\r\nhandler->callback_data = NULL;\r\n}\r\nreturn err;\r\n}
