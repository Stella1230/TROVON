static struct lola_pcm *lola_get_pcm(struct snd_pcm_substream *substream)\r\n{\r\nstruct lola *chip = snd_pcm_substream_chip(substream);\r\nreturn &chip->pcm[substream->stream];\r\n}\r\nstatic struct lola_stream *lola_get_stream(struct snd_pcm_substream *substream)\r\n{\r\nstruct lola_pcm *pcm = lola_get_pcm(substream);\r\nunsigned int idx = substream->number;\r\nreturn &pcm->streams[idx];\r\n}\r\nstatic unsigned int lola_get_lrc(struct lola *chip)\r\n{\r\nreturn lola_readl(chip, BAR1, LRC);\r\n}\r\nstatic unsigned int lola_get_tstamp(struct lola *chip, bool quick_no_sync)\r\n{\r\nunsigned int tstamp = lola_get_lrc(chip) >> 8;\r\nif (chip->granularity) {\r\nunsigned int wait_banks = quick_no_sync ? 0 : 8;\r\ntstamp += (wait_banks + 1) * chip->granularity - 1;\r\ntstamp -= tstamp % chip->granularity;\r\n}\r\nreturn tstamp << 8;\r\n}\r\nstatic void lola_stream_clear_pending_irq(struct lola *chip,\r\nstruct lola_stream *str)\r\n{\r\nunsigned int val = lola_dsd_read(chip, str->dsd, STS);\r\nval &= LOLA_DSD_STS_DESE | LOLA_DSD_STS_BCIS;\r\nif (val)\r\nlola_dsd_write(chip, str->dsd, STS, val);\r\n}\r\nstatic void lola_stream_start(struct lola *chip, struct lola_stream *str,\r\nunsigned int tstamp)\r\n{\r\nlola_stream_clear_pending_irq(chip, str);\r\nlola_dsd_write(chip, str->dsd, CTL,\r\nLOLA_DSD_CTL_SRUN |\r\nLOLA_DSD_CTL_IOCE |\r\nLOLA_DSD_CTL_DEIE |\r\nLOLA_DSD_CTL_VLRCV |\r\ntstamp);\r\n}\r\nstatic void lola_stream_stop(struct lola *chip, struct lola_stream *str,\r\nunsigned int tstamp)\r\n{\r\nlola_dsd_write(chip, str->dsd, CTL,\r\nLOLA_DSD_CTL_IOCE |\r\nLOLA_DSD_CTL_DEIE |\r\nLOLA_DSD_CTL_VLRCV |\r\ntstamp);\r\nlola_stream_clear_pending_irq(chip, str);\r\n}\r\nstatic void wait_for_srst_clear(struct lola *chip, struct lola_stream *str)\r\n{\r\nunsigned long end_time = jiffies + msecs_to_jiffies(200);\r\nwhile (time_before(jiffies, end_time)) {\r\nunsigned int val;\r\nval = lola_dsd_read(chip, str->dsd, CTL);\r\nif (!(val & LOLA_DSD_CTL_SRST))\r\nreturn;\r\nmsleep(1);\r\n}\r\ndev_warn(chip->card->dev, "SRST not clear (stream %d)\n", str->dsd);\r\n}\r\nstatic int lola_stream_wait_for_fifo(struct lola *chip,\r\nstruct lola_stream *str,\r\nbool ready)\r\n{\r\nunsigned int val = ready ? LOLA_DSD_STS_FIFORDY : 0;\r\nunsigned long end_time = jiffies + msecs_to_jiffies(200);\r\nwhile (time_before(jiffies, end_time)) {\r\nunsigned int reg = lola_dsd_read(chip, str->dsd, STS);\r\nif ((reg & LOLA_DSD_STS_FIFORDY) == val)\r\nreturn 0;\r\nmsleep(1);\r\n}\r\ndev_warn(chip->card->dev, "FIFO not ready (stream %d)\n", str->dsd);\r\nreturn -EIO;\r\n}\r\nstatic int lola_sync_wait_for_fifo(struct lola *chip,\r\nstruct snd_pcm_substream *substream,\r\nbool ready)\r\n{\r\nunsigned int val = ready ? LOLA_DSD_STS_FIFORDY : 0;\r\nunsigned long end_time = jiffies + msecs_to_jiffies(200);\r\nstruct snd_pcm_substream *s;\r\nint pending = 0;\r\nwhile (time_before(jiffies, end_time)) {\r\npending = 0;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nstruct lola_stream *str;\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nstr = lola_get_stream(s);\r\nif (str->prepared && str->paused) {\r\nunsigned int reg;\r\nreg = lola_dsd_read(chip, str->dsd, STS);\r\nif ((reg & LOLA_DSD_STS_FIFORDY) != val) {\r\npending = str->dsd + 1;\r\nbreak;\r\n}\r\nif (ready)\r\nstr->paused = 0;\r\n}\r\n}\r\nif (!pending)\r\nreturn 0;\r\nmsleep(1);\r\n}\r\ndev_warn(chip->card->dev, "FIFO not ready (pending %d)\n", pending - 1);\r\nreturn -EIO;\r\n}\r\nstatic void lola_sync_pause(struct lola *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_substream *s;\r\nlola_sync_wait_for_fifo(chip, substream, false);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nstruct lola_stream *str;\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nstr = lola_get_stream(s);\r\nif (str->paused && str->prepared)\r\nlola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRUN |\r\nLOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);\r\n}\r\nlola_sync_wait_for_fifo(chip, substream, true);\r\n}\r\nstatic void lola_stream_reset(struct lola *chip, struct lola_stream *str)\r\n{\r\nif (str->prepared) {\r\nif (str->paused)\r\nlola_sync_pause(chip, str->substream);\r\nstr->prepared = 0;\r\nlola_dsd_write(chip, str->dsd, CTL,\r\nLOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE);\r\nlola_stream_wait_for_fifo(chip, str, false);\r\nlola_stream_clear_pending_irq(chip, str);\r\nlola_dsd_write(chip, str->dsd, CTL, LOLA_DSD_CTL_SRST);\r\nlola_dsd_write(chip, str->dsd, LVI, 0);\r\nlola_dsd_write(chip, str->dsd, BDPU, 0);\r\nlola_dsd_write(chip, str->dsd, BDPL, 0);\r\nwait_for_srst_clear(chip, str);\r\n}\r\n}\r\nstatic int lola_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct lola *chip = snd_pcm_substream_chip(substream);\r\nstruct lola_pcm *pcm = lola_get_pcm(substream);\r\nstruct lola_stream *str = lola_get_stream(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nmutex_lock(&chip->open_mutex);\r\nif (str->opened) {\r\nmutex_unlock(&chip->open_mutex);\r\nreturn -EBUSY;\r\n}\r\nstr->substream = substream;\r\nstr->master = NULL;\r\nstr->opened = 1;\r\nruntime->hw = lola_pcm_hw;\r\nruntime->hw.channels_max = pcm->num_streams - str->index;\r\nif (chip->sample_rate) {\r\nruntime->hw.rate_min = chip->sample_rate;\r\nruntime->hw.rate_max = chip->sample_rate;\r\n} else {\r\nruntime->hw.rate_min = chip->sample_rate_min;\r\nruntime->hw.rate_max = chip->sample_rate_max;\r\n}\r\nchip->ref_count_rate++;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\nchip->granularity);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\nchip->granularity);\r\nmutex_unlock(&chip->open_mutex);\r\nreturn 0;\r\n}\r\nstatic void lola_cleanup_slave_streams(struct lola_pcm *pcm,\r\nstruct lola_stream *str)\r\n{\r\nint i;\r\nfor (i = str->index + 1; i < pcm->num_streams; i++) {\r\nstruct lola_stream *s = &pcm->streams[i];\r\nif (s->master != str)\r\nbreak;\r\ns->master = NULL;\r\ns->opened = 0;\r\n}\r\n}\r\nstatic int lola_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct lola *chip = snd_pcm_substream_chip(substream);\r\nstruct lola_stream *str = lola_get_stream(substream);\r\nmutex_lock(&chip->open_mutex);\r\nif (str->substream == substream) {\r\nstr->substream = NULL;\r\nstr->opened = 0;\r\n}\r\nif (--chip->ref_count_rate == 0) {\r\nchip->sample_rate = 0;\r\n}\r\nmutex_unlock(&chip->open_mutex);\r\nreturn 0;\r\n}\r\nstatic int lola_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct lola_stream *str = lola_get_stream(substream);\r\nstr->bufsize = 0;\r\nstr->period_bytes = 0;\r\nstr->format_verb = 0;\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int lola_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct lola *chip = snd_pcm_substream_chip(substream);\r\nstruct lola_pcm *pcm = lola_get_pcm(substream);\r\nstruct lola_stream *str = lola_get_stream(substream);\r\nmutex_lock(&chip->open_mutex);\r\nlola_stream_reset(chip, str);\r\nlola_cleanup_slave_streams(pcm, str);\r\nmutex_unlock(&chip->open_mutex);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int setup_bdle(struct snd_pcm_substream *substream,\r\nstruct lola_stream *str, u32 **bdlp,\r\nint ofs, int size)\r\n{\r\nu32 *bdl = *bdlp;\r\nwhile (size > 0) {\r\ndma_addr_t addr;\r\nint chunk;\r\nif (str->frags >= LOLA_MAX_BDL_ENTRIES)\r\nreturn -EINVAL;\r\naddr = snd_pcm_sgbuf_get_addr(substream, ofs);\r\nbdl[0] = cpu_to_le32((u32)addr);\r\nbdl[1] = cpu_to_le32(upper_32_bits(addr));\r\nchunk = snd_pcm_sgbuf_get_chunk_size(substream, ofs, size);\r\nbdl[2] = cpu_to_le32(chunk);\r\nsize -= chunk;\r\nbdl[3] = size ? 0 : cpu_to_le32(0x01);\r\nbdl += 4;\r\nstr->frags++;\r\nofs += chunk;\r\n}\r\n*bdlp = bdl;\r\nreturn ofs;\r\n}\r\nstatic int lola_setup_periods(struct lola *chip, struct lola_pcm *pcm,\r\nstruct snd_pcm_substream *substream,\r\nstruct lola_stream *str)\r\n{\r\nu32 *bdl;\r\nint i, ofs, periods, period_bytes;\r\nperiod_bytes = str->period_bytes;\r\nperiods = str->bufsize / period_bytes;\r\nbdl = (u32 *)(pcm->bdl.area + LOLA_BDL_ENTRY_SIZE * str->index);\r\nofs = 0;\r\nstr->frags = 0;\r\nfor (i = 0; i < periods; i++) {\r\nofs = setup_bdle(substream, str, &bdl, ofs, period_bytes);\r\nif (ofs < 0)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\ndev_err(chip->card->dev, "Too many BDL entries: buffer=%d, period=%d\n",\r\nstr->bufsize, period_bytes);\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int lola_get_format_verb(struct snd_pcm_substream *substream)\r\n{\r\nunsigned int verb;\r\nswitch (substream->runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nverb = 0x00000000;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nverb = 0x00000200;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nverb = 0x00000300;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_FLOAT_LE:\r\nverb = 0x00001300;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nverb |= substream->runtime->channels;\r\nreturn verb;\r\n}\r\nstatic int lola_set_stream_config(struct lola *chip,\r\nstruct lola_stream *str,\r\nint channels)\r\n{\r\nint i, err;\r\nunsigned int verb, val;\r\nerr = lola_codec_read(chip, str->nid, LOLA_VERB_SET_STREAM_FORMAT,\r\nstr->format_verb, 0, &val, NULL);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "Cannot set stream format 0x%x\n",\r\nstr->format_verb);\r\nreturn err;\r\n}\r\nfor (i = 0; i < channels; i++) {\r\nverb = (str->index << 6) | i;\r\nerr = lola_codec_read(chip, str[i].nid,\r\nLOLA_VERB_SET_CHANNEL_STREAMID, 0, verb,\r\n&val, NULL);\r\nif (err < 0) {\r\ndev_err(chip->card->dev,\r\n"Cannot set stream channel %d\n", i);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lola_setup_controller(struct lola *chip, struct lola_pcm *pcm,\r\nstruct lola_stream *str)\r\n{\r\ndma_addr_t bdl;\r\nif (str->prepared)\r\nreturn -EINVAL;\r\nbdl = pcm->bdl.addr + LOLA_BDL_ENTRY_SIZE * str->index;\r\nlola_dsd_write(chip, str->dsd, BDPL, (u32)bdl);\r\nlola_dsd_write(chip, str->dsd, BDPU, upper_32_bits(bdl));\r\nlola_dsd_write(chip, str->dsd, LVI, str->frags - 1);\r\nlola_stream_clear_pending_irq(chip, str);\r\nlola_dsd_write(chip, str->dsd, CTL,\r\nLOLA_DSD_CTL_IOCE | LOLA_DSD_CTL_DEIE | LOLA_DSD_CTL_SRUN);\r\nstr->prepared = 1;\r\nreturn lola_stream_wait_for_fifo(chip, str, true);\r\n}\r\nstatic int lola_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct lola *chip = snd_pcm_substream_chip(substream);\r\nstruct lola_pcm *pcm = lola_get_pcm(substream);\r\nstruct lola_stream *str = lola_get_stream(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int bufsize, period_bytes, format_verb;\r\nint i, err;\r\nmutex_lock(&chip->open_mutex);\r\nlola_stream_reset(chip, str);\r\nlola_cleanup_slave_streams(pcm, str);\r\nif (str->index + runtime->channels > pcm->num_streams) {\r\nmutex_unlock(&chip->open_mutex);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i < runtime->channels; i++) {\r\nstr[i].master = str;\r\nstr[i].opened = 1;\r\n}\r\nmutex_unlock(&chip->open_mutex);\r\nbufsize = snd_pcm_lib_buffer_bytes(substream);\r\nperiod_bytes = snd_pcm_lib_period_bytes(substream);\r\nformat_verb = lola_get_format_verb(substream);\r\nstr->bufsize = bufsize;\r\nstr->period_bytes = period_bytes;\r\nstr->format_verb = format_verb;\r\nerr = lola_setup_periods(chip, pcm, substream, str);\r\nif (err < 0)\r\nreturn err;\r\nerr = lola_set_sample_rate(chip, runtime->rate);\r\nif (err < 0)\r\nreturn err;\r\nchip->sample_rate = runtime->rate;\r\nerr = lola_set_stream_config(chip, str, runtime->channels);\r\nif (err < 0)\r\nreturn err;\r\nerr = lola_setup_controller(chip, pcm, str);\r\nif (err < 0) {\r\nlola_stream_reset(chip, str);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lola_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct lola *chip = snd_pcm_substream_chip(substream);\r\nstruct lola_stream *str;\r\nstruct snd_pcm_substream *s;\r\nunsigned int start;\r\nunsigned int tstamp;\r\nbool sync_streams;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nstart = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nstart = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsync_streams = (start && snd_pcm_stream_linked(substream));\r\ntstamp = lola_get_tstamp(chip, !sync_streams);\r\nspin_lock(&chip->reg_lock);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nstr = lola_get_stream(s);\r\nif (start)\r\nlola_stream_start(chip, str, tstamp);\r\nelse\r\nlola_stream_stop(chip, str, tstamp);\r\nstr->running = start;\r\nstr->paused = !start;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t lola_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct lola *chip = snd_pcm_substream_chip(substream);\r\nstruct lola_stream *str = lola_get_stream(substream);\r\nunsigned int pos = lola_dsd_read(chip, str->dsd, LPIB);\r\nif (pos >= str->bufsize)\r\npos = 0;\r\nreturn bytes_to_frames(substream->runtime, pos);\r\n}\r\nvoid lola_pcm_update(struct lola *chip, struct lola_pcm *pcm, unsigned int bits)\r\n{\r\nint i;\r\nfor (i = 0; bits && i < pcm->num_streams; i++) {\r\nif (bits & (1 << i)) {\r\nstruct lola_stream *str = &pcm->streams[i];\r\nif (str->substream && str->running)\r\nsnd_pcm_period_elapsed(str->substream);\r\nbits &= ~(1 << i);\r\n}\r\n}\r\n}\r\nint lola_create_pcm(struct lola *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint i, err;\r\nfor (i = 0; i < 2; i++) {\r\nerr = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nPAGE_SIZE, &chip->pcm[i].bdl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_pcm_new(chip->card, "Digigram Lola", 0,\r\nchip->pcm[SNDRV_PCM_STREAM_PLAYBACK].num_streams,\r\nchip->pcm[SNDRV_PCM_STREAM_CAPTURE].num_streams,\r\n&pcm);\r\nif (err < 0)\r\nreturn err;\r\nstrlcpy(pcm->name, "Digigram Lola", sizeof(pcm->name));\r\npcm->private_data = chip;\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->pcm[i].num_streams)\r\nsnd_pcm_set_ops(pcm, i, &lola_pcm_ops);\r\n}\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n1024 * 64, 32 * 1024 * 1024);\r\nreturn 0;\r\n}\r\nvoid lola_free_pcm(struct lola *chip)\r\n{\r\nsnd_dma_free_pages(&chip->pcm[0].bdl);\r\nsnd_dma_free_pages(&chip->pcm[1].bdl);\r\n}\r\nstatic int lola_init_stream(struct lola *chip, struct lola_stream *str,\r\nint idx, int nid, int dir)\r\n{\r\nunsigned int val;\r\nint err;\r\nstr->nid = nid;\r\nstr->index = idx;\r\nstr->dsd = idx;\r\nif (dir == PLAY)\r\nstr->dsd += MAX_STREAM_IN_COUNT;\r\nerr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);\r\nreturn err;\r\n}\r\nif (dir == PLAY) {\r\nif ((val & 0x00f00dff) != 0x00000010) {\r\ndev_err(chip->card->dev,\r\n"Invalid wcaps 0x%x for 0x%x\n",\r\nval, nid);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif ((val & 0x00f00cff) != 0x00100010) {\r\ndev_err(chip->card->dev,\r\n"Invalid wcaps 0x%x for 0x%x\n",\r\nval, nid);\r\nreturn -EINVAL;\r\n}\r\nif ((val & 0x00001200) == 0x00001200)\r\nchip->input_src_caps_mask |= (1 << idx);\r\n}\r\nerr = lola_read_param(chip, nid, LOLA_PAR_STREAM_FORMATS, &val);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "Can't read FORMATS 0x%x\n", nid);\r\nreturn err;\r\n}\r\nval &= 3;\r\nif (val == 3)\r\nstr->can_float = true;\r\nif (!(val & 1)) {\r\ndev_err(chip->card->dev,\r\n"Invalid formats 0x%x for 0x%x", val, nid);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint lola_init_pcm(struct lola *chip, int dir, int *nidp)\r\n{\r\nstruct lola_pcm *pcm = &chip->pcm[dir];\r\nint i, nid, err;\r\nnid = *nidp;\r\nfor (i = 0; i < pcm->num_streams; i++, nid++) {\r\nerr = lola_init_stream(chip, &pcm->streams[i], i, nid, dir);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n*nidp = nid;\r\nreturn 0;\r\n}
