static void arcfour_init(struct arc4context *parc4ctx, u8 *key, u32 key_len)\r\n{\r\nu32 t, u;\r\nu32 keyindex;\r\nu32 stateindex;\r\nu8 *state;\r\nu32 counter;\r\nstate = parc4ctx->state;\r\nparc4ctx->x = 0;\r\nparc4ctx->y = 0;\r\nfor (counter = 0; counter < 256; counter++)\r\nstate[counter] = (u8)counter;\r\nkeyindex = 0;\r\nstateindex = 0;\r\nfor (counter = 0; counter < 256; counter++) {\r\nt = state[counter];\r\nstateindex = (stateindex + key[keyindex] + t) & 0xff;\r\nu = state[stateindex];\r\nstate[stateindex] = (u8)t;\r\nstate[counter] = (u8)u;\r\nif (++keyindex >= key_len)\r\nkeyindex = 0;\r\n}\r\n}\r\nstatic u32 arcfour_byte(struct arc4context *parc4ctx)\r\n{\r\nu32 x;\r\nu32 y;\r\nu32 sx, sy;\r\nu8 *state;\r\nstate = parc4ctx->state;\r\nx = (parc4ctx->x + 1) & 0xff;\r\nsx = state[x];\r\ny = (sx + parc4ctx->y) & 0xff;\r\nsy = state[y];\r\nparc4ctx->x = x;\r\nparc4ctx->y = y;\r\nstate[y] = (u8)sx;\r\nstate[x] = (u8)sy;\r\nreturn state[(sx + sy) & 0xff];\r\n}\r\nstatic void arcfour_encrypt(struct arc4context *parc4ctx, u8 *dest,\r\nu8 *src, u32 len)\r\n{\r\nu32 i;\r\nfor (i = 0; i < len; i++)\r\ndest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);\r\n}\r\nstatic u8 crc32_reverseBit(u8 data)\r\n{\r\nu8 retval = ((data << 7) & 0x80) | ((data << 5) & 0x40) |\r\n((data << 3) & 0x20) | ((data << 1) & 0x10) |\r\n((data >> 1) & 0x08) | ((data >> 3) & 0x04) |\r\n((data >> 5) & 0x02) | ((data >> 7) & 0x01);\r\nreturn retval;\r\n}\r\nstatic void crc32_init(void)\r\n{\r\nint i, j;\r\nu32 c;\r\nu8 *p, *p1;\r\nu8 k;\r\nif (bcrc32initialized == 1)\r\nreturn;\r\np = (u8 *) &c;\r\nc = 0x12340000;\r\nfor (i = 0; i < 256; ++i) {\r\nk = crc32_reverseBit((u8)i);\r\nfor (c = ((u32)k) << 24, j = 8; j > 0; --j)\r\nc = c & 0x80000000 ? (c << 1) ^ CRC32_POLY : (c << 1);\r\np1 = (u8 *)&crc32_table[i];\r\np1[0] = crc32_reverseBit(p[3]);\r\np1[1] = crc32_reverseBit(p[2]);\r\np1[2] = crc32_reverseBit(p[1]);\r\np1[3] = crc32_reverseBit(p[0]);\r\n}\r\nbcrc32initialized = 1;\r\n}\r\nstatic u32 getcrc32(u8 *buf, int len)\r\n{\r\nu8 *p;\r\nu32 crc;\r\nif (bcrc32initialized == 0)\r\ncrc32_init();\r\ncrc = 0xffffffff;\r\nfor (p = buf; len > 0; ++p, --len)\r\ncrc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);\r\nreturn ~crc;\r\n}\r\nvoid rtw_wep_encrypt23a(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\n__le32 crc;\r\nstruct arc4context mycontext;\r\nint curfragnum, length, index;\r\nu32 keylength;\r\nu8 *pframe, *payload, *iv;\r\nu8 wepkey[16];\r\nu8 hw_hdr_offset = 0;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nif (!pxmitframe->buf_addr)\r\nreturn;\r\nhw_hdr_offset = TXDESC_OFFSET;\r\npframe = pxmitframe->buf_addr + hw_hdr_offset;\r\nif (pattrib->encrypt != WLAN_CIPHER_SUITE_WEP40 &&\r\npattrib->encrypt != WLAN_CIPHER_SUITE_WEP104)\r\nreturn;\r\nindex = psecuritypriv->dot11PrivacyKeyIndex;\r\nkeylength = psecuritypriv->wep_key[index].keylen;\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags ; curfragnum++) {\r\niv = pframe + pattrib->hdrlen;\r\nmemcpy(&wepkey[0], iv, 3);\r\nmemcpy(&wepkey[3], &psecuritypriv->wep_key[index].key,\r\nkeylength);\r\npayload = pframe + pattrib->iv_len + pattrib->hdrlen;\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz - pattrib->hdrlen -\r\npattrib->iv_len - pattrib->icv_len;\r\ncrc = cpu_to_le32(getcrc32(payload, length));\r\narcfour_init(&mycontext, wepkey, 3 + keylength);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload + length,\r\n(char *)&crc, 4);\r\n} else {\r\nlength = pxmitpriv->frag_len - pattrib->hdrlen -\r\npattrib->iv_len - pattrib->icv_len;\r\ncrc = cpu_to_le32(getcrc32(payload, length));\r\narcfour_init(&mycontext, wepkey, 3 + keylength);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload + length,\r\n(char *)&crc, 4);\r\npframe += pxmitpriv->frag_len;\r\npframe = PTR_ALIGN(pframe, 4);\r\n}\r\n}\r\n}\r\nvoid rtw_wep_decrypt23a(struct rtw_adapter *padapter,\r\nstruct recv_frame *precvframe)\r\n{\r\nu32 actual_crc, expected_crc;\r\nstruct arc4context mycontext;\r\nint length;\r\nu32 keylength;\r\nu8 *pframe, *payload, *iv, wepkey[16];\r\nu8 keyindex;\r\nstruct rx_pkt_attrib *prxattrib = &precvframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct sk_buff *skb = precvframe->pkt;\r\npframe = skb->data;\r\nif (prxattrib->encrypt != WLAN_CIPHER_SUITE_WEP40 &&\r\nprxattrib->encrypt != WLAN_CIPHER_SUITE_WEP104)\r\nreturn;\r\niv = pframe + prxattrib->hdrlen;\r\nkeyindex = prxattrib->key_index;\r\nkeylength = psecuritypriv->wep_key[keyindex].keylen;\r\nmemcpy(&wepkey[0], iv, 3);\r\nmemcpy(&wepkey[3], &psecuritypriv->wep_key[keyindex].key, keylength);\r\nlength = skb->len - prxattrib->hdrlen - prxattrib->iv_len;\r\npayload = pframe + prxattrib->iv_len + prxattrib->hdrlen;\r\narcfour_init(&mycontext, wepkey, 3 + keylength);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\nactual_crc = getcrc32(payload, length - 4);\r\nexpected_crc = get_unaligned_le32(&payload[length - 4]);\r\nif (actual_crc != expected_crc) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s:icv CRC mismatch: "\r\n"actual: %08x, expected: %08x\n",\r\n__func__, actual_crc, expected_crc);\r\n}\r\n}\r\nstatic u32 secmicgetuint32(u8 *p)\r\n{\r\ns32 i;\r\nu32 res = 0;\r\nfor (i = 0; i < 4; i++)\r\nres |= ((u32)(*p++)) << (8 * i);\r\nreturn res;\r\n}\r\nstatic void secmicputuint32(u8 *p, u32 val)\r\n{\r\nlong i;\r\nfor (i = 0; i < 4; i++) {\r\n*p++ = (u8) (val & 0xff);\r\nval >>= 8;\r\n}\r\n}\r\nstatic void secmicclear(struct mic_data *pmicdata)\r\n{\r\npmicdata->L = pmicdata->K0;\r\npmicdata->R = pmicdata->K1;\r\npmicdata->nBytesInM = 0;\r\npmicdata->M = 0;\r\n}\r\nvoid rtw_secmicsetkey23a(struct mic_data *pmicdata, u8 *key)\r\n{\r\npmicdata->K0 = secmicgetuint32(key);\r\npmicdata->K1 = secmicgetuint32(key + 4);\r\nsecmicclear(pmicdata);\r\n}\r\nvoid rtw_secmicappend23abyte23a(struct mic_data *pmicdata, u8 b)\r\n{\r\npmicdata->M |= ((unsigned long)b) << (8 * pmicdata->nBytesInM);\r\npmicdata->nBytesInM++;\r\nif (pmicdata->nBytesInM >= 4) {\r\npmicdata->L ^= pmicdata->M;\r\npmicdata->R ^= ROL32(pmicdata->L, 17);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) | ((pmicdata->L & 0x00ff00ff) << 8);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ROL32(pmicdata->L, 3);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ROR32(pmicdata->L, 2);\r\npmicdata->L += pmicdata->R;\r\npmicdata->M = 0;\r\npmicdata->nBytesInM = 0;\r\n}\r\n}\r\nvoid rtw_secmicappend23a(struct mic_data *pmicdata, u8 *src, u32 nbytes)\r\n{\r\nwhile (nbytes > 0) {\r\nrtw_secmicappend23abyte23a(pmicdata, *src++);\r\nnbytes--;\r\n}\r\n}\r\nvoid rtw_secgetmic23a(struct mic_data *pmicdata, u8 *dst)\r\n{\r\nrtw_secmicappend23abyte23a(pmicdata, 0x5a);\r\nrtw_secmicappend23abyte23a(pmicdata, 0);\r\nrtw_secmicappend23abyte23a(pmicdata, 0);\r\nrtw_secmicappend23abyte23a(pmicdata, 0);\r\nrtw_secmicappend23abyte23a(pmicdata, 0);\r\nwhile (pmicdata->nBytesInM != 0)\r\nrtw_secmicappend23abyte23a(pmicdata, 0);\r\nsecmicputuint32(dst, pmicdata->L);\r\nsecmicputuint32(dst + 4, pmicdata->R);\r\nsecmicclear(pmicdata);\r\n}\r\nvoid rtw_seccalctkipmic23a(u8 *key, u8 *header, u8 *data, u32 data_len,\r\nu8 *mic_code, u8 pri)\r\n{\r\nstruct mic_data micdata;\r\nu8 priority[4] = {0x0, 0x0, 0x0, 0x0};\r\nrtw_secmicsetkey23a(&micdata, key);\r\npriority[0] = pri;\r\nif (header[1]&1) {\r\nrtw_secmicappend23a(&micdata, &header[16], 6);\r\nif (header[1]&2)\r\nrtw_secmicappend23a(&micdata, &header[24], 6);\r\nelse\r\nrtw_secmicappend23a(&micdata, &header[10], 6);\r\n} else {\r\nrtw_secmicappend23a(&micdata, &header[4], 6);\r\nif (header[1]&2)\r\nrtw_secmicappend23a(&micdata, &header[16], 6);\r\nelse\r\nrtw_secmicappend23a(&micdata, &header[10], 6);\r\n}\r\nrtw_secmicappend23a(&micdata, &priority[0], 4);\r\nrtw_secmicappend23a(&micdata, data, data_len);\r\nrtw_secgetmic23a(&micdata, mic_code);\r\n}\r\nstatic void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)\r\n{\r\nint i;\r\np1k[0] = Lo16(iv32);\r\np1k[1] = Hi16(iv32);\r\np1k[2] = Mk16(ta[1], ta[0]);\r\np1k[3] = Mk16(ta[3], ta[2]);\r\np1k[4] = Mk16(ta[5], ta[4]);\r\nfor (i = 0; i < PHASE1_LOOP_CNT; i++) {\r\np1k[0] += _S_(p1k[4] ^ TK16((i & 1) + 0));\r\np1k[1] += _S_(p1k[0] ^ TK16((i & 1) + 2));\r\np1k[2] += _S_(p1k[1] ^ TK16((i & 1) + 4));\r\np1k[3] += _S_(p1k[2] ^ TK16((i & 1) + 6));\r\np1k[4] += _S_(p1k[3] ^ TK16((i & 1) + 0));\r\np1k[4] += (unsigned short) i;\r\n}\r\n}\r\nstatic void phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16)\r\n{\r\nint i;\r\nu16 PPK[6];\r\nfor (i = 0; i < 5; i++)\r\nPPK[i] = p1k[i];\r\nPPK[5] = p1k[4] + iv16;\r\nPPK[0] += _S_(PPK[5] ^ TK16(0));\r\nPPK[1] += _S_(PPK[0] ^ TK16(1));\r\nPPK[2] += _S_(PPK[1] ^ TK16(2));\r\nPPK[3] += _S_(PPK[2] ^ TK16(3));\r\nPPK[4] += _S_(PPK[3] ^ TK16(4));\r\nPPK[5] += _S_(PPK[4] ^ TK16(5));\r\nPPK[0] += RotR1(PPK[5] ^ TK16(6));\r\nPPK[1] += RotR1(PPK[0] ^ TK16(7));\r\nPPK[2] += RotR1(PPK[1]);\r\nPPK[3] += RotR1(PPK[2]);\r\nPPK[4] += RotR1(PPK[3]);\r\nPPK[5] += RotR1(PPK[4]);\r\nrc4key[0] = Hi8(iv16);\r\nrc4key[1] = (Hi8(iv16) | 0x20) & 0x7F;\r\nrc4key[2] = Lo8(iv16);\r\nrc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);\r\nfor (i = 0; i < 6; i++) {\r\nrc4key[4 + 2 * i] = Lo8(PPK[i]);\r\nrc4key[5 + 2 * i] = Hi8(PPK[i]);\r\n}\r\n}\r\nint rtw_tkip_encrypt23a(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nu16 pnl;\r\nu32 pnh;\r\nu8 rc4key[16];\r\nu8 ttkey[16];\r\n__le32 crc;\r\nu8 hw_hdr_offset = 0;\r\nstruct arc4context mycontext;\r\nint curfragnum, length;\r\nu8 *pframe, *payload, *iv, *prwskey;\r\nunion pn48 dot11txpn;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nint res = _SUCCESS;\r\nif (pattrib->encrypt != WLAN_CIPHER_SUITE_TKIP)\r\nreturn _FAIL;\r\nif (!pxmitframe->buf_addr)\r\nreturn _FAIL;\r\nhw_hdr_offset = TXDESC_OFFSET;\r\npframe = pxmitframe->buf_addr + hw_hdr_offset;\r\nif (pattrib->psta)\r\nstainfo = pattrib->psta;\r\nelse {\r\nDBG_8723A("%s, call rtw_get_stainfo()\n", __func__);\r\nstainfo = rtw_get_stainfo23a(&padapter->stapriv,\r\n&pattrib->ra[0]);\r\n}\r\nif (!stainfo) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo == NULL!!!\n", __func__);\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nreturn _FAIL;\r\n}\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo!= NULL!!!\n", __func__);\r\nif (!(stainfo->state & _FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);\r\nreturn _FAIL;\r\n}\r\nif (is_multicast_ether_addr(pattrib->ra))\r\nprwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;\r\nelse\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {\r\niv = pframe + pattrib->hdrlen;\r\npayload = pframe + pattrib->iv_len + pattrib->hdrlen;\r\nGET_TKIP_PN(iv, dot11txpn);\r\npnl = (u16)(dot11txpn.val);\r\npnh = (u32)(dot11txpn.val>>16);\r\nphase1((u16 *)&ttkey[0], prwskey, &pattrib->ta[0], pnh);\r\nphase2(&rc4key[0], prwskey, (u16 *)&ttkey[0], pnl);\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = (pattrib->last_txcmdsz -\r\npattrib->hdrlen -\r\npattrib->iv_len -\r\npattrib->icv_len);\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_info_,\r\n"pattrib->iv_len =%x, pattrib->icv_len =%x\n",\r\npattrib->iv_len,\r\npattrib->icv_len);\r\ncrc = cpu_to_le32(getcrc32(payload, length));\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload + length,\r\n(char *)&crc, 4);\r\n} else {\r\nlength = (pxmitpriv->frag_len -\r\npattrib->hdrlen -\r\npattrib->iv_len -\r\npattrib->icv_len);\r\ncrc = cpu_to_le32(getcrc32(payload, length));\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload + length,\r\n(char *)&crc, 4);\r\npframe += pxmitpriv->frag_len;\r\npframe = PTR_ALIGN(pframe, 4);\r\n}\r\n}\r\nreturn res;\r\n}\r\nint rtw_tkip_decrypt23a(struct rtw_adapter *padapter,\r\nstruct recv_frame *precvframe)\r\n{\r\nu16 pnl;\r\nu32 pnh;\r\nu8 rc4key[16];\r\nu8 ttkey[16];\r\nu32 actual_crc, expected_crc;\r\nstruct arc4context mycontext;\r\nint length;\r\nu8 *pframe, *payload, *iv, *prwskey;\r\nunion pn48 dot11txpn;\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &precvframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct sk_buff *skb = precvframe->pkt;\r\nint res = _SUCCESS;\r\nif (prxattrib->encrypt != WLAN_CIPHER_SUITE_TKIP)\r\nreturn _FAIL;\r\npframe = skb->data;\r\nstainfo = rtw_get_stainfo23a(&padapter->stapriv,\r\n&prxattrib->ta[0]);\r\nif (!stainfo) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo == NULL!!!\n", __func__);\r\nreturn _FAIL;\r\n}\r\nif (is_multicast_ether_addr(prxattrib->ra)) {\r\nif (psecuritypriv->binstallGrpkey == 0) {\r\nres = _FAIL;\r\nDBG_8723A("%s:rx bc/mc packets, but didn't install group key!!!!!!!!!!\n", __func__);\r\ngoto exit;\r\n}\r\nprwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;\r\n} else {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo!= NULL!!!\n", __func__);\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\n}\r\niv = pframe + prxattrib->hdrlen;\r\npayload = pframe + prxattrib->iv_len + prxattrib->hdrlen;\r\nlength = skb->len - prxattrib->hdrlen - prxattrib->iv_len;\r\nGET_TKIP_PN(iv, dot11txpn);\r\npnl = (u16)(dot11txpn.val);\r\npnh = (u32)(dot11txpn.val>>16);\r\nphase1((u16 *)&ttkey[0], prwskey, &prxattrib->ta[0], pnh);\r\nphase2(&rc4key[0], prwskey, (unsigned short *)&ttkey[0], pnl);\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\nactual_crc = getcrc32(payload, length - 4);\r\nexpected_crc = get_unaligned_le32(&payload[length - 4]);\r\nif (actual_crc != expected_crc) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s:icv CRC mismatch: "\r\n"actual: %08x, expected: %08x\n",\r\n__func__, actual_crc, expected_crc);\r\nres = _FAIL;\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nstatic void xor_128(u8 *a, u8 *b, u8 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = a[i] ^ b[i];\r\n}\r\nstatic void xor_32(u8 *a, u8 *b, u8 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nout[i] = a[i] ^ b[i];\r\n}\r\nstatic u8 sbox(u8 a)\r\n{\r\nreturn sbox_table[(int)a];\r\n}\r\nstatic void next_key(u8 *key, int round)\r\n{\r\nu8 rcon;\r\nu8 sbox_key[4];\r\nu8 rcon_table[12] = {\r\n0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,\r\n0x1b, 0x36, 0x36, 0x36\r\n};\r\nsbox_key[0] = sbox(key[13]);\r\nsbox_key[1] = sbox(key[14]);\r\nsbox_key[2] = sbox(key[15]);\r\nsbox_key[3] = sbox(key[12]);\r\nrcon = rcon_table[round];\r\nxor_32(&key[0], sbox_key, &key[0]);\r\nkey[0] = key[0] ^ rcon;\r\nxor_32(&key[4], &key[0], &key[4]);\r\nxor_32(&key[8], &key[4], &key[8]);\r\nxor_32(&key[12], &key[8], &key[12]);\r\n}\r\nstatic void byte_sub(u8 *in, u8 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = sbox(in[i]);\r\n}\r\nstatic void shift_row(u8 *in, u8 *out)\r\n{\r\nout[0] = in[0];\r\nout[1] = in[5];\r\nout[2] = in[10];\r\nout[3] = in[15];\r\nout[4] = in[4];\r\nout[5] = in[9];\r\nout[6] = in[14];\r\nout[7] = in[3];\r\nout[8] = in[8];\r\nout[9] = in[13];\r\nout[10] = in[2];\r\nout[11] = in[7];\r\nout[12] = in[12];\r\nout[13] = in[1];\r\nout[14] = in[6];\r\nout[15] = in[11];\r\n}\r\nstatic void mix_column(u8 *in, u8 *out)\r\n{\r\nint i;\r\nu8 add1b[4];\r\nu8 add1bf7[4];\r\nu8 rotl[4];\r\nu8 swap_halfs[4];\r\nu8 andf7[4];\r\nu8 rotr[4];\r\nu8 temp[4];\r\nu8 tempb[4];\r\nfor (i = 0; i < 4; i++) {\r\nif ((in[i] & 0x80) == 0x80)\r\nadd1b[i] = 0x1b;\r\nelse\r\nadd1b[i] = 0x00;\r\n}\r\nswap_halfs[0] = in[2];\r\nswap_halfs[1] = in[3];\r\nswap_halfs[2] = in[0];\r\nswap_halfs[3] = in[1];\r\nrotl[0] = in[3];\r\nrotl[1] = in[0];\r\nrotl[2] = in[1];\r\nrotl[3] = in[2];\r\nandf7[0] = in[0] & 0x7f;\r\nandf7[1] = in[1] & 0x7f;\r\nandf7[2] = in[2] & 0x7f;\r\nandf7[3] = in[3] & 0x7f;\r\nfor (i = 3; i > 0; i--) {\r\nandf7[i] = andf7[i] << 1;\r\nif ((andf7[i - 1] & 0x80) == 0x80)\r\nandf7[i] = (andf7[i] | 0x01);\r\n}\r\nandf7[0] = andf7[0] << 1;\r\nandf7[0] = andf7[0] & 0xfe;\r\nxor_32(add1b, andf7, add1bf7);\r\nxor_32(in, add1bf7, rotr);\r\ntemp[0] = rotr[0];\r\nrotr[0] = rotr[1];\r\nrotr[1] = rotr[2];\r\nrotr[2] = rotr[3];\r\nrotr[3] = temp[0];\r\nxor_32(add1bf7, rotr, temp);\r\nxor_32(swap_halfs, rotl, tempb);\r\nxor_32(temp, tempb, out);\r\n}\r\nstatic void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)\r\n{\r\nint round;\r\nint i;\r\nu8 intermediatea[16];\r\nu8 intermediateb[16];\r\nu8 round_key[16];\r\nfor (i = 0; i < 16; i++)\r\nround_key[i] = key[i];\r\nfor (round = 0; round < 11; round++) {\r\nif (round == 0) {\r\nxor_128(round_key, data, ciphertext);\r\nnext_key(round_key, round);\r\n} else if (round == 10) {\r\nbyte_sub(ciphertext, intermediatea);\r\nshift_row(intermediatea, intermediateb);\r\nxor_128(intermediateb, round_key, ciphertext);\r\n} else {\r\nbyte_sub(ciphertext, intermediatea);\r\nshift_row(intermediatea, intermediateb);\r\nmix_column(&intermediateb[0], &intermediatea[0]);\r\nmix_column(&intermediateb[4], &intermediatea[4]);\r\nmix_column(&intermediateb[8], &intermediatea[8]);\r\nmix_column(&intermediateb[12], &intermediatea[12]);\r\nxor_128(intermediatea, round_key, ciphertext);\r\nnext_key(round_key, round);\r\n}\r\n}\r\n}\r\nstatic void construct_mic_iv(u8 *mic_iv, int qc_exists, int a4_exists, u8 *mpdu,\r\nuint payload_length, u8 *pn_vector)\r\n{\r\nint i;\r\nmic_iv[0] = 0x59;\r\nif (qc_exists && a4_exists)\r\nmic_iv[1] = mpdu[30] & 0x0f;\r\nif (qc_exists && !a4_exists)\r\nmic_iv[1] = mpdu[24] & 0x0f;\r\nif (!qc_exists)\r\nmic_iv[1] = 0x00;\r\nfor (i = 2; i < 8; i++)\r\nmic_iv[i] = mpdu[i + 8];\r\nfor (i = 8; i < 14; i++)\r\nmic_iv[i] = pn_vector[13 - i];\r\nmic_iv[14] = (unsigned char)(payload_length / 256);\r\nmic_iv[15] = (unsigned char)(payload_length % 256);\r\n}\r\nstatic void construct_mic_header1(u8 *mic_header1, int header_length, u8 *mpdu)\r\n{\r\nmic_header1[0] = (u8)((header_length - 2) / 256);\r\nmic_header1[1] = (u8)((header_length - 2) % 256);\r\nmic_header1[2] = mpdu[0] & 0xcf;\r\nmic_header1[3] = mpdu[1] & 0xc7;\r\nmic_header1[4] = mpdu[4];\r\nmic_header1[5] = mpdu[5];\r\nmic_header1[6] = mpdu[6];\r\nmic_header1[7] = mpdu[7];\r\nmic_header1[8] = mpdu[8];\r\nmic_header1[9] = mpdu[9];\r\nmic_header1[10] = mpdu[10];\r\nmic_header1[11] = mpdu[11];\r\nmic_header1[12] = mpdu[12];\r\nmic_header1[13] = mpdu[13];\r\nmic_header1[14] = mpdu[14];\r\nmic_header1[15] = mpdu[15];\r\n}\r\nstatic void construct_mic_header2(u8 *mic_header2, u8 *mpdu, int a4_exists,\r\nint qc_exists)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nmic_header2[i] = 0x00;\r\nmic_header2[0] = mpdu[16];\r\nmic_header2[1] = mpdu[17];\r\nmic_header2[2] = mpdu[18];\r\nmic_header2[3] = mpdu[19];\r\nmic_header2[4] = mpdu[20];\r\nmic_header2[5] = mpdu[21];\r\nmic_header2[6] = 0x00;\r\nmic_header2[7] = 0x00;\r\nif (!qc_exists && a4_exists) {\r\nfor (i = 0; i < 6; i++)\r\nmic_header2[8+i] = mpdu[24+i];\r\n}\r\nif (qc_exists && !a4_exists) {\r\nmic_header2[8] = mpdu[24] & 0x0f;\r\nmic_header2[9] = mpdu[25] & 0x00;\r\n}\r\nif (qc_exists && a4_exists) {\r\nfor (i = 0; i < 6; i++)\r\nmic_header2[8+i] = mpdu[24+i];\r\nmic_header2[14] = mpdu[30] & 0x0f;\r\nmic_header2[15] = mpdu[31] & 0x00;\r\n}\r\n}\r\nstatic void construct_ctr_preload(u8 *ctr_preload, int a4_exists, int qc_exists,\r\nu8 *mpdu, u8 *pn_vector, int c)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < 16; i++)\r\nctr_preload[i] = 0x00;\r\ni = 0;\r\nctr_preload[0] = 0x01;\r\nif (qc_exists && a4_exists)\r\nctr_preload[1] = mpdu[30] & 0x0f;\r\nif (qc_exists && !a4_exists)\r\nctr_preload[1] = mpdu[24] & 0x0f;\r\nfor (i = 2; i < 8; i++)\r\nctr_preload[i] = mpdu[i + 8];\r\nfor (i = 8; i < 14; i++)\r\nctr_preload[i] = pn_vector[13 - i];\r\nctr_preload[14] = (unsigned char) (c / 256);\r\nctr_preload[15] = (unsigned char) (c % 256);\r\n}\r\nstatic void bitwise_xor(u8 *ina, u8 *inb, u8 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = ina[i] ^ inb[i];\r\n}\r\nstatic int aes_cipher(u8 *key, uint hdrlen, u8 *pframe, uint plen)\r\n{\r\nuint qc_exists, a4_exists, i, j, payload_remainder,\r\nnum_blocks, payload_index;\r\nu8 pn_vector[6];\r\nu8 mic_iv[16];\r\nu8 mic_header1[16];\r\nu8 mic_header2[16];\r\nu8 ctr_preload[16];\r\nu8 chain_buffer[16];\r\nu8 aes_out[16];\r\nu8 padded_buffer[16];\r\nu8 mic[8];\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)pframe;\r\nu16 frsubtype = le16_to_cpu(hdr->frame_control) & IEEE80211_FCTL_STYPE;\r\nmemset((void *)mic_iv, 0, 16);\r\nmemset((void *)mic_header1, 0, 16);\r\nmemset((void *)mic_header2, 0, 16);\r\nmemset((void *)ctr_preload, 0, 16);\r\nmemset((void *)chain_buffer, 0, 16);\r\nmemset((void *)aes_out, 0, 16);\r\nmemset((void *)padded_buffer, 0, 16);\r\nif ((hdrlen == sizeof(struct ieee80211_hdr_3addr) ||\r\n(hdrlen == sizeof(struct ieee80211_qos_hdr))))\r\na4_exists = 0;\r\nelse\r\na4_exists = 1;\r\nif (ieee80211_is_data(hdr->frame_control)) {\r\nif ((frsubtype == IEEE80211_STYPE_DATA_CFACK) ||\r\n(frsubtype == IEEE80211_STYPE_DATA_CFPOLL) ||\r\n(frsubtype == IEEE80211_STYPE_DATA_CFACKPOLL)) {\r\nqc_exists = 1;\r\nif (hdrlen != sizeof(struct ieee80211_qos_hdr))\r\nhdrlen += 2;\r\n} else if ((frsubtype == IEEE80211_STYPE_QOS_DATA) ||\r\n(frsubtype == IEEE80211_STYPE_QOS_DATA_CFACK) ||\r\n(frsubtype == IEEE80211_STYPE_QOS_DATA_CFPOLL) ||\r\n(frsubtype == IEEE80211_STYPE_QOS_DATA_CFACKPOLL)) {\r\nif (hdrlen != sizeof(struct ieee80211_qos_hdr))\r\nhdrlen += 2;\r\nqc_exists = 1;\r\n} else {\r\nqc_exists = 0;\r\n}\r\n} else {\r\nqc_exists = 0;\r\n}\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen + 1];\r\npn_vector[2] = pframe[hdrlen + 4];\r\npn_vector[3] = pframe[hdrlen + 5];\r\npn_vector[4] = pframe[hdrlen + 6];\r\npn_vector[5] = pframe[hdrlen + 7];\r\nconstruct_mic_iv(mic_iv, qc_exists, a4_exists, pframe, plen, pn_vector);\r\nconstruct_mic_header1(mic_header1, hdrlen, pframe);\r\nconstruct_mic_header2(mic_header2, pframe, a4_exists, qc_exists);\r\npayload_remainder = plen % 16;\r\nnum_blocks = plen / 16;\r\npayload_index = hdrlen + 8;\r\naes128k128d(key, mic_iv, aes_out);\r\nbitwise_xor(aes_out, mic_header1, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nbitwise_xor(aes_out, mic_header2, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nfor (i = 0; i < num_blocks; i++) {\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\npayload_index += 16;\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nif (payload_remainder > 0) {\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index++];\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nfor (j = 0; j < 8; j++)\r\nmic[j] = aes_out[j];\r\nfor (j = 0; j < 8; j++)\r\npframe[payload_index + j] = mic[j];\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\npframe, pn_vector, i + 1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe,\r\npn_vector, num_blocks + 1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index + j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe,\r\npn_vector, 0);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < 8; j++)\r\npadded_buffer[j] = pframe[j + hdrlen + 8 + plen];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < 8; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\nreturn _SUCCESS;\r\n}\r\nint rtw_aes_encrypt23a(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nint curfragnum, length;\r\nu8 *pframe, *prwskey;\r\nu8 hw_hdr_offset = 0;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nint res = _SUCCESS;\r\nif (!pxmitframe->buf_addr)\r\nreturn _FAIL;\r\nhw_hdr_offset = TXDESC_OFFSET;\r\npframe = pxmitframe->buf_addr + hw_hdr_offset;\r\nif (pattrib->encrypt != WLAN_CIPHER_SUITE_CCMP)\r\nreturn _FAIL;\r\nif (pattrib->psta) {\r\nstainfo = pattrib->psta;\r\n} else {\r\nDBG_8723A("%s, call rtw_get_stainfo23a()\n", __func__);\r\nstainfo = rtw_get_stainfo23a(&padapter->stapriv, &pattrib->ra[0]);\r\n}\r\nif (!stainfo) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo == NULL!!!\n", __func__);\r\nDBG_8723A("%s, psta == NUL\n", __func__);\r\nres = _FAIL;\r\ngoto out;\r\n}\r\nif (!(stainfo->state & _FW_LINKED)) {\r\nDBG_8723A("%s, psta->state(0x%x) != _FW_LINKED\n",\r\n__func__, stainfo->state);\r\nreturn _FAIL;\r\n}\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo!= NULL!!!\n", __func__);\r\nif (is_multicast_ether_addr(pattrib->ra))\r\nprwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;\r\nelse\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz -\r\npattrib->hdrlen-pattrib->iv_len -\r\npattrib->icv_len;\r\naes_cipher(prwskey, pattrib->hdrlen, pframe, length);\r\n} else {\r\nlength = pxmitpriv->frag_len-pattrib->hdrlen -\r\npattrib->iv_len - pattrib->icv_len;\r\naes_cipher(prwskey, pattrib->hdrlen, pframe, length);\r\npframe += pxmitpriv->frag_len;\r\npframe = PTR_ALIGN(pframe, 4);\r\n}\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic int aes_decipher(u8 *key, uint hdrlen, u8 *pframe, uint plen)\r\n{\r\nstatic u8 message[MAX_MSG_SIZE];\r\nuint qc_exists, a4_exists, i, j, payload_remainder,\r\nnum_blocks, payload_index;\r\nint res = _SUCCESS;\r\nu8 pn_vector[6];\r\nu8 mic_iv[16];\r\nu8 mic_header1[16];\r\nu8 mic_header2[16];\r\nu8 ctr_preload[16];\r\nu8 chain_buffer[16];\r\nu8 aes_out[16];\r\nu8 padded_buffer[16];\r\nu8 mic[8];\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)pframe;\r\nu16 frsubtype = le16_to_cpu(hdr->frame_control) & IEEE80211_FCTL_STYPE;\r\nmemset((void *)mic_iv, 0, 16);\r\nmemset((void *)mic_header1, 0, 16);\r\nmemset((void *)mic_header2, 0, 16);\r\nmemset((void *)ctr_preload, 0, 16);\r\nmemset((void *)chain_buffer, 0, 16);\r\nmemset((void *)aes_out, 0, 16);\r\nmemset((void *)padded_buffer, 0, 16);\r\nnum_blocks = (plen - 8) / 16;\r\npayload_remainder = (plen - 8) % 16;\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen + 1];\r\npn_vector[2] = pframe[hdrlen + 4];\r\npn_vector[3] = pframe[hdrlen + 5];\r\npn_vector[4] = pframe[hdrlen + 6];\r\npn_vector[5] = pframe[hdrlen + 7];\r\nif ((hdrlen == sizeof(struct ieee80211_hdr_3addr) ||\r\n(hdrlen == sizeof(struct ieee80211_qos_hdr))))\r\na4_exists = 0;\r\nelse\r\na4_exists = 1;\r\nif (ieee80211_is_data(hdr->frame_control)) {\r\nif ((frsubtype == IEEE80211_STYPE_DATA_CFACK) ||\r\n(frsubtype == IEEE80211_STYPE_DATA_CFPOLL) ||\r\n(frsubtype == IEEE80211_STYPE_DATA_CFACKPOLL)) {\r\nqc_exists = 1;\r\nif (hdrlen != sizeof(struct ieee80211_hdr_3addr))\r\nhdrlen += 2;\r\n} else if ((frsubtype == IEEE80211_STYPE_QOS_DATA) ||\r\n(frsubtype == IEEE80211_STYPE_QOS_DATA_CFACK) ||\r\n(frsubtype == IEEE80211_STYPE_QOS_DATA_CFPOLL) ||\r\n(frsubtype == IEEE80211_STYPE_QOS_DATA_CFACKPOLL)) {\r\nif (hdrlen != sizeof(struct ieee80211_hdr_3addr))\r\nhdrlen += 2;\r\nqc_exists = 1;\r\n} else {\r\nqc_exists = 0;\r\n}\r\n} else {\r\nqc_exists = 0;\r\n}\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\npframe, pn_vector, i + 1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe,\r\npn_vector, num_blocks + 1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index + j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif ((hdrlen + plen + 8) <= MAX_MSG_SIZE)\r\nmemcpy(message, pframe, (hdrlen + plen + 8));\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen + 1];\r\npn_vector[2] = pframe[hdrlen + 4];\r\npn_vector[3] = pframe[hdrlen + 5];\r\npn_vector[4] = pframe[hdrlen + 6];\r\npn_vector[5] = pframe[hdrlen + 7];\r\nconstruct_mic_iv(mic_iv, qc_exists, a4_exists, message,\r\nplen - 8, pn_vector);\r\nconstruct_mic_header1(mic_header1, hdrlen, message);\r\nconstruct_mic_header2(mic_header2, message, a4_exists, qc_exists);\r\npayload_remainder = (plen - 8) % 16;\r\nnum_blocks = (plen - 8) / 16;\r\npayload_index = hdrlen + 8;\r\naes128k128d(key, mic_iv, aes_out);\r\nbitwise_xor(aes_out, mic_header1, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nbitwise_xor(aes_out, mic_header2, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nfor (i = 0; i < num_blocks; i++) {\r\nbitwise_xor(aes_out, &message[payload_index], chain_buffer);\r\npayload_index += 16;\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nif (payload_remainder > 0) {\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = message[payload_index++];\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nfor (j = 0 ; j < 8; j++)\r\nmic[j] = aes_out[j];\r\nfor (j = 0; j < 8; j++)\r\nmessage[payload_index + j] = mic[j];\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\nmessage, pn_vector, i + 1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &message[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\nmessage, pn_vector, num_blocks + 1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = message[payload_index + j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\n}\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, message,\r\npn_vector, 0);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < 8; j++)\r\npadded_buffer[j] = message[j + hdrlen + 8 + plen - 8];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < 8; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\nfor (i = 0; i < 8; i++) {\r\nif (pframe[hdrlen + 8 + plen - 8 + i] != message[hdrlen + 8 + plen - 8 + i]) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s:mic check error mic[%d]: pframe(%x) != message(%x)\n",\r\n__func__, i,\r\npframe[hdrlen + 8 + plen - 8 + i],\r\nmessage[hdrlen + 8 + plen - 8 + i]);\r\nDBG_8723A("%s:mic check error mic[%d]: pframe(%x) != message(%x)\n",\r\n__func__, i,\r\npframe[hdrlen + 8 + plen - 8 + i],\r\nmessage[hdrlen + 8 + plen - 8 + i]);\r\nres = _FAIL;\r\n}\r\n}\r\nreturn res;\r\n}\r\nint rtw_aes_decrypt23a(struct rtw_adapter *padapter,\r\nstruct recv_frame *precvframe)\r\n{\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &precvframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct sk_buff *skb = precvframe->pkt;\r\nint length;\r\nu8 *pframe, *prwskey;\r\nint res = _SUCCESS;\r\npframe = skb->data;\r\nif (prxattrib->encrypt != WLAN_CIPHER_SUITE_CCMP)\r\nreturn _FAIL;\r\nstainfo = rtw_get_stainfo23a(&padapter->stapriv, &prxattrib->ta[0]);\r\nif (!stainfo) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo == NULL!!!\n", __func__);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"%s: stainfo!= NULL!!!\n", __func__);\r\nif (is_multicast_ether_addr(prxattrib->ra)) {\r\nif (!psecuritypriv->binstallGrpkey) {\r\nres = _FAIL;\r\nDBG_8723A("%s:rx bc/mc packets, but didn't install "\r\n"group key!!!!!!!!!!\n", __func__);\r\ngoto exit;\r\n}\r\nprwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;\r\nif (psecuritypriv->dot118021XGrpKeyid != prxattrib->key_index) {\r\nDBG_8723A("not match packet_index =%d, install_index ="\r\n"%d\n", prxattrib->key_index,\r\npsecuritypriv->dot118021XGrpKeyid);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\n} else {\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\n}\r\nlength = skb->len - prxattrib->hdrlen - prxattrib->iv_len;\r\nres = aes_decipher(prwskey, prxattrib->hdrlen, pframe, length);\r\nexit:\r\nreturn res;\r\n}\r\nvoid rtw_use_tkipkey_handler23a(void *function_context)\r\n{\r\nstruct rtw_adapter *padapter = function_context;\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"^^^%s ^^^\n", __func__);\r\npadapter->securitypriv.busetkipkey = 1;\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n"^^^%s padapter->securitypriv.busetkipkey =%d^^^\n",\r\n__func__, padapter->securitypriv.busetkipkey);\r\n}
