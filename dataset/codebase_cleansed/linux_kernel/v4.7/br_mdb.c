static int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_port *p;\r\nstruct nlattr *nest, *port_nest;\r\nif (!br->multicast_router || hlist_empty(&br->router_list))\r\nreturn 0;\r\nnest = nla_nest_start(skb, MDBA_ROUTER);\r\nif (nest == NULL)\r\nreturn -EMSGSIZE;\r\nhlist_for_each_entry_rcu(p, &br->router_list, rlist) {\r\nif (!p)\r\ncontinue;\r\nport_nest = nla_nest_start(skb, MDBA_ROUTER_PORT);\r\nif (!port_nest)\r\ngoto fail;\r\nif (nla_put_nohdr(skb, sizeof(u32), &p->dev->ifindex) ||\r\nnla_put_u32(skb, MDBA_ROUTER_PATTR_TIMER,\r\nbr_timer_value(&p->multicast_router_timer)) ||\r\nnla_put_u8(skb, MDBA_ROUTER_PATTR_TYPE,\r\np->multicast_router)) {\r\nnla_nest_cancel(skb, port_nest);\r\ngoto fail;\r\n}\r\nnla_nest_end(skb, port_nest);\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\nfail:\r\nnla_nest_cancel(skb, nest);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void __mdb_entry_fill_flags(struct br_mdb_entry *e, unsigned char flags)\r\n{\r\ne->state = flags & MDB_PG_FLAGS_PERMANENT;\r\ne->flags = 0;\r\nif (flags & MDB_PG_FLAGS_OFFLOAD)\r\ne->flags |= MDB_FLAGS_OFFLOAD;\r\n}\r\nstatic void __mdb_entry_to_br_ip(struct br_mdb_entry *entry, struct br_ip *ip)\r\n{\r\nmemset(ip, 0, sizeof(struct br_ip));\r\nip->vid = entry->vid;\r\nip->proto = entry->addr.proto;\r\nif (ip->proto == htons(ETH_P_IP))\r\nip->u.ip4 = entry->addr.u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nip->u.ip6 = entry->addr.u.ip6;\r\n#endif\r\n}\r\nstatic int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct nlattr *nest, *nest2;\r\nint i, err = 0;\r\nint idx = 0, s_idx = cb->args[1];\r\nif (br->multicast_disabled)\r\nreturn 0;\r\nmdb = rcu_dereference(br->mdb);\r\nif (!mdb)\r\nreturn 0;\r\nnest = nla_nest_start(skb, MDBA_MDB);\r\nif (nest == NULL)\r\nreturn -EMSGSIZE;\r\nfor (i = 0; i < mdb->max; i++) {\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct net_bridge_port *port;\r\nhlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {\r\nif (idx < s_idx)\r\ngoto skip;\r\nnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\r\nif (nest2 == NULL) {\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nfor (pp = &mp->ports;\r\n(p = rcu_dereference(*pp)) != NULL;\r\npp = &p->next) {\r\nstruct nlattr *nest_ent;\r\nstruct br_mdb_entry e;\r\nport = p->port;\r\nif (!port)\r\ncontinue;\r\nmemset(&e, 0, sizeof(e));\r\ne.ifindex = port->dev->ifindex;\r\ne.vid = p->addr.vid;\r\n__mdb_entry_fill_flags(&e, p->flags);\r\nif (p->addr.proto == htons(ETH_P_IP))\r\ne.addr.u.ip4 = p->addr.u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (p->addr.proto == htons(ETH_P_IPV6))\r\ne.addr.u.ip6 = p->addr.u.ip6;\r\n#endif\r\ne.addr.proto = p->addr.proto;\r\nnest_ent = nla_nest_start(skb,\r\nMDBA_MDB_ENTRY_INFO);\r\nif (!nest_ent) {\r\nnla_nest_cancel(skb, nest2);\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nif (nla_put_nohdr(skb, sizeof(e), &e) ||\r\nnla_put_u32(skb,\r\nMDBA_MDB_EATTR_TIMER,\r\nbr_timer_value(&p->timer))) {\r\nnla_nest_cancel(skb, nest_ent);\r\nnla_nest_cancel(skb, nest2);\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nnla_nest_end(skb, nest_ent);\r\n}\r\nnla_nest_end(skb, nest2);\r\nskip:\r\nidx++;\r\n}\r\n}\r\nout:\r\ncb->args[1] = idx;\r\nnla_nest_end(skb, nest);\r\nreturn err;\r\n}\r\nstatic int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net_device *dev;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlmsghdr *nlh = NULL;\r\nint idx = 0, s_idx;\r\ns_idx = cb->args[0];\r\nrcu_read_lock();\r\ncb->seq = net->dev_base_seq + br_mdb_rehash_seq;\r\nfor_each_netdev_rcu(net, dev) {\r\nif (dev->priv_flags & IFF_EBRIDGE) {\r\nstruct br_port_msg *bpm;\r\nif (idx < s_idx)\r\ngoto skip;\r\nnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, RTM_GETMDB,\r\nsizeof(*bpm), NLM_F_MULTI);\r\nif (nlh == NULL)\r\nbreak;\r\nbpm = nlmsg_data(nlh);\r\nmemset(bpm, 0, sizeof(*bpm));\r\nbpm->ifindex = dev->ifindex;\r\nif (br_mdb_fill_info(skb, cb, dev) < 0)\r\ngoto out;\r\nif (br_rports_fill_info(skb, cb, dev) < 0)\r\ngoto out;\r\ncb->args[1] = 0;\r\nnlmsg_end(skb, nlh);\r\nskip:\r\nidx++;\r\n}\r\n}\r\nout:\r\nif (nlh)\r\nnlmsg_end(skb, nlh);\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int nlmsg_populate_mdb_fill(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nstruct br_mdb_entry *entry, u32 pid,\r\nu32 seq, int type, unsigned int flags)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct br_port_msg *bpm;\r\nstruct nlattr *nest, *nest2;\r\nnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), 0);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nbpm = nlmsg_data(nlh);\r\nmemset(bpm, 0, sizeof(*bpm));\r\nbpm->family = AF_BRIDGE;\r\nbpm->ifindex = dev->ifindex;\r\nnest = nla_nest_start(skb, MDBA_MDB);\r\nif (nest == NULL)\r\ngoto cancel;\r\nnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\r\nif (nest2 == NULL)\r\ngoto end;\r\nif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\r\ngoto end;\r\nnla_nest_end(skb, nest2);\r\nnla_nest_end(skb, nest);\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nend:\r\nnla_nest_end(skb, nest);\r\ncancel:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic inline size_t rtnl_mdb_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct br_port_msg))\r\n+ nla_total_size(sizeof(struct br_mdb_entry));\r\n}\r\nstatic void br_mdb_complete(struct net_device *dev, int err, void *priv)\r\n{\r\nstruct br_mdb_complete_info *data = priv;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port *port = data->port;\r\nstruct net_bridge *br = port->br;\r\nif (err)\r\ngoto err;\r\nspin_lock_bh(&br->multicast_lock);\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, &data->ip);\r\nif (!mp)\r\ngoto out;\r\nfor (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (p->port != port)\r\ncontinue;\r\np->flags |= MDB_PG_FLAGS_OFFLOAD;\r\n}\r\nout:\r\nspin_unlock_bh(&br->multicast_lock);\r\nerr:\r\nkfree(priv);\r\n}\r\nstatic void __br_mdb_notify(struct net_device *dev, struct net_bridge_port *p,\r\nstruct br_mdb_entry *entry, int type)\r\n{\r\nstruct br_mdb_complete_info *complete_info;\r\nstruct switchdev_obj_port_mdb mdb = {\r\n.obj = {\r\n.id = SWITCHDEV_OBJ_ID_PORT_MDB,\r\n.flags = SWITCHDEV_F_DEFER,\r\n},\r\n.vid = entry->vid,\r\n};\r\nstruct net_device *port_dev;\r\nstruct net *net = dev_net(dev);\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nport_dev = __dev_get_by_index(net, entry->ifindex);\r\nif (entry->addr.proto == htons(ETH_P_IP))\r\nip_eth_mc_map(entry->addr.u.ip4, mdb.addr);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nipv6_eth_mc_map(&entry->addr.u.ip6, mdb.addr);\r\n#endif\r\nmdb.obj.orig_dev = port_dev;\r\nif (port_dev && type == RTM_NEWMDB) {\r\ncomplete_info = kmalloc(sizeof(*complete_info), GFP_ATOMIC);\r\nif (complete_info) {\r\ncomplete_info->port = p;\r\n__mdb_entry_to_br_ip(entry, &complete_info->ip);\r\nmdb.obj.complete_priv = complete_info;\r\nmdb.obj.complete = br_mdb_complete;\r\nswitchdev_port_obj_add(port_dev, &mdb.obj);\r\n}\r\n} else if (port_dev && type == RTM_DELMDB) {\r\nswitchdev_port_obj_del(port_dev, &mdb.obj);\r\n}\r\nskb = nlmsg_new(rtnl_mdb_nlmsg_size(), GFP_ATOMIC);\r\nif (!skb)\r\ngoto errout;\r\nerr = nlmsg_populate_mdb_fill(skb, dev, entry, 0, 0, type, NTF_SELF);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nrtnl_set_sk_err(net, RTNLGRP_MDB, err);\r\n}\r\nvoid br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\r\nstruct br_ip *group, int type, u8 flags)\r\n{\r\nstruct br_mdb_entry entry;\r\nmemset(&entry, 0, sizeof(entry));\r\nentry.ifindex = port->dev->ifindex;\r\nentry.addr.proto = group->proto;\r\nentry.addr.u.ip4 = group->u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nentry.addr.u.ip6 = group->u.ip6;\r\n#endif\r\nentry.vid = group->vid;\r\n__mdb_entry_fill_flags(&entry, flags);\r\n__br_mdb_notify(dev, port, &entry, type);\r\n}\r\nstatic int nlmsg_populate_rtr_fill(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nint ifindex, u32 pid,\r\nu32 seq, int type, unsigned int flags)\r\n{\r\nstruct br_port_msg *bpm;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *nest;\r\nnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nbpm = nlmsg_data(nlh);\r\nmemset(bpm, 0, sizeof(*bpm));\r\nbpm->family = AF_BRIDGE;\r\nbpm->ifindex = dev->ifindex;\r\nnest = nla_nest_start(skb, MDBA_ROUTER);\r\nif (!nest)\r\ngoto cancel;\r\nif (nla_put_u32(skb, MDBA_ROUTER_PORT, ifindex))\r\ngoto end;\r\nnla_nest_end(skb, nest);\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nend:\r\nnla_nest_end(skb, nest);\r\ncancel:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic inline size_t rtnl_rtr_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct br_port_msg))\r\n+ nla_total_size(sizeof(__u32));\r\n}\r\nvoid br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,\r\nint type)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nint ifindex;\r\nifindex = port ? port->dev->ifindex : 0;\r\nskb = nlmsg_new(rtnl_rtr_nlmsg_size(), GFP_ATOMIC);\r\nif (!skb)\r\ngoto errout;\r\nerr = nlmsg_populate_rtr_fill(skb, dev, ifindex, 0, 0, type, NTF_SELF);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nrtnl_set_sk_err(net, RTNLGRP_MDB, err);\r\n}\r\nstatic bool is_valid_mdb_entry(struct br_mdb_entry *entry)\r\n{\r\nif (entry->ifindex == 0)\r\nreturn false;\r\nif (entry->addr.proto == htons(ETH_P_IP)) {\r\nif (!ipv4_is_multicast(entry->addr.u.ip4))\r\nreturn false;\r\nif (ipv4_is_local_multicast(entry->addr.u.ip4))\r\nreturn false;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (entry->addr.proto == htons(ETH_P_IPV6)) {\r\nif (ipv6_addr_is_ll_all_nodes(&entry->addr.u.ip6))\r\nreturn false;\r\n#endif\r\n} else\r\nreturn false;\r\nif (entry->state != MDB_PERMANENT && entry->state != MDB_TEMPORARY)\r\nreturn false;\r\nif (entry->vid >= VLAN_VID_MASK)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int br_mdb_parse(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct net_device **pdev, struct br_mdb_entry **pentry)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct br_mdb_entry *entry;\r\nstruct br_port_msg *bpm;\r\nstruct nlattr *tb[MDBA_SET_ENTRY_MAX+1];\r\nstruct net_device *dev;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*bpm), tb, MDBA_SET_ENTRY_MAX, NULL);\r\nif (err < 0)\r\nreturn err;\r\nbpm = nlmsg_data(nlh);\r\nif (bpm->ifindex == 0) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with invalid ifindex\n");\r\nreturn -EINVAL;\r\n}\r\ndev = __dev_get_by_index(net, bpm->ifindex);\r\nif (dev == NULL) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with unknown ifindex\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(dev->priv_flags & IFF_EBRIDGE)) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with non-bridge\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n*pdev = dev;\r\nif (!tb[MDBA_SET_ENTRY] ||\r\nnla_len(tb[MDBA_SET_ENTRY]) != sizeof(struct br_mdb_entry)) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with invalid attr\n");\r\nreturn -EINVAL;\r\n}\r\nentry = nla_data(tb[MDBA_SET_ENTRY]);\r\nif (!is_valid_mdb_entry(entry)) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with invalid entry\n");\r\nreturn -EINVAL;\r\n}\r\n*pentry = entry;\r\nreturn 0;\r\n}\r\nstatic int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,\r\nstruct br_ip *group, unsigned char state)\r\n{\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct net_bridge_mdb_htable *mdb;\r\nunsigned long now = jiffies;\r\nint err;\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, group);\r\nif (!mp) {\r\nmp = br_multicast_new_group(br, port, group);\r\nerr = PTR_ERR_OR_ZERO(mp);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (p->port == port)\r\nreturn -EEXIST;\r\nif ((unsigned long)p->port < (unsigned long)port)\r\nbreak;\r\n}\r\np = br_multicast_new_port_group(port, group, *pp, state);\r\nif (unlikely(!p))\r\nreturn -ENOMEM;\r\nrcu_assign_pointer(*pp, p);\r\nif (state == MDB_TEMPORARY)\r\nmod_timer(&p->timer, now + br->multicast_membership_interval);\r\nreturn 0;\r\n}\r\nstatic int __br_mdb_add(struct net *net, struct net_bridge *br,\r\nstruct br_mdb_entry *entry)\r\n{\r\nstruct br_ip ip;\r\nstruct net_device *dev;\r\nstruct net_bridge_port *p;\r\nint ret;\r\nif (!netif_running(br->dev) || br->multicast_disabled)\r\nreturn -EINVAL;\r\ndev = __dev_get_by_index(net, entry->ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\np = br_port_get_rtnl(dev);\r\nif (!p || p->br != br || p->state == BR_STATE_DISABLED)\r\nreturn -EINVAL;\r\n__mdb_entry_to_br_ip(entry, &ip);\r\nspin_lock_bh(&br->multicast_lock);\r\nret = br_mdb_add_group(br, p, &ip, entry->state);\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn ret;\r\n}\r\nstatic int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_device *dev, *pdev;\r\nstruct br_mdb_entry *entry;\r\nstruct net_bridge_port *p;\r\nstruct net_bridge_vlan *v;\r\nstruct net_bridge *br;\r\nint err;\r\nerr = br_mdb_parse(skb, nlh, &dev, &entry);\r\nif (err < 0)\r\nreturn err;\r\nbr = netdev_priv(dev);\r\npdev = __dev_get_by_index(net, entry->ifindex);\r\nif (!pdev)\r\nreturn -ENODEV;\r\np = br_port_get_rtnl(pdev);\r\nif (!p || p->br != br || p->state == BR_STATE_DISABLED)\r\nreturn -EINVAL;\r\nvg = nbp_vlan_group(p);\r\nif (br_vlan_enabled(br) && vg && entry->vid == 0) {\r\nlist_for_each_entry(v, &vg->vlan_list, vlist) {\r\nentry->vid = v->vid;\r\nerr = __br_mdb_add(net, br, entry);\r\nif (err)\r\nbreak;\r\n__br_mdb_notify(dev, p, entry, RTM_NEWMDB);\r\n}\r\n} else {\r\nerr = __br_mdb_add(net, br, entry);\r\nif (!err)\r\n__br_mdb_notify(dev, p, entry, RTM_NEWMDB);\r\n}\r\nreturn err;\r\n}\r\nstatic int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct br_ip ip;\r\nint err = -EINVAL;\r\nif (!netif_running(br->dev) || br->multicast_disabled)\r\nreturn -EINVAL;\r\n__mdb_entry_to_br_ip(entry, &ip);\r\nspin_lock_bh(&br->multicast_lock);\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, &ip);\r\nif (!mp)\r\ngoto unlock;\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (!p->port || p->port->dev->ifindex != entry->ifindex)\r\ncontinue;\r\nif (p->port->state == BR_STATE_DISABLED)\r\ngoto unlock;\r\n__mdb_entry_fill_flags(entry, p->flags);\r\nrcu_assign_pointer(*pp, p->next);\r\nhlist_del_init(&p->mglist);\r\ndel_timer(&p->timer);\r\ncall_rcu_bh(&p->rcu, br_multicast_free_pg);\r\nerr = 0;\r\nif (!mp->ports && !mp->mglist &&\r\nnetif_running(br->dev))\r\nmod_timer(&mp->timer, jiffies);\r\nbreak;\r\n}\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic int br_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_device *dev, *pdev;\r\nstruct br_mdb_entry *entry;\r\nstruct net_bridge_port *p;\r\nstruct net_bridge_vlan *v;\r\nstruct net_bridge *br;\r\nint err;\r\nerr = br_mdb_parse(skb, nlh, &dev, &entry);\r\nif (err < 0)\r\nreturn err;\r\nbr = netdev_priv(dev);\r\npdev = __dev_get_by_index(net, entry->ifindex);\r\nif (!pdev)\r\nreturn -ENODEV;\r\np = br_port_get_rtnl(pdev);\r\nif (!p || p->br != br || p->state == BR_STATE_DISABLED)\r\nreturn -EINVAL;\r\nvg = nbp_vlan_group(p);\r\nif (br_vlan_enabled(br) && vg && entry->vid == 0) {\r\nlist_for_each_entry(v, &vg->vlan_list, vlist) {\r\nentry->vid = v->vid;\r\nerr = __br_mdb_del(br, entry);\r\nif (!err)\r\n__br_mdb_notify(dev, p, entry, RTM_DELMDB);\r\n}\r\n} else {\r\nerr = __br_mdb_del(br, entry);\r\nif (!err)\r\n__br_mdb_notify(dev, p, entry, RTM_DELMDB);\r\n}\r\nreturn err;\r\n}\r\nvoid br_mdb_init(void)\r\n{\r\nrtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, br_mdb_dump, NULL);\r\nrtnl_register(PF_BRIDGE, RTM_NEWMDB, br_mdb_add, NULL, NULL);\r\nrtnl_register(PF_BRIDGE, RTM_DELMDB, br_mdb_del, NULL, NULL);\r\n}\r\nvoid br_mdb_uninit(void)\r\n{\r\nrtnl_unregister(PF_BRIDGE, RTM_GETMDB);\r\nrtnl_unregister(PF_BRIDGE, RTM_NEWMDB);\r\nrtnl_unregister(PF_BRIDGE, RTM_DELMDB);\r\n}
